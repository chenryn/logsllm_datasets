title:Publicly Verifiable Secure Cloud Storage for Dynamic Data Using Secure
Network Coding
author:Binanda Sengupta and
Sushmita Ruj
Publicly Veriﬁable Secure Cloud Storage for Dynamic Data
Using Secure Network Coding
Binanda Sengupta
Indian Statistical Institute
PI:EMAIL
Kolkata, India
ABSTRACT
Cloud service providers oﬀer storage outsourcing facility to
their clients. In a secure cloud storage (SCS) protocol, the
integrity of the client’s data is maintained. In this work, we
construct a publicly veriﬁable secure cloud storage protocol
based on a secure network coding (SNC) protocol where the
client can update the outsourced data as needed. To the
best of our knowledge, our scheme is the ﬁrst SNC-based
SCS protocol for dynamic data that is secure in the standard
model and provides privacy-preserving audits in a publicly
veriﬁable setting. Furthermore, we discuss, in details, about
the (im)possibility of providing a general construction of an
eﬃcient SCS protocol for dynamic data (DSCS protocol)
from an arbitrary SNC protocol. In addition, we modify an
existing DSCS scheme (DPDP I) in order to support privacy-
preserving audits. We also compare our DSCS protocol with
other SCS schemes (including the modiﬁed DPDP I scheme).
Finally, we ﬁgure out some limitations of an SCS scheme
constructed using an SNC protocol.
Keywords
Cloud Storage, Provable Data Possession, Dynamic Data,
Network Coding
1.
INTRODUCTION
Cloud computing has emerged as a recent technology en-
abling a device with restricted resources to delegate heavy
tasks that the device cannot perform by itself to a pow-
erful cloud server. The services a cloud server oﬀers in-
clude huge amount of computation, storage outsourcing and
many more. A smart phone, for example, having a low-
performance processor or a limited amount of storage ca-
pacity, cannot accomplish a heavy computation on its own
or cannot store a large amount of data (say, in the order of
terabytes) in its own storage. A client (cloud user) can del-
egate her computation or storage to the cloud server. Now,
she can just download the result of the computation, or she
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ASIA CCS ’16, May 30-June 03, 2016, Xi’an, China
c(cid:13) 2016 ACM. ISBN 978-1-4503-4233-9/16/05 . . . $15.00
DOI: http://dx.doi.org/10.1145/2897845.2897915
Sushmita Ruj
Indian Statistical Institute
Kolkata, India
PI:EMAIL
can read (or update) only the required portion of the up-
loaded data.
For storage outsourcing, the cloud server stores a massive
volume of data on behalf of its clients. However, a mali-
cious cloud server can delete the client’s data in order to
save some space. Thus, the client (data owner) has to have
a mechanism to check the integrity of her data outsourced to
the server. Secure cloud storage (SCS) protocols (two-party
protocols between the client and the server) provide a guar-
antee that the client’s data are stored untampered in the
server. Based on the nature of the data to be outsourced,
secure cloud storage protocols are classiﬁed as: SCS proto-
cols for static data (SSCS) and SCS protocols for dynamic
data (DSCS). For static data, the client cannot change her
data once they are uploaded to the server (suitable mostly
for backup or archival data). Dynamic data are more generic
in that the client can modify her data after the initial out-
sourcing. Some SSCS protocols include [3, 23, 36]; and some
DSCS protocols include [18, 39, 10, 37]. In SCS protocols,
the client can audit her data stored in the server without ac-
cessing the whole data ﬁle, and still, be able to detect an un-
wanted modiﬁcation of the data done by a malicious server.
The SCS protocols are publicly veriﬁable if the audits can be
performed by any third party auditor (TPA) with the knowl-
edge of public parameters only; they are privately veriﬁable
if the secret information of the client is needed to perform
audits. In privacy-preserving audits (for publicly veriﬁable
SCS protocols only), the TPA cannot gain the knowledge of
any portion of the data ﬁle.
Network coding technique [2, 25] serves as an alterna-
tive to the conventional store-and-forward routing technique
used in a communication network.
In a network coding
(NC) protocol, every intermediate node (all nodes except the
source and target nodes) in the network combines the incom-
ing packets to output another packet. The network coding
protocols enjoy much improved throughput, eﬃciency and
scalability compared to simply relaying an incoming packet
as it is. However, these protocols are susceptible to pollu-
tion attacks caused by a malicious intermediate node that
injects invalid packets in the network. These invalid pack-
ets produce more such packets downstream.
In the worst
case, the target node cannot decode the original ﬁle sent
to it via the network. Secure network coding (SNC) pro-
tocols provide countermeasures to resolve this issue using
some cryptographic primitives.
In an SNC protocol, the
source node authenticates each of the packets to be trans-
mitted through the network. For the authentication of the
packets, a small tag is attached to each packet. These tags
107are generated using homomorphic message authentication
codes (MACs) [1] or homomorphic signatures [13, 7, 19, 11].
Every intermediate node can combine the incoming packets
to output another packet along with its authentication tag.
In a recent work, Chen et al. [14] explore the relation
between a secure cloud storage (SSCS) protocol for static
data and a secure network coding (SNC) protocol. They
show that, given an SNC protocol, one can construct an
SSCS protocol using the SNC protocol. However, for static
data, the client (data owner) cannot perform any update
(insertion, deletion or modiﬁcation) eﬃciently on her data
after she uploads them to the cloud server. This constraint
makes an SSCS protocol insuﬃcient in many cloud appli-
cations where a client needs to update her data frequently.
Obviously, a naive way to update data in this scenario is to
download the whole data ﬁle, perform the required updates
and upload the ﬁle to the server again; but this procedure
is highly ineﬃcient as it requires huge amount of bandwidth
for every update. Thus, further investigations are needed
towards an eﬃcient (and more generic) construction of a se-
cure cloud storage (DSCS) protocol for dynamic data using
an SNC protocol.
Our Contribution Following the work of Chen et al. [14],
we provide a construction of a secure cloud storage (DSCS)
protocol for dynamic data from a secure network coding
(SNC) protocol. Unlike the construction of Chen et al., the
client, in our scheme, can eﬃciently perform updates (inser-
tion, deletion and modiﬁcation) on her data outsourced to
the cloud server. Our contributions in this paper are sum-
marized as follows.
• We investigate whether we can provide a general con-
struction of a DSCS protocol using any SNC protocol.
We discuss about the challenges for such a general con-
struction in details, and we identify some properties an
SNC protocol must have such that an eﬃcient DSCS
protocol can be constructed from it. Based on these
properties, we observe that, no eﬃcient DSCS proto-
cols can be constructed using some SNC protocols.
• We provide a construction of a DSCS protocol from an
SNC protocol proposed by Catalano et al. [11]. Our
construction is secure in the standard model and of-
fers public veriﬁability. Moreover, since the audits are
privacy-preserving in our scheme, a third party audi-
tor cannot gain knowledge of the content of the data
ﬁle.
• Erway et al. [18] propose an eﬃcient dynamic prov-
able data possession scheme (DPDP I). However, the
audits in this scheme are not privacy-preserving. We
modify this DPDP I scheme to make its audits privacy-
preserving.
• We analyze the eﬃciency of our DSCS protocol and
compare it with other existing secure cloud storage
protocols. We discuss about some limitations of an
SNC-based SCS protocol (for static or dynamic data).
The rest of the paper is organized as follows. In Section 2,
we discuss about the notations used in this paper, and we
describe the secure network coding and the secure cloud stor-
age protocols brieﬂy. Section 3 begins with a detailed discus-
sion on the general construction of a DSCS protocol using
an SNC protocol. Then, we describe our DSCS construc-
tion along with its security analysis and the probabilistic
guarantees it oﬀers. In Section 4, we modify the DPDP I
scheme [18] to support privacy-preserving audits with proper
security analysis of this modiﬁed DPDP I scheme. In Sec-
tion 5, we analyze the eﬃciency of our DSCS scheme and
compare its performance with the existing secure cloud stor-
age schemes. In the concluding Section 6, we summarize the
work done in this paper.
2. PRELIMINARIES AND BACKGROUND
2.1 Notation
We take λ to be the security parameter. An algorithm
A(1λ) is a probabilistic polynomial-time algorithm when its
running time is polynomial in λ and its output y is a ran-
dom variable which depends on the internal coin tosses of
A. An element a chosen uniformly at random from a set S
is denoted as a R←− S. A function f : N → R is called negli-
gible in λ if for all positive integers c and for all suﬃciently
λc . In general, F is used to denote
large λ, we have f (λ) < 1
a ﬁnite ﬁeld. The multiplication of a vector v by a scalar s
is denoted by s · v. The terms packet and vector are used
interchangeably in this work.
2.2 Secure Network Coding
Ahlswede et al. [2] introduce network coding as a replace-
ment of the conventional store-and-forward routing for net-
works. In network coding, intermediate nodes (or routers)
encode the received packets to output another packet which
increases the throughput of the network (optimal in case of
multicasting). Linear network coding was proposed by Li et
al. [25]. Here, the ﬁle F to be transmitted is divided into
several (say, m) packets (or vectors) v1, v2, . . . , vm each con-
sisting of n components (or blocks), and each of these com-
ponents is an element of a ﬁnite ﬁeld F. In other words, each
vi ∈ Fn for i ∈ [1, m]. Then, the sender (or source) node
augments each vector to form another vector ui = [vi ei] ∈
Fn+m for i ∈ [1, m], where ei is the m-dimensional unit vec-
tor containing 1 in i-th position and 0 in others. Finally, the
sender transmits these augmented vectors to the network.
Let V ⊂ Fn+m be the linear subspace spanned by the aug-
mented vectors u1, u2, . . . , um. A random ﬁle identiﬁer fid
is associated with the ﬁle F (or V ). In random (linear) net-
work coding [22, 21], an intermediate node in the network,
upon receiving l packets y1, y2, . . . , yl ∈ Fn+m, chooses l
R←− F and outputs another packet
coeﬃcients ν1, ν2, . . . , νl
i=1 νi · yi (here, summation
refers to vector additions). Thus, the output packet of each
intermediate node is of the form
w ∈ Fn+m such that w = (cid:80)l
for some c1, c2, . . . , cm ∈ F, where wj =(cid:80)m
w = [w1, w2, . . . , wn, c1, c2, . . . , cm] ∈ V
i=1 civij for each
j ∈ [1, n]. When the receiver (or target) node accumulates m
linearly independent vectors (or packets), it solves a system
of linear equations to obtain the ﬁle destined to it.
In a secure network coding (SNC) protocol, an authen-
tication information (or tag) is attached to each packet in
order to prevent pollution attacks. The authentication tags
are computed using homomorphic message authentication
codes (MACs) [1] or homomorphic signatures [13, 7, 19, 5,
11]. In an SNC protocol based on homomorphic signatures,
108every node in the network can verify the authenticity of
each of its incoming vectors. On the other hand, in case
of SNC protocols based on homomorphic MACs, it requires
the knowledge of the secret key to verify an incoming vector.
We deﬁne a secure network coding (SNC) protocol below.
Definition 2.1. A secure network coding (SNC) protocol
consists of the following algorithms.
• SNC.KeyGen(1λ, m, n): This algorithm generates a se-
cret key-public key pair K = (sk, pk) for the sender.
• SNC.TagGen(V, sk, m, n, fid): On input a linear sub-
space V ⊂ Fn+m, the secret key sk and a random ﬁle
identiﬁer fid associated with V , the sender runs this
algorithm to produce the authentication tag t for V .
• SNC.Combine({yi, ti, νi}1(cid:54)i(cid:54)l, pk, m, n, fid): Given l
incoming packets y1, y2, . . . , yl ∈ Fn+m and their cor-
responding tags t1, t2, . . . , tl for a ﬁle associated with
fid, an intermediate node chooses l random coeﬃ-
R←− F and runs this algorithm.
cients ν1, ν2, . . . , νl
The algorithm outputs another packet w ∈ Fn+m and
its authentication tag t such that w =(cid:80)l
i=1 νi · yi.
• SNC.Verify(w, t, K, m, n, fid): An intermediate node
or the receiver node, on input a packet w and its tag t
for a ﬁle associated with fid, executes this algorithm
which in turn returns 1 if t is authentic for the packet
w; returns 0, otherwise.
In some schemes, the algorithm SNC.Verify requires only
the public key pk [7, 19, 11]. The knowledge of the secret
key sk is necessary to verify the incoming packets in other
schemes [1].
Security of an SNC Protocol.
The security of an SNC protocol based on a homomor-
phic signature scheme is deﬁned by the security game be-
tween a challenger and a probabilistic polynomial-time ad-
versary A as stated below [11].
• Setup The adversary A provides the values m and
n of its choice to the challenger. The challenger runs
SNC.KeyGen(1λ, m, n) to output K = (sk, pk) and
returns pk to A.
• Queries The adversary A speciﬁes a sequence (adap-
tively chosen) of vector spaces Vi ⊂ Fn+m by respective
augmented basis vectors {ui1, ui2, . . . , uim} and asks
the challenger to authenticate the vector spaces. For
each i, the challenger chooses a random ﬁle identiﬁer
fidi from a predeﬁned space, generates an authentica-
tion tag ti by running SNC.TagGen(Vi, sk, m, n, fidi)
and gives ti to A.
• Forgery The adversary A outputs (fid
∗, w∗, t∗).
1 , w∗
n+1, w∗
2 , . . . , w∗
n+m] ∈ Fn+m. The adversary A
n+m] is not the
∗) outputs 1
Let w∗ = [w∗
wins the security game if [w∗
n+2, . . . , w∗
all-zero vector, SNC.Verify(w∗, t∗, pk, m, n, fid
and one of the following conditions is satisﬁed:
1. fid
2. fid
For a secure network coding (SNC) protocol, the prob-
ability that A wins the security game is negligible in the
security parameter λ.
∗ (cid:54)= fidi for all i (type-1 forgery)
∗ = fidi for some i, but w∗ (cid:54)∈ Vi (type-2 forgery).
We note that the security game for an SNC protocol based
on homomorphic MACs is exactly the same as the game
described above, except that the algorithm SNC.KeyGen
now produces a secret key only (unknown to the adversary