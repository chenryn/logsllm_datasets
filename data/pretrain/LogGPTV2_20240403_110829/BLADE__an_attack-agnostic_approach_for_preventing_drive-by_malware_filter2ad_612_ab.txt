entity (including the OS), of any on-disk data content received through
the browser process tree, unless that content can be correlated with
a user consent dialog event. BLADE enforces this requirement
while not interfering with normal browser operations in any way.
Speciﬁcally, we can accommodate automated software updating
that is a common practice among browsers and their plug-ins through
source domain whitelisting 2. Browser native code execution mech-
anisms (e.g., Native Client) are not affected by BLADE since they
rely on the preinstalled client, rather than the OS, to load and exe-
cute the code.
Inherent in this task are several key technical challenges, which
we outline here and further cast as design goals that we directly
address in this paper:
• Real-time user authorization capture and interpretation – BLADE
must monitor user-to-browser interaction events to capture explicit
user authorizations that permit upcoming download actions. From
each captured authorization, BLADE must extract identity infor-
mation pertaining to the expected download (i.e., remote URL, ﬁle
name, and local path) in order to uniquely identify the resulting ﬁle.
• Robust correlation between authorization and download con-
tent – BLADE must programmatically distinguish user-initiated
browser downloads from unauthorized ones and reliably correlate
every authorization event with the corresponding binary stream that
is downloaded by the browser from the network.
• Stringent enforcement of execution prevention – Files containing
unauthorized download content must be stringently prevented from
execution, while other types of access from supervised processes
are allowed. This enforcement must not impede normal operations
of browsers as well as other programs.
• Browser agnostic enforcement – BLADE must not depend on ei-
ther the integrity of browsers or their internal handling of tasks.
We must assume that new browser attack strategies will continue to
evolve along with the rapid development of new browser technolo-
gies. Browser updates or potential browser compromises caused
by inevitable software vulnerabilities must not affect the protection
quality BLADE provides.
2Our current prototype does not implement this capability.
• Exploit and evasion independence – BLADE’s enforcement mech-
anism must be entirely agnostic to exploits employed as the ﬁrst
step to subvert the browser into performing drive-by downloads,
and thus be immune to all kinds of sophisticated evasion techniques
including code obfuscations and zero-day vulnerabilities.
• Efﬁcient and usable system performance – BLADE’s performance
impact on browser content handling must be negligible. Overall,
BLADE should not impose perceptible delays to normal browser
operations, and have no impact on non-browser host operations.
Considering the threat model and design trade-offs, we believe
that placing BLADE as a dynamic loadable driver into the OS is a
viable design choice to achieve our goals listed above. To reliably
capture and interpret user interactions and guarantee unforgeability,
BLADE has to reside at least as low as the OS. Even in scenarios
where virtual machine monitoring systems are deployed, having
BLADE inside the kernel is more efﬁcient than placing BLADE-
equivalent functionalities inside the hypervisor and more accurate
than solely using virtual machine introspection.
3. THE BLADE SYSTEM ARCHITECTURE
Figure 1 illustrates the BLADE software architecture and its core
components. The front-end components, including the Screen Parser,
Hardware-Event Tracer and Supervisor are responsible for collect-
ing information displayed on the screen and tracking user interac-
tions when necessary. The Screen Parser monitors kernel window-
ing events as the status of on-screen UI changes in real time. It
signals the Supervisor upon the appearance of a download consent
dialog (or authorization dialog) on the screen foreground and re-
ports necessary information parsed from the screen (see § 3.1). A
download consent dialog is deﬁned as any prompt (dialog box) cre-
ated by browsers or plug-ins seeking download permission from
the user. Due to the well-deﬁned application interface used by
commodity browsers to implement download conﬁrmation dialogs,
a small number of signatures (one or two per browser family) are
needed to capture all download consent events. Each signature cap-
tures the external appearance and the internal hierarchy shared by
all UI instances of that class. The Screen Parser uses these sig-
natures to discover download consent dialogs, locate the respec-
tive positions of conﬁrmation elements on these UI dialogs (e.g.,
the “Save” button), and extract the download identity information
(e.g., URL, ﬁle name) to be used in the correlation process. Upon
receiving the signal from the Screen Parser, the Supervisor invokes
the Hardware-Event Tracer to intercept subsequent mouse and key-
board input events that would trigger the download conﬁrmation.
BLADE relies on hardware events as the only dependable source
UserFileSystemSecureZoneI/O RedirectorInput Device DriverWindowingSupervisorFile System ViewDisk I/OUser InteractionsBrowsersScreen ParserH/W Evt. TracerNetworkI/OTransport DriverCorrelatorBLADEOn-Screen EventsKernel Space442sent UI elements and effectively monitor content displayed on the
screen.
Since signiﬁcant performance degradation can be introduced if
suboptimal methods are employed, this component merits consid-
erable care in implementation. For example, a naive option to im-
plement the Screen Parser is as a direct hook into windowing event
handlers. However, such implementation would block the window
drawing process while trying to recognize newly visible UI ele-
ments, and in turn, result in perceptible UI delays when the window
being parsed contains too many elements.
To optimize performance, BLADE implants an agent in user
space to preﬁlter irrelevant windowing events. It runs in parallel
with the window management routines, asynchronously ﬁltering
and preparsing windowing events in the user space that would oth-
erwise incur signiﬁcant kernel CPU cycles if directly handled by
the Screen Parser. The agent pipes its output to the Screen Parser,
which may represent a user consent dialog currently in focus. To
secure against interference from untrusted user-level programs, an
independent sanity checker in the Screen Parser cross-validates the
input from the agent by inspecting kernel memory objects repre-
senting the UI elements.
On the Windows platforms, handling only three types of events is
sufﬁcient to completely cover the real-time changes of the currently
focused window: EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_
MOVESIZEEND, and EVENT_SYSTEM_MINIMIZEEND. Key strokes
triggering a particular UI element can also be obtained as one of
the associated attributes. Screen information is parsed only if the
newly focused window is deemed to represent a request for down-
load permission.
UI signatures are used to identify download consent dialogs and
guide information extraction from these dialogs. Each signature
describing the internal composition shared across all UI instances
of a class is sufﬁciently general and accurate in capturing all di-
alogs with the same look and feel as the sample used for signa-
ture generation. Due to the uniform use of interfaces by current
browsers to request download permissions, there are only a hand-
ful of UI classes that serve this purpose, which also remain highly
stable across browser versions and regular updates. Hence, using
only two signatures for Firefox and one signature for IE, we can
successfully capture all forms of download notiﬁcations in these
browser families across versions.
Note that attempted evasions by faking user consent dialogs may
trigger a signature match, but cannot elude the Correlator (see § 3.4
for the correlation process).
3.2 Supervisor
As the ﬁrst component loaded upon BLADE startup, the Super-
visor serves the role of coordinator for carrying out all tasks of
BLADE. It is charged with assigning tasks to other BLADE com-
ponents and coordinating their execution, as responding to the dif-
ferent event notiﬁcations from the Screen Parser. The Supervisor
also takes care of internal communications among all BLADE com-
ponents, including user-kernel communication backed by IOCTLs
(device input and output control), and kernel-kernel communica-
tion implemented by simply sharing a nonpaged pool across all
kernel components as a means of information exchange. Here,
spin-lock-based synchronizations are used to protect the integrity
of shared data.
Upon notiﬁcation of the appearance of a download consent dia-
log, or a status change to an existing one, the Supervisor initiates
other kernel components accordingly, or resets them in response to
status changes. As shown in Figure 2, when a new relevant UI ele-
ment is discovered, the Hardware Event Tracer (H/W Event Tracer)
is triggered, with input information such as the on-screen locations
of download consent dialogs. Its task is to sense the user-invoked
Figure 2: Download authorization workﬂow
of extracting user consent information due to their unforgeability
in our threat model (see § 3.3).
The Correlator and the I/O Redirector form the back end of the
BLADE system. They correlate inferred authorizations from the
front end with resulting downloads and enforce the nonexecution
policy for downloads that are not directly requested by the user.
The Correlator ensures BLADE’s resistance to spooﬁng attacks
such as forged UI dialogs (discussed in § 5), by virtue of its capabil-
ity to validate the authenticity of the consequent ﬁle corresponding
to a user download consent. We deﬁne the download identity infor-
mation as (URL, Path), i.e., a 2-tuple of the remote URL and the
local storage path, to uniquely delegate a user download authoriza-
tion. The Correlator matches a ﬁle f with a tuple (u, p) when f is
saved at p with data content received from u (see § 3.4).
The I/O Redirector persistently guarantees that uncorrelated down-
loads can do no harm by establishing the secure zone. As its name
suggests, the I/O Redirector intercepts disk write operations initi-
ated from the browser process tree (namely, supervised processes)
and redirects them to the secure zone, where execution is explicitly
prohibited by blocking memory-section synchronizations. We de-
scribe this in more detail in § 3.5. By default all ﬁles downloaded
by supervised processes are transparently redirected to the secure
zone. Files that pass the download correlation process (i.e., where
the content written is indeed from the user-authorized remote URL)
are subsequently moved out of the secure zone back to their orig-
inal destination in the ﬁle system. This move is accomplished by
modifying ﬁle system metadata as opposed to copying the down-
loaded data, which can be ﬁnished in constant time. Our design
of the secure-zone-based I/O redirection with the capability to dis-
cern user-initiated downloads enables a generic defense strategy
that targets the common behavioral pattern shared by all drive-by
download attacks.
We now discuss the design details of the BLADE architecture
components, in the order of web download and authorization work-
ﬂow as shown in Figure 2.
3.1 Screen Parser
BLADE’s download authorization lifecycle is triggered by the
appearance of download consent dialogs, which seek user’s per-
mission on downloads. Internally, every status change of UI ele-
ments causes a certain windowing event to be sent to the operating
system, which express the change by re-drawing the screen. For
instance, creating a new window causes an OBJ_CREATE event to
be generated on Windows platforms, which contains information
needed by the operating system to draw the new window on the
screen (e.g., position, size, text). The Screen Parser component
of BLADE relies on accurate interpretations of these windowing
events intercepted from within the OS to discover download con-
Screen Parser(1) Download consentUI appearedSupervisorH/W Event Tracer(2) Start tracingH/W Event(4) User consentcapturedI/ORedirectorCorrelator(3)Start stream recording(7) File contentcomparison(8) Releasecorrelated download(5) Notify download authorization(6) Correlation-candidate443hardware device signals that may indicate the user’s consent to per-
mit a pending download request. The Correlator also receives a
command from the Supervisor, indicating that the corresponding
stream recording process should start. A download authorization
is not recognized by the Supervisor until user consent is captured
by the H/W Event Tracer (in the form of physical mouse clicks or
keystrokes).
The Supervisor also actively maintains a complete list of super-
vised processes, on which most BLADE routines rely to function
correctly. For example, the I/O Redirector and the Correlator only
intercept ﬁle operations and record inbound network streams of su-
pervised processes. The list is initialized to be empty when BLADE
starts. A process p will be added into the list when (a) it is a newly
created browser process, (b) it is a newly created process spawned
by a supervised process, or (c) a remote thread is created within the
process by a supervised process. Tracking remote thread creations
is critical for blocking I/O redirection evasions, which may employ
a remote thread to carry out disk I/O on behalf of an unsupervised
process. The consequent list of this logic covers all possible execu-
tion entities that might either initiate a legitimate browser download
or be exploited to deliver surreptitious downloads. Listed processes
will be removed as they are terminated. The Supervisor registers
a callback routine for process creation and termination events by
calling PsSetCreateProcessNotifyRoutine.
3.3 Hardware Event Tracer
Once a download consent dialog is identiﬁed by the Screen Parser,
the next task is to interpret the user’s response. We developed the
Hardware Event Tracer (HET) to track user interactions with this
UI element by monitoring signals generated from the hardware to
the OS. Signals at this level can never be forged by attackers in our
threat model; thus, BLADE is immune to attempted evasions by
faking an afﬁrmative response to user download consent events.
The HET starts with a notiﬁcation from the Supervisor indicat-
ing the appearance of a certain download conﬁrmation UI. The
HET’s role is to capture responses from the user’s mouse clicks
or keystrokes. During the tracing interval, which normally lasts a
few seconds, the HET looks for any mouse click whose on-screen
coordinates fall in the areas of download consent dialogs, and any
keystroke that can trigger these UIs. The HET also maintains some
state information in order to make accurate decisions regarding
whether the intercepted hardware events could ﬁnally trigger the
download consent. The HET terminates the tracing activity due to