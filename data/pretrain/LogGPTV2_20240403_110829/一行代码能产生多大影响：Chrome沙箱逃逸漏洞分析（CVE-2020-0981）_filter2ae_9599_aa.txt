# 一行代码能产生多大影响：Chrome沙箱逃逸漏洞分析（CVE-2020-0981）
##### 译文声明
本文是翻译文章，文章原作者 googleprojectzero，文章来源：googleprojectzero.blogspot.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 概述
Windows环境上的Chromium沙箱已经经受了时间的考验，目前，人们普遍认为这是在大规模部署的沙箱机制中最好的一个，不需要特权提升即可运行。然而，优点和缺点往往都是相对的。沙箱的实现主要取决于Windows操作系统的安全性，而对Windows的更改行为不会受到Chromium开发团队的控制。如果我们在Windows的安全实施机制中发现错误，那么就有可能攻破沙箱。
本文主要分析了Windows 10
1903版本中引入的一个漏洞，该漏洞打破了CHromium用来保证沙箱安全的某些安全假设。我们将详细分析如何利用该漏洞来开发利用链，以在Chrome/Edge的GPU进程或Firefox的默认内容沙箱中实现沙箱逃逸。我们的漏洞利用过程，实际上是对Windows上一些小缺陷的仔细观察，这些小缺陷本身并没有越过安全边界，但却导致成功的沙箱逃逸。该漏洞在2020年4月修复，编号为CVE-2020-0981。
## 漏洞背景
在描述漏洞本身之前，我们首先快速浏览一下Chromium沙箱在Windows上的工作方式。借助受限令牌（Restricted
Token），沙箱可以按照最小特权的概念来工作。受限令牌是在Windows
2000中添加的一项功能，可以通过以下操作来修改进程的访问令牌，从而减少授予该进程的访问权限：
1、永久禁用组；
2、删除特权；
3、添加受限制的SID。
禁用组将会删除访问令牌的成员，从而导致无法访问由这些组进行保护的资源。删除特权可以防止进程执行任何不必要的特权操作。最后，添加受限制的SID会更改安全访问检查过程。如果要被授予对资源的访问权限，我们需要匹配主列表以及“受限SID”列表中的组的安全描述符条目。如果SID列表中的成员没有被授予对资源的访问权限，那么访问就会被拒绝。
Chromium还使用从Vista开始添加的完整性级别（IL）功能来进一步限制资源访问。通过设置较低的IL，无论访问检查的结果如何，都可以阻止对更高完整性资源的写入访问。
通过这种方式，将受限令牌与IL结合使用，沙箱可以限制受威胁进程能够访问哪些资源，从而限制远程代码执行可能造成的潜在影响。阻止写访问尤为重要，因为这通常会使攻击者可以通过写文件或注册表项，来破坏系统的其他部分。
Windows上的任何进程都可以使用其他令牌创建新进程，例如：通过调用`CreateProcessAsUser`。那么，是什么阻止了沙箱进程使用不受限制的令牌创建新进程呢？Windows和Chromium实施了一些安全缓解措施，以使得在沙箱外部创建新进程变得困难：  
1、内核限制了非特权用户可以向新进程分配的令牌；
2、沙箱限制限制了用于新进程的适用访问令牌的可用性；
3、Chromium在Job对象内运行一个沙箱进程，该进程可以被任何硬进程配额限制为1的子进程继承。
4、在Windows 10中，Chromium使用子进程缓解策略来阻止子进程创建。除了来自3的Job对象之外，还应用了该对象。
所有这些缓解措施最终都依赖于Windows来确保安全。但是，到目前为止，最关键的还在于1。即使2、3、4都失败了，从理论上来看，我们也不能为新的进程分配更多特权的访问令牌。那么，在分配新令牌时，内核需要检查哪些内容呢？
我们假设调用过程中没有`SeAssignPrimaryTokenPrivilege`（我们实际的测试中也没有），那么新的令牌必须满足两个条件之一，这两个条件已经在内核函数`SeIsTokenAssignableToProcess`中进行了检查。检查的条件基于内核TOKEN对象结构中的指定值，如下所示：
总而言之，令牌必须满足以下条件：
1、当前进程令牌的子级。要求新令牌的父令牌ID等于进程令牌的ID。
2、当前进程令牌的同级。要求父令牌ID和身份验证ID相同。
此外，还进行了其他检查，以确保新令牌不是身份验证级别的模拟令牌，并且新令牌的IL必须小于或等于当前进程令牌。这些同样重要，但正如我们即将看到的，在实际中用处不大。
令牌分配的过程中，不会检查父令牌或子令牌是否受到限制。如果位于受限令牌沙箱中，我们能否通过所有检查，并将其分配给可以逃逸的沙箱的子级不受限制的令牌呢？显然是不能的，系统会在分配受限令牌时进行“同级令牌”检查，而这些环节将无法通过，这时父级/子级检查将强制执行。如果我们查看内核函数`SepFilterToken`，我们将会了解其具体的实现方式。将现有属性从父令牌复制到新的受限令牌时，将会执行以下代码：
    NewToken->ParentTokenId = OldToken->TokenId;
通过设置新的受限令牌的父令牌ID，可以确保只有创建受限令牌的进程才能将其用于子级，因为令牌ID对于TOKEN对象的每个实例都是唯一的。同时，通过修改父令牌ID，将会破坏同级检查。
但是，当我在Windows 10
1909环境上进行测试以验证令牌分配行为时，我发现有些奇怪，因为无论我创建了什么令牌，都无法导致分配失败。再次查看`SepFilterToken`，我发现代码已经更改。
    NewToken->ParentTokenId = OldToken->ParentTokenId;
现在，内核代码只会从旧令牌中复制父令牌ID。这完全打破了原有的检查，因为新的沙箱进程具有一个令牌，而这个令牌被视为桌面上任何其他令牌的同级。
假设我可以绕过其他三个已有的子进程缓解措施，那么这一行更改就足以让我们突破“受限令牌”沙箱。为此，我们还要进行一系列的尝试。
## 沙箱逃逸
最终，我想到的沙箱逃逸方式非常复杂，不一定是最佳方案。但是，由于Windows的复杂性，我们很难在漏洞利用链中找到可以利用的替代原语。
首先，我们尝试获取合适的访问令牌，并将其分配给新的进程。令牌需要满足以下条件：
1、令牌是主令牌，或者可以转换为主令牌；
2、令牌的IL等于沙箱的IL，或者允许写入，从而可以降低IL级别；
3、令牌符合同级令牌的标准，可以进行分配；
4、令牌用于当前的控制台会话；
5、令牌未沙箱化，或者比当前令牌沙箱化的程序要小。
访问令牌是可保护的对象，因此，如果我们具有足够的访问权限，就可以打开令牌的句柄。但是，访问令牌不是用名称来引用的，而是需要打开令牌，这就意味着需要我们有权访问进程或模拟线程。我们可以使用`Get-AccessibleToken`命令使用PowerShell的`NtObjectManager`模块查找可访问的令牌。
    PS> $ps = Get-NtProcess -Name "chrome.exe" `
                      -FilterScript { $_.IsSandboxToken } `
                      -IgnoreDeadProcess
    PS> $ts = Get-AccessibleToken -Processes $ps -CurrentSession `
                                  -AccessRights Duplicate
    PS> $ts.Count
    101
这个脚本获取了计算机上运行的每个沙箱Chrome进程的句柄，然后使用每个进程中的访问令牌来确定我们可以为`TOKEN_DUPLICATE`访问打开哪些其他的令牌。之所以要检查`TOKEN_DUPLICATE`在新进程中使用的令牌的原因是，由于两个进程不能使用同一访问令牌对象，因此我们需要对令牌进行复制。访问检查需要判断调用进程是否对目标进程具有`PROCESS_QUERY_LIMITED_INFORMATION`访问权限，这是打开令牌的先决条件。我们得到了很多结果，大概超过100个条目。
但是，这个数字是有迷惑性的。一开始，几乎可以确定，我们可以访问的某些令牌在沙箱中的数量要比当前令牌在沙箱中的数量更多。确实，我们只需要未沙箱化的可访问令牌。其次，尽管有许多可访问的令牌，但这很可能是代表着只有少数进程能够访问大量的令牌。为此，我们需要将其过滤为仅可以访问非沙箱标记的Chrome进程的命令行。
    PS> $ts | ? Sandbox -ne $true | `
        Sort {$_.TokenInfo.ProcessCommandLine} -Unique | `
        Select {$_.TokenInfo.ProcessId},{$_.TokenInfo.ProcessCommandLine}
    ProcessId ProcessCommandLine
    --------- ----------------------------------         6840 chrome.exe --type=gpu-process ...
        13920 chrome.exe --type=utility --service-sandbox-type=audio ...