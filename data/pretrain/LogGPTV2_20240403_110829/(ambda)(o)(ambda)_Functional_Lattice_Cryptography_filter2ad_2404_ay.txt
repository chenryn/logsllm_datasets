function, given polynomially many pairs of the form (ğ‘¥ğ‘–, ğ¹ğ‘ (ğ‘¥ğ‘–)), where the ğ‘¥ğ‘– âˆˆ {0, 1}ğ‘˜
are uniformly random and independent (not chosen by the adversary). It is well known that
weak PRFs can be used in a generic manner to implement symmetric-key encryption, in the
following way:
Encğ‘ (ğ‘š; ğ‘Ÿ) = (ğ‘Ÿ, ğ¹ğ‘ (ğ‘Ÿ) âŠ• ğ‘š),
Decğ‘ (ğ‘Ÿ, ğ‘) = ğ¹ğ‘ (ğ‘Ÿ) âŠ• ğ‘,
175
where ğ‘š âˆˆ {0, 1}ğ‘› and ğ‘Ÿ âˆˆ {0, 1}ğ‘˜. The scheme is IND-CPA secure provided that ğ¹ğ‘  is a
weak PRF for sufï¬ciently large input length ğ‘˜, and ğ‘Ÿ is chosen uniformly at random in each
invocation.
Notice that homomorphically computing a PRF ğ¹ğ‘ , i.e., computing HE(ğ¹ğ‘ (ğ‘Ÿ)) from
HE(ğ‘ ) and ğ‘Ÿ, followed by a single homomorphic exclusive-or operation, corresponds to ho-
momorphically computing HE(Decğ‘ (ğ‘)) = HE(ğ¹ğ‘ (ğ‘Ÿ)âŠ• ğ‘) from HE(ğ‘ ) and ğ‘ = Encğ‘ (ğ‘š; ğ‘Ÿ).
Thus, efï¬cient homomorphic evaluation of the PRF directly translates to efï¬cient homomor-
phic symmetric decryption. So for all applications described above (including homomorphic
key management, which is attained just by evaluating the PRF itself), it is sufï¬cient to focus
on fast homomorphic evaluation of pseudorandom functions.
6.1.3 Our Results
Our primary technical contribution is the design and implementation for the efï¬cient homo-
morphic evaluation of the non-trivial ring rounding operation, including a novel arithme-
tization of an operation for rounding integer coefï¬cients of a ring element. As a concrete
application, we use ring rounding to implement homomorphic evaluation of the weak pse-
duorandom function of Banerjee, Peikert, and Rosen (BPR) [BPR12]. Our experimental
results show that the homomorphic evaluation of the BPR PRF is dramatically more efï¬cient
than the homomorphic evaluation of AES. For instance, on a standard laptop computer we
can homomorphically evaluate one useful and apparently secure instantiation of the BPR
weak PRF on a single input in less than 90 seconds, and requiring less than 150 megabytes
of memory. This is more than 1,400 times faster (on weaker hardware) than the best reported
total runtime for AES evaluation, and uses less memory by a factor of more than 1,500.
Figure 6.1 gives a high-level performance comparison between our implementation and
prior ones that homomorphically evaluate the AES function.
The key idea behind our design is to exploit the simple (yet still seemingly secure)
algebraic structure of the BPR pseudorandom function, and its tight â€œalgebraic ï¬tâ€ with
176
lattice-based HE constructions. Most importantly, this relationship allows us to use an HE
plaintext space that perfectly coincides with the domain of the PRF key elements, and the
operations that the PRF performs on them. From the perspective of homomorphic evaluation,
this correspondence translates into two main advantages:
1. It yields relatively compact encryptions of the PRF key element under the HE scheme,
and allows for signiï¬cant savings in the amount of auxiliary data (i.e., key-switching
â€œhintsâ€) needed for homomorphic evaluation.
2. It leads to very simple, small, and low-depth arithmetic circuits (and hence fast
homomorphic evaluation) for the main operation in the PRF computation, namely,
â€œroundingâ€ a public multiple of the secret to a smaller modulus.
Table 6.1: Performance comparison with prior homomorphic evaluations of AES [GHS12c;
Che+13].
total runtime (sec)
time/block (sec) memory
AES-128, 54-block batch
AES-128, 720-block batch
BPR weak PRF
130,000
216,000
90
2,400
300
90
256 GB
256 GB
160 MB
To date, a large roadblock for implementing homomorphic computations like pseudoran-
dom functions has been the complexity of using existing HE implementations. We give a
concise implementation using ALCHEMY (chapter 5), which automatically handles complex-
ities such as parameter generation, key/hint management, and noise management operations.
We compare our ALCHEMY implementation with a reference implementation using the
interface from section 4.3, and ï¬nd that ALCHEMY greatly reduces the implementation
burden with no loss in performance.
Organization. The rest of the chapter is organized as follows.
177
Section 6.2 deï¬nes the important ring-rounding operation and our method for evaluating it
homomorphically.
Section 6.3 gives our novel arithmetization (in terms of operations natively supported
by our target SHE scheme) of the integer rounding operation that is central to the
homomoprhic evaluation of ring-rounding. This arithmetization is more suitable for
rounding small moduli like those used in our PRF instantiation.
Section 6.4 introduces the BPR weak PRF, our concrete instantiation, and the homomorphic
evaluation fo the PRF.
Section 6.5 analyzes the concrete security of our BPR instantiation against known classes
of attacks.
Section 6.6 describes the implementation of homomorphic ring-rounding and PRF evalua-
tion using ALCHEMY.
Section 6.7 quantitatively measures the savings of using ALCHEMY compared to the current
method of hand-writing homomorphic computations. Note that the PRF application is
primarily a tool for evaluating ALCHEMY; for evaluating the BPR PRF implementa-
tion, see the discussion above this paragraph which compares it to prior homomorphic
evaluation of symmetric-key primitives.
6.2 Homomorphic Computation of Ring Rounding
We start by describing the ring rounding function and the technical ideas underlying its
homomorphic evaluation. Let ğ‘… be a cyclotomic ring of arbitrary index ğ‘š, and let ğ‘› = ğœ™(ğ‘š).
The ring rounding function is âŒŠÂ·âŒ‰ğ‘ : ğ‘…ğ‘ â†’ ğ‘…ğ‘. This operation is highly non-linear (which
leads to its usefulness in lattice primitives), so it is not obvious how to efï¬ciently evaluate in
homomorphically.
178
We call upon the literature on bootstrapping, which is Gentryâ€™s technique [Gen09b;
Gen09a] for transforming an SHE into an FHE by homomorphically evaluating the SHEâ€™s
decryption function. Since the rounding function âŒŠÂ·âŒ‰ğ‘ : ğ‘…ğ‘ â†’ ğ‘…ğ‘ is essentially the same
nonlinear step performed in the decryption algorithm of lattice-based cryptosystems (but
for a much smaller modulus ğ‘), bootstrapping techniques from several prior works provide
exactly what we need here. In more detail, the rounding step proceeds in two phases:
â€¢ Ring-switch: First, we homomorphically move the Zğ‘-coefï¬cients of the input into
separate plaintext â€œslotsâ€ of a different plaintext ring ğ‘†ğ‘, using the ring-tunneling
technique from section 4.2.
â€¢ Batch-round: Then, we apply the integer rounding function âŒŠÂ·âŒ‰ğ‘ : Zğ‘ â†’ Zğ‘ in batch
to all the slots at once, at the cost of just one homomorphic evaluation of the integer
rounding function.
Starting with the latter step, Smart and Vercauteren [SV11] ï¬rst proposed the idea of
batched (or SIMD) homomorphic operations. There are several known arithmetizations
of the integer rounding step in the special case where ğ‘ = 2ğ‘˜ is a power of two and
ğ‘ = 2. Gentry, Halevi and Smart [GHS12a] described a simple arithmetic circuit for these
parameters (slightly improved in [AP13]) which has depth exactly log(ğ‘/2) and performs
about log2(ğ‘)/2 multiplications and additions. In section 6.3 we give a quite different
circuit for the same specialized parameters, having the same log(ğ‘/2) depth, which can be
evaluated using exactly ğ‘/4 multiplications (and no additions). This is asymptotically worse
but concretely better than log2(ğ‘)/2 when ğ‘ â‰¤ 32, which is the case in our implementation.
We emphasize that all of these parameters are restricted to the case where ğ‘ = 2ğ‘˜ and ğ‘ = 2;
an arithmetization for somewhat more general parameters is given in [HS15].
Moving coefï¬cients into separate slots is more involved. Gentry et al. [GHS12a]
gave a procedure for doing this, but it requires working in more complex cyclotomic
rings than are convenient for our PRF, and it appears very difï¬cult to implement and
inefï¬cient. In particular, it relies on a general-purpose circuit compiler for HE [GHS12b],
179
and seems primarily of theoretical interest. Instead we rely on the ring-tunneling technique
given in chapter 4, which improves upon the work of Alperin-Sheriff and Peikert [AP13].
Tunneling gives a simple linear procedure for transferring the coefï¬cients of an ğ‘…ğ‘-element
into the plaintext slots of a different ring ğ‘†ğ‘, in which we can batch-round and ï¬nally decrypt
the resulting bits. To our knowledge, our weak PRF provides the ï¬rst implementation of a
batched rounding circuit.
Altogether, for the full evaluation of ring rounding, we obtain a very simple and regular
arithmetic circuit, consisting of: (1) a sequence of (at most) log ğ‘› ring-tunnels (which,
despite being a linear operation, performs operations and induces noise growth roughly
matching those of a homomorphic multiplication for each tunnel), and (2) a complete binary
tree of multiplications for the (batched) integer rounding. The total effective multiplicative
depth is therefore bounded by log ğ‘› + log(ğ‘/2).
6.3 Rounding Circuit for Small Moduli
In this section we describe a simple arithmetic circuit that for any ğ‘ = 2â„“ computes the
rounding function âŒŠÂ·âŒ‰2 : Zğ‘ â†’ Z2, i.e., it returns the bit indicating whether the input is
closer (modulo ğ‘) to 0, or to ğ‘/2.1 This operation is useful in a variety of contexts: it is an
important part of the bootstrapping step for FHE and is also the central component needed
for the RLWR problem and the strong and weak PRFs given in [BPR12], as well as for the
strong PRF in [BP14]. While this operation is easy to implement in-the-clear, it is not a
â€œnativeâ€ operation for our SHE scheme.
Gentry, Halevi, and Smart [GHS12a] described an algebraic procedure (slightly im-
proved in [AP13, Appendix B]) that can be used to (homomorphically) compute the rounding
2(ğ‘)/2 (homomorphic)
function in log2(ğ‘/2) multiplicative depth, using a total of about log2
multiplications and additions each. Here we describe a very different procedure that com-
putes the function in log2(ğ‘/2) multiplicative depth, exactly ğ‘/4 homomorphic multiplica-
1We thank Jacob Alperin-Sheriff (personal communication) for important observations that contributed to
the results of this section.
180
tions, and no homomorphic additions.2 While our procedure is clearly worse asymptotically,
it actually performs fewer operations in the same depth when ğ‘ â‰¤ 32, which is the case for
our PRF instantiation. The procedure is also very simple to implement, especially with the
help of ALCHEMY (see chapter 5).
For ğ‘– âˆˆ [â„“], deï¬ne functions ğ‘“ğ‘– : Zğ‘ â†’ Zğ‘/2ğ‘– recursively as follows: let ğ‘“0(ğ‘¥) = ğ‘¥ be the
identity function, and for 1 â‰¤ ğ‘– â‰¤ â„“ âˆ’ 1 deï¬ne
ğ‘“ğ‘–+1(ğ‘¥) =
ğ‘“ğ‘–(ğ‘¥) Â· ğ‘“ğ‘–(ğ‘¥ âˆ’ 2ğ‘–)
2
mod ğ‘/2ğ‘–+1.
(6.3.1)
Note that due to the division by two in Equation (6.3.1), in order for ğ‘“ğ‘–+1 to be well deï¬ned,
at least one of ğ‘“ğ‘–(ğ‘¥), ğ‘“ğ‘–(ğ‘¥ âˆ’ 2ğ‘–) must be even for all ğ‘¥ âˆˆ Zğ‘. The following lemma (for the
special case ğ‘˜ = 1) proves this fact in a more general form, which we will need for our ï¬nal
claim.
Lemma 6.3.1. Let 0 â‰¤ ğ‘– â‰¤ â„“ and 0 â‰¤ ğ‘˜ â‰¤ â„“ âˆ’ ğ‘–, and let ğ‘¥ âˆˆ Zğ‘ be arbitrary. Then over all
ğ‘— âˆˆ [2ğ‘˜], exactly one of ğ‘“ğ‘–(ğ‘¥ âˆ’ ğ‘— Â· 2ğ‘–) âˆˆ Zğ‘/2ğ‘– is divisible by 2ğ‘˜, namely, the one for which
ğ‘— = âŒŠğ‘¥/2ğ‘–âŒ‹ (mod 2ğ‘˜).
Proof. We proceed by induction on ğ‘–. First consider the base case ğ‘– = 0, where ğ‘“0(ğ‘¥) = ğ‘¥ is
the identity function. Since 2ğ‘˜ â‰¤ 2â„“ â‰¤ ğ‘, the 2ğ‘˜ consecutive residue classes ğ‘¥, ğ‘¥âˆ’1, . . . , ğ‘¥âˆ’
(2ğ‘˜ âˆ’ 1) âˆˆ Zğ‘ are all distinct, and clearly, ğ‘¥âˆ’ ğ‘— for ğ‘— = ğ‘¥ (mod 2ğ‘˜) is the only one divisible
by 2ğ‘˜.
To prove the lemma for positive ğ‘– â‰¤ â„“ and any ğ‘˜ â‰¤ â„“ âˆ’ ğ‘–, assume that it holds for ğ‘– âˆ’ 1
and any ğ‘˜ â‰¤ â„“ âˆ’ ğ‘– + 1. By deï¬nition of ğ‘“ğ‘–, for any ğ‘— âˆˆ Z we have
(ï¸€ğ‘¥ âˆ’ ğ‘— Â· 2ğ‘–)ï¸€ =
ğ‘“ğ‘–
ğ‘“ğ‘–âˆ’1(ğ‘¥ âˆ’ (2ğ‘—) Â· 2ğ‘–âˆ’1) Â· ğ‘“ğ‘–âˆ’1(ğ‘¥ âˆ’ (2ğ‘— + 1) Â· 2ğ‘–âˆ’1)
2
mod ğ‘/2ğ‘–.
2Our procedure also adds several ï¬xed constants to a ciphertext, but these steps take essentially no time,
and incur no growth in the ciphertext noise.
181
By the inductive hypothesis applied with ğ‘¥ âˆ’ (2ğ‘—) Â· 2ğ‘–âˆ’1 and ğ‘˜ = 1, exactly one of the two
terms in the numerator is even, and so the largest power of two that divides ğ‘“ğ‘–(ğ‘¥ âˆ’ ğ‘— Â· 2ğ‘–)
is exactly half that of the even term. In addition, over all ğ‘— âˆˆ [2ğ‘˜], each ğ‘“ğ‘–âˆ’1(ğ‘¥ âˆ’ ğ‘—â€² Â· 2ğ‘–âˆ’1)
for ğ‘—â€² âˆˆ [2ğ‘˜+1] appears in the numerator exactly once. By the inductive hypothesis, exactly
one of those terms is divisible by 2ğ‘˜+1, so exactly one of ğ‘“ğ‘–(ğ‘¥ âˆ’ ğ‘— Â· 2ğ‘–) is divisible by 2ğ‘˜.
Speciï¬cally, it is the one for which ğ‘— = âŒŠğ‘—â€²/2âŒ‹, where ğ‘—â€² = âŒŠğ‘¥/2ğ‘–âˆ’1âŒ‹ (mod 2ğ‘˜+1) by the
inductive hypothesis. Therefore, ğ‘— = âŒŠğ‘¥/2ğ‘–âŒ‹ (mod 2ğ‘˜), as claimed.
Corollary 6.3.2. The function ğ‘“â„“âˆ’1 : Zğ‘ â†’ Z2 is ğ‘“â„“âˆ’1(ğ‘¥) = msbğ‘(ğ‘¥) = âŒŠğ‘¥/2â„“âˆ’1âŒ‹.
Proof. Letting ğ‘– = â„“ âˆ’ 1 and ğ‘˜ = 1 in Lemma 6.3.1, we have that ğ‘“â„“âˆ’1(ğ‘¥) âˆˆ Z2 is even (i.e.,
equals 0) exactly when âŒŠğ‘¥/2â„“âˆ’1âŒ‹ = 0 (mod 2), i.e., when ğ‘¥ âˆˆ {0, . . . , ğ‘/2âˆ’ 1} (mod ğ‘).
By fully expanding ğ‘“â„“âˆ’1(ğ‘¥ + ğ‘/4) in terms of ğ‘“0 using Equation (6.3.1), we see that
the rounding function âŒŠğ‘¥âŒ‰2 can be expressed as a complete binary tree with ğ‘/2 leaf
nodes and depth log2(ğ‘/2) = â„“ âˆ’ 1, where the leaf nodes hold the terms ğ‘¥ âˆ’ ğ‘— for ğ‘— âˆˆ
{âˆ’ğ‘/4, . . . , ğ‘/4âˆ’1}, and the internal nodes are all â€œmultiply-and-divide-by-twoâ€ arithmetic
gates. Given an encryption ğ‘ = (ğ‘0, ğ‘1) of ğ‘¥, we can trivially get an encryption of each ğ‘¥âˆ’ ğ‘—
by just subtracting ğ‘— from the constant term ğ‘0. We can then homomorphically compute âŒŠğ‘¥âŒ‰2
by evaluating the gates of the tree, which takes exactly ğ‘/2âˆ’ 1 homomorphic multiplications
(and no additions).
Finally, the above method can be improved to require only ğ‘/4 multiplications, thus
halving the total work. The idea is to restructure the tree so that leaves (ğ‘¥âˆ’ğ‘—), (ğ‘¥âˆ’(âˆ’ğ‘—âˆ’1))
for ğ‘— âˆˆ {âˆ’ğ‘/4, . . . ,âˆ’1} are paired as siblings, and more generally, every internal node
at level ğ‘– = 1, 2, . . . , â„“ (where level 0 is the leaf level) has one descendant leaf from each
residue class modulo 2ğ‘–. It is straightforward to generalize the proof of Lemma 6.3.1 to
show that any such tree correctly computes the rounding function. With these pairings, the
nodes at level 1 are encryptions of (ğ‘¥âˆ’ ğ‘—)(ğ‘¥âˆ’ (âˆ’ğ‘— âˆ’ 1))/2 = (ğ‘¥2 + ğ‘¥âˆ’ (ğ‘—2 + ğ‘—))/2, which
just differ by known constants. Therefore, all the encryptions at level 1 can be computed
182
using just one homomorphic multiplication, then adjusting its constant term. It is tempting
to think that this trick could be generalized to reduce the number of multiplications further
(perhaps to only log2(ğ‘)), by efï¬ciently deriving many of the level-2 ciphertexts from just a
few others, but so far we have not found a way to do this. In any case, the rounding function
is not the main bottleneck in our implementations.
6.4 Homomorphic Computation of the BPR Weak PRF
In this section, we use the homomorphic evaluation of ring rounding as a building block for
the homomorphic evaluation of the BPR weak pseudorandom function [BPR12]. We give
concrete parameters for our instantiation and a security analysis against known attacks on
the PRFs.
6.4.1 BPR Weak PRF
Let ğ‘… be a cyclotomic ring of arbitrary index ğ‘š, and ğ‘› = ğœ™(ğ‘š)) be the dimension of the
ring over the integers. For ğ‘ = 2ğ‘˜ a power of two, the BPR family of weak pseudorandom
functions is the set of functions ğ‘“ğ‘  : ğ‘…ğ‘ â†’ {0, 1}ğ‘›, indexed by a ring element ğ‘  âˆˆ ğ‘…ğ‘, and
deï¬ned as the â€œrounded productâ€
ğ‘“ğ‘ (ğ‘) := âŒŠğ‘ Â· ğ‘ âŒ‰2.
Here âŒŠÂ·âŒ‰2 : ğ‘…ğ‘ â†’ ğ‘…2 denotes the â€œrounding functionâ€ that maps each of its input polyno-
mialâ€™s ğ‘› coefï¬cients to Z2 = {0, 1} depending on whether the coefï¬cient is closer (modulo
ğ‘ Â· ğ‘âŒ‰ âˆˆ Z2.) The
ğ‘) to 0 or to ğ‘/2. (Formally, the integer rounding function maps ğ‘ âˆˆ Zğ‘ to âŒŠ 2
resulting polynomial is interpreted as an ğ‘›-bit string simply by reading off its coefï¬cients in
order.
It is proved in [BPR12] that when ğ‘  âˆˆ ğ‘…ğ‘ is drawn from an appropriate distribution,
and ğ‘ is sufï¬ciently large, the above function family is a weak PRF familyâ€”or equivalently,
183
that the ring-Learning With Rounding (ring-LWR) problem is hardâ€”assuming that the ring-
LWE problem [LPR13b] is hard in ğ‘…ğ‘. This proof provides strong evidence that the family
has a sound design and is indeed a secure weak PRF, at least in an asymptotic sense. The
intuition behind the proof is that the rounding function destroys all but the most-signiï¬cant
bits of the product ğ‘ Â· ğ‘ , and that the round-off term can be seen as a kind of â€œsmallâ€ error,
though one that is generated deterministically from ğ‘ Â· ğ‘  rather than as an independent
random variable (as in the LWE problem).
We note that the known proofs of security (under ring-LWE) require ğ‘ to be super-
polynomial in ğ‘›. (More precisely, ğ‘ has to be lower bounded by the total number of samples