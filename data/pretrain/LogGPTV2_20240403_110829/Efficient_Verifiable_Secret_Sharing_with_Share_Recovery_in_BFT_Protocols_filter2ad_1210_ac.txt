3.2.1 Hiding Informally, the hiding property is set up in the fol-
lowing way. Suppose you have an adversary that gave the client
two secrets, of which the client picked one randomly and shared
it using our VSS scheme. Even with access to k − 1 of the replicas
and their secrets, the adversary cannot tell which secret was shared
with high probability. Note that our hiding definition is computa-
tional since we would like our transformation to be as ambivalent to
the underlying secret sharing scheme as possible. Any information
theoretic secret sharing scheme would satisfy these requirements
as well.
More formally, a hiding adversary AV is provided inputs q and
{vpki}i∈[n], where ⟨q, {⟨vpki , vski⟩}i∈[n]⟩ ← vssInit(1κ , k, n), and
access to n + 1 oracles. The first n oracles are denoted ⟨OV,i⟩i∈[n];
each OV,i is initialized with vski and can be invoked as described
below. The last oracle provided to AV is denoted ObV, where b ∈
{0, 1}. AV can invoke this oracle with two inputs s0, s1 ∈ Zq. When
invoked, ObV generates a random ˆs ∈ Zq[x] of degree k−1 such that
ˆs(0) = sb and performs ⟨c, {ui}i∈[n]⟩ ← vssShare(ˆs, q, {vpki}i∈[n]),
providing c to AV and ⟨c, ui⟩ to OV,i. The oracles ⟨OV,i⟩i∈[n]
can be invoked by AV as follows. AV can invoke OV,i .contrib(c),
which returns the share ui provided to OV,i with commitment c
by ObV. AV can also invoke OV,i .compromise, which returns vski
and all ⟨c, ui⟩ pairs received from ObV. For any c, let Ic be the oracle
indices such that for each i ∈ Ic, AV invokes OV,i .compromise
or OV,i .contrib(c). Then, AV is legitimate if |Ic| < k for every c.
Finally, AV outputs a bit. We say that the VSS V is hiding if for
all legitimate adversaries AV that run in time polynomial in κ,
P
− P
A⟨OV,i ⟩i∈[n],O1V
V
A⟨OV,i ⟩i∈[n],O0V
V
(q, {vpki}i∈[n]) = 1
(q, {vpki}i∈[n]) = 1
(2)
(cid:18)
(cid:18)
(cid:19)
(cid:19)
is negligible in κ.
3.2.2 Binding Informally, the binding property says that an ad-
versarial dealer’s public commitment uniquely identifies the secret
that is reconstructed. Essentially, the probability that the dealer
can cause two different secrets to be reconstructed with the same
public commitment is negligible.
⟨q, {⟨vpki , vski⟩}i∈[n]⟩ ← vssInit(1κ , k, n). AV outputs c, {ui}i∈I
and { ˆui}i∈ ˆI . We say that VSS V is binding if for all binding adver-
saries AV that run in time polynomial in κ,
Formally, a binding adversary AV is provided inputs
P(cid:169)(cid:173)(cid:171)
vssReconstruct(c, {⟨vpki , ui⟩}i∈I) = s
∧ vssReconstruct(c, {⟨vpki , ˆui⟩}i∈ ˆI) = ˆs
∧ s (cid:44) ⊥ ∧ ˆs (cid:44) ⊥ ∧ s (cid:44) ˆs
(cid:170)(cid:174)(cid:172)
is negligible in κ, where the probability is taken with respect to
random choices made in vssInit and by AV.
3.3 Goals
Given such a VSS scheme V and a DPRF F , our goal is to construct
a new VSS scheme V∗ that provides the vssInit, vssShare, vssVerify,
and vssReconstruct algorithms (denoted vssInit∗, vssShare∗, vssVerify∗
and vssReconstruct∗ for V∗, respectively) as defined in Section 3.1,
as well as three more algorithms, denoted vssRecoverContrib∗,
i , u∗
vssRecoverVerify∗, and vssRecover∗. We allow the vssShare∗ algo-
rithm to accept additional arguments (a set of private keys for a
DPRF) and to return an additional value r that is provided as input to
all procedures except for vssInit∗. The algorithms vssRecoverContrib∗,
vssRecoverVerify∗, and vssRecover∗ together permit a replica to re-
cover its share from other replicas, and behave as follows:
• vssRecoverContrib∗ is a randomized procedure that returns
i ← vssRecoverContrib∗(c∗, r, vsk∗
v∗
i , ˆi) where v∗
i is a re-
covery share with properties described below.
• vssRecoverVerify∗ is a deterministic procedure that returns
i , vpk∗
a boolean. vssRecoverVerify∗(c∗, r, v∗
i , ˆi) must return
i is output from vssRecoverContrib∗(c∗, r, vsk∗
true if v∗
i , u∗
i , ˆi)
with nonzero probability and vssVerify∗(vpk∗
i , c∗, r, u∗
i ) re-
turns true.
• vssRecover∗ is a deterministic procedure that returns u∗
←
ˆi
vssRecover∗(c∗, r, {⟨vpk∗
i ⟩}i∈I , ˆi, vpk∗
i , v∗
) if
ˆi
i , vpk∗
|I| ≥ k, vssRecoverVerify∗(c∗, r, v∗
i , ˆi) returns true for
all i ∈ I, and vssVerify∗(vpk∗
, c∗, r, u∗
) returns true. Other-
ˆi
ˆi
i ⟩}i∈I , ˆi, vpk∗
wise, vssRecover∗(c∗, r, {⟨vpk∗
i , v∗
) returns ⊥.
ˆi
Due to the additional interfaces above, we change the definition
of hiding security as follows. Each oracle OV∗,i additionally sup-
ports a query OV∗,i .recover(c∗, ˆi) that returns
i ← vssRecoverContrib∗(c∗, r, vsk∗
i , ˆi). For any c∗, let Ic∗ be
v∗
the oracle indices such that for each i ∈ Ic∗, AV∗ invokes
OV∗,i .compromise, OV∗,i .contrib(c∗), or {OV∗,ˆi .recover(c∗, i)}ˆi∈ ˆI
where |ˆI| ≥ k. Then, AV∗ is legitimate if |Ic∗| < k for every c∗.
3.4 Assumptions on Underlying VSS
Our construction combines an existing VSS scheme with a DPRF for
which, if ⟨q, {⟨vpki , vski⟩}i∈[n]⟩ ← vssInit(1κ , k, n), then R = Zq
and each share ui output from vssShare is in Zq. In addition, we
require that the VSS offer additional procedures, as follows.
• There is a procedure vssMakeSecret that creates
i , u∗
s ← vssMakeSecret(q, {⟨xi , yi⟩}i∈I)
where s ∈ Zq[x] is of degree |I|, and so that if
⟨c, {ui}i∈[n]⟩ ← vssShare(s, q, {vpki}i∈[n])
then ui = yi for any i ∈ I.
• There is a procedure vssCombineCommitments such that if
vssReconstruct(c, {⟨vpki , ui⟩}i∈I) = s
vssReconstruct(ˆc, {⟨vpki , ˆui⟩}i∈I) = ˆs
where s, ˆs (cid:44) ⊥, and if
ˇc ← vssCombineCommitments(c, ˆc)
then
vssReconstruct(ˇc, {⟨vpki ,(ui + ˆui)⟩}i∈I) = s + ˆs
An example of such a scheme is that due to Pedersen [42].
3.5 VSS Scheme with Recovery
Below we describe the procedures that make up the VSS scheme V∗.
The algorithms are expressed in terms of constants n (the number
of replicas), k (the reconstruction threshold), and ℓ = ⌈n/(k − 1)⌉.
Each share u∗
i and commitment c∗ is a zero-indexed vector of ℓ + 1
i (line 6).
vssVerify∗ and vssReconstruct∗ operate in the natural way.
elements. We denote the j-th element of each by u∗
i [j] and c∗[j],
respectively, for 0 ≤ j ≤ ℓ. Line numbers below refer to Figure 1.
vssInit∗ initializes the underlying VSS V in line 2, as well as a
DPRF F in line 3. The public key vpk∗
i for replica i consists of its
public key vpki for V and its public key dpki for F (line 7) and
similarly for the private key vsk∗
vssShare∗ is modified to take in all of the private keys {dski}i∈[n]
for the DPRF F , as well as the other arguments included in its
definition in Section 3.2. (For this reason, our construction requires
each dealer to have a distinct set of parameters for its sharings,
i.e., produced by its own call to vssInit∗.) This enables the dealer to
evaluate F itself, which it does on ⟨r, i⟩ for each i ∈ [n] (lines 10–
12), where r is a new, random κ-bit nonce (line 9). The resulting
values {yi}i∈[n] are divided into ℓ groups of size k − 1, each group
being used to construct a set of k − 1 points Pointsj ← {⟨i, yi⟩ |
(j − 1)(k − 1) < i ≤ j(k − 1)} (line 14) on which vssMakeSecret is
invoked (line 15). The resulting sj ∈ Zq[x] is then shared using
V (line 16). Recall that by the definition of vssMakeSecret, each
u∗
i [j] thus produced satisfies u∗
i [j] = yi. Of course, the input secret
s is also shared (line 17). The results of these sharings are grouped
according to replica index i and returned as u∗
i for each i ∈ [n],
along with all of the sharing commitments c∗ and the nonce r
(line 18).
vssVerify∗ verifies the commitment c∗[0] and share u∗
i [0] (line 21)
produced in the sharing of s, as well as verifying the commitment
c∗[j] and share u∗
i [j] (line 28) produced in the sharing of sj. In
addition, it verifies (intuitively) that u∗
i [j] = yi (line 25). The latter
two verifications are skipped if u∗
i [1] = ⊥ (line 23), which occurs
i was recovered (see below). In this case, u∗
if the share u∗
i [j] = ⊥
for all j ∈ [ℓ] (or should be, and so any j ∈ [ℓ] for which u∗
i [j] (cid:44) ⊥
is just ignored). vssReconstruct∗ simply uses vssVerify∗ to verify
i provided as input (line 33) and then submits c∗[0]
each share u∗
and the inputs {⟨vpki , u∗
i [0]⟩}i∈I to vssReconstruct to reconstruct
s (line 36).
i , ˆi) is invoked at replica i to
construct its contribution to enable replica ˆi to reconstruct its
share u∗
i [j] (line 41)
ˆi
where j ← ⌈ˆi/(k − 1)⌉. Then, so that replica ˆi can recover its share
of the original secret, replica i also returns its share of the DPRF
scheme F evaluated at ⟨r, ˆi⟩ (line 39).
i , ˆi) is executed by replica ˆi to
verify that replica i performed vssRecoverContrib∗ correctly. The
output of vssRecoverContrib∗ contributed by replica i is passed into
vssRecoverVerify∗ as v∗
i and is parsed into its constituent compo-
nents in line 44. First, the DPRF contribution di is checked on line 46
to ensure that it corresponds to a correct evaluation of the DPRF
scheme F at the point ⟨r, ˆi⟩. vssRecoverVerify∗ then combines the
commitments (line 48) and uses vssVerify (line 49) to check that
the blinded share u was created correctly. If both checks pass, then
vssRecoverVerify∗ returns true.
i , v∗
) is executed at replica
ˆi to recover its share u∗
[0] will be a share of the orig-
ˆi
inal polynomial for ˆi. vssRecover∗ first invokes vssRecoverVerify∗
to make sure that the share sent by each replica i ∈ I is correct
. vssRecoverContrib∗ returns u∗
vssRecoverContrib∗(c∗, r, vsk∗
vssRecoverVerify∗(c∗, r, v∗
vssRecover∗(c∗, r, {⟨vpk∗
i ⟩}i∈I , ˆi, vpk∗
ˆi
. In particular, u∗
ˆi
i [0] blinded by u∗
i , vpk∗
i , u∗
⟨q, {⟨vpki , vski⟩}i∈[n]⟩ ← vssInit(1κ , k, n)
⟨{⟨dpki , dski⟩}i∈[n]⟩ ← dprfInit(1κ , k, n, {0, 1}κ × [n], Zq)
for i ∈ [n] do
vpk∗
vsk∗
i ← ⟨vpki , dpki⟩
i ← ⟨vski , dski⟩
i , vsk∗
1: procedure vssInit∗(1κ , k, n)
2:
3:
4:
5:
6:
7:
8: procedure vssShare∗(s, q, {dski}i∈[n], {vpk∗
9:
10:
11:
12:
return ⟨q, {⟨vpk∗
i ⟩}i∈[n]⟩
$← {0, 1}κ
r
for i ∈ [n] do
⟨vpki , dpki⟩ ← vpk∗
yi ← dprfEval(⟨r, i⟩, {dprfContrib(dskˆi , ⟨r, i⟩)}ˆi∈[n])
Pointsj ← {⟨i, yi⟩ | (j − 1)(k − 1) < i ≤ j(k − 1)}
sj ← vssMakeSecret(q, Pointsj)
⟨c∗[j], {u∗
i [j]}i∈[n]⟩ ← vssShare(sj , q, {vpki}i∈[n])
for j ∈ [ℓ] do
i