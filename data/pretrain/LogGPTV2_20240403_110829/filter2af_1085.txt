CTF比赛中C++的题越来越多，题目中经常出现`string`，`vector`等，而实际上手时发现常常迷失在"库函数"中，比如跟进了空间配置器相关函数
最近研究一下关于这些的底层机制与逆向，应该会写成一个系列
# string
## 内存布局
`visual studio`的调试实在是太好用了，因此用它举例
定义一个`string`类，字符串为`abcd`，内存布局如下
其中，`size`是当前字符串长度，`capacity`是最大的容量
可以发现，`capacity`比`size`大的多
而`allocator`是空间配置器，可以看到单独的字符显示
原始视图中可以得知，字符串的首地址
可以看到，`abcd`字符串在内存中也是以`\x00`结尾的
## 扩容机制
正是由于`capacity`开辟了更多需要的空间，来具体研究一下它的策略
    #include
    #include
    #include
    #include
    using namespace std;
    int main(int argc, char** argv) {
        string str;
        for (int i = 0; i  31 -> 47 -> 70 -> 105`
注意到15是二进制的`1111`，而31是二进制的`11111`，可能是设计成这样的？...
只有第一次变化不是1.5倍扩容，后面都是乘以1.5
当长度为15时，如下，两个`0x0f`表示长度，而第一行倒数第三个`0f`则表示的是当前的`capacity`
再次`+='a'`
原先的`capacity`已经从0x0f变成了0x1f，长度也变成了16
而原先存储字符串的一部分内存也已经被杂乱的字符覆盖了
新的字符串被连续存储在另一块地址
> vs的调试中，红色代表刚刚改变的值
>
> 不过原先使用的内存里还有一些`aaaa...`，可能是因为还没有被覆盖到
## IDA视角
### 测试程序1
    #include
    #include
    using namespace std;
    int main(int argc, char** argv) {
        string input;
        cin >> input;
        for (int i = 0; i capacity`时，调用`Rellocate_xxx`函数
否则，就直接在`str_addr`后追加一个97，也就是`a`
第二块逻辑，这次因为用的是`append()`，每次追加10个字符，即使是一个`QWORD`也无法存放，所以看到的是`memmove_0`函数
最后是`v9[10] = 0`，也是我们在vs中看到的，追加后，仍然会以`\x00`结尾
> 一开始我没想明白，`+='a'`为什么没有设置`\x00结尾`
>
> 后来才发现，*(_WORD*)&str_addr[_size] = 97;
>
> 这是一个`WORD`，2个byte，考虑小端序，`\x00`已经被写入了
至于其中的`Reallocate_xxx`函数，有点复杂...而且感觉也没必要深入了，刚刚已经在vs里了解扩容机制了
最后还有一个`delete`相关的
之前在做题时经常分不清作者写的代码、库函数代码，经常靠动态调试猜，多分析之后发现清晰了不少
### 测试程序2
    #include
    #include
    using namespace std;
    int main(int argc, char** argv) {
        string input1;
        string input2;
        string result;
        std::cin >> input1;
        std::cin >> input2;
        result = input1 + input2;
        std::cout 
    #include
    using namespace std;
    int main(int argc, char** argv) {
        string input1;
        string input2;
        std::cin >> input1;
        std::cin >> input2;
        //语法糖
        for(auto c:input2){
            input1 += c;    
        }
        std::cout  这里命名应该把`input2_begin`改成`iterator`更好一些，因为它只是一开始是`begin`
## 小总结
逆向水深...动态调试确实很容易发现程序逻辑，但是有反调试的存在
多练习纯静态分析也有助于解题，看得多了也就能分辨库函数代码和作者的代码了