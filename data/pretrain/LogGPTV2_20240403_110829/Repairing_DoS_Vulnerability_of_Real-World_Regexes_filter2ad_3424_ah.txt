(NEGATIVE LOOKBEHIND)
(cid:50) is the i-th hole
((cid:50),w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) ({(p + 1,Γ,φ ∧ vw[p]
i
)},{(⊥,⊥,φ ∧¬vw[p]
i
(HOLE)
)})
(r1,w, p,Γ)(cid:59) N
w[p] ∈ C
(SET OF CHARACTERS FAILURE)
p < |w|
([C],w, p,Γ)(cid:59) {(p + 1,Γ)} (SET OF CHARACTERS)
p ≥ |w|∨ w[p] /∈ C
([C],w, p,Γ)(cid:59) /0
(ε,w, p,Γ)(cid:59) {(p,Γ)}
(cid:83)
∀(pi,Γi) ∈ N , (r2,w, pi,Γi)(cid:59) Ni
(r1r2,w, p,Γ)(cid:59)
(r2,w, p,Γ)(cid:59) N ′
(r1,w, p,Γ)(cid:59) N
(r1|r2,w, p,Γ)(cid:59) N ∪ N ′
(r,w, p,Γ)(cid:59) N
(r∗,w, p,Γ)(cid:59) {(p,Γ)}∪(cid:83)
∀(pi,Γi) ∈ (N \{(p,Γ)}), (r∗,w, pi,Γi)(cid:59) Ni
0≤i<|(N \{(p,Γ)})| Ni
(CONCATENATION)
(EMPTY STRING)
(REPETITION)
0≤i<|N | Ni
(UNION)
((r) j,w, p,Γ)(cid:59) {(pi,Γi[ j (cid:55)→ w[p..pi)]) | (pi,Γi) ∈ N } (CAPTURING GROUP)
(r,w, p,Γ)(cid:59) N
Γ(i) ̸= ⊥
(BACKREFERENCE)
(Γ(i),w, p,Γ)(cid:59) N
(\i,w, p,Γ)(cid:59) N
Γ(i) = ⊥
(\i,w, p,Γ)(cid:59) /0
N ′ = ite(N ̸= /0, /0,{(p,Γ)})
(r,w, p,Γ)(cid:59) N
((?=r),w, p,Γ)(cid:59) {(p,Γ′) | ( ,Γ′) ∈ N } (POSITIVE LOOKAHEAD)
(r,w, p,Γ)(cid:59) N
(NEGATIVE LOOKAHEAD)
(BACKREFERENCE FAILURE)
(x,w[p−|x|..p),0,Γ)(cid:59) N
(x,w[p−|x|..p),0,Γ)(cid:59) N
((?!r),w, p,Γ)(cid:59) N ′
((?<=x),w, p,Γ)(cid:59) N ′
((?<!x),w, p,Γ)(cid:59) N ′
N ′ = ite(N ̸= /0,{(p,Γ)}, /0)
(POSITIVE LOOKBEHIND)
N ′ = ite(N ̸= /0, /0,{(p,Γ)})
(NEGATIVE LOOKBEHIND)
Fig. 11: Rules of the matching relation (cid:59)
Fig. 12: Rules for generating consistency-with-examples constraints.
all j ̸= i and the positive lookahead (?=\2i− 1\2i) succeeds.
Thus, r2 is a correct repair.
We show the if direction. First, note that any valid repair of
r1 must preserve the k union choices of r11 because deleting
any union choice would already exceed the cost 2k. From this,
it is not hard to see that the only possible change is to change
the head ε in the union choices in r11. For instance, it is
useless to change [Si] to some r where L(r) contains elements
not in Si because of the 2k many (?=[Si]) preceding it. Note
that changing (?=[Si])2k would exceed the cost. Nor, can [Si]
be changed to some r where L(r) does not contain an element
of Si because of the capturing group (ε)2i and (ε)2i−1 before
and after [Si] and the check done in r12. Note that changing
any of the check in r12 would again exceed the cost. This also
shows that the capturing groups (ε)2i and (ε)2i−1 cannot be
changed. Therefore, the only meaningful change that can be
done is to change some of the head ε in r11 to some r. Note
that for any r chosen here, by the RWS1U property, r2 will not
accept {a | aw ∈ L(r)} as any input a ∈ {a | aw ∈ L(r)} would
direct the match algorithm deterministically to this choice but
the match would fail when it proceeds to [Si]. Therefore, the
only change that can be done is to change it to some r such
that L(r) = /0. Then, from a successful repair r2, we obtain the
solution S ′ to the EXACTCOVER instance where Si /∈ S ′ iff
the i-th head ε in r21 is changed to some r such that L(r) =
/0.
APPENDIX D
CORRECTNESS OF RWS1U
In this section, we show that a regex that satisfies RWS1U is
invulnerable. Before we go on with the main proof, we show
that lookaheads that satisfy RWS1U runs in constant time to
eliminate lookaheads from the later arguments.
Theorem D.1. A regex that does not contain repetitions,
unions, and backreferences runs in constant time.
Proof. We prove that, for such a regex r, the size of N where
(r,w,0, /0)(cid:59) N is constant. This proof is by induction on the
structure of the regex.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
162075
By the definition of RWS1U,
lookaheads that satisfy
RWS1U do not contain repetitions and backreferences. Hence,
lookaheads in a regex that satisfies RWS1U also run in
constant time. For this, lookarounds, lookbehinds, and empty
strings run in constant time. Also, they consume no characters.
Thus, in what follows, without loss of generality, we assume
that a regex does not contain empty strings, lookaheads, and
lookbehinds.
We map a derivation tree to a directed tree.
Definition D.1 (Directed Tree). A directed graph is a tuple
G = (V,E). Here, V is a finite set of vertices and E is a finite
set of directed edges. A vertex v = (i, p,Γ) ∈ V consists of a
unique index i and a matching result (p,Γ). A directed edge
(edge for short) e = (v1,v2) ∈ E consists of two vertices v1
(often called tail) and v2 (often called head). A directed tree
is a directed graph that is of a tree shape (i.e., has no cycles
and |E| = |V|− 1.).
We define the size of a directed tree G = (V,E) as the
size of E, i.e., |G| = |E|. We use the notation din(v) = |{v′ |
(v′,v) ∈ E}|, dout (v) = |{v′ | (v,v′) ∈ E}|, leaf(G) = {v | v ∈
V ∧ dout (v) = 0}, root(G) = v such that v ∈ V ∧ din(v) = 0,
tail(e) = v and head(e) = v′ for an edge e = (v,v′), and E(v),
where v ∈ V , for a set of heads, i.e., E(v) = {v′ | (v,v′) ∈ E}.
For a tuple t = (t1,··· ,tn), we write #i(t) for ti, where 1≤ i≤ n.
We define a construction AtoG from a derivation tree A
to the directed tree G as follows: Here, id() returns a fresh
identifier, and, a := b means that a is replaced with b. For
a directed tree G = (V,E) and G′ = (V′,E′) such that V ∩
V′ = /0 and v ∈ leaf(G), we write G[v (cid:55)→ G′] for the graph
(V ∪V′ \{v},E ∪ E′ ∪{(v′, root(G′))}\{(v′,v)}) where v′ is
the unique vertex such that (v′,v) ∈ E. I.e., G[v (cid:55)→ G′] is the
graph obtained by replacing the leaf v of G by (the root of)
G′. Additionally, we assume that Gi = (Vi,Ei).
• Case (SET OF CHARACTERS). G = ({v1,v2},{(v1,v2)}),
OF
(SET
• Case
CHARACTERS
(pi,Γi) ∈ N ,
FAILURE).
v1 = (id(), p,Γ)
where v1 = (id(), p,Γ) and v2 = (id(), p + 1,Γ).
G = ({v1,v2},{(v1,v2)}), where
and v2 = (id(), /0,Γ).
• Case (CONCATENATION). Let G1 = AtoG((r1,w, p,Γ)(cid:59)
N ). For all
there exists a vertex
( , pi,Γi) ∈ leaf(V ). For all ( , pi,Γi) ∈ leaf(V ), let G2i =
AtoG((r2,w, pi,Γi) (cid:59) Ni), G1 := G1[( , pi,Γi) (cid:55)→ G2i].
G = (V1∪{v},E1∪{(v, root(G1))} where v = (id(), p,Γ).
• Case (UNION). Let G1 = AtoG((r1,w, p,Γ) (cid:59) N )
and G2 = AtoG((r2,w, p,Γ) (cid:59) N ′). G = (V1 ∪ V2 ∪
{v},E1 ∪ E2 ∪ {(v, root(G1)), (v, root(G2))}), where v =
(id(), p,Γ).
• Case (REPETITION). Let G1 = AtoG((r,w, p,Γ) (cid:59) N ).
For all (pi,Γi) ∈ N , there exists a vertex ( , pi,Γi) ∈
leaf(V1). For
let G2i =
AtoG((r∗,w, pi,Γi) (cid:59) Ni), G1 := G1[( , pi,Γi) (cid:55)→ G2i].
G = (V1 ∪{v1,v2},E1 ∪{(v1,v2), (v1, root(G1))}), where
v1 = (id(), p,Γ) and v2 = (id(), p,Γ).
• Case (CAPTURING GROUP). Let G1 = AtoG((r,w, p,Γ)(cid:59)
N ). G = (V1 ∪{v},E1 ∪{(v, root(G1))}).
( , pi,Γi) ∈ lea f (V1),
all
• Case
G1
=
(BACKREFERENCE).
Let
• Case
AtoG((Γ(i),w, p,Γ) (cid:59) N ). G = (V1 ∪ {v},E1 ∪
{(v, root(G1))}) where v = (id(), p,Γ).
(BACKREFERENCE
({v1,v2},{(v1,v2)}), where
v2 = (id(), /0,Γ).
v1 = (id(), p,Γ)
G =
and
FAILURE).
Lemma D.1. Given a derivation tree (r,w,0, /0)(cid:59) N . Let A
be the derivation tree and G = AtoG(A) be the directed tree.
The size of the derivation tree A is greater than or equal to
the size of the directed tree G.
Proof. The proof is by induction on the structure of A.
Definition D.2 (Main and Sub Branch). Let G = (V,E) be
a directed tree. For each vertex v ∈ V , we say an edge e ∈
E(v) is a main branch of v if ∀e′ ∈ E(v)\{e},#2(head(e′)) <
#2(head(e)). Otherwise, we say the edge is sub branch of v.
Definition D.3 (Main Path). We say a sequence of main
branches pm = e1e2···en is a main path if head(ei) = tail(ei+1)
for 1 ≤ i < n, tail(e1) is a root, i.e., din(tail(e1)) = 0, and, for
every e ∈ E(head(en)), e is a sub branch.
By the definition of the main path, there is at most one main
path in a directed tree.
Lemma D.2. Given a directed tree G = (V,E), which is
obtained by AtoG((r,w,0, /0) (cid:59) N ). If G has a main path
pm, then the length |pm| is O(|w|).
Proof. By induction on the structure of r. The only interesting
case is when r is a repetition, say, r = r′∗. We show that
r′∗ consumes at most O(|w|) characters during the whole
matching. Let n be the number of iterations of r′∗ on w[p1..|w|)
and (r′∗
,w, pi,Γi)(cid:59) Ni be the i-th iteration, where 1 ≤ i ≤ n.
Let e1e2···en be the main path. For 1 ≤ i < n, #2(tail(ei)) <
#2(head(ei)) because if tail(ei) = head(ei), then it means that
r′ accepts an empty string and so it violates RWS1U because
there are two or more paths to the first alphabet in r′ or the
next expressions. Hence, #2(tail(ei)) < #2(head(ei)) and r′∗
consumes at most O(|w|) characters.
Definition D.4 (ε Subtree). Let G = (V,E). We say a subtree
Gε = (Vε ,Eε ), where Vε ⊆ V and Eε ⊆ E, is an ε subtree if
every e ∈ Eε is a sub branch, |Eε (root(Gε ))| = 1, #2(tail(e)) =
#2(head(e)) or #2(head(e)) = /0 for every e ∈ {(v,v′) ∈ Eε |
v ̸= root(Gε )}, and, for every v1,v2 ∈ Vε, where v1 ̸= v2, there
exists a sequence of Eε edges e1e2···en such that tail(e1) = v1,
head(en) = v2, head(ei) = tail(ei+1) for 1 ≤ i < n.
Lemma D.3. Given an ε subtree Gε in AtoG((r,w, p,Γ) (cid:59)
N ). The size of the ε subtree |Gε| is constant.
Proof. Suppose that |Gε| is not constant. Then, r contains
a repetition r′∗ and the repetition r′∗ iterates at least twice
because, if not, then the size is O(|r|), i.e., constant. By the
definition of ε subtrees, the repetition r′∗ does not consume
any character and this means that r′ accepts an empty string.
However, it means that the repetition r′∗ violates the RWS1U
condition because there are two or more paths to the first
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
172076
it is vulnerable as we have shown in Section III-B. Conse-
quently, synthesizing deterministic regexes is insufficient for
guaranteeing ReDoS invulnerability.
character in r′ or the next expression. Thus, r′∗ iterates at
most once. Hence, |Gε| is constant.
Lemma D.4. Let G = AtoG((r,w, p,Γ) (cid:59) N ). Then the
number of ε subtrees in G is O(|w|).
Proof. We show that the number of ε subtrees is O(|pm|), i.e.,
O(|w|). The proof is by induction on structure of derivation
trees. Here, we only focuses on the case (REPETITION). In the
case of (REPETITION), let m be the number of iterations of
(r′∗
,w, p′,Γ′)(cid:59) N ′. For the i-th iteration, let (r′,w, pi,Γi)(cid:59)
i , where 1 ≤ i ≤ m, p1 = p′, and Γ1 = Γ′. Then, by inductive
N ′
hypothesis, each derivation tree (r′,w, pi,Γi) (cid:59) N ′
satisfies
Lemma D.5. Let G = (V,E) = AtoG((r,w,0, /0)(cid:59) N ). For all
edges e ∈ E, e belongs to either a main path or an ε subtree.
Proof. The proof is by induction on the structure of derivation
trees.
the assertion. Hence, the assertion holds.
i
Theorem D.2. Given a directed tree G = (V,E). The size of
the directed tree |G| is O(|w|).
Proof. By Lemma D.5, G consists of a main path and ε
subtrees. By Lemma D.2, the size of the main path is O(|w|).
By Lemma D.3, the size of the ε subtrees is O(1), and by
Lemma D.4, the number of ε subtrees is O(|w|). Hence the
size of G is O(|w|× 1 + 1×|w|) = O(|w|).
Finally, we are now ready to proof Theorem IV.1.
Proof. (Proof of Theorem IV.1) Immediate from Lemma D.1
and Theorem D.2.
APPENDIX E
INSUFFICIENCY OF DETERMINISTIC REGEXES
The details of why [24] is insufficient for guaranteeing
unambiguity is as follows. The idea of [24] for repairing
ReDoS-vulnerability is to synthesize so-called “deterministic”
(also called 1-unambiguous [28], [29]) regexes. The definition
of deterministic regex is as follows:
Definition E.1 (Deterministic, Definition 2.1 in [28], [29]). A
regex E is deterministic (or 1-unambiguous) iff, for all words
u,v,w ∈ Π∗ and all symbols x,y ∈ Π,
uxv,uyw ∈ L(E′)∧ x ̸= y ⇒ x♮ ̸= y♮.
Here, Π is the subscripted alphabet {ai | a ∈ Σ,i ∈ N}, x♮
is the character obtained by dropping the subscript of x ∈ Π
(e.g., (a1)♮ = a), and E′ is E but with each characters in E
annotated with distinct subscripts (e.g., if E = ab(a|b)c, then
E′ = a1b1(a2|b2)c1).
Intuitively, a regex E is deterministic iff for any w ∈
there is a unique subscripted word v ∈ L(E′) such
L(E),
that v♮ = w. Thus, the vulnerable regex E = (a∗)∗ satisfies
the definition because its subscripted regex E′ is (a∗
1)∗ and
L(E′) = {ε,a1,a1a1, ...} (i.e., there are no uxv,uyw ∈ L(E′)
such that x ̸= y). Hence, (a∗)∗ is a deterministic regex while
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
182077