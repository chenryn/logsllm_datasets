    |      ; const char * s                       |                                
    |      ; 0x8a4                                |                                
    |      ; "Need exactly one argument."         |                                
    | lea rdi, str.Need_exactly_one_argument.     |                                
    | call sym.imp.puts;[gh]                      |                                
    |    ; -1                                     |                                
    | mov eax, 0xffffffff                         |                                
    | jmp 0x7c6;[gg]                              |                                
    `---------------------------------------------'
这就是我们刚刚分析的块。使用键盘方向键键跟随蓝色（无条件）箭头向下看看这个块之后会发生什么。您会在底部看到一个0x7c6的块，这个块可以从程序中的许多位置无条件地跳转到：
    add rsp, 0x10                                                      
    pop rbx                                                 
    ret
这里释放堆栈空间并返回。所以这个程序的行为与我们看过的其他程序一样：如果没有正确数量的参数，它会打印一个字符串并退出，返回错误代码（`eax`加载了-1）。
> **亲自尝试一下** ：在控制流程图中查看程序的其余部分，找到打印失败消息的块，有两个判断可以通向那里。您能弄清楚它们做了什么吗？  
>  回想一下，`test eax,eax`紧接着`je`表示“如果`eax`为零则跳转”。x86指令集有详细的文档，如果您不知道指令的作用，请查阅！
如果我们从第一个块向下进入没有执行`jne`的红色分支（即正好有2个字符串传递给二进制文件），您将看到在0x754的这些指令：
    mov dword [local_9h], 0x426d416c ; [0x426d416c:4]=-1
    mov word [local_dh], 0x4164 ; [0x4164:2]=0xffff
    mov byte [local_fh], 0
    mov word [local_6h], 0
    mov byte [local_8h], 0
    mov byte [local_2h], 2
    mov byte [local_3h], 3
    mov byte [local_4h], 2
    mov byte [local_5h], 3
    mov byte [local_6h], 5
    mov rbx, qword [rsi + 8]    ; [0x8:8]=0
    mov eax, 0
    mov rcx, 0xffffffffffffffff
    mov rdi, rbx
    repne scasb al, byte [rdi]
    cmp rcx, 0xfffffffffffffff8
    je 0x7df
这个块一大部分的工作是将一堆值加载到内存中。这里Radare不是显示实际地址，而是根据其堆栈偏移命名每个局部变量。向上滚动到最开始的块，我们可以看到`local_2h`到`local_fh`都是`int`类型（至少Radare认为是这样），并且它们都是一个字节大小。
在把这些值加载到局部变量之后，它将地址`rsi +
8`的内存加载到`rbx`中。回想一下x86_64调用约定，`rsi`是第二个命令行参数：`argv`。所以`rsi +
8`是`argv[1]`。然后它给`rax`载入0，`rcx`载入`0xffffffffffffffff`，`rdi`载入`rbx`的值，该值刚刚从`argv[1]`得到。
然后它运行`repne scasb`指令。这是x86的一个奇怪但快速的指令：它是一个获得字符串长度的 _原生指令_
。`repne`表示在不相等时重复执行（`rep`eat while `n`ot
`e`qual），`scasb`表示按字节扫描和比较——有关详细信息，请参阅[此处](http://www.felixcloutier.com/x86/SCAS:SCASB:SCASW:SCASD.html)。
因此，该指令将各字节与`al`的值（此处为0）依次进行比较，从`rdi`中的存储器地址开始，并对`rdi`进行累加，同时从`rcx`中减去1（`rcx`中的“C”是指计数counter寄存器）。实际上这个指令是计算字符串的长度。x86是不是很有趣？
不管怎样，一旦完成`repne
scasb`操作，`rcx`将存储着0xffffffffffffffff减去字符串的长度。我们可以看到下一条指令将它与0xfffffffffffffff8进行比较。因此，如果字符串长度是0xffffffffffffffff
- 0xfffffffffffffff8 = 7字节（包括终止字符），则跳转，否则不跳转。
如果不进行跳转，则流程进入到0x7a8处的块，会打印失败字符串。因此，我们可以确定正确的密码恰好是6个字节（要去掉终止符）。
### 函数
更有趣的是进行跳转的部分。
    lea rdx, [local_2h]
    lea rsi, [local_9h]
    mov rdi, rbx
    call sym.check_pw
    test eax, eax
    je 0x7a8
程序加载一些局部变量的地址，还有`argv[1]`（记得吗？它被存在`rbx`中），然后调用一个函数：`sym.check_pw`。当然，二进制文件中只存有函数的偏移量，但Radare可以在符号表中查找这个偏移量并把它替换为函数名称。`check_pw`看起来相当有意思，根据名称我们可以知道：在调用函数之后，如果函数返回零，程序跳转到失败分支，如果不为零，则继续进入成功分支（回想一下，`test
eax,eax`表示如果`eax`为零，则执行`je`跳转）。
那么这个函数到底是做什么的呢？
先回想一下x86_64调用约定。`rdi`，`rsi`和`rdx`（在调用之前赋值的三个寄存器）是函数的前三个参数。所以在C中，调用看起来像这样：
    int result = check_pw(argv[1], &local_9h, &local_2h);
    if (result == 0) {
        // 失败
    } else {
        // 成功
    }
那么问题就转换为`check_pw`究竟做了什么？为了弄明白这个，我们需要退出视觉模式（连按两次`q`），并进入这个函数（`s
sym.check_pw`），然后查看流程图（`VV`）。
很明显，这个函数包含一个循环。`main`函数里无论怎么跳转流程都会一直向下进行，而在`check_pw`中，靠近底部的一个块有一个跳到顶部的`jne`指令。再仔细一点看，我们可以发现有三个地方会返回。其中一个（在0x73e处）返回0（失败），另外两个（在0x744和0x748处）返回1（成功）。
这种高级分析只能通过流程图进行，并且这是使用Radare等工具的主要优势之一。刚接触逆向工程时，我亲手绘制流程图，是因为我不知道这些免费工具的存在。不要那样做，很浪费时间。
这个函数首先赋值一个64位通用寄存器`r8d`，其值为0。然后跳转到下一个块（0x716）：
    movsxd rax, r8d
    movzx ecx, byte [rdx + rax]
    add cl, byte [rsi + rax]
    cmp cl, byte [rdi + rax]
    jne 0x73e;[gb]
这个块将`r8d`（其中是零）赋值给`rax`，然后从函数的第三个参数加载一个字节，由`eax`索引。回到我们的参数列表，这个参数是`&local_2h`，所以它加载了`(&local_2h)[0]`。
然后程序把它与用`eax`索引的第二个参数中的一个字节（`(&local_9h)[0]`）相加，并将起与用`eax`索引的第一个参数中的一个字节（`argv[1][0]`）进行比较。注意这是一个循环，所以`eax`会改变。换一种说法：
    while (/* 一些条件？？ */) {
        char temp  = arg3[eax] + arg2[eax];
        if (temp != arg1[eax]) {
            return 0; // 失败
        }
    }
如果跳转不执行，代码会来到0x725处：
    add r8d, 1
    movsxd rax, r8d
    cmp byte [rsi + rax], 0
    je 0x744;[gd]
这里会增加循环计数器，检查用循环计数器索引的第二个参数的那个字节是否为零。如果是，它会跳转到返回成功的代码（0x744）。否则，它继续循环。更新的C代码如下所示：
    while (arg2[eax] != 0) {
        char temp  = arg3[eax] + arg2[eax];
        if (temp != arg1[eax]) {
            return 0; // 失败
        }
        eax++;
    }
    return 1;
这样就能很容易看出`check_pw`在做什么：它比较两个字符串，但它逐个地修改了其中一个字符串的字符。
看看`main`中传递给函数的参数，我们可以看到这个程序把`(&local_2h)[eax]`和`(&local_9h)[eax]`相加。可以回到`main`函数（退出可视模式，执行`pdf@main`）来查看每个值的内容。
这两个变量都在堆栈上。我们之前知道`check_pw`只会在一个含有6个字符的字符串上被调用，因此我们只需要查看6个值。这是`local_2h`之后的值（您可以看到它们在`main`中被赋值）：2,3,2,3,5。这只有5个值，是怎么回事？
我们再看一遍，堆栈变量的赋值从地址0x754开始：
    mov dword [local_9h], 0x426d416c ; [0x426d416c:4]=-1
    mov word [local_dh], 0x4164 ; [0x4164:2]=0xffff
    mov byte [local_fh], 0
    mov word [local_6h], 0
    mov byte [local_8h], 0
    mov byte [local_2h], 2
    mov byte [local_3h], 3
    mov byte [local_4h], 2
    mov byte [local_5h], 3
    mov byte [local_6h], 5
在按顺序将字节大小的值移入`local_2h`到`local_6h`之前，`local_6h`（即`rsp +
0x6`）被载入一个字（word）大小的0（这是Intel语法，所以一个字是16位。请参阅[这里](https://en.wikipedia.org/wiki/Word_%28computer_architecture%29#Size_families)）。这就是说`rsp
+ 0x6`和`rsp + 0x7`都被置为零。
注意，Radare完全没有意识到这些值是在一个数组中，更不要说告诉我们它被初始化了什么值，尽管它完全是静态的数组。这是需要人脑进行逆向工程的一个部分。计算机知道那些地址里有什么数据，但它无法知道它们的用途。
总之，我们从`local_2h`开始的值表是`[2,3,2,3,5,0]`。这些不是可打印的ASCII字符，因此硬编码的密码可能存储在另一个参数中：`local_9h`。
最上方的`mov`指令移动了一个双字（dword），这是一个32位的值，接下来是一个字（word）大小的值，然后是一个字节大小的零。这有4 + 2 =
6个字节，加上一个空终止符，所以这三个指令一起组成了一个字符串。 如果我们按字节分隔并写出这些值，则更明显一些：`42 6d 41 6c 41 64
00`。这很明显是以空字符结尾字符串的格式，其值都在可打印的ASCII范围内。
剩下的就是为它们添加偏移量，就得到`44 70 43 6e 44 64 00`。将这些字节转换为ASCII字符，我们得到：`DpCnDd`。
很明显，只要将字符串输入二进制文件……失败了。怎么回事？
> **亲自尝试一下** ：为什么会这样？这和x86组织数据的方式有关，很基础的知识。
原因是x86处理器是小端序的。也就是在多字节值中需要从右到左读取字节，而不是从左到右。只需翻转`local_9h`和`local_dh`的顺序就可以轻松纠正这个问题。`42
6d 41 6c`变为`6c 41 6d 42`；`41 64`变为`64 41`。我们的整个字符串变为`6c 41 6d 42 64 41
00`，正确的字符串变为`6e 44 6f 45 69 41 00`，ASCII字符是`nDoEiA`。
恭喜您完成本教程的这一部分。您现在已经拥有了静态逆向工程所需的所有技术！不要忘记通过做练习来巩固你的技能。
## crackme04.c
现在您已经知道了对这些CrackMe进行逆向工程所需的所有工具和技术，我只是要强调每个CrackMe中最重要的部分。解决crackme04可以使用与之前一样的基本过程：在Radare中打开它，运行分析，并进入`main`函数。流程图可以引导您进入代码的核心循环，如下所示：
    movsx eax, al
    add esi, eax
    add ecx, 1
    movsxd rax, ecx
    movzx eax, byte [rdx + rax]
    test al, al
    jne 0x72e;[ge]
如果`al`（输入字符串中的一个字节）不为零，那么跳转返回到顶部。否则将`ecx`与0x10进行比较，如果不相等则失败退出。如果相等则进行另一个检查：如果`esi`不等于0x6e2，则跳转到失败，如果相等，则检查成功。
那么`ecx`和`esi`里面是什么？很容易看出`ecx`是一个计数器。在每次循环迭代中它会递增，并用于索引输入字符串。因此，在循环完成后，它等于字符串中非零字节的数量。
`esi`仅在循环中的一行被修改：它是字符串中字符数值的总和。它后来与0x632进行了比较（译者注：这里应该是0x6e2而不是0x632，应为作者笔误）。所以我们需要一个16字符的字符串，其总和为0x6e2（1762）。
我的方法是简单地做除法然后最后一个字符添加它的余数。1913除以16等于110余数2（译者注：应该是1762而不是1913，又一处笔误），所以我们使用字符110（'n'），然后接上一个112（'p'）：`nnnnnnnnnnnnnnnp`。
# 附录
## Makefile
使用的Makefile相当简单，但可能有一些难以理解的地方。其中最主要的是在编译后的可执行文件上使用objcopy。我用它来去除FILE符号，否则Radare会利用这个符号在反汇编旁边显示源代码，完全练习达不到练习的目的。
## 练习
命名为`crackme01e.c`，`crackme02e.c`等等的文件是其没有e后缀的对应文件的修改版本。它们用于练习，可以用与本教程各个部分中提到的完全相同的技术来解决。如果您在继续下一个部分之前先解决它们，您将获得更好的体验。
## 媒体报道
2018年1月6日星期六：本教程在Hackaday上被发布，导致我的服务器短暂地宕机。从那里来的朋友们你们好。请看看我的其他教程，如果您想要我创建更多这样的内容，请支持我的[Patreon](https://leotindall.com/)。