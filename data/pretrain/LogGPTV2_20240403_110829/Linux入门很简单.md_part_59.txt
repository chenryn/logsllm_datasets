tar就是个打包裹的，不过他可不是邮递公司的那种，不会把打好的包扔来扔去。他的能力有点像Windows
7那里的WinZip，他能把很多文件和目录收拾在一起，打成一个包裹，也就是生成一个tar包文件。
![alt](images/00011.jpeg){.tpzz}**提示：**[过去的计算机使用磁带作为长期存储数据的介质（现在依然有使用磁带作为存储介质的场合），tar命令最初就用于将数据打包存储在磁带上。tar就是Tape
Archive（磁带归档）的缩写。]{.kai1}
可是跟WinZip不一样的是，tar只管打包，不管压缩。原来那些零碎的小文件有多大，打成tar包之后还是多大，只是变成一个整个的文件了而已。有人说，那我想压缩怎么办？别急，我这里还有另一个软件，叫gzip。这个软件就是专门负责压缩和解压缩的，但是他只能压缩单个文件，不能像WinZip那样能压缩一个目录里的很多文件。
这样，tar和gzip就成黄金搭档了。要想实现WinZip那样的功能，就得tar和gzip联手协作。比如有个目录叫aaaa，里面有好几十个文件，总共有10
MB大小。想要压成ZIP那样的压缩包，那就先让tar出手，把aaaa目录打成一个包裹文件------因为gzip只能压缩单个文件嘛。这样tar就把这个目录打成了aaaa.tar文件，这个文件还是10
MB大。然后由gzip出场，把这个文件压缩，压缩完了得标明一下啊，所以就又把文件名改了，叫做aaaa.tar.gz，表示这个文件经过了gzip压缩。这时候这个文件就小了，可能5
MB，也可能7
MB。有时候还有叫xxx.tgz的包，也是一个意思，只是把.tar.gz的扩展名合并了而已。
[8.5 规划局]{.kai}
configure脚本也好，Makefile文件也好，其写法都是有一定规律可循的。并且他们的内容都是有一定复杂度的。对于有规律还复杂的东西，就可以想办法让程序自动实现。
8.5.1 懒蜗牛的日记E
"2010年12月20日 回冷
总算是把代码发布到网上了。很多热心的网友提出了不错的建议和意见。才发现我写出来的程序真的很白痴。经过了这么一个过程，确实在编程方面长进了不少，了解了很多以前不了解的事情。
还有件最不了解的事，就是configure脚本。好几万行的代码啊！牛人们是怎么写出来这么复杂的脚本的？而且好像很多源码包里的configure脚本都差不多，难道都是一个专门给别人写脚本的大牛写的？不解中......"
8.5.2 自动生成的configure脚本
懒蜗牛的rubbish
1115号放到网上去之后，网络上的众多牛人们，为他修改了很多问题，把他调教得规规矩矩的。现在的rubbish
1115号，也不浪费内存了，也不乱改文件了，也不死机了，腰不酸了，背不疼了，现在我们都开始喜欢这个家伙了。他好，我们也好。这大概就是开源的力量吧。我们现在都不好意思叫他rubbish了，直接叫1115号。
【3万行的脚本真不是人写的】
1115号发布前的那段时间，我们几个软件都很纠结，担心懒蜗牛运行他，担心系统被他搞坏。那时候懒蜗牛也很纠结，纠结的是怎么能够把他发布到网上去。
那时候懒蜗牛整天研究Shell编程的技术，天天对着那3万多行的configure代码，出神地看着，嘴里念叨着："这是哪位神仙大姐写的脚本啊......这么多行得写多长时间啊......"直到有一天，他终于将眼睛聚焦在了configure文件前面的那段注释中的一句话：
![alt](images/00484.jpeg){.calibre3}
懒蜗牛顿时如醍醐灌顶一般，看着这一行注释，看着这个"Autoconf"，心里反复地呼喊，声音越来越强烈，直到终于爆发，脱口而出："原来这脚本是用软件自动生成的啊！"顿悟之后懒蜗牛立刻叫来狐狸，本着"内事不明问老婆，外事不明问Google"的宗旨，直奔www.google.com而去。
【3万行的脚本到底是谁写的】
一番查找后，懒蜗牛终于大致了解了Autoconf这个软件。
咱说gcc、cpp、as和ld他们4个命令就像施工队，make就是包工头，configure就是分析师，那这个Autoconf大概就是市政规划局了。有了他，什么Makefile，configure脚本，全都不用自己写，都由他一手代办。
规划局的工作，就是根据源代码的结构和组成，来决定如何根据环境，因地制宜、就地取材地施工，最终派出一个专门的分析师------也就是configure。之后在安装的时候，configure就可以根据目标系统的环境及既定的几套施工方案，来写出合适的Makefile，再交给那里的make去指导施工。
8.5.3 规划局的成员组成
虽然软件叫做Autoconf，但其实并不是只有他一个人。既然叫做规划局，那就不可能是一个人，你见过哪个地方的规划局就一个局长了？他们这规划局成员有4个：Aclocal、Autoconf、Automake、Autoscan。要想自动创建Makefile和configure脚本，就得跟这哥儿4个说。虽然可能你已经自己写了Makefile了，只是缺少configure。但你写的那个不行，他们向来是买一送一，搭配销售。你写的Makefile是没用的，必须得用他们创作的configure和Makefile，具体情况咱们待会儿再说。
这4个人各有各的工作，各司其职：Autoscan负责检查源码目录结构，看看都有哪些需要编译的文件；Aclocal用于检测一些编译环境相关的内容，例如使用哪个编译器；Autoconf负责生成configure脚本；Automake负责生成Makefile的蓝本------makefile.in。
8.5.4 图纸审查
经过一番查找，懒蜗牛同学已经了解了Autoconf这一组软件的使用了，现在他要开始为他的程序加入configure脚本和Makefile了。
首先，懒蜗牛来到存放1115号源码的那个目录，目录里现在有main.c、board.c、ai.c、board.h和ai.h几个文件（1115号已经被网络上的热心爱好者们改装得很精简了）。然后懒蜗牛运行了这个命令：
![alt](images/00485.jpeg){.calibre3}
那么"autoscan"这个命令是干什么呢？
【Autoscan的职能】
Autoscan是负责初步审查项目的。你的工程图纸画好了，得先拿给他看。他看了一遍之后，会给你写个报告。怎么还写报告？当然了，规划局嘛，审批个这处理个那的，不都是部门之间报告来、报告去的么。Autoscan写的这个报告叫做confiugre.scan。
但是这个Autoscan写的confiugre.scan报告，基本上是驴唇不对马嘴。Autoscan这家伙，要论本事，抬举他点说是一般。图纸他都不一定看得懂。所以多数情况下，还得动手改改。改过的报告还得改个名字，叫做configure.in。
正说着，只见Autoscan同学大摇大摆地来到1115号的源码目录，东瞅瞅，西看看，挨个打开每一个文件，终于搞清楚了各个文件之间的关系。然后他按照一套很官方的格式，写了初步审核报告书，存了个文件名叫做configure.scan的文件，之后就回去睡觉去了。报告书的内容大约是这样：
![alt](images/00486.jpeg){.calibre3}
【修改报告】
懒蜗牛拿到报告书，当然知道，这只是万里长征才走完了第一步。赶紧叫来gedit小弟，修改报告书。他把一些完全不着边际的东西删掉，或者注释掉（也就是在那一行的前面加上#号）修改后的报告书是这个样子的：
![alt](images/00487.jpeg){.calibre3}
看着挺多，其实真正有用的就下面这么几行。
![alt](images/00002.jpeg){.tpzz} AC_INIT(main.c)------这一句说明这个工程的主要图纸是哪个文件。
![alt](images/00002.jpeg){.tpzz} AM_INIT_AUTOMAKE(rubbish1115,1.0)------这一行是汇报这个项目的名称，叫做rubbish1115，版本是1.0版。
![alt](images/00002.jpeg){.tpzz} AC_PROG_CC------这一句是说，最终的configure需要检查C语言编译器是否正常。
![alt](images/00002.jpeg){.tpzz} AC_OUTPUT(Makefile)------这一行是说明，最终的configure需要产生的文件，叫做Makefile。
其他的，都是废话。
8.5.5 项目复审
懒蜗牛同学把改好的报告改名为configure.in，然后就去叫Aclocal来看报告了。也就是运行了这个命令：
![alt](images/00488.jpeg){.calibre3}
【Aclocal的职能】
Aclocal负责复查Autoscan的报告，并且根据里面的内容，做一些详细的注解和说明。并且把这些注解和说明也写成一个报告，叫做aclocal.m4。
这里所谓的说明，主要是针对configure.in中的一些宏定义，进行详细的阐述。比如configure.in中写的"AC_PROG_CC"，只是说明了在最终的configure脚本中，要加入检查编译器的部分。但是编译器怎么个检查法？检查哪个编译器？都没说明白。这些在Aclocal的报告中都会有详细的解释------编译器要使用GCC，configure脚本中，要检测系统是否有GCC编译器。
随着懒蜗牛按下回车键，只见硬盘中的Aclocal不紧不慢地起床，伸着懒腰走进工作间，拿起桌上的茶水杯，掀开杯盖，撇一撇浮在水面上的茶叶，拿嘴吹一吹，喝一口，盖上杯盖，放下杯子，开始看报告。扫了两眼后，就知道是怎么回事了，也不用懒蜗牛多说话，直接写了一份复查报告，叫做aclocal.m4，扔给了懒蜗牛，然后就赶紧回去继续睡觉去了。要说人家Aclocal的办事效率还真是不错，毕竟人家写的aclocal.m4不用懒蜗牛修改，直接就可以往上交了。
8.5.6 派遣分析师
主要领导终于出场了，懒蜗牛赶紧又叫来Autoconf，让他指派分析师configure。也就是运行了这个命令：
![alt](images/00489.jpeg){.calibre3}
【Aotuconf的职能】
Autoconf就是专门负责指派分析师。他看了两份报告后，一般会沉思一会儿，说说目前如何困难，人手不足之类的话。最终在用户一再的苦苦哀求，以及威逼利诱之下，无可奈何地说：好，就给你派个分析师吧！如果顺利，一个configure脚本就诞生了。
不过懒蜗牛遇到的Autoconf这回倒是没太耽搁，看了configure.in和aclocal.m4两份报告后，很快就生成了configure脚本。由于懒蜗牛同学的这个程序很简单，因此configure脚本的内容也只有4千多行，不过麻雀虽小，五脏俱全，跟正规的configure脚本没有差别。
8.5.7 编写施工计划
那么有了configure脚本就完事了么？当然没有！都给你介绍了规划局有4个人，第4个还没出场呢，怎么能完呢？
这个Autoconf生成的configure要想去工作，是有条件的。他必须搭配规划局制定的施工计划------makefile.in才能工作。有人会问，这个makefile.in是什么啊？我已经有了Makefile还要他干什么？咱不是说了么，你的那个Makefile，甭管写得多么天花乱坠，也是白搭，人家规划局派出来的configure根本都不会瞧上一眼，人家configure要写自己的Makefile来用。你又得说了，那你这configure就赶快写出来自己的Makefile啊。你看你，不讲道理了不是，这Makefile文件那么复杂，哪能就这么凭空写出来，总得有个参考，有个蓝本，有个全市统一Makefile模板之类的东西吧。这个模板，就是makefile.in。那么这个文件从哪来呢？这就用得着Automake了。
【Automake的职能】
Automake的职能就是专门写configure需要的makefile.in（您看咱规划局给您搭配得多好）。不过Automake也不能直接就把makefile.in写出来。人家比较忙，这一点您也得理解。局里那么多重要的事情，今天学习，明天会餐，后天考察什么的。就算不会餐不考察，谁也免不了上个网、偷个菜、斗个地主扫个雷吧？
所以，Automake是没工夫从头给你写出一份makefile.in的，你得先给Automake写好一个框架，然后人家才好动笔。这个框架，就叫做Makefile.am。有了这个框架，交给Automake，他就可以给你写出makefile.in了。
【编写Makefile.am】
懒蜗牛同学没有打听好这个步骤，他直接找来Automake，让他写makefile.in。
Automake拉着长声说："这个......我们这里呀，工作也比较忙嘛......要按说呢......这个文件我是应该给你写滴。不过我们这里每天这么多人来，我要是一个一个写，哪天才能写完呀。所以同志啊，为了帮助我们提高办事效率，也为了你自己早点拿到Makefile的蓝本，更为了我们能够早日实现共同富裕奔小康------您是不是自己先写个草稿给我，我也好帮你赶快写出蓝本呀。"
懒蜗牛听得都快扔板砖了，心说不就你想犯懒这么点事么，至于跟我废这么多话么。赶紧动手写草稿吧，这个草稿叫做Makefile.am。好在内容很简单：
![alt](images/00490.jpeg){.calibre3}
![alt](images/00002.jpeg){.tpzz} 第1行，是行业规定，一般都这么写。
![alt](images/00002.jpeg){.tpzz} 第2行，说明编译之后的程序应该叫做rubbish1115。
![alt](images/00002.jpeg){.tpzz} 第3行，说这个工程包括main.c、ai.c、board.c这3个文件。
![alt](images/00011.jpeg){.tpzz}**提示：**[第1行的AUTOMAKE_OPTIONS=foreign是Automake的选项。Automake主要帮助开发GNU软件的人员来维护软件，所以在执行Automake时，默认会检查目录下是否存在标准GNU软件中应具备的文件，例如NEWS、AUTHOR、ChangeLog等文件。设置为foreign则Automake忽略掉对这些文件的检查。]{.kai1}
就这么简单，草稿就写完了。之后再把Automake叫出来，总算是给写出了Makefile的蓝本------makefile.in。
做完了这些之后，这个工程就可以打包发布了。用户拿到这个包，解开之后，就直接依次运行"./configure"、"make"、"make
install"就把软件安装上了。
懒蜗牛欣喜地看着自己整出的这个像模像样的软件，看看configure脚本，4千多行！心想：不知道的人看见这个脚本一定以为我是大牛吧，哈哈哈。再运行一下configure，看看生成的Makefile，500多行，哈哈，俨然感觉自己已经成为高手了一样。于是，在懒蜗牛的YY中，我们结束了那一天的工作。
[8.6 本章小结]{.kai}
咱们的懒蜗牛同学创造了不少的rubbish之后，算是对Linux下面的软件开发有了深入一些的了解了。什么编译原理、Makefile，还有怎么使用configure，怎么使用Autoconf，全都体验了一下。
从这以后，懒蜗牛算是更理解这笨兔子系统了。理解它的开源；理解它的简洁；理解它的效率；理解它的灵活。从此，懒蜗牛和笨兔子幸福地生活在了一起......