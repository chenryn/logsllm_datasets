# 04 \| 动态规划：完美解决硬币找零你好，我是卢誉声。今天我们来继续学习动态规划。在前面的几节课中，我们经历了贪心算法求解硬币找零的问题，并从中发现了贪心算法本身的局限性：它几乎只考虑了局部最优，因此无法应对需要考虑整体最优的算法面试问题。针对这一问题，我们重新思考了解决方案，用递归的方法来**穷举**出所有可能的组合，从这些可能组合中找出最优解。虽然这么做考虑了整体最优，而且真的可以解决问题，但效率太低。因此，为了解决这个低效问题，我们又提出了备忘录的概念，并在硬币找零案例中应用它解决了问题。你应该发现了，我们在解决硬币找零问题时的思路是一以贯之的：发现问题，找解决方案；如果方案有局限性，那么就看如何扩展视野，找寻更优的方法。不知道你还记不记得，我在上一节课的结尾有提到：含有备忘录的递归算法已经与动态规划思想十分相似了，从效率上说也是如此。事实上，你已经在使用动态规划的思想解决问题了。但**"真正"的动态规划解法跟备忘录法又有什么区别呢？**接下来我们就带着这个问题，一起来学习今天的内容吧！动态规划的问题描述我们曾不止一次提到重叠子问题，并在上一课对其做了深入探讨。其实，重叠子问题是考虑一个问题是否为动态规划问题的先决条件，除此之外，我还提到了无后效性。嗯，是时候对这些问题做个总结了，动态规划问题一定具备以下三个特征：1.       重叠子问题：在穷举的过程中（比如通过递归），存在重复计算的现象；        2.       无后效性：子问题之间的依赖是单向性的，某阶段状态一旦确定，就不受后续决策的影响；        3.       最优子结构：子问题之间必须相互独立，或者说后续的计算可以通过前面的状态推导出来。        什么是最优子结构？这是我第一次在课程中提出**最优子结构**这一概念，所以咱们先了解一下。这东西乍一听有些玄乎，什么叫子问题之间必须相互独立？我举一个简单的例子，你就明白了。比如说，假设你在外卖平台购买 5 斤苹果和 3斤香蕉。由于促销的缘故，这两种水果都有一个互相独立的促销价。如果原问题是让你以最低的价格购买这些水果，你该怎么买？显然，由于这两种水果的促销价格相互独立、互不影响，你只需直接购买就能享受到最低折扣的价格。现在我们得到了正确的结果：最低价格就是直接购买这两种折扣水果。因为这个过程符合最优子结构，打折的苹果和香蕉这两个子问题是互相独立、互不干扰的。但是，如果平台追加一个条件：折扣不能同时享用。即购买了折扣的苹果就不能享受折扣的香蕉，反之亦然。这样的话，你肯定就不能同时以最低的苹果价格和最低的香蕉价格享受到最低折扣了。按刚才那个思路就会得到错误的结果。因为子问题并不独立，苹果和香蕉的折扣价格无法同时达到最优，这时最优子结构被破坏。回过头来，我们再读一下最优子结构的定义。首先，你应该已经理解了什么是子问题之间必须相互独立。其次，所谓后续的计算可以通过前面的状态推导，是指：如果你准备购买了 5斤折扣苹果，那么这个价格（即子问题）就被确定了，继续在购物车追加 3斤折扣香蕉的订单，只需要在刚才的价格上追加折扣香蕉的价格，就是最低的总价格（即答案）。现在，让我们回到硬币找零的问题上来，它满足最优子结构吗？满足。假设有两种面值的硬币 c\[0\]=5, c\[1\]=3，目标兑换金额为k=11。原问题是求这种情况下求最少兑换的硬币数。如果你知道凑出 k=6 最少硬币数为"2"（注意，这是一个子问题），那么你只需要再加 "1" 枚面值为 c\[0\]=5的硬币就可以得到原问题的答案，即 2 + 1 =3。 原问题并没有限定硬币数量，你应该可以看出这些子问题之间没有互相制约的情况，它们之间是互相独立的。因此，硬币找零问题满足最优子结构，可以使用动态规划思想来进行求解。使用动态规划求解硬币找零当动态规划最终落到实处，就是一个状态转移方程，这同样是一个吓唬人的名词。不过没关系，其实我们已经具备了写出这个方程的所有工具。现在，就让我带你一起看看如何写出这个状态转移方程。首先，任何穷举算法（包括递归在内）都需要一个终止条件。那么对于硬币找零问题来说，终止条件是什么呢？当剩余的金额为0时结束穷举，因为这时不需要任何硬币就已经凑出目标金额了。在动态规划中，我们将其称之为**初始化状态**。接着，我们按照上面提到的凑硬币的思路，找出子问题与原问题之间会发生变化的变量。原问题指定了硬币的面值，同时没有限定硬币的数量，因此它们俩无法作为"变量"。唯独剩余需要兑换的金额是变化的，因此在这个题目中，唯一的变量是目标兑换金额k。 在动态规划中，我们将其称之为**状态参数**。同时，你应该注意到了，这个状态在不断逼近初始化状态。而这个不断逼近的过程，叫做状态转移。接着，既然我们确定了状态，那么什么操作会改变状态，并让它不断逼近初始化状态呢？每当我们挑一枚硬币，用来凑零钱，就会改变状态。在动态规划中，我们将其称之为**决策**。终于，我们构造了一个初始化状态 -\> 确定状态参数 -\>设计决策的思路。现在万事俱备，只欠东风，让我们一起来写这个**状态转移方程**。通常情况下，状态转移方程的参数就是状态转移过程中的变量，即状态参数。而函数的返回值就是答案，在这里是最少兑换的硬币数。我在这里先用递归形式（伪代码形式）描述一下状态转移的过程，这跟我们在上面讨论的挑硬币的过程是一致的。    DP(values, k) {      res = MAX      for c in values        // 作出决策，找到需要硬币最少的那个结果        res = min(res, 1 + DP(values, k-c)) // 递归调用            if res == MAX        return -1      return res    }顺着这个思路，我把状态转移方程给写出来，它是这样的： {simplebar="init"} {.simplebar-wrapper style="margin: 0px;"} simplebar-height-auto-observer-wrapper simplebar-height-auto-observer simplebar-mask {.simplebar-offset style="right: 0px; bottom: 0px;"} {.simplebar-content-wrapper style="height: auto; overflow: scroll hidden;"} {.simplebar-content style="padding: 0px;"} {slate-type="block-katex" ]{.strut style="height:1em;vertical-align:-0.25em;"}[F]{.mord.mathdefault style="margin-right:0.13889em;"}[(]{.mopen}[n]{.mord.mathdefault}[)]{.mclose}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[=]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}]{.base}[[]{.strutstyle="height:3.60004em;vertical-align:-1.55002em;"}[[[[[]{.pstrutstyle="height:3.15em;"}[⎩]{.delimsizinginner.delim-size4}]{style="top:-2.49999em;"}[[]{.pstrutstyle="height:3.15em;"}[⎨]{.delimsizinginner.delim-size4}]{style="top:-3.15001em;"}[[]{.pstrutstyle="height:3.15em;"}[⎧]{.delimsizinginner.delim-size4}]{style="top:-4.30002em;"}]{.vliststyle="height:2.05002em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:1.55002em;"}]{.vlist-r}]{.vlist-t .vlist-t2}]{.delimsizing.mult}]{.mopen}]{.arraycolsep style="width:0.5em;"}[[[[[[]{.pstrutstyle="height:3em;"}[[0]{.mord}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[n]{.mord.mathdefault}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[=]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[0]{.mord}]{.mord}]{style="top:-4.21em;"}[[]{.pstrutstyle="height:3em;"}[[−]{.mord}[1]{.mord}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[n]{.mord.mathdefault}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[\ v) { continue; }               // 使用当前面值，得到剩余硬币总额               int rest = v - currentValue;               int restCount = memo[rest];                              // 如果返回-1，说明组合不可信，跳过               if (restCount == -1) { continue; }               // 保留最小总额               int kCount = 1 + restCount;               if (kCount & values) {        std::vector memo(k + 1, -1); // 创建备忘录        memo[0] = 0; // 初始化状态        for (int v = 1; v  v) { continue; }                // 使用当前面值，得到剩余硬币总额                int rest = v - currentValue;                int restCount = memo[rest];                                // 如果返回-1，说明组合不可信，跳过                if (restCount == -1) { continue; }                // 保留最小总额                int kCount = 1 + restCount;                if (kCount  values = { 3, 5 }; // 硬币面值        int total = 11; // 总值        // 求得最小的硬币数量        return GetMinCounts(total, values); // 输出答案    }我们的关注点在 GetMinCounts函数上，该函数先定义了一个"新款"状态备忘录，用数组 memo来表示（通常将其称之为 DP 数组，DP 是 Dynamic Programming的缩写即动态规划。你看，是不是高级起来了）。这个备忘录由数组构成，其定义是：当目标兑换金额为 i 时，至少需要memo\[i\] 枚硬币才能凑出。有了备忘录的定义后，我们接下来再依据状态转移方程的指导来**初始化状态**：1.       将 F(0) 初始化成 0，即    memo\[0\]=0；        2.       把备忘录中剩余的位置初始化成 k + 1。凑成金额 k    的硬币数至多只可能等于 k （如果硬币的最低面值是 1），因此初始化为    k + 1    就相当于将这些位置初始化成正无穷大，便于后续        **决策**        时取最小值。        接着，我们从 1 开始遍历，求解 F(1) 的结果，直到求解 F(k)的结果为止。循环结束后我们想要的结果就存储在 memo\[k\] 中，也就是 F(k)的解。 在这个基于原来递归代码上改进得到的代码中，我们来看一下每次循环中做了什么。每一次循环都包含一个小循环，这个小循环会遍历所有的面值。1.       先看当前面额总值是否小于当前硬币面额。如果是，说明组合不存在，直接进入下一轮循环。        2.       否则，我们就可以认为已经使用了这一枚硬币，那么就求得使用完硬币后的余额    rest，并从备忘录中获取 F(rest)    的结果：        >  > a. 如果 F(rest) 为 -1，说明 F(rest)> 组合不存在，子问题不成立那么当前问题也就无解，直接进入下一轮循环；> > >>>  > b. 如果返回的值不是 -1，说明组合存在，那么求 F(rest) +> 1，并和当前最小硬币总数比较，取最小值。> > >1.       内部循环结束后，我们看一下 minCount    的值：    >  > a. 如果是 -1，说明 F(v) 不存在，那么不做任何处理，保留 F(v)=-1> 即可；> >>>  > b. 否则将最小值存入 memo\[v\]，表示已经求得 f(v)> 的值，准备为后续的问题使用。> > >这样我们就通过这种自下而上的方法将递归转换成了循环。但是，这段代码还是跟我们常见的动态规划代码有些出入，不过没有关系，经过简单的调整就可以把它变漂亮。我先给出代码，然后再对其进行解释。Java 实现：    int getMinCounts(int k, int[] values) {       int[] memo = new int[k + 1]; // 创建备忘录       memo[0] = 0; // 初始化状态       for (int i = 1; i & values) {        int memo[k + 1]; // 创建备忘录        memo[0] = 0; // 初始化状态        for (int i = 1; i  values = { 3, 5 }; // 硬币面值        int total = 11; // 总值        return GetMinCounts(total, values); // 输出答案    }现在我们看一下，每一次循环中是如何做**决策**的。每一次循环都包含一个小循环，这个小循环会遍历所有的面值。1.       跟之前一样，我们先看当前面额总值是否小于当前硬币面额。如果是，则说明组合不存在，直接进入下一轮循环。        2.       否则，就可以认为已经使用了这一枚硬币，这时我们要作出决策：        >  > a. 如果采纳了这枚硬币，则凑的硬币数量需要 +1，这时"状态 A"是> memo\[i - coin\] + 1；> > >>>  > b. 如果不采纳这枚硬币，则凑的硬币数量不变，这时"状态 B"是> memo\[i\]；> > >>>  > c. 显然，硬币找零问题是求最值问题（即最少需要几枚硬币凑出总额> k）。因此，我们在这里作出决策，在状态 A 与状态 B> 中谁的硬币数量更少，即取最小值 min(状态 A, 状态> B)。> >1.       当循环结束后，我们看一下备忘录中位置为 k 的值是多少，即    memo\[k\]：        >  > a. 如果是 k +> 1，就意味着在初始化状态时的值没有被更新过，是"正无穷大"。这时按照题目要求，返回> -1；> >>>  > b.> 否则，我们就找到了最少凑出硬币的数量，返回它，就是我们的答案。> > >这样一来，借助于自底向上的方法，我们成功的将递归转换成了迭代。这段代码的时间复杂度是非常标准的O(m\*n)。它不会有任何额外的性能开销，我们通过动态规划完美地解决了硬币找零问题。通用的动态规划在掌握了如何使用标准的动态规划来解决硬币找零问题后，我们有必要将其推而广之，来看看解决动态规划面试问题的通用框架，或者说套路。在这里，我会给出一个经验总结，而非严格的数学推导。动态规划问题的核心是写出正确的状态转移方程，为了写出它，我们要先确定以下几点：1.       初始化状态：由于动态规划是根据已经计算好的子问题推广到更大问题上去的，因此我们需要一个"原点"作为计算的开端。在硬币找零问题中，这个初始化状态是    memo\[0\]=0；        2.       状态：找出子问题与原问题之间会发生变化的变量。在硬币找零问题中，这个状态只有一个，就是剩余的目标兑换金额    k；    3.       决策：改变状态，让状态不断逼近初始化状态的行为。在硬币找零问题中，挑一枚硬币，用来凑零钱，就会改变状态。        一般来说，状态转移方程的**核心参数**就是**状态**。接着，我们需要自底向上地使用备忘录来消除重叠子问题，构造一个备忘录（在硬币找零问题中，它叫memo。为了通用，我们以后都将其称之为 DPtable）。 最后，我们需要实现决策。在硬币找零问题中，决策是指挑出需要硬币最少的那个结果。通过这样几个简单步骤，我们就能写出状态转移方程： {simplebar="init"} {.simplebar-wrapper style="margin: 0px;"} simplebar-height-auto-observer-wrapper simplebar-height-auto-observer simplebar-mask {.simplebar-offset style="right: 0px; bottom: 0px;"} {.simplebar-content-wrapper style="height: auto; overflow: scroll hidden;"} {.simplebar-content style="padding: 0px;"} {slate-type="block-katex" ]{.strut style="height:1em;vertical-align:-0.25em;"}[D]{.mord.mathdefault style="margin-right:0.02778em;"}[P]{.mord .mathdefaultstyle="margin-right:0.13889em;"}[(]{.mopen}[n]{.mord.mathdefault}[)]{.mclose}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[=]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}]{.base}[[]{.strutstyle="height:3.60004em;vertical-align:-1.55002em;"}[[[[[]{.pstrutstyle="height:3.15em;"}[⎩]{.delimsizinginner.delim-size4}]{style="top:-2.49999em;"}[[]{.pstrutstyle="height:3.15em;"}[⎨]{.delimsizinginner.delim-size4}]{style="top:-3.15001em;"}[[]{.pstrutstyle="height:3.15em;"}[⎧]{.delimsizinginner.delim-size4}]{style="top:-4.30002em;"}]{.vliststyle="height:2.05002em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:1.55002em;"}]{.vlist-r}]{.vlist-t .vlist-t2}]{.delimsizing.mult}]{.mopen}]{.arraycolsep style="width:0.5em;"}[[[[[[]{.pstrutstyle="height:3em;"}[[0]{.mord}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[n]{.mord.mathdefault}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[=]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[0]{.mord}]{.mord}]{style="top:-4.21em;"}[[]{.pstrutstyle="height:3em;"}[[−]{.mord}[1]{.mord}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[n]{.mord.mathdefault}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[\]{.mrel}[=]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[w]{.mord .mathdefaultstyle="margin-right:0.02691em;"}[\[]{.mopen}[t]{.mord.mathdefault}[n]{.mord.mathdefault}[\]]{.mclose}]{.mord}]{style="top:-1.2099999999999997em;"}]{.vliststyle="height:2.6500000000000004em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:2.1500000000000004em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.col-align-c}[]{.arraycolsepstyle="width:0.5em;"}]{.mtable}]{.mord}[]{.mclose.nulldelimiter}]{.minner}]{.base}]{.katex-htmlaria-hidden="true"}]{.katex}]{.katex-display} {.simplebar-placeholder style="width: 432px; height: 132px;"} {.simplebar-track .simplebar-horizontal style="visibility: visible;"} {.simplebar-scrollbar style="width: 225px; transform: translate3d(0px, 0px, 0px); display: block;"} {.simplebar-track .simplebar-vertical style="visibility: hidden;"} {.simplebar-scrollbar style="height: 0px; display: none;"}现在，我们有了针对 0-1背包问题的完整状态转移方程，可以开始编写代码了。编写代码进行求解但在编写代码前，还有一个小问题需要解决，就是我们需要为动态规划代码准备一个备忘录，来存储计算过的子问题答案。那么这个备忘录的数据结构应该是什么样的呢？从前面的分析可以看出，状态转移方程中有两个状态参数，并通过这两个状态参数确定了一个子问题的答案。因此，我们可以使用一个二维数组作为备忘录。为了通用起见，我将其命名为 ]{.strutstyle="height:1em;vertical-align:-0.25em;"}[D]{.mord .mathdefaultstyle="margin-right:0.02778em;"}[P]{.mord .mathdefaultstyle="margin-right:0.13889em;"}[\[]{.mopen}[t]{.mord.mathdefault}[n]{.mord .mathdefault}[\]]{.mclose}[\[]{.mopen}[r]{.mord.mathdefault style="margin-right:0.02778em;"}[w]{.mord .mathdefaultstyle="margin-right:0.02691em;"}[\]]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"，其中行代表的是 [[[]{.strutstyle="height:0.61508em;vertical-align:0em;"}[t]{.mord.mathdefault}[n]{.mord .mathdefault}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"，表示第几个物品；列代表的是 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[r]{.mord .mathdefaultstyle="margin-right:0.02778em;"}[w]{.mord .mathdefaultstyle="margin-right:0.02691em;"}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"slate-object="inline"，表示背包还能容纳的重量。这个索引组合（比如 [[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[D]{.mord .mathdefaultstyle="margin-right:0.02778em;"}[P]{.mord .mathdefaultstyle="margin-right:0.13889em;"}[\[]{.mopen}[2]{.mord}[\]]{.mclose}[\[]{.mopen}[3]{.mord}[\]]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"slate-object="inline"）对应位置的值，就是这个子问题的答案，表示当背包还能容纳 3的重量时，放入前 2件物品的最大价值。所有先决条件都解决了，现在来看一下如何用标准的动归解法来求解此问题，我直接给出代码。Java 实现：    int dp(int[] w, int[] v, int N, int W) {        // 创建备忘录        int[][] dp = new int[N+1][W+1];              // 初始化状态        for (int i = 0; i & w, const std::vector& v, int N, int W) {      int dp[N+1][W+1]; memset(dp, 0, sizeof(dp)); // 创建备忘录            // 初始化状态      for (int i = 0; i  w = {0, 3, 2, 1}; // 物品的重量      std::vector v = {0, 5, 2, 3}; // 物品的价值            return DP(w, v, N, W); // 输出答案    }我们几乎照搬了状态转移方程描述的内容到代码里，因此这段代码通俗易懂。首先，我们定义了两个数组，其中 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[w]{.mord .mathdefaultstyle="margin-right:0.02691em;"}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex" 用来表示物品的重量，而 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[v]{.mord .mathdefaultstyle="margin-right:0.03588em;"}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"用来表示物品的价值。这里需要注意的是，每个数组的第 0 项都是 0。由于小于0 的值对应的都应该是 0，因此我们可以通过这个方法来省去冗余的 if判断逻辑。 我们已经定义了备忘录即 ]{.strutstyle="height:1em;vertical-align:-0.25em;"}[D]{.mord .mathdefaultstyle="margin-right:0.02778em;"}[P]{.mord .mathdefaultstyle="margin-right:0.13889em;"}[\[]{.mopen}[t]{.mord.mathdefault}[n]{.mord .mathdefault}[\]]{.mclose}[\[]{.mopen}[r]{.mord.mathdefault style="margin-right:0.02778em;"}[w]{.mord .mathdefaultstyle="margin-right:0.02691em;"}[\]]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex" 数组的含义：当背包还能装 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[r]{.mord .mathdefaultstyle="margin-right:0.02778em;"}[w]{.mord .mathdefaultstyle="margin-right:0.02691em;"}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex" 重量的物品，放入了前 [[[]{.strutstyle="height:0.61508em;vertical-align:0em;"}[t]{.mord.mathdefault}[n]{.mord .mathdefault}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"件物品时的最大价值。接下来，我们再依据状态转移方程的定义来**初始化状态**：1.       创建一个大小为 N+1 / W+1 的二维数组，并将所有位置初始化为    0；    2.       初始化状态，即前面提到的穷举的终止条件，把所有的        [[[]{.strut    style="height:1em;vertical-align:-0.25em;"}[d]{.mord    .mathdefault}[p]{.mord    .mathdefault}[\[]{.mopen}[0]{.mord}[\]]{.mclose}[\[]{.mopen}[i]{.mord    .mathdefault}[\]]{.mclose}]{.base}]{.katex-html    aria-hidden="true"}]{.katex    slate-string="true"}]}]{slate-type="inline-katex"     和        [[[]{.strut    style="height:1em;vertical-align:-0.25em;"}[d]{.mord    .mathdefault}[p]{.mord .mathdefault}[\[]{.mopen}[j]{.mord    .mathdefault    style="margin-right:0.05724em;"}[\]]{.mclose}[\[]{.mopen}[0]{.mord}[\]]{.mclose}]{.base}]{.katex-html    aria-hidden="true"}]{.katex    slate-string="true"}]}]{slate-type="inline-katex"     全部都设置为    0。    接着，进入编写函数主体循环的阶段，让我们看看每一次循环中是如何做**决策**的：1.       主循环分为两层，第 1 层遍历所有物品，也就是尝试放入每个物品；第 2    层遍历背包容量，也就是假定当前背包容量是        [[[]{.strut    style="height:0.43056em;vertical-align:0em;"}[r]{.mord .mathdefault    style="margin-right:0.02778em;"}[w]{.mord .mathdefault    style="margin-right:0.02691em;"}]{.base}]{.katex-html    aria-hidden="true"}]{.katex    slate-string="true"}]}]{slate-type="inline-katex"     的时候，求在背包容量为        [[[]{.strut    style="height:0.43056em;vertical-align:0em;"}[r]{.mord .mathdefault    style="margin-right:0.02778em;"}[w]{.mord .mathdefault    style="margin-right:0.02691em;"}]{.base}]{.katex-html    aria-hidden="true"}]{.katex    slate-string="true"}]}]{slate-type="inline-katex"        时，放入当前物品的最大价值；        2.       如果背包容量小于当前物品价值，那么这个时候最大价值也就是当前容量不变，使用上一个物品的最大价值即可；        3.       如果背包容量大于当前物品价值，那么这个时候最大价值也就是从以下两个决策中挑选：        >  > a. 放入这个物品前的最大价值 +> 当前物品价值和作为答案；> > >>>  > b.> 不放入这个物品时，当前容量的最大价值作为答案。> > >我在下面的表格中，用箭头画出了容量为 5时的求解路径。你可以参照这个求解路径来加深对代码的理解。![](Images/c6700db762d24cbd4620d98a2f0f3a5b.png)savepage-src="https://static001.geekbang.org/resource/image/af/d0/afbe718a68b8a1f89c42c259a75ca7d0.png"}在面试过程中，如果能养成对编写代码重审的习惯，也是可以加分的。因此，在我们实现完决策逻辑后，再对代码做些基本的检查，就可以"交卷"了。0-1 背包问题的延伸事实上，由于 0-1背包问题过于经典，在真正的算法面试环节，如果涉及动态规划问题时，基本不会让你直接解决这个问题，而是让你解决这个问题的变种。因此，我们有必要对 0-1背包问题做一个延伸，来看看如何把一个看似陌生的动态规划问题转化成 0-1背包问题来进行求解。算法问题分析我们先来看看问题的描述。问题：有一堆石头，每块石头的重量都是正整数。每次从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[x]{.mord.mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex" 和 [[[]{.strutstyle="height:0.625em;vertical-align:-0.19444em;"}[y]{.mord .mathdefaultstyle="margin-right:0.03588em;"}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"，且 [[[]{.strutstyle="height:0.7719400000000001em;vertical-align:-0.13597em;"}[x]{.mord.mathdefault}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[≤]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}]{.base}[[]{.strutstyle="height:0.625em;vertical-align:-0.19444em;"}[y]{.mord .mathdefaultstyle="margin-right:0.03588em;"}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"slate-object="inline"。那么粉碎的可能结果如下：1.       如果         [[[]{.strut    style="height:0.43056em;vertical-align:0em;"}[x]{.mord    .mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katex    slate-string="true"}]}]{slate-type="inline-katex"     与        [[[]{.strut    style="height:0.625em;vertical-align:-0.19444em;"}[y]{.mord    .mathdefault style="margin-right:0.03588em;"}]{.base}]{.katex-html    aria-hidden="true"}]{.katex    slate-string="true"}]}]{slate-type="inline-katex"        相等，那么两块石头都会被完全粉碎；        2.       否则，重量为         [[[]{.strut    style="height:0.43056em;vertical-align:0em;"}[x]{.mord    .mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katex    slate-string="true"}]}]{slate-type="inline-katex"     的石头将会完全粉碎，而重量为        [[[]{.strut    style="height:0.625em;vertical-align:-0.19444em;"}[y]{.mord    .mathdefault style="margin-right:0.03588em;"}]{.base}]{.katex-html    aria-hidden="true"}]{.katex    slate-string="true"}]}]{slate-type="inline-katex"     的石头的新重量为        [[[]{.strut    style="height:0.7777700000000001em;vertical-align:-0.19444em;"}[y]{.mord    .mathdefault style="margin-right:0.03588em;"}[]{.mspace    style="margin-right:0.2222222222222222em;"}[−]{.mbin}[]{.mspace    style="margin-right:0.2222222222222222em;"}]{.base}[[]{.strut    style="height:0.43056em;vertical-align:0em;"}[x]{.mord    .mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katex    slate-string="true"}]}]{slate-type="inline-katex"    slate-object="inline"    。        最后，最多只会剩下一块石头。返回此时石头最小的可能重量。如果没有石头剩下，就返回0。 示例：     示例：    输入：[1, 2, 1, 7, 9, 4    输出：    解释：Round 1: (2, 4) -> 2, 数组变成 [1, 1, 7, 9, 2         Round 2: (7, 9) -> 2, 数组变成 [1, 1, 2, 2         Round 3: (2, 2) -> 0, 数组变成 [1, 1         Round 4: (1, 1) -> 0, 数组为空，返回 0如果你是第一次遇见这个问题，那么你很可能跟绝大多数人（包括我在内）一样一脸茫然，一上来就没有什么思路。这其实很正常，事实上动态规划的面试题有规可循，总共就那么几种，见过了，以后就知道了。我们先来读一下题目，最后的问题中包含了"最"字，这时你就应该小心了。同时，这个题目显然需要通过排列组合的方式从所有可能组合中找到最优解，因此会涉及穷举，如果涉及穷举，就很有可能涉及重叠子问题。我刚才在 0-1背包中使用了一个模版化的分析方法，我建议你在这里对此问题进行类似的分析。分析后你就会发现，这应该是一个动态规划问题。转化成动态规划问题现在，我们就来讲一下到底如何将其转化为动态规划问题。首先，请你观察一下上面提供的示例。在示例中，第一步组合 2 和 4，求出(4 - 2) = 2；第二步组合 7 和 9，求出 (9 - 7) = 2；第三步组合 2 和2，求出 (2 - 2) = 0；最后第四步组合 1 和 1，同样得0。我们把这个过程组合成一个式子，它看起来是这样的： {simplebar="init"} {.simplebar-wrapper style="margin: 0px;"} simplebar-height-auto-observer-wrapper simplebar-height-auto-observer simplebar-mask {.simplebar-offset style="right: 0px; bottom: 0px;"} {.simplebar-content-wrapper style="height: auto; overflow: hidden;"} {.simplebar-content style="padding: 0px;"} {slate-type="block-katex" ]{.strutstyle="height:0.72777em;vertical-align:-0.08333em;"}[1]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[−]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[(]{.mopen}[(]{.mopen}[(]{.mopen}[4]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[−]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[2]{.mord}[)]{.mclose}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[−]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[(]{.mopen}[9]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[−]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[7]{.mord}[)]{.mclose}[)]{.mclose}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[−]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[1]{.mord}[)]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katex}]{.katex-display} {.simplebar-placeholder style="width: 432px; height: 58px;"} {.simplebar-track .simplebar-horizontal style="visibility: hidden;"} {.simplebar-scrollbar style="width: 0px; display: none; transform: translate3d(0px, 0px, 0px);"} {.simplebar-track .simplebar-vertical style="visibility: hidden;"} {.simplebar-scrollbar style="height: 0px; display: none;"}如果解开这些括号，就可以得到 1 - 4 + 2 + 9 - 7 -1。再做一下简单的变换，就可以得到如下式子： {simplebar="init"} {.simplebar-wrapper style="margin: 0px;"} simplebar-height-auto-observer-wrapper simplebar-height-auto-observer simplebar-mask {.simplebar-offset style="right: 0px; bottom: 0px;"} {.simplebar-content-wrapper style="height: auto; overflow: hidden;"} {.simplebar-content style="padding: 0px;"} {slate-type="block-katex" ]{.strutstyle="height:0.72777em;vertical-align:-0.08333em;"}[1]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[+]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:0.72777em;vertical-align:-0.08333em;"}[2]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[+]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:0.72777em;vertical-align:-0.08333em;"}[9]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[−]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:0.72777em;vertical-align:-0.08333em;"}[1]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[−]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:0.72777em;vertical-align:-0.08333em;"}[4]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[−]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:0.64444em;vertical-align:0em;"}[7]{.mord}]{.base}]{.katex-htmlaria-hidden="true"}]{.katex}]{.katex-display} {.simplebar-placeholder style="width: 432px; height: 58px;"} {.simplebar-track .simplebar-horizontal style="visibility: hidden;"} {.simplebar-scrollbar style="width: 0px; display: none; transform: translate3d(0px, 0px, 0px);"} {.simplebar-track .simplebar-vertical style="visibility: hidden;"} {.simplebar-scrollbar style="height: 0px; display: none;"}这个时候，我们可以把这个公式分成两组，一组是从数组中挑选出几个数字相加；然后，将另外几个数字相减，求两个数字的差。最后确保这个差最小。从直觉上来说，如何确保两组数字之差最小呢？我们可以看到如果一组数字接近所有数字之和的1/2，那么两组数字之差肯定越小，比如上面的示例中所有数字之和是24，所以一组数字是 12，另一组数字也是 12，最后肯定能得到最小值0。 现在，假设有一个背包，背包的容量是12（24/2）。接着，我们有一堆的物品，重量分别是 \[1, 2, 1, 7, 9,4\]，注意我们设它的价值与重量相同。现在我们希望选出的物品放到背包里的价值最大，这样一来，我们就可以把这个题目转化成0-1 背包问题了。写出状态转移方程那么，动态规划部分的状态转移方程就和 0-1背包问题中的一样，如下所示： {simplebar="init"} {.simplebar-wrapper style="margin: 0px;"} simplebar-height-auto-observer-wrapper simplebar-height-auto-observer simplebar-mask {.simplebar-offset style="right: 0px; bottom: 0px;"} {.simplebar-content-wrapper style="height: auto; overflow: scroll hidden;"} {.simplebar-content style="padding: 0px;"} {slate-type="block-katex" ]{.strut style="height:1em;vertical-align:-0.25em;"}[D]{.mord.mathdefault style="margin-right:0.02778em;"}[P]{.mord .mathdefaultstyle="margin-right:0.13889em;"}[(]{.mopen}[t]{.mord.mathdefault}[n]{.mord .mathdefault}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[r]{.mord .mathdefaultstyle="margin-right:0.02778em;"}[w]{.mord .mathdefaultstyle="margin-right:0.02691em;"}[)]{.mclose}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[=]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}]{.base}[[]{.strutstyle="height:4.80004em;vertical-align:-2.15002em;"}[[[[[]{.pstrutstyle="height:3.15em;"}[⎩]{.delimsizinginner.delim-size4}]{style="top:-1.8999899999999998em;"}[[]{.pstrutstyle="height:3.15em;"}[⎪]{.delimsizinginner.delim-size4}]{style="top:-1.8999899999999998em;"}[[]{.pstrutstyle="height:3.15em;"}[⎪]{.delimsizinginner.delim-size4}]{style="top:-2.1999899999999997em;"}[[]{.pstrutstyle="height:3.15em;"}[⎨]{.delimsizinginner.delim-size4}]{style="top:-3.15001em;"}[[]{.pstrutstyle="height:3.15em;"}[⎪]{.delimsizinginner.delim-size4}]{style="top:-4.30001em;"}[[]{.pstrutstyle="height:3.15em;"}[⎪]{.delimsizinginner.delim-size4}]{style="top:-4.60001em;"}[[]{.pstrutstyle="height:3.15em;"}[⎧]{.delimsizinginner.delim-size4}]{style="top:-4.90002em;"}]{.vliststyle="height:2.65002em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:2.15002em;"}]{.vlist-r}]{.vlist-t .vlist-t2}]{.delimsizing.mult}]{.mopen}]{.arraycolsep style="width:0.5em;"}[[[[[[]{.pstrutstyle="height:3em;"}[[0]{.mord}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[t]{.mord.mathdefault}[n]{.mord .mathdefault}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[\]{.mrel}[=]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[w]{.mord .mathdefaultstyle="margin-right:0.02691em;"}[\[]{.mopen}[t]{.mord.mathdefault}[n]{.mord.mathdefault}[\]]{.mclose}]{.mord}]{style="top:-1.2099999999999997em;"}]{.vliststyle="height:2.6500000000000004em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:2.1500000000000004em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.col-align-c}[]{.arraycolsepstyle="width:0.5em;"}]{.mtable}]{.mord}[]{.mclose.nulldelimiter}]{.minner}]{.base}]{.katex-htmlaria-hidden="true"}]{.katex}]{.katex-display} {.simplebar-placeholder style="width: 432px; height: 132px;"} {.simplebar-track .simplebar-horizontal style="visibility: visible;"} {.simplebar-scrollbar style="width: 218px; transform: translate3d(0px, 0px, 0px); display: block;"} {.simplebar-track .simplebar-vertical style="visibility: hidden;"} {.simplebar-scrollbar style="height: 0px; display: none;"}看到了吧！我们巧妙地把这个看似让人蒙圈的问题成功转化成了一个标准的0-1背包问题，而且能够直接复用我们所学的内容。万事俱备后就是编写代码，由于状态转移方程与 0-1背包问题如出一辙，因此我们这里就省略编码这一环节了。通用的动态规划在上一个模块"初识动态规划"中，我们曾经介绍了一种经过经验总结的动态规划解题框架（或者说是套路）。其实当时，我并未给出比较严格的框架，作为补充完善动态规划理论的重要一环，我们很有必要学习、掌握通用的动态规划的框架。我们已经知道，一个动态规划问题是指它可以从大问题中找到无后效性的重叠子问题。所谓无后效行是指，其子问题不会双向依赖，只会单向依赖。否则，我们就无法确保子问题处理后，更大的问题一定能取到子问题的解。现在，我们准备对动态规划问题进行泛化统一建模，如果用数学语言描述就如下公式所示： {simplebar="init"} {.simplebar-wrapper style="margin: 0px;"} simplebar-height-auto-observer-wrapper simplebar-height-auto-observer simplebar-mask {.simplebar-offset style="right: 0px; bottom: 0px;"} {.simplebar-content-wrapper style="height: auto; overflow: scroll hidden;"} {.simplebar-content style="padding: 0px;"} {slate-type="block-katex" ]{.strut style="height:1em;vertical-align:-0.25em;"}[f]{.mord.mathdefault style="margin-right:0.10764em;"}[(]{.mopen}[x]{.mord.mathdefault}[)]{.mclose}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[=]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}]{.base}[[]{.strutstyle="height:2.40003em;vertical-align:-0.95003em;"}{]{.delimsizing.size3}]{.mopen .delimcenter style="top:0em;"}]{.arraycolsepstyle="width:0.5em;"}[[[]{.pstrut style="height:3em;"}[[d]{.mord.mathdefault}[(]{.mopen}[x]{.mord.mathdefault}[)]{.mclose}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[x]{.mord.mathdefault}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[∈]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[[V]{.mord .mathdefaultstyle="margin-right:0.22222em;"}[[[]{.pstrutstyle="height:2.7em;"}I]{.mord .mathdefault .mtightstyle="margin-right:0.07847em;"}]{.mord .mtight}]{.sizing .reset-size6.size3.mtight}]{style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"}]{.vliststyle="height:0.32833099999999993em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:0.15em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.msupsub}]{.mord}]{.mord}]{style="top:-3.61em;"}[[]{.pstrutstyle="height:3em;"}[[g]{.mord .mathdefaultstyle="margin-right:0.03588em;"}[(]{.mopen}[{]{.mopen}[v]{.mord.mathdefault style="margin-right:0.03588em;"}[(]{.mopen}[f]{.mord.mathdefault style="margin-right:0.10764em;"}[(]{.mopen}[s]{.mord.mathdefault}[(]{.mopen}[x]{.mord .mathdefault}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[c]{.mord.mathdefault}[)]{.mclose}[)]{.mclose}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[c]{.mord.mathdefault}[)]{.mclose}[}]{.mclose}[)]{.mclose}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[c]{.mord.mathdefault}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[∈]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[v]{.mord .mathdefaultstyle="margin-right:0.03588em;"}[a]{.mord .mathdefault}[l]{.mord.mathdefault style="margin-right:0.01968em;"}[u]{.mord.mathdefault}[e]{.mord .mathdefault}[s]{.mord.mathdefault}[(]{.mopen}[x]{.mord.mathdefault}[)]{.mclose}]{.mord}]{style="top:-2.4099999999999997em;"}]{.vliststyle="height:1.45em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:0.9500000000000004em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.col-align-c}[]{.arraycolsepstyle="width:0.5em;"}]{.mtable}]{.mord}[]{.mclose.nulldelimiter}]{.minner}]{.base}]{.katex-htmlaria-hidden="true"}]{.katex}]{.katex-display} {.simplebar-placeholder style="width: 432px; height: 83px;"} {.simplebar-track .simplebar-horizontal style="visibility: visible;"} {.simplebar-scrollbar style="width: 412px; transform: translate3d(0px, 0px, 0px); display: block;"} {.simplebar-track .simplebar-vertical style="visibility: hidden;"} {.simplebar-scrollbar style="height: 0px; display: none;"}我们该怎么理解这个公式呢？首先，我们需要考虑一些边界情况，如果输入向量 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[x]{.mord.mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"，那么在边界组合 [[[]{.strutstyle="height:0.83333em;vertical-align:-0.15em;"}[[V]{.mord .mathdefaultstyle="margin-right:0.22222em;"}[[[]{.pstrutstyle="height:2.7em;"}I]{.mord .mathdefault .mtightstyle="margin-right:0.07847em;"}]{.mord .mtight}]{.sizing .reset-size6.size3.mtight}]{style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"}]{.vliststyle="height:0.32833099999999993em;"}[​]{.vlist-s}]{.vlist-r}[[]{.vliststyle="height:0.15em;"}]{.vlist-r}]{.vlist-t.vlist-t2}]{.msupsub}]{.mord}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex" 中，用一个边界函数 [[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[d]{.mord.mathdefault}[(]{.mopen}[x]{.mord.mathdefault}[)]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex" 直接返回 [[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[f]{.mord .mathdefaultstyle="margin-right:0.10764em;"}[(]{.mopen}[x]{.mord.mathdefault}[)]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"的值，就不需要再划分子问题了。比如在 0-1 背包问题中，当 [[[]{.strutstyle="height:0.61508em;vertical-align:0em;"}[t]{.mord.mathdefault}[n]{.mord .mathdefault}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex" 或 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[r]{.mord .mathdefaultstyle="margin-right:0.02778em;"}[w]{.mord .mathdefaultstyle="margin-right:0.02691em;"}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex" 小于等于 0 时，这个值就是0。 否则，说明这是一个可以划分子问题的问题，那么我们就需要从可选组合 [[[]{.strutstyle="height:0.69444em;vertical-align:0em;"}[v]{.mord .mathdefaultstyle="margin-right:0.03588em;"}[a]{.mord .mathdefault}[l]{.mord.mathdefault style="margin-right:0.01968em;"}[u]{.mord.mathdefault}[e]{.mord .mathdefault}[s]{.mord.mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"中取出用于划分子问题的备选值。需要牢记的是，在复杂问题中这个 [[[]{.strutstyle="height:0.69444em;vertical-align:0em;"}[v]{.mord .mathdefaultstyle="margin-right:0.03588em;"}[a]{.mord .mathdefault}[l]{.mord.mathdefault style="margin-right:0.01968em;"}[u]{.mord.mathdefault}[e]{.mord .mathdefault}[s]{.mord.mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"可能不是一个一成不变的组合，它会随着当前状态 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[x]{.mord.mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"变化而变化。接着，我们对每一个备选值 ]{.strutstyle="height:0.43056em;vertical-align:0em;"}[c]{.mord.mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"（与上面的 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[x]{.mord.mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"类似，同样可能是一个向量），通过函数 [[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[s]{.mord.mathdefault}[(]{.mopen}[x]{.mord .mathdefault}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[c]{.mord.mathdefault}[)]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex" 求得当前备选值的子问题的 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[x]{.mord.mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex", [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[c]{.mord.mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"。然后，通过 [[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[f]{.mord .mathdefaultstyle="margin-right:0.10764em;"}[(]{.mopen}[s]{.mord.mathdefault}[(]{.mopen}[x]{.mord .mathdefault}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[c]{.mord.mathdefault}[)]{.mclose}[)]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"得到这个子问题的结果。再接着，我们通过子问题 ]{.strutstyle="height:1em;vertical-align:-0.25em;"}[v]{.mord .mathdefaultstyle="margin-right:0.03588em;"}[(]{.mopen}[f]{.mord .mathdefaultstyle="margin-right:0.10764em;"}[(]{.mopen}[s]{.mord.mathdefault}[(]{.mopen}[x]{.mord .mathdefault}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[c]{.mord.mathdefault}[)]{.mclose}[)]{.mclose}[,]{.mpunct}[]{.mspacestyle="margin-right:0.16666666666666666em;"}[c]{.mord.mathdefault}[)]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex" 的结果和当前备选值 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[c]{.mord.mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"slate-object="inline"，来求得当前问题的解。因为我们有一系列的备选值 [[[]{.strutstyle="height:0.43056em;vertical-align:0em;"}[c]{.mord.mathdefault}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"slate-object="inline"，因此会得到一个当前问题的求解集合。最后，我们通过最优化函数 ]{.strutstyle="height:1em;vertical-align:-0.25em;"}[g]{.mord .mathdefaultstyle="margin-right:0.03588em;"}[(]{.mopen}[t]{.mord.mathdefault}[)]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"进行求解。比如原问题是求最小值，那么 [[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[g]{.mord .mathdefaultstyle="margin-right:0.03588em;"}[(]{.mopen}[t]{.mord.mathdefault}[)]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex" 就是 [[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[m]{.mord.mathdefault}[i]{.mord .mathdefault}[n]{.mord.mathdefault}[(]{.mopen}[t]{.mord.mathdefault}[)]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"；如果是求最大值，那么就是 [[[]{.strutstyle="height:1em;vertical-align:-0.25em;"}[m]{.mord.mathdefault}[a]{.mord .mathdefault}[x]{.mord.mathdefault}[(]{.mopen}[t]{.mord.mathdefault}[)]{.mclose}]{.base}]{.katex-htmlaria-hidden="true"}]{.katexslate-string="true"}]}]{slate-type="inline-katex"slate-object="inline"。这两种是最为常见的函数，我们在前面的例题当中也都见过了。这样一来，我们就可以把所有的问题都套入这个框架，写出对应的状态转移方程了。课程总结现在让我们回到这节课开头提出的那个问题，那就是 0-1 背包问题中的 0 和1 代表的到底是什么呢？其实，你可以看到在整个算法计算过程中，每次我们只能做两种选择：1.       放入当前物品；        2.       不放入当前物品。        如果我们对这个问题稍作修改：每个物品有一定的数量（注意不止一个），同时还允许在背包中反复放入多个相同的物品，那么这个问题就变成了每个物品应该放几个。我们可以看到 0-1 背包就是这种问题的一个子集，相当于每个物品都只有 1个的背包问题！如果从放入数量的角度来看，放入当前物品就相当于当前的物品放入了1 个，不放入当前物品就相当于放入了 0个。 所以，这就是为什么这个背包问题被称为 0-1背包的根本原因。充分理解 0-1背包的解题思路，对全面掌握背包问题来说至关重要。我会在下一节课为你讲解泛化的背包问题，并给出衍生的面试问题讨论，帮助你攻破背包问题难关。课后思考在这节课中，我们介绍了 0-1背包问题的延伸，提出了一个"粉碎石头"的问题。现在，请你按照求解 0-1背包问题的思路，全面分析一下这个问题，然后写出求解的代码。不知道你今天的收获如何呢？如果感觉已经掌握了解题思路，不妨也去考考你们的同事或者朋友吧，刚好也有机会复述一遍今天所学。