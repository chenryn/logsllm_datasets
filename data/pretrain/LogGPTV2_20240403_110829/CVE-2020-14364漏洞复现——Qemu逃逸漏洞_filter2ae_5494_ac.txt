                 */
                s->async_stepdown = 0;
                qemu_bh_schedule(s->async_bh);
                trace_usb_ehci_doorbell_ring();
            }
            if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=
                ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {
                if (s->pstate == EST_INACTIVE) {
                    SET_LAST_RUN_CLOCK(s);
                }
                s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */
                ehci_update_halt(s);
                s->async_stepdown = 0;
                qemu_bh_schedule(s->async_bh);
            }
            break;
        case USBSTS:
            val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO
            ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC
            val = s->usbsts;
            ehci_update_irq(s);
            break;
        case USBINTR:
            val &= USBINTR_MASK;
            if (ehci_enabled(s) && (USBSTS_FLR & val)) {
                qemu_bh_schedule(s->async_bh);
            }
            break;
        case FRINDEX:
            val &= 0x00003fff; /* frindex is 14bits */
            s->usbsts_frindex = val;
            break;
        case CONFIGFLAG:
            val &= 0x1;
            if (val) {
                for(i = 0; i opregbase, addr2str(addr),
                                    *mmio, old);
    }
    ---------------------------------------------------------------------------------------------------------------------------    static void ehci_port_write(void *ptr, hwaddr addr,
                                uint64_t val, unsigned size)
    {
        EHCIState *s = ptr;
        int port = addr >> 2;
        uint32_t *portsc = &s->portsc[port];
        uint32_t old = *portsc;
        USBDevice *dev = s->ports[port].dev;
        trace_usb_ehci_portsc_write(addr + s->portscbase, addr >> 2, val);
        /* Clear rwc bits */
        *portsc &= ~(val & PORTSC_RWC_MASK);
        /* The guest may clear, but not set the PED bit */
        *portsc &= val | ~PORTSC_PED;
        /* POWNER is masked out by RO_MASK as it is RO when we've no companion */
        handle_port_owner_write(s, port, val);
        /* And finally apply RO_MASK */
        val &= PORTSC_RO_MASK;
        if ((val & PORTSC_PRESET) && !(*portsc & PORTSC_PRESET)) {
            trace_usb_ehci_port_reset(port, 1);
        }
        if (!(val & PORTSC_PRESET) &&(*portsc & PORTSC_PRESET)) {
            trace_usb_ehci_port_reset(port, 0);
            if (dev && dev->attached) {
                usb_port_reset(&s->ports[port]);
                *portsc &= ~PORTSC_CSC;
            }
            /*
             *  Table 2.16 Set the enable bit(and enable bit change) to indicate
             *  to SW that this port has a high speed device attached
             */
            if (dev && dev->attached && (dev->speedmask & USB_SPEED_MASK_HIGH)) {
                val |= PORTSC_PED;
            }
        }
        if ((val & PORTSC_SUSPEND) && !(*portsc & PORTSC_SUSPEND)) {
            trace_usb_ehci_port_suspend(port);
        }
        if (!(val & PORTSC_FPRES) && (*portsc & PORTSC_FPRES)) {
            trace_usb_ehci_port_resume(port);
            val &= ~PORTSC_SUSPEND;
        }
        *portsc &= ~PORTSC_RO_MASK;
        *portsc |= val;
        trace_usb_ehci_portsc_change(addr + s->portscbase, addr >> 2, *portsc, old);
    }
    ---------------------------------------------------------------------------------------------------------------------------    
## 绕过检测
在漏洞调用链中我们可以看到第一个与usb有关的函数是`ehci_work_bh`，然后`ehci_work_bh`调用`ehci_advance_periodic_state`，我们直接来看一下`ehci_work_bh`函数需要经过哪些步骤才能调用到`ehci_advance_periodic_state`，函数代码如下，根据代码可以发现想要调用到`ehci_advance_periodic_state`的话，需要`ehci_periodic_enabled(ehci)`或者`ehci->pstate
!=
EST_INACTIVE`这两个条件中的一个为真即可，`ehci_periodic_enabled`的代码也在下方，可以看到我们只需要设置`s->usbcmd`的值为`USBCMD_PSE
| USBCMD_RUNSTOP`就可以调用到`ehci_advance_periodic_state`，这里可能有人会疑问`(ehci->frindex
& 7) == 0`这个条件并没有设置呀，这是因为这里有个循环并且每次循环都会让`frindex`加1，所以就一定会使`(ehci->frindex &
7) == 0`这个条件为真
    ----------------------------------------------------------------------------------------------------------------------------    static void ehci_work_bh(void *opaque)
    {
        EHCIState *ehci = opaque;
        int need_timer = 0;
        int64_t expire_time, t_now;
        uint64_t ns_elapsed;
        uint64_t uframes, skipped_uframes;
        int i;
        if (ehci->working) {
            return;
        }
        ehci->working = true;
        ......
        if (ehci_periodic_enabled(ehci) || ehci->pstate != EST_INACTIVE) {
            need_timer++;
            ......
            for (i = 0; i = MIN_UFR_PER_TICK) {
                    ehci_commit_irq(ehci);
                    if ((ehci->usbsts & USBINTR_MASK) & ehci->usbintr) {
                        break;
                    }
                }
                if (ehci->periodic_sched_active) {
                    ehci->periodic_sched_active--;
                }
                ehci_update_frindex(ehci, 1);
                if ((ehci->frindex & 7) == 0) {
                    ehci_advance_periodic_state(ehci);
                }
                ehci->last_run_ns += UFRAME_TIMER_NS;
            }
        } 
        ......
    }
    ----------------------------------------------------------------------------------------------------------------------------    static inline bool ehci_async_enabled(EHCIState *s)
    {
        return ehci_enabled(s) && (s->usbcmd & USBCMD_ASE);
    }    
    ----------------------------------------------------------------------------------------------------------------------------    static inline bool ehci_enabled(EHCIState *s)
    {
        return s->usbcmd & USBCMD_RUNSTOP;
    }
    ----------------------------------------------------------------------------------------------------------------------------    
下一个应该调用的函数是`ehci_advance_state`，同样也来看一下`ehci_advance_periodic_state`的代码看看怎么样才能调用到`ehci_advance_state`，函数代码如下，这里仅仅需要设置一下list即可，然后list是由`ehci->periodiclistbase`来设置的，乍一看这个`periodiclistbase`是不可控的，但是我们仔细观察一下`ehci_opreg_write`，在这个函数中虽然没有直接对`periodiclistbase`赋值的语句，但是最后他有一行这样的代码`*mmio
= val;`，并且mmio的地址是我们可以控制的因为最开始有一行这样的代码`uint32_t *mmio = s->opreg + (addr >>
2);`，同时我们可以看到`EHCIState`结构中`periodiclistbase`是在`opre`
后面的，所以说我们就可以控制list的值了，然后后面list+4(调试的时候得到的，因为`list |= ((ehci->frindex & 0x1ff8)
>>
1);`这行代码导致的+4)，后面还有一个`get_dwords`函数，这个函数会从list取内容存到entry里面，这个函数并不需要设置返回的就是大于0的值
    static void ehci_advance_periodic_state(EHCIState *ehci)
    {
        uint32_t entry;
        uint32_t list;
        const int async = 0;
        // 4.6
        switch(ehci_get_state(ehci, async)) {
        case EST_INACTIVE:
            if (!(ehci->frindex & 7) && ehci_periodic_enabled(ehci)) {
                ehci_set_state(ehci, async, EST_ACTIVE);
                // No break, fall through to ACTIVE
            } else
                break;
        case EST_ACTIVE:
            if (!(ehci->frindex & 7) && !ehci_periodic_enabled(ehci)) {
                ehci_queues_rip_all(ehci, async);
                ehci_set_state(ehci, async, EST_INACTIVE);
                break;
            }
            list = ehci->periodiclistbase & 0xfffff000;
            /* check that register has been set */
            if (list == 0) {
                break;
            }
            list |= ((ehci->frindex & 0x1ff8) >> 1);
            if (get_dwords(ehci, list, &entry, 1)  %08X\n",
                    ehci->frindex / 8, list, entry);
            ehci_set_fetch_addr(ehci, async,entry);
            ehci_set_state(ehci, async, EST_FETCHENTRY);
            ehci_advance_state(ehci, async);
            ehci_queues_rip_unused(ehci, async);
            break;
        default:
            /* this should only be due to a developer mistake */
            fprintf(stderr, "ehci: Bad periodic state %d. "
                    "Resetting to active\n", ehci->pstate);
            g_assert_not_reached();
        }
    }
下面就是到了`ehci_advance_state`这个函数，这个函数有很多case分支，代码如下，可以看到我们想要调用的`ehci_state_execute`前面有一个assert，他要求q不为空，同时我们可以看到`EST_FETCHQH`分支会给q赋值，而且这个switch是在一个循环里面，也就意味着说我们可以多次执行分支代码，所以说我们只要让最后面的`if
(again  16)`这个为真就可以保证我们在获取到q之后还可以进入`EST_EXECUTE`分支。
首先动调发现每次进入这个函数的时候第一个进入的分支就是`EST_FETCHENTRY`，这个函数会根据`p_fetch_addr`来获取entry的地址，并且会根据entry的后三位来决定下次循环进入哪个分支，`p_fetch_addr`是由我们可控的，在上一层函数`ehci_advance_periodic_state`中会调用`ehci_set_fetch_addr`函数来给`p_fetch_addr`赋值，赋的值就是entry的地址，entry的地址是list+4，list的地址是我们可控的，所以我们可以让list地址为一块dmabuf，这样我们就可以控制entry的值，从而来使下次分支会经过`EST_FETCHQH`
经过`EST_FETCHQH`分支之后，并不能直接控制分支去执行`EST_EXECUTE`处的代码，这里我们需要在执行完`EST_FETCHQH`分支之后去执行`EST_FETCHQTD`分支，因为这个分支里面才可以控制下一次分支执行`EST_EXECUTE`处的代码，在`EST_FETCHQH`里面我们需要设置获取的qh的token为`1
async == async);
                    again = 1;
                } else {
                    again = 0;
                }
                break;
            case EST_FETCHITD: