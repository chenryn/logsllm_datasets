title:Automatically Fixing C Buffer Overflows Using Program Transformations
author:Alex Shaw and
Dusten Doggett and
Munawar Hafiz
2014 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
2014 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
2014 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
Automatically Fixing C Buffer Overﬂows Using
Program Transformations
Alex Shaw
Auburn University
Auburn, AL, USA
PI:EMAIL
Dusten Doggett
Auburn University
Auburn, AL, USA
PI:EMAIL
Munawar Haﬁz
Auburn University
Auburn, AL, USA
PI:EMAIL
Abstract—Fixing C buffer overﬂows at source code level
remains a manual activity, at best semi-automated. We present
an automated approach to ﬁx buffer overﬂows by describing two
program transformations that automatically introduce two well-
known security solutions to C source code. The transformations
embrace the difﬁculties of correctly analyzing and modifying C
source code considering pointers and aliasing. They are effective:
they ﬁxed all buffer overﬂows featured in 4,505 programs of
NIST’s SAMATE reference dataset, making the changes auto-
matically on over 2.3 million lines of code (MLOC). They are
also safe: we applied them to make hundreds of changes on
four open source programs (1.7 MLOC) without breaking the
programs. Automated transformations such as these can be used
by developers during coding, and by maintainers to ﬁx problems
in legacy code. They can be applied on a case by case basis, or
as a batch to ﬁx the root causes behind buffer overﬂows, thereby
improving the dependability of systems.
I.
INTRODUCTION
Buffer overﬂow still remains as a critical problem to ﬁx
in dependable systems. Many research works have explored
how to detect buffer overﬂow, both statically [36], [38],
[62], [63] and dynamically [11], [12]. Yet, buffer overﬂow
vulnerabilities have not been eliminated. In 2012, National
Vulnerability Database [59] published reports on 5,297 security
vulnerabilities. Of them, 843 (15.91%) were overﬂows [50].
Existing prevention approaches do not ﬁx overﬂows at
source code level. Some dynamic approaches ﬁx overﬂow
by making the stack non-executable [49], checking array
bounds [29], [35], or checking integrity of code pointers [12],
[17], but all of these solutions are introduced transparently at
run time. Moreover, these approaches suffer from performance
overhead and the solutions can be circumvented [6], [64].
These approaches do not help developers produce better code.
It is very easy to write C code with buffer overﬂows. Existing
approaches at best detect or ﬁx buffer overﬂows, but they
cannot guide developers to understand and write secure code.
A more effective and didactic solution to ﬁx buffer over-
ﬂows is to introduce the solution at C source code level, thus
teaching the developers as their problems are being ﬁxed.
CCured [8] and Cyclone [34] provides solutions to ﬁx buffer
overﬂows by using annotations that extend pure C, but these
annotations have to be introduced manually in the source code.
Other approaches [14], [40] to introduce ﬁxes automatically at
source code level are not safe to use, since they are supported
by minimal or non-existent program analysis, and therefore
often break the original program with the ﬁx.
We describe a program transformation based approach—
speciﬁcally two transformations that ﬁx buffer overﬂows in
C programs by automatically introducing two frequently pre-
scribed security solutions. Experts have identiﬁed that some
library functions in C are potentially unsafe and should not be
used in practice. Our SAFE LIBRARY REPLACEMENT (SLR)
transformation replaces unsafe library functions in a C program
with safer alternatives. Experts also suggest that any pointer
arithmetic should keep track of the buffer bounds at source
code level. However, introducing this solution in legacy code
requires a lot of manual effort. Our SAFE TYPE REPLACE-
MENT (STR) transformation replaces a character buffer with
a safe data structure that keeps track of the length information
which it uses to check buffer bounds during pointer operations.
They are similar to refactorings [20], but they do not intend to
preserve behavior. They are instead security-oriented program
transformations [24], [25], that improve the security of systems
by preserving expected behavior but ﬁxing the two most
prominent root causes behind buffer overﬂows: the use of
unsafe library functions and bad pointer operations.
A transformation based approach has several advantages.
• Developers must make small, frequent changes in source
code to ﬁx buffer overﬂows manually. People are bad at
repetitive tasks—computers are better.
• A program transformation based solution is more likely to
be adopted, especially if the transformations make small
changes [60]. Developers can use the transformations dur-
ing development, similar to how refactorings are used, or
use them to produce security patches during maintenance.
• The source-level program transformations would help de-
velopers better understand and be aware of the subtleties
of buffer overﬂow vulnerabilities.
• Most importantly, the transformations can be applied on a
case by case basis to ﬁx a speciﬁc overﬂow, or as a batch
to automatically ﬁx root causes in large legacy systems,
improving their dependability in the process.
Automatically transforming C programs to remove buffer
overﬂows at source code level is challenging. Many of the
safe function choices and the safe data structures need length
information about buffers. It is hard to determine the length
of a buffer using static analysis; pointers and aliasing further
complicate the analysis. Program analyses that are applicable
for compilers are not useful for program transformations, since
the program transformations need to keep track of source
code. For example, approaches to perform alias analysis for
compilers transform source code to SSA form; this is not
978-1-4799-2233-8/14 $31.00 © 2014 IEEE
978-1-4799-2233-8/14 $31.00 © 2014 IEEE
978-1-4799-2233-8/14 $31.00 © 2014 IEEE
DOI 10.1109/DSN.2014.25
DOI 10.1109/DSN.2014.25
DOI 10.1109/DSN.2014.25
124
124
124
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:01:43 UTC from IEEE Xplore.  Restrictions apply. 
useful for program transformations since the results will be
hard to map back to source code. None of the existing program
transformation infrastructures for C support sophisticated static
analyses at C source code level, e.g., Eclipse CDT only
supports name binding,
type analysis, and limited control
ﬂow analysis. Without data ﬂow analysis, it is impossible to
implement any non-trivial program transformation.
This paper describes the design decisions, the program
analyses, and the mechanism to analyze and transform C code
at source code level to ﬁx buffer overﬂows. We implemented
the transformations using OpenRefactory/C [27], an infrastruc-
ture for developing C program transformations. We validated
the transformations by applying them automatically on bench-
mark programs and open source software. We demonstrated
that the two program transformations are sufﬁcient to ﬁx all
possible C buffer overﬂows originating from unsafe functions
and bad pointer operations by automatically applying them to
remove buffer overﬂows from 4,505 benchmark programs of
NIST’s SAMATE reference dataset [48] (Section IV-A). The
program transformations ran on more than 2.3 million lines of
code (MLOC). The SAMATE programs have a function show-
ing normal behavior and another function showing problem
behavior. In all cases, our transformations preserved normal
behavior, and modiﬁed behavior resulting from overﬂows.
To demonstrate that our program transformations do not
break existing code, we automatically applied the three trans-
formations on all potential targets in four open source pro-
grams: libpng, zlib, GMP, and LibTIFF (Section IV-B). SLR
was applied on all
targeted unsafe functions, STR on all
local character pointer variables. In total, SLR was applied on
317 function calls; it modiﬁed 259 function call expressions
(average 81.7% in 4 programs). STR modiﬁed all 237 pointer
variables that passed its preconditions (100%), overall 80.01%
of all local variables. Even after these changes, the modiﬁed
programs had minimal performance overhead (Section IV-C).
This paper makes the following contributions.
• It describes two source-to-source behavior-enhancing pro-
gram transformations—the design decisions behind the
transformations (Section II) and the mechanism of the
transformations (Section III) including the program analy-
ses to support the transformations (Section III-A).
• It demonstrates that complex, yet accurate, source-level C
program transformations can be implemented as part of the
refactoring catalog of popular IDEs.
• It shows that the two program transformations can prevent
all types of buffer overﬂow originating from unsafe library
functions and bad pointer operations (Section IV-A). It also
tests the accuracy of the transformations by applying them
automatically to make many small modiﬁcations to open
source programs in a way that produces programs that
maintain functionality (Section IV-B) and have minimal
overhead (Section IV-C).
More details and results are available at our web page:
https://munawarhaﬁz.com/research/overﬂow.
II. PROGRAM TRANSFORMATIONS TO FIX OVERFLOWS
We concentrate on the two most common root causes of
buffer overﬂow. First, the C library includes several unsafe
functions that may lead to buffer overﬂows. For example,
strcpy (or strcat) copies (or concatenates) a source buffer
to a destination buffer, but does not put a restriction that
the copy (concatenation) should not overﬂow the destination
buffer. Second, programmers often make mistakes in pointer
operations, speciﬁcally pointer arithmetic; these mistakes lead
to buffer overﬂows.
Avoiding unsafe functions and keeping track of buffer
length are well-known solutions but are often not followed
in legacy code. Empirical studies have shown that developers
manually make these changes, but the manual process does not
scale for large programs [25]. This paper describes how these
prescribed solutions can be introduced as ﬁxes at source code
level using program transformations.
We introduce two program transformations. One replaces
unsafe library functions in C programs with safe alternatives
(SAFE LIBRARY REPLACEMENT, Section II-A). The other
replaces character pointers with safe data structures that keep
track of buffer length and available memory information during
pointer operations (SAFE TYPE REPLACEMENT, Section II-B).
Our transformations make structural changes to source code
using sophisticated program analysis. They modify source code
so that it conforms to a safe C programming style [56].
A. Safe Library Replacement (SLR)
You have a program that uses a library function that may
cause data injection attacks if it receives an insufﬁciently
validated input. You want to ensure that the program is not
vulnerable to injection attacks.
Replace unsafe functions with safe functions that are not
vulnerable even if malicious data is injected.
1) Motivation: C library functions that do not perform
extra checking during buffer operations are vulnerable to buffer
overﬂow. Table I shows some of these unsafe functions. Safer
alternatives (right column of Table I) have been introduced by
researchers. Some alternatives force developers to explicitly
mention the number of bytes that can be written to the buffer
(functions in glib library); others use a different C string
data type that can be resized at runtime (functions in libmib
library). However, the unsafe functions are still used frequently.
Moreover, there is a lot of legacy C code that contains these.
We surveyed the developers of the top ten most active
projects of all time in SourceForge about their development
approach. Six projects used C/C++, three used PHP and one
used Java. In ﬁve out of six C/C++ projects, programmers
initially used unsafe strcpy and strcat functions, but manually
changed to safer C/C++ string libraries later.
Manual changes are error-prone. This method does not
scale for large projects. For example, Ghostscript (about 800
KLOC) is a medium size program, but its programmers have
replaced only a few of its unsafe functions (109 of 318, 34.3%
of the strcpy functions; 6 of 172, 3.5% of strcat). We asked
the developers the reason for this. They said that manually
changing the functions are difﬁcult; hence they made changes
only to those functions that they thought were vulnerable. This
is clearly a dangerous practice for dependable systems.
125125125
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:01:43 UTC from IEEE Xplore.  Restrictions apply. 
Unsafe Library Functions
g_strlcpy from glib library [45]
Safe Alternative Functions
strcpy(3), strncpy(3) - Copy string
(3) indicates that documentation is available in Linux man section 3
gsize g_strlcpy(gchar *dst, const gchar *src, gsize dst_size);
astrcpy, astrn0cpy from libmib library [19]
char *strcpy (char *dst, const char *src);
char *strncpy (char *dst, const char *src, size_t num);
memcpy(3) - Copy memory area
void *memcpy(void *dst, const void *src, size_t num);
gets(3) - Get input from stdin
char *gets(char *dst);
getenv(3) - Get value of an environment variable
char *getenv(char *dst);
sprintf(3), snprintf(3) - Print string
char *sprintf(char *str,const char *format, ...);
char *astrcpy(char **dst_address, const char *src);
strcpy_s from ISO/IEC 24731 [31] and SafeCRT library [41]
StringCchCopy, StringCchCopyN from StrSafe [44] library
safestr_copy and safestr_ncopy from Safestr library [43]
memcpy_s from ISO/IEC 24731 [31]
errno_t memcpy_s(void *dst, size_t dst_size,
const void *src, size_t num);
gets_s from ISO/IEC 24731 [31], fgets from C99 [32]
char *gets_s(char *destination, size_t dest_size);
char *fgets(char *dst, int dst_size, FILE *stream);
afgets from libmib library [19], gets_s from SafeCRT library [41]
getenv_s function [41]
errno_t getenv_s(size_t *return-value,
char *dst, size_t dst_size, const char *name);
g_snprintf from glib library [45]
asprintf from libmib library [19]
sprintf_s from ISO/IEC 24731 [31] and SafeCRT [41]
gint g_snprintf (gchar *string, gulong n,
gchar const *format, ...);
int asprintf (char *ppaz, const char *format, ...);
TABLE I.
SOME UNSAFE FUNCTIONS AND THEIR SAFER ALTERNATIVES
2) Precondition: A developer selects a function call ex-
pression and invokes the SAFE LIBRARY REPLACEMENT
transformation. The following preconditions are checked:
• The function is one of the unsafe library functions sup-
• The size of the buffer being written to can be calculated
by applying control ﬂow, data ﬂow, and alias analysis. If
the size of the buffer cannot be determined by our program
analysis, the precondition will not be met.
ported by the transformation.
3) Solution: Replace an unsafe function call with a safer
alternative. SLR uses safer alternatives that check and truncate
inputs to match the size of destination buffers, similar to
glib functions. These functions are syntactically similar to the
original functions. They do not require new data types like the
libmib functions; therefore, the changes will be minimal per
instance. The transformation has to analyze the program and
calculate the exact size of the destination buffer to introduce as
the extra parameter. This analysis is complicated by pointers