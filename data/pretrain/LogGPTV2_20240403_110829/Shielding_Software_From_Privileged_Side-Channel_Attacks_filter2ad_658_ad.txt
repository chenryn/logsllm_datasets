Our prototype also implements the LLC side-channel
mitigation features in Section 5.4. As our test machines
support 4 cache partitions, we reserved one for the Ap-
parition VM (dubbed VM COS), one for the OS kernel
and non-ghosting applications (dubbed kernel COS), and
one for a ghosting application (dubbed ghosting COS).
We modiﬁed all of the SVA-OS instructions to switch
between the kernel COS and the VM COS upon entry
and exit. Our prototype switches between the ghosting
COS and the kernel COS on context switches between
ghosting and non-ghosting applications.
It also multi-
plexes the ghosting COS by ﬂushing the cache on context
switches between two ghosting applications.
8 Evaluation
We ﬁrst evaluate the performance optimizations de-
scribed in Section 4. We then evaluate the performance
overheads of our page table and LLC side-channel de-
fenses.
8.1 Methodology
For our experiments, we used a Dell Precision T3620
workstation with an Intel R(cid:13) CoreTM i7-6700 hyper-
threading quad-core processor at 3.40 GHz with an 8 MB
16-way LLC, 16 GB of RAM, and an Intel E1000 net-
work card. The machine has both a 256 GB Solid State
Drive (SSD) and a 7,200 RPM 500 GB hard disk. We
stored all the ﬁles for our experiments on the SSD. For
the network experiments, we used a dedicated Gigabit
Ethernet network and a Dell T1700 Precision worksta-
tion as the remote system. The T1700 runs FreeBSD
9.3 and has an Intel R(cid:13) CoreTM i7-4770 hyper-threading
quad-core processor at 3.40 GHz and 16 GB of RAM.
We perform our experiments with the OS running in
single-user mode to reduce noise from other processes
on the system. We use a high-resolution timer (reading
rdtsc directly) to measure time, and we report the aver-
age (arithmetic mean of) execution time of multiple runs.
Our evaluation needed benchmarks and applications
that rely heavily on OS kernel services e.g., the ﬁle sys-
tem and network stack. Our evaluation therefore used the
following programs:
LMBench: We used the LMBench benchmark
suite [55] to measure the latency of various system calls
on Virtual Ghost with and without the new optimizations.
For the benchmarks for which we can specify the num-
ber of repetitions to run, we used 1,000 repetitions. LM-
Bench reports the median result of the number of repe-
titions speciﬁed. We conﬁgured lat select to use lo-
cal ﬁles. In lat ctx, we measured context switch time
between two processes; each process does nothing but
passes a token to the other process via a pipe. For all the
other workloads, we used the default conﬁgurations.
OpenSSH Client: We used the preinstalled
OpenSSH [65] Secure Shell client and server
to
evaluate the Virtual Ghost optimizations. We ran the
OpenSSH client on our FreeBSD 9.0 machine and
the server on the FreeBSD 9.3 machine to measure
bandwidth. We generated the contents of each ﬁle by
collecting random numbers from the /dev/random
device on our FreeBSD 9.0 machine and transferred the
ﬁles to the FreeBSD 9.3 machine.
Ghosting OpenSSH Client: We evaluated our de-
fenses on the ssh and ssh-keygen programs of the
OpenSSH 6.2p1 application suite modiﬁed by Criswell
et al.
to use ghost memory to store heap objects [26]:
ssh-keygen generates public and private key pairs for
ssh to use for password-less authentication. Criswell et
al. enhanced these two programs to share a hard-coded
AES private application key that they use to encrypt pri-
vate authentication keys. The ssh-keygen program en-
crypts all the private authentication key ﬁles it generates
with this private application key. The ssh client decrypts
these keys and puts them, as well as all other heap ob-
jects, into ghost memory. For these experiments, we ran
the ghosting OpenSSH client on the Virtual Ghost and
Apparition machine and the server on the machine run-
ning native FreeBSD 9.3. We collected the bandwidth
reported in the ssh client’s debug output when transfer-
ring 1 KB to 512 MB ﬁles using the modiﬁed ssh client.
We transferred the ﬁles by having the ssh client run the
cat command on the ﬁles on the server.
Ghosting Bzip2: We compiled Bzip2 1.0.6, a data
compression program [16], with a new C library that can,
at run-time, be conﬁgured to allocate heap objects in ei-
ther traditional user-space memory or in ghost memory.
We measure the time for Bzip2 to compress the 32 MB
ﬁle we used in the OpenSSH experiments.
Ghosting GnuPG: We compiled GnuPG 2.0.18, a
cryptography program [45], with our C library that can,
at run-time, be conﬁgured to allocate heap objects in ei-
ther traditional user-space memory or in ghost memory.
We evaluate encrypting, decrypting, signing, and verify-
ing signatures of ﬁles ranging from 1 KB to 32 MB in
size. Due to space, we only report overheads for sign-
ing ﬁles. Encryption, decryption, and veriﬁcation have
1450    27th USENIX Security Symposium
USENIX Association
Test
null syscall
open/close
mmap
page fault
fork + exit
fork + exec
fork + /bin/sh -c
signal handler install
signal handler delivery
read
write
stat
select
fcntl lock
context switch
pipe
Native
(µs)
0.1
1.8
5.6
36.3
49.2
54.4
515.4
0.2
1.1
0.1
0.1
1.2
2.8
2.8
0.5
1.6
Std.
Dev.
0.0
0.0
0.1
1.3
0.1
0.1
1.0
0.0
0.0
0.0
0.0
0.0
0.0
0.0
0.0
0.0
VG
Overhead
2.9×
2.3×
5.1×
1.0×
4.1×
3.9×
2.2×
2.3×
0.9×
2.7×
2.9×
2.1×
1.9×
1.9×
1.2×
1.7×
Opt-VG
Overhead
2.6×
1.8×
3.4×
1.0×
2.0×
1.9×
1.5×
2.1×
0.8×
2.3×
2.5×
1.8×
1.6×
1.6×
1.0×
1.5×
Table 3: LMBench Latency Results
similar overheads.
Ghosting RandomAccess: We created a microbench-
mark named RandomAccess which modiﬁes an 8 MB ar-
ray of 64 B elements in the heap in random order 20,000
times. Speciﬁcally, it ﬁrst generates a random order in
which to access all the array elements, ensuring that ev-
ery element in the array is accessed once. It then iterates
over the array in the random order, replacing the contents
of the current element with the index of the previously
accessed element. The ﬁrst iteration warms up the cache
and is not used in measuring performance; RandomAc-
cess records the execution time of the next 20,000 itera-
tions and reports the average latency of an iteration. By
seeding the pseudo-random number generator with the
same seed, RandomAccess can exhibit deterministic re-
sults. We link RandomAccess with our C library so that
we can conﬁgure it to allocate heap objects in traditional
user-space memory or in ghost memory as needed.
Ghosting Clang: We compiled Clang 3.0, a C/C++
compiler [1], with our C library that can, at run-time,
be conﬁgured to allocate heap objects in either tradi-
tional user-space memory or in ghost memory. We
measured the time to compile a C source ﬁle named
gcc-smaller.c from SPEC CPU 2017 [5] into assem-
bly code by using Clang. We used the -O3 and -pipe
command-line options.
Besides the native FreeBSD 9.0 kernel, we have
conducted our experiments on the FreeBSD SVA
kernels with the following conﬁgurations of Virtual
Ghost/Apparition:
Test
pipe
Native
(MB/s)
14,865.2
Std.
Dev.
29.7
VG
Overhead
1.3×
Opt-VG
Overhead
1.2×
Table 4: LMBench Bandwidth Results
3. Opt-VG-PG: The optimized Virtual Ghost en-
hanced with only our defenses to the page table
side-channel attacks.
4. Opt-VG-LLCPart: The optimized Virtual Ghost
enhanced with only our mitigations to the LLC side-
channel attacks.
5. Apparition: The optimized Virtual Ghost enhanced
with the defenses to both the page table and LLC
side-channel attacks (in other words, the full Ap-
parition system).
8.2 Virtual Ghost Optimizations
We evaluate the overheads of the optimized version of
Virtual Ghost’s SFI enforcement and SVA-OS MMU in-
structions (described in Section 4) relative to the orig-
inal Virtual Ghost and to native x86-64 FreeBSD. For
the baseline kernel, we used a native x86-64 FreeBSD
9.0 kernel conﬁgured with the same options as the Vir-
tual Ghost FreeBSD kernels and compiled with the same
compiler and compilation options. We focus here on
evaluating the overheads of Virtual Ghost on traditional
non-ghosting applications, i.e., applications that do not
use ghost memory but still need to run on the Virtual
Ghost system. Our microbenchmarks and benchmark ap-
plications therefore do not use ghost memory when run-
ning on Virtual Ghost.
As shown below, our optimizations always improve
performance for the benchmarks we tested.
Microbenchmarks: We used the LMBench bench-
mark suite [55] to measure the latency of various system
calls on Virtual Ghost with and without the new opti-
mizations. Tables 3 and 4 show the performance of the
1. VG: Virtual Ghost without the new optimizations
described in Section 4 and without our new de-
fenses. This version of Virtual Ghost is a faster and
more robust implementation of the original proto-
type [26].
2. Opt-VG: Virtual Ghost with the optimizations de-
scribed in Section 4.
Figure 4: LMBench File Creation/Deletion Rate
USENIX Association
27th USENIX Security Symposium    1451
 - 25,000 50,000 75,000 100,000 125,000 150,000 175,000 200,000 225,000 250,0000k1k4k10kFiles Created/Deleted Per SecondFile Size (KB)Native-createVG-createOpt-VG-createNative-deleteVG-deleteOpt-VG-deletenative FreeBSD 9.0 kernel and the overheads of Virtual
Ghost, with and without the optimizations, normalized to
the native FreeBSD 9.0 kernel. While the overheads in
Table 3 may seem high, we note that the performance of
real-world applications (shown subsequently) are much
better as applications only spend a portion of their time
executing kernel code.
As Tables 3 and 4 show, Virtual Ghost incurs 2.4×
overhead on average while our optimizations reduce the
overhead to 1.8× on average.
In particular, elimina-
tion of serializing instructions improves system calls that
perform many page table updates. For example, fork
+ exit overhead drops from 4.1× to 2.0×, and fork
+ exec drops from 3.9× to 1.9×. On FreeBSD, the
mmap() system call premaps some amount of physical
memory to the newly mapped region, so our optimiza-
tions also improve its overhead from 5.1× to 3.4×.
Signal handler function dispatch shows a slight perfor-
mance improvement on Virtual Ghost compared to native
FreeBSD. The FreeBSD kernel on Virtual Ghost cannot
read the register state saved on interrupts, traps, and sys-
tem calls [26] and therefore does not copy this informa-
tion into the user-space stack for signal handlers to in-
spect like the FreeBSD kernel does. We believe this is
why Virtual Ghost shows a slight performance beneﬁt
for signal handler dispatch.
Figure 4 reports the performance of the ﬁle cre-
ation/deletion workload of LMBench on native FreeBSD
and Virtual Ghost with and without the new optimiza-
tions. Virtual Ghost slows down the ﬁle creation and
deletion rates by 2.2× and 2.1×, respectively, on average
across all ﬁle sizes, and the optimizations reduce both of
the overheads to 1.7×. The standard deviation is 0% for
all ﬁle sizes tested.