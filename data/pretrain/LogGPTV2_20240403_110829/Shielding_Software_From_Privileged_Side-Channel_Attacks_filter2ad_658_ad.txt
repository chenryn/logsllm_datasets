### Implementation of LLC Side-Channel Mitigation

Our prototype incorporates the LLC side-channel mitigation features detailed in Section 5.4. Given that our test machines support four cache partitions, we allocated one partition to the Apparition VM (referred to as VM COS), another to the OS kernel and non-ghosting applications (referred to as Kernel COS), and a third to a ghosting application (referred to as Ghosting COS). We modified all SVA-OS instructions to switch between the Kernel COS and the VM COS upon entry and exit. Our prototype also switches between the Ghosting COS and the Kernel COS during context switches between ghosting and non-ghosting applications. Additionally, it multiplexes the Ghosting COS by flushing the cache on context switches between two ghosting applications.

### Evaluation

#### Performance Optimizations
We first evaluate the performance optimizations described in Section 4, followed by an assessment of the performance overheads associated with our page table and LLC side-channel defenses.

#### Methodology
For our experiments, we used a Dell Precision T3620 workstation equipped with an Intel Core i7-6700 hyper-threading quad-core processor running at 3.40 GHz, featuring an 8 MB 16-way LLC, 16 GB of RAM, and an Intel E1000 network card. The machine has both a 256 GB SSD and a 7,200 RPM 500 GB hard disk. All files for our experiments were stored on the SSD. For network experiments, we utilized a dedicated Gigabit Ethernet network and a Dell T1700 Precision workstation as the remote system. The T1700 runs FreeBSD 9.3 and is equipped with an Intel Core i7-4770 hyper-threading quad-core processor at 3.40 GHz and 16 GB of RAM.

To minimize noise from other processes, we conducted our experiments with the OS running in single-user mode. We used a high-resolution timer (reading `rdtsc` directly) to measure time and reported the average execution time over multiple runs.

#### Benchmarks and Applications
Our evaluation required benchmarks and applications that heavily rely on OS kernel services, such as the file system and network stack. We used the following programs:

- **LMBench**: We employed the LMBench benchmark suite [55] to measure the latency of various system calls on Virtual Ghost with and without the new optimizations. For benchmarks where the number of repetitions can be specified, we used 1,000 repetitions. LMBench reports the median result of the specified number of repetitions. We configured `lat_select` to use local files and measured context switch time between two processes in `lat_ctx`, where each process does nothing but passes a token to the other process via a pipe. For all other workloads, we used the default configurations.

- **OpenSSH Client**: We used the preinstalled OpenSSH [65] Secure Shell client and server to evaluate the Virtual Ghost optimizations. We ran the OpenSSH client on our FreeBSD 9.0 machine and the server on the FreeBSD 9.3 machine to measure bandwidth. The contents of each file were generated by collecting random numbers from the `/dev/random` device on our FreeBSD 9.0 machine and then transferred to the FreeBSD 9.3 machine.

- **Ghosting OpenSSH Client**: We evaluated our defenses on the `ssh` and `ssh-keygen` programs of the OpenSSH 6.2p1 application suite, modified by Criswell et al. [26] to use ghost memory for storing heap objects. `ssh-keygen` generates public and private key pairs for `ssh` to use for password-less authentication. These programs share a hard-coded AES private application key to encrypt private authentication keys. The `ssh-keygen` program encrypts all private authentication key files with this private application key, and the `ssh` client decrypts these keys and places them, along with all other heap objects, into ghost memory. For these experiments, we ran the ghosting OpenSSH client on the Virtual Ghost and Apparition machine, with the server on the native FreeBSD 9.3 machine. We collected the bandwidth reported in the `ssh` client’s debug output when transferring files ranging from 1 KB to 512 MB using the modified `ssh` client. The files were transferred by having the `ssh` client run the `cat` command on the files on the server.

- **Ghosting Bzip2**: We compiled Bzip2 1.0.6, a data compression program [16], with a new C library that can, at runtime, be configured to allocate heap objects in either traditional user-space memory or in ghost memory. We measured the time for Bzip2 to compress a 32 MB file used in the OpenSSH experiments.

- **Ghosting GnuPG**: We compiled GnuPG 2.0.18, a cryptography program [45], with our C library that can, at runtime, be configured to allocate heap objects in either traditional user-space memory or in ghost memory. We evaluated the performance of encrypting, decrypting, signing, and verifying signatures of files ranging from 1 KB to 32 MB in size. Due to space constraints, we only report overheads for signing files. Encryption, decryption, and verification have similar overheads.

- **Ghosting RandomAccess**: We created a microbenchmark named `RandomAccess` which modifies an 8 MB array of 64 B elements in the heap in random order 20,000 times. Specifically, it first generates a random order to access all array elements, ensuring each element is accessed once. It then iterates over the array in the random order, replacing the contents of the current element with the index of the previously accessed element. The first iteration warms up the cache and is not used in measuring performance; `RandomAccess` records the execution time of the next 20,000 iterations and reports the average latency of an iteration. By seeding the pseudo-random number generator with the same seed, `RandomAccess` can produce deterministic results. We linked `RandomAccess` with our C library to configure it to allocate heap objects in traditional user-space memory or in ghost memory as needed.

- **Ghosting Clang**: We compiled Clang 3.0, a C/C++ compiler [1], with our C library that can, at runtime, be configured to allocate heap objects in either traditional user-space memory or in ghost memory. We measured the time to compile a C source file named `gcc-smaller.c` from SPEC CPU 2017 [5] into assembly code using Clang, with the `-O3` and `-pipe` command-line options.

#### Experimental Configurations
In addition to the native FreeBSD 9.0 kernel, we conducted our experiments on the FreeBSD SVA kernels with the following configurations of Virtual Ghost/Apparition:

1. **VG**: Virtual Ghost without the new optimizations described in Section 4 and without our new defenses. This version of Virtual Ghost is a faster and more robust implementation of the original prototype [26].
2. **Opt-VG**: Virtual Ghost with the optimizations described in Section 4.
3. **Opt-VG-PG**: The optimized Virtual Ghost enhanced with only our defenses against page table side-channel attacks.
4. **Opt-VG-LLCPart**: The optimized Virtual Ghost enhanced with only our mitigations against LLC side-channel attacks.
5. **Apparition**: The optimized Virtual Ghost enhanced with defenses against both page table and LLC side-channel attacks (i.e., the full Apparition system).

#### Results
##### Virtual Ghost Optimizations
We evaluated the overheads of the optimized version of Virtual Ghost's SFI enforcement and SVA-OS MMU instructions (described in Section 4) relative to the original Virtual Ghost and to native x86-64 FreeBSD. For the baseline kernel, we used a native x86-64 FreeBSD 9.0 kernel configured with the same options as the Virtual Ghost FreeBSD kernels and compiled with the same compiler and compilation options. We focused on evaluating the overheads of Virtual Ghost on traditional non-ghosting applications, i.e., applications that do not use ghost memory but still need to run on the Virtual Ghost system. Our microbenchmarks and benchmark applications, therefore, did not use ghost memory when running on Virtual Ghost.

As shown below, our optimizations consistently improved performance for the benchmarks we tested.

**Microbenchmarks:**
We used the LMBench benchmark suite [55] to measure the latency of various system calls on Virtual Ghost with and without the new optimizations. Tables 3 and 4 show the performance of the native FreeBSD 9.0 kernel and the overheads of Virtual Ghost, with and without the optimizations, normalized to the native FreeBSD 9.0 kernel. While the overheads in Table 3 may seem high, real-world applications (shown subsequently) perform much better, as they spend only a portion of their time executing kernel code.

| Test | Native (µs) | Std. Dev. | VG Overhead | Opt-VG Overhead |
|------|-------------|-----------|-------------|-----------------|
| null syscall | 0.1 | 0.0 | 2.9× | 2.6× |
| open/close | 1.8 | 0.0 | 2.3× | 1.8× |
| mmap | 5.6 | 0.1 | 5.1× | 3.4× |
| page fault | 36.3 | 1.3 | 1.0× | 1.0× |
| fork + exit | 49.2 | 0.1 | 4.1× | 2.0× |
| fork + exec | 54.4 | 0.1 | 3.9× | 1.9× |
| fork + /bin/sh -c | 515.4 | 1.0 | 2.2× | 1.5× |
| signal handler install | 0.2 | 0.0 | 2.3× | 2.1× |
| signal handler delivery | 1.1 | 0.0 | 0.9× | 0.8× |
| read | 0.1 | 0.0 | 2.7× | 2.3× |
| write | 0.1 | 0.0 | 2.9× | 2.5× |
| stat | 1.2 | 0.0 | 2.1× | 1.8× |
| select | 2.8 | 0.0 | 1.9× | 1.6× |
| fcntl lock | 2.8 | 0.0 | 1.9× | 1.6× |
| context switch | 2.8 | 0.0 | 1.9× | 1.6× |
| pipe | 0.5 | 0.0 | 1.2× | 1.0× |

| Test | Native (MB/s) | Std. Dev. | VG Overhead | Opt-VG Overhead |
|------|---------------|-----------|-------------|-----------------|
| pipe | 14,865.2 | 29.7 | 1.3× | 1.2× |

**File Creation/Deletion Rate:**
Figure 4 shows the performance of the file creation/deletion workload of LMBench on native FreeBSD and Virtual Ghost with and without the new optimizations. Virtual Ghost slows down the file creation and deletion rates by 2.2× and 2.1×, respectively, on average across all file sizes, and the optimizations reduce both overheads to 1.7×. The standard deviation is 0% for all file sizes tested.

![LMBench File Creation/Deletion Rate](figure4.png)

In summary, our optimizations significantly reduce the overheads of Virtual Ghost, improving the performance of various system calls and reducing the impact on real-world applications.