IEEE,
2014. [Online]. Available: https://users.ece.cmu.edu/∼yoonguk/papers/
kim-isca14.pdf
[28] J. A. Clause, I. Doudalis, A. Orso, and M. Prvulovic, “Effective
memory protection using dynamic tainting,” in 22nd IEEE/ACM
International Conference on Automated Software Engineering (ASE).
ACM, 2007, pp. 284–292. [Online]. Available: http://www.cc.gatech.
edu/∼orso/papers/clause.doudalis.orso.prvulovic.pdf
[29] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie, A. Grier,
P. Wagle, and Q. Zhang, “StackGuard: Automatic Adaptive Detection
and Prevention of Buffer-Overﬂow Attacks,” in Proceedings of the 7th
USENIX Security Symposium, January 1998.
[30] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham,
and M. Winandy, “Return-Oriented Programming without Returns,”
in International Conference on Information Systems Security (CCS).
ACM, 2010.
[31] M. Abadi, M. Budiu,
´U. Erlingsson, and J. Ligatti, “Control-ﬂow
integrity,” in 12th ACM Conference on Computer and Communications
Security. ACM, 2005, pp. 340–353.
[Online]. Available: https:
//research.microsoft.com/apps/pubs/?id=69217
[32] klog. (1999) The Frame Pointer Overwrite. http://phrack.org/issues/55/
8.html.
[33] M. Conti, S. Crane, L. David, M. Franz, P. Larsen, C. Liebchen,
M. Negro, M. Qunaibit, and A.-R. Sadeghi, “Losing Control: On the
Effectiveness of Control-Flow Integrity under Stack Attacks,” in ACM
Conference on Computer and Communications Security. ACM, 2015,
pp. 952–963.
[34] P. Akritidis, C. Cadar, C. Raicui, M. Costa, and M. Castro, “Preventing
memory error exploits with WIT,” in Proceedings of the 29th IEEE
Symposium on Security and Privacy.
IEEE, 2008.
[35] M. Castro, M. Costa, and T. Harris, “Securing software by enforcing
data-ﬂow integrity,” in USENIX Symposium on Operating System Design
and Implementation, 2006.
[36] Qualsys, Inc. (2017) Qualys Security Advisory—The Stack Clash. https:
//www.qualys.com/2017/06/19/stack-clash/stack-clash.txt. 2018-03-29.
[37] A. Prakash and H. Yin, “Defeating ROP Through Denial of Stack Pivot,”
in Annual Computer Security Applications Conference. ACM, 2015.
[38] Standard Performance Evaluation Corporation. (2006) SPEC CPU 2006.
https://www.spec.org/cpu2006/.
[39] N. Muralimanohar, R. Balasubramonian, and N. P. Jouppi, “CACTI
6.0: A tool to model large caches,” HP Labs, Palo Alto, CA, HPL
2009-85, April 2009, latest code release for CACTI 6 is 6.5. [Online].
Available: http://www.hpl.hp.com/techreports/2009/HPL-2009-85.html
491
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:32:21 UTC from IEEE Xplore.  Restrictions apply. 
[40] Free Standards Group, DWARF Debugging Information Format, http:
//www.dwarfstd.org/doc/Dwarf3.pdf.
[41] D. Anderson. (2017) David A’s DWARF Page. https://www.prevanders.
net/dwarf.html. 2017-8-12.
[42] N. Binkert, B. Beckmann, G. Black, S. K. Reinhardt, A. Saidi, A. Basu,
J. Hestness, D. R. Hower, T. Krishna, S. Sardashti, R. Sen, K. Sewell,
M. Shoaib, N. Vaish, M. D. Hill, and D. A. Wood, “The gem5 simulator,”
in ACM SIGARCH Computer Architecture News, 2014.
[43] H. Ozdoganoglu, T. Vijaykumar, C. E. Brodley, B. A. Kuperman, and
A. Jalote, “SmashGuard: A Hardware Solution to Prevent Security
Attacks on the Function Return Address,” IEEE Transactions on
Computers, vol. 55, pp. 1271–1284, Oct. 2006. [Online]. Available:
http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1683758
[44] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, “Address-
Sanitizer: A Fast Address Sanity Checker,” in USENIX Annual Technical
Conference, 2012.
[45] S. Nagarakatte, J. Zhao, M. M. K. Martin, and S. Zdencewic, “Soft-
Bound: Highly compatible and complete spatial memory safety for c,”
in Proceedings of the ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI), 2009.
[46] J. Wilander, N. Nikiforakis, Y. Younan, M. Kamkar, and W. Joosen,
“RIPE: Runtime Intrusion Prevention Evaluator,” in 27th Annual Com-
puter Security Applications Conference (ACSAC). ACM, 2011.
[47] H. Shacham, “The geometry of innocent ﬂesh on the bone: return-
into-libc without function calls (on the x86),” in ACM Conference on
Computer and Communications Security. ACM, 2007, pp. 552–561.
[Online]. Available: http://cseweb.ucsd.edu/∼hovav/dist/geometry.pdf
[48] E. Buchanan, R. Roemer, H. Shacham, and S. Savage, “When Good
Instructions Go Bad: Generalizing Return-Oriented Programming to
RISC,” in Proc. ACM CCS, Oct. 2008, pp. 27–38.
[49] T. Newsham, “Bugtraq: Re: Smashing the Stack: prevention?” Apr.
1997. [Online]. Available: http://seclists.org/bugtraq/1997/Apr/129
[50] Solar Designer, “Bugtraq: Getting around non-executable stack (and
ﬁx),” Aug. 1997. [Online]. Available: http://seclists.org/bugtraq/1997/63
[51] MITRE, “CVE-2012-0769.” Available from MITRE, CVE-2012-0769
CVE-2012-0769., 2012. [Online]. Available: https://www.cve.mitre.org/
cgi-bin/cvename.cgi?name=CVE-2012-0769
[52] H. Hu, S. Shinde, S. Adrian, Z. L. Chua, P. Saxena, and Z. Liang,
“Data-Oriented Programming: On the Expressiveness of Non-Control
Data Attacks,” in IEEE Symposium on Security and Privacy (Oakland
S&P).
IEEE Computer Society, May 2016.
[53] I. Evans, S. Fingeret, J. Gonzalez, U. Otgonbaatar, T. Tang, H. Shrobe,
S. Sidiroglou-Douskos, M. Rinard, and H. Okhravi, “Missing the
Point(er): On the Effectiveness of Code Pointer Integrity,” in IEEE
Symposium on Security and Privacy (Oakland S&P).
IEEE Computer
Society, May 2015.
[54] A. Joannou, J. Woodruff, R. Kovacsics, S. W. Moore, A. Bradbury,
H. Xia, R. N. Watson, D. Chisnall, M. Roe, B. Davis, E. Napierala,
J. Baldwin, K. Gudka, P. G. Neumann, A. Mazzinghi, A. Richardson,
S. Son, and A. T. Markettos, “Efﬁcient tagged memory,” in Proceedings
of the International Conference on Computer Design (ICCD), 2017,
pp. 641–648. [Online]. Available: doi.ieeecomputersociety.org/10.1109/
ICCD.2017.112
[55] lowRISC project
team, “Tagged memory and minion cores in the
lowRISC SoC,” Computer Laboratory, University of Cambridge,
lowRISC-MEMO 2014-001, December 2014, http://www.lowrisc.org/
docs/memo-2014-001-tagged-memory-and-minion-cores/.
[56] W. Song, A. Bradbury,
tagged memory,”
purpose
Workshop,
06/riscv-tagged-mem-workshop-june2015.pdf.
2015,
June
and R. Mullins,
Proceedings
general
RISC-V
https://riscv.org/wp-content/uploads/2015/
“Towards
of
the
in
[57] A. Limited, “ARM architecture reference manual: ARMv8,
for
ARMv8-A architecture proﬁle,” December 2017. [Online]. Available:
https://static.docs.arm.com/ddi0487/ca/DDI0487C a armv8 arm.pdf
[58] lazytyped, “ADI vs. ROP,” https://lazytyped.blogspot.com/2017/09/
adi-vs-rop.html, September 2017.
[59] D. Chisnall, C. Rothwell, R. N. Watson, J. Woodruff, M. Vadera,
S. W. Moore, M. Roe, B. Davis, and P. G. Neumann, “Beyond the
PDP-11: Architectural support for a memory-safe C abstract machine,”
in Proceedings of
the International Conference on Architectural
for Programming Languages and Operating Systems, ser.
Support
ASPLOS ’15. ACM, 2015, pp. 117–130.
[Online]. Available:
http://doi.acm.org/10.1145/2694344.2694367
and A. Tolmach,
[60] A. Azevedo de Amorim, M. D´en`es, N. Giannarakis, C. Hrit¸cu,
“Micro-
B. C. Pierce, A. Spector-Zabusky,
tag-based security monitors,” in 36th
policies: Formally veriﬁed,
IEEE Symposium on Security and Privacy (Oakland S&P).
IEEE
Computer Society, May 2015, pp. 813–830. [Online]. Available: http:
//prosecco.gforge.inria.fr/personal/hritcu/publications/micro-policies.pdf
[61] A. Azevedo de Amorim, N. Collins, A. DeHon, D. Demange, C. Hrit¸cu,
D. Pichardie, B. C. Pierce, R. Pollack, and A. Tolmach, “A veriﬁed
information-ﬂow architecture,” in Proceedings of the 41st Symposium on
Principles of Programming Languages, ser. POPL. ACM, Jan. 2014,
pp. 165–178. [Online]. Available: http://www.crash-safe.org/node/29
[62] A. Azevedo de Amorim, “A methodology for micro-policies,” Ph.D.
dissertation, University of Pennsylvania, 2017. [Online]. Available:
http://www.seas.upenn.edu/∼aarthur/thesis.pdf
[63] J. Brown and T. F. Knight, Jr., “A minimally trusted computing base
for dynamically ensuring secure information ﬂow,” MIT CSAIL, Tech.
Rep. 5, November 2001, aries Memo No. 15. [Online]. Available:
http://www.ai.mit.edu/projects/aries/Documents/Memos/ARIES-15.pdf
[64] U. Dhawan, A. Kwon, E. Kadric, C. Hrit¸cu, B. C. Pierce,
J. M. Smith, A. DeHon, G. Malecha, G. Morrisett, T. F. Knight,
Jr., A. Sutherland, T. Hawkins, A. Zyxnfryx, D. Wittenberg,
P. Trei, S. Ray, and G. Sullivan, “Hardware support
for safety
in SASO Workshop on Adaptive
interlocks
Host and Network Security, Sep. 2012.
[Online]. Available: http:
//www.crash-safe.org/sites/default/ﬁles/interlocks ahns2012.pdf
and introspection,”
[65] A. DeHon, E. Boling, R. Nikhil, D. Rad, J. Schwarz, N. Sharma,
J. Stoy, G. Sullivan, and A. Sutherland, “DOVER: A Metadata-
Extended RISC-V,” in RISC-V Workshop, Jan. 2016, accompanying
talk at http://youtu.be/r5dIS1kDars. [Online]. Available: http://riscv.org/
wp-content/uploads/2016/01/Wed1430-dover riscv jan2016 v3.pdf
[66] S. Chen, M. Kozuch, T. Strigkos, B. Falsaﬁ, P. B. Gibbons,
T. C. Mowry, V. Ramachandran, O. Ruwase, M. P. Ryan, and
E. Vlachos, “Flexible Hardware Acceleration for Instruction-Grain
Program Monitoring,” in 35th International Symposium on Computer
Architecture (ISCA).
IEEE, 2008, pp. 377–388. [Online]. Available:
http://www.cs.cmu.edu/∼lba/papers/LBA-isca08.pdf
[67] S. Fytraki, E. Vlachos, Y. O. Koc¸berber, B. Falsaﬁ, and B. Grot,
instruction-grain
“FADE: A programmable ﬁltering accelerator
monitoring,”
in 20th IEEE International Symposium on High
Performance Computer Architecture, HPCA 2014, Orlando, FL, USA,
February 15-19, 2014, 2014, pp. 108–119.
[Online]. Available:
http://dx.doi.org/10.1109/HPCA.2014.6835922
[68] M. A. Wahab, P. Cotret, M. N. Allah, G. Hiet, V. Laptre, and G. Gogniat,
“ARMHEx: A hardware extension for DIFT on ARM-based SoCs,” in
Proceedings of the International Conference on Field-Programmable
Logic and Applications, Sept 2017, pp. 1–7.
for
A. Implementation Challenges
APPENDIX
setjmp/longjmp: System code written in C, as well as the
SPEC benchmarks, occasionally use setjmp() and longjmp(), in
which key program state (including the PC and frame pointer)
is stored to a memory buffer and later restored. The longjmp()
operation causes the machine to pop many stack frames with
no unwinding operations; as a result, all of the discarded
memory would remain tagged, which would later cause our
eager policies to encounter violations. To handle this function-
ality, we add additional code into the longjmp() routine that
includes a store instruction with a special LONGJMP–CLEAR
instruction tag; this tag allows it to overwrite the discarded
memory, which it tags with EMPTY STACK. These stores are
violations of the stack invariants as discussed in Sec. IV-C; we
are granting additional power to the longjmp() routine through
this special instruction-type. Similarly, C++ exceptions could
be handled by providing additional power to the exception
handling code with special
instruction tags. In the Depth
Isolation policy, the stack depth d is stored on the frame
492
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:32:21 UTC from IEEE Xplore.  Restrictions apply. 
(1)Store : (⊥, ST ORE–RA,⊥,⊥, OT HER) → (⊥, RA)
(2)Load : (⊥, READ–RA,⊥,⊥, RA) → (⊥,⊥)
(3)Store : (⊥, REM OV E–RA,⊥,⊥, RA) → (⊥, OT HER)
(4)Store : (⊥, IN ST R,⊥,⊥, OT HER) → (⊥, OT HER)
(5)Load : (⊥, IN ST R,⊥,⊥, OT HER) → (⊥,⊥)
(6)Other : (⊥, IN ST R,⊥,⊥,⊥) → (⊥,⊥)
(6)Store : (⊥, LON GJM P –CLR,⊥,⊥, ) → (⊥,⊥)
Fig. 10: Return Address Protection rules
pointer and retrieved appropriately by the standard policy
rules, so after longjmp() the system again has the correct depth
that was active at the time of the setjmp().
Tail call recursion: Tail call and sibling call elimination op-
timizations allow a program to reuse a caller’s stack frame for
its callee in the special case of tail calls. These optimizations
are activated with gcc’s -foptimize-sibling-calls optimization
pass which is included in the -O2 optimization level. Our
policies retag stack frames, as the authority identifer may have
changed. Additionally, arguments prepared for one authority
(in the argument for ﬁeld) may be stale for the new authority
identiﬁer after a sibling call. To handle this case, we insert
instructions with a special DELEGATE ARG tag that allows
an authority to permanently forgo its access rights and grant
them to the sibling authority before making a sibling call.
Dynamic stack allocations: Programs can perform dy-
namic memory allocations on the stack using alloca() or by
using dynamically sized arrays. We insert additional instruc-
tions to tag this memory at the time of the allocation, and
similarly insert additional instructions to clear the allocated
memory when the stack pointer is again incremented. Note
that these setup and cleanup operations are not in the function
prologue or epilogue, in contrast to the tagging operations
discussed in the policy descriptions. A current limitation of
our implementation is that we assign the same object-id to all
dynamically allocated stack objects. Dynamic stack memory
allocations are very rare in the SPEC benchmarks.
ﬁeld for this purpose. Then, before an indirect call takes place,
we use a special instruction tagged BEGIN–INDIRECT–CALL,
which, with an appropriate rule, takes the frame-id of the
register being used by the indirect call (e.g., jsr) and tags
the Program Counter tag with the frame-id of the dynamic
authority identiﬁer. Instructions that prepare arguments for
indirect calls are tagged with SET–ARG–FROM–PC and use
the authority identiﬁer held in the program counter tag to set
the appropriate argument for ﬁeld. Finally, the indirect call
instruction clears the tag on the PC when it executes.
This strategy requires having all function pointers tagged
with their appropriate frame-id. To achieve this, we tag entries
held in structures such as Global Offset Table (GOT) at
initialization with their appropriate frame-id so that when
these values are loaded the resulting registers get
tagged
correctly. Function pointers can also be crafted dynamically by
arithmetic instructions that compute at offset from the global
register. We tag these instructions with the instruction-type
CREATE–FP along with appropriate frame-id for the function
pointer that they are creating, so that with an appropriate rule
the resulting register will contain the correct frame-id.
frame-id-ptr, object-id-ptr,
In the rules we show in Fig. 11, we display tags on instruc-
tions as pairs of the form (instruction-type, frame-id), tags on
registers as triples of the form (frame-id, object-id, func ptr)
and tags on memory as 5-tuples of the form (frame-id, object-
func ptr). Tags on memory
id,
words require these ﬁeld so that when a stack pointer is stored
into stack memory, a future load can produce an appropriately
tagged pointer or function pointer identiﬁer (e.g., rule (5)). In
some cases we extend ﬁelds for particular instruction-types as
required by the policy.
D. Depth Isolation
In the rules we show in Fig. 12, we display tags on
instructions as singletons of the form (instruction-type), tags
on registers as doubles of the form (frame-id, object-id) and
tags on memory as 4-tuples of the form (frame-id, object-id,
frame-id-ptr, object-id-ptr).
B. Return Address Protection
Figure 10 shows the rule set for the Return Address Pro-
tection. In our rule notation we use ⊥ for the empty tag and
to indicate a don’t-care for a particular ﬁeld, which means
that the rule does not depend on a particular input and may
match any tag.
C. Static Authorities
In this section we explain how we tag arguments for indirect
function calls (as referenced in Sec. IV-D2), as well as provide
the full rules for the policy in SDMP notation.
To handle indirect function calls, we track all function
pointers in the system with their corresponding frame-id by
extending the tags on registers and memory words with another
493
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:32:21 UTC from IEEE Xplore.  Restrictions apply. 
,⊥), EM P T Y –ST ACK) → (⊥, (f, o,⊥,⊥,⊥))
, (f,⊥,⊥), (f, o, f 2, o2, p)) → (⊥, (f 2, o2, p))
, )) → (⊥, (f, o, f 2, o2, p))
,
,⊥) → (⊥, (f, o,⊥))
(1)Lda : (⊥, (M AKE–P T R, f, o),⊥,
(2)Store : (⊥, (SET –M EM, f, o),⊥, (f,
(3)Store : (⊥, (CLEAR–M EM, f,⊥),⊥, (f,⊥,⊥), ) → (⊥, EM P T Y –ST ACK)
(4)Store : (⊥, (ACCESS–LOCAL, f, o), (f 2, o2, p), (f,⊥,⊥), (f, o,
(5)Load : (⊥, (ACCESS–LOCAL, f, o),
(6)Arith prop : (⊥, (IN ST R, ),⊥,⊥,⊥) → (⊥,⊥)
(7)Arith prop : (⊥, (IN ST R, ),⊥, (f, o, p),⊥) → (⊥, (f, o, p))
(8)Arith prop : (⊥, (IN ST R, ), (f, o, p),⊥,⊥) → (⊥, (f, o, p))
(9)Arith prop : (⊥, (IN ST R, ), (f 1, o1, p1), (f 2, o2, p2),⊥) → (⊥,⊥)
(10)Arith no prop : (⊥, (IN ST R, ), (f 1, o1, p1), (f 2, o2, p2),⊥) → (⊥,⊥)
(11)Store : (⊥, (IN ST R, ),⊥,⊥,⊥) → (⊥,⊥)
(12)Load : (⊥, (IN ST R, ),⊥,⊥,⊥) → (⊥,⊥)
(13)Store : (⊥, (IN ST R, ), (f 2, o2, p), (f 1, o1,⊥), (f 1, o1,
(14)Load : (⊥, (IN ST R, ),
(15)Store : (⊥, (IN ST R, f ), (f 2, o2, p2),
(16)Load : (⊥, (IN ST R, f ),
(17)Store : (⊥, (SET –ARG, f 1, f 2), (f 3, o3, p), (f 1,⊥,⊥), (f 1,
(18)Arith : (⊥, (CREAT E–F P, f, p),⊥,
(19)Store : (⊥, (LON GJM P –CLEAR, ),⊥,
, ( ,
(20)Other : (⊥, (IN ST R,⊥,⊥),⊥,⊥,⊥) → (⊥,⊥)
(21)Arith prop : (⊥, (BEGIN–IN DIRECT –CALL, f ),⊥, (⊥,⊥, p),⊥) → (p,⊥)
(22)Store : (pc, (SET –ARG–F ROM–P C, f ), (f 2, o2, p), (f,
(23)Jsr : ( , ( , IN ST R,⊥,⊥),⊥,⊥,⊥) → (⊥,⊥)
, (f 1, o1,⊥), (f 1, o1, f 2, o2, p)) → (⊥, (f 2, o2, p))
,⊥) → (⊥, p)
,
,
,⊥), (f,
, ( , ARG,
,
,
,
,
,
,
, ( , ARG, f 2, o2, p, ARGF OR = f )) → (⊥, (f 2, o2, p)
,
, )) → (⊥, EM P T Y –ST ACK)
, )) → (pc, (f, ARG, f 2, o2, p, ARGF OR = pc))
, )) → (⊥, (f 1, o1, f 2, o2, p))
,
, ARGF OR = f )) → (⊥, (f, ARG, f 2, o2, p2, ARGF OR = f )
, )) → (⊥, (f 1, ARG, f 3, o3, ARGF OR = f 2))
Fig. 11: Static Authorities rules
494
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:32:21 UTC from IEEE Xplore.  Restrictions apply. 
, (d,⊥), (d, o, d2, o2)) → (⊥, (d2, o2))
(1)Lda : (⊥, IN CR–DEP T H,⊥, (d,⊥),⊥) → (⊥, (d + 1,⊥))
(2)Lda : (⊥, DECR–DEP T H,⊥, (d,⊥),⊥) → (⊥, (d − 1,⊥))
(3)Lda : (⊥, (M AKE–P T R, o),⊥, (d,⊥),⊥) → (⊥, (d, o))
(4)Store : (⊥, (SET –M EM, o),⊥, (d,⊥), EM P T Y –ST ACK) → (⊥, (d, o,⊥,⊥))
(5)Store : (⊥, CLEAR–M EM,⊥, (d,⊥), ) → (⊥, EM P T Y –ST ACK)
(6)Store : (⊥, (ACCESS–LOCAL, o), (d2, o2), (d,⊥), (d, o,
(7)Load : (⊥, (ACCESS–LOCAL, o),
(8)Arith prop : (⊥, IN ST R,⊥,⊥,⊥) → (⊥,⊥)
(9)Arith prop : (⊥, IN ST R,⊥, (d, o),⊥) → (⊥, (d, o))
(10)Arith prop : (⊥, IN ST R, (d, o),⊥,⊥) → (⊥, (d, o))
(11)Arith prop : (⊥, IN ST R, (d, o), (d, o),⊥) → (⊥,⊥)
(12)Arith no prop : (⊥, IN ST R, (d1, o1), (d2, o2),⊥) → (⊥,⊥)
(13)Store : (⊥, IN ST R,⊥,⊥,⊥) → (⊥,⊥)
(14)Load : (⊥, IN ST R,⊥,⊥,⊥) → (⊥,⊥)
(15)Store : (⊥, IN ST R, (d2, o2), (d1, o1,⊥), (d1, o1,
(16)Load : (⊥, IN ST R,
(17)Store : (⊥, IN ST R, (d2, o2), (d1, ), (d1, ARG,
,
(18)Store : (⊥, IN ST R, (d2, o2), (d1, ), (d1 + 1, ARG,
(19)Load : (⊥, IN ST R,
(20)Load : (⊥, IN ST R,
(21)Store : (⊥, LON GJM P –CLEAR,⊥,
(22)Other : (⊥, (IN ST R,⊥,⊥),⊥,⊥,⊥) → (⊥,⊥)
, (d1, ), (d1, ARG, d2, o2)) → (⊥, (d2, o2)
, (d1, ), (d1 + 1, ARG, d2, o2)) → (⊥, (d2, o2)
, (d1, o1), (d1, o1, d2, o2)) → (⊥, (d2, o2))
, ) → (⊥, EM P T Y –ST ACK)
, )) → (⊥, (d, o, d2, o2))
, )) → (⊥, (d1, o1, d2, o2))
,
, )) → (⊥, (d1, ARG, d2, o2)
,
, )) → (⊥, (d1 + 1, ARG, d2, o2)
Fig. 12: Depth Isolation rules
495
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:32:21 UTC from IEEE Xplore.  Restrictions apply.