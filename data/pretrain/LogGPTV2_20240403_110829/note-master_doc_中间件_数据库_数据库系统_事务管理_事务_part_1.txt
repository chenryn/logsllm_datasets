---
tags: ['数据库', '并发编程']
books: [
  {name: '数据密集型应用系统设计', chapters: ['第七章']},
  {name: '数据库系统概念', chapters: ['第十四章', '第十五章', '第十六章']}
]
links: [
  'http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE'
]
---
# 事务
> 构成单一逻辑工作单元的操作集合称为事务，可以通过commit提交一个事务，也可以使用rollback回滚
```mermaid
stateDiagram-v2
  一致性状态 --> 中间状态: insert,update,delete
  一致性状态 --> 一致性状态: rollback or error
  中间状态 --> 中间状态: insert,update,delete
  中间状态 --> 一致性状态
```
## ACID
- 原子性(Atomicity)：不可分割的最小操作单位，要么同时成功，要么同时失败
这点相较于并发编程的原子性有所不同：如果一个线程执行一个原子操作，这意味着另一个线程无法看到该操作的一半结果。与并发编程原子性较为相似概念的是ACID的隔离性
- 一致性(Consistency)：事务操作前后，数据总量不变
一致性的这种概念取决于应用程序对不变量的观念，应用程序负责正确定义它的事务，并保持一致性。如果你的应用程序非要写入脏数据，那么数据库也无能为力
- 隔离性(Isolation)：多个事务之间相互独立
隔离性最强的实现手段就是可序列化，但这种方式对性能极差。如Oracle中有一个名为“可序列化”的隔离级别，但实际上它实现了一种叫做快照隔离（snapshot isolation） 的功能，这是一种比可序列化更弱的保证。
- 持久性(Durability)：当事务提交或回滚后，数据会持久化的保存数据
完美的持久性是不存在的 ：如果所有硬盘和所有备份同时被销毁，那显然没有任何数据库能救得了你，最好抱着怀疑的态度接受任何理论上的“保证”。
只有满足一致性，事务执行结果才是正确的。事务串行执行，就能确保隔离性，此时只要满足原子性，就能满足一致性，在并发执行的情况下，要满足原子性和隔离性，才能满足一致性。
满足持久性的原因是为应对系统崩溃的情况，本质上满足持久性最终的目的也是为了满足一致性
AID是因 C是果
事务性质关系及作用：
```mermaid
stateDiagram-v2
  原子性 --> 一致性: 并发/无并发
  隔离性 --> 一致性: 并发
  一致性 --> 执行结果正确
  持久性 --> 应对系统崩溃
  应对系统崩溃 --> 一致性: 满足
```
为了应对系统崩溃，事务采取了事务日志，也就是追加的方式记录所有操作，这样在系统崩溃后也可以根据这些日志进行恢复。
### 实现原子性和持久性
原子性保证了事务的多个操作要么都生效要么都不生效，不会存在中间状态
但事实上磁盘写入总需要个过程，需要个额外的机制来保证出现下列情况后能进行恢复：
1. 未提交事务，写入后崩溃
2. 已提交事务，写入前崩溃
数据库通过修改数据前写入日志的情况来达到崩溃后能恢复的目的，称之为提交日志
同时为了实现事务功能 通过undo log来记录数据的修改的情况，以便随时回滚
为了精确定义事务成功的含义，需要建立抽象事务模型：
- 活动的
- 部分提交的
- 失败的
- 终止的
- 提交的
```mermaid
stateDiagram-v2
  [*] --> 活动状态
  活动状态 --> 局部提交状态
  活动状态 --> 活动状态: 读/写
  活动状态 --> 失败状态
  局部提交状态 --> 失败状态
  失败状态 --> 异常终止
  局部提交状态 --> 提交状态
```
对于异常终止的事务，数据库系统可以选择重启或者杀死事务，只有是硬件错误或者不是由事务本身导致的错误重启事务才有意义
### 实现隔离性
事务串行执行就不会有隔离性问题，但跟操作系统需要多道程序执行一样，数据库让事务并行可以有效提升吞吐量与降低延迟
为了判断一系列事务是否可串行化，需要对调度构造依赖图，进行是否有环检测
可恢复调度：对于事务 T1 与 T2，如果 T2 读取了 T1 修改的数据项，则 T1 要先于 T2 提交
无级联调度：对于事务 T1，T2，T3，如果 T2 依赖 T1 的修改，T3 依赖 T2 的修改，那么 T1 的回滚不能影响到 T2，T3，也就是 T3 首先提交，然后是 T2，然后是 T1
## 并发一致性问题
并发环境下，事务的隔离性很难保证
解决并发一致性问题的方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现
### 丢失修改
两个事务修改同一个数据，后修改的事务覆盖之前事务的修改
```mermaid
stateDiagram-v2
  op1: write A=10
  op2: write A=20
  res1: A=20(错误)
  res2: A=20
  T1 --> op1
  op1 --> T1等待
  T1等待 --> res1
  T2 --> T2等待
  T2等待 --> op2
  op2 --> res2
```
丢失修改有几种解决方案：
- 原子写：通常通过在读取对象时，获取其上的排它锁来实现。以便更新完成之前没有其他事务可以读取它
- 显式锁定：通过加锁只允许一个事务
- 原子操作和锁是通过强制读取-修改-写入序列按顺序发生,另一种方法是允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其读取-修改-写入序列
- CAS操作
### 脏读
一个事务修改了数据，随后回滚了，但是这个数据在回滚之前被另外一个事务读到了
```mermaid
stateDiagram-v2
  op1: read A=10
  op2: write A=20
  op3: read A=20
  T1 --> op1
  op1 --> op2
  op2 --> 回滚
  回滚 --> A=10
  T2 --> T2等待0
  T2等待0 --> T2等待1
  T2等待1 --> op3
  op3 --> A=20
```
### 脏写
一个事务修改了数据 另外一个事务也修改了同一份数据 随后前一个事务回滚 这样后一个事务的修改就丢失了
### 不可重复读
一个事务读取数据后，这个数据被另外的事务修改了，先前的事务再读一次，发现两次读取的数据不一致
```mermaid
stateDiagram-v2
  op1: read A=10
  op2: write A=20
  op3: read A=20
  T1 --> T1等待0
  T1等待0 --> op2
  op2 --> T1等待1
  T1等待1 --> A=20
  T2 --> op1
  op1 --> T2等待0
  T2等待0 --> op3
  op3 --> A=20(错误)
```
### 幻读
一个事务读取某个范围的数据，另外一个事务在这个范围上修改了数据，从而导致先前的事务两次读取数据不一致
```mermaid
stateDiagram-v2
  op1: size=COUNT(customer) size=N
  op2: INSERT customer
  op3: size=COUNT(customer) size=N+1(错误)
  T1 --> op1
  op1 --> T1等待0
  T1等待0 --> op3
  op3 --> [*]
  T2 --> T2等待0
  T2等待0 --> op2
  op2 --> T2等待1
  T2等待1 --> [*]
```
### 不可重复读与幻读