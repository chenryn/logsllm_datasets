alistically later in Section 5. We assume for now that: (a) all mem-
bers know when to initiate a protocol run and how to distinguish
one run from another; (b) all members of a group participate in ev-
ery protocol run; (c) all members have public encryption keys and
nonrepudiable signing keys known to all other members; and (d)
all members remain connected throughout a protocol run and never
stop sending correctly-signed messages until the protocol run has
completed from the perspective of all group members. Assumption
(d) implies that we address only safety properties for now, defer-
ring liveness issues to Section 5—including the important corner
case of a node withholding the last message it is supposed to send,
while collecting all other members’ ﬁnal messages, thereby learn-
ing a protocol run’s results while denying others those results.
3. SHUFFLE PROTOCOL
This section details the shufﬂe protocol, ﬁrst covering its cryp-
tographic building blocks, then formally describing the protocol,
proving its correctness, and analyzing its complexity.
3.1 Cryptographic Primitives
Dissent relies on a conventional, possibly randomized signature
scheme, which consists of: (a) a key generation algorithm produc-
ing a private/public key pair (u, v); (b) a signing algorithm taking
private key u and message m to produce signature σ = SIGu{m};
and (c) a deterministic veriﬁcation algorithm taking public key v,
message m, and candidate signature σ, and returning true iff σ is
a correct signature of m using v’s associated private key u. The
notation {m}SIGu indicates the concatenation of message m with
the signature SIGu{m}.
We also require a public-key cryptosystem, which must be IND-
CCA2 secure [2]. The cryptosystem must also provide access to
the random bits it uses in key generation and encryption; Dissent’s
accountability mechanisms use this capability for commitment and
veriﬁcation of behavior, as described below. A software implemen-
tation of RSA-OAEP [19] using a pseudorandom number generator
meets these requirements, for example. The cryptosystem specif-
ically consists of: (a) a key generation algorithm producing a pri-
vate/public key pair (x, y); (b) an encryption algorithm taking pub-
Figure 1: Shufﬂed send communication model
The protocol still requires each member to send a similar number
of bits on the underlying network for trafﬁc analysis protection,
but none of these bits are wasted for purposes of padding mes-
sages of unbalanced lengths. Members wishing receiver anonymity
can ﬁrst anonymously send a public encryption key to establish a
pseudonym, then look for messages encrypted with that key in sub-
sequent shufﬂed sends targeted at the whole group.
Since each member submits exactly one message per shufﬂed
send, one run’s messages can serve as ballots in an anonymous vote.
Unlike anonymous voting protocols designed for speciﬁc types of
ballots and tallying methods, Dissent supports ballots of arbitrary
type, format, and size. Group members can count and indepen-
dently verify the ballots in any agreed-upon fashion. Ballots need
not be one-shot messages either. A group can use one protocol run
to establish a set of pseudonymous signing keys, one per mem-
ber, then use these pseudonyms in subsequent protocol runs for
pseudonymous deliberation, without permitting members to create
unlimited pseudonyms for Sybil attacks [17] or sock puppetry [36].
Applications to which shufﬂed send may be suited include whistle-
blowing [42], surveys [7], ﬁle sharing [32], accountable Wiki-style
editing [36], and “cocaine auctions” [33]. The current version of
Dissent has some notable limitations: e.g., it may not scale to large
groups, it provides only a limited form of coercion resistance (de-
scribed in Section 5.3), and the latency incurred by its shufﬂe pro-
tocol may make it unsuitable for interactive or real-time messaging.
Future work may be able to address these limitations.
2.3 Security Goals
We now deﬁne Dissent’s attack model and security goals. We
assume the attacker is polynomial-time limited, but can monitor all
network trafﬁc and compromise any subset of group members. A
member is honest if she follows the protocol exactly and is not un-
der the attacker’s control, and is faulty otherwise. Faulty nodes are
byzantine: they may collude and send arbitrary messages. For sim-
plicity, our core protocol descriptions in Sections 3 and 4 assume
342Figure 2: Illustration of bulk protocol operation for 3-member group, shufﬂed using permutation π = [2, 3, 1].
lic key y, plaintext m, and some random bits R, and producing a ci-
phertext C = {m}R
y ; (c) a deterministic decryption algorithm tak-
ing private key x and ciphertext C, and returning the plaintext m. A
node can save the random bits R it uses during encryption, and can
encrypt deterministically using a given R, such that given inputs y,
m, and R always yield the same ciphertext. We assume that hon-
est nodes can check an arbitrary (x, y) purported to be a key pair,
to verify that this (x, y) is indeed a key pair generated according
to the speciﬁed key generation algorithm. The appendix describes
how any public-key cryptosystem can be adapted, if necessary, to
satisfy this assumption. The notation C = {m}R1:RN
y1:yN indicates
y1 . . . }RN
iterated encryption via multiple keys: C = {. . . {m}R1
yN .
We omit R when an encryption’s random inputs need not be saved.
We use a standard deﬁnition [35] of a collision-resistant unkeyed
hash function and will denote the hash of message m as HASH{m}.
We use a standard deﬁnition [35] of a pseudorandom number
generator (PRNG). We will denote the ﬁrst L bits generated from
a PRNG seeded with s as PRNG{L, s}.
3.2 Protocol Description
Each group member i (for i = 1, . . . , N ) initially has a primary
encryption key pair (xi, yi), a signing key pair (ui, vi), and a secret
message mi of ﬁxed length L to send anonymously.
Before a protocol run, all members agree on a session nonce
nR uniquely identifying this protocol run, the participants’ pri-
mary public encryption and signing keys, and a common ordering
of all members 1, . . . , N . Such agreement might be achieved via
Paxos [25] or BFT [8], as discussed further in Section 5.
The shufﬂe protocol operates in phases. Each honest member
i sends at most one unique message µiφ per phase φ. A member
i may send the same µiφ to all members, in which case we say i
broadcasts µiφ. An implementation of Dissent may use an under-
lying broadcast transmission primitive for this purpose, if available,
or may simply send the same message N times, once to each group
member. A faulty node might equivocate during a broadcast by
sending different messages to different members.
Each group member maintains a tamper-evident log of all mes-
sages it sends and receives in a protocol run [23]. Member i signs
each µiφ it sends with its private key ui, and includes in each mes-
sage the session nonce nR and a hash hiφ of i’s current log head in
phase φ. Each hiφ depends on all messages i received up to phase
φ, before sending µiφ. Members ignore any messages they receive
containing a bad signature or session nonce.
• Phase 1: Secondary Key Pair Generation. Each member i chooses
an encryption key pair (wi, zi), and broadcasts:
µi1 = {zi, nR, hi1}SIGui
• Phase 2: Data submission. Each member i encrypts her datum
mi with all members’ secondary public keys:
C ′
i = {mi}zN :z1
Member i stores C ′
i with
all members’ primary public keys, this time internally saving the
random bits used in each encryption:
i for later use, then further encrypts C ′
Ci = {C ′
i}RiN :Ri1
yN :y1
If encryption fails at any point, the group moves directly to phase
5b below (“blame”). Member i now sends to member 1:
µi2 = {Ci, nR, hi2}SIGui
• Phase 3: Anonymization. Member 1 collects all ciphertexts into
a vector ~C0 = C1, . . . , CN , randomly permutes its elements,
then strips one layer of encryption from each ciphertext using
private key x1 to form ~C1. Member 1 sends to member 2:
µ13 = { ~C1, nR, h13}SIGu1
Each member 1 < i < N in turn accepts ~Ci−1, permutes it
randomly, strips one encryption layer to form ~Ci, then sends ~Ci
to member i + 1. Member N ﬁnally permutes and decrypts
~CN −1 to form ~CN , and broadcasts to all members:
µN 3 = { ~CN , nR, hN 3}SIGuN
If any member i detects a duplicate or invalid ciphertext during
this phase, member i reports it and the group moves directly to
phase 5b below (“blame”).
• Phase 4: Veriﬁcation. All members now hold ~CN , which should
N . Each member i veriﬁes that
be a permutation of C ′
1, . . . , C ′
343i is included in the ~CN she received, and sets a ﬂag
her own C ′
GOi to TRUE if so and FALSE otherwise.
Each member i creates a vector ~B of all broadcast messages it
sent or received in prior phases: all members’ public key mes-
sages from phase 1, and member N ’s phase 3 message contain-
ing ~CN . Thus, ~B = µ11, . . . , µN 1, µN 3. Member i broadcasts:
µi4 = {GOi, HASH{ ~B}, nR, hi4}SIGui
Each member i then waits to receive such a “go/no-go” message
from every other member. If every member j reports GOj =
TRUE for the expected HASH{ ~B}, then member i enters phase
5a below; otherwise i enters phase 5b (“blame”).
• Phase 5a: Decryption. Each member i destroys her copy of C ′
i
and the random bits she saved in phase 2, then broadcasts her
secondary private key wi to all members:
3.3.2 Anonymity
The protocol preserves anonymity if no group of k ≤ N − 2
colluding members can win an anonymity game, determining with
non-negligible probability which of two honest members submitted
which of two plaintexts, as detailed in prior work [7]. The attacker
might gain advantage either by manipulating protocol messages, or
by using only the information revealed by a correct protocol run. In
the ﬁrst case, the attacker can identify the intermediate ciphertext
C ′
i of some honest member i by duplicating or eliminating other
honest members’ ciphertexts in phase 3, but any honest member
will detect duplication in stage 3 and elimination in stage 4, abort-
ing the protocol before the attacker can decrypt C ′
In the sec-
i.
ond case, an attacker who can win the anonymity game with non-
negligible probability, using only information revealed by correct
protocol runs, can use this ability to win the distinguishing game
that deﬁnes an IND-CCA2 secure cryptosystem [2, 7].
µi5 = {wi, nR, hi5}SIGui
3.3.3 Accountability
Upon receiving all keys w1, . . . , wN , member i checks that each
wj is the private key corresponding to public key zj , and if not,
exposes j using the signed messages from j containing these
invalid keys. Otherwise, i removes the remaining N levels of
encryption from ~CN , resulting in a permutation of the submitted
data m1, . . . , mN , and the protocol completes successfully.
• Phase 5b: Blame. Each member destroys her secondary pri-
vate key wi, then reveals to all members the random bits Rij
she saved from the primary public key encryptions in phase 2,
and all signed messages she received and sent in phases 1–4.
Each member i uses this information to check the behavior of
each member j in phases 1–4, replaying j’s primary key encryp-
tions in phase 2, and verifying that j’s anonymized output ~Cj
in phase 3 was a decrypted permutation of ~Cj−1. Member i ex-
poses member j as faulty if j signed an invalid zj in phase 1, an
incorrectly encrypted Cj in phase 2, an improperly decrypted or
permuted ~Cj in phase 3, a GOj = FALSE or a wrong HASH{ ~B}
in phase 4 after phases 1–3 succeeded, or if j equivocated by
signing more than one message or log head hjφ in any phase φ.
3.3 Protocol Correctness
The shufﬂe protocol’s integrity and anonymity derive almost di-
rectly from Brickell/Shmatikov [7], so we only sketch proofs of
these properties, focusing instead on the accountability property
introduced by our enhancements.
3.3.1
Integrity
To preserve integrity, after a protocol run every honest mem-
ber must either: (a) hold the datum mi of every honest member
i, or (b) know that the protocol did not complete successfully. Sup-
pose that a protocol run appears to complete successfully via phase
5a (decryption), but that some honest member i does not hold the
plaintext mj of some other honest member j. Since j is honest,
j’s intermediate ciphertext C ′
j must be a correct encryption of mj ,
j must have appeared in ~CN . Otherwise, j would have sent
and C ′
GOj = FALSE in phase 4. Since honest member i would not en-
ter phase 5a without receiving GOj = TRUE for the same ~B from
all members, and ~B includes message µN 3 containing ~CN , i must
hold C ′
j. If all members released correct secondary private keys
w1, . . . , wN during phase 5a, C ′
j must then decrypt to mj . If some
member k released a secondary private key wk such that (wk, zk)
is an invalid key pair, all honest members expose member k.
A member i exposes another member j if i obtains proof of j’s
misbehavior veriﬁable by a third party. To maintain accountability,
no member may expose an honest member, and at the end of a
protocol run, either: (a) the protocol completes successfully, or (b)
all honest members expose at least one faulty member.
We ﬁrst show that no member i can expose an honest member
j. A proof of misbehavior by j consists of some “incriminating”
message µjφ signed by j in phase φ, together with all of the mes-
sages in j’s log up through phase φ, and the random bits each node
saved during phase 2 and released in phase 5b. Member i could
“truthfully” expose j only if j signs an incorrect message in phases
1–5a, or signs more than one message per phase, contradicting the
assumption that j is honest. Member i could also falsely accuse j