title:Automatic Hot Patch Generation for Android Kernels
author:Zhengzi Xu and
Yulong Zhang and
Longri Zheng and
Liangzhao Xia and
Chenfu Bao and
Zhi Wang and
Yang Liu
Automatic Hot Patch Generation for Android Kernels
Zhengzi Xu, Nanyang Technological University; Yulong Zhang, Longri Zheng, 
Liangzhao Xia, and Chenfu Bao, Baidu X-Lab; Zhi Wang, Florida State University; 
Yang Liu, Nanyang Technological University
https://www.usenix.org/conference/usenixsecurity20/presentation/xu
This paper is included in the Proceedings of the 29th USENIX Security Symposium.August 12–14, 2020978-1-939133-17-5Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.Automatic Hot Patch Generation for Android Kernels
Zhengzi Xu
Nanyang Technological University
Yulong Zhang
Baidu X-Lab
Longri Zheng
Baidu X-Lab
Liangzhao Xia
Baidu X-Lab
Chenfu Bao
Baidu X-Lab
Zhi Wang
Florida State University
Yang Liu
Nanyang Technological University
Abstract
The rapid growth of the Android ecosystem has led to the
fragmentation problem where a wide range of (customized)
versions of Android OS exist in the market. This poses a se-
vere security issue as it is very costly for Android vendors
to ﬁx vulnerabilities in their customized Android kernels in
time. The recent development of the hot patching technique
provides an ideal solution to solve this problem since it can
be applied to a wide range of Android kernels without in-
terrupting their normal functionalities. However, the current
hot patches are written by human experts, which can be time-
consuming and error-prone.
To this end, we ﬁrst study the feasibility of automatic patch
generation from 373 Android kernel CVEs ranging from 2012
to 2016. Then, we develop an automatic hot patch generation
tool, named Vulmet, which produces semantic preserving hot
patches by learning from the oﬃcial patches. The key idea
of Vulmet is to use the weakest precondition reasoning to
transform the changes made by the oﬃcial patches into the hot
patch constraints. The experiments have shown that Vulmet
can generate correct hot patches for 55 real-world Android
kernel CVEs. The hot patches do not aﬀect the robustness of
the kernels and have low performance overhead.
1 Introduction
Android platform has become the biggest mobile platform in
the modern mobile device industry. The rapid growth of the
Android ecosystem makes our lives convenient by bringing us
thousands of new devices with various (customized) Android
operating systems. However, most of these devices cannot
receive timely updates. Table 1 gives the Android version
distribution from 500 million devices as of October 20181.
The table shows that the recent release of Android Pie (9.0) in
August 2018 reaches only very few devices after two months.
However, from the August 2018’s monthly release, the An-
droid Security Bulletin [1] stopped to carry security patches
1With user consent, we collected Android versions and patch levels from
devices with the Baidu app installed.
Table 1: Android version distribution (OCT 2018)
Android Major Version Release Date
Android 4.x
Android 5.x
Android 6.x
Android 7.x
Android 8.x
Android 9.x
Others
Oct 2011
Nov 2014
Oct 2015
Aug 2016
Aug 2017
Aug 2018
-
Percentage
6.65%
18.11%
19.96%
25.47%
29.60%
0.04%
0.17%
for Android 6.x and below. As a result, based on the statistics
in Table 1, 44.72% of Android devices will not receive any
security patches unless vendors can upgrade the ﬁrmware
themselves. Fig. 1 provides further detailed analysis of the
Android patch level of the same 500 million devices. Only
20% of the devices can catch up with the 3-month-old security
patch updates; only 60% of the devices can catch up with the
6-month-old security patch updates; and 20% of the devices
only have security updates more than a year ago.
The low upgrade rate has resulted in legacy Android sys-
tems with unpatched vulnerabilities. However, Android ven-
dors are not motivated to ﬁx those vulnerabilities. It is costly
to apply changes to kernels, as it requires to go through te-
dious testing process to ensure that the changes do not break
existing functionalities [18]. Therefore, the legacy systems
will remain vulnerable for a very long period. Attackers can
leverage the known vulnerabilities to attack easily.
To address this known vulnerability threat, tremendous ef-
forts have been made to patch old Android systems. Among
all the possible solutions, the hot patch technique provides
a convenient way to ﬁx the vulnerabilities without interrupt-
ing the normal functionalities of the program [47]. It greatly
improves the user experience since it can ensure the system
security without rebooting the devices. Based on the hot patch
idea, Chen et al. have proposed an adaptive Android kernel
live patching framework [14]. The framework hooks the vul-
nerable function and applies a pre-constructed hot patch to it.
USENIX Association
29th USENIX Security Symposium    2397
Overall, this paper has made the following contribution:
1. We formally deﬁne the process of automatic hot patch
generation via learning from the semantics of the oﬃcial
patches. We elicit three requirements of the process and deﬁne
its operation scopes.
2. We conduct an empirical study by collecting, summa-
rizing, and categorizing diﬀerent real-world Android kernel
vulnerability patches based on their behaviors and distill four
insights.
3. We propose an approach to automatically generate hot
patches, and implement a tool, named Vulmet, to simulate the
hot patch generating process and test its performance using
the vulnerabilities in the real-world legacy Android system.
The experiments show that the generated hot patch can ﬁx the
vulnerabilities with low overheads.
The rest of the paper is organized as follows. In Section 2,
we deﬁne the automatic hot patch generation problem with
a real-world example. Next, in Section 3, we conduct a sur-
vey of Android vulnerability type and deﬁne the scope of the
patch which can be used to generate the hot patch. Then, Sec-
tion 4 presents the automatic hot patch generation framework.
Section 5 evaluates of diﬀerent aspects of Vulmet with dif-
ferent experiments. Section 6 lists the related works in patch
generation. At last, Section 7 concludes the paper.
2 Automatic Hot Patch Generation
In this section, we deﬁne of the automatic hot patch generation
problem, state requirements and assumptions, and illustrate it
with an example.
2.1 Problem Deﬁnition
We deﬁne the automatic hot patch generation as follow:
Given a vulnerable function F and its oﬃcial patch P at
location L, we would like to ﬁnd a suitable location L(cid:48) of F
in binary form to insert an automatically generated hot patch
P(cid:48), which has the same semantics as P.
In this work, to achieve the goal of hot patch generation, we
have conducted a vulnerability and patch survey to collect the
vulnerable functions F with the oﬃcial patches P. Then, we
develop Vulmet to automatically set up the metrics to measure
whether a location is suitable to insert the hot patch and select
the most suitable one as L(cid:48). After that, Vulmet leverages
the weakest precondition to transform the constraints of the
original semantics into new constraints to form the hot patch
P(cid:48) at L(cid:48).
2.2 Requirements
To ensure the generated hot patches are practical, we have set
the requirements to measure whether it is suitable to patch
Android kernels.
Figure 1: Android patch level distribution as of Oct 2018
The hot patch will block the malicious input to the function
to ensure the security. Mulliner et al. [38] have built a frame-
work, named PatchDroid, which can insert the hot patches
into the binary for third-party unsupported Android kernels.
It checks constraints during patching the vulnerabilities to
ensure the stability of the system. These works try to build
the framework to insert the hot patch into the legacy system.
However, the hot patches are still needed to be provided to
the system. The framework cannot generate the patches auto-
matically.
Writing hot patches based on the oﬃcially released patches
is challenging. At source code level, programmers can modify
any parts of the vulnerable functions to ﬁx the bug, while in
binary, it is diﬃcult to ﬁnd exactly the locations to place the
same modiﬁcations. To get a hot patch in the suitable place, se-
curity experts are required to understand the semantics of the
oﬃcial patch and write a corresponding hot patch. However,
this is a time-consuming process and error-prone. It is not
acceptable for the IT industry with the fast development cycle
and limited security budgets. Therefore, there is a need to
develop an automatic solution to correctly convert an oﬃcial
patch into a hot patch.
To this end, this paper proposes a solution to automate the
hot patch generation process. We propose a proper deﬁnition
of the problem and set the requirements and assumptions that
involved. To have a complete understanding on the vulner-
ability patches, we ﬁrst analyze most of the Android CVEs
from the year 2012 to 2016 and categorize them based on
their patching behaviors. With the insight from the analysis,
we develop Vulmet, which can automatically generate hot
patches by extracting the semantics of the oﬃcial patches
using program analysis. Vulmet will ﬁnd a suitable place in
the function, build and apply a semantic equivalent hot patch
to ﬁx the vulnerability. To test the eﬀectiveness of Vulmet,
we have generated the hot patches for real-world Android
CVEs. The hot patches can prevent the exploits with only
little overhead on the system.
2398    29th USENIX Security Symposium
USENIX Association
0%2%4%6%8%10%12%14%16%0%10%20%30%40%50%60%70%80%90%100%Patch Level10/1/151/1/164/1/166/1/168/1/169/5/1610/5/1611/7/161/1/172/5/174/1/175/5/177/1/178/5/1710/1/1711/1/1712/1/171/5/182/18/184/1/185/1/186/5/187/13/189/1/1810/5/18Number of devices with patch levels newer than this dateNumber of devices on this patch levelFigure 2: Example of the special case for Rule 1
Requirement 1: the generated hot patch should preserve the
semantics as the corresponding oﬃcial patches, which guar-
antees its correctness.
Requirement 2: the generated hot patch should not break the
system, which ensures its robustness.
Requirement 3: the generated hot patch should incur low
overhead, which ensures its eﬃciency.
2.3 Operation Scopes
To ensure the robustness of the patched program, we have
deﬁned three rules to limit the operations used in the hot
patches.
Operation Rule 1. The patch can only be placed at the be-
ginning or end of the functions or at the beginning or end of
function calls.
In binary executables, the function level information is lim-
ited. For a given source code statement, it is diﬃcult to locate
a particular line of binary instruction. In addition, the instruc-
tion location changes in diﬀerent versions of the functions.
However, no matter what changes have been made inside a
function, its boundary remains the same. With the help of
IDA PRO [10], the function beginning and end place can be
pinpointed. These places are stable even if the contents of the
function have been slightly changed. Therefore, to ensure the
hot patch is practical in Android kernels, we only allow the
patch to be placed at the beginning or end of a function or the
call of the function.
Operation Rule 1 has one special situation, which has
been shown in Fig. 2. In the case where function A calls
function B, the hot patch can be applied to the beginning or
end of function A (Hook Point I and IV) and the call to func-
tion B (Hook Point II and III). By hooking at the beginning
or end of the call to function B (Hook Point II and III), we
can achieve the equivalent semantics as if we are hooking
in the middle of function A. Therefore, the hot patch still
obey Operation Rule 1, but looks like to have the ability
to hook in the middle of the function.
Operation Rule 2. The patch can read the valid content of the
memory but it is prohibited from modifying the contents.
Figure 3: Oﬃcial Patch for CVE-2015-8940
Modifying the memory contents directly may be dangerous.
A careless writing operation may change the program control
follow and tamper the important data, which will result in
unexpected behaviors of the program. Therefore, to enforce
the security, we restrict the patch operation to be only reading
the content without writing to the memory.
Operation Rule 3. The patch can only ﬁx vulnerability with
small changes and within one function.
Patches are usually small to address a speciﬁc security
problem. If the patch modiﬁes most parts of the function, it
is equivalent to implement a new function. Hot patch has the
limitation to ﬁx this kind of bugs without introducing other
problems [47]. Moreover, a large cross-function patch is rare
and may involve the redesigning of the program logic, which
is not suitable for hot patching. Therefore, we limit the hot
patch to ﬁx vulnerability within one function. However, if a
large oﬃcial patch can be divided into small patches within
one function, the small patches can be converted into hot
patches separately.
2.4 Real-world Example
In this section, a real-world example is given to demonstrate
the concept of converting the oﬃcial patch into the hot patch.
Fig. 3 has shown the oﬃcial source code patch for
CVE-2015-8940 [6] in Android Qualcomm msm kernel 3.10.
This patch ﬁxes the integer overﬂow bug in function q6lsm-
_snd_model_buf_allo() by adding a sanity check at line
15 to 17.
To convert it into a hot patch, we ﬁrst follow Operation
Rule 1 to hook the beginning of the function q6lsm-
_snd_model_buf_allo() at line 1. Then we need to ﬁnd a
semantic equivalent patch as the oﬃcial patch at this point.
The oﬃcial patch contains one sanity check of variable len,
SIZE_MAX, pad_zero, and cal_block->cal_data.size.
Not all of these variables’ values are known at the begin-
USENIX Association
29th USENIX Security Symposium    2399
1intq6lsm_snd_model_buf_alloc(structlsm_client*client,2size_tlen){3structcal_block_data*cal_block=NULL;4size_tpad_zero=0,total_mem=0;5...6cal_block=7cal_utils_get_only_cal_block(lsm_common.cal_data);8if(cal_block==NULL)9gotofail;10...11if(!client->sound_model.data){12client->sound_model.size=len;13pad_zero=(LSM_ALIGN_BOUNDARY-14(len%LSM_ALIGN_BOUNDARY));15+if((len>SIZE_MAX-pad_zero)||16+(len+pad_zero>17+SIZE_MAX-cal_block->cal_data.size)){18...19gotofail;}20...}21...}Table 2: Variable Relationships
Table 3: Patch Type Categorization
Patch Variable
len
SIZE_MAX
pad_zero
cal_block-
>cal_data.size
Equivalent Value
len (same as function input)
constant
constant - (len % constant)
cal_utils_get_only_cal_block()
ning of the function. To build an semantic equivalent patch,
we need to use variables whose values are known to represent
the same sanity check. Since we are hooking at the beginning
of the function, we can get the value of the function input
parameters, client and len. Then we need to use weakest
precondition reasoning, a program analysis technique, to ﬁnd
out the relationships between the input parameters and the
sanity check variables.
Table 2 shows the relationships between the variables. The
detailed algorithm to determine the relationships automati-