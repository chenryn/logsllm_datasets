the database. Metaphorically speaking, dynamic auditing is
similar to memorization, where results from previous compu-
tations are cached and reused when needed. The drawback
of dynamic auditing, however, is that the obtained exploits
are feasible only for a particular database instance.
For applications with databases that are initially popu-
lated from the code (e.g., a series of insert queries) rather
than from external data entry procedures, static input gener-
ation has visibility into the tuples that are inserted and can
generate the corresponding constraints. Therefore, for these
applications, the results obtained from dynamic auditing are
equivalent to those from static input generation with the
advantage of smaller overhead.
4.
IMPLEMENTATION
Our implementation is written on top of Pixy [18] and
TAPS [6] for source code analysis and Z3 [10] for constraint
solving. The input to Chainsaw is a web application source,
its database schema and the attack speciﬁcations. The output
is a set of HTTP requests that will exploit vulnerable sinks.
4.1 Context Awareness
Symbolic Parsers. Chainsaw symbolically evaluates each
path from a source to a sensitive sink (SQL or XSS) and
generates a symbolic expression by representing the sink
parameters as symbolic values. When it encounters loops,
Chainsaw symbolically executes them 0, 1 or 2 times.
To be able to derive the context of the user input in
these symbolic expressions, we implement two additional
(symbolic) parsers on top of the SQL and HTML parsers.
Our two parsers are able to create the abstract syntax trees
of the symbolic expressions and use those trees to derive the
context of the user input. For instance, the analysis identiﬁes
the context of the variables used in the sink by determining
whether each variable is single-, double-, or unquoted. As
another example, if the symbolic sink is a select query and
the user input is used in the WHERE clause, the parser is able
                 dashboard.php addcat.php redirect room.php redirect form L1 L2  D2 redirect A2 A1 A3  D1 Node Preconditions Summary   L2 1.isset($_GET[‘mode’])(cid:154) 2.isset($_SESSION[‘username’] (cid:154) 3.isset($_POST[‘room_name’]) (cid:154) 4.isset($_POST[‘category’]) (cid:154) 5.isset($mode) (cid:154) $mode==”enter”   $_SESSION[‘room_name’]    A3 1.isset($_SESSION [‘username’] (cid:154) 2.isset($_SESSION [‘room_name’]) (cid:154) 3.isset($_GET[‘mode’]) (cid:154) 4.isset($_GET[‘cat_desc’]) (cid:154) 5.isset($mode) (cid:154) $mode==”addcat” (cid:135)    D2 1.isset($_SESSION [‘username’] (cid:154) 2.isset($_SESSION [‘room_name’]) (cid:154) 3.isset($_GET[‘cat_desc’]) (cid:154) 4.$accesslevel==1 (cid:135)     646to derive the parsing context of user input. Subsequently, this
context is used to guide the expansion of the formula FA with,
say, a constraints expressing a tautology SQLI. In addition,
it is worth pointing out that, since Chainsaw automatically
includes the semantics of the sanitization functions when
creating the symbolic formula, it is sanitization-aware.
Context-awareness example. To see the relevance of the
context-awareness, let us consider Listing 5 for an XSS attack
scenario.
1 echo " here is the user input $input’’;
2 echo "This is a paragraph.’’;
Listing 5: Examples on context awareness in XSS.
For line 1 in Listing 5, the context of the variable $input
is: unquoted, paragraph, and any attack string such as
"" will trigger the attack. In
line 2, however, the user input $color is the value of an at-
tribute. Therefore, in the attack string, the quote and tag en-
closing character (>) must ﬁrst be closed and then followed by
the XSS payload (e.g.,"’>
"). The symbolic parsers used in Chainsaw are able to
infer these diﬀerent contexts and guide the construction of
the ﬁnal formula that is sent to the solver.
4.2 Analysis of Navigation Structure
General workﬂow graph construction. To construct
the GWFG of an application, our approach uses an HTML
parser as well as the generated CFG for each module to
extract workﬂow inference features: HTTP links, forms,
meta tags, iframes and PHP redirection functions. After
the extraction, Chainsaw creates two nodes that represent
the source and destination modules of the workﬂow feature.
Since our analysis is inter-procedural, and context-sensitive
data and control ﬂow analysis, variables in workﬂow function
arguments can be resolved by consulting the data depen-
dence graph generated for each workﬂow function. While
the GWFG is constructed from HTML and PHP features,
our extraction technique can be applied to languages with
similar functions.
Informed traversal of the GWFG. The main challenge
in traversing the RWFG is to intelligently decide which
path to take.
In our implementation, we use the notion
of summary history, which is a mechanism to ‘remember’
the traversal history and to use it as a guide to search for
the next compatible node (execution path). In particular,
for each edge traversal from a node vi to a node vj, the
summary of vi is added to the summary history (initially
empty). Intuitively, the summary history of a path on the
RFWG is the collection of all the summaries of the nodes of
that path.
A concrete example where we use such summaries is based
on Figure 3. The vulnerable query is in two execution paths
D1 and D2. If the search starts at L2, then there are two
possible nodes to traverse next: A2 and A3. Our search
technique, chooses A3 over A2 because the summary history
at L2 satisﬁes the preconditions of A3. Next, the search
adds the summary of L2 and A3 to the summary history to
further guide the search of the next node. After reaching A3,
the search checks all A3 ’s outgoing edges (D1 and D2 ) and
repeats the same heuristics until it reaches the vulnerable
sink in D2.
This search technique signiﬁcantly reduces the number
of edges in the RWFG by keeping only the feasible path
transitions. In turn, this improves the eﬃciency of the gen-
eration of working exploits for deeply located exploit seeds
in a global execution path.
4.3 Database Schema Analysis
In static analysis, modeling data ﬂows that cross persistent
storage is not trivial due to the absence of database con-
straints in the source code. To this end, Chainsaw analyzes
the database schema to capture the additional constraints
imposed by the database. Speciﬁcally, tables names and
columns deﬁnitions such as their names, types and values
constraints (e.g., NOT NULL and length) are retrieved.
As an example, Listing 6 shows an insert query, which
seems vulnerable. However, if columns var1 and var2 in table
TBL are of type enum{1, 2}, then that query is no longer
exploitable because the database will not accept any other
values. Chainsaw captures such database constraints (e.g.,
($v1==1 ∨ $v1==2) and ($v2==1 ∨ $v2==2)) and adds them
to PHP variables used in an insert or update query. Our
database schema analysis is capable of analyzing a variety of
SQL-based database schemas (e.g., MS SQL, MySQL, Oracle,
etc.).
1 $v1= $_GET[’v1’];
2 $v2= $_GET[’v2’];
3 mysql_query(INSERT INTO TBL (var1, var2) VALUES ($v1, $v2));
Listing 6: Example that demonstrates the need for
considering database constraints on PHP variables.
Another source of database constraints occur due to stored
procedures. To analyze these, we need to statically analyze
the stored procedure to extract constraints. Our implemen-
tation currently does not have this support. However, none
of our evaluated applications make use of stored procedures.
4.4 Constraint Solving
To generate exploit seeds and the ﬁnal working exploits,
Chainsaw uses the Z3 SMT [10] solver and its plug-in Z3-
str [30]. For each global execution path, Chainsaw prepro-
cesses the path information to facilitate the translation to
solver speciﬁcations. To do so, we take advantage of the gen-
erated Three-Address-Code (TAC) representation of source
code during the CFG construction. Each TAC statement is
then encoded as a formula.
Notes on Translation Our tool recognizes and translates
binary and unary PHP expressions, built-in PHP functions,
and conditional statements. Our approach models the se-
mantics of the 70 most used PHP built-in functions. The
support for several string operations in Z3 is coarse, so we
have augmented these with our own Z3 speciﬁcations to
model built-in functions and to infer data types.
As an example, Listing 7 shows a translation of the PHP
statement $cat_desc=htmlspecialchars($_GET[’cat_desc’])
in Z3 performed by Chainsaw. This function replaces cer-
tain characters (e.g., single quotes, ampersands) with their
HTML entity encodings. To model this function using the
solver language, we use the Z3-str Replace function. Since
this function replaces only the ﬁrst occurrence of a substring,
Chainsaw replicates the code shown in Listing 7 for each
occurrence of a special character.
1 (assert (= temp_0 (Replace $_GET[’cat_desc’] "&" "&amp;")))
2 (assert (= temp_1 (Replace temp_0 "\"" "&quot;")))
3 (assert (= temp_2 (Replace temp_1 "" "&gt;")))
647Listing 7: Z3 speciﬁcations that model the semantic of
htmlspecialchars PHP built-in function
5. EVALUATION
Subject Applications. We evaluated Chainsaw on the
9 PHP applications shown in Table 1. The applications
are of varying complexity, with SLOC ranging from 323 to
65302. Our dataset covers all test subjects used in two close
works to Chainsaw, namely Ardilla [19] and CraxWeb [16].
In addition, our dataset covers test subjects from multiple
related works (e.g., 2 from [9], 1 from [8], 1 from [26], and 1
from [3]).
Application
myBloggie (2.1.4)
scarf beta
DNScript
WeBid (0.5.4)
Eve(1.0)
schoolmate (1.5.4)
geccbblite (0.1)
faqforge (1.3.2)
webchess (0.9)
PHP
Files
56
19
60
300
8
63
11
17
29
PHP
SLOC
9090
978
1322
65302
905
15375
323
1676
5219
SQL
Queries
59
20
73
616
41
400
23
54
134
DB
Tables
4
7
7
63
2
15
1
2
7
XSS
Sinks
160
251
334
450
102
559
40
35
504
Table 1: Subject applications of our evaluation.
Setup. Chainsaw was deployed on Ubuntu 12.04 LTS VM
with 2-cores of 2.4GHz each and 40GB RAM. For each appli-
cation, we ﬁrst ran the seed generation and then the exploit
generation step. We automatically veriﬁed each exploit seed
and each working exploit to ensure they reach the sink, and
manually conﬁrmed each exploit to ensure the exploit had
the desired eﬀect. We also measured the run time of Chain-
saw. For these applications, the dynamic auditing mode
is equivalent to the static input generation mode, and the
former was used for eﬃciency.
5.1 Overview of Results
Table 2 shows the summary of our results. On the 9 subject
applications, Chainsaw identiﬁed a total of 181 exploit seeds
and a total of 199 working exploits with no false positives.
While 149 (75%) of the working exploits are SQLI exploits,
50 (25%) are XSS exploits. Of all the working exploits, 30
(15%) are second-order exploits. 13 of the 30 second-order
exploits are second-order SQLI exploits and the remaining
17/30 are stored XSS exploits. We outperform most related
approaches in the precision and coverage of vulnerability
detection (Section 5.6).
5.2 Selected First-Order Exploits
For webchess, Chainsaw generated multiple SQLI and
XSS exploits located in diﬀerent modules. One of these
is the SQLI exploit generated for the vulnerable query in
viewmessage.php (see Listing 8). This exploit allows the
attacker to view the communication messages of other users.
The global navigation sequence for this exploit is as follows:
The number of generated constraints is 203 with exploit
generation time of 156 sec. The exploit string is shown
in Listing 21 in the Appendix. Note, for demonstration
purposes, we represent all exploits as GET requests.
1 if(isset($_POST[’messageID’]))
2
{$messageID = $_POST[’messageID’]; //no sanitization
$SqlQuery="SELECT * FROM communication WHERE commID=$messageID";}
3
Listing 8: Vulnerable query in viewmessage.php of Webchess.
In Addcat2.php (see Listing 9) of the DNScript applica-
tion, an attacker can insert a malicious domain name to
the database. AddCat2.php does not apply sanitization on
the user input before using it in the query. The navigation
sequence is as follows:
Chainsaw generated 2 exploits for this query. The ﬁrst
exploit follows the intended workﬂow and has a path length
of 4. The number of constraints collected from the ﬁve
modules is 27. Due to the presence of a CAPTCHA in
login.php, to generate a working exploit, we made very
minimal changes to the source code so that it generates a
valid CAPTCHA string. The other exploit generated by
Chainsaw for the same query follows a shorter programmer
unintended workﬂow path which hits AddCat2.php (a publicly
accessible page) with exploit path length equals to 1 and 3
constraints. As we noted before, while most exploit paths
follow the intended workﬂow of an application, an equally
feasible exploit can be generated by breaking the workﬂow. In
this particular context, the alternative exploit path requires
visiting 1 module (compared to 4 modules).
1 $values = ’VALUES ("’.$_POST[’cat_name’].’")’; //no sanitization
2 $insert = mysql_query("INSERT INTO gen_cat (cat_name) " .$values);
Listing 9: AddCat2.php in DNScript.
1 http://host/DNScript/AddCat2.php?cat_name=1’ OR ’1’=’1
Listing 10: Exploit for the query at line 2 in Listing 9.
For EVE, Chainsaw generated 5 SQLI in two modules:
Case 1: In edit.php, Chainsaw generated an SQLI exploit
that has a path length of 1 (edit.php is public) and the
number of constraints is 40. This exploit enables retrieving
other members’ information. Listing 11 (line 2) shows the
vulnerable query and the generated exploit (line 3).
1 $member = $_GET[’id’]; //no sanitization
2 mysql_query("SELECT MemberID, Name, Division, DateJoined, RankCorp,
Vacation, Comment, Deleted FROM MembersMain WHERE MemberID=
’".$member."’";
3 http://host/eveactive/edit.php?id=1’ OR ’1’=’1
Listing 11: Exploit for the query at line 2 in edit.php.
Case 2: In member.php, Chainsaw generated 4 SQLI ex-
ploits, all on update queries (see sample in Listing 12) in
which the attacker can inject a malicious payload in $comment
and $name. Other variables used in the queries are safe be-
cause the other columns in the MembersMain table are either
integers or of date data type. Chainsaw adds the type of
the columns associated with each variable used in a query
to the set of the constraints extracted for the source code as
discussed in Section 4.3. All 4 exploits have the following
navigation sequence:
WebGraphviz is Graphviz in the BrowserEnter your graphviz data into the Text Area:(Your Graphviz data is private and never harvested)Sample 1 Sample 2 Sample 3 Sample 4 Sample 5 digraph G {  "Welcome" -> "To"  "To" -> "Web"  "To" -> "GraphViz!"}Generate Graph!index.phpmainmenu.phpformviewmessage.phpformWebGraphviz is Graphviz in the BrowserEnter your graphviz data into the Text Area:(Your Graphviz data is private and never harvested)Sample 1 Sample 2 Sample 3 Sample 4 Sample 5 digraph G {  "Welcome" -> "To"  "To" -> "Web"  "To" -> "GraphViz!"}Generate Graph!Login.phpDoLogin.phpformindex.phpheaderinc/nav.phpincludeAddCat2.phplinkWebGraphviz is Graphviz in the BrowserEnter your graphviz data into the Text Area:(Your Graphviz data is private and never harvested)Sample 1 Sample 2 Sample 3 Sample 4 Sample 5 digraph G {  "Welcome" -> "To"  "To" -> "Web"  "To" -> "GraphViz!"}Generate Graph!add.phpmember.phpform648Application
SQLI
Seeds
1st Order
SQLI Exploits
XSS
Seeds
1st Order
XSS Exploits
2nd order
SQLI Exploits
2nd order
XSS Exploits
Total
Exploits
myBloggie
scarf
DNScript
WeBid