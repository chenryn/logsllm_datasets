private key pair file. It is also possible to create this pair key in Visual Studio
In Visual Studio 2005, the C#, Visual Basic, and Visual J# integrated development environments (IDEs) allow you 
to generate key pairs and sign assemblies without the need to create a key pair using Sn.exe (Strong Name 
Tool). 
These IDEs have a Signing tab in the Project Designer. . The use of the AssemblyKeyFileAttribute to identify key 
file pairs has been made obsolete in Visual Studio 2005.
The following figure illustrates the process done by the compiler
A5 - Security Misconfiguration
108
Using Strong Name tool
The Sign Tool is a command-line tool that digitally signs files, verifies signatures in files, or time stamps files.
The Sign Tool is not supported on Microsoft Windows NT, Windows Me, Windows 98, or Windows 95.
In case you aren’t using the “Visual Studio Command Prompt” (Start >> Microsoft Visual Studio 2010 >> Visual 
Studio Tools >> Visual Studio Command Prompt (2010)) you can locate sn.exe at %ProgramFiles%\Microsoft 
SDKs\Windows\v7.0A\bin\sn.exe
The following command creates a new, random key pair and stores it in keyPair.snk.
sn -k keyPair.snk
The following command stores the key in keyPair.snk in the container MyContainer in the strong name CSP.
sn -i keyPair.snk MyContainer
The following command extracts the public key from keyPair.snk and stores it in publicKey.snk.
sn -p keyPair.snk publicKey.snk
The following command displays the public key and the token for the public key contained in publicKey.snk.
sn -tp publicKey.snk
The following command verifies the assembly MyAsm.dll.
sn -v MyAsm.dll
The following command deletes MyContainer from the default CSP.
sn -d MyContainer
Using the Assembly Linker(AI.exe)
C#VB
COMPILER
• ASSEMBLY BINARY
• SIMPLE NAME
• VERSION NUMBER
• CULTURE INFO
PUBLIC KEY
PRIVATE KEY
ASSEMBLY
Manifest
Version Number
Culture Info
Public Key
Simple Name
Metadata
CIL
Digital Signature
Figure 9: C# Strong Naming
A5 - Security Misconfiguration
109
This tool is automatically installed with Visual Studio and with the Windows SDK. To run the tool, we recom-
mend that you use the Visual Studio Command Prompt or the Windows SDK Command Prompt (CMD Shell). 
These utilities enable you to run the tool easily, without navigating to the installation folder. For more informa-
tion, see Visual Studio and Windows SDK Command Prompts.
If you have Visual Studio installed on your computer:
On the taskbar, click Start, click All Programs, click Visual Studio, click Visual Studio Tools, and then click Visual 
Studio Command Prompt.
-or-
If you have the Windows SDK installed on your computer:
On the taskbar, click Start, click All Programs, click the folder for the Windows SDK, and then click Command 
Prompt (or CMD Shell).
At the command prompt, type the following:
al sources options
Remarks
All Visual Studio compilers produce assemblies. However if you have one or more modules (metadata without 
a manifest) you can use Al.exe to create an assembly with the manifest in a separate file.
To install assemblies in the cache, remove assemblies from the cache, or list the contents of the cache, use the 
Global Assembly Cache Tool (Gacutil.exe).
The following command creates an executable file t2a.exe with an assembly from the t2.netmodule module. 
The entry point is the Main method in MyClass.
 al t2.netmodule /target:exe /out:t2a.exe /main:MyClass.Main
Use Assembly attributes
You can insert the strong name information in the code directly. For this, depending on where the key file is 
located you can use AssemblyKeyFileAttribute or AssemblyKeyNameAttribute
Use Compiler options :use /keyfile or /delaysign
Safeguarding the key pair from developers is necessary to maintain and guarantee the integrity of the assem-
blies. The public key should be accessible, but access to the private key is restricted to only a few individuals. 
When developing assemblies with strong names, each assembly that references the strong-named target as-
sembly contains the token of the public key used to give the target assembly a strong name. This requires that 
the public key be available during the development process.
You can use delayed or partial signing at build time to reserve space in the portable executable (PE) file for the 
strong name signature, but defer the actual signing until some later stage (typically just before shipping the 
assembly).
You can use /keyfile or /delaysign in C# and VB.NET (MSDN)
References
• http://msdn.microsoft.com/en-us/library/wd40t7ad(v=vs.80).aspx
• http://msdn.microsoft.com/en-us/library/c405shex(v=vs.110).aspx
• http://msdn.microsoft.com/en-us/library/k5b5tt23(v=vs.80).aspx
A5 - Security Misconfiguration
110
• http://msdn.microsoft.com/en-us/library/t07a3dye(v=vs.80).aspx
• http://msdn.microsoft.com/en-us/library/t07a3dye(v=vs.110).aspx
11.10 Round Tripping
Round Tripping is a reverse engineering technique that allows and attacker to decompile an assembly from a 
certain application. Ildasm.exe can be used for this purpose, and ILAsm is used to recompiled the assembly.
The MSIL Disassembler( Ildasm.exe) is a companion tool to the MSIL Assembler (Ilasm.exe). Ildasm.exe takes a 
portable executable (PE) file that contains Microsoft intermediate language (MSIL) code and creates a text file 
suitable as input to Ilasm.exe. This tool is automatically installed with Visual Studio and with the Windows SDK. 
The importance of Obfuscation
As mentioned before, Round Tripping is a technique used to reverse engineer assemblies. Therefore, if you 
want to avoid your assemblies being reversed engineered or even worse, that the code is victim of malicious 
manipulation using the Ildasm and Ilasm tools, then it is advisable to apply it. There are different kinds of prod-
ucts that can be used for this purpose such as DeepSea, Crypto or Dotfuscator.
Using Obfuscation
The most effective technique used to avoid reverse engineering and tampering of assemblies is the use of 
Obfuscation. Visual Studio contains a version of Dotfuscator. This program is accessible by choosing on the VS 
menu, Tools  Dotfuscator(Community Edition menu command). Note: This tools is not available in Express 
versions
To obfuscate your assemblies:
• Build the project in VS Studio
• Tools--> Dotfuscator Community Edition
• A screen prompts asking for which project type, choose ‘Creat New Project’ and click OK
• On the Input tab of the Dotfuscator interface, click ‘Browse and Add assembly to list’
Browse for the compiled application
ASPNetConfigs
Introduction
Securing resources in ASP.NET applications is a combination of configuration settings in the Web.config file 
but also, it’s important to remember that the IIS configurations play also a big part on this. It’s an integrated 
approach which provides a total framework of security.
The following highlights the most important aspects of ASP.NET configuration settings within the web.config 
file. For a total overview see chapter ASP.NET security (https://www.owasp.org/index.php/CRV2_Framework-
SpecIssuesASPNet)
Secure Configuration Values
Sensitive Information saved in config files should be encrypted. Encryption keys stored in the machineKey 
element for example or connectionstrings with username and passwords to login to database.
Lock ASP.NET Configuration settings
You can lock configuration settings in ASP.NET configuration files (Web.config files) by adding an allowOver-
ride attribute to a location element 
A5 - Security Misconfiguration
111
Configure directories using Location Settings
Through the  element you can establish settings for specific folders and files. The Path attribute is 
used to specify the file or subdirectory. This is done in the Web.config file example:
Configure exceptions for Error Code handling
Showing and handling the correct error code when a user sends a bad request or invalid parameters is an im-
portant configuration subject. Logging these errors are also an excellent help when analyzing potential attacks 
to the application.
It is possible to configure these errors in the code or in the Web.Config file
The HttpException method describes an exception that occurred during the processing of HTTP requests.For 
example:
or in the Web.config file:
Sample 11.29
if (string.IsNullOrEmpty(Request[“id”]))
     throw new HttpException(400, “Bad request”);
Sample 11.30
Sample 11.31
A5 - Security Misconfiguration
112
Input validation
Anything coming from external sources can be consider as input in a web application. Not only the user in-
serting data through a web form, but also data retrieved from a web service or database, also headers sent 
from the browsers fall under this concept. A way of defining when input is safe can be done through outlining 
a trust boundary.
Defining what is known as trust boundary can help us to visualize all possible untrusted inputs. One of those 
are user input.ASP.NET has different types of validations depending on the level of control to be applied. By 
default, web pages code is validated against malicious users. The following is a list types of validations used 
(MSDN, 2013):
References
MSDN, 2013 “Securing ASP.NET Configurations” available at 
http://msdn.microsoft.com/en-us/library/ms178699%28v=vs.100%29.aspx (Last Viewed, 25th July 2013)
11.11 .NET Authentication Controls
In the .NET, there are Authentication tags in the configuration file. The  element configures 
the authentication mode that your applications use. The appropriate authentication mode depends on how 
your application or Web service has been designed. The default Machine.config setting applies a secure Win-
dows authentication default as shown below
authentication Attributes:mode=”[Windows|Forms|Passport|None]”
Type of validation
Control to use
Required entry
RequiredFieldValidator
Comparison to a value
CompareValidator
Description
Ensures that the user does not skip an entry.
Compares a user’s entry against a constant value, against the value of another 
control (using a comparison operator such as less than, equal, or greater than), 
or for a specific data type.
Range checking
RangeValidator
Checks that a user’s entry is between specified lower and upper boundaries. 
You can check ranges within pairs of numbers, alphabetic characters, and dates.
Pattern matching
RegularExpressionValidator
Checks that the entry matches a pattern defined by a regular expression. This 
type of validation enables you to check for predictable sequences of characters, 
such as those in e-mail addresses, telephone numbers, postal codes, and so on.
User-defined
CustomValidator
Checks the user’s entry using validation logic that you write yourself. This type 
of validation enables you to check for values derived at run time.
Figure 10: IIS Input Validation
A5 - Security Misconfiguration
113
Forms Authentication Guidelines
To use Forms authentication, set mode=“Forms” on the  element. Next,
configure Forms authentication using the child  element. The following fragment shows a secure 
 authentication element configuration:
Use the following recommendations to improve Forms authentication security:
• Partition your Web site.
• Set protection=“All”.
• Use small cookie time-out values.
• Consider using a fixed expiration period.
• Use SSL with Forms authentication.
• If you do not use SSL, set slidingExpiration = “false”.
• Do not use the  element on production servers.
• Configure the  element.
• Use unique cookie names and paths.
Classic ASP 
For classic ASP pages, authentication is usually performed manually by including the user information in ses-
sion variablesafter validation against a DB, so you can look for something like:
Session (“UserId”) = UserName
Session (“Roles”) = UserRoles
Code Review .Net Manage Code
.NET Managed code is less vulnerable to common vulnerabilities found in unmanaged code such as Buffer 
Overflows and memory corruption however there could be issues in the code that can affect performance and 
security.  The following is a summary of the recommended practices to look for during the code review. Also, it 
is worth mentioning some tools that can make the work easier on this part and they can help you understand 
and pin point flaws in your code
Code Access Security
This supports the execution of semi-trusted code, preventing several forms of security threats. The following is 
a summary of possible vulnerabilities due to improper use of Code Access security:
   Sliding session lifetime
Sample 11.32
A5 - Security Misconfiguration
114
Declarative security
Use declarative security instead of imperative whenever possible. 
Example of declarative syntax(MSDN[2], 2013):
Unmanaged code 
Even though C# is a strong type language, it is possible to use unmanaged code calls by using the ‘unsafe’ 
code. “Check that any class that uses an unmanaged resource, such as a database connection across method 
calls, implements the IDisposable interface. If the semantics of the object are such that a Close method is more 
logical than a Dispose method, provide a Close method in addition to Dispose”.
Exception handling
Manage code should use exception handling for security purposes among other reasons. Make sure that you 
follow these recommendations:
*Avoid exception handling in loops, use try/catch block if it is necessary.
*Identify code that swallows exceptions
*Use exceptions handling for unexpected conditions and not just to control the flow in the application
Tools
FxCop
FxCop is an analysis tool that analyses binary assemblies, not source code. The tool has a predefined set of 
rules and it is possible to configure and extend them.
Some of the available rules regarding security are (CodePlex, 2010):
Vulnerability
Improper use of link demands or asserts
Code allows untrusted callers
Implications
The code is susceptible to luring attacks
Malicious code can use the code to perform sensitive operations and access resources
Table 16: Code Access Security Vulnerabilities
[MyPermission(SecurityAction.Demand, Unrestricted = true)]
  public class MyClass
  {
   public MyClass()
   {
      //The constructor is protected by the security call.
   }
   public void MyMethod()
   {
      //This method is protected by the security call.
   }
   public void YourMethod()
   {
      //This method is protected by the security call.
   }
}
Sample 11.33
A5 - Security Misconfiguration
115
Rule
Description
EnableEventValidationShouldBeTrue
Verifies if the EnableEventValidation directive is disabled on a certain page.
ValidateRequestShouldBeEnabled
Verifies if the ValidateRequest directive is disabled on a certain page.
ViewStateEncryptionModeShouldBeAlways
EnableViewStateMacShouldBeTrue
EnableViewStateShouldBeTrue
ViewStateUserKeyShouldBeUsed
EnableCrossAppRedirectsShouldBeTrue
FormAuthenticationProtectionShouldBeAll
FormAuthenticationRequireSSLShouldBeTrue
FormAuthenticationShouldNotContainFormAuthentica
tionCredentials
CustomErrorPageShouldBeSpecified
DebugCompilationMustBeDisabled
Verifies if the ViewStateEncryptionMode directive is not set to Never on a certain page.
Verifies if the EnableViewStateMac directive is not set to false on a certain page.
Verifies if the EnableViewState directive is not set to false on a certain page.
Verifies if the Page.ViewStateUserKey is being used in the application to prevent CSRF.
Verifies that system.web.authentication.forms enableCrossAppRedirects is set to true. The 
settings indicate if the user should be redirected to another application url after the authen-
tication process. If the setting is false, the authentication process will not allow redirection to 
another application or host. This helps prevent an attacker to force the user to be redirected 
to another site during the authentication process. This attack is commonly called Open redi-