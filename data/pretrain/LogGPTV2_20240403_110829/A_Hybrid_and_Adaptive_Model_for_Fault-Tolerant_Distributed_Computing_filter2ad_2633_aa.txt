title:A Hybrid and Adaptive Model for Fault-Tolerant Distributed Computing
author:S&apos;ergio Gorender and
Raimundo A. Macêdo and
Michel Raynal
A Hybrid and Adaptive Model for Fault-Tolerant Distributed Computing
S´ergio GORENDER
‡
Raimundo MAC ˆEDO
‡∗
Michel RAYNAL
†
‡
†
Distributed Systems Laboratory (LaSiD), Department of Computing Science (DCC)
Federal University of Bahia, Campus de Ondina, 40170-110, Salvador-BA, Brazil
IRISA, Universit´e de Rennes 1, Campus de Beaulieu, 35042 Rennes Cedex, France
{gorender|macedo}@ufba.br
Abstract
The capability of dynamically adapting to distinct run-
time conditions is an important issue when designing dis-
tributed systems where negotiated quality of service (QoS)
cannot always be delivered between processes. Providing
fault-tolerance for such dynamic environments is a chal-
lenging task. Considering such a context, this paper pro-
poses an adaptive model for fault-tolerant distributed com-
puting. This model encompasses both the synchronous
model (where there are time bounds on processing speed
and message delay) and the asynchronous model (where
there is no time bound). To illustrate what can be done in
this model and how to use it, the consensus problem is taken
as a benchmark problem. An implementation of the model is
also described. This implementation relies on a negotiated
quality of service (QoS) for channels, that can be timely or
untimely. Moreover, the QoS of a channel can be lost dur-
ing the execution (i.e., dynamically modiﬁed from timely to
untimely), thereby adding uncertainty into the system.
Keywords: Adaptability, Asynchronous/synchronous dis-
tributed system, Consensus, Distributed computing model,
Fault tolerance, Quality of service.
1 Introduction
Synchronous vs asynchronous models Distributed sys-
tems are made up of processes, located on one or more sites,
that communicate with one another to offer services to up-
per layer applications. A major difﬁculty a system designer
has to cope with in these systems lies in the capture of con-
sistent global states from which safe decisions can be taken
in order to guarantee a safe progress of the upper layer ap-
plications. To study and investigate what can be done (and
how it has to be done) in these systems when they are prone
to process failures, two distributed computing models have
∗
Corresponding author. Fax: +557132636145
PI:EMAIL
received a lot of attention, namely, the synchronous model
and the asynchronous model.
The synchronous distributed computing model provides
processes with bounds on processing time and message
transfer delay. These bounds, explicitly known by the
processes, can be used to safely detect process crashes and
allow consequently the non-crashed processes to progress
with safe views of the system state (such views can be ob-
tained with some “time-lag”). Differently, the asynchronous
model is characterized by the absence of time bounds (that
is why this model is sometimes called time-free model). In
these systems, a system designer can only assume an up-
per bound on the number of processes that can crash (usu-
ally denoted f ) and consequently design protocols relying
on the assumption that at least (n − f ) processes are alive
(n being the total number of processes). The protocol has
no means to know whether a given process is alive or not.
Moreover, if more than f processes crash, there is no guar-
antee on the protocol behavior (usually the protocol loses
its liveness property).
Synchronous systems are attractive because they allow
system designers to solve a lot of problems. The price that
has to be paid is the a priori knowledge on time bounds.
If they are violated, the upper layer protocols may be un-
able to still guarantee their safety property. As they do
not rely on explicit time bounds, asynchronous systems do
not have this drawback. Unfortunately, they have another
one, namely, some basic problems are impossible to solve
in asynchronous systems. The most famous is the consen-
sus problem, that has no deterministic solution when even a
single process can crash [7].
The consensus problem can be stated as follows. Each
process proposes a value, and has to decide a value, un-
less it crashes (termination), such that there is a single de-
cided value (uniform agreement), and that value is a pro-
posed value (validity). This problem, whose statement is
particularly simple, is fundamental in fault-tolerant asyn-
chronous distributed computing as it abstracts several basic
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:54:06 UTC from IEEE Xplore.  Restrictions apply. 
agreement problems. While consensus is considered as a
“theoretical” problem, systems designers are usually inter-
ested in the more practical Atomic Broadcast problem. That
problem is both a communication problem and an agree-
ment problem.
Its communication part speciﬁes that the
processes can broadcast and deliver messages in such a way
that the processes that do not crash deliver at least the mes-
sages they send. Its agreement part speciﬁes that there is a
single delivery order (so, the correct processes deliver the
same sequence of messages, and a faulty process delivers
a preﬁx of this sequence of messages). It has been shown
that consensus and atomic broadcast are equivalent prob-
lems in asynchronous systems prone to process crashes [5]:
in such a setting, any protocol solving one of them can be
used as a black box on top of which the other problem can
be solved. Consequently, in asynchronous distributed sys-
tems prone to process crashes, the impossibility of solving
consensus extends to atomic broadcast. This impossibility
in the asynchronous model has motivated researchers to ﬁnd
distributed computing models, weaker than the synchronous
model but stronger than the asynchronous model, in which
consensus can be solved.
Content of the paper
In practice, systems are neither
fully synchronous, nor fully asynchronous. Most of the time
they behave synchronously, but can have “unstable” periods
during which they behave in an anarchic way. Moreover,
there are now “QoS architectures” that allow processes to
dynamically negotiate the quality of service of their com-
munication channels. These simple observations motivate
the design of an adaptive distributed computing model that
does its best to provide the processes with safe information
on the current state of the other processes. This paper pro-
poses a model that is a step in that direction.
This model is time-free in the sense that processes are
not provided with time bounds guaranteed by the lower sys-
tem layer. Each process pi is provided with three sets de-
noted downi, livei and uncertaini. These sets, that are
always a partition of the whole set of processes, deﬁne the
view pi has of the state of the other processes. More pre-
cisely, if pk ∈ downi, then pi knows that pk has crashed;
when pk ∈ livei, then pi can consider pk as being alive;
ﬁnally, when pk ∈ uncertaini, pi has no information on
the current state of pk. These sets can evolve in time, and
can have different values for different processes. For ex-
ample, it is possible that (due to the fact that some qual-
ity of service can no longer be ensured) the view pi has on
pk be degraded in the sense that the model moves pk from
livei to uncertaini. It is also possible that (due to the fact
that a stable period lasts “long enough”) the view pi has
on pk be upgraded in the sense that the model moves pk
from uncertaini to livei. So, the model is able to beneﬁt
from time windows to transform timeliness properties (cur-
rently satisﬁed by the lower layer) into time-free properties
(expressed on the previous sets) which can be used by up-
per layer protocols. Interestingly, this model includes the
synchronous model and the asynchronous model as partic-
ular cases. The synchronous model corresponds to the case
where, for all the processes pi, the sets uncertaini are al-
ways empty. The asynchronous model corresponds to the
case where, for all the processes pi, the sets uncertaini
always include all processes.
It is important to notice that our approach is orthogonal
to the failure detector (FD) approach [5]. Given a prob-
lem P that cannot be solved in the asynchronous model, the
FD approach is a computability approach: it consists in en-
riching the asynchronous model with time-free properties
that are sufﬁcient for the problem to become solvable. Our
approach is “engineering” oriented.
It aims at beneﬁting
from the fact that systems are built on QoS architectures,
thereby allowing a process not to always consider the other
processes as being in an “uncertain” state. As the proposed
model includes the asynchronous model, it is still neces-
sary to enrich it with appropriate mechanism to solve prob-
lems that are impossible to solve in pure time-free systems.
To illustrate this point and evaluate the proposed approach,
the paper considers the consensus problem as a benchmark
problem. A consensus protocol is presented, that is based on
the fact that each process pi is provided with (1) three sets
downi, livei and uncertaini with the previously deﬁned
semantics, and (2) an appropriate failure detector module
(namely, 3S).
Interestingly, while 3S-based consensus
protocols in asynchronous systems require f < n/2, the
proposed 3S-based protocol allows bypassing this bound
when few processes are in the uncertaini sets during the
protocol execution.
Another interesting feature of the proposed model lies
in the fact that it allows to design generic protocols, in the
sense that a protocol designed for that model “includes”
both a synchronous protocol and an asynchronous proto-
col. In that sense, the proposed model provides the designer
with a better insight on the borderline separating synchrony
and asynchrony in presence of process crashes.
Related work Our approach relates to previous work on
distributed system models and adaptiveness. The timed
asynchronous model [6] considers asynchronous processes
equipped with physical clocks. The timely computing base
[14] provides services built on top of an underlying dedi-
cated synchronous network.
Several works aimed at circumventing the impossibility
of consensus in the asynchronous system model [7] (e.g.,
minimal synchronism and partial synchrony that have been
abstracted in the failure detector approach introduced and
investigated in [4, 5]).
Many systems have addressed adaptiveness, including
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:54:06 UTC from IEEE Xplore.  Restrictions apply. 
[11, 13, 9, 3]. AquA [11] provides adaptive fault-tolerance
to CORBA applications by replicating objects and provid-
ing a high-level method that an application can use to spec-
ify its desired level of reliability. AquA also provides an
adaptive mechanism capable of coping with application de-
pendability requirements at runtime.
It does so by using
a majority voting algorithm. Ensemble [13] offers a fault-
tolerant mechanism that allows adaptation at runtime. This
is used to dynamically adapt the components of a group
communication service to switch between two total order
algorithms (sequencer-based vs token-based) according to
the desired system overhead and end-to-end latency for ap-
plication messages.
The concept of real-time dependable channels (RTD) has
been introduced in [9] to handle QoS adaptation at channel
creation time. In their paper, the authors show how an appli-
cation can customize a RTD channel according to speciﬁc
QoS requirements, such as bounded delivery time, reliable
delivery, message ordering, and jitter (variance in message
transmission time). Such QoS requirements are stated in
terms of the probabilities related to speciﬁc QoS guarantees
and are enforced by a composite protocol based on the real-
time version of the Cactus system (CactusRT).
The work presented in [3] explicitly addresses the prob-
lem of dynamically adapting applications when a given ne-
gotiated QoS can no longer be delivered. In order to accom-
plish that, they deﬁned a QoS coverage service that provide
the so-called time-elastic applications (such as mission-
critical or soft real-time systems) with the ability of depend-
ably decide how to adapt time bounds in order to maintain a
constant coverage level. Such service is implemented over
the wormhole Timely Computing Base or TCB. By using
its duration measurement service, TCB is able to monitor
the current QoS level (in terms of timeliness), allowing ap-
plications to dynamic adapt when a given QoS can not be
delivered.
Like [3], our work tackles QoS adaptability in terms of
timeliness at run-time. However, we do not adapt time
bounds to time-elastic applications. Instead, our hybrid sys-
tem model adapts to the available QoS, providing applica-
tions with safe information on the current state of processes.
Moreover, we show how an adaptive consensus protocol
can take advantage of the proposed hybrid model. As we
shall see in section 4, though we have our own implemen-
tation based on QoS architectures, our system model could
be easily implemented on top of systems such as TCB and
CactusRT.
Roadmap The paper is made up of ﬁve sections. Section
2 introduces the model. Then, Section 3 presents and proves
correct a consensus protocol suited to the model. Section 4
describes an implementation of the model based on a dis-
tributed system architecture providing negotiated QoS guar-
antees. Finally, Section 5 concludes the paper.
2 An Adaptive Model for Fault-Tolerant Dis-
tributed Computing
It is important to notice that the model offered to upper
layer applications is time-free in the sense that it offers them
neither timing assumptions, nor time functions.
2.1 Asynchronous Distributed
Process Crash Failures
System with
We consider a system consisting of a ﬁnite set Π of
n ≥ 2 processes, namely, Π = {p1, p2, . . . , pn}. A process
executes steps (a step is the reception of a message, the
sending of a message, each with the corresponding local
state change, or a simple local state change). A process
can fail by crashing, i.e., by prematurely halting. After
it has crashed a process does not recover. It behaves cor-
rectly (i.e., according to its speciﬁcation) until it (possibly)
crashes. By deﬁnition, a process is correct in a run if it does
not crash in that run. Otherwise, a process is faulty in the
corresponding run. In the following, f denotes the max-