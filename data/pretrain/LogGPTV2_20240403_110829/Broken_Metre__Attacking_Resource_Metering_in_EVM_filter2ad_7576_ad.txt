Fig. 12: Bytecode snippet generated by our genetic algorithm. Instructions in
bold involve some sort of IO operations.
function described in the program construction section:
to
avoid CALLDATACOPY to read very far away in memory,
which would make the program run out of gas, the arguments
are replaced with small values. We note that our algorithm can
generate programs of arbitrary length but in our experiments
we set it to create programs of around 4,000 instructions which
consume between 100,000 and 150,000 gas.
Generating low-throughput contracts. We show how the
throughput of the lowest performing contract evolved with the
number of generations in Figure 10. The line represents the
mean of the measurements and the band represents the standard
deviation of the measurements. The measurements are run 3
times. Except from one point in the ﬁrst measurements, overall
the standard deviation remains relatively low.
We can see that during the ﬁrst generations, the throughput
is around 1.25M gas per second, which is already fairly low
given that the average throughput for a transaction on the
same machine is around 20M gas per second. This shows
that our initialisation is effective. The throughput decreases
very quickly in the ﬁrst few generations, and then steadily
decreases down to around 110K gas per second, which is more
than 180 slower than the average transaction. After about 200
generations, the throughput more or less plateaus.
Exploring the minimum. The minimum in our experiments
is attained at generation 243. At this point, the block uses in
total approximately 9.9M gas and takes around 93 seconds
to execute, or a throughput of about 107,000 gas per second.
We show in Figure 11 how the execution time increases with
the amount of gas consumed within the block. It is important
to note that the execution time increases perfectly linearly
with the gas used, which means that all transactions in the
block have almost the same throughput. This implies that an
attacker could easily tune the time he wants to delay the
nodes depending on his budget. If a block full of malicious
Client
Time
second
Throughput
Gas/s
Aleth
Parity
Parity (metal)
Geth
Geth (ﬁxed)
IO load
MB/s
107, 349 ± 606.6 93.6 ± 0.53 9.12 ± 4.70
210, 746 ± 7, 672 47.1 ± 1.61 10.0 ± 1.36
542, 702 ± 9, 487 18.2 ± 0.23 17.2 ± 1.97
131, 053 ± 4, 207 75.6 ± 2.42 6.57 ± 4.13
3, 021, 038 ± 4.67e5 3.33 ± 0.56 0.72 ± 0.11
Fig. 13: Evaluation of different clients when executing 10M gas worth of
malicious transactions. What is presented is the mean across three measure-
ments ± standard deviation. All the measurements are performed on our GCP
except the “metal” which is done on our bare-metal server.
transactions were to be processed, given that an Ethereum
block is produced roughly every 13 seconds, 7 new blocks
would have been created by the time the node ﬁnishes to
validate the malicious one.
C. Evaluation on Other Ethereum Clients
We used aleth [22] to run our genetic algorithm and ﬁnd
low-throughput contracts. In this section, we show that the
contracts crafted using our algorithm are also effective on
the two most popular Ethereum clients: geth (v1.9.6) [30]
and Parity Ethereum (v2.5.9) [46]. We also show that the ﬁx
released in geth following discussions with the development
team successfully resolves the issue. Furthermore, although
our attack is mainly efﬁcient on less powerful hardware, we
include the measurements of Parity on a more powerful bare-
metal machine with 4 cores (8 threads) at 2.7GHZ, 32GB of
RAM and an SSD with 540MB/s throughput. To benchmark
the clients, we use the following procedure, and repeat the
measurements three times for each client.
1)
2)
3)
Synchronise the client to test;
Start the client in a private network, so that it does
not execute anything else but our contracts;
Execute
eth_call RPC endpoint;
transactions on the
client using the
a)
b)
Send transactions to warm-up the client
Send enough malicious transactions to con-
sume 10M gas
4) Measure the gas, time, IO, CPU and memory used
during the execution of the malicious transactions.
We report our results in Figure 13. Although we measured
CPU, memory, and IO usage, most of the used time was related
to IO operations and there was no signiﬁcant increase in either
CPU or memory usage during the attack. Therefore, we only
report the IO measurements collected during the attack. We
express the IO load in terms of MB/s, which we collect using
Linux’s iotop utility.
Before geth’s ﬁx, geth takes more than 75 seconds to exe-
cute 10M gas worth of malicious transactions. Parity Ethereum
is the least vulnerable to our attack, but still takes on average
about 47 seconds. Parity has on average a higher, but more
constant IO load than geth. Large increase in the IO load tend
to increase the IO wait time, which could explain why geth
is vastly slower than Parity. Aleth is the slowest of the three
clients. There could be two reasons for this: ﬁrst, our algorithm
10
is optimised on aleth, which makes it more likely to slow it
down, second, aleth is less actively developed than the other
two clients and might lack some optimisations.
The results of running Parity on a more powerful bare-
metal server show that even such machines are relatively
vulnerable to our attack. Indeed, Parity, which was the fastest
of the tree clients, still took more than 18 seconds to execute
the transactions. An important point to notice is that the IO
throughput is considerably higher on our bare-metal server,
which is most likely one of the main reason for the speedup.
Finally, we ran our attack on an improved version of
geth, which the Ethereum developers pointed us to as a result
of our interactions with them. This version includes several
optimisations to improve the storage access speed. We can see
that these improvements drastically reduced the IO load of the
client. With these improvements, geth executes the transactions
more than 20 times faster, making the execution speed fast
enough to counter such an attack. Our interaction with geth
developers shows the effectiveness of responsible vulnerability
disclosure, as discussed in Section IV-E.
D. REA as a Form of DoS
Malicious contracts crafted using our algorithm could eas-
ily be used to perform a DoS attacks on Ethereum. In this
section, we will describe the threat model of such an attack,
including the implications and feasibility of the attack.
Attack implications. As described in Section II,
there
have already been several instances of DoS attacks against
Ethereum [13], [12]. There are several consequences to such
attacks. The most direct one is a high increase in the block
production time [26], which in the worst cases more than
doubled, signiﬁcantly decreasing the total throughput of the
network. This decrease comes not only from miners who might
take more time to validate blocks but also from full nodes who
are supposed to relay validated blocks and might take vastly
longer to do so. A further indirect consequence of such attacks
is the loss of trust in the system, which can lead to a decrease
in the price of Ethereum, at least for a short period of time [18].
Probable attacker. Although instances of irrational behaviours
with likely no proﬁt
to the attacker have been seen on
Ethereum [9], we assume that the attacker is rational and wants
to proﬁt from such an attack. In this context, there are several
ways in which such an attack could be performed.
First, this attack could be beneﬁcial to miners. A miner
could use these malicious transactions to perform a sort of
selﬁsh-mining [27]. Indeed, if the miner chooses to include
a small amount of malicious transactions in the blocks he
mines, the propagation time per block is likely to increase and
give the miner a head-start on mining the next block. Given
that the block arrival time in Ethereum is around 13 seconds,
gaining a couple of seconds can be ﬁnancially interesting for
a miner. Furthermore, the only cost for a miner would be
the opportunity cost of not including other transactions in the
block, as he could include malicious transactions with a gas
price of 0.
ecosystem. An attacker wanting to make a one-shot proﬁt could
spend some amount of money into performing such a DoS
attack while taking a short position on ETH, waiting for the
price to go down. Other blockchains competing with Ethereum
could also potentially use such tactics to try to discredit the
reliability of Ethereum.
Attack feasibility. To reason about
the feasibility of this
attack, we assume that given the same gas price, a malicious
transaction has the same chance of being included in a block
as any other transaction. We use the time we obtained in our
experiments with geth, as it is the Ethereum client with the
largest usage share [24].
To ﬁnd a reasonable gas price, we analyse the gas price
of all transactions and blocks from October 1, 2019 (block
8,653,171) to December 31, 2019 (block 9,193,265). We
ﬁnd that the median value of the minimum gas price in a
block is around 1.1Gwei and that the average gas price is
around 10Gwei with a standard deviation of 11Gwei. These
values are in agreement with some other source of gas com-
putation [19]. Finally, we ﬁnd that at least 2 million gas worth
of transactions are included for less than 3Gwei in about 90%
of the blocks, and choose this value as the gas price to compute
the cost of an attack.
Given that our malicious transactions have a throughput of
about 131,000 gas per second, using a price of 3 Gwei, it would
cost roughly 131, 000 × 3 × 109 = 3.93 × 1014Wei = 3.93 ×
10−4 ETH ≈ 0.057 USD to execute code for one second.
Consequently, it would cost slightly more than 0.741 USD per
block to prevent nodes running on commodity hardware to
keep up with the network. This is a very cheap price to pay
and could indeed motivate the probable attackers discussed
earlier to execute such an attack.
It is worth noting that if an attacker wanted to ﬁll a larger
portion of the block with malicious transactions, he would need
to increase the gas price. Indeed, to ﬁll half of the block with
malicious transactions, it would require to pay around 15Gwei,
or 5 times more per gas, than to ﬁll only 20% of the block.
This would result in a cost of 10, 000, 000×50%×1.5×1010 =
0.075 ETH ≈ 10.875 USD. Nevertheless, this remains a very
low price to pay for an attacker with ﬁnancial incentives such
as the ones described earlier.
Attack limitations. The current requirements to run a full node
on the Ethereum main net are low enough for most commodity
hardware to be able to keep up without any issue. The only
point mentioned by the Ethereum developers is that running
a full node requires an SSD [50]. Although there is currently
no ofﬁcial documentation on other requirements, other sources
estimate the minimum required memory to be about 8GB [48],
there is very little information about
[47], [45]. However,
the typical hardware setup of full nodes. Therefore,
is
very difﬁcult to accurately evaluate how many nodes would
be affected by such an attack. Nevertheless, the attack was
judged severe enough by the Ethereum developers to react
very promptly (within less than 24 hours for the ﬁrst reply and
within four days for them to test the ﬁx) after our disclosure.
it
E. Responsible Disclosure
Another potential motivation for an attack could be to try to
reduce the price of the ETH token and the trust in the Ethereum
Given that the attack is very easy and cheap to execute, and
worked on all major clients, we went through a responsible
11
disclosure process. The Ethereum Foundation has an ofﬁcial
bug bounty program [23] to report vulnerabilities. With the
help of colleagues5, we wrote a report summarising our main
ﬁndings, including a minimal script to execute our attack, and
sent it to the bug bounty program on October 3, 2019. We
received a reply the next day from the Ethereum Security Lead,
acknowledging the issue and pointing us to some ongoing
efforts to improve some of the inefﬁciencies exploited by
our attack. The Ethereum foundation team also let us know
that they would coordinate with Parity developers. After dis-
cussions about the ongoing efforts and some other potential
solutions, we have been conﬁrmed that our report had been
awarded a reward of 5,000 USD on November 17, 2019.
Finally, the ofﬁcial announcement was published on the bounty
program website on January 7, 2020.
V. TOWARDS A BETTER APPROACH
Gas metering and pricing is a difﬁcult but fundamental
problem in Ethereum and other blockchains which use a
similar approach to price contract execution. Mispricing of
gas instructions has been a concern for a long time and
improvements have been included in several hard forks [11],
[53]. However, there remain issues in the current Ethereum
pricing model, allowing attacks such as the one we presented
in the previous sections. In this section, we will discuss short-
term ﬁx which can be used to prevent DoS such as the one
presented in this paper, and then brieﬂy present longer-term
potential solutions which are still being actively researched.
The main attack vector presented in this paper comes
from the low speed of searching for an account which is not
currently cached. One of the main issues is that the state of
Ethereum gets larger with time. This means that operations
accessing the state get more expensive with time in terms of
resource usage.
Short-term ﬁxes. Short-term ﬁxes for slow IO related issues
can be categorised in the two following classes: increase in
the gas cost of IO instructions, as seen in EIP-150 [11] and
EIP-2200 [53], and improvements in the speed of Ethereum
clients.
Increasing the cost of IO instructions improves the fairness
of the gas costs yet is often not sufﬁcient to protect against
DoS attacks, albeit it does increase their cost. The attack we
present in this paper uses mainly instructions whose prices
have increased in EIP-150 or EIP-2200, but remains relatively
cheap to execute.
Improvements involve adding more layers of caches to
reduce the number of IO accesses, which are typically the bot-
tleneck. However, this requires to keep more data in memory
and therefore creates a trade-off between memory consumption
and execution speed. Regarding account lookup, two cases
must be considered: when the looked up account exists and
when it does not. Naively caching all the accounts could allow
an attacker to easily evict existing accounts from the cache
and is therefore dangerous. To check whether a particular
account exists, a Bloom ﬁlter can be utilised as a ﬁrst test.
This eliminates the need for most of the IO accesses in case
the queried address does not exist, while keeping a relatively
5Matthias Egli and Hubert Ritzdorf from PwC Switzerland
low memory footprint [43]. The next case which needs to be
handled is the fast lookup of existing accounts. The current
attempt
to do this keeps an on-disk dynamic snapshot of
the accounts state [52], which allows to perform an on-disk
look up of an account in O(1), at the cost of increasing the
storage usage of the node. This indeed solves the bottleneck
of accessing account data but is very speciﬁc to this particular
issue.
Long-term ﬁxes. Long-term ﬁxes are likely to only arrive
in Ethereum 2.0, as most of them will require major and
breaking changes. There have been several solutions discussed
by the community and other researchers, which can mostly be
categorised as either a) changing the gas pricing mechanism
or b) changing the way clients store data.
Current proposals to change the gas mechanism involve
making the pricing more dynamic that it is currently. Chen et
al. [18] propose a mechanism where contracts using a single
instruction in excess would be penalised. The threshold is
set using historical data in order to penalise only contracts
which diverge too much from what would be a regular usage.
Although the approach has some advantages over the current
pricing mechanism, it is unclear how well it would be able to
prevent attacks taking this mechanism into account.
A promising and actively researched approach is the use
of stateless clients and stateless validation. The key idea
is that instead of forcing clients to store the whole state,
entity emitting transactions must send the transaction, the data
needed by the transactions, and a proof that this data is correct.
The proof can be fairly trivially constructed as a Merkle proof,
as the block headers hold a hash of the root of the state and
the state can be represented as a Merkle tree. This allows such
clients to verify all transactions without accessing IO resources
at all, making execution and storage much cheaper, at the cost
of an increased complexity when creating transactions and a
higher bandwidth usage.
Another active area of research which should help making
things better in this direction is sharding [3]. Although shard-
ing does not address the fundamental issue of gas pricing in
the presence of IO operations, it does help to keep the state of
the nodes smaller, as different shards will be responsible for
storing the state of different parts of the network.
VI. RELATED WORK
There has been a great deal of attention focused on the
correctness of smart contracts on blockchains, especially, the
Ethereum blockchain. Some of the vulnerability types have
to do with gas consumption, but not all. There has been
relatively little attention given to the organisation of metering
for blockchain systems. We will ﬁrst present research focusing
on smart contract issues, and then highlight the work that
focuses on metering at the smart contract level. We will then
present research focusing on metering at the virtual machine
level — EVM in the case of Ethereum.
A. Smart Contracts
Major contracts vulnerabilities have been observed in re-