KEM CPAKEM
IND-CPA-secure
an
(cid:2)
1) Security under MEX attacks. One corruption pattern in
MEX attacks reveals all ephemeral secrets to the ad-
versary, including the used randomness. The motivation
for this pattern is a situation in which the protocol is
executed on a device with a subverted, or simply broken
RNG – in this case security can only be derived from
the long-term secrets that have (ideally) been generated
in a secure environment. In the above naive approach
we do not obtain any security in this scenario. The
reason is that the randomness used by CCAKEM.Enc is
corrupted and consequently, an adversary can recompute
the shared secret simply running CCAKEM.Enc.
The general approach to address this issue is to securely
combine ephemeral randomness r with some long-term
secret σ before using it as protocol input. In [58] this is
done using PRF(r, σ)⊕PRF(σ
(cid:2)) for two independent
(cid:2) and two independent long-
ephemeral values r and r
(cid:2), where ⊕ denotes exclusive
term secret values σ and σ
or. This “twisted PRF” trick ensures that nothing beyond
PRF security is required to prove this approach secure
in the standard model. In the case of WireGuard we
will see that we require a dual-prf assumption on KDF1
anyway, so we can use this assumption here as well and
simplify the construction to KDF1(σ, r).
2) Resistance to unknown-keyshare attacks. The static-
static DH is also the only line of defense in WireGuard
against unknown-keyshare attacks. This is because the
IDs (or public keys) of the two parties are not hashed
into the ﬁnal session key. As brieﬂy discussed in Sec-
tion I, WireGuard has the option to hash a pre-shared
key psk into the ﬁnal session key; by default psk is set
to the all-zero string. In PQ-WireGuard we instead set
psk to H(spki ⊕ spkr). This ensures that session keys
are linked to the static public keys of the communicating
parties and thus prevents unknown-keyshare attacks.
, r
3) Authenticated initiation. Finally,
the static-static DH
ensures that the ﬁrst message from the initiator is already
authenticated. This allows the server to detect illegiti-
mate messages at this very early stage and consequently
abort the handshake. This is not a security property in
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:30 UTC from IEEE Xplore.  Restrictions apply. 
310
COMPUTATION OF SEED VALUES, KEYS, AND HASHES THROUGH THE WireGuard HANDSHAKE. FOR VALUES OF k WITH TWO ROWS, THE FIRST ROW
DENOTES COMPUTATION ON THE INITIATOR SIDE AND THE SECOND ROW THE CORRESPONDING COMPUTATION ON THE RESPONDER SIDE.
TABLE I
seed Ck
H(lbl1)
KDF1(C1, epki)
KDF1(C2, DH.Shared(eski, spkr))
KDF1(C2, DH.Shared(sskr, epki))
KDF1(C3, DH.Shared(sski, spkr))
KDF1(C3, DH.Shared(sskr, spki))
KDF1(C4, epkr)
KDF1(C6, DH.Shared(eski, epkr))
KDF1(C6, DH.Shared(eskr, epki))
KDF1(C7, DH.Shared(sski, epkr))
KDF1(C7, DH.Shared(eskr, spki))
KDF1(C8, psk)
k
1
2
3
4
8
5 —
6
7
9
10 —
key κk
—
—
KDF2(C2, DH.Shared(eski, spkr))
KDF2(C2, DH.Shared(sskr, epki))
KDF2(C2, DH.Shared(sski, spkr))
KDF2(C2, DH.Shared(sskr, spki))
—
—
—
—
—
—
KDF3(C8, psk)
—
hash Hk
H(C1 (cid:3) lbl2)
H(H1 (cid:3) spkr)
H(H2 (cid:3) epki)
H(H2 (cid:3) epki)
H(H3 (cid:3) ltk)
H(H3 (cid:3) ltk)
H(H4 (cid:3) time)
H(H5 (cid:3) epkr)
—
—
—
—
H(H6 (cid:3) KDF2(C8, psk))
H(H9 (cid:3) zero)
the cryptographic sense, but helps mitigate easy DoS
attacks. If we follow the argumentation of [12] stating
that static public keys of WireGuard users are typically
not public and hence not known to attackers, the same
level of DoS protection is achieved by the default value
of psk = H(spki ⊕ spkr). Users who do not want to
rely on this assumption need to set psk to a secret shared
key that is agreed on out-of-band to achieve the same
level of DoS protection as in WireGuard.
Adding key conﬁrmation. As mentioned above, WireGuard
uses the ﬁrst application-data packet from the initiator for
implicit key conﬁrmation, which makes it
impossible to
prove the WireGuard handshake secure in the eCK-PFS-PSK
model. The proof in [9], just like our computational proof,
requires an explicit and separate InitConf key-conﬁrmation
message from the initiator at the end of the handshake. In
PQ-WireGuard we add this explicit key-conﬁrmation.
together. Our full proposal for the KEM-based
Putting it
PQ-WireGuard handshake is given in Algorithm 2 and Ta-
ble II. Aside from translating all DH key exchanges, except
for the static-static one, to corresponding KEM operations, we
introduce the following changes to the WireGuard handshake:
• We use calls to KDF1(σi, ri) and KDF1(σr, rr) in steps
4 and 13 of Alg. 2 to securely mix ephemeral randomness
with long-term randomness. This is precisely the coun-
termeasure against MEX attacks discussed above.
• We use H(spki ⊕ spkr) as default value for psk.
• Instead of feeding spki into AEAD.Enc in step 5, we
use H(spki). This is essentially the same trick proposed
in [12], except that we need it for a very different reason.
In [12] the reason is to add some protection against future
quantum attackers who are recording handshakes today.
For us the reason is simply a size reduction from the
potentially large public key of CCAKEM to a 32-byte
hash of this public key.
• We add the explicit key-conﬁrmation message InitConf.
Responder
$← {0, 1}32
Algorithm 2 High-level view on our PQ-WireGuard hand-
shake. Highlighted in blue are differences to Alg. 1.
Initiator
1: (eski, epki) ← CPAKEM.Gen()
2: sidi
3: ri ← {0, 1}λ
4: (ct1, shk1) ← CCAKEM.Enc(spkr, KDF1(σi, ri))
5: ltk ← AEAD.Enc(κ3, 0, H(spki), H3)
6: now ← Timestamp()
7: time ← AEAD.Enc(κ4, 0, H4, now)
8: m1 ← MAC(H(lbl3(cid:3)spkr), type(cid:3) 03(cid:3)sidi(cid:3)epki(cid:3)ct1(cid:3)ltk(cid:3)time)
9: m2 ← MAC(cookie, type (cid:3) 03 (cid:3) sidi (cid:3) epki (cid:3) ct1 (cid:3) ltk (cid:3) time (cid:3) m1)
10: InitHello ← type (cid:3) 03 (cid:3) sidi (cid:3) epki (cid:3) ct1 (cid:3) ltk (cid:3) time (cid:3) m1 (cid:3) m2
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
e, rr ← {0, 1}λ × {0, 1}λ
11:
(ct2, shk2) ← CPAKEM.Enc(epki, e)
12:
(ct3, shk3) ← CCAKEM.Enc(spki, KDF1(σr, rr))
13:
$← {0, 1}32
14:
zero ← AEAD.Enc(κ9, 0, H9, ∅)
15:
16: m1 ← MAC(H(lbl3(cid:3)spki), type(cid:3)03(cid:3)sidr(cid:3)sidi(cid:3)ct2 (cid:3) ct3(cid:3)zero)
17: m2 ← MAC(cookie, type (cid:3) 03 (cid:3) sidr (cid:3) sidi (cid:3) ct2 (cid:3) ct3 (cid:3) zero (cid:3) m1)
18: RespHello ← type (cid:3) 03 (cid:3) sidr (cid:3) sidi (cid:3) ct2 (cid:3) ct3 (cid:3) zero (cid:3) m1 (cid:3) m2
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
InitHello
RespHello
sidr
19: conf ← AEAD.Enc(κ10, 0, H10, ∅)
20: m1 ← MAC(H(lbl3 (cid:3) spkr), type (cid:3) 03 (cid:3) sidi (cid:3) sidr (cid:3) conf)
21: m2 ← MAC(cookie, type (cid:3) 03 (cid:3) sidi (cid:3) sidr (cid:3) conf (cid:3) m1)
22: InitConf ← type (cid:3) 03 (cid:3) sidi (cid:3) sidr (cid:3) conf (cid:3) m1 (cid:3) m2
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
InitConf
23:
24:
tki ← KDF1(C10, ∅)
tkr ← KDF2(C10, ∅)
IV. SECURITY ANALYSIS
We provide two proofs of security for PQ-WireGuard:
one in the computational and one in the symbolic model.
Thereby we provide the same level of security guarantees
as for WireGuard. Below we outline both proofs. In the
computational model we prove that the PQ-WireGuard hand-
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:30 UTC from IEEE Xplore.  Restrictions apply. 
311
COMPUTATION OF SEED VALUES, KEYS, AND HASHES THROUGH THE PQ-WireGuard HANDSHAKE. FOR VALUES OF k WITH TWO ROWS, THE FIRST
ROW DENOTES COMPUTATION ON THE INITIATOR SIDE AND THE SECOND ROW THE CORRESPONDING COMPUTATION ON THE RESPONDER SIDE.
TABLE II
HIGHLIGHTED IN BLUE ARE DIFFERENCES TO TABLE I.
4
5 —
6
7
seed Ck
H(lbl1)
KDF1(C1, epki)
KDF1(C2, shk1)
KDF1(C2, CCAKEM.Dec(sskr, ct1))
KDF1(C3, psk)
KDF1(C4, ct2)
KDF1(C6, CPAKEM.Dec(eski, ct2))
KDF1(C6, shk2)
KDF1(C7, CCAKEM.Dec(sski, ct3))
KDF1(C7, shk3)
KDF1(C8, psk)
KDF1(C9, ∅)
k
1
2
3
8
9
10
key κk
—
—
KDF2(C2, shk1)
KDF2(C2, CCAKEM.Dec(sskr, ct1))
KDF2(C2, psk)
—
—
—
—
—
—
KDF3(C8, psk)
KDF2(C9, ∅)
hash Hk
H(C1 (cid:3) lbl2)
H(H1 (cid:3) spkr)
H(H2 (cid:3) epki)
H(H2 (cid:3) epki)
H(H3 (cid:3) ltk)
H(H4 (cid:3) time)
H(H5 (cid:3) ct2)
—
—
—
—
H(H6 (cid:3) KDF2(C8, psk))
H(H9 (cid:3) zero)
shake, like the WireGuard handshake (with added key con-
ﬁrmation), achieves eCK-PFS-PSK-security. While certainly
on the stronger end of security notions for authenticated key-
exchange, eCK-PFS-PSK only proves session-key secrecy and
authenticity properties. Further notions that PQ-WireGuard
also targets, like identity hiding and DoS-mitigation, are not
covered by it. These additional notions are covered by the
symbolic proof. The symbolic proof not only covers addi-
tional security properties but also has the advantage of being
computer-veriﬁed. However, this comes at the cost of being
done in the symbolic model which treats all building blocks as
ideal and consequently can only provide a heuristic argument.
A. The Computational Proof
To prove that
the PQ-WireGuard handshake achieves
eCK-PFS-PSK-security, we adapt the computational proof for
WireGuard [9] by Dowling and Paterson (who kindly provided
us with their LATEX-sources) to PQ-WireGuard. The core of
this adaptation is to replace proof steps (i.e., game-hops)
making use of either the PRFODH- or the DDH-assumptions
by generic KEM-security- and prf-assumptions. Most of these
changes are straightforward and readers who are familiar with
the original proof should ﬁnd the result familiar.
On a high level both proofs consist of the same case-
distinction between whether the adversary tries to impersonate
a party or learn information about the established key and the
ways in which the adversary is allowed to corrupt parties. For
each case the proof uses a sequence of games to show that
the adversary has to either directly break the authenticity of
the AEAD-scheme for a successful impersonation attack or
distinguish two information-theoretically indistinguishable bit
strings to learn any non-trivial information about the key.
The majority of game hops are ones where the prf or
the prfswap assumptions are used. In these game-hops the
output of KDF, used to combine two intermediate values,
at
least one of which is random (which one depends on
the adversarial corruption), gets replaced by a random value.
These ”symmetric game hops” are essentially the same in the
WireGuard and the PQ-WireGuard proof.
The other major category of game hops are those where
the output of some asymmetric primitive is replaced by a
random value. For WireGuard, these are the cases where two