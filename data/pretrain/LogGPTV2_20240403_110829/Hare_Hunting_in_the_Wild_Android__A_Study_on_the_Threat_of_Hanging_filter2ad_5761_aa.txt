title:Hare Hunting in the Wild Android: A Study on the Threat of Hanging
Attribute References
author:Yousra Aafer and
Nan Zhang and
Zhongwen Zhang and
Xiao Zhang and
Kai Chen and
XiaoFeng Wang and
Xiao-yong Zhou and
Wenliang Du and
Michael Grace
Hare Hunting in the Wild Android: A Study on the Threat of
Hanging Attribute References
Yousra Aafer∗,1, Nan Zhang∗,2, Zhongwen Zhang3, Xiao Zhang1, Kai Chen2,3
XiaoFeng Wang2, Xiaoyong Zhou4, Wenliang Du1, Michael Grace4
1Syracuse University
2Indiana University, Bloomington
3SKLOIS, Institute of Information Engineering, Chinese Academy of Sciences
4Samsung Research America
{yaafer, xzhang35, wedu}@syr.edu, {nz3, xw7}@indiana.edu
{zhangzhongwen, chenkai}@iie.ac.cn, {x.zhou01, m1.grace}@samsung.com
ABSTRACT
Android is characterized by the complicated relations among its
components and apps, through which one party interacts with the
other (e.g., starting its activity) by referring to its attributes like
package, activity, service, action names, authorities and permis-
sions. Such relations can be easily compromised during a cus-
tomization: e.g., when an app is removed to ﬁt an Android version
to a new device model, while references to the app remain inside
that OS. This conﬂict between the decentralized, unregulated An-
droid customization process and the interdependency among dif-
ferent Android components and apps leads to the pervasiveness of
hanging attribute references (Hares), a type of vulnerabilities never
investigated before. In our research, we show that popular Android
devices are riddled with such ﬂaws, which often have serious secu-
rity implications: when an attribute (e.g., a package/authority/ac-
tion name) is used on a device but the party deﬁning it has been
removed, a malicious app can ﬁll the gap to acquire critical system
capabilities, by simply disguising as the owner of the attribute.
More speciﬁcally, we discovered in our research that on vari-
ous Android devices, the malware can exploit their Hares to steal
the user’s voice notes, control the screen unlock process, replace
Google Email’s account settings activity and collect or even modify
the user’s contact without proper permissions. We further designed
and implemented Harehunter, a new tool for automatic detection of
Hares by comparing attributes deﬁned with those used, and analyz-
ing the references to undeﬁned attributes to determine whether they
have been protected (e.g., by signature checking). On the factory
images for 97 most popular Android devices, Harehunter discov-
ered 21557 likely Hare ﬂaws, demonstrating the signiﬁcant impacts
of the problem. To mitigate the hazards, we further developed an
app for detecting the attempts to exploit Hares on different devices
∗The two lead authors are ordered alphabetically.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813648.
and provide the guidance for avoiding this pitfall when building
future systems.
1.
INTRODUCTION
Never before has any operating system (OS) been so popular and
diverse as Android. So far, over one billion mobile devices are run-
ning the OS, whose ofﬁcial versions (Android Open Source Project
or AOSP) have been aggressively customized into thousands of sys-
tem images by almost everyone in the production chain, hardware
manufacturers (e.g., Qualcomm), device manufacturers (e.g., Sam-
sung, LG, HTC), carriers (e.g., Verizon, AT&T, etc.) and others,
for the purposes of tailoring the OS to different hardware platforms,
countries/regions and other needs. This practice has led to a highly
fragmented ecosystem, a wild wild west when it comes to the sup-
ports for Android applications (app for short) to operate across dif-
ferent devices (e.g., phones from different manufacturers). To put
this unregulated ecosystem under control, Google has launched the
Android Compatibility Program [1] to guide the customization pro-
cess. This effort, however, fails to address a serious concern that
comes with the aggressive customization: security hazards could
arise when proper precautions have not been taken in changing the
OS and apps to ﬁt different devices.
Hares in the Wild Wild Android. For example, the manufacturer
may customize a smartphone OS for a tablet without 3G capability
by removing some components, including the messaging and tele-
phony provider apps; however, in the presence of the apps capable
of receiving SMS/MMS messages, malware on the tablet could im-
personate the missing telephony providers (using its SMS/MMS
authorities) to communicate with those apps and their users (e.g.,
cheating them into believing that their friends are sending them
messages from the VoIP channel). Fundamentally, what causes the
problem here is the intrinsic interdependent relations between dif-
ferent Android components (apps and framework services), which
connect one party to another through references to the latter’s at-
tributes such as package, activities, services names, authorities of
content providers and permissions: e.g., startActivity called
by one app to invoke another’s activity (whose name is speciﬁed
through setClassName). Customizations made to those com-
ponents, if not well thought-out, could easily break some of such
relations, resulting in the references to nonexisting attributes (e.g.,
the authorities of the SMS/MMS providers not on the tablet). We
call them hanging attribute references, or simply Hare.
1248As a side effect of the Android fragmentation, Hares could also
be brought in by the third-party developer who designs her app to
run on various Android versions, with or without certain service
components it utilizes. For example, a reference to the nonexist-
ing messaging content provider could also be embedded in a third-
party app meant to work on both the smartphone and the tablet.
Compared with the customization ﬂaws discovered in the prior re-
search, which are about misconﬁgurations of Linux-layer device
drivers [26], the hanging reference is a framework-layer issue and
potentially more pervasive, given the fact that system apps on that
layer have always been the focus of a customization [24]. How-
ever, such a problem has never been studied, whose security impli-
cations, scope and magnitude, therefore, are not clear at all.
Our ﬁndings. This new type of vulnerabilities have ﬁrst been dis-
covered in our research, which shows that they are indeed both
security-critical and extensive. More speciﬁcally, we found that a
Hare on Note 8.0 can be exploited to steal the user’s voice note and
another ﬂaw on Tab S 8.4 allows a malicious app to impersonate the
Facelock guard to gain control on the user’s login authentication.
The popular Tango app contains an unprotected reference to the
missing sms, which can be leveraged to steal the user’s messages.
Also through hijacking various packages, activities or missing con-
tent providers, the adversary is able to replace Google Email’s inter-
nal account settings interface, inject activities into LG FileManager
and LG CloudHub to steal the user’s password, and trick S-Voice
into launching a malicious program whenever the user needs to use
the pre-installed voice recorder. Moreover, on Note 3 (phone) and
Note 8.0 (tablet), a Hare related to an absent permission can be ex-
ploited to steal all the contact information (e.g., email, phone num-
ber, etc.) of the device user and even tamper with its content (e.g.,
changing a friend’s phone number, email and URL to those under
the adversary’s control), when the malicious app does not have the
privilege to do so.
To understand the scope and magnitude of the security hazards
introduced by Hares, we ran a new tool to automatically evaluate
over 97 OS images for Google, Samsung, LG, HTC and Motorola
devices. This measurement study shows that unprotected Hares
exist on every single device we tested and are completely open to
exploits. Also interestingly, we found that though such ﬂaws can
be caused by carriers and other parties, apparently they have been
primarily introduced by the manufacturers when customizing the
same OS to different device models. Further, the problems are still
pervasive even on the latest OS versions and phone models, across
different manufacturers, indicating that this security risk has yet
come to their attentions. These ﬁndings point to the gravity of such
security hazards and the urgent need to develop effective solutions
to address them. We reported the high-proﬁle Hares discovered in
our research to Google, Samsung and other related organizations,
who all acknowledged the importance of our ﬁndings. Video demos
of some attacks are posted on a private website [6].
Detection and protection. Our measurement study was made pos-
sible by Harehunter, a new tool for automatic detection of the Hare
vulnerabilities within system apps. For this purpose, Harehunter
ﬁrst performs a differential analysis, comparing all the attributes
deﬁned by the system apps on an Android image with those re-
ferred to by them. Any discrepancy between the deﬁnitions and the
references reveals a Hare risk. This instance is further evaluated
through automatic program analysis to ﬁnd out whether it is actu-
ally protected: e.g., whether a package’s signature has been veriﬁed
before its activity is invoked. If not, then the problem is reported
as a likely Hare (LHare) case. Running Harehunter on 97 popular
device images, we discovered 21557 likely Hares within 3450 vul-
nerable system apps, which have been documented in a database.
This database is utilized by a protecting app we developed, called
HareGuard, to inspect every newly installed app on these devices,
identifying the suspicious ones that attempt to exploit the Hares
there, thereby securing the device even before its manufacturer can
ﬁx the problems. Our study further evaluated the efﬁcacy and per-
formance of Harehunter and HareGuard, which were both shown
to be highly effective. We further discussed the lessons learnt from
our study and the effort that needs to be made to avoid similar prob-
lems in the development of future systems.
Contributions. The scientiﬁc contributions of the paper are out-
lined below:
• New ﬁndings. We discovered Hare, a new category of Android
vulnerabilities never known before. The problems are not iso-
lated, random bugs and actually caused by the fundamental con-
ﬂict between the under-regulated Android customization process
and the complicated interdependencies among the apps and com-
ponents on different Android systems. Our research reveals the
signiﬁcant impacts of the ﬂaws, which could lead to privilege es-
calation or information leaks on almost every popular Android
device we inspected. Given the serious consequences of the
ﬂaws once they are exploited, our research highlights the impor-
tance of incorporating proper security checks into the ongoing
effort on regulating the highly fragmented Android ecosystem.
• New techniques. We developed a set of new techniques for auto-
matically detecting Hares within different Android versions and
protecting them against exploits. These tools can be utilized by
the device manufacturers and other parties to improve the secu-
rity quality of their custom OSes. Also the Android user can
get immediate protection for her device by simply installing our
user-land app, before the manufacturers are able to ﬁx their prob-
lems. More importantly, the design of our ﬂaw detection mecha-
nism could inspire the follow-up research on automatic recovery
of the interdependent relations on different OS versions to sup-
port a securer customization process.
• Implementation and evaluation. We implemented Harehunter
and HareGuard, and evaluated them on a large number of cus-
tomized Android versions.
Roadmap. The rest of the paper is organized as follow: Section 2
introduces the background of our study; Section 3 elaborates differ-
ent Hare ﬂaws and their security implications through a few high-
proﬁle examples; Section 4 describes our detection and protection
techniques, and our large-scale measurement study using the tool;
Section 5 discusses the lessons learnt from our study; Section 6
compares our work with related prior research and Section 7 con-
cludes the whole paper.
2. BACKGROUND
Android Fragmentation. As mentioned earlier, the AOSP base-
lines have been intensively customized by different parties. For
each new version released by Google, hardware manufacturers such
as Qualcomm ﬁrst change the OS to support their products, and
then the device manufacturers like Samsung, LG and HTC mod-
ify the version to enrich its functionalities and tailor it to different
devices (phones, tablets for different languages, countries/regions,
etc.). This customization process continues when the devices reach
carriers, such as Verizon and AT&T, which revise services or add
in new apps to distinguish their phones or tablets from those of oth-
ers. Further complicating the situation is Android upgrades: since
September 2008, 21 ofﬁcial versions (from 1.0 to 5.1) have been
1249released; such rapid updates outpace the distribution of the hard-
ware platforms capable of supporting the new systems. As a result,
a large number of custom Android systems have been built (over
10,000 for Samsung alone), and many of them, at various version
levels, co-exist in today’s market.
Prior research shows that the most heavily-customized compo-
nents are actually a device’s pre-installed apps. As an example, a
study found that across the smartphones produced by major device
manufacturers (Samsung, HTC, LG, Sony), only 18% of the pre-
installed apps were from their corresponding AOSP baselines, 65%
from the manufacturers and 17% added there by other parties such
as carriers [24]. Although it has been reported that some of these
apps contain known vulnerabilities, such as re-delegation [13], con-
tent leaks [15] and permission overprivilege [12], little has been
done to understand whether new, customization-speciﬁc security
ﬂaws have also been introduced, which our study aimed at.
Attribute reference and Android security model. Different An-
droid components (apps or their internal activities, services, con-
tent providers, receivers, etc.) are connected together by Inter-
Component Communication (ICC), such as Intent messaging. An
Intent is a message that describes the operations to be performed
by the recipient: for example, startActivity that triggers an
activity (a set of user-interface related operations) associated with
an app. The app’s package name and activity name can be speciﬁed
through the Intent, using the method setPackage, setClassNa
me, setComponent, etc. Here the reference from one com-
ponent to another happens through the latter’s attributes, i.e., the
package name and activity name. When these attributes have not
been set for the communication, the Intent is implicit and needs
to be resolved by the OS to locate the recipient capable of han-
dling it. In this case, the sender needs to provide an action (e.g.,
android.intent.action.Edit through setAction) and
other parameters (such as data), and the recipient is supposed to de-
clare an Intent ﬁlter for its component (activity, service, receiver)
that matches these parameters in order to get the Intent. Another
important Android component is content provider, which manages
access to an app’s databases (structured datasets). To operate on
another app’s content provider, one must get an URI “content:
//authorityname/path”, through which the database table
corresponding to the path can be read (query) and written (e.g.,
insert), under the consent of its owner. In all such ICC commu-
nication, once the target of a reference (e.g., package name, activity
name, action name and authority name) is not present on the same
system, the reference becomes hanging, which can have serious se-
curity implications (Section 3).
Android protects its information assets through an application-
sandbox and permission model, in which every app runs within its
own compartment (enforced through the Linux user protection) and
can only access sensitive global resources and other app’s compo-
nents (content provider, service, activity, broadcast receiver) with
proper permissions. More speciﬁcally, the app can specify for each
of its components a permission and only process the message or
service request from the parties with the permission. For example,
a content provider can be guarded with a readPermission and
a writePermission; a broadcast receiver can be conﬁgured to
get the message only from those with a speciﬁc permission. Such
permission protection is mostly set statically within an app’s man-
ifest ﬁle, but it can also be speciﬁed programmatically, using the
APIs like checkPermission. An app that wants to obtain such
a permission needs to ask for the user’s consent. However, when
the party that deﬁnes such a permission does not exist on a cus-
tom version, the permission protection becomes hanging: anyone
that deﬁnes the permission can silently gain the privilege to access
protected app components.
Adversary Model. We consider a scenario where a malicious app
has been installed on the target device. However, the app does not
need to have any suspicious permissions. Actually, in the case of
hanging permission protection, it can deﬁne the missing permission
by its own to launch all kinds of attacks. To deliver the information
stolen from the device, the app needs the communication capability.
This can be done explicitly by asking for the network permission,
which has been requested by almost all apps. Alternatively, the
malicious app can utilize other channels, such as browser, to send
the data out, as demonstrated in the prior work [8].
3. EXPLOITING HARES
As mentioned earlier, a hanging attribute reference could be an
ICC call to a nonexisting package, activity, service (which could
be implicitly speciﬁed by the action or data ﬁlters) or authority of
a content provider, or the use of a missing permission to protect
an app component (service, activity, broadcast receiver and con-
tent provider). In the presence of such a reference, a malicious app
that claims its target attribute could gain access to the information
assets exposed by the ICC or guarded by the permission. More
speciﬁcally, when the reference is not guarded along the execu-
tion path involving the Hare, that is, no validation of the existence
and legitimacy of the attribute before using it, the malware that
acquires the attribute (e.g. package/authority/permission name) au-
tomatically obtains the privilege associated with the attribute and
becomes entitled to get sensitive messages from the sender, utilize
its component, etc. Examples of the attacks are presented in the
rest of the section.
It is important to note that not every hanging reference is ex-
ploitable. It can be protected by verifying the existence of the pack-
age that supposes to deﬁne it and then verifying its signature (ex-
tracted through getPackageInfo with ﬂag GET_SIGNATURE
S), or its application info FLAG_SYSTEM, or by checking the cur-
rent device’s model, country code or other properties (e.g. getPro
perty). The presence of such protection was identiﬁed in our