ory using only software) as the technique to inject errors.
This is a general technique that is not attached to any speciﬁc
microprocessor. The injection of an error is triggered by
a software breakpoint, which is placed at the instruction
identifying the time instant when the error should be in-
jected. The software breakpoint is inserted by replacing the
instruction at the breakpoint address in the target program
with an instruction to branch to a fault injection routine. The
routine keeps track of the number of invocations, and injects
the error when the speciﬁed invocation count is reached.
The original instruction, which is replaced by the branch
instruction, is executed in the instrumentation routine.
Compared with other techniques, our implementation of
instrumentation-based injection provides low spatial intru-
siveness and low to medium temporal
intrusiveness [7].
As discussed in [15], other techniques such as exception-
based injection may have lower temporal intrusiveness, and
may therefore be used as a complement. However, our
observation is that instrumentation-based injection has very
low temporal intrusiveness in the vast majority of exper-
iments. Furthermore,
the additional machine instructions
are executed in the context of the faulty task. Hence, the
SWIFI technique’s temporal intrusiveness in the fault-free
tasks can be expected to be very low. A benchmark user
may nonetheless execute the target system with the fault
injector installed but not activated, to measure the actual
intrusiveness.
Regarding the faultload based on software faults, we used
a software fault injection tool that mutates the source code of
the applications [16]. Thus, the workloads were recompiled
for each fault injection experiment. One may alternatively
use fault
injectors capable of emulating software faults
directly into the binary code of the application.
C. Experimental Results
The three benchmark targets were evaluated through a set
of fault injection campaigns, separated into hardware faults
and software faults, as speciﬁed in Section III. Each target
had three distinct workload conﬁgurations: Altimeter with
Hamdist, Altimeter with CRC32, and CRC32 with Hamdist.
In each conﬁguration, faults were injected into one of the
two workloads, to determine if partitioning would prevent
propagation to the other partition.
Table I shows the results of the evaluation of the basic
scheduler. The ﬁrst
two columns identify the workload
conﬁgurations, including which of the workloads had faults
injected into it – those marked with (f). For each of the three
conﬁgurations, we injected single bit-ﬂips into processor
registers and memory. We can observe that only a fraction
of the injected faults became activated (according to our
deﬁnition, a fault injected into one workload is activated
if any workload produces results differing from the golden
run).
Out of those faults that were activated, we can observe
in Table I that a large proportion is able to propagate to the
fault-free partition, i.e., partitioning is violated. Moreover,
we can observe that the number of spatial violations is
nearly identical to the number of temporal violations. A
careful analysis showed that in most of the experiments in
which partitioning was violated, both the logical value and
the timing of the output were affected. In fact, the same
observation could be made for the other benchmark targets
as well.
The ﬁnal score for all hardware faults is computed taking
the arithmetic mean of register errors and memory errors.
This results in 61.42% of the activated faults to violate
spatial partitioning and 60.91% to violate temporal parti-
tioning, for the basic scheduler as benchmark target. Since,
after deployment, errors affecting processor registers and
memory may have distinct frequencies, the ﬁnal score may
be less meaningful than the individual results for memory
and registers. Nevertheless,
the ﬁnal score allows us to
compare different targets with fairness in their ability to
handle both kinds of error.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:27:15 UTC from IEEE Xplore.  Restrictions apply. 
GOOFIOn-board Nexus debuggerUSBMPC5554 runningC/OS-II and SECERNNexus425PARTITIONING VIOLATIONS FOR HARDWARE FAULTS TARGETING THE BASIC SCHEDULER.
Table I
Workloads
High priority
Altimeter (f)
Altimeter
CRC32
Low priority
Injected
Activated
Hamdist
CRC32 (f)
Hamdist (f)
94
93
100
6
4
6
Register faults
Spatial violation
1 (16.67%)
4 (100%)
3 (50%)
Temporal violation
Injected
Activated
1 (16.67%)
4 (100%)
3 (50%)
95
94
100
27
39
33
Memory faults
Spatial violation
19 (70.37%)
17 (43.59%)
29 (87.88%)
Temporal violation
Spatial violation
Temporal violation
Average for all hardware faults
19 (70.37%)
17 (43.59%)
28 (84.85%)
Average
43.52%
71.79%
68.94%
61.42%
43.52%
71.79%
67.42%
60.91%
PARTITIONING VIOLATIONS FOR HARDWARE FAULTS TARGETING µC/OS-II WITHOUT PARTITIONING.
Table II
Workloads
High priority
Altimeter (f)
Altimeter
CRC32
Low priority
Injected
Activated
Hamdist
CRC32 (f)
Hamdist (f)
93
96
100
9
9
12
Register faults
Spatial violation
6 (66.67%)
7 (77.78%)
10 (83.33%)
Temporal violation
Injected
Activated
6 (66.67%)
6 (66.67%)
9 (75%)
90
93
100
0
2
1
Memory faults
Spatial violation
0 (–)
1 (50%)
0 (0%)
Temporal violation
Spatial violation
Temporal violation
Average for all hardware faults
0 (–)
1 (50%)
1 (100%)
Average
66.67%
63.89%
41.67%
57.41%
66.67%
58.33%
87.5%
70.83%
PARTITIONING VIOLATIONS FOR HARDWARE FAULTS TARGETING µC/OS-II WITH SECERN.
Table III
Workloads
High priority
Altimeter (f)
Altimeter
CRC32
Low priority
Injected
Activated
Hamdist
CRC32 (f)
Hamdist (f)
89
95
100
6
8
6
Register faults
Spatial violation
2 (33.33%)
0 (0%)
0 (0%)
Temporal violation
Injected
Activated
2 (33.33%)
0 (0%)
0 (0%)
98
90
100
2
2
0
Memory faults
Spatial violation
2 (100%)
0 (0%)
0 (–)
Temporal violation
Spatial violation
Temporal violation
Average for all hardware faults
2 (100%)
0 (0%)
0 (–)
Average
66.67%
0%
0%
22.22%
66.67%
0%
0%
22.22%
The results of µC/OS-II without partitioning, for hardware
faults, are shown in Table II. We can observe that the ﬁnal
average for all hardware faults is comparable to that of the
basic scheduler. However, the proportion of activated mem-
ory faults is fairly low, thereby decreasing the conﬁdence in
this result. In such cases it is appropriate to inject a larger set
of errors. Averaging register faults and memory faults results
in 57.41% of activated faults causing spatial violation and
70.83% causing temporal violation.
Regarding µC/OS-II with Secern, one may observe in
Table III that it provides better partitioning than the other
two benchmark targets. However, there are a few faults
that propagate from the faulty partition to the fault-free
partition, meaning that not all faults are contained by Secern.
On average, 22.22% of the activated faults violate spatial
partitioning, and the same proportion violates temporal par-
titioning. In Section V we examine the causes for this and
identify two issues in which Secern required improvement.
The partitioning coverage of the three benchmark targets
was evaluated with respect
to software faults. Table IV
summarizes the outcomes of the fault injection campaigns
targeting the basic scheduler. We can observe that most
of the software faults injected into the workload marked
with (f) are activated, thereby having some impact on the
system. Spatial violations and temporal violations occur
only in the conﬁguration where faults are injected into the
CRC32 workload, and propagate to the Altimeter. Taking
the average of the three workload conﬁgurations, the basic
scheduler allows 7.41% of the activated software faults to
violate spatial partitioning and the same proportion to violate
temporal partitioning.
The campaigns targeting µC/OS-II without partitioning
provided nearly identical results as for the basic scheduler.
As we can observe in Table V, the difference is in the
number of activated faults, while the proportion of activated
faults leading to partitioning violation is the same (2 cases
out of 9 activated software faults in the conﬁguration running
the Altimeter and the CRC32 workloads). The average result
for µC/OS-II without partitioning is equal to that of the basic
scheduler – 7.41% of the activated software faults propagate
to the fault-free workload, both in the spatial and in the
temporal domain.
The last set of campaigns corresponds to the injection of
software faults to evaluate µC/OS-II with Secern. Perhaps
surprisingly, Secern failed to contain a fairly high proportion
of faults, resulting in a score comparable to that of the
other two benchmark targets (which have no partitioning
mechanisms). As we can see in Table VI, spatial violations
occur in two cases, resulting in an average score of 8.47%,
and in one case there is a temporal violation, resulting in a
score of 4.76%. Consequently, the benchmarked version of
Secern can still be improved. We discuss this issue in detail
in Section V.
The measured partitioning coverage for the three bench-
mark targets, regarding software and hardware faults,
is
summarized in Table VII. The two main metrics – PCs
and PCt – are calculated by subtracting the proportion of
violations from one hundred percent. That is, the proportion
of covered faults equals one minus the proportion of non-
covered faults.
As one may observe in Table VII, µC/OS-II with Secern
ranks ﬁrst in the partitioning coverage – both temporal and
spatial. The other two targets are ranked closely to one
another, with an advantage in terms of spatial partitioning
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:27:15 UTC from IEEE Xplore.  Restrictions apply. 
426PARTITIONING VIOLATIONS FOR SOFTWARE FAULTS TARGETING THE BASIC SCHEDULER.
Table IV
High priority
Altimeter (f)
Altimeter
CRC32
Workloads
Low priority
Injected
Activated
Software faults
Spatial violation
Temporal violation
Hamdist
CRC32 (f)