straightforward (we instrument the program to dynamically
check if the index is within the bounds of the array), we do
static analysis to determine how to instrument indirect ac-
cesses to an array. This means that our bounds checker will
not ﬁnd all cases of such accesses, but since we’re only in-
terested in reducing the risk of already unlikely attack vec-
tors (like arrays of pointers), this is acceptable. Because
most programs do not operate heavily on these unlikely
vectors, the performance overhead of adding this type of
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006bounds checking will likely be low.
If this selective bounds checker is applied to reduce the
amount of stacks to two, it could be realistic to reserve a
register as a stack pointer for this second stack. This would
allow us to place this second stack anywhere in memory
which would solve both the ﬁxed stack size problem, the
incompatibility with ASLR and would eliminate the gaps.
However, a possible performance overhead will probably
be incurred because this extra register must be modiﬁed in
much the same way as the original stack pointer.
One vulnerability that is present in existing countermea-
sures, that we did not address in our countermeasure either
is the fact that a structure can contain both a pointer and
an array of characters, giving the attacker the possibility to
overwrite this pointer using the array of characters. The
same is true for memory allocated with alloca (it can be used
to store array of characters and pointers). This is an impor-
tant limitation, however, this type of vulnerability does not
occur often in practice, so the limitation is unlikely to sig-
niﬁcantly undermine the protection.
A non-control data attack [9] that relies on modifying a
character array would still work, but is severely limited to
only being able to overwrite character arrays.
Our approach also does not detect when a buffer over-
ﬂow has occurred.
It is, however, possible to easily and
efﬁciently add such detection as an extension to our imple-
mentation by using the technique used by StackGuard and
Propolice of placing a random number on the stack and ver-
ifying it before returning from the function. This canary
would be placed on every stack and compared to the value
stored on the ﬁrst stack before returning. Since the random
number is mirrored, we can also use a per function canary,
rather than a global one, reducing the risk of an attacker
discovering one random number and using it to circumvent
the detection in another function. If an attacker does dis-
cover the value, the countermeasure will no longer be able
to perform detection, but it will not be circumvented, be-
cause only the detection and not the security relies on it.
6 Related work
Many countermeasures against code injection attacks ex-
ist.
In this section, we brieﬂy describe the different ap-
proaches that could be applicable for protecting against
buffer overﬂows. The focus is more on the countermea-
sures which are designed speciﬁcally to protect the stack
from stack-smashing attacks.
6.1 Protection from attacks on stack-
based vulnerabilities
Because the stack-based buffer overﬂow is a very
widespread vulnerability, many countermeasures have been
designed to protect against attacks on the stack. In this sec-
tion we discuss the countermeasures which are most closely
related to our countermeasure.
Two related countermeasures, StackGuard [12] and
Propolice [13] were both discussed in section 2. They rely
on random values that must remain secret to provide protec-
tion.
Stack Shield [29] is a countermeasure that attempts to
protect against stack smashing attacks by copying the re-
turn address to another memory location, before entering
the function call and restoring it just before returning from
the function. This is an efﬁcient countermeasure and will
protect the return address from attack, but will still allow an
attacker to use indirect pointer overwriting [8] to bypass the
protection.
RAD [10] is similar to Stack Shield, except that it com-
pares the return addresses stored at both locations and will
terminate the program if they are different. It solves some
compatibility problems of Stack Shied and also better pro-
tects the area where the return addresses are copied to.
However, it will still only protect return addresses and, thus,
could be bypassed using indirect pointer overwriting.
Xu et al. [31] suggest a similar approach to Stack Shield.
Their countermeasure splits the stack into a control and a
data stack. The control stack stores the return addresses
while the data stack contains the rest of the data stored on
the stack. Their implementation copies the return address
to the the control stack before entering the function call and
copies it back from the control stack onto the data stack be-
fore returning from the function. The authors provide per-
formance results for the SPEC CPU2000 benchmarks, the
performance overheads associated with this approach range
from 0.01% for 181.mcf to 23.77% for 255.vortex.
Libverify [5] offers the same kind of protection as Stack
Shield: upon entering a function it saves the return address
on a return address stack (that it calls a canary stack) and
when exiting from a function the saved return address is
compared to the actual return address. The main difference
with Stack Shield lies in the way that this check is added:
Libverify does not require access to the source code of the
application, the checks are added by dynamically linking
the process with the library at run-time.
Libsafe [5] replaces the string manipulation functions
that are prone to misuse with functions that prevent a buffer
from being overﬂown outside its stackframe. This is done
by calculating the size of the input string and then mak-
ing sure that the size of the source string is less than the
upper bound of the destination string (the space from the
variable’s stack location to the saved frame pointer). If it
is not smaller, the program will be terminated. Again, as is
the case with several other countermeasures, this protection
can be bypassed using indirect pointer overwriting.
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 20066.2 Alternative approaches
6.2.3 Execution monitoring
Other approaches that protect against the more general
problem of buffer overﬂows also protect against stack-based
buffer overﬂows. In this section, we give a brief overview
of this work.
6.2.1 Compiler-based countermeasures
Bounds checking [17, 4, 15, 21, 23, 24, 32] is the ideal
solution for buffer overﬂows, however, performing bounds
checking in C can have a severe impact on performance
or may cause existing object code to become incompatible
with bounds checked object code.
Protection of all pointers as provided by PointGuard [11]
is an efﬁcient implementation of a countermeasure that will
encrypt (using XOR) all pointers stored in memory with
a randomly generated key and decrypts the pointer before
loading it into a register. To protect the key, it is stored
in a register upon generation and is never stored in mem-
ory. However, attackers could guess the decryption key if
they were able to view several different encrypted pointers.
Another attack described in [3] describes how an attacker
could bypass PointGuard by partially overwriting a pointer.
By only needing a partial overwrite, the randomness can be
reduced, making a brute force attack feasible (1 byte: 1 in
256, 2 bytes: 1 in 65536, instead of 1 in 232).
6.2.2 Operating system-based countermeasures
Non-executable memory [26, 28] tries to prevent code injec-
tion attacks by ensuring that the operating system does not
allow execution of code that is not stored in the text segment
of the program. This type of countermeasure can, however,
be bypassed by a return-into-libc attack [30] where an at-
tacker executes existing code (possibly with different pa-
rameters).
Randomized instruction sets [6, 16] also try to prevent
an attacker from executing injected code by encrypting in-
structions on a per process basis while they are in memory
and decrypting them when they are needed for execution.
However, software based implementations of this counter-
measure incur large performance costs, while a hardware
implementation is not immediately practical. Determined
attackers may also be able to guess the encryption key and,
as such, be able to inject code [27].
Address randomization [28, 7] is a technique that at-
tempts to provide security by modifying the locations of
objects in memory for different runs of a program, how-
ever, the randomization is limited in 32-bit systems (usually
to 16 bits for the heap) and as a result may be inadequate
for a determined attacker [25].
In this section we describe two countermeasures that will
monitor the execution of a program and will prevent trans-
ferring control-ﬂow which could be unsafe.
Program shepherding [18] is a technique that will mon-
itor the execution of a program and will disallow control-
ﬂow transfers7 that are not considered safe. Program shep-
herding can be used for example to ensure that programs can
only jump to entry points of functions or libraries, denying
an attacker the possibility of bypassing checks that might
be performed before a certain action is taken in a function.
Another example of a use for program shepherding is to en-
force return instructions to only return to the instruction af-
ter the call site. The proposed implementation of this coun-
termeasure is done using a runtime binary interpreter, as a
result the performance impact of this countermeasure is sig-
niﬁcant for some programs, but acceptable for others.
Control-ﬂow integrity [1] determines a program’s con-
trol ﬂow graph beforehand and ensures that the program
adheres to it. It does this by assigning a unique ID to each
possible control ﬂow destination of a control ﬂow transfer.
Before transferring control ﬂow to such a destination, the
ID of the destination is compared to the expected ID, and
if they are equal, the program proceeds as normal. Perfor-
mance overhead may be acceptable for some applications,
but may be prohibitive for others.
7 Conclusion
In this paper we described a countermeasure that pro-
tects against stack-based buffer overﬂows which has neg-
ligible performance overhead, while solving some of the
shortcoming of existing efﬁcient countermeasures. We as-
sign all the different data types stored on the stack a high,
medium or low ranking, both for the risk of it being an at-
tack vector and the value it has as a possible target. Using
this information we assigned the data on the stack to differ-
ent categories. Each of these categories was then mapped
onto a separate stack. This effectively separated high-value
targets from data which has a high risk of being used to
launch an attack. A straight mapping of categories resulted
in an implementation which has a very low performance
overhead and offers better protection than existing counter-
measures. However, the memory usage in our implemen-
tation is higher than most other countermeasures, and we
discuss possible ways to reduce it. One of the important ad-
vantages of our approach over existing approaches, is that
it does not rely on the secrecy of canaries. Our counter-
measure remains secure even if an attacker is able to read
arbitrary memory locations.
7Such a control ﬂow transfer occurs when e.g. a call or ret instruction
is executed.
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006References
[1] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti. Control-
ﬂow integrity. In Proc. of the 12th ACM Conf. on Computer
and Communications Security, Alexandria, VA, Nov. 2005.
[2] Aleph One. Smashing the stack for fun and proﬁt. Phrack,
49, 1996.
[3] S. Alexander. Defeating compiler-level buffer overﬂow pro-
tection. ;login: The USENIX Magazine, 30(3), June 2005.
[4] T. M. Austin, S. E. Breach, and G. S. Sohi. Efﬁcient detec-
tion of all pointer and array access errors. In Proc. of the
ACM SIGPLAN ’94 Conf. on Programming Language De-
sign and Implementation, Orlando, FL, June 1994.
[5] A. Baratloo, N. Singh, and T. Tsai. Transparent run-time
In USENIX 2000
defense against stack smashing attacks.
Annual Technical Conf. Proc., San Diego, CA, June 2000.
[6] E. G. Barrantes, D. H. Ackley, S. Forrest, T. S. Palmer,
D. Stefanovi´c, and D. D. Zovi. Randomized instruction set
emulation to disrupt binary code injection attacks. In Proc.
of the 10th ACM Conf. on Computer and Communications
Security, Washington, DC, Oct. 2003.
[7] S. Bhatkar, D. C. DuVarney, and R. Sekar. Address obfus-
cation: An efﬁcient approach to combat a broad range of
memory error exploits. In Proc. of the 12th USENIX Secu-
rity Symp., Washington, DC, Aug. 2003.
[8] Bulba and Kil3r. Bypassing Stackguard and stackshield.
Phrack, 56, 2000.
[9] S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer. Non-
control-data attacks are realistic threats. In Proc. of the 14th
USENIX Security Symp., Baltimore, MD, Aug. 2005.
[10] T. Chiueh and F.-H. Hsu. RAD: A compile-time solution to
In Proc. of the 21st Int. Conf. on
buffer overﬂow attacks.
Distributed Computing Systems, Phoenix, AZ, Apr. 2001.
[11] C. Cowan, S. Beattie, J. Johansen, and P. Wagle. Point-
Guard: protecting pointers from buffer overﬂow vulnerabil-
ities. In Proc. of the 12th USENIX Security Symp., Washing-
ton, DC, Aug. 2003.
[12] C. Cowan, C. Pu, D. Maier, H. Hinton, J. Walpole, P. Bakke,
S. Beattie, A. Grier, P. Wagle, and Q. Zhang.
Stack-
Guard: Automatic adaptive detection and prevention of
buffer-overﬂow attacks. In Proc. of the 7th USENIX Security
Symp., San Antonio, TX, Jan. 1998.
[13] H. Etoh and K. Yoda. Protecting from stack-smashing at-
tacks. Technical report, IBM Research Divison, Tokyo Re-
search Laboratory, June 2000.
[14] J. L. Henning. Spec cpu2000: Measuring cpu performance
in the new millennium. Computer, 33(7), July 2000.
[15] R. W. M. Jones and P. H. J. Kelly. Backwards-compatible
bounds checking for arrays and pointers in C programs. In
Proc. of the 3rd Int. Workshop on Automatic Debugging,
Link¨oping, Sweden, 1997.
[16] G. S. Kc, A. D. Keromytis, and V. Prevelakis. Countering
code-injection attacks with instruction-set randomization. In
Proc. of the 10th ACM Conf. on Computer and Communica-
tions Security, Washington, DC, Oct. 2003.
[17] S. C. Kendall. Bcc: Runtime checking for C programs. In
Proc. of the USENIX Summer 1983 Conf., Toronto, ON, July
1983.
[18] V. Kiriansky, D. Bruening, and S. Amarasinghe. Secure
In Proc. of the 11th
execution via program shepherding.
USENIX Security Symp., San Francisco, CA, Aug. 2002.
[19] klog. The frame pointer overwrite. Phrack, 55, 1999.
[20] R. B. Lee, D. K. Karig, J. P. McGregor, and Z. Shi. Enlisting
hardware architecture to thwart malicious code injection. In
Proc. of the First Int. Conf. on Security in Pervasive Com-
puting, volume 2802 of LNCS, 2003.
[21] K.-S. Lhee and S. J. Chapin. Type-assisted dynamic buffer
overﬂow detection. In Proc. of the 11th USENIX Security
Symp., San Francisco, CA, Aug. 2002.
[22] National Institute of Standards and Technology. National
vulnerability database statistics. http://nvd.nist.
gov/statistics.cfm.
[23] Y. Oiwa, T. Sekiguchi, E. Sumii, and A. Yonezawa. Fail-
safe ANSI-C compiler: An approach to making C programs
secure: Progress report. In Proc. of Int. Symp. on Software
Security 2002, Tokyo, Japan, Nov. 2002.
[24] O. Ruwase and M. S. Lam. A practical dynamic buffer over-
ﬂow detector. In Proc. of the 11th Annual Network and Dis-
tributed System Security Symp., San Diego, CA, Feb. 2004.
[25] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu,
and D. Boneh. On the Effectiveness of Address-Space Ran-
domization. In Proc. of the 11th ACM Conf. on Computer
and communications security, Washington, DC, Oct. 2004.
[26] Solar Designer. Non-executable stack patch. http://
www.openwall.com.
[27] N. Sovarel, D. Evans, and N. Paul. Where’s the FEEB?
the effectiveness of instruction set randomization. In Proc.
of the 14th USENIX Security Symp., Baltimore, MD, Aug.
2005.
[28] The PaX Team. Documentation for the PaX project. http:
//pageexec.virtualave.net/docs/.
[29] Vendicator. Stack shield. http://www.angelfire.
com/sk/stackshield.
[30] R. Wojtczuk. Defeating Solar Designer’s Non-executable
Stack Patch. Bugtraq mailinglist, 1998.
[31] J. Xu, Z. Kalbarczyk, S. Patel, and K. I. Ravishankar. Ar-
chitecture support for defending against buffer overﬂow at-
tacks. In Second Workshop on Evaluating and Architecting
System dependabilitY, San Jose, CA, Oct. 2002.
[32] W. Xu, D. C. DuVarney, and R. Sekar. An Efﬁcient and
Backwards-Compatible Transformation to Ensure Memory
Safety of C Programs. In Proc. of the 12th ACM SIGSOFT
Int. Symp. on Foundations of Software Engineering, New-
port Beach, CA, October-November 2004.
[33] Y. Younan, W. Joosen, and F. Piessens. Code injection in
C and C++ : A survey of vulnerabilities and countermea-
sures. Technical Report CW386, Departement Computer-
wetenschappen, Katholieke Universiteit Leuven, July 2004.
[34] Y. Younan, W. Joosen, and F. Piessens. A methodology for
designing countermeasures against current and future code
injection attacks. In Proc. of the Third IEEE Int. Information
Assurance Workshop 2005, College Park, MD, Mar. 2005.
[35] Y. Younan, W. Joosen, and F. Piessens. Efﬁcient protec-
tion against heap-based buffer overﬂows without resorting
to magic. In Proc. of the Int. Conf. on Information and Com-
munication Security, Raleigh, NC, Dec. 2006.
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006