# Title: Towards Paving the Way for Large-Scale Windows Malware Analysis: Generic Binary Unpacking with Orders-of-Magnitude Performance Boost

## Authors:
- Binlin Cheng, Wuhan University & Hubei Normal University, Wuhan, Hubei 430072, China
- Jiang Ming, University of Texas at Arlington, Arlington, TX 76019, USA
- Jianming Fu, Wuhan University, Wuhan, Hubei 430072, China
- Guojun Peng, Wuhan University, Wuhan, Hubei 430072, China
- Ting Chen, University of Electronic Science and Technology of China, Chengdu, Sichuan 611731, China
- Xiaosong Zhang, University of Electronic Science and Technology of China, Chengdu, Sichuan 611731, China
- Jean-Yves Marion, Université de Lorraine, CNRS, LORIA, F-54000 Nancy, France

## Abstract
Binary packing, which involves encoding binary code before execution and decoding it at runtime, is a common obfuscation technique used by malware authors to conceal malicious code. Most packers use a series of "written-then-executed" layers to recover the original code, making it increasingly difficult to determine the end of the unpacking process. Many generic binary unpacking approaches have been proposed to extract packed binaries without prior knowledge of the packers. However, these approaches often suffer from high runtime overhead and lack of anti-analysis resistance, limiting their practical adoption. This paper revisits the binary unpacking problem from a new perspective: packers consistently obfuscate the standard use of API calls. Our in-depth study of various Windows malware packers reveals a common property: the Import Address Table (IAT) of the malware, which acts as a lookup table for dynamically linked API calls, is typically erased by packers for further obfuscation. The unpacking routine then reconstructs the IAT before the original code resumes execution. If an API is invoked through a rebuilt IAT during the execution of packed malware, it indicates that the original payload has been restored. This insight motivates the design of BinUnpack, an efficient unpacking approach. Unlike previous methods that monitor multiple "written-then-executed" layers, BinUnpack avoids tedious memory access monitoring, resulting in significantly lower runtime overhead. To counter evolving evasion techniques, BinUnpack's API monitor module uses a novel kernel-level DLL hijacking technique. We evaluated BinUnpack with over 238,000 packed malware samples and several Windows utilities, demonstrating its superior success rate and performance compared to existing tools.

## CCS Concepts
- **Security and privacy** → Software reverse engineering

## Keywords
- Windows Malware Analysis
- Generic Binary Unpacking
- Import Address Table
- Kernel-level DLL Hijacking

## ACM Reference Format
Binlin Cheng, Jiang Ming, Jianming Fu, Guojun Peng, Ting Chen, Xiaosong Zhang, and Jean-Yves Marion. 2018. Towards Paving the Way for Large-Scale Windows Malware Analysis: Generic Binary Unpacking with Orders-of-Magnitude Performance Boost. In *CCS '18: 2018 ACM SIGSAC Conference on Computer & Communications Security*, Oct. 15–19, 2018, Toronto, ON, Canada. ACM, New York, NY, USA, 17 pages. https://doi.org/10.1145/3243734.3243771

## 1 Introduction
Malicious software (malware) poses a significant threat to cybersecurity, with major attacks like ransomware causing widespread damage. Driven by financial incentives, cyber-criminals employ various obfuscation techniques to evade detection and analysis. Binary packing, which encodes malware code and attaches an unpacking routine, is a widely used method to thwart antivirus scanning. Packers also erase the Portable Executable (PE) file’s import address table (IAT) to complicate the analysis of API calls. When a packed malware runs, the unpacking routine decodes the payload and reconstructs the IAT, allowing the malware to invoke Windows APIs. This makes the actual malicious code unrecognizable until runtime, evading static analysis techniques. For example, machine learning applied to large-scale packed malware often detects packers rather than malicious behavior. Additionally, many antivirus scanners incorrectly identify packed system files as malware. 

Binary packing has evolved from simple, single-layer packers to complex, multi-layer packers with various anti-analysis tricks. The "written-then-executed" procedure can iterate multiple times, making it challenging to determine the end of the unpacking process. Existing generic unpacking tools track this behavior but suffer from high runtime overhead and are susceptible to evasion techniques. Sophisticated packers use anti-analysis methods such as debugging, dynamic binary instrumentation, and API hooking, which can be detected and bypassed by evasive packers.

In this paper, we present BinUnpack, a new generic unpacking approach based on the observation that packers consistently obfuscate API call resolution. Our approach captures the "rebuilt-then-called" behavior, where an API call through a rebuilt IAT indicates the restoration of the original code. BinUnpack hooks API calls and locates the original entry point (OEP) efficiently, avoiding the overhead of multi-layer unpacking. To counter evasion, BinUnpack uses a hybrid, kernel-level DLL hijacking technique, enabling it to resist various anti-analysis tricks. We evaluated BinUnpack with over 238,000 packed malware samples and common Windows utilities, demonstrating its high success rate and significant performance improvement over existing tools.

### Scope and Contributions
- **New Generic Solution**: We propose a new, generic solution to quickly determine the end of unpacking by capturing the "rebuilt-then-called" behavior, free from heavy memory access tracing.
- **Novel Technique**: We design a novel, hybrid kernel-level DLL hijacking technique, enabling more powerful unpacking capability.
- **Extensive Evaluation**: We evaluate BinUnpack with large-scale datasets, including almost all available Windows malware packers, and demonstrate consistent good results across various packers and potential attacks.

## 2 Background and Motivation
### 2.1 The Status Quo of Generic Unpacking
Existing generic unpacking approaches suffer from high overhead and lack of anti-analysis resistance. Multi-layer packers, which repeat the "written-then-executed" process, make it challenging to determine the end of unpacking. Traditional methods rely on heavy memory access tracing and heuristics, leading to high runtime overhead. Additionally, packers can detect and evade analysis systems, such as debuggers and dynamic binary instrumentation environments, further complicating the unpacking process.

### 2.2 API Call Resolution Obfuscation
Packers obfuscate API call resolution by erasing the IAT and reconstructing it at runtime. This common feature among packers inspired our approach to capture the "rebuilt-then-called" behavior, providing a more efficient and effective way to determine the end of unpacking.

This work aims to provide a robust and efficient solution for large-scale malware analysis, contributing to the ongoing efforts to combat evolving malware threats.