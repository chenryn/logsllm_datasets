title:Towards Paving the Way for Large-Scale Windows Malware Analysis: Generic
Binary Unpacking with Orders-of-Magnitude Performance Boost
author:Binlin Cheng and
Jiang Ming and
Jianming Fu and
Guojun Peng and
Ting Chen and
Xiaosong Zhang and
Jean-Yves Marion
Towards Paving the Way for Large-Scale Windows Malware
Analysis: Generic Binary Unpacking with Orders-of-Magnitude
Performance Boost
Binlin Cheng∗‡
Wuhan University & Hubei Normal
University
Wuhan, Hubei 430072, China
PI:EMAIL
Guojun Peng‡
Wuhan University
Wuhan, Hubei 430072, China
PI:EMAIL
Jiang Ming∗†
University of Texas at Arlington
Arlington, TX 76019, USA
PI:EMAIL
Jianming Fu†‡
Wuhan University
Wuhan, Hubei 430072, China
PI:EMAIL
Ting Chen
Xiaosong Zhang
University of Electronic Science and
University of Electronic Science and
Technology of China
Chengdu, Sichuan 611731, China
PI:EMAIL
Technology of China
Chengdu, Sichuan 611731, China
PI:EMAIL
Jean-Yves Marion
Université de Lorraine, CNRS, LORIA
F-54000 Nancy, France
PI:EMAIL
ABSTRACT
Binary packing, encoding binary code prior to execution and deco-
ding them at run time, is the most common obfuscation adopted
by malware authors to camouflage malicious code. Especially, most
packers recover the original code by going through a set of “written-
then-executed” layers, which renders determining the end of the
unpacking increasingly difficult. Many generic binary unpacking
approaches have been proposed to extract packed binaries without
the prior knowledge of packers. However, the high runtime over-
head and lack of anti-analysis resistance have severely limited their
adoptions. Over the past two decades, packed malware is always a
veritable challenge to anti-malware landscape.
This paper revisits the long-standing binary unpacking problem
from a new angle: packers consistently obfuscate the standard use
of API calls. Our in-depth study on an enormous variety of Win-
dows malware packers at present leads to a common property:
malware’s Import Address Table (IAT), which acts as a lookup table
for dynamically linked API calls, is typically erased by packers for
further obfuscation; and then unpacking routine, like a custom
∗Both authors contributed equally to the paper.
†Corresponding authors: PI:EMAIL and jmfu@whu.edu.cn.
‡(1) Key Laboratory of Aerospace Information Security and Trust Computing;
(2) School of Cyber Science and Engineering, Wuhan University
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ’18, October 15–19, 2018, Toronto, ON, Canada
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5693-0/18/10...$15.00
https://doi.org/10.1145/3243734.3243771
dynamic loader, will reconstruct IAT before original code resumes
execution. During a packed malware execution, if an API is invo-
ked through looking up a rebuilt IAT, it indicates that the original
payload has been restored. This insight motivates us to design an
efficient unpacking approach, called BinUnpack. Compared to the
previous methods that suffer from multiple “written-then-executed”
unpacking layers, BinUnpack is free from tedious memory access
monitoring, and therefore it introduces very small runtime over-
head. To defeat a variety of ever-evolving evasion tricks, we design
BinUnpack’s API monitor module via a novel kernel-level DLL hi-
jacking technique. We have evaluated BinUnpack’s efficacy extensi-
vely with more than 238K packed malware and multiple Windows
utilities. BinUnpack’s success rate is significantly better than that of
existing tools with several orders of magnitude performance boost.
Our study demonstrates that BinUnpack can be applied to speeding
up large-scale malware analysis.
CCS CONCEPTS
• Security and privacy → Software reverse engineering;
KEYWORDS
Windows Malware Analysis, Generic Binary Unpacking, Import
Address Table, Kernel-level DLL Hijacking
ACM Reference Format:
Binlin Cheng, Jiang Ming, Jianming Fu, Guojun Peng, Ting Chen, Xiaosong
Zhang, and Jean-Yves Marion. 2018. Towards Paving the Way for Large-Scale
Windows Malware Analysis: Generic Binary Unpacking with Orders-of-
Magnitude Performance Boost. In CCS ’18: 2018 ACM SIGSAC Conference on
Computer & Communications Security Oct. 15–19, 2018, Toronto, ON, Canada.
ACM, New York, NY, USA, 17 pages. https://doi.org/10.1145/3243734.3243771
Session 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada3951 INTRODUCTION
Malicious software (malware) has become a significant threat to cy-
bersecurity. Big malware attacks such as ransomware ripple across
the world and cause catastrophic damage [6, 66]. Driven by the rich
profit, cyber-criminals are highly motivated to undermine malware
detection/analysis by applying numerous obfuscation schemes [94].
Among them, binary packing is believed to be a panacea to thwart
the widely used anti-virus scanning [11, 50, 65, 70]. Binary packers
first encode malware code through encryption or compression and
attach an unpacking routine to the packed malware. In addition,
packers also erase the Portable Executable (PE) file’s import address
table (IAT) to complicate the analysis of API calls. When a packed
malware starts running, the unpacking routine first decodes the
payload binary to memory pages and reconstructs its IAT. After
that, the execution flow will jump to the original entry point (OEP)
to resume malware payload execution. In this way, the actual mali-
cious code and data stays unrecognizable until run time, making it
immune to malware analysis techniques that measure static featu-
res. For example, applying machine learning to large-scale packed
malware will lead to the detection of packers rather than malicious
behavior [100]. An embarrassing fact is many anti-virus scanners,
which are widely deployed at the end host, take a particular pac-
ker’s signature as the identification of malware [93, 104]. A study
in 2013 shows that nearly 70% of packed Windows system files are
falsely labeled as malware [67].
Binary packing technique has evolved from the simple, single-
layer packer to the complicated, multi-layer packer with a variety
of anti-analysis tricks [97]. When a packed binary starts running,
the original code is written in memory pages sometime and then
get executed. Besides, this “written-then-executed” procedure can
iterate many times, i.e., the dynamically generated code itself may
continue generating new code and executing it. Each iteration of
dynamically generated code is called a layer [97] or wave [14]. The
previous generic unpacking tools have fully utilized this feature
by tracking the “written-then-executed” instructions [3, 9, 36, 55,
77, 81] or memory pages [28, 31, 49, 56]. However, no silver bullet
can sharply determine the end of multi-layer unpacking because it
has been proven to be an undecidable problem [83] 1. The existing
approaches have to continuously monitor all possible “written-
then-executed” layers and detect the existence of original code
in a certain layer with several heuristics [28, 35, 37, 55]. All of
these factors contribute to the high runtime overhead imposed by
current generic unpacking tools, making them too expensive for
wide deployment.
The second notable feature of sophisticated packers is that they
adopt different anti-analysis techniques to impede unpacking at-
tempts [13, 21, 82]. To track a packer’s self-decoding progress,
generic unpacking typically relies on dynamic analysis techni-
ques, such as debugging [17, 83, 91], dynamic binary instrumen-
tation [3, 9, 55, 77, 81], system emulator [8, 29, 36, 97], and API
hooking [31, 49, 56]. However, most of them are not transparent to
the packers. Evasive packers can fingerprint these analysis systems
and, as a result, terminate unpacking execution [40]. Themida [72],
1Denis et al. prove that detecting the end of unpacking can be reduced to an NP-
complete problem under certain assumptions [10].
a well-known commercial packer, even applies virtualization obfus-
cation to its unpacking routine [85, 102], which will result in 630X
instruction size explosion when tracing unpacking progress [63].
Worse still, malware authors can customize new packers from exis-
ting ones, as many packers are open source (e.g., UPX2 and Yoda’s
Protector3). The lack of anti-analysis resistance renders existing
generic unpacking futile for sophisticated packers. Security com-
panies have been overwhelmed by packed malware over the past
two decades, which slows down the response to emerging malware
threats [15, 64, 73]. An online packing service even utilizes existing
packers and anti-malware scanners as a feedback mechanism, and
it returns the packer that presents the optimal evasion result [69].
In this paper, we present a new generic unpacking idea by stu-
dying how packers obfuscate payload binary’s API call resolution.
Our approach, named BinUnpack, is motivated by two key observa-
tions. The first one is, no matter how sophisticated a packer may
evolve, malware payload always interacts with Windows OS to
perform malicious behavior (e.g., code remote injection and ran-
somware’s file encryption). Malware authors achieve this mainly
by calling user-level Windows APIs rather than native APIs4, since
most API semantic information is missing at the native level. Typi-
cally, binary code resolves a Windows API’s address by visiting PE
header’s IAT, which is an address lookup table when calling APIs
exported by a dynamic-link library (DLL). As the Windows APIs in
payload reveal rich semantics about malware and hence can provide
security analysts with an upper hand, our second observation is a
packer usually removes the payload’s import address table (IAT)
to impede reverse engineering. Afterwards, the unpacking routine
will obtain each API’s address and rebuild the IAT at run time. In
this way, the restored payload can invoke Windows APIs properly.
These observations inspire us to chase down a new heuristic to
determine the end of unpacking: if an API call is invoked through
looking up a rebuilt IAT, it indicates that the original code has been
restored, and the control flow has reached OEP already5. We call
this property as “rebuilt-then-called”. The key idea of BinUnpack is
to capture such a “rebuilt-then-called” feature instead of “written-
then-executed” behavior. To this end, BinUnpack hooks API calls
and finds the first one whose related IAT is rebuilt at run time. Then,
tracing back from that API, BinUnpack is able to locate OEP within
a very short distance. Compared to the existing work, BinUnpack
presents a distinct advantage: it sidesteps multi-layer unpacking
and avoids the significant overhead imposed by tedious memory
access tracing. It seems API hooking has become a textbook pro-
blem, as many options are available in the arsenal [2, 101, 105].
However, state-of-the-art malware packers have already embedded
anti-hooking tricks (e.g., stolen code [38], process hollowing [48],
and crash hooking module [41]) to evade API monitoring. Our solu-
tion is to develop a hybrid, kernel-level DLL hijacking technique as
API monitoring module. Our approach overcomes the path search
order limit for core DLLs (e.g., kernel32.dll), which prevents the
traditional way [79] from achieving complete DLL hijacking. Furt-
hermore, we have integrated existing work in system call sequence
alignment [42], memory subversion rootkit [90], and scalable binary
2https://upx.github.io/
3https://sourceforge.net/projects/yodap/
4Windows system calls are also known as native APIs.
5We will discuss the exceptions of this conclusion in Section 7.
Session 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada396function matching [87] to deal with fake API calls, DLL integrity
check, and custom API implementation, respectively. Our design
enables a strong resistance to various evasions.
We have performed a large-scale evaluation with 238, 835 pac-
ked malware and a set of common Windows utilities. Our tested
packer types contains a full range of malware packers in use, in-
cluding sophisticated commercial and custom packers. We also
evaluate BinUnpack with more challenging cases, such as multiple
packer combinations, a partial code revealing packer6, and possible
denial-of-service (DoS) attacks. Nevertheless, BinUnpack maintains
a high success rate consistently in all cases. The unpacked code
produced by BinUnpack can greatly increase the accuracy of anti-
virus scanning, and the overhead to Windows utility execution
is negligible as well. The comparative evaluation on a consumer
grade laptop shows that BinUnpack outperforms existing tools in
terms of significantly better performance and effectiveness. Bin-
Unpack is able to complete unpacking within 0.5 second in most
cases, which is substantially smaller than that of existing tools by
one ∼ three orders of magnitude. The hook evasion evaluation
indicates that BinUnpack outperforms well-known sandboxes (e.g.,
CwSandbox [101] and Cuckoo [71]) in terms of better resistance.
Our encouraging results demonstrate that BinUnpack can be de-
ployed to honeypot or sandbox to preprocess large-scale packed
malware, or integrated into online malware scanning service such
as VirusTotal7 to achieve the optimal malware recognition rate.
Scope and Contributions: Another related obfuscation to binary
packing is code virtualization [85, 102], which represents a comple-
tely different challenge. Although BinUnpack is immune to the case
of unpacking routine virtualization (see Section 8.1.3), recovering
virtualization protected code is out of our scope. In summary, the
contributions of this paper are as follows.
• We propose a new, generic solution to quickly determine the
end of unpacking by capturing the “rebuilt-then-called” beha-
vior. Our approach is free from heavy memory access tracing
caused by multi-layer unpacking, and therefore BinUnpack’s
performance is significantly better than the previous work.
• We design a novel, hybrid kernel-level DLL hijacking techni-
que. We are not aware of any other scientific work on Win-
dows core DLL hijacking. Our design enables BinUnpack to
exhibit more powerful unpacking capability than the existing
work.
• We evaluate BinUnpack extensively with large-scale datasets,
which include almost all of the Windows malware packers
available at present. BinUnpack shows consistently good
results across various packers and potential attacks. A free
online BinUnpack web service is under construction.
2 BACKGROUND AND MOTIVATION
In this section, we first summarize the drawbacks of existing work
when dealing with multi-layer and anti-analysis packers. Then we
present an example to illustrate another pervasive feature among
packers: API call resolution obfuscation and import address table
rebuilding. All of these inspire us to propose our unpacking method.
6It represents the worst case for all generic unpackers [7].
7https://www.virustotal.com
2.1 The Status Quo of Generic Unpacking
Existing generic unpacking approaches suffer from high overhead
and lack of anti-analysis resistance. When a unpacking routine
starts running, the procedure of writing to memory and then exe-
cuting the written memory can repeat many times. We borrow
the definition of unpacking layer from Xabier et al. [97]: “a layer
is, intuitively, a set of memory addresses that are executed after
being written by code in another layer”. Their longitudinal study
on 389 unique packers shows that 92.7% of them are multi-layer
packers. Two factors contribute to the challenge of determining
the end of unpacking. First, the “written-then-executed” feature is
just an indication of dynamically generated code but not original
code execution. Second, counter-intuitively, the original code is
not necessarily in the deepest layer. CoDisasm [9] finds 19 out of
total 28 packers have multiple layers. We further evaluate these 19
packers and identify that 4 of them do not present the original code
at the last layer. Figure 1 illustrates such an example: the deepest
layer only contains junk code rather than original code. There-
fore, the unpacking heuristics that captures either the last layer
or the signal of process termination (e.g., “TerminateProcess” or
“ExitProcess” ) will miss the real payload. To follow the unpacking
progress, the traditional approaches have to go through each un-
packing layer via heavy memory access tracing and determine the
presence of OEP with various heuristics. As a result, they typically
impose significantly high runtime overhead and are too expensive
for resource-constrained scenarios.
Generic unpacking utilizes various analysis systems to moni-
tor unpacking progress. However, these analysis systems leak out
many recognizable footprints, and packers can detect them to evade
unpacking. For example, Armadillo will terminate execution in
a debugging setting [21]; PESpin packers perform dynamic inte-
grity check to fingerprint dynamic binary instrumentation envi-
ronment [40]. Although some unpacking tools rely on hardware
virtualization [19] to achieve transparency, the cost is a much hig-
her performance penalty (e.g., 3, 000X slowdown [103]). The default
function of Themida packer applies virtualization obfuscation to its
unpacking routine, making monitoring unpacking progress even