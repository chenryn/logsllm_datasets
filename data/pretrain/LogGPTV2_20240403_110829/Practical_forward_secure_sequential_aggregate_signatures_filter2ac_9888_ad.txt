R← Z∗
R← Z∗
0 , r2l
0 )
mod n
0
0
mod n
Asig(SKt, M, σ1,t−1) (t = 1,··· , T and σ1,0 = 1)
Let SKt = (n, T, t, st, rt)
c ← H(t, y, M )
zt ← rt · sc
σ1,t ← σ1,t−1 · zt mod n
return (cid:104)t, (σ1,t)(cid:105)
t mod n
1. size of aggregate signature
2. size of secret key
3. complexity of secret key update (on-line)
4. complexity of aggregate signing (on-line)
5. complexity of generation (oﬀ-line)
6. size of public key
7. complexity of aggregate verifying (on-line)
The ﬁrst ﬁve parameters represent signer eﬃciency and the
last two – veriﬁer eﬃciency. The size of public and secret
keys correspond to space eﬃciency and signing, verifying
and key update complexity correspond to time eﬃciency.
We view signer eﬃciency as being more important than ver-
iﬁer eﬃciency and space eﬃciency – more important than
time eﬃciency. In envisaged applications, such as auditing
and data gathering systems, signers are the monitoring or
data gathering devices performing operations in real time
and generating/collecting data at high rates. They might
also have limited storage facilities and limited power (e.g.,
battery-operated sensors in unattended environments). A
veriﬁer, in contrast, is assumed to be a powerful entity (e.g,
a server or a sink) that collects and veriﬁes data gener-
It can perform
ated/gathered by aforementioned devices.
these tasks oﬀ-line.
We evaluate size parameters in number of elements in Z∗
n.
We evaluate the time parameters in terms of basic cryp-
tographic operations. Sqtt(m) denotes t modular squar-
ings and M ultt(m) denotes t modular multiplication with
modulus of size m. We estimate that one modular expo-
nentiation Exp1
l (m) with exponent size of l and modulus
Upd(SKt−1) (t = 2,··· , T )
Let SKt−1 = (n, T, t − 1, st−1, rt−1)
return SKt = (n, T, t, s2l
t−1, r2l
t−1)
Aver(P K, M1,··· , Mt,(cid:104)t, (σ1,t, y)(cid:105)
Let P K = (n, T, u, y)
for j = t··· 1,
• compute cj ← H(j, y, Mj)
• if j = t, compute σ(cid:48) ← σ2l(T +1−t)
• else σ(cid:48) ← σ(cid:48)2l · y · ucj
1,t
j
· y · ucj
if σ(cid:48) = 1 then return 1 else return 0
size m roughly equals l modular squarings and l/2 modular
multiplications: Exp1
l (n) = Sqtl(n) + M ultl/2(n). In prac-
tice, modular squaring is much faster than modular multi-
plication. Evaluation results are shown in Table 8.1. Both
schemes have constant-size parameters. Signer computation
(key update and aggregate signature generation) is constant,
while veriﬁer computation (aggregate veriﬁcation) requires
O(T ) complexity.
AR-F ssAgg1 has smaller public and private keys; it re-
quires only 2 units of storage for both signer and veriﬁer.
BM-F ssAgg1 requires l + 1 units of storage for both signer
and veriﬁer. BM-F ssAgg1 requires fewer squarings and mul-
tiplications in key update, signature generation and veriﬁ-
cation. It is thus more eﬃcient in term of computation. We
recommend its use in applications where computation and
communication are the ﬁrst two priorities.
8.2
Implementation
We implemented both proposed schemes on an Intel Dual-
Core 1.73GHz laptop with 1GB RAM under Linux. We
implemented BM-F ssAgg1 and AR-F ssAgg1 using Shoup’s
NTL library [1]. We ﬁxed security parameters at k = 1024
and l = 160. For comparison, we also implemented the BLS-
F ssAgg scheme using the Stanford PBC library [2] on the
same hardware platform. We used a singular curve Y 2 =
X 3 + X deﬁned on ﬁeld Fq for |q| = 512 and group order
|p| = 160 where p is a Solinas prime. Such groups have the
fastest pairing operations [2]. We measured signer cost by
signature generation and key update on a per message basis.
We measured veriﬁer cost over an aggregate signature σ1,t
when t = 100, 1, 000 and 10, 000 which corresponds to small,
medium, and large data sets, respectively. The results are
shown in Table 8.2.
Although key update in both schemes requires more com-
348
Table 4: Costs in terms of cryptographic operations; k = |n| and l are security parameters and t denotes the
current interval.
Parameters
Signature Size
Secret Key Size
Key Update Time
Asig Time
Public Key Size
Aver Time
AR F ssAgg1
1/O(1)
2/O(1)
Sqr2l(n)/O(1)
Sqrl(n) + M ult2+l/2(n)/O(1)
2/O(1)
SqrT (n) + M ul(1+l/2)t(n)/O(T ) Sqrl(T +t)(n) + M ult(2+l/2)t(n)/O(T )
BM F ssAgg1
1/O(1)
l + 1/O(1)
Sqrl+1(n)/O(1)
M ult1+l/2(n)/O(1)
l + 1/O(1)
Table 5: Operation Timing in msec.
Signer Cost Asig
U pd
(per msg)
total
t = 100
t = 1000
t = 10000
Veriﬁer Cost
BM-F ssAgg1 AR-F ssAgg1 BLS-F ssAgg1
30
0.002
30.00
3.30 × 103
29.3×103
330.72×103
2.09
3.46
5.55
211.97
2.13×103
21.35×103
4.39
7.27
11.66
810.88
8.16×103
80.84×103
putation than key update in BLS-F ssAgg (where key up-
date is merely a hash), aggregate signature generation in
our schemes requires much less computation than that in
BLS-F ssAgg. Therefore, signer costs (per message) - one
aggregation, one sign operation plus one key update - in
our schemes are less than those in BLS-F ssAgg. Speciﬁ-
cally, signer computation per message in BM-F ssAgg1 and
AR-F ssAgg1 is, respectively, 6 and 3 times faster than that
in BLS-F ssAgg. Veriﬁer computation in both new schemes
also costs less than that in BLS-F ssAgg: 16 and 4 times
faster, respectively.
In conclusion, new F ssAgg1 schemes perform much better
in almost all parameters than the pre-existing BLS-F ssAgg
scheme. Among the two new schemes, BM-F ssAgg1 is more
eﬃcient in computation, while AR-F ssAgg1 is more eﬃcient
in storage. They have the same communication eﬃciency.
9. DISCUSSION
Cross User Aggregation and Veriﬁcation. How fast can
aggregate veriﬁcation be? Can we have constant veriﬁca-
tion time? So far, all aggregate signatures including ours
require O(T ) aggregate veriﬁcation time. (Although the ag-
gregate veriﬁcation in LOSSW [19] requires only two pairing
operations regardless of how many intervals or signers, it do
require O(T ) multiplications.) Note that the cost of the
ﬁrst iteration in both our aggregate veriﬁcation functions
dominates the total cost as it requires O(T ) operations. A
possible way to reduce aggregate veriﬁcation cost is to ag-
gregate F ssAgg signatures from multiple signers ﬁrst and
then verify this super aggregate signature to amortize the
cost in the ﬁrst iteration among multiple users.
From F ssAgg1 to F ssAggm. We can trivially extend our
F ssAgg1 schemes to be F ssAggm schemes at a cost of in-
creasing size of secret key and public key. That is, let m
be the maximum number of messages generated in each in-
terval.
In the key generation stage, we selects m random
numbers r0,1,··· , r0,m and calculate m corresponding com-
mon commitments y1,··· , ym such that yi = r2T +1
. We use
yi to generate the challenge when we sign the i-th message
of each interval. Therefore by additional m units of space,
0,1
we can support up to mT messages.
10. CONCLUSION
In this paper, we identiﬁed general scenarios that use a
F ssAggm scheme can equivalently use a F ssAgg1 scheme
because of QFS. We proposed two practical F ssAgg1 signa-
ture schemes that can be used in applications which require
both forward security and storage/communication eﬃciency.
Our schemes are extended from existing forward secure sig-
nature schemes and they are provable secure. They outper-
form the BLS-F ssAgg signature scheme in almost all param-
eters. Especially they have compact public key and lower ag-
gregate veriﬁcation complexity. From our implementation,
the BM-F ssAgg1 is 16 times faster than the BLS-F ssAgg
scheme while the AR-F ssAgg1 is 4 times faster than the
BLS-F ssAgg scheme in aggregate veriﬁcation. Therefore
our schemes are more practical than the BLS-F ssAgg sig-
nature scheme to be used in applications with either weak
unattended device such as sensors or with intensive data gen-
eration such as secure logging. We applied them to secure
logging systems to provide forward secure stream integrity
for audit logs and evaluated their viability with implemen-
tation. However, our construction is still trivial. We will
investigate non-trial F ssAgg signature scheme construction
in the future.
Acknowledgments
The author thanks Professor Gene Tsudik, her PHD advi-
sor, for his kind support help on the ﬁnal version of this
paper. The author also thanks Dr. Guilin Wang for his
time analyzing the security of proposed schemes. Further-
more, the author is grateful to the anonymous reviewers for
their valuable comments.
11. REFERENCES
[1] Ntl: a library for doing number theory.
http://www.shoup.net/ntl/.
[2] Pbc library benchmarks.
http://crypto.stanford.edu/pbc/times.html.
349
[3] M. Abdalla and L. Reyzin. A new forward-secure
digital signature scheme. In Asiacrypt 2000, pages
116–129, 2000.
[4] R. Anderson. Two remarks on public-key cryptology -
invited lecture. In Fourth ACM Conference on
Computer and Communications Security (CCS), April
1997.
[5] M. Bellare and S. K. Miner. A forward-secure digital
signature scheme. In Proc. of Advances in Cryptology -
Crypto 99, pages 431–448, August 1999.
[6] M. Bellare and B. Yee. Forward integrity for secure
audit logs. In Technical Report, Computer Science and
Engineering Department, University of San Diego,
November 1997.
[7] M. Bellare and B. Yee. Forward-security in private-key
cryptography. In Proc. of CT-RSA’03, 2003.
[8] D. Boneh, C. Gentry, B. Lynn, and H. Shacham.
Aggregate and veriﬁably encrypted signatures from
bilinear maps. In Proc. of Eurocrypt 2003, pages
416–432, May 2003.
[9] D. Boneh, B. Lynn, and H. Shacham. Short signatures
from the Weil pairing. In Asiacrypt, volume 2248 of
Lecture Notes in Computer Science, 2001.
[10] X. Boyen, H. Shacham, E. Shen, and B. Waters.
Forward-secure signatures with untrusted update. In
ACM CCS’06, October 2006.
[11] A. Fiat and A. Shamir. How to prove yourself:
practical solutions to identiﬁcation and siganture
problems. In Advances in Cryptology - CRYPTO’86,
pages 186–194, August 1986.
[12] C. G. G¨unther. An identity-based key-exchange
protocol. In EUROCRYPT ’89: Proceedings of the
workshop on the theory and application of
cryptographic techniques on Advances in cryptology,
pages 29–37, New York, NY, USA, 1990.
Springer-Verlag New York, Inc.
[13] J. E. Holt. Logcrypt: forward security and public
veriﬁcation for secure audit logs. In ACSW Frontiers
’06: Proceedings of the 2006 Australasian workshops
on Grid computing and e-research, pages 203–211,
Darlinghurst, Australia, 2006. Australian Computer
Society, Inc.
[14] G. Itkis. Forward security (adaptive cryptography:
time evolution). Handbook of Information Security,
2006.
[15] G. Itkis and L. Reyzin. Forward-secure signatures
with optimal signing and verifying. In CRYPTO ’01:
Proceedings of the 21st Annual International
Cryptology Conference on Advances in Cryptology,
pages 332–354, London, UK, 2001. Springer-Verlag.
[16] A. Kozlov and L. Reyzin. Forward-secure signatures
with fast key update. In Proc. of the 3rd International
Conference on Security in Communication Networks
(SCN’02), 2002.
[17] H. Krawczyk. Simple forwardsecure signatures from
any signature scheme. In Proc. 7th ACM Conference
on Computer and Communication Security (CCS),
pages 108–115, November 2000.
[18] B. Libert, J. J. Quisquater, and M. Yung.
Forward-secure signatures in untrusted update
environments: eﬃcient and generic constructions. In
ACM CCS’07, Oct 2007.
[19] S. Lu, R. Ostrovsky, A. Sahai, H. Shacham, and
B. Waters. Sequential aggregate signatures and
multisignatures without random oracles. In Prof. of
Eurocrypt 2006, May 2006.
[20] A. Lysyanskaya, S. Micali, L. Reyzin, and
H. Shacham. Sequential aggregate signatures from
trapdoor permutations. In Proc. of Eurocrypt 2004,
pages 245–254, November 2001.
[21] D. Ma and G. Tsudik. Forward-secure sequentical
aggregate authentication. In Proceedings of IEEE
Symposium on Security and Privacy 2007, May 2007.
[22] T. Malkin, D. Micciancio, and S. Miner. Eﬃcient
generic forward-secure signatures with an unbounded
number of time periods. In Proc. of Eurocrypt
(Eurocrypt’02), 2002.
[23] B. Schneier and J. Kelsey. Cryptographic support for
secure logs on untrusted machines. Proceedings of the
7th USENIX Security Symposium, Jan. 1998.
[24] B. Schneier and J. Kelsey. Secure audit logs to support