的恢复过程，通常会根据各个报错条目来确定适当的修改方法,修改栈顶状态和/或第一个
言的使用方法来决定程序员所犯的何种错误最有可能引起这个语法错误。然后构造出适
装
其
GOTO(s，A)压人栈中，继续进行正常的语法分析。在实践中可能会选择多个这样的非终结符
个错误的输人符号移入到栈中。
弃
报
零个或多个输入符号，直到发现一个可能合法地跟在A之后的符号α为止。之后语法分析器
告错误。SLR 和LALR 语法分析器可能会在报错之前执行几次归约动作，但是它们决不会把-
号串，LR 语法分析器就会立刻报错。规范LR语法分析器不会做任何多余的归约动作，会立
许
构造。
它已经找到了A的一个实例，并继续进行正常的语法分析。
共余部分。通过从栈中删除状态，跳过一部分输人，并将 GOTO（s，A）压人栈中，语法分析器
在输入中，语法分析器则在输人中查找可以合法地跟在A后面的符号，从而试图跳过这个串日
含错误。这个串的一部分已经被处理，并形成了栈顶部的一个状态序列。这个串的其余部分
号 stmu，α就可能是分号或者}。其中，标记了--个语句序列的结束。
下扫描，直到发现某个状态s，它有一个对应于某个非终结符号A的 GOTO目标。然后我们-
语法分析
在为一个 LR语法分析器设计专门的错误处理例程时，我们可以在表的动作字段的每个空
实现短语层次错误恢复的方法如下：检查LR语法分析表中的每个报错条目，并根据语
这个错误恢复方法试图消除包含语法错误的短语。语法分析器确定一个从 A 推导出的串中
通常这些非终结符号代表了主要的程序段，比如表达式、语句或块。比如，如果A是非终乡
在LR 语法分析过程中，我们可以按照如下方式实现恐慌模式的错误恢复策略。我们从栈]
当 LR 语法分析器在查询语法分析动作表并发现一个报错条目时，它就检测到了一个语法错
错误处理例程如下：
图4-49 中显示了这个文法的 LR 分析表。图
 E-→E +EIE * E1(E)lid
再次考虑表达式文法
图 4- 49 中剩余的空白项已经被
替
次
状态
6
8
图4-53带有错误处理子
程序的 LR 语法分析表
3
2
4
ACTION
和
3
3
&
2
23
的
GOTO
78
6
181
输
须
条
顶
---
## Page 198
错误恢复例程，实现语法分析中的错误恢复。
空-else问题的常用方法来解决其中的冲突。
在这里，e和s仍然是分别代表条件表达式和“其他语句”
性表达式文法的使用，这个比较结果告诉我们什么信息？
及它们的语法分析表的大小，你能得出什么结论？关于
对这个文法重复(1)和(3)部分。
析表。
类推，我们应该如何解决 SLR 项之间的冲突？
法，它描述了包含n个二目中缀运算符且具有n个不同优先级的表达式：
4.8.44.8 节的练习
析器进人的格局序列显示在图4-54 中。
调用。
栈中。
个符号，这个符号可能是id或左括号，但是实际读人的却是+、＊或输入结束标记。
2）在这个语法分析表中填人额外的归约动作或适当的
1）为这个文法构造一个LR 语法分析表，并用解决悬
5）比较这两个(二义性和无二义性)文法的项集总数！
4）图4-55中的无二义性文法定义了相同的表达式集合。
3）给出你的语法分析器在处理下列输人时的行为：
！练习4.8.2：图4-56 给出了某种语句的文法。这些语句和练习 4.4.12中讨论的语句类似。
 3）根据你在(2）中的决定，给出相应的 SLR 语法分
2）要使得所有的运算符都是左结合的，并且θ，的优先级高于02，02的优先级高于θ3，依次
！练习 4.8.1：下面是一个二义性文
el：这个例程在状态0、2、4 和5 上被调用。所有这些状态都期望读人一个运算分量的第一
182
 while e do begin s ; if e then s ; end
@ if e then s ; if e then s end
1）将 SLR 项集表示为n 的函数。
在处理错误的输人id+)时，语法分
发出诊断信息“缺少右括号。”
将状态9(对应于右括号)压入栈中
e4：当在状态6上发现输人结束标记时
发出诊断信息“缺少运算符。”
将状态4(对应于符号+的状态)压入
e3：当在状态1和6上，期待读人一个运算符却发现了－个id或左括号时调用。
发出诊断信息“不匹配的右括号。”
从输入中删除右括号；
e2：在状态0、1、2、4 和5上发现输入为右括号时调用这个过程。
发出诊断信息“缺少运算分量。”
将状态3(状态 0、2、4 和5 在输入id上的 GOTO目标)压入栈中；
E→E θE丨EθEＩ..IEθnEI(E)lid
口
分
014
000
3
栈
图 4-54
11
E+
’的终结符号。
的语法分析和错误恢复步骤
符号
义
一个 LR 语法分析器所做
stint
图
图 4-56
输人
表达式的无二义性文法
14-55
++
begin list end
ife then stmt else stmt
if e then stmt
含有 n个运算符的
while e do stnt
el将状态3压入栈中
“不匹配的右括号”
某类语句的文法
；stmt
0n E2 
动作
第4章
---
## Page 199
声明用%和}%括起来。那些由第二和第三部分中的翻译规则及过程使用的临时变量都在这里
在图 4-58 中。
其中的词法单元 digit 是一个0~9 之间的数字。根据这个文法得到的 Yacc 桌上计算器程序显示
开始构造这个桌上计算器：
例4.69
它们可以和其他的C程序一样，和y.tab.c一起编译并加载。
α. out。这个程序执行了由最初的 Yacc 程序 translate. y所描述的翻译工作。如果需要其他过程，
对 y. tab.c 进行编译，并和包含 LR 语法分析程序的库 ly 连接，我们就得到了想要的目标程序
缩的。使用命令
析
程序 y. tab.c是一个用 C 语言编写的 LALR 语法分
translate. y转换成为--个名为 y.tab.c 的 C 程序。
如 translate.y，文件中包含了对将要构造的翻译器的规约。UNIX 系统命令
4.9.1语法分析器生成工具Yacc
译器产品。
分析器生成工具非常流行。Yacc 在 UNIX 系统中是以命令的方式出现的，它已经用于实现多个编
语法分析器生成工具 Yacc 作为我们讨论的基础，因为它实现了我们在前两节中讨论的很多概念，
4. 9
中的 LALR 分析表是按照 4.7 节中描述的方法
器，另外还包括由用户准备的C语言例程。其
按照图 4-57中演示的方法就可以使用 Yac 来构造一个翻译器。首先要准备好一个文件，比
函数库的名字 ly 和具体系统相关。
语法分析
cc y.tab.c -1y
使用算法 4.63 中给出的 LALR方法将文件
本节将介绍如何使用语法分析器生成工具来帮助构造一个编译器的前端。我们将使用LALR
一个Yacc 程序的声明部分分为两节,它们都是可选的。在第一节中放置通常的C声明，这个
声明部分
--个 Yacc 源程序由三个部分组成：
译规则
语法分析器生成工具
为了说明如何编写一-个 Yac 源程序，我们构造一个简单的桌上计算器。该计算器读
F→（E）Ｉ digit
T-→T * F I F
E-→E + TI T
压
图4-57用Yacc 创建一个输入/输出翻译器
y.tab.c-
规
Yacc
输入
约
a.out
编译器
Q
输出
a.out
183
口
译
---
## Page 200
单元，它就会被当作非终结符号处理。带引号的单个字符，比如‘c’，会被当作终结符号c以及
的一组产生式在 Yacc 中被写成：
和一个相关联的语义动作组成。我们前面写作
节中讨论的，Lex 生成的词法分析器也可以使用这里声明的词法单元。
中使用。如果向 Yacc 语法分析器传送词法单元的词法分析器是使用Lex 创建的，那么如 3.5.2
声明 DIGIT是一个词法单元。在这一节中声明的词法单元可以在Yacc 规约的第二和第三部分
这个语句使得C语言的预处理器将标准头文件包含进来,这个头文件中包含了断言
声明。在图 4-58 中，这一-节只包含 include 语句
isdigit。
184
在一个 Yacc 产生式中，如果一个由字母和数位组成的字符串没有加引号且未被声明为词法
我们将翻译规则放置在 Yacc 规约中第一个% % 对之后的部分。每个规则由-一个文法产生式
%token DIGIT
在声明部分中还包括对词法单元的声明。在图4-58中，语句
#include 
翻译规则部分
→2|…丨
：：1l
factor
term
expr
line