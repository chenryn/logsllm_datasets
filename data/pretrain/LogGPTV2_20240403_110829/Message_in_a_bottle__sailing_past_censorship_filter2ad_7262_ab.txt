Distributing the software bundle. To use miab, Alice
needs a copy of the software, and Bob’s public key. The key
should rarely change, so it can be distributed with the software.
This bundle can be downloaded in clear-text before the Censor
becomes too controlling. Otherwise, it can be distributed via
USB drives, or spam. Also, it could be published in multiple
locations online, encoded in a variety of formats (e.g., DeCSS code
diffusion [1]), so that the Censor cannot easily fingerprint and
block them all. In this case, Alice should collect several of these
bundles and compare them, to mitigate the possibility that she is
using bundles that were disseminated by the Censor. However,
this possibility cannot be ruled out with certainty. We expect
that the Censor will also have a copy of the software.
Alice’s need for the initial bundle is certainly a shortcoming
of miab. However, distributing the software and establishing a
root of trust is a fundamental problem, with no easy solution,
that affects every related work (e.g., Collage, Tor – see Section 7).
Moreover, miab represents a step toward solving this fundamental
problem, as its bundle need updates only in exceptional cases (e.g.,
Bob’s key has expired), and therefore can be used to bootstrap
other protocols, distributing the rendezvous points. We note that
also Telex has this property, but it needs the collaboration of
ISPs to be deployed, whereas miab does not.
Steganographic scheme. The choice of an appropriate
steganographic scheme is critical to achieve our confidentiality
and deniability goals. Ideally, we would like to have a perfectly
secure stegosystem, which is a system where the stego object (i.e.,
the object with an embedded hidden message) exactly matches
the probability distribution of the cover source (i.e., the object
before the embedding). Solutions to this problem exist [49,61], but
they require an exact knowledge of the probability distribution of
the cover source. Unfortunately, this knowledge is hard to obtain,
if not impossible [9], from real digital media, such as photos. To
overcome this setback, these solutions opt to artificially generate
the cover object. More pragmatic approaches, instead, focus on
hiding messages in real digital media by minimizing perturbations,
in the hope that the image noise will make these alterations appear
inconspicuous. The positive dependence between the fraction of
changes in the cover and their detectability is formalized under
the “square root law of steganography” [27]. Fortunately, miab
needs to embed a very limited payload, consisting only of a few
hundred bytes, which are embedded in cover photos whose size is
in the hundreds of Kbytes. To minimize our detectability, then,
we need to minimize the alterations made during the embedding,
and to curtail our changes in difficult-to-model areas of the digital
Figure 1: Alice sends a message to Bob, using the miab
protocol in its basic form.
the messages exchanged between Alice and Bob.
In particular, we aim to satisfy these properties for miab:
• Confidentiality: The Censor should not be able to read
• Availability: The Censor should not be able to block miab
without incurring unacceptable costs (by indiscriminately
blocking large portions of the Internet).
• Deniability: When confidentiality holds, the Censor should
not be able to distinguish whether Alice is using the system,
or behaving normally.
• Unobtrusive deployment: Deploying a miab instance
should be easy and cheap, so that small organizations or
private citizens with some disposable income (e.g., Bob)
can do it.
We will give a detailed analysis about to which extent we
achieved these properties in Section 6.
The only requirement that Alice must satisfy to use this protocol
is to be able to make a blog post. She can create this post on
any blog hosted (or self-hosted) outside the Censor’s jurisdiction.
3.1 Components
Before explaining the details of the miab protocol, we must
introduce the notion of blog pings, a concept that will play a
crucial role in our system. A blog ping is a message sent from a
blog to a centralized network service (a ping server) to notify the
server of new or updated content. Blog pings were introduced
in October 2001 by Dave Winer, the author of the popular
ping server weblogs.com, and are now a well-established reality.
Over the last ten years, the rising popularity of pings pushed
for the development of a wealth of protocols that compete for
performance and scalability (e.g., FriendFeed’s SUP [29], Google’s
PubSubHubbub [31], and rssCloud [48]).
Search engines use blog pings to efficiently index new content in
real time. Since search engines drive a good part of the traffic on
the Internet, blog writers adopt pings to increase their exposure
and for Search Engine Optimization. Consequently, the vast
majority of blogging platforms support pings, and have them
enabled by default (e.g., Wordpress, Blogger, Tumblr, Drupal).
3.2 The miab Protocol
Our scene opens with Alice, who lives in a country controlled
by the Censor. Alice wants to communicate with Bob, who is
residing outside the country, without the Censor ever knowing
that this communication took place. To do so, Alice sends a
message with the miab protocol, following these steps (also shown
in Figure 1):
1. Alice authors a blog post of arbitrary content. The content
should be selected to be as innocuous as possible.
2. Alice snaps one or more photos to include in the post.
media. Among the current state-of-the-art proposals in this
field, we selected, and used in our experiments, an adaptive
LSB-matching steganographic approach that chooses the location
of the pixels to alter with the help of Syndrome-Trellis Codes
(STCs) [25]. LSB-matching, also called ± embedding, consists
in randomly adding ±1 to the least significant bit of pixels to
match the hidden message. LSB-matching has been shown to be
near optimal when only a single pixel can be utilized [23]. Pure
LSB-matching schemes have been broken [30, 45], exploiting an
invalid underlying assumption of LSB-matching, which considers
natural image noise to be independent among pixels. Using
STCs, LSB-matching can be augmented by choosing the pixels
in which to embed the message wisely, minimizing detectable
alterations. In particular, we chose a near-optimal algorithm [26]
that minimizes distortions. This algorithm first associates a cost
to each possible pixel alteration, and then it finds the least costly
series of modification needed to embed the message. Both its
space and time complexity are linear with respect to the size of
the cover source. LSB-matching with STCs is also the approach
chosen by HUGO [46], which is a stegosystem that is optimized
to embed large messages. Although miab does not benefit from
HUGO’s efficient embedding, as its messages are short, this
stegosystem can give us a reference point about the state of the
art in the steganalysis of a system close to ours. This is because
HUGO has been targeted by steganalysis experts from all over the
world, in the first international challenge on steganalysis called
“Break Our Steganographic System” (BOSS [6]). For details on
HUGO’s resilience to attacks, see the next section. If we consider
also that, as we will show in the next section, tens of thousands
of photos are published in blog posts around the world every
minute, we expect that, if our adversary tries to detect stego
images in the blog posts stream, she will be overwhelmed by the
sheer number of false positives. Finally, we would like to note
that the miab protocol is decoupled from the particular scheme in
use, and swapping schemes is quite easy. Because of this, a miab
implementation can support multiple PKS schemes, much like
the SSL/TLS protocol does with cipher suites. In this scenario,
Alice can pick the PKS scheme she feels safe to use, and encode
her choice into a pre-determined place in the blog post (e.g., the
fist letter of the title will decide the scheme). Other schemes
that we have been considering are Gibbs constructions [24], and
Greenstadt’s work on an image-steganography scheme that can
withstand re-encoding [32].
4. ACHIEVING TWO-WAY MESSAGING
The miab protocol can be used to achieve two-way communi-
cation in two ways: either by bootstrapping a more demanding
censorship resistent protocol (that requires more than just Bob’s
public key to be initiated), or with a channel-hopping protocol
that establishes rendezvous points in Internet locations chosen at
will by the users.
Bootstrapping another protocol. We can use miab to
bootstrap Collage [12], which is a protocol that uses user-generated
content (e.g., photos, tweets) as drop sites for hidden messages.
Differently from the miab approach, in Collage, the drop sites
must be decided upon in advance: These rendezvous points are
the secret that Alice and Bob share. To put and retrieve the
messages from these rendezvous points, the users of Collage have
to perform a series of tasks. For example, if the drop site is a
photo posted on Flickr under the keyword “flowers,” the sender
task will be the series of HTTP requests required to post a photo
with that keyword, and the receiver task will be composed of
requests designed to retrieve the latest photos with that tag.
Figure 2: Covert messaging with miab.
To bootstrap a Collage installation, the database of tasks that
Collage employs must be distributed offline. This database needs
to be constantly updated as the Censor reacts and the drop
sites change (both in location and structure). It is, therefore,
crucial that this bootstrap database is up-to-date: Otherwise, the
agreement on the drop points between sender and receiver will
be lost, breaking the communication channel. Once Collage has
been bootstrapped, further updates can be received through the
Collage network. To receive these updates, however, the Collage
client must be connected to the Internet. When the connectivity
is sporadic, the client’s database might become obsolete, and a
new bootstrap round will be necessary.
We believe that miab is a good fit for bootstrapping Collage,
because the only information that Alice must know in order
to request a current copy of the task database is Bob’s public
key. miab could also be used to communicate with a censorship-
resistant micro-blogging service, like #h00t [4], or a privacy-
preserving one, like Hummingbird [16].
Covert Messaging. Another option to achieve two-way mes-
saging is to extend the miab protocol to let Bob reply to Alice.
To do so, Alice will need to inform Bob about the next rendezvous
point, and about the steganographic scheme Bob should use in
his reply. If Bob is a human (i.e., he is not running an automated
service), Alice will run the same algorithm presented in Section 3.2,
with a small modification in Step 3. In particular,
• Alice will choose the next rendezvous point R1 (e.g., site_
a.com in Figure 2). As rendezvous point, Alice will choose
the URL of a web page where Bob can post additional
content: for example, a forum, a media-sharing service, or
an online newspaper that lets its users comment the news.
If possible, Alice should indicate a website that she routinely
visits, so that the Censor will not be alarmed when she
visits that URL. This website should be located outside
Tyria, so that the Censor cannot see if Bob is visiting the
site (the censor would need to know Bob’s IP address, but
miab does not prevent this from happening).
• Alice will decide which steganographic scheme S1 Bob
should use to hide his answer. Note that now Alice is
not restricted to PKS schemes: She can also indicate a
shared-key scheme, along with a secret password to initialize
the scheme.
• If Alice intends to send additional messages to Bob, she
should also specify an additional rendezvous point, R2
(site_b.com in the Figure), and steganographic scheme S2.
Alice will then append this information to the message M, which
she will then embed in the photos. Following the usual protocol,
Bob will then recover Alice’s message, and obtain R1, R2, S1, and
S2. Bob will then prepare his reply to Alice, and post it (Point
8 in Figure 2), encoded with S1, on the rendezvous point R1.
Alice will periodically check R1, looking for Bob’s reply (Point
9 in the same Figure – we will empirically show in Section 5
that this wait is less than ten minutes). Alice could check R1
manually or, if the rendevouz point supports it, by email or RSS
feed. When she finds Bob’s message, she will decode it with S1,
completing the two-way messaging cycle. If Alice requires any
further communication with Bob, she will post her reply, encoded
with S2, on the rendezvous point R2, which Bob will periodically
check. Following the guidelines for the previous message from
Alice, this reply will also contain R3 and S3, if Alice expects
an answer from Bob (and, optionally, R4 and S4, if she plans
to send additional messages). If Bob is running an automated
service, Alice will also need to instruct the service on how to
reply. To do so, much like a Collage task, she will add to M the
sequence of actions that the automated service must follow to post
a reply (e.g., perform a POST request to http://site_a.com,
with payload comment=ANSWER). Alice has the option to provide
the cover channel for the automated service’s reply (i.e., she could
write a comment relevant to R1, or an image, and embed it in M).
Otherwise, the automated service will embed the reply into a spam
message, which will then post. Spam messages can be generated
(e.g., see [39]), or real spam messages can be collected from a set of
email accounts. Note that, for the sake of simplicity, in describing
this covert messaging protocol we assumed that Alice choses the
rendezvous points and encryption schemes manually. However,
this can be automated, so that Alice can use the protocol without
hassle. In particular:
• miab’s client software can detect the available stegano-
graphic schemes on Alice’s computer, and pick one at
random
• Alice, with the help of a browser extension, can collect po-
tential rendezvous points while surfing the web in her usual
routine. The extension would observe when Alice makes
POST requests containing files or long strings, without being
authenticated to the website she is interacting with (e.g.,
over clear-text HTTP, or without a Cookie HTTP header)
, and record them as possible rendezvous points. Essentially,
the extension would observe Alice’s browsing, looking for
commenting systems and media-sharing web services.
Once one of these rendezvous point is used in the covert
messaging, the browser extension can collect the answer
automatically, after waiting for the appropriate time for
Bob to answer (see Section 5 for details).
5.
IMPLEMENTATION