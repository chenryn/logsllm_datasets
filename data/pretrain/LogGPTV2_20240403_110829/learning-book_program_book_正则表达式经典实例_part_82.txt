## Page 438
#只有当这些标签包含上面列出的属性时.
）
才需要避免匹配到它们
[a=z]
#标签名称首字母必须是a~z
(？：[^>"]
除了>、”或、之外的任意字符
1"["] *"
双引号引起来的属性值
+￥[.v].]
#
单引号引起来的属性值
) *
>
正则选项：不区分大小写、宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
至于使用这样复杂的正则表达式来解决问题是不是合乎情理，这可能已经快接近极限
了。如果你的规则比这还要复杂，那么我们推荐你最好使用实例3.11或实例3.16中所
可以依据标签名称、所包含的属性或者所需的其他任何信息来进行）。
参见
实例8.1讲解了如何匹配所有XML风格的标签，并且讨论了如何进行利权衡，其中
包括如何容忍不合法的标记。
实例8.2与本实例正好相反，讲解如何匹配一个指定标签列表中的所有标签。
8.4匹配XML名称
问题描述
你想要检查一个字符串是否是一个合法的XML名称（-一种常见的语法结构）。对于在
一个名称中可以出现的字符，XML提供了精确的规则，并且会对元素、属性和实体名
称、处理指令目标以及许多其他内容都使用同样的规则。名称的组成规则如下：必须
由字母、下划线或冒号作为第一个字母，后面可以是任意组合的字母、数字、下划线、
冒号、连字符和点号。这实际上只是一个近似的介绍，但是它已经相当接近实际情况
了。实际上充许出现的字符要取决于你使用的XML版本。
如果为了更加精确而不惜采用更复杂的形式，那么另外一种可选的方式是把匹配合法
名称的模式插人到其他处理XML的正则表达式中。
下面是一些合法名称的例子：
·thing
·_thing_2_
·：PoccnicKne-Bemb
·fantastic4:the.thing
·日本の物
422第8章
www.TopSage.com
---
## Page 439
需要注意的是，这里允许出现非拉丁语的字母表，而且在最后一个示例中还包括了表
意文字。类似的，在第一个字符之后会充许出现任意的Unicode数字，而不只是阿拉伯
数字0~9。
作为对比，下面给出了一些这个正则式不应当匹配的非法名称的例子：
·thing!
·thing with spaces
·.thing.with.a.dot.in.front
·-thingamajig
·2nd_thing
解决方案
与许多编程语言中的标识符一样，在XML名称中可以出现的字符会组成-一个集合，
而其中的一个子集可以用于第一个学符。对于XML1.0第4版（以及更阜版本）和
XML1.1和1.0第5版来说，这些字符列表有很大的区别。本质上来说，XML1.1名
称可以使用在1.0第4版中充许的所有字符，另外再加上几乎100方个其他字符。然
而，这些额外的字符仅仅是在Unicode字符表中的一个位置而已。大多数位置还没有
被赋予任何实际字符，但是它们被预留以便Unicode字符数据库扩展时能做到与未来
兼容。
为了简洁起见，在本实例中提到XML1.0的时候指的是XML1.0的第1～4版。当我们
提到XML1.1名称时，也包括了XML1.0第5版的规则。第5版直到2008年12月底
才正式成为W3C的推荐标准，这比XML1.1要晚了几乎五年。
提示
在这个实例中所给出的正则式都使用了字符串开始和结束定位符（使用
本不能匹配。如果想要把这些模式嵌入到一个用来匹配XML元素的更长
的正则表达式之中，就一定要记住把位于这些模式首尾的定位符去掉。
关于定位符的讲解，请参考实例2.5。
XML1.0名称（近似方案）
\A[:_\pL1\p{Lu)\p(Lt}\(Lo)\p(N1}1[:_\-.\p{L}\p{M\{Nd}\p{N1}]*\z
正则选项：无
正则流派：.NET、Java、PCRE、Perl、Ruby1.9
PCRE必须使用Unicode属性（p{}>）的UTF-8支持进行编译才能正确执行。在PHP
中，需要使用模式修饰符/u打开UTF-8支持。
在JavaScript、Python或Ruby1.8中不支持Unicode属性。随后要给出的XML1.1名称
的正则式并不依赖于Unicode属性，因此如果你使用的是这些编程语言之中的一种，那
标记语言和数据交换423
www.TopSage.com
---
## Page 440
么可以选择使用下面一个正则式。即使你的正则流派支持Unicode属性，最好也还是
不要使用基于XML1.1的解决方案，要想了解其中的详细原因，请参见本实例随后的
“讨论”小节。
XML1.1名称（精确方案）
下面给出的是同一个正则表达式的适用于不同流派的3种版本。前两个正则式之间的
唯一区别是在模式开始和结尾使用的定位符不同。第3个版本中使用了，在Python中可以添加（注意要使用大
写的U，其后必须跟着8位的十六进制数字）。但是即使不添加这样大的范围，XML1.1
名称字符列表已经要比XML1.0的列表大很多了。
讨论
因为在本章中的许多正则表达式要处理的都是匹配XML元素，本实例的目标是当你想
要对标签和属性名称中能匹配具体哪些内容感兴趣的时候，为读者提供更为完整的讨
论。在书中其他地方，我们一般只会使用更简单、从而不是这么精确的模式，主要是
为了可读性和效率的考虑。
因此，我们下面再来更深人地挖掘这些模式背后的规则。
XML1.0名称
XML1.0规范在它的名称规则中使用的是白名单的方法，明确列出了它允许使用的所
有字符。名称首字符可以是一个冒号（：)、下划线（_）或者在如下Unicode类别中的
几乎任何字符：
·
小写字母(LI)
·
大写字母（Lu)
标题大写（Titlecase）字母（Lt）
·
不区分大小写的字母（Lo）
字母数字（N1）
在首字母之后，除了上面介绍的字符之外，还可以使用连字符（-）、点号（.）和在下
列类别中的任意字符：
标记（M），其中包括了3个子类：非间距标记（Mn）、间距组合标记（Mc）和封
闭标记（Me)。
·
修饰符字母（Lm）
十进制数字（Nd）
根据这些规则，我们可以得到在本实例的“解决方案”小节中所给的正则表达式。下
面我们给出了这个正则表达式的宽松排列形式：
\A
#字符串开始
[:_\p{L1}\p{Lu^p{Lt}\p{Lo}\p{N1}]
#名称首字母
[:_\.\p{L)\p{M}\p{Nd}\p{N1}] *
名称字母（0个或多个）
#字符串结束
正则选项：宽松排列
正则流派：.NET、Java、PCRE、Perl、Ruby1.9
标记语言和数据交换
425
www.TopSage.com
---
## Page 442
同样需要注意PCRE必须使用UTF-8支持进行编译。在PHP中，需要使用模式修饰符
u来打开UTF-8支持。
注意在第2个字符类中，所有这些字母子类（Ll、Lu、Lt、Lo和Lm）被合起来表示为
其基类p{L}>。
在早些时候，我们提到过这里描述的规则是近似的。这有两个原因。首先，XML1.0
规范（记住我们在这里讲的不包括它的第5版）中列出了不遵守这些规则的一些例外。
其次，XML1.0字符列表是从Unicode2.0中导出的，而后者是早在1996年发布的。
Unicode标准的更新版本中添加了一些新的文字，其中的字符在XML1.0规则中是不支
持的。然而，如果把正则表达式同你的正则引擎使用的Unicode版本之间分开来，从而
可以把匹配限制到Unicode2.0的字符集之上，就会把这个模式变成一个包含几百个范
围和代码点的畸形正则表达式，它会占据一整页的内容。如果你的确想要创建这样一
个怪物，那么可以参考XML1.0第4版（http://www.w3.org/TR/2006/REC-xml-20060816）
如果我们只考虑把这个正则式用于某些特定正则流派，那么我们还可以按照下面的方
式来简化这个正则式。
Perl和PCRE允许把小写字母（Ll）、大写字母（Lu）和标题大写字母（Lt）子类合并
成为-个特殊的“带大小写的字母”（L&）类别。这些正则流派同样允许省略在转义序
列p{}）中的花括号，前提是其中只包含一个字符。在下面这个正则式中我们利用
了这个特性，因此可以使用（pLpM）来替代（p{L)p{M})：
\A[:_\p(L&}\p(Lo}\p{N1}][:_\.\pL\pM\pNd)\p{N1}] *\z
正则选项：无
正则流派：PCRE、Per1
NET支持字符类差，在第一个字符类中，我们用它从L中减去了Lm子类，这样就不
用一一列出所有其他的字母子类：
\A[:_\p(L}\p(N1}[\p{Lm}11 [ :_\- .\p{L}\p{M}\p(Nd}\p(N1}] *\z
正则选项：无
正则流派：，NET
同PCRE和Perl一样，Java也允许省略掉单字母Unicode类别两边的花括号。下面的
正则式还利用了Java中更为复杂的字符类减法（通过否定字符类的交集来实现），把
Lm子类从字母类L中减掉：
\A[:_\pL\p(N1}&&[\p(Lm}1 1[:_\-.\pL\pM\p{Nd}\p{N1)] *\z
正则选项：无
正则流派：Java
JavaScript、Python和Ruby1.0根本不支持Unicode类别。Ruby1.9中也不包含前面讲
到的花哨功能，但是它会支持我们在本实例的“解决方案”中给出的正则式的更加轻
便的版本。
426第8章
www.TopSage.com
---
## Page 443
XML1.1名称
XML1.0犯了个错误，把自已和Unicode2.0绑到了一起。Unicode标准的随后版本中
添加了对更多字符的支持，其中有些来自于之前根本没有考虑过的文字（例如切洛基
语、埃塞俄比亚语和蒙古语）。因为XML希望把自已当作一种统一的格式，因此它试
图在XML1.1和1.0第5版中改正这个问题。在这些更新版本中，对于名称中可以使
用的字符从白名单的做法改成了黑名单，这样就可以不仅能够支持在Unicode2.0之后
添加的字符，同样还可以支持未来添加的字符。
这种新的策略支持没有明确声明禁止的内容，这样就提高了未来兼容性，而且它还使
得我们更加容易做到精确遵守这些规则。这也就是为什么XML1.1名称的正则式被标
记为精确方案，而XML1.0的正则式却是近似方案。
变体
在本章的有些实例中（例如实例8.1），用来处理XML名称的模式片段，要么几乎不做