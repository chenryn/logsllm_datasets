### 译者注
本文翻译自Fireeye 
译者力求贴近文章原意，即使经过了逐句逐词地翻译校对，仍需在此做一些说明以便于读者对本文的学习与理解:
obfuscation detector "混淆检测器" 文中指识别混淆过的命令行的程序
Malicious actors 恶意的行动者，指黑客
living off the land "不落地" 指恶意软件不在磁盘存储
machine learning (ML) 机器学习
Pattern Matching 模式匹配
Neural Networks 神经网络
Convolutional Neural Network (CNN) 卷积神经网络
natural language processing 自然语言处理
Gradient Boosted Decision Tree 梯度增强的决策树
caret 即符号^
pipe symbols 管道符号 即|
discriminator 鉴别器
classifier 分类器
Gradient Boosted Tree,GBT 梯度增强树
#### 机器学习效果的常用评测指标
F1值( F1-score)综合指标  
准确率(Precision)，简单说就是找得对  
召回率(Recall)，简单说就是找得全
### 前言
这篇博客文章介绍了一种机器学习（ML）方法，用于解决新出现的安全问题：在终端上检测混淆的Windows命令行调用。  
我们首先介绍这种相对较新的威胁，然后讨论处理这些问题的传统办法。再说明解决此问题的机器学习方法，并指出ML如何极大地简化了强大的混淆检测器的开发和维护。最后，我们展示了使用2种不同的ML技术获得的结果，并比较了每种技术的优点。
### 介绍
恶意的行动者逐渐变得“不落地”，使用PowerShell和Windows Command
Processor(cmd.exe)等系统内置的实用程序作为其感染工作流程的一部分，以尽量减少恶意软件被检测的机会，并绕过白名单防御策略。  
新发布的混淆工具通过添加一个中接层(在可见的语法和命令的最终的行为之间)，使得检测这类威胁变得更加困难。例如最近发布的两个混淆命令的工具：  
Invoke-Obfuscation 自动混淆Powershell命令  
Invoke-DOSfuscation 混淆Windows的cmd.exe命令行
(用于检测混淆的)传统的"模式匹配"和"基于规则的方法"难以开发和归纳，并且可能对防御者造成巨大的维护问题。我们将展示如何使用ML技术来解决这个问题。
"检测混淆过的命令行"是一种非常有用的技术，因为它为可能的恶意活动提供了强大的过滤器，减少了防御者必须查看的数据。虽然在野外有一些“合法”混淆的例子，但在绝大多数情况下，混淆的存在通常是一种恶意意图的信号。
### 背景
混淆技术被用来隐藏恶意软件的存在，已经有很长的历史了：包括恶意有效载荷的加密（从Cascade病毒开始）和字符串的混淆，到JavaScript混淆。
混淆的目的有两个：
  * 使防御类的软件越来越难找到：易于检测它们(可执行代码、字符串或脚本)的模式。
  * 使逆向工程师和分析师更难以破译并完全理解恶意软件正在做什么。
从这个意义上讲，命令行混淆不是一个新问题 - 只是混淆的目标(Windows命令处理器 cmd.exe)相对较新。最近发布的等工具如Invoke-Obfuscation（用于PowerShell）和Invoke-DOSfuscation（用于cmd.exe）已经证明了这些命令的灵活性，并且经过混淆的非常复杂的命令仍然可以有效运行。
如图所示，混淆过的命令行 与 非混淆的命令行，空间图中有两个轴：
  * 简单的(simple) -> 复杂的(complex)
  * 明文的(clear) -> 混淆的(obfuscated)
对于本次讨论中：
  * "简单的"("simple")表示简短且相对不太复杂，但仍然可以包含混淆；
  * "复杂的"("complex")表示长而复杂的字符串(可能会混淆，也可能不被混淆)
因此，简单/复杂 轴 与 混淆/未混淆 轴
正交。这两个轴的相互作用产生许多边界情况，其中用于检测脚本是否被混淆的简单启发式方法（例如，命令的长度）会在未经混淆处理的样本上产生误报。  
从ML的角度来看，命令行处理器(command line processor)的灵活性使"分类"成为一项困难的任务。
> 图1:混淆的维度  
>
> 
-
> 图2:弱混淆和强混淆  
>
> 
### 传统的混淆检测办法
传统的混淆检测办法可以分为三种。
#### 第一种方法
编写大量复杂的正则表达式以匹配Windows命令行中最常被滥用的语法。
例1  
如这个正则表达式，试图匹配在混淆中常见的"使用call命令的&符号链"这一混淆模式。  
`(set [a-zA-Z0-9]+=.* &&)+ (call set [a-zA-Z0-9]+=%[a-zA-Z0-9%]+%).* call
%.*%`
它能够匹配到这个样本（以混淆的方式调用`echo`）  
`set env1=ec && set env2=ho && call set env3=%env1% %env2% && call %env3%`
译者专门测试了这个正则表达式的匹配 如图，可以匹配到这个样本。  
可点击查看匹配效果   
这种方法存在两个问题：
  * 不可能开发非常多的正则表达式来涵盖每一种命令行可能的滥用方式，而且命令行的灵活性可以导致非常规的语句，用正则表达式表示这些语句是能做但不切实际的。
  * 即使恶意样本使用的混淆技术存在对应的正则表达式能够匹配到，一个决心强的攻击者也能够对混淆后的命令继续进行一些微小修改，不被之前的正则表达式匹配到。图5显示了对图4中序列的一个小修改，它避免了正则表达式检测。
对例1中的样本进行一些小调整变为如下语句，即可不被例1中的正则表达式匹配到。
`set env1 =ec && set env2=ho ^&^& call set env3=:%env1% %env2% && call %env3%`
译者专门比较了具体的修改点 如图  
#### 第二种方法
第二种方法更接近ML方法，涉及编写一些复杂的if-then规则，但是这些规则难以推导，验证起来复杂，并且随着作者本人逐渐开发出绕过这些规则的一些语句，给这种办法造成了沉重的维护负担。
例2 一个if-then规则  
**可能** 指出混淆（注意这个规则宽松 可能出现误报）