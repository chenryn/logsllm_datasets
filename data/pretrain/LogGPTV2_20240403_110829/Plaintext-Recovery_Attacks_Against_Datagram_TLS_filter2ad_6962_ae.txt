0.99
0.91
0.89
0.92
0.89
1280
0.01
0.03
0.07
0.08
0.09
0.15
1280
1.00
0.93
0.93
0.81
0.77
0.68
1280
1.00
0.93
0.94
0.81
0.77
0.68
1456
0.13
0.18
0.02
0.04
0.07
0.05
1456
0.93
0.92
0.83
0.57
0.54
0.59
1456
0.93
0.92
0.83
0.57
0.54
0.59
128
0.00
0.03
0.03
0.04
0.14
0.04
256
0.12
0.12
0.20
0.17
0.10
0.08
m = 1
256
1.00
1.00
1.00
1.00
1.00
1.00
128
0.99
0.99
0.99
0.99
0.97
0.98
m = 5
256
1.00
1.00
1.00
1.00
1.00
1.00
128
0.99
0.99
0.99
0.98
0.98
0.99
m = 10
Table 2. Success probabilities per byte for
3DES, for various attack parameters.
DTLS implementation. This, then, may also indicate of a
lack of truly expert code review in the OpenSSL project.
This is concerning given the prominence and wide applica-
tion of the OpenSSL code, but also understandable given
its volunteer-led effort. By contrast, GnuTLS’s implemen-
tation has common code for the TLS and DTLS packet de-
cryption procedure, meaning that countermeasures imple-
mented for TLS are immediately carried over to DTLS.
However, as we saw, even this was not sufﬁcient to fully
protect the GnuTLS implementation against the type of at-
tack developed in this paper.
A second reason that the obvious and mandated coun-
termeasures were not implemented in OpenSSL may stem
from DTLS’s lack of error messages, which makes the
previous attacks apparently impossible against DTLS. We
proved otherwise, exploiting DTLS Heartbeat request and
response messages to obtain the required timing informa-
tion. This kind of approach may be more widely applicable
than DTLS.
A third possible explanation is that the DTLS speciﬁca-
tion relies heavily on cross-references to the TLSv1.1 speci-
ﬁcation, and indeed only gives speciﬁcation details at points
where TLS and DTLS differ. So an implementor needs to
be familiar with both speciﬁcations in order to implement
DTLS properly. We suggest that “speciﬁcation by diff”
is not a good approach to specifying secure protocols, since
it requires an implementor to jump back and forth between
speciﬁcations and may allow important details to fall into
the gap between.
Secondly, a comparison between our attacks on DTLS
and previous attacks on TLS is instructive. Our attacks are
in some sense more challenging because of the lack of ex-
plicit error messages, but also easier to carry out because
of DTLS’s tolerance of errors, meaning that DTLS connec-
tions are not torn-down whenever an error is encountered as
they are in TLS. Ultimately, this error-tolerance comes from
DTLS’s use of an unreliable transport protocol. For similar
[11] E. Rescorla and N. Modadugu. Datagram Transport
Layer Security. RFC 4347, Internet Engineering Task
Force, April 2006.
[12] Juliano Rizzo and Thai Duong. Practical Padding Or-
acle Attacks. In 4th USENIX Workshop on Offensive
Technologies (WOOT’10), August 2010.
[13] J. Salowey, T. Petch, R. Gerhards, and H. Feng.
Datagram Transport Layer Security (DTLS) Transport
Mapping for Syslog. RFC 6012, Internet Engineering
Task Force, October 2010.
[14] R. Seggelmann and M. Williams.
(TLS)
Transport
Layer Security
and Datagram Trans-
port Layer Security (DTLS) Heartbeat Exten-
sion.
Internet Engineering Task
Force.
http://tools.ietf.org/html/
draft-ietf-tls-dtls-heartbeat-02.
Draft RFC,
[15] Serge Vaudenay. Security Flaws Induced by CBC
Padding - Applications to SSL, IPSEC, WTLS ... In
Lars R. Knudsen, editor, EUROCRYPT, volume 2332
of Lecture Notes in Computer Science, pages 534–
546. Springer, 2002.
reasons, the anti-replay feature in DTLS is made optional in
the speciﬁcation. In this context, our work shows how non-
security features of lower layer protocols can have a major
inﬂuence on security at higher layers. This phenomenon is
seemingly not that well-explored in the literature, present-
ing an interesting challenge for future work.
References
[1] P. Calhoun, M. Montemurro, and D. Stanley. Control
And Provisioning of Wireless Access Points (CAP-
WAP) Protocol Speciﬁcation. RFC 5415, Internet En-
gineering Task Force, March 2009.
[2] Brice Canvel, Alain P. Hiltgen, Serge Vaudenay,
and Martin Vuagnoux. Password Interception in a
SSL/TLS Channel. In Dan Boneh, editor, CRYPTO,
volume 2729 of Lecture Notes in Computer Science,
pages 583–599. Springer, 2003.
[3] Scott A. Crosby, Dan S. Wallach, and Rudolf H. Riedi.
Opportunities and Limits of Remote Timing Attacks.
ACM Trans. Inf. Syst. Secur., 12(3), 2009.
[4] Jean Paul Degabriele and Kenneth G. Paterson. At-
tacking the IPsec standards in encryption-only conﬁg-
urations. In IEEE Symposium on Security and Privacy,
pages 335–349, 2007.
[5] Jean Paul Degabriele and Kenneth G. Paterson. On the
(in)security of IPsec in MAC-then-encrypt conﬁgura-
tions. In ACM Conference on Computer and Commu-
nications Security, pages 493–504, 2010.
[6] T. Dierks and E. Rescorla. The Transport Layer Secu-
rity (TLS) Protocol Version 1.1. RFC 4346, Internet
Engineering Task Force, April 2006.
[7] Thai Duong and Juliano Rizzo. Cryptography in the
Web: The Case of Cryptographic Design Flaws in
ASP.NET. In IEEE Symposium on Security and Pri-
vacy. IEEE Computer Society, May 2011.
[8] W. Hardaker. Transport Layer Security (TLS) Trans-
port Model for the Simple Network Management Pro-
tocol (SNMP). RFC 5953, Internet Engineering Task
Force, August 2010.
[9] S. Kent and R. Atkinson. IP Authentication Header.
RFC 2402, Internet Engineering Task Force, Novem-
ber 1998.
[10] Nagendra Modadugu and Eric Rescorla. The Design
and Implementation of Datagram TLS. In NDSS. The
Internet Society, 2004.
A Timing and Packet Processing
In this appendix we look in detail at how a receiver pro-
cesses a packet, with a view to building a simple model of
how RTTs are affected by the attack parameters. To this
end, Figure 9 shows a simpliﬁed time-line of how packet i,
having valid padding, is processed by the receiver.
In the time-line we have:
• ti,0: The time at which packet i arrives in the OpenSSL
buffer. The buffer holds DTLS packets waiting to be
processed.
• ti,1: The time at which the decryption and padding
check are completed for packet i.
• ti,2: The time at which the MAC check is completed
for packet i.
• ti,3: The time at which OpenSSL is ready to process
the next DTLS packet, packet i + 1.
• OSt: Any additional time spent by the operating sys-
tem in relation to the processing of the packet. We
assume this to be a constant, independent of i.
In the case of a packet with invalid padding, the MAC
veriﬁcation is not performed and hence we have ti,2 = ti,1.
Figure 10 is the analogue of Figure 9 for the case of in-
valid padding, and illustrates that, for a ﬁxed DTLS packet
length, the time taken to process a packet with invalid
padding is less than that taken to process a packet with valid
padding.
In Section 3, we deﬁned RT T to be the time taken be-
tween sending the ﬁrst packet in a train to receiving a Heart-
beat response packet. Next, we analyse the different contri-
butions to RT T . As an example, the time-line in Figure 11
shows a train made of two identical data packets (so n = 2),
both having valid padding, followed by a Heartbeat request
packet, which then provokes a Heartbeat response packet.
In Figure 11 we have:
• Ts: The time at which the adversary sends the ﬁrst
DTLS packet, packet 1.
• Tf : The time at which the Heartbeat response packet
is sent by the receiver
• Te: The time at which the Heartbeat response packet
is received by the adversary.
• t1,0 − Ts: The time it takes for packet 1 to reach the
receiver.
• Te − Tf : The time it takes for the Hearbeat response
packet to reach the adversary after being sent by the
targeted system.
• Te − Ts: The RTT for the packet train.
Figure 11 shows the second data packet, packet 2, arriv-
ing after the completion of processing of packet 1 , i.e. so
that t2,0 > t1,3. The same applies to the Heartbeat request
packet arriving after the completion of processing of packet
2. In this situation, the receiver enters a wait state until the
next packet arrives and the arrival time of a packet and its
processing start time are the same. In general, this situa-
tion results in some or all of the timing difference arising
because of the MAC veriﬁcation being “absorbed” into the
wait state of the receiver, and hence is sub-optimal in terms
of detecting the time difference.
In the opposite situation, where packet 2 arrives before
processing of packet 1 is complete, packets are buffered.
Then packet 2 is immediately available for processing at
the receiver as soon as processing of packet 1 is complete,
and none of the MAC veriﬁcation time is absorbed. The
buffer is managed by OpenSSL and its maximum size is 100
DTLS packets. Figures 12 and 13 illustrate this situation for
packet trains having valid and invalid padding, respectively,
with the white boxes representing the amount of time spent
by packets in the buffer.
It is evident from these ﬁgures
how the time arising from MAC veriﬁcation (in the case of
valid padding) accumulates packet-by-packet to create an
ampliﬁed time difference in the RTT for the train.
The upshot of this analysis is that, from the adversary’s
perspective, it is desirable to select the attack parameters so
that the receiver’s buffer always contains some (but not too
many) packets. In this way, the receiver is never waiting for
a packet to arrive and the MAC processing time accumu-
lates across the whole packet train.
We have experimentally veriﬁed the essential basic cor-
rectness of this model for packet processing in the following
way. Let RT T1 denote the RTT for a train that uses packets
having valid padding, and let RT T2 denote the RTT for a
train that uses packets having invalid padding. Let δ denote
the time difference between the two RTTs, so that:
δ = RT T1 − RT T2
Then, if we artiﬁcially inject delays in between packets
from the train as they leave the adversary’s machine, we
would expect to see the value of δ steadily decrease and
eventually reach zero as the size of the artiﬁcial delay in-
creases. Figure 14 shows the results of such an experiment
which conﬁrms this behaviour. Somewhat surprisingly, Fig-
ure 14 also shows that adding small artiﬁcial delays can ac-
tually increase the time difference δ, making this difference
in RTTs easier for the adversary to detect.
Decryption and Padding Check
MAC Check OSt
ti,0
ti,1
ti,2
ti,3
Figure 9. Packet processing time-line – valid padding
Decryption and Padding Check
OSt
ti,0
ti,1 ti,3
Figure 10. Packet processing time-line – invalid padding
packet 1
t1,0
t1,1
t1,2
t1,3
packet 2
t2,0
t2,1
t2,2
t2,3
Heartbeat Request
Heartbeat Response
Tf
Te
Figure 11. Time-line for a train with n = 2 (not to scale).
Ts
packet 1
t1,0
t1,1
t1,2
t1,3
packet 2
t2,0
t2,1
t2,2
t2,3 Heartbeat Request
Ts
Heartbeat Response
Tf
Te
Figure 12. Time-line for packet train with valid padding and packet buffering.
packet 1
t1,0
t1,1
t1,3
packet 2
t2,0
t2,1
t2,3 Heartbeat Request
Ts
Heartbeat Response
Tf
Te
Figure 13. Time-line for packet train with invalid padding and packet buffering.
Figure 14. Value of δ, the difference in RTTs for valid and invalid padding, against artiﬁcial delay.
10203040500100200300400500600700ArtificialDelayTimeinMicroseconds