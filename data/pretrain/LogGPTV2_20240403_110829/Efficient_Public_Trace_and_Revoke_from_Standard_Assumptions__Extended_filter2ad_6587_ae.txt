by correctness of â„±â„°.
â„±â„°.Dec(skid, ğ¶1)
âŸ¨xid, vâ„›âŸ©
=
âŸ¨xid, ğ‘š Â· vâ„›âŸ©
âŸ¨xid, vâ„›âŸ© = ğ‘š,
â–¡
Now, we consider the implementation of Step (a) of Al-
gorithm Trace. The aim is to find ğ‘š, ğ‘šâ€² âˆˆ Zğ‘ such that an
encryption of ğ‘š has a non-negligible probability difference
of decrypting to ğ‘š and ğ‘šâ€² via ğ’ªğ’Ÿ. These plaintexts are
used for tracing as follows: the first probe ciphertext distribu-
tion will be a genuine encryption of ğ‘š, while the last probe
ciphertext distribution will be a genuine encryption of ğ‘šâ€².
(To see this, observe that for the last probe ciphertext, we
have ğ’®ğ‘– = âˆ… and vğ’®ğ‘– = (ğ‘šâ€² âˆ’ ğ‘š)Â· vâ„›. Consequently, we have
ğ¶ğ’®ğ‘– = (â„±â„°.Enc(pk, y),â„›) where y = vğ’®ğ‘– +ğ‘šÂ·vâ„› = ğ‘šâ€²Â·vâ„›.)
The fact that ğ’ªğ’Ÿ behaves differently for these two distribu-
tions ensures that there will be an ğ‘– such that |ğ‘ğ‘– âˆ’ ğ‘ğ‘–âˆ’1|
is non-negligible. Now, if the oracle ğ’ªğ’Ÿ was perfect, i.e., a
genuine encryption of ğ‘š always decrypts to ğ‘š for all ğ‘š,
then the existence of a pair (ğ‘š, ğ‘šâ€²) as in Step (a) would be
immediate. The difficulty is that the oracle ğ’ªğ’Ÿ only achieves
correct decryption with non-negligible advantage.
Lemma 3.2. Let â„› be arbitrary and assume that Equa-
tion (1) holds for â„›. Then, with probability â‰¥ 1/(4ğœ†ğ‘) over
the choice of ğ‘š, ğ‘šâ€² â†Ë’ â„³, we have:
âƒ’âƒ’âƒ’
]ï¸
[ï¸ğ’ªğ’Ÿ
[ï¸ğ’ªğ’Ÿ
Pr
ğ¶â†Ë’Enc(pk,â„›,ğ‘š)
âˆ’
Pr
ğ¶â€²â†Ë’Enc(pk,â„›,ğ‘šâ€²)
(ğ¶, ğ‘š) = 1
â€²
(ğ¶
, ğ‘š) = 1
]ï¸âƒ’âƒ’âƒ’ â‰¥ 1
2ğœ†ğ‘ .
Based on Lemma 3.2, Step (a) of Algorithm Trace can be
implemented by repeatedly sampling ğ‘š, ğ‘šâ€² â†Ë’ â„³ and esti-
mating the probabilities that ğ’ªğ’Ÿ(ğ¶, ğ‘š) = 1 and ğ’ªğ’Ÿ(ğ¶â€², ğ‘š) =
1 using Hoeffdingâ€™s bound, until the probability difference is
sufficiently large.
Proof. For ğ‘š, ğ‘šâ€² âˆˆ â„³, let ğ‘ƒ (ğ‘šâ€², ğ‘š) denote the proba-
bility that ğ’ªğ’Ÿ(ğ¶â€², ğ‘š) = 1, where ğ¶â€² â†Ë’ Enc(pd, pk,â„›, ğ‘šâ€²).
Equation (1) states that
ğ‘šâ†Ë’â„³ [ğ‘ƒ (ğ‘š, ğ‘š)] â‰¥ 1
Pr
|â„³| +
1
ğœ†ğ‘ .
Let us assume by contradiction (of the statement to be
proved), that
ğ‘š,ğ‘šâ€²â†Ë’â„³[|ğ‘ƒ (ğ‘š, ğ‘š) âˆ’ ğ‘ƒ (ğ‘š
Pr
â€²
, ğ‘š)|  1 âˆ’ 1
4ğœ†ğ‘ .
(2)
We show that if (2) holds, then the following inequality holds
as well.
Pr
ğ‘šâ€²â†Ë’â„³[ Pr
ğ‘šâ†Ë’â„³[|ğ‘ƒ (ğ‘š, ğ‘š)âˆ’ ğ‘ƒ (ğ‘š
â€²
, ğ‘š)|  1âˆ’ 1
2ğœ†ğ‘ ] >
.
1
2
(3)
By contradiction of (3) above, let us assume that
â€²
1
Pr
, ğ‘š)|  1âˆ’ 1
2ğœ†ğ‘ ] â‰¤ 1
2
.
â€²
, ğ‘š)| <
Pr
ğ‘š,ğ‘šâ€²[|ğ‘ƒ (ğ‘š, ğ‘š) âˆ’ ğ‘ƒ (ğ‘š
ğ‘šâ€² [Pr
1
|â„³|
= Pr
Pr
ğ‘š
=
ğ‘š
[|ğ‘ƒ (ğ‘š, ğ‘š) âˆ’ ğ‘ƒ (ğ‘š
â€²
1
2ğœ†ğ‘ ]]
[|ğ‘ƒ (ğ‘š, ğ‘š) âˆ’ ğ‘ƒ (ğ‘š
â€²
1
2ğœ†ğ‘ ]
, ğ‘š)| <
, ğ‘š)| <
1
2ğœ†ğ‘ ]
ğ‘šâ€²
âˆ‘ï¸
âˆ‘ï¸
âˆ‘ï¸
ğ‘šâ€²
of Type 1
of Type 2
+
1
|â„³|
â‰¤ 1
|â„³|
[|ğ‘ƒ (ğ‘š, ğ‘š) âˆ’ ğ‘ƒ (ğ‘š
â€²
, ğ‘š)| <
1
2ğœ†ğ‘ ]
Pr
ğ‘š
âˆ‘ï¸
1 +
1
|â„³|
(1 âˆ’ 1
2ğœ†ğ‘ )
ğ‘šâ€²
of Type 2
of Type 1
= ğ‘¥ + (1 âˆ’ ğ‘¥)(1 âˆ’ 1
ğ‘šâ€²
2ğœ†ğ‘ ) â‰¤ 1 âˆ’ 1
4ğœ†ğ‘ ,
âˆ‘ï¸€
We consider an ğ‘šâ€² of Type 1. Using the fact that
(ï¸‚
âˆ‘ï¸
âˆ‘ï¸
ğ‘š ğ‘ƒ (ğ‘šâ€², ğ‘š) â‰¤ 1, we obtain:
which would contradict (2) above.
)ï¸‚
â€²
ğ‘ƒ (ğ‘š, ğ‘š) <
ğ‘ƒ (ğ‘š
, ğ‘š) +
1
2ğœ†ğ‘
â‰¤ 1 +
|â„³|
2ğœ†ğ‘ +
ğ‘š
ğ‘š
This contradicts Equation (1).
|â„³|
ğœ†ğ‘ .
â–¡
Session K1:  Secure ComputationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA22853.2 Semantic Security
We start by proving IND-CPA security of our scheme.
Theorem 3.3. If â„±â„° is ğ‘Ÿ-IND-CPA secure, then ğ’¯ â„› is
IND-CPA secure.
Proof. Let ğ’œğ’¯ â„› be a probabilistic polynomial-time ad-
versary that breaks semantic security of ğ’¯ â„›. We construct
a probabilistic polynomial-time adversary ğ’œâ„±â„° that breaks
semantic security of â„±â„°. Adversary ğ’œâ„±â„° proceeds as follows.
âˆ™ It first obtains the public key pk output by the â„±â„°
challenger (who runs the â„±â„°.Setup(1ğœ†, 1â„“) algorithm)
and relays it to ğ’œğ’¯ â„›.
âˆ™ The adversary ğ’œğ’¯ â„› adaptively chooses at most ğ‘Ÿ iden-
tities id (that forms the revoked set â„›) and are included
in pd. The adversary ğ’œâ„±â„° then queries the â„±â„° chal-
lenger for each xid for all id âˆˆ â„› and receives the
corresponding skid. Adversary ğ’œâ„±â„° relays all skid for
each id âˆˆ â„› to ğ’œğ’¯ â„›.
âˆ™ When ğ’œğ’¯ â„› chooses two messages ğ‘š0, ğ‘š1 âˆˆ â„³ and
provides them to ğ’œâ„±â„° , adversary ğ’œâ„±â„° proceeds as
follows:
âˆ’ It computes vâ„› âˆˆ Zâ„“
ğ‘ âˆ– {âƒ—0} such that âŸ¨xid, vâ„›âŸ© = 0
for every id âˆˆ â„›.
âˆ’ It sends yâ„›,0 = ğ‘š0 Â· vâ„› and yâ„›,1 = ğ‘š1 Â· vâ„› to the
â„±â„° challenger who samples ğ‘ â†Ë’ {0, 1} and encrypts
yâ„›,ğ‘ as ğ¶yâ„›,ğ‘ â†Ë’ â„±â„°.Enc(pk, yâ„›,ğ‘).
âˆ’ Adversary ğ’œâ„±â„° receives ğ¶yâ„›,ğ‘ from the â„±â„° chal-
lenger and sends ğ¶ = (ğ¶yâ„›,ğ‘ ,â„›) to ğ’œğ’¯ â„›.
âˆ™ Finally, adversary ğ’œğ’¯ â„› outputs its guess ğ‘â€² âˆˆ {0, 1}
and ğ’œâ„±â„° also outputs ğ‘â€² as its own guess of ğ‘.
Note that adversary ğ’œâ„±â„° behaves as an IND-CPA challenger
in the view of ğ’œğ’¯ â„›. Further, it is a valid adversary against
â„±â„°, as âŸ¨yâ„›,0, xidâŸ© = âŸ¨yâ„›,1, xidâŸ© for every vector xid queried to
the â„±â„° challenger (i.e., each id âˆˆ â„›). The advantage of ğ’œâ„±â„°
is exactly the same as the advantage of ğ’œğ’¯ â„›.
â–¡
We may observe that for ğ’¯ â„› to be IND-CPA secure, an ğ‘Ÿ-
IND-CPA secure â„±â„° scheme is sufficient. However, as we see
below, for traceability with up to ğ‘¡ colluding traitors along
with ğ‘Ÿ already revoked users, we need an â„±â„° scheme that
is (ğ‘¡ + ğ‘Ÿ)-IND-CPA secure.
3.3 Traceability
Here, we prove the traceability of the scheme. To start with,
we first prove the following lemma.
Lemma 3.4. Assume that a pirate decoder ğ’Ÿ satisfies Equa-
tion (1) for some â„› and ğ’®. Then, the execution of Trace does
not return âŠ¥ but returns some id âˆˆ ğ’® with overwhelming
probability.
Proof. We consider a variant of Trace that continues its
execution until it exhausts ğ’®âˆ–â„›, even if it has already output
an id. We consider the probabilities ğ‘ğ‘– at the start and end
of that modified execution.
(1) At the beginning, algorithm Trace considers ğ’®1 = ğ’®âˆ–â„›
and vğ’®1 = 0. Hence, the genuine ciphertext output by
the Enc algorithm and the probe ciphertext created
by the Trace algorithm for the suspect subset ğ’®1 are
exactly the same.
(2) When ğ‘– = |ğ’® âˆ– â„›| + 1, we have ğ’®ğ‘– = âˆ… and vğ’®ğ‘– =
(ğ‘šâ€² âˆ’ ğ‘š) Â· vâ„›. In Step (a) of the Trace algorithm, the
messages ğ‘š and ğ‘šâ€² were chosen such that the difference
in the probabilities ğ‘1 and ğ‘|ğ’®âˆ–â„›|+1 is â‰¥ 1/(2ğœ†ğ‘).
Note that the two latter observations imply, via the triangle
inequality, that there exists an ğ‘– such that |ğ‘ğ‘– âˆ’ ğ‘ğ‘–âˆ’1| is non-
negligible. By the Hoeffding bound, Trace algorithm outputs
â–¡
idğ‘–âˆ’1 with overwhelming probability.
Then, we prove the following theorem.
Theorem 3.5. If â„±â„° is (ğ‘¡ + ğ‘Ÿ)-IND-CPA secure, then ğ’¯ â„›
satisfies public traceability.
Proof. Let us assume by contradiction that an adversary
ğ’œ can break the public traceability of ğ’¯ â„› with non-negligible
probability. We then construct a probabilistic polynomial-
time adversary ğ’œâ„±â„° that breaks the semantic security of â„±â„°.
Adversary ğ’œâ„±â„° proceeds as follows.
âˆ™ It first obtains the public key pk output by the â„±â„°
challenger (who runs the â„±â„°.Setup(1ğœ†, 1â„“) algorithm)