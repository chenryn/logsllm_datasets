os::PlatformEvent:spark (long) [clone -part.12]
Monitor::INait (Thread*, long)
Monitor:ait (bool, Long, boo1)
KatchezThszead::sleep l} const
KatcherThread::run ()
thread_native_entry (Thread*)
start_thread
clone
VM Periodic Tas 122029)
TOS0L66
The output has been truncated as it was many pages long. A few interesting stacks have been
included here to discuss.
The first shows Java blocking for 5.1 milliseconds (S717 us) in total on a safepoint, which was
handled using a futex lock in the kernel. These times are totals, so this 5.1 ms may include multi-
ple blocking events.
---
## Page 593
556
8Chapter 12 Languages
The last stack shows Java blocking in pthread_cond_timedwait() for almost the same 10-second
duration of the trace: it is a WatcherThread waiting for work, with the thread name *VM Periodic
Tas* (runcated to appear without the *k*). For some appliation types that use many threads that
wait for work, the output of offcputime(8) can be dominated by these waiting stacks, and you
need to read past them to find the stacks that matter: the wait events during application requests.
The second stack surprised me: it shows Java blocked on an unlink(2) syscall, to delete a file,
which ended up blocking on disk I/O (io_schedule() etc). What files is freecol deleting during
gameplay? A bpftrace one-liner to show unlink(2) with the pathname deleted reveals:
,u\,sg,) gau2d 1/t69t == prd/ xurunzaguse:treose:a, o- aoezdq +
str (args->pathnane)) : 1 *
Attach.ing l probe...
/hone/bgregg/ . 1ocal/shaze/freecol/save/autosave/Autosave-be fore
/home/bgregg/-1ocal/zhsre/freeco1/save/autosave/Rutosave-before
[.--]
freecol is deleting auto savegames.
libpthread Stacks
Since this may be a commonly seen issue, here is how the final stack looked with a default install
patpdq o
finish_task_swltch
schedule
futex_xal t_gqueve_ne
futex_xait
do_futex
SyS_futex
do_aysca11_64
entry_SYsCALL_64_after_hframe
pthzead_cond_tinedvalt
VM Per1odic Tas (16936)
9934452
The stack ends at pthread_cond_timedwaito. The current default libpthread that is shipped with
uogezudo saduoo e '1eutodsuexgtwog tm padoo uaaq seu suopnqsp xnur sure
that breaks frame pointer-based stack walking, My earlier example used my owm compiled version of
libpthread with fno=om1 tfranepo1n ter. See Section 2.4 in Chapter 2 for more about this.
Off-CPU Time Flame Graphs
The output of offcputime(8) was hundreds of pages long. To navigate it more quickly, it can be used
to generate off-CPU time flame graphs. Here is an example using the FlameGraph software [37]:
+ jmaps; offoputine -fp 16914 10 > out.offcpa01.txt
Fetching maps for all java processes..
Mapping PI0 16914 (user bgregg) :
---
## Page 594
12.3Java557
vc 11) :  12015 37080 768710 /tnp/perf-16914.map
flanegzaph -pl --color=java --bgcolor=blue --hash
\008=PTa-
-title=*off-Cru Time Flame Graph*  out,offcpa01.svg
This generated the graph shown in Figure 12-5.
Figure 1.2-5 off-CPU time flame graph
The top of this flame graph has been truncated. The width of each frame is relative to the
blocked off-CPU time. Since offcputime(8) is showing stack traces with their total blocking time
in microseconds, the =coun tname=us option to flamegraph.pl is used to match this, which
changes the information shown for mouse-overs. The background color was also changed to
blue, as a visual reminder that this is showing blocking stacks. (CPU flame graphs use a yellow
background.)
This flame graph is dominated by threads waiting for events. Since the thread name is included as
the first frame in the stack, it groups threads with the same name together as a tower. Each tower
in this flame graph shows waiting threads.
But I am not interested in threads waiting for events: I am interested in threads waiting during
an application request. This application was freecol, and using the flame graph search feature for
*freecol* highlighted those frames in magenta (see Figure 12-6).
---
## Page 595
558Chapter 12Languages
Figure 1.2-6 Off-CPU time flame graph, searching for application code
Using click-to-zoom on the narrow third tower showed code during the game (see Figure 12-7).
Figure 1.2-7 Off-CPU time flame graph zoomed
---
## Page 596
12.3Java 559
The graph shown in Figure 12-7 shows the blocking paths in freecol, providing targets to begin
optimizing. Many of these frames were still *Interpreter*, as the JVM had not executed that
method enough times to hit the CompileThreshold.
Sometimes the application code paths can be so narrow due to other waiting threads that they
are elided from the flame graph. One approach to solve this is to use grep(1) at the command line
to include only the stacks of interest. For example, matching those containing the application
 grep freecol out.offcpu01.txt I flanegraph.pl ... > out.offcpu01.svg
It is one of the benefits of the folded-file format for stack traces: it can be easily manipulated as
needed before generation as a flame graph.
12.3.9stackcount
The BCC stackcount(8) tool, covered in Chapter 4, can collect stacks on any event, which can
show the libjvm and Java method code paths that led to the event. For stackcount(8) to work with
Java, see Section 12.3.7.
For example, using stackcount(8) to show user-level page faults, which is a measure of main
memory growth:
 stackcount =p 16914 t:exceptions:page_fault_user
Tracing 1 functions for *tiexceptions:page_fault_user*... Hit Ctrl-C to end.
[..-]
do_page_fault
poge_fault
Interpreter
Lnet/sf /freeco1/server/contro1/ChangeSet$MoveChangez1:con.sequences
[unknown]
[unknoxn]
Lnet/af/fxeeco1/sexvez/contzo1/InGaneContro1lez:::nove
Lnet/sf /freeco1/conmon/netvorking/MoveMessagez1 :handle
Lnet/af/fxeeco1/sexvez/contzo1/InGaneInputHandler$37; : :handle
Lnet/sf/freeco]/connon/ne tworking/OurrentPlayeretvorkRequestHandler, ::handIe
[unknovn]
Lnet/sf/freeco1/server/ai/AIMessage:1task
Lnet/af/freeco1/sexvez/a1/AIMessage: ::askHandling
Lnet/sf/freeco1/server/ai/aIUnit/iimove
Lnet/af/freeco1/sexvez/a1/nission/Mi sLon,: :noveRandonly
Lnet/sf/freeco1/server/ai/mission/UnitManderBostileMission,1:doMission
Llava/avt/Contalnex;::LsParen tOf
---
## Page 597
560
Chapter 12 Languages
[unknovn]
Lcom/sun/org/apache/xeroes/1ntexmal/1np1/x0MLEnt1tySca
nnex,::reset
ca11_stub
JavaCalls::call_helpez (JavaValue*, nethodBandle consta, JavaCallArgunents*, Thre.. -
JavaCalls::cal1_virtual (JavaValue*, Handle, Klass*, Symbo1*, Symbol*, Thread*)
thread_entry (JavaThread*, Thxead*)
JavaThread: :thread_nain_inner ()
Thzead: :ca11_run (1)
thread_native_entry ITh.resad*)
pesxqxes
[...]
do_page_fault
page_fault
sux7x.easus
PhaseChaitlni:Regiater_Allocate ()
Compile::Code_Gen ()
Comspile::Comp1le |c1Env+, C2Conp1lex*, ciMethod*, 1nt, boo1, bool, boo1, Dizectiv.. .
C2Compiler:icompile_method (ciEnv*, ciMethod*, int, DirectiveSet*)
Comp11eBzokex::1nvoke_compi1er_on_nethod (Conpi1eTask*)
CompileBroker::compiler_thread_loop 1)
JavaThread: ithread_naln_Innex ()
Thread: :ca11_run.11
thzead_native_entry (Thread*)
start_thread
414
Although many stacks were shown, only two have been included here. The first shows a page fault
through freecol ai code; the second is from the JVM C2 compiler generating code.
Page Fault Flame Graph
A flame graph can be generated from the stack count output to aid browsing. For example, using
the FlameGraph software [37]:
+ jmaps; stackcount -p 16914 t:exceptions:page_fault_user > out faults01.txt
Fetching naps for all java processes...
Mapping PI0 16914 (user bgregg) :
vc (1) :  12015 37080 768710 /trp/pexf-16914.nap
+ stackco1lapse-pl169T == prd/ zesntnegsfed:suotdeoxe:3. 8- gesun-- 8oexagdq 
[kstack, ustack, conn] = count() : 1 黑ND { systen("jmaps") : 1′
Attach.ing 1 pzobe..-
^C
[.--]
07+aTnega6edop
page_fault+69
---
## Page 599
562
Chapter 12 Languages
0x7fa369bbef2d
PhaseChaltin: tReglster_Al1ocate () +930
Compi le::Code_Gen () +650
Conplle::Conp1le (ciEnv*, C2Conpiler*, ciNethod*, int, bool, bool, bool, Dlrect.. .
C2Conpilerirconpile_method(ciEnv*, ciMethod*, int, DirectiveSet*)+188
Conp1leBroker::Invoke_conp1 1ex_on_sethod (Conp11eTask*) +1016
Compi leBrokerirconpiler_thread_loop ()+1352
JavaThzead: : thread_main_Innez () +44 6
Th.read: :cal1_run () +376
8E2+(peexua) /xueestaeupeeau
start_thread+219
 C2 CospilerThre] : 3
[..-]
The execution of the maps for Java method symbols has been moved to the END clause, so it is
run immediately before the stacks are printed out.
12.3.10
javastat
javastat(8)# is a BCC tool that provides high-level Java and JVM statistics. It refreshes the screen
freecol game:
similarly to top(1), unless the C option is used. For example, running javastat(8) for the Java 
 javastat -C
Tracing... Output every 1 secs. Hit Ctel-C to end
14:16:56 1oadavg: 0.57 3.66 3,93 2/3152 32738
PID
CMDLINE
METHOD/s
GC/s
OBJNEX/s
CL0AD/ s
EXC/sTHR/s
32447
/home/bgregg/Bu11α/o 0
0
169
D
14:16:58 1oadavg: 0.5T 3.66 3.93 8/3157 32744
PID
CHDLINE
KETHOD/s
GC/s
OBJNEX/s
CLOAD/ s
EXC/s THR/s
32447
/home/bgregg/Bui1d/o 0
Q
730
522
14:16:59 1oadavg: 0.69 3.64 3.92 2/3155 32747
PID
/home/bgregg/Bu11d/α 0
CMDLINE
METHOD/s
GC/s
OBJNEX/s
CL0AD/ s
EXC/sTHR/s
32447
Z
O
484
1
[..]
14 0rigin: This wss crested by Sasha Goldshtein as 8 wrapper to his ustat(8) tool from 26-0ct-2016. 1created a similar
tool for DTrace called j_stat.d on 9-Sep-2007 to demonstrate these new probes in the DTraceToolkit
---
## Page 600
12.3Java 563
The columns show:
 PID: Process ID.
• CMDLINE: Process command line. This example has truncated the path to my custom JDK
build.
• METHOD/s: Method calls per second.
 GC/s: Garbage collection events per second.
• OBJNEW/s: New objects per second.
 CLOAD/s: Class loads per second.
• EXC/s: Exceptions per second.
THR/s: Threads created per second.
This works by using Java USDT probes. The METHOD/s and OBJNEW/s columns will be zero
unless the XX: +ExtendedDTra ce Probe.s option is used, which activates those probes, however,
with a high overhead cost. As described earlier, an application may run 10 times slower with these
probes enabled and instrumented.
Command line usage:
javastat[options][1nterval[count]]
Options include:
 -C: Don’t clear the screen
javastat(8) is really a wrapper to a ustat(8) tool in BCC's tools/lib directory, which handles
multiple languages.
12.3.11 javathreads
javathreads(8) is a bpfrace tool to show thread start and stop events. Example output for when
freecol was started:
Attaching 3 pzobes...
TIME
PID/TID  -- THREAD
14:15: 00
3892/3904
=> Reference Handler
14 :15 : 00
3892/3905
=> Finslizer
14:15:00
3892/3906
zsuoqedsTα teubTs 
C2 CorpilerThread0
14 :15 : 00
3892/3908
pea3v1 1adsaxg  C1 CorpilerThread0
14 :15 : 00
3892/3909
14 :15 : 00
3892/3910
=> Connon-Cleaner
15 0rigin: I crested this for this book on 19-Feb-2019,
---
## Page 601
564
Chapter 12 Languages
14 :15: 01
3892/3911 => C2 ConpilerThread1
14:15:01
3892/3912
pesxs 8ot.xeg  C2 ConpilezThzead1
14 :15 : 02
3892/3935
=> FreeCo1Client:-Resource Losder
14 :15 : 02
3892/3937
 => FreeCo1Client:Norker
14:15 : 02
3892/3935
 FzeeCo1Cllent:=Resouxce 1oader
14:15 : 02
3892/3939
=> Image Fetcher 0
14 :15 : 03
3892/3952
=> FreeCo1Client:Resouxce Loader
[...]
This shows the creation and execution of threads and also some that were short-lived and
finished during tracing (* 5s^n", p1d, tid, str (arg0, argll);
usdt:/.../libjvm.so:hotspot:thread_stop
t.ime (*B:M:s *) 
printf(*s6d/s=5d <= ssn", pld, tid, str (argo, arg1l)
The path to the library has been truncated in this source (*...*) but needs to be replaced with your
libjvm.so library path. In the future bpftrace should also support specifying the library name
without the path, so that this can simply be written as *libjvm.so*.
---
## Page 602
12.3Java 565
12.3.12 javacalls
javacalls(8) # is a BCC and bpftrace tool that counts Java method calls. For example:
+ javacalls 16914
Tracing calls 1n process 16914 (language: javal ..- Ctrl-C to quit.
If you do not see any results, make sure you ran java xith option -X:
+ExtendedDTraceProbes
^C
KETHOD
CALLS
net/sf/freeco1/client/contro1/InGameInputHandler$$Lanbda$443,get$Lanbda
sun/avt/X11/xXindovPeer , getLocalHostname
net/sf/freecol/conmon/model/vni tType,getSpace
T
1
[..-]
jara/avt/image/Raster-getHeight
129668