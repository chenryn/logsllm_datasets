use 2 bits. Another important difference is our support
for implicit ﬂows, which are not handled in [22].
Dynamic Taint Based Techniques for Detecting At-
tacks on Web Applications.
Independently and in par-
allel to our work, which ﬁrst appeared in [33], [23] and
[24] have proposed the idea of using ﬁne-grained taint
analysis to detect injection attacks on web applications.
The implementations of [23] and [24] are very similar,
using hand-transformation of the PHP interpreter to track
taint data. However, [24] provides a more detailed for-
mulation and discussion of the problem, so we focus on
this work here. They explain that these injection attacks
are the result of ad hoc serialization of complex data such
as SQL queries or shell commands, and develop a de-
tection technique called context-sensitive string evalua-
tion (CSSE), which involves checking the use of tainted
data in strings. Our work improves over theirs in sev-
eral ways. First, by working at the level of the C lan-
guage, we are able to handle many more applications:
most server programs that are written in C, as well as
programs written in interpreted languages such as PHP,
bash and so on. Second, our formulation of the prob-
lem as taint-enhanced policy enforcement is more gen-
eral, and can be applied to stealthy attacks such as those
discussed in Section 2 that do not involve serialization
problems; and to attacks involving arbitrary types of data
rather than being limited to strings. Third, our approach
relies on a simple transformation that is shown in Section
3, and implemented using 3.6KLOC of code, while their
approach relies on manual transformation of a large piece
of software that has over 300KLOC. Other technical con-
tributions of our work include (a) the development of a
simple policy language for concise speciﬁcation of taint-
enhanced polices, and (b) support for implicit ﬂows that
allow us to provide some support for character encodings
and translations.
As discussed in Section 7, Su et al [27] describe a tech-
nique for detecting SQL injection attacks using syntax
analysis. Their main focus is on providing a precise and
formal characterization of SQL injection attacks. How-
ever, their implementation of taint tracking is not very
reliable.
In particular, they suggest a technique that
avoids runtime operations for taint-tracking by “brack-
eting” each input string with two special symbols that
surround untrusted input strings. Assuming that these
brackets would be propagated together with input strings,
checking for the presence of taint would reduce to check-
ing for the presence of these special symbols. However,
this assumption does not hold for programs that extract
parts of their input and use them, e.g., a web applica-
tion may remove non-alphanumeric characters from an
input string and use them, and this process would likely
discard the bracketing characters. In other cases, a web
application may parse a user input into multiple ﬁelds,
and use each ﬁeld independently, once again causing the
special symbols to be lost.
Manual Approaches for Correcting Input Validation
Errors. Taint analysis targets vulnerabilities that arise
due to missing or incorrect input validation code. One
can manually review the code, and try to add all the nec-
essary input validation checks. However, the notion of
validity is determined by the manner in which the input
134
Security ’06: 15th USENIX Security Symposium
USENIX Association
is used. Thus, one has to trace forward in the program to
identify all possible uses of an input in security sensitive
operations, which is a very time-consuming and error-
prone task. If we try to perform the validation check at
the point of use, we face the problem that the notion of
validity depends on the data source. For instance, it is
perfectly reasonable for an SQL query to contain semi-
colons if these originated within the program text, but
not so if it came from external input. Thus, we have
to trace back from security-sensitive operations to iden-
tify how its arguments were constructed, once again hav-
ing to manually examine large number of program paths.
This leads to situations where validation checks are left
out on some paths, and possibly duplicated on others.
Moreover, the validation checks themselves are notori-
ously hard for programmers to code correctly, and have
frequently been the source of vulnerabilities.
Information Flow.
Information ﬂow analysis has been
researched for a long time [1, 10, 8, 18, 30, 20, 25]. Early
research was focused on multi-level security, where ﬁne-
grained analysis was not deemed necessary [1]. More re-
cent work has been focused on tracking information ﬂow
at variable level, and many interesting research results
have been produced. While these techniques are promis-
ing for protecting privacy and integrity of sensitive data,
as discussed in Section 2, the variable-level granularity
is insufﬁcient for detecting most attacks discussed in this
paper.
Static Analysis. Static taint analysis techniques have
been proposed by many for ﬁnding security vulnerabil-
ities, including input validation errors in web applica-
tions [17, 14, 32], user/kernel pointer bugs [15], format
string bugs [26], and bugs in placement of authorization
hooks [34]. The main advantage of static analysis (as
compared to runtime techniques) is that all potential vul-
nerabilities can be found statically, while its drawback is
a relative lack of accuracy. In particular, these techniques
typically detect dependencies rather than vulnerabilities.
For instance, [17] will produce a warning whenever un-
trusted data is used in any manner in an SQL query. This
may not be very useful if such a dependency is an inte-
gral part of application logic. To solve this problem, the
concept of endorsement can be used to indicate “safe”
dependencies. Typically, this is done by ﬁrst perform-
ing appropriate validation checks on a piece of untrusted
data, and then endorsing it to indicate that it is safe to
use (i.e., no longer “tainted”). However, programmers
are still responsible for determining what is “safe” — as
discussed before, there is no easy way for them to do this.
An important difference between our work and static
analysis is one of intended audience. Static analysis
based tools are typically intended for use by developers,
since they need detailed knowledge about program logic
to determine where to introduce endorsements, and what
validation checks need to be made before endorsement.
In contrast, the audience for our tool is a system admin-
istrator or an outside security engineer that lacks detailed
knowledge of application code.
Other Techniques. SQLrand [4] defeats SQL injec-
tion by randomizing the textual representation of SQL
commands. A drawback of this approach, as compared
to the technique presented in this paper, is that it requires
manual changes to the program so that the program uses
the modiﬁed representation for SQL commands gener-
ated by itself. Our approach was inspired by the ef-
fect achieved by SQLrand, namely, that of distinguish-
ing commands generated by the application from those
provided by untrusted users.
AMNESIA[12] is another interesting approach for de-
tecting SQL injection attacks. It uses a static analysis of
Java programs to compute a ﬁnite-state machine model
that captures the lexical structure of SQL queries issued
by a program. SQL injection attacks cause SQL queries
issued by the program to deviate from this model, and
hence detected. A key beneﬁt of this approach is that by
using static analysis, it can avoid runtime taint-tracking,
and is hence much more efﬁcient than our approach. Al-
though this approach has been demonstrated to work well
for SQL injections, the conservative nature of its static
analysis and its inability to distinguish different sources
of inputs can lead to a higher rate of false positives when
applied to other types of attacks.
Perl has a taint mode [31] that tracks taint information
at a coarse granularity – that of variables. In Perl, one
has to explicitly untaint data before using it in a secu-
rity sensitive context. This is usually done after perform-
ing appropriate validations. In our approach, due to the
ﬂexibility provided by our policy language, we have not
faced a need for such explicit untainting. Nevertheless,
if a user explicitly wants to trust some input, a primitive
can be easily added to support this.
9 Conclusion
In this paper, we presented a uniﬁed approach that ad-
dresses a wide range of commonly reported attacks that
exploit software implementation errors. Our approach
is based on a fully automatic and efﬁcient taint analy-
sis technique that can track the ﬂow of untrusted data
through a program at the granularity of bytes. Through
experiments, we showed that our technique can be ap-
plied to different types of applications written in multiple
programming languages, and that it is effective in detect-
ing attacks without producing false positives.
We believe that a number of software vulnerabilities
arise due to the fact that security checks are interspersed
throughout the program, and it is often difﬁcult to check
USENIX Association
Security ’06: 15th USENIX Security Symposium
135
if the correct set of checks are being performed on every
program path, especially in complex programs where the
control ﬂows through many, many functions. By decou-
pling policies from application logic, our approach can
provide a higher degree of assurance on the correctness
of policies. Moreover, the ﬂexibility of our approach al-
lows site administrators and third parties to quickly de-
velop policies to prevent new classes of attacks, without
having to wait for patches.
Acknowledgments
This research was supported in part by an ONR grant
N000140110967 and NSF grants CNS-0208877 and
CCR-0205376.
References
[1] D. E. Bell and L. J. LaPadula. Secure computer systems: Math-
ematical foundations. Technical Report MTR-2547, Vol. 1,
MITRE Corp., Bedford, MA, 1973.
[2] S. Bhatkar, D. C. DuVarney, and R. Sekar. Address obfuscation:
An efﬁcient approach to combat a broad range of memory error
exploits. In USENIX Security Symposium, August 2003.
[3] T. Bowen, D. Chee, M. Segal, R. Sekar, T. Shanbhag, and P. Up-
puluri. Building survivable systems: An integrated approach
based on intrusion detection and damage containment. In DIS-
CEX, 2000.
[4] S. W. Boyd and A. D. Keromytis. SQLrand: Preventing SQL
injection attacks. In International Conference on Applied Cryp-
tography and Network Security (ACNS), pages 292–302, 2004.
[5] S. Chen, J. Xu, N. Nakka, Z. Kalbarczyk, and R. K. Iyer. Defeat-
ing memory corruption attacks via pointer taintedness detection.
In IEEE International Conference on Dependable Systems and
Networks (DSN), 2005.
[6] C. Cowan, M. Barringer, S. Beattie, and G. Kroah-Hartman. For-
matGuard: Automatic protection from printf format string vul-
nerabilities. In USENIX Security Symposium, 2001.
[7] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie,
A. Grier, P. Wagle, Q. Zhang, and H. Hinton. Automatic de-
tection and prevention of buffer-overﬂow attacks.
In USENIX
Security Symposium, 1998.
[8] D. E. Denning and P. J. Denning. Certiﬁcation of programs for se-
cure information ﬂow. Communications of the ACM, 20(7):504–
513, July 1977.
[9] H. Etoh and K. Yoda.
Protecting from stack-smashing at-
http://www.trl.ibm.com/projects/security/ssp/main.html,
tacks.
June 2000.
[10] J. S. Fenton. Memoryless subsystems. Computing Journal,
17(2):143–147, May 1974.
[11] J. Goguen and J. Meseguer. Security policies and security mod-
els. In IEEE Symposium on Security and Privacy, 1982.
[12] W. Halfond and A. Orso. AMNESIA: Analysis and monitoring
for neutralizing SQL-injection. In IEEE/ACM International Con-
ference on Automated Software Engineering (ASE), 2005.
[13] N. Hardy. The confused deputy:
(or why capabilities might
have been invented). ACM SIGOPS Operating Systems Review,
22(4):36–38, October 1988.
[14] Y.-W. Huang, F. Yu, C. Hang, C.-H. Tsai, D. Lee, and S.-Y. Kuo.
Securing web application code by static analysis and runtime pro-
tection. In International World Wide Web Conference, 2004.
[15] R. Johnson and D. Wagner. Finding user/kernel pointer bugs with
type inference. In USENIX Security Symposium, 2004.
[16] G. S. Kc, A. D. Keromytis, and V. Prevelakis. Countering code-
injection attacks with instruction-set randomization.
In ACM
Conference on Computer and Communication Security (CCS),
2003.
[17] V. B. Livshits and M. S. Lam. Finding security vulnerabilities in
Java applications with static analysis. In USENIX Security Sym-
posium, 2005.
[18] J. McLean. A general theory of composition for trace sets closed
In IEEE Symposium on
under selective interleaving functions.
Security and Privacy, pages 79–93, May 1994.
[19] S. McPeak, G. C. Necula, S. P. Rahul, and W. Weimer. CIL: In-
termediate language and tools for C program analysis and trans-
formation. In Conference on Compiler Construction, 2002.
[20] A. C. Myers.
JFlow: Practical mostly-static information ﬂow
control. In ACM Symposium on Principles of Programming Lan-
guages (POPL), pages 228–241, Jan. 1999.
[21] N. Nethercote and J. Seward. Valgrind: A program supervision
framework. In Workshop on Runtime Veriﬁcation (RV), Boulder,
Colorado, USA, July 2003.
[22] J. Newsome and D. Song. Dynamic taint analysis for automatic
detection, analysis, and signature generation of exploits on com-
modity software.
In Network and Distributed System Security
Symposium (NDSS), 2005.
[23] A. Nguyen-Tuong, S. Guarnieri, D. Greene, J. Shirley, and
D. Evans. Automatically hardening web applications using pre-
cise tainting.
In 20th IFIP International Information Security
Conference, 2005.
[24] T. Pietraszek and C. V. Berghe. Defending against injection at-
tacks through context-sensitive string evaluation. In Recent Ad-
vances in Intrusion Detection (RAID), 2005.
[25] A. Sabelfeld and A. C. Myers. Language-based information-ﬂow
security. IEEE J. Selected Areas in Communications, 21(1), Jan.
2003.
[26] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner. Detecting
format string vulnerabilities with type qualiﬁers. In USENIX Se-
curity Symposium, 2001.
[27] Z. Su and G. Wassermann. The essence of command injection
attacks in web applications. In ACM Symposium on Principles of
Programming Languages (POPL), January 2006.
[28] G. E. Suh, J. W. Lee, D. Zhang, and S. Devadas. Secure pro-
gram execution via dynamic information ﬂow tracking. In Inter-
national Conference on Architectural Support for Programming
Languages and Operating Systems, pages 85–96, Boston, MA,
USA, 2004.
[29] P. Uppuluri and R. Sekar. Experiences with speciﬁcation based
In proceedings of the Recent Advances in
intrusion detection.
Intrusion Detection conference, October 2001.
[30] D. Volpano, G. Smith, and C. Irvine. A sound type system for
secure ﬂow analysis. Journal of Computer Security, 4(3):167–
187, 1996.
[31] L. Wall, T. Christiansen, and R. Schwartz. Programming Perl.
O’Reilly, 1996.
[32] Y. Xie and A. Aiken. Static detection of security vulnerabilities
in scripting languages. In USENIX Security Symposium, 2006.
[33] W. Xu, S. Bhatkar, and R. Sekar. Practical dynamic taint analysis
for countering input validation attacks on web applications. Tech-
nical Report SECLAB-05-04, Department of Computer Science,
Stony Brook University, May 2005.
[34] X. Zhang, A. Edwards, and T. Jaeger. Using CQual for static
analysis of authorization hook placement. In USENIX Security
Symposium, 2002.
136
Security ’06: 15th USENIX Security Symposium
USENIX Association