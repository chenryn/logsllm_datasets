gaj·s·M∗
i,j )−1
(cid:89)
j=1,...,n∗
= gaλiδ
i = gr(cid:48)
j=1,...,n∗
−r(cid:48)
i−s·bi
2,x∗
k∈Ri
= gaλiδ
However, if T ∈R GT , the challenge ciphertext is independent of the bit b in the view of A.
5. Query Phase II. Same as Query Phase I but with the constraints deﬁned in Deﬁnition 4.
6. Guess. A outputs a guess bit b(cid:48) ∈ {0, 1}. If b(cid:48) = b, C outputs 1 (i.e. deciding T = e(g, g)aq+1·s);
−ri
2,x∗ = gaλiH3(x∗)−ri = gaλiH3(ρ∗(i))−ri, C∗
otherwise, C outputs 0 (i.e. deciding T ∈R GT ).
We ﬁrst analyze the simulations of the random oracles. Clearly, the simulations of the oracles are
2 be the events that A has queried (mb, β∗) to H1 and
perfect except H1 and H2. Let H∗
R∗ = e(g, g)α·s to H2 before the challenge phase, respectively, where β∗, b ∈ {0, 1} are chosen by C in
the challenge phase. Except for the cases above, the simulations of H1 and H2 are perfect. We denote
i+s·bi = gri.
1 and H∗
20
1 ,A the probability of A in successfully querying (mb, β∗) from H1 before the challenge phase.
by AdvT CR
H∗
Similarly, we have AdvT CR
2 ,A.
H∗
In the simulation of the private key generation, the responses to A are perfect. As to the simulation
of the re-encryption key queries, the responses to A are also perfect except for the case where the re-
encryption key is randomly generated. It can be seen that rk1, rk2, rk3 and Rx (which are generated
by C) can take the form of the corresponding components of the valid re-encryption key, respectively.
Hence, the indistinguishability between the random re-encryption key and the valid one depends on
the indistinguishability between the encryption generated by C and the one constructed in the real
scheme. If A can distinguish the encryptions above, then C can break the decisional q-parallel BDHE
problem using A. As for the simulation given in the challenge phase, it is perfect as well.
In the simulation of the re-encryption queries, the responses to A are perfect with the exception
that A submits a valid original ciphertext which is generated without issuing the query to H1. We
denote by P r[ReEncErr] the probability of the above exception. Then, we have P r[ReEncErr] ≤ qre
p ,
where qre is the total number of re-encryption queries.
In the simulation of decryption queries, it might be possible that C cannot provide a decryption
for a valid ciphertext. Suppose A can generate a valid ciphertext without querying e(g, g)α·s to H2,
where s = H1(m, β). Let valid be the event that the original ciphertext or the re-encrypted ciphertext
is valid, QueryH1 be the event that A has queried (m, β) to H1 and QueryH2 be the event that A
has queried e(g, g)α·s to H2. From the simulation, we have
P r[valid|¬QueryH2] ≤ P r[QueryH1|¬QueryH2] + P r[valid|¬QueryH1 ∧ ¬QueryH2] ≤ qH1
and P r[valid|¬QueryH1] ≤ qH2
p , where qH1 and qH2 are the maximum number of random or-
acle queries to H1 and H2. Let P r[DecErr] be the probability that the event valid|(¬QueryH1 ∨
p ) · (qd1 + qd2), where qd2 and qd1 denote
¬QueryH2) occurs, then we have P r[DecErr] ≤ (
the total numbers of original ciphertext decryption queries and re-encrypted ciphertexts decryption
queries.
22k + 2
22k + 1
22k +
qH1 +qH2
1
p
Let Bad denote the event that (H∗
1|¬H∗
2 ) ∨ H∗
2 ∨ ReEncErr ∨ DecErr. Then we have
2 ∨ ReEncErr ∨ DecErr]
P r[(H∗
2 ) ∨ H∗
1 = |P r[b(cid:48) = b] − 1
| ≤ 1
1|¬H∗
2
2
qH1 + (qH1 + qH2) · (qd1 + qd2)
P r[Bad] =
1
2
≤ 1
2
(AdvT CR
H∗
2 ,A +
22k
+
2(qd1 + qd2) + qre
p
).
Therefore, AdvD−q−parallelBDHE
2 ,A) ≥ 1
H∗
qH2
From the simulation, the running time of C is bound by
≥ 1
qH2
(AdvT CR
A
(21− qH1 +(qH1 +qH2 )·(qd1 +qd2 )
22k
− 2(qd1 +qd2 )+qre
p
).
t(cid:48) ≤ t + O(1)(qH1 + qH2 + qH3 + qH4 + qH5 + qH6 + qsk + qrk + qre + qd2 + qd1)
+ te(qskO(n∗2) + (qrk + qre)O(f ) + (qd2 + qd1)O(l) + qH1(qre + qd2 + qd1)O(1))
+ tp((qre + qd2 + qd1)O(l)),
where qHi denotes the total number of random oracle queries to Hi (i ∈ {1, 2, 3, 4, 5, 6}), qsk and qrk
denote the total numbers of private key extraction queries and re-encryption key extraction queries,
te denotes the running time of an exponentiation in group G, tp denotes the running time of a pairing
in group GT , t is the running time of A, l is the number of rows of matrix.
This completes the proof of Theorem 2.
2
B.2 Proof of Theorem 3
Proof. Suppose there exists an adversary A who can break the IND-sAS-CCA-Re security of our
scheme. We then construct a reduction algorithm C to plays the decisional q-parallel BDHE problem.
C takes in (p, g, G, GT , e) ← BSetup(1k) and a q-parallel BDHE instance y and T ∈ GT , where T
is either equal to e(g, g)aq+1·s or to T (cid:48) ∈R GT .
1. Initialization. Same as the proof of Theorem 2.
2. Setup. Same as the proof of Theorem 2.
3. Query Phase I. Same as the proof of Theorem 2 but with constraints deﬁned in Deﬁnition 5.
4. Challenge. A outputs (M, ρ), m0 and m1 to C. C chooses b ∈R {0, 1} and responds as follows.
21
1
1
n∗, r(cid:48)
k∈Ri
ga·M∗
i,j·y(cid:48)
(cid:89)
−r(cid:48)
2,x∗ · (
(a) Run C(M,ρ) ← Enc((M, ρ), mb) as in the real scheme, and output ((M, ρ), A1, A3, (B1, C1), ...,
(Bl, Cl), D). Here the component A2 is unnecessarily output. Note that M is an l × n matrix.
(b) Find an attribute set S such that S |= (M, ρ)15, and choose β(cid:48)∗, δ∗ ∈R {0, 1}k. Issue an H5
query on δ∗ to obtain ξ∗
2. Note that in step (a) the query (mb, β) must be issued to H1 such
that the tuple (mb, β, s(cid:48)) is already stored in H List
p. Then recover
4 = (e(ga, gaq ) · e(g, gα(cid:48)
(mb, β, s(cid:48)) from H List
, and set A∗
))s(cid:48)·ξ∗
2 .
(c) For each row i of M∗ (an l∗ × n∗ matrix), set x∗ = ρ∗(i), issue an H3 query on x∗ to obtain
l∗ ∈R Z∗
p, for all i ∈ {1, ..., l∗}, denote Ri
2, ..., y(cid:48)
the tuple (x∗, zx∗, δ2,x∗). Choose y(cid:48)
1, ..., r(cid:48)
(cid:89)
(cid:89)
as the set of all i (cid:54)= k such that ρ∗(i) = ρ∗(k). Set
B(cid:48)∗
i = δ
, where β ∈ {0, 1}k, s(cid:48) ∈ Z∗
j ) · gbi·s·(−zx∗ ) · (
(gaj·s·(bi/bk))M∗
1 ), ..., (B(cid:48)∗
3, δ∗
1 ⊕ (δ∗||β(cid:48)∗), and set A(cid:48)∗
1 , A(cid:48)∗
l∗ ), S, (M∗, ρ∗), ξ∗
1 , C(cid:48)∗
A(cid:48)∗
2 , (B(cid:48)∗
1 , A(cid:48)∗
4, A(cid:48)∗
D, A∗
(d) Choose A(cid:48)∗
(e) Issue an H6 query on (A(cid:48)∗
2 , (B(cid:48)∗
l∗ , C(cid:48)∗
(f) Output the challenge ciphertext CR∗
1 ), ..., (B(cid:48)∗
j=1,...,n∗
1 ∈R {0, 1}2k, implicitly deﬁne H2(T · e(gs, gα(cid:48)
l∗ , C(cid:48)∗
4), and deﬁne D(cid:48)∗ = (gs)ξ∗
1 ), ..., (B(cid:48)∗
3 .
1 , C(cid:48)∗
2 , (B(cid:48)∗
If T = e(g, g)aq+1·s, CR∗
(M∗,ρ∗) is a valid ciphertext. Clearly, the components corresponding to C(M,ρ)
are valid. Since C(M,ρ) is re-encrypted to CR∗
(M∗,ρ∗) under a valid re-encryption key rkS→(M∗,ρ∗)
(S |= (M, ρ)), the re-encryption must be valid, i.e. the construction of A∗
4 is valid. With the
same analysis technique given in the proof of Theorem 2, it is not diﬃcult to see that the rest of
components are valid as well. If T ∈R GT , the challenge ciphertext is independent of the bit b in
the view of A.
2 = gs.
l∗ ), S, (M∗, ρ∗)) to obtain the tuple (A(cid:48)∗
1 , C(cid:48)∗
1 ,
(M∗,ρ∗) = (S, (M, ρ), (M∗, ρ∗), A1, A3, (B1, C1), ..., (Bl, Cl),
l∗ , C(cid:48)∗
l∗ ), D(cid:48)∗) to A.
k,j )−1, C(cid:48)∗
i = gr(cid:48)
)) = A(cid:48)∗
i
j=2,...,n∗
i+s·bi.
5. Query Phase II. Same as Query Phase I but with the constraints deﬁned in Deﬁnition 5.
6. Guess. A outputs a guess bit b(cid:48) ∈ {0, 1}. If b(cid:48) = b, C outputs 1 (i.e. deciding T = e(g, g)aq+1·s);
otherwise, C outputs 0 (i.e. deciding T ∈R GT ).
The probability analysis is almost the same as the one given in Appendix B.1 except that we should
5 denotes the event that A has
≥
). The running time of C is
take the even H∗
queried δ∗ to H5 before the challenge phase. From the simulation we have AdvD−q−parallelBDHE
5 into account when analyzing the event Bad, where H∗
2k − 2(qd1 +qd2 )+qre
1
qH2
p
identical to that given in Appendix B.1. We hence omit the details.
(22 − qH1 +(qH1 +qH2 )·(qd1 +qd2 )
2 ,A) ≥ 1
H∗
(AdvT CR
− qH5
qH2
22k
A
This completes the proof of Theorem 3.
2
15 Note that it is possible that S can be found in SK List.