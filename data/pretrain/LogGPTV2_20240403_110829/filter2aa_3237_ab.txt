Enter American Fuzzy Lop
See http://lcamtuf.coredump.cx/afl/
AFL is a coverage-guided fuzzer that gravitates towards new
code paths.
Useful for generating a corpus
Able to find buggy code paths quickly
Second round methodology:
Develop harness to test Stagefright
Run AFL on beefy hardware
Periodically triage, analyze, and restart the fuzzer
Catalog and fix bugs as they are discovered
Second Round Results
I ran the second round of testing for about 3 weeks.
Used both default and dictionary based modes
Tried with and without ASAN
~3200 tests per second
Total CPU hours was over 6 months
Five more critical issues discovered!
Plenty more less-severe crashing bugs too..
The code fuzzed clean at the end.
Bug Summary
CVE-2015-1538 #1 -- MP4 'stsc' Integer Overflow
CVE-2015-1538 #2 -- MP4 'ctts' Integer Overflow
CVE-2015-1538 #3 -- MP4 'stts' Integer Overflow
CVE-2015-1538 #4 -- MP4 'stss' Integer Overflow
CVE-2015-1539 ------ MP4 'esds' Integer Underflow
CVE-2015-3824 ------ MP4 'tx3g' Integer Overflow
CVE-2015-3826 ------ MP4 3GPP Buffer Overread
CVE-2015-3827 ------ MP4 'covr' Integer Underflow
CVE-2015-3828 ------ MP4 3GPP Integer Underflow
CVE-2015-3829 ------ MP4 'covr' Integer Overflow
..and a whole slew of stability fixes
Details for a FAIL
Full vulnerability analysis details will be published in the whitepaper (in progress)
Due to time constraints, let's look at a few interrelated
issues found in round 1.
Fixes pushed to AOSP in Lollipop release:
Date:   Mon Jul 28 09:54:57 2014 -0700
    SampleTable: check integer overflow during table alloc
    Bug: 15328708
    Bug: 15342615
    Bug: 15342751
Three Related Issues
All three are very similar, so let's look at just one:
@@ -330,6 +330,10 @@ status_t SampleTable::setTimeToSampleParams(
     }
     mTimeToSampleCount = U32_AT(&header[4]);
+    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);
+    if (allocSize > SIZE_MAX) {
+        return ERROR_OUT_OF_RANGE;
+    }
     mTimeToSample = new uint32_t[mTimeToSampleCount * 2];
     size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
Okay. So if the 64-bit result is bigger than 2^32, we return
ERROR_OUT_OF_RANGE.
Right?
Embarrassing, but Educational
"Catching Integer Overflows in C", Felix von Leitner, http://www.fefe.de/intof.html
SORT OF. So what REALLY happens?
In C, on the other hand, if you multiply two 32-bit
integers, you get a 32-bit integer again, losing the
upper 32 bits of the result. ... which is a typical mistake
of inexperienced C hackers.
All three multiplicands are uint32_t
No integer promotion so upper 32-bits are lost
No integer overflow is ever detected.
The original vulnerability remained. OOPS.
Exploitability
Can these issues be exploited?
Exploitability Analysis
Many of the vulnerabilities result in memory corruption in
heap memory.
These types of issues have been proven exploitable
numerous times in the past.
Android's mitigations come into play.
Diversity in the Android ecosystem complicates research,
but is not a barrier to exploitation.
mediaserver Recap
Some properties of mediaserver help and hurt us!
Spawning from init (a native service) means...
+ Zygote ASLR weakness does not apply
- Possible to retry an attack repeatedly/indefinitely
- Poissble to bypass ASLR through sheer bruteforce.
The process runs multiple threads
+ Less determinism in heap usage
New Mitigation in Android 5.0
The release of Android Lollipop brought more
improvements!
Heap implementation changed to jemalloc
Integer overflow mitigation in GCC 5.0
These two blocks of code are functionally equivalent.
236     mSampleToChunkEntries =
237         new SampleToChunkEntry[mNumSampleToChunkOffsets];
236     mSampleToChunkEntries =
237         malloc( mNumSampleToChunkOffets * sizeof(SampleToChunkEntry) )
The Android compiler team introduced this, not Android
Security.
Mitigation Summary
* Only affects some of the vulnerabilities. It still leads to DoS.
Mitigation
Applicability
SELinux
N/A
Stack Cookies
N/A
FORTIFY_SOURCE
N/A
ASLR
only Android >= 4.0
NX
bypass with ROP
GCC new[] mitigation
N/A*
ASLR is the ONLY challenge.
Address Space Layout Randomization
I managed to fully bypass ASLR on ICS. Partially on JB+
May also be possible on newer Android version too.
Information leakage issues
Address space is usually only 32-bits
Heap spraying
Other virtual memory tricks
Bruteforce or statistical guessing
Exploitability by Release
Android Release
Exploitable?
Gingerbread
YES: NO ASLR
Ice Cream Sandwich
YES: WEAK ASLR
Jelly Bean
YES, IN THEORY
KitKat
YES, IN THEORY
Lollipop
YES, IN THEORY
Exploited ICS
DEMO!
Disclosure
What about getting these issues fixed?
Disclosure process review
Reported via patches to Google
Early April - Sent first set of patches
Late April - Reported one to Mozilla
Early May - Sent second set of patches
Late April through Early June
Reported issues to Blackphone via Bugcrowd
I requested embargo from everyone.
90 days from notifying Google despite our 30 day policy.
Fixes
Everyone was great to work with!
Android accepted the patches and applied to their
internal code branches in <= 4 days.
They notified their partners, but not non-partners.
Mozilla fixed quickly and released in Firefox 38.
Blackphone rolled out the fixes in binary form.
Zimperium created the Zimperium Handset Alliance to
improve this process in the future.
Over 25 carriers, manufacturers, and vendors have
already joined!
Update Deployment
This is still ongoing.
If you get an update to your Android device soon, it is
probably the fixes.
There's a long tail to Android updates and many devices
may never get fixed :-/
This research has made a huge positive impact on Android
security already.
NEW: 30 day patch cycles for Google and Samsung
NEW: Updates possibly being created for older devices!
Conclusions
Wait, what are you trying to say?
Conclusions
Android's code base needs more attention.
Audit, fuzz, test, submit to the Android VRP
Mitigations are not a silver bullet
Especially in situations where multiple attempts are
possible
Vendors using Android need to
1. Be more proactive in finding / fixing flaws
2. Be more aggressive in deploying fixes
Thankfully, things appear to be improving! For more
information, see Adrian's talk from this morning!
Thanks for your time!
Any questions?
Prefer to ask offline? Contact me:
Joshua J. Drake
PI:EMAIL
jduck @ Twitter/IRC
www.droidsec.org
the end
BONUS SLIDES!!!
These didn't make the cut
Be sure to thank me for the extra content =)
Discovering the Media Scanner
Looking into Browser download handling...
Discovering the Media Scanner
Looking at the Browser's DownloadHandler is the beginning
of a journey down the rabbit hole.
 37 /*
 38  * Handle download requests
 39  */
 40 public class DownloadHandler {
...
142     /*package */ static void onDownloadStartNoStream(Activity activity,
...
188         final DownloadManager.Request request;
189         try {
190             request = new DownloadManager.Request(uri);
...
199         // let this downloaded file be scanned by MediaScanner -
200         // so that it can show up in Gallery app, for example.
201         request.allowScanningByMediaScanner();
DownloadManager.Request.allowScanningByMediaScanner
Media Scanner II
But how does that work?!
To see, we consult DownloadManager.java in
frameworks/base/core/java/android/app:
 557         public void allowScanningByMediaScanner() {
 558             mScannable = true;
 559         }
*shrug*
Let's try again with mScannable...
Media Scanner III
And looking into mScannable, we find:
 345     public static class Request {
 ...
 375         private boolean mScannable = false; // THANKFULLY
 ...
 705          * @return ContentValues to be passed to DownloadProvider.insert()
 706          */
 707         ContentValues toContentValues(String packageName) {
 ...
 723             // is the file supposed to be media-scannable?
 724             values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? 
 725                     SCANNABLE_VALUE_NO);
Alright, so now we are going off to DownloadProvider...
Having fun yet?
MediaScanner IV
DownloadProvider is a Service that processes a queue of files
to download. The most relevant part of the code follows:
 71 public class DownloadService extends Service {
...
113     private DownloadScanner mScanner;
...
281     /**
282      * Update {@link #mDownloads} to match {@link DownloadProvider} state.
283      * Depending on current download state it may enqueue {@link DownloadThr
284      * instances, request {@link DownloadScanner} scans, update user-visible
...
293     private boolean updateLocked() {
...
328...      // Kick off download task if ready
329...      final boolean activeDownload = info.startDownloadIfReady(mExecutor);
330...
331...      // Kick off media scan if completed
332...      final boolean activeScan = info.startScanIfReady(mScanner);
MediaScanner V
Looking closer at DownloadScanner, we see:
 41 public class DownloadScanner implements MediaScannerConnectionClient {
...
 60         public void exec(MediaScannerConnection conn) {
 61             conn.scanFile(path, mimeType);
 62         }
This sends us down another rabbit hole, to see the internals
of the MediaScanner implementation. More details on that
will be in the whitepaper.
Suffice to say that it eventually leads to
MPEG4Extractor::parseChunk.
MediaScanner VI
Stepping back, we see that another API that leads to
scanning too...
DownloadManager.addCompletedDownload (since API 12)
frameworks/base/core/java/android/app/DownloadManager.java:1199: \
     return addCompletedDownload(title, description, isMediaScannerScannable, \
          mimeType, path,
frameworks/base/core/java/android/app/DownloadManager.java-1200- \
          length, showNotification, false);
Let's look into calls to this API and see if they do or don't
scan things.
MediaScanner VII
These don't scan media:
packages/apps/Browser/src/com/android/browser/Controller.java:2118: \
              manager.addCompletedDownload(target.getName(),
packages/apps/Browser/src/com/android/browser/Controller.java-2119- \
                     mActivity.getTitle().toString(), false,
packages/apps/Email/emailcommon/src/com/android/emailcommon/utility/AttachmentUt
             long id = dm.addCompletedDownload(attachment.mFileName, attachment
packages/apps/Email/emailcommon/src/com/android/emailcommon/utility/AttachmentUt
                     false /* do not use media scanner */,
packages/providers/DownloadProvider/src/com/android/providers/downloads/Download
104     @Override
105     public String createDocument(String docId, String mimeType, String displ
...
         return Long.toString(mDm.addCompletedDownload(
packages/providers/DownloadProvider/src/com/android/providers/downloads/Download
                 file.getName(), file.getName(), false, mimeType, file.
MediaScanner IV
These DO use the media scanner:
packages/apps/UnifiedEmail/src/com/android/mail/providers/EmlAttachmentProvider.
                 mDownloadManager.addCompletedDownload(attachment.getName(),
packages/apps/UnifiedEmail/src/com/android/mail/providers/EmlAttachmentProvider.
                         description, true, attachment.getContentType(),
After reading some documentation and searching around
for more details about the MediaScanner, we see that it can
also be triggered via several Intents.
android.intent.action.MEDIA_MOUNTED
android.intent.action.MEDIA_SCANNER_SCAN_FILE
Vectors into the Media Scanner
A MediaScanner Darkly!
Vectors into the Media Scanner I
Users of MediaScannerConnection include:
The Android Compatability Test Suite (CTS)
The ExternalStorage sample in ApiDemos
The Roboelectric test suite
The CameraBrowser's ObjectViewer
CarouselViewUtilities (??)
BluetoothOppService
VCardService
Email app AttachmentUtilities
The Gallery (of course) IngestService
....and....
Vectors into the Media Scanner II
Users of MediaScannerConnection also include:
Nfc app HandoverTransfer
CalendarProvider's CalendarDebugActivity
DownloadProvider's DownloadScanner
used by the Browser, via DownloadManager
MediaProvider
Implements Intents for scanning
TestingCamera from the PDK
It's important to note that some vectors don't process
untrusted data. (i.e. the Camera and test suites)
Vectors into the Media Scanner III
Locations that invoke via the MEDIA_MOUNTED Intent
include:
The MediaScannerActivity sample
MountService (via vold)
Music app TestSongs
This includes when SD cards are inserted as well as when
dealing with MTP connections.
Vectors into the Media Scanner IV
Locations that invoke via the MEDIA_SCANNER_SCAN_FILE
Intent include:
Taking pictures from within the Browser (SelectFileDialog
or UploadHandler)
The screenrecord command
"photobasics"
Mms app ComposeMessageActivity
Ringtones and Media via copyPart
SoundRecorder app SoundRecorder
UnifiedEmail app EmlAttachmentPRovider
VideoEditor app ApiService
Vectors into the Media Scanner V
Classes that implement the MediaScannerConnectionClient
interface include:
The Android CTS
CameraBrowser.ObjectViewer
Bluetooth app BluetoothOppService
Contacts app VCardService
Gallary2 app
DownloadProvider.DownloadScanner
MediaProvider
h0dg3 p0dg3
A bunch of random nixed slides
Caveats to Attacking via MTP/PTP
MTP/PTP requires a USB connection
It's enabled by default on Nexus devices since 4.0
Can be disabled (mine is)
Can't disable it on some devices (i.e. SGS5) :-(
Requires an unlocked while USB is plugged in!
Doesn't apply to "None" or "Swipe" screen locking
Sending MMS w/o Carriers I
need to broadcast WAP_PUSH_RECEIVED
can't do it via "am broadcast"
it doesn't support byte[] Intent extras
inject a re-broadcast receiver (MmsProxy) into
com.android.phone with adbi/ddi
MMSC connections forced over mobile network
netd adds a route temporarily
created a patch to netd to avoid that
Sending MMS w/o Carriers II
Modify APN settings
remove "mmsc" from existing APN
create new APN with:
LAN server for MMSC
"mmsc" in APN type
host your own MMSC
Now you're ready to test!
the real end. really.