# 【技术分享】CVE-2016-7255：虚拟内存、页表与关键位

## 译文声明
本文为翻译文章，原文来源于 [ricklarabee.blogspot.com](ricklarabee.blogspot.com)。译文仅供参考，具体内容及含义以原文为准。
- 翻译者：[Ox9A82](http://bobao.360.cn/member/contribute?uid=2676915949)
- 预估稿费：200 RMB
- 投稿方式：发送邮件至 [linwei#360.cn](mailto:linwei@360.cn) 或访问 [网页版](http://bobao.360.cn/contribute/index) 在线投稿

## 前言
在Google安全团队公布了一个本地提权漏洞的细节后，我决定深入研究这个漏洞。该漏洞通过`win32k.sys`中的系统调用`NtSetWindowLongPtr()`将索引为`GWLP_ID`的Windows句柄设置为`GWL_STYLE`并赋值为`WS_CHILD`。

我在Twitter上找到了一个关于[CVE-2016-7255的PoC](https://github.com/tinysec/public/tree/master/CVE-2016-7255)。此PoC展示了攻击者如何在内核模式下控制地址，并对其进行解引用和逻辑或运算（与0x4进行）。

在Blackhat 2016会议上，发布了一份名为《Windows 10 Mitigation Improvements》的报告，其中提到系统空间的PML4条目现在已经被随机化，不再使用静态条目0x1ed。

在Zero Nights 2016会议上，Enrique Nissim展示了如何确定最新版本Windows中已被随机化的PML4条目。他发布了相应的[POC](https://github.com/IOActive/I-know-where-your-page-lives/) 和[议题](https://2016.zeronights.org/program/main-track/#4)。

我基于Enrique的POC进行了调整，使其适用于64位版本的Windows 7, 8.1, 10以及Server 2012 R2上的相同漏洞。我的主要改动包括：
1. 将PML4自引用条目设置为静态条目0xFFFFF6FB7DBEDF68。
2. 调整shellcode以适配不同操作系统版本中的偏移量。
3. 为不同的操作系统设置了不同的覆盖目标。
   - Windows 7 工作站 – 使用通用Hal Dispatch Table并通过调用`NtQueryIntervalProfile`函数实现。
   - Windows 8.1 工作站 – 使用`HalpApicRequestInterrupt`指针。
   - Windows 10 工作站（周年更新之前） – 使用`HalpApicRequestInterrupt`指针。
   - Windows Server 2012 R2 – 使用`HalpApicRequestInterrupt`指针。

为了更好地理解这一漏洞及其利用原理，我们需要先了解虚拟内存管理器的工作机制。

## 虚拟内存与页表
要了解虚拟地址如何映射到物理地址，可以参考AMD和Intel的开发者手册中关于映射和页表的内容。

以下是几个关键位：
- **读/写 (R/W) 位**：第1位 – 如果为0，则禁止写入。
- **用户/管理员 (U/S) 位**：第2位 – 如果为0，则禁止用户模式访问（ring 3）。
- **不可执行 (NX) 位**：第63位 – 如果为1，则禁止执行代码。

### 跟踪虚拟地址到物理地址的映射过程
为了帮助大家理解如何将虚拟地址映射到物理地址，我使用Windbg来展示这个过程。以下是一个小程序的例子，它在虚拟地址0x1000000处写入“A”。

#### 虚拟地址转换到物理地址
在下面的例子中，我使用Windbg作为内核调试器，并切换到用户进程的上下文中。

```plaintext
!process 0 0 nameofexe.exe
.process /i 
.reload /user
```

**CR3寄存器**用于查找PML4表的基地址。

1. 获取CR3寄存器的值：
   ```plaintext
   r cr3
   ```
   输出：`0x1fddff000`，这是指向PML4表的物理地址。

2. 使用虚拟地址的第47-39位 * 8（每个地址是64位或8字节）来找到页目录指针表的物理地址：`0x1ff48867`。

#### 页目录指针表 (Page Directory Pointer Table, PDP)
使用PDP表的物理地址并将低12位清零，得到：
- 物理地址：`0x1ff48000`
- 加上虚拟地址的38-30位 * 8作为偏移，找到页目录表 (Page Directory Table) 的物理地址：`0x19d90867`。

#### 页目录表 (Page Directory Table)
清零11-0位，得到物理地址：`0x19d90000`。
- `0x19d90000 + 虚拟地址的29-21位 * 8` 得到页表 (Page Table) 的物理地址：`0x1f491867`。

#### 页表 (Page Table)
清零第11-0位，获得物理地址：`0x1f491000`。
- `0x1f491000 + 虚拟地址的20-12位 * 8` 获得物理页的物理地址：`0x20692867`。

#### 一个物理页中的偏移
清零第11-0位，得到物理地址：`0x20692000`。
- `0x20692000 + 虚拟地址的11-0位`：`0x2692000`。这表示一个物理页中的偏移，并且也表示该页的大小为4KB（0x0-0xfff）。

Windbg中的`!pte`命令提供了相同的信息。

### Python代码实现
以下Python代码实现了Windbg中`!pte`的功能，并能够使用不同的自引用索引（这对于计算Windows 10 build 1607中的信息很有用）。

```python
#!/usr/bin/python
import sys

PML4_SELF_REF_INDEX = 0x1ed

def get_pxe_address(address):
    entry = PML4_SELF_REF_INDEX
    result = address >> 9
    lower_boundary = (0xFFFF << 2)
    if len(sys.argv) > 2:
        PML4_SELF_REF_INDEX = int(sys.argv[2], 16)
    pt = get_pxe_address(address)
    pd = get_pxe_address(pt)
    pdpt = get_pxe_address(pd)
    pml4 = get_pxe_address(pdpt)
    selfref = get_pxe_address(pml4)
    print("Virtual Address: %s" % (hex(address)))
    print("Self reference index: %s" % (hex(PML4_SELF_REF_INDEX)))
    print("\n")
    print("Page Tables")
    print("Self Ref: \t%s" % (hex(selfref)))
    print("Pml4:\t\t%s" % (hex(pml4)))
    print("Pdpt:\t\t%s" % (hex(pdpt)))
    print("Pd:\t\t%s" % (hex(pd)))
```

希望这些信息能帮助您更好地理解CVE-2016-7255漏洞及其利用方法。