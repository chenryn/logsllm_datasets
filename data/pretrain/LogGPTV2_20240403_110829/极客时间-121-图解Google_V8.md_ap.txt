# 21 \| 垃圾回收（二）：V8是如何优化垃圾回收器执行效率的？你好，我是李兵。上节我们介绍了 V8使用副垃圾回收器和主垃圾回收器来处理垃圾回收，这节课我们看看 V8是如何优化垃圾回收器的执行效率的。由于 JavaScript是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿（Stop-The-World）**。一次完整的垃圾回收分为标记和清理两个阶段，垃圾数据标记之后，V8会继续执行清理和整理操作，虽然主垃圾回收器和副垃圾回收器的处理方式稍微有些不同，但它们都是主线程上执行的，执行垃圾回收过程中，会暂停主线程上的其他任务，具体全停顿的执行效果如下图所示：![](Images/654f4574054a9f907db5dafca7a4b3b8.png)savepage-src="https://static001.geekbang.org/resource/image/90/23/9004196c53f2f381a1321bcbc346fc23.jpg"}可以看到，执行垃圾回收时会占用主线程的时间，如果在执行垃圾回收的过程中，垃圾回收器占用主线程时间过久，就像上面图片展示的那样，花费了200 毫秒，在这 200毫秒内，主线程是不能做其他事情的。比如，页面正在执行一个 JavaScript动画，因为垃圾回收器在工作，就会导致这个动画在这 200毫秒内无法执行，造成页面的**卡顿 (Jank)**，用户体验不佳。为了解决全停顿而造成的用户体验的问题，V8团队经过了很多年的努力，向现有的垃圾回收器添加并行、并发和增量等垃圾回收技术，并且也已经取得了一些成效。这些技术主要是从两方面来解决垃圾回收效率问题的：1.  第一，        **将一个完整的垃圾回收的任务拆分成多个小的任务**        ，这样就消灭了单个长的垃圾回收任务；        2.  第二，        **将标记对象、移动对象等任务转移到后台线程进行**        ，这会大大减少主线程暂停的时间，改善页面卡顿的问题，让动画、滚动和用户交互更加流畅。        接下来，我们就来深入分析下，V8是怎么向现有的垃圾回收器添加并行、并发和增量等技术，来提升垃圾回收执行效率的。并行回收既然执行一次完整的垃圾回收过程比较耗时，那么解决效率问题，第一个思路就是主线程在执行垃圾回收的任务时，引入多个辅助线程来并行处理，这样就会加速垃圾回收的执行速度，因此V8 团队引入了并行回收机制。所谓并行回收，是指垃圾回收器在主线程上执行的过程中，还会开启多个协助线程，同时执行同样的回收工作，其工作模式如下图所示：![](Images/360847a2b0a160cdbe6e89a9cc732d0d.png)savepage-src="https://static001.geekbang.org/resource/image/00/1f/00537bdadac433a57c77c56c5cc33c1f.jpg"}采用并行回收时，垃圾回收所消耗的时间，等于总体辅助线程所消耗的时间（辅助线程数量乘以单个线程所消耗的时间），再加上一些同步开销的时间。这种方式比较简单，因为在执行垃圾标记的过程中，主线程并不会同时执行JavaScript 代码，因此 JavaScript代码也不会改变回收的过程。所以我们可以假定内存状态是静态的，因此只要确保同时只有一个协助线程在访问对象就好了。V8的副垃圾回收器所采用的就是并行策略，它在执行垃圾回收的过程中，启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域。由于数据的地址发生了改变，所以还需要同步更新引用这些对象的指针。增量回收虽然并行策略能增加垃圾回收的效率，能够很好地优化副垃圾回收器，但是这**仍然是一种全停顿**的垃圾回收方式，在主线程执行回收工作的时候才会开启辅助线程，这依然还会存在效率问题。比如老生代存放的都是一些大的对象，如window、DOM这种，完整执行老生代的垃圾回收，时间依然会很久。这些大的对象都是主垃圾回收器的，所以在2011 年，V8从又引入了增量标记的方式，我们把这种垃圾回收的方式称为**谓增量式垃圾回收**。所谓增量式垃圾回收，是指垃圾收集器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作，具体流程你可以参看下图：![](Images/8a55364d1c24f47153cde2108b3e4c43.png)savepage-src="https://static001.geekbang.org/resource/image/be/6f/be18e6dc6c93e761a37d50aed48f246f.jpg"}增量标记的算法，比全停顿的算法要稍微复杂，这主要是因为**增量回收是并发的（concurrent）**，要实现增量执行，需要满足两点要求：1.       垃圾回收可以被随时暂停和重启，暂停时需要保存当时的扫描结果，等下一波垃圾回收来了之后，才能继续启动。        2.       在暂停期间，被标记好的垃圾数据如果被 JavaScript    代码修改了，那么垃圾回收器需要能够正确地处理。        我们先来看看第一点，V8是如何实现垃圾回收器的暂停和恢复执行的。这里我们需要知道，在没有采用增量算法之前，V8使用黑色和白色来标记数据。在执行一次完整的垃圾回收之前，垃圾回收器会将所有的数据设置为白色，用来表示这些数据还没有被标记，然后垃圾回收器在会从GC Roots出发，将所有能访问到的数据标记为黑色。遍历结束之后，被标记为黑色的数据就是活动数据，那些白色数据就是垃圾数据。如下图所示：![](Images/4a56b6d79157b633c891ea2b011b4c36.png)savepage-src="https://static001.geekbang.org/resource/image/e1/0c/e1409de965aaab9bbf401249b1e02d0c.jpg"}如果内存中的数据只有两种状态，非黑即白，那么当你暂停了当前的垃圾回收器之后，再次恢复垃圾回收器，那么垃圾回收器就不知道从哪个位置继续开始执行了。比如垃圾回收器执行了一小段增量回收后，被 V8暂停了，然后主线程执行了一段 JavaScript代码，然后垃圾回收器又被恢复了，那么恢复时内存状态就如下图所示：![](Images/d55212dfdaf6e7bcade4fe22f9f316f5.png)savepage-src="https://static001.geekbang.org/resource/image/2c/4d/2cd1ef856522ad0c8176c60b75e63c4d.jpg"}那么，当垃圾回收器再次被启动的时候，它到底是从 A 节点开始标记，还是从B节点开始执行标注过程呢？因为没有其他额外的信息，所以垃圾回收器也不知道该如何处理了。为了解决这个问题，V8 采用了**三色标记法，**除了黑色和白色，还额外引入了灰色：1.       黑色表示这个节点被 GC Root    引用到了，而且该节点的子节点都已经标记完成了    ;    2.       灰色表示这个节点被 GC Root    引用到，但子节点还没被垃圾回收器标记处理，也表明目前正在处理这个节点；        3.       白色表示这个节点没有被访问到，如果在本轮遍历结束时还是白色，那么这块数据就会被收回。        引入灰色标记之后，垃圾回收器就可以依据当前内存中有没有灰色节点，来判断整个标记是否完成，如果没有灰色节点了，就可以进行清理工作了。如果还有灰色标记，当下次恢复垃圾回收器时，便从灰色的节点开始继续执行。因此采用三色标记，可以很好地支持增量式垃圾回收。接下来，我们再来分析下，标记好的垃圾数据被 JavaScript 修改了，V8是如何处理的。我们看下面这样的一个例子：    window.a = Object()    window.a.b = Object()    window.a.b.c=Object() 执行到这段代码时，垃圾回收器标记的结果如下图所示：![](Images/18aa57a241a64c1082a4859c0c10307a.png)savepage-src="https://static001.geekbang.org/resource/image/19/17/19bbfb35d274064b253814b58413bc17.jpg"}然后又执行了另外一个代码，这段代码如下所示：    window.a.b = Object() //d执行完之后，垃圾回收器又恢复执行了增量标记过程，由于 b 重新指向了 d对象，所以 b 和 c对象的连接就断开了。这时候代码的应用如下图所示：![](Images/04a38c3fbca0977bced9cc91786d2ec2.png)savepage-src="https://static001.geekbang.org/resource/image/75/15/759f6a8105d64d3aebdc16f81a2b5e15.jpg"}这就说明一个问题，当垃圾回收器将某个节点标记成了黑色，然后这个黑色的节点被续上了一个白色节点，那么垃圾回收器不会再次将这个白色节点标记为黑色节点了，因为它已经走过这个路径了。但是这个新的白色节点的确被引用了，所以我们还是需要想办法将其标记为黑色。为了解决这个问题，增量垃圾回收器添加了一个约束条件：**不能让黑色节点指向白色节点**。通常我们使用**写屏障 (Write-barrier)机制**实现这个约束条件，也就是说，当发生了黑色的节点引用了白色的节点，写屏障机制会强制将被引用的白色节点变成灰色的，这样就保证了黑色节点不能指向白色节点的约束条件。这个方法也被称为**强三色不变性**，它保证了垃圾回收器能够正确地回收数据，因为在标记结束时的所有白色对象，对于垃圾回收器来说，都是不可到达的，可以安全释放。所以在 V8 中，每次执行如 `window.a.b = value`的写操作之后，V8会插入写屏障代码，强制将 value这块内存标记为灰色。并发 (concurrent) 回收虽然通过**三色标记法和写屏障**机制可以很好地实现增量垃圾回收，但是由于这些操作都是在主线程上执行的，如果主线程繁忙的时候，增量垃圾回收操作依然会增加降低主线程处理任务的**吞吐量(throughput)**。结合并行回收可以将一些任务分配给辅助线程，但是并行回收依然会阻塞主线程，那么，有没有办法在不阻塞主线程的情况下，执行垃圾回收操作呢？还真有，这就是我们要来重点研究的**并发回收机制**了。**所谓并发回收，是指主线程在执行 JavaScript的过程中，辅助线程能够在后台完成执行垃圾回收的操作。**并发标记的流程大致如下图所示：![](Images/265ba7e76abf94b0d931a53c41ab4e69.png)savepage-src="https://static001.geekbang.org/resource/image/15/c2/157052aa087c840f5f58a7708f30bdc2.jpg"}并发回收的优势非常明显，主线程不会被挂起，JavaScript 可以自由地执行，在执行的同时，辅助线程可以执行垃圾回收操作。但是并发回收却是这三种技术中最难的一种，这主要由以下两个原因导致的：1.  第一，当主线程执行 JavaScript    时，堆中的内容随时都有可能发生变化，从而使得辅助线程之前做的工作完全无效；        2.  第二，主线程和辅助线程极有可能在同一时间去更改同一个对象，这就需要额外实现读写锁的一些功能了。        尽管并行回收要额外解决以上两个问题，但是权衡利弊，并行回收这种方式的效率还是远高于其他方式的。不过，这三种技术在实际使用中，并不是单独的存在，通常会将其融合在一起使用，V8的主垃圾回收器就融合了这三种机制，来实现垃圾回收，那它具体是怎么工作的呢？你可以先看下图：![](Images/44d073478d295546fd59f10f5acbec72.png)savepage-src="https://static001.geekbang.org/resource/image/7b/42/7b8b901cb2eb575bb8907e1ad7dc1842.jpg"}可以看出来，主垃圾回收器同时采用了这三种策略：1.  首先主垃圾回收器主要使用并发标记，我们可以看到，在主线程执行    JavaScript，辅助线程就开始执行标记操作了，所以说标记是在辅助线程中完成的。        2.  标记完成之后，再执行并行清理操作。主线程在执行清理操作时，多个辅助线程也在执行清理操作。        3.  另外，主垃圾回收器还采用了增量标记的方式，清理的任务会穿插在各种    JavaScript 任务之间执行。        总结V8最开始的垃圾回收器有两个特点，第一个是垃圾回收在主线程上执行，第二个特点是一次执行一个完整的垃圾回收流程。由于这两个原因，很容易造成主线程卡顿，所以 V8采用了很多优化执行效率的方案。第一个方案是并行回收，在执行一个完整的垃圾回收过程中，垃圾回收器会使用多个辅助线程来并行执行垃圾回收。第二个方案是增量式垃圾回收，垃圾回收器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作。第三个方案是并发回收，回收线程在执行 JavaScript的过程，辅助线程能够在后台完成的执行垃圾回收的操作。主垃圾回收器就综合采用了所有的方案，副垃圾回收器也采用了部分方案。思考题虽然 V8为执行垃圾回收的效率做了大量的优化，但是在实际项目中我们依然要关心内存问题，那么今天我留给你的思考题是：在使用JavaScript时，如何避免内存泄漏？欢迎你在留言区与我分享讨论。感谢你的阅读，如果你觉得这一讲的内容对你有所启发，也欢迎把它分享给你的朋友。
# 22｜答疑：几种常见内存问题的解决策略你好，我是李兵。 这是我们"事件循环和垃圾回收"这个模块的最后一讲。在这个模块中，我们讲了消息循环系统和垃圾回收机制，这两块内容涉及到了比较底层的知识，但是这些知识对实际的项目有着非常重要的指导作用，很多同学也比较关注这两部分内容。 今天这节答疑课，我们来结合 Node中的读文件操作，分析下消息循环系统是怎么影响到异步编程的，然后我们再来结合JavaScript中的几种常见的内存问题，来分析下内存问题出现的原因和解决方法。 Node 中的 readFile API 工作机制Node 中很多 API都提供了同步和异步两种形式，下面我们来看下《17 \| 消息队列：V8是怎么实现回调函数的？slate-object="inline"》这节课留的思考题。思考题中有两段代码，我们通过这两段代码来分析下同步和异步读文件API 的区别。     var fs = require('fs')    var data = fs.readFileSync('test.js')    function fileHanlder(err, data){      data.toString()      }    fs.readFile('test.txt', fileHanlder)在解答这个问题之前，我们来看看 Node的体系架构。你可以先参考下图： ![](Images/87ec961235fc3722394883d34189f204.png)savepage-src="https://static001.geekbang.org/resource/image/b2/eb/b2894f2297a23a9d706d0517610deeeb.jpg"}Node 是 V8 的宿主，它会给 V8 提供事件循环和消息队列。在 Node中，事件循环是由 libuv 提供的，libuv工作在主线程中，它会从消息队列中取出事件，并在主线程上执行事件。 同样，对于一些主线程上不适合处理的事件，比如消耗时间过久的网络资源下载、文件读写、设备访问等，Node会提供很多线程来处理这些事件，我们把这些线程称为线程池。 通常，在 Node中，我们认为读写文件是一个非常耗时的工作，因此主线程会将回调函数和读文件的操作一道发送给文件读写线程，并让实际的读写操作运行在读写线程中。 比如当在 Node 的主线程上执行 readFile 的时候，主线程会将 readFile的文件名称和回调函数，提交给文件读写线程来处理，具体过程如下所示： ![](Images/d5bd4e30712dbe4338f0ea4c5465d9b0.png)savepage-src="https://static001.geekbang.org/resource/image/65/ff/654cccf962dccd2797bd1267ab82b9ff.jpg"}文件读写线程完成了文件读取之后，会将结果和回调函数封装成新的事件，并将其添加进消息队列中。比如文件线程将读取的文件内容存放在内存中，并将data 指针指向了该内存，然后文件读写线程会将 data和回调函数封装成新的事件，并将其丢进消息队列中，具体过程如下所示： ![](Images/b7b394e722b2c08142187367ca5a179d.png)savepage-src="https://static001.geekbang.org/resource/image/da/99/daaad54f06e7bb25dbb3b8174f55bf99.jpg"}等到 libuv从消息队列中读取该事件后，主线程就可以着手来处理该事件了。在主线程处理该事件的过程中，主线程调用事件中的回调函数，并将data结果数据作为参数，如下图所示： ![](Images/20657f947191805c91361ebce00b4f1f.png)savepage-src="https://static001.geekbang.org/resource/image/b9/c2/b9e3c603cfa7d3f47178c06ffd945fc2.jpg"}然后在回调函数中，我们就可以拿到读取的结果来实现一些业务逻辑了。 不过，总有些人觉得异步读写文件操作过于复杂了，如果读取的文件体积不大或者项目瓶颈不在文件读写，那么依然使用异步调用和回调函数的模式就显得有点过度复杂了。 因此 Node 还提供了一套同步读写的 API。第一段代码中的 readFileSync就是同步实现的，同步代码非常简单，当 libuv 读取到 readFileSync的任务后，就直接在主线程上执行读写操作，等待读写结束，直接返回读写的结果，这也是同步回调的一种应用。当然在读写过程中，消息队列中的其他任务是无法被执行的。 所以在选择使用同步 API 还是异步 API 时，我们要看实际的场景，并不是非A 即 B。 几种内存问题分析了异步 API，接下来我们再来看看 JavaScript中的内存问题，内存问题至关重要，因为通过内存而造成的问题很容易被用户察觉。总的来说，内存问题可以定义为下面这三类： 1.  **内存泄漏 (**        **Memory    leak**       **)**        ，它会导致页面的性能越来越差；        2.  **内存膨胀 (**        **Memory    bloat**       **)**        ，它会导致页面的性能会一直很差；        3.  **频繁垃圾回收**        ，它会导致页面出现延迟或者经常暂停。        内存泄漏我们先看内存泄漏。本质上，内存泄漏可以定义为：当进程不再需要某些内存的时候，这些不再被需要的内存依然没有被进程回收。 在 JavaScript 中，造成内存泄漏( **Memoryleak)** 的主要原因是不再需要 (没有作用)的内存数据依然被其他对象引用着。 下面我们就来看几种实际的例子： 我们知道，JavaScript是一门非常宽松的语言，你甚至可以使用一个未定义的变量，比如下面这样一段代码：     function foo() {        //创建一个临时的temp_array        temp_array = new Array(200000)       /**        * 使用temp_array        */    }当执行这段代码时，由于函数体内的对象没有被 var、let、const这些关键字声明，那么 V8 就会使用 this.temp_array 替换temp_array。     function foo() {        //创建一个临时的temp_array        this.temp_array = new Array(200000)       /**        * this.temp_array        */    }在浏览器，默认情况下，this 是指向 window 对象的，而 window对象是常驻内存的，所以即便 foo 函数退出了，但是 temp_array 依然被 window对象引用了， 所以 temp_array 依然也会和 window对象一样，会常驻内存。因为 temp_array已经是不再被使用的对象了，但是依然被 window 对象引用了，这就造成了temp_array 的泄漏。 为了解决这个问题，我们可以在 JavaScript文件头部加上`use strict`，使用严格模式避免意外的全局变量，此时上例中的this 指向 undefined。 另外，我们还要时刻警惕闭包这种情况，因为闭包会引用父级函数中定义的变量，如果引用了不被需要的变量，那么也会造成内存泄漏。比如你可以看下面这样一段代码：     function foo(){          var temp_object = new Object()        temp_object.x = 1        temp_object.y = 2        temp_object.array = new Array(200000)        /**        *   使用temp_object        */        return function(){            console.log(temp_object.x);        }    }可以看到，foo 函数使用了一个局部临时变量 temp_object，temp_object对象有三个属性，x、y，还有一个非常占用内存的 array 属性。最后 foo函数返回了一个匿名函数，该匿名函数引用了 temp_object.x。那么当调用完 foo函数之后，由于返回的匿名函数引用了 foo 函数中的 temp_object.x，这会造成temp_object 无法被销毁，即便只是引用了 temp_object.x，也会造成整个temp_object 对象依然保留在内存中。我们可以通过 Chrome调试工具查看下： ![](Images/ef3545554baccbaee700e0396e85530a.png)savepage-src="https://static001.geekbang.org/resource/image/ff/10/ff81eec387d021a3b4a3d019c09cbb10.jpg"}从上图可以看出，我们仅仅是需要 temp_object.x 的值，V8 却保留了整个temp_object 对象。 要解决这个问题，我就需要根据实际情况，来判断闭包中返回的函数到底需要引用什么数据，不需要引用的数据就绝不引用，因为上面例子中，返回函数中只需要temp_object.x的值，因此我们可以这样改造下这段代码：     function foo(){          var temp_object = new Object()        temp_object.x = 1        temp_object.y = 2        temp_object.array = new Array(200000)        /**        *   使用temp_object        */       let closure = temp_object.x        return function(){            console.log(closure);        }    }当再次执行这段代码时，我们就可以看到闭包引用的仅仅是一个 closure的变量，最终如下图所示： ![](Images/375f3121f06337487ade50aecc4f3dd6.png)savepage-src="https://static001.geekbang.org/resource/image/8c/ca/8c3309fd82201bf67d5c92b58d58e6ca.jpg"}我们再来看看由于 JavaScript 引用了 DOM节点而造成的内存泄漏的问题，只有同时满足 DOM 树和 JavaScript代码都不引用某个 DOM 节点，该节点才会被作为垃圾进行回收。如果某个节点已从 DOM 树移除，但 JavaScript仍然引用它，我们称此节点为"**detached** "。"**detached "**节点是 DOM内存泄漏的常见原因。比如下面这段代码：     let detachedTree;    function create() {    var ul = document.createElement('ul');    for (var i = 0; i < 100; i++) {    var li = document.createElement('li');    ul.appendChild(li);    }    detachedTree = ul;    }    create() 我们通过 JavaScript 创建了一些 DOM 元素，有了这些内存中的 DOM元素，当有需要的时候，我们就快速地将这些 DOM 元素关联到 DOM树上，一旦这些 DOM 元素从 DOM上被移除后，它们并不会立即销毁，这主要是由于 JavaScript代码中保留了这些元素的引用，导致这些 DOM元素依然会呆在内存中。所以在保存 DOM元素引用的时候，我们需要非常小心谨慎。内存膨胀了解几种可能造成内存泄漏的问题之后，接下来，我们再来看看另外一个和内存泄漏类似的问题：**内存膨胀（****Memory bloat****）**。内存膨胀和内存泄漏有一些差异，内存膨胀主要表现在程序员对内存管理的不科学，比如只需要50M 内存就可以搞定的，有些程序员却花费了 500M内存。 额外使用过多的内存有可能是没有充分地利用好缓存，也有可能加载了一些不必要的资源。通常表现为内存在某一段时间内快速增长，然后达到一个平稳的峰值继续运行。比如一次性加载了大量的资源，内存会快速达到一个峰值。内存膨胀和内存泄漏的关系你可以参看下图：![](Images/b410a7f883c5bccb337f9d72d835ae84.png)savepage-src="https://static001.geekbang.org/resource/image/99/10/992872337410ff5915e288e68f2c2e10.jpg"}我们可以看到，内存膨胀是快速增长，然后达到一个平衡的位置，而内存泄漏是内存一直在缓慢增长。要避免内存膨胀，我们需要合理规划项目，充分利用缓存等技术来减轻项目中不必要的内存占用。频繁的垃圾回收除了内存泄漏和内存膨胀，还有另外一类内存问题，那就是频繁使用大的临时变量，导致了新生代空间很快被装满，从而频繁触发垃圾回收。频繁的垃圾回收操作会让你感觉到页面卡顿。比如下面这段代码：    function strToArray(str) {      let i = 0      const len = str.length      let arr = new Uint16Array(str.length)      for (; i < len; ++i) {        arr[i] = str.charCodeAt(i)      }      return arr;    }    function foo() {      let i = 0      let str = 'test V8 GC'      while (i++ < 1e5) {        strToArray(str);      }    }    foo()这段代码就会频繁创建临时变量，这种方式很快就会造成新生代内存内装满，从而频繁触发垃圾回收。为了解决频繁的垃圾回收的问题，你可以考虑将这些临时变量设置为全局变量。总结这篇答疑主要分析了两个问题，第一个是异步 API 和同步 API的底层差异，第二个是 JavaScript的主要内存问题的产生原因和解决方法。Node 为读写文件提供了两套 API，一套是默认的异步 API，另外一套是同步API。 readFile 就是异步 API，主线程在执行 readFile的时候，会将实际读写操作丢给文件读写线程，文件读写线程处理完成之后，会将回调函数读取的结果封装成新的消息，添加到消息队列中，然后等主线执行该消息的时候，就会执行readFile 设置的回调函数，这就是 Node 中的异步处理过程。readFileSync是同步 API，同步 API很简单，直接在主线程上执行，执行完成直接返回结果给它的调用函数。使用同步API会比较方便简单，但是你需要考虑项目能否接受读取文件而造成的暂停。内存问题对于前端开发者来说也是至关重要的，通常有三种内存问题：内存泄漏(Memory leak)、内存膨胀 (Memorybloat)、频繁垃圾回收。在 JavaScript 中，造成内存泄漏 (Memory leak) 的主要原因，是不再需要(没有作用)的内存数据依然被其他对象引用着。所以要避免内存泄漏，我们需要避免引用那些已经没有用途的数据。内存膨胀和内存泄漏有一些差异，内存膨胀主要是由于程序员对内存管理不科学导致的，比如只需要50M 内存就可以搞定的，有些程序员却花费了 500M内存。要解决内存膨胀问题，我们需要对项目有着透彻的理解，也要熟悉各种能减少内存占用的技术方案。如果频繁使用大的临时变量，那么就会导致频繁垃圾回收，频繁的垃圾回收操作会让你感觉到页面卡顿，要解决这个问题，我们可以考虑将这些临时变量设置为全局变量。思考题今天留给你的题目是，在实际的项目中，你还遇到过哪些具体的内存问题呢？这些问题都是怎么解决的？欢迎你在留言区与我分享讨论。感谢你的阅读，如果你觉得这一讲的内容对你有所启发，也欢迎把它分享给你的朋友。