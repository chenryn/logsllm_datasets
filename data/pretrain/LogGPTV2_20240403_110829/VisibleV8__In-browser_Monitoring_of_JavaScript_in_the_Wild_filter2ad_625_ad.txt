discover candidate artifacts by following these steps: (1) find all dis-
tinct access sites for seed artifacts in all archived scripts, (2) find all
candidate feature access sites no more than 1,024 characters away
from one of the located seed access sites and (3) extract the set of all
candidate features whose access sites matched the seed locality re-
quirement. From our initial set of 3 seed artifacts, the above process
yields a set of 209 candidate artifacts (0.01% of the candidate pool)
found near seed access sites in 7,528 distinct scripts (of which only
1,813 scripts were lexically-distinct).
Modern Browser Artifacts. We next eliminated from our candi-
dates any artifacts found in a current, major web browser. We tested
a total of nine browser variants manually: two for Chrome (v70 on
Linux, v69 on macOS), three for Firefox (v63 on Linux, v62 on macOS,
v63 on macOS), one for Safari (v12.0 on macOS), one for Edge (v17
on Windows 10), and two for Internet Explorer (v8 on Windows 7,
Possible Bot Indicator
Category
Count
3
Seed Bot Artifact
46 New Bot Artifact
10
19 Device/Browser Fingerprint
46
Property Pollution/Iteration
11 Type Error/Misspelling
8 Missing Dependency
5 Other
Table 4: Candidate artifacts classified
v11 on Windows 10). In total we found 61 of the candidates present
on at least one tested browser, leaving 148 candidates that might be
indicative of a distinctive bot platform. The only 2 present on all 9
browsers were in fact standard JS (but not WebIDL-defined) features
in the global object: Object and Function.
Manual Classification. The remaining 148 candidate artifacts
we classified manually. Intuitively, if for every one of a candidate
artifact’s access sites there exists a data flow from that site to ap-
parent data exfiltration or evasion logic, we consider that candidate
a true artifact. If there exist benign or inconclusive examples, we
conservatively assume the candidate is not a true artifact. (We also
attempt to categorize false positives, but that process often depends
on subjective judgment of programmer intent.)
To assist this process, we classified artifact access sites into 3
categories: direct if the feature name appears in the source code at
the exact offset of the access site; indirect if the name appears only
elsewhere in the code; and hidden if the name does not appear at all.
A candidate found in a small number of distinct scripts and accessed
mostly via hidden, monomorphic access sites almost always proved
to be a bot detection artifact. Conversely, candidates found far and
wide and accessed mostly via direct or polymorphic sites usually
proved to not be true bot artifacts.
Table 4 shows the breakdown of manual classifications. We iden-
tified a total of 49 artifacts (including our seeds) used exclusively,
as far as we could tell, for bot detection. We identified 10 more that
we did see used for bot detection activity but not exclusively so.
(To avoid false positives, we exclude these “maybe” artifacts from
our aggregate results.) An additional 19 appeared to be known or
suspected fingerprinting artifacts of specific browsers or devices
(e.g., standard features with vendor prefixes like moz- and WebGL
information query constants).
Almost all of the remaining candidate artifacts appear to be side-
effects of JS language quirks and sloppy programming. An example,
extracted from a lightly obfuscated bot detection routine, explains
some of the 46 artifacts we attribute to property pollution in itera-
tion (Listing 5). This code iterates over an array of property names
to check (in this case, all true bot artifacts). However, JS arrays
intermingle indexed values with named properties, and this code
fails to exclude properties (e.g., findAll)inherited from the array’s
prototype. As a result, a single polymorphic access site within our
clustering radius would access both true bot artifacts and unrelated
array method names, bloating our initial candidate artifact pool with
spurious features that had to be weeded out manually.
IMC ’19, October 21–23, 2019, Amsterdam, Netherlands
Jordan Jueckstock and Alexandros Kapravelos
Visit Domain
Alexa Rank
youtube.com
yahoo.com
reddit.com
amazon.com
tmall.com
weibo.com
google.de
ebay.com
mail.ru
stackoverflow.com
2
6
7
11
13
21
23
45
50
55
Origin Domain
tpc.googlesyndication.com
googleads.g.doubleclick.net
ad.doubleclick.net
secure.ace.advertising.com
www.youtube.com
nym1-ib.adnxs.com
media.netseer.com
adserver.juicyads.com
openload.co
aax-us-east.amazon-adsystem.com
Visit Domains
10,291
3,980
1,853
1,150
1,041
699
321
175
168
121
Table 5: Highest ranked visit domains probing identified bot
artifacts
Table 6: Top security origin domains probing bot artifacts
Fortunately, the small size of the candidate set combined with
the insights provided by access site classification made this task
straightforward and tractable. Other identifiable sources of noise in
the final candidate set include obvious type errors or misspellings
(11) and what appear to be missing dependencies (8).
5.2 Artifact Analysis Results
Across Visited Domains. Our trace logs recorded probes of at least
one definite bot artifact during visits to 14,575 (29%) of the Alexa top
50k. This number includes artifact accesses from both monomorphic
(sites accessing only one feature; 24%) and polymorphic access sites
(those accessing more than one feature name; 5%). If we consider
only monomorphic access sites, the number drops to 11,830 visited
sites, which is under 24% of the top 50k. The modest size of that drop
implies that most bot detection scripts, even if obfuscated, perform
artifact probes on a one-by-one basis rather than through changing,
loop-carried indirect member accesses. Table 5 shows the top 10
visited domains (by Alexa ranking at the time of data collection) on
which bot artifact probes were detected.
Across Security Origin Domains. When we consider security
origin domains as well as visit domains, we find that the majority
(over 73%) of bot artifact accesses happen inside third-party sourced
s, as is typical of advertisements, third-party widgets, and
trackers. Here we are defining “first-party” as having a security
origin domain containing the visit domain as a suffix and “third-
party” as everything else. Using a stricter, exact-match definition
like the browser’s Same-Origin Policy would result in an even higher
third-to-first-party ratio.
/* originally
obfuscated via string opaque concatenation */
var d
= [" _phantom " ," __nightmare " ," _selenium " ," callPhantom
" ," callSelenium " ," _Selenium_IDE_Recorder "],
e = window ;
for ( var l in d) {
var v = d[l ];
if (e[v ]) return v
}
Listing 5: Noisy artifact probing
1
2
3
4
5
6
7
8
Artifact Feature Name
HTMLDocument.$cdc_asdjflasutopfhvcZLmcfl_
Window.domAutomationController
Window.callPhantom
Window._phantom
Window.awesomium
HTMLDocument.$wdc_
Window.domAutomation
Window._WEBDRIVER_ELEM_CACHE
Window.webdriver
Window.spawn
HTMLDocument.__webdriver_script_fn
Window.__phantomas
HTMLDocument.webdriver
Window.phantom
Window.__nightmare
Visit
Domains
11,409
11,032
10,857
10,696
10,650
10,509
7,013
6,123
2,756
1,722
1,526
1,363
1,244
953
909
Security
Origins
887
2,317
5,088
5,052
203
18
2,674
1,803
1,832
1,559
1,390
1,103
529
820
628
Table 7: Most-probed bot artifacts
We found bot artifact probes in the contexts of 6,257 distinct
security origin domains. Table 6 lists the top 10 origin domains for
bot detection activity. Naturally, four of the top five are affiliated
with Google’s advertising platform. Scripts running in the context
of the top domain, tpc.googlesyndication.com, probed no less
than 42 of our 49 confirmed artifacts (85%).
We believe most of these instances to be benign in intent. Ad-
vertisers have legitimate incentive to avoid paying for pointless ad
impressions by blocking bots. But large-scale (i.e., automated) web
measurement accuracy may become collateral damage in this arms
race. The future is not bright for naive, off-the-shelf web crawling
infrastructure.
Popular Artifacts. In Table 7we list our 15most popular (by visit
domain cardinality) bot detection artifacts. Unsurprisingly, given
our seed artifacts, most results appear associated with variants of
Selenium and PhantomJS. But our locality search pattern also dis-
covered artifacts of additional automation platforms: Awesomium,
NightmareJS, and Rhino/HTMLUnit. The full list of discovered arti-
facts includes a superset of all the Selenium and PhantomJS artifacts
tested for in the latest available version [54] of Fp-Scanner [55].
VisibleV8: In-browser Monitoring
of JavaScript in the Wild
detectExecEnv : function () {
var e = "";
return
( window . _phantom
|| /* more PhantomJS probes */ )
&& (e += " phantomjs ") ,
window . Buffer && (e += " nodejs ") ,
window . emit && (e += " couchjs ") ,
window . spawn && (e += " rhino ") ,
window . webdriver && (e += " selenium ") ,
( window . domAutomation
|| window . domAutomationController )
&& (e +=
},
" chromium - based - automation - driver ") , e
Listing 6: Artifact attribution in the wild
Most of the artifact names are highly suggestive and/or self-
explanatory, with the single most common association being Se-
lenium, but a few require explanation. The $cdc_... artifact is an
indicator of ChromeDriver, as $wdc_ is of WebDriver; notably, these
are among the relative minority of artifacts found on non-global
objects like window.document. spawn is an artifact of the Rhino
JS engine, which is itself an indicator of the HTMLUnit headless
browser system.
5.3 Case Studies
Explicit Bot Identification. Listing 6 shows part of a script loaded
from http://security.iqiyi.com/static/cook/v1/cooksdk.js which we
observed on visits to iqiyi.com, qiyi.com, zol.com, and pps.tv.
The script, which appeared to be the result of automatically bundling
many related library modules together, was minified but not obfus-
cated. It provides a rare example in which the attribution logic is
fairly obvious: the presence of specific artifacts directly triggers what
appears to be bot labeling via string concatenation. Note that this
example uses Window.Buffer, one of our “possible” bot artifacts,
which implies execution in the Node.js environment. Code locality
strikes again: the code immediately adjacent to this excerpt includes
functions that collect attributes of a containing  and and
detect the activation of “private browsing.”
Evasive Action. Listing 7 includes the core of an aggressively
obfuscated script loaded exactly once, from http://www.school.kotar.
co.il/. 73 other scripts in our collection share the same lexical hash.
These were loaded on visits to 10 different Alexa domains, including
https://www.payoneer.com/ and several .il domains. This script
provides a clear example of artifact-based bot deflection. The ob-
fuscation is distinctive, layering typical string garbling techniques
behind a tangle of trivial functions performing simple operations
/* Original obfuscated code excerpt */
_ = window ;
if ( u82222 .w( u82222 .O( /* ... */ ))) {}
else location [ u82222 .f( u82222 .r (11) + /* ... */ ]() ;
/* Deobfuscated version */
if (_[" phantom "] || /* more PhantomJS probes */
|| _[" Buffer "] || _[" emit "] || _[" spawn "]
|| _[" webdriver "] || _[" domAutomation "]
||
_[" domAutomationController " ]) {}
else location [" reload " ]() ;
Listing 7: Bot deflection in the wild
1
2
3
4
5
6
7
8