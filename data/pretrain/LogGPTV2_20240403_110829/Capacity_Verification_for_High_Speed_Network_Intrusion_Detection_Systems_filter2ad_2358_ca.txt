Race-conditions using symbolic links. As a ﬁrst simple example, we propose
to discuss an old classical attack using “lpr,” that has the advantage of being
well-known and very simple, yet suﬃciently illustrative. Although this particular
problem was solved, we can argue that it was not solved by updating or reﬁning
the security policy deﬁnition, but by modifying “lpr” itself to include speciﬁc,
ad-hoc inode number checking. This “patch-and-pray” approach proved to be
ineﬀective, since other attacks such as the /bin/mail vulnerability [12] rely on
an identical principle. The “lpr” attack consists in the following steps:
1. disconnect the printer
2. Ω1::lpr -s /home/bob/mydoc.ps
3. Ω2::rm /home/bob/mydoc.ps
4. Ω3::ln -s /etc/shadow /home/bob/mydoc.ps
5. connect back the printer
6. Ω4::/etc/shadow is printed by the lpr daemon
Here the user user exploits a side-eﬀect of a standard, legitimate system feature
(in this case, symbolic links) in a way that doesn’t break any access control rules
by itself, yet leads to illegal behaviour because it allows him to print the contents
of a ﬁle (/etc/shadow) even if he does not have a read access permission.
It is important to note that in this example, the initial request to print
/home/user/mydoc.ps could actually have been submitted by any user - even
one that is allowed to read /etc/shadow. Moreover, nothing prevents the user
user from creating links to /etc/shadow as long as they are under the control
of the same access rules as the ﬁle they link to. So this attack involves no illegal
operation in the access control sense.
However, the proposed model allows to detect Ω4 as a security policy viola-
tion. We suppose that the lpr daemon itself is permitted to read /etc/shadow
(in practice, this is case), i.e. Ω4 will be executed using any reference bag rs (as
302
J. Zimmermann, L. M´e, and C. Bidan
“read shadow”) where reading /etc/shadow is possible. Therefore, Ω4 is not
forbidden by itself. We consider also that the user bob operates with reference
bags that do not contain references to read /etc/shadow.
When creating the symbolic link, operation Ω3 generated references to the
symlink, since otherwise, the it could not be accessed. By default, a symlink by
itself is considered to be writable, readable and executable, depending on the
type of the ﬁle it points to. Thus:
ref3 = Ref(Ωuid:bob
3
) = uid : bob ∪ symref s
where symref s denotes the read, write and execute references to ﬁle
/home/bob/mydoc.ps in the bag uid:bob.
By creating the link, Ω3 writes to the /home/bob directory. Ω4 performs
actually two steps. The ﬁrst step, denoted Ω4.1, reads the /home/bob directory
and searches the mydoc.ps ﬁle. Therefore, Ω3 ⇒ Ω4.1 by deﬁnition. The reference
propagation rule states then that:
ref4.1 = Ref(Ωrs
4.1) = ref3 ∪ {Ruid:bob(f d.read)}
fd being a ﬁle descriptor to the /home/bob directory.
The second step of Ω4, denoted Ω4.2, actually opens the ﬁle. Triv-
ially, Ω4.1 ⇒ Ω4.2. Thus Ωref4.1
should be executed. However, the se-
mantics of a symbolic link as deﬁned in Unix, state that a read opera-
tion is permitted on the symlink if
it is permitted on the ﬁle the link
points to. That is, opening /home/bob/mydoc.ps for reading requires both
RS(/home/bob/mydoc.ps.openread) and RS(/etc/shadow.openread).
4.2
we
see
this,
Given
since
/∈ ref4.1. Neither it is possible to consider
RS(/etc/shadow.openread)
Ω4.2 as an independent concurrent operation, i.e. as Ωrs
4.2, since rs itself does not
contain required references to read /home/bob/mydoc.ps. In fact, the operation
would be possible as Ωref4.1∪rs
, but this is by deﬁnition an intrusion symptom.
possible,
that Ωref4.1
4.2
is
not
4.2
OpenSSH vulnerability. This vulnerability was published in November 2001
[13]. It is interesting to note that this is a well-known attack that originally
aﬀected the telnet daemon, which was patched. It was discovered only recently
that a similar technique could be used against OpenSSH to yield exactly the
same symptom (a regular user getting a root shell).
The OpenSSH daemon has a controversial feature that allows users to deﬁne
their own environment variables to be set on login. If so conﬁgured, this can
be exploited to introduce a Trojan horse that will prevent the user’s login shell
from being started with uid correctly set. In practice, the LD PRELOAD variable is
used to require the OpenSSH daemon to load an attacker-supplied shared library
(usually called libroot.so) that overrides the setuid system call, eﬀectively
forcing the the attacker’s session to be always started with uid set to 0. Thus,
Introducing Reference Flow Control
303
this is a means for the attacker to start a root shell without going through
appropriate authentication.
The attack includes then the following major steps:
1. Ω1::Create and install libroot.so
2. Log in as a regular user
3. Ω2::libroot.so is loaded
4. Ω3::The session’s uid is set to 0
5. A root shell is started
It is evident that Ω1 ⇒ Ω2. Similarly, the libroot.so ﬁle requires to be loaded
a buﬀer which is written by operation Ω2 and read by Ω3 when calling the
executable code, however, memory buﬀer access monitoring as described above
is needed to eﬀectively establish that Ω3 requires a read reference to this buﬀer.
The only reference to allow reading this buﬀer is Ruid:boblibroot.so.read, which
results from Ω2. In addition, Ω3 requires by deﬁnition also Rsetuid:rootsetuid.root
to perform the actual setuid call. As it is not possible to meet these requirements
within the same reference bag, Ω3 is an intrusion symptom.
4.3 Discussion
We described how two diﬀerent, realistic attacks can be detected using the pro-
posed model. We can observe, however, that in the ﬁrst example there is nothing
really speciﬁc to lpr, any race-condition attack involving symbolic links may be
detected in an identical way. It is interesting to observe that as seen in this
example, the reference propagation rules actually restrict the usage of symbolic
links. To be usable at all, a symbolic link must be created such that it points to
an object that is accessible form within the same domain. By analogy, in Unix
terms this means that if some user is not allowed to access a particular object,
neither would he be able to create symlinks to that object. This behaviour, if im-
plemented in Unix instead of the default one, would eﬀectively solve the problem
and such attacks would not be possible.
In the OpenSSH example, reference propagation forbids using a shared li-
brary to overload operations in another operation domain. Again, this is in no
way speciﬁc to OpenSSH, the same arguments hold for other attacks relying
on libroot.so, such as the original telnet attack. However, while the model
eﬀectively prevents the attack from succeeding, such a restriction on the use of
shared libraries is probably needlessly strong for practical use. Weaker reference
propagation rules for the speciﬁc case of dynamic library function calls should
be experimented.
The most promising aspect is that the model as presented appears to be able
to detect various “intrusions by delegation” given a security policy speciﬁcation.
In this sense, the proposed approach provides a policy-based intrusion detector.
No knowledge of particular program behaviour nor particular attack scenarii was
required for the policy to be deﬁned.
Obviously, authentication is the delicate part. The model makes no hypothe-
sis about the authentication process, it simply considers it as a virtual operation
304
J. Zimmermann, L. M´e, and C. Bidan
that is assumed to behave correctly according to the security policy. While it
is possible to detect attacks that circumvent authentication (as shown in the
OpenSSH example), the model itself cannot be used to detect attacks that rely
on authentication errors or cheating.
The examples show also that the security policy deﬁnition depends on a
granularity choice, which reﬂects the application context. In the present case,
our focus was on elementary system operations. A coarser approach, for instance
considering the receiving of a connection and opening a session as a single op-
eration in OpenSSH would provide a much more elegant and straightforward
view of the problem and, if needed, would allow for an easy deﬁnition of special
reference ﬂow rules. However this means making hypotheses on the OpenSSH
daemon’s internals (in this case, the fact that it simply and immediately executes
what it reads on the socket) that may or may not be true. It is also possible
to defeat the operation-based scheme by introducing hidden channels between
memory objects. For example:
1. read(fd1, a, data len);
2. for(i=0 ; i<data len ; i++) b[i]=a[i];
3. write(fd2, b, data len);
If the eﬀect of step 2 is known, it is clear that the a reference in step 1 actually
ﬂows to step 3 as the b reference. Unfortunately, this does not appear if we
consider only system operations, information ﬂow control is needed in such a
case.
For this reason, the proposed approach is suitable to handle attacks that ex-
ploit system-level features or problems; it falls short to detect attacks exploiting
such hidden channels.
5 Related Work
By deﬁnition, the proposed approach belongs to the EM class of security policy
enforcement mechanisms, as deﬁned by F. B. Schneider in [14]. In its pure form,
EM is implemented using security automata to detect illegal steps sequence pre-
ﬁxes. On the one hand, in our case sequences of steps are implicit, resulting from
the causal dependency relation. On the other hand, the deﬁnition of an illegal
step is trivial. For these reasons, the proposed EM implementation seems suit-
able for use in cases where illegal steps (i.e. intrusion goals) are well-deﬁned, but
the possible ways to achieve them are either unknown or even hardly deﬁnable.
Certain race-condition attacks can be detected by the noninterference-based
intrusion detection model recently proposed by C. Ko and T. Redmond in [9].
In this model, intrusion symptoms appear as non-commuting sequences of priv-
ileged and unprivileged operations. We can observe that by considering a strict
“privileged vs. unprivileged” distinction, then the reference propagation rule
along with the requirement that any operation should require only one reference
bag actually enforces operation commutability. However, the model proposed by
the authors requires knowledge of system call commutability, thus using it to
detect for instance Trojan horses that implement backdoor system calls (which
Introducing Reference Flow Control
305
can be easily done on Linux) seems to be non-trivial. In contrast, our proposed
approach relies on the weaker assumption of knowledge of system calls semantics
in terms of reference creation and deletion, with the default behaviour that ref-
erences are preserved unless speciﬁed otherwise (this results from the reference
propagation rule). In addition, our proposed model is more ﬁne-grained, as by
deﬁnition, it does not consider system calls to be atomic operations.
Research is very active in the information ﬂow control ﬁeld. Robust and very
mature formalisms exist [15,16] and may be useful for static security policy val-
idation in our case. Applications of information ﬂow for access control purposes
have been proposed [17,18,19]. We will examine how reference ﬂow control could
be used to implement such policies on a general-purpose operating system. How-
ever, real information ﬂow control is not applicable in this case without static
program analysis, however, hidden channels exploits cannot be detected using
the proposed approach.
6 Conclusion
We have presented an approach to detect intrusion symptoms by controlling
the ﬂow of references. As shown in this paper, the proposed approach has the
ability to detect the same symptom achieved in a variety of diﬀerent scenarii,
even scenarii unknown at the time the security policy is deﬁned. It is easy to
control reference ﬂow by observing executed system operations.
We are currently experimenting our proposed approach using a reference
ﬂow simulator with actual execution traces. In the short term, we will develop
a runtime implementation. An important part of our work, along with intrusion
detection accuracy and policy speciﬁcation eﬀectiveness, will be the performance
impact of such a module on the system.
The distributed intrusion symptom problems are yet to be addressed. This
would require dealing with remote objects through “distant references”, which
in turn involves distant reference authentication. Existing digital signature tech-
niques may provide an usable framework for such a system.
References
1. J. Allen, A. Christie, W. Fithen, J. McHugh, J. Pickel, and E. Stoner. State of
the practice of intrusion detection technologies. Technical Report SEI-99TR-028,
CMU/SEI, 2000.
2. John McHugh. Intrusion and intrusion detection. International Journal of Infor-
mation Security, July 2001.
3. D. Schnackenberg, K. Djahandari, and D. Sterne.
Infrastructure for intrusion
detection and response. In Proceedings of the DARPA Information Survivability
Conference and Exposition (DISCEX’00), 2000.
4. Fr´ed´eric Cuppens. Managing alerts in a multi-intrusion detection environment. In
Proceedings of the 17th Annual Computer Security Applications Conference (AC-
SAC 2001), December 2001.
306
J. Zimmermann, L. M´e, and C. Bidan
5. R. P. Goldman, W. Heimerdinger, S. A. Harp, C. W. Geib, V. Thomas, and R. L.
Carter. Information modeling for intrusion report aggregation. In Proceedings of
the DARPA Information Survivability Conference and Exposition, June 2001.
6. Fr´ed´eric Cuppens and Alexandre Mi`ege. Alert correlation in a cooperative intrusion
In Proccedings of the IEEE Symposium on Security and
detection framework.
Privacy, 2002.
7. Benjamin Morin, Ludovic M´e, Herv´e Debar, and Mireille Ducass´e. M2D2: A formal
In Proceedings of the Fifth International
data model for IDS alert correlation.
Symposium on the Recent Advances in Intrusion Detection (RAID’2002), 2002.
8. Prem Uppuluri and R. Sekar. Experiences with speciﬁcation-based intrusion de-
tection. In W. Lee, L. M´e, and A. Wespi, editors, Proceedings of the Fourth Inter-
national Symposium on the Recent Advances in Intrusion Detection (RAID’2001),
number 2212 in LNCS, pages 172–189, October 2001.
9. Calvin Ko and Timothy Redmond. Noninterference and intrusion detection. In
Proccedings of the IEEE Symposium on Security and Privacy, 2002.
10. Daniel Hagimont, Jacques Mossiere, Xavier Rousset de Pina, and F. Saunier. Hid-
den software capabilities. In International Conference on Distributed Computing
Systems, pages 282–289, 1996.
11. David F.C. Brewer and Michael J. Nash. The chinese wall security policy.
In
Proceedings of the IEEE Symposium on Research in Security and Privacy, pages
206–214. IEEE Computer Society Press, May 1989.
12. CMU CERT/CC. Ca-1995-02: Vulnerabilities in /bin/mail.
http://www.cert.org/advisories/CA-1995-02.html, January 26 1995.
13. CMU CERT/CC. Vu#40327: Openssh uselogin option allows remote execution of
commands as root. http://www.kb.cert.org/vuls/id/40327, November 2001.
14. Fred B. Schneider. Enforceable security policies. Information and System Security,
3(1):30–50, 2000.
15. John Rushby. Noninterference, transitivity, and channel-control security policies.
Technical Report CSL-92-02, SRI, dec 1992.
16. J. McLean. A general theory of composition for trace sets closed under selective
In Proceedings of the IEEE Symposium on Research in
interleaving functions.
Security and Privacy, May 1994.
17. E. Ferrari, P. Samarati, E. Bertino, and S. Jajodia. Providing ﬂexibility in in-
In Proceedings of the IEEE
formation ﬂow control for object-oriented systems.
Symposium on Security and Privacy, pages 130–140, 1997.
18. H. Mantel and A. Sabelfeld. A generic approach to the security of multi-threaded
In Proceedings of the 13th ProIEEE Computer Security Foundations
programs.
Workshop, pages 200–214, June 2001.
19. Steve Zdancewic, Lantian Zheng, Nathaniel Nystrom, and Andrew C. Myers. Un-
trusted hosts and conﬁdentiality: Secure program partitioning. In Proceedings of
the 18th ACM Symposium on Operating Systems Principles, 2001.
The Effect of Identifying Vulnerabilities and Patching
Software on the Utility of Network Intrusion Detection*
Richard Lippmann, Seth Webster, and Douglas Stetson
Lincoln Laboratory MIT, 244 Wood Street, Lexington, MA 02173-9108
PI:EMAIL
important 
remote-to-local  vulnerabilities  demonstrates 
Abstract.  Vulnerability  scanning  and  installing  software  patches  for  known
vulnerabilities  greatly  affects  the  utility  of  network-based  intrusion  detection
systems that use signatures to detect system compromises. A detailed timeline
analysis  of 
(1)
Vulnerabilities  in  widely-used  server  software  are  discovered  infrequently  (at
most 6 times a year) and (2) Software patches to prevent vulnerabilities from
being  exploited  are  available  before  or  simultaneously  with  signatures.
Signature-based  intrusion  detection  systems  will  thus  never  detect  successful
system compromises on small secure sites when patches are installed as soon as
they are available. Network intrusion detection systems may detect successful
system  compromises  on  large  sites  where  it  is  impractical  to  eliminate  all
known vulnerabilities. On such sites, information from vulnerability scanning
can be used to prioritize the large numbers of extraneous alerts caused by failed