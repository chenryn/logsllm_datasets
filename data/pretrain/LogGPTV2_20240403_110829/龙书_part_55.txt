23.
22.
6
5:2 (1962), Pp. 127-129.
n3,” Information and Control 10:2 (1967), pp. 189-208.
Schorre, D. V.,
Parr, T., "ANTLR," http://www. antlr.org/ .
Naur, P. et al., “Report on the algorithmic language ALGOL 60, Comm
Natl. Conf. (1965), pp. 262-274.
McClure, R. M., "TMG--a syntax-directed compiler," PROO. 20th ACM
ACM 15:3 (1968), Pp. 465-488.
 uonpsuen pas-euas, sures  'H pue I  'd 'sm
Korenjak, A. J., “A practical method for constructing LR(k) processors,
Knuth, D. E., "On the translation of languages from left to right," Infor-
Comm. ACM 12:11 (Nov., 1969), pp. 613-623.
Laboratory, Bedford, MA, 1965.
 Kasami, T., “An efficient recognition and syntax analysis algorithm for
1963), pp. 1-17.
Available at http: //dinosaur.compilertools.net/yacc/ .
Johnson, S. C., “Yacc
"Meta-II: a syntax-oriented compiler writing language,
AFCRL-65-758, Air Force Cambridge Research
193
---
## Page 210
使用的中间语言的代码。
有多种类型，比如数字、类型、表格引用或串。这些串甚至可能是很长的代码序列，比如编译器
个语法分析树的结点，那么X的属性可以被实现为代表X的结点的记录的数据字段。属性可以
我们用 X.α 来表示α 在某个标号为 X的分析树结点上的值。如果我们使用记录或对象来实现这
属性和文法符号相关联，而规则和产生式相关联。如果X是一-个符号而α是X的一个属性，那么
5.1语法制导定义
过程联系起来。
较小的类别，称为“S 属性翻译方案”（S 代表综合），这类方案可以很容易地和自底向上语法分析
案，这一类方案实际上包含了所有可以在语法分析过程中完成的翻译方案。我们还将研究一个
的语法分析树。因此，我们将研究--类称为“L属性翻译"（L代表从左到右）的语法制导翻译方
结点来计算结点的属性值。在很多情况下，翻译可以在扫描分析过程中完成，不需要构造出明确
更加高效，因此更适合用于翻译的实现。
产生式体中的任何位置。
序。在产生式(5.2)中，语义动作出现在所有文法符号之后。一般情况下，语义动作可以出现在
段。比如
低效的。
是根据E,、7的翻译结果和“+"构造得到的，但直接通过字符串操作来实现这个翻译过程是很
是通过将 E．code、T. code 和字符+连接起来而得到的。虽然这个规则明确指出对 E的翻译结果
生式头部的出现。E和T都有－个字符串类型的属性 code。上面的语义规则指明字符串 E.code
一个从中缀表达式到后缀表达式的翻译器可能包含如下产生式和规则：
个语言构造联系起来。语法制导定义通过与文法产生式相关的语义规则来描述属性的值。比如，
语言。本章包含了一个有关排版的例子。
在第6 章中用于类型检查和中间代码生成。这些技术也可以用于实现那些完成特殊任务的小型
语法制导定义(Syntax-Directed Definition,SDD)是一个上下文无关文法和属性及规则的结合。
最通用的完成语法制导翻译的方法是先构造一棵语法分析树，然后通过访问这棵树的各个
对于这两种标记方法，语法制导定义更加易读，因此更适合作为对翻译的规约。而翻译方案
按照惯例，语义动作放在花括号之内。（对于作为文法符号出现的花括号，我们将用单引号
这个产生式有两个非终结符号E和T，E，的下标用于区分E在产生式体中的出现和E在产
如2.3.2节所讨论的，我们把一些属性附加到代表语言构造的文法符号上，从而把信息和一-
本章继续2.3节的主题：使用上下文无关文法来引导对语言的翻译。
第5章语法制导的翻译
,E→E+T
产生式
{+,d}+←
E.code = E.code I| T.code il 't'
语义规则
本章讨论的翻译技术将
(5.2)
(5.1)
---
## Page 211
我们将看到，它就是整个表达式的值。
只能通过 N 的子结点或N本身的属性值来定义。
5. 1.1 继承属性和综合属性
一些方便。比如允许打印桌上计算器计算得到的结果，或者和一个符号表进行交互。等到在5.2
头部非终结符号的一个属性。
质。在一个S 属性的 SDD 中，每个规则都根据相应产生式的产生式体中的属性值来计算产生式
是
二个产生式类似，它的规则将子结点的值相乘，而不
值和对应于 T 的子结点的 val 值相同。产生式 4 和第
的和。
N
任何标号为 E 的语法分析树结点 N上，E 的 ual 值是
和 T的值的和，作为产生式头E的val 属性的值。在
时假设终结符号 digit'具有一个综合属性 lexval，它是由词法分析器返回的整数值。
结尾标记的表达式求值。在这个 SDD 中，每个非终结符号具有唯一的被称为 ual 的综合属性。我们同
例5.1
供的词法值，在SDD 中没有计算终结符号的属性值的语义规则。
上的一个综合属性通过结点N本身的继承属性来定义。
 val 赋予一个 digit 的值，即由词法分析器返回的词法单元 digit 的数值。
相加。产生式5和6的规则和第三个产生式的规则类似，它们拷贝子结点的值。产生式7丝
的两个子结点（标号分别为E和 T)上的 val 值
继承属性的方法计算得到 B.c。在实践中很少需要这种属性。
点的子结点上的属性拷贝过来。然后，我们使用属性B.c、B.c2、来替换子结点属性，按照
建附加的 B 的属性，比如 B.c、B.c2、··来模拟。这些都是综合属性，用于把标号为 B 的结
弟结点上的属性值来定义，我们可以定义的翻译的种类并不会增加。这样的规则可以通过创
2）继承属性（inheried attribute）：在分析树结点 N上的非终结符号B的继承属性是由 N的父
（1）综合属性（synthesized atribute）：在分析树结点N上的非终结符号A 的综合属性是由 N上
语法制导的翻译
--个只包含综合属性的 SDD 称为 S 属性(S-atribute)的 SDD，图 5-1 中的 SDD 就具有这个性
产生式2 E→E+T也有一个规则。它计算出，
产生式 1 L→E n 的规则将 L.val 设置为 E.val。
 终结符号可以具有综合属性，但是不能有继承属性。终结符号的属性值是由词法分析器提
我们将处理非终结符号的两种属性：
产生式3 E→T有唯一的规则，它定义了 E的 ual
即使我们允许结点 N上的一个继承属性 B.c通过 N的子结点、N本身、N的父结点和兄
图5-1 中的 SDD 基于我们熟悉的带有运算符＊和+的算术表达式文法。它对一个以 n 作为
另一种定义继承属性的方法 
9
C
C
图5-1
F → digit
F→(E)
+
12
产生式
的语法制导定义
一个简单的桌上计算器
F.val = digit.lexval
F.val = E.val
T.val = F.val
T.val = T1.val x F.val
E.cal = E1.val + T.oal
L.val = E.val
val = T.val
语义规则
195
口
---
## Page 212
第一-和第三个子结点上的 T. ual =3 和 F.val =5 之后
我们可以看到每个结点都关联了一个结果值。比如，在图中结点＊的父结点上，当计算得到它的
析器提供。对应于非终结符号的每个结点都有--个按自底向上顺序计算得到的 nal 属性。在图中
例5.2
介绍这类 SDD。
类，它们能够保证对每棵语法分析树都存在一个求值顺序。我们将在5.2节中
对上的 A.s 和 B.i之间的循环依赖关系如图 5-2 所示。
上的B.中的一个的值，然后再求出另－个的值。一棵语法分析树的某个结点
产生式和规则如下：
求值。比如，考虑非终结符号A 和B，它们分别具有综合属性 A.s 和继承属性 B.i。同时它们的
序遍历的顺序。对于 S 属性定义的求值将在5.2.3 节中讨论。
之前，必须求出该结点的所有子结点的属性 val 的值。
值。比如，如例5.1所示，所有的属性都是综合属性，那么在我们对一个结点上的 val属性求值
语法分析树的某个结点的一个属性进行求值之前，必须首先求出这个属性值所依赖的所有属性
它的各个属性的值的语法分析树称为注释语法分析树（anotated parse tree）。
要构建语法分析树。因此，我们想象一下在应用一个 SDD 的规则之前首先构造出一棵语法分析
5.1.2在语法分析树的结点上对 SDD 求值
通过其他属性值和常量值来定义一个属性值。
性 L. val。
者的区别在于，Yacc 程序在产生式1 的规则中通过副作用打印了 E.uval 的值，而不是定义属
图 4-58 中的Yacc 程序的另－-种表示，该程序演示了在 LR 语法分析过程中进行翻译的过程。两
作用。
节中讨论了属性的求值顺序之后，我们将允许语义规则计算任意的函数，这些函数可能会有副
简单地讲，虽然这个问题是可判定的，但即使9P=A成立，它也不可能使用多项式时间的算法来求解，因为它具
对于同时具有继承属性和综合属性的 SDD，不能保证有一个顺序来对各结点上的属性进行
我们如何构造一棵注释语法分析树呢？我们按照什么顺序来计算各个属性？在我们对一棵
在语法分析树上进行求值有助于将 SDD 所描述的翻译方案可视化，虽然翻译器实际上不需
196
 从计算的角度看，给定一个 SDD，很难确定是否存在某棵语法分析树使得
对于综合属性，我们可以按照任何自底向上的顺序计算它们的值，比如对语法分析树进行后
一个 S 属性的 SDD 可以和--个 LR 语法分析器--起自然地实现。实际上，图5-1 中的 SDD 是
这些规则是循环定义的。不可能首先求出结点 N上的 A.s 或 N的子结点
有指数的时间复杂性。
图5-3显示了一个对应于输人串3*5+4n的注释语法分析树，该图5-2A.s和 B.
A→B
产生式
后，我们应用了相应的规则，指明 T. pal 就是这
语义规则
第5章
---
## Page 213
digit.lexval，等于3。
的。它的父结点对应于产生式 4，即 F-→digi。和这个产生式相关的唯--语义规则定义 F.pal =
分析树中最左边的标号为 digit 的叶子结点具有属性值 lexval = 3，其中的3 是由词法分析器提供
就通过综合属性向上传递到树的根部。
的处理过程。当所有的因子都处理完毕后，这个结果
承
定
分量是通过继承得到的。更准确地说，产生式 T"一>
有
结符号 digit有一个综合属性 lexal。非终结符号 T具
为说明自顶向下语法分析的例子。
运算符*。
分析过程首先使用了产生式T→FT"。这里，F生成了数位3，但是运算符＊由 T'生成。因此，左
例5.3
况。下面的例子显示了如何使用继承属性来解决这个问题。
法不是为了翻译而定义的，而是以语法分析为目的进行定义的，因此可能会产生这种不匹配的情
两个值的乘积，即15。
为了了解如何使用这些语义规则，考虑图 5-5 中对应于3＊5 的注释语法分析树。这棵语法
值。如果项中还有更多的因子，我们可以继续这样
了x的值。对应于*z的子树的根结点继承了x*y
一个项x*y*z，对应于*y*z的子树的根结点继
TF}的头 T继承了产生式体中＊的左运算分量。给
有两个属性：继承属性 inh 和综合属性 syn。
这些语义规则基于如下思想：运算符＊的左运算
语法制导的翻译
非终结符号T和 F 各自有一个综合属性 ual，终
这个例子中的文法摘自常见的表达式文法的无左递归版本，我们在4.4节中使用这个文法作
当一棵语法分析树的结构和源代码的抽象语法不“匹配”时，继承属性是很有用的。因为文
图5-4中的SDD计算诸如3＊5 和3＊5＊7这样的项。处理输人3＊5的自顶向下语法
digit.lezval = 3
F.val = 3
T.val =3
图5-33*5+4n的注释语法分析树
E.uval = 15 
digit.lezval = 5
F.val = 5 digit.lerval = 4
L. val = 19
2）
1）