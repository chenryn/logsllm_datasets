behavioral  intercession (step  2),  the  metaobject  acts  on  its 
object  to  trigger  the  execution  of  the  intercepted  method 
329 
invocation.  The  considered  MOP  distinguishes  between 
methods belonging to the Service interface of the object and 
internal methods  encapsulated in  the  object  implementation. 
The activity of these internal methods (step 3) is not reified to 
the object's metaobject. Steps 4 and 5 show the path followed 
by the generated output values. 
client object 
server object 
Figure 2. MOP interactions 
The structural view of the base-level object handled by  its 
metaobject includes the  reference of the object, its attributes 
and their types, its methods and their respective signatures, the 
inheritance links, etc. This information can be retrieved using 
the  introspection mechanisms of  the  MOP. This enables the 
metaobject to reason about the current state of  its base-level 
object and customize that state using structural intercession. 
The  above  object-metaobject interactions are  defined  in 
terms  of  method  invocations exchanged  through  two  well- 
known interfaces called rejective interfaces: 
The  Metaobject  interface  through  which  metaobjects  are 
notified about events goveming thebehavi'or,ofi their objects. 
The Object interface, which1 is. used by metaofij$cus  to act on 
their objects. 
Through  the  Object  interface, ti netaobject  can  inspect the 
state of its object, modify that state and trigger the execution 
of  one of  the object's methods. It must be noted that both the 
introspection and  the  structural intercession mechanisms  of 
the  MOP  are  not  controllable  through  the  Metuobject 
interface.  Metaobjects  activate  these  mechanisms  when 
necessary  according  to  the  needs  associated  with  the  non- 
functional requirements of  the  system,  or  upon  requests  of 
other metaobjects. 
We  do  not  consider  multi-threaded  objects  and  other 
sources of  non-determinism in  the  generic  MOP presented 
above, i.e., we assume that  both  objects and metaobjects are 
deterministic and mono-threaded system components. 
3.  A Strategy for Testing MOPs 
The test  strategy has been  defined for the  verification of 
MOP-based dependable reflective architectures. It is part of  a 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:26 UTC from IEEE Xplore.  Restrictions apply. 
complete test strategy whose main concern is the incremental 
verification of: 
1.  Functional mechanisms defined by the base-level; 
2.  Reflective  mechanisms  used  to  compose  the  functional 
mechanisms and the non-functional mechanisms  supplied 
by the meta-level; 
3.  Non-functional mechanisms given by the meta-level; 
4.  Composition of functional and non-functional mechanisms 
using the MOP reflective mechanisms. 
Phases  1,  3  and  4,  which  are  highly  dependent  on  the 
particular 
functional  and  non-functional  mechanisms 
implemented in  the target reflective architecture, are beyond 
the scope of this paper. Regarding phase 2, emphasis was put 
on  analyzing  the  MOP  interaction  mechanisms  shown  in 
Figure 2, in order to propose a generic test strategy that may 
be used for any MOP of the family described in Section 2. 
The generic strategy specifies a test order for the protocol 
mechanisms  that  aims  to  reduce  the  testing  effort  by 
promoting  a  gradual  increment  of  the  observability  and 
controllability of  the  mechanisms  under  test. The goal  is  to 
enable the reuse of  those mechanisms that have already been 
tested for verifying the remaining ones. Four testing levels are 
thus  identified, and  for  each  level  we  characterize  the  test 
objectives and  the required test environment. The objectives 
are focused on the verification of the properties expected from 
each reflective mechanism in order to be confident on  its use. 
Obviously, the instantiation of the strategy for the testing of a 
the  MOP 
target  MOP  will  have 
implementation.  It  will  be  exemplified  on  the  !FKI!€qDS 
architecture [ 131 in Section 4. 
to  comply  with 
3.1. Overview of the Strategy 
The activation of the reflective mechanisms is based on the 
interaction channel used by  objects and metaobjects. Hence, 
exercising (and thus testing) these mechanisms require a high 
level of confidence in the interaction channel. This confidence 
may be  obtained by  testing the process followed to establish 
the  interconnection. But  the  issues  related  to  this  very  first 
testing 
the  MOP 
implementation  and  thus,  they  vary  from  one  MOP  to 
another.  As  a  result,  the  strategy  cannot  provide  general 
guidelines  for  this  level  although  we  assume  that  it  is 
successfully achieved in the first place. 
level  are  highly  dependent  on 
Once  objects  and  metaobjects  are  correctly  linked,  the 
reflective mechanisms of the MOP are exercised following a 
test  order  defined  according  to  the  dependencies  existing 
among these mechanisms. These dependencies are exploited 
in order to define an incremental test strategy that reduces the 
testing effort  to  be  spent.  In  accordance  with  this  goal,  we 
propose the following order to conduct the testing process of 
the four reflective mechanisms identified in Figure 1 : 
Structural intercession mechanisms. 
Behavioral intercession mechanisms; 
Testing level 1.  Reification mechanisms; 
Testing level 2. 
Testing level 3.  Introspection mechanisms; 
Testing level 4. 
The relevance of this order will appear all through the next 
sections  that  describe  the  testing  levels. For  each  level,  we 
give  the  test  objectives, i.e., the  requirements  to  be  met  by 
(and thus tested on) the implementation of the target reflective 
mechanisms. Then, the necessary test environment is defined 
in  terms  of  the  entities participating in  the  test experiments 
(server object, metaobject, test driver and oracle objects), the 
interactions among these entities, and the conformance checks 
to be  performed  in  order  to decide whether or not the MOP 
passes the tests. The role of the oracle object is to verify that 
the test executions meet the requirements: it analyzes the test 
results  according  to  an  oracle  procedure  that  implements 
conformance  checks. The test driver object manages  the test 
experiments: (i) it acts as a client object to exercise the MOP 
by  supplying it with test case input values and, (ii) it provides 
the  oracle  object  with  (part  of  the)  data  that  the  oracle 
procedure uses to determine correctness during test execution. 
3.2. Testing Level 1: Reification Mechanisms 
The behavioral image supplied to the object’s metaobject 
the  reification  mechanisms  must  be  complete  and 
by 
consistent with  the real  object activity. Hence, completeness 
and consistency are requirements to be verified: 
1. Completeness requirement - Every message received by  a 
server object  through its Service interface must be  reified 
(notified)  to  the  server’s metaobjcct.  Any  invocation  not 
observed at the meta-level invalidates the interpretation of 
the object’s execution model performed by the metaobject. 
2. Consistency  requirenient  -  Reification  messages  must 
provide  the  metaobject  with  a  correct  view  of  the  events 
triggered  at  the  base-level.  In  our  case,  these  events  are 
method  invocations.  Consequently,  reification  messages 
must  identify the  invoked method and give  the parameter 
values  used  in  the  invocation.  Then,  (possible)  output 
values produced in response to the activation of the invoked 
method have to be returned to the client object. 
Figure  3  shows  the 
test  environment  required  for 
conducting  test  experiments.  The  object  Service  interface 
must  be  defined  using  operations  with  various  types  of 
method signatures in order to test the capacity of the MOP for 
handling  a  significant  sample  of  signatures,  e.g.,  different 
directional  parameter  qualifiers 
and 
input/output  parameters),  different  parameter  data  types 
(language built-in types, structures, arrays.. .), different retum 
data  types.  It  is  also  necessary  to  consider  interfaces  that 
inherit operations from other interfaces. 
(input,  output, 
The test environment works as follows. Each time the test 
driver object  sends a request (i.e., a test case input value) to 
330 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:26 UTC from IEEE Xplore.  Restrictions apply. 
metaobject through the  behavioral intercession mechanisms 
which are under test, and thus, not yet reliable. As a result, the 
report must be supplied directly by the base-level object. 
Figure  4  represents  the  test  environment.  The  object 
Service  interface  must  be  defined  using  operations  with 
various  method  signatures  (see  Section  3.2). As  explained 
above,  here  the  server  object  must  report  on  its  internal 
activity (notion of  verbose  object). As a result, in addition to 
the code related to the event treatment, every method - public, 
protected  or  private  - has  to  generate  an  execution  trace 
containing at least its name, the values of  its parameters, and 
the output values obtained after completion of its execution. 
a ''1 
Behevlornl  intercession 
Test driver object 
Figure 4: Testing of the behavioral 
intercession mechanisms of the MOP 
server object 
Test experiments proceed as follows. The test driver object 
sends requests to  the  server object, which  are reified  to  the 
metaobject (step 1). Both the format and the contents of every 
reified message may be  considered as correct since they are 
built  by  the  reification  mechanisms that  have already  been 
tested  according to the strategy. The metaobject involved  in 
this environment delivers the reified information to its object 
(step 2). Then, the behavioral intercession mechanisms should 
trigger the execution of the server object code in charge of the 
initial request treatment (step 3), and return the output values 
to  the  metaobject  (step  4).  In  addition,  the  server  object 
produces the execution trace for the oracle object (step 5). The 
values returned to  the metaobject are transmitted to  the  test 
driver object by  way of the - presumably correct - reification 
mechanisms  (step  6).  Then,  the  driver  object  sends  the 
following data to the oracle object (step 7): (a) the name of the 
invoked  method,  (b)  the  parameter  values  used  in  the 
invocation,  and  (c)  the  output  values  delivered  by  the 
metaobject.  Finally, 
the 
compliance between the data supplied by the server object and 
by the test driver object (step 8). 
the  oracle  procedure  checks 
3.4. Testing Level 3: Introspection Mechanisms 
The 
introspection  mechanisms  provide  means  to  a 
metaobject  for retrieving  structural data  from  its  base-level 
331 
a\ 2 
I 
1 
Comparison : 
* Invalod method 
* Parameter values 
* Oufpul values 
'-0bservatton 
Methodexecuhon  I S  slmulated 
bygenerahng a random value 
. 
8  for  each output p,m"er 
- 
J 
Test driver object 
server object 
Figure 3: Testing of the reification 
mechanisms of the MOP 
3.3. Testing  Level  2:  Behavioral  Intercession 
Mechanisms 
The  behavioral 
intercession  mechanisms  allow  a 
metaobject to act on its object in order to trigger the execution 
of the invoked method. Hence, the test objectives are to verify 
their capacity for (1) activating the right code of the base-level 
object  with  the  correct  input  parameter  values,  and  (2) 
returning to the metaobject the output values produced by the 
object's  code. To decide whether or  not  a  MOP passes the 
tests, the oracle procedure needs to get a report on the actual 
object activity in  order to compare it  with  the  image of  the 
object activity obtained through the MOP. This report cannot 
be  delivered through the MOP for two reasons. First, due to 
encapsulation, the metaobject may not know anything about 
the internal activity of its object. Second, even breaking this 
encapsulation,  the  information  would  be  supplied  to  the 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:26 UTC from IEEE Xplore.  Restrictions apply. 
object. These data are related to the object state defined by the 
current values of the object attributes. Depending on the non- 
functional  mechanisms  implemented  at  the  meta-level,  the 
introspection mechanisms may have to supply all the attribute 
values,  or  only  some  of  them.  Testing  these  mechanisms, 
without  making  any  assumption  about  their  future  use  in  a 
specific system, may  be performed  by  considering the most 
general case, i.e., when all the attribute values are retrieved. 
The test objectives are then to verify that the full image of the 
object  state  obtained  from  the  introspection  mechanisms 
conforms to the actual object state (same attribute values). 
As said in  Section 2.2, the introspection mechanisms are 
not  controllable  through  the Metuobject  interface. They  are 
triggered at the meta-level through a specific interface, called 
MetuControl (see  Figure 5). The metaobject  involved in  the 
test  environment  must  implement  this  second  interface.  In 
order  to  check  the  capacity  of  the  MOP  for  handling  a 
representative  sample  of  attributes,  the  server  object  must 
possess  attributes  with  various  types  and  different  levels  of 
visibility  (e.g.,  public,  protected,  private).  Inheritance  is 
another feature to be considered at this testing level. 
attributes. Public attributes may be directly initialized, while 
attributes  with  a  more  restricted  visibility  may  cause  a 
controllability  problem.  A  simple  solution consists  in  using 
the server object constructor, which in that case must provide 
means  for  initializing  the  entire  object  state  from  the 
parameter values used in its activation'. 
3.5. Testing  Level  4:  Structural  Intercession 
Mechanisms 
Like 