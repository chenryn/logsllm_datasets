分析. https://github.com/MG1937/AntiProguard-KRSFinder 
  而该项目的实现本质无疑是分析整个 Apk 工程的 Dalvik 操作码,为操作码分配相应的句柄以具体处
理操作码的操作对象,并依据处理结果进一步分析 Apk 内各个类的成员与方法,生成对应的分析报告用以
联动 JADX.(关于 Dalvik 操作码,可以参考 Gabor Paller 于 2009 年提供的 Dalvik Opcodes). 
像 Dalvik 虚拟机一样思考 
分析 Apk 无不分析其 Dex,分析 Dex 无不 Dump 其 IR,得其 IR,何如?  
正如前文所述,该项目旨在通过分析成员间关系与 DataFlow 以辅助逆向工程,然则不论如
何分析,深入到 Dex 文件其操作码总是必要的.虽从 Dex 中获取 Dalvik 操作码的方法有千百
种,但论如何处理操作码及其处理思想,固然是要引 Google 之鉴的.然则自 Android5.0 开
始,Google 就弃用 Dalvik 转而以 ART 虚拟机处理 Dex,但 ART 绝大情况下使用 AOT 技术,仅于
技术需求而言,该项目对操作码的处理思想必然要取 JIT 之鉴,故该部分将分析 Dalvik 虚拟机
处理字节码的部分实现,进以指导项目实现. 
  以 Android-4.0.1_r1 分支下的 Dalvik 虚拟机源码为例,Dex 实例将流入 Frontend.cpp 文件下 
dvmCompileTrace 函数,该函数正是将 Dalvik 字节码转换为机器码的入口函数. 
该函数不断遍历包含字节码的基本块,最终将携带 Dalvik 字节指令的 cUnit 成员引用传入 
compileLoop 函数下,而 compileLoop 函数最终将引用传入 CodegenDriver.cpp 文件下的关键函数 
dvmCompilerMIR2LIR , 顾名思义,此函数将 Dalvik 字节指令处理为 LIR,最终由其他方法处理 LIR 为机器
码. 
dvmCompilerMIR2LIR 函数下 cUnit 成员引用中携带的 Dalvik 字节码被 dexGetFormatFromOpcode 
函数下处理为 dalvikFormat 成员,最终该成员被传入一个巨大的 switch-case 块中进行处理,该 switch-
case 块根据 dalvikFormat 成员为 cUnit 成员分配对应的处理句柄(handle)以具体处理其携带的 Dalvik
字节码即其操作对象(即寄存器). 
  至此,Android4.0 Dalvik 虚拟机处理字节码的大致流程已经分析完毕,如上图流程图所示,该流程及
其 Dalvik 字节码处理思想将被运用到接下来的项目结构中. 
项目实现 
项目已经开源 , 可至 AntiProguard-KRSFin d e r 下 查看项目具体代码 . 
  基于前文对 Dalvik 虚拟机处理字节码的流程分析,基于 Dalvik 思想绘制如上流程图,该图所示流程在
项目正式开始前被作为理想流程框架用以指导项目进行,并且在已经完成的项目中其对字节码的大致处
理流程也接近该理想流程框架. 
由 Dalvik 虚拟机源码下 docs 文件夹中文档的部分描述可知 Dalvik 虚拟机是基于寄存器的.故项目也
需要一个组件用以储存寄存器,该组件即为项目中 TempRegisterMap.cs 文件下的 TempRegisterMap 类.而
该组件本质上是一个 Dictionary 对象,该 
组件其键为 Dalvik 操作码具体操作的寄存器其名(即 p0,v0...),其值为 TempRegister 对象,该对象即代表一
个具体的寄存器,此寄存器目前仅需要储存字符串与方法.下图为该组件大致结构. 
  下面部分为项目对单个 Dalvik 字节码处理部分,该部分模仿了 Dalvik 虚拟机处理字节码的模式. 
  上图为项目下 MethodCodeAnalyseModule.cs 文件中 MethodCodeAnalyseModule 类的 methodAnalyse 函
数,该函数为项目处理操作码的正式入口,可以看到该部分我效仿 Dalvik 虚拟机处理单个字节码的流程模
式,为即将处理的操作码分类,并为之分配处理句柄以具体解析操作码及其携带的寄存器,值得一提的是该
函数的实现并不完全与 Dalvik 虚拟机处理操作码的形式相同,在正式为操作码分配处理句柄前,我将操作
码的处理优先级以 MUST , CHECK , PASS 划分,被赋予 MUST 优先级的操作码将被优先分配处理句柄,赋予 
CHECK 优先级的操作码将在检查其具体操作的寄存器是否有必要处理后再为操作码分配处理句柄,赋予 
PASS 优先级的操作码将不进行任何解析,以此略去部分不必要解析的操作码,以加快整个流程的处理速 
度. 
  在正式进入下个部分前,有必要阐述清楚函数中方法区块(以下称为块)的含义.  
Dex 中以 MIR 形式储存的函数不仅以多个字节码组成的串形式保存,单个函数也可被分为多个块,即
以多个块组成一个函数, 欲简单理解块,可以 ASM 中的 JMP 指令为参考,JMP 指令可以跳跃到内存中的
任意地址,而在 Dalvik 中则以块为跳跃对象,即在 Dalvik 中以块为基本单位组成执行流程.以市面上常见
的工具抽离 Dex 其操作码串,输出的结果中大多以高级语言中 Label 的形式表示函数中的块,如下图为带
有多个块的函数片段. 
下面部分为项目对单个函数的处理部分. 
  先假设项目即将对一个函数进行处理,且该函数被分为数量未知的多个块,而上图所示流程即为项目
在该情况下的大致处理流程,假设一个理想情况,此时块与块之间没有任何指令使得程序跨块跳跃,即执行 
流程从块顶部向下执行直到方法结束,那么项目将在每个块执行结束时,立刻截取当前块的寄存器集(即 
TempRegisterMap 组件)快照,并且记录当前的执行路线,以寄存器集快照为引索保存每次执行路线,那么在
该执行流程下,寄存器集将以如下图情况保存. 
  那么此时假设块与块之间出现了一个或多个流程控制指令(如 if,goto). 
• 若流程控制指令为 goto 指令,项目将标记其操作对象为强行跳转目标,并继续向下执行,但不具体解 
析非强行跳转目标的块,直到目标块被找到才具体对块中操作码进行解析. 
• 若为 if 类指令,项目将仅对其操作对象进行标记,而不令项目强行寻找目标块,正常向下执行并解析
块. 
以如上两种流程控制方法尽可能覆盖到大多数由流程控制指令导致的未知数量的解析路线. 
假设块与块之间出现了数量未知的 goto 指令,此时处理流程将为下图所示. 
从流程上来看似乎处理过程没有太大变化,但此时构造一个在 Dalvik 执行流程上能够影响寄存器内
容的函数片段,此时且看下图处理结果. 
  项目对流程的控制及寄存器集快照保存的作用就在此体现,从上图给出的函数片段可知块 L1 中的 
v1 寄存器为执行流程所改变,若不保存寄存器集快照,就不能够完全记录寄存器的前后变化. 
上文即为项目对单个函数的大致处理流程,该部分也是项目最核心的部分,不论是成员关系分析还是
DataFlow 分析,其结果的精确度都依赖于此,更多细节不再在此文写出,至此,本文完结.