is 25.73%, the 90th percentile of the overhead is 68.37%.
However, the signi(cid:12)cance of these results is limited as we
are unable to control for network-induced delay. In order to
eliminate these e(cid:11)ects, we conducted the following experi-
ments locally.
Using the laptop, we determined how the user experience
is a(cid:11)ected by TrueHTML in typical scenarios, like using a
web mailer or browsing popular webpages. We therefore
assigned document.body.innerHTML of an otherwise empty
DOM to the content of a typical email body of a multi-
part message (consisting of both the content types text/-
plain and text/html), the scraped content of the landing
pages of google.com, yahoo.com, baidu.com, duckduckgo.
com, youtube.com, and the scraped content of a map dis-
play on Google Maps, as well as of a Facebook pro(cid:12)le and
a Twitter timeline. Each generated page was accessed three
times and the load times logged per criteria described earlier
on. The data were generated locally, thus the results do not
contain network-induced delays. Table 2 shows the average
values.
The results of the previous test show that the user-perceived
page load time is not only dependent on the size of the
content, but also reliant on the structure and type of the
markup. While the data show that in no case the user expe-
rience is negatively a(cid:11)ected in the typical use cases, this kind
of evaluation does not o(cid:11)er a generic insight into how True-
HTML performance overhead relates to content size and the
amount of markup elements. To evaluate this in a controlled
environment, we generate a single  markup frag-
ment that contains 1kB of text. Again, we assigned doc-
ument.body.innerHTML of an otherwise empty DOM this
markup element between one and one hundred times, cre-
ating pages containing one element with 1kB text content,
scaling up to pages containing one thousand with 1000kB of
text content. As before, the data was generated locally. We
compare page load times with and without TrueHTML as
described above. While the load time increases slightly with
size and the amount of markup elements, it can be seen from
Figure 2 that the performance penalty introduced through
TrueHTML does not raise signi(cid:12)cantly.
7. RELATED WORK
XSS. First reported back in the year 2000 [6], Cross-Site
Scripting (XSS) attacks gained recognition and attention
from a larger audience with the Samy MySpace worm in
2005 [17]. Several types of XSS attacks have been described
thus far.
Figure 2: Page load time plotted against page size/#markup elements
Content
DuckDuckGo
Email Body
Baidu.com
Facebook pro(cid:12)le
Google
Youtube
Twitter timeline
Yahoo
Google Maps
Size w/o TH w/ TH
361 ms
349 ms
466 ms
520 ms
577 ms
1346 ms
1164 ms
937 ms
782 ms
336 ms
316 ms
336 ms
539 ms
533 ms
1216 ms
1133 ms
893 ms
756 ms
8.2 kB
8.5 kB
11 kB
58 kB
111 kB
174 kB
190 kB
244 kB
299 kB
Table 2: User-perceived page load times ordered by
content size with and without TrueHTML (TH)
Re(cid:13)ected XSS, which typically present a user with an
HTML document accessed with maliciously manipulated pa-
rameters (GET, HTTP header, cookies). These parameters
are sent to the server for application logic processing and the
document is then rendered along with the injected content.
Stored XSS, which is injected into web pages through user-
contributed content stored on the server. Without proper
processing on the server-side, scripts will be executed for
any user that visits a web page with this content.
DOM XSS, or XSS of the third kind, which was (cid:12)rst de-
scribed by Klein [18]. It may be approached as a type of
re(cid:13)ected XSS attack where the processing is done by a Java-
Script library within the browser rather than on the server.
If the malicious script is placed in the hash part of the URL,
it is not even sent to the server, meaning that server-side
protection techniques fail in that instance.
Server-side mitigation techniques range from simple char-
acter encoding or replacement, to a full rewriting of the
HTML code. The advent of DOM XSS was one of the main
reasons for introducing XSS (cid:12)lters on the client-side. The
IE8 XSS Filter was the (cid:12)rst fully integrated solution [25],
timely followed by the Chrome XSS Auditor in 2009 [4].
For Firefox, client-side XSS (cid:12)ltering is implemented through
the NoScript extension6. XSS attack mitigation has been
covered in a wide range of publications [5, 8, 9, 16, 26, 35].
Noncespaces [10] use randomized XML namespace pre(cid:12)xes
as a XSS mitigation technique, which would make detec-
6mXSS is mostly not in scope for these, thus remains unde-
tected
tion of injected content reliable. DSI [23] tries to achieve
the same goal based on a classi(cid:12)cation of HTML content
into trusted and untrusted content on the server side, sub-
sequently changing browser parsing behavior to take this
distinction into account. Blueprint [21] generates a model
of the user input on the server-side and transfers this model,
together with the user-contributed content, to the browser;
browser behavior is modi(cid:12)ed by injecting a Javascript li-
brary to process the model along with the input. While the
method to implement Blueprint in current browsers is re-
markably similar to our mitigation approach, it seems hard
to exclude the mXSS string from the model as it looks like
legitimate content. mXSS attacks are likely to bypass all
three of those defensive techniques given that the browser
itself is instrumented to create the attack payload from orig-
inally benign-looking markup.
Mutation-based Attacks. Weinberger et al. [30] give an
example where innerHTML is used to execute a DOM-based
XSS; this is a di(cid:11)erent kind of attack than those described
in this paper, because no mutations are imposed on the
content, and the content did not pass the server-side (cid:12)lter.
Comparable XSS attacks based on changes to the HTML
markup have been initially described for client-side XSS (cid:12)l-
ters. Vela Nava et al. [24] and Bates et al. [4] have shown
that the IE8 XSS Filter could once be used to "weaponize"
harmless strings and turn them into valid XSS attack vectors
by applying a mutation carried out by the regular expres-
sions used by the XSS Filter, thus circumventing server-
side protection. Zalewski covers concatenation problems
based on NUL strings in innerHTML assignments in the
Browser Security Handbook [33] and later dedicates a section
to backtick mutation in his book \The Tangled Web" [34].
Other mutation-based attacks have been reported by Barth
et al. [1] and Heiderich [13]. Here, mutation may occur after
client-side (cid:12)ltering (WebKit corrected a self-closing script
tag before rendering, thus activating the XSS vector) or
during XSS (cid:12)ltering (XSS Auditor strips the code attribute
value from an applet tag, thus activating a second malicious
code source). Hooimeijer et al. describe dangers associated
with sanitization of content [15] and claim that they were
able, for each of a large number of XSS vectors, to produce
a string that would result in that valid XSS vector after san-
itization. The vulnerabilities described by Kolbitsch et al.
may form the basis for an extremely targeted attack by web
malware [19]. Those authors state that attack vectors may
be prepared for taking into account the mutation behavior of
di(cid:11)erent browser engines. Further, our work can be seen as
another justi(cid:12)cation of the statement from Louw et al. [22]:
"The main obstacle a web application must overcome when
implementing XSS defenses is the divide between its un-
derstanding of the web content represented by an HTML
sequence and the understanding web browsers will have of
the same".
We show that there is yet another data processing layer
in the browser, which managed to remain unknown to the
web application up till now. Note that our tests showed
that Blueprint would have to be modi(cid:12)ed to be able to
handle prevention of mXSS attacks. The current status of
standardization can be retrieved from [20]. Aside from the
aforementioned \print preview problem" referenced in Sec-
tion 2.2, another early report on XSS vulnerabilities con-
nected to innerHTML was (cid:12)led in 2010 for WebKit browsers
by Vela Nava [28]. Further contributions to this problem
scope have been submitted by Silin, Hasegawa and oth-
ers, being subsequently documented on the HTML5 Security
Cheatsheet [12].
8. CONCLUSION
The paper describes a novel attack technique based on
a problematic and mostly undocumented browser behavior
that has been in existence for more than ten years { initially
introduced with Internet Explorer 4 and adopted by other
browser vendors afterwards. It identi(cid:12)es the attacks enabled
by this behavior and delivers an easily implementable solu-
tion and protection for web application developers and site-
owners. The discussed browser behavior results in a widely
usable technique for conducting XSS attacks against appli-
cations otherwise immune to HTML and JavaScript injec-
tions. These internal browser features transparently convert
benign markup, so that it becomes an XSS attack vector
once certain DOM properties { such as innerHTML and out-
erHTML { are being accessed or other DOM operations are
being performed. As we label this kind of attack Mutation-
based XSS (mXSS), we dedicate this paper to thoroughly
introducing and discussing this very attack. Subsequently,
we analyze the attack surface and propose an action plan for
mitigating the dangers via several measurements and strate-
gies for web applications, browsers and users. We also sup-
ply research-derived evaluations of the feasibility and prac-
ticability of the proposed mitigation techniques.
The insight gained from this publication indicates the
prevalence of risks and threats caused by the multilayer ap-
proach that the web is being designed with. Defensive tools
and libraries must gain awareness of the additional process-
ing layers that browsers possess. While server- as well as
client-side XSS (cid:12)lters have become highly skilled protection
tools to cover and mitigate various attack scenarios, mXSS
attacks pose a problem that has yet to be overcome by the
majority of the existing implementations. A string mutation
occurring during the communication between the single lay-
ers of the communication stack from browser to web appli-
cation and back is highly problematic. Given its place and
time of occurrence, it cannot be predicted without detailed
case analysis.
9. REFERENCES
[1] A. Barth. Bug 29278: XSSAuditor bypasses from
sla.ckers.org.
https://bugs.webkit.org/show_bug.cgi?id=29278.
[2] A. Barth, J. Caballero, and D. Song. Secure content
sni(cid:14)ng for web browsers, or how to stop papers from
reviewing themselves. In Security and Privacy, 2009
30th IEEE Symposium on, pages 360{371. IEEE, 2009.
[3] A. Barua, H. Shahriar, and M. Zulkernine. Server side
detection of content sni(cid:14)ng attacks. In Software
Reliability Engineering (ISSRE), 2011 IEEE 22nd
International Symposium on, pages 20{29. IEEE, 2011.
[4] D. Bates, A. Barth, and C. Jackson. Regular
expressions considered harmful in client-side XSS
(cid:12)lters. In Proceedings of the 19th international
conference on World wide web, WWW ’10, pages
91{100, 2010.
[5] P. Bisht and V. N. Venkatakrishnan. XSS-GUARD:
Precise Dynamic Prevention of Cross-Site Scripting
Attacks. In Conference on Detection of Intrusions and
Malware & Vulnerability Assessment, 2008.
[6] CERT.org. CERT Advisory CA-2000-02 Malicious
HTML Tags Embedded in Client Web Requests.
http://www.cert.org/advisories/CA-2000-02.html,
2012.
[7] T. j. Foundation. jQuery: The Write Less, Do More,
JavaScript Library. http://jquery.com/, Nov. 2012.
[8] M. Gebre, K. Lhee, and M. Hong. A robust defense
against content-sni(cid:14)ng xss attacks. In Digital
Content, Multimedia Technology and its Applications
(IDC), 2010 6th International Conference on, pages
315{320. IEEE, 2010.
[9] B. Gourdin, C. Soman, H. Bojinov, and E. Bursztein.
Toward secure embedded web interfaces. In
Proceedings of the Usenix Security Symposium, 2011.
[10] M. V. Gundy and H. Chen. Noncespaces: Using
randomization to defeat Cross-Site Scripting attacks.
Computers & Security, 31(4):612{628, 2012.
[11] Y. Hasegawa, Mar. 2007.
[12] M. Heiderich. HTML5 Security Cheatsheet.
http://html5sec.org/.
[13] M. Heiderich. Towards Elimination of XSS Attacks
with a Trusted and Capability Controlled DOM. PhD
thesis, Ruhr-University Bochum, 2012.
[14] M. Heiderich, M. Niemietz, F. Schuster, T. Holz, and
J. Schwenk. Scriptless attacks{stealing the pie without
touching the sill. In ACM Conference on Computer
and Communications Security (CCS), 2012.
[15] P. Hooimeijer, B. Livshits, D. Molnar, P. Saxena, and
M. Veanes. Fast and precise sanitizer analysis with
bek. In Proceedings of the 20th USENIX conference on
Security, SEC’11, pages 1{1, Berkeley, CA, USA,
2011. USENIX Association.
[16] M. Johns. Code Injection Vulnerabilities in Web
Applications - Exempli(cid:12)ed at Cross-site Scripting.
PhD thesis, University of Passau, Passau, July 2009.
[17] S. Kamkar. Technical explanation of The MySpace
Worm.
[18] A. Klein. DOM Based Cross Site Scripting or XSS of
the Third Kind. Web Application Security
Consortium, 2005.
[19] C. Kolbitsch, B. Livshits, B. Zorn, and C. Seifert.
Rozzle: De-Cloaking Internet Malware. In Proc. IEEE
Symposium on Security & Privacy, 2012.
[20] T. Leithead. Dom parsing and serialization (w3c
editor’s draft 07 november 2012). http://dvcs.w3.
org/hg/innerhtml/raw-file/tip/index.html.
[21] M. T. Louw and V. N. Venkatakrishnan. Blueprint:
Robust Prevention of Cross-site Scripting Attacks for
Existing Browsers. In Proceedings of the 2009 30th
IEEE Symposium on Security and Privacy, SP ’09,
pages 331{346, Washington, DC, USA, 2009. IEEE
Computer Society.
[22] M. T. Louw and V. N. Venkatakrishnan. Blueprint:
Robust Prevention of Cross-site Scripting Attacks for
Existing Browsers. Proc. IEEE Symposium on
Security & Privacy, 2009.
[23] Y. Nadji, P. Saxena, and D. Song. Document
Structure Integrity: A Robust Basis for Cross-site
Scripting Defense. In NDSS. The Internet Society,
2009.
[24] E. V. Nava and D. Lindsay. Abusing Internet Explorer
8’s XSS Filters. http:
//p42.us/ie8xss/Abusing_IE8s_XSS_Filters.pdf.
[25] D. Ross. IE8 XSS Filter design philosophy in-depth.
http://blogs.msdn.com/b/dross/archive/2008/07/
03/ie8-xss-filter-design-philosophy-in-depth.
aspx, Apr. 2008.
[26] P. Saxena, D. Molnar, and B. Livshits.
SCRIPTGARD: Automatic context-sensitive
sanitization for large-scale legacy web applications. In
Proceedings of the 18th ACM conference on Computer
and communications security, pages 601{614. ACM,
2011.
[27] B. van der Sluis. swfobject - SWFObject is an
easy-to-use and standards-friendly method to embed
Flash content, which utilizes one small JavaScript (cid:12)le.
http://code.google.com/p/swfobject/.
[28] E. Vela. Issue 43902: innerHTML decompilation issues
in textarea. http://code.google.com/p/chromium/
issues/detail?id=43902.
[29] W3C. Navigation Timing. http://www.w3.org/TR/
2012/PR-navigation-timing-20120726/, July 2012.
[30] J. Weinberger, P. Saxena, D. Akhawe, M. Finifter,
E. C. R. Shin, and D. Song. A systematic analysis of
xss sanitization in web application frameworks. In
ESORICS, 2011.
[31] E. Z. Yang. HTML Puri(cid:12)er CSS quoting full
disclosure. http://htmlpurifier.org/, Sept. 2010.
[32] E. Z. Yang. HTML Puri(cid:12)er.
http://htmlpurifier.org/, Mar. 2011.
[33] M. Zalewski. Browser Security Handbook.
http://code.google.com/p/browsersec/wiki/Main,
July 2010.
[34] M. Zalewski. The Tangled Web: A Guide to Securing
Modern Web Applications. No Starch Press, 2011.
[35] G. Zuchlinski. The Anatomy of Cross Site Scripting.
Hitchhiker’s World, 8, Nov. 2003.