<>
需要注意的是这个模式匹配到的不只是标签。更糟糕的是，它无法正确匹配到在目标
>
1)">之中的整个标签。相反地，它只会匹配到属性值中出现的第一个>。在处理注释、
XMLCDATA片段、DOCTYPE、在元素中的代码以及任何其他包含内嵌的>符
号的内容的时候，都会遇到类似的问题。
如果你要处理的不只是最基本的标记，特别是如果目标文本来自混合的或者未知的来
源，那么你可能就需要使用本实例中后面给出的一种更加健壮的解决方案。
在属性值中允许出现>
与上面刚刚讲解过的速成方案的正则式一样，接下来的这一个正则表达式被引入的目
的也主要是为了同后面更加健壮的解决方案作比较。然而，它还是覆盖了用来匹配
XML风格标签的基本需求，因此如果你只是用它来处理其中仅包含有元素和文本的合
法标记的代码片段，那么它也可以正常工作。与上一个正则式的区别是它会忽略出现
在属性值中的>字符。例如，它能够正确匹配在我们前面提到过的目标字符串标签。
与前面一样，这个正则式在两头使用了字面的尖括号字符来匹配一个标签的开始和结
束。在二者之间，它会重复一个非捕获分组，其中包含了3个选择分支，彼此之间通
过多选结构元字符进行分隔。
其中第一个选择分支是否定型字符类{>">，它会匹配除了右尖括号（用来结束标
签）、双引号或单引号（两个引号都可以用作属性值的开始）之外的任意单个字符。这
第一个选择分支负责匹配标签和属性名称，以及在被引起来的值以外的任意其他字符。
404第8章
www.TopSage.com
---
## Page 421
这些选择分支之间的顺序是有意安排的，在设计时考虑了执行的效率。正则表达式引
擎会从左向右尝试一个正则表达式中的不同选择分支路径，而匹配这第一个选项的尝
试很可能总是会比用来匹配引起来的值的选择分支的成功可能性要大很多（特别是考
虑到它一次只会匹配一个字符）。
使用了否定字符类，从而在匹配的时候可以跨过其中包含的>字符、换行符和非结束
引号的其他任何内容。
需要注意的是，这个解决方案并没有做任何特殊的处理来排除或者正确匹配注释，以
及在你的文档中的其他特殊节点。所以在真的使用这个正则表达式之前，一定要确保
你很熟悉要处理的内容种类。
一种（安全的）效率优化方法
在阅读本节之后，你可能会认为如果在前面的否定字符类（[>"）之后添加一个量
词（*）或（十》，就能够提高这个正则表达式的性能。如果正则式会在目标字符串内部
的位置找到匹配，那么你这样想是正确的。通过每次匹配多于一个字符，你就能够使
正则引擎在到达成功匹配的途中省略掉许多不必要的步骤。
然而在正则引擎只能找到部分匹配的时候，这样的改动还可能会带来一个可能看起来
不是那么明显的消极后果。当正则式匹配到一个起始的
正则选项：无
正则流派：.NET、Java、PCRE、Perl、Ruby
采用占有量词的形式：
正则选项：无
正则流派：Java、PCRE、Per15.10、Ruby1.9
标记语言和数据交换
405
www.TopSage.com
---
## Page 422
（X)HTML标签（灵活方案）
这个正则式中只添加了很简单的功能，就可以做到非常接近当前浏览器在源代码中识
别(X)HTML标签时所采用的灵活规则。当你试图要模仿浏览器的行为，而不需要考虑
你所匹配到的内容实际上是否遵守了合法标记的所有规则时，这个正则式会是一个较
好的解决方案。要记住的是，在处理某些非常奇怪的非法HTML的时候，这个正则式
可能无法做到同某些浏览器处理得一样好，因为浏览器通常会采用自已的独特方式来
分析错误标记中的边界情形。
与前一个解决方案相比，这个正则式中最重要的区别是它要求在起始的左尖括号（元素的内容等之内看起来貌似
中（X
决这个问题的办法。但是我们首先还是来看一下这个正则式的工作原理。
（会允许出现一个用于结束标签
的可选正斜杠。接下来是一个捕获分组/]*），它会匹配标签的名称，并
把它保存到第1个向后引用中。如集你不需要在之后引用标签的名称（例如，你只是
想删除所有标签），那么可以去掉用来捕获的两个括号（但是要保留两个括号之间的模
式）。在分组中有两个字符类。第一个学符类[A-Za-z]设定的是标签名称的首字母规
则。接下来的字符类[^s>]>允许接着出现几乎任何字符来作为名称的一部分。唯一
的例外是空白字符（即心s>，用来把标签名称和随后的任意属性分隔开来）、>（用作标
签的结束）和/（出现在结束的>之前，用于说明XHTML风格的单体标签）。任何其
他字符（甚至包括引号）都可以被当作标签名称的一部分。看起来似乎有些太过宽松，
但是这正是大多数浏览器所采用的方式。对于那些似是而非的标签，它们可能根本不
会影响到网页上显示的任何效果，但是依然可以通过DOM树来进行访问，而且即使包
含在标签之内的内容会被显示，这些标签也不会被当作文本来显示。
在标签名称之后是属性的处理，这部分内容是从上一个正则式中直接拿来的：
"]"[^]*"[^*)*>。最后添加了一个右尖括号来结束这个标签，我们的任务就完
成了。
下面的正则式会展示如何对这个模式进行修改成只匹配起始、结束或单体（自结束的）
标签：
起始标签
/]*）（?：[>"/]1"["]*"|*[]*）*>
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
406第8章
www.TopSage.com
---
## Page 423
这个版本中，在非捕获分组中的第一个否定字符类之后添加了正斜杠（/)，从而可以避
免在除了被引起来的属性值外的任何其他地方出现正斜杠。
单体标签
/]*)(?:[>"+]1"{"]*"丨*[+]**)*/>
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
在这里，我们在结束的右尖括号之前添加了一个必需的正斜杠。
起始标签和单体标签
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
这里没有添加任何内容。我们删除了在原来的正则式中的起始（。
结束标签
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
在起始左尖括号之后的正斜杠在这里成为了匹配中必需的一部分。注意，我们有意在
结束标签内充许出现属性，因为这里所依据的是“灵活的”解决方案。虽然浏览器不
会使用出现在结束标签的中属性，它们也并不介意你在其中使用这样的属性。
有量词来提高匹配标签的性能。这次潜在的性能提高可能会更显著，因为字符类
s>小能匹配到的字符会与正则式稍后部分中的字符出现重叠，因此在正则引擎放弃
某个部分匹配尝试之前，需要尝试更多可能的组合情形。
如果在你所使用的正则流派中支持原子分组或占有量词，那么利用它们可能会得到相
当的性能优化。下面的改动也可以被应用到刚刚所给的“起始/结束/单体”特定的正则
式之上：
[^\s>/]*))(?>(?:(?>[^>"]+) 1"[^
正则选项：无
正则流派：.NET、Java、PCRE、Perl、Ruby
+[x]，1+[nx}1++[.
正则选项：无
正则流派：Java、PCRE、Perl5.10、Ruby1.9
（X)HTMLtagS（严格方案）
之所以说这个解决方案是严格的，是因为它会尝试按照在本章最开始部分所讲解的
HTML和XHTML语法规则来进行匹配，而不是模仿在实际中浏览器分析某个文档源
标记语言和数据交换407
www.TopSage.com
---
## Page 424
代码时所采用的规则。与前面的正则式相比，这个严格方案中添加了如下的规则。
·标签和属性名称都必须以A～Z或a～z之中的一个学母开头，而它们的名称则只
能使用字符A～Z、a～Z、0～9、连字号和冒号（如果用正则式来表示，也就是
)。
在标签名称之后不允许出现不合适的、零星的字符。在标签名称之后只能使用空
格、属性（无论带不带相应的值）以及一个可选的正斜杠。
没有引起来的属性值中只能使用字符A～Z、a～Z、0~9、下划线、连字符、句号
和曾号（以正则式来表示，也就是个[-:A-Za-z0-9]+S>）。
·
结束标签中不能包含属性。
因为这个模式被划分为了2个分支（第一个分支是起始和单体标签，第二个分支是结
束标签），根据你所匹配到的标签类型的不同，标签名称会被捕获到第1个或第2个向
后引用中。如果你在之后不会再用到标签名称，也可以去掉这两组捕获括号。
起始和单体标签
）之前的/?>会充许这个正则式匹配起始和单体标签。把它删掉
的话就只能用于匹配起始标签。只删除问号量词（把/变为必需的），它就只能匹配单
体标签。
结束标签
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
在前面两个小节中，我们讲解了如何通过添加原子分组或者占有量词来获得潜在的性
能提高。使用这个正则式来严格定义的路径意味着我们无法用多于一种方式来匹配相
同的字符串，因此也就不必担心可能出现的回溯。这个正则式并不依赖回溯，因此，
如果愿意，你也可以把位于最后的每一个量词*)、（+）或（？）变成占有量词（或者使
用原子分组来达到相同的效果）。虽然这样做可能会有帮助，但是为了控制本实例的篇
福，我们对于该正则式这些可能的变形略去不谈。
想知道如何可以避免匹配到在注释、标签和其他内容之内的标签，请参考后面的“跳
过复杂的（X)HTML和XML片段”小节。
XML标签（严格方案）
XML采用了严格的规范，并且要求支持它的分析器不要处理格式不正确的标记，因此
408第8章
www.TopSage.com
---
## Page 425
我们不需要再给XML也来一个“灵活方案”。虽然你也可能会使用前面所给的一个正
则式处理XML文档，但是它们的简单性无法让你得到执行更可靠查找的好处，因为
我们并不需要去模拟任何的XML用户代理行为。
这个正则式本质上是前面所给的“(X）HTML标签（严格方案）”正则表达式的简化
版本，因为我们从中删除了在XML中不支持的两个HTML特性：没有引起来的属
性值和最小化的属性（也就是不带对应值的属性）。其他唯一的区别是在标签和属性
名称中充许出现的字符。事实上，XML名称规则（用来规定对标签和属性名称的要
求）比我们这里所给的要更为宽松，它会允许成千上万个其他Unicode字符。如巢
需要在查找中支持这些字符，那么你可以把其中3处出现：A-Z]{-.：w]*的地方
替换为在实例8.4中讲解的一种模式。注意XML支持的字符与你所使用的XML版
本是有关系的。
与(X)HTML正则表达式一样，根据你匹配到的是起始/单体标签还是结束标签，标签名
称会被捕获到第1个或第2个向后引用中。当然，如果你不需要在后面使用这些名称，
那么也可以去掉用来捕获的括号。
在下面的例子中，上述模式的2个分支会被分别放到它们自已的正则式中。这样做的
结果是，两个正则式都会把标签名称捕获到第1个向后引用中：
起始和单体标签
）之前的/?>会允许这个正则式匹配起始和单体标签。把它删掉
的话就只能用于匹配起始标签。只删除问号量词（把/变为必需的），它就只能匹配
单体标签。
结束标签
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
想知道如何避免匹配到在注释、CDATA片段和DOCTYPE之内的标签，请参考随后的
“跳过复杂的（X）HTML和XML片段”小节。
跳过复杂的（X)HTML和XML片段
当你尝试要在一个源文件或字符串中匹配XML风格的标签时，很多精力会花费到如
何避免匹配到貌似标签的内容上，这些看起来像是标签的内容由于其所在位置或者
其他上下文，使之不能被解释为标签。在本实例中我们所给的(X)HTML和XML风
格的正则表达式中都会通过限制元素名称的首字母来避免一些有问题的内容。有时
标记语言和数据交换409
www.TopSage.com