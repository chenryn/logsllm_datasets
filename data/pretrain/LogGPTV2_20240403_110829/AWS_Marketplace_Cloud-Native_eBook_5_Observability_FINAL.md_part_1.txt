EBOOK
Cloud-native Observability:
Actionable intelligence
for complex systems
How to architect observability for modern
applications and infrastructure using metrics,
events, logs, and traces (MELT) data.
1
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
CLOUD - NATIVE OBSERVABILITY:
ACTIONABLE INTELLIGENCE FOR COMPLEX SYSTEMS
Table of contents
End-to-end monitoring and insights power reliability and innovation…..…………..… 3
Observability for cloud-native development ……………..…………………..……...….… 7
More about MELT …………………………………………..……………………………….… 9
Why Observability? ……….………………………………………..…………………..……. 10
Who needs Observability? …………………..…………………………..…………….……. 13
Where to start?……………………………………………..........……………………...……. 14
Data sources …………….………………………………….…….………..…………………. 15
What is OpenTelemetry? .…………….………………………..….………….………..…… 16
The four golden signals ……...…………...………..………………………………….….… 19
Dashboards and visualizations .………………..……………………………………..….… 21
Key takeaways for Observability …………………..…………………........……………..... 25
Tools for building cloud-native ……………...………………………........…………...…... 26
Recap: Observability architecture ……………..…….………………………...……..….… 38
Conclusion………………………….………………..……………….……………………..… 40
2
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
End-to-end monitoring and insights
power reliability and innovation
Implementing microservices and cloud-native architectures has been a goal for many
organizations who hope to increase speed and agility. But gaining these capabilities introduces
additional complexity, as cloud-native applications are decoupled and distributed. Systems become
increasingly challenging to observe, and when issues occur it’s often difficult to identify their root
cause. DevOps teams can also find it difficult to monitor components outside of their control.
In this ebook, we’ll offer guidance for architecting end-to-end Observability for cloud-native
applications and infrastructure using telemetry data. You’ll take away practical methods for
establishing baselines and uncovering the why versus the what when things go wrong.
3
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
Modernization is a business priority today
To delight customers and win new business, organizations need to build reliable,
scalable, and secure applications. That means adopting new technologies, practices,
and consuming services as APIs.
As an application development professional, your goal is to deliver business value fast.
Modern applications help achieve this goal by separating and decoupling the monolith
into smaller functional services—or microservices—that focus on one thing and do it
well. Each microservice often has its own data store and can be deployed and scaled
independently. They represent the real world, where service boundaries equal
business boundaries.
This has forced organizations to evolve by giving engineering teams the autonomy
to architect, develop, deploy, and maintain each microservice. With this approach,
you end up with the ability to make decisions very quickly because your decisions
only impact individual services. After all, innovation requires change. You can
learn faster by making lots of little changes to drive incremental innovation,
rather than waiting to take one giant leap.
4
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
Increasing the speed of innovation
Modern applications were born out of a necessity to deliver smaller features faster to customers.
While this directly addresses only the application architecture aspect, it requires other teams to build
and execute in a similar manner to be successful. In order to continuously deliver features, there is a
need for all cross-functional teams to operate as a single team—a strategy referred to as One Team.
Each type of change will need its own fully automated delivery pipeline—for example, application,
infrastructure, configurations, feature flags and OS patching will either need their own pipeline or
need to be part of the Continuous Delivery (CD) pipeline. And capabilities like test automation and
security testing need to be integrated into the pipeline so there is a high degree of confidence
for changes that flow through the pipeline are ready to be deployed into production.
Key aspects of
modern applications:
• Use independently
scalable microservices such
as serverless and containers
• Connect through APIs
• Deliver updates continuously
• Adapt quickly to change
• Scale globally
• Are fault tolerant
• Carefully manage
state and persistence
• Have security built in
55
©© 22002233,, AAmmaazzoonn WWeebb SSeerrvviicceess,, IInncc.. oorr iittss aaffffiilliiaatteess.. AAllll rriigghhttss rreesseerrvveedd..
What is cloud-native? Why does it matter?
Cloud-native is an evolving term. The vast amount of software that’s being
built today needs a place to run and all the components and processes required
to build an application need to fit together and work cohesively as a system.
The Cloud Native Computing Foundation (CNCF) definition states:
Cloud-native technologies empower organizations to
build and run scalable applications in modern, dynamic
environments such as public, private, and hybrid clouds.
This definition has to broadly apply to everyone, but not everyone has the
same capabilities. This is known as the lowest common denominator problem.
It is where you try and appeal to a broader group and their capabilities, but in
doing so you also need to limit the capabilities that can be leveraged.
Amazon Web Services (AWS) goes many steps further
by providing a broad set of capabilities that belong to
a family called serverless. Serverless technologies are
more than just AWS Lambda—these services remove
the heavy lifting associated with running, managing,
and maintaining servers. This lets you focus on core
business logic and quickly adding value.
6
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
Observability for
cloud-native development
As we cover the different capabilities your organization needs to acquire to go fully
cloud-native, it’s useful to view each one as a step in a journey.
The map below is a model for how organizations typically evolve their cloud-native
understanding. As your organization or team moves from stage to stage, you are gaining
capabilities that make releasing new features and functionality faster, better, and cheaper.
In the following sections, we’ll be focusing on the capability of Observability.
4.
Observability
77
©© 22002233,, AAmmaazzoonn WWeebb SSeerrvviicceess,, IInncc.. oorr iittss aaffffiilliiaatteess.. AAllll rriigghhttss rreesseerrvveedd..
But first: What is Observability?
The concept and terminology of Observability has only recently been applied
to information technology (IT) and cloud computing. The term originated in the
discipline of control systems engineering, where Observability was defined as a
measurement of how well a system’s internal states could be inferred from its
external outputs. A system is observable if its current state can be determined
in a finite time period using only the outputs of the system. For such a system,
all of its behaviors and activities can be evaluated based on its outputs.
However, the term has increasingly been applied to improving the performance
of distributed IT systems. In this context, Observability uses four types of
telemetry data: Metrics, events, logs, and traces (MELT).
METRICS EVENTS LOGS TRACES
Analyzing MELT data provides deep visibility into distributed systems and allows
teams to get to the root cause of issues and improve their system’s performance.
When you instrument each component of your system to collect MELT data, you
can form a fundamental working knowledge of connections—the relationships
and dependencies within your system—as well as the system’s detailed
performance and health. This is what it means to practice Observability.
8
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
More about MELT
Let’s look at the individual types of data that make up MELT.
METRICS Metrics are numeric measurements. They can include:
• A numeric status at a moment in time, such as CPU percent used
• Aggregated measurements, such as a count of events over a one-minute timeframe,
or a rate of events-per-minute
• The types of metric aggregation are diverse—for example, average, total, minimum,
maximum, sum-of-squares—but all metrics generally share the following traits:
• They have a name • They have a timestamp • They have ≥1 numeric values
EVENTS Events can be user actions—such as clicking a mouse button or pressing a key—or system
events such as new user created. In other words, a discrete action happening at a moment
in time. AWS provides two event-focused services:
1. Amazon CloudWatch Events delivers a near real-time stream of system events that
describe operational changes in AWS resources.
2. Amazon EventBridge is a serverless event bus that ingests data from your own apps,
SaaS apps, and AWS services and routes that data to targets. For example, when an
Amazon Elastic Container Service (Amazon ECS) task changes from running to stopped,
you can have a rule that sends the event to an AWS Lambda function.
LOGS Logs are the original data type. In their most fundamental form, logs are essentially lines
of text a system or application produced when certain code blocks were executed.
Developers rely heavily on logs to troubleshoot their code and to retroactively verify and
interrogate the code’s execution. In fact, logs are incredibly valuable for troubleshooting
databases, caches, load balancers, or older proprietary systems that aren’t friendly to
in-process instrumentation.
TRACES Traces—more precisely called distributed traces—are samples of causal chains of events or
transactions between different components in a microservices ecosystem. And like events
and logs, traces are discrete and irregular in occurrence.
In distributed systems, traces are stitched together to form special events called spans.
Spans help you track a causal chain through a microservices ecosystem for a single
transaction. To accomplish this, each service passes correlation identifiers known as
trace context to each other—this trace context is used to add attributes to the span.
9
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
What should
you be observing? Why Observability?
Now that we’ve learned about MELT, let’s talk Now that we have explored the what, it’s time
about what you should be observing. There are to move into the why. Systems no longer consist
obvious choices such as data and metrics from of a single server in a single environment. With
traditional monitoring—infrastructure metrics cloud-native, systems are composed of multiple
like CPU, memory, and disk usage. But you applications and services running together to
should expand this practice to areas that can solve business problems. And the evolution of
provide context on user experience and insights applications have made them highly distributed,
that help you streamline troubleshooting. If a which addresses scalability and resiliency, but
system errors, you should collect all associated comes at the cost of added complexity.
data, such as runtime variable values, stack
Observability becomes incredibly important
traces, and any other information that will
in distributed systems because you need
help you identify the root cause faster.
information from several different applications
Besides standard compute information, to gain a complete picture.
also bring in telemetry from edge cases
such as API gateways, border routers, caches,
and third-party services for authentication,
payments, and location. Cloud-native systems
are highly distributed, so you’re going to need
data from any and all components that are
part of the user experience.
Imagine that this image is a service,
and all the different dots are components
that make up the service. If a user reports
an issue, how would you pinpoint in this
diagram where the issue occurred?
10
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
Anti-patterns: Where poor
Environment inconsistency
Observability hurts you
Development, test, stage, and production
environments need to be consistent in
There can be too much of a good terms of the resources and the processes
used to observe those environments.
thing—and in this case, that is the
misuse of Observability.
Unnecessary alerts
The diagram below illustrates some anti-
patterns of Observability. Each anti-pattern If engineers receive too many unactionable
represents a common way that development alerts, they may eventually suffer from alert
teams undermine themselves with weak fatigue and may simply ignore all alerts,
capabilities for Observability. For example: even those they should be looking into.
1111
©© 22002233,, AAmmaazzoonn WWeebb SSeerrvviicceess,, IInncc.. oorr iittss aaffffiilliiaatteess.. AAllll rriigghhttss rreesseerrvveedd..
Issues that result from poor Observability
Time between failures
Time to repair Time to failure
¬
! !
System failure Resume normal operations System failure
Slower mean time to resolution (MTTR)
Not having good Observability capabilities can be disadvantageous in two important ways:
1. With business services composed of several 2. MTTR will suffer as you find yourself
microservices, not having full visibility into your digging through logs and calling on
own system and how it interacts with upstream and engineers from other teams to help
downstream systems can leave you with blind spots. identify the cause of failure.
Poorly performing systems that you can’t see
Without Observability, you have very little visibility into how systems are actually performing. You may
have monitoring data that shows CPU and memory utilization, but do you have accurate information
regarding calls that are blocking or where your biggest source of wait time for a method call is?
Without a platform to raise this type of system visibility, you may not know where to invest your
engineering efforts to give you the biggest return on your time spent. Observability can go even further
and provide visibility into the features and functionalities that end users are utilizing. This will help
eliminate some technical debt by focusing attention on code areas that are heavily used by customers
and removing code with no usage.
Higher costs
Poor Observability ends up costing you more in resources. Companies often over-provision resources
preparing for peak traffic that may never arrive or is inconsistent. Good Observability helps with cost
savings by letting you scale up or down based on traffic patterns.
12
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
Who needs Observability?
We just covered challenges related to poor Observability into
systems. Now let’s cover who needs Observability. The short
answer is everyone. But, practically, the personas presented
here are the ones that will see an immediate benefit.
QA/Test Engineer Security Engineer
• Wants to know how tests impact the system • Wants to know if systems are secure
• Wants contextual data about bugs • Wants to know what software has
• Wants to know about test coverage been deployed and where
• Wants to understand how the new features are functioning • Wants to know patch versions
• Wants visibility into the overall health of the system as • Wants to ensure compliance with
tests execute various areas of the codebase corporate standards and best practices
• Wants to make sure no new
vulnerabilities are being introduced with
Operations Engineer
applications as they are being developed
• Wants real-time analysis of security
• Wants to know if systems are meeting customers’ demands
alerts generated by applications and
• Wants to reduce signal-to-noise ratio in alerts network hardware
• Wants to correlate data across distributed systems and get
to the root cause faster
• Wants to know if systems are configured with best practices Leadership
• Wants to know if all systems are patched
• Wants visibility into thresholds and patterns; what is normal • Wants visibility into business KPIs
versus an anomaly • Wants to know about issues and risks
• Wants assurances that systems are
performant and cost-optimized
Developer
• Wants visualizations and reports
that reduce signal to noise ratio
• Wants to know how software can be optimized
• Wants to understand the performance impact of changes
• Wants the ability to troubleshoot issues
• Wants to know how the pipeline and systems are performing
• Wants to be able to trace transactions through the entire system
• Wants contextual information when failures occur
13
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
Where to start?
From a high level, we now know what Observability
is, and we also know why we need Observability.
Now let’s talk about how to start building your
Observability capabilities.
14
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
Data sources
To make your journey more manageable, start with an application or service you want to observe.
Armed with different personas and their needs, work backwards from there and determine what data
sources will get you the information you need. In this diagram are just a few examples of common data
sources to think about. After you compile a list of the data sources, you’ll be in a better position to
determine which Observability platform will best serve your needs.
End user Amazon
Network LOB app On-premises
telemetry CloudWatch
Observability
platform
AWS Third-party AWS
Hybrid cloud AWS Config
environments SaaS CloudTrail
Unified logging and standardization
Once you have a good understanding of your data sources, you’ll want to think about how to get that
data into a common format that can be shared across different systems. It’s not uncommon that systems
don’t standardize on how logs are written or what metrics are collected and how they are aggregated.
This makes it impossible to trace transactions across services and difficult to compile analytic and
forensic information. Because of this, it’s important to standardize on the way MELT data is created,
published, and shared.
PROBLEM: Log data in various formats SOLUTION: Standardize the log data model
• Annotate log records with distributed tracing states
• Cross-service tracing impossible
• Adopt OpenTracing (http://opentracing.io/)
• Complexity for monitoring,
forensics, analytics • Provide SDK that supports major languages
• Integrate with vendor application performance
monitoring (APM) products
15
© 2023, Amazon Web Services, Inc. or its affiliates. All rights reserved.
What is OpenTelemetry?
OpenTelemetry is a CNCF incubating project, formed through a merger of the OpenTracing and
OpenCensus projects. To help standardize Observability, the OpenTelemetry project provides a
set of APIs, SDKs, and agents to enable developers to instrument their application once and send
correlated traces and metrics to a destination of their choice. It supports SDKs in 11 languages and
auto-instrumentation agents in Java. JavaScript, Python, .NET, and more are actively being developed.
• An Observability framework
for cloud-native software
• You use it to instrument, generate, collect, and
export telemetry data (metrics, logs, and traces)
for analysis in order to understand your software's
performance and behavior
• Supports 11 languages and growing
AWS Distro for OpenTelemetry (ADOT)