这个例子很好地说明了，为什么通常情况下，忽略优先量词并不是排除类的完美替身。在
“.*"的例子中，使用[~"]替换点号能避免跨越引号的匹配一一这正是我们希望实现的
功能。
如果支持排除环视（133），我们就能得到与排除型字符组相当的结果。比如，（?1）
这个测试，只有当不在字符串中的当前位置时才能成功。这也是.*？中的点号
期望匹配的内容，所以把点号改为（（?！B>）.）得到的正则表达式，就能准确匹配我们期
望的内容。把这些综合起来，结果有点儿难看懂，所以我选用带注释的宽松排列模式（111）
来讲解：
#匹配开头的
(
#然后只匹配尽可能少的内容
(?!)
#如果不是..
#·.：任何宇持都可以
)*?
#
#：.：直到遇到结束标记
使用了环视功能之后，我们可以重新使用普通的匹配优先量词，这样看起来更清楚：
#匹配开头的
(
#然后匹配尽可能多的内容
(？!)
#如果不是，也不是.
#..任何字符都可以
)*
#（现在是匹配优先的量词）
#..．直到结束分隔符匹配
现在，环视功能会禁止正则表达式的主体（mainbody）匹配和之外的内容，这也
是我们之前试图用忽略优先量词解决的问题，所以现在可以不用忽略优先功能了。这个表
达式还有能够改进的地方，我们将在第6章关于效率的讨论中看到它（270）。
匹配优先和忽略优先都期望获得匹配
Greedinessnnd LazinessAluaysFacoraMatch
回忆一下第2章中显示价格的例子（51）。我们会在本章的多个地方仔细检查这个例子，
//+P\([6-]P\P\）/s~=at1ds
来保存sprice小数点后头两到三位十进制数字。\.\d\d匹配最开始两位数字，而（1-9]？
用来匹配可能出现的不等于零的第三个数字。
---
## Page 194
168
第4章：表达式的匹配原理
然后我写道：
到现在，我们能够匹配的任何内容都是希望保留的，所以用括号包围起来，作为$1捕
获。然后就能在replacement字符事中使用s1。如果这个正则表达式能够匹配的文本就
等于s1，那么我们就是用一个文本取代它本身一这没有多少意义。然而，我们继续
匹配$1括号之外的部分。在替代字符事中它们并不出现，所以结果就是它们被删掉了。
在本例中，“要删掉”的文本就是任何多余的数字，也就是正则表达式中末尾的d*
匹配的部分。
到现在看起来一切正常，但是，如果sprice的数据本身规范格式，会出现什么问题呢？如
果Sprice是27.625，那么\.\d\d（1-9]？能够匹配整个小数部分。因为\d*无法匹配任
何字符，整个替换就是用‘.625’替换‘.625’一一相当于白费工夫。
结果当然是我们需要的，但是否存在更有效率的办法，只进行真正必要的替换（也就是，
一位数字”！只要把\d*替换为\d+就好了：
$price=~s/(\.\d\d[1-9]?)\d+/$1/
对于“1.62500000002828”这样复杂的数字，正则表达式仍然有效；但是对于“9.43”这种
数字，末尾的d+不能匹配，所以不会替换。所以，这是个了不起的改动，对吗？不！如
果要处理的数字是27.625，情况如何呢？我们希望这个数字能够被忽略，但是这不会发生。
请仔细想想27.625的匹配过程，尤其是表达式如何处理5’这个数字。
知道答案之后，这个问题就变得非常简单了。在（\.\d\d（1-9]？)\d+匹配27.625之后，
"d+无法匹配。但这并不会影响整个表达式的匹配，因为就正则表达式而言，由{1-9]：
匹配5’只是可选的分支之一，还有一个备用状态尚未尝试。它容许（1-9]？匹配-个空
字符，而把5留给至少必须匹配一个字符的d+。于是，我们得到的是错误的结果：.625
被替换成了.62。
如果[1-9]？：是忽略优先的又如何呢？我们会得到同样的匹配结果，但不会有“先匹配5
再回溯”的过程，因为忽略优先的[1-9]？？首先会忽略尝试匹配的选项。所以，忽略优先
量词并不能解决这个同题。
匹配优先、忽略优先和回溯的要旨
The Essence of Greediness,Laziness, aned Backtracking
之前的章节告诉我们，正则表达式中的某个元素，无论是匹配优先，还是忽略优先，都是
为全局匹配服务的，在这一点上（对前面的例子来说）它们没有区别。如果全局匹配需要，
无论是匹配优先（或是忽略优先），在遇到“本地匹配失败”时，引擎都会回归到备用状态
】
---
## Page 195
关于匹配优先和回溯的更多内容
169
（按照足迹返回找到面包屑），然后尝试尚未尝试的路径。无论匹配优先还是忽略优先，只
要引擎报告匹配失败，它就必然尝试了所有的可能。
测试路径的先后顺序，在匹配优先和忽略优先的情况下是不同的（这就是两者存在的理由），
但是，只有在测试完所有可能的路径之后，才会最终报告匹配失败。
相反，如果只有一条可能的路径，那么使用匹配优先量词和忽略优先量词的正则表达式都
能找到这个结果，只是他们尝试路径的次序不同。在这种情况下，选择匹配优先还是忽略
优先，并不会影响匹配的结果，受影响的只是引擎在达到最终匹配之前需要尝试的次数（这
是关于效率的问题，第6章将会谈到）。
最后，如果存在不正一个可能的匹配结果，那么理解匹配优先、忽略优先和回溯的读者，
就明白应该如何选择。“.*"有3个可能的匹配结果：
The nameMcDonald's" s said_"makudonarudo*in Japenese.
我们知道，使用匹配优先星号的.*"匹配最长的结果，而使用忽略优先星号的”.*？"匹
配最短的结果。
占有优先量词和固化分组
Possessiie Quantifiers and Atomic Grouping
上一页中.625”的例子展示了关于NFA匹配的重要知识，也让我们认识到，针对这个具
体的例子，考虑不仔细就会带来问题。针对某些流派提供了工具来帮助我们，但是在接触
它们以前，必须彻底弄明白“匹配优先、忽略优先和回溯的要旨”这一节。如果读者还有
不明白的地方，请务必仔细阅读上一节。
那么，仍然来考虑.625’的例子，想想我们真正的自的。我们知道，如果匹配能够进行
到（\.\d\d[1-9]？）\d+中标记的位置，我们就不希望进行回溯。也就是说，我们希望的
是，如果可能，[1-9]能够一个字符，果真如此的话，我们不希望交还这个字符。或者说
的更直白一些就是，如果需要的话，我们希望在（1-9]匹配的字符交还之前，整个表达式
就匹配失败。（这个正则表达式匹配“.625”时的问题在于，它不会匹配失败，而是进行回
溯，尝试其他备用状态）。
那么，如果我们能够避免这些备用状态呢（也就是在[1-9]进行尝试之前，放弃？保存的
状态，）？如果没有退路，【1-9]的匹配就不会交还。而这就是我们需要的！但是，如果没
有了这个备用状态会发生什么？如果我们用这个表达式来匹配‘.5000’呢？此时（1-9】
---
## Page 196
170
第4章：表达式的匹配原理
不能匹配，就确实需要回溯，放弃[1-9]，让之后的d+能够匹配需要删除的数字。
听起来，我们有两种相反的要求，但是仔细考虑考虑就会发现，我们真正需要的是，只有
能够成功匹配，就必须抛弃对应的备用状态，这样就永远也不会回退。如果正则表达式的
流派支持固化分组（?>）；（139），或者占有优先量词（1-9]？+）（142），就可以这么
做。首先来看固化分组。
用（？>）实现固化分组
具体来说，使用（?>）的匹配与正常的匹配并无差别，但是如果匹配进行到此结构之后
（也就是，进行到闭括号之后），那么此结构体中的所有备用状态都会被放弃。也就是说，
在固化分组匹配结束时，它已经匹配的文本已经固化为-一个单元，只能作为整体而保留或
放弃。括号内的子表达式中未尝试过的备用状态都不复存在了，所以回溯永远也不能选择
其中的状态（至少是，当此结构匹配完成时，“锁定（lockedin）”在其中的状态）。
所以，让我们来看（\.\d\d（?>[1-9]?））\d+)。在固化分组内，量词能够正常工作，所以
如果【1-9]不能匹配，正则表达式会返回？留下的备用状态。然后匹配脱离固化分组，
继续前进到d+。在这种情况下，当控制权离开固化分组时，没有备用状态需要放弃（因
为在固化分组中没有创建任何备用状态）。
如果（1-9]能够匹配，匹配脱离固化分组之后，？：保存的备用状态仍然存在。但是，因为
它属于已经结束的固化分组，所以会被抛弃。匹配‘.625’或者‘.625000’时就会发生
这种情况。在后一种情况下，放弃那些状态不会带来任何麻烦，因为d+：匹配的是
“.625000'，到这里正则表达式已经完成匹配。但是对于‘.625’来说，因为d+无法匹
配，正则引擎需要回溯，但回溯又无法进行，因为备用状态已经不存在了。既然没有能够
回溯的备用状态，整体匹配也就失败，.625”不需要处理，而这正是我们期望的。
固化分组的要旨
从第168页开始的“匹配优先、忽略优先和回溯的要旨”这一节，说明了一个重要的事实，
即匹配优先和忽略优先都不会影响需要检测路径的本身，而只会影响检测的顺序。如果不
能匹配，无论是按照匹配优先还是忽略优先的顺序，最终每条路径都会被测试。
---
## Page 197
关于匹配优先和回溯的更多内容
171
然而，固化分组与它们截然不同，因为固化分组会放弃某些可能的路径。根据具体情况的
不同，放弃备用状态可能会导致不同的结果：
·毫无影响如果在使用备用状态之前能够完成匹配，固化分组就不会影响匹配。我们刚
导致匹配失败放弃备用状态可能意味着，本来有可能成功的匹配现在不可能成功了。
6.25’的例子就是如此。
·
改变匹配结果在某些情况下，放弃备用状态可能得到不同的匹配结果。
·
加快报告匹配失贩的速度如果不能找到匹配对象，放弃备用状态可能能让正则引擎更
快地报告匹配失败。先做个小测验，然后我们来谈这点。
小测验：（？>.*？）是什么意思？它能匹配什么文本？请翻到下页查看答案。
某些状态可能保留在匹配过程中，引擎退出固化分组时，放弃的只是固化分组中创建的状
态。而之前创建的状态依然保留，所以，如果后来的回溯要求退回到之前的备用状态，固
化分组部分匹配的文本会全部交还。
Subject”中不含冒号，但正则引擎必须经过尝试才能得到这个结论。
第一次检查：时，\W+已经匹配到了字符单的结尾，保存了若干状态一w：匹配的每个
字符，都对应有“忽略”的备用状态（第一个除外，因为加号要求至少匹配一次）。：无法
匹配字符串的末尾，所以正则引擎会回溯到最近的备用状态：
\W+：
此处的字符是‘t'，：仍然无法匹配。于是回溯-测试-失败的循环会不断发生，最终退回开
始的状态：
(1W+)
此处仍然无法匹配成功、所以报告整个表达式无法匹配。
---
## Page 198
172
第4章：表达式的匹配原理
测验答案
171页测试的答案
（？>.*？）会匹配什么？
它永远无法匹配任何字符。充其量它只能算是个相当复杂的正则表达式，但不匹配任
何字符。.*？1是.*的忽略优先表示，它限定的是一个点号，所以首选的分支就是忽
略点号，把匹配点号的状态保留下来备用。但是，这个保存的状态马上叉会被放弃，
因为匹配退出了固化分组，所以真正尝试的只有忽略点号的分支。总是被忽略的东西，
实际上相当于不存在。
我们只消看一眼就能知道，所有的回溯都是白费工夫。如果冒号无法匹配最后的字符，那
么它当然无法匹配+交还的任何字符。
既然我们知道，八w+匹配结束之后，从任何备用状态开始测试都不能得到全局匹配，就可
以命令正则引擎不必检查它们：（?>\w+）。我们已经全面了解了正则表达式的匹配过程，
可以使用固化分组来控制w+的匹配，放弃备用的状态（因为我们知道它们没有用），提
高效率。如果存在可以匹配的文本，那么固化分组不会有任何影响，但是如果不存在能够
匹配的文本，放弃这些无用的状态会让正则引擎更快地得出无法匹配的结论（先进的实现
也许能够自动进行这样的优化，251）。
我们将在第6章看到（第269页），固化分组非常有价值，我怀疑它可能会成为最常用的技
巧。
占有优先量词，？+、*+、++和（m，n}+
Possessioe Quantifiers, ?+, ++, ++, and (m,n}+
占有优先量词与匹配优先量词很相似，只是它们从来不交还已经匹配的字符。我们在\W+
的例子中看到，加号在匹配结束之前创建了很少的备用状态，而占有优先的加号会直接放
弃这些状态（或者，更形象地说，并不会创造这些状态）。
你也许会想，占有优先量词和固化分组关系非常紧密。像W++这样的占有优先量词与
(?>\W+）的匹配结果完全相同，只是写起来更加方便而已（注7)。使用占有优先量词，
（?>\w+）：可以写作\w++:)，（\.1d\d（?>[1-9]?)）\d+写做（\.1d\d[1-9]？+）~\d+1。
注7：聪明的实现方式在处理占有优先量词时会更高效一些，250
---
## Page 199
关于匹配优先和回溯的更多内容
173
请务必区分（?>M）+和（?M+）。前者放弃M创建的备用状态，因为M不会制造任何状态，
所以这样做没什么价值。而后者放弃M+创造的未使用状态，这样做显然有意义。
比较（?>M）+和"（?>M+），显然后者就对应于M++)，但如果表达式很复杂，例如（\\"I[~"]）
*+1，从占有优先量词转换为固化分组时大家往往会想到在括号中添加？>”得到
（？>\\"[^"]）*。这个表达式或许有机会实现你的目的，但它显然不等于那个使用占有
优先量词的表达式；它就好像是把M++写作（?>M）+1一样。正确的办法是，去掉表示占有
优先的加号，用固化分组把余下的部分包括起来：（?>（\\"1[^"]）*）。
环视中的回溯
IhcBack!rncking ofLookarounu
初看时并不容易认识到，环视（见第2章，·59）与固化分组和占有优先量词有紧密的联
系。坏视分为4种：肯定型（positive）和否定型（negative），顺序环视与逆序环视。它们
只是简单地测试，其中表达式能否在当前位置匹配后面的文本（顺序环视），或者前面的文
本(逆序环视)。
深人点看，在NFA的世界中包含了备用状态和回溯，环视是怎么实现的？环视结构中的子
表达式有自己的世界。它也会保存备用状态，进行必要的回溯。如果整个子表达式能够成
功匹配，结果如何呢？肯定型环视会认为自已匹配成功：而否定环视会认为匹配失败。在
任何一种情况下，因为关注的只是匹配存在与否（在刚才的例子中，的确存在匹配），此四
配尝试所在的“世界”，包括在尝试中创造的所有备用状态，都会被放弃。
如果环视中的子表达式无法匹配，结果如何呢？因为它只应用到这个“世界”中，所以回
溯时只能选择当前环视结构中的备用状态。也就是说，如果正则表达式发现，需要进一步
回溯到当前的坏视结构的起点以前，它就认为当前的子表达式无法匹配。对肯定型环视来
说，这就意味着失败，而对于否定型环视来说，这意味着成功。在任何一种情况下，都没
有保留备用状态（如果有，那幺子表达式的匹配尝试就没有结束），自然也谈不上放弃。
所以我们知道，只要环视结构的匹配尝试结束，它就不会留下任何备用状态。任何备用状
态和例子中肯定坏视成功时的情况一样，都会被放弃。我们在其他什么地方看到过放弃状
态？当然是固化分组和占有优先量词。
---
## Page 200
174
第4章：表达式的匹配原理
用肯定环视模拟固化分组
如果流派本身支持固化分组，这么做可能有点多此一举，但如果流派不支持固化分组，这
么做就很有用：如果所使用的工具支持肯定环视，同时可以在肯定环视中使用捕获括号（大
多数风格都支持，但也有些不支持，TcI就是如此），就能模拟实现固化分组和占有优先量
词。（?>regex）：可以用（？=（regex)）\1i来模拟。举例来说，比较（?>\w+）：和~（？=（\w+））