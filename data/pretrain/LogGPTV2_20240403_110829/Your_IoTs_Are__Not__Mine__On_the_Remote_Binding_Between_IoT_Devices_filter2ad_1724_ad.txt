the dynamic instrumentation tool Frida [2] to intercept and
modify the source requests generated in the app. On the other
hand, to forge device messages, we need to perform ﬁrmware
reverse engineering. As we all know that ﬁrmware analysis is
not easy [21], [27], [57] and not always feasible, we were only
able to forge device messages for 3 devices (with ﬁrmware
downloaded from the ofﬁcial websites). We either performed
dynamic analysis to emulate the ﬁrmware images (for 1 of
them) or perform static analysis to identify and manually craft
device messages out of the box (for 2 of them).
B. Results
Table III shows the designs of the devices and the results of
our attacks. As can be seen, at least 4 of the devices use device
229
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:13:41 UTC from IEEE Xplore.  Restrictions apply. 
#1: Belkin
#2: BroadLink
#3: KONKE
#4: Lightstory
#5: Orvibo
#6: OZWI
#7: Philips Hue
#8: TP-LINK
Smart Plug
IP Camera
Smart Bulb
Smart Bulb
Smart Plug
#9: E-Link Smart
#10: D-LINK
: attack successfully launched;
IP Camera
Smart Plug
DevT oken
Ο
Smart Plug
Smart Socket DevT oken
DevT oken
Smart Plug
Sent by the app
Sent by the app
Sent by the app
Sent by the app
Sent by the app
Sent by the app
Sent by the app
Sent by the device
Sent by the app
Sent by the app
Ο
DevId
Ο
DevId
DevId
DevId
Attacks
U nbind
A1
A2
A3
A4
(DevId, U serT oken)
(DevId, U serT oken)
N.A.
(DevId, U serT oken)
(DevId, U serT oken)
(DevId, U serT oken)
(DevId, U serT oken)
(DevId, U serT oken)
& DevId
(DevId, U serT oken)
(DevId, U serT oken)

Ο


Ο
Ο
Ο

Ο











A3-2

A3-3

A3-2







A4-2

A3-1 & A3-4
A4-3


A4-1

TABLE III: Evaluation Results on Experimental Devices
Vendors
Device Types
Status
Designs
Bind :
(DevId, U serT oken)
: attack failed to launch; Ο: Unable to conﬁrm due to ﬁrmware challenges; N.A.: Not Applicable.
IDs for device authentication7. A favorite design is to send
messages by the app, while we still found one exception that
sends binding messages by the device. Most devices (90%)
support message type U nbind : (DevId, U serT oken) sent
by the app to revoke bindings. For device #3 that does not
support binding revocation, we found out that it actually uses
binding operations of a new user to replace a previous user’s
binding.
On the whole, our attacks were successfully launched on
9 devices. In particular, data injection and stealing (A1) was
launched on device #10. We reverse engineered its ﬁrmware
and found the device messages. Next, we forged such device
messages by reconstructing the messages and establishing an
OpenSSL socket connection with the cloud. To simulate data
injection attacks, we forged messages that report fake power
consumption to the user. For data stealing attacks, we setup
a schedule on the app to turn on and turn off the smart plug.
And the attacker could then successfully receive the response
of the schedule from the cloud.
There are 6 devices suffering from binding denial-of-service
attacks (A2). For device #7, when the binding is initiated on
the user app, it requires the user to press a physical button
on the device within 30 seconds. Under the hood, a device
registration message is sent when the button is pressed. Then
the cloud compares whether the source IP addresses of the
device request and the user request are the same [30]. The
binding fails if they are not the same. Interestingly, device
#3 does not suffer from binding denial-of-service because of
its broken unbinding mechanism: any new binding creation
manipulates the previous binding.
To our surprise, there are 4 devices suffering from device
unbinding attacks (A3). Since device #3 does not support bind-
ing revocation, the binding between the user and the device
can be replaced by the attacker’s new binding. Therefore,
it suffers from device unbinding attacks. However, although
7For device #1, #8 and #10, we reverse engineered their ﬁrmware. For
device #4, we checked its API document. For device #6 and #9, we
successfully launched binding and unbinding attacks. Those attacks indicate
that the devices use device ID for authentication.
the attacker can create such a binding, she is not able to
hijack the device. Because it uses the device token for device
authentication and the attacker cannot send a fresh token to
the device. For device #8, we forged its device status messages
and this also causes device unbinding with the user. We also
forged an unbinding message with type U nbind : devId, and
this can also successfully unbind the user with the device.
Besides, we successfully launched device hijacking attacks
(A4) on 3 devices. Device #9 is hijacked with design ﬂaw A4-
1, by simply sending a new binding message to replace the
user’s binding in the cloud. Device #6 is hijacked when it is
in the online state and not bound with any users. For device
#8, we ﬁrst sent an unbinding message to revoke its binding
with the user. Then we forged a binding message to bind it
with the attacker.
In prior research [43], device hijacking requires the attacker
to send a message directly to the device to setup the device
communication key. However, our attacks exploit the design
ﬂaws and cloud implementation ﬂaws and thus does not
require any local network access.
C. Ethics and Responsible Disclosure
We carefully designed our experiment
to avoid ethical
problems. When we conduct our attacks, we only exploit
the devices that we purchased, meaning that we only obtain
privacy data of our own devices and exploit the ﬂawed designs
that only affect our own devices. Although the device IDs
could be sequential, we only substitute the IDs of our own de-
vices and we do not brute-force them in case of affecting other
users. Also, we have reported our discoveries and suggestions
to the corresponding vendors. At the time of this writing,
we have received acknowledgments from some of them, and
they have promised to check the details and improve their
designs of remote binding. To disclose vulnerability details
responsibly, we release the vulnerabilities that have been ﬁxed
as case studies on our project website8.
8https://sites.google.com/view/iot-remote-binding
230
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:13:41 UTC from IEEE Xplore.  Restrictions apply. 
VII. LESSONS LEARNED
In our research, we discovered a series of design failures and
implementation ﬂaws in IoT remote binding. In fact, vendors
have not yet raised awareness to protect the device IDs in
their solutions. For example, they may use ﬁxed, sequential or
predictable device IDs. Although they can adopt device IDs
with sufﬁcient length and randomness, the leak of device IDs
is unavoidable. Since the device is a thing in nature and the
ownership can be transferred in reusing or selling. Such loose
protection of device IDs in practice actually poses security
challenges in IoT remote binding.
More importantly, given the complexity, the security impli-
cations in remote binding are less understood by IoT devel-
opers. To this end, we systematically examined the designs
and implementations from products of 10 IoT vendors, and
successfully launched real-world attacks on the devices. Our
study brings the following misunderstandings in IoT remote
binding to the spotlight:
• First of all,
the use of static device IDs for device
authentication allows the attacker to compromise de-
vice authentication. As aforementioned attacks show, this
could lead to serious consequences like data injection and
stealing or device hijacking. Given that IoT devices are
ﬁrst conﬁgured by users in most scenarios, we suggest
that a better solution is to request a dynamic device secret
from the user.
• Second, the binding between a user and a device involves
the user’s authorization to access her device in the cloud.
As such, proper access control mechanisms should be
enforced in binding (i.e., both pre-binding and post-
binding). Unfortunately, the devices that we studied do
not have such proper design of authorization. In this case,
the device ID is essentially an ambient authority, and it
cannot be used to represent the user’s ownership (i.e. the
authority of binding) of the device.
• Third, binding revocation is also a critical authorization
step, in which only the user who is already bound with
the device can revoke its binding. However, some devices
do not have correct designs and implementations in this
step. A prominent example is that binding revocation
is achieved by creating a new binding to replace the
previous binding, which has been demonstrated to suffer
from multiple attacks.
• Last, given that nowadays IoT devices are attracting
more and more attention of attackers, a user’s sensitive
information, such as the user account, should never be
delivered to the device during remote binding.
VIII. DISCUSSION
We have present a systemtic study on the remote binding
mechanisms together with multiple attacks against them. In
this section, we discuss some of the limitations of our research
in terms of the scope and the evaluation. We also highlight a
few of the potential follow-up studies that could be performed
based on our ﬁndings.
Problem scope. First, our study is based on the common
communication architecture that only includes three parties:
the device (or the hub), the user, and the cloud. In future work,
it may be interesting to see if our study could be generalized
to other communication architectures that involve four parties:
the Zigbee/Bluetooth device, the IP-based hub device, the user,
and the cloud. Second, although the goal of our research is to
understand the protocol-level vulnerabilities that are speciﬁc
to remote binding, the remote binding process could also be
affected by other vulnerabilities during local conﬁguration,
for example, Man-in-the-Middle attacks that compromise the
local binding by proximity [23], key reinstallation attacks that
allow injection and manipulation of encrypted home Wi-Fi
packets [51], and snifﬁng attacks that allow the attacker to
obtain Wi-Fi credentials [41].
Experimental results. First of all, since we could not obtain
the ﬁrmware images for some of our experimental devices, we
were unable to conﬁrm data injection and stealing attacks on
them. Second, although the results of our attacks do not have
false positives, there could be some false negatives. In our
experiments, the attack failures were identiﬁed from: response
messages or the success of other attacks. As an example, the
success of attack A3-3 indicates that binding denial-of-service
attack would fail. However, given that some implementation
ﬂaws are in the cloud, we were unable to conﬁrm the root
causes of some potential attack failures.
Automatic detection. As a starting point, our systematic study
and manual analysis reveal a series of attack surfaces in remote
binding. In the future, we plan to explore the feasibility to
develop effective and automatic approaches. This could further
help IoT vendors improve the security of their products and
their clouds. Currently, our analyses require the presence of
physical devices, which is less scalable. Therefore, we would
also like to explore the feasibility to automatically discover
remote binding threat without the presence of physical devices.
IX. RELATED WORK
In this section, we introduce and compare prior studies that
are related to ours. We discuss how our work is different from
prior IoT authentication and authorization studies. Apart from
that, our study is also related to the security analysis of IoT
devices.
Authentication in IoT. Given the unique communication
architecture, authentication schemes in IoT have been heavily
studied in previous works, such as [35], [36], [44], [46],
[48], [54]. In fact, the works that are the most related to our
work focus on the authentication problems in Wireless Sensor
Networks (WSN). In WSN, there are three parties: the sensor
node, the gateway node, and the user. Users can communicate