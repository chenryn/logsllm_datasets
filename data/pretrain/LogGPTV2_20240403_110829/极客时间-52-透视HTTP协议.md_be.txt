## 强化安全出于兼容的考虑，HTTP/2 延续了 HTTP/1的"明文"特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。但由于 HTTPS 已经是大势所趋，而且主流的浏览器 Chrome、Firefox等都公开宣布只支持加密的 HTTP/2，所以"事实上"的 HTTP/2是加密的。也就是说，互联网上通常所能见到的 HTTP/2都是使用"https"协议名，跑在 TLS 上面。为了区分"加密"和"明文"这两个不同的版本，HTTP/2协议定义了两个字符串标识符："[h2]{.orange}"表示加密的HTTP/2，"[h2c]{.orange}"表示明文的HTTP/2，多出的那个字母"c"的意思是"clear text"。在 HTTP/2 标准制定的时候（2015 年）已经发现了很多 SSL/TLS 的弱点，而新的TLS1.3 还未发布，所以加密版本的 HTTP/2在安全方面做了强化，要求下层的通信协议必须是 TLS1.2以上，还要支持前向安全和 SNI，并且把几百个弱密码套件列入了"黑名单"，比如DES、RC4、CBC、SHA-1 都不能在 HTTP/2 里使用，相当于底层用的是"TLS1.25"。
## 协议栈下面的这张图对比了 HTTP/1、HTTPS 和 HTTP/2的协议栈，你可以清晰地看到，HTTP/2是建立在"HPack""Stream""TLS1.2"基础之上的，比 HTTP/1、HTTPS 复杂了一些。![](Images/682f034add98e40d3984337fc94b5550.png){savepage-src="https://static001.geekbang.org/resource/image/83/1a/83c9f0ecad361ba8ef8f3b73d6872f1a.png"}虽然 HTTP/2 的底层实现很复杂，但它的"语义"还是简单的HTTP/1，之前学习的知识不会过时，仍然能够用得上。我们的实验环境在新的域名"**www.metroid.net**"上启用了 HTTP/2协议，你可以把之前"进阶篇""安全篇"的测试用例都走一遍，再用 Wireshark抓一下包，实际看看 HTTP/2的效果和对老协议的兼容性（例如""）。在今天这节课专用的 URI"/30-1"里，你还可以看到服务器输出了 HTTP的版本号"2"和标识符"h2"，表示这是加密的HTTP/2，如果改用""访问就会是"1.1"和空。![](Images/5cebc44c36caa3732aa3bb7f7fee3ddf.png){savepage-src="https://static001.geekbang.org/resource/image/fd/d1/fdf1a6916c3ac22b6fb7628de3d7ddd1.png"}你可能还会注意到 URI里的一个小变化，端口使用的是"8443"而不是"443"。这是因为 443端口已经被"www.chrono.com"的 HTTPS 协议占用，Nginx不允许在同一个端口上根据域名选择性开启HTTP/2，所以就不得不改用了"8443"。
## 小结今天我简略介绍了 HTTP/2 的一些重要特性，比较偏重理论，下一次我会用Wireshark 抓包，具体讲解 HTTP/2 的头部压缩、二进制帧和流等特性。1.  [HTTP 协议取消了小版本号，所以 HTTP/2 的正式名字不是 2.0；]{.orange}2.  [HTTP/2 在"语义"上兼容 HTTP/1，保留了请求方法、URI    等传统概念；]{.orange}3.  [HTTP/2    使用"HPACK"算法压缩头部信息，消除冗余数据节约带宽；]{.orange}4.  [HTTP/2    的消息不再是"Header+Body"的形式，而是分散为多个二进制"帧"；]{.orange}5.  [HTTP/2    使用虚拟的"流"传输消息，解决了困扰多年的"队头阻塞"问题，同时实现了"多路复用"，提高连接的利用率；]{.orange}6.  [HTTP/2 也增强了安全性，要求至少是    TLS1.2，而且禁用了很多不安全的密码套件。]{.orange}
## 课下作业1.  你觉得明文形式的 HTTP/2（h2c）有什么好处，应该如何使用呢？2.  你觉得应该怎样理解 HTTP/2 里的"流"，为什么它是"虚拟"的？3.  你能对比一下 HTTP/2 与 HTTP/1、HTTPS 的相同点和不同点吗？欢迎你把自己的学习体会写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。![unpreview](Images/d40950250024198841edae132ec980c5.png){savepage-src="https://static001.geekbang.org/resource/image/78/42/781da6191d342d71d3be2675cb610742.png"}![unpreview](Images/4913a489805db29b38aefa585223c013.png){savepage-src="https://static001.geekbang.org/resource/image/56/63/56d766fc04654a31536f554b8bde7b63.jpg"}
# 31 \| 时代之风（下）：HTTP/2内核剖析今天我们继续上一讲的话题，深入 HTTP/2 协议的内部，看看它的实现细节。![](Images/faa30d92f1fc2973ffff873fe488bdad.png){savepage-src="https://static001.geekbang.org/resource/image/89/17/8903a45c632b64c220299d5bc64ef717.png"}这次实验环境的 URI 是"/31-1"，我用 Wireshark把请求响应的过程抓包存了下来，文件放在 GitHub的"wireshark"目录。今天我们就对照着抓包来实地讲解 HTTP/2的头部压缩、二进制帧等特性。
## 连接前言由于 HTTP/2"事实上"是基于 TLS，所以在正式收发数据之前，会有 TCP 握手和TLS 握手，这两个步骤相信你一定已经很熟悉了，所以这里就略过去不再细说。TLS 握手成功之后，客户端必须要发送一个"**连接前言**"（connectionpreface），用来确认建立 HTTP/2 连接。这个"连接前言"是标准的 HTTP/1 请求报文，使用纯文本的 ASCII码格式，请求方法是特别注册的一个关键字"PRI"，全文只有 24 个字节：    PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n在 Wireshark 里，HTTP/2的"连接前言"被称为"**Magic**"，意思就是"不可知的魔法"。所以，就不要问"为什么会是这样"了，只要服务器收到这个"有魔力的字符串"，就知道客户端在TLS 上想要的是 HTTP/2 协议，而不是其他别的协议，后面就会都使用 HTTP/2的数据格式。``{=html}
## 头部压缩确立了连接之后，HTTP/2 就开始准备请求报文。因为语义上它与 HTTP/1兼容，所以报文还是由"Header+Body"构成的，但在请求发送前，必须要用"**HPACK**"算法来压缩头部数据。"HPACK"算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib等压缩算法不同，它是一个"有状态"的算法，需要客户端和服务器各自维护一份"索引表"，也可以说是"字典"（这有点类似brotli），压缩和解压缩就是查表和更新表的操作。为了方便管理和压缩，HTTP/2废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，并且给这些"不是头字段的头字段"起了个特别的名字------"**伪头字段**"（pseudo-headerfields）。而起始行里的版本号和错误原因短语因为没什么大用，顺便也给废除了。为了与"真头字段"区分开来，这些"伪头字段"会在名字前加一个":"，比如":authority"":method" ":status"，分别表示的是域名、请求方法和状态码。现在 HTTP 报文头就简单了，全都是"Key-Value"形式的字段，于是 HTTP/2就为一些最常用的头字段定义了一个只读的"**静态表**"（Static Table）。下面的这个表格列出了"静态表"的一部分，这样只要查表就可以知道字段名和对应的值，比如数字"2"代表"GET"，数字"8"代表状态码200。![](Images/5c99cadab49fc9d81d06d2556299af2a.png){savepage-src="https://static001.geekbang.org/resource/image/76/0c/769dcf953ddafc4573a0b4c3f0321f0c.png"}但如果表里只有 Key 没有 Value，或者是自定义字段根本找不到该怎么办呢？这就要用到"**动态表**"（DynamicTable），它添加在静态表后面，结构相同，但会在编码解码的时候随时更新。比如说，第一次发送请求时的"user-agent"字段长是一百多个字节，用哈夫曼压缩编码发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号"65"。那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。![](Images/f3fcab83c3f1bf5402a39b539a949e3e.png){savepage-src="https://static001.geekbang.org/resource/image/5f/6f/5fa90e123c68855140e2b40f4f73c56f.png"}你可以想象得出来，随着在 HTTP/2连接上发送的报文越来越多，两边的"字典"也会越来越丰富，最终每次的头部字段都会变成一两个字节的代码，原来上千字节的头用几十个字节就可以表示了，压缩效果比gzip 要好得多。
## 二进制帧头部数据压缩之后，HTTP/2 就要把报文拆成二进制的帧准备发送。HTTP/2 的帧结构有点类似 TCP 的段或者 TLS 里的记录，但报头很小，只有 9字节，非常地节省（可以对比一下 TCP 头，它最少是 20 个字节）。二进制的格式也保证了不会有歧义，而且使用位运算能够非常简单高效地解析。![](Images/cb7a418179d719a82933c3c31c898ede.png){savepage-src="https://static001.geekbang.org/resource/image/61/e3/615b49f9d13de718a34b9b98359066e3.png"}帧开头是 3 个字节的**长度**（但不包括头的 9 个字节），默认上限是2\^14，最大是 2\^24，也就是说 HTTP/2 的帧通常不超过 16K，最大是 16M。长度后面的一个字节是**帧类型**，大致可以分成**数据帧**和**控制帧**两类，HEADERS帧和 DATA 帧属于数据帧，存放的是 HTTP 报文，而 SETTINGS、PING、PRIORITY等则是用来管理流的控制帧。HTTP/2 总共定义了 10 种类型的帧，但一个字节可以表示最多 256种，所以也允许在标准之外定义其他类型实现功能扩展。这就有点像 TLS里扩展协议的意思了，比如 Google 的 gRPC就利用了这个特点，定义了几种自用的新帧类型。第 5 个字节是非常重要的**帧标志**信息，可以保存 8个标志位，携带简单的控制信息。常用的标志位有**END_HEADERS**表示头数据结束，相当于HTTP/1里头后的空行（"\\r\\n"），**END_STREAM**表示单方向数据发送结束（即EOS，End of Stream），相当于 HTTP/1 里 Chunked分块结束标志（"0\\r\\n\\r\\n"）。报文头里最后 4个字节是**流标识符**，也就是帧所属的"流"，接收方使用它就可以从乱序的帧里识别出具有相同流ID 的帧序列，按顺序组装起来就实现了虚拟的"流"。流标识符虽然有 4 个字节，但最高位被保留不用，所以只有 31位可以使用，也就是说，流标识符的上限是 2\^31，大约是 21 亿。好了，把二进制头理清楚后，我们来看一下 Wireshark 抓包的帧实例：![](Images/0502daf8858bb9a4689e6baaa0ebb791.png){savepage-src="https://static001.geekbang.org/resource/image/57/03/57b0d1814567e6317c8de1e3c04b7503.png"}在这个帧里，开头的三个字节是"00010a"，表示数据长度是 266 字节。帧类型是 1，表示 HEADERS 帧，负载（payload）里面存放的是被 HPACK算法压缩的头部信息。标志位是 0x25，转换成二进制有 3 个位被置 1。PRIORITY表示设置了流的优先级，END_HEADERS表示这一个帧就是完整的头数据，END_STREAM表示单方向数据发送结束，后续再不会有数据帧（即请求报文完毕，不会再有DATA 帧 /Body 数据）。最后 4 个字节的流标识符是整数1，表示这是客户端发起的第一个流，后面的响应数据帧也会是这个ID，也就是说在 stream\[1\] 里完成这个请求响应。