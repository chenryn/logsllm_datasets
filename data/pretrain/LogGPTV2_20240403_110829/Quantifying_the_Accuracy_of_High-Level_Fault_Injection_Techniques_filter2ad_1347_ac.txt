# 优化后的文本

## SDC 结果比较：LLFI 与 PINFI

| 指令类别 | LLFI 结果 (%) | PINFI 结果 (%) |
| --- | --- | --- |
| (a) 算术操作指令 | 12% (268007691) | 7% (56928497) |
| (b) 类型转换指令 | 8% (31542955) | 3% (539958621) |
| (c) 比较指令 | 4% (PINFI 38227320) | 11% (827164028) |
| (d) 加载指令 | 12% (268007694) | 13% (57166980) |

### 图 4: LLFI 和 PINFI 的 SDC 结果
子图 (a) 至 (d) 分别表示不同指令类别的 SDC 结果；子图 (e) 表示所有指令的 SDC 结果。

## 加载指令的差异
加载指令在 LLVM IR 中被翻译为数据操作，而这些操作是 LLFI 的注入目标。然而，在汇编代码中，数据直接通过 `mov` 指令从一个位置移动到另一个位置，并没有相应的加载指令。因此，LLFI 注入了更多的数据操作，导致其 SDC 率比 PINFI 更高。

## RQ3: LLFI 和 PINFI 的崩溃结果
表 V 显示了基准程序在 LLFI 和 PINFI 下的崩溃百分比。从表 V 可以看出，LLFI 和 PINFI 在比较指令上的崩溃百分比相似。然而，在其他指令类别上，崩溃百分比存在显著差异。两个工具之间的最大差异如下：
- "所有" 类别（ocean）：17%
- "算术" 类别（bzip2）：40%
- "类型转换" 类别（hmmer）：32%
- "加载" 类别（hmmer）：21%

在第七部分中，我们将解释崩溃率差异的原因。

## 讨论
第六部分的故障注入实验结果显示，LLFI 的 SDC 率与 PINFI 非常接近，这表明 LLFI 是研究 SDC 引起错误的良好选择。然而，在崩溃方面，两种注入器之间存在显著差异。我们将探讨这些差异的原因及其解决方法（未来工作）。

### 1. GetElementPtr 指令
LLVM IR 使用 `getelementptr` 指令进行指针地址计算，但在汇编代码级别，指针计算使用普通的加、减、乘指令。虽然看似可以通过将所有 `getelementptr` 指令视为等效的算术操作来解决这个问题，但并非所有 `getelementptr` 指令都转化为算术操作。我们需要一种启发式方法来决定何时将 `getelementptr` 指令视为算术指令，并仅对这些指令注入故障。

### 2. 类型转换指令
类型转换指令在处理指针转换时（如 bzip2 基准测试中的情况）会导致不准确性。为了消除这种差异，我们需要识别这些情况，并不在 LLVM IR 级别注入故障。

### 3. Mov 指令
在汇编代码中，`mov` 指令用于在寄存器之间以及寄存器和内存之间移动数据。然而，在 LLVM IR 中，这些操作由不同的指令完成，因此对应于汇编代码中 `mov` 指令的 LLVM IR 指令数量更多。为了消除这种差异，我们需要仅对那些在汇编代码中有相应类比的指令注入故障。

## 相关工作
我们将相关工作分为三类：
1. 硬件故障的程序级故障注入
2. 硬件故障的汇编代码级故障注入
3. 软件故障的故障注入

### 硬件故障的程序级故障注入
许多尝试在程序级别构建硬件故障注入器。Propane [10] 是第一个在程序级别注入故障并跟踪其传播的工具。然而，据我们所知，Propane 在硬件故障注入方面的准确性尚未得到测量。

Pattabiraman 等人 [24] 提出了一种通过复制关键数据的后向切片来选择性保护关键数据的方法。Relax [2] 是一种通过结构化块和异常处理来容忍软错误的代码转换技术。Cong 等人 [5] 使用静态分析来识别需要复制以保护软计算应用的指令。类似于 LLFI，上述论文的作者基于 LLVM 编译器开发了故障注入器来验证他们的技术。然而，他们都没有验证故障注入器在注入硬件故障方面的准确性。

Thomas 等人 [12] 构建了一种静态分析技术，用于识别软计算应用中的关键数据以防止严重的输出偏差。他们也在 LLVM 编译器级别进行了故障注入。与上述论文不同的是，他们对其注入器进行了有限的验证，但仅限于 EDC 导致的错误。然而，EDC 只是 SDC 的一小部分，他们的评估仅限于软计算应用。相比之下，我们评估了 LLFI 在通用应用中的准确性，并涵盖了所有 SDC 和崩溃导致的错误。

最近，Sharma 等人提出了 KULFI [11]，它是一个“可配置的注入器”。像 LLFI 一样，KULFI 也是基于 LLVM 编译器基础设施构建的，并在 IR 代码上运行。据我们所知，KULFI 尚未在汇编代码级别进行验证。此外，KULFI 的作者将其用于比较算法在 SDC 和崩溃导致的错误方面的错误恢复能力。然而，正如本文所示，在 LLVM 级别进行故障注入可能并不准确，尤其是在崩溃导致的错误方面，尽管我们尚未直接验证 KULFI 在此类故障中的准确性。

### 汇编代码级故障注入
在汇编语言级别进行故障注入以模拟硬件故障已有大量工作。例如 NFTAPE [7]、GOOFI-2 [8] 和 Xception [9]。NFTAPE 使用断点注入在机器代码级别。GOOFI-2 支持三种故障注入方法：基于插桩、基于异常和基于 Nexus 的方法。所有三种方法都在汇编代码或更低级别操作。Xception 使用调试寄存器和现代处理器中的功能在运行时注入故障。尽管 Xception 允许高度可配置的故障注入，但它也操作在汇编语言级别。

Cho 等人 [25] 最近的一篇论文评估了汇编代码级别故障注入与寄存器传输语言 (RTL) 级别故障注入的准确性。他们发现 RTL 级别的单比特翻转可能在汇编代码级别表现为多比特翻转。与我们的工作试图校准更高层次的故障注入相对于汇编语言级别的准确性不同，他们感兴趣于基准测试汇编级别注入器的准确性。因此，他们的研究是对我们工作的补充。

### 软件故障的故障注入
注入软件故障的技术通常在源代码级别或接近源代码的级别（例如抽象语法树）操作。G-SWiFT 是一种试图在机器代码级别模拟软件故障的技术 [15]，通过识别与高级软件构造相对应的汇编代码指令模式并在其中注入故障来模拟软件错误。由于软件错误主要发生在源代码级别，因此校准汇编代码级别注入技术相对于源代码级别的准确性非常重要。Cotroneo [16] 进行了这样的特征描述，并发现机器代码级别的软件故障注入可能不代表残留的软件错误。与软件故障不同，硬件故障发生在微处理器或内存内部，并影响程序执行。因为可执行文件是汇编/机器语言，硬件故障更容易在该级别模拟。因此，在高层次注入硬件故障时，校准其相对于汇编代码级别的准确性非常重要。这是上述软件故障注入论文面临问题的反面。

## 结论
本文定量比较了高层次故障注入技术和汇编代码级别故障注入技术在硬件故障方面的准确性。我们开发了两个故障注入器：LLFI 代表高层次故障注入器，PINFI 代表低层次故障注入器。我们通过六个基准应用程序上的故障注入实验，比较了 LLFI 和 PINFI 在崩溃和 SDC 方面的准确性。结果表明，LLFI 在注入 SDC 导致的错误方面非常准确，但在崩溃导致的错误方面不如 PINFI 准确。因此，高层次故障注入技术适合研究 SDC 导致的错误，而不适合研究崩溃导致的错误。

## 致谢
本研究得到了加拿大自然科学与工程研究委员会 (NSERC) 的 Discovery 授予的部分支持，以及洛克希德·马丁公司的研究资助。感谢 DSN 匿名评审者的宝贵意见，使本文得以改进。

## 参考文献
[略]

---

希望这个优化后的版本能更清晰、连贯和专业。如果有任何进一步的修改需求，请告诉我！