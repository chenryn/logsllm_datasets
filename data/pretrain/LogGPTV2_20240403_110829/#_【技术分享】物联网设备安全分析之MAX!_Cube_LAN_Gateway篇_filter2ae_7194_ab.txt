    B:FOOBAR1,5a8a4a5d3c1bd612b8bf1e2fecf609f7,1,SuperSecret
第一行包括的内容是序列号、RF地址和固件版本。
第二行包括用户名（FOOBAR1）、MD5哈希值，数字（1）和实际密码（SuperSecret）。MD5哈希值是
password||serial_number的哈希值：
    ~ » echo -n "SuperSecretKMD1016788"|openssl md5
    (stdin)= 5a8a4a5d3c1bd612b8bf1e2fecf609f7
为了将这个有效载荷发送到远程系统，我们必须进行Base64编码：
    ~ » echo -n "H:KMD1016788,099c3e,0113
    B:FOOBAR1,5a8a4a5d3c1bd612b8bf1e2fecf609f7,1,SuperSecret"|base64 -w0
    SDpLTUQxMDE2Nzg4LDA5OWMzZSwwMTEzCkI6Rk9PQkFSMSw1YThhNGE1ZDNjMWJkNjEyYjhiZjFlMmZlY2Y2MDlmNywxLFN1cGVyU2VjcmV0
然后进行加密：
    e:SDpLTUQxMDE2Nzg4LDA5OWMzZSwwMTEzCkI6Rk9PQkFSMSw1YThhNGE1ZDNjMWJkNjEyYjhiZjFlMmZlY2Y2MDlmNywxLFN1cGVyU2VjcmV0^M
    E:kGxTXPZVm8CQGcurInyvX3z4C+6zKKKcuS8Wp259XC1yKUfN8tFIfRt0s3qRliIcUGSAcuhuDzl7fpT6fWOnyysSxk9TG1cXtrcVkeNWUzgeO5poXjS5tJlXWgV64ibG
我们现在可以将该Base64字符串复制到Burpsuite的中继器中，进行Base64解码（选中它，然后按CTRL + Shift +
b），并将其发送到服务器，具体如下图所示：
如图所示，服务器返回了一个200
OK响应，说明我们的请求成功了。之后，我们就可以使用用户名FOOBAR1和密码SuperSecret登录到http://smarthome.md.de/的Web界面了。
为了给响应消息进行解密，我们可以对响应的主体进行Base64编码（只选中响应的主体，并按CTRL + b），然后将其发送到Cube，利用其解密功能进行处理：
    d:QAINuzPCglmG1nNNI/ylrbV6AXKdtBQbkNXT/pMobpXSeuP6/tZtCIq8GD5YSHjK^M
    D:aTowMDAwNTFiMSwwMDAwMDAwMCxmZmZmZmZmZg0KYjpPSw0KAAAAAAAAAAAAAAAA
然后，对得到的Base64字符串进行解码：
    ~ » echo -n "aTowMDAwNTFiMSwwMDAwMDAwMCxmZmZmZmZmZg0KYjpPSw0KAAAAAAAAAAAAAAAA"|base64 -d
    i:000051b1,00000000,ffffffff
    b:OK
这里的重要问题是：该设备是如何加密该字符串的，加密密钥是什么？ 当谈论AES加密时，你必须弄清楚：
使用的密钥大小是多少？ AES支持128、192和256位密钥。
使用什么操作模式？
根据操作模式：初始化向量（IV）是什么？
第一个问题很容易回答：在供应商页面上，他们说它使用的是AES-128。 那么操作模式是什么呢？ 知道了它，我们就可以加密任意字符串。
最基本的操作模式是ECB：每个16字节块都被独立加密，对于它来说，如果对明文加密两次后会得到相同的密文。 我已经通过字符串（ 16 *
“xff”的Base64编码）进行了测试，这个字符串的大小正好等于AES密码的块大小：
    e://///////////////////w==^M
    E:XQfNd8PcLZgnJbwGTuTx5A==
    e://///////////////////w==^M
    E:XQfNd8PcLZgnJbwGTuTx5A==
我们可以看到，对相同的明文（///////////////////// w ==）加密两次，得到的密文是一致的，那么这可能意味着使用的是ECB 。
但是，让我们看看多个块是否是单独进行加密的。 以下示例将会加密32 *“ xff”（两个块）：
    e://///////////////////w==^M
    E:XQfNd8PcLZgnJbwGTuTx5A==
    e://////////////////////////////////////////8=^M
    E:XQfNd8PcLZgnJbwGTuTx5LM36fXWGGUjgVLWxtzwCgo=
如果它使用了ECB模式，那么密文应包含两份先前看到的字节序列：
    cryptotest » echo -n "XQfNd8PcLZgnJbwGTuTx5A=="|base64 -d |xxd
    00000000: 5d07 cd77 c3dc 2d98 2725 bc06 4ee4 f1e4 ]..w..-.'%..N...
    cryptotest » echo -n "XQfNd8PcLZgnJbwGTuTx5LM36fXWGGUjgVLWxtzwCgo="|base64 -d |xxd
    00000000: 5d07 cd77 c3dc 2d98 2725 bc06 4ee4 f1e4 ]..w..-.'%..N...
    00000010: b337 e9f5 d618 6523 8152 d6c6 dcf0 0a0a .7....e#.R......
我们可以在hexdump中看到，第一个16字节的确与以前的加密结果一致，但是第二个块是完全不同的。 实际上，ECB加密结果应该是这样的：
    cryptotest » xxd plain_16
    00000000: ffff ffff ffff ffff ffff ffff ffff ffff ................
    cryptotest » xxd plain_32
    00000000: ffff ffff ffff ffff ffff ffff ffff ffff ................
    00000010: ffff ffff ffff ffff ffff ffff ffff ffff ................
    cryptotest » openssl enc -aes-128-ecb -in plain_16 -nosalt -nopad -k TEST |xxd
    00000000: cb30 66d5 3db8 89f6 da4b 5831 d29c 6b9f .0f.=....KX1..k.
    cryptotest » openssl enc -aes-128-ecb -in plain_32 -nosalt -nopad -k TEST |xxd
    00000000: cb30 66d5 3db8 89f6 da4b 5831 d29c 6b9f .0f.=....KX1..k.
    00000010: cb30 66d5 3db8 89f6 da4b 5831 d29c 6b9f .0f.=....KX1..k.
我们现在知道，它不是ECB。第二种猜测是使用CBC模式进行的加密。CBC在进行AES加密之前，先对第一个块用初始向量IV进行XOR运算，而所有后续块将与前一块的密文进行XOR运算。这样做的好处是防止相同的明文加密两次，会产生两份相同的密文。对于这个IV来说，就是每次加密时生成的一个随机数字。所以这里合理的猜测是，这个Cube使用的是静态IV的CBC。
但是，要想解密密文的话，我们首先需要获得相应的加密密钥。我这里的猜测是，密钥可能是基于序列号的，因为如果MAX-serial头部中包含的是另一个序列号（即使有效）的话，那么远程服务器就不会接受密文。然而，密钥从未露面，同时Cube和远程服务器在磋商加密参数的时候也没有进行握手。所以，我猜测这个密钥可能是通过序列号计算得到的。
除了软件方面之外，我还还考察了Cube的硬件。结果是，电路板本身是很小，正面除了序列号之外，好像也没有其他有用的信息。但是，我把它翻过来的时候，有趣的东西出现了……
背面有几个QR码，包括MAC地址，RF地址，序列号，以及一个…KEY …？
标识为KEY的QR码包含以“k”（可能是"key"的意思）为前缀的MD5哈希值，所以，我们不妨尝试用这个密钥来解密密文：
    ~ » echo -n "XQfNd8PcLZgnJbwGTuTx5LM36fXWGGUjgVLWxtzwCgo="|base64 -d |openssl enc -aes-128-cbc -d -nopad -nosalt -K 98bbce3f1b25df8e6894b779456d330e -iv 00 |xxd
    00000000: c975 1589 ed36 536c c975 1589 ed36 536c  .u...6Sl.u...6Sl
    00000010: ffff ffff ffff ffff ffff ffff ffff ffff  ................
棒极了！您可以看到，第二个块已正确解密了。 实际上，第一个块应该是相同的，但它看起来却是完全随机的。 在上一个命令中，我使用了空字节来作为IV（-iv
00）。但是，不要忘了，在解密CBC模式中的最后一个块之后，需要将最后一个块与IV进行XOR。这样就好理解了：由于第一个块（在解密期间将被最后处理）与一个错误的值进行了异或运算，所以才导致了不同的明文。
然而，在这种情况下获得IV是相当容易的，因为我们知道明文。我们只要将前面得到的第一个块与明文（即16 *“
xff”）进行异或运算，就能得到正确的IV了。现在，请打开一个Python shell，只需要进行如下所示的操作即可：
    >>> hex(0xc9751589ed36536cc9751589ed36536c^0xffffffffffffffffffffffffffffffff)
    '0x368aea7612c9ac93368aea7612c9ac93L'
现在，让我们用这里的IV再次对密文进行解密：
    ~ » echo -n "XQfNd8PcLZgnJbwGTuTx5LM36fXWGGUjgVLWxtzwCgo="|base64 -d |openssl enc -aes-128-cbc -d -nopad -nosalt -K 98bbce3f1b25df8e6894b779456d330e -iv 368aea7612c9ac93368aea7612c9ac93 |xxd
    00000000: ffff ffff ffff ffff ffff ffff ffff ffff  ................
    00000010: ffff ffff ffff ffff ffff ffff ffff ffff  ................
如你所见，我们的明文已经完全恢复了！我们还可以解密远程服务器的响应：
    ~ » echo -n "QAINuzPCglmG1nNNI/ylrbV6AXKdtBQbkNXT/pMobpXSeuP6/tZtCIq8GD5YSHjK"|base64 -d |openssl enc -aes-128-cbc -d -nopad -nosalt -K 98bbce3f1b25df8e6894b779456d330e -iv 368aea7612c9ac93368aea7612c9ac93    
    i:000051b1,00000000,ffffffff
    b:OK
现在，我们已经掌握了在Cube和远程服务器上对字符串进行加密和解密的所有秘密。同时，我还实现了一个小的Python脚本，不仅使得加密/解密字符串变得更加简单，同时还能完成适当的填充操作。
****
**网络发现的自动化**
在我看来，分析未知设备的一个重要部分，就是让其他人也能使用已获得的信息，以支持他人的进一步研究，或能够让人们用通用工具来发现这样的设备。当涉及到发现网络上的设备时，我选择的通用工具是Nmap。除了纯端口扫描之外，它还提供了大量已知服务的签名，同时，我们还可以通过NSE脚本来对其功能进行扩展。