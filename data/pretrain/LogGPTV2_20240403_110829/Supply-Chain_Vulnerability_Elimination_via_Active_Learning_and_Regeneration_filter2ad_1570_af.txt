9.95
(0.9%)
46.01
(0.3%)
9.36
(2.9%)
9.43
9.45
(1.2%)
(0.0%)
9.38
(0.9%)
9.26
(-0.9%)
9.27
(-1.6%)
(6.4%)
(2.3%)
Correctness (%)
(100%)
9/9
(100%)
9/9
(100%)
40/40
14/14
(100%)
(100%)
35/35
(100%)
31/31
(100%)
8/8
(93.3%)
28/30
7/7
(100%)
(100%)
8/8
(100%)
3/3
(100%)
4/4
(100%)
4/4
4/4
(100%)
(66.7%)
4/6
(100%)
1/10
(68.8%)
11/16
(66.7%)
(100.0%)
(95.8%)
Correctness: Out of 17 libraries, 14 are fully regenerated, pass-
ing 100% of developer-provided and client-application tests. Three
libraries are partially regenerated, passing between 4/6 (66.7%)
and 28/30 (99.3%) of tests. Two of repeat-string’s tests are de-
signed to generate exceptions—not expressible in Harp’s DSL. Two
of upper-case’s tests are locale-dependent, with string locales
that fall outside Harp’s input generation algorithm. Finally, 5 of
zero-fill’s tests expect a partially evaluated function, which is
currently not expressible in Harp’s DSL.
8 RELATED WORK
Active Learning: Active learning is a classical topic in machine
learning [54]. Recent research has introduced the concept of using
a domain-specific language to define and infer classes of target
computations [9, 50, 56, 57]. This approach promotes the clean
identification of target computations across a range of domains
and the development of efficient inference algorithms for these
computations. The approach has been used to infer and regenerate
computations with additional safety checks, increased functionality,
enhanced user interfaces, the ability to operate in new execution
contexts, expressed in different programming languages, and to syn-
thesize combine operations that enable the exploitation of divide
and conquer parallelism in stream computations [9, 50, 55–57, 67].
Example application domains include data parallelism in Unix shell
scripts [55], programs that access databases [56, 57], work with
key/value stores [50], or interact with external or internal com-
ponents [9, 67]. Functionality developed in this context includes
an efficient top-down inference algorithm [56, 57], and algorithms
that use input shapes to generate inputs that productively disam-
biguate potential candidate inferred computations (Harp and [55]).
Harp is the first active learning and regeneration system to target
string computations and the first to successfully eliminate software
supply-chain vulnerabilities in widely used libraries.
Input-Output Synthesis: Program synthesis and programming
by example automatically generate programs that satisfy a given
set of input-output examples [2, 15, 17, 18, 22, 47, 48, 59, 68]. Harp
differs in that it works with an existing component as opposed to
a fixed set of input-output examples and interacts with the com-
ponent to build a model of its behavior. The goal is to eliminate
dependencies and vulnerabilities by replacing the original version
with the regenerated version, without requiring developers to pro-
vide input-output examples manually.
Component-based synthesis [14, 16, 32, 58] aims to generate a
program consisting of library calls to a provided API. It synthesizes
code for making library calls by executing the candidate program
on a set of test cases. Harp, in contrast, infers and regenerates
complete string computations. Instead of working with a provided
set of test cases, Harp uses active learning to automatically and
adaptively generate custom inputs that enable Harp to infer each
string computation.
Component Protection: Runtime component protection tech-
niques provide monitoring, instrumentation, and policy enforce-
ment, typically through sandboxing, wrapping, or transformation [1,
19, 24, 31, 34–36, 38, 51, 53, 63]. Harp differs in that it replaces the
library with a regenerated version instead of executing the library
in a sandbox or wrapping the library to dynamically enforce a
security policy. The regenerated library therefore executes with
no runtime instrumentation overhead and requires no sandboxing.
We note that, to avoid exploitation during inference, Harp uses
a combination of sandboxing and wrapping during inference. Un-
like sandboxing or wrapping, Harp also protects against library
deletion attacks.
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1766Software Debloating: Software debloating [3, 20, 25, 26] lowers
the potential for vulnerabilities by eliminating unused code in a
program. Functionality excision [49] removes code that implements
counterproductive, irrelevant, or undesirable functionality. Like de-
bloating and functionality excision, Harp can eliminate code in the
inferred library. Unlike debloating, which prunes computation in
the original library but leaves unpruned code intact, Harp replaces
the original library with a regenerated version that is guaranteed
to conform to a safe model of computation. Harp can also dis-
card potentially malicious code in the regeneration, including code
that executes during inference but does not affect the client-visible
behavior of the inferred library.
Vulnerability Detection: Prior work on static [8, 12, 13, 23, 62]
and dynamic [46, 70] analysis can detect malicious code at devel-
opment or production time. Harp does not attempt to detect a
vulnerability—rather, it assumes libraries as a potential liability
with stealthy Turing-complete vulnerabilities, and rewrites them
into functionally equivalent, side-effect-free versions.
9 DISCUSSION & LIMITATIONS
Synthesis Limitations: There are desirable guarantees that Al-
gorithm 1 does not satisfy. First, if the behavior of the original
library L does not correspond to any program in the DSL, there
is no guarantee that the algorithm will determine this fact in any
finite time—it is possible that the difference in behavior will be
exposed only by an input that the algorithm has yet to consider.
Second, if the behavior of the original library L does correspond to
some program in the DSL, there is no guarantee that the algorithm
will find that DSL program in any finite time—it is possible that the
program is larger than programs that the algorithm has considered.
So given a set of DSL programs P at some point in execution
of Algorithm 1, what must be true of the relationship between the
DSL programs f ∈ P and the original library L? First, P and all
f exhibit identical behavior on all considered inputs I. Second, if
there is some program f of size n or less that has the same behavior
as L on all inputs, then f ∈ P. If additionally P = { f }, then the
algorithm will return a new library L′ that has identical behavior as
the original library L. There are two key preconditions here which
Algorithm 1 does not check: (1) there is some DSL program f which
has identical behavior on all inputs as the original library L, and
(2) this DSL program is of size n or less for some known n. These
preconditions may come, for example, from the general domain
knowledge of the programmer.
Attacks on outputs: As outlined earlier (§3), the primary targets
of active library learning and regeneration are (1) side-effectful
attacks—e.g., ones targeting the file system, global variables, the
module system, process arguments, or environment variables, (2)
attacks via low-level, memory-unsafe, and type-unsafe code such
as ones typical in C and C++ code. Could ALR additionally protect
against attacks targeting the output of a library function?
For attacks that target function outputs, there are two broad
possibilities. If the malicious behavior is hidden and therefore not
exposed during testing/normal use, Harp will not learn the mali-
cious behavior and thus the regenerated code will not contain the
corresponding vulnerability. If, however, the malicious behavior is
exposed during testing/normal use, Harp would either (1) deter-
mine that the observed behavior is outside the scope of the DSL
and reject the library, or (2) learn and regenerate the behavior. In
the latter case, Harp is relying on the exposure of the malicious
behavior during testing/normal use to detect and eliminate the
behavior—i.e., we would expect the behavior to be detected by the
developer during development and before deployment. We antici-
pate that, at least for string processing programs, almost all such
malicious behaviors will be outside the scope of the Harp DSL.
Generalizing ALR: Active learning and regeneration is a black-
box program inference approach that fixes (1) a specific computa-
tional domain (SCD) such as string processing, tensor operators,
database interfaces, (2) a corresponding language (DSL) for model-
ing computations in that domain, and (3) an input generation algo-
rithm (IGA) for interacting with the black-box computation. These
three elements are interlinked and are designed to complement
each other. For example, the DSL is designed to enable differential
testing, using the IGA to guide efficient inference—by inferring
the existence or absence of certain DSL terms in the regenerated
programs while minimizing ambiguity.
An active learning and regeneration system such as Harp is
an instantiation of these three elements (SCD, DSL, IGA) for a
particular domain. We do not expect a single system to be expanded
to capture all or even a large range of computation of interest. Such
an expansion can quickly result in general computations and thus
quickly hit known intractability limits.
Instead, we anticipate mul-
Applying ALR to further domains:
tiple active learning and regeneration systems, each targeting a
certain class of libraries. Harp exemplifies this approach for string
computations—a central, widely used class of computations. Other
classes of computation and associated DSLs include: arithmetic-
operation libraries, linear algebra and tensor operations, key-value
operations, spreadsheet-style computations, components that ac-
cess SQL databases, blockchain smart contracts, and stream-based
parallelizing combiners.
The technique has been applied successfully in some of these
domains—e.g., programs that access stateful key-value stores [50],
applications that access relational databases [56, 57], binary data
parsing and transformation [9], and synthesis of parallel Unix shell
commands [55]. Harp is the first active learning and regeneration
system to target security vulnerabilities in software supply chains.
10 CONCLUSION
Supply-chain attacks are becoming a critical security concern. This
paper presented a new approach, active library learning and re-
generation (ALR), to infer and regenerate the client-observable
functionality of a black-box, third-party software dependency. The
regenerated dependency leverages domain-specific modeling, in
which the target class of attacks cannot be expressed. We demon-
strate ALR in Harp, a prototype system for inferring and regener-
ating components that implement string computations.
ACKNOWLEDGMENTS
We thank Dimitris Karnikis, Grigoris Ntousakis, Kostis Sagonas, the par-
ticipants of 18th Athens PL Seminar, and our shepherd Sooel Son. This
research was funded in part by DARPA contracts HR00112020013 and
HR001120C0191.
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1767REFERENCES
[1] Pieter Agten, Steven Van Acker, Yoran Brondsema, Phu H. Phung, Lieven Desmet,
and Frank Piessens. 2012. JSand: Complete Client-side Sandboxing of Third-party
JavaScript Without Browser Modifications. In Proceedings of the 28th Annual
Computer Security Applications Conference (ACSAC ’12). ACM, New York, NY,
USA, 1–10. https://doi.org/10.1145/2420950.2420952
[2] Rajeev Alur, Rastislav Bodik, Garvit Juniwal, Milo MK Martin, Mukund
Raghothaman, Sanjit A Seshia, Rishabh Singh, Armando Solar-Lezama, Emina
Torlak, and Abhishek Udupa. 2013. Syntax-guided synthesis. In 2013 Formal
Methods in Computer-Aided Design. IEEE, 1–8.
Less is
[3] Babak Amin Azad, Pierre Laperdrix, and Nick Nikiforakis. 2019.
more: quantifying the security benefits of debloating web applications. In 28th
{USENIX} Security Symposium ({USENIX} Security 19). 1697–1714.
[4] Daniel J Bernstein, Bernard Van Gastel, Wesley Janssen, Tanja Lange, Peter
Schwabe, and Sjaak Smetsers. 2014. TweetNaCl: A crypto library in 100 tweets. In
International Conference on Cryptology and Information Security in Latin America.
Springer, 64–83. https://tweetnacl.cr.yp.to/
[5] Oscar Bolmsten. 2017. Malicious Package: crossenv and other 36 malicious
packages. https://snyk.io/vuln/npm:crossenv:20170802 Accessed: 2019-03-19.
[6] Benjamin Byholm, Rod Vagg, and NAN contributors. 2018. Native Abstractions
for Node. https://www.npmjs.com/package/nan Accessed: 2020-06-11.
[7] Mircea Cadariu, Eric Bouwers, Joost Visser, and Arie van Deursen. 2015. Tracking
known security vulnerabilities in proprietary software systems. In Software
Analysis, Evolution and Reengineering (SANER), 2015 IEEE 22nd International
Conference on. IEEE, 516–519.
[8] Stefano Calzavara, Michele Bugliesi, Silvia Crafa, and Enrico Steffinlongo. 2015.
Fine-Grained Detection of Privilege Escalation Attacks on Browser Extensions. In
Programming Languages and Systems - 24th European Symposium on Programming,
ESOP 2015, Held as Part of the European Joint Conferences on Theory and Practice
of Software, ETAPS 2015, London, UK, April 11-18, 2015. Proceedings (Lecture Notes
in Computer Science), Jan Vitek (Ed.), Vol. 9032. Springer, 510–534. https://doi.
org/10.1007/978-3-662-46669-8_21
[9] José P. Cambronero, Thurston H. Y. Dang, Nikos Vasilakis, Jiasi Shen, Jerry
Wu, and Martin C. Rinard. 2019. Active Learning for Software Engineering. In
Proceedings of the 2019 ACM SIGPLAN International Symposium on New Ideas,
New Paradigms, and Reflections on Programming and Software (Onward! 2019).
Association for Computing Machinery, New York, NY, USA, 62–78. https://doi.
org/10.1145/3359591.3359732
[10] David Bryant Copeland. 2019. The Frightening State of Security Around NPM
Package Management. https://bit.ly/3pID2h1 Accessed: 2020-12-10.
[11] Ruian Duan, Omar Alrawi, Ranjita Pai Kasturi, Ryan Elder, Brendan Saltaformag-
gio, and Wenke Lee. 2021. Towards Measuring Supply Chain Attacks on Package
Managers for Interpreted Languages. NDSS.
[12] Aurore Fass, Michael Backes, and Ben Stock. 2019. JStap: A Static Pre-Filter for
Malicious JavaScript Detection. In Proceedings of the 35th Annual Computer Secu-
rity Applications Conference (ACSAC ’19). Association for Computing Machinery,
New York, NY, USA, 257–269. https://doi.org/10.1145/3359789.3359813
[13] Aurore Fass, Robert P. Krawczyk, Michael Backes, and Ben Stock. 2018. JaSt: Fully
Syntactic Detection of Malicious (Obfuscated) JavaScript. In Detection of Intrusions
and Malware, and Vulnerability Assessment, Cristiano Giuffrida, Sébastien Bardin,
and Gregory Blanc (Eds.). Springer International Publishing, Cham, 303–325.
[14] Yu Feng, Ruben Martins, Yuepeng Wang, Isil Dillig, and Thomas W Reps. 2017.
Component-based synthesis for complex APIs. In Proceedings of the 44th ACM
SIGPLAN Symposium on Principles of Programming Languages. 599–612.
[15] John K Feser, Swarat Chaudhuri, and Isil Dillig. 2015. Synthesizing data structure
transformations from input-output examples. In ACM SIGPLAN Notices, Vol. 50.
ACM, 229–239.
[16] Joel Galenson, Philip Reames, Rastislav Bodik, Björn Hartmann, and Koushik
Sen. 2014. Codehint: Dynamic and interactive synthesis of code snippets. In
Proceedings of the 36th International Conference on Software Engineering. 653–663.
[17] Sumit Gulwani. 2011. Automating string processing in spreadsheets using input-
output examples. In ACM Sigplan Notices, Vol. 46. ACM, 317–330.