rough idea of the total overhead required for destroying
a sandbox.
Additionally, we measured the latency of the kill()
system call when executed by a sandboxed process. The
results are shown in Figure 8. For this experiment, we
so that
its sandbox allows sending signals to the receiving pro-
is placed in sand-
boxes nested at various depths. For instance, the value
3 on the horizontal axis represents the case in which
conﬁgured the sandbox of the sending process *
cess + , which has been placed within a separate sandbox.
The values represent latencies when *
the sandbox enclosing * has a parent and a grandpar-
case in which *
ent. Therefore, privilege checks occur at three separate
levels. The value 0 on the horizontal axis indicates the
is not inside a sandbox and therefore
no privilege checks occur. As the graph shows, a single
privilege check incurs approximately 5 microseconds of
overhead. When sandboxes are nested, additional privi-
)
.
c
e
s
(
y
c
n
e
a
L
t
)
(
l
l
i
k
16
14
12
10
8
6
4
2
0
0
1
2
3
4
5
6
7
8
Sandbox Nest Depth
Figure 8: Latency of kill() executed by sandboxed process
lege checks incur approximately 1 microsecond each.
Capabilities[1] are another alternative to sandboxes. A
capability has two primary characteristics:
5 Related Work
Access control lists (ACLs) are a commonly used mech-
anism for enhancing system security. They associate
detailed access rights with objects such as ﬁles. The
main difference between sandboxes and ACLs is that
they take opposite points of view. ACLs associate priv-
ileges with objects while sandboxes associate privileges
with subjects. The centralized location of the controls on
sandboxes makes the correctness of their settings easy to
verify. Sandboxes impose strict upper bounds on privi-
leges without depending on assumptions such as settings
of ﬁle permissions throughout the system. They permit
easy creation of customized protection domains without
having to change settings on a wide variety of system ob-
jects. However, our sandboxing mechanism is designed
to complement alternatives such as ACLs rather than re-
placing them. Sandboxes may be used in combination
with other mechanisms to implement policies not easily
enforceable using any single mechanism by itself.
 A subject that holds a capability is granted access
to the privilege it speciﬁes.
 A subject that lacks a capability is denied access to
the privilege it speciﬁes.
complete revocation of a capability 
requires revocation from both 
has been delegated by 
which 
A sandbox exhibits the second property but not the ﬁrst
one. This aspect of sandboxes allows their controls to be
safely manipulated by untrusted users. The centralized
location of the controls on a sandbox makes sandbox-
granted privileges easy to track and revoke. In contrast,
held by process
and all processes to
. The ability to create
nested sandboxes provides a mechanism for delegation
of privileges in a manner somewhat similar to delega-
tion of capabilities. Opening ﬁles represents an inter-
esting area of interaction between sandboxes and capa-
bilities, since a ﬁle descriptor may be viewed as a ca-
pability for accessing a ﬁle.
In our current design, a
sandbox cannot revoke a previously granted ﬁle access
m

privilege once the sandboxed process has obtained a ﬁle
descriptor. However, this limitation may be removed
by attaching sandbox-related tags to ﬁle descriptors and
performing additional privilege checks during read()
and write() system calls. Although this requires ex-
tra overhead, the creator of a sandbox could be given the
option of disabling the feature to increase performance.
not be used with setuid programs. It also has substan-
tial overhead because the monitoring agent is a separate
process and interprocess context switches are therefore
required for monitoring. Furthermore, the monitoring
process must fork() each time the sandboxed process
forks. The fact that the monitoring agent runs in user
space may also create vulnerabilities.
Domain and type enforcement (DTE)[2, 3] is a useful
tool for implementing mandatory access controls. This
technique groups subjects into domains and objects into
types. Rules are provided that specify which domains
are granted access to which types. In addition, the sys-
tem may be conﬁgured so that execution of certain pro-
grams causes transitions between domains. A major dif-
ference between DTE and our sandboxing mechanism
is that DTE is geared toward implementing systemwide
mandatory access controls. A trusted security adminis-
trator deﬁnes the domains and types, along with the rules
governing their interactions. In contrast, sandboxes are
lightweight entities that may be created, conﬁgured, and
destroyed by untrusted users. Our implementation al-
lows them to enforce either mandatory or discretionary
access controls. We plan on extending their functionality
by allowing transitions between sandboxes when certain
programs are executed.
A variety of sandboxing techniques have been previ-
ously implemented. One approach is to build protec-
tion mechanisms into programming languages such as
Java[7]. Since this option ties the sandbox to a particu-
lar language or runtime environment, it is not suitable as
a general-purpose mechanism. However, it is still useful
as a special-purpose technique, since security policies
may be tailored to the language or runtime environment.
Alternately, the sandbox may be embedded within the
sandboxed program. Proof-carrying code[8] is one ex-
ample of this type of approach. Another option is to
instrument an existing binary with additional machine
instructions that verify compliance with a security pol-
icy as a program executes[9]. However, these alterna-
tives are inconvenient because they require modiﬁcation
of binaries. Furthermore, they are not useful as general-
purpose techniques since they do not apply to all types
of programs (such as shell scripts, for instance).
A sandboxing system known as Janus[10], along with
two similar mechanisms[11, 12], employs user-space
monitoring processes for interception of system calls
made by sandboxed programs. The monitoring pro-
cesses use the /proc process tracing facility of Solaris
for system call interception. This approach limits the
scope of applicability of these techniques, since it may
To overcome the limitations of user-space mechanisms,
sandboxes may be implemented as loadable kernel
modules[14, 15]. Placing sandboxes inside the kernel
may enhance their security by providing increased iso-
lation from potentially malicious entities. Since kernel-
based sandboxes may be implemented as passive enti-
ties, context switching overhead is not required for priv-
ilege checking. A disadvantage of this approach is that
creating a new sandbox requires loading a kernel mod-
ule. The module must be fully trusted, and a trusted user
must perform the module loading operation.
A design known as ChakraVyuha (CV)[16] implements
a kernel-based sandboxing mechanism. In this system,
sandboxes for individual applications are deﬁned using
a domain-speciﬁc language. Sandbox deﬁnitions are
stored in a secure location somewhere in the ﬁle system.
When a given program is executed, its sandbox deﬁni-
tion is passed to a kernel-resident enforcer. This entity
enforces restrictions by matching system call parameters
against the sandbox deﬁnition. Therefore, problems as-
sociated with implementing sandboxes as loadable ker-
nel modules are avoided.
One difference between ChakraVyuha and our design is
the level at which its external interfaces are speciﬁed.
To conﬁne a program with ChakraVyuha, it must ﬁrst be
installed using a specialized installer program. The in-
staller generates a conﬁguration ﬁle that speciﬁes a de-
fault sandbox for the new program. If users wish to cre-
ate customized sandboxes, they must do so using conﬁg-
uration ﬁles that follow a speciﬁc format. Our external
interface is at a much lower level. We export a general-
purpose system call API that application programs may
use for their own purposes. This approach widens the
scope of applicability of our design.
A second advantage of our model is the ability to
dynamically reconﬁgure sandboxes at runtime. With
ChakraVyuha, users may customize sandboxes, but the
sandboxes are ﬁxed once the sandboxed programs start
executing. Other advantages of our model include nested
sandboxes and our treatment of privilege sets as ﬁrst
class objects that may be manipulated using set-theoretic
primitives.
Another solution, known as WindowBox[13], imple-
ments a sandboxing mechanism within the Windows NT
kernel. The emphasis here is on providing an easy to
use mechanism that is simple enough for unsophisticated
users. The design consists of a set of desktops that are
completely separated from each other and from the rest
of the system. Users can give some desktops more priv-
ileges than others. As a user’s level of trust increases,
a program may be gradually moved to more privileged
desktops. However, the desktops are relatively static en-
tities. They are not designed to function as lightweight
containers for individual programs.
Finally, a sandboxing mechanism somewhat similar
to ours has been added to the ULTRIX operating
system[17]. This mechanism, known as TRON, is simi-
lar to our design in some ways but more limited in scope,
since it only deals with ﬁle-related privileges. Like our
sandboxing mechanism, TRON allows creation of sand-
boxes by untrusted users. However, it does not provide
a blocking mechanism for interactive privilege determi-
nation at runtime.
TRON does allow nesting of sandboxes, although this
feature behaves differently from our design. When sand-
boxes are nested, our mechanism performs privilege
checks at each level individually. However, TRON ver-
iﬁes at creation time that a nested sandbox contains a
subset of its parent’s privileges. It then checks privileges
against only the innermost sandbox. Although TRON’s
approach reduces performance overhead, we chose our
method for two reasons. First of all, our design allows
changes in a sandbox conﬁguration to affect all sand-
boxes nested below it. This behavior is necessary for
interactive manipulation of sandboxes to function prop-
erly when sandboxes are nested. Secondly, our design
allows a sandboxed process to create a nested sandbox
without any awareness of how its own sandbox is conﬁg-
ured. The child sandbox is not cluttered with restrictions
imposed by its parent and therefore maintains a precise
representation of the policies its creator wishes to en-
force. Furthermore, restrictions imposed by the parent
sandbox may be kept secret from its inhabitants.
The method that TRON employs for specifying access
controls is less expressive than our ﬁle system compo-
nent. When privileges are assigned to a directory, they
automatically extend to all ﬁles it contains.
It is not
possible to grant privileges only for the directory with-
out extending them to all of its ﬁles. However, a sub-
tree option does exist that is equivalent to the union of
self, children, and grandchild subtrees in our ﬁle sys-
tem component. One feature that TRON omits is the
ability to speciﬁcally deny access to ﬁles. It is therefore
not powerful enough to support composition of privilege
sets through union, intersection, and complement opera-
tions.
6 Conclusions
In summary, we have presented a general-purpose sys-
tem call API for conﬁnement of untrusted programs. We
have described our design within the context of a sys-
tematic exploration of the design space for conﬁnement
mechanisms. Our approach is distinguished by its ﬂex-
ibility and provision of a relatively simple set of primi-
tives that permit a wide scope of applicability. Prelimi-
nary performance results are encouraging, although we
still need to perform more extensive testing.
Availability
the time of
At
this writing, we are still ﬁnish-
ing the implementation of the sandboxing API. The
latest version of
the code may be obtained from
http://seclab.cs.ucdavis.edu/projects/sandbox.html. As
our work progresses, we will make updates available at
this location.
References
[1] Dennis, J., and VanHorn, E. Programming seman-
tics for multiprogrammed computations. Commu-
nications of the ACM, 9:143–155, Mar. 1966.
[2] Walker, K., Sterne, D., Badger, L., Petkac,
M., Shermann, D., and Oostendorp, K. Conﬁning
root programs with domain and type enforcement
(DTE). In Proceedings of the Sixth USENIX Secu-
rity Symposium, Jul. 1996.
[3] Security-enhanced linux
http://www.nsa.gov/selinux/.
.
[4] Saltzer, J., and Schroeder, M. The protection of
information in computer systems. Proceedings of
the IEEE, 63(9):1278–1308, Sep. 1975.
[5] Chang, F., Itzkovitz, A., and Karamcheti, V. User-
level resource-constrained sandboxing.
In Pro-
ceedings of the 4th USENIX Windows Systems
Symposium, Aug. 2000.
[6] Lal, M., and Pandey, R. A scheduling scheme for
controlling allocation of cpu resources for mobile
programs. Autonomous Agents and Multi-Agent
Systems, 5(1):7–43, Mar. 2002.
[17] Berman, A., Bourassa, V., and Selberg, E. TRON:
Process-speciﬁc ﬁle protection for the UNIX oper-
ating system. In Proceedings of the 1995 Winter
USENIX Conference, Jan. 1995.
[7] Gong, L., Mueller, M., Prafullchandra, H., and
Schemers, R. Going beyond the sandbox: An
overview of the new security architecture in the
java development kit 1.2.
In Proceedings of the
USENIX Symposium on Internet Technologies and
Systems, Dec. 1997.
[8] Necula, G., and Lee, P. Safe kernel extensions
without run-time checking. In Proceedings of the
USENIX 2nd Symposium on Operating Systems
Design and Implementation, Oct. 1996.
[9] Small, C. A tool for constructing safe extensible
C++ systems. In Proceedings of the Third USENIX
Conference on Object-Oriented Technologies and
Systems, Jun. 1997.
[10] Goldberg, I., Wagner, D., Thomas, R., and Brewer,
E. A secure environment for untrusted helper ap-
plications (conﬁning the wily hacker). In Proceed-
ings of the Sixth USENIX Security Symposium, Jul.
1996.
[11] Acharya, A., and Raje, M. MAPbox: Using param-
eterized behavior classes to conﬁne applications.
In Proceedings of the 9th USENIX Security Sym-
posium, Aug. 2000.
[12] Alexandrov, A., Kmiec, P.,
Conﬁned
internet
and Schauser,
execution
en-
K.
vironment
computations.
http://www.cs.ucsb.edu/˜berto/papers/99-usenix-
consh.ps.
Consh:
for
[13] Balfanz, D., and Simon, D. WindowBox: A sim-
ple security model for the connected desktop. In
Proceedings of the 4th USENIX Windows Systems
Symposium, Aug. 2000.
[14] Fraser, T., Badger, L., and Feldman, M. Hardening
COTS software with generic software wrappers. In
Proceedings of the 1999 IEEE Symposium on Secu-
rity and Privacy, May 1999.
[15] Mitchem, T., Lu, R., and O’Brien, R. Using kernel
hypervisors to secure applications. In Proceedings,
13th Annual Computer Security Applications Con-
ference, Dec. 1997.
[16] Dan, A., Mohindra, A., Ramaswami, R., and
Sitaram, D. Chakravyuha (CV): A sandbox oper-
ating system environment for controlled execution
of alien code. Technical Report 20742, IBM T.J.
Watson Research Center, 1997.