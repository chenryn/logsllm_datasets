the set of readers may result in unintended declassiﬁcation
of secrets. In light of these observations, we must weaken
our speciﬁcation of secrecy.
Deﬁnition 4.3 (Secrecy). Secrecy is preserved in Plutus if,
for all g and v, any secret m written by an honest writer for
g using keys for v is leaked only if a reader or writer for g
is corrupt at some v0 ≥ v, i.e., the process modeling Plutus
satisﬁes the correspondence
puts(w, m, g, v) ∧ attacker(m)  
v0 ≥ v ∧ corrupt(a, g, v0)
∧ (isreader(a, g, v0) ∨ iswriter(a, g, v0))
(1)
This weaker property is proved as follows.
Theorem 4.4. Secrecy is preserved in Plutus.
Proof. Let m[g = G, v = V ] denote the name m created
in line 49 when the variables g and v in lines 45 and 47
are bound to the terms G and V , respectively. (This nota-
tion can be used directly in ProVerif, exploiting ProVerif’s
internal representation of bound names by patterns. It is de-
tailed and justiﬁed in [14].) ProVerif automatically proves
the following correspondence:
attacker(m[g = xg, v = xv])  
v0 ≥ xv ∧ corrupt(a, xg, v0)
∧ (isreader(a, xg, v0) ∨ iswriter(a, xg, v0))
(2)
By the semantics of the input language, for any terms
W , M, G, and V , if puts(W, M, G, V ) is executed, then
M = m[g = G, v = V ]. Thus, for all substitutions σ, if a
trace T satisﬁes σputs(w, xm, xg, xv) and σattacker(xm),
then σxm = σm[g = xg, v = xv]; so T satisﬁes
σattacker(m[g = xg, v = xv]); so by correspondence (2),
T satisﬁes σ0(v0 ≥ xv∧corrupt(a, xg, v0)∧(isreader(a, xg,
v0) ∨ iswriter(a, xg, v0))) for some substitution σ0 such that
σ0xg = σxg and σ0xv = σxv. Hence, correspondence (1)
is satisﬁed.
Next, we specify an integrity property. Speciﬁcally, we
are interested in the integrity of some data x read by an
honest reader r for group g using keys for version v. We
expect x to come from the adversary if a dishonest writer
for g at v colludes with the adversary at v; otherwise, we
expect x to be written by an honest writer w for g using
keys for version v. Moreover, such w must be a writer for g
at v.
Deﬁnition 4.5 (Integrity). Integrity is preserved in Plutus
if for all g and v, any data x read by an honest reader for
g using keys for v is written by an honest writer for g us-
ing keys for v unless a writer for g is corrupt at v, i.e., the
process modeling Plutus satisﬁes the correspondence
gets(r, x, g, v)  
iswriter(w, g, v)
∧ (puts(w, x, g, v) ∨ corrupt(w, g, v))
(3)
Unfortunately, when we try to show that integrity is pre-
served in Plutus, ProVerif cannot prove the required corre-
spondence for this model. Manual inspection of the deriva-
tion output by ProVerif reveals an attack, where the adver-
sary is able to send data to an honest reader for group g at
version 0 without corrupting a writer for g at 0.
Theorem 4.6. Integrity is not preserved in Plutus, i.e., the
correspondence (3) is not satisﬁed.
Proof. When ProVerif is given the query (3), it cannot
prove this query, and outputs a derivation of gets(r, m,
g, 0) from facts that do not include puts(w, m, g, 0) or
corrupt(w, g, 0) for any w; we manually check that this
derivation corresponds to an attack. Brieﬂy, a reader for
g is corrupted at version 0 and a writer for g is corrupted at
version 1; the adversary then constructs a bogus write key
for version 0 and writes content that can be read by r using
the read key for version 0. In more detail:
1. A reader for group g is corrupted at version 0 to get the
lockbox key lk0 for version 0.
2. Next, a writer for g is corrupted at version 1 to get the
lockbox key lk1, the sign key (d(s1, lk1), N(s1)), and
the owner-signed modulus sn1 = exp(hash(N(s1)),
ownerprivkey) for version 1 (where s1 is the RSA
seed for version 1 and ownerprivkey is the private key
of the owner).
3. The exponent e(s1, lk 1) is computed as genExp(N(s1),
lk1).
4. Next, the RSA seed s1 is computed as crack(e(s1,
lk1), d(s1, lk1), N(s1)).
5. Now a bogus sign key sk0 is constructed as (d(s1, lk0),
N(s1)).
6. Choosing some fresh data m, the following content is
then sent to the ﬁle system, where M = enc(m, lk0):
(g, 0, sn1, N(s1), M, exp(hash(M), sk0))
Theorem 4.7. Integrity is preserved in Plutus with ﬁx F.
Proof. Under the given conditions, ProVerif automatically
proves the correspondence (3).
7. An honest reader r for g reads m using keys for version
0, without detecting that the modulus in the sign key is
in fact not the correct one!
Note that corrupting a reader for g at version 0 to obtain lk0
is not a necessary step in the above attack; the adversary can
instead compute lk0 from lk1 by unwinding. Orthogonally,
the adversary can collude with a writer for a different group
at version 0, instead of corrupting a writer for group g at
version 1. In each case, a bogus sign key for the target group
and version may be constructed from an unrelated modulus
because the correct group and version of that modulus is not
veriﬁed in this model.
The above attack can have serious consequences, since
it implies that a writer for an arbitrary group can act as
a legitimate writer for a target group simply by colluding
with a reader for that group. Here, we consider a model
without server-veriﬁed writes, that is, we assume that the
server is compromised and colludes with the adversary. As
argued in [28, 34], server compromise is a realistic possi-
bility, so the above attack can be quite damaging. Worse,
integrity is not preserved even in a model extended with
server-veriﬁed writes. However with server-veriﬁed writes,
the consequences are less serious—in order to write data for
a group, the adversary needs to obtain the current write to-
ken for that group, for which it needs to corrupt a current
writer for that group. Still, the attack has the same undesir-
able effect as allowing rotation of write keys. Speciﬁcally,
it allows a corrupt writer at a later version to modify data
in such a way that readers date the modiﬁed data back to an
earlier version; in other words, the modiﬁed data appears to
be older than it actually is to readers. This situation can be
dangerous. Suppose that a reader trusts all writers at ver-
sion 0, but not some writer at version 1 (say because the
corruption of that writer at version 1 has been detected and
communicated to the reader). The reader may still trust data
written at version 0. However, the above attack shows that
such data cannot be trusted: that data may in fact come from
a corrupt writer at version 1.
We propose a simple ﬁx F to correct the protocol: owners
must sign each modulus with its correct group and version.
More concretely, the term bound to sn at line 38 of the code
for owners must be exp(hash(n, g, v), ownerprivkey), and
conversely, line 68 of the code for readers must check
that hash(n, g, v) = exp(sn, ownerpubkey). The corrected
model preserves integrity as shown by Theorem 4.7 below.
(Moreover, Theorem 4.4 continues to hold for the corrected
model, with an unchanged proof.)
While Deﬁnition 4.5 restricts the source of data read by
honest readers, it still allows the adversary to replay stale
data from a cache; in particular, content written by a writer
at version v may be cached and replayed by the adversary
at a later version v0, when that writer is revoked. Unfortu-
nately, in the model above we cannot associate contents that
are read from the ﬁle system with the versions at which they
are written to the ﬁle system. Such associations are possible
only if the ﬁle system is (at least partially) trusted, as with
server-veriﬁed writes.
The code for the extended model
Below we specify a stronger integrity property that we
expect to hold in a model extended with server-veriﬁed
writes; the property not only restricts the source of data
read by honest readers, but also requires that such data
be fresh.
is avail-
able online at http://www.soe.ucsc.edu/∼avik/
projects/plutus/. Brieﬂy, we deﬁne a process to
model the storage server, and extend the code for owners
so that for any group g, a new write token is created for
each version v, communicated to the server, and distributed
to writers for g at v. Corrupt writers leak their write tokens.
A writer must send contents to the server with a token; the
contents are written to the ﬁle system only if that token is
veriﬁed by the server to be the write token for the current
version. Honest readers securely obtain server-veriﬁed con-
tents from the server. (Of course, those contents are also
publicly available from the server.) To verify the stronger
integrity property, we replace the event gets(r, x, g, vx) in
the code for readers (line 74) with a more precise event
gets(r, x, g, vx, v0). The latter event subsumes the former,
and further asserts that the relevant contents are written to
the ﬁle system after server-veriﬁcation at v0. We expect that
v0 = vx, where vx is the version of keys used to read those
contents, unless a writer for g is corrupt at v0; in the latter
case, the adversary is able to replay at v0 data that is origi-
nally written using keys for vx, so we may have v0 ≥ vx.
Deﬁnition 4.8 (Strong integrity). Strong integrity is pre-
served in Plutus if for all g and v, any data x read by an
honest reader for g using keys for v is written by an honest
writer for g using keys for v, unless a writer for g is corrupt
at v; and further, such data is written either at v or at some
version v0 ≥ v at which a writer is corrupt, i.e., the process
modeling Plutus satisﬁes the correspondence
gets(r, x, g, v, v0)  
iswriter(w, g, v)
∧ (puts(w, x, g, v) ∨ corrupt(w, g, v))
∧ (v0 = v ∨ (v0 ≥ v ∧
iswriter(w0, g, v0) ∧ corrupt(w0, g, v0)))
(4)
maxrev
Without server-veriﬁed writes
With server-veriﬁed writes
Without ﬁx F
1
0:01
0:05
With ﬁx F
3
4
0:05
1:19
0:14
7:14
2
0:02
0:17
1
0:01
0:03
5
0:40
42:05
Figure 4. Running times of ProVerif
The corrected, extended model preserves strong in-
tegrity, as expected. Once again, the proof is automatic.
Theorem 4.9. Strong integrity is preserved in Plutus with
server-veriﬁed writes and ﬁx F.
Proof. Under the given conditions, ProVerif automatically
proves the correspondence (4).
Further, we show (using a correspondence omitted here)
the correctness of server-veriﬁed writes: for any group g,
only writers for g at the current version v can write data for
g at v. (Such writes must be authorized by the current write
token for g, which is distributed only to the current writers
for g.) Consequently, server-veriﬁed writes prevent at least
two kinds of attacks:
• Unauthorized writers cannot destroy data by writing
unreadable junk over such data.
• Revoked writers cannot roll back new data by writing
data with old keys over such data.
Running times of ProVerif Figure 4 presents the running
times of ProVerif 1.14pl4 for the scripts above, in “min-
utes:seconds” format, on a 2.6 GHz AMD machine with
8 GB memory. We test models with or without ﬁx F, and
with or without server-veriﬁed writes. We already ﬁnd at-
tacks assuming maxrev = 1 for models without ﬁx F.
On the other hand, models with ﬁx F are tested assuming
maxrev ≤ 5, so our security proofs apply only to those
models (although we expect them to hold with larger val-
ues of maxrev as well). Memory usage increases signif-
icantly with server-veriﬁed writes; for example, the script
with maxrev = 5, ﬁx F, and server-veriﬁed writes takes
around 2.2 GB of memory. For maxrev = 6, ProVerif runs
out of memory on this 8 GB machine.
4.3. Analysis of some design details
Next, using ProVerif, we clarify some design details of
Plutus.
4.3.1. Why should a new modulus be created for each
version?
The following explanation is offered by [32]:
the reason for changing the modulus after
. . .
every revocation is to thwart a subtle collusion
attack . . . a revoked writer can collude with a
reader to become a valid writer . . .
We formalize this attack as a violation of integrity in Plutus:
if the modulus for version 1 is the same as that for version
0, the adversary is able to send data to an honest reader for
group g at version 1 without corrupting a writer for g at 1.
We manually reconstruct the attack.
1. A writer for g is corrupted at version 0, and a reader for
g is corrupted at version 1. Thus the adversary obtains
the lockbox key lk0 and sign key (d0, n) for version 0,
and the lockbox key lk1 for version 1. We may assume
that the writer corrupted at 0 is revoked at 1. Let there
be another writer for g at version 1 that publishes some
content, so that the adversary also knows the owner-
signed header sn1 for version 1.
2. The adversary computes the exponent e0 = genExp(n,
lk0), the RSA seed s = crack(e0, d0, n), and the sign
key sk1 = (d(s, lk1), N(s)) for version 1. (Since the
modulus n is unchanged, the RSA seed s is the same
for versions 0 and 1.) Finally, choosing some fresh
data m the adversary sends the following content to
the ﬁle system, where M = enc(m, lk1):
(g, 1, sn1, n, M, exp(hash(M), sk1))
3. An honest reader for g reads m using keys for ver-
sion 1.
However, we have two comments on this attack:
• With server-veriﬁed writes, the sentence of [32] quoted
above is not quite true:
in order to become a valid
writer, one additionally needs to obtain a write token
at some version v ≥ 1, which can be done only by
corrupting a writer at some version v ≥ 1.
• But by corrupting a writer at version v ≥ 1, the ad-
versary can mount a much simpler attack. Indeed, the
adversary can compute the RSA seed s and all keys for
version 1 from the keys for such v—without corrupt-
ing a writer at version 0 or a reader at version 1. We
reconstruct a simple attack along these lines by mod-
ifying the ProVerif script so that the modulus is not
changed between versions and inspecting the deriva-
tion output by ProVerif. Here the adversary is able to
send data to an honest reader for group g at version 0
without corrupting a writer for g at 0.
1. A writer for g is corrupted at version 1. Thus
the adversary obtains the lockbox key lk1, and
the sign key (d1, n) for version 1. Let there be
another writer for g at version 0 that publishes
some content, so that the adversary also knows
the owner-signed header sn0 for version 0.
2. The adversary computes the lockbox key lk0 by
unwinding lk1, the exponent e1 = genExp(n,
lk1), the RSA seed s = crack(e1, d1, n), and the
sign key sk0 = (d(s, lk0), N(s)) for version 0.
Finally, choosing some fresh data m the adver-
sary sends the following content to the ﬁle sys-
tem, where M = enc(m, lk0):
(g, 0, sn0, n, M, exp(hash(M), sk0))