titleblackhat:eu-21 Lost in the Loader: The Many Faces of the Windows PE File Format
This Briefing presents our research on parser differentials for the PE format. We defined a custom language to write "formal models" of various PE loaders, for different versions of Windows and reverse-engineering tools. We then built a framework that, using these models, can perform a number of analyses that aid reverse-engineering tasks.First, given a PE executable, it can determine whether a PE loader would consider it valid. This feature provides a filtering stage for dynamic malware analysis, as it can identify broken samples before running them in sandboxes. Our framework is also able to automatically generate SMT models of the various PE loaders, and it can automatically perform several powerful tasks: given a PE loader, generate a valid executable that can be loaded by it; or, it can perform "differential analysis" and automatically generate PE files that are valid for one PE loader but not for another one. This makes our framework powerful enough to perform complex tasks like "creating valid executables that reverse-engineering tools/AVs cannot correctly parse/consider invalid", thus bypassing them. Our framework can also *systematically* explore differences among various PE loaders, and it can perform "differences enumeration" and "corner-cases generation".We wrote models for the loaders Windows XP, 7, and 10, radare2, ClamAV, and yara (which we'll publicly release, alongside the framework). Surprisingly, we discovered that they all handle the PE format differently. We also performed a live hunt on VirusTotal, and we identified malware samples that actively employ these discrepancies, likely to bypass AV products.Finally, we conclude by pointing out that there is no one "correct way to parse an executable," and that analysis tools should start allowing users to select "which loader to simulate" when loading a binary.