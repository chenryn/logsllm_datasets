Store categories (with some failures in collection) and in total
analyzed 1308 apps to identify statistics regarding the use of
custom permissions. As can be seen in Table I, 65% of the
apps in our dataset declare custom permissions (statically or
dynamically) and 70% of them request custom permissions.
Additionally, 89% of all the permissions created by these apps
are of protection level signature (see Table II), which indicates
3
TABLE I: Apps at risk due to custom permissions
Usage
Create Static Custom Permissions
Create Dynamic Custom Permissions
Create Custom Permissions
Request Third-party Permissions
Total number of apps in dataset
Number of Apps
834 (64%)
50 (3%)
847 (65%)
919 (70%)
1308 (100%)
TABLE II: Protection Levels of Custom Permissions
Permission Protection Level
Signature Permissions
Dangerous Permissions
Normal Permissions
Signature or System Permissions
Total Number of Permissions
Number of Permissions
1203 (89%)
14 (1%)
40 (2%)
57 (4%)
1350 (100%)
that app developers typically use custom permissions to allow
other apps to utilize their protected components only if they
are signed by the same developer or company.
This analysis shows that custom permissions are commonly
utilized by app developers. Vulnerabilities in their use create
risks for the security of the platform and key apps. To
illustrate this we have identiﬁed ways we can launch attacks
on the platform to obtain any system resource (e.g., camera,
microphone) without user consent and on apps to stealthily
access their protected components and data. Apps that utilize
custom permissions are potentially susceptible to the attacks
that target their protected components when they are installed
on Android 6.0 or newer. This currently includes more than
50% of all Android devices [3] with a growing user base. This
is a widespread security concern: just the apps in our dataset
have been downloaded on average 25 million times.
B. Case Studies
In this section, we present case studies where sensitive data or
resources of popular Android apps have been leaked through
the custom permission vulnerabilities. In order to obtain the
vulnerable components that leak resources, we conduct manual
analysis which requires going through the decompiled applica-
tion code and crafting attacks speciﬁcally for the app in study.
As an example, to attack a vulnerable activity component,
we go through the decompiled code to ﬁnd the Java ﬁle for
the activity itself and if it is not obfuscated, we proceed to
inspect the source code to identify whether the intent it expects
is of a particular format. Finally, using this information, we
create attack apps that exploit the existing custom permission
vulnerabilities and stealthily activate the component of interest
with the appropriate intent. We will explain the details of how
this attack works in Section IV-B.
CareZone is a medical Android app produced by a com-
pany with the same name. It has 1,000,000+ downloads and
has a 4+ rating on the Google Play Store. The app allows
users to store medical-related information such as health
background (e.g., blood type, medical conditions, allergies
etc.), medication lists, medical contacts and their addresses,
calendar events, insurance information, and photos or health
ﬁles in an organized manner. It also features calendars to
track appointments as well as to-do and notiﬁcation lists for
tracking tasks. All of this medical data and meta-data is stored
in a single content provider which has been exported and
4
is protected by a signature permission. There are no other
dynamic checks on accessing the content provider. Our attack
is able to bypass the signature requirements and read the entire
content provider, which gives us access to the aforementioned
sensitive data without the user’s explicit consent or knowledge.
The fact that all this data was stored in a single content
provider seems to reﬂect the developer’s implicit reliance on
the security guarantees provided by the platform.
Skype is an Android app by Microsoft that allows users
to make voice and video calls over the Internet. It has
500,000,000+ downloads and a 4+ rating. Skype has an activity
which can be invoked to start the call functionality to any
telephone number. This activity is protected using a signature
permission which, once bypassed, would allow the adversary
to invoke calls to a speciﬁed person or number. This could
have many implications. For example, it could be used as part
of a suite of other spying capabilities. Our attack is able to
spoof the original permission and launch Skype calls without
the user’s knowledge through this protected activity.
IV. ATTACKS
Custom permissions play an important role in enabling re-
usability on the Android platform by providing security to
IPC; hence, any threat to their proper operation can result in
the compromise of the security of the apps and the platform
itself. In this section, we discuss two types of custom per-
mission vulnerabilities we identiﬁed on Android: 1) custom
permission upgrade and 2) confused deputy. By exploiting
these vulnerabilities, an app can bypass user consent screens
for granting/denying permissions to obtain high-risk system
resources and can also gain unauthorized access to protected
components of other apps. We reported these to Google which
acknowledged both of them as severe vulnerabilities. Given its
real-world implications and its prevalence, we believe that the
predicament of custom permissions constitutes a current and
notable security risk worth addressing.
Threat Model. We consider an adversary that has the ability to
crawl app markets (e.g., Google Play Store) to download vic-
tim apps of interest, reverse engineer them by utilizing several
tools [7], [12], [10], and analyze the Android manifest ﬁles and
source code of these apps to observe the cases where custom
permissions are used to protect app components. The adversary
can build and distribute on app markets a set of malicious apps
that exploit the custom permission vulnerabilities of Android
to launch attacks on the victim apps and on the platform.
A. Custom Permission Upgrade Attack
Android runtime permission model (supported by Android
6.0 and onward) requires user’s approval for granting apps per-
missions of protection level dangerous. This attack enables
a malicious app to completely bypass the user consent screen
and automatically obtain any dangerous system permissions
[15].
In particular,
there are 24 dangerous permissions in 9
permission groups [2] on the current version of the Android
platform (7.0), which protect access to high-risk system re-
sources (e.g., storage, contacts, location, camera, microphone,
sms, sensors etc.). Our attack illustrates how an adversary can
gain unfettered access to all high-risk system resources that
are protected by these permissions without the user’s consent.
the protection level
Attack Overview. First, the adversary creates an app that
includes in its manifest ﬁle a custom permission declaration
with the protection level normal or signature and sets this
custom permission to be a part of a system permission group
(e.g., storage, camera etc.). Then, they update the deﬁnition
of this custom permission so that
is
changed to dangerous and proceed to push an update to
their app on the respective app market. Here, this update can
be pushed to all the app users after the app reaches a target
user base. In addition, speciﬁc user groups can be targeted
via the use of push services (e.g., Google Cloud Messaging
(GCM) [11], which is used by 94% of the apps in our database
that utilize custom permissions) that allow sending update
notiﬁcations, and via enterprise app stores (e.g., Appaloosa
[18]) that enable enforced targeted updates. The expectation is
that since the custom permission is of level dangerous, the
user will be prompted at runtime to make a decision on whether
to grant or deny this permission in the runtime permission
model. However, the malicious app automatically gets granted
the permission. In addition, since the runtime permission
model grants dangerous permissions on a group basis, the app
also automatically obtains all the other requested dangerous
permissions of the system permission group that the original
permission belongs to. Same procedure can be followed to
attack any system permissions group; hence, the adversary can
silently obtain all system permissions simultaneously. Request-
ing dangerous permissions in the Android manifest constitutes
no problems for the adversary, as permission requirements of
an app are not directly presented to users at installation since
Android 6.0. Hence, the user will be completely unaware that
all these system permissions are granted to the app.
the Attack. Android does not
Internals of
treat custom
permissions any differently than system permissions. As we
will describe in more detail
in Section VI-B, granting of
any permission is handled according to the permission’s
protection level and the SDK level of the requesting app
on the runtime model. Normal and signature permissions
are always granted as install time permissions. For legacy
apps (SDK level <23), dangerous permissions are still install
time permissions; whereas for new apps they are granted at
runtime. In case a legacy app gets upgraded to SDK level 23
or more, the system also “upgrades” the granted dangerous
permissions from install
time to runtime permissions and
automatically grants them if they were not manually revoked
by the user through the permission settings (indicated by the
FLAG PERMISSION REVOKE ON UPGRADE ﬂag being
set for the permission). However, the system does not consider
other cases where a change in the deﬁnition of a permission can
mistakenly trigger the same permission upgrade operation. In
the case of our attack, when a custom permission declaration
is modiﬁed by an app update such that the protection level
changes from normal or signature to dangerous, the system
wrongfully treats this case as an app upgrade, and tries to also
upgrade the existing permission to a runtime permission even
though the update operation did not change the app’s SDK
level. Since Android does not allow users to revoke normal or
signature permissions, the aforementioned ﬂag will never be
set for the existing install permission. Hence, the dangerous
permission will be granted automatically without any user
consent. Evidently, this violates a key security principle that
should always hold in the Android runtime permission model:
no dangerous runtime permission should be granted without
user interaction.
Note that, the problem here is that the system does not
consider the special cases that can happen in the case of
custom permissions. If a system permission is being upgraded
from an install to a runtime permission for an app, this can
only mean that the app is being upgraded to SDK level 23
or more. However, when a custom permission is upgraded for
an app, this can indicate either that the legacy app is being
upgraded, or that the permission deﬁnition is being changed
from normal or signature to dangerous. Currently, the system
is not equipped with the ability to distinguish between these
two cases for custom permissions as it cannot even distinguish
system permissions from custom permissions. To make things
worse, the system allows a third party developer to declare a
custom permission as a part of a system permission group.
Thus, the adversary can not only get a dangerous custom
permission silently granted, but they can further get access
to all system dangerous permissions in the same group with
any granted dangerous custom permission.
B. Confused Deputy Attack
its components [13]. To do this,
In this attack, the adversary exploits the lack of naming
conventions for custom permissions on Android to launch
an attack on a victim app that utilizes custom permissions
to protect
the adversary
counterfeits the custom permissions of the victim app by
reusing their names in her own permission declarations and
takes advantage of the system’s inability to track the true origin
of permissions to access protected components of the victim
app.
Attack Overview. In this attack, the adversary’s goal is to get
the operating system to grant their apps a signature custom
permission of a victim app that is signed by a different key than
that of the adversary and therefore obtain unauthorized access
to the components protected by this signature permission.
In order to achieve this, the adversary develops two applica-
tions: 1) a deﬁner attack app which spoofs the custom permis-
sion of the the victim app by reusing the same permission name
but changing the protection level to dangerous, 2) a user
attack app which only requests this permission in its manifest
ﬁle. The reason adversary needs two apps to carry out this
particular attack is that Android currently does not allow two
applications that declare a custom permission with the same
name to coexist on the same device. Hence, the adversary’s
app cannot simultaneously exist on the device along with the
victim app if it declares a permission with the same name to
the one used by the victim. However, the adversary can divide
their attack into two different apps, one that spoofs the custom
permission as long as the victim app is not installed on the
device, and a second one that only requests this permission and
is able to coexist with the victim. The deﬁner attack app needs
to be installed ﬁrst by the user, and this should be followed
by the installation of the user attack app. After the spoofed
permission of the deﬁner attack app is granted to the user
attack app at runtime, the deﬁner attack app can be uninstalled
5
by the user or updated by the app developer (for all users or
targeted to a speciﬁc group by using services like GCM or
Appaloosa) to remove the custom permission deﬁnition so that
the victim can be installed afterwards. After the installation of
the victim app, the user attack app is able to launch an attack
on the victim to freely access victim’s signature-protected
components even though it is not signed with the same app
certiﬁcate as the victim. Google acknowledged this as a high-
severity attack since it bypasses operating system protections
that isolate application data from other applications.
Note that there can be many ways for an adversary to
get the user to install two applications on their device. For
instance, the app developer can use in-app advertisements and
links to direct the user to app stores to download their other app
(e.g., Facebook and Messenger). Another effective way would
be to utilize a common Android app development practice
called plug-in architectures [8], [5], which on demand unravel
new features to the user in the form of new apps in order to
foster re-usability and save storage space by unlocking features
only if they are necessary. An example to apps using this
architectures is Yoga Guru [19], which unlocks users new yoga
exercises—as part of new apps—only after making progress
with the set of exercises they currently have.
Internals of the Attack. During the installation or the update
of an app, if a permission deﬁnition is removed from the
system due to this operation, the system iterates over the
existing apps to readjust their granted permissions. The desired
outcome of this behavior is that all the undeﬁned permissions
should be revoked to the remaining apps after an uninstallation
or an update. However, instead of immediately revoking an
undeﬁned permission to the remaining apps, the system instead
revokes it only if a new permission with the same name is
being redeclared. Even though this initially seems unharmful
since the granted permission is rendered useless until it is
redeﬁned, this behavior is what enables our attack. Once the
permission name is recycled by the introduction of a new
signature permission, due to the mismatch of signatures, the
system attempts to revoke this permission to the adversary;
however, it mistakenly only revokes install permissions and
fails to do so for runtime permissions. This, in turn, leaves
the undeﬁned runtime permissions granted to the app. Since
Android utilizes only the names of permissions during permis-
sion enforcement, it cannot differentiate between two distinct
permissions with the same declared name. Hence, the app
holding a “dormant” dangerous permission gains unauthorized
access to components protected with a signature permission
with the same name. Evidently, this violates a key security
principle that should always hold in the Android permission
model: there should be no unauthorized component access.
Note that again the framework developers seem to disregard
the peculiarities and corner cases created by custom permis-
sions. Currently, a third-party app cannot deﬁne a custom
permission using the name of an existing system permission.
It was, however, possible for them to use the name of a new
system permission that were to be deﬁned in the next version of
the OS, to hijack the system permissions [32]. Google’s ﬁx to
this security vulnerability was that the system would always
take the ownership of permissions deﬁned by itself; hence,
spooﬁng attacks on system permissions should not succeed
anymore as the platform is treated as the main principal to
deﬁne/remove system permissions under any circumstance.
However, a similar approach cannot be applied to custom
permissions as the system cannot make a decision regarding
the ownership of a permission between two apps that deﬁne the
same custom permission. Hence, we not only need to identify
whether a permission is system or custom, but in the latter
case, we also need a way to identify its origin and treat it as
a different permission in case there are other permissions with
the same name. It is worth noting that whether a permission
is custom or system cannot be determined solely based on its
name as even custom permissions can currently use system
preﬁxes (e.g. android.permission) and system apps can
create permissions with any name without being forced to use