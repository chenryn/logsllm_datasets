static int j = i;
上⾯示例中， 属于静态变量，初始化时不能赋值为另⼀个变量 。
j i
另外，在块作⽤域中， 声明的变量有默认值 。
static 0
static int foo;
static int foo = 0;
可以⽤来修饰函数本身。
static
static int Twice(int num) {
int result = num * 2;
return(result);
}
上⾯示例中， 关键字表示该函数只能在当前⽂件⾥使⽤，如果没有这个关键字，其他⽂件也可以使
static
⽤这个函数（通过声明函数原型）。
也可以⽤在参数⾥⾯，修饰参数数组。
static
int sum_array(int a[static 3], int n) {
}
上⾯示例中， 对程序⾏为不会有任何影响，只是⽤来告诉编译器，该数组⻓度⾄少为 3，某些情况
static
下可以加快程序运⾏速度。另外，需要注意的是，对于多维数组的参数， 仅可⽤于第⼀维的说明。
static
const 说明符 #
函数参数⾥⾯的 说明符，表示函数内部不得修改该参数变量。
const
void f(int* p) {
}
上⾯示例中，函数 的参数是⼀个指针 ，函数内部可能会改掉它所指向的值 ，从⽽影响到函数外
f() p *p
部。
为了避免这种情况，可以在声明函数时，在指针参数前⾯加上 说明符，告诉编译器，函数内部不能
const
修改该参数所指向的值。
void f(const int* p) {
*p = 0;
}
上⾯示例中，声明函数时， 指定不能修改指针 指向的值，所以 就会报错。
const p *p = 0
但是上⾯这种写法，只限制修改 所指向的值，⽽ 本身的地址是可以修改的。
p p
void f(const int* p) {
int x = 13;
p = &x;
}
上⾯示例中， 本身是可以修改， 只限定 不能修改。
p const *p
如果想限制修改 ，可以把 放在 前⾯。
p const p
void f(int* const p) {
int x = 13;
p = &x;
}
如果想同时限制修改 和 ，需要使⽤两个 。
p *p const
void f(const int* const p) {
}
可变参数 #
有些函数的参数数量是不确定的，声明函数的时候，可以使⽤省略号 表示可变数量的参数。
...
int printf(const char* format, ...);
上⾯示例是 函数的原型，除了第⼀个参数，其他参数的数量是可变的，与格式字符串⾥⾯的占位
printf()
符数量有关。这时，就可以⽤ 表示可变数量的参数。
...
注意， 符号必须放在参数序列的结尾，否则会报错。
...
头⽂件 定义了⼀些宏，可以操作可变参数。
stdarg.h
（1） ：⼀个数据类型，⽤来定义⼀个可变参数对象。它必须在操作可变参数时，⾸先使⽤。
va_list
（2） ：⼀个函数，⽤来初始化可变参数对象。它接受两个参数，第⼀个参数是可变参数对象，
va_start
第⼆个参数是原始函数⾥⾯，可变参数之前的那个参数，⽤来为可变参数定位。
（3） ：⼀个函数，⽤来取出当前那个可变参数，每次调⽤后，内部指针就会指向下⼀个可变参
va_arg
数。它接受两个参数，第⼀个是可变参数对象，第⼆个是当前可变参数的类型。
（4） ：⼀个函数，⽤来清理可变参数对象。
va_end
下⾯是⼀个例⼦。
double average(int i, ...) {
double total = 0;
va_list ap;
va_start(ap, i);
for (int j = 1; j <= i; ++j) {
total += va_arg(ap, double);
}
va_end(ap);
return total / i;
}
上⾯示例中， 定义 为可变参数对象， 将参数 后⾯的参数统⼀放⼊
va_list ap ap va_start(ap, i) i
， ⽤来从 依次取出⼀个参数，并且指定该参数为 double 类型，
ap va_arg(ap, double) ap va_end(ap)
⽤来清理可变参数对象。
全⽂完
本⽂由 简悦 SimpRead 转码，⽤以提升阅读体验，原⽂地址
数组 语⾔教程 ⽹道
- C -
⽹道（WangDoc.com），互联⽹⽂档计划
“
⽹道（WangDoc.com），互联⽹⽂档计划
简介 #
数组是⼀组相同类型的值，按照顺序储存在⼀起。数组通过变量名后加⽅括号表示，⽅括号⾥⾯是数组的
成员数量。
int scores[100];
上⾯示例声明了⼀个数组 ，⾥⾯包含 100 个成员，每个成员都是 类型。
scores int
注意，声明数组时，必须给出数组的⼤⼩。
数组的成员从 开始编号，所以数组 就是从第 0 号成员⼀直到第 99 号成员，最后⼀个成员
0 scores[100]
的编号会⽐数组⻓度⼩ 。
1
数组名后⾯使⽤⽅括号指定编号，就可以引⽤该成员。也可以通过该⽅式，对该位置进⾏赋值。
scores[0] = 13;
scores[99] = 42;
上⾯示例对数组 的第⼀个位置和最后⼀个位置，进⾏了赋值。
scores
注意，如果引⽤不存在的数组成员（即越界访问数组），并不会报错，所以必须⾮常⼩⼼。
int scores[100];
scores[100] = 51;
上⾯示例中，数组 只有 100 个成员，因此 这个位置是不存在的。但是，引⽤这个位置
scores scores[100]
并不会报错，会正常运⾏，使得紧跟在 后⾯的那块内存区域被赋值，⽽那实际上是其他变量的区
scores
域，因此不知不觉就更改了其他变量的值。这很容易引发错误，⽽且难以发现。
数组也可以在声明时，使⽤⼤括号，同时对每⼀个成员赋值。
int a[5] = {22, 37, 3490, 18, 95};
注意，使⽤⼤括号赋值时，必须在数组声明时赋值，否则编译时会报错。
int a[5];
a = {22, 37, 3490, 18, 95};
上⾯代码中，数组 声明之后再进⾏⼤括号赋值，导致报错。
a
报错的原因是，C 语⾔规定，数组变量⼀旦声明，就不得修改变量指向的地址，具体会在后⽂解释。由于
同样的原因，数组赋值之后，再⽤⼤括号修改值，也是不允许的。
int a[5] = {1, 2, 3, 4, 5};
a = {22, 37, 3490, 18, 95};
上⾯代码中，数组 赋值后，再⽤⼤括号重新赋值也是不允许的。
a
使⽤⼤括号赋值时，⼤括号⾥⾯的值不能多于数组的⻓度，否则编译时会报错。
如果⼤括号⾥⾯的值，少于数组的成员数量，那么未赋值的成员⾃动初始化为 。
0
int a[5] = {22, 37, 3490};
int a[5] = {22, 37, 3490, 0, 0};
如果要将整个数组的每⼀个成员都设置为零，最简单的写法就是下⾯这样。
int a[100] = {0};
数组初始化时，可以指定为哪些位置的成员赋值。
int a[15] = {[2] = 29, [9] = 7, [14] = 48};
上⾯示例中，数组的 2 号、9 号、14 号位置被赋值，其他位置的值都⾃动设为 0。
指定位置的赋值可以不按照顺序，下⾯的写法与上⾯的例⼦是等价的。
int a[15] = {[9] = 7, [14] = 48, [2] = 29};
指定位置的赋值与顺序赋值，可以结合使⽤。
int a[15] = {1, [5] = 10, 11, [10] = 20, 21}
上⾯示例中，0 号、5 号、6 号、10 号、11 号被赋值。
C 语⾔允许省略⽅括号⾥⾯的数组成员数量，这时将根据⼤括号⾥⾯的值的数量，⾃动确定数组的⻓度。
int a[] = {22, 37, 3490};
int a[3] = {22, 37, 3490};
上⾯示例中，数组 的⻓度，将根据⼤括号⾥⾯的值的数量，确定为 。
a 3
省略成员数量时，如果同时采⽤指定位置的赋值，那么数组⻓度将是最⼤的指定位置再加 1。
int a[] = {[2] = 6, [9] = 12};
上⾯示例中，数组 的最⼤指定位置是 ，所以数组的⻓度是 10。
a 9
数组⻓度 #
运算符会返回整个数组的字节⻓度。
sizeof
int a[] = {22, 37, 3490};
int arrLen = sizeof(a);
上⾯示例中， 返回数组 的字节⻓度是 。
sizeof a 12
由于数组成员都是同⼀个类型，每个成员的字节⻓度都是⼀样的，所以数组整体的字节⻓度除以某个数组
成员的字节⻓度，就可以得到数组的成员数量。
sizeof(a) / sizeof(a[0])
上⾯示例中， 是整个数组的字节⻓度， 是数组成员的字节⻓度，相除就是数组的
sizeof(a) sizeof(a[0])
成员数量。
注意， 返回值的数据类型是 ，所以 的数据类型也是 。
sizeof size_t sizeof(a) / sizeof(a[0]) size_t
在 ⾥⾯的占位符，要⽤ 或 。
printf() %zd %zu
int x[12];
printf("%zu\n", sizeof(x));
printf("%zu\n", sizeof(int));
printf("%zu\n", sizeof(x) / sizeof(int));
上⾯示例中， 就可以得到数组成员数量 。
sizeof(x) / sizeof(int) 12
多维数组 #
C 语⾔允许声明多个维度的数组，有多少个维度，就⽤多少个⽅括号，⽐如⼆维数组就使⽤两个⽅括号。
int board[10][10];
上⾯示例声明了⼀个⼆维数组，第⼀个维度有 10 个成员，第⼆个维度也有 10 个成员。
多维数组可以理解成，上层维度的每个成员本身就是⼀个数组。⽐如上例中，第⼀个维度的每个成员本身
就是⼀个有 10 个成员的数组，因此整个⼆维数组共有 100 个成员（10 x 10 = 100）。
三维数组就使⽤三个⽅括号声明，以此类推。
int c[4][5][6];
引⽤⼆维数组的每个成员时，需要使⽤两个⽅括号，同时指定两个维度。
board[0][0] = 13;
board[9][9] = 13;
注意， 不能写成 ，因为 是⼀个逗号表达式，返回第⼆个值，所以
board[0][0] board[0, 0] 0, 0 board[0,
等同于 。
0] board[0]
跟⼀维数组⼀样，多维数组每个维度的第⼀个成员也是从 开始编号。
0
多维数组也可以使⽤⼤括号，⼀次性对所有成员赋值。
int a[2][5] = {
{0, 1, 2, 3, 4},
{5, 6, 7, 8, 9}
};
上⾯示例中， 是⼀个⼆维数组，这种赋值写法相当于将第⼀维的每个成员写成⼀个数组。这种写法不⽤
a
为每个成员都赋值，缺少的成员会⾃动设置为 。
0
多维数组也可以指定位置，进⾏初始化赋值。
int a[2][2] = {[0][0] = 1, [1][1] = 2};
上⾯示例中，指定了 和 位置的值，其他位置就⾃动设为 。
[0][0] [1][1] 0
不管数组有多少维度，在内存⾥⾯都是线性存储， 的后⾯是 ， 的后⾯是
a[0][0] a[0][1] a[0][1] a[1]
，以此类推。因此，多维数组也可以使⽤单层⼤括号赋值，下⾯的语句是上⾯的赋值语句是完全等同
[0]
的。
int a[2][2] = {1, 0, 0, 2};
变⻓数组 #
数组声明的时候，数组⻓度除了使⽤常量，也可以使⽤变量。这叫做变⻓数组（variable-length array，简
称 VLA）。
int n = a + b;
int a[n];
上⾯示例中，数组 就是变⻓数组，因为它的⻓度取决于变量 的值，编译器没法事先确定，只有运⾏
a n
时才能知道 是多少。
n
变⻓数组的根本特征，就是数组⻓度只有运⾏时才能确定。它的好处是程序员不必在开发时，随意为数组
指定⼀个估计的⻓度，程序可以在运⾏时为数组分配精确的⻓度。
任何⻓度需要运⾏时才能确定的数组，都是变⻓数组。
int i = 10;
int a1[i];
int a2[i + 5];
int a3[i + k];
上⾯示例中，三个数组的⻓度都需要运⾏代码才能直到，所以它们都是变⻓数组。
变⻓数组也可以⽤于多维数组。
int m = 4;
int n = 5;
int c[m][n];
上⾯示例中， 就是⼆维变⻓数组。
c[m][n]
数组的地址 #
数组是⼀连串连续储存的同类型值，只要获得起始地址（⾸个成员的内存地址），就能推算出其他成员的
地址。请看下⾯的例⼦。
int a[5] = {11, 22, 33, 44, 55};
int* p;
p = &a[0];
printf("%d\n", *p);
上⾯示例中， 就是数组 的⾸个成员 的内存地址，也是整个数组的起始地址。反过来，从这个
&a[0] a 11