# 19 \| 如何用着色器实现像素动画？你好，我是月影。上节课，我们以 HTML/CSS为例，讲了三种动画的实现方法，以及标准的动画模型。我们先来回顾一下：1.  固定帧动画：为每一帧准备一张图片，然后把 CSS 关键帧动画的    easing-function 设为 step-end    进行循环播放。        2.  增加增量动画：在每帧给元素的相关属性增加一定的量，比如增加一个    rotate 角度。        3.  时序动画：通过控制时间和动画函数来描述动画，首先定义初始时间和周期，然后在    update 中计算当前经过时间和进度 p，最后通过 p    来更新动画元素的属性。        4.  标准动画模型：先定义 Animator    类，然后使用线性插值实现匀速运动的动画，以及通过缓动函数实现变速运动的动画。        而 WebGL实现动画的方式和以上这些方式都有差别。所以这节课，我们就接着来讲怎么用着色器来实现动画。因为实现固定帧动画最简单，所以我们还是先来说它。如何用着色器实现固定帧动画我们完全可以使用在片元着色器中替换纹理坐标的方式，来非常简单地实现固定帧动画。为了方便对比，我还是用上一节课实现会飞的小鸟的例子来讲，那片元着色器中的代码和最终要实现的效果如下所示。    #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    uniform sampler2D tMap;    uniform float fWidth;    uniform vec2 vFrames[3];    uniform int frameIndex;    void main() {      vec2 uv = vUv;      for (int i = 0; i  {        renderer.uniforms.frameIndex++;      }, 200);      const x = 43 / canvas.width;      const y = 30 / canvas.height;      renderer.setMeshData([{        positions: [          [-x, -y],          [-x, y],          [x, y],          [x, -y],        ],        attributes: {          uv: [            [0, 0],            [0, 1],            [1, 1],            [1, 0],          ],        },        cells: [[0, 1, 2], [2, 0, 3]],      }]);      renderer.render();    }());实际上 WebGL实现固定帧动画的思路，和上一节课的思路是类似的。只不过，上一节课我们直接用CSS 的 background-image，来切换 background-position就可以实现动画。而在这里，我们需要将图片纹理 tMap 传进去，然后根据不同的frameIndex来计算出对应的纹理坐标，并且这个计算是在片元着色器中进行的。如何用着色器实现非固定帧动画好了，知道了怎么实现固定帧动画。接着，我们再来说增量动画和时序动画的实现。由于这两种动画都要将与时间有关的参数传给着色器，处理过程非常相似，所以我们可以将它们统称为非固定帧动画，放在一起来说。由于这两种动画都要将与时间有关的参数传给着色器，因此它们的处理过程非常相似，我们可以将它们统称为非固定帧动画，放在一起来说。用 Shader实现非固定帧动画，本质上和上一节课的实现方法没有太大区别。所以，我们仍然可以使用同样的方法，以及标准动画模型来实现它。只不过，用Shader来实现非固定帧动画更加灵活，我们可以操作更多的属性，实现更丰富的效果。下面，我们详细来说说。1. 用顶点着色器实现非固定帧动画我们知道，WebGL 有两种Shader，分别是顶点着色器和片元着色器，它们都可以用来实现动画。我们先来看顶点着色器是怎么实现动画的。    attribute vec2 a_vertexPosition;    attribute vec2 uv;    varying vec2 vUv;    uniform float rotation;    void main() {      gl_PointSize = 1.0;      vUv = uv;      float c = cos(rotation);      float s = sin(rotation);      mat3 transformMatrix = mat3(        c, s, 0,        -s, c, 0,        0, 0, 1      );      vec3 pos = transformMatrix * vec3(a_vertexPosition, 1);      gl_Position = vec4(pos, 1);    }在顶点着色器中，我们先绘制出一个红色的正方形，然后用三维齐次矩阵实现旋转。具体来说，就是把顶点坐标进行矩阵运算，再配合下面的JavaScript代码，就能让这个正方形旋转了。    renderer.uniforms.rotation = 0.0;    requestAnimationFrame(function update() {      renderer.uniforms.rotation += 0.05;      requestAnimationFrame(update);    });![](Images/7500856d6f1823ff26e00b85a3383903.png)savepage-src="https://static001.geekbang.org/resource/image/2d/cb/2dbbyy2470cb07ed2e67e4d43aee21cb.gif"}逆时针旋转的红色正方形当然，我们也可以使用上一节课得到的标准动画模型来实现。具体来说，就是定义一个新的Animator 对象，然后在 Animator 对象的方法中更新 rotation属性。使用标准模型能更加精确地控制图形的旋转效果，代码如下：    const animator = new Animator({duration: 2000, iterations: Infinity});    animator.animate(renderer, ({target, timing}) => {      target.uniforms.rotation = timing.p * 2 * Math.PI;    });总之，WebGL实现非固定帧动画的方法与上节课的方式基本上一样。只不过，前一节课我们直接修改HTML 元素的属性，而这一节课我们将属性通过 uniform变量传给着色器执行渲染。2. 用片元着色器实现非固定帧动画除了用顶点着色器，我们也能用片元着色器实现动画。实际上，我们已经用片元着色器实现了不少动画。比如说，当我们将时间参数uTime 通过 uniform传给着色器的时候，就是在实现动画。还是用上面的例子。这次，我们将旋转放到片元着色器中处理，其实也能实现类似的旋转效果。代码如下所示：    #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    uniform vec4 color;    uniform float rotation;    void main() {      vec2 st = 2.0 * (vUv - vec2(0.5));      float c = cos(rotation);      float s = sin(rotation);      mat3 transformMatrix = mat3(        c, s, 0,        -s, c, 0,        0, 0, 1      );      vec3 pos = transformMatrix * vec3(st, 1.0);      float d1 = 1.0 - smoothstep(0.5, 0.505, abs(pos.x));      float d2 = 1.0 - smoothstep(0.5, 0.505, abs(pos.y));      gl_FragColor = d1 * d2 * color;    }![](Images/cd7a9c306329b42a22d02a63f64ade0f.png)savepage-src="https://static001.geekbang.org/resource/image/81/34/8176f915e61f55ae0c54da3283b23134.gif"}顺时针旋转的红色正方形你发现了吗，顶点着色器和片元着色器实现的旋转动画方向正好相反。为什么会出现这样的情况呢？因为在顶点着色器中，我们直接改变了顶点坐标，所以这样实现的旋转动画和WebGL坐标系（右手系）的方向一致，角度增大呈逆时针方向旋转。而在片元着色器中，我们的绘制原理是通过距离场着色来实现的，所以这里的旋转实际上改变的是距离场的角度而不是图形角度，最终绘制的图形也是相对于距离场的。又因为距离场逆时针旋转，所以图形就顺时针旋转了。最后我再补充一点，一般来说，动画如果能使用顶点着色器实现，我们会尽量在顶点着色器中实现。因为在绘制一帧画面的时候，顶点着色器的运算量会大大少于片元着色器，所以使用顶点着色器消耗的性能更少。但是，在片元着色器中实现非固定帧动画也有优势。我们可以使用片元着色器的技巧，如重复、随机、噪声等等来绘制更加复杂的效果。比如说，我们把上面的代码稍微修改一下，使用取小数和取整数的函数，再用之前网格化的思路，来利用网格实现了大量的重复动画。这个做法充分利用了GPU的并行效率，比用其他方式把图形一个一个地绘制出来性能要高得多。    #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    uniform float rotation;    float random (vec2 st) {        return fract(sin(dot(st.xy,                            vec2(12.9898,78.233)))*            43758.5453123);    }    vec3 hsb2rgb(vec3 c){      vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);      rgb = rgb * rgb * (3.0 - 2.0 * rgb);      return c.z * mix(vec3(1.0), rgb, c.y);    }    void main() {      vec2 f_uv = fract(vUv * 10.0);      vec2 i_uv = floor(vUv * 10.0);      vec2 st = 2.0 * (f_uv - vec2(0.5));      float c = 0.7 * cos(rotation);      float s = 0.7 * sin(rotation);      mat3 transformMatrix = mat3(        c, s, 0,        -s, c, 0,        0, 0, 1      );      vec3 pos = transformMatrix * vec3(st, 1.0);      float d1 = 1.0 - smoothstep(0.5, 0.505, abs(pos.x));      float d2 = 1.0 - smoothstep(0.5, 0.505, abs(pos.y));      gl_FragColor = d1 * d2 * vec4(hsb2rgb(vec3(random(i_uv), 1.0, 1.0)), 1.0);    }![](Images/65b941f399cb009d054e9f06229d968e.png)savepage-src="https://static001.geekbang.org/resource/image/9b/8c/9b7fe730d2f82df5f05b015eb08aab8c.gif"}大量重复的旋转正方形如何在着色器中实现缓动函数与非线性插值在前面的例子中，我们使用 Shader的矩阵运算实现了旋转动画。同样，轨迹动画也可以用 Shader矩阵运算实现。比如说，我们要在画布上绘制一个红色的方块，利用它实现轨迹动画。首先，我们要实现一个着色器，它通过设置translation来改变图形位置，代码如下：    attribute vec2 a_vertexPosition;    attribute vec2 uv;    varying vec2 vUv;    uniform vec2 translation;    void main() {      gl_PointSize = 1.0;      vUv = uv;      mat3 transformMatrix = mat3(        1, 0, 0,        0, 1, 0,        translation, 1      );      vec3 pos = transformMatrix * vec3(a_vertexPosition, 1);      gl_Position = vec4(pos, 1);    }然后，在 JavaScript 中，我们将 translation依照时间变化传给上面的着色器，就可以让方块移动。那利用下面的代码，我们就让方块沿水平方向向右匀速运动一段距离。    const canvas = document.querySelector('canvas');    const renderer = new GlRenderer(canvas);    const program = renderer.compileSync(fragment, vertex);    renderer.useProgram(program);    renderer.uniforms.color = [1, 0, 0, 1];    renderer.uniforms.translation = [-0.5, 0];    const animator = new Animator({duration: 2000});    animator.animate(renderer, ({target, timing}) => {      target.uniforms.translation = [-0.5 * (1 - timing.p) + 0.5 * timing.p, 0];    });    renderer.setMeshData([{      positions: [        [-0.25, -0.25],        [-0.25, 0.25],        [0.25, 0.25],        [0.25, -0.25],      ],      attributes: {        uv: [          [0, 0],          [0, 1],          [1, 1],          [1, 0],        ],      },      cells: [[0, 1, 2], [2, 0, 3]],    }]);    renderer.render();![](Images/82d2730001c9db3990b0cedfcbf3f483.png)savepage-src="https://static001.geekbang.org/resource/image/be/cf/beeb13aa9565a4b066883d8a08632acf.gif"}水平向右匀速运动的红色正方形此外，我们还可以通过缓动函数来实现非匀速运动。而且我们既可以将缓动函数用JavaScript 计算，也可以直接将缓动函数放在 Shader 中。如果将缓动函数用JavaScript 计算，那么方法和上一节课完全一样，也就是给 Animator 传一个easing 函数进去就可以了，这里我就不再重复了。但如果要将缓动函数写在Shader 中，其实方法也非常简单。我们以前面顶点着色器实现非固定帧动画的代码为例，这次，我们不使用Animator，而是直接将时间 uTime 参数传入 Shader，然后在 Shader中加入缓动函数。在这里，我们用 smooth(0.0, 1.0, p)来让方块做平滑加速、减速运动。除此之外，你也可以替换缓动函数，比如clamp(p \* p, 0.0, 1.0) 或者 clamp(p \* (2 - p) \* 0.0, 1.0)来实现匀加速、匀减速的运动效果。修改后的代码如下：    attribute vec2 a_vertexPosition;    attribute vec2 uv;    varying vec2 vUv;    uniform vec4 uFromTo;    uniform float uTime;    float easing(in float p) {      return smoothstep(0.0, 1.0, p);      // return clamp(p * p, 0.0, 1.0);      // return clamp(p * (2 - p) * 0.0, 1.0);    }    void main() {      gl_PointSize = 1.0;      vUv = uv;      vec2 from = uFromTo.xy;      vec2 to = uFromTo.zw;      float p = easing(uTime / 2.0);      vec2 translation = mix(from, to, p);      mat3 transformMatrix = mat3(        1, 0, 0,        0, 1, 0,        translation, 1      );      vec3 pos = transformMatrix * vec3(a_vertexPosition, 1);      gl_Position = vec4(pos, 1);    }总之，因为 Shader 是在 GPU中运算的，所以所有顶点都是被并行处理的。因此，通常情况下，我们在顶点着色器中执行缓动函数会更快。不过，直接用 JavaScript计算和放在顶点着色器里计算，差别也不是很大，但如果把它放在片元着色器里计算，因为要把每个像素点都计算一遍，所以性能消耗反而更大一些。那我们为什么还要在着色器中计算easing 呢？这是因为，我们不仅可以利用 easing控制动画过程，还可以在片元着色器中用 easing来实现非线性的插值。那什么是非线性插值呢？我们依然通过例子来进一步理解。我们知道，在正常情况下，顶点着色器定义的变量在片元着色器中，都会被线性插值。比如，你可以看我下面给出的顶点着色器、片元着色器，以及JavaScript 中的代码。    //顶点着色器    attribute vec2 a_vertexPosition;    attribute vec2 uv;    attribute vec4 color;    varying vec2 vUv;    varying vec4 vColor;    uniform vec4 uFromTo;    uniform float uTime;    void main() {      gl_PointSize = 1.0;      vUv = uv;      vColor = color;      gl_Position = vec4(a_vertexPosition, 1, 1);    }    //片元着色器    #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    varying vec4 vColor;    void main() {      gl_FragColor = vColor;    }    //JavaScript中的代码    renderer.setMeshData([{      positions: [        [-0.5, -0.25],        [-0.5, 0.25],        [0.5, 0.25],        [0.5, -0.25],      ],      attributes: {        uv: [          [0, 0],          [0, 1],          [1, 1],          [1, 0],        ],        color: [          [1, 0, 0, 1],          [1, 0, 0, 1],          [0, 0.5, 0, 1],          [0, 0.5, 0, 1],        ],      },      cells: [[0, 1, 2], [2, 0, 3]],    }]);    renderer.render();![](Images/b37cd8b59d9caca73b3306c54f98344e.png)savepage-src="https://static001.geekbang.org/resource/image/28/eb/28934b0fd2dayy775f20b48cb18d1ceb.jpg"}从左往右，由红色线性过渡到绿色通过执行上面的代码，我们可以得到一个长方形，它的颜色会从左到右，由红色线性地过渡到绿色。如果想要实现非线性的颜色过渡，我们就不能采用这种方式了，我们可以采用uniform 的方式，通过 easing函数来实现。    #ifdef GL_ES    precision highp float;    #endif    float easing(in float p) {      return smoothstep(0.0, 1.0, p);      // return clamp(p * p, 0.0, 1.0);      // return clamp(p * (2 - p) * 0.0, 1.0);    }    varying vec2 vUv;    uniform vec4 fromColor;    uniform vec4 toColor;    void main() {      float d = easing(vUv.x);      gl_FragColor = mix(fromColor, toColor, d);    }比如，我们可以使用 smoothstep 这种 easing函数，来实现如下的插值效果：![](Images/b9ece14053ba4e987bdf047891006938.png)savepage-src="https://static001.geekbang.org/resource/image/87/38/87519e16885ca453475173318d459d38.jpg"}另外，我们还可以像利用 JavaScript 那样，在 Shader里实现贝塞尔曲线缓动。    // http://www.flong.com/texts/code/shapers_bez/    // Helper functions:    float slope_from_t (float t, float A, float B, float C){      float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C);       return dtdx;    }    float x_from_t (float t, float A, float B, float C, float D){      float x = A*(t*t*t) + B*(t*t) + C*t + D;      return x;    }    float y_from_t (float t, float E, float F, float G, float H){      float y = E*(t*t*t) + F*(t*t) + G*t + H;      return y;    }    float cubic_bezier (float x, float a, float b, float c, float d){      float y0a = 0.00; // initial y      float x0a = 0.00; // initial x       float y1a = b;    // 1st influence y         float x1a = a;    // 1st influence x       float y2a = d;    // 2nd influence y      float x2a = c;    // 2nd influence x      float y3a = 1.00; // final y       float x3a = 1.00; // final x       float A = x3a - 3.0 *x2a + 3.0 * x1a - x0a;      float B = 3.0 * x2a - 6.0 * x1a + 3.0 * x0a;      float C = 3.0 * x1a - 3.0 * x0a;         float D = x0a;      float E = y3a - 3.0 * y2a + 3.0 * y1a - y0a;          float F = 3.0 * y2a - 6.0 * y1a + 3.0 * y0a;                   float G = 3.0 * y1a - 3.0 * y0a;                   float H = y0a;      // Solve for t given x (using Newton-Raphelson), then solve for y given t.      // Assume for the first guess that t = x.      float currentt = x;      const int nRefinementIterations = 5;      for (int i=0; i  {          positions.push(vertices[i]);          color.push(colors[colorIdx % colorLen]);        });        cells.push(          [0, 1, 2].map(i => i + cellsIdx),          [0, 2, 3].map(i => i + cellsIdx),        );        colorIdx++;        cellsIdx += 4;      }      quad(1, 0, 3, 2);      quad(4, 5, 6, 7);      quad(2, 3, 7, 6);      quad(5, 4, 0, 1);      quad(3, 0, 4, 7);      quad(6, 5, 1, 2);      return {positions, color, cells};    }这样，我们就可以构建出立方体的顶点信息，我在下面给出了 12个立方体的顶点。    const geometry = cube(1.0, [      [1, 0, 0, 1],      [0, 0.5, 0, 1],      [1, 0, 1, 1],    ]);通过上面的代码，我们就能创建出一个棱长为 1的立方体，并且六个面的颜色分别是"红、绿、蓝、红、绿、蓝"。这里我还想补充一点内容，绘制 3D 图形与绘制 2D图形有一点不一样，那就是我们必须要开启**深度检测和启用深度缓冲区**。在 WebGL中，我们可以通过`gl.enable(gl.DEPTH_TEST)`，来开启深度检测。而且，我们在清空画布的时候，也要用`gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);`，来同时清空颜色缓冲区和深度缓冲区。启动和清空深度检测和深度缓冲区这两个步骤，是这个过程中非常重要的一环，但是我们几乎不会用原生的方式来写代码，所以我们了解到这个程度就可以了。事实上，对于上面这些步骤，为了方便使用，我们还是可以直接使用gl-renderer 库。它封装了深度检测，在使用它的时候，我们只要在创建renderer 的时候设置一个参数 depth: true即可。 现在，我们把这个三维立方体用 gl-renderer渲染出来，渲染代码如下：    const canvas = document.querySelector('canvas');    const renderer = new GlRenderer(canvas, {      depth: true,    });    const program = renderer.compileSync(fragment, vertex);    renderer.useProgram(program);    renderer.setMeshData([{      positions: geometry.positions,      attributes: {        color: geometry.color,      },      cells: geometry.cells,    }]);    renderer.render();![](Images/dc88ed9dd17cd59babf8ef0eb648f9a1.png)savepage-src="https://static001.geekbang.org/resource/image/39/4d/39bc7f588350b3c990c4cd0e2b616e4d.jpeg"}立方体的正视图，在画布上只呈现了一个红色正方形，因为其他面被遮挡住了投影矩阵：变换 WebGL 坐标系结合渲染出来的这个图形，我想让你再仔细观看一下我们刚才调用的代码。当时立方体的顶点我们是这么定义的：     const vertices = [        [-h, -h, -h],        [-h, h, -h],        [h, h, -h],        [h, -h, -h],        [-h, -h, h],        [-h, h, h],        [h, h, h],        [h, -h, h],而立方体的六个面的颜色，我们是这么定义的：    //立方体的六个面      quad(1, 0, 3, 2); // 红 -- 这一面应该朝内      quad(4, 5, 6, 7);  // 绿 -- 这一面应该朝外      quad(2, 3, 7, 6);  // 蓝      quad(5, 4, 0, 1);  // 红      quad(3, 0, 4, 7);  // 绿      quad(6, 5, 1, 2);  // 蓝有没有发现问题？我们之前说过，WebGL 的坐标系是 z 轴向外为正，z轴向内为负，所以根据我们调用的代码，赋给靠外那一面的颜色应该是绿色，而不是红色。但是这个立方体朝向我们的一面却是红色，这是为什么呢？实际上，WebGL 默认的**剪裁坐标**的 z 轴方向，的确是朝内的。也就是说，WebGL坐标系就是一个左手系而不是右手系。但是，基本上所有的 WebGL教程，也包括我们前面的课程，一直都在说 WebGL坐标系是右手系，这又是为什么呢？这是因为，规范的直角坐标系是右手坐标系，符合我们的使用习惯。因此，一般来说，不管什么图形库或图形框架，在绘图的时候，都会默认将坐标系从左手系转换为右手系。**那我们下一步，就是要将 WebGL的坐标系从左手系转换为右手系。**关于坐标转换，我们可以通过齐次矩阵来完成。将左手系坐标转换为右手系，实际上就是将z轴坐标方向反转，对应的齐次矩阵如下：    [      1, 0, 0, 0,      0, 1, 0, 0,      0, 0, -1, 0,      0, 0, 0, 1    这种转换坐标的齐次矩阵，又被称为**投影矩阵**（ProjectionMatrix）。接着，我们就修改一下顶点着色器，将投影矩阵加入进去。这样，画布上显示的就是绿色的正方形了。代码和效果图如下：    attribute vec3 a_vertexPosition;    attribute vec4 color;    varying vec4 vColor;    uniform mat4 projectionMatrix;    void main() {      gl_PointSize = 1.0;      vColor = color;      gl_Position = projectionMatrix * vec4(a_vertexPosition, 1.0);    }![](Images/b3012f3eb06bea31cadb16e413ed5bd8.png)savepage-src="https://static001.geekbang.org/resource/image/19/40/19ee7c8dbddee10663e83b00eb740040.jpeg"}投影矩阵不仅可以用来改变 z轴坐标，还可以用来实现正交投影、透视投影以及其他的投影变换，在下一节课我们会深入去讲。模型矩阵：让立方体旋转起来通过前面的操作，我们还是只能看到立方体的一个面，因为我们的视线正好是垂直于z轴的，所以其他的面被完全挡住了。不过，我们可以通过旋转立方体，将其他的面露出来。旋转立方体，同样可以通过矩阵运算来实现。这次我们要用到另一个齐次矩阵，它定义了被绘制的物体变换，这个矩阵叫做**模型矩阵**（ModelMatrix）。接下来，我们就把模型矩阵加入到顶点着色器中，然后将它与投影矩阵相乘，最后再乘上齐次坐标，就得到最终的顶点坐标了。    attribute vec3 a_vertexPosition;    attribute vec4 color;    varying vec4 vColor;    uniform mat4 projectionMatrix;    uniform mat4 modelMatrix;    void main() {      gl_PointSize = 1.0;      vColor = color;      gl_Position = projectionMatrix * modelMatrix * vec4(a_vertexPosition, 1.0);    }接着，我们定义一个 JavaScript 函数，用立方体沿 x、y、z轴的旋转来生成模型矩阵。我们以 x、y、z三个方向的旋转得到三个齐次矩阵，然后将它们相乘，就能得到最终的模型矩阵。    import {multiply} from '../common/lib/math/functions/Mat4Func.js';    function fromRotation(rotationX, rotationY, rotationZ) {      let c = Math.cos(rotationX);      let s = Math.sin(rotationX);      const rx = [        1, 0, 0, 0,        0, c, s, 0,        0, -s, c, 0,        0, 0, 0, 1,      ];      c = Math.cos(rotationY);      s = Math.sin(rotationY);      const ry = [        c, 0, s, 0,        0, 1, 0, 0,        -s, 0, c, 0,        0, 0, 0, 1,      ];      c = Math.cos(rotationZ);      s = Math.sin(rotationZ);      const rz = [        c, s, 0, 0,        -s, c, 0, 0,        0, 0, 1, 0,        0, 0, 0, 1,      ];      const ret = [];      multiply(ret, rx, ry);      multiply(ret, ret, rz);      return ret;    }最后，我们把这个模型矩阵传给顶点着色器，不断更新三个旋转角度，就能实现立方体旋转的效果，也就可以看到立方体其他各个面了。效果和代码如下所示：    let rotationX = 0;    let rotationY = 0;    let rotationZ = 0;    function update() {      rotationX += 0.003;      rotationY += 0.005;      rotationZ += 0.007;      renderer.uniforms.modelMatrix = fromRotation(rotationX, rotationY, rotationZ);      requestAnimationFrame(update);    }    update();![](Images/fca5e91a7f68c206b094d7fae8244d8b.png)savepage-src="https://static001.geekbang.org/resource/image/ff/69/ff4dd2c260eb6aba433b4yye4cef7569.gif"}到这里，我们就完成了一个旋转的立方体。如何用 WebGL 绘制圆柱体立方体还是比较简单的几何体，那类似的，我们还可以构建顶点和三角形，来绘制更加复杂的图形，比如圆柱体、球体等等。这里，我再用绘制圆柱体来举个例子。我们知道圆柱体的两个底面都是圆，我们可以用割圆的方式对圆进行简单的三角剖分，然后把圆柱的侧面用上下两个圆上的顶点进行三角剖分。![](Images/0bedf6601217737435521347e4c6ebef.png)savepage-src="https://static001.geekbang.org/resource/image/30/01/30a5c31ea777ef8b5f9586d5bb6ed401.jpg"}具体的算法如下：    function cylinder(radius = 1.0, height = 1.0, segments = 30, colorCap = [0, 0, 1, 1], colorSide = [1, 0, 0, 1]) {      const positions = [];      const cells = [];      const color = [];      const cap = [[0, 0]];      const h = 0.5 * height;      // 顶和底的圆      for(let i = 0; i  [x, y, -h]));      for(let i = 1; i  [x, y, h]));      for(let i = 1; i  colorCap));      // 侧面      offset = positions.length;      for(let i = 1; i ```     function cube(width = 1.0, height = 1.0, depth = 1.0, colors = [[1, 0, 0, 1]])1.       你能用我们今天讲的方法绘制出一个正四面体，并给不同的面设置不同的颜色，然后在正四面体上实现点光源光照效果吗？        欢迎在留言区和我讨论，分享你的答案和思考，也欢迎你把这节课分享给你的朋友，我们下节课见！  源码课程中完整示例代码见 slate-object="mark"}GitHub 仓库slate-object="mark"}