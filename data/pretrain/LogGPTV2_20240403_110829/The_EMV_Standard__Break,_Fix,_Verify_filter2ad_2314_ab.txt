the EMV standard has been extensively studied. We review
here the most relevant related work. This previous work con-
cerns either implementation ﬂaws or protocol ﬂaws discovered
by analyzing selected and possibly simpliﬁed parts of the
EMV speciﬁcation. In contrast, our analysis integrates all
the different conﬁgurations for card authentication, cardholder
veriﬁcation, and transaction authorization in a single symbolic
model. This provides a basis not only for ﬁnding all relevant
design errors, but also producing correctness proofs.
In 2010, Murdoch et al. [1] identiﬁed a serious ﬂaw
in EMV’s ofﬂine Cardholder Veriﬁcation Methods (CVMs).
Namely, the card’s response to the terminal’s PIN veriﬁcation
request is not authenticated. Therefore, a man-in-the-middle
(MITM) could reply with the success message to any PIN the
terminal would request veriﬁcation for. The dummy PIN could
be blocked from reaching the card, which would then assume
that either the chosen CVM was paper signature or no CVM
was required at all. All subsequent steps would be carried out
normally and the transaction would be accepted.
Even though Murdoch et al.’s attack comes with some
engineering challenges, such as miniaturizing the MITM in-
frastructure, these challenges appear to have been overcome
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:10:50 UTC from IEEE Xplore.  Restrictions apply. 
1767
as observed in the aforementioned forgery of credit cards in
France and Belgium [11]. Our analysis demonstrates that this
attack still exists in old cards that support neither asymmetric
cryptography nor online PIN veriﬁcation (see Section V-A).
Unfortunately, many modern cards that support both features
are still vulnerable to our own PIN bypass attack, which we
present in this paper.
Soon after, De Ruiter and Poll [16] gave a ProVerif [19]
model of a variant of the EMV contact protocol. They sum-
marize over 700 pages of EMV speciﬁcations into 370 lines
of F# code, which they transform into the ProVerif language
using the FS2PV tool [20]. Their analysis misses the attack
of [1] because the terminal’s selection of the CVM is over-
simpliﬁed to always opt for the ofﬂine plaintext PIN. This
makes the card always expect a PIN veriﬁcation request, with
the correct PIN, before continuing with the transaction.
Some of EMV’s ﬂaws have also been identiﬁed from
empirical studies in the ﬁeld [3], [9], [10]. For example, Bond
et al. [9], together with unsatisﬁed consumers who were denied
refunds for fraud claims, were given access to the bank logs of
the disputed transactions. This access, together with reverse-
engineering some ATMs, revealed ﬂawed implementations of
EMV. They noted that the supposedly unpredictable numbers
generated by some terminals were actually pretty predictable,
allowing criminals to pre-play payments and use the retrieved
data for later purchases.
Bond et al. also report that a pre-play attack is still possible
even when the terminal’s random number generator works
correctly. In this case, the pre-play consists of the attacker
replacing the terminal-generated nonce with one used in an
earlier transaction between the attacker and the victim’s card.
Symbolic models consider the Dolev-Yao threat model [21],
where the adversary only knows public knowledge, the data
sent over the network, and the outcome of public functions
on known input. The adversary is also an active attacker, who
can modify, block, and inject data on the network. In this
model, however, random number generators are assumed to be
sound, i.e., random numbers cannot be predicted. Therefore,
attacks of this kind are usually not part of a symbolic analysis
that examines the speciﬁcation (not the implementation) for
logical errors. Our analysis thus does not uncover Bond et al.’s
attacks [9]. Note that it is possible though to incorporate weak
random generators and compromised channels into symbolic
models, as described in [22].
The EMV contactless protocol’s security has been chal-
lenged multiple times too. For example, Roland and Langer [3]
detected a downgrade attack that exploits Mastercard’s
MagStripe mode, a legacy authentication mode kept
for
backward compatibility. They showed that a mobile phone
supporting Near Field Communication (NFC) can collect all
authentication codes that a card could produce in response to
all potential challenges from a terminal. Hence, a clone card
pre-loaded with the codes can be used for fraudulent payments.
This attack is feasible because the MagStripe mode reduces the
terminal’s pool of unpredictable numbers to 1000 values only.
In this paper we do not consider the MagStripe mode because
the random generators are assumed sound (as explained above)
and this mode has been deprecated in many countries.
Other attacks demonstrated against EMV contactless pay-
ment protocols are well-known relay attacks [4]–[8]. The
works [4], [7], [8] suggest using distance bounding proto-
cols [23], [24] as a countermeasure to such attacks. Although
distance bounding does prevent relay attacks, only Mastercard
seems to be inclined to use it. Relay attacks are usually ignored
because they are presumably feasible only for small transac-
tions, since larger transactions require cardholder veriﬁcation.
In 2014, Emms et al. [10] observed that some UK-issued
contactless Visa credit cards drop the PIN veriﬁcation for
transactions in foreign currencies. The authors developed a
proof-of-concept implementation of the attack, where they
faked a transaction of almost one million US dollars. We
attempted to reproduce the experiments of [10] but all modern
cards we tested did ask for PIN veriﬁcation for high-value
transactions in both domestic and foreign currencies.
There exist various symbolic models that showcase the
EMV contactless protocols [17], [18], [25]–[27]. All of these
focus on verifying proximity between the card and the termi-
nal. They also consider the terminal and the bank as a single
agent and consequently do not cover the pre-play attack of [3].
Galloway and Yunusov [28] recently presented a man-in-
the-middle attack that also circumvents Visa’s PIN veriﬁcation.
Their attack is similar to ours in that it modiﬁes a card-sourced
message that instructs the terminal that cardholder veriﬁcation
was performed on the consumer’s device. In contrast to our at-
tack, Galloway and Yunusov’s attack also modiﬁes a terminal-
sourced message in which the cardholder veriﬁcation request is
encoded. According to EMV’s (generic) cryptogram deﬁnition,
such message should be protected against modiﬁcation. Their
attack works because Visa’s proprietary cryptograms do not
prevent such modiﬁcation, or at least not the ones implemented
by the cards they tested. Interestingly, and worrisome, our own
attack demonstrates that the strongest cryptogram proposed by
EMV still does not sufﬁce to correctly verify the cardholder.
The details are given in Section VI.
III. EMV DESCRIPTION
The EMV speciﬁcation runs over 2,000 pages split across
several books. Moreover, many of the statements in these
books are quite complex and cross-reference other books. In
this section we give a detailed description of the standard.
Given its complexity, creating this speciﬁcation and its formal
model in Tamarin was a major undertaking that took over
six months of full-time work. Our methodology included not
only carefully reading the standard, but also cross-checking
and disambiguating its statements with data from over 30 real-
world transaction logs that we obtained using the Android app
we developed, described in later sections.
An EMV transaction consists of a series of Application
Protocol Data Unit (APDU) command/response exchanges and
can be divided into four phases:
1) Initialization: the card and the terminal agree on the appli-
cation to be used for the transaction and exchange static
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:10:50 UTC from IEEE Xplore.  Restrictions apply. 
1768
data such as the card’s records containing information
about the card and the issuing bank (or simply the bank
from now on, unless otherwise speciﬁed).
2) Ofﬂine Data Authentication (ODA): the terminal performs
a PKI-based validation of the card. Once the card has
provided the terminal with the Certiﬁcate Authority (CA)
index, the bank’s Public Key (PK) certiﬁcate issued by the
CA, and the card’s PK certiﬁcate issued by the bank, the
terminal validates the card’s signature on the transaction
details.
3) Cardholder Veriﬁcation: the terminal determines whether
the person presenting the card is the legitimate cardholder.
This is done using a method that
the card and the
terminal both support. The most common method is
online enciphered PIN veriﬁcation, in which the terminal
sends (an encryption of) the entered PIN to the bank for
veriﬁcation. The card is not involved.
4) Transaction Authorization (TA):
the transaction is de-
clined ofﬂine, accepted ofﬂine, or sent to the issuing bank
for online authorization.
An overview of the full EMV transaction ﬂow is depicted
in Figure 1 and the details of each phase are given next.
A. Initialization
The ﬁrst step of an EMV transaction is the application
selection. The terminal issues the SELECT command with the
string 1PAY.SYS.DDF01 (in bytes), which refers to the contact
Payment System Environment (PSE), or 2PAY.SYS.DDF01
for contactless. The card responds with the sequence of
Application Identiﬁers (AIDs). In the response, the card may
also request the Processing Data Object List (PDOL), which is
a list of terminal-sourced transaction data. The PDOL typically
includes the amount, the country code, the currency, the date,
the transaction type, and the terminal’s random number UN
(called Unpredictable Number in EMV’s terminology).
The terminal
issues the GET PROCESSING OPTIONS
command along with the PDOL data, if requested by the card.
The card responds with the 2-byte Application Interchange
Proﬁle (AIP, which indicates the supported authentication
methods and whether cardholder veriﬁcation is supported)
and the Application File Locator (AFL, which points to a
list of ﬁles and records that the terminal should read from
the card). The terminal then learns these records using the
READ RECORD command. The records typically include:
• the Primary Account Number (PAN, commonly known
as the card number), the card’s expiration date, and other
static data;
• the index of the CA, the bank’s PK certiﬁcate issued by
the CA, and the card’s PK certiﬁcate issued by the bank,
if the card supports asymmetric encryption;
• the ﬁrst and second Card Risk Management Data Object
Lists (CDOL1 and CDOL2, respectively), which typically
include the PDOL and further transaction data; and
• the list of the supported CVMs.
From the CA’s index,
the terminal retrieves the CA’s
PK from an internal data base and then veriﬁes the bank’s
certiﬁcate. Afterwards, from the bank’s certiﬁcate, the terminal
acquires the bank’s PK and veriﬁes the card’s certiﬁcate, if
applicable. Finally, the terminal acquires the card’s PK from
the card’s certiﬁcate.
B. Ofﬂine Data Authentication
There are three methods for Ofﬂine Data Authentication
(ODA), also known as Card Authentication:
1) Static Data Authentication (SDA): the card supplies the
terminal with the Signed Static Authentication Data
(SSAD), which is the bank’s signature on the card’s static
data such as the PAN, the card’s expiration date, and op-
tionally the AIP. The SDA method prevents modiﬁcation
of the card’s static data, but it does not prevent cloning.
2) Dynamic Data Authentication (DDA): the terminal trans-
mits the INTERNAL AUTHENTICATE command whose
payload is the Dynamic Data Object List (DDOL). The
DDOL must contain the terminal’s Unpredictable Num-
ber. In response to this challenge, the card transmits the
Signed Dynamic Authentication Data (SDAD), which is
the card’s signature on the card’s dynamic data (a fresh
number NC) and the received DDOL. The DDA method
protects against modiﬁcation of card data and cloning.
3) Combined Dynamic Data Authentication (CDA): this is
similar to DDA but it includes the transaction details in
the SDAD, e.g., the transaction amount.
C. Cardholder Veriﬁcation
A Cardholder Veriﬁcation Method (CVM) can be a paper
signature, PIN veriﬁcation, Consumer Device CVM (CD-
CVM), or a combination of these. There are three speciﬁc
methods for PIN veriﬁcation:
1) Ofﬂine Plaintext PIN (or simply plain PIN): the terminal
sends the VERIFY command along with the entered PIN
and the card responds with the success message 9000 if
the PIN is correct, or the failure message 63Cx, where
the digit x is the number of tries left. When no tries
remain, i.e., x = 0, then the card must respond with the
PIN-blocked message 6983 to any subsequent VERIFY
requests.
2) Ofﬂine Enciphered PIN (or simply enciphered PIN): the
terminal sends the GET CHALLENGE command and the
card responds with a random number. Then the termi-
nal issues the VERIFY command whose payload is the
encryption, with the card’s PK, of the entered PIN, the
received random number, and random padding generated
by the terminal. Upon reception, the card decrypts the
payload and responds accordingly, using the messages
described in the plain PIN method.
3) Online Enciphered PIN (or simply online PIN): the card
is not involved. Instead, the terminal sends the entered
PIN encrypted to the issuing bank when requesting the
transaction authorization.
The Consumer Device CVM is intended to be performed
by devices such as mobile phones, which authenticate the
cardholder through ﬁngerprint or face recognition. How the
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:10:50 UTC from IEEE Xplore.  Restrictions apply. 
1769
Fig. 1. An overview of the EMV transaction. Dashed messages and bracketed terms are either optional, or depend on previous steps, or de-
pend on the parties’ choices. For simplicity,
this chart only shows the execution ﬂow in which the card responses have the success trailer 9000.
Notation: ⊕ is exclusive-OR; f is a one-way function; (privC , pubC ), (privB , pubB ), and (privCA, pubCA) are the PKI pairs of the card, the bank, and
the CA, respectively; cert k(cont) is the PKI certiﬁcate on cont signed with the private key k; sign k(m) is the signature on m with the key k; aenck(m)
is the asymmetric encryption of m with the key k; MAC k(m) and MAC (cid:48)
k(m) are Message Authentication Codes on m with the key k; pb(m) is the
right-padding of m with b zero bytes.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:10:50 UTC from IEEE Xplore.  Restrictions apply. 
1770
CardCTerminalTBankBs=f(mk,ATC),randomNCrandomUNs=f(mk,ATC)SELECT,1PAY.SYS.DDF01AID1,AID2,...,AIDnSELECT,AIDxPDOLtags&lengthsGETPROCESSINGOPTIONS,PDOLAIP,AFLREADRECORDPAN,expDate,...,certprivCA(B,pubB),[certprivB(C,pubC,CVMlist,AIP),]CDOLstags&lengths,CVMlistODAstartsSSAD=signprivB(PAN,expDate,AIP)INTERNALAUTHENTICATE,UNSDAD=signprivC(NC,UN)[OfﬂinePINveriﬁcation]TAstartsGENERATEAC,CDOL1X=hPDOL,CDOL1iAC=MACs(X,AIP,ATC,IAD)T=h(X,CID,ATC,AC,IAD)SDAD=signprivC(NC,CID,AC,[T,]UN)CID,ATC,AC/SDAD,IADPAN,AIP,X,ATC,IAD,AC[,aencpubB(PIN)]Y=AC⊕p8(ARC)ARPC=MAC′s(Y)CDOL2=hARC,ARPC,...iGENERATEAC,CDOL2X′=hPDOL,CDOL1,CDOL2iTC=MACs(X′,AIP,ATC,IAD′)T′=h(X′,CID′,ATC,TC,IAD′)SDAD′=signprivC(NC,CID′,TC,[T′,]UN)CID′,ATC,TC/SDAD′,IAD′IAD′,TCterminal and the device conduct CDCVM is out of EMV’s
scope. Nevertheless, this method is the fundamental cause of
one of the new attacks that we report on in this paper.
D. Transaction Authorization
The terminal can decide either to decline the transaction
ofﬂine, to authorize the transaction ofﬂine, or to request online
authorization from the issuing bank. This decision is made
based on various checks such as the ofﬂine ceiling limit, above
which transactions should be processed online.
The terminal sends the GENERATE AC command to the
card, along with the CDOL1. This command instructs the card
to supply the 8-byte Application Cryptogram (AC) which is:
• an Application Authentication Cryptogram (AAC), if the
terminal decided to decline the transaction,
• a Transaction Cryptogram (TC), if the terminal decided
to approve the transaction ofﬂine, or
• an Authorization Request Cryptogram (ARQC), if the
terminal decided to request online authorization.
The requested type of cryptogram is encoded in the com-
mand payload. The card then issues the AC whose type can
be either the requested one, or an ARQC, or an AAC. The
card cannot generate a TC when an ARQC was requested.
The cryptogram is a Message Authentication Code (MAC)
computed over the transaction details,
the AIP, and the
Application Transaction Counter (ATC, which is a 2-byte
counter incremented on every transaction). The MAC’s key
is a session key s derived from the ATC and a symmetric
master key mk shared by the bank and the card. Along with
the cryptogram itself, the card sends other data such as the
1-byte Cryptogram Information Data (CID, which indicates
the type of cryptogram being sent), the transaction counter
ATC, and if CDA was requested in the command payload, the
Signed Dynamic Authentication Data (SDAD). In this case,
the SDAD is a signature on the card’s random number NC,
the CID, the cryptogram, a hash of the transaction details, and
the terminal’s UN.
If the card responds with a TC and the chosen CVM was
not online PIN, then the transaction is approved and the TC
serves as a settlement to instruct the bank to transfer the funds
to the merchant’s account.
If the transaction must be authorized online,
then the
terminal forwards to the bank the transaction details,
the
ARQC, and if online PIN veriﬁcation was the selected CVM,
then also the entered PIN. The bank authorizes or declines