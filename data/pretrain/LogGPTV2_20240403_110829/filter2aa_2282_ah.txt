  bit	
more	
  tedious	
  since	
  the	
  operator	
  would	
  need	
  to	
  manually	
  compute	
  the	
  bits	
  to	
  transmit	
  taking	
  into	
consideration	
  the	
  preamble	
  and	
  parity	
  bits.	
All	
  of	
  the	
  AWID	
  tags	
  I	
  have	
  seen	
  to	
  date	
  have	
  a	
  printed	
  facility	
  code	
  and	
  card	
  number	
  making	
  it	
  possible	
to	
  duplicate	
  the	
  card	
  even	
  from	
  a	
  photograph.	
  This	
  section	
  covers	
  addition	
  of	
  the	
  ‘lf	
  awid	
  sim’	
  command	
to	
  automate	
  the	
  process	
  of	
  simulating	
  a	
  specific	
  AWID	
  tag	
  based	
  on	
  the	
  numbers	
  printed	
  on	
  the	
  card.	
  The	
first	
  step	
  in	
  this	
  process	
  is	
  of	
  course	
  to	
  write	
  a	
  function	
  for	
  encoding	
  a	
  facility	
  code	
  and	
  card	
  number	
  into	
a	
  stream	
  of	
  bits	
  to	
  be	
  transmitted.	
  The	
  logic	
  was	
  coded	
  into	
  getAWIDBits()	
  derived	
  entirely	
  from	
  the	
previously	
  referenced	
  AWID	
  PDF	
  referenced	
  in	
  the	
  T55x7	
  thread.	
  This	
  function	
  does	
  the	
  bit-­‐wise	
operations	
  needed	
  to	
  construct	
  an	
  array	
  of	
  bytes	
  representing	
  the	
  card	
  data.	
  (Parity	
  calculations	
  are	
performed	
  with	
  the	
  existing	
  parityTest()	
  function.)	
  While	
  this	
  code	
  could	
  reside	
  in	
  either	
  the	
  client	
  or	
  the	
device	
  layer,	
  it	
  seems	
  most	
  appropriate	
  to	
  keep	
  this	
  in	
  the	
  client	
  since	
  pm3	
  will	
  not	
  need	
  to	
  perform	
  this	
calculation	
  except	
  when	
  receiving	
  commands	
  from	
  the	
  client	
  and	
  so	
  it	
  was	
  added	
  to	
  client/cmdlfawid.c.	
The	
  next	
  step	
  is	
  to	
  implement	
  code	
  in	
  the	
  client	
  to	
  initiate	
  the	
  tag	
  simulation.	
  While	
  it	
  would	
  be	
  trivial	
  to	
add	
  a	
  specific	
  command	
  definition	
  to	
  the	
  ARM	
  as	
  was	
  done	
  for	
  the	
  fskdemod	
  routine,	
  it	
  is	
  also	
  completely	
unnecessary	
  and	
  since	
  the	
  ARM	
  has	
  a	
  finite	
  storage	
  capacity	
  it	
  seems	
  best	
  to	
  reuse	
  existing	
  code	
  where	
possible.	
  Since	
  we	
  know	
  that	
  the	
  simfsk	
  operation	
  is	
  already	
  implemented,	
  the	
  easiest	
  option	
  is	
  to	
  have	
the	
  client	
  compose	
  and	
  send	
  an	
  appropriate	
  UsbCommand.	
  An	
  example	
  of	
  sending	
  this	
  command	
  is	
available	
  in	
  armsrc/appmain.c	
  revealing	
  that	
  CMD_FSK_SIM_TAG	
  is	
  the	
  appropriate	
  command	
  type	
leading	
  to	
  the	
  ARM	
  function	
  CmdFSKsimTAG().	
  Reviewing	
  the	
  definition	
  of	
  this	
  function	
  (in	
armsrc/lfops.c)	
  illustrates	
  how	
  the	
  command	
  arguments	
  are	
  used.	
  In	
  this	
  function,	
  arg[0]	
  indicates	
  the	
high	
  and	
  low	
  logic	
  sequence,	
  arg[1]	
  combines	
  the	
  clock	
  rate	
  and	
  inversion	
  setting,	
  and	
  arg[2]	
  indicates	
the	
  size	
  in	
  bits	
  of	
  the	
  buffer.	
  The	
  buffer	
  itself	
  is	
  passed	
  in	
  d.asBytes	
  with	
  each	
  byte	
  representing	
  a	
  bit	
  in	
HOW	
  TO	
  TRAIN	
  YOUR	
  RFID	
  HACKING	
  TOOLS	
the	
  intended	
  stream	
  meaning	
  that	
  the	
  12-­‐byte	
  code	
  will	
  need	
  to	
  be	
  represented	
  as	
  96-­‐bytes	
  of	
  true	
  or	
false.	
  The	
  design	
  of	
  getAWIDBits()	
  however	
  is	
  to	
  return	
  bytes	
  in	
  an	
  easily	
  printable	
  format	
  so	
  a	
  for	
  loop	
  is	
used	
  to	
  iterate	
  over	
  each	
  bit	
  setting	
  d.asBytes	
  one	
  byte	
  at	
  a	
  time	
  by	
  iterating	
  over	
  the	
  bits	
  masking	
  out	
  all	
but	
  the	
  relevant	
  bit	
  and	
  setting	
  the	
  byte	
  accordingly.	
As	
  illustrated	
  in	
  figure	
  25,	
  the	
  ‘lf	
  awid	
  sim’	
  command	
  also	
  displays	
  the	
  equivalent	
  ‘lf	
  simfsk’	
  parameters	
  to	
simulate	
  the	
  specific	
  tag. 
Figure	
  25	
  Sample	
  output	
  from	
  'lf	
  awid	
  sim	
  ...'	
Cloning	
  AWID26	
  from	
  facility-­‐code	
  and	
  card	
  number	
As	
  previously	
  described,	
  low-­‐frequency	
  tags	
  can	
  be	
  impersonated	
  by	
  cards	
  with	
  the	
  T55x7	
  family	
  chipset.	
Programming	
  the	
  card	
  requires	
  nothing	
  more	
  than	
  calculating	
  values	
  for	
  each	
  T55x7	
  configuration	
  block	
and	
  writing	
  them	
  to	
  a	
  card.	
  (Figures	
  22	
  and	
  23	
  illustrate	
  this	
  relationship.)	
  As	
  with	
  the	
  simulation	
  code,	
the	
  first	
  step	
  is	
  to	
  translate	
  the	
  badge	
  details	
  into	
  a	
  well-­‐formed	
  AWID26	
  demodulated	
  buffer	
  and	
  then	
split	
  this	
  across	
  the	
  blocks	
  of	
  the	
  T55x7.	
  Once	
  again	
  this	
  functionality	
  could	
  be	
  performed	
  by	
  a	
  dedicated	
function	
  on	
  the	
  ARM	
  side	
  but	
  since	
  T55x7	
  programming	
  functionality	
  already	
  exists	
  it	
  is	
  an	
  easy	
  task	
  to	
have	
  the	
  client	
  automate	
  the	
  task	
  of	
  calculating	
  and	
  programming	
  the	
  tag	
  blocks.	
  Writing	
  to	
  the	
  tag	
  uses	
the	
  CMD_T55XX_WRITE_BLOCK	
  command	
  with	
  arg[0]	
  for	
  the	
  block	
  data	
  (4-­‐byte	
  int),	
  arg[1]	
  indicates	
  the	
block	
  number,	
  and	
  arg[2]	
  could	
  be	
  used	
  for	
  working	
  with	
  a	
  password	
  protected	
  card.	
  Similar	
  to	
  the	
  ‘lf	
awid	
  sim’	
  command,	
  the	
  clone	
  operation	
  also	
  prints	
  the	
  equivalent	
  individual	
  commands	
  as	
  shown	
  below.	
HOW	
  TO	
  TRAIN	
  YOUR	
  RFID	
  HACKING	
  TOOLS	
Figure	
  26	
  Sample	
  output	
  of	
  'lf	
  awid	
  clone	
  ...'	
Ironically	
  this	
  relatively	
  simple	
  functionality	
  actually	
  uncovered	
  a	
  quirky	
  behavior	
  in	
  the	
  communication	
between	
  the	
  client	
  and	
  the	
  device.	
  After	
  submitting	
  the	
  pull	
  request	
  with	
  this	
  function,	
  I	
  received	
feedback	
  from	
  another	
  developer	
  that	
  the	
  clone	
  method	
  was	
  failing	
  after	
  block	
  0.	
  After	
  some	
  back	
  and	
forth	
  we	
  were	
  able	
  to	
  establish	
  that	
  the	
  new	
  code	
  was	
  exposing	
  differences	
  in	
  the	
  serial	
  communication	
as	
  performed	
  by	
  the	
  Windows	
  client	
  versus	
  Linux/OS	
  X	
  clients.	
  On	
  Windows,	
  data	
  was	
  being	
  lost	
  rather	
than	
  buffered	
  when	
  commands	
  are	
  sent	
  from	
  the	
  client	
  in	
  rapid	
  succession.	
  The	
  ideal	
  solution	
  for	
  this	
  is	
to	
  have	
  the	
  client	
  wait	
  for	
  a	
  response	
  from	
  the	
  ARM	
  between	
  each	
  command.	
  This	
  not	
  only	
  eliminates	
  the	
timing	
  issue	
  but	
  also	
  allows	
  the	
  operator	
  to	
  validate	
  that	
  commands	
  were	
  executed.	
  As	
  a	
  short-­‐term	
solution	
  however	
  the	
  logic	
  was	
  updated	
  to	
  include	
  a	
  short	
  delay	
  between	
  each	
  command.	
Replacing	
  LF	
  standalone	
  mode	
  with	
  NFC	
  functions	
Low-­‐frequency	
  and	
  high-­‐frequency	
  RFID	
  both	
  rely	
  on	
  a	
  carrier	
  wave	
  to	
  wirelessly	
  power	
  a	
  chip	
  through	
induction	
  but	
  in	
  practice	
  the	
  two	
  technologies	
  are	
  very	
  different.	
  Near	
  field	
  communication	
  (NFC)	
  is	
based	
  on	
  high-­‐frequency	
  RFID	
  technology	
  with	
  communication	
  as	
  specified	
  by	
  ISO14443	
  standards.	
Whereas	