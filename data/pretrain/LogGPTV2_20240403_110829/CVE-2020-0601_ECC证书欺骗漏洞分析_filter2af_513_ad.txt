    00593ef0  00000004 80000000 0058d278 00000010
    00593f00  00000000 005942a0 abababab abababab
注意标志为0x19的属性，其大小也为0x10。经过对比发现，该属性的内容和a3指向的结构体偏移0xE8处0x10大小的数据相同。而本次SetProperty函数要设置的属性标志为0x18，对应于a3指向的结构体偏移0xF8。
    0:000> dd 5946b0
    005946b0  2848569c b80f667d 65cb78a4 11e4da77
    005946c0  abababab abababab 00000000 00000000
    0:000> dd 005940d8
    005940d8  00000001 00000002 0056b7a8 00000004
    005940e8  00000004 00000000 00000002 00000000
    005940f8  00000000 00000000 00000003 00000000
    00594108  00002000 00000000 00000000 00000000
    00594118  00000000 00000000 00000000 00000000
    00594128  00568ee0 00000000 00000000 00000000
    0:000> dd 005940d8+e8
    005941c0  2848569c b80f667d 65cb78a4 11e4da77
    005941d0  1e7d9e7d 1da15d8d 074bc8c0 cbedec57
现在回顾一下，签名验证成功后，程序将签发者证书CCertObject结构偏移0xE8处的内容复制给证书CCertObject结构偏移0xF8处，并用此值设置了证书的0x18属性，并将证书CCertObject结构偏移0x14处的flag设置为3。后面我们又验证了证书CCertObject结构偏移0xE8处的内容和标志为0x19的属性是一致的，这说明每个证书都有0x19属性，程序先给签发者证书设置了0x19属性，然后同步0xE8处内容（也有可能先设置0xE8处内容，再设置0x19属性），然后又将该内容复制给其签发证书（通过验证）的CCertObject结构的0xF8处。如果ChainGetSubjectStatus函数再次被调用，且a3还是指向这个证书的CCertObject结构，由于其偏移0x14处的flag已经设置了2这个标志位，所以肯定会执行
memcmp((const void )((DWORD *)a3 + 0xF8), *(DWORD *)a1 + 0xE8,
0x10u)，一旦比较成功，函数就会成功返回。
下面我们来看一下证书结构体偏移0xE8处存放的数据从何而来。在CCertObject::CCertObject函数中会初始化CCertObject结构体，后面会执行如下代码，证书的属性就是在这里初始化的。下面这段代码通过CertGetCertificateContextProperty函数获取对应的属性值放进结构体相应的偏移处。这里可以清楚的看到属性0x18、属性0x19以及属性0x14和结构体0xF8、0xE8以及0xE0偏移的对应关系。另外，如果存在0x18属性，就会将结构体偏移0x14处的flag设置1。所以推测flag
2 应该是证书的签名验证成功的标志。
      if ( !CertGetCertificateContextProperty(pCertContext, 0x14u, v12, (DWORD *)v7 + 0x38) )
        goto LABEL_88;
      pcbData = 16;
      if ( !CertGetCertificateContextProperty(pCertContext, 0x19u, (char *)v7 + 0xE8, &pcbData) || pcbData != 0x10 )
        goto LABEL_88;
      pcbData = 16;
      if ( CertGetCertificateContextProperty(pCertContext, 0x18u, (char *)v7 + 0xF8, &pcbData) && pcbData == 0x10 )
        *((_DWORD *)v7 + 5) |= 1u;
CertGetCertificateContextProperty函数最终会调用GetProperty函数来获取对应的属性，该函数会调用DefaultHashCertificate函数来计算相应数据的散列值。如果要获取的属性标志为0x19（v10），则v25被设置为指向证书公钥的缓冲区，v24被设置为公钥长度，计算出的散列值及其长度分别存放在
pbComputedHash和pcbComputedHash中。由于v10为标志0x19，所以该函数第一个参数为0x8003。
    else
    {
      cbEncoded = 0;
      v26 = (struct _RTL_CRITICAL_SECTION *)DefaultHashCertificate(
                                               (v10 == 3) + 0x8003,
                                               (int)v25,
                                              v24,
                                              &pbComputedHash,
                                              &pcbComputedHash);
      v7 = pv;
    }
    goto LABEL_56;
下面为DefaultHashCertificate函数的流程，如果第一个参数为0x8003，则使用MD5算法计算a2指向数据的散列值，并存放在a4指向的内存中。
    v10 = a2;
    ......
    if ( a1 == 0x8003 )
    {
      v7 = 0x10;
      if ( v6 >= 0x10 )
      {
        MD5Init(&v11);
        if ( a3 )
          MD5Update(&v11, v10, a3);
        MD5Final(&v11);
        *a4 = v12;
        a4[1] = v13;
        v9 = a4 + 2;
        *v9 = v14;
        v9[1] = v15;
        v5 = a4;
      }
    }
然后通过SetProperty函数设置其0x19属性（公钥散列值），然后再次调用GetProperty将散列值复制到CCertObject结构偏移0xE8处。我们可以来验证一下，使用python计算系统Microsoft
ECC Product Root Certificate Authority
2018证书公钥的MD5，和之前复制的数据相比较，再次验证了证书CCertObject结构偏移0xE8处存放的就是该证书公钥MD5值。
    >>> import hashlib
    >>> a = "\x04\xc7\x11\x16\x2a\x76\x1d\x56\x8e\xbe\xb9\x62\x65\xd4\xc3\xce\xb4\xf0\xc3\x30\xec\x8f\x6d\xd7\x6e\x39\xbc\xc8\x49\xab\xab\xb8\xe3\x43\x78\xd5\x81\x06\x5d\xef\xc7\x7d\x9f\xce\xd6\xb3\x90\x75\xde\x0c\xb0\x90\xde\x23\xba\xc8\xd1\x3e\x67\xe0\x19\xa9\x1b\x86\x31\x1e\x5f\x34\x2d\xee\x17\xfd\x15\xfb\x7e\x27\x8a\x32\xa1\xea\xc9\x8f\xc9\x7e\x18\xcb\x2f\x3b\x2c\x48\x7a\x7d\xa6\xf4\x01\x07\xac"
    >>> hex(len(a))
    '0x61'
    >>> hashlib.md5(a).hexdigest()
    '7d9e7d1e8d5da11dc0c84b0757ecedcb'
    0:000> db 005941d0 l10
    005941d0  7d 9e 7d 1e 8d 5d a1 1d-c0 c8 4b 07 57 ec ed cb  }.}..]....K.W...
接下来就是0x14偏移处的flag了，这个值还是在CCertObject::CCertObject中被初始化为0，然后在ChainGetSubjectStatus中验证了证书签名并且设置了0x18属性之后被设置为了3。在后续流程中，由于标志2已被设置，所以在CChainPathObject::FindAndAddIssuers函数中跳出了原来的循环，之后又继续调用了CChainPathObject::FindAndAddIssuersByMatchType函数。
      while ( 1 )
      {
        v8 = *(int *)((char *)&dword_5CF10DBC + v7);
        if ( (1 = 0xC )
          return 1;
      }
      if ( CChainPathObject::FindAndAddIssuersByMatchType(this, 4u, a2, a3, a4) )
        return 1;
然后又调用CChainPathObject::FindAndAddIssuersFromStoreByMatchType函数，使用FindElementInCollectionStore函数搜索与之前比较的公钥散列值相匹配的系统信任证书（返回X结构）。
    0:000> dd eax
    005ea490  00000004 00000000 00010000 00000001
    005ea4a0  00579240 005722d0 00000000 00000000
    005ea4b0  005763f0 00000000 00000000 005ea468
    005ea4c0  00000001 00579380 00000327 00579b40
    005ea4d0  005722d0 abababab abababab 00000000
    005ea4e0  00000000 00000000 79bed629 0000e6a4
    005ea4f0  005ea158 0054a9d8 feeefeee feeefeee
    005ea500  61bdd632 1800e6ab 00000003 005ea510
然后通过CCertObject::CCertObject为找到的根证书建立CCertObject结构，然后调用CCertIssuerList::AddIssuer函数，最终会再次调用ChainGetSubjectStatus函数，a1和a3参数分别为系统信任证书和伪造证书签发的证书的结构。由于标志被设置，所以只比较了系统信任证书和伪造证书的公钥散列值（从伪造证书CCertObject结构偏移0xE8处复制到用户证书CCertObject结构偏移0xF8处的数据），如果一样就成功返回。这个时候再来看一眼补丁，新增的ChainComparePublicKeyParametersAndBytes函数有四个参数，从第三、四个参数可以看出，这两个分别为系统信任证书的算法参数（Parameters）和公钥（PublicKey）结构。那么相应的前两个参数应该就是要比较的自签名证书（伪造证书）的算法参数和公钥结构了。
    //ChainGetSubjectStatus
      v37 = ChainComparePublicKeyParametersAndBytes(
              *(int **)(v9 + 0x108),
              *(_DWORD *)(v9 + 0x10C),
              (int *)(*((_DWORD *)pvIssuer + 3) + 0x3C),
              *((_DWORD *)pvIssuer + 3) + 0x44);
      v26 = v37 == 0;
    ----------------------------------------------------------------------------------------------------------      0:000> dt cert_context 05ea4c0
    combase!CERT_CONTEXT
       +0x000 dwCertEncodingType : 1
       +0x004 pbCertEncoded    : 0x00579380  "0???"
       +0x008 cbCertEncoded    : 0x327
       +0x00c pCertInfo        : 0x00579b40 _CERT_INFO
       +0x010 hCertStore       : 0x005722d0 Void
    0:000> dx -r1 ((combase!_CERT_INFO *)0x579b40)
    ((combase!_CERT_INFO *)0x579b40)                 : 0x579b40 [Type: _CERT_INFO *]
        [+0x000] dwVersion        : 0x2 [Type: unsigned long]
        [+0x004] SerialNumber     [Type: _CRYPTOAPI_BLOB]
        [+0x00c] SignatureAlgorithm [Type: _CRYPT_ALGORITHM_IDENTIFIER]
        [+0x018] Issuer           [Type: _CRYPTOAPI_BLOB]
        [+0x020] NotBefore        [Type: _FILETIME]
        [+0x028] NotAfter         [Type: _FILETIME]
        [+0x030] Subject          [Type: _CRYPTOAPI_BLOB]
        [+0x038] SubjectPublicKeyInfo [Type: _CERT_PUBLIC_KEY_INFO]
        [+0x050] IssuerUniqueId   [Type: _CRYPT_BIT_BLOB]
        [+0x05c] SubjectUniqueId  [Type: _CRYPT_BIT_BLOB]
        [+0x068] cExtension       : 0x5 [Type: unsigned long]
        [+0x06c] rgExtension      : 0x579bc0 [Type: _CERT_EXTENSION *]
    0:000> dx -r1 (*((combase!_CERT_PUBLIC_KEY_INFO *)0x579b78))
    (*((combase!_CERT_PUBLIC_KEY_INFO *)0x579b78))                 [Type: _CERT_PUBLIC_KEY_INFO]
        [+0x000] Algorithm        [Type: _CRYPT_ALGORITHM_IDENTIFIER]
        [+0x00c] PublicKey        [Type: _CRYPT_BIT_BLOB]
    0:000> dx -r1 (*((combase!_CRYPT_ALGORITHM_IDENTIFIER *)0x579b78))
    (*((combase!_CRYPT_ALGORITHM_IDENTIFIER *)0x579b78))                 [Type: _CRYPT_ALGORITHM_IDENTIFIER]
        [+0x000] pszObjId         : 0x568f47 : "1.2.840.10045.2.1" [Type: char *]
        [+0x004] Parameters       [Type: _CRYPTOAPI_BLOB]
在第一次调用ChainGetSubjectStatus函数时，如果下级证书的签名验证成功，会分别申请两块内存来存放其签发者证书的算法参数（如果参数存在的话）和公钥数据的结构及数据，即前4个字节为数据的长度，紧接着是指向缓存区的指针。然后分别放在该证书CCertObject结构偏移0x108和0x10C处，以便后续进行比较。
          v17 = PkiZeroAlloc(*(_DWORD *)(v16 + 0x3C) + 8);
          *(_DWORD *)(v9 + 0x108) = v17;
          if ( v17 )
          {
            v18 = v42;
            *v17 = *(_DWORD *)(v42 + 0x3C);
            v17[1] = v17 + 2;
            memcpy(v17 + 2, *(const void **)(v18 + 0x40), *(_DWORD *)(v18 + 0x3C));
    LABEL_30:
            v19 = PkiZeroAlloc(*(_DWORD *)(v42 + 0x44) + 0xC);
            *(_DWORD *)(v9 + 0x10C) = v19;
            if ( v19 )
            {
              v20 = v42;
              *v19 = *(_DWORD *)(v42 + 68);
              v19[1] = v19 + 3;
              memcpy(v19 + 3, *(const void **)(v20 + 0x48), *(_DWORD *)(v20 + 0x44));
然后在新增的ChainComparePublicKeyParametersAndBytes函数中分别比较了两个证书的公钥、算法参数以及它们的长度，如果成功的话就返回0。
    signed int __fastcall ChainComparePublicKeyParametersAndBytes(int *a1, int a2, int *a3, int a4)
    {
      ...
      v9 = 0;
      v10 = 0;
      v4 = a1;
      if ( a2