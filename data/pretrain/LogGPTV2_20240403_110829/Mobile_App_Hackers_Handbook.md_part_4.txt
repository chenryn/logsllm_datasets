protocols such as HTTP or SOAP. This risk incorporates any vulnerability that results in the session tokens
being exposed to an adversary and somewhat overlaps the concepts in “A2 – Broken Authentication and
Session Management” in the web application Top 10 project.
M10: Lack of Binary Protections—This risk addresses the defensive protections that a developer can and
in many cases should build into a mobile application. Binary protections will typically attempt to slow down
an adversary that is attempting to analyze, reverse-engineer, or modify an application’s binary code.
The Top 10 project is undoubtedly a useful resource for raising awareness of the types of vulnerabilities that can
occur in mobile applications. As mobile application security continues to grow we expect that the top 10 project
will evolve to cover new threats as they are discovered, and play an even more important role in educating
developers and security professionals.
OWASP Mobile Security Tools
Whether their purpose is for simply supplementing manual assessments, providing a framework for the
development of other tools, or as a resource to offer remedial or hardening advice for developers, tools are an
important part of any security professional’s arsenal. The OWASP Mobile Security Project has developed a
number of open source security tools
(https://www.owasp.org/index.php/OWASP_Mobile_Security_Project#tab=Mobile_Tools) for the community
that you may find useful in your learning. We briefly describe each of them now:
iMAS (https://www.owasp.org/index.php/OWASP_iMAS_iOS_Mobile_Application_Security_Project)
—Created by the MITRE Corporation, this project is an open source secure application framework for iOS. It
provides an ideal resource for developers or security professionals who want to learn or understand how to
implement security controls for the iOS platform. The goal of the project is to demonstrate and provide
implementations protecting iOS applications and data beyond the Apple-provided security model and as a
consequence reduce an adversary’s ability to reverse engineer, manipulate, and exploit an application. To
achieve this goal, the project has created a number of open source implementations that address several
areas of common vulnerability, including in-application passcodes, jailbreak detection, debugging protection,
and runtime validation. Although we delve into some of these topics in great detail in Chapters 2 and 3, the
iMAS project is certainly a useful resource for learning defensive techniques or as a reference for developers.
GoatDroid (https://www.owasp.org/index.php/Projects/OWASP_GoatDroid_Project)—The GoatDroid
project developed by Jack Mannino and Ken Johnson is a self-contained training environment for Android
applications. The environment provides two sample implementations to hone your skills: FourGoats, a
location-based social network, and Herd Financial, a fictional mobile banking application. Between them,
these two projects provide broad coverage for most of the OWASP Top 10 Mobile Risks and are a good
starting point for beginners in Android application security.
iGoat (https://www.owasp.org/index.php/OWASP_iGoat_Project) —Similar to the GoatDroid project, iGoat
is a training application for improving your iOS assessment knowledge. The project is developed by Ken van
Wyk, Jonathan Carter, and Sean Eidermiller and is open source (https://code.google.com/p/owasp-igoat/).
It provides both a server and client application with a number of exercises covering important topics such as
local storage, the key chain, SQL injection, and more.
Damn Vulnerable iOS (https://www.owasp.org/index.php/OWASP_DVIA) —This project, created by Prateek
Gianchandani, provides another vulnerable iOS application for training purposes. In conjunction with the
iGoat project, the two applications provide good coverage of the OWASP Top 10 Mobile Risks. The
application is comprised of several challenges that you can complete to further your understanding,
including topics that are omitted from iGoat such as jailbreak detection, runtime manipulation, patching,
and cryptography.
MobiSec (https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_–
_MobiSec)—MobiSec is a live environment for penetration testing mobile applications; it is created by Tony
DeLaGrange and Kevin Johnson. The idea behind the project is to provide a single resource to host and
maintain the latest versions of all the individual tools you might need during a mobile application
assessment, in a similar way to other live distributions such as the popular Kali Linux, but in this case
specifically focused on mobile security.
Androick (https://www.owasp.org/index.php/Projects/OWASP_Androick_Project)—This project addresses
a slightly different topic from the other projects and is focused on automating forensic analysis tasks for
Android applications rather than penetration testing or self-learning. The project, created by Florian
Pradines, automates the retrieval of key forensic artifacts such as APKs, application data, databases, and logs
from the device.
Of course, you will encounter and even require many other tools during your adventures in mobile application
security and we document many of these in later chapters. However, the OWASP projects are particularly useful
for self-learning as they’re well documented, open source, and specifically developed to provide coverage for the
Top 10 Mobile Risks project, so we certainly recommend them as a starting point for beginners.
The Future of Mobile Application Security
The explosive rate at which smartphones and mobile applications have been adopted over the past five years has
shown no signs of diminishing, and we expect this trend to continue in the future. The consequence of the
growing mobile revolution will only place further emphasis on understanding the security threats that mobile
deployments face as well as effective ways of addressing them. We do not believe the current threats to mobile
security are at present well understood, particularly in the development communities. As such, we expect that
classic vulnerabilities such as insecure data storage and insufficient transport security will continue to be
prevalent for the immediate future.
That said, mobile application security is a continually evolving landscape and we fully expect new categories of
attacks to arise following advances in mobile technologies. The introduction of new hardware components such
as fingerprint sensors and increased adoption in existing technologies such as NFC will undoubtedly lead to the
discovery of new vulnerabilities, particularly when deployed into environments such as mobile payment
processing, as used by Google Wallet and Apple Pay.
As with other areas of software and particularly those that are used to facilitate monetary transactions,
criminals will seek to take advantage of vulnerabilities for financial gain. We have already seen an increase in
banking malware and premium-rate SMS fraud and expect this trend to continue. This increase has already
somewhat altered the threat landscape and in response, some application developers have begun to employ
binary protections to defend against these threats. As awareness of these threats matures, the adoption of such
protections will likely increase in prominence, along with the use of technologies such as two-factor
authentication.
It is also likely that the evolution of cross-platform mobile applications will continue as developers aim to
reduce fragmentation across the various mobile platforms. This has been witnessed in the growth of two
development trends:
Browser-based applications—This term describes applications that are usually a “mobile friendly” clone
of the main site and loaded via the device’s browser.
Hybrid applications—This term refers to mobile applications that are a native wrapper for a webview and
often use a framework to access native device functionality.
To complement these trends a large number of both commercial and freely available frameworks have been
created, each with its own quirks and intricacies that can lead to a variety of different vulnerabilities. As with
most changes in technology, these trends have brought with them new attacks and variations on existing
attacks; we examine the security implications of these and similar ones in Chapter 18.
Despite all the changes in mobile applications no signs exist that the classic attacks are diminishing. A positive
step toward addressing this, however, is raising awareness of mobile security threats and vulnerabilities through
documentation, classification, and demonstrations such as those being developed by OWASP. Through this and
similar projects we believe that awareness of mobile security can mature and help to provide development
controls to reduce the number of mobile application vulnerabilities.
Summary
Over the past five years the increased popularity of the modern smartphone has contributed to a surge in third-
party application development. Enhancements in smartphone hardware have helped applications rapidly evolve
from simple standalone applications to feature rich offerings that can integrate into multiple online
technologies. During this evolution several technical, economic, and development-related features have
contributed to bring about a weak security posture demonstrated by many of today’s mobile applications.
In addition to the traditional input-based security problems that can affect all types of applications, mobile
applications are also affected by several relatively unique vulnerabilities due to the nature in which they are
used. These issues are often not well understood by developers and can lead to attacks when a device is used on
an untrusted network, when a device is lost or stolen, or even from other components on the mobile platform.
Research on the current state of mobile security has shown that application vulnerabilities are not well
understood and that the majority of applications are vulnerable to attack. Furthermore, the evolution of new
technologies and integrations is likely to produce entirely new attacks, which could pose a serious threat to
organizations that do not react and adapt accordingly.
CHAPTER 2
Analyzing iOS Applications
Apple’s iOS, the platform used by today’s iPhone, iPad, and iPod touch devices, is one of the most popular
mobile operating systems available. For this reason, and with the possible exception of Android, it is the
platform that is targeted the most by hackers and comes under the greatest scrutiny for application layer
vulnerabilities.
With more than one million applications in Apple’s App Store, the attack surface is significant. Numerous
examples of application-based security flaws have been documented, affecting a wide range of applications
including but not limited to those used in banking, retail, and enterprise environments.
This chapter introduces the iOS platform and the ecosystem and provides an introduction to iOS applications. It
sets out in detail the practical steps you can follow to build an environment suitable for testing and exploiting
iOS applications. Finally, it describes the ways in which you can begin to analyze and modify iOS applications to
identify security flaws.
Understanding the Security Model
Before delving into the inner working of iOS applications and the techniques you can use to attack them,
understanding the fundamental security features of the iOS platform itself is important. This not only provides
context to application-based vulnerabilities, but also highlights some of the opt-in features that applications can
take advantage of to improve security.
The core security features of the iOS platform are summarized here:
Secure boot chain
Code signing
Process-level sandboxing
Data-at-rest encryption
Generic native language exploit mitigations:
1. Address space layout randomization
2. Non-executable memory
3. Stack-smashing protection
Apple combines these security technologies, which are implemented as either hardware or software
components, to improve the overall security of iPhone, iPad, and iPod devices. These security features are
present on all non-jailbroken devices and you should take them into consideration when you are assigning risk
ratings to application-based vulnerabilities. Some of these features are documented in the blog post by MDSec
at http://blog.mdsec.co.uk/2012/05/introduction-to-ios-platform-security.html.
Initializing iOS with Secure Boot Chain
The Secure Boot Chain is the term used to describe the process by which the firmware is initialized and loaded
on iOS devices at boot time, and it can be considered the first layer of defense for the security of the platform. In
each step of the Secure Boot Chain, each of the relevant components that have been cryptographically signed by
Apple is verified to ensure that it has not been modified.
When an iOS device is turned on, the processor executes the boot ROM, which is a read-only portion of code
that is contained within the processor and is implicitly trusted by the device; it is burned onto the chip during
manufacturing. The boot ROM contains the public key for Apple’s Root CA, which is used to verify the integrity
of the next step of the Secure Boot Chain, the low-level bootloader (LLB).
The LLB performs a number of setup routines, including locating the iBoot image in flash memory before
booting from it. The LLB looks to maintain the Secure Boot Chain, shown in Figure 2.1, by verifying the
signature of the iBoot image, and if the signature does not match the expected value, the device boots into
recovery mode. iBoot, which is the second-stage bootloader, is responsible for verifying and loading the iOS
kernel, which in turn goes on to load the usermode environment and the OS which you will no doubt be familiar
with.
Figure 2.1 The secure boot chain
Introducing the Secure Enclave
The Secure Enclave is a coprocessor shipped with A7 and A8 chip devices (iPhone 6, iPhone 5s, iPad Air, and
iPad Mini second generation at the time of writing) that uses its own secure boot and software update processes,
independent from the main application processor. The Secure Enclave handles cryptographic operations on the
device, specifically the key management for the Data Protection API and Touch ID fingerprint data. The Secure
Enclave uses a customized version of the ARM TrustZone
(http://www.arm.com/products/processors/technologies/trustzone/index.php) to partition itself from the
main processor and provide data integrity even if the device’s kernel becomes compromised. In short, this
means that if the device is jailbroken or otherwise compromised, extracting cryptographic material such as
biometric fingerprint data from the device should be impossible. For further information about the Secure
Enclave, please refer to the whitepaper release by Apple
(http://www.apple.com/ca/ipad/business/docs/iOS_Security_Feb14.pdf).
Restricting Application Processes with Code Signing
Code signing is perhaps one of the most important security features of the iOS platform. It is a runtime security
feature of the platform that attempts to prevent unauthorized applications from running on the device by
validating the application signature each time it is executed. Additionally, code signing ensures that applications
may execute only code signed by a valid, trusted signature; for example, any attempt made to execute pages in
memory from unsigned sources will be rejected by the kernel.
For an application to run on an iOS device, it must first be signed by a trusted certificate. Developers can install
trusted certificates on a device through a provisioning profile that has been signed by Apple. The provisioning
profile contains the embedded developer certificate and set of entitlements that the developer may grant to
applications. In production applications, all code must be signed by Apple, a process initiated by performing an
App Store submission. This process allows Apple some control over applications and the APIs and functionality
used by developers. For example, Apple looks to prevent applications that use private APIs or applications that
download and install executable code, thus preventing applications from upgrading themselves. Other actions
that Apple deems as banned or potentially malicious will similarly result in application submissions being
rejected from the App Store.
Isolating Applications with Process-Level Sandboxing
All third-party applications on iOS run within a sandbox, a self-contained environment that isolates applications
not only from other applications but also from the operating system. Sandboxing introduces significant security
to the platform and limits the damage that malware can do, assuming a malicious application has subverted the
App Store review process.
Although all applications run as the mobile operating system user, each application is contained within its own
unique directory on the filesystem and separation is maintained by the XNU Sandbox kernel extension. The seat
belt profile governs the operations that can be performed in the sandbox. Third-party applications are assigned
the container profile, which generally limits file access to the application home tree (top-level and all
subsequent directories), and with some exceptions, unrestricted access to outbound network connections. Since
iOS7, the seat belt container profile has been made much more prohibitive and for an application to access
things like media, the microphone, and the address book, it must request the relevant permissions from the
user. This means that assuming a piece of malware has bypassed the App Store review process, it would not be
able to steal your contacts and photos unless you grant it the relevant permissions.
Protecting Information with Data-at-Rest Encryption
By default, all data on the iOS filesystem is encrypted using block-based encryption (AES) with the filesystem
key, which is generated on first boot and stored in block 1 of the NAND flash storage. The device uses this key
during the startup process to decrypt the partition table and the system partition. The filesystem is encrypted
only at rest; when the device is turned on, the hardware-based crypto accelerator unlocks the filesystem. iOS
leverages this key to implement the device’s remote wipe capability because destroying the filesystem key
causes the filesystem to become unreadable.
In addition to the hardware encryption, individual files and keychain items can be encrypted using the Data
Protection API, which uses a key derived from the device passcode. Consequently, when the device is locked,
items encrypted using the Data Protection API in this way will be inaccessible, and upon unlocking the device by
entering the passcode, protected content becomes available.
Third-party applications needing to encrypt sensitive data should use the Data Protection API to do so. However,
consideration should be given for background processes in how they will behave if necessary files become
unavailable due to the device becoming locked. For in-depth details on how the Data Protection API works
consult the later section in this chapter, “Understanding the Data Protection API.”
Protecting Against Attacks with Exploit Mitigation Features
The iOS platform employs a number of modern-day exploit mitigation technologies to increase the complexity
of attacks against the device.
Perhaps one of the most important of these protections is the implementation of the write but not execute
(W^X) memory policy, which states that memory pages cannot be marked as writeable and executable at the
same time. This protection mechanism is applied by taking advantage of the ARM processor’s Execute Never
(XN) feature. As part of this policy, executable memory pages that are marked as writeable cannot also be later
reverted to executable. In many ways this is similar to the Data Execution Protection (DEP) features
implemented in Microsoft Windows, Linux, and Mac OS X desktop OSs.
Although non-executable memory protections alone can be easily bypassed using return-oriented programming
(ROP)–based payloads, the complexity of exploitation is significantly increased when compounded with ASLR
and mandatory code signing.
Address space layout randomization (ASLR) is an integral part of the platform’s exploit mitigation features and
looks to randomize where data and code are mapped in a process’ address space. By randomizing code locations,
exploitation of memory corruption vulnerabilities becomes significantly more complex. This makes techniques
to bypass non-executable memory like ROP difficult because attackers are unlikely to know the location of the
portions of code that they want to reuse in their ROP gadget chain.
ASLR was first introduced to iOS in version beta 4.3 and since its implementation it has gradually improved
with each release. The primary weakness in the early ASLR implementations was the lack of relocation of the
dynamic linker (dyld); this was addressed with the release of iOS 5.0. However, a number of techniques can
weaken its effectiveness, the most common of which is making use of memory disclosure bugs. This generally
involves using a separate vulnerability to leak the contents or confirm memory layout in an effort to make
exploitation attempts much more likely to succeed.
Applications can have ASLR applied in two different flavors: either partial ASLR or full ASLR, depending on
whether they have been compiled with support for position-independent execution (PIE). In a full ASLR
scenario, all the application memory regions are randomized and iOS will load a PIE-enabled binary at a random
address each time it is executed. An application with partial ASLR will load the base binary at a fixed address and
use a static location for the dyld. Although now dated, an in-depth assessment of ASLR in iOS has been
conducted by Stefan Esser and is recommended reading for those looking to gain a greater understanding
(http://antid0te.com/CSW2012_StefanEsser_iOS5_An_Exploitation_Nightmare_FINAL.pdf).
A further protection mechanism that iOS applications can take advantage of is “stack-smashing” protection. This
compiler-based exploit mitigation offers some defense against traditional stack-based overflow exploits by
introducing stack canaries. Stack canaries are pseudo-random DWORD values that are inserted behind local
variables. Stack canaries are checked upon return of the function. If an overflow has occurred and the canary
has been corrupted or overwritten entirely, the application will forcibly terminate to prevent any unintended
behavior that may be brought on by the memory corruption.
Understanding iOS Applications
Although more than a million iOS applications exist in the App Store alone, at a high level one can categorize all
iOS applications into three main groups:
Standard native applications
Browser-based applications
Hybrid applications
Traditional standard native applications are the most common of iOS applications, and these are developed in
Objective-C or more recently in Swift. Objective-C is an object-orientated programming language that adds
Smalltalk-style messaging to the C programming language, whereas Swift is Apple’s new multi-paradigm
programming language that is likely to replace Objective-C in the long term. Both are discussed in greater detail
later in this chapter. Because Objective-C is a strict superset of C, seeing native applications developed in a
mixture of Objective-C, C, or even C++ is not uncommon. These applications are compiled to native code and
linked against the iOS SDK and Cocoa Touch frameworks. Programming in Objective-C and Swift is beyond the
scope of this book; however, knowledge of these languages and their basic principles will be beneficial to your
understanding. If you have never seen any Objective-C or Swift code before, we recommend that you familiarize
yourself with these languages; the documentation provided by the Apple developer program is a useful starting
point (specifically
https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-
CH3-XID_0 and
https://developer.apple.com/library/mac/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html
Browser-based applications are the “mobile-friendly” clone of a web application. These applications are