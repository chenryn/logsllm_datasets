注：在intel
CPU上，glibc在32位和64位体系结构上仍然使用0x10字节的对齐方式，这与上面刚刚描述的常见情况不同。这意味着对于glibc，我们在32位上提供了增强的保护，并且可以阻止16次攻击尝试中的15次。
###  示例
下图显示了我们提交给glibc的初始补丁的片段：
图7：来自补丁程序初始版本的示例代码片段
虽然补丁已经被清除，但是我们仍然可以看到保护glibc的TCache所需的代码修改是非常容易的。这就引出了下一部分基准测试。
###  基准测试
基准测试表明，添加的代码总计为:对于free()2-3个asm指令和对于malloc()3-4个asm指令。在glibc上，即使在GCP中的单个vCPU上总计10亿次malloc()/
free()操作，这种更改可以忽略不计，测试在64位版本的库上运行。下面是在同一GCP服务器上的大小为128
(0x80)字节的缓冲区上运行glibc的基准测试malloco-simple后的结果:
图8:glibc malloc-simple测试结果
每次测试的更快结果用粗体标记。正如我们所看到的，结果几乎是一样的，而且在一半的测试中，修补版本的速度更快，这实际上没有任何意义。这通常意味着服务器上的噪音级别远高于所添加功能对整体结果的实际影响。简而言之，这意味着我们新功能所增加的开销可以忽略不计，这是个好消息。
再举一个例子，对tcmalloc（gperftools）测试的最坏影响是1.5％的开销，而平均值仅为0.02％。
这些测试结果归因于所建议机制的精简设计：
  * 1.该保护没有内存开销。
  * 2.保护不需要初始化。
  * 3.不需要特殊的随机性来源。
  * 4.保护只使用L和P，它们都在指针需要被protect()或reveal()时出现。
需要特别注意的是，FastBin和TCache都使用单链表来保存数据，这一点在glibc的文档中有详细说明。它们只支持put/get
API，没有通用的功能遍历整个列表并保持完整。虽然这种功能确实存在，但它只用于收集malloc统计信息(mallinfo)，因此访问单链接指针的额外开销可以忽略不计。
###  回顾我们的线程模型
对齐检查减少了攻击面，并要求Fastbin或TCache的chunk指向一个对齐的内存地址。这直接阻止了已知的利。
就像Safe-Unlinking一样，我们的保护依赖于这样一个事实：攻击者不知道合法的堆指针是什么样子的。在双链表方案中，能够伪造内存结构并知道有效堆指针的结构的攻击者可以成功伪造有效的FD/BK对指针，该指针不会触发任意写原语，但是允许在攻击者控制的地址上创建一个chunk。
在单链表场景中，没有指针泄漏的攻击者将无法完全控制重写的指针，这是因为保护层依赖于从部署的ASLR继承的随机性。建议PAGE_SHIFT将随机位放在存储的指针的第一个位上。与对齐检查一起，这在阻止了攻击者更改保存的单链指针的最低位/字节(小端)。
###  Chromium’s MaskPtr()
我们的目的是将Safe-Unlinking合并到主要的开放源代码中，这些源代码实现了包含单链表的各种堆。其中一个这样的实现是由Google开发的tcmalloc，它当时只是作为gperftools存储库的一部分开放源码的。在将我们的补丁提交给gperftools之前，我们决定先看看Chromium的Git存储库，以防它们可能使用不同版本的tcmalloc。事实证明，他们做到了。
我们直接查看结果：
  * 1.gperftools自2007年以来已经发布了公开版，最新版本是2.7.90。
  * 2.Chromium的tcmalloc看起来好像是基于gperftool的2.0版本。
  * 3.2020年2月，在我们已经向所有开源提交了补丁程序之后，Google发布了一个官方的[TCMalloc GitHub存储库](https://github.com/google/tcmalloc)，该存储库与之前的两种实现都不相同。
在检查Chromium的版本时，我们发现他们的TCache现在不仅基于双向链表（现在称为FL，for Free
List），而不是基于单链表（最初称为SLL），还添加了一个特别的函数MaskPtr()。仔细查看他们2012年发布的问题，可以看到以下代码片段:
    inline void* MaskPtr(void* p) {
      // Maximize ASLR entropy and guarantee the result is an invalid address.
      const uintptr_t mask =
          ~(reinterpret_cast(TCMalloc_SystemAlloc) >> 13);
      return reinterpret_cast(reinterpret_cast(p) ^ mask);
    }
代码与我们的PROTECT-PTR实现非常相似。此外，这个补丁的作者特别提到“这里的目标是防止使用freelist攻击”
看起来Chromium的安全团队引入了他们自己的Safe-Linking到Chromium的tcmalloc的版本，他们在8年前就这么做了，这让人佩服。
通过检查他们的代码，我们可以看到他们的掩码是基于代码部分（TCMalloc_SystemAlloc）中的一个指针(随机值)，而不是实现中使用的堆位置。另外，它们将地址移位硬编码值13，并且还反转其掩码的位。由于找不到他们设计的文档，我们可以从代码中读取位反转用于确保结果是无效地址。
通过阅读他们的日志，我们还了解到他们估计这个特性的性能开销小于2%。
与我们的设计相比，Chromium的实现包含了一个额外的内存引用和一个额外的asm指令，用于位反转。不仅如此，它们的指针掩码无需额外的对齐检查即可使用，因此代码无法在不导致进程崩溃的情况下提前捕获指针修改。
## 总结
我们测试了补丁程序，以将建议的缓解措施成功集成到最新版本的glibc（ptmalloc），uClibc-NG（dlmalloc），gperftools（tcmalloc）和更高版本的Google全新TCMalloc。此外，我们还指出了Chromium的开发团队使用我们提交给gperftools的版本的“Safe-Linking”，希望我们针对gperftools的性能提升能够在Chromium版本中发挥作用。
当我们开始研究Safe-Linking时，我们相信将Safe-Linking集成到这3个（现在为4个）主流库中，将会导致其他库在开源社区和行业内的封闭软件中得到更广泛的采用。自2012年以来，基础版本的Safe-Linking已嵌入Chromium中，这一事实证明了该解决方案的成熟性。
以下是整合的结果，与撰写此博客文章时的结果相同。
###  glibc（ptmalloc）
**状态** ：集成。将于2020 年8月以2.32版发布。  
 **激活** ：默认情况下打开。
GNU的glibc项目的维护者非常积极响应合作。主要的障碍是签署法律文件，这将使我们作为公司的员工可以向GNU的存储库捐赠GPL许可的源代码。一旦解决了这个问题，过程就非常顺利了，我们的补丁的已提交到最新版本库中，可以在即将发布的版本中使用。
我们要感谢glibc的维护者在整个过程中给予的合作。他们愿意将一个“默认打开”的安全特性集成到他们的项目中，这令人振奋，尤其是与我们最初的期望相比，以及与我们从其他存储库收到的响应相比。
###  uClibc-NG（dlmalloc）
**状态** ：已在v1.0.33版本中发布。  
 **激活** ：默认情况下打开。
向uClibc-NG提交我们的功能非常容易，并且已将其立即集成到此[commit](https://gogs.waldemar-brodkorb.de/oss/uclibc-ng/commit/886878b22424d6f95bcdeee55ada72049d21547c)中。我们可以自豪地说，安全链接已作为uClibc-NG版本v1.0.33的一部分发布。如果我们回到对智能灯泡的研究，此功能将阻止我们的利用，并迫使我们在产品中发现其他漏洞。
我们再次感谢uClibc-NG的维护者在此过程中的合作。
###  gperftools（tcmalloc）
**现状** ：正在进行整合。  
 **激活** ：默认为关闭。
尽管我们之前提到了Chromium的MaskPtr()功能（自2012年起可用），但该功能并未在tcmalloc的两个公开版本中找到它。因此，我们很幸运能向gperftools的tcmalloc实现提交Safe-Linking。
由于gperftools存储库的复杂状态，现在谷歌的官方TCMalloc存储库是公开的，这个过程正在取得进展，但是比较缓慢。在2020年1月开始的pull请求中，您可以看到我们将该特性集成到存储库中的努力。最初的反应是我们担心的:我们的“破坏性能”功能。提醒一下，在使用存储库的标准测试套件时，最坏的情况是产生1.5%的开销，而平均只有0.02%。
最后，我们勉强决定将这个功能添加为“默认关闭”，希望有一天会有人自己激活这个功能。这个特性还没有被合并，但是我们希望它在不久的将来会被合并。
我们仍然要感谢这个项目的唯一维护者，他提供了所有必要的准备工作，以便允许用户使用配置选项来启用Safe-Linking。
###  TCMalloc（tcmalloc）
**状态** ：已拒绝。  
 **激活** ： N / A。
我们在此[pull](https://github.com/google/tcmalloc/pull/19)请求中将补丁提交给了TCMalloc
，但不幸的是，该请求被立即拒绝了。我们再一次听到“此功能的性能成本太高而无法合并”，并且即使作为“默认关闭”可配置功能，他们也不会将其集成：虽然macro-protected,它增加了另一个配置,需要构建并定期测试,以确保一切都保持工作。我们在谷歌中找不到任何能够帮助我们解决与存储库维护者之间的冲突的代表，所以我们让它保持原样。
不幸的是，谷歌最常见的malloc()的实现，在大多数C/C++项目中使用（如TCMOLLC文档中提到的），并没有集成一个安全特性，这使得在他们的项目中利用漏洞变得更加困难。
## 最后说明
Safe-Linking并不是阻止所有针对现代堆实现的攻击尝试的灵丹妙药。然而，这是朝着正确方向迈出的又一步。通过迫使攻击者在开始基于堆的攻击之前就存在指针泄漏漏洞，我们逐渐提高了标准。
从我们过去的经验来看，这种特定的缓解会阻止我们多年来利用的几个主要漏洞，从而将“破坏”的软件产品转变为“无法利用”（至少在我们各自研究项目时存在漏洞）。
还需要注意的是，我们的解决方案不仅限于堆实现。它还可以通过位于用户缓冲区附近的单链表指针来使危险的数据结构获得完整性保护，而不会增加任何内存开销，并且对运行时的影响可以忽略不计。这个解决方案可以很容易地扩展到ASLR系统中的每个单链表。
从我们在2019年底首次解决此问题开始，到设计安全缓解措施，最后将其集成为安全功能，这是一段艰难的旅程，默认情况下，该功能可在世界上两个最著名的libc实现中使用：glibc和uClibc-NG。最后，我们在集成此功能方面取得了比最初预期更好的结果，因此，我们再次感谢所有帮助实现此想法的维护者和研究人员。我们逐渐提高了漏洞利用水平，并帮助保护全世界的用户。