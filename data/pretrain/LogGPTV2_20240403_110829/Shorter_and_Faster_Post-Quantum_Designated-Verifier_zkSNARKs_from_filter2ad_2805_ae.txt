ğ‘ and
v2 âˆˆ ğ‘…ğœ
ğ‘ and âŠ¥ otherwise.
Correctness and security analysis. Below, we state our main theo-
rems on the correctness and security of Construction 3.5. We defer
the formal analysis to the full version of this paper [78].
Theorem 3.6 (Additive Homomorphism). Let ğœ† be a security pa-
rameter and ğ‘, ğ‘, ğ‘›, â„“â€², ğœ’, ğµ be as defined in Construction 3.5. Suppose
ğœ’ is subgaussian5 with parameter ğ‘ . If ğ‘›, â„“â€², ğ‘ , ğ‘‘, ğ›¾ğ‘… = poly(ğœ†), then
for all ğ‘˜ = ğ‘˜(ğœ†), there exists ğ‘ = (ğ‘ğµ + ğ‘˜ğ‘2) Â· poly(ğœ†) such that Con-
struction 3.5 is additively homomorphic with respect to ğ‘…ğ‘˜
ğ‘ . Concretely,
let ğ¶ be a correctness parameter and let ğµ1, ğµ2 be bounds. Define the
set ğ‘† = {y âˆˆ ğ‘…ğ‘˜
ğ‘ : âˆ¥yâˆ¥1 â‰¤ ğµ1 and âˆ¥yâˆ¥2 â‰¤ ğµ2}. If â„“â€², ğ‘› > 8, and
ğ‘ > 2ğ‘(ğµ + ğ›¾ğ‘…ğµ2ğ¶ğ‘  + ğ›¾ğ‘…ğµ1/2 + 2ğ›¾ğ‘…ğ‘›ğ¶2ğ‘ 2) + ğ‘,
(3.4)
then Eq. (3.1) holds with probability 1 âˆ’ (4ğ‘› + 2)ğ‘‘â„“â€² exp(âˆ’ğœ‹ğ¶2) for
all (ğ‘¦1, . . . , ğ‘¦ğ‘˜) âˆˆ ğ‘†.
Theorem 3.7 (CPA Security). Fix a security parameter ğœ† and let
ğ‘, ğ‘, ğ‘›, â„“â€², ğœ’ be as defined in Construction 3.5. Take any ğ‘„ = poly(ğœ†)
and suppose that ğ‘, ğ‘ are coprime. Under the MLWEğ‘›,ğ‘š,ğ‘‘,ğ‘,ğœ’ assump-
tion with ğ‘š = ğ‘› + ğ‘„, Construction 3.5 is ğ‘„-query CPA secure.
5When ğ‘‘ > 1, we assume that ğœ’ is the concatenation of ğ‘‘ independent subgaussian
distributions over Z, each with parameter at most ğ‘ . This is true for discrete Gaussian
distributions over a power-of-two cyclotomic ring.
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea219Theorem 3.8 (Circuit Privacy). Let ğœ† be a security parameter and
ğ‘, ğ‘, ğ‘›, â„“â€², ğœ’ be as defined in Construction 3.5. Suppose that ğœ’ is sub-
gaussian with parameter ğ‘ . If ğ‘›, â„“â€², ğ‘ , ğ‘‘, ğ›¾ğ‘… = poly(ğœ†), and ğµ = 2ğœ”(log ğœ†)Â·
ğ‘˜ğ‘2, then under the MLWEğ‘›,ğ‘š,ğ‘‘,ğ‘,ğœ’ assumption with ğ‘š = ğ‘›, Con-
ğ‘ . Con-
struction 3.5 is circuit private with respect to the set ğ‘† = ğ‘…ğ‘˜
cretely, let ğ¶ be a correctness parameter and let ğµ1, ğµ2 be bounds.
ğ‘ : âˆ¥yâˆ¥1 â‰¤ ğµ1 and âˆ¥yâˆ¥2 â‰¤ ğµ2}. Then under the
Let ğ‘† = {y âˆˆ ğ‘…ğ‘˜
MLWEğ‘›,ğ‘š,ğ‘‘,ğ‘,ğœ’ assumption with ğ‘š = ğ‘›, for every efficient adversary
A restricted to strategies in ğ‘†, there exists an efficient simulator S
where
Pr[ExptCircuitPrivÎ Enc,A,S(1ğœ†) = 1] â‰¤ 1/2 + ğœ€ + negl(ğœ†),
and
ğœ€ = (4ğ‘› + 2)ğ‘‘â„“â€² exp(âˆ’ğœ‹ğ¶2) + ğ‘‘â„“â€²(ğ›¾ğ‘…ğµ2ğ¶ğ‘  + ğ›¾ğ‘…ğµ1/2 + 2ğ›¾ğ‘…ğ‘›ğ¶2ğ‘ 2)
.
(3.5)
ğ‘, ğ‘‘, ğœ be defined as in Construction 3.5. If(cid:12)(cid:12)ğ‘…ğ‘(cid:12)(cid:12)ğœ
Conjecture 3.9 (Linear-Only). Fix a security parameter ğœ† and let
= ğ‘ğœğ‘‘ = ğœ†ğœ”(1), then
Construction 3.5 is strictly linear-only (Definition 3.2).
ğµ
Extensions and variants. In the full version of this paper [78], we
discuss the plausibility of Conjecture 3.9 and describe an extension
of Construction 3.5 to higher-degree extensions and an alternative
approach based on bit decompositions to reduce noise growth.
Modulus switching. The size of the ciphertext in Construction 3.5
is determined by three main parameters: the ring dimension ğ‘‘, the
module dimension ğ‘›, and the ciphertext modulus ğ‘. According to
Theorem 3.6, the modulus ğ‘ must be sufficiently large to support
the required number of homomorphic operations. However, the
modulus switching technique developed in the context of fully
homomorphic encryption [3, 40, 41, 52, 56] provides a way to re-
duce the size of the ciphertexts after performing homomorphic
operations. Specifically, modulus switching allows one to take a ci-
phertext over ğ‘…ğ‘ and convert it to one over ğ‘…ğ‘â€² where ğ‘â€²  ğ‘â€² > ğ‘ and a
ğ‘ , the scale operation outputs the vector xâ€² âˆˆ ğ‘…ğ‘›
vector x âˆˆ ğ‘…ğ‘›
ğ‘â€²
that is closest to (ğ‘â€²/ğ‘) Â· x such that xâ€² = x (mod ğ‘).
We now state the main theorem, adapted from [40]. We provide the
proof in the full version of this paper [78].
Theorem 3.10 (Modulus Switching [40, adapted]). Let ğœ† be a se-
curity parameter and ğ‘, ğ‘, ğ‘›, ğ‘‘, â„“â€², ğœ’ be as defined in Construction 3.5.
Let ğ¶ be a correctness parameter. Suppose that ğœ’ is subgaussian with
parameter ğ‘ . Let ğ‘â€²  ğ‘ğ‘”. Indeed, the construction
of Ben-Sasson et al. uses a specially-chosen elliptic curve group
whose order is divisible by a large power of 2. In our setting, we
consider linear PCPs over a quadratic extension Fğ‘2, whose order
is ğ‘2 âˆ’ 1 = (ğ‘ + 1)(ğ‘ âˆ’ 1). In the best case, if ğ‘ = 2ğ‘‘ Â± 1, then Fğ‘2
has a subgroup of order 2ğ‘‘+1. However, if ğ‘ğ‘” > 2ğ‘, the field Fğ‘2
never has a sufficiently large subgroup to directly compute radix-2
FFTs.6
Our approach. When the field F contains a multiplicative sub-
group whose order is a moderately large power of two (e.g., 2ğ‘‘), we
can still leverage (multiple) radix-2 FFTs to efficiently implement
multipoint polynomial evaluation and interpolation over a domain
ğ· âŠ‚ F of size |ğ·| = ğ‘˜Â·2ğ‘‘ for a (small) ğ‘˜ > 1. We give a brief overview
of our approach here and defer the full details to Appendix D. Let
ğœ” âˆˆ F be a primitive 2ğ‘‘-th root of unity and let ğ» = ğ»1 = âŸ¨ğœ”âŸ© âŠ‚ F
be the subgroup of order 2ğ‘‘ generated by ğœ” (corresponding to the
2ğ‘‘-th roots of unity). We define our domain ğ· (for multipoint eval-
uation and interpolation) to beğ‘–âˆˆ[ğ‘˜] ğ»ğ‘–, where ğ»2, . . . , ğ»ğ‘˜ are
pairwise disjoint cosets of ğ». Polynomial evaluation over ğ· can
be implemented using ğ‘˜ degree-2ğ‘‘ FFTs (over ğ»1), along with 2ğ‘‘
multipoint evaluations of polynomials of degree-ğ‘˜ (over a fixed
basis determined by the cosets). An analogous result holds for inter-
polation. As long as ğ‘˜ < 2ğ‘‘, the smaller evaluation/interpolations
can be implemented in ğ‘˜ log ğ‘˜ time using standard FFTs. In this
case, the running time of our algorithm for evaluating a polynomial
on a domain of size 2ğ‘‘ğ‘˜ is ğ‘‚(2ğ‘‘ğ‘˜(ğ‘‘ + log ğ‘˜)), which matches the
asymptotic complexity of a standard FFT over a domain of the same
size. We give more details in Appendix D. We use this approach to
implement the linear PCP prover when working over fields with
insufficient roots of unity to support a standard radix-2 FFT.
4.2 Lattice-Based zkSNARK Implementation
In this section, we describe our overall zkSNARK implementation.
We begin by describing our methodology for setting the lattice
parameters ğ‘›, ğ‘, ğœ’ for our lattice-based vector encryption scheme
(Construction 3.5). We then describe a few optimizations to improve
the concrete efficiency of the resulting construction.
6While more general algorithms for FFT can be used for multipoint evaluation and
interpolation over a domain whose size is a prime power [90] or a product of coprime
values [72, 104], these algorithms are more complex to implement and worse in terms
of concrete efficiency compared to basic radix-2 FFTs. We show how to implement
our approach using a small number of radix-2 FFTs.
ğœ†ğ‘
128
128
128
128
ğœ†ğ‘
138
138
138
138
ğ‘ 
80
36
64
40
â„“
82
71
109
36
ğ‘
5 Â· 225 + 1
219 âˆ’ 1
213 âˆ’ 1
219 âˆ’ 1
log ğ‘
123
107
98
108
(ğ‘›, ğ‘‘)
(4700, 1)
(4050, 1)
(1815, 2)
(2045, 2)
Fieldsâˆ—
ğœ
5
Fğ‘, Fğ‘
7
Fğ‘2, Fğ‘
5
Fğ‘2, Fğ‘2
4
âˆ— The first field listed is the base field for the linear PCP Î LPCP and the second is
the plaintext field for the linear-only vector encryption scheme Î Enc.
Table 2: Lattice parameters for zkSNARK instantiations ob-
tained by combining the linear PCP Î LPCP from Claim A.6
and Remark A.7 with the linear-only vector encryption
scheme Î Enc from Construction 3.5. Here, ğœ†ğ‘ is the estimated
number of bits of quantum security, ğœ†ğ‘ is the estimated num-
ber bits of classical security, ğ‘ is the plaintext modulus, ğ‘› is