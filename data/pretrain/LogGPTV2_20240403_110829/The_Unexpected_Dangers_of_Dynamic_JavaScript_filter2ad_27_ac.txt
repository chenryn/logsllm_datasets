count on a given website or not. However, out of these
domains, nine domains had scripts with unguessable to-
kens in the URL, therefore these cannot be utilized as
login oracles unless the tokens are known, leaving 40 do-
mains with login oracles.
The most prominent script we found to show such
a behavior is hosted by Google and is part of the
API for Google Plus. This script, which has a seem-
ingly static address, shows differences in three differ-
ent variables, namely isLoggedIn, isPlusUser and
useFirstPartyAuthV2 and hence enables an attacker
to ascertain a user’s login status with Google.
The information obtained from the oracles can be
utilized to provide additional bits to ﬁngerprinting ap-
proaches [7]. It may however also be used by an attacker
to perform a service-speciﬁc phishing attack against his
victim. Oftentimes, spam emails try to phish user cre-
dentials from banks or services the receiving user does
not even have an account on. If, however, the attacker
knows with certainty that the user currently visiting his
USENIX Association  
24th USENIX Security Symposium  729
website is logged in to, e.g., google.com, he can display
a phishing form speciﬁcally aimed at users of Google.
This attack can also be improved if additional informa-
tion about the user is known – we will discuss this attack
later in this section.
4.5.2 Tracking Users
Out of the 40 domains which provided a login oracle, 28
also provided some pieces of data which uniquely iden-
tify a user. Among these features, the most common
identiﬁer was the email address used to register for the
corresponding service, followed by some form of user ID
(such as login name or customer ID). These features can
be used to track users even across device platforms, given
that they log in to a service leaking this information. The
highest-rated service leaking this kind of unique identi-
ﬁer was a top-ranked Chinese search engine. Following
that, we found that a highly-frequented page which fea-
tures a calendar function also contained a script leaking
the email address of the currently logged in user. Since
the owning company also owns other domains which all
use a single sign-on, logging in to any of these sites also
enabled the attack.
4.5.3 Personalized Social Engineering
In many applications, we found that email addresses
were being leaked to an attacker. This information can
be leveraged to construct highly-personalized phishing
attacks against users. As Downs et al. [5] discovered,
users tend to react on phishing emails in more of the
cases if they have a standing business relationship with
the sending entity, i.e. have an account on a given site, or
the email appears to be for them personally.
Hence, gathering information on sites a user has an
account on as well as retrieving additional information
such as his name can aid an attacker in a personalized at-
tack. An attacker may choose to abuse this in two ways –
ﬁrst and foremost, trying to send phishing mails to users
based on the services they have accounts. However, by
learning the email address and hence email provider of
the user, an attacker may also try to phish the user’s mail
account. In our study, we found that 14 different domains
leak email addresses and out of these, ten domains also
revealed (at least) the ﬁrst name of the logged in user.
In addition, two domains leaked the date of birth and
one script, hosted on a Chinese Web site, even contained
the (veriﬁed) mobile phone number of the victim. We
believe that, especially considering the discoveries by
Downs et al., all this information can be leveraged to-
wards creating highly-personalized phishing attacks.
Another form of personalized social engineering at-
tacks enabled by our ﬁndings is targeted advertisement.
We found that two online shopping platforms utilize a
dynamic script which provides the application with the
user’s wish list. This information can be leveraged by an
attacker to either provide targeted advertisements aimed
at proﬁting (e.g. linking to the products on Amazon, us-
ing the attacker’s afﬁliate ID) or to sell fake products
matching the user’s wishes.
Application-Speciﬁc Attacks Alongside the theoreti-
cal attack scenarios we discussed so far, we found multi-
ple applications with issues related to the analyzed leak-
ing scripts as well as several domains with CSRF ﬂaws.
In the following, we discuss these attacks brieﬂy.
Extracting Calendar Entries: One of the most promi-
nent Web sites we could successfully exploit was a mail
service which offers a multitude of additional functional-
ity such as management of contacts and a calendar. The
latter is implemented mostly in JavaScript and retrieves
the necessary bootstrap information when the calendar is
loaded. This script, in the form a function call to a cus-
tom JavaScript API, provides the application with all of
the user’s calendars as well as the corresponding entries.
This script was not protected against inclusion by third-
party hosts and hence, leaks this sensitive information
to an attacker. Alongside the calendar’s and entries, the
script also leaks the e-mail address of the victim, there-
fore allowing the attacker to associate the appointments
to their owner.
Reading Email Senders and Subjects: When logging
in to the portal for a big Chinese Web service provider,
we found that the main page shows the last ﬁve emails
for the currently logged in user. Our browser exten-
sion determined that this information was provided by
an external script, solely using cookies to authenticate
the user. The script contained the username, amount of
unread emails and additionally the senders and subjects
as well as the received dates for the last ﬁve emails of
the victim. An abbreviated excerpt is shown in Listing 6.
Although this attack does not allow for an actual extrac-
tion of the content of an email, at the very least contacts
and topics of current discussions of the victim are leaked
which we believe to be a major privacy issue.
Listing 6 Excerpt of the script leaking mail information
var mailinfo = {
"email": "PI:EMAIL",
...,
"maillist": [{
"mid": "0253FE71.....001",
"mailfrom":"First Last ",
"subject":"Top secret insider information",
"ctime": "2014-05-02 21:11:46"}]
..}
730  24th USENIX Security Symposium 
USENIX Association
Session Hijacking Vulnerabilities: During the course
of our study, we found that two German ﬁle storage ser-
vices contained session hijacking vulnerabilitie. Both
these services are implemented as a JavaScript applica-
tion, which utilizes XMLHttpRequest to retrieve direc-
tory listings and manage ﬁles in the storage. To avoid
unauthorized access to the system, both applications re-
quire a session key to be present within a cookie as well
as in an additional HTTP header. When ﬁrst visiting
the ﬁle storage service, the application loads an external
script called userdata.js which contains the two nec-
essary secrets to access the service: the username and the
aforementioned session key. We found that this script is
not properly protected against cross-domain data leak-
age, allowing an attacker to leak the secret information.
With this information at hand, we were able to list and
access any ﬁle in the victim’s ﬁle storage. Furthermore,
it enabled us to invoke arbitrary actions in the name of
the user such as creating new ﬁles or deleting existing
ones.
One minor drawback in this attack is the need for the
attacker to know the victim’s username in advance, since
the dynamic script requires a GET parameter with the
username. Regardless, we believe that by either targeted
phishing emails or retrieving the email address through
another service (as discussed earlier) this attack is still
quite feasible.
Circumventing CSRF Protection: One way of pre-
venting cross-domain attacks is the use of CSRF tokens,
namely secrets that are either part of the URL (as a GET
parameter) or need to be posted in a form and can then
be veriﬁed by the server. Although CSRF tokens are a
well-understood means of preventing these attacks and
provide adequate security, the proper implementation is
a key factor. In our analysis, we found that two domains
contained scripts which leaked just these critical tokens.
The ﬁrst one was present on a new domain, which re-
quired the knowledge of two secrets in order to change
proﬁle data of the user – a 25 byte long token as well as
the numerical user ID. While browsing the Web site, our
extension detected a state-dependent dynamic script that
exactly contained these two values. As a consequence,
we were able to leak this data and use it to send a properly
authenticated proﬁle change request to the correspond-
ing API. As a consequence, we were able to arbitrarily
change a user’s proﬁle data. Interestingly, one ﬁeld that
was only visible to the user himself contained a stored
XSS vulnerability. Hence, we were able to send a Cross-
Site Scripting payload within this ﬁeld to exploit the, oth-
erwise unexploitable, XSS ﬂaw.
Apart from the obvious issues an XSS attack could
cause, for a user logged in via the Facebook Social Lo-
gin, we could retrieve the Facebook API access token and
hence interact with the Facebook API in the name of the
user, accessing proﬁle information and even make posts
in the name of the user.
Similar to the ﬁrst ﬁnding, we found an issue on the
highly-ranked domain of a weather service. The appli-
cation provides an API for changing a user’s proﬁle as
well as the password, whereas the old password does not
need to be entered to set a new one. Nevertheless, the
API requires knowledge of the email address of the cur-
rently logged in user, thereby employing at least a vari-
ant of a CSRF token. Similar to the previously outlined
ﬂaw, we found a script that provides information on the
user – among which also the email address is contained.
Hence, we could successfully automate the attack by ﬁrst
retrieving the necessary token (email) from the leaking
script and subsequently sending a password change re-
quest to the API. Afterwards, we sent both the email ad-
dress (which is also used as the login name) and the new
password back to our servers, essentially taking over the
user’s account in a fully automated manner.
4.5.4 Notiﬁcation of Vulnerable Sites
In order to allow affected pages to ﬁx the vulnerabili-
ties before they can be exploited, we notiﬁed the security
teams of all domains for which we could successfully
craft exploits. To allow for a better understanding of the
general vulnerability as well as the speciﬁcs of each do-
main, we created a Web site detailing the problem asso-
ciated with cross-domain includes of JavaScript and the
attack pattern. In addition, we created proof-of-concept
exploits for each ﬂaw and shared this information, aug-
mented by a description of the problem and its impact,
e.g., the potential to hijack a user’s session, with the do-
mains owners.
As of this writing, we received only three replies stat-
ing that the ﬂaw was either being dealt with or had
been ﬁxed already. However, none of the affected sites
agreed to be mentioned in the paper, therefore we opted
to anonymize all the vulnerable services we discovered.
4.5.5 Summary of Our Findings
In total, we found that out of the 49 domains which are
dependent on the user’s login state, 40 lack adequate pro-
tection and can therefore be used to deduce if a user is
logged into a certain application. On 28 of these do-
mains, dynamic scripts allowed for unique identiﬁcation
of the current user through various means like customer
IDs or email addresses.
Additionally and partly overlapping with the afore-
mentioned scripts, we found that personal data (such as
the name or location) was contained in scripts on 13 do-
mains. Last but not least, we encountered four domains
which allow for extraction of tokens that could in turn be
USENIX Association  
24th USENIX Security Symposium  731
used to control the target application in the name of the
victimized user. An overview of these results is depicted
in Table 2.
4.6 Non-exploitable Situations
As shown in Table 2, we were not able to leak data from
all of the dynamic scripts we found. In general, we iden-
tiﬁed two different reasons for this: Either the URL of
the script was not guessable by an attacker or the Web
site utilized referrer checking to avoid the inclusion of
resources by third parties. While these mechanisms pro-
tected some Web sites from being exploitable, we believe
that the corresponding countermeasures were not placed
intentionally against the described attack, but were rather
in place because of the used application framework (Re-
ferrer checking) or because of the application’s design
(unguessable URLs). In this section, we brieﬂy discuss
and analyze these situations.
4.6.1 Unguessable URLs
A prerequisite for the attack described in this paper is
that an attacker is able to include a certain script ﬁle into
his page during a user’s visit. For this, the attacker needs
to know the exact URL under which a certain dynamic
script is available.
Some of the scripts we found required a session ID or
another unguessable token to be present in a GET param-
eter of the URL. As the attacker is in general not able to
obtain such a session ID, the script cannot be included by
the attacker and hence sensitive data cannot be leaked.
4.6.2 Referrer Checking
Another technique that prevented us from exploiting a
script leakage vulnerability was referrer checking. When
a browser generates an HTTP request for an embedded
script, it adds the Referer header containing the URL
of the embedding site. Many Web pages tend to misuse
this header as a security feature [31]. By checking the
domain of the referrer, a Web site is in theory able to
ascertain the origin of the page requesting a resource.
In 2006, however, Johns showed that referrer check-
ing has several pitfalls [17]. As the Referer header was
never intended to serve as a security feature, it should
not be used as a reliable source of information. So, for
example, many proxies and middle boxes remove the
Referer header due to privacy concerns. Furthermore,
several situations exist in which a browser does not attach
a Referer header to a request and as discussed by Ko-
towicz, an attacker can intentionally remove the header
from requests [19].
As a consequence, servers should not rely on the pres-
ence of the Referer header. Hence, if a server receives
a request for a dynamic script that does not provide a
Referer header, it needs to decide whether to allow the
request or whether to block it. If the request is allowed,
the attacker may force the removal of the referrer as dis-
cussed before. On the other hand, if the server blocks
the request (strict referrer checking), it might break the
application for users behind privacy-aware proxies.
We found several domains that implemented referrer
checking. However, of seven pages that conducted such
a check, only two conducted strict referrer checking. As
a consequence, the other ﬁve Web sites were still ex-
ploitable by intentionally removing the Referer header.
Listing 7 shows the attack we utilized aiming at stripping
the Referer header. In this example, we use a data URI
assigned to an iframe to embed the leaking script.
Listing 7 Using a data URL within a frame to send a
request without a Referer header
var url = "data:text/html,"
+ ""
+ "";
// create a new iframe
var frame = document.createElement(’iframe’);
// assign the previously created data url
frame.src = url;
body.appendChild(frame);
5 Protection Approach
In our study, we observed a surprisingly high number
of popular Web sites utilizing the dangerous pattern of
using external, dynamically-generated scripts to provide
user-speciﬁc data to an application.
It seems that de-
velopers are not aware of the severe consequences this
practice has. In order to improve this situation, we pro-
vide a secure and functionally-equivalent solution. The
main problem of dynamically generated script includes is
the incorporation of sensitive user data into ﬁles that are
not completely protected by the Same-Origin Policy. We
discourage this practice and advise developers to strictly
separate JavaScript code from sensitive user data.
Figure 2 depicts our design proposal.
In this pro-
posal script code is never generated on the ﬂy, but al-
ways pulled from a static ﬁle. Sensitive and dynamic
data values should be kept in a separate ﬁle, which cannot
be interpreted by the browser as JavaScript. When the
static JavaScript gets executed, it sends an XMLHttpRe-
quest to the ﬁle containing the data. By default access
732  24th USENIX Security Symposium 
USENIX Association
(cid:12)(cid:25)(cid:19)(cid:33)(cid:37)(cid:37)(cid:10)(cid:29)(cid:7)(cid:16)(cid:19)(cid:15)(cid:10)(cid:34)(cid:18)(cid:20)(cid:11)(cid:37)(cid:21)(cid:8)(cid:20)(cid:13)(cid:19)(cid:22)(cid:34)(cid:14)(cid:21)(cid:1)
(cid:12)(cid:25)(cid:19)(cid:33)(cid:37)(cid:37)(cid:10)(cid:29)(cid:7)(cid:16)(cid:19)(cid:15)(cid:10)(cid:34)(cid:18)(cid:20)(cid:11)(cid:37)(cid:9)(cid:7)(cid:22)(cid:7)(cid:34)(cid:14)(cid:21)(cid:18)(cid:17)(cid:1)
(cid:22)(cid:12)(cid:20)(cid:18)(cid:28)(cid:1)(cid:41)(cid:32)(cid:1)
(cid:38)(cid:1)
(cid:1)(cid:1)(cid:35)(cid:26)(cid:21)(cid:10)(cid:20)(cid:17)(cid:7)(cid:16)(cid:10)(cid:35)(cid:33)(cid:1)(cid:35)(cid:5)(cid:18)(cid:12)(cid:17)(cid:4)(cid:18)(cid:10)(cid:35)(cid:31)(cid:1)
(cid:1)(cid:1)(cid:35)(cid:10)(cid:16)(cid:7)(cid:13)(cid:15)(cid:36)(cid:33)(cid:1)(cid:35)(cid:14)(cid:18)(cid:12)(cid:17)(cid:40)(cid:10)(cid:29)(cid:7)(cid:16)(cid:19)(cid:15)(cid:10)(cid:34)(cid:18)(cid:20)(cid:11)(cid:36)(cid:1)
(cid:39)(cid:1)
(cid:6)(cid:10)(cid:20)(cid:27)(cid:10)(cid:20)(cid:1)