代码清单 /463/46-020.php
 输入个人信息 
姓名 :">
邮箱地址 :">
代码清单 /463/46-021.php
 确认个人信息 
姓名 :
邮箱地址 :
 返回 
代码清单 /463/46-022.php
 注册个人信息 
已注册 
姓名 :
邮箱地址 :
正常情况下的页面跳转如下。
图 4-57 页面跳转
接下来我们就尝试对此应用实施攻击。诱导用户使用以下 URL 访问应用并使其输入个人信息。
http://example.jp/463/46-020.php?PHPSESSID=ABC
受害用户输入自己的个人信息，如下图所示。
图 4-58 受害用户输入个人信息
而在另一边，攻击者会定期监视刚才的 URL 页面。当用户输入个人信息后，如下图所示，攻击者的浏览器中也能显示用户的个人信息。
图 4-59 受害用户的个人信息显示在攻击者的浏览器中
由此可见，不需要认证的网页如果使用了会话变量，也可能会遭受会话固定攻击。
但是，由于此情况下攻击者无法伪装成登录后的用户，也无法使用用户的权限进行恶意操作，因此攻击造成的影响就仅限于用户输入的信息被泄漏。
会话采纳
前面所介绍的攻击流程中使用了 PHPSESSID=ABC 这个会话 ID。我们发现，虽然 ABC 是攻击者任意生成的，但是也能够使攻击得到成功。这是因为能够接受来源不明的会话 ID 是 PHP 的特性之一。而此特性就被称为会话采纳（Session Adoption）。除了 PHP，ASP.NET 中也存在会话采纳的特征。而 PHP 和 ASP.NET 以外的中间件，如 Tomcat 等则不存在会话采纳，这种情况下，随意生成的会话 ID 就会被忽略。
在对不存在会话采纳的中间件上运行的应用程序发动攻击时，攻击者会先浏览攻击目标应用，取得有效的会话 ID，然后再利用此会话 ID 布置恶意网站。
由此可见，开发工具中若存在会话采纳就能减少会话固定攻击的步骤，然而，即便不存在会话采纳问题，会话固定攻击也不可能被完全杜绝。
仅在 Cookie 中保存会话 ID 的网站固定会话 ID
之前介绍的攻击示例中，我们使用的都是能够将会话 ID 保存在 URL 中的应用程序。这是因为会话 ID 保存在 URL 的情况下攻击起来比较容易。然而，仅将会话 ID 保存在 Cookie 时，会话 ID 还是有可能会被固定化。
通常情况下，从外部设置 Cookie 的会话 ID 是行不通的，但是，如果浏览器或 Web 应用中存在安全隐患就另当别论了。比如，以下安全隐患就有可能造成 Cookie 被第三方设置。
Cookie Monster Bug（浏览器的安全隐患，参考 3.1 节）
跨站脚本漏洞（参考 4.3 节）
HTTP 消息头注入漏洞（参考 4.7.2）
会话固定攻击的影响
一旦会话固定攻击取得成功，由于中招的用户（前例中为 tanaka）已处于登录状态，攻击者就能够使用该用户的权限执行操作或浏览信息等。
安全隐患的产生原因
固定会话 ID 安全隐患产生的根本原因为外界能够劫持会话 ID。因此，彻底应对就需要实施以下所有步骤。
不将会话 ID 嵌入 URL
不使用（或不让用户使用）存在 Cookie Monster Bug39
 的浏览器
不使用易发生 Cookie Monster Bug 的地域型域名
消除跨站脚本漏洞
消除 HTTP 消息头注入漏洞
消除其他能够导致 Cookie 被篡改的安全隐患
39
 Cookie Monster Bug 的详情请参考 3.1 节的专栏。
但是，想要满足以上所有条目并不简单。比如 Internet Explorer 中使用地域型域名时就存在 Cookie Monster Bug，而微软似乎并没有打算修复该问题。然而，Internet Explorer 又是使用率最高的浏览器，我们不可能强迫所有用户将其舍弃。
因此，目前采取的普遍做法是，姑且允许会话 ID 被外界挟持，而将防范重点放在防止会话固定攻击造成会话劫持上。
在认证成功时更改会话 ID 就是一种行之有效的方法，具体会在后面详述。
对策
正如前面所介绍的那样，会话 ID 被外界固定化的手段多种多样，有时还会恶意利用浏览器的 Bug（安全隐患），因此，Web 应用中防范会话固定攻击可以采取如下策略。
认证后更改会话 ID
PHP 中执行此处理可以使用 session_regenerate_id
 函数。该函数的格式如下。
格式清单 session_regenerate_id 函数
bool session_regenerate_id([bool $delete_old_session = false])
session_regenerate_id
 函数中有一个可省略的参数。但由于该参数会指定是否将变更前的会话 ID 对应的会话信息删除，所以应始终将该参数指定为 true
 。
下面为添加了更改会话 ID 这一处理的脚本。
代码清单 /463/46-011a.php
 登录成功 
 个人信息 
无法更改会话 ID 时采用令牌
有些 Web 应用的开发语言或中间件无法在程序中显式地更改会话 ID。使用此类开发工具时，可以使用令牌来防范会话固定攻击。
具体方法为，在登录时生成一个随机数字符串（令牌），并将其同时保存至 Cookie 和会话变量中。然后在各页面进行认证确认时比较 Cookie 和会话变量中的令牌值，如果两者一致即视为已认证，不一致时即视为认证错误。
由于只有在登录的时候令牌才能够被传到外界，攻击者无法得知令牌值，因此，使用令牌能够成功防御会话固定攻击。
此外，鉴于令牌需要确保在足够长的时间内无法被预测，生成令牌时应当使用密码学级别的伪随机数生成器。由于 PHP 中没有提供能够调用伪随机数生成器的函数，因此，这里我们使用“改善 PHP 的会话 ID 的随机性的方法”中提到的 /dev/urandom 来进行说明。
以下为登录后生成令牌部分的脚本。
代码清单 /463/46-015.php
 认证成功  
虽然示例中使用的是 PHP，但由于 PHP 中提供了 session_regenerate_id
 函数，因此并非一定要使用令牌。然而，由于令牌也能够作为 4.8.2 节讲述的“Cookie 的安全属性设置不完善”的对策来使用，因此，某些情况下该方法对 PHP 开发者来说会非常有用。详情请参考 4.8 节。
登录前的会话固定攻击的对策
如果登录前使用了会话变量，要完全防范会话固定攻击就非常困难。这种情况下，比较现实而有效的对策就是，登录前不使用会话管理机制，而使用 hidden 参数来传递值。
像电子商务网站的购物车功能这种不得不在登录前使用会话变量的情况下，可以参考以下对策。但要注意的是，这些都不是根本性的对策，而只能通过组合使用来提高防御能力。
不在登录前的会话变量内存储敏感信息
不使用嵌入 URL 的会话 ID
不使用地域型域名
总结
本节讲述了不完善的会话管理所导致的会话劫持。会话管理是安全性的要害之处，因此，若出现会话劫持的话就会造成巨大影响。
会话管理不完善的对策如下。
不自制会话管理机制而使用 Web 应用开发工具的内置功能
将会话 ID 保存至 Cookie 中
认证成功时更改会话 ID
认证前不在会话变量中存储敏感信息