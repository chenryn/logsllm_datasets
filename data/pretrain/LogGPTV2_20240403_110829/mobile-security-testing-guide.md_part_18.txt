Android")
Debuggable flag: debuggable (see "Code Quality and Build Settings of Android Apps")
Please refer to the mentioned chapters to learn more about how to test each of these points.
App Binary
As seen above in "Exploring the App Package", the app binary ( classes.dex ) can be found in the root directory of the
app package. It is a so-called DEX (Dalvik Executable) file that contains compiled Java code. Due to its nature, after
applying some conversions you'll be able to use a decompiler to produce Java code. We've also seen the folder
smali that was obtained after we run apktool. This contains the disassembled Dalvik bytecode in an intermediate
language called smali, which is a human-readable representation of the Dalvik executable.
Refer to the section "Statically Analyzing Java Code" in the chapter "Tampering and Reverse Engineering on Android"
for more information about how to reverse engineer DEX files.
Native Libraries
You can inspect the lib folder in the APK:
$ ls -1 lib/armeabi/
libdatabase_sqlcipher.so
libnative.so
libsqlcipher_android.so
libstlport_shared.so
135
Setting up a Testing Environment for Android Apps
or from the device with objection:
...g.vp.owasp_mobile.omtg_android on (google: 8.1.0) [usb] # ls lib
Type ... Name
------ ... ------------------------
File ... libnative.so
File ... libdatabase_sqlcipher.so
File ... libstlport_shared.so
File ... libsqlcipher_android.so
For now this is all information you can get about the native libraries unless you start reverse engineering them, which
is done using a different approach than the one used to reverse the app binary as this code cannot be decompiled but
only disassembled. Refer to the section "Statically Analyzing Native Code" in the chapter "Tampering and Reverse
Engineering on Android" for more information about how to reverse engineer these libraries.
Other App Resources
It is normally worth taking a look at the rest of the resources and files that you may find in the root folder of the APK as
some times they contain additional goodies like key stores, encrypted databases, certificates, etc.
Accessing App Data Directories
Once you have installed the app, there is further information to explore, where tools like objection come in handy.
When using objection you can retrieve different kinds of information, where env will show you all the directory
information of the app.
$ objection -g sg.vp.owasp_mobile.omtg_android explore
...g.vp.owasp_mobile.omtg_android on (google: 8.1.0) [usb] # env
Name Path
---------------------- ---------------------------------------------------------------------------
cacheDirectory /data/user/0/sg.vp.owasp_mobile.omtg_android/cache
codeCacheDirectory /data/user/0/sg.vp.owasp_mobile.omtg_android/code_cache
externalCacheDirectory /storage/emulated/0/Android/data/sg.vp.owasp_mobile.omtg_android/cache
filesDirectory /data/user/0/sg.vp.owasp_mobile.omtg_android/files
obbDir /storage/emulated/0/Android/obb/sg.vp.owasp_mobile.omtg_android
packageCodePath /data/app/sg.vp.owasp_mobile.omtg_android-kR0ovWl9eoU_yh0jPJ9caQ==/base.apk
Among this information we find:
The internal data directory (aka. sandbox directory) which is at /data/data/[package-name] or
/data/user/0/[package-name]
The external data directory at /storage/emulated/0/Android/data/[package-name] or
/sdcard/Android/data/[package-name]
The path to the app package in /data/app/
The internal data directory is used by the app to store data created during runtime and has the following basic
structure:
...g.vp.owasp_mobile.omtg_android on (google: 8.1.0) [usb] # ls
Type ... Name
--------- ... -------------------
Directory ... cache
Directory ... code_cache
Directory ... lib
Directory ... shared_prefs
Directory ... files
136
Setting up a Testing Environment for Android Apps
Directory ... databases
Readable: True Writable: True
Each folder has its own purpose:
cache: This location is used for data caching. For example, the WebView cache is found in this directory.
code_cache: This is the location of the file system's application-specific cache directory designed for storing
cached code. On devices running Android 5 (API level 21) or later, the system will delete any files stored in this
location when the app or the entire platform is upgraded.
lib: This folder stores native libraries written in C/C++. These libraries can have one of several file extensions,
including .so and .dll (x86 support). This folder contains subdirectories for the platforms the app has native
libraries for, including
armeabi: compiled code for all ARM-based processors
armeabi-v7a: compiled code for all ARM-based processors, version 7 and above only
arm64-v8a: compiled code for all 64-bit ARM-based processors, version 8 and above based only
x86: compiled code for x86 processors only
x86_64: compiled code for x86_64 processors only
mips: compiled code for MIPS processors
shared_prefs: This folder contains an XML file that stores values saved via the SharedPreferences APIs.
files: This folder stores regular files created by the app.
databases: This folder stores SQLite database files generated by the app at runtime, e.g., user data files.
However, the app might store more data not only inside these folders but also in the parent folder
( /data/data/[package-name] ).
Refer to the "Testing Data Storage" chapter for more information and best practices on securely storing sensitive data.
Monitoring System Logs
On Android you can easily inspect the log of system messages by using Logcat . There are two ways to execute
Logcat:
Logcat is part of Dalvik Debug Monitor Server (DDMS) in Android Studio. If the app is running in debug mode, the
log output will be shown in the Android Monitor on the Logcat tab. You can filter the app's log output by defining
patterns in Logcat.
You can execute Logcat with adb to store the log output permanently:
$ adb logcat > logcat.log
With the following command you can specifically grep for the log output of the app in scope, just insert the package
name. Of course your app needs to be running for ps to be able to get its PID.
137
Setting up a Testing Environment for Android Apps
$ adb logcat | grep "$(adb shell ps | grep  | awk '{print $2}')"
Setting up a Network Testing Environment
Basic Network Monitoring/Sniffing
Remotely sniffing all Android traffic in real-time is possible with tcpdump, netcat (nc), and Wireshark. First, make sure
that you have the latest version of Android tcpdump on your phone. Here are the installation steps:
$ adb root
$ adb remount
$ adb push /wherever/you/put/tcpdump /system/xbin/tcpdump
If execution of adb root returns the error adbd cannot run as root in production builds , install tcpdump as follows:
$ adb push /wherever/you/put/tcpdump /data/local/tmp/tcpdump
$ adb shell
$ su
$ mount -o rw,remount /system;
$ cp /data/local/tmp/tcpdump /system/xbin/
$ cd /system/xbin
$ chmod 755 tcpdump
Remember: To use tcpdump, you need root privileges on the phone!
Execute tcpdump once to see if it works. Once a few packets have come in, you can stop tcpdump by pressing
CTRL+c.
$ tcpdump
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on wlan0, link-type EN10MB (Ethernet), capture size 262144 bytes
04:54:06.590751 00:9e:1e:10:7f:69 (oui Unknown) > Broadcast, RRCP-0x23 reply
04:54:09.659658 00:9e:1e:10:7f:69 (oui Unknown) > Broadcast, RRCP-0x23 reply
04:54:10.579795 00:9e:1e:10:7f:69 (oui Unknown) > Broadcast, RRCP-0x23 reply
^C
3 packets captured
3 packets received by filter
0 packets dropped by kernel
To remotely sniff the Android phone's network traffic, first execute tcpdump and pipe its output to netcat (nc):
$ tcpdump -i wlan0 -s0 -w - | nc -l -p 11111
The tcpdump command above involves
listening on the wlan0 interface,
defining the size (snapshot length) of the capture in bytes to get everything (-s0), and
writing to a file (-w). Instead of a filename, we pass - , which will make tcpdump write to stdout.
By using the pipe ( | ), we sent all output from tcpdump to netcat, which opens a listener on port 11111. You'll usually
want to monitor the wlan0 interface. If you need another interface, list the available options with the command $ ip
addr .
To access port 11111, you need to forward the port to your machine via adb.
$ adb forward tcp:11111 tcp:11111
138
Setting up a Testing Environment for Android Apps
The following command connects you to the forwarded port via netcat and piping to Wireshark.
$ nc localhost 11111 | wireshark -k -S -i -
Wireshark should start immediately (-k). It gets all data from stdin (-i -) via netcat, which is connected to the forwarded
port. You should see all the phone's traffic from the wlan0 interface.
You can display the captured traffic in a human-readable format with Wireshark. Figure out which protocols are used
and whether they are unencrypted. Capturing all traffic (TCP and UDP) is important, so you should execute all
functions of the tested application and analyze it.
This neat little trick allows you now to identify what kind of protocols are used and to which endpoints the app is
talking to. The questions is now, how can I test the endpoints if Burp is not capable of showing the traffic? There is no
easy answer for this, but a few Burp plugins that can get you started.
Firebase/Google Cloud Messaging (FCM/GCM)
Firebase Cloud Messaging (FCM), the successor to Google Cloud Messaging (GCM), is a free service offered by
Google that allows you to send messages between an application server and client apps. The server and client app
communicate via the FCM/GCM connection server, which handles downstream and upstream messages.
139
Setting up a Testing Environment for Android Apps
Downstream messages (push notifications) are sent from the application server to the client app; upstream messages
are sent from the client app to the server.
FCM is available for Android, iOS, and Chrome. FCM currently provides two connection server protocols: HTTP and
XMPP. As described in the official documentation, these protocols are implemented differently. The following example
demonstrates how to intercept both protocols.
Preparation of Test Setup
You need to either configure iptables on your phone or use bettercap to be able to intercept traffic.
FCM can use either XMPP or HTTP to communicate with the Google backend.
HTTP
FCM uses the ports 5228, 5229, and 5230 for HTTP communication. Usually, only port 5228 is used.
Configure local port forwarding for the ports used by FCM. The following example applies to Mac OS X:
$ echo "
rdr pass inet proto tcp from any to any port 5228-> 127.0.0.1 port 8080
rdr pass inet proto tcp from any to any port 5229 -> 127.0.0.1 port 8080
rdr pass inet proto tcp from any to any port 5230 -> 127.0.0.1 port 8080
" | sudo pfctl -ef -
The interception proxy must listen to the port specified in the port forwarding rule above (port 8080).
XMPP
For XMPP communication, FCM uses ports 5235 (Production) and 5236 (Testing).
Configure local port forwarding for the ports used by FCM. The following example applies to Mac OS X:
$ echo "
rdr pass inet proto tcp from any to any port 5235-> 127.0.0.1 port 8080
rdr pass inet proto tcp from any to any port 5236 -> 127.0.0.1 port 8080
" | sudo pfctl -ef -
Intercepting the Requests
The interception proxy must listen to the port specified in the port forwarding rule above (port 8080).
Start the app and trigger a function that uses FCM. You should see HTTP messages in your interception proxy.
140
Setting up a Testing Environment for Android Apps
End-to-End Encryption for Push Notifications
As an additional layer of security, push notifications can be encrypted by using Capillary. Capillary is a library to
simplify the sending of end-to-end (E2E) encrypted push messages from Java-based application servers to Android
clients.
Setting Up an Interception Proxy
Several tools support the network analysis of applications that rely on the HTTP(S) protocol. The most important tools
are the so-called interception proxies; OWASP ZAP and Burp Suite Professional are the most famous. An interception
proxy gives the tester a man-in-the-middle position. This position is useful for reading and/or modifying all app
requests and endpoint responses, which are used for testing Authorization, Session, Management, etc.
Interception Proxy for a Virtual Device
Setting Up a Web Proxy on an Android Virtual Device (AVD)
The following procedure, which works on the Android emulator that ships with Android Studio 3.x, is for setting up an
HTTP proxy on the emulator:
1. Set up your proxy to listen on localhost and for example port 8080.
2. Configure the HTTP proxy in the emulator settings:
Click on the three dots in the emulator menu bar
Open the Settings Menu
Click on the Proxy tab
Select "Manual proxy configuration"
Enter "127.0.0.1" in the "Host Name" field and your proxy port in the "Port number" field (e.g., "8080")
Tap "Apply"
141
Setting up a Testing Environment for Android Apps
HTTP and HTTPS requests should now be routed over the proxy on the host machine. If not, try toggling airplane
mode off and on.
A proxy for an AVD can also be configured on the command line by using the emulator command when starting an
AVD. The following example starts the AVD Nexus_5X_API_23 and setting a proxy to 127.0.0.1 and port 8080.
$ emulator @Nexus_5X_API_23 -http-proxy 127.0.0.1:8080
Installing a CA Certificate on the Virtual Device
An easy way to install a CA certificate is to push the certificate to the device and add it to the certificate store via
Security Settings. For example, you can install the PortSwigger (Burp) CA certificate as follows:
1. Start Burp and use a web browser on the host to navigate to burp/, then download cacert.der by clicking the
"CA Certificate" button.
2. Change the file extension from .der to .cer .
3. Push the file to the emulator:
$ adb push cacert.cer /sdcard/
4. Navigate to "Settings" -> "Security" -> "Install from SD Card".
5. Scroll down and tap cacert.cer .
You should then be prompted to confirm installation of the certificate (you'll also be asked to set a device PIN if you
haven't already).
For Android 7 and above follow the same procedure described in the "Bypassing the Network Security Configuration"
section.
Interception Proxy for a Physical Device
The available network setup options must be evaluated first. The mobile device used for testing and the machine
running the interception proxy must be connected to the same Wi-Fi network. Use either an (existing) access point or
create an ad-hoc wireless network.
Once you've configured the network and established a connection between the testing machine and the mobile
device, several steps remain.
142
Setting up a Testing Environment for Android Apps
The proxy must be configured to point to the interception proxy.
The interception proxy's CA certificate must be added to the trusted certificates in the Android device's certificate
storage. The location of the menu used to store CA certificates may depend on the Android version and Android
OEM modifications of the settings menu.
Some application (e.g. the Chrome browser) may show NET::ERR_CERT_VALIDITY_TOO_LONG errors, if the leaf
certificate happens to have a validity extending a certain time (39 months in case of Chrome). This happens if the
default Burp CA certificate is used, since the Burp Suite issues leaf certificates with the same validity as its CA
certificate. You can circumvent this by creating your own CA certificate and import it to the Burp Suite, as
explained in a blog post on nviso.be.
After completing these steps and starting the app, the requests should show up in the interception proxy.
A video of setting up OWASP ZAP with an Android device can be found on secure.force.com.
A few other differences: from Android 8 onward, the network behavior of the app changes when HTTPS traffic is
tunneled through another connection. And from Android 9 onward, the SSLSocket and SSLEngine will behave a little
bit different in terms of erroring when something goes wrong during the handshakes.
As mentioned before, starting with Android 7, the Android OS will no longer trust user CA certificates by default,
unless specified in the application. In the following section, we explain two methods to bypass this Android security
control.
Bypassing the Network Security Configuration
From Android 7 onwards, the network security configuration allows apps to customize their network security settings,
by defining which CA certificates the app will be trusting.
In order to implement the network security configuration for an app, you would need to create a new xml resource file
with the name network_security_config.xml . This is explained in detail in one of the Google Android Codelabs.
After the creation, the apps must also include an entry in the manifest file to point to the new network security
configuration file.
...
The network security configuration uses an XML file where the app specifies which CA certificates will be trusted.
There are various ways to bypass the Network Security Configuration, which will be described below. Please also see
the Security Analystâ€™s Guide to Network Security Configuration in Android P for further information.
# Adding the User Certificates to the Network Security Configuration
There are different configurations available for the Network Security Configuration to add non-system Certificate
Authorities via the src attribute:
Each certificate can be one of the following:
- a "raw resource" ID pointing to a file containing X.509 certificates
- "system" for the pre-installed system CA certificates
- "user" for user-added CA certificates
143
Setting up a Testing Environment for Android Apps
The CA certificates trusted by the app can be a system trusted CA as well as a user CA. Usually you will have a
dded the certificate of your interception proxy already as additional CA in Android. Therefore we will focus on