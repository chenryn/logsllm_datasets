### Debuggable Flag: `debuggable`
For more information on the `debuggable` flag and its implications for code quality and build settings in Android apps, refer to the "Code Quality and Build Settings of Android Apps" chapter. This section will provide you with a deeper understanding of how to test and manage this flag.

### App Binary
As discussed in the "Exploring the App Package" section, the app binary, typically named `classes.dex`, is located in the root directory of the app package. This file is a DEX (Dalvik Executable) that contains compiled Java code. After applying certain conversions, you can use a decompiler to convert the DEX file back into Java source code.

Additionally, when using tools like `apktool`, you may encounter a folder named `smali`. This folder contains the disassembled Dalvik bytecode in an intermediate language called Smali, which is a human-readable representation of the Dalvik executable. For more details on reverse engineering DEX files, refer to the "Statically Analyzing Java Code" section in the "Tampering and Reverse Engineering on Android" chapter.

### Native Libraries
You can inspect the `lib` folder within the APK to find native libraries. For example:
```sh
$ ls -1 lib/armeabi/
libdatabase_sqlcipher.so
libnative.so
libsqlcipher_android.so
libstlport_shared.so
```
Alternatively, you can use `objection` to list the libraries from a connected device:
```sh
...g.vp.owasp_mobile.omtg_android on (google: 8.1.0) [usb] # ls lib
Type ... Name
------ ... ------------------------
File ... libnative.so
File ... libdatabase_sqlcipher.so
File ... libstlport_shared.so
File ... libsqlcipher_android.so
```
To reverse engineer these native libraries, you need to use different techniques than those used for the app binary, as native code cannot be decompiled but only disassembled. Refer to the "Statically Analyzing Native Code" section in the "Tampering and Reverse Engineering on Android" chapter for more information.

### Other App Resources
It's often beneficial to examine other resources and files in the root folder of the APK. These may include key stores, encrypted databases, and certificates, among other items.

### Accessing App Data Directories
After installing the app, you can explore additional information using tools like `objection`. The `env` command in `objection` will display the directory structure of the app:
```sh
$ objection -g sg.vp.owasp_mobile.omtg_android explore
...g.vp.owasp_mobile.omtg_android on (google: 8.1.0) [usb] # env
Name Path
---------------------- ---------------------------------------------------------------------------
cacheDirectory /data/user/0/sg.vp.owasp_mobile.omtg_android/cache
codeCacheDirectory /data/user/0/sg.vp.owasp_mobile.omtg_android/code_cache
externalCacheDirectory /storage/emulated/0/Android/data/sg.vp.owasp_mobile.omtg_android/cache
filesDirectory /data/user/0/sg.vp.owasp_mobile.omtg_android/files
obbDir /storage/emulated/0/Android/obb/sg.vp.owasp_mobile.omtg_android
packageCodePath /data/app/sg.vp.owasp_mobile.omtg_android-kR0ovWl9eoU_yh0jPJ9caQ==/base.apk
```
The internal data directory, also known as the sandbox directory, is located at `/data/data/[package-name]` or `/data/user/0/[package-name]`. The external data directory is found at `/storage/emulated/0/Android/data/[package-name]` or `/sdcard/Android/data/[package-name]`.

The internal data directory has the following basic structure:
```sh
...g.vp.owasp_mobile.omtg_android on (google: 8.1.0) [usb] # ls
Type ... Name
--------- ... -------------------
Directory ... cache
Directory ... code_cache
Directory ... lib
Directory ... shared_prefs
Directory ... files
Directory ... databases
Readable: True Writable: True
```
Each folder serves a specific purpose:
- **cache**: Used for data caching, such as WebView cache.
- **code_cache**: Application-specific cache directory for storing cached code. Files in this directory are deleted during app or platform upgrades.
- **lib**: Stores native libraries written in C/C++.
- **shared_prefs**: Contains XML files for values saved via the `SharedPreferences` APIs.
- **files**: Stores regular files created by the app.
- **databases**: Stores SQLite database files generated by the app at runtime.

Refer to the "Testing Data Storage" chapter for best practices on securely storing sensitive data.

### Monitoring System Logs
On Android, you can use `Logcat` to inspect system logs. There are two ways to use `Logcat`:
1. **Android Studio**: If the app is running in debug mode, the log output will be displayed in the Android Monitor on the Logcat tab. You can filter the log output by defining patterns.
2. **ADB**: You can execute `Logcat` with ADB to store the log output permanently:
   ```sh
   $ adb logcat > logcat.log
   ```
   To specifically grep for the log output of the app in scope, use:
   ```sh
   $ adb logcat | grep "$(adb shell ps | grep <package-name> | awk '{print $2}')"
   ```

### Setting Up a Network Testing Environment
#### Basic Network Monitoring/Sniffing
You can remotely sniff all Android traffic in real-time using `tcpdump`, `netcat`, and `Wireshark`. First, ensure you have the latest version of `tcpdump` on your phone. Here are the installation steps:
```sh
$ adb root
$ adb remount
$ adb push /wherever/you/put/tcpdump /system/xbin/tcpdump
```
If `adb root` returns an error, follow these alternative steps:
```sh
$ adb push /wherever/you/put/tcpdump /data/local/tmp/tcpdump
$ adb shell
$ su
$ mount -o rw,remount /system;
$ cp /data/local/tmp/tcpdump /system/xbin/
$ cd /system/xbin
$ chmod 755 tcpdump
```
Execute `tcpdump` to verify it works:
```sh
$ tcpdump
```
To remotely sniff the Android phone's network traffic, use:
```sh
$ tcpdump -i wlan0 -s0 -w - | nc -l -p 11111
```
Forward the port to your machine via ADB:
```sh
$ adb forward tcp:11111 tcp:11111
```
Connect to the forwarded port via `netcat` and pipe to `Wireshark`:
```sh
$ nc localhost 11111 | wireshark -k -S -i -
```
This setup allows you to capture and analyze all traffic from the `wlan0` interface.

#### Firebase/Google Cloud Messaging (FCM/GCM)
Firebase Cloud Messaging (FCM), the successor to Google Cloud Messaging (GCM), is a free service by Google for sending messages between an application server and client apps. FCM supports both HTTP and XMPP protocols for communication.

##### Preparation of Test Setup
To intercept FCM traffic, you need to configure local port forwarding. For HTTP, FCM uses ports 5228, 5229, and 5230. For XMPP, it uses ports 5235 (Production) and 5236 (Testing).

Configure local port forwarding for HTTP (example for Mac OS X):
```sh
$ echo "
rdr pass inet proto tcp from any to any port 5228-> 127.0.0.1 port 8080
rdr pass inet proto tcp from any to any port 5229 -> 127.0.0.1 port 8080
rdr pass inet proto tcp from any to any port 5230 -> 127.0.0.1 port 8080
" | sudo pfctl -ef -
```

Configure local port forwarding for XMPP (example for Mac OS X):
```sh
$ echo "
rdr pass inet proto tcp from any to any port 5235-> 127.0.0.1 port 8080
rdr pass inet proto tcp from any to any port 5236 -> 127.0.0.1 port 8080
" | sudo pfctl -ef -
```

Start the app and trigger a function that uses FCM. You should see HTTP messages in your interception proxy.

#### End-to-End Encryption for Push Notifications
Push notifications can be encrypted using Capillary, a library for sending end-to-end (E2E) encrypted push messages from Java-based application servers to Android clients.

#### Setting Up an Interception Proxy
Tools like OWASP ZAP and Burp Suite Professional are commonly used for network analysis of applications that rely on the HTTP(S) protocol. These tools allow you to read and modify app requests and endpoint responses, useful for testing authorization, session management, etc.

##### Interception Proxy for a Virtual Device
To set up an HTTP proxy on an Android Virtual Device (AVD):
1. Set up your proxy to listen on `localhost` and a specific port (e.g., 8080).
2. Configure the HTTP proxy in the emulator settings:
   - Click on the three dots in the emulator menu bar.
   - Open the Settings Menu.
   - Click on the Proxy tab.
   - Select "Manual proxy configuration".
   - Enter `127.0.0.1` in the "Host Name" field and your proxy port in the "Port number" field (e.g., `8080`).
   - Tap "Apply".

You can also configure the proxy on the command line when starting an AVD:
```sh
$ emulator @Nexus_5X_API_23 -http-proxy 127.0.0.1:8080
```

##### Installing a CA Certificate on the Virtual Device
To install a CA certificate on the virtual device:
1. Start Burp and navigate to `burp/` in a web browser on the host.
2. Download `cacert.der` and change the file extension to `.cer`.
3. Push the file to the emulator:
   ```sh
   $ adb push cacert.cer /sdcard/
   ```
4. Navigate to "Settings" -> "Security" -> "Install from SD Card".
5. Scroll down and tap `cacert.cer`.

For Android 7 and above, follow the same procedure described in the "Bypassing the Network Security Configuration" section.

##### Interception Proxy for a Physical Device
Ensure the mobile device and the machine running the interception proxy are connected to the same Wi-Fi network. Configure the proxy to point to the interception proxy and add the interception proxy's CA certificate to the trusted certificates on the Android device.

##### Bypassing the Network Security Configuration
From Android 7 onwards, the network security configuration allows apps to customize their network security settings. To bypass this, create a new XML resource file named `network_security_config.xml` and include an entry in the manifest file to point to this configuration.

For more information, refer to the "Security Analystâ€™s Guide to Network Security Configuration in Android P" and the "Adding the User Certificates to the Network Security Configuration" section.