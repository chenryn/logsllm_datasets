The problem is that you can shoot yourself in the foot with the numpy version
of `all`, because it is not consistent with the Python build-in `all` in
return value when generator is passed to it:
    In [1]: import numpy
    In [2]: numpy.all(a for a in [False])
    Out[2]:  at 0x7f22623eeaa0>
    In [3]: bool(numpy.all(a for a in [False]))
    Out[3]: True
    In [4]: __builtin__.all(a for a in [False])
    Out[4]: False
This is especially confusing when used with `ipython -pylab` in which case the
**buildin**.all is shadowed with the numpy one:
    $ ipython -pylab
    ... blah blah...
    In [2]: all.func_code
    Out[2]: 