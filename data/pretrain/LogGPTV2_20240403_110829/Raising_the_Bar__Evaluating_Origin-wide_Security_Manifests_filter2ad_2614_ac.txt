the rules of the origin manifest, are also handled by the client-
proxy without forwarding the request to the web server.
We implemented the clientproxy using mitmproxy v2.0.2 [9] as
a mitmproxy addon script, using python v3.5.
5.2 Server-side manifest handling
As a complement to the clientproxy, we also implemented the origin
manifest mechanism on the server-side. Instead of modifying the
source code of any particular web server software, we chose to
implement the server-side prototype as a proxy. This serverproxy is
located on the server-side, intercepting and modifying any trac
to the web server, as seen in Figure 1.
The serverproxy has three functions:
• serve the origin manifest le to any web client requesting it,
• inform the web clients about the version of the latest origin
manifest, through the Sec-Origin-Manifest header, and
• strip the HTTP response headers received from the web
server according to the fallback section in the origin man-
ifest to reduce bandwidth towards the web client.
Just like the clientproxy, the serverproxy was implemented as a
mitmproxy v2.0.2 [9] addon script, using python v3.5.
5.3 Automated manifest generation from
observed trac
We implemented a prototype for an automated origin manifest
generator which can be used to assist security ocers with the
creation of an origin manifest. Our implementation does not use
any advanced AI or machine learning techniques to “learn”. Instead,
we apply a pragmatic approach to provide the security ocer with
a reasonable starting point. The manifest generator hooks into the
serverproxy, observing and storing the HTTP headers for all HTTP
requests and responses for the back-end web servers for which it is
proxying trac.
After a data collection phase, the manifest generator analyzes the
observed HTTP headers and generates origin manifest les for all
observed origins. Then the origin manifest mechanism is activated
in the serverproxy, so that it will respond to requests related to the
Raising the Bar: Evaluating Origin-wide Security Manifests
ACSAC ’18, December 3-7, 2018, San Juan, PR, USA
origin manifest mechanism such as manifest retrieval and sending
the manifest version via the Sec-Origin-Manifest header.
The automated generation of the manifest consists of three parts:
• Firstly, the fallback section is generated by enumerating
all HTTP headers and their values that occur in a certain
ratio (cutoff) observed responses have in common. By de-
fault we use the cutoff value 51%. Multiple responses for
the same requested URL are counted only once and only
common headers and values are considered. To prevent ori-
gin manifest creation based on a single HTTP response, we
disregard origins with less than minsize observed HTTP
responses. By default we use the minsize of 2.
• Secondly, the baseline and augmentonly sections are gen-
erated by combining observed security headers and values
from HTTP responses, using the t operator described in
Section 4.
• Lastly, the unsafe-cors-preflight-with-credentials
and cors-preflight sections are generated from the ob-
served HTTP requests and their responses.
Note that for the manifest generation, we only consider those
headers that are applicable to the given origin and content-type. For
instance, a CSP header set on an HTTP response which does not
have a Content-Type of text/html, is ignored. Similarly, HSTS
headers in HTTP responses on a non-HTTPS origin are ignored.
Some HTTP headers have a large impact on the functioning
of HTTP itself and how resources are handled and displayed in
the browser. Because it makes no sense to place these headers in
the origin manifest, they were blacklisted for automated manifest
generation. These headers are: Content-Encoding, Content-Type,
Content-Length and Content-Disposition.
The automated origin manifest generator is implemented as part
of a mitmproxy v2.0.2 addon script using python v3.5.
5.4 Limitations and considerations
The implementations of the clientproxy and serverproxy are fully
functional, suering only minor limitations:
First, we are unable to dierentiate between authenticated and
unauthenticated CORS preight requests/responses for the spe-
cic case when the browser is using client-side SSL certicates
for the given origin. This limitation is intrinsic to our setup using
proxies breaking the SSL tunnel. Luckily, the use of client-side SSL
certicates is not widespread on the Web [31]. Furthermore, imple-
menting the origin manifest mechanism as a browser modication
will not suer from the same limitation.
Secondly, we must disable strict certicate checking (such as
HPKP), simply because of our need to alter both HTTP and HTTPS
trac “in ight”. This limitation is again intrinsic to our setup and
is no longer an issue when the origin manifest is implemented as a
browser modication.
Thirdly, we disable HTTP/2 support in mitmproxy, which it
supports by default. Our implementations work with HTTP/2 just as
well as with HTTP/1. However, HTTP/2 oers some improvements
over HTTP/1 which we do not take advantage of in our prototypes
as currently implemented.
Fourthly, our implementation does not limit itself to only HTTPS
connections as required in Section 3. For this feasibility study, we do
not wish to limit ourselves to only HTTPS, but are also interested
to see how the origin manifest mechanism would behave for non-
HTTPS origins.
Lastly, note that the origin manifest generator is a proof of con-
cept tool to assist origin security ocers in nding a good starting
point for composing a meaningful origin manifest based on the
currently hosted web applications. We recommend that security
ocers review generated origin manifests before deployment, and
we do not advocate deploying this tool in production environments
to generate origin manifests in “real time”.
6 EVALUATION
We evaluate the origin manifest mechanism as well as our proto-
types with several experiments.
Firstly, we evaluate that our prototypes are working properly
and do not break web pages in unexpected ways.
Secondly, we perform a longitudinal experiment to determine if
the application of the origin manifest mechanism is practical.
Thirdly, we evaluate the performance of the origin manifest
mechanism by measuring its eect on network trac during a large-
scale experiment in which we apply the origin manifest mechanism
to the Alexa top 10,000 domains.
All data sizes refer to the uncompressed data in bytes because of
our experiment setup.
6.1 Functional evaluation
We evaluated the correctness of our implementation by manually
inspecting a randomly chosen subset of the Alexa top 1 million
domains and their respective websites, with and without origin
manifest.
Fully automated testing to verify the correctness of the imple-
mentation was deemed impractical, because typical web pages are
often dynamically generated with e.g. advertising, which makes it
dicult for an algorithm to determine whether a web application
is still operating and rendered correctly before and after applica-
tion of the origin manifest mechanism. The use of an ad-blocker
such as AdBlock [1], would alleviate some of these impracticalities.
However, advertising is omni-present on the Web and removing it
from the web trac would interfere with the normal operations
of web pages, and thus also with our testing of the origin manifest
mechanism.
6.1.1
Setup. The evaluation progressed in two phases: an in-
teractive phase and a visual inspection phase. Both these ex-
periments used the setup as shown in Figure 1, where browser web
trac is forwarded through both the clientproxy and serverproxy.
The interactive phase used a regular browser (Chrome version
63.0.3239.132) in incognito mode, operated by a human. The visual
inspection phase used the same browser, but operated by Selenium
3.8.1 [30]. The results of this phase were human inspected.
Interactive phase. We randomly selected 100 domains from the
Alexa top 1 million for this experiment. For each of these domains,
we visited the top-most page, e.g. http://example.tld for the exam-
ple.tld domain, and interacted with the web page, mimicking the
behavior of a typical user without authenticating for that web site.
348
ACSAC ’18, December 3-7, 2018, San Juan, PR, USA
Steven Van Acker, Daniel Hausknecht, and Andrei Sabelfeld
The clientproxy and serverproxy both respond to internal URLs
that allow state inspection. These inspection tools were used to
determine when enough data had been collected: we aimed to
navigate on a web domain at least ve times and gather data for at
least ten web origins.
When enough data was collected, the origin manifest mechanism
was activated in both proxies. The browser was then restarted to
clear caches and the web pages visited again. During the second
visit, we inspected the pages both visually, and tested the func-
tionality of the web page by triggering menus, playing videos, and
otherwise interacting with the web page as an ordinary visitor.
Visual inspection phase. We randomly selected another 1000 do-
mains from the Alexa top 1 million for this experiment. Like in
the interactive phase, we also visited the top-most page before and
after the activation of the origin manifest mechanism.
However, in this visual inspection phase, we simply took a screen-
shot of the web page using Selenium, before and after activation
of the origin manifest mechanism. The browser was restarted in
between visits to clear any caches. We repeated these steps four
times to have reliable results in the face of dynamic content, such
as advertising, resulting in eight screenshots. The screenshots were
combined into a single image with four rows of two images: the
“before” and “after” screenshots side by side.
The resulting images were inspected visually one by one to
determine whether web pages exhibited unusual rendering artifacts.
Any images in which the screenshots appeared to dier before and
after activation of the origin manifest mechanism, were put aside
and their domains revisited using the same technique as in the
“interactive phase”.
6.1.2 Results. Our manual and visual inspections conrm that
our implementations work correctly. From the 1100 domains we
visited, we only encountered abnormal behavior in three cases. In
each of these cases, the problem was due to the automated learner
not receiving sucient learning input, which could have been easily
prevented by changing a parameter. As expected, the automated
origin manifest learner and generator tool can be used as a good
starting point to formulate an initial origin manifest, although we
recommend that the generated manifest should still be reviewed
by a human to ensure correct congurations.
6.2 Longitudinal study
We dene the stability of a header as the average amount of time
that we observe the header to be present and its value unchanged.
For instance, a stability of 5 days indicates that the header was
observed with the same value for an average of 5 days in a row.
Likewise, the stability of a manifest le indicates the average life-
time of a manifest le.
The stability of HTTP headers has an impact on the fallback
section in manifest les and their stability. To be usable in practice,
manifest les should be as stable as possible to reduce network
trac and workload of the security ocer.
By the size of a header, we mean the total amount of bytes it
occupies including its header name.
We conducted a longitudinal study over 100 days to examine the
frequency, stability and size of HTTP headers and auto-generated
manifest les in the real world.
6.2.1
Setup. We used OpenWPM [11], which is based on Firefox,
to visit a set of 1000 domains from the Alexa top 1 million.
The domain list consisted of the top 200 domains, 200 domains
randomly picked from the top 201 – 1,000, 200 domains randomly
picked from the top 1,001 – 10,000, 200 domains randomly picked
from the top 10,001 – 100,000, and nally another 200 domains
randomly picked from 100,001 – 1,000,000.
For each domain we visited its top-most page, e.g. for the ex-
ample domain example.tld we visited http://example.tld. We
set OpenWPM to collect all request and response headers and ran
it daily between October 5th 2017 and January 12th 2018, for a
total of 100 days. We did not use our origin manifest prototype
implementation during data collection.
6.2.2 Results.
HTTP headers. In total we collected 12,322,019 responses over
100 days. We visited a total of 3,575,043 unique URLs (25,533 origins)
of which 20,201 URLs (3,682 origins) where visited every day. We
counted 2,423 dierent header names (case-insensitive).
We only consider the headers in responses for those URLs which
were observed for every day in our experiment. The frequency
of HTTP headers indicates how often they were observed in the
combined set of all responses. The stability of headers is computed
over all observed responses.
Table 2: Selection of popular headers and security headers
with their popularity rank, frequency, average size (bytes)
and stability (days).
rank header
freq. avg. size stability
3 server
16.13B
32.14d
87.39%
8 accept-ranges
18.03B
68.06d
47.57%
9 connection
19.68B
44.61%
43.01d
10 x-refox-spdy
16.01B
62.07d
43.55%
33 x-powered-by
21.70B
34.77d
5.96%
14 access-control-allow-origin 29.95%
32.03B
67.20d
15 x-content-type-options
29.02B
77.10d
25.33%
16 x-xss-protection
28.06B
23.48%
67.78d
19 timing-allow-origin
26.41d
19.31%
22.31B
24 set-cookie
1.32d
11.63% 395.09B
26 strict-transport-security
22.97d
52.52B
8.03%
32 x-frame-options
5.98%
24.15B
76.51d
5.84d
2.69% 566.50B
42 content-security-policy
380 public-key-pins
0.04% 191.25B
23.21d
Table 2 shows a selection of ve popular HTTP headers, as well
as all security headers relevant to origin manifest. The selected
popular HTTP headers are potential candidates for use in origin
manifest. We omitted headers such as Date and Content-Type
which are highly response dependent. For each header, we list their
observed frequency, stability and size. A longer list of the top 50
most popular headers can be found in Appendix A.
From these results, we can make two observations:
349
Raising the Bar: Evaluating Origin-wide Security Manifests
ACSAC ’18, December 3-7, 2018, San Juan, PR, USA
Table 4: Selection of popular headers and security headers
with their popularity rank, occurrence frequency (%), aver-
age size (bytes) and average stability (days) for the fallback,
baseline and augmentonly sections.
rank header
fallback (non-security headers)
freq. avg. size stability
1 server
5 accept-ranges
6 connection
10 x-refox-spdy
24 x-powered-by
fallback (security headers)
13 CORS headers