### Figure 7. JBoss/J2EE-based Non-Repudiable Invocation

In the Java 2 Platform, Enterprise Edition (J2EE), service invocation typically involves the remote invocation of an operation on an enterprise bean. As illustrated in Figure 7, the JBoss framework utilizes server- and client-side interceptors to ensure that these operations are non-repudiable. The client's reference to the remote bean is a dynamic proxy generated by the server, which includes client-side interceptors for context propagation.

To achieve non-repudiation, we introduce an additional interceptor, the JBoss NR (Non-Repudiation) interceptor, into both the client and server invocation paths. These NR interceptors are responsible for initiating the execution of a non-repudiation protocol, as described in Section 3.2. On the client side, the NR interceptor interacts with the client’s non-repudiation middleware, which manages the client’s participation in the protocol and its access to the supporting infrastructure for storing evidence.

#### Interceptor Chain Execution

Each interceptor in the chain can execute on both the outgoing and incoming invocation paths. To ensure non-repudiation of the request as constructed by the client and to verify the integrity of the response presented to the client, the client-side NR interceptor is placed first in the chain on the outgoing path and last on the return path. On the server side, to verify the integrity of the request as it enters the server and to provide non-repudiation of the response as it leaves the server, the NR interceptor is placed first in the chain on the incoming path and last on the return path.

#### JBoss Interceptor Operation

Each JBoss interceptor has an `invoke` method that takes an `Invocation` object as a parameter. The interceptor processes this object and then passes it to the next interceptor in the chain by calling its `invoke` method. The `invoke` method of the client-side JBoss NR interceptor is implemented as follows:

```java
public Object invoke(Invocation inv) {
    B2BInvocationHandler b2bInvHdlr = B2BInvocationHandler.getInstance("JBossJ2EE", "direct");
    B2BInvocation b2bInv = new JBossB2BInvocation(nextInterceptor(), inv);
    return b2bInvHdlr.invoke(b2bInv);
}
```

The `getInstance` method is a factory method that returns a reference to a `B2BInvocationHandler` for the given platform ("JBossJ2EE") and protocol ("direct"). The specific implementation of the `B2BInvocationHandler` is controlled by the client. A `B2BInvocation` object is a generic wrapper for platform-specific representations of the service to be invoked and the invocation parameters. For a `JBossB2BInvocation`, the service to be invoked is the next interceptor in the chain, and a `JBoss Invocation` object encapsulates the invocation parameters.

When the `invoke` method is called, the general behavior of the client-side `B2BInvocationHandler` is:
1. Obtain a reference to or instantiate the local `B2BCoordinator` service.
2. Obtain a reference to or instantiate a protocol handler for the given protocol and register it with the coordinator service.
3. Request that the protocol handler execute its non-repudiation protocol using the given service and invocation parameters.
4. Return the outcome of the protocol execution (typically the server’s response) to the client.

To start the protocol execution, the client-side `B2BInvocationHandler` replaces the arguments to the service invocation with the first message of the protocol and a reference to its local coordinator service. These are then passed up through the interceptor chain to the server.

When the server-side NR interceptor receives the `Invocation` object, it instantiates a JBoss-specific `B2BInvocationHandler` object and calls its `invoke` method with the `Invocation` object as a parameter. The general behavior of the server-side `B2BInvocationHandler` is:
1. Obtain a reference to or instantiate the local `B2BCoordinator` service.
2. Obtain a reference to or instantiate a protocol handler for the type of `B2BProtocolMessage` encapsulated in the `Invocation` object and register it with the coordinator service.
3. Request that the protocol handler execute its non-repudiation protocol using the protocol message and remote coordinator reference (obtained from the `Invocation` object).

During the execution of the non-repudiation protocol, the client’s request is passed through the interceptor chain to the EJB component for execution. The result of this execution is used to complete the non-repudiation protocol.

#### Server-Side Configuration

The application programmer on the server side is responsible for identifying when non-repudiation is required and for specifying the platform and protocol for the instantiation of the `B2BInvocationHandler` in the bean’s deployment descriptor. This allows the server to control the activation of non-repudiation. However, the client controls its own participation through its own implementations of `B2BInvocationHandler`, `B2BProtocolHandler`, and `B2BCoordinator`. For example, the client may change the behavior of its `B2BInvocationHandler` to renegotiate the non-repudiation protocol.

Thus, the NR interceptor, `B2BInvocationHandler`, `B2BProtocolHandler`, and `B2BCoordinator` together form each party’s trusted interceptor.

### 4.3. Implementation of Non-Repudiable Information Sharing

The implementation of non-repudiable information sharing is based on our previous work on B2BObjects, which provides the abstraction of shared information by coordinating the state of local (object) replicas that encapsulate the information. Figure 8 illustrates the component-based implementation when two organizations, A and B, share a B2BObject, and organization A is updating the object state.

As in a standard J2EE application, an EJB client makes invocations through an application interface (a session bean) that may result in access and update to an associated entity bean. In this case, the entity bean has been identified as a B2BObject that should be coordinated with remote replicas. An interceptor traps invocations on the entity bean to ensure that a `B2BObjectController` controls access and update to the bean. The controller is the local interface for configuration, initiation, and control of information sharing.

The controller uses protocol handlers and a coordinator service to execute non-repudiable state and membership coordination protocols with remote parties. Implementations of the interceptor, controller, protocol handlers, and coordinator are all provided by the middleware, as is the supporting infrastructure to store evidence. The controller uses application-specific validation listeners to validate state and membership changes proposed by remote parties. Figure 8 shows organization B’s controller validating organization A’s proposed update by appealing to one or more state validators (implemented as session beans). The update is only applied to the replicas if organization B agrees to the proposal. The process is the same for an update proposed by organization B. Additionally, the implementation supports sharing by more than two parties.

The middleware-provided JBoss interceptor is responsible for interaction with the `B2BObjectController`, and, through the controller, with the B2BObjects middleware. The application programmer is responsible for:
- Identifying an entity bean as a B2BObject.
- Providing configuration information in the bean’s deployment descriptor (e.g., to identify validator beans).
- Providing implementations of one or more session beans to perform validation.
- Optionally, specifying that a method in the application interface should result in a series of operations on an underlying B2BObject bean being “rolled-up” into a single (atomic) coordination event.

The enhancement of an entity bean to become a B2BObject is effectively transparent to the local EJB client and its application interface.

### 5. Related Work

We are not aware of other work that provides systematic integration of services for trusted interaction with component middleware. There is a Web Services non-repudiation proposal [9] that specifies a mechanism to request and send a signed receipt for a SOAP (XML-encoded) message to support so-called “voluntary” non-repudiation. The OASIS Digital Signature Service [15] proposes XML request/response protocols for signing, verifying, and time-stamping data. The Universal Postal Union has proposed the Global Electronic Postmark (EPM) [17] standard, which is a TTP service for generation, verification, time-stamping, and storage of non-repudiation evidence. None of these proposals provide for the exchange of non-repudiation evidence or the governance of complex interactions, which would have to be delivered at the application level with the proposed services used as back-end infrastructure.

Early work by Clark and Wilson [3] on security policy emphasized the importance of data integrity in the commerce domain, as opposed to the military domain’s focus on disclosure. In the Clark-Wilson model, constrained data items are only manipulated through verified transformation procedures as part of well-formed transactions, ensuring that transformations respect an organization’s integrity rules and are logged for audit. The model was concerned with enforcing policy within organizations. The use of verified transformation procedures that mediate actions within an organization is similar to the use of trusted interceptors as mediators between organizations.

There has been much recent work on fair exchange and fair non-repudiation, and on the formal verification of protocols. Kremer et al. [10] summarize the state of the art and provide a useful classification of protocols according to types of fairness and the role of TTPs in protocols. Contributions on the transformation of fair exchange to meet fault tolerance requirements [11, 7] can inform the choice of protocols that trusted interceptors execute to meet interaction requirements.

The work of Minsky et al. on Law-Governed Interaction (LGI) [13] represents one of the earliest attempts to provide coordination between autonomous organizations. Trusted agents act as mediators that comply with a global policy, similar to the trusted interceptor abstraction, where the interaction between agents is assumed to be legal. LGI does not address systematic non-repudiation.

Wichert et al. [18] used filters in CORBA to provide non-repudiable invocation on a remote object. However, their approach is asymmetric—the client provides the server with non-repudiation of origin of a request but there is no corresponding evidence provided to the client. Their work did provide useful insights into the representation of evidence in XML documents. In our system, the exact representation of evidence is a matter for agreement between the parties concerned, with the key requirement being that the representation can be subsequently rendered meaningful and irrefutable.

### 6. Conclusions

This paper presents a unified approach to regulated interaction based on the abstraction of trusted interceptors that mediate interactions. The component-based middleware implementation provides the basic building blocks for constructing a composite service by organizations collaborating to form a virtual enterprise. This can be extended to support transactional interaction. Our preliminary work in this area [6] shows how B2BObjects can participate in distributed (JTA [2]) transactions. We intend to build on this work to provide component-based transactional and non-repudiable interaction.

In effect, the trusted interceptor abstraction and its realization in middleware provide a flexible framework for implementing different approaches to non-repudiable service invocation (fair exchange) and regulated information sharing. Future work will include using this framework to provide a suite of protocols and other mechanisms that can be deployed to meet different application requirements.

### Acknowledgements

This work is partially funded by the EU under projects IST-2001-34069: "TAPAS (Trusted and QoS-Aware Provision of Application Services)" and IST-2001-37126: “ADAPT (Middleware Technologies for Adaptive and Composable Distributed Components)”; and by the UK EPSRC under grant GR/S63199: “Trusted Coordination in Dynamic Virtual Organizations”. We thank our colleague Paul Ezhilchelvan for useful discussions on this work.

### References

[1] R. Axelrod. The Evolution of Co-operation. Penguin Books, 1990.

[2] S. Cheung and V. Matena. Java Transaction API (JTA version 1.0.1B). Sun Microsystems Inc., 2002.

[3] D. R. Clark and D. R. Wilson. A Comparison of Commercial and Military Computer Security Policies. In Proc. IEEE Symp. on Security and Privacy, pages 184–194, 1987.

[4] N. Cook, P. Robinson, and S. Shrivastava. Component Middleware to Support Non-repudiable Service Interactions. Technical Report CS-TR 834, School of Computing Science, Univ. Newcastle, 2004.

[5] N. Cook, S. Shrivastava, and S. Wheater. Distributed Object Middleware to Support Dependable Information Sharing between Organisations. In Proc. IEEE Int. Conf. on Dependable Syst. and Networks (DSN), Washington DC, USA, 2002.

[6] N. Cook, S. Shrivastava, and S. Wheater. Middleware Support for Non-repudiable Transactional Information Sharing between Enterprises. In Proc. IFIP Int. Conf. on Distributed Applications and Interoperable Syst. (DAIS), Springer LNCS 2893, Paris, France, Nov 2003.

[7] P. Ezhilchelvan and S. Shrivastava. Systematic Development of a Family of Fair Exchange Protocols. In Proc. 17th IFIP WG 11.3 Working Conf. on Database and Applications Security, Colorado, USA, 2003.

[8] M. Fleury and F. Reverbel. The JBoss Extensible Server. In Proc. ACM/IFIP/USENIX Int. Middleware Conf., Springer LNCS 2672, Rio de Janeiro, Brazil, Jun 2003.

[9] E. Gravengaard, G. Goodale, M. Hanson, B. Roddy, Non-Reactivity, and D. Walkowski. Web Services Security: Non-Repudiation Proposal Draft 05. http://schemas.reactivity.com/2003/04/web-services-non-repudiation-05.pdf, Apr 2003.

[10] S. Kremer, O. Markowitch, and J. Zhou. An Intensive Survey of Fair Non-repudiation Protocols. Computer Communications, 25:1601–1621, 2002.

[11] P. Liu, P. Ning, and S. Jajodia. Avoiding Loss of Fairness Owing to Process Crashes in Fair Data Exchange Protocols. In Proc. IEEE Int. Conf. on Dependable Syst. and Networks (DSN), New York, USA, 2000.

[12] O. Markowitch, D. Gollmann, and S. Kremer. On Fairness in Exchange Protocols. In Proc. 5th Int. Conf. on Information Security and Cryptology (ISISC 2002), Springer LNCS 2587, 2002.

[13] N. Minsky and V. Ungureanu. Law-Governed Interaction: A Coordination and Control Mechanism for Heterogeneous Distributed Systems. ACM Trans. Softw. Eng. and Methodology, 9(3):273–305, 2000.

[14] C. Molina-Jimenez, S. Shrivastava, E. Solaiman, and J. Warne. Contract Representation for Run-time Monitoring and Enforcement. In Proc. IEEE Int. Conf. on E-Commerce (CEC), pages 103–110, Newport Beach, USA, 2003.

[15] T. Perrin, D. Andivahis, J. C. Cruellas, F. Hirsch, P. Kasselman, A. Kuehne, J. Messing, T. Moses, N. Pope, R. Salz, and E. Shallow. Digital Signature Service Core Protocols and Elements. OASIS Committee Working Draft, http://www.oasis-open.org/committees/dss, Dec 2003.

[16] Sun. Java 2 Platform Enterprise Edition (J2EE) Specification. Sun Microsystems Inc., http://java.sun.com/j2ee/, 1.4 edition, 2003.

[17] UPU. Global EPM Non-repudiation Service Definition and the Electronic Postmark 1.1. Universal Postal Union, http://www.globalepost.com/prodinfo.htm, Oct 2002.

[18] M. Wichert, D. Ingham, and S. Caughey. Non-repudiation Evidence Generation for CORBA using XML. In Proc. IEEE Annual Comp. Security Applications Conf., Phoenix, USA, 1999.