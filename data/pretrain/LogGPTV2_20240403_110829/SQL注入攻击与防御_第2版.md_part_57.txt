其他的字符串操作函数也很有用，例如Oracle 中的 REVERSE、TRANSLATE、REPLACE
和 SUBSTR函数。
还有另外一种在SQLServer平台上构造动态执行的字符串的方法：使用代表字符串ASCII
字符编码的十六进制数字来实例化字符串。例如，对于字符串
SELECT passvord FROM tblUsers
可以按照下列方式进行构造并动态执行：
DECLARE BquexY VARCHAR (100)
SELECT 8query = 0x53454c4543542070617373776f72642046524f4d2074626c5573657273
EXEC (8query)
从2008年年初开始，针对Web应用的大量SQL注入攻击均使用该技术来降低所利用代码
被应用程序输入过滤器阻止的概率。
277
---
## Page 292
SQL注入攻击与防御（第2版）
7.2.5使用空字节
实现的，比如在入侵检测系统（IDS)或WAF中。由于性能原因，这些组件通常由原生语言（比如
C++）编写，对于这种情况，可以使用空字节攻击来避开输入过滤器并将漏润输入至后台应用程
序中。
空字节之所以能起作用，是因为原生代码（native code)和托管代码分别采用不同的方法来处
理空字节。在原生代码中，根据字符申起始位置到出现第一个空字节的位置来确定字符申长度
（空字节有效终止了字符串)。面在托管代码中，字符串对象包含一个字符数组（可能包含空字节）
和一条单独的字符串长度记录。
这种差异意味着原生过滤器在处理输入时，如果遇到空字节，便会停止处理，因为在过滤
器看来，空字节代表字符串的结尾。如果空字节之前的输入是良性的，那么过滤器将不会阻止
该输入。不过在托管代码语境中，应用在处理相同的输入时，会将跟在空字节后面的输入一同
处理以使执行利用。
要想执行空字节攻击，只需在过滤器阻止的字符前面提供一个采用URL编码的空字节
(%00）)即可。在原来的例子中，可以使用下列格式的攻击字符申来避开原生输入过滤器：
$00* UNION SELECT passvord FROM tblUsers WHERE username=*admin*--
7.2.6嵌套剥离后的表达式
有些审查过滤器会先从用户输入中剥离特定的字符或表达式，然后再按照常用的方式处理
剩下的数据。如果被剥离的表达式中包含两个或多个字符，就不会递归应用过滤器。通常可以
通过在禁止的表达式中嵌套自身来战胜过滤器。
例如，如果从输入中剥离了SQL关键词SELECT，就可以使用下列输入战胜过滤器：
SELSELECTECT
7.2.7利用截断
审查过滤器通常会对用户提供的数据执行多种操作，有时这些操作中会包括将输入截断成
最大的长度（可能是为了尽力阻止缓冲区溢出攻击）或者调整数据使其位于拥有预定义最大长度
的数据库字段内。
请思考执行下列SQL查询的登录函数，它包含两个由用户提供的输入项：
SELECT uid FROM tblUsers WHERE username - 'jlo* AND pass￥ord = 'r1Mj06*
假设应用使用了一个审查过滤器，它执行下列步骤：
（1）对引号标记进行双重编码，使用两个单引号（）替换所有的单引号（示例。
(2）将每一项截断成16个字符。
如果提供一个典型的如下所示的SQL注入攻击要素：
admin *=*
那么将执行下列查询并且攻击会失败：
278
---
## Page 293
第7章高级话题
SELECT uid FROM tblUsers KHERE username = 'admin*--* AND passvord = "
请注意，引号双重编码意味着您的输入没有终止用户名字符串，所以该查询实际上检查了
用户是否拥有您所提供的字面用户名。
不过，如果提供下列包含15个字母a和一个单引号的用户名：
3a3333a833883a8'
那么应用将首先双重编码单引号，产生一个包含17个字符的字符串。接下来将其截断成16
个字符，清除附加的单引号。这样便可以通过向查询插入一个保留的引号字符来干预其语法：
AND passvord = 11
这种初期攻击会产生一个错误，因为我们实际上拥有一个未终结的字符串。跟在字母a后面
的每一对引号代表一个转义引用，因而最终没有引号来界定用户名字符串。不过，因为存在第
二个插入点，所以可以在口令字段恢复该查询语法的有效性，可通过提供下列口令来避开登录：
or 1=1--
这会导致应用执行下列查询：
ONY .,eeeeeeeeeeeeeee, = aweuiasn 3e3He saesnTqn Hota pin Joer39
passvord - *or 11--
数据库执行该查询时，会查找从文字上看用户名为
aaaaaaaaaaaaaaa ′AND pass?0rd *
的表项，一般来说这是永假条件，而1=1为永真。因此，查询会返回表中所有用户的UID，
这通常导致我们作为表中的第一个用户来登录应用。如果想以特定的用户（比如UID为0的用
户登录，可以按下列方式提供口令：
or uid=0--
秘密手记
其他截断攻击
截断用户在SQL查询中提供的输入会引发漏润（尤其是当纯种的SQL注入不可行
时）.在Microsof SQLServer中，参数化查询必须为每个字符串参数指定最大长度.如
果参数中包含更长的输入，那么输入会被截断成最大长度.进一步讲，SQLServer在比
较WHERE子句中的字符串时会忽略后面的空白符，在易受攻击的应用程序中，这些特
点会引发很多问题，比如，假设应用程序允许忘记口令的用户通过提交e-mail地址来接
收忘记的口令，如果应用接收过长的输入并在SQL查询中将其截断，那么攻击者使可
以提交下列输入
279
---
## Page 294
SQL注入攻击与防御（第2版）
PI:EMAIL [many spaces]; evilfattacker.org
在相应的查询中，上述输入会检索e-mail为PI:EMAIL的用户的口令，因
为被截断输入尾部的空格会被忽略：
接下来当应用程序向原来提供的c-mail地址发送口令时，它还会向攻击者发送一份
副本，这样攻击者就可以侵害受害者的账户。要想获取类似于这种攻击的详细信息，请
阅读 th Gary O'Leary-Stcele 撰写的 “Buffer Truncation Abuse in .NET and Microsoft SQL
Server”，该文章位于www.scoobygang.org/HiDDenWarez/bta.pdf。
7.2.8避开自定义过滤器
Web应用的类型有很多种，现实中您可能会遇到各种奇怪绝妙的输入过滤器，可以通过发
挥想象力来避开这些过滤器。
Oracle应用服务器针对设计低劣的自定义过滤器提供了一个有用的研究案例。该产品提供
了一个针对数据库存储过程的Web接口，它允许开发人员根据数据库中已经实现的功能来快
速部署Web应用。为防止攻击者充分利用服务器访问Oracle数据库中内置的功能强大的存储
过程，服务器实现了一个执行列表并阻止对诸如I SYS和OWA等包的访间。
当然，避开这种声名狼藉的基于黑名单的过滤器会比较容易（Oracle的执行列表也不例外）。
2000年年初，DavidLitchfield发现了该过滤器存在的一系列缺陷，每种缺陷都与被阻止的包的
表示方式有关。这些包虽然就前台过滤器而言是良性的，但在后台数据库中处理时仍然包含特
定的意图。
例如，可以在包名前添加空白符：
https: //www. example.com/pls/dad/$oASYS-package,procedure
可以使用y字符的URL编码替换SYS中的Y字符：
https://www,exanple.com/pls/dad/SsFFS.package.procedure
可以为包名添加双引号：
https: //www,exanple,com/pls/dad/"sYs*,package procedure
可以在包名前添加编程用的跳转标签：
https: / /www,example,com/p1s/dad/>SYS-package procedure
虽然上述例子都是针对特定的产品，但它们演示了自定文输入过滤器可能出现的向题类
型，并说明了尝试避开这些过滤器时需要使用的技术。
7.2.9使用非标准入口点
有时我们会遇到部署了应用型防御（比如WAF）的情况，其中实现了有效的输入过滤器并且
能防止常见的代码漏洞。对于这种情况，我们应该寻找进入应用程序的非标准入口点，这些入
280
---
## Page 295
第7章高级话题
口点易受到SQL注入攻击，并且应用程序级别的过滤器可能忽视了这些入口点。
很多WAF会检查每个请求参数的值，但不会验证参数名。当然，可以向任何请求添加任
意参数。如果应用在动态SQL查询中集成了任意参数名，就可以忽略过滤器的存在面继续执
行SQL注入。
请思考在应用中保存用户偏好这一功能。用户喜好页面包含了大量输入字段，它们被提交
给下列URL：
https://vww,example, org/Preferences aspx?lang=ensregion=ukscurrency
gbp...
请求上述URL会导致应用生成很多SQL查询，格式如下所示：
UPDATE profi1e SET 1ang=′en' WHERE UID=2104
UPDATE profile SET region=*uk* WHERE UID-2104
UPDATE profile SET currency=′gbp* KHERE UID=2104
由于用户偏好使用的字段会随时间发生改变，因面开发人员决定采用一种捷径，按下列方
式实现该功能：
IEnumerator 1 = Request,QueryString.GetEnumerator () ;
while (i.MoveNext () )
(string name = (string).Current;
+..*= + oweu + α I3S TTgoid 3Lvodn = Azenb DuTaqs
Request,QueryString[name] Replace(**", "***)+
"* WHERE uid=" + uid;
秘密手记
通过搜索查询引用页进行注入
除了自定义登录请求机制外，很多应用还会执行测览分析功能。这些功能向管理员
提供与用户在应用申导航路径相关的数据以及用户最开始到达应用的外部源，这种分析
通常包括用户执行搜索查询的信息，而这些信息可引导用户到达应用，为了确定这些搜
索查询所使用的数据项，应用会检查引用页头部以使寻找流行的搜索引学的域名，之后
再从引用页URL包含的相关参数中解析出搜索项。如来使用了不安全的方式将这些项
集成到SQL查询中，就可以通过在搜索URL的查询参数中嵌入攻击并在引用页头部提
交该查询来执行SQL注入，例如：
GET /vu1n.aspx HTTP/1.1
Host: www.example.org
Referer: http:/ /www. google.com/search?hl=en&q=a′ ; +waitfor+
delay+*0:0:30*--
这种攻击要素极其隐藏，许多渗透测试人员和自动扫描器（BurpScanncr除外，它会
针对扫描的每个请求检查这种攻击）可能会忽视它。
281
---
## Page 296
SQL注入攻击与防御（第2版）
上述代码枚举了查询字符串中的所有参数，并使用各个参数构造了一条SQL查询。虽然
到了查询中。因此应用程序容易受到攻击，不过只能将攻击放在参数名中。
如果应用程序中包含自定义登录机制，该机制将所有请求的URL（包括查询字符申）保存到
数据库中，那么便会出现与之类似的漏润。如果输入过滤器只验证参数值而不验证参数名，那
么可以通过将有效载荷放到参数名中来利用该漏润。
应用类型输入过滤器通常还会忽视的一个入口点是HTTP请求中的头部。应用程序的代码
可以使用任意方式处理HTTP头部。应用程序经常处理的头部包括主机、引用页以及应用级登
就可以通过攻击这些入口点来执行SQL注入。
7.3利用二阶SQL注入
实际上到目前为止，本书讨论的所有SQL注入示例都可以归类到“一阶”SQL注入中，
因为这些例子涉及的事件均发生在单个HTTP请求和响应中，整个过程如下所示：
(1）攻击者在HTTP请求中提交某种经过构思的输入。
(2）应用程序处理输入，导致攻击者注入的SQL查询被执行。
(3）如果可行的话，会在应用程序对请求的响应中向攻击者返回查询结果。
（1）攻击者在HTTP请求中提交某种经过构思的输入。
(2)应用程序存储该输入(通常保存在数据库中)以便后面使用并响应请求。
(3）攻击者提交第二个(不同的）请求。
（4）为处理第二个请求，应用程序会检索已经存储的输入并处理，从而导致攻击者注入的
SQL查询被执行。
(5）如果可行的话，会在应用程序对第二个请求的响应中向攻击者返回查询结果。
二阶SQL注入跟等价的一阶SQL注入一样功能强大。不过它是一种更细微的漏洞，通常
更难被检测到。
开发人员在考虑受感染和经过验证的数据时犯下的简单错误通常会引发二阶SQL注入。
在直接从用户获取输入的位置点，很明显该输入会潜在地受到感染。知道这些情况的开发人员
会努力去防御一阶SQL注入，比如将单引号双重编码或（更倾向于）使用参数化查询。不过，如
果该输入是持久的且以后会重用，那么不容易看出该数据依然容易受到感染，这会导致部分开
发人员错误地对数据进行不安全的处理。
请思考一个通讯薄应用，用户可以保存朋友的联系信息。创建一个联系人时，用户可以输
入姓名、c-mail和地址等明细信息。应用程序使用INSERT语句为该联系人创建一条新的数据
库记录，并将输入中的引号双重编码以防止SQL注入攻击（请参见图7-1)。
该应用程序还允许用户修改选中的已存在联系人的明细信息。用户修改已存在的联系人
时，应用程序将先使用SELECT语句检索该联系人的当前细节信息并将其保存到内存中：然后
使用用户提供的新细节信息更新相关的数据项，并再次对该输入中的引号进行双重编码，用户
没有更新的数据项在内存中将保持不变；最后使用UPDATE语句将内存中的所有数据项回写
282
---
## Page 297
第7章高级话题
到数据库中（请参见图7-2）。
姓名
e-manl
1.将所有引号
2. 使用 INSERT
地址
双重编码
语句
DB(数据车)
图7-1创建新联系人的信息流
1. SELECT
语句
DB(数据牟)