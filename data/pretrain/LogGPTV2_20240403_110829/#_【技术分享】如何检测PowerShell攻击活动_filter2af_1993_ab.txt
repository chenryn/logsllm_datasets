我们经常可以在钓鱼攻击中看到这类行为，在这种场景中，用户会点击并打开嵌有宏（vbscript）的Word文档，该文档会启动PowerShell进程，从Web端下载恶意数据。
因此，如果出现以下几种情况，我们需要多加小心并记录下相应的蛛丝马迹：
1、PowerShell由`winword.exe`启动运行（其父进程为`winword.exe`）；
2、PowerShell由`cmd.exe`启动运行（其父进程为`cmd.exe`），并且`cmd.exe`的父进程为`winword.exe`（即PowerShell的祖父进程为`winword.exe`）：
3、PowerShell由`mshta.exe`、`wscript.exe`、`wuapp.exe`、`tasking.exe`中的某个进程启动运行（其父进程为mshta、wscript、cscript、wuapp、tasking等）。
举个例子，执行某个简单的脚本后，我们可以利用Power
Monitor工具观察到进程创建顺序，如下所示。这个例子中，PowerShell由`Wscript.exe`启动运行，这表明`Wscript.exe`为PowerShell的父进程，而PowerShell则是`conshost.exe`的父进程，该进程最终启动了`calc.exe`。
该脚本如下所示，只需将两行代码拷贝到Notepad中，将其保存为`.js`文件并运行即可。
    shell = new ActiveXObject('WScript.Shell');
    shell .Run("powershell.exe  Invoke-Item c:\windows\system32\calc.exe");
前面提到的特征可以作为攻击指示器加以使用，这些特征涉及许多方面的内容，我们可以以此为起点，在实际环境中记录PowerShell执行痕迹，然后着重查找上述IOC，根据这些特征进一步分析任何可疑的攻击活动。
**4.2 命令行即王道**
许多情况下，我们可以监控传递给PowerShell进程的命令行参数，借此来检测许多PowerShell攻击活动。此外，这些信息可以为我们提供线索，了解下一步该收集哪些证据。比如，如果攻击活动中用到了
**downlodFile()**
方法，那么我们可以知道恶意文件在磁盘中的具体存储路径，也能知道恶意文件来自于哪个恶意网站。根据这些线索，我们可以进一步评估攻击活动的操作过程以及影响范围。
**  
**
**五、Windows安全日志在检测PowerShell攻击活动中的作用**
根据PowerShell的具体版本以及所用的操作系统，我们可以使用各种方法来记录PowerShell相关日志。
在本文中，我想谈一下如何借助Windows事件代码来识别前文中提到的IOC。只要启用相关日志，记录下事件ID，我们就有可能检测到基于PowerShell的攻击行为。
这里我想分析一下Windows安全日志中的
4688事件，这个事件对应的是进程创建操作。进程创建过程中会产生大量事件，但只要使用基本的过滤条件，我们就能梳理出需要关心的那些日志。默认情况下，进程创建审计功能处于禁用状态，因此，我们首先需要使用GPO来启动这一功能，你可以参考[此处链接](https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/manage/component-updates/command-line-process-auditing)了解更多细节。
此外，在进程创建过程中，我们还需要记录下所涉及的命令行参数。从Windows 8.1及Windows Server 2012
R2起，Windows系统开始提供命令行审计功能。我们可以使用GPO，在“ **Administrative TemplatesSystemAudit
Process Creation** ” 中启用“ **Include command line in process creation events**
”选项来启用该功能。更多细节请参考[此处链接](https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/manage/component-updates/command-line-process-auditing)。
在Windows 7、Server 2008以及Server 2008
R2系统上，你可以通过系统更新来添加这一新功能。更多细节请参考这两处链接[[1]](https://technet.microsoft.com/library/security/3004375)[[2]](https://support.microsoft.com/en-in/help/3004375/microsoft-security-advisory-update-to-improve-windows-command-line-aud)。
4688事件可以给我们提供三个关键元素，在SIEM（安全信息和事件管理）中，我们可以根据这些元素生成警告信息，以检测此类攻击行为。
1、创建的是哪个进程。
2、进程创建过程中用到了哪些命令行参数（如果存在参数传递的话）。
3、哪个进程是父进程（Windows 10/Server
2016及新版的系统会在Creator_Porcess_Name字段中包含父进程的进程名，之前版本的系统会在Creator_Process_ID字段中包含父进程的进程ID）。
我会以Splunk为例，介绍如何在实际环境中生成警告信息，检测可疑的PowerShell活动。此外，我也会介绍警告信息中需要注意哪些事项。
首先，我们感兴趣的是如何捕捉PowerShell攻击行为，因此我们需要监控与`Powershell.exe`进程创建或生成有关的一些事件。典型的4688事件如下所示，这个事件中包含一个名为“New_Process_Name”的字段，我们可以通过该字段了解创建的是哪个进程。
因此，我们需要通过如下搜索语句来筛选这些事件：
    index=win_sec EventCode=4688 New_Process_Name="C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
接下来，我们需要分析Powershell进程初始化过程中传递了哪些命令行参数。
我们可以通过Process_Command_Line字段了解新创建的进程（如Powershell）用到了哪些命令行参数。我们可以根据攻击中常用参数（如-e、-Encod、-windowstyle、-Bypass
、-c 、-command等）来构建警告信息。
    index=win_sec EventCode=4688 New_Process_Name="C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe –c OR –Encode OR  -e,  OR – windowstyle
更好的方法是根据已知的可疑命令行参数来构建输入查找清单，然后在警告信息中匹配这个清单。
从Windows 10以及Windows Server 2016开始，微软在4688事件中添加了一个名为“Creator Process
Name”的字段，这个字段包含父进程的进程名信息。利用这个字段，我们可以根据可疑父进程来创建警告信息。
    index=win_sec EventCode=4688 
    New_Process_Name="C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Creator_Process_Name= C:Program FilesMicrosoft OfficeOffice15winword.exe
    New_Process_Name="C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Creator_Process_Name= C:windowssystem32mshta.exeNew_Process_Name="C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Creator_Process_Name= C:windowssystem32cmd.exe
**  
**
**六、注意事项**
“不幸的是，PowerShell命令或脚本混淆起来非常简单。”
攻击者可以使用各种方法来混淆PowerShell脚本。比如，攻击者可以在PowerShell中使用随机变量或者字符串拼接技术，轻松绕过基于命令行参数及输入查找清单（如前文所述）的静态匹配机制。如下几种混淆技术可以让我们的静态匹配机制形同虚设。
赛门铁克曾发表过关于PowerShell攻击方法的一份[白皮书](https://www.symantec.com/content/dam/symantec/docs/security-center/white-papers/increased-use-of-powershell-in-attacks-16-en.pdf)（ _THE
INCREASED USE OF POWERSHELL IN ATTACKS_ ），其中包含了[Daniel
Bohannon](https://www.youtube.com/watch?v=P1lkflnWb0I)在Derbycon
2016上提到的关于Powershell混淆技术的几个绝佳案例。几种混淆技术如下所示，那份白皮书中也讨论过其中几种样例。
1、混用小写及大写字母（因为命令对大小写并不敏感）。
典型用例：
    (neW-oBjEct system.NeT.WeBclieNT). dOWNloadfiLe
2、拼接字符串，变量中也可以使用这种技术，用单引号或双引号来拼接都可以。
典型用例：
    (New-Object Net.WebClient). DownloadString(“ht”+’tp://’+$url)
3、除了14种特殊场景以外，转义字符（`）可以放在某个字符前，并且不会改变程序执行结果。当通过`cmd.exe`启动PowerShell时，我们也可以使用转义字符（^）来达到类似效果。
典型用例：
    (new-object net. webclient).”d`o`wnl`oa`dstr`in`g”($url)
4、某些变量可以使用其对应的数字表示法来替代。
典型用例：我们可以使用“-window 1”来替代“-window hidden”。
在实际环境中，监控PowerShell的执行情况是非常有必要的一件事情，如果涉及到的命令行经过混淆处理，那么这种情况与网络攻击活动挂钩的可能性就变得非常大。因此，我们必须启用4688事件的记录功能，在该事件上应用过滤器，梳理出与PowerShell进程创建有关的那些事件，监控PowerShell进程创建过程中传递的命令行参数。
下次如果碰到类似场景，请保持冷静，竖起耳朵，仔细检查。