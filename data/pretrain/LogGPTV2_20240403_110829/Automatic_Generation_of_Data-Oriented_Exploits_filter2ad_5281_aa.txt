title:Automatic Generation of Data-Oriented Exploits
author:Hong Hu and
Zheng Leong Chua and
Sendroiu Adrian and
Prateek Saxena and
Zhenkai Liang
Automatic Generation of Data-Oriented Exploits
Hong Hu, Zheng Leong Chua, Sendroiu Adrian, Prateek Saxena, and Zhenkai Liang, 
National University of Singapore
https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/hu
This paper is included in the Proceedings of the 24th USENIX Security SymposiumAugust 12–14, 2015 • Washington, D.C.ISBN 978-1-939133-11-3Open access to the Proceedings of  the 24th USENIX Security Symposium is sponsored by USENIXAutomatic Generation of Data-Oriented Exploits
Hong Hu, Zheng Leong Chua, Sendroiu Adrian, Prateek Saxena, Zhenkai Liang
Department of Computer Science, National University of Singapore
{huhong, chuazl, sendroiu, prateeks, liangzk}@comp.nus.edu.sg
Abstract
As defense solutions against control-ﬂow hijacking at-
tacks gain wide deployment, control-oriented exploits
from memory errors become difﬁcult. As an alterna-
tive, attacks targeting non-control data do not require
diverting the application’s control ﬂow during an at-
tack. Although it is known that such data-oriented at-
tacks can mount signiﬁcant damage, no systematic meth-
ods to automatically construct them from memory er-
rors have been developed.
In this work, we develop a
new technique called data-ﬂow stitching, which system-
atically ﬁnds ways to join data ﬂows in the program to
generate data-oriented exploits. We build a prototype
embodying our technique in a tool called FLOWSTITCH
that works directly on Windows and Linux binaries. In
our experiments, we ﬁnd that FLOWSTITCH automati-
cally constructs 16 previously unknown and three known
data-oriented attacks from eight real-world vulnerable
programs. All the automatically-crafted exploits respect
ﬁne-grained CFI and DEP constraints, and 10 out of the
19 exploits work with standard ASLR defenses enabled.
The constructed exploits can cause signiﬁcant damage,
such as disclosure of sensitive information (e.g., pass-
words and encryption keys) and escalation of privilege.
1
Introduction
In a memory error exploit, attackers often seek to ex-
ecute arbitrary malicious code, which gives them the
ultimate freedom in perpetrating damage with the vic-
tim program’s privileges. Such attacks typically hijack
the program’s control ﬂow by exploiting memory errors.
However, such control-oriented attacks, including code-
injection and code-reuse attacks, can be thwarted by efﬁ-
cient defense mechanisms such as control-ﬂow integrity
(CFI) [10, 43, 44], data execution prevention (DEP) [12],
and address space layout randomization (ASLR) [15,33].
Recently, these defenses have become practical and are
gaining universal adoption in commodity operating sys-
tems and compilers [8, 36], making control-oriented at-
tacks increasingly difﬁcult.
However, control-oriented attacks are not the only ma-
licious consequence of memory error exploits. Memory
errors also enable attacks through corrupting non-control
data — a well-known result from Chen et al. [19]. We
refer to the general class of non-control data attacks as
data-oriented attacks, which allow attackers to tamper
with the program’s data or cause the program to disclose
secret data inadvertently. Several recent high-proﬁle vul-
nerabilities have highlighted the menace of these attacks.
In a recent exploit on Internet Explorer (IE) 10, it has
been shown that changing a single byte — speciﬁcally
the Safemode ﬂag — is sufﬁcient to run arbitrary code in
the IE process [6]. The Heartbleed vulnerability is an-
other example wherein sensitive data in an SSL-enabled
server could be leaked without hijacking the control-ﬂow
of the application [7].
If data-oriented attacks can be constructed such that
the exploited program follows a legitimate control ﬂow
path, they offer a realistic attack mechanism to cause
damage even in the presence of state-of-the-art control-
ﬂow defenses, such as DEP, CFI and ASLR. However,
although data-oriented attacks are conceptually under-
stood, most of the known attacks are straightforward cor-
ruption of non-control data. No systematic methods to
identify and construct these exploits from memory er-
rors have been developed yet to demonstrate the power of
data-oriented attacks. In this work, we study systematic
techniques for automatically constructing data-oriented
exploits from given memory corruption ﬂaws.
Based on a new concept called data-ﬂow stitching, we
develop a novel solution that enables us to systematize
the understanding and construction of data-oriented at-
tacks. The intuition behind this approach is that non-
control data is often far more abundant than control data
in a program’s memory space; as a result, there exists
an opportunity to reuse existing data-ﬂow patterns in the
USENIX Association  
24th USENIX Security Symposium  177
program to do the attacker’s bidding. The main idea of
data-ﬂow stitching is to “stitch” existing data-ﬂow paths
in the program to form new (unintended) data-ﬂow paths
via exploiting memory errors. Data-ﬂow stitching can
thus connect two or more data-ﬂow paths that are disjoint
in the benign execution of the program. Such a stitched
execution, for instance, allows the attacker to write out a
secret value (e.g., cryptographic keys) to the program’s
public output, which otherwise would only be used in
private operations of the application.
Problem. Our goal is to check whether a program is ex-
ploitable via data-oriented attacks, and if so, to automat-
ically generate working data-oriented exploits. We aim
to develop an exploit generation toolkit that can be used
in conjunction with a dynamic bug-ﬁnding tool. Specif-
ically, from an input that triggers a memory corruption
bug in the program, with the knowledge of the program,
our toolkit constructs a data-oriented exploit.
Compared to control-oriented attacks, data-oriented
attacks are more difﬁcult to carry out, since attackers
cannot run malicious code of their choice even after the
attack. Though non-control data is abundant in a typi-
cal program’s memory space, due to the large range of
possibilities for memory corruption and their subtle in-
ﬂuence on program memory states, identifying how to
corrupt memory values for a successful exploit is difﬁ-
cult. The main challenge lies in searching through the
large space of memory state conﬁgurations, such that the
attack exhibits an unintended data consequence, such as
information disclosure or privilege escalation. An addi-
tional practical challenge is that defenses such as ASLR
randomize addresses, making it even harder since abso-
lute address values cannot be used in exploit payloads.
Our Approach. In this work, we develop a novel so-
lution to construct data-oriented exploits through data-
ﬂow stitching. Our approach consists of a variety of
techniques that stitch data ﬂows in a much more efﬁ-
cient manner compared to manual analysis or brute-force
searching. We develop ways to prioritize the search-
ing for data-ﬂow stitches that require a single new edge
or a small number of new edges in the new data-ﬂow
path. We also develop techniques to address the chal-
lenges caused by limited knowledge of memory lay-
out. To further prune the search space, we model the
path constraints along the new data-ﬂow path using sym-
bolic execution, and check its feasibility using SMT
solvers. This can efﬁciently prune out memory corrup-
tions that cause the attacker to lose control over the ap-
plication’s execution, like triggering exceptions, failing
on compiler-inserted runtime checks, or causing the pro-
gram to abort abruptly. By addressing these challenges, a
data-oriented attack that causes unintended behavior can
be constructed, without violating control-ﬂow require-
ments in the victim program.
We build a tool called FLOWSTITCH embodying these
techniques, which operates directly on x86 binaries.
FLOWSTITCH takes as input a vulnerable program with
a memory error, an input that exploits the memory er-
ror, as well as benign inputs to that program. It employs
dynamic binary analysis to construct an information-
ﬂow graph, and efﬁciently searches for data ﬂows to be
stitched. FLOWSTITCH outputs a working data-oriented
exploit that either leaks or tampers with sensitive data.
Results. We show that automatic data-oriented exploit
generation is feasible.
In our evaluation, we ﬁnd that
multiple data-ﬂow exploits can often be constructed from
a single vulnerability. We test FLOWSTITCH on eight
real-world vulnerable applications, and FLOWSTITCH
automatically constructs 19 data-oriented exploits from
eight applications, 16 of which are previously unknown
to be feasible from known memory errors. All con-
structed exploits violate memory safety, but completely
respect ﬁne-grained CFI constraints. That is, they create
no new edges in the static control-ﬂow graph. All the
attacks work with the DEP protection turned on, and 10
exploits (out 19) work even when ASLR is enabled. The
majority of known data-oriented attacks (c.f. Chen et.
al. [19], Heartbleed [7], IE-Safemode [6]) are straight-
forward non-control data corruption attacks, requiring at
most one data-ﬂow edge. In contrast, seven exploits we
have constructed are only feasible with the addition of
multiple data-ﬂow edges in the data-ﬂow graph, showing
the efﬁcacy of our automatic construction techniques.
Contributions. This paper makes the following contri-
butions:
• We conceptualize data-ﬂow stitching and develop a
new approach that systematizes the construction of
data-oriented attacks, by composing the benign data
ﬂows in an application via a memory error.
• We build a prototype of our approach in an au-
tomatic data-oriented attack generation tool called
FLOWSTITCH. FLOWSTITCH operates directly on
Windows and Linux x86 binaries.
• We show that constructing data-oriented attacks
from common memory errors is feasible, and offers
a promising way to bypass many defense mecha-
nisms to control-ﬂow attacks. Speciﬁcally, we show
that 16 previously unknown and three known data-
oriented attacks are feasible from eight vulnerabili-
ties. All our 19 constructed attacks bypass DEP and
the CFI checks, and 10 of them bypass ASLR.
2 Problem Deﬁnition
2.1 Motivating Example
The following example shown in Code 1 is modeled after
a web server. It loads the web site’s private key from a
2
178  24th USENIX Security Symposium 
USENIX Association
char *userInput, *reqFile;
char *privKey, *result, output[BUFSIZE];
char fullPath[BUFSIZE] ="/path/to/root/";
privKey = loadPrivKey("/path/to/privKey");
/* HTTPS connection using privKey */
GetConnection(privKey, ...);
userInput = read_socket();
if (checkInput(userInput)) {
1 int server() {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19 }
Code 1: Vulnerable code snippet. String concatenation on line 14
introduces a stack buffer overﬂow vulnerability.
/* user input OK, parse request */
reqFile = getFileName(userInput);
/* stack buffer overflow */
strcat(fullPath, reqFile);
result = retrieve(fullPath);
sprintf(output,"%s:%s",reqFile,result);
sendOut(output);
}
ﬁle, and uses it to establish an HTTPS connection with
the client. After receiving the input — a ﬁle name, the
code sanitizes the input by invoking checkInput()
(on line 10). The code then retrieves the ﬁle content and
sends the content and the ﬁle name back to the client.
There is a stack buffer overﬂow vulnerability on line 14,
through which the client can corrupt the stack memory
immediately after the fullPath buffer.
However, there is no obvious security-sensitive non-
control data [19] on the stack of the vulnerable function.
To create a data-oriented attack, we analyze the data ﬂow
patterns in the program’s execution under a benign input,
which contains at least two data ﬂows: the ﬂow involv-
ing the sensitive private key pointed to by the pointer
named privKey, and the ﬂow involving the input ﬁle
name pointed by the pointer named reqFile, which is
written out to the program’s public outputs. Note that in
the benign run, these two data ﬂows do not intersect —
that is, they have no shared variables or direct data de-
pendence between them, but we can corrupt memory in
such a way that the secret private key gets written out to
the public output. Speciﬁcally, the attacker crafts an at-
tack exploiting the buffer overﬂow to corrupt the pointer
reqFile, making it to point to the private key. This
forces the program to copy the private key to the output
buffer in the sprintf function on line 16, and then the
program sends the output buffer to the client on line 17.
Note that the attack alters no control data, and executes
the same execution path as the benign run.
This example illustrates the idea of data-ﬂow stitch-
ing, an exploit mechanism to manipulate the benign data
ﬂows in a program execution without changing its con-
trol ﬂow. Though it is not difﬁcult to manually analyze
this simpliﬁed example to construct a data-oriented at-
tack, real-world programs are much more complex and
often available in binary-only form. Constructing data-
oriented attacks for such programs is a challenging task
we tackle in this work.
2.2 Objectives & Threat Model
In this paper, we aim to develop techniques to automat-
ically construct data-oriented attacks by stitching data
ﬂows. The generated data-oriented attacks result in the
following consequences:
G1: Information disclosure. The attacks leak sensitive
data to attackers. Speciﬁcally, we target the following
sources of security-sensitive data:
• Passwords and private keys. Leaking passwords
and private keys help bypass authentication controls
and break secure channels established by encryption
techniques.
• Randomized values. Several memory protection
defenses utilize randomized values generated by the
program at runtime, such as stack canaries, CFI-
enforcing tags, and randomized addresses. Disclo-
sure of such information allows attackers bypass
randomization-based defenses.
G2: Privilege escalation. The attacks grant attackers the
access to privileged application resources. Speciﬁcally,
we focus on the following kinds of program data:
• System call parameters. System calls are used for
high-privilege operations, like setuid(). Cor-
rupting system call parameters can lead to privilege
escalation.
• Conﬁguration settings.
Program conﬁguration
data, especially for server programs (e.g., data
loaded from httpd.conf for Apache servers)
speciﬁes critical information, such as the user’s per-
mission and the root directory of the web server.
Corrupting such data directly escalates privilege.
Threat Model. We assume the execution environment
has deployed defense mechanisms against control-ﬂow
hijacking attacks, such as ﬁne-grained CFI [10,32], non-
executable data [12] and state-of-the-art implementation
of ASLR. Therefore attackers cannot mount control ﬂow
hijacking attacks. All non-deterministic system gener-
ated values, e.g., stack-canaries or CFI tags, are assumed
to be secret and unknown to attackers.
2.3 Problem Deﬁnition
To systematically construct data-oriented exploits, we
introduce a new abstraction called the two-dimensional
data-ﬂow graph (2D-DFG), which represents the ﬂows
of data in a given program execution in two dimensions:
memory addresses and execution time. Speciﬁcally, a
USENIX Association  
24th USENIX Security Symposium  179
3
address 
&privKey 
privKey1 
privKey1 
output 
&userInput 
&reqFile 
userInput1 
reqFile1 
userInput1 
reqFile1 
0 
6 
9 
12 
16 
time 
Figure 1: 2D-DFG of a concrete execution of Code 1. Black edges
are data edges, while grey edges are address edges. For clarity, ver-
tices do not strictly conform the order on address-axis (this applies to
all ﬁgures). We use line number to represent the time. var1 means a
particular value (constant) of the variable var in Code 1.
2D-DFG is a directed graph, represented as G = {V,E},
where V is the set of vertices, and E is the set of edges. A
vertex in V is a variable instance, i.e., a point in the two
dimensional address-time space, denoted as (a,t), where
a is the address of the variable, and t is a representation
of the execution time when the variable instance is cre-
ated. The address includes both memory addresses and
register names1, and the execution time is represented as
an instruction counter in the execution trace of the pro-
gram. An edge (v(cid:29), v) from vertex v(cid:29) to vertex v denotes
a data dependency created during the execution, i.e., the
value of v or the address of v is derived from the value of
v(cid:29). Therefore, the 2D-DFG also embodies the “points to”
relation between pointer variables and pointed variables.
Each vertex v has a value property, denoted as v.value.
A new vertex v = (a,t) is created if an instruction
writes to address a at the execution time t. A new data
edge (v(cid:29), v) is created if an instruction takes v(cid:29) as the
source operand and takes v as a destination operand. A
new address edge (v(cid:29), v) is created if an instruction takes
v(cid:29) as the address of one operand v. Therefore, an instruc-
tion may create several vertices at a given point in execu-
tion if it changes more than one variables, for instance in
the loop-preﬁxed instructions (e.g., repmov). Note that
the 2D-DFG is a representation of the direct data depen-
dencies created in a program execution under a concrete
input, not the static data-ﬂow graph often used in static
analysis. Figure 1 shows a 2D-DFG of Code 1.