(2) allow documents to safely embed untrusted remote con-
tent, such as YouTube videos. Oﬃce 2010 exposes a rich
add-in interface [39] which we used for all our modiﬁcations,
thus avoiding the need to access Word and Excel source
code.
Our add-in ensures that every opened document is routed
to an appropriate Word instance using CreatePI(), and it
extends Word’s hyperlink class, which is used to embed links
in documents, to enable an iframe-like embedding model,
allowing users to embed a frame pointing to a remote web
page or object. On Word’s “document open” event, our add-
in scans the document for these special hyperlinks, extracts
information such as frame’s URL, position, and dimensions,
and calls Embed() accordingly. In response, ServiceOS will
fetch corresponding remote content, dispatch it to a prop-
erly isolated principal instance, and connect the rendered
content’s visual output into its UI container in the Word
document. As an example, we have used our add-in to se-
curely embed video clips from YouTube, playable right from
1174the containing Word document — functionality that has so
far been unavailable in Word.
Our Word add-in consists of only 223 lines of C# code and
took about one man-day to write after getting familiar with
Word’s add-in APIs. As a separate exercise, we have ported
the plug-in to Excel 2010 to provide the same functionality.
This took only 2 man-hours and resulted in a 227-line Excel
add-in.
Each Word or Excel principal instance has its own UI
with all menu items, most of which perform functions on the
underlying document and continue to work on ServiceOS.
Some functions, such as document comparison or merge, will
not work if the involved documents are owned by diﬀerent
principals3. Although we have not yet done so, such features
can be enabled via explicit ServiceOS-mediated IPC between
diﬀerent instances of Word.
7.1.2 Wordpad
Wordpad is a sophisticated text editor. We pick it as
a case study of porting via source code modiﬁcation, since
unlike Word, Wordpad is not modularized and does not pro-
vide plug-in interfaces. It consists of more than 50k lines of
C++ code, and we consider it representative of reasonably
complex applications.
We extended Wordpad with the same ServiceOS support
as for Word and Excel. For example, we modiﬁed the docu-
ment parser to recognize special objects representing remote
content and to call Embed(), and we modiﬁed UI code to
make room for embedded content frames when rendering the
document. With no prior knowledge of Wordpad, this eﬀort
took about 50 hours for one author, with most of it spent on
understanding the source code. In total, we added only 435
lines of C++ code, and we expect that Wordpad develop-
ers could make these changes much more quickly. Overall,
our experience showed that adaptation onto ServiceOS is
feasible even when source code modiﬁcation is required.
7.1.3 Internet Explorer
As our primary browser renderer, we have ported Mi-
crosoft Internet Explorer’s Trident rendering engine to use
our new system APIs. This eﬀort closely mirrors the imple-
mentation of the Gazelle browser [49], so we omit further
details here. In summary, we changed Trident to use Ser-
viceOS system calls (see Table 1) using public IE COM inter-
faces, and by doing so, we forced Trident to use ServiceOS’s
isolation policies instead of IE’s. This could impact web
compatibility. While this merits further investigation, re-
cent work showed that an architecture like ours should have
little or no compatibility hit [44].
7.1.4 Microsoft Outlook 2010
Microsoft Outlook 2010 is a popular e-mail and personal
information management application. Outlook needs to iso-
late untrusted content in e-mail messages, but unlike Word
documents or web pages, e-mail messages are not address-
able via URLs. For such content, applications can still use
our Embed() call to conveniently oﬄoad content isolation
while still rendering it in-place with the rest of application’s
UI. We follow this approach and extend Outlook to use Em-
bed() to render e-mail messages in-place as before, but in
3Note that is an example of a future problem that never
actually occurs in Oﬃce today.
Content processing
Total
(prevented in ServiceOS)
Microsoft Oﬃce
Adobe Reader
Internet Explorer
256
202
144
224 (88%)
64 (83% of known∗)
122 (85%)
Table 2: Security analysis of vulnerabilities (’08-’11).
∗ We could not analyze 125 Adobe vulnerabilities with unspeciﬁed
attack vectors.
a separate protection domain, using our IE renderer (Sec-
tion 7.1.3). Because ServiceOS cannot determine such con-
tent’s owner information or even retrieve it, we let Outlook
download message bodies and provide them directly to Em-
bed (via “data:” URLs); ServiceOS uses uniquely-labeled
containers in such cases.
Outlook’s own protection mechanisms for restricting e-
mail rendering, such as ﬁlters for , ,
and other dangerous tags, have been error-prone: two re-
cent patches ﬁxed 15 vulnerabilities that, in most severe
cases, allowed attackers to take control of a system when a
victim simply viewed a specially-crafted e-mail [34]. With
ServiceOS, Outlook gains stronger isolation from e-mail ren-
dering bugs, while e-mail content can beneﬁt from additional
functionality provided by IE, such as scripts and embeddable
iframes.
We also extended Outlook to safely preview attachments
using any ServiceOS content processor. ServiceOS picks the
renderer based on the content type of the attachment; this
replaces previewer lookup in the system-wide Windows reg-
istry, which is unavailable in sandboxed applications. This
isolation is not only stronger but also more usable, as it ob-
viates Outlook’s prompting the user to consent to a preview
of untrusted attachments.
Like Word, we modiﬁed Outlook using its add-in frame-
work. This eﬀort required 20 hours, including the time to
understand Outlook’s add-in model, and resulted in a small
342-line add-in.
7.2 Vulnerability analysis
We analyzed vulnerabilities published for three large Win-
dows applications during 2008-2011 [2, 34]. We evaluated
whether ServiceOS’s design mitigated these vulnerabilities
by checking whether each vulnerability was related to pars-
ing or other content processing errors. The results are shown
in Table 2. Content processing errors are widespread: 88%
of Oﬃce vulnerabilities and 85% of IE vulnerabilities are re-
lated to content parsing. Adobe Reader’s numbers included
125 vulnerabilities with unknown attack vectors; of the rest,
83% involved content processing. Exploits of all these ﬂaws
would be naturally contained if users were using these appli-
cations on ServiceOS; Section 7.3 demonstrates this with two
concrete exploits. The rest of the vulnerabilities that Ser-
viceOS cannot contain include insecure library loading vul-
nerabilities exploitable by planting malicious DLLs, HTML
sanitization vulnerabilities leading to XSS, and denial-of-
service vulnerabilities.
The ServiceOS monitor has only 9.4K lines of code which
is signiﬁcantly smaller than many applications. For exam-
ple, OpenOﬃce has about 9M lines of code [6], and even the
relatively simple Wordpad has more than 50K lines of code.
Fundamentally, ServiceOS does not rely on large applica-
1175Figure 6: Time to start applications.
tions to enforce remote content security and thus reduces
the TCB for isolation logic signiﬁcantly.
7.3 Exploit mitigation
To verify that our system can indeed stop exploits of con-
tent processing ﬂaws we analyzed above, we examined two
real-world Word 2010 exploits. First, we used a proof-of-
concept parsing exploit that uses an RTF Header stack over-
ﬂow vulnerability [35] to construct a malicious document
that looks for other, potentially sensitive Word documents
the user has concurrently opened the same Word instance
and sends them to an attacker via HTTP. The attack worked
successfully on Word 2010 version 14.0.4760, bypassing both
DEP and ASLR.4
We also crafted a second malicious document that uses
macros to perform the same attack. Word treats documents
opened from the web as untrusted and does not run macros
by default, but oﬀers users a choice to trust the document
via a single click on a yellow security button above it. The
attack document tricks the victim to click on this button by
pretending to be a greeting card that needs permission to be
customized. Such an attack is much easier to implement as
it does not require bypasses of existing security mechanisms,
and it demonstrates the pitfalls of relying on user prompts
for isolation decisions. This attack works on the latest ver-
sion of Word 2010, provided the victim clicks on the yellow
security button.
Note that application-based isolation (such as that on iOS
or Android) would also not be able to stop these two exploits,
as they both work within the permission boundaries of their
Word instance.
Next, we tried opening both attack documents in Word
running on ServiceOS. We ran ServiceOS with UID-based
sandboxing (Section 6), as Drawbridge does not yet cor-
rectly support libraries to parse an older Word document
format required in the ﬁrst exploit, or to run macros for
the second exploit. We observed that ServiceOS stopped
both exploits. Moreover, ServiceOS’s Word version did
not use any user prompts to enable macros — it no longer
needs to restrict remote documents in any way since they
are already isolated according to their owner. This provides
better user experience for documents that legitimately use
dangerous features such as macros or ActiveX.
7.4 Performance
In measuring ServiceOS performance, we were primarily
interested in (1) startup latencies we impose on opening doc-
uments, which could happen in an existing process on Win-
dows but require starting a new process in our model, (2)
4Microsoft has patched this vulnerability in later Word ver-
sions.
Figure 7: Memory committed for increasing instances
of Excel. Each new instance loads a 10MB document.
overheads on memory usage, since our model uses more pro-
cesses, one for each content owner rather than one per appli-
cation, and (3) performance of our content fetch APIs, which
ServiceOS applications must use instead of native Windows
libraries. Our measurements were performed on a 64-bit
Windows 7 desktop with dual 3.16GHz Intel Xeon E8500
Duo-Core CPUs, 4GB of RAM, and a Broadcom NetX-
trem Gigabit Ethernet NIC. We present results for three
applications: Excel 2010, Internet Explorer (IE), and Word-
pad. Excel and Wordpad experiments used 10KB, 10MB
and 100MB documents; IE was used to open a simple test
page on an Intranet web server. We separate the overhead
of Drawbridge from overhead of the rest of our system where
possible, since our system can also work with other sandbox-
ing mechanisms. To run a ServiceOS application without
Drawbridge, we execute it as a regular Windows process.
Startup latencies. The ServiceOS monitor and shell
take 118ms to start. After a user navigates to a URL, our
system starts up the appropriate renderer. Figure 6 com-
pares this startup time to startup times of applications’ na-
tive versions on Windows. We ﬁnd that most overhead (up
to 1.5 sec) comes from starting the Drawbridge environment.
Excluding Drawbridge, in all tests ServiceOS adds less than
200ms to connect to the monitor and initialize. An obvious
optimization is to maintain a small number of pre-created
renderers for popular content types. Even without this op-
timization, we feel the startup overhead is acceptable. For
example, if a user is viewing a web page with an embed-
ded 10KB Excel spreadsheet, starting our modiﬁed Excel on
ServiceOS would add only 112ms to Excel’s normal startup
time.
Memory usage. We measured the committed memory
size for each application with one document open. Excel
running on ServiceOS uses about 47MB more memory than
when running on Windows, regardless of document size.
This is due to Excel’s loading of interoperability DLLs re-
quired to run any Excel add-in; our plug-in itself has neg-
ligible additional memory cost. Both Wordpad and ported
IE carry a very small memory overhead (less than 3MB),
which is required to load and initialize our 74KB LibSer-
viceOS DLL. Drawbridge isolation introduces an additional
overhead of up to 37MB for Excel.
Figures 7 and 8 show the aggregate memory usage for
running multiple instances of Excel and Wordpad simultane-
ously. Both native and ServiceOS-enabled Excel is capable
of opening multiple documents in the same process or sepa-
rate processes. ServiceOS-enabled Excel render documents
in the same process only if their owners are the same; e.g.,
0.3 0.6 4.2 0.4 1.0 5.3 0.4 0.4 0.8 4.4 0.5 1.0 5.3 0.5 0.5 0.9 5.7 0.9 1.3 5.7 1.9 0.02.04.06.08.010.0Excel 10KBExcel 10MBExcel100MBWordpad10KBWordpad10MBWordpad100MBInternetExplorerStart Time (s) WindowsServiceOSServiceOS (Drawbridge)04008001200160012345678910Memory Size (MB) Windows (single process)Windows (multi-process)ServiceOS (single process)ServiceOS (multi-process)ServiceOS (Drawbridge)11768. RELATED WORK
Browsers. Much recent work in browsers explored
stronger isolation of web sites. OP [18] applies a microker-
nel architecture design with a browser kernel that enforces
SOP. Tahoma [10] isolates (its own deﬁnition of) web appli-
cations using virtual machines. Major commercial browsers
like Chrome and IE have adopted a process-per-tab kind of
multi-process model and reduce privileges of tab processes.
Gazelle [49] has a design that treats web sites as OS prin-
cipals and makes its browser kernel the exclusive place for
cross-principal protection. Our work builds on Gazelle and
generalizes Gazelle’s design to support all applications be-
yond web applications. We introduce the notion of a con-
tent processing stack to give a uniform treatment for both
web content and content processed by native applications,
we generalize browsers’ same-origin policy to allow arbitrary
isolation granularity for URI-addressable content and to en-
able separation of owning and hosting, and we introduce the
dispatch bit mechanism to enforce principal deﬁnitions.
Modern client platforms.
iOS, Android, Windows
Phone, Windows 8, and the research OS Singularity [20, 51]
all treat application code packages as diﬀerent principals
and put their execution instances into separate processes
with diﬀerent uids. While this marks a milestone of ﬁnally
moving away from the decades-old model of treating user
accounts as principals, we take another signiﬁcant step by
advocating a content-based principal model.
IBOS [45] aims to reduce the trusted computing base for
browsers by applying a microkernel design for all traditional
OS components, exposing browser abstractions at the lowest
software layer and removing many components not needed
by browsers. IBOS solves an orthogonal problem from ours.
Our problem is to let the OS provide content-based isolation
for browsers and non-browser applications alike.
Embassies [19] describes web browsers as pico-datacenters
where each ”machine” corresponds to a web site and is iso-
lated from other sites or ”machines”. This view is consistent
with the semantics of existing browsers where the same-
origin policy is applied to isolate web sites. Nevertheless,
existing browsers do not realize isolation reliably. Embassies
advocates refactoring browsers into the CEI and the DPI.
This mirrors the refactoring done in Gazelle [49]: CEI cor-
responds to the Browser Kernel API in Gazelle which is
runtime-independent; DPI corresponds to the runtime API
in Gazelle’s principal instances, which allows any program-
ming languages or enrichment of the runtime as needed. Em-
bassies deﬁnes web site principals using public keys, similar
to one of our principal ID proposals (Section 4.2.1). Our
work additionally considers content processing stacks (Sec-
tion 4.1) and cross-principal content fetch of two forms: data
communication and spawning new principals (Section 5)
which are commonplace in practice. Finally, ServiceOS aims
to support both web applications and native applications
on the same OS platform without compromising security se-
mantics of the web while allowing easy adaptation of native