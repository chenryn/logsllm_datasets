Colors
::= · | x:t | α | e (cid:31) p | Γ1,Γ2
::= · | (x (cid:55)→ e) | (α (cid:55)→ t) | σ1,σ2
::= pol | app
Γ (cid:96)c n : int (T-INT)
Γ (cid:96) t
Γ, f :t (cid:96)c v : t
(T-FIX)
Γ (cid:96)c ﬁx f :t.v : t
Γ,x:t (cid:96)c e : t(cid:48)
Γ (cid:96) t
Γ (cid:96)c λ x:t.e : (x:t) → t(cid:48)
Γ,α (cid:96)c e : t
Γ (cid:96)c Λα.e : ∀α.t
(T-TAB)
(T-ABS)
Γ (cid:96)c e1 : (x:t1) → t2
Γ (cid:96)c e1 e2 : (x (cid:55)→ e2)t2
x:t ∈ Γ
Γ (cid:96)c x : t
Γ (cid:96)c e : ∀α.t(cid:48)
Γ (cid:96) t
Γ (cid:96)c e[t] : (α (cid:55)→ t)t(cid:48)
Γ (cid:96)c e2 : t1
(T-APP)
(T-VAR)
(T-TAP)
Γ (cid:96)c ei : lab
(T-LAB)
Γ (cid:96)c C((cid:126)e) : lab∼C((cid:126)e)
Γ (cid:96) t
Γ,(cid:126)xi:lab (cid:96)c pi : lab
(cid:126)xi = FV (pi)\ dom(Γ)
Γ (cid:96)c e : lab
pn = x where x (cid:54)∈ dom(Γ)
Γ,(cid:126)xi:lab,e (cid:31) pi (cid:96)c ei : t
Γ (cid:96)c match e with p1 ⇒ e1 . . . pn ⇒ en : t
Γ (cid:96)c e : lab∼ e(cid:48)
Γ (cid:96)c e : lab
(T-HIDE)
Γ (cid:96)c e : lab
Γ (cid:96)c e : lab∼ e
(T-SHOW)
(T-MATCH)
Γ (cid:96)pol e : t{e(cid:48)}
Γ (cid:96)pol {◦}e : t
(T-UNLAB)
Γ (cid:96)pol e : t
Γ (cid:96)pol e(cid:48) : lab
Γ (cid:96)pol {e(cid:48)}e : t{e(cid:48)}
(T-RELAB)
Γ (cid:96)pol e : t
Γ (cid:96)c ([e]) : t
(T-POL)
Γ (cid:96)c e : t
Γ (cid:96) t ∼= t(cid:48)
Γ (cid:96)c e : t(cid:48)
(T-CONV)
Γ (cid:96) t ∼= t(cid:48)
Γ (cid:96) t ∼= t (TE-ID)
Γ (cid:96) t
Type contexts T
L
Term label contexts
Γ (cid:96) t ∼= t(cid:48)
Γ (cid:96) t(cid:48) ∼= t
(TE-SYM)
Types t and t(cid:48) are convertible
::= • | •{e} | x:• → t | x:t → • | ∀α.•
::= lab∼• | t{•}
Γ (cid:96) t ∼= t(cid:48)
Γ (cid:96) T ·t ∼= T ·t(cid:48)
(TE-CTX)
e (cid:31) p ∈ Γ
Γ (cid:96) L· e ∼= L· p
(TE-REFINE)
∀σ .(dom(σ) = FV (e1) ∧ Γ (cid:96) σ(e1) : lab) ⇒ σ(e1) c(cid:32) σ(e2)
Γ (cid:96) L· e1 ∼= L· e2
(TE-REDUCE)
Type t is well-formed in environment Γ
Γ (cid:96) int (K-INT)
α ∈ Γ
Γ (cid:96) α (K-TVAR)
Γ (cid:96) lab (K-LAB)
Γ (cid:96)pol e : lab
Γ (cid:96) lab∼ e
(K-SLAB)
Γ (cid:96) t
Γ (cid:96)pol e : lab
Γ (cid:96) t{e}
(K-LABT)
Γ (cid:96) t1
Γ,x:t1 (cid:96) t2
Γ (cid:96) (x:t1) → t2
(K-FUN)
Γ,α (cid:96) t
Γ (cid:96) ∀α.t
(K-ALL)
Figure 4. Static semantics of FABLE
procedures that can be used to partially decide type con-
vertibility. One simpliﬁcation would be to attempt to show
convertibility for closed types only—i.e. no free variables.
In our implementation of FABLE, SELINKS, we use a com-
bination of three techniques. First, we use type information.
If l is free in a type, and the declared type of l is lab∼e,
then we can use this information to substitute e for l. Simi-
larly, if the type context includes an assumption of the form
l (cid:31) e (when checking the branch of a pattern), we can sub-
stitute l with e. Finally, since type-level expressions typi-
cally manipulate labels by pattern matching, we use a sim-
ple heuristic to determine which branch to take when pat-
tern matching expressions with free variables. These tech-
niques sufﬁce for all the examples in this paper and both our
SEWIKI and SEWINESTORE applications. Our technical
report [38] discusses these decision procedures in greater
detail and proves them sound.
Finally, the judgment Γ (cid:96) t states that t is well-formed in
Γ. Rules (K-INT), (K-TVAR), and (K-LAB) are standard,
(K-FUN) deﬁnes the standard scoping rules for names in
dependent function types, and (K-ALL) deﬁnes the stan-
dard scoping rule for universally quantiﬁed type variables.
(K-SLAB) and (K-LABT) ensure that all expressions e that
appear in types can be given lab-type. Notice that type-
374
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:10:14 UTC from IEEE Xplore.  Restrictions apply. 
level expressions are typed in pol-context. Because FABLE
enjoys a type-erasure property any (un)labeling operations
appearing in types pose no security risk. We use this feature
to good effect in Section 3.2 to protect sensitive information
that may appear in labels.
2.3. Operational Semantics
Figure 5 deﬁnes FABLE’s operational semantics. We
deﬁne a pair of small-step reduction relations e app(cid:32) e(cid:48) and
e pol(cid:32) e(cid:48) for application and policy expressions, respectively.
Rules of the form e c(cid:32) e(cid:48) are polychromatic—they apply
both to policy and application expressions. Since the values
for each kind of expression are different, we also parameter-
ize the evaluation contexts Ec by the color of the expression;
i.e., the context, either app or pol, in which the expression is
to be reduced. Rule (E-CTX) uses these evaluation contexts
Ec , similar to the type contexts used above, to enforce a
left-to-right evaluation order for a call-by-value semantics.
Policy expression reduction e pol(cid:32) e(cid:48) takes place within brack-
ets according to (E-POL). The rules (E-APP), (E-TAP), and
(E-FIX) deﬁne function application, type application, and
ﬁxed-point expansion, respectively, in terms of substitu-
tions; these are all standard. Rule (E-MATCH) relies on a
standard pattern-matching judgment v (cid:31) p : σ, also deﬁned
in Figure 5, which is true when the label value matches the
pattern such that v = σ(p).
(E-MATCH) determines the
ﬁrst pattern p j that matches the expression v and reduces
the match expression to the matched branch’s body after
applying the substitution. The (U-CON) rule in the pattern-
matching judgment v (cid:31) p : σ is the only non-trivial rule. As
explained in Section 2.2, since pattern variables may occur
more than once in a pattern, (U-CON) must propagate the
result of matching earlier sub-expressions when matching
subsequent sub-expressions. For example, pattern match-
ing should fail when attempting to match ACL(Alice,Bob)
with ACL(x,x). This is achieved in (U-CON) because, after
matching (Alice (cid:31) x : x (cid:55)→ Alice) using (U-VAR), we must
try to match Bob with (x (cid:55)→ Alice)x, which is impossible.
An applied policy function will eventually reduce to a
bracketed policy value vpol. When vpol has the form ([u]), the
brackets may be removed so that the value u can be used
by application code. (E-BLAB) and (E-BINT) handle label
expressions ([C((cid:126)u)]) and integers n, respectively. To main-
tain the invariant that (un)labeling operators only appear in
policy code, rules (E-BABS) and (E-TABS) extrude only
the λ and Λ binders, respectively, from bracketed abstrac-
tions, allowing them to be reduced according to (E-APP) or
(E-TAP). Brackets cannot be removed from labeled values
([{e}u]) by application code, to preserve the labeling invari-
ant. On the other hand, brackets can be removed from any
expression by policy code, according to (E-NEST). This
is useful when reducing expressions such as ([λ x:t.x])([v]),
which produces ([([v])]) after two steps; (E-NEST) (in com-
bination with (E-POL)) can then remove the inner brackets.
Finally, (E-UNLAB) allows an unlabeling operation to an-
nihilate the top-most relabeling operation. Notice that the
expressions within a relabeling operation are never evalu-
ated at runtime—relabelings only affect the types and are
purely compile time entities. The types that appear else-
where, such as (E-TAP), are also erasable, as is usual for
System F.
2.4. Soundness
We state the standard type soundness theorems for FA-
BLE here. In addition to ensuring that well-typed programs
never go wrong or get stuck, we have put this soundness
result to good use in proving that security policies encoded
in FABLE satisfy desirable security properties. We discuss
this further in the next section. Our technical report [38]
contains proofs of the following theorems for an extension
of FABLE that includes references and substructural types.
If · (cid:96)c e : t; then either
Theorem 1 (Type soundness).
∃e(cid:48).e c(cid:32) e(cid:48) or ∃vc.e = vc. Furthermore, if e c(cid:32) e(cid:48); then,
· (cid:96)c e(cid:48) : t.
3 Example Policies in FABLE
This section uses FABLE to encode several security poli-
cies. We prove that any well-typed program using one of
these policies enjoys relevant security properties—i.e., the
program is sure to enforce the policy correctly. Space con-
straints preclude presentation of all of the encodings we
have explored, so we focus on three kinds of policies: ac-
cess control, provenance, and static information ﬂow. We
conclude by discussing how FABLE’s design eases the con-
struction of proofs of policy correctness.
3.1. Access Control Policies
Access control policies govern how programs release in-
formation but, once the information is released, do not con-
trol how it is used. To prove that an access control pol-
icy is implemented correctly, we must show that programs
not authorized to access some information cannot learn the
information in any way, e.g., by bypassing a policy check
(something not uncommon in production systems [34]) or
by exploiting leaks due to control-ﬂow or timing channels.
We call this security condition non-observability.
Intuitively, we can state non-observability as follows. If
some program P is not allowed to access a resource v1 hav-
ing a label l, then a program P(cid:48) that is identical to P ex-
cept that v1 has been replaced with some other resource v2
375
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:10:14 UTC from IEEE Xplore.  Restrictions apply. 
e c(cid:32) e(cid:48)
Small-step chromatic reduction rules
Evaluation contexts Ec
::= •e | vc• | •[t] | C((cid:126)vc,• ,(cid:126)e)
| match• with pi ⇒ ei | {e}• | {◦}•
(λ x:t.e) vc
c(cid:32) (x (cid:55)→ vc)e (E-APP)
(Λα.e) [t]
c(cid:32) (α (cid:55)→ t)e (E-TAP)
e c(cid:32) e(cid:48)
(E-CTX)
Ec · e c(cid:32) Ec · e(cid:48)
([e]) app(cid:32) ([e(cid:48)])
ﬁx f :t.v c(cid:32) ( f (cid:55)→ ﬁx f :t.v)v (E-FIX)
e pol(cid:32) e(cid:48)
(E-POL)
∀i < j. vc (cid:54)(cid:31) pi : σi
vc (cid:31) p j : σ j
match vc with p1 ⇒ e1 . . . pn ⇒ en
c(cid:32) σ j(e j)
(E-MATCH)
([C((cid:126)u)]) app(cid:32) C((cid:126)u) (E-BLAB)
([n]) app(cid:32) n (E-BINT)
([λ x:t.e]) app(cid:32) λ x:t.([e]) (E-BABS)
([Λα.e]) app(cid:32) Λα.([e]) (E-BTAB)
([e]) pol(cid:32) e (E-NEST) {◦}{e}vpol
pol(cid:32) vpol
(E-UNLAB)
e (cid:31) p : σ
Expression e matches pattern p under substitution σ
p (cid:31) p : ·
(U-PATID)
v (cid:31) x : x (cid:55)→ v (U-VAR)
∀i.σ∗
i = (σ0, . . . ,σi−1)
ei (cid:31) σ∗
i pi : σi
C((cid:126)e) (cid:31) C((cid:126)p) : (cid:126)σ
(U-CON)
Figure 5. Dynamic semantics of FABLE
(having the same type and label as v1) should evaluate in
the same way as P—it should produce the same result and
take the same steps along the way toward producing that
result. If this were not true then, assuming P’s reduction
is deterministic, P must be inferring information about the
protected resource.
To make this intuition formal, we will show that the eval-
uations of programs P and P(cid:48) are bisimilar, where the only
difference between them is the value of the protected re-
source. To express this, ﬁrst we deﬁne an equivalence re-
lation called similarity up to l (analogous to deﬁnitions of
low equivalence [32, 7]) which holds for two terms e and e(cid:48)