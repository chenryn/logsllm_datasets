执行面退出，同时Android系统报告一个段违规（segmentation fault）为止。
尽量记住你给应用程序输入了多少个字符，因为在使用gdbserver 进行调试
时，你需要输入同样数目的字符来触发前溃。图8.21是这个可执行文件正常
运行时的屏幕截图。
(oob)nune
thecore
aryuoa
-overflom.c:7
gdb)c
[Inferlor 1(Renote target)exited nornally]
The progran Is not beting run.
图 8.21
你可以看到GDB输出了exited normally，这表示进程的返回值是正常的，且
没有命中任何断点也没什么追使进程暂停下来。
如果给应用程序的输入字符太多，它就会报一段违规错，并退出。在GDB
中显示如图8.22所示。
255
---
## Page 274
Android安全攻防实战
(gdb)c
ontinutng
Progran recelved stgnal sIcsEGv,Seg
tatton fault.
odb）1
X
8x13
19
39488
6x8
1092158748
ex8Aed
34829
1092158652
exbee6fbso
0x2
1092158640
8x8
9
6x0
oxfffdad84
1092158660
exbee6fbes
152188
0x84e5
34021
1610612752
图8.22
2.在gdbserver中启动应用程序，给它一个“不安全”的大量输入，即，输入能
让它前溃的数目的字符。对于我们的代码而言，输入的应该是大于14至16
个字符的任意字符串。在这个例子中，我输入了约16个字符，以确保我能
覆盖掉内存的正确位置上的数据。
3.运行androideabi-gdb并连接到远端进程。如果需要复习一下，请翻阅第6章
4.用GDB设置几个断点。我们在调用strcpy的blx指令前后各设置一个断点，
如图8.23这张截图所示。
图 8.23
256
---
## Page 275
第8章原生代码中漏润的利用与分析
你可以用brcak命令或者它的简写b，来设置断点。设置断点时，
要输入断点在源码中的行号或存放这条指令的内存地址。如果是
以后一种方式表示断点地址的话，还要在内存地址之前加上个
“号。
5.断点设置完毕后，通过gdbsever重新运行该应用程序，并用Android GDB重
新连接它。后面会对每个断点作解释。接下来你要做的就是：在GDB提示
符下输入continue，或它的缩写符c。GDB就会继续执行程序直至命中某个
断点。
我们到达的第一个断点位于调用strcpy之前。在这里设置断点的目的，是想
让你能看到调用strcpy之前之后栈的变化情况。搞清楚这一点是非常重要的，
因为这样你就能计算出：要传给应用程序多少数据才能覆盖掉函数的返回地
址。图8.24这张截图显示了这一点。
gdb)tergetrenate:3i337
hat GoB
tuluers
db)c
otacce
图 8.24
这是调用 strcpy之前，vulnerable函数栈的快照。除了已经为局部变量预留
了一些空间外，没什么大的变化。到达第一个断点后，你需要打印栈中存储
的数据，对栈进行一番检查。
下面的例子中，在GDB中执行x命令来达到目的的。
x/32xw $sp
这个命令告诉GDB，将sp（栈指针）寄存器指向的位置起，以十六进制形
257
---
## Page 276
Android安全攻防实战
式打印32个word中的内容。你将看到如图8.25所示的内容。
(odb)disass vulnerable
0084d0:
for functlon vulnerable:
aush
{rθ,r1,r2,r3,r4,lr}
0x000084d4
:
≤+2＞
add
r1,rθ,#0
0x000084d6
:
blx
：
re,[pc,#12]
;(0x84e8)
:
:
add
r1,sp,#4
0x000084e0
0x000084e4
:
ppe
0x088684e6
sp,#20
@x000084e8
:
(pc)
:
r1,rθ,r6,asr r5
nd of assenbler
durp
（qdb）x/32xw$sp
0xbee6faf0:
6xbee6fc75
0xbee6fb44
oxbee6fb58
exbee6fb00:
Bxbee6fb10:
6x066684ed
0x000684fs
0x806
Bx488366f9
exbee6fb28
oxbee6fb30:
0x0000ae84
0x0000000
0x0000ae94
0x40004bbb
0x0000ae8c
oxbee6fb40:
oxbee6fc7s
axbee6fbso:
exbee6fcc6
exbee6fcd7
0xbee6fe68
exbee6feB1
0xbee6fe95
(gdb)
图8.25
你可能已经注意到，我选中了其中的一些值。它们是函数在初始化时被压入
栈中的，也就是由下面这条指令压入栈中的。
push (r0, r1,r2, r3, r4, 1z}
这条push 指令一
一也就是别才使用的指令一是用来在调用函
数时，保存寄存器中存储的值的。这条指令用来确保，当被调函
数返回到主调函数时，通过栈，能把各个寄存器原来的值一一还
原到对应的寄存器中。
在这条PUSH指令中使用一个值是Ir或link寄存器。link寄存器中通常存放
的是当前函数的返回地址。这里，Ir寄存器中保存的值是0x000084f5。稍后
我们将试图用我们能控制的一个值把它覆盖掉。几分钟之内你就能看到，我
们是怎么用我们输入的数据去修改这个值的，所以眼下暂时先记住它。
①原文如此，不过看一眼下面的截图你就会发现打印的是32个DWORD。—译者注
258
---
## Page 277
第8章原生代码中漏洞的利用与分析
我们这样做的原因是：vulnerable函数最终会要执行下面这条指令。
Pop (pe)
该指令将保存在栈中的LR值直接写入程序计数寄存器。这使得程序可以继
续执行保存在LR寄存器中的地址上的指令。如果我们覆盖了保存在栈中的
LR值，我们就可以有效地控制vulnerable函数返回后，程序跳转到哪里去执
行。接下来的步骤中将介绍如何精确地进行计算，把某些东西写到程序里去，
能确保你像上面描述的那样控制程序。
6.继续到下一个断点，当GDB命中该断点时，strcpy会把你的输入写到堆栈里。
现在再来检查一下栈，会产生如图8.26所示的输出。
(ont)nuing.
printf([xis]\n,dest)://print theresult
abte (s
o）x/32xM550
6fb00
faf6
txbee6fc75
x6664736
64667361
oee6fb28
exbeefcs9
oxbee6fe2b
xbeesfcee
oxbeeefe68
bxbee6fe81
beesfcd
（gb）
图 8.26
你应该注意到之前的0x000084f5已经变成0x00008400了。它们看上去有点
像。这是因为strcpy把我们的输入写到缓冲区时，它只是用我们的字符串最
后面的NULL字节部分覆盖了保存下来的LR的值。这就是为什么0xf5会被
替换为0×00的原因。现在我们知道，输入16个字符会覆盖保存下来的返回
地址中的一个字节。这意味着完全覆盖2个字节的返回地址，我们需要再加
入2个字节的输入—再加上NULL字节，这最后4个字节将成为新的返回
地址。下面是它如何工作的。
在调用strcpy之前，栈的结构如表8.5所示。
表8.5
我们不关心的输入缓冲区
保存下来的
栈中的内容
占据的部分
Ir 值
Oxbee6fc75
0xbee6fb44
0xbee6fb500x000000000x000084ed0x00000
0x840xF5
在用输入的16个字节调用了strcpy之后，栈的结构变成了表8.6所示的这个样子。
259
---
## Page 278
Android安全攻防实战
表8.6
我们不关心的
输入缓冲区占据的
保存下来的Ir值
栈中的内容
部分
0xbee6fc75
16个字符
0x00000
0x84
0x00
加粗的0x00值来自于我们输入的NULL字节。在此基础上，为了控制新的返回
地址，我们还要输入16再加2个字符，它会是如表8.7所示。
表8.7
我们不关心的栈中输入缓冲区占据的
保存下来的lr值
的内容
部分
0xbee6fc750
[16 chars]
x00000
0x??
0x??
这里，0x?2字符表示我们额外给strcpy输入的，想用它覆盖返回地址的字符。
而且，我们再一次看到，紧跟在我们的输入后面的是0x00字符。
7.用给定的输入再运行一遍GDB server。我们打算试着跳过输出”youlose”的这
个printf函数，并以这个函数是否被执行作为验证标志一这个是确定你是
不是已经成功地重定向了控制流的简单的检查方法。问题是：你能把控制流
重定向到哪里去呢？下面是一个如何获取重定向目标地址的方法。在GDB
shell里执行disass main命令，会产生如图8.27所示的输出。
0x000084ec : push (x3,1x)
0x000084ee : 1dr r0,[r1, #4]
0x000084f0 : b1 0x84d0 
0x000084f4: 1dr r0,[pc,#8]
0x000084f6 : add r0,pc
0x000084f8 :blx 0x83f8
0x000084f3:pop (x3,pc)
0x000084fc : movs r0,#0
0x00008500 : andeq x1,z0,r2,asr,x5
[E 8.27