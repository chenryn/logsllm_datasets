possible reasons for this. First, there are no valid dispatcher blocks.
Second, gadgets required to build the payload are not available to the
dispatcher. Lastly, the constraints on the payload are unsatisfiable.
Lastly, in order to better understand the failing attempts Table 8
lists the exact reasons for failure. As such, in most cases, a required
gadget was missing, such as an arbitrary memory write gadget. In
other cases, when generating the complex mprt payload, the search
timed out as in column 13—from left to right—in Table 8 for the
programs Nginx, Apache Httpd, and Redis.
7 DISCUSSION
Symbolic Execution. Symbolic execution is a powerful approach
for payload generation as it allows for automated exploration of the
program control flow graph, precisely program state reasoning, and
automatic generation of the payload. However, it is greatly limited
by the size of the target binary. Further, by for example using basic
block constraints summaries, similarly to BOPC [24], this could en-
able a better analysis of combinations of gadgets, at the cost of even
more runtime performance increase, making them infeasible for
large binaries. However, an alternative approach based on pattern
recognition instead of symbolic execution would lead to significant
speedup, sacrificing the capabilities to identify complex, branching,
but still usable gadgets.
iTOP’s Analysis Generality. In this work, we focus on COOP-
like attacks, similarly to [48], but we envisage iTOP to be used for
crafting other types of attacks as well. In contrast to Newton, for
example, iTOP is currently limited to static CFI defenses but can
be extended to work with dynamic CFI defenses. In this work, we
decided to mainly address the expressiveness of our attack specifi-
cation language (ESL) and thus focusing only on static CFI defenses.
Further, in order for iTOP to craft other attack types, the calltargets
(i.e., gadgets) used within an attack have to be reconsidered such
that consecutive instructions (i.e., gadgets) can be targeted by the
indirect control flow transfers used to assemble the gadget chain.
In order to achieve this, the first step is to use an analysis that
first classifies these gadgets and then creates a map with all their
locations in memory.
Tool Potential. As opposed to a common belief that high percent-
ages in the realm of automated attack construction is an indicator
for tool potential we rather think that this is not the most essential
indicator for tool potential, as attack success depends on the types
of gadgets used and it is less significant to have for example 1000
possible attack variations for a single target program but rather
13
one attack is sufficient to perform the attack. Further, in real attack
creation scenarios, the situation is more simplified as all available
tools are used to craft the attack. Note that only one of these tools
has to be successful.
Gadget Evaluation. Due to intrinsic limitations of symbolic exe-
cution: reads from, writes to, and jumps to unconstrained addresses
cannot reliably be evaluated, as these would lead to state explosion
issues. We addressed this within iTOP by constraining reads and
writes to point to predefined addresses. This solution is far from
being perfect, and some usable gadgets might be missed. Further,
reads and writes to symbolic file descriptors and I/O in general is
also hard to model using symbolic execution, as there is no way
to predict which files are present and what these contain during
the actual execution of the target program. iTOP addresses this
by skipping all functions containing I/O, possibly missing gadgets.
Also large gadgets (size > 1k bytes), gadgets containing many calls
to other functions, and gadgets that would require symbolic objects
larger than 128 bytes to be simulated are currently skipped to avoid
increased runtime overhead.
COOP Attacks. iTOP generates COOP and COOP-like attacks,
which do not violate the program stack discipline, thus eliminating
the need to bypass shadow stack techniques. Further, we showed
that COOP attacks are flexible enough to work around CFI con-
straints, and powerful enough to implement complex control flows.
Lastly, as long as no fully precise class hierarchy based CFI policy
is enforced our attacks are feasible in a majority of cases.
8 LIMITATIONS AND FUTURE WORK
Gadget Discovery Time. For large binaries such as web browsers,
iTOP needs a large amount of time to be spent in order to generate
a payload due to the number of gadgets that have to be evaluated.
In future work, by developing a more precise gadget discovery
framework for COOP, COOP-like or arbitrary attacks that can
pre-calculate the set of usable gadgets for a target binary it could
provide significant help for attack building frameworks, reducing
their domain purely to finding gadget chains.
Gadget Search Granularity. iTOP analyzes one function at a time
and maps one ESL statement to one gadget. In some cases, multiple
ESL statements can be mapped using only one gadget, or multiple
gadgets could be combined to fulfill the requirements defined by one
ESL statement. While both of these issues can be mitigated by our
gadget chaining algorithm, an analyst has to manually specify all
alternatives required, which requires precise knowledge of iTOP’s
limitations. In future work, by making iTOP inherently aware of
such shortcuts, we could improve its gadget generation and analysis
capabilities as more attacks could be constructed.
Attack Probabilities Formula. To carry out the attack we need
a suitable gadget of each type. These types of gadgets do not have
necessarily the same frequencies. It might be that, say, 5% of the
functions is suitable as a dispatcher, 20% to write %rdi, and 1% to
execute a function. Now we need one of each for a particular attack.
W.r.t. this point Equation 2 might be too simple, as it does not con-
sider the differences in probabilities. Moreover, a CFI defense does
not remove the different gadget types at the same rate. A target of
an indirect call would be relatively likely to be a callback or virtual
function, and we cannot assume that this is independent of the
gadget types. In particular, it is plausible these would be simpler
on average than functions that are not indirect call targets. In fu-
ture work, we can improve Equation 2 by modeling the frequency
distribution of gadgets. Further in the updated formula the gadget
probabilities will be longer averaged as in the current version. Thus,
more accurate results can be obtained.
Different Attack Types. ESL provides a Python like API which
can be used to craft COOP-like attacks. In future work, by extending
our DSL-based ESL to implement new attacks, other attack types
can be specified. As such, iTOP’s API can make the implementation
of other types of attacks relatively easy. Thus, by implementing
other types of attacks (e.g., ROP), this would considerably enhance
iTOP’s target binary analysis of the assessed CFI policy.
9 RELATED WORK
Automatic Exploit Generation (AEG) [6] automatically searches
for a vulnerability in the target binary and generates an exploit.
Assuming no defenses are in-place, AEG [6] is an end-to-end attack
crafting tools which first discovers a vulnerability and then tries
to generate exploits, if possible, for both source code and binary
programs, respectively. In contrast to iTOP, AEG finds first the vul-
nerability and is not designed to operate under strong defenses.
Opposed to iTOP, AEG has no attack specification language. iTOP
is not dependent on the provided vulnerability type, while AEG
focuses only on stack overflows and format string vulnerabilities.
Revery [49] is a dynamic attack crafting tool that analyzes a
vulnerable program and collects runtime information on the crash-
ing path as for example taint attributes of variables. Revery is an
extension of AEG but goes beyond by focusing on other challenges.
In contrast to iTOP, Revery analyzes crashing paths and as such
a vulnerability has not be provided. Revery fails in certain cases
to generate an attack due to complicated defense mechanisms of
which the tool is not aware. Further, in some cases, Revery does not
generate exploits due to dynamic decisions that have to be made
during exploitation. In contrast to iTOP, Revery does not come with
an attack specification language.
Newton [48] is a runtime attack crafting tool whereas iTOP is a
static attack crafting tool that both provide an attack specification
language. In contrast to iTOP which focuses on COOP-like attacks,
Newton focus on other types of attacks as well. Further Newton,
iTOP uses a static specification for constructing the payload while
Newton uses an attack specification language which is used to inter-
act during runtime with the monitored program. Further, Newton
uses a more general black-box approach based on dynamic taint
analysis and is not limited to COOP attacks. In contrast, iTOP covers
both black-box (i.e., a CFI policy is not deployed) and white-box
(i.e., a CFI policy is deployed) during attack construction.
BOPC [24] is a framework for automatic static building of data-
only attacks which do not violate the control flow of the program.
BOPC can assess whether an attacker can perform arbitrary code
execution attacks within a binary which was previously hardened
with CFI and/or shadow stack defenses. In contrast to BOPC, iTOP
does not address data-only attacks as BOPC does, but rather control-
flow violating attacks. BOPC searches inside the legitimate CFG of
the program for machine code basic blocks to used for an attack, in
14
contrast iTOP searches inside and outside of the program CFG for
targets which may or may not be protected by a CFI policy which
then can be used as gadgets for constructing COOP-like attacks.
Other tools such as PSHAPE [15], Kepler [51], ropc [38], ROPGad-
get [42], Q [44], and work by Wollgast et al. [50] seek to automate
the full attack construction process. In contrast to iTOP, these tools
are limited, as these rely on finding hard-coded sequences of in-
structions to identify gadgets and can only build pre-determined
gadget chains.
10 CONCLUSION
We have presented iTOP, a framework for fully automated construc-
tion of control-flow hijacking attacks, which can bypass state-of-
the-art deployed CFI defenses and shadow stack defenses. iTOP
automates the analysis of the target binary, the identification of
useful gadgets and gadget dispatch mechanisms, and can build
payloads under consideration of state-of-the-art CFI policies. We
have evaluated iTOP by testing it on seven real-world programs,
successfully creating payloads ranging from spawning a shell to
loops and conditionals when using our attack generation primitives.
These payloads have spawned a shell (no CFI policy deployed) for
all evaluated binaries and demonstrated that many state-of-the-art
CFI policies are too permissive, allowing an attacker with in-depth
knowledge of the vulnerable program to construct attacks that
bypass these deployed state-of-the-art fine-grained CFI defenses.
ACKNOWLEDGMENTS
We are grateful to the anonymous reviewers, and our shepherd
Erik van der Kouwe, VU Amsterdam, Netherlands, for their help
in improving this work. We also would like to thank Chao Zhang,
Tsinghua University, P. R. China and Haohuang Wen, The Ohio
State University, USA, for providing insightful feedback on earlier
versions of this paper.
REFERENCES
[1] 2018. pyelftools. (2018). https://github.com/eliben/pyelftools.
[2] 2018. System – Execute a shell command in Linux man pages. (2018). https:
//linux.die.net/man/3/system.
[3] ANTLR. 2020. ANother Tool for Language Recognition. (2020). https://www.
antlr.org/.
bounty/.
[4] Apache. 2017. Apache Httpd. (2017). https://httpd.apache.org/.
[5] Apple. 2020. Apple Security Bounty. (2020). https://developer.apple.com/security-
[6] T. Avgerinos, S. K. Cha, A. Rebert, E. Schwartz, M. Woo, and D. Brumley. 2015.
Automatic exploit generation. In Communications of the ACM. ACM.
[7] D. Bounov, R. G. Kici, and S. Lerner. 2016. Protecting C++ Dynamic Dispatch
Through VTable Interleaving. In Proceedings of the Symposium on Network and
Distributed System Security (NDSS). ISOC.
[8] Capstone. 2019. Capstone Disassembly Framework. (2019). http://www.capstone-
engine.org/.
html.
[9] N. Carlini, A. Barresi, M. Payer, D. Wagner, and T. R. Gross. 2015. Control-Flow
Bending: On the Effectiveness of Control-Flow Integrity. In Proceedings of USENIX
Security Symposium (USENIX Security). USENIX.
[10] Clang. [n. d.]. Clang SafeStack. ([n. d.]). https://clang.llvm.org/docs/SafeStack.
[11] T. H. Y. Dang, P. Maniatis, and D. Wagner. 2015. The Performance Cost of Shadow
Stacks and Stack Canaries. In Proceedings of the Asia Conference on Computer and
Communications Security (AsiaCCS). ACM.
[12] M. Elsabagh, D. Fleck, and A. Stavrou. 2017. Strict Virtual Call Integrity Check-
ing for C ++ Binaries. In Proceedings of the Asia Conference on Computer and
Communications Security (AsiaCCS). ACM.
[13] Firefox. 2019. Firefox. (2019). https://www.mozilla.org/en-US/firefox.
[14] Firefox. 2019. LibTorrent. (2019). https://www.libtorrent.org/.
[34] P. Muntean, S. Wuerl, J. Grossklags, and C. Eckert. 2018. CastSan: Efficient Detec-
tion of Polymorphic C++ Object Type Confusions with LLVM. In Proceedings of
the European Symposium on Research in Computer Security (ESORICS). Springer.
[35] Nginx. 2017. Nginx web server. (2017). https://nginx.org/en/.
[36] B. Niu and G. Tan. 2014. Modular Control-Flow Integrity. In Proceedings of the
Symposium on Programming Language Design and Implementation (PLDI). ACM.
[37] NodeJS. 2017. Open-source, cross-platform JavaScript run-time environment.
(2017). https://nodejs.org/en/.
pakt/ropc.
[38] Pakt. 2013. ropc: A turing complete ROP compiler. (2013). https://github.com/
[39] A. Pawlowski, M. Contag, V. van der Veen, C. Ouwehand, T. Holz, H. Bos, E.
Athanasopoulos, and C. Giuffrida. 2017. MARX: Uncovering Class Hierarchies
in C++ Programs. In Proceedings of the Network and Distributed System Security
Symposium (NDSS). ISOC.
[40] Application Entry Point. 2021.
InfoSec Institure.
infosecinstitute.com/topic/discovering-entry-points/.
(2021). https://resources.
[41] Redis. 2017. Redis in-memory database. (2017). https://redis.io/.
[42] J. Salwan. 2011. ROPgadget - Gadgets Finder and Auto-roper. (2011). http://shell-
storm.org/project/ROPgadget/.
[43] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and T. Holz. 2015.
Counterfeit Object-oriented Programming: On the Difficulty of Preventing Code
Reuse Attacks in C++ Applications. In Proceedings of the Symposium on Security
and Privacy (S&P). IEEE.
[44] E. J. Schwartz, T. Avgerinos, and D. Brumley. 2011. Q: Exploit Hardening Made
Easy. In Proceedings of the Conference on Security (USENIX Security). USENIX.
[45] Y. Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and G. Vigna. 2015. Firmal-
ice - Automatic Detection of Authentication Bypass Vulnerabilities in Binary
Firmware. In Proceedings of the Symposium on Network and Distributed System
Security (NDSS). ISOC.
[46] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino, A. Dutcher, J. Grosen,
S. Feng, C. Hauser, C. Kruegel, and G. Vigna. 2016. SoK: (State of) The Art of
War: Offensive Techniques in Binary Analysis. In Proceedings of the Symposium
on Security and Privacy (S&P). IEEE.
[47] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, Ú. Erlingsson, L. Lozano, and
G. Pike. 2014. Enforcing Forward-Edge Control-Flow Integrity in GCC and LLVM.
In Proceedings of USENIX Security Symposium (USENIX Security). USENIX.
[48] V. van der. Veen, D. Andriesse, M. Stamatogiannakis, X. Chen, H. Bos, and C.
Giuffrida. 2017. The Dynamics of Innocent Flesh on the Bone: Code Reuse Ten
Years Later. In Proceedings of the Conference on Computer and Communications
Security (CCS). ACM.
[49] Y. Wang, C. Zhang, X. Xiang, Z. Zhao, W. Li, X. Gong, B. Liu, K. Chen, and W.
Zou. 2018. Revery: From Proof-of-Concept to Exploitable. In Proceedings of the
Conference on Computer and Communications Security (CCS). ACM.
[50] P. Wollgast, R. Gawlik, B. Garmany, B. Kollenda, and T. Holz. 2016. Automated
Multi-architectural Discovery of CFI-Resistant Code Gadgets. In Proceedings of
the European Symposium on Research in Computer Security (ESORICS). Springer.
[51] W. Wu, Y Chen, X Xing, and W. Zou. 2019. Kepler: Facilitating Control-flow
Hijacking Primitive Evaluation for Linux Kernel Vulnerabilities. In Proceedings
of USENIX Security Symposium (USENIX Security). USENIX.
[52] C. Zhang, C. Song, K. Chen Zhijie, Z. Chen, and D. Song. 2015. vTint: Protecting
Virtual Function Tables’ Integrity. In Proceedings of the Network and Distributed
System Security Symposium (NDSS). ISOC.
com/.
[15] A. Follner, A. Bartel, H. Peng, Y. C. Chang, K. Ispoglou, M. Payer, and E. Bod-
den. 2016. PSHAPE: Automatically Combining Gadgets for Arbitrary Method
Execution. In Proceedings of the International Workshop on Security and Trust
Management (STM). ACM.
[16] GCC. 2016. shadow stack proposal. (2016). https://gcc.gnu.org/ml/gcc/2016-
04/msg00083.html.
[17] E. Goektas, E. Athanasopoulos, H. Bos, and G. Portokalidis. 2014. Out Of Control:
Overcoming Control-Flow Integrity. In Proceedings of the Symposium on Security
and Privacy (S&P). IEEE.
[18] Google. 2017. Google Chrome. (2017). https://www.chromium.org/.
[19] Google. 2020. Google Application Security. (2020). https://www.google.ch/
about/appsecurity/reward-program/.
[20] Google. 2020. Google’s Project Zero . (2020). https://googleprojectzero.blogspot.
[21] B. Gras, K. Razavi, E. Bosman, B. Herbert, and C. Giuffrida. 2017. ASLR on
the Line: Practical Cache Attacks on the MMU. Proceedings of the Network and
Distributed System Security Symposium (NDSS) (2017).
[22] D. Gruss, C. Maurice, A. Fogh, M. Lipp, and S. Mangard. 2016. Prefetch Side-
Channel Attacks: Bypassing SMAP and Kernel ASLR. In Proceedings of the Con-
ference on Computer and Communications Security (CCS). ACM.
[23] I. Haller, E. Goktas, E. Athanasopoulos, G. Portokalidis, and H. Bos. 2015.
ShrinkWrap: VTable Protection Without Loose Ends. In Proceedings of the Annual
Computer Security Applications Conference (ACSAC). ACM.
[24] K. Ispoglou, B. AlBassam, T. Jaeger, and M. Payer. 2018. Block Oriented Pro-
gramming: Automating Data-Only Attacks. In Proceedings of the Conference on
Computer and Communications Security (CCS). ACM.
[25] J. Koschel, C. Giuffrida, H. Bos, and K. Razavi. 2020. TagBleed: Breaking KASLR
on the Isolated Kernel Address Space using Tagged TLBs. In Proceedings of the
European Symposium on Security and Privacy (Euro S&P). IEEE.
[26] Metasploit. 2019. Metasploit Framework. (2019). https://github.com/rapid7/
metasploit-framework.
[27] Microsoft. 2009.
https:
//docs.microsoft.com/en-us/previous-versions/commerce-server/ee823878(v=
cs.20)?redirectedfrom=MSDN.
The STRIDE Threat Model.
[28] Microsoft. 2020. Microsoft Bug Bounty Program. (2020). https://www.microsoft.
(2009).
com/en-us/msrc/bounty.
[29] Changes to Functionality in Microsoft Windows XP Service Pack 2. Microsoft.
2003. (2003). https://technet.microsoft.com/en-us/library/bb457151.aspx.
[30] L. d. Moura and N. Bjorner. 2008. Z3: An efficient SMT solver. In Proceedings
of the International Conference on Tools and Algorithms for the Construction and
Analysis of Systems (TACAS/ETAPS). Springer.
[31] P. Muntean, M. Fischer, G. Tan, Z. Lin, J. Grossklags, and C. Eckert. 2018. τ FI:
Type-Assisted Control Flow Integrity for x86-64 Binaries. In Proceedings of the
International Symposium on Research in Attacks, Intrusions, and Defenses (RAID).
Springer.
[32] P. Muntean, M. Neumayer, Z. Lin, G. Tan, J. Grossklags, and C. Eckert. 2019.
Analyzing Control Flow Integrity with LLVM-CFI . In Proceedings of the Annual
Computer Security Applications Conference (ACSAC). ACM.
[33] P. Muntean, M. Neumayer, Z. Lin, G. Tan, J. Grossklags, and C. Eckert. 2020. ρFEM:
Efficient Backward-edge Protection Using Reversed Forward-edge Mappings. In
Annual Computer Security Applications Conference (ACSAC). ACM.
15