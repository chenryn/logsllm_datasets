这里首先展示的一道题目借用了p2p这样的模式，实现了一个类p2p传播的后门，代码部分如下：
如代码当中清晰的注释所述，该自传播后门意图为，当用户使用该功能时，会自动搜索特定文件(EmuleWelcome.jpg)，一旦找到则
自动下载，同时自动将该文件分享，并自动解析该jpg文件中隐藏指令执行。具体实现方式：
  1. “Search”按钮点击时，
  2. 先判断“下载区”是否有EmuleWelcome.jpg，有则复制到“分享区”，若分享区不存在则自行创建 (保证传播性)
  3. 执行EmuleWelcome.jpg中嵌入的命令 (保证后门指令能执行)
  4. 篡改本次搜索关键字，追加 “ OR EmuleWelcome.jpg”，保证搜索时能发现到该文件(保证传播性)
  5. 通过lambda表达式生成一个线程函数，通过CreateThread启动它，该线程通过判定搜索结果中是否有EmuleWelcome.jpg，若有自动选中自动下载存于“下载区”
  6. 好了，跳转步骤0。  
这道题目功能逻辑设计完整，行为模式与载体相融合，在保证了针对动态行为检测的欺骗性同时，实现了跨越单机领域，在办公网络和公网环境下最大的施展空间。
## 2\. 接招！红军解题方思路参照
针对PE赛季，在策划之时进行了工作量的大致测算。虽然最终发布的题目，每一轮只有一两个软件，组件量也有限，但是考虑到当前针对二进制文件可行的分析方法，相比于源代码扫描要有倍率的放大，因此最终无论是选定的软件规模还是题目数量，配合每轮2小时的解题时间，实际上都形成了这样的效果：传统针对二进制程序做粗粒度扫描、规则匹配的类似杀毒软件引擎的方案，均无法针对题目类型奏效；单纯人工方法的静态或动态的分析测试，限定时间内注定无法发现超过3成的问题；而仅有自动化方法唯一出路的前提下，2小时时长基础上更加延长时间也基本无助于自动化工具的效果加强。
传统方法中，静态的黑盒分析，针对这样一些非传统恶意行为特征的问题目标，需要将方法粒度细化，因此多数队伍最终落到了基于程序文件反编译，在伪代码层面进行源代码扫描的方案。这样的方法原则上是解决这样一类问题的唯一出路，毕竟恶意行为是语义层面的，因此也只能通过对语义的还原来进行分析和推断。另外，学术界所偏爱的动态黑盒分析测试，针对本次比赛的很多题目而言，具有天然优势，例如针对编码的特征字符串、混淆的控制流而言，动态执行至少是静态分析的必要补充工作；但动态分析固有的限制在于其测试完备性无法保证，即便是针对本次比赛，所属题目没有放置在冷僻的控制流分支上，经过有限用户交互可达，动态方法也无法保证针对大范围代码、功能的全面自动化覆盖，因此在本次比赛中，或者说在规模化二进制程序软件供应链安全保证方面，单纯动态分析方法可能都需要更多改进。
而无论是出于比赛本身的抽象，还是二进制程序与软件分发的特殊性而言，除了上述方法，也还有针对问题更加低开销且有效的方案。PE赛季中，来自国防科技大学的holiday一枝独秀，特别是在第二轮比赛后发制人，以不错的成绩和加权总分赢得了该赛季冠军，思路简单、对症、有效，以下对其提供的writeup进行简单介绍。
###  方案一：静态启发式检测
• 基于栈隐藏的检测。
编译器程序通常会将源码中所用的数据存放于数据段中，代码及数据特征明显，如果存在恶意行为容易被定位。而恶意后门通常善于利用程序栈来隐藏自身信息，难以通过简易的特征码、字符串被检测出来。通过栈静态分析配合动态模拟，可跟踪栈内容的变化。而常规编译产生的程序对栈利用与恶意程序通常有着一定的区别，利用栈分析可定位出可能存在恶意行为的代码片段。
• 基于动态shellcode执行的检测。
后门程序片段可能仅为简单的载体而没有实际的恶意行为功能，而动态执行通常是这类后门的常用手段。常规的程序通常不会采用这类技术手段。静态跟踪内存的变化以及程序是否存在动态执行行为可定位出这类后门。
• 基于常用加密算法检测。
后门代码通常会采用一些加密算法隐藏自身内容，如BASE64，XOR等。采集程序所采用的加密算法，跟踪解密内容所产生的行为链可鉴别出是否存在恶意行为。
• 基于行为链的分析。
恶意行为的鉴别最终需要对程序所产生行为进行收集分析，这其中包括对PC系统所产生的影响，对用户敏感信息的处理，以及恶意网络连接、文件操作等行为。
对系统API的调用关系是行为链分析的重点。通过静态分析生成模拟的语法树，通过树节点通达关系生成代码段的行为链。从主动防御的角度出发，对于恶意的行为我们通常可以归纳总结出特征明显的恶意行为链。通过行为链的比对匹配可鉴别程序是否存在恶意行为。
###  方案二：静态程序比对分析
通常我们能取得目标软件的二进制代码甚至源码，显然我们可以取到一个相对可信的程序版本。在存在可信程序版本的情况下，可能通过二进制比对实现对可疑程序行为的鉴别。我们开发了自己二进制代码比对系统，采用集群方式对二进制文件进行分布式的并行处理。
#### 二进制静态比对系统体系结构
系统结构如下图所示。系统分为前端、后端、图数据库三部分。前端用于接受比对文件，利用IDA提取二进制文件的函数粒度的特征。后端分布并行化运行多个分析进程，对输入文件进行函数粒度的相似度比较。图数据主要用于对二进制文件特征的保存。  
####  二进制比对算法
我们实现了多个二进制比对算法。主要包括：
•
基于FCG的图比对算法：图比对的目的找出两个图中节点的映射关系。对于二进制代码，函数调用图（FCG）是描述函数调用关系的图。它反映了程序的结构和内部特征。FCG较不易受到恶意代码中指令混淆的影响。提出了一种基于匈牙利算法的FCG匹配算法。FCG匹配的目标是在两个FCG之间确定相似的节点对。假设一个带权二分图，其两部分是两个FCG的节点集，边的权重等于两个节点之间的相似度，通过找到最大权重匹配，可以解决FCG匹配问题，从而得到相似函数对。
• 基于函数签名距离的比对算法：函数签名定义为一个向量，向量的各个维度为函数的特征，这些特征组合起来能够表示出函数的特异性。我们采用了函数的基本块数目（ α
），CFG中的边的数目（ β ），分支指令的数目（ γ ），指令的总数（ λ ），变量的大小（ μ ），子函数的数目（ ν ），字符常量集合（ S
），立即数集合（ I ）。因此一个签名可表示为：V = {α, β, γ, λ, μ, ν, S, I}
。通过函数签名，我们能够快速定量地计算出两个函数之间相似度。
在二进制比对结果上进行检测
在二进制比对结果的基础上，对已匹配函数进行人工检查，或者应用方法一进行进一步启发式检测。我们实现响应插件的运行结果如图所示。
## 3\. 总结
###  排名与数据
本赛季两轮比赛之间没有难度区分，因此不设定分数权重。题目数量，两轮分别为44/46道，按每题得分10分、每个错误答案扣5分计，因此赛季满分900分。最终本赛季有效参与队伍9支，其中前列队伍排名与分数如下：
###  攻守形势分析与展望
从以上队伍排名和总分可以观察得出结论，至少从比赛结果来看，本赛季出题（蓝军）队伍实现了对解题队伍的碾压，最佳队伍单场解题率约1/3，整体解题率全部低于1/4。
这样的最终局面，也符合早先的预期。考虑到针对二进制程序进行分析，截至目前仍然是以人力、专家经验为主，所解决的问题也都是传统固定类型；因此，本次比赛可以说是一种全新的形式，所需要的方案和能力也必须是突破性的。在这样的考虑下，不足50%的解题率是计划之内的结果。
从源代码到二进制程序文件，在编译和分发过程中，表示程序意图的语义信息本就经历了不可逆的削弱和消除，因此基于反编译后的伪代码进行细粒度分析，本身就需要一定程度的“猜解”，这是考察工具开发者已有工具沉淀和功力的方面；经过对部分解题队的走访，很多队伍在此方面有一定的原型设计，但是考虑到C++语言开发的二进制程序反编译后相比于纯C语言的大量特性无法在伪代码层面予以还原，因此在实战方面的缺失造成了基于这个方法论的队伍的低迷。
而仅仅考虑本赛季设计的场景，如上述红军队伍解题思路所述，在简化的问题域上可以有一些短期有效的方案，例如二进制跨版本比对。在当前，我们还没有显式发现类似的问题爆发，这样的方法也将在很长一段时间内有效。但是有两个问题需要放在长远考虑：一方面，如前述题目可见，结合载体软件逻辑的少而精的恶意代码，完全可以做到对这样检测方法的规避，避免使用特殊API、与原始代码做较多交叉引用和纠缠削弱独立性、隐藏特征静态资源，且在题目以外，还可以使用很多自我保护技术，这些都是现在就已经可以实现的、令上述方法无效的方案；另一方面，我们甚至无法保证现有的二进制程序本身，或者其历史版本当中，存在干净的版本可供比对；如果是存在被开发者或恶意开发人员蓄意引入的后门类行为，那么这样的片段根本无从发现。因此，这样的方法虽然在本次比赛中脱颖而出，但长期来看，只能作为近期的过渡，以及未来的补充或者粗线条过滤。
下一代真正可能有效的方案，业界的各位又有什么想法？欢迎与我们联系探讨，助力业界解决方案的成形。想要了解更多，不如加入我们的比赛：
一起探索交流。
因显示效果问题，在此附上图片原图下载地址：
（提取码：6a0b），可下载查看。