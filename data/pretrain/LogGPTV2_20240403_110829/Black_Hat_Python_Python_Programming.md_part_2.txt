the source code examples from this book are available at http://nostarch.com/
blackhatpython/.
Here we go!
xviii Preface
acknowleDgments
I would like to thank my family—my beautiful wife, Clare, and my five
children, Emily, Carter, Cohen, Brady, and Mason—for all of the encourage-
ment and tolerance while I spent a year and a half of my life writing this
book. My brothers, sister, Mom, Dad, and Paulette have also given me a lot
of motivation to keep pushing through no matter what. I love you all.
To all my folks at Immunity (I would list each of you here if I had the
room): thanks for tolerating me on a day-to-day basis. You are truly an
amazing crew to work with. To the team at No Starch—Tyler, Bill, Serena,
and Leigh—thanks so much for all of the hard work you put into this
book and the rest in your collection. We all appreciate it.
I would also like to thank my technical reviewers, Dan Frisch and Cliff
Janzen. These guys typed out and critiqued every single line of code, wrote
supporting code, made edits, and provided absolutely amazing support
throughout the whole process. Anyone who is writing an infosec book
should really get these guys on board; they were amazing and then some.
For the rest of you ruffians that share drinks, laughs and GChats:
thanks for letting me piss and moan to you about writing this book.
1
se t ting U P y oUr
Py tHon e nvironment
This is the least fun—but nevertheless critical—part of
the book, where we walk through setting up an environ-
ment in which to write and test Python. We are going
to do a crash course in setting up a Kali Linux virtual
machine (VM) and installing a nice IDE so that you
have everything you need to develop code. By the end
of this chapter, you should be ready to tackle the exer-
cises and code examples in the remainder of the book.
Before you get started, go ahead and download and install VMWare
Player.1 I also recommend that you have some Windows VMs at the ready as
well, including Windows XP and Windows 7, preferably 32-bit in both cases.
1. You can download VMWare Player from http://www.vmware.com/.
installing kali linux
Kali is the successor to the BackTrack Linux distribution, designed by
Offensive Security from the ground up as a penetration testing operating
system. It comes with a number of tools preinstalled and is based on Debian
Linux, so you’ll also be able to install a wide variety of additional tools and
libraries beyond what’s on the OS to start.
First, grab a Kali VM image from the following URL: http://images
.offensive-security.com/kali-linux-1.0.9-vm-i486.7z.2 Download and decompress
the image, and then double-click it to make VMWare Player fire it up. The
default username is root and the password is toor. This should get you into
the full Kali desktop environment as shown in Figure 1-1.
Figure 1-1: The Kali Linux desktop
The first thing we are going to do is ensure that the correct version of
Python is installed. This book will use Python 2.7 throughout. In the shell
(ApplicationsAccessoriesTerminal), execute the following:
root@kali:~# python --version
Python 2.7.3
root@kali:~#
2. For a “clickable” list of the links in this chapter, visit http://nostarch.com/blackhatpython/.
2 Chapter 1
If you downloaded the exact image that I recommended above,
Python 2.7 will be automatically installed. Please note that using a dif-
ferent version of Python might break some of the code examples in this
book. You have been warned.
Now let’s add some useful pieces of Python package management in the
form of easy_install and pip. These are much like the apt package manager
because they allow you to directly install Python libraries, without having
to manually download, unpack, and install them. Let’s install both of these
package managers by issuing the following commands:
root@kali:~#: apt-get install python-setuptools python-pip
When the packages are installed, we can do a quick test and install the
module that we’ll use in Chapter 7 to build a GitHub-based trojan. Enter
the following into your terminal:
root@kali:~#: pip install github3.py
You should see output in your terminal indicating that the library is
being downloaded and installed.
Then drop into a Python shell and validate that it was installed correctly:
root@kali:~#: python
Python 2.7.3 (default, Mar 14 2014, 11:57:14)
[GCC 4.7.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import github3
>>> exit()
If your results are not identical to these, then there is a “misconfigura-
tion” in your Python environment and you have brought great shame to our
Python dojo! In this case, make sure that you followed all the steps above
and that you have the correct version of Kali.
Keep in mind that for most examples throughout this book, you can
develop your code in a variety of environments, including Mac, Linux, and
Windows. There are some chapters that are Windows-specific, and I’ll make
sure to let you know at the beginning of the chapter.
Now that we have our hacking virtual machine set up, let’s install a
Python IDE for development.
wingide
While I typically don’t advocate commercial software products, WingIDE
is the best IDE that I’ve used in the past seven years at Immunity. WingIDE
provides all the basic IDE functionality like auto-completion and explana-
tion of function parameters, but its debugging capabilities are what set it
Setting Up Your Python Environment 3
apart from other IDEs. I will give you a quick rundown of the commercial
version of WingIDE, but of course you should choose whichever version is
best for you.3
You can grab WingIDE from http://www.wingware.com/, and I recom-
mend that you install the trial so that you can experience firsthand some
of the features available in the commercial version.
You can do your development on any platform you wish, but it might be
best to install WingIDE on your Kali VM at least to get started. If you’ve
followed along with my instructions so far, make sure that you download
the 32-bit .deb package for WingIDE, and save it to your user directory.
Then drop into a terminal and run the following:
root@kali:~# dpkg -i wingide5_5.0.9-1_i386.deb
This should install WingIDE as planned. If you get any installation
errors, there might be unmet dependencies. In this case, simply run:
root@kali:~# apt-get -f install
This should fix any missing dependencies and install WingIDE. To
verify that you’ve installed it properly, make sure you can access it as shown
in Figure 1-2.
Figure 1-2: Accessing WingIDE from the Kali desktop
3. For a comparison of features among versions, visit https://wingware.com/wingide/features/.
4 Chapter 1
Fire up WingIDE and open a new, blank Python file. Then follow along
as I give you a quick rundown of some useful features. For starters, your
screen should look like Figure 1-3, with your main code editing area in the
top left and a set of tabs on the bottom.
Figure 1-3: Main WingIDE window layout
Let’s write some simple code to illustrate some of the useful functions
of WingIDE, including the Debug Probe and Stack Data tabs. Punch the
following code into the editor:
def sum(number_one,number_two):
number_one_int = convert_integer(number_one)
number_two_int = convert_integer(number_two)
result = number_one_int + number_two_int
return result
def convert_integer(number_string):
converted_integer = int(number_string)
return converted_integer
answer = sum("1","2")
Setting Up Your Python Environment 5
This is a very contrived example, but it is an excellent demonstration
of how to make your life easy with WingIDE. Save it with any filename you
want, click the Debug menu item, and select the Select Current as Main
Debug File option, as shown in Figure 1-4.
Figure 1-4: Setting the current Python script for debugging
Now set a breakpoint on the line of code that says:
return converted_integer
You can do this by clicking in the left margin or by hitting the F9 key.
You should see a little red dot appear in the margin. Now run the script by
pressing F5, and execution should halt at your breakpoint. Click the Stack
Data tab and you should see a screen like the one in Figure 1-5.
The Stack Data tab is going to show us some useful information such
as the state of any local and global variables at the moment that our break-
point was hit. This allows you to debug more advanced code where you
need to inspect variables during execution to track down bugs. If you click
the drop-down bar, you can also see the current call stack, which tells you
which function called the function you are currently inside. Have a look at
Figure 1-6 to see the stack trace.
6 Chapter 1
Figure 1-5: Viewing stack data after a breakpoint hit
Figure 1-6: Viewing the current stack trace
Setting Up Your Python Environment 7
We can see that convert_integer was called from the sum function on
line 3 of our Python script. This becomes very useful if you have recursive
function calls or a function that is called from many potential places. Using
the Stack Data tab will come in very handy in your Python developing career!
The next major feature is the Debug Probe tab. This tab enables you
to drop into a Python shell that is executing within the current context
of the exact moment your breakpoint was hit. This lets you inspect and
modify variables, as well as write little snippets of test code to try out
new ideas or to troubleshoot. Figure 1-7 demonstrates how to inspect the
c onverted_integer variable and change its value.
Figure 1-7: Using Debug Probe to inspect and modify local variables
After you make some modifications, you can resume execution of the
script by pressing F5.
Even though this is a very simple example, it demonstrates some
of the most useful features of WingIDE for developing and debugging
Python scripts.4
That’s all we need in order to begin developing code for the rest of
this book. Don’t forget about making virtual machines ready as target
machines for the Windows-specific chapters, but of course using native
hardware should not present any issues.
Now let’s get into some actual fun!
4. If you already use an IDE that has comparable features to WingIDE, please send me an
email or a tweet because I would love to hear about it!
8 Chapter 1
2
tHe n e t work: Basics
The network is and always will be the sexiest arena
for a hacker. An attacker can do almost anything with
simple network access, such as scan for hosts, inject
packets, sniff data, remotely exploit hosts, and much
more. But if you are an attacker who has worked your
way into the deepest depths of an enterprise target,
you may find yourself in a bit of a conundrum: you have no tools to execute
network attacks. No netcat. No Wireshark. No compiler and no means to
install one. However, you might be surprised to find that in many cases,
you’ll find a Python install, and so that is where we will begin.
This chapter will give you some basics on Python networking using the
socket1 module. Along the way, we’ll build clients, servers, and a TCP proxy;
and then turn them into our very own netcat, complete with command shell.
1. The full socket documentation can be found here: http://docs.python.org/2/library/socket.html.
This chapter is the foundation for subsequent chapters in which we will
build a host discovery tool, implement cross-platform sniffers, and create a
remote trojan framework. Let’s get started.
Python networking in a Paragraph
Programmers have a number of third-party tools to create networked
servers and clients in Python, but the core module for all of those tools is
socket. This module exposes all of the necessary pieces to quickly write TCP
and UDP clients and servers, use raw sockets, and so forth. For the purposes
of breaking in or maintaining access to target machines, this module is all
you really need. Let’s start by creating some simple clients and servers, the
two most common quick network scripts you’ll write.
tcP client
There have been countless times during penetration tests that I’ve needed
to whip up a TCP client to test for services, send garbage data, fuzz, or
any number of other tasks. If you are working within the confines of large
enterprise environments, you won’t have the luxury of networking tools or
compilers, and sometimes you’ll even be missing the absolute basics like the
ability to copy/paste or an Internet connection. This is where being able to
quickly create a TCP client comes in extremely handy. But enough jabber-
ing—let’s get coding. Here is a simple TCP client.
import socket
target_host = "www.google.com"
target_port = 80
# create a socket object
u client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# connect the client
v client.connect((target_host,target_port))
# send some data
w client.send("GET / HTTP/1.1\r\nHost: google.com\r\n\r\n")
# receive some data
x response = client.recv(4096)
print response
We first create a socket object with the AF_INET and SOCK_STREAM param-
eters u. The AF_INET parameter is saying we are going to use a standard
IPv4 address or hostname, and SOCK_STREAM indicates that this will be a TCP
10 Chapter 2
client. We then connect the client to the server v and send it some data w.
The last step is to receive some data back and print out the response x.
This is the simplest form of a TCP client, but the one you will write most
often.
In the above code snippet, we are making some serious assumptions
about sockets that you definitely want to be aware of. The first assump-
tion is that our connection will always succeed, and the second is that the
server is always expecting us to send data first (as opposed to servers that
expect to send data to you first and await your response). Our third assump-
tion is that the server will always send us data back in a timely fashion. We
make these assumptions largely for simplicity’s sake. While programmers
have varied opinions about how to deal with blocking sockets, exception-
handling in sockets, and the like, it’s quite rare for pentesters to build these
niceties into the quick-and-dirty tools for recon or exploitation work, so
we’ll omit them in this chapter.
UdP client
A Python UDP client is not much different than a TCP client; we need to
make only two small changes to get it to send packets in UDP form.
import socket
target_host = "127.0.0.1"
target_port = 80
# create a socket object
u client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# send some data
v client.sendto("AAABBBCCC",(target_host,target_port))
# receive some data
w data, addr = client.recvfrom(4096)
print data
As you can see, we change the socket type to SOCK_DGRAM u when creat-
ing the socket object. The next step is to simply call sendto() v, passing in
the data and the server you want to send the data to. Because UDP is a con-
nectionless protocol, there is no call to connect() beforehand. The last step
is to call recvfrom() w to receive UDP data back. You will also notice that it
returns both the data and the details of the remote host and port.
Again, we’re not looking to be superior network programmers; we want
to be quick, easy, and reliable enough to handle our day-to-day hacking
tasks. Let’s move on to creating some simple servers.
The Network: Basics 11
tcP server
Creating TCP servers in Python is just as easy as creating a client. You might
want to use your own TCP server when writing command shells or craft-
ing a proxy (both of which we’ll do later). Let’s start by creating a standard
multi-threaded TCP server. Crank out the code below:
import socket
import threading
bind_ip = "0.0.0.0"
bind_port = 9999
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
u server.bind((bind_ip,bind_port))
v server.listen(5)
print "[*] Listening on %s:%d" % (bind_ip,bind_port)
# this is our client-handling thread
w def handle_client(client_socket):
# print out what the client sends
request = client_socket.recv(1024)
print "[*] Received: %s" % request
# send back a packet
client_socket.send("ACK!")
client_socket.close()
while True:
x client,addr = server.accept()
print "[*] Accepted connection from: %s:%d" % (addr[0],addr[1])
# spin up our client thread to handle incoming data
client_handler = threading.Thread(target=handle_client,args=(client,))
y client_handler.start()
To start off, we pass in the IP address and port we want the server to
listen on u. Next we tell the server to start listening v with a maximum
backlog of connections set to 5. We then put the server into its main loop,
where it is waiting for an incoming connection. When a client connects x,
we receive the client socket into the client variable, and the remote connec-
tion details into the addr variable. We then create a new thread object that
12 Chapter 2
points to our handle_client function, and we pass it the client socket object
as an argument. We then start the thread to handle the client connection y,
and our main server loop is ready to handle another incoming connection.
The handle_client w function performs the recv() and then sends a simple
message back to the client.
If you use the TCP client that we built earlier, you can send some test
packets to the server and you should see output like the following:
[*] Listening on 0.0.0.0:9999
[*] Accepted connection from: 127.0.0.1:62512
[*] Received: ABCDEF