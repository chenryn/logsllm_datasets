图10-16处理异常时的指令跳跃
LO_CONST
POP BLOCI
PRINT_ITE
OAL HAHE
POP_TOR
pOPtop
COIPAPE OP
ODNAHE
LTOP
10.4
IE
Python源码剖析
Python虚拟机中的异常控制流
1(None)
2（to8）
1（e)
14（t046）
异常匹配
深度探索动态语言核心技术
211
---
## Page 242
Python源码剖析
212
是否为异常设置了except代码块和finally代码块。Pyhon虚拟机处理异常的过程就是
示Python虚拟机当前是否发生了异常，而pyTryBlock对象则指示Python虚拟机程序员
态及PyFrameObject对象中_blockstack里存放的PyTryBlock对象了。变量why将指
怎样的呢，有兴趣的读者可以自己分析一下，其实与这里所分析的结果并无二致。
的字节码指令了。
应的pyTryBlock对象弹出，然后Python虚拟机的流程就进入了与finally表达式对应
置为WHY_RERAISE了
[POP_BLOCK]
使命。从END_FINALLY指令的实现代码可以清晰地看到这一点：
的动作，寻找真正能处理异常的代码。所以这两条指令就是完成这个“重返异常状态”的
置why的状态，让Pyhon虚拟机的内部状态重新进入“异常发生状态号，并开始栈帧展开
然，这时已经取出来的异常信息不能扔掉，而要重新放回到线程状态对象中，然后重新设
匹配，就是说虽然有excepE表达式，但是实际上并没有处理当前异常的代码。那么很显
并将其分别压入运行时栈中。当异常匹配时，它们都会从栈中取出来处理掉：如果异常不
Python虚拟机从当前线程的状态对象中将当前的异常信息取了出来，分别为tb、val、exc，
竞完成怎样的工作呢，我们不妨分析一下。前面已经提到，在进入except表达式之前，
常匹配时多执行两条字节码指令代码“46POPTOP，47ENDEINALLY”。这两条指令究
如果一段代码只有inally代码块而没有except代码块，Pyhon虚拟机的行为又是
[END_FINALLY]
好了，总结一下，Python的异常机制的实现中，最重要的就是why所表示的虚拟机状
这里将当前PyFrameobject的_blockstack中还剩下的那个与sETUP_FINALLY对
不管异常是否匹配，最终处理异常的两条岔路都会在“48POP_BLOCK”会合：
确实，Python虚拟机通过PyErr_Restore重新设置了异常信息，并把why的状态设
我们注意到，如果忽略“printe”所对应的字节码指令，
第10章Python虚拟机中的控制流
一深度探索动态语言核心技术
PyTryBlock *b=PyFrame_BlockPop(f);
breaki
PyErr_Restore(v,
(PyExceptionClass_Check(v)
whiy
Py_DECREF(V);
POP();
POP
WHY_RERAISE:
>b->b_level)H
Pystring_eheck(v))(
，当异常不匹配时，会比异
---
## Page 243
的详细的流程：
why和pyTryBlock的共同作用下完成的。在图10-17中给出了Python中实现异常机制
RAISE_VARARGS抛出异常
堆栈展开
执行inally块中代码
发现PyTryblock？
跳转到finally块
重回异常状态
图10-17
从线程状态对象取出异常信息
JUMPTO到except代码块
将异常信息入栈
Python中异常机制的流程图
异常匹配？
人
对应SETUPEXCEPT
10.4
执行except块中代码
Python源码剖析
Python虚拟机中的异常控制流
在当前PyFrameObjct中维续执行
执行inally块中代码
跳转到finally块
深度探索动态语言核心技术
Z
213
---
## Page 245
11.1
object对象链，这条对象链就是对x86平台上运行时栈的模拟。
对象。随着函数调用链的增长，这些pyFrameObject对象之间也会连接成一条pyFrame
本章我们也将看到，Python的虚拟机在执行函数调用时会动态地创建新的pyFrameObject
行时栈中创建新的栈帧，用于函数的执行。在Python中这个过程也同样存在。
看过在x86平台上函数调用时的情形，在那里我们看到，当函数调用发生时，系统会在运
正是因为有了函数机制，功能分解、代码复用这些目标才能在程序中实现。之前，我们曾
数这种抽象机制是通过一个Python对象一
一系列动作。
typedef
[funcobject.h]
PyFunctionObject对象
本章将研究在Python中对函数的实现，以及在函数调用的过程中，Python虚拟机的
我们已经知道，在Python中，PyFrameobject对象就是对一个栈帧的模拟，所以在
我们说过，在Pyhon中，任何东西都是一个对象，函数也不例外。在Pyhon中，函
函数，作为对动作过程的抽象，是任何一门现代编程语言都具有的基本的编程元素。
PyQbjectfunc_weakreflist;
Pyobiect
Pyobject
Pyobject
Pyobject
PyObjeat
Pyobjeot_HEAD
Pyobfect
Pyoblect
struct
*func_aict
*funcclosure;
*func_defaults
*func_doe;
*func_globals;
*func_code;
Python虚拟机中的函数机制
//欧认参数（tuple或NULL）
//函数运行时的global名字空间
//晶数的文档（PyShringobject）
1/对应函数编译后的PyCodeObject对象
PyFunctionobject-
Python源码剖析
一深度探索动态语言核心技术
属性,（PyStringobject）
来实现的。
第
CHAPTER
11章
---
## Page 246
Python源码剖析
216
对象之间的关系。
关联到这个PyCodeobject对象。图11-1展示了这种pyFunctionobject与pyCodeobject
创建多个ryFunctionObject对象，每一个PyFunctionobject对象的func_code域都会
PyFunctionobject对象却可能有很多个，比如一个函数多次调用，则Python会在运行时
行时才能确定，所以这部分必须在运行时动态创建，无法存储在PyCodeobject中。
是函数在执行时关联的global作用域。globa1作用域中的符号和值的对应关系必须在运
中还包含了一些函数在执行时必需的动态信息，即上下文信息，比如funcglobals，就
一定会指向与函数代码对应的PyCodeobject对象。除此之外，PyFunctionObject对象
当然会包括这个函数的静态信息，这些信息存储在func_code中，实际上，Func_code
产生的，更准确地说，是在执行一个deE语句的时候创建的。在PyFunctionobject中，
得到的，因此PyCodeObject是编译时的结果。
以及它们之间的联系就是一种静态的信息，这些信息会分别存储在PyCodeobject的常量
以从源代码中看到的信息。比如CodeBlock中有a=1这样的表达式，那么符号a和值1，
PyCodeobject对象中包含了这个CodeBlock的一些静态的信息，所谓静态的信息是指可
对源代码经过编译后，对一个CodeBlock会产生一个且只有一个PyCodeobject，这个
两个对象的区别非常重要。PyCodeObject对象是对一段Python源代码的静态表示。Python
在本章以后的叙述中，我们将逐渐介绍重要的域，而对有些不重要的域，则会略过不谈。
PyFunctionobject:
而pyFunctionobject则不同，PyFunctionobject对象是Python代码在运行时动态
在Python中，有两个对象都和函数有关，PyCodeobject和PyFunctionObject，这
第11章Python虚拟机中的函数机制
对于一段Python代码，其对应的PyCodeobject对象只有一个，而代码所对应的
在eyFunctionobject对象中，并非每一个域都对我们理解函数机制有重要的意义
Pyobject*func_module;
一深度探索动态语言核心技术
图11-1PyCodeObject对象与PyFunctionObject对象的关系
PyFunctionObject
func_code
1/函数的
PyCodeObject
module
，可以是任何对象
---
## Page 247
11.2.1
11.2无参函数调用
如图11-2和图11-3所示：
另一个对应函数。这两个PyCodeobject对象中的常量表co_const和符号表co_names
func_O.py经过编译后，产生的两个PyCodeobject对象中，
在本章中，我们所考察的代码经过编译后都会产生至少两个pycodeobject对象。源文件
func_0.py源代码及经过编译后的字节码序列。
制有一个整体框架层面的了解。我们剖析的对象是如下所示的func_O.py，下面列出了
细节，而将关注的焦点放在函数调用的整个流程框架上，以求对Pyton中的函数调用机
函数调用形式。从无参函数入手，我们可以在开始时不去考虑复杂的参数传递机制这样的
E（）
def
[func_O.py]
LOAD_CONST
STORELNAME
MAKE_FUNCTION O
以前我们考察的代码在经过Python编译后，都只会产生一个PyCodeobject对象，而
RETURN VALUE
LOAD_CONST
LOAD_NAMEO(E）
POP_TOP
OALD
print
我们对Pyhon中函数的剖析从无参函数的调用开始，因为无参函数调用是最简单的
）：
函数对象的创建
RETURN_VALUE
PRINT_NEWLINE
PRINT_ITEM
FUNCTIONO
(auONT
图11-2
0(None)
(codeobjectF）
("Function")
func_0.py对应的PyCodeObject对象
Coonsts>
Python源码剖析
11.2无参函数调用
一个对应整个func_0.py，而
一深度探索动态语言核心技术
217
---
## Page 248
Python源码剖析
218
必须在func_O.py对应的PyCodeobject对象中，因为我们说过，在Python中，函数也是
这个函数时，却在物理上将它们分离开了。其实，第1行代码所对应的字节码指令序列也
实是这样，第1行代码虽然和第2行代码确实在逻辑上是一个整体，但是在Pyon实现
的声明与函数的实现是分离的，甚至是分离在了不同的PyCodeObject对象中。没错，确
是它们分别构成了函数的声明和函数的实现。但是在我们上一段的叙述中，看上去，函数
理来看，fun_0.py中第1行Python代码和第2行Python代码应该是一个完整的整体，正
点需要注意。
只是在我们显示时，只能平面地显示字节码指令序列，不能显示出它们的层次结构。这一
码指令，print语句对应的字节码指令序列是在与函数对应的PyCodeobject对象中。
的pyCodeobject对象中，字节码指令序列中根本就没有print“bunction”对应的字节
令，即“9LOAD_NAMEo”。这是因为实际上在func_O.py编译后得到的与func_O.py对应
“Function”对应的字节码指令，而是会执行函数调用语句主（）所对应的第一条字节码指
的，但是实际情况并非如此。
节码执行机制不同。虽然在我们所列出的代码文件中，defF）的最后一条指令“6
了这两个PyCodeObject对象之间的联系：
象，也正是图11-3所示的那个PyCodeobject对象。在图11-4中，我们在IDLE中观察到
细心的读者可能已经注意到了，在上一段的描述中，隐藏着一个惊天的秘密。按照常
Python虚拟机在执行完了def f（对应的字节码指令之后，并不会执行print
当Python虚拟机执行func_O.py编译后的字节码指令序列时，与我们之前所考察的字
注意在图11-2的consts中的那个codeobject就是与函数主对应的PyCodeobject对
第11章Python虚拟机中的函数机制
>>co.co_consts[0].co_name
ctype
ktype
深度探索动态语言核心技术
CO
图11-4两个PyCodeObject对象间的关系
图11-3函数f对应的PyCodeObject对象
une_o.py
exec
---
## Page 249
代码清单11-1
数在运行时的global名字空间（见代码清单11-1）。
当前PyFrameObject对象中维护的global名字空间_globals 对象为参数，通过
MAKE_FUNCTION时，首先就是将这个PyCodeObject对象弹出运行时栈，然后以该对象和
看到，这条指令将函数F对应的Pycodeobject对象压入到了运行时栈中。所以，在执行
对象：在这个过程中，MAKE_FUNCTTON指令是一个关键：
[function.c]
的这种分离现象。
声明语句：而从虚拟机的角度看，它其实是函数对象的创建语句。图11-5展现了函数机制
Pyobject*
[MAKE FUNCTION]
个函数对象的创建工作正是在def(）这条代码处完成的。从语法上讲，def（）是函数
节码指令序列，那么，在能调用一个函数之前，Pyhon必须首先创建这个函数对象。而这
一个对象。在与func_O.py 对应的PyCodeobject对象中，包含着函数调用语句±（）的字
static Pyobjeot
7/[1]：申请PyFunctionObject对象所需的内存空间
在MAKE_FUNCTION之前，Python虚拟机会执行LOAD_CONSTO。对照图11-2，我们会
if
EyFumct-lonobject
Python虚拟机在执行aef语句时，会动态地创建一个函数，即一个PyFunctionobject
op->func_name=((RyCodeobject *)code)-xco_name:
//设置函数名
op->func_globals=globals;
//[2]：初始化PyFunctiotObject对象中的各个域
top
/7设置global名字空间
PyFunetion_New(Pyobject*code)
break;