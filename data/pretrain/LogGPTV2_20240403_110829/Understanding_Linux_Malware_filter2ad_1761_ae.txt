Path
/sys/devices/system/cpu/online
/sys/devices/system/node/node0/meminfo
/sys/module/x tables/initstate
/sys/module/ip tables/initstate
/sys/class/dmi/id/sys vendor
/sys/class/dmi/id/product name
/sys/class/net/tx queue len
/sys/ﬁrmware/eﬁ/systab
/sys/devices/pci0000:00/
/sys/bus/usb/devices/
Samples
Percentage
338
26
22
22
18
18
9
3
3
2
4.34%
0.33%
0.28%
0.28%
0.23%
0.23%
0.12%
0.04%
0.04%
0.03%
ELF PROGRAMS SHOWING EVASIVE FEATURES
TABLE XIII
Type of evasion
Sandbox detection
Processes enumeration *
Anti-debugging
Anti-execution
Stalling code
Samples
Percentage
19
259
63
3
0
0.24%
3.32%
0.81%
0.04%
-
* Not used for evasion but candidate behavior
FILE SYSTEM PATHS LEADING TO SANDBOX DETECTION
TABLE XIV
TOP TEN ACCESSES ON /E T C/ BY MALICIOUS
TABLE XII
SAMPLES
Path
/etc/rc.d/rc.local
/etc/rc.conf
/etc/resolv.conf
/etc/nsswitch.conf
/etc/hosts
/etc/passwd
/etc/host.conf
/etc/rc.local
/etc/localtime
/etc/cron.deny
Samples
Percentage
1393
1236
641
453
423
244
201
170
165
101
17.88%
15.86%
8.23%
5.81%
5.43%
3.13%
2.58%
2.18%
2.12%
1.30%
by a C&C server. In this section we look at which portions of
the ﬁle system are inspected by malware and discuss security-
relevant paths analysts should monitor when inspecting new
malware strains.
Proc and Sysfs File Systems. The proc and sysfs virtual
ﬁle systems contain, respectively, runtime system informa-
tion on processes, system and hardware conﬁgurations, and
information on the kernel subsystems, hardware devices, and
kernel drivers. We divide the type of information collected
by malware samples in three macro categories: system con-
ﬁguration, processes information, and network conﬁguration.
The network category is the most common in our dataset with
more than 3000 samples, as shown in Table X, which accessed
/proc/net/route (system routing table) to get the list
of active network interfaces with their relative conﬁguration.
Additional information is extracted from /proc/net/tcp
(active TCP sockets) and /proc/net/dev (sent and re-
ceived packets). Moreover, 111 samples in our dataset read
/proc/net/arp to retrieve the system ARP table. For the
sysfs counterpart, reported in Table XI, we found accesses
to /sys/class/net/ to get the transmission queue length,
a relevant information for DDoS attacks.
The system conﬁguration category is the second most com-
mon, with hundreds of samples that extracted the amount of
installed memory, the number of available CPU cores, and
other CPU characteristics. The ﬁles used for sandbox detection
and evasion also fall into this category (see Subsection V-H)
as well as the lists of USB and PCI connected devices.
This category also includes accesses to /proc/cmdline to
Path
/sys/class/dmi/id/product name
/sys/class/dmi/id/sys vendor
/proc/cpuinfo
/proc/sysinfo
/proc/scsi/scsi
/proc/vz and /proc/bc
/proc/xen/capabilities
/proc//mountinfo
CPU model/hypervisor ﬂag
QEMU
KVM
Detected Environments
VMware/VirtualBox
VMware/VirtualBox
OpenVZ container
XEN hypervisor
chroot jail
#
18
18
1
1
1
1
1
1
retrieve the name of the running kernel image.
Another common type of information gathering focuses
on processes enumeration. This is used to prevent multiple
executions of the same malware (e.g., by the Mirai family),
or to identify other relevant programs running on the target
machine. As reported in Table IX, we found 131 samples
executing the shell command ps, used as a fast interface to
get the list of running processes. For example, 67 samples of
the BitcoinMiner family invoke ps and then try to kill other
crypto-miner processes that may interfere with their malicious
activity.
Conﬁguration Files. System conﬁguration ﬁles are contained
in the /etc/ folder. As reported in Table XII, conﬁguration
ﬁles required to achieve persistence are the ones accessed more
often. Network-related conﬁguration ﬁles also appear to be
popular, with /etc/resolv.conf (the DNS resolver) or
/etc/hosts (the mapping between hosts and IP addresses).
Among the top entries we also ﬁnd /etc/passwd (list of
registered accounts). For instance, Flooder samples use it to
check for the presence of a backdoor account on the system.
If not found,
they add a new user by directly writing to
/etc/passwd and /etc/shadow.
H. Evasion
The purpose of evasion is to hide the malicious behavior and
remain undetected as long as possible. This typically requires
the sample to detect the presence of analysis tools, or to distin-
guish whether it is running within an analysis environment or
on a real target device. We now present more details about the
different evasion techniques, whose prevalence in our dataset
is summarized in Table XIII.
Sandbox Detection. Our string comparison instrumentation
detected a number of programs that attempted to detect the
presence of a sandbox by comparing different pieces of
171
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:40 UTC from IEEE Xplore.  Restrictions apply. 
information extracted from the system with strings such as
“VMware” or “QEMU.” Table XIV reports the ﬁles where
the information was collected. Ten samples who tested the
sys_vendor ﬁle were able to detect our analysis environ-
ment when executed with root privileges (as we restricted
the permissions to ﬁles exposing the motherboard DMI zone
information reported by the kernel). We also identiﬁed sam-
ples attempting to detect chroot()-based jails (by com-
paring /proc/1/mountinfo with /proc//mountinfo), OpenVZ containers [24], and even one
binary (from the Handofthief family) trying to evade IBM
mainframes and IBM’s virtualization technology. It is also in-
teresting to note how some samples simply decide to exit when
they detect they are running in a virtual environment, while
other adopt a more aggressive (but less stealthy) approach,
such as trying to delete the entire ﬁle system.
Processes Enumeration. It is common in Windows to evade
analysis by verifying the presence of a particular set of
processes, or inspecting the goodness and authenticity of
companion processes that live on the system. We investigated
whether Linux malware samples already employ similar tech-
niques and found 259 samples that perform a full scan of
the /proc/ directories. However, none of the samples
appeared to perform these scans for evasive purposes but
instead to test if the machine was already infected or to identify
target processes to kill (as we explain in Section V-F).
Anti-Debugging. The most common anti-debugging technique
is based on the ptrace system call that provides to debuggers
the ability to “attach” to a target process to programmati-
cally inspect and interact with it. As a given process can
only have at most one debugger attached to it, one com-
mon evasion technique used by malware consists of invoking
the ptrace system call with ﬂags PTRACE_TRACEME or
PTRACE_ATTACH on themselves to detect if another debugger
is already attached or prevent it to do so while the sample
is running. We found 63 samples employing this mechanism.
We also identiﬁed one sample checking the presence of the
LD_PRELOAD environment variable, which is often used to
override functions in dynamically loaded libraries (with the
goal of dynamically instrumenting their execution).
It
is important
to note that
the tracing system we use
in our sandbox is based on kernel probes (as described in
section III-D), and it cannot be detected or tampered with by
using anti-debugging techniques.
Anti-Execution. Our experiments detected samples belonging
to the DnsAmp malware family that did not manifest any
behavior, except from comparing their own ﬁle name with
a hardcoded string. A closer look at these samples showed
that the malware authors used this trick as an evasive solu-
tion, as many malware collection infrastructures and analysis
sandboxes often rename the ﬁles before their analysis.
Stalling Code. Windows malware is known to often employ
stalling code that, as the name suggests, is a technique used to
delay the execution of the malicious behavior – assuming an
analysis sandbox would only run each sample for few minutes.
TOP 20 LIBRARIES INCLUDED BY DYNAMICALLY LINKED EXECUTABLES
TABLE XV
Library
glibc
uclibc
libgcc
libstdc++
libz
libcurl
libssl
libxml2
libjansson
libncurses
Percentage
74.21%
24.24%
9.74%
7.12%
5.24%
3.64%
2.35%
1.44%
1.39%
1.28%
Library
libscotch
libtinfo
libgmp
libmicrohttpd
libkrb5
libcomerr
libperl
libhwloc
libedit
libopencl
Percentage
1.23%
0.75%
0.75%
0.64%
0.64%
0.64%
0.59%
0.59%
0.54%
0.54%
We investigated whether Linux malware is already using
simple variants of this technique by scanning our execution
traces for samples using time- or sleep-related functions. We
found that 64% of the binaries we analyzed make use of the
nanosleep system call, with values ranging from less than
a second to higher than three hours. However, none of them
appear to use these delays to stall their execution (in fact, our
traces contained clear signs of their behavior), but rather to
coordinate child processes or network communications.
I. Libraries
There are two main ways an executable can make use
of libraries. In the ﬁrst (and more common) case, the exe-
cutable is dynamically linked and external libraries are loaded
at run-time, permitting code reuse and localized upgrades.
Conversely, an executable that is statically linked includes
the object ﬁles of its libraries as part of its executable ﬁle—
removing any external dependency of the application and thus
making it more portable.
More than 80% of the samples we analyzed are statically
linked. Nevertheless, we note that only 24% of these samples
have been stripped from their symbols, with the remaining
ones often including even functions and variables names used
by developers. Similarly for dynamically linked samples in our
dataset, only 33% of them are stripped. We ﬁnd this trend very
interesting as apparently malware developers lack motivation
to obfuscate their code against manual analysis—which is
in sharp contrast with the complexity of evasive Windows
malware.
Common Libraries. Table XV lists the dynamic libraries that
are most often imported by malware samples in our dataset.
This lists shows two important aspects. First, that while the
GNU C library (glibc) is (expectedly) the most requested
library, we found that 24% of samples link against smaller
implementations like uClibc, often used in embedded systems.
It is also interesting to see how almost 10% of the dataset links
against libgcc, a library used by the GCC compiler to handle
arithmetic operations that the target processor cannot perform
directly (e.g., ﬂoating-point and ﬁxed-point operations). This
library is rarely used in the context of desktop environments,