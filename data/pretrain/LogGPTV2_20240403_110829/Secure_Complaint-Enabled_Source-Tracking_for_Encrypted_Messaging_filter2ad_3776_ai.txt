ğ‘ˆğ‘Ÿ such that this simulated transcript is indistinguishable from a
real transcript to any efficient distinguisher with access to ğ‘ˆğ‘  and
ğ‘ˆğ‘Ÿ â€™s secret keys.
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1498Substituting in a weaker assumption on the messaging scheme
would just result in the same weakened guarantee for the overall
system, so using this approach means that we can guarantee a
source-tracking scheme preserves the offline deniability of any
messaging scheme it is built on top of.
Following the approach of [31], we additionally show that in
addition to universal deniability, where the forger has access to an
arbitrary third party user and the discerning party has access to
the long-term keys of all involved users, our schemes also satisfy
platform-compromise deniability, which gives the forger and dis-
cerning party additional access to the platformâ€™s keys. This second
form of deniability ensures that even in the event that the platform
was compromised and its secret keys exposed, deniability can be
preserved.
While not required in our definition for deniable source-tracking
schemes, it is worth noting that our scheme constructions provide
strong deniability protections for reporters of malicious messages,
regardless of the deniability guarantees of the underlying messaging
scheme. Neither scheme makes use of the messaging oracles or
usersâ€™ secret keys while making a report, and additionally anyone
with knowledge of the forwarding data for a particular message
can report it even if they themselves did not receive it, meaning
that the pool of users who could have reported a message is not
restricted to the users on the forwarding path of the message in
question.
We present two security games to address each of these types of
deniability: ğ‘ˆ ğ‘›ğ‘–ğ‘£ğ·ğ¸ğ‘ and ğ‘ƒğ‘™ğ‘ğ‘¡ğ·ğ‘’ğ‘› (Figure 8). Each game accepts
the corresponding forgery algorithm that simulates a forwarding
pathâ€™s transcripts as a parameter. The games get access to a chal-
lenge oracle Chal(Â·, Â·, Â·, ğ‘¡ğ‘¦ğ‘ğ‘’), where the value of ğ‘¡ğ‘¦ğ‘ğ‘’ is either u
(universal) or p (platform) depending on the type of game, as well
as the ability to create new users of their choice.
The deniability challenge consists of the adversary presenting a
query that consists of a message ğ‘š, a path of users ğ‘, a forging user
ğ‘ˆğ·, and a list of metadata mds. The challenge will either output
the actual transcripts (ğ‘‡ğ‘Ÿğ‘Ÿ , ğ‘‡ğ‘Ÿ ğ‘“ , and ğ‘‡ğ‘Ÿğ‘Ÿğ‘’ğ‘) and forwarding data
resulting from sending the message along the path and then being
reported by the last user, or a forged version constructed by in-
putting the query into the forgery algorithm, which is given access
to the sending and receiving capabilities of ğ‘ˆğ· and a simulator
for the underlying messaging scheme, SimE. The functions of this
oracle are presented in Figure 8 as interactive protocols where F is
the portion of the interaction that the forger can control.
B SECURITY PROOFS FOR TREE-LINKABLE
SOURCE-TRACKING
B.1 Confidentiality â€“ Proof of Theorem 4.1
Proof. The proof of this statement follows immediately from
combining the results of Lemmas B.1 and B.2, which prove user
and platform confidentiality, respectively.
â–¡
Proof. We construct a series of hybrid games to show that
ğ‘™ğ‘ˆğ¶ğ‘‚ğ‘ ğ¹ 1 is indistinguishable from ğ‘™ğ‘ˆğ¶ğ‘‚ğ‘ ğ¹ 0 to any efficient ad-
versary. This proves that the scheme satisfies tree-linkable user
confidentiality.
G0: This game is identical to the standard ğ‘ˆğ¶ğ‘‚ğ‘ ğ¹ game when
ğ‘ = 0.
G1: We modify goodAuth (oracle function for authoring a mes-
sage between two honest users) and malSend (oracle func-
tion for sending a message from a malicious user) so that
the ğ‘ ğ‘Ÿğ‘ the platform computes and includes in the platform
data is an encryption of some default user and metadata
ğ‘ˆğ·||mdğ· rather than the actual author of the message (the
default data can, for example, be an all-zero string). Because
the adversary does not have the secret key, and this value is
never decrypted by the platform, this version of the game is
indistinguishable from Game 0 by the CPA-security of the
platformâ€™s encryption scheme, P.
G2: We modify goodFwd (oracle function for forwarding a mes-
sage between two honest users) to immediately abort if the
user provides an ğ‘šğ‘–ğ‘‘ âˆˆ ğ‘‡ğ‘Ÿğ‘’ğ‘ such that the signature or com-
mitment included in the forwarding data for the associated
message is invalid. By the definition of the scheme, any mes-
sage stored in ğ‘‡ğ‘Ÿğ‘’ğ‘ thatâ€™s associated with an honest receiver
was received successfully by that honest user who checked
the correctly formed signature and commitment, so this will
never happen, and this game is indistinguishable from Game
1.
G3: We again modify goodFwd so that after checking that
the users associated with the given ğ‘šğ‘–ğ‘‘ are correct and
that ğ‘šğ‘–ğ‘‘ âˆˆ ğ‘‡ğ‘Ÿğ‘’ğ‘, if ğ‘š, fd, ğ‘¡ğ‘–ğ‘‘ is the data associated with
the provided ğ‘šğ‘–ğ‘‘, the oracle doesnâ€™t actually forward the
message but instead just adds a new entry ğ‘‡ğ‘Ÿğ‘’ğ‘[ğ‘šğ‘–ğ‘‘â€²] =
(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , ğ‘š, fd, ğ‘¡ğ‘–ğ‘‘) to the table. By definition of the scheme,
the resulting entry in ğ‘‡ğ‘Ÿğ‘’ğ‘ is identical to the entry if the
message had actually been forwarded, and so this game is
indistinguishable from Game 2 as the oracle does not modify
any other persistent state outside of the table ğ‘‡ğ‘Ÿğ‘’ğ‘.
We note that after these modifications, the output of malRec
(oracle function for forwarding a message to a malicious receiver,
the function gets two potential forwards and uses the value of ğ‘ to
determine which one the adversary sees), which is the only oracle
function that uses ğ‘ to decide what to output, no longer depends on
ğ‘ because the forwarding data of all honestly sent messages have
the same contents. This means that applying and identical series of
hybrid steps to those described in G0 to G3 starting at ğ‘™ğ‘ˆğ¶ğ‘‚ğ‘ ğ¹ 1
instead of ğ‘™ğ‘ˆğ¶ğ‘‚ğ‘ ğ¹ 0 gets us to a game identical to Game 3 that is
indistinguishable from ğ‘™ğ‘ˆğ¶ğ‘‚ğ‘ ğ¹ 1 to an efficient adversary.
Thus we have shown that we can go from ğ‘™ğ‘ˆğ¶ğ‘‚ğ‘ ğ¹ 0 to ğ‘™ğ‘ˆğ¶ğ‘‚ğ‘ ğ¹ 1
through a series of indistinguishable hybrids, and we can con-
clude that any adversaryâ€™s advantage against the ğ‘™ğ‘ˆğ¶ğ‘‚ğ‘ ğ¹ game
for Scheme 1 must be negligible.
â–¡
Lemma B.1. Assuming that P is CPA-secure, and the commitment
and signatures schemes C and S are correct, the advantage of any
efficient adversary against the ğ‘™ğ‘ˆğ¶ğ‘‚ğ‘ ğ¹ game for Scheme 1 is negli-
gible.
Lemma B.2. Assuming that the commitment scheme is hiding and
the messaging encryption scheme E is AE-secure, the advantage of
any efficient adversary A against the ğ‘ƒğ¶ğ‘‚ğ‘ ğ¹ game for Scheme 1 is
negligible.
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1499ğ‘†ğ‘‡ ,E,UForge
ğ‘ˆ ğ‘›ğ‘–ğ‘£ğ·ğ¸ğ‘ A,ğ‘
(pk, sk) â†R KGen(ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ )
ğ‘â€² â† AOu (pk)
return ğ‘â€²
Chal(ğ‘ğ‘ğ‘¡â„, ğ‘ˆğ·, ğ‘š, mds, ğ‘¡ğ‘¦ğ‘ğ‘’)
ğ‘†ğ‘‡ ,E,PForge
ğ‘ƒğ‘™ğ‘ğ‘¡ğ·ğ¸ğ‘ A,ğ‘
(pk, sk) â†R KGen(ğ‘ğ‘ğ‘Ÿğ‘ğ‘šğ‘ )
ğ‘â€² â† AOp (pk, sk)
return ğ‘â€²
//Construct path
(ğ‘ˆ0, ..., ğ‘ˆğ‘˜) â† ğ‘ğ‘ğ‘¡â„
if ğ‘ˆğ·, ğ‘ˆ0, ..., ğ‘ˆğ‘˜ âˆ‰ U :
return âŠ¥
ad â† ğ‘‡ğ‘ğ‘¢ğ‘¡â„[ğ‘ˆ0], ğ‘šğ‘ ğ‘” â† (ğ‘š, ad)
(adâ€², ğ‘ğ‘‘, ğ‘’) â† âŸ¨ğ‘ˆğ‘ğ‘¢ğ‘¡â„(ğ‘šğ‘ ğ‘”), ğ‘ƒğ‘ ğ‘’ğ‘›ğ‘‘ (sk, mds[0])âŸ©(ğ‘ˆ0, ğ‘ˆ1, pk)
(ğ‘š, fd,ğ‘‡ ğ‘Ÿğ‘Ÿ) â† âŸ¨ğ‘ˆğ‘Ÿğ‘’ğ‘, ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk, ğ‘ğ‘‘)âŸ©(ğ‘ˆ0, ğ‘ˆ1, ğ‘’, pk)
ğ‘œğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡0.ğ‘ğ‘ğ‘ğ‘’ğ‘›ğ‘‘((ğ‘‡ ğ‘Ÿğ‘Ÿ , fd)),ğ‘‡ğ‘ğ‘¢ğ‘¡â„[ğ‘ˆ0] â† adâ€²
for ğ‘– = 1, ..., ğ‘˜ âˆ’ 1 :
ğ‘šğ‘ ğ‘” â† (ğ‘š, fd)
(fdâ€², ğ‘ğ‘‘, ğ‘’,ğ‘‡ ğ‘Ÿ ğ‘“ ) â† âŸ¨ğ‘ˆğ‘“ ğ‘¤ğ‘‘ (ğ‘šğ‘ ğ‘”), ğ‘ƒğ‘ ğ‘’ğ‘›ğ‘‘ (sk, mds[ğ‘–])âŸ©(ğ‘ˆğ‘–, ğ‘ˆğ‘–+1, pk)
(ğ‘š, fd,ğ‘‡ ğ‘Ÿğ‘Ÿ) â† âŸ¨ğ‘ˆğ‘Ÿğ‘’ğ‘, ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk, ğ‘ğ‘‘)âŸ©(ğ‘ˆğ‘–, ğ‘ˆğ‘–+1, ğ‘’, pk)
ğ‘œğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡0.ğ‘ğ‘ğ‘ğ‘’ğ‘›ğ‘‘(ğ‘‡ ğ‘Ÿ ğ‘“ , fdâ€²,ğ‘‡ ğ‘Ÿğ‘Ÿ , fd)
((ğ‘ ğ‘Ÿğ‘, md),ğ‘‡ ğ‘Ÿğ‘Ÿğ‘’ğ‘) â† âŸ¨ğ‘ˆğ‘Ÿğ‘’ğ‘ (fd), ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk)âŸ©(ğ‘š, pk)
ğ‘œğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡0.ğ‘ğ‘ğ‘ğ‘’ğ‘›ğ‘‘(ğ‘‡ ğ‘Ÿğ‘Ÿğ‘’ğ‘, (ğ‘ ğ‘Ÿğ‘, md))
//construct forgery
if ğ‘¡ ğ‘¦ğ‘ğ‘’ = u :
if ğ‘¡ ğ‘¦ğ‘ğ‘’ = p :
return ğ‘œğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡ğ‘
ğ‘œğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡1 â† UForgeO(ğ‘ˆğ· ) (ğ‘ğ‘ğ‘¡â„, ğ‘š, mds, pk)
ğ‘œğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡1 â† PForgeO(ğ‘ˆğ· ) (ğ‘ğ‘ğ‘¡â„, ğ‘š, mds, pk, sk)
return âŠ¥
getUser(ğ‘ˆ)
if ğ‘ˆ âˆˆ U :
(ad, Uâ€²) â† âŸ¨ğ‘ˆğ‘›ğ‘’ğ‘¤, ğ‘ƒğ‘›ğ‘’ğ‘¤ (U, sk)âŸ©(ğ‘ˆ , pk)
ğ‘‡ğ‘ğ‘¢ğ‘¡â„[ğ‘ˆ ] â† ad, U.ğ‘ğ‘‘ğ‘‘(ğ‘ˆ)
return ad
ForgeSend(ğ‘ˆğ‘Ÿ , md)
(ğ‘ğ‘‘, ğ‘’) â† âŸ¨F, ğ‘ƒğ‘ ğ‘’ğ‘›ğ‘‘ (sk, md)âŸ©(ğ‘ˆğ·, ğ‘ˆğ‘Ÿ , pk)
if ğ‘ˆğ‘Ÿ â‰  ğ‘ˆğ· : return
âŸ¨F, ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk, ğ‘ğ‘‘)âŸ©(ğ‘ˆğ·, ğ‘ˆğ·, ğ‘’, pk)
Report(ğ‘š)
âŸ¨F, ğ‘ƒğ‘Ÿğ‘’ğ‘ (sk)âŸ©(ğ‘š, pk)
ğ‘’ â† SimE(ğ‘ˆğ‘ , ğ‘ˆğ‘Ÿ , ğ‘š)
Oracle functions O(Â·) for forgery algorithms. SimE
simulates a transcript of the messaging scheme using
the simulator guaranteed to exist by the deniability of
the messaging scheme.
Figure 8: Deniability games and oracle functions. Oracles Oğ‘¡ ğ‘¦ğ‘ğ‘’ for ğ‘¡ ğ‘¦ğ‘ğ‘’ = u or p give the adversary access to the functions getUser(Â·, Â·),
Chal(Â·, Â·, Â·, Â·, ğ‘¡ ğ‘¦ğ‘ğ‘’), and send(Â·, ğ‘ˆ , Â·) and receive(Â·, Â·, ğ‘ˆ) oracles for the underlying messaging scheme for all users ğ‘ˆ âˆˆ U. Oracle O(ğ‘ˆğ·)
gives the forgery algorithms access to the Send and Report functions.
Note that the lemma requires that the messaging scheme guar-
antee authenticated encryption. This sort of guarantee is common
among most encrypted messaging schemes, such as Signalâ€™s Double
Ratchet Protocol [23].
Proof. We first present a series of hybrid games that show an
adversary cannot gain advantage by tampering with messages be-
tween honest users. By definition of the scheme, the platform is
tasked with passing on the platform data (ğœ, ğ‘ ğ‘Ÿğ‘) to the receiving
user, and the security game additionally gives the option for the
platform to choose the message identifier ğ‘’ that the receiver gets
as input. The platform could stray from the correct protocol by
calling goodRec (oracle function for receiving a message between
honest users) with an ğ‘’ that wasnâ€™t the same as the one outputted
by the sending interaction associated with the ğ‘šğ‘–ğ‘‘, or by signing
a value other than the ğ‘ ğ‘Ÿğ‘ value chosen by the platform and the
commitment presented by the sender.
G0: This initial game is identical to ğ‘ƒğ¶ğ‘‚ğ‘ ğ¹ A,0
ğ‘†ğ‘‡ ,E, the game when
G1: We add the additional condition to goodRec to abort imme-
diately if the inputted ğ‘’ value has never been outputted by
the sender ğ‘ˆğ‘  as part of a message to the receiver ğ‘ˆğ‘Ÿ at any
ğ‘ = 0.
point in the game. By definition, this can only happen dur-
ing a call to goodSend because ğ‘ˆğ‘  and ğ‘ˆğ‘Ÿ are honest. This
is indistinguishable from G0 because finding a valid ğ‘’ that
was not sent from ğ‘ˆğ‘  to ğ‘ˆğ‘Ÿ contradicts the authenticated
encryption properties of the messaging scheme, specifically
its ciphertext integrity, and can therefore happen with only
negligible probability.
We note that if the adversary presents a different ğ‘’ but the
game does not abort due to the above condition, ğ‘’ must have
resulted from a call to goodSend between ğ‘ˆğ‘  and ğ‘ˆğ‘Ÿ earlier
in the game, and so there exists some ğ‘šğ‘–ğ‘‘â€²â€² in ğ‘‡ğ‘ ğ‘’ğ‘›ğ‘‘ that
stores ğ‘’. The only difference between calling goodRec with
the correct pair (ğ‘šğ‘–ğ‘‘â€²â€², ğ‘’) instead of (ğ‘šğ‘–ğ‘‘, ğ‘’) is that the ğ‘¡ğ‘–ğ‘‘
will always be âŠ¥, which only weakens the adversaryâ€™s power
because it can no longer see the message contents by having
the message reported and so we can assume that ğ‘’ = ğ‘’â€² in
all other cases.
In this game, if during goodRec the platform presents an
honest user with platform data (ğœ, ğ‘ ğ‘Ÿğ‘) and a message iden-
tifier ğ‘’ such that ğœ is a signature on the pair (ğ‘ğ‘š, ğ‘ ğ‘Ÿğ‘), but
(ğ‘ğ‘š, ğ‘’) was never sent by the sending user, the game aborts.
By the properties of Game 1, we know that the ğ‘’ must have
G2:
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1500been created by the sending user and so contains an encryp-
tion of the commitment ğ‘ğ‘š that the sender linked to ğ‘’, and
therefore the receipt of the message will fail when the re-
ceiving user compares the commitment that is signed by the
platform to the value encrypted in ğ‘’. Therefore, this game is
indistinguishable from Game 3 because an adversary cannot
create an otherwise valid message that fails for this reason.
Similarly, the ğ‘ ğ‘Ÿğ‘ value is chosen by the platform and sent
over in the clear, so the platform gains no advantage by
signing a value other than the correct ğ‘ ğ‘Ÿğ‘, because it already
knows it will cause the signature verification to fail.
We conclude that a platform gains no advantage by passing a
receiver something other than the platform data and message iden-
tifier outputted by following the honest protocol. We now present
two hybrids that show forwarded messages are indistinguishable
from authored messages.
G3: Game 3 is identical to Game 2, except that during goodSend,
a forwarded message ğ‘š with forwarding data ğœ, ğ‘ ğ‘Ÿğ‘, ğ‘ğ‘š, ğ‘Ÿ
that would normally be forwarded as ğ‘’, ğ‘âŠ¥ where ğ‘âŠ¥ is a
commitment to âŠ¥ is instead forwarded with ğ‘’, ğ‘â€²
ğ‘š where ğ‘â€²
ğ‘š
is a new commitment to ğ‘š. The honest receiver evaluates the
message as if ğ‘â€²