memory pages assigned to the mbuf cluster pool with it. Moreover, mbinit() starts a kernel thread running mbuf_expand_thread()
[bsd/kern/uipc_mbuf.c] in the kernel task, with the purpose of growing the cluster pool if the number of free clusters becomes low.
audit_init() [bsd/kern/kern_audit.c] initializes the kernel's audit event table, audit memory zone, associated data structures, and the BSM
audit subsystem.[29] It calls kau_init() [bsd/kern/kern_bsm_audit.c] to initialize the latter, which, among other things, calls
au_evclassmap_init() [bsd/kern/kern_bsm_klib.c] to set up the initial audit-event-to-event-class mapping for system calls. For example,
an event called AUE_OPEN_R (defined in bsd/bsm/audit_kevents.h) is mapped to an event class called AU_FREAD (defined in
bsd/sys/audit.h). audit_init() also initializes a zone (audit_zone) for audit records. Note that audit logging is not initiated until the user-
space audit daemonauditdis started.
[29] BSM stands for Basic Security Module. We will look at the implementation details of the audit subsystem in Chapter 6.
knote_init() [bsd/kern/kern_event.c] initializes a zone (knote_zone) for the kqueue kernel event notification mechanism. It also allocates
kqueue-related locks.
aio_init() [bsd/kern/kern_aio.c] initializes the asynchronous I/O (AIO) subsystem. This includes initialization of locks, queues, statistics,
and an AIO work queue zone (aio_workq_zonep) for AIO work queue entries. aio_init() creates AIO worker threads by calling
_aio_create_worker_threads() [bsd/kern/kern_aio.c]. The number of threads created is contained in the variable aio_worker_threads
[bsd/conf/param.c], which is initialized to the constant AIO_THREAD_COUNT (defined to be 4 in bsd/conf/param.c). An AIO worker thread
runs the function aio_work_thread() [bsd/kern/kern_aio.c].
pipeinit() [bsd/kern/sys_pipe.c] initializes a zone (pipe_zone) for pipe data structures and allocates locking data structures.
bsd_init() now initializes locks for the POSIX and System V IPC mechanisms. Moreover, it calls pshm_cache_init()
[bsd/kern/posix_shm.c] and psem_cache_init() [bsd/kern/posix_sem.c] to initialize hash tables for storing hash values of looked-up
names of POSIX shared memory and semaphores, respectively.
bsd_init() then calls time_zone_slock_init() [bsd/kern/kern_time.c] to initialize tz_slock, a simple lock used for accessing the global
time zone structure, tz, which is defined in bsd/conf/param.c. The lock is used by the gettimeofday() and settimeofday() calls.
Next, bsd_init() calls sysctl_register_fixed() [bsd/kern/kern_newsysctl.c] to register sysctl object IDs from the statically defined
sysctl lists, such as newsysctl_list [bsd/kern/sysctl_init.c] and machdep_sysctl_list (bsd/dev/ppc/sysctl.c). This includes
creating and populating top-level sysctl nodes such as kern, hw, machdep, net, debug, and vfs. bsd_init() then calls sysctl_mib_init()
[bsd/kern/kern_mib.c] to populate optional sysctls.
5.7.4. Networking Subsystem Initialization
At this point, bsd_init() starts initialization of the networking subsystem. dlil_init() [bsd/net/dlil.c] initializes the data link interface
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh90B0.htm 20.08.2007
Chapter 5. Kernel and User-Level Startup Page 34 of 59
layer (DLIL). This includes initializing queues for data link interfaces, interface families, and protocol families. dlil_init() also starts the
DLIL input thread (dlil_input_thread() [bsd/net/dlil.c]) and another thread for invoking delayed detachment[30] of protocols, protocols
filters, and interface filters (dlil_call_delayed_detach_thread() [bsd/net/dlil.c]).
[30] The detachment is delayed if it is not safe to detach.
The input thread services two input queues of mbufs: one for the loopback[31] interface and the other for nonloopback interfaces. For each
packet, it invokes dlil_input_packet() [bsd/net/dlil.c] with three arguments: the interface the packet was received on, an mbuf pointer
for the packet, and a pointer to the packet header. Finally, the input thread calls proto_input_run() [bsd/net/kpi_protocol.c], which first
handles any pending attachment or detachment[32] of protocol input handler functions and then iterates over all existing protocol input entries,
looking for those with a nonempty chain of packets. It calls proto_delayed_inject() [bsd/net/kpi_protocol.c] on entries that have
packets to input.
[31] Mac OS X supports only one loopback interface.
[32] If an input handler is already registered, it is detached.
proto_kpi_init() [bsd/net/kpi_protocol.c] allocates locking data structures used by the protocol code in bsd/net/kpi_protocol.c.
socketinit() [bsd/kern/uipc_socket.c] allocates locking data structures and initializes a zone (so_cache_zone) for the kernel's socket-
caching mechanism. It also arranges for so_cache_timer() [bsd/kern/uipc_socket.c] to run periodically. The latter frees cached socket
structures whose timestamps are older than the current timestamp by SO_CACHE_TIME_LIMIT [bsd/sys/socketvar.h] or more. This caching
mechanism allows process control blocks to be reused for sockets cached in the socket layer.
domaininit() [bsd/kern/uipc_domain.c] first creates a list of all available communications domains. It then calls init_domain()
[bsd/kern/uipc_domain.c] on each available domain. Figure 518 depicts the domain and protocol initialization performed by these functions.
Figure 518. Domain and protocol initialization
// bsd/sys/domain.h
struct domain {
int dom_family; // AF_xxx
char *dom_name; // string name
void (*dom_init)__P((void)); // initialization routine
...
struct protosw *dom_protosw; // chain of protosw structures
struct domain *dom_next; // next domain on chain
...
};
// bsd/kern/uipc_domain.c
void
domaininit()
{
register struct domain *dp;
...
extern struct domain localdomain, routedomain, ndrvdo-main, ...;
...
// Initialize locking data structures
...
// Put them all on the global domain list
concat_domain(&localdomain);
concat_domain(&routedomain);
...
// Initialize each domain
for (dp = domains; dp; dp = dp->dom_next)
init_domain(dp);
...
timeout(pffasttimo, NULL, 1);
timeout(pfslowtimo, NULL, 1);
}
...
void
init_domain(register struct domain *dp)
{
...
// Call domain's initialization function
if (dp->dom_init)
(*dp->dom_init)();
// Initialize the currently installed protocols in this domain
for (pr = dp->dom_protosw; pr; pr = pr->pr_next) {
if (pr->pr_usrreqs == 0)
panic("domaininit: %ssw[%d] has no usrreqs!",
dp->dom_name, (int)(pr - dp->dom_protosw));
if (pr->pr_init)
(*pr->pr_init)();
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh90B0.htm 20.08.2007
Chapter 5. Kernel and User-Level Startup Page 35 of 59
}
...
}
...
void
pfslowtimo(void *arg)
{
// For each protocol within each domain, if the protocol has a
// pr_slowtimo() function, call it.
//
// Moreover, if do_reclaim is TRUE, also call each protocol's
// pr_drain() if it has one.
...
timeout(pfslowtimo, NULL, hz/2);
}
void
pffasttimo(void *arg)
{
// For each protocol within each domain, if the protocol has a
// pr_fasttimo() function, call it.
...
timeout(pffasttimo, NULL, hz/5);
}
init_domain() calls the initialization routineif one existsfor the domain. It then uses the domain structure's dom_protosw field to retrieve the
chain of protocol switch structures supported for the address family represented by the domain. It iterates over the list of protosw structures
[bsd/sys/protosw.h], calling each installed protocol's initialization routine (the pr_init field of the protosw structure). init_domain() also
looks at the domain's protocol header length (the dom_protohdrlen field of the domain structure), and, if needed, updates the values of the
following global variables: max_linkhdr (largest link-level header systemwide), max_protohdr (largest protocol header systemwide), max_hdr
(largest system/protocol pair systemwide), and max_datalen (the difference of MHLEN and max_hdr, where MHLEN is computed in
bsd/sys/mbuf.h).
5.7.5. Miscellaneous BSD Initialization (Part 3)
bsd_init() sets process 0's root directory and current directory pointers to NULL. Note that the root device has not been mounted yet.
bsd_init() then calls thread_wakeup() to wake threads sleeping on lbolt, the global once-a-second sleep address. Next, it calls timeout()
[bsd/kern/kern_clock.c] to start running lightning_bolt() [bsd/kern/bsd_init.c], which will continue to call thread_wakeup() on
lbolt every second. lightning_bolt() also calls klogwakeup() [bsd/kern/subr_log.c], which checks whether any log entries are pending,
and if so, it calls logwakeup() [bsd/kern/subr_log.c] to notify any processes (such as system loggers) that may be waiting for log output.
// bsd/kern/bsd_init.c
void
lightning_bolt()
{
boolean_t funnel_state;
extern void klogwakeup(void);
funnel_state = thread_funnel_set(kernel_flock, TRUE);
thread_wakeup(&lbolt);
timeout(lightning_bolt, 0, hz);
klogwakeup();
(void)thread_funnel_set(kernel_flock, FALSE);
}
bsd_init() calls bsd_autoconf() [bsd/kern/bsd_init.c], which first calls kminit() [bsd/dev/ppc/km.c] to tell BSD's keyboard (input)
and monitor (output) module to flag itself initialized. It then initializes the pseudo-devices by iterating over the pseudo_inits array of
pseudo_init structures [bsd/dev/busvar.h] and calling each element's ps_func function. The pseudo_inits array is generated at compile
time by the config utility:
// build/obj/RELEASE_PPC/bsd/RELEASE/ioconf.c
#include 
extern pty_init();
extern vndevice_init();
extern mdevinit();
extern bpf_init();
extern fsevents_init();
extern random_init();
struct pseudo_init pseudo_inits[] = {
128, pty_init,
4, vndevice_init,
1, mdevinit,
4, bpf_init,
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh90B0.htm 20.08.2007
Chapter 5. Kernel and User-Level Startup Page 36 of 59
1, fsevents_init,
1, random_init,
0, 0,
};
bsd_autoconf() finally calls IOKitBSDInit() [iokit/bsddev/IOKitBSDInit.cpp], which publishes the BSD kernel as a resource named
"IOBSD".
bsd_init() attaches the loopback interface by calling loopattach() [bsd/net/if_loop.c], which calls lo_reg_if_mods()
[bsd/net/if_loop.c] to register the PF_INET and PF_INET6 protocol families by calling dlil_reg_proto_module() [bsd/net/dlil.c].
loopattach() then calls dlil_if_attach() [bsd/net/dlil.c] to attach the loopback interface, followed by a call to bpfattach()
[bsd/net/bpf.c], which attaches the loopback interface to the Berkeley Packet Filter (BPF)[33] mechanism. The link layer type used in this
attachment is DLT_NULL.
[33] BPF provides a raw interface to data link layers independently of protocols.
ether_family_init() [bsd/net/ether_if_module.c] initializes the Ethernet interface family by calling dlil_reg_if_modules()
[bsd/net/dlil.c]. This is followed by calls to dlil_reg_proto_module() [bsd/net/dlil.c] to register the PF_INET and PF_INET6 protocol
families for the Ethernet interface family. ether_family_init() also initializes support for IEEE 802.Q Virtual LANs (VLANs) by calling
vlan_family_init() [bsd/net/if_vlan.c]. This creates a VLAN pseudo-devicea device in softwarethat uses much of the Ethernet interface
family's functionality. Finally, ether_family_init() calls bond_family_init() [bsd/net/if_bond.c] to initialize support for IEEE
802.3ad Link Aggregation, which allows multiple Ethernet ports to be bonded, or aggregated, into a single virtual interface, with automatic load
balancing across the ports.
The kernel provides an interfacethe net_init_add() functionto register functions that will be called when the network stack is being
initialized. This is useful for kernel extensions that wish to register network filters before any sockets are created or any network activity occurs
in the kernel. After initializing the Ethernet interface family, bsd_init() calls net_init_run() [bsd/net/init.c] to run any such registered
functions.
vnode_pager_bootstrap() [osfmk/vm/bsd_vm.c] initializes a zone (vnode_pager_zone) for the vnode pager's data structures. This zone has
an allocation size of one page and an element size the same as that of a vnode_pager structure [osfmk/vm/bsd_vm.c]. The zone can use a
maximum memory that allows for as many as MAX_VNODE such structures. MAX_VNODE is defined to be 10,000 in osfmk/vm/bsd_vm.c.
inittodr() [bsd/kern/kern_time.c] calls microtime() [bsd/kern/kern_time.c] to retrieve the calendar time value in a timeval structure
[bsd/sys/time.h]. If either of the seconds or microseconds components of the structure is negative, inittodr() resets the calendar clock by
calling setthetime() [bsd/kern/kern_time.c].
5.7.6. Mounting the Root File System
bsd_init() now initiates mounting of the root file system. As shown in Figure 519, it goes into an infinite loop that breaks when the root file
system is successfully mounted. Within the loop, bsd_init() calls setconf() [bsd/kern/bsd_init.c], which determines the root device,
including whether it is to be accessed over the network. bsd_init() then calls vfs_mountroot() [bsd/vfs/vfs_subr.c] to attempt to mount
the root device.
Figure 519. Mounting the root file system
// bsd/kern/bsd_init.c
void
bsd_init()
{
...
// Mount the root file system
while (TRUE) {
int err;
setconf();
...
if (0 == (err = vfs_mountroot()))
break;
#if NFSCLIENT
if (mountroot == netboot_mountroot) {
printf("cannot mount network root, errno = %d\n", err);
mountroot = NULL;
if (0 == (err = vfs_mountroot()))
break;
}
#endif
printf("cannot mount root, errno = %d\n", err);
boothowto |= RB_ASKNAME;
}
...
}
As shown in Figure 520, setconf() calls IOFindBSDRoot() [iokit/bsddev/IOKitBSDInit.cpp]an I/O Kit functionto determine the root
device. On success, IOFindBSDRoot() populates the rootdev variable that is passed to it as an argument. If IOFindBSDRoot() fails, setconf
() may explicitly set the root device to /dev/sd0a as a debugging aid. setconf() also checks the value of the flags variable, because
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh90B0.htm 20.08.2007
Chapter 5. Kernel and User-Level Startup Page 37 of 59
IOFindBSDRoot() sets its lowest bit in the case of the root being a network boot device. If so, setconf() sets a global function
pointermountroot [bsd/vfs/vfs_conf.c]to point to the function netboot_mountroot() [bsd/kern/netboot.c]. If the value of flags is 0,
the mountroot pointer is set to NULL. Later, vfs_mountroot() checks whether mountroot is a valid pointer; if so, it invokes the corresponding
function to attempt to mount the root file system.
Figure 520. Finding the root device with help from the I/O Kit
// bsd/kern/bsd_init.c
dev_t rootdev; // root device major/minor number
char rootdevice[16]; // root device name
...
extern int (*mountroot) __P((void));
...
setconf()
{
u_int32_t flags;
...
err = IOFindBSDRoot(rootdevice, &rootdev, &flags);
...
if (err) {
// debugging: set root device to /dev/sd0a
flags = 0;
}
if (flags & 1) {
// root will be mounted over the network
mountroot = netboot_mountroot;
} else {
// the VFS layer will query each file system to
// determine if it can provide the root
mountroot = NULL;
}
}
Let us look at the working of IOFindBSDRoot(). Since setconf() is called in a loop, IOFindBSDRoot() may be called more than once. As
Figure 521 shows, IOFindBSDRoot() keeps track of the number of times it has been called and sleeps for 5 seconds on the second and
subsequent invocations. It checks for the presence of the rd and rootdev (in that order) boot arguments. If it finds either, it retrieves its value.
Figure 521. Doing the core work of finding the root device
// iokit/bsddev/IOKitBSDInit.cpp
kern_return_t
IOFindBSDRoot(char *rootName, dev_t *root, u_int32_t *oflags)
{
...
IOService *service;
IORegistryEntry *regEntry;
OSDictionary *matching = 0;
...
OSData *data = 0;
...
UInt32 flags = 0;
int minor, major;
bool findHFSChild = false;
char *mediaProperty = 0;
char *rdBootVar;
char *str;
const char *look = 0;
...
bool forceNet = false;
...
const char *uuidStr = NULL;
static int mountAttempts = 0;
enum { kMaxPathBuf = 512, kMaxBootVar = 128 };
...
if (mountAttempts++)
IOSleep(5 * 1000);
// allocate memory for holding the root device path
str = (char *)IOMalloc(kMaxPathBuf + kMaxBootVar);
if (!str)
return (kIOReturnNoMemory);
rdBootVar = str + kMaxPathBuf;
if (!PE_parse_boot_arg("rd", rdBootVar )
&& !PE_parse_boot_arg("rootdev", rdBootVar ))
rdBootVar[0] = 0;
...
}
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh90B0.htm 20.08.2007
Chapter 5. Kernel and User-Level Startup Page 38 of 59