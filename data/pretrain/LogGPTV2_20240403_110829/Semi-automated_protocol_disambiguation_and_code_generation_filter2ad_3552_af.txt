[6] Beckett, R., Mahajan, R., Millstein, T., Padhye, J., and Walker, D.
Network configuration synthesis with abstract topologies. SIGPLAN
Not. 52, 6 (June 2017), 437–451.
[7] Berant, J., Chou, A., Frostig, R., and Liang, P. Semantic parsing
on freebase from question-answer pairs. In Proceedings of the 2013
conference on empirical methods in natural language processing (2013),
pp. 1533–1544.
[8] Bertero, C., Roy, M., Sauvanaud, C., and Trédan, G. Experience
report: Log mining using natural language processing and application
to anomaly detection. In 2017 IEEE 28th International Symposium on
Software Reliability Engineering (ISSRE) (2017), IEEE, pp. 351–360.
[9] Bhargavan, K., Obradovic, D., and Gunter, C. A. Formal verification
of standards for distance vector routing protocols. Journal of the ACM
(JACM) 49, 4 (2002), 538–576.
[10] Bishop, S., Fairbairn, M., Norrish, M., Sewell, P., Smith, M., and
Wansbrough, K. Rigorous specification and conformance testing tech-
niques for network protocols, as applied to tcp, udp, and sockets. In
13
Proceedings of the 2005 conference on Applications, technologies, architec-
tures, and protocols for computer communications (2005), pp. 265–276.
[11] Bolognesi, T., and Brinksma, E. Introduction to the iso specification
language lotos. Computer Networks and ISDN systems 14, 1 (1987).
[12] Boussinot, F., and De Simone, R. The esterel language. Proceedings
of the IEEE 79, 9 (1991), 1293–1304.
bake2.html.
[32] Jethanandani, M., Agarwal, S., Huang, L., and Blair, D. YANG
Data Model for Network Access Control Lists (ACLs). RFC 8519, 2019.
[13] Budkowski, S., and Dembinski, P. An introduction to estelle: a spec-
ification language for distributed systems. Computer Networks and
ISDN systems 14, 1 (1987), 3–23.
[14] Chen, D. L., and Mooney, R. J. Learning to interpret natural language
In Twenty-Fifth AAAI
navigation instructions from observations.
Conference on Artificial Intelligence (2011).
[15] Clark, D. D. A cloudy crystal ball: visions of the future. Proceedings
of the Twenty-Fourth Internet Engineering Task Force (1992), 539–544.
[16] D. Harkins, E. Secure Password Ciphersuites for Transport Layer
Security (TLS). RFC 8492, 2019.
[17] Date, C. J. A Guide to the SQL Standard: A User’s Guide to the Standard
Relational Language SQL. Addison-Wesley Longman Publishing Co.,
Inc., USA, 1987.
[18] Deering, D. S. E. Host extensions for IP multicasting. RFC 1112, 1989.
[19] Devlin, J., Chang, M.-W., Lee, K., and Toutanova, K. Bert: Pre-
training of deep bidirectional transformers for language understanding.
arXiv preprint arXiv:1810.04805 (2018).
[20] Dong, L., and Lapata, M. Coarse-to-fine decoding for neural semantic
parsing. arXiv preprint arXiv:1805.04793 (2018).
[21] Editor, R., and Flanagan, H. RFC Style Guide. RFC 7322, Sept. 2014.
[22] Feng, Z., Guo, D., Tang, D., Duan, N., Feng, X., Gong, M., Shou, L.,
Qin, B., Liu, T., Jiang, D., and Zhou, M. Codebert: A pre-trained
model for programming and natural languages. ArXiv abs/2002.08155
(2020).
[23] Feser, J. K., Chaudhuri, S., and Dillig, I. Synthesizing data structure
transformations from input-output examples. ACM SIGPLAN Notices
50, 6 (2015), 229–239.
[24] Fu, Q., Lou, J.-G., Wang, Y., and Li, J. Execution anomaly detection in
distributed systems through unstructured log analysis. In 2009 ninth
IEEE international conference on data mining (2009), IEEE, pp. 149–158.
[25] Gao, X., Kim, T., Wong, M. D., Raghunathan, D., Varma, A. K., Kan-
nan, P. G., Sivaraman, A., Narayana, S., and Gupta, A. Switch code
generation using program synthesis.
In Proceedings of the Annual
Conference of the ACM Special Interest Group on Data Communica-
tion on the Applications, Technologies, Architectures, and Protocols for
Computer Communication (New York, NY, USA, 2020), SIGCOMM ’20,
Association for Computing Machinery, p. 44–61.
[26] Group, S. N. Corenlp coreference resolution. https://stanfordnlp.
github.io/CoreNLP/coref.html.
[27] Hockenmaier, J., and Bisk, Y. Normal-form parsing for combinatory
categorial grammars with generalized composition and type-raising.
In Proceedings of the 23rd International Conference on Computational
Linguistics (Coling 2010) (Beijing, China, Aug. 2010), Coling 2010 Or-
ganizing Committee, pp. 465–473.
[28] Honnibal, M., and Montani, I. spaCy 2: Natural language under-
standing with Bloom embeddings, convolutional neural networks and
incremental parsing. To appear, 2017.
[29] Hutchinson, N. C., and Peterson, L. L. The x-kernel: An architecture
for implementing network protocols. IEEE Transactions on Software
engineering, 1 (1991), 64–76.
[30] Institute, A. A. AllenNLP Coreference Resolution. https://demo.
allennlp.org/coreference-resolution.
[31] Ipp interoperability testing event #2. http://www.pwg.org/ipp/testing/
arXiv:1812.00978 (2018).
RFC 5880, 2010.
[34] Katz, D., and Ward, D. Bidirectional Forwarding Detection (BFD).
[35] Kempson, R. M., and Cormack, A. Ambiguity and quantification.
Linguistics and Philosophy 4, 2 (1981), 259–309.
[36] Kessens, D., Bates, T. J., Alaettinoglu, C., Meyer, D., Villamizar,
C., Terpstra, M., Karrenberg, D., and Gerich, E. P. Routing Policy
Specification Language (RPSL). RFC 2622, June 1999.
[37] Killian, C., Anderson, J. W., Jhala, R., and Vahdat, A. Life, death,
and the critical transition: Finding liveness bugs in systems code. In 4th
USENIX Symposium on Networked Systems Design & Implementation
(NSDI 07) (2007), NSDI, USENIX Association.
[38] Killian, C. E., Anderson, J. W., Braud, R., Jhala, R., and Vahdat,
A. M. Mace: language support for building distributed systems. ACM
SIGPLAN Notices 42, 6 (2007), 179–188.
[39] Kohler, E., Kaashoek, M. F., and Montgomery, D. R. A readable
tcp in the prolac protocol language. In Proceedings of the conference
on Applications, technologies, architectures, and protocols for computer
communication (1999), pp. 3–13.
[40] Krishnamurthy, J., Dasigi, P., and Gardner, M. Neural semantic
parsing with type constraints for semi-structured tables. In Proceed-
ings of the 2017 Conference on Empirical Methods in Natural Language
Processing (2017), pp. 1516–1526.
[41] Kurose, J., and Ross, K. Computer networking: A top down approach,
2012.
[42] Lan, Z., Chen, M., Goodman, S., Gimpel, K., Sharma, P., and Sori-
cut, R. Albert: A lite bert for self-supervised learning of language
representations. arXiv preprint arXiv:1909.11942 (2019).
[43] Lantz, B., Heller, B., and McKeown, N. A network in a laptop: rapid
prototyping for software-defined networks. In Proceedings of the 9th
ACM SIGCOMM Workshop on Hot Topics in Networks (2010), pp. 1–6.
[44] Lee, H., Seibert, J., Killian, C. E., and Nita-Rotaru, C. Gatling:
Automatic attack discovery in large-scale distributed systems. In NDSS
(2012).
[45] Liang, C., Berant, J., Le, Q., Forbus, K. D., and Lao, N. Neural
symbolic machines: Learning semantic parsers on freebase with weak
supervision. arXiv preprint arXiv:1611.00020 (2016).
[46] Lin, X. V., Wang, C., Pang, D., Vu, K., and Ernst, M. D. Program
synthesis from natural language using recurrent neural networks. Uni-
versity of Washington Department of Computer Science and Engineering,
Seattle, WA, USA, Tech. Rep. UW-CSE-17-03-01 (2017).
[47] Ling, W., Grefenstette, E., Hermann, K. M., Kočisk`y, T., Senior,
A., Wang, F., and Blunsom, P. Latent predictor networks for code
generation. arXiv preprint arXiv:1603.06744 (2016).
[48] Loper, E., and Bird, S. Nltk: the natural language toolkit. arXiv
preprint cs/0205028 (2002).
[49] McClurg, J., Hojjat, H., Čern`y, P., and Foster, N. Efficient synthesis
of network updates. Acm Sigplan Notices 50, 6 (2015), 196–207.
[50] McClurg, J., Hojjat, H., Foster, N., and Čern`y, P. Event-driven
network programming. ACM SIGPLAN Notices 51, 6 (2016), 369–385.
[51] McMillan, K. L., and Zuck, L. D. Formal specification and testing of
QUIC. In Proceedings of ACM SIGCOMM (2019).
[52] McQuistin, S., Band, V., Jacob, D., and Perkins, C. Parsing protocol
standards to parse standard protocols. In Proceedings of the Applied
Networking Research Workshop (New York, NY, USA, 2020), ANRW ’20,
Association for Computing Machinery, p. 25–31.
[53] Mills, D. Network Time Protocol (version 1) specification and imple-
mentation. RFC 1059, 1988.
[54] Monsanto, C., Reich, J., Foster, N., Rexford, J., and Walker, D.
Composing software defined networks. In 10th USENIX Symposium
on Networked Systems Design and Implementation (NSDI 13) (Lombard,
[33] Kamath, A., and Das, R. A survey on semantic parsing. arXiv preprint
IL, Apr. 2013), USENIX Association, pp. 1–13.
[55] Nagaraj, K., Killian, C., and Neville, J. Structured comparative
analysis of systems logs to diagnose performance problems. In Pre-
sented as part of the 9th {USENIX} Symposium on Networked Systems
Design and Implementation ({NSDI} 12) (2012), pp. 353–366.
[56] Osera, P.-M., and Zdancewic, S. Type-and-example-directed pro-
gram synthesis. ACM SIGPLAN Notices 50, 6 (2015), 619–630.
[57] Pedrosa, L., Fogel, A., Kothari, N., Govindan, R., Mahajan, R., and
Millstein, T. Analyzing protocol implementations for interoperabil-
ity. In 12th {USENIX} Symposium on Networked Systems Design and
Implementation ({NSDI} 15) (2015), pp. 485–498.
[58] Peters, M. E., Neumann, M., Iyyer, M., Gardner, M., Clark, C., Lee,
K., and Zettlemoyer, L. Deep contextualized word representations.
arXiv preprint arXiv:1802.05365 (2018).
[59] Piterman, N., Pnueli, A., and Sa’ar, Y. Synthesis of reactive (1)
designs. In International Workshop on Verification, Model Checking,
and Abstract Interpretation (2006), Springer, pp. 364–380.
[60] Pnueli, A., and Rosner, R. On the synthesis of a reactive module. In
Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles
of programming languages (1989), pp. 179–190.
[61] Postel, J. Internet Control Message Protocol. RFC 792, 1981.
[62] Rabinovich, M., Stern, M., and Klein, D. Abstract syntax net-
works for code generation and semantic parsing. arXiv preprint
arXiv:1704.07535 (2017).
[63] Radford, A., Wu, J., Child, R., Luan, D., Amodei, D., and Sutskever,
I. Language models are unsupervised multitask learners. OpenAI Blog
1, 8 (2019), 9.
[64] Rayner, K., and Duffy, S. A. Lexical complexity and fixation times
in reading: Effects of word frequency, verb complexity, and lexical
ambiguity. Memory & cognition 14, 3 (1986), 191–201.
[65] Rfc editor. http://www.rfc-editor.org/.
[66] S. Gueron, A. Langley, Y. L. AES-GCM-SIV: Nonce Misuse-Resistant
Authenticated Encryption. RFC 8452, 2019.
[67] Sidhu, D., and Chung, A. A formal description technique for protocol
engineering. University of Maryland at College Park, 1990.
[68] First sip interoperability test event. https://www.cs.columbia.edu/sip/
sipit/1/, 2008.
[69] Sipos, R., Fradkin, D., Moerchen, F., and Wang, Z. Log-based predic-
tive maintenance. In Proceedings of the 20th ACM SIGKDD international
conference on knowledge discovery and data mining (2014), pp. 1867–
1876.
[70] Srivastava, S., Gulwani, S., and Foster, J. S. From program verifi-
cation to program synthesis. In Proceedings of the 37th annual ACM
SIGPLAN-SIGACT symposium on Principles of programming languages
(2010), pp. 313–326.
[71] Srivastava, S., Labutov, I., and Mitchell, T. Joint concept learning
and semantic parsing from natural language explanations. In Proceed-
ings of the 2017 conference on empirical methods in natural language
processing (2017), pp. 1527–1536.
[72] Steedman, M., and Baldridge, J. Combinatory categorial grammar.
Non-Transformational Syntax: Formal and explicit models of grammar
(2011), 181–224.
[73] Tcpdump & libpcap public repository. https://www.tcpdump.org/.
Accessed: 2020-05-22.
[74] Tellex, S., Kollar, T., Dickerson, S., Walter, M. R., Banerjee, A. G.,
Teller, S., and Roy, N. Understanding natural language commands
for robotic navigation and mobile manipulation. In Twenty-fifth AAAI
conference on artificial intelligence (2011).
[75] Thomson, M. Example Handshake Traces for TLS 1.3. RFC 8448, 2019.
[76] Vaarandi, R. A data clustering algorithm for mining patterns from
event logs. In Proceedings of the 3rd IEEE Workshop on IP Operations &
14
Management (IPOM 2003)(IEEE Cat. No. 03EX764) (2003), IEEE, pp. 119–
126.
[77] von Bochmann, G. Methods and tools for the design and validation of
protocol specifications and implementations. Université de Montréal,
Département d’informatique et de recherche ..., 1987.
[78] Wang, S. I., Liang, P., and Manning, C. D. Learning language games
through interaction. arXiv preprint arXiv:1606.02447 (2016).
[79] Wang, Z., Qin, Y., Zhou, W., Yan, J., Ye, Q., Neves, L., Liu, Z., and
Ren, X. Learning from explanations with neural execution tree. In
International Conference on Learning Representations (2020).
[80] White, M., and Rajkumar, R. A more precise analysis of punctuation
for broad-coverage surface realization with ccg. In Coling 2008: Pro-
ceedings of the workshop on Grammar Engineering Across Frameworks
(2008), pp. 17–24.
[81] Xu, W., Huang, L., Fox, A., Patterson, D., and Jordan, M. I. Detecting
large-scale system problems by mining console logs. In Proceedings
of the ACM SIGOPS 22nd symposium on Operating systems principles
(2009), pp. 117–132.
[82] Yang, Z., Dai, Z., Yang, Y., Carbonell, J., Salakhutdinov, R. R., and
Le, Q. V. Xlnet: Generalized autoregressive pretraining for language
understanding. In Advances in neural information processing systems
(2019), pp. 5754–5764.
[83] Yin, P., and Neubig, G. A syntactic neural model for general-purpose
code generation. arXiv preprint arXiv:1704.01696 (2017).
[84] Yin, P., and Neubig, G. A syntactic neural model for general-purpose
code generation. In Proceedings of the 55th Annual Meeting of the Associ-
ation for Computational Linguistics (Volume 1: Long Papers) (Vancouver,
Canada, July 2017), Association for Computational Linguistics.
[85] Yin, P., Zhou, C., He, J., and Neubig, G. Structvae: Tree-structured
latent variable models for semi-supervised semantic parsing. arXiv
preprint arXiv:1806.07832 (2018).
[86] Zhang, S., Ma, X., Duh, K., and Durme, B. V. Amr parsing as sequence-
to-graph transduction. ArXiv abs/1905.08704 (2019).
[87] Zhang, S., Ma, X., Duh, K., and Durme, B. V. Broad-coverage semantic
parsing as transduction. In EMNLP/IJCNLP (2019).
APPENDIX
A ICMP Test Scenario Setup
Destination Unreachable Message. At the router/receiver
side, we assume the router only recognizes three subnets,
which are 10.0.1.1/24, 192.168.2.1/24, and 172.64.3.1/24. At the
sender side, we craft the packet with destination IP address
not belonging to any of the three subnets. The receiver reads
the packet and calls the generated function to construct the
destination unreachable message back to the sender.
Time Exceeded Message. At the sender side, we inten-
tionally generate a packet with the time-to-live field in IP
header set to 1, and the destination IP address set to server
1’s address. At the router side, the router checks the value of
time-to-live field and recognizes the packet cannot reach the
destination before the time-to-live field counts down to zero.
The router interface calls the generated function to construct
a time exceed message and sends it back to the client.
Parameter Problem Message. At the router side, we as-
sume the router can only handle IP packets in which the
type of service value equals to zero. At the sender side, we
modify the sent packet to set the type of service value to
one. The router interface recognizes the unsupported type
of service value and calls the generated function to construct
a parameter problem message back to the client.
Source Quench Message. At the receiver side, we assume
one outbound buffer is full, and therefore there is no space
to hold a new datagram. At the sender side, we generated a
packet to server 1. If there is still buffer space for the router
to forward the packet to server 1, the router should push
the packet to the outbound buffer connected to the subnet
where server 1 belongs to. Under this scenario, the router
will decide to discard the received packet, and construct a
source quench packet back to the client.
Redirect Message. At the sender side, the client generated
a packet to an IP address that is within the same subnet, but
sent to the router. The router discovered the next gateway
is in the same subnet as the sender host, and therefore con-
structs the redirect message to the client with the redirect
gateway address by calling the generated functions.
Echo and Echo Reply Message. In RFC 792, echo/echo
reply are explained together, but some sentences are merely
for echo while some are only for echo reply. After analysis,
sage generates two different pieces of code. One is specific to
the sender side, and the other is specific to the receiver side.
The client calls the generated function to construct an echo
message to the router interface. The router interface finds
15
Figure 7: Constructing one logical form from: “For computing the checksum, the checksum should be zero” with CCG.
it is the destination and constructs an echo reply message
back to the client by calling the receiver code.
Timestamp and Timestamp Reply Message. The sender
and receiver behavior in this scenario is identical to echo/e-
cho reply. The sender sends a packet by calling the generated
function and the receiver matches the ICMP type and replies
to packets with the generated function. The difference lies
in the packet generated by the function. The timestamp or
timestamp reply message do not have datagram data, but
they have three different timestamp fields in its header. The
generated function correctly separates three different times-
tamps with respect to the roles and computation time.
Information Request and Reply Message. The sender
and receiver behavior of this scenario is the same as echo/e-
cho reply and timestamp/timestamp reply. Similar to times-
tamp/timestamp reply, the differences lie in the generated
packets that do not have data; the field values are different.
B CCG Parsing Example
We show a more complex example, of deriving one final log-
ical form from the sentence: “For computing the checksum,
the checksum should be zero.” in Figure 7. First, each word in
the sentence is mapped to its lexical entries (e.g., checksum
→ NP: "checksum"). Multiple lexical entries may be available
for one word; in this case we make multiple attempts to parse
the whole sentence with each entry. After this step, the CCG
parsing algorithm automatically applies combination rules
and derives final logical forms for the whole sentence.
16
S\NP  λ(S/S)/NP 𝛌λNPNP/NPλNP/NP λNPS/SλNP/NP λ$TheNP$ModalVerb(S\NP)/(S\NP)λ(S\NP)/NPλλ𝐱NPNPNPS/S  λS\NP  λSSSFor$Forcomputing$Computethe$Thechecksum“checksum”$Punctuate,thechecksum“checksum”shouldbe$Iszero.“0”