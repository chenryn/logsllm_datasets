+ Advdual-PRF-sec
HKDF.Extract,B11
.
Game B4 (random CAHTS, SAHTS, dAHS). In this game, in ses-
sion ğœ‹, we replace the values CAHTS, SAHTS, and dAHS with
uniformly random values. Additionally, in any sessions ğœ‹â€² of ğ‘‰
which received the same ctğ‘† that was sent in ğœ‹, we replace CAHTS,
SAHTS, and dAHS with independent uniformly random values. All
values derived from dAHS in these sessions use the newly random-
ized values.
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B12 against the PRF security of HKDF.Expand
as follows.
When B12 needs to compute CAHTS, SAHTS, or dAHS in ğœ‹ or in
any of the sessions of ğ‘‰ that received the same ctğ‘† that was sent in ğœ‹,
it queries its HKDF.Expand challenge oracle on the corresponding
labels and transcripts, and uses the responses. If the responses were
the real output, then B12 has exactly simulated ğºğµ3 to A1; if the
responses were random values, then B12 has exactly simulated ğºğµ4
to A1. Note in particular that while there may be Reveal queries
to CAHTS or SAHTS values in sessions at ğ‘‰ that used the same
ctğ‘† as in ğœ‹, previous game ğº1 ensures that other sessions at ğ‘‰ use
different nonces ğ‘Ÿğ‘ , and thus have different transcripts (and game
ğº2 ensures distinct transcripts give distinct transcript hashes), so
our simulation remains valid even in the face of Reveal queries to
sessions of ğ‘‰ . Thus:
Advğºğµ3A1 â‰¤ Advğºğµ4A1
+ AdvPRF-sec
HKDF.Expand,B12
.
master secret MS with a uniformly random (cid:102)MS. Additionally, in
The stage 3 and 4 keys CAHTS and SAHTS in ğœ‹ are now uni-
formly random strings independent of everything else in the game.
Thus, the stage 3 and 4 keys have been shown to have wfs2 security.
Game B5 (random MS). In this game, in session ğœ‹, we replace the
any sessions ğœ‹â€² of ğ‘‰ which received the same ctğ‘† that was sent in
ğœ‹, we replace MS with an independent uniformly random value. All
values derived from MS in these sessions use the newly randomized
values.
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B13 against the PRF security of HKDF.Extract
in its first argument as follows (which we view as â€œdual PRF securityâ€
of HKDF.Extract).
When B13 needs to compute MS in ğœ‹ or in any of the sessions
of ğ‘‰ which received the same ctğ‘† that was sent in ğœ‹, it queries its
HKDF.Extract challenge oracle on âˆ… and uses the response as MS. If
the HKDF.Extract challenge oracle was returning real values, then
B13 has exactly simulated ğºğµ4 to A1; if it was returning random
values, then B13 has exactly simulated ğºğµ5 to A1. Thus:
Advğºğµ4A1 â‰¤ Advğºğµ5A1
+ Advdual-PRF-sec
HKDF.Extract,B13
.
Game B6 (random CATS, fkğ’„, fkğ’”). In this game, in session ğœ‹, we
replace the value CATS, fkğ‘, and fkğ‘  with uniformly random values.
Additionally, in any sessions ğœ‹â€² of ğ‘‰ which received the same ctğ‘†
that was sent in ğœ‹, we replace CATS, fkğ‘, and fkğ‘  with independent
uniformly random values.
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B14 against the PRF security of HKDF.Expand
as follows.
When B14 needs to compute CATS, fkğ‘, or fkğ‘  in ğœ‹ or in any of
the sessions of ğµ that received the same ctğ‘† that was sent in ğœ‹, it
queries its HKDF.Expand challenge oracle on the corresponding
label and transcript, and uses the response. If the responses were
the real output, then B14 has exactly simulated ğºğµ5 to A1; if the
response were random values, then B14 has exactly simulated ğºğµ6
to A1. Note in particular that while there may be Reveal queries
to CATS values in sessions at ğ‘‰ that used the same ctğ‘† as in ğœ‹,
previous game ğº1 ensures that other sessions at ğ‘‰ use different
nonces ğ‘Ÿğ‘ , and thus have different transcripts (and game ğº2 ensures
distinct transcripts give distinct transcript hashes), so our simula-
tion remains valid even in the face of Reveal queries to sessions of
ğ‘‰ . Thus:
Advğºğµ5A1 â‰¤ Advğºğµ6A1
+ AdvPRF-sec
HKDF.Expand,B14
.
Post-Quantum TLS Without Handshake Signatures
CCS â€™20, November 9â€“13, 2020, Virtual Event, USA
The stage 5 key CATS in ğœ‹ is now a uniformly random string
independent of everything else in the game. Thus, the stage 5 key
has been shown to have wfs2 security.
Game B7 (random SATS). In this game, in session ğœ‹, we replace
the value SATS with a uniformly random value. Additionally, in
any sessions ğœ‹â€² of ğ‘‰ which received the same ctğ‘† that was sent in
ğœ‹, we replace SATS with an independent uniformly random value.
Any adversary A1 that can detect this change can be used to con-
struct a distinguisher B15 against the PRF security of HKDF.Expand
as follows.
When B15 needs to compute SATS in ğœ‹ or in any of the sessions
of ğµ that received the same ctğ‘† that was sent in ğœ‹, it queries its
HKDF.Expand challenge oracle on the corresponding label and
transcript, and uses the response. If the responses were the real
output, then B15 has exactly simulated ğºğµ6 to A1; if the response
were random values, then B15 has exactly simulated ğºğµ7 to A1.
Note in particular that while there may be Reveal queries to SATS
values in sessions at ğ‘‰ that used the same ctğ‘† as in ğœ‹, previous game
ğº1 ensures that other sessions at ğ‘‰ use different nonces ğ‘Ÿğ‘ , and thus
have different transcripts (and game ğº2 ensures distinct transcripts
give distinct transcript hashes), so our simulation remains valid
even in the face of Reveal queries to sessions of ğ‘‰ . Thus:
Advğºğµ6A1 â‰¤ Advğºğµ7A1
+ AdvPRF-sec
HKDF.Expand,B15
.
The stage 6 key SATS in ğœ‹ is now a uniformly random string
independent of everything else in the game. Thus, the stage 6 key
has been shown to have wfs2 security.
Analysis of game B7. In game B7, all stage keys in the tested
session are uniformly random and independent of all messages
in the game, so the hidden bit ğ‘ used in the tested session is now
= 0.
independent all information sent to the adversary. Thus Advğºğµ7A1
This concludes case B, yielding:
(cid:170)(cid:174)(cid:174)(cid:174)(cid:172) .
AdvğºğµA1 â‰¤ ğ‘›ğ‘¢
(cid:169)(cid:173)(cid:173)(cid:173)(cid:171)
+ Advdual-PRF-sec
HKDF.Extract,B11
AdvIND-CCA
KEMs,B10
+ AdvPRF-sec
HKDF.Expand,B12
+ AdvPRF-sec
HKDF.Expand,B14
+ Advdual-PRF-sec
+ AdvPRF-sec
HKDF.Extract,B13
HKDF.Expand,B15
Case C: No contributive partner, peer not
corrupted before acceptance
Case C differs from Case B when the intended peer ğ‘‰ of the tested
session ğœ‹ was corrupted after the tested session accepted.
As in case B, stages aiming for wfs1 are outside the scope of this
case, so we can assume the tested session is a client session.
In this case we will start by repeating the same sequence of
games as in case B. However, the replacement of the static KEM
in the reduction B10 for game B2 is problematic, as in case C the
adversary may make a Corrupt(ğ‘‰ ) query after the target session
accepts, but our reduction B10 will be unable to answer that query
consistently.
We will show that, under the additional assumption that the
MAC used for the ServerFinished message is secure, there are in
fact no sessions that accept under the conditions of case C. In other
words, no client session can be made to maliciously accept at stage
6. Consequently, if a client session has accepted in stage 6, then in
fact the session has a partner at stage 6, and thus at all previous
stages. From this we can make two conclusions. First, once stage 6
accepts, all stages are retroactively authenticated. Moreover, by the
argumentation in case A, all its stage keys are indistinguishable to
an adversary (even an adversary who corrupts any long-term key).
This yields the retroactive fs security of all stage keys.
Our task then in case C is to bound the probability of a malicious
acceptance in stage 6 of the tested session.
Game C1 (guess peer). This game is identical to game B1, in which
the identity of the intended peer of the tested session is guessed.
Thus,
Advğºğ¶A1 â‰¤ ğ‘›ğ‘¢ Â· Advğºğ¶1A1
.
Let bad mark the event that C1 accepts in stage 6 of the (fresh)
tested client session without a partner session at stage 6.
Game C2 (identical-until-bad). This game is identical to game
C1, with the additional condition that the game aborts if bad occurs.
Games C1 and C2 are identical-until-bad [7]. Thus,
|Pr [ğºğ¶1 â‡’ 1] âˆ’ Pr [ğºğ¶2 â‡’ 1]| â‰¤ Pr [ğºğ¶2 reaches bad] .
Trivially,
Advğºğ¶2A1
= 0.
Our goal for the rest of this case is to bound Pr [ğºğ¶2 reaches bad].
Games C3 through C8 are the same as games B2 through B7 in
case B, with the additional condition that the game aborts if bad
occurs.
Game C3 (long-term KEM). This game is identical to game B2,
in which the static shared secret ssğ‘† is replaced with a uniformly
random value, with the additional condition that the game aborts if
bad occurs. Using the same reduction B10 as for game B2 but with
the reduction aborting if bad occurs, we have
Pr [ğºğ¶2 reaches bad] â‰¤ Pr [ğºğ¶3 reaches bad] + AdvIND-CCA
KEMe,B10
Note that this avoids the problem mentioned at the start of the case
regarding the reduction needing to simulate answers to Corrupt(ğ‘‰ ),
since any such queries would happen after bad occurs.
Game C4 (random AHS). This game is identical to game B3, in
which the secret AHS is replaced with a uniformly random value,
with the additional condition that the game aborts if bad occurs.
Using the same reduction B11 as for game B3 but with the reduction
aborting if bad occurs, we have
Pr [ğºğ¶3 reaches bad] â‰¤ Pr [ğºğ¶4 reaches bad]+Advdual-PRF-sec
HKDF.Extract,B11
Game C5 (random CAHTS, SAHTS, dAHS). This game is identi-
cal to game B4, in which CAHTS, SAHTS, and dAHS are replaced
with uniformly random values, with the additional condition that
the game aborts if bad occurs. Using the same reduction B12 as for
game B4 but with the reduction aborting if bad occurs, we have
Pr [ğºğ¶4 reaches bad] â‰¤ Pr [ğºğ¶5 reaches bad]+AdvPRF-sec
HKDF.Expand,B12
Game C6 (random MS). This game is identical to game B5, in
which the master secret MS is replaced with a uniformly random
value, with the additional condition that the game aborts if bad
occurs. Using the same reduction B13 as for game B5 but with the
reduction aborting if bad occurs, we have
Pr [ğºğ¶5 reaches bad] â‰¤ Pr [ğºğ¶6 reaches bad]+Advdual-PRF-sec
HKDF.Extract,B13
CCS â€™20, November 9â€“13, 2020, Virtual Event, USA
Game C7 (random CATS, fkğ’„, fkğ’”). This game is identical to
game B6, in which CATS, fkğ‘, and fkğ‘  are replaced with uniformly
random values, with the additional condition that the game aborts
if bad occurs. Using the same reduction B14 as for game B6 but
with the reduction aborting if bad occurs, we have
Pr [ğºğ¶6 reaches bad] â‰¤ Pr [ğºğ¶7 reaches bad]+AdvPRF-sec
HKDF.Expand,B14
Game C8 (random SATS). This game is identical to game B7, in
which SATS is replaced with a uniformly random value, with the
additional condition that the game aborts if bad occurs. Using the
same reduction B15 as for game B7 but with the reduction aborting
if bad occurs, we have
Pr [ğºğ¶7 reaches bad] â‰¤ Pr [ğºğ¶8 reaches bad]+AdvPRF-sec
HKDF.Expand,B15
Game C9 (HMAC forgery). In this game, in session ğœ‹, we reject
upon receiving the ServerFinished message.
Any adversary that behaves differently in game C9 compared
to game C8 can be used to construct an HMAC forger B16. In
particular, notice that games C9 and C8 only behave differently if
the SF the client received should have been accepted as a valid MAC
tag, but was in fact rejected. Since no partner session to ğœ‹ at stage
6 exists, no honest server session has the same session identifier
as ğœ‹ at stage 6, and thus also not the same transcript. So no honest
server session ever created a MAC tag for the transcript that the
client verified. The client, therefore received a forgery. Thus,
Pr [ğºğ¶8 reaches bad] â‰¤ Pr [ğºğ¶9 reaches bad] + AdvEUF-CMA
HMAC,B16
Analysis of game C9. Since game C9 rejects all SF messages, it
never reaches the bad event. Thus:
Pr [ğºğ¶9 reaches bad] = 0
This concludes case C, yielding:
(cid:169)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:171)
AdvIND-CCA
KEMs,B10
+ AdvPRF-sec
HKDF.Expand,B12
+ AdvPRF-sec
HKDF.Expand,B14
+ AdvEUF-CMA
HMAC,B16
+ Advdual-PRF-sec
HKDF.Extract,B11
+ Advdual-PRF-sec
+ AdvPRF-sec
HKDF.Extract,B13
HKDF.Expand,B15
(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172) .
Advğºğ¶A1 â‰¤ ğ‘›ğ‘¢
Combining the bounds in cases A, B, and C yields the theorem.
â–¡
C CLIENT-AUTHENTICATION IN KEMTLS
Although perhaps not used much for web browsing, client authen-
tication is an important optional feature of the TLS handshake. In
TLS 1.3 a server can send the client a CertificateRequest mes-
sage. The client replies with its certificate in a ClientCertificate
message and a ClientCertificateVerify message containing a
signature. This allows mutual authentication.
In this section, we show how to extend KEMTLS to provide client
authentication. Fig. 7 adds a client authentication message flow to
KEMTLS.
Recall that we assume that the client does not have the serverâ€™s
certificate when initiating the handshake, and similarly the server
does not have the clientâ€™s certificate in advance. There may be more
efficient message flows possible if this is the case, which we leave
as future work.
Client
TCP SYN
TCP SYN-ACK
Schwabe, Stebila, Wiggers
Server
(pkğ‘’, skğ‘’)â†KEMe.Keygen()
ClientHello: pkğ‘’, ğ‘Ÿğ‘ â†$ {0, 1}256, supported algs.
ESâ†HKDF.Extract(0, 0)
dESâ†HKDF.Extract(ES, "derived", âˆ…)
(ssğ‘’, ctğ‘’)â†KEMe.Encapsulate(pkğ‘’)
ServerHello: ctğ‘’, ğ‘Ÿğ‘  â†$ {0, 1}256, selected algs.
ssğ‘’â†KEMe.Decapsulate(ctğ‘’, skğ‘’)
HSâ†HKDF.Extract(dES, ssğ‘’)
accept CHTSâ†HKDF.Expand(HS, "c hs traffic", CH..SH)
accept SHTSâ†HKDF.Expand(HS, "s hs traffic", CH..SH)
dHSâ†HKDF.Expand(HS, "derived", âˆ…)
{EncryptedExtensions}ğ‘ ğ‘¡ğ‘ğ‘”ğ‘’2
{ServerCertificate}ğ‘ ğ‘¡ğ‘ğ‘”ğ‘’2: cert[pkğ‘†], int. CA cert.
{CertificateRequest}ğ‘ ğ‘¡ğ‘ğ‘”ğ‘’2
(ssğ‘†, ctğ‘†)â†KEMs.Encapsulate(pkğ‘†)
{ClientKemCiphertext}ğ‘ ğ‘¡ğ‘ğ‘”ğ‘’1: ctğ‘†
ssğ‘† â†KEMs.Decapsulate(ctğ‘†, skğ‘†)