in Computer Science, pp. 239–260, Springer, 2015.
[18] E. Y. Chen, Y. Pei, S. Chen, Y. Tian, R. Kotcher, and P. Tague, “OAuth
Demystiﬁed for Mobile Application Developers,” in Proceedings of
the 2014 ACM SIGSAC Conference on Computer and Communications
Security - CCS ’14, pp. 892–903, 2014.
[19] M. Shehab and F. Mohsen, “Towards Enhancing the Security of
OAuth Implementations in Smart Phones,” in 2014 IEEE International
Conference on Mobile Services, Institute of Electrical & Electronics
Engineers (IEEE), 6 2014.
[20] W. Li and C. J. Mitchell, “Analysing the Security of Google’s Imple-
mentation of OpenID Connect,” in Proceedings of the 13th International
Conference on Detection of Intrusions and Malware, and Vulnerability
Assessment (DIMVA), vol. 9721, pp. 357–376, 2016.
[21] V. Mladenov, C. Mainka, J. Krautwald, F. Feldmann, and J. Schwenk,
“On the security of modern Single Sign-On Protocols: Second-Order
Vulnerabilities in OpenID Connect,” CoRR, vol. abs/1508.04324v2, 2016.
[22] D. Fett, R. Küsters, and G. Schmitz, “An Expressive Model for the
Web Infrastructure: Deﬁnition and Application to the BrowserID SSO
System,” in 35th IEEE Symposium on Security and Privacy (S&P 2014),
pp. 673–688, IEEE Computer Society, 2014.
[23] D. Fett, R. Küsters, and G. Schmitz, “SPRESSO: A Secure, Privacy-
Respecting Single Sign-On System for the Web,” in Proceedings of
the 22nd ACM SIGSAC Conference on Computer and Communications
Security, Denver, CO, USA, October 12-6, 2015, pp. 1358–1369, ACM,
2015.
[24] D. Fett, R. Küsters, and G. Schmitz, “Analyzing the BrowserID SSO
System with Primary Identity Providers Using an Expressive Model of
the Web,” in Computer Security - ESORICS 2015 - 20th European Sym-
posium on Research in Computer Security, Vienna, Austria, September
21-25, 2015, Proceedings, Part I, vol. 9326 of Lecture Notes in Computer
Science, pp. 43–65, Springer, 2015.
[25] D. Fett, P. Hosseyni, and R. Küsters, “An Extensive Formal Se-
curity Analysis of
the OpenID Financial-grade API,” Tech. Rep.
arXiv:1901.11520, arXiv, 2019. Available at http://arxiv.org/abs/1901.
11520.
[26] D. Hardt (ed.), “RFC6749 – The OAuth 2.0 Authorization Framework.”
IETF. Oct. 2012. https://tools.ietf.org/html/rfc6749.
[27] N. Sakimura, J. Bradley, M. Jones, B. de Medeiros, and C. Mortimore,
“OpenID Connect Core 1.0 incorporating errata set 1.” OpenID Foun-
dation. Nov. 8, 2014. http://openid.net/specs/openid-connect-core-1_0.
html.
[28] J. Richer (ed.), “RFC7662 – OAuth 2.0 Token Introspection.” IETF. Oct.
2015. https://tools.ietf.org/html/rfc7662.
[29] N. Sakimura (Ed.), J. Bradley, and N. Agarwal, “Proof Key for Code
Exchange by OAuth Public Clients.” RFC 7636 (Proposed Standard),
Sept. 2015.
[30] W. Denniss and J. Bradley, “OAuth 2.0 for Native Apps,” RFC, vol. 8252,
pp. 1–21, 2017.
[31] M. Jones, J. Bradley, and N. Sakimura, “RFC7519 – JSON Web Token
(JWT).” IETF. May 2015. https://tools.ietf.org/html/rfc7519.
[32] M. Jones, J. Bradley, and N. Sakimura, “RFC7515 – JSON Web
Signature (JWS).” IETF. May 2015. https://tools.ietf.org/html/rfc7515.
[33] B. Campbell, J. Bradley, N. Sakimura, and T. Lodderstedt, “OAuth 2.0
Mutual TLS Client Authentication and Certiﬁcate Bound Access Tokens,”
Internet-Draft draft-ietf-oauth-mtls-09, Internet Engineering Task Force,
June 2018. Work in Progress.
[34] M. Jones, B. Campbell, J. Bradley, and W. Denniss, “OAuth 2.0 Token
https://www.ietf.org/id/
Binding - draft-ietf-oauth-token-binding-07.”
draft-ietf-oauth-token-binding-07.txt.
[35] A. Popov, M. Nystrom, D. Balfanz, A. Langley, and J. Hodges, “The
Token Binding Protocol Version 1.0.” RFC 8471, Oct. 2018.
[36] A. Popov, M. Nystrom, D. Balfanz, and A. Langley, “Transport Layer
Security (TLS) Extension for Token Binding Protocol Negotiation.” RFC
8472, Oct. 2018.
[37] A. Popov, M. Nystrom, D. Balfanz, A. Langley, N. Harper, and J. Hodges,
“Token Binding over HTTP.” RFC 8473, Oct. 2018.
[38] E. Rescorla, “Keying Material Exporters for Transport Layer Security
(TLS).” RFC 5705, Mar. 2010.
[39] A. Popov, M. Nystrom, D. Balfanz, A. Langley, N. Harper, and J. Hodges,
“Token Binding over HTTP,” internet-draft, Internet Engineering Task
Force, June 2018. Work in Progress.
[40] T. Lodderstedt (ed.), “JWT Secured Authorization Response Mode
for OAuth 2.0 (JARM).” Aug. 23, 2018. https://bitbucket.org/openid/
fapi/src/ceb0f829bc532e9c540efaa94f6f96d007371ca2/Financial_API_
JWT_Secured_Authorization_Response_Mode.md.
[41] OpenID Financial-grade API Working Group, “Financial API - Part
1: Read-Only API Security Proﬁle.” Aug. 23, 2018. https://bitbucket.
(cid:21)(cid:23)(cid:24)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:17 UTC from IEEE Xplore.  Restrictions apply. 
org/openid/fapi/src/ceb0f829bc532e9c540efaa94f6f96d007371ca2/
Financial_API_WD_001.md.
[42] T. Lodderstedt, J. Bradley, A. Labunets, and D. Fett, “OAuth 2.0 Security
Best Current Practice,” 10 2018. https://tools.ietf.org/html/draft-ietf-
oauth-security-topics.
[43] OpenID Financial-grade API Working Group, “Financial API - Part 2:
Read and Write API Security Proﬁle.” Aug. 23, 2018. https://bitbucket.
org/openid/fapi/src/ceb0f829bc532e9c540efaa94f6f96d007371ca2/
Financial_API_WD_002.md.
[44] T. Lodderstedt (ed.), M. McGloin, and P. Hunt, “RFC6819 – OAuth
2.0 Threat Model and Security Considerations.” IETF. Jan. 2013. https:
//tools.ietf.org/html/rfc6819.
[45] D. Fett, R. Küsters, and G. Schmitz, “The Web SSO Standard OpenID
Connect: In-Depth Formal Analysis and Security Guidelines,” Tech. Rep.
arXiv:1704.08539, arXiv, 2017. Available at http://arxiv.org/abs/1704.
08539.
[46] M. Abadi and C. Fournet, “Mobile Values, New Names, and Secure
Communication,” in Proceedings of
the 28th ACM Symposium on
Principles of Programming Languages (POPL 2001), pp. 104–115, ACM
Press, 2001.
[47] A. Barth and M. West, “Cookies: HTTP State Management Mechanism.”
https://httpwg.org/http-extensions/rfc6265bis.html.
APPENDIX A
AUTHORIZATION REQUEST LEAK ATTACK – DETAILS
We here provide further details about the authorization
request leak attack, which was only sketched in Section IV-D.
A concrete instantiation of this attack is shown in Figure 7,
where the scenario is based on the Read-Only ﬂow of a public
client. As explained below, similar attacks also work for all
other conﬁgurations of the FAPI (except for web server clients
which use OAUTB, for which, as mentioned, we show that
they are not susceptible in Section V).
In the Authorization Request Leak Attack, the client sends
the authorization request to the browser in Step 2 , where it
leaks to the attacker in Step 3 . From here on, the attacker
behaves as the browser and logs himself in (Step 5 ), hence,
is associated with
the authorization code received in Step 6
the identity of the attacker.
The state value used in the authorization request aims
at preventing Cross-Site Request Forgery (CSRF) attacks.
However, as the state value leaks, this protection does not
work. For showing that this is the case, we assume that a CSRF
attack happens. If, for example, the user is visiting a website
that is controlled by the attacker, then the attacker can send,
from the browser of the user, a request to the AS containing
the code and the state value (Step 8 ). As the state received
by the client is the same that it included in the authorization
request, the client continues the ﬂow and uses the code to
retrieve an access token in Steps 9 and 10 .
This access token is associated with the attacker, which
means that the honest user is accessing resources belonging to
the attacker.
As a result, the honest user can be logged in under the
identity of the attacker if the authorization server returns an
id token. In the case of the Read-Write ﬂow, the honest user
can modify resources of the attacker: for example, she might
upload personal documents to the account of the attacker.
As noted above, this attack might happen for all conﬁgura-
tions, except for the Read-Write ﬂow when the client is a web
server client using OAUTB (see Figure 3).
Browser
Attacker
Client
Authorization Server
1 POST /start
POST /start
2 Response
Response
Redirect to AS (client_id, redirect_uri, state)
Redirect to AS (client_id, redirect_uri, state)
3 Leakage
Leakage
(client_id, redirect_uri, state)
(client_id, redirect_uri, state)
4 GET /authorization_endpoint
GET /authorization_endpoint
(client_id, redirect_uri, state) (Authorization Request)
(client_id, redirect_uri, state) (Authorization Request)
5
attacker authenticates
attacker authenticates
Response
6 Response
Redirect to C (code, state)
Redirect to C (code, state)
7 CSRFCSRF
Redirect to C (code, state)
Redirect to C (code, state)
GET /redirect_uri
8 GET /redirect_uri
(code, state)
(code, state)
9 POST /token
POST /token
(code)
(code)
10 Response
Response
(access token)
(access token)
Browser
Attacker
Client
Authorization Server
Figure 7. Leakage of Authorization Request Attack
In all other conﬁgurations, this attack can happen as the
attacker can behave exactly like the browser of the honest
user, i.e., after receiving the authorization request, the attacker
can send this request to the AS, log in under his own identity,
and would then receive a response that the client accepts. The
only ﬂow in which this is different is the Read-Write ﬂow
where the client is a web server and uses OAUTB, as here,
the browser (and therefore, also the attacker) needs to prove
possession of a key pair (i.e., the key pair used for the client).
As the attacker cannot prove possession of the private key of
the key pair which the browser uses for the client, the AS
would then stop the ﬂow. (In the other ﬂows, the AS does not
check if the response was sent by the browser that logged in
the user.)
If we say that the FAPI is not required to be secure if the
authorization request leaks (i.e., if we remove the assumption
that the authorization request leaks), then the ﬂow is still not
secure, as the authorization response might still leak to the
attacker (see Section III-C1), which also contains the state
value. More precisely, the authorization response might leak
in the case of app clients due to the operating system sending
the response to the attacker app (for details, see Section II-B).
After receiving the authorization response, the attacker app
knows the state value and can start a new ﬂow using this
value. The attacker can then continue from Step 3 (Figure 7),
and when receiving the authorization response (which is a URI
(cid:21)(cid:23)(cid:25)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:17 UTC from IEEE Xplore.  Restrictions apply. 
containing the OAuth parameters), he could, using his own app
that runs on the device of the victim, call the legitimate client
app with this URI (i.e., with the code that is associated with the
identity of the attacker and the state value with which the client
started the ﬂow). The effect of this is that the legitimate app,
at which the honest user started the ﬂow, would continue the
ﬂow using an authorization code associated with the attacker.
Therefore, the honest user would either be logged in with the
identity of the attacker or use the resources of the attacker.
We note that even encrypting the state value contained
in the authorization request does not solve the problem, as
the attacker is using the whole authorization request. (Strictly
speaking, he acts as the browser of the honest user).
APPENDIX B
THE WIM: SOME BACKGROUND
We here provide more details about the Web Infrastructure
Model.
a) Signature and Messages: As mentioned, the WIM
follows the Dolev-Yao approach where messages are expressed
as formal terms over a signature Σ. For example, in the WIM
an HTTP request is represented as a term r containing a nonce,
an HTTP method, a domain name, a path, URI parameters,
request headers, and a message body. For instance, an HTTP
request for the URI http://ex.com/show?p=1 is represented
as r :=(cid:5)HTTPReq,n1, GET, ex.com, /show,(cid:5)(cid:5)p,1(cid:6)(cid:6),(cid:5)(cid:6),(cid:5)(cid:6)(cid:6) where
the body and the list of request headers is empty. An HTTPS
request for r is of the form enca((cid:5)r,k
(cid:2)(cid:6), pub(kex.com)), where
(cid:2)
is a fresh symmetric key (a nonce) generated by the sender
k
of the request (typically a browser); the responder is supposed
to use this key to encrypt the response.
The equational
theory associated with Σ is deﬁned as
usual in Dolev-Yao models. The theory induces a congru-
ence relation ≡ on terms, capturing the meaning of the
function symbols in Σ. For instance,
the equation in the
equational theory which captures asymmetric decryption is
deca(enca(x, pub(y)),y) = x. With this, we have that, for
(cid:2)(cid:6) , i.e.,
example, deca(enca((cid:5)r,k
these two terms are equivalent w.r.t. the equational theory.
(cid:2)(cid:6), pub(kex.com)),kex.com) ≡ (cid:5)r,k
b) Scripts: A script models JavaScript running in a
browser. Scripts are deﬁned similarly to Dolev-Yao processes.
When triggered by a browser, a script is provided with state
information. The script then outputs a term representing a new
internal state and a command to be interpreted by the browser
(see also the speciﬁcation of browsers below). Similarly to
an attacker process,
the so-called attacker script outputs
everything that is derivable from the input.
c) Running a system: As mentioned, a run of a system
is a sequence of conﬁgurations. The transition from one
conﬁguration to the next conﬁguration in a run is called
a processing step. We write, for example, Q = (S,E,N) −→
(cid:2),E
(cid:2)) to denote the transition from the conﬁguration
(S
(S,E,N) to the conﬁguration (S
are
the states of the processes in the system, E and E
are pools of
waiting events, and N and N
are sequences of unused nonces.
(cid:2)), where S and S
(cid:2),N
(cid:2),N
(cid:2),E
(cid:2)
(cid:2)
(cid:2)
d) Web Browsers: An honest browser is thought to be
used by one honest user, who is modeled as part of the browser.
User actions, such as following a link, are modeled as non-
deterministic actions of the web browser. User credentials are
stored in the initial state of the browser and are given to