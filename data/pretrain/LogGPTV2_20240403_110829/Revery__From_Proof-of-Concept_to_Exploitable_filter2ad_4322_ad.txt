YES
YES
YES
YES
NO
NO
NO
NO
NO
NO
NO
NO
NO
NO
GDB
Rex
Exploitable
NO Exploitable
NO Exploitable
NO UNKNOWN
NO UNKNOWN
NO UNKNOWN
NO
NO
NO
NO
NO
NO
NO
NO
NO
NO Exploitable
NO
NO
NO
NO
Failed
Failed
Failed
Failed
Failed
Failed
Failed
Failed
Failed
Failed
Failed
Failed
Failed
UAF
UAF
UAF
UAF
UAF
Off-by-one
Heap overflow
Heap overflow
Heap Overflow
Heap Overflow
Heap Overflow
Heap Overflow
Heap Overflow
Off-by-one
Double Free
Off-by-one
Heap Overflow
Heap Overflow
UAF
CONTROL
FLOW
HIJACK
EXPLOIT-
ABLE
STATE
FAILED
Table 1: List of CTF pwn programs evaluated with Revery. Out of 19 applications, Revery could generate exploits for 9 of them,
and generate EXP inputs to trigger exploitable state for another 5 of them, and failed for the rest 5.
each program must have at least one heap-based vulnerability; (3)
the diversity of vulnerability types must be large; and (4) the quality
of the source CTF events is well acknowledged.
All programs are tested in a regular modern Linux operating
system (Ubuntu 17.04), with the defense DEP [9] enabled. Unlike
traditional environments, we disabled ASLR [26] in the evaluation.
In practice, an information disclosure vulnerability or exploit is
required to bypass ASLR. The current prototype of Revery could
not generate information disclosure exploits yet.
6.1 Exploits by Revery
Table 1 shows the list of programs we evaluated. Out of 19 pro-
grams, Revery successfully exploited 9 of them, i.e., able to hijack
their control flow. Revery could trigger the exploitable states for
5 more programs, i.e., providing exploit primitives for experts to
launch successful exploits. It failed to analyze the rest 5 programs.
More details will be discussed later.
This table also shows in detail the name and CTF event of each
program. It shows the type of the known vulnerability in each
program, including heap overflow, off-by-one, UAF and double free.
Further, it shows the crash type of each vulnerability, i.e., results
of applying PoC inputs to the vulnerable programs. Some of them
are caught by the memory manager’s sanity checks (denoted as
heap error in the table), some others crash at invalid memory
read instructions. Most of them do not even crash.
In addition, it shows the violation type of each vulnerability
detected by Revery, the final exploitable state triggered by Revery,
and whether Revery could generate exploits or not. Revery could
detect security violations in 16 out of 19 programs. It could trigger
exploitable states of EIP hijacking, arbitrary memory write, and
unlink attack for 3, 6 and 5 programs respectively. Revery could
generate working exploits for first two types of exploitable states.
As a comparison, we also evaluated the open-source AEG solu-
tion Rex [5] provided by the Shellphish team and the exploitable
plugin in GDB on these programs. As shown in the last two columns
of the table, Rex could not solve any of these programs, and GDB
exploitable simply assesses the exploitability based on crash type.
6.2 Case Studies
In this section, we investigated these programs in detail, and
analyzed why our solution Revery succeeded or failed.
6.2.1 Control-Flow Hijacking Exploits. Revery successfully
generated control-flow hijacking exploits for 9 programs. With the
given PoC inputs, 2 programs corrupt the heap metadata and are
caught by the sanity checks deployed in glibc memory allocator.
Three other programs crash at invalid memory read instructions,
whose results are only dumped by functions like printf, which
could not cause control-flow hijacking. The rest 4 programs do not
even crash with the provided PoC.
Limit of State-of-the-art AEG Solutions. Such vulnerabilities are
usually considered as non-exploitable by exploitability assessment
tools. To successfully exploit these vulnerabilities, we have to avoid
the metadata corruption being caught by sanity checks, and accu-
rately model the memory allocator if using symbolic execution.
So state-of-the-art AEG solutions could not generate exploit
automatically for them. We have tested all these programs with
Rex[5], an automated exploit generation tool that developed by the
Shellphish team, which won the first in offense in CGC. But it failed
to generate exploits for any of them.
Performance of Revery. By exploring exploitable states in diverg-
ing paths, Revery can generate exploits for all 9 programs. For
example, WoO2 and WoO_fixed crash because one object is freed
twice. To exploit this kind of vulnerabilities, heap Fengshui [35] is
Session 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1923Figure 10: Time interval for finding first diverging path trig-
gering the layout-contributor slice by Revery, comparing to
AFL.
Figure 11: Time interval for finding exploitable states in di-
verging path by Revery, comparing to AFL.
needed, which is too complicated for automated solutions. Instead,
Revery goes back to the vulnerability point, and finds a diverging
path which could lead to EIP hijack.
Three of the exploitable states could hijack the program counter,
and the other six could cause arbitrary address write (AAW). AAW
is a well-known exploit primitive, could enable many exploits. For
example, it could be used to modify the global offset table (GOT)
and hijack the control flow.
6.2.2 Exploitable States. Sometimes Revery is not able to gen-
erate working exploits, even if it has found the exploitable states
and stitched an exploitation path. As shown in the table, Revery
could trigger exploitable states but fail to generate working exploits
for 5 programs.
For these programs, there is no critical data fields (e.g., function
pointer, VTable pointer etc.) in the exceptional object, and it is
extremely challenging to automatically generate exploits against
them. Instead, we have to utilize the corrupted metadata in the
exceptional objects to exploit the specific heap allocators.
Revery utilizes layout-oriented fuzzing to find a diverging path
that will free the exceptional object, and trigger an exploitable state.
Given that the glibc library uses a double-linked list to maintain
objects, unlinking a node from this list (due to certain memory
operations) will update forward and backward nodes’ pointers,
causing an unintended memory write operation. This is known as
unlink attack [6].
However, to successfully exploit such states, we have to arrange
the heap layout, with heap Fengshui and other techniques, which is
out of the scope of this paper. However, with the inputs generated
by Revery, experts could manually massage the heap layouts and
write an exploit much quicker.
6.2.3 Failed Cases. As aforementioned, Revery cannot guaran-
tee to generate working exploits or trigger exploitable states. In our
experiments, Revery failed for 5 programs.
Limitations of Vulnerability Detection. For some of the programs,
Revery fails to detect the security violations. For example, the
challenge SimpleMemoPad has a buffer overflow inside objects, i.e.,
it will corrupt the neighbor data fields rather than neighbor objects.
Revery currently only supports object level corruption detection.
We leave it as a future work to support detection of in-object buffer
overflow.
Limitations of Angr. Our solution Revery relies on angr [34] to
perform symbolic execution. Angr emulates all syscalls by itself,
which has not fully implemented yet. Alternatively, angr rewrites
library functions in Python, and hooks the original functions. How-
ever, this is far from finished too. As a result, angr cannot support
most real world programs. This is also the major reason why we
only evaluate Revery on CTF programs.
For example, to exploit childheap, some special characteristics
of the fgets function are required. This function is hooked by angr
but the required features are not properly implemented. So Revery
is not able to find a way to exploit the vulnerability.
6.3 Efficiency of Layout-oriented Fuzzing
We further evaluated the efficiency of Revery in terms of diverg-
ing path exploration and exploitable states searching. We compared
our layout-oriented fuzzing with the original fuzzer AFL. To evalu-
ate the efficiency of layout-oriented fuzzing fairly, we run Revery
and AFL at the same time, and use a same exploitable state search-
ing module in Revery to evaluate the test cases generated by both
fuzzers.
Figure 10 shows the time interval used by Revery and AFL to
find the first input that hits all instructions in layout-contributor
slice. On average, Revery is 122% faster than AFL.
Revery also spends less time than AFL to find an exploitable
state in diverging paths. As shown in Figure 11, AFL failed to find
exploitable states for 3 programs in 8 hours. By contrast, Revery
has found exploitable states for all the programs. For programs that
both AFL and Revery succeed, Revery is 247% faster than AFL on
average.
In short, with layout-oriented fuzzing, Revery could find diverg-
ing paths and exploitable states much faster than AFL.
We also compared layout-oriented fuzzing with Driller[37]. The
result shows that Driller didn’t find any exploitable state for all
the programs in 4 hours. And only in one program (i.e., note1) the
symbolic execution engine of Driller is invoked. This is probably
because driller is designed for CGC programs and has some bugs
for ELF binaries.
BabyheapbooksbragmainMarimonote1Woo2Woo-fixedezhpBinary name050001000015000200002500030000time/sN/AReveryAFLBabyheapbooksbragmainMarimonote1Woo2Woo-fixedezhpBinary name050001000015000200002500030000time/sN/AN/AN/AReveryAFLSession 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1924Name
shop 2
note2
ezhp
fb
note3
main
stkof
marimo
simplenote
babyheap
note1
b00ks
woO2
woO2_fixed
Vul
Type
UAF
BOF
BOF
BOF
BOF
UAF
BOF
BOF
BOF
UAF
BOF
BOF
UAF
UAF
Revery
Gen.
Time (s)
238
70
56
60
83
146
208
264
263
442
161
81
38
38
Path
Reuse
Rate
100%
100%
98.0%
85.1%
84.1%
71.1%
65.5%
62.2%
41.9%
27.8%
84.0%
83.3%
22.7%
22.7%
Revery
EXP.
Work
YES
YES
YES
YES
YES
YES
YES
YES
YES
YES
YES
YES
YES
YES
SYMBEX.
Gen.
Time(s)
Failed
Failed
Failed
Failed
Failed
>4hours
Failed
Failed
Failed
Failed
412
91
39
38
SYMBEX.
Unknown
EXP.
Work