# 一、了解 Kubernetes 和 Helm
感谢您选择本书《学习掌舵》。如果你对这本书感兴趣，你可能会意识到现代应用带来的挑战。团队面临着确保应用轻量级和可伸缩性的巨大压力。应用还必须高度可用，并且能够承受不同的负载。从历史上看，应用通常被部署为单片，或者在单个系统上服务的大型单层应用。随着时间的推移，该行业已经转向微服务方法，或者转向在多个系统上服务的小型多层应用。该行业通常使用容器技术进行部署，已经开始利用 Kubernetes 等工具来编排和扩展他们的容器化微服务。
然而，Kubernetes 也有自己的一系列挑战。虽然它是一个有效的容器编排工具，但它呈现出陡峭的学习曲线，团队很难克服。Helm 是帮助简化在 Kubernetes 上运行工作负载的挑战的一个工具。Helm 允许用户更简单地部署和管理 Kubernetes 应用的生命周期。它抽象了配置 Kubernetes 应用背后的许多复杂性，并允许团队在平台上更有效率。
在本书中，您将探索 Helm 提供的每一项优势，并了解 Helm 如何在 Kubernetes 上简化应用部署。您将首先承担最终用户的角色，使用社区编写的 Helm 图表，并学习将 Helm 作为包管理器的最佳实践。随着这本书的进展，你将扮演一个 Helm 图表开发人员的角色，并学习如何以易于消费和高效的方式打包 Kubernetes 应用。在本书的最后，您将通过 Helm 了解关于应用管理和安全性的高级模式。
让我们首先了解微服务、容器、Kubernetes，以及它们给应用部署带来的挑战。然后，我们将讨论 Helm 的主要特性和优势。在本章中，我们将涵盖以下主要主题:
*   单片、微服务和容器
*   Kubernetes 概述
*   如何部署 Kubernetes 应用
*   配置 Kubernetes 资源的挑战
*   【Helm 为简化 Kubernetes 上的生活应用部署提供的优势
# 从单片到现代微服务
软件应用是大多数现代技术的基础组成部分。无论是文字处理器、网络浏览器还是媒体播放器，它们都支持用户交互来完成一项或多项任务。应用有着悠久而传奇的历史，从第一台通用计算机 ENIAC 的时代，到阿波罗太空任务中的载人登月，再到万维网、社交媒体和在线零售的兴起。
这些应用可以在各种平台和系统上运行。我们说过，在大多数情况下，它们运行在虚拟或物理资源上，但从技术上讲，这些不是唯一的选择吗？根据其用途和资源要求，整个机器可能专用于满足应用的计算和/或存储需求。幸运的是，部分由于摩尔定律的实现，微处理器的功率和性能最初随着时间的推移而增加，同时与物理资源相关的总成本也在增加。近年来，这一趋势已经消退，但这一趋势的出现及其在处理器存在的前 30 年中的持续存在有助于技术的进步。
软件开发人员充分利用了这个机会，在他们的应用中捆绑了更多的特性和组件。因此，单个应用可以由几个较小的组件组成，每个组件都可以独立地编写为各自的服务。最初，将组件捆绑在一起产生了几个好处，包括简化的部署过程。然而，随着行业趋势开始改变，企业更加关注更快速交付功能的能力，单个可部署应用的设计带来了许多挑战。每当需要变更时，需要再次验证整个应用及其所有底层组件，以确保变更没有不利的特性。这个过程可能需要多个团队的协调，这减缓了特性的整体交付。
更快地交付特性，尤其是跨组织内的传统部门交付特性，也是组织想要的。这种快速交付的概念是一种叫做 DevOps 的实践的基础，它的流行大约发生在 2010 年。DevOps 鼓励随着时间的推移对应用进行更多的迭代更改，而不是在开发之前进行广泛的规划。为了在这种新模式中保持可持续性，架构从单一的大型应用发展到支持几个更小的应用，这些应用可以更快地交付。因为这种思维的转变，更传统的应用设计被贴上了**铁板一块**的标签。这种将组件分解成独立应用的新的方法为这些组件创造了名称为**微服务**。微服务应用固有的特性带来了几个理想的特性，包括从一个应用到另一个应用同时开发和部署服务的能力，以及独立扩展(增加实例数量)服务的能力。
软件架构从单片到微服务的变化也导致了重新评估应用在运行时是如何打包和部署的。传统上，整个机器专用于一个或两个应用。现在，由于微服务导致单个应用所需的资源总体减少，将整个机器专用于一个或两个微服务不再可行。
幸运的是，一项名为**容器**的技术被引入，并因填补了创建微服务运行时环境所需的许多缺失功能的空白而广受欢迎。Red Hat 将容器定义为“一组与系统其余部分隔离的一个或多个进程，包括运行所需的所有文件”(https://www . red Hat . com/en/topics/containers/what-a-Linux-container)。容器技术在计算领域有着悠久的历史，可以追溯到 20 世纪 70 年代。许多基础容器技术，包括 **chroot** (能够将进程及其任何子进程的根目录更改到文件系统的新位置)和**监狱**，今天仍在使用。
简单和可移植的打包模型的结合，以及在每个物理或虚拟机上创建许多隔离沙箱的能力，导致了容器在微服务领域的快速采用。2010 年代中期容器受欢迎程度的提高也可以归功于 Docker，它通过简化的包装和可以在 Linux、macOS 和 Windows 上使用的运行时将容器推向大众。轻松分发容器映像的能力导致了容器技术的普及。这是因为首次用户不需要知道如何创建映像，而是可以利用他人创建的现有映像。
容器和微服务成了天作之合。应用具有打包和分发机制，并且能够共享相同的计算空间，同时利用彼此隔离的优势。然而，随着越来越多的容器化微服务被部署，整体管理成为一个关注点。如何确保每个运行容器的健康？如果容器出现故障，你会怎么做？如果您的 0my 底层计算机没有所需的计算能力，会发生什么情况？输入 Kubernetes，这有助于满足容器编排的需求。
在下一节中，我们将讨论 Kubernetes 如何工作并为企业提供价值。
# 什么是魔方？
Kubernetes，通常缩写为 **k8s** (发音为 **kaytes** ，是一个开源容器编排平台。该项目源于谷歌专有的编排工具博格，于 2015 年开源，并更名为 Kubernetes。继 2015 年 7 月 21 日发布 v1.0 之后，谷歌和 Linux 基金会合作成立**云原生计算基金会** ( **CNCF** )，作为 Kubernete 项目的当前维护者。
Kubernetes 这个词是希腊语，意思是“舵手”或“领航员”。舵手是负责驾驶船只的人，与船上的高级船员密切合作，确保安全和稳定的航线，以及船员的整体安全。Kubernetes 在容器和微服务方面也有类似的职责。Kubernetes 负责容器的编排和调度。它负责将这些容器“引导”到能够处理其工作负载的适当工作节点。Kubernetes 还将通过提供高可用性和修复第次检查来帮助确保这些微服务的安全。
让我们回顾一下 Kubernetes 帮助简化容器化工作负载管理的一些方法。
## 容器编排
Kubernetes 最突出的特点是容器编排。这是一个相当复杂的术语，所以我们将把它分成不同的部分。
容器编排是根据需求将容器放置在计算资源池中的特定机器上。容器编排最简单的用例是在能够处理其资源需求的机器上部署容器。在下图中，有一个应用请求 2 Gi 的内存(Kubernetes 资源请求通常使用它们的“二的幂”值，在这种情况下大约相当于 2 GB)和一个 CPU 内核。这意味着容器将从它被调度的底层机器中被分配 2 Gi 的内存和 1 个 CPU 核心。由 Kubernetes 来跟踪哪些机器(在这种情况下称为节点)具有可用的所需资源，并在该机器上放置一个传入容器。如果节点没有足够的资源来满足请求，容器将不会在该节点上被调度。如果集群中的所有节点都没有足够的资源来运行工作负载，则不会部署容器。一旦节点有足够的空闲资源，容器将被部署在具有足够资源的节点上:
![Figure 1.1: Kubernetes orchestration and scheduling ](img/Figure_1.1.jpg)
图 1.1 - Kubernetes 编排和调度
容器编排使您无需一直努力跟踪机器上的可用资源。Kubernetes 和其他监控工具提供了对这些指标的洞察。因此，日常开发人员不需要担心可用的资源。开发人员可以简单地声明他们期望容器使用的资源量，Kubernetes 将在后端上处理剩余的资源。
## 高可用性
Kubernetes 的另一个好处是，它提供了有助于处理冗余和高可用性的功能。高可用性是防止应用停机的一个特征。这是由负载平衡器执行的，它将传入的流量分配给应用的多个实例。高可用性的前提是，如果应用的一个实例关闭，其他实例仍然可以接受传入的流量。在这方面，避免了停机时间，并且终端用户，无论是人还是另一个微服务，仍然完全不知道应用有一个失败的实例。Kubernetes 提供了一种网络机制，称为服务，允许应用负载平衡。我们将在本章的*部署 Kubernetes 应用*部分更详细地讨论服务。
## 可扩展性
考虑到容器和微服务的轻量级特性，开发人员可以使用 Kubernetes 快速扩展他们的工作负载，包括水平和垂直扩展。
水平扩展是部署更多容器实例的行为。如果在 Kubernetes 上运行工作负载的团队预计负载会增加，他们可以简单地告诉 Kubernetes 部署更多的应用实例。由于 Kubernetes 是一个容器编排器，开发人员不需要担心那些应用将要部署在的物理基础设施。它只需在集群中找到一个具有可用资源的节点，并在那里部署额外的实例。每个额外的实例将被添加到负载平衡池中，这将允许应用继续保持高可用性。
垂直扩展是向应用分配额外内存和 CPU 的行为。开发人员可以在应用运行时修改其资源需求。这将提示 Kubernetes 重新部署正在运行的实例，并在支持新资源需求的节点上重新计划它们。根据配置方式，Kubernetes 可以在部署新实例时，以防止停机的方式重新部署每个实例。
## 活跃社区
Kubernetes 社区是一个非常活跃的开源社区。因此，Kubernetes 经常收到补丁和新功能。该社区还对文档做出了许多贡献，包括官方的 Kubernetes 文档以及专业或业余博客网站。除了文档之外，社区还高度参与规划和参加世界各地的会议和大会，这有助于增加平台的教育和创新。
Kubernetes 大型社区的另一个好处是构建了大量不同的工具来增强所提供的能力。头盔就是其中一种工具。正如我们将在本章后面和本书中看到的，Helm——一个由 Kubernetes 社区成员构建的工具——通过简化应用部署和生命周期管理，极大地改善了开发人员的体验。
了解了 Kubernetes 为管理容器化工作负载带来的好处后，现在让我们讨论如何在 Kubernetes 中部署应用。
# 部署 Kubernetes 应用
在 Kubernetes 上部署应用与在 Kubernetes 之外部署应用基本相似。所有应用，无论是否是容器化的，都必须围绕包括以下内容的主题进行详细配置:
*   建立工作关系网
*   持久存储和文件装载
*   可用性和冗余性
*   应用配置
*   安全
在 Kubernetes 上配置这些细节是通过与 Kubernetes **应用编程接口** ( **应用编程接口**)交互来完成的。
Kubernetes API 充当一组端点，可以通过交互来查看、修改或删除不同的 Kubernetes 资源，其中许多资源用于配置应用的不同细节。
让我们讨论用户可以与之交互的一些基本的应用编程接口端点，以便在 Kubernetes 上部署和配置应用。
## 部署
我们将探索的第一个 Kubernetes 资源是名为部署。部署决定了在 Kubernetes 上部署应用所需的基本细节。这些基本细节之一包括 Kubernetes 应该部署的容器映像。容器映像可以在本地工作站上使用`docker`和`jib`等工具构建，但是映像也可以使用`kaniko`在 Kubernetes 上构建。因为 Kubernetes 没有公开用于构建容器映像的本机 API 端点，所以我们不会详细讨论如何在配置部署资源之前构建容器映像。
除了指定容器映像，部署还指定要部署的应用的副本或实例的数量。创建部署时，它会生成一个中间资源，称为复制集。复制集根据部署上的`replicas`字段决定部署多少个应用实例。应用部署在容器中，容器本身部署在一个名为 Pod 的构造中。Pod 是 Kubernetes 中最小的单元，至少封装了一个容器。
部署还可以定义应用的资源限制、运行状况检查和卷装载。创建部署时，Kubernetes 会创建以下体系结构:
![Figure 1.2: A deployment creates a set of Pods ](img/Figure_1.2.jpg)
图 1.2 -部署创建了一组 Pods
Kubernetes 中的另一个基本 API 端点用于创建服务资源，这将在下面讨论。
## 服务
虽然部署用于将应用部署到 Kubernetes，但它们不配置允许应用与 Kubernetes 通信的网络组件，而是公开一个单独的 API 端点，用于定义称为服务的网络层。服务允许用户和其他应用通过向服务端点分配静态 IP 地址来相互对话。然后，可以将服务端点配置为将流量路由到一个或多个应用实例。这种配置提供了负载平衡 ng 和高可用性。
下图描述了使用服务的示例体系结构。请注意，该服务位于客户端和 Pods 之间，以提供负载平衡和高可用性:
![Figure 1.3: A Service load balancing an incoming request ](img/Figure_1.3.jpg)
图 1.3 -服务负载平衡传入的请求
作为最后一个例子，我们将讨论`PersistentVolumeClaim` API 端点。
## 持久性卷索赔
微服务- 风格的应用通过以短暂的方式维护它们的状态来实现自给自足。然而，在许多用例中，数据必须超过单个容器的生命周期。Kubernetes 通过提供一个子系统来抽象如何提供存储以及如何使用存储的底层细节，从而解决了这个问题。为了给他们的应用分配持久存储，用户可以创建一个`PersistentVolumeClaim`端点，它指定所需的存储类型和数量。Kubernetes 管理员负责静态分配存储，表示为`PersistentVolume`，或者使用`StorageClass`动态调配存储，后者响应于`PersistentVolumeClaim`端点分配`PersistentVolume`。`PersistentVolume`捕获所有必要的存储细节，包括类型(如网络文件系统[NFS]、互联网小型计算机系统接口[iSCSI]或来自云提供商)，以及存储大小。从用户的角度来看，无论在集群中使用`PersistentVolume`分配方法还是存储后端的哪种方法，他们都不需要管理存储管理的底层细节。在 Kubernetes 中利用持久存储的能力增加了可以在平台上部署的潜在应用的数量。
下图描述了正在调配的持久性存储的示例。该图假设管理员已经通过`StorageClass`配置了动态供应:
![Figure 1.4: A Pod mounting PersistentVolume created by PersistentVolumeClaim ](img/Figure_1.4.jpg)
图 1.4 -由持久卷声明创建的装载持久卷的容器
Kubernetes 中有更多的资源，但是到现在，你可能已经得到了图片。现在的问题是这些资源实际上是如何产生的？