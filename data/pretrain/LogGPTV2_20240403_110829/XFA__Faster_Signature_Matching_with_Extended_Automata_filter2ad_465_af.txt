DFA
MDFA
Total Mem
43MB + 3.5MB
> 15GB
432 MB
397 MB
277 MB
191 MB
98 MB
66 MB
Num
Automata
1
n/a
67
107
147
346
587
786
Exec
(s/GB)
75.6
∼11.6
1,458
2,690
3,780
8,570
14,889
20,865
Table 5. Machine size and execution times
for XFAs, DFAs, and Multiple DFAs for several
memory settings. XFAs approach DFA perfor-
mance at small memory sizes.
world signatures. We produced efﬁcient XFAs for 93%
of Snort’s HTTP signatures. Construction of this set
required a day of manual effort, but our experience sug-
gests that new XFAs can be quickly constructed and in-
corporated in many cases.
5.3. Performance and memory usage
We compared XFAs to traditional DFAs and to
multiple DFA-based solutions, using the same 1450 sig-
natures for each of these techniques that were used for
XFA construction. Our attempt to build a single, com-
bined DFA for all signatures failed after only 88 out of
1450 signatures had been processed, at which time over
15 GB of memory was needed for the partial automaton.
We produced MDFAs for several memory limits rang-
ing from 66 MB (the smallest memory size that could
hold all signatures) to 512 MB.
Table 5 summarizes the performance and memory
usage individually for each of the techniques. DFAs, if
realizable, would have the best performance with the
largest memory consumption; the reported execution
time was obtained using the largest partially combined
DFA that could be ﬁt into our test machine’s memory.
The six MDFA points shown exhibit the tradeoffs be-
tween increased memory vs. increased time, with their
execution time being largely a function of the number of
created automata. The combined XFA compares favor-
ably as these results show: compared to the next-best
data point (the penultimate MDFA entry), the XFA re-
quires 10× less memory and is 20× faster. On average,
the XFA executed 1.12 instructions per byte, roughly
consistent with the data in Table 3.
Figure 11 compares the MDFAs to XFAs graphi-
cally. In the plot, the y-axis reﬂects total memory usage
and for XFAs includes both instruction and scratch
memory (46.5 MB). Both axes are on a logarithmic
scale. The plus marks (’+’) in the plot show the points
Multiple DFAs
XFA
1e+09
1e+08
)
e
l
a
c
s
g
o
l
s
e
t
y
b
(
e
g
a
s
u
y
r
o
m
e
M
1e+07
10
100
1000
10000
1e+05
Processing time (seconds/gigabyte logscale)
Figure 11. Memory vs. run-time for MDFAs and
XFAs. XFAs are both smaller and faster than
MDFAs for many memory ceilings.
for several MDFA instances and in a sense represent
the true cost of realizable DFA-based approaches. The
points hint at the tradeoffs obtained through pure DFA
approaches and suggest lower bounds given speciﬁc
time or memory requirements. The DFA point, if we
could plot it, would reside close to the left edge, several
orders of magnitude beyond the extent of the graph.
The XFA result, represented by a star, is below and
to the left of the curve suggested by the DFA-based ap-
proaches, indicating that XFAs require fewer resources
overall. Even with the inefﬁciencies of our prototype
system, the XFA yields superior results as compared to
MDFAs both in memory usage and performance.
6. Limitations and discussion
6.1. Mapping to EIDDs
The basic procedure for mapping an XFA with ab-
stract data domains to an appropriate EIDD, given in
Algorithm 4, uses a backtracking algorithm that we
have enhanced to aggressively identify and prune fruit-
less searches. Even so, some mappings require an hour
or more of computation time to complete. Further, each
EIDD must specify all the high-level scratch memory
types (typically just bits and counters in various forms)
to be used by an XFA. Common expressions that sim-
ply need one or more bits or counters have standard
patterns and can be mapped quickly. However, com-
plex regular expressions in which bits and counters are
composed into complex data types require equally com-
plex EIDDs. These are difﬁcult to specify. In princi-
ple, we could deﬁne a fully generic EIDD that provides
many compositions of bits and counters from which Al-
199
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:11:01 UTC from IEEE Xplore.  Restrictions apply. 
bmap[ctr%k]=F;
ctr++;
bmap[ctr%k]=F;
ctr++;
bmap[ctr%k]=F;
ctr++;
[^ab]
bmap[0..k-1]=F 
ctr=0
b
S
a
if (bmap[ctr%k]) {
accept();
}
[^ab]
T
a
b
bmap[ctr%k]=T;
ctr++;
bmap[ctr%k]=T;
ctr++;
bmap[ctr%k]=F;
ctr++;
Figure 12.
where k = n + 2.
The XFA recognizing .*a.{n}b
gorithm 4 selects only those that it needs. But in our
prototype, the resulting mapping times would be infea-
sible. We are working to address this issue.
6.2. Expressions with exponential state
Some signatures require exponential amounts of
space during the construction process, even though they
have a compact XFA representation. For example any
deterministic automaton recognizing .*a.{n}b needs
to remember which of the previous n+1 bytes in the in-
put were ‘a’ so that it knows to accept if it sees a ‘b’ in
the next n + 1 input characters. DFAs require at least
2n+1 states for this case. Similarly, during construc-
tion an XFA also needs at least 2n+1 distinct conﬁgu-
rations, although ultimately these can be contained par-
tially in scratch memory rather than only in explicit au-
tomaton states. For example, an XFA corresponding to
this regular expression, given in Figure 12, needs only
two states, a counter, and a bitmap with k = n + 2 bits
of scratch memory. The number of conﬁgurations is ex-
ponential, but the number of distinct states is small. For
small values of n, we can annotate the regular expres-
sion (as .*a#.{n}b), construct an EIDD, and build
the XFA in Figure 12. However, since the number of
conﬁgurations is exponential in n, we quickly run out
of memory during construction as n grows. We found
dozens of such regular expressions among Snort’s web
rules, such as rule 3519, which recognizes the regular
expression .*wqPassword=[ˆ\r\n&]{294} .
We are working to develop techniques that address
the difﬁculties described above and expand the class of
signatures that can be readily mapped to compact, efﬁ-
cient XFAs. Fortunately, XFAs are not an exclusive so-
lution and can be easily combined with other techniques
to achieve full generality. For instance, we may use
substring-based ﬁlters [20, 22] that identify only sub-
parts of signatures and invoke full signature evaluation
using DFAs, NFAs, or other techniques when the sub-
parts are matched. Alternatively, MDFAs [33] may also
be used.
In general, we observe that signatures are written
with an understanding of the underlying matching en-
gine’s capabilities. Signatures that are written for an
NFA-based engine (such as .*a.{n}b) are not neces-
sarily appropriate for a deterministic engine and vice-
versa. As shown, signatures that can be represented
compactly for nondeterministic automata may require
exponential state for deterministic automata. In many
cases, small changes to a regular expression turn it into
something we can build XFAs for efﬁciently. For ex-
ample, it is possible to recognize .*a[ˆa]{n}b as an
XFA with two states and a data domain of size n + 2
used essentially as a counter. Of course, whether such
changes are possible without changing the intent of the
rule requires human judgment and is best performed by
the signature writer.
7. Conclusion and future work
In this paper we have introduced Extended Fi-
nite Automata (XFAs), which augment traditional ﬁ-
nite state automata with a scratch memory that is ma-
nipulated by instructions attached to edges and states.
We provide a formal deﬁnition for XFAs and present
a technique for constructing them from regular expres-
sions. We performed a feasibility study using a set of
HTTP signatures from Snort and observed that XFAs
have matching speeds approaching DFAs yet memory
requirements similar to NFAs. Compared to multiple
DFA-based techniques, our tests used 10× less mem-
ory and were 20× faster.
The techniques and results we have presented here
are preliminary in many respects and we are actively
working to reﬁne them. Some aspects of our construc-
tion procedure require some manual input, and some
signatures require inordinately long construction times.
In addition, there is still some missing functionality and
inefﬁciencies in our interpreter and execution environ-
ment. We are investigating techniques for addressing
these and other issues. Notwithstanding these open
problems, we are hopeful that in the end XFAs will lead
to better solutions for high speed signature matching.
Acknowledgements
This work is sponsored by NSF grants 0546585
and 0716538 and by a gift from the Cisco University
Research Program Fund at Silicon Valley Community
Foundation.
200
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:11:01 UTC from IEEE Xplore.  Restrictions apply. 
References
[1] A. V. Aho and M. J. Corasick. Efﬁcient string matching:
An aid to bibliographic search. In Communications of
the ACM, June 1975.
[2] R. Alur.
Timed automata.
In Proceedings of the
Int. Conf. on Computer Aided Veriﬁcation, pages 8–22,
1999.
[3] R. S. Boyer and J. S. Moore. A fast string searching
algorithm. In Communications of the ACM, volume 20,
October 1977.
[4] D. Brumley, J. Newsome, D. Song, H. Wang, and
S. Jha. Towards automatic generation of vulnerability-
based signatures. In IEEE Symposium on Security and
Privacy, Oakland, California, May 2006.
[5] C. R. Clark and D. E. Schimmel.
Scalable pattern
matching for high-speed networks. In IEEE Symposium
on Field-Programmable Custom Computing Machines
(FCCM), pages 249–257, April 2004.
[6] C. J. Coit, S. Staniford, and J. McAlerney. Towards
faster pattern matching for intrusion detection or exceed-
ing the speed of Snort. In 2nd DARPA Information Sur-
vivability Conference and Exposition, June 2001.
[7] S. Crosby. Denial of service through regular expres-
sions. In Usenix Security work in progress report, Au-
gust 2003.
[8] S.T. Eckmann, G. Vigna, and R.A. Kemmerer. STATL:
An attack language for state-based intrusion detection.
Journal of Computer Security, 10(1/2):71–104, 2002.
[9] M. Fisk and G. Varghese. Fast content-based packet han-
dling for intrusion detection. TR CS2001-0670, UC San
Diego, May 2001.
[10] L. Fortnow. Nondeterministic polynomial time versus
nondeterministic logarthmic space: Time-space trade-
offs for satisﬁability.
In Proceedings of Twelfth IEEE
Conference on Computational Complexity, 1997.
[11] M. Handley, V. Paxson, and C. Kreibich. Network intru-
sion detection: Evasion, trafﬁc normalization, and end-
to-end protocol semantics. In Usenix Security, August
2001.
[12] T. A. Henzinger. The theory of hybrid automata.
In
Proceedings of the 11th Annual Symposium on Logic in
Computer Science (LICS), pages 278–292, 1996.
[13] M. Jordan. Dealing with metamorphism. Virus Bulletin
Weekly, 2002.
[14] S. Kumar, S. Dharmapurikar, F. Yu, P. Crowley, and
J. Turner. Algorithms to accelerate multiple regular ex-
pressions matching for deep packet inspection. In Pro-
ceedings of ACM SIGCOMM, September 2006.
[15] R-T Liu, N-F Huang, C-H Chen, and C-N Kao. A fast
string-matching algorithm for network processor-based
intrusion detection system. Transactions on Embedded
Computing Sys., 3(3):614–633, 2004.
[16] A. Narayanan and V. Shmatikov. Fast dictionary at-
tacks on passwords using time-space tradeoff. In ACM
Conference on Computer and Communications Security
(CCS), 2005.
[17] P. Oechslin. Making a faster cryptanalytic time-memory
trade-off. In 23rd Annual International Cryptology Con-
ference (CRYPTO), 2003.
[18] V. Paxson. Bro: a system for detecting network intruders
in real-time. In Computer Networks, volume 31, pages
2435–2463, 1999.
[19] T. Ptacek and T. Newsham. Insertion, evasion and de-
nial of service: Eluding network intrusion detection. In
Secure Networks, Inc., January 1998.
[20] M. Roesch. Snort - lightweight intrusion detection for
networks. In Proceedings of the 13th Systems Adminis-
tration Conference. USENIX, 1999.
[21] S. Rubin, S. Jha, and B. Miller. Language-based gener-
ation and evaluation of NIDS signatures. In IEEE Sym-
posium on Security and Privacy, May 2005.
[22] S. Rubin, S. Jha, and B. P. Miller. Protomatching net-
work trafﬁc for high throughput network intrusion de-
tection. In ACM Conference on Computer and Commu-
nications Security (CCS), pages 47–58, 2006.
[23] R. Sekar and P. Uppuluri. Synthesizing fast intrusion
prevention/detection systems from high-level speciﬁca-
tions. In Usenix Security, August 1999.
[24] U. Shankar and V. Paxson. Active mapping: Resisting
NIDS evasion without altering trafﬁc. In IEEE Sympo-
sium on Security and Privacy, May 2003.
[25] R. Sidhu and V. Prasanna.
matching using FPGAs.
tom Computing Machines (FCCM), April 2001.
Fast regular expression
In Field-Programmable Cus-
[26] R. Sommer and V. Paxson. Enhancing byte-level net-
In
work intrusion detection signatures with context.
ACM Conference on Computer and Communications Se-
curity (CCS), 2003.
[27] I. Sourdis and D. Pnevmatikatos. Fast, large-scale string
match for a 10gbps fpga-based network intrusion detec-
tion system. In International Conference on Field Pro-
grammable Logic and Applications, September 2003.
[28] I. Sourdis and D. Pnevmatikatos. Pre-decoded CAMs
for efﬁcient and high-speed NIDS pattern matching. In
IEEE Symposium on Field-Programmable Custom Com-
puting Machines (FCCM), April 2004.
[29] L. Tan and T. Sherwood. A high throughput string
matching architecture for intrusion detection and pre-
vention. In International Symposium on Computer Ar-
chitecture (ISCA), June 2005.
[30] K. Thompson. Programming techniques: Regular ex-
pression search algorithm. Commun. ACM, 11(6):419–
422, 1968.
[31] H. J. Wang, C. Guo, D. Simon, and A. Zugenmaier.
Shield: Vulnerability-driven network ﬁlters for prevent-
ing known vulnerability exploits. In Proceedings of the
2004 ACM SIGCOMM Conference, August 2004.
[32] V. Yegneswaran, J. T. Gifﬁn, P. Barford, and S. Jha. An
architecture for generating semantics-aware signatures.
In 14th USENIX Security Symposium, August 2005.
[33] F. Yu, Z. Chen, Y. Diao, T. V. Lakshman, and R. H. Katz.
Fast and memory-efﬁcient regular expression matching
for deep packet inspection.
In Proceedings of Archi-
tectures for Networking and Communications Systems
(ANCS), pages 93–102, 2006.
201
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:11:01 UTC from IEEE Xplore.  Restrictions apply.