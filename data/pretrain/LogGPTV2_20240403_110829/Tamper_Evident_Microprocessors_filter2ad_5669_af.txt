from
Fetch a malicious program instead of the one the OS intends.
Control Corrupter
#10
OpenSPARC
Unit
IFU
IFU
IDU
IDU
ITLB
ITLB
IL1
IL1
EXU
EXU
LSU
DL1
DL1
DL1
UL2
UL2
UL2
MC
DTLB
DTLB
DTLB
instruction
Fetch
wrong address
Fetch extra instructions
Emit spurious instructions
Transform no-op into load or
store
Translate pages incorrectly
Change or
sions
Loads wrong instruction
Loads extra instruction
Ignore permis-
Incorrect operation
Incorrect operation
Loads/Stores extra data
Loads extra data
Loads from wrong location
in UL2
Stores extra data
Loads extra data
Loads from wrong location
in RAM
Loads/Stores extra data
Loads/Stores extra data
Translates data location in-
correctly
Change permissions
Ignores permissions
Fetch a malicious program in addition to the one the OS
intends
Emit a spurious load or store to private information
Allow inappropriate load or store
Emitter
Emitter
Control Corrupter
Translate a valid load into a load from a malicious program
Allow loading from pages without permissions
Control Corrupter
Control Corrupter
#2
#1
#13
#12
#12
Data Corrupter
Emitter
duplic
#4
Fetch a malicious program instead of the one the OS intends
Fetch a malicious program in addition to the one the OS
intends
ALU produces incorrect output; Widespread damage
Compute wrong address
Load/store private information
Load private information
Load private information
Exﬁltrate private information
Load private information
Load private information
Data Corrupter
Data Corrupter
Emitter
Emitter
Data Corrupter
Emitter
Emitter
Data Corrupter
Overwrite OS critical information
Overwrite OS critical information
Translate a valid load into a load of private information
Emitter
Emitter
Control Corrupter
Allow loading from pages without permissions
Allow loading from pages without permissions
Control Corrupter
Control Corrupter
#11
#11
verif. V-C
verif. V-C
#3
#5#8
duplic.
#5#8
#6#7#9
duplic.
#6#7#9
IV-A
#11
equation:
trafﬁc ≤ 2 ∗ (MemoryOps ∗ MemoryMonitors
+ Instructions ∗ PipelineMonitors)
The factor of two comes from the fact that each monitoring
event consists of two packets - a prediction and a reaction.
This is a loose upper bound, and we expect real programs
to produce far less than this much trafﬁc. However, this upper
bound demonstrates our design’s scalability. This linear scaling
with the IPC and the pipeline depth is optimal (up to constant
factors) given that we want to monitor every pipeline stage
and every instruction.
We experimentally measured how much monitoring network
trafﬁc is generated by real programs with two questions in
mind: (1) Are there programs that create ﬂoods of trafﬁc (near
the worst-case bound)? (2) Do high-level differences between
programs affect the amount of trafﬁc caused by our monitors?
Our expectation was that the different programs would have
little impact on the amount of trafﬁc produced by the monitors.
As Figure 7 shows, the differences between programs do not
signiﬁcantly impact the EPC (events per cycle) of our system.
Figure 7 displays the number of communications per cycle
sent between TRUSTNET monitors during executions of SPEC
integer benchmarks. These numbers are deterministic because
the monitors behave deterministically and the instructions are
in order. The trafﬁc generated is relatively low (always less
than 2 per cycle). It is also stable across the benchmarks
(between 1.1 and 1.2). This supports our belief that a single
model works for all programs and that program adaptive
features would be unnecessary. These numbers would be
higher for a program that, for example, consisted of only
store instructions or only branch instructions, but we do not
anticipate such behavior in real programs.
F. Area Estimates
In this section, we provide bounds on the general area cost
of TRUSTNET and DATAWATCH and estimate the cost of the
implementation in our case study. We use bytes of storage as
Events per cycle created by the TRUSTNET monitoring scheme
Fig. 7.
for SPEC benchmarks. An event is any communication between two on-chip
units. A prediction and a reaction count as two separate events.
185
our metric because the computational logic required is trivial
(XORs, buffer logic, or equality check over a few bits).
The area cost of our monitors comes from the fact that an
event must be stored by the monitoring system from the time
it reaches the predictor to the time it reaches the reactor. In
complex processors, this time can be variable. It is necessary
to have buffers large enough to store all events that are still
incomplete. This number depends on the architecture but is
known a priori for a given microprocessor. Therefore:
BufferPackets ≤ MaxMemoryRequests
+ MaxInstructionsInPipeline
In the single-issue, in order case, each packet is a single
bit. Additionally, if there are N threads sharing a pipeline, the
data must be N bits wide instead of one, so that no thread-
swapping attacks are possible. So in general:
Area ≤ (MaxMemoryRequests
+ MaxInstructionsInPipeline) ∗ PacketSize
triangles. It
is sufﬁcient
Speciﬁcally, TRUSTNET as described in Table III, employs
nine different
to use a one byte
prediction buffer for each triangle at the input (although in
most cases less would sufﬁce). Analysis of an OpenSPARC
T2 core shows that it is impossible for a one byte prediction
buffer (eight slots) to overﬂow. This makes a total of at most
nine bytes of storage. Using maximal scaling i.e., conservative
scaling with no microarchitectural optimizations, would re-
quire 9∗8 = 72 bytes to cover an eight-threaded OpenSPARC
T2 core. An OpenSPARC T2 chip, which contains eight
cores, would require eight copies of TRUSTNET for a total
of 72 ∗ 8 = 576 bytes of storage.
DATAWATCH, as described in Table IV, employs four addi-
tional triangles on top of TRUSTNET. The two triangles for
the pipeline use eight-wide prediction buffers of one byte
signatures, for a total of eight bytes each. If we create the two
triangles on all eight cores, that makes 2 ∗ 8 ∗ 8 = 128 total
bytes of storage. Including the duplicate direct-mapped TLBs
(both data and instruction) adds a total of 128 + 64 = 192
duplicated TLB entries. If we do this for each of the eight
cores and give each line a generous 9 bytes of storage, this
adds 8 ∗ 9 ∗ 192 = 13824 bytes of storage. Then DATAWATCH
uses a total of 128 + 13824 = 13952 bytes of storage on top
of TRUSTNET, for a total of 13952 + 576 = 14528 bytes, or a
little under 15 KB of storage (total for 8 cores and the cache
hierarchy).
VI. CONCLUSION
One of the long-standing classic problems in systems se-
curity is “How to build trustworthy systems from untrust-
worthy components?” In this paper we study and propose
a solution for a variant of the problem: “How to build
trustworthy microprocessors from untrustworthy components
built by untrusted designers?” Since all software and hardware
is under the control of microprocessors, establishing trust in
186
microprocessors is a critical requirement for establishing trust
in computing bases.
We classiﬁed the set of possible RTL level design attacks
into three categories and explained the trade-offs between each
of the categories. We proposed as a solution to the untrusted
microprocessor designer problem TRUSTNET, a dynamic ver-
iﬁcation engine that continuously monitors communications
to detect violations of deterministic communication invariants
between on-chip units. TRUSTNET keeps track of microarchi-
tectural events required to execute an instruction and reports
a discrepancy when a microarchitectural unit does more or
less work than is expected. We also propose a more robust
system, DATAWATCH, which watches not only the amount of
events that happen but also the type of events that happen.
Within these two systems, each unit within a processor is
monitored by two other units, a predictor unit and reactor unit.
The predictor unit supplies inputs to the actor unit and reactor
unit receives outputs from the actor. By tracking predictions
and reactions, TRUSTNET and DATAWATCH detect malicious
modiﬁcations to a chip.
TRUSTNET and DATAWATCH are capable of detecting ma-
jor categories of microprocessor attacks without complete
replication (a classic textbook solution for such problems)
at low design complexity, for a small area investment, and
with no performance impact. Based on our evaluation of the
OpenSPARC T2 RTL, we determined that TRUSTNET takes
up less than 1 KB of storage to catch emitter attacks. We
also determined that DATAWATCH can protect the cores and
the cache hierarchy from known emitter and control corrupter
attacks at the cost of less than 2 KB of storage per processor
core. Lastly, we discussed how logic in the rest of the design
can be duplicated in order to provide more robust coverage
for high security domains at a fraction of the cost of complete
duplication (the current state of practice).
The ideas behind TRUSTNET viz. using the causal structure
of microarchitectural operations in concert with the division
of work between processor units, opens up exciting opportu-
nities to optimize over traditional techniques used to improve
reliability and availability of microprocessors. For instance,
TRUSTNET and DATAWATCH like infrastructure may be used
to detect transient faults and for dynamic veriﬁcation without
traditional duplication or diversity based techniques.
VII. ACKNOWLEDGEMENTS
We thank Edward Suh and anonymous reviewers for
their detailed comments. We also thank Sal Stolfo and
computer
members
valuable
systems
supported
feedback
by
an
(FA
99500910389)
of
group
on
instrumentation
this work. This work was
at Columbia University
from AFOSR.
the
security,
architecture