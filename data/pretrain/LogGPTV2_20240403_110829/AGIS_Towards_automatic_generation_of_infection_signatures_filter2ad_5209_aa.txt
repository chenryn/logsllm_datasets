title:AGIS: Towards automatic generation of infection signatures
author:Zhuowei Li and
XiaoFeng Wang and
Zhenkai Liang and
Michael K. Reiter
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
AGIS: Towards Automatic Generation of Infection Signatures
Zhuowei Lit, XiaoFeng Wangt, Zhenkai Liang§ and Michael K. Reiter£
tlndiana University at Bloomington §Carnegie Mellon University £University of North Carolina at Chapel Hill
Abstract
An important yet largely uncharted problem in malware
defense is how to automate generation of infection signa(cid:173)
tures for detecting compromised systems,
i.e., signatures
that characterize the behavior ofmalware residing on a sys(cid:173)
tem. To this end, we develop AGIS, a host-based technique
that detects infections by malware and automatically gener(cid:173)
ates an infection signature of the malware. AGIS monitors
the runtime behavior of suspicious code according to a set
ofsecurity policies to detect an infection, and then identifies
its characteristic behavior in terms of system or API calls.
AGIS then statically analyzes the corresponding executa(cid:173)
bles to extract the instructions important to the infection's
mission. These instructions can be used to build a template
for a static-analysis-based scanner, or a regular-expression
signature for legacy scanners. AGIS also detects encrypted
malware and generates a signature from its plaintext de(cid:173)
cryption loop. We implemented AGIS on Windows XP and
evaluated it against real-life malware, including keyloggers,
mass-mailing worms, and a well-known mutation engine.
The experimental results demonstrate the effectiveness of
our technique in detecting new infections and generating
high-quality signatures.
1 Introduction
The capability of malware to spread rapidly has moti(cid:173)
vated research in fully automated defense techniques that
do not require human intervention. For example, signifi(cid:173)
cant strides have been made in the automated generation of
exploit signatures and patches (e.g., [28, 17, 14, 24, 22, 30,
23, 21, 6, 8, 33, 20, 27]) to protect vulnerable software from
being exploited. These approaches detect the compromise
of a process and then trace the compromise to the exploit
input that caused it, enabling the construction of a signature
for that input and possibly variations thereof. These tech(cid:173)
niques, however, are largely constrained to detecting and
generating signatures for code-injection attacks, due to the
limited class of violations they can detect.
Although many research projects have developed solu(cid:173)
tions to automatically generate exploit signatures to prevent
the malware from penetrating vulnerable systems, they can-
not prevent all attacks, especially zero-day ones, and thus
allow malware to infect the victim systems. This prob(cid:173)
lem calls for an automatic mechanism to detect the mal(cid:173)
ware when it has already penetrated the vulnerable systems.
We meet this challenge by exploring the automatic genera(cid:173)
tion of a different type of signature, an infection signature,
which characterizes malware's behavior when it resides on
a system. The main objective of constructing infection sig(cid:173)
natures is to detect the presence of a malware that has suc(cid:173)
cessfully penetrated a system. While an exploit signature
can be generated through analyzing the software vulnera(cid:173)
bility which allows the exploit to happen [33, 2], infection
signatures are generally more difficult to get, due to the di(cid:173)
versity of malware's behavior in an infected system.
The first kind of infection signatures to have undergone
extensive study are virus signatures, which are generated
mostly through manual analyses of virus code. Kephart and
Arnold proposed an approach that automatically extracts
invariant byte sequences from "goat" files infected by the
virus running in a controlled environment [13]. A similar
approach has been adopted by Symantec in their digital im(cid:173)
mune system [29]. These techniques rely on a virus' repli(cid:173)
cation behavior, which is absent in other types of malware
such as spyware, Trojans and back doors. In addition, they
cannot handle polymorphic and metamorphic code [3].
There are other malware detectors that identify malware
by its MD5 checksum. Generation of a checksum signa(cid:173)
ture can be easily automated. However, it is too specific
to accommodate any modification to the code. Wang et
al. [31] proposed a network-based signature generation ap(cid:173)
proach which automatically extracts invariant tokens from
malware's communication traffic. However, such a signa(cid:173)
ture can be evaded if attackers vary the servers which com(cid:173)
municate with infected hosts (possibly through a botnet) or
simply encrypt network traffic.
In this paper, we seek a very general approach to auto(cid:173)
matically generating infection signatures, in particular one
that does not presuppose a method by which the attacker
causes his code to be executed on the computer; in the limit,
the user could have installed and run the malware himself,
as users are often tricked into doing. Consequently, our ap(cid:173)
proach does not begin with detectors for a code-injection at-
1-4244-2398-9/08/$20.00 ©2008 IEEE
237
DSN 2008: Li et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:16:20 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 2008
tack (e.g., using an input-provided value as a pointer [18)),
but rather monitors for an array of suspicious behaviors
that are indicative of a compromise, such as a system call
to hook a dynamic-link library (DLL) file for intercepting
keystrokes, and subsequent I/O activities for depositing and
transferring a log file. Once such behaviors are detected,
our technique employs dynamic and static analyses to ex(cid:173)
tract the instruction sequences used to perform the offend(cid:173)
ing actions, and can do so even if the instructions have un(cid:173)
dergone moderate obfuscations. These instructions can be
used to build a "vanilla" version of infection [4, 5], an in(cid:173)
struction template for a static analyzer to detect the infec(cid:173)
tion's variants, or regular-expression signatures for legacy
malware scanners.
In the case that malware has been en(cid:173)
crypted, our technique extracts the instructions necessary
for it to decrypt its executable and run, which must be plain(cid:173)
text. We have implemented these techniques in a system
called AGIS, and will detail its operation here.
At a high level, AGIS bears some similarity to behavior(cid:173)
based spyware detection that employs a composite of dy(cid:173)
namic and static analyses to detect spyware in the form of
browser plug-ins [16, 9]. However, our technique comple(cid:173)
ments that approach in that it works on standalone malware
such as keyloggers and mass-mailing worms. Recently,
Yin et al. [34] proposed Panorama, a technique that ap(cid:173)
plies instruction-level taint analysis to malware detection
and analysis. Panorama is designed for infection detec(cid:173)
tion, whereas AGIS is the first host-based approach for au(cid:173)
tomatic infection signature generation, though it also con(cid:173)
tains a coarser-grained detection component. Our experi(cid:173)
mental evaluation shows that AGIS' system-call level taint
analysis seems to be sufficient for detecting many existing
infections and is much more efficient.
We believe that AGIS advances research on malware de(cid:173)
fense in the following respects.
• Detection of infections caused by novel malware. We
have developed a new technique to detect a previously un(cid:173)
known infection by monitoring behavior of suspicious code
for violations of security policy. Examples of such behavior
include hooking a DLL file and exporting log files, or re(cid:173)
cursively searching a file system (for email addresses) and
connecting to SMTP servers. While our technique is also
applicable to plugin-based spyware (c.f. [16]), our current
focus is standalone malware.
• Automatic generation of infection signatures. We have
developed novel dynamic and static analysis techniques to
generate infection signatures. Our dynamic analyzer inputs
to the static analyzer the locations of the system or API calls
within an infection's executables that are responsible for its
malicious behavior, and other information that facilitates
static analysis of the malicious code. The static analyzer
then extracts the instructions indispensable to these calls.
Our approach also keeps track of the relationships among
different components of an infection through monitoring
their interactions, which enables automatic generation of
a series of signatures to identify the infection components
which are indirectly responsible for the malicious behavior.
This property is particularly important to malware disinfec(cid:173)
tion, as some infection component, if left undetected, could
restore other components once removed.
• Resilience to obfuscated and encrypted infection exe(cid:173)
cutables. We demonstrate that our technique can reliably
and efficiently extract signatures from an infection even if
its code has been moderately obfuscated and encrypted.
2 Design and Implementation
In this section, we describe the general design of AGIS
and a prototype we implemented under Windows XP. To
generate infection signatures, AGIS takes two key steps:
malicious behavior detection and infection signature ex(cid:173)
traction. We first present the general idea through a simple
example, and then elaborate on these individual steps.
2.1 Overview
As an illustrative example, consider a Trojan downloader
trapped within a honeypot. Once activated,
the Trojan
downloads and installs a keylogger, and sets a Run registry
key to point to it in order to survive the infected system
reboots. The keylogger consists of two components, an ex(cid:173)
ecutable file which installs a hook to Windows message(cid:173)
handling mechanism, and a DLL file containing the hook
callback function to create and transfer log files.
To detect this infection, the AGIS-enhanced honeypot
first runs the Trojan to monitor its system calls. From these
calls, AGIS constructs an infection graph which records the
relations anl0ng the Trojan and the files it downloads, as
evidenced by, e.g., the registry change to automatically in(cid:173)
voke the keylogger executable, and extends the surveillance
to them. An alarm is raised when the keylogger installs
the DLL to monitor keyboard inputs through the system
call NtUserSetWindowsHookEx, and the DLL exports
a file in response to inputs of keystrokes. 1 Such behavior is
suspected to violate a security policy which forbids hooking
the keyboard and writing a log file. The presence of this ma(cid:173)
licious activity can be confirmed by a static analyzer which
tries to find an execution path from the callback function in
the DLL to the NtWriteFile call being observed. Back(cid:173)
tracking on the infection graph, AGIS also pronounces the
Trojan to be malicious.
To extract infection signatures, our dynamic analyzer
first identifies the locations of the calls within executables
(a.k.a. call sites) responsible for the malicious behaviors,
which include downloading of the keylogger, modification
of the registry key, invocation of the keylogger, installation
1Keystrokes are automatically generated by a program in AGIS.
1-4244-2398-9/08/$20.00 ©2008 IEEE
238
DSN 2008: Li et at.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:16:20 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
Security Policies. Tainted executables are monitored by
AGIS for the behaviors that violate a set of predetermined
security policies.
Infections of the same type usually ex(cid:173)
hibit common behavior patterns. For example, a keylog(cid:173)
ger usually hooks the system message-handling mechanism
and then records keystrokes into a local or remote log; a
mass-mailing worm is very likely to search the file sys(cid:173)
tem for email addresses and then connect to remote SMTP
servers to propagate itself to other clients. Security policies
are set to flag an alarm whenever these malicious activities
are observed. For the above example, the keylogger pol(cid:173)
icy detects a sequence of hooking and recording behaviors,
and the mass-mailing policy detects reading files and then
connecting to SMTP servers. In AGIS, we specify security
policies using Behavior Monitoring Specification Language
(BMSL) [26]. Table 1 describes two example policies.
A policy can capture many malware instances: e.g., we
examined 23 mass-mailing worms reported by Symantec,
all of which exhibit the behaviors described above. Our ex(cid:173)
periments on 19 common applications using the above poli(cid:173)
cies (see Section 3.1) did not report any false positives.
Infection Detection and Behavior Extraction. AGIS de(cid:173)
tects an infection by matching the behaviors of suspicious
code to the event pattern of a security policy. Most such
behaviors can be directly observed through system calls,
while the rest need to be identified through static analy(cid:173)
sis of suspicious executables. For example, the keylogger
rule in Table 1 will be activated only if the program makes
WriteFile or Sendto calls and those calls are reachable
from the hooked function f. The second condition is ver(cid:173)
ified by the helper function ExistPath, which searches for
an execution path connecting f to a function exporting a file
in the control flow graph (CFO) of a tainted executable.2
The ExistSearchLoop helper function in the mass-mailing
rule can be implemented using dynamic analysis alone: our
approach triggers the rule if the frequency of recurrence of
ReadFile or related calls from the same call site exceeds a
pre-determined threshold.
Once an event pattern is observed, AGIS detects an in(cid:173)
fection and puts the detected processes and their executable
files in the infection set N. After that, the backtrack func(cid:173)
tion is invoked, which inductively adds to N all vertices
from which N can be reached in the infection graph. Dur(cid:173)
ing this process, the file representing a vertex in N, which
could also be a vertex, is also included in the infection set.
These vertices and their arcs form a subgraph connecting
the sources to the behaviors that trigger a security policy.
We then remove the vertices which do not have physical
representations on the hard disk and their arcs. The remain(cid:173)
ing subgraph records all the behaviors leading to the ma-
2Static analysis can be defeated by anti-disassembling techniques [11], or deep
obfuscations of the executable. When this happens, we can use instruction-level dy(cid:173)
namic analysis to verify the existence of an execution path.
Figure 1. The infection graph of the example. The dotted lines
annotated with 'backtrack' describe the backtracking process. The
vertices with 'Detected!!!' are detected violating security policies.
of the DLL and export of a log file. It can also collect other
information useful to static analysis, in particular, the call
sites of other observed system calls, anchoring the execu(cid:173)
tion path of the program. Using such information, a static
analyzer extracts the instruction sequences in individual ex(cid:173)
ecutables which affect the malicious calls directly or tran(cid:173)
sitively. The infection signatures of the Trojan downloader
are derived from these instructions.
2.2 Malicious Behavior Detection
The objectives of this step are to determine whether a
piece of suspicious code is malware and if so, to identify a
set of behaviors which characterize it. AGIS adopts a novel
technique which first builds an infection graph to describe
the relationships among different components of an infec(cid:173)
tion, such as modified registry keys and downloaded exe(cid:173)
cutables, and then detects some components' malicious be(cid:173)
haviors using a set of security policies. These behaviors are
used to generate infection signatures.
Infection Graph. An infection graph is a tuple (V, A),
where V is a set of vertices and A is a set of arcs. The set
V is further partitioned into two subsets: a set S of subjects
which contains executable components such as a keylogger
and a set 0 of objects that includes other components such
as registry entries. An arc a from component v to v' indi(cid:173)
cates that either v outputs something to v', e.g., creating v',
or v' inputs something from v, e.g., reading from v. We
also consider an arc existing from an auto-start extensibil(cid:173)
ity point (ASEP) [32] such as the Run registry key to the