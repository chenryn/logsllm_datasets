# AGIS: Towards Automatic Generation of Infection Signatures

**Authors:** Zhuowei Li, XiaoFeng Wang, Zhenkai Liang, and Michael K. Reiter

**Conference:** International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27, 2008

**Affiliations:**
- Zhuowei Li and XiaoFeng Wang: Indiana University at Bloomington
- Zhenkai Liang: Carnegie Mellon University
- Michael K. Reiter: University of North Carolina at Chapel Hill

## Abstract

A significant yet underexplored challenge in malware defense is the automation of generating infection signatures to detect compromised systems. These signatures characterize the behavior of malware residing on a system. To address this, we developed AGIS, a host-based technique that detects infections by malware and automatically generates an infection signature. AGIS monitors the runtime behavior of suspicious code based on a set of security policies to detect an infection. It then identifies the characteristic behavior in terms of system or API calls. AGIS also performs static analysis on the corresponding executables to extract instructions critical to the infection's mission. These instructions can be used to build templates for static-analysis-based scanners or regular-expression signatures for legacy scanners. Additionally, AGIS can detect encrypted malware and generate a signature from its plaintext decryption loop. We implemented AGIS on Windows XP and evaluated it against real-life malware, including keyloggers, mass-mailing worms, and a well-known mutation engine. The experimental results demonstrate the effectiveness of our technique in detecting new infections and generating high-quality signatures.

## 1. Introduction

The rapid spread of malware has driven research into fully automated defense techniques that do not require human intervention. Significant progress has been made in the automated generation of exploit signatures and patches to protect vulnerable software from being exploited. These approaches detect the compromise of a process and trace it to the exploit input, enabling the construction of a signature for that input and its variations. However, these techniques are primarily effective for code-injection attacks due to the limited class of violations they can detect.

While many research projects have developed solutions to automatically generate exploit signatures to prevent malware from penetrating vulnerable systems, they cannot prevent all attacks, especially zero-day ones. This necessitates an automatic mechanism to detect malware once it has penetrated a system. We address this challenge by exploring the automatic generation of infection signatures, which characterize malware's behavior when it resides on a system. The main objective is to detect the presence of malware that has successfully penetrated a system. Unlike exploit signatures, which can be generated by analyzing software vulnerabilities, infection signatures are more challenging to obtain due to the diversity of malware behavior in an infected system.

The first type of infection signatures to be extensively studied are virus signatures, typically generated through manual analysis of virus code. Kephart and Arnold proposed an approach that automatically extracts invariant byte sequences from "goat" files infected by the virus running in a controlled environment. Symantec adopted a similar approach in their digital immune system. These techniques rely on a virus' replication behavior, which is absent in other types of malware like spyware, Trojans, and backdoors. They also cannot handle polymorphic and metamorphic code.

Other malware detectors use MD5 checksums to identify malware. While generating a checksum signature is easily automated, it is too specific to accommodate any modifications to the code. Wang et al. proposed a network-based signature generation approach that automatically extracts invariant tokens from malware's communication traffic. However, such signatures can be evaded if attackers vary the servers communicating with infected hosts or encrypt network traffic.

In this paper, we propose a general approach to automatically generating infection signatures, particularly one that does not presuppose a method by which the attacker causes the code to be executed. Our approach monitors for an array of suspicious behaviors indicative of a compromise, such as system calls to hook a dynamic-link library (DLL) file for intercepting keystrokes and subsequent I/O activities for depositing and transferring log files. Once detected, our technique uses dynamic and static analyses to extract the instruction sequences used to perform the offending actions, even if the instructions have undergone moderate obfuscation. These instructions can be used to build a "vanilla" version of the infection, an instruction template for a static analyzer to detect variants, or regular-expression signatures for legacy malware scanners. For encrypted malware, our technique extracts the instructions necessary for it to decrypt its executable and run, which must be in plaintext. We have implemented these techniques in a system called AGIS and will detail its operation here.

At a high level, AGIS shares some similarities with behavior-based spyware detection, which employs a combination of dynamic and static analyses to detect spyware in the form of browser plug-ins. However, our technique complements this approach by working on standalone malware such as keyloggers and mass-mailing worms. Recently, Yin et al. proposed Panorama, a technique that applies instruction-level taint analysis to malware detection and analysis. While Panorama is designed for infection detection, AGIS is the first host-based approach for automatic infection signature generation, though it also contains a coarser-grained detection component. Our experimental evaluation shows that AGIS' system-call level taint analysis is sufficient for detecting many existing infections and is much more efficient.

We believe AGIS advances malware defense in the following ways:
- **Detection of infections caused by novel malware:** We have developed a new technique to detect previously unknown infections by monitoring the behavior of suspicious code for violations of security policy.
- **Automatic generation of infection signatures:** We have developed novel dynamic and static analysis techniques to generate infection signatures.
- **Resilience to obfuscated and encrypted infection executables:** We demonstrate that our technique can reliably and efficiently extract signatures from infections, even if the code has been moderately obfuscated and encrypted.

## 2. Design and Implementation

In this section, we describe the general design of AGIS and a prototype we implemented under Windows XP. To generate infection signatures, AGIS takes two key steps: malicious behavior detection and infection signature extraction. We first present the general idea through a simple example, and then elaborate on these individual steps.

### 2.1 Overview

Consider a Trojan downloader trapped within a honeypot. Once activated, the Trojan downloads and installs a keylogger, sets a Run registry key to ensure the keylogger survives system reboots, and consists of an executable file that installs a hook to the Windows message-handling mechanism and a DLL file containing the hook callback function to create and transfer log files.

To detect this infection, the AGIS-enhanced honeypot first runs the Trojan to monitor its system calls. From these calls, AGIS constructs an infection graph that records the relationships among the Trojan and the files it downloads, such as the registry change to automatically invoke the keylogger executable. An alarm is raised when the keylogger installs the DLL to monitor keyboard inputs through the `NtUserSetWindowsHookEx` system call and exports a file in response to keystrokes. This behavior violates a security policy that forbids hooking the keyboard and writing a log file. The presence of this malicious activity is confirmed by a static analyzer that finds an execution path from the callback function in the DLL to the `NtWriteFile` call. Backtracking on the infection graph, AGIS also pronounces the Trojan to be malicious.

To extract infection signatures, our dynamic analyzer first identifies the locations of the calls within executables (call sites) responsible for the malicious behaviors, such as downloading the keylogger, modifying the registry key, invoking the keylogger, installing the DLL, and exporting a log file. It also collects other information useful for static analysis, such as the call sites of other observed system calls, anchoring the execution path of the program. Using this information, a static analyzer extracts the instruction sequences in individual executables that affect the malicious calls directly or transitively. The infection signatures of the Trojan downloader are derived from these instructions.

### 2.2 Malicious Behavior Detection

The objectives of this step are to determine whether a piece of suspicious code is malware and, if so, to identify a set of behaviors that characterize it. AGIS adopts a novel technique that first builds an infection graph to describe the relationships among different components of an infection, such as modified registry keys and downloaded executables, and then detects some components' malicious behaviors using a set of security policies. These behaviors are used to generate infection signatures.

#### Infection Graph

An infection graph is a tuple \((V, A)\), where \(V\) is a set of vertices and \(A\) is a set of arcs. The set \(V\) is further partitioned into two subsets: a set \(S\) of subjects, which includes executable components such as a keylogger, and a set \(O\) of objects, which includes other components such as registry entries. An arc \(a\) from component \(v\) to \(v'\) indicates that either \(v\) outputs something to \(v'\), e.g., creating \(v'\), or \(v'\) inputs something from \(v\), e.g., reading from \(v\). We also consider an arc existing from an auto-start extensibility point (ASEP), such as the Run registry key, to the executable it invokes.

#### Security Policies

Tainted executables are monitored by AGIS for behaviors that violate a set of predetermined security policies. Infections of the same type usually exhibit common behavior patterns. For example, a keylogger typically hooks the system message-handling mechanism and records keystrokes into a local or remote log, while a mass-mailing worm is likely to search the file system for email addresses and connect to remote SMTP servers to propagate itself. Security policies are set to flag an alarm whenever these malicious activities are observed. In AGIS, we specify security policies using the Behavior Monitoring Specification Language (BMSL).

A policy can capture many malware instances. For instance, we examined 23 mass-mailing worms reported by Symantec, all of which exhibited the described behaviors. Our experiments on 19 common applications using these policies did not report any false positives.

#### Infection Detection and Behavior Extraction

AGIS detects an infection by matching the behaviors of suspicious code to the event pattern of a security policy. Most such behaviors can be directly observed through system calls, while others need to be identified through static analysis of suspicious executables. For example, the keylogger rule in Table 1 will be activated only if the program makes `WriteFile` or `Sendto` calls, and these calls are reachable from the hooked function \(f\). The second condition is verified by the helper function `ExistPath`, which searches for an execution path connecting \(f\) to a function exporting a file in the control flow graph (CFG) of a tainted executable. The `ExistSearchLoop` helper function in the mass-mailing rule can be implemented using dynamic analysis alone: our approach triggers the rule if the frequency of recurrence of `ReadFile` or related calls from the same call site exceeds a predetermined threshold.

Once an event pattern is observed, AGIS detects an infection and adds the detected processes and their executable files to the infection set \(N\). After that, the backtrack function is invoked, which inductively adds to \(N\) all vertices from which \(N\) can be reached in the infection graph. During this process, the file representing a vertex in \(N\), which could also be a vertex, is included in the infection set. These vertices and their arcs form a subgraph connecting the sources to the behaviors that trigger a security policy. We then remove the vertices that do not have physical representations on the hard disk and their arcs. The remaining subgraph records all the behaviors leading to the malicious activities.

This comprehensive approach ensures that AGIS can effectively detect and generate high-quality infection signatures, even for complex and obfuscated malware.