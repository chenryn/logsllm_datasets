文件格式。这些模糊器可以对一个指定的协议进行完整的测试，也可以被扩展用来对支持该协
议的不同应用程序进行压力测试。例如，同样一个专门的SMTP模糊器可以被用来对一些不同
的邮件传输程序进行模糊测试，如微软的Exchange、Sendmail、qmail等等。其他的模糊器采用
一种更加通用的方法以允许对任意的协议和文件格式进行模糊测试，并且执行简单的、不被协
议所意识到的变异，如位翻转以及字节置换。
尽管这些模糊器对范围广阔的普通应用而言是有效的，但是我们经常需要针对私有的、以
前没有被测试过的协议实施更加专用化的、更加彻底的模糊测试，在这个时候，模期测试框架
就变得非常有用了。
在本章中，我们将研究一些目前可用的开源的模糊测试框架，其中包括SPIKE，它是一个
曾经非常流行的框架，现在已经变成了家族名（这要取决于你的家族的族谱）。同时，我们还
要讨论一些在该领域中新出现的、令人感兴趣的框架，如Autodafé和GPF。在对现有的技术进
行分析之后我们将会看到，尽管许多通用的模糊测试框架已经提供了强大的功能，但是我们仍
然需要在某些时候重新创建一个模糊器。我们稍后将通过一个模糊测试问题以及针对该问题的
解决方案的实际例子来说明这一点。最后，我们将介绍一个由本书作者所开发的新的模糊测试
框架，并研究该框架所具有的特点。
21.1模糊测试框架的概念
目前可用的一些模糊测试框架是用C语言编写的，而其他的框架则是用Python或者Ruby来
编写的。有一些框架是通过开发语言自身来实现的，而其他框架则是利用了一个定制的语言。
例如，Peach模糊测试框架是使用Python来构建的，而dfuz则实现了它自已的模糊测试对象集
（本章的后面将对这两种框架进行更加详细的讨论）。有一些框架将数据的生成进行了抽象，而
另外一些则没有。还有一些框架是面向对象并且公开的，而其他的框架在大多数时候只能被创
---
## Page 261
246第三部分高级模糊测试技术
建者所使用。然面，所有模糊测试框架的共同目标都是相同的，即为模糊器的开发者提供一个
快速的、灵活的、可重用的以及同构的开发环境。
一个好的模糊测试框架应当将一些单调的工作进行抽象化，并且将这些工作减少到最少的
程度。为了帮助实现协议建模的第一个阶段，有一些框架包含这样的工具，即将被捕获的网络
通信转换为该框架能够理解的一种格式。这样以来，研究者就可以导人大量的经验数据，并且
将其关注的重点放在更加适合于人工完成的工作上，比如确定协议字段的边界。
对于一个成熟的框架来说，自动化的长度计算是绝对必需的。许多协议是使用类似于
ASN.1标准的一个TLV（类型、长度、值）风格的语法来实现的。考虑这样一个例子，数据
通信的第一个字节定义了后面跟着的数据的类型：0x01表示纯文本，0x02表示原始二进制数据。
接下来的两个字节定义了后面数据的长度。最后，剩余的字节定义了特定于通信的值或者数据，
如下所示：
010007
FUZZING
类型长度
值
当对这个协议的值字段进行模糊测试时，我们必须要在每个测试用例中计算并更新该协议
中两个字节的长度字段。否则的话，当违背协议规范而进行通信时，我们的测试用例将面临无
法被执行的风险。CRC（CalculatingCyclicRedundancyCheck）计算以及其他校验和算法作
为完成其他任务的工具，应当被一个有用的框架所包含.CRC值通常旅人到文件和协议规范中
以识别潜在的被破坏的数据。例如，如果接收到的CRC与所计算的CRC值不匹配，那么PNG图
像文件可以利用CRC值以允许程序避免处理一个图像。尽管这对于安全性和功能性来说是一个
非常重要的特性，但是如果当协议变异时CRC值没有被正确的更新，那么就会阻碍模测试的
进行。作为一个更加极端的例子，可以考虑分布式网络协议（DistributedNetworkProtocol，
DNP3）规范，该规范在监督控制和数据获取（SupervisoryControlandDataAcquisition，
SCADA）通信中被利用。数据流被单个的划分为250字节的块，并且每个块的前面增加了一个
CRC一16的校验和。最后，考虑一下客户端和服务器的IP地址，它们中的一者或两者经常是处
于所传输的数据中，并且在模测试的过程中，这两者的地址可能会经常发生变化。如果一个
模糊测试框架能够提供这样一个方法，即在所生成的模糊测试用例中自动化的确定并包含这些
值，那么将是非常方便的。
即使不是所有的，那么也是大多数的框架都提供了生成伪随机数的方法。一个好的框架将
通过包含一个启发式攻击的完整列表来提供更强大的功能。一个启发式攻击实际上就是一个被
存储的数据序列，并且已知该数据序列将会导致一个软件错误。格式化字符串（%n%n%n%n）和
目录遍历序列是简单的启发式攻击的常用例子。在重新回到随机测试数据生成之前，遍历包含
这样的测试用例的一个有限列表，将会在许多情形下节省时间，同时它还是一个值得进一步研
http://en.wikipedia.org/wiki/Asn.1
http://en.wikipedia.org/wiki/Cyclic_redundancy_check
Bodupm.nodn
---
## Page 262
第21章模糊测试枢架247
究的课题。
深人的探讨。一个模糊器可以发现如果其测试目标不能接收一个新的连接的话，那么它可能会
在一个非常简单的层次上执行失败。更加高级的错误检测通常是借助于一个调试器来完成的。
一个高级的模糊测试框架应当允许模糊器与关联到目标应用的一个调试器直接进行通信，或是
在其框架内绑定一个定制的调试器技术。
依赖于你个人的喜好，这里可能会有一个很长的包含各种细微特性的清单，可以显著提高
你的模糊器开发经验。例如，有一些框架包含对解析范围很广的一类格式化数据的支持。例如，
当将原始字节复制并粘贴到一个模糊测试脚本时，能够以如下格式0x410x42，x41x42.4142等
中的任意一种来粘贴十六进制字节将会是非常方便的。
一个高级的模糊测试框架应当包含一个接口，以同一个度量收集工具如代码覆盖监视器进行
通信。
最后，理想的模糊测试框架将提供便利条件以最大程度的实现代码重用，方法是通过使已
开发的构件能够很容易地用于后续项目。如果被正确地加以实现，那么这个概念将使得一个模
翻器变得更加智能化。在深入讨论特定于任务的以及面向通用目的这两种框架的设计和创建过
程之前，当我们对一些模糊测试框架进行研究时，要牢记所讨论的这些概念。
21.2现有框架
在本节中，我们将通过剖析一些模糊测试框架来了解目前已经存在的一些情况。我们并不
会涉及所有可用的模糊测试框架，但是相反，我们将研究一个代表了许多不同方法学的框架示
例。下面所列出的框架是根据其成熟度和包含特性的丰富程度来排列的，首先介绍的是最原始
的框架。
21.2.1 antiparser
Antiparser是一个用Python语言编写的API，被设计用来帮助生成随机数据，特别是针对模
糊器的创建。这个框架可以被用来开发能够跨多种平台运行的模糊器，因为该框架只依赖于一
个Python解释器的可用性。该框架的使用是非常方便的。首先必须要创建antiparser类的一个实
例，该类是作为一个容器使用的。接下来，antiparser将提供一些可以被实例化并追加到该容器
中的模期类型。可用的模糊类型如下所示：
·apChar（）：一个8位的C字符。
*apCString（）：一个C类型的字符串，即以一个空字节结尾的字符数组。
·apkeywords（）：一个值的列表，每个值关联着一个分隔符，数据块以及终结符。
·apLong（）：一个32位的C整数。
http://antiparsersourceforge.net
---
## Page 263
248
第三部分高级模糊测试技术
apShort（）:一个16位的C整数。
·apString（）：一个自由形式的字符串。
在所有可用的数据类型中，apkeywords（）是最有趣的一种。使用这个类，你可以定义关键
字的一个列表，一个数据块，关键字和数据之间的一个分隔符，以及一个可选的数据块终结符。
这个类将以如下的格式来生成数据：[keyword][separator][datablock][terlminator]
Antiparser发布了一个示例脚本evilftpclient.py，该脚本利用了apkeywords（）数据类型。让
我们通过研究该脚本的一部分来更好地理解该框架的开发过程。下面摘录的Python代码显示了
evilftpclient.py脚本中的相关部分，该部分的功能是在解析FTP动词参数的过程中，对一个FTP
daemon程序进行测试以发现格式化字符串漏洞。例如，该代码片段井没有显示使用目标FTP
dacmon程序进行验证的功能，为了得到完整的代码，可以参考相关的源代码。
出中
from antiparser inport *
CMDLIST -['ABOR'，·ALLO'，·APPE'，CDUP'，“XCUP'，‘CWD',
个
.3130.'.0OX,
'HELP'，'LIST',
`MKD',
XMKD'
'MACB'.MODE',
MTMD',*NLST'，
'SSd..dooN.
'PASV',‘PORT',
'PMD',
'XPWD',
'QUIT',
'REIN',
'RETR'，'RMD',
'XRMD',
'REST',
'SITE','SIZE',
‘STOR','STRU',‘STOU',
`RNFR',
'RNTO',
'STAT',
‘SYST'，‘TYPE'，‘USER’]
TERMINATOR - "\r\n*
SIS销器
for cmd in CMDLIST:
ap =antiparser()
spoayde=Mp
cndkw.setKeywords([cmd])
cndkw.setSeparator(SEPARATOR)
cmdkw.SetTerminator(TERMINATOR)
cndkwsetContent(%n%n%nnnnnnn%n”)
cndkw.setMode('incremental')
cndkw.setMax51ze(65536)
（moxpu）puaddede
sock-ap5ocket(）
sock.connect(HOST,PORT)
print FTP daenon banner
print sock.recv(1024)
sock.sendTCP(ap.getPay1oadO)
#send fuzz test
print FTP daenon response
print sock.recv(1024)
sock.c1ose()
---
## Page 264
第21章模糊测试枢案249
在上述代码的开头，首先从antiparser框架中导入了所有可用的数据类型，定义了一个列表，
该列表包含FTP动词，动词参数分隔符字符（空格）以及命令终止序列（回车后面跟着一个新
行）。然后，以一个新的antiparser容器类的实例作为开始，每一个所列出的FTP动词被单独循
环选代并测试。接下来，就该apkeywords（）数据类型发挥作用了。有一个列表定义了一个单独
的条目，当前正在被测试的动词被指定为关键词（在这个例子中是keyword）。然后，定义适当
的动词一—参数分隔符以及命令终止字符。所创建的apkeywords（）对象的数据内容被设置为格
式化字符串标记的一个序列。如果在解析动词参数的过程中，目标FTP服务器暴露了一个格式
化字符串漏洞，那么该数据内容必定将触发它。
接下来的两个调用setMode（'incremental°）和setMaxSize（65536），指定了在变异过
程中，数据块应当逐渐递增到最大值65536。然而，在这个特定的例子中，这两个调用却是不
相关的，因为模糊器并不会通过调用ap.permute（）来循环遍历一些测试用例或者变异。相反，
每个动词使用一个单独的数据块来测试。
上述代码的剩余行都是能够自解释的。单个数据类型apkeywords（）被追加到antiparser容器
中，并且创建了一个socket。一且建立起一个连接，那么就在对ap.getPay1oad（）的调用中生
成测试用例，并且通过sock.sendTCP（）来传输测试用例。
显然，antiparser也具有一些局限性。可以使用原始Python来很容易地重新生成示例FTP模
糊器，而不需要框架提供帮助。当在antiparser框架下开发模糊器时，特定于框架的代码与通用
代码之间的比率与其他的框架相比是非常低的。该框架也缺乏在上一节所列出、所需要的许多
目动化功能，比如自动化的计算并表示通用1LV协议格式的能力。最后一点局限性是，该框架
的文档的参考价值不高，并且不幸的是，在2005年8月所发布的该框架2.0版本中，只有一个单
独的例子是可用的。尽管该框架非常简单，并且为创建简单模糊器提供了一些帮助，但是它不
足以处理更加复杂的问题。
21.2.2Dfuzθ
Dfuz是DiegoBauche用C语言编写的，它是一个被动态维护并且经常被更新的模糊测试框
架。该框架用来发现影响提供商如微软、Ipswitch和RealNetwork的一些不同的漏洞。该框架的
源代码是开放的并且可以下载，但是一个限制性的许可将禁止任何复制或者修改操作，除非经
过作者的特殊许可。取决于你的需要，这个受限制的许可可能会阻止你利用该框架。这个严格
的许可背后的激发因素可能是作者对他自己的代码的质量感到不满意（根据README文件）。
如果你想要重用他的代码的某些部分，那么就应当直接与他联系。Dfuz被设计为运行在
UNIX/Linux平台上，并且提供了一个定制语言以开发新的模糊器。这个框架井不是本章所讨论