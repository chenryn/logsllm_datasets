Qdcount ﬁeld (i.e. the number of DNS queries) from the
query packet to the response packet. This value is usually
one, but if the query is not valid, some implementations, de-
pending on the error, will set the ﬁeld to one in the response
while others will keep it to zero. Note that current tools
such as fpdns do not test this ﬁeld because they consider it
uninteresting.
Our preliminary exploration of the candidate query space
has been able to ﬁnd multiple novel ﬁngerprints, which
reafﬁrms our intuition that the space of queries that could
be used for ﬁngerprinting remains largely unexplored and
demonstrates the effectiveness of our automatic approach.
5.4. Clustering
For the clustering experiments, we generate the clusters
using 70% of the hosts in each class and then evaluate ap-
proximate matching using the remaining 30% hosts, sim-
ilarly to the ﬁngerprint generation experiments. To gen-
erate the clusters, we run the X-Means algorithm on the
two feature spaces that we described in Section 4.4, that
is, we compute the features either from a selected set of
ﬁelds that contains implementation-dependent information
or from the complete TCP/IP or DNS headers. We name
these cases Chosen Fields and Full Header respectively.
The X-means range that we use is from one to twenty. This
range is chosen conservatively, and we check that the upper
limit is never reached.
Table 5 shows the clustering results for the OS and DNS
experiments. As expected, many of the classes deﬁned in
Tables 1 and 2 spread over more than one cluster, which
indicates the presence of multiple behaviors inside the same
class. We manually check a few of the DNS clusters and
ﬁnd that some of them are due to multiple versions in the
same class such as BIND 9.2.3 and 9.3.2 being placed in
the same class although they behave differently. Also, some
BIND tags like 9.3.0 represent up to 8 different versions (3
betas, 4 releases candidates and the ﬁnal version) [1].
In order to analyze the differences between the Chosen
Fields and Full Header cases and to check if hosts that be-
long to different classes are well-separated, Figure 6 shows
the visualization of distances between hosts by projecting
the feature space into the ﬁrst two principal components.
All hosts belonging to the same class are plotted using the
same icon. This visualization does not reﬂect the precise
distances, as there are a number of less signiﬁcant principal
components, but the ﬁrst two principal components are sig-
niﬁcant enough to show the qualitative distances between
different clusters.
Figures 6(a) and 6(b) show the results with Chosen
Fields. The classes in the OS case are well-separated with
only one Windows cluster (6 hosts) farther from the rest of
the class but still clearly separated from the other classes. In
the DNS case, the classes are more spread and the distances
between hosts in the same class are larger. For example,
some of the BIND9 hosts are close to the BIND8 hosts but
others are close to the MyDNS hosts. This could be due to
the evolution of versions of the same implementation that
are expected to be close when they share a signiﬁcant code
base and move farther apart as the evolution of the new ver-
sion progresses. With Chosen Fields, no cluster contains
hosts from two implementation classes.
Figure 6(c) shows the results with the full DNS header.
Results for the full TCP/IP header are similar and omitted
for brevity. Using the full header, the hosts in the same
class are further apart and hosts from different classes are
closer or even overlap. For example, in this case one cluster
contains hosts from the BIND8 and BIND 9 classes, shown
with the name Mixed in Table 5. These results indicate
that using an approach without any domain knowledge, that
just considers the complete protocol header, does not ob-
tain well-separated clusters. This is because some protocol
ﬁelds that include session or host-speciﬁc information, such
as the DNS ID or the DNS answers, may have more weight
than the implementation-speciﬁc differences.
Linux
Solaris
Windows
6
5
4
3
2
1
0
t
n
e
n
o
p
m
o
C
l
i
a
p
c
n
i
r
t
n
e
n
o
p
m
o
C
l
i
a
p
c
n
i
r
P
d
n
o
c
e
S
−1
−2
−3
−4
−6
P
d
n
o
c
e
S
2
4
0
−2
−4
First Principal Component
(a) Chosen Fields: OS
5
4
3
2
1
0
−1
−2
−3
−2
Bind8
Bind9
Win2003
MyDNS
TinyDNS
1.5
1
0.5
0
−0.5
−1
−1.5
Bind8
Bind9
Win2003
MyDNS
TinyDNS
t
n
e
n
o
p
m
o
C
l
i
a
p
c
n
i
r
P
d
n
o
c
e
S
−1
0
1
2
3
First Principal Component
(b) Chosen Fields: DNS
4
5
−2
−2
−1
0
1
2
First Principal Component
(c) Full Header: DNS
3
4
Figure 6. Principal component plots of the responses from the hosts for both OS and DNS clustering.
OS
DNS
Fingerprint type
Chosen Fields
Full Header
Linux
Solaris Windows
Bind8
Bind9 Microsoft MyDNS
TinyDNS Mixed
1
1
1
1
10
3
2
2
3
4
3
6
2
2
1
1
-
1
Table 5. For each implementation class, the number of clusters that contain hosts from this class.
Multiple clusters indicate different behaviors inside the implementation class.
Now, we quantitatively measure how well approximate
matching works for the OS and DNS cases with Chosen
Fields. We perform the following experiment: from the set
of implementation classes, we remove one class and extract
the clusters using 70% of the hosts in the remaining classes.
Then, we perform approximate matching using the z-gap
rule on the remaining 30% hosts from the classes used to
extract the clusters, plus all the hosts from the class that
was removed. We repeat this process multiple times, each
time removing a different class and at the end, we calculate
the average classiﬁcation error for different values of z.
The results show that the classiﬁcation error is mini-
mized with values z ≈ 2 for both the OS and DNS cases
and that in the DNS case the error quickly increases for
other z values. The OS case does not show such a strong
increase. We show the corresponding graphs in Figure 7.
Setting the value of z to be 2, the classiﬁcation error is 3%
for the OS case and 12% for the DNS case. This indicates
that the class separation for OS with Chosen Fields is more
robust and might be used for approximate matching but in
the case of DNS with Chosen Fields, approximate matching
is unlikely to yield good results.
6. Related Work
Fingerprinting has been used for more than a decade. In
1994 Comer and Lin proposed probing to ﬁnd differences
between TCP implementations [15]. Early application for
TCP ﬁngerprinting focused on standard compliance testing
to identify ﬂaws, support for optional functionality, protocol
violations and design decisions taken by the different im-
plementations [22]. Besides active probing, there has been
research on how to passively identify TCP implementations
looking at trafﬁc traces [23] and how to passively classify
host’s operating systems [13, 19]. Franklin et al. [16] pro-
posed a passive ﬁngerprinting technique to identify wire-
less device drivers on IEEE 802.11 compliant devices. In
the context of ﬁnding approximate matches, Lippmann et
al. [19] proposed to use a k-nearest-neighbor classiﬁer to
avoid hosts being classiﬁed as unknown when no exact
match was found. Our approximate matching differs in that
we use a clustering approach and focus on evaluating when
such approximate matching is possible. Hardware ﬁnger-
printing has also been proposed with applications such as
remotely tracking a host in a network [18]. However, to the
best of our knowledge, this is the ﬁrst work to address the
problem of automatically generating ﬁngerprints.
TCP/IP ﬁngerprinting can also be used to identify the
operating system running on a host [3, 4]. There exists
multiple tools for both active and passive OS ﬁngerprinting.
The most common active ﬁngerprinting tool in use today is
Nmap [9] written by Fyodor, which uses a similar approach
to older tools such as Queso [11]. Other active ﬁngerprint-
ing tools include Xprobe [12] that focuses on ICMP probes
and Snacktime that identiﬁes hosts based on the TCP time-
out and retransmission policy. Passive ﬁngerprinting tools
such as p0f [10] and siphon [6] do not need to send trafﬁc
)
%
(
r
o
r
r
e
n
o
i
t
a
c
i
f
i
s
s
a
C
l
70
60
50
40
30
20
10
0
0
5
50
45
40
35
30
25
20
15
)
%
(
r
o
r
r
e
n
o
i
t
a
c
i
f
i
s
s
a
C
l
15
20
10
0
5
10
z
10
z
15
20
(a) Chosen Fields: OS
(b) Chosen Fields: DNS
Figure 7. Classiﬁcation error of approximate matching using z-gap rule for different values of z.
and can be used to ﬁngerprint hosts that might not reply to
a query, such as those ﬁrewalled, but require access to the
trafﬁc sent by a host
There has also been work on defeating OS ﬁngerprinting.
Smart et al. [27] proposed a stack ﬁngerprinting scrubber
that sits on the border of a protected network and limits the
information gathered by a remote attacker by standardizing
the TCP/IP communication. This work is based on the pro-
tocol scrubber proposed by Malan et al. [20]. More recent
tools such as Morph [7] and IPPersonality [5] operate on
the host-level and allow to change the responses to speciﬁc
queries by faking the behavior of a chosen OS.
7. Conclusion
Fingerprinting is a useful technique that allows us to
identify different implementations of the same functional-
ity. But, the ﬁngerprint generation process is at large ardu-
ous and manual. In this paper we have proposed a novel ap-
proach for automatic ﬁngerprint generation, that produces