title:Fluorescence: Detecting Kernel-Resident Malware in Clouds
author:Richard Li and
Min Du and
David Johnson and
Robert Ricci and
Jacobus E. van der Merwe and
Eric Eide
Fluorescence: Detecting Kernel-Resident Malware in Clouds
Richard Li(cid:63) Min Du† David Johnson(cid:63) Robert Ricci(cid:63)
Jacobus Van der Merwe(cid:63) Eric Eide(cid:63)
(cid:63)University of Utah
†University of California, Berkeley
Abstract
Kernel-resident malware remains a signiﬁcant threat. An
effective way to detect such malware is to examine the kernel
memory of many similar (virtual) machines, as one might
ﬁnd in an enterprise network or cloud, in search of anomalies:
i.e., the relatively rare infected hosts within a large population
of healthy hosts.
It is challenging, however, to compare
the kernel memories of different hosts against each other.
Previous work has relied on knowledge of speciﬁc kernels—
e.g., the locations of important variables and the layouts of
key data structures—to cross the “semantic gap” and allow
kernels to be compared. As a result, those previous systems
work only with the kernels they were built for, and they make
assumptions about the malware being searched for.
We present a new approach to detecting kernel-resident
malware within a “herd” of similar virtual machines. Our
approach uses limited knowledge of the kernels under
examination—e.g., the location of the page global directory
and the processor’s instruction set—to concisely ﬁngerprint
each kernel. It uses no kernel-speciﬁc semantics to compare
the ﬁngerprints and ﬁnd those that represent anomalous hosts.
We implement our method in a tool called Fluorescence and
demonstrate its ability to identify Linux and Windows hosts
infected with real-world, kernel-resident malware. Fluores-
cence can examine a herd of 200 virtual machines with Linux
guests in about an hour.
1
Kernel-resident malware is stealthy. Once a kernel-resident
rootkit infects a machine, it will generally try to hide traces of
its intrusion, disable security software, and install persistent
backdoors for future unauthorized access [12, 22, 39, 40].
Despite recent advances in protecting kernel integrity, kernel
rootkits remain a signiﬁcant threat: for example, at Black
Hat 2017, Bulygin et al. [7] demonstrated a successful kernel
rootkit attack against Windows 10, which has multiple kernel-
protection mechanisms enabled.
Introduction
To persist and perform malicious activities, a kernel rootkit
must inject code into the kernel’s address space [21]. Thus, in
principle, an analyst can detect the presence of a kernel rootkit
by comparing a memory snapshot of a suspect host against
a memory snapshot of a clean, uninfected host running the
same kernel. Such a comparison is difﬁcult in practice for
three reasons. First, the analyst must locate the baseline: a
host that is running the relevant kernel and that is guaranteed
to be uninfected. A clever way to solve this problem is to
leverage the fact that clouds commonly run many instances
of a single virtual-machine (VM) image [6]. Given a large
number of VMs running the same image and the assump-
tion that infections are rare, an analyst can assume that the
overwhelming majority of the VMs will be clean [3]. Sec-
ond, kernel memory snapshots are large. While it is possible
to transfer “raw” memory snapshots to a single point for
analysis [3], the network cost of this collection can be high
when many VMs are to be examined. Third and most signif-
icantly, the kernel-memory snapshots of two VMs that run
“the same kernel” can differ widely, for a large number of
reasons that do not indicate the presence of a rootkit infection.
Across two snapshots, the routine differences due to divergent
virtual-to-physical memory mappings, address-space layout
randomization (ASLR), paravirtualization-related patching,
and other factors can make it very challenging to identify the
differences that are indicators of kernel malware.
To distinguish between benign differences and potentially
important ones, previous work relies on knowledge of the ker-
nels being inspected. For example, the Blacksheep system [3]
uses knowledge of the Windows XP and 7 kernels—e.g., the
identities and layouts of important data, the locations of ker-
nel entry points, and the structure of Portable Executable (PE)
ﬁles—so that it can give special attention to differences in
Windows’ key components. Bridging the “semantic gap” in
this way is effective but has three practical weaknesses. First,
the analyzer becomes specialized: it works only on the ker-
nels for which it has special (and accurate) implementation
knowledge. Second, the analyzer becomes more complex: it
must include code to walk individual data structures, extract
speciﬁc kernel features, assign weights to the extracted fea-
tures, and so on. Third, by choosing to give special attention
to certain parts of the kernel, the analyzer inherently makes
assumptions about how malware will integrate with the ker-
nel. These assumptions may or may not be accurate, and as
malware evolves, the analyzer’s assumptions may become
less true over time.
In this paper, we present a new and alternative approach
to detecting kernel-resident malware within a large group of
similarly conﬁgured VMs (a “herd”). Our approach uses no
malware-speciﬁc knowledge, e.g., no signatures or assump-
tions about how malware attaches to the kernel, except for
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 367the assumption that the malware has code that resides in the
kernel. Our approach uses limited kernel-speciﬁc knowledge
to obtain, for each VM in the herd, a meaningful but concise
ﬁngerprint of the code in that VM’s kernel. The knowledge
used in this process is low-level: e.g., the location of the page
global directory, allowing the rest of the kernel’s memory to
be located, and knowledge of the processor’s instruction set,
allowing the kernel’s code to be disassembled. Each ﬁnger-
print is a collection of hashes that summarize the (normalized)
contents of a kernel’s code pages: we use fuzzy hashing [20]
so that similar page contents map to similar hash values. The
ﬁngerprints are generated on the physical machines that host
the VMs, and then they are sent to a central analysis server.
The server uses no kernel-speciﬁc knowledge to carry out its
task. It compares the ﬁngerprints by ﬁrst performing feature
alignment (identifying the elements that “line up” over all the
ﬁngerprints); then putting the ﬁngerprints into a space over
which distances can be computed; and ﬁnally, computing clus-
ters over the ﬁngerprints. The ﬁngerprints of most VMs form
a single cluster, representing the healthy members of the herd.
Fingerprints that fall outside the main cluster correspond to
VMs with anomalous, possibly malware-infected, kernels.
We have implemented our approach in a tool called Fluores-
cence and evaluated its ability to detect VMs that are infected
with real-world kernel rootkits. Fluorescence can examine
both Linux (3.13–4.15, x64) and Windows 7 (x64) kernels.
Because the kernel-speciﬁc knowledge needed for memory
acquisition and normalization is minimal and low-level, it
tends to be stable across many versions of a single kernel: in
particular, we report that Fluorescence’s single Linux-speciﬁc
agent works correctly across the range of Linux kernels we
have tested, 3.13.0–4.15.0. We also report on our experiments
using Fluorescence to detect the presence of kernel rootkits
within herds. Fluorescence was able to ﬁnd all of the infected
hosts in the Linux- and Windows-based herds that we created;
in addition, when multiple types of malware were present,
Fluorescence was able to correctly cluster the infected hosts
by type. Finally, we report that the time taken by Fluorescence
is reasonable, even for herds containing a few hundred VMs.
In our experience, Fluorescence can analyze a 50-host herd
in less than ten minutes, and 200 hosts in ∼60–80 minutes.
Our contributions are threefold. First, we present a new
method for detecting kernel-resident malware within a group
of VMs that run the same kernel. Unlike previous methods
that require detailed knowledge of the kernel under exami-
nation, our method uses limited kernel-speciﬁc knowledge
to construct ﬁngerprints and no kernel-speciﬁc knowledge to
analyze the ﬁngerprints. Second, we describe the implemen-
tation of our method in Fluorescence. Our implementation
shows that our approach is general: Fluorescence works with
both Windows and Linux kernels, and a single Linux agent
sufﬁces for a wide range of Linux kernel versions. Third, we
evaluate Fluorescence in terms of its detection abilities and
speed. In our experiments, Fluorescence was able to detect
Figure 1: Fluorescence architecture.
all the real-world kernel rootkits in our VM herds. The time
required by Fluorescence is reasonable for regular (e.g., daily)
scanning of large herds, containing up to a few hundred VMs.
2 Design
Figure 1 illustrates the overall design of Fluorescence, our
system for detecting kernel-resident malware within a herd
of similarly conﬁgured VMs. Fluorescence implements a
three-step algorithm. First, it collects the current ﬁngerprint
of every VM in the herd (§2.1). A ﬁngerprint summarizes the
code pages within the kernel of a VM’s guest; ﬁngerprints are
computed by agents that run on the physical machines that are
being monitored by Fluorescence, and these agents send the
ﬁngerprints to a central node for analysis. Second, Fluores-
cence’s central node performs feature alignment (§2.2). Each
ﬁngerprint is an unordered multiset that represents the content
of one VM’s kernel, and the feature-alignment step ﬁnds the
elements that best correspond to each other across the multi-
sets. The output of this step is a matrix. Each row encodes the
ﬁngerprint of one VM, and each column represents a feature;
the elements of each ﬁngerprint (row) are permuted so that
the best-corresponding elements across all ﬁngerprints are
aligned (columns). Third, the central node performs anomaly
detection over the data in the matrix (§2.3). Fluorescence does
this in two steps: the ﬁrst transforms the data in the matrix
so that one can compute “distances” between the ﬁngerprints,
and the second uses machine learning—deep learning (§2.3.1)
and clustering (§2.3.2)—to ﬁnd anomalies. The ﬁngerprints
of most VMs form a single cluster. Given the assumption that
malware infections are rare [3], that cluster represents VMs
that are healthy. Outliers correspond to VMs with anomalous
kernel-memory code, e.g., malware infections. The clustering
pattern among the outliers can help an analyst determine if
the outlier VMs are infected by a single kind of malware (one
cluster) or different kinds (multiple clusters).
Fluorescence is designed to be general in two ways. First,
it relies on no malware-speciﬁc knowledge: no signatures
or assumptions about how malware works, except for the
assumption that it must have code in order to stay resident.
Second, it requires only very limited information about the
kernels that are being monitored. As Table 1 shows, the
VMVMVM VMMVMI AgentFingerprintingVMVMVM VMMVMI AgentFingerprintingVMVMVM VMMVMI AgentFingerprintingCentral nodeFeature alignmentAnomaly detection368          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX AssociationAnalysis Step
Fingerprinting
kernel page pinning (opt.)
VM pause/resume
kernel page acquisition
normalization
hashing
Feature alignment
Anomaly detection
Kernel/Arch.-speciﬁc Knowledge
debug info used by pinning tool
none
page global dir. (KPGD) location
x86 64 page table
Intel Extended Page Tables
general ELF/PE loading layout
OS-dependent addr. space layout
x86 instruction set
none
none
none
Table 1: Kernel- and architecture-speciﬁc knowledge needed by
Fluorescence.
ﬁngerprinting agents need some basic, low-level information
in order to locate a kernel’s pages (§2.1.1) and normalize their
contents (§2.1.2). Fluorescence’s central server, which does
feature alignment and anomaly detection, needs no kernel- or
architecture-speciﬁc knowledge at all.
2.1 Fingerprinting
Fluorescence’s agents, which are co-located with the VMs be-
ing monitored, produce a ﬁngerprint for every VM in the herd.
Fluorescence’s feature-alignment and clustering steps operate
on these ﬁngerprints, rather than kernel memory snapshots,
which greatly reduces the amount of data that is transferred
to the central server. The key goal of ﬁngerprinting, therefore,
is to preserve the most important characteristics of a VM’s
guest kernel code memory while also being concise.
Creating a ﬁngerprint involves four steps. First, the agent
pauses the target VM. Second, the agent uses virtual machine
introspection (VMI) to locate the VM guest’s kernel code
memory pages. It copies the pages and their metadata into
its own memory—a quick operation—and then resumes the
target VM.1 Third, the agent normalizes the contents of the
copied pages to reduce expected sources of “noise,” e.g., the
effects of address-space layout randomization (ASLR). The
agent has multiple ways to normalize the raw data, resulting
in multiple feature views of each page. Fourth, the agent uses
fuzzy hashing [20] to compute a hash for each feature view. A
fuzzy hash function produces similar hashes for similar inputs,
and is therefore a summarizer: the “distance” between the
hashes of pages A and B can be used to estimate the similarity
of the full contents of pages A and B.
The complete ﬁngerprint of a VM guest’s kernel is a multi-
set, and each element of the multiset is a tuple that describes
one 4 KB-page of the kernel’s code memory. The ﬁrst ele-