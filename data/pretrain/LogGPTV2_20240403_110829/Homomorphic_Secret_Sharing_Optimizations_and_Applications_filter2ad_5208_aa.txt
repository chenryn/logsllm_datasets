title:Homomorphic Secret Sharing: Optimizations and Applications
author:Elette Boyle and
Geoffroy Couteau and
Niv Gilboa and
Yuval Ishai and
Michele Orrù
Homomorphic Secret Sharing:
Optimizations and Applications
Elette Boyle
IDC, Israel
PI:EMAIL
Geoffroy Couteau
DI ENS, CNRS, PSL Research
University, Paris, France
INRIA
PI:EMAIL
Niv Gilboa
Ben Gurion University, Israel
PI:EMAIL
Yuval Ishai
Technion, Israel, and UCLA, USA
PI:EMAIL
ABSTRACT
We continue the study of Homomorphic Secret Sharing (HSS), re-
cently introduced by Boyle et al. (Crypto 2016, Eurocrypt 2017).
A (2-party) HSS scheme splits an input x into shares (x
) such
that (1) each share computationally hides x, and (2) there exists
an efficient homomorphic evaluation algorithm Eval such that for
any function (or “program”) P from a given class it holds that
, P ) = P (x ). Boyle et al. show how to construct
Eval(x
an HSS scheme for branching programs, with an inverse polynomial
error, using discrete-log type assumptions such as DDH.
, P ) +Eval(x
, x
0
1
0
1
We make two types of contributions.
Optimizations. We introduce new optimizations that speed up the
previous optimized implementation of Boyle et al. by more than a
factor of 30, significantly reduce the share size, and reduce the rate
of leakage induced by selective failure.
Applications. Our optimizations are motivated by the observation
that there are natural application scenarios in which HSS is useful
even when applied to simple computations on short inputs. We
demonstrate the practical feasibility of our HSS implementation in
the context of such applications.
KEYWORDS
Homomorphic Secret Sharing; Homomorphic Encryption; Private
Information Retrieval; Secure Computation
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’17, October 30-November 3, 2017, Dallas, TX, USA
© 2017 Copyright held by the owner/author(s). Publication rights licensed to Associa-
tion for Computing Machinery.
ACM ISBN 978-1-4503-4946-8/17/10...$15.00
https://doi.org/10.1145/3133956.3134107
Michele Orrù
DI ENS, CNRS, PSL Research
University, Paris, France
INRIA
PI:EMAIL
1 INTRODUCTION
Fully homomorphic encryption (FHE) [26, 42] is commonly viewed
as a “dream tool” in cryptography, enabling one to perform arbi-
trary computations on encrypted inputs. In the context of secure
multiparty computation (MPC) [6, 17, 31, 45], FHE can be used to
minimize the communication complexity and the round complexity,
and shift the bulk of the computational work to any subset of the
participants.
However, despite exciting progress in the past few years, even
the most recent implementations of FHE [18, 24, 32] are still quite
slow and require large ciphertexts and keys. This is due in part to
the limited set of assumptions on which FHE constructions can be
based [15, 27, 44], which are all related to lattices and are therefore
susceptible to lattice reduction attacks. As a result, it is arguably
hard to find realistic application scenarios in which current FHE
implementations outperform optimized versions of classical secure
computation techniques (such as garbled circuits) when taking both
communication and computation costs into account.
Homomorphic secret sharing. An alternative approach that pro-
vides some of the functionality of FHE was introduced in the recent
work of Boyle et al. [11] and further studied in [13]. The high
level idea is that for some applications, the traditional notion of
FHE can be relaxed by allowing the homomorphic evaluation to be
distributed among two parties who do not interact with each other.
This relaxation is captured by the following natural notion of
homomorphic secret sharing (HSS). A (2-party) HSS scheme ran-
domly splits an input x into a pair of shares (x
) such that:
(1) each share xb computationally hides x, and (2) there exists a
polynomial-time local evaluation algorithm Eval such that for any
“program” P (e.g., a boolean circuit, formula or branching program),
the output P (x ) can be efficiently reconstructed from Eval(x
, P )
and Eval(x
As in the case of FHE, we require that the output of Eval be
compact in the sense that its length depends only on the output
length |P (x )| but not on the size of P. But in fact, a unique feature
of HSS that distinguishes it from traditional FHE is that the output
representation can be additive. That is, we require that Eval(x
, P ) +
, P ) = P (x ) mod β for some positive integer β ≥ 2 that can
Eval(x
be chosen arbitrarily. This enables an ultimate level of compactness
, P ).
, x
0
1
0
1
0
1
Session J1:  OutsourcingCCS’17, October 30-November 3, 2017, Dallas, TX, USA2105and efficiency of reconstruction that is impossible to achieve via
standard FHE. For instance, if P outputs a single bit and β = 2, then
P (x ) is reconstructed by taking the exclusive-or of two bits.
The main result of [11] is an HSS scheme sfor branching programs
under the Decisional Diffie-Hellman (DDH) assumption.1 At a small
additional cost, this HSS scheme admits a public-key variant, which
enables homomorphic computations on inputs that originate from
multiple clients. In this variant, there is a common public key pk
and two secret evaluation keys (ek0, ek1). Each input xi can now
be separately encrypted using pk into a ciphertext cti, such that
cti together with a single evaluation key ekb do not reveal xi. The
homomorphic evaluation can now apply to any set of encrypted
inputs, using only the ciphertexts and one of the evaluation keys.
That is, Eval(ek0, (ct1, . . . , ctn ), P ) + Eval(ek1, (ct1, . . . , ctn ), P ) =
P (x ) mod β.
The HSS scheme from [11] has been later optimized in [13],
where the security of the optimized variants relies on other discrete-
log style assumptions (including a “circular security” assumption for
ElGamal encryption). These HSS schemes for branching programs
can only satisfy a relaxed form of δ-correctness, where the (additive)
reconstruction of the output may fail with probability δ and where
the running time of Eval grows linearly with 1/δ. As negative
byproducts, the running time of Eval must grow quadratically with
the size of the branching program, and one also needs to cope
with input-dependent and key-dependent leakage introduced by
selective failure. The failure probability originates from a share
conversion procedure that locally converts multiplicative shares
into additive shares. See Section 3 for a self-contained exposition
of the HSS construction from [11] that we build on.
The main motivating observation behind this work is that unlike
standard FHE, HSS can be useful even for small computations that
involve short inputs, and even in application scenarios in which
competing approaches based on traditional secure computation
techniques do not apply at all. Coupled with the relatively simple
structure of the group-based HSS from [11] and its subsequent op-
timizations from [13], this gives rise to attractive new applications
that motivate further optimizations and refinements.
Before discussing our contribution in more detail, we would like
to highlight the key competitive advantages of HSS over alternative
approaches.
Optimally compact output. The optimal compactness feature
discussed above enables applications in which the communication
and computation costs of output reconstruction need to be mini-
mized, e.g., for the purpose of reducing power consumption. For
instance, a mobile client may wish to get quickly notified about
live news items that satisfy certain secret search criteria, receiving
a fast real-time feed that reveals only pointers to matching items.
HSS also enables applications in which the parties want to generate
large amounts of correlated randomness for the purpose of speed-
ing up an anticipated invocation of a classical secure computation
protocol. Generating such correlated randomness non-interactively
provides a good protection against traffic analysis attacks that try
to obtain information about the identity of the interacting parties,
1HSS for general circuits can be based on LWE via multi-key FHE [23] or even threshold
FHE [10, 23]. Since these enhanced variants of FHE are even more inefficient than
standard FHE, these constructions cannot get around the efficiency bottlenecks of FHE.
We provide a brief comparison with LWE-based approaches in the full version.
the time of the interaction, and the size of the computation that is
about to be performed. This “low communication footprint” fea-
ture can be used more broadly to motivate secure computation via
FHE. However, the optimal output compactness of HSS makes it the
only available option for applications that involve computing long
outputs (or many short outputs) from short secret inputs (possibly
along with public inputs). We explore several such applications in
this work. Other advantages of group-based HSS over existing FHE
implementations include smaller keys and ciphertexts and a lower
start up cost.
Minimal interaction. HSS enables secure computation protocols
that simultaneously offer a minimal amount of interaction and
collusion resistance. For instance, following a reusable setup, such
protocols can involve a single message from each “input client” to
each server, followed by a single message from each server to each
“output client.” Alternatively, the servers can just publicize their
shares of the output if the output is to be made public. The security
of such protocols holds even against (semi-honest) adversaries who
may corrupt an arbitrary subset of parties that includes only one
of the two servers. Such protocols (a special type of 2-round MPC
protocols) cannot be obtained using classical MPC techniques and
are only known under indistinguishability obfuscation [25], special
types of fully homomorphic encryption [23, 39], or HSS [13].
1.1 Our Contribution
We make two types of contributions, extending both the efficiency
and the applicability of the recent constructions of group-based
HSS from [11, 13].
Optimizations. We introduce several new optimization ideas that
further speed up the previous optimized implementation from [13],
reduce the key and ciphertext sizes, and reduce the rate of leakage
of inputs and secret keys.
Computational optimizations. We show that a slight modification of
the share conversion procedure from [13] can reduce the expected
computational cost by a factor 16 or more, for the same failure
probability. (As in [13], the failure is of a “Las Vegas” type, namely
if there is any risk of a reconstruction error this is indicated by the
outputs of Eval.) Together with additional machine-level optimiza-
tions, we reduce the computational cost of Eval by more than a
factor of 30 compared to the optimized implementation from [13].
Improved key generation. We describe a new protocol for distributing
the key generation for public-key HSS, which eliminates a factor-2
computational overhead in all HSS applications that involve inputs
from multiple clients.
Ciphertext size reduction. We suggest a method to reduce the cipher-
text size of group-based HSS by roughly a factor of 2, relying on a
new entropic discrete-log type assumption. In addition, we show
how to make HSS ciphertexts extremely succinct (at the cost of a
higher evaluation time) using bilinear maps in the full version.
Reducing leakage rate. We suggest several new methods to address
input-dependent and key-dependent failures introduced by the
share conversion procedure, mitigating the risk of leakage at a lower
concrete cost than the previous techniques suggested in [11, 13].
These include “leakage-absorbing pads” that can be used to reduce
Session J1:  OutsourcingCCS’17, October 30-November 3, 2017, Dallas, TX, USA21062
the effective leakage probability from δ to O (δ
) at a low cost. In
particular, unlike earlier leakage reduction techniques from [11,
13], the (centralized or distributed) generation of such leakage-
absorbing pads does not require group operations.
Extensions and further optimizations. We exploit the specific struc-
ture of group-based HSS to enrich its expressiveness, and to improve
the efficiency of homomorphic natural types of functions, including
low-degree polynomials, branching programs, and boolean formu-
las. One particularly useful extension allows an efficient evaluation
of a function that discloses a short bit-string (say, a cryptographic
key) under a condition expressed by a branching program.
Applications. As noted above, our optimizations are motivated
by the observation that there are natural application scenarios in
which HSS is useful even for simple computations. These include
small instances of general secure multiparty computation, as well
as distributed variants of private information retrieval, functional
encryption, and broadcast encryption. We demonstrate the practical
feasibility of our optimized group-based HSS implementation in
the context of such applications by providing concrete efficiency
estimates for useful choices of the parameters.
Secure MPC with minimal interaction. Using public-key HSS, a set
of clients can outsource a secure computation to two non-colluding
servers by using the following minimal interaction pattern: each
client independently sends a single message to the servers (based
on its own input and the public key), and then each server sends a
single message to each client. Alternatively, servers can just publish
shares of the output if the output is to be made public. The resulting
protocol is resilient to any (semi-honest) collusion between one
server and a subset of the clients, and minimizes the amount of
work performed by the clients. It is particularly attractive in the
case where many “simple” computations are performed on the same
inputs. In this case, each additional instance of secure computa-
tion involves just local computation by the servers, followed by a
minimal amount of communication and work by the clients.
Secure data access. We consider several different applications of HSS
in the context of secure access to distributed data. First, we use HSS
to construct a 2-server variant of attribute based encryption, in
which each client can access an encrypted file only if its (public or
encrypted) attributes satisfy an encrypted policy set up by the data
owner. We also consider a 2-server private RSS feed, in which clients
can get succinct notifications about new data that satisfies their
encrypted matching criteria, and 2-server PIR schemes with general
boolean queries. The above applications benefit from the optimal
output compactness feature of HSS discussed above, minimizing
the communication from servers to clients and the computation
required for reconstructing the output.
Unlike competing solutions based on classical secure compu-
tation techniques, our HSS-based solutions only involve minimal
interaction between clients and servers and no direct interaction
between servers. In fact, for the RSS feed and PIR applications, the
client is free to choose an arbitrary pair of servers who have access
to the data being privately searched. These servers do not need to be
aware of each other’s identity, and do not even need to know they
are participating in an HSS-based cryptographic protocol. Indeed,