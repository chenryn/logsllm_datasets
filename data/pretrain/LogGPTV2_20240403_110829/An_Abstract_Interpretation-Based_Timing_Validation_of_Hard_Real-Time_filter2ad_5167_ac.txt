reliability. It was able to handle real-life sized programs on
common hardware (1GHz Athlon). The evaluation process
was performed by Airbus France personnel and did not re-
quire an operator highly specialized in program analysis.
The graphical visualization features of the tool with re-
gard to WCET distribution over all called functions and
cycle-wise pipeline evolution were very helpful. The ana-
lyzer was able to deliver a safe and tight WCET prediction.
The results were typically better than those obtained with
the legacy method used for comparison. The application is
comprised of 12 tasks whose individual WCET is required.
For a given version of the application, Table 1 compares
the WCETs computed by Airbus’ method with the results
of AbsInt’s aiT. The pronounced improvements in preci-
sion are due to the fact that the legacy method had to be
overly conservative in its WCET computations. aiT can be
more precise due to its detailed modeling of the hardware
features, but its results are still correct upper bounds of the
(unknown) true worst-case execution times.
Since the true WCETs cannot be known in general, the
only way to check results from WCET computation meth-
ods is to measure real executions (which give times proba-
bly below the real WCET) and compare the measurements
against the analyses results. Doing this, it was veriﬁed that
the predicted WCETs are greater than, but not far away
from, observed running times.
The code analyzed didn’t have to be instrumented in or-
der to apply the tool. No changes in the development pro-
Figure 5. Fragment of a call graph visualiza-
tion
3.1. Practical Experiences
In the course of the DAEDALUS project, the WCET
analyzer was evaluated by Airbus France in order to as-
sess its usefulness. This procedure involved an evaluation
of the precision of the predicted WCET. Another aspect
was usability, i. e., whether a “normal” developer can use
the tool on common computer hardware. Other aspects in-
cluded scalability and performance on programs of real-life
size and the overall reliability of the tool (i. e., no program
crashes, etc).
The evaluation was done on a representative benchmark
for the most time-critical avionics software. This bench-
mark consists of twelve tasks activated in round-robin fash-
ion by a non-preemptive scheduler. Each task is made up
of hundreds of smaller components called nodes and func-
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:28:15 UTC from IEEE Xplore.  Restrictions apply. 
Task Airbus’ method
aiT’s results
improvement
precision
1
2
3
4
5
6
7
8
9
10
11
12
6.11 ms
6.29 ms
6.07 ms
5.98 ms
6.05 ms
6.29 ms
6.10 ms
5.99 ms
6.09 ms
6.12 ms
6.00 ms
5.97 ms
5.50 ms
5.53 ms
5.48 ms
5.61 ms
5.54 ms
5.49 ms
5.35 ms
5.49 ms
5.45 ms
5.39 ms
5.19 ms
5.40 ms
10.0 %
12.0 %
9.7 %
6.2 %
8.4 %
12.7 %
12.3 %
8.3 %
10.5 %
11.9 %
13.5 %
9.5 %
Table 1. Comparison between Airbus’ legacy
method and aiT
cess of the programs to be analyzed were necessary.
The results of the evaluation are very encouraging. We
believe that the WCET tool not only can be used in verify-
ing that WCET constraints are met but also in earlier stages
of the development process as well. At a stage when the
software is already available, but working hardware is not,
the tool can be used for a performance evaluation. Based on
the contributions of the program parts to the WCET one can
make design decisions, e. g., with respect to static schedul-
ing or code/data placement. The effects on the cache and
pipeline can be viewed using the visualization options of
the tool and causes for unexpected local timing behavior
identiﬁed.
4. Conclusions
We have presented a tool to obtain WCETs for time-
critical real-time systems. The tool is based on static anal-
ysis techniques and is thus applicable without requiring the
real hardware of the system. The tool was evaluated in a
real-life setting by Airbus France and the results are very
promising. We have shown that our tool not only can pro-
vide safe and tight WCET bounds but that it can also be
applied to realistically sized programs and environments as
well.
4.1. Future Work
The methodology underlying the WCET analyzer for the
ColdFire 5307 is also being used to implement a WCET an-
alyzer for the PowerPC 755. This processor is much more
sophisticated, featuring super-scalarity, out-of-order execu-
tion, branch prediction and folding, and truly parallel exe-
cution units. A prototype of the WCET analyzer for Pow-
erPC 755 is currently undergoing an extensive veriﬁcation
process.
We plan to model more processors for further WCET an-
alyzers in the same way. Also, a more formal way to specify
the pipeline model and derive its implementation is being
investigated.
4.2. Related Work
A vast body of literature on WCET determination exists.
We have only listed references dealing with complex pro-
cessors containing all features considered in combination,
not architectural features in isolation.
Li et al. suggest a solution using integer linear program-
ming [8]. Both cache and pipeline behavior prediction
are formulated as a single linear program. The i960KB is
investigated, a 32-bit microprocessor with a 512 byte di-
rect mapped instruction cache and a fairly simple pipeline.
Only structural hazards need to be modeled, thus keep-
ing the complexity of the integer linear program moder-
ate. Variable execution times, branch prediction, and in-
struction prefetching are not considered at all. Using this
approach for super-scalar pipelines does not seem very
promising, considering the analysis times reported in the
article. Nonetheless, the description of the worst-case path
through the program via ILP is an elegant method and can
be efﬁcient if the size of the ILP is kept small. This is the
case in our tool.
Lundqvist and Stenstr¨om present an integrated approach
for obtaining WCET bounds through the simulation of the
pipeline in [9, 10]. They extend a pipeline simulator to
handle unknown values in inputs. We share conceptual
similarities with this approach in that we perform a cycle-
wise evolution of a pipeline (model). In contrast to our ap-
proach, Lundqvist and Stenstr¨om use an integrated method
in which value analysis for register/memory contents and
execution time computation are parts of the same simula-
tion.
If the simulation cannot determine a branch condi-
tion exactly due to dependencies on unknown (input) val-
ues, both branches have to be simulated. This method does
not guarantee termination of the analysis, but offers the ad-
vantage of sometimes determining loop bounds and/or re-
cursion bounds “for free” (providing they don’t depend on
unknown input values in a non-trivial way). However, we
feel that this analysis is very costly due to the huge amount
of data that has to be kept for each branch followed.
In contrast, our method does not retain information like
register or memory contents in the pipeline analysis phase,
contents that have already been determined in the value
analysis to predict conditional and computed branches, for
example. In [10] experiments with a PowerPC-like archi-
tecture are conducted for small example programs using an
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:28:15 UTC from IEEE Xplore.  Restrictions apply. 
[10] T. Lundqvist and P. Stenstr¨om. An Integrated Path and Tim-
ing Analysis Method Based on Cycle-Level Symbolic Ex-
ecution. Real-Time Systems, 17(2/3):183–207, November
1999.
[11] F. Martin, M. Alt, R. Wilhelm, and C. Ferdinand. Analysis
of Loops. In Proceedings of the International Conference
on Compiler Construction (CC’98). Springer-Verlag, 1998.
[12] F. Nielson, H. R. Nielson, and C. Hankin. Principles of Pro-
gram Analysis. Springer-Verlag, 1999.
[13] J. Schneider and C. Ferdinand. Pipeline Behavior Predic-
tion for Superscalar Processors. Technical report, Saarland
University, May 1999.
[14] J. Schneider and C. Ferdinand. Pipeline Behavior Predic-
tion for Superscalar Processors by Abstract Interpretation.
In Proceedings of the ACM SIGPLAN Workshop on Lan-
guages, Compilers and Tools for Embedded Systems, vol-
ume 34, pages 35–44, May 1999.
[15] H. Theiling. Extracting Safe and Precise Control Flow from
Binaries. In Proceedings of the 7th Conference on Real-Time
Computing Systems and Applications, Cheju Island, South
Korea, 2000.
[16] H. Theiling. Generating Decision Trees for Decoding Bi-
naries.
In Proceedings of the ACM SIGPLAN Workshop
on Languages, Compilers and Tools for Embedded Systems,
Snowbird, Utah, USA, June 2001.
[17] H. Theiling.
ILP-based Interprocedural Path Analysis.
In Proceedings of the Workshop on Embedded Software,
Grenoble, France, October 2002.
[18] H. Theiling and C. Ferdinand. Combining Abstract Interpre-
tation and ILP for Microarchitecture Modelling and Program
Path Analysis. In Proceedings of the 19th IEEE Real-Time
Systems Symposium (RTSS), Madrid, Spain, 1998.
extended PSIM simulator with simple reservation tables for
instructions. All in all, it is not clear how well this method
scales up to programs of realistic size.
In contrast to Lundqvist and Stenstr¨om’s integrated ap-
proach, Engblom presents a WCET tool in [2] with a clear
separation of all the analysis modules. The modules com-
municate using interface data structures. One main com-
ponent is a simulator that estimates the execution time for
a given sequence of instructions. These timing estimates
are composed to form the execution time of the entire pro-
gram. The quality of the WCET obtained is greatly inﬂu-
enced by the quality of the simulator used. Cache behavior
prediction is not incorporated in the tool as the addressed
targets do not have any caches. This eliminates the prob-
lem of cache and pipeline interaction, which becomes more
difﬁcult with increasingly complex pipelines, prefetching,
and branch prediction. The author comes to the conclusion
that “. . . out-of-order processors are deﬁnitely too complex
to model with current techniques.”
References
[1] P. Cousot and R. Cousot. Abstract Interpretation: A Uniﬁed
Lattice Model for Static Analysis of Programs by Construc-
tion or Approximation of Fixpoints. In Proceedings of the
4th ACM Symposium on Principles of Programming Lan-
guages, pages 238–252, Jan. 1977.
[2] J. Engblom. Processor Pipelines and Static Worst-Case
Execution Time Analysis. PhD thesis, Uppsala University,
2002.
[3] C. Ferdinand. Cache Behavior Prediction for Real-Time
Systems. PhD thesis, Saarland University, 1997.
[4] C. Ferdinand, R. Heckmann, M. Langenbach, F. Martin,
M. Schmidt, H. Theiling, S. Thesing, and R. Wilhelm. Re-
liable and precise WCET determination for a real-life pro-
cessor. In Proceedings of EMSOFT 2001, First Workshop
on Embedded Software, volume 2211 of Lecture Notes in
Computer Science, 2001.
[5] R. Heckmann and S. Thesing. Cache and Pipeline Analysis
for the ColdFire 5307. Technical report, Saarland Univer-
sity, 2001.
[6] M. Inc. MCF5307 ColdFire Integrated Microprocessor
User’s Manual. Motorola Inc., Aug. 2000. MCF5307UM/D,
Rev. 2.0.
[7] M. Langenbach, S. Thesing, and R. Heckmann. Pipeline
Modeling for Timing Analysis. Proceedings of the 9th In-
ternational Static Analysis Symposium, 2002.
[8] Y.-T. S. Li, S. Malik, and A.Wolfe. Cache Modeling for
Real-Time Software: Beyond Direct Mapped Instruction
Caches. IEEE Real-Time Systems Symposium, January 1997.
[9] T. Lundqvist and P. Stenstr¨om. Integrating Path and Timing
Analysis Using Instruction-Level Simulation Techniques. In
F. Mueller and A. Bestavros, editors, Proceedings of the
ACM SIGPLAN Workshop Languages, Compilers and Tools
for Embedded Systems (LCTES), volume 1474 of Lecture
Notes in Computer Science, pages 1–15, 1998.
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:28:15 UTC from IEEE Xplore.  Restrictions apply.