CFSD
Sony Rootkit
Vanquish
4m+2m
4m+2s
6m+12m
Hacker Defender
5m+27m
14G
2.8G
25M
4.4G
7.4G
Uay backdoor
4m+25s
117M
2
1
4
5
4
11
4
5
1
1
3
4
4
Data, Call:SetWindowsHookEx(WH KEYBOARD LL,...)
Data, Call:SetWindowsHookEx(WH CALLWINDPROC,...)
Code, Call:WriteProcessMemory
Data, Call:FltRegisterFilter
Data, Direct, Static Point:KeServiceDescriptorTable
11
Code, Direct, Static Point:GetProcAddress
1
2
Code, Call:NtWriteVirtualMemory
Data, Direct, Static Point:NdisRegisterProtocol
Table 2. Summarized experimental results
a system thread with the thread entry provided by the
caller. Thus, these three hooks are normal hooks. The
other two are suspicious, and their hook graphs are sim-
ilar. We show one graph in Figure 4. We also show
the original hardware-level graph in Figure 6 in the Ap-
pendix.
As we can see in Figure 4, there are two branches
at the bottom. The left branch describes how the hook
site L was inferred, and the right branch presents how
the hook H was formulated. From the top of the right
branch, we can see that H originated from the output of
a function call NdisAllocateMemoryWithTag. This ker-
nel function is used to allocate a memory region in the
kernel space. According to the function’s semantics, this
output has to be the address of the allocated memory re-
gion. This address is ﬁnally implanted into the hook site
L.
From the top of the left branch, we observe that L
is derived from the output of a function call NdisReg-
isterProtocol. This kernel function registers a network
protocol. According to the function semantics, we be-
lieve this output is the protocol handle in the second ar-
gument. This handler points to an internal data structure
maintained by the Windows kernel. Then we can see the
instruction (at uay.sys+1695) reads a ﬁeld with the off-
set 0x10 in this data structure. The obtained value (v1)
is then used as a pointer to read another value (v2) from
the offset 0x10 in the data structure pointed by v1, in the
subsequent instruction (at uay.sys+16a0). Then, the in-
struction (at uay.sys+1589) adds v2 with 0x40, and the
resulting value is eventually used as the hook site L. We
believe that this sample actually walks into this internal
data structure that it obtains from NdisRegisterProtocol,
and locates the designated hook site L. Interestingly, the
deﬁnition of the data structure for the protocol handle
created from NdisRegisterProtocol is not released in any
documentation from Microsoft, but this malware sample
seems to be able to understand this data structure, and
knows how to locate the desired hook site from it.
The hook graph for another suspicious hook is very
similar to this one, except that it adds v2 with 0x10. With
the knowledge of how this internal structure is deﬁned,
we would be able to tell which two functions this mal-
ware sample actually hooked.
By analyzing this sample using HookFinder, we are
able to unveil a novel mechanism for intercepting the
NDIS.sys+827f: mov 0xc(%ebp), %eax
Call: NdisRegisterProtocol
kernel32.dll+119ab4: mov %eax, (%esi)
Call: GetProcAddress
[0x61f81c]=0x77dd6bf0
Impacted Address
NDIS.sys+828c: mov %ebx, (%eax)
Call: NdisRegisterProtocol
[0xf56f2d68]=0x81dd0f28
NDIS.sys+829a: mov %ecx,0x10(%ebx)
Call: NdisRegisterProtocol
uay.sys+168d: mov 0xfffffffc(%ebp), %eax
[0x81dd0f38]=0x81e95ca8
uay.sys+1695: mov 0x10(%eax), %esi
uay.sys+16a0: mov 0x10(%esi), %esi
kernel32.dll+ac81: mov 0xc(%ebp), %eax
vanquish.dll+2834: push $0x1ae4c22
Call: GetProcAddress
[0x61f824]=0x1ae4c22
Simple Propagation
vanquish.dll+216d: mov 0xc(%ebp), %edx 
vanquish.dll+2170: sub 0x8(%ebp), %edx 
vanquish.dll+1ea7: add $0x1,%eax
vanquish.dll+2173: sub $0x5, %edx
Simple Propagation
vanquish.dll+2176: mov %edx, 0xfffffff8(%ebp) 
[0x61f810]=0x89d0e02d
Simple Propagation
Impacted Address
vanquish.dll+217f: mov 0xfffffff8(%ebp), %ecx
uay.sys+1589: lea 0x40(%esi), %eax
Simple Propagation
Call: NdisAllocateMemoryWithTag
NDIS.sys+115b: mov %eax, (%ecx)
[0xf56f2cc4]=0x81e563a8
vanquish.dll+2182: and $0xff, %ecx
vanquish.dll+218b: mov %cl, 0x1(%edx) 
[0x1ae928d]=0x2d
Impacted Address
Simple Propagation
vanquish.dll+1ea0: mov (%ecx), %dl 
uay.sys+fcd: mov %eax, (%esi)
[0x81ed3548]=0x81e563a8
vanquish.dll+1ea2: mov %dl, (%eax) 
[0x77dd6bf1]=0x2d
NDIS.sys+22faa: call *0x40(%eax)
advapi32.dll+6bf0: jmp 0x89d0e032
Figure 4. Hook Graph for Uay
Figure 5. Hook Graph for Vanquish
network stack employed by malware. That is, malware
can tamper with the function pointers in some kernel
data structures associated with registered network pro-
tocols. With this important understanding, we can ver-
ify and protect the integrity of these data structures, to
defend against this kind of hooking mechanism.
Vanquish HookFinder identiﬁed 11 code hooks in to-
tal for Vanquish. After reviewing the hook graphs, we
found that Vanquish hooked four unique APIs: Reg-
CloseKey, LoadLibraryExW, RegEnumKeyW and Re-
gEnumKeyExW. Thus, multiple hooks may correspond
to one API hooking, because Vanquish installs one hook
per process for that API.
We show a hook graph for hooking RegCloseKey in
Figure 5. The other hook graphs are similar. First, we
can see the bottom node. This is the actual instruc-
tion Vanquish injected into the system code to set up
the hook. It is a jmp instruction, and its address is the
entry point of RegCloseKey. The rest of the graph shows
how the jump target of this instruction is formulated.
Here the address of this jump target (i.e., 0x77dd6bf1)
is the hook site L, and the content in L is H (i.e.,
0x89d0e032). Again, the left branch represents how L
was inferred, and the right branch indicates how H was
formulated.
The left branch starts with the output of function call
GetProcAddress. This function returns the actual func-
tion address, given a function name. Therefore, the
source of the left branch is the address of a function
call, and the actual value is 0x77dd6bf0, which is the
address for RegCloseKey. As we follow the links down,
we can see this address is added by 1 and used as L.
Obviously, the offset 1 is for the opcode of jmp. Now
for the right branch, we can see that it originates from
an immediate (0x1ae4c22) pushed onto the stack. This
value is ﬁrst subtracted by the address for RegCloseKey,
and then subtracted by 5. Then the value is “and” with
0xff to get the lowest byte, and this byte is written to the
hook site L directly. Obviously, these steps are used to
calculate the relative address for the jmp instruction.
5 Discussion
In this section, we discuss the resilience of our system
to various evasion techniques that malware writers may
exploit.
Exploiting Control Dependency The basis of our ap-
proach is to identify all impacts made by the malicious
code, and keep track of the impact propagation via data
dependency. It is natural for malware writers to think of
exploiting control dependency, to evade our detection.
For example, the malicious code may embed a complex
switch statement like below to cut the data dependency
between a and b.
switch(a) {
case 1: b=1; break;
case 2: b=2; break;
...
}
This evasion is not viable. This is because in the im-
pact marker, we thoroughly mark all the initial impacts
(i.e., memory and register writes) made by the malicious
code. Thus, the output b will be marked anyway.
Not Exhibiting Hooking Behaviors When Tested
Malware may not exhibit hooking behavior during our
dynamic analysis. It may detect that it is running in our
analysis environment and stay inactive if indeed. For
example, it may run a redpill test [25], observe consid-
erable slowdown on performance, or perform more so-
phisticated methods to determine this fact. Moreover,
some malware only performs malicious behavior under
certain conditions, such as on a speciﬁc date. This is a
common shortcoming of dynamic analysis. The current
implementation of HookFinder can deal with some com-
mon detection methods. We specially instrument several
instructions like sidt to return deceitful results to mal-
ware, in order to bypass the redpill test. We also slow
down the frequency of the PIT timer in QEMU to dis-
guise the performance slowdown of our emulated sys-
tem. A more comprehensive solution to this problem
would be to explore multiple execution paths that de-
pend upon certain conditions. Some research work has
been done in this direction. Moser et al. [17] and Brum-
ley et al. [3] also used QEMU to build malware analysis
systems, which are able to uncover hidden behaviors of
malware by exploring multiple execution paths. We will
leave incorporating these techniques into HookFinder as
future work.
Evading through “return-into-libc” In this paper,
we consider that malware registers a function in its own
code as a hook. Potentially, malware may not neces-
sarily register its own function. It can put the address
of certain function in system code into the hook site,
exploiting the functionality of that function to perform
some tasks, without being detected by HookFinder. This
potential evasion resembles “return-into-libc” in buffer
overﬂow attacks [18]. We do not consider this kind of
evasion in the current implementation of HookFinder, as
it is generally difﬁcult to realize, in terms of ﬁnding good
candidate functions and preparing compatible stack lay-
out. We would like to extend our detection strategy to
cope with this potential evasion in our future work.
Subverting or Misleading HookFinder Built on top
of an emulator, HookFinder provides strong isolation
such that it is unlikely for the malware running inside
to interfere with HookFinder and the host system. How-
ever, some study shows the possibility of subverting the
entire emulated environment by exploiting buffer over-
ﬂows and integer bugs [21]. This problem can be ad-
dressed by ﬁxing these bugs. HookFinder may also be
misled. HookFinder identiﬁes and analyzes hooks by
examining both hardware-level and OS-level informa-
tion. Hardware-level information can be trustworthy,
because the underlying hardware relies on it to run the
guest system. However, OS-level information can be
spurious. Malware can ﬁnd numerous methods to hijack
the semantics extractor. Especially, the kernel module
inserted into the guest system can be an obvious tar-
get. In the future release of HookFinder, we are going
to develop a more robust and secure semantics extractor.
More speciﬁcally, we will reason about OS-level seman-
tics completely from outside, using reliable and faithful
states of the emulated system.
6 Related Work
Hook Detection Researchers have developed several
tools, such as VICE [4], System Virginity Veriﬁer [24],
and IceSword [13], to detect the existence of hooks in
the system. With prior knowledge how malicious code
usually set hooks, these tools examine known memory
regions for suspicious entries. The common examined
places are system service descriptor table (i.e., SSDT)
exported by the OS kernel, interrupt descriptor table
(i.e., IDT) that stores interrupt handlers, import address
tables (i.e., IAT) and export address tables (i.e., EAT)
of important system modules. Assuming that important
system modules do not modify their code (with a few ex-
ceptions), System Virginity Veriﬁer checks if code sec-
tions of important system DLLs and drivers remain the
same in memory as those in the corresponding binaries
on disk. In nature, these tools fall into misuse detection,
and thus cannot detect hooks in previously unknown
memory regions. In comparison, our approach captures
the intrinsic characteristics of hooking behaviors: one of
the malware’s impacts has to be used to redirect the sys-
tem execution into the malicious code. Therefore, it can
identify unknown hooking behaviors. Moreover, it also
provides insights about the hooking mechanisms.
Dynamic Taint Analysis The ﬁne-grained impact
analysis resembles the dynamic taint analysis technique,
which is proposed to solve and analyze many other secu-
rity related problems. Many systems [8, 9, 19, 22, 28] de-
tect exploits by tracking the data from untrusted sources
such as the network being misused to alter the control
ﬂow. Other systems [7, 10, 33] make use of this tech-
nique to analyze how sensitive information is processed
by the system. Chow et al. applies dynamic taint anal-
ysis to understand the lifetime of sensitive information
(such as password) in operating systems and large pro-
grams [7]. Egele et al. utilize this technique to ana-
lyze BHO-based spyware behavior [10]. Yin et al. also