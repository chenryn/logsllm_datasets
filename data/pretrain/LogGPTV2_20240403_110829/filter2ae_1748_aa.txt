# re2cæµ…æŽ¢
|
##### è¯‘æ–‡å£°æ˜Ž
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŽŸæ–‡ä¸ºå‡†ã€‚
## å‰è¨€
æœ¬æ–‡ä¸»è¦ä¾æ®NFAs with Tagged Transitions, their Conversion to Deterministic Automata
and Application to Regular Expressions Ville Laurikari Helsinki University of
Technology Laboratory of Computer Science PL 9700, 02015 TKK, Finland
[PI:EMAIL](mailto:PI:EMAIL)è¿™ç¯‡è®ºæ–‡ä»¥åŠre2cè‡ªèº«ä»£ç è¿›è¡Œæè¿°ã€‚
## EXPæŠ½è±¡åŒ–
re2cçš„æŠ½è±¡åŒ–è¿‡ç¨‹å’Œæˆ‘ä»¬ç¨‹åºåˆ†æžç†è®ºä¸­çš„å†…å®¹æœ‰å¾ˆé«˜çš„ä¸€è‡´æ€§ã€‚é¦–å…ˆæ˜¯æœ€åŸºæœ¬çš„ç»“æž„å•å…ƒEXPã€‚æ¯ä¸€å¥ä»£ç éƒ½æ˜¯EXPï¼Œè€Œè¿™äº›EXPå¾€å¾€å¯ä»¥è¿›ä¸€æ­¥åˆ†è§£ï¼šå¦‚123+234ï¼Œåœ¨ç¨‹åºåˆ†æžç†è®ºçš„ç»“æž„ä¸Šçš„æ“ä½œè¯­ä¹‰éƒ¨åˆ†ï¼Œæˆ‘ä»¬æå‡ºäº†è¿™æ ·çš„åˆ†æžæ–¹æ³•ï¼šA[a1
opa a2]Ïƒ = A[a1]Ïƒ opa
A[a2]Ïƒã€‚è¿™é‡Œä¹Ÿæ˜¯ä¸€æ ·ï¼ŒåŒæ—¶è¿˜å¢žåŠ äº†å®žé™…åˆ†æžçš„ç»†èŠ‚ï¼šé¦–å…ˆï¼Œæˆ‘ä»¬å°†123+234æ•´ä¸ªEXPè½¬æ¢æˆEXP+EXPã€‚éšåŽå¯¹ç¬¬ä¸€ä¸ªEXPè¿›è¡ŒåŒæ ·çš„åˆ†è§£ã€‚ç”±äºŽ123ä¸åŒ…å«opæ‰€ä»¥è½¬æ¢æˆVARã€‚å¯¹äºŽVARæˆ‘ä»¬è¿›è¡ŒæŒ‰ä½è¯»å–è¯†åˆ«ï¼šå°†ç¬¬ä¸€ä½å’ŒåŽç»­åˆ†å¼€ã€‚ç¬¬ä¸€ä½çœ‹ä½œDGTï¼ŒåŽç»­çœ‹ä½œæ–°çš„VARã€‚ç›´åˆ°å°†123å…¨éƒ¨è¯†åˆ«ã€‚éšåŽå¯¹234è¿›è¡ŒåŒæ ·çš„æ“ä½œã€‚
å³
EXP->EXP+EXP->VAR+EXP->1 VAR +EXP ->12 VAR +EXP ->123+EXP->123+VAR->123+2
VAR->123+23 VAR ->123+234
## NFAè‡ªåŠ¨æœº
NFA Nondeterministic Finite Automaton éžç¡®å®šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœº
æœ‰é™çŠ¶æ€è‡ªåŠ¨æœºã€‚é¦–å…ˆå¯¹çŠ¶æ€è¿›è¡Œå®šä¹‰ï¼ŒçŠ¶æ€æ˜¯è‡ªåŠ¨æœºæ¯ä¸€æ¬¡å¤„ç†ä¿¡å·çš„ç»“æžœï¼Œæ¯ä¸€æ¬¡æŽ¥æ”¶ä¿¡å·åŽä¼šè¿›å…¥æ–°çš„çŠ¶æ€ï¼Œè¿™ä¸ªçŠ¶æ€å¯èƒ½æ˜¯å¾ªçŽ¯çŠ¶æ€ï¼ˆå¤„ç†ä¿¡å·åŽä¹‹å‰çš„å¤„ç†æœºåˆ¶ä¾æ—§é€‚ç”¨ï¼‰ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸‹ä¸€ä¸ªçŠ¶æ€ï¼ˆå·²ç»ä¸é€‚ç”¨äºŽç›¸åŒçŠ¶æ€çš„å¤„ç†ï¼Œéœ€è¦è¿›å…¥æ–°çš„çŠ¶æ€ï¼Œåº”ç”¨æ–°çš„å¤„ç†æœºåˆ¶ï¼‰
è¦å®žçŽ°ä¸Šé¢æ‰€æè¿°çš„çŠ¶æ€ï¼Œéœ€è¦è¿›è¡Œç›¸åº”çš„è¿ç®—ï¼Œå¯¹äºŽåº”ç”¨æ–°çš„å¤„ç†æœºåˆ¶çš„è¿ç®—ä¸ºç»„åˆè¿ç®—ï¼Œç”¨RSè¡¨ç¤ºã€‚å¯¹äºŽä¾æ—§ä½¿ç”¨å½“å‰æœºåˆ¶çš„è¿ç®—ä¸ºé‡å¤è¿ç®—ï¼Œç”¨R^*è¡¨ç¤ºã€‚é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰æ›¿æ¢è¿ç®—ï¼šä»Žå½“å‰çŠ¶æ€è½¬æ¢åˆ°ä¸‹ä¸€çŠ¶æ€å¯ä»¥åº”ç”¨ä¸¤ç§ä¸åŒçš„å¤„ç†æœºåˆ¶ï¼Œæ¯”å¦‚è¯´ä¸€ä¸ªEXPå¯ä»¥å¤„ç†æˆVARï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ªå‡½æ•°çš„è°ƒç”¨ã€‚ç”¨R|Sè¡¨ç¤ºã€‚
## DFAè‡ªåŠ¨æœº
DFA Deterministic Finite Automaton ç¡®å®šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœº
å…¶ç¡®å®šæ€§åœ¨äºŽè¯¥æ¨¡åž‹ç”¨äºŽè§£å†³å·²çŸ¥å­—ç¬¦ä¸²æ˜¯å¦æ»¡è¶³è‡ªåŠ¨æœºè®¾ç½®ã€‚å³æ»¡è¶³æ¡ä»¶å°±ç»§ç»­å¦åˆ™é€€å‡ºï¼Œè¿™ç§æ˜¯å°±æ˜¯æ˜¯ä¸æ˜¯å°±æ˜¯ä¸æ˜¯çš„è®¾ç½®ä½¿å¾—è‡ªåŠ¨æœºåªå­˜åœ¨ä¸€æ¡è·¯å¾„ï¼Œä¸ä¼šå‡ºçŽ°R|Sçš„è¿ç®—ã€‚è¿™ä¸ä»£è¡¨DFAè‡ªåŠ¨æœºä¸€æ¬¡åªèƒ½åº”ç”¨ä¸€ç§å¤„ç†æœºåˆ¶ï¼ŒDFAè‡ªåŠ¨æœºå’ŒNFAè‡ªåŠ¨æœºå®žé™…å¯ä»¥ç›¸äº’è½¬åŒ–ï¼ŒDFAè‡ªåŠ¨æœºæ¯ä¸€ä¸ªçŠ¶æ€çš„å¤„ç†æœºåˆ¶æ˜¯NFAç›¸å¯¹åº”å¤„ç†æœºåˆ¶çš„é›†åˆã€‚
å³å¯¹äºŽä¸‹é¢ä¸€ä¸ªNFAè‡ªåŠ¨æœºï¼Œæˆ‘ä»¬å¯ä»¥è½¬æ¢æˆå¦‚å›¾äºŒæ‰€ç¤ºçš„DFAè‡ªåŠ¨æœº
å›¾ä¸€
å›¾äºŒ
å›¾äºŒä¸­çš„0åŒ…å«å›¾ä¸€ä¸­çš„0,1,2ï¼šåœ¨æŽ¥æ”¶åˆå§‹çŠ¶æ€æ—¶ï¼Œè¿›å…¥NFAçš„0ï¼Œä¹Ÿå°±æ˜¯DFAä¸­çš„0(0)ã€‚æŽ¥æ”¶åˆ°aåˆ™è¿›å…¥NFAçš„1ï¼Œä¹Ÿå°±æ˜¯DFAä¸­çš„0(1)ã€‚æŽ¥æ”¶åˆ°båˆ™ç›´æŽ¥è¿›å…¥NFAçš„3ï¼Œä¹Ÿå°±æ˜¯DFAçš„1(3)ã€‚å…¶ä½™éƒ¨åˆ†ç›¸ä¼¼ã€‚æ‰€ä»¥DFAçš„å¤„ç†æœºåˆ¶æ˜¯NFAå¤„ç†æœºåˆ¶çš„é›†åˆã€‚
## TNFAè‡ªåŠ¨æœº
NFA with tagged transitionså°±æ˜¯åœ¨NFAçš„åŸºç¡€ä¸ŠåŠ ä¸Šäº†tagå…ƒç´ ï¼Œç”¨äºŽè®°å½•è‡ªåŠ¨æœºå¤„ç†è¿‡ç¨‹ã€‚
ä¹Ÿå°±æ˜¯TNFAä¸ä»…åŒ…å«NFAä¸­æœ‰çš„æœ‰é™ä¸ªçŠ¶æ€ï¼Œæœ‰é™ä¸ªç¬¦å·ï¼Œè¿ç®—å…³ç³»ï¼Œåˆå§‹çŠ¶æ€ï¼Œç»“æŸçŠ¶æ€ï¼Œè¿˜åŒ…å«æœ‰é™ä¸ªæ ‡ç­¾ã€‚
åœ¨å¤„ç†ä¸€ä¸ªè¾“å…¥æ—¶ï¼Œé¦–å…ˆæŽ¥æ”¶å‰ï¼Œè‡ªåŠ¨æœºå¤„äºŽä¸Šä¸€ä¸ªçŠ¶æ€ï¼ŒæŽ¥æ”¶è¾“å…¥æ—¶ï¼Œè®¾ç½®tagåœ¨å½“å‰å¤„ç†æœºåˆ¶ï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªçŠ¶æ€
è™½ç„¶åŠ ä¸Šäº†Tagï¼Œä½†æ˜¯NFAçš„ä¸ç¡®å®šæ€§ä¾æ—§å­˜åœ¨ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æŠŠTNFAè½¬æ¢æˆDA deterministic automataã€‚
é¦–å…ˆï¼Œæˆ‘ä»¬è¦æ‰¾åˆ°åˆå§‹çŠ¶æ€ï¼Œæ ¹æ®TNFAçš„å¤„ç†æœºåˆ¶ç¡®å®šTDFAçš„åˆå§‹çŠ¶æ€ã€‚å†æ ¹æ®æ‰€æœ‰çš„å¤„ç†æœºåˆ¶ï¼Œå°†å¤„ç†æœºåˆ¶è¿›è¡Œåˆ†ç±»é›†åˆï¼Œå½¢æˆTDFAçš„å¤„ç†æœºåˆ¶ã€‚æœ€åŽç¡®å®šé€€å‡ºçŠ¶æ€ã€‚
## TDFAè‡ªåŠ¨æœº
åŒæ ·çš„TDFAæ˜¯åŠ ä¸Šäº†tagçš„DFAã€‚
ç›¸è¾ƒäºŽTNFAï¼ŒTDFAä¸ä»…åŒ…å«æœ‰é™ä¸ªçŠ¶æ€ï¼Œæœ‰é™ä¸ªç¬¦å·ï¼Œåˆå§‹çŠ¶æ€ï¼Œæœ€ç»ˆçŠ¶æ€ï¼Œè¿˜åŒ…å«è¿‡åº¦å‡½æ•°ï¼Œåˆå§‹åŒ–å’Œç»ˆæ­¢åŒ–ã€‚
###  tagçš„ä½œç”¨
å½“æˆ‘ä»¬æƒ³è¦åŒ¹é…[0-9] _[a-z]\_
çš„æ—¶å€™ï¼Œåœ¨[0-9]å’Œ[a-z]ä¹‹é—´çš„å¤„ç†æœºåˆ¶çš„è½¬æ¢åœ¨æ²¡æœ‰tagçš„æ—¶å€™ä¸èƒ½æ˜Žç¡®æ ‡è¯†å‡ºæ¥ã€‚åŠ å…¥tagåŽï¼Œæˆ‘ä»¬ä¸å†éœ€è¦é€šè¿‡æ£€æµ‹åˆ°éž[0-9]åˆ‡æ¢å¤„ç†æœºåˆ¶ï¼Œå†é‡å¤è¯»å–è¯¥éž[0-9]çš„ä¿¡å·ã€‚
å½“ç„¶ï¼Œtagçš„æ·»åŠ ä¸å…·æœ‰å”¯ä¸€æ€§ï¼Œæ¯”å¦‚æ­£åˆ™è¡¨è¾¾å¼ä¸º(a|b) _t_0 b (a|b)\_
çš„å¤„ç†æœºåˆ¶ï¼Œå¯¹äºŽabbaä¿¡å·ï¼Œt_0å¯ä»¥æ ‡è®°åœ¨ç¬¬ä¸€ä¸ªaåŽé¢ï¼Œä¹Ÿå¯ä»¥æ ‡è®°åœ¨ç¬¬ä¸€ä¸ªbåŽé¢ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬æ·»åŠ ä¸€é¡¹åŽŸåˆ™ä½¿å¾—tagå”¯ä¸€ã€‚å¯¹äºŽåŒ…å«é‡å¤å¤„ç†æœºåˆ¶çš„åŒ¹é…ï¼Œæˆ‘ä»¬å°½å¯èƒ½çš„å¤šåŽ»å®žçŽ°é‡å¤ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œé™¤éžå½“å‰å¤„ç†æœºåˆ¶ä¸èƒ½åº”ç”¨ï¼Œæˆ–è€…åº”ç”¨å½“å‰åŒ¹é…æœºåˆ¶åŽæ— æ³•ç»§ç»­åŒ¹é…ï¼Œå¦åˆ™ä½¿ç”¨å½“å‰å¤„ç†æœºåˆ¶ã€‚
## ä¾‹å­
0æ˜¯åˆå§‹çŠ¶æ€ï¼ŒæŽ¥æ”¶ä¿¡å·åŽï¼Œå¯èƒ½åº”ç”¨åŒæ ·çš„å¤„ç†æœºåˆ¶æˆ–è€…è¿›å…¥ä¸‹ä¸€çŠ¶æ€ã€‚æ‰€ä»¥TDFAçš„åˆå§‹çŠ¶æ€ä¹Ÿæ˜¯0.
çŠ¶æ€1å¯èƒ½ä½¿ç”¨åŒæ ·çš„å¤„ç†æœºåˆ¶ä¹Ÿå¯èƒ½è¿›å…¥çŠ¶æ€2ï¼Œè€ŒçŠ¶æ€2æ˜¯TNFAçš„ç»ˆæ­¢çŠ¶æ€ï¼Œæ‰€ä»¥å¯¹äºŽTNFAçš„1ï¼Œ2æ˜¯TDFAçš„1ï¼Œä¹Ÿæ˜¯TDFAçš„ç»ˆæ­¢çŠ¶æ€ã€‚é™¤æ­¤ä¹‹å¤–ï¼ŒTDFAå…·æœ‰ç»ˆæ­¢åŒ–æ“ä½œï¼Œå³å¯¹äºŽè¿›å…¥TDFAçš„1(2)åŽï¼Œä¼šé€€å‡ºç¨‹åºã€‚åŒæ ·çš„ï¼Œåœ¨TDFAçš„åˆå§‹çŠ¶æ€0ä¸­ï¼Œä¼šåŒ…å«åˆå§‹åŒ–è¾¾åˆ°ä½¿ç”¨æ–°çš„å¤„ç†æœºåˆ¶è¿›å…¥ç¨‹åºçš„ä½œç”¨ã€‚å…¶ä¸­ï¼Œè¿‡åº¦å‡½æ•°å°±æ˜¯åº”ç”¨å¤„ç†æœºåˆ¶æ—¶è®°å½•æ ‡ç­¾ä»Žè€Œè¾¾åˆ°è®°å½•æ‰§è¡Œè¿‡ç¨‹çš„ä½œç”¨ã€‚
## ä¼ªä»£ç å®žçŽ°
å¯¹äºŽä¸€ä¸ªçŠ¶æ€tï¼Œè¿›è¡Œaå¤„ç†
å¯¹äºŽä»»æ„çŠ¶æ€u->uâ€™ä¹‹é—´å­˜åœ¨aå¤„ç†ï¼Œåˆ™æ·»åŠ åˆ°é“¾è¡¨ä¸­ã€‚
reach(t,a)
for u->uâ€™ == a ï¼š r = r + (uâ€™ , k)
å½“å‰çŠ¶æ€æ‰€æœ‰å¯èƒ½çš„å¤„ç†æœºåˆ¶è¿›è¡ŒéåŽ†ï¼Œæ‰¾åˆ°è¿›å…¥å…¶ä»–çŠ¶æ€çš„æœ€çŸ­è·¯å¾„ã€‚
t_closure
for (u , k) âˆˆ S (ï¼špush(u,0,k) ðŸ˜‰
init closure
while stack (: pop(s,p,k) ; for s -> u (: if tag (: remove ; add )
if (u,pâ€™,kâ€™) âˆˆ closure and p  uâ€™ == R : add R to c ; else signal uâ€™ ; t = uâ€™ ; c
= a ; if uâ€™ == final : finish ;
ä¼ªä»£ç æ‰§è¡Œæµç¨‹ï¼š
å°†å½“å‰çŠ¶æ€çš„å¤„ç†æœºåˆ¶ä¿å­˜åˆ°é“¾è¡¨ä¸­ï¼Œå°†æ‰€æœ‰ä¿æŒ0çŠ¶æ€çš„å¤„ç†æœºåˆ¶æ·»åŠ åˆ°åˆå§‹åŒ–éƒ¨åˆ†ã€‚æŽ¥æ”¶ä¿¡å·ï¼Œå°†æ‰€æœ‰èƒ½å¤Ÿå¤„ç†aä¿¡å·çš„å¤„ç†æœºåˆ¶æ·»åŠ åˆ°æ–°çš„é“¾è¡¨ä¸­ï¼Œå¹¶ä¸”å°†è¯¥é“¾è¡¨ä¸­çš„å¤„ç†æœºåˆ¶è¿›è¡Œç­›é€‰ï¼Œæ‰¾åˆ°èƒ½å¤Ÿè·³è½¬çš„æœ€çŸ­çš„åº”ç”¨é“¾ç¾¤ã€‚å°†è·³è½¬çš„çŠ¶æ€å’Œä½¿ç”¨çš„å¤„ç†æœºåˆ¶é“¾è®°å½•ï¼Œé‡å¤ä¸Šè¿°æ­¥éª¤å¤„ç†æ–°çš„çŠ¶æ€ç›´åˆ°è¿›å…¥ç»ˆæ­¢çŠ¶æ€ã€‚
## ä»£ç åˆ†æž
    import qualified Test.QuickCheck as Q
    import qualified Test.QuickCheck.Monadic as QM
    import qualified System.Process as SP
    import qualified System.Exit as SE
    import qualified Data.ByteString.Char8 as BS
    import           Data.Char (ord)
    import qualified Text.Regex.TDFA as X
    import qualified Data.Array as A
    import           Control.Monad (when)
    data E = A | B | C
           | Empty
           | NA | NB | NC
           | Alt E E
           | Cat E E
           | Star E
           | Plus E
           | Mayb E
           | FromTo Int Int E
           | From   Int     E
    instance Show E where
      show x = case x of
        A       -> "[a]"
        B       -> "[b]"
        C       -> "[c]"
        Empty   -> "(\"\")"
        NA      -> "[^a]"
        NB      -> "[^b]"
        NC      -> "[^c]"
    --    Alt l r -> show l ++ "|" ++ show r
        Alt l r -> "(" ++ show l ++ "|" ++ show r ++ ")"
    --    Cat l r -> show l ++ show r
        Cat l r -> "(" ++ show l ++ show r ++ ")"
        Star e  -> "(" ++ show e ++ ")*"
        Plus e  -> "(" ++ show e ++ ")+"
        Mayb e  -> "(" ++ show e ++ ")?"
        FromTo n m e -> "(" ++ show e ++ "){" ++ show n ++ "," ++ show m ++ "}"
        From   n   e -> "(" ++ show e ++ "){" ++ show n ++ ",}"
    show_posix :: E -> String
    show_posix x = case x of
        A       -> "[a]"
        B       -> "[b]"
        C       -> "[c]"
        Empty   -> "()"
        NA      -> "[^a]"
        NB      -> "[^b]"
        NC      -> "[^c]"
    --    Alt l r -> show_posix l ++ "|" ++ show_posix r
        Alt l r -> "(" ++ show_posix l ++ "|" ++ show_posix r ++ ")"
    --    Cat l r -> show_posix l ++ show_posix r
        Cat l r -> "(" ++ show_posix l ++ show_posix r ++ ")"
        Star e  -> "(" ++ show_posix e ++ ")*"
        Plus e  -> "(" ++ show_posix e ++ ")+"
        Mayb e  -> "(" ++ show_posix e ++ ")?"
        FromTo n m e -> "(" ++ show_posix e ++ "){" ++ show n ++ "," ++ show m ++ "}"
        From   n   e -> "(" ++ show_posix e ++ "){" ++ show n ++ ",}"
    instance Q.Arbitrary E where
        arbitrary = do
            d  a -> Q.Gen E
    arbitrary_d 0 = do
        Q.frequency
            [ (1, pure Empty)
            , (1, pure A)
            , (1, pure B)
            , (1, pure C)
            , (1, pure NA)
            , (1, pure NB)
            , (1, pure NC)
            ]
    arbitrary_d d = do
        n  arbitrary_d d'  arbitrary_d d')
            , (30,  Cat  arbitrary_d d'  arbitrary_d d')
            , (10, Star  arbitrary_d d')
            , (10, Plus  arbitrary_d d')
            , (10, Mayb  arbitrary_d d')
            , (10, FromTo n m  arbitrary_d d')
            , (10, From   n    arbitrary_d d')
            ]
            where d' = pred d
    parse_input :: Int -> IO [(BS.ByteString, [Int], [BS.ByteString], X.MatchArray)]
    parse_input ncaps = do
        let step :: BS.ByteString -> BS.ByteString -> (BS.ByteString, [Int], [BS.ByteString], X.MatchArray, BS.ByteString)
            step input key =
                let ns'@(n1:n2:_:ns) = reverse $ BS.foldl' (\xs c -> ord c : xs) [] key
                    s = BS.take n2 input
                    ss = split ns s
                    ar = A.listArray (0, ncaps) (split2 ns s)
                    rest = BS.drop n1 input
                in (s, ns', ss, ar, rest)
    â€‹    go :: [BS.ByteString] -> BS.ByteString -> [(BS.ByteString, [Int], [BS.ByteString], X.MatchArray)]
    â€‹    go [] _ = []
    â€‹    go (key:keys) input =
    â€‹        let (s, ns, ss, ar, rest) = step input key
    â€‹        in (s, ns, ss, ar) : go keys rest
    â€‹    split :: [Int] -> BS.ByteString -> [BS.ByteString]
    â€‹    split [] _ = []
    â€‹    split (n1:n2:ns) s = (BS.drop n1 . BS.take n2) s : split ns s
    â€‹    split _ _ = error "uneven number of keys"
    â€‹    split2 :: [Int] -> BS.ByteString -> [(Int, Int)]
    â€‹    split2 [] _ = []
    â€‹    split2 (n1:n2:ns) s = case (n1, n2) of
    â€‹        (255, 255)                 -> (-1, 0) : split2 ns s
    â€‹        _ | n1 /= 255 && n2 /= 255 -> (n1, n2 - n1) : split2 ns s
    â€‹        _                          -> error $ "bad re2c result: " ++ show (n1, n2)
    â€‹    split2 _ _ = error "uneven number of keys"
    â€‹    split_at :: Int -> BS.ByteString -> [BS.ByteString]
    â€‹    split_at _ s | s == BS.empty = []
    â€‹    split_at n s | BS.length s  BS.readFile "a.c.line1.keys"
    return $ go keys input
    prop_test_re2c :: E -> Q.Property
    prop_test_re2c r1 = QM.monadicIO $ do   //è¯»å–è¾“å…¥æµ
        let portable_empty = "[a]{0}"
            re_file = "/*!re2c " ++ show r1 ++ "|" ++ portable_empty ++ " {} */"  //showå‡½æ•°
            re_posix = "^" ++ show_posix r1 ++ "|" ++ portable_empty   //show_posix
            rr = X.makeRegex re_posix :: X.Regex  //æ­£åˆ™åŒ¹é…
            ncaps = length $ filter (== '(') re_posix
            re2c = "../re2c"
    ok0 >re2c_last_warning"
            ++ " || exit 42 && gcc a.c -o a && ./a"
    QM.assert $ ok0 `elem` [SE.ExitSuccess, SE.ExitFailure 42]
    when (ok0 == SE.ExitFailure 42) $ do
        QM.run $ print re_posix
    when (ok0 == SE.ExitSuccess) $ do
        ss  do
                let s1 = map BS.unpack xs
                    s2 = ((\x -> if x == [] then [] else head x) . X.match rr . BS.unpack) s
                    ar' = (X.match rr . BS.unpack) s :: X.MatchArray
                    ok = (ar == ar' && s1 == s2) || (BS.filter (== '\n') s) /= BS.empty
                QM.run $ when (not ok) $ do
                    print re_posix
                    print ncaps
                    print $ BS.unpack s
                    print ns
                    print s1
                    print s2
                    print ar