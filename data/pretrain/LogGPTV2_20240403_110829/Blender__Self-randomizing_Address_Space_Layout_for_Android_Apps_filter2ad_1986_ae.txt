### Cold Start and Warm Start
The initial delay caused by the cold start will not affect the subsequent launches of the app (warm start) if the app is not terminated due to low memory. Unlike Morula [32], this delay only applies to apps with our protection and does not impact other apps.

### Runtime Overheads
Blender provides self-randomization capabilities to apps, and the randomization process occurs at the app’s startup time, thereby not affecting runtime performance. We used Quadrant Standard Edition v2.1.1 to measure the general-purpose benchmark for CPU, memory, I/O, 2D, and 3D graphics. Since we do not have access to the source code of the benchmark tool, we used apktools [52] to repackage the app and add Blender protection for our evaluation. Table 4 illustrates the benchmark results, which show that the benchmark results are nearly identical due to the startup time randomization.

### Memory Overheads
We also evaluated the memory usage at runtime for the original app, an app with re-delegation, an app with BlenderLRM only, and an app with both BlenderLRM and BlenderART. We created a script to monitor the `/proc/[pid]/status` file, which contains all memory information at runtime. Figure 9 shows the VmRSS sizes during the first 2000 ms. VmRSS (Virtual Memory Resident Set Size) represents the portion of memory occupied by a process in memory. In the first 250 ms, the VmRSS value increases from a low level and then stabilizes. The VmRSS values for BlenderLRM only and BlenderLRM/ART together are nearly the same at runtime, introducing about 5513 kB (11.5%) overhead. Blender incurs less memory overhead compared to the previous mitigation solution, Morula [32], which introduces 13 MB for each app by patching the Android system.

### Battery Overheads
Battery consumption is crucial for mobile devices. Since Blender conducts randomization at the app's startup time, it consumes more battery than the original settings. We conducted the following experiments to measure the battery overhead of the Blender system. First, we used a fully charged device (Nexus 5) and set the screen to "always on." Then, we launched and closed the experiment app (the same app used in the performance evaluation experiments) 500 times with a 10-second interval. For each execution, we recorded the current time and the current battery capacity. For the Blender evaluation, we used a fully charged device to execute the experiment app with Blender installed and recorded the battery capacity. For both experiments, we obtained the battery capacity by reading the `/sys/class/power_supply/battery/capacity` file. Figure 10 illustrates the remaining battery capacities after multiple executions for two apps, and we plotted their linear fit as two dashed lines. There is only a 1% increase in power consumption after 500 executions over approximately 6400 seconds, which is comparable to the Morula system. Therefore, the battery overhead is negligible for normal users.

### Discussion
#### Limitations of Caching Patched ART Code
To balance security gains and performance overheads, our design caches patched ART code (i.e., `boot.oat`) in a pool. Although attackers can try multiple times to guess the offsets of the `boot.oat` file in the pool, they still cannot obtain the current offset from previous executions or through other side channels. However, this technique decreases the entropy of the randomization. To achieve high-entropy randomization, developers can disable the use of cached code and conduct randomization at runtime. This may introduce more startup overhead (less than two seconds), but it is still acceptable for apps with high security requirements. Additionally, we can randomize the `boot.oat` file at runtime, such as when the app is idle in the background, to reduce the startup time delay. However, this requires a deep understanding of the app's logic and more involvement from the app developer.

#### Blender on Other Architectures
Since most mobile devices are based on the ARM architecture (99% according to report [3]), our ret2art attack and Blender system are implemented on an ARM-based device. The latest Android versions support other architectures, including x86 and MIPS. The only differences are architecture-specific source code. Therefore, the weakness of ASLR introduced by the zygote process creation model still exists, and one can easily write code to initiate a ret2art attack on those platforms. For the Blender system, one can port it to other architectures by translating the architecture-specific ARM assembly code to the corresponding architecture.

#### Randomization within Shared Library
Another limitation of the current system is that Blender does not randomize functions inside a library. This means that if there is a memory leak vulnerability, attackers could know the base address and compute offsets of ROP gadgets to launch an ROP attack. To overcome this potential security problem, we can use the method proposed as binary stirring [51] to randomly rewrite the binary code blocks of loaded libraries. However, this method requires disassembling, rewriting, and assembling all loaded libraries at the launch time of an app, which introduces considerable overhead. Therefore, we leave it as future work.

### Related Work
#### Security Problems in Memory
Security issues in memory are among the oldest in computer security. Previous studies [28, 46, 49] summarize the attack and defense solutions for memory security. Our work focuses on attacking and protecting the weakened ASLR mechanism on Android.

#### Attacks and Defenses of ASLR Mechanism
Modern operating systems have implemented/deployed ASLR and DEP defense mechanisms by default [24, 30, 47]. Attackers have developed various bypassing techniques, including brute-forcing methods [34, 42]. Leaked pointers, type confusion, and use-after-free bugs can also be exploited [40, 41]. By repeatedly abusing memory disclosures, attackers can map an application’s memory layout on-the-fly with dynamically discovered gadgets [43]. Several return-oriented programming techniques are described in several papers [34, 53]. Some researchers [22, 51] have proposed protecting memory by introducing high randomization entropy.

#### Attacks and Defenses on Android
Compared to traditional desktop operating systems, mobile OS have domain-specific architecture designs that introduce new attack surfaces. For Android, many researches discuss security issues in the permission mechanism [19, 29, 31]. Additionally, some work exploits underlying system components on Android [15, 21, 27, 35, 37, 38, 48, 50, 57]. Given the prevalence of malware on Android, Zhou et al. [59] provide the characterization and evolution of Android malware. Some systems propose preventing [45] or detecting malware [44]. Researchers have also proposed both static analysis systems [26, 33, 56, 58] and dynamic analysis systems [25, 55] to assist malware researchers in understanding malicious logic.

#### Mitigating ASLR on Android
Due to the limitations of mobile systems, the design and implementation of ASLR mechanisms are weak. Retouching [17], Morula [32], and LR2 [18] are three systems that discuss attacking techniques and provide mitigation solutions. Retouching can randomize pre-linked code when deploying Android applications but does not resolve the issue of uniform memory layout introduced by the zygote process creation model. Morula proposes a patch for Android source code to randomize all layouts of apps after forking from zygote and introduces low overheads. LR2 proposes a leakage-resilient layout randomization method by introducing transformations as passes on the compiler. However, these systems have major deployment issues, requiring modifications to the Android source code. Users must replace the original firmware with the customized system, and the system must keep up with the latest Android version with new features and bug fixes. Hence, due to these deployment issues, both users and developers cannot easily adopt these mitigation solutions. Our work provides a non-invasive methodology for both developers and users.

### Conclusion
In this paper, we demonstrate that the ASLR protection on Android is weakened due to the zygote app creation model. We also present a newly discovered attack surface introduced by the ART runtime and a novel way to exploit the weakness of the ASLR protection and this new attack surface. We propose a non-invasive user-level solution called Blender, which self-randomizes the address space layout for apps, raising the bar for successfully bypassing the weakened ASLR protection on Android. We discuss the design, implementation, and present the effectiveness and performance overhead of our system.

### References
[References listed here as provided in the original text.]