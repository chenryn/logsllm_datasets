them claim themselves as CTF players or exploit practitioners.
14 are researchers in academia. 2 are members of blue team
in an enterprise. Note that one participant can have multiple
roles. Besides, 10 participants have experience in crafting
Linux kernel exploits, 4 reading write-ups or exploits, and
7 debugging kernel and developing patches. As the subjects
participating in the survey have diverse backgrounds, we deem
that the survey results reﬂect the viewpoint of most security
1) Which of the following roles do you identify yourself
as (multiple choices)?
a. CTF player/exploit practitioner
b. Academia researcher
c. Security analyst in enterprise blue team
d. Ofﬁcial in government agency
2) How’s your experience in Linux kernel exploitation
a. I’ve debugged kernel or developed kernel patches but
done nothing about exploitation
b. I’ve read some writeups
c. I’ve written some exploits for CTF challenges or
real-world vulnerabilities
3) What’s the easiest way to get in touch with you? We
ask this question for gift card sending and potential
follow-up question. We promise to keep privacy and
won’t identify you via the contact.
4) Do you agree that, without going into details, double
free behavior implies higher exploitability than BUG in
most cases?
a. Yes
b. No
c. I don’t know
Fig. 3: Sampled questions from the exploitability survey
form [78]
experts regarding how to assess the exploitability of bugs
according to their error behaviors.
Our survey showed that 18 out of 21 participants agree
that, for all comparison pairs, error behaviors like double-
free, use-after-free, and out-of-bound access imply higher
exploitation potential. For the comparison between double-
free and BUG/GPF, use-after-free and BUG/GPF, out-of-
bound access, and BUG/GPF/WARN/NULL ptr deref, there
are 1/2, 2/3, and 3/2/1/1 participants who disagree with our
classiﬁcation, respectively. They explained that, in the situation
where the attacker can control the corruption range, errors like
GPF/BUG/WARN could imply higher exploitation potential.
In our user study, we further contacted those participants for
further clariﬁcation. In the follow-up interview, they conceded
that though they have encountered some particular cases, they
agree that our classiﬁcation works in most situations. As such,
we carefully conclude that there is a shared sense among
security analysts. That
is, compared with error behaviors
like GPF/WARN/BUG/NULL ptr deref, kernel error behaviors
such as double free, use-after-free, and out-of-bound imply
higher exploitation potential.
B. Procedure of Error Triaging
When exploring multiple error behaviors for a target bug,
GREBE may hit other bugs, demonstrating error behaviors
that do not result from the target bug. To ensure the newly
identiﬁed error behaviors are truly tied to the bug of our
interest, error triaging is needed. As we mentioned earlier,
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2093
It is challenging to measure the distance between the root
cause and the error site for a given bug. The Linux kernel is
a multi-process system. The system call that triggers the root
cause could be different from the one that brings about the
error. As a result, we address this issue as follows. First, we
identify all the lines of the kernel code that the patch changes.
Second, we examine which of these lines is executed ﬁrst when
replaying the PoC program. In this work, we treat that line as
our root cause site. If the patch site and the error site share
the same system call, we simply count the basic blocks in
between. For the kernel bug, the root cause of which and the
error site reside in different system calls, we combine the basic
blocks of both system calls. More speciﬁcally, we take the
total number of basic blocks that the error-site-related system
call has executed. Then, we add this number to the number
of basic blocks that the root-cause-related system calls have
executed (right after the root cause is triggered and before the
error occurs).
In Table V (“N of BB” column), we show the distance
measure for the error manifested in the bug’s original report.
We mark the distance measure with a star sign if that bug’s root
cause and error site do not share the same system call. As we
can observe from the table, there is no clear relation between
the distance and the false positive. GREBE demonstrates false
positives regardless of whether the distance is long or short
enough. In addition, the false-negative occurrence does not
depend upon whether root cause and error site share (or not
share) the same system call. With these observations, we safely
reject our hypothesis.
there has not yet been accurate error triaging methods. We,
therefore, seek the help of kernel professionals.
In this work, our professional team performed error triaging
by following the procedure below. Given a bug of our interest,
the team ﬁrst ﬁnds the bug’s patch and applies it
to the
corresponding kernel image. Then, for each newly identiﬁed
error behavior, the team executes the PoC program tied to
that newly discovered error behavior. If the patch fails to
block the demonstration of the error (i.e., the patched kernel
still crashes),
the team excludes that error behavior with
the conclusion that it is not associated with the target bug.
Otherwise, the team will put their effort into inspecting the
execution of the PoC program. In the inspection phase, the
team will manually examine the bug patch and extract the
condition of the bug triggering. With this triggering condition
in hand, the team further examines the execution of the PoC
program. If the execution aligns with the triggering condition,
the team safely concludes the newly discovered error is tied
to the bug of our interest. To minimize the possible human
mistake, we asked the team to form a unanimous agreement
before we associate that new error behavior to the bug of our
interest.
It should be noted that, like Syzkaller, when GREBE triggers
a bug and demonstrates an error behavior, it may not generate
a PoC program allowing the team to follow the procedure
above. In this situation, the team will take a close look at the
call stack of the kernel panic. Following the call stack, the
team will manually track the kernel execution reversely and
infer if the panic results from the same root cause. In this
manual analysis phase, the team utilizes several heuristics to
align an error with the bug. First, the team will conﬁrm the
functions in the call stack are relevant to the functions where
the patch is applied. Second, the team will ensure the panic
site is related to the variables that the patch inﬂuences.
As we can see, the rationale of the triaging procedure above
is as follows. We assume that the patch could successfully
block the triggering of the bug and thus prevent
it from
exhibiting the corresponding errors. If the patched kernel
image still demonstrates errors, the manifested error is not
likely to associate with the bug of our interest. However, it
should be noted that the procedure above might mistakenly
exclude some error behaviors tied to the bug of our interest
simply because the patch might not be correct, and we falsely
rule out the corresponding error behaviors. As a result, we
emphasize that the error behaviors we identiﬁed could mean
only the lower bound of the total number of all possible error
behaviors. However, as we showed in Section VI, the lower
bound still provides good utility, helping a security researcher
explore multiple error behaviors for a given kernel bug.
C. Detail of Distance Measurement & Hypothesis Validation
Section VI-B hypothesizes that the distance (number of ba-
sic blocks) between a bug’s root cause and the corresponding
error site may correlate with the false negatives of GREBE.
Here, we detail how we measure the distance and present our
hypothesis testing result.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2094
SYZ ID
1fd1d44[40]
N of BB
5128 (cid:63)
New Behaviors Discovered Manually
general protection fault in skcipher walk done
KASAN: use-after-free Write in bpf tcp close
New Behaviors Discovered by GREBE
general protection fault in skcipher walk done
KASAN: use-after-free Write in bpf tcp close
695527b[42]
2313 (cid:63)
BUG: unable to handle kernel paging request in qlist free all
BUG: unable to handle kernel paging request in qlist free all
ebcbbb6[79]
f7649aa[80]
6a03985[46]
27ea7ae[81]
1
38
2
1
d5222b3[47]
652 (cid:63)
de28cb0[28]
f56bbe6[30]
b7f4861[82]
2
2
1
e4be308[53]
857 (cid:63)
d1baeb1[27]
1043 (cid:63)
7022420[11]
0df4c1a[35]
badc913[83]
33913c9[84]
28741ff[85]
0df4c1a[35]
64
553
1510 (cid:63)
1
2
6
WARNING: ODEBUG bug in sock hash free
-
-
general protection fault in hfsc unbind tcf
WARNING: refcount bug in
tcf action put
KASAN: use-after-free Read in route4 get
WARNING: refcount bug in route4 destroy
KASAN: null-ptr-deref Read in route4 destroy
KASAN: use-after-free Read in route4 destroy
-
-
-
-
general protection fault in hfsc unbind tcf
WARNING: refcount bug in
tcf action put
KASAN: use-after-free Read in route4 get
WARNING: refcount bug in route4 destroy
KASAN: null-ptr-deref Read in route4 destroy
KASAN: use-after-free Read in route4 destroy
-
WARNING: bad unlock balance in ucma destroy id
WARNING: bad unlock balance in ucma destroy id
general protection fault in rdma listen
KASAN: use-after-free Read in addr handler
KASAN: use-after-free Read in cma cancel operation
KASAN: use-after-free Read in rdma listen
BUG: corrupted list in rdma listen
BUG: corrupted list in neigh mark dead
KASAN: use-after-free Read in neigh mark dead
KASAN: slab-out-of-bounds Read in neigh mark dead
KASAN: use-after-free Read in
neigh create
KASAN: slab-out-of-bounds Read in
neigh create
KASAN: use-after-free Read in neigh change state
general protection fault in rdma listen
-
-
KASAN: use-after-free Read in rdma listen
BUG: corrupted list in rdma listen
BUG: corrupted list in neigh mark dead
KASAN: use-after-free Read in neigh mark dead
KASAN: slab-out-of-bounds Read in neigh mark dead
KASAN: use-after-free Read in
neigh create
KASAN: slab-out-of-bounds Read in
neigh create
KASAN: use-after-free Read in neigh change state
KASAN: slab-out-of-bounds Read in qrtr endpoint post
KASAN: slab-out-of-bounds Read in qrtr endpoint post
-
-
KASAN: slab-out-of-bounds Write in tgr192 ﬁnal
KASAN: slab-out-of-bounds Write in tgr160 ﬁnal
KASAN: slab-out-of-bounds Write in tgr192 ﬁnal
KASAN: slab-out-of-bounds Write in tgr160 ﬁnal
KASAN: slab-out-of-bounds Write in crypto sha3 ﬁnal
KASAN: slab-out-of-bounds Write in crypto sha3 ﬁnal
KASAN: slab-out-of-bounds Write in rmd320 ﬁnal
KASAN: slab-out-of-bounds Write in wp384 ﬁnal
KASAN: slab-out-of-bounds Write in sha512 ﬁnup
KASAN: slab-out-of-bounds Write in sha1 ﬁnup
KASAN: slab-out-of-bounds Write in sha1 ﬁnal
KASAN: slab-out-of-bounds Write in sha256 ﬁnal
KASAN: slab-out-of-bounds Write in rmd160 ﬁnal
KASAN: slab-out-of-bounds Write in sha256 ﬁnup
general protection fault in skb release data
general protection fault in skb clone
KASAN: slab-out-of-bounds Write in rmd320 ﬁnal
KASAN: slab-out-of-bounds Write in wp384 ﬁnal
KASAN: slab-out-of-bounds Write in sha512 ﬁnup
KASAN: slab-out-of-bounds Write in sha1 ﬁnup
KASAN: slab-out-of-bounds Write in sha1 ﬁnal
KASAN: slab-out-of-bounds Write in sha256 ﬁnal
KASAN: slab-out-of-bounds Write in rmd160 ﬁnal
KASAN: slab-out-of-bounds Write in sha256 ﬁnup
general protection fault in skb release data
-
KASAN: wild-memory-access Read in skb copy ubufs
KASAN: slab-out-of-bounds Write in pskb expand head
KASAN: wild-memory-access Read in skb copy ubufs
KASAN: slab-out-of-bounds Write in pskb expand head
KASAN: slab-out-of-bounds Write in default read copy kernel
KASAN: slab-out-of-bounds Write in default read copy kernel
KASAN: use-after-free Read in remove wait queue
KASAN: use-after-free Read in corrupted
KASAN: use-after-free Read in eventfd release
KASAN: use-after-free Read in remove wait queue
KASAN: use-after-free Read in corrupted
KASAN: use-after-free Read in eventfd release
-
-
KASAN: use-after-free Read in do madvise
KASAN: use-after-free Read in do madvise
WARNING in snd usbmidi submit urb/usb submit urb
WARNING in snd usbmidi submit urb/usb submit urb
BUG: unable to handle kernel paging request
BUG: unable to handle kernel paging request
in pcpu freelist populate
in pcpu freelist populate
BUG: unable to handle kernel paging request in htab map alloc
BUG: unable to handle kernel paging request in htab map alloc
BUG: unable to handle kernel paging request in bpf lru populate BUG: unable to handle kernel paging request in bpf lru populate
KASAN: vmalloc-out-of-bounds Write in pcpu freelist populate
KASAN: vmalloc-out-of-bounds Write in pcpu freelist populate
KASAN: vmalloc-out-of-bounds Write in bpf lru populate
KASAN: vmalloc-out-of-bounds Write in htab map alloc
KASAN: vmalloc-out-of-bounds Read in htab free elems
BUG: unable to handle kernel paging request in htab free elems
KASAN: vmalloc-out-of-bounds Write in bpf lru populate
KASAN: vmalloc-out-of-bounds Write in htab map alloc
KASAN: vmalloc-out-of-bounds Read in htab free elems
-
TABLE V: The results of false negative analysis. The “SYZ ID” column is the case ID. The second column is the number of
basic block between the root cause and the crash site. The star (cid:63) right after the number indicates that the site of root cause
and crash are from different syscalls. Otherwise, they are from the same syscall. The third and fourth column represent the
new behaviors discovered manually and by GREBE, respectively. The dash “-” means no such behavior is discovered in the
corresponding way. It should be noted that the cases like #ebcbbb6 have two dashes in a row. It is because no new error behavior
was discovered either manually or by GREBE.
2095
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply.