ACM Proc. ASPLOS, 2013.
[22] Y. Kang, B. Ray, and S. Jana. Apex: Automated In-
In Proc.
ference of Error Speciﬁcations for C APIs.
IEEE/ACM ASE, 2016.
[23] G. Klees, A. Ruef, B. Cooper, S. Wei, and M. Hicks.
Evaluating Fuzz Testing. In Proc. ACM CCS, 2018.
[24] A. Lenharth, V. Adve, and S. T. King. Recovery Do-
mains: An Organizing Principle for Recoverable Oper-
ating Systems. In Proc. ACM ASPLOS, 2009.
[25] J. Lettner, D. Song, T. Park, P. Larsen, S. Volckaert, and
M. Franz. PartiSan: Fast and Flexible Sanitization via
Run-time Partitioning. In International Symposium on
Research in Attacks, Intrusions, and Defenses, 2018.
[26] H. Liu, Y. Wang, L. Jiang, and S. Hu. PF-Miner: A New
Paired Functions Mining Method for Android Kernel in
Error Paths. In IEEE COMPSAC, 2014.
[27] F. Long, S. Sidiroglou-Douskos, and M. Rinard. Auto-
matic Runtime Error Repair and Containment via Re-
covery Shepherding. In Proc. ACM PLDI, 2014.
[29] J. Newsome, D. Brumley, and D. Song. Vulnerability-
Speciﬁc Execution Filtering for Exploit Prevention on
Commodity Software. In Proc. Internet Society NDSS,
2006.
[30] H. D. T. Nguyen, D. Qi, A. Roychoudhury, and S. Chan-
dra. Semﬁx: Program repair via semantic analysis. In
Proc. IEEE ICSE, 2013.
[31] S. Pailoor, A. Aday, and S. Jana. MoonShine: Optimiz-
ing OS Fuzzer Seed Selection with Trace Distillation.
In Proc. USENIX Security Symposium, 2018.
[32] J. Pan, G. Yan, and X. Fan. Digtool: A Virtualization-
Based Framework for Detecting Kernel Vulnerabilities.
In Proc. USENIX Security Symposium, 2017.
[33] J. H. Perkins, S. Kim, S. Larsen, S. Amarasinghe,
J. Bachrach, M. Carbin, C. Pacheco, F. Sherwood,
S. Sidiroglou, G. Sullivan, W. Wong, Y. Zibin, M. D.
Ernst, and M. Rinard. Automatically patching errors in
deployed software. In Proc. ACM SOSP, 2009.
[34] C. Rubio-González, H. S. Gunawi, B. Liblit, R. H.
Arpaci-Dusseau, and A. C. Arpaci-Dusseau. Error prop-
agation analysis for ﬁle systems. In Proc. ACM PLDI,
2009.
[35] S. Saha, J. Lozi, G. Thomas, J. L. Lawall, and G. Muller.
Hector: Detecting Resource-Release Omission Faults
in Error-Handling Code for Systems Software. In Proc.
IEEE/IFIP DSN, 2013.
[36] S. Schumilo, C. Aschermann, R. Gawlik, S. Schinzel,
kAFL: Hardware-Assisted Feedback
In Proc. USENIX Security
and T. Holz.
Fuzzing for OS Kernels.
Symposium, 2017.
[37] S. M. Seyed Talebi, H. Tavakoli, H. Zhang, Z. Zhang,
A. Amiri Sani, and Z. Qian. Charm: Facilitating Dy-
namic Analysis of Device Drivers of Mobile Systems.
In Proc. USENIX Security Symposium, 2018.
[38] H. Shi, R. Wang, Y. Fu, M. Wang, X. Shi, X. Jiao,
H. Song, Y. Jiang, and J. Sun.
Industry Practice of
Coverage-guided Enterprise Linux Kernel Fuzzing. In
Proc. ACM European Software Engineering Conference
and Symposium on the Foundations of Software Engi-
neering (ESEC/FSE), 2019.
[39] S. Sidiroglou, O. Laadan, C. Perez, N. Viennot, J. Nieh,
and A. D. Keromytis. ASSURE: Automatic Software
Self-healing Using REscue points. In Proc. ACM ASP-
LOS, 2009.
[28] K. Lu, A. Pakki, and Q. Wu. Automatically Identifying
Security Checks for Detecting Kernel Semantic Bugs.
In Proc. European Symposium on Research in Computer
Security, 2019.
[40] D. Song, J. Lettner, P. Rajasekaran, Y. Na, S. Volckaert,
P. Larsen, and M. Franz. SoK: Sanitizing for Security. In
Proc. IEEE Symposium on Security and Privacy (S&P),
2019.
2396    30th USENIX Security Symposium
USENIX Association
[41] A. Sotirov. Hotpatching and the rise of third-party
patches. In Black Hat Technical Security Conference,
2006.
[42] Y. Tian and B. Ray. Automatically Diagnosing and
Repairing Error Handling Bugs in C. In Proc. ACM
ESEC/FSE, 2017.
[43] J. Tucek, J. Newsome, S. Lu, C. Huang, S. Xanthos,
Sweeper: A
D. Brumley, Y. Zhou, and D. Song.
Lightweight End-to-end System for Defending Against
Fast Worms. In Proc. ACM EuroSys, 2007.
[44] J. Vander Stoep. Android: Protecting the Kernel. In
Linux Security Summit (LSS), 2016.
[45] Y. Wei, Y. Pei, C. A. Furia, L. S. Silva, S. Buchholz,
B. Meyer, and A. Zeller. Automated ﬁxing of programs
with contracts. In Proc. ACM ISSTA, 2010.
[46] W. Weimer, T. Nguyen, C. Le Goues, and S. Forrest.
Automatically Finding Patches Using Genetic Program-
ming. In Proc. IEEE ICSE, 2009.
[47] Z. Xu, Y. Zhang, L. Zheng, L. Xia, C. Bao, Z. Wang, and
Y. Liu. Automatic Hot Patch Generation for Android
Kernels. In Proc. USENIX Security Symposium, 2020.
[48] X. Zhang, Y. Zhang, J. Li, Y. Hu, H. Li, and D. Gu.
Embroidery: Patching Vulnerable Binary Code of Frag-
mentized Android Devices. In IEEE ICSME, 2017.
Appendix
CVE-2019-2293
This vulnerability, which is rated as
medium security severity, is caused by a possible null
pointer dereference in Qualcomm camera ife module. A
null pointer dereference might happen because of lack of a
proper check on the isp_resource length variable before
calling cam_ife_mgr_acquire_hw_for_ctx(). There are
7 functions in this bug’s call stack. Hecaton overall gen-
erates 10 undo statements in these functions. Hecaton suc-
cessfully detects several types of state-mutating statements
and their corresponding undo statements including direct
function calls, function pointers, and global variable assign-
ments. However, our manual investigation shows that one
bowknot does not correctly undo the side effect of its func-
tion. In cam_context_handle_acquire_dev() function
ioctl_ops.acquire_dev(), which modiﬁes the state of the
camera device driver is called, but it is not paired with its undo
function, ioctl_ops.release_dev() . Hecaton missed this
statement because the original error handling code was not
complete and did not call ioctl_ops.release_dev().
After correcting the incomplete bowknot manually, when
we run the PoC of this vulnerability on the mitigated kernel,
all bowknots in the call stack get executed and successfully
In
undo the side effects of the PoC. The camera device remains
functional after this successful undo.
CVE-2019-1999
function
binder_alloc_free_page(), there is a possible double-
free vulnerability due to improper locking. This vulnerability
is rated as high security severity because it could lead to
local escalation of privilege in the kernel with no additional
execution privileges needed. In 2 functions in the call
stack, there are 2 state-mutating statements, which Hecaton
automatically detects and uses to generate bowknots. Our
manual investigation shows that the generated bowknots
are complete. Also, Hecaton-generated bowknots preserve
the binder’s functionality after recovery. Hence, after the
recovery, the system is functional and successfully passes
a binder test program that we execute. Our test program
consists of two processes, a binder-server and a binder-client.
It checks for successful communication between these two
processes.
CVE-2019-10529 This is a use-after-free bug that can get
triggered with a race condition while attempting to mark the
entry pages as dirty using the function set_page_dirty().
Use-after-free bugs in the kernel can cause a system crash,
put the system in an unexpected state, or be used in privi-
lege escalation exploits. Automated bowknots generated by
Hecaton mitigate this vulnerability and preserve the GPU
driver’s functionality. To test the GPU driver’s functionality,
we used the “GPU Mark BenchMark” application, which tests
the GPU under the stress of rendering. We do not notice any
difference in the result before and after Hecaton mitigates
this vulnerability. Our manual investigation also shows that
bowknots undo worked correctly in this case.
CVE-2019-2000 This is a bug in the binder module of the
Pixel3 phone. There are 4 functions in this bug’s call stack.
Hecaton ﬁnds 6 state-mutating statements in these functions
and generate the undo code for them in their bowknots. Our
experiments show that the binder module remains functional
after triggering this bug and executing the bowknots. Our
manual investigation conﬁrms that there are no other state-
ments that result in any change in the system’s state, which
leaks to non-local variables.
CVE-2019-2284: This is a bug in camera driver of Pixel3
phone. There are 4 functions in this bug’s call stack. Heca-
ton ﬁnds 10 state-mutating statements in these functions
and generates the undo code for them. However, our ex-
periments show that the Camera device loses its function-
ality after triggering this bug and executing the bowknots.
Our investigation shows that 2 out of 4 bowknots Heca-
ton generates for this bug’s functions are incomplete. In
cam_sensor_core_power_up() function, there is a loop in
which it turns on an array of voltage regulators. Although this
function has another for loop in its error handling path which
turns off the same array of the voltage regulators, Hecaton
currently does not support multi-statement undo, and only
produces a warning for the user. Our investigation shows that
USENIX Association
30th USENIX Security Symposium    2397
the bowknot generated for cam_sensor_driver_cmd() is
also not complete. In this case, Hecaton fails to generate the
complete bowknot because of the incomplete error handling
code. Please note that after we manually add the missing
undo statements to the mentioned functions, the system and
the camera device remain functional after triggering the bug
and execution of bowknots.
Syzbot bug a11372b6c9b5fd4abe1c266903bcb27e80e8f2bc
This is a bug in the TTY driver of the x86 Linux-Next
kernel. There are 5 functions in this bug’s call stack. Hecaton
locates two state-mutating functions and generates proper
undo code for them. It pairs kmalloc() with kfree()
and console_lock() with console_unlock() in the
con_font_get() function. The system and TTY module
remain functional after triggering this bug and execution
of bowknots. Our manual investigation shows that in one
of the functions, fbcon_get_font(), there are changes to
a data structure called font, which is not a local variable
of fbcon_get_font() and is provided as an input variable.
Since there is no undo code to revert changes of the font
data structure, at ﬁrst glance, it seems that the bowknot
does not completely undo the driver’s state. However, our
further analysis shows that font data structure is not a global
variable of the driver and is deﬁned as a local variable in
con_font_get() function, which is the parent function of
fbcon_get_font(). As a result, changes to the font data
structure do not leak to the other parts of the kernel before
bowknot’s execution. Hence, our manual investigation shows
that Hecaton-generated bowknots correctly undo the effects
of partially-executed system call, which conﬁrms the result
of the functionality test.
Syzbot bug 9ad0eb3691bac24fd21ae3d8add8c08014a69f57
This is a bug in the ﬁle system of the upstream x86 Linux
kernel. There are 10 functions in this bug’s call stack.
Hecaton ﬁnds one state-mutating statement and pairs it with
its undo statement. This pair is blk_start_plug() and
blk_finish_plug(), which appears twice in the execution
path of this function. The ﬁle system functionality tests,
including kernel self-tests for the ﬁle system, successfully
pass after triggering the bug and execution of bowknots. In
two functions in the call stack, we observe statements that
change the non-local variables of those functions. However,
similarly to the previous case, our detailed analysis shows
that these non-local variables are not part of the global state
of the system or the ﬁle system; they are local variables
deﬁned in the parent functions in the call stack. There is no
change to the system’s state, which does not have undo code
in the bowknots. As a result, our manual investigation is in
agreement with the functionality test.
Syzbot bug d708485af9edc3af35f3b4d554e827c6c8bf6b0f
This is a bug in HCI Bluetooth driver of the x86 Linux-Next
kernel. There are three functions in the call stack of this
bug. Hecaton successfully pairs 4 state-mutating statements
with their undo code in these functions’ bowknots. We test
the functionality of HCI Bluetooth driver with a user-space
program that uses this driver and with the network stack
self-tests of Linux kernel. The HCI Bluetooth driver and
the network stack remain functional after triggering the
bug and execution of bowknots. Our manual investigation
shows that, in addition to the 4 state-mutating statements
that Hecaton ﬁnds, there are three other function calls
that can potentially change the state of the system. One is
hci_req_cmd_complete(), which manipulates the hdev
the driver data structure. However, our further analysis shows
that this function does not get executed in the execution path
of this bug. As a result, it is not a concern. The two other
function calls, which can possibly change the state of system,
are hci_send_to_sock() and hci_send_to_monitor().
Sending data over HCI socket changes the state of system and
it is not reversible. However, our deeper analysis shows in the
case of triggering this bug, these two functions return at the
beginning and do not reach to the point that they change the
state of system. As a result, the success of functionality test
indicates the correct undo of system state in this case, too.
Syzbot bug f0ec9a394925aafbdf13d0a7e6af4cff860f0ed6
This is a bug in a network driver of the upstream x86 Linux
kernel. The bug is located in HCI Bluetooth driver. There
are 11 functions in this bug’s call stack. Although Hecaton
generates complete bowknot for 10 out of the 11 functions in
the call stack for this bug, the remaining incomplete bowknot
results in unsuccessful recovery. The last function in the call
stack of this bug, the __list_add() function, is designed to
add an entry to a speciﬁed location of a doubly linked list in
the kernel. It modiﬁes the two nodes that it wants to insert
a new node in between. The bug occurs after processing of
the ﬁrst node but before the second node. At this point, the
doubly link list is corrupted and there is no code to undo this
corruption. We could not ﬁx this problem in the two-hour
window that we allow for manual work for each bug.
Syzbot bug 0d93140da5a82305a66a136af99b088b75177b99
This is a bug in a network driver of the upstream x86 Linux
kernel. The bug is located in HCI physical layer driver. There
are 11 functions in this bug’s call stack. Hecaton pairs 5 state-
mutating statements with their undo code in these function’s
bowknots. However, the network self-test result changes after
triggering the bug and execution of the bowknots. Hence, the
functionality test for the automatically-generated bowknot
fails for this function. Our investigation shows that there is
one pair of state-mutating and undo functions, which Hecaton
missed because of its database’s incompleteness. When
we manually add hci_conn_drop() to the bowknot of the
function hci_phy_link_complete_evt() to reverse the
effect of hci_conn_hold(), the bowknots become complete
and the functionality test passes successfully.
2398    30th USENIX Security Symposium
USENIX Association