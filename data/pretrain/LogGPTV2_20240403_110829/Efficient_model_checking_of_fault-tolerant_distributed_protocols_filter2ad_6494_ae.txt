for Actor Computation. Journal of Functional Programming,
7(1):1–72, 1997.
[2] C. Artho, W. Leungwattanakit, M. Hagiya, Y. Tanabe. Efﬁcient
Model Checking of Networked Applications. Objects, Models,
Components and Patterns, pp. 22–40, 2008.
[3] H. Attiya, A. Bar-Noy, D. Dolev. Sharing Memory Robustly
in Message-Passing Systems. J. ACM, 42(1):124–142, 1995.
[4] H. Attiya, J. Welch. Distributed Computing. Wiley, 2004.
11
[5] R. Bhattacharya, S. German, G. Gopalakrishnan. Exploiting
Symmetry and Transactions for Partial Order Reduction of
Rule Based Speciﬁcations. SPIN, pp. 252-270, 2006.
[23] S. Lauterburg, M. Dotta, D. Marinov, G. Agha. A Framework
for State-Space Exploration of Java-Based Actor Programs.
Automated Software Engineering, pp. 468–479, 2009.
[6] K. P. Birman. Reliable Distributed Systems: Technologies, Web
Services, and Applications. Springer, 2005.
[7] P. Bokor, M. Seraﬁni, N. Suri, H. Veith. Role-Based Sym-
metry Reduction of Fault-tolerant Distributed Protocols with
Language Support. ICFEM, pp. 147–166, 2009.
[8] P. Bokor, M. Seraﬁni, N. Suri. On Efﬁcient Models for Model
Checking Message-Passing Distributed Protocols. FORTE, pp.
216–223, 2010.
[9] P. Bokor, J. Kinder, M. Seraﬁni, N. Suri. Local Partial-Order
Reduction. Tech. Report, TR-TUD-DEEDS-11-01-2010, 2010.
[10] M. Burrows. The Chubby Lock Service for Loosely-Coupled
Distributed Systems. OSDI, pp. 335-350, 2006.
[24] S. Lauterburg, R.K. Karmani, D. Marinov, G. Agha. Evaluat-
ing Ordering Heuristics for Dynamic Partial-Order Reduction
Techniques. FASE, pp. 308–322, 2010.
[25] M. Odersky, L. Spoon, B. Venners. Programming in Scala.
Artima, 2008.
[26] M. K. Reiter. Secure Agreement Protocols: Reliable and
Atomic Group Multicast in Rampart. CCS, pp. 68–80, 1994.
[27] K. Sen, G. Agha. Automated Systematic Testing of Open
Distributed Programs. FASE, pp. 339–356, 2006.
[28] M. Seraﬁni et al. Application-Level Diagnostic and Mem-
bership Protocols for Generic Time-Triggered Systems. IEEE
Trans. on Dep. and Sec. Comp., 2011 (To appear).
[11] M. Chaouch-Saad, V. Charron-Bost, S. Merz. A Reduction
Theorem for the Veriﬁcation of Round-Based Distributed Al-
gorithms. Proc. Reachability Problems, pp. 93–106, 2009.
[29] W. Steiner, J. Rushby, M. Sorea, H. Pfeifer. Model Checking
a Fault-Tolerant Startup Algorithm: From Design Exploration
To Exhaustive Fault Simulation. DSN, pp. 189–198, 2004.
[12] E. Clarke, O. Grumberg, D. Peled. Model Checking. MIT
Press, 2000.
[30] T. Tsuchiya, A. Schiper. Using Bounded Model Checking to
Verify Consensus Algorithms. DISC, pp. 466–480, 2008.
[13] C. Flanagan, P. Godefroid. Dynamic Partial-Order Reduction
for Model Checking Software. POPL, pp. 110–121, 2005.
[31] A. Valmari. The State Explosion Problem. Petri Nets I: Basic
Models, pp. 429-528, 1998.
[14] S. Frolund, G. Agha. Abstracting Interactions Based on Mes-
sage Sets. Object-based Models and Languages for Concurrent
Systems., pp. 107–124, 1995.
[15] P. Godefroid.
Partial-Order Methods for the Verifcation
of Concurrent Systems: An Approach to the State-Explosion
Problem Springer, 1996.
[16] G. Gueta, C. Flanagan, E. Yahav, M. Sagiv. Cartesian Partial-
Order Reduction. SPIN, pp. 95–112, 2007.
[32] P. Verissimo, L. Rodrigues. Distributed Systems for System
Architects. Kluwer, 2001.
[33] M. Yabandeh, N. Knezevic, D. Kostic, V. Kuncak. Crystal-
Ball: Predicting and Preventing Inconsistencies in Deployed
Distributed Systems. NSDI, pp. 229–244,2009.
[34] Y. Yang, X. Chen, G. Gopalakrishnan, R. Kirby. Efﬁcient
Stateful Dynamic Partial Order Reduction. SPIN, pp. 288–305,
2008.
[17] G. J. Holzmann. The SPIN Model Checker : Primer and
Reference Manual. Addison-Wesley, 2004.
[35] J. Yang et al. MODIST: Transparent Model Checking of
Unmodiﬁed Distributed Systems. NSDI, pp. 213–228, 2009.
[18] V. Kahlon, C. Wang, A. Gupta. Monotonic Partial Order
Reduction: An Optimal Symbolic Partial Order Reduction
Technique. CAV, pp. 398–413, 2009.
[19] R. K. Karmani, A. Shali, G. Agha. Actor Frameworks for the
JVM Platform: A Comparative Analysis. Int. Conf. Principles
and Practice of Programming in Java., pp. 11–20, 2009.
[20] L. Lamport. The part-time parliament. ACM Trans. Comp.
Sys., 16(2):133–169, 1998.
[21] L. Lamport.
Paxos made simple. ACM SIGACT News,
32(4):18–25, 2001.
[22] L. Lamport, R. Shostak, M. Pease. The Byzantine Generals
Problem. ACM Trans. Prog. Lang. and Sys., 4(3): 382–401,
1982.
12
[36] http://www.deeds.informatik.tu-darmstadt.de/peter/MP-
Basset.pdf
[37] http://hadoop.apache.org/zookeeper/issue tracking.html
[38] http://hadoop.apache.org/zookeeper/
[39] http://babelﬁsh.arc.nasa.gov/trac/jpf
[40] http://aws.amazon.com/s3/
[41] http://code.google.com/p/upright/
[42] http://www.isi.deterlab.net/
[43] http://www.deeds.informatik.tu-darmstadt.de/peter/mp-basset/
APPENDIX
I. MP-BASSET – USER GUIDE
Basic Model Structure. MP-Basset models are written in
Java-syntax and consist of the following (copying Basset’s
actor programs):
• Process (or actor) classes are “types” of processes.
For example, Paxos deﬁnes three classes of processes:
proposers, acceptors, and learners. An actual process is
an instantiation of its class. Every process class must
extend the Actor class and deﬁne a constructor for
instantiation. In additions, a process class can deﬁne
variables and transitions. Variables are used to encode
the local state of the process. Transitions specify the
change of the local state.
• A driver is a conﬁguration ﬁle describing the number
and classes of processes of the system under test. Every
process is created as an instance of its class and is
launched by the driver. If a transition t requires no
message to be executed, then “fake” messages called
t are sent by the driver to the process executing t.
For example, proposers in Paxos can be triggered from
within the driver.
• The speciﬁcation expresses the desired properties of
the system. In the current version of MP-Basset, the
speciﬁcation is a set of Java assertions that can be
deﬁned within transitions. In other words, the spec-
iﬁcation restricts to invariants (or global predicates).
If the assertion evaluates to false,
then the search
is terminated and a counterexample is given (if the
+fw.ce=1 ﬂag is set).7
Models are stored under /jpf-actor/src/examples. An ex-
ample model of the Paxos protocol can be found in the
package paxos.actor (DriverMP.java, ProposerMP.java, Ac-
ceptorMP.java, and LearnerMP.java).
Deﬁning Transitions. The syntax of transitions is ex-
plained in Table III. In MP-Basset, every transition t is
annotated with @message and is named after the type
of the messages that can be consumed by t. Formally,
the type of the message corresponds to a subset of all
messages and a transition can only process messages from
the corresponding subset. A message consists of its type
(or name) and a tuple of values. These values are passed
as parameters to the transition consuming the message. For
example, “READ(proposer1, 2)” in Paxos is a message of
type READ carrying the parameters proposer1 (the name of
the sender of the message) and 2 (proposal number). A tran-
sition might change the local state of the process and send
messages to other processes. Sending a message follows
the syntax send(recipient,msgType,p1,...,pN)
7Note that although the message-passing computation model “isolate”
one process from another, Java in MP-Basset allows access to the state of
a remote process. Be aware: this is a hack and side effects must be avoided!
with the recipient,
message.
the type, and the parameters of the
A special class of transitions is quorum transitions.
Quorum transitions can consume more than one messages.
A quorum transition msgType has an additional param-
eter of the Java type Object[] that
is an array of
messages each of them of type msgType. The order of
the elements in this array is arbitrary, in accordance to
the the MP semantics. Given a quorum transition of the
form msgType(p1,...,pN,Object[] messages),
the parameters p1,...,pN deﬁne the format of the message
so that a message can be cast from its Object type in the
array. By convention, p1,...,pN must not be read or written
by a quorum transition!
Every transition msgType can be associated with a guard
(similarly to disabling “local synchronization guards” in
ActorFoundry). Guards are annotated with @Guard. The
guard is a Java function with boolean return value. A guard
must not change the local state of the process nor send any
message. If no guard is deﬁned, any set containing messages
of type msgType and sent to this process is accessible for
transition msgType (as of MP semantics).
SPOR Support. Transitions can be annotated with
@LPORAnnotation in order to ease SPOR and to enable
our transition reﬁnement strategies (Table IV). The methods
of this annotation are summarized in Table IV. The last three
methods relate to quorum and reply-split, respectively. In
particular, the user can tune the initial transition heuristic
of POR. A possible heuristic is the “opposite transaction
heuristic” where the greater priority() the most likely
that t does not ﬁnish a concurrent operation (e.g., a Paxos
instance or a multicast). In the current version of MP-Basset,
the correctness of @LPORAnnotation must be veriﬁed by the
user!
We now review the most important property preservation
features of the SPOR algorithm in MP-Basset:
• All deadlock states are preserved, i.e.,
the reduced
state graph contains a deadlock state s iff s is in the
unreduced state graph.
• If the unreduced state graph contains no cycles, no
inﬁnite paths, and all visible transitions with respect
to a “state-predicate” P [12] are annotated (with
isVisible=true), then global reachability is pre-
served, i.e., there is a state s ∈ S in the reduced
state graph such that ¬P (s) iff there is s′ ∈ S in the
unreduced state graph such that ¬P (s′).
Transition Reﬁnement: Reply-split. Reply-split can be
implemented by using isReplyTransition() (see Ta-
ble IV). The current implementation only supports reply-
split of single-message transitions. If a transition t con-
suming messages of type msgType is ﬂagged by this
annotation, then we assume that
• the transition is called msgType_senderID where
13
Name
Single-message
transition
Quorum
transition
Guard
Syntax
Description
@message
msgType(Type1 p1, ..., TypeN pN)
@message
msgType(Type1 p1, ..., TypeN pN,
Object[] msgSet)
@Guard
_msgType(Type1 p1, ..., TypeN pN,
Object[] msgSet)
msgType: type of incoming message
pi: ith parameter of the message
msgSet: incoming messages, each of type msgType
pi: ith parameter of msgType
Guard of msgType, returns boolean
msgSet: only for quorum transitions
THE SYNTAX OF MP-BASSET TRANSITION M S GTY P E.
Table III
Name
messageIn()
messageOut()
isReceiver()
recipients()
isSender()
senders()
isStateSensitive()
isWrite()
priority()
isQuorumTransition()
quorumPeers()
isReplyTransition()
quorumSize()
isVisible()
Default return value
""
""
true
Actor.class
true
Actor.class
false
false
0
false
{}
false
0
false
Description
The only type of message t can receive.
The only type of message t can send.
t might process incoming messages.
The class of processes that might send a message to this transition.
t might send messages.
The class of processes whom this transition might send a message.
t’s guard reads the local state.
t writes the local state.
POR initial transition heuristic.
t is quorum transition.
(quorum-split) t receives messages only from the listed processes.
(reply-split) t is a reply transition.
Size of the quorum if t is an exact quorum transition.
True if t is a visible transition.
SUMMARY OF ANNOTATIONS OF TRANSITION t.
Table IV
MP-Basset
implements a static POR algorithm called
LPOR. LPOR can be run with NET-optimization (necessary
enabling transitions). We call this algorithm LPOR-NET.
Currently, the NET relation (required by LPOR-NET) is
based on quorum transitions. Therefore, if there are no
quorum transitions in the protocol, then LPOR and LPOR-
NET achieve the same reduction. Since LPOR-NET has
additional overhead compared to LPOR, we recommend to
use LPOR in these cases. The ﬂag +fw.spor= shall be set
1 for LPOR and 4 for LPOR-NET (the values 2 and 3 are
reserved for pre-computed versions of LPOR).
Compatibility with Basset. The current implementation
of MP-Basset is not fully compatible with Basset. For exam-
ple, the dynamic POR (DPOR) algorithms implemented by
Basset do not work with quorum transitions. Also, DPOR
and LPOR cannot be combined. Protocols without quorum
transitions and using the “guards” of ActorFoundry can be
model checked with Basset. The different DPOR algorithms
can be used by setting the value of +fw.dpor (see Basset
documentation).
senderID is the ID of the (only) process that “commu-
nicates” with this transition,
• the process
senderID sending messages of
type
msgType to the process executing t renames these
messages to msgType_senderID before sending
them.
Note that the messageIn() annotation of a reply transi-
tion does not have to be changed, i.e., it assumes msgType.
Transition Reﬁnement: Quorum-split. A quorum-split
transition is a special quorum transition where the set of pro-
cesses (quorum peers) from which the transition consumes a
message is ﬁx. A quorum transition msgType can be “split”
into a set of quorum transitions by specifying the quorum
peers as an array of process IDs in quorumPeers(). Since
Java does not allow identical method names with the same
signature quorum-split transition names must have a preﬁx
msgType__ (“
” means double underscore).
Examples of both transition reﬁnements techniques can
be found in paxos.actor in classes QSplit*.java.
Running MP-Basset. MP-Basset is built upon Basset and
can be run similarly using the additional ﬂag +fw.mp=1.
14