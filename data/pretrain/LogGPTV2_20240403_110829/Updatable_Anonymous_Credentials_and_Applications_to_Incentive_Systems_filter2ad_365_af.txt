(2) because dsidprvdr, dsid∗
remains to show that if error does not happen and there exists a consistent explanation list L, then
22
Table 1: Avg. performance of our implementation over 100 runs in milliseconds. Emphasized: typical
execution platform for each algorithm.
Device
Google Pixel (Phone, Snapdragon 821)
Surface Book 2 (Laptop, i7-8650U)
Issue
56
10
Join Credit Earn Deduct Spend
390
76
13
69
110
18
122
17
353
64
A cannot win (implying that unless error, if A wins, then B wins as there is no L that would make
it lose). The proof of this is somewhat technical, but essentially, we look at each user individually.
For this user, there exists some “canonical” sequence of spend and earn operations in L that does
not involve any spend operations marked as invalid (in the double-spending database DB). From
the design of update functions and consistency of L, it is clear that in such a sequence, the value
accumulated by earn operations cannot be smaller than the value spent through spend operations,
i.e. the desired property vearned ≥ vspent − vinvalid holds if we only consider these canonical operations.
The rest of the proof deals with ensuring that spend operations that are not part of the canonical
sequence have all been marked invalid in DB (such that removing all non-canonical operations
from consideration does not change vspent − vinvalid and only decreases vearned). Because of ¬error,
challenges γ do not repeat and any two attribute-vectors that share the same dsid have the same
usk, dsrnd. This implies that extracting usk from two transactions with the same dsid works without
error (given c = usk · γ + dsrnd and the deﬁnition of Link). Since any extracted usk is correct in this
sense, the tracing of dsid as in DBsync works as intended, i.e. all invalid transactions will be marked
as such in DB as required.
The full proof can be found in Appendix F.3.
Theorem 16. If encryption scheme Πenc is CPA-secure and Πuacs has simulation anonymity, then
Πinsy (Construction 23) is framing resistant.
Framing resistance follows easily via reduction to Πenc’s (key-ind.) CPA security: An adversary
who can frame an honest user needs to be able to compute the secret key usk for the user’s
upk = ComputePKenc(pp, usk). The proof can be found in Appendix F.4
8 Instantiation and Performance of our Incentive System
We instantiated Construction 23 using the signature scheme by Pointcheval and Sanders [PS16]
for the UACS, and ElGamal as the public-key encryption scheme and malleable commitment. A
concrete description of the instantiated scheme can be found in Appendix E. Using the open-source
Java library upb.crypto and the bilinear group provided by mcl (bn256)2 we implemented this
instantiation and ran it on a phone (typical user device) and a laptop (approximate provider device).
In Table 1 we focus on the execution time (in ms) of the protocols, excluding communication cost.
The numbers illustrate that our scheme is practical. They are better or comparable to the BBA+
performance [HHNR17], who do not oﬀer partial spending (the user needs to reveal point count
when spending) and hence can avoid expensive range proofs.
References
[Ame19]
American Express Company. American express membership rewards. https://global.
americanexpress.com/rewards, January 2019.
2upb.crypto: https://github.com/upbcuk. mcl: https://github.com/herumi/mcl
23
[BB18]
Johannes Bl¨omer and Jan Bobolz. Delegatable attribute-based anonymous credentials
from dynamically malleable signatures.
In Bart Preneel and Frederik Vercauteren,
editors, ACNS 18, volume 10892 of LNCS, pages 221–239. Springer, Heidelberg, July
2018.
[CGH11]
[CHL05]
[CKS10]
[CDD17]
[BBB+18] Kai Bemmann, Johannes Bl¨omer, Jan Bobolz, Henrik Br¨ocher, Denis Diemert, Fabian Ei-
dens, Lukas Eilers, Jan Haltermann, Jakob Juhnke, Burhan Otour, Laurens Porzenheim,
Simon Pukrop, Erik Schilling, Michael Schlichtig, and Marcel Stienemeier. Fully-featured
anonymous credentials with reputation system. In ARES, pages 42:1–42:10. ACM, 2018.
[BCKL08] Mira Belenkiy, Melissa Chase, Markulf Kohlweiss, and Anna Lysyanskaya. P-signatures
and noninteractive anonymous credentials. In Ran Canetti, editor, TCC 2008, volume
4948 of LNCS, pages 356–374. Springer, Heidelberg, March 2008.
Jan Camenisch, Raﬁk Chaabouni, and abhi shelat. Eﬃcient protocols for set membership
and range proofs. In Josef Pieprzyk, editor, ASIACRYPT 2008, volume 5350 of LNCS,
pages 234–252. Springer, Heidelberg, December 2008.
Jan Camenisch, Manu Drijvers, and Maria Dubovitskaya. Practical UC-secure dele-
gatable credentials with attributes and their application to blockchain. In Bhavani M.
Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017,
pages 683–699. ACM Press, October / November 2017.
Scott E. Coull, Matthew Green, and Susan Hohenberger. Access controls for oblivious
and anonymous systems. ACM Trans. Inf. Syst. Secur., 14(1):10:1–10:28, 2011.
Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact e-cash. In Ronald
Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 302–321. Springer,
Heidelberg, May 2005.
Jan Camenisch, Markulf Kohlweiss, and Claudio Soriente. Solving revocation with
eﬃcient update of anonymous credentials. In Juan A. Garay and Roberto De Prisco,
editors, SCN 10, volume 6280 of LNCS, pages 454–471. Springer, Heidelberg, September
2010.
Jan Camenisch and Anna Lysyanskaya. An eﬃcient system for non-transferable anony-
mous credentials with optional anonymity revocation.
In Birgit Pﬁtzmann, editor,
EUROCRYPT 2001, volume 2045 of LNCS, pages 93–118. Springer, Heidelberg, May
2001.
Jan Camenisch and Anna Lysyanskaya. Signature schemes and anonymous credentials
from bilinear maps. In Matthew Franklin, editor, CRYPTO 2004, volume 3152 of LNCS,
pages 56–72. Springer, Heidelberg, August 2004.
Ivan Damg˚ard. Eﬃcient concurrent zero-knowledge in the auxiliary string model. In Bart
Preneel, editor, EUROCRYPT 2000, volume 1807 of LNCS, pages 418–430. Springer,
Heidelberg, May 2000.
Liesje Demuynck and Bart De Decker. Anonymous updating of credentials. Technical
report, December 2005.
[DDD05]
[Dam00]
[CCs08]
[CL01]
[CL04]
[DMM+18] Dominic Deuber, Matteo Maﬀei, Giulio Malavolta, Max Rabkin, Dominique Schr¨oder,
and Mark Simkin. Functional credentials. PoPETs, 2018(2):64–84, 2018.
24
[GGM14] Christina Garman, Matthew Green, and Ian Miers. Decentralized anonymous credentials.
In NDSS 2014. The Internet Society, February 2014.
Jens Groth and Amit Sahai. Eﬃcient non-interactive proof systems for bilinear groups.
In Nigel P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 415–432.
Springer, Heidelberg, April 2008.
[GS08]
[HHNR17] Gunnar Hartung, Max Hoﬀmann, Matthias Nagel, and Andy Rupp. BBA+: improving
the security and applicability of privacy-preserving point collection. In ACM Conference
on Computer and Communications Security, pages 1925–1942. ACM, 2017.
Tibor Jager and Andy Rupp. Black-box accumulation: Collecting incentives in a
privacy-preserving way. PoPETs, 2016(3):62–82, 2016.
[JR16]
[MDPD15] Milica Milutinovic, Italo Dacosta, Andreas Put, and Bart De Decker. ucentive: An
eﬃcient, anonymous and unlinkable incentives scheme. In TrustCom/BigDataSE/ISPA
(1), pages 588–595. IEEE, 2015.
[NDD06] Vincent Naessens, Liesje Demuynck, and Bart De Decker. A fair anonymous submission
and review system. In Herbert Leitold and Evangelos P. Markatos, editors, Commu-
nications and Multimedia Security, 10th IFIP TC-6 TC-11 International Conference,
CMS 2006, Heraklion, Crete, Greece, October 19-21, 2006, Proceedings, volume 4237 of
Lecture Notes in Computer Science, pages 43–53. Springer, 2006.
PAYBACK GmbH. Payback. https://www.payback.net/, January 2019.
David Pointcheval and Olivier Sanders. Short randomizable signatures. In Kazue Sako,
editor, CT-RSA 2016, volume 9610 of LNCS, pages 111–126. Springer, Heidelberg,
February / March 2016.
[PAY19]
[PS16]
A Security Deﬁnitions for Building Blocks
Deﬁnition 17 (Unforgeability). Consider the following unforgeability game Expblind-uf(Π,A, λ) for
a blind signature scheme Π:
• The experiment runs pp ← G(1λ) and hands pp to A. A responds with 1n for some n ∈ N.
The experiment generates (pk, sk) ← KeyGen(pp, 1n) and hands pk to A.
• A can query signatures by announcing c, ~m ∈ Mn and r such that c = Commit(pp, pk, ~m, r).
The experiment then runs BlindSign(pp, pk, sk, c) interacting with A and records ~m.
• Eventually, A outputs ~m∗ and σ∗. The experiment outputs 1 iﬀ Vrfy(pp, pk, ~m∗, σ∗) = 1 and
~m∗ was not recorded in any query.
Π has blind unforgeability if for all ppt A there exists negl such that Pr[Expblind-uf(Π,A, λ) = 1] ≤
(cid:5)
negl(λ) for all λ.
Deﬁnition 18 (Perfect msg privacy). We say that a blind signature scheme has perfect message
privacy if
• “the commitment scheme is perfectly hiding”: For all ~m0, ~m1 ∈ M n, Commit(pp, pk, ~m0, r0) is
distributed exactly the same as Commit(pp, pk, ~m1, r1) over the random choice of r0, r1.
25
• “BlindRcv does not reveal the message”: for any two messages ~m0, ~m1 ∈ M n and all (unre-
stricted) A:
(outputA[A(C0) ↔ BlindRcv(pp, pk, ~m0, r0)], χ0)
is distributed exactly like
(outputA[A(C1) ↔ BlindRcv(pp, pk, ~m1, r1)], χ1)
where r0, r1 is chosen uniformly at random, Cj = Commit(pp, pk, ~mj, rj) and χj is an indicator
variable with χj = 1 if and only if Vrfy(pp, pk, ~mj, σj) = 1 for the local output σj of BlindRcv
(cid:5)
in either case.
While this deﬁnition may seem strong, it is satisﬁed, for example, by the Pointcheval Sanders blind
signature scheme [PS16], where Commit is a eﬀectively a (perfectly hiding) Pedersen commitment,
Their BlindRcv (in our formulation without zero-knowledge proof) does not send any messages
(meaning the output of A is clearly independent of ~m), and the χj bit (validity of the resulting
signature) is also independent of the committed message.
Deﬁnition 19 (Key-indistinguishable CPA). Let Πenc be a public-key encryption scheme. Consider
the following experiments Expkey-ind
(Πenc,A, λ) for b ∈ {0, 1}.
b
• The experiment generates public parameters pp ← G(1λ) and two keys KeyGenenc(pp) →
sk0, sk1, hands A the pp and the two public keys (pk0, pk1) = (ComputePKenc(pp, sk0),
ComputePKenc(pp, sk1)).
• A outputs two messages m0, m1 ∈ Mpp.
• A gets Encryptenc(pp, pkb, mb) from the experiment and outputs a bit ˆb.
0
(Πenc,A, λ) = 1] − Pr[Expkey-ind
We say that Πenc is key-ind. CPA secure if for all ppt A, there exists a negligible function negl s.t.
| Pr[Expkey-ind
Deﬁnition 20 (Perfectly binding commitment). A (malleable) commitment scheme is perfectly
binding if for all pp ∈ [G(1λ)], pk ∈ [KeyGen(pp)] and all (c, o) ∈ [Commit(pp, pk, m)], there exists no
m0, o0 such that m0 6= m and Vrfy(pp, pk, c, o0, m0) = 1.
Deﬁnition 21 (Comp. hiding commitment). Let Πcmt be a malleable commitment scheme. Consider
the following experiment Exphid
(Πenc,A, λ) = 1]| ≤ negl(λ)
(Πcmt,A, λ).
1
b
• pp ← G(1λ), pk ← KeyGen(pp), (m0, m1, st) ← A(pp, pk), m0, m1 ∈ Mpp
• ˆb ← A(c, st) where c = Commit(pp, pk, mb)
We say that Πcmt is computational hiding if for all ppt A, there exists a negligible function negl s.t.
| Pr[Exphid
0 (Πcmt,A, λ) = 1] − Pr[Exphid