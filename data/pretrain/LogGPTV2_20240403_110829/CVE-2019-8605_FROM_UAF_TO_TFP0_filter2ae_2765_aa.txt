# CVE-2019-8605 FROM UAF TO TFP0
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
作者：wnagzihxa1n | wnagzihxa1n#gmail.com
这篇文章的开始是我看了Ned Williamson的一个漏洞
  * 
同时还在PJ0的博客上发了一篇非常非常棒的文章
  * 
公告
    // https://support.apple.com/en-us/HT210549
    Available for: iPhone 5s and later, iPad Air and later, and iPod touch 6th generation
    Impact: A malicious application may be able to execute arbitrary code with system privileges
    Description: A use after free issue was addressed with improved memory management.
    CVE-2019-8605: Ned Williamson working with Google Project Zero
## 1\. 开发层面的Socket
如公告所描述，这是一个存在于Socket中的UAF漏洞
一般搞开发的同学对于Socket更多的是了解到开发层面，比如使用Socket通信，我们从开发层面开始，逐步分析到底层
我们在学习计算机网络的时候，通过逻辑分层将网络分为七层，也叫作七层模型
  * 
后来又出现了更为符合使用习惯的四层模型
  * 
函数`socket()`的原型如下，一共有三个参数
    int socket(int domain, int type, int protocol);
第一个参数domain：协议族，比如`AF_INET`，`AF_INET6`
第二个参数type：socket类型，比如`SOCK_STREAM`，`SOCK_DGRAM`，`SOCK_RAW`
    #define    SOCK_STREAM    1        /* stream socket */
    #define    SOCK_DGRAM    2        /* datagram socket */
    #define    SOCK_RAW    3        /* raw-protocol interface */
    #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
    #define    SOCK_RDM    4        /* reliably-delivered message */
    #endif    /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
    #define    SOCK_SEQPACKET    5        /* sequenced packet stream */
第三个参数protocol：传输协议，比如`IPPROTO_TCP`，`IPPROTO_UDP`
创建一个`Socket`对象的代码如下
    int tcp_sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    if (tcp_sock 
## 2\. 漏洞源码分析
**用户态函数`disconnectx()`**
这个函数很难在搜索网站上搜到相关文档信息，我最后是通过源码阅读来理解这个函数调用在Poc里的作用
    __API_AVAILABLE(macosx(10.11), ios(9.0), tvos(9.0), watchos(2.0))
    int disconnectx(int, sae_associd_t, sae_connid_t);
    448    AUE_NULL    ALL    { int disconnectx(int s, sae_associd_t aid, sae_connid_t cid); }
通过分发，会调用到这个内核态函数，然后调用位置1的函数`disconnectx_nocancel()`
    int
    disconnectx(struct proc *p, struct disconnectx_args *uap, int *retval)
    {
        /*
         * Due to similiarity with a POSIX interface, define as
         * an unofficial cancellation point.
         */
        __pthread_testcancel(1);
        return (disconnectx_nocancel(p, uap, retval));    // 1
    }
位置2的函数`file_socket()`获取结构体变量`so`，最后调用位置3的函数`sodisconnectx()`
    static int
    disconnectx_nocancel(struct proc *p, struct disconnectx_args *uap, int *retval)
    {
    #pragma unused(p, retval)
        struct socket *so;
        int fd = uap->s;
        int error;
        error = file_socket(fd, &so);    // 2
        if (error != 0)
            return (error);
        if (so == NULL) {
            error = EBADF;
            goto out;
        }
        error = sodisconnectx(so, uap->aid, uap->cid);    // 3
    out:
        file_drop(fd);
        return (error);
    }
前后调用函数`socket_lock()`和`socket_unlock()`用了锁防条件竞争，然后调用位置4的函数`sodisconnectxlocked()`
    int
    sodisconnectx(struct socket *so, sae_associd_t aid, sae_connid_t cid)
    {
        int error;
        socket_lock(so, 1);
        error = sodisconnectxlocked(so, aid, cid);    // 4
        socket_unlock(so, 1);
        return (error);
    }
位置5的`*so->so_proto->pr_usrreqs->pru_disconnectx`是一个函数
    int
    sodisconnectxlocked(struct socket *so, sae_associd_t aid, sae_connid_t cid)
    {
        int error;
        /*
         * Call the protocol disconnectx handler; let it handle all
         * matters related to the connection state of this session.
         */
        error = (*so->so_proto->pr_usrreqs->pru_disconnectx)(so, aid, cid);    // 5
        if (error == 0) {
            /*
             * The event applies only for the session, not for
             * the disconnection of individual subflows.
             */
            if (so->so_state & (SS_ISDISCONNECTING|SS_ISDISCONNECTED))
                sflt_notify(so, sock_evt_disconnected, NULL);
        }
        return (error);
    }
通过结构体初始化赋值的特征进行搜索，找到对应的实现是函数`tcp_usr_disconnectx()`，该函数的三个参数就是用户态传入的参数，位置6有一个条件判断，我们只需要令第二个参数为`0`即可绕过，绕过判断之后，调用位置7的函数`tcp_usr_disconnect()`
    #define    SAE_ASSOCID_ANY    0
    #define    SAE_ASSOCID_ALL    ((sae_associd_t)(-1ULL))
    #define    EINVAL        22        /* Invalid argument */
    static int
    tcp_usr_disconnectx(struct socket *so, sae_associd_t aid, sae_connid_t cid)
    {
    #pragma unused(cid)
        if (aid != SAE_ASSOCID_ANY && aid != SAE_ASSOCID_ALL)    // 6
            return (EINVAL);
        return (tcp_usr_disconnect(so));    // 7
    }
函数`tcp_usr_disconnect()`有两个宏：`COMMON_START()`和`COMMON_END(PRU_DISCONNECT)`，`COMMON_START()`会执行`tp
= intotcpcb(inp)`对变量`tp`进行赋值，所以业务逻辑上是没有问题的，然后调用位置8的函数`tcp_disconnect()`
    static int
    tcp_usr_disconnect(struct socket *so)
    {
        int error = 0;
        struct inpcb *inp = sotoinpcb(so);
        struct tcpcb *tp;
        socket_lock_assert_owned(so);
        COMMON_START();
            /* In case we got disconnected from the peer */
            if (tp == NULL)
            goto out;
        tp = tcp_disconnect(tp);    // 8
        COMMON_END(PRU_DISCONNECT);
    }
函数`tcp_disconnect()`有一个判断`tp->t_state t_state`是Socket状态，我列举了部分，因为我们只创建了一个结构体变量`socket`，并没有调用函数`bind()`与函数`listen()`，所以状态为`TCPS_CLOSED`，那么这里就应该调用位置9的函数`tcp_close()`
    #define    TCPS_CLOSED        0    /* closed */
    #define    TCPS_LISTEN        1    /* listening for connection */
    #define    TCPS_SYN_SENT        2    /* active, have sent syn */
    #define    TCPS_SYN_RECEIVED    3    /* have send and received syn */
    /* states t_inpcb->inp_socket;
        if (so->so_rcv.sb_cc != 0 || tp->t_reassqlen != 0)
            return tcp_drop(tp, 0);
        if (tp->t_state so_options & SO_LINGER) && so->so_linger == 0)
            tp = tcp_drop(tp, 0);
        else {
            soisdisconnecting(so);
            sbflush(&so->so_rcv);
            tp = tcp_usrclosed(tp);
    #if MPTCP
            /* A reset has been sent but socket exists, do not send FIN */
            if ((so->so_flags & SOF_MP_SUBFLOW) &&
                (tp) && (tp->t_mpflags & TMPF_RESET))
                return (tp);
    #endif
            if (tp)
                (void) tcp_output(tp);
        }
        return (tp);
    }
想要在用户态进行状态判断可以参照如下代码
    // https://developer.apple.com/documentation/kernel/tcp_connection_info
    int tcp_sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    struct tcp_connection_info info;
    int len = sizeof(info);
    getsockopt(tcp_sock, IPPROTO_TCP, TCP_CONNECTION_INFO, &info, (socklen_t *)&len);
    NSLog(@"%d", info.tcpi_state);
函数`tcp_close()`实在是太长了，这里去掉了部分业务逻辑代码，反正肯定会执行到下面的，此处会判断协议族，本次漏洞发生在位置10的函数`in6_pcbdetach()`
    struct tcpcb *
    tcp_close(struct tcpcb *tp)
    {
        struct inpcb *inp = tp->t_inpcb;
        struct socket *so = inp->inp_socket;
        ...
    #if INET6
        if (SOCK_CHECK_DOM(so, PF_INET6))
            in6_pcbdetach(inp);    // 10
        else
    #endif /* INET6 */
        in_pcbdetach(inp);
        /*
         * Call soisdisconnected after detach because it might unlock the socket
         */
        soisdisconnected(so);
        tcpstat.tcps_closed++;
        KERNEL_DEBUG(DBG_FNC_TCP_CLOSE | DBG_FUNC_END,
            tcpstat.tcps_closed, 0, 0, 0, 0);
        return (NULL);
    }
函数`in6_pcbdetach()`的位置11调用函数`ip6_freepcbopts()`释放结构体成员`inp->in6p_outputopts`，从上下文可以看出来，这里只进行了释放操作，并没有将`inp->in6p_outputopts`置为`NULL`，符合UAF的漏洞模型
    void
    in6_pcbdetach(struct inpcb *inp)
    {
        struct socket *so = inp->inp_socket;
        if (so->so_pcb == NULL) {
            /* PCB has been disposed */
            panic("%s: inp=%p so=%p proto=%d so_pcb is null!\n", __func__,
                inp, so, SOCK_PROTO(so));
            /* NOTREACHED */
        }
    #if IPSEC
        if (inp->in6p_sp != NULL) {
            (void) ipsec6_delete_pcbpolicy(inp);
        }
    #endif /* IPSEC */
        if (inp->inp_stat != NULL && SOCK_PROTO(so) == IPPROTO_UDP) {
            if (inp->inp_stat->rxpackets == 0 && inp->inp_stat->txpackets == 0) {
                INC_ATOMIC_INT64_LIM(net_api_stats.nas_socket_inet6_dgram_no_data);
            }
        }
        /*
         * Let NetworkStatistics know this PCB is going away
         * before we detach it.
         */
        if (nstat_collect &&
            (SOCK_PROTO(so) == IPPROTO_TCP || SOCK_PROTO(so) == IPPROTO_UDP))
            nstat_pcb_detach(inp);
        /* mark socket state as dead */
        if (in_pcb_checkstate(inp, WNT_STOPUSING, 1) != WNT_STOPUSING) {
            panic("%s: so=%p proto=%d couldn't set to STOPUSING\n",
                __func__, so, SOCK_PROTO(so));
            /* NOTREACHED */
        }
        if (!(so->so_flags & SOF_PCBCLEARING)) {
            struct ip_moptions *imo;
            struct ip6_moptions *im6o;
            inp->inp_vflag = 0;
            if (inp->in6p_options != NULL) {
                m_freem(inp->in6p_options);
                inp->in6p_options = NULL;
            }
            ip6_freepcbopts(inp->in6p_outputopts);    // 11
            ROUTE_RELEASE(&inp->in6p_route);
            /* free IPv4 related resources in case of mapped addr */
            if (inp->inp_options != NULL) {
                (void) m_free(inp->inp_options);