title:NativeX: Native Executioner Freezes Android
author:Qinsheng Hou and
Yao Cheng and
Lingyun Ying
NativeX: Native Executioner Freezes Android
Qinsheng Hou
QI-ANXIN Technology Research
Legendsec Information Technology
Institute
(Beijing) Inc.
Beijing, China
PI:EMAIL
Yao Cheng
Huawei International
Singapore, Singapore
PI:EMAIL
Lingyun Ying∗
QI-ANXIN Technology Research
University of Chinese Academy of
Institute
Sciences
Beijing, China
PI:EMAIL
ABSTRACT
Android is a Linux-based multi-thread open-source operating
system that dominates 85% of the worldwide smartphone market
share. Though Android has its established management for its
framework layer processes, we discovered for the first time that the
weak management of native processes is posing tangible threats
to Android systems from version 4.2 to 9.0. As a consequence,
any third-party application without any permission can freeze
the system or force the system to go through a reboot by
starving or significantly delaying the critical system services using
Android commands in its native processes. We design NativeX to
systematically analyze the Android source code to identify the
risky Android commands. For each identified risky command,
NativeX can automatically generate the PoC (Proof-of-Concept)
application, and verify the effectiveness of the generated PoC.
We conduct manual vulnerability analysis to reveal two root
causes beyond the superficial attack consequences. We further
carry out quantitative experiments to demonstrate the attack
consequences, including the device temperature surge, the battery
degeneration, and the computing performance decrease, based on
which, three representative PoC attacks are engineered. Finally, we
discuss possible defense approaches to improve the management
of Android native processes.
CCS CONCEPTS
• Security and privacy → Mobile platform security; Denial-
of-service attacks.
KEYWORDS
Android security, mobile system security, denial-of-service attacks,
Android native processes, Android commands
ACM Reference Format:
Qinsheng Hou, Yao Cheng, and Lingyun Ying. 2020. NativeX: Native
Executioner Freezes Android. In Proceedings of the 15th ACM Asia Conference
on Computer and Communications Security (ASIA CCS ’20), June 1–5, 2020,
∗Corresponding author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ASIA CCS ’20, June 1–5, 2020, Taipei, Taiwan
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6750-9/20/06...$15.00
https://doi.org/10.1145/3320269.3384713
Taipei, Taiwan. ACM, New York, NY, USA, 13 pages. https://doi.org/10.1145/
3320269.3384713
1 INTRODUCTION
Android is a Linux-based multi-thread open-source operating
system for mobile devices. It not only has gained tremendous
popularity among mobile users in recent years, but also has
been used in IoT devices and various mission-critical tasks, such
as point-of-sale devices [11], medical devices [30], on-vehicle
systems [5][6], and even aircraft and satellite devices [1][10]. One
of the reasons that Android has been widely adopted is that Android
provides compatible development support for programming in both
framework layer and native layer, so that developers can freely
enjoy both the transparent access to Android resources in the
framework layer and the low running latency and high protection
in the native layer.
The fundamental resources, i.e., system resources and device
computing resources, are shared across the Android system for both
framework layer processes and native layer processes. In order to
avoid conflict during the use of the system resources, the access to
such resources is coordinated by the synchronization mechanism.
The synchronization mechanism works by introducing an exclusive
lock that only one thread at a time can acquire the lock (except the
read lock) and the lock is required to be acquired prior to any access
to the shared resource [7]. However, it also implies that if a process
has occupied a system resource, the other processes waiting for the
resource are blocked until the resource becomes free. Similarly, if a
process has taken a large portion of the device computing resources,
e.g., CPU or RAM, the other processes may run slow due to the lack
of computing resources.
In case such an undesirable situation happens, Android provides
a set of process management mechanisms for different situations
to ensure the proper functioning of the system. For the situations
where an app is not responding, the device memory is low, and a
system service is not responding, Android triggers Application Not
Responding (ANR), Low Memory Killer (LMK), and the Android
watchdog mechanism, respectively. The proper functioning of
Android relies on the assumption that there is no process that
cannot be properly managed (e.g., killing or restarting the process)
by any above memory management mechanism.
Unfortunately, this assumption does not always hold. Our work
uncovers that an Android native process is such a process that
can exhaustively monopolize the system resources or the device
computing resources in an unconfined manner. The native process
here aligns with the native process concept used in LMK. It refers
to Linux processes running in the Android system. A native process
can be from i) the Linux executables shipped in Android system, no
matter it can be invoked by third-party apps or not, and ii) the third-
party apps through Java API Runtime.getRuntime().exec(), na-
tive API fork() or system(). A native process cannot be properly
managed by any existing memory management mechanism. Due
to the insufficient management of native processes, an app without
any permission can result in an unresponsive Android within 5
seconds using the legitimate Android commands as attack vectors.
To the best of our knowledge, this is the first exploration
of exploiting Android commands as attack vectors. With the
improvement of discreet security mechanisms in Android, it is more
and more difficult to exploit APIs as attack vectors. The attacks
relying APIs as attack vectors on previous Android versions cannot
be reproduced in later versions due to the unavailability of the attack
APIs or new constraints in accessing directories or files [22][23][31].
Using legitimate commands as attack vectors is rarely studied which
is, in fact, a valuable direction that is worth exploring.
We quantitatively evaluate the attack consequences, including
device temperature surge, battery degeneration, and computing
performance decrease under persistent attack. Though the attack
consequences may be speculative, they are rarely studied in a
quantitative manner. Based on the easily-exploitable nature of the
vulnerability, we also design and present three representative PoC
attacks, i.e., DoS attack against Android system, DoS attack against
Android app, and physical harm to users.
This work suggests that the weak management of Android native
processes urgently requires amendment. We also discuss possible
We design and implement an automatic analyzing tool named
NativeX (Native eXecutioner) to identify the risky Android
commands, generate the PoC (Proof-of-Concept) exploit apps, and
verify the effectiveness of the generated PoC apps. Note that the
Android commands here include both Linux commands (e.g., top)
and Android-specific commands (e.g., am). Specifically, NativeX
takes Android source code including both framework source code
and command source code as input. It is able to find out the system
resources, specifically the storage resources, i.e., files and directories,
that are shared by both the framework critical system services
and the Android commands. NativeX focuses on storage resources
since they have been considered as a type of informative and
competing resources [17]. NativeX further automatically constructs
a PoC exploit app for each Android command identified in the
previous step, and verifies the effectiveness of the app. Our findings
show that this type of vulnerabilities existing in a wide range of
Android versions from 4.2 to 9.0 which cover 99.7% of more than 2
billion real-world Android devices including smartphones and IoT
devices [3][9].
We further conduct manual vulnerability analysis and reveal
two root causes. Firstly, there is no restriction on the number
of native processes that an Android app can spawn. Secondly,
for the native processes that have already started, there is no
effective management, that is, Android cannot effectively manage
the resources used by native processes even when the system itself
is under high resource pressure. The vulnerability analysis shows
that, although the attack consequences seem alike, the causes of
the identified vulnerabilities are totally different from the previous
DoS attacks [13][22].
defense approaches against this type of vulnerabilities. In summary,
this paper makes the following main contributions.
• We reveal a new type of vulnerability existing in a wide range
of Android versions from 4.2 to 9.0 that can lead to a system
freeze/reboot within 5 seconds, ascribing to the insufficient
management of Android native processes. An app without
any permission can monopolize a shared resource using
legitimate Android commands in native processes to force
critical system services to be starved or slowed down, which
further freezes the system.
• In order to find out the attack vectors exploiting such
vulnerability, we design and implement an automatic static
analyzing tool NativeX which is the first exploration of using
Android commands as attack vectors. NativeX successfully
identifies a list of commands on the 6 major Android versions
from 4.2 to 9.0 which can be practically used to launch attacks.
It can further construct a PoC exploit app for each identified
command and verify the effectiveness of the PoC app.
• We conduct experiments to qualitatively demonstrate the
attack consequences of the vulnerability in three aspects,
i.e., the temperature surge, the battery degeneration, and
the computing performance decrease. We also showcase
three representative attacks including the DoS attack against
Android system, the DoS attacks against target Android
application, and the physical harm to device users due to the
device overheat.
• We conduct vulnerability analysis and reveal the root causes
of the vulnerability, based on which, we discuss the defense
approaches against such vulnerability and provide our
mitigation analysis to the Android security team for their
reference.
2 BACKGROUND AND VULNERABILITY
OVERVIEW
2.1 Android Process Management
There are four mechanisms that manage the running processes
in Android, i.e., ANR, LMK, Android watchdog, and JVM Garbage
Collector.
ANR. ANR is a situation where an application is not responding
to an input event or processing a broadcast for a certain amount
of time. The ANR mechanism is mainly to guarantee the smooth
performance of Android from the user experience angle. ANR is
managed according to the running information, e.g., the CPU states
and the timeout message, from ActivityManagerService (AMS). ANR
sets time thresholds for completing different types of operations. If
any operation exceeds the preset threshold regardless of the cause
of the delay, Android treats the situation as ANR and pops up a
dialog providing the user with options either to wait or force quit
the unresponsive app. Although the force quit may cause data loss
or interim operation interruption, it can generally improve the user
experience and reduce the risk of extending the local delay to the
system-wide.
LMK. LMK manages the processes from the system memory
usage angle. LMK is designed to monitor the memory state
of the Android system and react to high memory pressure by
killing the least essential processes at that moment to keep the
system performing at acceptable levels. In order to determine the
importance of processes, LMK maintains an importance hierarchy
based on the oom_adj value of the process which has 16 importance
values and is calculated based on a list of factors regularly in
ActivityManagerService. The smaller the process’s oom_adj
value is, the more important the process is. The “native process”
is one of the priority levels. The absolute oom_adj value for the
native process may vary in different Android versions (e.g., -1000
in Android 9.0), but it is the lowest among all the processes within
the same Android version and commented as “not being managed”
in the source code.
Android Watchdog. Android watchdog is to deal with the
system not responding situation. Android watchdog is a separate
thread in system_server that monitors the most important
system services in system_server. It is worth noting here that
the Android watchdog is different from the traditional Linux
watchdog. The Linux watchdog monitors the running status of the
whole system, while Android watchdog only monitors the critical
system services. These services, such as ActivityManagerService
which is fundamental in the previous two process management
mechanisms, are so critical to the Android system that any
failure of these services may lead to the system unavailability.
Android watchdog is a time-based monitor that any opera-
tion exceeding the preset timer triggers a recovery process.
Specifically, Android watchdog has two checkers, i.e., Monitor
Checker. The monitored services reg-
Checker and Looper
ister themselves to watchdog’s Monitor
Checker or Looper
Checker by adding Watchdog.getInstance().addMonitor() or
Watchdog.getInstance().addThread() to the source code in
their service classes. These two checkers obtain the service running
status through some operational tests. If there is a timeout occurs,
Android watchdog generates necessary log information and sends
signal 9 to system_server process to kill and restart it. We can
see that the Android watchdog is designed to recover the system
service from deadlock, starvation and other failures by killing the
system_server and forcing a system soft-reboot. In this sense, the
watchdog is the last line of defense in Android.
JVM Garbage Collector. Other than the three management
mechanisms designed specifically for Android, there is one more
memory management mechanism inherited from the JVM (Java
Virtual Machine). In order to avoid the instability and unrespon-
siveness in JVM applications caused by memory shortage, JVM
Garbage Collector (GC) is to free unreferenced space in the JVM
heap memory. GC monitors all the objects in the heap memory and
deletes objects that are not referenced by any part of the running
application. For Android processes, the framework processes run
in JVM and the native processes spawned from the Java code
(e.g., Runtime.getRuntime().exec()) are also managed by such
mechanisms. However, the native processes spawned from the
native code through JNI framework use memory in the native heap
instead of memory in JVM heap, and hence are not managed by
any mechanisms from JVM.
The above four existing process management mechanisms are all
focusing on the framework processes. Terminating the app process,
e.g., by ANR or LMK, indeed kills all processes in its process group
including both framework processes and native processes. However,
we have not observed any management mechanism specifically for
the native processes, which implies a risk to the Android system.
2.2 Vulnerability Overview
We reveal a new type of vulnerability that is due to the weak man-
agement of native processes. The vulnerability can be understood
from two angles, i.e., the system resources and device computing
resources.