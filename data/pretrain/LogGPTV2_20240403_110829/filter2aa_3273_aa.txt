Re-establishing Trust in Compromised Systems:
Recovering from Rootkits that Trojan the
System Call Table
Julian B. Grizzard, John G. Levine, and Henry L. Owen
{grizzard, levine, owen}@ece.gatech.edu
School of Electrical and Computer Engineering
Georgia Institute of Technology
Atlanta, Georgia 30332–0250, USA
Abstract. We introduce the notion of re-establishing trust in compro-
mised systems, speciﬁcally looking at recovering from kernel-level root-
kits. An attacker that has compromised a system will often install a set
of tools, known as a rootkit, which will break trust in the system as well
as serve the attacker with other functionalities. One type of rootkit is a
kernel-level rootkit, which will patch running kernel code with untrusted
kernel code. Speciﬁcally, current kernel-level rootkits replace trusted sys-
tem calls with trojaned system calls. Our approach to recover from these
type of rootkits is to extract the system call table from a known-good
kernel image and reinstall the system call table into the running ker-
nel. Building on our approach to current generation rootkits, we discuss
future generation rootkits and address how to recover from them.
1
Introduction
Modern computer systems are vulnerable to a wide variety of attacks. As attack-
ers develop methods to exploit these vulnerabilities, a large number of systems
are compromised. Compromises are costly to individuals, companies, govern-
ments, and other organizations in terms of data breach, downtime, adminis-
tration, and recovery. The number of new vulnerabilities discovered each year
is growing, and as such we believe system compromises will continue to be a
problem for the foreseeable future.
Much work has been done on preventing and detecting system compromises;
however, system compromises continue to be a problem. To date we have seen
little work done in terms of methods for recovering from system compromises.
Conventional wisdom states that one should wipe the system clean, reinstall,
and patch with the latest updates.
In this paper, we begin to explore alternatives to conventional wisdom in
terms of recovering from system compromises. In certain cases, it may not be
possible or desirable to shutdown the system to perform a fresh install. We study
kernel-level rootkit modiﬁcations to compromised systems and present tools to
recover from kernel-level rootkits. Our work focuses on the Linux kernel and Red
Hat Linux distribution. The results of our work should be applicable to other
operating systems, especially those on the x86 architecture.
We speciﬁcally discuss one of the most common tactics of modern kernel-level
rootkits: trojaning the system call table. When the system call table is trojaned,
even known good system binaries will not report true information about the
system. Our approach to recover from such attacks is to insert a trusted system
call table from a known good kernel image into the running kernel. This approach
gives control back to the system administrator and is the ﬁrst step in recovering
from a root compromise in which a kernel-level rootkit has been installed.
Future generation kernel-level rookits may trojan other types of kernel code
instead of the system call table. We discuss possible directions for future root-
kits and alternative kernel penetration techniques. Our recovery approach of
bootstrapping trusted code into the kernel may be useful to recover from future
generation rootkits.
1.1
Deﬁnition of Compromised System
When an attacker has gained some level of permissions on a computer system,
the system is said to be compromised. If the attacker gains root access, the com-
promise is considered a root-level compromise. With root-level privileges, the
attacker can change any state within the system. The attacker owns the system.
The attacker can modify the system so that the original trusted reporting pro-
cesses no longer report accurate information. Some level of trust must be restored
to the system before all reporting information can be relied upon, depending on
how trust is broken.
Compromised System — If a system is compromised, then the following con-
ditions are true.
1. An attacker has gained some level of privileges on the system.
2. The attacker can read or modify some portion of the state within the system.
Root-level Compromised System — One speciﬁc class of compromised systems
are root-level compromises. If a system is compromised with root-level access,
then the following conditions are true.
1. An attacker has gained unlimited access to the system.
2. Any state within the system can be read or modiﬁed by the attacker.
3. Trust can be broken in the system.
1.2
Deﬁnition of Rootkit
A rootkit may be considered as a form of a Trojan Horse as discussed in [1].
Once an attacker has compromised a system, he or she often use a rootkit as a
tool to covertly retain access to that system. A rootkit can contain utilities to
allow the attacker to retain access, hide processes and activities, and break trust
in the local system reporting and querying functions.
We classify rootkits into user-level and kernel-level rootkits. A user-level
rootkit will alter operating system tools at the user level (which usually involves
adding or modifying system binaries such as /bin/login). A kernel-level rootkit
will alter or insert kernel-space executing code (e.g. system calls).
1.3
Deﬁnition of Trust
Trust can be deﬁned as the level to which a user believes a computer system
executes as speciﬁed and does nothing else. If a compromise occurs on that
computer system and the user discovers it, the level at which the user trusts
the system is signiﬁcantly lessened. The lowered level of trust is understandable
because, for example, a rootkit may be installed on the compromised system such
that ﬁle listing commands hide certain ﬁles and thus not execute as speciﬁed.
1.4
Overview and Organization
The rest of our paper is outlined as follows. Section 2 discusses the problem of
kernel-level rootkits and previous work. Section 3 discusses current generation
rootkits that modify the system call table. Section 4 describes our approach for
recovering from current generation rootkits. Section 5 shows results of applying
our techniques to real-world rootkits. In Section 6 we look at future generation
rootkits in terms of their penetration techniques and kernel targets to trojan.
Further, we discuss a concept to strengthen our algorithm described in Section
4. Finally, we discuss our conclusions and future work in Section 7
2
Motivation
With the proliferation of exploits targeted to today’s computer systems, an at-
tacker has the ability to compromise a number of systems. Once an attacker has
compromised a system, he or she will want to retain access to that system even
if the original security hole is patched. In order to retain access to a compro-
mised system, the attacker will often install a rootkit onto the target system.
The rootkit will add a backdoor onto the target system that the attacker can
use to reenter the system at a later time. We set up a Red Hat 6.2 system on
the Georgia Tech honeynet [2], and within a matter of days an attacker had
compromised the box and installed a kernel-level rootkit, r.tgz, on the system.
If the system administrator notices that an attacker has compromised the
system, the administrator will immediately take pervasive actions to block the
attacker from reentering the system. However, the attacker may have installed
a rootkit to hide the attacker’s activities, ﬁles, and backdoor entry point. To
accomplish this goal, the rootkit will break trust in system reporting facilities
(e.g. /bin/ls, /usr/bin/top, /sbin/lsmod).
With a user-level rootkit, the system administrator can restore trust in the
system by using known good utilities (e.g. /mnt/cdrom/ls, /mnt/cdrom/top,
/mnt/cdrom/lsmod ). A kernel-level rootkit does not replace binaries but rather
replaces running kernel code. We are not aware of any current methodology
for restoring trust in a running system in which a kernel-level rootkit has been
installed except for a complete reinstallation.
2.1
Related Work
Thimbleby, Anderson, and Cairns developed a mathematical framework to model
Trojans and viruses [3]. They discuss a virus that could infect a system querying
program in such a way that the querying program itself would be unable to
detect that it was infected. This recursive infection leads to the idea behind
kernel-level rootkits. When a kernel-level rootkit is installed, tools that check to
see if a rootkit is installed are relying on an infected program, the kernel.
Recent research has been conducted developing a methodology for charac-
terizing rootkits [1, 4, 5]. The methodology to characterize rootkits involves de-
termining the ∆ between a baseline system and a system compromised with a
kernel-level rootkit. The ∆ is used to characterize rootkits based on checksums,
number of ﬁles replaced, number of ﬁles added, user level verses kernel level,
penetration into the kernel, and so forth.
Government organizations have begun to investigate rootkits. The National
Infrastructure Security Co-ordination Centre for the United Kingdom has re-
cently published a report on Trojans and rootkits that discusses detection, reme-
diation, and prevention of rootkits [6]. Their report describes Trojans as Remote
Access Tools (RATs) that provide the attacker with a backdoor into the com-
promised system. The report discusses some of the functionality of RATs, which
includes: monitoring system activities (i.e. watch users keystrokes and monitor
users), monitor network traﬃc, use system resources, modify ﬁles, relay email
(i.e. spam).
Other work has been conducted towards detecting and preventing kernel-level
rootkits. Kim and Spaﬀord show how a ﬁle system integrity checker, tripwire,
can be used to monitor ﬁles for corruption, change, addition, and deletion [7].
In addition to other uses, tripwire can notify system administrators that system
binaries have changed. Tripwire must establish a baseline for a known good ﬁle
system. To establish a baseline, tripwire takes a hash (e.g. MD5, CRC, Snefru) of
the ﬁles at a known good point. The baseline can be used for comparison at later
points in time. A binary-level rootkit will replace system binaries, which will set
oﬀ the “trip wire” and alert the administrator. However, a rootkit designer can
counteract tripwire by breaking trust in the reporting tools upon which tripwire
relies.
The open source and hacker communities have developed various tools to
detect and prevent rootkits, which include: chkrootkit [8], kern check [9], Check-
IDT [10], and Saint Michael [11]. The chkrootkit tool is a script that checks
systems for signs of rootkits. The chkrootkit script can detect many rootkits in-
cluding both user-level rootkits and kernel-level rootkits, however some rootkits
may evade detection. The kern check tool is used to detect kernel-level root-
kits. The kern check tool compares the addresses of system calls as deﬁned in
the System.map ﬁle, generated at kernel compile time, to the current addresses
of system calls. The CheckIDT tool is a user-level program that can read and
restore the interrupt descriptor table, of which the 0x80th entry points to the
system call handler. Saint Michael is a kernel module that monitors the ktext
(kernel code in memory) for modiﬁcations and attempts to recover from any
modiﬁcation to running kernel code. Saint Michael, however, must be installed
prior to a system compromise and is not always successful.
2.2
Broader Scope
Intrusion prevention and intrusion detection have not slowed the growth of com-
puter compromises to an acceptable rate. Research is drifting towards intrusion
tolerance, and one element of intrusion tolerance is repair and recovery. In this
paper, we begin to explore recovering from system compromises. There may be
certain circumstances where the traditional format and reinstall is undesirable
such as military systems, enterprise servers, or large clusters of machines.
We are also motivated by the need to perform forensics analysis on com-
promised systems. When a system is compromised, it is important to gather
evidence that can be used for legal purposes.1 It is important to understand the
attack in order to prevent future attacks. Much of the evidence in a compromised
system might only be resident in memory, so the evidence must be recovered be-
fore powering oﬀ the machine. In order to retrieve accurate information in the
system, trust must be restored.
Although our work focuses on methods to recover operating system struc-
tures from system compromises, in many cases the most damaging part of a
compromise is the data on the system that was compromised. This data can
include passwords, credit cards numbers, keys, or other sensitive information.
Our work does not solve the problem of data compromise, but we think it is an-
other step in that direction. We envision self-healing systems that automatically
detect system compromises and halt all attacker activity as quickly as possible
in order to minimize the damage done.
3
Analysis of Current Generation Kernel-Level Rootkits
Kernel-level rootkits are rootkits that modify or insert code that runs in kernel
mode. These types of rootkits may include user-level components but must have
some functionality that resides at the kernel level. From our experience of ex-
amining rootkits, we characterize kernel-level rootkits based on two additional
characteristics: Penetration into the kernel and Modiﬁcation of the system call
table.
3.1
Penetration
In terms of Penetration, we classify current generation kernel-level rootkits into
two types based on their technique used for modifying kernel code. The subclas-
siﬁcations of kernel-level rootkits are:
1 From discussions with Oﬃce of Information Technology personnel at Georgia Tech.
– Module — Kernel-level rootkit that enters malicious code into the kernel
by way of a loadable kernel module (LKM). The LKM, once inserted, will
usually hide itself from system reporting facilities (i.e. /sbin/lsmod). We
consider these type of rootkits generation I kernel-level rootkits.
– User — Kernel-level rootkit that patches running kernel code with malicious
code from a user-space process. Usually, this type of rootkit will access ker-
nel memory through the /dev/kmem ﬁle. The Linux kernel provides access
to kernel memory to user-space processes through the /dev/kmem ﬁle. We
consider these type of rootkits generation II kernel-level rootkits.
3.2
Modiﬁcation
In addition, to classifying kernel-level rootkits in terms of penetration, we also
classify rootkits in terms of how they modify the system call table, denoted
Modiﬁcation. Below are the subclassiﬁcations of Modiﬁcation:
– Entry Redirection — Redirects individual system calls within the system call
table. Modiﬁes original system call table.
– Entry Overwrite — Overwrites individual system call code. Does not modify
original system call table.
– Table Redirection — Redirects the entire system call table. Does not modify
original system call table.
Figure 1(a) shows how a kernel-level rootkit can redirect individual system
calls within the system call table (SCT). The picture represents kernel memory
after a kernel-level rootkit with Entry Redirection has been installed on the
system. In Figure 1(a), the sys fork system call is unmodiﬁed. Notice, however,
that system calls number three and number four point to Trojan system calls.
The trusted sys read and sys write are still resident in memory, but there are
no references to them. The system call table now points to trojan read and
trojan write. Any binary executable that relies upon the system calls sys read
and sys write will receive untrusted information from the trojaned system calls.
Figure 1(c) represents kernel memory after a rootkit with Entry Overwrite
has been installed. Again, the sys fork system call is unaltered. Notice, however,
that the two system calls sys read and sys write have been overwritten. The
actual code for the system calls has been overwritten as opposed to the corre-
sponding table entry that references the system calls. The system call table itself
is unaltered with this type of rootkit. We have not seen this type of rootkit but
speculate that one could be constructed. The advantage of this type of rootkit is
that a program such as kern check [9] would not be able to detect the presence
of the rootkit as kern check only checks the system call table, but that is only a
short-lived advantage as new tools are developed.
Figure 1(b) represents kernel memory after a rootkit with Table Redirection
has been installed. The picture depicts kernel memory for the i386 architecture
and the Linux kernel. Within the Linux kernel code exists a table called the In-
terrupt Descriptor Table (IDT) that points to kernel handlers for each interrupt.
Kernel Memory
sys_fork