P（精度） 
4 
U（下溢） 
3 
O（上溢） 
2 
Z（运算结果为零） 
1 
D（操作数规格异常） 
0 
I（无效操作） 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
附录 A  x86 
915 
状态位 SF、P、U、O、Z、D、I 用于异常反馈。 
有关 C3、C2、C1、C0 的更详细介绍，请参见本书的 17.7.1 节。 
在软件使用 st（x）时，FPU 会计算 x 与栈顶指针序号的和，必要的时候还会再计算 8 的模（余数），
以此确定栈指针的物理寄存器地址。 
A.3.3  标记字寄存器（16 位） 
标志字寄存器总共 16 位。每 2 位为一组，表示 FPU 数据寄存器的使用情况。 
位    序 
描    述 
15，14 
Tag（7） 
13，12 
Tag（6） 
11，10 
Tag（5） 
9，8 
Tag（4） 
7，6 
Tag（3） 
5，4 
Tag（2） 
3，2 
Tag（1） 
1，0 
Tag（0） 
Tag（x）存储着FPU物理寄存器R（x）
①
A.4  SIMD 寄存器 
的状态码。 
其各值的代表含义是： 
 00：该寄存器存储着非零的值。 
 01：该寄存器存储的值为零。 
 10：寄存器的值为特殊的值，NAN、∞或者无效操作数。 
 11：寄存器为空。 
A.4.1  MMX 寄存器 
MMX 寄存器由 8 个 64 位寄存器（MM0～MM7）组成。 
A.4.2  SSE 与 AVX 寄存器 
SSE 都有 XMM0～XMM7 这 8 个 128 位寄存器，x86-64 系统还有额外的 8 个寄存器（XMM8～XMM15）。 
而支持 AVX 指令集的 CPU，它们把 XMM＊寄存器扩充为 256 位寄存器。 
A.5  FPU 调试寄存器 
调试寄存器（Debugging registers）用于实现基于硬件的断点控制。 
 DR0 为第 1 个断点的地址（线性地址）。 
 DR1 为第 2 个断点的地址。 
 DR2 为第 3 个断点的地址。 
 DR3 为第 4 个断点的地址。 
① 请注意，Tag（x）描述的不是 FPU 逻辑寄存器 ST（x）的状态。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
916 
逆向工程权威指南（下册） 
 DR6 为调试状态寄存器。在调试过程异常时，它负责报告产生异常的原因。 
 DR7 为用于控制断点调试。 
A.5.1  DR6 规格 
位序（掩码） 
描    述 
0（1） 
B0：触发了断点 DR0 
1（2） 
B1：触发了断点 DR1 
2（4） 
B2：触发了断点 DR2 
3（8） 
B3：触发了断点 DR3 
13（0x2000） 
BD：仅在 DR7 的 GD 为 1 的情况下有效。只有当下一条指令要访问到某一个调试寄存器的时
候，BD 位才被置位（1） 
14（0x4000） 
BS：当进行单步调试的时候，即 EFLAGS 的 TF 标识位被置位的时候，BS 才被置位。单步调
试具有最高的调试优先级，不受其他标识位影响 
15（0x8000） 
BT：任务切换标识位 
单步调试断点是在执行一条指令之后发生的断点。设置 EFLAGS（附录 A.2.19）的 TF 标识，即可实
现单步调试。 
A.5.2  DR7 规格 
DR7 用于控制断点类型。 
位序（掩码） 
描    述 
0（1） 
L0：在当前任务的 DR0 处设置断点 
1（2） 
G0：在所有任务中都设置 DR0 的断点 
2（4） 
L1：在当前任务的 DR1 处设置断点 
3（8） 
G1：在所有任务中都设置 DR1 的断点 
4（0x10） 
L2：在当前任务的 DR2 处设置断点 
5（0x20） 
G2：在所有任务中都设置 DR2 的断点 
6（0x40） 
L3：在当前任务的 DR3 处设置断点 
7（0x80） 
G3：在所有任务中都设置 DR3 的断点 
8（0x100） 
LE：P6 以及 P6 以后的处理器不支持这个标识位。如果被置位，那么 FPU 将会在当前任务中
追踪精确的数据断点 
9（0x200） 
GE：P6 以及 P6 以后的处理器不支持这个标识位。如果被置位，那么 FPU 将会在所有任务中
追踪精确的数据断点 
13（0x2000） 
GD：如果置位，那么当 MOV 指令修改 DRx 寄存器的值时，FPU 将进行进行异常处理 
16，17（0x3000） 
断点 DR0 的触发条件 
18，19（0xC000） 
断点 DR0 的断点长度 
20，21（0x30000） 
断点 DR1 的触发条件 
22，23（0xC0000） 
断点 DR1 的断点长度 
24，25（0x300000） 
断点 DR2 的触发条件 
26，27（0xC00000） 
断点 DR2 的断点长度 
28，29（0x3000000） 
断点 DR3 的触发条件 
30，31（0xC000000） 
断点 DR3 的断点长度 
其中，断点 DRx 的触发条件又分为： 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
附录 A  x86 
917 
 00：执行指令。 
 01：数据的写操作。 
 10：读写 I/O（User mode 下不可用）。 
 11：读写数据。 
可见，FPU 断点的触发条件里没有“读取数据”这一项。 
FPU 断点长度的规格如下： 
 00：1 个字节。 
 01：2 个字节。 
 10：32 位系统中未定义，64 位系统中代表 8 字节。 
 11：4 个字节。 
A.6  指令 
标记为（M）的指令通常都不是编译器生成的指令。这种指令或许属于手写出来的汇编代码，或许属
于编译器的内部指令（参见本书第 90 章）。 
本节仅列举那些常见指令。如果需要查看完整的指令说明，请参见《Intel® 64 and IA-32 Architectures 
Software Developer’s Manual Combined Volumes:1，2A，2B，2C，3A，3B，and 3C》和《AMD64 Architecture 
Programmer’s Manual》。 
我们是不是也要记住指令的 opcode 呢？除非您专门从事给代码打补丁的工作（参见本书第 89 章第 2 节），
否则没那种必要。 
A.6.1  指令前缀 
LOCK：数据总线封锁前缀。在执行 LOCK 作前缀的汇编指令时，它可起到独占数据总线的作用。简
单地说，在执行这种指令时，多处理器的其他 CPU 都将停下来、等该指令执行结束。这种指令常见于各种
关键系统、（硬件）信号量和互斥锁。 
禁止协处理器修改数据总线上的数据，起到独占总线的作用。该指令的执行不影响任何标志位。它常
作为 ADD、AND、BTR、BTS、CMPXCHG、OR、XADD、XOR 指令的前缀。本书的第 68 章第 4 节详细
介绍了这种指令。 
REP：与 MOVSx 和 STOSx 指令结合使用，以循环的方式进行数据复制及数据存储。在执行 REP 指
令时，CX/ECX/RCX 寄存器里存储的值将作为隐含的循环计数器。有关 MOVSx 和 STOSx 指令的详细说
明，请参见附录 A.6.2。 
REP 指令属于 DF 敏感指令。DF 标识位决定了它的操作方向。 
REPE/REPNE：（又称为 REPZ/REPNZ）与 CMPSx 和 SCASx 指令结合使用，以循环的方式进行数值
比较。在执行这种指令时，CX/ECX/RCX 寄存器里存储的值将作为隐含的循环计数器。当 ZF 标识位
为 0（REPE），或 ZF 标识位为 1（REPNE）时，它将终止循环过程。 
有关 CMPSx 和 SCASx 的详细描述，请参见附录 A.6.2 和 A.6.3。 
REPE/REPNE 指令属于 DF 敏感指令。DF 标识位决定了它的操作方向。 
A.6.2  常见指令 
ADC（进位加法运算）：在进行加法运算时，会把 CF 标识位代表的进位加入和中。它常见于较大数值的
加法运算。例如，在 32 位系统进行 64 位数值的加法运算时，会组合使用 ADD 和 ADC 指令，如下所示： 
; 64 位值的运算：val2= val1 + val2. 
; .lo 代表低 32 位，.hi 代表高 32 位。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
918 
逆向工程权威指南（下册） 
ADD val1.lo, val2.lo 
ADC val1.hi,val2.hi；会使用上一条指令设置的 CF 
本书的第 24 章有更为详细的使用案例。 
ADD：加法运算指令。 
AND：逻辑“与”运算指令。 
CALL：调用其他函数。相当于“PUSH（CALL 之后的返回地址）；JMP label”。 
CMP：比较数值、设置标识位。虽然它的运算过程确是减法运算，但是 SUB 指令保存运算结果（差）、
而 CMP 指令不保存运算结果。 
DEC：递减运算。它不影响 CF 标识位。 
IMUL：有符号数的乘法运算指令。 
INC：递增运算。它不影响 CF 标识位。 
JCXZ，JECXZ，JRCXZ（M）：当 CX/ECX/RCX=0 时跳转。 
JMP：跳转到指定地址。相应的 opcode 中含有转移偏移量（jump offset）。 
Jcc：条件转移指令。cc 是 condition code 的缩写。 
JAE 即 JNC：（unsigned）在大于或等于的情况下进行跳转；转移条件是 CF=0。 
JA 即 JNBE：（unsigned）在大于的情况下进行跳转；转移条件是 CF=0 且 ZF=0。 
JBE：（unsigned）在小于或等于的条件下进行跳转；转移条件是 CF=1 或 ZF=1。 
JB 即 JC：（unsigned）在小于的情况下进行跳转；转移条件是 CF=1 
JC 即 JB：在小于的情况下进行跳转；转移条件是 CF=1。 
JE 即 JZ：在相等的情况下进行跳转；转移条件是 ZF=1。 
JGE：（signed）在大于或等于的情况下进行跳转；转移条件是 SF=OF。 
JG：（signed）在大于的情况下进行跳转；转移条件是 ZF=0 且 SF=OF。 
JLE：（signed）在小于或等于的情况下进行跳转；转移条件是 ZF=1 或 SF≠OF。 
JL：（signed）在小于的条件下进行跳转；转移条件是 SF≠OF。 
JNAE 即 JC：（unsigned）在小于（不大于且不相等）的情况下进行跳转；转移条件是 CF=1。 
JNA：（unsigned）在不大于的情况下进行跳转；转移条件是 CF=1 或 ZF=1。 
JNBE：（unsigned）在大于的情况下进行转移；转移条件是 CF=0 且 ZF=0。 
JNB 即 JNC：（unsigned）在不小于的情况下进行跳转；转移条件是 CF=0。 
JNC 即 JAE：等同于 JNB；转移条件是 CF=0。 
JNE 即 JNZ：在不相等的情况下进行跳转；转移条件是 ZF=0。 
JNGE：（signed）在不大于且不等于的情况下进行跳转；转移条件是 SF≠OF。 
JNG：（signed）在不大于的情况下进行跳转；转移条件是 ZF=1 或 SF≠OF。 
JNLE：（signed）在不大于且不相等的情况下进行跳转；转移条件是 ZF=0 且 SF=OF。 
JNL：（signed）在不小于的情况下进行跳转；转移条件是 SF=OF。 
JNO：在不溢出的情况下进行跳转；转移条件是 OF=0。 
JNS：在 SF 标识位为 0 的情况下进行跳转。 
JNZ 即 JNE：在不大于且不等于的情况下进行跳转；转移条件是 ZF=0 
JO：在溢出的情况下进行跳转；转移条件是 OF=1。 
JPO：在 PF 标识位为零的情况下进行跳转。 
JP 即 JPE：在 PF 标识位为 1 的情况下进行跳转。 
JS：在 SF 标识位为 1 的情况下进行跳转。 
JZ 即 JE：在操作数相等的情况下进行跳转；转移条件是 ZF=1。 
LAHF：标识位读取指令。它把标识位复制到 AH 寄存器。数权关系如下表所示。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
附录 A  x86 
919 
7 
6 
5 
4 
3 
2 
1 
0 
SF 
ZF 
AF 
PF 
CF 
LEAVE：等效于“MOV ESP，EBP”“POP EBP”指令的组合。即，这条指令释放当前子程序在堆栈
中的局部变量，恢复栈指针（stack pointer/ESP）和 EBP 寄存器的初始状态。 
LEA：有效（偏移）地址传送指令。 
这个指令并非调用寄存器的值，也不会进行地址以外的求值运算。它可利用数组地址、元素索引号和
元素空间进行混合运算，求得某个元素的有效地址。 
所以，MOV 和 LEA 指令有巨大的差别：MOV 指令会把操作数的值当作地址、而后对这个地址的值
进行读写操作；而 LEA 就对操作数的地址进行直接处理。 
因此，LEA 指令也经常用于各种常规计算。 
LEA 指令有一个重要的特点—它不会影响 CPU 标识位的状态。对于 OOE（乱序方式执行的指令）
处理器来说，这一特性有利于大幅度降低数据依赖性。 
int f(int a, int b) 
{ 
         return a*8+b; 
}; 
使用 MSVC 2010（启用优化功能）编译上述程序，可得到： 
指令清单 A.1  优化 MSVC 2010 
_a$ = 8           
; size = 4 
_b$ = 12          
; size = 4 
_f 
  PROC 
  mov  
eax, DWORD PTR _b$[esp-4] 
  mov  
ecx, DWORD PTR _a$[esp-4] 
  lea  
eax, DWORD PTR [eax+ecx*8] 
  ret  
0 
_f 
  ENDP 
Intel C++编译器生成的汇编代码更为烦琐。例如，在编译下述源代码时： 
int f1(int a) 
{ 
  return a*13; 
}; 
Intel C++生成的汇编代码为： 
指令清单 A.2  Intel C++2011 
_f1 
  PROC NEAR 
  mov  
  ecx, DWORD PTR [4+esp]      
     ; ecx = a 
  lea        edx, DWORD PTR [ecx+ecx*8]   ; edx = a*9 
  lea        eax, DWORD PTR [edx+ecx*4]   ; eax = a*9 + a*4 = a*13 
  ret 
即使如此，两条 LEA 指令的执行效率仍然超过了单条 IMUL 指令。 
MOVSB/MOVSW/MOVSD/MOVSQ：复制 8 位单字节数据（Byte）/16 位 Word 数据（Word）/32 位
双字型数据（Dword）/64 位四字型数据（Qword）的指令。默认情况下，它将把 SI/ESI/RSI 寄存器里的值
当作源操作数的地址，目标操作数的地址将取自 DI/EDI/RDI 寄存器。 
在与 REP 前缀组合使用时，它会把 CX/ECX/RCX 作为循环控制变量进行循环操作。这种情况下，它
就像 C 语言中的 memcpy() 函数那样工作。如果编译器在编译阶段能够确定每个模块的大小，编译器通常
异步社区会员 dearfuture(15918834820) 专享 尊重版权
920 
逆向工程权威指南（下册） 
使用 REP MOVSx 指令以内连函数的形式实现 memcpy()。 
例如，memcpy（EDI，ESI，15）等效于： 
; copy 15 bytes from ESI to EDI 
CLD      
 ; set direction to "forward" 
MOV ECX, 3 
REP MOVSD    ; copy 12 bytes 
MOVSW    
 ; copy 2 more bytes 
MOVSB    
 ; copy remaining byte 
在复制 15 字节的内容时，从寄存器读取的操作效率来看，上述代码的效率要高于 15 次数据读写（MOVSB）
的操作效率。 
MOVSX：以符号扩展的方法实现 signed 型数据的类型转换（参见本书 15.1.1 节）。 
MOVZX：以用零扩展的方法实现 unsigned 型数据的类型转换（参见本书 15.1.1 节）。 
MOV：数据传送指令。“MOV”这个名字与“MOVE”（移动）拼写相似，不过它的功能是复制数据
而非移动数据。在某些平台上，这条指令的名字是“LOAD”或者某个类似的名字。 
值得一提的是，当使用 MOV 指令给 32 位寄存器的低 16 位赋值时，寄存器的高 16 位不会发生变化。
而使用 MOV 指令给 64 位寄存器的低 32 位赋值时，寄存器的高 32 位会被清零。 
64 位寄存器的高 32 位被自动清零的特性，可能是为了在 x86-64 系统上兼容 32 位程序而有意这样设计的。 
MUL：unsigned 型数据的乘法运算指令。 
NEG：求补指令（并非补码计算指令）。NEG op 可得到–op。 
NOP：NOP 指令。在 x86 平台上的 opcode 是 0x90。这个 opcode 和 XCHG EAX，EAX 的空操作指令
相同。这即是说，x86 平台没有 NOP 专用的汇编指令，而 RISC 平台上 NOP 有专用的汇编指令。有关这个
指令的详细介绍，请参见本书的第 88 章。 
编译器可能会使用 NOP 指令进行 16 字节边界对齐。此外，在手工修改程序时，人们也会使用 NOP
指令进行指令替换，用于屏蔽条件转移之类的汇编指令。 
NOT：求反指令/逻辑“非”运算指令。 
OR：逻辑“或”运算指令。 