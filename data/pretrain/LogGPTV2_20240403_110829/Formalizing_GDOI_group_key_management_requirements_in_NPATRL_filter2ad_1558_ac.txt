as a result of receiving the ﬁnal message of a group-key pull
exchange or as a result of receiving a group-key push mes-
sage.
The events are speciﬁed as follows.
Requesting a Key:
member requestkey(M, GCKS , (G, NM , KGM ), N )
where GCKS is the GCKS, G is the group, NM is the nonce
M uses in initiating the request (to distinguish it from other
requests), and KGM is the pairwise key shared between
GCKS and M . This corresponds to M sending the ﬁrst
message in a group-key pull exchange.
Accepting a Key From a Group-key Pull Exchange:
member acceptpullkey(M, GCKS , (G, KG, NGM , NM , KGM ), N )
where GCKS is the GCKS, G is the group, KG is the key,
and KGM is the pairwise key shared between M and the
GCKS. Again, this does not give the whole picture, as it
leaves out the portion of the key hierarchy that the GCKS
sends to M .
Accepting a Key From a Group-key Push Message:
member acceptpushkey(M, GCKS , (G, KG, K(cid:2)
G), N )
where GCKS is the GCKS, G is the group, KG is the new
key, and K(cid:2)
G is the current key encryption key. Again, we
leave out the portion of the key hierarchy that M uses to
authenticate the message and decrypt KG.
For conciseness, we set
member acceptkey(M, GCKS , (G, KG), N )
↔ member acceptpullkey(M, GCKS , (G, KG,
∨ member acceptpushkey(M, GCKS , (G, KG, ), N )
,
, ), N )
4.3 Authentication Requirements
Since GDOI is only intended to address the problem of
secure distribution of group keys, not the authentication of
group members to each other, its authentication require-
ments are simple and rather similar to those for two-party
protocols. Thus we give them ﬁrst. There are authentication
requirements for both the group member and the GCKS.
The group member will want to know, if it accepts a key,
that that key was generated by the GCKS for that group.
The GCKS will want to know that, if it sends a key to a
group member, then that group member requested a key.
Finally, there are authentication requirements on the proof
of possession (POP) algorithm. If the GCKS accepts a proof
of possession from a group member, then the group mem-
ber should have obtained the appropriate authorizations and
the group member should have responded to the GCKS’s re-
quest for a POP. A similar requirement holds for the group
member’s accepting a POP from the GCKS. We consider
the three types of authentication below.
4.3.1 Authentication of a Key to a Group Member
Since there are two diﬀerent ways a group member can
receive a key, we have two diﬀerent sets of requirement. In
the case of the group member M accepting a key KG for
group G as a result of the pull protocol, we require that one
of two things must have happened; either the pairwise key
shared between the member and the GCKS was lost, or the
GCKS did send KG to M for use in G:
member acceptpullkey(M, GCKS , (G, KG, NM , NGM , KGM ), )
→ ✸gcks losepairwisekey(GCKS , (), (M, KGM ), )
∨ ✸gcks sendpullkey(GCKS , M, (KG,
, G, KGM ), )
,
In the case of the member M accepting the key KG for
group G as the result of receiving a push datagram, we again
require that the GCKS has sent KG for use in G in a push
datagram protected by key K(cid:2)
G:
member acceptpushkey(M, GCKS , (G, KG, K(cid:2)
→ ✸gcks sendpushkey(GCKS , (), (G, KG, K(cid:2)
G), )
G), )
Observe that this requirement does not make any provision
for losing an old group key K(cid:2)
G since gcks sendpushkey mes-
sages are authenticated with the signature of the GCKS.
4.3.2 Authentication of a Group Member’s Request
Although the GCKS has two ways of sending keys, it has
only one way of sending a key to a speciﬁc group member:
via a pull protocol. Thus we need only one requirement here,
saying that if the GCKS sent a key to a group member in
response to a pull protocol request, then either the pair-
wise key between the GCKS and group member was lost,
or the group member actually sent that request. We need a
unique way of identifying the group member’s request, and
so we will use the nonce the group member sends in the ﬁrst
message of the pull protocol:
Here and in the rest of this paper, we write “ ” for an argu-
ment whose actual value is irrelevant. Each occurrence can
be thought of as a distinct variable.
gcks sendpullkey(GCKS , M, (KG, NM , NGM , G, KGM ), )
→ ✸gcks losepairwisekey(GCKS , (), (M, KGM ), )
∨ ✸member requestkey(M, GCKS , (G, NM , KGM ), )
Sending a POP:
member sendpop(M, GCKS , (G, NM , NGM , CM ), N )
This event describes a member M sending a POP in re-
sponse to a GCKS’s request. CM stands for M ’s credentials.
4.3.3 Authentication of a Proof of Possession
For proofs of possession, we want to show that, for either
the GCKS or a member, if A accepts a key requiring a proof
of possession from B, then B sent the POP in response to
240A’s request, and B obtained the credentials from the appro-
priate authority. The act of obtaining credentials is outside
the scope of GDOI; however, we leave it in the requirement
speciﬁcation because it is clearly the intent of the POP.
gcks sendpullkey(GCKS , M, (KG, NM , NGM , G, KGM ), )
→✸ ( member sendpop(M, GCKS , (G, NM , NGM , M, CM ), )
∧ ✸auth issuecreds(AU T H, M, (CM , G), ))
member acceptpullkey(M, GCKS , (KG, NM , NGM , G, KGM ), )
→✸ (
gcks sendpop(GCKS , M (G, NM , NGM , CM ), )
∧ ✸auth issuecreds(AU T H, M, (CM , G), ))
4.4 Freshness Requirements
For GDOI, we can identify two types of freshness. One,
we call recency freshness. This is the requirement that, if a
principal receives a piece of information, such as a key, then
it must have been current at some speciﬁed point in time
according to the principal’s local clock, for example when
the principal requested it. The other, we call sequential
freshness. This is the requirement that, if a principal accepts
a key KG, then it could not have previously accepted a key
that became current after KG.
4.4.1 Recency Freshness for Pull Protocol
member acceptpullkey(M, GCKS , (G, NM , NGM , K(cid:2)
→ ✸gcks losepairwisekey(GCKS , (), (M, KGM ), )
G, KGM ), N )
∨ ¬(✸ ( member requestkey(M, GCKS , (G, NM , KGM ), N )
∧ ✸gcks sendpushkey(GCKS , (), (G, KG, K(cid:2)
G), )))
Note that the deﬁnition of recency freshness is one of the
few places we make use of round numbers, since the member
requests and accepts the key in the same round. Note also
that the GCKS’s act of sending a key KG protected by K(cid:2)
G
using the push protocol results in the expiration of K(cid:2)
G.
4.4.2
member acceptpullkey(M, GCKS , (G, NM , NGM , KG, KGM ), )
→ ✸gcks losepairwisekey(GCKS , (), (M, KGM ), )
∨ ¬(✸ ( member acceptkey(M, GCKS , (G, K(cid:2)
gcks createkey(GCKS , (), (G, K(cid:2)
Sequential Freshness for Pull Protocol
∧ ✸ (
∧ ✸gcks createkey(GCKS , (), (G, KG), )))
G), )
G), )
Recall from Section 4.2.3 that a group key is sent (and
therefore made current) immediately after it is created by
the GCKS.
4.4.3
Sequential Freshness for Push Protocol
member acceptpushkey(M, GCKS , (G, KG, K(cid:2)
G), )
→ ¬(✸ ( member acceptkey(M, GCKS , (G, K(cid:2)(cid:2)
gcks createkey(GCKS , (), (G, K(cid:2)(cid:2)
∧ ✸ (
G), )
G), )
∧ ✸gcks createkey(GCKS , (), (G, KG), )))
Note that we do not specify recency freshness as a re-
quirement for the push protocol. This can be achieved, if
desired, by including timestamps in the Security Associa-
tion, but this is not a requirement of GDOI.
4.4.4 Freshness of a Member’s Key Request
We now consider a freshness requirement from the GCKS’s
point of view. When the GCKS responds to a member’s re-
quest with a key, it must be sure that this is a new request,
not a replay of some old request. Since a member’s request
contains a nonce which is intended to be unique, we make
this into a requirement that a GCKS should not have pre-
viously distributed a key to that member using that nonce.
Note that this freshness requirement can only be guaran-
teed for an honest member, since there is nothing prevent-
ing a dishonest member from replaying an old request and
then participating in the protocol to obtain a key. Since
honest members are the only ones we are interested in pro-
tecting anyway, this is not a problem for us. However, we
need a way of distinguishing between honest and dishonest
members. We do this by borrowing a trick from the NRL
Protocol Analyzer speciﬁcation language, and referring to
principals as member(M, H) where H is a variable that can
be instantiated to honest or dishonest. At this point we are
only interest in member(M, honest):
gcks sendpullkey(GCKS , Mh, (KG, NM , NGM , G, KGM ), )
→ ✸gcks losepairwisekey(GCKS , (), (Mh, KGM ), )
∨¬✸gcks sendpullkey(GCKS , Mh, (K(cid:2)
G, NM , N(cid:2)
where Mh = member(M, honest).
GM , G, KGM ), )
4.4.5 Freshness of Proof of Possession
Freshness requirements for Proof of Possession are more
similar to two-party freshness requirements than some of
the others we have visited. Since POPs are computed on
nonces supplied by sender and receiver we require that, if a
principal accepts a POP for two nonces, then it should not
have accepted it previously. Since the POP is computed on
the sender’s and receiver’s nonces, this can be enforced by
requiring that the GCKS does not engage in a sendpullkey
event based on the same nonces twice, and that a member
does not engage in an member acceptpullkey event based on
the same nonces twice. Note that the GCKS’s freshness
requirement is similar, but somewhat stronger than, the re-
quirement for freshness of a member’s key request; it is not
dependent on the pairwise key being uncompromised.
gcks sendpullkey(GCKS , Mh, (KG, NM , NGM , G, KGM ), )
→¬✸gcks sendpullkey(GCKS , Mh, (K(cid:2)
G, NM , NGM , G, K(cid:2)
member acceptpullkey(M, GCKS , (KG, NM , NGM , G, KGM ), )
→¬✸member acceptpullkey(M, GCKS , (K(cid:2)
G, NM, NGM, G(cid:2), K(cid:2)
where again Mh = member(M, honest).
4.5 Secrecy Requirements
GM ), )
GM ), )
GDOI has one basic secrecy requirement, that keys should
only be learned by members of the group. However, we may
want to put other conditions on this requirement. For ex-
ample, we may require that new members should not have
access to old keys (backward access control ), and that ex-
pelled members will not have access to any keys generated
after they were expelled (forward access control ). GDOI
also allows for an option that provides a degree of protec-
tion against compromise of pairwise keys; it allows for the
optional use of Diﬃe-Hellman to assure perfect forward se-
crecy:
if a pairwise key is stolen, then the intruder should
only be able to learn key encryption keys distributed after
the event.
As we can see, the diﬀerent secrecy requirements are not
quite orthogonal, and they can interact with each other in
diﬀerent ways. For example, one would not want to waste
time with perfect forward secrecy if one did not also have
backwards access control. In general, it is assumed that it
is more likely that a dishonest member will join the group
than that a pairwise key shared between only two principals
will be stolen. So it makes little sense to use perfect forward
secrecy to protect old keys, if they could be compromised
241by having a group key distributed to a dishonest principal.
Likewise, requirements such as forward and backward access
control should not only govern the eﬀects of the distribution
of keys, but other events such as the stealing of keys. For
example, if members should no longer have access to new
keys after leaving the group, then an intruder’s stealing a
key should not give it access to subsequent keys either.
Our solution to this problem is to deﬁne a number of con-
ditions describing sequences of events that deﬁne the sit-
uation under which an intruder might learn a key. These
conditions can then be mixed and matched to put together
the appropriate requirement. We can then use the NPA-
TRL logic to reduce the requirements to normal form, when
necessary.
In the remainder of this section, we describe the various
sequences. These include ﬁve “base cases” that describe
some simple sequences of events that could lead to key com-
promise, as well as two recursively deﬁned cases that de-
scribe forward access control without backward access con-
trol, and vice versa. We also give several examples showing
how the various cases can be combined to produce diﬀerent
types of requirements.
4.5.1 The Base Cases
The ﬁve base cases are as follows:
BC1(KG, G):
gcks losegroupkey(GCKS , (), (G, KG), )
This describes the a group key-encryption key being
stolen.
BC2a(KG, G):
G, KGM ), ))
G), N )
, NGM , K(cid:2)(cid:2)
G), N )
✸( gcks sendpushkey(GCKS , (), (G, KG, K(cid:2)
∧ ✸gcks sendpullkey(GCKS , Md, (G,
∧ ¬✸( gcks sendpushkey(GCKS , (), (G, KG, K(cid:2)
∧ ✸gcks cancel(GCKS , Md, (G, NGM ), ))
where Md = member(M, dishonest). This describes a
group key being distributed while a dishonest member
is in the group. Note that it is in two parts. The ﬁrst
says that the dishonest member has joined the group;
the second says that the member has not left it yet. In
order to take care of the possibility of multiple joinings
and leavings, we give both join and leave the same
index NGM , which uniquely identiﬁes M ’s joining the
group.
BC2b(KG, G):
✸gcks sendpullkey(GCKS , Md, (G,
, NGM , KG, KGM ), )
for Md = member(M, dishonest). This describes a group
key KG being distributed to a dishonest member via
a pull protocol, that is, the dishonest member is being
admitted to the group.
BC3a(KG, G):
✸gcks losepairwisekey(GCKS , (), (M, KGM ), )
∧ ✸gcks sendpullkey(GCKS , M, (G,
, KG, KGM ), )
,
This describes the result of a pairwise key being lost
and a key being sent using that pairwise key.
BC3b(KG, G):
✸ (
gcks sendpullkey(GCKS , M, (G,
∧ ✸gcks losepairwisekey(GCKS , (), (M, KGM ), ))
, KG, KGM ), )
,
This describes a pairwise key being lost and a key being
sent using that pairwise key after the pairwise key is
lost.
4.5.2 The Recursive Cases
There are two recursive cases. The ﬁrst describes an in-
truder learning an old key after a later key has become cur-