shows for comparison the overheads resulting from using only
the underlying Boehm-Demers-Weiser pool allocator, without
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:38:23 UTC from IEEE Xplore.  Restrictions apply. 
587
d
a
e
h
r
e
v
O
d
a
e
h
r
e
v
O
 4
 3.5
 3
 2.5
 2
 1.5
 1
1/32
 4.5
 4
 3.5
 3
 2.5
 2
 1.5
 1
1/32
CPU
Memory
Performance
1/16
1/8
1/4
1/2
1
2
4
8
Quarantine List to Heap Ratio
(a) Perlbench
1/16
1/8
1/4
1/2
1
2
4
8
Quarantine List to Heap Ratio
(c) Omnetpp
d
a
e
h
r
e
v
O
d
a
e
h
r
e
v
O
 5
 4.5
 4
 3.5
 3
 2.5
 2
 1.5
 1
1/32
 1.3
 1.2
 1.1
 1
 0.9
 0.8
 0.7
1/32
1/16
1/8
1/4
1/2
1
2
4
8
Quarantine List to Heap Ratio
(b) Xalancbmk
1/16
1/8
1/4
1/2
1
2
4
8
Quarantine List to Heap Ratio
(d) DealII
Fig. 12: Tradeoffs in memory-usage, performance and CPU utilisation for the four allocation-intensive benchmarks [7] from
SPEC CPU2006 [24], based on the maximum permitted quarantine list size relative to the rest of the heap.
d
a
e
h
r
e
v
O
d
a
e
h
r
e
v
O
 20
 18
 16
 14
 12
 10
 8
 6
 4
 2
 0
 4
 3.5
 3
 2.5
 2
 1.5
 1
 0.5
 0
f o r m a n c e
p e r
m e m o r y
(a) Perlbench
f o r m a n c e
p e r
m e m o r y
(c) Omnetpp
c p u
c p u
d
a
e
h
r
e
v
O
d
a
e
h
r
e
v
O
 35
 30
 25
 20
 15
 10
 5
 0
 10
 9
 8
 7
 6
 5
 4
 3
 2
 1
 0
Optimisations
None
Page unmapping
Mark frequency optimisation
Small-object block sweeping
f o r m a n c e
p e r
m e m o r y
(b) Xalancbmk
f o r m a n c e
p e r
m e m o r y
(d) DealII
c p u
c p u
Fig. 13: Overhead observed by cumulatively adding optimisations to the basic quarantine-list and mark technique, compared
with no protection, for the four allocation-intensive benchmarks [7] from SPEC CPU2006 [24].
MarkUs’s protection or any garbage collection: manual frees
are freed immediately in this case.
We see that this allocator itself can be a poor choice in
certain circumstances: it is 5% slower than the default Linux
allocator, accounting for almost half of MarkUs’s overhead.
In particular GCC shows one of the highest overheads for our
technique, but is unaffected in performance by the MarkUs
security mechanisms themselves. Indeed, many of the choices
in this sample allocator are not fundamental to the function-
ing of MarkUs, and we should expect a dedicated allocator
designed to optimise these cases may perform signiﬁcantly
better depending on the circumstance. On the ﬂip side, the
Boehm-Demers-Weiser allocator can perform better than the
stock glibc allocator baseline. For example, with xalancbmk
MarkUs does introduce true overhead, because frequent mark-
ing procedures are necessary. Still, the only SPEC CPU2006
workloads we see signiﬁcant overhead on for MarkUs itself
are omnetpp, perlbench, milc and xalancbmk; most others
are relatively unaffected despite the security provided. By
comparison, providing the same security guarantees using
the full garbage collector adds very large overheads even
on workloads such as astar, milc, sphinx and soplex, where
MarkUs has no observable overhead.
H. Deallocation Efﬁciency
While one concern with MarkUs’s approach is that dangling
pointers could prevent it from freeing quarantined data, ﬁg-
ure 15 shows that this is unwarranted. This ﬁgure shows the
proportion of quarantined space that can be cleared across
all marking procedures (i.e., memory freed not allocations
freed). We see that for most workloads, with the full MarkUs
technique, almost all data is freed, meaning dangling pointers
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:38:23 UTC from IEEE Xplore.  Restrictions apply. 
588
Allocator Only (No Safety)
9.4
82
n
w
o
d
w
o
S
l
4
3.5
3
2.5
2
1.5
1.25
1
r
s t a
a
2
z i p
b
a lI I
e
d
c
c
g
b m k
2
h
r
4
6
e f
r
h m m e
o
g
MarkUs
9.7
14.1
14.4
Full GC
31.6
n t u m
a
u
m c f
m il c
a m d
o m n
n
e t p
p
p
e
r l b
h
c
n
e
y
a
r
v
o
p
n
s j e
g
s
h i n
p
3
x
o
s
x
p l e
a l a
x
c
n
b m k
e
g
n
a
o m e
l b m
q
li b
Fig. 14: Slowdown resulting from the use of the Boehm-Demers-Weiser [16] pool allocator alone without garbage collection
or temporal safety, as opposed to the standard GNU allocator, compared with the full MarkUs technique which makes use
of the allocator, and compared with the allocator’s default full garbage collector (augmented with a quarantine list to prevent
false deletion of objects and thus allow correct execution).
Full MarkUs
No Page Unmapping
Kibibytes
Percent
 100000
 10000
s
e
t
y
b
b
K
i
i
 1000
 100
 10
1
 0.1
a star
b zip 2
d e alII
g c c
g o b
h 2 6 4ref
m k
h
m
m k
10-3