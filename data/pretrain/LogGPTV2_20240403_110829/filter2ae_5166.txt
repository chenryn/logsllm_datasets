# 【WriteUp】labyrenth CTF windows track挑战（上）
|
##### 译文声明
本文是翻译文章，文章来源：jmprsp
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
**前言**
**我花了一周时间完成了Palo Alto CTF、Windows
和Docs两条轨道的测试，现在我将在文章中分享我的解决方案，希望读者朋友可以从中学到一些解决恶意软件技术的有用技巧。**
**  
**
**文件: AntiD.exe**
**SHA256:** 49f3638065722b96809cb72c226d86566783d510c968d516436aa7c248d608ee
**加壳** ︰自定义 UPX
**使用工具** : ExeInfo, IDA Pro, Ollydbg, Scylla & CFF Explorer
**代码与二进制文件：**
[https://github.com/jmprsp/labyrenth/tree/master/Window-Challenge-1](https://github.com/jmprsp/labyrenth/tree/master/Window-Challenge-1)
**说明：**
这一挑战使用了UPX用来加壳，但是加成了阻止upx-d运行的模式。它还使用了一些反调试技术来遏制调试工具的使用。具体的标记还不是很清楚，所以需要分析背后的数学函数并解码标记。
看起来该二进制文件使用的加壳工具是UPX。让我们试着用官方工具进行解码，虽然看起来并不能解码成功。
在IDA
Pro中加载该二进制文件，我们可以观察该二进制文件确实经过加壳。从下面的截图中我们只能看到一个函数和一个已加壳二进制文件的指令。接下来，我们可以清楚地看到有一个尾部跳转。要手动解压缩此二进制文件，我们只需要打破尾部跳转和转储进程。
但在那之前，我想要禁用 ASLR 来简化过程，并且同时进行调试。使用补偿资源管理器工具，只需取消选中"可以移动DLL "复选框并应用更改。
在 ollydbg 中运行AntiD.exe补丁；设置一个断点 @ 0x4091AC。运行程序直到中断并进入下一条指令。
下面是转储进程的示例，但是运行释放的过程中会弹出一个错误提示。
释放过程的 IAT 需要加以修正。为此，我使用了Scylla 工具来删除无效的导入和点击修复转储按钮。现在我们已经有了二进制文件的工作副本。
将解压缩的二进制文件加载到 IDA Pro，我们可以看到现在似乎已经解码成功。我们可以看到更多的函数、 进口和普通字符串。
使用X-字符串引用，我们将得到下面的函数。看起来0x004011B0 函数是解决这个难题的关键。
在 0x004011B0 函数中，我们可以看到一些编码变量以及其中40个变量和由XOR 、加法和减法组成的数学变换。
我简单地将这些代码转换成 PHP，然后尝试强制性标记。
标记: PAN{C0nf1agul4ti0ns_0n_4_J08_W3LL_D0N3!}
**文件: BabbySay.exe**
**SHA256:** 7CA8D9F1BE070DEB6535326AB4DFAE4824055F777DD929D2DEE9D0ADBEBDE785
**加壳：** 无
**使用工具:** exeinfo, Reflector
**代码与二进制文件：**
**说明：** 这次的挑战是以 C#语言编写的。使用反射器之类的工具进行反编译将会非常繁琐。你可能会在 github中发现反编译源代码的副本。
在执行这个挑战的时候，你将会看到下面这种画面，或许我们需要知道一定顺序的密钥才能得到标记。
使用反射器进行反编译很容易。Key_click 函数和所有有趣字符看起来都是可疑的。
我只是单纯地将另一个 c# 项目的大部分代码副本粘贴在这里 (做适当删除)并且将变量写入文件。编译并运行 XDDDD。
这样我们就得到了这样的标记。
标记: PAN{B4BBY_Y3LL5_50_L0UD!}