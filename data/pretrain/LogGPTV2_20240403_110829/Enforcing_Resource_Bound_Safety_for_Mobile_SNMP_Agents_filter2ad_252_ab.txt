variable “example1” that have been sent to the node (the
master agent) from the outside.
In the following subsections, we use the scalar agent to
illustrate the design of the off-line checker and its usage
by programmers of mobile agents, and the use of the on-
line checker invoked at the hosting system. We show that
TINMAN provides full coverage and guarantees resource
safety of mobile SNMP agents.
3.1 Resource Bound Prediction for SNMP Agents
The off-line checker provides tools for the programmer
of a mobile SNMP agent to perform resource bound predic-
tion and to provide resource usage certiﬁcation for the agent
code. The output of the resource analysis as well as a usage
certiﬁcate as the evidence for the code’s safety with regard
to resource consumption, are transferred together with the
mobile agent code.
In our current implementation, only timing analysis and
live memory-demand analysis are performed. We are in-
vestigating the extension of usage bound prediction to other
system resources such as disk I/O and static network band-
width consumption. In general, the approach we present in
this paper may be applied in the same way to safeguard the
usage of the variety of system resources, with more efforts
on analysis of the relevant system calls and their parame-
ters (e.g. fork() and system() calls for thread and process
analysis), and relevant safety policies deﬁnitions.
Resource usage prediction is done at the source code
level. First, we modiﬁed the Broadway Compiler [4], a
source-to-source translator for ANSI C to parse the source
code and output a ﬂow graph with data and control informa-
tion for the resource analysis modules. The resource usage
of a mobile agent is mainly decided by its program structure
(statements, branches, loops etc.) and the resource usage of
the library services calls (e.g. SNMP APIs) invoked.
For the part of program structure analysis, a resource
schema approach is used to perform timing analysis on a
variety of programming constructs, henceforth referred as
to tasks. Timing analysis tasks are deﬁned at different gran-
ularities such as basic blocks, loops and service routines.
The task information of the scalar agent, as shown in Fig-
ure 2, was generated by the program ﬂow analysis. Each
task in the ﬂow graph is labeled with its type (e.g. L = Loop
task) followed by a global counter value.
The basic idea of the timing schema approach [13] is
that the program execution time is determined by basic tasks
and the control structures of a program. Loops are treated
specially to obtain their resource bounds. For loops whose
loop bounds are difﬁcult to deduce automatically (or may
not even exist as is in the case of an inﬁnite loop) by static
analysis but nevertheless are known to the programmer, the
programmer is asked to assert a loop bound which will be
automatically monitored on-line.
Considering the possible actions of malicious codes on
memory, our efforts in memory usage analysis are focused
on memory allocation requests in a program. We com-
bine analysis of memory allocation statements (malloc()
and memdup() as commonly used by SNMP agents), path
analysis of memory freed, and call chain analysis to achieve
this goal.
The resource usage of library services are treated as well.
Resource usage of a service is speciﬁed in a policy rule
which is a pair of pre- and post- condition speciﬁcations
deﬁned in a formal logic (to be described in the next sub-
section). The resource consumed by a service is param-
eterized given the ranges of its arguments. Exact values
are determined at the remote host site at run-time. This ap-
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:29:18 UTC from IEEE Xplore.  Restrictions apply. 
proach is more ﬂexible since the policy is conﬁgurable for a
speciﬁc platform and run-time environment. For example,
snmp enable stderrlog() which is called in main() in Fig-
ure 2 is an SNMP agent library service. Its exact execution
time and memory allocation is determined at the hosting
system site, and deﬁned as an axiom in the TINMAN proof
system.
For a user-deﬁned function, its resource usage is ob-
tained by summing all its basic blocks, loops, library ser-
vices calls and user-deﬁned functions.
The timing and memory bound information obtained by
either automatic analysis or from programmer input are
maintained by using a resource skeleton. Basically, a re-
source skeleton can be viewed as an abstraction of a pro-
gram with regard to its resource consumption, and will
be used by the usage certiﬁcate generator and the on-line
checker. It contains the execution time and memory allo-
cation for each task, path information of the program, loop
bounds, and parameterized resource usage for services.
int   main (int argc, char **argv) {
/*@ Entry T[t0] M[m0]*/
B1: {...}
/*@B1: T[Entry + tsnmp_enable_stderrlog + tds_set_boolean + tinit_agent+3]
             M[Entry + msnmp_enable_stderrlog + mds_set_boolean + minit_agent]*/
U2: {...}
/*@U2: T[B7]  M[B7]*/
B3: {...}
/*@B3: T[U2 + tinit_snmp + 2*tsignal + 7]
              M[U2 + minit_snmp + 2*signal] */
/*@L4lb = 1000 */
L4: {...}
/*@L4: T[B3 + L4lb*(tagent_check_and_process+1) + 1]
             M[B3 + L4lb*magent_check_and_process]*/
B6: {...}
/*@B6: T[L4 + tsnmp_shutdown + texit + 1]
             M[L4 + msnmp_shutdown]*/
}
void init_scalar_int(void) {
/*@Entry */
B7: {...}
/*@B7: T[Entry + 13 + 2*tDEBUGMSGTL + tnetsnmp_register_int_instance]
             M[Entry + 2*mDEBUGMSGTL + mnetsnmp_register_int_instance]*/
}
Figure 3. Resource Skeleton for code in Figure 2
Results of resource usage analysis on the scalar agent
are shown in Figure 3. Resource annotations for each task
are enclosed in “=@ . . . =”, which can be identiﬁed by the
on-line validator and be ignored by a standard compiler.
T[ex] and M[ex] represent the time and memory-demand
bounds of the corresponding task. For example, the annota-
tion for task B3: T[U2 + tinit snmp + 2*tsignal + 7] means
the execution time to the point after B3 is the sum of T[U2],
T[init snmp], 2*T[signal] and 7, where T[U2] is obtained
recursively from the corresponding annotation for U2, and
the constant 7 is the total number of atomic blocks involved
in B3. We observe from the above that a task is enclosed
by a pair of predicates on the resource usage, and this ar-
rangement can be treated like a Hoare triple. In the next
subsection, we shall expand on this idea into a process of
formal certiﬁcate generation.
3.2 Usage Certiﬁcate Generation
The resource skeleton contains information about the re-
source usage bound of a mobile agent. At the stage of usage
certiﬁcate generation, the off-line checker produces a cer-
tiﬁcate for the resource skeleton as a proof for its validity.
Speciﬁcally, it translates the annotations into a set of pred-
icates coded in a formal logic of a proof system, and then
proves them within the proof system.
Our basic strategy for establishing the correctness of cer-
tiﬁcates is to use an extended Hoare Logic. For a task T, an
extended Hoare triple for T is in the form fPg T fQg, where
assertion P is the pre-condition, and assertion Q is the post-
condition that holds if P is true and T terminates.
For example, the extended Hoare triple for task B1 in
Figure 2 and Figure 3 is
PRE1: f w= 0 ^ e = 0 ^ eiaeg
B1
POS1:f w bool]) : [State−>bool] =
        (LAMBDA s : P1(s) IMPLIES P2 (s));
spec (P, Q) : program = (LAMBDA s0, s1: P(s0) IMPLIES Q(s1))
%task B1: basic block bb1  
ASRT1: pred[State] = (LAMBDA s :
      now(s) = t0 AND
      mem(s) = m0 AND term(s))
ASRT2: pred[State] = (LAMBDA s :
      now(s) spec ( ASRT1, ASRT2)
%task L4: loop task loop1
ASRT4: pred[State] = (LAMBDA s :
      val(s)(inter_lb1) = 0 AND L4lb = 1000 AND
      now(s) = 0
loop1init  : program = lbop(inter_lb1, (LAMBDA s: 0))
loop1cond  : pred[State] = (LAMBDA s: val(s)(inter_lb1) spec(ASRT4, ASRT5)
Figure 4. A Fragment of PVS Speciﬁcation for Figure 3
gram is proved automatically. PVS outputs the proof into a
text ﬁle which constitutes the usage certiﬁcate for the pro-
gram.
The corresponding proofs to Figure 4 are given in Fig-
ure 5. Program constructs such as bb (basic blocks), seq (se-
quence of tasks) and srvc (services calls) are expanded, and
basic PVS proof rules such as ASSERT and SKOSIMP*
are applied to complete the proofs. The proof strategy for
loop task L4 is more complicated than that of basic block
task B1 in that an inference rule (LEMMA “rulewhile”) for
loops and a loop invariant (loop1inv) are involved in the
proof generation.
The size of the proof, however, may be as large as, for
this example, three times the source code. In order to re-
duce its size, we further simplify the usage certiﬁcate by
only keeping the strategies and related parameters for re-
constructing the proof. As a result, the above proof frag-
ment is reduced to the form of
cor1: SB bb1 ASRT1 ASRT2
cor4: SL loop1 loop1inv loop1ceterm
where SB and SL stand for the strategies for basic tasks and
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:29:18 UTC from IEEE Xplore.  Restrictions apply. 
loop tasks, respectively.
(|cor1| "" (EXPAND "bb1")
  (("" (EXPAND "ASRT1") (("" (EXPAND "ASRT2")
    (("" (EXPAND "seq") (("" (EXPAND "spec")
      (("" (EXPAND "bb") (("" (EXPAND "srvc")
      (("" (EXPAND "=>") (("" (ASSERT)
          (("" (SKOSIMP*) (("" (ASSERT)
          (("" (SKOSIMP*) (("" (ASSERT)
          (("" (SKOSIMP*) (("" (ASSERT) NIL NIL)) .... NIL))
(|cor4| "" (LEMMA "rulewhile")
 (("" (EXPAND "loop1") (("" (INST?)
   (("" (GROUND) (("" (INST + "loop1inv" "loop1cterm")
   (("" (HIDE 2) (("" (LEMMA "lb1axiom")
   (("" (SPLIT)
    (("1" (GRIND) NIL NIL)
     ("2" (EXPAND "=>") (("2" (SKOSIMP) (("2" (GRIND) NIL... NIL)
     ("3" (EXPAND "=>") (("3" (SKOSIMP) (("3" (GRIND) NIL... NIL)
     ("4" (GRIND) NIL NIL)) ... NIL))
Figure 5. The Proof Fragment for Figure 4
appropriate assertions for checking the value range of un-
trusted data and communication primitives: UNIX signals
and FIFO queues in our current implementation. The while
loop in the scalar agent is changed to the following code.
...
TINMAN scope(SCOPE LOOP IN);
int internal lb = 0;
while(keep running) f
TINMAN assert(internal lb<1000);
agent check and process(1);
g
TINMAN scope(SCOPE LOOP OUT);
...
A run-time exception will be raised if any assertion is
violated. Whereas dynamic resource utilization monitoring
has been used by previous work, our approach avoids much
of the work since the resource bound safety is guaranteed
by static veriﬁcation and run-time checking is required only
on programmer-provided annotations.
3.3 On-line Validation and Run-time Check for
SNMP Agents
4 Experimental Results