 1:   int sum;
 2:
 3:   p = str;
 4:   sum = 0;
 5:   while (*p >= '0' && *p  l0
str[1]  l1
Initial state
Mapping:
Constraints:
str[0]  l0
str[1]  l1
c       l5
sum     l6
l2 = l0 - 30
l3 = l2
l4 = 10 * l3
l5 = l1 - 30
l6 = l4 + l5 
State after second loop iteration
Figure 3. Constraints generated during program execution.
ten to be characters that do not represent numbers. In these
cases, the while-loop would terminate immediately.
In the example,
the program reaches the check on
Line 11 after the second loop iteration. Given the origi-
nal input for str, sum is 0 at this point and the else-branch
is taken. However, because this conditional branch involves
the value sum that is labeled with l6, a snapshot of the cur-
rent program state is created. When this snapshot is later
restored, our system needs to rewrite sum with the value 82
be able to take the if-branch. To determine how the pro-
gram state can be updated consistently, the constraint sys-
tem is solved for l 6 = 82. A solution to this system can
be found (l0 = 38, l1 = 32, l2 = l3 = 8, l4 = 80, and
l5 = 2). Using the mappings, this solution determines how
the related memory locations can be consistently modiﬁed.
As expected, str[0] and str[1] are set to the characters ’8’
and ’2’, respectively. The variable c is also set to 2.
Non-linear dependencies. The atoi function discussed
previously represents a more complex example of what can
be captured with linear relationships. However, it is also
possible that a program performs operations that cannot be
represented as linear constraints. These operations involve,
for example, bitwise operators such as and, or or a lookup
in which the input value is used as an index into a table. In
case of a non-linear relationship, our current system cannot
infer the assignment of appropriate values to labels such that
a certain memory location can be rewritten as desired. Thus,
whenever an operation creates a non-linear dependency be-
tween labels l i and lj, we no longer can consistently update
the state when any label related to l i or lj should be rewrit-
ten. To address this problem, we maintain a set N that keeps
track of all labels that are part of non-linear dependencies.
Whenever a label should be rewritten, all related labels are
determined. In case any of these labels is in N , the state
cannot be consistently changed and the alternative path can-
not be explored.
3.2 Saving and Restoring Program State
The previous section explained our techniques to track
the propagation of input values during program execution.
Every memory location that depends on some interesting
input has an attached label, and the constraint system deter-
mines how values with different labels are related to each
other. Based on this information, multiple paths in the exe-
cution space can be explored. To this end, our system mon-
itors the program execution for conditional operations that
use one (or two) labeled arguments. When such a branch
instruction is identiﬁed, a snapshot of the current process
state is created.
The snapshot of the current execution state contains the
content of the complete virtual address space that is in use.
In addition, we have to store the current mappings and the
constraint system. But before the process is allowed to con-
tinue, one additional step is needed. In this step, we have
to ensure that the conditional operation itself is taken into
account. The reason is that no matter which branch is actu-
ally taken, this conditional operation enforces a constraint
on the possible value range of the labeled argument. We
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007call this constraint a path constraint. The path constraint
has to be remembered and taken into account in case the la-
beled value is later rewritten (further down the execution
path). Otherwise, we might create inconsistent states or
reach impossible paths. When the if-branch of the condi-
tional is taken (that is, it evaluates to true for the current
labeled value), the condition is directly used as path con-
straint. Otherwise, when the else-branch is followed, the
condition has to be reversed before it is added to the con-
straint system. To this end, we simply take the condition’s
negation.
For example, recall the ﬁrst program that we showed
in Figure 1. This program uses two checks to ensure that
x > 0 and x  0 is added to the constraint system. At the next check
on Line 3, another snapshot is created. This time, the else-
branch is taken, and we add the path constraint l0 >= 2
to the constraint system (which, because of the else-branch,
is the negation of the conditional check x  0. When these constraints are analyzed, our
solver determines that l0 = 1. As a result, x is rewritten to
1 and the program continues with the call to print.
When a program state is restored, the ﬁrst task of our
system is to load the previously saved content of the pro-
gram’s address space and overwrite the current values with
the stored ones. Then, the saved constraint system is loaded.
Similar to the case in which the ﬁrst branch was taken, it is
also necessary to add the appropriate path constraint when
following the alternative branch. To this end, the path con-
straint that was originally used is reversed (that is, we take
its negation). This new path constraint is added to the con-
straint system and the constraint solver is launched. When
a solution is found, we use the new values for all related
labels to rewrite the corresponding memory locations in a
consistent fashion. As mentioned previously, when no solu-
tion is found, the alternative branch cannot be explored.
Note that at any point during the program’s execution,
the solution space of the constraint system speciﬁes all pos-
sible values that the labeled input can have in order to reach
this point in the program execution. This information is im-
portant to determine the conditions under which certain be-
havior is exhibited. For example, consider that our analysis
observes an operating system call that should be included
into the report of suspicious behavior. In this case, we can
use the solution(s) to the constraint system to determine all
values that the labeled input can take to reach this call. This
is helpful to understand the conditions under which certain
malicious behavior is triggered. For example, consider a
worm that deactivates itself after a certain date. Using our
analysis, we can ﬁnd the program path that exhibits the ma-
licious behavior. We can then check the constraint system
to determine under which circumstances this path is taken.
This yields the information that the current time has to be
before a certain date.
4 System Implementation
We implemented the concepts introduced in the previous
section to explore the execution space of Windows binaries.
More precisely, we extended our previous malware analy-
sis tool [2] with the capability to automatically label input
sources of interest and track their propagation using stan-
dard taint analysis (as, for example, realized in [12, 23]). In
addition, we implemented the mechanisms to consistently
save and restore program states. This allows us to automati-
cally generate more complete reports of malicious behavior
than our original tool. The reports also contain the infor-
mation under which circumstances a particular behavior is
observed. In this section, we describe and share implemen-
tation details that we consider interesting for the reader.
4.1 Creating
Snapshots
and Restoring Program
Our system (and the original analysis tool) is built on top
of the system emulator Qemu [3]. Thus, the easiest way to
save the execution state of a program would be to save the
state of the complete virtual machine (Qemu already sup-
ports this functionality). Unfortunately, when a sample is
analyzed, many snapshots have to be created. Saving the
image of the complete virtual machine costs too much time
and resources. Thus, we require a mechanism to take snap-
shots of the process’ image only. To this end, we developed
a Qemu component that can identify the active memory
pages of a process that is executing in the guest operating
system (in our case, Microsoft Windows). This is done by
analyzing the page table directory that belongs to the Win-
dows process. Because Qemu is a PC emulator, we have full
access to the emulated machine’s physical memory. Hence,
we can access the Windows kernel data structures and per-
form the same calculations as the Windows memory man-
agement code to determine the physical page that belongs
to a certain virtual address of the process under analysis.
Once we have identiﬁed all pages that are memory mapped
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007for our process, we simply copy the content of those that
are ﬂagged valid. In addition, when creating a snapshot of
a process, we have to make a copy of the virtual CPU regis-
ters, the shadow memory, and the constraint system.
The method described above has one limitation. We can-
not store (or reset) memory that is paged out on disk. This
limitation stems from the fact that although we can access
the complete main memory from outside, we cannot read
the content on the virtual hard disk (without understand-
ing how the Windows ﬁle system and swapping is imple-
mented). Thus, we have to disable swapping and prevent
the guest OS from moving memory pages to the disk where
they can no longer be accessed.
In our experiments, we
found that this limitation is not a problem as our malware
samples had very modest memory demands and never ex-
ceeded the 256 MB main memory of the guest OS.
To reset a process such that it continues from a previ-
ously saved snapshot, we use a procedure that is similar
to the one for storing the execution state. First, we iden-
tify all mapped pages that belong to our process of interest.
Then, for each page that was previously saved, we overwrite
the current content with the one that was stored. When the
pages are restored, we also reset the virtual CPU to its saved
state. Note that it is possible that the process has allocated
more pages than were present at the time when the snapshot
was taken. This is the case when the program has requested
additional memory from the operating system. Of course,
these new pages cannot be restored. Fortunately, this is no
problem and does not alter the behavior of the process. The
reason is that all references in the original pages that now
point to the new memory areas are reverted back to the val-
ues that they had at the time of the snapshot (when the new
pages did not exist yet). The only problem is that the newly
allocated pages are lost for the process, but still considered
in use by the operating system. This “memory leak” might
become an issue when, for example, a memory allocating
routine is executed various times when different execution
paths are explored. Although we never experienced prob-
lems in our experiments, one possible solution would be to
inject code into the guest OS that releases the memory.
An important observation is that a process can only be
reset to a previously stored state when it is executing in user
mode. When a process is executing kernel code, reverting
it back to a user mode state can leave data structures used
by the Windows kernel in an inconsistent state. The same
is true when the operating system is executing an interrupt
handling routine. Typically, resetting the process when not
in user mode leads to a crash or freezes the system.
Our current implementation allows us to reliably reset
processes to previous execution states. However, one has
to consider the kernel state when snapshots are taken or re-
stored. In particular, we have to address the problem that a
resource might be returned to the operating system after a
snapshot has been taken. When we later revert to the pre-
viously stored snapshot, the resource is already gone, and
any handles to it are stale. For example, such a situation
can occur when a ﬁle is closed after a snapshot is made. To
address this problem, we never allow a process to close or
free any resource that it obtains from the operating system.
To this end, whenever an application calls the NtClose
function or attempts to return allocated memory to the OS,
we intercept the function and immediately return to the user
program. From the point of view of the operating system,
no handle is ever closed. Thus, when the process is reset to
an old state, the old handles are still valid.
4.2 Identiﬁcation of Program Termination
The goal of our approach is to obtain a comprehensive
log of the activities of a program on as many different ex-
ecution paths as possible. Thus, before reverting to a pre-
viously stored state, the process is typically allowed to run
until it exits normally or crashes. Of course, our system can-
not allow the process to actually terminate. Otherwise, the
guest operating system removes the process-related entries
from its internal data structures (e.g., scheduler queue) and
frees its memory. In this case, we would lose the possibility
to revert the image to a snapshot we have taken earlier.
To prevent the program from exiting normally, we in-
tercept all calls to the NtTerminateProcess system
service function (provided by the ntdll.dll library).
This is done by checking whether the program counter
of the emulated CPU is equal to the start address of the
NtTerminateProcess function. Whenever the in-
spected process calls this function, we assume that it wishes
to terminate. In this case, we can revert the program to a
previous snapshot (in case unexplored paths are left).
Segmentation faults (i.e., illegal memory accesses) are
another venue for program termination that we intercept.
To this end, we hook the page fault handler and examine
the state of the emulated CPU whenever a page fault oc-
curs. If an invalid memory access is detected, the process is
reverted to a stored snapshot. Interestingly, invalid memory
accesses occur relatively frequently. The reason is that dur-
ing path exploration, we often encounter checks that ensure
that a pointer is not null. In order to explore the alternative
path, the pointer is set to an arbitrary non-null value. When
this value is later dereferenced, it very likely refers to an
unmapped memory area, which results in an illegal access.
Often, we encounter the situation that malicious code
does not terminate at all. For example, spreading routines
are typically implemented as endless loops that do not stop
scanning for vulnerable targets. In such cases, we cannot
simply end the analysis, because we would fail to analyze
other, potentially interesting paths. To overcome this prob-
lem, we set a timeout for each path that our system explores
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007(currently, 20 seconds). Whenever a path is still executed
when the timeout expires, our system waits until the pro-
cess is in a safe state and then reverts it to a previous snap-
shot (until there are no more unexplored paths left). As a
result, it is also not possible for an attacker to thwart our
analysis by deliberating inserting code on unused execution
paths that end in an endless loop.
4.3 Optimization
One construct that frequently occurs in programs are
string comparisons. Usually, two strings are compared by
performing a sequence of pairwise equality checks between