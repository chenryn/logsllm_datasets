title:Sleak: automating address space layout derandomization
author:Christophe Hauser and
Jayakrishna Menon and
Yan Shoshitaishvili and
Ruoyu Wang and
Giovanni Vigna and
Christopher Kruegel
Sleak: Automating Address Space Layout
Derandomization
Christophe Hauser¹ , Jayakrishna Menon¹,² Yan Shoshitaishvili² ,
Ruoyu Wang² , Giovanni Vigna³ , Christopher Kruegel³
Information Sciences Institute, University of Southern California¹ 
Arizona State University²
University of California, Santa Barbara³
Sleak in a Nutshell
What
- Sleak automates the process of discovering address 
leaks in binary programs.
- It detects partial and indirect leaks as well (i.e., 
leaking some bits of address).
How
- I performs static analysis and symbolic execution in 
order to generate precise expressions of what leaks.
Why
- I helps attackers bypass ASLR by recovering bits of 
leaked addresses.
Background: exploiting memory corruption 
bugs on modern OS platforms
The C programming language :)
● Is almost 50 years old!
● In the top 10 programming 
languages used in 2019.
● The majority of our software 
stacks are still written in C ( and 
C++).
● It compiles to binary and runs 
efficiently.
The C programming language :)
Memory safety :(
● Is almost 50 years old!
● In the top 10 programming 
languages used in 2019.
● The majority of our software 
stacks are still written in C ( and 
C++).
● It compiles to binary and runs 
efficiently.
● Memory corruption bugs remain 
very common.
● It remains the most exploited class 
of bugs.
Memory corruption: memory modified with 
no assignments, e.g., buffer overflows, 
arbitrary writes
Fast forward: mitigations
Non-executable 
data
Compiler-level mitigations
OS-level mitigations
2003: 
OpenBSD’s W^X
2005: ASLR 
in Linux
2007: Return-oriented 
programming
1997: return 
to libc
2004: DEP (MS 
Windows)
2007: ASLR in
MacOS and 
Windows
Fast forward: mitigations
Compiler-level mitigations
OS-level mitigations
Address Space 
Layout 
Randomization
2003: 
OpenBSD’s W^X
2005: ASLR 
in Linux
2007: Return-oriented 
programming
1997: return 
to libc
2004: DEP (MS 
Windows)
2007: ASLR in
MacOS and 
Windows
Non-executable data pages
W^X: “Write xor Execute”
DEP: Data Execution Prevention 
@BUF
Overflow
Classic BOF
Stack
RET
...
...
...
BUF
...
Libc
...
...
Main binary
Code
Non-executable data pages
W^X: “Write xor Execute”
DEP: Data Execution Prevention 
@BUF
Overflow
After W^X/DEP
Stack
RET
...
...
...
BUF
...
Libc
...
...
Main binary
Code
Non-executable data pages
After W^X/DEP
W^X: “Write xor Execute”
DEP: Data Execution Prevention
- Attackers employ code reuse 
attacks. 
Stack
@Gadget1
@Gadget2
@Gadget3
@Gadget4
...
Gadget1
Gadget2
Gadget3
Gadget4
...
Code
Fixed base 
address
Fixed base 
address
0x4000000
● W^X, DEP: non-executable data pages
○ Attackers employ code reuse 
attacks
● ASLR: Address Space Layout 
Randomization - the base address of 
.text, .data, heap, stack and memory 
mappings is randomized
○ Attackers need pointer leaks!
ASLR
Stack
@Gadget1
@Gadget2
@Gadget3
@Gadget4
...
Gadget1
Gadget2
Gadget3
Gadget4
...
Code
Randomized 
base address
Randomized 
base address
0x???????
Pointer leak example
Attacker-controlled
While (i < size)
{
b = buf[i];
…
}
Attacker-controlled
While (i < size)
{
b = buf[i];
…
}
*f;
Int x;
Char 
*buf;
OOB 
read!
Pointer leak example
Attacker-controlled
While (i < size)
{
b = buf[i];
…
}
0xAB200
OOB 
read!
*f;
Int x;
Char 
*buf;
Pointer leak example
0xAB200
Attacker-controlled
While (i < size)
{
b = buf[i];
…
}
*f;
Int x;
Char 
*buf;
OOB 
read!
f()
Base+0x200
libc
Base
address= 0xAB200 - 0x200
ASLR weaknesses
- Leaking a single address is generally enough to recover 
the layout of an entire module (e.g., library).
- The entropy is limited by practical constraints (e.g., 
user/kernel separation, stack located higher than heap, 
etc.)
ASLR weaknesses
- Prior work has demonstrated that up to 20-bit of 
address-entropy remains within the reach of practical 
attacks.
- As a result partially leaking addresses can be 
sufficient for successful attacks.
Architecture
32-bit
64-bit
Stack
19
30
Heap
13
28
Mmap
8
28
Bits of entropy per memory region (Linux 4.5.0)
Enough background, now, Sleak!
Sleak in a Nutshell
- Consider a program with outputs o1 , ..., on and 
addresses a1 , ...an.
- We are interested in outputs leaking any transformation 
fk of an address, i.e.,:
{oi = fk (ai )}
Assumptions
- Stripped (Linux) binaries.
- Standard input/output implementations (i.e., we rule 
out custom input/output functions).
- Standard compiler, calling conventions...
Attacker Model
Inputs
Program
execution
Outputs
Binary
Remote 
attacker
Challenges
Source code
Binary
● Types.
● Variable names.
● Functions.
● ...
● Registers.
● Memory locations.
● Basic blocks.
● ...
Static analysis
Symbolic 
execution
● Scalable.
● Imprecise.
● Precise.
● Unscalable.
Dynamic analysis
● Precise.
● Low coverage.
1. Path selection
2. Address 
identification
3. Leak identification
4. De-randomization
Static analysis: Path selection and address 
identification
1: Output function identification
output
…
…
● Control-Flow recovery.
● Identify statements 
corresponding to output 
function calls.
● Those are marked as sinks.
…
…
…
…
…
…
output
…
…
…
…
2: Address identification
● Static backward slicing.
● Locate program statements 
defining addresses.
● Leverages address inference 
rules.
● Consider those as sources.
…
…
…
…
…
…
…
…
address
address
…
…
…
…
Address Inference Rules
(1) Leverage known information (GOT, relocations, 
external function prototypes, e.g., return 
values of malloc() or mmap()).
(2) Leverage instruction semantics (i.e., target of 
load and store operations)
(3) Value range: does the value fall within the 
.text, .data, heap, stack or memory mapping 
regions?
3: Leak Identification
● Paths between sources and sinks are 
symbolically executed.
● To limit state explosion, the 
execution is constrained to those 
paths defined statically.
● The symbolic expressions of output 
parameters are analyzed. 
Expressions depending on an address 
are flagged.
…
…
…
…
…
…
…
…
output
address
…
…
…
…
4. De-randomization
● An remote attacker observes the 
output ok of the program.
● The attacker obtains the expression 
of ok from Sleak.
● Using a constraint solver, the 
attacker guesses possible values for 
the leaked address.
Execution
Binary
0k = 42
0k = ai / 4
$ z3.solve(o== 42, o== a/4)
(a = 168, o = 42)
(a =169, o = 42)
(a = 170, o = 42)
(a = 171, o = 42)
Evaluation
80 CTF binaries 
(Deconf quals 
2012-2018)
OverlayFS
(Linux Kernel)
libXSLT
(large library used 
by Firefox and 
Chrome)
● angr (built-in analyses 
+ custom module)
● Lightly modified Qemu
● Xeon E5-1650 v4 @ 
3.60GHz CPUs and 64GB
Experimental setup
- We collected ground truth data from CTF writeups, manual 
analysis and the Common Vulnerabilities and Exposures 
(CVE) database.
- libXSLT and OverlayFS are complex code bases with 
extensive use of dynamic constructs. Therefore, we 
leverage dynamic execution to initialize the program 
state.
- XSLT: test cases shipping with the library.
- OverlayFS: benchmark of file system operations.
Evaluation results 
(summary)
CFG Nodes Functions Sinks
Leak 
Detected
Ground 
Truth
CTF binaries
0x00ctf_17_left
a5afefd29d5dc067ed6507
d78853c691
defcon_16_heapfun4u
ez_pz
pwn1
int3rrupted
libXSLT
Overlayfs
72
496
200
91
318
327
76842
1981
1
16
5
2
1
6
505
191
3
11
1
3
1
4
27
27
✓
✓
✓
✓
✓
✓
✓
✓
✓
x
✓
✓
x
✓
✓
✓
Limitations
- Tracking data dependency on complex data structures on 
long code paths is hard!
- Static analysis / code coverage vs dynamic aspects of 
code (e.g. runtime binding).
- State explosion
- Paths with complex loops.
- Symbolic strings.
- Environment models(e.g., system calls).
Stumbling blocks
Data structure 
recovery.
Pointer aliasing.
Conclusion
- Sleak allows attackers to recover information about the 
memory layout applications in the presence of address 
space randomization.
- It is the first model to reason about indirect address 
leaks at the binary level.
- We evaluated it on both small userspace programs, a 
complex library and a kernel file system.
?