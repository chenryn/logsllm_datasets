the  examples  from  Figures  1  and  3.  Here,  BigCo  HR’s 
public key is rsa:3:c1ebab5d, while BCL HR’s public 
key is rsa:3:8e72145b. 
5.1 Example from Figure 1 
Program  1  shows  the  English  security  statements 
from Figure 1 and their translations into Binder. 
English 
statement 
Binder statement 
statement 1b is shown after it has been imported into the 
context  of  service  S.  Statement  1b is  explicitly  quoted  as 
coming from BigCo HR (rsa:3:c1ebab5d). 
Statement 2 shows the establishment of trust in state-
ments from BigCo HR; variable S stands for the employ-
ment status (e.g., full_time). If BigCo HR’s public key 
appears often in our program, we might choose to write 
employee(X, bigco, full_time) :- 
  Y says employee(X, bigco, full_time), 
  bound(bigco_hr, Y). 
bound(bigco_hr, rsa:3:c1ebab5d). 
and  bind  the  local  name  bigco_hr  to  a  public  key.  We 
can even refer to local names elsewhere on the distributed 
system, simulating the linked name spaces of SDSI/SPKI, 
but without built-in language support. 
In  this  example,  names  like  john_smith,  bigco, 
and full_time  pass  unchanged  from  BigCo  HR  to  ser-
vice  S;  more  complex  mappings  can  be  implemented  by 
additional rules, perhaps carrying along extra public keys 
to  root  these  names  as  in  SDSI/SPKI.  For  example,  we 
might explicitly write 
employee( 
  rsa:3:c1ebab5d, john_smith, 
  rsa:3:c1ebab5d, bigco, 
  rsa:3:c1ebab5d, full_time) 
“John Smith is a 
full-time BigCo 
employee” 
employee(john_smith, 
         bigco, 
         full_time). 
(original form, in the context of 
BigCo HR) 
rsa:3:c1ebab5d says 
  employee(john_smith, 
           bigco, 
           full_time). 
(as imported into the context of 
service S) 
to  associate  these  names  with  a  particular  name  space, 
while modifying the other rules accordingly. 
Finally,  statement  3  shows  the  statement  “Full-time 
BigCo employees can read resource R,” while statement 4 
shows the derived atom at service S that gives John Smith 
access to resource R. 
5.2 Example from Figure 3 
Program  2  shows  the  English  security  statements 
from Figure 3 and their translations into Binder. 
# 
1a 
1b 
2 
3 
4 
“I trust BigCo 
HR to say 
who is a BigCo 
employee” 
employee(X, bigco, 
         S) :- 
  rsa:3:c1ebab5d says 
    employee(X, bigco, 
            S). 
“Full-time BigCo 
employees 
can read resource 
R” 
can(X, read, 
    resource_r) 
:- employee(X, bigco, 
            full_time). 
“John Smith can 
read resource R” 
can(john_smith, 
    read, resource_r). 
Program 1. English statements from Figure 1 
and their translations into Binder 
Statement 1a— “John Smith is a full-time BigCo em-
ployee”—is  shown  in  the  context  of  BigCo  HR;  while 
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE 
# 
1a 
1b 
2a 
English 
statement 
Binder statement 
“John Smith is a 
BCL employee”  rsa:3:8e72145b says 
employee(john_smith, 
         bcl). 
(original form, in the context of 
BCL HR) 
  employee(john_smith, 
           bcl). 
(as imported into the context of 
BigCo HR or service S) 
“I trust BCL HR 
to say 
who is a BCL 
employee” 
employee(X, bcl) :- 
  rsa:3:8e72145b says 
    employee(X, bcl). 
(original form, in the context of 
BigCo HR) 
“All BCL 
employees are 
BigCo 
employees” 
“I trust BigCo 
HR to say who is 
a BigCo 
employee” 
“John Smith is a 
BigCo 
employee” 
2b 
3a 
3b 
4 
5a 
5b 
5c 
rsa:3:c1ebab5d says 
  employee(X, bcl) 
:- rsa:3:8e72145b says 
     employee(X, bcl). 
(as imported into the context of 
service S) 
employee(X, bigco) :- 
  employee(X, bcl). 
(original form, in the context of 
BigCo HR) 
rsa:3:c1ebab5d says 
  employee(X, bigco) 
:- 
rsa:3:c1ebab5d says 
  employee(X, bcl). 
(as imported into the context of 
service S) 
employee(X, bigco) :- 
  rsa:3:c1ebab5d says 
    employee(X, bigco). 
employee(john_smith, 
         bigco).  
(in the context of BigCo HR) 
rsa:3:c1ebab5d says 
  employee(john_smith, 
           bigco).  
(in the context of service S, after 
certificate import or local deri-
vation) 
employee(john_smith, 
         bigco)  
(in the context of service S, after 
further local derivation) 
Program 2. Security statements from Figure 3 
and their translations into Binder 
Statement  1—“John  Smith  is  a  BCL  employee”—is 
shown  in  its  original  form  at  BCL  HR  and  as  imported 
into either BigCo HR or service S. 
Statement 2 shows the establishment of trust in state-
ments from BCL HR, both at BigCo HR and as imported 
into  service  S.  Note  that  statement 2b has  been rewritten 
from  its  expected  form; this  is  discussed  in  detail  in  Ap-
pendix B. 
Statement 3 is shown at BigCo HR and at service S. 
Statement 4 is shown at service S. 
Statement  5  is  shown  in  multiple  forms  because  of 
the  different  certificate  flows  possible.  Statement  5a  can 
be  derived  at  BigCo  HR  and  imported  into  service  S  as 
statement 5b; statement 5b can also be derived directly at 
service S using statements 1b and 2b; statement 5c can be 
derived at service S using statements 4 and 5b. 
6. Proofs, monotonicity, and revocation 
A  service  grants  access  to  a  resource  in  Binder  only 
when it can derive an atom saying it should; otherwise, by 
default,  access  is  denied.  The  derivation  steps  form  a 
proof that access should be granted. 
A proof can be generated at the service—as tradition-
ally—or we can require that the client generate the proof 
and  transmit  it  with  the  request.  If  so,  the  service  need 
only  check  the  proof;  this  optimization  can  offload  work 
from  a  heavily  loaded  service  onto  its  less  busy  clients, 
while  also  helping  avoid  denial-of-service  attacks.  (This 
approach is also used by Jim [13] and by Appel and Fel-
ten  [3].)  Since  the  service’s  policy  is  stored  as  a  Binder 
program,  and  since  Binder  statements  can  be  passed  in 
certificates, the service can pass its policy to the client in 
preparation for the construction of such a proof. 
Binder is monotonic—if an atom is derivable, it’s still 
derivable if we add more statements [15]. Monotonicity is 
appropriate  in  a  distributed  environment,  since  withhold-
ing  some  statements  from  a  service  will  not  cause  it  to 
grant  greater  access  rights.  Moreover,  a  proof  generated 
on a client with little information available will still check 
on a service with more information. 
One  consequence  of  monotonicity  is  that  traditional 
certificate  revocation  cannot  be  modeled  from  inside 
Binder; it requires additional mechanism. We have studied 
three ways to extend Binder to support revocation reliably. 
One is through short-lived statements. We can attach 
validity  intervals  to  each  Binder  statement, as  with tradi-
tional  certificates,  and  constrain  the  validity  intervals  of 
derived  atoms  accordingly.  Once  a  statement  expires,  it 
can  be  removed  from  all  contexts,  along  with  all  atoms 
that cannot be derived without it. 
A  second  approach  is  through  a  language  extension 
allowing freshness  constraints on  statements. If  a  deriva-
tion rule depends on fresh P(X, Y), say, instead of just 
P(X,  Y),  then  a  new  P(X,  Y)  must  be  derived  for  each 
use. This may involve contacting the exporters of old cer-
tificates  to  obtain  fresher  ones.  A  generalization  of  this 
mechanism is to allow each use of a certificate to specify 
how fresh it must be. 
The  final  approach  is  to  reference  distributed  state. 
For  example,  a  statement  could  have  an  associated  Boo-
lean  state  “valid”  that  turns  from  true  to  false  if  it  is  re-
voked.  This  state  could  be  explicitly  referenced  from 
Binder, perhaps with a freshness constraint. Such support 
for  state,  while  problematical,  might  also  be  needed  for 
Binder  to  emulate  features  of  digital  rights  management 
languages as discussed below. 
If the validity of a proof can vary with time, a proof 
that checks at a client may not check at the service. If so, 
the  client  can  be  informed  of  its  error—e.g.,  that  a  par-
ticular statement is no longer fresh enough—and asked to 
regenerate the proof. 
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE 
7. Taxonomy and related work 
The Binder security language has five key properties. 
1)  A statement in Binder can be translated into a de-
clarative,  stand-alone  English  sentence.  This  is 
known  good  practice  for  messages  in  a  security 
protocol [1] and we propose that it is even better 
practice for statements in a security language. 
2)  Binder  programs  can  explicitly  define  new,  ap-
plication-specific  predicates,  which  can  act  as 
lemmas  in  proofs.  Predicates  can  be  defined  re-
cursively. Rich proofs are allowed. 
3)  Certificates  can  contain  arbitrary  statements,  in-
cluding  definitions  and  uses  of  new  application-
specific  predicates.  These  certificates  can  be 
safely interpreted outside their exporting context. 
4)  Binder  statements  can  appear  in  certificates,  in 
policies,  in  ACLs,  and  elsewhere,  and  these 
statements can interoperate freely. 
5)  Queries  in  Binder  are  decidable  in  polynomial 
time, as outlined in Appendix C. 
None  of  the  existing  languages  compared  below—
X.509,  SDSI/SPKI,  PolicyMaker  and  KeyNote,  SD3  and 
other  logic-based  security  languages,  and  various  digital 
rights management (DRM) languages—shares all of these 
properties. With a few exceptions, we believe that Binder 
provides  functionality  as  great as  any  of  these  languages 
and is more appropriate for use in open systems. 
7.1 X.509 
An  X.509  certificate  is  a  signed  n-tuple,  where  n  is 
large and most of the fields are optional. This n-tuple can 
be thought of as asserting a predicate P(x1, x2, x3, …, xn) 
over the values it contains, but X.509 certificates have no 
straightforward way to say  which P is being used. (Thus, 
the translation of an X.509 certificate into English has no 
verb. Perhaps the predicate is best thought of as the con-
stant  is_an_X509_certificate.)  X.509  thus  does  not  share 
properties 1–3. X.509 also fails property 4; it can be used 
only in certificates, not in policies or ACLs.  
A  complex  X.509  certificate  may  often  be  factored 
into a number of smaller Binder certificates, rather like a 
translation  from  a  CISC  architecture  to  a  RISC  architec-
ture; the  operations  may  require more  steps  but  these  in-
dividual  steps  can  combine  in  more  ways.  The  access 
control  decisions  in  Binder  programs  are  more  explicit 
than in X.509, and perhaps more understandable in many 
cases. 
In  X.509  it  is  easy  to  talk  about  a  security  decision 
requiring  the  approval  of  one  of  a  certain  class  of  CAs, 
but  hard  to  talk  about  the  approval  of  k-out-of-n  CAs. 
This  is  because  X.509  depends  so  directly  on  the  con-
struction of linear chains of certificates. 
Much of the difficulty in using X.509 comes from its 
great  complexity  and many  implicit  mechanisms  [9].  We 
can  expect  that  a  simpler,  more  explicit  language  like 
Binder might be easier to use as well as more expressive. 
7.2 SDSI and SPKI 
SDSI/SPKI  programs  do  not  explicitly  encode  the 
predicate  being  defined.  Instead,  SDSI  statements  build 
their meaning from an implicit “speaks-for” predicate [16, 
2], while SPKI also encodes the predicate into the “tags” 
in  SPKI  statements  [8].  Nevertheless,  SDSI/SPKI  state-
ments can be translated directly into English. While SPKI 
programs  can  define  multiple  predicates,  SDSI  programs 
can  define  only  the  speaks-for  predicate,  and  thus  SDSI 
does not share properties 2 and 3. Even SPKI cannot de-
fine  arbitrary  predicates:  the  boss  example  in  Section  2 
cannot  easily  be  defined  in  SPKI,  since  the  tags  cannot 
contain  (i.e.,  be  parameterized  by)  constrained  variables 
like Y. 
Formalizing  SDSI’s  speaks-for  relationship  is  diffi-