of the aforementioned file should look like this:
[database]
ssl: true
verify_ssl: false
[ 210 ]
Enterprise Repository Management with Pulp Chapter 8
If you examine this file, you will see there is a great deal of configuration that can
be carried out, all of which is well documented with comments. Specifically, you
can customize the following sections:
[email]: This is off by default but if you want your Pulp server to
send email reports, you would configure this here.
[database]: We have simply turned on SSL support in this
section, but if the database was on an external server or required
more advanced parameters, these would be specified here.
[messaging]: For communication between different Pulp
components, the default Qpid message broker requires no further
configuration here, but if you are using RabbitMQ and/or have
turned on authentication/SSL support, then that will need to be
configured here.
[tasks]: Pulp can have separate message brokers for inter-
component communication and its asynchronous tasks, and the
broker for the latter can be configured here. As we are using the
same Qpid instance for both functions, nothing further is required
for this example.
[server]: This is used to configure the server's default
credentials, hostname, and such.
12. Once the Pulp server is configured, we must generate the RSA key pair and CA
certificate for Pulp using the following two commands:
$ sudo pulp-gen-key-pair
$ sudo pulp-gen-ca-certificate
13. Pulp uses Apache to serve its HTTP(S) content, and so we must configure this.
First of all, we initialize the backend database by running the following
command (note it is run as the apache user):
$ sudo -u apache pulp-manage-db
[ 211 ]
Enterprise Repository Management with Pulp Chapter 8
14. If you are intending to use SSL transport with Apache, be sure to configure it to
your enterprise requirements. CentOS installs a self-signed certificate for Apache
SSL by default, but you may want to replace this with a certificate signed by your
Enterprise CA. Also, be sure to disable the insecure SSL protocols—as a
minimum, it is recommended to place the following two settings
into /etc/httpd/conf.d/ssl.conf:
SSLProtocol all -SSLv2 -SSLv3
SSLCipherSuite HIGH:3DES:!aNULL:!MD5:!SEED:!IDEA
This, of course, is only a guide, and most enterprises will have their own security
standards that should be adhered to here.
As new vulnerabilities are discovered, these requirements may change.
The preceding configuration is believed to be good practice at the time of
writing, but could change at any time without notice. It is up to you to
check any and all security-related settings for your environment.
15. With Apache configured, set it to start on boot and start it up:
$ sudo systemctl enable httpd.service
$ sudo systemctl start httpd.service
16. Pulp has several other backend services that are required for it to be operational.
Each of these can be configured and tuned as required, but again, for the sake of
our example server, it is sufficient to enable and start each in turn:
$ sudo systemctl enable pulp_workers.service
$ sudo systemctl start pulp_workers.service
$ sudo systemctl enable pulp_celerybeat.service
$ sudo systemctl start pulp_celerybeat.service
$ sudo systemctl enable pulp_resource_manager.service
$ sudo systemctl start pulp_resource_manager.service
17. Our final task is to install the administrative components of Pulp so that we can
manage our server:
$ sudo yum install pulp-admin-client pulp-rpm-admin-extensions
pulp-deb-admin-extensions
[ 212 ]
Enterprise Repository Management with Pulp Chapter 8
18. There is one final task to complete for our server. Pulp is designed to be
administered remotely, and as such, it communicates over SSL to ensure the
security of all transactions. Although we have created an all-in-one host and
throughout this chapter will perform the server admin from the same host, we
need to tell the Pulp admin client that we are using self-signed
certificates—otherwise, SSL validation will fail. To do this,
edit /etc/pulp/admin/admin.conf, and in the [server] section, define the
following parameter:
verify_ssl: False
19. Finally, we can test that our Pulp server is operational by logging in to it.
Although Pulp supports multiple user accounts, and even integration with LDAP
backends, a simple installation such as ours comes with one administrator
account, where the username and password are both admin.
If all goes well, you should see output similar to the following and be able to
query to server status (note that the output has been truncated to save space):
Now that we have a fully operational Pulp server, we shall demonstrate the process of
creating repositories for managed stable updates and system builds using our newly built
Pulp system.
[ 213 ]
Enterprise Repository Management with Pulp Chapter 8
Building repositories in Pulp
Although in this chapter we will only be using a subset of the features available in Pulp, it
is intended that a viable workflow is demonstrated here that showcases why you might
choose Pulp to manage Enterprise repositories, rather than rolling your own solution (for
example, copying packages off an ISO as we did in Chapter 6, Custom Builds with PXE
Booting).
The process for handling RPM-based package repositories and DEB-based ones is broadly
similar.
Let's start by exploring how to create and manage RPM-based repositories.
Building RPM-based repositories in Pulp
Although installing Pulp is quite a complex process, once it is installed, the process of
managing repositories is incredibly straightforward. However, it does require a little
knowledge of the repository structure for your chosen Linux distribution. Let's continue
with the CentOS 7 build that we have been using as an example throughout this book.
The core CentOS 7 repositories are split into two—first of all, there is the OS repository; this
contains all of the files for the latest point release of CentOS 7—which, at the time of
writing, is 7.6. This was last updated in November 2018 and will remain static until CentOS
7.7 is released. The updates for this release are then contained in a separate repository, and
so to build a fully functional mirror for CentOS 7 in our Pulp server, we need to mirror both
of these paths.
Let's start by creating a mirror of the base operating system:
1. The first step is to log into the pulp-admin client, as we demonstrated at the end
of the previous section. Then, from there, we run the following command to
create a new repository:
$ pulp-admin rpm repo create --repo-id='centos76-os' --relative-
url='centos76-os' --
feed=http://mirror.centos.org/centos/7/os/x86_64/
[ 214 ]
Enterprise Repository Management with Pulp Chapter 8
Let's break that command down:
rpm repo create: This set of keywords tells the Pulp server to
create a new RPM-based repository definition. Note that nothing is
synchronized or published at this stage—this is simply creating
metadata for a new repository.
--repo-id='centos76-os': This tells Pulp that the ID of our
new repository is centos76-os—this is like a unique key and
should be used to differentiate your new repository from others.
--relative-url='centos76-os': This instructs Pulp where to
publish the repository—RPM-based repositories are published
at http(s)://pulp-server-
address/pulp/repos/.
--feed=http://mirror.centos.org/centos/7/os/x86_64/:
This is the upstream location from which RPM-based content will
be synchronized.
2. With our repository definition created, the next step is to synchronize the
packages from the upstream server. This is as simple as running this command:
$ pulp-admin rpm repo sync run --repo-id='centos76-os'
3. This kicks off an asynchronous command that runs in the background on the
server—you can check the status at any time using this command:
$ pulp-admin rpm repo sync status --repo-id='centos76-os'
4. Finally, once the synchronization is completed, the repository must be
published—this effectively makes the synchronized content available over the
Apache web server installed as part of the Pulp installation earlier:
$ pulp-admin rpm repo publish run --repo-id='centos76-os'
[ 215 ]
Enterprise Repository Management with Pulp Chapter 8
Now, with this completed, you have an internal snapshot of the upstream CentOS 7.6 OS
repository defined by the --feed parameter, which will remain constant on our Pulp
server even when CentOS 7.7 is released.
Now, of course, we also need updates to ensure we get the latest security patches, bug fixes,
and so on. The frequency of updates of your repositories will depend upon your patching
cycle, internal security policies, and so on. Hence, we will define a second repository to
house the update packages.
We will issue an almost identical set of commands to the preceding ones to create the
updates repository, only this time there are two key differences:
We are using the /updates/ path for the feed rather than /os/.
We have put a date stamp into repo-id and relative-url—you could, of
course, adopt your own versioning scheme here—however, as this repository
will be a snapshot of all CentOS 7 updates to August 7, 2019, using the date of
the snapshot as an identifier is one sensible approach:
$ pulp-admin rpm repo create --repo-id='centos7-07aug19' --
relative-url='centos7-07aug19' --
feed=http://mirror.centos.org/centos/7/updates/x86_64/
$ pulp-admin rpm repo sync run --repo-id='centos7-07aug19'
$ pulp-admin rpm repo publish run --repo-id centos7-07aug19
With this run, we can then use the pulp-admin client to inspect the repositories and
inspect the disk usage. At present, we can see that the Pulp filesystem has 33 GB used,
though not all of this is for CentOS as there are other repositories on this test system. This
level of usage will become important in a minute.
In an enterprise environment, a good practice would be to build or update a set of test
CentOS 7 systems to this August 7 snapshot and perform the requisite testing on them to
ensure confidence in the build. This is especially important in physical systems where
kernel changes could cause issues. Once confidence has been established in this build, it
becomes the baseline for all CentOS 7 systems. The great thing about this for an enterprise
scenario is that all systems (provided they use the Pulp repository) will have the same
versions of all packages. This, combined with good automation practices, as we have
discussed throughout this book so far, brings almost Docker-like stability and platform
confidence to a Linux environment.
[ 216 ]
Enterprise Repository Management with Pulp Chapter 8
Building on this scenario, suppose that overnight a critical security patch is released for
CentOS 7. As important it is to apply this patch in a timely manner, it also is important to
perform testing on it to ensure it doesn't break any existing services. As a result, we do not
wish to update our centos7-07aug19 repository mirror, as this is a known stable snapshot
(in other words, we have tested it and are happy with it—it is stable within our enterprise
environment).
If we were just using the upstream internet-facing repositories, then we would have no
control over this and our CentOS 7 servers would blindly pick up the patch the next time
an update was run. Equally, if we were manually building repository mirrors using a tool
such as reposync, we would have one of two choices. First, we could update our existing
mirror, which would cost us little disk space, but would bring the same problems as using
the upstream repositories (that is, all servers pick up the new patch as soon as an update is
run). Alternatively, we could create a second snapshot for testing purposes. I estimated that
mirroring the CentOS 7 updates on the Pulp server required approximately 16 GB of disk
space and so creating a second snapshot would require around 32 GB of disk space. As time
goes on, more snapshots would require more and more disk space, which is incredibly
inefficient.
This is where Pulp really shines—not only can it create and manage RPM-based
repositories in an efficient manner, but it also knows not to download packages that it
already has on a sync operation and not to duplicate packages on a publish—hence, it is
very efficient in terms of both bandwidth and disk usage. Due to this, we can issue the
following command set to create a new snapshot of the CentOS 7 updates on August 8:
$ pulp-admin rpm repo create --repo-id='centos7-08aug19' --relative-
url='centos7-08aug19' --
feed=http://mirror.centos.org/centos/7/updates/x86_64/
$ pulp-admin rpm repo sync run --repo-id='centos7-08aug19'
$ pulp-admin rpm repo publish run --repo-id centos7-08aug19
[ 217 ]
Enterprise Repository Management with Pulp Chapter 8
You will recognize the similarity with the commands we ran earlier in this section to create
the August 7, 2019 snapshot—they are, in fact, identical except for the new repository ID (-
-repo-id) and URL (--relative-url), which carry the new date in to differentiate it
from our earlier one. This process will run as before, as shown in the following
screenshot—it appears that all packages are downloaded and at this stage, there is little
clue as to what goes on behind the scenes:
However, let's now examine the disk usage:
Here, we can see that the disk usage has been rounded up to 34 GB—we would likely find
the usage considerably less if we used a more fine-grained measure. In this way, Pulp
allows us to create snapshots almost as we require them, without consuming vast amounts
of disk space, while retaining older ones for stability purposes until new ones are proved, at
which point redundant snapshots can be deleted.
It is worth saying in this regard that deleting a repository from Pulp does not necessarily
free up disk space. The reason for this is that the package de-duplication at the backend
must be careful not to delete any packages that are still required. In our example, more than
99% of the packages from our August 7 snapshot are also in the August 8 one, and so it is
important that if we delete either of these, that the other remains intact.
[ 218 ]
Enterprise Repository Management with Pulp Chapter 8
In Pulp, this process is called orphan recovery, and it is the very process of finding
packages that no longer belong to any repository (presumably because the repository was
deleted) and tidying them up.
Completing our current example, suppose that we tested our August 8 snapshot and the
updated packages in it caused problems in testing. From this, we have determined that this
snapshot is not suitable for production and that we will delete it, pending creation of a new
snapshot when a fix becomes available:
1. First of all, we must delete the repository itself:
$ pulp-admin rpm repo delete --repo-id='centos7-08aug19'
This removes the repository definition and the published URL on the Apache
server so that it can no longer be used.
2. To clean up any orphan packages, we can then issue the following command:
$ pulp-admin orphan remove --all
This command is a general cleanup that removes all orphans from across the
entire Pulp server and is a good general maintenance step. However, the
command can receive more fine-grained control to remove only a specific type of
orphan (for example, you could clean out all orphan RPMs, but not DEB
packages):
[ 219 ]
Enterprise Repository Management with Pulp Chapter 8
3. Once this step is completed, we will see that our additional disk space used by
the new snapshot has been recovered:
In this section, so far we have stepped through all the Pulp commands and activities
manually—this has been done to provide you with a good understanding of the steps
required in setting up Pulp and the accompanying repositories. In regular services, best
practice would dictate that these steps are performed with Ansible—however, there are no
native Ansible modules to cover all of the tasks we have performed in this chapter.
For example, the pulp_repo module (introduced to Ansible in version 2.3) is capable of
creating and deleting repositories, as we have done so far in this chapter with pulp-admin
rpm repo create. However, it cannot perform orphan clean-up, and so this command
would need to be issued using the shell or command Ansible modules. Full automation
with Ansible is left as an exercise for you.
Once our repos are set up, the final step is to put them into use on our Enterprise Linux
servers, and we will cover this in the next section of this chapter.
First, though, we will look at some of the nuances of managing DEB packages in Pulp in
contrast to RPM-based management.
Building DEB-based repositories in Pulp
Although there are some subtle differences in the command-line structure between the
RPM repository plugin for Pulp and the DEB one, the overall process is the same. As
before, some prior knowledge is also required of the repository structure to create an
effective mirror. In this book, we have worked with Ubuntu Server 18.04 LTS as an
example, and the default repository set that is configured on this is as follows:
bionic: This is the baseline repository for the release of Ubuntu Server 18.04
(codename Bionic Beaver), and as with the OS repository for CentOS 7, does not
change following the release of the operating system
bionic-security: These are security-specific updates for the bionic operating
system built post-release
bionic-updates: These are non-security updates for the bionic operating
system release
[ 220 ]
Enterprise Repository Management with Pulp Chapter 8
There are other repositories too, such as backports, and in addition to
the main component (which we will concern ourselves with here), there is a wide array of
packages available in the restricted, universe, and multiverse components. Going
into greater detail about the Ubuntu repository structure is beyond the scope of this book,
but suffice to say there is a wide array of documentation available on this subject. The
following link is a good place to start reading about the different Ubuntu repositories you
may wish to mirror: https:/​/​wiki.​ubuntu.​com/​SecurityTeam/​FAQ#Repositories_​and_
Updates.
For now, let's suppose we are updating a minimal build of Ubuntu Server 18.04 LTS. For
this, we are only interested in packages in the main component, but we do need a snapshot
of all the security fixes and updates at a given point in time, just like one we had for our
CentOS 7 build:
1. First of all, having ensured we are logged in to the pulp-admin client as before,
we will create a repository in Pulp for the main component and the operating
system release packages:
$ pulp-admin deb repo create --repo-id='bionic-amd64-08aug19' --
relative-url='bionic-amd64-08aug19' --
feed='http://de.archive.ubuntu.com/ubuntu' --releases=bionic --
components=main --architectures='amd64' --serve-http=true
As you can see, the preceding command is very similar to our RPM repository
creation command. We specify repo-id and relative-url in the same manner
as before and specify an upstream feed URL. This time, though, we are
specifying the Ubuntu releases, components, and architectures as
command-line options whereas, in our CentOS 7 example, these were implicit in
the URL we mirrored. In addition to these DEB-specific configuration parameters,
we are now also specifying the --serve-http option. By default, Pulp serves all