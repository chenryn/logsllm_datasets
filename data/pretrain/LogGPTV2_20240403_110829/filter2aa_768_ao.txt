22 
22 
N/A 
get_typeId 
1333 
1335 
1327 
1334 
get_virtualAddress 
N/A 
N/A 
N/A 
0x1a090 
从上表可以看出，静态变量具有虚拟地址、节和地址偏移等信息，因此可以从内存中
读到它的值，即使不在执行这个函数，也可以使用调试器读取它的值，从这个意义上来说，
它与全局变量很类似。其他 3 个局部变量都是分配在栈上的，它的偏移属性是相对于栈帧
的基地址寄存器（EBP）。所有变量符号都有一个 typeId 属性用来查询它的类型。 
图 25-13  FuncTest 函数（发布版本）的调试符号 
图 25-13 显示的是发布版本的 FuncTest 函数的子符号情况，从图中可以看到，用于变
量检查功能的静态变量在发布版本中不见了，另外，循环变量 i 也被优化掉而分配到寄存
器中了。 
《软件调试》补编 
- 52 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
25.13  Thunk 及其符号 
当 CPU 在不同字长（16 位和 32 位）、不同空间（内核空间和用户空间）或不同模块
之间（DLL）的代码之间跳转（执行转移）时，往往需要有一些代码来完成衔接、映射，
以及转换翻译等工作，人们给这样的代码片段起了个很特别的名字，叫做 Thunk。关于
Thunk 一词的来源有很多种说法，有人说它是 Think 的一种特别的过去式（类似于 drink > 
drunk），有人说这个词来源于早期计算机在运算时所发出的声音，也有人说它就是
“THe-fUNCtion”的缩写。不管怎样，大家只要知道 Thunk 就是用来实现某些特别的函
数调用和执行转移而设计的一小段代码。下面我们先分别介绍几种常见的 Thunk，然后介
绍描述 Thunk 的符号。 
25.13.1  DLL 技术中的 Thunk 
Thunk 的一种典型应用就是在动态连接库（Dynamic Link Library，DLL）技术中实现
动态绑定和跨模块调用。让我们通过一个例子来理解 DLL 技术的简要原理和 Thunk 在其
中的作用。 
在使用了 MessageBox API 的 HiWorld 程序中，我们可以看到如下代码： 
0:001> u HiWorld!MessageBoxW 
HiWorld!MessageBoxW: 
00412538 ff2500b44100    jmp     dword ptr [HiWorld!_imp__MessageBoxW (0041b400)] 
其中的 HiWorld!_imp__MessageBoxW 可以理解成是一个全局变量，使用 dd 命令可以观
察到它的值： 
0:001> dd HiWorld!_imp__MessageBoxW l1 
0041b400  77d9610a 
使用 ln 命令可以看到 77d9610a 是 User32.DLL 中的 MessageBoxW 函数的地址： 
0:001> ln 77d9610a 
(77d9610a)   USER32!MessageBoxW   |  (77d96158)   USER32!SetSysColors 
位于 HiWorld 中的 MessageBoxW 是一个典型的 Thunk，它的作用是跳转到全局变量
HiWorld!_imp__MessageBoxW 所指定的地址。 
25.13.2  实现不同字长模块间调用的 Thunk 
Thunk 的另一种典型应用就是在不同字长的模块间进行函数调用以完成翻译和转换
任务。例如在 Windows 9x 中，为了支持旧的 16 位软件，系统允许从 32 位的应用程序（EXE）
中调用 16 位模块（DLL）中的函数。但因为 32 位代码使用的数据类型和寄存器与 16 位
代码有很大差异，所以在调用前，必须将函数参数翻译为 16 位代码所使用的数据类型，
然后将线程的栈切换为供 16 位代码所使用的栈，当函数返回时，再将 16 位函数的返回值
翻译成 32 位。为了简化这一过程，Windows 9x 设计了一种称为 Flat Thunk 的机制，使用
一对 DLL（一个 32 位，一个 16 位）来执行从 32 位代码到 16 位代码的函数调用，并且提
供了一个专门的编译工具（Thunk Compiler）来帮助生成这对 DLL。主要步骤是先使用这
个工具根据 Thunk 脚本产生合适的汇编代码，然后使用汇编编译器（ml.exe）将汇编代码
分别编译成 16 位和 32 位的目标文件（obj），最后再分别生成 16 位和 32 位的 DLL。在这
两个 DLL 中用来做翻译和转换工作的代码，便被称为 Thunk。今天的 Windows 操作系统
已经不再支持 16 位的模块，因此 Flat Thunk 技术已经过时，只有个别的 API（例如
ThunkConnect32）还残留在 MSDN 中。 
《软件调试》补编 
- 53 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
25.13.3  启动线程的 Thunk 
在 kernel32.dll 中我们可以看到一段名为 BaseProcessStartThunk 的代码，其汇编指令
如下： 
0:001> u kernel32!BaseProcessStartThunk 
kernel32!BaseProcessStartThunk: 
7c810665 33ed            
xor     ebp,ebp 
7c810667 50              
push    eax 
7c810668 6a00           
push    0 
7c81066a e945690000     
jmp     kernel32!BaseProcessStart (7c816fb4) 
这段代码将 EBP 寄存器清 0，然后向栈中压入两个参数，便无条件地跳转到
BaseProcessStart 函数（永远不会再返回到这段代码）。事实上，这段代码就是每个进
程的初始线程开始在用户态执行的起点。其中 EAX 的值是进程的启动函数地址，即登记
在 PE 文件头结构中的入口地址。BaseProcessStartThunk 是一个典型的 Thunk，它做一点
简单的操作后便跳转到真正执行任务的目标函数。那么为什么要使用这个 Thunk 呢？因为
系统在创建进程的初始线程时，是不方便向线程的栈中压入内容的，所以便只是将进程的
启动函数放入到线程上下文结构（CONTEXT）的 EAX 寄存器中，这样，当用户线程开
始执行时，便需要一段简单代码来调用使用栈来接收参数的 BaseProcessStart 函数。当
然，这段代码的另一个作用就是将 EBP 寄存器清零，这为回溯栈帧设置了一个很好的终
结点。例如，我们在调试器中显示线程的栈回溯信息时，其最后一个栈帧指针的内容总是
0。 
0012ffc0 7c816fd7 01a3f6f0 0000008c 7ffd8000 HiWorld!wWinMainCRTStartup+0xd  
0012fff0 00000000 0041128f 00000000 78746341 kernel32!BaseProcessStart+0x23 
0:000> dd 0012fff0 l1 
// 显示最末栈帧基地址处的值 
0012fff0  00000000 
// 0 代表这是线程的最后一个栈帧 
与 BaseProcessStartThunk 类似的还有 BaseThreadStartThunk，它将 EBP 寄存器清零并
将 EBX、EAX 和 0 压入到栈中后便跳转到 BaseThreadStart 函数。 
25.13.4  Thunk 分类 
在 NTDLL.DLL 中，我们也可以看到 Thunk 代码，比如 LdrInitializeThunk（目标函数
为 LdrInitialize），在 ATL 中也使用了 Thunk，因为篇幅关系，我们不一一叙述。DIA SDK
中的 THUNK_ORDINAL 枚举类型将 Thunk 归纳为表 25-31 所列出的 7 种类型。 
表 25-31  Thunk 分类 
常量 
值 
说明 
THUNK_ORDINAL_NOTYPE 
0 
普通的 Thunk 
THUNK_ORDINAL_ADJUSTOR 
1 
用于调整 this 指针的 Thunk 
THUNK_ORDINAL_VCALL 
2 
用于调用虚函数的 Thunk 
THUNK_ORDINAL_PCODE 
3 
用于调用 P-Code 的 Thunk 
THUNK_ORDINAL_LOAD 
4 
加载地址并跳转到这个地址 
THUNK_ORDINAL_TRAMP_INCREMENTAL 
5 
增量性的 Trampoline Thunk 
THUNK_ORDINAL_TRAMP_BRANCHISLAND 
6 
分支性的 Trampoline Thunk 
其中 P-Code 是 Packed Code 的缩写，它是一种比.NET 技术更早的中间代码技术。其
基本思想是通过使用中间代码（P-Code）来缩减可执行文件的大小，当执行时，链接到可
执行文件中的一个小的引擎将 P-Code 解释为机器码来执行。VB 支持将程序编译为
P-Code。 
Trampoline Thunk 用于将函数调用从一个空间弹到另一个空间，比如从内核空间到用
户空间或反之。 
《软件调试》补编 
- 54 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
25.13.5  Thunk 符号 
Thunk 符号（SymTagThunk[27]）用来描述程序中的 Thunk。表 25-32 列出了用来描述
我们前面介绍的 HiWorld!MessageBoxW 的 Thunk 符号的各种属性。 
表 25-32  Thunk 符号示例 
属性 
值 
说明 
get_addressOffset 
0x1538 
Thunk 的地址偏移 
get_addressSection 
2 
Thunk 的节地址 
get_length 
0x6 
Thunk 的代码长度，6 个字节 
get_lexicalParentId 
449 
父词条 ID，代表的是 User32.DLL 
get_locationType 
static[1] 
位置类型 
get_name 
MessageBoxW 
名称 
get_relativeVirtualAddress 
0x12538 
Thunk 的 RVA 
get_thunkOrdinal 
standard thunk[0] 
Thunk 类型 
get_virtualAddress 
0x12538 
Thunk 过程的虚拟地址 
从 PDB 的编纂结构角度来讲，Thunk 符号是 Compiland 符号的子符号。比如，表 25-32
所描述的 MessageBoxW 符号的父词条 ID（449）代表的是描述 User32.DLL 的 Compiland
符号。 
《软件调试》补编 
- 55 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
补编内容
补编内容
补编内容
补编内容 6 调试器标准
调试器标准
调试器标准
调试器标准 
补编说明： 
这一节本来属于《软件调试》第 28 章的最后一节，讲的是 Java 调试器的标
准。 
《软件调试》的出发点是写软件调试的一般原理的，但是为了不流于空泛，
始终是选择真实的产品（软件和硬件）为例来讲的。但是因为众所周知的事
实，无论是 CPU 还是核心软件，如果只在主流的产品中选择，那么选择的余
地很有限。 
我在多年前做过几年的 Java 开发，对 Java 还算熟悉，于是写作了这一内容，
写作时很觉得这一内容巩固调试器原理和了解 Java 都听不错。特别是可以证
明，原理是相通的，不论是 Java 调试器，还是 C/C++调试器，它们内部其实
很像。 
在最后一轮压缩篇幅时，这一节被删除了，主要原因是这一内容是属于“锦
上添花（姑且用这个词吧）”类型，删除后也不会影响整个内容的完整性。 
28.9  JPDA 标准 
Java 是一种流行的动态语言，使用 Java 语言开发的程序先编译为字节码，然后由 Java
虚拟机（JVM）按照 JIT 编译的方式来执行。Java 程序可以在各种装有 Java 运行环境（Java 
Runtine）的系统中运行，具有非常好的跨平台特征，因此被广泛应用到企业应用、网络服
务、网站开发、移动和嵌入式设备等领域。本节我们介绍用于调试 Java 程序的调试器标
准——JPDA。我们介绍的版本是 Java SE 6。 
28.9.1  JPDA 概貌 
JPDA 的全称是 Java 平台调试器架构（Java Platform Debugger Architecture），它由图
28-13 所示的 3 个部分组成，即： 
1. 
Java 调试器接口（Java Debug Interface），简称 JDI，这是一套供调试器或者性能分析
工具使用的 Java API，用来访问目标程序的内部状态和调用 Java 虚拟机的各种调试功
能。JDI 工作在调试器进程中，负责与调试器的其他部分进行交互。 
2. 
Java 虚拟机工具接口（JVM Tool Interface），简称 JVM TI，它是 JVM 对外提供调试
服务的标准接口，它工作在被调试的 Java 进程中，负责与 Java 虚拟机进行交互收集
《软件调试》补编 
- 56 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
调试信息并接收和处理来自 JDI 的命令请求。 
3. 
Java Debug Wire Protocol ，简称 JDWP，这是 JVM TI 与 JDI 之间进行通信的协议，
二者通过这个协议交换信息。 
图 28-13  Java 平台调试器架构（JPDA） 
从用户的角度来看，位于调试器进程中的部分（包括 JDI）常被称为前端（Front End），
被调试器进程中负责支持调试器前端工作的部分常被称为后端（Back End）。下面我们对
以上 3 个部分进行分别介绍。 
28.9.2  JDI 
JDI 是一套纯粹的 Java API 库，用来简化使用 Java 语言来开发 Java 调试器，它封装
了通过 JDWP 与 JVM TI 通信的过程，使得调试器开发者只要调用这些简单易用的 Java API
就能开发出强大的调试器。尽管调试器开发者可以直接使用 JDWP 或 JVM TI，但是使用
JDI 是推荐的方法。JDI 它主要包含表 28-7 所列出的一些 Java 包（package）。 
表 28-7  JDI 的各个包 
包名 
功能 
com.sun.jdi 
JDI 的核心包，定义了位于目标进程内的类型、数据和虚拟机本身