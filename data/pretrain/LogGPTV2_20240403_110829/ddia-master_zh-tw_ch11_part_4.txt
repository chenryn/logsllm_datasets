如果消费者远远落后，而所要求的资讯比保留在磁碟上的资讯还要旧，那么它将不能读取这些资讯，所以代理实际上丢弃了比缓冲区容量更大的旧资讯。你可以监控消费者落后日志头部的距离，如果落后太多就发出报警。由于缓冲区很大，因而有足够的时间让运维人员来修复慢消费者，并在讯息开始丢失之前让其赶上。
即使消费者真的落后太多开始丢失讯息，也只有那个消费者受到影响；它不会中断其他消费者的服务。这是一个巨大的运维优势：你可以实验性地消费生产日志，以进行开发，测试或除错，而不必担心会中断生产服务。当消费者关闭或崩溃时，会停止消耗资源，唯一剩下的只有消费者偏移量。
这种行为也与传统的讯息代理形成了鲜明对比，在那种情况下，你需要小心地删除那些消费者已经关闭的伫列 —— 否则那些伫列就会累积不必要的讯息，从其他仍活跃的消费者那里占走记忆体。
#### 重播旧讯息
我们之前提到，使用 AMQP 和 JMS 风格的讯息代理，处理和确认讯息是一个破坏性的操作，因为它会导致讯息在代理上被删除。另一方面，在基于日志的讯息代理中，使用讯息更像是从档案中读取资料：这是只读操作，不会更改日志。
除了消费者的任何输出之外，处理的唯一副作用是消费者偏移量的前进。但偏移量是在消费者的控制之下的，所以如果需要的话可以很容易地操纵：例如你可以用昨天的偏移量跑一个消费者副本，并将输出写到不同的位置，以便重新处理最近一天的讯息。你可以使用各种不同的处理程式码重复任意次。
这一方面使得基于日志的讯息传递更像上一章的批处理，其中衍生资料透过可重复的转换过程与输入资料显式分离。它允许进行更多的实验，更容易从错误和漏洞中恢复，使其成为在组织内整合资料流的良好工具【24】。
## 资料库与流
我们已经在讯息代理和资料库之间进行了一些比较。尽管传统上它们被视为单独的工具类别，但是我们看到基于日志的讯息代理已经成功地从资料库中获取灵感并将其应用于讯息传递。我们也可以反过来：从讯息传递和流中获取灵感，并将它们应用于资料库。
我们之前曾经说过，事件是某个时刻发生的事情的记录。发生的事情可能是使用者操作（例如键入搜寻查询）或读取感测器，但也可能是 **写入资料库**。某些东西被写入资料库的事实是可以被捕获、储存和处理的事件。这一观察结果表明，资料库和资料流之间的联络不仅仅是磁碟日志的物理储存 —— 而是更深层的联络。
事实上，复制日志（请参阅 “[复制日志的实现](ch5.md#复制日志的实现)”）是一个由资料库写入事件组成的流，由主库在处理事务时生成。从库将写入流应用到它们自己的资料库副本，从而最终得到相同资料的精确副本。复制日志中的事件描述发生的资料更改。
我们还在 “[全序广播](ch9.md#全序广播)” 中遇到了状态机复制原理，其中指出：如果每个事件代表对资料库的写入，并且每个副本按相同的顺序处理相同的事件，则副本将达到相同的最终状态 （假设事件处理是一个确定性的操作）。这是事件流的又一种场景！
在本节中，我们将首先看看异构资料系统中出现的一个问题，然后探讨如何透过将事件流的想法带入资料库来解决这个问题。
### 保持系统同步
正如我们在本书中所看到的，没有一个系统能够满足所有的资料储存、查询和处理需求。在实践中，大多数重要应用都需要组合使用几种不同的技术来满足所有的需求：例如，使用 OLTP 资料库来为使用者请求提供服务，使用快取来加速常见请求，使用全文索引来处理搜寻查询，使用资料仓库用于分析。每一种技术都有自己的资料副本，并根据自己的目的进行储存方式的最佳化。
由于相同或相关的资料出现在了不同的地方，因此相互间需要保持同步：如果某个专案在资料库中被更新，它也应当在快取、搜寻索引和资料仓库中被更新。对于资料仓库，这种同步通常由 ETL 程序执行（请参阅 “[资料仓库](ch3.md#资料仓库)”），通常是先取得资料库的完整副本，然后执行转换，并批次载入到资料仓库中 —— 换句话说，批处理。我们在 “[批处理工作流的输出](ch10.md#批处理工作流的输出)” 中同样看到了如何使用批处理建立搜寻索引、推荐系统和其他衍生资料系统。
如果周期性的完整资料库转储过于缓慢，有时会使用的替代方法是 **双写（dual write）**，其中应用程式码在资料变更时明确写入每个系统：例如，首先写入资料库，然后更新搜寻索引，然后使快取项失效（甚至同时执行这些写入）。
但是，双写有一些严重的问题，其中一个是竞争条件，如 [图 11-4](../img/fig11-4.png) 所示。在这个例子中，两个客户端同时想要更新一个专案 X：客户端 1 想要将值设定为 A，客户端 2 想要将其设定为 B。两个客户端首先将新值写入资料库，然后将其写入到搜寻索引。因为运气不好，这些请求的时序是交错的：资料库首先看到来自客户端 1 的写入将值设定为 A，然后来自客户端 2 的写入将值设定为 B，因此资料库中的最终值为 B。搜寻索引首先看到来自客户端 2 的写入，然后是客户端 1 的写入，所以搜寻索引中的最终值是 A。即使没发生错误，这两个系统现在也永久地不一致了。
![](../img/fig11-4.png)
**图 11-4 在资料库中 X 首先被设定为 A，然后被设定为 B，而在搜寻索引处，写入以相反的顺序到达**
除非有一些额外的并发检测机制，例如我们在 “[检测并发写入](ch5.md#检测并发写入)” 中讨论的版本向量，否则你甚至不会意识到发生了并发写入 —— 一个值将简单地以无提示方式覆盖另一个值。
双重写入的另一个问题是，其中一个写入可能会失败，而另一个成功。这是一个容错问题，而不是一个并发问题，但也会造成两个系统互相不一致的结果。确保它们要么都成功要么都失败，是原子提交问题的一个例子，解决这个问题的代价是昂贵的（请参阅 “[原子提交与两阶段提交](ch9.md#原子提交与两阶段提交)”）。
如果你只有一个单领导者复制的资料库，那么这个领导者决定了写入顺序，而状态机复制方法可以在资料库副本上工作。然而，在 [图 11-4](../img/fig11-4.png) 中，没有单个主库：资料库可能有一个领导者，搜寻索引也可能有一个领导者，但是两者都不追随对方，所以可能会发生冲突（请参阅 “[多主复制](ch5.md#多主复制)”）。
如果实际上只有一个领导者 —— 例如，资料库 —— 而且我们能让搜寻索引成为资料库的追随者，情况要好得多。但这在实践中可能吗？
### 变更资料捕获
大多数资料库的复制日志的问题在于，它们一直被当做资料库的内部实现细节，而不是公开的 API。客户端应该透过其资料模型和查询语言来查询资料库，而不是解析复制日志并尝试从中提取资料。
数十年来，许多资料库根本没有记录在档的获取变更日志的方式。由于这个原因，捕获资料库中所有的变更，然后将其复制到其他储存技术（搜寻索引、快取或资料仓库）中是相当困难的。
最近，人们对 **变更资料捕获（change data capture, CDC）** 越来越感兴趣，这是一种观察写入资料库的所有资料变更，并将其提取并转换为可以复制到其他系统中的形式的过程。CDC 是非常有意思的，尤其是当变更能在被写入后立刻用于流时。
例如，你可以捕获资料库中的变更，并不断将相同的变更应用至搜寻索引。如果变更日志以相同的顺序应用，则可以预期搜寻索引中的资料与资料库中的资料是匹配的。搜寻索引和任何其他衍生资料系统只是变更流的消费者，如 [图 11-5](../img/fig11-5.png) 所示。
![](../img/fig11-5.png)
**图 11-5 将资料按顺序写入一个数据库，然后按照相同的顺序将这些更改应用到其他系统**