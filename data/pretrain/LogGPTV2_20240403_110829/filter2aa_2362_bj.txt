over and over again. Some fuzz-file databases can contain tens of millions of tests
(files) that can be used for testing against various versions of software. The more
advanced file fuzzing techniques are based on automatic file specification engines.
These engines will automatically reverse-engineer the file structure and deploy fuzz
tests to the structure. For example, the PROTOS Genome10 project (ongoing since
2001) has used the same algorithms that are used to reverse-engineer structures in
the human genome to map common structures and understand the logic inside.
When conducting file fuzzing, you first need to analyze which file formats are
parsed by the application you wish to test. For example, a standard web browser,
9.3
Application Developer Fuzzing
259
8There have been other testing tools that have attempted to crash the SUT with various inputs,
but the Fuzz project was probably the first in which the intention was to find security vulnerabil-
ities and not just quality errors.
9A SUID bit in the file system will tell the operating system to launch the program with other
privileges, typically those of a system administrator.
10www.ee.oulu.fi/research/ouspg/protos/genome
such as Internet Explorer, can easily support many different image formats and
their variants. A full coverage of tests with file fuzzing can be laborious, and there-
fore a pregenerated suite of tests might give a good starting point for fuzzing. The
greatest challenge with file fuzzing, at least for QA people, is deciding when to stop
fuzzing.
For an interesting case study, consider the work done fuzzing libpng, an open
source PNG image decoder.11 Libpng is the decoder used by many common appli-
cations such as Firefox, Opera, and Safari. In this case, we began fuzzing this library
by using a mutation-based approach and monitoring the number of lines executed.
In other words, a particular PNG was obtained from the Internet and 100,000
fuzzed PNGs were created by randomly changing bytes in the original file. Using
these files, approximately 10.7% of the library was executed. Next, in order to get
a feel for how important the choice of initial PNG was to this particular case of
mutation-based fuzzing, the same procedure was repeated starting from four other
different PNGs. In other words, for 5 distinct PNGs, 100,000 fuzzed PNGs were
created for each of the 5 initial files. Again, code coverage was monitored during
testing. It turns out that the choice of initial input to a mutation-based fuzzer is very
important, as Table 9.2 indicates.
Thus, it is important when fuzzing with a mutation-based approach to always
use a variety of initial files (or in general inputs) in order to mutate, because in this
small sample, some files obtained almost 50% more code coverage than others
when used as an initial file. Likewise, if you compute the code coverage from all
500,000 of the PNGs, you obtain code coverage of 17.4%, which is better than any
one of the files by itself. In other words, some of the PNGs exercise certain portions
of the code while other PNGs may exercise other portions of the code. No matter
how many bytes you change randomly, you will never duplicate the structure found
in different PNGs in a reasonable amount of time starting from one file.
Finally, we took libpng and fuzzed it using a generational-based approach with
SPIKEfile. This required writing out a complete specification for the PNG file for-
mat and intelligently fuzzing each particular field of the format. This required many
hours of labor to produce 30,000 fuzzed PNGs. However, the benefit was clear, as
25.5% code coverage was obtained by these 30,000 files. By consulting the results
of the mutation-based fuzzing, this is roughly twice the code coverage that you
would typically find with mutation-based fuzzing. Throughout all of this testing of
libpng, no crashes were observed, although deep monitoring was not conducted.
260
Fuzzing Case Studies
Table 9.2
Code Coverage Obtained with a Mutation-Based Fuzzer for Five Different Initial
“Good” Inputs
PNG 1
PNG 2
PNG 3
PNG 4
PNG 5
Code coverage
10.7%
14.9%
13.7%
12.5%
10.5%
11www.defcon.org/html/defcon-15/dc-15-speakers.html#Miller
9.3.3
Web Application Fuzzing
In web application fuzzing, the fuzzer will simulate a browser that will respond to
the web application using many malicious inputs into all the form fields, cookies,
URLs, and so on. Furthermore, it will ignore all possible input validation performed
in the client, such as that done with JavaScript. Of course, input validation should
always be performed on the server side, even if a legal user would be restricted from
inputting whatever they pleased in the standard user interface.
The main reason why web fuzzing is such a popular area of fuzzing is because
of the diverse developer community creating web applications. Almost every web
designer knows some scripting languages and will happily implement a server-side
script that receives input from a web browser. Those web applications can be quite
complex, and almost always tailored to each user.
Web application fuzzing happens in several different layers. Most web fuzzing
tools only test the highest layer, and only with simple request-response test cases,
apparently going for the low-hanging fruit. Others “spider” through a website
looking for individual targets, such as web forms, and then test each of these auto-
matically with all visible parameters. Some tools can even benefit from reading in
the server-side source code and also testing those parameters that are left in the
scripts from older releases but are not visible in the public web form.
But, real-life web fuzzing can be much more complex than these examples. A
complex business application may contain a complicated state machine, and there-
fore each web application test case can consist of a sequence of messages. For exam-
ple, an automated fuzz test against an e-commerce portal could include the
preamble of logging in, then adding items to a shopping basket, activating the pur-
chase, and then logging out. Web fuzzing is actually an interesting target for model-
based fuzzing, and numerous security consultants using most available fuzzing
frameworks have already conducted such tests.
When the use case or template for fuzzing is defined, or the model is built, the
fuzzers will then automatically input anomalies into various parts of the inputs.
Most web fuzzing tools test through a predefined set of inputs for each parameter
in the web forms. More advanced fuzzers will also enable the user to define sub-
structure for the parameters. The goal is to try inputs that would be passed through
the web application and into a middleware component, operating system com-
mand, or a database. Therefore, the inputs are almost always targeted against spe-
cific implementations. A set of test cases targeted to a specific variant of database
query language (such as the many variants of SQL) will probably not trigger a fail-
ure when some other database is used in the server. Similarly, if the web server is
running on a proprietary operating system, then tests that target Unix-based shell
commands would be doomed to fail.
Web 2.0 increases the complexity of web fuzzing significantly, and makes it
even harder for standard off-the-shelf fuzzing tools to succeed due to the increased
proprietary communication interfaces between the browser and the server(s).12
9.3
Application Developer Fuzzing
261
12Alex Stamos and Zane Lackey. “Attacking AJAX Web Applications,” Presentation at Black
Hat USA 2007 conference. Las Vegas, NV. (July/August 2007)
Example attack vectors include
• HTTP headers;
• Transport protocols such as IP, TCP, SSL, and TLS;
• Database query languages: SQL;
• Execution flaws (scripting language specific);
• Web 2.0 remote procedure calls and streams such as SOAP and XML-RPC;
• XML XPath and XQuery;
• HTML content: Cross-Site Scripting (XSS);
• LDAP;
• Flash;
• Java Remoting;
• E-mail, and any other application protocol launched by a web application.
Both free and commercial web testing tools are numerous, and a well-maintained
list is available from, for example, the OWASP portal.13
9.3.4
Browser Fuzzing
Web browser fuzzing is not really that interesting, unless you are developing your
own browser or an extension to a browser. The reason is that there are only a hand-
ful of browser implementations used by consumers. Then again, this is exactly why
it makes a good target for security researchers. A set of 0-day flaws found in a
widely used browser can result in a devastating attack tool, with the capability to
infect every customer that browses to a malicious site.
Browsers are the easiest fuzzing targets to set up, and you will never run out of
tests that you can run against them because they support almost everything that
most users are familiar with. Browsers can also be used to trigger a variety of local
applications on the host, such as PDF readers and office document viewers.
Some example attack vectors against browsers include
• HTTP;
• HTML;
• Java and JavaScript (including fuzzing against the Java runtime);
• ActiveX (and all the available COM objects in Windows);
• XML and SOAP;
• Ajax XML, Java scripts and script arrays;
• JSON (e.g., Java script arrays);
• Flash;
• Images: gif, jpeg, png, and many others;
• Video: avi, mov, mpeg-variants, and many others;
• Audio: wav, mpeg-variants, streaming protocols, and many others.
262
Fuzzing Case Studies
13www.owasp.org/index.php/Appendix_A:_Testing_Tools
Browsers are also probably one of the simplest applications to instrument. This
is because they run as stand-alone applications. It is extremely easy to build a sim-
ple script that will automatically start and kill the browser, requesting a new test
case every time it is launched. You can also use HTTP features such as the “META
REFRESH” tag to automatically refresh the page where the browser obtains its
test cases.
In short, you should test any application that acts as a web browser, or any
application that is launched by a web browser, with all available fuzzing tools. You
can find tens of freely available browser fuzzing tools in any search engine with the
keywords “browser fuzzing.” For example, “Mangle” was a famous HTML fuzzer
that found many bugs in Internet Explorer, and JSFunFuzz is a JavaScript Fuzzer.
Some commercial network protocol fuzzing companies also support web browser
fuzzing.
9.4
Network Equipment Manufacturer Fuzzing
Fuzzing is especially important to network equipment manufacturers, due to the
difficulty of deploying updates to the devices after their release. For example, Cisco
Systems has explained how fuzzing is a key part of their software development life
cycle.14
9.4.1
Network Switch Fuzzing
A network switch or a router is a critical device in all network deployments. These
devices come in varying sizes and configurations and often run some real-time oper-
ating systems such as Windriver or QNX. This can be a challenge for on-device
monitoring and instrumentation. Interfaces that can be fuzzed include router pro-
tocols, IP services, and various proxy components. Many home routers also have
application-level gateways and anti-virus systems built into the device.
Router protocols include
• BGP;
• OSPF;
• IS-IS;
• PIM-SM/DM;
• GRE;
• DVMRP;
• RSVP;
• VRRP;
• RIP;
• MPLS/LDP.
9.4
Network Equipment Manufacturer Fuzzing
263
14 Ari Takanen and Damir Rajnovic. “Robustness Testing to Proactively Remove Security Flaws
with a Cisco Case Study.” October 26, 2005. Silicon Valley Software Process Improvement Net-
work (SV-SPIN). www.svspin.org/Events/2005/event20051026.htm
9.4.2
Mobile Phone Fuzzing
Mobile phone fuzzing, especially against smartphones, is very much like fuzzing
against a typical desktop workstation. The specialty with smartphones is that the
failure mode can be devastating—i.e., total corruption of the handset flash-memory,
requiring reprogramming of the flash memory to fix the operation. Fuzzing can
result in corruption of the SIM card beyond repair—for example, when fuzzing is
conducted over Bluetooth SIM access Profile (SAP).
The biggest challenge is that most widely used mobile phones run on special
operating systems such as Symbian, which does not allow much debugging of the
application after it has been launched. The Symbian SDK, on the other hand, is a
very interesting environment for fuzzing specialists. Since some of the earliest
releases, the Symbian SDK has allowed someone to run Symbian applications on
top of standard workstation operating systems and allowed him or her to “fuzz”
them at the API layer. The Symbian (it was earlier called Epoc) development envi-
ronment will simulate random failures in the API return values, such as telling the
application that it is now out of memory, and so on.
Mobile phones come with a number of open interfaces. We would not be sur-
prised to see a web server on a mobile phone, as some messaging techniques actu-
ally use HTTP to transfer files between smartphones.
But, the most interesting interfaces and applications to fuzz in mobile phones
are the following:
• Wireless (Bluetooth, WiFi and WiMAX).
• Web browser (HTTP itself and all related interfaces mentioned earlier in
browser fuzzing).
• E-mail client (SMTP client, POP, IMAP4).
• VoIP client (SIP, RTP, TLS client).
• Instant messaging (SMS, MMS).
• Media formats (images, audio, video).
• Calendar data (vCal, iCal, vCard).
One of the authors of this text found a vulnerability in the web browser in
Apple’s iPhone by using fuzzing techniques.15
Bluetooth is a special challenge in mobile phones due to the complex protocol
stack. Several Bluetooth interfaces are open to attack without any user acknowl-
edgment. Examples of such interfaces include Bluetooth/LCAP and Bluetooth/SDP.
Typically, low-level tests will break the stack itself, but high-level fuzzing of the
Bluetooth profiles will break the applications running above the stack.
Mobile phones can be tested through a range of different injection vectors (Fig-
ure 9.5). Active attacks push the fuzzed messages to the phone, requiring no action
by the user. Active fuzzing typically consists of testing the request messages or ini-
tiating messages on the SUT. Sometimes active fuzzing can also test interfaces that
require no action on the SUT but are automatically requested by the device itself.
On the other hand, passive attacks require test automation on the mobile phone to
264
Fuzzing Case Studies
15www.nytimes.com/2007/07/23/technology/23iphone.html
fetch each fuzzed test case. An example of this is testing web clients or e-mail clients
on the smartphone. This setup can pose problems, especially when a test case causes
a crash and the device will fetch the same test case each time from the cellular infra-
structure. This happens often in SMS fuzzing, which can be set up as both active
and passive fuzzing. The offending test message is typically not deleted from the
messaging server before the handset crashes, and therefore other means must exist
to skip over that test to be able to automatically continue the test execution.
9.5
Industrial Automation Fuzzing
At the present time, most industrial control system equipment and software manu-
facturers are limited in their ability to rigorously test new products for possible
security flaws. As a result, new vulnerabilities are discovered each year, but only
after the products are sold and installed by the end user. This is particularly true for
the control and SCADA systems used in critical infrastructures such as oil and gas,
water, and electrical generation/distribution industries since standard information
technology (IT) vulnerability testing does not typically address the unique resource
and timing constraints of critical systems.16
To help provide a solution, the Achilles Vulnerability Assessment Project was
launched by the British Columbia Institute of Technology (BCIT) in the summer of
9.5
Industrial Automation Fuzzing
265
Figure 9.5
Test environment for fuzzing mobile phones.
16The entire section on SCADA fuzzing is based on personal communications with Dr. Nate Kube
from Wurldtech, the leading SCADA fuzzing company from Canada.
2003.17 The intent was to create a test platform that would eventually allow con-
trol system vendors and end users to systematically stress-test critical equipment
and software for both known and unknown security vulnerabilities prior to market
release or field deployment.
SCADA fuzzing is different from other use scenarios in two perspectives. The
legacy SCADA systems were built on complex infrastructures involving serial (for
example, RS323, JTAG, USB) and potentially some proprietary parallel buses.
Today, most of these interfaces have been adapted into Ethernet-based technolo-
gies, and that has introduced a family of new protocols such as:
• Modbus/TCP;
• ModbusPLUS;
• Vnet/IP;
• Ethernet/IP;
• Profinet;
• MMS (Manufacturing Message Specification).
The fuzz traffic generation is similar to any other fuzzer, but the models used
will require some rethinking due to the master-slave relationships used in SCADA.
Very few SCADA protocols use the client-server architecture. Determining the
extent of the malady is of greatest import. Therefore, the monitoring of key device
functionalities becomes the paramount issue. To achieve this, the SCADA fuzzing
frameworks divide the control functionality into three discrete areas:
• Ethernet communications processing.
• Logic processing.
• I/O processing.
Each of these areas is monitored separately to accurately quantify a SUT’s
response to testing stimulus. Monitor data is used as a part of determining the
severity metric if a failure is detected.
Key challenges in SCADA fuzzing include
• Diversity in protocol implementations (optional and vendor extensions);
• Ambiguity in protocol implementation;
• Access to test equipment;
• Complexity in configuration of systems and test beds;
• Simulations with and without loaded behavior;
• Gray box access to SUT;
• Multi-way redundancy in SUT;
• Fail-over behavior of SUT;
266
Fuzzing Case Studies
17The Achilles project was a success and Wurldtech Security Technologies emerged as the leading
provider of security solutions to SCADA, process control, and mission-critical industries, and the
first company to offer a comprehensive suite of products and services designed specifically to pro-
tect the systems and networks that operate the foundation of the world’s critical infrastructure.
• Performance constraints because some devices are very slow;
• Accounting for watchdogs, fail-safe modes, communication fail-over, etc.
The various storm-based test cases included in the Achilles fuzzer suite were
developed in response to lab and field testing as well as reported failures in the field
that found that high volumes of regular or unusual packets often caused opera-
tional discontinuity (for example, hard-faulted devices, loss of communication for
extended periods after a storm has ceased, tripped safety systems). They are also
used to discover and validate functional constraints of the device under test (such
as maximum packet per second rates before being DoS’ed). This allows other tests
to ensure they deliver valid results and prevent false positives or can be used to force
a device to fault and reset, providing access to device states that only occur during
startup. These states can contain information like log-in sequences or database down-
loads, that can provide a huge amount of valuable information.
The traffic generated by each type of storm has a structurally correct header for
the protocol being tested with a random payload. Different failure patterns were
identified depending on how well structured the packet was (i.e., how many protocol
headers were structurally valid) and that one of the primary causes of fault was