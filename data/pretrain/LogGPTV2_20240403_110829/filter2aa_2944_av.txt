token ID. You shouldn’t use a normal database sequence for this, because token IDs
Alternative token storage databases
Although the SQL database storage used in this chapter is adequate for demonstration
purposes and low-traffic APIs, a relational database may not be a perfect choice for all
deployments. Authentication tokens are validated on every request, so the cost of a
database transaction for every lookup can soon add up. On the other hand, tokens are
usually extremely simple in structure, so they don’t need a complicated database
schema or sophisticated integrity constraints. At the same time, token state rarely
changes after a token has been issued, and a fresh token should be generated when-
ever any security-sensitive attributes change to avoid session fixation attacks. This
means that many uses of tokens are also largely unaffected by consistency worries. 
For these reasons, many production implementations of token storage opt for non-
relational database backends, such as the Redis in-memory key-value store (https://
redis.io), or a NoSQL JSON store that emphasizes speed and availability.
Whichever database backend you choose, you should ensure that it respects consis-
tency in one crucial aspect: token deletion. If a token is deleted due to a suspected
security breach, it should not come back to life later due to a glitch in the database.
The Jepsen project (https://jepsen.io/analyses) provides detailed analysis and test-
ing of the consistency properties of many databases.
Listing 5.2
The token database schema
Link the token to 
the ID of the user.
Store the attributes 
as a JSON string.
Grant permissions to the Natter database user.
157
Tokens without cookies
must be unguessable for an attacker. Otherwise an attacker can simply wait for
another user to login and then guess the ID of their token to hijack their session. IDs
generated by database sequences tend to be extremely predictable, often just a simple
incrementing integer value. To be secure, a token ID should be generated with a high
degree of entropy from a cryptographically-secure random number generator (RNG). In
Java, this means the random data should come from a SecureRandom object. In other
languages you should read the data from /dev/urandom (on Linux) or from an
appropriate operating system call such as getrandom(2) on Linux or RtlGenRandom()
on Windows.
DEFINITION
In information security, entropy is a measure of how likely it is that
a random variable has a given value. When a variable is said to have 128 bits of
entropy, that means that there is a 1 in 2128 chance of it having one specific
value rather than any other value. The more entropy a variable has, the more
difficult it is to guess what value it has. For long-lived values that should be un-
guessable by an adversary with access to large amounts of computing power,
an entropy of 128 bits is a secure minimum. If your API issues a very large
number of tokens with long expiry times, then you should consider a higher
entropy of 160 bits or more. For short-lived tokens and an API with rate-limiting
on token validation requests, you could reduce the entropy to reduce the token
size, but this is rarely worth it.
What if I run out of entropy?
It is a persistent myth that operating systems can somehow run out of entropy if you
read too much from the random device. This often leads developers to come up with
elaborate and unnecessary workarounds. In the worst cases, these workarounds
dramatically reduce the entropy, making token IDs predictable. Generating cryp-
tographically-secure random data is a complex topic and not something you should
attempt to do yourself. Once the operating system has gathered around 256 bits of
random data, from interrupt timings and other low-level observations of the system,
it can happily generate strongly unpredictable data until the heat death of the uni-
verse. There are two general exceptions to this rule:
 When the operating system first starts, it may not have gathered enough
entropy and so values may be temporarily predictable. This is generally only a
concern to kernel-level services that run very early in the boot sequence. The
Linux getrandom() system call will block in this case until the OS has gath-
ered enough entropy.
 When a virtual machine is repeatedly resumed from a snapshot it will have
identical internal state until the OS re-seeds the random data generator. In
some cases, this may result in identical or very similar output from the ran-
dom device for a short time. While a genuine problem, you are unlikely to do
a better job than the OS at detecting or handling this situation.
In short, trust the OS because most OS random data generators are well-designed
and do a good job of generating unpredictable output. You should avoid the /dev/
158
CHAPTER 5
Modern token-based authentication
For Natter, you’ll use 160-bit token IDs generated with a SecureRandom object. First,
generate 20 bytes of random data using the nextBytes() method. Then you can
base64url-encode that to produce an URL-safe random string:
    private String randomId() {
        var bytes = new byte[20];             
        new SecureRandom().nextBytes(bytes);  
        return Base64url.encode(bytes);    
    }
Listing 5.3 shows the complete DatabaseTokenStore implementation. After creating a
random ID, you can serialize the token attributes into JSON and then insert the data
into the tokens table using the Dalesbred library introduced in chapter 2. Reading
the token is also simple using a Dalesbred query. A helper method can be used to con-
vert the JSON attributes back into a map to create the Token object. Dalesbred will
call the method for the matching row (if one exists), which can then perform the
JSON conversion to construct the real token. To revoke a token on logout, you can
simply delete it from the database. Navigate to src/main/java/com/manning/api-
securityinaction/token and create a new file named DatabaseTokenStore.java. Type in
the contents of listing 5.3 and save the new file.
package com.manning.apisecurityinaction.token;
import org.dalesbred.Database;
import org.json.JSONObject;
import spark.Request;
import java.security.SecureRandom;
import java.sql.*;
import java.util.*;
public class DatabaseTokenStore implements TokenStore {
    private final Database database;
    private final SecureRandom secureRandom;        
    public DatabaseTokenStore(Database database) {
        this.database = database;
        this.secureRandom = new SecureRandom();     
    }
(continued)
random device on Linux because it doesn’t generate better quality output than /dev/
urandom and may block your process for long periods of time. If you want to learn
more about how operating systems generate random data securely, see chapter 9 of
Cryptography Engineering by Niels Ferguson, Bruce Schneier, and Tadayoshi Kohno
(Wiley, 2010).
Listing 5.3
The DatabaseTokenStore
Generate 20 bytes of random 
data from SecureRandom.
Encode the result with URL-safe 
Base64 encoding to create a string.
Use a SecureRandom to 
generate unguessable 
token IDs.
159
Tokens without cookies
    private String randomId() {
        var bytes = new byte[20];                        
        secureRandom.nextBytes(bytes);                   
        return Base64url.encode(bytes);                  
    }
    @Override
    public String create(Request request, Token token) {
        var tokenId = randomId();                        
        var attrs = new JSONObject(token.attributes).toString();   
        database.updateUnique("INSERT INTO " +
            "tokens(token_id, user_id, expiry, attributes) " +
            "VALUES(?, ?, ?, ?)", tokenId, token.username,
                token.expiry, attrs);
        return tokenId;
    }
    @Override
    public Optional read(Request request, String tokenId) {
        return database.findOptional(this::readToken,            
                "SELECT user_id, expiry, attributes " +
                "FROM tokens WHERE token_id = ?", tokenId);
    }
    private Token readToken(ResultSet resultSet)                 
            throws SQLException {                                
        var username = resultSet.getString(1);                   
        var expiry = resultSet.getTimestamp(2).toInstant();      
        var json = new JSONObject(resultSet.getString(3));       
        var token = new Token(expiry, username);                 
        for (var key : json.keySet()) {                          
            token.attributes.put(key, json.getString(key));      
        }                                                        
        return token;                                            
    }
    @Override
    public void revoke(Request request, String tokenId) {
        database.update("DELETE FROM tokens WHERE token_id = ?",   
                tokenId);                                          
    }
}
All that remains is to plug in the DatabaseTokenStore in place of the CookieToken-
Store. Open Main.java in your editor and locate the lines that create the Cookie-
TokenStore. Replace them with code to create the DatabaseTokenStore, passing in
the Dalesbred Database object:
var databaseTokenStore = new DatabaseTokenStore(database);
TokenStore tokenStore = databaseTokenStore;
var tokenController = new TokenController(tokenStore);
Use a SecureRandom to 
generate unguessable 
token IDs.
Serialize the
token attributes
as JSON.
Use a helper 
method to 
reconstruct 
the token 
from the 
JSON.
Revoke a token on logout by
deleting it from the database.
160
CHAPTER 5
Modern token-based authentication
Save the file and restart the API to see the new token storage format at work. 
TIP
To ensure that Java uses the non-blocking /dev/urandom device for
seeding the SecureRandom class, pass the option -Djava.security.egd=file:
/dev/urandom to the JVM. This can also be configured in the java.security
properties file in your Java installation.
First create a test user, as always:
curl -H 'Content-Type: application/json' \
  -d '{"username":"test","password":"password"}' \
  https://localhost:4567/users
Then call the login endpoint to obtain a session token:
$ curl -i -H 'Content-Type: application/json' -u test:password \
   -X POST https://localhost:4567/sessions
HTTP/1.1 201 Created
Date: Wed, 22 May 2019 15:35:50 GMT
Content-Type: application/json
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Cache-Control: private, max-age=0
Server: 
Transfer-Encoding: chunked
{"token":"QDAmQ9TStkDCpVK5A9kFowtYn2k"}
Note the lack of a Set-Cookie header in the response. There is just the new token in
the JSON body. One quirk is that the only way to pass the token back to the API is via
the old X-CSRF-Token header you added for cookies:
$ curl -i -H 'Content-Type: application/json' \
  -H 'X-CSRF-Token: QDAmQ9TStkDCpVK5A9kFowtYn2k' \  
  -d '{"name":"test","owner":"test"}' \
  https://localhost:4567/spaces
HTTP/1.1 201 Created
We’ll fix that in the next section so that the token is passed in a more appropriate header.
5.2.2
The Bearer authentication scheme
Passing the token in a X-CSRF-Token header is less than ideal for tokens that have
nothing to do with CSRF. You could just rename the header, and that would be per-
fectly acceptable. However, a standard way to pass non-cookie-based tokens to an API
exists in the form of the Bearer token scheme for HTTP authentication defined by RFC
6750 (https://tools.ietf.org/html/rfc6750). While originally designed for OAuth2
usage (chapter 7), the scheme has been widely adopted as a general mechanism for
API token-based authentication.
DEFINITION
A bearer token is a token that can be used at an API simply by
including it in the request. Any client that has a valid token is authorized to
Pass the token in the 
X-CSRF-Token header to 
check that it is working.
161
Tokens without cookies
use that token and does not need to supply any further proof of authentication.
A bearer token can be given to a third party to grant them access without
revealing user credentials but can also be used easily by attackers if stolen.
To send a token to an API using the Bearer scheme, you simply include it in an Autho-
rization header, much like you did with the encoded username and password for
HTTP Basic authentication. The token is included without additional encoding:2
Authorization: Bearer QDAmQ9TStkDCpVK5A9kFowtYn2k
The standard also describes how to issue a WWW-Authenticate challenge header for
bearer tokens, which allows our API to become compliant with the HTTP specifica-
tions once again, because you removed that header in chapter 4. The challenge can
include a realm parameter, just like any other HTTP authentication scheme, if the
API requires different tokens for different endpoints. For example, you might return
realm="users" from one endpoint and realm="admins" from another, to indicate to
the client that they should obtain a token from a different login endpoint for adminis-
trators compared to regular users. Finally, you can also return a standard error code and
description to tell the client why the request was rejected. Of the three error codes
defined in the specification, the only one you need to worry about now is invalid_
token, which indicates that the token passed in the request was expired or otherwise
invalid. For example, if a client passed a token that has expired you could return:
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="users", error="invalid_token",
        error_description="Token has expired"
This lets the client know to reauthenticate to get a new token and then try its request
again. Open the TokenController.java file in your editor and update the validate-
Token and logout methods to extract the token from the Authorization header. If the
value starts with the string "Bearer" followed by a single space, then you can extract
the token ID from the rest of the value. Otherwise you should ignore it, to allow
HTTP Basic authentication to still work at the login endpoint. You can also return a
useful WWW-Authenticate header if the token has expired. Listing 5.4 shows the
updated methods. Update the implementation and save the file.
public void validateToken(Request request, Response response) {
    var tokenId = request.headers("Authorization");             
    if (tokenId == null || !tokenId.startsWith("Bearer ")) {    
        return;
    }
    tokenId = tokenId.substring(7);     
2 The syntax of the Bearer scheme allows tokens that are Base64-encoded, which is sufficient for most token
formats in common use. It doesn’t say how to encode tokens that do not conform to this syntax.
Listing 5.4
Parsing Bearer Authorization headers
Check that the 
Authorization 
header is present 
and uses the 
Bearer scheme.
The token ID is the rest 
of the header value.
162
CHAPTER 5
Modern token-based authentication
    tokenStore.read(request, tokenId).ifPresent(token -> {
        if (Instant.now().isBefore(token.expiry)) {
            request.attribute("subject", token.username);
            token.attributes.forEach(request::attribute);
        } else {
            response.header("WWW-Authenticate",               
                    "Bearer error=\"invalid_token\"," +       
                           "error_description=\"Expired\"");  
    halt(401);
        }
    });
}
public JSONObject logout(Request request, Response response) {
    var tokenId = request.headers("Authorization");             
    if (tokenId == null || !tokenId.startsWith("Bearer ")) {    
        throw new IllegalArgumentException("missing token header");
    }
    tokenId = tokenId.substring(7);    
    tokenStore.revoke(request, tokenId);
    response.status(200);
    return new JSONObject();
}
You can also add the WWW-Authenticate header challenge when no valid credentials
are present on a request at all. Open the UserController.java file and update the
requireAuthentication filter to match listing 5.5.
public void requireAuthentication(Request request, Response response) {
    if (request.attribute("subject") == null) {
        response.header("WWW-Authenticate", "Bearer");   
        halt(401);
    }
}
5.2.3
Deleting expired tokens
The new token-based authentication method is working well for your mobile and
desktop apps, but your database administrators are worried that the tokens table
keeps growing larger without any tokens ever being removed. This also creates a
potential DoS attack vector, because an attacker could keep logging in to generate
enough tokens to fill the database storage. You should implement a periodic task to
delete expired tokens to prevent the database growing too large. This is a one-line task
in SQL, as shown in listing 5.6. Open DatabaseTokenStore.java and add the method in
the listing to implement expired token deletion.
Listing 5.5
Prompting for Bearer authentication
If the token is expired, 
then tell the client using 
a standard response.
Check that the 
Authorization 
header is present 
and uses the 
Bearer scheme.
The token ID is the rest 
of the header value.
Prompt for Bearer authentication
if no credentials are present.
163
Tokens without cookies
public void deleteExpiredTokens() {
    database.update(
        "DELETE FROM tokens WHERE expiry  {
    databaseTokenStore.deleteExpiredTokens();
    return new JSONObject();
});
For now, you can use a simple Java scheduled executor service to periodically call
the method. Open DatabaseTokenStore.java again, and add the following lines to the
constructor:
 Executors.newSingleThreadScheduledExecutor()
         .scheduleAtFixedRate(this::deleteExpiredTokens,
                 10, 10, TimeUnit.MINUTES);
This will cause the method to be executed every 10 minutes, after an initial 10-minute
delay. If a cleanup job takes more than 10 minutes to run, then the next run will be
scheduled immediately after it completes.
5.2.4
Storing tokens in Web Storage
Now that you’ve got tokens working without cookies, you can update the Natter UI to
send the token in the Authorization header instead of in the X-CSRF-Token header.
Open natter.js in your editor and update the createSpace function to pass the token
in the correct header. You can also remove the credentials field, because you no lon-
ger need the browser to send cookies in the request:
    fetch(apiUrl + '/spaces', {
        method: 'POST',            
        body: JSON.stringify(data),
Listing 5.6
Deleting expired tokens
Delete all tokens with an
expiry time in the past.
Remove the credentials 
field to stop the browser 
sending cookies.
164
CHAPTER 5
Modern token-based authentication
        headers: {