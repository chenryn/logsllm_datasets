# Squirrel：利用语义有效性和覆盖反馈来测试数据库管理系统
|
##### 译文声明
本文是翻译文章，文章原作者 Rui Zhong，Yongheng Chen， Hong Hu，Hangfan Zhang，Wenke Lee，Dinghao
Wu*，文章来源：ACM CCS 2020（Nov）
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
这是一篇会议论文，提出了针对DBMS的一种模糊测试框架SQUIRREL，效果显著优于其他的模糊器。
## 0 摘要
模糊测试是一种越来越流行的用于验证软件功能和寻找安全漏洞的技术。然而，现在的基于突变的模糊器（Fuzzer）不能有效地测试数据库管理系统（DBMS），因为数据库管理系统对于有效的语法和语义有着严格的检查。基于生成的测试可以保证输入的语法正确性，但是它不利用任何反馈（例如代码覆盖率）来指导路径探索。
在本文中，我们开发了SQUIRREL，这是一个新颖的模糊框架，考虑了语言的有效性和覆盖反馈来测试数据库管理系统。我们设计了一个中间表示（IR），以结构化和信息丰富的方式维护SQL查询。为了生成语法正确的查询，我们在IR上执行基于类型的突变，包括语句插入，删除和替换。为了减轻语义错误，我们通过分析每个IR来确定参数之间的逻辑依赖性，然后生成满足这些依赖性的查询。我们在四个流行的数据库管理系统上测试了SQUIRREL：`SQLite,MySQL,PostgreSQL,MariaDB`。
_SQUIRREL_
发现了`SQLite`的51个漏洞，`MySQL`和`MariaDB`则分别是7个和5个。其中，有52个是已经修复了的，有12个具有CVE编号。在我们的实验中，与最新的模糊测试相比，
_SQUIRREL_ 的语义正确性提高了2.4-243.9倍，与基于变异的工具相比，它所探寻的新边缘（Edges）增加了2.0-10.9倍。这些结果表明，
_SQUIRREL_ 可有效地发现数据库管理系统中的内存错误。
## 1 介绍
数据库管理系统（DBMS）是现代数据密集型系统的组成部分。与所有其他复杂系统一样，DBMS也会出现许多错误，这些错误不仅会影响其功能，而且还可能导致恶意攻击。在所有威胁中，臭名昭著的内存错误漏洞使攻击者能够泄漏甚至破坏正在运行的DBMS进程的内存，这最终可能导致远程代码执行，数据库违规（breach），或者拒绝服务。例如，最近的“Collection＃1”数据泄露揭示了7.73亿个电子邮件地址和210亿个密码。
基于生成的测试技术是DBMS的事实上的错误查找工具，这些技术要求开发人员创建一个正式模型，以精确地定义SQL（结构化查询语言）。该工具基于该模型枚举所有可能的SQL查询，以验证DBMS的功能或查找错误。
但是，基于生成的测试工具的有效性有限，因为它们将工作量平均分配给每个SQL查询。考虑到无限的输入空间和罕见的错误触发查询，这种类似蛮力的枚举无法有效地从DBMS中查找内存错误漏洞。
近年来，模糊测试已被广泛用作检测内存错误漏洞的软件测试技术。与基于生成的测试不同，模糊测试依靠随机突变来创建新的测试用例，并利用诸如代码覆盖率之类的反馈来指导输入空间探索。从种子主体开始，模糊器会随机更改现有输入（例如翻转几位）以生成略有不同的变体。它使用新的输入运行目标程序，并检测异常行为，例如执行崩溃和断言失败。
在执行期间，模糊器还会记录代码路径信息，例如执行的块或分支。触发新代码路径的输入具有更高的优先级，可以选择用于另一轮变异。通过花费大量的精力来提高模糊的效率和功效，模糊器已经成功地从流行的应用程序中发现了数千个错误。
但是，将模糊测试技术用于测试DBMS具有挑战性，因为DBMS在执行SQL查询之前执行两项正确性检查，即语法检查和语义检查。
具体来说，DBMS首先解析每个SQL查询以获得其语法含义。 如果查询中有任何语法错误，则DBMS将停止执行，并立即通过错误消息来提示。
否则，DBMS会进一步检查查询中是否存在语义错误，例如使用不存在的表，并且在出现语义错误的任何情况下会停止。
经过这两项检查后，DBMS将创建多个执行计划，并选择最有效的执行计划来执行查询。 因此，为了达到DBMS的深层逻辑，查询应在语法和语义上正确。
当前的模糊测试技术使用的随机字节突变无法轻易生成语法正确或语义正确的输入。 例如，基于突变的代表性模糊器AFL 可以在24小时内生成2000万个SQLite
查询，但只有30％的查询可以通过语法检查，而4％的查询具有正确的语义。
但是，大多数DBMS代码负责查询计划的构建，优化和执行，只有一小部分用于语法检查和语义检查。
例如，AFL生成的20,000个语义正确查询触发了SQLite中的19,291条代码分支，而相同数量的语法错误查询仅覆盖9,809条分支，仅占前者的50.8％。
因此，当前的模糊技术无法触发DBMS的深层逻辑，也无法全面探索程序状态。
在本文中，我们提出了一个Squirrel系统来应对这些挑战，以便我们可以有效地模糊DBMS。
我们的系统嵌入了两项关键技术，即保留语法的变异和基于语义的实例化。为了生成语法正确的SQL查询，我们设计了一个中间表示（IR），以结构化和信息丰富的方式维护查询。每个IR语句最多包含两个操作数，每个操作数也是另一个IR语句。每个IR具有指示语法结构（例如，SELECT
a FROM
b）的结构类型和数据类型（例如，表名称）。进行突变之前，我们的系统会从IR中剥离具体数据，仅保留操作的框架。然后，我们执行三个随机突变，包括插入类型匹配的操作数，删除可选操作数或用其他类型匹配的操作数替换操作数。基于类型的变异确保了生成的查询具有正确的语法。接下来，我们执行查询分析以找出不同IR数据之间的预期依赖关系。例如，SELECT子句中的数据应该是FROM子句中表的列。我们用具体数据填充每个剥离的IR，并确保它们满足所有预期的依赖性。最后，我们将IR转换回SQL，并将其提供给DBMS进行测试。
Squirrel结合了基于覆盖的模糊测试（即指导性探索）和基于模型的生成（即高语言正确性）的优势，因此可以触发DBMS的深层逻辑并发现严重的错误。
我们用 **43,783** 行C ++代码实现了Squirrel，主要集中在保留语法的变异和语义指导的实例化上。
我们将AFL的代码重复用于覆盖率收集和输入优先级划分。 我们对Squirrel的设计是通用的，经过一些工程工作，它应该可以与其他模糊测试器一起使用。
为了了解我们系统的有效性，我们使用Squirrel测试了四个流行的DBMS：SQLite，MySQL，PostgreSQL和MariaDB。
Squirrel在40天内成功发现了63个内存错误问题，其中包括SQLite中的51个错误，MySQL中的7个错误和MariaDB中的5个错误。
相比之下，Google OSS-Fuzz在40个月内检测到19个来自SQLite的错误，在5个月内检测到来自MySQL的15个错误。
我们已经以负责任的态度向DBMS开发人员报告了所有这些错误，并获得了积极的反馈。 在撰写本文时，已修复了52个错误。
由于严重的安全后果，例如窃取数据库内容，我们甚至可以获得12个错误的CVE编号。
我们检查了模糊测试的各个方面，并将Squirrel与其他先进的工具进行了比较，包括基于突变的模糊器AFL和Angora，基于生成的工具SQLsmith，结构模糊器GRIMOIRE和混合模糊器QSYM。
在24小时的测试过程中，Squirrel成功地发现了9个独特的错误，而其他错误则检测到了一个或零个错误。
与基于突变的工具相比，Squirrel发现了2.0-10.9倍的新边缘，并且获得了与基于生成的测试器SQLsmith相当的结果。
与其他工具相比，它的语义正确性也高2.4-243.9倍。
我们在本文中做出了以下贡献：
  * 我们提出了保留语法的变异和语义指导的实例化，以解决使DBMS模糊化的挑战。
  * 我们实现了Squirrel，这是一个将变异和生成结合起来以检测DBMS错误的端到端系统。
  * 我们在实际的DBMS上评估了Squirrel，并确定了63个内存错误问题。 结果表明，在从DBMS查找错误时，Squirrel优于现有工具。
我们计划发布Squirrel的代码，以帮助DBMS开发人员测试其产品，并加强对DBMS安全的未来研究。
## 2 问题定义（Problem Definition）
在本节中，我们首先简要描述DBMS如何处理SQL查询。 然后，我们介绍现有的DBMS测试技术，并说明它们在查找深层逻辑中的隐藏错误时的局限性。
最后，我们提出解决这一问题的见解。
### 2.1 DBMS中的查询过程
> 图1：测试DBMS的挑战.DBMS采取四个步骤来处理一个SQL查询。 其中，parse检查语法正确性，而validation检查语义有效性。
> 随机变异不太可能保证语法正确性，而基于语法的生成可能无法确保语义正确性。
现代DBMS通常以四个阶段处理SQL查询： **解析，验证，优化和执行**
，如图1所示。在收到SQL查询之后，DBMS首先解析查询以获取其语法含义。解析器将查询分解为单独的标记，并对照语法规则检查它们。如果检测到任何语法错误，DBMS将立即终止执行并将错误消息返回给客户端。其次，DBMS在验证阶段检查查询的语义正确性，例如数据库中是否存在表或表中的列是否明确。在此阶段可以检测到大多数语义错误。接下来，在优化阶段，查询优化器构造几种可能的查询计划，并尝试确定执行给定查询的最有效计划。最后，DBMS在数据库上执行选定的计划，并将结果发送回客户端。因此，仅在查询语法正确的情况下，执行才会进入第二阶段，而在查询语义正确的情况下，执行将进入最后两个短语。
**Motivating Example.** 图1中的“原始查询”首先连接两个表t1和t2，并搜索t1的c1列与t2的c5列相同的行。
对于每个匹配的行，查询将返回c2和c6的值。 DBMS发现此查询通过了语法检查和语义检查。 它在数据库中搜索，最后返回“ alice read”。
### 2.2 测试DBMS的难点
生成SQL查询以测试DBMS的方法主要有两种：基于模型的生成和随机变异。 基于模型的生成遵循精确的语法模型，因此可以构造语法正确的输入。
例如，流行的DBMS测试工具SQLsmith直接从抽象语法树（AST）生成语法正确的测试用例。但是，在没有任何指导的情况下，基于模型的生成顺序扫描整个输入空间。考虑到许多查询是由DBMS以相同的方式处理的，因此该方法无法有效地探索程序的状态空间。
此外，基于生成的方法几乎不能保证语义的正确性，并且在验证过程中，DBMS会过滤掉语义不正确的查询。 图1显示了由生成器（生成后）构造的查询。
尽管此查询在语法上是正确的，但由于当前数据库中不存在WHERE子句中的表t3，因此无法执行该查询。
随机突变更新现有输入以生成新输入。为了提高性能，模糊器利用先前执行的反馈来评估生成输入的优先级。如果反馈指示先前的输入很有趣，例如触发新的执行路径，则模糊测试人员会将其放入队列中以进行进一步的更改。这样，模糊测试者将收集越来越多有趣的测试用例，从而可以有效地探索程序的状态空间。统计数据表明，在许多软件中，具有反馈驱动的随机突变效果很好。例如，谷歌通过基于反馈的基于突变的模糊器发现了5,000多个漏洞。但是，盲语法突变策略在处理结构化输入（例如SQL和JavaScript）方面效率较低。例如，随机翻转SQL关键字的位几乎不会产生另一个有效关键字，并且整个查询在语法上将变得不正确。图1显示了这种情况（突变后），其中将SELECT中S的最后一位翻转会导致无效的关键字RELECT。
DBMS将在解析阶段拒绝新查询。
我们设计评估以了解AFL生成的SQL查询的质量以及语法正确性和语义正确性的重要性。
具体来说，我们使用AFL在24小时内测试SQLite，这会生成2000万个查询。 但是，只有大约30％的语法正确，只有4％的语法可以通过语义检查。
我们随机选择了20,000个语义正确的查询，并发现它们在SQLite中触发了19,291个不同的代码分支。
相同数量的语法不正确和语义不正确的查询分别分别到达9,809和12,811个分支。
这些结果表明：AFL生成的查询的验证率较低，以及语义正确性对于探索程序状态空间的重要性。
### 2.3 我们的解决方法
本文的想法是将语法正确和语义感知的变异引入模糊测试中，以便我们可以利用基于变异的技术和基于生成的机制来最大化测试DBMS的能力。
**生成语法正确的查询：** 我们设计了一个新的中间表示（IR），以结构化和信息化的方式维护SQL查询，并采用基于类型的变异来保证语法的正确性。
每个IR语句最多只包含两个操作数，因此，我们的突变只需要处理两个值。
每个语句都有一个关联的语法类型，例如SELECT语句的SelectStmt，而每个数据都有一个语义类型，例如表名。
我们的变异执行基于类型的操作，包括插入类型匹配的操作数、删除可选操作数以及用类型匹配的操作数替换操作数。