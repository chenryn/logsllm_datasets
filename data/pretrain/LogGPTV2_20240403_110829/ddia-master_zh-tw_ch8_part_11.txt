#### 演算法的正确性
为了定义演算法是正确的，我们可以描述它的属性。例如，排序演算法的输出具有如下特性：对于输出列表中的任何两个不同的元素，左边的元素比右边的元素小。这只是定义对列表进行排序含义的一种形式方式。
同样，我们可以写下我们想要的分散式演算法的属性来定义它的正确含义。例如，如果我们正在为一个锁生成防护令牌（请参阅 “[防护令牌](#防护令牌)”），我们可能要求演算法具有以下属性：
* 唯一性（uniqueness）
  没有两个防护令牌请求返回相同的值。
* 单调序列（monotonic sequence）
  如果请求 $x$ 返回了令牌 $t_x$，并且请求 $y$ 返回了令牌 $t_y$，并且 $x$ 在 $y$ 开始之前已经完成，那么 $t_x < t_y$。
* 可用性（availability）
  请求防护令牌并且不会崩溃的节点，最终会收到响应。
如果一个系统模型中的演算法总是满足它在所有我们假设可能发生的情况下的性质，那么这个演算法是正确的。但这如何有意义？如果所有的节点崩溃，或者所有的网路延迟突然变得无限长，那么没有任何演算法能够完成任何事情。
#### 安全性和活性
为了澄清这种情况，有必要区分两种不同的属性：**安全（safety）属性** 和 **活性（liveness）属性**。在刚刚给出的例子中，**唯一性** 和 **单调序列** 是安全属性，而 **可用性** 是活性属性。
这两种性质有什么区别？一个试金石就是，活性属性通常在定义中通常包括 “**最终**” 一词（是的，你猜对了 —— 最终一致性是一个活性属性【89】）。
安全通常被非正式地定义为：**没有坏事发生**，而活性通常就类似：**最终好事发生**。但是，最好不要过多地阅读那些非正式的定义，因为好与坏的含义是主观的。安全和活性的实际定义是精确的和数学的【90】：
* 如果安全属性被违反，我们可以指向一个特定的安全属性被破坏的时间点（例如，如果违反了唯一性属性，我们可以确定重复的防护令牌被返回的特定操作）。违反安全属性后，违规行为不能被撤销 —— 损失已经发生。
* 活性属性反过来：在某个时间点（例如，一个节点可能传送了一个请求，但还没有收到响应），它可能不成立，但总是希望在未来能成立（即透过接受答复）。
区分安全属性和活性属性的一个优点是可以帮助我们处理困难的系统模型。对于分散式演算法，在系统模型的所有可能情况下，要求 **始终** 保持安全属性是常见的【88】。也就是说，即使所有节点崩溃，或者整个网路出现故障，演算法仍然必须确保它不会返回错误的结果（即保证安全属性得到满足）。
但是，对于活性属性，我们可以提出一些注意事项：例如，只有在大多数节点没有崩溃的情况下，只有当网路最终从中断中恢复时，我们才可以说请求需要接收响应。部分同步模型的定义要求系统最终返回到同步状态 —— 即任何网路中断的时间段只会持续一段有限的时间，然后进行修复。
#### 将系统模型对映到现实世界
安全属性和活性属性以及系统模型对于推理分散式演算法的正确性非常有用。然而，在实践中实施演算法时，现实的混乱事实再一次地让你咬牙切齿，很明显系统模型是对现实的简化抽象。
例如，在崩溃 - 恢复（crash-recovery）模型中的演算法通常假设稳定储存器中的资料在崩溃后可以幸存。但是，如果磁碟上的资料被破坏，或者由于硬体错误或错误配置导致资料被清除，会发生什么情况【91】？如果伺服器存在韧体错误并且在重新启动时无法识别其硬碟驱动器，即使驱动器已正确连线到伺服器，那又会发生什么情况【92】？
法定人数演算法（请参阅 “[读写的法定人数](ch5.md#读写的法定人数)”）依赖节点来记住它声称储存的资料。如果一个节点可能患有健忘症，忘记了以前储存的资料，这会打破法定条件，从而破坏演算法的正确性。也许需要一个新的系统模型，在这个模型中，我们假设稳定的储存大多能在崩溃后幸存，但有时也可能会丢失。但是那个模型就变得更难以推理了。
演算法的理论描述可以简单宣称一些事是不会发生的 —— 在非拜占庭式系统中，我们确实需要对可能发生和不可能发生的故障做出假设。然而，真实世界的实现，仍然会包括处理 “假设上不可能” 情况的程式码，即使程式码可能就是 `printf("Sucks to be you")` 和 `exit(666)`，实际上也就是留给运维来擦屁股【93】。（这可以说是计算机科学和软体工程间的一个差异）。
这并不是说理论上抽象的系统模型是毫无价值的，恰恰相反。它们对于将实际系统的复杂性提取成一个个我们可以推理的可处理的错误型别是非常有帮助的，以便我们能够理解这个问题，并试图系统地解决这个问题。我们可以证明演算法是正确的，透过表明它们的属性在某个系统模型中总是成立的。
证明演算法正确并不意味著它在真实系统上的实现必然总是正确的。但这迈出了很好的第一步，因为理论分析可以发现演算法中的问题，这种问题可能会在现实系统中长期潜伏，直到你的假设（例如，时序）因为不寻常的情况被打破。理论分析与经验测试同样重要。
## 本章小结
在本章中，我们讨论了分散式系统中可能发生的各种问题，包括：
* 当你尝试透过网路传送资料包时，资料包可能会丢失或任意延迟。同样，答复可能会丢失或延迟，所以如果你没有得到答复，你不知道讯息是否传送成功了。
* 节点的时钟可能会与其他节点显著不同步（尽管你尽最大努力设定 NTP），它可能会突然跳转或跳回，依靠它是很危险的，因为你很可能没有好的方法来测量你的时钟的错误间隔。
* 一个程序可能会在其执行的任何时候暂停一段相当长的时间（可能是因为停止所有处理的垃圾收集器），被其他节点宣告死亡，然后再次复活，却没有意识到它被暂停了。