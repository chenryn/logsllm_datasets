## 辅助界面元素的架构设计到目前为止，我们实现了三个符合我们定义的控件规范的辅助界面元素。如下：-   [controls/BaseLineWidthPicker.js](https://github.com/qiniu/qpaint/blob/v31/paintweb/www/controls/BaseLineWidthPicker.js)-   [controls/BaseColorPicker.js](https://github.com/qiniu/qpaint/blob/v31/paintweb/www/controls/BaseColorPicker.js)-   [controls/ColorPicker.js](https://github.com/qiniu/qpaint/blob/v31/paintweb/www/controls/ColorPicker.js)观察这些辅助界面元素的代码，你会发现它们都没有基于 MVC 架构。是因为辅助界面元素不适合用 MVC 架构来编写么？当然不是。更本质的原因是因为它们规模太小了。这些界面元素的特点是 DOM 都是一个value，并不是一棵树，这样 Model 层就没什么代码了。同样的逻辑，View层、Control 层代码量都过于短小，就没必要有那么清楚的模块划分。View负责界面呈现，Control 负责事件响应，只是在心里有谱就好了。但并不是所有辅助界面元素都这么简单。举一个简单的例子。让我们给自己设定一个新目标：把我们前面实战的 "画图"程序，改造成一个标准的辅助界面元素，这可行么？答案当然是肯定的。但是这意味着我们有一些假设需要修正。这些假设通常都和唯一性有关。比如，全局有唯一的 View 对象实例 qview:QPaintView。如果我们是辅助界面元素，意味着我们可能在同一个界面出现多个实例。在多实例的情况下，View对象显然就应该有多个。再比如，我们画图程序的辅助界面元素（参见accel/menu.js](https://github.com/qiniu/qpaint/blob/v31/paintweb/www/accel/menu.js)）都是单例，具体表现为这些界面元素的id 都是固定的。当然，辅助界面元素的改造方案有多种可能性。一种方案是将辅助界面元素也改造为多例，使得每个QPaint 实例都有自己的辅助界面元素。另一种方案是继续保持单例，这意味着多个 QPaint实例会有一个当前实例的概念。辅助界面元素根据场景，可以是操作全部实例，也可以是操作当前实例。我们选择继续保持单例。这意味着 qview: QPaintView这个全局变量可以继续存在，但是和之前的含义有了很大不同。之前 qview代表的是单例，现在 qview 代表的是当前实例。有了当前实例当然就有切换。这样就需要增加焦点相关的事件响应。在画图程序中，很多 Controller 都是 View实例相关的。比如：PathCreator、ShapeSelector 等。在 View存在多例的情况下，这些 Controller 之前的 registerController动作就需要重新考虑。为了支持多例，我们引入了 onViewAdded、onCurrentViewChanged事件。当一个新的 View 实例被创建时，会发送 onViewAdded 事件。Controller可以响应该事件去完成 registerController 动作。如下：    onViewAdded(function(view) {  view.registerController("PathCreator", function() {    return new QPathCreator(view, false)  })})原先，当前图形样式是放在 View 中的，通过 qview.style可以访问到。这会导致多个 View实例的当前图形样式不一样，但是我们辅助界面元素又是单例的，这就非常让人混淆。最后我们决定把qview.style 挪到全局，改名叫 defaultStyle（参阅accel/menu.js#L42](https://github.com/qiniu/qpaint/blob/v31/paintweb/www/accel/menu.js#L42)）。做完这些改造，我们的画图程序就有了成为一个标准控件的基础。具体代码如下（参阅PaintView.js](https://github.com/qiniu/qpaint/blob/v31/paintweb/www/PaintView.js)）：    function newPaintView(drawingID) {  let view = new QPaintView(drawingID)  fireViewAdded(view)  return view} function initPaintView(drawingID) {  let view = newPaintView(drawingID)  setCurrentView(view)} function PaintView(div) {  let id = div.id  let width = div.getAttribute("width")  let height = div.getAttribute("height")  div.outerHTML = ` 你的浏览器不支持 Canvas！`  initPaintView(id)} qcontrols.register("PaintView", PaintView)有了这个 PaintView 控件，我们就可以到处引用它了。我们做了一个 PaintView控件的 DEMO 程序，它效果看起来是这样的（代码参阅PaintDemo.htm](https://github.com/qiniu/qpaint/blob/v31/paintweb/www/PaintDemo.htm)）：![](Images/54123ed20f60a37b3c2e25b0251ec56b.png){savepage-src="https://static001.geekbang.org/resource/image/29/52/295e17f40fa63b929a4a5175da39ae52.png"}从这个截图看，细心的你可能会留意到，还有一个问题是没有被修改的，那就是URL 地址。我们的 QPaintView 在 load 文档后会修改URL，这作为应用程序并没有问题。但是如果是一个控件，整个界面有好多个PaintView，URL 中应该显示哪个文档的 ID？显然谁都不合适。如果非要显示，可能要在 PaintView实例附近放一个辅助界面元素来显示它。怎么修改？这个问题暂且留给大家。
## 结语今天探讨了辅助界面元素，或者叫控件的架构设计。从大的实现逻辑来说，它和应用程序不应该有本质的不同。但控件总是要考虑支持多实例，这会带来一些细节上的差异。支持多实例听起来是一项简单的工作，但是从我的观察看，对很多工程师来说实际上并不简单。不少初级工程师写代码往往容易全局变量满天飞，模块之间相互传递信息不假思索地基于全局变量来完成。这些不良习惯会导致代码极难控件化。当然我们不见得什么桌面应用程序都要考虑把它控件化。但是我们花一些精力去思考控件化的话，会有助于你对架构设计中的一些决策提供帮助。当然更重要的，其实是让你有机会形成更好的架构设计规范。这一讲我们作出的修改如下：-   这是最新版本的源代码：-   如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们会谈谈架构设计的第二步：如何做好系统架构。如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。![](Images/66b9828c3d4de21b8f7a14213cf3c4e7.png){savepage-src="https://static001.geekbang.org/resource/image/43/00/43231f3789095eb4cdb38e67ff3d7900.jpg"}
# 32 \| 架构：系统的概要设计你好，我是七牛云许式伟。我们第二章 "桌面开发篇" 就快要结束了。今天我们把话题重新回到架构上。
## 基础架构与业务架构桌面开发篇我们主要涉及的内容如下。![](Images/2d0300f994d4a838f342241d8df78185.png){savepage-src="https://static001.geekbang.org/resource/image/55/50/553d5dd6b9e774585514a05674066550.png"}对于一位架构师而言，其架构工作的内容可以大体分为两块，一块是基础架构，一块是业务架构。基础架构，简单来说就是做技术选型。选择要支持的操作系统、选择编程语言、选择技术框架、选择第三方库，这些都可以归结为基础架构方面的工作。基础架构的能力，考验的是选择能力。背后靠的是技术前瞻性和判断力。这并不简单。大部分架构师往往更容易把关注点放到业务架构上，但实际上基础架构的影响面更广，选错产生的代价更高。架构师之间的差距，更大的是体现在其对待基础架构的态度和能力构建上。真正牛的架构师，一定会无比重视团队的技术选型，无比重视基础平台的建设。阿里提倡的"大中台、小前台"，本质上也是在提倡基础平台建设，以此不断降低业务开发的成本，提升企业的创新能力。业务架构，简单来说就是业务系统的分解能力。基础架构其实也是对业务系统的分解，只不过分解出了与业务属性几乎无关的部分，形成领域无关的基础设施。而业务架构更多的是分解领域问题。一旦我们谈业务架构，就避不开领域问题的理解。所谓领域问题，谈的是这个领域的用户群面临的普遍需求。所以我们需要对用户的需求进行分析。``{=html}在第一章，我们已经聊了需求分析：-   [17 \|    架构：需求分析（上）](https://time.geekbang.org/column/article/100140)-   [18 \| 架构：需求分析（下）-    实战案例](https://time.geekbang.org/column/article/100930)这是我们开始业务架构的第一步。没有需求分析，就没有业务架构。在业务架构过程中，需求分析至少应该花费三分之一以上的精力。今天，我们聊一聊架构的第二步：系统的概要设计，简称系统设计。系统设计，简单来说就是 "对系统进行分解"的能力。这个阶段核心要干的事情，就是明确子系统的职责边界和接口协议，把整个系统的大框架搭起来。那么怎么分解系统？首先我们需要明确的是分解系统优劣的评判标准。也就是说，我们需要知道什么样的系统分解方式是好的，什么样的分解方式是糟糕的。最朴素的评判依据，是这样两个核心的点：-   功能的使用界面（或者叫接口），应尽可能符合业务需求对它的自然预期；-   功能的实现要高内聚，功能与功能之间的耦合尽可能低。在软件系统中有多个层次的组织单元：子系统、模块、类、方法 /函数。子系统如何分解模块？模块如何分解到更具体的类或函数？每一层的分解方式，都遵循相同的套路。也就是分解系统的方法论。