整体流程图：
1. 用户层发送请求给驱动，驱动层配置并启动intel PT。
2. 用户层去拉起目标程序执行，同时请求接收trace数
据，如果没有数据将阻塞。
3. 目标程序执行，遇到符合filter的指令，将会由CPU 
生成压缩的数据包，保存到trace buff中。
4. Trace buff的数据满后，会产生PMI中断。
5. PMI handle中，先停止intel PT trace，获取trace 
buff的数据，配置好ring buff，唤醒用户层阻塞的
线程。
6. 分为两步：
1. 用户层程序负责从ring buff中读取数据。
2. 驱动重新配置trace buff entry，防止覆盖未被用户层
即时读取的数据。并恢复intel PT trace。
Intel PT的工作机制
•
我们对数据进行解析，解包，按照intel的格式进行拆解，并过滤不关注的数据。
•
数据包格式如下：我们以TIP数据包为例，10110 为数据包类型标记。
Intel PT 数据包解析
• 我们以TIP数据包为例，0~4位10110 表示TIP数据包。
• 5~7位 IPBytes含义如下：例如说 IPBytes 为000时，数据包不带任何数据。IPBytes 为010时，后续
8字节的0~31位对应Payload的0~31位，32~63位对应Payload的32~63位。
Intel PT 数据包解析
• 并不是所有的跳转指令都记录，例如说 jmp $rip + 10，这种指令源地址和目标地址都是可以通过解
析二进制进行获取，所以就不会生成数据包。
• 带条件的直接跳转指令，只会记录条或者不跳，生成TNT bit。CPU会将多个TNT bit 压缩成一个数
据包。
• 注意：这里的绝大多数Payload并没有记录源IP，我们需要根据解析二进制文件，将每一个跳转信息
都和二进制进行一一对应，才能够计算源IP和目标IP。
Intel PT 数据包解析
•
我们完成数据包解析后，提取出感兴趣的跳转指令序列，例如说：
•
ret， ret *
•
jmp reg， jmp [reg], jmp [reg + *], ……… 
•
call reg, call [reg], call [reg + *], ………
•
到此，我们就完成了trace 指令收集的任务。
Intel PT 数据包解析
Shadow stack
•
我们目前已经拿到了所有的call 和ret 的指令序列，我们自己实现一个栈，来模拟call 的入栈操作，和ret
的出栈操作。
•
执行call指令后，会将call 指令的下一条指令的地址压入栈中，用于ret返回：
•
返回地址 = 指令地址+ 指令长度；
•
注意：
•
每一个线程分配一个单独的栈。
•
中断产生，线程切换等问题需要进行逐一处理。
•
调用栈原本就不对称，例如线程刚创建后，栈中已经有一部分数据，但是当前线程未产生call指令压
栈。
•
spectre_v2 漏洞， Retpoline修复方案不兼容！！
•
栈模拟，检测逻辑
Shadow stack
IBT+CFI
•
如何确定跳转指令的合法性？
•
直接调用。
•
肯定合法。
•
间接调用。
•
可能出现问题。
•
对于间接调用，对应的多数都是函数指针，callback，虚函数等，并且是漏洞喜欢篡改的地方。
•
如何确认间接跳转的合法性？
•
目标函数地址，是否是一个函数的起始位置，IBT机制。
•
通过源码得知指针是否可以指向目标函数，CFI机制。
•
如何确定是否是函数起始位置？
•
通过符号解析来实现。
•
通过源码得知函数指针是否可以指向目标函数，自动化如何实现？
•
编译器生成call graph。
IBT+CFI
•
传统的指针分析不能满足需求。
•
如何生成call graph？
•
获取到内核二进制文件的对应源码。
•
通过二次开发的GCC，对源码进行编译，在编译过程中，提取基础信息，并插入到数据库。
•
根据数据库进行关联查询。
•
后面章节详细讲解。
IBT+CFI
•
IBT：
IBT+CFI
•
CFI算法：
IBT+CFI
•
演示效果如下：
基于硬件特性的漏洞防御方案
•
演示效果如下：
基于硬件特性的漏洞防御方案
基于编译器的漏洞防御方案
张海全
基于编译器的漏洞防御方案
•
编译器生成call graph。
•
struct_san 漏洞防御。
call graph
•
直接函数调用，我们不关注。
•
间接函数调用的方式：
•
全局函数指针。
•
全局函数指针链表。
•
参数传递的函数指针。
•
结构体内的函数指针。
•
函数指针数组。
•
函数指针调用是程序分析的难点。
•
源码文件太多。
•
发现内核中的大量结构体的函数指针都是全局结构体定义，然后再使用这个结构体，定义如下：
call graph
•
通过这个规律，在编译器parser阶段，编译器在parse到全局结构体时。提取信息，并插入数据库，
按照如下格式：
•
结构体的类型 : 字段名称 : 函数名字 ；
call graph
•
在编译器parser阶段，编译器在parse到函数时，如果函数内出现间接调用，通过解析gimple，最终
生成如下格式数据，并插入数据库：
•
function : struct : field；
call graph
•
编译完成后进行数据整理，通过上面的两个表中的数据，我们可以得知：
•
ceph_init_file函数里存在一个file_operations->open的间接调用。
•
file_operations->open指针为rtc_open函数是合法的。
•
从而推导：ceph_init_file调用rtc_open是合法的。
call graph
•
通过函数参数传递过来的函数指针。
•
常数传播 + 别名分析。
•
通过向链表注册的callback函数，在加入全局符号表时，也可以进行数据原型的提取，思路如上，并
结合常数传播，即可生成调用关系数据。
• 整体来说我们的思想就是提取原子信息，插入到数据库。后续进行关联查询。
• 精准度和误报率进行衡量。
call graph
struct_san
•
为了防止堆喷，篡改结构体函数指针这种利用方式，我们提出了struct-sanitizer(struct_san)这种新
的控制流完整性检测机制。以最少的插装，最小的性能损耗为宗旨，更严格的校验来抵御漏洞攻击。
当前主流CFI
struct_san
验证方式
函数指针类型
函数指针类型+结构体实例
插装量级
全量插装
最小规模插装
•
例如说：
•
漏洞篡改结构体的ops指针进行流程劫持。
•
我们只需要在所有ops函数指针执行前插桩，从而检测函数指针的合法性。
struct_san
•
如何保证只在ops函数指针调用前进行插装?
•
新增一个GNU Attributes __attribute__ ((sanitize_struct)) 。
•
例如想要保护内核中pipe_buf_operations->release()函数。
•
在结构体类型声明时加入此关键字。
•
编译器会在所有调用pipe_buf_operations结构体函数指针的位置插入
__sanitizer_struct_guard__()。
•
struct_san会将此类型的所有结构体实例保存到.sanitize_struct段内。
•
遵循前面描述的规律，结构体的函数指针，都是定义在一个全局结构体变量里，编译期间，就能确定地址。
struct_san
插桩前后在gcc的gimple IR中的不同表示：
struct_san
•
struct_san目前只在内核中完成了相关实现。其算法是在内核中开辟一个128M大小shadow 
memory用来保存结构体和结构指针的对应关系。
•
__sanitizer_struct_guard__()在调用时会检测传入的struct和函数指针是否在shadow memory中，
如果不在则抛出一个ud2异常，否则返回函数指针。实现方案如下：
•
•
这个算法参考了AddressSanitizer的实现，兼顾了效果和效率。
struct_san
以漏洞CVE-2021-22555的攻击代码
为例，在启用struct_san的情况下，
阻断了攻击代码的执行，起到了有效
的防御。
struct_san
•
我们对struct_san进行了开源，期望和业界一起探讨CFI技术的改进。后续我们也会推出一些其它的
漏洞缓解技术。
•
开源地址：https://github.com/YunDingLab/struct_sanitizer
struct_san
后续展望
•
相关特性部分已经移植到OpenCloudOS中。
•
希望广大安全人员共建。
引用参考文献
•
https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html
•
https://github.com/google/security-research/tree/master/pocs/linux/cve-2021-22555
•
https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html
•
https://github.com/OpenCloudOS/community
Q&A
•
PI:EMAIL/PI:EMAIL
Thanks for listening