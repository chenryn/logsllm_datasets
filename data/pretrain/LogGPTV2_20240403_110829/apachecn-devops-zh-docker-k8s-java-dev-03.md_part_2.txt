*   它不太适合敏捷开发过程，在敏捷开发过程中，我们需要一直实现变更，几乎同时发布到生产中，并为下一次迭代做好准备。
如您所见，单片应用只适合小规模团队和小项目。如果你需要一个规模比较大，涉及到很多团队的东西，最好还是看替代方案。但是如何处理你可能喜欢处理的现有单一系统呢？您可能会意识到，将系统的某些部分外包给小型服务会很方便。这将加快开发过程，增加可测试性。这也将使您的应用更容易扩展。尽管单片应用仍然保留了核心功能，但许多部分可以外包给支持核心模块的小型辅助服务。下图显示了这种方法:
![](img/43878efc-3297-4d03-b814-390d87bf44df.jpg)
在这种情况下，让我们说中介解决方案，主要的业务逻辑将留在您的应用整体。例如，集成、后台作业或其他可以由消息触发的小子系统可以移动到它们自己的服务中。您甚至可以将这些服务放入云中，以进一步限制管理基础架构的必要性。这种方法允许您逐步将现有的整体应用转移到完全面向服务的体系结构中。让我们看看微服务方法。
# 微服务架构
微服务架构旨在解决我们提到的单片应用的问题。主要的区别在于，在单体应用中定义的服务被分解成单独的服务。最重要的是，它们彼此分开部署在不同的主机上。请看下图:
![](img/6730e15c-0f0c-4028-98dc-13f3e745cf56.jpg)
使用微服务架构创建应用时，每个微服务负责一个特定的业务功能，并且只包含执行特定业务逻辑所需的实现。这就像是一种**除**和**征服**的方式来创建一个系统。这可能看起来类似于面向服务架构。事实上，传统的 SOA 和微服务架构有一些共同的特征。两者都将应用的片段组织成服务，并且都定义了一个服务可以与另一个服务分离的清晰边界。然而，SOA 的根源在于需要将单个应用相互集成。这通常是使用一个通常基于 SOAP 的应用编程接口，使用大量的 XML 消息来完成的。在 SOA 中，这种集成严重依赖于中间的某种中间件，通常是**企业服务总线** ( **ESB** )。微服务架构也可以利用消息总线，但有很大的不同。在微服务体系结构中，消息传递层根本没有逻辑，它纯粹是用作消息从一个服务到另一个服务的传输。这与 ESB 完全不同，ESB 需要大量的逻辑来进行消息路由、模式验证、消息翻译等等。因此，微服务架构没有传统的 SOA 那么麻烦。
当涉及到扩展时，将微服务与单块应用进行比较会有很大的不同。微服务的主要优势在于，单个服务可以根据资源需求单独扩展。那是因为他们自给自足，独立自主。由于微服务通常部署在较小(就资源而言)的主机上；主机只需要包含服务正常运行所需的资源。随着资源需求的增长，横向和纵向扩展都很容易。为了水平扩展，您只需部署所需数量的实例来处理特定组件上的负载。
在接下来的章节中，我们将回到这个概念，那时我们将了解 Kubernetes。与单体系统相比，垂直扩展也更容易、更便宜，您只需升级部署微服务的主机。此外，引入新版本的服务很容易，你不需要为了升级一个功能而停止整个系统。事实上，你可以在飞行中完成。部署时，微服务提高了整个应用的容错能力。例如，如果一个服务出现内存泄漏或其他问题，只有这个服务会受到影响，然后可以修复和升级，而不会干扰系统的其他部分。单片架构的情况并非如此，一个有故障的组件可能会导致整个应用瘫痪。
从开发人员的角度来看，将应用拆分成单独的部分单独部署会带来巨大的优势。精通服务器端 JavaScript 的开发人员可以开发它的部分`node.js`，而系统的其余部分将使用 Java 开发。这都与每个微服务公开的 API 有关；除了这个 API，每个微服务都不需要知道其他服务的任何信息。这使得开发过程更加容易。独立的微服务可以独立开发和测试。基本上，微服务方法规定，不是有一个所有开发人员都在工作的巨大代码库，这通常变得很难管理，而是有几个由小型敏捷团队管理的更小的代码库。服务之间唯一的依赖是它们公开的 API。存储数据也是有区别的。正如我们之前所说的，每个微服务都应该负责存储自己的数据，因为同样，它应该是独立的。这导致了微服务体系结构的另一个特性，一种拥有多语种持久性的可能性。微服务应该拥有自己的数据。
虽然微服务使用 REST 端点或事件与其他微服务通信和交换数据，但它们可以以最适合作业的形式存储自己的数据。如果数据是关系型的，服务将使用传统的关系型数据库，如 MySQL 或 PostgreSQL。如果文档数据库更适合这项工作，例如，微服务可以使用 MongoDB，如果它是作为数据的图形，则可以使用 Neo4j。这导致了另一个结论，通过实现微服务架构，我们现在只能选择最适合这项工作的编程语言或框架，这也适用于数据存储。当然，拥有自己的数据会给微服务架构带来挑战，即数据一致性。我们将在这一章中讨论这个问题。
让我们从开发过程的角度总结一下使用微服务架构的好处:
*   可以使用各种语言、框架及其版本来编写服务
*   每个微服务都相对较小，更容易被开发人员理解(这导致更少的错误)，易于开发，并且可测试
*   部署和启动时间很快，这使得开发人员更有效率
*   每个服务可以由多个服务实例组成，以提高吞吐量和可用性
*   每个服务都可以独立于其他服务进行部署，更易于频繁部署新版本的服务
*   更容易组织开发过程；每个团队拥有并负责一个或多个服务，并且可以独立于所有其他团队开发、发布或扩展他们的服务
*   你可以选择任何你认为最适合这项工作的编程语言或框架。对技术栈没有长期的承诺。如果需要，可以在新的技术栈中重写服务，如果没有 API 更改，这对于系统的其余部分将是透明的
*   它更适合持续交付，因为小型单元更容易管理、测试和部署。只要每个团队保持向后和向前的应用编程接口兼容性，它就可以在与其他团队分离的发布周期中工作。在某些情况下，这些发布周期是相互关联的，但这种情况并不常见
# 保持数据一致性
服务必须松散耦合，以便能够独立开发、部署和扩展。他们当然需要交流，但他们是相互独立的。它们有定义良好的接口，并封装了实现细节。但是数据呢？在现实世界和非平凡的应用中(微服务应用可能是非平凡的)，业务事务必须经常跨越多个服务。例如，如果您创建了一个银行应用，在您执行客户的汇款指令之前，您需要确保它不会超过他的账户余额。整体应用附带的单一数据库给了我们很多便利:原子事务、寻找数据的单一位置等等。
另一方面，在微服务领域，不同的服务需要独立。这也意味着它们可以有不同的数据存储要求。对于某些服务，它将是一个关系数据库，其他服务可能需要一个文档数据库，如 MongoDB，它擅长存储复杂的非结构化数据。
因此，当构建微服务并将我们的数据库拆分成多个更小的数据库时，我们如何应对这些挑战？我们还说过，服务应该拥有自己的数据。也就是说，每个微服务应该只依赖于它自己的数据库。该服务的数据库实际上是该服务实现的一部分。这在设计微服务架构时带来了相当有趣的挑战。正如马丁·福勒在他的`Microservice trade-offs`专栏中所说:对于分布式系统来说，保持强一致性是极其困难的，这意味着每个人都必须管理最终的一致性。我们该如何应对？嗯，这都是关于界限的。
微服务应该有明确定义的责任和边界。
微服务需要根据其业务领域进行分组。此外，在实践中，您将需要以这样一种方式设计您的微服务，即它们不能直接连接到另一个服务拥有的数据库。松散耦合意味着微服务应该公开清晰的 API 接口，这些接口对数据和与这些数据相关的访问模式进行建模。他们必须坚持那些接口，当需要改变时，你可能会引入一个版本控制机制，并创建微服务的另一个版本。您可以使用发布/订阅模式将事件从一个微服务分派给其他微服务处理，如下图所示:
![](img/f32d5aff-cd71-467b-bf8b-794fdd5f380f.jpg)
您想要使用的发布/订阅机制应该为事件处理提供重试和回滚功能。在发布/订阅场景中，修改或生成数据的服务允许其他服务订阅事件。订阅的服务接收到数据已被修改的事件。通常情况下，事件包含已修改的数据。当然，事件发布/订阅模式不仅可以用于数据更改，还可以用作服务之间的通用通信机制。这是一个简单而有效的方法，但它有一个缺点，有可能会失去一个事件。