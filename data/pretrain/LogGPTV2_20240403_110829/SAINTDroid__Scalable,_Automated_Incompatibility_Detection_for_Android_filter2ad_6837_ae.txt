Lint
APC
(cid:3)(7)
(cid:3)
(cid:2)(3)(cid:3)(7)
(cid:3)(5)
(cid:3)(12)
(cid:2)(2)(cid:3)
(cid:3)(3)
(cid:2)(2)(cid:3)(2)
(cid:2)(1)(cid:3)(4)
0%
0%
0%
0%
0%
0%
2
9
30
In order to demonstrate the efﬁciency of each tool, we reported the analysis
time for each approach against all the 19 benchmark apps. Table 5.2 shows those
results, along with the maximum, minimum and average time to evaluate an app.
It is important to notice that all the unit of measurement is in second.
5.1 RQ1: Accuracy
For RQ1, we evaluated the ability of our tool to ﬁnd API invocation and callback
mismatches by comparing against CiD [51] ,Cider [46] and Lint [3]. We divide
the results into two parts, API invocation and callback mismatches, respectively.
API Invocation: We ﬁrst start utilizing the 12 apps that we were able to built
from [46] and applying GAINDroid, CiD and Lint to them.
As shown in Table 5.1, our approach reports less false positives and more true
positives than CiD and Lint.
Our approach and Lint were able to analyze all the 12 apps, while CiD did not
halt for 4 apps (AFWall, NetworkMonitor, NyaaPantsu and PassAndroid).
Comparing against CiD, GAINDroid shows much higher precision and compa-
rable recall, contributing for than double of F-Measure. CiD has a slightly higher
recall because the aforementioned tool ﬁnds less false negatives than GAINDroid.
However, GAINDroid identiﬁes less false positives than CiD. Thus, contributing
to higher precision. The tool Lint has higher precision than GAINDroid because
it has found no false positives (but only one true positive). However, it has found
many false negatives, corroborating for lower recall. Its F-Measure is 19 times
lower than GAINDroid. After this analysis and based on a higher F-Measure
compared to CiD and Lint, it is possible to conclude that GAINDroid indeed
better in ﬁnding API invocation mismatches, with a convincing number of true
31
positives and lower false positives and false negatives. Below we describe the
reasons that our approach found false positives and false negatives.
The apps Kolab notes, MaterialFbook and SimpleSolitaire are examples of false
positives and false negative, respectively. In the ﬁrst app, the false positive happens
because of the invocation of getFileName() in method onBindViewHolder(ViewHolder,
int) from class AttachmentRecyclerViewAdapter.
It is a call to a method which
belongs to an external library. Jitana understands this method as being part of
the API, searches for it in the database and does not ﬁn it. Therefore, generating a
false positive. We would have to identify in the static analysis framework, why
this error happens while decoding certain instructions. In the second app, The
false positive happens because a correctly guarded call to an Android API (line
27 and 29) in a private method in the MainActivity class is made from inside
an anonymous class (line 8), as shown in Listing 5.1. Finally, the false positive
in SimpleSolitaire is due to an error while decoding the instruction by the static
analysis framework. Jitana incorrectly identiﬁed a call to Checkable.setChecked,
which has been in the stack of Android frameworks since version 1, as a call to
TwoStatePreference.setChecked, which was introduced in API level 14. The false
negative happens because of the invocation of getUrl() in method onCreate from
class MainActivity of app MaterialFBook. The API is triggered by a method inside
an anonymous class. The decoding of anonymous class is a challenge that will
deﬁnitely improve our results once implemented. However, due to time limitation,
the identiﬁcation of anonymous classes will be left as future work. Furthermore, the
reason that Lint yield many false negatives is because it does not analyze methods
with the annotation @TargetApi or SuppressLint. For example, app PassAndroid
utilizes the mentioned annotation in the method doPrint in class PrintHelper. The
method uses android.print.PrintManager which was introduced only in API level 19.
32
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
@ O v e r r i d e
public boolean o n C r e a t e O p t i o n s M e n u ( Menu menu ) {
...
notif . s e t O n C l i c k L i s t e n e r ( new View . O n C l i c k L i s t e n e r () {
@ O v e r r i d e
public void onClick ( View v ) {
if ( Build . VERSION . SDK_INT >= Build . V E R S I O N _ C O D E S . L O L L I P O P )
c i r c l e R e v e a l ( v ) ;
m W e b V i e w . loadUrl ( baseURL + " n o t i f i c a t i o n s . php " ) ;
s e t T i t l e ( R . string . n a v _ n o t i f i c a t i o n s ) ;
Helpers . u n c h e c k R a d i o M e n u ( m N a v i g a t i o n V i e w . getMenu () ) ;
N o t i f i c a t i o n s J I S . C l e a r b y I d ( M a i n A c t i v i t y . this , 1) ;
}
}) ;
...
return true ;
}
@ S u p p r e s s W a r n i n g s ( " NewApi " )
private void c i r c l e R e v e a l ( int viewID , final boolean show ) {
final View v = f i n d V i e w B y I d ( viewID ) ;
int cy = v . g e t H e i g h t () / 2;
A n i m a t o r anim ;
if ( show )
anim = V i e w A n i m a t i o n U t i l s . c r e a t e C i r c u l a r R e v e a l (v , v . g e t W i d t h () , cy , 0 ,
v . g e t W i d t h () ) ;
else
anim = V i e w A n i m a t i o n U t i l s . c r e a t e C i r c u l a r R e v e a l (v , v . g e t W i d t h () , cy , v .
g e t W i d t h () , 0) ;
30
31
32
33
34
Listing 5.1: Perfectly guarded API invocation but identiﬁed as false positive
anim . start () ;
...
}
However, the app minSdkVersion is 14, then the aforementioned method can fail in
Android versions below 19.
GAINDroid also identiﬁes more true positives than CiD and Lint in some
scenarios. For instance, in the app Simple Solitaire, while CiD only reports only
one true positive and Lint none. Our approach has found two (method setChecked
from class TwoStatePreference in addition to onAttach from class Fragment). We have
noticed that CiD presents more false positives than our approach. During manual
veriﬁcation, it was possible to identify that CiD reports API invocation issues even
if they are bounded by conditions, in other words, using a guard. For example in
33
app SurvivalManual, where setTextIsSelectable(boolean) is only executed if the app
runs on a device with Android level greater or equal than 11.
The second app set-up consists of utilizing the 7 apps from [51]. As demon-
strated in Table 5.1, GAINDroid was able to ﬁnd all the errors reported by CiD.
Once again, Lint has only reported false negatives and the reason is all the API
methods causing errors are in methods annotated with @TargetApi or SuppressLint.
Therefore Lint will not check those methods.
With respect to API callback issues, as presented in Table 5.1, our approach
ﬁnds more true positives and less false positive errors compared to Cider and
Lint. This is expected because our approach is automatic and does not require
manually constructed callback control ﬂow graph as being done with Cider.
Cider also only detects 4 families of API callbacks (Activity, Fragment, Service
and WebView). Instead, GAINDroid relies on a database of Android methods
derived from each API level. Therefore, it can support a larger number of callback
APIs than the 24 within the 4 families of API callbacks supported by Cider. For
example, Cider ﬁnds 1 true positive for the app AFWall while GAINDroid ﬁnds 7
true positives. The reported result shows that callbacks such as PreferenceActivity,
ContentObserver and onAuthenticationError from classes that Cider does not support,
have been found as problematic. However, there are some callbacks that Jitana
cannot decode into its call-graph, generating false negative. For example, in apps
DuckDuckGo and Padland, both of these mismatches occur in anonymous classes
which override callbacks. As seen in Listing 5.2, app Padland, a callback that
can be invoked by the system but, it only exists in Android level 23 and further
versions. The app may fail when installed on devices below Android 23.
34
...
1 private WebView _ m a k e W e b V i e w () {
2
3
4
5
6
7
8
9
10
11
...
String [] u r l _ w h i t e l i s t = g e t S e r v e r W h i t e L i s t () ;
webView . s e t W e b V i e w C l i e n t ( new P a d L a n d S a f e r W e b V i e w C l i e n t ( u r l _ w h i t e l i s t ) {
@ O v e r r i d e
public void o n R e c e i v e d E r r o r ( WebView view , W e b R e s o u r c e R e q u e s t request ,
W e b R e s o u r c e E r r o r error ) {
super . o n R e c e i v e d E r r o r ( view , request , error ) ;
-- w e b v i e w _ h t t p _ c o n n e c t i o n s [0];
_ h i d e P r o g r e s s W h e e l () ;
Log . e ( TAG , " WebView (cid:32) Error (cid:32) " + error . t o S t r i n g () + " ,(cid:32) Request : (cid:32) " +
request . t o S t r i n g () ) ;
12
13
14
15
16
17
18 }
}
}
Listing 5.2: Callback being invoked inside an anonymous class
5.2 RQ2: Real-World Applicability
To evaluate the implications of our tool in practice, we applied GAINDroid to real-
world apps collected from [9] and [32]. GAINDroid detected 68,268 potential API
invocation mismatches, with 41.19% of the apps harboring at least one potential
mismatch. It also identiﬁed 2,115 potential API callback mismatches occurring in
20.05% of the apps under analysis. To perform the permission-induced mismatch
analysis, we divided the apps into two groups based on the target SDK version:
(i) 1,815 apps target Android API levels greater than or equal to 23 and (ii) 1,756
apps target Android API levels below 23. We identiﬁed a total of 1,430 apps
across both groups with at least one permissions-induced compatibility issue. 224
apps (12.34%) in the group (i) attempt to use dangerous permissions without
implementing the runtime permissions request system, and 1,206 apps (68.68%) in
the group (ii) are vulnerable to permissions revocation mismatches.
We then manually investigated the GAINDroid’s results to appraise its utility
in practice. In the following, we report some of our ﬁndings. To avoid revealing
35
previously unknown compatibility issues, we only disclose a subset of those that
we have had the opportunity to bring to the app developers’ attention.
API invocation mismatch. In the Ofﬂine Calendar app [30], the invocation of
the getFragmentManager() API method in PreferencesActivity.onCreate causes an API
invocation mismatch. The getFragmentManager() method was added to the Activity
class in API level 11. Also, Ofﬂine Calendar sets its minSdkVersion to API level 8.
Therefore, as soon as the PreferencesActivity is activated, the Ofﬂine Calendar app
will crash if running on API levels 8 to 11. The mismatch could be resolved by
wrapping the call to getFragmentManager() in a guard condition to only execute it
if the device’s API level is equal or greater than 11, or by setting the minSdkVersion
to 11.
API callback mismatch. FOSDEM [29] is a conference companion app.
It
exhibits an API callback mismatch in its ForegroundLinearLayout class, which
overrides the View.drawableHotspotChanged callback method, introduced in API
level 21. However, its minSdkVersion is set to API level 15, which would not support
the aforementioned callback method, and in turn may not properly propagate
the new hotspot location to the Drawable stored as a member of the layout class.
This could lead to crashes or other instability in the app’s interface. Setting the
minSdkVersion to 21 would resolve the mismatch.
Permission request mismatch. Kolab Notes [13] is a note-taking app that can
synchronize notes with other apps. It exhibits a permission request mismatch. The
app targets API 26 and uses the WRITE EXTERNAL STORAGE permission, but
does not implement the necessary methods to request the permission at runtime. If
the permission is not already granted when the user attempts to save or load data
to/from an SD card, the action will fail. To resolve the mismatch, the developers
should update the app to implement the new runtime permissions request system,
36
particularly the onRequestPermissionsResult callback.
Permission revocation mismatch. AdAway [1] is an ad blocking app that
suffers from a permission revocation mismatch. The app targets API level 22 and
uses the WRITE EXTERNAL STORAGE permission, which could be revoked by the
user when installed on a device running API 23 or greater. If the user revokes
the permission and tries to export a ﬁle, the app will crash. The developers could
resolve the issue by updating the app to use runtime permissions and setting the
minSdkVersion to 23.
5.3 RQ3: Performance
In this last research question, we evaluated the efﬁciency of GAINDroid and
compared its running time against CiD and Lint. Note that we could not compare
against the performance of Cider because the authors of that work neither reported
the analysis time of their technique nor made the tool available. Since Cider
authors have not replied to our inquiries, we were unable to measure its analysis
time.
Table 5.2 shows the analysis time (in seconds) of GAINDroid and the two
state-of-the-art tools mentioned above. Dashes indicate that a system fails to
produce analysis results after 600 seconds. As shown, the analysis time taken by
GAINDroid is signiﬁcantly lower than those of CiD and Lint for almost all the
apps. Also, note that CiD fails to completely analyze four apps after 600 seconds
have passed. The average analysis time taken by GAINDroid, CiD, and Lint per
app is 5.7, 22.9 and 17.4 seconds respectively, corroborating that GAINDroid can
efﬁciently vet Android apps for compatibility issues in a fraction of time taken by
the other state-of-the-art tools.
Table 5.2: Time comparison between GAINDroid
and state-of-the-art tools
37
App
AFWall
DuckDuckGo
FOSS Browser
Kolab notes
MaterialFBook
NetworkMonitor
NyaaPantsu
Padland
PassAndroid
SimpleSolitaire
SurvivalManual
Uber ride
Basic
Forward
GenericType
Inheritance
Protection
Protection2
Varargs
h
c
n
e
B
-
r
e
d
C
i