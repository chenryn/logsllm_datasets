The “boot” fastboot command loads and executes 
Android images deployed via USB
It was noted that verification and execution of the 
image were two separate functions
There was a high likelihood that the image could be 
changed between verification and execution
This could bypass bootloader unlocking protections 
while accessing the encrypted partition
Modifying Boot
The “boot” command receives the full Android “boot” image, via the fastboot
“download:” command
This is loaded into RAM, verified and executed
By patching the “boot” command, the behaviour could be altered for a TOCTOU attack
Instead of sending one image, two could be sent, and swapped after verification
A tool was created, which sent three pieces of data to achieve this: a four byte offset, a 
signed image, and an unsigned, malicious image
Patching In Functionality
The “boot” command does not function on locked bootloaders
The check for the lock state was replaced with an operation for moving the image pointer 
up by four bytes – to the signed image
The image at the moved pointer would then be verified
Patching In Functionality
Function calls occur between verification and 
booting
These are unnecessary to boot Android, and could 
be overwritten
This allowed for five spare instructions to be 
patched in
This would be sufficient to change to the unsigned 
image
Patching In Functionality
Four additional instructions were required:
• Move pointer back to start of payload - sub x19, x19, 4
• Read offset value - ldr w22, [x19]
• Add offset value to pointer - add x19, x19, x22
• Push new pointer value to “Info” structure “ImageBuffer” pointer - str x19, [x21,#0xa0]
These would be sufficient to swap the signed image with the unsigned image
Patching this code and executing it was found to be effective, facilitating the TOCTOU attack
This could allow for running unsigned Android images without unlocking the bootloader
Tethered Root
Unlocking the bootloader wipes all user data
Permanent rooting exposes the device to greater risk
A device being permanently rooted is not a necessity for most phone users
By deploying a rooted Android image via this TOCTOU attack, these problems can be 
resolved, as rebooting will remove the root capabilities
These can easily be generated using the Magisk app
Lockscreen Bypass
By accessing the unencrypted userdata partition, one 
can remove lockscreen restrictions
By using a custom recovery image, such as TWRP, or by 
modifying the Operating System, it is possible to gain 
access to all apps and stored data
Backdooring Encrypted Phones
Via developer functionality, further encryption can be placed on the userdata partition
This adds a password requirement, which forces a password to be input as the device is 
booting
The Android “boot” image, where the kernel and root filesystem are stored, is not encrypted
It is possible to add a reverse shell to the image, to access the data later
Backdooring Encrypted Phones
Disclosure and Impact
The TOCTOU attack was disclosed to Qualcomm
The attack was only possible with the initial buffer overflow vulnerability
Patching of the phone to prevent this attack would be difficult, due to its usage of internal, 
unmodifiable APIs
These weaknesses could allow an attacker with physical access to an SDM660-based 
phone to bypass all bootloader locking mechanisms
Project Two – The NXP PN Series
The NXP PN series is a set of chips used for NFC communication in smartphones and 
embedded electronics
By breaking the firmware protections on these chips, one could add new NFC capabilities
The NXP PN series is extremely popular in smartphones, and any exploits would be 
transferrable to a large number of devices
NXP PN553
NFC chip used solely in mobile devices
PN553 bears similarities with the PN547, PN548, PN551 and PN5180
All use a similar firmware update files and protocol
All use ARM Cortex-M architecture
Little public research available
Protocol
Communicates via I2C interface - /dev/nq-nci
Utilises NCI for NFC communication, the standard NFC protocol 
Custom protocol in use for firmware updates
Communication can be traced via ADB logcat
Forcing Firmware Updates
Tracing firmware updates can help in reverse engineering the protocol in use
Firmware updates only occur when signed firmware versions differ
Base Android image contains a main firmware image and recovery image
libpn553_fw.so
libpn553_rec.so
Swapping these files can force the update to occur
Each function can be traced against source code
Bootloader Firmware Update Protocol
Unique to NXP chips
Structure:
1 byte: Status
1 byte: Size
1 byte: Command
x bytes: Parameters
2 bytes: CRC-16
Encapsulated in 0xfc byte chunks for 
large payloads
Interfacing with device files
Reads and writes to /dev/nq-nci translate to communication over I2C
Chip can be configured via IOCTL functions
These can set power mode and enable/disable firmware update mode
Firmware File Format
Firmware files are kept in ELF files – libpn553_fw.so
This file has one sector, which contains binary formatted data
This data contains the commands that run in sequence for firmware updates
These commands can be extracted to rebuild the firmware image
Firmware Update Process
The C0 write command is used throughout
The first command contained unknown, high entropy data
All subsequent commands contained a 24-bit address, 16-bit 
size, data payload, and an unknown hash
These commands were required to be sent in the sequence 
they were stored in the update file
Stitching Firmware Updates
Memory addresses at the start of commands aided 
reconstruction of firmware
Firmware data was very small
Multiple references to code in inaccessible memory 
locations were noted
The core system functionality was likely to be stored in the 
bootloader
Memory Read Commands
Two commands were found to read back memory from the chip – A2 and E0
A2 was found to read memory from a provided address – limited only to memory that 
could be written during firmware updates
E0 was found to calculate checksums of memory, and provide four bytes of configuration 
data
RSA Public Key
Large block of random data was referenced in E0 memory dump – sized 0xC0
0x10001 (65537) was found after this block
These could be the modulus and exponent for a public RSA key
This size aided in identifying the signature of the firmware update
Additional Write Command
Command A7 was found to allow writing to 64 bytes of configuration memory
This memory had no bearing on any functionality, and its size was restricted
This was likely to be used for logging of data during updates
Unknown Hash
Block write commands end with a 256-bit hash
This was assumed to be SHA-256, but did not match the contents of the packet
Multiple other hashing algorithms were attempted, with no valid results
It was identified that the hash was for the next block in the sequence
Hashing Process
The first C0 command contains a version number, SHA-256 hash, and signature of the hash
This is a hash of the next block, which contains an additional hash
This cascades through the firmware update, with each subsequent block having a 
matching hash
This guarantees that all written blocks are valid, without verifying the entire update at 
once
The final block has no hash, because it has no subsequent block
Fuzzing
Targeted fuzzing was performed on both the Firmware Update and NCI interfaces
The chip was found to contain hidden, vendor-specific configs, accessible via the standard 
NCI Config Write command
Bitwise incrementing values were written to these configurations, which prevented the 
main firmware from continuing to function, bricking the core functionality of the chip
The bootloader still functioned, but the configurations could not be overwritten
Weaknesses in the Firmware Update Process
It was noted that the last block of the firmware update could be written multiple times, 
despite the hash-chain
This implied that the hash of the previous block remained in memory
There was a potential opportunity for overwriting this hash in memory
An invalid command, the same size as a firmware update block, was sent between these 
packets
This prevented the last block from being written, implying the hash had been overwritten 
in memory
Bypassing Signature Verification
Modified hashes could be written in the right portion of 
memory
The ability to overwrite the hash meant that the hash chain 
could be broken
This would allow writing of arbitrary memory blocks to the 
chip, by generating a valid hash
This could bypass the signature verification mechanisms of 
firmware updates, and allow us to overwrite the broken 
config
Repairing the Firmware
Using a dump of the working config, the new config could be hashed and written
This repaired the chip, and proved that arbitrary memory writes were possible
The next goal was to dump the bootloader from the chip
Patching New Features
All standard functions were stored in the bootloader, with limited functionality in the 
firmware update
The NCI Version Number command was part of the firmware update
The version number was easy to identify in memory, and its function references
A function was called using the version number and a pointer
This was identified to be a memcpy function
Patching New Features
The Branch instruction to the function could be overridden to point to a 
custom function
Using C and the gcc “-c” flag, a custom function could be written
Its effect on the version number command could be observed after 
flashing
The lack of data in the response implied that it was a memcpy for the 
return message
Patching New Features
The location of RAM was assumed to be at 0x100000, due to 
the firmware referencing this address space
The overridden memcpy was changed to search for a unique 
value in RAM, sent  in the NCI command
This provided a global pointer to command parameters at 
0x100007
This could then set a pointer to arbitrary memory
Using this functionality, the bootloader could be dumped
Dumping The Bootloader
The entire memory was stitched from the read commands
This could be disassembled, demonstrating it was valid
This functionality could be extended to modify the core NFC functionality of the chip
Replicating The Vulnerability – PN5180
The PN5180 is a chip often used by hobbyists for NFC connectivity
It has a similar architecture to the PN553, but uses a custom communication protocol
Can be communicated with via an SPI interface and GPIO pins
The firmware update process was the same, allowing the signature bypass to be replicated
Replicating The Vulnerability – PN5180
A command in the chip’s communication protocol read memory from a specific part of the 
EEPROM
This pointer was found in the firmware payload
By overwriting this and redeploying the firmware, the chip’s bootloader could be read, 
without functional code changes
Impact
The vulnerability was likely to be available on similar chipsets
This could allow an attacker with access to firmware updates to completely take over the 
chips
This would provide the capability to add custom and malicious NFC functionality
On smartphones, this would require full root access to the device
In hobbyist projects, this would expand the capabilities of the chip
Disclosure
The vulnerability was disclosed to NXP in June 2020
They confirmed that it affected multiple chips in their product line
A long remediation period was requested, with public release permitted in August 2021
Alteration of a primary bootloader is a complex task, which could risk bricking the chip
The current generation of NXP NFC products, including the SN series, are not affected
Remediation across all affected chipsets was performed in phased rollouts
Conclusion
Special thanks to Qualcomm and NXP for remediating the findings
Firmware signature protection is only as good as its implementation
Common chips are great targets, as they have high impact 
Bootloader vulnerabilities are common, even in popular hardware
End