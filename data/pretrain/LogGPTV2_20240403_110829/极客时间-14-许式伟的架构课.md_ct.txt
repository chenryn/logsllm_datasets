# 63 \| 接口设计的准则  你好，我是七牛云许式伟。   上一讲 " [62 \|重新认识开闭原则 (OCP)"我们介绍了开闭原则。这一讲的内容非常非常重要，可以说是整个架构课的灵魂。总结来说，开闭原则包含以下两层含义：   第一，模块的业务要稳定。模块的业务遵循 "只读"设计，如果需要变化不如把它归档，放弃掉。这种模块业务只读的思想，是架构治理的基础哲学。我平常和小伙伴们探讨模块边界的时候，经常会说这样一句话：   slate-type="block-quote"   每一个模块都应该是可完成的。   这实际上是开闭原则的业务范畴 "只读"的架构治理思想的另一种表述方式。   第二，模块业务的变化点，简单一点的，通过回调函数或者接口开放出去，交给其他的业务模块。复杂一点的，通过引入插件机制把系统分解为"最小化的核心系统 +多个彼此正交的周边系统"。事实上回调函数或者接口本质上就是一种事件监听机制，所以它是插件机制的特例。   今天，我们想聊聊怎么做接口设计。   不过在探讨这个问题前，我想和大家探讨的第一个问题是：什么是接口？   你可能会觉得这个问题挺愚蠢的。毕竟这几乎是我们嘴巴里天天会提及的术语，会不知道？但让我们用科学家的严谨作风来看待这个问题。接口在不同的语义环境下，主要有两个不同含义。   一种是模块的使用界面，也就是规格，比如公开的类或函数的原型。我们前面在这个架构课中一直强调，模块的接口应该自然体现业务需求。这里的接口，指的就是模块的使用界面。   另一种是模块对依赖环境的抽象。这种情况下，接口是模块与模块之间的契约。在架构设计中我们经常也会听到"契约式设计（Design by Contract）"这样的说法，它鼓励模块与模块的交互基于接口作为契约，而不是依赖于具体实现。   对于这两类的接口语义，我们分别进行讨论。 模块的使用界面  对于模块的使用界面，最重要的是 KISS原则，让人一眼就明白这个模块在做什么样的业务。   KISS 的全称是 Keep it Simple,Stupid，直译是简单化与傻瓜化。用土话来说，就是要"让傻子也能够看得懂"，追求简单自然，符合惯例。   这样说比较抽象，我们拿七牛开源的 mockhttp项目作为例子进行说明。   这个项目早期的项目地址为：      slate-type="list-line" 代码主页：https://github.com/qiniu/mockhttp.v1   slate-type="list-line" 文档主页：https://godoc.org/github.com/qiniu/mockhttp.v1  最新的项目地址变更为：      slate-type="list-line" 代码主页：https://github.com/qiniu/x/tree/master/mockhttp   slate-type="list-line" 文档主页：https://godoc.org/github.com/qiniu/x/mockhttp  mockhttp 是做什么的呢？它用于启动 HTTP服务作为测试用途。   当然 Go 的标准库 net/http/httptest  slate-object="inline"已经有自己的 HTTP服务启动方法，如下：    key="505" code-language="go"}  }                             .ps .ps--active-x}   slate-type="code-line" package]{.gkhl-keywordannotation-key="gkann_3250458771"annotation-type="annotation"}first-offset="true"}[[ httptestoffset-key="507:1"}]{   slate-type="code-line" ]{   slate-type="code-line" type]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_5231443188"annotation-type="annotation"}first-offset="true"}[[ Server offset-key="511:1"}struct]{.gkhl-keywordannotation-key="gkann_9697157493"annotation-type="annotation"}] offset-key="511:2"}[[{offset-key="511:3"}]{   slate-type="code-line"  URL first-offset="true"}string]{.gkhl-keywordannotation-key="gkann_2004953925"annotation-type="annotation"}offset-key="513:1"}]{   slate-type="code-line"  \...    slate-type="code-line" }    slate-type="code-line" ]{   slate-type="code-line" func]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_4449160284"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_9416825360"annotation-type="annotation"}first-offset="true"} ]{.gkhl-functionannotation-key="gkann_9416825360"annotation-type="annotation"}offset-key="521:1"}[NewServer]{.gkhl-functionannotation-key="gkann_9416825360"annotation-type="annotation"}]{.gkhl-title slate-object="annotation"annotation-key="gkann_8974941532"annotation-type="annotation"}offset-key="521:2"}[(servicehttp.Handler)]{.gkhl-paramsannotation-key="gkann_6960429263"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_9416825360"annotation-type="annotation"}] offset-key="521:3"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_9416825360"annotation-type="annotation"}offset-key="521:4"}[(ts\*Server)]{.gkhl-functionannotation-key="gkann_9416825360"annotation-type="annotation"}]{.gkhl-params slate-object="annotation"annotation-key="gkann_9625668167"annotation-type="annotation"}offset-key="521:5"}]{   slate-type="code-line" func]{.gkhl-title slate-object="annotation"annotation-key="gkann_0212375215"annotation-type="annotation"}first-offset="true"}[[ offset-key="523:1"}(ts \*Server)]{.gkhl-paramsannotation-key="gkann_7983989388"annotation-type="annotation"}] offset-key="523:2"}[[offset-key="523:3"}Close]{.gkhl-titleannotation-key="gkann_5013144313"annotation-type="annotation"}offset-key="523:4"}()]{.gkhl-paramsannotation-key="gkann_9814679208"annotation-type="annotation"}offset-key="523:5"}]{ {.ps__rail-x style="width: 365px; left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 348px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}  httptest.NewServer 分配一个空闲可用的 TCP 端口，并将它与传入的 HTTP服务器关联起来。最后我们得到的 ts.URL就是服务器的访问地址。使用样例如下：    key="526" code-language="go"}  }                                   .ps}   slate-type="code-line" import]{.gkhl-keywordannotation-key="gkann_2214949398"annotation-type="annotation"}first-offset="true"}[[ offset-key="528:1"}\"net/http\"]{.gkhl-stringannotation-key="gkann_3051187924"annotation-type="annotation"}offset-key="528:2"}]{   slate-type="code-line" import]{.gkhl-keywordannotation-key="gkann_5848498936"annotation-type="annotation"}first-offset="true"}[[ offset-key="530:1"}\"net/http/httptest\"]{.gkhl-stringannotation-key="gkann_2800177330"annotation-type="annotation"}offset-key="530:2"}]{   slate-type="code-line" ]{   slate-type="code-line" func]{.gkhl-functionannotation-key="gkann_5287258261"annotation-type="annotation"}]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_1285356430"annotation-type="annotation"}first-offset="true"} ]{.gkhl-functionannotation-key="gkann_5287258261"annotation-type="annotation"}offset-key="534:1"}[TestXXX]{.gkhl-functionannotation-key="gkann_5287258261"annotation-type="annotation"}]{.gkhl-title slate-object="annotation"annotation-key="gkann_6034642473"annotation-type="annotation"}offset-key="534:2"}[(t\*testing.T)]{.gkhl-functionannotation-key="gkann_5287258261"annotation-type="annotation"}]{.gkhl-params slate-object="annotation"annotation-key="gkann_7111649636"annotation-type="annotation"}] offset-key="534:3"}[[{offset-key="534:4"}]{   slate-type="code-line"  service := \...  first-offset="true"}// HTTP业务服务器]{.gkhl-commentannotation-key="gkann_4396607755"annotation-type="annotation"}offset-key="536:1"}]{   slate-type="code-line"  ts :=httphtest.NewServer(service)    slate-type="code-line"  first-offset="true"}defer]{.gkhl-keywordannotation-key="gkann_3113436162"annotation-type="annotation"}] offset-key="540:1"}[[ts.Close()offset-key="540:2"}]{   slate-type="code-line" ]{   slate-type="code-line"  resp, err := http.Get(ts.URL +first-offset="true"}\"/foo/bar\"]{.gkhl-stringannotation-key="gkann_5145811291"annotation-type="annotation"}offset-key="544:1"}[[)offset-key="544:2"}]{   slate-type="code-line"  \...    slate-type="code-line" }  {.ps__rail-x style="left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 0px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}  mockhttp 有所不同，它并不真的启动 HTTP服务，没有端口占用。这里我们不谈具体的原理，我们看接口。mockhttp.v1版本的使用界面如下：    key="551" code-language="go"}  }                 .ps}   slate-type="code-line" package]{.gkhl-keywordannotation-key="gkann_6244663685"annotation-type="annotation"}first-offset="true"}[[ mockhttpoffset-key="553:1"}]{   slate-type="code-line" ]{   slate-type="code-line" var]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_0406968424"annotation-type="annotation"}first-offset="true"}[[ Clientrpc.Clientoffset-key="557:1"}]{   slate-type="code-line" ]{   slate-type="code-line" func]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_7160958029"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_6665867274"annotation-type="annotation"}first-offset="true"} ]{.gkhl-functionannotation-key="gkann_6665867274"annotation-type="annotation"}offset-key="561:1"}[Bind]{.gkhl-titleannotation-key="gkann_8602487845"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_6665867274"annotation-type="annotation"}offset-key="561:2"}[(host string, serviceinterface{})]{.gkhl-paramsannotation-key="gkann_4310662414"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_6665867274"annotation-type="annotation"}offset-key="561:3"}]{ {.ps__rail-x style="left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 0px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}  这里比较古怪的是 service，它并不是 http.Handler类型。它背后做了一件事情，就是帮 service 这个 HTTP服务器自动实现请求的路由分派能力。这有一定的好处，使用上比较便捷：    key="564" code-language="go"}  }                          .ps .ps--active-x}   slate-type="code-line" import]{.gkhl-keywordannotation-key="gkann_9463303819"annotation-type="annotation"}first-offset="true"}[[ offset-key="566:1"}\"github.com/qiniu/mockhttp.v1\"]{.gkhl-stringannotation-key="gkann_3363901566"annotation-type="annotation"}offset-key="566:2"}]{   slate-type="code-line" ]{   slate-type="code-line" func]{.gkhl-functionannotation-key="gkann_1839439005"annotation-type="annotation"}]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_3726301885"annotation-type="annotation"}first-offset="true"} ]{.gkhl-functionannotation-key="gkann_1839439005"annotation-type="annotation"}offset-key="570:1"}[TestXXX]{.gkhl-functionannotation-key="gkann_1839439005"annotation-type="annotation"}]{.gkhl-title slate-object="annotation"annotation-key="gkann_3363085492"annotation-type="annotation"}offset-key="570:2"}[(t\*testing.T)]{.gkhl-paramsannotation-key="gkann_8319578005"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_1839439005"annotation-type="annotation"}] offset-key="570:3"}[[{offset-key="570:4"}]{   slate-type="code-line"  service := \...  first-offset="true"}// HTTP业务服务器]{.gkhl-commentannotation-key="gkann_0091647086"annotation-type="annotation"}offset-key="572:1"}]{   slate-type="code-line"  mockhttp.Bind(first-offset="true"}\"example.com\"]{.gkhl-stringannotation-key="gkann_4369865942"annotation-type="annotation"}] offset-key="574:1"}[[,service)offset-key="574:2"}]{   slate-type="code-line"  resp, err :=mockhttp.Client.Get(first-offset="true"}\"http://example.com/foo/bar\"]{.gkhl-stringannotation-key="gkann_7338132328"annotation-type="annotation"}offset-key="576:1"}[[)offset-key="576:2"}]{   slate-type="code-line"  \...    slate-type="code-line" }  {.ps__rail-x style="width: 365px; left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 266px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}  但是它有两个问题。   一个问题是关于模块边界上的。严谨来说 mockhttp.v1 并不符合"单一职责原则（SRP）"。它干了两个业务：      slate-type="list-line" 启动 HTTP 测试服务；    slate-type="list-line" 实现 HTTP服务器请求的路由分派。   另一个是关于接口的 KISS 原则。mockhttp.Bind虽然听起来不错，也很简单，但实际上并不符合 Go 语言的惯例语义。另外就是mockhttp.Client 变量。按 Go 语义的惯例它可能叫 DefaultClient会更好一些，另外它的类型是 rpc.Client，而不是http.Client，这样方便是方便了，但却产生了多余的依赖。   mockhttp.v1这种业务边界和接口的随意性，一定程度上是因为它是测试用途，所以有点怎么简单怎么来的意思。但是后来的发展表明，所有的偷懒总会还回来的。于是就有了mockhttp.v2 版本。这个版本在我们做小型的 package 合并时，把它放到了https://github.com/qiniu/x 这个 package中。接口如下：    key="594" code-language="go"}  }                    .ps .ps--active-x}   slate-type="code-line" package]{.gkhl-keywordannotation-key="gkann_2841495284"annotation-type="annotation"}first-offset="true"}[[ mockhttpoffset-key="596:1"}]{   slate-type="code-line" ]{   slate-type="code-line" var]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_3455742347"annotation-type="annotation"}first-offset="true"}[[ DefaultTransport\*Transportoffset-key="600:1"}]{   slate-type="code-line" var]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_2432609968"annotation-type="annotation"}first-offset="true"}[[ DefaultClient\*http.Clientoffset-key="602:1"}]{   slate-type="code-line" ]{   slate-type="code-line" func]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_0734310477"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_5677346051"annotation-type="annotation"}first-offset="true"} ]{.gkhl-functionannotation-key="gkann_5677346051"annotation-type="annotation"}offset-key="606:1"}[ListenAndServe]{.gkhl-titleannotation-key="gkann_3818258210"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_5677346051"annotation-type="annotation"}offset-key="606:2"}[(host string, servicehttp.Handler)]{.gkhl-paramsannotation-key="gkann_7707880477"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_5677346051"annotation-type="annotation"}offset-key="606:3"}]{ {.ps__rail-x style="width: 365px; left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 316px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}  这里暴露的方法和变量，一方面 Go 程序员一看即明其义，另一方面语义上和Go 标准库既有的 HTTP package可自然融合。它的使用方式如下：    key="609" code-language="go"}  }                          .ps .ps--active-x}   slate-type="code-line" import]{.gkhl-keywordannotation-key="gkann_3054076458"annotation-type="annotation"}first-offset="true"}[[ offset-key="611:1"}\"github.com/qiniu/x/mockhttp\"]{.gkhl-stringannotation-key="gkann_5415325168"annotation-type="annotation"}offset-key="611:2"}]{   slate-type="code-line" ]{   slate-type="code-line" func]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_4579186533"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_9589305491"annotation-type="annotation"}first-offset="true"} ]{.gkhl-functionannotation-key="gkann_9589305491"annotation-type="annotation"}offset-key="615:1"}[TestXXX]{.gkhl-titleannotation-key="gkann_0060651897"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_9589305491"annotation-type="annotation"}offset-key="615:2"}[(t\*testing.T)]{.gkhl-functionannotation-key="gkann_9589305491"annotation-type="annotation"}]{.gkhl-params slate-object="annotation"annotation-key="gkann_3078010393"annotation-type="annotation"}] offset-key="615:3"}[[{offset-key="615:4"}]{   slate-type="code-line"  service := \...  first-offset="true"}// HTTP业务服务器]{.gkhl-commentannotation-key="gkann_8698136307"annotation-type="annotation"}offset-key="617:1"}]{   slate-type="code-line"  mockhttp.ListenAndServe(first-offset="true"}\"example.com\"]{.gkhl-stringannotation-key="gkann_0504607575"annotation-type="annotation"}] offset-key="619:1"}[[,service)offset-key="619:2"}]{   slate-type="code-line"  resp, err :=mockhttp.DefaultClient.Get(first-offset="true"}\"http://example.com/foo/bar\"]{.gkhl-stringannotation-key="gkann_2210563240"annotation-type="annotation"}offset-key="621:1"}[[)offset-key="621:2"}]{   slate-type="code-line"  \...    slate-type="code-line" }  {.ps__rail-x style="width: 365px; left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 240px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}  从上面的例子可以看出，我们说接口要KISS，要简单自然，这里很重要的一点是符合语言和社区的惯例。如果某类业务在语言中已经有约定俗成的接口，我们尽可能沿用相同的接口语义。 模块的环境依赖  接口的另一种含义是模块对依赖环境的抽象，也就是模块与模块之间的契约。我们大部分情况下提到的接口，指的是这一点。   模块的环境依赖，也分两种，一种是使用界面依赖，一种是实现依赖。所谓使用界面依赖是指用户在使用该模块的使用界面时自然涉及的。所谓实现依赖则是指模块当前实现方案中涉及到的组件，它带来的依赖条件。如果我换一种实现方案，这类依赖可能就不再存在，或者变成另外的依赖。   在环境依赖上，我们遵循的是 "最小依赖原则"，或者叫"最少知识原则（Least KnowledgePrinciple，LKP）"，去尽可能发现模块中多余的依赖。   具体到细节，使用界面依赖与实现依赖到处置方式往往还是有所不同。   从使用界面依赖来说，我们接口定义更多考虑的往往是对参数的泛化与抽象，以便让我们可以适应更广泛的场景。   比如，我们前面谈到 IO 系统的时候，把存盘与读盘的接口从 \*.os.File换成io.Reader、io.Writer，以获得更强的通用性，比如对剪贴板的支持。   类似的情况还有很多，一个接口的参数类型稍加变化，就会获得更大的通用性。再比如，对于上面mockhttp.v1 中 rpc.Client 这个接口就存在多余的依赖，改为 http.Client会更好一些。   不过有的时候，我们看起来从接口定义似乎更加泛化，但是实际上却是场景的收紧，这需要特别注意避免的。比如上面mockhttp.v1 的接口：    key="646" code-language="go"}  }     .ps}   slate-type="code-line" func]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_0923936935"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_8341458914"annotation-type="annotation"}first-offset="true"} ]{.gkhl-functionannotation-key="gkann_8341458914"annotation-type="annotation"}offset-key="648:1"}[Bind]{.gkhl-titleannotation-key="gkann_4865414143"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_8341458914"annotation-type="annotation"}offset-key="648:2"}[(host string, serviceinterface{})]{.gkhl-paramsannotation-key="gkann_6983148720"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_8341458914"annotation-type="annotation"}offset-key="648:3"}]{ {.ps__rail-x style="left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 0px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}  与 mockhttp.v2 的接口：    key="651" code-language="go"}  }     .ps .ps--active-x}   slate-type="code-line" func]{.gkhl-keyword slate-object="annotation"annotation-key="gkann_2403809682"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_7310555557"annotation-type="annotation"}first-offset="true"} ]{.gkhl-functionannotation-key="gkann_7310555557"annotation-type="annotation"}offset-key="653:1"}[ListenAndServe]{.gkhl-titleannotation-key="gkann_8814251615"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_7310555557"annotation-type="annotation"}offset-key="653:2"}[(host string, servicehttp.Handler)]{.gkhl-paramsannotation-key="gkann_8863361796"annotation-type="annotation"}]{.gkhl-function slate-object="annotation"annotation-key="gkann_7310555557"annotation-type="annotation"}offset-key="653:3"}]{ {.ps__rail-x style="width: 365px; left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 316px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}  看似 v1 版本类型用的是 interface{}，形式上更加泛化，但实际上 v1版本有更强的假设，它内部通过反射机制实现了 HTTP 服务器请求的路由分派。而v2 版本对 service 则用的是 HTTP服务器的通用接口，是更加恰如其分的描述方式。   当然，在接口参数的抽象上，也不适合过度。如果某种泛化它不会发生，那就是过度设计。不要一开始就把系统设计得非常复杂，而陷入"过度设计"的深渊。应该让系统足够的简单，而却又不失扩展性，这其中的平衡完全依赖你对业务的理解，它是一个难点。   聊完使用界面依赖，我们接着聊实现依赖。   从模块实现的角度，我们环境依赖有两个选择：一个是直接依赖所基于的组件，一个是将所依赖的组件所有被引用的方法抽象成一个接口，让模块依赖接口而不是具体的组件。   那么，这两种方式应该怎么选择？   我的建议是，大部分情况下应该选择直接依赖组件，而不必去抽象它。   如无必要，勿增实体。   如果我们大量抽象所依赖的基础组件，意味着我们系统的可配置性（Configurable）更好，但学习成本也更高。   什么时候该当考虑把依赖抽象化？   其一，在需要提供多种选择的时候。比较典型的是日志的 Logger组件。对于绝大部分的业务模块，都并不希望绑定 Logger的选择，把决策权交给使用方。   但是有的时候，在这一点上过度设计也会比较常见。比如，不少业务模块会选择抽象对数据库的依赖，以便于在MySQL 和 MongoDB之间自由切换。但这种灵活性绝大部分情况下是一种过度设计。选择数据库应该是非常谨慎严谨的行为。   其二，在需要解除一个庞大的外部系统的依赖时。有时候我们并不是需要多个选择，而是某个外部依赖过重，我们测试或其他场景可能会选择mock一个外部依赖，以便降低测试系统的依赖。   其三，在依赖的外部系统为可选组件时。这个时候模块会实现一个 mock的组件，并在初始化时将接口设置为 mock组件。这样的好处是，除非用户关心，否则客户可以当模块不存在这个可选的配置项，这降低了学习门槛。   整体来说，对模块的实现依赖进行接口抽象，本质是对模块进行配置化，增加很多配置选项，这样的配置化需要谨慎，适可而止。 结语  接口设计是一个老生常谈的话题。接口有分模块的使用界面和模块的环境依赖这两种理解。   对于模块的使用界面，我们推崇 KISS原则，简单自然，符合业务表达的惯例。   对于模块的环境依赖，我们遵循的是 "最小依赖原则"，或者叫"最少知识原则（Least KnowledgePrinciple，LKP）"，尽可能发现模块中多余的依赖。   如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们的话题是"不断完善的架构范式"。   如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。 
# 64 \| 不断完善的架构范式  你好，我是七牛云许式伟。  我们在 " [62 \|重新认识开闭原则 (OCP)"这一讲中介绍了开闭原则。这篇内容非常非常重要，可以说是整个架构课的灵魂。  总结来说，开闭原则包含以下两层含义：  第一，模块的业务要稳定。模块的业务遵循 "只读"设计，如果需要变化不如把它归档，放弃掉。这种模块业务只读的思想，是架构治理的基础哲学。我平常和小伙伴们探讨模块边界的时候，经常会说这样一句话：  slate-type="block-quote"   每一个模块都应该是可完成的。  这实际上是开闭原则的业务范畴 "只读"的架构治理思想的另一种表述方式。  第二，模块业务的变化点，简单一点的，通过回调函数或者接口开放出去，交给其他的业务模块。复杂一点的，通过引入插件机制把系统分解为"最小化的核心系统 +多个彼此正交的周边系统"。事实上回调函数或者接口本质上就是一种事件监听机制，所以它是插件机制的特例。  上一讲我们介绍了接口设计。到此为止，我们的架构思维篇也已经基本接近尾声。可能有人会越来越奇怪，为什么我还是没有去聊那些大家耳熟能详的架构设计原则？  实际上，并不是这些架构设计原则不好，它们之中不乏精彩绝伦、振聋发聩的总结。比如：     slate-type="list-line" 接口隔离原则（Interface SegregationPrinciple，ISP）：一个模块与另一个模块之间的依赖性，应该依赖于尽可能小的接口。   slate-type="list-line" 依赖倒置原则（Dependence InversionPrinciple，DIP）：高层模块不应该依赖于低层模块，它们应该依赖于抽象接口。   slate-type="list-line" 无环依赖原则（Acyclic DependenciesPrinciple，ADP）：不要让两个模块之间出现循环依赖。怎么解除循环依赖？见上一条。   slate-type="list-line" 组合 / 聚合复用原则（Composition/Aggregation ReusePrinciple，CARP）：当要扩展功能时，优先考虑使用组合，而不是继承。   slate-type="list-line" 高内聚与低耦合（High Cohesion and LowCoupling，HCLC）：模块内部需要做到内聚度高，模块之间需要做到耦合度低。这是判断一个模块是在做一个业务还是多个业务的依据。如果是在做同一个业务，那么它所有的代码都是内聚的，相互有较强的依赖。   slate-type="list-line" 惯例优于配置（Convention overConfiguration，COC）：灵活性会增加复杂性，所以除非这个灵活性是必须的，否则应尽量让惯例来减少配置，这样才能提高开发效率。如有可能，尽量做到"零配置"。    slate-type="list-line" 命令查询分离（Command QuerySeparation，CQS）：读写操作要分离。在定义接口方法时，要区分哪些是命令（写操作），哪些是查询（读操作），要将它们分离，而不要揉到一起。   slate-type="list-line" 关注点分离（Separation ofConcerns，SOC）：将一个复杂的问题分离为多个简单的问题，然后逐个解决这些简单的问题，那么这个复杂的问题就解决了。当然这条说了等于没说，难在如何进行分离，最终还是归结到对业务的理解上。  这些都是很好很好的。但是，我们需要意识到的一点是，熟读架构思维并不足以让我们成为优秀的架构师。  要始终记住的一点是，我们做的是软件工程。软件工程的复杂性它自然存在，不会因为好的架构思维而消除。  所以虽然理解架构思维是非常重要的，但是架构师真正的武器库并不是它们。  那么架构师的武器库是什么？  这就要从 "架构治理"开始谈起。   前面我们说过，"开闭原则" 推崇模块业务 "只读"的思想，是很好的架构治理哲学。它告诉我们，软件是可以以 "搭积木"的方式搭出来的。  核心的一点是，我们如何形成更多的"积木"，即一个个业务只读、接口稳定、易于组合的模块。  所以，真正提高我们工程效率的，是我们的业务分解能力和历史积累的成果。  前面我们说过，架构分解中有两大难题：其一，需求的交织。不同需求混杂在一起，也就是存在所谓的全局性功能。其二，需求的易变。不同客户，不同场景下需求看起来很不一样，场景呈发散趋势。  在 " [61 \|全局性功能的架构设计"这一讲我们重点聊的是第一点。对于全局性功能怎么去拆解，把它从我们的业务中剥离出来，并无统一的解决思路。  但好的一点是，绝大部分全局性功能都会有很多人去拆解，并最终会被基础设施化。所以具体业务中我们会碰到的全局性功能并不会非常多。  比如，怎么做用户的鉴权？怎么保障软件 24小时持续服务？怎么保障快速定位用户反馈的问题？这些需求和所有业务需求是交织在一起的，也足够普适，所以就会有很多人去思考对应的解决方案。  作为架构师，心性非常重要。  架构师需要有自己的信仰。我们需要坚持对业务进行正交分解的信念，要坚持不断地探索各类需求的架构分解方法。这样的思考多了，我们就逐步形成了各种各样的架构范式。  这些架构范式，并不仅仅是一些架构思维，而是"一个个业务只读、接口稳定、易于组合的模块 +组合的方法论"，它们才是架构师真正的武器库。  这个武器库包含哪些内容？  首先，它应该包括信息科技形成的基础架构。努力把前辈们的心血，变成我们自己真正的积累。光会用还不够，以深刻理解它们背后的架构逻辑，确保自己与基础架构最大程度上的"同频共振"。  只有让基础架构完全融入自己的思维体系，同频共振，我们才有可能在架构设计需要的时候"想到它们"。这一点很有趣。有些人看起来博学多才，头头是道，但是真做架构时完全想不到他的"博学"。   从体系结构来说，这个基础架构包含哪些内容？  其一，基础平台。包括：冯·诺依曼体系、编程语言、操作系统。  其二，桌面开发平台。包括：窗口系统、GDI系统、浏览器与小程序。当然我们也要理解桌面开发背后的架构逻辑，MVC架构。   其三，服务端开发平台。包括：负载均衡、各类存储中间件。服务端业务开发的业务逻辑比桌面要简单得多。服务端难在如何形成有效的基础架构，其中大部分是存储中间件。  其四，服务治理平台。主要是以容器技术为核心的DCOS（数据中心操作系统），以及围绕它形成的整个服务治理生态。这一块还在高速发展过程中，最终它将让服务端开发变得极其简单。  理解了这些基础架构，再加上你自己所处行业的领域知识，基本上设计出一个优秀业务系统，让它健康运行，持续不间断地向用户提供服务就不是问题。  读到这里，你可能终于明白，为什么这个架构课的内容结构是目前这个样子组织的。因为消化基础架构成为架构师自身的本领，远比消化架构设计原则，架构思维逻辑要难得多。  消化基础架构的过程，同时也是消化架构思维的过程。  把虚的事情往实里做，才有可能真正做好。  理解了基础架构，剩下的就是如何沉淀业务架构所需的武器库。这一般来说没有太统一的体系可以参考，如果有，大部分都会被基础设施化了。  所以，业务只能靠你自己的架构设计能力去构建它。而这，其实也是架构师的乐趣所在。  还没有被基础设施化但比较通用的，有一个大门类是数据相关的体系。数据是软件的灵魂。它可能包括以下这些内容：     slate-type="list-line" 存盘与读盘（IO）；   slate-type="list-line" 文本处理；   slate-type="list-line" 存储与数据结构；   slate-type="list-line" Undo/Redo；   slate-type="list-line" ......   我们在下一讲，会专门聊聊其中的 "文本处理"这个子课题。  从完整性讲，我们的架构课并没有包括所有的基础架构。我们把话题收敛到了"如何把软件跑起来，并保证它持续健康运行"这件事情上。  但从企业的业务运营角度来说，这还远不是全部。"54 \|业务的可支持性与持续运营"我们稍稍展开了一下这个话题。但要谈透这个话题，它会是另一本书，内容主题将会是"数据治理与业务运营体系构建"。  我希望有一天能够完成它，但这可能要很久之后的事情了。它是我除架构课外的另一个心愿。结语  我们在 " [56 \|服务治理篇：回顾与总结"这一讲，也就是第四章结束的时候，谈到我们下一章的内容时提到：  slate-type="block-quote"   我个人不太喜欢常规意义上的"设计模式"。或者说，我们对设计模式常规的打开方式是有问题的。理解每一个设计模式，都应该放到它想要解决的问题域来看。所以，我个人更喜欢的架构范式更多的是"设计场景" 的总结。"设计场景"和设计模式的区别在于它有自己清晰的问题域定义，是一个实实在在的通用子系统。  slate-type="block-quote"   是的，这些"通用的设计场景"，才是架构师真正的武器库。如果我们架构师总能把自己所要解决的业务场景分解为多个"通用的设计场景"的组合，这就代表架构师有了极强的架构范式的抽象能力。而这一点，正是架构师成熟度的核心标志。  结合今天这一讲我们聊的内容，相信你对这段话会有新的理解。  "开闭原则" 推崇模块业务 "只读"的思想，是很好的架构治理哲学。它告诉我们，软件是可以以 "搭积木"的方式搭出来的。核心的一点是，我们如何形成更多的"积木"，即一个个业务只读、接口稳定、易于组合的模块。  结合今天这一讲的内容，相信你终于完全能理解我们这个架构课的内容组织为什么是现在你看到的样子了。  如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们的话题是"架构范式：文本处理"。  如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。