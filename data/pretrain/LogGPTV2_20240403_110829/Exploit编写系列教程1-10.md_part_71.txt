bcdedit.exe/setnxAlwaysOn
bcdedit.exe/setnxAlwaysOff
你可以通过运行“bcdedit”来得到目前的状态然后看下nx的值
一些关于硬件DEP的链接：
●http://support.microsoft.com/kb/875352
●http://en.wikipedia.org/wiki/Data_Execution_Prevention
●http://msdn.microsoft.com/en-us/library/aa366553(VS.85).aspx
绕过 DEP--构建模块
正如在介绍中陈述的，当硬件DEP启用时，你不能只是跳到你的在栈上的shellcode，因为
它不会执行。相反，它将会触发一个访问违例并且很可能会结束进程。
在那个的顶部，每个特殊的DEP设置（OptIn,OptOut,AlwaysOn,AlwaysOff）和永久的DEP
的影响（或者缺席）将需要一个特殊的方法和技术。
因此，我们的选择是什么？
好的，由于我们不能在栈上执行我们自己的代码，我们唯一能做的事是从已经加载的模块中
执行现有的指令/调用现有的函数，然后用栈上的数据作为这些函数/指令的参数。
这些现有的函数会提供给我们这些选择
●执行命令（举个例子，WinExec-典型的“ret-to-libc）
●将包含你的shellcode的页面（例如栈）标记为可执行（如果可以通过主动的DEP策略来
使它运行执行）然后跳到那里
●将数据拷贝到可执行区域然后跳到那里（我们可能要分配内存然后首先将那个区域标记为
可执行）
●在运行shellcode之前改变当前进程的DEP设置
当前的主动的DEP策略和设置将几乎支配你不得不在某些情况下用来绕过DEP的技术。
一个需要一直有效的技术是典型的“ret-to-libc”。你需要能够执行简单的命令，用现有的
Windows API调用（如WinExec），但是用这个很难精巧地制作“真正的”shellcode。
因此我们要看得远点。我们真的需要绕过/推翻/改变DEP设置然后使我们的自定义
shellcode运行。幸运地，标记页面可执行/改变DEP策略设置/等等都能通过Windows OS
的native API/函数调用。
因此，这很简单吧？
是也不是。
当我们要绕过DEP，我们要调用一个WindowsAPI（我将会在后面更进一步描述这些Windows
API的细节）。
那个API的参数必须在寄存器或者栈中。为了将这些参数放在它们应该在的地方，我们很可
能要写一些自定义代码。
想想。
如果给定的API函数的一个参数比如是shellcode的地址，那么你不得不动态产生/计算这
个地址，然后将它放在栈上的正确位置。你不能硬编码，因为这将会不可靠（或者，如果缓
冲区不能处理null字节并且其中的一个参数需要null字节，那么你就不能再你的缓冲区里
硬编码那个值）。用一些短小的shellcode来产生值也不能成功，因为...DEP启用。
问题：我们如何得到栈上的这些参数
回答：用自定义代码
在栈上的自定义代码，无论如何，是不能执行的，DEP会阻止那个发生。
不相信我？那我们来试下在教程1里的那个老而好的Easy RM to MP3 Convertor exploit。
没有DEP（OptIn）
有DEP（OptOut）
或者，在调试器中可以看到的（启用DEP-OptOut），就在shellcode的第一条指令将要执行
（就在jumpesp的后面）：Movie
相信我。甚至是一个简单的NOP指令也不会执行。
小配件
无论如何，回到我们的“自定义代码”问题上。因此如果在栈上运行代码不成功，我们不得
不用ROP。
为了运行我们的自定义代码和最终执行WindowsAPI函数调用，我们将需要用现有的指令
（进程里的可执行区域的指令），并且将它们按顺序放在一起（并且将它们链在一起），因此
它们将会产生我们所需要的然后将数据放入寄存器中或者栈上。
我们需要打造一连串指令。我们需要从链的一部分跳转到链的其他部分在没有从DEP保护
的区域里执行一条简单的指令。或者，用一种更好的术语，我们需要从一条指令返回到下一
条指令的地址（最终返回到WindowsAPI调用当栈已经被设置了）。
在我们的ROP链中的每一条指令（一系列的指令）将会被叫做一个“小配件”。每个小配件
将会返回到下一个小配件（=到下一个小配件的地址，在栈上），或者直接调用下一个地址。
那样，指令序列被链在一起。
在他的原始文章中，HovavShacham用术语“小配件”当涉及到高级别的宏/代码片
段。时下，术语“小配件”通常用来指一系列的以ret结尾的指令（实际上只是原始“gadget”
定义的一个子集）。理解这微妙的东西很重要，但是同时我确信你会原谅我当我在这篇教程
里用“gadget”来指以些以ret结尾的指令集合。
在你打造基于ROP的exploit的同时，你会发现用这些小配件来打造你的栈和调用API的思
想有时能和解决酷比魔方相提并论（感谢Lincoln的伟大比较）。当你试着在栈上设置一个
特定的寄存器或者值，你可能以改变其他的一个而结束。
因此没有通用的方法来打造一个ROPexploit，然后有时你会发现它有点让人沮丧。但是我
能向你保证毅力和坚持不懈会有回报的。
这是理论。
调用 Windows 函数绕过 DEP
首先，在你开始写exploit之前，你需要决定你的方法是什么。在当前OS/DEP策略下，你
能用来绕过DEP的可利用的/可能的Windows API是什么？一旦你已经决定了，你可以相应
地思考设置你的栈。
这些是最重要的函数能够帮你绕过/停用DEP：
●VirtualAlloc（MEM_COMMIT+PAGE_READWRITE_EXECUTE)+复制内存。这会允许你创建一个
新的可执行内存区域，将你的shellcode复制到这里，然后执行。这技术要求你将这2个
API互相链在一起。
●HeapCreate（HEAP_CREATE_ENABLE_EXECUTE）+HeapAlloc()+复制内存。大体上，这函数
提供了一种和VirtualAlloc()相似的技术，但是需要将3个API互相链在一起。
●SetProcessDEPPolicy()。这允许你改变当前进程的DEP策略（因此你能从栈上执行你的
shellcode）（VistaSP1，XPSP3，Server2008，并且只在DEP策略设成OptIn或者OptOut）
●NtSetInformationProcess()。这个函数会改变当前进程的DEP策略，因此你能从栈上执
行你的shellcode。
●VirtualProtect(PAGE_READ_WRITE_EXECUTE)。这个函数会改变一个给定内存页的访问保
护级别，允许你将shellcode在的地方标记为可执行。
●WriteProcessMemory()。这个将允许你将shellcode复制到另一个（可执行）位置，因此
你能跳到那里并且执行shellcode。目标位置必须是可写和可执行的。
这些函数中的每一个都要求栈或者寄存器按一种特定的方法设置。毕竟，当一个函数被调用，
它会假设函数的参数被放在栈顶（=在ESP）。这意味着你的首要目标是在栈上精巧地制作这
些值。用一种通用的和可靠的方法，没有在栈上执行任何代码。
最后（在设置完栈后），你将很可能停止调用这个API。为了使调用成功，ESP必须指向API
函数的参数。
因为我们将会用小配件（一系列指令的指针），被放在栈上的你的payload/缓冲区的一部分，
并且因为我们一直很可能在构建完你的整个rop链来配置参数后返回到栈上，你的最终结果
很可能是这样的：
在函数被调用之前，ESP指向WindowsAPI函数指针。这个指针直接跟着函数需要的参数。
那时，一个简单的“RET”指令将会跳到那个地址。这会调用函数并且是ESP移动4字节。
如果一切顺利的话，栈顶（ESP）指向被调用函数的参数。
选择你的武器
（1）=不存在
（2）=将会失败因为默认的DEP策略设置
不要担心怎么应用这些技术，一会儿事情将会变明白。
函数参数&用法提示
正如早些时候陈述的那样，当你想用这些可用的WindowsAPI中的一个，你首先要用正确的
参数为那个函数设置栈。接下来的是这些函数的总结，它们的参数，和一些用法提示。
VirtualAlloc()
这个函数将会分配新的内存。这个函数的一个参数指定了最近分配的内存的可执行/访问级
别，因此我们的目标是将这个值设成EXECUTE_READWRITE。
http://msdn.microsoft.com/en-us/library/aa366887(VS.85).aspx
这个函数需要你设置栈包含下面的值：
返回值 函数返回地址（=在它完成后函数需要返回的地址）。我将在一会儿讨论
这个值
lpAddress 要分配区域的起始地址（=你想要分配内存的新位置）。记住这个地址会
在最近倍数的内存粒度传开。你可以试着为这个参数提供一个硬编码值
dwSize 区域的大小。（你将可能需要用rop来产生这个值，除非你的exploit能
处理null字节）
flAllocationType 设成0x1000（MEM_COMMIT）。可能需要rop在栈上产生&写这个值
flProtect 设成0x40（EXECUTE_READWRITE）。可能需要rop在栈上产生&写
这个值
在XPSP3，这个函数在0x7C809AF1处（kernel32.dll）
当VirtualAlloc()调用成功，分配的内存地址会被保存在eax中。
注意：这个函数只分配新的内存。你要用另一个API调用来复制shellcode到新的区域并执
行它。因此，你需要另一个rop链来完成这个。（在上面的表格中，我提到返回地址参数需
要指向第二个rop链。因此，VirtualAlloc()的返回地址需要指向将shellcode复制到新分配区
域并跳转到那里的rop链）
为了完成这个，你能用
●memcpy()（ntdll.dll）-在XP SP3上0x7C901DB3
●WriteProcessMemory()（看后面）
举个例子，如果你要用memcpy()，然后你可以同时hook VirtualAllocate()和memcpy()调
用并且使它们直接互相执行，用下面的设置：
首先，VirtualAlloc()函数的指针必须在栈顶，之后在栈上跟着参数的值：
●memcpy的指针（VirtualAlloc()的返回地址地段）。当VirtualAlloc停止后，它会返回
这个地址
●lpAddress：任意的地址（分配新内存的地址，比如0x0020000）
●大小（新分配的内存的大小）
●flAllocationType（0x1000：MEM_COMMIT）
●flProtect（0x40：PAGE_EXECUTE_READWRITE）
●任意地址（和lpAddress一样的地址，这个参数将会用在memcpy()返回后跳转到
shellcode）。这个字段是memcpy()函数的第一个参数
●任意地址（一样，和lpAddress一样的地址。这个参数用来作为memcpy()的目的地址）。
这个字段是memcpy()函数的第二个参数
●shellcode的地址（=memcpy()的源参数）。这个是memcpy()的第三个参数
●大小：memcpy()的大小参数。这是memcpy()的最后一个参数
很明显，关键是找到一个可靠的地址（分配内存的地址）和在栈上用rop产生所有的参数。
当这个链结束后，你将会以执行被拷贝到最近分配的内存中的代码而告终。
HeapCreate()
http://msdn.microsoft.com/en-us/library/aa366599(VS.85).aspx
这个函数将会创建一个能在我们的exploit中用的私有堆。空间将会被保留在进程的虚拟地
址空间。
当flOptions参数被设置成0x00040000(HEAP_CREATE_ENABLE_EXECUTE)，然后所有从
这个堆里分配的内存块将会允许执行代码，尽管DEP已经开启。
dwInitialSize参数必须包含一个指示堆大小的值，用字节表示。如果你设置这个参数为0，
然后将会分配一个页。
dwMaximumSize参数指堆的最大大小，用字节表示。
这个函数只能创建一个私有堆并将它标记为可执行。你依然要在这个堆里分配内存（如用
HeapAlloc）然后将shellcode拷贝到那个堆位置（如用memcpy()）。
当CreateHeap函数返回时，一个指向最新创建的堆指针会存在eax中。你需要这个值来调
用HeapAlloc()：
http://msdn.microsoft.com/en-us/library/aa366597(v=VS.85).aspx
当新的堆分配完之后，你可以用memcpy()来将shellcode拷贝到已分配的堆中并且执行。
在XPSP3中，HeapCreate在0x7C812C56处。HeapAlloc()在7C8090F6。二者都是kernel32.dll
的一部分。
SSSSeeeettttPPPPrrrroooocccceeeessssssssDDDDEEEEPPPPPPPPoooolllliiiiccccyyyy(((())))
http://msdn.microsoft.com/en-us/library/bb736299(VS.85).aspx
适用在：WindowsXPSP3，VistaSP1和Windows2008。
为了能使这个函数有效，当前的DEP策略必须设成OptIn或者OptOut。如果策略被设成
AlwaysOn（或者AlwaysOff），然后SetProcessDEPPolicy将会抛出一个错误。如果一个模块
是以/NXCOMPAT链接的，这个技术也将不会成功。最后，同等重要的是，它这能被进程调
用一次。因此如果这个函数已经被当前进程调用（如IE8，当程序开始时已经调用它），它
将不成功。
BernardoDamele写了一篇出色的关于这个话题的博文：
http://bernardodamele.blogspot.com/2009/12/dep-bypass-with-setprocessdeppolicy.html
这个函数需要一个参数，并且这个参数必须设置为0来停用当前进程的DEP。
为了在ROP链中用这个函数，你需要在栈上这样设置：
●指向SetProcessDEPPolicy的指针
●指向shellcode的指针
●0
指向shellcode的指针会确认当SetProcessDEPPolicy()执行完ROP链会跳到shellcode。
在XP SP3下SetProcessDEPPolicy的地址是7C8622A4（kernel32.dll）
NtSetInformationProcess()
适用于：Windows XP,Vista SP0,Windows 2003
Skape和skywing的技术文档：http://uninformed.org/index.cgi?v=2&a=4
用这个函数需要在栈上有5个参数：
返回值 要产生的值，指示了函数需要返回的地方（=shellcode在的地方）
NtCurrentProcess() 静态值，设成0xFFFFFFFF
ProcessExecuteFlags 静态值，设成0x22
&ExecuteFlags 指向0x2（值可以是静态的，也可能是动态的）。这个地址必须指向
包含0x00000002的内存位置
sizeOf(ExecuteFlags) 静态值，设成0x4
如果永久DEP标志已经标记，那么NtSetInformationProcess将会失败。在Vista（然后更
后面的），这个标志会对所有的以/NXCOMPAT链接选项链接的可执行文件自动设置。如果DEP
策略模式设成AlwaysOn，这个技术也会失败。