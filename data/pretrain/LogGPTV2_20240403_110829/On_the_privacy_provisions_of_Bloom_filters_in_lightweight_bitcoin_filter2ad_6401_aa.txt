title:On the privacy provisions of Bloom filters in lightweight bitcoin
clients
author:Arthur Gervais and
Srdjan Capkun and
Ghassan O. Karame and
Damian Gruber
On the Privacy Provisions of Bloom Filters in Lightweight
Bitcoin Clients
Arthur Gervais†, Ghassan O. Karame‡, Damian Gruber(cid:96), Srdjan Capkun†
†(cid:96)ETH Zurich, Switzerland, ‡NEC Laboratories Europe, Germany
†ﬁPI:EMAIL, ‡ﬁPI:EMAIL, (cid:96)PI:EMAIL
ABSTRACT
Lightweight Bitcoin clients are gaining increasing adoption among
Bitcoin users, owing to their reduced resource and bandwidth con-
sumption. These clients support a simpliﬁed payment veriﬁcation
(SPV) mode as they are only required to download and verify a part
of the block chain—thus supporting the usage of Bitcoin on con-
strained devices, such as smartphones. SPV clients rely on Bloom
ﬁlters to receive transactions that are relevant to their local wal-
let. These ﬁlters embed all the Bitcoin addresses used by the SPV
clients, and are outsourced to more powerful Bitcoin nodes which
then only forward to those clients transactions relevant to their out-
sourced Bloom ﬁlters.
In this paper, we explore the privacy of existing SPV clients.
We show analytically and empirically that the reliance on Bloom
ﬁlters within existing SPV clients leaks considerable information
about the addresses of Bitcoin users. Our results show that an SPV
client who uses a modest number of Bitcoin addresses (e.g., < 20)
risks revealing almost all of his addresses. We also show that this
information leakage is further exacerbated when users restart their
SPV clients and/or when the adversary has access to more than one
Bloom ﬁlter pertaining to the same SPV client. Motivated by these
ﬁndings, we propose an efﬁcient countermeasure to enhance the
privacy of users which rely on SPV clients; our proposal can be
directly integrated within existing SPV client implementations.
1.
INTRODUCTION
Bitcoin has already witnessed a wider adoption and attention
than any other digital currency proposed to date. Bitcoin imple-
ments a distributed time-stamping service [28], which operates on
top of the Bitcoin Peer-to-Peer (P2P) network and ensures that all
transactions and their order of execution are visible to all Bitcoin
users. Transactions are included in Bitcoin blocks that are broad-
casted in the entire network; blocks link to each other, thus forming
the Bitcoin block chain.
Currently, a typical Bitcoin installation requires more than 18 GB
of disk space, and requires considerable time to download and lo-
cally index blocks and transactions that are contained in the block
chain. Given its increasing use, the transactional volume in Bitcoin
is only expected to increase—thus yielding a considerable growth
in the size of the block chain [1].
In addition to disk space us-
age, the continuous growth of Bitcoin’s transactional volume in-
curs considerable overhead on the Bitcoin clients that need to ver-
ify the correctness of broadcasted blocks and transactions in the
network. This problem becomes even more evident when users
wish to perform/verify Bitcoin payments using resource-constraint
devices, such as mobile devices.
To remedy this, the Bitcoin developers released a lightweight
client, BitcoinJ [2], which supports a simpliﬁed payment veriﬁ-
cation (SPV) mode where only a small part of the block chain is
downloaded— thus supporting the typical usage of Bitcoin on con-
strained devices (e.g., smartphones, cheap virtual private servers).
SPV clients were originally proposed by Nakamoto in [28] and
were later extended to rely on Bloom ﬁlters [20] in order to receive
transactions that are relevant to their local wallet. These Bloom ﬁl-
ters embed all the addresses used by the SPV clients, and are out-
sourced to more powerful Bitcoin nodes; these nodes will then for-
ward to the SPV clients those transactions relevant to their Bloom
ﬁlters.
Bloom ﬁlters can be deﬁned with a target false positive rate; by
appropriately setting the target false positive rate of Bloom ﬁlters,
Bitcoin developers aim to provide a suitable anonymity set to hide
the addresses of SPV clients. As far as we are aware, the informa-
tion leakage associated with the reliance on Bloom ﬁlters has not
been yet thoroughly analyzed in the context of Bitcoin [3].
In this paper, we address this problem, and explore the privacy
provisions due to the use of Bloom ﬁlters in existing SPV client im-
plementations. We show analytically and empirically that the cur-
rent integration of Bloom ﬁlters within Bitcoin leaks considerable
information about the addresses of Bitcoin users. More speciﬁ-
cally, we show that the information leakage due to Bloom ﬁlters
signiﬁcantly depends on the number of addresses that each user
possesses; notably, users who have a modest number of addresses
(< 20) risk leaking all of their addresses by embedding them in a
Bloom ﬁlter. This information leakage is further exacerbated when
nodes restart their client, or generate additional Bitcoin addresses
to their SPV clients; in these cases, the SPV clients re-compute new
Bloom ﬁlters. We show that the computation of new Bloom ﬁlters
considerably reduces the privacy of SPV clients.
Our work therefore motivates a careful assessment of the cur-
rent implementation of SPV clients, prior to any large-scale de-
ployment. In this work, we make the following contributions:
• We show that considerable information about users who pos-
sess a modest number of Bitcoin addresses (e.g., < 20) is
leaked by a single Bloom ﬁlter in existing SPV clients.
• We show that an adversary can easily link different Bloom
ﬁlters which embed the same elements—irrespective of the
target false positive rate. This also enables the adversary to
link, with high conﬁdence, different Bloom ﬁlters which per-
tain to the same originator.
• We show that a considerable number of the addresses of users
are leaked if the adversary can collect at least two Bloom ﬁl-
ters issued by the same SPV client—irrespective of the target
false positive rate and of the number of user addresses.
• Finally, we propose a lightweight and efﬁcient countermea-
sure to enhance the privacy offered by SPV clients. Our
countermeasure can be integrated with minimum modiﬁca-
tions within existing SPV client implementations.
The remainder of this paper is organized as follows. In Section 2,
we brieﬂy overview the operation of SPV clients. In Section 3, we
introduce our system and attacker model. In Section 4, we ana-
lyze the privacy provisions of existing SPV client implementations
when the adversary captures a single Bloom ﬁlter of an SPV client.
In Section 5, we discuss the information leakage when the adver-
sary can acquire multiple Bloom ﬁlters of an SPV node. In Sec-
tion 6, we propose an efﬁcient solution to enhance the privacy of
users in SPV clients. In Section 7, we review related work in the
area and we conclude the paper in Section 8.
2. BACKGROUND
In what follows, we brieﬂy overview Bitcoin and introduce SPV
clients.
Bitcoin enables its users to perform payments by issuing trans-
actions. Standard transactions transfer Bitcoins (BTC) from one or
several input addresses to at least one output address. A Bitcoin
address corresponds to a public key, whose corresponding secret
key enables the address owner to spend the BTCs stored in the re-
spective address.
In order to spend BTCs, a user ﬁrst creates a
transaction, which typically takes as inputs the outputs of earlier
transactions addressed to his addresses, and speciﬁes as outputs the
Bitcoin addresses (or their corresponding public keys) which will
collect the resulting BTCs. Finally, the user signs the transaction
and broadcasts it into the Bitcoin peer-to-peer (P2P) network.
Transactions are included and stored into Bitcoin blocks. Blocks
are generated (or mined) by solving a hash-based proof-of-work
(PoW) scheme. More speciﬁcally, miners need to ﬁnd the appro-
priate block parameters (e.g., a nonce value) such that the resulting
block hash is below a given target value. Once such a block is
found, the miner broadcasts the block in the network enabling all
Bitcoin peers to verify the correctness of the included transactions
and the PoW. If the block is deemed correct, the miner is awarded
a ﬁxed amount of BTCs. Note that every generated block points to
the previous block, thus growing the block chain.
Bitcoin requires all peers in the system to verify all broadcasted
transactions and blocks. Clearly, this comes at the expense of stor-
age and computational overhead. Currently, a typical Bitcoin in-
stallation requires more than 18 GB of disk space, and considerable
time to download and locally index blocks and transactions that are
contained in the block chain. Additionally, the continuous growth
of Bitcoin transactional volume incurs signiﬁcant computational
overhead on the Bitcoin clients, when verifying the correctness of
broadcasted blocks and transactions in the network. This problem
becomes even more evident when users wish to perform/verify Bit-
coin payments from resource-constrained devices such as mobile
devices, tablets, etc.
To remedy that, lightweight client implementations (or simpli-
ﬁed payment veriﬁcation, SPV) have been proposed in [28]; SPV
clients do not store the entire block chain, nor do they validate all
transactions in the system. Notably, SPV clients only perform a
limited amount of veriﬁcations, such as the veriﬁcation of block
difﬁculty and the presence of a transaction in the Merkle tree, etc.,
and ofﬂoad the veriﬁcation of all transactions and blocks to the full
Bitcoin nodes. Note that in order to calculate their own balance,
SPV clients request full blocks from a given block height on; here,
the full Bitcoin nodes can also provide “ﬁltered blocks” to the SPV
client that only contain relevant transactions from each block.
Unlike full Bitcoin nodes, SPV clients do not receive all the
transactions that are broadcasted within the Bitcoin P2P network,
Figure 1: Sketch of the operation undergone by an SPV client. SPV
clients connect to a full Bitcoin node, which only forwards to the
SPV clients the transactions relevant to their Bloom ﬁlters.
but instead receive a subset of transactions, ﬁltered for them by the
full nodes to which they are connected1. This is mainly done to re-
duce the communication load on SPV clients, typically run on mo-
bile devices. To reduce bandwidth consumption, SPV clients make
use of Bloom ﬁlters [20]. A Bloom ﬁlter [14] is a space-efﬁcient
probabilistic data structure which is used to test membership of an
element. An SPV client constructs a Bloom ﬁlter by embedding all
the Bitcoin addresses which appear in its wallets. Upon connection
to a full Bitcoin node, the constructed Bloom ﬁlter is outsourced to
the full node following an initial handshake protocol (cf. Figure 1).
Whenever the full node receives a transaction, it ﬁrst checks to see
if its input and/or output addresses match the SPV client’s Bloom
ﬁlter. If so, the full node forwards the received transaction to the
SPV client.
Bloom Filters: Bloom ﬁlters have been ﬁrst proposed by Bloom
in 1970; we refer the readers to [15] for detailed information on
Bloom ﬁlters. In SPV clients [2], a Bloom ﬁlter B of an SPV client
is speciﬁed by the maximum number of elements that it can ﬁt,
denoted by M, without exceeding its target false-positive rate Pt.
Let m ≤ M denote the number of elements that are inserted in
B(M, Pt). In SPV clients, the size of the ﬁlter n is computed as
follows:
n = − M ln(Pt)
(ln(2))2
(1)
A Bloom ﬁlter B basically consists of an array B[.] of n bits
accessed by k independent hash functions H1(.), . . . , Hk(.), each
of which maps an input string x ∈ {0, 1}∗ to one of the n bits of
the array. In SPV clients, k is computed as follows:
n
M
k = ln(2)
(2)
To insert an element x ∈ {0, 1}∗ to a Bloom ﬁlter B, then
∀j ∈ {1, . . . , k}, B[Hj(x)] ← 1. Similarly, to query the pres-
ence of an element x ∈ {0, 1}∗ in B, then this entails computing
∧k
j=1B[Hj(x)] (thus returning 1, if all corresponding bits are 1).
Bloom ﬁlters can generate a number of false positives, but cannot
result in false negatives. The literature features a number of tech-
niques to estimate the false positive rate of Bloom ﬁlters [15, 24].
In this paper, we focus on the proposal due to Mullin et al. [24] to
estimate the false positive rates in Bloom ﬁlters (which is computed
1Currently, SPV clients connect to a default of four different ran-
domly chosen nodes
SPV clientFull Bitcoin clientRelevant transactionsFull Bitcoin clientFull Bitcoin clientTransactionTransactionIs transaction relevant for Bloom ﬁlter?TCP connection establishementHandshake, e.g. version infoBloom ﬁlterBitcoin connection establishementover all possible inputs to the Bloom ﬁlter). More speciﬁcally, we
compute the false positive rate of a ﬁlter B(M, Pt) which has m
elements, Pf (m), as follows [15]:
(cid:32)
(cid:18)
(cid:19)km(cid:33)k
Pf (m) =
1 −
1 − 1
n
(3)
In Section 4.2, we show that this estimation experimentally matches
the false positive rate featured by existing implementations of SPV
clients. We acknowledge that there might be more accurate tech-
niques for computing the false positive rates (e.g., [15]); our ﬁnd-
ings, however, show that the difference in false positives resulting
from [15] and [24] was negligible and did not affect our results.
We therefore elected to rely on the estimation of Pf which appears
in [24]. Here, note that Pf (M ) ≈ Pt. That is, the target false
positive rate of a Bloom ﬁlter is only reached when the number of
elements contained in the ﬁlter matches M.
3. MODEL
In this section, we present our system and attacker model. We
also introduce our privacy metric which will be used to quantify
the privacy of SPV clients.
System Model.
We assume that lightweight SPV clients connect to the Bitcoin
P2P network through full Bitcoin nodes. As described earlier, full
nodes only inform the SPV clients about transactions speciﬁc to
their corresponding Bloom ﬁlters. We further assume that the full
Bitcoin nodes do not know the IP address of the SPV clients; for
example, SPV clients might rely on TOR [4] when connecting to
other Bitcoin nodes.
Attacker Model.
We assume that the adversary can compromise one or more full
Bitcoin nodes and eavesdrop on communication links in order to
acquire one or more Bloom ﬁlters pertaining to an SPV client.
Here, the goal of the adversary is to identify the Bitcoin addresses
that are inserted within a Bloom ﬁlter created by a particular SPV
client. The addresses inserted in the Bloom ﬁlter typically corre-
spond to addresses that the SPV client is interested in receiving in-
formation about (e.g., these addresses typically belong to the wallet
of the SPV client). For example, the adversary might be connected
to the node which generated the Bloom ﬁlter or might try to as-
sign an identity to nodes according to their addresses, etc. Note
that since the Bitcoin network provides currently less than 10,000
reachable full Bitcoin nodes, it is likely that regular nodes receive
one or more ﬁlter pertaining to each SPV client over a sufﬁciently
long period of time.
In our analysis, we assume that the adversary knows the param-
eters used to create a Bloom ﬁlter. This includes, for instance, the
target false positive rate, Pt, that the Bloom ﬁlter is designed to
achieve, and the number of hash functions k used in the Bloom ﬁl-
ter. Since Bitcoin is an open payment system, we also assume that
the adversary has access to all addresses/transactions which appear
in the block chain, and to their respective order of execution.
Clearly, we assume that the adversary is computationally bounded.
However, since the Bitcoin network only contains a bounded num-
ber of addresses (around 33 million Bitcoin addresses), the adver-
sary can simply check whether all existing addresses match to a
given Bloom ﬁlter.
Note that an adversary who is connected to an SPV client can
see the transactions issued by the client and could potentially use
this in order to learn the clients’ addresses. This can be countered
e.g., by SPV clients using TOR whenever they issue Bitcoin trans-
actions. Instead, in this work, we focus on analyzing the privacy
issues of the use of Bloom ﬁlters within existing SPV client imple-
mentations, which as we show, cannot be solved by simply relying
on anonymizing networks. In Section 6, we still discuss the case
where the adversary can additionally link Bitcoin addresses by ob-
serving the behavior of users, timing of transactions, etc.
Let B refer to the set of all existing Bitcoin addresses. Further-
more, let Bi refer to the set of all elements y in B that are members
of Bloom ﬁlter Bi (i.e., for which a query in Bi returns true), and
Fi ⊂ Bi denote the set of false positives of Bi.
In our analysis, we assume that all elements map uniformly at
random to the bits of the Bloom ﬁlter; that is, we assume that all
addresses y ∈ Bi are equally likely to be a true member of Bi.
We further assume that the adversary can collect additional in-
formation from the system which can help her classify (a fraction
of) the false positives exhibited by Bloom ﬁlters; for example, the
adversary can try to identify some false positives generated by ﬁl-
ters by analyzing two different Bloom ﬁlters which embed the same
true positives (cf. Section 5). We capture this additional knowledge
using the set K ⊆ Fi which contains addresses in Fi that the ad-
versary can correctly classify. We acknowledge that the adversary
could also try to gather prior knowledge about the addresses in-
serted in the Bloom ﬁlter; in this work, we focus however on the
case where the adversary does not have any prior knowledge about
the true positives of the ﬁlter.
Our analysis throughout the rest of the paper does not exploit
the fact that the adversary knows the public keys of Bitcoin ad-
dresses. Indeed, in current implementations of SPV clients, both
the addresses and their public keys are inserted in the outsourced
Bloom ﬁlter. As such, if the adversary knows both the address and