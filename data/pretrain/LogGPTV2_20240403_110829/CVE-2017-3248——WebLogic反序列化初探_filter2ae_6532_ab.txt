ysoserial是本地ysoserial的路径，JRMPListener ip和JRMPListener port第一步中启动JRMP
Server的IP地址和端口。JRMPClient是执行JRMPClient的类，可选的值是JRMPClient（针对CVE-2017-3248）或JRMPClient2（针对CVE-2017-3248的绕过）。
最后查看相应目录，
可见已成功执行命令。
###  （三）调试
开启JRMP Server后，以exp打之，先是正常的读入字节流进行反序列化（这里很遗憾的一点就是环境对应不到相应的补丁，看不到完全的流程），
ysoserial中，反向连接所需的host和port先存入te，而后存入了LiveRef中，接着封装进 UnicastRef 里，
再封装进 RemoteObjectInvocationHandler 中，最后用 Proxy.newProxyInstance 生成了一个 proxy
，这里和之前区别不大，
exp打过去，会触发RemoteObjectInvocationHandler的反序列化
RemoteObjectInvocationHandler 反序列化时，会调用其父类 RemoteObject 的 readObject()，
因为有重写，会越过这一段，
在下面调用，
就开始触发。
这里从跟进RemoteObject的readObject向下走，
向下，
接下来就层层剥开，
LiveRef的read函数中会向server发起请求，注册对象，
接下来进入DGCClient（但不知道什么原因这里有的点断不下来），
这里面调用了重载的registerRefs，
这个函数里面就有我们最终需要的makeDirtyCall，
跟进，
接下来就是关键部分，
这里的this.dgc.dirty是一个关键点，正常情况下它应该返回一个Lease，作为这个远程对象的存活时间的依据，
如下，真实的Lease，
但是这里远程服务器是恶意的，返回的并不是一个Lease，而是一个构造好的Set，虚假的Lease，
而这里的触发点并不在黑名单之列，故而不会受影响。
再向下跟就进入了我们熟悉的CommonsCollections1环节（这是我的一个疑惑点，为什么就进去了），
接受指点和查阅资料后，意识到跟进的不够深入，于是重新调试，
[参考链接](https://xz.aliyun.com/t/2650#toc-2)
接着下面这个场景，重新调试，
根据之前调用栈的情况，
我们知道应该跟进到DGCImpl_Stub的dirty（而非普通的DGC）里（个人认为这算是调试工具的一点点不足，就是无法通过分析代码逻辑确定一个变量的最终类型，对于变量的相关信息主要还是静态分析获得的。但也不能就说这个工具不好，毕竟人也很难做到），
然而尝试了好几种方法也没能断下来，
无奈，只好越过它跟进
UnicastRef.invoke()（这里想了点题外话，为什么不能完全依靠静态时的Ctrl+点击跟进RefRemote.invoke()，而必须要根据动态调试结合调用栈确定是
UnicastRef.invoke()。原因一是要围绕主题，整个CVE的利用都是用到的是UnicastRef而不是RefRemote；原因二是只有动态调起来才能确定程序的走向）,
继续跟进，
这里的几处判断都比较简单，进入switch，
这里调用了this.in.readObject()，
查看this.in，
可见，正是构造好的字节流，
接着正常进入了AnnotationInvocationHandler的readObject，
此时完整的调用栈如下，
    readObject:320, AnnotationInvocationHandler (sun.reflect.annotation)
    invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
    invoke:39, NativeMethodAccessorImpl (sun.reflect) [2]
    invoke:25, DelegatingMethodAccessorImpl (sun.reflect)
    invoke:597, Method (java.lang.reflect)
    invokeReadObject:969, ObjectStreamClass (java.io)
    readSerialData:1871, ObjectInputStream (java.io)
    readOrdinaryObject:1775, ObjectInputStream (java.io)
    readObject0:1327, ObjectInputStream (java.io)
    defaultReadFields:1969, ObjectInputStream (java.io)
    readSerialData:1893, ObjectInputStream (java.io)
    readOrdinaryObject:1775, ObjectInputStream (java.io)
    readObject0:1327, ObjectInputStream (java.io)
    defaultReadFields:1969, ObjectInputStream (java.io)
    defaultReadObject:478, ObjectInputStream (java.io)
    readObject:313, AnnotationInvocationHandler (sun.reflect.annotation)
    invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
    invoke:39, NativeMethodAccessorImpl (sun.reflect) [1]
    invoke:25, DelegatingMethodAccessorImpl (sun.reflect)
    invoke:597, Method (java.lang.reflect)
    invokeReadObject:969, ObjectStreamClass (java.io)
    readSerialData:1871, ObjectInputStream (java.io)
    readOrdinaryObject:1775, ObjectInputStream (java.io)
    readObject0:1327, ObjectInputStream (java.io)
    defaultReadFields:1969, ObjectInputStream (java.io)
    readSerialData:1893, ObjectInputStream (java.io)
    readOrdinaryObject:1775, ObjectInputStream (java.io)
    readObject0:1327, ObjectInputStream (java.io)
    readObject:349, ObjectInputStream (java.io)
    executeCall:225, StreamRemoteCall (sun.rmi.transport)
    invoke:359, UnicastRef (sun.rmi.server)
    dirty:-1, DGCImpl_Stub (sun.rmi.transport)
    makeDirtyCall:342, DGCClient$EndpointEntry (sun.rmi.transport)
    access$1600:153, DGCClient$EndpointEntry (sun.rmi.transport)
    run:555, DGCClient$EndpointEntry$RenewCleanThread (sun.rmi.transport)
    run:662, Thread (java.lang)
可以看出是起于DGCClient 的makeDirtyCall及相关的成员变量，
接下来是熟悉的invoke(),
查看此时的调用栈，
和CVE-2015-4852的调用栈对比来看（黄圈内为黑名单设的点，红框向上即为CommonsCollections1的链），
从这里我们可以看出这里的反序列化是由DGC请求触发的，没有走原来的线路，所以在原来的那几个反序列化点上设置的限制条件没有任何用处。
下面都很熟悉了，稍作展示，不再赘述。
当这些完成后，退回到executeCall() 中，
引发异常，
这里便是前面看到的异常。
另外，从Ubuntu 的wireshark里抓包，查看其返回给docker的数据包的情况，
载荷的一小部分，
由此可见，返回给靶机docker的数据包是序列化后的CommonsCollections1的攻击链，确实与原来无异，也与上面的this.in一致。
## 三、收获与启示
调完之后，我意识到最开始的那个比喻虽然不贴合严肃的学习，却跟这几个漏洞的演进过程比较贴切。
这几个漏洞的基础都是最开始CVE-2015-4852的那条链，由于Oracle在进行防护时采用的黑名单不严谨（比如只截断一个链上的一个点），对这条链的后续利用可谓是层出不穷。
起初的学习过程中，我认为这个系列的漏洞的黑名单只是个噱头而已，作用不大。然而，在这个漏洞的调试过程中，我感受到：这个黑名单虽然没能完全达到防护的效果，但它一定程度上已经发挥了不小的防护作用。CVE-2015-4852的黑名单添加了CVE-2016-3510和CVE-2016-0638的触发点后，原来的那条链从源头上基本被切断了，很难找到合适的线路去连接CommonsCollections1的片段了，这已经是一个不小的进步了。这一现状迫使大牛们寻找新的利用链路，在2017年提出了通过构造JRMP
Listener 反向触发的方法，算是又开启了一个新的系列。
在CVE-2017-3248的学习过程中，我感受到了比最开始接触CVE-2015-4852时更大的压力，之前虽然学了Java的一些基础知识，但是对于其中的很多内容理解不够到位，这个漏洞涉及到的内容偏底层，对我这样一个Java新手来说难度有些大，我通过自己写demo、深入跟踪调试的方法才慢慢能够理解其部分的内在原理，一定程度上算是走出了自己的舒适区。
另外，这里我有一点体会到了二分法解决问题的思路，这个描述不太准确，大体的意思就是先确定调试过程中的几个少量的关键点，然后以这些点分段，逐段下断仔细研究、调试。