# Deriving an Information Flow Checker and Certifying Compiler for Java

## Authors
- Gilles Barthe<sup>1</sup>
- David A. Naumann<sup>2</sup>
- Tamara Rezk<sup>1</sup>

<sup>1</sup> INRIA Sophia-Antipolis, Project EVEREST, {Gilles.Barthe, Tamara.Rezk}@sophia.inria.fr  
<sup>2</sup> Stevens Institute of Technology, PI:EMAIL

## Abstract
Language-based security provides a means to enforce end-to-end confidentiality and integrity policies in mobile code scenarios, and is increasingly being considered by the smart-card and mobile phone industries as a solution to enforce information flow and resource control policies.

Two main research threads have emerged in language-based security: one focuses on enforcing security policies for source code, aimed at developers who want to increase confidence in their applications; the other focuses on efficiently verifying similar policies for bytecode, aimed at code consumers who want to protect themselves against hostile applications. These lines of work serve different purposes and have been developed independently, but connecting them is a key step towards the practical deployment of language-based security.

This paper introduces a systematic technique to connect source code and bytecode security type systems. The technique is applied to an information flow type system for a fragment of Java with exceptions, addressing challenges in both control and data flow tracking.

## 1. Introduction
Security models for mobile code typically rely on typing mechanisms that statically enforce basic safety policies (e.g., code containment or absence of pointer arithmetic) and mechanisms such as stack inspection in Java and .NET that dynamically enforce access control policies. While these mechanisms are intended to enforce confidentiality and integrity policies, it is difficult to assess the end-to-end policies they guarantee. In particular, they do not ensure information-flow policies, which are commonly desirable in scenarios involving the execution of untrusted code. To enforce stronger security guarantees, information-flow type systems provide a means to track data flows and control dependencies, thereby rejecting any program that may leak confidential information.

JFlow is an extension of Java with a flexible and expressive information flow type system [12]. The flexibility and expressiveness of JFlow's information flow policies have been exploited for modeling and analyzing the policies underlying games like battleship and mental poker [2]. Despite its rich language, JFlow's information-flow policies can be automatically enforced by a constraint-based algorithm that rejects programs violating the policy. However, the flexibility of the type system, especially regarding declassification, makes it difficult to formally characterize the security properties verified by typable programs. Subsequent work [4, 3] has focused on developing an information-flow type system for a fragment of Java that includes objects, inheritance, and methods, enforcing non-interference, a baseline policy requiring that secret input data cannot be inferred by an attacker observing only public output. (Non-interference also captures integrity by duality.)

The benefits provided by JFlow (and [3]) do not directly address mobile code security since they apply to source code, whereas Java applets are deployed in compiled form as JVM bytecode programs. Therefore, it is desirable to develop information flow type systems at the bytecode level. An extended bytecode verifier is provided by [7]; their type system guarantees secure information flow for a fragment of Java bytecode that includes objects, inheritance, methods, and a simplified mechanism for exceptions.

The type systems of JFlow and [7] have been developed and applied in isolation: JFlow offers a practical tool for developing secure applications, ensuring that developers' applications meet high-level policies about API usage. In contrast, the type system of [7] augments the Java security architecture to provide assurance to users that applets respect high-level policies about API usage. The value of these two lines of work can be greatly increased by connecting them via a type preservation result, showing that programs typable in a suitable fragment of JFlow will be compiled into bytecode programs that pass information-flow bytecode verification (as suggested by Abadi [1]). Such a result would show that applications written with JFlow can be deployed in a mobile code architecture that delivers the promises of JFlow in terms of confidentiality, and that the enhanced security architecture from [7] can benefit from practical tools for developing applications that meet the policy it enforces.

## Contributions
- We propose a systematic method to derive an information flow type system for a high-level language (an extension to exceptions of the fragment of Java in [3]) from an information flow type system for a low-level language (the fragment of the JVM in [7]) using a non-optimizing compiler [17] from Java source to bytecode. The novelty of the resulting type system is the use of security environments, which assign security levels to control points instead of code fragments. The flow of information via control is tracked by propagating the levels of guard conditions along control paths. This approach was previously used only for low-level languages. Another novelty induced by the presence of security environments at the source level is the simplification of the information flow typing rules for the JVM, as the security environment can be retrieved from the source code and does not need to be computed at the bytecode level. The result is a simpler and faster bytecode verification algorithm for information flow.
- We introduce a conventional type system for the same fragment of Java source code and show that each program typable in this high-level type system is also typable in the intermediate type system based on security environments. By combining this result with type-preserving compilation (the first item above), we show that a non-optimizing Java compiler [17] preserves information flow typing, meaning that a program typable by the high-level system for source programs will be compiled into a program that will be accepted by a bytecode verifier that enforces secure information flow.

The only previous type-preserving compiler for information flow is that of [6] for a simple imperative language. As [6] points out, an additional benefit of type preservation is that it proves noninterference for the source language type system, provided that the compiler preserves semantics (as it should) and noninterference has been shown for the target language. Thus, another contribution of this paper is to add exceptions to the language in [3], but instead of extending their soundness proof, we can obtain noninterference for the high-level type system using our type preservation result and the noninterference result of [7].

Besides [7], there has been some work on secure information flow for typed assembly languages. Medel et al. [11] treat a simple imperative assembly language, tracking implicit flows using code annotations so the typing rules can, in effect, recover structured control flow. In subsequent work, Yu and Islam [20] treat a richer assembly language with indirect addressing/aliasing and code pointers but still not heap allocation or object-oriented features. A comparable advance is made independently in [8]. These works prove that their rules ensure noninterference; [20] also gives a security-type preserving translation from an imperative language with first-order procedures.

## Overview
The key technical idea is to connect unstructured bytecode with structured source code by way of an intermediate type system that applies to source code but tracks control dependence regions in terms of control flow labels, as done for bytecode in [7]. Although one of the contributions is a method to derive a type system for source code from one for target code, we only have space to present the result of this derivation. For clarity, we present the type systems top-down. Section 2 reviews security policy and noninterference in the presence of exceptions and heap allocation and gives an overview of control dependence regions. Section 3 presents the source language and its high-level security type system. Section 4 gives the key definition of the paper, a type system for source programs that deals with control flow using explicit control point labels. Section 5 connects these two type systems. Section 6 presents the target language and its security typing and defines the non-optimizing compiler. Section 7 connects the intermediate typing system with the target one and proves the main result. The concluding section discusses how the results can be adapted to optimizing compilers and richer policies such as those in JFlow.

## 2. Secure Flow Policy and Control Dependence Regions
We assume a lattice S of security levels. Confidentiality policy is specified by labeling observable input and output channels of the program (e.g., static variables like `System.in` and `System.out`, and public method parameters and results in public APIs) [10]. To statically check conformance with policy, labels are needed on intermediate interfaces such as methods, fields, and local variables. It is straightforward (and implemented by the JFlow tool) to infer labels for local variables, and feasible to infer labels for fields and methods and to allow label polymorphism [18]. In this paper, we take as given the result of inference, assuming labels are provided for all methods, fields, and locals.

Without loss of generality, we assume that all field and local variable names are distinct, so the label assignment can be given as a single function, Γ, from variable names to levels, and a function, `fieldlevel`, from field identifiers to levels.

### Security Policy and Noninterference
A policy determines a notion of indistinguishability for states. Indistinguishability is interpreted here in terms suitable for static checking of programs, not considering covert channels such as timing and power consumption. Two states are indistinguishable for an observer at level k if they agree on variables and fields labeled k or below. A program is called noninterferent [15] if it conforms to the policy in the standard sense: given two initial states that are indistinguishable for the low observer, the corresponding pair of final states from two runs of the program are indistinguishable. In this paper, we do not consider divergence to be observable. The low observer can distinguish between normal and abnormal termination (uncaught exception). To account for dynamic allocation and aliasing, indistinguishability is formalized using a bijective renaming for low-visible locations [3, 7].

Barthe et al. [7] prove noninterference for a bytecode type system very similar to the one used here, so we refrain from giving the formal details in the present paper. Note, however, that their formalization treats all abnormal states as indistinguishable (as if upon abnormal termination, the attacker cannot read any of the state). In the present paper, we consider that exceptions can carry information. The low observer can test the type and even fields of an exception object; other parts of the state could therefore be observable. In fact, the type system of [7] ensures indistinguishability of the entire state even in the abnormal case (as can be seen by inspecting their proofs).

Our treatment of exceptions is conservative for notational simplicity: we do not distinguish the security levels of exceptions by type but lump all exceptions together. For practical use, one would replace our single exception level by a set of levels, indexed by relevant exception type, which can then be tracked with relative precision since the `try-catch` construct declares the type of exceptions handled. In the full version of the paper, we spell out this generalization, which is very similar to the treatment in JFlow [12], and formalize the details of indistinguishability where the low observer can read state even upon abnormal termination. The noninterference proof [7] is then adapted to the JVM rules in this paper.

In this version of the paper, exceptions are thrown for null dereferencing and by the explicit `throw` construct, but not by object construction. Whereas Java has an `OutOfMemoryException` that can be thrown by `(new)`, we assume an unbounded heap, as done in [7].

### Control Dependence Regions
Tracking information flow via control flow in a structured language without exceptions is easy since the analysis can exploit control structure [19, 3]. Exceptions make tracking cumbersome due to the loss of structured control flow. Our high-level type system tracks exception levels in a way similar to [9].

For unstructured low-level code, such as Java bytecode, implicit flows can be tracked in terms of an analysis of control dependence regions, which provides information about different blocks in the program due to conditional or exceptional instructions. This analysis can be statically approximated [7, 14].

To deal with the mismatch between tracking implicit flows at the source and bytecode levels, we introduce an intermediate analysis that applies to source code but uses control dependence regions. One of the contributions of this paper is an inductive definition of control dependence regions for a language with exceptions. An important consequence of such an analysis for source programs is that, given a compiler from source programs to target programs, it is possible to obtain control dependence regions for the compiled program (Definition 7). In a scenario where the compiler is not trusted, it is possible to check that the regions given by the analysis based on compilation have the requisite properties for soundness of the information flow analysis (see Property 1, also in [7]).

### Methods
For lack of space, this version of the paper omits method calls. Their typing constraints are analogous to assignment statements, taking into account the security signature of the method. Signatures are used so that checking is modular, particularly, each method body is checked separately. We plan to extend this in future work and do not expect it to be too difficult. It was done in [3] and [7] without exceptions, and the full version of [7] includes exceptions. The security signature of a method reflects the security context used in typing judgments, particularly an upper bound on the result and lower bound on heap writes. A method signature would also give a bound on the level of information that can escape via uncaught exceptions. These constraints would be reflected in the rule for the return statement as well as constraints involving handlers, in rules for exception-throwing commands like field update.

## 3. High-Level Security Type System
In this section, we define a high-level type system for the source language. By "high-level," we mean that it consists of syntax-directed rules together with subsumption rules. It enforces the policy specified by a mapping, Γ, from variable names in the program to security levels and a mapping, `fieldlevel`, from field names to security levels.

### Source Language
Exceptions in Java can be explicitly programmed and are also thrown by expressions such as field updates.