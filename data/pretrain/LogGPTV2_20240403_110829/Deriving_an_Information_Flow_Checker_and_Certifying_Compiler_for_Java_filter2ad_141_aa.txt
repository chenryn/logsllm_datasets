title:Deriving an Information Flow Checker and Certifying Compiler for Java
author:Gilles Barthe and
Tamara Rezk and
David A. Naumann
Deriving an Information Flow Checker and
Certifying Compiler for Java
∗
Gilles Barthe1
David Naumann2
Tamara Rezk1
1INRIA Sophia-Antipolis, Project EVEREST,
{Gilles.Barthe,Tamara.Rezk}@sophia.inria.fr
2Stevens Institute of Technology
PI:EMAIL
Abstract
Language-based security provides a means to enforce end-
to-end conﬁdentiality and integrity policies in mobile code sce-
narios, and is increasingly being contemplated by the smart-
card and mobile phone industry as a solution to enforce infor-
mation ﬂow and resource control policies.
Two threads of work have emerged in research on language-
based security: work that focuses on enforcing security poli-
cies for source code, which is tailored towards developers that
want to increase conﬁdence in their applications, and work
that focuses on eﬃciently verifying similar policies for byte-
code, which is tailored to code consumers that want to pro-
tect themselves against hostile applications. These lines of
work serve diﬀerent purposes—and thus have been developed
independently—but connecting them is a key step towards the
deployment of language-based security in practical applica-
tions.
This paper introduces a systematic technique to connect
source code and bytecode security type systems. The technique
is applied to an information ﬂow type system for a fragment of
Java with exceptions, thus confronting challenges in both con-
trol and data ﬂow tracking.
1. Introduction
Security models for mobile code typically rely on typ-
ing mechanisms that statically enforce basic safety policies
(e.g. code containment or absence of pointer arithmetic)
and mechanisms such as stack inspection in Java and .NET
that dynamically enforce access control policies. While these
mechanisms are intended to enforce conﬁdentiality and in-
tegrity policies, it is diﬃcult to assess the end-to-end poli-
cies that they guarantee. In particular, they do not guaran-
tee information-ﬂow policies that are commonly desirable in
∗ Work partially supported by IST Projects Mobius; by the ACI
S´ecurit´e SPOPS; by the RNTL project CASTLES; and by US NSF
CCR-0208984 and CCF-0429894.
scenarios involving the execution of untrusted code. To en-
force these stronger security guarantees, information-ﬂow
type systems provide a means to track data ﬂows and con-
trol dependencies, and thereby to reject any program that
may leak conﬁdential information.
JFlow is an extension of Java with a ﬂexible and ex-
pressive information ﬂow type system [12]. The ﬂexibil-
ity and expressiveness of information ﬂow policies sup-
ported by JFlow has been exploited for modeling and an-
alyzing the policies that underlie battleship and mental
poker games [2]. Despite the richness of its language, the
information-ﬂow policies of JFlow can be enforced auto-
matically by a constraint-based algorithm that rejects pro-
grams that may violate their policy. However, the ﬂexibil-
ity of the type system, especially with respect to declassiﬁ-
cation, makes it diﬃcult to characterize formally the secu-
rity properties that are veriﬁed by typable programs. Thus,
subsequent work [4, 3] has focused on developing for a frag-
ment of Java that includes objects, inheritance, and meth-
ods, an information-ﬂow type system that enforces non-
interference, a baseline policy that requires that secret in-
put data cannot be inferred by an attacker that can only
observe public output. (Non-interference also captures in-
tegrity, by duality.)
The beneﬁts provided by JFlow (and [3]) do not directly
address mobile code security since they apply to source
code, whereas Java applets are deployed in compiled form as
JVM bytecode programs. Thus, it is desirable to develop in-
formation ﬂow type systems at bytecode level. An extended
bytecode veriﬁer is provided by [7]; their type system guar-
antees secure information ﬂow for a fragment of Java byte-
code that includes objects, inheritance, methods, and (a
simpliﬁed mechanism for) exceptions.
The type systems of JFlow and of [7] have been devel-
oped and applied in isolation: JFlow oﬀers a practical tool
for developing secure applications, and in particular for en-
suring to developers that applications meet high-level poli-
cies about API usage. In contrast, the type system of [7]
augments the Java security architecture to provide assur-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 22,2021 at 05:58:21 UTC from IEEE Xplore.  Restrictions apply. 
ance to users that applets respect high-level policies about
API usage. The value of these two lines of work can be
greatly increased by connecting them via a type preserva-
tion result, showing that programs typable in a suitable
fragment of JFlow will be compiled into bytecode programs
that pass information-ﬂow bytecode veriﬁcation (as sug-
gested, e.g., by Abadi [1]). The interest of such a result is to
show on the one hand that applications written with JFlow
can be deployed in a mobile code architecture that deliv-
ers the promises of JFlow in terms of conﬁdentiality, and
on the other hand that the enhanced security architecture
from [7] can beneﬁt from practical tools for developing ap-
plications that meets the policy it enforces.
This paper makes the following contributions:
• We propose a systematic method to derive an informa-
tion ﬂow type system for a high-level language (here, an
extension to exceptions of the fragment of Java in [3])
from an information ﬂow type system for a low-level
language (here, the fragment of the JVM in [7]) us-
ing a non-optimizing compiler [17] from Java source
to bytecode. The novelty of the resulting type system,
as compared to other type systems for high-level lan-
guages, is to rely on security environments: these assign
security levels to control points instead of to code frag-
ments. The ﬂow of information via control is tracked by
propagating the levels of guard conditions along con-
trol paths. This approach was previously used only for
low-level languages. Another novelty induced by the
presence of security environments at source level is the
simpliﬁcation of the information ﬂow typing rules for
the JVM, as the security environment can be retrieved
from the source code and does not need to be com-
puted at bytecode level. The result is a simpler and
faster bytecode veriﬁcation algorithm for information
ﬂow.
• We introduce a conventional type system for the same
fragment of Java source code and show that each pro-
gram typable in this high level type system is also ty-
pable in the intermediate type system based on security
environments. Further, by combining this result with
type-preserving compilation (the ﬁrst item above), we
show that a non-optimizing Java compiler [17] pre-
serves information ﬂow typing, in the sense that a pro-
gram typable by the high-level system for source pro-
grams will be compiled into a program that will be ac-
cepted by a bytecode veriﬁer that enforces secure in-
formation ﬂow.
The only previous type preserving compiler for information
ﬂow is that of [6] for a simple imperative language. As [6]
points out, an additional beneﬁt of type preservation is that
it proves noninterference for the source language type sys-
tem, provided that the compiler preserves semantics (as it
should) and noninterference has been shown for the target
language. Thus another contribution of this paper is to add
exceptions to the language in [3], but, instead of extend-
ing their soundness proof we can obtain noninterference for
the high level type system using our type preservation re-
sult and the noninterference result of [7].
Besides [7], there has been some work on secure infor-
mation ﬂow for typed assembly languages. Medel at al. [11]
treat a simple imperative assembly language, tracking im-
plicit ﬂows using code annotations so the typing rules can,
in eﬀect, recover structured control ﬂow. In work subse-
quent to ours, Yu and Islam [20] treat a richer assembly
language with indirect addressing/aliasing and code point-
ers but still not heap allocation or object-oriented features.
A comparable advance is made independently in [8]. These
works prove that their rules ensure noninterference; [20] also
gives a security-type preserving translation from an imper-
ative language with ﬁrst order procedures.
Overview. The key technical idea is to connect unstructured
bytecode with structured source code by way of an interme-
diate type system which applies to source code but tracks
control dependence regions in terms of control ﬂow labels
just as it is done for bytecode in [7]. Although one of the con-
tributions is a method to derive a type system for source
code from one for target code, we only have space to present
the result of this derivation. So for clarity we present the
type systems top down. Section 2 reviews security policy
and noninterference in the presence of exceptions and heap
allocation; it also gives an overview of control dependence
regions. Section 3 gives the source language and its high
level security type system. Section 4 gives the key deﬁni-
tion of the paper, a type system for source programs that
deals with control ﬂow using explicit control point labels.
Section 5 connects these two type systems. Section 6 gives
the target language and its security typing and deﬁnes the
non-optimizing compiler. Section 7 connects the intermedi-
ate typing system with the target one and proves the main
result. The concluding section discusses how the results can
be adapted to optimizing compilers and richer policies such
as those in JFlow.
2. Secure ﬂow policy and control depen-
dence regions
We assume given a lattice S of security levels. Conﬁden-
tiality policy is speciﬁed by labeling with security levels the
observable input and output channels of the program (in
particular, static variables like System.in and System.out
and also public method parameters and results in public
APIs) [10]. In order to statically check conformance with
policy, labels are needed on intermediate interfaces such as
methods, ﬁelds, and local variables. It is straightforward
(and implemented by the JFlow tool) to infer labels for lo-
cal variables, and feasible to infer labels for ﬁelds and meth-
ods and to allow label polymorphism [18]. In this paper we
take as given the result of inference, that is, we assume la-
bels are given for all methods, ﬁelds, and locals.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 22,2021 at 05:58:21 UTC from IEEE Xplore.  Restrictions apply. 
Without loss of generality we assume that all ﬁeld, and
local variable names are distinct so that the label assign-
ment can be given as a single function, Γ, from variable
names to levels and a function, ﬁeldlevel, from ﬁeld identi-
ﬁers to levels.
Security policy and noninterference. A policy determines a
notion of indistinguishability for states. Indistinguishabil-
ity is interpreted here in terms suitable for static check-
ing of programs: it does not consider covert channels such
as timing and power consumption. Roughly speaking, two
states are indistinguishable for an observer at level k if they
agree on variables and ﬁelds labeled k or below. A program
is called noninterferent [15] if it conforms to the policy in
the standard sense: given two initial states that are indis-
tinguishable for the low observer, the corresponding pair of
ﬁnal states from two runs of the program are indistinguish-
able. In this paper we do not consider divergence to be
observable. The low observer can distinguish between nor-
mal and abnormal termination (uncaught exception). To ac-
count for dynamic allocation and aliasing, indistinguishabil-
ity is formalized using a bijective renaming for low-visible
locations [3, 7].
Barthe et al. [7] prove noninterference for a bytecode type
system very similar to the one used here, so we refrain from
giving the formal details in the present paper. Note, how-
ever, that their formalization treats all abnormal states as
indistinguishable (as if upon abnormal termination the at-
tacker cannot read any of the state). In the present paper
we consider that exceptions can carry information. Surely
the low observer can test the type and even ﬁelds of an ex-
ception object; other parts of the state could therefore be
observable. In fact, the type system of [7] ensures indistin-
guishability of the entire state even in the abnormal case
(as can be seen by inspecting their proofs).
Our treatment of exceptions is rather conservative for the
sake of notational simplicity: we do not distinguish the se-
curity levels of exceptions by type, but instead lump all ex-
ceptions together. For practical use, one would replace our
single exception level by a set of levels, indexed by relevant
exception type; this can then by tracked with relative preci-
sion since the try-catch construct declares the type of excep-
tions handled. In the full version of the paper we spell out
this generalization, which is very similar to the treatment
in JFlow [12], and formalize the details of indistinguisha-
bility where the low observer can read state even upon ab-
normal termination. The noninterference proof [7] is then
adapted to the JVM rules in this paper.
In this version of the paper, exceptions are thrown for
null dereferencing and by the explicit throw construct, but
not by object construction. Whereas Java has an Out-
OfMemoryException that can be thrown by (new), we as-
sume an unbounded heap since that is what is done in [7].
Control dependence regions. Tracking information ﬂow via
control ﬂow in a structured language without exceptions is
easy since the analysis can exploit control structure [19, 3].
Exceptions make tracking cumbersome due to the loss of
structured control ﬂow. Our high level type system tracks
exception levels in a way similar to [9].
For unstructured low level code, such as Java bytecode,
implicit ﬂows can be tracked in terms of an analysis of con-
trol dependence regions which gives information about dif-
ferent blocks in the program due to conditional or excep-
tional instructions. This analysis can be statically approxi-
mated [7, 14].
To deal with this mismatch between tracking of implicit
ﬂows at source and bytecode level, we introduce an inter-
mediate analysis that applies to source code but uses con-
trol dependence regions. One of the contributions of this
paper is an inductive deﬁnition of control dependence re-
gions for a language with exceptions. An important conse-
quence of such an analysis for source programs is that, given
a compiler from source programs to target programs, it is
possible to obtain control dependence regions for the com-
piled program (Deﬁnition 7). In a scenario where the com-
piler is not trusted, it is possible to check that the regions
given by the analysis based on compilation has the requi-
site properties for soundness of the information ﬂow analy-
sis (see Property 1, also in [7]).
Methods. For lack of space, this version of the paper also
omits method calls. Their typing constraints are analogous
to assignment statements, taking into account the secu-
rity signature of the method. Signatures are used so that
checking is modular, in particular, each method body is
checked separately. We plan to make the extension in fu-
ture work and do not expect it to be too diﬃcult. It was
done in [3] and [7] without exceptions, and the full ver-
sion of [7] includes exceptions. The security signature of a
method reﬂects the security context used in typing judge-
ments (in particular, of the method body), in particular
an upper bound on the result and lower bound on heap
writes. A method signature would also give a bound on
the level of information that can escape via uncaught ex-
ceptions. These constraints would be reﬂected in the rule
for the return statement as well constraints involving han-
dlers, in rules for exception-throwing commands like ﬁeld
update.
3. High level security type system
In this section we deﬁne a high level type system for the
source language. By high level we mean that it consists of
syntax-directed rules together with subsumption rules. It
enforces the policy speciﬁed by a mapping, Γ, from vari-
able names in the program to security levels and a map-
ping, ﬁeldlevel, from ﬁeld names to security levels.
Source language. Exceptions in Java can be explicitly pro-
grammed and are also thrown by expressions such as ﬁeld