view of server 0, while (dpf1, 𝑀 0→1, 𝑀 2→1) suffices to re-
construct the view of server 1 and (𝑀 2→0, 𝑀 2→1) consti-
tutes the entire view of server 2. The prover constructs
a 4-ary Merkle-tree (with height 1) having root H (cid:66)
Hash(cw(0)∥ · · · ∥cw(ℎ)∥𝐻 0→1∥𝐻 1→0∥𝐻 2→0∥𝐻 2→1), and then it
sends
1) Π(0) (cid:66) (𝑀 1→0, 𝑀 2→0, 𝐻 2→1) to server 0,
2) Π(1) (cid:66) (𝑀 0→1, 𝑀 2→1, 𝐻 2→0) to server 1, and
3) Π(2) (cid:66) (𝐻 0→1, 𝐻 1→0, 𝑀 2→0, 𝑀 2→1) to server 2.
To verify its portion of
server 0 uses
(dpf0, 𝑀 1→0, 𝑀 2→0)
if
it
(𝑀 0→1, 𝑀 1→0, 𝑀 2→0, 𝐻 2→1) is not consistent with the Merkle
root H. Servers 1 and 2 verify their portions analogously.
The 3-verifier SNIP is accepting if and only if (i) each of
the three servers received the same Merkle root H, and
(ii) none of the servers rejects its portion of the SNIP. Since
the three verifiers collectively scrutinize all views from the
simulation,
inconsistencies in the simulation cannot escape
notice by at least one verifier (discounting the negligible
probability of hash collisions when constructing the Merkle
tree). In particular, we have just argued that—except with
probability negligible in the hash-length 𝜇—a prover can
produce an accepting 3-verifier SNIP for (dpf0, dpf1) and [𝑖]
only if these same values would have passed (2 + 1)-party
auditing—which has perfect soundness. Moreover, because
each verifier merely inspects one view from the (2+1)-party
audit protocol,
the view of any given verifier remains
trivially simulatable; we have thus proved the following
theorem.
Theorem 3. The 3-verifier SNIP auditing protocol with hash
function Hash: {0, 1}∗ → {0, 1}𝜇 is perfectly simulatable and
has perfect completeness and soundness overwhelming in 𝜇.
the SNIP,
recreate 𝑀 0→1;
rejects
to
A more detailed proof sketch for Theorem 3 is included as
Appendix E.
3) 2-verifier SNIP auditing: The 2-verifier SNIP audit pro-
tocol employs cut-and-choose to eliminate the need for a
third verifier while maintaining soundness error negligible
in 𝜇. Specifically, upon sampling its DPF keys, the prover
now runs 𝜇 parallel simulations of the (2 + 1)-party audit
protocol, committing to each unidirectional communication
link among the three parties in each simulation. For each
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 14:58:18 UTC from IEEE Xplore.  Restrictions apply. 
91961
𝑖
𝑖
).
let 𝑀 𝑎→𝑏
𝑖 = 1, . . . , 𝜇,
denote the ordered sequence of
messages sent from party 𝑎 to party 𝑏 in the 𝑖 th parallel
simulation and let 𝐻 𝑎→𝑏
𝑖 (cid:66) Hash(𝑀 𝑎→𝑏
As in the 3-verifier SNIPs, the prover constructs a Merkle
tree committing to all unidirectional channel commitments.
In particular, for each 𝑖 = 1, . . . , 𝜇, it computes the digest
H𝑖 (cid:66) Hash(cw(0)∥ · · · ∥cw(ℎ)∥𝐻 0→1
), and
then it constructs the Merkle root as Hash(H1∥ · · · ∥H𝜇).
Regarding Hash as a random oracle, each of the 𝜇 bits
of the Merkle root constitutes a distinct “challenge” (à la
Fiat-Shamir [15]): when the bit is 0, each verifier will inspect
“its own” view; when the bit is 1, both verifies will inspect
server 2’s view. Such a tree is depicted in Figure 3.
∥𝐻 2→0
∥𝐻 2→1
∥𝐻 1→0
𝑖
𝑖
𝑖
𝑖
𝑐3
𝑐4
𝑐1
𝑐2
0 0 1 0 · · · 1 0 1 1
𝑐𝜇-3 𝑐𝜇-2 𝑐𝜇-1
𝑐𝜇
H1
𝐻 1→0
1
𝐻 0→1
1
𝐻 2→0
1
𝐻 2→1
1
· · ·
· · ·
H𝜇
𝐻 1→0
𝜇
𝐻 0→1
𝜇
𝐻 2→0
𝜇
𝐻 2→1
𝜇
𝑀 0→1
1
𝑀 2→1
𝑀 1→0
1
Fig. 3: Merkle-tree commitment for 2-verifier SNIPs.
𝑀 2→1
1
𝑀 2→0
1
𝑀 0→1
𝑀 1→0
𝑀 2→0
𝜇
𝜇
𝜇
𝜇
· · ·
Let 𝑐𝑖 denote the 𝑖 th bit of the Merkle root. For each 𝑖 =
(cid:40)(𝑀 1→0
𝑖
(𝑀 2→0
𝑖
1, . . . , 𝜇, the prover discloses the tuple
)
Π(0)
𝑖 (cid:66)
, 𝑀 2→0
, 𝑀 2→1
𝑖
𝑖
, 𝐻 2→1
)
𝑖
if 𝑐𝑖 = 0, and
otherwise,
to server 0, and symmetrically for server 1.
𝑖
To verify its portion of the SNIP, server 𝑏 uses dpf𝑏 and
the Π(𝑏)
to reconstruct the missing leaf hashes, and then it
checks their consistency with the Merkle root. The 2-verifier
SNIP is accepting if and only if (i) both servers received
the same Merkle root H, (ii) the tuple disclosed in each Π(𝑏)
𝑖
is consistent with the challenge bit 𝑐𝑖 from this root, and
(iii) neither server rejects its portion of the SNIP.
As per Theorem 3, even a single inconsistency-free simu-
lation suffices to establish well-formedness of the DPF with
probability overwhelming in 𝜇; moreover, if a given simula-
tion does have an inconsistency, then this inconsistency must
be evident in the view of either server 2 or at least one of
servers 0 or 1 and will, therefore, be detected with probability
at least 1
2. Furthermore, as with 3-verifier SNIP auditing,
the view of any given verifier remains trivially simulatable.
Hence, we obtain the following theorem.
Theorem 4. The 2-verifier SNIP auditing protocol with hash
function Hash: {0, 1}∗ → {0, 1}𝜇 is perfectly simulatable and
has perfect completeness and soundness overwhelming in 𝜇.
A more detailed proof sketch for Theorem 4 is included as
Appendix F.
VI. Security Guarantees
their read and write requests directly to some ideal func-
tionality, who faithfully executes the requested actions while
leaking no superfluous information to external observers.
In the real world, one of the 2- or 3-server Sabre-BB or
Sabre-M instantiations replaces the ideal functionality. We
then consider an attacker A who controls an arbitrary
number of readers and writers in addition to (at most) one
server.
Informally, we wish to show that A cannot exploit its
privileged position as a Sabre server to compromise sender
anonymity. We do this by exhibiting an efficient simulator
that interacts with the ideal functionality to sample “simu-
lated” views from a distribution close to the one describing
A’s view in the real world. We then ask whether A can adap-
tively conjure up sequences of events allowing it to distin-
guish between real and simulated views; if not, we conclude
that the real Sabre protocols leak essentially nothing beyond
what is leaked by their ideal-world counterparts.
Due to space constraints, we defer a detailed security
definition and analysis to Appendix G.
VII. Implementation and Evaluation
To assess the practicality of Sabre, we wrote a proof-of-
concept reference implementation in C++. Our implemen-
tation uses Boost.Asio v1.18.1 for asynchronous communi-
cation, OpenSSL 1.1.1i for hashing and TLS support, and
dpf++ [18] for (2, 2)-DPFs; we wrote all other non-STL
functionality by hand.6
Experimental setup: We ran a series of experiments on
Amazon EC2, with the servers running in geographically
distant locations to mimic realistic Internet latency. The
servers are all m5.4xlarge instances equipped with 64 GiB
of RAM and 16 vCPUs, running the standard Ubuntu 18.04
AMI. For each of the experiments reported in this section, we
configured LowMC to use 128-bit blocks (and 128-bit keys)
with r = 19 rounds consisting of s = 32 S-boxes a piece.
Appendix C presents experimental results to justify these
parameter choices. (As a spoiler, this setting turns out to be
pessimal with respect to (2+1)-party auditing and SNIPs, but
optimal for the full-domain evaluation, which dominates the
execution time.) We ran all experiments for 100 trials and
report in our plots the sample mean over those 100 runs.
(The plots also show error bars, but in most cases they are
too small to see.)
In order to sustain high throughput, Sabre uses a custom
bitsliced implementation of LowMC that operates on either
128 or 256 ciphertexts in parallel using SIMD operations;
thus, several of our plots report the wall-clock time to process
batches of size 128 where the reader might naturally expect
to find the cost for “singleton” batches.
A. Communication Cost
We first present an (analytically determined) accounting of
communication costs for all three variants of Sabre auditing.
We define security for Sabre in the ideal-world/real-world
simulation paradigm. In the ideal world, Sabre users hand
6Our source code is available under the GNU General Public License
(version 3) via https://pr.iva.cy/sabre.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 14:58:18 UTC from IEEE Xplore.  Restrictions apply. 
101962
TABLE I: Communication cost of auditing (in bytes) for a Sabre instance with 𝑛 = 2ℎ buckets/mailboxes. In the table,
ℎ = lg 𝑛 denotes the height of the DPF tree, while r and s respectively denote the number of rounds and S-boxes in
LowMC with 128-bit blocks. The 2-verifier SNIP employs cut-and-choose with soundness error ≈ 2−128.
client→server 𝒃
Audit type
(2+1)-party
112+⌈(64.25+3sr)(ℎ−1)⌉
3-verifier SNIP
2-verifier SNIP 37 888+(4 112+192sr)(ℎ−1)
—
—
64
—
8 + 3
2
16
16
client→server 2 server 𝒃↔server (1 − 𝒃)
sr)(ℎ−1)
16+(16 1
server 𝒃→server 2
16+(16 1
sr)(ℎ−1) 16+(32 1
server 2→server 𝒃
sr)(ℎ−1)
8 + 3
2
16
—
8 + 3
2
16
—
The costs are summarized in Table I, with the derivations
of these numbers included as Appendix H. (Note that these
costs account for auditing only; they do not include the DPF
itself.) Observe that the client-to-server communication cost
in both 2- and 3-verifier SNIP-based auditing scales with the
product rs of LowMC parameters. (To a first approximation,
r ≈ lg s so that proof-size scaling is more or less softly linear
in r.) Also notice that 3-verifier SNIPs reduce communication
about (𝜆/2)-fold relative to 2-verifier SNIPs; however, this
reduction comes at the cost of an additional server and a
correspondingly stronger non-collusion assumption.
B. Auditing
Our first set of experiments measure the cost of Sabre
auditing and compare it with that of Riposte and Express
auditing. Figure 4 shows the relative cost of (2 + 1)-party,
3-verifier SNIP, and 2-verifier SNIP auditing in Sabre.
)
s
m
(
e
m
i
t
k
c
o
l
c
-
l
l
a
W
103
102
101
210
2-verifier SNIP
3-verifier SNIP
(2+1)-PC
216
234
Number of buckets/mailboxes (𝑛)
228
222
240
Fig. 4: Time to audit a batch of 128 requests in Sabre.
Owing to its reliance on cut-and-choose with 𝜆 = 128
instances, the 2-verifier SNIP auditing is by far
parallel
the slowest of the pack, taking two orders of magnitude