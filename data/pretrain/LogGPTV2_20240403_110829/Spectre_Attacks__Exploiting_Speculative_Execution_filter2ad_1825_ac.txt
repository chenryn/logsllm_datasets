A. Experimental Results
i5-6200U,
We performed experiments on multiple x86 processor ar-
including Intel Ivy Bridge (i7-3630QM), Intel
chitectures,
Haswell (i7-4650U), Intel Broadwell (i7-5650U), Intel Skylake
(unspeciﬁed Xeon on Google Cloud,
i7-6600U,
i7-6700K), Intel Kaby Lake (i7-7660U), and AMD Ryzen.
The Spectre vulnerability was observed on all of these CPUs.
Similar results were observed on both 32- and 64-bit modes,
and both Linux and Windows. Some processors based on the
ARM architecture also support speculative execution [7], and
our initial testing on a Qualcomm Snapdragon 835 SoC (with
a Qualcomm Kyro 280 CPU) and on a Samsung Exynos 7420
Octa SoC (with Cortex-A57 and Cortex-A53 CPUs) conﬁrmed
that these ARM processors are impacted. We also observe that
speculative execution can proceed far ahead of the instruction
pointer. On a Haswell i7-4650U, the code in Appendix C
(cf. Section IV-B) works with up to 188 simple instructions
inserted in the source code between the ‘if’ statement and
the line accessing array1/array2, which is just below the
192 micro-ops that ﬁt in the reorder buffer of this processor
(cf. Section II-B).
B. Example Implementation in C
Appendix C includes a proof-of-concept code in C for
x86 processors1 which closely follows the description in
Section IV. The unoptimized implementation can read around
10 KB/s on an i7-4650U with a low (= length, branch to instruction after movq below
; Set rsi = r12 + rdx = addr of first byte in simpleByteArray
; Read byte from address rsi+r15 (= base address + index)
; Multiply rsi by 4096 by shifting left 12 bits
; AND reassures JIT that next operation is in-bounds
; Read from probeTable
; XOR the read result onto localJunk
; Copy localJunk into rdi
Listing 3: Disassembly of JavaScript Example from Listing 2.
Context A
Context B
call [function]
?? ?
call [function]
...
...
function A
function B
Branch
Predictor
spectre gadget
legit function
s
p
e
c
u
l
a
t
e
Fig. 2: The branch predictor is (mis-)trained in the attacker-
controlled context A. In context B, the branch predictor makes
its prediction on the basis of training data from context A,
leading to speculative execution at an attacker-chosen address
which corresponds to the location of the Spectre gadget in the
victim’s address space.
V. VARIANT 2: POISONING INDIRECT BRANCHES
In this section, we demonstrate how indirect branches can
be poisoned by an attacker and the resulting misprediction of
indirect branches can be exploited to read arbitrary memory
from another context, e.g., another process. Indirect branches
are commonly used in programs across all architectures (cf.
Section II-C). If the determination of the destination address of
an indirect branch is delayed, e.g., due to a cache miss, spec-
ulative execution will often continue at a location predicted
from previous code execution.
In Spectre variant 2, the adversary mistrains the branch
predictor with malicious destinations, such that speculative
execution continues at a location chosen by the adversary.
This is illustrated in Figure 2, where the branch predictor
is (mis-)trained in one context, and applies the prediction
in a different context. More speciﬁcally, the adversary can
misdirect speculative execution to locations that would never
occur during legitimate program execution. Since speculative
execution leaves measurable side effects, this is an extremely
powerful means for attackers, for example exposing victim
memory even in the absence of an exploitable conditional
branch misprediction (cf. Section IV).
For a simple example attack, we consider an attacker
seeking to read a victim’s memory, who has control over
two registers when an indirect branch occurs. This commonly
occurs in real-world binaries since functions manipulating
externally-received data routinely make function calls while
registers contain values that an attacker controls. Often these
values are ignored by the called function and instead they are
simply pushed onto the stack in the function prologue and
restored in the function epilogue.
The attacker also needs to locate a “Spectre gadget”, i.e.,
a code fragment whose speculative execution will transfer the
victim’s sensitive information into a covert channel. For this
example, a simple and effective gadget would be formed by
two instructions (which do not necessarily need to be adjacent)
where the ﬁrst adds (or XORs, subtracts, etc.) the memory
location addressed by an attacker-controlled register R1 onto
an attacker-controlled register R2, followed by any instruction
that accesses memory at
the address in R2. In this case,
the gadget provides the attacker control (via R1) over which
address to leak and control (via R2) over how the leaked
memory maps to an address which is read by the second
instruction. On the CPUs we tested, the gadget must reside
in memory executable by the victim for the CPU to perform
speculative execution. However, with several megabytes of
shared libraries mapped into most processes [25], an attacker
has ample space to search for gadgets without even having to
search in the victim’s own code.
Numerous other attacks are possible, depending on what
state is known or controlled by the adversary, where the
information sought by the adversary resides (e.g., registers,
stack, memory, etc.), the adversary’s ability to control spec-
ulative execution, what instruction sequences are available to
form gadgets, and what channels can leak information from
(cid:25)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:03 UTC from IEEE Xplore.  Restrictions apply. 
speculative operations. For example, a cryptographic function
that returns a secret value in a register may become exploitable
if the attacker can simply induce speculative execution at an
instruction that brings memory from the address speciﬁed in
the register into the cache. Likewise, although the example
above assumes that the attacker controls two registers, attacker
control over a single register, value on the stack, or memory
value is sufﬁcient for some gadgets.
In many ways, exploitation is similar to return-oriented
programming (ROP), except that correctly-written software is
vulnerable, gadgets are limited in their duration but need not
terminate cleanly (since the CPU will eventually recognize the
speculative error), and gadgets must exﬁltrate data via side
channels rather than explicitly. Still, speculative execution can
perform complex sequences of instructions, including reading
from the stack, performing arithmetic, branching (including
multiple times), and reading memory.
Mistraining branch predictors on x86 processors. The
attacker, from its own context, performs a mistraining of the
branch predictors to trick the processor into speculatively
executing the gadget when it runs the victim code. Our attack
process mimics the victim’s pattern of branches leading up to
the branch to be misdirected.
Note that the history mistraining requirements vary among
CPUs. For instance, on a Haswell i7-4650U, the low 20 bits of
the approximately 29 prior destination addresses are used, al-
though some further hashing on these addresses was observed.
On an AMD Ryzen, only the low 12 bits of the approximately
prior 9 branches are used. The reverse-engineered pseudo
code for updating the branch history buffer on an Intel Xeon
Haswell E5-1650 v3 is provided in Appendix A.
In addition, we placed a jump for mistraining at the same
virtual address in the attacker as in the victim process. Note
that this may not be necessary, e.g., if a CPU only indexes
predictions based on the low bits of the jump address. When
mistraining branch predictors, we only need to mimic the
virtual addresses; physical addresses, timing, and process ID
do not appear to matter. Since the branch prediction is not
inﬂuenced by operations on other cores (cf. Section II-C), any
mistraining has to be done on the same CPU core.
We also observed that branch predictors learn from jumps
to illegal destinations. Although an exception is triggered in
the attacker’s process, this can be caught easily, e.g., using a
signal handler on Linux or structured exception handling on
Windows. As in the previous case, the branch predictor will
then make predictions that send other processes to the same
destination address, but in the victim’s virtual address space
(i.e., the address space in which the gadget resides).
Lake (i7-7660U), AMD Ryzen, as well as some ARM proces-
sors. We were able to observe similar results on both 32- and
64-bit modes, and different operating systems and hypervisors.
To measure the effectiveness of branch poisoning, we im-
plemented a test victim program that repeatedly executes a
ﬁxed pattern of 32 indirect
jumps, ﬂushes the destination
address of the ﬁnal jump using clflush and uses Flush+
Reload on a probe memory location. The victim program also
included a test gadget that reads the probe location and is never
legitimately executed. We also implemented an attack program