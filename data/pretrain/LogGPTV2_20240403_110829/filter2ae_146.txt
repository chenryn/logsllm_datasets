# 【技术分享】.NET逆向工程——第1部分
|
##### 译文声明
本文是翻译文章，文章来源：codepool.me
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
翻译：[维一零](http://bobao.360.cn/member/contribute?uid=32687245)
预估稿费：100RMB
投稿方式：发送邮件至[linwei#360.cn](mailto:PI:EMAIL)，或登陆[网页版](http://bobao.360.cn/contribute/index)在线投稿
**前言**
你有没有曾经感觉自己是一块狗屎，只是一个知道如何组合从StackOverflow找到的源代码？
不是么？去他妈的自己。就个人而言，我经常有这种感觉。
这种感觉督促我去学习新的东西，寻找方法来测试我的大脑，玩逆向工程只是一种正确的事情，让我开始感觉再次像一个核心开发人员（或者只是和狗屎有点不一样而已）。
这里是我学习新事物的秘诀：
1、感觉自己像狗屎。
2、做一些“酷”的东西。
3、等待15分钟，然后转到第1点（注意不要在源代码中使用goto跳转。）
好的，如果你调整好正确的心情，就让我们开始进入正题。
**.NET逆向工程**
上一次我们已经混淆了一个使用VB.NET编写的加密器。我们的主要目标是找出加密的逻辑和方法。我认为逆向工程最难的部分之一是确定逻辑，而不仅仅是写一个补丁或从程序中找出一个密钥。
在这部分我们将：
**1、移除各种反逆向的保护。**
**2、使程序可反编译和运行。**
关于如何尝试多个反混淆工具而不靠运气这里可以写很多文章，让我们跳过这一步，试试自己手动来进行。（右手是最有效的，感觉更好）。
让我们使用[dnSpy](https://github.com/0xd4d/dnSpy)加载程序集。然后，看看我们的模块和类，然后我们注意到的是，在程序集中定义的方法没有被反编译。
这意味着我们的方法被加密在某些隐藏节里（而不是在第一个节里），当程序运行时它从那个节里解密出方法，并把它们放到正确的地方。为了确认这点让我们用CFF资源管理器打开我们的程序集并导航到PE部分。
是的，我们是对的。现在我们必须在源代码中找到函数解密和修复发生的地方。观察一会之后就变得清楚了，该过程发生在.ctor。此构造函数在应用程序的主入口点之前被调用。这意味着它是进行这种工作的完美地方。
重新打开dnSpy，然后右键单击程序集 – >转到 .cctor。
因为在类中有些函数也没有被反编译，我们得出结论，修复的方法必须在第一次调用期间发生，所以让我们跟进看看。
这里我们看到一个从kernel32.dll导入的函数调用VirtualProtect。这个函数用于设置内存块的访问属性。好吧，这给了我们：程序获取节地址（方法真正的位置）并设置PAGE_EXECUTE属性…。我们不想知道更多细节了。我们发现了方法被修复的确切地方，就是它。
让我们在调用之后设置一个断点，然后从内存中转储程序集。
保存并使用dnSpy打开新保存的模块。现在可以看到我们的方法被反编译好了，感觉还可以。我们做到了！
**但是仍然有一个问题，我们的.exe是损坏的，因为我们忘记移除“方法修复函数”。**
程序仍然认为它需要修复方法（但方法已经被修复），所以有些东西就完全混乱了。
现在让我们移除该函数并再次保存程序集。
然后单击模块，再单击文件 – >保存模块。不要忘记设置MD Writer选项，如：
好了，现在我们有一个可运行的可执行文件与被反编译的方法。
这里有一个给你的完美[ **逆向工程**](https://www.youtube.com/watch?v=Itt1nn9aWz0) 曲。
在下一部分，我们将尝试破解并激活。