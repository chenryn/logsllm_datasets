# 技术分享：.NET逆向工程——第1部分

## 译文声明
本文为翻译文章，原文来源：codepool.me。译文仅供参考，具体内容及含义以原文为准。
- 翻译者：维一零（[个人主页](http://bobao.360.cn/member/contribute?uid=32687245)）
- 预估稿费：100 RMB
- 投稿方式：发送邮件至 [linwei@360.cn](mailto:linwei@360.cn)，或访问 [网页版投稿平台](http://bobao.360.cn/contribute/index)

## 前言
你是否曾觉得自己像一块废物，只会从StackOverflow上拼凑代码？我经常会有这种感觉。但正是这种自我怀疑推动我去学习新知识、寻找挑战，并尝试逆向工程。这让我重新找回了作为一名核心开发者的自信。以下是我在学习过程中遵循的三个步骤：
1. 认识到自己的不足。
2. 完成一些“酷”的项目。
3. 休息片刻后，重复第一步。

如果你已经准备好接受挑战，让我们正式开始今天的主题。

## .NET逆向工程简介
在之前的文章中，我们讨论了一个用VB.NET编写的加密器的混淆过程。我们的主要目标是揭示其内部的加密逻辑和机制。我认为逆向工程中最难的部分之一就是理解程序背后的逻辑，而不仅仅是简单地修补漏洞或提取密钥。

在这篇文章中，我们将：
1. 移除各种反逆向保护措施。
2. 使程序能够被成功反编译并运行。

虽然可以写很多关于如何有效使用多种反混淆工具的文章，但我们今天将直接手动进行操作。（手动操作往往更有效率且更有成就感。）

### 使用dnSpy加载程序集
首先，使用[dnSpy](https://github.com/0xd4d/dnSpy)打开待分析的程序集文件。浏览模块与类定义时，你会发现某些方法无法被正常反编译。这意味着这些方法可能存储在一个隐藏的数据段内，在运行时才会被解密并加载到正确的位置。

为了验证这一假设，请使用CFF Explorer打开该程序集并查看PE头信息。果然，我们的猜测得到了证实。接下来需要找到源码中执行此解密操作的具体位置。经过仔细观察，发现这个过程发生在`.cctor`构造函数中，即应用程序启动前调用的一个初始化函数。

### 跟踪方法修复过程
回到dnSpy界面，右键点击相关类 -> 选择 "Go to .cctor" 选项。由于还有其他几个未被反编译的方法存在，我们可以推断出修复工作应该会在首次调用时自动完成。因此，让我们继续跟踪下去。

在此处可以看到一个对 `VirtualProtect` 函数（来自 kernel32.dll）的调用，该函数用于更改内存区域的访问权限。通过这种方式，程序获取到了存储实际方法体的数据段地址，并将其设置为可执行状态。现在我们已经找到了方法修复的确切位置。

### 保存修改后的程序集
在上述调用之后设置断点，并从内存中导出更新后的程序集。然后再次使用dnSpy打开新生成的文件，此时你应该能看到所有方法均已成功反编译。

然而还有一个问题：当前的 `.exe` 文件仍然是损坏的，因为我们还没有移除原有的“方法修复”代码。程序仍然试图去修复已经被修复过的方法，导致了一些混乱的情况发生。

解决办法很简单：删除这部分多余的代码，并重新保存整个程序集。确保勾选正确的MD Writer选项，以保证输出格式正确无误。

至此，我们就得到了一个完全可用且已反编译的目标文件。

最后推荐一首适合进行逆向工程工作的背景音乐：[逆向工程BGM](https://www.youtube.com/watch?v=Itt1nn9aWz0)。

下一篇文章中，我们将进一步探讨如何破解和激活该程序。