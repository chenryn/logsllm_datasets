We apply Coppersmith algorithm and its variants to solve
the co-ACD problem. Given τ ciphertexts in our scheme,
we might guess the log τ most signiﬁcant bits of hidden pi’s.
Then, we obtain a multivariate polynomial and several uni-
variate polynomials that have common divisors when eval-
uated at certain points. We devise a new algorithm to ﬁnd
these common divisors by extending the Coppersmith algo-
rithm and show that the co-ACD problem is still hard for
our parameters. Due to the space limitation, we omit Cop-
persmith algorithm for one instance of the co-ACD problem.
Recently, Cohn and Heninger improved an algorithm to
solve the ACD problem using multiple instances. We ap-
ply this to solve the co-ACD problem using its multiple in-
stances.
Theorem 4. Given τ instances ~ci = Φ(Qei) = (ci1, . . . ,
cik) of ˆDρ,Q and N , we can compute e1, . . . , eτ in polynomial
time if |ej|k  2ηk·j2/k2
≈ N β2
,
since N = p1 ·· · pk ≈ 2ηk, gcd(N, Gj(r1, . . . , rj)) ≥ p1 ··· pj ≈
N j/k, and j ≤ k. Hence, it does not work for our parame-
ters.
Moreover, since we may also have polynomials Fij (x) =
(xQ − ci1) ··· (xQ − cij) for 1 ≤ i ≤ τ and 1 ≤ j ≤ k − 1
when multiple instances are given, we may try to ﬁnd a
certain pi with such Fij’s and Gj using a lattice algorithm.
293The following theorem gives the condition under which we
may ﬁnd the solution of the co-ACD problem.
Then,
(X d1
1 · · · X dτ
τ )(Xτ +1 · · · Xτ +d)  ρ + log Q(C + 1) + log A + µ + 3 where C is the
number of allowed scalar multiplications.
γ + 2λ and µ > λ + log m + 1.
• Then, the bit size γ of fresh ciphertext is to be 2η.
• From Lemma 3, we set m and µ to be satisﬁed m >
• We set the size Q of the messages space to 2256. In
this case, it supports the calculation of the mean of
2127 nonnegative 128-bit integers.
Table 1 provides some concrete parameters for the number
of allowed additions. We have tested on an ordinary laptop
with an Intel Core i7-2600 processor running at 3.4 GHz,
with 16 GB of memory. Test results given in Table 1 are the
averages from 100 key generations and 100 operations per
key generation.
We also compare the performance of our public-key scheme
with that of previously proposed additive public-key homo-
morphic encryption schemes. To do this, we provide imple-
mentation results of Paillier encryption [41] and Joye and
Libert encryption [32]. For the case of a ring-LWE-based
additive homomorphic encryption scheme, we referred to the
implementation results in [36].2
The results show that the encryption of our scheme is a
little bit faster than the previous best result and decryption
and addition algorithms are much faster than the previous.
Though the public key size of ours is around 10 thousand
times larger than the previous, the ciphertext size is compa-
rable to the previous results. In summary, our additive ho-
momorphic encryption scheme is the most practical of those
that support an additive homomorphic property.
1We set η assuming N is given as the threshold version in
Section 6. Considering N is private in secret key and public
key schemes, η may become small and hence public key and
ciphertext sizes become short.
2Note that the implementation results provided in [36] can
be improved by estimating the parameter size according to
a recent result [46].
294[Pai99]
[NLV11]†
[JL13]