Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
3
fect attestation service satisfying all of the desired proper-
ties mentioned above, how would it aid us in designing se-
cure distributed systems?
First, if such an attestation service can be built, a cor-
rupted process immediately gets detected, and legitimate
processes can thereupon eliminate it from the distributed
system by refusing to accept any data they produce. Thus
the system architect no longer has to deal with Byzantine
faults on the part on the part of processes. Instead he only
needs to consider a simple fail-stop failure mode. By con-
trast, to deal with data falsiﬁcation attacks by malicious pro-
cesses, traditional Byzantine fault tolerant algorithms create
replicas of each process, and use variants of majority voting
algorithms to eliminate corrupted data. However, creating
replicas is expensive and hence often impractical. Mean-
while, though researchers have endeavored to improve the
performance of majority voting algorithms, they still in-
volve high communication overhead.
On the other hand, a ﬁne-grained attestation service does
not deal with data misuse attacks from malicious intermedi-
aries. In fact, similar to malicious delay and replay attacks,
probabilistic delays, duplicates, and out-of-order message
transmissions may just be inherent properties of the under-
lying network. The system architect should embed logic
in the process itself to deal with such attacks. Many ap-
proaches have been proposed to deal with data misuse at-
tacks by malicious intermediaries. For instance, we often
use timestamps and sequence numbers to provide resilience
to message delay and replay attacks. To counter the substi-
tution attack (See Section 2.2 for the deﬁnition of the sub-
stitution attack), a process can tag each piece of data with a
speciﬁcation on how it is to be used, before having it signed
by the attestation service. Now even if the malicious inter-
mediary can cheat and substitute the input, the process can
easily detect it by examining the speciﬁcation.
In conclusion, we examined the desired properties we
would ultimately like to achieve out of attestation. We ar-
gue that if we were able to build a perfect attestation ser-
vice with the desired properties, we would be able to deal
with malicious processes in a distributed system by reduc-
ing Byzantine faults to fail-stop failures. On the other hand,
as with all ﬁne-grained attestation, it is up to the protocol
semantics to rule out intermediary attacks.
3 BIND Overview
In this section, we give a design overview of BIND. We
begin by deﬁning what it means for a process and data to
be genuine under the conceptual model deﬁned in the pre-
vious section. Then we describe the techniques BIND uses
to ensure process and data integrity. We also explain the
interface BIND exposes to the programmer, and state the
properties BIND guarantees.
3.1 Process and Data Integrity
Deﬁning Process and Data Integrity Under the concep-
tual model proposed in Section 2, we deﬁne the notion of
integrity for process and data. Since BIND does not address
malicious intermediary attacks, we are not considering such
attacks in the following deﬁnition.
The integrity of a process is a relatively simple notion.
Since a process is essentially a piece of code, the integrity
of a process is deﬁned by the genuineness of the code.
Integrity of data (or that the data is genuine) can be in-
ductively deﬁned as:
1. Either the data is primitive and is genuine;
2. Or the data is derived by running a genuine process
over genuine data inputs.
Ensuring the Integrity of Primitive Data In practice,
the meaning of primitive data integrity is application spe-
ciﬁc. Therefore, BIND cannot enforce primitive data in-
tegrity by itself.
Instead we need a mechanism external
to BIND to ensure primitive data integrity. Potential tech-
niques include:
Semantic Check: We can embed logic in the process itself
to perform semantic checks on primitive data, e.g., a dis-
tributed scientiﬁc computing application checks whether an
input matrix is well-formed.
Certiﬁcates: We may have a central trusted authority to sign
certiﬁcates for primitive data, e.g., in a secure version of
Domain Name Service (DNS), hostname to IP address map-
pings are secured through digital signatures from a trusted
DNS authority.
Trusted Path: For user input data, we may use trusted path
mechanisms to ensure that the data came from an authenti-
cated user.
Ensuring the Integrity of Process and Derived Data
BIND offers a mechanism to ensure the integrity of pro-
cess and derived data. BIND produces an authenticator for
every piece of data a process generates. The authenticator
states the fact that the data is generated by running a le-
gitimate process on genuine data inputs. We assume that
the authenticator is attached to the data throughout its life-
time, i.e., when data is sent over the network, or stored and
fetched from local untrusted storage, etc.
3.2 BIND Interface
We assume the process, i.e., the critical code, is stored
in contiguous memory regions. Figure 2 depicts the in-
terface BIND offers to the programmer. At the begin-
ning of the process is an ATTESTATION INIT call to initi-
ate an attestation phase. The parameters passed along with
ATTESTATION INIT include the memory addresses of the
process’s input data and the size of the process code. On
receiving the ATTESTATION INIT request, BIND ﬁrst veri-
ﬁes the authenticator on the input data. If there are multiple
instances of input data, BIND veriﬁes each one of them.
BIND then hashes the process code along with the input
data addresses. To make sure that what is hashed is what
is executed, BIND sets up an isolated environment for the
process to execute. If the above steps are successful, BIND
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
4
1.
2.
interface ATTESTATION INIT
in input data memory addresses,
in size of process code,
out success indicator;
interface ATTESTATION COMPLETE
in output data memory addresses,
out authenticator.
Figure 2. Interface of the attestation service
to the process
yields control to the process with a success indicator, and
from the this point on until an ATTESTATION COMPLETE
command is issued, the process is ensured to execute in
a protected environment safe from tampering. At the end
of the process is an ATTESTATION COMPLETE command
with output data addresses as parameters. In response to
the ATTESTATION COMPLETE command, BIND computes
an authentication tag over both the output data and a hash of
the process code. This authentication tag binds the output
data with the code that has generated it. Then BIND undoes
the protections it has set up for the process and returns the
authenticator to the process.
3.3 BIND Properties
We now discuss the salient ideas underlying BIND:
Fine-grained Attestation When designing a distributed
protocol, we are often concerned about the trustworthiness
of a remote participant. In particular, we care about the pro-
cess, the critical piece of code that performs transformations
over protocol data.
As Figure 2 shows, BIND allows a programmer to
identify the process and annotate the beginning and end
of the process with an ATTESTATION INIT and ATTESTA-
TION COMPLETE call. In this way, every time the process
executes, BIND will be invoked to attest to its integrity.
Through this attestation annotation mechanism, BIND of-
fers ﬁne-grained attestation by attesting only to the process
but not any uncritical code. This simpliﬁes hash veriﬁca-
tion.
by a genuine process. Therefore, in a distributed system, the
integrity of processes and that of data are inseparable from
each other, and it means little to speak of either alone.
BIND embeds the integrity proof of a process in the
integrity proof of the data it has generated. This binding
also arises from our endeavor to narrow the time-of-use and
time-of-attestation discrepancy which current code attesta-
tion technology has not resolved. We seek to prove what
process code has been run to generate a piece of data, in-
stead of what the process code is at an arbitrary point of
time throughout the life span of the system.
BIND hashes the process code immediately before it is
going to be executed. Then it sets up protection mecha-
nisms so that the process will be executed in a sandbox safe
from tampering. After the process has completed execution,
BIND signs the hash of the code along with the output data
the process has produced. In this way, BIND proves what
code has been executed to generate the data.
Transitive Integrity Veriﬁcation The inductive deﬁni-
tion of data integrity naturally reﬂects the existence of a
chain-of-trust. To ensure the integrity of some derived data,
we need to ensure the integrity of its generating process as
well as the integrity of the input data to the process; and
to ensure the integrity of the input data, it is necessary to
ensure the integrity of the previous hop process (i.e., the
process that generated the input data), as well as the input
to the previous hop process, etc.
BIND achieves transitive integrity veriﬁcation with O(1)
overhead. A BIND authenticator not only vouches for the
most recent process that has operated on the data, but the
entire chain of prior processes as well. To achieve this,
BIND always veriﬁes the authenticator on the input data
when attesting to the process and its output data. A simi-
lar inductive construction is used by Arbaugh et al. [8, 9]
to achieve a secure bootstrap mechanism. While they ver-
ify the integrity of the next layer software before loading it,
BIND veriﬁes the integrity of previous hop process/data be-
fore using it; and we assume an external mechanism exists
to verify primitive data integrity too.
Efﬁcient BIND utilizes TPM’s hardware-based cryptog-
raphy engine to enable fast cryptography computations
needed for attestation. Meanwhile, because BIND supports
transitive integrity veriﬁcation, it is efﬁcient to verify the in-
tegrity of a piece of data, even when the data has traversed
multiple processes.
Binding Process and Data Integrity From the deﬁnition
of data integrity, it is evident that the integrity of derived
data builds on the integrity of its generating process, since a
corrupted process may have performed arbitrary operations
on the data it produces. On the other hand, it is not mean-
ingful to speak of the integrity of a process unless we actu-
ally use the process. A process contributes to the system by
operating on input data and thus generating new data. Ul-
timately, our concern over the integrity of a process stems
from the concern whether a piece of data has been generated
Discussion BIND does not deal with software vulnerabil-
ities in the attested code itself. To exploit a software vulner-
ability in the process code, a malicious attacker can supply
the process with malicious input data, so that the process
may be compromised during its own execution. At ﬁrst, it
may seem that if we hash the process both before and after
its execution, we can eliminate attacks that exploit bugs in-
side the process. In fact, this does not provide a fundamen-
tal solution to the problem, for a sophisticated attacker can
escape detection by restoring the correct code right before
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
5
reaching ATTESTATION COMPLETE. Though BIND fails to
detect a software vulnerability inside the process, the adver-
sary has a restricted attack interface. First, since the process
code is small in size, it is easier to manage and verify; hence
it arguably has few vulnerabilities. It may even be possible
to perform security evaluation on such a small piece of code
to prove that it is free of vulnerabilities. Moreover, to ex-
ploit a vulnerability in the process code, the attacker has to
feed it with carefully-constructed malicious inputs. How-
ever, BIND veriﬁes the integrity of any derived data input
to a process, which drastically reduces the vulnerability sur-
face.
The microprocessor and TCG technology we use for
BIND offers a hybrid hardware and software solution to-
ward overcoming software-based attacks. BIND runs in the
core privilege ring of a modern TCG-aware processor. An
adversary may attempt to break BIND through exploiting a
vulnerability in the BIND code. However, such an attacker
has a restricted attack interface. First, BIND relies heavily
on protection mechanisms provided by the hardware micro-
architecture. Second, the BIND code is small in size and
complexity such that a security evaluation may be possible
to prove that it is free of bugs. Third, BIND offers a minimal
interface to the operating system and applications.
Denial-of-Service (DoS) attackers may be able to com-
promise the availability of BIND by repeatedly sending at-
testation requests to BIND. However, such DoS attacks can
only hurt the adversary, for unless BIND is available, data
produced by that host will not be accepted by legitimate
processes in the system. The compromised host not only
fails to participate in the system, but also is going to be de-
tected. Therefore we do not consider DoS attacks in the
design of BIND.
4 Detailed Design of BIND
This section explores how to instantiate the trusted en-
tity and the attestation service. First we discuss the various
implications of placing trust on different software/hardware
components; next we present a design based on state-of-the-
art processor isolation technology with TCG/TPM support.
4.1 Trust Assumptions
Placement of Trust and Implications We consider how
to instantiate a trusted entity on a host. Our options in-
clude: trusting the operating system, trusting the hardware,
or trusting the Secure Kernel (SK). This section discusses
the security implications of each solution.
Operating System: One option is to integrate the attestation
service into the operating system or run it as an application.
Here we must assume that we trust the protection and fault
isolation mechanisms offered by the OS. This is a relatively
weak security practice, since numerous kernel vulnerabili-
ties exist, and once an attacker has successfully exploited
a buffer overﬂow [13] or a format string [4] vulnerability,
it can inject arbitrary code to be run at the kernel privi-
lege level. Even though researchers have developed sophis-
ticated software veriﬁcation techniques, e.g., static analy-
sis [15], to detect software vulnerabilities, these techniques
are not perfect and may miss unknown vulnerabilities.
Hardware: Since our goal is to overcome software-based
attacks, we would like to push the trust onto hardware. The
general belief is that compromising hardware is much more
difﬁcult than compromising software for the following rea-
sons. First, subverting a piece of hardware usually requires
physical vicinity to the targeted hardware; second, tamper
resistant hardware technology continues to mature. The
drawbacks of using trusted hardware include its relatively
high cost for design, manufacture, and deployment, and in-
ﬂexibility when it comes to customization or upgrading.
Secure Kernel: The Secure Kernel (SK) is a new mode on
modern processors such as AMD’s Secure Execution Mode
(SEM) [5]. In Section 6, we provide more information on
SEM-like technology. The SK can be viewed as a middle
ground between pure software and pure hardware solutions.
First the SK is by nature a piece of software code, and suf-
fers the same software vulnerability problem as the OS ker-
nel. Yet, since the SK is usually a compact piece of code,
and offers a minimal interface to the OS, it is far more man-
ageable than the OS kernel, and it may even be practical
to run software veriﬁcation on the SK code. One of the
greatest challenges of software veriﬁcation is complexity.
With a small piece of code such as the SK, it may be pos-
sible to enumerate all possible states and verify their cor-
rectness. The SK runs at the core of the privilege rings. It
can utilize several new hardware protection features to pro-
tect itself and other sensitive system resources, including
memory, IO, DMA and system registers. SEM also pro-
vides a secure kernel intercept mechanism to serve as the
single interface between the OS and SK. With the reasons
stated above, it is reasonable to assume the security of the
SK code, and that it remains intact and trustworthy through-
out its lifetime. In Section 6, we also review other micro-
processor technologies that can be used in place of SEM.
BIND Trust Assumptions
In designing BIND, we as-
sume that every participating platform is equipped with a
TPM chip and a modern secure processor similar to AMD’s
SEM chip. Trust thus builds on the TPM as well as the
Secure Kernel. In Section 4.1, we discuss the security im-
plications of trusting the SK. Meanwhile, since the TPM
is by nature a passive chip in the TCG context, the SK
serves to bridge the gap between the TPM and the untrusted
OS/application code.
We rely on secure boot and load-time attestation [36] to
establish trust on the integrity of the SK.3 One responsibil-
ity of secure boot is to set up appropriate hardware protec-
tion mechanisms on the processor. Here we need to enforce
write protection on the SK memory space, so that it cannot
be altered by OS/application code nor through DMA; we