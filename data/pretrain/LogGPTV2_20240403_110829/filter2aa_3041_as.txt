在代码清单 5-67 的第 15 行，代码试图创建未公开的 alertCounter 类型的值。不过这段代码会
造成第 15 行展示的编译错误，这个编译错误表明第 15 行的代码无法引用 counters.alertCounter
这个未公开的标识符。这个标识符是未定义的。 
由于 counters 包里的 alertCounter 类型是使用小写字母声明的，所以这个标识符是未
公开的，无法被 listing64.go 的代码访问。如果我们把这个类型改为用大写字母开头，那么就不
会产生编译器错误。让我们看一下新的示例程序，如代码清单 5-68 所示，这个程序在 counters
包里实现了工厂函数。 
代码清单 5-68 listing68/ 
counters/counters.go 
----------------------------------------------------------------------- 
01 // counters 包提供告警计数器的功能 
02 package counters 
03 
04 // alertCounter 是一个未公开的类型 
05 // 这个类型用于保存告警计数 
06 type alertCounter int 
07 
08 // New 创建并返回一个未公开的 
09 // alertCounter 类型的值 
10 func New(value int) alertCounter { 
11 
  return alertCounter(value) 
12 } 
listing68.go 
----------------------------------------------------------------------- 
01 // 这个示例程序展示如何访问另一个包的未公开的 
02 // 标识符的值 
03 package main 
04 
05 import ( 
06 
 "fmt" 
07 
08 
 "github.com/goinaction/code/chapter5/listing68/counters" 
09 ) 
10 
11 // main 是应用程序的入口 
12 func main() { 
13 
 // 使用 counters 包公开的 New 函数来创建 
14 
 // 一个未公开的类型的变量 
15 
 counter := counters.New(10) 
16 
17 
 fmt.Printf("Counter: %d\n", counter) 
18 } 
这个例子已经修改为使用工厂函数来创建一个未公开的 alertCounter 类型的值。让我们
先看一下 counters 包的代码，如代码清单 5-69 所示。
代码清单 5-69 counters/counters.go
01 // counters 包提供告警计数器的功能 
02 package counters 
03 
04 // alertCounter 是一个未公开的类型 
05 // 这个类型用于保存告警计数 
06 type alertCounter int 
07 
08 // New 创建并返回一个未公开的 
09 // alertCounter 类型的值 
10 func New(value int) alertCounter { 
11 
 return alertCounter(value) 
12 } 
代码清单 5-69 展示了我们对 counters 包的改动。alertCounter 类型依旧是未公开的，
不过现在在第 10 行增加了一个名为 New 的新函数。将工厂函数命名为 New 是 Go 语言的一个习
惯。这个 New 函数做了些有意思的事情：它创建了一个未公开的类型的值，并将这个值返回给
调用者。让我们看一下 listing68.go 的 main 函数，如代码清单 5-70 所示。
代码清单 5-70 listing68.go 
11 // main 是应用程序的入口 
12 func main() { 
13 
 // 使用 counters 包公开的 New 函数来创建 
14 
 // 一个未公开的类型的变量 
15 
 counter := counters.New(10) 
16 
17 
 fmt.Printf("Counter: %d\n", counter) 
18 } 
在代码清单 5-70 的第 15 行，可以看到对 counters 包里 New 函数的调用。这个 New 函数
返回的值被赋给一个名为 counter 的变量。这个程序可以编译并且运行，但为什么呢？New 函
数返回的是一个未公开的 alertCounter 类型的值，而 main 函数能够接受这个值并创建一个
未公开的类型的变量。 
要让这个行为可行，需要两个理由。第一，公开或者未公开的标识符，不是一个值。第二，
短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量。永远不能显式创
建一个未公开的类型的变量，不过短变量声明操作符可以这么做。 
让我们看一个新例子，这个例子展示了这些可见的规则是如何影响到结构里的字段，如代码
清单 5-71 所示。 
代码清单 5-71 listing71/ 
entities/entities.go 
----------------------------------------------------------------------- 
01 // entities 包包含系统中 
02 // 与人有关的类型 
03 package entities 
04 
05 // User 在程序里定义一个用户类型 
06 type User struct { 
07 
 Name  string 
08 
 email string 
09 } 
listing71.go 
----------------------------------------------------------------------- 
01 // 这个示例程序展示公开的结构类型中未公开的字段 
02 // 无法直接访问 
03 package main 
04 
05 import ( 
06 
 "fmt" 
07 
08 
 "github.com/goinaction/code/chapter5/listing71/entities" 
09 ) 
10 
11 // main 是应用程序的入口 
12 func main() { 
13 
 // 创建 entities 包中的 User 类型的值 
14 
 u := entities.User{ 
15 
 Name:  "Bill", 
16 
 email: "PI:EMAIL", 
17 
 } 
18 
19 
 // ./example69.go:16: 结构字面量中结构 entities.User 
20 
 //                    的字段’email’未知 
21 
22 
 fmt.Printf("User: %v\n", u) 
23 } 
代码清单 5-71 中的代码有一些微妙的变化。现在我们有一个名为 entities 的包，声明了
名为 User 的结构类型，如代码清单 5-72 所示。
代码清单 5-72 entities/entities.go
01 // entities 包包含系统中 
02 // 与人有关的类型 
03 package entities 
04 
05 // User 在程序里定义一个用户类型 
06 type User struct { 
07 
 Name  string 
08 
 email string 
09 } 
代码清单 5-72 的第 06 行中的 User 类型被声明为公开的类型。User 类型里声明了两个字段，
一个名为 Name 的公开的字段，一个名为 email 的未公开的字段。让我们看一下 listing71.go 的
代码，如代码清单 5-73 所示。 
代码清单 5-73 listing71.go 
01 // 这个示例程序展示公开的结构类型中未公开的字段 
02 // 无法直接访问 
03 package main 
04 
05 import ( 
06 
 "fmt" 
07 
08 
 "github.com/goinaction/code/chapter5/listing71/entities" 
09 ) 
10 
11 // main 是程序的入口 
12 func main() { 
13 
 // 创建 entities 包中的 User 类型的值 
14 
 u := entities.User{ 
15 
 Name:  "Bill", 
16 
 email: "PI:EMAIL", 
17 
 } 
18 
19 
 // ./example69.go:16: 结构字面量中结构 entities.User 
20 
 //                    的字段'email'未知 
21 
22 
 fmt.Printf("User: %v\n", u) 
23 } 
代码清单 5-73 的第 08 行导入了 entities 包。在第 14 行声明了 entities 包中的公开的
类型 User 的名为 u 的变量，并对该字段做了初始化。不过这里有一个问题。第 16 行的代码试
图初始化未公开的字段 email，所以编译器抱怨这是个未知的字段。因为 email 这个标识符未
公开，所以它不能在 entities 包外被访问。
让我们看最后一个例子，这个例子展示了公开和未公开的内嵌类型是如何工作的，如代码清
单 5-74 所示。 
代码清单 5-74 listing74/ 
entities/entities.go 
----------------------------------------------------------------------- 
01 // entities 包包含系统中 
02 // 与人有关的类型 
03 package entities 
04 
05 // user 在程序里定义一个用户类型 
06 type user struct { 
07 
 Name  string 
08 
 Email string 
09 } 
10 
11 // Admin 在程序里定义了管理员 
12 type Admin struct { 
13 
 user   // 嵌入的类型是未公开的 
14 
 Rights int 
15 } 
listing74.go 
----------------------------------------------------------------------- 
01 // 这个示例程序展示公开的结构类型中如何访问 
02 // 未公开的内嵌类型的例子 
03 package main 
04 
05 import ( 
06 
 "fmt" 
07 
08 
 "github.com/goinaction/code/chapter5/listing74/entities" 
09 ) 
10 
11 // main 是应用程序的入口 
12 func main() { 
13 
 // 创建 entities 包中的 Admin 类型的值 
14 
 a := entities.Admin{ 
15 
 Rights: 10, 
16 
 } 
17 
18 
 // 设置未公开的内部类型的 
19 
 // 公开字段的值 
20 
 a.Name = "Bill" 
21 
 a.Email = "PI:EMAIL" 
22 
23 
 fmt.Printf("User: %v\n", a) 
24 } 
现在，在代码清单 5-74 里，entities 包包含两个结构类型，如代码清单 5-75 所示。
代码清单 5-75 entities/entities.go
01 // entities 包包含系统中 
02 // 与人有关的类型 
03 package entities 
04 
05 // user 在程序里定义一个用户类型 
06 type user struct { 
07 
 Name  string 
08 
 Email string 
09 } 
10 
11 // Admin 在程序里定义了管理员 
12 type Admin struct { 
13 
 user   // 嵌入的类型未公开 
14 
 Rights int 
15 } 
在代码清单 5-75 的第 06 行，声明了一个未公开的结构类型 user。这个类型包括两个公开
的字段 Name 和 Email。在第 12 行，声明了一个公开的结构类型 Admin。Admin 有一个名为
Rights 的公开的字段，而且嵌入一个未公开的 user 类型。让我们看一下 listing74.go 的 main
函数，如代码清单 5-76 所示。 
代码清单 5-76 listing74.go：第 11 到 24 行 
11 // main 是应用程序的入口 
12 func main() { 