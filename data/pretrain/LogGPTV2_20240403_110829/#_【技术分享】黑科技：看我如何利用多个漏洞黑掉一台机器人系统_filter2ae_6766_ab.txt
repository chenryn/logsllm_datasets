步骤3.修改security.conf文件，该文件将覆盖所有的通用安全限制，接头限制，边界和安全I/O值限制；
步骤4.强制绕过计算校验和值，并上传新文件。我们需要伪造这个校验和值，因为通常集成商很可能在硬件上写入当前的校验和值；
步骤5.重新启动机器人，以便更新安全配置；
步骤6.通过利用UR控制服务上的认证问题，以任意危险的方式操作机器人。
通过逆向分析ursys-CB3.1-3.3.4-310.img这个系统镜像，我知道了机器人的入口点以及允许网络上的其他机器与操作系统进行交互的服务程序。对于此演示，我使用供应商提供的URSim模拟器，该模拟器包含了机器人镜像中大部分核心的二进制文件。尽管这个示例使用模拟器可以更为清楚展示攻击效果，但我还是修改了这个二进制文件，修改后的文件部分代码可以在Linux机器上正常运行。URControl这个二进制文件中导出了很多不同的网络服务，这些网络服务的私有协议在实现上都没有使用强大的认证机制。例如，网络上的任何用户都可以向其中一个服务发出命令，并获取正在运行的进程的远程操作系统的版本（步骤1）：
现在我已经验证了远程目标运行着一个易受攻击的系统ursys-CB3.1-3.3.4-310（UR3，UR5或UR10），下一步我准备利用网络服务漏洞来破坏这个机器人系统（步骤2）。由于UR Modbus
TCP服务（端口502）不支持对命令源的认证机制，因此，网络攻击者可能会在控制的过程中破坏机器人系统。与机器人IP连接的攻击者可以发出Modbus读/写请求，并部分更改机器人的状态或向操作人员发送请求，以更改控制链接的状态。发送Modbus写请求并不能改变机器人的任何安全设置，然而，我们在在UR
Modbus TCP接收器（URControl内核的一个二进制文件）中发现了一个基于堆栈的缓冲区溢出。
UR Modbus
TCP服务程序的recv函数存在堆栈缓冲区溢出漏洞，攻击者通过该函数可以向程序的缓冲区写入超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其他的指令，以达到攻击的目的，这是一个很常见的堆栈缓冲区漏洞。
在进行漏洞利用之前，我们先来看一下漏洞利用的将要面临的阻碍。机器人的Linux内核被设置为堆栈随机化（randomize_va_space = 1 =>
ASLR），VDSO（virtual dynamic shared object page）和内存区域共享。此外，由于内核中的"No eXecute"
(NX) 被置位，因此该内核文件是不可写以及不可执行的。
当对目标缓冲区进行溢出操作时，我们也需要要对指向函数参数的指针执行溢出操作。在函数返回之前，这些参数在其他函数调用中被使用，所以我们必须要为这些函数调用提供有效的实参。否则，我们永远不能找到函数的返回点以及控制函数的执行流程。
如上图所示，edx +
0x2c内存地址中的值作为一个参数传递给了0x82e0c90函数，另一个就是EBX寄存器（从我们以前的EDX控制指针计算出来）也需要指向一个与文件描述符相关的结构体变量。
在实现上，需要选择符合上述两个要求的静态地址，我使用以下静态区域，因为ASLR技术会使内存中其他地址都可能发生变化。
我写了一些脚本用来找到一个合适的内存地址，通过这些脚本我发现0x83aa1fc这个地址是完美的，因为它适合这两个条件：
**0x83aa1fc + 0x2c指向有效内存 – > 0x831c00a（“INT32”）**
**0x83aa1fc + 0x1014包含0（所有这个区域几乎都为零）**
现在我已经找到满足上述两个条件的解决方法，可以继续执行代码直到函数返回，并且通过溢出堆栈上保存的寄存器，我能够得到EIP的控制权：
现在，我控制了大部分的寄存器，所以我需要将我的shellcode放到机器内存中的某个地方，并将函数的执行流重定向到shellcode那里。为此，我在实现上使用了面向返回的编程（ROP），遇到的难题是需要合适的EXP代码来执行漏洞利用。自动ROP链工具不能很好地满足我的需求，所以我决定自己手动进行此操作。
现在，我最终目的是希望在目标系统中执行一个反弹shell以连接到我的攻击机器上。在Linux系统中构建基于远程ROP漏洞利用的一个关键点是系统调用，在这些可靠的系统调用函数中，我可以使用诸如write或dup2之类的系统函数去重用已经创建的套接字来反弹一个shell。
在这个二进制文件中，我只找到一个int
0x80指令，该指令用于在支持x86指令集的Linux系统中调用系统调用。使用该指令我只能执行一个系统调用：我将使用execve系统调用来执行一个程序。int
0x80指令需要使用设置在一个寄存器中的一个系统调用号（EAX，在本例中为0xb），然后设置一个指向特殊结构的寄存器（EBX）。这个结构包含一个指针数组，每个指针指向要执行的命令的参数。
想要触发这个漏洞，就不能在请求缓冲区上使用空字节（0x00）。这是碰到的另一个难题，因为我们需要发送命令和参数，并创建一个以空字节结尾的指针数组。为了克服这个难题，在请求中我先发送一个占位符（像0xFF这样的字节块），之后利用ROP在运行时将占位符0xFF替换成0x00。
伪代码中如下图所示（通过TCP链接来反弹一个Shell）：
由于所有的受控数据都位于堆栈中，所以首先我将尝试将堆栈指针（ESP）与我的最大控制区段（STAGE
1）对齐。我将最大的受控部分分为两个阶段，因为它们都可能包含许多ROP代码。
正如前面所叙述的那样，此时我控制了EBX和EIP这两个寄存器。接下来，我必须将ESP与任何控制的区段对齐，以便我可以开始执行ROP代码。
以下代码片段（ROP1 0x8220efa）用于调整ESP：
这样ESP = ESP + EBX – 1，上面的代码将ESP与我的STAGE 1部分的代码对齐。
EBX应该将ESP减少0x137字节，所以我使用数字0xfffffec9（4294966985），因为当把该数字添加到ESP时，我们就能够得到所需的值。
当代码的retn指令执行时，STAGE 1的ROP代码将会开始执行。漏洞利用的第1阶段将执行以下操作：
1\. 将结构体变量的末尾字节置0。这样处理器就会知道EXECVE参数只是这三个指针。
2\. 在我们的结构体参数中保存指向我们第一个命令的指针。
3\. 跳到STAGE 2，因为这里没有太多的空间。
漏洞利用的第2阶段将执行以下操作：
1\. 将cmd []数组中的每个参数末尾的 xff xff xff xff删除。
2\. 在我们的结构体参数中保存一个指向cmd []数组中第二和第三个参数的指针。
3\. 为EXECVE准备寄存器。如前所述，我们需要
    EBX = * ARGS []
    EDX = 0
    EAX = 0XB
4.调用int 0x80代码并执行反弹shell。
一旦TCP反弹shell的有效载荷被执行，机器人系统便会发送一个请求用来和我的攻击电脑建立链接。现在我可以执行命令，并可以使用sudo在机器人控制器中以root身份执行命令。
安全设置保存在security.conf文件中（步骤3），Universal
机器人在系统中实现了CRC（STM-32）算法，使用此算法为二进制文件提供完整性校验，并将计算的校验值保存在磁盘上。但是该算法不会为安全配置提供任何真正的完整性校验，因为对新配置计算产生的新校验值，可能会与文件系统上的某个特殊文件的校验值产生冲突。我逆向分析了对每个安全配置进行计算的算法，并用代码实现了该算法。在视频演示中，尽管伪造一个新的CRC校验值可能会使攻击变得更容易，但我并没有这样做，而是保持该CRC校验值不变（位于屏幕的右上角）（步骤4）。
在修改机器人上的任何安全配置之前，我创建了一个进程，该进程会在25秒后自动启动一个机器人控制器的新实例，这将给我足够的时间来下载，修改和上传一个新的安全设置文件。以下命令创建了一个新的URControl进程。命令中我使用的是Python语言，因为它允许我在执行forking操作时关闭当前正在运行的所有进程文件描述符。因为我正在从反弹shell的对象中执行fork操作，所以我需要创建一个不继承任何文件描述符的新进程，以便在父进程URControl被关闭时，从该进程fork的子进程也都会被关闭。
现在我有25秒下载当前文件，修改它，计算新的CRC，重新上传它，并关闭正在运行的URControl进程（它具有较旧的安全设置配置），我可以通过使用kill命令来关闭当前的URControl进程（步骤5）。
最后，我将此命令发送到URControl服务，以加载我们上传的新配置文件，同时我也关闭可能会出现在用户界面上的任何弹出窗口。
最后，攻击者可以简单地调用URControl服务中的movej函数，以自定义速度和加速度远程移动被攻击者控制的机器人（步骤6）。
**后记**
本文我向大家展示了先进的机器人系统中存在的安全漏洞以及被利用的整个过程，这些其实都是非常技术性的安全漏洞，如其中一个协议的缓冲区溢出漏洞，将整个机器人系统的安全性暴露给了远程的攻击者。
我们已经在一月份向供应商报告了漏洞的整个流程，但是该漏洞还没有被修补。