## Page 41
op->ob_item=（Pyobject*）ma1loc(nbytes）;
PyListobjeet*op.=new FyList_Type();
等效于：
p
[PyList_New() in listobject.c]
(PyStringobject*)malloe(sizeof(PyStringobject)+size);
PyStringobject* op
[PyString_FromString() in atringobject.c]
在本书中，我使用了大量的图片，一图胜千言。在这些图片中，大量使用的构图元素
=PyObject_Co_New(PyListobject,&PyLiat_Type)
在图0-13中，深色的方块就是指针所指向的内存块。
离指针最近的向右或向下的那块内存，图0-13中给出了一个例子：
指向的是两块内存中的哪块内存就存在着模糊。在本书中，指针指向的内存块都是距
的边界，而不是内存块本身。由于边界本身就应该是两块内存的交界，所以这个箭头
是，基于C中的指针是指向某一内存的起始地址，所以在图中，箭头指向的是内存块
情况下箭头并不表示指针，这个通过上下文的信息可以判断出来：另一点需要注意的
就是箭头。在大多数情况下，箭头是用来表示C中的指针这个概念的，但是也有某些
作符视之。下面是儿个例子：
的，都以C++中的new操作符视之；凡是以Mal1oc结尾的，都以C中的mal1oc操
PyMem MALLOC，Pyobject_MALLOc等API。只要坚持一个原则，即凡是以New结尾
接口。通常Python
图0-13指针图示
Python源码剖析
0.7
深度探索动态语言核心技术
一些注意事项
11
---
## Page 43
Python内建对象
第1部分
---
## Page 44
成载内no
---
## Page 45
有关系，先放下，只要有一个直观的感觉就可以了，这并不妨碍你阅读接下来的内容。
不肤浅，有的地方甚至会相当深入。因此，在本章的阅读中，如果有什么疑难的地方，没
的作用及它与实例对象的关系。总之，本章对Pyhon对象体系的介绍力求简洁，但是并
内部是如何表示的，更确切地说，因为Pyhon是由C实现的，所以我们首先要弄清楚的
个体系阐释清楚，这只能说明我是个疯子。在本章中，我们的重点将放在了解对象在Pyhon
们称之为“类型系统”或“对象体系”的东西。
中不光有着这些千差万别的对象，这些对象之间还存在着各种复杂的关系，从而构成了我
基于这些类型对象，同样可以进行“实例化”的操作，创建的对象称为“实例对象”Pyton
概念在Python中的体现。
string对象、dict对象。类似的，这些实例对象可以视为面向对象理论中“对象”这个
这些内建类型对象通过“实例化”，可以创建内建类型对象的实例对象，比如int对象、
类型等，这些我们称之为内建类型对象。这些类型对象实现了面向对象中“类”的概念；
头六臂，还是烈焰红唇。
一个问题就是：对象，这个神奇的东西，在C的层面，究竞长得是个什么模样，究竟是三
两个概念在Pyhon中都是通过Pyhon内的对象来实现的。
一个对象，字符串类型也是一个对象。换句话说，面向对象理论中的“类”和“对象”这
是一个对象，一个字符串也是一个对象。更为奇妙的是，类型也是一种对象，整数类型是
Pyhon中的对象体系是一个庞大而复杂的体系，如果说在本书的第一章我就试图将这
同时，Python还允许程序员通过elassA（object）这样的表达式自已定义类型对象。
除此之外，我们还将了解到类型对象在C的层面是如何实现的，并初步认识类型对象
在Python中，已经预先定义了一些类型对象，比如int类型、string类型、dict
对象是Pyhon中最核心的一个概念，在Python的世界中，一切都是对象，一个整数
Python源码剖析
Python对象初探
深度探索动态语言核心技术
第
CHAPTER
---
## Page 46
Python源码剖析
16
1.1
得到更新，光是想一想，就知道这样的工作是多么的繁琐。
属于B的数据。只要将A移动到内存中的其他位置，那么所有指向A的指针就必须立即
大了，这意味着必须将A整个移动到内存中的其他位置，否则A增大的部分将覆盖原本
的情形。在内存中有对象A，并且其后紧跟着对象B。如果运行期某个时刻，A的大小增
对象的工作变得非常的简单。一旦允许对象的大小可在运行期改变，我们就可以考虑如下
的指针。为什么要设定这样一条特殊的规则呢，因为遵循这样的规则可以使通过指针维护
那些需要容纳可变长度数据的对象只能在对象内维护一个指向一块可变大小的内存区域
所有的内建的类型对象（如整数类型对象，字符串类型对象）都是被静态初始化的。
不能被静态初始化的，并且也不能在栈空间上生存。唯一的例外就是类型对象，Pyhon中
操作的一系列代码。
就是一个对象。在这片内存中，存储着一系列的数据以及可以对这些数据进行修改或读取
的，这都不重要，重要的是这片内存在更高的层次上可以作为一个整体来考虑，这个整体
中，一个对象实际上就是一片被分配的内存空间，这些内存可能是连续的，也可能是离散
的一切都是字节。通常的说法是，对象是数据以及基于这些数据的操作的集合。在计算机
抽象的概念。它并不能理解这是一个整数，那是一个字符串，对于计算机来说，它所知道
言，那么在Pyhon中，它的对象机制是如何实现的呢？
一次的升级，但是其实现语言一直都是ANSIC。我们知道，C并不是一个面向对象的语
Python内的对象
们才有足够的能力将这个体系看个明白。
Pyhon对象体系的详细剖析，会在第2部分的最后一章中介绍到。只有到了那个时候，我
在Python中，一个对象一旦被创建，它在内存中的大小就是不变的了。这就意味着
在Pyton中，对象就是为C中的结构体在堆上申请的一块内存，
对于人的思维来说，对象是一个比较形象的概念，而对于计算机来说，对象却是一个
第1章Python对象初探
从1989年Guido在圣诞节揭开Python的大幕开始，一直到现在，Python经历了一次
本章的目的是为能够顺利而快速地进入对内建对象的剖析打下必要的基础，至于对
一深度探索动态语言核心技术
一般来说，对象是
---
## Page 47
1.1.1
象，它是用来指定一个对象类型的类型对象。这个类型对象我们将在后边详细地分析。现
那么这个结构体是一个什么东西呢？实际上这个结构体对应着Pyton内部的一种特殊对
该对象时，A的引用计数应该增加：而当这个pyobject*被删除时，A的引用计数应该减
现了基于引用计数的垃圾收集机制。对于某一个对象A，当有一个新的Pyobject*引1用
REFs的。所以在实际发布的Python中，Pyobject的定义非常简单：
都隐藏在Pyobject_HEAD这个宏中。
少
[object.h]
容在Pyobjeot中定义，Pyobject是整个Python对象机制的核心。
typedef
/*Pyobject_HEAD defines the initial segment of every Pyobject.*
#endlE
#else
[obfect.h]
[object.h]
Pyobject;
ifdef
Pyobject;
当A的引用计数减少到0时，A就可以从堆上被删除，以释放出内存供别的对象使用。
对象机制的基石
在ob_refcnt之外，我们注意到ob_type是一个指向_typeobject结构体的指针，
在pyobject的定义中，整型变量ob_retent与Python的内存管理机制有关，它实
#define_PyObject_ExTRA_INIT
这个结构体是Python对象机制的核心基石，从代码中可以看到，Python对象的秘密
在Python中，所有的东西都是对象，而所有的对象都拥有一些相同的内容，这些内
structLtyoeobieet*obtype;
#define
#define_Pyobject_ExTRA_INTT
Pyobdect
int
Py_TRACELREFS
struct
typeobject
Pyobject_HEAD_EXTRA
HEAD_EXTRA
_object
object
ob_next;
aar-qo
prey
-PyObject
101
Python源码剖析
1.1Python内的对象
一深度探索动态语言核心技术
二
---
## Page 48
Python源码剖析
1.1.2
18
Lypedef struat
#definePyobject_VAR_HEAD
此，Python在Pyobject对象之外，还有一个表示这类对象的结构体——PyVarobject：
个pyobject对象”。看上去这种“n个”似乎也是一类Python对象的共同特征，
PyVarobiect;
上不光是字符申对象，比如对应于C++中1ist或vector的列表对象，它也应该维护
样的概念，所以准确的说法是，字符串对象应该维护“n个char型变量”。这种对象实际
Pyobject之外，字符串对象应该维护“一个字符串”，但在C中，没有“一个字符串”
是Pyhon的设计师，考虑一下应该如何实现字符串对象。很显然，类似于ryIntobject，
[object.h]
保存在这个整形变量（ob_ival）中。但是很不幸，对于另一类对象，就没这么幸运了。如果你
已的特殊的信息。
对象、list 对象、dict对象、成千上万的其他对象，都在Pyobject之外保存了属于自
当然应该有一个值，这个“值”的信息就保存在ob_ival中。同样，Python中的字符串
Pyobject之外“其他的东西”究竟是些什么东西。
须拥有的一部分内容，以我们将在下一章剖析的整数对象为例子，你可以看到对象中除
种对象了，这可是大大的不妙。在pyObject中定义的内容仅仅是每一个Pyuon对象都必
西。没错，倘若所有的Python对象都只包含Pyobject，那Python中岂不是只有唯一的一
象除了必须有这个PyObject内容外，似乎还应该占有一些额外的内存，放置些其他的东
Python对象所占有的内存的最开始的字节中。这句话的另一个意思是，每一个Pyhon对
是类型信息。
在我们看到了，在Pyhon中，对象机制的核心其实非常简单，一个是引用计数，一个就
我们把整数对象这样不包含可变长度数据的对象称为“定长对象”，而字符串对象这
PyIntobjeet:
typedef struot
[intobject,h]
PyObject_VAR_HEAD
PyObfeet_HEAD
整数对象的特殊信息是一个C中的整形变量，无论这个整数对象的值有多大，都可以
定长对象和变长对象
Python的整数对象中，除了Pyobject，还有一个额外的1ong变量，我们说一个整数
第1章Python对象初探
在pyobject中定义了每一个Python对象都必须有的内容，这些内容将出现在每一
long ob_ival;
Pyobject_HEAb
一深度探索动态语言核心技术
在
---
## Page 49
1.2
内存空间的大小的信息到底在哪里呢？显然在Pyobject中没有这样的信息。其实，这样
要不同的空间，一个整数对象和一个字符串对象所需的空间肯定不同。那么，对象所需的
无疑问地，必须要知道申请多大的空间。显然，这不会是一个定值，因为不同的对象，需
当我们顺着时间轴追溯，就会发现一个问题。当在内存中分配空间，创建对象的时候，毫
存在某一个Pyhon对象时，该对象开始的儿个字节的含义一定会符合我们的预想。但是，
指针就可以引用任意的一个对象。而不论该对象实际是一个什么对象。
部。这就使得在Pyhon中，对对象的引用变得非常的统一，我们只需要用一个Pyobject*
意义和pyobject是一样的。换句话说，在Python内部，每一个对象都拥有相同的对象头
中有5个元素，那么ob_size的值就是5。
对于Python中最常用的1ist，它就是一个pyVarobject对象，如果某一时刻，这个list
纳了多少个元素。注意，ob_size指明的是所容纳元素的个数，而不是字节的数量。比如
的出现。变长对象通常都是容器，ob_size这个成员实际上就是指明了变长对象中一共容
和“Ruby”占用的内存大小就不同了。正是这种区别导致了PyVarObject对象中ob_size
的内存大小是一样的，而变长对象的不同对象占用的内存可能是不一样的。比如，整数对
一个扩展而己。因此，对于任何一个PyVarobject，其所占用的内存，开始部分的字节的
样包含可变长度数据的对象称为“变长对象”，它们的区别在于定长对象的不同对象占用
类型对象
在上面的描述中，我们看到了Python中所有对象共有信息的定义。所以，当内存中
从Pyobject_VAR_HEAD的定义可以看出，PyVarObject实际上只是对Pyobject的
ob_refent
图1-1显示了Python中不同对象与Pyobject、PyVarObject在内存布局上的关系：
obival
oh_type
int
图1-1不同Python对象与PyObject、PyVarObject的关系
obsize
obtype
obrefent
string
Python源码剖析
ob size
obtype
obrefent
list
其他信息
深度探索动态语言核心技术
1.2
类型对象
obtype
ob_refent
dict
19
---
## Page 50
Python源码剖析
1.2.1
20
的说法是不对的，这个信息虽然不显见于pyobject的定义中，但它恰恰是隐身于pyobject
本身也是C写成的，所以Python内部也大量使用了这些API。Python的CAPI分成两类，
PythonCAPI来创建，第二种是通过类型对象EyInt_Typea
才能从无到有地创建出一个整数对象呢？一般来说，Python会有两种方法。第一种是通过
分的阅读。
object做一个粗略的介绍，如果读者有不太明白的地方，可以跳过，这并不影响第1部
详细剖析构建在PyTypeObject之上的Python的类型和对象体系。这里仅仅是对pyType-
实现，而pyTypeObject也是一个非常复杂的话题，我们将在第2部分专门以一章的篇幅
一下类型对象_typeobject：
密切相关的，因此它一定会出现在与对象所对应的类型对象中。现在我们可以来详细考察
之中。
V
ypedef
[object.h]
Python对外提供了CAPI，让用户可以从C环境中与Python交互，实际上，因为Python
对象的创建
第1章Python对象初探
考虑一下这个问题，假如我们命令Pyton创建一个整数对象，Python内部究竟如何
类型名，tp_name，主要是Python内部以及调试的时候使用；
实际上，
创建该类型对象时分配内存空间大小的信息，即tp_basicsize和tp_itemsize;
在_typeobject的定义中包含了许多的信息，主要可以分为4类：
我们在下面将要描述的类型的类型信息。
与该类型对象相关联的操作信息（就是诸如tp_prirnt这样的许多的函数指针）;
printfunctp.printy
iashfunc
destructor
Methods to:impiement standard operations/
More:standard operations (here for binary compatibility)*/
struct
深度探索动态语言核心技术
，占用内存空间的大小是对象的一种元信息，这样的元信息是与对象所属类型
tp_hash;
VARHEAD
tp
typeobject
dealloc:
---
## Page 51
PyBaseObject_Type：图1-3显示了读者可能更熟悉的C++中的定义int这种类型（class）
这样的表达式时，就是通过PyInt_Type创建了一个整数对象。
类型A，如果要创建A的实例对象（前面我们已经提到，实例对象可以视为面向对象理论
FromLong（10），这样就创建了一个值为10的整数对象。
的方式，以及在Pyhon内部，这种继承的关系是如何实现的。
会通过A所对应的类型对象创建实例对象。图1-2给出了这样的一个例子：
中的“对象”概念），Python就不可能事先提供PyA_New这样的API。对于这种情况，Pyhon
比如对于整数对象，我们可以利用如下的API来创建，Pyobject*intob=PyInt
只能作用在某一种类型的对象上，对于每一种内建对象，Python都提供了这样的一组API。
象，我们可以采用如下的表达式：PyObject*intobj=PyObject_New（Pyobject）
object），API内部会有一整套机制确定最终调用的函数是哪一个。对于创建一个整数对