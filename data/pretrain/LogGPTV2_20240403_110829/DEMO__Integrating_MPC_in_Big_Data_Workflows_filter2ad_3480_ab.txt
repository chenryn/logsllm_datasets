ate representation (IR): a directed acyclic graph (DAG) of opera-
tors. From this IR, Musketeer generates code for multiple parallel
2The HHI is the sum of squared market shares.
Figure 1: Vehicle-for-hire market concentration workﬂow:
gray boxes are tables, rounded nodes are operators. The red,
shaded operations happen in MPC, and arrows crossing the
MPC boundary correspond to private inputs.
backend execution engines, and executes the workﬂow by ﬂexibly
choosing and combining them. To achieve the above beneﬁts for
computations involving secure MPC, we added prototype support
for MPC to Musketeer.
4.
IMPLEMENTATION
We have extended Musketeer with support for input columns to
be marked as private, and with a set of MPC operators in the IR.
With just these two extensions, Musketeer automatically generates
Python code for VIFF’s secret sharing-based MPC when given a
clique of MPC operators. In the generated code, private columns
are secret-shared between parties and computations on them use
MPC constructs. Further, we added initial code generation sup-
port for the VIFF MPC framework by integrating it as a Musketeer
backend. To ensure that secure computations run in MPC, we spec-
iﬁed inﬁnite costs for combining them with non-MPC operators and
for mapping them to non-MPC backends. We chose VIFF because
it is open-source and more general than other available frameworks:
it offers a choice between active and passive security as well as ad-
justable corruption thresholds. In the future, we plan to also include
recent and more efﬁcient MPC frameworks as backends. Our Mus-
keteer extensions are open-source, and available at:
https://github.com/hicsail/Musketeer.
5.
INITIAL RESULTS
We prototyped the market concentration use case discussed in
§2 using our implementation.
In our example, we compute the
Herﬁndahl-Hirschman Index (HHI) [5] over the market shares of
several vehicle-for-hire (VFH) companies. This computation, for
example, might allow a regulator to assess the long-term impact of
a changing market environment – such as the emergence of “ride-
sharing” services such as Uber and Lyft – on market concentration.
The workﬂow proceeds as shown in Figure 1: each company ﬁrst
computes its local aggregate fare revenue from private trip data us-
ing their big data analytics stack of choice. The per-company rev-
enues are then passed into the secure part of the workﬂow, which
sums them under MPC to determine the aggregate revenue, and
tripsSUMDIVIDEJOINSELECTtrip_fareshhimarket_sizerevenuemarket_sharesmarket_shares_sqSUMMULTIPLYSUMMPCprivate,per-companyanalytics jobsSetup
Insecure, trusted Hadoop
(8 nodes)
Musketeer with MPC
(5 parties, 1+1+1+1+4 nodes)
Secure MPC framework only
(VIFF only, 5 parties, 5 nodes)
Runtime
16 min 10 s (970s)
17 min 31 s (1,051s)
>2 hours (7,200s)
Table 1: End-to-end runtimes for the vehicle-for-hire market
HHI computation. Our MPC-extended Musketeer workﬂow
is almost as fast as an insecure analysis on a trusted Hadoop
cluster, and much faster than using an MPC framework only.
subsequently computes market shares by dividing each per-company
revenue by the total revenue. Finally, the secure MPC computes the
HHI by squaring the market shares and adding the results.
We use six years of public NYC taxi trips’ fare information [11]
as our input data, dividing the data across ﬁve imaginary taxi com-
panies (50%/20%/10%/10%/10%). Each company privately com-
putes the initial revenue on between 16 and 80 GB of trip data in
their own Hadoop cluster running on Amazon EC2. The results are
automatically passed into a shared VIFF cluster with three compute
parties, also running on EC2.
Table 1 shows our preliminary results. We compare (i) the run-
time of this workﬂow on a single Hadoop cluster operated by a
trusted third party (e.g., the regulating authority); (ii) the runtime
of the same workﬂow when implemented entirely in Python and
VIFF; and (iii) the end-to-end runtime for our integrated, mixed-
mode MPC Musketeer workﬂow. Having a trusted third party run
this computation is both impractical (must ship hundreds of GB of
data) and contentious (the VFH companies might not wish to dis-
close their per-trip fare information). However, the trusted third
party case is a useful performance baseline, since it constitutes the
fastest possible execution of this workﬂow (as using MPC can only
add overhead). As our results show, the integrated Musketeer work-
ﬂow only takes 8.3% longer than this baseline (1,051s vs. 970s),
since the data-intensive parts of the computation run in companies’
private Hadoop clusters and parallelize well. By contrast, had the
companies executed the entire computation in Python and VIFF, it
would not have ﬁnished after two hours, and required substantial
MPC expertise to implement.
6. DEMO
In our demo, we show a Musketeer-based implementation and
live execution of the market concentration use case described above.
First, we illustrate how an analyst or regulator speciﬁes the joint
computation in a SQL-like Musketeer front-end language. Sec-
ond, we visualize the decomposition into a Musketeer IR DAG,
highlighting the parties’ input ownership, the boundaries between
their local computations, and the joint MPC. Third, we show the
generated code executing on real Hadoop and VIFF clusters, and
reproduce our evaluation results from §5.
7. FUTURE DIRECTIONS
We are currently extending Musketeer to support other MPC
frameworks such as Sharemind [3]. Moreover, Musketeer’s sched-
uler can automatically choose which system is used to execute a
particular operator (e.g., based on a simple performance model).
We plan to exploit and extend this capacity in several ways to im-
prove the out-of-box performance of MPC.
Static analysis and optimization techniques can similarly be lever-
aged to help Musketeer pick the most performant MPC implemen-
tation for a given workﬂow, as in work on inferring and improv-
ing the performance of MPC protocols [6]. They might also help
Musketeer to select an appropriate partitioning, similar to strategies
used in work on MPC protocol selection [7].
We will also look at how end-users specify their security and
privacy requirements. In real-world scenarios, the authors of an an-
alytics algorithm may not know the privacy requirements of input
data contributors. Analysts might require a framework that sup-
ports policy-agnostic programming [14], in which security and pri-
vacy properties are abstracted away from the programmer and spec-
iﬁed independently. We are currently working on initial support for
this approach by extending Musketeer to automatically detect op-
erations for which data must cross trust domain boundaries, and
automatically using MPC for these operations.
Acknowledgements
Research supported by NSF awards #1414119 and #1430145.
8. REFERENCES
[1] VIFF, the Virtual Ideal Functionality Framework.
http://viff.dk/. Accessed 01/08/2016.
[2] E. A. Abbe, A. E. Khandani, and A. W. Lo.
Privacy-preserving methods for sharing ﬁnancial risk
exposures. American Economic Review, 102(3):65–70, May
2012.
[3] D. Bogdanov, S. Laur, and J. Willemson. Sharemind: A
Framework for Fast Privacy-Preserving Computations. In
ESORICS, volume 5283 of LNCS, pages 192–206. Springer,
2008.
[4] I. Gog, M. Schwarzkopf, N. Crooks, M. P. Grosvenor,
A. Clement, and S. Hand. Musketeer: all for one, one for all
in data processing systems. In EuroSys, Apr. 2015.
[5] A. O. Hirschman. The paternity of an index. The American
Economic Review, 54(5):761–762, 1964.
[6] F. Kerschbaum. Automatically optimizing secure
computation. In CCS, pages 703–714. ACM, 2011.
[7] F. Kerschbaum, T. Schneider, and A. Schröpfer. Automatic
protocol selection in secure two-party computations. In
ACNS, pages 566–584. 2014.
[8] E. Meijer, B. Beckman, and G. Bierman. LINQ: Reconciling
Object, Relations and XML in the .NET Framework. In
SIGMOD, pages 706–706, 2006.
[9] A. Narayan, A. Papadimitriou, and A. Haeberlen. Compute
globally, act locally: Protecting federated systems from
systemic threats. In HotDep, Oct. 2014.
[10] A. Rastogi, M. A. Hammer, and M. Hicks. Wysteria: A
programming language for generic, mixed-mode multiparty
computations. In IEEE S&P, pages 655–670, 2014.
[11] T. W. Schneider. NYC taxi trip data. https://github.
com/toddwschneider/nyc-taxi-data. Accessed
03/08/2016.
[12] A. Shamir. How to share a secret. Communications of the
ACM, 22(11):612–613, 1979.
[13] N. Volgushev, A. Lapets, and A. Bestavros. Programming
Support for an Integrated Multi-Party Computation and
MapReduce Infrastructure. In HotWeb, Nov. 2015.
[14] J. Yang, T. Hance, T. H. Austin, A. Solar-Lezama,
C. Flanagan, and S. Chong. End-to-end policy-agnostic
security for database-backed applications. CoRR,
abs/1507.03513, 2015.
[15] A. C. Yao. Protocols for secure computations. In FOCS,
pages 160–164, 1982.