### 优化后的文本

#### 0x01 漏洞分析
在 `_NamingContextAnyImplBase._invoke()` 方法中，由于 `val1` 的值为 "bind_any"，因此会进入 case 0 分支，并调用 `IIOPInputStream.read_any()` 方法。此方法最终会触发 `IIOPInputStream.read_value()` 进行反序列化操作。之前提到在流量中没有看到 "aced" 魔术头，这是因为 `IIOPInputStream` 有一套独立的解析方式。`IIOPInputStream` 的 hex-value 形式包含类名和字段信息，最终会调用恶意类的 `readObject()` 方法。

查看补丁后发现，2015 年 T3 反序列化利用的 [补丁](https://www.tenable.com/security/research/tra-2016-09) 与此次漏洞修复的位置相同。[WebLogic CVE-2020-2551 漏洞分析](https://paper.seebug.org/1138/) 中提到，CVE-2020-2551 在 `weblogic.iiop.Utils` 类中过滤了特定类。但在本地测试中，WebLogic 10.3.6 打上 2015 年的补丁后，并未触发 `isBlacklisted()` 函数（尽管在 `MsgAbbrevInputStream` 和 `InboundMsgAbbrev` 中均有调用该函数进行黑名单验证）。

此次 CVE-2020-2551 的补丁在 `weblogic.iiop.Utils.LoadClass()` 中添加了 `verifyclassermitted()` 方法来过滤恶意类，其中包括 `JtaTransactionManager` 的父类 `com.bea.core.repackaged.springframework.transaction.support.AbstractPlatformTransactionManager`。这个类是 WebLogic 自带的，非常危险。考虑到 `LoadClass()` 之后的验证，如果在加载 `className` 时执行恶意静态代码块，可能会绕过防御机制。这个问题将在后续讨论。

#### 0x02 构造 POC
使用 Java 程序编写的 POC 在本地攻击 WebLogic 服务时有效，但在 Docker 容器或外网机器上无效。相关分析文章如下：
- [手把手教你解决 WebLogic CVE-2020-2551 POC 网络问题](https://xz.aliyun.com/t/7498)
- [漫谈 WebLogic-CVE-2020-2551](https://paper.seebug.org/1149/)

调试 POC 时发现，在 `new InitialContext(env)` 时，`EndPointImpl.sendReceive()` 发送和接收了两个包。`LocateReply` 包含 IOR 信息，IOR 用于 RMI-IIOP 客户端与服务端对象交互时提供 IIOP 通信所需的 host 和 port 信息，以及区分不同服务端对象的 Object_key。

模拟 IIOP 协议时，重点关注的是 Object_key。通过正则匹配从 `LocateReply` 中获取 key address，并手动设置恶意 JRMP 服务器地址 (rmi://...)。间隔 1 秒发送 `bind_any` 包，由于利用链发出的 JRMP 请求不是通过 DGCClient，因此不受 JEP290 影响，可以通过 jrmplisten 进行利用。

POC 在 Docker 环境中测试成功，可以使用 [vulhub](https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf) 提供的 SSRF 环境，将 IP 设置为宿主机，Docker 成功获取宿主机的 JRMP 请求。具体代码见 [GitHub](https://github.com/Dido1960/Weblogic-CVE-2020-2551-To-Internet/blob/master/CVE-2020-2551.py)。

#### 0x03 验证猜想
前面提到通过 codebase 加载远程代码绕过检测的想法。熟悉 JNDI 攻击的同学应该知道，codebase 可以用来指定远程类的位置。如果 codebase 可控且程序允许远程加载类，则可以加载远程恶意类并执行静态代码块中的恶意代码。

阅读代码可知，`weblogic.iiop.Utils.loadClass()` 的第二个参数表示 codebase，该参数在 `IIOPInputStream.read_value()` 中读取，即 `var8` 参数。在 1659 行调用 `readIndirectingRepositoryId(var8)`，最终会调用 `weblogic.iiop.Utils.loadClass()`。要执行 1644 行和 1659 行代码，需要 `(var4 & 1) = 1` 且 `(var4 & 6) = 2`，因此 `var4` 的值应为 3。

从 `readIndirectingRepositoryId` 到 `getClassFromId` 的调用栈显示，最终会在 304 行执行 `loadClass()`。查看 `bind_any` 数据包，发现其由 GIOP Header 和 GIOP Request 组成，GIOP Request 包括 key address、ServiceContextList 和 stub_data。`var4` 的值是 stub_data 中的 `x7f xff xff x02`，因此 `(var4 & 1) = 0` 且 `(var4 & 6) = 2`，不会执行 1644 行代码设置 codebase。

我们通过修改第一个框 `x7f xff xff x02` 为 `x00 x00 x00 x03`，并在第二个框中添加 codebase 长度和值信息。具体代码见 [GitHub](https://github.com/Dido1960/Weblogic-CVE-2020-2551-To-Internet/blob/master/CVE-2020-TEST.py)。需要注意的是，这里进行了对齐操作，因为读取类信息前会检查下一个字节的位置是否为 4 的倍数，如果不是则忽略一些位数。

还有一个问题是，在 `readIndirectingRepositoryId` 到 `getClassFromId` 的调用栈中，中间会经过 `findClassInfo()` 函数。如果某个类已被加载，类 ID 信息会被保存起来，直接返回类信息而不会进入 `weblogic.iiop.Utils.getClassFromID()` 函数。因此，在测试时每次都需要更改类名。

尽管成功模拟 IIOP 协议修改了 codebase 值并执行了 `weblogic.iiop.Utils.getClassFromId()` 函数，但最终在获取 `RMIURLClassFinder` 时返回 NULL，`RMIEnvironment.getEnvironment().isNetworkClassLoadingEnabled()` 返回 false。原因是 `ServerMBeanImpl` 中 `_NetworkClassLoadingEnable` 参数的值为 False。尝试查找哪个 WebLogic 配置文件设置了此参数，但未找到。

#### 总结
学习此漏洞的过程中，需要掌握许多前置知识，如 Java 反序列化、RMI 和 JNDI 等。虽然最终未能通过修改 codebase 实现利用，但收获颇丰。相关学习资料可参考 [安全客专栏](https://www.anquanke.com/subject/id/206001)。