_NamingContextAnyImplBase._invoke()中，因为va1是“bind_any”，所以进入case
0分支，调用IIOPInputStream.read_any()方法，后面还是会调用IIOPInputStream.read_value()触发反序列，之前说在流量中没有看到aced魔术头，是因为在IIOPInputStream中有一套解析方式，IIOPInputStream的hex-value形式如下，其中包含类名和字段信息：
最终会调用恶意类的readObejct()方法
看了一下补丁，发现跟2015年T3反序列化利用的[补丁](https://www.tenable.com/security/research/tra-2016-09)的是同个位置
[WebLogic
CVE-2020-2551漏洞分析](https://paper.seebug.org/1138/)的测试中，看到CVE-2020-2551过滤的类位置也是在weblogic.iiop.Utils类中
但是在本地测试的时候，weblogic10.3.6打上2015年的补丁，并没有触发isBlacklisted()函数（但是在MsgAbbrevInputStream与InboundMsgAbbrev中都有调用isBlacklisted()进行黑名单验证，奇奇怪怪。。。）
这次CVE-2020-2551的补丁，在weblogic.iiop.Utils.LoadClass()中添加了过滤的verifyclassermitted()方法
黑名单过滤了恶意类，其中包括JtaTransactionManager的父类com.bea.core.repackaged.springframework.transaction.support.AbstractPlatformTransactionManager，这个类是weblogic自带的，十分危险，在看补丁的时候就有一个想法，因为606行的验证是在LoadClass()之后，那如果在加载className的时候进行了类的加载执行恶意静态代码块不就绕过防御了吗？这个后面再说
## 0x03 模拟IIOP协议构造POC
用JAVA程序写的POC有网络问题，就直接打本地weblogic服务可以，打docker容器或者外网机器不行，提到这个问题的分析文章：
[手把手教你解决Weblogic CVE-2020-2551 POC网络问题](https://xz.aliyun.com/t/7498)
[漫谈 WebLogic-CVE-2020-2551](https://paper.seebug.org/1149/)
下面对POC进行调试，可以参考前面remove那个，也可以参考[Y4er](https://github.com/Y4er/CVE-2020-2551)的，前面两篇文章提到两种解决方法：
  * 修改weblogic.jar包并重新打包
  * 模拟IIOP协议
我都进行了尝试，重新打包weblogic后，会报java.lang.NoSuchMethodError:weblogic.security.subject.SubjectManager.installCESubjectManager错误，但是没有找到解决方案
所以就尝试模拟IIOP协议，先在POC下断点调试
发现在new InitialContext(env)时，调用EndPointImpl.sendReceive()中发送和接收了两个包
LocateReply中包含IOR信息，这里要理解[什么是IOR](http://www.pvv.ntnu.no/~ljosa/doc/encycmuclopedia/devenv/corba-index.html)，它的作用是，在RMI-IIOP客户端利用IIOP协议与服务端对象进行交互时，用来提供IIOP通信需要的host和port，还有红框部分Object_key用来区分服务端不同的对象
在模拟IIOP协议时，需要重点关注的是Object_key，host跟ip其实并不影响，之前开始测试的时候，是直接把所有的包重新重放一遍，发送resolve_any的时候返回location
forward
GIOP的[官方文档](https://docs.oracle.com/cd/E13211_01/wle/wle42/corba/giop.pdf)中讲到location
forward时，表示Object_key是会变化的，不同次请求返回的Object_key可能不同（这里说的Object_key就是数据包中的key
address），这个Object_key，前面也有说到，是在用IIOP协议时，用来区别跟哪个对象进行通信，这个值需要在LocateReply中动态获取
最后这里没有选择模拟remove()，而是模拟bind()方法发出的IIOP请求，因为请求比较少，看下本地正常利用的数据包
发送LocateRequest，接收data，通过正则匹配获取LocateReply中的key address
手动设置恶意jrmp服务器(rmi://…)地址，间隔1秒发送bind_any包，因为这里的利用链发出的jrmp请求不是用DGCClient，所以不受[JEP290](https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/)的影响，可以通过jrmplisten进行利用
POC在docker环境中测试成功，可以用[vulhub](https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf)这个SSRF环境，设置IP为宿主机，docker成功获取宿主机jrmp请求，具体代码放在[Github](https://github.com/Dido1960/Weblogic-CVE-2020-2551-To-Internet/blob/master/CVE-2020-2551.py)
## 0x04 验证猜想
前面有提到利用codebase加载远程代码绕过检测的想法，研究过[JNDI攻击](https://www.veracode.com/blog/research/exploiting-jndi-injections-java)的同学应该清楚，codebase可以用来指定远程类的位置，如果codebase可控并且程序允许远程加载类，那么就可以加载远程恶意类执行静态代码块中的恶意代码。
阅读代码可知，weblogic.iiop.Utils.lodaClass()第二个参数表示codebase，这个参数在IIOPInputStream.read_value()中读取，即为var8参数，1659行调用readIndirectingRepositoryId(var8)，最终会调用weblogic.iiop.Utils.lodaClass()，要执行1644行和1659行代码，需要(va4r
& 1)=1，(va4 & 6)=2，所以var4的值为3
readIndirectingRepositoryId到getClassFromId的调用栈，最后会执行304行loadclass()
看一下bind_any数据包，其实就是通过GIOP Header与GIOP Request组合而成的，GIOP Request中又包括key
address（与LocateteReply中一致）、ServiceContextList与stub_data，var4的值就是stub_data中的x7fxffxffx02，所以(va4r
& 1)=0，(va4 & 6)=2，不会执行1644行代码设置codebase
我们通过修改下面第一个框x7fxffxffx02为x00x00x00x03，第二个框添加codebase长度与值信息，具体的代码放在[Github](https://github.com/Dido1960/Weblogic-CVE-2020-2551-To-Internet/blob/master/CVE-2020-TEST.py)，可以看到还进行了一个对齐操作，这是一个坑点，因为在读取后面类信息前，会判断下一个字节的位置是不是4的倍数，如果不是会忽略掉一些位数，比如下一个字节的位置是1，则会忽略掉3个字节，直接从位置为4的这个字节读起，这个位置是相对整个bind_any包来说的，这里如果字节不是4的倍数，进行补0操作
还有一个问题，看一下之前readIndirectingRepositoryId到getClassFromId的调用栈，中间会经过findClassInfo()函数，在这里，如果已经加载过某个类，类ID信息会保存起来，findClassInfo()时直接返回类信息，不会进入weblogic.iiop.Utils.getClassFromID()函数
所以在进行测试时，每次都要改一下类名
不管怎样，最后总算是成功模拟IIOP协议修改了codebase值，并执行weblogic.iiop.Utils.getClassFromId()函数。
不幸的是，在获取RMIURLClassFinder的时候返回NULL，RMIEnvironment.getEnvironment().isNetworkClassLoadingEnabled()函数返回false
原因是ServerMBeanImpl中_NetworkClassLoadingEnable参数的值为False
想要看看在哪个weblogic配置文件中设置了这个参数，但是没有找到。。。
## 总结
在学习这个漏洞的过程中，发现需要很多的前置知识，比如java反序列化，RMI，JNDI那些东西，相关的学习可以参考这个[文章专栏](https://www.anquanke.com/subject/id/206001)，虽然最后修改codebase进行利用失败，但还是收获不少。