  2. parseValue 方法
已上条件都不匹配的情况下就认为是普通查询，普通查询都会调用`parseWhereItem` 方法
  3. parseWhereItem 方法
进入此方法以后会发现这个方法会根据 `$exp` 变量的不同拼接不同的sql语句 而在这个方法中看到最多的就是`parseValue`方法了
  4. parseValue 方法
这个方法有会去调用`escapeString`方法 `escapeString`方法里面写的就是将传进来的变量进行addslashes 然后返回
嗯。。。。。。。整体流程看起来我们可以发现TP使用的过滤方法就是一个简单addslashes 来防止过滤,不得不说虽然简单但是还挺有效的。
一套流程走下来，好像并没有发现什么问题呢,该过滤的都过滤了,嗯。。。。那我为什么要写这文章呢？(´°̥̥̥̥̥̥̥̥ω°̥̥̥̥̥̥̥̥｀)
### 0x05 本文重点内容
先在放一次图先
前面我说了吧`parseWhereItem`方法会使用`parseValue`方法
最终是会调用`addslashes`函数进行过滤来防止注入，那么假如，有没有使用`parseValue`方法的变量，并且我们能控制的情况那么是否就可以进行注入了呢？
看到上面我画的三个圈圈了么，这是没有使用`parseValue`方法过滤的,这一块的作用是什么呢？我来简单的说明一下
这里我们来做个实验,重新修改我们的代码
在试另一个
是不是有点小激动？？哦哦哦哦框架sql注入漏洞~~~，emmmmmm，嗯不存在的，来了解一个重要TP重要的安全函数`I`函数先来了解一下`I`函数的功能
从这里可以得知`I`函数是官方强烈推荐的用来代替`post get cookie seesion`等获取数据的方法，我们这里把原来的代码改回去在测试一下
#### 神奇的I函数
> 路径:`ThinkPHP\Common\functions.php`  
>  方法名：`function I($name,$default='',$filter=null,$datas=null)`
这个函数的主要功能为3个
  1. 确定数据类型
  2. 对数据进行循环取值
  3. 调用think_filter 函数进行过滤
#### think_filter函数分析
结合我们前面看的知识，大概就可以清楚这个空格的意思了。
例如：
  1. 没有使用`think_filter`函数时`goods_name[0]=in&goods_name[1]=(true) and (updatexml(1,concat(1,(select user())),1))--&goods_name[2]=exp`
  2. 使用了`think_filter`函数时`goods_name[0]=in &goods_name[1]=(true) and (updatexml(1,concat(1,(select user())),1))--&goods_name[2]=exp`
注意：使用了`think_filter`函数时`in`后面是有空格的也就是说返回值是`goods_name[0]=in(空格)&goods_name[1]=(true)
and (updatexml(1,concat(1,(select user())),1))--&goods_name[2]=exp`
也就是说我们传进去的值`If( in(空格) == ‘in’ )`那么当然是不匹配的也就防止了sql注入的产生
### 0x06 完
​ 经过上面的分析不知道大家是否有学到什么，对于使用TP框架是否熟悉了？已下是不按官方的规范使用的方式。
注入：(已下通通通通通通都是使用者的错误，不管TP的事情，自己看看对比一下自己的网站有没有这样做)
  1. 进入目录直接搜索 `$_POST $_GET`查看是否带入了`where`查询如果带入了，根据我们上面的分析，基本上都可以进行注入。（因为根据我们上面的分析，当不使用TP推荐的I函数时，我们是可以自己构造语句来进行注入的）例如：
  1. 全局搜索`where`查看是否有字符串拼接的痕迹
  1. 链操作方法中 画红圈圈的地方可以外部操控时，就可以产生注入
例如：全局搜索`order`(当我们可以操控`order`传进去的参数时，也是可以进行注入的，这是因为Tp对`order`方法只是一个字符串拼接的操作 )
  1. 全局搜索`join`，`field`(与上同理，执行的都是字符串拼接，只要可以外部操作就可以产生注入) 这个基本可以无视了，正常人根本不会开放这两个方法外部操控
#### 小技巧找储蓄Xss：
关于过滤Xss TP做的满好的基本上我们只能通用变量来判断是否可以Xss
> 1，`I(‘post.xxx’,’’,’’); I(‘get.xxx’,’’,’’); I(‘request.xxxx’,’’,’’)`
>
> 2，`I(‘post.xxx’,’’,’xxxx’); I(‘get.xxx’,’’,’xxxx’);
> I(‘request.xxxx’,’’,’xxxx’)`
这种情况是可以尝试进行Xss的，第三个参数给设置的情况下（给设置了时请自己查看调用的函数是用来干嘛的才进行Xss），或是为空的情况下（为空的情况下就可以直接进行Xss）
> 3, `$_GET[‘xxx’] $_POST[‘XX’] $_REQUEST[‘XXX’]`
当你看到 这样的变量给带入`add`方法或是`save`方法也是可以进行Xss的
#### 小技巧查看是否可以直接Getshell
查看是否设置了`DATA_CACHE_KEY`（有设置的情况下，这个技巧请无视）
  1. 缓存函数`S`查看是否使用了如果使用了查看是否可以控制可操控的情况下就可以直接getshell（我相信百分之90的人会去设置目录访问权限，但是我不相信百分百的人都会这么干）
语句：
    %0D%0A%24a%3Deval(%24_POST%5B%27a3%27%5D)%3B%23
这里小技巧的话设置了`DATA_CACHE_KEY` 也是无用的不影响。
  1. 缓存函数`F`这个与上面的区别在于 `S`函数只要可以外部操控就可能可以getshell，而`F`函数 要利用起来的话，需要几个条件
2.1 对方这样使用`I`函数
> I(‘post.xxx’,’’,’’); I(‘get.xxx’,’’,’’); I(‘request.xxxx’,’’,’’)
​ 2.2 对方直接使用`$_GET[‘xxx’] $_POST[‘XX’] $_REQUEST[‘XXX’]`
语句：
为什么需要这样才能利用呢？因为`F`函数生成的缓存不带 `` 所以我们需要自己构造 而自己构造的话，经过了`I`函数`‘’`就会给过滤导致无用,
当然`F`函数我认为可以利用的情况下比`S`函数要方便很多因为`F`函数生成的文件名称是不加密的
例子1：
例子2：
注：使用框架请严格准守框架规范，避免一些出现意外的问题。