# Catena: Efficient Non-equivocation via Bitcoin

**Authors:** Alin Tomescu and Srinivas Devadas  
**Conference:** 2017 IEEE Symposium on Security and Privacy

## Abstract
We introduce Catena, an efficiently verifiable Bitcoin-based witnessing scheme. Catena enables any number of thin clients, such as mobile phones, to agree on a log of application-specific statements managed by an adversarial server. Catena implements a log as a chain of OP_RETURN transactions and prevents forks in the log by leveraging Bitcoin's security against double spends. Specifically, if a log server attempts to equivocate, it must double-spend a Bitcoin transaction output. Thus, Catena logs are as secure as the Bitcoin blockchain: an adversary without a significant fraction of the network’s computational power cannot fork Bitcoin and, consequently, cannot fork a Catena log either. Unlike previous Bitcoin-based schemes, Catena reduces the bandwidth requirements for log auditors from 90 GB to just tens of megabytes. More precisely, our clients only need to download all Bitcoin block headers (currently less than 35 MB) and a small, 600-byte proof for each statement in a block. We implement Catena in Java using the bitcoinj library and use it to extend CONIKS, a recent key transparency scheme, to witness its public-key directory in the Bitcoin blockchain, where it can be efficiently verified by auditors. We demonstrate that Catena can secure various systems, including public-key directories, Tor directory servers, and software transparency schemes.

## 1. Introduction
Security often hinges on non-equivocation [1], [2]. For example, if a Certificate Authority (CA) equivocates by signing conflicting certificates for the same identity, it can impersonate websites and compromise users' privacy. This has occurred multiple times in the past [3]–[9]. To prevent equivocation, Certificate Transparency (CT) [10] was introduced to publicly log all CA-issued certificates. However, a CT log server can still equivocate about the log of issued certificates and, in collusion with a CA, launch impersonation attacks. While gossiping [11] about the log can help detect equivocation, detection can be slow or may not occur at all, as gossip messages can be indefinitely delayed. Another example is the Tor [12] anonymity network, where malicious directory servers can equivocate about the set of Tor relays and deanonymize users by tricking them into using malicious relays [13]. Therefore, we believe non-equivocation is a critical security requirement in many systems today, such as public-key distribution, blockchain-based transparency [14], [15], and software transparency (see §II-A).

Unfortunately, achieving non-equivocation without online trusted parties is impossible [16]. To address this, systems enforce a weaker property called fork consistency [16]. Fork-consistent systems make equivocation "permanent" and easier to prove later when clients can communicate or "gossip" out-of-band. However, for systems like public-key directories and Tor directory servers, undetected equivocation attacks can severely impact users' security. Thus, a more proactive approach [17] to security is desirable for such systems.

To proactively prevent equivocation, recent work [14], [15] uses the Bitcoin blockchain [18] as a witness. We believe this Bitcoin witnessing approach, though currently inefficient, is promising for three reasons. First, it makes equivocation as difficult as forking the Bitcoin blockchain, which has proven resistant to forking attacks. Second, it relies on a single global witness, the Bitcoin blockchain, eliminating the need for users to obtain correct cryptographic identities of multiple trusted entities, such as log providers and auditors in CT [10] or witnesses in CoSi [17]. It also does not require the witness to keep any secrets, which, if compromised, would result in equivocation. Third, the Bitcoin blockchain's open, decentralized, and censorship-resistant nature makes deploying witnessing schemes easy and interference with them difficult. Unfortunately, the main drawback of existing Bitcoin witnessing schemes is that auditors must download the entire Bitcoin blockchain, which, in November 2016, was almost 90 GB [19] in size and growing by 52 GB annually.

This paper presents Catena, an efficient Bitcoin-based witnessing scheme that significantly reduces auditors' bandwidth overhead. At a high level, Catena is a tamper-evident log [20] built on top of the Bitcoin blockchain. Catena prevents adversarial log servers who cannot fork the Bitcoin blockchain from equivocating about a log of application-specific statements. Importantly, auditors running Catena clients can check the log for non-equivocation efficiently via Simplified Payment Verification (SPV) [18] (see §II-B6). This drastically decreases auditing bandwidth from 90 GB [19] to only tens of megabytes, as Catena clients only need to download Bitcoin block headers and small Merkle proofs under some of those headers. Furthermore, after all block headers are downloaded, the bandwidth decreases to less than 1 KB of data every 10 minutes.

### A. Efficient Non-equivocation via Bitcoin
Previous Bitcoin witnessing schemes [14], [15] cannot efficiently prove non-membership of inconsistent statements unless auditors download all the transactions in the Bitcoin blockchain. Our design addresses this issue by allowing Catena clients to skip downloading all irrelevant transactions while still ensuring non-equivocation. The key idea behind Catena is that Bitcoin's mechanism for preventing double spends can be regarded as a non-membership proof. Specifically, Bitcoin proves that no transactions double-spending a previous transaction's output exist. If a client verifies blockchain membership for a transaction `tx2` that spends a previous transaction output `tx1[0]`, the client implicitly verifies that no other transaction `tx2′` that spends `tx1[0]` exists in the blockchain. (`tx1[0]` refers to the first output of transaction `tx1`; see §II-B4 for Bitcoin background.)

Catena turns this idea into a non-equivocation scheme. Each Catena transaction stores exactly one statement and spends the previous Catena transaction, creating a chain of statements as shown in Figure 1. This implies that if an auditor sees a statement `si` in the blockchain whose transaction correctly spends the transaction for the previous statement `si−1`, it constitutes a non-membership proof that no other inconsistent statement `s'i` exists. In other words, if an adversarial log server wants to equivocate about `si`, it must double-spend the previous Catena transaction for `si−1`, which can only be done by forking the Bitcoin blockchain.

#### 1. Root-of-Trust
Catena guarantees that once a client correctly obtains a log’s genesis transaction, the server cannot equivocate about that log unless it forks the Bitcoin blockchain. The genesis transaction is the first transaction in the log and acts as the root-of-trust or "public key" for a Catena log (see §IV-A1). Once clients obtain the correct genesis transaction, they can efficiently verify that every issued statement comes from a transaction that spends coins originating from the genesis transaction. In §IV, we explain how this implicitly prevents equivocation in a Catena log. Our design is simple and efficient and obviates the need for log servers and clients to download the full Bitcoin blockchain while ensuring the consistency of the log.

#### 2. Bitcoin-friendly
To embed log statements in Bitcoin transactions, Catena uses provably-unspendable OP_RETURN transaction outputs [21], which, unlike previous work [15], [22], do not harm Bitcoin by polluting the unspent transaction output (UTXO) set on Bitcoin nodes. However, Catena's novelty is not in leveraging OP_RETURN (previous work already does that; see §VIII), but in chaining together OP_RETURN transactions that contain log statements, making it possible to check for non-equivocation efficiently. Furthermore, Catena does not place unnecessary stress on the Bitcoin P2P network. First, clients query the Catena log server directly to discover statements instead of using disk-intensive Bloom filtering on the Bitcoin P2P network (see §II-B6). Second, to avoid depleting the small connection pool of Bitcoin's P2P network, clients query a header relay network (HRN) to obtain the latest Bitcoin block headers (see §IV-B). The HRN can be thought of as an "extension" of Bitcoin’s P2P network for handling additional block header requests from Catena clients. We discuss potential attacks on the HRN in §V-E.

#### 3. Applications
Due to Bitcoin’s 10-minute block rate, the Catena log server can only issue a statement every 10 minutes, and clients have to wait at least 60 minutes before accepting an issued statement. Despite these delays, we believe Catena can help secure applications such as key transparency schemes, Tor directory servers, and software transparency schemes. We discuss these applications in more detail in §II-A and discuss Catena’s application-agnostic nature in §VII-3.

#### 4. Evaluation
To demonstrate the feasibility of Catena, we implement a small-scale prototype in 3000 lines of Java using the bitcoinj Simplified Payment Verification (SPV) library [23] (see §VI). Our current prototype does not include a Header Relay Network (HRN), so it will not scale to many Catena clients without stressing Bitcoin’s P2P network. We leave this to future work. We also analyze the Bitcoin transaction fees the server has to pay per issued statement and show they could range from 7 to 12 US cents per statement. Since existing systems like Keybase [14] already pay close to 7 US cents per transaction, we believe this cost is practical. Finally, we use our prototype to add Bitcoin witnessing to CONIKS [2], a recent key transparency scheme (see §VI-D), to demonstrate the ease of using Catena.

### B. Contributions and Organization
To summarize, this paper makes the following contributions:
- A new, efficient approach to transparency based on witnessing in the Bitcoin blockchain.
- Catena, an append-only log built on top of Bitcoin that is efficiently verifiable by thin clients, eliminating the need to download the full Bitcoin blockchain.
- A prototype implementation of Catena in Java that can be used by applications today.

**Organization.** We motivate Catena and present the necessary Bitcoin background to understand our design in §II. We describe our system’s actors, threat model, and goals in §III. We present Catena’s design in §IV and discuss attacks and countermeasures in §V. We discuss our prototype implementation, its overheads, and our extension of CONIKS in §VI. We discuss remaining issues and future work in §VII. We review related work in §VIII and conclude in §IX.

## 2. Background and Motivation
In this section, we discuss our motivation for designing Catena and provide the necessary background on Bitcoin needed to understand Catena’s design.

### A. Motivation
Our primary motivation for designing Catena is to provide proactive security to many applications that depend on it. We also aim to improve previous blockchain-based transparency schemes [14], [24] whose shortcomings we describe in §II-A2. Finally, we want a non-equivocation scheme that does not require many trustworthy parties and can be deployed today.

#### 1. Key Transparency
Catena can prevent equivocation attacks in current key transparency work [2], [10], [25]–[28] and, as a result, thwart man-in-the-middle (MITM) attacks. Key transparency schemes bundle public key bindings together into a directory implemented using authenticated data structures [29]. Users are presented with digests of the directory as it evolves over time and can verify someone’s public key against a digest of the directory, preventing equivocation with respect to that digest. The remaining challenge for key transparency schemes is to prevent equivocation about the digests themselves. Current schemes rely on federated trust [2], any-trust assumptions [27], non-collusion between actors [27], [28], or on users gossiping between themselves [2], [11], [25], [26] or with trusted validators [28].

With Catena, we propose using the Bitcoin blockchain as a hard-to-coerce, trustworthy witness that can vouch for directory digests. For example, in Certificate Transparency (CT), a log server would directly witness signed tree heads (STHs) in Bitcoin via a Catena log. Users can efficiently look up new STHs in the Catena log and be certain that the log server has not equivocated about them. We believe this approach could be more resilient to attacks, as a compromised log server cannot equivocate without forking the Bitcoin blockchain. Additionally, because most transparency schemes publish digests of the directory periodically, we believe they are amenable to being secured by Catena.

#### 2. Blockchain-based Transparency
Blockchain-based transparency schemes [14], [15] are promising due to their simplicity and resilience to forks, but the overhead of downloading all blockchain data makes them unusable on many devices. Catena can decrease the overhead of these schemes from currently 90 GB [19] to around 35 MB. For example, Catena can enable thin clients running on mobile phones to efficiently audit the Bitcoin-witnessed Keybase public-key directory [14]. Currently, Keybase publishes digests of their public-key directory in Bitcoin by creating transactions signed by a predetermined public key [30]. Keybase clients recognize these transactions and read directory digests from them (see §VIII for details). The problem with this approach is that thin clients cannot securely use Bloom filtering (see §II-B6) to avoid downloading irrelevant transactions, as an adversary could selectively hide Keybase transactions and equivocate about the directory (we explain this attack in §IV-C). Catena prevents this attack and also avoids polluting Bitcoin’s unspent transaction output (UTXO) set [22].

Catena can also be used to improve Blockstack’s thin client security [15]. Currently, to benefit from Bitcoin’s resilience against forks, Blockstack clients need to download the entire blockchain and compute their own consensus hash over all Blockstack-related operations (see §VIII for details). Blockstack clients could also choose to trust someone else’s consensus hash and verify public key lookups against it efficiently using Simplified Name Verification (SNV) [15]. However, clients still have to download full Bitcoin blocks to update that consensus hash or continue trusting someone else to update it. As with Keybase, Bloom filtering cannot be used securely to avoid downloading irrelevant transactions.