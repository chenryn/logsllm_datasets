title:Catena: Efficient Non-equivocation via Bitcoin
author:Alin Tomescu and
Srinivas Devadas
2017 IEEE Symposium on Security and Privacy
Catena: Efﬁcient Non-equivocation via Bitcoin
Alin Tomescu
MIT CSAIL
Srinivas Devadas
MIT CSAIL
Abstract—We present Catena, an efﬁciently-veriﬁable Bitcoin
witnessing scheme. Catena enables any number of thin clients,
such as mobile phones, to efﬁciently agree on a log of application-
speciﬁc statements managed by an adversarial server. Catena
implements a log as an OP_RETURN transaction chain and
prevents forks in the log by leveraging Bitcoin’s security against
double spends. Speciﬁcally, if a log server wants to equivocate it
has to double spend a Bitcoin transaction output. Thus, Catena
logs are as hard to fork as the Bitcoin blockchain: an adversary
without a large fraction of the network’s computational power
cannot fork Bitcoin and thus cannot fork a Catena log either.
However, different from previous Bitcoin-based work, Catena
decreases the bandwidth requirements of log auditors from 90
GB to only tens of megabytes. More precisely, our clients only
need to download all Bitcoin block headers (currently less than
35 MB) and a small, 600-byte proof for each statement in a block.
We implement Catena in Java using the bitcoinj library and use it
to extend CONIKS, a recent key transparency scheme, to witness
its public-key directory in the Bitcoin blockchain where it can be
efﬁciently veriﬁed by auditors. We show that Catena can secure
many systems today, such as public-key directories, Tor directory
servers and software transparency schemes.
I. INTRODUCTION
Security often depends on non-equivocation [1], [2]. For
example, when a Certiﬁcate Authority (CA) equivocates by
signing contradicting certiﬁcates for the same identity, it can
impersonate websites and compromise users’ privacy. In fact,
this has happened many times in the past [3]–[9]. To prevent
equivocation, Certiﬁcate Transparency (CT) [10] has been
introduced as a way of publicly logging all CA-issued cer-
tiﬁcates. However, a CT log server can still equivocate about
the log of issued certiﬁcates and, together with a colluding CA,
can launch impersonation attacks. While gossiping [11] about
the log can help detect equivocation, detection can be slow or
not happen at all, as gossip messages can be delayed indef-
initely. Another example is the Tor [12] anonymity network,
where malicious directory servers can equivocate about the
set of Tor relays and deanonymize users by tricking them to
use malicious relays [13]. Thus, we believe non-equivocation
is an important security requirement in many systems today,
such as public-key distribution, blockchain-based transparency
[14], [15] and software transparency (see §II-A).
Unfortunately, without online trusted parties, achieving non-
equivocation is impossible [16]. To deal with this impossibility
result, systems resort to enforcing a weaker property called
fork consistency [16]. Fork-consistent systems essentially
make equivocation “permanent” and thus easier to prove later
when clients are able to communicate or “gossip” out-of-band.
However, as illustrated above, for systems such as public-key
Fig. 1. A Catena log is a chain of Bitcoin transactions. Each Catena
transaction has two outputs: (1) a continuation output, which is spent by
the next Catena transaction, thus creating a chain and (2) an OP_RETURN
output, which commits some application-speciﬁc statement. The server pays
Bitcoin transaction fees for each issued statement. For applications that publish
statements often, batching can be used to keep the fee per statement low.
directories and Tor directory servers, undetected equivocation
attacks can seriously impact users’ security. Thus, we believe a
more proactive approach [17] to security is desirable for such
systems.
To prevent equivocation proactively, recent work [14], [15]
uses the Bitcoin blockchain [18], as a witness. We believe
this Bitcoin witnessing approach, though currently inefﬁcient,
is promising for three reasons. First, this approach makes
equivocation as hard as forking the Bitcoin blockchain itself,
which has proven resistant to forking attacks. Second, this
approach only relies on a single global witness, namely the
Bitcoin blockchain, obviating the need for users to obtain
correct cryptographic identities of multiple trusted entities,
such as log providers and auditors as in CT [10], or witnesses
as in CoSi [17]. It also has the advantage of not requiring
the witness to keep any secrets, which if compromised would
result in equivocation. Third, the Bitcoin blockchain’s open,
decentralized and censorship-resistant nature makes deploy-
ment of witnessing schemes easy and interference with them
hard. Unfortunately, the main drawback of existing Bitcoin
witnessing schemes has been that auditors have to download
the entire Bitcoin blockchain, which, in November 2016, was
almost 90 GB [19] in size and growing by 52 GB every year.
This paper presents Catena, an efﬁcient Bitcoin-based wit-
nessing scheme that dramatically reduces auditors’ bandwidth
overhead. At a high level, Catena is a tamper-evident log
[20] built on top of the Bitcoin blockchain. Catena prevents
adversarial log servers who cannot fork the Bitcoin block-
© 2017, Alin Tomescu. Under license to IEEE.
DOI 10.1109/SP.2017.19
393
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:20:17 UTC from IEEE Xplore.  Restrictions apply. 
chain from equivocating about a log of application-speciﬁc
statements. Importantly, auditors who run Catena clients can
check the log for non-equivocation efﬁciently via Simpliﬁed
Payment Veriﬁcation (SPV) [18] (see §II-B6). This drastically
decreases auditing bandwidth from 90 GB [19] to only tens of
megabytes, as Catena clients only need to download Bitcoin
block headers and small Merkle proofs under some of those
headers. Furthermore, after all block headers are downloaded,
the bandwidth decreases to less than 1 KB of data every 10
minutes.
A. Efﬁcient Non-equivocation via Bitcoin
Previous Bitcoin witnessing schemes [14], [15] cannot
efﬁciently prove non-membership of inconsistent statements
unless auditors download all the transactions in the Bitcoin
blockchain. Our design addresses this issue by allowing
Catena clients to skip downloading all irrelevant transactions
while still guaranteeing non-equivocation. The key idea behind
Catena is that Bitcoin’s mechanism for preventing double
spends can actually be regarded as a non-membership proof.
Speciﬁcally, Bitcoin proves that no transactions double spend-
ing a previous transaction’s output exist. That is, if a client
veriﬁes blockchain membership for a transaction tx2 which
spends a previous transaction output tx1[0], that client has also
implicitly veriﬁed that no other transaction tx(cid:2)
2 which spends
tx1[0] exists in the blockchain. (tx1[0] refers to the ﬁrst output
of transaction tx1; see §II-B4 for Bitcoin background.)
Catena turns this idea into a non-equivocation scheme.
Each Catena transaction stores exactly one statement and
spends the previous Catena transaction, creating a chain of
statements as shown in Figure 1. This implies that
if an
auditor sees a statement si in the blockchain whose transaction
correctly spends the transaction for the previous statement
si−1, then that constitutes a non-membership proof that no
other inconsistent statement s(cid:2)
i exists. Looked at differently,
if an adversarial log server wants to equivocate about si, it
has to double spend the previous Catena transaction for si−1,
which can only be done by forking the Bitcoin blockchain.
1) Root-of-Trust: Catena guarantees that once a client cor-
rectly obtains a log’s genesis transaction, the server cannot
equivocate about that log unless it forks the Bitcoin block-
chain. The genesis transaction is the ﬁrst transaction in the
log and acts as the root-of-trust or “public key” for a Catena
log (see §IV-A1). Once clients obtain the correct genesis trans-
action they can efﬁciently verify that every issued statement
comes from a transaction that spends coins originating from
the genesis transaction. In §IV, we explain how this implicitly
prevents equivocation in a Catena log. Our design is simple
and efﬁcient and obviates the need for log servers and clients
to download the full Bitcoin blockchain while ensuring the
consistency of the log.
2) Bitcoin-friendly: To embed log statements in Bitcoin
transactions, Catena uses provably-unspendable OP_RETURN
transaction outputs [21], which, unlike previous work [15],
[22], does not harm Bitcoin by polluting the unspent transac-
tion output (UTXO) set on Bitcoin nodes. However, we em-
phasize that Catena’s novelty is not in leveraging OP_RETURN
(previous work already does that; see §VIII), but in chaining
together OP_RETURN transactions that contain log statements,
which makes it possible to check for non-equivocation efﬁ-
ciently. Furthermore, Catena does not place unnecessary stress
on the Bitcoin P2P network. First, clients query the Catena log
server directly to discover statements instead of using disk-
intensive Bloom ﬁltering on the Bitcoin P2P network (see
§II-B6). Second, to avoid depleting the small connection pool
of Bitcoin’s P2P network, clients query a header relay network
(HRN) to obtain the latest Bitcoin block headers (see §IV-B).
Put simply, the HRN can be thought of as an “extension” of
Bitcoin’s P2P network for handling additional block header
requests coming from Catena clients. We discuss potential
attacks on the HRN in §V-E.
3) Applications: Due to Bitcoin’s 10-minute block rate, the
Catena log server can only issue a statement every 10 minutes
while clients have to wait at least 60 minutes before accepting
an issued statement. Still, even with these delays, we believe
Catena can help secure applications such as key transparency
schemes, Tor directory servers and software transparency
schemes. We discuss these applications in more detail in §II-A
and discuss Catena’s application-agnostic nature in §VII-3.
4) Evaluation: To demonstrate the feasibility of Catena, we
implement a small-scale prototype in 3000 lines of Java using
the bitcoinj Simpliﬁed Payment Veriﬁcation (SPV) library [23]
(see §VI). Our current prototype does not include a Header
Relay Network (HRN) so it will not scale to too many Catena
clients without stressing Bitcoin’s P2P network. We leave this
to future work. We also analyze the Bitcoin transaction fees
the server has to pay per issued statement and show they
could be anywhere between 7 to 12 US cents per statement.
Since existing systems like Keybase [14] already pay close to
7 US cents per transaction, we believe this cost is practical.
Finally, we use our prototype to add Bitcoin witnessing to
CONIKS [2], a recent key transparency scheme (see §VI-D),
to demonstrate the ease of using Catena.
B. Contributions and Organization
To summarize, this paper makes the following contributions:
• A new, efﬁcient approach to transparency based on wit-
nessing in the Bitcoin blockchain.
• Catena, an append-only log built on top of Bitcoin that
is efﬁciently veriﬁable by thin clients, obviating the need
to download the full Bitcoin blockchain.
• A prototype implementation of Catena in Java that can
be used by applications today.
Organization. We motivate Catena and present the Bitcoin
background necessary to understand our design in §II. We
describe our system’s actors, threat model and goals in §III.
We present Catena’s design in §IV and we discuss attacks and
countermeasures in §V. We discuss our prototype implemen-
tation, its overheads and our extension of CONIKS in §VI.
We discuss remaining issues and future work in §VII. We go
over related work in §VIII and we conclude in §IX.
394
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:20:17 UTC from IEEE Xplore.  Restrictions apply. 
II. BACKGROUND AND MOTIVATION
In this section, we discuss our motivation for designing
Catena and give the necessary background on Bitcoin needed
to understand Catena’s design.
A. Motivation
Our main motivation for designing Catena is to provide
proactive security to many applications that depend on it.
At the same time, we want to improve previous blockchain-
based transparency schemes [14], [24] whose shortcomings
we describe in §II-A2. Finally, we want a non-equivocation
scheme that does not require many trustworthy parties to come
into existence and that can be deployed today.
1) Key Transparency: Catena can prevent equivocation at-
tacks in current key transparency work [2], [10], [25]–[28] and,
as a result, thwart man-in-the-middle (MITM) attacks. Key
transparency schemes bundle public key bindings together into
a directory implemented using authenticated data structures
[29]. Users are presented with digests of the directory as
it evolves over time and can verify someone’s public key
against a digest of the directory, preventing equivocation
with respect to that digest. The remaining problem for key
transparency schemes is to prevent equivocation about the
digests themselves. For this, current schemes rely on federated
trust [2], any-trust assumptions [27], non-collusion between
actors [27], [28] or on users gossiping between themselves
[2], [11], [25], [26] or with trusted validators [28].
With Catena, we propose using the Bitcoin blockchain as a
hard-to-coerce, trustworthy witness that can vouch for direc-
tory digests. For example, in Certiﬁcate Transparency (CT), a
log server would directly witness signed tree heads (STHs) in
Bitcoin via a Catena log. Users can efﬁciently look up new
STHs in the Catena log and be certain that the log server has
not equivocated about them. We believe this approach could
be more resilient to attacks, as a compromised log server
cannot equivocate without forking the Bitcoin blockchain.
Also, because most transparency schemes publish digests of
the directory periodically, we believe they are amenable to
being secured by Catena.
Transparency:
2) Blockchain-based
Blockchain-based
transparency schemes [14], [15] are promising due to their
simplicity and resilience to forks, but
the overhead of
downloading all blockchain data makes them unusable on
many devices. Catena can decrease the overhead of these
schemes from currently 90 GB [19] to around 35 MB.
For example, Catena can enable thin clients running on
mobile phones to efﬁciently audit
the Bitcoin-witnessed
Keybase public-key directory [14]. Currently, Keybase
publishes digests of their public-key directory in Bitcoin
by creating transactions signed by a predetermined public
key [30]. Keybase clients recognize these transactions and
read directory digests from them (see §VIII for details). The
problem with this approach is that thin clients cannot securely
use Bloom ﬁltering (see §II-B6)
to avoid downloading
irrelevant transactions, as an adversary could selectively hide
Keybase transactions and equivocate about the directory (we
explain this attack in §IV-C). Catena prevents this attack and
also has the advantage of not polluting Bitcoin’s unspent
transaction output (UTXO) set [22].
Catena can also be used to improve Blockstack’s thin client
security [15]. Currently, to beneﬁt from Bitcoin’s resilience
against forks, Blockstack clients need to download the entire
blockchain and compute their own consensus hash over all
Blockstack-related operations (see §VIII for details). Block-
stack clients could also choose to trust someone else’s con-
sensus hash and verify public key lookups against it efﬁciently
using Simpliﬁed Name Veriﬁcation (SNV) [15]. However,
clients still have to download full Bitcoin blocks to update that
consensus hash or continue trusting someone else to update it.
As with Keybase, Bloom ﬁltering cannot be used securely to