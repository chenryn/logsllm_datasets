ACME and 𝑠, 𝐷, 𝑘, 𝑐𝑒𝑟𝑡 as above, 𝑡 fulfills ACME’s secure binding
property for 𝑠, 𝐷, 𝑘, and 𝑐𝑒𝑟𝑡.
We highlight that by proving this theorem for our detailed ACME
model, we can exclude many classes of attacks. In particular, we
can exclude the attacks described in Section 5, e.g., attacks based on
logical errors in the protocol flow, ambiguities in the specification
(e.g., not stating explicitly that the ACME server must enforce that
the same account is used in one protocol flow) or even potential im-
plementation glitches unintentionally implied by the specification.
We state (and prove) the above theorem as a lemma in DY★ which re-
quires that the secure binding property follows from the valid_trace
invariant. We discuss this invariant in the proof structure paragraph
below (see also Section 2 for the general proof technique in DY★).
We formulate this theorem in DY★ as follows (slightly simplified
for presentation):
val secure_binding_theorem:
s:principal → // any (server) principal
trace_idx:nat → // any trace index
cert:certificate → // any certificate
dom:domain → // any domain
priv_key:bytes → // any private key
DY unit
(requires (𝜆 t0 → ( valid_trace t0 ∧ // any trace t0 that is valid
// if the server s updated its internal state at trace index trace_idx
// and stored the certificate cert in a state entry of this updated state
is_certificate_in_server_state s trace_idx cert ∧
// if the domain dom is one of the domains for which the certificate is issued
is_domain_in_certificate cert dom ∧
// if the key priv_key is the private key to the certificate public key
pk priv_key == cert.pub_key ∧
// and if the server is not corrupted by the attacker
¬(is_principal_corrupted_before trace_idx s))))
(ensures (𝜆 t0 _t1 → (t0 == t1 ∧ (
// then the attacker cannot derive the private key priv_key
is_unknown_to_attacker_at (len t0) priv_key ∨
// or the principal that owns the domain is corrupted
is_principal_corrupted (owner_of_domain dom)))))
Proof Structure. In the following, we give a simplified high-level
overview of how we prove the secure binding property within DY★.
We provide the full proof of the property in our supplementary
material [10] and only point to selected modules in what follows.
As already stated, the theorem must be implied by the valid_trace
invariant. Recall that valid_trace includes, among others, the state
invariant of the principal states state_inv and the authenticated
send predicate auth_send_pred (see Sections 2 and 3.1). We need
to construct the components of valid_trace such that they reflect
relevant aspects from the different stages of the protocol. The ma-
jority of the work is then to ensure that valid_trace is preserved
throughout all modules of the model.
One central property inferred from the challenge verification
step is the connection between the owner of a domain and an ACME
client account. When the ACME server receives a verification re-
sponse containing the account’s public key (see Step 16 of Figure 2)
via an authenticated channel, we can infer that, if the sender is
an honest principal, the sender of the message indeed owns the
private key to the account.7 We express this fact in auth_send_pred.
Of course, the client must obey this predicate when sending the
verification message, verified by F★’s typecheck.
7See the module ACME.Server.ReceiveChallengeVerification.
We propagate the connection between the domain owner and
the account key using DY★’s labeling system and encode this fact
in the state invariant of the ACME server.8 More precisely, if the
server sets the status of an authorization to valid, then the account
key related to the authorization must be labeled with the domain
owner. Every time the server updates its state, we must ensure
that this invariant holds true. In particular, the server’s function
processing the verification response infers this property from the
guarantees of the authenticated channel.9
To connect the issuance of a certificate to the domain verifi-
cation, we have to enrich the state invariant further: Whenever
the server issues a certificate (as recorded in the server state), we
require that the certificate key is labeled such that it belongs to
the rightful domain owner for the domains in the certificate.10 To
prove that the server preserves this invariant as well, we first link
the processing of the message containing a CSR to the guarantees
of the ownership verification sketched above: Recall that, whenever
the server receives a CSR for an ACME order to issue a certificate,
the server checks whether the account key used for signing the
JWS containing the CSR is the same key associated with the ACME
order (as recorded in the server state). Following from the state
invariant constructed above, we have that the JWS containing the
CSR must have been signed by the rightful owner of the domains.
Next, we link the label of the key contained in the CSR (that will be
the key of the certificate) to the owner of the domains: To this end,
we define the application-specific signature predicate such that it
provides the guarantee that honest principals only ever create a
JWS with a CSR if they own the key contained in the CSR. We again
convey this information using the labeling system.11
Finally, to prove the secure binding theorem, we use the invari-
ants on labels of certificate keys as sketched above and the generic
secrecy properties of DY★’s labeling system.12
Modularity. We highlight that the DY★ framework enables the
proofs to be highly modular, illustrated by the example above, where
the server needs to fulfill specific properties before being able to
store the certificate. Overall, this leads to quite local proofs for
each function, making the proof very efficient. Furthermore, the
invariants hold true for arbitrary interleavings of arbitrary protocol
sessions.
Secure Coding Discipline. We emphasize that F★’s typecheck
guarantees that we never violate any of the invariants sketched
above. If the model would contain any flaws, for example, missing
checks, incorrect handling of keys, incorrect modification of the
state, etc., the corresponding function would fail this typecheck.
As mentioned in Section 6.3, we have implemented a faulty
server that incorrectly iterates over domains during ownership
verification, similar to the bug in Boulder [35] (see also Section 5).
As expected, the typecheck fails, and we have to manually override
F★’s typechecker to compile this code.13
8See valid_acme_server_st in Application.Predicates.Helpers.
9See again the module ACME.Server.ReceiveChallengeVerification.
10See again valid_acme_server_st in Application.Predicates.Helpers.
11See the module ACME.Server.FinalizeOrder.
12See the module ACME.SecurityProperties.
13See the faulty implementation check_valid_and_set_ready_for_order_faulty
in the module ACME.Server.Helperfunctions of our supplementary material [10].
Session 10B: Crypto and Protocol Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea26117.2 Integrity Properties
We consider two main integrity properties: Integrity of an ACME
flow from the server’s perspective and the client’s perspective. In
the following, we present both properties and refer to Appendix B
for the (simplified) DY★ lemmas and the high-level proof structures.
Server-Side Integrity. The server-side integrity property states
that any certificate that the server has issued for an honest client
has actually been requested by the client, and the client owns the
corresponding account key used for the protocol flow.
Theorem 2 (Server-Side Integrity). For all possible global
traces 𝑡 of the DY★ model of ACME, with 𝑠 being a principal (an ACME
server), 𝑑 being a domain, 𝐷 being a set of domains, 𝑎𝑐𝑐_𝑝𝑢𝑏_𝑘𝑒𝑦
being some public key, and 𝑐𝑒𝑟𝑡 some certificate issued by 𝑠 in 𝑡 for
the set 𝐷, if 𝑑 is a domain in 𝐷, 𝑎𝑐𝑐_𝑝𝑢𝑏_𝑘𝑒𝑦 is the account public
key used for issuing 𝑐𝑒𝑟𝑡, and the principal owning the domain 𝑑 is
honest, then the owner of 𝑑 created an ACME order for the domains
𝐷 and owns the private key to 𝑎𝑐𝑐_𝑝𝑢𝑏_𝑘𝑒𝑦.
Client-Side Integrity. The client-side integrity property states
that whenever the client stores a certificate (issued by an arbitrary,
potentially dishonest server), then this certificate has been issued
for the same set of domains that the client requested earlier.
Theorem 3 (Client-Side Integrity). For all possible global
traces 𝑡 of the DY★ model of ACME, with 𝑐 being a principal (an
ACME client), 𝐷 being a set of domains, and 𝑐𝑒𝑟𝑡 some certificate
issued for the set 𝐷, if 𝑐 stores the certificate 𝑐𝑒𝑟𝑡 in its state, then 𝑐
previously created an ACME order object for the domains 𝐷.
Similarly to the secure binding property, we specify both properties
as lemmas in DY★ and define suitable predicates, including those
for valid traces, and prove these properties.
7.3 Proof Effort
For proving the security properties presented in the previous sec-
tions, we added 5,191 lines of proof-related code, which roughly
corresponds to the number of functional lines of code of the ACME
model (see Table 1). This number includes the proofs that follow
from the trace invariants and all local proofs (see also Section 7.1,
where we describe how local proofs are used to prove the secure
binding theorem). Overall, the verification of the complete ACME
model (including the typecheck of the DY★ model) takes 67 minutes
using an off-the-shelf machine. We highlight again that the verifi-
cation is done modularly, and on average, each module is verified
in less than 1.5 minutes. We estimate that the ACME analysis (cre-
ating the ACME model and proving the security properties) took
several person-months, a large portion of which was for reading
and transcribing the standard. We refer the reader to Section 9 for
a comparison of our analysis to prior ACME analyses.
8 INTEROPERABLE IMPLEMENTATION
In the symbolic execution tests as described in Section 6.3, we
confirmed our model to be internally consistent, i.e., our modeled
ACME client and server are able to finish a protocol run when
communicating to each other. While this provides some confidence
in the correctness of our model within itself, we could still have
modeled the ACME specification slightly incorrectly. So in a second
step, we use our approach for interoperability (see Section 3.3)
and augment our model with an (unverified) wrapper library to
be able to connect our implementation to the real world. Here,
we illustrate that our ACME client is indeed interoperable with a
real-world server. To this end, we have our client run the ACME
protocol with several different ACME servers, including pebble [44],
an ACME server developed specifically for client compliance testing,
as well as Let’s Encrypt’s staging and production servers based on
Boulder [42], and show that all of them indeed issue certificates to
our client.
As presented in Section 3.3, this wrapper library is written in
OCaml and uses the ACME client APIs outlined in Section 6.2.
On a technical level, the ACME model and the underlying DY★
framework are compiled from F★ to an OCaml library, against
which we link our wrapper library. As with the ACME model itself,
we provide the wrapper library and necessary configuration in our
supplementary material [10].
Running the resulting interoperable client implementation with
real-world ACME servers allowed us to find a bug in our model that
did not surface in the symbolic execution tests from Section 6.3. As
presented in Section 6.1, an ACME order object (in our model as well
as in the specification) contains several sequences, e.g., a sequence
of authorization URLs associated with the respective order object.
The ACME specification does not require ACME servers to retain
the order of elements in these sequences when including them in
a response. Our initial client model, however, implicitly assumed
to receive these sequences exactly as sent in the request. This bug
did not surface in the symbolic execution tests, as our server model
just reflects them in responses. But the pebble ACME (compliance
testing) server [44] permutates them on purpose and thus leads us
to the error. In addition to being quite subtle, this modeling bug
only shows when ordering a certificate for more than one domain.
Therefore, we emphasize the value of an executable model and
using that ability to build confidence in the model’s correctness.
9 RELATED WORK
As mentioned before, early drafts of ACME have been analyzed
before. We will discuss these works as well as other work that
focuses on public key infrastructures and the verification of crypto
protocols in general.
Prior Analyses of ACME. Two prior works present formal anal-
ysis results for early drafts of the ACME standard. Bhargavan et
al. [15] model domain authentication protocols of ACME draft 00
in ProVerif and analyze it for an authentication property similar
to secure binding, in a symbolic cryptographic model without key
substitution attacks. They introduce a notion of strong identifier
channels for HTTP and DNS authentication (corresponding to Au-
thenticated Send in Section 3.1) and show these mechanisms are
strictly stronger than Email-based authentication (which is not sup-
ported anymore in the current standard). Jackson et al. [36] analyze
the DNS-based domain authentication protocol in ACME drafts 00
and 02 in Tamarin. They show attacks on draft 00 if the signature
scheme is vulnerable to key substitution attacks. Our treatment of
no-CEO and no-DEO (see Section 3.2) key substitution is inspired
by their work.
Session 10B: Crypto and Protocol Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2612Both these prior works only model a small cryptographic core of
the ACME protocol and focus on a narrow class of attacks, ignoring
important RFC details like message formats and state management.
The Tamarin model of Jackson et al. has ~100 lines of code, while
the one of Bhargavan et al. has ~280 lines.
In contrast, we build the first in-depth model for the published
ACME standard [5]. We account for certificates that cover multiple
domains (which requires reasoning on unbounded data structures),
while prior analyses only model a single domain. We also model
JWS signatures and long-running sessions where domain lists are
iteratively and asynchronously processed for domain verification,
while prior analyses do not. Our specification is detailed enough
to be seen as a reference implementation; it is both symbolically
and concretely executable, and our ACME client interoperates with
other ACME servers. Our security proofs account both for the high-
level cryptographic attacks considered in prior work as well as low-
level flaws in the message processing algorithms (see Section 5).
This level of precision and rigor is reflected in the size of our verified
ACME implementation (cf. Table 1).
Analyses of Public Key Infrastructures (PKI). Several prior
works present novel PKI designs with security analyses in a variety
of models. We refer the reader to [38] for a formal comparison
between some of these proposals. ARPKI [7] and DTKI [56] seek to
reduce the trust in certification authorities by using multiple CA
servers and a public log. LocalPKI [27] is an IoT-friendly PKI design
that allows local authorities to validate users and issues certificates.
All three of these protocols were analyzed using the Tamarin prover,
but none of the analyses focused on domain authentication, which
is the main goal of ACME.
Verification of Crypto Protocol Standards. In recent years, sym-
bolic and computational verification tools have been used to verify
multiple real-world protocols (see [4] for a survey of the state-of-
the-art). For example, the TLS 1.3 protocol standard was comprehen-
sively analyzed using Tamarin, ProVerif, CryptoVerif, and F★ [14,
22, 24]. The OAuth and OpenID standards were verified using a
symbolic pen-and-paper model [28, 30, 31] as well as Tamarin [34].
This paper adds ACME to the list of formally analyzed protocol
standards and closes an important gap in the security analysis of
the web PKI, which is implicitly relied on by protocols like TLS.
One of the by far largest mechanized formal verification efforts
of cryptographic protocols to date is the analysis of the 3,600 line
miTLS implementation, which required 2,050 lines of type anno-
tations for F7, as well as a large cryptographic proof that includes
both manual arguments and a 3,000 line EasyCrypt proof [18]. In
comparison, our analysis of ACME comprises more than 10,000
lines of functional and proof code, not counting the code of the
DY★ framework itself (see Table 1), again indicating the exceptional
level of detail of our analysis and the scalability of our approach
compared to other works in the domain of protocol analysis.
10 CONCLUSION
In this work, we have verified the security of the ACME standard [5]
in an unprecedented level of detail. Our executable model of ACME
in F★ carefully accounts for all high-level protocol flows, includ-
ing arbitrary recursive interleavings of multiple asynchronous sub-