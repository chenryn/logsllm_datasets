# IE11 CVE-2017-0037 Type Confusion分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
最近在用`WinAFL`，看到作者`ifratric`在2017年利用`winafl`发现了[CVE-2017-0037](https://bugs.chromium.org/p/project-zero/issues/detail?id=1011)这个洞， 类型是`type
confusion`，没分析过这种类型的洞，并且在分析恶意代码时遇到过，但是并没有分析具体原因，所以就自己动手复现了一下，详细的捋了一下整个流程
## 环境搭建
浏览器环境
开启页堆
为了便于分析并在分析中节省时间，建议将`symbol path`设置在共享目录里，附加过后设置一个快照
## 漏洞分析
首先利用`ifratric`给出的`PoC`进行测试
结果
崩溃调用栈
分析`HandleColumnBreakOnColumnSpanningElement`函数
    signed int __fastcall Layout::MultiColumnBoxBuilder::HandleColumnBreakOnColumnSpanningElement(Layout::ContainerBoxBuilder *a1, Tree::ANode *a2, int a3)
    {
      int v3; // esi
      Layout::ContainerBoxBuilder *v4; // eax
      int v5; // ecx
      int v6; // ecx
      bool v7; // zf
      Layout::ContainerBoxBuilder *v8; // ebx
      int v9; // eax
      Tree::ANode *v10; // eax
      Tree::ANode *v11; // edi
      char v13; // al
      int v14; // eax
      int v15; // eax
      _DWORD *v16; // ebx
      _DWORD *v17; // eax
      char v18; // al
      int v19; // eax
      int v20; // [esp+0h] [ebp-2Ch]
      char v21; // [esp+Ch] [ebp-20h]
      Tree::ANode *v22; // [esp+14h] [ebp-18h]
      _DWORD *v23; // [esp+18h] [ebp-14h]
      int *v24; // [esp+1Ch] [ebp-10h]
      int v25; // [esp+20h] [ebp-Ch]
      Layout::ContainerBoxBuilder *v26; // [esp+24h] [ebp-8h]
      bool v27; // [esp+2Bh] [ebp-1h]
      v22 = a2;
      v3 = 0;
      v4 = Layout::ContainerBoxBuilder::ParentContainerBoxBuilder(a1);
      v6 = *(_DWORD *)(v5 + 16);
      v7 = *(_DWORD *)(v6 + 136) == 0;
      v25 = *(_DWORD *)(v6 + 12);
      v27 = v7;
      while ( 1 )
      {
        v8 = v4;
        v26 = v4;
        if ( !v4 )
          return 0;
        if ( Layout::LayoutBoxBuilder::IsMultiColumnBoxBuilder(v4) )
        {
          if ( v8 )
          {
            v9 = *((_DWORD *)v8 + 131);
            if ( v9 == 1 || v9 == 2 || v9 == 4 )
            {
              v10 = Layout::MultiColumnBoxBuilder::LastColumnSpanningElement(v8);
              v11 = v22;
              if ( v10 == v22 || v10 && Tree::ANode::StartsBefore(v22, v10) )
                return 2;
              if ( !(*((_BYTE *)v8 + 576) & 1) )
              {
                SP::operator=((char *)v8 + 560, v11);
                *((_DWORD *)v8 + 141) = v3 + a3;
                *((_BYTE *)v8 + 568) ^= (v27 ^ *((_BYTE *)v8 + 568)) & 1;
                return 1;
              }
            }
          }
          return 0;
        }
        v13 = (*(int (__thiscall **)(Layout::ContainerBoxBuilder *))(*(_DWORD *)v8 + 84))(v26);
        if ( &v20 != &v20 )
          __fastfail(4u);
        if ( v13 )
        {
          v14 = (*(int (__thiscall **)(Layout::ContainerBoxBuilder *, char *))(*(_DWORD *)v26 + 88))(v26, &v21);
          if ( &v20 != &v20 )
            __fastfail(4u);
          v3 += *(_DWORD *)(v14 + 4);
        }
        if ( v27 )
        {
          v15 = *((_DWORD *)v26 + 4);               // TableGridBoxBuilder
          v16 = *(_DWORD **)(v15 + 136);            // TableGridBox
          v23 = *(_DWORD **)(v15 + 136);
          if ( !*(_DWORD *)Layout::Patchable>::Readable(v23) )
            goto LABEL_35;
          v17 = (_DWORD *)Layout::Patchable>::Readable(v16);
          v24 = &v20;
          v18 = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)*v17 + 0x1A4))(*v17);
          if ( v24 != &v20 )
            __fastfail(4u);
          if ( v18
            && (v19 = Layout::Patchable>::Readable(v23),
                *(_DWORD *)(*(_DWORD *)v19 + 12) == v25) )
          {
    LABEL_35:
            v27 = 1;
          }
          else
          {
            v27 = 0;
          }
        }
        v25 = *(_DWORD *)(*((_DWORD *)v26 + 4) + 12);
        v4 = Layout::ContainerBoxBuilder::ParentContainerBoxBuilder(v26);
      }
    }
可以发现通过函数`Layout::ContainerBoxBuilder::ParentContainerBoxBuilder`，循环处理元素，为了清楚到底是怎么处理的，将所有的处理结果打印处理出来
    // mshtml.dll x86
    bu 663DBF61 ".printf "###BeforeWhile=> 参数(ecx): "; dps ecx L1; .printf "                 返回值(ecx+0x14): "; dps poi(ecx+0x14) L1;g"
    bu 6669FCE4 ".printf "###InWhile=> 参数(ecx): "; dps ecx L1; .printf "             返回值(ecx+0x14): "; dps poi(ecx+0x14) L1;g"
结果
最后一次的返回值，是一个`TableGridBoxBuilder`类型，在转换中出错
可以看到最终出错是在将`TableGridBoxBuilder`转换到`SGridBoxItem`的过程
     v15 = *((_DWORD *)v26 + 4);    // 获得TableGridBoxBuilder对象
     v16 = *(_DWORD **)(v15 + 136); // TableGridBox
     v23 = *(_DWORD **)(v15 + 136);
     if ( !*(_DWORD *)Layout::Patchable>::Readable(v23) ) // 转换出错
既然出错在`TableGridBoxBuilder`对象上，那就来看看`TableGridBoxBuilder`对象是如何生成的，其生成涉及到三个主要函数
     Layout::TableGridBoxBuilder::TableGridBoxBuilder
     Layout::TableGridBoxBuilder::Constructor
     Layout::TableGridBoxBuilder::CreateTableGridBoxBuilder
首先其构造函数
    Layout::TableGridBox *__thiscall Layout::TableGridBox::TableGridBox(Layout::TableGridBox *this, struct Tree::ElementNode *a2, struct Layout::ContainerBoxBuilder *a3, bool a4, bool a5, struct Layout::ScrollState *a6)
    {
      Layout::TableGridBox *v6; // esi
      _DWORD *v7; // edi
      int v8; // eax
      Layout::TableGridBox *v9; // esi
      char v11; // [esp+Ch] [ebp-10h]
      Layout::TableGridBox *v12; // [esp+18h] [ebp-4h]
      v6 = this;
      v12 = this;
      Layout::ContainerBox::ContainerBox(this, a2, a3, a4, a5, a6);
      *(_DWORD *)v6 = &Layout::TableGridBox::`vftable';
      v7 = (_DWORD *)((char *)v6 + 164);
      *((_DWORD *)v6 + 34) = 0;   // readable 读取对象(34*4=136)
      *((_DWORD *)v6 + 35) = 0;      // readable 返回对象
      *((_DWORD *)v6 + 36) = 0;
      *((_DWORD *)v6 + 37) = 0;
      *((_DWORD *)v6 + 38) = 0;
      *((_DWORD *)v6 + 39) = 0;
      *((_DWORD *)v6 + 40) = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
      v7[3] = 0;
      *((_DWORD *)v6 + 47) = 0;
      *((_DWORD *)v6 + 48) = 0;
      *((_DWORD *)v6 + 49) = 0;
      *((_DWORD *)v6 + 50) = 0;
      *((_DWORD *)v6 + 51) = 0;
      *((_DWORD *)v6 + 52) = 0;
      *((_DWORD *)v6 + 53) = 0;
      *v7 = Math::SRectangle::Empty;
      *((_DWORD *)v6 + 42) = *(&Math::SRectangle::Empty + 1);
      *((_DWORD *)v6 + 43) = *(&Math::SRectangle::Empty + 2);
      *((_DWORD *)v6 + 44) = *(&Math::SRectangle::Empty + 3);
      *((_BYTE *)v6 + 216) &= 0xFEu;
      *((_DWORD *)v6 + 45) = 0;
      *((_DWORD *)v6 + 46) = 0;
      v8 = Layout::LayoutBox::ComputedStyle(v6, &v11);