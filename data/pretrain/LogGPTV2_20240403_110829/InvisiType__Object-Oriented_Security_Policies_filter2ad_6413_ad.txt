get raw body, we deﬁne an attribute accessingACL
to record the context whether getACL is currently execut-
ing for that page. get raw body is redeﬁned so that it
will throw an exception if it is invoked, not by getACL, on
a protected object.
Every page is guarded by an AccessControlPolicy object
when it is created. In the constructor init of the Page
class, the page instance self is demoted with its own in-
stance of the AccessControlPolicy class. An object
class Page(object):
def get_raw_body(self):
# returns the raw body of the text page
...
def getACL(self, request):
...
acl = self.parseACL()
...
return acl
class AccessControlList(object):
def may(self, request, name, dowhat):
# returns True if user with name has
# access to read, write, delete, etc
...
Figure 12. MoinMoin’s Page class and Ac-
cessControlList class
is promoted back to an ordinary page when the access con-
trol check is performed successfully by the may method.
We have so far described how we enforce access con-
trol on read accesses; similar policies can be deﬁned to pro-
tect the write accesses. We were able to detect all of Moin-
Moin’s known access control bugs. More importantly, our
system can guard against all the access control errors in the
hundreds of existing MoinMoin plugins, without requiring
any code changes be made.
6.4.4 Comparison With Previous Work
Krohn et al. previously attempted to enhance MoinMoin’s
security using Flume [17]. Flume’s approach is based on
OS-level information ﬂow control; they extracted the login
module and made it a separate process. However, Flume
does not address cross-site scripting vulnerabilities since
it is not possible with OS-level information ﬂow control.
Flume cannot be applied to taint tracking which needs ﬁne-
grained information ﬂow control. Moreover, their approach
requires more effort than ours. We used less than 150 lines
of Python code to deﬁne and apply the two policies, but
Flume required modifying 1,000 lines of Python code and
adding 1,000 extra lines of C++ code. We also modiﬁed the
Python interpreter by adding about 2,000 lines of RPython
code, but this requires signiﬁcantly less effort than modify-
ing the operating system as in Flume.
7 Related Work
There has been much interest recently in using informa-
tion ﬂow control for improving security on software sys-
class AccessControlPolicy(InvisiType):
def __init__(self):
self.accessingACL = False
def get_raw_body(method, self):
if not self.accessingACL:
raise Exception("Illegal read access")
# invoking get_raw_body method
# in Page class
return method(self)
def getACL(method, self):
self.accessingACL = True
# invoking getACL method in Page class
result = method(self)
self.accessingACL = False
return result
class Page(object):
def __init__(self, request, pagename,
**kws):
...
demote(self, AccessControlPolicy)
class AccessControlList(object):
def may(self, request, name, dowhat):
# after authorized to read the page,
# we promote the page object back.
promote(self.page, AccessControlPolicy)
Figure 13. Enforcing access control checking
for wiki pages
tems. Asbestos [6] and Histar [37] incorporated Decentral-
ized Information Flow Control (DIFC) into new operating
systems. Flume [17] implemented DIFC in the Linux op-
erating system. These projects control information ﬂow be-
tween OS entities such as processes and threads. InvisiType
enables applying security policies at a ﬁner-grained level.
For instance, TaintPolicy introduced in this paper sup-
ports information ﬂow control within a process allowing en-
forcement of the policy on each object in memory.
Myers and Liskov introduced JFlow and its successor
JIF, which are Java-based programming languages with
DIFC support [24, 25].
JIF allows labeling variables to
specify access permissions, and enforces it with static anal-
ysis, thus supporting information ﬂow control. When prop-
erly used, JIF guarantees that there is no information leak-
age in an application written in JIF while InvisiType can-
not give a similar guarantee. However, to take advantage
of it, legacy applications need to be re-written using JIF.
Our scheme allows developers to enforce policies to legacy
applications with minimal modiﬁcations; our experience
with MoinMoin shows that the amount of effort is relatively
small.
Guard interface and GuardedObject class are used to en-
force access control policy in Java security architecture [9].
An instance of GuardedObject embeds an object to be pro-
tected and a Guard object. The Guard object represents an
access control policy for the protected object. When the
protected object is requested to be retrieved, the Guard ob-
ject is called upon to check against the access control policy.
This mechanism can enforce access control on individual
objects like InvisiType. However, it cannot describe secu-
rity policies like TaintPolicy described in Section 2.2,
where code needs to be injected into speciﬁc methods or
operators.
Sekar et al. introduced the Model-Carrying Code (MCC)
approach, where a security model is extracted from an ap-
plication and the user of the application determines a se-
curity policy that is compatible with the model [32]. At
runtime, MCC guarantees that the selected security policy
is not violated by the application. MCC uses the Behavior
Monitoring Speciﬁcation Language (BMSL) to capture im-
portant security events, such as entering and exiting system
calls, and describes security policies with regular expres-
sion patterns. Compared to their work, InvisiType adopts a
more object-oriented approach. InvisiType policies are de-
ﬁned as a class hence policies may inherit from other poli-
cies; policies are applied by overriding the default behaviors
of objects to be protected. As a result, InvisiType provides
better abstraction for security policies.
Bytecode re-writing is a technique that modiﬁes byte-
code at static time or at runtime. There has been much in-
terest in this area and there are many generic bytecode re-
writing frameworks [3, 4, 13]. Welch and Stroud used the
binary re-writing technique to enforce security policies on
mobile code [35]. However, our approach differs from those
works in that we implement security policies at the type sys-
tem layer. This makes the implementation relatively simple
and does not incur runtime translation overhead.
Aspect Oriented Programming (AOP) is a programming
paradigm which allows specifying cross-cutting concerns
across multiple classes [15]. There has been much research
in applying AOP to security [5, 33]. Although there are
similarities in that both allow modularizing security con-
cerns, our work differs from these approaches in signiﬁcant
ways. First, InvisiType is capable of enforcing policies on
individual objects, whereas AOP implementations only al-
low describing aspects for classes. This is essential for se-
curity policies like the taint policy, which requires safety
checks be added at object granularity. Also, InvisiType al-
lows the removal of policies when they are no longer nec-
essary. Thus, no overhead is incurred by unused security
policies. AOP implementations use bytecode re-writing and
even when policies are not used, there is the overhead of in-
serted bytecodes.
The Inlined Reference Monitor (IRM) approach is to
modify an application to include reference monitors, which
observe the execution of the application and take actions
on operations that violate a policy [7, 8]. Transactional
Memory Introspection (TMI) is a reference monitor archi-
tecture that builds on software transactional memory [2]. In
the TMI architecture, reference monitors are invoked when
security-related resources are accessed inside transactions.
InvisiType is a more object-oriented technique than IRM or
TMI since safety checks are encapsulated in policy classes
and the policies are applied to objects by changing the type
of the objects. However, our technique is only applicable to
object-oriented languages while IRM and TMI do not have
such a restriction.
Program Query Language (PQL) allows expressing
application-speciﬁc design rules and enforces them via
static and dynamic analysis [19]. Although PQL’s pattern-
matching based query is capable of expressing many
application-speciﬁc policies, some policies may not be eas-
ily expressed. PQL does not provide any means to examine
the value of an object. This makes it difﬁcult to express for
instance, MoinMoin access control checking policy. Also,
PQL only allows expressing error patterns; the only way
to enforce a good pattern is to query for every pattern that
violates the good pattern. Finally, PQL does not support
untrusted domain, which is necessary to enforce policies on
third-party code.
8 Conclusion
Third-party software is used across many software plat-
forms today. To help ensure that third-party software fol-
lows ﬁne-grained security policies, we have proposed a gen-
eral type extension concept to object-oriented programming
languages called InvisiType.
InvisiType allows safety policies to be encapsulated in an
object-oriented manner. The platform developers specify all
the safety checks in a class, and can selectively and dynam-
ically decide which object instances are to be subjected to
safety checks. No changes need to be made to third-party
software, at either the source or binary level.
The InvisiType runtime system uses the efﬁcient virtual
method dispatch mechanism to enforce the execution of
these safety checks on selected objects. Unlike source or bi-
nary level instrumentation, the overhead of safety checks is
applied only to those instances considered at risk. This im-
plementation makes it efﬁcient to provide low-level safety
checks, even at the granularity of individual attribute ac-
cesses. Thus, ﬁne-grained control like taint and access con-
trol can be provided efﬁciently with very little overhead.
Another contribution of this paper is in the security poli-
cies themselves. These policies are general and can be used
across many applications. We have demonstrated the use-
fulness of this approach by showing that we can secure
large, real-life applications with relative ease and low over-
head.
Acknowledgment
This paper is supported in part by the NSF POMI (Pro-
grammable Open Mobile Internet) 2020 Expedition Grant
No. 0832820, NSF Grant TRUST CCF-0424422, and a
Samsung scholarship. The authors thank John C. Mitchell,
Sudheendra Hangal, Michael Barrientos, Ben Dodson, and
Debangsu Sengupta for their help with the paper.
References
[1] C. Anley.
Advanced SQL injection in SQL server
http://www.nextgenss.com/papers/advanced
applications.
sql injection.pdf, 2002.
[2] A. Birgisson, M. Dhawan, U. Erlingsson, V. Ganapathy, and
L. Iftode. Enforcing authorization policies using transac-
In Proceedings of the 15th
tional memory introspection.
ACM Conference on Computer and Communications Secu-
rity, pages 223–234, Oct. 2008.
[3] S. Chiba.
Load-time structural reﬂection in Java.
In
Proceedings of the 14th European Conference on Object-
Oriented Programming, pages 313–336, June 2000.
[4] G. Cohen, J. Chase, and D. Kaminsky. Automatic pro-
In Proceedings of the
gram transformation with JOIE.
1998 USENIX Annual Technical Conference, pages 167–
178, June 1998.
[5] B. De Win, W. Joosen, and F. Piessens. Developing se-
cure applications through aspect-oriented programming. In
Proceedings of the 3rd International Conference on Aspect-
Oriented Software Development, pages 633–650, March
2004.
[6] P. Efstathopoulos, M. Krohn, S. VanDeBogart, C. Frey,
D. Ziegler, E. Kohler, D. Mazi`eres, F. Kaashoek, and
R. Morris. Labels and event processes in the asbestos op-
erating system. In Proceedings of the 20th ACM Symposium
on Operating Systems Principles, pages 17–30, Oct. 2005.
[7] U. Erlingsson. The inlined reference monitor approach to
security policy enforcement. PhD thesis, Cornell University,
Ithaca, New York, 2004.
[8] U. Erlingsson and F. Schneider. IRM enforcement of Java
stack inspection. In IEEE Symposium on Security and Pri-
vacy, pages 246–255, May 2000.
[9] L. Gong, G. Ellison, and M. Dageforde. Inside Java 2 plat-
form security: architecture, API design, and implementa-
tion. Addison-Wesley Professional, 2003.
[10] L. Gong, M. Mueller, H. Prafullchandra, and R. Schemers.
Going beyond the sandbox: an overview of the new security
In Proceed-
architecture in the Java development kit 1.2.
ings of the USENIX Symposium on Internet Technologies
and Systems, pages 103–112, Dec. 1997.
[28] A. Rigo and S. Pedroni. PyPy’s approach to virtual machine
construction. In Proceedings of the 21st Annual ACM SIG-
PLAN Conference on Object-Oriented Programming, Sys-
tems, Languages, and Applications Companion, pages 944–
953, Oct. 2006.
[29] Roundup cross-site scripting vulnerability. http://secunia.
com/advisories/9371.
[30] Roundup multiple vulnerabilities. http://secunia.com/ advi-
sories/29336.
[31] Paving the way to securing the Python interpreter.
http://tav.espians.com/paving-the-way-to-securing-the-
python-interpreter.html.
[32] R. Sekar, V. Venkatakrishnan, S. Basu, S. Bhatkar, and D. C.
DuVarney. Model-carrying code: a practical approach for
safe execution of untrusted applications. In Proceedings of
the 19th ACM Symposium on Operating Systems Principles,
pages 15–28, Oct. 2003.
[33] J. Viega, J. Bloch, and P. Chandra. Applying aspect-oriented
programming to security. Cutter IT Journal, 14(2):31–39,
2001.
[34] ViewCVS’s cross-site scripting bug. http://www.derkeiler.
com/Mailing-Lists/Securiteam/2002-05/0082.html.
[35] I. Welch. Using reﬂection as a mechanism for enforcing
security policies on compiled code. Journal of Computer
Security, 10(4):399–432, 2002.
[36] XML injection in PyBlosxom. http://seclists.org/ fulldisclo-
sure/2009/Feb/0084.html.
S. Boyd-Wickizer, E. Kohler,
Making information ﬂow explicit
and
[37] N. Zeldovich,
in
D. Mazieres.
In Proceedings of the 7th USENIX Symposium
HiStar.
on Operating Systems Design and Implementation, pages
263–278, Nov 2006.
[11] C. Gould, Z. Su, and P. Devanbu. Static checking of dynam-
In Pro-
ically generated queries in database applications.
ceedings of the 26th International Conference on Software
Engineering, pages 645–654, May 2004.
[12] W. G. J. Halfond and A. Orso. Amnesia: Analysis and Mon-
itoring for NEutralizing SQL-Injection Attacks. In Proceed-
ings of the 20th IEEE/ACM International Conference on Au-
tomated Software Engineering, pages 174–183, Nov. 2005.
[13] R. Keller and U. Hoelzle. Binary component adaptation. In
Proceedings of the 12th European Conference on Object-
Oriented Programming, pages 307–329, July 1998.
[14] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, J. Palm,
and W. Griswold. An overview of AspectJ. In Proceedings
of the 15th European Conference on Object-Oriented Pro-
gramming, pages 327–353, June 2001.
[15] G. Kiczales,
J. Lamping, A. Mendhekar, C. Maeda,
C. Lopes, J. JEAN-MARC Loingtier, and J. Irwin. Aspect-
oriented programming. In Proceedings of the 11th European
Conference on Object-Oriented Programming, pages 220–
242, June 1997.
[16] S. Kost. An introduction to SQL injection attacks for Oracle
developers. http://www.net-security.org/dl/articles/ Integri-
gyIntrotoSQLInjectionAttacks.pdf, 2004.
[17] M. Krohn, M. Brodsky, M. Kaashoek, and R. Morris. In-
formation ﬂow control for standard OS abstractions. In Pro-
ceedings of the 21st ACM SIGOPS Symposium on Operating
Systems Principles, pages 321–334, Oct. 2007.
[18] V. B. Livshits and M. S. Lam. Finding security vulnerabili-
ties in Java applications with static analysis. In Proceedings
of the 14th USENIX Security Symposium, pages 271–286,
Aug. 2005.
[19] M. Martin, B. Livshits, and M. S. Lam. Finding applica-
tion errors and security ﬂaws using PQL: a program query
In Proceedings of the 20th Annual ACM SIG-
language.
PLAN Conference on Object-Oriented Programming, Sys-
tems, Languages, and Applications, pages 365–383, Oct.
2005.
[20] H. Masuhara and K. Kawauchi. Dataﬂow pointcut in aspect-
oriented programming. In The 1st Asian Symposium on Pro-
gramming Languages and Systems, pages 105–121, Nov.
2003.
[21] MoinMoin. http://moinmo.in.
[22] MoinMoin macro market. http://moinmo.in/MacroMarket.
[23] MoinMoin security ﬁx announcements. http://moinmo.in/
SecurityFixes.
[24] A. Myers and B. Liskov. A decentralized model for informa-
tion ﬂow control. In Proceedings of the 16th ACM Sympo-
sium on Operating Systems Principles, pages 129–142, Oct.
1997.
[25] A. Myers and B. Liskov. Protecting privacy using the decen-
tralized label model. ACM Transactions on Software Engi-
neering and Methodology, 9(4):410–442, 2000.
[26] PyBlosxom contributed packages comments plugin multiple
cross-site scripting vulnerabilities. http://www. securityfo-
cus.com/bid/18292.
[27] PyPy performance benchmark. http://morepypy.blogspot.
com/2008/05/general-performance-improvements.html.