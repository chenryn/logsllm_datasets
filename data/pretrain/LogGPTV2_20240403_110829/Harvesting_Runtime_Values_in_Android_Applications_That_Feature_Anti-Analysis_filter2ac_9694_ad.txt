161 ( 2
157
161 )
14
23 ( 8
23 )
15
24 ( 8
24 )
35 ( 12
19
35 )
22
34 ( 8
34 )
16
24 ( 4
24 )
3 ( 0
3
3 )
SUMMARY
53 ( 10
37
53 )
7 ( 1
5
7 )
8 ( 2
6
8 )
8 ( 0
8
8 )
86
136 ( 34
136 )
600
641 ( 5
641 )
7 ( 4
3
7 )
745
860 ( 56
860 )
constant
non-constant
#(extracted non-constant)
#(all non-constant) + #(all constant)
(
#(extracted constant)
#(all non-constant) + #(all constant)
)
TABLE I: Recall-Evaluation of HARVESTER. Green slices: amount of logging points with non-constant values where a dynamic
analysis is necessary for value extraction. Red slices: amount of missing logging points. Grey slices: amount of logging points
with constant values where no static/dynamic analysis is necessary. Fraction next to circle: fraction of successfully extracted
logging points for non-constant values. Fraction in brackets: fraction of successfully extracted logging points for constant values.
for automatically extracting values of interest from malicious
applications.
We
Static Analysis:
compared HARVESTER with
SAAF [17], a static approach for identifying parameter values
based on a backward slicing approach starting from a method
call. This method is similar to the static backward-analysis
part in HARVESTER but uses traditional slicing. HARVESTER
was evaluated on the same 6,100 malware samples as SAAF
was evaluated (taken from MobileSandbox [32]). The logging
points for both tools were the number and the corresponding
message of text messages. The results for SAAF show that
the tool has some issues with certain string operations such as
concatenation. Instead of the concatenated string, SAAF reports
the two distinct operands. This gives only partial insight into the
behavior of the application. In some cases, HARVESTER found
more fragments of the target telephone number as SAAF.2
In contrast, HARVESTER extracts the ﬁnal, complete SMS
numbers for all of the samples, even in cases in which SAAF
did not yield any data. Furthermore, SAAF does not support
extracting the texts of the SMS messages being sent since they
are usually not string constants, but built through concatenation
and string transformation. Due to its static nature, opposed
2e.g. number 1065-5021-80133 in sample with MD5 hash
b238628ff1263c0cd3f0c03e7be53bfd
8
to HARVESTER, SAAF cannot handle reﬂective calls with
obfuscated target strings either. We further evaluated SAAF
on current Android malware taken from Table I including the
most sophisticated Android malware families: Obad, Pincer,
Ssucl and Dougalek. SAAF was conﬁgured to extract values
of interest for reﬂective method calls, SMS numbers and SMS
messages. The tool was not able to extract any value of interest
for Obad, Pincer and Ssucl. For Dougalek, SAAF found the
same SMS numbers as HARVESTER, but was not able to extract
SMS messages. The SMS numbers can be extracted in a static
way (static backward slicing) since no obfuscation is applied to
the constant string values. In summary, this shows that hybrid
approaches such as HARVESTER can handle current malware
samples more effectively than purely static ones like SAAF.
Dynamic Analysis:
Extracting values of interest can also
be achieved by executing the app and applying code coverage
techniques [33]–[37] that try to reach the statement of the
logging point. To evaluate HARVESTER on dynamic approaches,
we randomly chose a set of 150 samples from 18 malware
families from the Malware Genome Project [38]. We compared
HARVESTER’s recall with 5 different state-of-the-art testing-
based approaches that were publicly available to us and
could be setup with reasonable effort: Google’s Monkey [33],
PUMA [35], AndroidHooker [39], DynoDroid [34] and a naive
approach that starts the app, waits for 10 seconds and quits
the app. Unfortunately, we were not able to test Acteve [37]
and SwiftHand [36] on our samples due to tool-internal issues.
The goal was to ﬁnd the telephone numbers to which SMS
messages are sent (all 150 samples contained at least one
API call for sending SMS messages). To count how many
logging points were reached by the dynamic testing tools, we
instrumented the malware samples’ bytecode to create a log
entry directly before sending the message. After running the
testing tools, we evaluated the log output taken from the Logcat
tool. All tests were carried out on an Android 4.1 emulator
(API version 16).
Table II shows that HARVESTER’s recall is around four
to six times higher than the one of current state-of-the-art
dynamic analysis approaches. One reason for the particularly
poor recall of the existing dynamic testing tools are emulator-
detection techniques. These checks prevent the tools (which
run the potentially malicious apps on an emulator for security
reasons [32], [40]) from ever reaching a logging point in most
malware samples.
Approaches
Simply open and close app
Monkey
PUMA
AndroidHooker
Dynodroid
HARVESTER
total logging-points covered
14.1%
15.6%
17.3%
16.2%
22.3%
83.4%
TABLE II: Measuring Recall of HARVESTER in Comparison
to State-Of-The-Art Dynamic Testing Tools
As an example for such an emulator check, Listing 4 shows
malicious code extracted from the “DogWars” application.
It accesses the user’s contact database in line 3. Only if
contacts are available on the phone (line 5), the app sends
out the premium SMS message (line 11). When a dynamic tool
9
runs the app on an emulator, the contact database is usually
empty and the logging point for sending SMS messages is
thus never executed. As our results conﬁrm, such behavior
is common among modern malware applications. Since such
checks, however, do not inﬂuence the target telephone number,
HARVESTER simply removes the respective condition and
correctly retrieves the number 73822. Note that the taunting
text messages (line 9) get sent to every telephone number in
the user’s address book and are thus data-dependent on the
environment (i.e., the contact database). Thus no ﬁxed target
phone number can be retrieved by any tool. In such cases,
HARVESTER reports a constant string with information about
the source (e.g., contact database information). Many malicious
applications such as the GoldDream, BaseBridge, and BgServ
malware families, as well as the DogWars app, perform their
malicious activities in a background service that is started
only after the phone is rebooted. Apps from the GPSSMSSpy
family act on incoming SMS messages. To obtain the respective
runtime values, traditional dynamic approaches must generate
such external events and restart the phone. HARVESTER instead
directly executes the code slices containing the logging points
and thus does not need to emulate these events.
To overcome simple environment checks, Android-
Hooker [39] and Dynodroid [34] ﬁrst prepare the emulator with
fake “personal user data” such as contacts. Only afterwards, they
install the application and exercise it. Both also send external
events such as incoming SMS messages and AndroidHooker
even reboots the emulator during the test to trigger actions that
only happen at boot time. AndroidHooker was able to reveal
the premium SMS message in the DogWars app, but does not
solve the code-coverage problem in general. For instance, it
still fails if the malicious code is only executed after receiving
a command from a remote server, such as in the GoldDream
malware family. Due to such problems, AndroidHooker only
covered 16.2% of all logging points. In only 10.67% of all apps
it covered any logging point at all—a marginal improvement
over running Monkey as is. In summary, these results show
that current state-of-the art testing tools are not sufﬁcient
for revealing malicious behavior of current state-of-the art
malicious applications. HARVESTER succeeds in all cases, as
the conditional checking for the server’s command is not part of
the slice that HARVESTER computes, and the code containing
the logging point is executed directly and unconditionally.
All in all, dynamic tools only reach a small fraction of
all logging points for these malware samples. It is worth
mentioning that a naive approach that starts an app, waits
for ten seconds and closes the app, produces similar results
public void onStart(Intent intent, int i)
ContentResolver cr = getContentResolver();
Cursor contacts = cr.query(CONTENT_URI, null, ...);
SmsManager sms = SmsManager.getDefault();
if (contacts.getCount() > 0) {
1
2
3
4
5
6
7
8
9
do {
int colIdx = contacts.getColumnIndex("data1");
String telNo = contacts.getString(colIdx);
sms.sendTextMessage(telNo, null, "I take
pleasure in hurting small animals, just thought you
should know that", ...);
} while (contacts.moveToNext());
sms.sendTextMessage("73822", null, "text", ...);
10
11
12
13 }
Listing 4: “DogWars” Game from Malware Genome Project
}
(ﬁrst line in table) as Google’s Monkey approach. HARVESTER,
on the other hand, covers 83.4% of all logging points and thus
shows a much higher recall.
RQ3: How efﬁcient is HARVESTER?: App Stores such as the
Google Play Store receive thousands of new or updated Android
apps per day [41] which they need to check for malicious
behavior. Therefore, one requires fast tools which scale to the
size of the market. We tested HARVESTER on our full set
of 16,799 malware samples (which includes all samples from
the previous sections). We conﬁgured HARVESTER with two
logging-points (SMS phone numbers and the respective text
messages) for each sending SMS API call included in the app’s
bytecode. We focused on SMS numbers and messages since
SMS trojans are among the most sophisticated malware apps
today [15]. With HARVESTER, one can effectively ﬁnd the
real values for phone numbers and text messages and compare
them to known blacklists or apply existing ﬁlters for identifying
scamming malware.
The performance evaluation reported in this section was run
on a compute server with 64 Intel Xeon E5-4650 cores running
Ubuntu Linux 14.04 with Oracle’s Java HotSpot 64-Bit Server
VM version 1.7.0 and a maximum heap size of 20 GB to avoid
intermediate garbage collection. We used the Android ARM
emulator in version 22.6.0. On average, HARVESTER took about
2.5 minutes per application. This shows that HARVESTER can
be used for mass analyses and delivers results very quickly.
On average over all slices in all our samples, HARVESTER had
to try different values for 0.21 EXECUTOR ﬂags per slice. The
highest average number of EXECUTOR ﬂags we encountered per
slice in a single app was 1.31.
RQ4: Which interesting values does HARVESTER reveal?:
We next report interesting values that HARVESTER extracted
from malware applications. Our analysis is based on our full
sample set of 16,799 malware apps. Some of these results
have already been found through earlier manual investigation
by security experts. However, to the best of our knowledge,
HARVESTER is the ﬁrst fully-automated approach that is able
to reveal all of these ﬁndings. HARVESTER found a lot of
cases where malicious applications used reﬂective method
calls to hide sensitive method calls such as “getDeviceId” or
“sendTextMessage”. In some applications even the reﬂective
calls themselves were again called via reﬂection to produce
a multi-stage obfuscation. HARVESTER is able to extract the
called methods in all of our samples.
HARVESTER also discovered that current SMS trojans
are far more sophisticated then just sending a hard-coded
number of premium-rate SMS messages per time frame or upon
certain actions (e.g., every time the victim opens the malicious
application). Some SMS trojans store the number of messages
sent in SharedPreferences, a key-value storage provided
by the Android framework. HARVESTER uncovers many keys
like “SENDED SMS COUNTER KEY” or “sendCount” used
for this purpose. Some samples even use keys like “cost” for
storing the total amount of money stolen so far. Based on these
values, the malware decides when the next premium-rate SMS
message is sent. We also found applications that contact a
command-and-control (C&C) server via SMS messages. Since
the same commands reappear in many samples, they also could
be used for blacklisting.
Some benign applications encrypt sensitive data such as
chat conversations, or credit card information, before storing
it locally on the phone. This encryption, however, is rendered
useless if the same hard-coded symmetric key is used for all
installations of the app. Interestingly, this is the case in the
popular WhatsApp messenger app [13]. Since the encrypted
database is stored on the SD card, malicious applications can
easily access it. Once the key is known, it can be decrypted
and leaked. HARVESTER can fully automatically extract the
WhatsApp encryption key by obtaining the values passed to
the constructor of the SecretKeySpec class.
A more detailed overview of HARVESTER’s ﬁndings can
be found in our technical report [42].
VII. CASE-STUDIES
While the previous section focused on how well HAR-
VESTER can extract runtime values from (obfuscated) Android
applications, we report on two case studies that assess how
existing off-the-shelf static and dynamic analysis tools can
beneﬁt from a lightweight
integration with HARVESTER.
Figure 4 shows which step of our approach can be further
used for the improvement of static and dynamic analysis tools.
Improvements to Static Analysis Tools
For the ﬁrst case study, we used HARVESTER to inject
information about discovered reﬂective calls into the original
app’s bytecode (phase C in Figure 4). We then compared the
recall of the FlowDroid [4] static data ﬂow tracker on real-world
malware applications with and without this call information. For
this comparison, we chose the Fakeinstaller.AH [2] malware
family 3 which is known for leaking private data, but also for its
massive use of reﬂection to hide calls to sensitive API methods.
On the original obfuscated sample, FlowDroid detected only
9 distinct leaks. After using HARVESTER with the option of
replacing reﬂective calls with their respective actual callees,
FlowDroid detected 26 privacy leaks, almost three times as
many as before. These 26 leaks included stealing the IMEI or
phone number via SMS.
To evaluate in more detail how HARVESTER improves the
precision and recall of existing tools on obfuscated applications,
we tested FlowDroid on ten randomly-picked applications from
DroidBench [4] which we obfuscated using DexGuard [16].
All API method calls were replaced with reﬂective calls on
encrypted strings. Table III compares the detection rate of
FlowDroid on the obfuscated applications without applying
HARVESTER (BEFORE - column 2 and 4) to the respective
detection rates after applying HARVESTER (AFTER - column
3 and 5). These results show that FlowDroid was initially
not able to detect any leak in the obfuscated apps. After
deobfuscating the apps with HARVESTER through runtime-
value injection (see Section V-C), FlowDroid found the same
leaks as in the unobfuscated original version. The enhanced