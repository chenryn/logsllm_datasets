friendlier towards real-time write requirements on M. Likewise, it
is possible to dynamically acquire and release the lock on M′ if it
is not entirely allocated to F.
4.3.2 Cpy-Lock & Writeback. To extend consistency until tr,
one can copy M′ back to M once computation of F(M′) is finished.
M is locked at te until tr. This way, R is consistent with M within
the intervals [ts, tc] and [te, tr]. Consequently, Mts = Mte, and M
remains constant between te and tr. Similar to Cpy-Lock, it might
be less constraining to use Dec-Lock during the copy and Inc-Lock
during the writeback, instead of All-Lock.
4.4 Variations on the Theme
We outline some extensions to previously discussed mechanisms.
4.4.1 Non-Sequential Functions. Some functions are not sequen-
tial, e.g., they might require input blocks to be used concurrently or
might reuse blocks in computation. Simple mechanisms (No-Lock
or All-Lock) are not affected by this. However, dynamic locking
techniques need to be amended.
A lock on Mi needs to be acquired the first time that block is
needed by F. Likewise, a lock on Mi can only be released when Mi
is no longer required. Consequently, in non-sequential functions,
locks may be acquired sooner, or released later, than in sequential
ts
ts
te
tr
ts
ts
te
tr
(a) Dec-Lock (Non-Sequential)
(b) Inc-Lock (Non-Sequential)
Figure 6: Locked memory in sliding mechanisms of Section 4.2 for
non-sequential F . Time goes from top to bottom, and M is repre-
sented horizontally. Locked portion of M is in gray.
functions. Figure 6 shows the effect on Dec-Lock and Inc-Lock. A
larger gray area indicates more restrictive operation for real-time
systems (for the same guarantees of consistency), though still less
restrictive than the All-Lock.
Dec-Lock requires the execution environment to be aware of
blocks that are no longer needed for the remainder of computation
of F. If that information is not available, locks cannot be released un-
til te, in which case Dec-Lock degenerates to All-Lock. Inc-Lock
does not have this issue (blocks are locked the first time they are
needed for F and not freed until te).
4.4.2 Adaptive Locking. Multiple mechanisms can be combined
in order to achieve alternative timings of consistency in computing
F. For example, to achieve consistency at tk (ts ≤ tk ≤ te), we
can combine the use of: (1) Inc-Lock on [M0, . . . , Mk], and (2)
Dec-Lock on [Mk , . . . , Mn]. Nevertheless, it is somewhat unclear
if and when such hybrids may be useful in practice. One potentially
relevant application is adaptive locking that aims to minimize impact
on other processes, especially, if the execution environment is aware
of other processes’ interrupt schedules.
4.4.3 Lazy Copy (Cpy-Lazy). Another variation of copy-based
4
mechanisms in Section 4.3 is Cpy-Lazy. It involves using All-Lock
on M with a lazy (or reactive) copy mechanism. When another pro-
cess interrupts F and, during its execution, wishes to write Mi, this
block is first copied to M′
. The lock on Mi is then released so the
i
process can write to it. The rationale for Cpy-Lazy is that copying
only what is, and when, necessary reduces overhead. This is partic-
ularly relevant when few blocks are likely to be modified during
computation of F. However, if many blocks are to be modified and
copied, cumulative overhead might exceed that of a single bulk
copy. Another consideration is whether there is OS or hardware
(e.g., MPU) support for the “interrupt-on-write” primitive required
to implement Cpy-Lazy.
4.5 Uninterruptibility vs. Locking
All mechanisms described above achieve consistency by temporar-
ily locking (parts of) memory. As mentioned earlier, uninterrupt-
ibility of computation of F (e.g., as in SMART [11]) also provides
consistency, though rigidly, i.e., for the interval [ts, te]. There are
other differences:
• Even when M is locked entirely or partially, other processes
can interrupt execution of F and modify memory outside of
M, as well as read all memory, including M. This does not
violate consistency of F’s result R.
• Whereas, if F is uninterruptible and the underlying hard-
ware platform is a single-CPU device, other processes are
completely blocked, regardless of whether M is locked.
• If multiple CPUs have shared memory access, uninterruptibil-
ity does not guarantee consistency, since a process running
on a CPU different from the one running F can modify M
concurrently.
• Locking is more flexible than uninterruptibility: while lock-
ing and unlocking of M can be dynamic and gradual (i.e.,
block-wise), execution of F is rigid: either it is interruptible or
not. For example, SMART provides consistency only because,
in a single-CPU device, uninterruptibility is equivalent to
All-Lock.
4.6 Memory Access Violations
If some process P′ tries to write to Mi which is currently locked by
process P running F, a memory access violation occurs (recall that
read access to M requires no extra handling). P and P′ might be run-
ning concurrently, on different CPUs, or P′ might have interrupted
P. There are several alternatives:
If P handles the situation, one possibility is to abort F and ter-
minate P. This approach is the most friendly with respect to P′
and other processes. However, it makes it easy for a malicious
4It can also be easily adapted to Inc-Lock and Dec-Lock.
process to starve P, i.e., prevent F from ever completing. Other-
wise, we can adopt the reactive Cpy-Lazy approach discussed in
Section 4.4.3. Alternatively, P′ can be aborted. Though this would
allow P (and thus F) to complete uninterrupted, it might be imprac-
tical in safety-critical scenarios. Another possibility is to stall P′
until Mi is unlocked. This approach is gentler, although it might
still be problematic, depending on how long P′ has to wait.
4.7 Inconsistency Detection
Another approach to enforce consistency is to detect inconsistency.
The memory M is not locked but instead a trigger is setup such
that the integrity measuring (e.g., attestation) process is alerted if
any changes occur to M during the computation of F. If any such
changes occur, the result produced is thus no longer consistent
throughout the computation. Depending on the strategy for dealing
with inconsistency, the computation of F can be stopped, continued,
or restarted. An implementation of this is presented and discussed
in Section 5.5.
The clear benefit of inconsistency detection over consistency
enforcement is that it does not interfere with the execution of other
processes. This is particularly relevant in time-critical applications
when availability must be maintained at all times. The drawback
is that consistency might not be guaranteed, depending on the
strategy used whenever an inconsistency is detected. This may lead
to attestation never terminating if inconsistencies are constantly
created, even by benign software.
5 IMPLEMENTATION & EVALUATION
Our prototype of temporal consistency mechanisms is realized
in the context of HYDRA hybrid RA architecture [10]. Below, we
overview HYDRA, discuss implementation details of each mecha-
nism and assess their performance on two popular low- to medium-
end development boards: I.MX6-SabreLite [9] and ODROID-XU4 [7].
Security considerations for our implemented mechanisms are dis-
cussed in Appendix B.
5.1 HYDRA
HYDRA implements a hybrid RA design for devices with a Memory
Management Unit (MMU). It builds upon the formally verified seL4
[18] microkernel, which ensures process memory isolation and
enforces access control to memory regions. Using the (mathemati-
cally) proven isolation features of seL4, access control rules can be
implemented in software and enforced by the microkernel. Note
that, in addition to the design of seL4 being formally verified and
ensured to guarantee isolation, seL4 software implementation is
also formally verified for conformance to the design.
HYDRA stores an attestation key (K) and attestation code (that
computes a MAC using K) in a writable memory region (e.g., flash
or RAM) and configures the system such that no other process, be-
sides the attestation process (PAtt ), can access this memory region.
Access control configuration in HYDRA also involves PAtt having
exclusive access to its thread control block as well as to memory
regions used for K-related computations. The latter ensures that K
is properly protected. To ensure uninterruptibility, HYDRA runs the
attestation process as the so-called initial user-space process with
the highest scheduling priority. As the initial user-space process in
seL4, PAtt is also initialized with capabilities to all memory pages.
Meanwhile, the rest of user-space processes are assigned lower
priorities and spawned by PAtt . Finally, hardware-enforced secure
boot feature is used to ensure integrity of seL4 itself and of PAtt
when the system is initialized.
5.2 Experimental Setup
Our implementation ensures temporal consistency by locking mem-
ory regions. It thus does not require the execution of PAtt to be
uninterruptible, unlike the original HYDRA implementation [10].
As a result, all user-space processes, including PAtt , have the same
priority in our implementation.
The microkernel executable is compiled from the unmodified
seL4 source code v4.0.0 [27]. Our user-space code is based on open-
source seL4 libraries [26], mostly for providing abstractions for
processes, memory management and virtual address space.
5.3 Experimental Results: Primitives
Our implementation of mechanisms discussed in Section 4 consists
of four primitives: LockPaдe, U nlockPaдe, CopyMem and MacMem.
In HYDRA (and in seL4, in general), locking and unlocking a memory
page can be invoked from user-space (by authorized processes) and
handled inside the kernel.
To lock a specific page, PAtt needs to perform three steps: (1)
revoke all capabilities associated with the page 5, (2) create a read-
only capability to the page, (3) assign the new capability to a
targeted process and map the page into the process’ virtual ad-
dress space. Unlocking can be done similarly by using a read-
and-write capability, instead of a read-only capability. In terms
of seL4 implementation, each of these primitives translates into
three function calls: seL4_CNode_Revoke(), seL4_CNode_Copy()
and seL4_ARCH_Paдe_Map().
Another parameter related to LockPaдe and U nlockPaдe is mem-
ory page size, which can differ depending on the underlying
instruction-set architecture. For instance, I.MX6-SabreLite, which
is based on the ARMv7-A architecture, only supports the follow-
ing page sizes: 4KB, 64KB, 1MB and 16MB. CopyMem performs a
memory copy between source and destination RAM locations. We
note that only Cpy-Lock requires this primitive. Finally, MacMem
performs a MAC computation over a memory range. MacMem is
implemented as a keyed hash using: BLAKE2S [31], AES256-CBC
based MAC [17] and HMAC-SHA256 [37] algorithms.
Figure 7 illustrates run-time of primitive operations on 16MB
of memory. Results show that page size heavily influences perfor-
mance of LockPaдe and U nlockPaдe: the larger the page size, the
faster it is to lock or unlock memory of the same size. This is ex-
pected, because larger pages result in fewer entries that need to
be modified in a page table. Run-time performance of CopyMem
and MacMem, however, remains almost unchanged, regardless of
page size. In addition, the same figure suggests that run-times of
CopyMem, LockPaдe and U nlockPaдe are relatively fast, compared
to that of MacMem. The first three primitives take at most 9% of
MacMem’s run-time.
5This step by default includes modifying the corresponding page table entry, clearing
a cache line and invalidating a TLB entry.
Figure 7: Performance of primitives with 16MB of memory on
I.MX6-SabreLite.
Finally, we evaluate and compare performance of the various
primitives on I.MX6-SabreLite running at 1.0GHz, and ODROID-
XU4 running at 2.1GHz. Figure 8 shows the results of this com-
parison. It shows that: (1) run-times of LockPaдe and U nlockPaдe
primitives are still roughly the same on both hardware platforms,
and (2) MacMem remains, by far, the most time-consuming primi-
tive.
5.4 Experimental Results: Mechanisms
We assess performance of five temporal consistency mechanisms –
No-Lock, All-Lock, Dec-Lock, Inc-Lock and Cpy-Lock – on the
SabreLite board. No-Lock is the baseline and it directly translates
into the MacMem primitive. All-Lock, Dec-Lock and Inc-Lock
all require additional steps of sequentially locking and unlocking
memory blocks. For its part, Cpy-Lock involves all four primitives.
Figure 9 demonstrates run-time performance of aforementioned
mechanisms (using BLAKE2S as the underlying function) with
various memory sizes: 16MB to 96MB, and page sizes 4KB and
64KB. Results can be summarized as follows:
• Run-time of all mechanisms is linear in terms of memory
size. This is expected since they are built upon a sequential
function, i.e., a MAC.
• Run-time of MAC computation on large memory sizes is in-
deed non-negligible, e.g., it takes around 4 seconds for keyed
BLAKE2S over 96MB of memory. This clearly demonstrates
the need for ensuring temporal consistency, especially, in
settings where PAtt needs to be interruptible.
• Run-times of All-Lock, Dec-Lock and Inc-Lock are all
roughly equal, in all cases. This is also expected, since each
of these three mechanisms involves a similar number of
invocations of primitives.
• The difference in run-time between baseline and All-Lock,
Dec-Lock and Inc-Lock decreases as page size grows. This
difference then becomes negligible (< 0.1%) when page size
reaches 1MB. Thus, it is beneficial to use these mechanisms
with reasonably large page sizes. One disadvantage of larger
page sizes is that memory pages, on average, will be locked
for longer periods.
LockPageUnlockPageCopyMemKeyed BLAKE2SAES256-CBCMACHMAC-SHA25610-610-510-410-310-210-1100101run-time [s]4KB Page Size64KB Page Size1MB Page Size16MB Page SizeFigure 8: Performance of primitives with 16MB memory on I.MX6-
SabreLite and ODROID-XU4.
• Cpy-Lock comes out as the preferred mechanism. It incurs
small (∼ 8%) run-time overhead; however, this mechanism
provides much better availability as memory is locked for
a very short amount of time (only during the copying pro-
cess). However, recall that an obvious disadvantage is that it
requires additional memory of size M′.
(a) 4KB Page Size
5.5 Implementation of Inconsistency Detection
We could implement the inconsistency detection mechanism by
having PAtt detect whether any dirty/accessed bits are set after
each measurement is completed. However, this obvious approach
falls short in the context of HYDRA. Doing so would imply some
modifications to the existing kernel, which may consequently break
formally verified properties of seL4.
Instead, we base our implementation of inconsistency detection
on the All-Lock implementation. The idea is to have PAtt first lock
memory to be attested before starting to compute the integrity-
ensuring function, e.g., the MAC. If the computation completes
without interruptions or detecting any inconsistency, PAtt then
unlocks the memory; this scenario resembles typical All-Lock
execution. However, if another process (denoted by P′) attempts
to modify any part of the locked memory, the kernel will suspend
execution of P′ and PAtt will be made aware of such inconsistency;
PAtt then resolves the inconsistency by unlocking the memory
and resuming execution of P′. Note that this implementation still
requires some interference with other processes as P′ is suspended
when inconsistency occurs. However, we show later in Section 5.6
that the overhead from this interference is very small compared to
the actual measurement runtime.
into the following three threads:
To implement this mechanism in HYDRA, we decompose PAtt
• Thchecksum: computing the integrity-ensuring function and
returning an attestation result to Thmain on success.
• Thfault: listening for any memory write fault and notifying
Thmain when there is an attempt to modify memory being
attested.
• Thmain: managing the other two threads, locking and unlock-
ing memory and reporting to Vrf when an inconsistency
occurs.