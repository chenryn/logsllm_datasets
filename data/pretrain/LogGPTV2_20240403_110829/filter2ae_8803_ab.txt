在此步骤中，我们目的是通过修改目标可执行文件的指令将执行流重定向到后门代码。这里有一个关于选择将被修改的指令重要细节,
所有二进制指令具有字节大小，为了跳转到后门代码地址，将使用5或6字节的长跳跃。
因此，当修补二进制时，将被修补的指令需要与长跳转指令的大小相同，否则上一条或下一条指令将被破坏。
选择适当的空间来重定向执行对于绕过AV产品的动态检测和沙箱分析机制是非常重要的。如果直接发生重定向，则可能在AV的动态扫描分析阶段就被检测到。
**隐藏在用户交互下：**
绕过沙盒与动态分析阶段的第一件事是延迟`ShellCode`的执行或设计沙箱感知和触发机制。
但在添加后门时，大多数时候没有这么多的空间用于在PE文件中添加这些额外的代码。在汇编级语言中设计防检测机制这需要大量的时间和知识。
该方法主要是利用与用户交互来执行操作的功能,
作为一个触发机制，当一个用户操作程序时激活后门代码。如果这个方法可以正确实现，它将有100%的成功率，而且不会增加后门代码的大小。
在`putty`启动后的界面中, 点击 “Open” 按钮会启动一个检查IP地址是否有效的功能。
如果IP地址字段值不为空并且有效，则它启动尝试连接给定IP地址的连接功能。如果客户端成功创建SSH会话，将弹出一个新窗口并请求凭据，
这将是重定向发生的点，因为AV产品不能够复制这种复杂的环境，植入的后门将不会被自动化沙盒和动态分析机制检测到。
使用基本的逆向方法，搜索下面的字符串和字符串引用，将不难找到连接函数的地址。客户端建立与给定IP的连接后，有一个字符串 “login as:”
打印到出现的窗口。 这个字符串将帮助我们找到连接函数的地址，`IDA Pro`在这方面做得很好。
为了找到 **“login as:”** 字符串, 在`IDA`上依次打开 **Views- >Open Subviews->Strings**
找到字符串后，双击转到所在位置，在数据节内部`IDA`查找所有对字符串的交叉引用，按 “Ctrl+X”，它显示所有交叉引用，这个引用在打印 “login
as:” 字符串的函数内部。
这将是要修补的指令，在进行任何更改之前，请注意上下文的指令。 执行后门代码后，将再次使用。
通过将`PUSH 467C7C`指令改为`JMP 0x47A478`，完成后门过程的重定向阶段。
重要的是注意下一个指令地址。它将在执行后门代码后用作返回地址。
接下来将是注入后门代码的环节。
## 6\. 注入后门代码
在注入后门代码时，首先需要做的是在执行后门之前保存寄存器中的内容。所有寄存器中的每个值对于程序的执行是非常重要的。通过在代码的OEP(程序入口点)放置`PUSHED`和`PUSHED`指令，所有寄存器内的值和寄存器标志都存储在堆栈中。
这些值将在执行完后门代码之后弹出，以便程序可以继续执行而没有任何问题。
如前所述，使用的后门代码是来自`metasploit`项目的`meterpreter`反向TCP
`ShellCode`。但是在`ShellCode`中需要做少量修改。 通常，反向TCP
`ShellCode`会有尝试连接到处理程序的次数或时间限定，如果连接失败，则通过调用`ExitProcess API`调用关闭进程。
这是问题的所在，如果连接到处理程序失败，`putty`客户端的执行将停止。改变几行`ShellCode`使其每次连接失败时`ShellCode`将重试连接到处理器，这样也会相应的减少`ShellCode`的体积。
在汇编代码中进行更改后，使用`nasm -f bin stager_reverse_tcp_nx.asm`命令进行编译。现在反向的TCP
`ShellCode`已经可以使用了，但是它不会被直接放置, 我们的目标是在新线程上执行`ShellCode`。
为了创建一个新的线程实例，需要另一个`ShellCode`，使`CreateThread`API调用指向反向TCP
`ShellCode`。这里使用`Metasploit`项目中创建线程的[`ShellCode`](https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/single/createthread.asm)。
如上, 将 [createthread.asm](https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/single/createthread.asm)
文件中的代码转换为十六进制格式的`ShellCode`，使用`nasm -f bin
createthread.asm`命令进行编译。在这里，`ShellCode`准备插入到`Caves`中，但在插入`ShellCode`之前，它应该被编码以便绕过AV产品的静态/特征分析机制。因为`Metasploit`项目中的所有编码器被大多数AV产品所知，所以强烈建议使用自定义编码器。
本文不会覆盖这种自定义`ShellCode`编码器的制作，它将在下一篇文章中介绍到，这里还可以使用多个`Metasploit`编码器来工作。在每个编码过程完成之后，将编码的`ShellCode`上传到线上的病毒检测站点，根据检测分数。
尝试每个组合，直到它不被检测到或等待下一篇文章。
在正确编码`ShellCode`之后，就可以把它插入`Code Caves`。选择在`PUSHFD`下的指令，然后在免调试器上按下 “Ctrl +
E”，`ShellCode`将以十六进制格式粘贴。
使用`xxd -ps
createthread`命令，以十六进制格式打印编码创建线程的`ShellCode`或使用十六进制编辑器打开`ShellCode`并复制十六进制值。当将十六进制值粘贴到调试器时，请注意字节限制，这些修补操作是用免试器进行的，免调试器在粘贴到编辑代码窗口时有一个字节限制。
它不会粘贴所有`ShellCode`，记住粘贴的`ShellCode`的最后2个字节在编辑代码窗口内，按下OK按钮后继续粘贴字节，当所有`ShellCode`粘贴到`Code
Cave`时后门代码就插入完了。
## 7\. 恢复执行流程
在创建后门代码线程之后，程序需要恢复到其正常执行流程，这意味着EIP应该跳回到将执行重定向到`Cave`的函数。但是在跳回到该函数之前，应该检索所有保存的寄存器。
通过在`ShellCode`的末尾放置`POPFD`和`POPAD`指令，所有保存的寄存器都以相同的顺序从堆栈中弹出。在检索寄存器后，还有一件事要做，执行被劫持的指令。为了将程序的执行重定向到`Code
Cave`, 我们将`PUSH 467C7C`指令替换为了`JMP 0x47A478`。 现在把`PUSH
467C7C`指令放在最后，被劫持的指令也被检索。现在是返回到通过插入`JMP
0x41CB73`指令将执行重定向到`Cave`的函数的时候了，结果代码应该如下图所示。
最后选择所有修补和插入的指令，按右键单击并复制到可执行文件。此操作应对已修改的每个指令执行。当所有指令被复制并保存到文件时，关闭调试器并测试可执行文件，如果可执行文件运行顺畅，则后门可以使用。
最后，建议固定最终文件校验和，以保持文件的真实性，而不是看起来可疑，这也可能对降低检测分数有影响。
## 8\. 总结与预防措施
最后，当所有操作都正常完成后，产生的后门是完全不会被检测到的。针对以上的两种代码注入方式，下面给出这些相应技术的对策，这些策略可以帮助系统管理员、恶意软件记录器、反病毒与反恶意软件产品的开发人员。
### 8.1 区段特权控制
当谈论后门文件时，区段的特权对于检测异常是非常重要的，编译器永远不会设置对区段的完全权限，除非开发人员强制添加。特别是像`.data`或`.rdata`这样的数据段不应该有执行权限，类似`.text`的代码段不应该有写权限，这些异常应该被认为是可疑的行为。
### 8.2 不常见区段识别
如果开发人员不进行任何配置,
编译器通常创建5-6个通用类型的区段，所有安全产品应该具有识别不常见和可疑段的机制，这种机制可以寻找段内的熵和数据对齐，如果一个段包含高熵和异常排序的数据，它应该被认为是可疑的。
### 8.3 签名检查
这种对策非常经典，也是最有效的，当下载一个新的程序或任何一块可执行文件，检查sha1签名来验证程序是否被修改。
### 8.4 检查文件校验和
当内部镜像和文件的实际校验和的值之间存在差异时，这表明该文件已被修改过，安全产品和系统管理员应计算实际校验和并与镜像头比较，来检查文件的真实性。
## 9\. 原文链接
  * http://NoDistribute.com/result/image/Ye0pnGHXiWvSVErkLfTblmAUQ.png
  * https://github.com/secretsquirrel/the-backdoor-factory
  * https://www.shellterproject.com/
  * https://en.wikipedia.org/wiki/Red_team
  * https://en.wikipedia.org/wiki/Address_space_layout_randomization
  * https://en.wikipedia.org/wiki/Code_cave
  * https://en.wikipedia.org/wiki/Checksum
## 10\. 译者参考
  * https://ccdcoe.org/publications/LockedShields13_AAR.pdf
* * *