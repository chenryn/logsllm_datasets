S
A
t
c
e
t
o
r
P
S
A
i
e
n
h
p
r
o
M
r
e
k
n
i
r
h
S
C
P
k
c
a
P
E
P
t
c
a
p
m
o
C
E
P
X
E
P
e
t
i
t
E
P
i
n
p
S
E
P
t
p
y
r
C
y
o
P
l
X
P
U
k
c
a
p
U
k
c
a
p
U
n
W
i
r
e
h
t
o
A
D
O
Y
k
c
a
P
S
n
Packer
r
o
t
c
e
t
o
r
P
e
d
0
c
V
L
S
Fine-grained memory access
tracking (at instruction level)
Coarse-grained memory access
tracking (at memory-page level)
Figure 2: Comparison of the number of unpacking
stages per packer, observed using ﬁne- and coarse-
grained memory-access tracking. The numbers repre-
sent averages over 272 packed samples.
433433
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:38:39 UTC from IEEE Xplore.  Restrictions apply. 
System call
NtWriteFile
NtSetValueKey
NtCreateProcess
NtDeleteFile
NtDeleteKey
NtWriteVirtualMemory Write data into memory (can be
used to write in the memory of
another process)
Description
Write data into a ﬁle
Set the value of a registry key
Create a new process
Delete a ﬁle
Delete a registry key
...
Table 2: Microsoft Windows dangerous system calls.
from the traditional view of unpacking and scanning as
separate, one-time stages of the malware detection pro-
cess. Attempts to protect the malicious code with multi-
ples layers interleaved with the execution of dangerous
system calls or attempts to delay the execution of the
unpacked code are worthless with our system. As our
experimental results show (Section 5), the low overhead
of OmniUnpack allows for continuous monitoring in an
end-user environment.
3. The OmniUnpack Algorithm
We now give a detailed description of the algorithm
sketched in Section 2. The algorithm ensures that every
code fragment reached during a program execution is
checked by a malware detector before the host system
might be irreparably harmed. The OmniUnpack algo-
rithm monitors the execution of the program and in-
vokes the malware detector on newly generated code.
The program is stopped while the malware detector is
executed and resumed if no malicious code is found.
Intuitively, newly generated code is available for
scanning when an unpacking stage is concluded. Unfor-
tunately, in presence of a high number of spurious un-
packing stages, invoking the detector at the end of each
observed unpacking stage would become prohibitively
expensive. Using the fact that the host system cannot be
damaged without executing a dangerous system call, we
can postpone malware detection until such a system call
is invoked. The advantage of postponing detection is
that the output of multiple unpacking stages is accumu-
lated and analyzed only once. A pseudo-code version
of OmniUnpack is given in Algorithm 1.
The algorithm tracks the memory pages that were
written (the set W ) and the memory pages that were
written and executed (the set W X ). Obviously, W X ⊆
W . When the program invokes a dangerous system call
after executing code from a previously written mem-
ory page (line 11), the algorithm triggers malware de-
tection on all the pages written (i.e., those recorded in
the set W ). Unless the process is found to be mali-
cious and thus terminated (line 14), the system call is
allowed and execution is resumed. After a scan, the sets
W and W X are reset to ensure that the same pages will
Algorithm 1: OmniUnpack
Input: An execution trace T = he0 , e1 , . . .i, where a trace
event ei is either a write access w(p) to a memory
page p, an instruction execution x(p) from a memory
page p, or the system-call invocation s.
W ← /0 ;
/* written pages */
W X ← /0 ; /* pages written then executed */
foreach e ∈ T do
switch the value of e do
case write access w(p)
W ← W ∪ {p}
case instruction execution x(p)
if p ∈ W then
W X ← W X ∪ {p}
case system-call invocation s
if s ∈ {dangerous system calls} ∧W X 6= /0 then
foreach p ∈ W do
r ← Scan(p)
if r = MALICIOUS then
halt execution
return
invoke the system-call handler for s
W ← /0
W X ← /0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
not be scanned again (unless modiﬁed once again be-
fore execution). At the end of an unpacking stage we
do not scan only the executed-after-write pages, but all
the written pages. Therefore, if unpacking is concluded,
no further memory scans are required during the rest of
the execution.
We note that OmniUnpack does not need to observe
all memory-page accesses.
It is sufﬁcient to observe
the ﬁrst memory access in an uninterrupted sequence of
accesses of the same type. For example, only the ﬁrst
write to a page is useful, subsequent writes to the same
page do not impact the result of the algorithm and can
be ignored. In other words, the information we need is
the ﬁrst execution of a page after write accesses to the
same page. The implementation makes use of this ob-
servation to attain near-native performance, with mini-
mal overhead.
4. Implementation
We have implemented OmniUnpack as a kernel
driver for Microsoft Windows XP executing on a In-
tel IA-32 processor, where we simulate non-executable
pages in software. This setting allows us to measure the
performance and efﬁcacy of unpacking in a real-world
scenario, i.e., on unmodiﬁed hardware. Our implemen-
tation is derived from OllyBone [17], a plugin for the
well known debugger OllyDbg, which allows for page-
level break-on-execute by adopting an approach similar
to that used by PaX PAGEEXEC [13]. The user-space
434434
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:38:39 UTC from IEEE Xplore.  Restrictions apply. 
Suspicious
program
ClamAV
Malware
detector
User
Kernel
System-call
monitor
Memory
access
monitor
OmniUnpack
kernel
driver
Figure 3: Architecture of
malware-detection system.
the OmniUnpack-based
malware detector is based on the ClamAV open source
anti-virus [4].
4.1. Architecture Overview
Our system is composed of a kernel driver and a
user-space component (Figure 3). The kernel compo-
nent is responsible for (I) tracking memory accesses
to detect the end of an unpacking stage (Section 4.2),
(II) detecting when a dangerous interaction between the
suspicious program and the system occurs (Section 4.3),
and (III) triggering malware detection. The user-space
component consists of a malware detector responsible
for on-demand scanning of memory of the suspicious
program (Section 4.4).
The kernel component keeps track of the memory
locations that can potentially contain newly generated
malicious code. Before allowing any dangerous inter-
actions with the system, it notiﬁes the user-space mal-
ware detector to analyze these locations. If the malware
detector does not ﬁnd any malware, the execution is re-
sumed, otherwise the program is terminated.
4.2. Monitoring Memory Accesses
Coarse-grained memory-access tracking is imple-
mented by leveraging the memory protection mecha-
nism offered by the hardware. Attempts to execute the
code generated during unpacking are detected by en-
forcing a write-xor-execute policy (W ⊕ X ) on the mem-
ory pages of the suspicious program (i.e., a memory
page can be either writable or executable).
When an unpacking routine writes the unpacked
code to memory, the destination page is marked as
writable but not executable. At the end of the unpack-
ing stage, when the program accesses the same page
for execution, the lack of execution permission causes
a protection exception that is reported to the operating
system (OS). We intercept and process such exceptions.
Further accesses for execution will not cause any pro-
tection exception because the execution permission has
been granted since the ﬁrst access for execution. A sub-
sequent attempt to modify the code stored in the exe-
cuted page will not cause a new protection exception
unless the write permissions have been removed again
at the end of the unpacking stage.
The W ⊕ X policy is only temporarily applied on
the original page permissions to allow for the inter-
ception of write and execution attempts. The real per-
missions are recorded and restored, when necessary, to
guarantee the correct behavior of the monitored pro-
gram. During the execution of the program when a pro-
tection exception is raised, we check the original page
permissions to detect whether the protection exception
is real (i.e., the access to the page violates the original
permissions) or it is caused by the W ⊕ X policy. In the
ﬁrst case we restore the original page permissions and
we invoke the OS page fault handler. In the second case
we update the page permissions to authorize the new
type of access and to prevent the complementary type
of access. Note that, once a page has been marked as
written-then-executed, there is no need anymore to en-
force the W ⊕ X policy on the page until the end of the
current unpacking stage.
Many hardware architectures (e.g., Intel IA-64,
Sun Sparc, Alpha) offer facilities to enforce the W ⊕ X
policy through support for read, write, and execute per-
missions at the page level. Unfortunately, the architec-
ture targeted by the vast majority of malicious programs
(Intel IA-32) lacks such facilities. On this architecture
non-executable pages can be simulated via a software
mechanism with only a minimal overhead, as demon-
strated by the PaX PAGEEXEC project [13]. We em-
ploy a mechanism similar to PaX PAGEEXEC for the
purpose of tracking memory write and execute accesses.
The idea is to simulate non-executable pages by mark-
ing them as not accessible from user space, while grant-
ing only temporarily read/write access permissions by
exploiting the presence of two separate caches on the
CPU for the virtual-to-physical address translation (one
for data and the other for instructions).
When the program is loaded in memory and when
a new page is allocated in memory (e.g., as a result of a
page miss or of dynamic memory allocation), we record
the original page permissions and we remove the write
permission. We handle explicit requests from the pro-
gram to update page permissions similarly. Algorithm 2
is responsible for enforcing the W ⊕ X policy and for
passing any errors to the OS page fault handler. The
algorithm is invoked every time a memory protection
error is raised by the CPU during the execution of the
suspicious program. If the access type complies with
the original page permissions, the algorithm updates the
permissions according to the access type. Otherwise,
the algorithm restores the original permissions and in-
vokes the OS page fault handler to gracefully handle the
435435
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:38:39 UTC from IEEE Xplore.  Restrictions apply. 
Algorithm 2: Track page accesses
Input: The address a of the page fault and the type
t ∈ {READ, WRITE, EXECUTE} of the attempted
access that caused the page fault.
p ← Page(a)
if t authorized by the original permissions of p then
if t = EXECUTE then
remove write permission from p