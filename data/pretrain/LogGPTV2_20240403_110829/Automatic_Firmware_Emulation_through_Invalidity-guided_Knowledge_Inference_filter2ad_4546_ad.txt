the ﬁrst time. Then, every time the execution ﬁnishes reading
test-case or the ﬁrmware crashes/hangs, the plugin rolls back
to the fork point and clones another state to continue fuzzing.
For crash detection, we implemented a very basic memory
error detector, which checks the memory access permissions
based on regions: R+X for the whole ROM, R+W for RAM,
peripherals, and system control block, and no access for the
rest. We also consider HardFault as a crash indicator be-
cause typically it means an unrecoverable error. The timeout
is set as 10 seconds for hang detection.
Data Registers Identiﬁcation. In fuzz testing, it is essential
to identify input channels under attackers’ control. In MCUs,
this corresponds to peripheral data registers. We found candi-
date data registers often exhibit the following characteristics,
which gave us opportunities to identify them automatically.
First, the T3 registers are mostly data registers. This is because
the readings from them are often protocol data, as exempliﬁed
in Listing 4. Second, data registers are often read in interrupt
handlers but their readings are consumed in the non-interrupt
context. Third, compared with other kinds of registers, data
registers are frequently accessed during execution (more than
hundreds of times). If a register has one of the above charac-
teristics, we mark it as a data register for fuzzing. As shown
in Table 5, this method enables us to accurately identify data
registers for real-world fuzzing.
5 Evaluation
The main evaluation questions for µEmu are as follows. 1)
whether it is able to emulate the behaviors of different kinds
of unknown peripherals correctly; 2) whether the performance
is within an acceptable range for practical uses; 3) whether it
enables analysis tools like fuzzers to ﬁnd real-world bugs of
the task code of ﬁrmware. All experiments were conducted on
an 8-core/16-thread Xeon server with 48GB RAM, running a
Ubuntu 18.04 OS.
5.1 Unit Tests
We conducted the same unit-test experiment as was done in
P2IM to ensure a head-to-head comparison. It tests how µEmu
can handle individual peripheral functions.
5.1.1 Experimental Setup
We reused the same 66 ﬁrmware samples1 in the P2IM
experiment [3]. These samples cover eight most popular
MCU peripherals, three MCU chips (STM32 F103RB, NXP
MK64FN1M0VLL12, and Atmel SAM3X8E), and three
widely used MCU OS/system libraries (NuttX, RIOT, and
Arduino). Each unit-test sample represents a unique and fea-
sible combination of a peripheral, an OS, and an SoC. After
rebooting, the ﬁrmware performs the basic peripheral opera-
tions. For each unit test, we ﬁrst ran the knowledge extraction
phase. During dynamic analysis, we overrode the testcases
generated by AFL with the expected data extracted from the
unit test to emulate data input.
5.1.2 Experiment Results
The results are summarized in Table 1. All the unit tests ﬁn-
ished the knowledge extraction phase within one minutes with
one round. It suggests the high efﬁciency of our knowledge
extraction algorithm. Out of 66 samples, only three unit tests
failed, suggesting a passing rate of 95%, which is higher than
the result in P2IM (79%).
Failed Tests in P2IM. A major reason for failed tests in P2IM
is register mis-categorization. When the register is treated
as another type, the resulting response is very likely to be
1The original P2IM paper claimed 70 valid samples while 4 of them can never
pass the unit test. P2IM authors have acknowledged this mistake in errata:
https://github.com/RiS3-Lab/p2im-unit_tests#errata.
USENIX Association
30th USENIX Security Symposium    2017
Peripheral Functional Operations
ADC
DAC
GPIO
PWM
I2C
UART
SPI
Timer
Table 1: Unit tests results without human intervention
F103/Arduino F103/RIOT F103/NUTTX K64F/RIOT SAM3/Arduino
Read an analog-to-digital conversion
Pass
Write a value for digital-to-analog conversion N/A
Pass
Execute callback after pin interrupt
Read status of a pin
Pass
Pass
Set/Clear a pin
Pass
Conﬁgure PWM as an autonomous peripheral
Pass
Read a byte from a slave
Pass
Write a byte to a slave
Pass
Receive a byte
Transmit a byte
Pass
Pass
Receive a byte
Pass
Transmit a byte
N/A
Execute callback after interrupt
Read counter value
N/A
Pass
N/A
Pass
Pass
Pass
Pass
Fail
N/A*
Pass
Pass
Pass
N/A*
N/A
N/A
N/A
N/A
Pass
Pass
Pass
N/A
N/A*
N/A*
Pass
Pass
Pass
Pass
Pass
Pass
Pass
N/A
Pass
Pass
Pass
Pass
Fail
Fail
Pass
Pass
Pass
Pass
Pass
Pass
Pass
Pass
Pass
Pass
Pass
Pass
Pass
Pass
Pass
Pass
Pass
Pass
N/A
N/A
SAM3/RIOT
Pass
Pass
Pass
Pass
Pass
Pass
N/A
N/A
Pass
Pass
Pass
Pass
Pass
Pass
Note: 1. There are 18 unavailable entries (marked with “N/A”) because these combinations of MCU Soc and OS/libraries are not correctly supported by real devices. The original
P2IM paper marked 14 of them. There are 4 additional ones (marked with “*”) after we conﬁrmed with the P2IM authors.
2. Since unit test-cases are simple, we set BB#_INV1 as 15, BB#_INV2 as 500 and BB#_Termination as 10,000 for all unit test samples.
wrong. We attribute failed tests to several reasons, including
mis-categorization (MC), invalid assumption (IA) and limited
exploration (LE), which are explained in Section 5.3.
Failed Tests in µEmu. Invalidity checking plays an important
role in µEmu. If an unexpected path is not recognized as
invalid, µEmu may lead the emulation to it. The failed tests
were all caused by this issue. In Listing 6, we show such an
example in which the ﬁrmware reads a byte via the I2C bus. It
ﬁrst checks the status register. If an error condition is detected
in line 3, the function returns an error. Otherwise, the normal
function is performed.
I2C_TypeDef * i2c_dev = i2c_config [ dev ]. dev ;
if (( i2c_dev -> SR & 6) == 2)
1 int i2c_read_bytes (...) {
2
3
4
5
6
7 }
...
data = i2c_dev -> DR ;
return Error ;
Code Listing 6: Code snippet in which µEmu fails to extract
correct information.
In this example, the error returned in line 5 is not handled.
As a result, regardless of the path being executed in the func-
tion, the execution error cannot be detected by the proposed
invalidity checking mechanism. In our evaluation, 3 out of
66 test-cases have this issue. We argue that this problem is
mainly due to not following the best practice in programming.
In particular, well implemented ﬁrmware should detect the er-
ror code and handle it immediately. This problem can also be
mitigated by invoking the provided interface to specify invalid
program points. In this example, line 4 should be avoided.
Therefore, the analyst can conﬁgure the address of line 4 as an
invalid program point, so that the InvalidStateDetection
plugin is able to detect it (Section 4.3) when line 4 is exe-
cuted. After adding one additional invalid point to each failed
sample, µEmu achieved a 100% passing rate.
5.2 Fuzzing with µEmu
5.2.1 Experimental Setup
To comprehensively evaluate our work, we obtained the ten
ﬁrmware samples used in P2IM [3], two used in HALuci-
nator [1], two used in Pretender [4], and one used in the
paper WYCINWYC [35]. In addition, we collected six extra
ﬁrmware samples running on real-world commercial devices.
The source and a brief description for each extra ﬁrmware
sample can be found in Appendix B. In total, our sample set
includes 21 real-world ﬁrmware images. In general, these
samples collectively cover more than ten MCU models from
top MCU vendors such as Atmel, NXP, Maxim, and STM by
revenue [13]. Each of them includes a diverse set of periph-
erals, including UART, CAN, Radio, USB, etc. and popular
OSs/libraries such as FreeRTOS, RIOT, and Arduino. All
on-chip peripherals used by each ﬁrmware is listed in Table 4.
In the experiment, 15 samples were tested under the default
conﬁguration without any manual inputs during KB extraction.
For the remaining 6 samples, only one user-deﬁned invalid
program point (see Column 5 in Table 5) needs to be added for
each to enhance the invalidity checking. During fuzzing, three
samples need analysts to manually specify one additional data
register that was missed during KB extraction (i.e., bracketed
registers in the last column in Table 5), while others directly
used the automatically identiﬁed data registers. The detailed
information about the conﬁguration for each tested sample
can be found in Table 5 of Appendix C.
As a comparison, we used P2IM to conduct experiments
on the same set of ﬁrmware samples. To ensure a fair compar-
ison, we strictly followed the instructions on P2IM GitHub
repo [2] and communicated with the authors when some-
thing uncertain was encountered. We performed the following
manual works when using P2IM. First, for each sample, we
modiﬁed the source code to explicitly invoke the function
startForkserver for AFL fuzzing integration2. Second, we
2 https://github.com/RiS3-Lab/p2im/blob/master/docs/prep_fw
2018    30th USENIX Security Symposium
USENIX Association
Table 2: Results of knowledge extraction and fuzzing with µEmu
Knowledge Extraction Performance
Refs
P2IM [21]
Firmware
CNC
Console
Drone
Gateway
Heat_Press
PLC
Reﬂow_Oven
Robot
Soldering_Iron
Steering_Control
6LoWPAN_Sender
6LoWPAN_Receiver
Thermostat
XML_Parser
GPS_Tracker
LiteOS_IoT
Zepyhr_SocketCan
3Dprinter
µµµtasker_MODBUS
µµµtasker_USB
Round #
2
1
1
9
1
3
2
1
3
1
6
6
1
2
2
3
3
4
2
4
6
Total
Time(s)
49s
5s
593s
173s
26s
33s
267s
53s
115s
15s
287s
293s
117s
449s
54s
57s
62s
535s
25s
256s
227s
HALucinator
[19]
Pretender [25] RF_Door_Lock
WYC [35]
µEmu
w/Cache
Round #1
Path
Coverage Time(s)
18s
5s
593s
16s
26s
9s
165s
53s
44s
15s
88s
89s
117s
412s
39s
22s
28s
336s
18s
95s
45s
4/689
2/147
2/412
5/543
2/424
6/143
6/372
9/437
11/875
2/389
4/876
4/875
4/332
5/686
5/572
4/304
13/537