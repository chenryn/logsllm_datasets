### Approximation with Respect to Wave Semantics for Code Coverage Determination

The response provided is not entirely satisfactory. For instance, when dealing with packed malware, one might be interested in reconstructing the assembly code of the malware. The reconstruction of assembly code for packed malware is a distinct issue from the one addressed in this work.

In some cases, a packer may intertwine the malware's functionalities and protection mechanisms. In such scenarios, identifying and reconstructing the malware's functionality becomes a research subject in itself. For example, Yadegari et al. [34] developed a de-obfuscation method to extract a simplified code. They combined dynamic analysis with concolic executions to collect multiple traces, which were then simplified to reconstruct a control flow graph.

### Disassembler Comparison and Evaluation

Comparing disassemblers is currently challenging due to the lack of benchmarks based on obfuscated binary codes. Specifically, it is not meaningful to compare CoDisasm with off-the-shelf disassemblers, as none of them handle self-modifying code and overlapping instructions. As a result, it is difficult to assess a disassembler, and we have not been able to define a metric that adequately determines code coverage for CoDisasm or any other disassembly tool.

To address this, we propose a fourfold evaluation of CoDisasm, focusing on testing its functionality and usefulness:

1. **Section 5.2: Correctness on Regular Binaries**
   - We verify that CoDisasm correctly retrieves the code of regular binaries produced by a compiler. This is demonstrated in Table 1 using samples from the Mälardalen WCET benchmark programs [14].

2. **Section 5.3: Relevance on Malware**
   - While we cannot verify the correctness on malware (for which source code is typically unavailable), we validate our approach by running CoDisasm on 500 malware families. We observe the number of waves and layers, deducing that tools not handling self-modification and code overlap simultaneously would fail to disassemble the majority of these samples.

3. **Section 5.4: Relevance on Packers**
   - We successfully benchmark CoDisasm by packing known applications with 28 different readily available packers and retrieving these known applications. This is illustrated in Table 4, showing the number of processes, threads, and waves generated by each packer.

4. **Section 5.5: Malware Analysis**
   - We demonstrate CoDisasm's capacity for malware analysis by packing a known malware and showing that our approach can significantly aid in malware analysis.

### Experimental Validation of Correctness

**Table 1: Precision of Disassembly**

| Program       | #Inst. | #Inst.CoDisasm | Time (ms) |
|---------------|--------|----------------|-----------|
| adpcm.exe     | 120    | 1191           | 506       |
| compress.exe  | 34     | 99             | 5550      |
| ns.exe        | 1700   | 1375           | 506       |
| nsichneu.exe  | 155    | 99             | 5550      |
| statemate.exe | 5550   | 1375           | 506       |

- **#Inst.**: Number of instructions
- **#Inst.CoDisasm**: Number of instructions disassembled

### Relevance of Our Approach on Malware

We demonstrate the relevance of our approach by analyzing 500 malicious software samples from the public repository malware.lu. All these malware are detected by at least three well-known antivirus software. We verify our assumptions that (i) malware are self-modifying code by computing the number of waves, and (ii) malware use overlapping instructions by computing the number of layers per sample.

**Table 2: Number of Waves from 500 Malware**

| # Waves | Percentage |
|---------|------------|
| 1       | 8%         |
| 2       | 53%        |
| 3       | 12%        |
| 4       | 6%         |
| 5–10    | 13%        |
| > 10    | 9%         |

- 93% of the samples are self-modifying code. Half of them have only 2 waves, which could be disassembled using a generic unpacker followed by a disassembler. However, the remaining 40% of samples are more difficult to analyze, confirming the usefulness of our approach.

**Table 3: Number of Layers from 500 Malware**

| # Layers | Percentage |
|----------|------------|
| 1        | 32%        |
| 2        | 35%        |
| 3        | 17%        |
| 4        | 11%        |
| ≥ 5      | 5%         |

- 70% of the samples use at least one instruction overlapping technique.

### Relevance of Our Approach on Packers

We show that CoDisasm can retrieve the original code of a packed binary by using `hostname.exe` as a probe. We packed `hostname.exe` with 28 different packers and observed the number of processes, threads, and waves. The results are shown in Table 4.

**Table 4: Results for 28 Packers**

| Packer Name          | #proc. | #thr. | #Wave | DM  |
|----------------------|--------|-------|-------|-----|
| ACProtect v2.0       | 1      | 1     | 3     | N   |
| Armadillo v9.64      | 1      | 11    | 6     | Y   |
| Aspack v2.12         | 1      | 1     | 2     | N   |
| BoxedApp v3.2        | 1      | 1     | 2     | Y   |
| EP Protector v0.3    | 1      | 1     | 2     | N   |
| Expressor            | 1      | 1     | 3     | N   |
| FSG v2.0             | 1      | 1     | 3     | N   |
| JD Pack v2.0         | 1      | 1     | 4     | N   |
| MoleBox              | 1      | 1     | 2     | N   |
| Mystic               | 1      | 1     | 2     | Y   |
| Neolite v2.0         | 1      | 1     | 2     | N   |
| nPack v1.1.300       | 1      | 1     | 4     | N   |
| Packman v1.0         | 1      | 1     | 99    | N   |
| PE Compact v2.20     | 1      | 1     | 15    | N   |
| PECrypt V1.02        | 1      | 1     | 80    | N   |
| PE Lock              | 1      | 1     | 3     | Y   |
| PE Spin v1.1         | 1      | 1     | 2     | Y   |
| Petite v2.2          | 1      | 1     | 3     | N   |
| RLPack               | 1      | 1     | 18    | N   |
| Setisoft v2.7.1      | 1      | 1     | 106   | Y   |
| TELock v0.99         | 1      | 1     | 3     | Y   |
| Themida v2.0.3.0     | 1      | 1     | 32    | Y   |
| Upack v0.39          | 1      | 1     | 1     | N   |
| Upx v2.90            | 1      | 1     | 1     | N   |
| VM Protect v1.50     | 1      | 1     | 5     | Y   |
| WinUPack             | 1      | 1     | 1     | N   |
| Yoda’s Crypter v1.3  | 1      | 1     | 1     | N   |
| Yoda’s Protector v1.02 | 1    | 1     | 1     | N   |

- Packers massively use waves, some of which are dynamically allocated. The cascade of waves can be as deep as 635. Up to 20% of these waves are composed of overlapped instructions.

### A Malware Writer Scenario

In a final experiment, we sent the backdoor `hupigon.eyf` to the Virus Total Web service. Out of 57 antivirus products, 45 detected `hupigon.eyf` and correctly identified it. We then packed `hupigon.eyf` with the Mystic packer and sent it back to Virus Total. This time, only 22 antivirus products detected the file as malicious, and none were able to identify it.

We analyzed the same Mystic-packed file with CoDisasm. The Mystic packer generates 4 waves. The last wave creates a new process, which in turn creates two new processes.