approximation obtained with respect to the wave semantics
in order to determine the code coverage.
This response is not completely satisfactory. For example,
a malware may be packed and in this case one might be in-
752Addresses
Bytes
Layer 1 @0xf2
Layer 2 @0xfb
0xf2
79
jns +9 (0xfb)
0xf3
07
...
...
...
0xf9
47
inc edi
0xfa
b9
0xfb
57
mov ecx, aef24857
0xfc
48
0xfd
f2
0xfe
ae
0xﬀ
55
push ebp
push edi
dec eax
repne scasb
Figure 9: Overlapping : UPX case
terested in reconstructing the assembly code of the malware.
The assembly code reconstruction of a packed malware is a
diﬀerent issue than the one studied in this work.
Indeed
we may for example develop a packer in which the malware
functionalities and the protection functionalities are fully in-
tertwined. In this case, malware functionality identiﬁcation
and reconstruction is a research subject per se. For example,
the work of Yadegari et al. [34] developed a de-obfuscation
method to extract a simpliﬁed code. For this, they com-
bined a dynamic analysis with concolic executions in order
to collect several traces, which are simpliﬁed in order to re-
construct a control ﬂow graph.
Another approach is to compare disassemblers. The com-
parison between disassemblers is currently diﬃcult because
there is no benchmark based on obfuscated binary codes. In
particular, it makes no sense to compare CoDisasm with oﬀ-
the-shelf disassemblers because none deal with self-modifying
code and overlapping instructions.
As such, it is diﬃcult to assess a disassembler and we rec-
ognize that we have not been able to deﬁne a metric that
allows us to adequately determine code coverage for CoDis-
asm, or for any other disassembly tool, for that matter. That
is why, we propose a fourfold evaluation of CoDisasm focus-
ing on testing functionality and usefulness of the tool and
showing that there is no major operational problems with
the tool or its approach. First in Section 5.2, we check that
CoDisasm correctly retrieves the code of a regular binary
produced by a compiler. Second in Section 5.3, while we
cannot verify its correctness on malware for which source
code is normally not available, we veriﬁed the relevance of
our approach by running the tool on 500 malware families,
and observing the number of waves and layers; more pre-
cisely, we were able to deduct that tools not handling self-
modiﬁcation and code overlap simultaneously would have
failed to correctly disassemble the majority of those sam-
ples. Third, in Section 5.4, we successfully benchmarked
CoDisasm by packing known applications with 28 diﬀerent
readily available packers and retrieving these known appli-
cations. Finally in Section 5.5, we illustrated CoDisasm’s
capacity with malware analysis by packing a known mal-
ware and showing that our approach may considerably help
malware analysis.
Program
adpcm.exe
compress.exe
ns.exe
nsichneu.exe
statemate.exe
#Inst. #Inst.CoDisasm Time (ms)
120
34
6
1700
155
1191
506
99
5550
1375
1191
506
99
5550
1375
#Inst. = number of instructions
#Inst.CoDisasm= number of instructions disassembled
Table 1: Precision of disassembly
5.2 Experimental validation of correctness
We consider regular binaries coming from a compiler. We
show the correctness of CoDisasm on regular programs in
Table 1. These samples are taken from the M¨alardalen
WCET benchmark programs [14]. This correctness is simply
established by comparing assembly outputs.
5.3 Relevance of our approach on malware
We demonstrate that our approach is relevant by taking
500 malicious software from the public repository malware.
lu. All these malware are detected by at least three well-
known anti-virus software. We verify our assumptions that
(i) malware are self-modifying code by computing the num-
ber of waves, and that (ii) malware use overlapping instruc-
tions by computing the number of layers per sample.
Table 2 shows the number of waves generated by the sam-
ples. It can be seen that 93% are self-modifying code. Half
of them have only 2 waves. In this case, most of them could
be disassembled by using ﬁrst a generic unpacker and then
by running a disassembler on the unpacked code. However,
the remaining 40% of samples are more diﬃcult to analyze.
Generic unpackers fail, while our approach works, thus con-
ﬁrming its usefulness with respect to discovery and analysis
of waves.
Table 3 shows the number of layers obtained on the same
samples. As can be seen, 70% of the samples use at least
one instruction overlapping technique.
5.4 Relevance of our approach on packers
In this section, the goal is to show that we are able to
retrieve the original code of a packed binary. For this, we
take hostname.exe, which plays the role of a probe that we
can easily detect. Notice that the same experiment with
010059f0!!89!f9!!!!mov ecx,edi!010059f2!!79!07!!!!jnz +9!010059f4!!0f!b7!07!!!movzx eax, word [edi]!010059f7!!47!!!!!inc edi!010059f8!!50!!!!!push eax!010059fa!!b9!57!48!f2!ae!mov ecx, aef24857!!010059fb!!57!!!!push edi!!010059fc!!!48!!!dec eax!!010059fd!!!!f2!ae!repne scasb!010059ff!!55!!!!!push ebpre-synchronizationoverlapped !instructionsmov ecx,edi
jnz +9movzx eax, [edi]
inc edi
push eax
inc edi
mov ecx, aef24857push edi dec eax repne scasb push ebppush ebpinstruction !overlappingLayer 1Layer 2753# Waves
1
2
3
4
5–10 > 10
8% 53% 12% 6% 13%
9%
Table 2: Number of waves from 500 malware
# Layers
1
4 ≥ 5
32% 35% 17% 11% 5%
2
3
Table 3: Number of layers from 500 malware
an unknown binary like a malware will not be conclusive
because we do not know a priori its assembly code (probably
generated at runtime). Therefore, we packed hostname.exe
with 28 diﬀerent packers. The results are shown in Table 4.
We display the number of processes, threads and waves of
the 28 packers. The last column indicates whether instruc-
tions are run in dynamically allocated memory or not. What
we immediately see is that packers massively use waves,
some of them being dynamically allocated. The cascade
of waves may be as deep as 635. We were dumbfounded to
see that up to 20% of some of these waves were composed
of overlapped instructions. The case of armadillo is as-
tounding. We observed 132 overlapping instructions and the
packer creates 11 threads and has 2 processes. (The father
process creates a new process which contains the original
code. Then the father process attaches to the son process
like a debugger.)
For all packers but Setisoft, we observed that the packed
code behaves like hostname.exe.
In fact, Setisoft detects
the presence of Pin tracer and does not run hostname.exe.
Thus, in all but one case, we can state that we escape anti-
debugging techniques and that we correctly reach the “pay-
load”. In all but three cases (PE Lock, PE Spin and VM
Protect), we have been able to manually ﬁnd the original
code of hostname.exe within the waves disassembly, some-
times sliced into small pieces. The packer VM Protect is a
code virtualizer, and thus it is expected that we cannot see
that original code, only its intermediate representation. PE
Spin and PE Lock are based on code transformations, and
again it is not surprising that the original code cannot be
recovered. This sequence of test shows that Pin tracer is
able to correctly instrument many signiﬁcant packers.
For completeness, we also repeated the experiment replac-
ing hostname.exe with other software. No signiﬁcant diﬀer-
ences in results were observed.
Finally, we determine for each packer the number of in-
structions by wave and also the number of layers. To con-
duct these experiments, we packed again hostname.exe ,which
has 335 instructions. Due to a lack of space, we just present
the results for Aspack in Table 5.4 and TELock in Table 6.
5.5 A malware writer scenario
In this last experiment, we sent the backdoor hupigon.eyf
to the Virus Total Web service. From a total of 57 antivirus
products, 45 detected hupigon.eyf and correctly identiﬁed
it. We then packed hupigon.eyf with the Mystic packer
and sent it back to Virus Total. This time, only 22 antivirus
products detected that the ﬁle was malicious, but none were
able to identify it.
We analyzed the same Mystic-packed ﬁle with CoDisasm.
The Mystic packer generates 4 waves. The last wave cre-
ates a new process, which in turn creates two new processes.
Packer name
ACProtect v2.0
Armadillo v9.64
Aspack v2.12
BoxedApp v3.2
EP Protector v0.3
Expressor
FSG v2.0
JD Pack v2.0
MoleBox
Mystic
Neolite v2.0
nPack v1.1.300
Packman v1.0
PE Compact v2.20
PECrypt V1.02
PE Lock
PE Spin v1.1
Petite v2.2
RLPack
Setisoft v2.7.1
TELock v0.99
Themida v2.0.3.0
Upack v0.39
Upx v2.90
VM Protect v1.50
WinUPack
Yoda’s Crypter v1.3
Yoda’s Protector v1.02
3
6
2
2
2
3
3
4
2
2
2
4
99
15
80
3
2
32
18
106
#proc. #thr. #Wave DM
N
Y
N
Y
N
N
N
N
N
Y
N
N
N
Y
Y
Y
Y
N
N
Y
Y
Y
N
N
N
N
Y
N
1
11
1
15
1
1
1
1
1
1
1
1
1
1
4
1
1
1
1
5
1
28
1
1
1
1
1
1
1
2
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1