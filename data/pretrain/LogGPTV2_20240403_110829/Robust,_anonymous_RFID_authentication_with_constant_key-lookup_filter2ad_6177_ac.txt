tags. However, since the outputs of f observed by the adversary are pseudo-random, the adversary can only
have a negligible probability of forcing such an outcome without re-using the outputs of f. It is possible
that the adversary could re-use the outputs of f with different values for H. Now, by re-using f-values, the
adversary (with overwhelming probability) commits to (unknown values) of the key k (and hence the tag
identity id), c, and the input r (cid:8) r0 to f. To be able to re-use these with some other value H = h(id; r 00),
and randomness r000, the adversary must be able to (cid:2)nd r000 such that r000 (cid:8) r00 = r (cid:8) r0, which implies
knowledge of r000 (cid:8) r = r0 (cid:8) r00. Now, if r0 were to be revealed, this would allow to invert h(id; r 00) for
r00. Traditionally, the de(cid:2)nition of a one-way function allows for knowledge of unrelated input-output value
pairs, so an adversary that could re-use such values H could be (cid:2)tted into a slightly different protocol to
invert the function h.
We get Case 2 when the randomly generated values in the ideal-world that correspond to the evaluations of
h((cid:1); (cid:1)) and f ((cid:1); (cid:1); (cid:1)) on different inputs lead to a coincidental match. Since the values generated by F are
random and independent, the chance of coincidence is negligible.
It follows that when the challenge-response protocol UC-realizes one-way authentication with strong
privacy, then the compiled protocol will maintain this security level. We get scalable lookup because the
server can invert the function h.
(cid:3)
4 Strong Privacy with Constant Key-Lookup Implies Public-Key Obfusca-
tion
We show that when the number of tags T is large, anonymous, unlinkable RFID authentication with constant
key-lookup implies public-key obfuscation. To achieve this, we clarify in greater detail what we mean by
constant cost of key-lookup.
The security parameter n serves as a natural constraint on algorithmic ef(cid:2)ciency. More speci(cid:2)cally,
a feasible algorithm is characterized by having its cost factor dominated by some polynomial p(n). Let
DB(n) be the number of tags in the server database, in some instance of the RFID scheme, with security
parameter n. We require that the algorithm that lists all entries in DB(n) to be feasible, since the database
must be constructible(cid:151)hence, the size of DB(n) is bound above by some polynomial p DB(n). Note that
the cost of the (honest) server to invalidate an answer from the adversary, by exhaustion in the database, is
O(DB(n) (cid:2) val(n)), where val(n) is the cost to authenticate an honest tag, if the server knows its identity
in advance. Therefore, if the strategy (in the worst-case) is to use exhaustive search for the key, then the
key-lookup cost lookup(n) is O(DB(n)) and it is only constant when DB(n) is constant. By contrast, our
8
de(cid:2)nition of scalable key lookup requires that the lookup cost lookup(n) is constant whenever the size of
DB(n) is bounded by a polynomial in n.
To simplify our argument, we make the following assumptions on the obfuscator h and the authenticator f:
1. h(id; r0), r0 2R f0; 1ga, is as in Section 3,
2. f (k; c; r (cid:8) r0), r 2R f0; 1gb, is pseudo-random,
with a; b linear in n. We require T to be an increasing function of n, otherwise the key-lookup cost would
be constant simply be exhausting all the keys.
The proof is straightforward. Suppose that a tag’s response r; h(k; r 0); f (k; c; r (cid:8) r0), to the server’s
challenge c identi(cid:2)es the tag to the server with overwhelming probability, say 1 (cid:0) ", " negligible (in n).
Then it is easy to see that the obfuscator h will identify the tag to the server with non-negligible probability.
Indeed, the contribution of the authenticator f to the identi(cid:2)cation of the tag in constant key-lookup time is
asymptotically smaller than 1 by a non-negligible amount. More speci(cid:2)cally, if the server can only check
the authenticator of a constant number ‘ of tags for a possible match, then it will succeed with probability
bounded by "0 = ‘=T . It follows that the obfuscator h will identify the tag to the server independently of f
with probability bounded below by 1 (cid:0) " (cid:0) "0, or 1 (cid:0) ‘=T (cid:0) ", which is non-negligible if n is large enough,
since ‘=T must eventually approach 0(cid:151)as ‘ is constant, and T is not, as functions of n.
Since we are assuming that every RFID tag in our challenge-response protocol can obfuscate its iden-
ti(cid:2)er, but only the back-end server can disambiguate it, h must be a public-key one-way function (it must
have a trapdoor that only the back-end server possesses).
5 Mitigating Privacy in Support of Availability
In this section we weaken the requirement for unlinkable privacy while maintaining scalability for the back-
end server. We (cid:2)rst observe that for tag responses to be linked certain patterns must be detectable. This
can happen in different ways. For example, the adversary may succeed in detecting patterns after having
corrupted some tags. Alternatively the adversary may destabilize tags so that they cannot be recognized by
the back-end server in scalable time, thus forcing them into using responses with detectable patterns (e.g.,
re-using pseudonyms), or forcing the server into a linear key-lookup search.
The Molnar-Soppera-Wagner [MSW06] protocol discussed earlier is an example of an anonymous RFID
protocol for which tag responses may be linked if some tags get corrupted. Most of the other anonymous
RFID protocols proposed in the literature rely on state synchronization(cid:151)see e.g., [BvLdM06, Dim05, Jue04,
HM04, vLBdM07, OSK03, Tsu06]. State synchronization protocols require an extra pass to con(cid:2)rm state
changes, and are subject to the well known (cid:147)two generals’ attack(cid:148) problem: the server (tag) can never be
certain of the next state of the tag (server) when the adversary controls the communication channels. These
protocols are prone to disabling attacks. In the worst case, tags cannot be directly recognized by the server,
which must then run a linear search through the key-lookup database for each disabled tag. To mitigate this
DoS attack, tags may reuse earlier pseudonyms (if these are still recognizable), or as a last resort, reveal
their identity (not their secret key).
A desirable privacy compromise is to minimize the loss of privacy. For example, to restrict linkability to
those periods when the tag is attacked. One of the most effective disabling attack is the entrapment attack,
in which the tag is prevented from communicating with authorized readers and can only be interrogated by
the adversary. Entrapment is not necessarily physical although it does imply the ability to locate or track,
since tags communicate autonomously in wireless mode.
Attacks of this kind on privacy prompt us to revisit the de(cid:2)nition of identi(cid:2)cation. The traditional
9
cryptographic approach is to de(cid:2)ne identi(cid:2)cation as entity authentication [MvOV96]. However in more
general applications it is clear that identi(cid:2)cation has a broader scope and interpretation. Entities are typically
identi(cid:2)ed by their attributes, which may not involve authentication. For example, for a criminal anonymity
means not being visually identi(cid:2)ed by a witness: if the criminal is identi(cid:2)ed then he/she will most likely be
found guilty in a court of law even though the witness may not have checked the criminal’s ID while the
crime was committed. It is therefore necessary to interpret RFID privacy in the context of its application.
5.1 An Anonymous RFID Authentication Protocol with Constant Key-Lookup
We present a scalable solution for RFID authentication in which anonymity is established by synchronizing
states. Our solution will allow a determined adversary to link tags during an entrapment attack, but this
will not extend beyond such attacks. More speci(cid:2)cally, although the adversary may succeed in linking
tags during an entrapment session, this information will be independent for each entrapment session, thus
minimizing the loss of privacy.
The protocol is described in Fig. 2, and has three passes. It is based on O-FRAP, a protocol proposed
Figure 2: An anonymous RFID authentication protocol that supports constant key-lookup.
TAG(k; r; q; mode; ctr)
SERVER(D = f[(k; ri; q; q1
i ; : : : ; qc
i ); i 2 fold; curg]g)
c
(cid:27)
c 2R f0; 1g
if mode = 0 then ps   r else
ps   g(k; qjjIV jjctr); update ctr
(cid:23)0jj(cid:23)1jj(cid:23)2  (cid:0) g(k; psjjc)
auth   (cid:23)1
psjjauth
-
if (ps; k) 62 D then output REJECT else
conf
(cid:27)
if conf = (cid:23)2 then
if mode = 0 then r   (cid:23)0 else
mode   0 and q   (cid:23)0
else mode   1
1jj(cid:23) 0
2   g(k; psjjc)
0jj(cid:23) 0
(cid:23) 0
if (cid:23) 0
1 6= auth then output REJECT else
conf   (cid:23) 0
2
if ps = rcur then
rold   rcur and rcur   (cid:23) 0
0
fqi
else if ps = rold then rcur   (cid:23) 0
else if ps = qj
old   qi
else if ps = qj
cur then q   (cid:23) 0
curgc
old then q   (cid:23) 0
i=1; fqi
0 and
cur   g(k; qjjIV jjctr(i))gc
0 and
fqi
cur   g(k; qjjIV jjctr(i))gc
i=1
0
i=1
by Le et al. [vLBdM07], which is an optimistic forward-secure RFID authentication protocol. To simplify
output ACCEPT
10
the description of our protocol in this paper, we shall drop the requirement for forward-secrecy: however
the required changes to recapture this functionality are straightforward (and are discussed in Section 5.5).
5.2 Trusted Setup and Key-Lookup Database.
Each tag is initially assigned a unique tuple (k; r; q) of random values that is stored in non-volatile memory:
k is its secret key, r a one-time pseudonym and q a seed for generating entrapment pseudonyms. The tag is
also given a boolean variable mode and a cyclic counter ctr that takes c distinct values, c a small constant.
The protocol uses an appropriate PRF g to generate values for the pseudonyms, the authenticators and for
con(cid:2)rmation. For each tag, the server stores in a key-lookup database DB a tuple: (k; r i; q; q1
i ); i 2R
fold; currg, with the q a seed and the qj
i pseudonyms used during entrapment attacks. Initially: q = q 0,
r = ri = r0, and qj
i = g(k; jjq0jjIV jjctr(j)), i 2 fold; curg, 1 (cid:20) j (cid:20) c, where q0; r0 are random values,
IV is an initial vector and ctr(j) is the j-th value of ctr. The server stores pairs (old; cur) of values in
DB to maintain state coordination with the tags. We assume that DB is indexed by each of the 2c + 2
pseudonyms so that the cost of disambiguating a pseudonym is constant.
The state of each tag is controlled by the variable mode: if the tag is subject to an attack mode = 1,
otherwise mode = 0. More speci(cid:2)cally, mode   1 whenever the tag fails to receive con(cid:2)rmation to its