第15章 数据类型详解
全国嵌入式人才培训基地
，因为x86的浮点运算单元具有80位精度，
2.浮点型
例如3.e-1，
起始页
上一级
现在看看浮点数常量还有哪些写法。
，但各平台的实现有较大差异。
，和整型一样，
.987等等。浮点数也可以加一个后缀，
没有后缀的浮点数常量
 既没有规定每种类型占多少字
，有的处理器有浮点运算
。在x86平台上，
3.类型转换
，由于浮点数
下一页
下一
真
大
贝
---
## Page 241
除了+号之外还有哪些运算符在计算之前需要做lnteger Promotion呢？我们在下一小节先介绍Usual
到什么结果是Undefined，在大多数平台上会把进位截掉，得到的结果应该是1。
要做lnteger Promotion，然后才能参与计算。例如：
2、算术运算中的类型转换。
ch要被提升为int型之后再传给printf。
这样的代码：
Promotion。做lnteger Promotion只影响上述几种类型的值，对其它类型无影响。C99规定lnteger
3.1. Integer Promotion 请点评
3.类型转换 请点评
达式的值也是int型，
是0~255，完全可以用int表示，
计算表达式c1＋c2的过程其实是先把ci和c2提升为int型然后再相加（unsigned char的取值范围
数"），
Promotion适用于以下几种情况：
为int，如果原始类型的取值范围用int型表示不了，
号的char型、short型和Bit-field。如果原始类型的取值范围都能用int型表示,
在一个表达式中，凡是可以使用int或unsigned int类型做右值的地方也都可以使用有符号或无符
然
错误原因。本节分成几小节，
但有时候会不小心犯错，
换的情况都是C标准未做明确规定的阴暗角落。虽然我们写代码时不会故意去触碰这些阴暗角落，
规则的数量自然很庞大，
符号、无符号整数和浮点数加起来有那么多种类型,
如果有人问C语法规则中最复杂的是哪一部分，
、如果一个函数的形参类型未知，
后介绍编译器如何处理这样的关
上一页
，或者函数的参数列表中有.
unsigned char cl = 255, c2 = 2;
char ch = 'A';
，最后的结果是257。
 ch);
 更何况由于各种体系结构对于整数和浮点数的实现很不相同，
有符号或无符号的char型、short型和Bit-field在做算术运算之前首先
，首先介绍哪些情况下会发生类型转换，会把什么类型转成什么类型，
所以提升为int就可以了，
类型转换。
例如使用了Old Style C风格的函数声明（详见第2 节“自定义函
那么调用函数时要对相应的实参做lnteger Promotion，此外,
第 15 章 数据类型详解
全国嵌入式人才培训基地
假如没有这个提升的过程，
3.类型转换
，我一定会说是类型转换。
，这条规则称为Default Argument Promotion。
 每两种类型之间都要定义一个转换规则，
不需要提升为unsigned int）
从上面两节可以看出，
，这称为lnteger 
 则其类型被提升
很多类型转
整个表
241
下一
转换
有
---
## Page 242
如果赋值或初始化时等号两边的类型不相同，
3.3.由赋值产生的类型转换 请点评
再做赋值。
Conversion。单目运算符+－～只有一个操作数，
“ => >>两边的操作数类型不要求一致
，如果两边操作数的类型不同，
并且无符号数的Rank低于有符号数
，那么较低Rank的类型转换成较高Rank的
不是为了让你用，
，并且在程序出错时记得往这.
，编译器会自动做类
而是为了让
242
因
T
你
---
## Page 243
型，本节介绍编译器如何处理任意两种类型之间的转换。现在要把一个M位的类型（值为X）转换
3.5.编译器如何处理类型转换 请点评
者void型。
3.4.强制类型转换 请点评
成
以上几小节介绍了哪些情况下会发生类型转换,
则，
转换成double型（值为3.0）
的一套规则将一种类型自动转换成另一种类型。除此之外,
以上三种情况通称为隐式类型转换
为单位的IO函数"详细讨论这个问题。
在函数调用和返回过程中发生的类型转换往往容易被忽视，
值1.2会自动转成int型再返回。
定义一个临时变量并且用return的表达式对其做初始化，
我们知道，函数调用传参的过程相当于定义形参并且用实参对其做初始化，
是
（Cast Operator）自己规定某个表达式要转换成何种类型，
一个N位的类型，所有可能的情况如下表所示。
一个类型转换运算符,
，首先把i也转成double型,
unsigned 
integer
signed integer
signed integer 
integer 
signed integer
表15.3.如何做类型转换
to unsigned 
integer to
unsigned
待转换的类型
 signed 
X % 2N 
如果X在目标类型的取值范围内则值
不变，
如果X在目标类型的取值范围内则值
这种运算符由-
，否则Implementation-defined
然后两者相加，最后整个表达式也是double型的。这里的(double)就
然后和整型变量i相加，
这样赋值会引起类型转换，可能产生Bug，我们在第2.5节“以字节
，看到这一句往往会想当然地认为getchar的返回值是char型，
M>N的情况
 (Implicit Conversion,
一个类型名套()括号组成,
并且明确了每种情况下会把什么类型转成什么类
这时适用Usual Arithmetic Conversion规
 所以由赋值产生的类型转换也适用于这两
或者叫Coercion）
，因为函数原型和函数调用并没有写在-
 程序员也可以通过类型转换运算符
这称为显式类型转换（Explicit 
X % 2N 
defined
则Implementation- 
范围内则值不变，否
如果X在目标类型的取值
值不变
属于单目运算符，
M==N的情况
函数返回的过程相当于
编译器根据它自己
首先将整数3强制
后面的3是这
X
变
值不
不变
值
情况
W
%
v
243
，而事
K
---
## Page 244
维持值不变，在高位补1还是补o取决于原来的符号位，这称为符号扩展（Sign Extension）。
示就是fff,
应该值不变。那怎么维持值不变呢？是不是在高位补16个0就行了呢？如果原值是-1，
最后一个例子，把short型转换成int型，
=-32769;这个语句gcc会报警告。
32768,32767]之间则值不变，
比如把int类型转换成short类型,
结果落在[0,65535]之间。
是正的，
比如把int型转换成unsigned short型，对应表中的"signed integer to unsigned integer"，
否则产生溢出，结果是Undefined，例如对于short s=32768.4;这个语句gcc会报警告。
signed or unsigned integer", 
下面举几个例子说明上表的用法。比如把double型转换成short型，
defined和Undefined的情况，但程序出错时可以借助上表分析错误原因。
2.浮点型
于C语言%运算的定义。写程序时不要故意用上表中的规则，
范围内"，
注意上表中的"X% 2N",
上一页
，则把它除以216取模，其实就是取它的低16位，如果原值是负的，则加上216的整数倍，使
point 
to floating- 
floating-point 
floating-point
integer to
unsigned
signed or
integer 
unsigned 
floating-point 
integer 
unsigned
integer to
，当X是负数时运算结果也得是正数,
 signed or
要转成intt型的-1需要变成fff，因此需要在高位补16个1而不是166个0。换句话说，
出目标类型的取值范围则Undefined
不变，
如果X在目标类型的取值范围内则值
果X超出目标类型的取值范围则Undefined
如果X在目标类型的取值范围内则值不变，但有可能损失精度，如
Truncate toward Zero,
× % 2N 
则Undefined 
我想表达的意思是“把X加上或者减去2V的整数倍，
，如果原值在(-32769.0,32768.0)之间则截掉小数部分得到转换结果
，但有可能损失精度，如果X超
，否则产生溢出，
对应表中的“signed integer to signed integer",
全国嵌入式人才培训基地
，对应表中的"signed integer to signed integer"，转换之后
 即运算结果和除数同号而不是和被除数同号，
起始页
上一级
 如果X的整数部分超出目标类型的取值范围
 尤其不要触碰lmplementation-
值不变
值不变
，对应表中的“floating-point to
，使结果落入[0,2N-1]的
第 16 章运算符详解
如果原值在[-
十六进制表
值不变
值不变
，如果原值
，这不同
FI`
要
---
## Page 245
在最后一节总结C语言各种运算符的优先级和结合性。
本章介绍很多前面没有讲过的运算符，
4.运算符总结
3. Side Effect与Sequence Point
2.其它运算符
3.类型转换
1.位运算
目录
第 16 章 运算符详解 请点评
一页
2.4.sizeof运算符与typedef类型声明
2.3.逗号运算符
2.2.条件运算符
2.1.复合赋值运算符
1.4.异或运算的一些特性
1.3.掩码
1.2.移位运算
1.1.按位与、
或、异或、取反运算
重点是位运算，
全国嵌入式人才培训基地
全国嵌入式人才培训基地
第16章运算符详解
部分IⅡ. C语言本质
起始页
然后引出一个重要的概念Sequence Point,
1.位运算
下一页
---
## Page 246
移位运算符（Bitwise Shif）包括左移>。左移将一个整数的各二进制位全部左移若干
1.2.移位运算 请点评
是8位整数的取反，最后结果就得3了，
是fc，计算~c时先提升为整型（000000fc）然后取反，
计算过程是这样的：常量0xfc是int型的，
Promotion）
注意，&、丨、~运算符都是要做Usual Arithmetic Conversion的（其中有一步是Integer 
么计算机用二进制计数"讲过异或运算。下面用二进制的形式举几个例子。
取反（BitwiseNOT）运算符~，
或、非运算，C语言提供了按位与（Bitwise AND）运算符&、按位或（Bitwise OR）运算符I和按位
在第3节“布尔代数"讲过逻辑与、
1.1.按位与、或、异或、取反运算请点评
码程序。本节首先介绍各种位运算符，然后介绍与位运算有关的编程技巧。
“Unicode和UTF-8"介绍的UTF-8编码就是如此，
个位来存储，
整数在计算机中用二进制的位来表示，
1.位运算请点评
上一页
，这些运算符的操作数都必须是整型的。
二是每一步计算都要按上一章讲的类型转换规则仔细检查。
图16.1.位运算
unsigned char c = 0xfc;
&
00000101
00000001
00000011
，要访问这些位，仅仅有对整数的操作是不够的，
～运算符也要做lnteger Promotion，
int 
|00000101
1
00000111
00000011
，此外还有按位异或（Bitwise XOR）运算符~，我们在第1节“为仕
、或、非运算，
，这就错了。为了避免出错，
，C语言提供一些运算符可以直接操作整数中的位，
00000110
00000101
00000011
全国嵌入式人才培训基地
第16 章运算符详解
赋给c要转成unsigned char,
在以后的学习中你会发现,
1.位运算
并列出了真值表,
，学完本节之后你应该能自己写出UTF-8的编码和解
，所以在C语言中其实并不存在8位整数的位运
11111100
00000011
最后结果是f03。注意，
必须借助位运算，
一是尽量避免不同类型之间的赋
 对于整数中的位也可以做与、
值不变；c的十六进制表示
有些信息利用整数中的某几
 例如第 2 节 
 如果把-c看成
 称为位运
246
下一
贝
---
## Page 247
习题请点评
号数做位运算，
综上所述，
当操作数是有符号数时，右移运算的规则比较复杂：
移1位相当于除以2，小数部分截掉。
数也必须小于左操作数的总位数，
最低两位的11被移出去了，
当操作数是无符号数时，右移运算的规则和左移类似，例如0xcrff3>>2得到0x33fffc:
码中有i＊8，可以编译成移位指令而不是乘法指令。
取值范围内"。由于计算机做移位比做乘法快得多，
成1100，
复习一下第2节“不同进制之间的换算"讲过的知识可以得出结论，
致，
于32位，
必须小于左操作数的总位数，
最高两位的11被移出去了，
位，例0xcff3>
00110011111111111111111111111100
 11001111111111111111111111110011
00111111111111111111111111001100
 11001111111111111111111111110011
由于类型转换和移位等问题，
以减少出错的可能。
最高位移入1,
，最高两位又补了两个0，其它位依次右移两位。和左移类似，移动的位
 最低两位又补了两个0,
比如上面的例子
，否则结果是Undefined。在一定的取值范围内，将一个整数右
，也就是仍保持负数的符号位，这种处理方式对负数仍然保持
，用有符号数做位运算是很不方便的，所以，建议只对无符
 那么结果肯定不是乘以2了，