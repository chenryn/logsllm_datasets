### Overhead Analysis

None of the methods—PW NoTrap, PGT Trap, or PW Trap—introduced significant overhead. Notably, even for kcbench, the overhead of PW NoTrap was indistinguishable from that of I/O and network benchmarks. The relative overhead of PW Trap compared to PGT Trap was only about 1%. Kernel compilation, which requires spawning a large number of processes to compile individual source files (using `gcc`) and link the resulting object files (using `ld`), frequently triggers operations monitored by PrivWatcher. This indicates that the overhead of PrivWatcher is negligible at the application level.

### Related Work

#### Data-Flow Integrity
Data-Flow Integrity (DFI) was proposed as a generic defense against software attacks [23]. Using static program analysis, DFI computes a data-flow graph (DFG) that represents define-use relationships. To enforce the DFG, runtime checks are inserted before read operations to verify that the memory location is defined by legitimate instructions. However, its protection accuracy is limited by the precision of static analysis, and complete DFI enforcement incurs high overhead. Recent works have applied DFI to kernel space. Kenali [52] uses static source code analysis to identify sensitive data fields relevant to security checks; any pointers that can refer to these sensitive fields are also considered sensitive. Instead of checking on memory reads, integrity verification is done only on write operations (a variation of Write Integrity Testing [16]) to avoid full DFI enforcement overhead.

The main differences between PrivWatcher and Kenali are:
1. **Write Access Mediation**: Kenali instruments all write instructions so that only intended memory locations (as specified by the DFG) can be modified. In contrast, PrivWatcher explicitly verifies that the new values being written do not violate the security policy.
2. **TOCTTOU Consistency**: Kenali protects all pointers that can potentially refer to sensitive data fields, thus preventing simple redirection attacks that violate TOCTTOU consistency (e.g., the pointer in `task_struct` cannot be redirected to refer to another `cred` structure). However, Kenali does not protect the saved pgd address, which is critical for preventing address space injection attacks, as mentioned in Section 2. Similarly, although Kenali randomizes the location of the kernel-mode stack, the saved `sp` register (an index into a redirection table) is not protected. Consequently, attackers can still influence the current `task_struct` (and thus the current `cred`) retrieved by the kernel (see Section 3.2.3). On the other hand, PrivWatcher explicitly links the context of verification and the context of use and actively verifies this link before protected data fields are used, providing a strong guarantee for TOCTTOU consistency.

#### Data Integrity Protection
Sentry [53] is another related work that aims to protect the integrity of critical kernel data fields. It introduced the idea of partitioning kernel data structures so that their security-sensitive fields are aggregated into a single struct definition, and replaced in the original structure with a pointer reference. The new structure is then allocated in protected memory pages that are non-writable to the kernel. To verify write accesses, Sentry checks whether the value of the current program counter is within the kernel address space. This check is inadequate against kernel-level memory corruption. Unlike PrivWatcher, there is no guarantee for TOCTTOU consistency. Specifically, attackers can freely modify the (after partitioning) referencing structure, which is not protected.

#### Data Integrity in Rootkit Detection
Previous works [21, 22, 30, 41, 47] have applied non-control data protection to detect rootkits. These techniques are based on scanning memory snapshots for anomalies in kernel data. As such, they can only detect attacks after-the-fact and suffer from TOCTTOU inconsistencies, where an attacker can scrub traces of intrusion between two consecutive scans. PrivWatcher guarantees the TOCTTOU consistency of the protected data fields. Its event-driven nature also means PrivWatcher can actively prevent attacks.

Additionally, previous approaches proposed policy-based methods to protect the semantic integrity of kernel data structures. However, the invariants proposed by previous work, such as [47] and [21], are best suited for expressing relationships between data structures, e.g., that differences between the process list and CPU run queue are forbidden. None of the previous approaches can describe malicious privilege escalation, as required by the sample DAC policy presented in Section 3.3.

### Conclusion

In this paper, we presented PrivWatcher, a framework that allows for the integrity verification and protection of process credentials against memory corruption attacks. We proposed techniques to overcome the challenges of isolating, verifying, and ensuring the TOCTTOU consistency of credentials data fields. We applied PrivWatcher to ensure the correct DAC semantics enforced by the Linux kernel and prevent unauthorized processes from elevating their privileges. An implementation of PrivWatcher on Intel x86-64 Ubuntu is provided. Our experimental evaluation showed that the overhead of PrivWatcher monitoring is small, making it suitable for practical deployment. Future work will involve adapting PrivWatcher to other forms of kernel access control policies and applying PrivWatcher principles to protect other types of critical kernel non-control data.

### References
[References listed here as in the original text]

This version of the text is more structured, clear, and professional, with improved readability and coherence.