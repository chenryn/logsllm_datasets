ther did PW NoTrap, PGT Trap, or PW Trap introduce
signiﬁcant overhead. On the other hand, it is worth men-
tioning that even for kcbench, the overhead of PW NoTrap is
not distinguishable from the I/O and network benchmarks,
and the relative overhead of PW Trap to PGT Trap is only
about 1%. Kernel compilation requires spawning a large
number of processes to compile each individual source ﬁles
(gcc), as well as to link the resulting object ﬁles together
(ld).
It therefore needs to frequently trigger operations
monitored by PrivWatcher. This indicates that the over-
head of PrivWatcher is negligible at the application level.
6. RELATED WORK
Data-Flow Integrity: Data-ﬂow integrity (DFI) was pro-
posed as a generic defense against software attacks [23]. Us-
ing static program analysis, it computes a data-ﬂow graph
(DFG) that represents deﬁne-use relationships. To enforce
the DFG, runtime checks are inserted before read operations
to verify that the memory location is deﬁned by legitimate
instructions. However, its protection accuracy is limited by
the precision of static analysis, and complete DFI enforce-
ment incurs a high overhead. Recent works applied DFI to
kernel space. Kenali [52] uses static source code analysis
to identify sensitive data ﬁelds that are relevant to security
checks; any pointers that can refer to the sensitive ﬁelds are
also considered sensitive.
Instead of checking on memory
reads, integrity veriﬁcation is done only on write operations
(a variation of Write Integrity Testing [16]), in order to avoid
full DFI enforcement overhead.
The main diﬀerences between PrivWatcher and Kenali
are: 1) How write accesses are mediated : Kenali instru-
ments all write instructions so that only intended memory
locations (as speciﬁed by the DFG) can be modiﬁed, while
PrivWatcher explicitly veriﬁes that the new values being
written do not violate the security policy. 2) How TOCT-
TOU consistency is preserved : Kenali protects all point-
ers that can potentially refer to sensitive data ﬁelds, hence
it prevents simple redirection attacks that violate TOCT-
TOU consistency (e.g., the pointer in task_struct cannot
be redirected to refer to another cred structure). Nev-
ertheless, Kenali does not protect the saved pgd address,
which is critical to preventing address space injection at-
tacks, as mentioned in Section 2. Likewise, although Ke-
nali randomizes the location of kernel-mode stack, the saved
sp register (in this case an index into a redirection table)
is not protected. Consequently, attackers can still inﬂu-
ence the current task_struct (and thus the current cred)
retrieved by the kernel (see Section 3.2.3). On the other
hand, PrivWatcher explicitly links together the context of
veriﬁcation and the context of use and actively veriﬁes this
link before protected data ﬁelds are used, providing a strong
guarantee for TOCTTOU consistency.
Data Integrity Protection: Sentry [53] is another related
work that aims to integrity protect critical kernel data ﬁelds.
It introduced the idea of partitioning kernel data structures
so that their security-sensitive ﬁelds are aggregated into a
single struct deﬁnition, and replaced in the original struc-
ture with a pointer reference. The new structure is then al-
located in protected memory pages that are non-writable to
the kernel. To verify write accesses, Sentry checks whether
176the value of the current program counter is within the kernel
address space. This check is inadequate against kernel-level
memory corruption. Unlike PrivWatcher, there is no guar-
antee for TOCTTOU consistency. In particular, attackers
are free to modify the (after partitioning) referencing struc-
ture, which is not protected.
Data Integrity in Rootkit Detection: Previous works
[21, 22, 30, 41, 47] have also applied non-control data protec-
tion to detecting rootkits. All of these techniques are based
on scanning memory snapshots for anomalies in kernel data.
As such, they can only detect attacks after-the-fact, and
suﬀer from TOCTTOU inconsistencies whereby an attacker
scrubs traces of intrusion between two consecutive scans.
PrivWatcher guarantees the TOCTTOU consistency of the
protected data ﬁelds.
Its event-driven nature also means
PrivWatcher can actively prevent attacks.
In addition, previous approaches proposed policy based
approaches to protect the semantic integrity of kernel data
structures. However, the invariants proposed by previous
work, such as [47] and [21], are best suited for expressing the
relationships between data structures, e.g., that diﬀerences
between the process list and CPU run queue are forbidden.
None of the previous approaches can be used to describe ma-
licious privilege escalation, as required by the sample DAC
policy presented in Section 3.3.
7. CONCLUSION
In this paper we presented PrivWatcher, a framework that
allows integrity veriﬁcation and protection of process cre-
dentials against memory corruption attacks. We proposed
techniques to overcome the challenges of isolating, verifying,
and ensuring the TOCTTOU consistency of credentials data
ﬁelds. We applied PrivWatcher to ensure the correct DAC
semantics enforced by the Linux kernel and prevent unau-
thorized processes from elevating their privileges. An imple-
mentation of PrivWatcher on Intel x86-64 Ubuntu is given.
Our experimental evaluation showed that the overhead of
PrivWatcher monitoring is small. It is therefore suitable for
practical deployment. Our future work will involve adapting
PrivWatcher to other forms of kernel access control policies
and applying PrivWatcher principles to protect other types
of critical kernel non-control data.
8. REFERENCES
[1] ApacheBench. https://httpd.apache.org/.
[2] CVE-2013-2596.
http://www.cvedetails.com/cve/CVE-2013-2596.
[3] CVE-2013-6282.
http://www.cvedetails.com/cve/CVE-2013-6282.
[4] CVE-2014-3153.
http://www.cvedetails.com/cve/CVE-2014-3153.
[5] CVE-2015-3636.
http://www.cvedetails.com/cve/CVE-2015-3636.
[6] CVE-2016-0728. http://www.cve.mitre.org/cgi-bin/
cvename.cgi?name=2016-0728.
[7] iovyroot. https://github.com/dosomder/iovyroot.
[8] kcbench. https://github.com/knurd/kcbench.
[9] Kernel address space layout randomization.
https://lwn.net/Articles/569635/.
[10] KNOXout. http://www.vsecgroup.com/single-post/
2016/09/16/KNOXout---Bypassing-Samsung-KNOX.
[11] PingPong Root. http://pingpongroot.co/.
[12] QuadRooter. https://media.defcon.org/DEF%
20CON%2024/DEF%20CON%2024%20presentations/
DEFCON-24-Adam-Donenfeld-Stumping-The-Mobile-Chipset.
pdf.
[13] The SLUB allocator. http://lwn.net/Articles/229984.
[14] UnixBench.
https://github.com/kdlucas/byte-unixbench.
[15] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti.
Control-ﬂow integrity. In Proceedings of the 12th ACM
conference on Computer and communications security,
pages 340–353. ACM, 2005.
[16] P. Akritidis, C. Cadar, C. Raiciu, M. Costa, and
M. Castro. Preventing memory error exploits with
WIT. In Security and Privacy, 2008. SP 2008. IEEE
Symposium on, pages 263–277. IEEE, 2008.
[17] Android. System and kernel security.
http://source.android.com/devices/tech/security/
overview/kernel-security.html.
[18] A. M. Azab, P. Ning, E. C. Sezer, and X. Zhang.
HIMA: A hypervisor-based integrity measurement
agent. In Computer Security Applications Conference,
2009. ACSAC’09. Annual, pages 461–470. IEEE, 2009.
[19] A. M. Azab, P. Ning, J. Shah, Q. Chen, R. Bhutkar,
G. Ganesh, J. Ma, and W. Shen. Hypervision across
worlds: real-time kernel protection from the ARM
TrustZone secure world. In Proceedings of the 2014
ACM SIGSAC Conference on Computer and
Communications Security, pages 90–102. ACM, 2014.
[20] A. M. Azab, P. Ning, Z. Wang, X. Jiang, X. Zhang,
and N. C. Skalsky. HyperSentry: enabling stealthy
in-context measurement of hypervisor integrity. In
Proceedings of the 17th ACM conference on Computer
and communications security, pages 38–49. ACM,
2010.
[21] A. Baliga, V. Ganapathy, and L. Iftode. Automatic
inference and enforcement of kernel data structure
invariants. In Computer Security Applications
Conference, 2008. ACSAC 2008. Annual, pages 77–86.
IEEE, 2008.
[22] M. Carbone, W. Cui, L. Lu, W. Lee, M. Peinado, and
X. Jiang. Mapping kernel objects to enable systematic
integrity checking. In Proceedings of the 16th ACM
conference on Computer and communications security,
pages 555–565. ACM, 2009.
[23] M. Castro, M. Costa, and T. Harris. Securing software
by enforcing data-ﬂow integrity. In Proceedings of the
7th symposium on Operating systems design and
implementation, pages 147–160. USENIX Association,
2006.
[24] H. Chen, D. Wagner, and D. Dean. Setuid demystiﬁed.
In USENIX Security Symposium, pages 171–190, 2002.
[25] S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K.
Iyer. Non-control-data attacks are realistic threats. In
Usenix Security, volume 5, 2005.
[26] Y. Cheng, Z. Zhou, Y. Miao, X. Ding, and R. Deng.
ROPecker: A generic and practical approach for
defending against ROP attack. In Network and
Distributed System Security Symposium, 2014.
[27] J. Criswell, N. Dautenhahn, and V. Adve. KCoFI:
Complete control-ﬂow integrity for commodity
177operating system kernels. In Security and Privacy
(SP), 2014 IEEE Symposium on, pages 292–307.
IEEE, 2014.
[28] N. Dautenhahn, T. Kasampalis, W. Dietz, J. Criswell,
V. Adve, S. K. Sahoo, C. Geigle, B. Ding, Y. He,
Y. Wu, et al. Nested kernel: An operating system
architecture for intra-kernel privilege separation. In
Proceedings of the Twentieth International Conference
on Architectural Support for Programming Languages
and Operating Systems, pages 191–206. ACM, 2015.
[29] L. Davi, A.-R. Sadeghi, D. Lehmann, and F. Monrose.
Stitching the gadgets: On the ineﬀectiveness of
coarse-grained control-ﬂow integrity protection. In
23rd USENIX Security Symposium (USENIX Security
14), pages 401–416, 2014.
[30] B. Dolan-Gavitt, A. Srivastava, P. Traynor, and
J. Giﬃn. Robust signatures for kernel data structures.
In Proceedings of the 16th ACM conference on
Computer and communications security, pages
566–577. ACM, 2009.
[31] I. Fratric. ROPGuard: runtime prevention of
return-oriented programming attacks (2012).
[32] X. Ge, N. Talele, M. Payer, and T. Jaeger.
Fine-grained control-ﬂow integrity for kernel software.
In Security and Privacy (EuroS&P), 2016 IEEE
European Symposium on, pages 179–194. IEEE, 2016.
[33] X. Ge, H. Vijayakumar, and T. Jaeger. Sprobes:
Enforcing kernel code integrity on the TrustZone
architecture. arXiv preprint arXiv:1410.7747, 2014.
[34] A. Gr¨unbacher. POSIX access control lists on Linux.
In USENIX Annual Technical Conference, FREENIX
Track, pages 259–272, 2003.
[35] H. Hu, S. Shinde, S. Adrian, Z. L. Chua, P. Saxena,
and Z. Liang. Data-oriented programming: On the
expressiveness of non-control data attacks. In Security
and Privacy (SP), 2016 IEEE Symposium on. IEEE,
2016.
[36] Intel. Intel 64 and and IA-32 architectures software
developer’s manual, Volume 2.
[37] X. Jiang, X. Wang, and D. Xu. Stealthy malware
detection through vmm-based out-of-the-box semantic
view reconstruction. In Proceedings of the 14th ACM
conference on Computer and communications security,
pages 128–138. ACM, 2007.
[38] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea,
R. Sekar, and D. Song. Code-pointer integrity. In
USENIX Symposium on Operating Systems Design
and Implementation (OSDI), 2014.
[39] C. Lattner and V. Adve. LLVM: A compilation
framework for lifelong program analysis &
transformation. In Code Generation and Optimization,
2004. CGO 2004. International Symposium on, pages
75–86. IEEE, 2004.
[40] J. Li, Z. Wang, X. Jiang, M. Grace, and S. Bahram.
Defeating return-oriented rootkits with return-less
kernels. In Proceedings of the 5th European conference
on Computer systems, pages 195–208. ACM, 2010.
[41] Z. Lin, J. Rhee, X. Zhang, D. Xu, and X. Jiang.
SigGraph: Brute force scanning of kernel data
structure instances using graph-based signatures. In
Network and Distributed System Security Symposium
(NDSS), 2011.
[42] L. Litty, H. A. Lagar-Cavilla, and D. Lie. Hypervisor
support for identifying covertly executing binaries. In
USENIX Security Symposium, pages 243–258, 2008.
[43] G. C. Necula, S. McPeak, S. P. Rahul, and
W. Weimer. CIL: Intermediate language and tools for
analysis and transformation of C programs. In
Compiler Construction, pages 213–228. Springer, 2002.
[44] V. Pappas. kBouncer: Eﬃcient and transparent ROP
mitigation. Apr, 1:1–2, 2012.
[45] V. Pappas, M. Polychronakis, and A. D. Keromytis.
Transparent ROP exploit mitigation using indirect
branch tracing. In USENIX Security, pages 447–462,
2013.
[46] B. D. Payne, M. Carbone, M. Sharif, and W. Lee.
Lares: An architecture for secure active monitoring
using virtualization. In Security and Privacy, 2008.
SP 2008. IEEE Symposium on, pages 233–247. IEEE,
2008.
[47] N. L. Petroni Jr, T. Fraser, A. Walters, and W. A.
Arbaugh. An architecture for speciﬁcation-based
detection of semantic integrity violations in kernel
dynamic data. In Usenix Security, 2006.
[48] N. L. Petroni Jr and M. Hicks. Automated detection
of persistent kernel control-ﬂow attacks. In Proceedings
of the 14th ACM conference on Computer and
communications security, pages 103–115. ACM, 2007.
[49] Samsung. White paper: An overview of Samsung
KNOX, 2013.
[50] A. Seshadri, M. Luk, N. Qu, and A. Perrig. SecVisor:
A tiny hypervisor to provide lifetime kernel code
integrity for commodity OSes. ACM SIGOPS
Operating Systems Review, 41(6):335–350, 2007.
[51] S. Smalley, C. Vance, and W. Salamon. Implementing
SELinux as a Linux security module. NAI Labs
Report, 1(43):139, 2001.
[52] C. Song, B. Lee, K. Lu, W. Harris, T. Kim, and
W. Lee. Enforcing kernel security invariants with data
ﬂow integrity. In NDSS, 2016.
[53] A. Srivastava and J. Giﬃn. Eﬃcient protection of
kernel data structures via object partitioning. In
Proceedings of the 28th Annual Computer Security
Applications Conference, pages 429–438. ACM, 2012.
[54] X. Wang, Y. Chen, Z. Wang, Y. Qi, and Y. Zhou.
SecPod: a framework for virtualization-based security
systems. In Proceedings of the 2015 USENIX
Conference on Usenix Annual Technical Conference,
pages 347–360. USENIX Association, 2015.
[55] C. Wright, C. Cowan, S. Smalley, J. Morris, and
G. Kroah-Hartman. Linux security modules: General
security support for the Linux kernel. In USENIX
Security Symposium, 2002.
[56] W. Xu and Y. Fu. Own your Android! yet another
universal root. In 9th USENIX Workshop on Oﬀensive
Technologies (WOOT 15), 2015.
[57] X. Zhang, A. Edwards, and T. Jaeger. Using CQUAL
for static analysis of authorization hook placement. In
USENIX Security Symposium, pages 33–48, 2002.
178