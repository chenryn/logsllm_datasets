---
author: ''
category: 技术
comments_data: []
count:
  commentnum: 0
  favtimes: 0
  likes: 4
  sharetimes: 0
  viewnum: 14457
date: '2013-11-30 19:48:00'
editorchoice: false
excerpt: 本文来源于一篇stackexchange的问题回答。提问者问到，我们在计算机科学和数学课程里面学习到的那些算法，到底在什么地方用到了？结果Vijay
  D给出一个洋洋洒洒的深入回答，得到了提问者和众多围观。我们将这篇回答翻 ...
fromurl: ''
id: 2317
islctt: true
largepic: /data/attachment/album/201311/30/182019yhnv4yipj17ljli9.gif
permalink: /article-2317-1.html
pic: /data/attachment/album/201311/30/182019yhnv4yipj17ljli9.gif.thumb.jpg
related: []
reviewer: ''
selector: ''
summary: 本文来源于一篇stackexchange的问题回答。提问者问到，我们在计算机科学和数学课程里面学习到的那些算法，到底在什么地方用到了？结果Vijay
  D给出一个洋洋洒洒的深入回答，得到了提问者和众多围观。我们将这篇回答翻 ...
tags:
- 算法
- 应用
thumb: false
title: 那些算法在哪里？
titlepic: false
translator: geekpi
updated: '2013-11-30 19:48:00'
---
本文来源于一篇stackexchange的[问题](http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed/)回答。提问者问到，我们在计算机科学和数学课程里面学习到的那些算法，到底在什么地方用到了？结果[Vijay D](http://cstheory.stackexchange.com/users/4155/vijay-d)给出一个洋洋洒洒的[深入回答](http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed/19773#19773)，得到了提问者和众多围观。我们将这篇回答翻译过来以飨读者。
![](/data/attachment/album/201311/30/182019yhnv4yipj17ljli9.gif)
[Vijay D](http://cstheory.stackexchange.com/users/4155/vijay-d)写到：
在我看来，一个系统背后主要发挥作用的算法更容易在非算法课程上找到，这和应用数学中的成果比理论数学中更容易出现在应用中是一个道理。在讲座中，很少有实际问题能够精确匹配到一个抽象问题。归根结底，我认为没有理由让流行的算法课程，诸如Strassen乘法，AKS素性测试、或者Moser-Tardos算法与底层实际问题，如实现视频数据库、优化的编译器、操作系统、网络拥堵控制系统或者其他系统相关。这些课程的价值是学习利用错综复杂的方法发现问题的脉络而找出有效的解决方案。高级算法和简单算法的分析都不简单。正是由于这个原因，我不会忽略简单随机算法或者PageRank。
我想你可以选择任何一个大型软件，并在内部找到它所采用的基础和高级的算法。作为一个研究案例，我选择了Linux内核，并会示例一些Chromium里面的例子。
### Linux内核中的基本数据结构和算法
Linux内核([源代码的链接在github](https://github.com/mirrors/linux-2.6))。
1.[链表](https://github.com/mirrors/linux-2.6/blob/master/lib/llist.c)、[双向链表](https://github.com/mirrors/linux-2.6/blob/master/include/linux/list.h)、[无锁链表](https://github.com/mirrors/linux-2.6/blob/master/include/linux/llist.h)。
2.[B+ 树](https://github.com/mirrors/linux-2.6/blob/39caa0916ef27cf1da5026eb708a2b8413156f75/lib/btree.c)，这是一些你无法在教科书上找到的说明。
> 
> 一个相对简单的B+树的实现。我把它作为一个学习练习来帮助理解B+树是如何工作的。这同样也被证明是有用的。
> 
> 
> ...
> 
> 
> 一个在教科书中并不常见的技巧。最小的值在右侧而不是在左侧。所有在一个节点里用到的槽都在左侧，所有没有用到的槽包含了空值(NUL)。大多数操作只简单地遍历所有的槽一次并在第一个空值时(NUL)终止。
> 
> 
> 
3.[优先排序列表](https://github.com/mirrors/linux-2.6/blob/master/include/linux/plist.h) 用于 [互斥量](https://github.com/mirrors/linux-2.6/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/include/linux/rtmutex.h)、[驱动](https://github.com/mirrors/linux-2.6/blob/f0d55cc1a65852e6647d4f5d707c1c9b5471ce3c/drivers/powercap/intel_rapl.c)等等。
4.[红黑树](https://github.com/mirrors/linux-2.6/blob/master/include/linux/rbtree.h)[用于](http://lwn.net/Articles/184495/)调度、虚拟内存管理、追踪文件描述符和目录项等。
5.[区间树](https://github.com/mirrors/linux-2.6/blob/master/include/linux/interval_tree.h)
6.[根树](https://github.com/mirrors/linux-2.6/blob/master/include/linux/radix-tree.h)用于[内存管理](http://lwn.net/Articles/175432/)，NFS相关查询和网络相关功能。
> 
> 根树的一个通用的用处是存储指针到结构页中。
> 
> 
> 
7.[优先级堆](https://github.com/mirrors/linux-2.6/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/include/linux/prio_heap.h)，如其名称的教科书实现，用于[cgroup](https://github.com/mirrors/linux-2.6/blob/42a2d923cc349583ebf6fdd52a7d35e1c2f7e6bd/include/linux/cgroup.h)。
> 
> 《简单的基于CLR的只插入的，含有指针的定长优先级堆》第七章
> 
> 
> 
8.[哈希函数](https://github.com/mirrors/linux-2.6/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/include/linux/hash.h)，参考了Knuth和一篇论文。
> 
> Knuth建议，用乘法哈希的机器字来表示接近黄金比例的素数的最大整数。Chuck Lever验证了该技术的有效性：
> 
> 
> [http://www.citi.umich.edu/techreports/reports/citi-tr-00-1.pdf](ttp://www.citi.umich.edu/techreports/reports/citi-tr-00-1.pdf)
> 
> 
> 这些素数的选择是位稀疏的，他们可以通过移位和加法操作，而不必使用乘法器，乘法器是很慢的。
> 
> 
> 
9.有的代码，比如[这个驱动](https://github.com/mirrors/linux-2.6/blob/0b1e73ed225d8f7aeef96b74147215ca8b990dce/drivers/staging/lustre/lustre/lov/lov_pool.c)，实现了他们自己的哈希函数。
> 
> 使用了一种旋转哈希算法的哈希函数
> 
> 
> Knuth, D. 《计算机程序设计艺术, 卷 3: 排序与搜索》, 第6、7章. Addison Wesley, 1973
> 
> 
> 
10.[哈希表](https://github.com/mirrors/linux-2.6/blob/master/include/linux/hashtable.h)用于实现[inode](https://github.com/mirrors/linux-2.6/blob/42a2d923cc349583ebf6fdd52a7d35e1c2f7e6bd/fs/inode.c)、[文件系统完整性检测](https://github.com/mirrors/linux-2.6/blob/ff812d724254b95df76b7775d1359d856927a840/fs/btrfs/check-integrity.c)等等。
11.[位数组](https://github.com/mirrors/linux-2.6/blob/master/include/linux/bitmap.h)用于处理标志位、中断等等。并在Knuth那本书的卷4中阐述。
12.[信号量](https://github.com/mirrors/linux-2.6/blob/master/include/linux/semaphore.h)和[自旋锁](https://github.com/mirrors/linux-2.6/blob/master/include/linux/spinlock.h)
13.[二分查找](https://github.com/mirrors/linux-2.6/blob/master/lib/bsearch.c)用于[中断处理](https://github.com/mirrors/linux-2.6/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/drivers/sh/intc/chip.c),[寄存器缓存查询](https://github.com/mirrors/linux-2.6/blob/10d0c9705e80bbd3d587c5fad24599aabaca6688/drivers/base/regmap/regcache.c)等等。
14.[B树的二分查找](https://github.com/mirrors/linux-2.6/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/fs/befs/btree.c)。
15.[深度优先搜索](https://github.com/mirrors/linux-2.6/blob/a9238741987386bb549d61572973c7e62b2a4145/drivers/acpi/acpica/nswalk.c)被广泛地用于[目录配置中](https://github.com/mirrors/linux-2.6/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/fs/configfs/dir.c)。
> 
> 执行一个修改过的命名空间树的深度优先遍历，以指定的start\_handle节点开始（及结束）。回调函数会在任何一个参数匹配的节点被发现时被调用。如果回调函数返回了一个非0值，搜索将会立即终止并且将其返回给调用者。
> 
> 
> 
16.[广度优先搜索](https://github.com/mirrors/linux-2.6/blob/4fbf888accb39af423f271111d44e8186f053723/kernel/locking/lockdep.c)用于检测运行时锁定的正确性。
17.链表中的[归并排序](https://github.com/mirrors/linux-2.6/blob/master/lib/list_sort.c)用于[垃圾收集](https://github.com/mirrors/linux-2.6/blob/42a2d923cc349583ebf6fdd52a7d35e1c2f7e6bd/fs/ubifs/gc.c)、[文件系统管理](https://github.com/mirrors/linux-2.6/blob/ff812d724254b95df76b7775d1359d856927a840/fs/btrfs/raid56.c)等等。
18.[冒泡排序](https://github.com/mirrors/linux-2.6/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/drivers/media/common/saa7146/saa7146_hlp.c)在一个驱动库中也有一个令人惊讶的实现。
19.[Knuth-Morris-Pratt 字符串匹配](https://github.com/mirrors/linux-2.6/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/lib/ts_kmp.c),
> 
> 根据Knuth、Morris和Pratt[1]实现了一个线性时间的字符串匹配算法。他们的算法避免了转换函数的显式地计算DELTA。对于长度为n的文本，其匹配时间是O(n)，对于长度为m的模式(pattern)，仅使用一个辅助函数PI[1 . .m]，预先计算模式的时间为O(m)。数组PI允许转换函数DELTA被实时有效地计算。粗略地说，对于任何状态"q"= 0,1,…、m和在SIGMA中的任何字符"a",PI["q"]的值包含的信息是独立的"a"并需要计算DELTA("q","a") [2]。既然PI只有m个记录，而DELTA有O(m |SIGMA|)个记录，在预处理时间计算PI而不是DELTA的时候，我们可以节省一个因数|SIGMA|
> 
> 
> [1] Cormen, Leiserson, Rivest, Stein，算法介绍，第二版，MIT出版社
> 
> 
> [2] 见有限自动机原理
> 
> 
> 
20.[Boyer-Moore 模式匹配](https://github.com/mirrors/linux-2.6/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/lib/ts_bm.c)是在找替代品时的参考和建议。
> 
> 实现了Boyer-Moore字符串匹配算法:
> 
> 
> [1] 《一个快速的字符串搜索算法》，R.S. Boyer and Moore.计算机通信协会，20(10), 1977, pp. 762-772. 
> 
> 
> [2] 《准确的字符串匹配算法手册》，Thierry Lecroq, 2004 [http://www-igm.univ-mlv.fr/~lecroq/string/string.pdf](http://www-igm.univ-mlv.fr/%7Elecroq/string/string.pdf)
> 