[38] Ben Gras, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2018. Translation
Leak-aside Buffer: Defeating Cache Side-channel Protections with TLB Attacks.
In USENIX Security.
ASLR on the Line: Practical Cache Attacks on the MMU. In NDSS.
[40] Spyridoula Gravani, Mohammad Hedayati, John Criswell, and Michael L Scott.
2019. IskiOS: Lightweight defense against kernel-level code-reuse attacks. arXiv
preprint arXiv:1903.04654 (2019).
[41] Daniel Gruss, Clémentine Maurice, Anders Fogh, Moritz Lipp, and Stefan Man-
gard. 2016. Prefetch side-channel attacks: Bypassing SMAP and kernel ASLR. In
CCS.
remote software-induced fault attack in Javascript. In DIMVA.
Spectre Attacks: Exploiting Speculative Execution.
https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-
with-side.html
[39] Ben Gras, Kaveh Razavi, Erik Bosman, Herbert Bos, and Cristiano Giuffrida. 2017.
[42] Daniel Gruss, Clémentine Maurice, and Stefan Mangard. 2016. Rowhammer.js: A
[43] Jann Horn. 2018.
[45] Ralf Hund, Carsten Willems, and Thorsten Holz. 2013. Practical timing side
[49] Vasileios P Kemerlis, Michalis Polychronakis, and Angelos D Keromytis. 2014.
[46] Intel. 2018. Speculative Execution Side Channel Mitigations. https://software.
[44] Hong Hu, Shweta Shinde, Sendroiu Adrian, Zheng Leong Chua, Prateek Saxena,
and Zhenkai Liang. 2016. Data-oriented programming: On the expressiveness of
non-control data attacks. In IEEE S&P.
channel attacks against kernel space ASLR. In IEEE S&P.
intel.com/security-software-guidance/api-app/sites/default/files/336996-
Speculative-Execution-Side-Channel-Mitigations.pdf
[47] Saad Islam, Ahmad Moghimi, Ida Bruhns, Moritz Krebbel, Berk Gulmezoglu,
Thomas Eisenbarth, and Berk Sunar. 2019. {SPOILER}: Speculative Load Hazards
Boost Rowhammer and Cache Attacks. In USENIX Security.
[48] Yeongjin Jang, Sangho Lee, and Taesoo Kim. 2016. Breaking kernel address space
layout randomization with Intel TSX. In CCS.
ret2dir: Rethinking kernel isolation. In USENIX Security.
[50] Vasileios P Kemerlis, Georgios Portokalidis, and Angelos D Keromytis. 2012.
kGuard: lightweight kernel protection against return-to-user attacks. In USENIX
Security.
[51] Khaled N. Khasawneh, Esmaeil Mohammadian Koruyeh, Chengyu Song, Dmitry
Evtyushkin, Dmitry Ponomarev, and Nael Abu-Ghazaleh. [n.d.]. SafeSpec: Ban-
ishing the Spectre of a Meltdown with Leakage-Free Speculation (DAC’19).
Attacks and defenses. arXiv preprint arXiv:1807.03757 (2018).
[53] Paul Kocher, Jann Horn, Anders Fogh, Daniel Genkin, Daniel Gruss, Werner Haas,
Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher, Michael Schwarz,
and Yuval Yarom. 2019. Spectre Attacks: Exploiting Speculative Execution. In
IEEE S&P.
[54] Benjamin Kollenda, Enes Goktas, Tim Blazytko, Philipp Koppe, Robert Gawlik,
Radhesh Krishnan Konoth, Cristiano Giuffrida, Herbert Bos, and Thorsten Holz.
2017. Towards Automated Discovery of Crash-Resistant Primitives in Binaries.
In DSN.
[55] Koen Koning, Xi Chen, Herbert Bos, Cristiano Giuffrida, and Elias Athanasopou-
los. 2017. No Need to Hide: Protecting Safe Regions on Commodity Hardware.
In EuroSys.
Exploiting the Linux kernel via packet sock-
ets. https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-
via-packet.html
[52] Vladimir Kiriansky and Carl Waldspurger. 2018. Speculative buffer overflows:
[56] Andrey Konovalov. 2017.
[57] Hyungjoon Koo, Yaohui Chen, Long Lu, Vasileios P Kemerlis, and Michalis
Polychronakis. 2018. Compiler-assisted code randomization. In IEEE S&P.
RAID.
[86] Andrei Tatar, Radhesh Krishnan Konoth, Elias Athanasopoulos, Cristiano Giuf-
frida, Herbert Bos, and Kaveh Razavi. 2018. Throwhammer: Rowhammer Attacks
over the Network and Defenses. In USENIX ATC.
[87] Minh Tran, Mark Etheridge, Tyler Bletsch, Xuxian Jiang, Vincent Freeh, and Peng
Ning. 2011. On the Expressiveness of Return-into-libc Attacks. In Proceedings
of the 14th International Conference on Recent Advances in Intrusion Detection
(RAID).
[88] Paul Turner. 2018. Retpoline: a software construct for preventing branch-target-
injection. https://support.google.com/faqs/answer/7625886
[89] Jo Van Bulck, Marina Minkin, Ofir Weisse, Daniel Genkin, Baris Kasikci, Frank
Piessens, Mark Silberstein, Thomas F. Wenisch, Yuval Yarom, and Raoul Strackx.
[n.d.]. Foreshadow: Extracting the Keys to the Intel SGX Kingdom with Transient
Out-of-Order Execution. In SEC’18.
[90] Jo Van Bulck, Daniel Moghimi, Michael Schwarz, Moritz Lipp, Marina Minkin,
Daniel Genkin, Yarom Yuval, Berk Sunar, Daniel Gruss, and Frank Piessens.
2020. LVI: Hijacking Transient Execution through Microarchitectural Load Value
Injection. In S&P’20.
[91] Victor van der Veen, Dennis Andriesse, Manolis Stamatogiannakis, Xi Chen,
Herbert Bos, and Cristiano Giuffrida. 2017. The Dynamics of Innocent Flesh on
the Bone: Code Reuse Ten Years Later. In CCS.
[92] Victor van der Veen, Yanick Fratantonio, Martina Lindorfer, Daniel Gruss, Clemen-
tine Maurice, Giovanni Vigna, Herbert Bos, Kaveh Razavi, and Cristiano Giuffrida.
2016. Drammer: Deterministic Rowhammer Attacks on Mobile Platforms. In
CCS.
[93] Stephan van Schaik, Cristiano Giuffrida, Herbert Bos, and Kaveh Razavi. 2018.
Malicious Management Unit: Why Stopping Cache Attacks in Software is Harder
Than You Think. In USENIX Security.
[94] Stephan van Schaik, Alyssa Milburn, Sebastian Osterlund, Pietro Frigo, Giorgi
Maisuradze, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2019. RIDL:
Rogue In-flight Data Load. In S&P.
Finding Eviction Sets. In IEEE S&P.
[96] Jan Werner, George Baltas, Rob Dallara, Nathan Otterness, Kevin Z Snow, Fabian
Monrose, and Michalis Polychronakis. 2016. No-execute-after-read: Preventing
code disclosure in commodity software. In ASIACCS.
[97] David Williams-King, Graham Gobieski, Kent Williams-King, James P Blake,
Xinhao Yuan, Patrick Colp, Michelle Zheng, Vasileios P Kemerlis, Junfeng Yang,
and William Aiello. 2016. Shuffler: Fast and deployable continuous code re-
randomization. In OSDI.
Low Noise, L3 Cache Side-Channel Attack. In USENIX Security.
[99] Jiyong Yu, Mengjia Yan, Artem Khyzha, Adam Morrison, Josep Torrellas, and
Christopher W. Fletcher. [n.d.]. Speculative Taint Tracking (STT): A Comprehen-
sive Protection for Speculatively Accessed Data. In MICRO’19.
[98] Yuval Yarom and Katrina Falkner. 2014. FLUSH+RELOAD: A High Resolution,
[95] Pepe Vila, Boris Köpf, and José Francisco Morales. 2019. Theory and Practice of
[58] Jakob Koschel, Cristiano Giuffrida, Herbert Bos, and Kaveh Razavi. 2020. Tag-
Bleed: Breaking KASLR on the Isolated Kernel Address Space Using Tagged TLB.
In EuroS&P.
[59] Donghyun Kwon, Jangseop Shin, Giyeol Kim, Byoungyoung Lee, Yeongpil Cho,
and Yunheung Paek. 2019. uXOM: Efficient eXecute-Only Memory on {ARM}
Cortex-M. In USENIX Security.
[60] Moritz Lipp, Vedad Hadžić, Michael Schwarz, Arthur Perais, Clémentine Maurice,
and Daniel Gruss. 2019. Take A Way: Exploring the Security Implications of
AMD’s Cache Way Predictors. (2019).
[61] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas,
Anders Fogh, Jann Horn, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval
Yarom, and Mike Hamburg. 2018. Meltdown: Reading Kernel Memory from User
Space. In USENIX Security.
[62] Hongjiu Lu, Michael Matz, Milind Girkar, Jan Hubiaka, Andreas Jaeger, and Mark
Mitchell. 2018. System V Application Binary Interface AMD64 Architecture
Processor Supplement (With LP64 and ILP32 Programming Models) Version 1.0.
https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf
[63] Kangjie Lu, Wenke Lee, Stefan Nürnberger, and Michael Backes. 2016. How to
[68] Angelos Oikonomopoulos, Elias Athanasopoulos, Herbert Bos, and Cristiano
[69] Dag Arne Osvik, Adi Shamir, and Eran Tromer. 2006. Cache Attacks and Coun-
Make ASLR Win the Clone Wars: Runtime Re-Randomization. In NDSS.
[64] Giorgi Maisuradze, Michael Backes, and Christian Rossow. 2016. What cannot
be read, cannot be leveraged? revisiting assumptions of JIT-ROP defenses. In
USENIX Security.
[65] Giorgi Maisuradze and Christian Rossow. 2018. Ret2Spec: Speculative Execution
Using Return Stack Buffers. In Proceedings of the 2018 ACM SIGSAC Conference
on Computer and Communications Security.
[66] Giorgi Maisuradze and Christian Rossow. 2018. Speculose: Analyzing the security
implications of speculative execution in CPUs. arXiv preprint arXiv:1801.04084
(2018).
[67] Ahmad Moghimi, Thomas Eisenbarth, and Berk Sunar. 2018. MemJam: A False
Dependency Attack Against Constant-Time Crypto Implementations in SGX. In
CT-RSA.
Giuffrida. 2016. Poking Holes in Information Hiding. In USENIX Security.
termeasures: The Case of AES. In CT-RSA.
[70] Soyeon Park, Sangho Lee, Wen Xu, Hyungon Moon, and Taesoo Kim. 2019.
libmpk: Software Abstraction for Intel Memory Protection Keys (Intel {MPK}).
In USENIX ATC.
[71] Marios Pomonis, Theofilos Petsios, Angelos D Keromytis, Michalis Polychronakis,
and Vasileios P Kemerlis. 2017. kRˆ X: Comprehensive kernel protection against
just-in-time code reuse. In EuroSys.
[72] Kaveh Razavi, Ben Gras, Erik Bosman, Bart Preneel, Cristiano Giuffrida, and
Herbert Bos. 2016. Flip Feng Shui: Hammering a Needle in the Software Stack.
In USENIX Security.
[73] Robert Rudd, Richard Skowyra, David Bigelow, Veer Dedhia, Thomas Hobson,
Stephen Crane, Christopher Liebchen, Per Larsen, Lucas Davi, Michael Franz,
et al. 2017. Address Oblivious Code Reuse: On the Effectiveness of Leakage
Resilient Diversity.. In NDSS.
[74] Felix Schuster, Thomas Tendyck, Christopher Liebchen, Lucas Davi, Ahmad-Reza
Sadeghi, and Thorsten Holz. 2015. Counterfeit Object-oriented Programming:
On the Difficulty of Preventing Code Reuse Attacks in C++ Applications. In IEEE
S&P.
[75] Michael Schwarz, Moritz Lipp, Daniel Moghimi, Jo Van Bulck, Julian Stecklina,
Thomas Prescher, and Daniel Gruss. 2019. ZombieLoad: Cross-privilege-boundary
data sampling. In CCS.
to gain kernel privileges. Black Hat (2015).
(2012).
[77] Fermin J Serna. 2012. The info leak era on software exploitation. Black Hat USA
[78] Hovav Shacham. 2007. The Geometry of Innocent Flesh on the Bone: Return-
[76] Mark Seaborn and Thomas Dullien. 2015. Exploiting the DRAM rowhammer bug
into-libc Without Function Calls (on the x86). In CCS.
[79] Hovav Shacham, Matthew Page, Ben Pfaff, Eu-Jin Goh, Nagendra Modadugu, and
Dan Boneh. 2004. On the effectiveness of address-space randomization. In CCS.
[80] Kevin Z Snow, Fabian Monrose, Lucas Davi, Alexandra Dmitrienko, Christopher
Liebchen, and Ahmad-Reza Sadeghi. 2013.
Just-in-time code reuse: On the
effectiveness of fine-grained address space layout randomization. In IEEE S&P.
[81] Kevin Z Snow, Roman Rogowski, Jan Werner, Hyungjoon Koo, Fabian Monrose,
and Michalis Polychronakis. 2016. Return to the zombie gadgets: Undermining
destructive code reads via code inference attacks. In IEEE S&P.
[82] Wei Song and Peng Liu. 2019. Dynamically Finding Minimal Eviction Sets Can
Be Quicker Than You Think for Side-Channel Attacks against the LLC. In RAID.
[83] Dean Sullivan, Orlando Arias, Travis Meade, and Yier Jin. 2018. Microarchitectural
Minefields: 4K-Aliasing Covert Channel and Multi-Tenant Detection in IaaS
Clouds. In CCS.
Thwarting memory disclosure attacks using destructive code reads. In CCS.
[85] Andrei Tatar, Cristiano Giuffrida, Herbert Bos, and Kaveh Razavi. 2018. Defeating
Software Mitigations against Rowhammer: A Surgical Precision Hammer. In
[84] Adrian Tang, Simha Sethumadhavan, and Salvatore Stolfo. 2015. Heisenbyte:
A APPENDIX A - IMPACT OF REPETITIONS
This appendix details the impact of repetitions on the success rate
of individual probes of the primitives used in our exploits. In our
experiments, we arrange memory such that the probes are expected
to give a signal. We report experimental results (Figures 3-7) on the
setup detailed earlier and measured over 20 runs.
Note that for the noise-sensitive prime+probe (p+p), we require
a certain number of hits on the target page to assert with a high cer-
tainty that we have a signal. We express this amount as a threshold
in percentage indicating the required minimum number of hits out
of the total number of measurement repetitions. We compute the
threshold for each primitive that uses p+p by taking the minimum
number of hits in 100 measurements over 20 runs and reduce this
number by 10% to cover potential outliers. We then use the calcu-
lated threshold to determine whether we obtain a signal over the
given number of measurement repetitions. For example, a success
rate of 90% means that for the given number of repetitions per run, the
number of hits exceeded the calculated threshold in 90% of the 20 runs.
For p+p-based probing, we picked the lowest number of repetitions
with a 100% success rate (highlighted with a dot in Figures 3-6).
For the more noise-resistant flush+reload (f+r), we found that
having a single hit at the expected cache line is sufficient to assert
that we have a signal (i.e., for gadget probing and Spectre probing
in testing mode). This is because the verification step is sufficient
to weed out false hits caused by the prefetcher—our Spectre gadget
loads consecutive cache lines for consecutive f+r buffer offsets.
As such, for calibration, we picked the maximum of repetitions (8)
required to produce the first hit across 20 runs (𝑁 = 1 in Figure 7).
However, when we do not know which cache line will produce
a signal (i.e., for Spectre probing in leaking mode), it is preferable
to aim for more hits. We found 2 hits to be sufficient to avoid
interference from the prefetcher in practice for our gadget. As such,
for calibration, we initially picked the maximum of repetitions (9)
required to produce the first 2 hits across 20 runs (𝑁 = 2 in Figure 7).
As an optimization, we lowered this value to 7 repetitions without
reducing the (100%) success rate, since the redundancy offered by
our gadget in leaking mode allowed us to efficiently detect and
recover from occasionally erroneous leaked byte values.
Figure 4: Success rate vs. number of repetitions to sample
the target cache signal with p+p and f+r for our data region
probing primitive (calculated thresholds: 52.2%).
Figure 5: Success rate vs. number of repetitions to sample the
target cache signal with p+p and f+r for our object probing
primitive (calculated thresholds: ≈49%).
Figure 6: Success rate vs. number of repetitions to sample the
target cache signal with p+p and f+r for our gadget probing
and Spectre probing (testing mode) primitives (calculated
thresholds: 45.0% and 27.9%, respectively).
Figure 3: Success rate vs. number of repetitions to sample
the target cache signal with p+p for our code region probing
primitive (calculated threshold: 78.3%).
Figure 7: Frequency of the number of repetitions at which
the first or second hit was seen in the user page using the
Spectre gadget with f+r. When using Spectre probing in test-
ing (leaking) mode we consult the histogram with N=1 (N=2).
 0 10 20 30 40 50 60 70 80 90 100 0 10 20 30 40 50 60 70 80 90 100Success rate (%)Number of repetitionsPrime+Probe 0 10 20 30 40 50 60 70 80 90 100 0 10 20 30 40 50 60 70 80 90 100Success rate (%)Number of repetitionsPrime+ProbeFlush+Reload 0 10 20 30 40 50 60 70 80 90 100 0 10 20 30 40 50 60 70 80 90 100Success rate (%)Number of repetitionsPrime+ProbeFlush+Reload 0 10 20 30 40 50 60 70 80 90 100 0 10 20 30 40 50 60 70 80 90 100Success rate (%)Number of repetitionsPrime+ProbeFlush+Reload 0 1 2 3 4 5 6 7 812345678910FrequencyNumber of repetitions for ﬁrst N hitsN=1N=2