protection mechanisms.
In the demonstration we consider only these cases of
injection attacks – when protections are in place – since
the ﬁrst ones (unsanitized inputs) are commonly known. The
activation of SEPTIC inside of the MySQL will block these
attacks, thus defending the application, i.e., the application is
safeguarded from the injection attacks.
IV. THE DEMONSTRATION
The demonstration is based on the application scenario
described in the previous section. The setup is presented in
Figure 7. It involves two computers and one Ethernet switch.
One of the computers represents the web and DBMS servers,
containing two virtual machines, one per server. The other
computer takes the role of a client. In this way, the com-
puters represent the following entities: MySQL DBMS server,
including the SEPTIC mechanism (1 virtual machine); Apache
web server with ModSecurity, Zend engine, and the web
application (1 virtual machine); a browser to access the web
application and other tools to perform SQLI attacks, such as
sqlmap tool [19] (probably, the most used tool for testing web
applications against SQLI vulnerabilities and used by hackers
and professionals) (1 machine). The displays from SEPTIC and
ModSecurity are used to show the events related to these two
protection mechanisms. For SEPTIC, we developed a register
of events that logs all actions taken by the mechanism, such as
query model creation, query processing, and attack detection.
It was inserted in the logger module.
The demonstration has ﬁve phases. The ﬁrst shows the
exploitation of the semantic mismatch problem, although the
application is protected with the sanitization functions it in-
cludes out-of-the-box. In the second phase, the protection of
the application is enhanced with the ModSecurity WAF. The
next three phases are dedicated to SEPTIC, from its training
to attack detection.
A. Attacks with sanitization function protection
In the ﬁrst phase there are no external protection mech-
anisms enabled. The application is only protected by the
556
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:04:13 UTC from IEEE Xplore.  Restrictions apply. 
second time. All query models are in memory and are stored
persistently. Also, after the query models are built, the queries
are executed by MySQL as expected (with benign inputs).
(cid:3)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)(cid:18)(cid:9)(cid:19)(cid:13)(cid:19)(cid:31)(cid:9)
D. SEPTIC protection
(cid:27)(cid:10)(cid:13)(cid:15)(cid:16)(cid:15)(cid:16)(cid:17)(cid:18)(cid:3)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)
(cid:3)(cid:19)(cid:10)(cid:31)(cid:14)(cid:19)(cid:31)(cid:10)(cid:13)(cid:22)(cid:18)(cid:13)(cid:19)(cid:19)(cid:13)(cid:14)(cid:23)
(cid:1)(cid:15)(cid:32)(cid:15)(cid:14)(cid:10)(cid:2)(cid:18)(cid:13)(cid:19)(cid:19)(cid:13)(cid:14)(cid:23)
(cid:3)(cid:1)(cid:18)(cid:9)(cid:19)(cid:10)(cid:31)(cid:14)(cid:19)(cid:31)(cid:10)(cid:13)(cid:22)(cid:18)(cid:13)(cid:19)(cid:19)(cid:13)(cid:14)(cid:23)
(cid:3)(cid:1)(cid:18)(cid:32)(cid:15)(cid:32)(cid:15)(cid:14)(cid:10)(cid:2)(cid:18)(cid:13)(cid:19)(cid:19)(cid:13)(cid:14)(cid:23)
(cid:3)(cid:19)(cid:12)(cid:10)(cid:7)(cid:30)(cid:18)(cid:15)(cid:16)(cid:33)(cid:7)(cid:14)(cid:19)(cid:34)(cid:18)(cid:13)(cid:19)(cid:19)(cid:13)(cid:14)(cid:23)
(cid:13)(cid:19)(cid:19)(cid:13)(cid:14)(cid:23)(cid:7)(cid:10)
(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)
(cid:24)(cid:18)(cid:3)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)
(cid:3)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)(cid:18)(cid:7)(cid:11)(cid:7)(cid:16)(cid:19)(cid:9)
(cid:13)(cid:21)(cid:13)(cid:14)(cid:20)(cid:7)(cid:18)(cid:24)
(cid:1)(cid:12)(cid:30)(cid:3)(cid:7)(cid:14)(cid:31)(cid:10)(cid:15)(cid:19)(cid:2)
(cid:1)(cid:12)(cid:30)(cid:3)(cid:7)(cid:14)(cid:31)(cid:10)(cid:15)(cid:19)(cid:2)
In this phase SEPTIC is set to normal mode, more con-
cretely to prevention mode (blocks and logs attacks). Then,
MySQL is restarted to assume the new conﬁguration,
the
persistent query models are loaded and SEPTIC status display
notiﬁes this change.
Using the same injection attacks performed in the ﬁrsts
two phases, we illustrate that SEPTIC detects and blocks
all of them (i.e., no false negatives). The actions taken by
SEPTIC are registered in the events register. It registers: query
structure construction, query identiﬁer generation, query model
discovery, comparison of both structures, attacks detected, and
the type of attack (SQLI or stored injection). For the SQLI
attacks, it also logs if they are structural or syntactical, i.e.,
in which step of the SQLI detection algorithm discovered the
attack.
When SEPTIC ﬂags an attack, we observe that the attack
is blocked, the query is dropped and its execution is stopped
in MySQL. This action is visible in the browser. Moreover, we
show that the injection of benign inputs does not break any
step of the detection algorithms used by SEPTIC, meaning
that queries are executed as expected and SEPTIC does not
interfere with the normal processing inside of MySQL (i.e.,
no false positives).
E. ModSecurity versus SEPTIC
Finally, in this last phase we ﬁlter the results of both ex-
ternal protection mechanisms, looking for the attacks detected
by both. We observe that ModSecurity does not protect the
application from all injected attacks. For SEPTIC we observe
that all attacks are detected and no false positives are reported.
V. CONCLUSIONS AND DISCUSSION
The demonstration described in this paper illustrates, in
the ﬁrst place, how injection attacks can compromise an
application developed following secure coding best practices
(sanitization of entry points before they reach a sensitive sink)
and pass barriers of protection that are put before the user
inputs reach the application (web application ﬁrewalls). These
attacks have the aim of inserting or retrieving data to/from the
application database. We consider a speciﬁc class of attacks
that exploit semantic mismatch ﬂaws, which appear due to a
gap on the way SQL queries are believed to be run and the
way they are actually executed by databases. For this purpose,
we use a non-trivial PHP web application implementing entry
point sanitization and ModSecurity.
In second place, the demonstration shows the protection of
the web application using our own mechanism, SEPTIC [11].
This mechanism runs inside of the DBMS, which is MySQL
in its ﬁrst implementation. Running SEPTIC inside the DBMS
allows it to handle queries just before execution. Therefore,
adding SEPTIC to MySQL mitigates the semantic mismatch
problem.
Fig. 7: The setup of the demonstration, including example
displays.
sanitization functions from the PHP language. We illustrate
that the application contains vulnerabilities – is attackable –
even with its entry points sanitized.
The attacker uses the browser and/or the sqlmap tool to
access the application, and inserts erroneous data that reaches
the queries. Then these queries are sent to MySQL and are
executed. The results of the attacks are showed in the browser
and/or console, respectively, as the response of the database
and application.
B. Attacks with additional ModSecurity protection
In the second phase, we activate ModSecurity to show if
it can improve the protection of the application. After turning
on ModSecurity and restarting the web server, the attacks per-
formed in the previous phase are executed again. Some those
that were previously successful are blocked by ModSecurity,
whereas others are not, corresponding to ModSecurity false
negatives. This is observed in two ways: the blocked attacks
appear in the ModSecurity log, whereas the effect of those that
pass the protection mechanism have their outcome shown in
the browser. At the end of these experiments, ModSecurity is
disabled and the web server restarted.
C. Training SEPTIC
In this third phase, SEPTIC is conﬁgured for training
mode operation, the MySQL server is restarted to assume
this conﬁguration, and the SEPTIC status display notiﬁes that
SEPTIC operates now in that mode.
We illustrate the training of SEPTIC by inserting benign
inputs in application forms in the browser. These inputs reach
existing queries in the application and the queries are sent to
MySQL. SEPTIC, for each new query received, creates its
query model and stores it with a query identiﬁer. SEPTIC
events display logs with the addition of the query models for
each new query. We also illustrate that for a query processed
twice by SEPTIC,
is created and stored
only once. This happens because SEPTIC only creates query
models when it does not have stored any model with the
produced query identiﬁer. This is shown in the SEPTIC events
display, which does not notify any query model addition the
the query model
557
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:04:13 UTC from IEEE Xplore.  Restrictions apply. 
In the original paper about SEPTIC we report an ex-
perimental comparison between SEPTIC and several other
protection mechanisms, showing that SEPTIC provides better
protection [11]. Moreover, we also show that its overhead is
low.
[20] Z. Su and G. Wassermann. The essence of command injection attacks in
web applications. In Proceedings of the 33rd ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, pages 372–382,
Jan. 2006.
[21] A. Technologies. Q1 2016 state of the internet / security report. June
2016.
[22] The Register.
hacked,
ical
Mar.
http://www.theregister.co.uk/2016/03/24/water utility hacked/.
plant
supplies,
Water
for
mix
changed
treatment
tap
chem-
2016.
[23] Trustwave SpiderLabs. ModSecurity - Open Source Web Application
Firewall. http://www.modsecurity.org.
[24] WaspMon. https://github.com/azping/WaspMon.
[25] W. Xu, S. Bhatkar, and R. Sekar. Practical dynamic taint analysis
for countering input validation attacks on web applications. Technical
Report SECLAB-05-04, Department of Computer Science, Stony Brook
University, 2005.
[26] ZeroCMS. Content management system built using PHP and MySQL.
http://www.aas9.in/zerocms/.
ACKNOWLEDGMENT
This work was partially supported by the EC through
project FP7-607109 (SEGRID), and by national funds through
Fundac¸˜ao para a Ciˆencia e a Tecnologia (FCT) with references
UID/CEC/50021/2013 (INESC-ID) and UID/CEC/00408/2013
(LaSIGE).
REFERENCES
[1] S. Bandhakavi, P. Bisht, P. Madhusudan, and V. N. Venkatakrishnan.
CANDID: preventing SQL injection attacks using dynamic candidate
evaluations. In Proceedings of the 14th ACM Conference on Computer
and Communications Security, pages 12–24, Oct. 2007.
[2] S. W. Boyd and A. D. Keromytis. SQLrand: Preventing SQL injection
attacks. In Proceedings of the 2nd Applied Cryptography and Network
Security Conference, pages 292–302, 2004.
[3] G. T. Buehrer, B. W. Weide, and P. Sivilotti. Using parse tree validation
to prevent SQL injection attacks. In Proceedings of the 5th International
Workshop on Software Engineering and Middleware, pages 106–113,
Sept. 2005.
[4] E. Cecchet, V. Udayabhanu, T. Wood, and P. Shenoy. Benchlab:
An open testbed for realistic benchmarking of web applications.
In
Proceedings of the 2nd USENIX Conference on Web Application De-
velopment, 2011.
[5] GreenSQL. http://www.greensql.net.
[6] W. Halfond and A. Orso. AMNESIA: analysis and monitoring for neu-
tralizing SQL-injection attacks. In Proceedings of the 20th IEEE/ACM
International Conference on Automated Software Engineering, pages
174–183, Nov. 2005.
[7] W. Halfond, A. Orso, and P. Manolios. WASP: protecting web
applications using positive tainting and syntax-aware evaluation. IEEE
Transactions on Software Engineering, 34(1):65–81, 2008.
info security. SQL Injection Flaw Found in Mossack Fonseca CMS,
Apr. 2016. http://www.infosecurity-magazine.com/news/sql-injection-
ﬂaw-mossack-fonseca/.
[8]
[9] A. Lerner, J. Skorupa, and D. Ciscato. Gartner Inc. Magic quadrant for
application delivery controllers. 2016.
[10] W. Masri and S. Sleiman. SQLPIL: SQL injection prevention by input
Security and Communication Networks, 8(15):2545–2560,
labeling.
2015.
I. Medeiros, M. Beatriz, N. F. Neves, and M. Correia. Hacking the
DBMS to prevent injection attacks. In Proceedings of the Sixth ACM
Conference on Data and Application Security and Privacy, pages 295–
306, Mar. 2016.
[11]
[12] Percona toolkit. https://www.percona.com.
[13] PHP Address Book. http://php-addressbook.sourceforge.net.
[14] T. Pietraszek and C. V. Berghe. Defending against injection attacks
through context-sensitive string evaluation. In Proceedings of the 8th
International Conference on Recent Advances in Intrusion Detection,
pages 124–145, 2005.
refbase. http://http://www.refbase.net.
[15] Quinta. http://www.navigators.di.fc.ul.pt/wiki/Quinta.
[16]
[17] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen, and
A.-R. Sadeghi. Just-in-time code reuse: On the effectiveness of ﬁne-
grained address space layout randomization. In Proceedings of the IEEE
Symposium on Security and Privacy, pages 574–588, 2013.
[18] S. Son, K. S. McKinley, and V. Shmatikov. Diglossia: detecting code
injection attacks with precision and efﬁciency. In Proceedings of the
20th ACM Conference on Computer and Communications Security,
pages 1181–1192, 2013.
sqlmap. https://github.com/sqlmapproject/testenv/tree/master/mysql.
[19]
558
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:04:13 UTC from IEEE Xplore.  Restrictions apply.