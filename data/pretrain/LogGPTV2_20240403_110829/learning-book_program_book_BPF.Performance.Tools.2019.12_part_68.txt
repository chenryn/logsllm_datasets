execsnoop(8) was introduced in Chapter 6; it is a BCC and bpftrace tool to trace new processes,
and can be used to identify suspicious process execution. Example output:
execsnoop
PCOMX
PID
PPID
RET ARGS
1s
7777
21086
0/bin/1s -F
a,out
7778
21086
0/tnp/a. out
[...]
This shows a process executing from /tmp named a.out.
execsnoop(8) works by tracing the execve(2) syscall. This is a typical step in the creation of new
processes, which begins by calling fork(2) or clone(2) to create a new process and calls execve(2) to
execute a different program. Note that this is not the only way new software can execute: a buffer
overflow attack can add new instructions to an existing process, and execute malicious software
without needing to call execve(2)
See Chapter 6 for more about execsnoop(8).
---
## Page 534
11.2 BPF Tools
497
11.2.2 elfsnoop
elfsnoop(8)* is a bpftrace tool to trace the execution of binary files of the executable and linking
format (ELF) commonly used on Linux. This traces execution from deep in the kernel, from a
function where all ELF execution must pass. For example:
+ elfsnoop.bt
Attaching 3 probes...
Tracing ELF loads. Ctr1-C to end
TIME
PID
INTERPRETER
FILE
LNDOK
INCDE
RET
11:18:43 9022
/bin/1s
 /bin/1s
29098068
11:18:45 9023
/ tnp /1.s
/tnp/1.s
/us/bin/pythsn
23462045
11:18:49 9029
fddoousoado/*
20190728
[...]
This shows the executed file with various details. Columns are:
 TIME: Timestamp as HH:MM:SS.
• PID: Process ID.
 INTERPRETER: For scripts, the interpreter that was executed.
• FILE: Executed file.
• MOUNT: Mount point for the executed file.
 INODE: Index node number for the executed file: with the mount point, this forms a
unique identifier.
• RET: Return value from the attempted execution. 0 is success.
The mount point and inode number are printed out for further verification of the executed
binary. An attacker may create their own version of system binaries with the same name (and
perhaps use control characters so that when displayed it appears to have the same path as welI),
but these attacks will be unable to spoof the mount point and inode combination.
This tool works by tracing the load_elf_binary0 kermel function, which is responsible for loading
new ELF programs for execution. The overhead of this tool should be negligible, as the rate of this
function should be low.
The source to elfsnoop(8) is:
#1/usx/local/bin/bpEtrace
#1nclude 
include 
#1nc1ude 
4 0rigin: 1 created it for this book on 25-Feb-2019.
---
## Page 535
498
 Chapter 11 Security
BEGIN
printf (*Tracing ELF loads. Ctr]C to end`n*) 
printf(*4=8s 5=6s 18s 18s 10s 510s RET',n²,
kprobe:1oad_e1f_b1nary
o6xe = [pTlobxe8
kretprobe:load_elf_binary
/Barg0 [t1d]/
Sbin = (struct 11nux_binpxn *) Barg0[t1d]
time I**B:M:s *)
printf(*6d s-18s 1-18s 1-10s 110d 3d`n*, p1d,
str($bin=>interp) 。 str ($bin->filename]  
stx (Sbln=>11e=>f_path,mnt=>nnt_root=>d_name nae) ,
$bin=>file=>f_inode->i_ino, retval1 
delete (faxg0[tid]1 
This tool can be enhanced to print extra details about the file that is executed, including the full
path. Note that bpftrace currently has a seven-element limit to printf(), so multiple printf()s will
be necessary to print extra fields.
11.2.3 modsnoop
modsnoop(8)a is a bpftrace tool to show kernel module loads. For example:
 nodsnoop.bt
Attach.ing 2 probes...
Tracing keznel nodule loads. Hit Ctz1C to end.
12:51:38 module init: msr, by modprobe (PID 32574, user root, UID 0)
[..-]
This shows that at 10:50:26 the *msr" module was loaded by the modprobe(8) tool, with UID 0.
Loading modules is another way for the system to execute code, and is one way that various
rootkits work, making it a target for security tracing.
5 0rigin: I created it for this book on 14-Mar-2019
---
## Page 536
11.2 BPF Tools
499
The source to modsnoop(8) is:
#1/usx/local/bin/bpftrace
#Include 
BEGIX
printf (*7racing keznel nodule 1oads. Hlt Ctz1~C to end. n*);
kprobe :do_in1 t_nodule
Snod = (struct module *)axg0;
time (*:H:S *)
printf (*nodule init: ls, by Is (PID 5d, usez 5s, UID 4d)\n*,
$mod->nane, comn, pid, usernane, uid) :
This works by tracing the do_init_module( kernel function, which can access details from the
module struct.
There is also a module:module_load tracepoint, used by later one-liners.
11.2.4 bashreadline
bashreadline(8) is a BCC and bpftrace tool to trace interactively entered commands in the bash
shell, system-wide. For example, running the BCC version:
bashreadline
bashreadline
7IHE
PID
CONMAND
11 :43: 51
210861s
11 :44: 07
21086
echo heLlo book readers
11:44:22
21086
eccho hi
11 :44: 33
21086
/tnp/1s
[...]
This output shows commands that were entered while tracing, including shell built-ins (echo)
and commands that failed (eccho). This works by tracing the readline) function from the bash
6 0rigjin: I wrote the frst version for BCC on 28-Jar-2016 and for bpftrsce on 6-Sep-201.8. These were created a5
especially for loging activity in locked-down esironments where only one shell(bash) can be used.
---
## Page 537
009
Chapter 11 Security
shell, so any entered command will be shown. Note that while this can trace commands across all
shells running on the system, it cannot trace commands by other shell programs, and an attacker
may install their own shell (e.g., a nanoshell) that is not traced.
bpftrace
The following is the code for the bpftrace version.
1/usz/local/bin/bpftrace
BEGIN
printf (*Tracing bash commands... Hit Ctr]C to end. .n*) :
printf(*=9s 5=6s s\n”, "TIYE”, *PID”, "COMAND*)
uretprobe:/bin/bash:readline
time ("sB: M:1S *) ;
printf(*s=6d ss^n*, pid, ste(retval1)
This traces the readline) function in /bin/bash using a uretprobe. Some Linux distributions build
bash differently such that readline( is used from the libreadline library instead; see Section 12.2.3
in Chapter 12 for more about this and tracing readlline().
11.2.5 shellsnoop
shellsnoop(8) is a BCC and bpftrace tool that mirrors the output from another shell session. For
example:
+shel1snoop 7866
bgzegg:~/Bu11d/bpftrace/too1s> date
Fri Ray 31 18:11:02 F07 2019
bgregg:/Bu1ld/bpftrace/too1s> echo He11o BPF
bgzegg:~/Bu11d/bpftrace/too1s> typo
Connand 'typo′ not found, did you nean:
Khotoutueq gep uong ,dod., puewmco
Txy: apt install 
7 Origin: I wrote the BCC version on 15-0ct-2016 and the bpftrace version on 31-May-2019. These were based on
Phrack ezine by Bors Loza as a security forensics tool [132].
o e u pouoa sem doousgaus agea w saulea g podsu *toog-set woy oos doousijas soljea A
---
## Page 538
11.2  BPF Tools
501
This shows the commands and output from a shell session with PID 7866. It works by tracing writes
by that proces to STDOUT or STDERR, including children of that process. Tracing children is
necessary to catch the output of their commands, such as the output of date(1) seen in this output.
:apduexa rog xdpos aqs keqdas e nta of uogdo ue seq osje (s)doousaqs
9981 1- d0ouetteqe +
echo -e *dc*
sleep 0.10
echo -e *a\,c*
sleep 0.06
echo =e *tc*
sleep 0.07
o)e,9-oqoe
sleep 0.25
echo -e 
\c*
sleep 0.00
6T07 IGa S0s=eT 1c ex Taa, - oqa
\c*
This can be saved to a file and executed using the bash(1) shell: it then replays the shell session
output with the original timing. It's a little spooky.
BCC
Command line usage:
shellsnoop [optlons] PID
Options include:
● s: Shell only output (no subcommands)
: Replay shell script
bpftrace
This bpftrace version shows the core functionality:
+1/usr/local/bin/bpft.race
BEGIN
/0 == 1s/
the future by smitching from PF stack storge to map storage for strings.
---
## Page 539
502
Chapter 11 Security
printf (*vsAGE: shel1sneop,bt PIDn*) =
ex1t1) :
tracepoint:sched:sched_process_fork
/ [ptduezedchild_p1d] = 1;
tracepointisyscallsisys_enter_vrite
/(z == pbuf, args=>count)) 
11.2.6
ttysnoop
ttysnoop(8)?° is a BCC and bpftrace tool to mirror output from a tty or pts device. This can be used
to watch a suspicious login session in real time. For example, watching /dev/pts/16:
 ttysnoop 16
$ unane -a
Linux 1gud=bgzegg 4.15,0=43-gener1e 446=buntu SMP Thu Dec 6 14:45:28 UTC 2018 x85_64
x86_64 x8 6_64 G0/Linux
$ gcc -o a,out crack,c
no'e/* $
Segnentation fault
[...]
The output duplicates what the user on /dev/pts/16 is seeing. This works by tracing the tty_write()
kernel function, and printing what is being written.
BCC
Command line usage:
ttysnoop [options]device
Options include:
 -c: Don’t clear the screen
9 0rigjin: I wrote the BCC tool on 15-0ct-2016, inspired by an older Unix tool called ttywatcher, and my earier ouckoo.d
tool from 201.1. As a sysadmin, I used ttywstcher to watch a non-root intruder in real time on a production system s5
they downlosded various privilege escslation exploits, compiled them, and ran them without success. Most annoying
of all sthing them use the pico text editor insted of my frite, v. Fr amore esciting story of TT sopin, ee
[Stoll 89], which was the inspiration for cuckoo.d. I wrote the bpftrace version for this book on 26-Feb2019,
---
## Page 540
11.2 BPF Tools
503
The device is either a full path to a pseudo terminal, e-g., /dev/pts/2, or just the number 2, or
another tty device path: e.g., /dev/tty0. Running ttysnoop(8) on /dev/console shows what is
printed on the system console.
bpftrace
The following is the code for the bpftrace version:
+1/usr/local/bin/bpftrace
include 
BEGIN
1
if ($1 == 0)(
pxintr (*osAGE: ttysncop,bt pta_device
# eg, pts14`n*);
exit (1 
printf(*Tracing tty vrites. Ctel-C to end.\n*)
kprobe : tty_vr 1 te
rQ6xe (+ Ta omaas) - TT3$
:sxd, sdtxe c+ / /
1f (stx ($f1le=>f_path,dentry>d_nane,nane] == str ($1 + 3)1 [
printf ("es", str (a.rgl, arg211
This is an example of a bpftrace program that takes a required argument. If the device name is not
specified, a USAGE message is printed, and bpftrace exits. This exit is necessary because tracing all
devices will mix the output together and create a feedback loop with the tool itself.
11.2.7
opensnoop
tool to trace file opens, which can be used for a number of security tasks, such as understanding
opensnoop(8) was covered in Chapter 8 and shown in earlier chapters; it is a BCC and bpftrace
malware behavior and monitoring file usage. Example output from the BCC version:
1 open.snoop
PID
COMK
FD ERR FATH
12748apensnosp
-1
2 /usz/11b/python2. 7/encodLnga/asc11.x86_6411nux=gnu,so
12748
dooosusdo
-1 
2/usr/lib/python2. 7/encodings/ascii .s0
12748opensnoop
-1
2/usz/11b/python2.7/encodings/asc11nodu1e .so
---
## Page 541
504
Chapter 11 Security
dooossad99T
18 0/usz/1ib/python2. 7/encodings/ascii -pY
12748
 opensnocp
19
0/usz/11b/python2 7/encodinga/asc11-pyc
1222
polkitd
11
pAεsed/oα/ 0
1222
po1kitd
11
0 /proc/11881/status
1222
PITXod
11
0 /proc/11881/stat
1222
po1k1td
11
0/etc/passvd
1222
polkitd
11
0/proc/11881/status
1222
po1kitd
11
0 /pxoc/11881/stat
1222
po1kitd
11
0/proc/11881/cgroup
1222
po1kitd
11
0 /pxoc/1/cgroup
1222
polkitd
11 0 /run/systend/sessions/2
[..-]
This output shows opensnoop(8) searching for and then loading an asci python module: the
first three opens were unsuccessful. Then polkitd(8) (PolicyKit daemon) is caught opening the
passwd file and checking process statuses. opensnoop(8) works by tracing the open(2) variety
of syscalls.
See Chapter 8 for more about opensnoop(8).
11.2.8 eperm
eperm(8)1# is a bpftrace tool to count syscalls that failed with either EPERM *operation not
permitted or EACCES *permission denied” errors, both of which may be interesting for security
analysis. For example:
+ eperm.bt
Attaching 3 pzobes...
Tracing EACCEss and EPERM syscall errors. Ctrl-C to end.
°C
?EACCEss[systend-1ogind,sys_setsockopt] : 1
@EPERM[cat, sys_openat]: 1
eEPERM[gnsin, ays_inotify_add_ratch] : 6
This shows the process name and the syscall that failed, grouped by failure, For example, this
output shows there was one EPERM failure by cat(1) for the openat(2) syscall. These failures can
be further investigated using other tools, such as opensnoop(8) for open failures.
This works by tracing the raw_syscalls:sys_exit tracepoint, which fires for all syscalls. The
overhead may begin to be noticeable on systems with high I/O rates; you should test in a lab
environment.
10 0rigin: I crested it for this book on 25-feb-2019
---
## Page 542
11.2 BPF Tools
505
The source to eperm (8) is:
#1/usx/local/bin/bpftrace
BEGIX
1
printf (*Tracing EACCEss
and EPERH syscall ezrors. Ctz1C to end.\n*);
tracepoint:rax_syscalls1ays_exi t
/args->ret 
-1 f
count (1 
tracepoint:rax_syscal1s:sys_ex1 t
/1- =* 2id * 8)) ] =
count (1 #
The raw_syscalls:sys_exit tracepoint provides only an identification number for the syscall. To