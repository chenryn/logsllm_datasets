## 完整性摘要算法保证了"数字摘要"和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。比如，你发了条消息："转账 1000 元"，然后再加上一个 SHA-2的摘要。网站收到后也计算一下消息的摘要，把这两份"指纹"做个对比，如果一致，就说明消息是完整可信的，没有被修改。如果黑客在中间哪怕改动了一个标点符号，摘要也会完全不同，网站计算比对就会发现消息被窜改，是不可信的。不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。这有个术语，叫哈希消息认证码（HMAC）。![](Images/ab216cef83e4b5b56e6611ba17bc1eeb.png){savepage-src="https://static001.geekbang.org/resource/image/c2/96/c2e10e9afa1393281b5633b1648f2696.png"}
## 数字签名加密算法结合摘要算法，我们的通信过程可以说是比较安全了。但这里还有漏洞，就是通信的两个端点（endpoint）。就像一开始所说的，黑客可以伪装成网站来窃取信息。而反过来，他也可以伪装成你，向网站发送支付、转账等消息，网站没有办法确认你的身份，钱可能就这么被偷走了。现实生活中，解决身份认证的手段是签名和印章，只要在纸上写下签名或者盖个章，就能够证明这份文件确实是由本人而不是其他人发出的。你回想一下之前的课程，在 TLS里有什么东西和现实中的签名、印章很像，只能由本人持有，而其他任何人都不会有呢？只要用这个东西，就能够在数字世界里证明你的身份。没错，这个东西就是非对称加密里的"**私钥**"，使用私钥再加上摘要算法，就能够实现"**数字签名**"，同时实现"身份认证"和"不可否认"。数字签名的原理其实很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。但又因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。![](Images/b105f30dc4176a44083bb1893337e43c.png){savepage-src="https://static001.geekbang.org/resource/image/84/d2/84a79826588ca35bf6ddcade027597d2.png"}刚才的这两个行为也有专用术语，叫做"**签名**"和"**验签**"。只要你和网站互相交换公钥，就可以用"签名"和"验签"来确认消息的真实性，因为私钥保密，黑客不能伪造签名，就能够保证通信双方的身份。比如，你用自己的私钥签名一个消息"我是小明"。网站收到后用你的公钥验签，确认身份没问题，于是也用它的私钥签名消息"我是某宝"。你收到后再用它的公钥验一下，也没问题，这样你和网站就都知道对方不是假冒的，后面就可以用混合加密进行安全通信了。实验环境的 URI"/25-2"演示了 TLS 里的数字签名，它使用的是 RSA1024。
## 数字证书和 CA到现在，综合使用对称加密、非对称加密和摘要算法，我们已经实现了安全的四大特性，是不是已经完美了呢？不是的，这里还有一个"**公钥的信任**"问题。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么来判断这个公钥就是你或者某宝的公钥呢？真是"按下葫芦又起了瓢"，安全还真是个麻烦事啊，"一环套一环"的。我们可以用类似密钥交换的方法来解决公钥认证问题，用别的私钥来给公钥签名，显然，这又会陷入"无穷递归"。但这次实在是"没招"了，要终结这个"死循环"，就必须引入"外力"，找一个公认的可信第三方，让它作为"信任的起点，递归的终点"，构建起公钥的信任链。这个"第三方"就是我们常说的**CA**（CertificateAuthority，证书认证机构）。它就像网络世界里的公安局、教育部、公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。CA对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成"**数字证书**"（Certificate）。知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let'sEncrypt 等，它们签发的证书分 DV、OV、EV 三种，区别在于可信程度。DV 是最低的，只是域名级别的可信，背后是谁不知道。EV是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份（在浏览器地址栏会显示出公司的名字，例如Apple、GitHub 的网站）。不过，CA 怎么证明自己呢？这还是信任链的问题。小一点的 CA 可以让大 CA签名认证，但链条的最后，也就是**RootCA**，就只能自己证明自己了，这个就叫"**自签名证书**"（Self-SignedCertificate）或者"**根证书**"（RootCertificate）。你必须相信，否则整个证书信任链就走不下去了。![](Images/1caea09c6f9e7a330ac48dd7857de8fd.png){savepage-src="https://static001.geekbang.org/resource/image/8f/9c/8f0813e9555ba1a40bd2170734aced9c.png"}有了这个证书体系，操作系统和浏览器都内置了各大 CA的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（CertificateChain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。我们的实验环境里使用的证书是"野路子"的自签名证书（在 Linux 上用 OpenSSL命令行签发），肯定是不会被浏览器所信任的，所以用 Chrome访问时就会显示成红色，标记为不安全。但你只要把它安装进系统的根证书存储区里，让它作为信任链的根，就不会再有危险警告。![](Images/cd0f566511131030be6580d9bab3fc5b.png){savepage-src="https://static001.geekbang.org/resource/image/a5/8f/a55051ca7ae941ae04791cdddde6658f.png"}
## 证书体系的弱点证书体系（PKI，Public KeyInfrastructure）虽然是目前整个网络世界的安全基础设施，但绝对的安全是不存在的，它也有弱点，还是关键的"**信任**"二字。如果 CA失误或者被欺骗，签发了错误的证书，虽然证书是真的，可它代表的网站却是假的。还有一种更危险的情况，CA 被黑客攻陷，或者 CA有恶意，因为它（即根证书）是信任的源头，整个信任链里的所有证书也就都不可信了。这两种事情并不是"耸人听闻"，都曾经实际出现过。所以，需要再给证书体系打上一些补丁。针对第一种，开发出了 CRL（证书吊销列表，Certificate revocation list）和OCSP（在线证书状态协议，Online Certificate StatusProtocol），及时废止有问题的证书。对于第二种，因为涉及的证书太多，就只能操作系统或者浏览器从根上"下狠手"了，撤销对CA 的信任，列入"黑名单"，这样它颁发的所有证书就都会被认为是不安全的。
## 小结今天我们学习了数字签名和证书、CA，是不是有种"盗梦空间"一层套一层的感觉？你可以在课后再去各大网站，结合它们"小锁头"里的信息来加深理解。今天的内容可以简单概括为四点：1.  [摘要算法用来实现完整性，能够为数据生成独一无二的"指纹"，常用的算法是    SHA-2；]{.orange}2.  [数字签名是私钥对摘要的加密，可以由公钥解密后验证，实现身份认证和不可否认；]{.orange}3.  [公钥的分发需要使用数字证书，必须由 CA    的信任链来验证，否则就是不可信的；]{.orange}4.  [作为信任链的源头 CA 有时也会不可信，解决办法有    CRL、OCSP，还有终止信任。]{.orange}
## 课下作业1.  为什么公钥能够建立信任链，用对称加密算法里的对称密钥行不行呢？2.  假设有一个三级的证书体系（Root CA=\> 一级 CA=\> 二级    CA），你能详细解释一下证书信任链的验证过程吗？欢迎你把自己的学习体会写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。![](Images/c4aa9b2fd3b5ccd035042e6c4bdbd9c9.png){savepage-src="https://static001.geekbang.org/resource/image/37/57/37c59439c36e75f610fe84c22009cc57.png"}![unpreview](Images/4913a489805db29b38aefa585223c013.png){savepage-src="https://static001.geekbang.org/resource/image/56/63/56d766fc04654a31536f554b8bde7b63.jpg"}
# 26 \| 信任始于握手：TLS1.2连接过程解析经过前几讲的介绍，你应该已经熟悉了对称加密与非对称加密、数字签名与证书等密码学知识。有了这些知识"打底"，现在我们就可以正式开始研究 HTTPS 和 TLS 协议了。
## HTTPS 建立连接当你在浏览器地址栏里键入"**https**"开头的URI，再按下回车，会发生什么呢？回忆一下[第 8讲](https://time.geekbang.org/column/article/100502)的内容，你应该知道，浏览器首先要从URI里提取出协议名和域名。因为协议名是"https"，所以浏览器就知道了端口号是默认的443，它再用 DNS 解析域名，得到目标的 IP地址，然后就可以使用三次握手与网站建立 TCP 连接了。在 HTTP 协议里，建立连接后，浏览器会立即发送请求报文。但现在是 HTTPS协议，它需要再用另外一个"握手"过程，在 TCP 上建立安全连接，之后才是收发HTTP 报文。这个"握手"过程与 TCP 有些类似，是 HTTPS 和 TLS协议里最重要、最核心的部分，懂了它，你就可以自豪地说自己"掌握了 HTTPS"。