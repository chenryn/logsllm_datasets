3
2
RBP
EBP
BP
BPL
帧指针（FramePointer），通常是局部变量的指针。在调用函数时，它也常常用来传递参数。有关这个
寄存器的详细介绍，请参照本书的7.1.2节。
A.2.17 RIP/EIP/IP
7
4
3
RIP""
EIP
指令指针instruction pointer应当总是指向接下来将要执行的那条指令。正常情况下，无法直接干预它
的值。但是，下述指令可以等效地实现调整指令指针的功能：
JMP EAX
MOV EAX,
或者：
9ST
PUSH
Value
---
## Page 437
附录Ax86
16
A.2.18段地址寄存器CS/DS/ES/SS/FS/GS
CS/DS/SS/ES 分别代表Code Segment 代码段寄存器、Data Segment 数据段寄存器、Stack Segment 堆栈
段寄存器和Extra Segment附加段寄存器。
在Win32系统里，FS 附加段寄存器（Extra Segment Register）承担TLS（线程本地存储/Thread Local
Storage）的角色：而在Linux系统里，GS（另一个附加段寄存器）承担这个角色。早期，这两个寄存器用
于实现段式寻址：而现在，它们用于提供更为快速的TLS和TIB（线程信息块/ThreadInformationBlock）功
能。有关段地址寄存器的详细介绍，请参见本书第94章。
A.2.19标识寄存器
标识寄存器即 Eflags
Bit位（及掩码）
缩写（及含义）
捐
述
0 (1)
CF（速/替位）
除了常规计算指令之外，专门操作CF的指令还有CLCSTCCMC
2 (4)
PF（奇偶标识位）
参见17.7.1 节
4 (0x10)
AF（辅助速/借位标识）
6 (040)
ZF（零标识位）
ZF用来反晚运算结果是否为0.如果运算结果为0，则其值为1.
否则其值为0
7 (0x80)
SF(号位)
8 (0x100)
TF （追踪标识)
当追踪标志TF被置为I时，CPU进入单步执行方式，即每执行
条指令，产生一个单步中断请求，这种方式主要用于程序的调试
9 (0h200)
IF（中斯允许标识）
中斯允许标志用来决定CPU是西响应CPU外部的可屏蔽中斯发出
的中斯请求，CLI/STI指令可对它进行赋值
决定在执行串操作指令（REPMOVSx、REPCMPSx、REPLODSx
10 (0400)
DF（方向标识）
和REPSCASx）时有关指针寄存器发生调整的方向，CLD/STD指令
可对它进行赋值
11 (0x800)
OF(爱出标识)
12,13 (03000)
IOPL（10特权标识）%
14 (0x4000)
NT（嵌套任务标志）
16 (0x10000)
RF (董自标识) M8
重启动标识用来控制是否接受调试，如果它的值为1，那么CPU将
忽略 DRx中的硬件斯点调试功能
17 (0x20000)
VM（虚报8086方式标志）
18 (0x40000)
AC（对准校验方式位）
19 (0x80000)
VIF（虚拟中新标志）Aw
20 (0x100000)
VIP（虚拟中断术决标志）m
21 (0x200000)
ID（标识标志）Nrr
其余的标识位都是保留标识位。
A.3
FPU寄存器
FPU栈由8个80位寄存器构成，这8个寄存器分别叫作ST（0）~ST（7）。IDA把ST（0）显示为
ST。FPU寄存器用于存储符合IEEE754标准的longdouble型数据。这种数据的格式如下表所示。
第 79 位
第 78-64 位
第63位
第 62-0 位
符号位
指数位
整数位
尾数（小数）位
---
## Page 438
914
逆向工程权威指南（下册）
A.3.1控制字寄存器（16位）
FPU 的控制字（Control Word）用于控制FPU的行为。
位
维写（及含义）
述
IM（无效操作掩码）
DM（操作数规格异常掩码）
2
ZM（除数为0的掩码）
3
OM（上源/覆出掩码)
UM(下澄/覆出掩码)
5
PM（精度异常掩码）
7
IEM（异常中断位/软件处理控制位）
值，若IEM为0，则由FPU处理所有的异常信息，从而对软件屏
第0~5位拖码控制功能的总开关，现在的 FPU已经不可对其赋
嵌了所有的错误信息，款认值为1
00:IEEE单精度 24亿（REAL4)
8, 9
PC（精度控制）
01: 保B
10:IEE 双精度 53位（REAL8)
11:IEEE 扩展双精度64位（REAL.10)
00：就近含入（默认）
10. 11
RC（舍入控别）
01：向-∞舍入
10：+入
11：截断（向零含入）
12
IC（无限/∞控制位)
0：按照 unsigned 处理士oo（初始态）
1：按照 signed 处理∞
若PM、UM、OM、ZM、DM、IM字段（第0~5位）设置为1，则由FPU处理异常信息（对软件屏
蔽了错误信息）：若某位设置为0，则FPU将会在遇到相应异常时进行中断、释放异常信息给应用程序，
程序在处理之后再把控制权返还给FPU.
A.3.2状态字寄存器（16位）
FPU的状态寄存器又称Fstate，属于只读寄存器。
位序
蟾写（及含文）
描
15
B (忙)
1:FPU 正在进行运算
0:FPU可进行下次运算
14
C3（条作代码位C3）
13, 12, 11
TOP（栈预指针)
ST（0）使用的物理寄存器
10
C2（条件代码位C2）
9
C1（条件代码位C1）
8
CO（条件代码位C0)
7
IR（中斯请求)
6
SF(栈异常)
5
P（精度）
4
U (下澄)
3
0 (.上湿)
2
Z（运算结果为零）
1
D（操作数规格异常)
0
I（无效操作)
---
## Page 439
附录Ax86
915
状志位SF、P、U、O、Z、D、I用于异常反馈。
有关C3、C2、CI、C0的更详细介绍，请参见本书的17.7.1节。
在软件使用st（x）时，FPU会计算x与栈项指针序号的和，必要的时候还会再计算8的模（余数），
以此确定栈指针的物理寄存器地址。
A.3.3标记字寄存器（16位）
标志字寄存器总共16位。每2位为一组，表示FPU数据寄存器的使用情况，
位序
描述
15, 14
Tag (7)
13, 12
Tag (6)
11. 10
Tag (5)
9, 8
Tag (4)
7, 6
Tag (3)
5, 4
Tag (2)
3. 2
Tag (1)
1. 0
Tag (0)
Tag（x）存储着FPU物理寄存器R（x）的状态码。
其各值的代表含义是：
00：该寄存器存储着非零的值。
●01：该寄存器存储的值为零。
10：寄存器的值为特殊的值，NAN、0或者无效操作数。
11：寄存器为空。
A.4
SIMD寄存器
A.4.1MMX寄存器
MMX寄存器由8个64位寄存器（MM0~MM7）组成。
A.4.2SSE与AVX寄存器
SSE都有XMM0~XMM7这8个128位寄存器，x86-64系统还有额外的8个寄存器（XMM8~XMM15)。
面支持AVX指令集的CPU，它们把XMM*寄存器扩充为256位寄存器。
A.5FPU调试睿存器
调试寄存器（Debugging registers）用于实现基于硬件的断点控制。
·DR0为第1个断点的地址（线性地址）。
●DR1为第2个断点的地址，
·DR2为第3个断点的地址。
●DR3为第4个断点的地址。
①请注意，Tag（x）精述的不是 FPU 逻调寄存器 ST（x）的状态。
---
## Page 440
916
逆向工程权威指南（下册）
DR6为调试状态寄存器。在调试过程异常时，它负责报告产生异常的原因。
DR7为用于控制断点调试。
A.5.1DR6规格
位序(掩码)
描
述
0 (1)
B0：舱发了斯点DR0
1(2)
B1:触发了断点 DR1
2 (4)
B2：触发了断点DR2
3 (8)
B3:触发了断点 DR3
13 (0x2000)
BD：仅在DR7的GD为1的情况下有效。只有当下一条指令要访问到某一个调试寄存器的时
候，BD 位才被置位（1)
14 (0x4000)
BS：当进行单步调试的时候，即EFLAGS的TF标识位被置位的时候，BS才被置位，单步调
试具有最高的调试优先级，不受其他标识位影响
15 (0x8000)
BT：任务切换标识位
单步调试断点是在执行一条指令之后发生的断点。设置EFLAGS（附录AL2.19）的TF标识，即可实
现单步调试。
A.5.2DR7规格
DR7用于控制断点类型。
位序（掩码）
插
述
0 (1)
L0:在当前任务的DRO处设置新点
1 (2)
G0：在所有任务中都设置DR9的断点
2 (4)
L1：在当前任务的DR1处设置新点
3 (8)
G1：在所有任务中都设置DR1的断点
4 (0x10)
L2：在当前任务的DR2处设置新点
5 (0x20)
G2：在所有任务中都设置DR2的断点
6 (0x40)
L3:在当前任务的DR3处设置新点
7 (0x80)
G3：在所有任务中都设置DR3的断点
8 (0x100)
LE：P6以及P6以后的处理器不支持这个标识位。如果被置位，那么FPU将会在当前任务中
追踪精确的数据断点
9 (0x200)
GE：P6以及P6以后的处理器不支持这个标识位。如果被置位，那么FPU将会在所有任务中
治踪精确的数据断点
13 (0x2000)
GD：如果置位，那么当MOV指令修改DRx寄存器的值时，FPU将进行进行异常处理
16. 17 (0x3000)
断点DRO的触发条件
18, 19 (0xC000)
新点DR0的断点长度
20. 21 (0x30000)
新点DR1的触发条件
22.23（0xC0000)
斯点DR1的斯点长度
24. 25 (0x300000)
新点 DR2的敏发条作
26. 27 (0xC00000)
新点 DR2 的斯点长度
28.29 (0x300000)
新点DR3的触发条件
30.31(0xC000000)
新点 DR3 的斯点长度
其中，断点DRx的触发条件又分为：
---
## Page 441
附录Ax86
L16
00：执行指令。
·01：数据的写操作。
·10：读写I/O（Usermode下不可用）。
11：读写数据
可见，FPU断点的触发条件里没有“读取数据”这一项。
FPU断点长度的规格如下：
00：1个字节。
01：2个字节。
·10：32位系统中未定义，64位系统中代表8字节。
11：4个字节。
A.6指令
标记为（M）的指令通常都不是编译器生成的指令。这种指令或许属于手写出来的汇编代码，或许属
于编译器的内部指令（参见本书第90章）。
本节仅列举那些常见指令。如果需要查看完整的指令说明，请参见《Intel&64 andIA-32Architectures
Programmer’s Manual)。
我们是不是也要记住指令的opcode呢？除非您专门从事给代码打补丁的工作（参见本书第89章第2节），
否则没那种必要，
A.6.1指令前级
LOCK：数据总线封锁前缓。在执行LOCK作前缓的汇编指令时，它可起到独占数据总线的作用。简
单地说，在执行这种指令时，多处理器的其他CPU都将停下来、等该指令执行结束。这种指令常见于各种
关键系统、（硬件）信号量和互斥锁。
禁止协处理器修改数据总线上的数据，起到独占总线的作用。该指令的执行不影响任何标志位。它常
作为ADD、AND、BTR、BTS、CMPXCHG、OR、XADD、XOR指令的前级。本书的第 68章第4节详细
介绍了这种指令。
REP：与MOVSx和 STOSx指令结合使用，以福环的方式进行数据复制及数据存储。在执行REP指
令时，CX/ECX/RCX寄存器里存储的值将作为隐含的循环计数器。有关MOVSx和STOSx指令的详细说
明，请参见附录A.6.2。
REP指令属于DF敏感指令.DF标识位决定了它的操作方向。
REPE/REPNE：（又称为REPZ/REPNZ）与CMPSx和SCASx指令结合使用，以循环的方式进行数值
比较。在执行这种指令时，CX/ECX/RCX寄存器里存储的值将作为隐含的循环计数器。当ZF标识位
为0（REPE），或ZF标识位为1（REPNE）时，它将终止循环过程。
有关CMPSx和ISCASx的详细描述，请参见附录A.6.2和A.6.3.
REPE/REPNE指令属于DF敏感指令。DF标识位决定了它的操作方向。
A.6.2常见指令
ADC（进位加法运算）：在进行加法运算时，会把CF标识位代表的进位加入和中。它常见于较大数值的
加法运算，例如，在32位系统进行64位数值的加法运算时，会组合使用ADD和ADC指令，如下所示：
1 64 位值的运算;va12= va11 + va12
.1o 代表低32位，.hi代表高32夜。
---
## Page 442
918
逆向工程权威指南（下册）
ADo va11.1o, va12.10
ADC va11.hi,va12.hi:会使用上—条指令设置的 cF
本书的第24章有更为详细的使用案例。
ADD：加法运算指令。
AND：逻辑“与”运算指令。
CALL：调用其他函数。相当于“PUSH（CALL之后的返回地址）：JMPlabel”
CMP：比较数值、设置标识位。虽然它的运算过程确是减法运算，但是SUB指令保存运算结果（差）、
面CMP指令不保存运算结果。
DEC：递减运算，它不影响CF标识位。
IMUL：有符号数的乘法运算指令。
INC：递增运算。它不影响CF标识位。
JCXZ，JECXZ，JRCXZ（M）：当CX/ECX/RCX=0时跳转。
JMP：跳转到指定地址，相应的 opcode中含有转移偏移量（jump offset）。
Jee：条件转移指令。cec 是condition code 的缩写。
JAE即JNC：（unsigned）在大于或等于的情况下进行跳转：转移条件是CF=0。
JA 即JNBE：（unsigned）在大于的情况下进行跳转：转移条件是CF=0且 ZF=0。
JBE：（unsigned）在小于或等于的条件下进行跳转：转移条件是CF=1或ZF=1。
JB 即 JC：（unsigned）在小于的情况下进行跳转：转移条件是CF-1
JC即JB：在小于的情况下进行跳转：转移条件是CF=1。
JE即JZ：在相等的情况下进行跳转：转移条件是ZF=1。
JGE：（signed）在大于或等于的情况下进行跳转：转移条件是SF=OF.
JG：（signed）在大于的情况下进行跳转：转移条件是ZF=0且SF=OF。
JLE：（signed）在小于或等于的情况下进行跳转：转移条件是ZF-1或SF≠OF。
JL：（signed）在小于的条件下进行跳转：转移条件是SF≠OF。
JNAE即JC：（unsigned）在小于（不大于且不相等）的情况下进行跳转：转移条件是CF-1.
JNA：（unsigned）在不大于的情况下进行跳转：转移条件是CF=1或ZF=1。
JNBE：（unsigned）在大于的情况下进行转移：转移条件是CF=0且ZF=0。
JNB即JNC：（unsigned）在不小于的情况下进行跳转：转移条件是CF=0。
JNC即JAE：等同于JNB：转移条件是CF=0。
JNE即JNZ：在不相等的情况下进行跳转：转移条件是ZF=0.
JNGE：（signed）在不大于且不等于的情况下进行跳转：转移条件是SF≠OF。
JNG：（signed）在不大于的情况下进行跳转：转移条件是ZF-1或SF≠OF。
JNLE：（signed）在不大于且不相等的情况下进行跳转：转移条件是ZF=0且 SF=OF。
JNL：（signed）在不小于的情况下进行跳转：转移条件是SF=OF。
JNO：在不溢出的情况下进行跳转：转移条件是OF=0.
JNS：在SF标识位为0的情况下进行跳转。
JNZ即JNE：在不大于且不等于的情况下进行跳转：转移条件是ZF-0
JO：在溢出的情况下进行跳转：转移条件是OF-1。
JPO：在PF标识位为零的情况下进行跳转。
JP即JPE：在PF标识位为1的情况下进行跳转。
JS：在SF标识位为1的情况下进行跳转。
JIZ即JE：在操作数相等的情况下进行跳转：转移条件是ZF-1。
LAHF：标识位读取指令。它把标识位复制到AH寄存器。数权关系如下表所示。
---
## Page 443
附录Ax86
919
7
6
5
4
3
2
0
SF
ZF
AF
PF
CF
LEAVE：等效于“MOVESP，EBP”“POPEBP”指令的组合。即，这条指令释放当前子程序在堆栈
中的局部变量，恢复栈指针（stackpointer/ESP）和EBP寄存器的初始状态。
LEA：有效（偏移）地址传送指令。
这个指令并非调用寄存器的值，也不会进行地址以外的求值运算。它可利用数组地址、元素索引号和
元素空间进行混合运算，求得某个元素的有效地址。
所以，MOV和LEA指令有巨大的差别：MOV指令会把操作数的值当作地址、而后对这个地址的值
进行读写操作：而LEA就对操作数的地址进行直接处理。
因此，LEA指令也经常用于各种常规计算。
LEA指令有一个重要的特点—它不会影响CPU标识位的状态。对于OOE（乱序方式执行的指令）
处理器来说，这一特性有利于大幅度降低数据依赖性。
Int f(int a, int b)
return a*8+b;
使用MSVC2010（启用优化功能）编译上述程序，可得到：
指令清单A.1优化MSVC2010
_a$ - 8
/ 8i2e = 4
PROC
7 81ze = 4
_f
IOV
eax, DMORD PTR _b$[esp-4]
mOV
eCx, DMORD PTR _as[esp~4]
lea
eax, DMORD PTB [eax+ecx*8]
ret
_f
EXDP