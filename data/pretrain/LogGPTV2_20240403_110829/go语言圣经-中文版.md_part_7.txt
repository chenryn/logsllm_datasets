gopl
$ go doc http.ListenAndServe
package http // import "net/http"
func ListenAndServe(addr string, handler Handler) error
ListenAndServe listens on the TCP network address addr and then
calls Serve with handler to handle requests on incoming connections.
...
注释： 我们之前已经提到过了在源文件的开头写的注释是这个源文件的文档。在每一个函数
之前写一个说明函数行为的注释也是一个好习惯。这些惯例很重要，因为这些内容会被像
godoc这样的工具检测到，并且在执行命令时显示这些注释。具体可以参考10.7.4。
多行注释可以用 来包裹，和其它大多数语言一样。在文件一开头的注释一般都是
/* ... */
这种形式，或者一大段的解释性的注释文字也会被这符号包住，来避免每一行都需要加//。在
注释中//和/*是没什么意义的，所以不要在注释中再嵌入注释。
本章要点 50
gopl
第二章 程序结构
Go语言和其他编程语言一样，一个大的程序是由很多小的基础构件组成的。变量保存值，简
单的加法和减法运算被组合成较复杂的表达式。基础类型被聚合为数组或结构体等更复杂的
数据结构。然后使用if和for之类的控制语句来组织和控制表达式的执行流程。然后多个语句被
组织到一个个函数中，以便代码的隔离和复用。函数以源文件和包的方式被组织。
我们已经在前面章节的例子中看到了很多例子。在本章中，我们将深入讨论Go程序基础结构
方面的一些细节。每个示例程序都是刻意写的简单，这样我们可以减少复杂的算法或数据结
构等不相关的问题带来的干扰，从而可以专注于Go语言本身的学习。
程序结构 51
gopl
2.1. 命名
Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个
简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意
数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不
同的名字。
Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构
中使用。
break default func interface select
case defer go map struct
chan else goto package switch
const fallthrough if range type
continue for import return var
此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。
内建常量: true false iota nil
内建类型: int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
float32 float64 complex128 complex64
bool byte rune string error
内建函数: make len cap new append copy close delete
complex real imag
panic recover
这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景
中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。
如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，
那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可
见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函
数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的
Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。
名字的长度没有逻辑限制，但是Go语言的风格是尽量使用短小的名字，对于局部变量尤其是
这样；你会经常看到i之类的短名字，而不是冗长的theLoopIndex命名。通常来说，如果一个
名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。
命名 52
gopl
在习惯上，Go语言程序员推荐使用 驼峰式 命名，当名字有几个单词组成的时优先使用大小写
分隔，而不是优先用下划线分隔。因此，在标准库有QuoteRuneToASCII和parseRequestLine
这样的函数命名，但是一般不会用quote_rune_to_ASCII和parse_request_line这样的命名。
而像ASCII和HTML这样的缩略词则避免使用大小写混合的写法，它们可能被称为
htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。
命名 53
gopl
2.2. 声明
声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明
语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。这一章
我们重点讨论变量和类型的声明，第三章将讨论常量的声明，第五章将讨论函数的声明。
一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件中。每个源文件以包的声
明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其它包，
然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序
无关紧要（译注：函数内部的名字则必须先声明之后才能使用）。例如，下面的例子中声明
了一个常量、一个函数和两个变量：
gopl.io/ch2/boiling
// Boiling prints the boiling point of water.
package main
import "fmt"
const boilingF = 212.0
func main() {
var f = boilingF
var c = (f - 32) * 5 / 9
fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
// Output:
// boiling point = 212°F or 100°C
}
其中常量boilingF是在包一级范围声明语句声明的，然后f和c两个变量是在main函数内部声明
的声明语句声明的。在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而
不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部
很小的范围被访问。
一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一
个可选的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表
是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果
没有返回语句则是执行到函数末尾，然后返回到函数调用者。
我们已经看到过很多函数声明和函数调用的例子了，在第五章将深入讨论函数的相关细节，
这里只简单解释下。下面的fToC函数封装了温度转换的处理逻辑，这样它只需要被定义一
次，就可以在多个地方多次被使用。在这个例子中，main函数就调用了两次fToC函数，分别
是使用在局部定义的两个常量作为调用函数的参数。
声明 54
gopl
gopl.io/ch2/ftoc
// Ftoc prints two Fahrenheit-to-Celsius conversions.
package main
import "fmt"
func main() {
const freezingF, boilingF = 32.0, 212.0
fmt.Printf("%g°F = %g°C\n", freezingF, fToC(freezingF)) // "32°F = 0°C"
fmt.Printf("%g°F = %g°C\n", boilingF, fToC(boilingF)) // "212°F = 100°C"
}
func fToC(f float64) float64 {
return (f - 32) * 5 / 9
}
声明 55
gopl
2.3. 变量
var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始
值。变量声明的一般语法如下：
var 变量名字 类型 = 表达式
其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据
初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变
量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零
值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是
nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在
未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保
边界条件下的合理行为。例如：
var s string
fmt.Println(s) // ""
这段代码将打印一个空字符串，而不是导致错误或产生不可预知的行为。Go语言程序员应该
让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效
的零值状态。
也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变
量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推
导）：
var i, j, k int // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前
完成初始化（§2.6.2），局部变量将在声明语句被执行到的时候完成初始化。
一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：
var f, err = os.Open(name) // os.Open returns a file and an error
2.3.1. 简短变量声明
变量 56
gopl
在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字
:= 表达式”形式声明变量，变量的类型根据表达式来自动推导。下面是lissajous函数中的三个
简短变量声明语句（§1.4）：
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var形
式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初
始值无关紧要的地方。
i := 100 // an int
var boiling float64 = 100 // a float64
var names []string
var err error
var p Point
和var形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：
i, j := 0, 1
但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如for语
句的循环的初始化语句部分。
请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作。也不要混淆多个变量的声明和元
组的多重赋值（§2.4.1），后者是将右边各个的表达式值赋值给左边对应位置的各个变量：
i, j = j, i // 交换 i 和 j 的值
和普通var形式的变量声明语句一样，简短变量声明语句也可以用函数的返回值来声明和初始
化变量，像下面的os.Open函数调用将返回两个值：
f, err := os.Open(name)
if err != nil {
return err
}
// ...use f...
f.Close()
这里有一个比较微妙的地方：简短变量声明左边的变量可能并不是全部都是刚刚声明的。如
果有一些已经在相同的词法域声明过了（§2.7），那么简短变量声明语句对这些已经声明过
的变量就只有赋值行为了。
变量 57
gopl
在下面的代码中，第一个语句声明了in和err两个变量。在第二个语句只声明了out一个变量，
然后对已经声明的err进行了赋值操作。
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
解决的方法是第二个简短变量声明语句改用普通的多重赋值语言。
简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量
是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。
我们在本章后面将会看到类似的例子。
2.3.2. 指针
一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到
一个变量名，比如叫x的变量，但是还有很多变量始终以表达式方式引入，例如x[i]或x.f变量。
所有这些表达式一般都是读取一个变量的值，除非它们是出现在赋值语句的左边，这种时候
是给对应变量赋予一个新的值。
一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个
值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以
直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。
如果用“var x int”声明语句声明一个x变量，那么&x表达式（取x变量的内存地址）将产生一个
指向该整数变量的指针，指针对应的数据类型是 ，指针被称之为“指向int类型的指针”。
*int
如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。
同时 表达式对应p指针指向的变量的值。一般 表达式读取指针指向的变量的值，这里
*p *p
为int类型的值，同时因为 对应一个变量，所以该表达式也可以出现在赋值语句的左边，表
*p
示更新指针所指向的变量的值。
x := 1
p := &x // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2 // equivalent to x = 2
fmt.Println(x) // "2"
变量 58
gopl
对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应
一个变量，因此可以被取地址。
变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受 取
&
地址操作。
任何类型的指针的零值都是nil。如果p指向某个有效变量，那么 测试为真。指针之
p != nil
间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局
部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。
var p = f()
func f() *int {
v := 1
return &v
}
每次调用f函数都将返回不同的结果：
fmt.Println(f() == f()) // "false"