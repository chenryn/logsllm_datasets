mode at time T −  was still AC, and by inductive hypothesis
we know that the invariant held at that time; therefore, we
know that ReachM (sT−,∗, ∆) ⊆ φsaf e. Therefore, for the
period [T − , T −  + ∆], we know that the reached state will
be in φsaf e and the invariant holds. Moreover, SC will get
a chance to execute in this interval at least once, and hence,
from that time point onwards, Property (P2a) will guarantee
that the invariant holds.
(Case4) The current mode at time T is AC and there is a no
mode switch. Since there is no mode switch at T , it implies
that ReachM (sT ,∗, 2∆) ⊆ φsaf e and hence for the next ∆
time units, we are guaranteed that ReachM (sT ,∗, ∆) ⊆ φsaf e
holds.
The invariant established in Theorem 3.1 ensures that if the
assumptions of the theorem are satisﬁed, then all reachable
states are always contained in φsaf e.
Remark 3.1 (Guarantee switching and avoid oscillation):
The liveness property (P2b) guarantees that the system will
deﬁnitely switch from Nsc to Nac (to maximize performance).
Property (P3) ensures that the system will stay in the AC mode
for some time and not switch back immediately to the SC
mode. Note that property (P2b) is not needed for Theorem 3.1.
Remark 3.2 (AC is a black-box): Our well-formedness
check does not involve proving anything about Nac. (P1a)
and (P1b) require that Nac samples at most as fast as Ndm
and generates the same outputs as Nsc, this is for smooth
transitioning between Nac and Nsc. We only need to reason
about Nsc, and we need to reason about all possible controller
actions (when reasoning with ReachM (s,∗, ∆)). The latter is
worst-case analysis, and includes Nac’s behavior. One could
restrict behaviors to Nac∪Nsc if we wanted to be more precise,
but then Nac would not be a black-box anymore.
Our formalism makes no assumptions about the code (be-
havior) of the AC node, except that we do need to know the set
of all possible output actions (required for doing worst-case
reachability analysis). Theorem 3.1 ensures safety as long as
all output actions generated by the code AC (like in Figure 4)
belong to the assumed set of all possible actions.
Deﬁnition 3.1 (Regions): Let R(φ, t) = {s | s ∈ φ ∧
ReachM (s,∗, t) ⊆ φ}. For example, R(φsaf e, ∆) represents
the region or set of states in φsaf e from which all reachable
states in time ∆ are still in φsaf e.
Regions of operation of a well-formed RTA module. We
informally describe the behavior of an RTA protected module
by organizing the state space of the system into different
regions of operation (Figure 10). R1 represents the unsafe
region of operation for the system. Regions R2-R5 represent
the safe region and R3-R5 are the recoverable regions of the
state space. The region R3\R4 represents the switching control
region (from AC to SC) as the time to escape φsaf e for the
states in this region is less than 2∆.
6
As the DM is guar-
anteed to sample the
state of
the system
at
least once in ∆
time (property (P1a)),
the DM is guaran-
teed to switch con-
trol from AC to SC
if the system remains
in the switching con-
Fig. 10. Regions of Operation for an RTA
trol region for at least
Module.
∆ time, which is the
case before system can leave region R3. Consider the case
where T1 represents a trajectory of the system under the
inﬂuence of AC, when the system is in the switching control
region the DM detects the imminent danger and switches
control to SC. (P1a) ensures that Nsc takes control before
the system escapes φsaf e in the next ∆ time. Property (P2a)
ensures that the resultant trajectory T2 of the system remains
inside the safe region and Property (P2b) ensures that the
system eventually enters region R5 where the control can be
returned to AC for maximizing the performance of the system.
Property (P3) ensures that the switch to AC is safe and the
system will remain in AC mode for at least ∆ time.
Remark 3.3 (Choosing φsaf er and ∆): The value of ∆ is
critical for ensuring safe switching from AC to SC. It also de-
termines how conservatively the system behaves: for example,
large value of ∆ implies a large distance between boundaries
of region R4 and R5 during which SC (conservative) is in
control. Small values of ∆ and a larger R5 region (φsaf er) can
help maximize the use of AC but might increase the chances
of switching between AC and SC as the region between the
boundaries of R4 and R5 is too small. Currently, we let the
programmer choose these values and leave the problem of
automatically ﬁnding the optimal values as future work.
From theory to practice: We are assuming here that the
checks in Property (P2) and Property (P3) can be performed.
The exact process for doing so is outside the scope of this
paper. The popular approach in control
theory is to use
reachability analysis when designing an Nsc that always keeps
the system within a set of safe states. We used existing tools
like FastTrack [19] and the Level-Set Toolbox [20].
First, consider the problem of synthesizing the safe con-
troller Nsc for a given safe set φsaf e. Nsc can be synthesized
using pre-existing safe control synthesis techniques. For exam-
ple, for the motion primitives, we can use a framework like
FaSTrack [19] for synthesis of low-level Nsc. Next, we note
that the DM needs to reason about the reachable set of states
for a system when either the controller is ﬁxed to Nsc or is
nondeterministic. Again, there are several tools and techniques
for performing reachability computations [20]. One particular
concept that SOTER requires here is the notion of time to failure
less than 2∆ (ttf2∆). The function ttf2∆ : S × 2S → B,
given a state s ∈ S and a predicate φ ⊆ S returns true if
starting from s, the minimum time after which φ may not hold
7
is less than or equal to 2∆. The check Reach(st,∗, 2∆) (cid:54)⊆
φsaf e in Figure 9 can be equivalently described using the
ttf2∆ function as ttf2∆(st, φsaf e). Let us revisit the boolean
functions PhiSafer_MPr and TTF2D_MPr from Figure 7,
these functions correspond to the checks st ∈ φsaf er and
ttf2∆(st, φsaf e) respectively.
sc, N j
ac, N i
(cid:54)= j, {N i
then, for all i, j s.t. i
ac, N j
IV. OPERATIONAL SEMANTICS OF AN RTA MODULE
In SOTER, a complex system is designed as a composition
of RTA modules. An RTA system is a set of composable
RTA modules. A set of modules S = {M0, M1, . . . , Mn} are
composable if:
1. The nodes in all modules are disjoint, if N i
sc, and
dm represent the AC, SC and DM nodes of a module
N i
dm} ∩
Mi
{N j
dm} = ∅.
2. The outputs of all modules are disjoint, for all i, j s.t. i (cid:54)= j,
O(Mi) ∩ O(Mj) = ∅.
Note that only constraint for composition is that the outputs
(no constraints on inputs) must be disjoint as described by
traditional compositional frameworks like I/O Automata and
Reactive Modules [21], [22].
Composition. If RTA modules P and Q are composable then
their composition P (cid:107) Q is an RTA system consisting of the
two modules {P, Q}. Also, composition of two RTA systems
S1 and S2 is an RTA system S1∪S2, if all modules in S1∪S2
are composable.
ac, N i
sc, N i
THEOREM 4.1 (Compositional RTA System): Let S =
{M0, . . . Mn} be an RTA system. If for all i, Mi is a well-
formed RTA module satisfying the safety invariant φi
Inv then,
S satisﬁes the invariant(cid:86)
i φi
Inv.
Proof. Note that this theorem simply follows from the fact
that composition just restricts the environment. Since we are
guaranteed output disjointness during composition, composi-
tion of two modules is guaranteed to be language intersection.
The proof for such composition theorem is described in details
in [21], [22].
Theorem 4.1 plays an important role in building the reliable
software stack in Figure 2c. Each RTA module individually
satisﬁes the respective safety invariant and their composition
helps establish the system-level speciﬁcation.
We use dom(X) to refer to the domain of map X and
codom(X) to refer to the codomain of X. Given an RTA
system S = {M0, . . . , Mn}, its attributes (used for deﬁning
the operational semantics) can be inferred as follows:
1. ACN odes ∈ N → N is a map that binds a DM node n
to the particular AC node ACN odes[n] it controls, i.e., if
Mi ∈ S then (N i
2. SCN odes ∈ N → N is a map that binds a DM node n
to the particular SC node SCN odes[n] it controls, i.e., if
Mi ∈ S then (N i
3. N odes ⊆ N represents the set of all nodes in the RTA
system, N odes = dom(ACN odes) ∪ codom(ACN odes) ∪
codom(SCN odes).
ac) ∈ ACN odes.
sc) ∈ SCN odes.
dm, N i
dm, N i
n∈N odes O(n).
4. OS ⊆ T represents the set of outputs of the RTA system,
5. IS ⊆ T represents the set of inputs of the RTA system
n∈N odes I(n)\ OS.
6. CS represents the calendar or time-table of the RTA
OS =(cid:83)
(inputs from the environment), IS =(cid:83)
system, CS =(cid:83)
n∈N odes C(n).
We refer
to the attributes of a RTA system S as
ACN odes(S), SCN odes(S), N odes(S), OS(S), IS(S),
and CS(S) respectively.
state of that node.
We next present the semantics of an RTA system. Note that
the semantics of an RTA module is the semantics of an RTA
system where the system is a singleton set. We use the timeout-
based discrete event simulation model [18] for modeling the
semantics of an RTA system. The calendar CS stores the
future times at which nodes in the RTA system must step.
Using a variable ct to store the current time and F N to store
the enabled nodes, we can model the real-time system as a
discrete transition system.
Conﬁguration. A conﬁguration of an RTA system is a tuple
(L, OE, ct, F N, T opics) where:
1. L ∈ N odes → L represents a map from a node to the local
2. OE ∈ N → B represents a map from a node to a
boolean value indicating whether the output of the node
is enabled or disabled. This is used for deciding whether
AC or SC should be in control. The domain of OE is
codom(ACN odes) ∪ codom(SCN odes).
3. ct ∈ R represents the current time.
4. F N ⊆ N represents the set of nodes that are remaining to
5. T opics ∈ T → V is a map from a topic name to the value
stored at that topic, it represents the globally visible topics.
If X ⊆ T then T opics[X] represents a map from each
x ∈ X to T opics[x].
The initial conﬁguration of any RTA system is represented
as (L0, OE0, ct0, F N0, T opics0) where: L0 maps each node
in its domain to default local state value l0 if the node is AC
or SC, otherwise, mode = SC for the DM node, OE0 maps
each SC node to true and AC node to false (this is to
ensure that each RTA module starts in SC mode), ct0 = 0,
F N0 = ∅, and T opics0 maps each topic name to its default
value v ∈ V.
be ﬁred at time ct.
We represent the operational semantics of a RTA system as
a transition relation over its conﬁgurations (Figure 11).
There are two types of transitions: (1) discrete transi-
tions that are instantaneous and hence does not change the
current time, and (2) time-progress transitions that advance
time when no discrete transition is enabled. DM-STEP and
AC-OR-SC-STEP are the discrete transitions of the system.
ENVIRONMENT-INPUT transitions are triggered by the envi-
ronment and can happen at any time. It updates any of the
input topics e ∈ IS of the module to (e, v). DISCRETE-TIME-
PROGRESS-STEP represents the time-progress transitions that
can be executed when no discrete transitions are enabled (dt1).
It updates ct to the next time at which a discrete transition must
ITE(x, y, z) represents if x then y else z
(ENVIRONMENT-INPUT)
e ∈ IS
v ∈ V
(L, OE, ct, F N, T opics) → (L, OE, ct, F N, T opics[e (cid:55)→ v])
(DISCRETE-TIME-PROGRESS-STEP)
(cid:48)
F N = ∅(dt1) ct
(cid:48)
F N
= min({t | (x, t) ∈ CS, t > ct})(dt2)
= {n | (n, ct
(cid:48)
(L, OE, ct, F N, T opics) → (L, OE, ct
, T opics)
) ∈ CS}(dt3)
, F N
(cid:48)
(cid:48)
(DM-STEP)
dm ∈ F N
(cid:48)
F N
(l, {(STATE, st)}, l
sc = SCN odes[dm]
= F N \ {dm}
(cid:48)
, ∅) ∈ T (dm)
ITE(l
(cid:48)
dm ∈ dom(ACN odes)
ac = ACN odes[dm]
(L[dm (cid:55)→ l
(cid:48)
], OE[ac (cid:55)→ en, sc (cid:55)→ ¬en](dm2), ct, F N
(cid:48)
, T opics)
(L, OE, ct, F N, T opics) →
= AC, en = true, en = false)(dm1)
(AC-OR-SC-STEP)
n ∈ F N
(cid:48)
= F N \ {n}
F N
n (cid:54)∈ dom(ACN odes)
(cid:48)
ITE(OE[n], T opics
in = T opics[I(n)]
(cid:48)
, out) ∈ T (n)
(cid:48)
= out ∪ T opics[T \ dom(out)], T opics
(cid:48)
], OE, ct, F N
(cid:48)
, T opics