我们的任务是编写一个与Max的脚本几乎相同的脚本，但不是像Max那样扫描端口5505，我们的脚本将扫描连接到无处不在的在线数据库MySQL的系统。MySQL是一个在数百万个网站背后使用的开源数据库(现在MySQL属于Oracle旗下，但依然保留有社区版，原开源分支变为MariaDB)，我们将在第12章中使用MySQL。默认情况下，MySQL使用端口3306。数据库是几乎每个黑帽子黑客都在寻找的“金羊毛”，因为它们经常包含在黑市上非常有价值的信用卡号和个人身份信息（PII）。
#### *一个简单的扫描器*
在编写在互联网上扫描公共ip的脚本之前，让我们先完成一个小得多的任务。让我们先编写一个脚本，以扫描局域网上的端口3306，而不是扫描全球，以查看脚本是否实际工作。如果有，我们可以很容易地编辑它来完成更大的任务。
在文本编辑器中，输入清单8-3所示的脚本。
➊ \#! /bin/bash
➋ \# This script is designed to find hosts with MySQL installed
nmap ➌­sT 192.168.181.0/24 ➍­p 3306 ➎\>/dev/null ➏­oG MySQLscan
➐ cat MySQLscan \| grep open \> MySQLscan2 ➑
cat MySQLscan2
*清单8-3:简化的扫描程序脚本*
➊我们使用标识符\#！开始。➋让我们遵循这个注释来解释脚本的用途。
现在，让我们使用➌nmap命令TCP扫描局域网，寻找端口3306➍。(请注意，您的IP地址在您的终端中可能不同，请使用Linux上的ifconfig命令或Windows上的ipconfig命令来确定您的IP地址。)
为了保持隐秘，我们还发送通常会出现在屏幕上的标准nmap输出到Linux的一个特殊的地方➎，一个特殊的地方在Linux中消失。我们在本地机器上做这个，所以这并不重要，但如果要远程使用脚本，则需要隐藏nmap输出。然后，我们将扫描的输出发送到一个名为MySQLscan的文件➏，格式为grep格式，这意味着grep可以处理的格式。
下一行显示我们存储输出的MySQLscan文件，➐然后输出到grep的管道，以过滤包含关键字open（端口开放）的所在行。然后我们把这些字符行放到一个命名为MySQLscan2的文件中➑。
最后，显示文件MySQLscan2的内容。此最终文件应仅包含nmap的输出行，其中包含端口3306打开的主机。将此文件另存为MySQLscanner.sh并使用chmod
755为自己赋予执行权限。
执行脚本，如下所示：
kali \>./MySQLscanner.sh
host: 192.168.181.69 () Ports: 3306/open/tcp//mysql///
我们可以看到，这个脚本能够识别局域网内运行MySQL的唯一的IP地址。当然，您的结果可能会有所不同，具体取决于是否有任何端口在本地网络上运行MySQL服务。
#### *改进MySQL扫描器*
现在，我们希望修改这个脚本，使其不仅适用于您自己的本地网络。如果该脚本能够提示用户想要扫描的IP地址范围和要查找的端口，然后使用该输入，那么该脚本将更容易使用。请记住，您在此章节前一小节页的“添加带有变量和用户输入处理功能”中学习了如何提示用户并将其键盘输入内容输入到变量中。
让我们看看如何使用变量使这个脚本更加灵活和高效。
##### 在黑客脚本中添加提示和变量
在文本编辑器中，输入清单8-4所示的脚本（或直接创建*MySQLscannerAdvanced*文件并打开输入以下内容）。
\#! /bin/bash
➊ echo "Enter the starting IP address : "
➋ read FirstIP
➌ echo "Enter the last octet of the last IP address : " read LastOctetIP
➍ echo "Enter the port number you want to scan for : " read port
➎ nmap ­sT \$FirstIP­\$LastOctetIP ­p \$port \>/dev/null ­oG MySQLscan
➏ cat MySQLscan \| grep open \> MySQLscan2
➐ cat MySQLscan2
*清单8-4:高级MySQL端口扫描器*
我们需要做的第一件事是用IP地址范围替换指定的子网。我们将创建一个名为**FirstIP**的变量和另一个名为**LastOctetIP**的变量来创建这个范围，并为端口号创建一个名为**port**的变量(最后一个八位体是IP地址中第三段（以**.**分割的IP）之后的最后一组数字。在IP地址192.168.1.101中，最后一个字节是101)。
![](media/3748e7e7264f2e86559ef80539e43267.emf)
![](media/4858864cb327786ba5721a42ccaf9061.png)
我们还需要提示用户输入这些值。我们可以使用清单8-1中使用的echo命令来实现这一点。
**FirstIP**变量的值，对应“Enter the starting IP address ：”
➊，向用户询问他们想扫描第一个IP地址。在屏幕上看到这个提示时，用户将输入第一个IP地址，因此我们需要从用户那里获取该输入。
➋我们可以读取命令后跟变量的名称我们想在存储输入。这个命令将把用户输入的IP地址放入变量**FirstIP**中。然后我们可以在整个脚本中使用**FirstIP**中的值。
我们将做同样的为变量**LastOctetIP**➌和**port**➍通过提示用户输入信息，然后使用一个读命令来捕获它。
接下来，我们需要在脚本中编辑nmap命令，以使用刚刚创建和填充的变量。要使用存储在变量中的值，只需在变量名前面加上**\$**，例如在**\$port**中。所以，➎我们扫描一系列IP地址，从用户输入第一个IP到用户输入第二个IP开始，并查找用户输入的特定端口。我们使用变量代替子网来扫描，使用端口来决定扫描什么。重定向符号（**\>**）告诉标准的nmap输出(通常显示在屏幕上)转到**/dev/null**
(/dev/null只是一个发送输出的地方，以便它消失)。然后，我们将输出以grep标准格式发送到名为MySQLscan的文件。
下一行与我们的简单扫描器中相同：它输出MySQLscan文件的内容，将其传输到grep，在那里对包含关键字的行进行筛选过滤，然后将该输出发送到名为MySQLscan2的新文件➏。最后，我们打印展示MySQLscan2文件内容➐。
如果一切正常，此脚本将扫描从第一个输入地址到最后一个输入的IP地址，搜索输入端口，然后仅使用指定端口打开的IP地址进行报告。将脚本文件保存为*MySQLscannerAdvanced*，记住要给其执行权限。
##### 一个运行示例
现在我们可以使用变量来运行我们的简单扫描程序脚本，这些变量确定要扫描的IP地址范围和端口，而不必在每次要运行扫描时编辑脚本：
kali \>./MySQLscannerAdvanced.sh Enter the starting IP address : 192.168.181.0
Enter the last IP address :
192.168.181.255
Enter the port number you want to scan for :
3306
Host: 192.168.181.254 ()Ports:3306/open/tcp//mysql//
脚本提示用户输入第一个IP地址、最后一个IP地址，然后输入要扫描的端口。在收集这些信息之后，脚本执行nmap扫描，并生成具有指定端口的范围内所有IP地址的报告。正如您所看到的，即使是最简单的脚本也可以创建强大的工具。在第17章中，您将学习更多关于脚本的知识。
### 常用内置BASH命令
如前所述，表8-1提供了bash中内置的一些有用命令的列表。
表8-1:内置Bash命令
| **命令功能** |                                    |
|--------------|------------------------------------|
| ：           | 返回0或**true**                    |
| .            | 执行shell脚本                      |
| b            | 将作业放在后台                     |
| break        | 退出当前循环                       |
| cd           | 改变目录                           |
| continue     | 执行当前循环                       |
| echo         | 显示命令参数                       |
| eval         | 计算以下表达式                     |
| exec         | 在不创建新进程的情况下执行以下命令 |
| exit         | 退出shell                          |
| export       | 使变量或函数对其他程序可用         |
| fg           | 将工作放在前台                     |
| getopts      | 解析shell脚本的参数                |
| jobs         | 列出后台(bg)执行的工作             |
| Pwd          | 显示当前目录                       |
| Read         | 从标准输入读取一行                 |
| Readonly     | 将变量声明为只读                   |
| set          | 列出所有变量                       |
| shift        | 将参数向左移动                     |
| test         | 评估参数                           |
| [            | 执行条件测试                       |
| times        | 打印用户和系统时间                 |
| trap         | 追踪一个信号                       |
| type         | 显示如何将每个参数解释为一个命令   |
| umask        | 更改新文件的默认权限               |
| unset        | 从变量或函数中删除值               |
| wait         | 等待后台进程完成                   |
### 总结
脚本是任何黑客或系统管理员的基本技能。它使您能够通常需要花费几个小时的任务变得自动化，并且一旦保存为脚本，就可以反复使用它。Bash脚本是脚本的最基本形式，在第17章中，您将使用更多的功能进一步学习Python脚本。
9
-
压缩和归档
----------
COMPRESSING AND ARCHIVING
![](media/451fdbee142e8cd4684d71b24707d050.jpg)
黑客经常需要下载和安装新软件，以及发送和下载多个脚本和大文件。如果将这些文件压缩并合并到单个文件中，那么这些任务就更容易完成。如果您来自Windows世界，您可能会从**.zip**格式中认识到这个概念，该格式组合和压缩文件，使其更小，以便通过互联网或可移动媒体传输。在Linux中有很多方法可以做到这一点，在本章中我们将介绍一些最常用的工具。我们还将查看**dd**命令，它允许您复制整个驱动器，包括这些驱动器上的已删除文件。
### 压缩是什么?
压缩这个有趣的主题本身就可以填满一整本书，但是对于这本书，我们只需要对这个过程有一个基本的了解。顾名思义，压缩使数据更小，因此需要更少的存储容量，使数据更容易传输。对于初学者来说，将压缩分类为有损或无损就足够了。
有损压缩在减小文件大小方面非常有效，但是会丢失信息的完整性。换句话说，压缩后的文件与原始文件并不完全相同。这种类型的压缩用于较大的图形，视频和音频文件，其中一些小的差异在文件中很难察觉
.mp3、.mp4、.png和.jpg都是有损压缩算法。如果.png文件中的一个像素或.mp3文件中的一个音符发生了变化，你的眼睛或耳朵不太可能注意到其中的差别——当然，音乐爱好者会说他们肯定能分辨出.mp3和未压缩的.flac文件之间的差别。有损压缩的优点是它的效率和有效性。压缩比是非常高，这意味着生成的文件比原始文件小得多。
然而，当您发送文件或软件时，有损压缩是不可接受的，而数据完整性是至关重要的。例如，如果您正在发送脚本或文档，那么在解压缩原始文件时，它的完整性必须保持。本章主要讨论这种无损压缩类型，它可以从许多实用程序和算法中获得。不幸的是，无损压缩并不像您想象的那样有效，但是对于黑客来说，完整性通常比压缩比重要得多。
### 将文件存档在一起
通常，压缩文件时要做的第一件事是将它们合并到归档文件中。在大多数情况下，在归档文件时，您将使用**tar**命令。Tar是磁带存档的缩写，指的是系统使用磁带存储数据的史前计算时代。tar命令从许多文件创建一个文件，然后将其称为归档文件、tar文件或tar包。
例如，假设您有三个脚本文件，与我们在第8章节中使用的脚本文件类似，分别名为hackersarise1、hackersarise2和hackersarise3。如果您切换到保存它们的目录并执行以长列表格式列出查看，您可以清楚地看到文件和您期望的详细信息，包括文件的大小，如下所示:
kali \>ls -l
­rwxr­xr­x 1 root root 22311 Nov 27 2018 13:00 hackersarise1.sh
­rwxr­xr­x 1 root root 8791 Nov 27 2018 13:00 hackersarise2.sh
­rwxr­xr­x 1 root root 3992 Nov 27 2018 13:00 hackersarise3.sh
假设您希望将所有这三个文件发送给与您一起工作的另一个黑客。您可以使用清单9-1中的命令组合它们并创建一个归档文件。
kali \>tar -cvf HackersArise.tar hackersarise1 hackersarise2 hackersarise3
hackersarise1
hackersarise2
hackersarise3
*清单9-1:创建一个包含三个文件的tar包*
让我们分解这个命令以更好地理解它。归档命令是**tar**，我们在这里使用它有三个参数选项。**c**选项表示创建，**v**(代表详细过程，是可选的)列出tar正在处理的文件，**f**表示写入以下一个文件。最后一个选项也适用于从文件中读取。然后，我们为新归档文件提供您希望从这三个脚本来创建的文件名:HackersArise.tar。
总之，这个命令将获取所有三个文件，并创建一个完整的单独新文件HackersArise.tar。当您对此目录执行以长列表格式列出所有文件时，您将看到它还包含了新的.tar文件，如下所示:
kali \>ls -l
­­snip­­
­rw­r­­r­­ 1 root root 40960 Nov 27 2018 13:32 HackersArise.tar
­­snip­­
kali \>
注意这里tar包的大小：40,960字节。在归档这三个文件时，tar使用了大量的开销来执行此操作：在归档之前，这三个文件的总和是35094字节，而在归档之后，tar包已经增长到了40960字节。换句话说，归档过程增加了5000多个字节。尽管这种开销对于小文件来说非常重要，但是对于越来越大的文件来说就变得越来越不重要了。
我们可以使用**tar**命令和**-t**内容列表参数从tar包中显示这些文件，而不需要提取它们，如下所示:
kali \>tar -tvf HackersArise.tar
­rwxr­xr­x 1 root root 22311 Nov 27 2018 13:00 hackersarise1.sh
­rwxr­xr­x 1 root root 8791 Nov 27 2018 13:00 hackersarise2.sh
­rwxr­xr­x 1 root root 3992 Nov 27 2018 13:00 hackersarise3.sh
在这里，我们看到三个原始文件和它们的原始大小。然后您可以使用**tar**命令和**-x**
(extract)选项从tar包中提取这些文件，如下所示:
kali \>tar -xvf HackersArise.tar
hackersarise1.sh
hackersarise2.sh
hackersarise3.sh
因为您仍然在使用**-v**参数，所以这个命令将显示在输出中提取哪些文件。如果您想提取文件并“静默”地这样做，这意味着不显示任何输出，您可以简单地删除**-v**(详细)选项，如下所示:
kali \>tar -xf HackersArise.tar
这些文件已经被提取到当前目录下，您可以在目录下以长列表格式列出，来进行双重检查。请注意，默认情况下，如果提取的文件已经存在，tar将删除现有文件，并用提取的文件替换它。
### 压缩文件