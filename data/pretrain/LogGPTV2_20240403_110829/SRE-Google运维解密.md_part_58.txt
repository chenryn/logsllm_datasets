让整个情况变得更复杂的是，对于某些任务来说没有运行也是可以接受的，但是对其他
该任务也是安全的。但是其他Cron任务，例如某个大批量发送E-mail通知的任务，是
能。数量繁多、功能和需求各异的Cron任务很明显会影响到整个服务的可靠性要求。
Cron任务一般都被用来执行周期性任务，但是除此之外我们很难知道某个任务的具体功
Cron任务和幂等性
从可靠性的角度来看，Cron服务有几个方面值得一提：
可靠性
护进程（daemon），该进程负责加载Cron任务的定义列表，而任务会在对应的时间被启动。
Cron 通常的实现方式是由一个单独组件组成，通常被称为crond。crond是一个系统守
义，例如，“仅仅在每月第30天，且当天为周六的时候执行”。
天中午执行一次”、“每小时整点的时候执行”）。也可以通过这种格式进行复杂的周期定
执行时间表格式是所谓的“crontab”格式，这个格式支持使用简单的周期定义（例如，“每
274
尔跳过一次执行。但是一个每月执行一次的工资计算任务却不应该被跳过。
不应该运行多于一次的。
有些Cron任务，例如垃圾回收机制，是具有幂等性的。在系统异常状态下，多次运行
·anacron是一个特例。anacron在系统恢复运行时，会试图运行那些在岩机时间中
·Cron服务的故障域仅仅是单台物理机器。如果这台物理机器并没有在运行，那
中来实现的。
有用。该功能是通过将所有已注册的Cron任务上次运行的时间记录在一个文件
周期的任务起作用。这种功能对运行在工作站和笔记本上的维护性任务来说非常
本来应该运行的程序。但是这种重新运行机制只会对那些每天运行一次或者更短
件自身。Cron进程启动任务之后不会再追踪任务状态。
当crond重启时（包括物理机器重启），唯一需要保存的状态就是crontab 配置文
器上启动工作任务（例如，使用SSH）。这个场景中有两个不同的故障域，任何
的模型，将Cron服务运行在一台机器上，那么可用远程方式在另外一台物理机
么Cron服务和对应的用户任务都不会运行。注2这里我们如果使用一个非常简单
一个故障域的故障都可能影响整个服务的可靠性。
第24章
分布式周期性任务系统
，可能可以偶
---
## Page 317
上，消耗一定时间重新安装软件并且启动新的进程。
然而，这个过程是需要一定时间的。一台损坏的物理机需要一定时间才能被发现，通常
器发送一个RPC了。
系统还会处理物理机的故障问题。这样一来，运行一个任务就仅仅等于向数据中心分发
分发系统（该系统应该是高可靠的）来决定一台或者多台机器来运行你的服务，同时该
仅仅通过指明该服务的资源要求，以及应该运行的数据中心即可。数据中心内部的任务
为了提升Cron的可靠性，我们将实际进程与物理机器分开。如果我们想要运行一个服务
个Cron服务不可用。这种实现显然是不可行的。
于一个拥有1000台物理机的数据中心中，那么一次1/1000的不可用故障就可能使得整
将Cron服务部署在单台物理机器上对可靠性来说可能是灾难性的。假设这台物理机位
机器上。
在常规实现里，Cron只能运行在一台机器上。大规模系统部署需要将Cron分布到多台
对基础设施的扩展
需的某些设计改变。
方案之前，我们会先讨论小规模部署和大规模部署的区别，并且描述在大规模部署下必
某些基础定义，这样才能使得Cron在大规模场景下工作得更好。在展示Google的解决
从单台物理机器的部署场景迁移到更大规模部署的场景需要我们重新思考Cron任务的
大规模Cron系统
以此来避免系统化地制造困难局面。
常是很难的，甚至是不可能的。因此，在Cron服务中，我们优先于“失效关闭（fail-close）”
合适的行动。与之相比，之前提到的发邮件任务，如果试图从运行两次的情况中恢复经
Cron任务执行效果的监控。在任务没有执行的情况中，任务所有者可以针对该任务采取
所有者可以通过Cron服务暴露的状态信息监控自已的任务，也可以建立起独立的、针对
Cron任务的所有者，可以（并且应该）监控他们自己的Cron任务：例如，某个任务的
常情况下，试图修复某个任务没有执行的问题，要比修复任务执行两次造成的问题容易，
最差情况下跳过某个任务的执行，而不会冒有可能将任务执行两次的风险。这是因为通
有一个可以适用所有情况的固定答案。一般来说，在系统允许的情况下，我们更倾向于
Cron任务的这种多样性使得讨论系统的可靠性变得很难：针对Cron这样的服务，并没
大规模Cron系统
275
318
---
## Page 318
319
276
中有其对应的好处：该服务与其对应的数据中心任务分发系统延迟很低，同时共享一个
将Cron服务部署在全球范围内可能是可行的，但是将Cron部署在一个单独的数据中心
整个Cron系统不可用。
数据中心内部分散地同时运行多份调度器的副本，我们可以避免单个供电单元故障造成
候（例如部分供电系统故障，或者存储系统故障），整个服务仍然能够正常运行。通过在
的依赖的服务。对Cron这样的基础服务来说，必须保证在数据中心遇到部分故障的时
Cron服务，当大规模部署时从一个简单的二进制文件变成了一个具有许多明显和不明显
在讨论故障模式的时候，一个数据中心相比单个物理机来说是一个更加丰富的生态系统，
发送过程中崩溃了）。Cron故障恢复过程必须要处理这种情况。
我们会遇到某个RPC成功，而其他RPC不成功的问题（例如，发送RPC的进程本身在
障类型。Cron任务的多样性意味着某些任务在启动的时候可能需要发送多个RPC，有时
将进程启动过程与具体运行的机器分离使得整个Cron系统需要处理“部分启动”的故
到任务终止。
对任务运行情况的监控需要，使得我们需要记录Cron任务的全过程，从预计执行一直
Cron任务可能由于数据中心没有足够资源满足该任务而延迟。这种资源要求，加上用户
知道它预计使用的资源一不管是Cron系统本身，还是该系统所要运行的任务。某个
会互相影响是一个基础性假设。为了保证这种假设有效，我们必须在每个进程运行之前
更好地进行资源隔离。在这里，隔离是很有必要的，因为数据中心中每个独立进程不
而将Cron系统部署到整个数据中心级别，一般来说意味着将进程部署到容器中，以便
crond和其他的Cron任务经常是没有隔离的。
容器里一般是不常见的，也是不必要的。因此，如果Cron系统部署在单个物理机上，
段。虽然现在容器（container）技术已经很流行，但将机器上每个组件都隔离在自己的
单物理机系统通常会将所有运行着的程序聚合在一起，仅仅提供非常有限的资源隔离手
对需求的扩展
可以极大降低系统的不可用时间。
可能是无法接受的。在这种情况下，热备任务，在主任务迁移的时候及时介入恢复服务
务需要每5分钟运行一次，由于Cron服务迁移导致的每次一分钟，或者两分钟的延迟
移过程中没有运行的任务。但是这种解决方案可能无法解决即时性的要求：如果某个任
例如GFS。在服务启动的时候，直接通过该分布式文件系统查询并且启动那些在系统迁
应对措施。为了保持本地状态，我们可能会简单地将状态存储在一个分布式文件系统中，
定义的最小时间间隔：1分钟。于是我们需要一些针对数据丢失和重新启动时间过长的
丢失（除非采用某种在线迁移技术）。同时整个系统的重新分发过程可能会超过系统所
第24章
分布式周期性任务系统
---
## Page 319
以修改共享状态的副本，也是唯一
如图24-1所示，分布式Cron系统使用了一个单独的领头人任务，该副本是唯一
致（参见第23章）。就算某些基础设施出现故障，只要整个组中大多数成员可用，整个
我们为Cron服务部署了多个副本，同时采用Paxos分布式共识算法保证它们状态的一
Paxos协议的使用
以下几个：
当Google设计分布式Cron任务的时候，我们选择的是第二个选项。这样选择的原因有
跟踪任务的状态有两个选项：
那些发送邮件和计算工资之类的非幂等的Cron任务吗？
生故障的时候快速恢复。更重要的是，该状态信息的一致性是关键！还记得前文所述的
如上一节所述，我们需要记录关于Cron任务的一些状态信息，并且必须能够在系统发
跟踪Cron任务的状态
了Google的分布式Cron服务的儿个设计要点。
本节主要展示构建一个可靠的大型分布式Cron系统所必须要解决的问题。同时也强调
GoogleCron系统的构建过程
故障域。毕竟，数据中心任务分发系统是Cron服务的一个核心依赖。
分布式系统就可以顺利地进行状态变更。
·分布式文件系统，包括GFS和HDFS通常用来存储非常大的文件（例如，网页
系统内部自行存储一些（很小量的）状态信息。
）将数据存储在一个可用度很高的外部分布式存储上。
而运行，以便服务更多的内部用户。
（存储部分其实只是一个实现细节）。然而，Cron服务应该可以独立于下游系统
工作一段时间。但是这个要求并不一定意味着存储区域一定要在Cron进程内部
该依赖越少越好。即使数据中心的一部分出现故障，Cron服务也应该能够持续
基础服务，也就是那些失效时会带来许多副作用的（就像Cron这样的）服务应
件系统就不是为这种类型的写操作进行优化的。
的。小型写操作在分布式文件系统上的开销很高，同时延迟也很高，因为这些文
爬虫程序的输出文件），而我们需要存储的Cron任务状态信息通常来说是非常小
一个可以启动Cron任务的副本。
GoogleCron系统的构建过程
。我们基于Paxos协议
一个可
277
320
---
## Page 320
321>
在记录Cron任务的启动时可能会产生歧义（这种歧义通常出现在那些高频任务中，比
领头人角色
领头人角色和追随者角色
由于已经有另外几个Cron进程处于启动状态，所以可以很快地选举出一个新的领头人。
如果领头人副本崩溃了，Paxos小组的健康检查会很快发现这个问题（通常在几秒之内）
图24-1：不同分布式Cron副本之间的交互过程
领头人合为一个。
278
简单地标记某个Cron任务是不够的，应该将某次启动时间作为唯一标识符标记；否则
领头人进程是唯一一个主动启动Cron任务的进程。该领头人进程内部有一个内置调度器，
服务需要不停地以同步方式通知大多数的副本每个计划任务的启动和结束信息。
各个副本利用Paxos协议同步的最重要的状态信息就是哪些Cron任务已经被启动了。该
选举速度很快，使我们可以很轻松地保证在可接受的一分钟故障时间内进行故障切换。
实是一个，但是Cron领头人在选举结束后需要完成一系列额外的操作。领头人过程的
手之前领头人未完成的工作。虽然Cron服务的领头人进程和Paxos协议的领头人进程其
的变种一
任务的启动条件可能已经变化了，这些启动信息也必须同步给其他所有的跟随者角色。
间，和普通的crond实现一样。当然，与普通的crond类似，自从上次执行过后，Cron
当到达预定启动时间时，领头人宣布它将要开始启动该Cron任务，同时计算新的启动时
与本章开头提到的简单的crond实现非常类似。该调度器按照预定的启动时间排序维护
每种角色的职责。
正如前文所述，Cron服务使用Paxos协议分配两个角色：领头人和追随者。下文会详述
一旦新的领头人被选举出来，根据Cron服务自定义的选举过程使得新的领头人进程接
一个Cron任务列表。领头人进程在第一个任务的预期执行时间之前一直处于等待状态。
—FastPaxos（参见文献[Lam06]）协议的优势，将领头人副本和Cron服务的
第24章分布式周期性任务系统
分布式Cron
（主进程）
分布式Cron
分布式Cron
调度器
数据中心
---
## Page 321
次预计启动时间。这项重要的状态改变（是同步进行的）保证了所有Cron任务在整个
当接收到某个已经执行的“启动”通知时，追随者副本需要更新该副本内部该任务的下
致（这就是要使用Paxos协议的原因）。
跟踪者也必须要维护系统中所有Cron任务的列表，这个列表必须在所有副本中保持一
换。所有的状态改变都是从领头人角色基于Paxos协议传递的。就像领头人角色那样。
追随者副本需要持续跟踪领头人进程提供的目前的系统状态，以便在需要的时候及时替
追随者角色
和新的领头人进程同时进行相互冲突的操作。