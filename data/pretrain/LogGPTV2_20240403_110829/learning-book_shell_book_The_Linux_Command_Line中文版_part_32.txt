要确认一下这是否是你真正想要的效果。通过把这条语句添加到你的.bashrc文件
中，你可以使这个更改永久有效。
ezport LANG=POSIX
259
---
## Page 261
20.9POSIX基本正则表达式与POSIX扩展正则表达式
就在我们认为这已经非常令人困惑了，我们却发现POSIX把正则表达式的实现分成了两类
任意应用程序，都支持我们目前研究的所有正则表达式特性。我们的grep程序就是其中一个。
BRE和ERE之间有什么区别呢？这是关于元字符的问题。BRE可以辨别以下元字符：
$.[]*
其它的所有字符被认为是文本字符。ERE添加了以下元字符（以及与其相关的功能）：
（)qe,oqo s[-xoqxnuto]
[ne@linuxbox -]$
我们看到这个正则表达式不匹配“ab9”这一行，因为它包含了一个非字母的字符：它也不
匹配“abcd”，因为在字符“e”和“d”之间不止一个空格。
20.12.2{}-匹配特定个数的元素
{和}元字符都被用来表达要求匹配的最小和最大数目。它们可以通过四种方法来指定：
限定符
意思
n
匹配前面的元素，如果它确切地出现了n次。
n,m
匹配前面的元素。如果它至少出现了n次，但是不多于m
次。
n,
匹配前面的元素，如果它出现了n次或多于n次。
264
---
## Page 266
,m
匹配前面的元素，如果它出现的次数不多于m次。
表20-3:指定匹配的数目
回到之前处理电话号码的例子，我们能够使用这种指定重复次数的方法来简化我们最初的
正则表达式：
(？ [09] [09] [09])?  [09] [09] [09]  [09] [09] [09] [09]$
简化为：
\(？[09]{3}\)？[09]{3}[09]{4}$
让我们试一下：
[ne@linuxbox -]$ echo *(555) 1234567" 1 grep -E ^\(?[09]{3}\)? [09]{3}-[09]{4}$
(555) 1234567
[ne@1inuxbox -]$ echo *555 123-4567* 1 grep -E *^\(?[0-9](3)\)? [0-9]{3}-[0-9]{4)$
555 1234567
[ne@linuxbox -]$ echo “5555 123-4567* 1 grep -E ^\(?[0-9]{3}\)? [09]{3}-[09]{4}$*
[nedlinuzbox -]$
我们可以看到，我们修订的表达式能成功地验证带有和不带有圆括号的数字，而拒绝那些格
式不正确的数字。
20.13让正则表达式工作起来
让我们看看一些我们已经知道的命令。然后看一下它们怎样使用正则表达式。
20.13.1通过grep命令来验证一个电话簿
在我们先前的例子中，我们查看过单个电话号码，并且检查了它们的格式。一个更现实的情形
是检查一个数字列表，所以我们先创建一个列表。我们将念一个神奇的咒语到命令行中。它会
265
---
## Page 267
很神奇，因为我们还没有涵盖所涉及的大部分命令，但是不要担心。我们将在后面的章节里面
讨论那些命令·这就是那个咒语：
[nelinuxbox -] $ for i in {1..10}; do echo "($ {RANDOM: 0:3}) $ {RANDOM: 0:3]- $ {RANDOM:
0:4}* >> phonelist.txt; done
这个命令会创建一个包含10个电话号码的名为phonelist.txt的文件。每次重复这个命令的
时候，另外10个号码会被添加到这个列表中。我们也能够更改命令开头附近的数值10，来生
成或多或少的电话号码。如果我们查看这个文件的内容，然而我们会发现一个问题：
[ne@linuzbox -]$ cat phonelist.txt
(232) 2982265
(624) 3811078
(540) 1261980
(874) 1632885
(286) 254-2860
(292) 108518
(129) 441379
(458) 2731642
(686) 2998268
(198) 3072440
一些号码是残缺不全的，这正是我们想要的，因为我们将使用grep命令来验证电话号码的
正确性。
一个有用的验证方法是扫描这个文件，查找无效的号码，并把搜索结果显示到屏幕上：
${}[60]{e}[60] (\{}[60])，Ag-doxs[xoqxnuo]
phonelist.txt
(292) 108518
(129)  441379
[nedlinuxbox -]$
这里我们使用-v选项来产生相反的匹配，因此我们将只输出不匹配指定表达式的文本行
这个表达式自身的两端都包含定位点（锚）元字符，是为了确保这个号码的两端没有多余的字
符。这个表达式也要求圆括号出现在一个有效的号码中，不同于我们先前电话号码的实例。
266
---
## Page 268
20.13.2用find查找丑陋的文件名
这个find命令支持一个基于正则表达式的测试。当在使用正则表达式方面比较find和grep命
令的时候，还有一个重要问题要牢记在心。当某一行包含的字符串匹配上了一个表达式的时候，
grep命令会打印出这一行，然而find命令要求路径名精确地匹配这个正则表达式。在下面的
例子里面，我们将使用带有一个正则表达式的find命令，来查找每个路径名，其包含的任意字
符都不是以下字符集中的一员。
[1_- /09a=zA2]
这样一种扫描会发现包含空格和其它潜在不规范字符的路径名：
**[z-vz-6-0/-"\-]+*, xo3o-pu $[- xoqxnuou]
由于要精确地匹配整个路径名，所以我们在表达式的两端使用了.*，来匹配零个或多个字
符。在表达式中间，我们使用了否定的中括号表达式，其包含了我们一系列可接受的路径名字
符。
20.13.3用locate查找文件
这个locate程序支持基本的（--regexp选项）和扩展的（--regex选项）正则表达式。通过locate
命令，我们能够执行许多与先前操作dirlist文件时相同的操作：
(dtz|z3|zq)/urq, xogox-- ozesot s[- xoqxnutgou]
/bin/bzcat
/bin/bzcnp
/bin/bzdiff
/bin/bzegrep
/bin/bzexe
/bin/bzfgrep
/bin/bzgrep
/bin/bzip2
/bin/bzip2recover
/bin/bzless
267
---
## Page 269
/bin/bznore
/bin/gzeze
/bin/gzip
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgzep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
通过使用alternation，我们搜索包含bin/bz，bin/gz，或/bin/zip字符串的路径名。
20.13.4在less和vim 中查找文本
less和vim两者享有相同的文本查找方法。按下/按键，然后输人正则表达式，来执行搜索任
务。如果我们使用less程序来浏览我们的phonelist.txt文件：
[ne@linuxbox -]$ less phonelist.txt
然后查找我们有效的表达式：
(232) 2982265
(624)3811078
(540) 1261980
(874) 1632885
(286) 2542860
(292) 108518
(129)441379
(458) 2731642
(686) 2998268
(198) 3072440
/([09]{3}) [09]{3}- [09] {4}$
less将会高亮匹配到的字符串，这样就很容易看到无效的电话号码：
268
---
## Page 270
(232)2982265
(624) 3811078