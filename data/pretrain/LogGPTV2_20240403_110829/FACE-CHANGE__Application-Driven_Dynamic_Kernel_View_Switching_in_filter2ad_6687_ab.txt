phase to recover any missing kernel code. We explain this
mechanism in detail in Section III-B3.
3) Interrupt Context: In modern OS kernels, hardware
triggered asynchronous interrupts can happen at any time,
and thus interrupt handler code is not attached to any
single process’ context. We choose to include the interrupt
1RUBiS is an ebay-like auction service that heavily uses mysql.
493
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:20:50 UTC from IEEE Xplore.  Restrictions apply. 
Profiling Phase
Runtime Phase
Process 1
Process 2
Process 3
{user space}
Process 1
Process 2
Process 3
{user space}
[Process 1] 
kernel view
Kernel
{kernel space}
[Process 2] 
kernel view
[Process 3] 
kernel view
[Process 1] 
kernel view
[Process 2] 
kernel view
[Process 3] 
kernel view
{kernel space}
Figure 1: Overview of FACE-CHANGE
handler’s code in every application’s kernel view to avoid
having to repeatedly recover this code at runtime. Our
proﬁler leverages QEMU to identify the occurrence of an
interrupt. If this interrupt is not a software interrupt (such
as system call), we can infer that the system has entered
interrupt context. At this point, we record all kernel code
addresses accessed in the interrupt’s context for use in all
applications’ customized kernel view.
B. Runtime Phase
We describe the general design of the runtime phase in
Algorithm 1 and discuss some interesting features below in
detail.
1) Kernel View Initialization: When loading a new kernel
view conﬁguration, FACE-CHANGE allocates memory pages
for both the base kernel code and any kernel modules’ code
and ﬁlls them with undeﬁned instruction (UD2) “0xf 0xb”
(UD2 will raise an invalid opcode exception when executed).
FACE-CHANGE then loads the kernel code speciﬁed in the
kernel view conﬁguration into it’s appropriate locations in
the new pages. Recall that during proﬁling, we track the
kernel control ﬂow at the basic block level. However, rather
than loading individual basic blocks, we slightly relax the
condition to load the entire kernel function which contains
the valid basic blocks. The rationales for this relaxation are:
(1) The adjacent code within the same kernel function is
more likely to be accessed at runtime. Thus, we can reduce
the frequency of kernel code recovery by loading the whole
kernel function. (2) UD2 is a 2-byte instruction. If an address
range in the kernel view conﬁguration starts from an odd-
numbered address, only the ﬁrst byte of UD2 will be in
the kernel view, and the processor may misinterpret the
fragmented UD2 as a different instruction. Loading entire
kernel functions avoids this problem because the boundaries
of kernel functions are aligned on powers-of-two2.
To identify function boundaries, we search for a func-
tion header signature backwards and forwards from the
Algorithm 1 Kernel View Switching/Kernel Code Recovery
Input:
modulelist ← kernel module list
context switch addr ← Address of context switch function
resume userspace addr ← Address of resume userspace function
full kernel view index ← Index of full kernel view
RECOVER BACKTRACE(prev rip)
iter rbp := prev rbp
iter rbp := rbp
prev rip := rip
while IS VALID(prev rip) do
DUMP BACKTRACE(prev rip)
prev rip := READ PREV RIP(iter rbp)
prev rbp := READ PREV RBP(iter rbp)
if PREV RIP = ’0B 0F’ then
BACK TRACE(vcpu.rip, vcpu.rbp)
mem page := GET MEMORY PAGE(vcpu.rip)
start addr := SEARCH BACKWARDS(vcpu.rip)
end addr := SEARCH FORWARDS(vcpu.rip)
FETCH FILL CODE(page, start addr, end addr)
1: - - - - - - - - Kernel Code Recovery - - - - - - - - - -
2: procedure BACK TRACE(rip, rbp)
3:
4:
5:
6:
7:
8:
9:
10:
11:
12: procedure HANDLE INVALID OPCODE(vcpu)
13:
14:
15:
16:
17:
18:
19: - - - - - - - - Kernel View Switching - - - - - - - - - -
20: procedure SWITCH BASE KERNEL(index)
21:
kernel range := GET KERNEL RANGE()
22:
LOAD KERNEL VIEW EPT(kernel range, index)
23: procedure SWITCH KERNEL MODULES(index)
24:
25:
26:
27: procedure SWITCH KERNEL VIEW(index)
28:
29:
30: procedure HANDLE KERNEL VIEW TRAP(vcpu)
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
procinfo := READ PROC INFO(vcpu)
index := KERNEL VIEW SELECTOR(procinfo)
if index = full kernel view index then
ENABLE RESUME SPACE TRAP()
lastindex := index
else if vcpu.rip = resume userspace addr then
CLEAR RESUME USERSPACE TRAP()
SWITCH KERNEL VIEW(lastindex)
CLEAR RESUME USERSPACE TRAP()
SWITCH KERNEL VIEW(index)
else
for all mod in modulelist do
module range := GET MODULE RANGE(mod)
LOAD MODULE VIEW EPT(module range, index)
SWITCH BASE KERNEL(index)
SWITCH KERNEL MODULES(index)
if vcpu.rip = context switch addr then
2Linux kernel is by default compiled with -O2 that contains optimization
ﬂag -falign-functions
494
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:20:50 UTC from IEEE Xplore.  Restrictions apply. 
basic blocks marked in the kernel view conﬁguration. For
example, a common function header signature in the x86
Linux kernel is “push ebp; mov ebp, esp”(binary opcodes
“0x55 0x89 0xe5”). There is a possibility that one kernel
function may cross two memory pages and further, one
single instruction may split across pages. In this case, we
continue searching from the head of the next page or the tail
of the previous page to locate the complete kernel function.
After all of the kernel view’s code is identiﬁed and loaded
into the new pages, FACE-CHANGE redirects any kernel
code access made by this application to the customized
kernel view. We implement our FACE-CHANGE runtime
component within a KVM hypervisor (i.e., kvm-kmod-3.6
and qemu-kvm-1.2.0) and leverage Extended Page Tables
(EPT) to manipulate kernel code mappings. When using
EPT, the guest VM maintains its own page table to translate
guest virtual addresses to guest physical addresses. The
hypervisor then uses EPT to transparently map the guest
physical addresses to host physical addresses. During guest
OS context switches, FACE-CHANGE changes the page table
entries in the EPT to direct any kernel code accesses to the
customized kernel view for the application (instead of the
original kernel’s code). This procedure is explained in the
Section III-B2.
Again, FACE-CHANGE must
take care when handling
kernel modules’ code in a customized kernel view. Recall
that kernel modules are dynamically loaded at runtime in the
kernel’s heap, and thus, during the proﬁling phase, we record
these addresses relative to the module’s base address. Before
we load modules’ code into a kernel view, we traverse the
kernel’s module list to identify the loading addresses for any
modules marked in the kernel view conﬁguration. Then we
load the valid kernel code in the code pages for the kernel
modules.
2) Kernel View Switching: Figure 2 illustrates each step
of the kernel view switching procedure. In step 1, the guest
OS chooses a process to run and prepares to context switch
to the new process. In step 2, using VMI, we intercept this
context switch and determine which customized kernel view
is needed for the new application. In step 3A and 3B, we
modify the pointers to the page directory (level 2 in the
EPT) corresponding to the base kernel code and all kernel
modules’ code respectively. Because kernel modules’ code
pages are scattered in the kernel heap, we reuse any entries in
the page directory that point to kernel data and only modify
the entries pointing to the modules’ code.
We also develop a set of optimizations to improve perfor-
mance. Through our experimentation, we ﬁnd that switching
kernel views immediately at context switches may cause
the application to miss interrupts, and thus jeopardize I/O
performance. We choose instead to switch kernel views
when the code resumes user space execution after the context
switch. This will still satisfy the strictness goal (minimize
the attack surface) and mitigate the performance degradation
caused by missed interrupts. We also check whether the
previous process and the next process use the same kernel
view, and if so, we can avoid one additional kernel view
switch.
3) Kernel Code Recovery: There are two situations where
FACE-CHANGE may need to recover missing kernel code:
(i) An incomplete kernel view generated during proﬁling:
Testing in a controlled runtime environment without
introducing any attacks, we ﬁnd that the majority of
the benign kernel recoveries are triggered due to miss-
ing code for handling interrupts. For example, KVM
provides a para-virtualized clock device to the guest
VM. This KVM speciﬁc code cannot be included in the
kernel view during the proﬁling in QEMU. Thus, at
runtime, FACE-CHANGE needs to recover the missing
kernel functions shown below in chronological order:
kvm clock get cycles → kvm clock read
→ pvclock clocksource read → native read tsc
In addition,
interrupt handling code is not bound
to any process and can be triggered by hardware
interrupts at any time. In the proﬁling phase, we may
not observe all possible interrupts for this application.
Before missing code recovery, we inspect the current
call stack to determine whether the current execution is
in interrupt context (through backtracking the current
function traces). Thereafter we recover the missing
kernel code to correctly handle those interrupts.
All other benign kernel code recoveries due to in-
complete proﬁling of the application’s execution paths
are recorded as a reference for the administrator to
ameliorate the proﬁling test suite.
(ii) Anomalous execution caused by malicious attacks:
User level malware may hijack a normal process to
execute shellcode which requests kernel services that
are not in the customized kernel view. Additionally,
kernel level rootkits can detour the kernel’s execution
path to their payload’s malicious code, and obviously,
this malicious payload will not be in any application’s
kernel view. FACE-CHANGE is designed to report the
suspicious execution traces, but still recover the kernel
code in this case. In order to track the provenance of
the attack, we not only record any recovered functions,
but also backtrack the anomalous execution’s call
stack to ﬁnd the origin of the invocation chain for
later analysis.
As we mentioned in Section III-B1, we ﬁll any kernel
code space that is not in the kernel view with UD2 “0xf 0xb”.
When executed, UD2 raises an invalid opcode exception
which causes a trap to the hypervisor. We illustrate this as
step 4 invalid opcode trap in Figure 2. After intercepting
the trap, we check the faulting address and try to fetch the
missing kernel function from the original kernel code pages
(step 5 in Figure 2).
495
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:20:50 UTC from IEEE Xplore.  Restrictions apply. 
Guest VM
Hypervisor
Extended Page Tables
Guest Page Tables
kernel 
address space
3G ~ 4G
Process  Scheduler
1
Process
Process
Process
user
 address space
      0 ~ 3G
{Kernel Module Code}
3B
Invalid Opcode Trap
4
Context Switch Trap
2
3A
{Base Kernel Code}
Code Recovery
5
Original Code
Profiled Code
Invalid Code
Figure 2: The Procedure of Dynamic Kernel View Switching and Kernel Code Recovery
During our implementation of the kernel code recovery
mechanism, we ﬁxed an interesting cross-view bug in FACE-
CHANGE that is worth mentioning here. If no customized
kernel view is enabled for a speciﬁc process, it will have
a full kernel view. When executing this process, its kernel
execution may be interrupted or the process may voluntarily
give up the CPU. If we enable a customized kernel view for
that process at this time and the process is re-scheduled by
the kernel, some functions in the process’ execution stack
may not be in the new kernel view. We give an example of
this situation in Figure 3.
In this case, the process was re-scheduled while executing
pipe poll at address 0xc0211370. The invocation chain in
the stack is as follows:
syscall call → sys poll → do sys poll
We ﬁnd that because sys poll and do sys poll are not in
the new customized kernel view, their code regions are ﬁlled
with UD2 (shown in red). If we recover pipe poll and return
to its caller (do sys poll), the process will execute undeﬁned