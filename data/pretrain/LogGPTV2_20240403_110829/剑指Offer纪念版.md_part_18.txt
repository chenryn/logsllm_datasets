本题完整的源代码详见14_ReorderArray项目。
源代码：
如果把问题改成把数组中的负数移到非负数的前面，或者把能被3整
测试用例：
对于已经工作过几年的应聘者，面试官还将考查其对扩展性的理
两部分，不是一件容易的事情，需要较快的思维能力。
考查应聘者的快速思维能力。要在短时间内按照要求把数组分隔成
特殊输入测试（输入NULL指针、输入的数组只包含一个数字)。
解，要求应聘者写出的代码具有可重用性。
都出现在奇数的前面，输入的数组中所有奇数都出现在偶数的前面)。
功能测试（输入数组中的奇数、偶数交替出现，输入的数组中所有偶数
一名企面试官精讲典型编程题（纪念版）
---
## Page 121
struct ListNode
如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。
数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例
面试题15：链表中倒数第k个结点
题的根源要好得多。
提前解决问题。这比让面试官发现问题之后我们再去慌忙分析代码查找问
那么代码会出什么问题？这样的思考方式能够帮助我们发现潜在的问题并
表中结点的个数大于k。我们就要问如果链表中的结点的数目不是大于k个，
题。比如面试题15“链表中倒数第k个结点”，这里隐含着一个条件就是链
单。
有防御性编程的习惯，能够写出鲁棒的软件。
能把这些问题都提前考虑到，并做相应的处理，那么面试官就会觉得我们
怎么办？如果输入的是一个字符串，那么字符串的内容为空怎么办？如果
格外关注这些函数的输入参数。如果输入的是一个指针，那指针是空指针
验证用户输入是否符合要求。通常面试要求的是写一两个函数，我们需要
我们的掌握之中，而不至于出现不可预见的事情。
可以试图连接备用服务器等。这样当异常情况发生时，软件的行为也尽在
存在，我们可以提示用户检查文件名和路径：当服务器连接不上时，我们
并为这些可能出现的问题制定处理方式。比如试图打开文件时发现文件不
编程。防御性编程是一种编程习惯，是指预见在什么地方可能会出现问题，
的代码是否鲁棒也非常关注。提高代码的鲁棒性的有效途径是进行防御性
这个链表的倒数第3个结点是值为4的结点。
。我们看到问题的时候，要多问几个“如果不………那么…”这样的问
int
链表结点定义如下：
题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多
在面试时，最简单也最实用的防御性编程就是在函数入口添加代码以
当然并不是所有与鲁棒性相关的问题都只是检查输入的参数这么简
由于鲁棒性对软件开发非常重要，面试官在招聘的时候对应聘者写出
m_nValue;
第3章高质量的代码107
---
## Page 122
108
剑指Offer一
点（如图3.5（a）所示）。接着我们把第二个指针初始化指向链表的第一个
过程。首先用第一个指针从头结点开始向前走两（2=3-1）步到达第3个结
结点时，第二个指针指向倒数第3个结点。
头结点。（c）两个指针一同沿着链表向前走。当第一个指针指向链表的尾
图3.5在有6个结点的链表上找倒数第3个结点的过程
（c）
(b)
点时，第二个指针（走在后面的）指针正好是倒数第k个结点。
不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于
个指针。第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持
后
第
从头开始遍历链表，每经过一个结点，计数器加1就行了。
结点开始往后走n-k+1步就可以了。如何得到结点数n？这个不难，只需要
第 n-k+1个结点。如果我们能够得到链表中结点的个数n，那我们只要从头
（a)
来。假设整个链表有n个结点，那么倒数第k个结点就是从头结点开始的
这种思路行不通。
链表，单向链表的结点只有从前往后的指针而没有从后往前的指针，因此
尾端回溯k步。可是我们从链表结点的定义可以看出本题中的链表是单向
第二次就能找到倒数第k个结点。但是当我们把这个思路解释给面试官之
下面以在有6个结点的链表中找倒数第3个结点为例分析这个思路的
注：（a）第一个指针在链表上走两步。（b）把第二个指针指向链表的
为了实现只遍历链表一次就能找到倒数第k个结点，我们可以定义两
，他会告诉我们他期待的解法只需要遍历链表一次。
也就是说我们需要遍历链表两次，第一次统计出链表中结点的个数，
既然不能从尾结点开始遍历这个链表，我们还是把思路回到头结点上
为了得到倒数第k个结点，很自然的想法是先走到链表的尾端，再从
一名企面试官精讲典型编程题（纪念版）
---
## Page 123
是意料之外但也在情理之中。
看到这样的代码时会有什么样的心情，最终他给出的是拒信而不是Offer虽
环执行的次数远远超出我们的预计，同样也会造成程序崩溃。
得到的将不是-1，而是4294967295（无符号的0xFFFFFFFF）。因此for循
环中会在链表上向前走k-1步，仍然会由于空指针造成程序崩溃。
程序崩溃。
以找出3种办法让这段代码崩溃：
原因很简单，就是自己写的代码不够鲁棒。以上面的代码为例，面试官可
可是几天之后他们等来的不是Offer，却是拒信，于是百思不得其解。其实
题，因此听到面试官问这道题，他们心中一阵窃喜，很快就能写出代码。
ListNode* FindKthToTail(ListNode* pListHead,unsigned int k)
3.5（c）所示）。
到达链表的尾结点时，第二个指针指向的刚好就是倒数第3个结点（如图
结点（如图3.5（b）所示)。最后让两个指针同时向前遍历，当第一个指针
这么简单的代码却存在3个潜在崩溃的风险，我们可以想象当面试官
输入的参数k为0。由于k是一个无符号整数，那么在for循环中k-1
输入的以 pListHead 为头结点的链表的结点总数少于k。由于在 for 循
输入的pListHead 为空指针。由于代码会试图访问空指针指向的内存，
有不少人在面试之前从网上看到过用两个指针遍历的思路来解这道
return pBehind;
while(pAhead->m_pNext !=NULL)
pBehind=pListHead;
for（unsigned inti=0;im_pNext;
pAhead->m_pNext;
pListHead;
NULL;
第3章
高质量的代码109
---
## Page 124
110剑指Offer-
ListNode* FindKthToTail(ListNode* pListHead,unsigned int k)
m_pNext，因此我们在 for循环中应该加一个if判断。修改之后的代码如下：
表的结点数少于k，在 for 循环中遍历链表可能会出现指向 NULL 的
数是从1开始的，因此输入0没有实际意义，也可以返回NULL。如果链
NULL。如果输入的k是0，也就是试图查找倒数第0个结点，由于我们计
为NULL，那么整个链表为空，此时查找倒数第k个结点自然应该返回
的风险，那我们很有可能和Offer失之交臂。
return pBehind;
本题完整的源代码详见15_KthNodeFromEnd项目。
pBehind =pListHead;
ListNode*pBehind=NULL;
ListNode*pAhead=pListHead;
if（pListHead == NULL 11 k ==0)
源代码：
for（unsigned inti=0;im_pNext;
if(pAhead->m_pNext != NULL)
return NULL;
else
一名企面试官精讲典型编程题（纪念版）
return NULL;
pAhead=pAhead->m_pNext;
如果写出的代码存在多处崩溃
---
## Page 125
上走两步），或者让它先在链表上走若干步。
针来遍历链表。可以让其中一个指针遍历的速度快一些（比如一次在链表
当我们用一个指针遍历链表不能解决问题的时候，可以尝试用两个指
举一反三：
相关题目：
本题考点：
测试用例：
求链表的中间结点。如果链表中结点总数为奇数，返回中间结点
考查代码的鲁棒性。鲁棒性是解决这道题的关键所在。如果应聘
考查对链表的理解。
特殊输入测试（链表头结点为NULL 指针，链表的结点总数少于
功能测试（第k个结点在链表的中间，第k个结点是链表的头结
NULL）都没有追上第一个指针，那么链表就不是环形链表。
就是环形链表；如果走得快的指针走到了链表的末尾（m_pNext 指向
指针一次走两步。如果走得快的指针追上了走得慢的指针，那么链表
两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个
判断一个单向链表是否形成了环形结构。和前面的问题一样，定义
走到链表的末尾时，走得慢的指针正好在链表的中间。
一个指针一次走一步，另一个指针一次走两步。当走得快的指针
这个问题，我们也可以定义两个指针，同时从链表的头结点出发，
如果结点总数是偶数，返回中间两个结点的任意一个。为了解决
面试的。
者写出的代码有着多处崩溃的潜在风险，那么他是很难通过这轮
k，k等于0)。
点，第k个结点是链表的尾结点)。
第3章高质量的代码111
---
## Page 126
112
剑指Offer-
本身之外，还需要i的前一个结点h，因为我们需要把结点i的m_pNext 指
调整结点i的m_pNext 之前，把结点j保存下来。
们无法在链表中遍历到结点j。为了避免链表在结点i处断开，我们需要在
个结点，导致链表在结点i、j之间断裂。
图3.6反转链表中结点的m_pNext指针导致链表出现断裂
所示。
个结点。接下来我们把i的m_pNext指向h，此时的链表结构如图3.6（b)
们已经把结点h 之前的指针调整完毕，这些结点的 m_pNext 都指向前面一
（a）所示的链表中，h、i和j是3个相邻的结点。假设经过若干操作，我
指针这个复杂的过程分析清楚，我们可以借助图形来直观地分析。在图3.6
（b)
析再写出鲁棒的代码。
试官留下很好的印象。与其很快写出一段漏洞百出的代码，倒不如仔细分
时候我们不要急于动手写代码，而是一开始仔细分析和设计，这将会给面
在实际软件开发周期中，设计的时间通常不会比编码的时间短。在面试的
来考查应聘者的编码功底。为了避免出错，我们最好先进行全面的分析。
是容易出错的。很多面试官喜欢出链表相关的问题，就是想通过指针操作
struct ListNode
转后链表的头结点。链表结点定义如下：
(a)
面试题16：反转链表
也就是说我们在调整结点i的 m_pNext 指针时，除了需要知道结点i
不难注意到，由于结点i的 m_pNext 指向了它的前一个结点，导致我
为了正确地反转一个链表，需要调整链表中指针的方向。为了将调整
解决与链表相关的问题总是有大量的指针操作，而指针操作的代码总
ListNode*m_pNext;
int
题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反
日1日1□1日1日
一名企面试官精讲典型编程题（纪念版）
m_nKey;
日门
---
## Page 127
面试官找出问题之后再去慌慌张张修改代码要好得多。其实面试官检查应
提交面试官。我们要记住一点：自己多花时间找出问题并修正问题，比在
那也要在心里默默运行代码做单元测试。只有确保代码通过测试之后，再
立即用事先准备好的测试用例检查测试。如果面试是以手写代码的方式，
上述错误呢？一个很好的办法就是提前想好测试用例。在写出代码之后，
不一样。那么应聘者如何才能及时发现并纠正代码中的问题，以确保不犯
ListNode*ReverseList(ListNode* pHead)
的结点。
结点是原始链表的尾结点。什么结点是尾结点？自然是m_pNext 为 NULL
因此相应地我们需要定义3个指针，分别指向当前遍历到的结点、它的前
向结点h。同时，我们还事先需要保存i的一个结点j，以防止链表断开。
一个结点及后一个结点。
在实际面试的时候，不同应聘者的思路各不相同，因此写出的代码也
有了前面的分析，我们不难写出如下代码：
在面试的过程中，我们发现应聘者的代码中经常出现如下3种问题：
最后我们试着找到反转后链表的头结点。不难分析出反转后链表的头
返回的反转之后的头结点不是原始链表的尾结点。
输入的链表头指针为 NULL 或者整个链表只有一个结点时，程序
反转后的链表出现断裂。
立即崩溃。
return pReversedHead;
while(pNode != NULL)
ListNode*
ListNode*
ListNode* pReversedHead = NULL;
pNode=pNext;