# Fr3v1带你读论文-Hybrid Firmware Analysis for Known Mobile and IoT Security
Vulnerabilities
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
[Hybrid Firmware Analysis for Known Mobile and IoT Security
Vulnerabilities](https://ieeexplore.ieee.org/abstract/document/9153399)([针对移动和物联网设备已知漏洞的混合固件分析](https://www.anquanke.com/post/id/259246))的太长不看版
## 主要内容
移动设备和物联网设备的操作系统以及它们随后的升级文件通常是以二进制文件的形式发布。由于这些二进制文件通常是闭源的，用户或第三方企业若是想测试软件的安全性只能依靠逆向工程，此外，如何验证二进制文件中最近的补丁是否有效也是一个悬而未决的问题。常规的软件补丁修复是提升移动设备和物联网设备安全性的重要保障，这就需要开发人员、集成商和供应商的共同支持，及时把补丁分发到受影响的所有设备上。但实际上，供应商们对移动和物联网产品遵循着不同，甚至是错误的安全更新议程。其次，以往的研究反映出存在着“潜在的补丁缺口(a
hidden patch
gap)”：有些供应商错误的声称他们已经修复了漏洞。因此，在二进制文件中检测漏洞是否被修复对于软件安全至关重要。以往对二进制文件中的漏洞检测大多基于静态的代码相似性分析，然而它无法捕捉程序的动态行为，因此可能产生大量误报且难以区分漏洞是否已经修复。  
在论文中，作者提出了一个针对可执行文件漏洞和补丁存在性检测的框架PATCHECKO。它混合了静态检测和动态检测方法，能够对X86和arm架构的二进制代码进行漏洞检测。作者的测试结果表明这个框架对漏洞检测和漏洞函数区分具有较高的准确率。
## 设计与实现
PATCHECKO的工作需要以下三个步骤：
  1. 训练漏洞检测器
  2. 用漏洞检测器对固件进行静态分析
  3. 对2分析得出的可能含有漏洞的函数进行动态分析，验证漏洞是否存在并识别函数中的漏洞是否被修复
工作过程如图：
## 0x1 漏洞静态检测器和静态分析
对于已知漏洞挖掘，深度学习方法的准确性和效率都明显优于过去的二分图匹配和动态相似性测试。PATCHECKO的漏洞检测器使用Keras和TensorFlow实现了神经网络的建模、训练和分类，使用TensorBoard来实现整个训练过程的可视化。
###  Ⅰ 构建数据集
使用反汇编器（如IDA）的插件提取程序控制流图（CFG），并生成每个函数以及其基本块级的特征向量，每个特征向量包括48个特征，如下图：
###  Ⅱ 深度学习
作者在采用了一个线性层堆叠的序贯模型。  
图3展示了一个用于深度学习模型的样本向量。样本向量由函数向量对和一个表示两个函数是否相似的比特组成，其中两个相似的特征向量对应着相同源代码的两个二进制函数。图4是该6层序列模型训练的实际过程，第一层接收输入张量的形状（input
shape）的信息。这个模型使用了从数据集中提取的函数特征进行训练。
## 0x2 动态分析
动态分析的工作流程如图5：
该阶段使用相同的输入值执行两个函数，并比较两个函数的执行轨迹和其他特征的相似性。
###  Ⅰ 动态分析引擎的输入数据
作者使用Fuzz工具（在评估过程中选用了LibFuzzer）生成函数的多组输入数据，以完全覆盖CFG，并测试证明这些数据都能正常运行于漏洞函数和已修复漏洞的函数。接着使用这些数据来测试每个候选函数，筛去执行过程中崩溃的函数。  
随后PATCHECKO将剩下函数作为可执行文件导出，在后续动态分析中使用DLL注入进行执行
###  Ⅱ 插桩测试
作者使用了gdbserver和debugserver对函数执行进行跟踪和特征提取，提取的特征包括指令的数量和类型、系统调用的次数和类型，以及库函数调用和堆栈数据读写量等，具体在表Ⅱ中展示：
对于每个输入执行时，动态分析引擎会对每个特征会生成一组观察结果。当该函数里的所有指令都被覆盖到后，PATCHECKO会根据所有结果生成一个单独的向量。这个过程会在每次对函数进行不同输入时重复。
###  Ⅲ 计算函数语义相似度
对于每个函数对(f,g)，PATCHECKO基于它们的动态特征向量距离计算出语义相似度。对于每个函数的特征向量，PATCHECKO使用了闵氏距离(Minkowski
Distance)作为测量相似度的方法，在评估过程中，作者把p设为3。闵氏距离公式的一般式如下：
在这个公式中，f代表了CVE函数，g代表目标固件中的候选函数，k指的是用到了第k个执行环境，x和y分别代表f和g的动态特征向量，此时P设为3。
每个函数相似度的最终结果为所有执行环境中得到相似距离的平均值，相似度计算方程如下（k为执行环境编号）：
###  Ⅳ 补丁检测
PATCHECKO使用了一个差分引擎来收集静态和动态相似性的检测结果，以此判断漏洞是否被修复。  
对于给定的漏洞函数fv、已修复函数fp和目标函数ft，差分引擎会首先生成三个值：fv、fp和ft的静态特征、simv与simt、simp与simt的动态语义相似性得分以及Sv和Sp之间的差分特征（differential
signatures）。静态特征即上述的48个不同的量化特征，动态语义相似度得分与上述的函数相似度指标。差分特征（differential
signatures）是一个用于比较CFG结构的附加指标，即两个函数的CFG拓扑以及语义信息，例如函数参数、局部变量和库函数调用。
## 评价
###  评估结果
对于模型训练数据集，作者使用Clang从Android-8.1.0_r36的源码中编译了100个库函数，每个库根据不同的目标平台（ x86, AMD64,
ARM 32bit， ARM 64bit ISA）、优化级别（O0, O1, O2,O3, Oz,
Ofast）生成了23个不同的二进制文件，总共获得了2108个库文件，包含了2037772个函数特征样本。其中1222663个函数用于模型训练，407554个函数用于校验，407555个函数用于下图的测试  
图8展示了在训练了大约15小时后，深度学习模型的准确率和损失，其中准确率可达到96%。
作者对Android Things 1.0 和 Google Pixel 2 XL (Android 8.0)
的固件进行了评估。所用的漏洞函数数据集来自Android Security
Bulletins，包括了从2016年7月到2018年11月的漏洞，涵盖2076个漏洞。检测结果表明，模型的静态检测平均准确率高于93%
对于动态分析输出的漏洞函数，除了深度学习阶段就被漏报的CVE-2017-13209外，PATCHECKO能将其余所有预期的目标函数输出到结果的前三位。
对于函数是否已修复的检测，PATCHECKO在25个CVE漏洞函数中只遗漏了CVE-2018-9470，该CVE的漏洞函数和修复函数仅差了一个整数。
## 缺点
  1. 在静态检测时，PATCHECKO通过比较候选函数与已修复/未修复函数来检测是否为目标函数，这导致了可能会产生遗漏
  2. 检测漏洞是否已修复时，由于CFG表示的特征粒度不够细，可能会因为漏洞函数和已修复函数之间的差异非常微小，导致相似性检测可能无法捕捉到它们之间的差异。
第二点或许可以通过应用/结合其他程序表示方法，如CDG、PDG等结构来进行优化。但如作者所说的，这样可能还需要进一步对方案通用性方面进行设计。