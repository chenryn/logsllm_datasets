19

20 }
}
}
}
. . . ) ;
bind( sock , . . . ) ;
WSAIoctl( sock , OPT PROMISCUOUS,
while (recv( sock , b u f f e r , . . ) ) {
i p = (IPHEADER ∗) b u f f e r ;
i f
( ip−>p r o t o == TCP){
p a c k e t = b u f f e r + s i z e o f (TCPHEADER ) ;
i f
( s t r s t r ( p a c k e t , ” password ” )
w r i t e ( log , ” Got a password ! ” ) ;
w r i t e ( log , p a c k e t ) ;
!= NULL){


Running example. As a running example to illustrate the
way in which genotype model generation works, consider
the code snippet shown in Program 1. This code snippet
shows a part of the main control loop of a bot. In particular,
we focus on one case statement that is executed when the
bot receives a “sniff” command. If the botmaster sends such
a command, the program ﬁrst opens a socket in promiscuous
mode (Lines 5-9). Then, for each packet, the code checks
whether a TCP packet was received (Lines 11 and 12). If so,
the bot scans the packet payload for passwords (indicated by
the presence of the string password) and logs those that
are found (Lines 13-16).
When the code in the example is executed during dynamic
analysis, our system would recognize that the WSAIoctl
call is being used to put a socket in promiscuous mode.
This behavior is associated with “snifﬁng activity,” and
the dynamic behavior identiﬁcation step would mark the
WSAIoctl call in Line 9 as relevant, together with all
other calls operating on the promiscuous socket sock; the
socket, bind, and recv calls in Lines 5, 8 and 10. The
corresponding genotype that we aim to identify and model
is the entire case statement (the code enclosed in the box),
but not the helper functions such as strstr.
For packet snifﬁng activity, the genotype extraction phase
ﬁrst computes a forward and backward slice for all relevant
system calls. This includes into the slice Lines 5, 6, 8, 9
and 10 because they operate on the variable sock, which is
the result of the socket system call. Moreover, the system
includes the code in Lines 12, 14, and 16, because they
operate on the tainted data buffer returned by the call to
recv. Note that Lines 11 and 13 are not (yet) included,
because they only manipulate variables that point to tainted
data, but are not themselves tainted. Furthermore, Line 1
is not included in the backwards slice, because our slicing
67
approach takes into account only data ﬂow, and not the effect
of control ﬂow decisions.
2) Filtering: As discussed in the previous section, the
program slice φ contains all instructions that are connected
to relevant system calls by a data ﬂow. However,
is
likely that φ contains code that is not directly related to
the malicious behavior that was observed. This occurs for
two main reasons.
it
First, when generating a forward slice from instructions
that operate on system call outputs (tainted data), it is often
the case that instructions are included that are part of general
purpose utility functions (e.g., string processing routines).
This is particularly critical for library functions that are
statically compiled into a binary, because models for such
functions will match against any code that makes use of the
same library.
A second reason why slices often contain code that is
not directly related to the observed malware behavior is
the fact that backward slices might lead back “too far”
in the program. That is, it is not immediately clear when
the analysis should stop to follow deﬁne-use chains. As
a result, slices frequently contain initialization code. Even
more problematic, when the malware program is unpacked
during runtime, the slice might even include the generic
code of the packer. Including such code into the genotype
is undesirable because the corresponding model potentially
matches all binaries that use the same unpacking routine
(which is clearly not related to a certain runtime behavior).
To address the problem of unrelated code that is part of the
program slices computed during the ﬁrst step, we introduce
an additional ﬁltering step. The goal of this ﬁltering step is
to identify instructions that are not directly responsible for
a malicious behavior. To this end, we have developed the
following two techniques:
White-listing. The ﬁrst technique uses white-listing to re-
move instructions from the slice φ that are not related
to behavior B. White-listing requires a set of white-listed
genotype models Ω = {ω}. Each white-listed genotype
model ω characterizes code that
is not directly related
to a certain behavior B. For each ω, we perform model
matching against the program under analysis. The result of
model matching is a set of instructions Nω ⊆ N of the
malware program that successfully matched against ω. We
then remove all instructions from φ that appear in Nω.
To obtain a white-list for a malware program, we can
make use of the program itself. More precisely, given a
number of threads, processes, or distinct executions of a
program under analysis, we can include into a white-list for
B the genotype model of all the code that is executed by
threads or processes that did not perform behavior B. That
is, whenever a thread or process is run and does not exhibit
behavior B, we can include into the white-list for B all code
that was executed during this run.
It would also be possible to use “foreign” genotypes for
white-listing purposes (where a foreign genotype is derived
from programs other than the malware under analysis). For
instance, we could assemble a collection of genotype models
of standard library functions, or packing routines, and use it
to ensure that no such code is included in genotype models
of a malware sample. We did not use a foreign white-list in
our experiments. However, the results in Section V show that
REANIMATOR nonetheless achieved a high level of accuracy.
Finding exclusive instructions. The second technique relies
on identifying instructions that do not always operate on
tainted data. That is, we identify the set of instructions θ ⊆ φ
such that all instructions in θ operate on tainted data (output
from marked system calls) every time they are executed. We
call these instructions exclusive to the malware behavior.
The rationale behind exclusive instructions is that code
that
is directly responsible for a particular behavior is
expected to always operate on data that is related to this
behavior. General purpose functions, on the other hand,
might also be invoked in other contexts. In those contexts,
these functions will operate on untainted data, and hence,
they will not be included in θ. For example, in the case
of packet snifﬁng, the general-purpose string routines are
very likely to be used also by code that is unrelated to
manipulating the sniffed packet payloads.
At this point, we could remove all instructions from a slice
φ that are not an element of θ. However, in certain cases, this
limits the possibility of the subsequent germination step to
discover additional, relevant instructions. Thus, we perform
the subsequent germination step on instructions in φ, and
use θ only at the end for ﬁnal post-processing.
Running example. In the example shown in Program 1,
the initial slice would not only contain the instructions that
are part of the case statement, but also the code of utility
functions that are called with tainted data (such as strstr
in Line 14). Assuming that we have properly white-listed
this library routine, the corresponding instructions would
be directly removed from the slice. If this code was not
white-listed, it would be removed later. The reason is that it
likely does not contain exclusive instructions. In contrast, all
instructions in the slice that are part of the case statement
are exclusive (i.e., they are in θ), since they always operate
on tainted data.
3) Germination: A ﬁltered slice φ contains instructions
that are directly related to an observed, malicious behavior.
However, a slice might be incomplete. In particular, a slice
might fail to include instructions that are part of a behavior,
simply because these instructions do not directly operate
on tainted data or because they are not part of deﬁne-use
chains. Such instructions typically perform auxiliary tasks,
for example, saving register values to the stack before a
function call, updating a loop counter variable, or performing
68
pointer arithmetic. Others affect the data ﬂow only indirectly,
by inﬂuencing control ﬂow decisions.
The goal of the germination step is to improve the
completeness of a genotype by expanding a slice φ to include
auxiliary instructions that are also part of the code directly
responsible for a behavior. At the same time, we do not want
to reduce the precision of a model by including unrelated
code.
The basic approach to do this is the following: We
consider an instruction as part of the code that implements
a behavior when this instruction cannot be executed without
executing at least one instruction that is part of φ. The
intuition behind this approach is that all instructions in a
slice are known to be directly related to a certain behavior.
Thus, operations that will only be executed together with
these directly-related instructions should also be considered
to be part of this behavior.
Algorithm. More formally, we consider a ﬁltered slice φ to
be the initial genotype for the corresponding phenotype. In
a ﬁrst step, we add all instructions d to the genotype that
are dominated by the slice φ. This is a variation of the well-
known concept of dominance in graphs. In the traditional
case, a node d is dominated by another node n when every
path from the start node to d must go through n. In our case,
we consider an instruction to be dominated by the slice φ
when every path from the start node (function entry point in
the CFG) to d goes through at least one instruction n ∈ φ
(but not necessarily the same n for all paths). In a second
step, we add all instructions p to the genotype that are post-
dominated by the slice φ. Again, this is an extension of the
traditional concept of post-dominance. In our case, we say
that instruction p is post-dominated by slice φ when all paths
to the exit nodes of the graph, starting at p, go through at
least one n ∈ φ. As desired, both dominated instructions d
and post-dominated instructions p cannot be executed unless
at least one instruction n ∈ φ is also executed.
To compute dominator and post-dominator relationships,
the CFG of the program is needed, and it can be built in
one of two ways. First, we can build a dynamic CFG from
the execution trace, which holds all instructions that were
executed during dynamic analysis. This CFG is accurate,
since it contains only instructions that were actually exe-
cuted by the binary under analysis. However, it might be
incomplete, since it does not cover program paths that were
not executed. To include such paths as well, one can build
the static CFG by performing an additional, static analysis
step that attempts to disassemble the non-executed regions.
In addition to the CFG itself, one requires its start and exit
nodes. Currently, we run our analysis on the intra-procedural
CFG. Thus, the start node of the graph is the entry point to
the function (a new function entry point is recorded when-
ever our dynamic analysis observes a call instruction). The
exit nodes of the graph correspond to return instructions.
This works well when operating on the static CFG. When
using a dynamic CFG, however, this approach often misses
exit nodes. The reason is that most exit nodes are never
executed during the dynamic analysis run. Thus, when using
a dynamic CFG, we add pseudo exit nodes to all targets of
conditional branches that were not executed during dynamic
analysis. We currently operate on intra-procedural CFGs
for performance and convenience reasons. When malware
authors decide to attack our technique, e.g., by splitting their
program into a large number of extremely small functions,
or by merging all functions into one, our approach can be
extended to work on the entire program CFG.
n ← |φ(cid:3)|
function entry point  and exit points χ.
Algorithm 1 germinate()
Input: The CFG G = (N, E). The slice φ = {nφ}. The
Result: The extended slice ψ : {nφ} ⊆ {nψ} ⊆ N.
1: φ(cid:3) ← φ
2: repeat
3:
4: H ← G[(N \ {nφ(cid:2)})]
5: M ← mark reachable f orward(H, )
φ(cid:3) ← φ(cid:3) ∪ (N \ M)
6:
7: H ← G[(N \ {nφ(cid:2)})]
8: M ← mark reachable backwards(H, χ)
φ(cid:3) ← φ(cid:3) ∪ (N \ M)
9:
10: until |φ(cid:3)| = n
11: ψ ← φ(cid:3)
Based on either the dynamic or the static CFG G =
(N, E) (N is the set of instructions, and E the control
the slice φ, a start node , and a set of
ﬂow edges),
exit nodes χ, we then apply the algorithm germinate
(Algorithm 1). The goal of this algorithm is to ﬁnd additional
instructions that should be added to the genotype. To this
end, the algorithm ﬁrst locates and marks all instructions
nφ (instructions that are part of slice φ) in the program’s
CFG. Then, it uses graph reachability analysis to identify
the instructions that are dominated and post-dominated by
the slice φ. These instructions are added to φ. Since adding
instructions to a slice φ might increase its dominance and
post-dominance in the graph, the algorithm runs in a loop
until a ﬁxpoint is reached (Lines 2, 3, and 10).
To ﬁnd instructions that are dominated by the slice φ(cid:3),
the algorithm ﬁrst removes the nodes that correspond to
instructions in φ(cid:3) from the graph. More formally, the algo-
rithm generates an induced subgraph H from the CFG G by
removing all nodes from G that are in φ(cid:3) (Line 4). Note that
a subgraph H is said to be induced if, for any pair of vertices
x and y of H, x → y is an edge of H if and only if x → y
is an edge of G. When the set of nodes S in H is a subset
of the nodes in G, then we can write H = G[S]. Then, on
the new graph H, starting from start node , the algorithm
marks all nodes that are still reachable from the start node,
69
following the forward edges (Line 5). All instructions that
could not be reached (i.e., all instructions N\M in the graph
that are not marked) must have been “cut off” from the start
node by the previously removed nodes. That is, there is no
path from the start node to an unmarked node that does not
“pass through” the slice φ. As a result, all instructions that
correspond to these unmarked nodes are added to the slice
(Line 6). A similar approach is used for the post-dominance
computation. The only difference is that the mark algorithm
starts at the exit nodes χ (Line 7) and follows control ﬂow
edges in the opposite direction (backwards, in Line 8).
Model generation. Given the extended slice ψ, the next step
is to translate it into a corresponding genotype model. To
this end, the system proceeds in two steps. First, it splits the
subgraph G[ψ], induced by ψ on the program CFG G, into
maximal connected subgraphs G1, .., GJ. It then splits the
slice into the corresponding subsets ψ1, .., ψJ, where ψj is
the set of instructions corresponding to nodes of Gj. Clearly,
ψ =
(cid:3)
ψj
In the second step, to ﬁlter possibly spurious instructions
that might have been added by the germination step, we
make use of the set of exclusive instructions θ (as introduced
in the previous Section IV-B2). More precisely, we discard
all the slices ψj that contain no instruction in θ. The ﬁnal
slice is then ψf inal = {ψj|ψj ∩ θ (cid:11)= ∅}.
The genotype model γ is deﬁned as the induced subgraph
γ = G[ψf inal].
Running example. The germination phase adds a number of
instructions (lines) to the genotype that were not previously
considered by the program slicing step. In particular, it adds
Lines 11, 13 and 15 (in Program 1), which are dominated
by instructions in the slice (for example, by Line 5). This
step does not, however, add any instructions outside of the
case statement. The reason is that there are paths from the
start of the function (and the switch statement) to other case
statements that do not traverse any instructions in the slice
associated with the sniff behavior.
Interestingly, when we use a dynamic CFG to perform the
germination step, then Line 7 would not be considered in
the genotype. The reason is that the error condition handled
by Line 7 never occurred, so this instruction was never
executed, and hence, would not appear in the dynamic CFG
at all. If, however, the system uses a static CFG, then this
line would be included.
C. Genotype Matching
The output of the previous step is a set of genotype models
γB, one for each observed phenotype B. Thus, the system
knows, for each genotype model, what the corresponding
behavior is. This information can be leveraged to search for
dormant functionality.
Initially, the genotype models must be prepared for efﬁ-
cient searching. To this end, as mentioned in Section IV-A,
each genotype model, which is a graph, is translated into a
set of corresponding ﬁngerprints.
To perform genotype matching and, hence, to identify dor-
mant functionality, an unknown binary is ﬁrst disassembled,
and its CFG is extracted. Then, this CFG is searched for
the presence of ﬁngerprints (as discussed in the context of
polymorphic worms in a previous paper [9]). Whenever a
ﬁngerprint matches, we have found the genotype that this
ﬁngerprint belongs do. Thus, we know that the malware
contains dormant functionality that is capable of producing
the runtime behavior that is associated with this genotype.