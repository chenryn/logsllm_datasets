Total
5
6
7
8
9
10
14
15
16
17
18
19
21
22
23
14
0
0
13
8
0
30
3
20
21
10
28
54
11
46
2
0
0
2
6
0
1
1
0
0
1
2
9
3
8
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
5
4
1
5
0
6
7
0
2
6
0
7
0
0
0
1
0
0
1
0
0
8
0
0
3
0
0
0
0
6
4
1
6
0
6
15
0
2
9
0
128
135
Interestingly, while the total amount of permissions increases with every new
Android release, the number of permissions with normal and dangerous levels,
which guard the functionality exposed to third-party applications, remains fairly
stable. Therefore, from the developer perspective, the cognitive load did not
increase much in terms of new permissions (however, the amount of compatibility
issues to be handled is still growing due to the ﬂuctuations in permissions). At
the same time, security researchers, and platform and system app developers
have to cope with more and more permissions.
At the same time, permissions are not only added. Throughout the plat-
form evolution, many permissions were removed or changed their protection
level. We analyzed code commits to AOSP [1] and found the following reasons
why permissions are removed. Most of the package permissions were removed,
because either the corresponding packages were deleted from the system, or
the functionality of these packages became closed-source. Some permissions
became obsolete because the corresponding functionality was either provided to
all applications (e.g., the backup functionality protected with the BACKUP DATA
permission was made available to all apps in API 8) or merged with other
functionality, as in case of GRANT REVOKE PERMISSIONS (removed in API 23)
used to protect the runtime granting of development permissions. Interestingly,
while the permission READ OWNER DATA was removed in API 9, more than 5 years
An Updated View on the Android Permission System
357
ago, the current documentation still contains references to it1. Additionally,
permissions may be simply renamed (e.g., BROADCAST SCORE NETWORKS became
BROADCAST NETWORK PRIVILEGED). All these perturbations hinder understanding
of the permission system and its changes across Android releases.
According to Table 2, there was only 1 case of the category change: the
ACCESS CACHE FILESYSTEM permission in API 7 was in the package category,
while in API 8 its declaration was moved to the core Android Manifest ﬁle.
As for the protection level changes, Table 2 reports the number of permissions
that increased or decreased2 their protection level.
The overall trend in the table shows that, prior to Android 6.0, permissions
had a tendency to increase their protection level with the lapse of time. However,
the majority of protection level updates were related to changing the protection
level from signature to signature|system, what is actually not a restriction in con-
trol. Although internally signature|system permissions are assigned with a higher
value, in general the signature permissions are more restrictive, because they
allow the apps to obtain these permissions only if the declaring and requesting
packages are signed with the same certiﬁcate. Permissions of the signature|system
level can be also granted if the app is installed into the special system folder,
what allows vendors to use this functionality to vest pre-installed applications
with additional capabilities. For instance, the ability to shutdown the system
(protected with the SHUTDOWN permission) in API 14 was also given to vendor
apps. At the same time, other changes of protection level mostly aimed at limit-
ing the privileges of third-party apps. E.g., in API 16 the READ LOGS permission
allowing to read the system log that may contain sensitive data, changed level
from dangerous to signature|system.
Before API 23 there were not so many cases of decreases in the protection
level. These were mostly related to relaxing dangerous permissions in order to
avoid bothering the end-users with their approval. For instance, the WAKE LOCK
permission allowing an app to prevent the system from going into the sleep mode
changed its level from dangerous to normal in API 17.
There are permissions that changed their protection level several times. E.g.,
permission BATTERY STATS initially appeared as normal. In API 17 it became
dangerous, and in API 19 it emerged as a signature|system permission. Finally,
in API 23 it became a signature permission. Thus, during its life BATTERY STATS
has had all possible security levels.
The API level 23 introduced signiﬁcant changes in protection levels
of permissions. Now, there are only a few dangerous permissions, as opposed to
all previous Android releases. Table 2 shows that the protection level decreased
for 128 permissions. The main reason for this change is deprecation of the signa-
ture|system protection level (104 permissions became signature). Moreover, the
shift to runtime permissions forced platform developers to reconsider the entries
1 http://developer.android.com/guide/topics/manifest/manifest-intro.html.
2 For this table we interpret the protection levels normal, dangerous, signature and
signature|system as an ordered set, where normal corresponds to the least critical
permissions and signature|system – to the most critical.
358
Y. Zhauniarovich and O. Gadyatskaya
in the dangerous set, leaving only the most critical ones that can be compre-
hended by users. Consequently, some dangerous permissions were transformed
into normal (22 cases). Section 6 discusses the eﬀects of these changes.
Permission groups show more stable behavior with respect to changes. In
Android 1.6 (API 4) there were 11 groups. As permission groups were not widely
used, this number remained the same till API 17, when 19 new groups were
added. In API 18 one additional group appeared, resulting in 31 total. There
is not much information why this reorganization happened in these 2 consecu-
tive releases. However, this may be connected with the Google Play installer app
starting to cluster permissions according to their groups [18]. In Android 6.0 per-
mission groups were completely reconsidered once again. There are 4 new groups
added, while 26 were removed, resulting in 9 groups total. This radical change
happened because dangerous permissions are now granted on per-group basis.
Thus, the amount of groups was considerably reduced to avoid overwhelming
users with lots of permissions.
6 Key Findings
Ideally, the security critical components of a system should remain quite stable
to ensure easy security assessment. Unfortunately, this does not hold true in
case of the Android operating system. This section reports on our ﬁndings and
doubts inferred during the analysis of the evolution of the permission system.
6.1
Important Changes in API 23
(1) Runtime permissions. Undoubtedly, from the security perspective one
of the biggest changes in Android 6.0 is the introduction of runtime permis-
sions. Such a change requires eﬀorts from both the OS designers and third-party
developers to ensure backward compatibility of old apps with the new platform
version, and forward compatibility of new apps with older platforms.
Backward compatibility of old apps with the new platform. Although
the intention was to make legacy (targeting the Android API levels before 23)
and new (API level 23) apps to behave in the same way, the diﬀerences are
quite substantial. First, during the installation of a legacy app the user must
agree with the requested permissions, or it will not be installed (see Fig. 1a),
while apps targeting API 23 will be installed silently. Second, after the installa-
tion all dangerous permissions of legacy apps will be in the granted state, while
runtime permissions of new apps will be disabled. Third, and most important,
in Android 6.0 only core permissions can granted and revoked to legacy apps,
while if an app targets API 23 it is also possible to adjust custom dangerous
permissions. Furthermore, some subtle diﬀerences require high attention from
developers. For instance, developers must ensure that the application, which
functionality is called, has been already granted with the permission to access
this functionality [43]. Additionally, in order to use an external library, which
An Updated View on the Android Permission System
359
requires access to the protected functionality, the developers must handle prop-
erly runtime permission requests [42].
Forward compatibility of new apps with older platforms. The new run-
time permission functionality has not come transparently for the application
developers. According to the new guidelines [19], before making an API call
protected with a permission, the app should ascertain that the appropriate per-
mission has been granted. If not, the developer must ask for the permission,
and the user can allow or deny it. Irrespectively of the user’s decision, both
cases must be handled by the developer (see Sect. 3). Unfortunately, the check
whether the permission has been granted does not always return the correct
result. We found out that if a developer runs an app on the older Android
version, which has not yet declared the requested permission, the permission
check returns that the permission is denied, while actually it is not required.
We made a script that automatically identiﬁes the permissions producing this
unexpected behavior by extracting the list of runtime permissions in Android
6.0, and comparing it with the lists of dangerous permissions in the previous
versions. We found 8 such permissions added after API 4, namely USE SIP
(added in API 9); ADD VOICEMAIL (in API 14); WRITE CALL LOG, READ CALL LOG,
READ CELL BROADCASTS, READ EXTERNAL STORAGE (in API 16); BODY SENSORS
(in API 213); and READ TV LISTINGS (in API 23). These peculiarities are not
described in the Android documentation, although some developers have started
to experience problems4. At the same time, there is no bullet-proof solution how
to overcome this issue at the operating system level (it is possible to imple-
ment the corresponding check in apps themselves [44]). As previous versions of
Android are usually not supported (patches for older versions are rarely produced
and deployed), it is practically impossible to deploy patches on all devices run-
ning older versions of Android. Handling through patching the Android support
library is not a solution also, because developers may simply not use it in their
apps. Thus, the developers must consider these cases in their applications them-
selves. In any case, this issue must be at least speciﬁed in the documentation.
(2) Runtime permissions are granted per permission groups. Clearly,
this decision was made to reduce the amount of interruptions for asking permis-
sions at runtime and to facilitate user’s understanding of permissions [36]. At the
same time, experienced users are not given any option to control permissions in
a more ﬁne-grained manner. Similar functionality introduced for the ﬁrst time
in the Google Play client received negative feedback both from the users and
security analysts [18]. Moreover, this architectural decision implies that security
researchers have to consider permission groups in their analysis of apps.
We can remark here that for a long time security researchers have asked for
better and more ﬁne-grained control over sensitive data and functionality on
3 This permission was added in API 20, which we did not analyze (API 20 was devel-
oped for wearable systems).
4 http://stackoverﬂow.com/questions/33482474/android-marshmallow-permission-
model-on-os-4-0-read-external-storage-permission.
360
Y. Zhauniarovich and O. Gadyatskaya
Android (e.g., [32,41,45], to mention just a few). Android 6.0 clearly moves in
the opposite direction. Arguably, the users often did not understand the impli-
cations of various dangerous permissions, and the reduced complexity of permis-
sions could be beneﬁcial for some end-users [36]. Therefore, new evaluations and
studies of the system are required from the community.
(3) UID sharing. There was an attempt to change permission granting to on
per package basis. It failed, and permissions are still granted per UID [2]. This
creates an additional attack possibility for collaborative applications sharing the
same UID to access the functionality protected with runtime permissions. As we
explained in Sect. 3, in Android 6.0 the screen with the required runtime per-
missions is not shown to the user during app installation, but the user’s approval
for these permissions is requested at the runtime. Thus, the user ﬁnds out about
the required permissions only once they are requested. If two applications share
the same UID, then if a user grants a runtime permission to one app, the sec-
ond will be automatically granted with the same permission, and the user will
be unaware of this fact. For instance, the Microsoft Excel [15] and Microsoft
PowerPoint [16] apps share the same UID. Thus, if at runtime Microsoft Excel
is granted with READ EXTERNAL STORAGE permission, the Microsoft PowerPoint
app instantly receives the same permission even without user’s consent. Addi-
tionally, the apps will also receive rights to perform the actions protected with
the WRITE EXTERNAL STORAGE permission (if it is requested by the apps), because
both permissions belong to the same group. This is clearly not the behaviour the
user expects. The eﬀort from the OS developers should be put into this direction.
(4) Signature permissions available to third-party apps. Before it was
assumed that third-party applications cannot obtain any signature permission
if they are not signed with the same certiﬁcate. However, this is not true any-
more, and any new security system for Android needs to take these permissions
into account. In our analysis we found 4 groups of exceptions that considerably
inﬂuence the security analysts. This change especially aﬀects permission maps,
which considered before only dangerous and normal permissions as available for
third-party apps [23].
Appop permissions. Introduction of the appop permissions (with FLAG APPOP
set) entails quite substantial consequences. First of all, for every set of such
permissions a separate activity was added where the user can grant them
to an app. Currently, there are 3 diﬀerent activities responsible for grant-
ing such permissions (an example is given in Fig. 1b): to grant the usage
access (PACKAGE USAGE STATS), draw over other apps (SYSTEM ALERT WINDOW),
and modify system settings (WRITE SETTINGS) privileges. Interestingly, these
activities are accessed through diﬀerent conﬁguration screens: the ﬁrst one is
located under the “Security” settings, while the last two are on the “Conﬁg-
ure apps” screen. This design decision is inconvenient for the users who must
look in diﬀerent locations to grant these permissions. Moreover, internally these
activities are represented as 3 diﬀerent classes with the corresponding permis-
sions hardcoded within each class. Thus, if any new appop permission appears
An Updated View on the Android Permission System
361
in the future, this will require the OS developers to add a new class processing