或 10 。
绝对时间
示何的时间 1968  3  25 。
相对绝对时间式的。进程能 500 内
新 60 或操作 7 。
– 328 –
 10 
时间
相对时间。能存聚 2
 8 文件将文件时写的时间（5
的相对时间的时示自的相
对时间。
Unix  1970  1  1  00:00:00以
的示绝对时间。 UTC（调世时 GMT（林
时间或时间。的 Unix 即绝对时间
更相对的。 Unix 的存自
以的我们将。
件时内的时操作件时时间进
程。内率的周时时
(system timer)。时间时内将时间单
 tick 或 jiffy。 jiffy 的作 jiffy  (jiffies counter)。
jiffy 以 32  2.6 Linux 内 64 进。∗
Linux 的时率 HZ同的
。 HZ 的相的 Linux ABI 的
程能能。上 x86 
 100示时 100 （时的率
100HZ。 jiffy 的 0.01  1/HZ 。 2.6 Linux 内内
 HZ 的子提 1000 jiffy 的 0.001 。然
 2.6.13 的 HZ  250 jiffy  0.004 。∗ HZ 的
的上以的能提的更的时
。
进程何的 HZ  POSIX 时
时率的
long hz;
hz = sysconf (_SC_CLK_TCK);
∗Linux 内的能时时或实时时即内
式 jiffy 。时间的内操作将的时
时。
∗HZ 内的 x86 上以 100、 250  1000。的
空间能何的 HZ 。
– 329 –
 10 
时间
if (hz &=&
-1)
perror (‘‘sysconf’’); /* should never occur
*/
程时率的时将
时间 POSIX 出的时间
或 HZ 的。 HZ 同的
的率 ABI 的 x86 上的 100。以时周
的 POSIX  CLOCKS PER SEC 示的率。
件。时
然时时间然。
的件时时存时间。内时件时
时间。同时内将时间写件时
。理以 hwclock 将时更新时间。
理 Unix 的时间进程
的设墙上时间时间段时间进
的时间以及时。时间相的内。我们
将 Linux 示时间的。
10.1 时间的数据结构
 Unix 的展们示单的时间
上实自的时间理。以
单的段。我们我们
。
10.1.1 原始表示
单的 time t文件  。 time t 
的。然 Unix 上 ( Linux) 单的 C
的
typedef long time_t;
– 330 –
 10 
时间
time t 示自以的。对们的
出。实上的然
的 Unix 实出出。 32 的 time t 能示
 2,147,483,647 。示我们将 2038 然
的 2038  18 的 22:14:07 时件将
 64 的。
10.1.2 毫秒级精度
 time t 相的内。 timeval 对
time t 进扩展。文件  对:
#include 
struct timeval {
time_t tv_sec; /* seconds */
suseconds_t tv_usec; /* microseconds */
};
tv sec  tv usec 。的 suseconds t 
的 typedef。
10.1.3 纳秒级精度
出对的满 timespec 将提。文件
 对
#include 
struct timespec {
time_t tv_sec; /* seconds */
long tv_nsec; /* nanoseconds */
};
更。
timespec 时间相的更的。然
– 331 –
 10 
时间
我们将的的然 timeval。
实时提的何
提的能提的。
的的以提的。
10.1.4 “分解”时间
我们将的进 Unix 时间间的或
示时间。程 C 提 tm将
Unix 时间们理的式。  
#include 
struct tm {
int tm_sec; /* seconds */
int tm_min; /* minutes */
int tm_hour; /* hours */
int tm_mday; /* the day of the month */
int tm_mon; /* the month */
int tm_year; /* the year */
int tm_wday; /* the day of the week */
int tm_yday; /* the day in the year */
int tm_isdst; /* daylight savings time? */
#ifdef _BSD_SOURCE
long tm_gmtoff; /* time zone’s offset from
GMT */
const char *tm_zone; /* time zone
abbreviation */
#endif /* _BSD_SOURCE */
};
tm 以我们更的理 time t 的 314159
周周（。空间的示时间
然的示的时更方。
– 332 –
 10 
时间
tm 段
tm sec
的。 0  59 间以 61 
示 2 。
tm min
小时的。 0  59 间。
tm hour
的小时。 0  23 间。
tm mday
的。 0  31 间。 POSIX  0 然
Linux 示上的。
tm mon
以的。 0  11 间。
tm year
 1900 以的。
tm wday
周以的。 0  6 间。
tm yday
 1 以的。 0  365 间。
tm isdst
示时（DST段的时间效。
 DST 效。 0 DST 效。
DST 的。
tm gmtoff 以的时林时间。段
  BSD SOURCE 出。
tm zone
时的写 EST。段  
 BSD SOURCE 出。
10.1.5 一种进程时间类型
clock t 示时。。对
同 clock t 示实时率（HZ或 CLOCKS PER SEC。
10.2 POSIX 时钟
的调 POSIX 时实示时间
的。 clockid t 示的 POSIX 时 Linux 
CLOCK MONOTONIC
      何 进 程 设  的 单 调   的 时
。示自以的
时间。
CLOCK PROCESS CPUTIME ID 处理提给进程的时。
 i386 上时时间
– 333 –
 10 
时间
（TSC存。
CLOCK REALTIME
真实时间（墙上时间时。设时
。
CLOCK THREAD CPUTIME ID    进 程 的 时       程  
的。 POSIX 时间
CLOCK REALTIME 实的。
然 Linux 提时的
 CLOCK REALTIME。
10.3 时间源精度
SIX  clock getres() 给时间的。
#include 
int clock_getres (clockid_t clock_id,
struct timespec *res);
调 clock getres() 将 clock id 的时存 res 
 NULL 0。时 -1设 errno 以 > 
EFAULT res 的。
EINVAL clock id 上的时间。
以的示将出的时间的
clockid_t clocks[] = {
CLOCK_REALTIME,
CLOCK_MONOTONIC,
CLOCK_PROCESS_CPUTIME_ID,
CLOCK_THREAD_CPUTIME_ID,
(clockid_t) -1 };
int i;
for (i = 0; clocks[i] != (clockid_t) -1; i++) {
– 334 –
 10 
时间
struct timespec res;
int ret;
ret = clock_getres (clocks[i], &res);
if (ret)
perror (‘‘clock_getres’’);
else
printf (‘‘clock=%d sec=%ld nsec=%ld\n’’,
clocks[i], res.tv_sec, res.tv_nsec);
}
 x86 上出的子
clock=0 sec=0 nsec=4000250
clock=1 sec=0 nsec=4000250
clock=2 sec=0 nsec=1
clock=3 sec=0 nsec=1
 4,000,250  4  0.004 。 0.004 给
 HZ  250 的 x86 时的 (我们的)。
我们 CLOCK REALTIME  CLOCK MONOTONIC  jiffy 以
及时提的。相的 CLOCK PROCESS CPUTIME ID 
CLOCK THREAD CPUTIME ID 更的时间同
x86 上 TSC能提。
 Linux 上（ Unix  POSIX 时的
将文件 librt 。的
的程能以的
$ gcc -Wall -W -O2 -lrt -g -o snippet snippet.c
10.4 取得当前时间
程出以的时间示给相
对时间或的时间给件时间。单的
时间的方 time() 
– 335 –
 10 
时间
#include 
time_t time (time_t *t);
time() 调时间以自以的的的
示。 t  NULL将时间写提的 t 。
时 -1（ time t设 errno 相的
。能的 errno  EFAULT t 的。
子
time_t t;
printf(‘‘current time: %ld\n’’, (long) time (&t));
printf(‘‘the same value: %ld\n’’. (long) t);
的时方
time t 示的自以的真的的
。 Unix 的方能的
的。 time t 示的。
10.4.1 一个更好的接口
gettimeofday() 扩展 time()上提
#include 
int gettimeofday (struct timeval *tv,
struct timezone *tz);
调 gettimeofday() 将时间 tv 的 timeval 
0。 timezone  tz  Linux 。
NULL 给 tz。
子
struct timeval tv;
– 336 –
 10 
时间
int ret;
ret = gettimeofday (&tv, NULL);
if (ret)
perror (”gettimeofday”);
else
printf (”seconds=%ld useconds=%ld\n”,
(long) tv.sec, (long) tv.tv_usec);
timezone  时 内  理时 glibc 能
timezone 的 tz dstime 段。我们将何操作时。
10.4.2 一个高级接口
POSIX 提 clock gettime() 时间的时间。然更的
以。
#include 
int clock_gettime (clockid_t clock_id,
struct timespec *ts);
时调 0将 clock id 的时间的时间存 ts
。时调 -1设 errno 
EFAULT ts 。
EINVAL clock id 上时间。
clockid_t clocks[] = {
CLOCK_REALTIME,
CLOCK_MONOTONIC,
CLOCK_PROCESS_CPUTIME_ID,
CLOCK_THREAD_CPUTIME_ID,
(clockid_t) -1 };
int i;
– 337 –
 10 
时间
for (i = 0; clocks[i] != (clockid_t) -1; i++) {
struct timespec ts;
int ret;
ret = clock_gettime (clocks[i], &ts);
if (ret)
perror (”clock_gettime”);
else
printf (”clock=%d sec=%ld nsec=%ld\n”,
clocks[i], ts.tv_sec, ts.tv_nsec);
}
10.4.3 取得进程时间
times() 调的进程及子进程的进程时间进程时
间以时时示。
#include 
struct tms {
clock_t tms_utime; /* user time consumed */
clock_t tms_stime; /* system time consumed */
clock_t tms_cutime; /* user time consumed by
children */
clock_t tms_cstime; /* system time consumed
by children */
};
clock_t times (struct tms *buf);
时调将进程及子进程的进程时间写 buf 的 tms
。的时间时间。时间空间
的时间。时间内空间的时间 (进调或
页的时间)。子进程的时子进程
– 338 –
 10 
时间
进程对调 waitpid()（或相进。调时
时的单调。以时间
( times() 的时间以时时进。)
的以。内以
处理间的内。
的绝对的调的相对时间然。
时调 -1设 errno。 Linux 上能的
EFAULT示 buf 。
10.5 设置当前时间
的何时间程将时间
设给。提的工 ( date ) 
。
时间设 time() 相对的 stime()
#define _SVID_SOURCE
#include 
int stime (time_t *t);
调 stime() 设时间 t 的 0。调
 CAP SYS TIME 。的 root 。
时调 -1设 errno  EFAULT示 t 或
 EPERM示 CAP SYS TIME 。
相单
time_t t = 1;
int ret;
/* set time to one second after the epoch */
ret = stime (&t);
if (ret)
perror (”stime”);
– 339 –
 10 
时间
我们将将我们的时间式方的 time t 
。
10.5.1 高精度定时
 gettimeofday() 对的 settimeofday()
#include 
int settimeofday (const struct timeval *tv ,
const struct timezone *tz);
调 settimeofday() 将时间设 tv 给出的 0。 gettime-
ofday()  tz  NULL 的。时调 -1将 errno
设
EFAULT tv 或 tz 内存。
EINVAL 提的段效。
EPERM
调进程 CAP SYS TIME 。
的子将时间设 1979 的周。
struct timeval tv = { .tv_sec = 31415926,
.tv_usec = 27182818 };
int ret;
ret = settimeofday (&tv, NULL);
if (ret)
perror (”settimeofday”);
10.5.2 设置时间的一个高级接口
 clock gettime() 进 gettimeofday()  clock settime()  settimeof-
day() 时
#include 
– 340 –
 10 
时间
int clock_settime (clockid_t clock_id,
const struct timespec *ts);
调 0 clock id 的时间设 ts 的时间。
时调 -1设 errno 
EFAULT ts 。
EINVAL clock id 上时间。
EPERM
进程设时间的相或时间能设。
上以设的时间 CLOCK REALTIME。
 settimeofday() 处提（处理
的 timezone 。
10.6 玩转时间
Unix  C 提进时间（ASCII 
示的时间 time t 间的。 asctime() 将 tm 时
间 ASCII 
#include 
char * asctime (const struct tm *tm);
char * asctime_r (const struct tm *tm, char *buf);
的的。对何时间的调
能 asctime() 程的。
   程 程 （以 及       设  的       asc-
time r()。的 buf 提的
26 的。
时 NULL。
mktime()  tm  time t。
#include 
time_t mktime (struct tm *tm);
– 341 –
 10 