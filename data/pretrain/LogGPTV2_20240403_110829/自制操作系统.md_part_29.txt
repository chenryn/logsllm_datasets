讲数字问题时，以钱为例大家可能更容易理解，所以我们就用钱来举例说明。比如，把123
元以10元为单位进行向下舍入，就是120元；把456元以100元为单位进行向下舍入，就是400元。
通过这些例子，你会发现“所谓向下舍入，就是把最后几位数字强制变为0”。
所以如果将0x12345678以0x1000为单位进行向下舍入，得到的就应该是0x12345000吧？没
错，这就是正确答案。这样一来，用纸笔就可以进行向下舍入运算了。不过，如果我们要写个程
序让电脑来做同样的事，那该怎么办才好呢？
在二进制下，如果我们想把某位变为0，只要进行“与运算”就可以了，这在4.2节已经介绍
过了。而十六进制其实就是把二进制数4位4位地排在一起，所以要想把十六进制的某一位设置为
0，同样只进行“与运算”就可以。
0x12345678 & 0xfffff000 = 0x12345000
因此把变量i中的数字以0x1000为单位进行向下舍入的式子如下：
i = i & 0xfffff000；
顺便告诉大家一下，以0x10为单位向下舍入的式子是“i =i & 0xfffffff0;”。这样我们就掌握
了向下舍入的方法。
■■■■■
下面我们来看看向上舍入。如果把123元以10元为单位进行向上舍入，就是130元；把456元
以100元为单位进行向上舍入，就是500元。嗯嗯，原来如此，看来先向下舍入，再在它的结果上
做个加法运算就可以了。
以0x1000为单位对0x12345678进行向上舍入的结果为0x12346000。所以有人可能会问：“要
是用程序来表达这个过程的话就应该写成这样吧？”
图灵社区会员 metorm 专享 尊重版权
1 内存管理（续）（harib07a） …… 183
i = (i & 0xfffff000) + 0x1000;
1
看起来貌似确实不错，但其实这并不是正确答案。 因为如果“i = 0x12345000;”时执行上述
命令，结果就变成了“i=0x12346000;”。这当然不对啦。这就相当于，以10元为单位对120元进行
18
向上舍入，结果为130元，但实际上120 元向上舍入后应该还是120元。
所以我们要对程序进行改进。具体做法是：先判断最后几位，如果本来就是零则什么也不做，
3
如果不是零就进行下面的运算。
if ((i & 0xfff) ！= 0) { i = (i & 0xfffff000) + 0x1000;}
20
这样问题就解决了。大功告成。
21
■■■■■
现在我们可以灵活自由地进行向下舍入和向上舍入了，而实际上向上舍入还有改进的“窍 22
门”，那就是：
i = (i + 0xfff) & 0xfffff000; 7
这是怎么回事呢？实际上这是“加上0xfff后进行向下舍入”的运算。不论最后几位是什么，
都可以用这个公式进行向上舍入运算。真的吗？ 8
由于十六进制不易理解，所以我们还是以钱的十进制运算为例来说明吧。如使用这个方法
以100元为单位对456元进行向上舍入，就相当于先加上99元再进行向下舍入。456元加上99元是 9
555元，向下舍入后就是500元了。嗯，这方法做出来的答案没错，456元向上舍入的结果确实就
是500元。
10
那么如果对400元进行向上舍入呢？先加上99元，得到499元，再进行向下舍入，结果是400
元。看，400元向上舍入的结果还是400元。
10
这种方法多方便呀，可比if语句什么的好用多了。不过其中的原理是什么呢？其实加上99元
就是判断进位，如果最后两位不是00，就要向前进一位，只有当最后两位是00时，才不需要进位。
12
接下来再向下舍入，这样就正好把因为加法运算而改变的后两位设置成00了。看，向上舍入就成
功了。
13
这个技巧并不是笔者想出来的，忘了是从哪本书上看到的。能想到这么做的人真是相当聪明
呢。既然有了这么方便的技巧，我们没道理不用，在此笔者大力推荐给大家。而在memman_alloc_4k
14
和memman_free_4k中也大量使用了该技巧。
那么试着“make run”一下吧。可是没有任何反应呀！那当然了，这次做的新函数，还没有
15
被调用呢。
16
图灵社区会员 metorm 专享 尊重版权
184 …… 第10天：叠加处理
COLUMN-6 十进制数的向下舍入
上面介绍了“与运算”可以应用于二进制数和十六进制数的向下舍入，那么对于我们所
熟悉的十进制数的向下舍入，也能使用“与运算”吗?
以0x10为单位对变量 i 进行向下舍入时，实际上是进行了“i = i & 0xfffffff0；”处理,可以
将它看成“i = i &(0x100000000 - 0x10)；”。同样，以0x100为单位进行向下舍入时，进行的是
“i = i & 0xffffff00；”处理，所以这也可以看成是“i = i & (0x100000000 - 0x100)； ”。也就是
说，我们好像可以归纳出“i = i & (0x100000000 - 向下舍入单位)；”。
按照以上思路，如果以100为单位对变量i进行向下舍入，就可以按照“i = i &
(0x100000000  100)；”，即“i = i & 0xffffff9c；”来处理。但这样做并不成功。假设“i = 123；”，
结果是123& 0xffffff9c=24，没有得到我们的预期答案100。
不愿轻易放弃的人可以尝试更多的计算式，不过没有一个能成功,因为不能用“与运算”
来进行十进制数的向下舍入处理，“与运算”只能用于二进制数的向下舍入处理。而十六进
制数因为是4位4位排在一起的二进制数，所以凑巧成功了。
这倒不是说无法对二进制和十六进制以外的数进行向下舍入处理,只不过是不能使用
“与运算”而已。如果允许使用其他方法，一样可以轻松地进行计算。例如“i = (i / 100)*100；”,
只需要先除以100再乘以100就可以了。我们来假设“i=123”，123除以100，结果是1（当整
数除以整数时，答案还是整数，所余的数值叫做“余数”），再用1乘以100就得到了我们的预
期结果100。再假设“i = 456；”，那么先除以100得到4，再扩大100倍结果就是400，这个答
案也是正确的。
我们还可以把计算方法进一步改进一下，写成“i = i  (i %100)；”，意思是用 i 减去 i 除
以100所得的余数。这种方法只用了除法和减法计算，比既用除法又用乘法要快。
不管采用以上哪种方法，在以2n（n>0）以外的数为单位进行向下舍入和向上舍入处理
时，都必须要使用除法命令，而它恰恰是CPU最不好处理的命令之一，所以计算过程要花费
较长的时间（当然，在我们看来是一瞬间就结束了）。而“与”命令是所有CPU命令中速度
最快的命令之一，和除法命令相比其执行速度要快10倍到100倍。
由此可见，如果以1000字节或4000字节单位进行内存管理的话，每次分配内存时，都不
得不进行繁琐的除法计算。但如果以1024字节或4096字节为单位进行内存管理的话（两者都
是在二进制下易于取整的数字。附带说明:0x1000 = 4096），在向上舍入的计算中就可以使用
“与运算”，这样也能够提高操作系统的运行速度，因此笔者认为这个设计很高明。
22 叠加处理（harib07b）
上一节我们为了转换心情，做了内存管理的探讨，现在还是回过头来，继续解决鼠标的问题
吧。从各方面深入思考鼠标的叠加处理确实很有意思，不过考虑到今后我们还面临着窗口的叠加
图灵社区会员 metorm 专享 尊重版权
2 叠加处理（harib07b） …… 185
处理问题，所以笔者想做这么一段程序，让它不仅适用于鼠标的叠加处理，也能直接适用于窗口 1
的叠加处理。
18
■■■■■
其实在画面上进行叠加显示，类似于将绘制了图案的透明图层①叠加在一起。
3
20
21
22
实际上，我们并不是像上面那样仅仅把两张大小相同的图层重叠在一起，而是要从大到小准
7
备很多张图层。
最上面的小图层用来描绘鼠标指针，它下面的几张图层是用来存放窗口的，而最下面的一
8
张图层用来存放桌面壁纸。同时，我们还要通过移动图层的方法实现鼠标指针的移动以及窗口
的移动。
9
10
10
12
13
14
■■■■■
我们想法已经有了，下面就把它们变成程序吧。首先来考虑如何将一个图层的信息编成程序。 15
——————————
16
① 读者朋友如果对图像处理软件中的“层”有所了解，也许脑海中会立刻浮现出这个概念。
图灵社区会员 metorm 专享 尊重版权
186 …… 第10天：叠加处理
struct SHEET {
unsigned char *buf;
int bxsize, bysize, vx0, vy0, col_inv, height, flags;
};
暂时先写成这样就可以了。程序里的sheet这个词，表示“透明图层”的意思。笔者觉得英文
里没有和“透明图层”接近的词，就凭感觉选了它。buf是用来记录图层上所描画内容的地址（buffer
的略语）。图层的整体大小，用bxsize*bysize表示。vx0和vy0是表示图层在画面上位置的坐标，v
是VRAM的略语。col_inv表示透明色色号，它是color（颜色）和invisible（透明）的组合略语。
height表示图层高度。Flags用于存放有关图层的各种设定信息。
只有一个图层是不能实现叠加处理的，所以下面我们来创建一个管理多重图层信息的结构。
#define MAX_SHEETS 256
struct SHTCTL {
unsigned char *vram;
int xsize, ysize, top;
struct SHEET *sheets[MAX_SHEETS];
struct SHEET sheets0[MAX_SHEETS];
};
我们创建了SHTCTL结构体，其名称来源于sheet control的略语，意思是“图层管理”。
MAX_SHEETS是能够管理的最大图层数，这个值设为256应该够用了。
变量vram、xsize、ysize代表VRAM的地址和画面的大小，但如果每次都从BOOTINFO查询
的话就太麻烦了，所以在这里预先对它们进行赋值操作。top代表最上面图层的高度。sheets0这
个结构体用于存放我们准备的256个图层的信息。而sheets是记忆地址变量的领域，所以相应地也
要先准备256份。这是干什么用呢？由于sheets0中的图层顺序混乱，所以我们把它们按照高度进
行升序排列，然后将其地址写入sheets中，这样就方便多了。
不知不觉我们已经写了很多了，不过也许个别地方大家还不太明白，与其在这纸上谈兵，不
如直接看程序更易于理解。所以前面的说明部分，大家即使不懂也别太在意，先往下看吧。
在这里我们稍微说一下结构体吧。内容不难，只是确认大家是不是真正理解了这个概念。
struct SHTCTL结构体的内部既有子结构体，又有结构体的指针数组，稍稍有些复杂，不过
却是一个不错的例子。
我们的这个例子并不是用文字来解说，而是通过图例展示给大家。请大家看看下面这幅
图，确认一下是否理解了结构体。
我们提到的图层控制变量中，仅仅sheets0的部分大小就有32× 256=8 192，即8KB，如果再加
上sheets的话，就超过了9KB。对于空间需要如此大的变量，我们想赶紧使用memman_alloc_4k
图灵社区会员 metorm 专享 尊重版权
2 叠加处理（harib07b） …… 187
来分配内存空间，所以就编写了对内存进行分配和初始化的函数。 1
18
3
20
21
22
7
■■■■■
8
本次的*sheet.c节选
struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize)
{
9
struct SHTCTL *ctl;
int i;
ctl = (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL));
if (ctl == 0) { 10
goto err;
}
ctl->vram = vram;
10
ctl->xsize = xsize;
ctl->ysize = ysize;
ctl->top = -1; /*一个SHEET没都有 */
for (i = 0; i sheets0[i].flags = 0; /* 标记为未使用 */
}
err: 13
return ctl;
}
14
这段程序是什么的呢？首先使用memman_alloc_4k来分配用于记忆图层控制变量的内存空
间，这时必须指定该变量所占空间的大小，不过我们可以使用sizeof（struct SHTCTL）这种写法，
15
让C编译器自动计算。只要写sizeof（变量型），C编译器就会计算出该变量型所需的字节数。
接着，我们给控制变量赋值，给其下的所有图层变量都加上“未使用”标签。做完这一步，
16
这个函数就完成了。
图灵社区会员 metorm 专享 尊重版权
188 …… 第10天：叠加处理
■■■■■
下面我们再做一个函数，用于取得新生成的未使用图层。
本次的*sheet.c节选
#define SHEET_USE 1
struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
struct SHEET *sht;
int i;
for (i = 0; i sheets0[i].flags == 0) {
sht = &ctl->sheets0[i];
sht->flags = SHEET_USE; /* 标记为正在使用*/
sht->height = -1; /* 隐藏 */
return sht;
}
}
return 0; /* 所有的SHEET都处于正在使用状态*/
}
在sheets0[ ]中寻找未使用的图层，如果找到了，就将其标记为“正在使用”，并返回其地址
就可以了，这里没有什么难点。高度设为1，表示图层的高度还没有设置，因而不是显示对象。
程序中出现的&ctl>sheets0[i]是“ctl>sheets0[i]的地址”的意思。也就是说，指的是&
（ctl>sheets0[i]），而不是（&ctl）> sheets0[i]。
■■■■■
本次的*sheet.c节选
void sheet_setbuf(struct SHEET *sht, unsigned char *buf, int xsize, int ysize, int col_inv)
{
sht->buf = buf;
sht->bxsize = xsize;
sht->bysize = ysize;
sht->col_inv = col_inv;
return;
}
这是设定图层的缓冲区大小和透明色的函数，这也没什么难点。
■■■■■
接下来我们写设定底板高度的函数。这稍微有些复杂，所以我们在程序中加入了不少注释。
这里的updown就是“上下”的意思。
图灵社区会员 metorm 专享 尊重版权
2 叠加处理（harib07b） …… 189
本次的*sheet.c节选
1
void sheet_updown(struct SHTCTL *ctl, struct SHEET *sht, int height)
{
int h, old = sht->height; /* 存储设置前的高度信息 */ 18
/* 如果指定的高度过高或过低，则进行修正 */
if (height > ctl->top + 1) {