be unpredictable. We note that this process is only suitable
for ATMS that employ public-coin parameters; our ATMS
constructions in Section V are only of this type.
For the induction base, P is published as part of the
Genesis block G. Each time an MC stakeholder Ui posts the
sidechain support message to MC, he also includes an ATMS
key vki. Subsequently, when the SC is initialised, the stake
∗
jstart is known to the MC participants. Hence,
distribution SD
∗
jstart and ¯ηjstart, these can determine the last 2k
based on SD
slot leaders of epoch jstart in SC, we will refer to them as the
jstart-th trust committee. (In general, the j-th trust committee
for j ≥ jstart will be the set of last 2k slot leaders in epoch
j.) SC-maintainers (that also follow MC) can also determine
the jstart-th trust committee and therefore create avkjstart from
their public keys and insert it into the genesis block G of SC.
They can also serve it as a special transaction to the MC-
maintainers to include into the mainchain. The correctness
of avkjstart can be readily veriﬁed by anyone following the
mainchain using the procedure ACheck of the used ATMS.
For the induction step, consider an epoch j > jstart and
assume that there exists an ATMS key of the previous epoch
avkj−1, known to the mainchain maintainers. Every honest
SC slot leader among the last 2k slot leaders of SC epoch
j − 1 will produce a local signature sj
i on the message m =
(j,(cid:16)pendingj(cid:17), avkj) using their private key skj−1
by running
Sig(skj−1
, m), and include this signature into the block they
create. The rest of the SC maintainers will verify that the
epoch index, avkj and (cid:16)pendingj(cid:17) are correct (by ensuring
ACheck(VKj, avkj) is true for VK denoting the public keys
of the last 2k slot leaders on SC for epoch j, and by recom-
puting the Merkle tree commitment (cid:16)pendingj(cid:17)) and that sj
i
i
i
150
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:41 UTC from IEEE Xplore.  Restrictions apply. 
i
, sj
is valid by running Ver(m, vkj−1
i ), otherwise the block is
considered invalid. Thanks to the chain growth property of the
underlying Ouroboros protocol, after the last 2k slots of epoch
j − 1 the honest sidechain maintainers will all observe at least
k + 1 signatures among the {sj
i : i ∈ [2k]} desired ones. They
then combine all of these local signatures into an aggregated
ATMS signature σj ← ASig(m,{(sj
). This
combined signature is then diffused as part of sc certj on
the mainchain network. The mainchain maintainers verify that
it has been signed by the sidechain maintainers by checking
that AVer(m, avkj−1, σj) evaluates to true and include it in
a mainchain block. This effectively hands over control to the
new committee.
)}, keysj
i , vkj−1
i
V. CONSTRUCTING AD-HOC THRESHOLD
MULTISIGNATURES
We now present an instantiation of the ATMS primitive
based on the multisignature scheme ΠMGS from [6]. Note that
other constructions are possible: we defer a discussion of a
plain signature-based ATMS, as well as an ATMS based on
proofs of knowledge, to the full version of this paper.
We make use of a homomorphic property of ΠMGS: any
d individual signatures σ1, . . . , σd created using secret keys
belonging to (not necessarily unique) public keys vk1, . . . , vkd
can be combined into a multisignature σ =
that
can then be veriﬁed using an aggregated public key avk =
(cid:7)d
i=1 σi
(cid:7)d
(cid:9)
d(cid:10)
aggregate signature
i=1 returns avk = (
i=1 vki.
Our multisignature-based t-ATMS construction works as
follows: the procedures PGen, Gen, Sig and Ver work exactly
as in ΠMGS. Given a set S, denote by (cid:16)S(cid:17) a Merkle-tree
(cid:7)n
commitment to the set S created in some arbitrary, ﬁxed,
deterministic way. Procedure AKey, given a sequence of public
keys VK = {vki}n
i=1 vki,(cid:16)VK(cid:17)). Since
AKey is deterministic, ACheck(VK, avk) simply recomputes
n − d additional public keys {(cid:8)vki}n−d
to verify avk. ASig takes the message m, d pairs of
it
signatures with their respective public keys {σi, vki}d
i=1 and
and produces an
i=1 ,{π(cid:3)vki
i=1 ∪ {(cid:8)vki}n−d
σi,{(cid:8)vki}n−d
(cid:12)
where π(cid:3)vki denotes the (unique) inclusion proof of (cid:8)vki in
following: (a) veriﬁes that each of the public keys(cid:8)vki indeed
(cid:8)vki; (c) returns true if and only
. Finally, the
the Merkle commitment
procedure AVer takes a message m, an aggregate key avk,
and an aggregate signature σ parsed as in (1), and does the
belongs to a different leaf in the commitment (cid:16)VK(cid:17) in avk
using membership proofs π(cid:3)vki; (b) computes avk(cid:5) by dividing
the ﬁrst part of avk by
if d ≥ t and the ﬁrst part of σ veriﬁes as a ΠMGS-signature
under avk(cid:5).
(cid:7)n−d
(cid:11)
(cid:13)
{vki}d
}n−d
σ =
(1)
i=1
i=1
Note that the scheme ΠMGS requires vki to be accompanied
by a (non-interactive) proof-of-possession (POP) [26] of the
respective secret key. This POP can be appended to the public
i=1
i=1
i=1
key and veriﬁed when the key is communicated in the protocol.
For conciseness, we omit these proofs-of-knowledge from the
description (but we include them in the size calculation below).
In the optimistic case where each of the 2k committee
members create their local signatures, both the aggregate key
avk and the aggregate signature σ are linear in the security
parameter, which is optimal. If r < k of the keys do not
provide their local signatures, the construction falls back to
being quadratic in the worst case if r = k − 1.
Concrete signature sizes in this scheme for practical pa-
rameters could be as follows. We set k = 2160 (as is done
in the Cardano implementations of [18]) and for the signature
of [6] we have in bits: |vki| = 272, |σi| = 528 (N. Di Prima,
V. Hanquez, personal communication, 16 Mar 2018), with
|vki +P OP| = |vki|+|σi| = 800 bits. Assuming 256-bit hash
function is used for the Merkle tree construction, the size of
the data which needs to be included in MC in the optimistic
case during an epoch transition is |avk| +|σ| +|(cid:16)pending(cid:17)| =
|vki + P OP| + 2|H(·)| + |σi| = 800 + 512 + 528 = 1840
bits per epoch. In a case where 10% of participants fail
to sign, the size will be |avk| + |σ| = |vki + P OP| +
2|H(·)| + |σi| + 0.1 · 2 · k(|vki + P OP| + log(k)|H(·)) =
800 + 512 + 528 + 432· (500 + 12· 256) = 1544944, or about
190 KB per epoch (which is approximately 5 days).
VI. SECURITY
∗
Our main theorem below states that under natural assump-
tions, the construction from Section IV implements a secure
2-way peg according to Deﬁnition 8.
Let Ahm(L) denote the honest-majority assumption for an
Ouroboros ledger L. Namely, Ahm(L) postulates that in each
slot t, the majority of stake in the stake distribution used to
sample slot leader for slot t in L is controlled by honest parties
for MC
(note that the distribution in question is SD and SD
and SC, respectively). The assumption AMC we consider for
MC is precisely Ahm(MC), while the assumption ASC for
SC is Ahm(MC)∧ Ahm(SC). The reason that ASC ⇒ AMC
is that SC uses merged staking and hence cannot provide any
security guarantees if the stake records on MC get corrupted.
It is worth noting that it is possible to program SC to wean
off MC and switch to independent staking; in such case the
assumption for SC will transition to Ahm(SC) (now with
respect to SD) after the weaning slot and the two chains will
become sidechains of each other.
Theorem 1. Consider the synchronous setting with 2R-
semiadaptive corruptions deﬁned in Section II-A. The con-
struction of Section IV, using a secure ATMS and a collision
resistant hash function, is pegging secure with liveness param-
eter u = 2k with respect to assumptions AMC and ASC, and
merge, eﬀect and VA deﬁned in Section IV-B.
The proof of Theorem 1 is deferred to the full version of the
paper.
Acknowledgements. This research was partially supported by
H2020 project PRIVILEDGE #780477.
151
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:41 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell, A. Miller,
A. Poelstra, J. Tim´on, and P. Wuille. Enabling blockchain innovations
with pegged sidechains.
http://www.opensciencereview.com/
papers/123/enablingblockchain-innovations-with-pegged-sidechains.
2014.
[2] C. Badertscher, P. Gaˇzi, A. Kiayias, A. Russell, and V. Zikas. Ouroboros
genesis: Composable proof-of-stake blockchains with dynamic avail-
ability. Cryptology ePrint Archive, Report 2018/378, 2018.
https:
//eprint.iacr.org/2018/378. To appear at ACM CCS 2018.
[3] E. Ben-Sasson,
I. Bentov, Y. Horesh, and M. Riabzev.
transparent, and post-quantum secure computational
Scal-
able,
integrity.
Manuscript.(2017). Slides at https://people. eecs. berkeley. edu/˜
alexch/docs/pcpip bensasson. pdf, 2017.
[4] I. Bentov, R. Pass, and E. Shi. Snow white: Provably secure proofs
of stake. Cryptology ePrint Archive, Report 2016/919, 2016. http:
//eprint.iacr.org/2016/919.
[5] I. Bentov, R. Pass, and E. Shi. Snow white: Provably secure proofs of
stake. IACR Cryptology ePrint Archive, 2016:919, 2016.
[6] A. Boldyreva. Threshold signatures, multisignatures and blind sig-
natures based on the gap-Difﬁe-Hellman-group signature scheme.
In
Y. Desmedt, editor, PKC 2003, volume 2567 of LNCS, pages 31–46.
Springer, Heidelberg, Jan. 2003.
[7] E. Buchman.
Tendermint: Byzantine fault
tolerance in the age of
blockchains. PhD thesis, 2016.
[8] B. B¨unz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell.
Bulletproofs: Short proofs for conﬁdential transactions and more.
[9] V. Buterin et al. A next-generation smart contract and decentralized
application platform. white paper, 2014.
[10] R. Canetti. Universally composable security: A new paradigm for
cryptographic protocols. In 42nd FOCS, pages 136–145. IEEE Computer
Society Press, Oct. 2001.
[11] B. David, P. Gazi, A. Kiayias, and A. Russell. Ouroboros praos: An
adaptively-secure, semi-synchronous proof-of-stake blockchain. In J. B.
Nielsen and V. Rijmen, editors, EUROCRYPT 2018, Part II, volume
10821 of LNCS, pages 66–98. Springer, Heidelberg, Apr. / May 2018.
[12] J. Dilley, A. Poelstra, J. Wilkins, M. Piekarska, B. Gorlick, and
M. Friedenbach.
Strong federations: An interoperable blockchain
solution to centralized third party risks. CoRR, abs/1612.05491, 2016.
[13] Y. Dodis and A. Yampolskiy. A veriﬁable random function with short
In S. Vaudenay, editor, PKC 2005, volume 3386 of
proofs and keys.
LNCS, pages 416–431. Springer, Heidelberg, Jan. 2005.
[14] C. Dwork and M. Naor. Pricing via processing or combatting junk mail.
In E. F. Brickell, editor, CRYPTO’92, volume 740 of LNCS, pages 139–
147. Springer, Heidelberg, Aug. 1993.
[15] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone
protocol: Analysis and applications.
In E. Oswald and M. Fischlin,
editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 281–
310. Springer, Heidelberg, Apr. 2015.
[16] A. Kiayias, N. Lamprou, and A.-P. Stouka. Proofs of proofs of work
with sublinear complexity. In J. Clark, S. Meiklejohn, P. Y. A. Ryan,
D. S. Wallach, M. Brenner, and K. Rohloff, editors, FC 2016 Workshops,
volume 9604 of LNCS, pages 61–78. Springer, Heidelberg, Feb. 2016.
[17] A. Kiayias, A. Miller, and D. Zindros. Non-interactive proofs of proof-
of-work, 2017.
[18] A. Kiayias, A. Russell, B. David, and R. Oliynykov. Ouroboros: A
provably secure proof-of-stake blockchain protocol.
In J. Katz and
H. Shacham, editors, CRYPTO 2017, Part I, volume 10401 of LNCS,
pages 357–388. Springer, Heidelberg, Aug. 2017.
[19] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and
B. Ford. OmniLedger: A secure, scale-out, decentralized ledger via
sharding.
In 2018 IEEE Symposium on Security and Privacy, pages
583–598. IEEE Computer Society Press, May 2018.
[20] J. A. Kroll, I. C. Davey, and E. W. Felten. The economics of bitcoin
mining, or bitcoin in the presence of adversaries.
In The Twelfth
Workshop on the Economics of Information Security (WEIS 2013),
Washington DC, June 10-11 2013.
[21] S. D. Lerner. Drivechains, sidechains and hybrid 2-way peg designs,
2016.
[22] C. Li, T. Hwang, and N. Lee. Threshold-multisignature schemes where
suspected forgery implies traceability of adversarial shareholders.
In
A. D. Santis, editor, Advances in Cryptology - EUROCRYPT ’94,
Workshop on the Theory and Application of Cryptographic Techniques,
Perugia, Italy, May 9-12, 1994, Proceedings, volume 950 of Lecture
Notes in Computer Science, pages 194–204. Springer, 1994.
[23] L. Luu, V. Narayanan, C. Zheng, K. Baweja, S. Gilbert, and P. Saxena.
A secure sharding protocol for open blockchains.
In E. R. Weippl,
S. Katzenbeisser, C. Kruegel, A. C. Myers, and S. Halevi, editors,
Proceedings of the 2016 ACM SIGSAC Conference on Computer and
Communications Security, Vienna, Austria, October 24-28, 2016, pages
17–30. ACM, 2016.
[24] S. Micali. ALGORAND: the efﬁcient and democratic ledger. CoRR,
abs/1607.01341, 2016.
[25] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.
[26] T. Ristenpart and S. Yilek. The power of proofs-of-possession: Securing
multiparty signatures against rogue-key attacks. Cryptology ePrint
Archive, Report 2007/264, 2007. https://eprint.iacr.org/2007/264.
[27] P. Sztorc. Drivechain - the simple two way peg, November 2015. http:
//www.truthcoin.info/blog/drivechain/.
[28] S. Thomas and E. Schwartz. A protocol for interledger payments.
https://interledger.org/interledger.pdf.
[29] G. Wood. Ethereum: A secure decentralised generalised transaction
ledger. Ethereum Project Yellow Paper, 151:1–32, 2014.
[30] G. Wood. Polkadot: Vision for a heterogeneous multi-chain framework,
2016.
[31] M. Zamani, M. Movahedi, and M. Raykova. RapidChain: A fast
blockchain protocol via full sharding. Cryptology ePrint Archive, Report
2018/460, 2018. https://eprint.iacr.org/2018/460.
[32] A. Zamyatin, N. Stifter, A. Judmayer, P. Schindler, E. Weippl, W. Knot-
tenbelt, and A. Zamyatin. A wild velvet fork appears! inclusive
blockchain protocol changes in practice.
In International Conference
on Financial Cryptography and Data Security. Springer, 2018.
APPENDIX
A. The Diffuse Functionality
that participates. A party,
In the model described in Section II-A we employ the “De-
layed Diffuse” functionality of [11], which we now describe in
detail for completeness. The functionality is parameterized by
Δ ∈ N and denoted DDiﬀuseΔ. It keeps rounds, executing one
round per slot. DDiﬀuseΔ interacts with the environment Z,
stakeholders U1, . . . , Un and adversary A, working as follows
for each round: DDiﬀuseΔ maintains an incoming string for
each party Pi
if activated, can
fetch the contents of its incoming string, hence it behaves
as a mailbox. Furthermore, parties can give an instruction to
the functionality to diffuse a message. Activated parties can
diffuse once per round.
When the adversary A is activated, it can: (a) read all
inboxes and all diffuse requests and deliver messages to the
inboxes in any order; (b) for any message m obtained via a
diffuse request and any party Pi, A may move m into a special
string delayedi instead of the inbox of Pi. A can decide this
individually for each message and each party; (c) for any party
Pi, A can move any message from the string delayedi to the
inbox of Pi.
At the end of each round, the functionality ensures that
every message that was either (a) diffused in this round and
not put to the string delayedi or (b) removed from the string
delayedi in this round is delivered to the inbox of party Pi. If a
message currently present in delayedi was originally diffused
Δ slots ago, the functionality removes it from delayedi and
appends it to the inbox of party Pi.
Upon receiving (Create, U,C) from the environment, the
functionality spawns a new stakeholder with chain C as its
initial local chain (as in [11], [18]).
152
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:41 UTC from IEEE Xplore.  Restrictions apply. 
B. Omitted Algorithms
Here we spell out
the procedures for
initializing the
sidechain (Alg. 2), maintaining the mainchain (Alg. 3), de-