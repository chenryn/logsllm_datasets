这也包括关于宣告节点死亡的决定。如果法定数量的节点宣告另一个节点已经死亡，那么即使该节点仍感觉自己活著，它也必须被认为是死的。个体节点必须遵守法定决定并下台。
最常见的法定人数是超过一半的绝对多数（尽管其他型别的法定人数也是可能的）。多数法定人数允许系统继续工作，如果单个节点发生故障（三个节点可以容忍单节点故障；五个节点可以容忍双节点故障）。系统仍然是安全的，因为在这个制度中只能有一个多数 —— 不能同时存在两个相互冲突的多数决定。当我们在 [第九章](ch9.md) 中讨论 **共识演算法（consensus algorithms）** 时，我们将更详细地讨论法定人数的应用。
#### 领导者和锁
通常情况下，一些东西在一个系统中只能有一个。例如：
* 资料库分割槽的领导者只能有一个节点，以避免 **脑裂**（即 split brain，请参阅 “[处理节点宕机](ch5.md#处理节点宕机)”）。
* 特定资源的锁或物件只允许一个事务 / 客户端持有，以防同时写入和损坏。
* 一个特定的使用者名称只能被一个使用者所注册，因为使用者名称必须唯一标识一个使用者。
在分散式系统中实现这一点需要注意：即使一个节点认为它是 “**天选者（the choosen one）**”（分割槽的负责人，锁的持有者，成功获取使用者名称的使用者的请求处理程式），但这并不一定意味著有法定人数的节点同意！一个节点可能以前是领导者，但是如果其他节点在此期间宣布它死亡（例如，由于网路中断或 GC 暂停），则它可能已被降级，且另一个领导者可能已经当选。
如果一个节点继续表现为 **天选者**，即使大多数节点已经宣告它已经死了，则在考虑不周的系统中可能会导致问题。这样的节点能以自己赋予的权能向其他节点发送讯息，如果其他节点相信，整个系统可能会做一些不正确的事情。
例如，[图 8-4](../img/fig8-4.png) 显示了由于不正确的锁实现导致的资料损坏错误。（这个错误不仅仅是理论上的：HBase 曾经有这个问题【74,75】）假设你要确保一个储存服务中的档案一次只能被一个客户访问，因为如果多个客户试图对此写入，该档案将被损坏。你尝试透过在访问档案之前要求客户端从锁定服务获取租约来实现此目的。
![](../img/fig8-4.png)
**图 8-4 分散式锁的实现不正确：客户端 1 认为它仍然具有有效的租约，即使它已经过期，从而破坏了储存中的档案**
这个问题就是我们先前在 “[程序暂停](#程序暂停)” 中讨论过的一个例子：如果持有租约的客户端暂停太久，它的租约将到期。另一个客户端可以获得同一档案的租约，并开始写入档案。当暂停的客户端回来时，它认为（不正确）它仍然有一个有效的租约，并继续写入档案。结果，客户的写入将产生冲突并损坏档案。
#### 防护令牌
当使用锁或租约来保护对某些资源（如 [图 8-4](../img/fig8-4.png) 中的档案储存）的访问时，需要确保一个被误认为自己是 “天选者” 的节点不能扰乱系统的其它部分。实现这一目标的一个相当简单的技术就是 **防护（fencing）**，如 [图 8-5](../img/fig8-5.png) 所示
![](../img/fig8-5.png)
**图 8-5 只允许以增加防护令牌的顺序进行写操作，从而保证储存安全**
我们假设每次锁定伺服器授予锁或租约时，它还会返回一个 **防护令牌（fencing token）**，这个数字在每次授予锁定时都会增加（例如，由锁定服务增加）。然后，我们可以要求客户端每次向储存服务传送写入请求时，都必须包含当前的防护令牌。
在 [图 8-5](../img/fig8-5.png) 中，客户端 1 以 33 的令牌获得租约，但随后进入一个长时间的停顿并且租约到期。客户端 2 以 34 的令牌（该数字总是增加）获取租约，然后将其写入请求传送到储存服务，包括 34 的令牌。稍后，客户端 1 恢复生机并将其写入储存服务，包括其令牌值 33。但是，储存伺服器会记住它已经处理了一个具有更高令牌编号（34）的写入，因此它会拒绝带有令牌 33 的请求。
如果将 ZooKeeper 用作锁定服务，则可将事务标识 `zxid` 或节点版本 `cversion` 用作防护令牌。由于它们保证单调递增，因此它们具有所需的属性【74】。
请注意，这种机制要求资源本身在检查令牌方面发挥积极作用，透过拒绝使用旧的令牌，而不是已经被处理的令牌来进行写操作 —— 仅仅依靠客户端检查自己的锁状态是不够的。对于不明确支援防护令牌的资源，可能仍然可以解决此限制（例如，在档案储存服务的情况下，可以将防护令牌包含在档名中）。但是，为了避免在锁的保护之外处理请求，需要进行某种检查。
在伺服器端检查一个令牌可能看起来像是一个缺点，但这可以说是一件好事：一个服务假定它的客户总是守规矩并不明智，因为使用客户端的人与执行服务的人优先顺序非常不一样【76】。因此，任何服务保护自己免受意外客户的滥用是一个好主意。
### 拜占庭故障
防护令牌可以检测和阻止无意中发生错误的节点（例如，因为它尚未发现其租约已过期）。但是，如果节点有意破坏系统的保证，则可以透过使用假防护令牌传送讯息来轻松完成此操作。
在本书中，我们假设节点是不可靠但诚实的：它们可能很慢或者从不响应（由于故障），并且它们的状态可能已经过时（由于 GC 暂停或网路延迟），但是我们假设如果节点它做出了回应，它正在说出 “真相”：尽其所知，它正在按照协议的规则扮演其角色。
如果存在节点可能 “撒谎”（传送任意错误或损坏的响应）的风险，则分散式系统的问题变得更困难了 —— 例如，如果节点可能声称其实际上没有收到特定的讯息。这种行为被称为 **拜占庭故障（Byzantine fault）**，**在不信任的环境中达成共识的问题被称为拜占庭将军问题**【77】。
> ### 拜占庭将军问题
>
> 拜占庭将军问题是对所谓 “两将军问题” 的泛化【78】，它想象两个将军需要就战斗计划达成一致的情况。由于他们在两个不同的地点建立了营地，他们只能透过信使进行沟通，信使有时会被延迟或丢失（就像网路中的资讯包一样）。我们将在 [第九章](ch9.md) 讨论这个共识问题。
>
> 在这个问题的拜占庭版本里，有 n 位将军需要同意，他们的努力因为有一些叛徒在他们中间而受到阻碍。大多数的将军都是忠诚的，因而发出了真实的资讯，但是叛徒可能会试图透过传送虚假或不真实的资讯来欺骗和混淆他人（在试图保持未被发现的同时）。事先并不知道叛徒是谁。
>
> 拜占庭是后来成为君士坦丁堡的古希腊城市，现在在土耳其的伊斯坦布林。没有任何历史证据表明拜占庭将军比其他地方更容易出现诡计和阴谋。相反，这个名字来源于拜占庭式的过度复杂，官僚，迂回等意义，早在计算机之前就已经在政治中被使用了【79】。Lamport 想要选一个不会冒犯任何读者的国家，他被告知将其称为阿尔巴尼亚将军问题并不是一个好主意【80】。