本文由红日安全成员： **l1nk3r** 编写，如有不当，还望斧正。
## 前言
大家好，我们是红日安全-代码审计小组。最近我们小组正在做一个PHP代码审计的项目，供大家学习交流，我们给这个项目起了一个名字叫 [**PHP-Audit-Labs**](https://github.com/hongriSec/PHP-Audit-Labs) 。现在大家所看到的系列文章，属于项目
**第一阶段** 的内容，本阶段的内容题目均来自 [PHP SECURITY CALENDAR
2017](https://www.ripstech.com/php-security-calendar-2017/)
。对于每一道题目，我们均给出对应的分析，并结合实际CMS进行解说。在文章的最后，我们还会留一道CTF题目，供大家练习，希望大家喜欢。下面是 **第5篇**
代码审计文章：
## Day 5 - postcard
题目叫做明信片，代码如下：
**漏洞解析** ：
这道题其实是考察由 **php** 内置函数 **mail** 所引发的命令执行漏洞。我们先看看 **php** 自带的 **mail** 函数的用法：
    bool mail (
        string $to ,
        string $subject ,
        string $message [,
        string $additional_headers [,
        string $additional_parameters ]]
    )
其参数含义分别表示如下：
>   * to，指定邮件接收者，即接收人
>   * subject，邮件的标题
>   * message，邮件的正文内容
>   * additional_headers，指定邮件发送时其他的额外头部，如发送者From，抄送CC，隐藏抄送BCC
>   * additional_parameters，指定传递给发送程序sendmail的额外参数。
>
在Linux系统上， **php** 的 **mail** 函数在底层中已经写好了，默认调用 **Linux** 的
**[sendmail](http://www.sendmail.com/)** 程序发送邮件。而在额外参数(
**additional_parameters** )中， **sendmail** 主要支持的选项有以下三种：
>   * -O option = value
>
> QueueDirectory = queuedir 选择队列消息
>
>
>   * -X logfile
>
> 这个参数可以指定一个目录来记录发送邮件时的详细日志情况。
>
>
>   * -f from email
>
> 这个参数可以让我们指定我们发送邮件的邮箱地址。
>
>
举个简单例子方便理解:
上面这个样例中，我们使用 **-X** 参数指定日志文件，最终会在 **/var/www/html/rce.php** 中写入如下数据：
    17220 
     17220  **[filter_var](http://php.net/manual/zh/function.filter-var.php)**
> ：使用特定的过滤器过滤一个变量
>  
>  
>     mixed filter_var ( mixed $variable [, int $filter = FILTER_DEFAULT [,
> mixed $options ]] )
>
> **功能** ：这里主要是根据第二个参数filter过滤一些想要过滤的东西。
关于 **filter_var()** 中 **FILTER_VALIDATE_EMAIL** 这个选项作用，我们可以看看这个帖子 [PHP
FILTER_VALIDATE_EMAIL](https://stackoverflow.com/questions/19220158/php-filter-validate-email-does-not-work-correctly) 。这里面有个结论引起了我的注意： **none of the
special characters in this local part are allowed outside quotation marks**
，表示所有的特殊符号必须放在双引号中。 **filter_var()**
问题在于，我们在双引号中嵌套转义空格仍然能够通过检测。同时由于底层正则表达式的原因，我们通过重叠单引号和双引号，欺骗 **filter_val()**
使其认为我们仍然在双引号中，这样我们就可以绕过检测。下面举个简单的例子，方便理解：
当然由于引入的特殊符号，虽然绕过了 **filter_var()** 针对邮箱的检测，但是由于PHP的 **mail()** 函数在底层实现中，调用了
**escapeshellcmd()** 函数，对用户输入的邮箱地址进行检测，导致即使存在特殊符号，也会被 **escapeshellcmd()**
函数处理转义，这样就没办法达到命令执行的目的了。 **escapeshellcmd()** 函数在底层代码如下（详细点
[这里](https://github.com/php/php-src/blob/PHP-5.6.29/ext/standard/mail.c) ）：
因此我们继续往下看，在第七行有这样一串代码：
    return escapeshellarg($email);
这句代码主要是处理 **$email** 传入的数据。我们先来看一下 **escapeshellarg** 函数的定义：
> **[escapeshellarg](http://php.net/manual/zh/function.escapeshellarg.php)** —
> 把字符串转码为可以在 shell 命令里使用的参数
>
> **功能** ：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入
> shell 函数，shell 函数包含 exec()，system() 执行运算符(反引号)
>
> **定义** ：`string escapeshellarg ( string $arg )`
具体功能作用，可以参考如下案例：
那我们前面说过了PHP的 **mail()** 函数在底层调用了 **escapeshellcmd()**
函数对用户输入的邮箱地址进行处理，即使我们使用带有特殊字符的payload，绕过 **filter_var()** 的检测，但还是会被
**escapeshellcmd()** 处理。然而 **escapeshellcmd()** 和 **escapeshellarg**
一起使用，会造成特殊字符逃逸，下面我们给个简单例子理解一下：
详细分析一下这个过程：
  1. 传入的参数是
        127.0.0.1' -v -d a=1
  2. 由于`escapeshellarg`先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。所以处理之后的效果如下：
        '127.0.0.1'\'' -v -d a=1'
  3. 接着 `escapeshellcmd` 函数对第二步处理后字符串中的 `\` 以及 `a=1'` 中的单引号进行转义处理，结果如下所示：
        '127.0.0.1'\\'' -v -d a=1\'
  4. 由于第三步处理之后的payload中的 `\\` 被解释成了 `\` 而不再是转义字符，所以单引号配对连接之后将payload分割为三个部分，具体如下所示：
所以这个payload可以简化为 `curl 127.0.0.1\ -v -d a=1'` ，即向 `127.0.0.1\` 发起请求，POST 数据为
`a=1'` 。
总结一下，这题实际上是考察绕过 **filter_var()** 函数的邮件名检测，通过 **mail** 函数底层实现中调用的
**escapeshellcmd()** 函数处理字符串，再结合 **escapeshellarg()** 函数，最终实现参数逃逸，导致
**远程代码执行** 。
## 实例分析
这里实例分析选择 **PHPMailer 命令执行漏洞** （ **CVE-2016-10045** 和 **CVE-2016-10033**
）。项目代码可以通过以下方式下载：
    git clone https://github.com/PHPMailer/PHPMailer
    cd PHPMailer
    git checkout -b CVE-2016-10033 v5.2.17