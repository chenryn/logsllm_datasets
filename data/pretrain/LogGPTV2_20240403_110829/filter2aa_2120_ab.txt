char *strip_comma;
/* Hey - it's only for printing and demo purposes.. */
if (serviceFlags & XP1_CONNECTIONLESS)
{
strcat (serviceFlagsText, "Connectionless, ");
}
if (serviceFlags & XP1_GUARANTEED_ORDER)
{
strcat (serviceFlagsText, "Guaranteed Order, ");
}
if (serviceFlags & XP1_GUARANTEED_DELIVERY)
{
strcat (serviceFlagsText, "Message Oriented, ");
}
if (serviceFlags & XP1_MESSAGE_ORIENTED)
{
strcat (serviceFlagsText, "Message Oriented, ");
}
if (serviceFlags & XP1_CONNECT_DATA )
{
strcat (serviceFlagsText, "Connect Data, ");
}
if (serviceFlags & XP1_DISCONNECT_DATA )
{
strcat (serviceFlagsText, "Disconnect Data, ");
}
if (serviceFlags & XP1_SUPPORT_BROADCAST )
{
strcat (serviceFlagsText, "Broadcast Supported, ");
}
if (serviceFlags & XP1_EXPEDITED_DATA )
{
strcat (serviceFlagsText, "Urgent Data, ");
}
if (serviceFlags & XP1_QOS_SUPPORTED )
{
strcat (serviceFlagsText, "QoS supported, ");
}
/* 
* While we're quick and dirty, let's get as dirty as possible..
*/
strip_comma = strrchr(serviceFlagsText,',');
if (strip_comma)
*strip_comma = '\0';
return (serviceFlagsText);
}
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
14
void PrintProtocolInfo (LPWSAPROTOCOL_INFOW prot)
{
wprintf (L"Protocol Name: %s\n",prot->szProtocol); /* #%^@$! UNICODE...*/   
printf ("\tServiceFlags1:  %d (%s)\n",
prot->dwServiceFlags1,
ExpandServiceFlags(prot->dwServiceFlags1));
printf ("\tProvider Flags: %d\n",prot->dwProviderFlags);
printf ("\tNetwork Byte Order: %s\n",
(prot->iNetworkByteOrder == BIGENDIAN) ? "Big Endian" : "Little Endian");
printf ("\tVersion: %d\n", prot->iVersion);
printf ("\tAddress Family: %d\n", prot->iAddressFamily);
printf ("\tSocket Type: ");
switch (prot->iSocketType)
{
case SOCK_STREAM:
printf ("STREAM\n");
break;
case SOCK_DGRAM:
printf ("DGRAM\n");
break;
case SOCK_RAW:
printf ("RAW\n");
break;
default:
printf (" Some other type\n");  
}
printf ("\tProtocol: ");
switch (prot->iProtocol)
{
case IPPROTO_TCP:
printf ("TCP/IP\n");
break;
case IPPROTO_UDP:
printf ("UDP/IP\n");
break;
default:
printf ("some other protocol\n");
}
}
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
15
And finally, the main:
int _cdecl main( int argc, char** argv)
{
LPWSAPROTOCOL_INFOW  bufProtocolInfo = NULL;
DWORD                dwSize = 0;
INT                  dwError;
INT                  iNumProt;
/*
* Enum Protocols - First, obtain size required 
*/
printf("Sample program to enumerate Protocols\n");
WSCEnumProtocols(NULL,                     // lpiProtocols
bufProtocolInfo,          // lpProtocolBuffer
& dwSize,                 // lpdwBufferLength
& dwError);               // lpErrno
bufProtocolInfo = (LPWSAPROTOCOL_INFOW) malloc(dwSize);
if (!bufProtocolInfo){
fprintf (stderr,"SHOOT! Can't MALLOC!!\n");
exit(1); 
}
/* Now, Enum */
iNumProt = WSCEnumProtocols(
NULL,                    // lpiProtocols
bufProtocolInfo,         // lpProtocolBuffer
&dwSize,                 // lpdwBufferLength
&dwError);
if (SOCKET_ERROR == iNumProt)
{
fprintf(stderr,"Darn! Can't Enum!!\n");
exit(1);
}
printf("%d Protocols detected:\n", iNumProt);
for (int i=0; 
i wVersion = MAKEWORD(2,2);
lpWSPData->wHighVersion = MAKEWORD(2,2);
wcscpy(lpWSPData->szProtocol, L”My Name”);  )
- Save the UpCallTable: for future use
- Populate the lpProcTable to the addresses of the local WSP functions
(e.g. - lpProcTable->lpWSPAccept = WSPAccept; 
lpProcTable->lpWSPConnect = WSPConnect;
lpProcTable->lpWSPSend = WSPSend; …)
- Return NO_ERROR
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
17
Winsock 2 Providers
API->SPI Mapping
Most Winsock2 API functions are mapped to corresponding 
SPI functions, with the simple rule of WSA*  WSP*.
Once a WSA* function is called, Winsock 2 will call the 
corresponding WSP function, from the provider chain, in 
order.
ALL functionality can be hijacked – getpeerbyname, 
setsockopt.. AddresstoString, etc.
Call Upcall table function to enable passthrough.
Functions NOT implemented in the SPI:
Event Handling Functions:
WSACreateEvent, 
WSACloseEvent, 
WSASetEvent, 
WSAResetEvent
WSAWaitForMultipleEvents
Naming Services functions:
GetXXXByYYY and their WSAAsync counterparts.
ntohs, ntohl, htonl, htons
inet_XtoY, inet_addr, ... 
As well as:
WSAEnumProtocols – Enumerating service providers
WSAIsBlocking, 
WSASetBlockingHook,
WSAUnhookBlockingHook
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
18
Winsock 2 Providers
Installing Providers
Finally, call our old friend, WSCInstallProvider():
int WSPAPI WSCInstallProvider(
IN LPGUID lpProviderId,
IN const WCHAR FAR * lpszProviderDllPath,
IN const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
IN DWORD dwNumberOfEntries,
OUT LPINT lpErrno
);
ws2spi.h
Reorder using WSCWriteProviderOrder()
Finally, when your service provider is done, install it by an external .exe, like so:
INT InstallProvider(OUT PDWORD CatalogId)
{
WSAPROTOCOL_INFOW  proto_info;
int
rc, errno;
GUID someGUID = { 0x10241975,  0x0000, 0x0000, 0x0000,  0x1234567890 }; 
/* populate PROTOCOL_INFO */
memset(&proto_info , ‘\0’, sizeof(proto_info)); /* Tabula Rasa */
proto_info.dwProviderFlags = PFL_HIDDEN; /* :-) */
proto_info.ProviderId
= someGUID;
proto_info.ProtocolChain.ChainLen = LAYERED_PROTOCOL;
proto_info.iAddressFamily = AF_INET;
proto_info.iSocketType = SOCK_STREAM;
proto_info.iProtocol = IPPROTO_TCP;  
proto_info.iMaxSockAddr = proto_info.iMinSockAddr = 16;
proto_info.iNetworkByteOrder = BIGENDIAN;
proto_info.iSecurityScheme=SECURITY_PROTOCOL_NONE; /* Security? THIS?! HA! */
wcscpy(proto_info.szProtocol, L”Incognito”);
rc = WSCInstallProvider(&LayeredProviderGuid,
L“trojan.dll", // lpszProviderDllPath
&proto_info,   // lpProtocolInfoList
1,             // dwNumberOfEntries (1 too many..)
&errno);       // lpErrno
/* Pass this back to our caller – for reordering.. */
*CatalogId = proto_info.dwCatalogEntryId;
return(rc);
}
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
19
Winsock 2 SPI
Demo
The demo shown is a nearly unmodified version of the 
INTC/MSFT source code provided in the platform SDK.
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
20
Winsock 2 SPI
The Security Issue
No matter how you code your application – if you use 
Winsock, you’re subject to socket hijacking. 
Lessons to be learned:
Whether you use server or client sockets, an attacker can 
intercept your calls and redirect your connections to 
where ever he (or she) pleases.
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
21
Winsock 2 SPI
Good Vs. Bad
Possible (lawful goody-goody) uses include:
- Implement a user-mode application layer firewall
(rather than work at TDI/NDIS, be socket-aware)
- transparently add encryption to applications
(but then, there’s IPSec)
- Support new protocols
(IPv9, anyone? (RFC1606) (for future use: RFC 1149?))
- Enforce QoS
(s/Q/D)
- Patch content on the fly (q.v. Google Desktop)
(A double edged sword)
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
22
Winsock 2 SPI
Let’s just stick with the BAD
But the MUCH better (chaotic evil) uses include:
- Obtain connection statistics, URLs, etc.
(for spyware, statistical purposes, or whatever)
- Eavesdropping (non SSL) connections
(all socket based communication (inc. raw))
- Rerouting connections (i.e. socket hijacking)
The Dark Side has never been so tempting before..
- Patch content on the fly (q.v. Google Desktop) 
(for obvious uses)
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
23
The End…
(or perhaps, the beginning?)
Questions/Comments Welcome:
PI:EMAIL