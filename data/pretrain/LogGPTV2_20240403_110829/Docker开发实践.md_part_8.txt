其中-t参数用来指定镜像的命名空间、仓库名及TAG。这个值可以在镜像创建成功之后通过tag命 8
令修改，事实上是创建一个镜像的两个名称引用，如下所示的xixihe/test:v1和xixihe/test:v2
指向的是同一个镜像实体8758374dc545： 10
# docker tag xixihe/test:v1 xixihe/test:v2
# docker images 10
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
xixihe/test v2 8758374dc545 5 minutes ago 192.7 MB
xixihe/test v1 8758374dc545 5 minutes ago 192.7 MB 11
ubuntu latest 9bd07e480c5b 6 days ago 192.7 MB
紧跟-t参数的是Dockerfile文件所在的相对目录，本例使用的是当前目录，即“.”。从以上的 13
构建输出中可以发现，构建的过程是分步骤的，每一条指令相当于构建一个临时镜像，直到最后
一步生成我们的目标镜像。下面以Step 5为例进行介绍： 14
Step 5 : RUN touch test.txt && echo "abc" >> abc.txt
---> Running in 141802f35d94 15
---> d3625958dc52
Removing intermediate container 141802f35d94
16
它从前一个临时镜像创建出容器141802f35d94，然后在这个容器中执行RUN touch test.txt &&
echo "abc" >> abc.txt命令，接着提交这个容器为一个临时镜像，供下一条Dockerfile指令使用，
17
最后将创建的临时容器141802f35d94删除。通过设置docker build命令参数-rm=false，可以避免
临时缓存被删除。
18
40 第3章 镜像
另外，Step 0、Step 1、Step 2和Step 3与其他步骤却有所不同：
Step 0 : FROM ubuntu:latest
---> 8eaa4ff06b53
Step 1 : MAINTAINER xxh "PI:EMAIL"
---> Using cache
---> f9caa95a4e54
Step 2 : USER root
---> Using cache
---> 05ee079f4925
Step 3 : RUN apt-get update
---> Using cache
---> 73ede9cd2370
这是由Docker构建器的缓存机制所致，每条指令执行都会产生一个缓存镜像，如果我们的
指令链执行过了且产生了缓存镜像，那么下一次再执行这条指令链时，就可以直接使用缓存镜
像，而无须重新执行指令链一遍。例子中的8eaa4ff06b53、f9caa95a4e54、05ee079f4925和
73ede9cd2370即已经存在的缓存镜像的ID。通过设置docker build命令参数--no-cache=true，
可以禁用缓存机制。
接下来，我们就可以使用刚才构建的镜像来创建一个容器了。在容器里，读者可自行检视
Dockerfile中的操作是否已经生效，在此不再展开。
除了使用本地Dockerfile文件外，我们还可以通过指定一个Git仓库来构建。待构建的
Dockerfile文件需要放置在仓库的根目录下，对应的Dockerfile文件里的ADD命令所依赖的文件也必
须放置在Git仓库目录中。在使用build命令时，Docker会自动将文件下载到本地镜像中来。需要
注意的是，build命令所需要的Git地址形式与GitHub上复制到的地址有所不同，如果直接使用来
自GitHub的地址，将会报错。
GitHub上复制的地址形式：PI:EMAIL:xixihe/gitDockerFile.git。
build命令所需要的地址形式：git://github.com/xixihe/gitDockerFile.git。示例代码如下：
# docker build -t xixihe/test:v1 git://github.com/xixihe/gitDockerFile.git
Sending build context to Docker daemon 49.15 kB
Sending build context to Docker daemon
Step 0 : FROM ubuntu
---> 9bd07e480c5b
Step 1 : ADD README.md /opt/
---> 66ef4ce82a4b
Removing intermediate container 95e82db31db1
Successfully built 66ef4ce82a4b
3.4 Docker Hub
在本节中，我们将讲解Docker Hub相关的内容，包括基本介绍、分发本地镜像到Docker Hub、
自动化构建以及创建私有库。
3.4 Docker Hub 41
3.4.1 Docker Hub简介
1
Docker Hub的网址是https://hub.docker.com，它与提供源代码托管服务的GitHub类似，不同的
2
是Docker Hub提供的是镜像托管服务。利用Docker Hub，我们可以搜索、创建、分享和管理镜像，
还可以利用其提供的自动化构建技术直接在集群云服务器上构建镜像。
3
Docker Hub为用户提供不限数目的公开镜像托管服务，但仅提供一个私有镜像托管服务。如
果需要更多的私有镜像托管，需要额外付费。
4
Docker Hub上的镜像分为两类。一类是官方镜像，比如ubuntu、nginx、redis、mysql、wordpress
等，此类镜像一般由权威的第三方（比如Canonical、Oracle、Red Hat等极具背景的大公司）进行 5
开发维护，最后还需要Docker官方认证通过。另一类为普通用户镜像。
6
3.4.2 镜像的分发
7
想要将本机上创建的镜像分发到互联网供其他用户使用，最便捷的方式就是使用Docker
Hub。首先登录Docker Hub官网注册，见图3-3。
9
8
10
10
11
13
14
图3-3 Docker注册页面
15
如果你已经拥有GitHub账号，可以点击用户名框上的Sign up with Github，使用GitHub账号直
接登录。注册时我们所填的用户名就是我们在Docker Hub上的命名空间，在此我们使用的是
16
xixihe，即笔者的用户名。最后，需要填入一个有效的邮箱。注册完后，需要使用此邮箱收取激
活你的Docker Hub账号的邮件。
17
注册成功之后，在命令行客户端登录我们刚才注册的账号：
# docker login 18
Username: xixihe
42 第3章 镜像
Password:
Email: PI:EMAIL
Login Succeeded
登录信息都保存在~/.dockercfg文件中：
# cat ~/.dockercfg
{
"https://index.docker.io/v1/":{"auth":"eGl4aWhlOndob2FtaQ==","email":"PI:EMAIL"}
}
用户名和密码通过哈希运算之后保存在auth字段，这样可以保证密码的安全性。当然，我们
也可以在首次上传镜像时由Docker主动提示我们输入密码。
登录成功之后，使用push命令上传镜像。如果不指定镜像TAG，指定的仓库在本地的所有镜
像都会上传到Docker Hub。下面的push命令将3.2节创建的镜像上传到Docker Hub：
# docker push xixihe/abcd:v1
The push refers to a repository [xixihe/abcd] (len: 1)
Sending image list
Pushing repository xixihe/abcd (1 tags)
511136ea3c5a: Image already pushed, skipping
01bf15a18638: Image already pushed, skipping
30541f8f3062: Image already pushed, skipping
e1cdf371fbde: Image already pushed, skipping
9bd07e480c5b: Image already pushed, skipping
ca1a774c2745: Image successfully pushed
Pushing tag for rev [ca1a774c2745] on
{https://cdn-registry-1.docker.io/v1/repositories/xixihe/abcd/tags/v1}
这样我们的镜像就已经成功上传到了Docker Hub。进入Docker Hub的仓库管理页面，如图3-4
所示，可以发现xixihe/abcd镜像仓库已经成功创建。此外，在镜像管理页面中，我们还可以为镜
像添加或更改图标、描述等信息，这样有助于我们管理镜像，方便其他用户使用该镜像。镜像默
认是公开的，其他用户可以搜索到并使用它。当然，我们也可以将其设为私有的。
图3-4 仓库管理页面
3.4 Docker Hub 43
3.4.3 自动化构建
1
除了在本地创建镜像然后使用push命令将其推送到Docker Hub之外，我们还可以使用Docker
2
Hub提供的自动化构建技术在服务端直接构建镜像。通过在Docker Hub连接一个包含Dockerfile
文件的Git Hub或Bit Bucket的仓库，Docker Hub的构建集群服务器就会自动构建镜像。通过这种
3
方式构建出来的镜像会被标记为Automated Build，也可以称为受信构建（Trusted Build）。
使用自动化构建有以下几个优点。
4
 用户可以确保他拉取的镜像是使用特定方式构建出来的。
 访问你的Docker Hub的用户能够自由查阅Dockerfile文件。 5
 因为构建的过程是自动的，所以能确保仓库里的镜像都是最新的。
6
下面我们将一步一步地演示如何使用GitHub来自动构建镜像。
(1) 登录到Docker Hub，在我的镜像页面点击右上角的Add Repository，见图3-5，然后选择下
7
面的Automated Build。
9
8
10
图3-5 添加库页面 10
(2) 选择用来构建的源，如图3-6所示，这里我们选择GitHub。由于还没有连接过GitHub，所
11
以在接下来的步骤中还要点击Link to your GitHub.com account，见图3-7。
13
14
15
16
17
18
图3-6 选择构建源页面
44 第3章 镜像
图3-7 第一次连接GitHub
(3) 选择连接到GitHub的方式，见图3-8，这里我们选择第一种：Public and Private(recommended)。
图3-8 选择连接到GitHub的方式
(4) 进入GitHub授权登录页面，如图3-9所示。输入你的GitHub账号登录，然后选择Authorize
application，见图3-10。
3.4 Docker Hub 45
1
2
3
4
5
图3-9 GitHub授权登录页面
6
7
9
8
10
图3-10 点击授权
(5) 成功授权后，会进入GitHub仓库选择页面，见图3-11，从中选择你想要构建的仓库。 10
11
13
14
15
16
图3-11 选择GitHub仓库
17
(6) 选择完仓库后，进入自动化构建配置页面，见图3-12。在这个页面中，我们可以配置镜
像的命名空间、仓库名、Tag、所在分支、Dockerfile文件位置、访问属性等。当然，我们也可以
18
全部使用默认值。
46 第3章 镜像
(7) 点击Create Repository按钮完成创建。
图3-12 自动化构建配置页面
(8) 进入自动化构建详情页面，见图3-13。
图3-13 自动化构建详情页面
3.4 Docker Hub 47
(9) 通过步骤(8)中Build Details选项卡中的build Id链接可以跳转到镜像构建的过程信息页面。
1
如果构建失败，我们可以通过这里的Logs信息定位构建失败的原因，见图3-14。
2
3
4
5
6
7
9
8
图3-14 用日志定位失败原因
至此，我们已经完整创建了一个自动化构建仓库。一旦对应的GitHub仓库文件有更新，Docker
10
Hub上的镜像构建就会被自动触发，从而保证镜像都是最新的。
10
3.4.4 创建注册服务器
11
除了使用Docker官方提供的注册服务器Docker Hub来存储管理镜像之外，我们还可以搭建自
己的注册服务器。Docker Hub所使用的注册服务器本身是开源的，并且以镜像的形式分发在
13
Docker Hub上。注册服务器源码的地址是https://github.com/docker/docker-registry，Docker Hub上
的镜像名是registry。
14
我们可以从GitHub上拉取源码，然后使用docker build命令手动构建注册服务器的镜像，也
可以使用docker pull拉取Docker Hub上已经构建好的镜像。使用后者，我们只需要两步就能完成
15
注册服务器的创建，具体如下所示。
(1) 拉取最新的registry官方镜像： 16
# docker pull registry
17
(2) 运行registry：
# docker run –p 5000:5000 -d -i -t registry 18
48 第3章 镜像
这样我们的注册服务器就已经成功地在5000端口运行了。接下来，可以将我们的镜像提交到
这个注册服务器上。
我们使用commit命令将任意一个容器提交成镜像，并且按照[registry_host: registry_port\
image_name:image_tag]方式指定TAG：
# docker ps -a
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS
NAMES
...
56d26c54b98f registry:latest "docker-registry" 9 minutes ago Exited (3) 9 minutes ago
pensive_davinci
...
# docker commit 56d26c54b98f 127.0.0.1:5000/my_image:v1
e35c26122c2ada4f2fb1a84542c3a0ec9e1e0dc191949e01cf5ba43da6aef410