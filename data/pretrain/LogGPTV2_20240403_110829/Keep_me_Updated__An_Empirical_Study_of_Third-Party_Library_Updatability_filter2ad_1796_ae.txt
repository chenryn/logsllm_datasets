4 (0.22%)
3,013
(42%)
236 (99.6%)
—
743 (82.1%)
594 (81.1%)
9,643 (57.3%)
non-fixable
0
0
272
16
10
0
—
0
79
377
(39.9%)
(0.88%)
(0.14%)
(10.8%)
(2.2%)
API changes. However, in reality, the majority of changelog entries
advertises new functionality rather than reporting (detailed) bug
fixes. The fact that we could only find a single entry security fix
illustrates the current status quo pretty well. It seems that library
developers put their main focus on functionality that, according to
our survey results, is only the third most important update crite-
rion. A recent study [26] reports that API changes/removals in the
Android SDK typically trigger discussions on Stack Overflow. A
simple means of providing community support after major releases
would involve an active participation of library developers in such
discussions to clarify changes and provide guidelines on how to
perform the upgrade.
There has also been some discussion about the usefulness of
Semantic Versioning. While it is certainly not supposed to be the
gold standard, it is, in fact, a simple and useful means for library
developers to express compatibility and for consumers to quickly
assess the expected library integration effort. Almost all libraries
in our dataset already use the X.Y.Z scheme, however, it seems
that API compatibility is not always the main factor in the version-
ing process. An open question remains how many developers are
aware of concepts like SemVer and would be able to interpret ver-
sion changes correctly. To raise the awareness, library developers
could pro-actively promote SemVer compliance, e.g. by adding a
SemVer compliant badge to their code repository. In the long term,
this concept will likely become more known, at least among iOS de-
velopers, since the new Swift package manager enforces versioning
according to SemVer rules.
5.2 How to improve Library Updatability?
Based on the survey responses and the follow-up analyses there
are different possibilities on how to improve library updatability
for different entities of the app ecosystem. Note, that this section is
giving educated advices and actionable items based on first-hand
information of app developers and results aggregated from follow-
up analyses on libraries and apps from Google Play. Implementation,
evaluation and assessment of developer adaption for the proposed
technical solutions are subject to future work.
Session J3:  Problematic PatchesCCS’17, October 30-November 3, 2017, Dallas, TX, USA2196The marketplace. One possibility to improve adaption is a cen-
tralized marketplace, like the Google Play Store. With the App
Security Improvement program, Google introduced a service that
identifies security problems in apps. It notifies the respective app
developer and provides a support document on how to fix the prob-
lems. However, this service also enforces that security fixes are
deployed within reasonable time. While this helps to improve the
overall application security on the market, it also comes with inher-
ent limitations. It only warns about known vulnerabilities and app
developers that are writing apps for markets other than the Play
Store do not benefit. The main limitation is, however, that it only
fights the symptoms and does not tackle the underlying problem
of the poor library version adaption rate.
About 79% of the developers in the survey could think of a ded-
icated library store or package manager for Android. There are
already established package managers for other ecosystems such
as nuget (.net), npm (JavaScript), Cargo (Rust), or Cocoapods (iOS).
There is no equivalent in size and acceptance for Android to search
for libraries to date. This is also documented by our survey in which
the majority of developers simply refers to “Google” or “Internet”
when being asked where to search for libraries. An accepted cen-
tral solution could also enforce certain library requirements or
quality standards more easily. For instance, the new Swift package
manager [2] (for macOS and soon for iOS) expects packages to be
distributed as source and to be named according to SemVer rules.
Source distributions might foster contributions and creation of
patches through the community. This is also backed by the results
of the survey in which open-source is the main criteria for library
selection for 61% of developers, next to functionality with about
80%.
Development tools. In 2014 the Android Gradle plugin was in-
troduced to give app developers a powerful dependency manager
to facilitate building complex applications with a larger number
of third-party components. But although this is the preferred way
to integrate libraries for about 30% of app developers, there is still
a high number (20%) that manually integrates libraries or uses a
combination of different methods (33%). Despite Gradle’s high ac-
ceptance (64% like its usability, 31% somewhat), the main criticism
constitutes its poor performance and the steep learning curve that
might be reasons to resort to different approaches. Google picked
up this criticism and recently announced a new Gradle version for
Android Studio that particularly improves build times for complex
applications [6]. Another argument against mixed approaches is
that including libraries manually implies a higher update effort,
since new versions have to be downloaded manually and there is no
notification when new releases become available. This reinforces
the unawareness of library updates among app developers as shown
in Figure 9. In contrast, Android Studio 2.2 recently integrated an
opt-in feature to automatically notify app developers when updates
of integrated third-party libraries from remote repositories such as
Maven Central and JCenter become available.
Besides improving the dependency manager, integrating our
detection of library version compatibility into the IDE could be
helpful to automatically classify a library update and to inform
about the expected code adaption effort based on the set of used
library APIs. We are currently in the process of evaluating how such
a plugin could be implemented for Android Studio, the preferred
IDE for about 61% of app developers in our survey.
Automated library updates to the rescue? A prominent example
for auto-updates is the former system component WebView that was
moved to a standalone-app in Android 5.0 after a series of severe
security vulnerabilities. Distributed as an app, Google can auto-
matically push security patches to this commonly used component
to reach millions of devices that do no longer receive Android OS
updates. Similarly, the app update mechanism of Google Play was
adapted to install app updates automatically as long as no new per-
missions are requested. However, patching libraries that are part of
the application bytecode is somewhat more challenging. Although
Section 4 has demonstrated that 85.6% of libraries could be automat-
ically updated, in 48.2% of the cases even to the latest version, there
might be additional obstacles that prevent auto-updates of minor
and major releases in reality (cf. Section 5.3). However, limiting
auto-updates to patch versions that provide critical bugfixes and
security fixes, would already tremendously improve the current
status-quo.
One possible integration approach includes the developer speci-
fying a subset of included libraries eligible for automatic updates.
A similar approach is deployed by Google Chrome to automati-
cally update extensions [18]. The difference, however, is that the
extension developer may specify this flag. There is also no formal
requirement or quality assurance required, since, in worst case, the
extension could simply be disabled after an unstable update. In
Android, one could further introduce an option to limit updates to
patch level updates that do not introduce new functionality. Accord-
ing to the survey, 52% of app developers would welcome such an
automated update mechanism, while only one quarter disapproves
such approaches. Note, that the questionnaire asked for updates
in general, not for bugfix/security fix updates in particular. Thus,
the acceptance for auto-fixing critical bugs only might actually be
higher.
There are also different on-device deployment strategies to inte-
grate new library versions. One option that does not require larger
modifications of the app installation routine is to integrate new
libraries during on-device compilation time. In Android 6, the ahead-
of-time compiler on the device compiles the entire applications’
bytecode to native code. There, the compilation would have to be
re-triggered for each library update, similar as for new app updates.
With Android 7, the ahead-of-time compilation was replaced by a
just-in-time compiler [13]. This way, library code could be updated
through a forced re-compilation whenever such code is used by
the app. Given the generally low library API usage, the expected
compilation overhead should be negligible.
Decoupling library code from application code, i.e., moving to dy-
namic linking, would be another option to facilitate library updates.
Dynamic linking of third-party components has been disallowed
by Android and iOS for a long time due to security reasons. This
changed with iOS 8, released in September 2014, when Apple ad-
dressed these security concerns with a new kernel extension to
check the integrity of app files [1], i.e., whether dynamic libraries
are signed, have a valid Team Identifier and that this identifier
matches the one of the containing application. Updating (compati-
ble) libraries is then simplified to replacing the library file.
Session J3:  Problematic PatchesCCS’17, October 30-November 3, 2017, Dallas, TX, USA21975.3 Threats to Validity
Programmatically determining the public API of a software com-
ponent is a non-trivial task, specifically on Android where, among
others, advertisement libraries are typically obfuscated with iden-
tifier renaming. We distinguish obfuscated and non-obfuscated
names in a best effort approach, but for corner cases this is gener-
ally undecidable. The same is true for whitelisting package names
that are supposed to be used internally. Only the ground truth in
form of a proper documentation for all library releases would pro-
vide the complete public interface. However, this information is not
always available. Given that we are conservative in our filtering
list, we report a lower bound on updatability, e.g., when we erro-
neously include an obfuscated public API which is not present in
the successor version due to re-obfuscation.
We conduct our library updatability analysis based on API com-
patibility. This constitutes the main factor to determine whether
a library can be updated without any code adaption. We do not
include rare cases in which public, static class fields are renamed in
subsequent library releases. While such cases can cause incompati-
bility, we assume that they do not occur frequently. Moreover, we
do not assess whether the intended functionality is preserved in
the new release, i.e., that no new bugs are introduced and no code
semantics changed that cause unexpected side-effects. Changing
semantics of already existing APIs is considered bad practice and
strongly discouraged as there is no simple means of detecting such
cases for the library consumer.
We also consider the case when libraries depend on additional
libraries. Versions that include other libraries can only be updated
if all sub-dependencies can be updated as well. We found that
55% of the libraries in our database include at least one version
with sub-dependencies. However, through manual investigation, we
identified most of these dependencies as optional. In the majority
of cases, advertisement mediation frameworks can be configured
to use multiple ad libraries from different providers. There are two
utility libraries that are used by five other libraries, Gson and okio
with an updatability of 99.9% and 100%, respectively. Hence, it is
safe to assume that these sub-dependencies do not influence the
updatability of libraries that include them.
Finally, we investigated changes of the minimal, required An-
droid API level by libraries. Although this does not affect the cor-
rectness of our library updatability results, the app developer might
have to increase the app’s minimum API level in order to update a
library. This implies that the updated application may no longer be
compatible with devices having an older Android version which
consequently reduces the app’s potential user base. To investigate
the severity of such cases we aggregated a history of changes of
the minimal API for the eight libraries in Table 6 from publicly
available changelogs. Across versions, libraries have changed the
minSDK version between 1–2 times. The most current version of
five libraries requires a minimum API level between 11–16 (An-
droid 3.0–4.1). Dropbox does not state this requirement explicitly,
only indirectly via an Android sample (API level 19, Android 4.4).
According to the latest Google Play Access Statistics [15] less than
2% of all users have a device with API level < 16 (9% with API
level < 19). These results suggest that library developers are very
conservative in their choice of the minimal SDK to support a wide
range of devices and consequently the expected loss of potential
users is negligible for app developers.
6 RELATED WORK
There have been several studies on different software ecosystems
to assess the ripple effect of API changes. Dig et al. [16] found that
in 80% of cases API changes in libraries break the client application
upon update. Kim et al. [22] investigated the relationship between
library API changes and bugs. They found that the number of bugs
particularly increases after API refactoring. Bavota et al. [5] studied
the evolution of dependencies between Java projects of the Apache
ecosystem to find that client projects are more willing to upgrade a
library when the new version includes a high number of bugfixes.
At the same time, API changes discouraged the user from upgrading
since substantial code adaption effort might be required to include
the new release. While those findings are in line with our results,
i.e., mismatch of expected and actual changes and insights from
app developers about why libraries are not updated, this work goes
one step further. We identified root causes for this problem in the
Android ecosystem. Based on our results we thoroughly discussed
various options to remedy this situation that would have a high
app developer acceptance (based on our survey results).
McDonnell et al. [29] studied the Android API stability and adop-
tion and found that app developers do not quickly adopt new APIs
to avoid instability and integration effort. Another study on the
Android API [25] showed that including fast-changing and error-
prone APIs negatively affects the app ratings in the market. In
contrast to our work, these studies investigated the Android API,
however, we can confirm their findings for third-party libraries
as well. Particularly, for over-privileged libraries, app developers
often receive negative feedback and ratings, e.g. “some users have
complained about the permissions the app requires due to libraries”
or “Google Play services and especially maps required for sometime
the storage permission which led to lots of questions and negative
ratings”.
Various studies [21, 30, 37] emphasized that code reuse is wide-