title:Efficient Intrusion Detection using Automaton Inlining
author:Rajeev Gopalakrishna and
Eugene H. Spafford and
Jan Vitek
Efﬁcient Intrusion Detection using Automaton Inlining
Rajeev Gopalakrishna
Eugene H. Spafford
Jan Vitek
Center for Education and Research in Information Assurance and Security
Department of Computer Sciences
{rgk,spaf,jv}@cs.purdue.edu
Purdue University
Abstract
Host-based intrusion detection systems attempt to identify
attacks by discovering program behaviors that deviate from
expected patterns. While the idea of performing behavior
validation on-the-ﬂy and terminating errant tasks as soon
as a violation is detected is appealing, existing systems ex-
hibit serious shortcomings in terms of accuracy and/or efﬁ-
ciency. To gain acceptance, a number of technical advances
are needed. In this paper we focus on automated, conser-
vative, intrusion detection techniques, i.e. techniques which
do not require human intervention and do not suffer from
false positives.
We present a static analysis algorithm for constructing a
ﬂow- and context-sensitive model of a program that allows
for efﬁcient online validation. Context-sensitivity is essen-
tial to reduce the number of impossible control-ﬂow paths
accepted by the intrusion detection system because such
paths provide opportunities for attackers to evade detection.
An important consideration for on-the-ﬂy intrusion detec-
tion is to reduce the performance overhead caused by mon-
itoring. Compared to the existing approaches, our inlined
automaton model (IAM) presents a good tradeoff between
accuracy and performance. On a 32K line program, the
monitoring overhead is negligible. While the space require-
ments of a naive IAM implementation can be quite high,
compaction techniques can be employed to substantially re-
duce that footprint.
1. Introduction
The goal of a host-based intrusion detection system (IDS) is
to identify an attacker’s attempts to subvert processes run-
ning on the system. An anomaly-based IDS achieves this by
identifying program behaviors that deviate from the known
normal behavior. Intuitively, IDS algorithms monitor a pro-
gram by observing event traces and comparing those traces
to some expected behavior. Most approaches use sequences
of system calls as a characterization of program behavior.
The “normal” program traces can be modeled by observ-
ing the program execution on known inputs (dynamic anal-
ysis) [2, 5, 7, 10, 11, 12, 19], by a domain expert who cre-
ates a speciﬁcation of the program (manual analysis) [8], or
by automatically creating a speciﬁcation of the program us-
ing static program analysis [1, 3, 4, 16, 17]. All approaches
must deal with false positives, when the IDS deems that a le-
gal program event is invalid, as well as false negatives, when
an attack goes unnoticed. Clearly false negatives are unde-
sirable as they denote failures of the IDS, but false positives
are often more harmful as they hamper correct execution of
the program. Dynamic analysis and manual speciﬁcations
can be accurate as they leverage both domain knowledge
and the program’s input data, but they are well known to
suffer from false positives. Static program analysis tech-
niques can construct conservative program models that are
guaranteed not to exhibit false positives. The accuracy of
these approaches is illustrated in Figure 1.
The design space of automated techniques for program-
model construction must balance the following concerns:
accuracy, as measured by the number of false negatives;
scalability, the size of programs that can be handled by the
algorithm; and efﬁciency, the runtime overhead of moni-
toring. There are two aspects of static analysis that affect
accuracy in model generation: ﬂow-sensitivity and context-
sensitivity. A ﬂow-sensitive model considers the order of
execution of statements in the program. The basic model
described by Wagner and Dean [17] is an example of a ﬂow-
insensitive model where the normal expected behavior is
the regular language S∗
over the set of program events S
(e.g. system calls issued from the program text). If the pro-
gram ever issues a system call outside S, an exception is
raised. Such a ﬂow-insensitive approach, while sound and
efﬁcient, is highly imprecise in practice because attacks us-
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
PDA
IAM
NFA
Dynamic
models
Manual
models
Attacks
Valid Program Executions
Figure 1. Accuracy of host-based IDS models.
The ﬁgure shows program traces indicating at-
tack and valid executions. Both Dynamic and
Manual models ﬂag some valid traces as er-
roneous (false positives) and miss some in-
valid traces (false negatives). Automatically con-
structed models based on static program analysis
are conservative i.e. they do not suffer from false
positives, but have varying degrees of accuracy.
Pushdown Automata (PDA) are strictly more pow-
erful (i.e. they catch more attacks) than both IAM
and Non-deterministic Finite Automata (NFA), al-
though in the absence of recursion, the accuracy
of IAMs is the same as that of PDAs.
ing system calls included in S cannot be detected. In large
programs, it is quite likely that the set S encompasses all
‘dangerous’ system calls. For this reason, this paper con-
siders only ﬂow-sensitive models: models that are able to
differentiate between sequences of system calls and raise
an alert if system calls are issued out of order.
A context-sensitive model keeps track of the calling context
of functions and is able to match the return of a function
with the call site that invoked it.
In a context-insensitive
model, event sequences are allowed to start at a call site,
go through the called procedure, and return to a different
call site. This kind of impossible trace (i.e. sequence of
events that can not possibly occur in a normal program ex-
ecution) is a source of inaccuracy for context-insensitive
static models.
In [17], for instance, a program is repre-
sented by a non-deterministic ﬁnite automaton (NFA) that
is ﬂow-sensitive but does not capture the call-return seman-
tics of high-level programming languages. The advantage
of such NFA models is that they impose small monitor-
ing overheads. Context-sensitive models are more accurate
at the cost of higher program running times caused by the
overhead of maintaining context information.
Context-sensitive models have been investigated by several
researchers. In [17], the behavior of a program was captured
by a pushdown automaton (PDA), but the authors deemed
the runtime costs of the approach prohibitive and argued for
simpler models. More recent works [1, 4] have signiﬁcantly
decreased these overheads, yet some monitored programs
can still run more than twice as slowly as the original un-
monitored code.
While there are obvious reasons why performance over-
heads are undesirable, there is an additional motivation for
keeping this overhead low. Flow- and context-sensitive in-
trusion detection systems can be tricked into overlooking an
attack if the adversary is able to embed the attack in a valid
program trace (a so-called mimicry attack [13, 14, 18]).
To make such attacks more difﬁcult to carry out, intrusion
detection systems must either decrease the granularity of
events (i.e. observe more of the application’s behavior) or
be able to perform inferences on the values of arguments to
‘dangerous’ system calls (e.g. discover dynamically that ar-
guments to a call are not valid). These approaches have the
potential to improve the accuracy of IDSs but also increase
the amount of state needed for veriﬁcation and thus further
increase runtime costs.
In this paper, we present a new abstraction of program
behavior referred to as an Inlined Automaton Model (IAM)
which is as accurate, in the absence of recursion, as a PDA
model and as efﬁcient, in terms of runtime overhead, as
a NFA. We believe that this abstraction is well suited to
be the basis for more expressive intrusion detectors. The
contributions of this paper are as follows:
• Inlined Automaton Model: The IAM is a ﬂow- and
context-sensitive model which is as accurate as a PDA,
up to recursion. The paper describes the construction
of inlined automata and relates our results to previous
work on context-sensitive models.
• Implementation: An implementation of IAM is pre-
sented. It is based on library interposition. In our sys-
tem, the events of interest are the invocation of library
functions. While it is clearly possible for us to track
system calls, we ﬁnd that library functions give a more
accurate model as they are typically more frequent.
• Empirical evaluation: The IAM has been evaluated
on a benchmark suite that includes two of the same
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
programs used in [1] to enable direct comparison of re-
sults. We have shown runtime performance improve-
ments in both cases. In terms of scalability, our im-
plementation is able to scale to larger programs. We
demonstrate scalability by monitoring a 32K line pro-
gram. Previous experiments with a similar sized pro-
gram introduced unreasonable overheads and had to be
terminated [17].
• Automata compaction techniques: We present au-
tomata compaction techniques to reduce the space-
overhead of IAMs. These techniques are designed to
allow users to tune the footprint of the algorithm, with
some potential loss of performance.
The remainder of the paper is organized as follows.
Section 2 describes existing approaches to statically-
constructed model-based anomaly detection. Section 3 de-
scribes the construction of IAM and Section 5 discusses dif-
ferent automata compaction techniques. The implementa-
tion issues, a solution to reducing non-determinism in IAM,
and experimental results are described in Sections 4, 6,
and 7 respectively. Section 8 discusses the challenges faced
by existing approaches and Section 9 presents the conclu-
sion.
2. Static Analysis-based Automated Intrusion
Detection
Static analysis techniques can be used to construct conser-
vative models of program behavior in an automated fashion.
The seminal paper on automated program model construc-
tion for IDS is by Wagner and Dean [17]. They consider
four different models: trivial, digraph, callgraph, and ab-
stract stack. The trivial model represents the expected pro-
gram behavior using the regular language S∗
over the set
of system calls S made by a program.
It completely ig-
nores the ordering of calls. The digraph model precomputes
the possible consecutive pairs of system calls from the con-
trol ﬂow graph (CFG) of a program and at runtime checks
if the pair (previous system call, current call) is present in
the model. The callgraph model represents all possible se-
quences of system calls by modeling the expected program
behavior using a NFA derived from the CFG of the pro-
gram. The context-insensitivity arises because only a single
instance of a function’s CFG is represented in the NFA and
this leads to impossible paths (see Figure 2). Finally, the
abstract stack model eliminates such impossible paths by
modeling the call stack of a program using a PDA. How-
ever, [17] demonstrate that in practice the operational costs
of a PDA model are prohibitive in both space and time be-
cause of having to maintain and search all possible stack
conﬁgurations on transitions.
Gifﬁn et al. [3] evaluate several interesting optimizations to
increase precision of NFA models and efﬁciency of PDAs.
The ﬁrst optimization is to rename system calls (thus ex-
tending the set of events S) and allowing the model to dis-
tinguish among different invocations of the same function,
thus increasing accuracy. The second technique, argument
recovery, helps distinguish call sites by recovering static ar-
guments, i.e. arguments to functions that can be determined
at compile time, for example constant strings or scalar val-
ues. Again, this has the effect of enriching the set of observ-
able events and decreasing the number of impossible paths.
The last technique proposed in this work consists of a sim-
ple, meaning-preserving, program transformation which in-
serts null calls, i.e. calls to a dummy function, at selected
points in the program. These calls provide additional con-
text information to disambiguate event sequences. The pa-
per evaluates four null call placement strategies for preci-
sion and efﬁciency. Inserting null calls in functions with a
fan-in of ﬁve or greater provides a good balance between
precision and efﬁciency. Extending it to functions with fan-
in two or greater results in runtime overheads of up to 729%.
A PDA model with a bounded runtime stack is also inves-
tigated. However, gains in efﬁciency are observed only by
combining this model with null call insertion, which has its
own limitations.
The Dyck model [4, 1] improves on the above mentioned
null call technique by inserting code around non-recursive
call sites to user functions that issue system-calls. The ap-
proach basically increases the set of events S accepted by
the automaton with unique push/pop symbols; one such
guard pair is added for every function call site of interest.
This disambiguates call sites to the same target function
and thus achieves context-sensitivity. The runtime of the
program is affected by the overhead of the instrumentation.
The runtime costs can be reduced by dynamic squelching,
i.e. pruning from the model symbols guarding a function
that does not exhibit interesting behavior (e.g. does not
issue system calls). Nevertheless, slowdowns of 56% and
135% are reported for cat and htzipd. Recursive calls
are not instrumented for performance reasons.
The VPStatic model [1] is a statically-constructed variant
of the dynamic context-sensitive VtPath model [2]. It cap-
tures the context of a system call by a list (called the vir-
tual stack list) of call site addresses for functions that have
not yet returned. This information is obtained at runtime
by observing the stack of the monitored process. The vir-
tual stack lists of consecutive system call events are used
to determine if that transition is acceptable by the model.
While the Dyck model incurs runtime overhead in generat-
ing new context-determining symbols, the VPStatic model
introduces overhead because of the stack walks necessary
to observe existing context-determining symbols. However,
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
the overhead of stack walks is incurred only at system call
events unlike the overhead in the Dyck model which might
occur on execution paths without system call events. This
difference results in reduced slowdown of 32% and 97% for
cat and htzipd in the case of the VPStatic model. The
stack walks make up much of the slowdown.
3. The Inlined Automaton Model
The Inlined Automaton Model (IAM) is a ﬂow- and
context-sensitive statically-constructed model of program
behavior that is simple, scalable, and efﬁcient. The model
is generated by ﬁrst constructing NFAs for each user func-
tion in the program. These automata are constructed by a
simple ﬂow-sensitive intra-procedural analysis of the pro-
gram text. Then, in a second phase, nodes representing call
sites are inlined with the models corresponding to the called
functions. This process is repeated until all calls have been
completely expanded. Recursive calls are treated specially
as will be discussed below.
Figure 2 shows an example program and its NFA represen-
tation. The NFA abstraction is a union of statement-level
CFGs for each function in the program. Each function has
unique entry and exit nodes and call sites are split into
call and return nodes. Call nodes are connected to the
entry nodes of the invoked functions and the exit nodes of
the invoked functions are connected to the return nodes cor-
responding to these calls. The context-insensitivity in the
NFA model arises because only a single copy of a function’s
CFG is maintained in the representation. This results in im-
possible paths being considered by the model. For example,
in Figure 2, the system call sequence (start, write,
write, close, end) is an impossible path. start
and end are special symbols used to denote the start and
end of program execution.
Deﬁnition 1 Formally, an -NFA N for a program P is rep-
resented as N = (Q, Σ, δ, q0, F ) [6] where:
Q is a ﬁnite set of states
Σ is a ﬁnite set of input symbols
q0, a member of Q, is the start state
F , a subset of Q, is a set of ﬁnal states
δ is the transition function that takes a state Q and an input
symbol in Σ ∪ {} as arguments and returns a subset of Q.
We associate a type T with every state in the NFA represen-
tation of a program. So, for each q ∈ Q,∃ T s.t. T (q) ∈
{E, X, C, R}, which represent entry, exit, call, and return
nodes respectively. We deﬁne successor of a state q as a set
of tuples (s, l), where s ∈ Q and ∃ l ∈ Σ∪{} s.t. δ(q, l) =
s. Fan-out of state q is deﬁned as the cardinality of the
set successor(q). Similarly, we deﬁne the predecessor of
a state q as a set of tuples (s, l), where s ∈ Q and ∃ l ∈
Σ ∪ {} s.t. δ(s, l) = q. Fan-in of state q is deﬁned as the
cardinality of the set predecessor(q).
The IAM representation of the program in Figure 3(a) is ob-
tained from the NFA model by inlining all the function calls
in the program. The resulting model is context-sensitive be-
cause the call-return semantics of function calls is modeled
by including a copy of a function’s CFG at every call to that
function. This model does not have, up to recursion, the
impossible paths resulting from context-insensitivity.
Formally, an -NFA N for a program P given by N =
(Q, Σ, δ, q0, F ) is transformed into an -IAM M given by
M = (Q(cid:2), Σ, δ(cid:2), q0, F (cid:2)) where an additional property holds.
Deﬁnition 2 An -IAM M is an -NFA where for each q ∈
Q(cid:2)
, if T (q) = E then fan-in(q) = 1 or else if T (q) = X
then fan-out(q) = 1, provided E and X are entry and exit
nodes of a non-recursive and non-main function.
The ﬁnal IAM representation shown in Figure 3(b) includes
only system call nodes and transitions, and discards the
other nodes. This -free IAM is obtained by performing
-reduction on -IAM. The deﬁnitions of successor and pre-
decessor are the same for an -free IAM except that  is not
an input symbol.
A drawback of inlining is that it may result in state explo-
sion. This indeed is the reason [3] decided not to pursue this
approach. The state space can be somewhat limited by re-
stricting the model to states that characterize the observable
behavior of the program, e.g. system calls, or in our cur-
rent implementation, calls to library functions. Section 5
discusses space compaction techniques.
Recursion is one obvious limitation of inlining. To ensure
termination, it is necessary to treat recursion specially. We
perform inlining depth-ﬁrst. On detecting recursion, we ter-
minate inlining. We connect the call node of the repeating
function to the entry node of its previously inlined instance
and the exit node of that instance to the current return node.
These transitions model the winding phase of recursion. We
also connect the call and return nodes of the repeating func-
tion to model the unwinding phase of recursion. Examples
of recursion bounding for both direct and indirect recursion
appear in Figures 4 and 5. Recursion introduces impossi-
ble paths, for example in Figure 4, the sequence (start,
open, write, end) is an impossible path, as it lacks
a call to close in the unwinding phase, but the path is al-
lowed by the model.
We can relate our approach to the formalization of [1].
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
main( int argc, char** argv) {
int fd;
if ( argc == 1 ) {
write(1, "StdOut", 6);
foo(1);
} else {
fd = open(argv[1], O_WRONLY);
foo(fd); close(fd);
} }
void foo(int x) {
write(x,"Hello World",11);
}
foo
E
X
write
main
E