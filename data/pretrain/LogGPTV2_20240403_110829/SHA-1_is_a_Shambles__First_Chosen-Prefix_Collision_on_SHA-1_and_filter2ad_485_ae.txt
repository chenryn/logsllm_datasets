the attack is to build two public keys of diﬀerent sizes, so
that the remaining ﬁelds to be signed are misaligned, and
we can hide the UserID of key A in another ﬁeld of key B.
Following RFC 4880, the signature packet is protected
by a length value at the beginning and at the end, so that
we have to use the same signature packet in key A and
key B (we cannot stuﬀ data in the hashed subpacket).
Therefore, we can only play with the UserID and/or user
attribute packets. Still, a user attribute packet with a
JPEG image gives us enough freedom to build colliding
certiﬁcates, because typical JPEG readers ignore any
bytes after the End of Image marker (ff d9). This gives
us some freedom to stuﬀ arbitrary data in the certiﬁcate.
More precisely, we build keys A and B as follows. Key
A contains an 8192-bit RSA public key, and a UserID
ﬁeld corresponding to Alice. On the other hand, key B
contains a 6144-bit RSA public key, the UserID of Bob
and a JPEG image. Therefore, when Bob gets a cer-
tiﬁcation signature of his key, the signer will sign two
certiﬁcates: one containing his public key and UserID,
and another one containing the public key and the image.
The public keys A and B and the image are crafted in
such a way to generate a collision between the certiﬁcates
with the key A and Alice’s UserID, and the certiﬁcate
with key B and the image.
6.1.1 Content of Identity Certiﬁcates
Figure 8 shows a template of the values included in
the identity certiﬁcate: those values are hashed when
signing a key, and we want the two hashes to collide. In
this example, the UserID ﬁeld of key A contains “Alice
”, and the image in key B is a
valid JPEG image that will be padded with junk data
after the End of Image marker. The real JPEG ﬁle is 181
bytes long5 (from ff d8 to ff d9), and it is padded with
81 bytes, so that the ﬁle included in the key is 262 bytes
long (here the padding includes 46 bytes corresponding
to the end of the modulus of key A, 5 bytes corresponding
to the exponent of key A, and 30 bytes corresponding
to Alice’s UserID).
In Figure 8, we use the following symbols:
01 Bytes with a ﬁxed value are ﬁxed by the speciﬁcations,
or chosen in advance by the attacker (length of ﬁelds,
UserID, user attribute, ...)
?? Represent bytes that are determined by the chosen-
preﬁx collision algorithm (the messages M and M0
to generate a collision)
!! Represent bytes that are selected after ﬁnding the
collision, to generate an RSA modulus with known
prime factors
.. Represent bytes that are copied from the other cer-
** Represent time-stamps chosen by the attacker
$$ Represent the time-stamp chosen by the signer
Underlined values correspond to packet headers (type
and length).
tiﬁcate
6.1.2 Attack Procedure
To carry out the attack, we have to perform the following
steps:
1. Build a chosen-preﬁx collision with preﬁxes “99
04 0d 04 ** ** ** ** 01 20 00” and “99 03
0d 04 ** ** ** ** 01 18 00”, after ﬁlling the **
with two arbitrary time-stamps. The chosen-preﬁx
collision must have at most 10 near-collision blocks.
This determines the ?? bytes of the keys.
2. Choose a tiny JPEG image to include in key B (ﬁxed
orange bytes), and an arbitrary UserID to include
in key A (ﬁxed yellow bytes)
known factors
3. Select “!!” bytes in B to obtain a modulus with
4. Select “!!” bytes in A to obtain a modulus with
5. Generate key B with the modulus and the padded
known factors
JPEG. Ask for a signature of the key.
5Building a JPEG image smaller than 256 bytes is not easy,
but it is possible
1850    29th USENIX Security Symposium
USENIX Association
Main resource
Step
Preparation of the graph CPU and RAM
Phase
Setup
Birthday Computing chains
GPU
Hard drive
Sorting chains
GPU
Locating collisions
RAM
Searching in graph
Human Time
Building trail & code
GPU
Finding block
Checking results in graph RAM
Finding last block
GPU
Blocks
Repetitions Wall time
≈ 1 month
34 days
≈ 1 day
< 1/2 day
< 1/2 day
≈ 1 day
3 hours – 3 days
< 1/2 hour
6 days
4 ×
4 ×
4 ×
9 ×
8 ×
8 ×
1 ×
Table 8: Resources used for the attack
6. Copy the signature to key A.
We point out that the chosen-preﬁx collision is com-
puted before choosing the UserIDs and images that will
be used in the attack. Therefore, a single CPC can be
reused to attack many diﬀerent victims. This contrasts
with attacks on X.509 certiﬁcates [25, 27], where the
identiﬁer is hashed before the public key.
In order to build the modulus (steps 3 and 4 above), we
use the same strategy as in previous works [25,27]. More
precisely, the high order bits are ﬁxed by previous steps,
and the low-order bits can be chosen freely. Therefore
we have to ﬁnd a modulus in an interval [A, B] with a
known factorisation. We select a random prime P (in
the order of B − A), and we compute Q = bB/Pc. If
Q is a prime, we use P ∗ Q as the modulus: we have
A ≤ P ∗ Q ≤ B when P ≤ B − A + 1. This takes a few
minutes in practice.
We note that the factors of the modulus are unbal-
anced. With the template of Figure 8, we expect factors
of 88 bits and 6056 bits for Key B, and 368 bits and
7824 bits for key A. In practice we managed to ﬁnd a CP
collision with fewer blocks than in Figure 8, so that key
B actually has factors of 1112 bits and 5032 bits. This
makes both keys hard to factor. As mentioned in [14], it
is possible to ﬁnd modulus with somewhat larger factors
using more advanced techniques.
6.1.3 Example Keys
An example of a pair of keys generated with this proce-
dure can be directly downloaded from these URLs:
Key A: https://SHA-mbles.github.io/alice.asc
Key B: https://SHA-mbles.github.io/bob.asc
that they include the same signature.
The keys can be examined with pgpdump -i to see
In our demonstration, we chose a time-stamp far in the
future to avoid malicious usage of our collision. However,
an attacker that can repeat our work will obviously use
a valid time-stamp.
6.1.4 Attack Variant
We also found an alternative attack, exploiting the PGP
key format in a slightly diﬀerent way, where key B con-
tains a short public key followed by a JPEG image. We
would consider both the public key and the image as the
preﬁx, and stuﬀ the CPC blocks inside the image (after
the EOI marker). This variant leaves a smaller space
for the CPC blocks, but the advantage is that key A
is less suspicious because it doesn’t need to contain a
valid JPEG ﬁle inside the modulus (the modulus is really
made of random-looking blocks). On the other hand, this
variant requires to compute a new CPC for each key B.
6.2 Impact
As explained in Section 7.1, the “classic” branch of
GnuPG (v1.4) uses SHA-1 by default for identity cer-
tiﬁcations, and there is still a non-negligible number of
keys signed with SHA-1. Before our attack was disclosed,
SHA-1 signatures were also accepted by the “modern”
branch of GnuPG (v2.2). This made the attack usable
in practice.
In addition, a single CPC can be reused to attack
many diﬀerent victims, so that the cost of the CPC is
just a one-oﬀ cost. Given our cost estimation around
US$ 50k, this is well within reach of strong adversaries.
7 SHA-1 Usage and Disclosure
SHA-1 is still used in a surprising number of security
applications. It is supported in many secure channel
protocols (TLS, SSH), and remains actually used for
some fraction of the connections. It is also used for PGP
identity certiﬁcations, and it is the foundation of GIT
versioning system. We expect there are also an important
USENIX Association
29th USENIX Security Symposium    1851
Key A (RSA-8192)
Key B (RSA-6144)
0x0000 99 04 0d 04 ** ** ** ** 01 20 00 ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
0x0040 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
99 03 0d 04 ** ** ** ** 01 18 00 ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
...
...
0x02c0 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
Collision here!
0x0300 .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← !! !! !! !! !! !! !! !! !! !! !! 00 11 01 00 01
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← d1 00 00 01 19 c0 57 01 10 00 01 01 00 00 00 00
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← 00 00 00 00 00 00 00 00 ff d8 ff db 00 43 00 ff
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
0x0340 .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← c0 00 0b 08 00 40 00 58 01 01 11 00 ff c4 00 28
0x0380 .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← 00 01 01 01 00 00 00 00 00 00 00 00 00 00 00 00
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← 00 00 04 03 10 01 00 00 00 00 00 00 00 00 00 00
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← 00 00 00 00 00 00 ff da 00 08 01 01 00 00 3f 00
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← d0 4e a0 01 3a 80 04 ea 01 3a 80 04 e0 00 a0 13
0x03c0 .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ← 8a 13 82 84 e2 84 e0 00 00 28 4e 00 0a 13 8a 13
.. .. .. .. .. .. .. .. .. .. .. .. .. !! !! !! ↔ a8 00 4e a1 3a 80 4e 28 4e 28 07 ff d9 .. .. ..
!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! → .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! → .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
0x0400 !! !! !! !! !! !! !! !! !! !! !! 00 11 01 00 01 → .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
b4 00 00 00 19 41 6c 69 63 65 20 3c 61 6c 69 63 → .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
65 40 65 78 61 6d 70 6c 65 2e 63 6f 6d 3e 04 10 → .. .. .. .. .. .. .. .. .. .. .. .. .. .. 04 10
01 02 00 06 05 02 .. .. .. .. 04 ff 00 00 00 0c ← 01 02 00 06 05 02 $$ $$ $$ $$ 04 ff 00 00 00 0c
Figure 8: Construction of colliding OpenPGP identity certiﬁcates. The colour corresponds to the packets hashed
when computing the signature: ﬁrst, the public key packet (with header), then the UserID or user attribute , and
ﬁnally the signature packet and trailer . Arrows show when a value is chosen in one key and copied to the other.
number of proprietary systems using SHA-1, but getting
actual data on this is diﬃcult.
Collisions and chosen-preﬁx collisions do not threaten
all those usages (in particular HMAC-SHA-1 seems rela-
tively safe), but there are several settings that are directly
aﬀected by chosen-preﬁx collisions:
• PGP identities can be impersonated if trusted third
parties sign identity certiﬁcates with SHA-1 (see 7.1)
• X.509 certiﬁcates could be broken if some CAs issue
SHA-1 certiﬁcates with predictable serial numbers
(see 7.2)
• TLS and SSH connections using SHA-1 signatures
to authenticate the handshake could be attacked
with the SLOTH attack [1] if the CP collision can
be generated extremely quickly (see 7.3 and 7.4)
We stress that when a protocol supports several hash
functions, those attacks are possible as long as SHA-1 is
supported by implementations, even if it is not selected
during normal use. A man-in-the-middle attacker will
just force the parties to use SHA-1.
1852    29th USENIX Security Symposium
USENIX Association
More generally, as cryptographers, we recommend to
deprecate SHA-1 everywhere, even when there is no direct
evidence that this weaknesses can be exploited. SHA-1
has been broken regarding collision resistance for 15
years, and there are better alternatives available, well-
studied, and standardized (SHA-2 [17], SHA-3 [18]). There
is no good reason to use SHA-1 in modern security soft-
ware. Attacks only get better over time, and the goal of
the cryptanalysis eﬀort is to warn users so that they can
deprecate algorithms before the attacks get practical.
As a stopgap measure, the collision-detection library
of Stevens and Shumow [26] can be used to detect attack
attempts (it successfully detects our attack).
Responsible disclosure. We have tried to contact
the authors of aﬀected software before announcing this
attack, but due to limited resources, we could not notify
everyone. We detail below the main aﬀected products,
some of the responses we received, and countermeasures
deployed at the time of writing. More up to date infor-
mation will be available on the website of the attack:
https://sha-mbles.github.io.
7.1 SHA-1 Usage in GnuPG
There are currently two supported branches of GnuPG:
GnuPGv1 is the “legacy” (or “classic”) branch, and
GnuPGv2 is the “modern” branch. The ﬁrst version of
GnuPGv2 dates back to 2006, and the “legacy” branch
is no longer recommended, but the transition took a
long time. In particular, GnuPGv1 was still the default
version in Fedora 29 (released in October 2018), and in
Ubuntu 16.04 LTS (which is supported until April 2021).
GnuPG supports many diﬀerent algorithms, including
SHA-1. Moreover, SHA-1 is the default algorithm for iden-
tity certiﬁcation in GnuPGv1. This is why we targeted
PGP in our demonstration of chosen-preﬁx collisions. Af-
ter we disclosed our results to the GnuPG team, SHA-1
signatures have been deprecated in the GnuPGv2 branch
(commit edc36f5, CVE-2019-14855).
Web of Trust. The original trust model of PGP was
the Web of Trust. Instead of using a central PKI, users
sign each other’s keys to attest of their identity (e.g.
when attending a key signing party), and trust such
certiﬁcates from third parties. A scan of the PGP Web
of Trust (i.e. identity certiﬁcations on public keyservers)
shows that roughly 1% of the identity certiﬁcations issued
in 2019 use SHA-1. This probably corresponds to usage
of GnuPGv1 with the default settings, and would make
our attack feasible.
CAcert. CAcert (http://cacert.org/) is one of the
main CAs for PGP keys, and they still use SHA-1 to
sign user keys. We have ﬁrst contacted them by email
on December 14th, and got an answer on January 6th
acknowledging this issue. They are now planning a switch
to a secure hash function for key certiﬁcation.
7.2 SHA-1 Usage in X.509 Certiﬁcates
The CA/Browser Forum decided to sunset SHA-1 in
October 2014, and its members are not supposed to issue
SHA-1 certiﬁcates after 2016. Web browsers have enforced
similar rules, and all modern browsers now reject SHA-1