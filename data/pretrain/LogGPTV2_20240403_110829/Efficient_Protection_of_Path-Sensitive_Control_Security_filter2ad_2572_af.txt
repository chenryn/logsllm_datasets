program states, called runs, that are generated by executing a
sequence of instructions in P from an initial state. In particular,
each program P defines two languages of runs. The first is
the language of well-defined runs, in which each step from the
current state is defined by the semantics of the next instruction
in P. The second is the language of feasible runs contain some
state q from which P executes an instruction that is not defined at
q (e.g., dereferencing an invalid address). When the successive
state of q is not defined and the program takes a step of execution,
the program may potentially perform an operation that subverts
security.
USENIX Association
26th USENIX Security Symposium    145
A state is a stack of assignments from registers to values and a
memory, which maps each memory cell to a value. Let Words be
a space of data words and let Cells be a space of memory cells. A
value is an instruction address (§A.1), a data word, or a memory
cell; i.e., Values = IAddrs∪ Words∪ Cells. Let the space of
registers be denoted Regs. A register frame is the address of the
current instruction and a map from each register to a value; i.e.,
the space of register frames, for RegMaps = Regs → Values, is
denoted
Frames = IAddrs× RegMaps
For each register frame f ∈ Frames, the instruction address of
f is denoted as ip[ f ].
A cell memory is a map from each memory cell to a value;
i.e., the space of cell memories is Mems = Cells → Values. A
state is a pair of a non-empty stack of register frames and a cell
memory; i.e., the space of states is denoted
States = Frames+ × Mems
For each state q, the instruction address of the top frame of q
is denoted ip[q]. For each sequence of states r ∈ States∗, the
sequence of corresponding instruction pointers of each state in
r is denoted IPs(r) ∈ IAddrs∗. The states consisting of a single
stack frame whose instruction pointer is ι are the initial states,
denoted States0 ⊆ States.
A transition relation relates each pre-state and instruction to
their resulting post-states. I.e., the space of transition relations
is TransRels = (States× Instrs)× States. The semantics of
Lang is defined by the well-defined transition relation of Lang,
denoted ρ[WellDef] ∈ TransRels. Each step of execution that
is safe is a step in ρ[WellDef]. The definition of ρ[WellDef] is
standard, and we omit a complete definition.
For each transition relation ρ ∈ TransRels, the runs of ρ in
P are the sequences of states r in which each state in r steps to
the successive state in r under ρ in P; the language of all such
runs is denoted Runs[ρ,P]. The runs of P under ρ[WellDef] are
the well-defined runs of P, denoted
Runs[WellDef,P] = Runs[ρ[WellDef],P]
The feasible transition relation of Lang is ρ[WellDef] ex-
tended to relate each pre-state and instruction undefined in
ρ[WellDef] to each post-state. The feasible transition relation
thus includes safe steps of execution that a program may take,
along with unsafe steps taken when the program executes an
instruction from a state in which the instruction is not defined
(i.e., loading from an address that does not point to allocated
memory). The feasible transition relation of Lang is denoted
ρ[Feasible] = ρ[WellDef]∪
((States× Instrs)\ Dom(ρ[WellDef]))× States
where Dom(ρ[WellDef]) denotes the domain of ρ[WellDef].
The runs of P under ρ[Feasible] are the feasible runs of P,
denoted Runs[Feasible,P] = Runs[ρ[Feasible],P].
B Formal definition of points-to analysis
A control analysis takes a program P and computes a sound over-
approximation of the instruction pointers that may be stored in
each register when P executes a given instruction over a well-
defined run. A control-analysis domain is an abstract domain [8]
consisting of a set of abstract states, a concretization relation
from abstract states to the program states that they represent,
and an abstract transformer that describes how each abstract
state is updated by a program.
(1) An abstract domain A.
Definition 3 A control-analysis domain is a triple (A,γ,τ),
(2)A concretization rela-
with:
tion γ ⊆ A × States. There must be initial and empty ele-
ments Init, Empty ∈ A such that (a) {Init}× States0 ⊆ γ and
(b) {Empty} × States ∩ γ = /0.
(3) An abstract transformer
τ : A× Instrs× IAddrs → A, where for each abstract state a ∈ A,
each state q ∈ States such that (a,q) ∈ γ, and each instruction
i ∈ Instrs and state q′ ∈ States such that (q, i,q′)∈ ρ[WellDef],
it holds that (τ(a, i, ip[q′]),q′) ∈ γ.
For each control domain D, we refer to the abstract states, con-
cretization relation, and abstract transformer of D as A[D], γ[D],
and τ[D], respectively. The space of control-analysis domains is
denoted Doms.
The initial and empty elements in A[D] are denoted Init[D]
and None[D]. The binary relation ⊑D⊆ A[D]× A[D] is defined
as follows. For all abstract states a0,a1 ∈ A[D], if for each
concrete state q ∈ States such that (a0,q) ∈ γ[D] it holds that
(a1,q) ∈ γ[D], then a0 ⊑D a1.
C Formal definitions of control security
C.1 Conventional CFI
For each control domain D and program P, a valid description
of P in D over-approximates the control targets stored bound to
registers and memory when control reaches each of instruction
address of P. In particular, a valid description δ maps each
instruction address to an abstract state of D that such that (1)
δ maps ι to Init[D] and (2) δ is consistent with the abstract
transformers of each instruction over D.
Definition 4 For each control domain D ∈ Doms and program
P ∈ Lang, let δ : IAddrs → A[D] be such that (1) δ (ι) = Init[D];
(2) for all instruction addresses a0,a1 ∈ IAddrs and instruction
i ∈ Instrs, it holds that τ[D](δ (a0), i,a1) ⊑D δ (a1). Then δ is
a valid description of P in D.
For each control domain D ∈ Doms and program P ∈
Lang, the space of valid descriptions of P in D is denoted
ValidDescs[D,P].
For each control domain D ∈ Doms and program P ∈ Lang
the most precise description of P in D, denoted µ[D,P] ∈
ValidDescs[D,P], is the valid description of P in D such that
for all valid descriptions δ′ ∈ ValidDescs[D,P] and each in-
struction address a ∈ IAddrs, µ[D,P](a) ⊑D δ′(a). Under well-
understood conditions [8], D has a most-precise description for
each program P that can be computed efficiently [2, 34].
Example 1 For program dispatch (§2.1) and any control do-
main D that maps each instruction pointer to a set of instruction
addresses, the most precise description of dispatch restricted
to function pointers is given in §2.2.
146    26th USENIX Security Symposium
USENIX Association
Each program P and domain D define a transition relation in
which at each step from each instruction address a, the program
only transfers control to an instruction address that is feasible in
the most precise description of P under D at a.
Definition 5 For each program P ∈ Lang and control do-
main D ∈ Doms, let ρ ∈ TransRels be such that for all in-
struction addresses a,a′ ∈ Addrs, each instruction i ∈ Instrs
with τ[D](µ[D,P](a), i,a′) ̸= None[D] and all states q,q′ ∈
States with (µ[D,P](a),q) and (µ[D,P](a′),q′), it holds that
((q, i),q′) ∈ ρ. Then ρ is the flow-sensitive transition relation
of D and P.
For each domain D and program P, the flow-sensitive transition
relation of D and P is denoted FS[D,P].
For each control domain D and program P, the most precise
flow-sensitive description of P in D (Appendix D) defines an
instance of generalized control security that is equivalent to
CFI [1].
Definition 6 For all programs P,P′ ∈ Lang and each control-
analysis domain D ∈ Doms, if P′ satisfies generalized control
security under FS[D,P] (Appendix D, Defn. 5) with respect to
P, then P′ satisfies CFI modulo D with respect to P.
Defn. 6 is equivalent to “ideal” CFI as defined in previous work
to establish fundamental limitations on CFI [5].
C.2 Path-sensitive CFI
The problem of enforcing CFI is typically expressed as instru-
menting a given program P to form a new program P′ that
allows each indirect control transfer in each of its executions
only if the target of the transfer is valid according to a flow-
sensitive description of the control-flow graph of P. To present
our definition of path-sensitive CFI, we will introduce a general
definition of control security parameterized on a given transition
relation ρ. P′ satisfies generalized control security under ρ with
respect to P if (1) P′ preserves each well-defined run of P and
(2) each feasible run of P′ has instruction addresses identical to
the instruction addresses of some run of P under ρ.
Definition 7 For each transition relation ρ ∈ TransRels, let
programs P,P′ ∈ Lang be such that (1) Runs[WellDef,P] ⊆
Runs[WellDef,P′]; (2) for each run r′ ∈ Runs[Feasible,P′],
there is some run r ∈ Runs[ρ,P] such that IPs(r) = IPs(r′).
Then P′ satisfies generalized control security under ρ with re-
spect to P.
We now define path-sensitive CFI, an instance of generalized
control security that is strictly stronger than CFI. Each control
domain D defines a transition relation over program states that
are described by abstract states of D connected by the abstract
transformer of D.
Definition 8 For each control domain D ∈ Doms (§3.2,
Defn. 3), let ρ[D] ∈ TransRels, be such that for each abstract
state a ∈ A[D], each state q ∈ States such that (a,q) ∈ γ[D],
and each instruction i ∈ Instrs and state q′ ∈ States such that
(τ[D](a, i, ip[q′]),q′) ∈ γ[D], it holds that (q, i,q′) ∈ ρ[D]. Then
ρ[D] is the transition relation modulo D.
For all programs P and P′ and each control domain D, P′
satisfies path-sensitive CFI modulo D with respect to P if each
step of each run of P′ corresponds to a step of P over states with
the same description under D.
Definition 9 For all programs P,P′ ∈ Lang and each control
domain D ∈ Doms, if P′ satisfies control security under ρ[D]
(Defn. 8) with respect to P, then P′ satisfies path-sensitive CFI
modulo D with respect to P.
Path-sensitive CFI is conceptually similar to, but stronger
than, context-sensitive CFI [37], which places a condition on
only bounded suffixes of a program’s control path before the
program attempts to execute a critical security event, such as a
system call.
Path-sensitive CFI is as strong as CFI.
Lemma 1 For each control domain D and all programs P,P′ ∈
Lang such that P′ satisfies path-sensitive CFI modulo D with
respect to P, P′ satisfies CFI modulo D with respect to P.
Lemma 1 follows immediately from the fact that any control-
transfer target that is along a given control path must be a valid
target in a meet-over-all-paths solution.
Path-sensitive CFI is in fact strictly stronger than CFI.
Lemma 2 For some control domain D and programs P,P′ ∈
Lang, P′ satisfies CFI with respect to P modulo D but P′ does
not satisfy path-sensitive CFI with modulo D respect to P.
Lemma 2 is immediately proven using any domain D that is
sufficiently accurate between two control states and a program
P that generates state with either control configuration at a
particular program point.
D Formal definition of online analysis
The behavior of the analyzer module is determined by a
fixed control-analysis domain D (§3.2, Defn. 3). We refer to
PITTYPAT instantiated to use control domain D for points-to
analysis as PITTYPAT[D].
As the analyzer module executes, it maintains a control-
domain abstract state d ∈ A[D]. In each step of execution, the
analyzer module receives from the monitor process the next
control-transfer target taken by the monitored program P, and
either chooses to raise an alarm that transferring control to the
target would cause P to break path-sensitive CFI modulo D, or
updates its state and allows P to take its next step of execution.
In each step of execution, the analyzer module receives the
next control target a ∈ IAddrs taken by the monitored program,
and either raises an alarm or updates its maintained control
description d as a result. If a is not a feasible target from d over
the next sequence of non-branch instructions, then the analyzer
module throws an alarm signaling that control flow has been
subverted, and aborts.
Theorem 1 For D ∈ Doms and P ∈ Lang, the program P′ sim-
ulated by running P in PITTYPAT[D] satisfies path-sensitive
CFI modulo D with respect to P (Defn. 9).
USENIX Association
26th USENIX Security Symposium    147
We have given the design of an analyzer module that uses an
arbitrary control domain generically; i.e., the analyzer can use
any control-analysis domain that satisfies the definition given in
§3.2, Defn. 3. However, we have found that the performance of
the analyzer module can be improved significantly by using a
control domain that takes advantage of the particular context of
online path-sensitive analysis by maintaining points-to informa-
tion about exactly the variables that are live in each live stack
frame in the program state. We now define in detail the control
domain used by our analysis, OnlinePtsTo = (A,γ,τ).
Each element in the space A is either None[A], which repre-
sents no states, or a tuple consisting of (1) a stack in which each
entry is a map from each register r to a set of memory cells and
instruction pointer that r may store and (2) a map from each cell
to the cells and instruction pointers that it may store. I.e., for
Addrs = IAddrs∪ Cells
RegPtsMaps = Regs → P(Addrs)
FramePtsTo = IAddrs× RegPtsMaps
CellPtsTo = Cells → P(Addrs)
with P(Addrs) the powerset of addresses, the abstract states are
A = FramePtsTo+ × CellPtsTo. The stack containing a single
frame that maps each register to the empty set of addresses,
paired with an empty memory map, is the initial element of A.
Example 2 §2.3 contains examples of elements of A. In order
to simplify the presentation, in §2.3, only bindings to the function
pointer handler are shown, because these bindings are the only
ones that need to be inspected to determine the security of a
given run of dispatch.
Concretization relation γ ⊆ A × States relates each stack
and memory of points-to information to each concrete state
with a similarly structured stack and heap. For each n ∈ N, let
a0, . . . , an ∈ IAddrs, R0, . . . ,Rn ∈ RegMaps, and R′
n ∈
RegPtsMaps be such that for each i ≤ n and each register r ∈
Regs, if Ri(r) ∈ Addrs, then Ri(r) ∈ R′
i(r). Let m ∈ Mems and
m′ ∈ CellPtsTo be such that for each cell c ∈ Cells, m(c) ∈
m′(c). Then:
0, . . . ,R′
0), . . . , (in,R′
(([(i0,R′
([(i0,R0), . . . , (in,Rn)],m)) ∈ γ
n)],m′),
The abstract transformer τ : A× Instrs× IAddrs → A is de-
fined as follows. For each set of memory cells C ⊆ Cells, let
fresh(C) ∈ Cells\C be a fresh memory cell not in C. For all
register frames f0, . . . , fn ∈ FramePtsTo, each register map m ∈
RegPtsTo, each cell points-to map c ∈ CellPtsTo, all registers
r0, r1, r2 ∈ Regs, and all instruction addresses a,a′ ∈ IAddrs, a
store instruction store r0, r1 updates the cell map so that each
cell bound to r1 points to each cell points to each cell bound to
r0. I.e., for c0, . . . ,cn ∈ R(r1),
τ(((a,R) :: F,m), store r0, r1,a′) =
((a′,R) :: F,m[c0 (cid:55)→ R(r0), . . . ,cn (cid:55)→ R(r0)])
A branch instruction requires that the target instruction address
is in the points-to set of the target register of the branch. I.e., if
a′ ∈ R(r0), then
τ(((a,R) :: F,m), br r0,a′) = ((a′,R) :: F,m)
Otherwise, τ maps the abstract state to None[A]. A call instruc-
tion increments the instruction pointer in the top frame and
pushes onto the stack a frame with an empty register map. I.e.,
if a′ ∈ R(r),
τ(((a,R) :: F,m), call r0,a′) =
((a′, /0) :: (a + 1,R) :: F,m)
Otherwise, τ maps the abstract state to None[A]. A return
instruction pops the top register frame from the stack.
I.e.,
τ(((a,R) :: F,m), return,a′) = (F,m) A data operation updates
only the instruction address:
τ(((a,R) :: F,m), op r0,r1,r2,a′) = ((a′,R) :: F,m)
An allocation alloc r0 updates the register map in the top frame
of the stack so that r0 points to a fresh memory cell. I.e.,
τ(((a,R) :: F,m), alloc r0,a′) =
((a′,R[r0 (cid:55)→ fresh(Rng(m))]) :: F,m)
where (a,R) :: F denotes (a,R) prepended to F and Rng(m)
denotes the range of m. A copy instruction copy r0, r1 updates
the register map so that each cell that may be stored in r0 may
be stored in r1. I.e.,
τ(((a,R) :: F,m), copy r0, r1,a′) =
((a′,R[r1 (cid:55)→ R(r0)]) :: F,m)
A load instruction load r0, r1 updates the register map in the
top frame so that each cell that may be pointed to by a cell bound
to r0 is bound to r1:
((a′,R[r1 (cid:55)→ (cid:91)
τ(((a,R) :: F,m), ld r0, r1,a′) =
m(c)]) :: F,m)
c∈R(r0)
The abstract transformers for other instructions, such as data
operations that perform pointer arithmetic, are defined similarly,
and we do not give explicit definitions here in order to simplify
the presentation.
Example 3 Consider descriptions of states of dispatch and its
instruction call handler (§2.1). For abstract state
A0 = ([(L22, [handler (cid:55)→ {priv}])], /0)
τ(A0, call handler, priv) consists of a fresh stack frame for
priv pushed onto the stack [(L22, handler (cid:55)→ priv)]. For ab-
stract state
A1 = ([(L22, [handler (cid:55)→ {unpriv}]), /0)
τ(A1, call handler, priv) is None[A].
We have given an online points-to analysis for a simple lan-
guage with only calls and returns. Practical languages typically
support additional interprocedural control instructions that, e.g.,
resolve calls targets through dynamic dispatch or unwind the
callstack. Our complete implementation handles each such in-
struction using an appropriate abstract transformer.
The fact that (D,γ,τ) defines a sound analysis can be proven
using standard techniques from abstract interpretation [8].
148    26th USENIX Security Symposium
USENIX Association