Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:05 UTC from IEEE Xplore.  Restrictions apply. 
  can seem attractive for a wired embedded network hav-ing only tens of receivers. Sending one MAC per re-ceiver is a simple extension of using shared secret keys, where each sender establishes a unique shared pair-wise key with every other node to provide asym-metric key possession. These MACs can be computed in milliseconds (or microseconds in hardware) for a small number of receivers. For each transmitted mes-sage, the sender appends a MAC for each distinct re-ceiver. A receiver would know that a message with a valid MAC could only have come from the sender, because those two nodes uniquely share a secret key (and the receiver knows it did not send the message).  However, even for a small number of receivers, the bandwidth overhead for full-size MACs makes this approach infeasible for most embedded networks. The total bit length of the MACs can be tens to hundreds of times greater than the size of a single message. (Con-sider a common situation in which a message reports whether a switch is “on” or “off,” requiring a one-bit data payload with perhaps thousands of bits of authen-ticator information.) Data could only be sent rarely in this scheme, because most bandwidth would be spent on authentication. Moreover, message size constraints would require fragmenting MACs across multiple mes-sages, and packets in many protocols are not retrans-mitted immediately if corrupted. If a packet containing even a small part of a receiver's authenticator is lost, the receiver would have to wait up to an entire set of message rounds until a new value and authenticator is broadcast. This delay may not be tolerable in a real-time system. 3.2. Possible improvements One possible improvement is to compute these MACs over a set of several messages to amortize the band-width cost over that set. The sending node broadcasts each message in the set in its respective time slot. Once the set of messages has been transmitted, the sender computes the MACs over the set and in following time slots broadcasts one MAC per receiver. While this am-ortizes the overhead over many packets, it induces even longer latency to authentication in the event that a message value or authenticator is lost.  Another possibility is to compute the set of MACs once every nth time a message type is broadcast. This improves loss tolerance since fewer packets contain authenticators, and the bandwidth cost for authentica-tion can be made arbitrarily small. Scheduling can be simplified by taking turns sending authenticators for different receivers (for example, sending only one re-ceiver’s authenticator in turn with each message). But, any single receiver must wait for up to n messages to arrive to see one with an authenticator it knows how to check. The receiver cannot determine whether the n-1 other messages are an attacker's forgeries or not. Addi-tionally, if the nth packet or its authenticator is lost in transmission, the receiver suffers a delay of another full set of n messages and the authenticators.  Schemes using one MAC per receiver are simple and computationally fast, but the poor ratio of message data to authentication data, and unacceptable delays due to losses must be addressed. In this paper we dis-cuss and improve upon an approach which solves these issues by exploiting time-triggered communications. 4. Related Work 4.1. Existing multicast authentication schemes Public key cryptography using digital signatures is another asymmetric approach. While this could provide strong source authentication, the processing overhead makes it impractical for a resource constrained node to compute digital signatures for real time control. Pagers and Palm Pilots can take several seconds to compute a 512 bit RSA signature in resource constrained nodes [4]. Several schemes suggest amortizing the cost of the digital signature over several packets [18][21][25][30]. But, a node would have to amortize the cost over sev-eral hundred messages for this to be effective.   Schemes using one-time digital signatures [8][10] [22] allow senders to sign messages much faster than with traditional digital signatures by using one-way hash functions, at the expense of increased message sizes. Unfortunately, one-time digital signatures can incur several kilobytes of authentication data per mes-sage. This makes them impractical for embedded net-works with small packet sizes and time-triggered communication, even if amortized over many packets.  Canetti et al. [5] suggest a scheme which appends k one-bit MACs to each message, computed using k dif-ferent keys. The keys are distributed amongst receivers such that at least w receivers must conspire to forge a message. While this is more efficient than using one MAC per receiver, it is vulnerable to collusion by mul-tiple nodes that together can masquerade as some other node. Mitigating collusion can require hundreds or thousands of authentication bits per message.   TESLA [23] uses time-delayed release of keys to provide asymmetry. By releasing keys at a pre-specified interval after a MAC is released, receivers can confirm the authenticity of the data from a sender. The released keys are computed using one-way hash chains, but require significant memory space. μTESLA [24], a version of TESLA for resource constrained sen-sor networks, limits the number of authenticated send-ers and utilizes a base station for communications. A base station is often cost-prohibitive for distributed embedded real-time control systems, which use peer-to-peer wired networks. An existing node, such as an embedded gateway, might act as a base station, but 978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
168
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:05 UTC from IEEE Xplore.  Restrictions apply. 
  would be an undesirable single point of failure for the entire network. A fully distributed approach is best. 4.2. Embedded network authentication This work builds upon [28], which provides multicast authentication on a per-packet basis in time-triggered applications, using one truncated MAC per receiver for wired networks.  Other approaches such as SPINS [24] and TinySec [13] apply security to resource constrained wireless sensor networks. However, those approaches are spe-cifically designed for use in wireless networks, which have significantly different constraints. Secure aggre-gation [12][26] focuses on aggregation of data from multiple sensors in close geographic proximity rather than time-triggered messages in temporal proximity.  Morris and Koopman [19] identify the potential for masquerade failures to cause accidental or malicious failures, via non-critical nodes masquerading as higher criticality nodes. They propose the use of counter-measures of varying strengths to prevent masquerading failures between nodes of varying criticality. Their approach assumes non-malicious software faults or attacks from a cryptologically unsophisticated attacker. Fault tolerance mechanisms are not necessarily secure against malicious masquerade or replay attacks. Mas-querade prevention for safety-based systems typically uses bus guardians or a symmetric key shared among all trusted nodes. Compromise of a single node would permit an attacker to masquerade as any system node.  Wolf et al. [29] provide an overview of the security vulnerabilities of various in-vehicle network protocols including Local Interconnect Network (LIN), Media Oriented System Transport (MOST), CAN, and FlexRay. These vulnerabilities primarily focus upon DoS attacks intended to disable networks. Addition-ally, they state the need for confidentiality and authen-tication. Wolf et al. suggest the use of digital signatures or the asymmetric MAC scheme proposed in [5] for authenticating sent packets along with gateways be-tween individual in-vehicle networks. These authenti-cation schemes may not be suitable for some distrib-uted embedded networks, as discussed in Section 4.1.   There have been several publications demonstrating attacks on the authenticity of messages and nodes in embedded networks. Nilsson and Larson [20] detail the actions which an attacker might take, and demonstrate masquerade attacks on CAN using simulation. Hoppe et al. [11] and Lang et al. [17] demonstrate a combina-tion of eavesdropping and replay attacks on CAN.  Lastly, Chávez et al. [6] propose using RC4 encryp-tion to provide confidentiality on CAN buses. They dismiss authentication and non-repudiation as unneces-sary in these networks, under the assumption that mes-sage identifiers and error detection provide sufficient confirmation of the sender's identity. Our work relaxes this assumption by assuming that sender identity can be forged, for example as discussed in [20]. 5. Criticality-based authentication Our approach provides multicast authentication on a per-message basis in time-triggered applications, using one truncated MAC of just a few bits per receiver. Au-thentication of both state-changing messages and reac-tive control messages is accomplished by validating these truncated MACs across multiple packets. In time-triggered applications, each node periodically broad-casts the current state of each of its state variables and sensor inputs to the rest of the network. Information is often broadcast faster than the rate at which receivers must act upon the data in their control loops, allowing authentication of messages over a series of packets containing consistent values. This faster rate also gives the system a degree of resilience to unexpected operat-ing situations and packet losses even with no authenti-cation. This resilience to packet losses carries over to our authentication approach, because all information required to validate a single packet is self-contained.  5.1. Message types We distinguish between two types of messages: state-changing and reactive control. State-changing mes-sages cause transitions within finite state machines in the system design, or cause discrete, discontinuous output changes in actuators. In our approach, to au-thenticate state-changing messages nodes must receive a predefined number of correctly authenticated packets with consistent message values directing the state change before executing the action. A set of state-changing packet values are consistent if all data values are equal, or all are within a predefined range in which each would trigger the same state change.   Our approach does not require the sender to trans-mit extra messages. Instead, our approach takes advan-tage of periodic transmissions of current state values, enabling a tradeoff between application level latency, per-packet authentication cost, and probability of in-duced failures. The number of required packets and authentication bits per packet depends upon the criti-cality of the state change, as discussed later.   Reactive control system messages cause updates to continuous or ordered values in network nodes running feedback control loops. These loops often contain a low pass filter to actuator changes (implicit or explicit), such as physical inertia. Again, a receiver performs authentication over packets with consistent values. Reactive control message values are consistent if they pass standard validity or sanity checks (such as input bounds checking), which is a less stringent criterion than that for state-changing messages. Authenticating 978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
169
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:05 UTC from IEEE Xplore.  Restrictions apply. 
  each consistent message value allows the receiver to perform per-message validation of messages. The sys-tem will tolerate some small number of forged mes-sages because of physical damping, requiring the at-tacker to forge multiple messages before an unsafe output can occur. So long as each reactive control mes-sage contains enough authenticator bits, the probability of successfully forging such a large set of messages can be made sufficiently low. This enables a tradeoff between per-packet authentication costs and probabil-ity of induced failure. 5.2. Assumptions This scheme relies upon several assumptions: • Packets are transmitted at a rate fast enough for a receiver to authenticate multiple consistent values for a message type within system deadlines.  • Each sender has sufficient computational resources to compute one MAC per receiver per packet that is sent. The required computational resources depend on the MAC function used. • The number of bits in a packet's data payload is greater than the number of receivers of a packet. This allows authenticators for each receiver in the packet, leaving room for the message value.  • Nodes use existing cryptographic one-way hash functions, such as SHA-256, and MAC functions to implement authentication ([27] includes examples). We assume the underlying cryptographic primitives are secure. We do not rely on specific MAC or one-way hash functions to implement our scheme. • A certification authority exists to assign key mate-rial to components when they are manufactured. • The network configuration is fixed; nodes are not installed or uninstalled on the fly. • Nodes remain synchronized to the nearest message round. 5.3. Attacker model We assume an attacker can gain access to the system through a gateway connection to an external network, malicious insider code, physical access to network lines, or tampering with nodes. They may own the de-vice being attacked. We consider an active attacker model [27] in which an attacker may modify, inject, drop, or eavesdrop upon network traffic.  Attackers accessing the network through corrupted nodes will have access to the key material in those nodes. An attacker must not be able to masquerade as any node they do not already control to perform a suc-cessful attack, except by random chance.  We will assume an attacker is aware of existing error detection mechanisms along with the network schedule, and is capable of injecting well-formed packets in valid time slots. This constrains an attacker to one forgery attempt per valid time slot in a TDMA network such as TTP or FlexRay, since transmitters are only permitted to transmit a single packet per time slot in a time-triggered application. For the purpose of analysis, we consider the worst case scenario in which a successful attack depends solely on fooling a single receiver. In practice, isolating receivers may be diffi-cult if strong existing fault containment mechanisms such as group membership are used.  Additionally, we consider the effects of packets containing invalid MACs (malicious and non-malicious) which might disrupt authentication. We do not consider full DoS attacks intended to prevent de-livery of all network traffic, because as discussed by Wolfe et al. [29], there are numerous existing vulner-abilities in these networks to that type of attack, and our scheme does not attempt to address these.  5.4. Authentication process 5.4.1. Key initialization and replay protection. Each node is programmed with  a public  and private Diffie- Hellman [7] key pair (digitally signed by a trusted cer-tification authority, such as the manufacturer) and the certification authority's public key. Upon installation or replacement, each node uses these keys to establish a shared secret key with each other node. Because of the pair-wise shared keys, an attacker cannot masquerade as any node other than the one compromised. All nodes wired to the network are known at design time, and key establishment costs are incurred once at installation.  Replay protection is provided using a protocol for securely synchronizing time or TDMA round number between nodes such as the Secure Pair-wise Synchro-nization protocol [9], once pair-wise keys are estab-lished. This can provide synchronization on the order of microseconds to ensure freshness of messages for each message round, which can be tens to hundreds of milliseconds. Global synchronization is not needed, since only pairs of nodes share each secret key. We include current time or TDMA round number along with the secret key as inputs to a cryptographically secure MAC function. Synchronized time values must not roll over for some acceptably long period of time. This prevents the attacker from predicting the MACs over this period of time even for identical data values.  5.4.2. Run-time message generation. When a node sends a packet, it computes a MAC for each distinct receiving node in the network over the message value, packet header, and the current time using the pair-wise shared secret key. Each MAC is truncated down to just a few bits, and appended to the message value. By only using a few bits, one MAC per receiver can be placed in a single packet, as illustrated in Figure 1. The size of each truncated MAC could be as little as one bit per 978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
170
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:05 UTC from IEEE Xplore.  Restrictions apply. 
  Figure 1. Example packet containing 32 bits of data and four 8-bit MACs, for four receivers. MAC. All authentication for each packet is fully con-tained within the data payload of that packet, allowing each packet to be verified independently. 5.4.3. State-changing message verification. A re-ceiver authenticates state-changing messages by au-thenticating a set of packets. The node keeps an au-thentication history buffer for each message type used. Each packet is authenticated individually when re-ceived, and the receiver stores the results (“valid” or “invalid”) for the n most recent packets in the history buffer. A receiver considers a packet to be valid if it contains correct authentication and error detection fields. It is invalid if the error detection field is correct and the authentication field is incorrect. Any packets containing an incorrect error detection field are invalid, and are omitted from the history buffer.   The state change occurs when at least k out of the past n time-triggered packets have consistent values and are valid. Assume that each packet contains b au-thentication bits per receiver. State changes occur as soon as the kth packet with a consistent message value has been validated. While it is likely that an attacker will be able to forge a single packet since we use just a few authentication bits per MAC, it is unlikely that they will be able to forge so many within the history of the buffer as to cause a successful masquerade attack. An attacker can successfully forge at least k of a set n packets with a binomial probability of: (2)(12)nbibniAiknPi−−−=⎛⎞=−⎜⎟⎝⎠∑  (1)     Allowing state changes to occur after validating a subset of MACs in the history buffer grants this ap-proach a degree of tolerance to interspersed invalid MACs. Without this tolerance, an attacker can increase message latency or prevent authentication altogether while remaining undetected by occasionally injecting invalid packets. Packets with a correct CRC but invalid MAC might also be caused by non-malicious faults. For example, if the sender's and receiver's notions of time differ due to a temporary internal fault, the re-ceiver would see an invalid MAC. Additionally, some message corruptions might be missed by error detec-tion mechanisms, so occasional invalid MACs might result from transmission errors.  In applications which do not require tolerance to invalid MACs or require a very low probability of suc-cessful attack, the receiver waits for a set of consecu-tively validated MACs. In this case, k is equal to n. The probability of forging n consecutive packets is: 2nbAP−=       (2)     This approach for authenticating state-changing messages enables the system designer to perform a tradeoff among per-packet authentication cost, applica-tion level latency, tolerance to invalid MACs and prob-ability of an induced failure. Based upon the criticality of the message, the designer trades increased band-width and latency for lower probability of failure, and trades increased tolerance to invalid MACs for in-creased risk of induced failure. Additionally, there is a limit on the number of required packets, based upon the maximum tolerated latency for authentication, how many packets are expected to contain consistent mes-sage values (depending upon network speed), and the bandwidth available for authentication bits in packets.  5.4.4. Reactive control message verification. Unlike state-changing message verification, nodes running feedback control loops authenticate each message packet as it arrives. Each authenticated message causes an immediate change in actuator outputs. Packets con-taining detected transmission errors or incorrect MACs are discarded without updating outputs. An actuator might cause an unsafe situation if it accepts too many successfully forged message values commanding it to an unsafe position within a time period, even if it re-ceives valid message values within that period. We consider the case where at least k messages must be successfully forged out of the n most recently received messages to force the system to an unsafe state. Values for n and k depend on the characteristics of the system. More complex control systems in which messages cause varying amounts of actuation depending upon their value and exact timing require further analysis and are beyond the scope of this paper.  For reactive control messages, the receiver does not explicitly retain an authentication history buffer in memory, but relies instead upon a damped response to messages. In order to successfully attack the system, an attacker must individually forge at least k out of the n most recent messages sent to the receiver. This gives the probability of a successful undetected attack in equation (1). For actuators which require a set of n consecutive messages to reach an unsafe output, equa-tion (2) describes the probability of a successful attack.  This approach also supports trading increased per packet authentication cost for reduced probability of induced system failure. The designer selects the num-ber of bits per packet b based upon the amount of physical change produced per message, such that the 978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
171