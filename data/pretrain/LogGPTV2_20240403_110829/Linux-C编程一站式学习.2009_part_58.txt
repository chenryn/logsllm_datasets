const
h
10
fopen(
const 
 sizeof(struct record),
1o
("Open file recfile");
1o
char
"recfile", "r");
10
00.０0.00
由于结构体中有填充字节，
10
*format,
10
10
1o
1c 00:00:00
;··);
1o
o
10034
\0030
 如果在一种平台上编译运
 fp);
 每条记录占16字节
10
10
10
为
---
## Page 471
数的函数。
上面列出的后四个函数在前四个函数名的前面多了个v，
较就可以知道是否发生了截断。
的\'）
串长度超过缓冲区长度,
很可能造成缓冲区溢出，
而是打印到用户提供的缓冲区str中并在末尾加\o,
printf格式化打印到标准输出，
就
例 25.8.实现格式化打印错误的err_sys函数
返回值：成功返回格式化输出的字节数（不包括字符串的结尾'\0`），
ap);
#include 
如果字符串被截断,
七
vsnprintf(char *str, size_t size, const 
 vsprintf(char
stderr);
%s", strerror(err));
void err_sys(const char *fmt, ...)
int main(int argc, char *argv[］)
#define MAXLINE 80
#include
#include
#include
#include
vaierd(ap);
fputs(buf,
strcat(buf
vsnprintf(buf,
va_start(ap; 
va
char
int err:
用snprintf更好一些,
(argc
返回的是截断之前的长度，把它和实际缓冲区中的字符串长度相比
，而fprintf打印到指定的文件stream中。sprintf并不打印到文件,
exit(1);
fputs("Usage: ./a.out pathname\n",
'stderr)
const
"\n"）
 fmt);
char 
va_list ap);
!(.
 参数size指定了缓冲区长度，
由于格式化后的字符串长度很难预计，
表示可变参数不是以...的形式传进来，
 char 
list
再加上一个写入缓冲区，
出错返回一个负值
 ap）
，如果格式化后的字符
":
山
所以
参
也
---
## Page 472
常用的转换字符有：
它格式请参考Man Page。每个转换说明以g号开头，
现在总结一下print格式化字符串中的转换说明的有哪些写法。
源代码行号，有打开文件的路径名，
有
表 25.2. print的转换字符
选项
表 25.1.printf转换说明的可选项
长
4
度
精
度
宽
#
于是有符号数还是无符号数则取决于转换字符；
对于整型参数，
为精度。
值而是写成一个*号，表示取下一个int型参数作
了格式化后的最小位数。精度也可以不指定整数
格式化后小数点右边的位数，
式化后保留的最大长度，
精度。
用于分隔上一条提到的最小长度和下一条要讲的
表示取一个int型参数作为宽度。
特别的形式，
化后的内容没有这么长，
用一个整数指定格式化后的最小长度，
格式化后的内容居左，右边可以留空格。
加0x（转换字符为x）或0X（转换字符为x）。
八进制前面加0（转换字符为。）
一个整数表示精度，
LINE_
，不仅简化了main函数的代码，
 不指定整数值而是写成一
return 0;
if (fp == NULL)
，hh、h、1、11分别表示
 argy[1]);
对于字符串来说指定了
描述
err_sys("Line %d - Open file %s",
，对于浮点数来说指定
 可以在左边留空格，如
一看就知道哪里出错了。
，对于整数来说指定
宽度有一种
十六进制前面
一个*号
如果格式
而且可以把fopen的错误提示打印得非常清楚，
，以转换字符结尾，我们以前用过的转换说明仅
格
定
printf("%hhd",， 255)打印-1。
%*.*f-"，8，4，3.14)打
100)打
printf("-%10s-"，"hello")打
printf("%#x"， Oxff)打
印_
printf("%.4s",
见下面的例子
hello
%-*s-" 
印_
见下面的例
印ff。
，在这里只列举几种常用的格式，
3.1400-。
 01oo-， printf("-
10，
 hello-,printf("-
一些可选项。
"hello")打印-
举例
"hello")打
其
有
---
## Page 473
传其它参数，
得到错误的结果，
下面看scanf函数的各种形式。
我
出的参数类型从栈帧上取参数，
们在第6节“可变参数"讲过可变参数的原理，
上面也举过几个这样的例子。
%格式化成一
#include 
gG
eE
d
s
C
X
×
n
d
符
转换字
或（转换字符是G）格式化，
小数点后的数字,
取double型参数格式化，
格式，小数点后的默认精度是6位，指数至少是
取double型参数格式化成[-]d.dddetdd（转换字
式，小数点后的默认精度是6位。
于%#x。
取void*型参数格式化成十六进制表示。
取constchar*型参数所指向的字符串格式化输
对应的ASCI码字符。
取int型参数转换成unsigned char型，格式化成
数小于指定的精度，
取unsignedint型参数格式化成无符号八进制
分
两位。
六进制数字用大写ABCDEF，
（o）、十进制（u)、十六进制（x或X）表
补0。
格式化后的位数小于指定的精度，
取int型参数格式化成有符号十进制表示，
(精度)
照样会从栈帧上取参数。所以比较保险的办法是printf（"%s"，s）。
，遇到\结束，
小数点也去掉。
，因为字符串中可能包含号而被printf当成转换说明，printf并不知道后面没有
）结束。
个%。
 默认精度是6。如果指数小于-
 或者达到指定的最大长度
就在左边补0。
描述
另外，
所以如果实际参数和转换说明的类型不符，
精度是指有效数字而非
 如果s指向一个字符串，
如果格式化后的位
否则按格式
就在左边
X表示十
相当
如果
printf("")打印一个。
printf("%g"， 3.00)打
址0x80483c4。
印main函数的首地
printf("%.4s",
printf("%c"， 256+'A')打印A。
-1)打印255。
oxDEADBEEF, printf("%hhu"
printf("%#x",
印0100。
printf("%.4d"， 100)打
05。
，用printf(s)打印这个字符串可能
，3.14)打
main）打
举例
，Oxdeadbeef)打
，结果可能会有些意
"hello")打
只能按转换说明
473
---
## Page 474
常用的转换字符有：
转换说明中的可选项有：
格式化字符串中包括：
时可以从这个位置继续。
回值可能小于赋值参数的个数，文件的读写位置指向输入中不匹配的地方，下次调用库函数读文件
换说明，
现在总结一下scanf的格式化字符串和转换说明，
传进来，而是以va_list类型传进来。
符，而sscanf从指定的字符串str中读字符。后面三个以v开头的函数的可变参数不是以...的形式
参数，
scanf 从标准输入读字符，按格式化字符串format中的转换说明解释这些字符，转换后赋给后面的
·对于整型参数可以指定字长,
·*号，表示这个转换说明只是用来匹配一段输入字符，但匹配结果并不赋给后面的参数。
·转换说明，以开头，以转换字符结尾，中间也有若干个可选项。
·空格或Tab，在处理过程中被忽略。
上1或L分别表示double*或1ong double*型。
用一个整数指定的宽度N。表示这个转换说明最多匹配N个输入字符，或者匹配到输入字符中
普通字符（不包括），
但i和还有一层含义,
的下一个空白字符结束。
表 25.3.scanf的转换字符
int vscanf(const char *format, va_list ap);.
#include 
就给-
int
int sscanf(const char 
int fscanf(FILE
10表示
一个参数赋值，
当转换字符是e、f、g时，
，如果读到文件或字符串末尾就停止，或者如果遇到和格式化字符串不
*stream, .
 和输入字符中的非空白字符相匹配。输入字符中的空白字符是指空
const char
 const char
const
.··);
，这里也只列举几种常用的格式，其它格式请参
描述
*format,.
，表示赋值参数的类型是float*而非double
*format，
*format,
...);
ya_list ap);
...);
是供的赋值参数，返
含义和printf相同。
如果成功匹配一个转
474
---
## Page 475
如果要读取12/25/1998这样的日期格式，
了不容易，需要多练习，
的空格和Tab再多一些,
如果str中的空白字符再多一些，
如果我们要读取25 Dec 1988这样的日期格式，
下面几个例子出自[K&R]。
例 25.9.用scanf实现简单的计算器
sscanf(str, "%d %s %d", &day, monthname, 
char monthname[20］;
char :
%
g
D
s
C
p
int
转换说明%%匹配一
*或long double ＊的字长。
匹配浮点数（开头可以有负号），赋值参数的类型是float＊，也可以指定double 
字符之前，或者匹配到指定的宽度，赋值参数的类型是char ＊，末尾自动添 
个空格去匹配。
匹配一串字符，字符的个数由宽度指定，
是unsigned int *o
匹配八进制、十进制、十六进制整数（开头可以有负号），
以0x或0X开头则匹配十六进制整数，
匹配整数 (开头可以有负号)
匹配十进制整数（开头可以有负号）
加\'。
匹配一串非空白字符，
，
day
末尾不会添加'。
*str = "25 Dec 1988";
，而是保存到参数中，
int main(void)
#include 
 year;
通过练习体会空白字符的作用。
double sum, v;
。第一个例子，
，比如"25 Dec 1998",
从输入字符中的第一个非空白字符开始匹配到下一个空白
 /* rudimentary calculator */
如果输入字符的开头有空白字符，
，要想跳过开头的空白字符，
不做赋值
，就需要在格式化字符串中用/匹配输入字符中的/：
，读取用户输入的浮点数累加起来。
赋值参数的类型是int*,
"\t%.2f\n", sum += v);
可以这样写：
如果输入字符以0开头则匹配八进制整数。
 &v） == 1)
，赋值参数的类型是int*。
，缺省宽度是1，赋值参数的类型是char
 仍然可以正确读取。如果格式化字符串中
 &year);
可以在格式化字符串中用一
这些空白字符并不被忽
，赋值参数的类型
如果输入字符
475
---
## Page 476
区中的数据传给内核，
2.10.C标准库的IVO缓冲区请点评
下图以fgets/fputs示意了I/O缓冲区的作用，
之前也会做Flush操作。
Hierarchy"中CPU、
到I/O缓冲区
向I/O缓冲区中的第二个字符,
每个打开的文件分配一
用户程序调用C标准I/O库函数读写文件或设备,
式，可以这样写：
好是先用fgets按行读取，然后再交给sscanf处理。如果我们的程序需要同时识别以上两种日期格
scanf把换行符也看作空白字符，
传给内核,
在IO缓冲区中，
进
核
（以后我们会看到与I/O相关的系统调用）
（图中的buf1和buf2）
区中，
用户空间
入内核读1K字节
当用户把这1字节都读完
用户调用读写函数大多数时候都在IO缓冲区中读写,
图 25.1.C标准库的VO缓冲区
scanf("%d/%d/%d", &month, &day, &year);
int day, month, year; 
这样fputc函数可以很快地返回，如果I/O缓冲区写满了，
间读取数据比进内核读数据要快得多。
中
 是希望用户程序随后要用到这些数据，
节到I/O缓冲区中,
else
else if “
 Cache和内存之间的关系一样，
 内核最终把数据写回磁盘。有时候用户程序希望把I/O缓冲区中的数据立刻
一个I/O缓冲区以加速读写操作，
printf("invalid: %s\n", line); /* invalid form */
N
，仅仅当作字段之间的分隔符，如果输入中的字段个数不确定，
后
然后返回IO缓冲区中的第一个字节给用户，
序、C标准库和内核之间的关系就像在第5节“Memory
月户再调fgetc，就直接从I/O缓冲区中读取,
%s