计工具里提取出来的，只保留了高危漏洞的规则。 
• 
'可能存在代码执行漏洞,或者此处是后门' : 
r"""$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}\s{0,5}(\s{0,5}$_(POST|GET|REQUEST|
SERVER)[.{1,20}]""", 
• 
'phpinfo()函数，可能存在敏感信息泄露漏洞' : r"""\bphpinfo\s{0,5}(\s{0,5})""", 
• 
'命令执行函数中存在变量，可能存在任意命令执行漏洞' : 
r"""\b(system|passthru|pcntl_exec|shell_exec|escapeshellcmd|exec)\s{0,10}(.{0,40
}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}""", 
• 
'eval 或者 assertc 函数中存在变量，可能存在代码执行漏洞' : 
r"""\b(eval|assert)\s{0,10}(.{0,60}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}""", 
• 
'存在文件上传，注意上传类型是否可控' : r"""\bmove_uploaded_file\s{0,5}(""", 
• 
'文件包含函数中存在变量,可能存在文件包含漏洞' : 
r"""\b(include|require)(_once){0,1}(\s{1,5}|\s{0,5}().{0,60}$(?!.*(this-
>))\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}""", 
• 
'preg_replace 的/e 模式，且有可控变量，可能存在代码执行漏洞' : 
r"""\bpreg_replace(\s{0,5}./[is]{0,2}e[is]{0,2}["']\s{0,5},(.$.,|.,.*$)""", 
• 
'call_user_func 函数参数包含变量，可能存在代码执行漏洞' : 
r"""\bcall_user_func(_array){0,1}(\s{0,5}$\w{1,15}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}""", 
• 
'读取文件函数中存在变量，可能存在任意文件读取漏洞' : 
r"""\b(file_get_contents|fopen|readfile|fgets|fread|parse_ini_file|highlight_file|fget
ss|show_source)\s{0,5}(.{0,40}$\w{1,15}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}""", 
• 
'parse_str 函数中存在变量,可能存在变量覆盖漏洞' : 
r"""\b(mb_){0,1}parse_str\s{0,10}(.{0,40}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}""
", 
• 
'双$$符号可能存在变量覆盖漏洞' : 
r"""${{0,1}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}\s{0,4}=\s{0,4}.{0,20}$\w{1,20}((
[["']|[)${0,1}[\w[]"']{0,30}){0,1}""", 
• 
'获取 IP 地址方式可伪造，HTTP_REFERER 可伪造，常见引发 SQL 注入等漏
洞' : r""""'["']""", 
• 
'文件操作函数中存在变量，可能存在任意文件读取/删除/修改/写入等漏洞' : 
r"""\b(unlink|copy|fwrite|file_put_contents|bzopen)\s{0,10}(.{0,40}$\w{1,20}(([["']|[
)${0,1}[\w[]"']{0,30}){0,1}""", 
• 
'extract 函数中存在变量，可能存在变量覆盖漏洞' : 
r"""\b(extract)\s{0,5}(.{0,30}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}\s{0,5},{0,1}\s{
0,5}(EXTR_OVERWRITE){0,1}\s{0,5})""", 
• 
'urldecode 绕过 GPC,stripslashes 会取消 GPC 转义字符' : 
r"""^(?!.*\baddslashes).{0,40}\b((raw){0,1}urldecode|stripslashes)\s{0,5}(.{0,60}$\
w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}""", 
• 
'`反引号中包含变量，变量可控会导致命令执行漏洞' : 
r"""$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}`""", 
• 
'array_map 参数包含变量，变量可控可能会导致代码执行漏洞' : 
r"""\barray_map\s{0,4}(\s{0,4}.{0,20}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}\s{0,
4}.{0,20},""", 
• 
'SQL 语句 select 中条件变量无单引号保护，可能存在 SQL 注入漏洞' : 
r"""select\s{1,4}.{1,60}from.{1,50}\bwhere\s{1,3}.{1,50}=["\s.]{0,10}$\w{1,20}(([["']|
[)${0,1}[\w[]"']{0,30}){0,1}""", 
• 
'SQL 语句 delete 中条件变量无单引号保护，可能存在 SQL 注入漏洞' : 
r"""delete\s{1,4}from.{1,20}\bwhere\s{1,3}.{1,30}=["\s.]{0,10}$\w{1,20}(([["']|[)${0,
1}[\w[]"']{0,30}){0,1}""", 
• 
'SQL 语句 insert 中插入变量无单引号保护，可能存在 SQL 注入漏洞' : 
r"""insert\s{1,5}into\s{1,5}.{1,60}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}""", 
• 
'SQL 语句 update 中条件变量无单引号保护，可能存在 SQL 注入漏洞' : 
r"""update\s{1,4}.{1,30}\s{1,3}set\s{1,5}.{1,60}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){
0,1}""", 
为什么要自写 python 代码呢，主要还是因为很多时候有些文件漏洞利用需要
登录界面之后才能利用。但是往往企业版本 CMS 很少具备注册、登录、用户发帖
功能。都是登录后台以后才能使用。所以我通常会做以下的判断： 
• 
1）分析配置文件是否有某些代码层上的过滤 
• 
2）分析会话验证文件，排除掉需要会话验证才能访问的文件 
• 
3）利用漏洞规则扫描未登录状态下可以访问的页面 
python 代码最终扫描出以下文件可以做文件上传的测试，完整的 python 代码
会贴到文章后面。： 
分析了前面几个文件后，发现了/my Admin/email/excel/excel.php 这个文件，
似乎利用起来是最简单的。 
因为打开的时候加上 http://xxxxxx/my Admin/email/excel/excel.php?pageT=new 
就有个 html 表单可以文件上传，感觉很开心，但是并不是这样。因为点开上传之
后就是 404。 
上传漏洞利用分析 
虽然文件上传漏洞利用没有想象中的顺利，回到漏洞文件仔细又分析了一遍源
码。发现是 POST 的请求 URI 位置不存在，但是 excel.php 这个文件确实接收到了
文件流数据。38 行文件上传未改名。59 行修改文件上传的临时文件名称为 10~ 
6000000 的整数。例如 2917320php.php 
手动构造了一下 form 表单页面，然后修改了 from 的来源页成真实存在的来源页后
再抓包发送。webshell 果然上传成功。 
 : 
/uploads/files/ema
ilImport.xls" target="_blank">. Create
 Excel File With 3 columns, 1 for Name, 2nd for Email, 3rd For group, U
pload Excel File and submit 
三、线索收集 
拿到 shell 后，迅速排查了下日志和 webshell。根据上传的时间发现了攻击者
的 webshell 和样本。 
再从原始投放样本时间相近的 20XX/XX/XX 16:48:10 范围内，error_log 日志找
到了攻击者的 IP。然后截图、打包 shell。 
扩展线索 
通过报告里的文件名在 VT 中尝试关联，name:"hmfs.exe"得到不同的 HASH 值。 
其中的 HASH 值：0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 可以关联出同类作为
水坑的正常站点。 
再利用这些被黑站点的 URI 反向打击一波，扩充了攻击者跳板 IP。 
四、事件小结 
对这次渗透测试的过程进行个小总结。 
1）Google hacking 得到登录后台 
2）登录后台 Github 找到了源码 
3）代码审计容易出现高危漏洞的函数找到了文件上传 
4）构造 HTML 表单成功上传了 webshell