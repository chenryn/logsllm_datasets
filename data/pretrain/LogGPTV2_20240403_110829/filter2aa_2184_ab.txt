### 高危漏洞规则提取

以下是从代码分析工具中提取的高危漏洞规则，这些规则旨在识别潜在的安全风险。

1. **可能存在代码执行漏洞或后门**：
   ```regex
   \w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}\s{0,5}(\s{0,5}$_(POST|GET|REQUEST|SERVER)[.{1,20}]
   ```

2. **phpinfo()函数，可能存在敏感信息泄露漏洞**：
   ```regex
   \bphpinfo\s{0,5}
   ```

3. **命令执行函数中存在变量，可能存在任意命令执行漏洞**：
   ```regex
   \b(system|passthru|pcntl_exec|shell_exec|escapeshellcmd|exec)\s{0,10}(.{0,40}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
   ```

4. **eval 或 assert 函数中存在变量，可能存在代码执行漏洞**：
   ```regex
   \b(eval|assert)\s{0,10}(.{0,60}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
   ```

5. **存在文件上传，注意上传类型是否可控**：
   ```regex
   \bmove_uploaded_file\s{0,5}
   ```

6. **文件包含函数中存在变量，可能存在文件包含漏洞**：
   ```regex
   \b(include|require)(_once){0,1}(\s{1,5}|\s{0,5}().{0,60}$(?!.*(this-))\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
   ```

7. **preg_replace 的/e 模式，且有可控变量，可能存在代码执行漏洞**：
   ```regex
   \bpreg_replace(\s{0,5}./[is]{0,2}e[is]{0,2}["']\s{0,5},(.$.,|.,.*$)
   ```

8. **call_user_func 函数参数包含变量，可能存在代码执行漏洞**：
   ```regex
   \bcall_user_func(_array){0,1}(\s{0,5}$\w{1,15}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
   ```

9. **读取文件函数中存在变量，可能存在任意文件读取漏洞**：
   ```regex
   \b(file_get_contents|fopen|readfile|fgets|fread|parse_ini_file|highlight_file|fgetss|show_source)\s{0,5}(.{0,40}$\w{1,15}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
   ```

10. **parse_str 函数中存在变量，可能存在变量覆盖漏洞**：
    ```regex
    \b(mb_){0,1}parse_str\s{0,10}(.{0,40}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
    ```

11. **双$$符号可能存在变量覆盖漏洞**：
    ```regex
    ${{0,1}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}\s{0,4}=\s{0,4}.{0,20}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
    ```

12. **获取 IP 地址方式可伪造，HTTP_REFERER 可伪造，常见引发 SQL 注入等漏洞**：
    ```regex
    '["']
    ```

13. **文件操作函数中存在变量，可能存在任意文件读取/删除/修改/写入等漏洞**：
    ```regex
    \b(unlink|copy|fwrite|file_put_contents|bzopen)\s{0,10}(.{0,40}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
    ```

14. **extract 函数中存在变量，可能存在变量覆盖漏洞**：
    ```regex
    \b(extract)\s{0,5}(.{0,30}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}\s{0,5},{0,1}\s{0,5}(EXTR_OVERWRITE){0,1}\s{0,5})
    ```

15. **urldecode 绕过 GPC, stripslashes 会取消 GPC 转义字符**：
    ```regex
    ^(?!.*\baddslashes).{0,40}\b((raw){0,1}urldecode|stripslashes)\s{0,5}(.{0,60}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
    ```

16. **反引号中包含变量，变量可控会导致命令执行漏洞**：
    ```regex
    $\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}`
    ```

17. **array_map 参数包含变量，变量可控可能会导致代码执行漏洞**：
    ```regex
    \barray_map\s{0,4}(\s{0,4}.{0,20}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}\s{0,4}.{0,20},
    ```

18. **SQL 语句 select 中条件变量无单引号保护，可能存在 SQL 注入漏洞**：
    ```regex
    select\s{1,4}.{1,60}from.{1,50}\bwhere\s{1,3}.{1,50}=["\s.]{0,10}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
    ```

19. **SQL 语句 delete 中条件变量无单引号保护，可能存在 SQL 注入漏洞**：
    ```regex
    delete\s{1,4}from.{1,20}\bwhere\s{1,3}.{1,30}=["\s.]{0,10}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
    ```

20. **SQL 语句 insert 中插入变量无单引号保护，可能存在 SQL 注入漏洞**：
    ```regex
    insert\s{1,5}into\s{1,5}.{1,60}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
    ```

21. **SQL 语句 update 中条件变量无单引号保护，可能存在 SQL 注入漏洞**：
    ```regex
    update\s{1,4}.{1,30}\s{1,3}set\s{1,5}.{1,60}$\w{1,20}(([["']|[)${0,1}[\w[]"']{0,30}){0,1}
    ```

### 自写 Python 代码的原因

编写 Python 代码的主要原因在于许多文件漏洞利用需要登录界面才能进行。然而，企业版本的 CMS 往往缺乏注册、登录和用户发帖功能，通常需要登录后台才能使用。因此，我通常会做以下判断：

1. **分析配置文件是否有某些代码层上的过滤**。
2. **分析会话验证文件，排除掉需要会话验证才能访问的文件**。
3. **利用漏洞规则扫描未登录状态下可以访问的页面**。

通过 Python 代码扫描，最终发现以下文件可以进行文件上传测试：`/my Admin/email/excel/excel.php`。

### 文件上传漏洞利用分析

虽然文件上传漏洞利用没有想象中的顺利，但经过对源码的仔细分析，发现 `excel.php` 文件确实接收到了文件流数据。具体问题在于 POST 请求的 URI 位置不存在。文件上传未改名，第 59 行修改了文件上传的临时文件名称为 10~6000000 的整数（例如 `2917320php.php`）。

手动构造了一个 form 表单页面，并将来源页修改为真实存在的页面后，成功上传了 webshell。

### 线索收集

获取 shell 后，迅速排查了日志和 webshell。根据上传时间发现了攻击者的 webshell 和样本，并在相近时间范围内的 `error_log` 日志中找到了攻击者的 IP。进一步通过 VT 关联文件名，扩展了攻击者的跳板 IP。

### 事件小结

对这次渗透测试的过程进行总结：

1. **通过 Google hacking 找到登录后台**。
2. **从 GitHub 获取源码**。
3. **代码审计找到文件上传漏洞**。
4. **构造 HTML 表单成功上传了 webshell**。