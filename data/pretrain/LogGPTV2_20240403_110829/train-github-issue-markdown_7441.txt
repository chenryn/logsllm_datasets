Examples:
    class C
    {
      value : R;
      constructor(v? : R) { this.value = v }
    }
    // OK, no type error
    var a : C = new C("x");
    // OK, type error
    var b : C = new C(1);
    var c : C = true ? new C("x") : new C(1);
    var d : C = new C(1) || new C(null);
    function e() : C { if (false) { return new C(null) } else { return new C(1) } }
    // Bad, no type error
    var f : C = true ? new C(null) : new C(1);
    var g : C = true ? new C(1) : new C(null);
    var h : C = (() => { if (false) { return new C(null) } else { return new C(1) } })();
    var i : C = new C(1) || new C(null);
Here, any time `new C(1)` is used it should have the type `C` and not
unify with `C`. It seems like `R` not being known in `new C(null)`
prevents these other type errors from occurring.