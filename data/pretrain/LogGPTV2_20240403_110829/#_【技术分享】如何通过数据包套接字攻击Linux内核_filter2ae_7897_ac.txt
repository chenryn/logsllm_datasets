    186 struct tpacket_hdr_v1 {
    187         __u32   block_status;
    188         __u32   num_pkts;
    189         __u32   offset_to_first_pkt;
    ...
    233 };
    234 
    235 union tpacket_bd_header_u {
    236         struct tpacket_hdr_v1 bh1;
    237 };
    238 
    239 struct tpacket_block_desc {
    240         __u32 version;
    241         __u32 offset_to_priv;
    242         union tpacket_bd_header_u hdr;
    243 };
同样，每个帧也有一个与之关联的头部，头部结构为tpacket3_hdr，其中tp_next_offset字段指向同一个内存块中的下一个帧。
    162 struct tpacket3_hdr {
    163         __u32  tp_next_offset;
    ...
    176 };
当某个内存块完全被数据填满时（即新的数据包不会填充到剩余的空间中），内存块就会被关闭然后释放到用户空间中（也就是说被内核停用）。由于通常情况下，用户希望尽可能快地看到数据包，因此内核有可能会提前释放某个内存块，即使该内存块还没有被数据完全填满。内核会维护一个计时器，使用tp_retire_blk_tov参数控制超时时间，当超时发生时就会停用当前的内存块。
还有一种方式，那就是指定每个块的私有区域，内核不会触碰这个私有区域，用户可以使用该区域存储与内存块有关的任何信息。这个区域的大小通过tp_sizeof_priv参数进行传递。
如果你想更加详细了解用户空间程序如何使用TPACKET_V3环形缓冲区，你可以阅读官方文档中提供的具体示例（搜索“TPACKET_V3
example”关键词）。
**四、AF_PACKET套接字的具体实现**
我们来快速了解一下AF_PACKET在内核中的具体实现。
**4.1 结构体定义**
每当创建一个数据包套接字时，内核中就会分配与之对应的一个packet_sock结构体对象，如下所示：
    103 struct packet_sock {
    ...
    105         struct sock             sk;
    ...
    108         struct packet_ring_buffer       rx_ring;
    109         struct packet_ring_buffer       tx_ring;
    ...
    123         enum tpacket_versions   tp_version;
    ...
    130         int                     (*xmit)(struct sk_buff *skb);
    ...
    132 };
这个结构体中，tp_version字段保存了环形缓冲区的版本，在本文案例中，我们通过setsockopt调用，传入PACKET_VERSION参数，将环形缓冲区的版本设置为TPACKET_V3。rx_ring以及tx_ring字段代表接收（receive）和传输（transmit）环形缓冲区，这类缓冲区使用设置了PACKET_RX_RING和PACKET_TX_RING选项的setsockopt调用来创建。这两个字段的类型为packet_ring_buffer，此类型的定义如下：
    56 struct packet_ring_buffer {
    57         struct pgv              *pg_vec;
    ...
    70         struct tpacket_kbdq_core        prb_bdqc;
    71 };
其中pg_vec字段为指向pgv结构体数组的一个指针，数组中的每个元素都保存了对某个内存块的引用。每个内存块实际上都是单独分配的，没有位于一个连续的内存区域中。
    52 struct pgv {
    53         char *buffer;
    54 };
prb_bdqc字段的类型为tpacket_kbdq_core结构体，这个结构体的字段描述了环形缓冲区的当前状态，如下所示：
    14 struct tpacket_kbdq_core {
    ...
    21         unsigned short  blk_sizeof_priv;
    ...
    36         char            *nxt_offset;
    ...
    49         struct timer_list retire_blk_timer;
    50 };
其中blk_sizeof_priv字段包含每个内存块所属的私有区域的大小。nxt_offset字段指向当前活跃的内存块的内部区域，表明下一个数据包的存放位置。retire_blk_timer字段的类型为timer_list结构体，用来描述超时发生后停用当前内存块的那个计时器，如下所示：
    12 struct timer_list {
    ...
    17         struct hlist_node       entry;
    18         unsigned long           expires;
    19         void                    (*function)(unsigned long);
    20         unsigned long           data;
    ...
    31 };
**4.2 设置环形缓冲区**
内核使用packet_setsockopt()函数处理数据包套接字的选项设置操作。当使用PACKET_VERSION套接字选项时，内核就会将po->tp_version参数的值设置为对应的值。
在这之后，内核会使用PACKET_RX_RING套接字选项，创建一个用于数据包接收的环形缓冲区。内核使用packet_set_ring()函数完成这一过程。这个函数做了很多工作，因此我只是摘抄其中比较重要的那部分代码。首先，packet_set_ring()函数会对给定的环形缓冲区参数执行一系列完整性检查操作，如下所示：
    4202                 err = -EINVAL;
    4203                 if (unlikely((int)req->tp_block_size tp_block_size)))
    4206                         goto out;
    4207                 if (po->tp_version >= TPACKET_V3 &&
    4208                     (int)(req->tp_block_size -    4209                           BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) tp_frame_size tp_hdrlen +
    4212                                         po->tp_reserve))
    4213                         goto out;
    4214                 if (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))
    4215                         goto out;
    4216 
    4217                 rb->frames_per_block = req->tp_block_size / req->tp_frame_size;
    4218                 if (unlikely(rb->frames_per_block == 0))
    4219                         goto out;
    4220                 if (unlikely((rb->frames_per_block * req->tp_block_nr) !=
    4221                                         req->tp_frame_nr))
    4222                         goto out;
之后，函数会分配环形缓冲区的内存块空间：
    4224                 err = -ENOMEM;
    4225                 order = get_order(req->tp_block_size);
    4226                 pg_vec = alloc_pg_vec(req, order);
    4227                 if (unlikely(!pg_vec))
    4228                         goto out;
我们应该注意到，alloc_pg_vec()函数使用了内核页分配器来分配内存块（我们会在漏洞利用中使用这个方法）：
    4104 static char *alloc_one_pg_vec_page(unsigned long order)
    4105 {
    ...
    4110         buffer = (char *) __get_free_pages(gfp_flags, order);
    4111         if (buffer)
    4112                 return buffer;
    ...
    4127 }
    4128 
    4129 static struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)
    4130 {