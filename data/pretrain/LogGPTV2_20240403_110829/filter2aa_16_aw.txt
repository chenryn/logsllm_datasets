if (flags.is_extern == 0 && flags.is_static == 0)
...
用于对 is_extern 和 is_static 位进行测试。 字段的所有属性几乎都同具体的实现有关。字段是否能覆盖字边界由具体的实现定义。
字段可以不命名，无名字段(只有一个冒号和宽度)起填充作用。特殊宽度   0   可以用来强制
在下一个字边界上对齐。
某些机器上字段的分配是从字的左端至右端进行的，而某些机器上则相反。这意味着， 尽管字段对维护内部定义的数据结构很有用，但在选择外部定义数据的情况下，必须仔细考 虑哪端优先的问题。依赖于这些因素的程序是不可移植的。字段也可以仅仅声明为 int，为 了方便移植，需要显式声明该 int 类型是 signed 还是 unsigned 类型。字段不是数组，并 且没有地址，因此对它们不能使用&运算符。
第7章 输入与输出
输入/输出功能并不是 C 语言本身的组成部分，所以到目前为止，我们并没有过多地强 调它们。但是，程序与环境之间的交互比我们在前面部分中描述的情况要复杂很多，本章将 讲述标准库，介绍一些输入/输出函数、字符串处理函数、存储管理函数与数学函数，以及 其它一些 C 语言程序的功能。本章讨论的重点将放在输入/输出上。
ANSI 标准精确地定义了这些库函数，所以，在任何可以使用 C 语言的系统中都有这些函 数的兼容形式。如果程序的系统交互部分仅仅使用了标准库提供的功能，则可以不经修改地 从一个系统移植到另一个系统中。
这些库函数的属性分别在十多个头文件中声明，前面已经遇到过一部分，如、
和。我们不打算把整个标准库都罗列于此，因为我们更关心如何使
用标准库编写 C 语言程序。附录 B 对标准库进行了详细的描述。
7.1 标准输入/输出
我们在第 1 章中讲过，标准库实现了简单的文本输入/输出模式。文本流由一系列行组 成，每一行的结尾是一个换行符。如果系统没有遵循这种模式，则标准库将通过一些措施使 得该系统适应这种模式。例如，标准库可以在输入端将回车符和换行符都转换为换行符，而 在输出端进行反向转换。
最简单的输入机制是使用 getchar 函数从标准输入中(一般为键盘)一次读取一个字符:
int getchar(void)
getchar 函数在每次被调用时返回下一个输入字符。若遇到文件结尾，则返回 EOF。符号常 量 EOF 在头文件中定义，其值一般为•1，但程序中应该使用 EOF 来测试文件是否 结束，这样才能保证程序同 EOF 的特定值无关。
在许多环境中，可以使用符号输出文件名"的格式将输出重定向到某个文件中。例如， 如果程序 prog 调用了函数 putchar，那么命令行
prog > 输出文件名
将把程序 prog 的输出从标准输出设备重定向到文件中。如果系统支持管道，那么命令行
prog | anotherprog
将把程序 prog 的输出从标准输出通过管道重定向到程序 anotherprog 的标准输入中。 函数 printf 也向标准输出设备上输出数据。我们在程序中可以交叉调用函数 putchar
和 printf，输出将按照函数调用的先后顺序依次产生。
使用输入/输出库函数的每个源程序文件必须在引用这些函数之前包含下列语句
#include 
当文件名用一对尖括号括起来时，预处理器将在由具体实现定义的有关位置中查找指定 的文件(例如，在 UNIX 系统中，文件一般放在目录/usr/include 中)。
许多程序只从一个输入流中读取数据，并且只向一个输出流中输出数据。对于这样的程 序，只需要使用函数 getchar、putchar 和 printf 实现输入/输出即可，并且对程序来 说已经足够了。特别是，如果通过重定向将一个程序的输出连接到另一个程序的输入，仅仅 使用这些函数就足够了。例如，考虑下列程序  lower，它用于将输入转换为小写字母的形式:
#include 
#include 
main() /* lower: convert input to lower case*/
{
int c
while ((c = getchar()) != EOF) putchar(tolower(c));
return 0;
}
函数 tolower 在头文件中定义，它把大写字母转换为小写形式，并把其它 字符原样返回。我们在前面提到过，头文件中的 getchar 和 putchar"函数” 以及中的    tolower"函数"一般都是宏，这样就避免了对每个字符都进行函数调 用的开销。我们将在 8.5 节介绍它们的实现方法。无论中的函数在给定的机器上 是如何实现的，使用这些函数的程序都不必了解字符集的知识。
练习 7•1             编写一个程序，根据它自身被调用时存放在 argv[0]中的名字，实现将大 写字母转换为小写字母或将小写字母转换为大写字母的功能。
7.2 格式化输出——printf 函数
输出函数 printf 将内部数值转换为字符的形式。前面的有关章节中已经使用过该函数。
下面只讲述该函数最典型的用法，附录 B 中给出了该函数完整的描述。
int printf(char *format, arg1, arg2, ...);
函数 printf 在输出格式 format 的控制下，将其参数进行转换与格式化，并在标准输出设 备上打印出来。它的返回值为打印的字符数。
格式字符串包含两种类型的对象:普通字符和转换说明。在输出时，普通字符将原样不 动地复制到输出流中，而转换说明并不直接输出到输出流中，而是用于控制 printf 中参数 的转换和打印，每个转换说明都由一个百分号字符(即%)开始，并以一个转换字符结束。在 字符%和转换字符中间可能依次包含下列组成部分:
             负号，用于指定被转换的参数按照左对齐的形式输出。
             数，用于指定最小字段宽度。转换后的参数将打印不小于最小字段宽度的字段。如 果有必要，字段左边(如果使用左对齐的方式，则为右边)多余的字符位置用空格
填充以保证最小字段宽。
             小数点，用于将字段宽度和精度分开。
             数，用于指定精度，即指定字符串中要打印的最大字符数、浮点数小数点后的位数、 整型最少输出的数字数目。
             字母 h 或 l，字母 h 表不将整数作为 short 类型打印，字母 l 表示将整数作为 long
类型打印。
表 7•1 列出了所有的转换字符，如果%后面的字符不是一个转换说明，则该行为是未定义 的。
表 7•1   printf 函数基本的转换说明
 字符              参数类型:输出形式
d
,
i             
 int 类型;十进制数
o
 int 类型;无符号八进制数(没有前导 0)
x
,
X             
 int 类型;无符号十六进制数(没有前导 0x 或 0X)，1015 分别用 abcdef 或 ABCDEF 表示
u
 int 类型;无符号十进制数
c
 int 类型;单个字符
s
 char *类型;顺序打印字符串中的字符，直到遇到'\0'或已打印了由精度指定的字符数为止 
f             
 double 类型;十进制小数[•]m.dddddd，其中 d 的个数由精度指定(默认值为 6)
e
,
E             
 double 类型;[•]m.dddddd e ±xx 或[•]m.dddddd E ±xx，其中 d 的个数由精度指定(默认值为 6)
g
,
G             
 double 类型;如果指数小于•4 或大于等于精度，则用%e 或%E 格式输出，否则用%f 格式输出。尾部的 0 和 小数点不打印
p
 void *类型;指针(取决于具体实现)
%
 不转换参数;打印一个百分号%
在转换说明中，宽度或精度可以用星号*表示，这时，宽度或精度的值通过转换下一参数 (必须为 int 类型)来计算。例如，为了从字符串 s 中打印最多 max 个字符，可以使用下列 语句:
printf("%.*s", max, s);
前面的章节中已经介绍过大部分的格式转换，但没有介绍与字符串相关的精度。下表说 明了在打印字符串"hello, world"(12 个字符)时根据不同的转换说明产生的不同结果。 我们在每个字段的左边和右边加上冒号，这样可以清晰地表示出字段的宽度。
:%s:              :hello, world:
:%10s:              :hello, world:
:%.10s:              :hello, wor:
:%•10s:              :hello, world:
:%.15s:              :hello, world:
:%•15s:              :hello, world              :
:%15.10s:              :              hello, wor:
:%•15.10s:              :hello, wor              :
注意:函数 printf 使用第一个参数判断后面参数的个数及类型。如果参数的个数不够 或者类型错误，则将得到错误的结果。请注意下面两个函数调用之间的区别:
printf(s);              /* FAILS if s contains % */ printf("%s", s);                            /* SAFE */
函数 sprintf 执行的转换和函数 printf 相同，但它将输出保存到一个字符串中:
int sprintf(char *string, char *format, arg1, arg2, ...); sprintf 函数和 printf 函数一样，按照 format 格式格式化参数序列 arg1、arg2、 ，
但它将输出结果存放到 string 中，而不是输出到标准输出中。当然，string 必须足够大以
存放输出结果。
练习 7•2 编写一个程序，以合理的方式打印任何输入。该程序至少能够根据用户的习 惯以八进制或十六进制打印非图形字符，并截断长文本行。
7.3 变长参数表
本节以实现函数 printf 的一个最简单版本为例，介绍如何以可移植的方式编写可处理 变长参数表的函数。因为我们的重点在于参数的处理，所以，函数 minprintf 只处理格式字 符串和参数，格式转换则通过调用函数 printf 实现。
函数 printf 的正确声明形式为:
int printf(char *fmt, ...)
其中，省略号表示参数表中参数的数量和类型是可变的。省略号只能出现在参数表的尾部。 因为 minprintf 函数不需要像 printf 函数一样返回实际输出的字符数，因此，我们将它 声明为下列形式:
void minprintf(char *fmt, ...)
编写函数 minprintf 的关键在于如何处理一个甚至连名字都没有的参数表。标准头文件
/* minprintf: minimal printf with variable argument list */ void minprintf(char *fmt, ...)
{
va_list ap; /* points to each unnamed arg in turn */ char *p, *sval;
int ival; double dval;
va_start(ap, fmt); /* make ap point to 1st unnamed arg */ for (p = fmt; *p; p++) {
if (*p != '%') { putchar(*p); continue;
}
switch (*++p) { case 'd':
ival = va_arg(ap, int); printf("%d", ival); break;
case 'f':
dval = va_arg(ap, double); printf("%f", dval);
break; case 's':
for (sval = va_arg(ap, char *); *sval; sval++) putchar(*sval);
break; default: