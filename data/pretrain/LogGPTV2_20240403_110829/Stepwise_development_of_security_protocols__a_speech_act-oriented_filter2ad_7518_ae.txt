The eﬀect of sending a request of type keyconﬁrm is
the same as the eﬀect of sending out a requests of type
newkey:
Ef f ect(+S) ≡ GNA,ρ(n)
Before receiving a request act of type keyconﬁrm, re-
ceiver B should know that K is indeed a secret common
key between A and B generated by C. Hence
P re(−S) ≡ KnowB,τ Key(K, A, B, C)
Because B knows that K is a secret common key be-
tween A and B, when B gets a request of type keycon-
ﬁrm, B knows that A has been informed about K as a
fresh session key between A and B. Hence
Ef f ect(−S) ≡ KnowB,τ Inf ormedA,ρ(K, A, B, C) ∧
HNB,τ (n)
A.2 Reply Acts
Let S be a reply act form as deﬁned in the main text.
• Let the type of S be newkey and the content of S be
Key(K,B,C,A) or νK.Key(K, B, C, A).
For A to send B a key in a reply act, A must have
been requested by B to do so before.
If K has not
been generated,
the content of S has the form
νK.Key(K, B, C, A) then the precondition simply re-
quires that A has obtained the Reply-To nonce n be-
fore:
i.e.
P re(+S) ≡ HNA,ρ(n)
The eﬀects of sending out such act is that A has freshly
generated key K as a session key between B and C.
Hence
Ef f ect(+S) ≡ GKA,ρ(K, B, C)
In contrast, if K has been generated, i.e. the content of
S has the form Key(K, B, C, A) then the preconditions
states also that A must have generated the key K before
sending the act:
P re(+S) ≡ GKA,ρ(K, B, C) ∧ HNA,ρ(n)
In this case, A does not gain any new information or
knowledge after sending out such act:
Ef f ect(+S) ≡ T rue
A receiver of a reply act would receive it only if it has
requested for such a act before. Hence the precondi-
tions for B to act as a receiver in a reply act S of type
newkey is
P re(−S) ≡ GNB,τ (n)
The eﬀects for B after receiving S is that B knows K
is a fresh key between B and C generated by A, and B
also knows that A has received nonce n. Hence
Ef f ect(−S) ≡ KnowB,τ GKA,ρ(K, B, C) ∧
KnowB,τ HNA,ρ(n)
• Let the type of S be keyconﬁrm and the content of S
be Key(K,A,B,C)
The preconditions for A to send out S is that A knows
that K is a fresh session key between A and B generated
by C and A has received nonce n before:
P re(+S) ≡ KnowA,ρKey(K, A, B, C) ∧ HNA,ρ(n)
A, as the sender in S, does not gain any new information
after sending S. Hence:
Ef f ect(+S) ≡ T rue
The preconditions for B to receive S is that B must
have requested for it before, i.e. B has generated the
nonce n and B must be informed about K. Hence
P re(−S) ≡ GNB,τ (n) ∧ Inf ormedB,τ (K, A, B, C)
After receiving S, B knows that K is indeed a fresh
session key between A and B generated by C and B
also knows that A also knows it.
Ef f ect(−S) ≡ KnowB,τ KnowA,ρKey(K, A, B, C) ∧
KnowB,τ HNA,ρ(n)
A.3 Inform Acts
Let S be a inform act form as deﬁned in the main text.
• Let the type of S be newkey and the content of S be
νK.Key(K, B, C, A) or Key(K,B,X,Y) where (X,Y) =
(A,C) or (C,A). If K has not been generated, i.e. the
content of S has the form νK.Key(K, B, C, A) then A
does not need any speciﬁc information to be able to
send the act:
P re(+S) ≡ T rue
The eﬀect for A as the sender in this case is:
Ef f ect(+S) ≡ GKA,ρ(K, B, C)
In contrast, if the key has been generated before the act,
i.e. the content of the act is of the form Key(K,B,X,Y)
where (X,Y) = (A,C) or (C,A) , then A must have
known about K before sending out the act as we assume
that regular principals honest and hence would inform
others only about what they know:
P re(+S) ≡ KnowA,ρKey(K, B, X, Y )
In this case, A does not gain any new information after
sending B the inform act. Hence
Ef f ect(+S) ≡ T rue
There is no preconditions for B to receive S. Hence
P re(−S) ≡ T rue
After receiving S, B is informed about key K. Hence
Ef f ect(−S) ≡ Inf ormedB,τ (K, B, X, Y )
• Let the type of S be keyconﬁrm and its content be
Key(K,A,B,C). For A to be able to conﬁrm to B that
K is generated by C as a fresh session key between A
and B, A should know that K is indeed generated by C
as a fresh session key between A and B. Hence
P re(+S) ≡ KnowA,ρKey(K, A, B, C)
The sender of an inform act of any type obviously does
not gain any information after sending the act.
Ef f ect(+S) ≡ T rue
The preconditions for B to receive an inform act of type
keyconﬁrm is that B knows that K is indeed generated
by C as a fresh session key between A and B. Hence
after receiving the act, B knows also that A knows that
K is generated by C as a fresh session key between A
and B. Hence
P re(−S) ≡ KnowB,τ Key(K, A, B, C)
Ef f ect(−S) ≡ KnowB,τ KnowA,ρKey(K, A, B, C)
B. OTWAY-REES PROTOCOL
(1)A → B : M, A, B,{Na, M, A, B}KAS
(2)B → S : M, A, B,{Na, M, A, B}KAS ,{Nb, M, A, B}KBS
(3)S → B : M,{Na, KAB}KAS ,{Nb, KAB}KBS
(4)B → A : M,{Na, KAB}KAS
C. APPENDIX C
Given that the connection topology allows direct com-
munication only between initiators and servers as well as
between initiators and responders, the abstract speech act
oriented protocol in example ?? is implemented by the fol-
lowing message exchanging protocol:
(1) A → S : req, newkey, A, Init, S, Server, Na, B
(2) S → A : {rep, newkey, S, Server, A, Init, Na, K, B}KAS
(3.1) S → A : {inf, newkey, S, Server, B, Resp, K, B, A, S}KBS
(3.2) A → B : {inf, newkey, S, Server, B, Resp, K, B, A, S}KBS
(4) B → A : {req, keyconf irm, B, Resp, A, Init, Nb, Hash(K), S}KA
(5) A → B : {rep, keyconf irm, A, Init, B, Resp, Nb}KB
(6) B → A : {inf, keyconf irm, B, Resp, A, Init, S}K
Steps (2) and (3.1) could be combined by letting S sending
both mS2 , mS3 to A in one step resulting in:
(1) A → S : req, newkey, A, Init, S, Server, Na, B
(2’) S → A : {rep, newkey, S, Server, A, Init, Na, K, B}KAS ,
{inf, newkey, S, Server, B, Resp, K, B, A, S}KBS
(3’) A → B : {inf, newkey, S, Server, B, Resp, K, B, A, S}KBS
(4) B → A : {req, keyconf irm, B, Resp, A, Init, Nb, Hash(K), S}KA
(5) A → B : {rep, keyconf irm, A, Init, B, Resp, Nb}KB
(6) B → A : {inf, keyconf irm, B, Resp, A, Init, S}K
D. APPENDIX D
of → ∪ ⇒.
For each bundle B, deﬁne ≺B to be the transitive closure
Theorem 3. (Soundness Theorem)
1. If (cid:5) F then |= F
2. If (cid:5) AP.R[F ] then |= AP.R[F ]
Proof(Sketch) The full proof is more than 15 pages long.
We hence will give only a sketch of it here.
1. Let (cid:5) F . By induction on the structure of a derivation
of F wrt the axioms and proof rules of ProtoLog.
(a) Base case: F is an axiom of ProtoLog. It is obvious
|= F holds for F ∈ {A1 − A6, A8 − A10} or
that
F is an axiom of the S5 system. It remains to show
|= F for F ∈ {A7, A11, A12}.
that
(cid:1)
i. Let F = A11. Assume the contrary. There-
fore there exists a historical bundle B and regu-
lar principal identiﬁers A,B,C,D such that B |=
Inf ormedA,ρ(K, B, C, D) and A (cid:6)∈ {B, C, D}.
Hence there is a recent regular strand s ∈ B
of A in role ρ and a node N in s such that N
implements a sending or receiving event of an
inform or reply act and K is associated with
B,C,D at N. Let S be the speech act imple-
mented by N. K is associated with B,C,D in S.
From the structure of the speech acts, it follows
that A ∈ {B, C, D}. Contradiction.
ii. Let F = A12. Let B be a historical bundle
such that B |= Key(K, A, B, C). It is enough
to prove the following two assertions:
1) For each recent regular strand s ∈ B, for
each node N of s, if K occurs in the speech act
S represented by term(N) then K is associated
with A,B,C in S .
Proof: Let Ω be the set of all nodes N’ in B
) (cid:5) Key(K, A, B, C). It is
such that Ef f ect(N
clear that Ω is not empty. Let N be a minimal
node in Ω wrt (cid:15)B. By case analysis, we can
prove that N implements a sending event of an
reply or inform act of type newkey and K is
generated at N. Let Σ be the set of regular
nodes N’ in B in which K occurs in the speech
act represented by N’. We prove by induction
wrt to the restriction of (cid:15)B on Σ that K is a
key associated with A,B,C at all nodes in Σ.
The assertion hence follows.
2) B (cid:6)|= Access(P E, K).
Proof: Assume the contrary. Applying the
above assertion and analyzing the structure of
the representations of speech acts, we will get
a contradiction.
iii. Let F = A7. Let B be a historical bundle
such that B |= KnowA,ρKey(K, B, C, D) for
regular principal identiﬁers A,B,C,D. It is not
diﬃcult to see that A ∈ {B, C, D} for oth-
erwise we could show that for the bundle B0
consisting of those strands in B that are ei-
ther a strand of A or precede a strand of A,
B0 |= KnowA,ρKey(K, B, C, D) and K does
not appear in B0. Contradiction to the prop-
erty that B0 |= Key(K, B, C, D).
Suppose now that B (cid:6)|= Inf ormedA,ρ(K, B, C, D).
It follows from the deﬁnition of the relation |=,
that for each strand s of A in B, if K occurs in
diﬀerent. Construct a historical bundle B of AP from IS(R)
by 1) adding r to IS(R) and 2) connect the receiving nodes
in r with the corresponding sending nodes in IS(R) and 3)
assign the past status to all strands in IS(R), and the re-
cent status to r. It is obvious that B (cid:6)|= Key(K, B, C, D)].
Contradiction. The theorem is proved.
s then K occurs in a sending or receiving event
of a request act. Hence K occurs in the sending
or receiving event of a request act of type key-
conﬁrm. Let N be a node implementing such a
event and N be the ﬁrst node on its strand con-
taining K. Because N represents a sending or
receiving event of a request act of type keycon-
ﬁrm, and the protocol is well-designed, there
must be a node M preceding N on the same
strand also containing K. Contradiction.
(b) Inductive case: We only need to show that if |= F ,
then |= KnowA,ρF for all regular principal iden-
tiﬁer A and ρ. This assertion follows immediately
from the deﬁnition of model semantics.
2. After having proved assertion (1), we only need to show
the validity of the propagation, consequence and initi-
ation rules wrt the model semantics. The validity of
the consequence and initiation rules wrt the model se-
mantics follows immediately from the deﬁnition of the
model semantics. The validity of the propagation rule
is proved by analyzing the structure of Eﬀect(E). The
proof is long (more than 10 pages) and tedious. We
refer the readers to the full paper ( not listed in the
reference to keep the paper anonymous).
E. APPENDIX E
(cid:1)
(cid:1)
(cid:1)
(cid:1)
Let T be a preﬁx of the ρ-track APρ of AP such that R
is a ground instance of T. Let θ be the most general uniﬁer
between T and R. Let θ
be a ground substitution over the
variables appearing in AP such that θ, θ
coincide for the
variables appearing in T and θ
assigns distinct constants to
distinct variables not in T. Let B denote a historical bundle
of AP satisfying following properties:
1) There is no penetrator node in B
2) There is no past bundle in B
3) For each role ρ that appears in AP, there is exactly a
strand in B implementing APρθ
(cid:1)
4) For each strand s in B there is exactly a role ρ that
appears in AP such that s implements APρθ
The existence of B is obvious. Let s be the strand in B
that implements R. Let B(cid:1)
denote the bundle obtained from
B by removing all nodes that do not precede a node in s.
B(cid:1)
is called the ideal scenario of R, denoted by IS(R). It is
easy to see that IS(R) is a historical bundle of AP.
Theorem(Limited Completeness Theorem)
|= AP.R[KnowA,ρKey(K, B, C, D)]
then (cid:5) AP.R[KnowA,ρKey(K, B, C, D)]
Proof:
Assume the contrary that |= AP.R[KnowA,ρKey(K, B, C, D)]
holds but (cid:5) AP.R[KnowA,ρKey(K, B, C, D)] does not hold.
There are three possible cases: 1) K does not appear in R,
or 2) K appears in R but is not associated with B,C,D, or 3)
K appears in R and is associated with B,C,D. Suppose that
the ﬁrst two cases happen. Then it is clear that IS(R) (cid:6)|=
Key(K, B, C, D), contradiction. Therefore it holds that K
appears in R and is associated with B,C,D. From
(cid:6)(cid:5) AP.R[KnowA,ρKey(K, B, C, D)], it is not diﬃcult to see
that 1) all receiving events in R are receiving events of inform
or request acts of type newkey, and 2) all sending events in
R are sending events of request acts. Let s be the strand in
IS(R) that implements R. Let r be a new strand that is ex-
actly like s with the exception that their nonces if exist are
If