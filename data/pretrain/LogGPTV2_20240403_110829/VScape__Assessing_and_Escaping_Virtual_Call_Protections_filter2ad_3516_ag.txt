[17] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie, A. Grier,
P. Wagle, Q. Zhang, and H. Hinton, “Stackguard: Automatic adaptive
detection and prevention of buffer-overﬂow attacks.” in SECURITY,
1998.
[18] C. Lattner and V. Adve, “Llvm: A compilation framework for lifelong
program analysis & transformation.” in International Symposium on
Code Generation and Optimization, 2004. CGO 2004.
IEEE, 2004,
pp. 75–86.
[19] F. Wang and Y. Shoshitaishvili, “Angr-the next generation of binary
IEEE,
analysis.” in 2017 IEEE Cybersecurity Development (SecDev).
2017, pp. 8–9.
[20] C. Zhang, C. Song, K. Z. Chen, Z. Chen, and D. Song, “Vtint: Protect-
ing virtual function tables’ integrity.” in NDSS, 2015.
[21] M. Castro, M. Costa, and T. Harris, “Securing software by enforcing
data-ﬂow integrity,” in Proceedings of the 7th symposium on Operat-
ing systems design and implementation, 2006, pp. 147–160.
[22] C. Song, B. Lee, K. Lu, W. Harris, T. Kim, and W. Lee, “Enforcing
kernel security invariants with data ﬂow integrity.” in NDSS, 2016.
[23] A. Pawlowski, V. van der Veen, D. Andriesse, E. van der Kouwe,
T. Holz, C. Giuffrida, and H. Bos, “Vps: excavating high-level c++
constructs from low-level binaries to protect dynamic dispatching,”
in Proceedings of the 35th Annual Computer Security Applications
Conference. ACM, Dec 2019, p. 97–112. [Online]. Available:
https://dl.acm.org/doi/10.1145/3359789.3359797
[24] N. Burow, D. McKee, S. A. Carr, and M. Payer, “Cﬁxx: Object
type integrity for c++ virtual dispatch.” in Prof. of ISOC Network &
Distributed System Security Symposium (NDSS). https://hexhive. epﬂ.
ch/publications/ﬁles/18NDSS. pdf, 2018.
[25] V. Van Der Veen, E. Göktas, M. Contag, A. Pawoloski, X. Chen,
S. Rawat, H. Bos, T. Holz, E. Athanasopoulos, and C. Giuffrida,
“A tough call: Mitigating advanced code-reuse attacks at the binary
level.” in 2016 IEEE Symposium on Security and Privacy (SP).
IEEE,
2016, pp. 934–953.
[26] A. Prakash, X. Hu, and H. Yin, “vfguard: Strict protection for virtual
function calls in cots c++ binaries.” in NDSS, 2015.
[27] N. Carlini, A. Barresi, M. Payer, D. Wagner, and T. R. Gross, “Control-
ﬂow bending: On the effectiveness of control-ﬂow integrity,” in 24th
USENIX Security Symposium (USENIX Security 15), 2015, pp. 161–
176.
[28] M. Conti, S. Crane, L. Davi, M. Franz, P. Larsen, M. Negro,
C. Liebchen, M. Qunaibit, and A.-R. Sadeghi, “Losing control: On the
effectiveness of control-ﬂow integrity under stack attacks.” in Proceed-
ings of the 22nd ACM SIGSAC Conference on Computer and Commu-
nications Security. ACM, 2015, pp. 952–963.
[29] S. Andersen and V. Abella, “Data Execution Prevention: Changes
to Functionality in Microsoft Windows XP Service Pack 2, Part
3: Memory Protection Technologies.” http://technet.microsoft.com/
en-us/library/bb457155.aspx, 2004.
[30] A. Sotirov, “Heap feng shui in javascript.” Black Hat Europe, 2007.
[31] O. Oleksenko, D. Kuvaiskii, P. Bhatotia, P. Felber, and C. Fetzer, “In-
tel mpx explained: A cross-layer analysis of the intel mpx system
stack.” Proceedings of the ACM on Measurement and Analysis of Com-
puting Systems, vol. 2, no. 2, pp. 1–30, 2018.
[32] Y. Li, M. Wang, C. Zhang, X. Chen, S. Yang, and Y. Liu, “Finding
cracks in shields: On the security of control ﬂow integrity mecha-
nisms.” in Proceedings of the 2020 ACM SIGSAC Conference on Com-
puter and Communications Security. ACM, 2020.
1732    30th USENIX Security Symposium
USENIX Association
[33] B. Maxwell, D. Thompson, G. Amerson, and L. Johnson, “Analysis
of crc methods and potential data integrity exploits.” in International
Conference on Emerging Technologies, 2003, pp. 25–26.
[34] K. K. Ispoglou, B. AlBassam, T. Jaeger, and M. Payer, “Block oriented
programming: Automating data-only attacks.” in Proceedings of the
2018 ACM SIGSAC Conference on Computer and Communications
Security. ACM, 2018, pp. 1868–1882.
[35] K. Serebryany and M. Böhme, “Aﬂgo: Directing aﬂ to reach speciﬁc
target locations.” 2017.
[36] J. Vanegue, “The automated exploitation grand challenge.” in pre-
sented at H2HC Conference, 2013.
[37] Y. Chen and X. Xing, “Slake: Facilitating slab manipulation for ex-
ploiting vulnerabilities in the linux kernel.” in Proceedings of the 2019
ACM SIGSAC Conference on Computer and Communications Secu-
rity. ACM, 2019, pp. 1707–1722.
[38] S. Heelan, T. Melham, and D. Kroening, “Automatic heap layout
manipulation for exploitation.” in 27th USENIX Security Symposium
(USENIX Security 18), 2018, pp. 763–779.
[39] “Firefox Browser.” https://www.mozilla.org/, 2020.
[40] “The Chromium Projects.” https://www.chromium.org/, 2020.
[41] “Opencascade .” https://github.com/tpaviot/oce, 2019.
[42] “Bento4 | Fast, Modern Tools and C++ Class Library.” https://github.
com/axiomatic-systems/Bento4, 2020.
[43] “ImageMagick.” https://www.imagemagick.org/, 2020.
[44] “Exif, IPTC & XMP metadata and ICC Proﬁle.” https://www.exiv2.
org/, 2020.
[45] “Open Source Computer Vision Library.” https://opencv.org/, 2020.
[46] “Ofﬁcial mirror of the qt-project.org qt.” https://github.com/qt, 2020.
[47] “A GRaphical Universal Modeler.” https://agrum.gitlab.io/, 2020.
[48] “Open Source/Free Software cross-platform network engine.” https:
//github.com/SLikeSoft/SLikeNet, 2020.
[49] “Bitcoin-Open source P2P money.” https://bitcoin.org/en/, 2020.
[50] “ZNC-An advanced IRC bouncer.” https://github.com/znc/znc, 2020.
[51] “MongoDB,” https://github.com/mongodb/mongo, 2020.
[52] “Open Babel:
The Open Source Chemistry Toolbox.” http://
openbabel.org/wiki/Main_Page, 2020.
[53] “Clang: a C language family frontend for LLVM.” https://clang.llvm.
org/, 2005.
[54] “The LLVM Compiler Infrastructure.” https://llvm.org/, 2000.
[55] “Valgrind Home.” https://valgrind.org/, 2020.
[56] M. Namolaru, “Devirtualization in gcc.” in Proceedings of the GCC
Developers’Summit. Citeseer, 2006, pp. 125–133.
[57] “Intel memory protection extensions.” 2018.
[Online]. Avail-
able: https://software.intel.com/content/www/us/en/develop/articles/
introduction-to-intel-memory-protection-extensions.html
[58] “Processor Tracing.” https://software.intel.com/en-us/blogs/2013/09/
18/processor-tracing, 2013.
[59] R. M. Yoo, C. J. Hughes, K. Lai, and R. Rajwar, “Performance eval-
uation of intel® transactional synchronization extensions for high-
performance computing,” in Proceedings of the International Confer-
ence on High Performance Computing, Networking, Storage and Anal-
ysis, 2013, pp. 1–11.
[60] B. Niu and G. Tan, “Modular control-ﬂow integrity.” in ACM SIG-
PLAN Notices, vol. 49, no. 6. ACM, 2014, pp. 577–587.
[61] ——, “Per-input control-ﬂow integrity,” in Proceedings of the 22nd
ACM SIGSAC Conference on Computer and Communications Secu-
rity. ACM, 2015, pp. 914–926.
[62] M. Khandaker, A. Naser, W. Liu, Z. Wang, Y. Zhou, and Y. Cheng,
“Adaptive call-site sensitive control ﬂow integrity,” in 2019 IEEE Eu-
ropean Symposium on Security and Privacy (EuroS&P).
IEEE, 2019,
pp. 95–110.
[63] “Pin - a dynamic binary instrumentation tool.” 2018. [Online]. Avail-
able: https://software.intel.com/content/www/us/en/develop/articles/
pin-a-dynamic-binary-instrumentation-tool.html
[64] D. Jang, Z. Tatlock, and S. Lerner, “Safedispatch: Securing c++ vir-
tual calls from memory corruption attacks.” in NDSS, 2014.
[65] M. Payer, A. Barresi, and T. R. Gross, “Fine-grained control-ﬂow
integrity through binary hardening,” in International Conference on
Detection of Intrusions and Malware, and Vulnerability Assessment.
Springer, 2015, pp. 144–164.
[66] “Reproduction of SafeDispatch.” https://github.com/kongxiao0532/
safedispatch-reproduce, 2020.
[67] “Benchmark
used
for
against
//github.com/cooplus-vscape/CFIbenchmark, 2021.
the COOP
LUS
testing CFI
attack.”
solutions’effectiveness
https://github.com/https:
[68] “Buffer Overﬂow in python socket packet.” https://bugs.python.org/
issue20246, 2014.
[69] “Mozilla Firefox Audio Driver Out of Bounds.” https://bugzilla.
mozilla.org/show_bug.cgi?id=1446062, 2018.
[70] “jemalloc: A general purpose malloc(3) implementation.” 2017.
[Online]. Available: https://github.com/jemalloc/jemalloc
[71] “Mozilla
Garbage
Avail-
https://developer.mozilla.org/en-US/docs/Mozilla/Projects/
collection.”
[Online].
2005.
able:
SpiderMonkey/Internals/Garbage_collection
[72] E. Goktas, E. Athanasopoulos, H. Bos, and G. Portokalidis, “Out
of control: Overcoming control-ﬂow integrity.” in 2014 IEEE
Symposium on Security and Privacy.
IEEE, pp. 575–589. [Online].
Available: http://ieeexplore.ieee.org/document/6956588/
[73] E. Gökta¸s, E. Athanasopoulos, M. Polychronakis, H. Bos, and G. Por-
tokalidis, “Size does matter: Why using gadget-chain length to pre-
vent code-reuse attacks is hard.” in 23rd USENIX Security Symposium
(USENIX Security 14), 2014, pp. 417–432.
[74] N. Carlini and D. Wagner, “Rop is still dangerous: Breaking mod-
ern defenses.” in 23rd USENIX Security Symposium (USENIX Secu-
rity 14), 2014, pp. 385–399.
[75] I. Evans, F. Long, U. Otgonbaatar, H. Shrobe, M. Rinard, H. Okhravi,
and S. Sidiroglou-Douskos, “Control jujutsu: On the weaknesses
of ﬁne-grained control ﬂow integrity.” in Proceedings of
the
22nd ACM SIGSAC Conference on Computer and Communications
Security - CCS ’15. ACM Press, pp. 901–913. [Online]. Available:
http://dl.acm.org/citation.cfm?doid=2810103.2813646
[76] D. Brumley, P. Poosankam, D. Song, and J. Zheng, “Automatic patch-
based exploit generation is possible: Techniques and implications.” in
2008 IEEE Symposium on Security and Privacy (sp 2008).
IEEE,
2008, pp. 143–157.
[77] T. Bao, R. Wang, Y. Shoshitaishvili, and D. Brumley, “Your exploit is
mine: Automatic shellcode transplant for remote exploits,” in IEEE
Symposium on Security and Privacy (Oakland).
IEEE, May 2017,
p. 824–839. [Online]. Available: http://ieeexplore.ieee.org/document/
7958612/
[78] D. Repel, J. Kinder, and L. Cavallaro, “Modular synthesis of
heap exploits.” ACM Press, 2017, p. 25–35. [Online]. Available:
http://dl.acm.org/citation.cfm?doid=3139337.3139346
[79] B. Garmany, M. Stoffel, R. Gawlik, P. Koppe, T. Blazytko, and
T. Holz, “Towards automated generation of exploitation primitives for
web browsers,” in Proceedings of the 34th Annual Computer Security
Applications Conference. ACM, Dec 2018, p. 300–312. [Online].
Available: https://dl.acm.org/doi/10.1145/3274694.3274723
USENIX Association
30th USENIX Security Symposium    1733
[80] W. Wu, Y. Chen, J. Xu, X. Xing, X. Gong, and W. Zou, “Fuze: To-
wards facilitating exploit generation for kernel use-after-free vulnera-
bilities.” in 27th USENIX Security Symposium (USENIX Security 18),
2018, pp. 781–797.
[81] I. Yun, D. Kapil,
and T. Kim,
to
systematically discover new heap exploitation primitives,” in 29th
USENIX Security Symposium (USENIX Security 20). USENIX
Association, Aug. 2020, pp. 1111–1128. [Online]. Available: https:
//www.usenix.org/conference/usenixsecurity20/presentation/yun
“Automatic techniques
[82] F. Deng, J. Wang, B. Zhang, C. Feng, Z. Jiang, and Y. Su, “A pattern-
based software testing framework for exploitability evaluation of meta-
data corruption vulnerabilities,” Scientiﬁc Programming, vol. 2020,
2020.
[83] Z. Zhao, Y. Wang, and X. Gong, “Haepg: An automatic multi-hop
exploitation generation framework,” in International Conference on
Detection of Intrusions and Malware, and Vulnerability Assessment.
Springer, 2020, pp. 89–109.
[84] H. Hu, Z. L. Chua, S. Adrian, P. Saxena, and Z. Liang, “Automatic
generation of data-oriented exploits.” in 24th USENIX Security Sym-
posium (USENIX Security 15), 2015, pp. 177–192.
[85] H. Hu, S. Shinde, S. Adrian, Z. L. Chua, P. Saxena, and Z. Liang,
“Data-oriented programming: On the expressiveness of non-control
data attacks.” in 2016 IEEE Symposium on Security and Privacy (SP).
IEEE, 2016, pp. 969–986.
[86] “Pymalloc: A Specialized Object Allocator.” https://docs.python.org/
2.3/whatsnew/section-pymalloc.html, 2002.
[87] “The gnu c library (glibc).” 2019, online: accessed 26-Feb-2019.
[Online]. Available: https://www.gnu.org/software/libc/
[88] Y. Chen and X. Xing, “A systematic study of elastic objects in kernel
exploitation.” in Proceedings of the 2020 ACM SIGSAC Conference
on Computer and Communications Security. ACM, 2020.
A Appendix
Due to the page limit, we present the case study of PyQt,
the sketch of the exploit for Firefox, the benchmark code
protected by CFI but bypassed by COOPLUS, and the detail
of how VScape performs capability analysis for primitives.
A.1 Case Study of PyQt-5.12
CPython itself has no virtual calls for COOPLUS since it
is a program fully developed with C language. But with
binding libraries, Python can easily use APIs compiled into
shared libraries. PyQt is a widely used library in Python
GUI programming, which is developed with C++. Cooper-
ating with a publicly documented heap overﬂow vulnerabil-
ity CVE-2014-1912 [68], we evaluate COOPLUS attack for
AAR and AAW as we do for Firefox.
Figure 10: COOPLUS exploit primitives in PyQt. 1 vulner-
able object: socket character buffer 2 victim object: QWid-
getPrivate 3 relay object: item list of pyListObject.
Like Firefox, Python implements an independent allocator
named Pymalloc [86] to manage user-controlled Pyobjects.
But when the size of the Pyobject exceeds a threshold value
(512 bytes on 64 bit systems), the native allocator will take
it over. In Linux, CPython utilizes ptmalloc [87] to manage
the native heap. Comparing with jemalloc, ptmalloc makes
the heap layout extremely casual without strict isolation.
Ampliﬁcation Strategy. CVE-2014-1912 [68] is a typical
heap overﬂow vulnerability. Attackers can write arbitrary
value directly into out-of-bound areas. And the number of
bytes corrupted is enough for our experiment. When the size
of the bytearray is 512 bytes, the three key objects could be
placed closely. In this case, VTables of the victim and the
counterfeit object are placed near to each other, we don’t
have to guess the base address of the Qt library. A partial
overwrite is enough to make the hijacking.
The vulnerable object is a character buffer in the native
heap. Thus, the victim object in primitive and the relay ob-
ject should be maintained in the native heap too. And there
are no other size requirements for objects in this case.
The strategy we used on Firefox still works well in this
case. We ﬁnd the data ﬁeld of pyListObject in CPython is
an ideal relay object. According to our observation, when
the items of a pyListObject exceed 64, the item table will
be allocated into the native heap. We select primitives that
can tamper with Hi Address of pointers in the relay object
with boolean values, redirect the pointer to a non-mapping
address, conterﬁet a pyString object, and set the size of string
0x7ff..f (set a large value for the size of string). As a result,
we can leak memory of a wide range. Then we attain the
base address of library array.cpython, and fake a bytearray
object for AAR and AAW.
Primitive in Exploit. The same as what we do in the
case of ﬁrefox, we list two rules (1) the offset of victim
member variable offset mod 8 > 1 and (2) the primitive
should have gadgets of ST-OW-nonPtr. Finally, the primi-
tive tuple (QWidgetPrivate::endBackingStorePainting(),
QWidgetPrivate, QOpenGLWidgetPrivate) is selected
for a byte ﬂipping in this case.
there is no
constraints
The only
for control ﬂow this
thing that the counterfeit function QOpenGLWidgetPri-
vate::endBackingStorePainting() does is to set the byte at
the offset +490 in the counterfeit object to zero. Since the