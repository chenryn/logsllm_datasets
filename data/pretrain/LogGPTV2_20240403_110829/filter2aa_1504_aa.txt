java-安全编码规范-1.0.1
java-安全编码规范-1.0.1
编写依据与参考文件：
1.《信息安全技术 应用软件安全编程指南》（国标 GBT38674-2020）
2.《国家电网公司网络和信息安全反违章措施-安全编码二十条》（信通技术〔2014〕117
号）
3.《国家电网公司应用软件系统通用安全要求》（企标 Q_GDW 1597-2015）
4.《Common Weakness Enumeration》 - 国际通用计算机软件缺陷字典
5.《OWASP Top 10 2017》 - 2017年十大Web 应用程序安全风险
6.《fortify - 代码审计规则》
7.《java开发手册》（阿里巴巴出品）
第一条 设计开发必须符合公司架构设计及安全防护方案
项目程序的设计开发必须在公司的SG-EA架构设计指导下开展，在开发实施过程中必须严格遵
循安全防护方案中的相关安全措施。
第二条 上线代码必须进行严格的安全测试并进行软著备案
所有系统上线前代码应进行严格的安全自测及第三方安全测试，并进行软件著作权备案，确保
上线代码与测试代码的一致。
第三条 严格限制帐号访问权限
账号权限设置应基于帐号角色赋予其相应权限，并遵循“权限最小化、独立”原则，应确保账号
权限分离、不交叉、不可变更。
第四条 提供完备的安全审计功能
必须提供必备的安全审计功能，对系统的帐号权限操作做到在线监控、违规告警和事后审计，
并具备防误操作、防篡改及备份机制，确保用户操作轨迹可定位可追溯。
第五条 采取有效措施保证认证安全
认证模块应符合公司网络与信息系统安全管理办法中对帐号口令强度要求，并包含防暴力破解
机制；同时重要外网业务系统如具备手机绑定功能需对绑定信息进行认证，以避免恶意绑定，
造成用户敏感信息泄露。
第六条 保证代码简洁、注释明确
应使用结构化的编程语言，避免使用递归和Go to声明，同时应去除程序冗余功能代码。
第七条 使用安全函数及接口
在程序中禁止采用被证实有缺陷的不安全函数或接口，并需要检查数据长度及缓冲区边界。
第八条 必须验证所有外部输入
必须对所有外部输入进行验证，包括用户的业务数据输入，及其它来自于外部程序接口之间的
数据输入，并对输入信息中的特殊字符进行安全检测和过滤。
第十条 避免内存溢出
在对缓存区填充数据时应进行边界检查，必须判断是否超出分配的空间。
HTTP参数污染
不受信任的Content-Type请求头
不受信任的HOST请求头
不受信任的查询字符串
不受信任的HTTP请求头
不受信任的http请求头Referer
不受信任的http请求头User-Agent
Cookie中的潜在敏感数据
不受信任的命令注入
不安全的反序列化
配置全局反序列化白名单
jackson编码示例
fastjson编码示例
服务器端请求伪造
正则表达式DOS（ReDOS）
XML外部实体（XXE）攻击
XStream安全编码规范
XPath注入
EL表达式代码注入
未经验证的重定向
Spring未验证的重定向
不安全的对象绑定
针对js脚本引擎的代码注入
JavaBeans属性注入
跨站脚本攻击（XSS）
第九条 必须过滤上传文件
必须检查上传文件的类型、名称等，并使用正则表达式等对文件名做严格的检查，限定文件名
只能包括字母和数字，同时限制文件的操作权限，并对文件的访问路径进行验证。
潜在的路径遍历（读取文件）
潜在的路径遍历（写入文件）
第十一条 确保多线程编程的安全性
确保在多线程编程中正确的访问共享变量，避免多个线程同时修改一个共享变量。
竞争条件
第十二条 设计错误、异常处理机制
应设计并建立防止系统死锁的机制及异常情况的处理和恢复机制，避免程序崩溃。
第十三条 数据库操作使用参数化请求方式
对需要使用SQL语句进行的数据库操作，必须通过构造参数化的SQL语句来准确的向数据库指
出哪些应该被当作数据，避免通过构造包含特殊字符的SQL语句进行SQL注入等攻击。
SQL注入
Mybatis安全编码规范
LDAP注入
第十四条 禁止在源代码中写入口令、服务器IP等敏感信息
应将加密后的口令、服务器IP、加密密钥等敏感信息存储在配置文件、数据库或者其它外部数
据源中，禁止将此类敏感信息存储在代码中。
硬编码密码
硬编码密钥
第十五条 为所有敏感信息采用加密传输
为所有要求身份验证的访问内容和所有其他的敏感信息提供加密传输。
接受任何证书的TrustManager
接受任何签名证书的HostnameVerifier
第十六条 使用可信的密码算法
如果应用程序需要加密、数字签名、密钥交换或者安全散列，应使用国密算法。
禁止使用弱加密
可预测的伪随机数生成器
错误的十六进制串联
第十七条 禁止在日志、话单、cookie等文件中记录口令、银行账号、通信内容等敏感数据
应用程序应该避免将用户的输入直接记入日志、话单、cookie等文件，同时对需要记入的数据
进行校验和访问控制。
不受信任的会话Cookie值
日志伪造
HTTP响应截断
第十八条 禁止高风险的服务及协议
禁止使用不加保护或已被证明存在安全漏洞的服务和通信协议传输数据及文件。
DefaultHttpClient与TLS 1.2不兼容
不安全的HTTP动词
第十九条 避免异常信息泄漏
去除与程序无关的调试语句；对返回客户端的提示信息进行统一格式化，禁止用户ID、网络、
应用程序以及服务器环境的细节等重要敏感信息的泄漏。
意外的属性泄露
不安全的 SpringBoot Actuator 暴露
不安全的 Swagger 暴露
第二十条 严格会话管理
应用程序中应通过限制会话的最大空闲时间及最大持续时间来增加应用程序的安全性和稳定
性，并保证会话的序列号长度不低于64位。
缺少HttpOnly标志的Cookie
缺少Spring CSRF保护
不安全的CORS策略
不安全的永久性Cookie
不安全的广播（Android）
编写依据与参考文件：
1.《信息安全技术 应用软件安全编程指南》（国标 GBT38674-
2020）
2.《国家电网公司网络和信息安全反违章措施-安全编码二十条》（信
通技术〔2014〕117号）
3.《国家电网公司应用软件系统通用安全要求》（企标 Q_GDW
1597-2015）
4.《Common Weakness Enumeration》 - 国际通用计算机软件缺
陷字典
5.《OWASP Top 10 2017》 - 2017年十大Web 应用程序安全风险
6.《fortify - 代码审计规则》
7.《java开发手册》（阿里巴巴出品）
第一条 设计开发必须符合公司架构设计及安
全防护方案
项目程序的设计开发必须在公司的SG-EA架构设计指导下
开展，在开发实施过程中必须严格遵循安全防护方案中的
相关安全措施。
管理类要求：
所有项目必须参照《概要设计》编写《安全防护方案》，在两者都评审通过后才能启动编码工作。
第二条 上线代码必须进行严格的安全测试并
进行软著备案
所有系统上线前代码应进行严格的安全自测及第三方安全
测试，并进行软件著作权备案，确保上线代码与测试代码
的一致。
管理类要求：
所有项目必须完成安全自测和第三方安全测试，并完成软著相关工作才能上线运行，上线运行版本
必须与测试通过版本一致。
第三条 严格限制帐号访问权限
账号权限设置应基于帐号角色赋予其相应权限，并遵循“权
限最小化、独立”原则，应确保账号权限分离、不交叉、不
可变更。
架构设计类要求：
系统禁止不同角色之间可以跨角色访问其他角色的功能，公共功能除外。
例如：某互斥业务名为发票打印涉及三个子菜单，专属于角色“会计”。角色“会计”可以看到发票打印
相关的三个子菜单并正常操作，角色“出纳”无法看到三个子菜单并无法访问该三个子菜单中对应的
后端接口，如果“出纳”可以访问或操作“会计”的专有功能则应判定为越权。
用户访问无权限的菜单url或者接口url，后台的HTTP响应码禁止等于200并且HTTP的响应包body内
容必须返回“无权限”。
电力系统禁止存在“记住密码”的功能。
第四条 提供完备的安全审计功能
必须提供必备的安全审计功能，对系统的帐号权限操作做
到在线监控、违规告警和事后审计，并具备防误操作、防
篡改及备份机制，确保用户操作轨迹可定位可追溯。
架构设计类要求：
用户在系统中只要在页面中存在点击、输入、拖拽等操作行为，日志记录中就应对应操作行为产生
日志，一条日志所包含的字段应包括：事件的日期（年月日）、时间（时分秒）、事件类型（系统
级、业务级二选一）、登录ID、姓名、IP地址、事件描述（用户主体对什么客体执行了什么操作？
该操作的增删改查的内容又是什么？）、事件结果（成功、失败）
第五条 采取有效措施保证认证安全
认证模块应符合公司网络与信息系统安全管理办法中对帐
号口令强度要求，并包含防暴力破解机制；同时重要外网
业务系统如具备手机绑定功能需对绑定信息进行认证，以
避免恶意绑定，造成用户敏感信息泄露。
架构设计类要求：
如果用户连续登录失败，应将该用户锁定，禁止其登陆。
外网系统用户登录时，应使用短信进行二次验证可以保证用户登录的安全性。
用户登录失败时，应提示“用户名或密码错误”，禁止提示“用户名不存在”或“登录密码错误”。
用户登录时，必须使用合规的加密方案加密传输用户的登录名和密码。
第六条 保证代码简洁、注释明确
应使用结构化的编程语言，避免使用递归和Go to声明，同
时应去除程序冗余功能代码。
架构设计类要求：
代码中禁止出现 goto 语句。
应保持代码审计工作，应禁止使用递归并及时去除程序中冗余的功能代码。
第七条 使用安全函数及接口
在程序中禁止采用被证实有缺陷的不安全函数或接口，并
需要检查数据长度及缓冲区边界。
第八条 必须验证所有外部输入
合规的双向加密数据的传输方案： 
   1）后端生成非对称算法（国密SM2、RSA2048）的公钥B1、私钥B2，前端访问后端获取公钥B1。公钥、私钥可以全系统固定为一对，前端
   2）前端每次发送请求前，随机生成对称算法（国密SM4、AES256）的密钥A1。 
   3）前端用步骤2的密钥A1加密所有业务数据生成encrypt_data，用步骤1获取的公钥B1加密密钥A1生成encrypt_key。 
   4）前端用哈希算法对encrypt_data + encrypt_key的值形成一个校验值check_hash。 
   5）前端将encrypt_data、encrypt_key、check_hash三个参数包装在同一个http数据包中发送到后端。 
   6）后端获取三个参数后先判断哈希值check_hash是否匹配encrypt_data + encrypt_key以验证完整性。 
   7）后端用私钥B2解密encrypt_key获取本次请求的对称算法的密钥A1。 
   8）后端使用步骤7获取的密钥A1解密encrypt_data获取实际业务数据。 
   9）后端处理完业务逻辑后，将需要返回的信息使用密钥A1进行加密后回传给前端。 
  10）加密数据回传给前端后，前端使用A1对加密的数据进行解密获得返回的信息。 
  11）步骤2随机生成的密钥A1已经使用完毕，前端应将其销毁。 
必须对所有外部输入进行验证，包括用户的业务数据输
入，及其它来自于外部程序接口之间的数据输入，并对输
入信息中的特殊字符进行安全检测和过滤。
第十条 避免内存溢出
在对缓存区填充数据时应进行边界检查，必须判断是否超
出分配的空间。
第七条、第八条、第十条 编码类要求：
HTTP参数污染
如果应用程序未正确校验用户输入的数据，则恶意用户可能会破坏应用程序的逻辑以执行针对客户端或
服务器端的攻击。
脆弱代码1：
// 攻击者可以提交 lang 的内容为： 
// en&user_id=1# 
// 这将使攻击者可以随意篡改 user_id 的值 
String lang = request.getParameter("lang"); 
GetMethod get = new GetMethod("http://www.host.com"); 
// 攻击者提交 lang=en&user_id=1#&user_id=123 可覆盖原始 user_id 的值 
get.setQueryString("lang=" + lang + "&user_id=" + user_id); 
get.execute(); 
解决方案1：
// 参数化绑定 
URIBuilder uriBuilder = new URIBuilder("http://www.host.com/viewDetails"); 
uriBuilder.addParameter("lang", input); 
uriBuilder.addParameter("user_id", userId); 
HttpGet httpget = new HttpGet(uriBuilder.build().toString()); 
脆弱逻辑2：
订单系统计算订单的价格 
步骤1: 
订单总价 = 商品1单价 * 商品1数量 + 商品2单价 * 商品2数量 + ... 
步骤2: 
钱包余额 = 钱包金额 - 订单总价 
当攻击者将商品数量都篡改为负数，导致步骤1的订单总价为负数。而负负得正，攻击者不仅买入了商品并且钱包金额也增长了。 
解决方案2：
应在后台严格校验订单中每一个输入参数的长度、格式、逻辑、特殊字符以及用户的权限。 
整体解决方案：
系统应按照长度、格式、逻辑以及特殊字符4个维度对每一个输入参数进行安全校验，然后再将其
传递给敏感的API。
原则上数据库主键不能使用自增纯数字，应使用uuid或雪花算法作为数据库表主键以保证唯一性和
不可预测性。
身份信息应使用当前请求的用户session或token安全的获取，而不是直接采用用户提交的身份信
息。
安全获取用户身份后，应对请求的数据资源进行逻辑判断，防止用户操作无权限的数据资源。
不受信任的Content-Type请求头
HTTP请求头Content-Type可以由恶意的攻击者控制。因此，HTTP的Content-Type值不应在任何重要的
逻辑流程中使用。
不受信任的HOST请求头
GET /testpage HTTP/1.1 
Host: www.example.com 
ServletRequest.getServerName() 和 HttpServletRequest.getHeader("Host") 具有相同的逻辑，即提取
Host 请求头。但是恶意的攻击者可以伪造 Host 请求头。
因此，HTTP的Host值不应在任何重要的逻辑流程中使用。
不受信任的查询字符串
查询字符串是GET参数名称和值的串联，可以传入非预期参数。
例如URL请求  /app/servlet.htm?a=1&b=2  对应查询字符串提取为  a=1&b=2 
那么  HttpServletRequest.getParameter() HttpServletRequest.getQueryString()  获取的值都可能是不
安全的。
解决方案：
查询字符串只能用以页面渲染时使用，不应将查询字符串关联任何业务请求。