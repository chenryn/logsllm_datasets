âˆ™ KeyGen(msk, id) takes as input the master secret msk
and an identity id âˆˆ ID of a user, and outputs a secret
key ğ‘ ğ‘˜id and some public information ğ‘id for id. It also
updates the public directory pd to include ğ‘id.3
âˆ™ Enc(pk,â„›, ğ‘š) takes as input the public key pk, a set
â„› of cardinality â‰¤ ğ‘Ÿ which contains the ğ‘id of each
revoked user in pd, and a plaintext message ğ‘š âˆˆ â„³.
It outputs a ciphertext ğ¶ âˆˆ ğ’.
âˆ™ Dec(skid, ğ¶) takes as input a secret key skid of a user
with identity id and a ciphertext ğ¶ âˆˆ ğ’. It outputs a
plaintext ğ‘š âˆˆ â„³.
âˆ™ Trace(pd,â„›,ğ’®,ğ’ªğ’Ÿ) is a black-box confirmation tracing
algorithm that takes as input the public directory pd,
a set â„› of â‰¤ ğ‘Ÿ revoked users, a set ğ’® of â‰¤ ğ‘¡ suspect
2In [32], a weaker notion of usefulness is considered (leading to a better
security guarantee): the box is considered useful if it distinguishes
between encryptions of two adversarially chosen plaintexts. We note
that our security proof actually handles this weaker usefulness. In fact,
we show in Lemma 3.2 that the notion of usefulness given here implies
that it is possible to efficiently find two plaintexts whose ciphertext
distributions can be distinguished by the decryption box. The rest of
the security proof carries over in an identical way for both usefulness
notions.
3We emphasize that ğ‘id does not need to contain id.
users, and has black-box access to the pirate decoder ğ’Ÿ
through the oracle ğ’ªğ’Ÿ. It outputs an identity id or âŠ¥.
The correctness requirement is that, with overwhelming
probability over the randomness used by the algorithms, we
have:
âˆ€ğ‘š âˆˆ â„³,âˆ€id âˆˆ ID : Dec(skid, Enc(pk,â„›, ğ‘š)) = ğ‘š,
for any set â„› of â‰¤ ğ‘Ÿ revoked users and for any id such that
id /âˆˆ â„›.
Public Traceability. It is required that, when ğ’® contains
the set ğ’¯ of traitors who produced the pirate decoder ğ’Ÿ, then
the id output by the tracing algorithm belongs to ğ’¯ . This
requirement is formalized using the following game, denoted
by AD-TT, between an adversary ğ’œ and a challenger:
âˆ™ The challenger runs Setup(1ğœ†, 1ğ‘¡, 1ğ‘Ÿ) and gives pk to
ğ’œ.
âˆ™ Adversary ğ’œ may ask the challenger to add polyno-
mially many users in the system. Adversary ğ’œ may
choose the idâ€™s of the users, but does not obtain the
corresponding skid. Nevertheless, the public directory
pd is updated accordingly.
âˆ™ Adversary ğ’œ is allowed to make up to ğ‘¡ arbitrary traitor
key queries. It may observe the database pd to choose
its queries in an adaptive way. If it queries id âˆˆ ID to
the challenger, then:
âˆ’ If the key for id was previously generated, i.e., if ğ‘id
is found in the database pd, then the challenger re-
sponds with skid. The challenger records the identity
query id in a list ğ’¯ .
âˆ’ Otherwise (i.e., user id is a new user in the system),
the challenger runs KeyGen(msk, id), responds with
skid and updates the directory pd with the public
information ğ‘id for id. The challenger also records
the identity query id in the list ğ’¯ .
âˆ™ Adversary ğ’œ is allowed to (adaptively) choose a set â„›
of up to ğ‘Ÿ revoked users in pd. The challenger gives
ğ’œ all the corresponding skid. These queries can be
interleaved with extensions of the number of users and
user corruption queries, in an adaptive manner.
âˆ™ Adversary ğ’œ finally produces a pirate decoder ğ’Ÿ. It
chooses a suspect set ğ’® of cardinality â‰¤ ğ‘¡ that con-
tains ğ’¯ , and sends ğ’® to the challenger.
âˆ™ The challenger then runs Trace(pd,â„›,ğ’®,ğ’ªğ’Ÿ). The ad-
versary wins if both of the following hold:
âˆ’ Equation (1) is satisfied for the set of revoked users â„›
chosen by the adversary (i.e., decoder ğ’Ÿ is useful),
âˆ’ the execution of Trace outputs âŠ¥ or outputs an id
that does not belong to ğ’¯ with probability â‰¥ 1/ğœ†ğ‘.
No probabilistic polynomial-time adversary ğ’œ should be able
to win game AD-TT with non-negligible probability.
Almost Public Traceability. This is the same as public
traceability, except that Trace only outputs the associated
information about the traitors instead of their identities,
namely ğ‘id instead of id. Consequently, the second winning
condition of the adversary should be adapted so that it only
Session K1:  Secure ComputationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA2281requires the execution of Trace to output a ğ‘id that does not
belong to pdğ’¯ , which is the set of all ğ‘idâ€² for idâ€² âˆˆ ğ’¯ .
This restriction does not change much the functionality of
the tracing because, from ğ‘id, the authority can immediately
map back to id and the authority can still delegate the tracing
procedure to untrusted parties. On the other side, this variant
may be useful in practice as we do not leak the information
of users in the public directory.
We note that our proposed schemes satisfy the public
traceability instead of the almost public traceability. However,
it is easy to modify them so that they satisfy the latter.
Hereafter, we will not discuss about almost public traceability.
Traitor Tracing Scheme. A traitor tracing scheme is simply
a trace-and-revoke scheme without the capacity of revoking
users. It corresponds to the above definition where the revoked
set is always set to be empty, in the encryption as well as in
the security game.
Semantic Security. The IND-CPA security of a trace-and-
revoke scheme ğ’¯ â„› is defined based on the following game.
âˆ™ The challenger runs Setup(1ğœ†, 1ğ‘¡, 1ğ‘Ÿ) and gives the pro-
duced public key pk to the adversary ğ’œ. The adversary
may ask the challenger to add polynomially many users
in the system.
âˆ™ The adversary (adaptively) chooses a set â„› of â‰¤ ğ‘Ÿ
revoked users in pd. The challenger gives ğ’œ all the skid
such that ğ‘id âˆˆ â„›.
âˆ™ The adversary then chooses two messages ğ‘š0, ğ‘š1 âˆˆ â„³
âˆ™ The challenger samples ğ‘ â†Ë’ {0, 1} and provides ğ¶ğ‘šğ‘ â†Ë’
âˆ™ Finally, the adversary returns its guess ğ‘â€² âˆˆ {0, 1} for
the ğ‘ chosen by the challenger. The adversary wins this
game if ğ‘ = ğ‘â€².
of equal length and gives them to the challenger.
Enc(pk,â„›, ğ‘šğ‘) to ğ’œ.
The advantage of the adversary is defined as AdvIND-CPA
ğ’¯ â„›,ğ’œ =
| Pr[ğ‘ = ğ‘â€²]âˆ’ 1/2|. The scheme ğ’¯ â„› is said semantically secure
if there is no probabilistic polynomial-time adversary ğ’œ that
wins this game with non-negligible advantage.
2.2 Inner Product Functional Encryption
In this section, we define functional encryption for the func-
tionality of inner products over Zğ‘.
Definition 2.2. A functional encryption scheme â„±â„° for
the inner product functionality over Zğ‘ is a tuple â„±â„° =
(â„±â„°.Setup, â„±â„°.KeyGen,â„±â„°.Enc,â„±â„°.Dec) of four probabilis-
tic polynomial-time algorithms with the following specifica-
tions:
âˆ™ â„±â„°.Setup(1ğœ†, 1â„“) takes as input the security parameter
ğœ† and outputs the public key and the master secret
key pair (pk, msk);
âˆ™ â„±â„°.KeyGen(msk, x) takes as input the master secret
key msk and a vector x âˆˆ Zâ„“
ğ‘ and outputs the secret
key skx;
âˆ™ â„±â„°.Enc(pk, y) takes as input the public key pk and a
message y âˆˆ Zâ„“
ğ‘ and outputs the ciphertext cty;
âˆ™ â„±â„°.Dec(skx, cty) takes as input the secret key of a user
skx and the ciphertext cty, and outputs an element
from Zğ‘ âˆª {âŠ¥}.
The correctness requirement is that, with overwhelming prob-
ability over the randomness used by the algorithms, for
(pk, msk) â†Ë’ â„±â„°.Setup(1ğœ†, 1â„“) and âˆ€x, y âˆˆ Zâ„“
ğ‘:
â„±â„°.Dec (â„±â„°.KeyGen(msk, x),â„±â„°.Enc(pk, y)) = âŸ¨x, yâŸ© mod ğ‘.
Security of â„±â„°. We consider security of functional encryp-
tion in the standard indistinguishability setting [10].
Definition 2.3. A functional encryption scheme â„±â„° =
(â„±â„°.Setup, â„±â„°.KeyGen,â„±â„°.Enc,â„±â„°.Dec) provides semantic
security under chosen-plaintext attacks (or IND-CPA secu-
rity) if no probabilistic polynomial-time adversary ğ’œ has
non-negligible advantage in the following game:
âˆ™ The challenger runs â„±â„°.Setup(1ğœ†, 1â„“) and the master
public key mpk is given to ğ’œ.
âˆ™ The adversary adaptively makes secret key queries to
the challenger. At each query, adversary ğ’œ chooses a
vector x âˆˆ Zâ„“
ğ‘ and obtains the corresponding secret key
skx â†Ë’ â„±â„°.KeyGen(msk, x).
âˆ™ Adversary ğ’œ chooses distinct messages y0, y1 âˆˆ Zâ„“
ğ‘
subject to the restriction that, for every vector x
queried in the previous step, it holds that âŸ¨x, y0âŸ© =
âŸ¨x, y1âŸ© mod ğ‘ and sends them to the challenger. In re-
sponse, the challenger samples ğ‘ â†Ë’ {0, 1} and sends
ctâ‹† â†Ë’ â„±â„°.Enc(pk, yğ‘) to ğ’œ.
âˆ™ Adversary ğ’œ makes further secret key queries for ar-
bitrary vectors x âˆˆ Zâ„“
ğ‘ of its choice. As before, it is
required that âŸ¨x, y0âŸ© = âŸ¨x, y1âŸ© mod ğ‘ for each query x
made by ğ’œ.
âˆ™ Adversary ğ’œ eventually outputs a bit ğ‘â€² âˆˆ {0, 1} and
wins if ğ‘â€² = ğ‘.
The adversaryâ€™s advantage is defined as Advğ’œ(ğœ†) := | Pr[ğ‘â€² =
ğ‘] âˆ’ 1/2|.
The Random-Key Bounded-Collusion Model. In bounded
collusion functional encryption [18], the adversary ğ’œ is re-
stricted to ask at most ğ‘„ secret key queries for some fixed
polynomial ğ‘„, which is input to the setup algorithm. Addi-
tionally, our application permits an additional weakening of
the security model for inner product functional encryption:
we are only required to show security against an adversary
who first sees arbitrarily many random vectors x â†Ë’ Zâ„“
ğ‘, re-
quests secret keys for an adaptively chose subset of them, and
does not make secret key queries after it gets the challenge
ciphertext. The above definition of security against such a
restricted adversary will be called ğ‘„-IND-CPA.
2.3 Lattice background
A lattice Î› is a (non-zero) discrete subgroup of Rğ‘š. A basis
of Î› is a linearly independent set of vectors whose Z-span is
Î›. We recall that the smoothing parameter of Î› is defined as
exp(âˆ’ğœ‹â€–Ì‚ï¸€bâ€–2/ğœ2) â‰¤ 1 + ğœ€
ğœ‚ğœ€(Î›) = min
ğœ > 0 :
(ï¸
âˆ‘ï¸
Ì‚ï¸€bâˆˆÌ‚ï¸€Î›
)ï¸
,
Session K1:  Secure ComputationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA2282âˆš
where Ì‚ï¸€Î› = {Ì‚ï¸€b âˆˆ SpanR(Î›) : Ì‚ï¸€bğ‘‡ Â· Î› âŠ† Z} refers to the dual
of Î›. Note that if ğœ = â„¦(
ğœ†), we have that there exists
ğœ€ = 2âˆ’Î©(ğœ†) such that ğœ â‰¥ ğœ‚ğœ€(Z).
For a lattice Î› âŠ† Rğ‘š, a vector c âˆˆ Rğ‘š, and an invertible
Î£ âˆˆ Rğ‘šÃ—ğ‘š, we define the Gaussian distribution of parameter
Î›, c, and Î£ by ğ·Î›,Î£,c(b) âˆ¼ ğœŒÎ£,c(b) = exp(âˆ’ğœ‹â€–Î£âˆ’1(b âˆ’
c)â€–2) for all b âˆˆ Î›. When Î£ = ğœIğ‘š, we simply write ğ·Î›,ğœ,c.
Sometimes, for convenience, we use the notation ğ·Î›+c,Î£ as
a shorthand for c + ğ·Î›,Î£,âˆ’c.
For ğ‘š â‰¥ ğ‘› and a rank-ğ‘› matrix X âˆˆ Rğ‘šÃ—ğ‘›, denote ğ‘ˆX =
{â€–Xuâ€– : u âˆˆ Rğ‘›,â€–uâ€– = 1}. The least singular value of
X is then defined as ğ‘ ğ‘›(X) := inf(ğ‘ˆX) and similarly the
largest singular value of X is ğ‘ 1(X) := sup(ğ‘ˆX). For a matrix
Y âˆˆ Rğ‘›â€²Ã—ğ‘šâ€²
with ğ‘›â€² > ğ‘šâ€², the least singular value and the
largest singular value are defined as ğ‘ 1(Y) := ğ‘ 1(Yğ‘¡) and
ğ‘ ğ‘šâ€² (Y) := ğ‘ ğ‘šâ€² (Yğ‘¡) respectively.
For the rest of this section, we assume that lattices are
full-rank, i.e., the dimensions of the span and the ambient
space match.
Lemma 2.4 (Corollary 2.8 in [16]). Let Î›â€² âŠ† Î› âŠ† Rğ‘š
be two lattices with the same dimension. Let ğœ€ âˆˆ (0, 1/2).
Then for any c âˆˆ Rğ‘š and any Î£ such that ğ‘ ğ‘š(Î£) â‰¥ ğœ‚ğœ€(Î›â€²),
the distribution ğ·Î›,Î£,c mod Î›â€² is within statistical distance
2ğœ€ from the uniform distribution over Î›/Î›â€².
âˆš
Lemma 2.5 (Lemma 1 in [21]). Let ğ‘Ÿ â‰¥ â„¦(
ğœ†) and
ğ‘, â„“, ğ‘š > 0 integers. Let b âˆˆ Zğ‘š
ğ‘ be arbitrary and x cho-
sen from ğ·Zğ‘š,ğ‘Ÿ. Then for any V âˆˆ Zâ„“Ã—ğ‘š and positive real
ğ‘Ÿâ€² > ğ‘ 1(V), there exists a probabilistic polynomial-time algo-
rithm ReRand(V, b + x, ğ‘Ÿ, ğ‘Ÿâ€²) that outputs bâ€² = Vb + xâ€² âˆˆ Zâ„“
where xâ€² is within statistical distance 2âˆ’Î©(ğœ†) from ğ·Zâ„“,2ğ‘Ÿğ‘Ÿâ€² .
We use the following variant of the leftover hash lemma,
ğ‘
adapted from [28] (see also Lemma 11 in [4]).
Lemma 2.6 ([28]). Let ğ‘š â‰¥ ğ‘› â‰¥ 1 and ğ‘ = ğ‘ğ‘˜ for ğ‘
prime and ğ‘˜ â‰¥ 1. Take ğ’³ a distribution over Zğ‘š. Let ğ·0
be a uniform distribution over Zğ‘›Ã—ğ‘š
ğ‘ and ğ·1 be the
distribution of (A, A Â· x), where sampling A â†Ë’ Zğ‘›Ã—ğ‘š
and
x â†Ë’ ğ’³ . Then,
Ã— Zğ‘›
ğ‘
ğ‘
â¯â¸â¸â· ğ‘˜âˆ‘ï¸
ğ‘–=1
âˆ†(ğ·0, ğ·1) â‰¤ 1
2
ğ‘ğ‘–Â·ğ‘› Â· Prğ‘–.