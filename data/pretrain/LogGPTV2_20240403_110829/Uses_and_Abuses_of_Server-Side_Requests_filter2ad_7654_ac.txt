to originate from the proxy service, once the URL is detected as malicious, the
proxy itself gets blacklisted. To avoid to disrupt the operations of SSR services,
3 See https://www.blackhat.com/us-15/brieﬁngs.html.
404
G. Pellegrino et al.
Fig. 4. DoS with data amplier
Fig. 5. DoS against data ampliﬁer
we did not test this attack in practice. With reference to our threat model, this
is an attack against S, i.e., risk R4.
Attack 2.2 (DoS with Data Ampliﬁer): In this second scenario, an attacker
can target any Internet-facing service and ﬂood it with HTTP requests. The
general idea is to use an interpreter service as coordinator to amplify number
and size of requests by using data ampliﬁer services via CORs. In order to
bypass SOP for CORs, this attack uses the web origin laundering presented in
Sect. 4.1 whenever the interpreter needs to send a request towards another service
role. Figure 4 shows an example involving the attacker, an interpreter, and an
ampliﬁer service. The attacker (C) submits the URL of the JavaScript program
to the interpreter service (S, step 1). The interpreter fetches and executes a
malicious program (steps 2 and 3) that performs two operations: enlistment
and attack. The enlistment consists in re-submitting the URL of the JavaScript
programs to the interpreter service. This will increase the number of instances
of JavaScript programs participating in the attack. In the attack phase, the
JavaScript code instructs the web service to send many HTTP requests to the
victim (ES). Browsers, such as used by S, can generate about 3,000 requests
per second using the XMLHttpRequest API [21]. One can further increase the
attack impact by using data ampliﬁer services that receive compressed requests
and submit the decompressed data to the victim (step 6). Data ampliﬁers allow
about a 1:1000 ratio between the data sent to the ampliﬁer and the data sent to
the victim [20].
For ethical reasons we did not perform any resource exhaustion DoS attacks.
Instead, we manually veriﬁed that the building blocks of this attack are oﬀered
by the services involved in the attack. More speciﬁcally, we veriﬁed that
(i) interpreters oﬀer the features needed for the attacks (e.g., XMLHttpRequest
API or Image API), (ii) chains and combinations of SSR services can be created,
and (iii) the composition of the services can be invoked by interpreters. With
reference to our threat model, this is an attack against ES, i.e., risk R1.
Attack 2.3 (DoS against Data Ampliﬁer)—A similar setup of Attack 2.2
can also be used to attack the data ampliﬁer, by keeping it busy with decom-
pression tasks (see Fig. 5). In this case, the attack also requires a storage service
to store attacker-controlled compressed data. The interpreter, again controlled
by a malicious program, will request the storage service to fetch the compressed
Uses and Abuses of Server-Side Requests
405
resource from the web server of the attacker (steps 4–6). Then, the storage service
returns an ID of the resource to the interpreter (step 7). Finally, the interpreter
will send many compressed requests to the victim that trigger the victim to
fetch resources from the storage (step 8, 8’, . . . ). The victim is not only forced
to decompress the requests, but it also has to continuously fetch compressed
resources from the storage service and decompress them, easily leading to mem-
ory exhaustion. Similarly for Attack 2.2, we did not perform the attack but we
veriﬁed that the building blocks of this attack are oﬀered by the services involved
in the attack. With reference to our threat model, this is an attack against S,
i.e., risk R4.
4.3 Network Reconnaissance
reconnaissance
is
Fig. 6. Port scanning with probe services
Network
a
previously-known family of attacks
(i.e.,
risk R1) which entails
attacks that gather information
about a network, server, or ser-
vice. We distinguish between port
scanning, host discovery, and
application ﬁngerprinting. Recon-
naissance is the main documented
attack exploiting SSRF [15,24].
While classical attacks require connecting directly to the victim, probe ser-
vices can be used to oﬀer anonymity and even allow access to private networks
across ﬁrewall boundaries. Figure 6 shows this attack with a probe service S.
The attacker prepares a request for S which contains the URL with the host or
service to be scanned. For example, if the attacker would like to probe an SSH
service, she can submit the URL http://target.com:22. As a result, S connects
to the URL (an SSH server) and responds to the attacker, potentially leaking
information about the status of the target service. In our example, S tries to
interpret the response of the target as an HTTP response, and returns the rea-
son for the failure (e.g., reporting that a given SSH server banner is not a valid
HTTP message). If S does not leak information about the target, as we will
show, an attacker can use side channels to determine the state of a TCP port,
the availability of a resource, or the reachability of a host.
4.4 Protocol Bridging Attacks
Protocol bridging is a previously-known family of attacks. The service S often
supports diﬀerent URL schemes, including ftp, gopher, and dict. In particu-
lar, the gopher scheme allows the attacker to send arbitrary data over the TCP
connection, by using the following URL: gopher://target.com:port/payload. If
a service does not properly validate the schemes of user-provided URLs, SSRs
406
G. Pellegrino et al.
can be used to send arbitrary data (i.e., payload) over TCP connections to non-
HTTP network services—eﬀectively acting as a bridge between diﬀerent proto-
cols. In the past, this technique has been used to connect to remote procedure
calls (RPC) services and exploit buﬀer overﬂow vulnerabilities [22], but it could
be used for many other malicious purposes, such as to send spam messages to
an SMTP server. With reference to our threat model, this is an attack against
ES, i.e., risk R1. A variation of this attack involves the file URL scheme to
retrieve ﬁles in S’s ﬁlesystem (e.g., by sending file:///etc/passwd to a bridge
service S). In one incident, such an attack allowed access to system ﬁles (e.g.,
passwd) of Google servers [1]. According to our threat model, this is an attack
against local resources of S, i.e., risk R2.
5 Case Studies and Analysis
Table 2. Mapping between tests and classiﬁca-
tion.
In an attempt to investigate the
prevalence of SSR attacks, we
analyzed 68 services taken from
seven web application classes,
i.e., social networks, business
web applications (e.g., spread-
sheet and calendar web appli-
cations), software development
tools, online image processing,
OpenID service providers, RSS
readers, and online web screen-
shot tools. For each category,
we selected the most popu-
lar web applications prioritized
by Google search ranks. About
60 % of our case studies are among the top 50,000 web sites, including six of the
top 10 web sites on Alexa.
The goal of our analysis is to study real SSR services and map them to our
classiﬁcation. To aid our analysis, we developed g¨unther, a novel open-source
black-box testing tool4 that reveals SSR ﬂaws and service behaviors. g¨unther
takes as input a description of url(reqES), possibly enriched with session data
(i.e., session cookies). Then, g¨unther generates a list of requests to probe the
service. g¨unther consists of a tester and a monitor component. The tester probes
S whereas the monitor dynamically spawns servers to receive SSRs originated
by the service. With reference to Fig. 1a, the tester and the monitor play the
roles of C and S, respectively. The current version of g¨unther supports the
tests in Table 2, i.e., (T1) URL validation and validation bypass via HTTP 3xx
redirection, (T2) proxy behavior, (T3) response header analysis, (T4) HTTP
client analysis, and (T5) side channel analysis. These tests are mapped to ﬂaws
and behaviors as shown in Table 2.
4 The tool is freely available here: https://github.com/tgianko/guenther.
Uses and Abuses of Server-Side Requests
407
We ran g¨unther against the 68 services in our dataset. The experiment results
are shown in Table 3. We anonymized each service in Table 3a by replacing its
domain name with an identiﬁer (column ID) because not all of them have been
ﬁxed. To improve readability, we have grouped services with the same ﬂaws and
behaviors in the same row. Our experiments revealed at least one service for each
ﬂaw and service behavior. In total, 50 out of 68 services suﬀer from one of the
ﬂaws in our classiﬁcation. All these services are either proxy, open origin policy,
probe, or bridge services. One also behaves as an ampliﬁer and four can act as
interpreters and therefore can be abused to coordinate other attacks. Then, ten
services (14.7 %) implement weak forms of URL validation that g¨unther suc-
cessfully bypassed via HTTP 3xx redirections. Finally, only 14 services (20.6 %)
in our experiments are not aﬀected by SSR-based vulnerabilities.
6 Mitigations
After discussing the vast potential and impact of SSRs, we will now discuss
eight mitigations and pitfalls. From our experiments on the case studies, and
reviewing the state of the art on the mitigation side, we extracted a list of
seven mitigations. Finally, as none of the observed ones are suﬃcient to block
Attack 1.2, we propose an additional mitigation to enforce URL-based browser
countermeasures.
(M1) Monitoring—Monitoring is a mitigation technique which aims at detect-
ing suspicious activity at service runtime. The owner of S5 reported to us that
they rely on a sophisticated monitoring technique to detect the SSR abuse tar-
geting C (R3 in Fig. 1c). Unfortunately, the use of monitoring to detect this
type of abuse has two shortcomings which make it insuﬃcient as a general solu-
tion. First, a complex infrastructure and a considerable amount of resources are
required to support monitoring, especially for popular services that serve a large
number of users. Second, while monitoring SSRs may successfully mitigate large-
scale abuses, it is often ineﬀective for detecting low-volume attacks. For example,
the advent of APT-based attacks has changed the distribution from large-scale
to a targeted distribution in which only a single user or organization is attacked.
For these reasons, we believe that monitoring should be complemented with
further preventive guidelines.
(M2) Avoid Acting as a Proxy or Wrap Response—Among our case stud-
ies, three services can be abused as transparent proxy to serve malicious content
to a client. However, we are not aware of intended use cases for transparent
proxies, and thus services should be explicitly designed to avoid this behavior.
For example, S can use a JSON envelope to wrap resES, which prevents a web
browser from interpreting the resource resES and thus blocks the Web Origin
Laundering Attack 1.1. Services S12, S59, and S60 use custom JSON data struc-
tures to wrap resES, i.e., they behaved as non-transparent proxies. However,
this countermeasure alone is not suﬃcient to also block Attack 1.2. As this sec-
ond attack uses malicious JavaScript to retrieve resES, the JavaScript program
408
G. Pellegrino et al.
Table 3. Results of our Experimental Analysis
can unpack resES and then encode it as inline data (i.e., via the data URI
scheme). Attack 1.2 can partially be mitigated by enforcing URL-based browser
countermeasures, such as Google Safe Browsing, at S (see M8).
(M3) Perform Proper URL Validation—S should validate urlES before
fetching the target resource. Table 3b shows how our case studies validate user-
provided URLs. The vast majority accept URLs containing an IP address (60
services) and/or a port number (55 services). None of these behaviors can be
considered a vulnerability per se. Some applications rejected URLs with IP
addresses, probably as an attempt to block attackers who may try to access local
machines in the company intranet. However, it is important to understand that
this countermeasure is often insuﬃcient, as attackers can still address any IP by
pointing an attacker-controlled domain to a local IP address (DNS rebinding).
Uses and Abuses of Server-Side Requests
409
Moreover, we found weak forms of URL validation that can be circumvented.
URL validation of ten services can be bypassed with HTTP redirections (last
column in Table 3b). This is critical, because it shows how the service developers
attempted to mitigate the problem, but were not aware of all the details of this
security threat. Worse, while few of the 68 services accept URLs with the Dict
(four services) or Gopher schemes (three services), redirection helps to bypass
an additional four cases for each scheme. These bridges are a severe threat, as
they give full control of a TCP socket and enable attackers to communicate with
non-HTTP network services.
URL validation that protects against rebinding can be implemented in HTTP
libraries. To the best of our knowledge, SafeCurl [14] is the only HTTP library
that provides these countermeasures for PHP services. Developers using other
programming languages or headless browsers need to implement the above mech-
anisms on their own.
(M4) Content Disposition—The content disposition header is used to sug-
gest that a browser should not display a resource inline [7]. This header has been
proposed in the past to ﬁx Reﬂected File Download attacks [11]. An SSR service
that uses this header can block the Web Origin Laundering Attack 1.1. In fact,
as the resource is not shown to the user inline, phishing attacks are prevented.
In our experiments, services S5 and S9 use the content disposition header. While
Content-Disposition mitigates Attack 1.1, it does not protect from Attack 1.2.
Content-Disposition alone does not solve the root cause of the insuﬃcient secu-
rity policy enforcement ﬂaw, but instead raises the diﬃculty for an attacker to
abuse SSRs. To mitigate Attack 1.2, see M8.
(M5) Limit Resource Usage—DoS attacks of Sect. 4.2 are the result of a
combination of services: interpreters to orchestrate the attack, ampliﬁers to
amplify the size and number of requests, and OOP services to chain SSRs ser-
vices. This mitigation targets the ﬁrst two services (for the OOP services, see
instead M6). Table 3c shows that 10 % of our case studies use browsers with full
JavaScript support, including JavaScript APIs that can be used to orchestrate
DoS attacks. In particular, seven services support the Image API, ﬁve services
support the XMLHttpRequest API, and two services support the Web Worker
API. These APIs can be abused to turn a seemingly innocuous web browser into
a weaponized HTTP-based bot that can generate thousands of HTTP requests