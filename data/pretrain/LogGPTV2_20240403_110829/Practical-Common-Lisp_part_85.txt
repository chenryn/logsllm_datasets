## Page 419
让输出更简洁。)
即受*pretty*影响的两个阶段，然后再将得到的结果插人到PROGN中。（PROGN返回NIL是为了
向量并在*pretty*绑定为指定值的情况下对其应用optimize-static-output和generate-code，
类型的代码，从而避免无用代码的爆炸。首先你定义一个助手函数，它接受由sexp->ops返回的op
但即便找出这点也需要相当多的时间，从而减慢了任何使用嵌套html调用的函数的编译时间。
个版本。如果编译器足够聪明，它最终会意识到其生成的多数代码都是没用的，并将清除它们,
本。而如果这个内嵌的html形式还含有另一个内嵌的html形式，那么你最后将得到该代码的8
里，另一次是在*pretty*为假的分支里。如果每个展开式都生成两个版本，那么你总共有4个版
导致代码量呈指数级增长，因为内嵌的html也将展开两次—一次是在*pretty*为真的分支
一个用在其为假时，那么再把内嵌的html形式也展开成两个版本的话就太傻了。事实上，这将
更复杂的是，html调用经常会含有嵌入的html调用，就像这样：
式和两个版本代码的展开式，一个在*pretty*绑定为真时编译，另一个在它绑定为NIL时编译。
凑输出的代码，具体取决于变量*pretty*在运行期的值。这样，html需要生成一个含有IF表达
中的所有对html宏后续的使用。
*xhtml*的代码包装在EVAL-WHEN中，这样就可以在一个文件里设置它，并让其影响同一个文件
没有什么功能是无法使用已有的语言和特殊操作符来完成的。?
幸运的是，你可以通过生成一个用MACROLET局部重定义html宏的展开式，让其只生成正确
402
① 在底层的语言处理基础设施里，到目前为止，还没有充分地通过特殊操作符暴露出来的一个元素是对缩进的处理。
在我到达html之前，公共API的最后--个元素是另一个宏in-html-style。该宏通过设置
有了这个函数，你随后就可以像下面这样来定义html：
(defun codegen-html (ops pretty)
如果外层的html展开成一个带有两个版本代码的Ir表达式，一个用在*pretty*为真时，另
(html (:ul (dolist (item stuff)) (html (:li item))))
最后让我们来查看html宏本身。实现html的唯一难点是必须生成那种可同时生成美观和紧
(defmacro in-html-style (syntax)
如果你想要令FOO更加灵活（尽管这要以增加其API的复杂度为代价），那么你可以添加用于管理底层缩进打印器
(defmacro html (&whole whole &body body)
的特殊操作符。不过看起来解释额外的特殊操作符的代价将远远超出在语言表达性上获得的微小提升。
(let
(eval-when (:compile-toplevel :load-toplevel :execute)
(((ttu ((sdo 2nd2no-staeas-aztutado) apos-azeiaua6)e' u6oid).
{case syntax
(:xhtml(setf *xhtml* t)))))
第 31章
((*pretty* pretty))
:html
(setf *xhtml* nil))
实践：HTML生成库，编译器部分
www.TopSage.com
---
## Page 420
何查找第三方库，如何优化CommonLisp代码，以及如何交付Lisp应用程序。
的最后一章了。在下一章里我将做个总结，同时简要讨论一些我尚未在本书涉及的主题，包括如
代码。
态生成的页面中，它可以使用来自User-Agent中的信息来让请求生成针对该浏览器的JavaScript
里做不同的事，要么直接根据你想要支持的浏览器来生成不同的代码。然后如果你把FOO用在动
厌的区别。这就是说，FOO生成的JavaScript代码要么可以含有适当的条件代码，在不同的浏览器
的构造，然后再将它们编译成JavaScript。另一个好处是，作为从FOO的S-表达式JavaScript到正
表达式语法以后，你就可以开始编写CommonLisp的宏，为你用来编写客户端代码的语言添加新
添加JavaScript支持可以得到两大好处。一个好处是，在定义出一种可映射到JavaScript语法的S-
将看到定义一种S-表达式语法来表示CSS中的多种结构仍然是可能的。
因为CSS的语法不能像HTML那样简单地映射到S-表达式上。不过，如果你实际查看那些代码，
了CSS输出的代码，它们可在解释器和编译器中与HTML输出集成在一起。这是一个有趣的案例，
层的输出框架来产生其他类型的输出。从本书Web站点上下载的FOO版本中，你将找到一些实现
31.5
html宏生成的工F表达式用来决定实际上应该运行美化打印还是非美化打印的代码。
codegen-html用来使generate-code生成一种或另一种类型的代码。而在运行期，它被顶层
常JavaScript转换的一部分，你可以轻松处理不同浏览器的JavaScript实现中的那些细微但令人讨
的代码。注意变量*pretty*被同时用于宏展开期和结果代码运行期。在宏展开期，它被
中，它将使用每个html的新定义重新处理，一个生成美化打印的代码，另一个生成非美化打印
如果这些事情激发了你的兴趣，那么你应当自行去实现它们，因为这已经是本书实践性内容
一项更具雄心的底层处理是添加对生成嵌入式JavaScript的支持。如果做法得当，那么为FOO
和往常一样，你可以继续研究这些代码，以不同的方式来增强它。一个有趣的方向是使用底
其中的&whole参数代表最初的html形式，而由于它被插入到两个MACROLET主体的展开式
结束语
(macrolet
,whole)))
(let((*html-pretty-printer*(get-pretty-printer)))
(（html
(&bodybody)
www.TopSage.com
(codegen-html
---
## Page 421
是简单地不想把自己捆绑在特定实现上，那么就有点恼人了。
序，那么这可能不是什么大问题。但如果你想要编写可以共享给其他Lisp程序员的代码，或者只
在交付面向最终用户的应用程序，或者正在一台你所控制的服务器上部署基于服务器的应用程
多线程。
源库。但是，即便是那些实现，通常也会支持一些语言标准没有涉及的重要领域，例如网络和
CAPI，用来开发能够运行在任何支持LispWorks的操作系统之上的GUI应用程序。
个卓越的商业Lisp平台LispWorks也提供了几个类似的库，包括广泛使用的可移植的GUI工具箱
析XML、进行SOAP通信、生成HTML、连接关系型数据库以及用多种方式构建图形界面。另一
提供用于其实现的附加库。例如，Franz的AllegroCommon Lisp企业版就自带了一些库，用于解
至少提供了Lisp语言标准里没有指定的一些功能。Common Lisp厂商为证明其价值，尤其倾向于
化语言之外所提供的第三方库。
构造。诸如编写GUI、与数据库进行通信以及解析XML之类的特定任务，都需要用到ANSI标准
32.1
去探索Lisp编程中你最关注的方面。
码，为交付而打包应用程序。
当你用CommonLisp来编写实际的应用程序时，还有两个非常重要的主题尚未讨论：优化Lisp代
如何连接关系型数据库，如何解析XML或是如何编写用作多种网络协议客户端的程序。类似地，
使用与具体实现相关的库的唯一缺点是，它们将你捆绑在了提供这些库的实现上。如果你正
免费和开源的CommonLisp实现通常不包含许多打包的库，而是依赖于可移植的免费和开
要获取一个用来做你想做的事情的库，最简单方式可能就是简单地查看Lisp实现。多数实现
尽管Common Lisp自带的函数、数据类型和宏的标准库规模宏大，但它只提供了通用的编程
显然，我并不打算在这最后的一章里深人讨论所有这些主题，我只想给你一些指点，以便你
对于可移植的库，其可移植性要么来源于它们完全是用标准的Common Lisp写成的，要么是
查找 Lisp 库
结论：下一步是什么
www.TopSage.com
---
## Page 422
复苏的边缘。
实现，McCLIM一
业CommonLisp实现支持它，但并未见其被大量使用。不过在过去的几年里，一种CLIM的开源
(CLIM)。作为SymbolicsLispMachine GUI框架的后裔，CLIM既强大又复杂。尽管事实上许多商
GTK和Tk这类高层次API和工具箱的绑定，这与你在Perl和Python里的工作方式差不多。
是X-Window协议的一个纯Common Lisp的实现，几乎等价于C的xlib库。或者你可以使用几种对
还提供了CAPI，前面提到过，这是一种可移植的GUIAPI。
支持的操作系统。
的情况相似，不存在在开发GUI的单一方法。相反，这项工作依赖于你所使用的发行版和你想要
CommonLisp提供应有的开源及商业库了。
合了多年以后，CommonLisp程序员在过去的几年里也终于开始勇敢地接受挑战，开始为
版的打包工具，即Debian的apt-get和Gentoo的emerge，打包在了一起。
的最佳起始点。
借助Web。虽然说URL变化很快，通常会在打印出来后立即失效，不过可以将下面三个作为当前
因为它们包含了适当的读取期条件化，从而可以工作在多个实现上”，获得它们的最佳途径就是
① Common Lisp的读取期条件化和宏使得开发可移植库成为可能，这些库本身只是为了在不同实现中为语言标准没
或者，如果你在寻找一些完全不同的工具，可以看一下Common LispInterface Manager
在开源领域，你有几种选择。在Unix上，你可以使用CLX来编写底层的X-Window GUI，CLX
商业的Common Lisp实现通常提供了某种方式在它们支持的平台上构建GUI。其中LispWorks
近年非常活跃的一个领域是GUI前端。Common Lisp不像Java和C#，但却跟Perl、Python和C
我在这里不会推荐具体的库，因为这些库的情况日新月异。在对Perl、Python和Java的库集
运行Debian或Gentoo发行版的Linux用户也可以轻松地安装越来越多的Lisp库，这些库与发行
口 Cliki（http://www.cliki.net/）是一个提供用Common Lisp编写的各种免费软件的Wiki站点。
 Common Lisp Open Code Collection (CLOCC)， (http://clocc.sourceforge.net/） 是--个较早
具体实现相关的API上尽可能地消除了对于语言标准的不同解释。
有指定的那些功能提供的API之上提供一个通用的API层。第15章的可移植路径名库就是这类库的一个例子，它在
和多种开源CommonLisp实现。该站点运行所依赖的软件也是用Common Lisp写成的。
尽管与其他任何Wki站点一样，它可能随时发生变化，但它通常可以链接到相当多的库
的免费软件库聚集地，目的是在各个Common Lisp实现之间做到可移植，并试图不依赖于
任何未包含在CLOCC的库。
年半里，注册了将近100个项目。
目的站点，它提供了版本控制、邮件列表以及项目页面的Web服务。在该站点启动后的一
一目前放在Common-Lisp.net上，正在蓬勃地发展，因此也许我们正处于CLIM
www.TopSage.com
32.1查找 Lisp 库
405
---
## Page 423
结构。
的动态特性使其易于编写高性能代码，因为编写高效代码的第一步是要找到正确的算法和数据
的动态本质—这正是当初使Lisp的性能难以达到FORTRAN编译器水平的原因。CommonLisp
相关的一些技术。
的代码。在本节里，我将讨论为什么说Common Lisp是用来编写高性能代码的杰出语言，并介绍
复杂AI系统到编写操作系统等一系列任务中，并且大量的工作被用来找出如何将Lisp编译成高效
即汇编语言和FORTRAN。但那已经是很久以前的事情了。在同一时期，Lisp曾经被用于从创建
岁月里，当计算机还在使用穿孔卡片来编程时，Lisp的高级特性可能确实让其慢于竞争对手，也
得到很高的性能。如果你曾经听到过有关Lisp很慢的传言的话，可能会感到惊奇。在Lisp的早期
化是万恶之源。?Common Lisp是一门杰出的语言，使用它你在拥有充分表达能力的同时还可以
32.3
特性，但它确实提供了一种构建基本CAPI外围Lisp封装的好方法。
FFI代码。UFFI的思路是选取最底层的共同特征，这意味着它无法充分利用不同实现的FFI的所有
实现上的可移植的FFI兼容层。它的工作方式是定义自己的宏，然后展开成其具体实现上的适兰
一些则不允许。Universal Foreign Function Interface（UFFI）项目提供了七八种不同Common Lisp
提供了它们自己的FFI，每种FFI都有稍微不同的功能和语法。某些FFI允许从C向Lisp回调，而另
该函数的Lisp对象转化成C类型，然后再将该函数的返回值转化回Lisp对象。不过，每个实现都
以链接外部代码。因此，如果你打算调用一个来自某C库的函数，就需要告诉Lisp如何将传递给
接口”(Foreign Function Interface 或简称FFI)。FFI的基本工作是让你给Lisp足够的信息以便其可
实现提供这样一种机制。不过近年来，几乎所有的Common Lisp发行版都支持所谓的“外部函数
言等其他语言的库会更为直接。
并且还有更多的库可以使用由给定实现所提供的非标准功能用Lisp写出来，但有时使用来自C语
32.2
语言标准并未指定一种机制让Lisp代码得以调用其他语言写成的代码，甚至也没有要求具体
带有讽刺意味的是，说Lisp是一门用来编写高性能代码的优秀语言，首要原因正是Lisp编程
406
③Knuth过去曾在其出版物中说过许多次，包括在他的1974年ACM图灵奖论文《作为艺术的计算机编程》和他的论文
② 在写这本书时，UFFI的两大缺点是缺少对从C到Lisp回调的支持（很多但并非全部实现的FFI都支持），以及缺少
①外部函数接口基本上等价于Java中的JNI，Perl中的XS或者Python中的扩展模块API。
人们总是说，并分别由Donald Knuth、C.A.R.Hoare和Edsger Dijkstra强调过，过早地进行优
尽管许多有用的库都可以只用语言标准里指定的特性，以“纯粹的”CommonLisp来编写，
《带有goto语句的结构化程序》中。在他的论文《TeX的错误》中，他将该说法归功于C.A.R.Hoare。而Hoare在一封
对CLISP的支持。后者的FFI很好但与其他实现的区别很大，以至于无法轻易集成到UFFI模型之中。
于2004年发给phobia.com的Hans Genwitz的电子邮件中说他不记得这一说法的起源了，但他可以将其归功于Dijkstra。
让它工作，让它正确，让它更快
与其他语言接口
第 32章结论：下一步是什么
www.TopSage.com
?
---
## Page 424
它使用了多少内存。该消息的确切形式是由具体实现定义的。
值，不过在这之前它会向*TRACE-OUTPUT*打印一条消息，指出它花费了多长时间来运行，以及
行时花了多长时间。特别是，TIME宏可以包装在任何形式之外，并返回由其形式所返回的任何
分析以找到你程序中最花时间的性能瓶颈，然后再考虑如何让这些部分提速。？
那么接下来就要思考性能分析和调优了。在Lisp中，和在任何语言中一样，关键在于首先要进行
式转译成了编译了的闭包树，这些闭包通过正常的函数调用机制来调用彼此。?
被转化成了本质上是字节码的东西，然后被插入到了正则引擎中，而CL-PPCRE直接将正则表达
要快，即便Perl的引擎是用高度优化的C写成的。这在很大程度上是因为在Perl中一个正则表达式
CL-PPCRE正则表达式库运行在CMUCL上的时候，在某些基准测试上比Perl的正则表达式引擎还
即便不使用运行期的编译器，闭包也给了你另一种将机器码与运行期数据混合使用的方式。例如，
器码来运行。如果生成的代码打算运行足够多次的话，那么由此带来的好处将是巨大的。或者
员拥有一些其他语言难以比拟的可能性－程序可以在运行期生成Lisp代码，然后再被编译成机
更简单的编译器或解释器的语言快得多了。另外，由于Lisp编译器在运行期可用，因此Lisp程序
可与C编译器生成的代码相媲美的代码，但不作改进的这些实现已经比那些不成熟的实现或使用
实现都带有成熟的编译器，可产生相当高效的机器码。我将很快谈及如何帮助这些编译器来生成
的函数上，这意味着你有更多的时间来找出一个更好的方法。
杂但却高效的实现。并且就算发现整个思路存在问题，你也不必将时间浪费在调整一个不再需要
效的版本（一份代码草图）来检查你的基本思路是否可行，如果是的话再将该函数替换成一个复
大量时间来使编译器得以通过你的代码并等待编译完成。你可以先写出一个函数的某个直接而低
间来编写一个程序，如果你不必花很多时间出入死胡同的话，多半会写出一个高性能的版本来。
一个花费很长时间来运行的函数，并且它还调用了其他两个类似下面的函数：
可以使用TIME来完成一些简单粗暴的分析，缩小你搜索性能瓶颈的范围。例如，假设你有
你有许多种方式来完成性能分析。语言标准提供了一些基本的工具用于测量特定的形式在执
不过,即便使用了正确的算法和高质量的编译器，你可能仍然无法达到你所需要的原始速度。
，
① CL-PPCRE还利用了另一个我没有讨论过的Common Lisp特性，即编译器宏（compiler macro）。编译器宏是一个特
Common Lisp的动态特性确保了代码的灵活性，这使其易于尝试不同的方法。给定有限的时
(defun foo ()
乎不需要花时间的程度，你的整个程序的性能提升也仅限于那段代码在程序运行时间中所占的比率。
“过早地优化”中的词汇“过早"完全可以被定义成“在分析之前”。请记住就算你可以将一些代码的速度提高到几