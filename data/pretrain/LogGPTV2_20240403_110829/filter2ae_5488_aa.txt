# 前言：
本次所用的crackme来自160个crackme系列的第5个，是上一个crackme的进阶版，要困难很多，主要通过这个crackme来学习一次PE逆向中各个步骤的对应操作和知识，以及相应的Delphi框架的基本知识
# 查壳：
使用一个常用的查壳工具：exeinfope，直接拖进去看一下：
可以看机下面有一个upx.exe，说明这是个upx壳，然后拖进OD里面看一下：
开头一个pushad，很明显的加壳操作（将寄存器状态入栈，后面会将这些寄存器状态出栈，然后进入程序真正的代码部分）
## 关于壳：
这展开说一下壳这个机制和对应的解决办法
### 什么是壳：
简单来说壳就是在程序被执行之前获得程序控制权并自动执行的一段指令，它的作用根据情况分为两种：加密和压缩，这里先讲压缩
### 压缩壳：
顾名思义，压缩壳就是让程序的大小变小但不影响正常的装入内存。
压缩壳在解压时会有一个问题，我们的代码在被解压时是从被压缩的地址开始解压，但是由于文件被压缩，那么紧邻这被解压地址的代码的可能会被正在解压的代码给覆盖掉，那么程序是先解压还是先覆盖？
其实在压缩之前，程序会记录原PE文件的节的个数和大小，此时我们生成新的带壳的文件，就会获取这个两个数据，在装载时只需要在壳解压缩的代码后面占用等大的空间，将解压出来的代码放入后面的空间中即可。
### 加密壳：
加密壳的种类相较于压缩壳就要多很多，每个加密壳的侧重点不同，它们有些可能只是单纯的保护程序和避免反编译，有些可能还会提供注册验证，使用次数等功能，加密壳比较复杂这里就不展开说了，后面遇到了再仔细说。
### 手动脱壳：
后面解题时会用专门的脱壳机，但是可以通过这道题来尝试一下自己手动脱壳下面是实际操作：
主要步骤：
  1. 寻找OEP
  2. 脱壳手法：ESP定律，API，单步跟踪
  3. 脱壳：手工拷贝内存，修复PE
本次的crackme在前面的查壳中发现了有一个UPX的壳的存在，UPX是一个压缩壳，它的特征非常明显，就是在程序开头会有一个pushad，然后按一下F8看一下ESP的情况：
只有ESP发生了改变，大概率是可以使用ESP定律，直接在这里下一个硬件断点，然后F9运行起来：
这里有一个jmp，特征非常明显，这里就是跳入程序实际执行的代码部分，可以先F7进入这个jmp看一下：
开头一个push ebp和mov ebp，esp
这是一个非常明显的程序在执行主函数前开栈的操作，基本可以确定这里就是程序的OEP了，那么直接右键选择OD自带的脱壳插件进行脱壳：
由于壳基址会抹去程序原本的IAT，所以OD脱壳后的程序是无法正常运行的，需要修复一下脱壳后程序的IAT，这里使用importREC进行修复：
点击获取导入表后在修复转储即可。之后得到的修复后的文件再拖入OD中调试就会是下面这个样子：
程序的开头就已经是push ebp，即主函数的开栈操作，到这里手动脱壳就完成了。
但是本次的解题为了后面的对齐准确和代码准确性使用的是专门的脱壳机进行脱壳，但是通过手动脱壳可以更深的了解壳机制和积累经验。
# 程序分析：
将脱壳后的程序再次放入exeinfope看一下：
这里已经解析出来了是一个Delphi框架下编写的程序，那么我们就可以使用Delphi的框架分析软件来先静态分析一下这个程序，这里使用的框架分析软件是DarkDe4，直接将脱壳后的程序拖进去：
首先是程序中各个模块的信息，但是我们先关注一下窗体信息，在窗体信息中有一个叫TForm1的窗体，双击它看一下细节：
发现这里其实有两个文本编辑框，但是当我们运行这个程序时只显示出来一个，说明有一个文本编辑框是被隐藏了，这是通过DarkDe4获得的第一个信息。然后看一下过程信息：
事件信息：
这里可以总结出在窗口中有以下几种时间：
  * 表单创建
  * 计时器Timer1
  * 双击事件
  * 编辑框2双击事件
  * 表单鼠标移动时间
  * Image1鼠标移动
  * Image2鼠标移动
  * Image3鼠标移动
  * Image4鼠标移动
  * 计时器Timer2
  * 按钮1点击事件
控件信息：
注意如果前面的脱壳部分采取的是手动脱壳或者通用脱壳机进行脱壳，那么这里的空间消息可能是空白的
## IDA导出MAP文件并导入OD：
为了方便后面对程序的分析，可以将程序的所有符号签名信息在IDA中导出为MAP文件并加载到OD中，首先将程序拖到IDA中：
然后在File选项中找到Produce file，然后在里面找到，create map file
然后出现这个界面后选择生成信息：
然后在目标文件夹中会生成这样一个map文件：
在OD中将这个文件进行导入：
在OD上面的菜单中找到插件，插件菜单中选择LoadMapEx就可以导入map文件了
导入后：
导入map文件后的OD在调试时会多出来很多注释，并且有些函数的名称会发生改变（编程IDA静态分析出来的sig），在后面对代码的分析中会有很大的帮助，所以在以后的程序分析中都可以先尝试使用IDA生成map文件后导入OD
（注意有些OD中可能没有这个插件，这就需要自己到网上下载一个插件之后把它放进OD的插件文件夹中，也就是下面这个文件夹里）
## 字符串分析：
下面正式进入对于这个程序的分析，首先还是按照以前的经验查一下程序里面的字符串：
找到了一些比较关键的字符串，这里选注册成功后的提示字符串点进去看一下：
在显示成功的字符串上面的代码中可以找到一个很明显的判断跳转，有四个与常量的判断跳转（也就是cmp
jcc组合），这里就说明了程序中有四个对于程序是否成功的判断检测，下面分别分析这四个检测以及对应的绕过方式。
## 第一层防护：
注意第一个CMP与JCC的组合，CMP是与一个常量0xC34进行比较，所以这里的ds:[ebx+0x304]就应该是一个与0xC34有关的变量，我们想要绕过这个判断就得让这个变量中的值不为0xC34，那么可以再OD中搜索有关这个0xC34的变量（右键->查找->所有变量->搜索0xC34）
可以看见在这次判断之前还有两次赋值操作，选择第一个点进去看一下：
​ 这里有两个对ds:[ebx+0x304]进行赋值的操作，将程序往上拉，分析一下这段程序的执行逻辑：
程序的开头是创建并初始化表单，并设置程序中的控件为可见（SetVisible）
但是这个流程并不是中单，需要继续往下看：
往下翻一点就会看见一个文件路径注释，还有一个指向赋值语句的跳转。
在跳转语句前还有三个CALL，这三个CALL对应的是Delphi框架下的一次文件IO操作，下面分别说一下：
  1. ASSIGN：这是Delphi中创建文件句柄的操作
  2. RESTTEXT：Delphi中通过文件句柄打开文件的操作
  3. IOResult：文件IO操作的结果
上面三个操作连起来就是打开对应位置路径上的文件并读取里面的内容，如果读取内容为空或者读取错误的话就会执行下面那个jnz跳转到赋值操作的部分，等于第一层检查就直接检测失败了，那么这里对应的操作就是要在对应的目标路径下先创建一个ok.txt文件。
**这里要注意一下，在最原始的题目当中这个路径是X盘，但是根据每个人的情况不一样可能并没有X盘，所以可以在OD中的数据区域将这个路径改成C盘或者其他电脑上有的盘**
接着往下看：
这里会发现一个名字很奇怪的函数：system
StrCmp，在C/C++编程中经常会用到这个名字的函数：strcmp，这里CALL的这个函数功能就是字符串比对，根据结果判断是否je跳过赋值语句，那么这个地方要进行比较的字符串和目标字符串是什么，在调用函数前要进行参数压栈（或通过寄存器传参），这里就要看调用函数前面的某些压栈或者寄存器操作，可以发现有个mov指令是往EDX里面传递了一个参数地址，在数据窗口中找到这个指针指向的数据：
这里正好就是一个字符串，也是作为被比较字符串传入函数的参数。
这里就可以得出绕过第一层防护的方法：在对应路径下创建文件，并将被比较字符串数据用十六进制编辑器写入文件即可。
可以看见被隐藏的编辑框已经可视化了。
## 第二层防护：
那么这里回到前面的四个CMP与JCC的组合判断中，看一下第二个防护是什么：
还是前面那个办法，找一下这个常量0x230D在程序中的赋值操作：