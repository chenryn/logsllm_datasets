## Page 114
104
第五章
一个比较实际可行的做法，就是将目录列表存放在一个make变量里。如果确定文件的数
量不会太多，我们可以通过make函数来达到相同的目的而不必使用for循环：
.INTERMEDIATE:file_list
file_list:
echo S（addsuffix/*.java,$（COMPILATION_DIRS）)>$@
如果预期的目录列表会与时俱增（growwithtime）的话，for循环的做法不太可能导致
命令行过长的问题。
make脚本中另一个常见的问题是如何切换目录。显然，如下的简单脚本：
TAGS:
cd src
ctags--recurse
将无法在src子目录中运行ctags程序。为了获得我们想要的结果，我们必须将这两
个命令放在同一行上，或是以反斜线规避换行符号（以及使用分号隔开这两个命令）：
TAGS:
cd src;
ctags -recurse
一个更好的做法就是在运行ctags程序之前检查cd的状态：
TAGS:
cd src &&
ctags -recurse
请注意，在某些情况下，省略分号并不会让make或shell产生错误信息：
disk-free=echo*Checking freedisk space."\
df.1awk（print $$4}
这个例子会先输出一段简单的信息，接着输出当前磁盘的可用块的数目。它会这么做
吗？我们不经意地省略了echo命令之后的分号，因此af程序根本不会运行、只会将如
下的内容送往awk：
Checking free disk space  df
于是awk便会忠实地输出第四个字段space...。
当你用define指令建立多行形式的命令序列时，也可能会遇到问题。这个问题跟前面
的问题不太一样。当一个多行形式的宏被扩展时，宏主体中的每一行会被插人脚本并具
有前导的跳格符，make会认为这样的每一行都是各自独立的命令，于是它们并不会在
单一的subshell中执行。所以你也应该注意宏中命令行延续的问题。
---
## Page 115
命令
105
命令修饰符
一个命令可以通过若干前缀加以修饰。我们已经多次看到“安静模式”前缀（@）被使
用在前面的范例中，接下来我们会完整列出所有可用的前缀（修饰符），并提供详细的
说明：
@不要输出命令。当你想将某个工作目标的所有命令全都隐藏起来的时候，如果考虑
到旧版的兼容性，你可以把该工作目标设成特殊工作日标.SILENT的一个必要条
件。不过，最好能够使用，因为它可以应用在脚本中个别的命令上。如果你将这
个修饰符应用在所有的工作目标上（尽管很难想象为什么要这么做），你可以使用-
-silent（或-s）选项。
隐藏命令可让make的输出较容易阅读，不过这么做可能会使得命令的调试较为困
难。如果你发现自已常常需要移除和恢复@修饰符，你可以创建一个内含修饰符
的变量，例如QUIET，并将它使用在命令上：
QUIET=@
hairy_script:
S(ouIET)complexscript..
往后，如果你在make运行复杂脚本（complexscript）的时候需要看到脚本本身，
只需要通过命令行重新设定QUIET变量就行了：
$make QUIET= hairy_script
complex script...
破折号前缀（dashprefix）用来指示make应该忽略命令中的错误。默认的情况下，
当make执行一个命令的时候，它会检查程序或管道的结束状态，如果所返回的是
非零（失败）的结束状态，make将会终止命令脚本接下来的执行动作，并且结束
执行。这个修饰符会指示make忽略被修饰那行（modifiedline）的结束状态，并
且继续执行下去，就好像没有发生错误一样。我们将会在下一节更深入地探讨这个
内容。
如果考虑到旧版的兼容性，你可以通过将工作目标设成.IGNORE特殊工作目标的
一个必要条件，让make忽略某部分的命令脚本。如果你想要忽略整个makefile中
的所有错误，你可以使用--ignore-errors（或-i）选项。同样地，这么做似乎
不太有用。
+
加号修饰符（plusmodifier）用来要求make执行命令，就算用户是以--just-
print（或-n）命令行选项来执行make的。当你要编写递归形式的makefile时，
就会用到这个功能。我们将会在“递归式make”一节中更深入地探讨这个议题。
这些修饰符都可以使用在单行命令上。显然，在命令执行之前，这些修饰符都会被去除。
---
## Page 116
106
第五章
错误与中断
make每执行一个命令就会返回一个状态码。值为零的状态码代表命令执行成功，值为
非零的状态码代表发生了某种错误。某些程序会以状态码来指示更其意义的内容，而不
仅是代表“错误”。举例来说，grep会返回0来代表“找到相符的模式”，返回1来代
通常，当有一个程序运行失败（也就是，返回非零值的结束状态）时，make会停止执
行命令的动作，并以错误的状态结束执行。有时你会想让make继续执行下去，以便尽
量完成其余的工作自标。举例来说，你可能会想要尽量编译完所有文件，好让你只需执
行一次就能看到所有的编译错误。这个时候你可以使用--keep-going（或-k）选项。
虽然-修饰符可让make忽略个别命令所发生的错误，不过我会尽量避免使用这个功能。
这是因为，此功能会让自动的错误处理机制复杂化，而且让人有不一致的感觉。
当make忽略错误时，它会在相应工作目标的名称（放在方括号里）之后输出警告信息。
例如，当rm试着要删除一个不存在的文件时，会输出如下的内容：
rm non-existent-file
rm:cannot removenon-existent-file':No such file or directory
make:[clean]Error 1（ignored）
有些命令，比如rm，本身具有选项可用来抑制错误结束状态。抑制错误信息的同时，你
还可以使用-f选项迫使rm返回成功结束状态。使用此类选项比依靠-修饰符要好。
有时，如果命令执行成功，你会希望它执行失败，以便取得错误结束状态。这个时候，
你应该将程序的结束状态取反（negate）：
确认程序代码里已不包含调试语句。
.PHONY:no_debug_printf
no_debug_printf:S(sources)
!grep--line-numberdebug:'S^
可惜make3.80有缺陷（bug），所以你无法直接这么做。make并不知道！字符是要给
shell处理的，它会自已执行该行命令，结果会导致错误。这个问题有一个简单的解决方
案，就是为该行命令加人一个shell特殊字符，以作为make判断的依据：
#确认程序代码里已不包含调试语句。
.PHONY:no_debug_printf
no_debug_printf:S(sources)
nu/ap/>s.:Bnqop.xaqu-ut--daxb
另一个常见的非预期的命令错误，就是使用shell的if结构时忘了使用else。
---
## Page 117
命令
107
$(config):S(config_template)
if[!-d $（dir $@）];
then
$(MKDIR)S（dir $）;
fi
BSS@
在shell中，冒号（：）是个no-op命令，它总是会返回“真值”，所以可用来取代true。
通过下面的替代方案也可以达到相同的目的：
S（config):S（config_template)
1[-d s（dir $e） 1]11 S(MKDIR）$（dir $@）
S（M4)S>S@
现在，只要目录存在或者mkdir执行成功，第一条语句就为“真值”。另一个替代方案
就是使用mkdir-P，这样即使目录已经存在，mkdir也会执行成功。即使目录已经
存在，以上所提到的各种做法都会在subshell中执行某个动作。如果不想在目录存在的
时候执行任何动作，则可以使用wildcard函数。
#S(callmake-dir,directory)
make-dir= $（if $（wildcard $1),,S(MKDIR)-p $1)
S（config):$(config_template)
$(call make-dir,$（dir $@）)
S(M4）S>$@
因为每个命令会在它自己的shell中被执行，所以你常会看到多行命令中的每个命令组件
被分号隔开，好让它们在同一个shell中被执行。这样即使其中有命令组件发生错误，也
不会让脚本终止运行：
target:
rm rm-fails;echo But the next command executes anyway
命令脚本的长度越短越好，这样make才会有机会为你处理结束状态以及终止运行。例
如：
---
## Page 118
108
第五章
path-fixup=-e"s;{a-zA-Z:/]*/src/;S（SOURCE_DIR)/;g"\
--]
#A good version.
define fix-project-paths
sedS(path-fixup)$1>$2.fixed&&\
mv $2.fixed $2
endef
A better version.
define fix-project-paths
sed S(path-fixup)$1> $2.fixed
mv $2.fixed $2
endef
这个宏可让你为特定的源文件树和输出文件树，将DOS风格的路径名称（但以斜线为分
隔符）转换成目标路径。这个宏的参数有两个：输人文件的名称和输出文件的名称。只
有在sed命令完全正确的状况下，你才需要担心输出文件是否会被覆盖掉。第一个版本
（goodversion）的做法就是使用&&将sed和mv连接在一起，这样它们就可以在同一
个shell中执行。第二个版本（betterversion）的做法就是将它们作为两个独立的命令
来执行，让make可以在sed执行失败的时候，终止脚本的运行。第二个版本的代价并
不高（mv可以直接执行，并不需要通过shell），也比较容易阅读，而且在错误发生时还
能提供较多的信息（因为make会指出是哪个命令执行失败）。
请注意，下面所要谈的并非cd的常见问题：
TAGS:
cd src&&\
ctags --recurse
由于脚本中的那两条语句必须在同一个subshell中执行，所以我们必须使用某种语句连
接符（像；或&&）来隔开它们。
删除与保存工作目标文件
如果有错误发生，make会假设相应的工作目标无法被重新建立。作为当前工作目标的
必要条件的任何其他工作目标也无法被重新建立，所以make不会这么做，也不会执行
其脚本中的任何一部分。如果执行make的时候用到了--keep-going（或-k）选项，则
make会试图进行下一个工作目标：否则make就会结束执行。假设当前的工作目标是
一个文件，如果在它的工作完成之前命令提早结束执行，则这个文件可能会遭到破坏。
遗憾的是，为了与旧版兼容，make会把这个可能已遭破坏的文件留在磁盘上。因为该
文件的时间戳已经更新，所以make随后的执行动作并不会以正确的数据来更新它。为
了避免此问题，只需将该工作目标文件设成.DELETE_ON_ERROR的一个必要条件，这
样当有错误发生时，make会删除有问题的文件。当你使用.DELETE_ON_ERROR的时
---
## Page 119
命令
109
候，如果没有为它指定任何必要条件，那么不管是哪个工作目标文件的编译过程发生错
误，都会使得make删除该工作目标文件。
当make的执行被信号（像Ctrl+C）中断时，会产生相反的问题。这个时候，如果文件
被更改，make就会删除当前的工作自标文件。有些时候，删除文件可能不是你想要的
结果，或许因为创建这个文件的代价非常高，能够保存部分的内容比什么都没有强：也
或许是这个文件必须存在，这样方能继续进行其他部分的编译工作。这个时候，你可以
通过将该文件设成特殊工作目标.PRECIOUS的一个必要条件来保护它。
使用哪个shell
当make需要传递一个命令给subshell时，默认情况下会使用/bin/sh。你可以通过设定
SHELL这个make变量来加以变更，但请三思而行。通常make的用途就是为开发者社
群提供一个工具，使他们可以从源文件来编译一个系统。如果能依照这个目的来使用工
具，makefile的创建应该相当容易，不过对开发者社群里的某些人来说目的并非如此。
然而，对任何（通过匿名ftp或开放式cvs）广泛发布的应用程序来说，使用/bin/sh以外
的任何shell被认为是最糟糕的做法。我们将会在第七章更深人地探讨可移植性的相关议
题。
不过，make也可能使用在另一种环境之中。通常在封闭的开发环境里，你会看到一群经
许可的开发者在一组有限的机器与操作系统上进行开发的工作。事实上，我常常发现自
已就身处在这样的环境之中。这个时候，根据make预期要运行的环境来进行环境的自定
义最有意义。开发者必须知道如何设置自已的环境好让编译工作能够正确进行，以及让
自己的日子好过一点。
在这样的环境之下，我比较喜欢在“最前面”对可移植性做些让步。我相信这样可让整
个开发过程更加顺利。我对此所做的让步是将SHELL变量设成/usr/bin/bash。bash是
一个具可移植性、与POSIX兼容的shell（因此它的功能涵盖sh），也是GNU/Linux所
采用的标准shell。makefile里许多的移植问题皆肇因于命令脚本中使用了不具可移植性
的语法结构。解决这个问题的方法很简单，使用标准的shell就行了，不必刻意使用具可
移植性的sh子集。GNUmake的维护者PaulSmith在他的Paul'sRulesofMakefiles
（
在自找麻烦，为何不使用具可移植性的make！”我也会这么说：“编写具可移植性的命
令脚本是在自找麻烦，只要有可能，请使用具可移植性的shell（bash）。”bashshell可
以在大多数的操作系统上运行，包括几乎所有的Unix变体、Windows、BeOS、Amiga
以及OS/2。
在本书其余的部分，当命令脚本用到bash特有的功能时，我将会加以说明。
---
## Page 120
110
第五章
空命令
空命令（emptycommand）就是一个什么事都不做的命令。
header.h:;
先前提到过工作目标的必要条件列表可以跟着个分号和命令。此处，分号之后空无一
物，这表示命令并不存在。当然你也可以在工作目标之后指定只包含一个跳格符的空白
行，不过这么做根本无法阅读。空命令最常用来避免模式规则匹配特定的工作目标，而
执行你不想要的命令的情况。
请注意，在make的其他版本中，空工作目标（emptytarget）有时会被作为假想工作目
标（phonytarget）来用。在GNUmake中，你可以使用.PHONY这个特殊工作目标，因
为这么做较安全也较清楚。
命令环境
make执行命令时会从make本身继承其处理环境。此环境包含当前的工作目标、文件描