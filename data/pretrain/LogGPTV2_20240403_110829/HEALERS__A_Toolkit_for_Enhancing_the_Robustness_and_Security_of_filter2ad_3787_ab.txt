edly probing the function with a hierarchy of function
types until it ﬁnds one that does not result in robustness
failures. By doing so, it generates the robust API for a
shared library. Although some manual editing may be
needed, this process is largely automated.
2.2 Automation
2.3 Flexible Wrapper Generation
One way to increase the security and robustness of
software is by visually examining the source code to de-
tect any loopholes. For example, we can examine the
control ﬂow of the program to see whether it ever ac-
cesses an invalid pointer or whether it performs bound-
ary checks when performing a string copy operation.
This approach, however, is labor-intensive: the human
cost for examining a large software product can be huge.
Moreover, whenever there is a new software release or
update, it has to be examined again.
With the price of computer hardware decreasing
rapidly, the key to providing cost-effective protection to
computer software is automation: let the computers do
the work. Our HEALERS system discovers the robust-
ness problems in C libraries through automated fault-
injection experiments as illustrated in Figure 2. The
system parses the header ﬁles and manual pages from
C libraries to generate the prototype information for all
global functions. Note that the API deﬁned by the proto-
type of a function is not always robust. For example, the
prototype of the strcpy function speciﬁes its ﬁrst ar-
gument to be char *. However, it actually has to be a
pointer to a writable buffer with enough space to accom-
One challenge in our system design is how to gen-
erate a large number of wrappers to suit the needs of
different applications. Apparently, it is undesirable to
write every wrapper from scratch. Our system provides
a ﬂexible framework for a wide variety of wrapper types.
This is achieved through a modular approach where the
functionality of a wrapper generator is decomposed into
a number of “features”, each supported by a micro-
generator. Each micro-generator generates a fragment
of the preﬁx and postﬁx code of a function. The micro-
generators can be combined in a variety of ways to gen-
erate new wrapper types.
Figure 3 depicts the wrapper function wctrans.
This code is generated by combining six micro-
generators: prototype, function exectime, collect errors,
func errors, call counter, and caller. The prototype
and caller are standard micro-generators that gener-
ate the prototype of the wrapper function and the call
to the original function, respectively. The rest micro-
generators generate code to collect various statistics dur-
ing the program execution. The micro-generator also
generates code for collecting the results. Just before the
application terminates, the collection code is called to
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Shared
Library
Function
Prototypes
searching robust
argument types
Automated
Fault−Injection
Experiments
Robust  API
Figure 2. HEALERS discovers robust API for shared libraries through automated fault-injection
experiments.
send the gathered information to a central server. Since
different types of wrappers can be used in a distributed
environment, the gathered information sent to the server
is in form of a “self-describing” XML document. The
server can extract from the document which functions
were wrapped and what kind of information was col-
lected. Such information is then stored for later process-
ing. Figure 5 shows an example of collected data.
3 Demonstration
We will demonstrate the following features of our
software.
3.1 Wrapping Libraries
Our toolkit can list all libraries in the system. A user
can select one of the libraries. Our system will then gen-
erate a list of all functions deﬁned in the library. In ad-
dition, our system will create a XML-style declaration
ﬁle that describes the prototype of each function in the
library. The results of such experiments can be used to
generate various wrappers as described in [5].
3.2 Wrapping Applications
The previous demo is library-centric. In contrast, this
demo is application-centric. It allows a user to browse
through the list of ﬁles in the current system and se-
lect an application program (i.e. an executable ﬁle).
Our toolkit can automatically extract the list of libraries
linked to this application as well as the list of undeﬁned
functions in the application. The Web interface for this
demo is illustrated in Figure 4.
Figure 4. HEALERS automatically extracts
the list of libraries linked to an application
and the list of undeﬁned functions.
3.3 Proﬁling
In this demo, we show that our proﬁling wrapper can
gather statistics related to the execution of a program
and automatically generate graphics to display the re-
sult as shown in Figure 5. A user executes a program
in the system with our proﬁling wrapper. Upon termi-
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
/* Preﬁx code by micro-gen prototype */
wctrans_t wctrans(const char* a1) (cid:0)
wctrans_t ret;
/* Preﬁx code by micro-gen function exectime */
(cid:0)
unsigned long long exectime_start;
unsigned long long exectime_end;
rdtsc(exectime_start);
/* Preﬁx code by micro-gen collect errors */
(cid:0) int collect_errors_err = errno;
/* Preﬁx code by micro-gen func error */
(cid:0) int func_error_err = errno;
/* Preﬁx code by micro-gen call counter */
++call_counter_num_calls[1206];
/* Postﬁx code by micro-gen caller */
ret = (*addr_wctrans)(a1);
/* Postﬁx code by micro-gen func error */
if (func_error_err != errno) (cid:0)
if (errno = MAX_ERRNO) (cid:0)
++func_error_cnter[1206][MAX_ERRNO];
(cid:1) else (cid:0) ++func error_cnter[1206][errno]; (cid:1)
(cid:1)
(cid:1)
/* Postﬁx code by micro-gen collect errors */
if (collect errors err != errno) (cid:0)
if (errno = MAX ERRNO) (cid:0)
++collect errors cnter[MAX ERRNO];
(cid:1) else (cid:0)
++collect errors cnter[errno];
(cid:1)
(cid:1)
(cid:1)
/* Postﬁx code by micro-gen function exectime */
rdtsc(exectime end);
exectime[NO FUNCTION] += exectime end-exectime start;
(cid:1)
/* Postﬁx code by micro-gen prototype */
return ret;
(cid:1)
Figure 3. Wrapped function for abs.
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
tion to many software systems. It uses automated fault
injection experiments to detect robustness and security
problems in a given software. Based on the knowledge
gathered from such experiments, it automatically gener-
ates software wrappers to ﬁx a large percentage of such
problems. The architecture of our system is ﬂexible in
that it can be conﬁgured to generate a variety of wrap-
pers to satisfy the needs of different applications.
References
[1] Arash Baratloo, Navjot Singh, and Timothy Tsai.
Transparent run-time defense against stack smash-
ing attacks.
In Proceedings of USENIX Annual
Technical Conference, June 2000.
[2] Subhachandra Chandra and Peter M. Chen. Whither
generic recovery from application faults? A fault
study using open-source software. In Proceedings of
the 2000 International Conference on Dependable
Systems and Networks, 2000.
[3] Christof Fetzer and Zhen Xiao. Detecting heap
smashing attacks through fault containment wrap-
pers. In Proceedings of the 20th IEEE Symposium
on Reliable Distributed Systems, October 2001.
[4] Christof Fetzer and Zhen Xiao. An automated ap-
proach to increasing the robustness of C libraries.
In Proceedings of the International Conference on
Dependable Systems and Networks, June 2002.
[5] Christof Fetzer and Zhen Xiao. A ﬂexible generator
architecture for improving software dependability.
In Proceedings of the International Symposium on
Software Reliability Engineering,, November 2002.
[6] Philip Koopman and John DeVale. The excep-
tion handling effectiveness of POSIX operating sys-
tems. IEEE Transactions on Software Engineering,
26(9):837–848, Sep 2000.
Figure 5. The proﬁling wrapper can collect
various runtime information.
nation, the wrapper generate a XML-style log ﬁle that
shows the frequency of function calls in this program,
the percentage of execution time in each function, the
distribution of function errors, the causes of such errors
(classiﬁed by errnos), etc..
3.4 Buffer Overﬂow Prevention
In this demo, we show that our security wrapper can
prevent buffer overﬂow attacks.
It ﬁrst shows that an
attacker can hijack the control ﬂow of a root privileged
program by overﬂowing a buffer allocated on the heap.
This results in a root shell for the attacker. An example
of such a program was previously published in [3]. Then
we show that our security wrapper can detect such buffer
overﬂows and terminate the attacker’s program.
4 Conclusion
We have described the HEALERS toolkit for in-
creasing the robustness and security of existing software
without source code access. The toolkit intercepts C li-
brary function calls and can provide transparent protec-
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE