---
author: Jacques Mattheij
category: 观点
comments_data: []
count:
  commentnum: 0
  favtimes: 1
  likes: 0
  sharetimes: 0
  viewnum: 4131
date: '2017-12-28 09:33:45'
editorchoice: false
excerpt: 在每一个程序员、项目管理员、团队领导的一生中，这都会至少发生一次。原来的程序员早已离职去度假了，给你留下了一坨几百万行屎一样的、勉强支撑公司运行的代码和（如果有的话）跟代码驴头不对马嘴的文档。
fromurl: https://jacquesmattheij.com/improving-a-legacy-codebase
id: 9184
islctt: true
largepic: /data/attachment/album/201712/28/093339ql5vt7lw1vpssnnl.jpg
permalink: /article-9184-1.html
pic: /data/attachment/album/201712/28/093339ql5vt7lw1vpssnnl.jpg.thumb.jpg
related: []
reviewer: ''
selector: ''
summary: 在每一个程序员、项目管理员、团队领导的一生中，这都会至少发生一次。原来的程序员早已离职去度假了，给你留下了一坨几百万行屎一样的、勉强支撑公司运行的代码和（如果有的话）跟代码驴头不对马嘴的文档。
tags:
- 代码
- 重构
thumb: false
title: 如何改善遗留的代码库
titlepic: true
translator: aiwhj
updated: '2017-12-28 09:33:45'
---
![](/data/attachment/album/201712/28/093339ql5vt7lw1vpssnnl.jpg)
在每一个程序员、项目管理员、团队领导的一生中，这都会至少发生一次。原来的程序员早已离职去度假了，给你留下了一坨几百万行屎一样的、勉强支撑公司运行的代码和（如果有的话）跟代码驴头不对马嘴的文档。
你的任务：带领团队摆脱这个混乱的局面。
当你的第一反应（逃命）过去之后，你开始去熟悉这个项目。公司的管理层都在关注着你，所以项目只能成功；然而，看了一遍代码之后却发现失败几乎是不可避免。那么该怎么办呢？
幸运（不幸）的是我已经遇到好几次这种情况了，我和我的小伙伴发现将这坨热气腾腾的屎变成一个健康可维护的项目是一个有丰厚利润的业务。下面这些是我们的一些经验：
### 备份
在开始做任何事情之前备份与之可能相关的所有文件。这样可以确保不会丢失任何可能会在另外一些地方很重要的信息。一旦修改了其中一些文件，你可能花费一天或者更多天都解决不了这个愚蠢的问题。配置数据通常不受版本控制，所以特别容易受到这方面影响，如果定期备份数据时连带着它一起备份了，还是比较幸运的。所以谨慎总比后悔好，复制所有东西到一个绝对安全的地方并不要轻易碰它，除非这些文件是只读模式。
### 重要的先决条件：必须确保代码能够在生产环境下构建运行并产出
之前我假设环境已经存在，所以完全丢了这一步，但 Hacker News 的众多网友指出了这一点，并且事实证明他们是对的：第一步是确认你知道在生产环境下运行着什么东西，也意味着你需要在你的设备上构建一个跟生产环境上运行的版本每一个字节都一模一样的版本。如果你找不到实现它的办法，一旦你将它投入生产环境，你很可能会遭遇一些预料之外的糟糕事情。确保每一部分都尽力测试，之后在你足够确信它能够很好的运行的时候将它部署生产环境下。无论它运行的怎么样都要做好能够马上切换回旧版本的准备，确保日志记录下了所有情况，以便于接下来不可避免的 “验尸” 。
### 冻结数据库
直到你修改代码结束之前尽可能冻结你的数据库，在你已经非常熟悉代码库和遗留代码之后再去修改数据库。在这之前过早的修改数据库的话，你可能会碰到大问题，你会失去让新旧代码和数据库一起构建稳固的基础的能力。保持数据库完全不变，就能比较新的逻辑代码和旧的逻辑代码运行的结果，比较的结果应该跟预期的没有差别。
### 写测试
在你做任何改变之前，尽可能多的写一些端到端测试和集成测试。确保这些测试能够正确的输出，并测试你对旧的代码运行的各种假设（准备好应对一些意外状况）。这些测试有两个重要的作用：其一，它们能够在早期帮助你抛弃一些错误观念，其二，这些测试在你写新代码替换旧代码的时候也有一定防护作用。
要自动化测试，如果你有 CI 的使用经验可以用它，并确保在你提交代码之后 CI 能够快速的完成所有测试。
### 日志监控
如果旧设备依然可用，那么添加上监控功能。在一个全新的数据库，为每一个你能想到的事件都添加一个简单的计数器，并且根据这些事件的名字添加一个函数增加这些计数器。用一些额外的代码实现一个带有时间戳的事件日志，你就能大概知道发生多少事件会导致另外一些种类的事件。例如：用户打开 APP 、用户关闭 APP 。如果这两个事件导致后端调用的数量维持长时间的不同，这个数量差就是当前打开的 APP 的数量。如果你发现打开 APP 比关闭 APP 多的时候，你就必须要知道是什么原因导致 APP 关闭了（例如崩溃）。你会发现每一个事件都跟其它的一些事件有许多不同种类的联系，通常情况下你应该尽量维持这些固定的联系，除非在系统上有一个明显的错误。你的目标是减少那些错误的事件，尽可能多的在开始的时候通过使用计数器在调用链中降低到指定的级别。（例如：用户支付应该得到相同数量的支付回调）。
这个简单的技巧可以将每一个后端应用变成一个像真实的簿记系统一样，而像一个真正的簿记系统，所有数字必须匹配，如果它们在某个地方对不上就有问题。
随着时间的推移，这个系统在监控健康方面变得非常宝贵，而且它也是使用源码控制修改系统日志的一个好伙伴，你可以使用它确认 BUG 引入到生产环境的时间，以及对多种计数器造成的影响。
我通常保持每 5 分钟（一小时 12 次）记录一次计数器，但如果你的应用生成了更多或者更少的事件，你应该修改这个时间间隔。所有的计数器公用一个数据表，每一个记录都只是简单的一行。
### 一次只修改一处