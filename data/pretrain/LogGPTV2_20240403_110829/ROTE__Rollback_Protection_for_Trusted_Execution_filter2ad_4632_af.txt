//software.intel.com/en-us/node/696636.
[25] R. Strackx et al., “Idea: State-continuous transfer of state in
protected-module architectures,” in ESSoS, 2015.
[26] M. Brandenburger et al., “Rollback and Forking Detection for
Trusted Execution Environments using Lightweight Collective
Memory,” 2017, http://arxiv.org/abs/1701.00981.
[27] B. Schneier et al., “Secure audit logs to support computer foren-
sics,” ACM TISSEC, 1999.
[28] D. Ma et al., “A new approach to secure logging,” ACM TOS,
2008.
[29] S. A. Crosby et al., “Efﬁcient data structures for tamper-evident
logging,” in USENIX Security, 2009.
[30] A. Sinha et al., “Continuous tamper-proof logging using tpm 2.0,”
in TRUST, 2014.
[31] A. Haeberlen et al., “PeerReview: Practical Accountability for
Distributed Systems,” ACM OSR, 2007.
[32] B.-G. Chun et al., “Attested append-only memory: Making ad-
versaries stick to their word,” in ACM OSR, 2007.
[33] D. Levin et al., “TrInc: Small Trusted Hardware for Large Dis-
tributed Systems,” in NSDI, 2009.
[34] M. Correia et al., “How to tolerate half less one Byzantine nodes
in practical distributed systems,” in DISC, 2004.
[35] J. Liu et al., “Scalable Byzantine Consensus via Hardware-
assisted Secret Sharing,” arXiv preprint arXiv:1612.04997, 2016.
[36] R. Kapitza et al., “CheapBFT: resource-efﬁcient byzantine fault
tolerance,” in EuroSys, 2012.
[37] F. J. Meyer et al., “Consensus with dual failure modes,” IEEE
TPDS, 1991.
[38] J. A. Garay et al., “A continuum of failure models for distributed
computing,” in PDAA, 1992.
[39] H.-S. Siu et al., “A note on consensus on dual failure modes,”
IEEE TPDS, 1996.
[40] F. Tramer et al., “Sealed-Glass Proofs: Using Transparent En-
claves to Prove and Sell Knowledge,” 2016, http://eprint.iacr.org/
2016/635.
[41] F. Zhang et al., “Town Crier: An Authenticated Data Feed for
Smart Contracts,” in CCS, 2016.
[42] N. Weichbrodt et al., “AsyncShock: Exploiting Synchronisation
Bugs in Intel SGX Enclaves,” in ESORICS, 2016.
[43] D. Gupta et al., “Using Intel Software Guard Extensions for Efﬁ-
cient Two-Party Secure Function Evaluation,” in WAHC, 2016.
[44] S. Brenner et al., “SecureKeeper: Conﬁdential ZooKeeper using
Intel SGX,” in Middleware, 2016.
[45] R. Pass et al., “Formal abstractions for attested execution secure
processors,” in Cryptology ePrint Archive, 2016.
[46] R. Sinha et al., “Moat: Verifying Conﬁdentiality of Enclave Pro-
grams,” in CCS, 2015.
[47] F. McKeen et al., “Innovative instructions and software model for
isolated execution,” in HASP@ ISCA, 2013.
[48] “Intel Software Guard Extensions, Reference Number:
https://software.intel.com/sites/default/
332680-002,”
2015,
ﬁles/332680-002.pdf.
Johnson et al.,
[49] S.
“Intel SGX: EPID provisioning and
attestation
https://software.intel.com/en-
us/blogs/2016/03/09/intel-sgx-epid-provisioning-and-attestation-
services.
services,”
2016,
[50] B. Alexander,
“Introduction
SGX Sealing,”
https://software.intel.com/en-us/blogs/2016/05/04/
Intel
to
2016,
introduction-to-intel-sgx-sealing.
[51] Intel, “Developer Zone Forums,” 2016, https://software.intel.
com/en-us/forums/intel-software-guard-extensions-intel-sgx/
topic/607330.
[52] ——, “Intel 100 Series and Intel C230 Series Chipset Family
Platform Controller Hub (PCH),” 2016, http://www.intel.com/
content/www/us/en/chipsets/100-series-chipset-datasheet-vol-1.
html.
[53] ——, “Intel 9 Series Chipset Family Platform Controller
Hub (PCH),” 2015, http://www.intel.com/content/www/us/en/
chipsets/9-series-chipset-pch-datasheet.html.
A SGX Background
Here we brieﬂy describe the main protection mecha-
nisms of SGX. For a more elaborate explanation of the
architecture, we refer interested readers to [1].
Enclave creation. An enclave is created by the sys-
tem software. During enclave creation, the system soft-
ware speciﬁes the enclave code. Security mechanisms
in the processors create a data structure called SGX En-
clave Control Structure (SECS) that is stored in a pro-
tected memory area (see below). Because enclaves are
created by the system software running on the OS, their
code cannot contain sensitive data. The start of the en-
clave is recorded by the processor, reﬂecting the content
1304    26th USENIX Security Symposium
USENIX Association
of the enclave code as well as the loading procedure (se-
quence of instructions). The recording of an enclave start
is called measurement and it can be used for later attes-
tation. Once an enclave is no longer needed, the OS can
terminate it and thus erase its memory structure from the
protected memory.
Runtime isolation. The SGX security architecture
guarantees that enclaves are isolated from all software
running outside of the enclave, including the OS, other
enclaves, and peripherals. By isolation we mean that
the control-ﬂow integrity of the enclave is preserved and
other software cannot observe its state. The isolation
is achieved via protection mechanisms that are enforced
by the processor. The code and data of an enclave are
stored in a protected memory area called Enclave Page
Cache (EPC) that resides in Processor Reserved Mem-
ory (PRM) [47]. PRM is a subset of DRAM that can-
not be accessed by the OS, applications or direct mem-
ory accesses. The PRM protection is based on a series
of memory access checks in the processor. Non-enclave
software is only allowed to access memory regions out-
side the PRM range, while enclave code can access both
non-PRM memory and the EPC pages owned by the en-
clave [1].
The untrusted OS can evict EPC pages into the un-
trusted DRAM and load these back at a later stage.
While the evicted EPC pages are stored in the untrusted
memory, SGX assures their conﬁdentiality, integrity and
freshness via cryptographic protections. The architecture
includes the Memory Encryption Engine (MEE) which is
a part of the processor uncore (microprocessor function
close to but not integrated into the core [1]). The MEE
encrypts and authenticates the enclave data that is evicted
to the non-protected memory, and ensures enclave data
freshness at runtime using counters and a Merkle-tree
structure. The root of the tree structure is stored on the
processor die. Additionally, the MEE is used to protect
SGX’s Enclave Page Cache against physical attacks and
is connected to the Memory Controller [48, 1].
Attestation. Attestation is the process of verifying
that certain enclave code has been properly initialized. In
local attestation a prover enclave can request a statement
that contains measurements of its initialization sequence,
enclave code and the issuer key. Another enclave on the
same platform can verify this statement using a shared
key created by the processor. In remote attestation the
veriﬁer may reside on another platform. A system ser-
vice called Quoting Enclave signs the local attestation
statement for remote veriﬁcation. The veriﬁer checks the
attestation signature with the help of an online attestation
service that is run by Intel. Each veriﬁer must obtain a
key from Intel to authenticate to the attestation service.
The signing key used by the Quoting Enclave is based on
a group signature scheme called EPID (Enhanced Pri-
vacy ID) which supports two modes of attestation: fully
anonymous and linkable attestation using pseudonyms
[49, 1]. The pseudonyms remain invariant across reboot
cycles (for the same veriﬁer). Once an enclave has been
attested, the veriﬁer can establish a secure channel to it
using an authenticated key exchange mechanism.
Sealing. Enclaves can save conﬁdential data across
executions. Sealing is the process to encrypt and authen-
ticate enclave data for persistent storage [50]. All lo-
cal persistent storage (e.g. disk) is controlled by the un-
trusted OS. For each enclave, the SGX architecture pro-
vides a sealing key that is private to the executing plat-
form and the enclave. The sealing key is derived from a
Fuse Key (unique to the platform, not known to Intel) and
an Identity Key that can be either the Enclave Identity or
Signing Identity. The Enclave Identity is a cryptographic
hash of the enclave measurement and uniquely identiﬁes
the enclave.
If data is sealed with Enclave Identity, it
is only available to this particular enclave version. The
Signing Identity is provided by an authority that signs the
enclave prior to its distribution. Data sealed with Sign-
ing Identity can be shared among all enclave versions
that have been signed with the same Signing Identity.
B SGX Counter Analysis
Intel has recently added support for monotonic coun-
ters [5] as an optional SGX feature that an enclave devel-
oper may use for rollback attack protection. However,
the security and performance properties of this mecha-
nism are not well documented. Furthermore, they are not
available on all platforms. In this Appendix we outline
all executed experiments and evaluate the SGX counter
and trusted time service.
SGX counter service. An enclave can query avail-
ability of counters from the Platform Service Enclave
(PSE). If supported, the enclave can create up to 256
counters. The default owner policy encompasses that
only enclaves with the same signing key may access the
counter. Counter creation operation returns an identiﬁer
that is a combination of the Counter ID and a nonce to
distinguish counters created by different entities. The en-
clave must store the counter identiﬁer to access it later, as
there is no API call to list existing counters. After a suc-
cessful counter creation, an enclave can increment, read,
and delete the counter.
According to the SGX API documentation [5], counter
operations involve writing to a non-volatile memory. Re-
peated write operations can cause the memory to wear
out, and thus the counter increment operations may be
rate limited. Based on Intel developer forums [51], the
counter service is provided by the Management Engine
on the Platform Control Hub (PCH).
Experiments. We tested SGX counters on ﬁve dif-
ferent platforms: Dell Inspiron 13-7359, Dell Latitude
USENIX Association
26th USENIX Security Symposium    1305
E5470, Lenovo P50, Intel NUC and Dell Optiplex 7040.
The counter service was not available on Intel NUC. On
Dell laptops a counter increment operation took approx-
imately 250 ms, while on the Lenovo laptop and Dell
Optiplex increment operations took approximately 140
ms and 80 ms, respectively. Strackx et al. [2] report 100
ms for counter updates. Counter read operations took
60-140 ms, depending on the platform. As expected,
the counter values remained unchanged across enclave
restarts and platform reboots. We tested the wear-out
characteristics of the counters and found out that on both
Dell laptops, after approximately 1.05 million writes, the
tested counter became unusable and other counters on the
same platform could not be created, incremented or read
(all SGX counter operations return SGX ERROR BUSY).
Additionally, we observed that reinstalling the SGX
Platform Software (PSW) or removing the BIOS battery
deletes all counters. Finally, to our surprise, we noticed
that after reinstalling the PSW, ﬁrst usage of counter
service triggered the platform software to connect to a
server whose domain is registered to Intel.
If Internet
connection is not available, the counters are unavailable.
Performance limitations. An enclave developer
could attempt to use SGX counters as a rollback pro-
tection mechanism. When an enclave needs to persis-
tently store an updated state, it can increment a counter,
include the counter value and identiﬁer to the sealed data,
and verify integrity of the stored data based on counter
value at the time of unsealing. However, such approach
may wear out the used non-volatile memory. Assuming
a system that updates one of the enclaves on the same
platform once every 250 ms, counters would become un-
usable in few days. Even with a modest update rate of
one increment per minute, the counters are exhausted in
two years. Services that need to process tens or hundreds
of transactions per second are not possible.
Weaker security model. According to Intel developer
forums [51], counter service is provided by the Manage-
ment Engine on the PCH (known as “south bridge” in
older architectures). However, to the best of our knowl-
edge, actual location of the non-volatile memory used to
store the counters is not publicly stated. Based on Intel
speciﬁcations [52, 53], the PCH typically does not host
non-volatile memory, but it is connected over an SPI bus
to a ﬂash memory that is also used by the BIOS. Since
Management Engine is an active component, communi-
cation between the processor and the Management En-
gine can be replay protected. However, the SPI ﬂash is
a passive component, and therefore any counter stored
there is likely to be vulnerable to bus tapping and ﬂash
mirroring attacks, as recently demonstrated in the case
of mobile devices (inspired by FBI iPhone unlocking de-
bate) [22]. Although the precise storage location of SGX
counters remains unknown at the time of writing, it is
clear that if the integrity of enclave data relies on the
SGX counter feature, then additional hardware compo-
nents besides the processor must be considered trusted.
This is a signiﬁcant shift from the enclave execution pro-
tection model, where the security perimeter is the pro-
cessor package [48, p. 30].
Other concerns. The current design of SGX counter
APIs makes safe programming difﬁcult. To demonstrate
this we outline a subtle rollback attack. Assume an en-
clave that at the beginning of its execution checks for the
existence of sealed state, and if one is not provided by
the OS, it creates a new state and counter, and stores the
state sealed together with the counter value and identi-
ﬁer. The enclave increments the counter after every state
update. Later, the OS no longer provides a sealed state
to the restarted enclave. The enclave assumes that this
is its ﬁrst execution and creates a new (second) counter
and new state. Recall that the SGX APIs do not allow
checking existence of previous counter. The enclave up-
dates its state again. Finally, the OS replays a previous
sealed state associated with the ﬁrst counter. A careful
developer can detect such attacks by creating and delet-
ing 256 counters (an operation that takes two minutes)
to check if a previous counter, and thus sealed state, ex-
ists. A crash before counter deletion would render that
particular enclave permanently unusable.
We have no good explanation why a connection to an
Intel server is needed after the PSW reinstall. Similarly,
we do not know why the SGX counters become unavail-
able after BIOS battery removal or PSW reinstall.
The above attack and availability issues probably
could be ﬁxed with better design of SGX APIs and sys-
tem services, but the performance limitations and the
weaker security model are hard to avoid in future ver-
sions of the SGX architecture.
SGX trusted time. Another recently introduced and
optional SGX feature is the trusted time service [24]. As
in the case of SGX counters, also the time service is pro-
vided by the Management Engine. The trusted time ser-
vice allows an enclave developer to query a time stamp
that is relative to a reference point. The function returns
a nonce in addition to the timestamp, and according to
the Intel documentation, the timestamp can be trusted as
long as the nonce does not change [24].
We tested the time service and noticed that the pro-
vided nonce remained same across platform reboots. Re-
installing PSW resulted in a different nonce, but the pro-
vided time was still correct. The reference point is the
standard Unix time. As a rollback protection mecha-
nism the trusted time service is of limited use. Includ-
ing a timestamp to each sealed data version allows an
enclave to distinguish which out of two seals is more re-
cent. However, the enclave cannot know if the sealed
data provided by the OS is fresh and latest.
1306    26th USENIX Security Symposium
USENIX Association