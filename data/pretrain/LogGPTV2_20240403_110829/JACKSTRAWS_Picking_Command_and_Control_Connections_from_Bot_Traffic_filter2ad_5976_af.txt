[2] D. Balzarotti, M. Cova, C. Karlberger, E. Kirda, C. Kruegel, and
G. Vigna. Efﬁcient Detection of Split Personalities in Malware.
In Symp. Network & Distributed System Security (NDSS), 2010.
[3] H. Bunke, P. Foggia, C. Guidobaldi, and M. Vento. Graph Clus-
tering Using the Weighted Minimum Common Supergraph. In
Graph Based Representations in Pattern Recognition, 2003.
[4] M. Christodorescu and S. Jha. Testing Malware Detectors. In
ACM Int. Symp. on Software Testing & Analysis (ISSTA), 2004.
[5] M. Christodorescu, S. Jha, and C. Kruegel. Mining speciﬁcations
of malicious behavior. In Meeting of the European Software En-
gineering Conf. & the SIGSOFT Symp. Foundations of Software
Engineering, 2007.
[6] D. Conte, P. Foggia, and M. Vento. Challenging complexity
of maximum common subgraph detection algorithms: A perfor-
mance analysis of three algorithms on a wide database of graphs.
Journal of Graph Algorithms & Applications, 11(1), 2007.
[7] E. Cooke, F. Jahanian, and D. McPherson.
The Zombie
Roundup: Understanding, Detecting, and Disrupting Botnets. In
USENIX Workshop Steps to Reducing Unwanted Trafﬁc on the
Internet Workshop (SRUTI), 2005.
[8] D. Dagon, G. Gu, C. Lee, and W. Lee. A Taxonomy of Bot-
net Structures. In Annual Computer Security Applications Conf.
(ACSAC), 2007.
[9] A. Dinaburg, P. Royal, M. I. Sharif, and W. Lee. Ether: Malware
Analysis Via Hardware Virtualization Extensions. In ACM Conf.
Computer & Communications Security (CCS), 2008.
[10] P. Fogla and W. Lee. Evading Network Anomaly Detection Sys-
In ACM
tems: Formal Reasoning and Practical Techniques.
Conf. Computer & Communications Security (CCS), 2006.
[11] P. Fogla, M. I. Sharif, R. Perdisci, O. Kolesnikov, and W. Lee.
Polymorphic Blending Attacks. In Usenix Security Symp., 2006.
[12] S. Forrest, S. Hofmeyr, A. Somayaji, and T. A. Longstaff. A
In IEEE Symp. Security &
Sense of Self for Unix Processes.
Privacy, 1996.
[13] M. Fredrikson, S. Jha, M. Christodorescu, R. Sailer, and X. Yan.
Synthesizing near-optimal malware speciﬁcations from suspi-
cious behaviors. In IEEE Symp. Security & Privacy, 2010.
[14] F. C. Freiling, T. Holz, and G. Wicherski. Botnet Tracking:
Exploring a Root-Cause Methodology to Prevent Distributed
Denial-of-Service Attacks. In European Symp. Research in Com-
puter Security (ESORICS), 2005.
[15] J. Goebel and T. Holz. Rishi: Identify Bot Contaminated Hosts
by IRC Nickname Evaluation. In USENIX Workshop Hot Topics
in Understanding Botnets (HotBots), 2007.
[16] G. Gu, R. Perdisci, J. Zhang, and W. Lee. BotMiner: Clus-
tering Analysis of Network Trafﬁc for Protocol- and Structure-
Independent Botnet Detection. In USENIX Security Symp., 2008.
[17] G. Gu, P. Porras, V. Yegneswaran, M. Fong, and W. Lee. BotH-
unter: Detecting Malware Infection Through IDS-Driven Dialog
Correlation. In USENIX Security Symp., 2006.
[18] G. Gu, J. Zhang, and W. Lee. BotSniffer: Detecting Botnet Com-
mand and Control Channels in Network Trafﬁc. In Symp. Net-
work & Distributed System Security (NDSS), 2008.
[19] T. Holz, M. Steiner, F. Dahl, E. Biersack, and F. C. Freiling.
Measurements and Mitigation of Peer-to-Peer-based Botnets: A
Case Study on Storm Worm. In Usenix Workshop Large-Scale
Exploits & Emergent Threats (LEET), 2008.
[20] International Secure Systems Lab. Anubis: Analyzing Unknown
Binaries. http://anubis.iseclab.org, 2011.
[21] G. Jacob, E. Filiol, and H. Debar. Functional polymorphic en-
gines: formalisation, implementation and use cases. Journal in
Computer Virology, 5(3):247–261, 2009.
[22] J. P. John, A. Moshchuk, S. D. Gribble, and A. Krishnamurthy.
Studying Spamming Botnets Using Botlab. In USENIX Symp.
Networked Systems Design & Implementation (NSDI), 2009.
[23] A. Kalafut, A. Acharya, and M. Gupta. A Study of Malware
In ACM SIGCOMM Conf. Internet
in Peer-to-Peer Networks.
Measurement, 2006.
[24] G. Karypis. CLUTO - A Clustering Toolkit. Technical Report
02-017, University of Minnesota, 2003.
[25] H.-A. Kim and B. Karp. Autograph: Toward Automated, Dis-
tributed Worm Signature Detection. In USENIX Security Symp.,
2004.
[26] C. Kolbitsch, P. Milani Comparetti, C. Kruegel, E. Kirda,
X. Zhou, and X. Wang. Effective and Efﬁcient Malware De-
tection at the End Host. In USENIX Security Symp., 2009.
[27] C. Kreibich and J. Crowcroft. Honeycomb: Creating Intrusion
Detection Signatures Using Honeypots. ACM SIGCOMM Com-
puter Communication Review, 34(1), 2004.
[28] W. Lee, S. J. Stolfo, and K. W. Mok. A Data Mining Framework
for Building Intrusion Detection Models. In IEEE Symp. Security
& Privacy, 1999.
[29] Z. Li, M. Sanghi, Y. Chen, M.-Y. Kao, and B. Chavez. Hamsa:
Fast Signature Generation for Zero-day PolymorphicWorms with
Provable Attack Resilience. In IEEE Symp. Security & Privacy,
2006.
[30] A. Moser, C. Kruegel, and E. Kirda. Exploring Multiple Exe-
cution Paths for Malware Analysis. In IEEE Symp. Security &
Privacy, 2007.
[31] J. Newsom, B. Karp, and D. Song. Polygraph: Automatically
Generating Signatures for Polymorphic Worms. In IEEE Symp.
Security & Privacy, 2005.
[32] S. Peisert, M. Bishop, S. Karin, and K. Marzullo. Analysis of
Computer Intrusions Using Sequences of Function Calls. IEEE
Trans. Dependable Secur. Comput., 4(2), 2007.
[33] R. Perdisci, D. Dagon, W. Lee, P. Fogla, and M. I. Sharif. Mis-
leading worm signature generators using deliberate noise injec-
tion. In IEEE Symp. Security & Privacy, 2006.
[34] R. Perdisci, W. Lee, and N. Feamster. Behavioral Clustering
of HTTP-based Malware and Signature Generation Using Ma-
licious Network Traces. In USENIX Symp. Networked Systems
Design & Implementation (NSDI), 2010.
[35] P. Porras, H. Sa¨ıdi, and V. Yegneswaran. A Foray into Conﬁckers
Logic and Rendezvous Points. In Usenix Workshop Large-Scale
Exploits & Emergent Threats (LEET), 2009.
[36] N. Provos, P. Mavrommatis, M. A. Rajab, and F. Monrose. All
Your iFRAMEs Point to Us. In USENIX Security Symp., 2008.
[37] M. Rajab, J. Zarfoss, F. Monrose, and A. Terzis. A Multifaceted
Approach to Understanding the Botnet Phenomenon. In Internet
Measurement Conference (IMC), 2006.
[38] E. J. Schwartz, T. Avgerinos, and D. Brumley. All You Ever
Wanted to Know about Dynamic Taint Analysis and Forward
Symbolic Execution (but Might Have Been Afraid to Ask). In
IEEE Symp. Security & Privacy, 2010.
[39] S. Singh, C. Estan, G. Varghese, and S. Savage. Automated
Worm Fingerprinting. In USENIX Symp. Operating Systems De-
sign & Implementation (OSDI), 2004.
[40] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager, M. G. Kang,
Z. Liang, J. Newsome, P. Poosankam, and P. Saxena. BitBlaze:
A New Approach to Computer Security via Binary Analysis. In
Int. Conf. Information Systems Security (ICISS), 2008.
[41] E. Stinson and J. C. Mitchell. Characterizing Bots’ Remote Con-
trol Behavior. In Conf. Detection of Intrusions and Malware &
Vulnerability Assessment (DIMVA), 2007.
[42] B. Stone-Gross, A. Moser, C. Kruegel, and E. Kirda. FIRE: FInd-
ing Rogue nEtworks. In Annual Computer Security Applications
Conf. (ACSAC), 2009.
[43] P. Szor. The Art of Computer Virus Research and Defense. Ad-
dison Wesley, 2005.
[44] C. Willems, T. Holz, and F. Freiling. CWSandbox: Towards
Automated Dynamic Binary Analysis. IEEE Security & Privacy,
5(2), 2007.
[45] P. Wurzinger, L. Bilge, T. Holz, J. G¨obel, C. Kruegel, and
E. Kirda. Automatically generating models for botnet detection.
In European Symp. Research in Computer Security (ESORICS),
2009.
[46] X. Yan, H. Cheng, J. Han, and P. S. Yu. Mining Signiﬁcant
In ACM SIGMOD Int. Conf.
Graph Patterns by Leap Search.
Management of Data, 2008.
[47] X. Yan and J. Han. gSpan: Graph-Based Substructure Pattern
Mining. In Int. Conf. Data Mining (ICDM), 2002.
[48] X. Yan and J. Han. CloseGraph: mining closed frequent graph
patterns. In ACM SIGKDD Int. Conf. Knowledge Discovery &
Data Mining (KDD), 2003.
[49] T.-F. Yen and M. K. Reiter. Trafﬁc Aggregation for Malware
Detection. In Conf. Detection of Intrusions and Malware, & Vul-
nerability Assessment (DIMVA), 2008.
[50] Y. Zhao and G. Karypis. Evaluation of hierarchical clustering
algorithms for document datasets. In ACM Conf. Information &
Knowledge Management (CIKM), 2002.
A Graph Labeling and Abstraction
Nodes and edges that are inserted into the behavior
graph are augmented with additional labels that capture
more information about the nature of the system calls
and the dependencies between nodes. In the following,
we describe this labeling in greater detail. For edges,
a label stores the names of the input and output argu-
ments, respectively, of the system calls that are con-
nected through a data dependency. In case of a node,
the label stores the system call name and some optional
information that depends on the speciﬁc type of call.
As shown in Table 1, the additional information can
correspond to the type of the resource (ﬁles, registry
keys, ...) that a system call operates on as well as ﬂags
(such as mode or permission bits for ﬁle operations).
Note that some information is only stored as comments;
this information is ignored for the template generation
and matching, but is saved for a human analyst who
might want to examine a template.
Operations
Label
Comment
File
Location, Type (Table 2),
Access, Attributes,
CreateDisposition
File name
Registry
Key name,
Value name
Network
Port
IP address
Table 1: Selected information for labels and comments.
One important additional piece of information stored
for system calls that manipulate ﬁles and registry keys is
the name of these ﬁles and keys. However, for these re-
source names, it is not desirable to use the actual string.
The reason is that labels are taken into account during
the matching process, and two nodes are considered the
same only when their labels match. Thus, some type of
abstraction is necessary for labels that represent resource
names, otherwise, graphs become too speciﬁc.
In the case of ﬁles, the name string is split into three
parts: the path representing the location of the ﬁle, the
short name of the ﬁle and its extension. Table 2 shows
how the paths, short names and extensions are mapped
to several generic classes of location and type, that are
then used for the ﬁle name label. Similarly, the registry
key names are split into two parts: the location of the key
and its short name. The location is ﬁrst normalized using
the standard registry abbreviations (HKLM, HKU, HKCU,
HKCR). The short key name is then confronted to generic
types (number, path, url). If the name does not comply
with any format, but still shows a high number of simi-
lar close variations, a generic type random is attributed.
Additional examples of this abstraction process can be
observed in the examples of template of the next section.
B Template Examples
We manually examined C&C templates to determine
whether they capture activity that a human analyst would
consider malicious. We now present two examples that
were automatically generated by JACKSTRAWS.
Figure 4 shows a template we extracted from bots
that use a proprietary, binary protocol for communicat-
ing with the C&C server. The behavior corresponds to
some kind of information leakage: the samples query the
Location
InWindowsDirectory\
InSystemDirectory\
InDocumentDirectory\
InStartupDirectory\
InTemporaryDirectory\
InInternetDirectory\
InProgramDirectory\
File Path
\Windows\
\Windows\System*\
\Documents and Settings\
\Documents and Settings\*\Startup\
\Documents and Settings\*\Local Settings\Temp\
\Documents and Settings\*\Local Settings\Temporary Internet Files\
\Program Files\
Type
IsExecutable
IsDynamicLibrary
IsDriver
IsConﬁguration
IsWebPage
IsScript
IsCookie
IsDevice
IsNetworkDevice
Extension
*.exe
*.dll
*.sys, *.drv
*.ini, *.cfg
*.htm, *.php, *.xml
*.js, *.vbs
\Cookies\*@*.txt
\Device\
\Device\AfdEndPoint
Table 2: File abstraction based on location and type.
Figure 5: Template that describes the download and execute functionality of a bot: an executable ﬁle is created, its
content is downloaded from the network, decoded, written to disk, its information is modiﬁed before being executed.
In the NtCreateFile node, the ﬁle name ldr.exe is only mentioned as a comment. Comments help a human analyst
when looking at a template, but they are ignored by the matching.
registry for the computer name and send this information
via the network to a server. We consider this a malicious
activity, which is often used by bots to generate a unique
identiﬁer for an infected machine. In the network trafﬁc
itself this activity cannot be easily identiﬁed, since the
samples use their own protocol.
As another example, consider the template shown in
Figure 5. This template corresponds to the download &
execute behavior, i.e., data is downloaded from the net-
work, written to disk, and then executed. The template
describes this speciﬁc behavior in a generic way.
Figure 4: Template that describes leaking of sensitive
data. Darker nodes constitute the template core, whereas
lighter ones are optional.
systemcall: recv  network: connectport: 443#ip=193.23.126.55#ip=94.75.255.138 arg: ip=buf  systemcall: NtCreateFileFilename: inProgramDirectory\isExecutableDesiredAccess: FileReadAttributesAttributes: AttributeNormalCreateDisposition: FileSupersede#Filename=\??\C:\Program Files\temp\ldr.exe arg: ObjectAttributes=buf  systemcall: NtCreateFileFilename: inProgramDirectory\isExecutableDesiredAccess: FileReadAttributes | FileWriteAttributesAttributes: AttributeNormalCreateDisposition: FileSupersede#Filename=\??\C:\Program Files\temp\ldr.exe arg: ObjectAttributes=buf  network: recvCollapse: isMultiple  arg: Socket=Socket  systemcall: NtAllocateVirtualMemory*: *  arg: ObjectAttributes=RegionSize  systemcall: NtDeviceIoControlFile*: *  arg: InputBuﬀer=buf  systemcall: NtWriteFile*: *  arg: Buﬀer=buf arg: Length=buf  systemcall: NtSetInformationFileCollapse: isMultiple  arg: FileInformation=buf  process: start   arg: buf=buf   arg: FileHandle=FileHandle   arg: FileHandle=FileHandle  network: send  systemcall: NtQueryValueKeyValuename: ComputerName  arg: buf=KeyValueInformation  systemcall: NtOpenKeyKeyname: hklm\system\currentcontrolset\control\computername\activecomputername#Keyname: HKLM\System\CurrentControlSet\Control\ComputerName\ActiveComputerName arg: KeyHandle=KeyHandle  systemcall: NtOpenKeyKeyname: hklm\system\currentcontrolset\control\computername#Keyname: \Registry\Machine\System\CurrentControlSet\Control\ComputerName arg: ObjectAttributes=KeyHandle  network: connectport: *  Socket=Socket