were contributed by domain names. Note that, without Tiger’s IPE,
simply searching strings that look like hostnames and using them
as imprints may not get the 10.10% increase since some hostnames
are dynamically generated from the code. We also compare the
app coverage between those from legitimate markets and PHAs
from Virustotal. Interestingly, only 39.24% PHAs can be covered by
the prior approach [39], while Tiger improves the rate to 66.32%.
Looking into the improvement, we found that Tiger is capable of
(cid:128)nding new types of invariants within tra(cid:129)c which helped detect
additional apps. We provide the details about these new imprints
in Section 5. We also note that, although the PHA coverage is in-
creased while compared with previous approaches, it is still not as
high as the coverage of legitimate apps. (cid:140)is is mainly due to the
shared tokens among malware (e.g., potential harmful libraries [11]).
Since our goal is to distinguish each unique app from other, we
did not catch them in current implementation of Tiger. However,
it would not be di(cid:129)cult to enhance our approach to identify the
PHAs. For example, a straightforward way is to keep the shared
tokens between PHAs.
We are also curious of the reason why Tiger’s imprint missed
the detection of the rest 1,197 apps. To (cid:128)nd such reason, we have
to manually check the generated imprints and the corresponding
code in the apps. Considering that it is very hard to analyze all
the 1,197 apps, we randomly selected 100 apps (around 10%) from
them. And we found that 90 apps produce tra(cid:129)c tokens from
the shared libraries they integrate (which appears on the tra(cid:129)c
of any apps utilizing these libraries) and/or downloads resources
from generic domains like h(cid:138)p://qzone.qq.cn. (cid:140)ese tra(cid:129)c tokens
are not unique for a single app, hence cannot be used as imprints
for app identi(cid:128)cation. Excluding these 90 apps that do not have
identi(cid:128)able imprints, Tiger only missed 10 apps due to the limitation
of IPE on processing loops (see Section 6). In other words, for the
apps that can be (cid:128)ngerprinted (including 3,803 identi(cid:128)ed, and 120
(= 1197 × (10/100)) possible missed by Tiger), our approach caught
96.94% (= 3803/(3803 + 120)) of them.
Tra(cid:129)c coverage. Further we studied the tra(cid:129)c coverage which is
estimated using the percent of the packets that carry the imprints for
uniquely identifying these individual apps. (cid:140)is “tra(cid:129)c coverage”
ratio is important, as it is critical in determining how timely and
likely an app can be recognized from its network tra(cid:129)c. (cid:140)e more
packets emi(cid:138)ed by an app can be (cid:128)ngerprinted, the sooner and
more likely the app can be detected. Especially, when mobile users
walk from one networks (e.g., 4G and Wi-Fi) to another one and
some of their apps’ identi(cid:128)able packets could be missed by these
networks. Still, considering the cost of dynamic analysis, we use the
5,000 randomly sampled apps as those in app coverage evaluation.
In our experiment, we found 72.85% packets of the apps sampled
were detected using the imprints created by Tiger, while only 28.87%
could be identi(cid:128)ed by those generated by other approach [39], as
shown in Table 2. Again, this di(cid:130)erence (43.98%) is caused by other
types of invariants discovered by Tiger through partially executing
these apps’ sink related code. As a result, the apps become easier
to detect and more likely to identify using our new technique. In
order to understand the imprints’ coverage of truly identi(cid:128)able
packets, we further randomly selected 100 apps and manually in-
spected all 3,872 packets in their communication. Among them,
2,844 carried identi(cid:128)able imprints, with 2,803 packages caught by
the imprints from Tiger. Altogether, we conclude that Tiger is
capable of capturing 98.56% (= 2, 803/2, 844) of the packets car-
rying identi(cid:128)able invariants. (cid:140)is level of coverage even exceeds
what could be a(cid:138)ained with a perfect training set: assuming that all
URL-related invariants can be recovered from the perfect training
set using other prior approaches [14] which is hard in practice;
still the coverage that could possibly be achieved using package
names, Ad-IDs and also the learnt hostnames was found to be no
more than 62.71%, which is 10.14% below our approach, due to the
new invariable tokens discovered by Tiger never reported before
(see Section 5.2). Further, by looking into the 41 (= 2, 844 − 2, 803)
packets our approach missed, we found that in all these cases, the
IPE engine recovered most part of their imprints. What it did not
do right include one or two missing tokens caused by inaccurately
processing a loop (which our approach only unwinds one iteration)
that brings in erroneous invariants.
False detection. We also want to see how many apps were in-
correctly captured by the imprints generated by Tiger. Since this
evaluation does not need to dynamically run the apps, we used all
of the 200,000 apps that we collected in this evaluation. In detail,
we randomly selected 50,000 apps from 200,000 apps and generated
their imprints. (cid:140)en we checked the false detection using the rest
150,000 apps. (cid:140)at is, for every app in the rest 150,000 apps, we
checked whether it can be identi(cid:128)ed by the imprints from 50,000
apps. If the identi(cid:128)ed app is not the one that generates the imprint,
we view it as a false detection. Here, to judge whether two apps
Session D2:  Vulnerable Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA822Table 3: False detection
GooglePlay
360
Xiaomi
Huawei
Wandoujia
Anzhi
AppChina
ChinaTelecom
VirusTotal
All Apps
# Total Apps
20,028
4,651
450
2,702
936
2,927
637
1,731
122,953
152,897
#(%) False Detection
31 (0.155%)
17 (0.366%)
2 (0.444%)
20 (0.740%)
8 (0.856%)
11 (0.376%)
8 (1.256%)
29 (1.675%)
1,008 (0.820%)
1,134 (0.742%)
Table 4: Performance of IPE.
Total Time Cost
Avg Time Cost
# of Total Node
# of Avg Node
Full Slice
314 hours
226.380 s
155,839,237
31,168
Coarse Slice
134 hours
96.482 s
101,082,209
20,216
Tiger
25 hours
18.227 s
9,214,422
1,843
are the same, we performed a strict rule: if the two apps have dif-
ferent MD5 values, we view them as di(cid:130)erent apps. Considering
that we have removed the redundant apps with the same MD5 in
our dataset, any identi(cid:128)ed app from the 150,000 apps should be a
false detection. Based on this strict rule, we found that the false
detection rate is only 0.742%. We also measured the false detection
rate for each market (in Table 3). For the apps from Google Play,
the false detection rate is very low (only 0.155%). We also found
the apps from some Chinese markets have high false detection rate.
(cid:140)is may be due to the repackaged apps, which are mis-identi(cid:128)ed
by the imprints of the original apps.
Impact of dead code. Some imprints from Tiger may not match
any app’s tra(cid:129)c, since their corresponding network sinks may sit
in a chunk of dead code. In our research, we estimated the ratio of
such non-functioning imprints by running a reachability test on
the sinks of the randomly selected 5,000 apps. Among the 9,488
network sinks discovered from these apps, 2,005 (21.13%) of them
could not be reached from any entry point. Note that imprints pro-
duced by our approach are supposed to be used in NGFW, which
is optimized to (cid:128)lter tra(cid:129)c with a large number of signatures. Re-
dundant signatures of a moderate scale (such as 21.13%) only have
a marginal impact on the (cid:128)rewall’s performance. (cid:140)erefore, we
did not integrate into our implementation any mechanism for dead
code removal.
4.3 Performance
Tiger is designed for discovering app tra(cid:129)c imprints on a massive
scale. Key to this mission is high performance, which our unique
design, the IPE in particular, strives to achieve. Here we report
our e(cid:130)ort to understand whether the new technique is indeed up
to this high performance expectation, compared with its more
straightforward alternative [32]. (cid:140)is evaluation was conducted on
the randomly selected 5,000 apps from our dataset.
Bene(cid:128)t of IPE. We ran Tiger against the conventional slicing and
execution approach, as proposed by the prior research [32]. In the
experiment, we set the timeouts in both approaches to 10 minutes.
(cid:140)e results of this study are presented in Table 4. As we can see
here, the total time the conventional approach, which requires a
full slicing, took to process all these apps is 314 hours on one of
server with 20 cores. In contrast, our IPE technique spent merely
Figure 5: Performance increase between instantiated slicing
and full slicing regarding to app size.
25 hours going through all these apps. On average, our approach
needed 18 seconds per app, while the conventional counterpart took
226 seconds7. Table 4 further shows the number of pruned nodes
from full slices. As we can see, on average, 94.09% (= (31, 168 −
1, 843)/31, 168) of nodes on a slice were pruned by the IPE, which
resulted in a signi(cid:128)cant enhancement of the performance. Overall,
Tiger achieved 12.42× (= 226.38s/18.227s) speed-up compared with
the conventional approach.
App sizes. We also compare the performance increase between
instantiated slicing and full slicing regarding to app sizes (Figure 5).
From the (cid:128)gure, we found the performance of Tiger increases more
when an app has a larger size.
5 MEASUREMENT
By analyzing the tra(cid:129)c tokens derived from the code of over 200,000
real-world applications, a scale never a(cid:138)ained before for this type
of research, we were able to gain an unprecedented understanding
of these imprints and their connections with today’s Android apps,
including their uniqueness and e(cid:130)ectiveness in app identi(cid:128)cation,
their relations with an app’s functionalities and the conditions for
triggering their related network tra(cid:129)c. Particularly, in addition to
known invariants, we discovered other unexpected types of content
that uniquely characterize a large number of popular apps. Further,
from the content of some invariants, we could even (cid:128)gure out an
app’s operation environments (e.g., the permissions possessed by a
library’s host app). Our study also shows that the tra(cid:129)c involving
some highly identi(cid:128)able imprints cannot be easily triggered by
automatic exploration tools like monkeyrunner, though the related
functionalities can probably be invoked by human users frequently.
5.1 Landscape
Imprint generation. From the 203,864 apps, 181,582 apps have
network sinks, and among them, Tiger discovered 392,645 imprints
in total, as summarized in Table 5. Except the PHAs from VirusTo-
tal, the apps from other sources, including Google Play and other
third-party marketplaces, all have very high identi(cid:128)cation rates:
7 (cid:140)e time is di(cid:130)erent from that reported in the prior work (150 seconds) [32]. (cid:140)is
is mainly because the sinks that Tiger cares (HTTP-related APIs) is much more than
that of HARVESTER (SMS-related APIs). Also, to be fair, we did not let HARVESTER
use Soot to slice, which is known to be slow. We re-implement the slicing algorithm
using the same technique as our IPE.
8.3811.8114.2916.1714.0729.1433.5036.800510152025303540123456780               500          1000          1500          2000          2500          3000         3500          4000App Dexsize(KB)Time performance increaseSession D2:  Vulnerable Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA823Table 5: Apps and their imprints
(Note that most unidenti(cid:128)ed apps are repackaged ones, which do not have unique imprints and are not identi(cid:128)able from their tra(cid:129)c.)
# Imprints per App
# (%) Apps Having Tra(cid:129)c
# (%) Identi(cid:128)able Apps
# Total Apps
# Imprints
GooglePlay
360
Xiaomi
Huawei
Wandoujia
Anzhi
AppChina
ChinaTelecom
VirusTotal
All Apps
25,750
6,177
600
3,592
1,235
3,891
848
2,290
159,481
203,864
25,183 (97.80%)
5,986 (96.91%)
585 (97.50%)
3,483 (96.97%)
1,160 (93.93%)
3,829 (98.41%)
821 (96.82%)
2,122 (92.66%)
138,413 (86.79%)
181,582 (89.07%)
24,753 (98.29%)
5,830 (97.39%)
571 (97.61%)
3,423 (98.28%)
1,113 (95.95%)
3,751 (97.96%)
769 (93.67%)
2,007 (94.58%)
97,748 (70.62%)
139,965 (77.08%)
89,678