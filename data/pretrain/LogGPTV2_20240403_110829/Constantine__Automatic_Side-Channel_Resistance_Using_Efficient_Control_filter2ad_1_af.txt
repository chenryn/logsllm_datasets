nested flows
(w/o cloning)
39
31
138
91
cycles (M)
1.6
2.6
2.9
33
w/ cloning
864
638 (16.35x)
33 (12.7x)
1.08
w/ cloning
nested (tainted)
1046 (118)
863 (139)
2898 (52)
1892 (2)
binary size (KB)
39
39
47
638
The library supports Elliptic Curve (EC) cryptography, which
is appealing as it allows smaller keys for equivalent guarantees of
non-EC designs (e.g. RSA) [69]. EC Digital Signature Algorithms
(ECDSA) are among the most popular DSA schemes today, yet their
implementations face pitfalls and vulnerabilities that threaten their
security, as shown by recent attacks such as LadderLeak [12] (tar-
geting the Montgomery ladder behind the EC scalar multiplication
in ECDSA) and CopyCat [49] (targeting the vulnerable hand-crafted
constant-time (CT) wolfSSL ECDSA code).
In this section, we harden with Constantine the mulmod modu-
lar multiplication procedure in ECDSA from the non-CT wolfSSL
implementation. This procedure calculates a curve point k × G,
where k is a crypto-secure nonce and G is the EC base point. Leaks
involving k bits have historically been abused in the wild for, e.g.,
stealing Bitcoin wallets [2] and hacking consoles [1].
Code Features and Analysis. The region to protect comprises 84
functions from the maximal tree that mulmod spans in the call graph.
We generate a profiling set of 1024 random inputs with 256-bit key
length and identify sensitive branches, loops, and memory accesses
(Table 2). The analysis of loops is a good example of how unrolling is
unpractical. We found an outer loop iterating over the key bits, then
1 inner loop at depth 1, 4 at depth 2, and 3 at depth 3 (all within the
same outer loop). Every inner loop iterates up to 4 times, resulting
in a nested structure—and potential unroll factor—of 61,440. And
this calulation is entirely based on profiling information, the inner
loops are actually unbounded from static analysis.
Similarly, cloning is crucial for the accuracy of DFL. We profiled
the object sets accessed at each program point with our DBI tool
(§6). With cloning, on average, a protected access over-strides (i.e.,
striding bytes that the original program would not touch) by as
little as 8% of the intended storage. Without cloning, on the other
hand, points-to sets are imprecise enough that DFL needs to make
as many as 6.29x more accesses than strictly needed.
Overheads. Table 2 presents our run-time performance overhead
results, measured and reported in the same way as our earlier
benchmark experiments. As shown in the table, the slowdown
compared to the original non-CT baseline of wolfSSL (using the
compilation parameter W=1) is 12.7x, which allows the Constan-
tine-instrumented version to complete a full run in 8 ms. The
compilation parameter W allows the non-CT version to use differ-
ent double-and-add interleavings over the key bits as part of its
sliding window-based double-and-add approach to implement ECC
multiplication. In brief, a higher W value trades run-time storage
(growing exponentially with W) with steady-state throughput (in-
creasing linearly with W), but also alters the code generated, due to
snowball optimization from inlined constants. This choice turns out
to be cost-effective in the non-CT world, but not for linearization.
For completeness, we also show results for the best configuration
of the non-CT version (which we profiled to be W=4) and the hand-
written CT version of wolfSSL. The non-CT code completes an ECC
multiplication in 0.35 ms in its best-performing scenario, while the
hand-written CT version completes in 0.7 ms. Our automatically
hardened code completes in 8ms, that is within a 11.42x factor of
the hand-written CT version, using 11.38x more CPU cycles, yet
with strong security guarantees for both control and data flows
from the articulate computation (i.e., 84 functions) involved.
In terms of binary size increase, with cloning we trade space
usage for DFL performance. We obtain a 16.36x increase compared
to the reference non-CT implementation, and 13.57x higher size
than the CT version. The performance benefits from cloning are
obvious (77x/12.7x=6.06x end-to-end speedup) and the size of the
binary we produce is 638 KB, which, in absolute terms is accept-
able, but amenable to further reduction. In particular, the nature of
wolfSSL code is tortured from a cloning perspective: it comprises
36 arithmetic helper functions that we clone at multiple usage sites.
We measured, however, that in several cases they are invoked in
function instances (which now represents distinct calling contexts
for the original program) that see the same points-to information.
Hence, after cloning, one may attempt merging back functions from
calling contexts that see the same points-to set, saving a relevant
fraction of code boat without hampering DFL performance.
Other optimizations, such as our DFL loop optimization also
yields important benefits, removing unnecessary striding in some
loops—without it, the slowdown would more than double (27.1x).
We conclude by reporting a few statistics on analysis and compila-
tion time. The profiling stage took 10m34s, the points-to analysis
20s (~2s w/o cloning), and the end-to-end code transformation and
compilation process 1m51s (31s for the non-CT reference).
Overall, our results confirm that Constantine can effectively
handle a real-world crypto library for the first time, with no anno-
tations to aid compatibility and with realistic compilation times,
binary sizes, and run-time overheads. Constantine’s end-to-end
run-time overhead, in particular, is significantly (i.e., up to two or-
ders of magnitude) lower than what prior comprehensive solutions
like Raccoon [53] have reported on much simpler benchmarks.
8 CONCLUSION
We have presented Constantine, an automatic constant-time sys-
tem to harden programs against microarchitectural side channels.
Thanks to carefully designed compiler transformations and opti-
mizations, we devised a radical design point—complete linearization
of control and data flows—as an efficient and compatible solution
that brings security by construction, and can handle for the very
first time a production-ready crypto library component.
ACKNOWLEDGEMENTS
We thank our shepherd Qi Li and the anonymous reviewers for
their valuable feedback. This work was supported by the European
Union’s Horizon 2020 research and innovation programme under
grant agreements No. 786669 (ReAct) and 825377 (UNICORE), and
by Intel Corporation through the Side Channel Vulnerability ISRA.
Session 3A: Side Channel CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea726REFERENCES
[1] 2010. Console Hacking 2010. (Dec. 2010). https://fahrplan.events.ccc.de/congress/
2010/Fahrplan/events/4087.en.html
[2] 2013. Bitcoin - Android Security Vulnerability. (Aug. 2013). https://bitcoin.org/
en/alert/2013-08-11-android
[3] 2015. The M/o/Vfuscator.
movfuscator
(Oct. 2015).
https://github.com/xoreaxeaxeax/
[4] 2019. RISC-V "V" Vector Extension.
documents/riscv-v-spec/riscv-v-spec.pdf
(Nov. 2019).
https://riscv.github.io/
[5] 2020. Google Publishes Latest Linux Core Scheduling Patches So Only Trusted
Tasks Share A Core. (Nov. 2020). https://www.phoronix.com/scan.php?page=
news_item&px=Google-Core-Scheduling-v9#:~:text=Google%20engineer%
20Joel%20Fernandes%20sent,against%20the%20possible%20security%20exploits
[6] Johan Agat. 2000. Transforming out Timing Leaks. In Proceedings of the 27th ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (Boston,
MA, USA) (POPL ’00). Association for Computing Machinery, New York, NY,
USA, 40–53. https://doi.org/10.1145/325694.325702
[7] Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. 2006. Compil-
ers: Principles, Techniques, and Tools (2nd Edition). Addison-Wesley Longman
Publishing Co., Inc., USA.
[8] A. C. Aldaya, B. B. Brumley, S. ul Hassan, C. Pereida García, and N. Tuveri. 2019.
Port Contention for Fun and Profit. In 2019 IEEE Symposium on Security and
Privacy (SP). 870–887. https://doi.org/10.1109/SP.2019.00066
[9] Lars Ole Andersen. 1994. Program Analysis and Specialization for the C Program-
ming Language. Ph.D. Dissertation.
[10] Marc Andrysco, David Kohlbrenner, Keaton Mowery, Ranjit Jhala, Sorin Lerner,
and Hovav Shacham. 2015. On Subnormal Floating Point and Abnormal Timing.
In Proceedings of the 2015 IEEE Symposium on Security and Privacy (SP ’15). IEEE
Computer Society, USA, 623–639. https://doi.org/10.1109/SP.2015.44
[11] Marc Andrysco, Andres Nötzli, Fraser Brown, Ranjit Jhala, and Deian Stefan.
2018. Towards Verified, Constant-Time Floating Point Operations. In Proceedings
of the 2018 ACM SIGSAC Conference on Computer and Communications Security
(Toronto, Canada) (CCS ’18). Association for Computing Machinery, New York,
NY, USA, 1369–1382. https://doi.org/10.1145/3243734.3243766
[12] Diego F. Aranha, Felipe Rodrigues Novaes, Akira Takahashi, Mehdi Tibouchi,
and Yuval Yarom. 2020. LadderLeak: Breaking ECDSA with Less than One Bit of
Nonce Leakage. In Proceedings of the 2020 ACM SIGSAC Conference on Computer
and Communications Security (CCS ’20). Association for Computing Machinery,
New York, NY, USA, 225–242. https://doi.org/10.1145/3372297.3417268
[13] G. Barthe, B. Grégoire, and V. Laporte. 2018. Secure Compilation of Side-Channel
Countermeasures: The Case of Cryptographic ”Constant-Time”. In 2018 IEEE 31st
Computer Security Foundations Symposium (CSF). 328–343. https://doi.org/10.
1109/CSF.2018.00031
[14] Erik Bosman, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2016. Dedup
Est Machina: Memory Deduplication as an Advanced Exploitation Vector. In 2016
IEEE Symposium on Security and Privacy (SP). 987–1004. https://doi.org/10.1109/
SP.2016.63
[15] Claudio Canella, Daniel Genkin, Lukas Giner, Daniel Gruss, Moritz Lipp, Ma-
rina Minkin, Daniel Moghimi, Frank Piessens, Michael Schwarz, Berk Sunar, Jo
Van Bulck, and Yuval Yarom. 2019. Fallout: Leaking Data on Meltdown-Resistant
CPUs. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and Com-
munications Security (CCS ’19). Association for Computing Machinery, New York,
NY, USA, 769–784. https://doi.org/10.1145/3319535.3363219
[16] Sunjay Cauligi, Craig Disselkoen, Klaus v. Gleissenthall, Dean Tullsen, Deian
Stefan, Tamara Rezk, and Gilles Barthe. 2020. Constant-Time Foundations for
the New Spectre Era. In Proc. of the 41st ACM SIGPLAN Conf. on Programming
Language Design and Implementation (PLDI 2020). Association for Computing Ma-
chinery, New York, NY, USA, 913–926. https://doi.org/10.1145/3385412.3385970
[17] Sunjay Cauligi, Gary Soeller, Brian Johannesmeyer, Fraser Brown, Riad S. Wahby,
John Renner, Benjamin Grégoire, Gilles Barthe, Ranjit Jhala, and Deian Stefan.
2019. FaCT: A DSL for Timing-Sensitive Computation. In Proceedings of the 40th
ACM SIGPLAN Conference on Programming Language Design and Implementation
(PLDI 2019). ACM, 174–189. https://doi.org/10.1145/3314221.3314605
[18] Maxime Chevalier-Boisvert, Laurie Hendren, and Clark Verbrugge. 2010. Op-
timizing Matlab through Just-In-Time Specialization. In Compiler Construction,
Rajiv Gupta (Ed.). Springer Berlin Heidelberg, Berlin, Heidelberg, 46–65.
[19] Jeroen V. Cleemput, Bart Coppens, and Bjorn De Sutter. 2012. Compiler Mitiga-
tions for Time Attacks on Modern X86 Processors. ACM Trans. Archit. Code Optim.
8, 4, Article 23 (Jan. 2012), 20 pages. https://doi.org/10.1145/2086696.2086702
[20] Bart Coppens, Ingrid Verbauwhede, Koen De Bosschere, and Bjorn De Sutter. 2009.
Practical Mitigations for Timing-Based Side-Channel Attacks on Modern X86
Processors. In Proceedings of the 2009 30th IEEE Symposium on Security and Privacy
(SP ’09). IEEE Computer Society, USA, 45–60. https://doi.org/10.1109/SP.2009.19
[21] Lesly-Ann Daniel, Sébastien Bardin, and Tamara Rezk. 2020. Binsec/Rel: Efficient
Relational Symbolic Execution for Constant-Time at Binary-Level. In Proceedings
of the 2020 IEEE Symposium on Security and Privacy (SP ’20). IEEE Computer
Society.
[22] Daniele Cono D’Elia, Emilio Coppa, Simone Nicchi, Federico Palmaro, and
Lorenzo Cavallaro. 2019. SoK: Using Dynamic Binary Instrumentation for Se-
curity (And How You May Get Caught Red Handed). In Proc. of the 2019 ACM
Asia Conference on Computer and Communications Security (Asia CCS ’19). ACM,
15–27. https://doi.org/10.1145/3321705.3329819
[23] Daniele Cono D’Elia, Camil Demetrescu, and Irene Finocchi. 2011. Mining Hot
Calling Contexts in Small Space. In Proceedings of the 32nd ACM SIGPLAN Confer-
ence on Programming Language Design and Implementation (San Jose, California,
USA) (PLDI ’11). Association for Computing Machinery, New York, NY, USA,
516–527. https://doi.org/10.1145/1993498.1993559
[24] Daniele Cono D’Elia, Camil Demetrescu, and Irene Finocchi. 2016. Mining Hot
Calling Contexts in Small Space. Software: Practice and Experience 46, 8 (2016),
1131–1152. https://doi.org/10.1002/spe.2348
[25] Sushant Dinesh, Nathan Burow, Dongyan Xu, and Mathias Payer. 2020.
RetroWrite: Statically Instrumenting COTS Binaries for Fuzzing and Sanitization.
(2020).
[26] Travis Downs. 2020. Hardware Store Elimination. https://travisdowns.github.io/
blog/2020/05/13/intel-zero-opt.html.
[27] Andrea Fioraldi, Dominik Maier, Heiko Eißfeldt, and Marc Heuse. 2020. AFL++ :
Combining Incremental Steps of Fuzzing Research. In 14th USENIX Workshop on
Offensive Technologies (WOOT 20). USENIX Association.
[28] Christopher W. Fletcher, Marten van Dijk, and Srinivas Devadas. 2012. A Secure
Processor Architecture for Encrypted Computation on Untrusted Programs. In
Proceedings of the Seventh ACM Workshop on Scalable Trusted Computing (Raleigh,
North Carolina, USA) (STC ’12). Association for Computing Machinery, New
York, NY, USA, 3–8. https://doi.org/10.1145/2382536.2382540
[29] Christopher W Fletchery, Ling Ren, Xiangyao Yu, Marten Van Dijk, Omer Khan,
and Srinivas Devadas. 2014. Suppressing the oblivious ram timing channel while
making information leakage and program efficiency trade-offs. In 2014 IEEE 20th
International Symposium on High Performance Computer Architecture (HPCA).
IEEE, 213–224.
[30] Shuitao Gan, Chao Zhang, Peng Chen, Bodong Zhao, Xiaojun Qin, Dong Wu,
and Zuoning Chen. 2020. GREYONE: Data Flow Sensitive Fuzzing. In 29th
USENIX Security Symposium (USENIX Security 20). USENIX Association, 2577–
2594. https://www.usenix.org/conference/usenixsecurity20/presentation/gan
[31] Oded Goldreich and Rafail Ostrovsky. 1996. Software Protection and Simulation
on Oblivious RAMs. J. ACM 43, 3 (May 1996), 431?473. https://doi.org/10.1145/
233551.233553
[32] Ben Gras, Cristiano Giuffrida, Michael Kurth, Herbert Bos, and Kaveh Razavi.
2020. ABSynthe: Automatic Blackbox Side-channel Synthesis on Commodity
Microarchitectures. https://doi.org/10.14722/ndss.2020.23018
[33] Daniel Gruss, Julian Lettner, Felix Schuster, Olga Ohrimenko, Istvan Haller, and
Manuel Costa. 2017. Strong and Efficient Cache Side-Channel Protection Using
Hardware Transactional Memory. In Proceedings of the 26th USENIX Conference
on Security Symposium (SEC’17). USENIX Association, USA, 217–233.
[34] S. He, M. Emmi, and G. Ciocarlie. 2020. ct-fuzz: Fuzzing for Timing Leaks. In 2020
IEEE 13th International Conference on Software Testing, Validation and Verification
(ICST). 466–471. https://doi.org/10.1109/ICST46399.2020.00063
[35] Casen Hunger, Mikhail Kazdagli, Ankit Rawat, Alex Dimakis, Sriram Vishwanath,
and Mohit Tiwari. 2015. Understanding contention-based channels and using
them for defense. In 2015 IEEE 21st International Symposium on High Performance
Computer Architecture (HPCA). IEEE, 639–650.
[36] Intel. 2020. Guidelines for Mitigating Timing Side Channels Against Cryp-
tographic Implementations. Developer Zone - Secure Coding (2020).
https:
//software.intel.com/security-software-guidance/secure-coding/guidelines-
mitigating-timing-side-channels-against-cryptographic-implementations
[37] Taesoo Kim, Marcus Peinado, and Gloria Mainar-Ruiz. 2012. {STEALTHMEM}:
System-level protection against cache-based side channel attacks in the cloud. In
Presented as part of the 21st {USENIX} Security Symposium ({USENIX} Security
12). 189–204.
[38] Julian Kirsch, Clemens Jonischkeit, Thomas Kittel, Apostolis Zarras, and Claudia
Eckert. 2017. Combating Control Flow Linearization. In ICT Systems Security and
Privacy Protection, Sabrina De Capitani di Vimercati and Fabio Martinelli (Eds.).
Springer International Publishing, Cham, 385–398.
[39] P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas, M. Hamburg, M.
Lipp, S. Mangard, T. Prescher, M. Schwarz, and Y. Yarom. 2019. Spectre Attacks:
Exploiting Speculative Execution. In 2019 IEEE Symposium on Security and Privacy
(SP). 1–19. https://doi.org/10.1109/SP.2019.00002
[40] Moritz Lipp, Andreas Kogler, David Oswald, Michael Schwarz, Catherine Easdon,
Claudio Canella, and Daniel Gruss. 2021. PLATYPUS: Software-based Power
Side-Channel Attacks on x86. In IEEE S&P.
[41] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas,
Anders Fogh, Jann Horn, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval
Yarom, and Mike Hamburg. 2018. Meltdown: Reading Kernel Memory from
User Space. In Proceedings of the 27th USENIX Conference on Security Symposium
(Baltimore, MD, USA) (SEC’18). USENIX Association, USA, 973–990.
[42] Chang Liu, Austin Harris, Martin Maas, Michael Hicks, Mohit Tiwari, and Elaine
Shi. 2015. GhostRider: A Hardware-Software System for Memory Trace Oblivious
Session 3A: Side Channel CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea727Computation. In Proceedings of the Twentieth International Conference on Archi-
tectural Support for Programming Languages and Operating Systems (Istanbul,
Turkey) (ASPLOS ’15). Association for Computing Machinery, New York, NY,
USA, 87–101. https://doi.org/10.1145/2694344.2694385
[43] Chang Liu, Michael Hicks, and Elaine Shi. 2013. Memory Trace Oblivious Program
Execution. In Proceedings of the 2013 IEEE 26th Computer Security Foundations
Symposium (CSF ’13). IEEE Computer Society, USA, 51–65. https://doi.org/10.
1109/CSF.2013.11
[44] Martin Maas, Eric Love, Emil Stefanov, Mohit Tiwari, Elaine Shi, Krste Asanovic,
John Kubiatowicz, and Dawn Song. 2013. PHANTOM: Practical Oblivious Compu-
tation in a Secure Processor. In Proceedings of the 2013 ACM SIGSAC Conference on
Computer & Communications Security (CCS ’13). Association for Computing Ma-
chinery, New York, NY, USA, 311–324. https://doi.org/10.1145/2508859.2516692
[45] Heiko Mantel and Artem Starostin. 2015. Transforming Out Timing Leaks, More
or Less. In Proceedings, Part I, of the 20th European Symposium on Computer
Security – ESORICS 2015 - Volume 9326. Springer-Verlag, Berlin, Heidelberg, 447–
467. https://doi.org/10.1007/978-3-319-24174-6_23
[46] Robert Martin, John Demme, and Simha Sethumadhavan. 2012. Timewarp:
Rethinking timekeeping and performance monitoring mechanisms to mitigate
side-channel attacks. In 2012 39th Annual International Symposium on Computer
Architecture (ISCA). IEEE, 118–129.
[47] Ana Milanova, Atanas Rountev, and Barbara G. Ryder. 2002. Parameterized
Object Sensitivity for Points-to and Side-Effect Analyses for Java (ISSTA ’02).
Association for Computing Machinery, New York, NY, USA, 1–11. https://doi.
org/10.1145/566172.566174
[48] Ahmad Moghimi, Jan Wichelmann, Thomas Eisenbarth, and Berk Sunar. 2019.
MemJam: A False Dependency Attack Against Constant-Time Crypto Implemen-
tations. Int. J. Parallel Program. 47, 4 (Aug. 2019), 538?570. https://doi.org/10.
1007/s10766-018-0611-9
[49] Daniel Moghimi, Jo Van Bulck, Nadia Heninger, Frank Piessens, and Berk Sunar.
2020. CopyCat: Controlled Instruction-Level Attacks on Enclaves. In 29th USENIX
Security Symposium (USENIX Security 20). USENIX Association, 469–486. https://
www.usenix.org/conference/usenixsecurity20/presentation/moghimi-copycat
[50] David Molnar, Matt Piotrowski, David Schultz, and David Wagner. 2005. The
Program Counter Security Model: Automatic Detection and Removal of Control-
Flow Side Channel Attacks. In Proceedings of the 8th International Conference on
Information Security and Cryptology (Seoul, Korea) (ICISC’05). Springer-Verlag,
Berlin, Heidelberg, 156–168. https://doi.org/10.1007/11734727_14
[51] Robert Muth, Scott Watterson, and Saumya Debray. 2000. Code Specialization
Based on Value Profiles. In Static Analysis, Jens Palsberg (Ed.). Springer Berlin
Heidelberg, Berlin, Heidelberg, 340–359.
[52] Dag Arne Osvik, Adi Shamir, and Eran Tromer. 2006. Cache Attacks and Coun-
termeasures: The Case of AES. In Proceedings of the 2006 The Cryptographers’