contain instructions that angr’s symbolic execution engine,
which is the basis of BASESPEC’s semantic analysis (§VI),
cannot completely support. In particular, most ARM instructions
support conditional execution, which have a special suffix in
their mnemonics such as ADDEQ and CMPEQ. However, angr
currently does not support these instructions when the condition
is symbolic. Thus, it raises errors at those instructions and fails
to identify IEs correctly, resulting in missing IEs.
Second, we found that a few binary-embedded messages
have exceptional structures. For instance, according to the
specification, the CC-ESTABLISHMENT message only has the
Setup container IE except for headers. However, BASESPEC
reports multiple unknown mismatches as the message contains
suspicious IEs that are not defined in the specification. After
checking the specification, we found that the Setup container
IE is a placeholder to contain the contents of a SETUP message,
which consists of other multiple IEs. In addition, a message
called SECURITY MODE COMMAND had four unknown imperative
IEs. This message is designed to set up security parameters
for encryption and integrity checks [6]. We found that the
decoder handles this specific message exceptionally owing to
its special purpose. Even though these mismatches are incorrect,
we learned from these false positives that this message is
special and worthwhile to be analyzed manually. As it requires
more attention to implement such exceptional cases, they often
involve critical vulnerabilities (§VIII).
C. Discovering Bugs with Mismatches
By investigating mismatches identified by BASESPEC, we
successfully discovered 9 erroneous cases as shown in Ta-
ble IV, which affect 33 distinct messages. We numbered those
erroneous cases from E1 to E9. Five of them (E1–E5) are
functional errors (the Functional column) that make baseband
firmware non-compliant to the specification (e.g., rejecting a
valid message), and the other four (E6–E9) are memory-related
TABLE V: The number of missing mismatches for imperative IEs
and unknown mismatches regarding each functional error in Model A.
Common
Syntactic-only
Semantic-only
Errors
Missing Unknown Missing Unknown Missing Unknown
i-IE n-IE
·
·
·
·
·
·
·
7
·
2
·
·
0
9
E1
E2
E3
E4
E5
FP
Total
FP: false positives. E1–E5: functional errors
i-IE n-IE
·
21
·
2
·
·
·
·
·
·
·
13
0
36
i-IE
1
·
·
·
·
·
1
i-IE
·
·
2
·
·
1
3
i-IE n-IE
·
·
·
·
·
·
13
2
·
·
·
4
6
13
i-IE
·
·
·
·
·
·
1
ones (the Memory-related column), which can lead to denial
of service or even remote code execution. Except for E7, all of
our cases are newly discovered (i.e., 0-days). We responsibly
disclosed all of them to the manufacturer. In the following, we
describe how BASESPEC helped us to discover these errors.
Functional errors from missing and unknown mismatches
(E1–E5). As pointed out in §V-E, BASESPEC’s mismatches
are highly related to various types of bugs in baseband firmware.
Missing imperative IEs and unknown IEs are strong indicators
for functional errors. As listed in Table V, all such mismatches
originated directly from function errors (E1–E5), except for
false positives that were mentioned previously. Accordingly, we
can identify such bugs from these mismatches. Note that one
bug can cause multiple mismatches; for example, E1, which is
the case for incorrectly ordered six IEs, causes a cascade effect
on 22 mismatches, as shown in Table V. More interestingly,
Table V summarizes the importance of employing both syntactic
and semantic comparisons; we find E3 only from syntactic
comparison and E5 only from semantic comparison owing to
their individual advantages. Although these bugs do not have
severe security implications, they may affect the service quality
by disturbing the process of benign messages. Notably, E5
affects the ATTACH ACCEPT and ROUTING AREA UPDATE message,
which are critical for network connection. Since how such
functional errors affect cellular communication depends on the
role of each communication protocol, verifying their effects is
outside the scope of this study.
Memory corruptions from invalid mismatches (E6–E7).
By checking invalid mismatches and related handlers, we
discovered two memory corruption vulnerabilities (E6–E7).
Unlike functional errors, memory corruption vulnerabilities
require more manual efforts to understand security issues in
handler functions; invalid mismatches can be harmless in terms
of security because the handlers may have additional checks.
However, invalid mismatches can help discover bugs because we
can focus on the effects of the mismatches (i.e., non-compliance
with specification) instead of analyzing every handler logic,
which is extremely complex [25], [15], [64]. For example, we
discovered E6 by focusing on one IE’s length, which can be
much larger than that in the specification; its length is 5 bytes
in the specification, but the firmware allows it up to 255 bytes.
Other memory corruptions from failures (E8–E9). By
analyzing two failure cases of BASESPEC, we discovered two
more memory corruption vulnerabilities (E8–E9). BASESPEC
produced false positives for a few messages as described
in §VII-B, and it stopped running its semantic analysis for one
message. BASESPEC analyzes a universal decoding routine
in baseband firmware to check their compliance with the
12
specification. Therefore, the failure of BASESPEC for a certain
message represents that this message is handled specially with
its dedicated routine, which is error-prone. Consequently, we
further analyzed the failures and discovered two memory corrup-
tion vulnerabilities. In particular, we discovered E8, which could
be exploited for RCE, while investigating the false positives
listed in Table V; they have exceptional structures unlike other
messages. Moreover, we discovered E9 by analyzing a failure in
symbolic execution for the START DTMF ACKNOWLEDGE message.
We found that our symbolic execution engine (i.e., angr) reports
a memory access violation error for that specific message unlike
others; its report is indeed a vulnerability that dereferences an
improperly initialized pointer variable, thereby causing a crash.
Note that this vulnerability is detectable only with our efforts
to address path explosion and implement symbolic memory.
D. Applying BASESPEC to Various Firmware Images
To check the applicability and scalability of BASESPEC,
we ran BASESPEC to analyze all the collected firmware images
from Vendor1. As a result, we found that BASESPEC can
effectively identify mismatches in all tested firmware images,
as summarized in Table IV. The build dates of the latest images
are in a two-month period, whereas those of the oldest ones are
spread over four years. The average time spent on analyzing
bare-mental firmware was 3,156 s, of which 2,557 s (≈ 81%)
were spent for preprocessing (§IV-B). To analyze the detected
buggy cases for all firmware images quickly, we extended
BASESPEC’s L3 decoder identification (§IV-C) to find the
erroneous functions discovered in §VII-C. By comparing their
results, we observed the following interesting points:
When comparing the latest images with the oldest ones,
we perceived that most of the identified cases have existed
from the old days. For example, E8 and E9 are long-lived
vulnerabilities from the oldest firmware in our dataset, and they
are likely to have existed from earlier models. Moreover, some
device models have the same mismatches and vulnerabilities.
For example, Model D, E, F, and G have the same results,
while those of Model H and I are the same. In addition, Model
C and B show the same results. This result implies that the
manufacturer may share the same/similar code base for those
group of device models.
Furthermore, as the build dates of the oldest images are
spread over four years, we noticed that there have been at least
two security changes in the baseband implementation. This
is because E6 newly appeared between April 2016 and April
2017, and E7 disappeared between March 2018 and February
2018. By analyzing them, we identified that E6 appeared with
changes in GMM handlers, and E7 disappeared because of the
addition of more security checks in EMM handlers. Meanwhile,
there was no change in Model H and I in both mismatches and
error cases except for E7 in their latest versions; however, the
build date had a four-year gap. Thus, they were not affected
by E6, which is a newly introduced error.
E. Applying BASESPEC to Other Vendors
To show that BASESPEC is applicable to other vendors, we
analyzed three firmware images from Vendor2, which is another
one of the top 3 baseband chipset vendors. Currently, we only
applied the syntactic analysis part (§V-C) of BASESPEC, which
is sufficient to show its applicability to other vendors. We leave
13
TABLE VI: Summary results of syntactic comparison for Vendor2
Missing Unknown
Invalid
Model Build Date Msgs IEs i-IE n-IE i-IE n-IE i-IE n-IE
11(2)∗ 28
Model X Sep/2017
11(2)∗ 28
Model Y Aug/2017
17(2)∗ 33
Model Z Oct/2016
∗ Numbers in the parenthesis are the number of false positives.
127 8(8)∗ 0
127 8(8)∗ 0
148 8(8)∗ 0
87 625 0
87 625 0
87 604 0
the semantic analysis as a future work because our underlying
symbolic execution engine, angr, is still insufficient to model
various library functions required to analyze the firmware
from Vendor2. Although we applied only a syntactic part of
BASESPEC for Vendor2, we discovered numerous mismatches
and even a buffer overflow bug, which was previously unknown.
Thus, we reported all the findings to the vendor.
Firmware acquisition. In the case of Vendor2, there is no third
party website that provides a well-structured list of firmware
images, unlike the case of Vendor1. Therefore, we collected
firmware images using a web search. Among them, we selected
three images based on the ARM architecture. Vendor2 adopted
the MIPS architecture instead of ARM in their recent devices
since 2017. As BASESPEC currently supports ARM only, we
used the old images. However, we found that recent MIPS
devices are not largely different from the old ones, except for
the architecture. In addition, we manually verified that the latest
firmware still has the buffer overflow that we found in the old
images. We believe that BASESPEC can apply to the recent
firmware if it supports MIPS.
Firmware analysis. We first followed similar steps that
we performed to the Vendor1’s firmware (§IV) to uncover
the obscurity of the Vendor2’s firmware. Unlike Vendor1, the
firmware image includes a file that stores debug symbols; the
file has a list of names and addresses of functions. By leveraging
this file, we could recover function symbols in the firmware.
Then, we identified a decoder function using the symbols and
other debug messages in the firmware. Similar to the firmware
of Vendor1, that of Vendor2 also implements a single decoder
function to process various L3 messages. Finally, we figured out
binary-embedded message structures from the decoder function.
We found that Vendor2’s firmware also has a machine-
friendly message structure,
thereby allowing us to apply
BASESPEC successfully. However, its format is completely
different from Vendor1’s. Instead of the hierarchical
lists
in Vendor1 (Figure 4), the embedded structure in Vendor2
maintains bytecode for each message, which comprises various
simple opcodes. In particular, the firmware decodes a certain
message by interpreting the corresponding bytecode. Several
opcodes exist to handle different types of IEs. For instance,
the unpack_BITS opcode parses bit-level IEs, and the unpack_-
MAXBYTES opcode parses IEs while limiting their maximum
lengths. Moreover, the bytecode also has opcodes for control
flow; for example, the IF opcode is used for checking IEI,
and the CALL opcode can reuse other opcodes. Despite the
different design of Vendor2, it still meets our key intuitions
(§III-B); we were able to apply BASESPEC to their firmware
by implementing an interpreter for syntactic comparison and
reusing other specification-related components.
Identifying mismatches. Table VI shows the number of
mismatches that the syntactic comparison of BASESPEC found
from three firmware images from Vendor2. Notably, Model X
and Model Y showed the same result; although they are different
models, they have the same embedded message structures.
BASESPEC reported 8 unknown mismatches in all models;
however, we identified that these are false positives. Specifically,
the firmware arbitrarily divides a certain IE (e.g., Progress
Indicator IE) into multiple pieces for its parsing. BASESPEC
identified the separated pieces as different IEs and reported them
as unknown mismatches. This issue also produced two false
positives that resulted in invalid mismatches of each model. In
summary, BASESPEC correctly reported 37 invalid mismatches
from both Model X and Y, and 48 invalid mismatches from
Model Z, with 10 false positives in each model.
Discovering bugs. By checking the invalid mismatches re-
ported by BASESPEC, we found a buffer overflow vulnerability
in all three models. Notably, although the firmware images
appeared several years ago, the identified bug has been unknown
previously. We found the bug by analyzing the mismatches
from IE1 and IE2; these IEs belong to the MESSAGE1 in the CS
protocol.4 According to the specification, the IE1 can be 14
bytes long, and IE2 can be 30 bytes long. However, BASESPEC
reported that their lengths are swapped; that is, the decoder
accepts the IE1 with 30 bytes and the IE2 with 14 bytes. This
issue causes a buffer overflow in a handler function. When the
handler copies incoming IEs to its internal structure, the IE1
can overflow and overwrite a length field in the structure. Then,
this corrupted structure will be delivered to other functions via
internal messaging procedure. Therefore, in further handling,
the overwritten length field can cause other security issues, such
as denial of service. Additionally, other invalid mismatches
revealed minor mistakes, i.e., one or two-byte differences in
the lengths, which can cause functional errors.
VIII. SECURITY ANALYSIS AND CASE STUDY
This section details interesting ones from the 9 erroneous
cases (E1–E9). For the details of the other bugs, please see §A.
E1: Incorrect indices in Global IE List. By analyzing the
mismatches from BASESPEC, we discovered that the baseband
firmware is not compliant with specification because its Global
IE List has incorrect indices for several IEs in ESM messages.
As shown in Figure 4, the baseband manages IE information in
the Global IE List to reuse it for multiple messages; various
messages can share the same IEs. Each IE has a unique