title:Toward Revealing Kernel Malware Behavior in Virtual Execution Environments
author:Chaoting Xuan and
John A. Copeland and
Raheem A. Beyah
Toward Revealing Kernel Malware Behavior in
Virtual Execution Environments
Chaoting Xuan1, John Copeland1, and Raheem Beyah1,2
1 Georgia Institute of Technology
2 Georgia State University
Abstract. Using a sandbox for malware analysis has proven eﬀective
in helping people quickly understand the behavior of unknown malware.
This technique is also complementary to other malware analysis tech-
niques such as static code analysis and debugger-based code analysis.
This paper presents Rkproﬁler, a sandbox-based malware tracking sys-
tem that dynamically monitors and analyzes the behavior of Windows
kernel malware. Kernel malware samples run inside a virtual machine
(VM) that is supported and managed by a PC emulator. By building
its monitoring component into the PC emulator, Rkproﬁler is able to
inspect each instruction executed by the kernel malware and therefore
possesses a powerful weapon against the malware. Rkproﬁler provides
several capabilities that other malware tracking systems do not. First,
it can detect the execution of malicious kernel code regardless of how
the monitored kernel malware is loaded into the kernel and whether it
is packed or not. Second, it captures all function calls made by the ker-
nel malware and constructs call graphs from the trace ﬁles. Third, a
technique called aggressive memory tagging (AMT) is proposed to track
the dynamic data objects that the kernel malware visit. Last, Rkproﬁler
records and reports the hardware access events of kernel malware (e.g.,
MSR register reads and writes). Our evaluation results show that Rkpro-
ﬁler can quickly expose the security-sensitive activities of kernel malware
and thus reduces the eﬀort exerted in conducting tedious manual mal-
ware analysis.
Keywords: Dynamic Analysis, Rootkit, Emulator.
1 Introduction
When a attacker breaks into a machine and acquires administrator privileges,
kernel malware could be installed to serve various attacking purposes (e.g., pro-
cess hiding, keystroke logging). The complexity of attackers’ activity on ma-
chines has signiﬁcantly increased. Rootkits now cooperate with other malware
to accomplish complicated tasks. For example, the rootkit Rustock.B has an en-
crypted spam component attached to its code image in memory. The initializa-
tion routine of this rootkit registers a notiﬁcation routine to the Windows kernel
by calling the kernel function PsCreateProcessNotifyRoutine. This notiﬁcation
E. Kirda, S. Jha, and D. Balzarotti (Eds.): RAID 2009, LNCS 5758, pp. 304–325, 2009.
c(cid:2) Springer-Verlag Berlin Heidelberg 2009
Toward Revealing Kernel Malware Behavior
305
routine is then invoked each time that a new process is created. When detect-
ing the creation of Windows system process Service.exe, Rustock.B decrypts the
spam components and injects two threads into the Service.exe process to execute
the spam components [7]. Without understanding the behavior of the Rustock.B
rootkit, it would be diﬃcult to determine how the spam threads are injected into
the Service.exe process. To fully comprehend malicious activitiy on a compro-
mised machine, it is necessary to catch and dissect key malware that attackers
have loaded onto the machine. Thus, analyzing rootkits is an inevitable task for
security professionals.
Most of the early rootkits were rudimentary in nature and tended to be single-
mission, small and did not employ anti-reverse engineering techniques (e.g., ob-
fuscation). These rootkits could be manually analyzed using disassemblers and
debuggers. Since rootkit technology is much more mature today, the situation
has changed. Rootkits have more capabilities and their code has become larger
and more complex. In addition, attackers apply anti-reverse engineering tech-
niques to rootkits in order to prevent people from determining their behavior.
Rustock.C is one such example. The security company, Dr. Web, who claimed
to be one of the pioneers that provided defense against Rustock.C, took several
weeks to unpack and analyze the rootkit [8]. The botnet using Rustock.C was
the third largest spam distributor at that time, sending about 30 million spam
messages each day. This example illustrates how the cost incurred by the delay of
analyzing kernel malware can be huge. As another example, the conﬁcker worm
that has infected millions of machines connected to the Internet was reported
by several Internet sources [6] [10] (on April 8th 2009) that a heavily encrypted
rootkit, probably a keylogger, was downloaded to the victim machines. At the
time of the initial submission of this paper for publication, which was three days
later, no one had published the details of the rootkit. It is still unclear how se-
vere the damage (e.g., economic, physical) will be as a result of this un-dissected
rootkit. Accordingly, developing new approaches for quickly analyzing rootkits
is urgent and also critical to defeating most rootkit-involved attacks.
Several approaches have been proposed to address the rootkits analysis prob-
lem to some extent. For examples, HookFinder [30] and HookMap [27] are two
rootkit hooking detection systems. The former uses dynamic data tainting to
detect the execution of hooked malicious code; and the latter applies backward
data slicing to locate all potential memory addresses that can be exploited by
rootkits to implant hooks. K-tracer [14] is another rootkit analysis system that
uses data slicing and chopping to explore the sensitive kernel data manipulation
by rootkits. Unfortunately, these systems cannot meet the goal of comprehen-
sively revealing rootkit behavior in a compromised system. Meeting this goal
requires answering two fundamental questions: 1) what kernel functions have
been called by rootkits?; and 2) what kernel data objects have been visited
by rootkits? In the paper, we present a proof-of-concept system, Rkproﬁler,
in attempt to address these two questions. Rkproﬁler is built based on the
PC emulator QEMU [5] and analyzes Windows rootkits. The binary transla-
tion of QEMU allows Rkproﬁler to sandbox rootkits and inspect each executed
306
C. Xuan, J. Copeland, and R. Beyah
malicious instruction. Further, Rkproﬁler develops the memory tagging tech-
nique to perform just-in-time symbol resolving for memory addresses visited by
rootkits. Combining deep inspection capability with the memory tagging capa-
bility, Rkproﬁler is able to track all function calls and most kernel object accesses
made by rootkits.
The rest of paper is structured as follows. We point out the technical chal-
lenges for completely revealing rootkit behavior in Section 2. Section 3 gives the
overview of the Rkproﬁler system, including its major components and malware
analysis process. Section 4 presents the technical details of tracking rootkits.
Then, we present several case studies in Section 5 and discuss the limitations of
Rkproﬁler in Section 6. Section 7 surveys related work and Section 8 gives the
conclusion of the paper.
2 Challenges
Modern operating systems (OSs) like Windows and Linux utilize two ring levels
(ring 0 and 3) provided by X86 hardware to establish the security boundary be-
tween the OS and applications. Kernel instructions and application instructions
run at ring level 0 and 3 respectively (also called kernel mode and user mode).
The execution of special system instructions (INT, SYSENTER and SYSEXIT)
allows the CPU to switch between kernel mode and user mode. This isolation
mechanism guarantees that applications can only communicate with the kernel
through well-deﬁned interfaces (system calls) that are provided by the OS. Many
sandbox-based program analysis systems take advantage of this isolation bound-
ary and monitor the system calls made by malware [1] [3]. While this approach
is eﬀective to address user-space malware, it fails to address kernel malware.
This is because there is no well-deﬁned boundary between benign kernel code
and malicious kernel code. Kernel malware possess the highest privileges and
can directly read and write any kernel objects and system resource. Moreover,
kernel malware may have no constant ”identity” - that is, some kernel malware
could be drivers and others could be patches to benign kernel software. So the
ﬁrst challenge is how to create a ”virtual” boundary between kernel malware and
benign kernel software. Rkproﬁler overcomes this challenge by using the timing
characteristic of malware analysis. Before loading kernel malware, all kernel code
is treated as benign code; after loading kernel malware, newly loaded kernel code
is considered malicious. Note this ”virtual” boundary only isolates code, but not
data. This is because the data created by malicious code can also be accessed
by benign code, and Rkproﬁler does not monitor the operations of benign kernel
code for the purpose of design simplicity and better performance.
When monitoring a VM at the hypervisor layer, only hardware-level activi-
ties (e.g., memory reads and writes) are observed. To make these observations
useful, it is necessary to translate the hardware-level activities to software-level
activities. Here, software-level activities refer to using software terms to describe
program activities. For example, ”local variable X is modiﬁed.” This transla-
tion requirement is also known as the semantic gap problem [9]. This problem
Toward Revealing Kernel Malware Behavior
307
can be expressed as the following: given a memory address, what is its symbol?
Automatically ﬁnding the symbols for static kernel objects (global variables and
functions) is straightforward, but automatically ﬁnding the symbols for dynamic
kernel objects (data on stack and heap) is challenging. This challenge is not well
addressed by previous work. In this paper, we propose a method called aggressive
memory tagging (AMT) to overcome this challenge. The basic idea of AMT is
to perform the symbol resolution at run time and derive the symbols of dynamic
kernel objects from other kernel objects whose symbols have been identiﬁed. It
should be pointed out that Microsoft does not publish all kernel symbols and
we can only gather the kernel symbols that are publically available (Microsoft
symbol server, DDK documents and some unoﬃcial Internet sources). So the
current implementation of Rkproﬁler is not able to resolve many unpublished
symbols. Nevertheless, we ﬁnd that it identiﬁes most sensitive available symbols
in our evaluation.
3 System Description
Rkproﬁler is composed of four software components: generator, controller, mon-
itor and reporter. These software components operate in three phases tempo-
rally: pre-analysis, analysis and post-analysis. In the pre-analysis phase, the
generator collects symbols of native Windows kernel modules (e.g., ntoskrnl.exe,
ndis.sys) from the program database (PDB) ﬁles available on the Microsoft sym-
bol server [15] and header ﬁles in Microsoft’s Driver Development Kit (DDK).
Two databases are produced by the generator at the end of this stage: type graph
and system map. The type graph database contains the data type deﬁnitions of
native Windows kernel modules. There are six classes of data types: basic type,
enum, structure, function, union, and pointer. The data types in the last four
classes are considered as composite data types, indicating that a data type in-
cludes at least one sub data type. For example, the sub data types of a structure
are data types of its data members. In the type graph database, Rkproﬁler as-
signs a unique type ID to each data type. A data type is represented by its type
ID, type name, size, class ID and class speciﬁc data (e.g., the number of sub data
types and their type IDs). The system map database keeps the names, relative
virtual addresses and type IDs of global variables and functions used by native
Windows kernel modules. In addition, the names and type ID of parameters and
the return value for each function are also stored in system map. The generator
is comprised of several executables and Perl scripts.
Executing malware and monitoring its behavior are carried out in the analysis
phase. Two components of Rkproﬁler, controller and monitor, are involved in
this phase. The monitor is built into QEMU. The controller is a standalone shell
script that sends commands to the monitor via the Linux signal mechanism. Four
commands are deﬁned in their communication messages: RKP_INIT, RKP_RUN,
RKP_STOP and RKP_REPORT, (which are explained shortly). First, a test VM is
started and goes into a clean state in which no malware is installed and executed.
Then, the controller sends a RKP_INIT command to the monitor. After receiving
308
C. Xuan, J. Copeland, and R. Beyah
Fig. 1. Rkproﬁler architecture and rootkit analysis process
the command, the monitor queries the kernel memory image of the guest OS
and creates a hash table of trusted kernel code. Next, the controller instructs
the monitor to start monitoring through a RKP_START command. At that point,
Rkproﬁler is ready for the monitoring task. For example, a user starts executing
malware in the VM. Depending on the attack objectives of the malware, the
user may run other applications to trigger more behaviors from the malware.
For example, if the malware is intended to hide processes, the user may open
the Windows task manager to induce the hiding behavior. Since the malware
can be tested repeatedly, the attack objectives of the malware can be inferred
from the analysis results of previous tests. To obtain the monitoring result or
end the test, the user can have the controller issue RKP_REPORT or RKP_STOP
commands to the monitor. The ﬁrst command informs the monitor to write the
monitoring result to local audit ﬁles; the second command prompts the monitor
to stop monitoring and clear its internal data structures. Four audit ﬁles in CSV
format are generated in the analysis phase: trace, tag trace, tag access trace,
and system resource access trace. These ﬁles contain the functions called by the
malware, their parameters and return values, kernel data objects visited by the
malware and their values. In the post-analysis phase, the reporter is executed
to create user-friendly reports. Using the audit ﬁles generated in the analysis
phase, the reporter performs three tasks. First it builds a call graph from the
call trace and saves the graph to another ﬁle; second, it visualizes the call graph
and tag trace with open-source software GraphViz [11]; third it generates the
HTML-formatted reports for call traces and tag traces (CSV format). The entire
analysis process is illustrated in Figure 1.
The monitor component of Rkproﬁler was built based on the open-source PC
emulator QEMU. To support multiple CPU architectures, QEMU deﬁnes an
Toward Revealing Kernel Malware Behavior
309
intermediate instruction set. When QEMU is running, each instruction of a VM is
translated to the intermediate instructions. Rkproﬁler performs code inspection
and analysis at the code translation stage. To improve the performance, QEMU
caches the translated Translation Block (TB) so that it can be re-executed on
the host CPU over time. However, this optimization approach is not desirable to
Rkproﬁler because an instruction can behave diﬀerently in varied machine states.
For example, the instruction CALL, whose operand is a general-purpose register,
may jump to diverse instructions depending on the value of that register. For each
malicious TB that has been cached, Rkproﬁler forces QEMU to always perform
the code translation. But, the newly generated code is not stored in the cache and
the existing cached code is actually executed. Another problem arises when a TB
contains multiple instructions. In QEMU, VM states (register and memory con-
tents) are not updated during the TB translation. Except for the ﬁrst instruction,
the translation of all other instructions in a TB could be accompanied by incorrect
VM states, possibly resulting in analysis errors. Rkproﬁler addresses this problem
by making each malicious TB include only one instruction and disabling the direct
block chaining for all malicious TBs.
4 Design and Implementation
Kernel malware could take the form of drivers and be legitimately loaded into
the kernel. They can also be injected into the kernel by exploiting vulnerabilities
of benign kernel software. Rkproﬁler is designed to detect kernel malware that
enter the kernel in both ways. Roughly speaking, before any malware is executed,
Rkproﬁler looks up the kernel memory image and identiﬁes all benign kernel
code in the VM. Then it groups them into a Trust Code Zone (TCZ) and a hash
table is created to store the code addresses of the TCZ. When malware is started,
any kernel code that does not belong to the TCZ is regarded as malicious and
therefore is tracked by Rkproﬁler.
Identiﬁcation of the trusted kernel code is straightforward if the non-execute
(NX) bit of the page table is supported by the (virtual) Memory Management
Unit (MMU) of a (virtual) processor. In this case, the kernel code and data do
not co-exist in any page of memory. Rkproﬁler just needs to traverse the page
table of a process to ﬁnd out all the executable kernel pages. QEMU can provide
a NX-bit enabled virtual processor (by enabling the PAE paging mechanism),
but this system conﬁguration is not common. Doing so may inﬂuence the mal-
ware behavior in an undesired manner. For example, the malware could stop
running when it detects that the (virtual) CPU is NX enabled. So, the current
implementation of Rkproﬁler does not require enabling the NX-bit of the vir-
tual CPU. Instead, it interprets all images of benign kernel modules and obtains
the Relative Virtual Addresses (RVA) of the code sections. Then it computes
their actual virtual addresses by adding the RVAs to the module base addresses,
which is acquired by scanning the kernel memory of the VM. After that, Rkpro-
ﬁler stores the TCZ addresses in a hash table. However, one common type of
kernel malware attack is to patch the benign kernel code. To accommodate this
310
C. Xuan, J. Copeland, and R. Beyah
type of attack, Rkproﬁler excludes the patched code from the TCZ and revises
the TCZ hash table at run time. Rkproﬁler identiﬁes the patched code by ex-
amining memory write operations and memory copy functions that the malware
performs. Note, malware could escape this detection by indirectly modifying the
TCZ code (e.g., tampering with kernel memory from user space). A more reliable
method is to monitor the integrity of the TCZ as [20] does. Last, Rkproﬁler de-
termines whether a kernel TB is malicious or not right before it is translated. If
the address of a TB is not within the TCZ, it is deemed as a malicious TB. The
hash table implementation of the TCZ ensures that malicious code detection has
a small performance hit on the entire system.
4.1 Malicious Code Detection
Kernel malware could take the form of drivers and be legitimately loaded into
the kernel. They can also be injected into the kernel by exploiting vulnerabilities
of benign kernel software. Rkproﬁler is designed to detect kernel malware that
enter the kernel in both ways. Roughly speaking, before any malware is executed,
Rkproﬁler looks up the kernel memory image and identiﬁes all benign kernel
code in the VM. Then it groups them into a Trust Code Zone (TCZ) and a hash
table is created to store the code addresses of the TCZ. When malware is started,
any kernel code that does not belong to the TCZ is regarded as malicious and
therefore is tracked by Rkproﬁler.
Identiﬁcation of the trusted kernel code is straightforward if the non-execute
(NX) bit of the page table is supported by the (virtual) Memory Management
Unit (MMU) of a (virtual) processor. In this case, the kernel code and data do
not co-exist in any page of memory. Rkproﬁler just needs to traverse the page
table of a process to ﬁnd out all the executable kernel pages. QEMU can provide
a NX-bit enabled virtual processor (by enabling the PAE paging mechanism),
but this system conﬁguration is not common. Doing so may inﬂuence the mal-
ware behavior in an undesired manner. For example, the malware could stop
running when it detects that the (virtual) CPU is NX enabled. So, the current
implementation of Rkproﬁler does not require enabling the NX-bit of the vir-
tual CPU. Instead, it interprets all images of benign kernel modules and obtains
the Relative Virtual Addresses (RVA) of the code sections. Then it computes
their actual virtual addresses by adding the RVAs to the module base addresses,
which is acquired by scanning the kernel memory of the VM. After that, Rkpro-
ﬁler stores the TCZ addresses in a hash table. However, one common type of
kernel malware attack is to patch the benign kernel code. To accommodate this
type of attack, Rkproﬁler excludes the patched code from the TCZ and revises
the TCZ hash table at run time. Rkproﬁler identiﬁes the patched code by ex-
amining memory write operations and memory copy functions that the malware
performs. Note, malware could escape this detection by indirectly modifying the
TCZ code (e.g., tampering with kernel memory from user space). A more reliable
method is to monitor the integrity of the TCZ as [17] does. Last, Rkproﬁler de-
termines whether a kernel TB is malicious or not right before it is translated. If
the address of a TB is not within the TCZ, it is deemed as a malicious TB. The
Toward Revealing Kernel Malware Behavior
311
hash table implementation of the TCZ ensures that malicious code detection has
a small performance hit on the entire system.
4.2 Function Call Tracking
Kernel malware often interacts with the rest of the kernel by calling functions
exported by other kernel modules. In Rkproﬁler, we use the terms I2E (Internal-