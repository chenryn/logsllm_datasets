### References

1. **EVTYUSHKIN, D., RILEY, R., ABU-GHAZALEH, N. C., PONOMAREV, D., et al.** "Branchscope: A New Side-Channel Attack on Directional Branch Predictor." In *Proceedings of the 23rd International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)*, ACM, pp. 693–707, 2018.

2. **FERRAIUOLO, A., BAUMANN, A., HAWBLITZEL, C., and PARNO, B.** "Komodo: Using Verification to Disentangle Secure Enclave Hardware from Software." In *Proceedings of the 26th Symposium on Operating Systems Principles (SOSP)*, ACM, 2017.

3. **FOGH, A.** "Negative Result: Reading Kernel Memory from User Mode." *Cyber.wtf*, July 2017. [Link](https://cyber.wtf/2017/07/28/)

4. **GE, Q., YAROM, Y., COCK, D., and HEISER, G.** "A Survey of Microarchitectural Timing Attacks and Countermeasures on Contemporary Hardware." *Journal of Cryptographic Engineering* 8, 1 (2018), 1–27.

5. **GÖTZFRIED, J., ECKERT, M., SCHINZEL, S., and MÜLLER, T.** "Cache Attacks on Intel SGX." In *Proceedings of the 10th European Workshop on Systems Security (EuroSec'17)*, ACM, pp. 2:1–2:6, 2017.

6. **HORN, J.** "Reading Privileged Memory with a Side-Channel." *Google Project Zero Blog*, January 2018. [Link](https://googleprojectzero.blogspot.com/2018/01/)

7. **INTEL.** "Sawtooth Hyperledger Documentation." [Link](https://sawtooth.hyperledger.org/docs/core/releases/latest/introduction.html)

8. **INTEL.** *Intel 64 and IA-32 Architectures Optimization Reference Manual*. December 2017.

9. **INTEL.** *Intel 64 and IA-32 Architectures Software Developer’s Manual – Combined Volumes*. December 2017.

10. **INTEL.** *Intel Software Guard Extensions SDK for Linux OS: Developer Reference*. November 2017.

11. **INTEL.** *Intel Analysis of Speculative Execution Side Channels*. January 2018. Reference no. 336983-001.

12. **INTEL.** *Intel Software Guard Extensions (SGX) SW Development Guidance for Potential Edger8r Generated Code Side Channel Exploits*. March 2018. Revision 1.0.

13. **INTEL.** *Retpoline: A Branch Target Injection Mitigation*. February 2018. Reference no. 337131-001.

14. **INTEL.** *Speculative Execution Side Channel Mitigations*. May 2018. Reference no. 336996-002.

15. **JOHNSON, S.** "Intel SGX and Side-Channels." *Intel Developer Zone*, March 2017. [Link](https://software.intel.com/en-us/articles/intel-sgx-and-side-channels)

16. **JOHNSON, S., SCARLATA, V., ROZAS, C., BRICKELL, E., and MCKEEN, F.** "Intel® Software Guard Extensions: EPID Provisioning and Attestation Services." *White Paper* 1 (2016), 1–10.

17. **KAPLAN, D., POWELL, J., and WOLLER, T.** "AMD Memory Encryption." *White Paper* (2016).

18. **KOCHER, P., GENKIN, D., GRUSS, D., HAAS, W., HAMBURG, M., LIPP, M., MANGARD, S., PRESCHER, T., SCHWARZ, M., and YAROM, Y.** "Spectre Attacks: Exploiting Speculative Execution." *arXiv preprint arXiv:1801.01203* (2018).

19. **KRZANICH, B.** "Intel (INTC) CEO Brian Krzanich on Q4 2017 Results." *Seeking Alpha*, January 2018. [Link](https://seekingalpha.com/article/4140338-intel-intc-ceo-brian-krzanich-q4-2017-results-earnings-call-transcript)

20. **LEE, J., JANG, J., JANG, Y., KWAK, N., CHOI, Y., CHOI, C., KIM, T., PEINADO, M., and KANG, B. B.** "Hacking in Darkness: Return-Oriented Programming Against Secure Enclaves." In *USENIX Security Symposium*, pp. 523–539, 2017.

21. **GRUSS, D., LETTNER, J., SCHUSTER, F., OHRIMENKO, O., HALLER, I., and COSTA, M.** "Strong and Efficient Cache Side-Channel Protection Using Hardware Transactional Memory." In *USENIX Security Symposium* (2017).

22. **LEE, S., SHIH, M.-W., GERA, P., KIM, T., KIM, H., and PEINADO, M.** "Inferring Fine-Grained Control Flow Inside SGX Enclaves with Branch Shadowing." In *Proceedings of the 26th USENIX Security Symposium* (August 2017), USENIX Association.

23. **LIPP, M., SCHWARZ, M., GRUSS, D., PRESCHER, T., HAAS, W., MANGARD, S., KOCHER, P., GENKIN, D., YAROM, Y., and HAMBURG, M.** "Meltdown." *arXiv preprint arXiv:1801.01207* (2018).

24. **VAN BULCK, J., PIESSENS, F., and STRACKX, R.** "SGX-Step: A Practical Attack Framework for Precise Enclave Execution Control." In *Proceedings of the 2nd Workshop on System Software for Trusted Execution (SysTEX'17)*, ACM, pp. 4:1–4:6, 2017.

25. **MAENE, P., GÖTZFRIED, J., DE CLERCQ, R., MÜLLER, T., FREILING, F., and VERBAUWHEDE, I.** "Hardware-Based Trusted Computing Architectures for Isolation and Attestation." *IEEE Transactions on Computers* 99 (2017).

26. **MAISURADZE, G., and ROSSOW, C.** "Speculose: Analyzing the Security Implications of Speculative Execution in CPUs." *arXiv preprint arXiv:1801.04084* (2018).

27. **MCKEEN, F., ALEXANDROVICH, I., BERENZON, A., ROZAS, C. V., SHAFI, H., SHANBHOGUE, V., and SAVAGAONKAR, U. R.** "Innovative Instructions and Software Model for Isolated Execution." In *Proceedings of the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy*, ACM, 2013.

28. **MOBILECOIN.** "Mobilecoin Whitepaper." *Mobilecoin*, December 2017. [Link](https://www.mobilecoin.com/whitepaper-en.pdf)

29. **MOGHIMI, A., EISENBARTH, T., and SUNAR, B.** "MemJam: A False Dependency Attack Against Constant-Time Crypto Implementations." *arXiv preprint arXiv:1711.08002* (2017).

30. **MOGHIMI, A., IRAZOQUI, G., and EISENBARTH, T.** "CacheZoom: How SGX Amplifies the Power of Cache Attacks." In *Conference on Cryptographic Hardware and Embedded Systems (CHES'17)*, 2017.

31. **MÜHLBERG, J. T., and VAN BULCK, J.** "Reflections on Post-Meltdown Trusted Computing: A Case for Open Security Processors." *;login: The USENIX Magazine* Vol. 43, No. 3 (Fall 2018). To appear.

32. **NOORMAN, J., VAN BULCK, J., MÜHLBERG, J. T., PIESSENS, F., MAENE, P., PRENEEL, B., VERBAUWHEDE, I., GÖTZFRIED, J., MÜLLER, T., and FREILING, F.** "Sancus 2.0: A Low-Cost Security Architecture for IoT Devices." *ACM Transactions on Privacy and Security (TOPS)* (2017).

33. **O’KEEFFE, D., MUTHUKUMARAN, D., AUBLIN, P.-L., KELBERT, F., PRIEBE, C., LIND, J., ZHU, H., and PIETZUCH, P.** "Sgxspectre." *GitHub*, 2018. [Link](https://github.com/lsds/spectre-attack-sgx)

34. **OPEN WHISPER SYSTEMS.** "Private Contact Discovery." *Signal Blog*, [Link](https://signal.org/blog/private-contact-discovery/)

35. **SCHWARZ, M., WEISER, S., GRUSS, D., MAURICE, C., and MANGARD, S.** "Malware Guard Extension: Using SGX to Conceal Cache Attacks." In *14th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA'17)*, July 2017.

36. **SEO, J., LEE, B., KIM, S., and SHIH, M.-W.** "SGX-Shield: Enabling Address Space Layout Randomization for SGX Programs." In *Proceedings of the 2017 Network and Distributed System Security Symposium (NDSS 2017)*, Feb. 2017.

37. **SHIH, M.-W., LEE, S., KIM, T., and PEINADO, M.** "T-SGX: Eradicating Controlled-Channel Attacks Against Enclave Programs." In *Proceedings of the 2017 Network and Distributed System Security Symposium (NDSS 2017)*, Feb. 2017.

38. **STRACKX, R., and PIESSENS, F.** "The Heisenberg Defense: Proactively Defending SGX Enclaves Against Page-Table-Based Side-Channel Attacks." *arXiv preprint arXiv:1712.08519* (Dec. 2017).

39. **TOMASULO, R. M.** "An Efficient Algorithm for Exploiting Multiple Arithmetic Units." *IBM Journal of Research and Development* 11, 1 (1967), 25–33.

40. **TRAMER, F., ZHANG, F., LIN, H., HUBAUX, J.-P., JUELS, A., and SHI, E.** "Sealed-Glass Proofs: Using Transparent Enclaves to Prove and Sell Knowledge." In *2nd IEEE European Symposium on Security and Privacy (Euro S&P)*, IEEE, 2017.

41. **VAN BULCK, J., WEICHBRODT, N., KAPITZA, R., PIESSENS, F., and STRACKX, R.** "Telling Your Secrets Without Page Faults: Stealthy Page Table-Based Attacks on Enclaved Execution." In *Proceedings of the 26th USENIX Security Symposium* (August 2017), USENIX Association.

42. **WEICHBRODT, N., KURMUS, A., PIETZUCH, P., and KAPITZA, R.** "AsyncShock: Exploiting Synchronization Bugs in Intel SGX Enclaves." In *European Symposium on Research in Computer Security (ESORICS'16)*, Springer, 2016.

43. **XU, Y., CUI, W., and PEINADO, M.** "Controlled-Channel Attacks: Deterministic Side Channels for Untrusted Operating Systems." In *36th IEEE Symposium on Security and Privacy*, IEEE, May 2015.

44. **YAROM, Y., and FALKNER, K.** "Flush+Reload: A High Resolution, Low Noise, L3 Cache Side-Channel Attack." In *23rd USENIX Security Symposium*, USENIX Association, pp. 719–732, 2014.

### Appendix: Foreshadow's Cache Requirements

In this appendix, we provide experimental evidence that Foreshadow requires enclaved data to be present in the L1 CPU cache. This condition is attributed to SGX's microarchitectural implementation, as previous Meltdown-type exploits targeting hierarchical kernel memory do not have such strict caching requirements.

#### Placing Secrets at Specific Cache Levels

We use Intel's Transactional Synchronization eXtensions (TSX) to ensure that secrets only reside in the L2 and L3 cache levels, but not in L1. Specifically, after a TSX transaction starts, writes are cached in the L1 cache without being propagated to L2 and L3. When the transaction aborts and needs to be rolled back, all cache lines in the write set are marked invalid in the L1 cache. Future references to these addresses will hit the L2 cache, which still holds their original value.

Listing 3 shows how we leverage this mechanism to ensure that the secret is only present in the L2 and L3 caches. At Line 3, we start a new transaction. Next, the secret is modified to ensure its updated value is located in the L1 cache. When the transaction is finally aborted, the L1 cache line holding the secret is marked as invalid, but the corresponding L2/L3 cache lines remain unaffected. Execution is rolled back to Line 3, where, from a programmer's perspective, `rtm_begin()` returned -1 immediately. The `mfence` instructions ensure that memory accesses cannot be reordered.

```c
void load_in_L2(uint64_t *secret) {
    asm volatile ("mfence\n");
    if (rtm_begin() == 0) {
        *(secret) += 1;
        rtm_abort();
    }
    asm volatile ("mfence\n");
}
```

#### Verifying Cache Levels

As enclave memory is exclusively accessible to the enclave, we rely on a carefully crafted benchmark enclave that places a secret at the intended cache level. Unfortunately, returning execution control from the enclave (eexit) may inadvertently evict enclave secrets to secondary cache levels or even to main memory. To detect such events, we confirm their current cache level after every attack iteration.

Verifying the cache level of enclave data is challenging. SGX's abort page semantics prevent us from directly measuring the access times of enclave data: we did not observe any timing difference between accessing cached and non-cached secrets from outside the enclave. Moving such cache verification code into the enclave is infeasible, as `rdtsc` instructions cannot be executed in enclave mode on SGXv1 machines [27]. We therefore resort to creating a debug benchmark enclave and measure access times of reading enclave data through the `edbgrd` instruction. As `edbgrd` may inadvertently move enclave data to caches closer to the processor, we only perform this additional verification step after the actual Foreshadow attack attempt.

We carefully benchmarked the access times for enclave secrets residing in L1, L2, and main memory. Table 1 displays the median timing results for 100,000 runs. As expected, accessing enclave secrets in the L1 cache is only slightly faster than when they need to be fetched from the second-level L2 cache. This timing difference (6 cycles) is identical to L1/L2 cache hits of non-enclave memory. When SGX memory needs to be fetched from main memory, it must be decrypted by the memory encryption engine, which adds significant additional latency.

| Cache Event | Unprotected (cycles) | edbgrd (cycles) |
|-------------|----------------------|-----------------|
| L1 cache hit | 40                   | 1,400           |
| L2 cache hit | 46                   | 1,406           |
| Cache miss   | 238                  | 1,734           |

#### Success Rates

We first executed the Foreshadow-L1 attack 100,000 times against an enclave secret residing in the L1 cache. When we observed `edbgrd` timings larger than 1,405 cycles after the attack attempt, we assumed the secret must have been evicted from the L1 cache and discarded the result. For the remaining 96,594 attack rounds, we successfully received the secret.

We repeated the same test for enclave secrets residing in the L2 cache. This time, we discarded results with `edbgrd` timings exceeding 1,408 ticks after the attack. Out of the 98,610 remaining attack attempts, none succeeded in speculatively loading a secret-dependent oracle buffer slot in the transient execution phase.

To rule out the possibility that the transient instructions may need more attempts to elevate the enclave secret from the L2 to the L1 cache, we ran the same benchmark with 1,000 repeated transient executions before actually reloading the oracle buffer. This severely reduced the number of accepted attack attempts down to 10,205. Still, all Foreshadow-L2 attack attempts failed.

#### Conclusions

As long as enclave secrets reside in the L1 cache, we observe 100% success rates. Even though L2 cache accesses only take a mere 6 cycles longer, the success rates sharply drop to zero. The Meltdown [40] attack to extract supervisor data does not suffer from such a hard limit and has even been successfully applied to read kernel secrets directly from main memory. When applying Foreshadow against kernel data, we could indeed trivially extract kernel secrets from the L2 cache without noticing a significant success rate drop.

We conclude that both Meltdown and Foreshadow exploit a similar race condition vulnerability in the CPU's out-of-order pipeline behavior, but Intel SGX's abort page semantics apparently have a profound microarchitectural impact. Attack conditions are much more stringent to breach enclave than kernel isolation.