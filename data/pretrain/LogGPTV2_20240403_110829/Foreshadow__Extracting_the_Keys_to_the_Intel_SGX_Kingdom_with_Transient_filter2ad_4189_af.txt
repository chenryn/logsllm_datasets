[13] EVTYUSHKIN, D., RILEY, R., ABU-GHAZALEH, N. C., PONO-
MAREV, D., ET AL. Branchscope: A new side-channel attack
on directional branch predictor. In Proceedings of the 23th Inter-
national Conference on Architectural Support for Programming
Languages and Operating Systems (2018), ACM, pp. 693–707.
[14] FERRAIUOLO, A., BAUMANN, A., HAWBLITZEL, C., AND
PARNO, B. Komodo: Using veriﬁcation to disentangle secure-
In Proceedings of the 26th
enclave hardware from software.
Symposium on Operating Systems Principles (2017), ACM.
[15] FOGH, A. Negative result: Reading kernel memory from user
mode. https://cyber.wtf/2017/07/28/, July 2017.
[16] GE, Q., YAROM, Y., COCK, D., AND HEISER, G. A survey
of microarchitectural timing attacks and countermeasures on con-
temporary hardware. Journal of Cryptographic Engineering 8, 1
(2018), 1–27.
[17] GÖTZFRIED, J., ECKERT, M., SCHINZEL, S., AND MÜLLER,
T. Cache attacks on intel sgx. In Proceedings of the 10th Euro-
pean Workshop on Systems Security (New York, NY, USA, 2017),
EuroSec’17, ACM, pp. 2:1–2:6.
J.
[24] HORN,
channel.
2018/01/, January 2018.
Reading privileged memory with a side-
https://googleprojectzero.blogspot.com/
[25] INTEL. https://sawtooth.hyperledger.org/docs/core/
releases/latest/introduction.html.
[26] INTEL. Intel 64 and IA-32 architectures optimization reference
manual, December 2017.
[27] INTEL. Intel 64 and IA-32 Architectures Software Developer’s
Manual – Combined Volumes, December 2017.
[28] INTEL.
Intel Software Guard Extensions SDK for Linux OS:
Developer Reference, November 2017.
[29] INTEL. Intel Analysis of Speculative Execution Side Channels,
January 2018. Reference no. 336983-001.
[30] INTEL. Intel Software Guard Extensions (SGX) SW Development
Guidance for Potential Edger8r Generated Code Side Channel
Exploits, March 2018. Revision 1.0.
[31] INTEL. Retpoline: A Branch Target Injection Mitigation, February
2018. Reference no. 337131-001.
[32] INTEL. Speculative Execution Side Channel Mitigations, May
2018. Reference no. 336996-002.
[33] JOHNSON, S.
https://
software.intel.com/en-us/articles/intel-sgx-and-
side-channels, March 2017.
Intel SGX and side-channels.
[34] JOHNSON, S., SCARLATA, V., ROZAS, C., BRICKELL, E., AND
MCKEEN, F. Intel® software guard extensions: Epid provisioning
and attestation services. White Paper 1 (2016), 1–10.
[35] KAPLAN, D., POWELL, J., AND WOLLER, T. Amd memory
encryption. White paper (2016).
[36] KOCHER, P., GENKIN, D., GRUSS, D., HAAS, W., HAMBURG,
M., LIPP, M., MANGARD, S., PRESCHER, T., SCHWARZ, M.,
AND YAROM, Y. Spectre attacks: Exploiting speculative execu-
tion. arXiv preprint arXiv:1801.01203 (2018).
[37] KRZANICH, B.
Intel (intc) ceo brian krzanich on q4 2017
https://seekingalpha.com/article/4140338-
results.
intel-intc-ceo-brian-krzanich-q4-2017-results-
earnings-call-transcript, January 2018.
[38] LEE, J., JANG, J., JANG, Y., KWAK, N., CHOI, Y., CHOI, C.,
KIM, T., PEINADO, M., AND KANG, B. B. Hacking in darkness:
Return-oriented programming against secure enclaves. In USENIX
Security (2017), pp. 523–539.
[18] GRUSS, D., LETTNER, J., SCHUSTER, F., OHRIMENKO, O.,
HALLER, I., AND COSTA, M. Strong and efﬁcient cache side-
channel protection using hardware transactional memory.
In
USENIX Security Symposium (2017).
[39] LEE, S., SHIH, M.-W., GERA, P., KIM, T., KIM, H., AND
PEINADO, M. Inferring ﬁne-grained control ﬂow inside SGX en-
claves with branch shadowing. In Proceedings of the 26th USENIX
Security Symposium (August 2017), USENIX Association.
1006    27th USENIX Security Symposium
USENIX Association
[40] LIPP, M., SCHWARZ, M., GRUSS, D., PRESCHER, T., HAAS,
W., MANGARD, S., KOCHER, P., GENKIN, D., YAROM, Y.,
AND HAMBURG, M. Meltdown. arXiv preprint arXiv:1801.01207
(2018).
[57] VAN BULCK, J., PIESSENS, F., AND STRACKX, R. SGX-Step:
A practical attack framework for precise enclave execution con-
trol. In Proceedings of the 2nd Workshop on System Software for
Trusted Execution (2017), SysTEX’17, ACM, pp. 4:1–4:6.
[41] MAENE, P., GÖTZFRIED, J., DE CLERCQ, R., MÜLLER, T.,
FREILING, F., AND VERBAUWHEDE, I. Hardware-based trusted
computing architectures for isolation and attestation. IEEE Trans-
actions on Computers, 99 (2017).
[42] MAISURADZE, G., AND ROSSOW, C. Speculose: Analyzing
the security implications of speculative execution in cpus. arXiv
preprint arXiv:1801.04084 (2018).
[43] MCKEEN, F., ALEXANDROVICH, I., BERENZON, A., ROZAS,
C. V., SHAFI, H., SHANBHOGUE, V., AND SAVAGAONKAR,
U. R. Innovative instructions and software model for isolated
execution. In Proceedings of the 2nd International Workshop on
Hardware and Architectural Support for Security and Privacy
(2013), ACM.
[44] MOBILECOIN. Mobilecoin. https://www.mobilecoin.com/
whitepaper-en.pdf, December 2017.
[45] MOGHIMI, A., EISENBARTH, T., AND SUNAR, B. Memjam: A
false dependency attack against constant-time crypto implementa-
tions. arXiv preprint arXiv:1711.08002 (2017).
[46] MOGHIMI, A.,
IRAZOQUI, G., AND EISENBARTH, T.
Cachezoom: How SGX ampliﬁes the power of cache attacks. In
Conference on Cryptographic Hardware and Embedded Systems
(2017), CHES ’17.
[47] MÜHLBERG, J. T., AND VAN BULCK, J. Reﬂections on post-
Meltdown trusted computing: A case for open security processors.
;login: the USENIX magazine Vol. 43, No. 3 (Fall 2018). to appear.
[48] NOORMAN, J., VAN BULCK, J., MÜHLBERG, J. T., PIESSENS,
F., MAENE, P., PRENEEL, B., VERBAUWHEDE, I., GÖTZFRIED,
J., MÜLLER, T., AND FREILING, F. Sancus 2.0: A low-cost se-
curity architecture for IoT devices. ACM Transactions on Privacy
and Security (TOPS) (2017).
[49] O’KEEFFE, D., MUTHUKUMARAN, D., AUBLIN, P.-L., KEL-
BERT, F., PRIEBE, C., LIND, J., ZHU, H., AND PIETZUCH, P.
Sgxspectre. https://github.com/lsds/spectre-attack-sgx, 2018.
[50] OPEN WHISPER SYSTEMS.
https://signal.org/blog/
private-contact-discovery/.
[51] SCHWARZ, M., WEISER, S., GRUSS, D., MAURICE, C., AND
MANGARD, S. Malware guard extension: Using sgx to conceal
In 14th International Conference on Detection
cache attacks.
of Intrusions and Malware, and Vulnerability Assessment (July
2017), DIMVA’17.
[52] SEO, J., LEE, B., KIM, S., AND SHIH, M.-W. SGX-Shield:
Enabling address space layout randomization for sgx programs. In
Proceedings of the 2017 Network and Distributed System Security
Symposium (NDSS 2017) (Feb. 2017).
[53] SHIH, M.-W., LEE, S., KIM, T., AND PEINADO, M. T-SGX:
Eradicating controlled-channel attacks against enclave programs.
In Proceedings of the 2017 Network and Distributed System Secu-
rity Symposium (NDSS 2017) (Feb. 2017).
[54] STRACKX, R., AND PIESSENS, F. The heisenberg defense:
Proactively defending sgx enclaves against page-table-based side-
channel attacks. arXiv preprint arXiv:1712.08519 (Dec. 2017).
[55] TOMASULO, R. M. An efﬁcient algorithm for exploiting multiple
arithmetic units. IBM Journal of research and Development 11, 1
(1967), 25–33.
[56] TRAMER, F., ZHANG, F., LIN, H., HUBAUX, J.-P., JUELS, A.,
AND SHI, E. Sealed-glass proofs: Using transparent enclaves to
prove and sell knowledge. In 2nd IEEE European Symposium on
Security and Privacy (Euro S&P) (2017), IEEE.
[58] VAN BULCK, J., WEICHBRODT, N., KAPITZA, R., PIESSENS,
F., AND STRACKX, R. Telling your secrets without page faults:
Stealthy page table-based attacks on enclaved execution. In Pro-
ceedings of the 26th USENIX Security Symposium (August 2017),
USENIX Association.
[59] WEICHBRODT, N., KURMUS, A., PIETZUCH, P., AND KAPITZA,
R. Asyncshock: exploiting synchronisation bugs in Intel SGX
In European Symposium on Research in Computer
enclaves.
Security (2016), ESORICS ’16, Springer.
[60] XU, Y., CUI, W., AND PEINADO, M. Controlled-channel attacks:
Deterministic side channels for untrusted operating systems. In
36th IEEE Symposium on Security and Privacy (May 2015), IEEE.
[61] YAROM, Y., AND FALKNER, K. Flush+reload: A high resolution,
low noise, L3 cache side-channel attack. In 23rd USENIX Security
Symposium (2014), USENIX Association, pp. 719–732.
A Foreshadow’s Cache Requirements
In this appendix, we provide experimental evidence that
Foreshadow requires enclaved data to be present in the L1
CPU cache. We attribute this condition to SGX’s microar-
chitectural implementation, for previous Meltdown-type
exploits targeting hierarchical kernel memory, do not have
such strict caching requirements.
Placing Secrets at Speciﬁc Cache Levels. We rely on
Intel’s Transactional Synchronization eXtensions (TSX)
to ensure that secrets only reside in the L2 and L3 cache
levels, but not in L1. Particularly, we abuse that after
a TSX transaction has started writes are cached in the
L1 cache, without being propagated down to L2 and L3.
When a transaction aborts and needs to be rolled back, all
cache lines in the write set are simply marked invalid in
the L1 cache. Future references to these addresses only
hit the L2 cache, which still holds their original value.
Listing 3 displays how we leverage this mechanism to
ensure that the secret is only present in the L2 and L3
caches. At Line 3 we start a new transaction. Next the
secret is modiﬁed to ensure its updated value is located
in the L1 cache. When ﬁnally the transaction is aborted,
the L1 cache line holding the secret is marked as invalid,
but the corresponding L2/L3 cache lines remain unaf-
fected. Execution is rolled back to Line 3 where from a
programmer’s perspective rtm_begin() returned −1 im-
mediately. The mfence instructions ensure that memory
accesses cannot be reordered.
Verifying Cache Levels. As enclave memory is exclu-
sively accessible to the enclave, we rely on a carefully
crafted benchmark enclave that places a secret at the in-
tended cache level. Unfortunately returning execution
control from the enclave (eexit), may inadvertently evict
USENIX Association
27th USENIX Security Symposium    1007
1 void load_in_L2( uint64_t ∗secret ) {
2
asm volatile ( "mfence\n" );
if ( rtm_begin() == 0 ) {
3
4
5
6
7
8 }
∗(secret) += 1;
rtm_abort();
}
asm volatile ( "mfence\n" );
Table 1: Access times for enclave and non-enclave mem-
ory at various cache levels (median over 100,000 runs).
Cache event Unprotected (cycles)
L1 cache hit
40
46
L2 cache hit
Cache miss
238
edbgrd (cycles)
1,400
1,406
1,734
Listing 3: We evict secrets from the L1 cache by including
them in the write set of an aborted TSX transaction.
evicted enclave secrets are discarded.
Success Rates. We ﬁrst execute the Foreshadow-L1 at-
tack 100,000 times against an enclave secret residing in
the L1 cache. When we observe edbgrd timings larger
than 1,405 cycles after the attack attempt, we assume the
secret must have been evicted from the L1 cache and dis-
card the result. For every of the remaining 96,594 attack
rounds, we successfully received the secret.
We repeated the same test for enclave secrets residing
in the L2 cache. This time, we discarded results with
edbgrd timings exceeding 1,408 ticks after the attack.
Out of the 98,610 remaining attack attempts, none suc-
ceeded in speculatively loading a secret-dependent oracle
buffer slot in the transient execution phase.
To rule out the possibility that the transient instructions
may need more attempts to elevate the enclave secret
from the L2 to the L1 cache, we ran the same benchmark
with 1,000 repeated transient executions before actually
reloading the oracle buffer. This severely reduced the
number of accepted attack attempt down to 10,205. Still,
all Foreshadow-L2 attack attempts failed.
Conclusions. As long as enclave secrets reside in the
L1 cache, we observe 100% success rates. Even though
L2 cache accesses only take a mere 6 cycles longer, the
success rates sharply drop to zero. The Meltdown [40]
attack to extract supervisor data does not suffer from such
a hard limit, and has even been successfully applied to
read kernel secrets directly from main memory. When
applying Foreshadow against kernel data, we could indeed
trivially extract kernel secrets from the L2 cache without
noticing a signiﬁcant success rate drop.
We conclude that both Meltdown and Foreshadow ex-
ploit a similar race condition vulnerability in the CPU’s
out-of-order pipeline behavior, but Intel SGX’s abort page
semantics apparently have a profound microarchitectural
impact. Attack conditions are much more stringent to
breach enclave than kernel isolation.
enclave secrets to secondary cache levels or even to main
memory. To detect such events, we conﬁrm their current
cache level after every attack iteration.
Verifying at which level enclave data is currently
cached is challenging. SGX’s abort page semantics pre-
vent us from directly measuring the access times of en-
clave data: we did not observe any timing difference be-
tween accessing cached and non-cached secrets from out-
side the enclave. Moving such cache veriﬁcation code into
the enclave, on the other hand, is infeasible as rdtsc in-
structions cannot be executed in enclave mode on SGXv1
machines [27]. We therefore resort to creating a debug
benchmark enclave and measure access times of reading
enclave data through the edbgrd instruction. As edbgrd
may inadvertently move enclave data to caches closer to
the processor, we only perform this additional veriﬁcation
step after the actual Foreshadow attack attempt.
We carefully benchmarked the access times for enclave
secrets residing in L1, L2, and main memory. Table 1
displays the median timing results for 100,000 runs. As
expected, accessing enclave secrets in the L1 cache is
only slightly faster than when they need to be fetched
from the second-level L2 cache. This timing difference
(6 cycles) is furthermore identical to L1/L2 cache hits
of non-enclave memory. When SGX memory needs to
be fetched from main memory, however, it needs to be
decrypted by the memory encryption engine which adds
signiﬁcant additional latency.
Experimental Setup. As we are only interested in
whether the attack variations succeed, not their bandwidth,
we made some changes to our attack setting. Each attack
operates in a guess/verify fashion; for every 256 possible
values of the secret byte, we performed 100,000 Fore-
shadow rounds. Each round starts by ﬁrst entering the
benchmark enclave to explicitly place the secret at the
desired cache level. After Foreshadow’s transient exe-
cution phase, a single oracle slot (the current guess) is
reloaded to receive the output of the transient instruction
sequence. Finally we verify whether the enclave secret
is still located at its intended cache level by measuring
edbgrd timing. Any attack results from inadvertently
1008    27th USENIX Security Symposium
USENIX Association