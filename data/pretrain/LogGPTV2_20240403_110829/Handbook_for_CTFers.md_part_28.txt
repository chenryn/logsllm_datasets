19
elif os.path,isfile(filename):
20
with cpen(filename,“rb") as f:
21
content = f.read()
22
23
else:
24
return “can’t find file"
Fig, 3.56 PHP code
py1e6 hash,cpython37,pyc
3.7.0 (defav7t, 3un 28 2018, 08:04:48) [ec v.2912 64 bft (AND
hh:4si bytes
Fig, 3.57 The source code
by adding a hook to the eval function. In the PHP extension, we replace
zend_compile_file at initialization with a function we wrote ourselves, and output
the decrypted result each time we execute it.
---
## Page 271
256
3 Advanced Web Challenges
*
4444449904444-95
0444
Fig, 3.58 The encrypted code directly
Fig, 3.59 The source code
Takes Phpjiami as an example. In PWNHUB, the *Day of Stupid Fufu" challenge
uses this encryption method. You can find its source code ad https:/github.com/
processed by PHPJiami, and you can download the encrypted code directly, as
CTFTraining/pwnhub_2017_open_weekday. The challenge provides a backup file
shown in Fig. 3.58.
There are a lot of eval hooking plug-in source code on the Internet, such as https://
github.com/bizonix/evalhook, only need to compile and load to the PHP, then run
the encrypted code, you can get the decrypted ones, as shown in Fig. 3.59.
In addition to code obfuscation in this way, using plug-ins to encrypt code is
another way to do it. This method hooks PHPs underlying zend_compile_*,
decrypts the source code in the function after the hook, and passes the decrypted
source code to the PHP executable. For this type of encryption, we can still decrypt it
in a manner similar to eval hook.
---
## Page 272
3.3 Cryptography and Reverse Knowledge
257
Fig, 3.60 Analyze the
encryption plug-in, which
zm_startup_encrypt_php()
hooks the
zend_compile_file
E
compiler_globals[135] |-1u;
4
org_compile_file -zend_compile_file;
5
zend_compile_file = encrypt_compile_file;
return OLL;
sf ( get_active_function_nane() )
v4 *(const char *)grt_active_functien_name();
strmcpy（（ch)bv8，v4，ox1tutL）;
f（（_YTE}）
f（Istrcesecnp（(const char “)&vB， “sho
return eLL;
us111（93
f（t +.s)（.y>tu
（（//=_func->op_array) :
 / / nothing to do
return old_execute_ex (execute_data TSRHLS_DC) ;
For example, in sourceGuardian in RCTF 2019, we can see the hint of sg_load
function and title name that the code is encrypted using SourceGuardian, as shown in
Fig. 3.63. Opcode can be exported using the modified VLD.
After analyzing the Opcode, the source code can be recovered step by step, as
shown in Fig. 3.64.
doua °WA e juauadu-au o1 s! uondiouo jo suoj xaqduoo isou ap jo suo
opCode generated by compiling PHP source code with a style that can only be
understood by the custom VM, and hand it over to the custom VM for parsing.
Typical examples are VMP, which is difficult to decrypt due to the huge workload
due to the need to analyze both the virtual machines and the codes.
---
## Page 274
3.3 Cryptography and Reverse Knowledge
259
nsgij7a
Fig, 3.63 The code is encrypted using SourceGuardian
年
Fig, 3.64 The source code can be recovered step by step
3.3.2.3JavaSeript
In any case, JavaScript encryption eventually sends the decrypted results to the
JavaScript engine for execution, so we simply add hooks to key functions as we do to
decrypt PHP.
For example, in most cases, encrypted code can be decrypted and executed again
only by calling functions such as eval. In this case, we can change the eval function
into a printed function instead of execute it, but output it to obtain the key code.
---
## Page 275
260
3 Advanced Web Challenges
window. eva] = funct1on (){
console . 1og ('eval ′, JsoN.stringify (arguments))
Some code may be detected by the developer tools, and for this kind of
undebugging, we can remove that part of the code through BurpSuite’s proxy
sso isou u os suad on nop oo si uondu apo iduogeae ana
it is just obfuscated. However, the obufuscation only changes the variable names and
code structures, but the code itself can be optimized by code beautification tools or
even solved by Partial Evaluation technology. There are many open source tools on
the web that can optimize code, such as Google’s Closure Compiler, FaceBook's
Prepack, and JStillery. While most applications optimize the code by refactint the
AST, evaluating functions, initializes objects, and so on at compile time to render
readable code.
3.4 Logic Flaws
Logic flaws refer to that in the process of program development, due to the lack of
strict consideration of the program processing logic, when reaching the branch logic
function, the normal processing or some errors can not be carried out, thus
causing hamm.
In general, the function of the more complex the application, access authentica-
tion and more complex business processing procedures, developers should consider
the content will be greatly increased, so the function of the more complex the
application, developers, the greater the possibility of negligence, when there is
negligence of these points will cause business function abnormal executes, logical
flaws formed. By logical flaws on actual normal business functions exist, so the
different business functions as a direct result of the use of each logical flaws are
different, also can’t like SQL injection vulnerabilities summarizes the use of a
common process or bypass method, and that for testers in the aspect of business
logic comb has a higher request.
Unlike traditional vulnerabilities such as SQL injection and file upload, logic
flaws are often difficult to find if analyzed only at the code level. As a result,
traditional vulnerability scanners based on “input abnormal data  get abnormal
response” are often weak to detect logical vulnerabilities. At present, the mining
method for logical vulnerabilities is still mainly manual testing, and because it is
closely related to business functions, it is closely related to the experience of testers.
---
## Page 276
3.4 Logic Flaws
261
3.4.1CommonLogicFlaws
By logical loopholes on actual normal business functions exist, can’t come to the
conclusion that a method of all logical loopholes effective use, but for these logical
loopholes, there is a common cause of it, this can be the logical loopholes a rough
classification, summed up in two kinds: permission problem, data problem.
Permission-related logic flaws
Let's start by looking at what a permission-specific logic flaw is. In normal service
s sosn uouo suossd Supuodsauoo anbou suoado isou soeuaos
such as anonymous visitors, ordinary login users, member users, administrators, etc.,
all have their own unique rights operation. Anonymous visitor permission can
perform operations such as browsing information, searching for specific content,
 ossd d d spo go w ssd uso 
make an appointment in advance, etc. These operations are closely related to the
user's permissions.
A privilege-related logical flaw occurs when there is a problem with the process
of assigning, confirming, and using privileges, which allows some users to perform 
saad umo s q pooddns pou ane ye suoeado pasaad
Common categories of privilege logic vulnerabilities are unauthorized access,
unauthorized access, and user authentication flaws.
Unauthorized access refers to the ability of a user to directly access information
such as text content or pages that would otherwise require authorization without
going through the authorization process. The essence of this is that when some
functions are developed, no user identity verification step is added, resulting in
unauthorized users accessing the corresponding functions without effective identity
verification, thus browsing the content that is not supported by their original
permissions, which leads to unauthorized access (see Fig. 3.65).
The main types of privileged access are lateral and vertical leaks. A horizontal
override vulnerability refers to an override that occurs between users with the same
level of privileges, where privileges are always limited to the same level, and is
therefore referred to as horizontal. In contrast, a vertical escape vulnerability refers to
the occurrence of an escape between users with different levels of privileges and is
often used to describe an escape from a user with lower privileges to a user with
higher privileges.
Suppose there are two users A and B, each with permissions for three actions, as
shown in Fig. 3.66.
For example, User A can view User B's order history, where the process of
changing privileges is “Ordinary User → Ordinary User” (see Fig. 3.67), but the
essential privilege level remains unchanged.
Vertical overreach involves the permission change between the administrator and
the user. For example, user A can edit the advertisement on the home page through
overreach, then the permission change process is from ordinary user to advanced
user, and the essential permission level changes.
---
## Page 277
262
3 Advanced Web Challenges
Admir
strator
privilege
escalation
Read sensitive passages
Anonymous User
Get Information of userst
Operations can only be
performed by admins
Administs
Protle Modificatior
tange axats
Jser B
---
## Page 278
3.4 Logic Flaws
263
User A
Protle Modication
Change avatar
Operations related to user b
Fig, 3.67 The process of changing privileges
Request with cookies
Request with cookies
of user B
Identifed as user A
Hetified as wser B
Client A
Fig, 3.68 He server uses the Cookie (Session) to determine the user’s identity
User authentication defects usually involve many parts, including login system
security, password recovery system, user identity authentication system, etc. In
general, the ultimate goal is to obtain the appropriate permissions of the user. Taking
the login system as an example, a complete system at least includes: usemame and
password consistency verification, verification code protection, Cookie (Session)
identity verification, and password retrieval. For example, Cookie (Session) authen-
tication. After a user logs in to the service system using a matched username and
password, the server is assigned a Cookie (Session) value, which is usually a unique
string. The server uses the Cookie (Session) to determine the user’s identity. As
shown in Fig. 3.68.
Open the browser’s console and view the cookies that the current page has
through JavaScript, as shown in Fig. 3.69. Or you can view the Cookie of the current
page in the network request section, as shown in Fig. 3.70.
---
## Page 279
264
3 Advanced Web Challenges
Fig, 3.69 Cookies
eooke: _ga=GA1.2,127672999. 155547593; _g1dGA1.2.187753667.1557881485; Ho_1vt_edc3c89ae38
2886fc3a47d6c11483dab155547e594, 1556777969, 15578e1485, 1557836174; Ha_1pvt_edc3ce9ae382886
fc3a47d6c11483dae1557836174
Fig, 3.70 Cookies
Cookie data is presented in the form of a key-value pair, and when the value is
modified, the content of the corresponding cookie key is modified. If the key-value
pairs used to verify the identity of a cookie are not effectively protected during
transmission, they may be tampered with by an attacker, and the server can then
recognize the attacker as a normal user. Suppose the key-value pair of the authen-
tication cookie is “auth_priv=guest", when the attacker modifies it to
“auth_priv=admin", the server will recognize the attacker as a normal user. This
Creates a cookie impersonation logical flaw in the cookie authentication process.
As for the Session mechanism, since the Session is stored on the server, the Angle
exploited by the attacker will change slightly. Unlike Cookie verification, Session
verification assigns a Session ID to the user after opening the web page, which is
usually a string of letters and numbers. After a user log in, the corresponding Session
ID records the corresponding permissions. The verification process is shown in
Fig. 3.71.
The key point of Session authentication is “identify the user by session ID". There
is a Session fixed attack on this key point. See Fig. 3.72 for the attack process.
In simple tems, the attack flow is as follows: the attacker opens the page and gets
a session ID, which we will call S; the attacker sends a link to the victim, which
causes the victim to use S to log in, such as http://session.demo.com/ login.php?
sessionldxxxx; victim B executes After logging in, the session ID corresponding to
S will contain the identifying information of user B. The attacker can also use S to
gain access to the victim's account.
2. Data-related logical flaws
In reality, for the shopping system with interwoven business functions, normal
business functions will involve a variety of scenarios, such as commodity balance,
money expenditure, commodity attribution determination, order modification, use of
vouchers, etc. Purchase of these functions, for example, in the process of buying
involves merchants balance changes of commodity, the buyer of the amount of
consumption, such as server transaction history data, because involves more types of
data, so in the actual development process, for some of the data type of the
possibility of ill-considered check then, such as cost amount is the amount of
positive and negative decision, if we can change and other issues. These problems
are often not directly caused by bugs at the code level, but rather by a partial failure
---
## Page 280
3.4 Logic Flaws
265
Open the webpage for the first time
A Unique Session ID is assigned
Logis with User A’s credentials
Bind the Identity Infonme
Cliem
With Given Session ID
ith As
H ID
Fig, 3.71 The verification process
of judgment in the business processing logic. This is due to a lack of judgment on the
part of the business process logic
Data-related logical flaws often focus on business data tampering, replaying, etc.
Business data tampering involves many of the problems mentioned above, and is
closely related to the legal regulations made by developers on normal business. For
example, in the purchase limit behavior, the breakthrough of the maximum purchase
quantity is also regarded as business data tampering. In addition, several common
business data tampering in purchase scenarios include amount data tampering,
commodity quantity tampering, maximum purchase limit modification, coupon ID
tampering. In different scenarios, tamper-able data varies and needs to be analyzed
according to the actual situation. Therefore, the above four types of data are only for
purchase scenarios.
By tampering with business data, attackers can modify the tasks they planned to
perform, such as tampering with consumption amount. If a payment link to http://
demo.meizj.com/pay.php?money=1000&purchaser=jack&productid=1001&
seller=john. The parameters have the following meanings: Money represents the
amount spent in the purchase, The purchasers’ usermame, Productid represents the
purchase information, and Seller represents the seller’s usermame.
If the backend purchase function is implemented through this URL, then the
business logic can be described as “purchaser spent money to buy the productid
product from seller". When the transaction is completed normally, the money is
---
## Page 281
266
3 Advanced Web Challenges
1. Open the webpage
2. Allocate Session ID to the
attacker_denoted as S
5. altacker browse with session S
Attacker
And is identified as Ilser B
3. send sessionID S
to the victim B
4. Login with Session S
Victim
Fig, 3.72 The attack process
deducted from the purchaser'’s balance, but when the server-side chargeback is based
only on the money parameter in the URL, an attacker can easily tamper with the
money parameter to change the actual amount he or she has spent. For example, the
tampered
URL
iS
http://demo.meizj.com/
pay.php?
money=1&purchaser=jack&productid1001&seller=john. At this point, the
attacker completes the purchase process with only 1 yuan. This is essentially because
the backend does not verify the type and format of the data effectively, resulting in
unexpected situations.
Therefore, in the author’s opinion, data-related logic vulnerabilities are basically
caused by errors and omissions in data verification.
3.4.2 Logic Flaws in CTFs
Compared with other Web flaws, logic flaws usually require the combination of
multiple business function vulnerabilities. Therefore, they often exist in complex
---
## Page 282