whitelist  and  therefore  thwarted  the  exploit  at  the  very 
beginning; on the encouraging side, we confirmed that if we 
could  succeed  in  setting  xdReceiver  to  Bob.com 
/xdcomm,  we  would  indeed  get  loc,  and  this  loc  value 
would indeed enable an end-to-end successful exploit.   
The  remaining  question  is  how  to  set  the  RP’s 
xdReceiver so that it points to Bob.com/xdcomm. Bob 
must accomplish this without being caught by the whitelist 
check in BRM1. The only option is to let Bob use his own 
AppName  (i.e.,  Bob-App)  in  BRM1,  because  Bob  can 
arbitrarily whitelist any domain that he wants for Bob-App. 
Essentially, it means Bob is not constrained by the whitelist 
check when BRM1 has argument AppName=“Bob-App”. 
How  can  this  affect  the  settings  (i.e.,  token_url  and 
xdReceiver)  for  RP-App?  Remember  that  after  BRM1, 
the 
referenced  by  settingsHandle 
collectively, which can be thought of as a secret session ID. 
The only hurdle for our exploit is how to bind this session 
ID  (which 
target  RP-App. 
Interestingly,  we  found  that  this  binding  is  established  by 
is  for  Bob-App) 
settings  are 
to  our 
373
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:47:30 UTC from IEEE Xplore.  Restrictions apply. 
BRM2 
(Figure 8). This gives us another opportunity.  
its  argument  openid.return_to 
through 
Here  is  our  third  plan,  consisting  of  two  steps:  first, 
Bob’s  own  browser  makes  the  request  of  BRM1  with 
AppName=“Bob-App”  &  token_url=“http://RP 
/finish-login”  &  xdReceiver=”http://Bob 
/xdcomm”.  This  not  only  gets  him  through  the  whitelist 
(which 
is  defined  by  himself)  but  also  gives  him 
settingsHandle  to  represent  the  above  two  URLs.  In 
the second step, Bob impersonates the RP: whenever Alice 
visits  Bob’s  website,  the  website  generates  BRM2,  which 
binds  RP-App  to  Bob’s  settingsHandle  through 
openid.return_to.  As  a  result,  Bob  will  get  loc  in 
BRM5,  allowing  his  browser  to  impersonate  Alice’s,  as 
described  before.  This  plan  turned  out  to  work  nicely.  A 
video demo is in [33].  
sets  settingsHandle 
Other JanRain SSO schemes. We found that the same 
exploit  also  worked  on  JanRain’s  wrapping  of  YahooID 
SSO. However, JanRain’s wrapping of Facebook SSO uses 
a different way to bind AppName and settingsHandle: 
it 
under 
AppName.rpxnow.com.  To  exploit  this  SSO,  we  had  to 
figure  out  a  way  to  let  Bob-App.rpxnow.com  set  the 
settingsHandle  cookie  for  RP-App.rpxnow.com.  In 
other  words,  the  security  of  the  scheme  can  be  reduced  to 
the following question: 
cookie 
as 
a 
Do browsers allow cross-(sub)domain cookies to be set?  
 Access control for browser cookies, especially between 
subdomains, is a complex issue, which has been studied for 
example  in  [8].  We  learned  from  existing  literature  that 
browsers at least share cookies of an HTTP domain with its 
corresponding HTTPS domain. This implies a disappointing 
fact  –  Facebook-wrapped  JanRain  SSO  cannot  secure 
HTTPS  websites  even  when  it  is  over  HTTPS.  Imagine  a 
banking website that runs this SSO scheme over HTTPS in 
order to protect the communication from a network attacker, 
e.g., a malicious router. Whenever the user visits any HTTP 
website, like google.com, the network attacker can insert a 
hidden  iframe  to  access  http://RP-App.rpxnow.com,  which 
sets  the  settingsHandle  cookie  for  this  subdomain. 
The cookie will be shared with https://RP-App.rpxnow.com 
(the HTTPS domain), making the above exploit succeed. 
Bug  reporting  and  JanRain’s  responses.  We  have 
reported  this  issue  to  JanRain,  who  acted  quickly  to  fix  it 
within  two  days.  Later  JanRain  notified  us  that  due  to  a 
compatibility  issue  with  their  legacy  systems,  their  fix  for 
the  JanRain-Facebook  issue  had  to  be  rolled  back.  The 
developers were working on a new fix. 
4.4.  Freelancer.com, Nasdaq.com and NYSenate.gov  
the  world’s 
Freelancer.com 
online 
outsourcing  marketplace  [17],  which  helps  match  buyers’ 
projects  to  the  services  that  sellers  can  offer.  The  website 
has  about  3  million  users,  1.3  million  projects  and  earned 
over 100 million dollars. Like many other websites today, it 
largest 
is 
374
allows Facebook sign-on, but in a different fashion: a user 
first  needs  to  register  an  account,  as  what  happens  on  a 
website  not  supporting  SSO;  then,  she  can  “link”  this 
account to her Facebook account, which allows her to log in 
through Facebook afterwards. Therefore, the security of this 
SSO critically depends on the linking process.  
We  found  other  high-profile  websites  that  also  enable 
SSO through account linking, such as Nasdaq.com (linkable 
to  Facebook  accounts)  and  NYSenate.gov  (linkable  to 
Twitter accounts). We have confirmed that they all contain 
exploitable  vulnerabilities  similar  to  that  of  Freelancer, 
which we describe below as an example.  
Analysis  result.  We  used  our  analyzer  to  study  the 
traces  collected  from  a  user’s 
linking  operation  on 
Freelancer.com under different adversarial scenarios. Figure 
14 describes what we found under Scenario (C), where Bob 
has a malicious web page in Alice’s browser, which can call 
other websites’ APIs. Specifically, BRM1 queries Facebook 
(the IdP) for Alice’s profile data. BRM3 does the linking3. 
In  BRM2,  Facebook  generates  a  secret  result.  As 
described  in  the  previous  Facebook  example,  BRM3  takes 
advantage  of  the  browser-side  security  mechanism  to  pass 
result  to  the  RP’s  page. Then,  Freelancer.com  (the  RP) 
sets  the  value  of  result  in  cookie  fbs,  and  calls 
lnk.php  to  do  the  linking.  As  we  can  see  from  the 
analysis, the system needs to ensure that fbs indeed holds 
Alice’s Facebook profile data when lnk.php is called.  
BRM1:src=RP dst=http://!IdP/permissions.req 
Arguments: app_id[BLOB] ↓ & cb[SEC][BG] &   
   next[URL]{   
      http://!IdP/connect/xd_proxy.php↓?  
      origin[BLOB] ↓&transport[WORD] ↓ 
   } & … & … & … (other 14 elements ) 
BRM2:src=!IdP  dst=http://!IdP/xd_proxy.php↓ 
Arguments: origin[BLOB] ↓ & transport[WORD] ↓& 
           result[SEC] & … & … (other 4 elements )
BRM3:src=!IdP dst=http://RP/facebook/lnk.php
Arguments: auto_link[INT] ↓  & goto_url[URL] ↓ 
Cookies: fbs[SEC] 
Figure 14: Traffic for scenario (C) 
  Flaw and exploit. The opportunity we see is that Bob 
can log into Freelancer as Alice if his web page in Alice’s 
browser  manages  to  link  her  Freelancer  account  to  Bob’s 
Facebook account. To this end, two things must happen: (1) 
the  page  signs  Alice’s  browser  onto  Bob’s  Facebook 
account, and then (2) it makes the browser do the linking.  
Linking from Alice’s browser. Let us  first assume  that 
Step (1) has succeeded, and focus on (2). The trouble here is 
that Bob’s page cannot produce BRM1, due to the presence 
of a browser-generated secret cb. Alternatively, we can try 
to  directly  invoke  BRM3.  The  only  hurdle  here  is  that 
without  BRM1–BRM2,  cookie  fbs  would  not  been 
3  This  step  includes  the  client-side  communication  to  pass  the 
token result from an IdP’s page to an RP’s page (Section 4.2).  
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:47:30 UTC from IEEE Xplore.  Restrictions apply. 
assigned the profile data of the current Facebook logon user. 
Interestingly, we found that by making the browser visit the 
page  http://freelancer.com/users/change-settings.php  (no 
argument  required),  the  current  Facebook  user’s  profile  is 
queried  and  set  to  cookie  fbs.  The  visit  is  essentially  an 
API call to accomplish BRM1–BRM2 with no secret. Bob’s 
page can then make the request of BRM3 for the linking.  
Signing Alice’s browser onto Bob’s Facebook account. 
Now we look at how to make step (1) happen. We analyzed 
the  traffic  of  Bob  signing  onto  Facebook  from  his  own 
browser,  which  was  a  POST  request  to  https://www 
.facebook.com/login.php with username and password as its 
arguments.  The  same  request,  however,  was  denied  by 
Facebook  when  it  was  produced  by  Bob’s  page.  A 
comparison between the traces of the two requests revealed 
that  the  referrer  header  in  the  successful  one  was  set  by 
Facebook.com,  while  that  of  the  failed  request  was  within 
Bob’s  domain.  We  had  known  from  various  sources  that 
referrer-checking is an  unreliable  means  for discriminating 
cross-site requests from same-site ones, because the referrer 
header  is  sometimes  removed  at  the  network  layer  for 
legitimate privacy reasons [5]. We tested the login request 
again with its referrer removed, Facebook accepted it. Thus, 
an exploit comes down to the answer to the question below:  
How to send a POST request with no referrer header?  
This question turned out to have known answers. Two 
browser  experts  pointed  us  to  some  working  examples,  as 
well as information resources, such as [26]. We tested one 
of  the  working  examples,  shown  in  Figure  15,  and 
confirmed that it works on the latest versions of IE, Chrome 
and Firefox. Using this approach, we were able to sign in as 
Alice  on  Freelancer.com,  thereby  confirming  the  presence 
of  the  logic  flaw  in  its  integration  of  Facebook’s  SSO 
service.  As  discussed  before,  the  same  vulnerability  exists 
on  Nasdaq.com  and  NYSenate.gov.  The  SSO  of 
NYSenate.gov is through Twitter.  
a.html     
b.html 
     formFrame.document.body.innerHTML= '  '; 
formFrame.document.all.tfm.submit();      
Figure 15: an implementation of referrer-free posting 
Bug reporting and Freelancer’s response. We reported 
the  issue  to  Freelancer.  The  company’s  CEO  Matt  Barrie 
thanked us and asked for suggestions about the fix [33]. We 
offered two suggestions, of which Freelancer adopted one.  
4.5.  OpenID’s Data Type Confusion 
Our  study  on  OpenID-based  systems  also  uncovers  a 
serious  logic  flaw,  which  is  caused  by  the  confusion 
between  the  RP  and  the  IdP  on  the  interpretation  of  BRM 
elements.  We  believe  that  the  problem  is  pervasive.  It  has 
been confirmed on Shopgecko.com, one of the first adopters 
375
(value.email 
of PayPal Access (PayPal’s new SSO service announced on 
10/13/2011),  and  Toms.com,  a  shopping  website.  The 
findings were made a few days before our paper submission. 
Flaws  and  exploits.  Let’s  look  at  the  BRM  traffic  of 
Smartsheet and GoogleID in  Figure 8. Our analysis  shows 
that  openid.ext1.type.email  (type.email  for 
short), an element in BRM1 and BRM3, is writable under 
Scenario (A) (where Bob controls the web client). A further 
analysis  of  the  element  reveals  that  it  affects  the  value  of 
openid.ext1.value.email 
for 
short), a signed element in BRM3. The RP typically treats 
this element as a user’s email address, but Google (the IdP) 
thinks  differently.  It  actually  sets  the  element’s  value 
according to type.email. Initially in BRM1, the RP sets 
the  value  of  type.email  to  http://schema.openid.net 
/contact/email,  OpenID’s  type  for  emails.  However,  Bob 
can  change  it  to  other  types,  such  as  http://axscheme.org 
/namePerson/first  (OpenID’s  data  type  for  first  names).  
As  a  result,  value.email  in  BRM3  can  hold  the  user’s 
first name. This enables an exploit if Bob could register with 
Google  a  first  name  “PI:EMAIL”.  Remember 
that 
Smartsheet  uses  the  registered  email  of  a  user  as  her 
authentication  token.  This  type  confusion  can  lead  to 
signing  Bob  onto  Alice’s  account.  We  confirmed  that 
Smartsheet indeed takes Bob’s first name as an email during 
the exploit. We believe that the misunderstanding about the 
content of  value.email is pervasive, given that Google 
developer’s guide only uses value.email as an example 
of  requested  user  attributes  in  its  specification,  and  never 
mentions how its content is actually determined [19].  
ID’s  user 
registration  page  does  not 
However,  this  exploit  did  not  get  through,  because 
Google 
treat 
“PI:EMAIL”  as  a  valid  first  name.  Therefore,  a  natural 
question produced by our analysis is whether there is a way 
to use “PI:EMAIL” as the value of any non-email field in 
Bob’s  Google  ID  profile,  maybe  through  direct  API  calls 
instead of the user registration page. 
Now  we  show  where 
this  exploit  does  work. 
Shopgecko.com identifies a user by her PayPal ID, which is 
not  a  secret.  The  type  of  the  ID  is  https://www.paypal 
.com/webapps/auth/schema/payerID, which Bob can change 
to  http://schema.openid.net/contact/street2, 
type  of 
“mailing address’ second line”. We successfully registered a 
user  whose  mailing  address’  second  line  is  Alice’s  PayPal 
ID.  For  toms.com,  we  found  the  element  “email”  in  fact 
contains a user’s Twitter ID during a Twitter SSO, though it 
indeed  carries  email  addresses  in  other  SSOs,  such  as 
Google ID. Bob, a Google user, can register his first name 
as “AliceOnTwitter”, which is Alice’s Twitter ID, and sign 
in as Alice through Google.   
the 
Bug reporting. We have reported the end-to-end cases 
to  PayPal,  Google,  OpenID  Foundation,  Toms.com  and 
Magento  (developer  of  Shopgecko).  Google  will  fix  it  by 
checking the value of type.email. Google also asked us 
to directly bring this issue to the attention of the executive 
director of OpenID Foundation.    
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:47:30 UTC from IEEE Xplore.  Restrictions apply. 