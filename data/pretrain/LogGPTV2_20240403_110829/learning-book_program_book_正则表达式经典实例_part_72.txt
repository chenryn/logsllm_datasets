正则流派：.NET、Java、PCRE、Perl、Python、Ruby1.9
JavaScript和Ruby1.8并不支持逆序环视。我们必须去掉在正则式开头，用来保证不会
找到位于一长串十六进制数和冒号序列中的IPv6地址的检查。但是我们也不能使用单
词边界，因为地址可能会以冒号开始，而冒号不是一个单词字符：
:)
#混合形式
(?:
#没有压缩的形式
(?:[A-F0-9](1, 4}:){6}
#被压缩为包含最多6个冒号
1 (?=(?:[A-F0-9] (0, 4}:) {0, 6}
(？:[0-9](1,3}\.){3}[0-9](1,3}
#和4个字节数
(?![: .\w]))
#和定位符
#以及最多1对连续冒号
(([0-9A-F]{1, 4} :) {0, 5}1:)((:[0-9AF](1, 4}){1, 5} : I:)
#255.255.255.
(?:(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?)\.){3}
255
（[6-0]6-0]0]16-0]-0]1-0]:)
1#标准形式
(?: [A-F0-9]{1, 4):){7)[A-F0-9}{1, 4}
1#压缩为最多包含7个冒号
(?=(?:[A-F0-9]{0, 4}:) {0, 7}[A-F0-9](0, 4}
372
第7章
www.TopSage.com
---
## Page 389
（？！[：.\w]））#和定位符
以及最多1对连续冒号
(([09AF]{1, 4):)(1, 7}1:)((:[0-9A-F]{1, 4}){1, 7}1 :)
（[M\·:]i）（
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
(?:(?: (?: [A-F0-9]{1, 4) :) (6} 1(?=(?: [A-F0-9] (0, 4) :) (0, 6} (?: [0-9] {1, 3)\.) {3}
[0-9]{1, 3} (?![: . \w])) (([09AF] {1, 4) :) {0, 5} 1:)((: [09A-F] {1, 4}) {1, 5} : 1 :))
(?: (?: 25[0-5]12 [0-4] [0-9] 1 [01] ? [09] [0-9] ?) \.) {3} (? :25[0-5]12[0-4] [0-9] 1
[01]?[0-9][0-9]?) 1(? : [A-F0-9]{1, 4} :) {7}[A-F0-9]{1, 4} |
(?=(? : [A-F09](0, 4) : ) (0, 7}[A-F0-9] {0, 4} (?![: . \w])) 
（([0-9A-F]{1, 4}:){1, 7} 1:) ((:[09A-F]{1, 4}){1, 7}1:)) (?![: . \w])
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
由于IPv6地址拥有不同的标记法，所以匹配IPv6地址就不像匹配IPv4地址那么简单。
你打算支持哪种标记法的IPv6地址会在很大程度上影响到正则表达式的复杂度。根本
上来说，IPv6总共包含两种标记法：标准和混合的。你可以决定是否只允许两种标记
法的其中之一，还是二者都允许。这样我们就需要使用3组正则表达式。
标准标记法和混合标记法都包含一种省略0的压缩形式。如果充许压缩标记法，那么
我们还需要再添加3组正则表达式。
根据你是想检查一个给定的字符串是一个有效的IPv6地址，还是要在-大段文本中
查找一个IP地址，正则表达式也会稍微有点不同。为了对IP地址做合法性验证，
我们需要使用在实例2.5中讲解的定位符。JavaScript中需要使用（和定位符，
而Ruby中可以使用和。其他所有流派则可以支持这两种定位符。Ruby也
支持（和S)，但是会同时允许它们匹配在字符串中内嵌的换行符。因此只有当你
已经知道在字符事汇总中不包含任何内嵌的换行符的时候，才能使用脱字符和美元
符号。
如果要在一大段文本中查找IPv6地址，那么我们就需要使用否定型逆序环
视和否定型顺序环视匹配1～4个十六进制字符，它可以匹配
一个带有可选的前缀0的16bit字数。在其中的字符类（实例2.3）中只列出了大写字
母。使用大小写无关匹配模式可以把小写字母也匹配进来。关于你的编程语言中如何
设定匹配模式，请参考实例3.4中的讲解。
非捕获分组（(?:[A-F0-9](1,4):)(7}>会匹配一个后面紧跟着一个字面上的冒号的十六
进制数。后面的量词会把这个组重复7次。如实例2.9中的说明一样，正则式中的第一
个冒号是正则式对非捕获分组语法的一部分，正则式中的第二个冒号是一个字面上的
冒号。在一些非常特殊的情况下，冒号会被用作更大的正则记号中的-一部分，这种时
候冒号是元字符，而除了这些情况之外，冒号在正则表达式中一般都不是一个元字符。
所以，我们并不需要使用反斜杠来转义正则表达式中字面上的冒号。虽然可以对它进
行转义，但这只会使我们的正则表达式更加难以读懂。
混合标记法
用来匹配混合IPv6标记法的正则式由两个部分组成。将它定位到目标文本的开端。然后就会使用一个肯定型的顺
序环视。它会检查是否可以匹配到1～8个由字母和/或（x>组成的序列，而且
当匹配到这1～8个字母之后，就到达了字符串的结尾。在顺序环视内的是至关重
要的。为了把正则式匹配的字符串限制在8个或更少的字符，这个顺序环视必须检查
在它已经匹配到的字符之后不会再跟着更多字符。
在另外一种情况下，你可能要使用另外一种分界符来代替（A）和Z>。如果要对
aaaaxbbb和类似的字符串来执行“整字匹配”的查找，那么你就需要使用某种分隔符，
并且必须把匹配字符串结尾的分隔符放在顺序环视内和正则表达式结尾处。如果不这
样做，那幺正则表达式会部分匹配一个含有太多字符的字符串。
当满足了顺序环视的要求后，顺序环视就会放弃已经匹配到的数据。这样，当正则式
376第7章
www.TopSage.com
---
## Page 393
引擎企图匹配（a{0,7)>时，就会回退到字符串的开始。顺序环视并不会消耗它所匹配到
的文本，这正是顺序环视和非捕获分组之间的一个关键区别，而这就会允许我们对一
个文本片段应用两个模式。
尽管（a{0,7}xb{0,7}>自身可以匹配至多15个字母，在这个例子中它只能匹配到8个字
母，这是因为顺序环视已经保证了只会包含8个字母。（a{0,7}xb{0,7)>需要做的所有事
情只是检查一下它们是否会以正确的顺序出现。实际上，（a*xb*在这个正则表达式中
会同（a{0,7}xb{0,7}>有完全一样的效果。
正则式结尾的第二个亿>同样也是至关重要的。正如顺序前视需要确保其中不会包含
太多字母一样，顺序环视之后的第二个测试需要确保所有的字母出现的顺序是正确的。
这样就可以确保我们不会匹配到诸如axba这样的字符串，尽管它的长度在1～8字符之
间，可以满足顺序环视的要求。
压缩的混合标记法
混合标记法可以和标准标记法一样进行压缩。虽然结尾的4个字节数哪怕是零也
必须被指定，在它们之前的十六进制数的个数还是可变的。如果所有的十六进制
数字都是零，那么这个IPv6地址结果看起来会像是个前面带了两个冒号的IPv4
地址。
为压缩的混合标记法创建一个正则式会涉及压缩的标准标记法要解决的同样问题。上
一个小节详细解释了这些问题。
用于压缩的混合标记法的正则式和用于压缩的（标准的）标记法的正则式之间的
主要区别在于，用于压缩的混合标记法的正则式中需要检查6个十六进制数后的
IPv4地址。我们会在正则式的结尾处做这个检查，所使用的正则式与我们在实例
7.16中用来精确匹配非压缩混合标记法的IPv6地址中的IPv4地址的正则式是-
样的。
我们必须在正则式的结尾匹配一个IPv4部分，但也必须在顺序环视内检查IPv4地址部
分，以确保不会在IPv6地址中匹配超过6个冒号或6个十六进制数字。因为我们已经
在正则式结尾做了一个精确的检查，因此顺序环视中只用一个简单的IPv4检查就足够
了。该顺序环视不需要对IPv4部分做合法性验证，因为正则式的主体部分已经保证了