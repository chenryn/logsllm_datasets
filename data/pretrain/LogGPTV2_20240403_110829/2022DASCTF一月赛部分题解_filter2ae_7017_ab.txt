    >>> for i in range(56, 0, -1):
    ...     enc[i] ^= 0xee
    ...     enc[i] ^= enc[i-1]
    ...
    >>> enc[0] ^= 0xee
    >>> enc
    [80, 102, 116, 101, 80, 56, 127, 116, 68, 95, 107, 63, 80, 76, 65, 62, 68, 98, 60, 56, 69, 76, 93, 60, 70, 95, 93, 61, 80, 95, 69, 121, 83, 92, 93, 60, 69, 72, 61, 102, 71, 79, 86, 97, 68, 97, 89, 60, 69, 92, 93, 57, 71, 102, 74, 52, 0]
    >>> bytes(enc)
    b'PfteP8\x7ftD_k?PLA>Db>>
    >>> enc
    [90, 109, 120, 104, 90, 51, 115, 121, 78, 84, 103, 50, 90, 71, 77, 51, 78, 105, 48, 53, 79, 71, 81, 49, 76, 84, 81, 48, 90, 84, 73, 116, 89, 87, 81, 49, 79, 67, 49, 107, 77, 68, 90, 108, 78, 106, 85, 49, 79, 87, 81, 52, 77, 109, 70, 57, 0]
    >>> bytes(enc)
    b'ZmxhZ3syNTg2ZGM3Ni05OGQ1LTQ0ZTItYWQ1OC1kMDZlNjU1OWQ4MmF9\x00'
    >>> base64.b64decode(b"ZmxhZ3syNTg2ZGM3Ni05OGQ1LTQ0ZTItYWQ1OC1kMDZlNjU1OWQ4MmF9")
    b'flag{2586dc76-98d5-44e2-ad58-d06e6559d82a}'
###  babyre
首先去除几种花指令。
第一种：
第二种：
第三种：
然后看到是进行了控制流平坦化混淆，但此程序代码量不多，也就相当于没加了。
其次程序中涉及的两个运算，整理一下：
    ~a&b|~b&a
    (a&0xf4|~a&0xF0C4020B)^(b&0xf4|~b&0xb)
其实两个都是异或运算，自己化简和拿数据测试一下。
    >>> a = 47
    >>> b = 69
    >>> a^b
    106
    >>> ~a&b|~b&a
    106
    >>> c = (a&0xf4|~a&0xF0C4020B)^(b&0xf4|~b&0xb)
    >>> c&0xff
    106
    >>>
最后加密就是一些异或和换表base64，如下面的base64
解密：
    table = "QVEJAfHmUYjBac+u8Ph5n9Od16FrICL/X0GvtM4qk7T2z3wNSsyoebilxWKgZpRD"
    enc = "Fi9X/fxX6Q6JBfUfBM1V/y6V6PcPjMaQLl9IuttFuH68"
    if '=' in enc:
        enc = enc.replace("=", '')
    tmp = [table.index(i) for i in enc]
    print("index = ", tmp)
    tmp1 = ''
    for i in tmp:
        tmp1 += bin(i)[2:].rjust(6, '0')
    res = []
    for i in range(0, len(tmp1), 8):
        res += [int(tmp1[i:i+8], 2)]
    print(res)
    print(tmp)
    for i in range(11):
        for j in range(i):
            res[3*i+0] ^= tmp[4*j+0]
            res[3*i+1] ^= tmp[4*j+1]
            res[3*i+2] ^= tmp[4*j+2]
    print(bytes(res))
    print(res)
    num = []
    key = 0
    for i in range(8):
        num += [int.from_bytes(res[4*i:4*(i+1)], "little")]
        key ^= num[i]
    key = list(key.to_bytes(4, "little"))
    print(key)
    flag = [res[i]^key[i%4] for i in range(len(res))]
    print(bytes(flag)
    #fce5e3dfc6db4f808ccaa6fcffecf583P
因为是填充了一个字节的，所以正确的输入就是 **fce5e3dfc6db4f808ccaa6fcffecf583**
## Crypto
###  babyrsa
    import os
    from secret import FLAG,p,q,e
    from Crypto.Util.number import bytes_to_long,long_to_bytes
    N = p*q
    def encrypt(m,N,e):
        return pow(m,e,N)
    def decrypt(c,N,d):
        return pow(c,d,N)
    def padding(msg):
        res = msg
        if len(res) < 128:
            res = res + os.urandom(128-len(res))
        return res
    def transfer(msg):
        assert len(msg) < 128
        m = padding(msg)
        return bytes_to_long(m)
    if __name__ == "__main__":
        m = transfer(FLAG)
        print(N,e)
        print(encrypt(m,N,e))
rsa中n可以直接查询数据库分解的模板题。[在线分解](http://factordb.com/index.php)
    import gmpy2
    from libnum import *
    n = 13123058934861171416713230498081453101147538789122070079961388806126697916963123413431108069961369055630747412550900239402710827847917960870358653962948282381351741121884528399369764530446509936240262290248305226552117100584726616255292963971141510518678552679033220315246377746270515853987903184512948801397452104554589803725619076066339968999308910127885089547678968793196148780382182445270838659078189316664538631875879022325427220682805580410213245364855569367702919157881367085677283124732874621569379901272662162025780608669577546548333274766058755786449491277002349918598971841605936268030140638579388226573929
    e = 2199344405076718723439776106818391416986774637417452818162477025957976213477191723664184407417234793814926418366905751689789699138123658292718951547073938244835923378103264574262319868072792187129755570696127796856136279813658923777933069924139862221947627969330450735758091555899551587605175567882253565613163972396640663959048311077691045791516671857020379334217141651855658795614761069687029140601439597978203375244243343052687488606544856116827681065414187957956049947143017305483200122033343857370223678236469887421261592930549136708160041001438350227594265714800753072939126464647703962260358930477570798420877
    enc = 1492164290534197296766878830710549288168716657792979479408332026408553210558539364503279432780006256047888761718878241924947937039103166564146378209168719163067531460700424309878383312837345239570897122826051628153030129647363574035072755426112229160684859510640271933580581310029921376842631120847546030843821787623965614564745724229763999106839802052036834811357341644073138100679508864747009014415530176077648226083725813290110828240582884113726976794751006967153951269748482024859714451264220728184903144004573228365893961477199925864862018084224563883101101842275596219857205470076943493098825250412323522013524
    p = 98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033
    q = 133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513
    assert p*q == n
    nn = (p-1)*(q-1)
    d = gmpy2.invert(e, nn)
    flag = int(pow(enc, d, n))
    print(n2s(flag))
    #b'hwctf{01d_Curs3_c4Me_Again}vG\x03MC\xcd\xfd\x1d\x0bO\xcaV\x9b\x87vk\xd6\xb3\xbb\x8f\xc5\xd61\xdf7\x0f\x90\xc6\x17oj]\xf5J\xd4\xa9\xcc\xdb\xbe?\xb2(\xf0\xb2\xb6\x99b\xa7e\xa8\x82\xf7SY\xc7\xd9\xde\xc4\xb5\xe3q\xc1\xe8\xfeM\xbd\xbe\xfdD\xed\xb3\x12~\x9d\xba\xa4\xb0\xfek\x81\xc4-\x82\xb3%\xae4\x7fGl\x9a\xac\xc3\x91\xc1\xbc\x04\x03o\xa4\x8d'