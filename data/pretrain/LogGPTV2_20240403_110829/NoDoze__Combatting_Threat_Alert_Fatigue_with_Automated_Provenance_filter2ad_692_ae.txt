8.0
9.0
19
17
23
15
12
12
8
11
10
15
21
16
24
20
11
11
8
12
9
15
49
48
65
36
48
40
36
33
36
45
100%
100%
100%
100%
88%
100%
100%
100%
100%
100%
0%
0%
0%
0%
0%
0%
0%
0%
0%
0%
100%
100%
100%
100%
84%
100%
90%
100%
100%
100%
0.03%
0%
0%
0%
0%
0.07%
0%
0.01%
0%
0%
(a) NODOZE response times to assign scores and
build concise graphs.
(b) Underlying provenance tracker response times
to build complete graphs.
(c) End-to-end response times from input alerts to
the results.
Fig. 7: CDF of query response times for all the 364 threat alerts in our dataset.
in the concise graph generated by NODOZE. For all 10 APT
attacks, we were able to recover the alert’s expected control
dependency graph except for Netcat attack where the expected
length of control dependency path was larger than user-deﬁned
τl. Note, this does not affect the correctness of causality anal-
ysis since cyber analysts can increase the depth of the path by
increasing τl during the alert investigation. In some cases, we
were not able to completely recover the data dependency graph
because incorporating those data dependencies required larger
merge threshold τm than set in our experiments. However,
increasing the merge threshold also increases the number of
FP in the data dependencies. Thus, ﬁnding the best possible
thresholds which strike a balance between TP and FP require
training run once before deployment in an enterprise.
Nevertheless, NODOZE decreases the size of original graph
by two orders of magnitude which accelerates the alert investi-
gation without losing vital information about attack. To further
explain how well can NODOZE capture the attack scenarios,
we will discuss two attack cases from Table II in §IX.
E. Time Saved Using NODOZE
Recent studies [2], [6] have shown that it takes around
10-40 mins to manually investigate a single threat alert in an
enterprise. This time spent on an investigation is also known as
Mean-Time-To-Know in industry. Note that these studies have
also conﬁrmed that cyber analysts receive around 60-80% false
alarms using existing TDS, which was also the false alarm rate
of the baseline TDS used in our experiments.
If we conservatively assume cyber analysts spend 20 mins
on average on each false alarm in our experiments they would
have to waste around 104 employee-hours on investigating
those false alarms. However, NODOZE reduces false alarms
of existing TDS by 84%, which saves around 90 employee-
hours in an enterprise setting.
F. Runtime Performance of NODOZE
To answer RQ4, we measured the runtime overhead of
NODOZE for all the alerts in our dataset. NODOZE’s response
time for all the 364 alerts events is shown as a CDF in Fig. 7a.
This response time includes running anomaly propagation
algorithm and generating a concise dependency graph for given
alerts. Results show that 95% of all the alerts are responded by
NODOZE in less than 40 seconds. There are few cases where
NODOZE took a long time to respond. In these cases, most
time was spent on constructing a large transition probability
matrix for a large input dependency graph.
To further understand why NODOZE has large response
times in some cases, we also measured the dependency graph
generation query response times for all 364 alerts in our
dataset. The results are shown in Fig. 7b. Complete graph
generation also has long response times because of extra
large dependency graph construction. For these large depen-
dency graphs, NODOZE also incurs larger overhead due to
the reasons mentioned above. However, because we rarely
encountered this issue in our experiments and other provenance
tracking techniques [49], [52] also suffer from this perfor-
mance problem, we leave solving this problem for future work.
CDF for end-to-end response time starting from the time alert
is received until the alert is triaged is shown in Fig. 7c. 95%
of the threat alerts are responded in less than 200 seconds.
Note that right now NODOZE analysis framework runs on a
single machine using single thread; however, NODOZE can be
11
 0 0.2 0.4 0.6 0.8 1 0 50 100 150 200 250 300 350 400CDFResponse Time (secs)NoDoze 0 0.2 0.4 0.6 0.8 1 0 50 100 150 200 250CDFResponse Time (secs)Prov. Tracker (Backward)Prov. Tracker (Forward) 0 0.2 0.4 0.6 0.8 1 0 100 200 300 400 500 600CDFResponse Time (secs)Prov Tracker + NoDoze(a)
(b)
Fig. 8: Data theft attack scenario discussed in §IX-A. (a) Part of dependency graph generated by traditional tools. (b) Concise true alert
dependency graph generated by NODOZE.
parallelized easily using existing distributed graph processing
frameworks (details in §X).
IX. CASE STUDIES
A. Data Theft Attack
Scenario.
In this attack, an employee of a mobile app
development company stoles app designs that were about to be
released and posted them online. To perform this data theft at-
tack, employee downloads a malicious bash script (stealer.sh)
to the data server via HTTP. Bash script (stealer.sh) discovers
and collects all the application designs on the server. Then,
the script compresses (tar) all the design ﬁles (design1.png
and design2.png) into a single tarball, transferred the tarball
to a low-proﬁle desktop computer via SSH, and ﬁnally uploads
it to an external FTP server under employee’s control. Since
the employee is aware of the company’s TDS, the bash script
also creates a bunch of spurious processes to create false alerts
which buys the employee enough time to complete the attack
and post the designs online.
Threat Alerts. Once the bash script is executed many threat
alerts are generated by TDS in a short period of time, which
are investigated by cyber analyst one by one. The dependency
graph of these threat alert is shown in Fig. 8a where dashed
edges show threat alert events.
Alert Investigation. Without NODOZE, an investigator will
generate a complete dependency graph for each of the threat
alerts generated by TDS and manually inspect them only to see
that just 1 of the 4 threat alerts was true attack. However, by the
time investigator has examined all the false alerts (∼1.6 hours),
all the app designs may have already been posted online.
On the other hand, NODOZE will ingest all these threat
alerts and rank them based on their anomaly score. In this
scenario, all the false alerts intentionally created by the attacker
will be ranked lower while the true alert will be ranked higher.
The threat alert events which led to data theft will be ranked
on the top because of various rare events in its progeny. For
example, using cp utility to copy data.tar to the ftp serving
directory and using ftp to make a connection outside the
organization. This chain of events has never happened in the
organization. Contrary to this, events in the progeny of all the
false threat alerts were quite common such as running g++ and
Linux utilities.
NODOZE also generates a concise dependency graph with
only data theft dependency paths, while all the benign paths
have been removed as shown in Fig. 8b. Observe that in
Fig. 8a, the progeny of the true threat alert event has various
operations such as run-parts and dpkg, which are removed in
the NODOZE generated graph because their anomaly score is
lower than the data theft dependency path. Note that NODOZE
generated graph has some socket vertices connected to chromium
and sshd which are unrelated to attack but they are included in
NODOZE’s graph because they were rare. Note that Table III
shows the FP rate higher than 0 due to these unrelated socket
connections. Nevertheless, NODOZE decreases the original
graph size by 2 orders of magnitude.
B. ShellShock Attack
Scenario. In this attack scenario, attacker targets a ShellShock
vulnerable Apache webserver to open several reverse shells and
steals sensitive ﬁles. The attacker launches the attack in two
phases. In the ﬁrst phase, the attacker runs some Linux utilities
(e.g.,ls, top) without doing serious damage. In the second
phase, the attacker tries to discover sensitive data on webserver
using commands such as ‘/bin/cat /etc/passwd‘ and ‘/bin/cat
/var/log/access logs‘ . Once the sensitive ﬁles are found, the
12
High Anomaly Score Progeny bashstealer.shtarrmscpcatchromiumdata.tartarbash        design1.pngﬁle2.txtﬁle2.tarsshsshd          sshdsshdsshdbashscpdata.tarcp/ftp/data.tarsshdbashrun-partsrun-parts  bashdpkgftp          bashbashjavapythonbashbash   bashg++cut      design2.pngg++     vim    bash.bash_history   vim  wgetgrepLow  Anomaly Score Progenybashstealer.shscpchromiumdata.tartar design1.pngsshsshdbashscpdata.tarcp/ftp/data.tarftpdesign2.pngFig. 9: ShellShock attack scenario discussed in §IX-B. (a) Part of dependency graph generated by traditional tools. (b) Concise true alert
dependency graph generated by NODOZE.
(a)
(b)
attacker archived (tar) and compressed (bzip2) the sensitive
ﬁles and transferred (cp) it to Apache hosting directory so
that attacker can download (wget) it from another machine.
Once this phase is done, the attacker erased the history of
bash commands by removing .bash history. Later, noises were
introduced when a normal user opened new bash terminals.
These terminals read the modiﬁed .bash history creating a
false causal link to the attack.
Threat Alerts. This attack scenario simulation generated
various threat alerts events because spawning a nc.traditional
from bash process is considered as anomalous behaviour by
TDS. These threat alert events are indicated by dashed arrows
in Fig. 9a.
Alert Investigation. The forward dependency graph of all the
threat alert events consists of bash commands which are quite
common in the enterprise such as ls and cat. However, alert
event E3 consist of other commands which are not common
in an organization such as ‘/bin/cat /etc/passwd‘ and ‘cp
data.tar.bz2 /var/www/‘. All the threat alert events will be
ranked lower than alert event E3 because the progeny graph of
alert event E3 contains most anomalous dependency paths as
compared to other alert events.
Fig. 9b shows the concise dependency graph generated by
NODOZE. NODOZE’s graph only has data exﬁltration while all
the common terminal commands are excluded from this graph
because of our behavioural execution partitioning technique.
This technique chooses alert dependency paths that have data
exﬁltration events over other dependency paths that launched
common terminal commands due to two reasons: 1) creation
and transfer of new ﬁles have low frequency in our event
database since these do not happen very often as compared
to running Linux utilities; 2) the dependency path for data
exﬁltration also wget’s sensitive ﬁles on other machines while
benign paths do not include any more anomalous behaviour.
X. LIMITATIONS & DISCUSSIONS
We outline the limitations of NODOZE through a series
of questions. We also discuss how NODOZE can be extended
under different scenarios.
What happens if an attacker uses benign process and ﬁle
names for an attack? NODOZE is resilient
to changes in
the ﬁle and process names. At ﬁrst glance,
it may seem
surprising; however, NODOZE inherits this from the use of
data provenance, which captures true causality, not merely
correlations. Even if the attacker starts a malware with a
benign program name such as Notepad, the causality of the
program such as how it was spawned and what changes it
induced differentiates its behaviour from the normal behaviour
of Notepad. Note that this property sets our work apart from
heuristics-based TDS (e.g., [68], [32]).
Can NODOZE be extended to incorporate distributed graph
processing frameworks for improved performance? NODOZE
uses a novel network diffusion algorithm to propagate the
anomaly scores on the edges of a large dependency graph
to generate an aggregate anomaly score. One can potentially
parallelize this algorithm using existing large-scale vertex-
centric graph processing frameworks [53]. In this work, we
do not enable distributed graph processing; however, we will
explore this option in future work.
Can NODOZE run anomaly propagation algorithm while gen-
erating the dependency graph from audit
logs? Currently,
NODOZE ﬁrst generates a complete dependency graph and
then it propagates the anomaly score on that dependency
graph. However, one can design a framework which propagates
the anomaly score while generating the large dependency
graph using iterative deepening depth ﬁrst search and stop the
analysis if anomaly scores do not increase in next iteration.
In this way additional step of generating a large dependency
graph ﬁrst can be removed completely.
What
is the role of underlying TDS in NODOZE’s effec-
tiveness? NODOZE is essentially an add-on to existing TDS
for false alarm reduction. Thus, NODOZE can detect
true
attack only if it was detected by the underlying TDS ﬁrst.
If underlying TDS misses true attack and does not generate an
alert, then NODOZE will not be helpful. Improving the true
detection rate of underlying TDS is orthogonal to our work;
however, our ﬁndings suggest that path-based context could be
a powerful new primitive in the design of new TDS.
Does the choice of underlying TDS affect the accuracy of