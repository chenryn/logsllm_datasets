Print，你可以Pyobject_Print（intobject），也可以Pyobject_Print（string
Pyobject_***的形式，可以应用在任何Python对象身上，比如输出对象的Byobject
的类型，类似于int对应着Python内部的PyInt_Type，object在Pyhon内部则对应着
是无所不知的。但是对于用户自定义的类型，比如通过classA（object)，定义的一个
&PyInt_Type)。
一类称为范型的API，或者称为AOL（Abstract Object Layer）。这类API 都具有诸如
图1-2还显示出，在Python2.2之后的newstyleclass中，int是一个继承自object
不论采用哪种CAPI，Python内部最终都是直接分配内存，因为Python对于内建对象
另一类是与类型相关的API，或者称为COL（ConcreteObjectLayer）。这类API通常
实际上，在Python完成运行环境的初始化之后，符号“int”就对应着一个表示为就是Python 内部的 PyType_Type，它是所
PyType_Type在Python的类型机制中是一个至关重要的对象，所有用户自定义class
仔细观察pyTypeObject，
类型的类型
第1章
sizeof(PyMemberbef),
"type"
PyObject_HEAD_INIT
一深度探索动态语言核心技术
Python对象初探
PyType_Type
图1-5PyType_Type与一般PyTypeObject的关系
会有一个有趣的发现。在PyTypeobject定义的最开始，
cype
>A.
PS3S
class
---
## Page 55
1.3
Type对象之间的关系：
这些宏在各种内建类型对象的初始化中被大量地使用着。
能从指针所指对象的ob_type域动态进行判断，而正是通过这个域，Python实现了多态
存和维护这个对象。其他对象也与此类似，所以在Python内部各个函数之间传递的都是
化。然后Python内部会用一个pyobject*变量，而不是通过一个Py主ntobject*变量来保
态的特性。在Pyihon创建一个对象，比如 PyIntobject对象时，会分配内存，进行初始
机制。
PyTypeObjectPyInt_Type=
[intobject.c]
#define PyObject_HEAD_INIT(type)
一种范型指针-
#endif
#else
Python对象的多态性
ob_refent
以PyInt_Type为例，可以更清晰地看到一般的类型对象和这个特立独行的pyType_
再回顾一下Pyobject和pyVarobject的定义，初始化的动作就一目了然了。实际上，
通过pyobject和pyTypeObject，Python利用C语言完成了C++所提供的对象的多
obival
int(10)
现在我们可以想象，看到一个整数对象在运行时的形象的表示了，如图1-6所示：
PyObject_HEAD_INIT(&RyType_Type)
#define_Pyobject_ExTRA_INIT
sizeof(PyIntobject),
PyObJect_EXTRA_INIP
#deflne_PyObieet_ExTRA_INIT O,O.
一Pyobject*。这个指针所指的对象究竟是什么类型的，我们不知道，只
图1-6运行时整数对象及其类型之间的关系
PyInt_Type
obtype
obrefent
tp_base
PyBaseObject_Type
Python源码剖析
ob:refent
obtypee
1.3
3Python对象的多态性
一深度探索动态语言核心技术
PyType_Type
ob_type
obrefent
25
---
## Page 56
Python源码剖析
.4
象的引用计数，从而也最终决定着该对象的创建与消亡。
在Python中每一个东西都是一个对象，都有一个ob_refcnt变量。这个变量维护着该对
员进行繁重的内存管理工作，而引用计数正是Pyhon垃圾收集机制的一部分。
高了开发效率，并降低了bug发生的几率。Pyhon同样也内建了垃圾收集机制，代替程序
用垃圾收集机制的语言来完成，这部分程序占了现存的大多数的程序。这样做的好处是提
价。现在看来，随着垃圾收集机制的完善，对时间要求不是非常高的程序完全可以通过使
放出来，但同时也剥夺了程序员与内存亲密接触的机会，并付出了一定的运行效率作为代
机制，比如Java和C#。垃圾收集机制使开发人员从维护内存分配和清理的繁重工作中解
正是万恶之源，大量内存泄露和悬空指针的bug由此而生，如黄河泛滥一发不可收拾。
面则对应着责任，程序员必须负责将申请的内存释放，并释放无效指针。可以说，这一点
个简单的例子：
不同情况下表现出了不同的行为，这正是多态的核心所在。
PyStringobject对象对应的类型对象中定义的输出操作。可以看到，这里同一个函数在
应的类型对象中定义的输出操作，如果指针是一个PyStringobject*，那么就会调用
[object.c]
引用计数
ong Pyobject_Haan(Pyobject*v)
Pyhon通过对一个对象的引用计数的管理来维护对象在内存中的存在与否。我们知道
现代的开发语言中一般都选择由语言本身负责内存的管理和维护，即采用了垃圾收集
在Pyhon中，主要是通过Py_INCREF（op）和Py_DECREF（op）两个宏来增加和减少一
前面已经提到的AOL的CAPI正是建立在这中“多态”机制之上的。下面给出了一
object->ob_type->tp_print(object);
第1章Python对象初探
在C或C++中，程序员被赋予了极大的自由，可以任意地申请内存。但是权利的另一
如果传给Print的指针是一个PyIntobject*，那么它就会调用PyIntObject对象对
PyTypeobject*op=
考虑下面的 Print函数：
一深度探索动态语言核心技术
v->ob_type
NULL
---
## Page 57
REES），引用计数的宏还要做许多额外的工作。下面展示的代码是Pyhon在最终发行时这
式的影子在ob_refcnt减为O之后，将触发对象销毁的事件。从Python的对象体系来
汇，实际上这个析构动作是通过在对象对应的类型对象中定义的一个函数指针来指定的，
构函数来释放该对象所占有的内存和系统资源。注意这里的“析构函数”借用了C++的词
引用计数初始化为1。
就是那个tp_aealloc。
个对象的引用计数。当一个对象的引用计数减少到O之后，PY_DECREF将调用该对象的析
技术，使用这种技术可以避免频繁地申请和释放内存空间。因此在析构时，通常都是将对
经多年背负了人们对其执行效率的不满）。一般来说，Python中大量采用了内存对象池的
的话，那频繁地申请、释放内存空间会使Python的执行效率大打折扣（更何况Pyhon已
注意的是，调用析构函数并不意味着最终一定会调用ee释放内存空间，如果真是这样
些宏所对应的实际的代码：
象
意代码，
个假设，
对象中静态完成的。
看
#define Py_XDECREF(op)if ((op）== NULL)elSe Py_DECREF(op)
#define
#detine
[object.h]
看，各个对象提供了不同的事件处理函数，而事件的注册动作正是在各个对象对应的类型
define
视为对类型对象的引用。
7
PyObject中的ob_refcnt是一个32位的整形变量，
如果熟悉设计模式中的Observer模式，就可以看到，这里隐隐约约透着Observer模
在一个对象的引用计数减为0时，与该对象对应的析构函数就会被调用，但是要特别
在Pyhon的源代码中可以看到，在不同的编译选项下（Py_REF_DEBUG，
“跳出三界外，不再五行中”
需要注意的是，在Pyhon的各种对象中，类型对象是超越引用计数规则的。类型对
else
1
，即对一个对象的引用不会超过一个整形变量的最大值。一般情况下，如果不是恶
_Py_Dealloc(/Pyobject
这个假设显然是成立的。
Py_NewReference(op)
(op）->ob_refentI=0)
INCREF（OP)
XINCREE(OP)
((op)->ob_refcnt++)
，永远不会被析构。每一个对象中指向类型对象的指针不
((op)
((op）->ob_refcnt=
>ob.type
NOLL)
Python源码剖析
>tp_dealloc)（(Pyobdect*（op)))
这实际蕴含着Pyhon所做的一
1）
be NULL:
1.4引1用计数
深度探索动态语言核心技术
PyTRACE
---
## Page 58
28
Python源码剖析
1.5
进入本书的第一部分，剖析Python的内建对象。
识已经足够我们支撑到细致剖析Python对象体系的那一天了。从现在开始，我们将正式
全正确，不过是提供一种看待Pyton中对象的视角而已。
清二楚。
象占用的空间归还到内存池中。这一点在接下来对Pyhon内建对象的实现中可以看得一
Python对象的分类
第1章Python对象初探
现在，我们已经有了一些关于Python对象体系的基本认识了，目前所掌握的这些认
Intermnal对象：Pyhon虚拟机在运行时内部使用的对象
Fundamental对象：类型对象
我们将Pyton的对象从概念上大致分为5类，需要指出的是，
图1-7列出了我们的对象分类体系，并给出了每一个类别中的一些实例：
Mapping对象：类似于C++中map的关联对象
Sequence对象：
Numeric对象：
method
module
function