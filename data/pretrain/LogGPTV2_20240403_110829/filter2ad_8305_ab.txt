](https://images.seebug.org/content/images/2019/01/27fa75cb-520b-4132-ad3a-8673d4e2f1d0.png-w331s)
大致思路有了，但上面提到过，GDI对象本身头部的handle如果验证错误，线程会被杀而导致利用失败。而我们对目标内存没有读能力（其实还有另一个系统调用NtGdiGetLinkedUFIs可以用来读内存，但测试时发现首先判断了另一个成员变量，有兴趣的读者可以深入看下这个成员），所以这里需要做一点小变动，在不改动Palette前四字节的要求下，改动Palette的大小。这里提一下，palette的大小字段位于对象的0x14处：
![
](https://images.seebug.org/content/images/2019/01/f3b9c2a5-779c-40a5-8c83-a117805bb843.png-w331s)
这里eca8cc1c处的0x28就是本Palette对象的元素个数（大小），而前面的0x501是它的版本号，这里是个固定值。所以我们只需要让目标BYTES区域对准eca8cc18即可，这样写内存更改掉eca88c1c处为0xffff即可（这也是一开始申请0xC10大小而不是0xc00的原因）！
那么利用过程就变成了这样：
![
](https://images.seebug.org/content/images/2019/01/55d97bd5-c871-4c3a-bba1-77b877d41827.jpg-w331s)
这样申请palette对象后，原来的BYTES区域其实指向的是某个Palette对象+0x10的地方，正好对准了对象大小的成员。另外这里说一点，在上图中，释放了0xC10后，由于本页面已经全部都释放状态，系统其实是会回收释放整个页面，整个页面变成了未分配状态。之后再次申请0xC00大小时，这个页面又被重新调拨分配了。而这里有个小坑就是由于目标页面被释放，同时又大量申请Palette对象，这很大几率造成本页面被分配用作二级句柄表了，避免这个意外的办法就是提前申请大量对象，让系统早分配句柄表，避免干扰我们的布局：
![
](https://images.seebug.org/content/images/2019/01/fed88cb7-b7b0-4561-84ed-670670e7b13d.png-w331s)
回到主题，按照思路，我们首先申请0x3f0大小的BYTES区域：
![
](https://images.seebug.org/content/images/2019/01/f60a2d46-3a91-496f-92bd-b5e9577f8158.png-w331s)
之后返回到内核态中，目标内存被释放：
![
](https://images.seebug.org/content/images/2019/01/7c0cec16-6e2b-47b1-a5e1-198991eb5ace.jpg-w331s)
可以看到原SBTrack内存区域被释放（Usst）后，被再次分配（Gadd），最后又被释放的过程（Free状态的Gadd）。之后，我们就再次申请0xC00并且继续申请要被越界的Palette：
![
](https://images.seebug.org/content/images/2019/01/8c4ff858-5dd4-4466-866f-87a685c8ba9a.png-w331s)
这里可以提一下，就是为什么不是理想中的C00大小而是0xB30，这里主要是考虑到，在申请越界Palette的过程中，系统其他进程也可能需要使用内存，如果正好碰到这种情形，那我们布局就会乱。所以这里预留下刚好不够一个Palette的空间，即使系统其他进程也同时申请了内存，也是会被放在前几个0xd0空隙中。最后布局如上图，这完全符合我们的需要，并且保证成功率（本人测试下，布局100%成功）！
之后调用NtGdiSetLinkedUFIs系统调用更改掉b4c21c00处Palette的大小：
![
](https://images.seebug.org/content/images/2019/01/e25ac6b9-5e6a-4a0a-a912-fa5c3608572c.png-w331s)
![
](https://images.seebug.org/content/images/2019/01/227f8961-0e43-4cf3-84e6-d28dd2b4f293.png-w331s)
![
](https://images.seebug.org/content/images/2019/01/15e13a13-08bf-4bf3-8482-328091495e13.png-w331s)
现在我们已经有了一个越界的Palette。但由于这个Palette内存地址是交叉的，所以我们还是尽量少用这个Palette，尽早切换到一个新的Palette。利用这个Palette更改下一个Palette作为Manager，再下一个作为Worker：
之后就是常规操作，获取SYSTEM进程EPROCESS->获取本进程EPROCESS->复制TOKEN-->创建新进程->恢复本进程TOKEN，不再赘述：
![
](https://images.seebug.org/content/images/2019/01/196d38d1-2bcc-4618-b8a1-eb594df4e395.png-w331s)
![
](https://images.seebug.org/content/images/2019/01/0264b8dd-47a7-4567-ae5e-778161ce6e02.png-w331s)
至此，我们已经有了一个SYSTEM权限的进程。但是系统中还存在一个有问题的HDC的句柄，这个DC对象的某个成员释放会造成BSOD。在逆向了这个对象的方法后，有两个思路：一是直接找到对象，把0xe0处直接改成0即可，但这个涉及的问题是如何通过句柄找到对象地址？二是在系统的句柄表里直接找到这一项，清零。但同样的问题，如何句柄表中找到这一项？网络翻找文章，也没找到WIN10下可用的具体方法。查看win32kfull.sys+win32kbase.sys发现，这个XDCOBJ对象从句柄得到对象地址会经过HmgLockEx函数（所有GDI对象都经过这个函数转换），而该函数又各种转换。没有心思深入，即使继续深入代码也难以实现查找。于是换了一个思路：在退出进程前，先释放掉交叉的Palette，这造成XDCOBJ+0xe0处成员指向了一个Free的内存。然后再次申请大量的AcceleratorTable，这就把一个查找GDI对象的问题换成了查找普通用户句柄的问题！然后释放掉DC句柄。此时，句柄表中有一个AcceleratorTable对象指向了Free的内存。那么这个AcceleratorTable句柄如何找到呢？
在NtUserDestroyAcceleratorTable中，主要通过HMValidateHandle来获取AcceleratorTable地址，它的主要转换过程如下：
![
](https://images.seebug.org/content/images/2019/01/994a805f-a48c-4000-a0dd-3d962f15016f.png-w331s)
其中gSharedInfo+8在win10上固定为0x10，则计算方法为：*gpKernelHandleTable + 8 * (handle &
0xffff)。那么只剩最后一个问题：gpKernelHandleTable的值如何得到？由于这是win32kbase.sys的全局变量，获取win32kbase.sys+偏移的方式？一是有通用性的问题，二是获取win32kbase.sys加载地址也麻烦，所以换一个方法。我们回到HMValidateHandle函数中，这个转换过程就直接有gpKernelHandleTable。所以我们采用搜索的方式，那么它的上层函数NtUserDestroyAcceleratorTable地址如何得到呢？
由于这是直接的系统调用，所以肯定在win32k!W32pServiceTable中，查找资料发现这个调用表可以在KeServiceDescriptorTableShadow+固定偏移中找到，而KeServiceDescriptorTableShadow虽然没有导出，但它固定在KeServiceDescriptorTable-0x40处。所以这就找到了一条可通行的路径：
![
](https://images.seebug.org/content/images/2019/01/ca38a411-d422-4e0f-814e-b28cd25936bb.jpg-w331s)
![
](https://images.seebug.org/content/images/2019/01/fec85708-ee70-4f76-9803-8cdf030dca6b.png-w331s)
所以直接找到这个句柄项，清零即可：
![
](https://images.seebug.org/content/images/2019/01/b00a7f98-819e-49e0-ac4c-30570cf0627d.png-w331s)
之后即完美退出EXP：
![
](https://images.seebug.org/content/images/2019/01/e91597df-d412-46fe-a708-b9e45e5f9a69.jpg-w331s)
本文EXP下载链接：
* * *