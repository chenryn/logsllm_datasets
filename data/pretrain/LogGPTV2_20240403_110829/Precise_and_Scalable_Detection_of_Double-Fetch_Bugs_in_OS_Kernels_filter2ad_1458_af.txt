[8] K. Lu, C. Song, T. Kim, and W. Lee, “UniSan: Proactive Kernel Memory
Initialization to Eliminate Data Leakages,” in Proceedings of the 23rd
ACM Conference on Computer and Communications Security (CCS),
Vienna, Austria, Oct. 2016.
[9] G. C. Mateusz Jurczyk, “Bochspwn: Identifying 0-days via System-wide
Memory Access Pattern Analysis,” in Black Hat USA Brieﬁngs (Black
Hat USA), Las Vegas, NV, Aug. 2013.
[10] P. Wang, J. Krinke, K. Lu, G. Li, and S. Dodier-Lazaro, “How Double-
Fetch Situations Turn into Double-Fetch Vulnerabilities: A Study of
Double Fetches in the Linux Kernel,” in Proceedings of the 26th USENIX
Security Symposium (Security), Vancouver, BC, Canada, Aug. 2017.
[11] M. Jurczyk and G. Coldwind, “Identifying and Exploiting Win-
dows Kernel Race Conditions via Memory Access Patterns,”
2013, https://static.googleusercontent.com/media/research.google.com/
en//pubs/archive/42189.pdf.
[12] I. Institute, “Exploiting Windows Drivers: Double-fetch Race Condi-
tion Vulnerability,” 2016, http://resources.infosecinstitute.com/exploiting-
windows-drivers-double-fetch-race-condition-vulnerability.
[13] C. Cadar, V. G. abd Peter M. Pawlowski, D. L. Dill, and D. R. Engler,
“EXE: Automatically Generating Inputs of Death,” in Proceedings of
the 13th ACM Conference on Computer and Communications Security
(CCS), Alexandria, VA, Oct.–Nov. 2006.
[14] C. Cadar, D. Dunbar, and D. Engler, “KLEE: Unassisted and Automatic
Generation of High-Coverage Tests for Complex Systems Programs,”
in Proceedings of the 8th USENIX Symposium on Operating Systems
Design and Implementation (OSDI), San Diego, CA, Dec. 2008.
[15] P. Godefroid, M. Y. Levin, and D. Molnar, “Automated Whitebox Fuzz
Testing,” in Proceedings of the 15th Annual Network and Distributed
System Security Symposium (NDSS), San Diego, CA, Feb. 2008.
[16] Y. Padioleau, J. L. Lawall, and G. Muller, “Understanding Collateral
Evolution in Linux Device Drivers,” in Proceedings of the 1st European
Conference on Computer Systems (EuroSys), Leuven, Belgium, Apr.
2006.
[17] D. A. Ramos and D. Engler, “Under-Constrained Symbolic Execution:
Correctness Checking for Real Code,” in Proceedings of the 24th USENIX
Security Symposium (Security), Washington, DC, Aug. 2015.
[18] B. Niu and G. Tan, “Modular Control-Flow Integrity,” in Proceedings of
the 2014 ACM SIGPLAN Conference on Programming Language Design
and Implementation (PLDI), Edinburgh, UK, Jun. 2014.
[19] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, ÃŽlfar Erlingsson,
L. Lozano, and G. Pike, “Enforcing Forward-Edge Control-Flow Integrity
in GCC & LLVM,” in Proceedings of the 23rd USENIX Security
Symposium (Security), San Diego, CA, Aug. 2014.
[20] J. McCarthy and J. Painter, “Correctness of a compiler for arithmetic
expressions,” Mathematical Aspects of Computer Science, vol. 1, 1967.
[21] L. de Moura and N. Bjorner, “Generalized, Efﬁcient Array Decision
Procedures,” Microsoft Research, Tech. Rep., Sep. 2009.
[22] L. De Moura and N. Bjørner, “Z3: An Efﬁcient SMT Solver,” in
Proceedings of the 14th International Conference on Tools and Algorithms
for the Construction and Analysis of Systems (TACAS’08), Berlin,
Heidelberg, Mar. 2008.
[23] M. Schwarz, D. Gruss, M. Lipp, C. Maurice, T. Schuster, A. Fogh, and
S. Mangard, “Automated Detection, Exploitation, and Elimination of
Double-Fetch Bugs using Modern CPU Features,” ArXiv e-prints, Nov.
2017.
[24] M. Musuvathi, S. Qadeer, T. Ball, G. Basler, P. A. Nainar, and I. Neamtiu,
“Finding and Reproducing Heisenbugs in Concurrent Programs,” in
Proceedings of the 8th USENIX Symposium on Operating Systems Design
and Implementation (OSDI), San Diego, CA, Dec. 2008.
[25] E. Yahav, “Verifying Safety Properties of Concurrent Java Programs
Using 3-valued Logic,” in Proceedings of the 28th ACM Symposium
on Principles of Programming Languages (POPL), London, United
Kingdom, Jan. 2001.
[26] M. Abadi, C. Flanagan, and S. N. Freund, “Types for Safe Locking: Static
Race Detection for Java,” ACM Trans. Program. Lang. Syst., vol. 28,
no. 2, pp. 207–255, Mar. 2006.
[27] D. Grossman, “Type-safe Multithreading in Cyclone,” in Proceedings of
the 2003 ACM SIGPLAN International Workshop on Types in Languages
Design and Implementation, ser. TLDI ’03, 2003.
[28] J. W. Voung, R. Jhala, and S. Lerner, “RELAY: Static Race Detection on
Millions of Lines of Code,” in Proceedings of the 15th European Software
Engineering Conference (ESEC) / 13th ACM SIGSOFT Symposium on
the Foundations of Software Engineering (FSE), Dubrovnik, Croatia, Sep.
2007.
[29] D. Engler and K. Ashcraft, “RacerX: Effective, Static Detection of Race
Conditions and Deadlocks,” in Proceedings of the 19th ACM Symposium
on Operating Systems Principles (SOSP), Bolton Landing, NY, Oct.
2003.
[30] C. Flanagan and S. N. Freund, “RedCard: Redundant Check Elimination
for Dynamic Race Detectors,” in Proceedings of the 27th European
Conference on Object-Oriented Programming, ser. ECOOP’13, 2013.
[31] M. D. Bond, M. Kulkarni, M. Cao, M. Zhang, M. Fathi Salmi, S. Biswas,
A. Sengupta, and J. Huang, “OCTET: Capturing and Controlling Cross-
thread Dependences Efﬁciently,” in Proceedings of the 24th Annual ACM
Conference on Object-Oriented Programming, Systems, Languages, and
Applications (OOPSLA), Indianapolis, IN, Oct. 2013.
[32] Y. Yu, T. Rodeheffer, and W. Chen, “RaceTrack: Efﬁcient Detection of
Data Race Conditions via Adaptive Tracking,” in Proceedings of the 20th
ACM Symposium on Operating Systems Principles (SOSP), Brighton,
UK, Oct. 2005.
[33] D. Rhodes, C. Flanagan, and S. N. Freund, “BigFoot: Static Check
Placement for Dynamic Race Detection,” in Proceedings of the 2017
ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI), Barcelona, Spain, Jun. 2017.
[34] L. De Moura and N. Bjørner, “Satisﬁability Modulo Theories: Introduc-
tion and Applications,” Communications of the ACM, vol. 54, no. 9, pp.
69–77, Sep. 2011.
[35] J. Burnim and K. Sen, “Heuristics for Scalable Dynamic Test Generation,”
University of California at Berkeley, Tech. Rep., Sep. 2008.
[36] E. Reisner, C. Song, K.-K. Ma, J. S. Foster, and A. Porter, “Using
Symbolic Evaluation to Understand Behavior in Conﬁgurable Software
Systems,” in Proceedings of the 32nd International Conference on
Software Engineering (ICSE), Cape Town, South Africa, May 2010.
[37] V. Chipounov, V. Kuznetsov, and G. Candea, “S2E: A Platform for
In-Vivo Multi-Path Analysis of Software Systems,” in Proceedings of
the 16th ACM International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS), Newport
Beach, CA, Mar. 2011.
[38] D. Babi´c, L. Martignoni, S. McCamant, and D. Song, “Statically-directed
dynamic automated test generation,” in Proceedings of the International
Symposium on Software Testing and Analysis (ISSTA), Toronto, Canada,
Jul. 2011.
[39] L. Martignoni, S. McCamant, P. Poosankam, D. Song, and P. Maniatis,
“Path-exploration lifting: Hi-ﬁ tests for lo-ﬁ emulators,” in Proceedings
of the 17th ACM International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS), London,
UK, Mar. 2012.
[40] M. J. Renzelmann, A. Kadav, and M. M. Swift, “SymDrive: Testing
Drivers Without Devices,” in Proceedings of the 10th USENIX Symposium
on Operating Systems Design and Implementation (OSDI), Hollywood,
CA, Oct. 2012.
[41] K. Lu, M.-T. Walter, D. Pfaff, S. NÃijrnberger, W. Lee, and M. Backes,
“Unleashing Use-Before-Initialization Vulnerabilities in the Linux Kernel
Using Targeted Stack Spraying,” in Proceedings of the 2017 Annual
Network and Distributed System Security Symposium (NDSS), San Diego,
CA, Feb.–Mar. 2017.
[42] S. Y. Kim, S. Lee, I. Yun, W. Xu, B. Lee, Y. Yun, and T. Kim, “CAB-Fuzz:
Practical Concolic Testing Techniques for COTS Operating Systems,” in
Proceedings of the 2017 USENIX Annual Technical Conference (ATC),
Santa Clara, CA, Jul. 2017.
674
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:58 UTC from IEEE Xplore.  Restrictions apply. 
A. A complicated symbolic checking example
APPENDIX
Figure 7 presents a much more complicated example to illustrate DEADLINE’s symbolic execution process. In particular, this examples shows two features
of DEADLINE:
• Loop unrolling: each of the two while loops are unrolled once which is further reﬂected in the symbolic execution trace: line 9-16, 22-35 (7c).
• Pointer resolving: in DEADLINE’s memory model, if DEADLINE can prove that two pointer values are the same, they should be pointing to the same
object, which is reﬂected in line 20 (7c).
This example also shows that although developers tend to exercise precaution to prevent double-fetch bugs, for example, by placing the sanity checks at line
36 (7a), such checks might not be sufﬁcient as shown in line 28 (7c).












// first batch of fetches
if (get_user(ucmlen, &ucmsg->cmsg_len))
tmp = ucmlen + sizeof(struct cmsghdr)
- sizeof(struct compat_cmsghdr);
}
return -EFAULT;
kcmlen += tmp;
ucmsg = (char *)ucmsg + ucmlen;
// 1st loop: calculate message length
kcmlen = 0;
ucmsg = kmsg->msg_control;
while (ucmsg != NULL) {
struct compat_cmsghdr __user *ucmsg;
compat_size_t ucmlen;
struct cmsghdr *kcmsg;
__kernel_size_t kcmlen, tmp;
// 2nd loop: copy the whole message
kcmsg = kbuf;
ucmsg = kmsg->msg_control;
while (ucmsg != NULL) {
1 int cmsghdr_from_user_compat_to_kern
(struct msghdr *kmsg, char *kbuf) {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53 }
(char *)kcmsg + sizeof(*kcmsg),
(char *)ucmsg + sizeof(*ucmsg),
(ucmlen - sizeof(*ucmsg))))
kcmsg = (char *)kcmsg + tmp;
ucmsg = (char *)ucmsg + ucmlen;
// irrelevant fetch
if (copy_from_user(
return -EINVAL;
return -EFAULT;
return -EFAULT;
}
tmp = ucmlen + sizeof(struct cmsghdr)
- sizeof(struct compat_cmsghdr);
// sanity check, but insufficient
if (kbuf + kcmlen - (char *)kcmsg msg_controllen = kcmlen;
return 0;
// secind batch of fetches
if (get_user(ucmlen, &ucmsg->cmsg_len))
@2
@3
@8
@9
@0
@1
@4
@5
@6
@7
= nil
= $UMEM(0)
= $KMEM(1)
= @3
= $KMEM(0)
= $KMEM(1)
= 0,
= @0(48, 55, K),
= nil
= nil
= nil
= $UMEM(1)
= $1
= @0(48, 55, K) == $3,
= @3(0, 3, U0),
= $4 - 12 + 16,
= $2 + $5,
= $3 + $4,
1 // init root SR
2 $0
= $PARM(0),
3 $1
= $PARM(1),
4 ---
5 // prepare for the 1st batch of fetches
6 $2
7 $3
8 ---
9 // unroll 1st loop
10 assert $2 != NULL
11 fetch(F1) is {A = $3 + 0, S = 4}
12 $4
13 $5
14 $6
15 $7
16 assert $7 == NULL (i.e., @7 = nil)
17 ---
18 // prepare for the 2nd batch of fetches
19 $8
20 $9
21 ---
22 // unroll 2nd loop
23 assert $9 != NULL
24 fetch(F2) is {A = $9 + 0, S = 4}
25 $10 = @3(0, 3, U1),
26 $11 = $10 - 12 + 16,
27
28 assert $1 + $6 - $8 >= $11
29
30 fetch(F3) is {A = $9 + 12, S = $10 - 12}
31 @8(12, $10 - 13, K) = @3(12, $10 - 13, U0)
32
33 $12 = $8 + $11,
34 $13 = $9 + $10,
35 assert $13 == NULL (i.e., @13 = nil)
36 ---
37
38 // check fetch overlap
39 assert F2.A  satisfiable with @3(0, 3, U)
42
43 assert F3.A  unsatisfiable
46
47 assert F3.A  unsatisfiable
50
51 // check double-fetch bug
52 prove @3(0, 3, U0) == @3(0, 3, U1)
53 // --> fail, as @3(0, 3, U0) >= @3(0, 3, U1)
@12 = $KMEM(2)
@13 = $UMEM(3)
@10 = nil
@11 = nil
// kmsg
// kbuf
// kcmlen_0
// ucmsg_0
// ucmlen_0
// tmp_0
// kcmlen_1
// ucmsg_1
// exit loop
// kcmsg_0
// ucmsg_2
// ucmlen_1
// tmp_1
// kcmsg_1
// ucmsg_3
// exit loop
--> @3(0, 3, U0) >= @3(0, 3, U1)
(a) C source code
(b) Memory access patterns
(c) Symbolic representation and checking
Fig. 7: A double-fetch bug in cmsghdr_from_user_compat_to_kern, with illustration on how it ﬁts the formal deﬁnition of double-fetch bugs
(7b) and DEADLINE’s symbolic engine can ﬁnd it (7c).
675
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:58 UTC from IEEE Xplore.  Restrictions apply. 
Loop unrolling. It is impossible to statically obtain all paths when a program
contains unbounded loops. Even for the loops with ﬁxed bounds, exploring all
paths is inefﬁcient. Therefore, we unroll each loop n times (n is conﬁgurable)
to cover as many runtime paths as possible. Algorithm 4 shows how we unroll
loops in a CFG. In procedure merge: for each loop in a CFG, if the loop
does not contain embedded loops, we merge all instructions inside the loop
as a single node, which simpliﬁes the CFG to a directed acyclic graph (DAG),
in which we can directly get all paths. Procedure unroll takes in a path from
the DAG, and recursively unroll the loop nodes for n times until there are
no loop nodes on the path. Although this unrolling algorithm is simple, it is
proved to be efﬁcient and effective.