程序第 4 行的 `block_given?` 方法被用来判断调用该方法时是否有块被传递给方法，如果有则返回 `true`，反之返回 `false`。如果方法没有块，则在程序第 7 行中直接把 `num` 相加。
在本例中，对 `yield` 传递 1 个参数，就有 1 个块变量接收。下面我们来看看对 `yield` 传递 0 个、1 个、3 个等多个参数时，对应的块变量是如何进行接收的。
```ruby
def block_args_test
  yield()             # 0 个块变量
  yield(1)            # 1 个块变量
  yield(1, 2, 3)      # 3 个块变量
end
puts "通过|a| 接收块变量"
block_args_test do |a|
  p [a]
end
puts
puts "通过|a, b, c| 接收块变量"
block_args_test do |a, b, c|
  p [a, b, c]
end
puts
puts "通过|*a| 接收块变量"
block_args_test do |*a|
  p [a]
end
puts
```
执行示例
```ruby
> ruby block_args_test.rb
通过|a| 接收块变量
[nil]
[1]
[1]
通过|a, b, c| 接收块变量
[nil, nil, nil]
[1, nil, nil]
[1, 2, 3]
通过|*a| 接收块变量
[[]]
[[1]]
[[1, 2, 3]]
```
首先我们注意到，`yield` 参数的个数与块变量的个数是不一样的。从 `|a|` 和 `|a, b, c|` 的例子中可以看出，块变量比较多时，多出来的块变量值为 `nil`，而块变量不足时，则不能接收参数值。
最后的通过 `|*a|` 接收的情况是将所有块变量整合为一个数组来接收。这与定义方法时接收可变参数的情况非常相似。
抽取嵌套数组的元素的规则，同样也适用于块变量。例如，`Hash.each_with_index` 方法的块变量有 2 个，并以 `yield([ 键 , 值 ], 索引 )` 的形式传递。在接收块变量后，我们就可以把 `[ 键 , 值 ]` 部分分别赋值给不同的变量。
```ruby
hash = {a: 100, b: 200, c: 300}
hash.each_with_index do |(key, value), index|
  p [key, value, index]
end
```
执行示例
```
> ruby param_grouping.rb
[:a, 100, 0]
[:b, 200, 1]
[:c, 300, 2]
```
**控制块的执行**
在调用代码清单 `total` 方法时，如果像下面那样在中途使用 `break`，`total` 方法的结果会变成什么样子呢？
```ruby
n = total(1, 10) do |num|
  if num == 5
    break
  end
  num
end
p n     #=> ??
```
答案是 `nil`。在块中使用 `break`，程序会马上返回到调用块的地方，因此 `total` 方法中返回计算结果的处理等都会被忽略掉。但作为方法的结果，当我们希望返回某个值的时候，就可以像 `break 0` 这样指定 `break` 方法的参数，这样该值就会成为方法的返回值。
此外，如果在块中使用 `next`，程序就会中断当前处理，并继续执行下面的处理。使用 `next` 后，执行块的 `yield` 会返回，如果 `next` 没有指定任何参数则返回 `nil`，而如果像 `next 0` 这样指定了参数，那么该参数值就是返回值。
```ruby
n = total(1, 10) do |num|
  if num % 2 != 0
    next 0
  end
  num
end
p n     #=> 30
```
最后，如果在块中使用 `redo`，程序就会返回到块的开头，并按照相同的块变量再次执行处理。这种情况下，块的处理结果不会返回给外部，因此需要十分小心 `redo` 的用法，注意不要使程序陷入死循环。
```ruby
n = total(1, 10) do |num|
  if num % 2 != 0
    next 0
  end
  num
end
p n     #=> 30
```
最后，如果在块中使用 `redo`，程序就会返回到块的开头，并按照相同的块变量再次执行处理。这种情况下，块的处理结果不会返回给外部，因此需要十分小心 `redo` 的用法，注意不要使程序陷入死循环。
**将块封装为对象**
如前所述，在接收块的方法中执行块时，可以使用 `yield` 关键字。
而 Ruby 还能把块当作对象处理。把块当作对象处理后，就可以在接收块的方法之外的其他地方执行块，或者把块交给其他方法执行。
这种情况下需要用到 `Proc` 对象。`Proc` 对象是能让块作为对象在程序中使用的类。定义 `Proc` 对象的典型的方法是，调用 `Proc.new` 方法这个带块的方法。在调用 `Proc` 对象的 `call` 方法之前，块中定义的程序不会被执行。
在下面的代码例子中，定义一个输出信息的 `Proc` 对象，并调用两次。这时，程序就会把 `call` 方法的参数作为块参数来执行块。
```ruby
hello = Proc.new do |name|
  puts "Hello, #{name}."
end
hello.call("World")
hello.call("Ruby")
```
执行示例
```
> ruby proc1.rb
Hello, World.
Hello, Ruby.
```
把块从一个方法传给另一个方法时，首先会通过变量将块作为 `Proc` 对象接收，然后再传给另一个方法。在方法定义时，如果末尾的参数使用“& 参数名”的形式，Ruby 就会自动把调用方法时传进来的块封装为 `Proc` 对象。
下面，我们将代码中块的接收方法加以改写，如下所示：
```ruby
def total2(from, to, &block)
  result = 0               # 合计值
  from.upto(to) do |num|   # 处理从from 到to 的值
    if block               #   如果有块的话
      result +=            #     累加经过块处理的值
           block.call(num)
    else                   #   如果没有块的话
      result += num        #     直接累加
    end
 end
 return result            # 返回方法的结果
end
p total2(1, 10)                   # 从1 到10 的和 => 55
p total2(1, 10){|num| num ** 2 }  # 从1 到10 的2 次幂的和 => 385
```
我们在首行的方法定义中定义了 `&block` 参数。像这样，在变量名前添加 `&` 的参数被称为 `Proc` 参数。如果在调用方法时没有传递块，`Proc` 参数的值就为 `nil`，因此通过这个值就可以判断出是否有块被传入方法中。另外，执行块的语句不是 `yield`，而是 `block.call(num)`，这一点与之前的例子也不一样。
方法可以有多个参数，而且定义参数的默认值等时都需要按照一定的顺序。而 `Proc` 参数则一定要在所有参数之后，也就是方法中最后一个参数。
将块封装为 `Proc` 对象后，我们就可以根据需要随时调用块。甚至还可以将其赋值给实例变量，让别的实例方法去任意调用。
此外，我们也能将 `Proc` 对象作为块传给其他方法处理。这时，只需在调用方法时，用“`&Proc` 对象”的形式定义参数就可以了。例如，向 `Array.each` 方法传递块时，可以像下面那样定义。
```ruby
def call_each(ary, &block)
  ary.each(&block)
end
call_each [1, 2, 3] do |item|
  p item
end
```
这样一来，我们就可以非常方便地把调用 `call_each` 方法时接收到的块，原封不动地传给 `ary.each` 方法。
执行示例
```
> ruby call_each.rb
1
2
3
```
# 局部变量与块变量
块内部的命名空间与块外部是共享的。在块外部定义的局部变量，在块中也可以继续使用。而被作为块变量使用的变量，即使与块外部的变量同名，Ruby 也会认为它们是两个不同的变量。
```ruby
x = 1            # 初始化x
y = 1            # 初始化y
ary = [1, 2, 3]
ary.each do |x|  # 将x 作为块变量使用
  y = x          # 将x 赋值给y
end
p [x, y]         # 确认x 与y 的值
```
执行示例
```
> ruby local_and_block.rb
[1, 3]
```
在 `ary.each` 方法的块中，`x` 的值被赋值给了局部变量 `y`。因此，`y` 保留了最后一次调用块时块变量 `x` 的值 3。而变量 x 的值在调用 `ary.each` 前后并没有发生改变。
相反，在块内部定义的变量不能被外部访问。在刚才的例子中，如果把第 2 行的代码删掉，程序就会出错。
```ruby
x = 1            # 初始化 x
#y = 1           # 初始化 y
ary = [1, 2, 3]
ary.each do |x|  # 将 x 作为块变量使用
  y = x          # 将 x 赋值给y
end
p [x, y]         # 引用 y 时会出错误（NameError）
```
块中变量的作用域之所以这么设计，是为了通过与块外部共享局部变量，从而扩展变量的有效范围。在块内部给局部变量赋值的时候，要时刻注意它与块外部的同名变量的关系。大家一定要小心 Ruby 中的这个小陷阱。
块变量是只能在块内部使用的变量（块局部变量），它不能覆盖外部的局部变量，但 Ruby 为我们提供了定义块变量以外的块局部变量的语法。使用在块变量后使用 `;` 加以区分的方式，来定义块局部变量。这里我们再稍微修改一下刚才的例子，如下所示。可以看出，块执行后 `x` 和 `y` 的值并没有变化。
```ruby
x = y = z = 0       # 初始化x、y、z
ary = [1, 2, 3]
ary.each do |x; y|  # 使用块变量x，块局部变量y
  y = x             # 代入块局部变量y
  z = x             # 代入不是块局部变量的变量z
  p [x, y, z]       # 确认块内的 x、y、z 的值
end
puts
p [x, y, z]         # 确认x、y、z 的值
```
执行示例
```
> ruby local_and_block2.rb
[1, 1, 1]
[2, 2, 2]
[3, 3, 3]
[0, 0, 3]
```