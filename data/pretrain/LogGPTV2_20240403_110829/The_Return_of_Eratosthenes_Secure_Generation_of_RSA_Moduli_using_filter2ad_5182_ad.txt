information about the underlying secret value.
To see the correctness of the protocol Î ConvInt observe the
following:
(1) For input values upper bounded by 2ğµ, the parties, invoking
the protocol Î Rand2k, sample shares of a random value
upper bounded by 2ğµ+ğœ. The additional ğœ bits of the random
value ensure that, upon additive masking, the randomness
statistically hides the input. The parties here receive two
types of additive shares of the same random value: one CRT
share, and the corresponding share over the integers.
(2) In Step 2, the parties additively mask their input share, using
the CRTshareoftherandomvalue,opentheresult,andlocally
perform the CRT reconstruction of the masked value ğ‘¡.
(3) In Step 3, the parties â€œunmask" their local value ğ‘¡, by
subtracting the integer share of the randomness they possess
from the local value ğ‘¡. Correctness follows because both the
Functionality FMPCâˆ’CRT
Let [ğ‘¥,â„“] denote the identifiers for the â„“ components of the CRT
representation a value ğ‘¥ stored in the functionality. Let ğ´ âŠ‚ {1, ...,ğ‘›}
denote the index set of the corrupted parties.
Init: Receive ğ‘1,...,ğ‘â„“ primes from all parties, store them and compute
ğ‘–=1ğ‘ğ‘–.
ğ‘€â„“ = Î â„“
Input: Receive a tuple (ğ‘¥,â„“â€²) âˆˆ Zğ‘€â„“â€² with â„“â€² â‰¤ â„“ from some party and
store ([ğ‘¥,â„“â€²]).
Add([ğ‘¥,â„“â€²],[ğ‘¦,â„“â€²]): Retrieve (ğ‘¥,â„“â€²) and (ğ‘¦,â„“â€²) from memory, compute
ğ‘§ =ğ‘¥+ğ‘¦ mod ğ‘€â„“â€², and store ([ğ‘§,â„“â€²]).
Mult([ğ‘¥,â„“â€²],[ğ‘¦,â„“â€²]): Retrieve (ğ‘¥,â„“â€²) and (ğ‘¦,â„“â€²) from memory, compute
ğ‘§ =ğ‘¥ Â·ğ‘¦ mod ğ‘€â„“â€², and store ([ğ‘§,â„“â€²]).
Open([ğ‘¥,â„“â€²]): Retrieve (ğ‘¥,â„“â€²) from memory and send the value ğ‘¥ to all
parties.
OpenTo([ğ‘¥,â„“â€²], ğ‘—): Retrieve (ğ‘¥, â„“â€²) from memory and send the CRT
represented values (ğ‘¥,â„“â€²) to party ğ‘ƒ ğ‘— .
Figure 4: MPC over CRT Functionality.
CRT sharing of the randomness, and the integer sharing
thereof reconstruct to the same value, and no wrap around
can happen, due to the bound on the product of the CRT
components, which is sufficiently large to accommodate the
bounded input, the statistical security parameter, and the
addition that is necessary to perform the masking.
The execution of the protocol Î ConvInt does not leak any informa-
tion about the secret. Indeed, the only opened value in the protocol
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea600Î MPCâˆ’CRT
...
Init(â„“): To initialize â„“ MPC engines, parties call FMPC.Init(Fğ‘šğ‘–) âˆ€ â„“
primes [ğ‘š1,ğ‘š2,...,ğ‘šâ„“ ].
Input(ğ‘¥, â„“â€²): To provide an input ğ‘¥ âˆˆ Zğ‘€â„“â€² (where â„“â€² â‰¤ â„“) any party
calls FMPC.Input(ğ‘¥ mod ğ‘šğ‘–) for ğ‘– âˆˆ [1, â„“â€²] to get (cid:74)ğ‘¥ mod ğ‘šğ‘–,ğ‘–(cid:75) as
((ğ‘¥ mod ğ‘šğ‘–) (1) ,
, (ğ‘¥ mod ğ‘šğ‘–) (ğ‘›)), where each (ğ‘¥ mod ğ‘šğ‘–) ( ğ‘—)
(cid:74)ğ‘¥,â„“â€²(cid:75)= ((cid:74)ğ‘¥ mod ğ‘š1,1(cid:75),...,(cid:74)ğ‘¥ mod ğ‘šâ„“â€²,â„“â€²(cid:75)).
represents the ğ‘–â€™th CRT share that each player ğ‘— obtains. The output is
Add((cid:74)ğ‘§,â„“â€²(cid:75),(cid:74)ğ‘¥,â„“â€²(cid:75),(cid:74)ğ‘¦,â„“â€²(cid:75)): To add two shared values (cid:74)ğ‘¥,â„“â€²(cid:75),(cid:74)ğ‘¦,â„“â€²(cid:75)
parties call FMPC.Add((cid:74)ğ‘§ mod ğ‘šğ‘–,ğ‘–(cid:75),(cid:74)ğ‘¥ mod ğ‘šğ‘–,ğ‘–(cid:75),(cid:74)ğ‘¦ mod ğ‘šğ‘–,ğ‘–(cid:75)) for
all ğ‘– âˆˆ [1,â„“â€²] engines and set(cid:74)ğ‘§,â„“â€²(cid:75)â† ((cid:74)ğ‘§ mod ğ‘š1,1(cid:75),...,(cid:74)ğ‘§ mod ğ‘šâ„“â€²,â„“â€²(cid:75)).
Mult((cid:74)ğ‘§,â„“â€²(cid:75),(cid:74)ğ‘¥,â„“â€²(cid:75),(cid:74)ğ‘¦,â„“â€²(cid:75)): To multiply two shared values(cid:74)ğ‘¥,â„“â€²(cid:75),(cid:74)ğ‘¦,â„“â€²(cid:75)
parties call FMPC.Mult((cid:74)ğ‘§ mod ğ‘šğ‘–,ğ‘–(cid:75),(cid:74)ğ‘¥ mod ğ‘šğ‘–,ğ‘–(cid:75),(cid:74)ğ‘¦ mod ğ‘šğ‘–,ğ‘–(cid:75)) for
ğ‘– âˆˆ [1,â„“â€²] and set(cid:74)ğ‘§,â„“â€²(cid:75)â† ((cid:74)ğ‘§ mod ğ‘š1,1(cid:75),...,(cid:74)ğ‘§ mod ğ‘šâ„“â€²,â„“â€²(cid:75).
Open((cid:74)ğ‘¥,â„“â€²(cid:75)): To open a shared value (cid:74)ğ‘¥,â„“â€²(cid:75) all parties call
FMPC.Open((cid:74)ğ‘¥ mod ğ‘šğ‘–,ğ‘–(cid:75)) and receive (ğ‘¥ mod ğ‘šğ‘–, ğ‘–) for ğ‘– âˆˆ [1, â„“â€²].
OpenTo((cid:74)ğ‘¥,â„“â€²(cid:75), ğ‘—): To open a shared value (cid:74)ğ‘¥,â„“â€²(cid:75) party ğ‘ƒ ğ‘— calls
FMPC.OpenTo((cid:74)ğ‘¥ mod ğ‘šğ‘–,ğ‘–(cid:75),ğ‘—) and receives (ğ‘¥ mod ğ‘šğ‘–,ğ‘–) for ğ‘– âˆˆ [1,â„“â€²].
They set (ğ‘¥,â„“â€²) â† (ğ‘¥ mod ğ‘š1,...,ğ‘¥ mod ğ‘šâ„“â€²).
Party ğ‘— sets (ğ‘¥,â„“â€²) â† (ğ‘¥ mod ğ‘š1,...,ğ‘¥ mod ğ‘šâ„“â€²).
Figure 5: Protocol for arithmetic MPC over CRT moduli.
Functionality FAdvMPCâˆ’CRT
$â† Z2ğ‘˜ and store ([ğ‘Ÿ,â„“â€²]), for â„“â€² â‰¤ â„“.
This functionality reproduces all the commands of FMPCâˆ’CRT and extends
it with:
Rand2k(â„“â€²,ğ‘˜): Sample ğ‘Ÿ
ConvInt([ğ‘¥,â„“â€²]): Retrieve (ğ‘¥,â„“â€²) from memory, sample random shares
ğ‘¥ (ğ‘–)
Int = ğ‘¥, and send them to the
corresponding parties. (Note: the sum is taken in Z).
LevelUp([ğ‘,â„“],â„“â€²): Receive ğ‘â„“+1,...,ğ‘â„“â€² from all parties, store them and
Int âˆˆ Z for each party ğ‘ƒğ‘– s.t.ğ‘›
compute ğ‘€â„“â€² =â„“â€²
ğ‘–=1ğ‘ğ‘–. Store ([ğ‘,â„“â€²]).
ğ‘–=1 ğ‘¥ (ğ‘–)
Figure 6: Advanced MPC over CRT Functionality.
Functionality FmaBits
(1) For ğ‘– =1,...,ğ‘š the functionality calls FMPC.GenBit() so as to store
(2) The bits ğ‘ğ‘– are retrieved from FMPC and are enterred into the
(3) The functionality samples a sharing of ğ‘ğ‘– in Zğ‘ and send its share
a bit ğ‘ğ‘–.
FMPC-CRT functionality.
ğ‘( ğ‘—)
ğ‘–
to every party ğ‘ƒ ğ‘— .
It also publicly outputs ğ‘˜ğ‘– = âŒŠğ‘( ğ‘—)
âŒ‹.
ğ‘–
ğ‘
(4) The functionality waits for a message Abort or Ok from the
adversary. If the message is Ok then it continues.
Figure 7: Random Bits Generation Functionality.
is(cid:74)ğ‘¥,â„“Jac(cid:75)+(cid:74)ğ‘Ÿ,â„“Jac(cid:75) with ğ‘Ÿ
$â† [2ğµ+ğœ] and ğ‘¥  ğ‘€â„“ for these two values. In our Î RSAGen
protocol, we use LevelUp command whenever a new operation on ğ‘
and ğ‘ could overflow the current CRT modulus. This happens twice:
first during the consistency check, and then in the GCD test. We note
that we execute this command only on [ğ‘,â„“] and [ğ‘,â„“], which we
know to be bounded by 2ğœ†+ğœ. We use this property in the Î LevelUp
The protocol ensures that the new(cid:74)ğ‘,â„“â€²(cid:75) is a sharing of the same
protocol (Fig. 10), which implements the LevelUp command.
value as(cid:74)ğ‘,â„“(cid:75). Indeed, by sampling small enough values ğ‘Ÿ and ğ‘  at ran-
dom, we can use ğ‘Ÿ as a MAC key and ğ‘  as a mask while avoiding any
overflow. As in all MAC checks, a cheating adversary would have to
guess ğ‘Ÿ to successfully cheat. In addition, we make sure to only open
ğ‘Â·ğ‘Ÿ +ğ‘  which is statistically close to uniform randomness because
ğ‘  is chosen uniformly random in [0,2ğœ†+3Â·ğœ] whereas ğ‘Â·ğ‘Ÿ  â„“, and ğ‘ 2ğœ†+ğœ .
In addition, let â„“c be the number of primes, the product of which (ğ‘€â„“c
)
serves as the space over which we compute without overflow the product
sample the candidate primes ğ‘ and ğ‘, such thatâ„“1
of the candidate primes ğ‘ and ğ‘, such thatâ„“c
>22Â·(ğœ†+ğœ) .
ğ‘–=1ğ‘šğ‘– =ğ‘€â„“c
(1) On receiving Sample from all parties, First query S for the
values ğ‘šğ‘ = ğ‘ mod ğ‘€sample and ğ‘šğ‘ = ğ‘ mod ğ‘€sample together
with the shares ğ‘( ğ‘—) , ğ‘( ğ‘—) of corrupt parties ğ‘ƒ ğ‘— âˆˆ C. Then,
uniformly sample ğ‘( ğ‘—) , ğ‘( ğ‘—) and send them to honest parties
ğ‘ƒ ğ‘— âˆˆ H with the condition thatğ‘— ğ‘( ğ‘—) mod ğ‘€sample = ğ‘šğ‘ and
ğ‘—ğ‘( ğ‘—) mod ğ‘€sample =ğ‘šğ‘.
(3) On receiving Jacobi(ğ›¾)
(2) On receiving Combine from all parties, send ğ‘ğ‘– = (ğ‘ Â·ğ‘) mod ğ‘šğ‘–
for all ğ‘– âˆˆ [â„“c] to all parties. If gcd(ğ‘ ,ğ‘€sample) â‰ 1 send AbortGCD
to all parties; if ğ‘ âˆ‰ [22ğœ†,22Â·(ğœ†+ğœ) ] send AbortOutOfRange to all
parties.