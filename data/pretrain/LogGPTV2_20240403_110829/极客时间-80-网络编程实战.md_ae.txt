### socket 的发展历史通过上面的讲解和这个打电话的类比，你现在清楚 socket 到底是什么了吧？那socket最开始是怎么被提出来的呢？接下来就很有必要一起来简单追溯一下它的历史了。socket 是加州大学伯克利分校的研究人员在 20 世纪 80年代早期提出的，所以也被叫做伯克利套接字。伯克利的研究者们设想用 socket的概念，屏蔽掉底层协议栈的差别。第一版实现 socket 的就是 TCP/IP协议，最早是在 BSD 4.2 Unix 内核上实现了socket。很快大家就发现这么一个概念带来了网络编程的便利，于是有更多人也接触到了socket 的概念。Linux 作为 Unix 系统的一个开源实现，很早就从头开发实现了TCP/IP 协议，伴随着 socket 的成功，Windows 也引入了 socket的概念。于是在今天的世界里，socket 成为网络互联互通的标准。
## 套接字地址格式在使用套接字时，首先要解决通信双方寻址的问题。我们需要套接字的地址建立连接，就像打电话时首先需要查找电话簿，找到你想要联系的那个人，你才可以建立连接，开始交流。接下来，我们重点讨论套接字的地址格式。
### 通用套接字地址格式下面先看一下套接字的**通用**地址结构：    /* POSIX.1g 规范规定了地址族为 2 字节的值.  */typedef unsigned short int sa_family_t;/* 描述通用套接字地址  */struct sockaddr{    sa_family_t sa_family;  /* 地址族.  16-bit*/    char sa_data[14];   /* 具体的地址值 112-bit */  }; 在这个结构体里，第一个字段是地址族，它表示使用什么样的方式对地址进行解释和保存，好比电话簿里的手机格式，或者是固话格式，这两种格式的长度和含义都是不同的。地址族在glibc 里的定义非常多，常用的有以下几种：-   AF_LOCAL：表示的是本地地址，对应的是 Unix    套接字，这种情况一般用于本地 socket 通信，很多情况下也可以写成    AF_UNIX、AF_FILE；-   AF_INET：因特网使用的 IPv4 地址；-   AF_INET6：因特网使用的 IPv6 地址。这里的 AF\_ 表示的含义是 Address Family，但是很多情况下，我们也会看到以PF\_ 表示的宏，比如 PF_INET、PF_INET6 等，实际上 PF\_ 的意思是 ProtocolFamily，也就是协议族的意思。我们用 AF_xxx 这样的值来初始化 socket地址，用 PF_xxx 这样的值来初始化 socket。我们在 \头文件中可以清晰地看到，这两个值本身就是一一对应的。    /* 各种地址族的宏定义  */#define AF_UNSPEC PF_UNSPEC#define AF_LOCAL  PF_LOCAL#define AF_UNIX   PF_UNIX#define AF_FILE   PF_FILE#define AF_INET   PF_INET#define AF_AX25   PF_AX25#define AF_IPX    PF_IPX#define AF_APPLETALK  PF_APPLETALK#define AF_NETROM PF_NETROM#define AF_BRIDGE PF_BRIDGE#define AF_ATMPVC PF_ATMPVC#define AF_X25    PF_X25#define AF_INET6  PF_INET6sockaddr是一个通用的地址结构，通用的意思是适用于多种地址族。为什么定义这么一个通用地址结构呢，这个放在后面讲。
### IPv4 套接字格式地址接下来，看一下常用的 IPv4 地址族的结构：    /* IPV4 套接字地址，32bit 值.  */typedef uint32_t in_addr_t;struct in_addr  {    in_addr_t s_addr;  };  /* 描述 IPV4 的套接字地址格式  */struct sockaddr_in  {    sa_family_t sin_family; /* 16-bit */    in_port_t sin_port;     /* 端口口  16-bit*/    struct in_addr sin_addr;    /* Internet address. 32-bit */      /* 这里仅仅用作占位符，不做实际用处  */    unsigned char sin_zero[8];  };我们对这个结构体稍作解读，首先可以发现和 sockaddr 一样，都有一个 16-bit的 sin_family 字段，对于 IPv4 来说这个值就是 AF_INET。接下来是端口号，我们可以看到端口号最多是 16-bit，也就是说最大支持 2 的16 次方，这个数字是 65536，所以我们应该知道支持寻址的端口号最多就是65535。关于端口，我在前面的章节也提到过，这里重点阐述一下保留端口。所谓保留端口就是大家约定俗成的，已经被对应服务广为使用的端口，比如ftp 的 21 端口，ssh 的 22 端口，http 的 80 端口等。一般而言，大于 5000的端口可以作为我们自己应用程序的端口使用。下面是 glibc 定义的保留端口。    /* Standard well-known ports.  */enum  {    IPPORT_ECHO = 7,    /* Echo service.  */    IPPORT_DISCARD = 9,   /* Discard transmissions service.  */    IPPORT_SYSTAT = 11,   /* System status service.  */    IPPORT_DAYTIME = 13,  /* Time of day service.  */    IPPORT_NETSTAT = 15,  /* Network status service.  */    IPPORT_FTP = 21,    /* File Transfer Protocol.  */    IPPORT_TELNET = 23,   /* Telnet protocol.  */    IPPORT_SMTP = 25,   /* Simple Mail Transfer Protocol.  */    IPPORT_TIMESERVER = 37, /* Timeserver service.  */    IPPORT_NAMESERVER = 42, /* Domain Name Service.  */    IPPORT_WHOIS = 43,    /* Internet Whois service.  */    IPPORT_MTP = 57,        IPPORT_TFTP = 69,   /* Trivial File Transfer Protocol.  */    IPPORT_RJE = 77,    IPPORT_FINGER = 79,   /* Finger service.  */    IPPORT_TTYLINK = 87,    IPPORT_SUPDUP = 95,   /* SUPDUP protocol.  */      IPPORT_EXECSERVER = 512,  /* execd service.  */    IPPORT_LOGINSERVER = 513, /* rlogind service.  */    IPPORT_CMDSERVER = 514,    IPPORT_EFSSERVER = 520,      /* UDP ports.  */    IPPORT_BIFFUDP = 512,    IPPORT_WHOSERVER = 513,    IPPORT_ROUTESERVER = 520,      /* Ports less than this value are reserved for privileged processes.  */    IPPORT_RESERVED = 1024,      /* Ports greater this value are reserved for (non-privileged) servers.  */    IPPORT_USERRESERVED = 5000实际的 IPv4 地址是一个 32-bit 的字段，可以想象最多支持的地址数就是 2 的32 次方，大约是 42亿，应该说这个数字在设计之初还是非常巨大的，无奈互联网蓬勃发展，全球接入的设备越来越多，这个数字渐渐显得不太够用了，于是大家所熟知的IPv6 就隆重登场了。
### IPv6 套接字地址格式我们再看看 IPv6 的地址结构：    struct sockaddr_in6  {    sa_family_t sin6_family; /* 16-bit */    in_port_t sin6_port;  /* 传输端口号 
# 16-bit */    uint32_t sin6_flowinfo; /* IPv6 流控信息 32-bit*/    struct in6_addr sin6_addr;  /* IPv6 地址 128-bit */    uint32_t sin6_scope_id; /* IPv6 域 ID 32-bit */  };整个结构体长度是 28 个字节，其中流控信息和域 IP先不用管，这两个字段，一个在 glibc的官网上根本没出现，另一个是当前未使用的字段。这里的地址族显然应该是AF_INET6，端口同 IPv4 地址一样，关键的地址从 32 位升级到 128位，这个数字就大到恐怖了，完全解决了寻址数字不够的问题。请注意，以上无论 IPv4 还是 IPv6的地址格式都是因特网套接字的格式，还有一种本地套接字格式，用来做为本地进程间的通信，也就是前面提到的 AF_LOCAL。    struct sockaddr_un {    unsigned short sun_family; /* 固定为 AF_LOCAL */    char sun_path[108];   /* 路径名 */};
### 几种套接字地址格式比较这几种地址的比较见下图，IPv4 和 IPv6套接字地址结构的长度是固定的，而本地地址结构的长度是可变的。![](Images/ff91d129b4dfb418a981d12f2aa39aca.png){savepage-src="https://static001.geekbang.org/resource/image/ed/58/ed49b0f1b658e82cb07a6e1e81f36b58.png"}
## 总结这一讲我们重点讲述了什么是套接字，以及对应的套接字地址格式。套接字作为网络编程的基础，概念异常重要。套接字的设计为我们打开了网络编程的大门，实际上，正是因为BSD 套接字如此成功，各大 Unix 厂商（包括开源的 Linux）以及 Windows平台才会很快照搬了过来。在下一讲中，我们将开始创建并使用套接字，建立连接，进一步开始我们的网络编程之旅。
## 思考题最后给你留两道思考题吧，你可以想一想IPv4、IPv6、本地套接字格式以及通用地址套接字，它们有什么共性呢？如果你是BSD 套接字的设计者，你为什么要这样设计呢？第二道题是，为什么本地套接字格式不需要端口号，而 IPv4 和 IPv6套接字格式却需要端口号呢？我在评论区期待你的思考与见解，如果你觉得这篇文章对你有所帮助，欢迎点击"请朋友读"，把这篇文章分享给你朋友或同事。![](Images/5a282807b2a1ff091b7f803e8cef3429.png){savepage-src="https://static001.geekbang.org/resource/image/bf/25/bfc96ae0d8f839919b9d9866cfb8b025.jpg"}