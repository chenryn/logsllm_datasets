semantics. These components help users understand the action,
or consequences respectively, of deleting the account.
Fig. 4: String-screen Mapping Graph for Line App.
top-level layout is used by a fragment (Frag). Finally, the
fragment is used by an activity (Act). Hence we successfully
mapped the AD string “If you delete your LINE account...” to
Android activity SettingsBaseFragmentActivity.
4.3. Finding Account Deletion Listeners
We reconstruct the link from AD code to AD GUI elements
via def-use-chain analysis: speciﬁcally, we connect AD strings
shown on a screen with GUI actions the user can perform on
that screen. Def-use-chain analysis has so far been applied to
program code, to connect variable deﬁnitions with variable
uses. In Android apps, however, many deﬁnitions are in
conﬁguration ﬁles, e.g., strings, or GUI element IDs, which
are outside the purview of traditional def-use-chain analysis.
We now discuss our approach for performing this analysis
across program code and conﬁguration ﬁles.
Fig. 5: An Example for Determining ADF.
Figure 5 shows an example of an account-deletion top-
layout from the EyeEm app. In the ﬁgure, fragment
level
frag settings delete account.xml is represented as a hierarchy,
with a [LinearLayout] root node, ID 0x7f0c0076. There are
three descendant [TextView] nodes; the interesting one is ID
0x7f11037f, showing the text ‘Delete Account’. This satisﬁes
condition (2). Also, in the ﬁgure, ID 0x7f090322 is mapped to
node [Button] with text ‘Delete’. We showed that this Button
has a listener from Section 4.3, which satisﬁes condition (1).
Hence the layout is an ADF layout.
5. Retention Period Analyzer
Some apps have a well-deﬁned retention policy: account
information will be retained on the server for a speciﬁed period
of time (e.g., 30 days) after users request account deletion.
We constructed an analyzer that checks for, and extracts, this
retention period. In our evaluation (Section 9.1), to conﬁrm
whether the account information was indeed removed after the
retention period had passed, we waited for the end of retention
period, then checked for LAI.
To automatically extract the retention period, RetentionPe-
riodAnalyzer ﬁnds text that meets two conditions. First, the
In Android, GUI actions such as button clicks are passed
to app code via listeners, e.g., onClickListener(). To associate
a button with the action, the app needs to bind the listener
with the button when the activity is created. This is done
by calling set*Listener-style functions, e.g., setOnClickListener,
setOnKeyListener, setOnTouchListener. If the action listener can be
traced, via def-use-chain analysis, to one of the AD component
id numbers, we conclude that Account Deletion Functionality
(ADF) has been found. The following code snippet is from
EyeEm, a popular photo app.
1
2
const v1, 0x7f090322
invoke−static {p2, v1, v0}, Lbutterknife / internal / Utils ;→
move−result−object v0
...
invoke−virtual {v0, v1}, Landroid/view/View;→
ﬁndRequiredView(Landroid/view/View;ILjava/lang/String;)
3
4
5
setOnClickListener(Landroid/view/View$OnClickListener;)
On line 5, setOnClickListener
is invoked on v0. We use
def-use chains to walk backwards to its deﬁnition: v0 is
deﬁned on line 3, and assigned the value returned by
ﬁndRequiredView. We continue to use def-use chains to ﬁnd
the deﬁnition of ﬁndRequiredView’s second parameter,
i.e.,
0x7f090322. The parameter value is deﬁned as the id of
settings delete account conﬁrm in the layout (public .xml).
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 13:00:26 UTC from IEEE Xplore.  Restrictions apply. 
62150
Adstr::Are	you	sure	you	want	to	delete	your	LINE	account	?Act::SettingsBaseFragmentActivity.smaliAdstr::If	you	delete	your	LINE	account,	your	purchase	history,	coins,	points	and	purchased	items	will	all	be	permanently	deleted.	Frag::AccountDeleteFragment.smaliNattr::settings_del_accountNattr::settings_del_account_youritems_descNattr::settings_del_account_confirmLay::settings_account_delete_fragment.xmlToplay::settings_account_delete_fragment.xmlLay::settings_account_delete_paid_item_row.xmlAdstr::Delete	accountXMLImageBytecode   TABLE 4: Retention Period String Examples.
Package Name
Phrases
com.snapchat.android After 30 days, your account will be deleted
com.opera.browser
com.azure.authentic. This account becomes unrecoverable 60 days
Your account will be deleted in 7 days
after you close the account
com.intsig.camscan. The account will be deleted in 14 days after
com.ebay.mobile
we receive your email
We have started the process to close your
account. The process may take up to 30 days
net.wargaming.wot.b. 45 days after creating a request, your account
will be deleted forever
text must contains strings with Account Deletion or Account
Restoring semantics (similar to AD semantics in Section 4).
Second, the text must contains a time period string, consisting
of a number and a time unit; for example, “1 month”, “3 days”,
or “30 minutes”. This time period is the retention period. The
grammar is deﬁned as follows:
RetentionP eriodString
In
N ounphrase
Cd
N ns
T o
Jj
::= In N ounphrase |
N ounphrase In |
T o N ounP hrase
::= “af ter” | “in” | “within”
::= Cd N ns | Cd Jj N ns
::= Integer
::= “minutes” | “hours” | “days”
| “weeks” | “months”
::= “to”
::= Adjective
Table 4 shows six examples of retention period strings
identiﬁed by the grammar, which illustrates that our grammar
is effective for recognizing retention periods.
6. Leftover Account Analyzer
To ﬁnd whether an app leaves leftover account data we
use an automated approach enabled by Appium. For LAI
after account deletion, LeftoverAccountAnalyzer performs several
steps, as described shortly: sign-up (account creation), account
deletion (where offered), sign-up/create account again with
the same credentials, and LAI veriﬁcation. LAI after app
uninstallation follows the same steps, except
the account
deletion step is replaced with app uninstall and app reinstall.
We now describe each step.
Initial sign-up. LeftoverAccountAnalyzer automatically installs
the app, ﬁnds the ‘Sign-up’ screen, creates a new account by
supplying the required user information, potentially navigating
through multiple screens via ‘Next’ or similar, until successful
sign-up is conﬁrmed. In the process, LeftoverAccountAnalyzer
logs the {GUI element→text input} mappings, which are key
to LAI detection.
Note that automating this process was far from trivial, due to
the aforementioned issues (text embedded in images, sign-ups
over multiple pages) and additional technical challenges, as
described next. To ensure correct processing, we used a hybrid
process (automated, but with human oversight), as follows.
We manually collected the word sets used in the 135-app pi-
lot study to mark Sign-up → N ext → [Done | Error] stage
transitions. Then, we used those sets to seed the automated
approach and monitored LeftoverAccountAnalyzer’s workﬂow on
each app. Apps that deviated from the expected workﬂow (e.g.,
used anti-automation techniques, as explained shortly) were
routed for manual analysis; there were 39 such apps.
Speciﬁcally, we use three word sets as “anchors”: sign-
up, next, and done. The sign-up word set contains keywords
such that users can click on their respective widgets to
start the account sign-up (e.g., “sign up”, “register”, “create
account”, “get started”, “join”, “continue with email”, “register
with email”, “log in”, “register”, etc.). The next word set
contains keywords that help identify next-screen or next-page
transitions; users can click on the associated widgets to move
to the next screen (e.g., “next”, “ok”, “continue”, “advance”,
“move forward”, “click”, “skip”, etc.). Finally, the done word
set is associated with widgets used to ﬁnish the account sign-
up (e.g., “ﬁnish”, “done”, “complete”, “create account”, “set
up”, “verify phone number”, “verify email address”, “sign up”,
“sign in”, “log in”, etc.).
Manual intervention was needed in three scenarios: when
apps used CAPTCHAs; to verify the phone number or email
address; and for conﬁrmation prompts ( privacy policy, up-
grading membership, enabling location, etc).
Automated account deletion. LeftoverAccountAnalyzer
in-
vokes AccountDeletionAnalyzer
to determine whether an app
has an AD button; if so, LeftoverAccountAnalyzer will note the
name of the corresponding screen and perform the follow-
ing workﬂow to automatically delete the leftover accounts,
created by the app. The workﬂow consists of three stages,
Login → Finding ADF → Deleting the Account, which are
navigated and exercised automatically.
Login. The log-in screens are anchored by word sets shown
on clickable widgets such as “log in”, “signin”, “log in with
email”, “sign in via email”, “login or register”, “existing
user”, “I already have an account”, “get started”, etc. The
LeftoverAccountAnalyzer ﬁlls in the login information using the
sign-up information retained from Step 1.
Finding ADF. The analyzer navigates to the screen contain-
ing ADF widgets (e.g., Delete Account buttons) by using a
word set which includes “more options”, “proﬁle”, “account
settings”, “edit proﬁle”, “my account”, etc. If the current
screen matches the screen name found by the AccountDeletion-
Analyzer, it moves to the next stage.
Deleting the Account. The analyzer completes the deletion
process by ﬁnding and clicking the deletion widget (“delete
account”, “close my account”, etc.).
Repeating the sign-up. LeftoverAccountAnalyzer attempts to
repeat the sign-up: installs the app, extracts the GUI layout,
and injects the same, Step 1, input values into the GUI. Apps
are categorized into apps that allow a second sign-up, and apps
that display error messages, e.g., “account cannot be created
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 13:00:26 UTC from IEEE Xplore.  Restrictions apply. 
72151
Fig. 6: Message sequence chart for No LAI (left) vs. LAI-all ﬁelds (center) vs. LAI-some ﬁelds (right).
because it already exists in the system.” We can thus check
whether the account is retained on the server, automatically
and at scale. Next, we show how we identify the precise
extent, i.e., ﬁelds, left on the server.
Verifying LAI. All ﬁelds entered when signing-up are
potentially retained on the server (hence constitute LAI).
Conﬁrming this retention by examining sever-side information
is infeasible, as we do not have access to apps’ (backend)
servers. Hence we developed an approach to infer retained
ﬁelds, as explained next.
At high level, our approach detects the three scenarios
shown in Figure 6. In each scenario, we show the interaction
between user, app/website, and backend, for account creation,
account update, and account deletion. The actual deletion
happens in the communication between the app/website and
the backend. On the left, we have the message sequence that
ensures account deletion: a request to delete the account is
reﬂected in a deleteUser() being sent to the backend. In the
middle, there is no such API call, hence all ﬁelds are LAI. On
the right, we have an API call to delete the user’s age, i.e.,
deleteUserAge() but no API call to deleteUserLocation(), meaning
the user’s location will be left on the server. Next, we show
our approach for inferring such LAI.
6.1. Reverse Engineering-based LAI Inference
We reverse-engineer the app–backend server communica-
tion to infer LAI by tracing and analyzing the AM (Account
Manipulation) operations; these operations are initiated in the
app but ultimately create, delete, or change user accounts in
the backend database.
There are four types of AM operations (two coarse-grained
and two ﬁne-grained): account creation and deletion that
manipulate the whole account, as well as ﬁeld creation and
deletion that manipulate a speciﬁc ﬁeld of an account. These
AM operations are implemented via API functions provided
by backend software development kits (SDK) or via requests
to a database.
To trace AM operations, we decompile apps’ APK ﬁles into
Smali code; identify account creation/deletion/manipulation
methods; extract AM API calls in these methods and their
call graphs’ transitive closure; and intercept AM calls to log
their in/out parameters at runtime. An alternative approach
to reverse-engineering AM calls would be to intercept trafﬁc,
e.g., via mitmproxy [16]; however, messages would still ulti-
mately be “put on the wire” via the AM API calls, hence
our approach (AM API call interception) would reveal those
messages.
Table 5 lists the AM API functions we logged and the
corresponding AM operations. To comprehensively cover AM
operations, we analyze both remote and local AM operations.
We focused on the Firebase (including CloudFirestore and
FirebaseDatabase) and Parse backends due to their popu-
larity, e.g., 99% of apps that employ backend SDKs use
Firebase [14].
Local operations involve an additional step: rather than com-
municating with Firebase/Parse directly, local AM operations
write into Android’s SharedPreferences or Bundle; data is sent
from local stores to the backend when necessary. Table 5 omits
these operations for brevity.
User account data can be stored into two separate locations
on the backend server. The primary location is controlled
by (hardcoded into) the backend SDK, but it only supports
ﬁve ﬁelds per account, which makes it unsuitable for most
applications. A custom location stores extra information of
an account at a location not controlled by the backend SDK.
For example, a custom location can be a separate node under
/users, inside the server database itself.
We run the app (with AM calls intercepted) to create and
delete an account. From AM logs we determine the ﬁelds
retained on the backend servers as follows:
Fr = (Fap + Fac) − (Fdp + Fdc)
where Fr, Fap, Fac, Fdp and Fdc represent ﬁelds retained,
added in the primary location, added in the custom location,
deleted in the primary location and deleted in the custom
location, respectively.
As a ﬁrst example, the app Rent-A-Car stores the user’s ﬁrst
name, last name, email, password and phone number in its
primary location; and street address in its custom location.
Therefore Fap = {ﬁrst name, last name, email, password,
phone number}, Fac = {street address}. The app does not
delete any ﬁelds when deleting an account, hence Fdp =
Fdc = ∅ and Fr = {ﬁrst name, last name, email, password,
phone number, street address}.
As a second example, consider the PiniOn app (which
helps brands and businesses understand their market and
consumers). The app’s code for creating a new user account
is shown in the following code snippet; hence Fap = {name,
email, password}.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 13:00:26 UTC from IEEE Xplore.  Restrictions apply. 
82152
UserCreate	User	AccountApp/Website	BackendcreateUser()Get/Update	User	AccountgetUser()/updateUser()Delete	User	AccountdeleteUser()(a)	No	LAI(b)	LAI,	allfieldsdeleteUser()UserCreate	User	AccountApp/Website	BackendcreateUser()Get/Update	User	AccountgetUser()/updateUser()Delete	User	Account(c)	LAI,	somefieldsdeleteUserLocation()UserCreate	User	AccountApp/Website	BackendcreateUser()Get/Update	User	AccountgetUser()/updateUser()Delete	User	AccountdeleteUserAge()TABLE 5: APIs for AM Operations.
AM Operations
Firebase
CloudFirestore
FirebaseDatabase
Parse
Account Creation
createUser, createUserAsync, cre-
ateUserWithEmailAndPassword
add
setValue
signUp, signUpInBackground
Account Deletion
delete, deleteUser
delete
removeValue
delete,
deleteInBack-
ground, deleteEventually
updateEmail,
Field Creation/Deletion
updateUser,
updatePass-
word, updatePhoneNumber, updateProﬁle
set, update, delete
updateChildren, setValue
setUsername, setEmail, setPassword, put
1
2
3
4
5
6
# Ljava/lang/String;
.param p1, ”name” # Ljava/lang/String;
.param p2, ”email”
# Ljava/lang/String;
.param p3, ”password”
.param p4, ”handler” # LFirebase$ResultHandler;
......
invoke−virtual {v0, p1, p2, p3, p4}, Lcom/ﬁrebase/client /
authentication/AuthenticationManager;→ createUser(
Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;
Lcom/ﬁrebase/client/Firebase$ResultHandler;)V
The app adds two extra ﬁelds in the following two code
snippets. Therefore, Fac = {birthday, gender}.
1
2