of two to three months before Google publishes these
CVEs on its security bulletin. Since most OEM vendors
follow Google’s monthly schedule to update security
patch level, OEM patches will be unnecessarily delayed.
4. OEM phones. To understand how patching is
performed on OEM kernels, we refer to the Pixel source
branches as well as an Oneplus repo that happened to
contain the complete commit history. We observe that
these kernels cherry-pick patches from Qualcomm
(either mainline or stable) and even Linux sometimes.
In addition, when OEM vendors decide to upgrade the
Android OS (e.g., Android Oreo to Android Pie), they
usually abandon the old branch and develop another
stable branch (forking from upstream) that corresponds
to the new Android OS (as the case study about
Samsung S8 showed). We can infer that other OEM
vendors follow the same strategy of (1) cherry-picking
instead of merging, and (2) forking when upgrading.
This is because (1) the ﬁrmware images often skip
upstream patches (so it
is unlikely performing git
merge), and (2) OS upgrades always happen together
with the kernel version updates, which is also the case
with Qualcomm stable branches — OS upgrades lead to
a new stable branch with an advanced kernel version. In
addition, we always observe a large number of kernel
patches applied when the ﬁrmware is upgraded to a new
Android OS.
Speciﬁcally, depending on the exact phone model,
30% to 75% of CVEs can be patched through forking a
new branch from upstream.
This is not a healthy
number because Android OS upgrades usually happen
on a yearly basis and not to mention that there are often
additional delays for these upgrades to reach user
devices (e.g., carrier delays). Clearly, more patches
should have been cherry-picked in between upgrades.
For the cherry-picked patches, we consider them
timely if they are applied within a reasonable amount of
time after Google or Qualcomm notify the OEMs,
which is typically expected to be a month or two.
Unfortunately, OEM vendors are often signiﬁcantly
behind the schedule. As Figure 19 shows, 80% of the
Qualcomm CVEs take OEMs 100 days or more to
deploy corresponding patches. This is likely because
OEM vendors ignore Qualcomm’s notiﬁcations and
prefer to follow the monthly updated security patch
level set by Google. We contacted Samsung and
conﬁrmed that OEMs are bound to follow Android’s
monthly bulletin while no such strict requirements exist
for Qualcomm. This is reﬂected in the ﬁgure where
more than 50% of the CVEs take OEMs less than a
month (sometimes even beforehand) to patch after the
Android security bulletin publication (which is within
the expectations [13]).
As we can see, Google’s
notiﬁcation plays a huge role in getting OEMs to patch.
We note that there is a small fraction of patches
(roughly 5%) delayed for 200 days or more after
Google’s security bulletin is published. This is not only
due to slow and infrequent security updates by some
devices but also occasionally skipped CVEs (out of the
ones published together in a month). For example, we
ﬁnd that Samsung S8 has
skipped nothing but
CVE-2018-13900 from Google’s Feb 2019’s security
bulletin, which interestingly got patched eventually in
2020. Finally, from Figure 19, we do not ﬁnd signiﬁcant
correlation between the severity of vulnerabilities and
timeliness of patches being cherry-picked by OEMs.
Note that the number of critical cherry-picked patches
by OEMs is very limited, especially for some new
phones, thus we combine high and critical ones into a
single line. In fact, CVE-2018-13900 is a high severity
USENIX Association
30th USENIX Security Symposium    3663
vulnerability yet skipped by Samsung S8.
To improve the situation, OEM vendors should
obviously react more timely to the earliest notiﬁcation,
e.g., Qualcomm.
Furthermore, similar to what we
suggest for Qualcomm, OEM vendors can consider
merging patches directly from upstream instead of
cherry-picking them. We also hope that high-end and
low-end phones can be treated equally, as we show
low-end phones tend to receive patches more slowly in
Figure 14. At the end of the day, we believe a better and
more automated patching/testing process will help.
Summary.
the analysis supports our
hypothesis and we propose three general areas that need
improvement.
Overall,
More efﬁcient triage systems. The triage process of
security vulnerabilities today is largely manual. This is
evident in the case study where the initial bug ﬁx made
in Linux mainline was never treated seriously enough
by the rest of the ecosystem (Linux LTS failed to
cherry-pick it also). Better automated reasoning tools
(e.g., [36]) can assist
the developers in identifying
security-critical bugs and take actions accordingly.
More efﬁcient knowledge propagation. Unfortunately,
even when the knowledge of an important security
vulnerability does become available in one party,
it
either does not have a good mechanism to propagate the
information (e.g., Linux), or propagate the information
in a delayed manner (e.g., notiﬁcation by Google and
Qualcomm).
In addition, sometimes it is beneﬁcial to
propagate the knowledge in the reverse direction (e.g.,
some patches shown to be applied in Google before
Linux LTS).
this process should be more
automated to reduce delay.
Ideally,
Cleanly separate the changes made in downstreams.
Current patching practices in downstreams largely rely
on cherry-picking, i.e., Linux LTS, Qualcomm stables,
and OEMs. If a downstream kernel can cleanly separate
its customization code from the upstream, or even
better, upstream its customization (as is the case with
Google[28]),
the responsibility of patching upstream
vulnerabilities can be completely automated with
merging,
i.e., Android common and Qualcomm
mainlines. A downstream kernel can simply merge
automatically and ﬁx security issues unknowingly.
7 Discussion
Unpatched kernels. By design, patch presence test is
unable to equate the absence of patches with the target
“being vulnerable”. Throughout our measurements, we
observe many cases where the downstream kernels
never apply patches from upstream. However, this could
simply mean that the downstream kernel is not affected
by the upstream vulnerability, e.g., due to customization
at
the
stops
of the vulnerable function. This is why we focus on the
patched cases only, because it implies the downstream
kernels are affected.
Further delays after the OEM patches. Our patch
propagation measurement
kernel
compilation (build) dates. However, in practice, there
are additional delays before the OEM updates can arrive
at a user device. They include carrier certiﬁcation delays
(for carrier-locked phones), and users intentionally
delaying the ﬁrmware update even if it
is already
available through OTA. Unfortunately, such delays are
hard to quantify and we consider them out of scope. To
get a basic sense of carrier certiﬁcation delays, we
manage to ﬁnd the LG V30/Samsung S7/Samsung S8
on T-Mobile websites and SamsungS7/SamsungS8 on
ATT websites that appear to publish the ﬁrmware
release date. The average delay between built and
release is about 20 days. To draw any meaningful
conclusions though, a large-scale analysis needs to be
done across more devices and carriers.
Chipset vendors other than Qualcomm. In addition to
Qualcomm,
include
MediaTek, Kirin, and Exynos. Unfortunately, none of
these vendors provides the complete git repositories for
their recent chipsets. In addition, the CVEs speciﬁc to
Kirin and Exynos chipsets are published only on
Huawei’s and Samsung’s ofﬁcial websites but no links
exist
they
represent a hurdle for any external party to track their
patches. We suspect
reverse engineering on the
ﬁrmware images will be the only way to analyze the
presence and absence of patches.
8 Related Work
Code similarity at the source and binary level. To
conduct our measurement we need the ability to
accurately test the patch presence at both source level
(e.g., the source code of the phone kernel is released)
and binary level (e.g., only ROMs are available for the
target phone). There exist a large body of work aiming
to compute the source/binary code similarity (e.g., to
ﬁnd similar functions as a given vulnerable one), using a
variety
level
features [14, 27, 26, 34, 41].
to the corresponding patches.
other major SoC vendors
Together,
source
binary
and
of
In theory, these work can be used to test the patch
presence by computing a target function’s similarity to
the patched/unpatched functions).
Unfortunately,
similarity-based approaches are fundamentally fuzzy
and not suitable to capture the essence of a security
patch which often makes only very small changes to
patched functions and can still
look similar to the
unpatched version of
Tuning the
similarity-based approach for patch presence test is an
interesting but orthogonal problem.
the function.
3664    30th USENIX Security Symposium
USENIX Association
FIBER [42]
Binary patch presence test.
is a
state-of-art open-source tool to test the patch presence in
binaries with the aid of the ﬁne-grained source level
patch information.
It generates binary signatures that
accurately capture the syntax and semantic information
of the patch change sites, and then matches them in the
target binary. It suits our needs perfectly and therefore
we leverage and build on top of FIBER to test the patch
presence for over 600 Android ROMs. To ensure that it
works well in our large-scale measurement, we enhance
the original FIBER to overcome several of its technical
weaknesses as detailed in §4.3.
Android security patch investigation.
Farhang et
al. [19] have recently conducted a measurement on
Android security patches, including both user and kernel
components, with some minor overlap with this paper.
In particular,
they also analyzed the delay from the
patch date (linked from the security bulletin which we
now know is often not the earliest date) to the release
date on the bulletin and observed a large delay.
However, this represents only a small part of the picture
of the end-to-end patch propagation in the ecosystem all
the way from the upstream Linux to the end Android
devices.
they do not attempt to locate
patches in the source or binary at all. Thus they cannot
ﬁnd the bottleneck of patch delay. On the other hand,
we not only showed where the bottleneck is but also
explained why they exist with actionable insights and
takeaways. More importantly, we also give suggestions
on how to improve the patch propagation in the
ecosystem.
Patch and vulnerability lifecycle analysis. There exist
a number of measurement studies focusing on various
aspects of patch propagation in open-source software.
Li et al. [31], Shahzad et al. [40] and Frei et al. [20]
performed large-scale measurements
regarding the
vulnerability lifecycle and the patching timeliness,
based on publicly available information collected from
data sources like CVE databases [4] and open-source
repositories.
them focus on speciﬁc
open-source projects, like Farhang et al. [19] focusing
on Android and Ozment et al. [32] targeting FreeBSD.
No analysis has been dedicated to the Android kernel
ecosystem which involves the analysis of multiple
parties in depth and the analysis of source and binary
kernels.
Speciﬁcally,
Some of
9 Conclusion
In this paper, we delved deep into the Android kernel
patch ecosystem,
revealing the relationship among
different parties as well as the bottleneck in patch
propagation.
to
measure such a huge, decentralized, fragmented, and yet
This represents a ﬁrst data point
collaborative project. We also analyze that the study is
worthwhile in identifying deﬁciencies and opportunities
to better manage such a project in the future.
References
[1] Android Security Bulletin.
https://source.
android.com/security/bulletin/.
[2] Android
Security
Bulletin—January
2020.
https://source.android.com/security/
bulletin/2020-01-01.
[3] Linux stable kernel patch rules.
https:
//www.kernel.org/doc/Documentation/
process/stable-kernel-rules.rst.
[4] National Vulnerability Database. https://nvd.
nist.gov/.
[5] Pixel Update Bulletins.
https://source.
android.com/security/bulletin/pixel.
[6] What to do about CVE numbers. https://lwn.
net/Articles/801157/.
[7] Huawei-ﬁrmware. http://huawei-firmware.
com/phone-list/, 2019.
[8] Latest Ofﬁcial Android ROMs. https://www.
cnroms.com/, 2019.
[9] MIUI Global ROM.
http://c.mi.com/oc/
miuidownload/index, 2019.
[10] Oppo Software Updates.
https://oppo.
custhelp.com/app/soft_update, 2019.
[11] Sammobile. www.sammobile.com, 2019.
[12] Stock ROM ﬁles.
com/, 2019.
https://stockromfiles.
[13] Adam Conway. How Monthly Android Security
https://www.xda-
Patch Updates Work.
developers.com/how-android-security-
patch-updates-work/.
[14] B. S. Baker. Parameterized duplication in strings:
Algorithms and an application to software main-
tenance.
SIAM J. Comput., 26(5):1343–1362,
October 1997.
[15] I. D. Baxter, A. Yahin, L. Moura, M. Sant’Anna,
and L. Bier. Clone detection using abstract syntax
trees. ICSM’98.
[16] Code Aurora. Android for MSM Project. https:
//wiki.codeaurora.org/xwiki/bin/QAEP/.
USENIX Association
30th USENIX Security Symposium    3665
[17] Code Aurora. Android releases. https://wiki.
codeaurora.org/xwiki/bin/QAEP/release.
[31] F. Li and V. Paxson. A large-scale empirical study
of security patches. CCS’17.
[18] Code Aurora.
Security Bulletin.
https://
www.codeaurora.org/category/security-
bulletin/page/3.
[32] A. Ozment and S. E. Schechter. Milk or wine: does
In USENIX
software security improve with age?
Security Symposium, pages 93–104, 2006.
[19] S. Farhang, M. B. Kirdan, A. Laszka, and
J. Grossklags. Hey google, what exactly do your
security patches tell us?
a large-scale empirical
study on android patched vulnerabilities. 2019.
[33] I. Patel. Xiaomi Still Hasn’t Released Kernel
https://www.xda-
Sources for the Mi A1.
developers.com/xiaomi-not-released-
kernel-sources-mi-a1/, 2018.
[20] S. Frei, M. May, U. Fiedler, and B. Plattner. Large-
scale vulnerability analysis. In Proceedings of the
2006 SIGCOMM workshop on Large-scale attack
defense, pages 131–138. ACM, 2006.
[21] Google.
https://
developer.android.com/about/dashboards.
Distribution dashboard.
[22] Google.
Learn when you’ll get Android
updates on Pixel phones
Nexus devices.
https://support.google.com/pixelphone/
answer/4457705?hl=en.
[23] Google. Stable Kernel Releases Updates - Secu-
rity. https://source.android.com/devices/
architecture/kernel/releases#security.
[24] Google Project Zero. Bad Binder: Android In-The-
https://googleprojectzero.
Wild Exploit.
blogspot.com/2019/11/bad-binder-
android-in-wild-exploit.html.
[25] Google
Project
Zero.
Use-After-Free
Android:
https://bugs.chromium.org/p/project-
zero/issues/detail?id=1942.
Issue
1942:
in Binder driver.
[26] J. Jang, A. Agrawal, and D. Brumley. Redebug:
ﬁnding unpatched code clones in entire os distribu-
tions. Oakland’12.
[27] L. Jiang, G. Misherghi, Z. Su, and S. Glondu.
Deckard: Scalable and accurate tree-based detec-
tion of code clones. ICSE’07.
[28] Jonathan Corbet. Bringing the Android kernel back
to the mainline. https://lwn.net/Articles/
771974/.
[29] A. Kernel.
developed.
devices/architecture/kernel/android-
common, 2019.
How Android common kernels
https://source.android.com/
[30] L. Kernel.
How the development process
works. https://www.kernel.org/doc/html/
latest/process/2.Process.html, 2019.
[34] J. Pewny, B. Garmany, R. Gawlik, C. Rossow, and
T. Holz. Cross-architecture bug search in binary
executables. Oakland’15.
[35] piunikaweb. Asus releases botched up kernel
sources for Zenfone Max M2 family on launch
day.
https://piunikaweb.com/2018/12/
12/asus-releases-botched-up-kernel-
sources-for-zenfone-max-m2-family-on-
launch-day/, 2018.
[36] S. M. Qiushi Wu, Yang He and K. Lu. Precisely
characterizing security impact in a ﬂood of patches
via symbolic rule comparison. NDSS, 2020.
[37] Qualcomm.
Security Bulletin.
https:
//www.qualcomm.com/company/product-
security/bulletins.
Samsung issues
[38] reddit.
source.
Android/comments/94ol07/samsung_
issues_related_to_kernel_source/, 2018.
related to kernel
https://www.reddit.com/r/
[39] Samsung. Knox Deep Dive: Real-time Kernel
Protection (RKP). https://www.samsungknox.
com/en/blog/knox-deep-dive-real-time-
kernel-protection-rkp, 2019.
[40] M. Shahzad, M. Z. Shaﬁq, and A. X. Liu. A large
scale exploratory analysis of software vulnerability
life cycles. In 2012 34th International Conference
on Software Engineering (ICSE), pages 771–781.
IEEE, 2012.
[41] X. Xu, C. Liu, Q. Feng, H. Yin, L. Song, and
D. Song. Neural network-based graph embedding
for cross-platform binary code similarity detection.
CCS ’17.
[42] H. Zhang and Z. Qian. Precise and accurate patch
presence test for binaries. USENIX Security, 2018.
3666    30th USENIX Security Symposium
USENIX Association