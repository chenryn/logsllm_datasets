你是否注意到了“0x40000-0x20-sc.length”？
因为js中字符串对象不是简单的Unicode。它是一种复合的字符串结构，称为BSTR，这一数据类型包含有数据长度域、数据域和一个终止符。
4个字节的size域描述字符串的字节数，但是不包含结束符
n个字节的string主体（Unicode格式）
2个字节的x00x00结束符
值得注意的是BSTR并不是javascript定义的，恰恰相反BSTR是微软官方定义的，可以直接在MSDN中查到（https://msdn.microsoft.com/en-us/library/windows/desktop/ms221069(v=vs.85).aspx）
并且可能是通过oleaut32.dll进行分配的
（ ）
参加MSDN的示例：
    BSTR MyBstr = SysAllocString(L"I am a happy BSTR");
我们试图把内存喷射到0x0C0C0C0C，经过简单的计算可知0x0C0C0C0C约为202116108个字节。
500*0x80000约为262144000个字节，262144000大于202116108个字节，因此我们的喷射一定可以到达0x0C0C0C0C。
根据这种算法我们可以得出
    0x0A0A0A0A（160M） 0x0C0C0C0C（192M） 0x0D0D0D0D（208M）
任务管理器中内存曲线突出的部分就是堆喷导致的
**  
**
**6.Win7+IE8环境下的堆喷射**
IE8相比IE6来说并没有在堆喷射方面做任何的限制，因此我们可以同样通过Javascript String对象进行喷射。
但是在代码执行的角度来看，IE8浏览器支持了ASLR和DEP这两个重要的漏洞环境措施，因此我们堆喷射策略也要进行调整。这一时期的堆喷射关键字是精准，要求能够准确预测到喷射的位置，甚至一个字节都不可以差。至于必须这样的原因，我会在利用部分讲，这里只需要知道此时要求精准喷射。
此外还有一点是IE8下需要把以前的连接语句换成substring()才能实现内存分配，这个没什么好说的。
    var sc = unescape("%ucccc%ucccc"); 
    var nop = unescape("%u0c0c%u0c0c");
    while (nop.length 
这一种技术很有可能是Pwn2Own 2010的获胜者Peter Vreugdenhil发明的
(参见
)
Peter
Vreugdenhil发现当堆块进行大量分配的时候，地址分配的熵处于高位并且是对齐的。就是说堆地址的低位不会发生变化，仅有几个高字节是改变的，为此Peter
Vreugdenhil给出了一个例子
    Heap alloc size(0x7ffc0) allocated at 063d0020
    Heap alloc size(0x7ffc0) allocated at 06450020
    Heap alloc size(0x7ffc0) allocated at 064d0020
    Heap alloc size(0x7ffc0) allocated at 06550020
    Heap alloc size(0x7ffc0) allocated at 065d0020
    Heap alloc size(0x7ffc0) allocated at 06650020
    Heap alloc size(0x7ffc0) allocated at 066d0020
利用这一点，如果我控制我分配的堆块大小为0x10000。因为低位不变，那么无论如何我们都可以成功的指向我们想要的地址。举个例子，假如我们在第一次运行中，0x0c0c0c0c属于开始地址在0x0c0c0018的堆块、第二次，0x0c0c0c属于开始地址在0x0c080018的块、第三次处于0x0c030018。因为块是对齐的，只要块的大小可以控制为0x10000的基数就可以，比如0×1000、比如0x5000、比如0x10000。这样一来，我们就可以控制0x0c0c0c0c处的内容始终指向rop链第一条语句了。
我在这里使用后面提到的shellcode.substring(0, (0x80000-6)/2);进行分配，分配结果如下图
接下来我们只需要计算目的地址与rop首语句之间的差值即可把eip准确的指向rop链了。
**  
**
**7.IE9环境下的堆喷射**
历史的轮盘转到了IE9的时代，微软为了阻止攻击者进行堆喷射在IE9中增加了Nozzle缓解机制，Nozzle缓解机制会检测到堆喷中分配的相同占位块从而导致堆喷失败。但是由于Nozzle的判断机制非常简单，因此只要堆喷的每个堆块有略微的不同比如加入随机数，甚至只需要改变一个字节就可以绕过Nozzle缓解机制的检测，成功实现堆喷。
其实，这里还有一个隐含的意思不知道你有没有意识到，那就是对于具有DEP环境下的堆喷射来说，除了我们布置的payload本身之外其它的部分已经没有什么意义了。我们既不需要它们作为跳板，也不指望它们可以实现什么，因为这部分的内容完全就是随意的，我们可以生成一些随机数或其它的随机内容填充这一部分来使得每个块内容都不同。如果你没能理解这句话意思，那么没关系我们会在后面利用部分详述。
这里展示了如何把IE8下的堆喷代码修改成IE9适用的以绕过Nozzle。
    var sc = unescape("%ucccc%ucccc"); 
    var nop = unescape("%u0c0c%u0c0c");
    while (nop.length 
我们这里演示了堆喷射的结果，如下图
**  
**
**8.IE10环境下的堆喷射**
到了IE10这里，情况就有一些不一样了。IE10浏览器中禁止了喷射BSTR（javascript
string）的操作，这意味着自IE6发展而来的堆喷射方法已经不再奏效了，我们以前的那些方法都不能在IE10浏览器下成功进行喷射。在这种情况下，一种被称为DOM
Element Property Spray（简称DEPS）的技术由Corelan
Team提了出来（https://www.corelan.be/index.php/2013/02/19/deps-precise-heap-spray-on-firefox-and-ie10/）