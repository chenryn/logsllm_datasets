verify all users have seen the same conversation. The details of the consistency check are not addressed in the
paper. GOTR only works in the synchronous model as all users must be online to execute the GKA and consistency
checks, making it not suitable for mobile communication.
SYM-GOTR [20] is a recent proposal for synchronous end-to-end secure group conversations with the same
properties as our work. SYM-GOTR works with existing XMPP servers and a client plugin. Similar to GOTR,
participants ﬁrst setup pairwise secure channels between all participants. Then the participants share symmetric key
inputs and veriﬁcation keys. When Alice sends a message she ﬁrst computes a symmetric encryption key by hashing
all of the symmetric key input material from all the other participants and encrypts the message. She broadcast the
ciphertext to all participants. After receiving a ciphertext all participants perform a two phase consistency check
of the ciphertext over the pairwise secure channels. The ﬁrst phase veriﬁes all users have received the ciphertext
and the second phase identiﬁes any users who have misbehaved in the ﬁrst phase. Modifying the participants of
the conversation is as simple as distributing new symmetric key inputs and veriﬁcation keys. The main limitations
of SYM-GOTR is that it requires all participants to be online at the same time and the two phase interactive
consistency check causes additional delay in message processing.
Signal [21] (formerly TextSecure) is the most widely deployed protocol for secure mobile messaging. However
it has only recently received formal analysis of its security properties [7], [4], [9]. With [19], [18] identifying
multiple participant consistency and conversation integrity vulnerabilities in two-party and group conversations. We
now quickly describe the group conversation protocol of Signal. When Alice registers with the Signal server she
uploads pre-keys allowing other users (Bob) to execute an X3DH [16] two-party key agreement with her while she
is ofﬂine. When Bob wants to start a conversation with Alice and Charlie he fetches a pre-key for each of them,
then executes the X3DH key agreement and sends each a secure “Group Setup” message. Conversation messages
are sent in the same fashion, setting up or ratcheting forward a two-party symmetric key with every pair of users,
then sending an encryption of the conversation message to each user individually. When Alice receives a group
message from Bob she sends a receipt of the message back to Bob. When Bob’s phone receives the ﬁrst receipt of
a messages it indicates to Bob the message was delivered. Signal lacks conversation consistency of messages and
receipts, Charlie can not verify if Alice has received Bob’s message and no order of messages is enforced.
Asynchronous Ratcheting Trees (ART) [5] describes a group key agreement protocol with forward and backward—
Post Compromise—secrecy. The protocol is asynchronous in that it allows a single user to set up the group key
while the other users are ofﬂine. ART is only a group key agreement and not a full messaging protocol like Mobile
CoWPI. It does not provide authentication of the author of a message, support for dynamic groups, or conversation
integrity. ART works by bootstrapping on secure two-party channels similar to our NAXOS two-party channels.
When setting up a group all participants are added one at a time. The group key agreement forms a DH tree where
the root node is the group key. Setting up a group with ART is O(n) but performing a single user key ratchet is
O(log(n)) where n is the number of users in the group.
VIII. CONCLUSION
In this work we addressed the problem of practical end-to-end secure mobile messaging with support for group
conversations. We identiﬁed a mobile messaging model and showed that (1) multiple servers must be used to provide
strong conversation integrity and (2) to provide message unlinkability, messages must be O(n) in size and must
provide pairwise unlinkability. We then showed that given an any-trust multiple-server model, a relatively simple
protocol, Mobile CoWPI, can achieve these strong security properties while being practically efﬁciency. We provide
proofs of the security of Mobile CoWPI, and analyze the performance of a Java implementation with groups of
varying size to show the protocol performs well with realistic internet latencies.
REFERENCES
[1] C. Alexander and I. Goldberg, “Improved user authentication in off-the-record messaging,” in Proceedings of the 2007 ACM workshop
on Privacy in electronic society. ACM, 2007, pp. 41–47.
[2] M. Bellare and C. Namprempre, “Authenticated encryption: Relations among notions and analysis of the generic composition paradigm,”
J. Cryptol., vol. 21, no. 4, pp. 469–491, Sep. 2008. [Online]. Available: http://dx.doi.org/10.1007/s00145-008-9026-x
[3] N. Borisov, I. Goldberg, and E. Brewer, “Off-the-record communication, or, why not to use pgp,” in Proceedings of the 2004 ACM
workshop on Privacy in the electronic society. ACM, 2004, pp. 77–84.
[4] K. Cohn-Gordon, C. Cremers, B. Dowling, L. Garratt, and D. Stebila, “A formal security analysis of the signal messaging protocol,” in
Security and Privacy (EuroS&P), 2017 IEEE European Symposium on.
IEEE, 2017, pp. 451–466.
18
[5] K. Cohn-Gordon, C. Cremers, L. Garratt, J. Millican, and K. Milner, “On ends-to-ends encryption: Asynchronous group messaging with
strong security guarantees,” in Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security. ACM,
2018, pp. 1802–1819.
[6] M. Di Raimondo, R. Gennaro, and H. Krawczyk, “Deniable authentication and key exchange,” in Proceedings of the 13th ACM conference
on Computer and communications security. ACM, 2006, pp. 400–409.
[7] T. Frosch, C. Mainka, C. Bader, F. Bergsma, J. Schwenk, and T. Holz, “How secure is textsecure?” in Security and Privacy (EuroS&P),
2016 IEEE European Symposium on.
I. Goldberg, B. Ustao˘glu, M. D. Van Gundy, and H. Chen, “Multi-party off-the-record messaging,” in Proceedings of the 16th ACM
conference on Computer and communications security. ACM, 2009, pp. 358–368.
IEEE, 2016, pp. 457–472.
[8]
[9] N. Kobeissi, K. Bhargavan, and B. Blanchet, “Automated veriﬁcation for secure messaging protocols and their implementations: A
symbolic and computational approach,” in IEEE European Symposium on Security and Privacy (EuroS&P), 2017.
[10] F. Laguillaumie and D. Vergnaud, “Multi-designated veriﬁers signatures,” in International Conference on Information and Communications
Security. Springer, 2004, pp. 495–507.
[11] B. LaMacchia, K. Lauter, and A. Mityagin, “Stronger security of authenticated key exchange,” in Provable Security.
Springer, 2007,
pp. 1–16.
linode, linode, https://linode.com/.
[12]
[13] H. Liu, E. Y. Vasserman, and N. Hopper, “Improved group off-the-record messaging,” in Proceedings of the 12th ACM workshop on
[14] M. Marlinspike,
Workshop on privacy in the electronic society. ACM, 2013, pp. 249–254.
for
“Facebook messenger deploys
https://whispersystems.org/blog/facebook-messenger/
signal protocol
end to end encryption,” 2016.
[Online]. Available:
[15] ——, “Open whisper
systems partners with google on end-to-end encryption for allo,” 2016.
[Online]. Available: https:
//whispersystems.org/blog/allo/
[16] M. Marlinspike and T. Perrin, “The x3dh key agreement protocol,” 2016. [Online]. Available: https://whispersystems.org/docs/
speciﬁcations/x3dh/
[17] P. Rogaway, “Nonce-based symmetric encryption,” in International Workshop on Fast Software Encryption. Springer, 2004, pp. 348–358.
[18] P. R¨osler, C. Mainka, and J. Schwenk, “More is less: On the end-to-end security of group chats in signal, whatsapp, and threema,” 2018.
[19] M. Schliep, I. Kariniemi, and N. Hopper, “Is bob sending mixed signals?” in Proceedings of the 2017 on Workshop on Privacy in the
Electronic Society. ACM, 2017, pp. 31–40.
[20] M. Schliep, E. Vasserman, and N. Hopper, “Consistent synchronous group off-the-record messaging with sym-gotr,” Proceedings on
Privacy Enhancing Technologies, vol. 2018, no. 3, pp. 181–202, 2018.
[21] O. W. Systems, Open Whisper Systems, https://whispersystems.org/.
[22] P. Syverson, R. Dingledine, and N. Mathewson, “Tor: The secondgeneration onion router,” in Usenix Security, 2004.
[23] N. Unger, S. Dechand, J. Bonneau, S. Fahl, H. Perl, I. Goldberg, and M. Smith, “Sok: Secure messaging,” in Security and Privacy (SP),
2015 IEEE Symposium on.
IEEE, 2015, pp. 232–249.
[24] WhatsApp, 2017. [Online]. Available: https://www.whatsapp.com/security
19
Fig. 3: IND$-CPA Game
Fig. 4: INT-CTXT Game
function INITIALIZE(l)
k ←R {0, 1}l
b ←R {0, 1}
function TEST(m, data)
c0 ← Enck(m, data)
c1 ←R {0, 1}|c0|
return cb
function FINALIZE(d)
return (d = b)
function INITIALIZE(l)
k ←R {0, 1}l
S ← {}
function VF(c)
function ENC(m, d)
c ← Enck(m, d)
S ← S ∪ {c}
return c
m ← Deck(c, d)
if m (cid:54)= ⊥ and c /∈ S then
win ← true
return (m (cid:54)= ⊥)
function FINALIZE(d)
return win
A. Security Assumptions
APPENDIX
We assume our symmetric AEAD scheme ciphertext are indistinguishable from random bit strings (IND$-CPA)
detailed in Figure 3 and provides integrity of ciphertext detailed in Figure 4. The advantage of an adversary M
winning each of the games is deﬁned as AdvIN D−CP A(M ) = P r[M wins]− 1
2, AdvIN T−CT XT (M ) = P r[Mwins]
respectively.
We assume the NAXOS protocol is a secure authenticated key agreement. Figure 5 describes the game used
by the original authors modiﬁed to include an addition bit string ({0, 1}l) into the EPHEMERAL KEY REVEAL and
TEST queries that is included in the input of KDF2 of NAXOS. This modiﬁcation is to allow the Mobile CoWPI
session id Sid to be incorporated into the KDF and does not affect the security of NAXOS. The NAXOS session
id is
sid = (role, ID, ID∗, comm1, . . . , commn)
where ID is the identify of the executing party and ID∗ is the identities of the other party, role ∈ {I, R} is the
role of initiator or responder, and commi is the ith communication sent by the parities. This preservers the session
matching of NAXOS.
An adversary wins if if it issues TEST on a clean session and guess the correctly in FINALIZE. Let sid be the
NAXOS session between parties A and B. Let sid∗ be the matching session of sid executed by B, sid∗ may not
exist. A session is not clean if any of the following hold:
• A or B is an adversary-controlled party
•
•
REVEAL is queried on sid or sid∗
sid∗ exists and both the long-term and ephemeral key of A or B are revealed
20
Fig. 5: NAXOS Game
function INITIALIZE(U)
Initialize PKI for all users in U.
function SEND(A, B, comm)
Send comm to A on behalf of B
This query allows A to start a NAXOS AKE with B.
return A’s communication to B
function LONG-TERM KEY REVEAL(A)
return Long-term private key of A
function EPHEMERAL KEY REVEAL(sid)
return Returns the ephemeral private key of a possibly incomplete session sid.
function REVEAL(sid, Sid)
function TEST(sid, Sid)
return Session key of completed NAXOS session sid with Mobile CoWPI session id Sid
b ←R {0, 1}
if b = 0 then
else
C ←REVEAL(sid, Sid)
C ←R {0, 1}l
return C
function FINALIZE(d)
return (d = b)
•
sid∗ does not exist and the long-term key of B was reveled or both the long-term and ephemeral key of
A was revealed
An adversary M’s advantage at winning the NAXOS game is deﬁned as AdvN AXOS(M ) = P r[M wins] − 1
2.
B. Message Conﬁdentiality
Message Conﬁdentiality is the property that only conversation participants can read a message. The adversary we
consider controls the network and is allowed to register malicious users and reveal the long-term keys and ephemeral
keys of users. When discussing message conﬁdentiality we consider the conﬁdentiality of individual (target)
messages in a session. The adversary is only limited to avoid trivially breaking message conﬁdentially. Message
conﬁdentiality is captured by the game in Figure 6.
First the adversary INITIALIZEs with a set of honest user identities. The challenger sets up the public key
infrastructure (PKI) and generates long-term keys for the honest users. The adversary is allowed to register
additional users and long-term keys with the PKI. SEND is called by the adversary to send network messages
from entity S to entity R. The adversary is also allowed to instruct users to SETUP, SENDGROUPMESSAGE, and
UPDATEPARTICIPANTS, to setup a session, send group messages, and update the set of participants in a session.
Additionally, the adversary is allowed to reveal the long-term and ephemeral secret keys of any participant or server
with REVEALLONGTERMKEYS and REVEALEPHEMALKEYS. The adversary may issue a single TEST query where
the challenger ﬂips a coin and sends either the encrypted message or a random ciphertext. Finally, the adversary
calls FINALIZES providing its guess of the bit. The adversary wins if it guesses correctly.
To prevent the adversary from trivially wining it is not allowed to:
•
•
Control a participant in the target session at the time of the target message.
Call REVEALLONGTERMKEYS and REVEALEPHEMERALKEYS of the sender P and a receiving partic-
ipant R (cid:54)= P in session Sid. This does allow the adversary to compromise the long-term and ephemeral
keys between receivers.
The advantage of adversary M is deﬁned as Advconf (M ) = P r[Mwins] − 1
2.
Theorem A.1. Mobile CoWPI provides message conﬁdentiality if all hash and key derivation functions are modeled
as random oracles.
21
Fig. 6: Message Conﬁdentiality Game G0
function INITIALIZE(U)
b ←R {0, 1}
Initialize PKI for all users in and servers U.
function SEND(R, S, m)
Send m to R from S where R and S may be participants or servers.
return Network output of R after processing m
function SETUPGROUP(Sid, P, U)
Setup session Sid, as participant P for users U.
return Network output of P
function SENDGROUPMESSAGE(Sid, P, m)
Send message m from P to group Sid.
return Network output of P .
function UPDATEPARTICPANTS(Sid, P, U)
Send participant update message as P for participants U in session Sid.
return Network output of P .
function REVEALEPHEMERALKEYS(Sid, A, B)
be users or servers. If A or B is a server, Sid is ignored.
function REVEALLONGTERMKEYS(T )
return The Long-term keys of T where T may be a server or participant.
return The ephemeral secret keys of A that A uses for communication with B in session Sid. A or B may
function TEST(Sid, P, m)
if
thenb = 0
P sends protocol broadcast message of m in session Sid