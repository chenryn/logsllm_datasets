## 额外收获在这个模块的最后，针对大家在学习过程中的一些问题，我也进行了回答，帮你梳理出一个思路，更好地理解学到的内容：-   持续集成的延伸。    -   持续集成完成系统集成。    -   持续交付完成可部署上线。    -   "持续验证"完成产品想法验证。-   AB 测试，用一个软件的多个版本验证想法。-   Selenium 用以完成浏览器的自动化。-   熟练使用快捷键。------《[答疑解惑 \|持续集成、持续交付，然后呢？](http://time.geekbang.org/column/article/89050)》
## 留言精选在讲到 "懒惰"应该是所有程序员的骄傲时，[jxin]{.orange} 同学提到：> 有价值的事并不局限性于事情本身。做自动化很重要，写代码很重要。但根据现有情况判断是否需要自动化，是否需要写代码也很重要。有的放矢，任务分解。权衡跟设计是件很艺术的事情，令人着迷。另外，关于持续交付，[Jxin ]{.orange}同学也提出了自己的理解：> 分而治之是解决复杂问题的一大利器。持续交互就像重构中小步快走（每次微调后运行测试代码验证），都能保证大工程的稳步前进。同时由于单元小了，所以也灵活了，持续交互可以结合最小产品的理念，以小成本做> test，收集数据后，即时调整产品发展方向。关于软件设计， [毅]{.orange} 同学分享了自己的感悟：> 我们常说任务到手不要着急去做，要从设计入手，把时间多花在前面。工作中发现大家都是思考了才动手的，那为什么越往后偏差越大呢？> 共性原因有二：一是全局观不够，用咱们课里的话说就是上下文局限和反馈延迟（看到问题不提，直到代码写到那绕不过去了再沟通）；> 二是没有领域的概念和有意识地去实践（纸上谈兵），尤其是做流程型任务，都喜欢先把表结构定义出来，再去生成实体，所以从领域层面来看这些实体就很不合适了。结果必然是用面向对象的工具写出了面向过程的代码，既然是面向过程那> OO> 设计原则就鲜有用武之地了。这两点也是我个人理解要做好软件设计的两个必要条件。讲到分层架构时，[ desmond]{.orange} 同学提到：> 学了 REST 和> DDD，感觉两者有相通的地方：两者都以数据（一个是资源，另外一个是领域对象）为中心，并制定一套标准的数据操作（一个是> HTTP Verb，另外一个我项目主要用 JPA 这一套）；而核心是业务建模。对于微服务的理解，[风翱]{.orange} 同学提到：> 公司说我们的开发方式是敏捷开发，实际上只是使用了一些敏捷开发的方法，只有遵守敏捷开发的价值观和原则，才能算是敏捷开发。微服务也是一样，不是说拆分成多个服务去部署，就叫做微服务。也不是采用市面上常用的微服务框架，就是微服务了。对于一个好的项目自动化应该是什么样子这个问题，[西西弗与卡夫卡]{.orange}同学提到：> 设想过这样的情景（还没实现，打算实践一把）：我们新招一名比较熟练的程序员，从> TA 入职拿到机器，到开发示意代码，再提交 SCM，然后> CI/CD，再发布到线上交付给用户，整个过程可以在入职当天的午饭之前完成。> 这不光要求构建和集成自动化，甚至要求从入职开始的各个环节都能提前准备好，包括机器、开发环境、线上环境等，甚至连示范的需求都要能及时传递给> TA。理想情况下，程序员只需要开发好程序，保证质量，提交到 SCM> 即可，其他事情都应该交给机器。> 要知道程序员都很贵，越早给用户交付价值越好。对于自动化验收测试，[ shniu]{.orange} 同学分享了他的学习感悟：> 自动化验收测试确实是很好的东西，比如在回归测试，省去了很多的重复工作。但我理解> BDD> 的初衷是驱动产品、业务、开发、测试等去深入讨论沟通需求，在还没有真的写代码的时候去实例化> story，并一起定义验收用例，让每个人对需求的理解都很透彻，当然特别注意的是要从统一的业务角度去描述，可见，真的做好> BDD 是需要不断的尝试和总结的。对于"5 万块做淘宝"这个话题，[enjoylearning ]{.orange}同学提到：> 做一个淘宝那样的，客户指的是业务类似，但用户量多少，需要多少并发数，搜索性能等如何都是需要跟客户沟通后才能决定技术选型的。现实中我们的有些系统已经满足了业务需求，就没有必要为了追求技术复杂度而去拆分了，只有面向问题技术选型才会有成效。关于运维知识，[hua168]{.orange} 同学对文章内容进行了补充：> 现在运维流行 DevOps，高级一点就是 AI，其中一篇文章《DevOps> 详解》不错，链接如下：\> > 《DevOps 知识体系与标准化的构建》也不错，下载地址：\> > 运维知识体系：\> > Web 缓存知识体系：\> **感谢同学们的精彩留言。在下一个模块中，我将结合具体的应用场景，将之前讲过的"思考框架"和"四个原则"进行综合应用的分析。**![](Images/4aeedbc8a938230747919f292ba0ff37.png){savepage-src="https://static001.geekbang.org/resource/image/67/37/67ec791b2d57a9af095e6a00ff99a137.png"}感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给你的朋友。![](Images/c5ab8bdd4a4ef9ab036086ec14b202fc.png){savepage-src="https://static001.geekbang.org/resource/image/b0/27/b0ac100b816b69b9f00634e65cb5e427.jpg"}
# 加餐 \| 你真的了解重构吗？今天（3 月 15 日），Martin Fowler《重构》第二版的中文版正式发布。前不久，人邮的杨海灵老师找到我，让我帮忙给这本书写推荐语，我毫不犹豫地就答应了，有机会为经典之作写推荐语，实属个人荣幸。不过，我随即想到，在专栏里，我只是在谈 TDD的时候提到了重构，并没有把它作为一个专门的话题来讲，于是，我决定给我的专栏读者加餐，专门谈谈重构，毕竟重构是几乎每个程序员都会用到的词汇。但你真的了解重构吗？
## 每个程序员都要做的事作为程序员，我们都希望自己的代码是完美的。但没有代码是完美的，因为只要你的代码还有生命力，一定会有新的需求进来，而新的需求常常是你在编写这段代码之初始料未及的。很多人直觉的选择是，顺着既有的代码结构继续写下去，这里添一个if，那里加一个标记位，长此以往，代码便随时间腐坏了。如果用一个物理学术语描述这种现象，那就是"熵增"，这也就是大名鼎鼎的热力学第二定律。如果没有外部干预，系统会朝着越来越混乱的方向发展。对抗熵增的一个办法就是引入负熵，让系统变得更加有序。而在代码中引入负熵的过程就是"重构"。调整代码这件事是程序员都会有的习惯，但把这件事做到比较系统，上升为"重构"这个值得推广的实践是从一个小圈子开始的，这个小圈子的核心就是我们在专栏里前面提到过的两位大师级程序员：WardCunningham 和 Kent Beck。``{=html}而真正让这个概念走出小圈子，来到大众面前的，则是 Martin Fowler 在 1999年写下那本软件行业的名著《重构：改善既有代码的设计》（Refactoring:Improving the Design of Existing Code）。Martin Fowler的本事就在于他极强的阐述能力，很多名词经过他的定义就会成为行业的流行语（Buzzword），重构就是其中之一。重构这个说法可比"调整代码"听上去高级多了。时至今日，很多人都会把重构这个词挂在嘴边："这个系统太乱了，需要重构一下。"**但遗憾的是，很多程序员对重构的理解是错的。**
## 重构是一种微操作你理解的重构是什么呢？就以前面那句话为例：这个系统太乱了，需要重构一下。如果我们接着问，你打算怎么重构呢？一些人就会告诉你，他们打算另立门户，重新实现这套系统。对不起，**你打算做的事叫重写（rewrite），而不是重构（refactoring）。**《重构》是一本畅销书，但以我的了解，很少有人真正读完它，因为 MartinFowler 是按照两本书（DuplexBook）来写的，这是他常用写书的风格，前半部分是内容讲解，后半部分是手册。让这本书真正声名鹊起的就是前半部分，这部分写出了重构这件事的意义，而后半部分的重构手册很少有人会看完。很多人以为看了前半部分就懂了重构，所以，在他们看来，重构就是调整代码。调整代码的方法我有很多啊，重写也是其中之一。如果真的花时间去看这本书的后半部分，你多半会觉得很无聊，因为每个重构手法都是非常细微的，比如，变量改名，提取方法等等。尤其是在今天，这些手法已经成了IDE 中的菜单。估计这也是很多人就此把书放下，觉得重构不过如此的原因。所以，行业里流传着各种关于重构的误解，多半是没有理解这些重构手法的含义。**重构，本质上就是一个"微操作"的实践。**如果你不能理解"微操作"的含义，自然是无法理解重构的真正含义，也就不能理解为什么说"大开大合"的重写并不在重构的范畴之内。我在《[大师级程序员的工作秘笈](http://time.geekbang.org/column/article/78507)》这篇文章中曾经给你介绍过"微操作"，每一步都很小，小到甚至在很多人眼里它都是微不足道的。重构，也属于微操作的行列，与我们介绍的任务分解结合起来，你就能很好地理解那些重构手法的含义了：**你需要把做的代码调整分解成若干可以单独进行的"重构"小动作，然后，一步一步完成它。**比如，服务类中有一个通用的方法，它并不适合在这个有业务含义的类里面，所以，我们打算把它挪到一个通用的类里面。你会怎么做呢？大刀阔斧的做法一定是创建一个新的通用类，然后把这个方法复制过去，修复各种编译错误。而重构的手法就会把它做一个分解：-   添加一个新的通用类，用以放置这个方法；-   在业务类中，添加一个字段，其类型是新添加的通用类；-   搬移实例方法，将这个方法移动到新的类里面。得益于现在的 IDE能力的增强，最后一步，按下快捷键，它就可以帮我们完成搬移和修改各处调用的工作。**在这个分解出来的步骤里，每一步都可以很快完成，而且，每做完一步都是可以停下来的，这才是微操作真正的含义。**这是大刀阔斧做法做不到的，你修改编译错误的时候，你不知道自己需要修改多少地方，什么时候是一个头。当然，这是一个很简单的例子，大刀阔斧的改过去也无伤大雅。但事实上，很多稍有规模的修改，如果不能以重构的方式进行，常常很快就不知道自己改到哪了，这也是很多所谓"重写"项目面临的最大风险，一旦开始，不能停止。你现在理解了，重构不仅仅是一堆重构手法，更重要的是，**你需要有的是"把调整代码的动作分解成一个个重构小动作"的能力。**
## 重构地图下面我准备给你提供一张关于重构的知识地图，帮你了解它与周边诸多知识之间的关系，辅助你更好地理解重构。学习重构，先要知道重构的定义。关于这点，Martin Fowler给出了两个定义，一个名词和一个动词。> 重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。> 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。之所以要了解重构的定义，因为重构的知识地图就是围绕着这个定义展开的。首先，我们要对软件的内部结构进行调整，第一个要回答的问题是，我们为什么要调整。MartinFowler 对于这个问题的回答是：代码的坏味道。代码的坏味道，在我看来，是这本书给行业最重要的启发。很多人常常是无法嗅到代码坏味道的，因此，他们会任由代码腐坏，那种随便添加if 或标记的做法就是嗅不出坏味道的表现。我经常给人推荐《重构》这本书，但我也常常会补上一句，如果你实在没有时间，就去看它的第三章《代码的坏味道》。顺便说一下，对比两版的《重构》，你会发现它们在坏味道的定义上有所差异，在新版的《重构》中，可变数据（MutableData）、循环语句（Loops）都定义成了坏味道，如果你不曾关注近些年的编程发展趋势，这样的定义着实会让人为之震惊。但只要了解了函数式编程的趋势，就不难理解它们的由来了。换句话说，**函数式编程已然成为时代的主流**。如果你还不了解，赶紧去了解。我们接着回到重构的定义上，重构是要不改变软件的可观察行为。我们怎么知道是不是改变了可观察行为，最常见的方式就是测试。关于测试，我在"任务分解"模块已经讲了很多，你现在已经可以更好地理解重构、TDD这些概念是怎样相互配合一起的了吧！再来，重构是要提高可理解性，那重构到什么程度算是一个头呢？当年重构讨论最火热的时候，有人给出了一个答案：[重构成模式](http://book.douban.com/subject/1917706/)（Refactoringto Patterns）。当然，这也是一本书的名字，有兴趣的话，可以找来读一读。我个人有个猜想，如果这个讨论可以延续到 2008 年，等到 Robert Martin的《Clean Code》出版，也许有人会提"重构成 CleanCode"也未可知。所以，无论是设计模式，亦或是 CleanCode，都是推荐你去学习的。至此，我把重构的周边知识整理了一番，让你在学习重构时，可以做到不仅仅是只见树木，也可看见森林。当然，重构的具体知识，还是去看Martin Fowler 的书吧！