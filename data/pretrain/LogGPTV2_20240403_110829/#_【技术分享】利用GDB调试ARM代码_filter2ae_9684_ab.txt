s
step 
执行下一行代码。不会进入函数内部
nexti
n
next 
继续处理，直到达到指定的行号、函数名称、地址、文件名函数或文件名：行号
until
until 、
显示当前行号以及所在的函数
where
    gef> nexti 5
    ...
    0x8068  bl 0x8074   sub sp, r11, #0
    0x8070  pop {r11, pc}
    0x8074  push {r11}
    0x8078  add r11, sp, #0
    0x807c  sub sp, sp, #12
    0x8080  cmp r0, r1
    0x8084  movlt r0, r1
    0x8088  add sp, r11, #0
使用info registers或i r命令检查寄存器的值
    gef> info registers
    r0     0x1     1
    r1     0x2     2
    r2     0x0     0
    r3     0x0     0
    r4     0x0     0
    r5     0x0     0
    r6     0x0     0
    r7     0x0     0
    r8     0x0     0
    r9     0x0     0
    r10    0x0     0
    r11    0xbefff7e8 3204446184
    r12    0x0     0
    sp     0xbefff7d8 0xbefff7d8
    lr     0x0     0
    pc     0x8068  0x8068 
    cpsr   0x10    16
命令“info registers”能够提供当前的寄存器状态。
我们可以看到，这里包括通用寄存器r0-r12，专用寄存器SP、LR和PC，以及状态寄存器CPSR。 函数的前四个参数通常存储在r0-r3中。
在这种情况下，我们可以通过手动方式将其值移动到r0和r1。
显示进程内存映射：
    gef> info proc map
    process 10225
    Mapped address spaces:
     Start Addr   End Addr    Size     Offset objfile
     0x8000     0x9000  0x1000          0   /home/pi/lab/max
     0xb6fff000 0xb7000000  0x1000          0          [sigpage]
     0xbefdf000 0xbf000000 0x21000          0            [stack]
     0xffff0000 0xffff1000  0x1000          0          [vectors]
通过命令“disassemble”，我们可以查看函数max的反汇编输出。
    gef> disassemble max
     Dump of assembler code for function max:
     0x00008074 : push {r11}
     0x00008078 : add r11, sp, #0
     0x0000807c : sub sp, sp, #12
     0x00008080 : cmp r0, r1
     0x00008084 : movlt r0, r1
     0x00008088 : add sp, r11, #0
     0x0000808c : pop {r11}
     0x00008090 : bx lr
     End of assembler dump.
GEF特有的命令（可以使用命令“gef”查看更多命令）：
将所有已加载的ELF镜像的所有节dump到进程内存中
X档案
proc map的增强版本，包括映射页面中的RWX属性
vmmap
给定地址的内存属性
xinfo
检查运行的二进制文件内置的编译器级保护措施
checksec
    gef> xfiles
         Start        End  Name File
    0x00008054 0x00008094 .text /home/pi/lab/max
    0x00008054 0x00008094 .text /home/pi/lab/max
    0x00008054 0x00008094 .text /home/pi/lab/max
    0x00008054 0x00008094 .text /home/pi/lab/max
    0x00008054 0x00008094 .text /home/pi/lab/max
    0x00008054 0x00008094 .text /home/pi/lab/max
    0x00008054 0x00008094 .text /home/pi/lab/max
    0x00008054 0x00008094 .text /home/pi/lab/max
    0x00008054 0x00008094 .text /home/pi/lab/max
    0x00008054 0x00008094 .text /home/pi/lab/max
    gef> vmmap
         Start        End     Offset Perm Path
    0x00008000 0x00009000 0x00000000 r-x /home/pi/lab/max
    0xb6fff000 0xb7000000 0x00000000 r-x [sigpage]
    0xbefdf000 0xbf000000 0x00000000 rwx [stack]
    0xffff0000 0xffff1000 0x00000000 r-x [vectors]
    gef> xinfo 0xbefff7e8
    ----------------------------------------[ xinfo: 0xbefff7e8 ]----------------------------------------    Found 0xbefff7e8
    Page: 0xbefdf000 -> 0xbf000000 (size=0x21000)
    Permissions: rwx
    Pathname: [stack]
    Offset (from page): +0x207e8
    Inode: 0
    gef> checksec
    [+] checksec for '/home/pi/lab/max'
    Canary:                  No
    NX Support:              Yes
    PIE Support:             No
    RPATH:                   No
    RUNPATH:                 No
    Partial RelRO:           No
    Full RelRO:              No
故障排除
为了更高效地使用GDB进行调试，很有必要了解某些分支/跳转的目标地址。 某些（较新的）GDB版本能够解析分支指令的地址，并能显示目标函数的名称。
例如，下面是缺乏这些功能的GDB版本的输出内容：
    ...
    0x000104f8 : bl 0x10334
    0x000104fc : mov r0, #8
    0x00010500 : bl 0x1034c
    0x00010504 : mov r3, r0
    ...
而下面则是提供了上述功能的GDB版本的的输出结果：
    0x000104f8 :    bl      0x10334 
    0x000104fc :    mov     r0, #8
    0x00010500 :    bl      0x1034c 
    0x00010504 :    mov     r3, r0
如果您的GDB版本中没有提供这些功能，可以升级Linux（前提是它们提供了更新的GDB），或者自己编译较新的GDB。
如果您选择自己编译GDB，可以使用以下命令：
    cd /tmp
    wget https://ftp.gnu.org/gnu/gdb/gdb-7.12.tar.gz
    tar vxzf gdb-7.12.tar.gz
    sudo apt-get update
    sudo apt-get install libreadline-dev python-dev texinfo -y
    cd gdb-7.12
    ./configure --prefix=/usr --with-system-readline --with-python && make -j4
    sudo make -j4 -C gdb/ install
    gdb --version
我使用上面提供的命令来下载、编译和运行Raspbian（jessie）上的GDB，并且没有遇到任何问题。同时，这些命令也将取代以前版本的GDB。如果您不想这样做的话，请跳过以单词install结尾的命令。此外，我在QEMU中模拟Raspbian时也是这样做的，不过这个过程非常耗时，大概需要几个小时，因为模拟环境的资源（CPU）有限。
我使用的GDB版本为7.12，但是你还可以使用更高的版本，为此可以点击此处查看其他版本。