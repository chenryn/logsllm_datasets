## URI 的完整格式讲完了 query 参数，URI 就算完整了，HTTP 协议里用到的 URI绝大多数都是这种形式。不过必须要说的是，URI 还有一个"真正"的完整形态，如下图所示。![](Images/a62e671dd27585f1700abbf3a6737b73.png){savepage-src="https://static001.geekbang.org/resource/image/ff/38/ff41d020c7a27d1e8191057f0e658b38.png"}这个"真正"形态比基本形态多了两部分。第一个多出的部分是协议名之后、主机名之前的**身份信息**"user:passwd@"，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。第二个多出的部分是查询参数后的**片段标识符**"#fragment"，它是 URI所定位的资源内部的一个"锚点"或者说是"标签"，浏览器可以在获取资源后直接跳转到它指示的位置。但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带"#fragment"的URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段。
## URI 的编码刚才我们看到了，在 URI 里只能使用 ASCII 码，但如果要在 URI里使用英语以外的汉语、日语等其他语言该怎么办呢？还有，某些特殊的 URI，会在 path、query里出现"@&?\"等起界定符作用的字符，会导致 URI解析错误，这时又该怎么办呢？所以，URI 引入了编码机制，对于 ASCII码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI语义不冲突的形式。这在 RFC 规范里称为"escape"和"unescape"，俗称"转义"。URI 转义的规则有点"简单粗暴"，直接把非 ASCII码或特殊字符转换成十六进制字节值，然后前面再加上一个"%"。例如，空格被转义成"%20"，"?"被转义成"%3F"。而中文、日文等则通常使用UTF-8 编码后再转义，例如"银河"会被转义成"%E9%93%B6%E6%B2%B3"。有了这个编码规则后，URI就更加完美了，可以支持任意的字符集用任何语言来标记资源。不过我们在浏览器的地址栏里通常是不会看到这些转义后的"乱码"的，这实际上是浏览器一种"友好"表现，隐藏了URI 编码后的"丑陋一面"，不信你可以试试下面的这个 URI。    http://www.chrono.com:8080/11-1? 夸父逐日先在 Chrome 的地址栏里输入这个 query 里含有中文的URI，然后点击地址栏，把它再拷贝到其他的编辑器里，它就会"现出原形"：    http://www.chrono.com:8080/11-1?%E5%A4%B8%E7%88%B6%E9%80%90%E6%97%A5
## 小结今天我们学习了网址也就是 URI 的知识，在这里小结一下今天的内容。1.  [URI 是用来唯一标记服务器上资源的一个字符串，通常也称为    URL；]{.orange}2.  [URI 通常由 scheme、host:port、path 和 query    四个部分组成，有的可以省略；]{.orange}3.  [scheme    叫"方案名"或者"协议名"，表示资源应该使用哪种协议来访问；]{.orange}4.  ["host:port"表示资源所在的主机名和端口号；]{.orange}5.  [path 标记资源所在的位置；]{.orange}6.  [query 表示对资源附加的额外要求；]{.orange}7.  [在 URI 里对"@&/"等特殊字符和汉字必须要做编码，否则服务器收到 HTTP    报文后会无法正确处理。]{.orange}
## 课下作业1.  HTTP 协议允许在在请求行里使用完整的    URI，但为什么浏览器没有这么做呢？2.  URI 的查询参数和头字段很相似，都是 key-value    形式，都可以任意自定义，那么它们在使用时该如何区别呢？欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，欢迎你把文章分享给你的朋友。![unpreview](Images/8f6cd58e2b3ca90e769e869cc3bb479f.png){savepage-src="https://static001.geekbang.org/resource/image/08/58/08850d708d38a1301c6960fc554e3d58.png"}![unpreview](Images/4913a489805db29b38aefa585223c013.png){savepage-src="https://static001.geekbang.org/resource/image/56/63/56d766fc04654a31536f554b8bde7b63.jpg"}
# 12 \| 响应状态码该怎么用？前两讲中，我们学习了 HTTP 报文里请求行的组成部分，包括请求方法和URI。有了请求行，加上后面的头字段就形成了请求头，可以通过 TCP/IP协议发送给服务器。服务器收到请求报文，解析后需要进行处理，具体的业务逻辑多种多样，但最后必定是拼出一个响应报文发回客户端。响应报文由响应头加响应体数据组成，响应头又由状态行和头字段构成。我们先来复习一下状态行的结构，有三部分：![](Images/ed4757c1ae592c1743f99a3c3b7c7ff4.png){savepage-src="https://static001.geekbang.org/resource/image/a1/00/a1477b903cd4d5a69686683c0dbc3300.png"}开头的 Version 部分是 HTTP 协议的版本号，通常是 HTTP/1.1，用处不是很大。后面的 Reason 部分是原因短语，是状态码的简短文字描述，例如"OK""NotFound"等等，也可以自定义。但它只是为了兼容早期的文本客户端而存在，提供的信息很有限，目前的大多数客户端都会忽略它。所以，状态行里有用的就只剩下中间的**状态码**（StatusCode）了。它是一个十进制数字，以代码的形式表示服务器对请求的处理结果，就像我们通常编写程序时函数返回的错误码一样。不过你要注意，它的名字是"状态码"而不是"错误码"。也就是说，它的含义不仅是错误，更重要的意义在于表达HTTP数据处理的"状态"，客户端可以依据代码适时转换处理状态，例如继续发送请求、切换协议，重定向跳转等，有那么点TCP 状态转换的意思。``{=html}
## 状态码目前 RFC 标准里规定的状态码是三位数，所以取值范围就是从 000 到999。但如果把代码简单地从 000开始顺序编下去就显得有点太"low"，不灵活、不利于扩展，所以状态码也被设计成有一定的格式。RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0\~99不用，这样状态码的实际可用范围就大大缩小了，由 000\~999 变成了100\~599。这五类的具体含义是：-   1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；-   2××：成功，报文已经收到并被正确处理；-   3××：重定向，资源位置发生变动，需要客户端重新发送请求；-   4××：客户端错误，请求报文有误，服务器无法处理；-   5××：服务器错误，服务器在处理请求时内部发生了错误。在 HTTP协议中，正确地理解并应用这些状态码不是客户端或服务器单方的责任，而是双方共同的责任。客户端作为请求的发起方，获取响应报文后，需要通过状态码知道请求是否被正确处理，是否要再次发送请求，如果出错了原因又是什么。这样才能进行下一步的动作，要么发送新请求，要么改正错误重发请求。服务器端作为请求的接收方，也应该很好地运用状态码。在处理请求时，选择最恰当的状态码回复客户端，告知客户端处理的结果，指示客户端下一步应该如何行动。特别是在出错的时候，尽量不要简单地返400、500 这样意思含糊不清的状态码。目前 RFC 标准里总共有 41个状态码，但状态码的定义是开放的，允许自行扩展。所以 Apache、Nginx 等Web 服务器都定义了一些专有的状态码。如果你自己开发 Web应用，也完全可以在不冲突的前提下定义新的代码。在我们的实验环境里也可以对这些状态码做测试验证，访问URI"**/12-1**"，用查询参数"code=xxx"来检查这些状态码的效果，服务器不仅会在状态行里显示状态码，还会在响应头里用自定义的"Expect-Code"字段输出这个代码。例如，在 Chrome里访问""的结果如下图。![](Images/2dcac0e53a26d61b863f8dc0d137b282.png){savepage-src="https://static001.geekbang.org/resource/image/07/d7/07e7a40241a09683c5420e7b311227d7.png"}接下来我就挑一些实际开发中比较有价值的状态码逐个详细介绍。
## 1××1××类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。我们偶尔能够见到的是"**101 Switching Protocols**"。它的意思是客户端使用Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如WebSocket。而如果服务器也同意变更协议，就会发送状态码101，但这之后的数据传输就不会再使用 HTTP 了。
## 2××2××类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。"**200OK**"是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非HEAD 请求，通常在响应头后都会有 body 数据。"**204 No Content**"是另一个很常见的成功状态码，它的含义与"200OK"基本相同，但响应头后没有 body 数据。所以对于 Web服务器来说，正确地区分 200 和 204 是很必要的。"**206 Partial Content**"是 HTTP分块下载或断点续传的基础，在客户端发送"范围请求"、要求获取资源的部分数据时出现，它与200 一样，也是服务器成功处理了请求，但 body里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段"**Content-Range**"，表示响应报文里 body数据的具体范围，供客户端确认，例如"Content-Range: bytes0-99/2000"，意思是此次获取的是总计 2000 个字节的前 100 个字节。