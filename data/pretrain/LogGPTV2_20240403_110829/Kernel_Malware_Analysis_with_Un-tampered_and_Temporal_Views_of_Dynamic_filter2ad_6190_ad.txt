fork.c:610
fork.c:610
generic.c:436 0x20
(Static object)
(Static object)
(Static object)
(Module object)
(Module object)
Type / Object (Static, Module object) Field
Offset
task struct (Case (1))
0x4,12c,130
0x134,138,13c task struct (Case (1))
0x140,144,148 task struct (Case (1))
task struct (Case (1))
0x1d0
task struct (Case (1))
0x1d4
task struct (Case (1))
0x1d8
proc dir entry (Case (2))
proc root inode operations lookup
proc root operations
unix dgram ops
ext3 dir operations
ext3 file operations
flags,uid,euid
suid,fsuid,gid
egid,sgid,fsgid
cap effective
cap inheritable
cap permitted
get info
readdir
recvmsg
readdir
write
the latest one before the attack and the earliest one after the attack, and presents them
for a comparison.
As a running example in this section, we will present the analysis of the attacks by
the adore-ng rootkit. This rootkit is chosen because of its advanced malware behavior
triggered by dynamic objects; and other rootkits can be analyzed in a similar way. Table 3
lists the kernel objects that the adore-ng rootkit tampers with. In particular, we focus on
two speciﬁc attack cases using dynamic objects: (1) The ﬁrst case is the manipulation
of a PCB (T3) for privilege escalation and (2) the second case is the manipulation of
a function pointer in a dynamic proc dir entry object (P1) to hijack kernel control
ﬂow. Fig. 4 presents a detailed view of kernel control ﬂow and the usage of the targeted
dynamic kernel memory in the attacks. The X axis shows the execution time, and kernel
control ﬂow is shown at top part of this ﬁgure. The space below shows the temporal usage
of dynamic memory at the addresses of T3 and P1 before and after rootkit attacks. Thick
horizontal lines represent the lifetime of kernel objects which are temporally allocated
at such addresses. + and × symbols below such lines show the read and write accesses
on corresponding objects. The aforementioned analysis process is illustrated as solid
arrows. From the times when T3 and P1 are manipulated (shown as dotted circles), the
monitor scans the execution trace backward and forward to ﬁnd the code execution that
consumes the values read from such objects (i.e., + symbols).
Fig. 4. Kernel control ﬂow (top) and the usage of dynamic memory (below) at the addresses of
T3 (Case (1)) and P1 (Case (2)) manipulated by the adore-ng rootkit. Time is in billions of
kernel instructions.
Kernel Malware Analysis with Un-tampered and Temporal Views
193
Selecting semantically relevant kernel behavior using data lifetime. Our monitor in-
spects dynamic memory states in the temporal execution trace and as such we face the
dynamic data identity problem described in Section 3.1. The core of the problem is that
one memory address may correspond with multiple objects over a period of time. This
problem can be solved if the lifetime of the inspected object is available because the
monitor can ﬁlter out irrelevant kernel behaviors triggered by other kernel objects that
share the same memory address. For example, in Fig. 4, we observe the memory for T3
is used for four other PCBs (i.e., T1, T2, T4, and T5) as well in the history of kernel ex-
ecution. Simply relying on the memory address to analyze the trace can lead to ﬁnding
kernel behavior for all ﬁve PCBs. However, the monitor limits the inspected time range
to the lifetime of T3 and select only semantically relevant behaviors to T3. Consequently
it can provide a reliable inspection of runtime behavior only relevant to attacks.
Other kernel memory mapping approaches commonly cannot handle this problem
properly. In static type-projection, when two kernel objects from different snapshots are
given we cannot determine whether they represent the same data instance or not even
though their status is identical because such objects may or may not be different data in-
stances depending on whether memory allocation/deallocation events occur between the
generation of such snapshots. Dynamic type-projection mapping is only based on mal-
ware instructions, and thus does not have information about allocation and deallocation
events which occur during legitimate kernel execution.
Case (1): Privilege escalation using direct memory manipulation. In order to demon-
strate the effectiveness of our temporal monitor we will discuss two speciﬁc attacks em-
ployed by adore-ng. The ﬁrst is a privilege escalation attack that works by modifying
the user and group ID ﬁelds of the PCB. The PCB is represented by T3 in Fig. 4. To
present the changed kernel behavior due to the manipulation of T3, the temporal monitor
ﬁnds the latest use of T3 before the attack (at t2) and the earliest use of it after the attack
(at t3). The data views at such times are presented in Fig. 5(a) and 5(b) as 2-dimensional
memory maps where a kernel memory address is represented as the combination of the
address in Y axis and the offset in X axis. These views present kernel objects relevant to
this attack before and after the attack. The manipulated PCB is marked with “Case (1)”
in the views and the values of its ﬁelds are shown in the box on the right side of each view
(PCB status). These values reveal a stealthy rootkit behavior that changes the identity of
(a) The original data view at t2.
(b) The manipulated data view at t3.
Fig. 5. Kernel data view before and after the adore-ng rootkit attack
194
J. Rhee et al.
a user process by directly patching its PCB (DKOM). Before the attack (Fig. 5(a)), the
PCB has the credentials of an ordinary user whose user ID is 500. However, after the
attack, Fig. 5(b) shows the credentials of the root user. This direct transition of its status
between two accounts is abnormal in conventional operating system environments. su
or sudo allow privileged operations by forking a process to retain the original identity.
Hence we determine that this is a case of privilege escalation that illegally permits the
root privilege to an ordinary user.
Case (2): Dynamic kernel object hooking. The next adore-ng attack hijacks kernel
code execution by modifying a function pointer and this attack is referred to as Kernel
Object Hooking (KOH) [10]. This behavior is observed when the inﬂuence of a manipu-
lated function pointer in P1 (see Fig. 4) is inspected. To select only the behaviors caused
by this object, the monitor guides the analysis to the lifetime of P1. The temporal mon-
itor detects several behaviors caused by reading this object and two samples are chosen
among those to illustrate the change of kernel behavior by comparison: the latest original
behavior before the attack (at t1) and the earliest changed behavior after the attack (at t4).
The monitor generates two kernel control ﬂow graphs at these samples, each for a period
of 4000 instructions. Fig. 6(a) and 6(b) present how this manipulated function pointer
affects runtime kernel behavior. The Y axis presents kernel code; thus, the ﬂuctuating
graphs show various code executed at the corresponding time of X axis. A hook-invoking
function (proc file read) reads the function pointer and calls the hook code pointed
to by it. Before the rootkit attack, the control ﬂow jumps to a legitimate kernel function
tcp get info which calls sprintf after that as shown in Fig. 6(a). However, after the
hook is hijacked, the control ﬂow is redirected to the rootkit code which calls kmalloc
to allocate its own memory, then comes back to the original function (Fig. 6(b)).
(a) The original control ﬂow at t1.
(b) The hijacked control ﬂow at t4.
Fig. 6. Kernel control ﬂow view before and after the adore-ng rootkit attack
7 Discussion
Since LiveDM operates in the VMM beneath the hardware interface, we assume that
kernel malware cannot directly access LiveDM code or data. However, it can exhibit po-
tentially obfuscating behavior to confuse the view seen by LiveDM. Here we describe
Kernel Malware Analysis with Un-tampered and Temporal Views
195
several scenarios in which malware can affect LiveDM and our counter-strategies to de-
tect them.
First, malware can implement its own custom memory allocators to bypass LiveDM
observation. This attack behavior can be detected based on the observation that any mem-
ory allocator must use internal kernel data structures to manage memory regions or its
memory may be accidentally re-allocated by the legitimate memory allocator. Therefore,
we can detect unveriﬁed memory allocations by comparing the resource usage described
in the kernel data structures with the amount of memory being tracked by LiveDM. Any
deviance may indicate the presence of a custom memory allocator.
In a different attack strategy, malware could manipulate valid kernel control ﬂow and
jump into the body of a memory allocator without entering the function from the be-
ginning. This behavior can be detected by extending LiveDM to verify that the function
was entered properly. For example, the VMM can set a ﬂag when a memory allocation
function is entered and verify the ﬂag before the function returns by interceding before
the return instruction(s) of the function. If the ﬂag was not set prior to the check, the
VMM detects a suspicious memory allocation.
8 Related Work
Static type-projection mapping has been widely used in the defense against kernel mal-
ware attacks. SBCFI [16] detects persistent manipulations to the kernel control ﬂow
graph by using kernel memory maps. Gibraltar [1] derives data invariants based on a
kernel memory map to detect kernel malware. KOP [5] improves the accuracy of map-
ping using extended type graph based on static analysis in addition to memory analysis.
Complementing these approaches, allocation-driven mapping provides an un-tampered
view of kernel objects where their identiﬁcation is not affected by kernel malware’s ma-
nipulation of the kernel memory content. It also accurately reﬂects the temporal status of
dynamic kernel memory, which makes it applicable to temporal analysis of kernel/kernel
malware execution.
PoKeR [23] and Rkproﬁler [31] use dynamic type-projection mapping generated from
rootkit instructions to understand the rootkit behavior. Since only rootkit activity is used
as the input to generate a kernel memory map, this approach can only cover the kernel
objects directly manipulated by rootkit code. Moreover, there exist the attacks that are
difﬁcult to be analyzed by these proﬁlers because rootkits can use various resource such
as hardware registers to ﬁnd the attack targets [21].
KernelGuard (KG) [20] is a system that prevents DKOM-based kernel rootkits by
monitoring and shepherding kernel memory accesses. It identiﬁes kernel objects to be
monitored by scanning the kernel memory using data structure-speciﬁc policies enforced
at the VMM level. Similar to type-projection mapping, KG’s view of kernel memory is
based on the runtime kernel memory content which is subject to malware manipulation.
As such, KG’s reliability can be improved by adopting LiveDM as the underlying kernel
memory mapping mechanism.
LiveDM involves techniques to capture the location, type, and lifetime of individ-
ual dynamic kernel objects, which can be described as belonging to the area of virtual
machine introspection [9].
196
J. Rhee et al.
9 Conclusion
We have presented allocation-driven mapping, a kernel memory mapping scheme, and
LiveDM, its implementation. By capturing the kernel objects’ allocation and dealloca-
tion events, our scheme provides an un-tampered view of kernel objects that will not
be affected by kernel malware’s manipulation of kernel memory content. The LiveDM-
generated kernel object map accurately reﬂects the status of dynamic kernel memory and
tracks the lifetimes of all dynamic kernel objects. This temporal property is highly desir-
able in temporal kernel execution analysis where both kernel control ﬂow and dynamic
memory status can be analyzed in an integrated fashion. We demonstrate the effective-
ness of the LiveDM system by developing a hidden kernel object detector and a temporal
malware behavior monitor and applying them to a corpus of kernel rootkits.
Acknowledgements. We thank the anonymous reviewers for their insightful comments.
This research was supported, in part, by the Air Force Research Laboratory (AFRL) un-
der contract FA8750-09-1-0224 and by the National Science Foundation (NSF) under
grants 0716444, 0852131, 0855036 and 0855141. Any opinions, ﬁndings, and conclu-
sions in this paper are those of the authors and do not necessarily reﬂect the views of the
AFRL or NSF.
References
1. Baliga, A., Ganapathy, V., Iftode, L.: Automatic Inference and Enforcement of Kernel Data
Structure Invariants. In: Proceedings of the 24th Annual Computer Security Applications
Conference (ACSAC 2008), pp. 77–86 (2008)
2. Bellard, F.: QEMU: A Fast and Portable Dynamic Translator. In: Proceedings of the USENIX
Annual Technical Conference, FREENIX Track, pp. 41–46 (2005)
3. Boehm, H.J., Weiser, M.: Garbage Collection in an Uncooperative Environment. Software,
Practice and Experience (1988)
4. Butler, J.: DKOM (Direct Kernel Object Manipulation),
http://www.blackhat.com/presentations/win-usa-04/
bh-win-04-butler.pdf
5. Carbone, M., Cui, W., Lu, L., Lee, W., Peinado, M., Jiang, X.: Mapping Kernel Objects
to Enable Systematic Integrity Checking. In: Proceedings of the 16th ACM Conference on
Computer and Communications Security, CCS 2009 (2009)
6. Chow, J., Garﬁnkel, T., Chen, P.M.: Decoupling Dynamic Program Analysis from Execution
in Virtual Environments. In: Proceedings of 2008 USENIX Annual Technical Conference,
USENIX 2008 (2008)
7. Cozzie, A., Stratton, F., Xue, H., King, S.T.: Digging For Data Structures. In: Proceedings
of the 8th USENIX Symposium on Operating Systems Design and Implementation (2008)
8. Free Software Foundation: The GNU Compiler Collection, http://gcc.gnu.org/
9. Garﬁnkel, T., Rosenblum, M.: A Virtual Machine Introspection Based Architecture for Intru-
sion Detection. In: Proceedings of the 10th Annual Network and Distributed Systems Security
Symposium, NDSS 2003 (2003)
10. Hoglund, G.: Kernel Object Hooking Rootkits (KOH Rootkits),
http://www.rootkit.com/newsread.php?newsid=501
11. Hund, R., Holz, T., Freiling, F.C.: Return-Oriented Rootkits: Bypassing Kernel Code Integrity
Protection Mechanisms. In: Proceedings for the 18th USENIX Security Symposium (2009)
Kernel Malware Analysis with Un-tampered and Temporal Views
197
12. Lin, Z., Riley, R.D., Xu, D.: Polymorphing Software by Randomizing Data Structure Layout.
In: Flegel, U., Bruschi, D. (eds.) DIMVA 2009. LNCS, vol. 5587, pp. 107–126. Springer,
Heidelberg (2009)
13. MITRE Corp.: Common Vulnerabilities and Exposures, http://cve.mitre.org/
14. Parallels: Parallels, http://www.parallels.com/
15. Petroni, N.L., Fraser, T., Molina, J., Arbaugh, W.A.: Copilot - A Coprocessor-based Ker-
nel Runtime Integrity Monitor. In: Proceedings for the 13th USENIX Security Symposium
(August 2004)
16. Petroni, N.L., Hicks, M.: Automated Detection of Persistent Kernel Control-Flow Attacks.
In: Proceedings of the 14th ACM Conference on Computer and Communications Security,
CCS 2007 (2007)
17. Petroni, N.L., Walters, A., Fraser, T., Arbaugh, W.A.: FATKit: A Framework for the Extrac-
tion and Analysis of Digital Forensic Data from Volatile System Memory. Digital Investiga-
tion Journal 3(4), 197–210 (2006)
18. Petroni, Jr. N.L., Fraser, T., Walters, A., Arbaugh, W.A.: An Architecture for Speciﬁcation-
Based Detection of Semantic Integrity Violations in Kernel Dynamic Data. In: Proceedings
of the 15th Conference on USENIX Security Symposium, USENIX-SS 2006 (2006)
19. Polishchuk, M., Liblit, B., Schulze, C.W.: Dynamic Heap Type Inference for Program Un-
derstanding and Debugging. In: Proceedings of the 34th Annual Symposium on Principles
of Programming Languages. ACM, New York (2007)
20. Rhee, J., Riley, R., Xu, D., Jiang, X.: Defeating Dynamic Data Kernel Rootkit Attacks via
VMM-Based Guest-Transparent Monitoring. In: International Conference on Availability,
Reliability and Security, ARES 2009 (2009)
21. Rhee, J., Xu, D.: LiveDM: Temporal Mapping of Dynamic Kernel Memory for Dynamic
Kernel Malware Analysis and Debugging. Tech. Rep. 2010-02, CERIAS (2010)
22. Riley, R., Jiang, X., Xu, D.: Guest-Transparent Prevention of Kernel Rootkits with VMM-
based Memory Shadowing. In: Lippmann, R., Kirda, E., Trachtenberg, A. (eds.) RAID 2008.
LNCS, vol. 5230, pp. 1–20. Springer, Heidelberg (2008)
23. Riley, R., Jiang, X., Xu, D.: Multi-Aspect Proﬁling of Kernel Rootkit Behavior. In: Proceed-
ings of the 4th European Conference on Computer Systems (Eurosys 2009) (April 2009)
24. Seshadri, A., Luk, M., Qu, N., Perrig, A.: SecVisor: A Tiny Hypervisor to Provide Lifetime
Kernel Code Integrity for Commodity OSes. In: Proceedings of 21st Symposium on Operating
Systems Principles (SOSP 2007). ACM, New York (2007)
25. Shacham, H.: The Geometry of Innocent Flesh on the Bone: Return-into-libc without Func-
tion Calls (on the x86). In: Proceedings of the 14th ACM Conference on Computer and Com-
munications Security (CCS 2007), pp. 552–561. ACM, New York (2007)
26. Sun Microsystems, Inc: VirtualBox, http://www.virtualbox.org/
27. The Month of Kernel Bugs archive, http://projects.info-pull.com/mokb/
28. US-CERT: Vulnerability Notes Database, http://www.kb.cert.org/vuls/
29. VMware, Inc.: VMware Virtual Machine Technology, http://www.vmware.com/
30. Wei, J., Payne, B.D., Gifﬁn, J., Pu, C.: Soft-Timer Driven Transient Kernel Control Flow
Attacks and Defense. In: Proceedings of the 24th Annual Computer Security Applications
Conference, ACSAC 2008 (December 2008)
31. Xuan, C., Copeland, J.A., Beyah, R.A.: Toward Revealing Kernel Malware Behavior in Vir-
tual Execution Environments. In: Proceedings of 12th International Symposium on Recent
Advances in Intrusion Detection (RAID 2009), pp. 304–325 (2009)