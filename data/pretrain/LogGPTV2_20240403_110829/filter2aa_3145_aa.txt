WHITE PAPER 
© 2015 IOActive, Inc. All Rights Reserved 
Abusing XSLT for Practical Attacks 
White Paper 
Fernando Arnaboldi 
IOActive Senior Security Consultant 
Abstract 
Over the years, XML has been a rich target for attackers due to flaws in its design as well as 
implementations. It is a tempting target because it is used by other programming languages to 
interconnect applications and is supported by web browsers. In this talk, I will demonstrate how to 
use XSLT to produce documents that are vulnerable to new exploits. 
XSLT can be leveraged to affect the integrity of arithmetic operations, lead to code logic failure, or 
cause random values to use the same initialization vector. Error disclosure has always provided 
valuable information, but thanks to XSLT, it is possible to partially read system files that could 
disclose service or system passwords. Finally, XSLT can be used to compromise end-user 
confidentiality by abusing the same-origin policy concept present in web browsers. 
This document includes proof-of-concept attacks demonstrating XSLT potential to affect 
production systems, along with recommendations for safe development. 
© 2015 IOActive, Inc. All Rights Reserved.  [2] 
Contents 
Abstract ......................................................................................................................... 1	
Introduction ................................................................................................................... 3	
Processors ............................................................................................................................. 3	
Gathering information about your target ................................................................................. 4	
Obtaining the current path ...................................................................................................... 6	
Loss of Precision with Large Integers ........................................................................... 8	
Loss of Precision with Real Numbers ......................................................................... 12	
Insecure Random Numbers ........................................................................................ 15	
Pseudorandom values are not secure .............................................................................. 15	
No initialization vector (IV) ................................................................................................ 16	
Same-Origin Policy Bypass ......................................................................................... 18	
Information Disclosure (and File Reading) through Errors .......................................... 21	
© 2015 IOActive, Inc. All Rights Reserved.  [3] 
Introduction 
XSLT is a language created to manipulate XML documents. This language can be used either by client 
side processors (i.e. web browsers) or server side processors (standalone parsers or libraries from 
programming languages).  
There are three major versions of XSLT: v1, v2 and v3. This research is focused on XSLT v1.0 since it 
is the most widely deployed version being used.  
There is a certain set of flaws that can put in risk the integrity and confidentiality of user information. 
Some of these flaws are analyzed on this paper along with recommendations to mitigate these 
problems. 
Processors 
The XSLT processors analyzed for this research are the following: 
• 
Server side processors: 
• 
Libxslt (Gnome):  
• 
Standalone: xsltproc 
• 
Python v2.7.10, PHP v5.5.20, Perl v5.16 and Ruby v2.0.0p481 (implemented 
in Nokogiri v1.6.6.2) 
• 
Xalan (Apache):  
• 
Standalone: Xalan-C v1.10.0 and Xalan-J v2.7.2 
• 
Java and C++ 
• 
Saxon (Saxonica):  
• 
Standalone: Saxon v9.6.0.6J 
• 
Java, JavaScript and .NET 
• 
Client side processors: 
• 
Web browsers: 
• 
Google Chrome v43.0.2357.124 
• 
Safari v8.0.6 
• 
Firefox v38.0.5 
• 
Internet Explorer v11 
• 
Opera v30.0 
© 2015 IOActive, Inc. All Rights Reserved.  [4] 
Gathering information about your target 
It is possible to query the XSLT processor for information about the backend system. This information 
may be used to target the specific flaws of each processor.  
The XSLT processor discloses specific information about the processor when retrieving information 
using the method system-property(). Normally, there are only three parameters available: 
version, vendor and vendor-url. Yet, certain processors provide additional system properties and, 
of course, web browsers will provide additional details when using JavaScript. 
Figure 1: XML file disclosure.xml 
    Version:  
    Vendor:  
    Vendor URL:  
      Product Name:  
      Product Version:  
      Is Schema Aware ?:  
      Supports Serialization:  
      Supports Backwards Compatibility:  
    Navigator Object (JavaScript stuff):  
    for (i in navigator) { document.write('navigator.' + i + 
' = ' + navigator[i]);}  
Figure 2: Stylesheet associated to get information 
© 2015 IOActive, Inc. All Rights Reserved.  [5] 
By using the previous XML and XSLT it is possible to obtain the XSLT and JavaScript properties (in 
case it is supported). The following table shows the two most significant values of the software tested: 
who the vendor is and if it supports JavaScript 
processor	
xsl:version	
xsl:vendor	
JavaScript	
server	
xalan-­‐c	
1	
Apache	
  Software	
  Foundation	
no	
xalan-­‐j	
1	
Apache	
  Software	
  Foundation	
no	
saxon	
2	
Saxonica	
no	
xsltproc	
1	
libxslt	
no	
php	
1	
libxslt	
no	
python	
1	
libxslt	
no	
perl	
1	
libxslt	
no	
ruby	
1	
libxslt	
no	
client	
safari	
1	
libxslt	
yes	
opera	
1	
libxslt	
yes	
chrome	
1	
libxslt	
yes	
firefox	
1	
Transformiix	
yes	
internet	
  explorer	
1	
Microsoft	
yes	
Table 1: summarize table of information disclosure 
All processors tested exposed some internal information: either the XSLT properties or the XSLT 
properties plus the JavaScript properties. 
© 2015 IOActive, Inc. All Rights Reserved.  [6] 
Obtaining the current path 
Certain attacks may require the specific path where the files are hosted. XSLT provides the function 
unparsed-entity-uri() that can be used to obtain this information. A document type definition 
(commonly known as DTD, a XML schema) is also required to accomplish this embedded in the XML 
document: 
]> 
Figure 3: XML using a DTD and referencing an XSLT 
         unparsed-entity-uri() 
               unparsed-entity-uri('currentpath') =  
Figure 4: XSLT using unparsed-entity-uri() to disclose the path of path-disclosure.xsl 
© 2015 IOActive, Inc. All Rights Reserved.  [7] 
processor	
path	
  disclosure	
server	
xalan-­‐c	
no	
xalan-­‐j	
yes	
saxon	
yes	
xsltproc	
no	
php	
yes	
python	
no	
perl	
no	
ruby	
no	
client	
safari	
yes	
opera	
yes	
chrome	
yes	
firefox	
no	
internet	
  explorer	
yes	
Table 2: path disclosure on processors using unparsed-entity-uri() 
All the web browsers except Firefox will expose the path of their files. When it comes to server side 
processors Xalan-j, Saxon and PHP are affected. It is worth noting that even though certain processors 
may use the same library, they do not necessarily share the same type of behavior. 
Once that some initial information has been gathered about our targets, we can jump to the different 
techniques used to exploit their flaws. 
© 2015 IOActive, Inc. All Rights Reserved.  [8] 
Loss of Precision with Large Integers 
When I do math, I expect calculations will have the same results regardless of whether they are 
performed on a computer or in the real world using a piece of paper and a pencil. Unfortunately, when 
using large numbers in XSLT 1.0, we might encounter unexpected results.  
Consider the following XML document that defines ten values: 
  1e22 
  1e23 
  1e24 
  1e25 
  1e26 
  10000000000000000000000 
  100000000000000000000000 
  1000000000000000000000000 
  10000000000000000000000000 
  100000000000000000000000000 
Figure 5: bigintegers.xml 
The values are simple numbers, which all follow the same rule: the number one followed by multiple 
zeroes.  
The next step is to represent these values with format-number(). This function is used to convert a 
number into a string and allows the input number to be formatted. In this case, we want to add a 
comma to separate thousands: 
     &#xa; 
     :  
Figure 6: bigintegers.xsl 
Applying this XSLT will result in ten different lines, one per value. These will contain the original value 
and its representation formatted with commas separating the thousands.  
This is the output when parsing the information using web browsers: 
© 2015 IOActive, Inc. All Rights Reserved.  [9] 
Figure 7: web browser showing incorrect values 
Notice the error introduced by format-number() on libxslt browsers (Safari, Opera, and Chrome on 
the left). Errors will be different depending on whether or not scientific notation is used. There were no 
errors for Firefox and Internet Explorer (on the right) 
© 2015 IOActive, Inc. All Rights Reserved.  [10] 
Figure 8: server side processors showing incorrect values 
A similar situation occurs on server side processors. On the left side of the screenshot the libxslt 
processors show a similar set of results. On the right xalan-c and xalan-j show unexpected results and 
Saxon shows the correct output at the bottom right. 
processor 
result 
server 
xalan-c (apache) 
errors 
xalan-j (apache) 
errors 
saxon 
ok 
xsltproc 
errors 
php 
errors 
python 
errors 
perl 
errors 
ruby 
errors 
client 
safari 
errors 
opera 
errors 
chrome 
errors 
firefox 
ok 
internet explorer 
ok 
Table 3: loss of precision with large integers 
It is also worth mentioning that processors will not notice if certain values are missing from very large 
integers. Whenever the processor is using more than 17 digits for a number, it will not be able to track 
missing numbers.  
The following statements in XSLT are always considered to be true: 
© 2015 IOActive, Inc. All Rights Reserved.  [11] 
   The statement 1 = 1 is true 
   The statement 10000000000000000000000 = 10000000000000000000000 - 1000000 is true 
Figure 9: Missing values are not detected 
Recommendation 
Use an XSLT processor capable of high-precision integer arithmetic to avoid incorrect calculations1. 
1 CWE-682: Incorrect Calculation (http://cwe.mitre.org/data/definitions/682.html) 
© 2015 IOActive, Inc. All Rights Reserved.  [12] 
Loss of Precision with Real Numbers 
Real numbers are difficult to represent exactly in computers. Some operations have anomalous 
behavior when used with certain values as a result of how calculations are performed.  
Consider the following XML document containing two float values: 