  2. 把延时换算法成计数，比如1秒等于32768次计数
  3. 把当前timetick计数加上延时的计数值作为该定时任务中断触发的match value
  4. 遍历所有定时任务，根据任务设置的定时任务中断触发的match value大小排序插入到定时任务列表
  5. 当timetick的计数到达某个定时任务的Match value的时候产生中断，中断处理例程ISR会通过向DPC（Deferred Procedure Calls）发送执行定时任务的消息去执行该定时任务的例程函数，如果只是延时任务就不需要执行了，同时更新timetick的下一次中断产生的match value，并把这个定时任务从定时任务列表中移除
如上图举例：
按照时间推进过程，这些定时任务执行需要设置的Match value来产生中断的顺序依次是：
M1 à M4 à M3 à M5 àM6 à M7
所以在基带系统里面会有一个专门的定时器应用任务来管理维护其它应用任务产生的定时器任务的调度。
#### e.任务管理和IPC通信机制
上面提到基带系统从内核态切入到应用态会创建第一个rootTask应用任务，这个任务有点类似linux系统里面的init进程，rootTask接下来会创建应用权限很高的DPC_task任务（负责高实时异步任务执行），权限仅次于IST（interruptservice
threads,中断服务接管线程），然后是应用层的全局管理任务main_task将会启动，接下来业务所需的各种驱动相关的初始化和通信业务逻辑任务将在main_task任务中得以创建，例如中断接管服务相关的IST(interruptService
Threads)，定时器业务相关的timer_task，qualcommEFS文件系统相关的fs_task，任务监控相关的watchdog_task，以及GSM/UMTS业务相关的通信层面的各个任务。
每个任务被创建时，REX内核和用户态各自会维护一套数据结构，以及用户自定义的一套TCB结构：
内核态—>KTCB（Kernel Task Control Block）
用户态—>UTCB（User Task Control Block）
用户态—>REX_TCB(用户自定义TCB结构)
在内核态，cpu通过KTCB来管理调度所有的任务，以及管理用户态任务在切换时存储任务的context信息。
内核态的KTCB列表包含1个idle内核线程,8个IRQ和1个FIQ内核线程任务KTCB结构，以及每一个用户任务UTCB对应的在内核空间存储的KTCB结构。
在用户态，每一个任务都会通过UTCB结构存储任务信息供用户读写，并且该UTCB结构也会映射到内核空间供内核读写，而用户态的REX_TCB是供用户自定义的数据结构，用户可以自定义一些方便业务间通信的数据结构。
任务的几个重要的特性：
  1. 内核态读取0xf0000008地址存储着当前活动任务的KTCB指针
  2. 内核态0xf001e000存储着所有KTCB结构的列表
  3. 在用户态读取0xff000ff0地址值可以获取当前活动任务的UTCB指针
KTCB，UTCB和用户定义的TCB结构关系如下图：
图从上图可知，UTCB结构通过内存映射的方式会被内核态和用户态共同读写，utcb通过timetick计数器来记录任务使用了多少cpu时间，为任务调度提供了很好的判断条件。
每个被创建的任务都包含一些信息，初始化时会存储在UTCB结构和用户定义的TCB结构中:
  1. 任务的执行函数地址
  2. 任务执行函数参数
  3. 堆栈起始地址
  4. 堆栈的长度
  5. 任务优先级别
  6. 存储用户tcb地址
  7. 任务名称
任务创建函数定义类似结构如下，不同的版本可能会有一些变形：
`Void *createTask(void *utcb,void*task_func_ptr,uint32 stack_size,void
*stack_buttom,void *stack_top,uint32task_priority，void *pararm)`
用户定义tcb结构是一个双向链表结构，每个用户tcb会把高于自己优先的任务插入到前链，低于自己优先级的任务插入到后链，所有的任务中中断接受任务中的FIQ任务的优先级是最高的，它用于快速处理来自于fiq中断请求。
下图是枚举出的部分运行的任务列表：
所有的任务通过优先级的高低，利用双向链表链接起来，如下图，FIQ任务具有最高优先级。
而sleep任务具有最低运行优先级
用户态的任务创建和运行流程如下图：
用户态任务运行特性：
  1. 每个被创建后的任务会被调度运行起来后，直至到等待信号的循环，阻塞接收消息，此时交出cpu执行权，切换执行任务。
  2. 当某个任务接收到消息后，任务等待信号的循环返回，根据接受到信号去处理相应的例程，然后清除接受到的信号值，继续新一轮的信号等待。
  3. 任务通过设置接受信号的掩码来设置多个信号处理例程，每个任务最多支持设置32个信号接受值。
  4. 信号接受值和信号接受掩码会在utcb结构中设置。
### IPC任务间通信
IPC通信是多任务协作通知和同步数据，非常重要的系统机制，在实时操作系统中应用广泛，对于无线通信复杂的状态机制以及低延时同步处理，IPC通信起到了至关重要的作用。
从上图我们可知每个运行的任务都有独立运行环境，有自己的堆栈空间，当不同任务之间进行数据交换和同步的时候，这时候就需要用到IPC机制了，我们把用户任务的rex_tcb结构作为任务的唯一标示，用它与之不同的任务进行通信，这里用到了很重要的信号通知和等待信号通知的机制，从上面我们可知每个任务可以定义最多32个信号量来区分接收到的不同信号，然后根据接受到的不同信号进行相应的处理。
例如A任务需要告之B任务，处理B任务里面的某个分支逻辑时，A只需要设置B任务rex_tcb结构里面信号值即可，当B任务被调度起来后的接受信号等待函数会立即返回取出A发送来的信号值，然后B任务作相应的处理。
该IPC通知机制在基带系统里面应用广泛，后续我也会提到。
任务调度机制：
  1. 中断发生时，cpu将调度到IST接管中断处理，因为IST的优先级比较高
  2. 当任务等待消息阻塞时，任务主动交出cpu控制权
  3. 应用任务都在等待时，rootTask和Main Task接管CPU，类似idleloop
  4. 当各个任务都有接受到消息时，根据任务的优先级和cpu使用时间进行调度
如下图系统初始化过程中的任务的切换过程以及CPU使用时间统计。
我们可以看到，在系统初始化过程中，各个任务的初始化过程，cpu使用时间都差不太多，因为初始化完了都处于阻塞状态了，只有rootTask和Main
Task占有大量的CPU时间，因为rootTask需要负责大量的KTCB切换的通知操作，而且Main Task主动初始化那些应用任务。
#### f.断管理
基带系统在系统初始化过程中会初始化中断控制器，注册相应的中断服务例程，设置中断优先级，并且生效中断响应，在高通的MDM6600基带系统中设置了8个响应IRQ的IST任务，和1个响应FIQ的IST任务，优先级依次提升，FIQ的IST任务具有最高的优先级别，因为在中断处理过程，可能会有更高优先级的中断产生，这时需要有高优先级的IST来接管响应来提升中断响应的实时性，由于中断是由硬件产生，而IST在应用态，所以中断处理过程如下。
  1. 硬件中断产生 （物理层）
  2. 判断是否是generic irq还是fiq （物理层）
  3. 进入到irq exception或者fiq exception向量表 （内核）
  4. 投递到相应中断处理分发器 （内核）
  5. 查询IRQ和FIQ的内核KTCB状态是否空闲 （内核）
  6. 通过KTCB结构找到相应的IST任务 （内核）
  7. 相应的IST接管中断，锁定该IST，并查询中断号对应的ISR （应用层）
  8. 执行ISR后，清除中断状态，解锁IST，等待新的中断响应 （应用层）
## 结语
本文章的目的主要是为了对高通的基带系统有一个体系化的了解，操作系统作为承载业务系统的基础设施，了解其运行原理对于研究上层业务会有很大的帮助，由于高通的的基带系统非常封闭，研究需要大量的逆向工程的工作，记录了大量的笔记，无法一一整理发出，所以也有可能会有一些遗漏和不足，如果有熟悉的同学，也希望能够指出有错误的地方，便于改正，接下来系列的研究文章将针对高通基带对于3GPP定义的GSM/UMTS/LTE，以及5G的实现上，并且挖掘其安全攻击面，希望能够坚持下去。
* * *