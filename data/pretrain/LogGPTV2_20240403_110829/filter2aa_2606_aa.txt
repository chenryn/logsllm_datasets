对 CVE-2022-39197 的曲折重现路 
0x01 前言 
之前看了@漂亮鼠大佬的文章《最新 CS RCE 曲折的复现路》，对文章的内容非常感兴
趣，但是大佬在文章中故意对关键利用链进行忽略，如图 1.1 所示，也勾起了大家浓烈的研
究兴趣。 
图 1.1 大佬隐藏的关键利用链 
本来以为按照大佬的提示这会是比较简单的一次复现，但是在实际过程中还是遇到很多
困难，可能这就是大佬和小弟的区别吧。非常感谢二哥@gainover 在复现过程中给予的指点
和帮助。 
在阅读本文之前需要首先阅读原文，原文中很多内容已经很详细了，我会尽量不写原文
已经有的内容。算是完成大佬留下的课后作业吧。 
0x02 初探 
第一次准备寻找相应的利用链的时候，听到旁边的同事说除了 CS 受影响，哥斯拉也受
到这个漏洞影响，我下意识的以为这是一个通用的 JDK 的利用链。所以最开始的很长一段时
间我都是直接在 JDK 中调试的，完全忽略了 CobatStrike 本身，虽然走了很多弯路，但是还
是积累了一些基本的方法。 
在第一步复现的时候，就遇到了问题。跟着大佬的思路，object 标签会自动调用对应的
setXXX 方法，如图 2.1 所示。但是我直接拷贝的大佬的代码，但是我无论如何都进不去 setText
方法，难道我连最基本的原理都理解错了？ 
图 2.1 原文中对 setXXX 方法的简单利用 
后来仔细调试之后才发现这里的单词写错了，不是 parame，而是 param。然后看到了
这样的截图，如图 2.2 所示。大佬套路深，我要回农村。 
图 2.2 大佬的套路 
按照文章中给的思路要找到利用链，需要满足四个条件。 
1）classid 传入需要实例化的类，类必须继承与 Component 
2）必须有无参构造方法，貌似是因为 newinstant 是调用的无参构造方法 
3）必须存在一个 setXXX 方法的 XXX 属性 
4）setXXX 方法的传参数必须是接受一个 string 类型的参数 
我们不可能人工来发现满足条件的类和方法，可以直接通过 idea 发现所有继承自
Component 的类，保存类名，并通过反射的方式来筛选满足其他条件的所有的类和方法。 
从 JDK 中发现所有继承自 Component 接口的类，如图 2.3 所示。 
图 2.3JDK 中继承自 Component 类的类 
这些类只是满足了条件 1，把所有继承自 Component 类的类道出保存成文件。但是要
满足其他条件，还需要继续对这些类进行筛选。为了更方便的找出满足条件的类和方法，我
写了一个自动化遍历的代码，其主要功能是读取刚才保存的继承自 Component 类信息的文
件，然后通过反射的方式来判断类是否满足其他几个条件，如图 2.4 所示。其中 classFullName
代表需要便利的完整的类名，主要是通过正则的方式从文件中读取，限于篇幅有限，就不展
示了，过程中主要的步骤我都以注释的方式解释代码。 
图 2.4 自动化便利筛选满足条件的类 
按照这种方式我们很容易就找到了很多满足条件的类，如图 2.5 所示。总计大概有 160
个。 
图 2.5 在 JDK 中筛选的满足条件的类及对应的方法 
但是按照这种方式筛选的满足条件的方法最终的数据量还是很大，筛选到的方法中有大
量无用的方法，比如 setName、setLabel、setToolTipText、setAsText 等。这些方法都很简单，
一般只是对应 swing 最终界面展示内容的功能，我们先暂时不考虑这些功能。所以我们对上
面的代码进行了改进，增加黑名单方法，如图 2.6 所示。 
图 2.6 增加黑名单方法 
按照这种方式筛选之后 JDK 中可能满足的方法就只剩下 19 个，如图 2.7 所示。 
图 2.7 筛选之后 JDK 中可疑的 19 个方法 
这些方法都需要进行人工研判，其中最能吸引人眼球的是 setDocumentBase 方法，这
种方法名总是给人一种像是 JNDI 注入设置路径的感觉，但是实际测试来看根本就不会调用
这个方法，因为 documentBase 属性不是 writeMethod，而仅仅是一个 readMethod。在
ObjectView 类中也明确要求，满足条件的属性必须是 writeable，而这应该也算是第 5 个条
件吧，如图 2.8 所示。 
图 2.8 判断属性是否是属于 Writeable property 
又对其他的方法依次都进行了查看，总归是没有找到哪一个方法能导致命令执行。 
0x03 峰转 
在我还在对着 JDK 的源码死磕的时候，看到朋友圈里面二哥发了一张利用 object 标签
执行命令的图，然后问了一下二哥”是不是 setContentType”，因为站在我当时的角度，只
有 setContentType 里面有较复杂的逻辑，设计到了动态类加载的过程。但是二哥回复说“不
是，不要看 JDK 的，可以看看 CS 的类”。 
这时候我才突然醒悟过来，这个漏洞虽然说影响了 CobaltStrike 和哥斯拉，但是实际上
大佬们在平时一直都是说这是一个 CS RCE 漏洞，并没有人说这是 JDK SWING 的 RCE。实际
上 CobaltStrike 和哥斯拉的利用链根本就不通用，第一次觉得自己浅薄了。 
赶紧把好久不用的 CS 掏出来，然后把对应的 jar 包加入 liabrary。按照之前的方式来自
动化发现可能利用的方法，结果如图 3.1 所示。 
图 3.1 在 CS 的 jar 包中发现的可能被利用的方法 
按照这种方式，确实找到一些新的可能利用的方法，依次对方法进行筛选之后之后，最
终我确定这里面可能利用的方法只可能是两个 setTeamServerAlias 和 setURI。只有这两个方
法中有比较复杂的代码逻辑，并且涉及到了动态类加载相关的代码，但是在实际 debug 的
时候发现 CS 的所有的类断点都只能下在方法名，不能把断点下载方法体里面，并且跟踪到
方法名之后 F7 也不能进入方法体。相当于我们调试只能到方法名，不能到方法体调试，这
是一件很痛苦的事情，如图 3.2 所示。 
图 3.2 在方法体中的断点式无法进入的 
后来问了一个大佬，大佬告诉我说 CS 的 class 文件为了反调试都去掉了行号，没有行
号之后就不能在方法体内部进行调试，只能调试到方法名。而且这种机制并没有什么好的办
法解决。 
Java 的代码都是很复杂的，内部逻辑很多，如果不能有效的调试，特别是涉及到内部还
有多线程并发的操作，就会显得尤其痛苦。因为一些其他的事情，本来好多天都没有看这个