title:IntScope: Automatically Detecting Integer Overflow Vulnerability in
X86 Binary Using Symbolic Execution
author:Tielei Wang and
Tao Wei and
Zhiqiang Lin and
Wei Zou
IntScope: Automatically Detecting Integer Overﬂow Vulnerability in X86 Binary
Using Symbolic Execution
Tielei Wang†, Tao Wei†∗, Zhiqiang Lin‡, Wei Zou†
†Key Laboratory of Network and Software Security Assurance
Institute of Computer Science and Technology, Peking University
{wangtielei, weitao, zouwei}@icst.pku.edu.cn
‡Department of Computer Science
Purdue University
PI:EMAIL
Abstract
The number of identiﬁed integer overﬂow vulnerabilities
has been increasing rapidly in recent years. In this paper,
we present a system, IntScope, which can automatically de-
tect integer overﬂow vulnerabilities in x86 binaries before
an attacker does, with the goal of ﬁnally eliminating the vul-
nerabilities. IntScope ﬁrst translates the disassembled code
into our own intermediate representation (IR), and then per-
forms a path sensitive data ﬂow analysis on the IR by lever-
aging symbolic execution and taint analysis to identify the
vulnerable point of integer overﬂow. Compared with other
approaches, IntScope does not run the binary directly, and
is scalable to large software as it can just symbolically ex-
ecute the interesting program paths. Experimental results
show IntScope is quite encouraging: it has detected more
than 20 zero-day integer overﬂows (e.g., CVE-2008-4201,
FrSIRT/ADV-2008-2919) in widely-used software such as
QEMU, Xen and Xine.
1. Introduction
Primitive types, including integers, typically have a ﬁxed
size (e.g., 32 bits) for a particular machine architecture.
Thus, variables of these types have a maximum value (e.g.,
232). Operations that result in a value greater than this max-
imum can cause the value to wrap-around: this well-known
condition is called overﬂow. Integer overﬂows are particu-
larly insidious: while the overﬂow itself is usually not ex-
ploitable, it often leads to other classes of vulnerabilities, in-
cluding stack and heap overﬂows.
Recently, the number of identiﬁed integer overﬂow vul-
nerabilities has been increasing rapidly, as shown in Table 1.
From 2000 to 2007, almost every year, 1.5 times more integer
overﬂows are recorded by National Vulnerability Database
∗Corresponding author
(NVD [16]). Moreover, nearly 60% (219/364) of these vul-
nerabilities have the highest severity (with score 7 −10) [16].
According to the 2006 CVE report [5], integer overﬂows rose
to the second most common vulnerability in the advisories
from operating system vendors. Furthermore, in the last 3
years, we have witnessed a number of integer overﬂow at-
tacks, such as 0-day exploits against Adobe PDF [27], Flash
[13], and the Microsoft WebViewFolderIcon ActiveX control
[26].
Year
Num
2000
1
2001
2
2002
5
2003
29
2004
40
2005
66
2006
96
2007
125
Table 1. The reported number of integer over-
ﬂows in NVD from 2000 to 2007.
It is important to identify integer overﬂows before an at-
tacker does. Given program source code, there are several
techniques and tools (e.g., RICH [32], EXE [36], KLEE
[35]) that can perform static analysis or model checking to
detect integer overﬂows. However, as source code is not al-
ways available to end users, the state-of-the-art techniques
have to rely on dynamically running the software, exploring
program paths (e.g., SAGE [44]), and generating test cases,
to show the existence of a vulnerability. Such fuzzing tech-
niques have been commonly used by underground attackers.
However, to the best of our knowledge, none of the binary-
based fuzz techniques (including SAGE [44]) focus speciﬁ-
cally on integer overﬂows; and even if the fuzzing tool could
explore all program paths, the vulnerability is still invisible
if the fuzzing tool does not generate a desired input.
In this paper, we present a systematic static binary anal-
ysis based approach to particularly focus on detecting inte-
ger overﬂow vulnerabilities when given only a binary, with
the goal of ﬁnally eliminating the vulnerabilities. Based on
the observation that most known integer overﬂow vulnerabil-
ities are caused by incomplete or improper input validation,
we apply symbolic execution and data ﬂow analysis (i.e.,
taint analysis) techniques to automatically detect the program
paths which lack proper input validation. Our approach is
static in the sense that it does not run the software directly
in a real environment, and instead it relies on a symbolic ex-
ecution engine we developed to scan the program paths and
identify integer overﬂows.
The key ideas of our approach are (1) symbolically exe-
cuting the x86 binary on an SSA-like [28] intermediate rep-
resentation; (2) using taint analysis, not only tracking the
propagation of taint property, but also modeling accurate
bounds of each tainted piece of data via symbolic execution;
and (3) using a lazy checking, i.e., instead of checking each
arithmetic operation, our approach only checks whether the
tainted symbolic value used in sensitive points (e.g., mem-
ory allocation functions malloc, alloca) could overﬂow
under path constraints. In short, our approach only reports
a potential integer overﬂow vulnerability if the tainted sym-
bolic value used in sensitive points could overﬂow.
We have implemented our system called IntScope. To en-
able our analysis, we ﬁrst use IDA Pro [12], a Windows and
Linux hosted multi-processor disassembler and debugger, to
disassemble an executable, and then we translate the disas-
sembled ﬁle into our own intermediate code, PANDA (Pro-
gram ANalysis Dedicated to ASM), on which our analysis
is performed.
IntScope handles both Windows and Linux
x86 binaries. We have evaluated it with a number of real-
world programs from Microsoft Windows and Linux plat-
form, and we have reached very encouraging experimen-
tal results:
IntScope not only successfully detects all the
known integer overﬂow bugs, but also identiﬁes more than 20
new integer overﬂow vulnerabilities (e.g., CVE-2008-4201,
FrSIRT/ADV-2008-2919) in widely used applications, such
as QEMU [18], Xen [20], Xine [25], Mplayer [15], and VLC
[23]. All of the new vulnerabilities (i.e., the 0-day ones)
have been conﬁrmed by our dynamic testing tool [46] and/or
the developers. In addition, after we reported our results to
the developers, some projects have already released patches
(e.g., Xine [25], MPD [14], Hamsterdb [11], Faad2 [7]).
Our contributions include:
• We propose a systematic method of combining taint
analysis and path-sensitive symbolic execution to
speciﬁcally detect integer overﬂow vulnerabilities in ex-
ecutables.
• We devise an intermediate instruction representation,
based on IDA Pro’s disassembled code, and a symbolic
execution engine.
• We implement a prototype called IntScope and use it to
analyze real-world binaries. Experimental results show
that our approach is highly effective and is able to detect
0-day integer overﬂow vulnerabilities.
2 Problem Statement
In this section, we ﬁrst describe the common features of
integer overﬂow vulnerabilities, and then discuss the chal-
lenges in binary level integer overﬂow detection and describe
the problem scope of this paper.
2.1 Features of Integer Overﬂow
We have conducted more than 200 integer overﬂow case
studies, and we found that integer overﬂow vulnerabilities
usually have the following features:
I. Untrusted source – For most arithmetic operations
where integer overﬂow occurs, there is an operand which is
arithmetically derived from some tainted data. Tainted data is
derived from untrusted input sources like network messages,
input ﬁles, or command line options. There are several typi-
cal source functions such as read, fread and recv which
could introduce tainted data.
II. Various types of sinks – Whether or not an integer
overﬂow is harmful depends on where and how the program
uses the overﬂowed value. It is very dangerous when an over-
ﬂowed value is used in some sensitive points, since it may
lead to other vulnerabilities. These sensitive points are called
sinks. Particularly, from our case studies, we found the sinks
for integer overﬂows are usually these points:
• Memory allocation: The overﬂowed value is used in
memory allocation functions (e.g., malloc, alloca)
as a size argument, and it usually results in an insufﬁ-
cient memory allocation, which may eventually become
an attacker’s springboard to a buffer overﬂow.
• Memory access: The overﬂowed value is used as an ar-
ray index or a pointer offset, which may cause arbitrary
bytes memory overwritten or read (e.g., an information
leakage attack).
• Branch statement: The overﬂowed value is used in a
branch statement, and the branch statement is not de-
signed to catch the integer overﬂow.
It could lead to
a bypass of security checks (e.g., one of the cases in
non-control-data attack [38]) or result in an undesirable
execution.
• Other program-dependent sensitive points: There
may be other program-dependent sensitive points which
could be affected by the overﬂowed values. For in-
stance, in the integer overﬂow vulnerability in NetBSD
(CVE-2002-1490), its overﬂowed value is used as a
structure reference counter, which causes a shared ob-
ject (still in use) to be freed prematurely.
III. Incomplete or improper sanitization checks – Not
all the tainted data can lead to integer overﬂows, because
tainted values could be safely used in a program after care-
ful checks. However, almost all the subtle integer overﬂow
vulnerabilities are actually caused by incomplete or improper
checks.
in real-world software is too large (even inﬁnite) to ex-
plore all paths. Although there are several methods to
reduce the path explosion problem, such as the use of
function summaries [45], it is still a major challenge.
2.2 Challenges
2.3 Problem Scope
As we aim to detect integer overﬂow vulnerabilities di-
rectly in x86 binaries without executing the program, there
are a number of challenges to overcome.
• Lack of type information: Type information is usually
not available in executables, and the only real informa-
tion enforced is the operand size (i.e., 8, 16, 32, and
64 bit) in x86 instructions. Consider the instruction se-
quence:
mov eax, 0xffffffff;//eax = 0xffffffff
add eax, 2;
//eax = 0xffffffff+0x2
we cannot determine whether 0xffffffff+0x2 is
an integer overﬂow;
if 0xffffffff is interpreted
as an int type value, 0xffffffff+0x2 is equiva-
lent to -1+2, which is a normal addition operation; if
0xffffffff is interpreted as an unsigned int,
0xffffffff+0x2 will certainly overﬂow. Since we
are dealing with integer overﬂows, we have to recover
all the possible use of integers in binary code, and make
our analysis speciﬁcally focus on the data ﬂow of these
integers.
• Differentiating benign integer overﬂow: Even if we
could recover type information, we still need to deal
with benign integer overﬂow operations (i.e., harmless
integer overﬂows). Benign integer overﬂow operations
do exist in binary code. Programmers (even compilers)
may use integer overﬂows deliberately. For example, if
x is an int type variable, the statement if(x >= -2
&& x<= 0x7ffffffd) will be translated into such
a piece of assembly code by GCC-4.2.0 compiler:
mov eax, x; // eax = x
add eax, 2; // eax = eax+2
js target
In this case, a large x such as 0x7fffffff causes an
overﬂow in above add instruction, but it is harmless as
GCC actually uses this overﬂow to reduce a compari-
son instruction. We cannot treat benign integer over-
ﬂow operations as vulnerabilities, and hence we have to
differentiate benign integer overﬂows.
• Path explosion: As integer overﬂows are mainly
caused by incomplete or improper sanitization checks,
we need to analyze program paths to determine the ex-
istence of sanitization checks, and then to further iden-
tify the incomplete or improper checks. Therefore, our
analysis is path sensitive. However, the number of paths
Integer overﬂows are one type of integer related bugs.
There are other types of integer bugs, such as assignment
truncation, integer underﬂow, and signedness errors [32]. In
this paper, we focus on the ﬁrst type of integer bugs, namely,
integer overﬂows, which amount to nearly 70% of all the in-
teger bugs in the study conducted by Brumley et al. [32]. We
leave other types as future work.
3 System Design
In this section, we ﬁrst give an overview of IntScope and
then describe its detailed design.
3.1 System Overview
The intuition behind our approach is that most integer
overﬂow vulnerabilities are caused by the misuse of over-
ﬂowed values in sinks (e.g., memory allocation functions).
Thus, we track the propagation of tainted data, collect path
constraints on tainted data, and check whether a path has suf-
ﬁcient checks to prevent integer overﬂows when tainted val-
ues are used in sinks.
Instead of checking whether each arithmetic operation
could overﬂow, we only check the tainted value used in sinks.
We call it “lazy checking”. Lazy checking can help differen-
tiate real integer overﬂow bugs from benign ones, and also
reduce the number of checks. Another advantage of lazy
checking is that most sinks mentioned in Section 2 have al-
ready provided some hints on the type inference.
Unlike traditional static analysis, our approach only an-
alyzes certain parts of a program to alleviate the path ex-
plosion problem. Most integer overﬂow vulnerabilities have
a prominent feature, i.e., tainted data are introduced by a
source function (e.g., fread, recv) and ﬂow into a sink
function (e.g., malloc, alloca). Hence, our approach
only analyzes those program paths which pass through a
source function and reach a sink function.
At a high level, IntScope takes an executable ﬁle as input
and outputs the suspicious paths, along which some over-
ﬂowed variables are used in sinks. Figure 1 shows the ar-
chitecture of IntScope. Given a binary program Pto be ana-
lyzed, IntScope works as follows:
• Pre-processing the program. IntScope ﬁrst uses our
Decompiler, which translates Pinto an SSA-like inter-
mediate representation called PANDA [51]. The De-
compiler also builds control ﬂow graphs (CFG) G of
'HFRPSLOHU
,QWHJHU2YHUIORZ&KHFNHU
([HFXWDEOH
&RPSRQHQW([WUDFWRU
3URILOH&RQVWUXFWRU
3DWK9DOLGDWRU
6\PEROLF([HFXWLRQ(QJLQH
6\PEROLF0HPRU\
(QYLURQPHQW
6XVSLFLRXV
3DWKV
3UHSURFHVV3URFHGXUH
'HWHFWLRQ3URFHGXUH
Figure 1. An Overview of IntScope.
functions in Pand a call graph (CG) Cof P. To allevi-
ate path explosion, our Component Extractor and Pro-
ﬁle Constructor are used to compute the “chop” graphs
G’ of P. G’ includes those program paths which pass
through a source function and reach a sink function.
The output of this procedure is the “chop” graphs G’.
• Detecting integer overﬂows.
In this procedure,
IntScope traversals G’ using a depth-ﬁrst search.
It
maintains a symbolic memory environment, and sym-
bolically executes the x86 binary on our PANDA repre-
sentation. At the same time, IntScope tracks the prop-
agation of tainted data. At each branch point, IntScope
uses the Path Validator to check which branch is fea-
sible under current path constraints. If both branches
are feasible, IntScope will fork an additional execution
and simulate each branch. At each sink (e.g., malloc,
alloca) where a tainted value is used, the Integer
Overﬂow Checker will enforce a constraint check on
that value. Once the tainted value could overﬂow,
IntScope outputs the path as a suspicious one.
3.2 Detailed Design
In this section, we describe the detailed design of
IntScope. We ﬁrst present the design of our PANDA inter-
mediate representation in Section 3.2.1 and discuss how to
compute the chop graphs of a program in Section 3.2.2. In
Section 3.2.3 and Section 3.2.4, we introduce the design of
the symbolic memory environment and execution strategies.
Finally, we describe our lazy checking in Section 3.2.5.
3.2.1 The Design of PANDA
It is a signiﬁcant challenge to directly analyze x86 instruc-
tions as the x86 instruction set is very complex.
It has
hundreds of instructions (many with side-effects), and there
is no notion of variables in executables. Further, tainted data
can be propagated between registers and memory locations.
For example, after executing the following instructions:
mov [esp+4], eax // [esp+4] = eax
push 0
mov ebx, [esp+8] // ebx = [esp+8]
ebx is actually assigned eax; if eax is tainted, so is ebx.
However, we cannot retrieve such information unless we can
infer the two symbolic address esp+4 and esp+8 are actu-
ally referring to the same memory location.
Inspired by recent work such as Vine [22], Boomerang
[40], and DIVINE [31], we devise an SSA-like IR, named