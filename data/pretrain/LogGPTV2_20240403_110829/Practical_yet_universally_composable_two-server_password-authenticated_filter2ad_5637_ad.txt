2 â†R Zq and encrypt password shares under the
2). En-
1 â†
2 â†
Choose s(cid:48)
1, s(cid:48)
1 â† encPK (p(cid:48)
CRS as C(cid:48)
crypt the shares and randomness for both servers as F (cid:48)
2, PK u)) and F (cid:48)
1, s(cid:48)
enc2PE 1 ((p(cid:48)
enc2PE 2 ((p(cid:48)
2, s(cid:48)
2, PK u)).
1, C(cid:48)
1, C(cid:48)
2 â† encPK (p(cid:48)
1, C(cid:48)
1, C(cid:48)
(d) Send encryptions to servers: Send (F (cid:48)
1), C(cid:48)
1);âˆ—; (sid , qid(cid:48), C(cid:48)
2);âˆ—; (sid , qid(cid:48), C(cid:48)
2, PK u) to S1
1; s(cid:48)
2; s(cid:48)
and (F (cid:48)
2, C(cid:48)
1, C(cid:48)
2, PK u) to S2.
531U(cid:48)
R1
R7
(F (cid:48)
(F (cid:48)
1, C(cid:48)
2, C(cid:48)
1, C(cid:48)
1, C(cid:48)
2, PK u)
2, PK u)
-
1, ËœC(cid:48)
2, sigSS 1
( ËœC(cid:48)


(sid , qid(cid:48), C(cid:48)
1, C(cid:48)
2, PK u, ËœC(cid:48)
1, ËœC(cid:48)
2))
S1
R2
R4
R6
Ï€1, (pk , E1, sigSS 1

Ï€3, Ï€4, ËœC(cid:48)
1

(sid, qid(cid:48), C(cid:48)
1, C(cid:48)
Ï€2, (E, sigSS 2
2, PK u, E1, pk ))
(sid, qid(cid:48), C(cid:48)
1, C(cid:48)
2, PK u, E))
S2
-
- R3
(sid, qid(cid:48), C(cid:48)
1, C(cid:48)
2, PK u, ËœC(cid:48)
-
Ï€5, ËœC(cid:48)
1, ËœC(cid:48)
2))
2
R5
( ËœC(cid:48)
1, ËœC(cid:48)
2, sigSS 2
Figure 5: Communication messages of the Retrieve protocol with computation steps Ri. In this picture, zero-knowledge proofs are
assumed to be non-interactive and thus denoted simply as sending the value Ï€; however, depending on their instantiation, they might
be interactive protocols.
Step R2: The ï¬rst server S1 proceeds as follows.
(a) Receive message from user, fail if account doesnâ€™t exist: Parse
the message received from U(cid:48) as (Rtr, sid , qid(cid:48), 1, F (cid:48)
1, C(cid:48)
2,
PK u). If no entry st 1[sid ] exists in the state information then
fail, else recover st 1[sid ] = (PS 2, p1, K1, s1, Ëœs1, C1, ËœC1, C2,
ËœC2).
1, C(cid:48)
(b) Ask environment for permission to continue: Output (RNot,
sid , qid(cid:48)) to the environment and wait for an input (Perm, sid ,
qid(cid:48), a) with a âˆˆ {allow, deny}. If a = deny then fail.
(c) Decrypt share and randomness: Decrypt F (cid:48)
1 with label (sid ,
qid(cid:48), C(cid:48)
1, C(cid:48)
2, PK u), which will fail if the label is wrong.
(d) Verify correct encryption of share under CRS: Check that C(cid:48)
1 =
encPK (p(cid:48)
1; s(cid:48)
1).
(e) Generate key pair for homomorphic encryption scheme and en-
crypt sharesâ€™ quotient: Generate (pk , sk ) â† keyg(1k), choose
r1 â†R Zq, and compute E1 â† encpk (p1/p(cid:48)
1; r1).
(f) Send signed encrypted quotient to second server: Compute the
2, PK u, E1, pk ) and
(sid , qid(cid:48), C(cid:48)
1, C(cid:48)
signature Ïƒ(cid:48)
send (pk , E1, Ïƒ(cid:48)
1 â† sigSS 1
1) to S2.
(g) Prove to second server that E1 is correct: Perform the follow-
ing proof protocol with S2:
Ï€1 := ZK{(p1, p
(cid:48)
1, s1, s
(cid:48)
1, r1) : E1 = encpk (p1/p
âˆ§ C1 = encPK (p1; s1) âˆ§ C
(cid:48)
1 = encPK (p
1)} .
(cid:48)
(cid:48)
1; r1)
(cid:48)
1; s
Step R3: The second server S2 proceeds as follows.
(a) Receive message from user, fail if account doesnâ€™t exist: Parse
the message received from U(cid:48) as (Rtr, sid , qid(cid:48), 1, F (cid:48)
1, C(cid:48)
2,
PK u). If no entry st 2[sid ] exists in the saved state then fail,
else recover st 2[sid ] = (PS 1, p2, K2, s2, Ëœs2, C1, ËœC1, C2, ËœC2).
2, C(cid:48)
(b) Ask environment for permission to continue: Output (RNot,
sid , qid(cid:48)) to the environment and wait for an input (Perm, sid ,
qid(cid:48), a) with a âˆˆ {allow, deny}. If a = deny then fail.
(c) Receive message from ï¬rst server and check proof: Parse the
1). Further-
message from S1 as (Rtr, sid , qid(cid:48), 2, pk , E1, Ïƒ(cid:48)
more interact in the proof Ï€1 with S1.
(d) Decrypt password share and randomness: Decrypt F (cid:48)
2 with la-
bel (sid , qid(cid:48), C(cid:48)
1, C(cid:48)
2, PK u) and fail if decryption fails.
(e) Verify share encryption under CRS and ï¬rst serverâ€™s signa-
2) and that verPS 1 ((sid ,
2 = encPK (p(cid:48)
ture: Check that C(cid:48)
qid(cid:48), C(cid:48)
1, C(cid:48)
2, PK u, E1, pk ), Ïƒ(cid:48)
2; s(cid:48)
1) = 1.
(f) Multiply encryption by quotient of own shares: Choose random
2; r2) and E â†
r2, z â†R Zq and compute E2 â† encpk (p2/p(cid:48)
(E1 Ã— E2)z.
(g) Send signed encrypted quotient to ï¬rst server: Compute Ïƒ(cid:48)
2) to S1.
2, PK u, E) and send (E, Ïƒ(cid:48)
(sid , qid(cid:48), C(cid:48)
1, C(cid:48)
sigSS 2
2 â†
(h) Prove to ï¬rst server that E is correct: Perform with S1 the
proof protocol:
Ï€2 := ZK{(p2, p
(cid:48)
2, s2, s
(cid:48)
2, r2, z) :
E = (E1 Ã— encpk (p
(cid:48)
2/p2; r2))z
âˆ§ C2 = encPK (p2; s2) âˆ§ C
(cid:48)
2 = encPK (p
(cid:48)
2; s
2)} .
(cid:48)
Step R4: The ï¬rst server S1 proceeds as follows.
(a) Receive message from second server and verify proof: Parse
the message from S2 as (E, Ïƒ(cid:48)
2) and interact with S2 in Ï€2.
(b) Verify signature and check z (cid:54)= 0: Verify that verPS 2 ((sid ,
qid(cid:48), C(cid:48)
1, C(cid:48)
2, PK u, E), Ïƒ(cid:48)
2) = 1 and that E (cid:54)= encpk (1; 0).
(c) Learn whether password matches: Decrypt E using sk and
verify that it decrypts to 1.
(d) Inform and convince second server of result: Prove to S2 that
E indeed decrypts to 1 with the protocol:
Ï€3 := ZK{(sk ) : 1 = decsk (E)}.
(e) Veriï¬ably encrypt key share for the user: Compute ciphertext
1 to S2.
1 encrypts the same key share as ËœC1 from
1 â†R Zq and send ËœC(cid:48)
1 â† encPK u (K1; Ëœs(cid:48)
ËœC(cid:48)
Prove to S2 that ËœC(cid:48)
the setup phase:
1) with Ëœs(cid:48)
1) : ËœC1 = encPK (K1; Ëœs1) âˆ§
Ï€4 := ZK{(K1, Ëœs1, Ëœs
(cid:48)
1)}.
(cid:48)
(cid:48)
1 = encPK u (K1; Ëœs
ËœC
Step R5: The second server S2 proceeds as follows.
(a) Receive message from ï¬rst server and verify proof: Parse the
1 and participate in proofs Ï€3 and Ï€4
message from S1 as ËœC(cid:48)
with S1.
532(b) Veriï¬ably encrypt key share for the user: Compute ciphertext
2 to S1.
2 encrypts the same key share as ËœC2 from
2 â†R Zq and send ËœC(cid:48)
2 â† encPK u (K2; Ëœs(cid:48)
ËœC(cid:48)
Prove to S1 that ËœC(cid:48)
the setup phase:
2) with Ëœs(cid:48)
Ï€5 := ZK{(K2, Ëœs2, Ëœs
2) : ËœC2 = encPK (K2; Ëœs2) âˆ§
(cid:48)
2)} .
(cid:48)
(cid:48)
2 = encPK u (K2; Ëœs
(c) Send signed result to user and ï¬nish protocol: Compute Ï„(cid:48)
1, ËœC(cid:48)
1, ËœC(cid:48)
2, PK u, ËœC(cid:48)
sigSS 2
to U(cid:48). Output (Rtr, sid , qid(cid:48), succ).
2) and send ( ËœC(cid:48)
(sid , qid(cid:48), C(cid:48)
1, C(cid:48)
ËœC
2 â†
2, ËœÏ„(cid:48)
2)
Step R6: The ï¬rst server S1 proceeds as follows.
(a) Receive message from second server and verify proofs: Parse
the message from S2 as ËœC(cid:48)
2 and interact with it in Ï€5.
1, C(cid:48)
(sid , qid(cid:48), C(cid:48)
(b) Send signed result to user and ï¬nish protocol: Compute Ï„(cid:48)
1, ËœC(cid:48)
1, ËœC(cid:48)
2, PK u, ËœC(cid:48)
sigSS 1
to U(cid:48). Output (Rtr, sid , qid(cid:48), succ).
Step R7: The user U(cid:48) proceeds as follows.
(a) Receive messages from both servers: Parse the messages from
2) and send ( ËœC(cid:48)
1 â†
2, Ï„(cid:48)
1)
S1 and S2 as ( ËœC(cid:48)
1, ËœC(cid:48)
2, Ï„(cid:48)
1) and ( ËœC(cid:48)
1, ËœC(cid:48)
2, Ï„(cid:48)
2), respectively.
(b) Check that both servers agree and verify signatures: Check