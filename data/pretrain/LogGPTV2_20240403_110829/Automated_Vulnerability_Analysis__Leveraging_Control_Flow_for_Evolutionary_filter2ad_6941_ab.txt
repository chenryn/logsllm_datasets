E 
.5 
I 
1 
.25
B
1
D
.33
H
1
M
.67
G
.8
.2
L
.1 
F 
.4 
J 
1 
N 
.6
K
Figure  2. Markov  probabilities  associated  with 
state  transitions  on  a  control  flow  graph.    The 
white  and  black  squares  represent  nodes  on  a 
control flow path from a given source node (A) to a 
destination node (M).  The grey squares represent 
reject  nodes  (nodes  from  which  it  is  no  longer 
possible  to  reach  the  destination  node  (M)  ).  The 
black  squares  represent  the  path  taken  by  an 
arbitrary input through the control flow logic.  This 
path 
transitions 
A→C→E→D→G→M.    We can  calculate  the fitness 
of  this  input  by  multiplying  the  edge  transition 
probabilities:   
consists 
node 
of 
Fitness = 1 / (.75 × .9 × .5 × .67 × .8) = 5.525 
1
Fitness  ∏=
x
)(
ip
l
     Where l is the length of the execution path for input 
x on the control flow graph, and pi corresponds to the 
estimated  probability  of  taking  edge  i  in  the  control 
flow graph.  Because our fitness function depends on 
the  behavior  of  all  of  the  other  genomes  in  a 
generation, it is necessary to compute the fitness value 
for a particular generation of genomes, we first find the 
execution path for all members of the population and 
update the transition probabilities of the Markov chain.  
We  then  find  the  probability  of  each  genome’s 
execution  path  using  the  updated  dynamic  Markov 
model. 
     Because  the  genetic  algorithm  is  attempting  to 
create  strings  that  will  follow  the  least  probable 
479479
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:40:16 UTC from IEEE Xplore.  Restrictions apply. 
that 
that 
input 
represent 
  This  will  reward  those  genomes 
that 
execution paths, it will bias our sampling.  While this 
may at first seem to be a disadvantage, it is actually an 
advantage.  The resulting fitness function calculation is 
actually  the  probability  the  genetic  algorithm  has 
produced  a  string  which  followed  a  given  execution 
path. 
in  the 
population 
takes 
previously unexplored execution paths as well as rare 
(i.e. difficult) execution paths.  
2.3. Grammatical Evolution 
     Grammatical evolution is a special type  of genetic 
algorithm  that  can  evolve  strings  in  an  arbitrary 
context-free 
than  directly 
encoding the resulting string in its genome, the genome 
encodes  production  rules  to  produce  a  string  from  a 
specified  context-free  grammar.    Each  genome  is  a 
variable  length  integer  string.   The algorithm  used  to 
produce a string from the grammar using a genome is 
summarized  in  Figure  3.    Figure  4  illustrates  the 
construction of a genome from a context-free grammar 
via grammatical evolution. 
language  [2]. 
  Rather 
while ( nonterminals in the string ) 
{ 
     find first nonterminal 
     numRules = number of production   
                rules for the  
                nonterminal 
     i = next integer in the genome %  
         numRules 
     apply production rule i 
} 
Figure 3. Pseudocode for grammatical evolution. 
following 
    Because the  input  space  for  the  program  represents 
the  search  space  for  our  program,  its  combinatorial 
nature makes blindly generating variable length binary 
input  in  a  linear  genome  (as  is  usual  in  genetic 
algorithms)  inefficient.    Rather  than  using  the  usual 
representation,  our  genomes  represent  instructions  for 
building  the  input  from  a  user-specified  context-free 
grammar, 
the  Grammatical  Evolution 
paradigm.    This  not  only  gives  the  user  the  ability  to 
narrow  the  search  space  based  on  knowledge  of  their 
specific application, it also gives the genetic algorithm 
flexibility  to  represent  input  with  similar  structural 
characteristics  as  being  more  nearly  adjacent  in  the 
search space  (e.g. Creating matching HTML tags in a 
variable 
length  linear  genome  would  require  four  insertion 
mutations for each bracket character and one mutation 
for  the  slash  character that  all  happen to  occur in the 
right  position,  but  with 
the  correct  grammar, 
grammatical evolution would require just one insertion 
480480
mutation that added the tag generation production rule 
to the genome). 
2
m 
AB 
e 
| 
| 
| 
1 
xBx 
0
sAs 
bBb 
aAa 
C 
| 
|  B 
|  C 
| 
d 
S  (cid:198) 
A  (cid:198) 
B  (cid:198) 
C  (cid:198) 
      1           0               0                    
S  (cid:198)  xBx  (cid:198) xaAax  (cid:198)  xabBbax   
     1                  1 
    (cid:198)  xabCbax (cid:198) xabdbax 
the  sequence  of 
Figure  4. Construction  of  a  genome from a context-
free  grammar.    Construction  begins  with  the  initial 
rule  S.    The  application  of  production  rule  S[1] 
results in the new string xBx.  The nonterminal B is 
then  replaced  by  B[0]  to  produce  the  string  xaAax.  
Application  of  production  rules  continues  in  the 
order  of  A[0], 
  B[1],  C[1]  until  there  are  no 
nonterminals  remaining  in  the  string.  The  final 
genome  consists  of 
rule 
applications  {S,  B[0],  A[0],    B[1],    C[1]}.    Thus,  the 
genome is a sequence of rule applications that forms 
a “set of instructions” for how an input string should 
be built.
 3. Implementation 
     In  order  to  implement  our  approach  as  a  practical 
tool, we needed to address several requirements: 
Disassembly  And  Control  Flow  Graph  Extraction: 
The  control  flow  graph  used  in  our  methodology  is 
actually a subgraph of the overall program control flow 
graph.  It consists of all basic blocks on a path between 
an 
input  block  and  a  desired  acceptance  (i.e. 
destination) block.  All edges leading to blocks off this 
subgraph are assigned to a special rejection set.  
Custom Debugger: We use a debugger for lightweight 
basic  block  level  binary  instrumentation.    This  is 
necessary  for  us  to  track  the  runtime  execution  path 
and  gather  the  statistics  necessary  for  the  genetic 
algorithm  to  rate  the  fitness  of  individual  inputs.  
Specifically, we set breakpoints in the test application 
on  the  entry  points  of  all  nodes  in  the  control  flow 
subgraph  and  rejection  set.    We  then  run  the  test 
application  successively  on  a  randomly  supplied 
population  of  inputs.    In  the  breakpoint  handler,  we 
track  the  execution  path  up  to  the  point  where  the 
execution  path  reaches  a  rejection  node  (i.e.  the 
destination is no longer reachable along all subsequent 
execution  paths)  or  terminates  in  success.    At  this 
point,  we  calculate 
input 
probabilistically  using 
the  previously  discussed 
Markov  Chain  heuristic.  The  fittest  individuals  are 
fitness 
the 
the 
for 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:40:16 UTC from IEEE Xplore.  Restrictions apply. 
mated to form the next generation of test inputs.  This 
process  of  input  injection,  execution  path  tracking, 
fitness  evaluation, and  mating continues  until either  a 
maximum  number  of  generations  are  reached  or  the 
application  has  been  forced  into  the  acceptance  state.  
Figure 5 provides pseudocode for our algorithm. 
GA  -  We  implemented  the  genetic  algorithm  in 
Python.    The  genomes  are  variable  length  integer 
strings,  which  we  convert  into  input  strings  using 
grammatical evolution.  We use single point crossover; 
elitism; and insertion, deletion, and point mutations.  If 
progress  in  the  control  flow  graph  stagnates,  the 
mutation  rate  dynamically 
increases  until  further 
progress is made.  
     We chose to use the PAIMEI framework because it 
provided most of the basic components we needed (e.g. 
scriptable  debugging  and  support  for  control  flow 
graph  extraction)  [14].   PAIMEI  is  written in  Python 
and  exposes  functionality  that includes  a  debugger,  a 
graph based binary abstraction, and a set of utilities for 
accomplishing  repetitive  tasks.  Python  was  also  an 
ideal language for implementing the genetic algorithm, 
since  it  provides  extensive  built-in  support  for  string 
manipulation.    PAIMEI  has  been  used  by  software 
security  researchers  for  a  wide  range  of  static  and 
dynamic  code  analysis 
tasks 
like  fuzzing,  code 
coverage, and data flow tracking.  
4. Evaluation 
     In the following sections, we evaluate of our tool’s 
potential as a fuzzer.  For all of our tests, we tested our 
tool  on the  tftpd.exe  Windows  server  program  for  50 
runs  and  compared  it  to  a  random  exploration  [17].  
We ran the GA for 3,000 generations and the random 
exploration for equivalent to 10,000 generations worth 
of input data. Each generation consisted of 50 different 
test  inputs.  The  context-free  grammar  we  used  to 
generate inputs consisted of hex bytes from 0 to 255 in 
addition  to  the  mode  strings  “netascii”,  “octet”  and 
“mail”.    We  included  these  strings  because  we  knew 
them  to  be  part  of  the  tftp  packet  format  and  they 
appeared in the disassembly listing of program strings.  
Indeed, such strings are easily extracted from a binary 
program and could potentially provide a rich source for 
the  automatic  derivation  of  application  specific 
grammar rules (clearly the GA will learn faster if it has 
more useful information in the grammar to generate its 
test inputs from).  The GA parameters we used in our 
experiments  were:  Mutation  Rate  =  90%,  Crossover 
Rate = 75%, Elitism, Selective Breeding, and Dynamic 
Mutation. 
     Lastly,  all  of  the  following  experiments  were 
performed upon a desktop PC containing an Intel Core 
Duo 2 processor, 1 GB of memory, and the Windows 
XP  Professional  operating  system.    Running  times 
481481
varied,  depending  upon  the  exact  experiment  and 
whether we were using the GA or the random search.  
None of the individual runs, however, took longer than 
a few hours to complete.  
4.1. Targeted Execution 
     Security researchers frequently encounter situations 
where  they  have  analyzed  and  located  a  potentially 
exploitable  location  in  a  program  that  is  dependent 
upon some user controlled input. An example might be 
a  packet  received  over  a  network  connection  by  an 
application  that  is  subsequently  sent  into  some  API 
function  known  to  be  vulnerable  to  buffer  overflows.  
Exploitability, however, also implies reachability. That 
is,  in  order  to  determine  if  the  vulnerability  is  an 
exploitable  threat,  one  must  prove  that  it is reachable 
on the execution path given some user supplied input.  
The  exact  format  of  this input is  dependent  upon the 
control  flow  logic  on  the  path  between  the  packet 
acceptance  and  the  basic  block  where  the  vulnerable 
API function is used. 
     In  this  section,  we  present  an  evaluation  of  our 
tool’s feasibility for the previously discussed scenario 
of  determining  the  input  structure  needed  to  drive 
program  execution  into  a  potentially  vulnerable  state. 
We  targeted  two  published  vulnerabilities  in  the 
TFTPD  server  program  [17].    These  vulnerabilities 
exist in  the  packet  parsing logic  and  are  the result  of 
improper  bounds  checking  on  strings  passed  into  two 
strcpy() functions.  
     Our findings were twofold.  First, we showed that 