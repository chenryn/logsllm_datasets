different meanings to each section of the document. For example:
Hello world!
Faced with such input, the general-purpose renderer will usually do
itsbest to make sense of all the recognized namespaces and assemble the
markup into a single, consistent document with a normal Document Object
Model representation. And, if any one of the recognized namespaces hap-
pens to support scripting, any embedded scripts will execute, too.
Because of the somewhat counterintuitive xmlns handling behavior,
Content-Type is not a suitable way to control how a particular XML document
will be parsed; the presence of a particular top-level xmlns directive is also not
a guarantee that no other data formats will be honored later on. Any attacker-
controlled XML-based formats must therefore be handled with care and san-
itized very thoroughly.
Generic XML View
In most browsers, a valid XML document with no renderer-recognized
namespaces present anywhere in the markup will be shown as an interactive,
pretty-printed representation of the document tree, as shown in Figure 7-1.
This mode is not particularly useful to end users, but it can aid debugging.
That said, when any of the namespaces in the document is known to the
browser (even when the top-level one is not recognized at all!), the document
will be rendered differently: All recognized markup will work as intended, all
unsupported tags will simply have no effect, and any text between them will
be shown as is.
To illustrate this rendering strategy, consider the following input:
Hello
world!
The above example will be rendered as “Hello world!” The first  tag,
with no semantics-defining namespace associated with it, will have no visible
effect. The second one will be understood as an XHTML tag that triggers
underlining.
120 Chapter 7
Figure 7-1: Firefox displaying an XML document with no recognized namespaces
The consequences of this fault-tolerant approach to the rendering of
unknown XML documents and unrecognized namespaces are subtle but
fairly important. For example, it will not be safe to proxy an unsanitized RSS
feed, even though this format is typically routed to a specialized renderer
and thus not subject to XSS risks. Any browser with no built-in RSS reader
may fall back to generic rendering and then find HTML buried deep inside
the feed.
Scalable Vector Graphics
Scalable Vector Graphics (SVG)1 is a quickly evolving, XML-based vector
graphics format. First published in 2001 by W3C, it is noteworthy for its inte-
grated animation capabilities and direct JavaScript scripting features. The
following example of a vector image draws a circle and displays a message
when this circle is clicked:
Non-HTML Document Types 121
The SVG file format is recognized all modern browsers except for
Internet Explorer prior to 9, and it is handled by the general-purpose XML
renderer. SVG images can be embedded into XHTML with an appropriate
xmlns directive or inlined in non-XML HTML5 documents using a pre-
defined  tag.
Interestingly, in several browsers the format can also be placed in a stand-
alone XML document and then viewed directly, or it can be loaded on third-
party pages via the  markup. While it is safe to load SVG images via 
(scripting should be disabled in this scenario), it is fairly dangerous to host
user-supplied SVG data because in cases of direct navigation, all embedded
scripts will execute in the context of the hosting domain. This unexpected
problem means that serving any externally originating SVG images will require
very careful syntax sanitization to eliminate non-SVG xmlns content from the
XML container and to permit only certain types of markup in the remainder
of the document.
NOTE The Content-Disposition header on the relevant HTTP responses is a potential
workaround that permits SVG to be included via  but not accessed directly. This
approach is not perfect, but it limits the risk. Using a throwaway domain to host such
images is another possibility.
Mathematical Markup Language
Mathematical Markup Language (MathML)2 is a fairly straightforward means
to facilitate the semantic, if a bit verbose, representation of mathematical
equations. The standard was originally proposed by the W3C in 1998, and it
has been substantially refined through the years. Because of its somewhat
niche application, MathML needed over a decade to gain partial support in
Opera and Firefox browsers, but it is slowly gaining acceptance today. In the
browsers that support the language, it may be placed in a standalone file or
inline in XHTML and HTML5 documents.
Unlike SVG, MathML has no additional security considerations beyond
those associated with generically handled XML.
XML User Interface Language
The XML User Interface Language (XUL)3 is a presentation markup lan-
guage created by Mozilla specifically for building browser-based applications,
rather than documents. XUL exists because although modern HTML is often
powerful enough to build basic graphical user interfaces, it is not particularly
convenient for certain specialized tasks that desktop applications excel in,
such as implementing common dialog windows or system menus.
XUL is not currently supported by any browser other than Firefox and
appears to be disabled in the recent release, Firefox 6. In Firefox, it is handled
by the general-purpose renderer, based on the appropriate xmlns namespace.
Firefox uses XUL for much of its internal UI, but otherwise the language is
seldom encountered on the Internet.
From the standpoint of web application security, Internet-originating
XUL documents can be considered roughly equivalent to HTML documents.
122 Chapter 7
Essentially, the language has JavaScript scripting capabilities and allows broad
control over the appearance of the rendered page. Other than that property,
it has no unusual quirks.
Wireless Markup Language
Wireless Markup Language (WML)4 is a largely obsolete “optimized” HTML
syntax developed in the 1990s by a consortium of mobile handset manufac-
turers and cellular network operators. This XML-based language, a part of
the Wireless Application Protocol suite (WAP), offered a simplified weblike
browsing experience for pre-smartphone devices with limited bandwidth and
CPU resources.* A simple WML page might have looked like this:
Click here!
Because WAP services needed to be engineered independently of nor-
mal HTML content and had to deal with closed and underspecified client
architectures and other carrier-imposed restrictions, WML never became as
popular as its proponents hoped. In almost all developed markets, WML has
been displaced by fast, Internet-enabled smartphones with fully featured
HTML browsers. Nevertheless, the legacy of the language lives on, and it is
still routed to specialized renderers in Opera and in Internet Explorer Mobile.
In the browsers that support the format, it is often possible to use WML-
based scripts. There are two methods to achieve this. The canonical way is to
use WMLScript (WMLS), a JavaScript-derived execution environment that
depends on stand-alone script files, coupled with an extremely inconsiderate
abuse of fragment IDs for an equivalent of possibly attacker-controlled
eval(...) statements:
Click here!
The other method of executing scripts, available in more featured brows-
ers, is to simply embed normal javascript: URLs or insert  blocks into
the WML file.
RSS and Atom Feeds
Feeds are a standardized way for clients to periodically poll sites of interest
tousers (such as their favorite blogs) for machine-readable updates to said
sites’ content. Really Simple Syndication (RSS)5 and Atom6 are two superfi-
cially similar but fiercely competing XML-based feed formats. The first (RSS)
is popular; the second (Atom) is said to be good.
* Astute readers will note that XML is not a particularly good way to conserve bandwidth or CPU
resources. To that effect, the WAP suite provides an alternative, binary-only serialization of
XML, known as WBXML.
Non-HTML Document Types 123
Built-in, specialized RSS and Atom renderers are available in Firefox,
Safari, and Opera. The determination to route an XML document to these
modules is based on simple, browser-specific heuristics, such as the top-level
tag being named  or  (and not having any conflicting xmlns direc-
tives). In Firefox, RSS parsing may kick in even if Content-Type is image/svg+xml
or text/html. Safari will happily recognize feeds in even more unrelated MIME
types.
One interesting feature of both feed formats is that they permit a subset
of HTML, including CSS, to be embedded in a document in a rather pecu-
liar, indirect way: as an entity-escaped text. Here is an example of this syntax:
...
&lt;u&gt; Underlined text! &lt;/u&gt;
...
The subset of HTML permitted in RSS and Atom feeds is not well defined,
and some feed renderers have previously permitted direct scripting or navi-
gation to potentially dangerous pseudo-URLs. Perhaps more importantly,
however, any browser that does not have built-in feed previews may render
the file using the generic XML parsing approach; if such feeds are not sani-
tized carefully, script execution will ensue.
A Note on Nonrenderable File Types
For the sake of completeness, it should be noted that all modern browsers
support a number of specialized file formats that remain completely opaque
to the renderer or to the web application layer but that are nevertheless rec-
ognized by a variety of in-browser subsystems.
A detailed investigation of these formats is beyond the scope of this
book, but some notable examples include plug-in and extension installation
manifests, automatic HTTP proxy autoconfiguration files (PAC), installable
visual skins, Certificate Revocation Lists (CRLs), antimalware site blacklists,
and downloadable TrueType and OpenType fonts.
The security properties of these mechanisms should be studied individ-
ually before deciding to allow any of these formats to be served to the user.
Save for the generic content-hosting considerations outlined in Chapter 13,
they are unlikely to harm the hosting web application directly, but they may
cause problems for users.
124 Chapter 7
Security Engineering Cheat Sheet
When Hosting XML-Based Document Formats
Assume that the payload may be interpreted as XHTML or some other script-enabled docu-
ment type, regardless of the Content-Type and the top-level xmlns directive. Do not allow uncon-
strained attacker-controlled markup anywhere inside the file. Use the Content-Disposition:
attachment if data is not meant to be viewed directly;  and feeds will still work.
On All Non-HTML Document Types
Use correct, browser-recognized Content-Type and charset values. Specify the Content-Disposition:
attachment where possible. Verify and constrain output syntax. Consult the cheat sheet in
Chapter 13 to avoid security problems related to content-sniffing flaws.
Non-HTML Document Types 125
C O N T E N T R E N D E R I N G W I T H
B R O W S E R P L U G - I N S
Browser plug-ins come in many forms and shapes, but
the most common variety give the ability to display new
file formats in the browser, as if they were HTML. The
browser simply hands over the retrieved file, provides
the helper application with a rectangular drawing sur-
face in the document window, and essentially backs away
from the scene. Such content-rendering plug-ins are clearly distinguished from
browser extensions, a farmore numerous bunch that commonly relies on
JavaScript code to tweak how the already-supported, in-browser content is
presented to the user.
Browser plug-ins have a long and colorful history of security flaws. In
fact, according to some analysts, 12 out of the 15 most frequently exploited
client-side vulnerabilities in 2010 could be attributed to the quality of plug-in
software.1 Many of these problems are because the underlying parsers were
originally not meant to handle malicious inputs gracefully and have not ben-
efited from the intense scrutiny that the remainder of the Web has been sub-
ject to. Other problems stem from the unusual security models devised by
plug-in developers and the interference between these permissions, the tra-
ditional design of web browsers, and the commonsense expectations of appli-
cation developers.
We will review some of the security mechanisms used by popular plug-ins
in the next chapter of this book. Before taking this dive, it makes sense to
look at the ways plug-ins integrate with other online content and the com-
mon functionality they offer.
Invoking a Plug-in
Content-rendering plug-ins can be activated in a couple of ways. The most
popular explicit method is to use  or  markup
ina “host” HTML document, with the src or data parameter pointing to the
URL from which the actual plug-in-recognized document is to be retrieved.
The dimensions and position of the drawable area allocated for the plug-in
can be controlled with CSS (or with legacy HTML parameters).
In this scenario, every  or  tag should be accompanied by
an additional type parameter. The MIME type specified there will be com-
pared to the list of MIME types registered by all the active plug-ins, and the
retrieved file will be routed to the appropriate handler. If no match is found,
a warning asking the user to download a plug-in should be theoretically dis-
played instead, although most browsers look at other signals before resorting
to this unthinkable possibility; examining Content-Type or the apparent file
extension spotted in the URL are two common choices.
NOTE An obsolete  tag, used to load Java programs (roughly equivalent to
), works in a comparable way but
unconditionally disregards these auxiliary signals.
Additional input to the plug-in is commonly passed using  tags
nested inside the  block or through nonstandard additional parame-
ters attached to the  markup itself. The former, more modern
approach may look like this:
...
In this content-inclusion mode, the Content-Type header returned by the
server when retrieving the subresource is typically ignored, unless the type
parameter is unknown to the browser. This is an unfortunate design, for rea-
sons that will be explained shortly.
The other method for displaying plug-in content involves navigating
directly to a suitable file. In this case, and in the case of  or 
with a missing type parameter, the Content-Type value obtained from the server
is honored, and it will be compared with the list of plug-in-recognized MIME
128 Chapter 8
types. If a match is found, the content is routed to the appropriate component.
If the Content-Type lookup fails or the header is missing, some browsers will
examine the response body for known content signatures; others just give up.
NOTE The aforementioned content-focused methods aside, several types of plug-ins can be
loaded directly from within JavaScript or VBScript programs without the need to explic-
itly create any HTML markup or retrieve any external data. Such is the case for ActiveX,
an infamous script-to-system integration bridge available in Internet Explorer. (We will
devote some time to ActiveX later in this chapter, but first things first.)
The Perils of Plug-in Content-Type Handling
As noted in the previous section, in certain scenarios the Content-Type param-
eter on a retrieved plug-in-handled file is ignored, and the type parameter in
the corresponding markup on the embedding page is used instead. While
this decision is somewhat similar to the behavior of other type-specific con-
tent-inclusion tags (say, ), as discussed in “Type-Specific Content Inclu-
sion” on page82, it has some unique and ultimately disastrous consequences
in the plug-in world.
The big problem is that several types of plug-ins are essentially full-
fledged code execution environments and give the executed applications
(applets) a range of special privileges to interact with the originating domain.
For example, a Flash file retrieved from fuzzybunnies.com would be granted
access to its originating domain (complete with a user’s cookies) when
embedded on the decidedly rogue bunnyoutlet.com.
In such a scenario, it would seem to be important for fuzzybunnies.com
tobe able to clearly communicate that a particular type of a document is
indeed meant to be interpreted by a plug-in—and, consequently, that some
documents aren’t meant to be used this way. Unfortunately, there is no way
for this to happen: The handling of a retrieved file is fully controlled by
theembedding site (in our example, by the mean-spirited bullies who own
bunnyoutlet.com). Therefore, if the originating domain hosts any type of user-
controlled content, even in a nominally harmless format (such as text/plain
or image/jpeg), the owners of bunnyoutlet.com may instruct the browser to dis-
regard the existing metadata and route that document to a plug-in of their
choice. A simple markup to achieve this sinister goal may be
<object data="http://fuzzybunnies.com/avatars/user11630.jpg"