# CVE-2017-13253：多个Android DRM服务中存在缓冲区溢出漏洞
|
##### 译文声明
本文是翻译文章，文章原作者 @tamir_zb，文章来源：blog.zimperium.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
近期，我们在进行Zimperium zLabs平台的研究过程中，披露了一个缓冲区溢出漏洞，该漏洞影响到Google的多个Android
DRM服务。在我们提交漏洞情况之后，Google将其定级为高危，并指定了CVE-2017-13253编号，该漏洞已经在2018年3月份的安全更新中实现了修复。  
在本文，我们将介绍该漏洞的详细信息。首先会介绍相关背景信息，包括常规的Android运行机制和与该漏洞相关的机制。我们将重点介绍最近推出的treble计划以及其意义。随后，将研究如何利用某些设备上的其他故障来修复该漏洞，以此获得root权限。最后，我们将一同研究该漏洞的成因，并探究该漏洞的缓解与防范方式。尽管Google声称Treble计划能增强安全性，但我们还是看到了它的不足之处。  
请读者注意，在本篇文章之中，我们将详细介绍大量与该漏洞相关的背景信息。如果您已经拥有Binder和libbinder的使用经验，可以跳过第一部分，直接从具体的漏洞分析开始阅读。
## Android的Binder与安全
在包括Android在内的许多操作系统中，为了实现进程之间通信（IPC），都使用了一种常见的安全模型。借助该模型，在非特权进程中运行的不可信代码可以与特权进程（服务）进行通信，并要求它们执行操作系统允许的制定操作。该模型依赖于服务与IPC机制自身，可以正确验证来自非特权进程的每一个输入。但是反之，这也意味着这些服务中一旦出现错误，特别是输入验证部分的错误非常容易导致漏洞。  
举例来说，Rani Idan在Zimperium发现的最新iOS漏洞（
 ）就属于上述方法。在IPS输入验证中存在一个问题，从而允许攻击者从非特权应用程序执行具有更高权限的代码。  
在Android系统中，IPC机制被称为Binder。Android Binder服务的安全性一直是许多漏洞研究者的一个研究方向（
）。Binder具有非常多有用的功能。举例来说，它允许进程之间传输文件描述符或对其他Binder服务的引用等较为复杂的对象。为了保持简洁和良好性能，Binder佳你给每个事务都限制在1MB大小之内。如果进程需要传输大量数据，可以使用共享内存来实现快速共享数据。
## Binder的C++库
Android的Binder库（libbinder）为依赖于Binder的C++代码提供了很多抽象，从而可以允许调用C++类的远程实例的方法。  
只要是使用了此类机制的对象，都会在预定义的结构中，实现了下面的几个类：  
1、一个接口类，定义了可以通过Binder调用的对象的方法，以“I”为前缀；  
2、负责序列化输入和反序列化输出的“客户端”类，以“Bp”为前缀；  
3、负责反序列化输入和序列化输出的“服务器端”类，以“Bn”为前缀。  
最终，在使用该对象时，几乎始终是使用接口类。这样一来，就可以以相同的方式处理对象，无论其处于同一个进程中还是处于不同的进程中。、
代码中“服务器端”部分通常都位于特权服务的内部，尽管在某些情况下角色是相反的，因此通常会负责验证输入。验证代码可以从Bn*类开始，并沿着随后调用的方法继续进行。这显然是脆弱性研究过程中最有意思的部分。
## ICrypto接口和解密方法
在介绍完Binder之后，就让我们来看看与漏洞相关的具体实现。
Mediadrmserver服务（该服务负责DRM媒体）提供了一个加密对象的接口，接口名为ICrypto。
在这里需要注意，最近这一对象已经变为了CryptoHal，我们将在稍后详细讨论。
该接口通常的用途是允许非特权应用程序解密需要较高权限解密的DRM数据，比如访问TEE。受文章篇幅所限，加密相关的细节不在此次讨论范围之内，我们会将重点放在输入验证上面。  
ICrypto有多种方法，但无疑最重要的方法是解密，这也正是大多数人的研究方向。  
在解密签名中，最引人注意的事情之一就是输入的复杂程度。由于每个参数都通过Binder进行传输，并且需要进行验证，因此复杂的输入会导致验证代码更为复杂。也就是说，这些代码可能容易受到漏洞的影响。  
我们来看一些参数：  
1、Mode：这是一个控制加密模式的枚举。其中的一个模式是kMode_Unencrypted，它表示数据实际上未被加密。该模式意味着数据只会从一个地方简单地复制到另一个地方，不会涉及到任何解密。这就使得整个过程非常简单，因此从现在开始我们主要专注于这个模式。所以正如前文所说，我们不考虑加密相关的参数。  
2、Source/Destination：输入和输出缓冲区。由于数据的大小可能非常大（大于1MB），实际数据就有可能通过这些对象所代表的共享内存进行传输。  
3、Offset：将偏移量偏移到数据开始的输入缓冲区中。  
4、subSamples/numSubSamples：一个子样本数组，其中存储与输入相关的元数据。每个子样本表示多个清空的字节，后面跟着一些加密的字节。这样一来便可以在清空和加密的输入数据之间切换。使用kMode_Unencrypted也可以简化这一部分，因为我们就只需要使用一个代表所有清空数据的子样本。  
现在，我们来仔细看看源参数和目标参数的类型：
源代码请参考：
。  
这里的相关结构成员是mHeapSeqNum和两个mSharedMemory成员（DestinationBuffer的其余部分是在目标未被存储为共享内存的情况下，这种情况与此漏洞无关）。
堆name在这里用来指代实际的共享内存（也就是运行mmap后所得到的内容）。mHeapSeqNum是一个像这样的内存标识符，它以前使用称为setHeap的ICrypto共享方法。这两个mSharedMemory成员仅表示堆内缓冲区的偏移量和大小。这意味着，虽然mHeapSeqNum在源结构的内部，但它实际上与两者都相关。
值得注意的是，在参数结构中的某些部分有一些奇怪。mSharedMemory是一个IMemory，它实际上连接到它自己的堆，并且应该是表示内部的一个缓冲区。然而，这个堆却被忽略，其偏移量和大小都被用于mHeapSeqNum堆。在源结构中，还存在mHeapSeqNum，但它与源和目标都有关。上述内容，是最近代码发生更新造成的，这些代码是作为Treble项目中重要架构的一部分而创建的。
###  Treble项目
Treble项目是在Android
8.0版本中被引入的，其主要目标是通过在AOSP和供应商之间建立明确的分隔，从而简化系统更新的过程。Google还声称，Treble项目会通过增加更多的隔离功能，从而提高Android的安全性。  
对于像mediadrmserver这样的服务，引入Treble项目后就会被隔离成多个进程。负责解密的代码属于供应商，因此它会被分成多个供应商进程，称为HAL，每个供应商都负责其自己的DRM方案。
Mediadrm服务器的作用现在只剩下在相关DRM方案的应用程序和HAL进程之间传输数据。
Mediadrmserver和HAL之间的通信也建立在Binder之上，但是在不同的域中会使用不同库的格式——libhwbinder。之前提到的从Crypto到CryptoHal的变化，其原因在于现在它是一个不同的类，其唯一目的是将数据转换为libhwbinder格式，并将其传递给HAL。
在上图中，展现了Google之所以声称Treble项目有助于提升安全性的原因。由于在不同的进程中权限被分开，每个HAL只能与自己的驱动程序通信，不受信任的应用程序不会再直接与高权限进程交互。  
然而，需要注意的是，从Android 8.1开始，隔离继续变回了可选项，具体取决于供应商的设定。例如，在Nexus
5X设备中，HAL都会位于mediadrmserver进程中。数据仍然会转换成HAL格式，但不会转移到其他进程。
###  加密插件