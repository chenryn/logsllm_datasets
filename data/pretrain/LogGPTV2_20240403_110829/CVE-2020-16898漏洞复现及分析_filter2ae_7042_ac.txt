## 漏洞分析与修复方案

### 0x01 漏洞触发过程

在第一次调用 `Ipv6pUpdateRDNSS` 函数后，通过调试器命令 `dt ndis!_NET_BUFFER @r14` 和 `dt ndis!_MDL 0xffff9a04`9ae4c350`，我们获取了以下结构体信息：

- **NET_BUFFER 结构**
  - `Next`: (null)
  - `CurrentMdl`: 0xffff9a04`9ae4c350
  - `CurrentMdlOffset`: 0x28
  - `DataLength`: 0x138
  - `stDataLength`: 0x138
  - `MdlChain`: 0xffff9a04`9c40a180
  - `DataOffset`: 0x88
  - `ChecksumBias`: 0
  - `Reserved`: 0
  - `NdisPoolHandle`: 0xffff9a04`9aba28c0
  - `NdisReserved`: [2] (null)
  - `ProtocolReserved`: [6] 0x00000160`00000000
  - `MiniportReserved`: [4] (null)
  - `DataPhysicalAddress`: _LARGE_INTEGER 0x0
  - `SharedMemoryInfo`: (null)
  - `ScatterGatherList`: (null)

- **MDL 结构**
  - `Next`: 0xffff9a04`9ae4c7d0
  - `Size`: 0n56
  - `MdlFlags`: 0n4
  - `AllocationProcessorNumber`: 0x9a04
  - `Reserved`: 0xffff
  - `Process`: (null)
  - `MappedSystemVa`: 0xffff9a04`9ae4c390
  - `StartVa`: 0xffff9a04`9ae4c000
  - `ByteCount`: 0x30
  - `ByteOffset`: 0x390

接下来，通过 `db 0xffff9a04`9ae4c390+0x10` 命令查看内存数据：
```
ffff9a04`9ae4c3a0  19 04 00 00 ff ff ff ff-5a 5a 5a 5a 5a 5a 5a 5a  ........ZZZZZZZZ
ffff9a04`9ae4c3b0  5a 5a 5a 5a 5a 5a 5a 5a-01 02 03 04 05 06 07 08  ZZZZZZZZ........
ffff9a04`9ae4c3c0  00 d0 09 02 43 63 50 63-9a 74 0e 74 7b 4b cd b6  ....CcPc.t.t{K..
ffff9a04`9ae4c3d0  fe 02 04 00 ff ff 00 00-90 c3 88 a0 04 9a ff ff  ................
ffff9a04`9ae4c3e0  60 09 80 02 00 00 00 00-60 09 c0 02 00 00 00 00  `.......`.......
ffff9a04`9ae4c3f0  60 09 c0 02 00 00 00 00-19 19 f3 02 00 00 00 00  `...............
ffff9a04`9ae4c400  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffff9a04`9ae4c410  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
```

可以看到，`\x01\x02` 被解析为下一个 Option 的头部。由于 `\x02` 位于 Length 字段，且没有对应的 Type，因此会跳过 0x10 个字节，直接跳到 `\x19\x04` 部分。

再次调用 `Ipv6pUpdateRDNSS` 后，通过 `dt ndis!_NET_BUFFER @r14` 和 `dt ndis!_MDL 0xffff9a04`9ae4c7d0` 获取的结构体信息如下：

- **NET_BUFFER 结构**
  - `Next`: (null)
  - `CurrentMdl`: 0xffff9a04`9ae4c7d0
  - `CurrentMdlOffset`: 8
  - `DataLength`: 0x128
  - `stDataLength`: 0x128
  - `MdlChain`: 0xffff9a04`9c40a180
  - `DataOffset`: 0x98
  - `ChecksumBias`: 0
  - `Reserved`: 0
  - `NdisPoolHandle`: 0xffff9a04`9aba28c0
  - `NdisReserved`: [2] (null)
  - `ProtocolReserved`: [6] 0x00000160`00000000
  - `MiniportReserved`: [4] (null)
  - `DataPhysicalAddress`: _LARGE_INTEGER 0x0
  - `SharedMemoryInfo`: (null)
  - `ScatterGatherList`: (null)

- **MDL 结构**
  - `Next`: 0xffff9a04`9ae4c8f0
  - `Size`: 0n56
  - `MdlFlags`: 0n4
  - `AllocationProcessorNumber`: 0xffff
  - `Reserved`: 0xffff
  - `Process`: (null)
  - `MappedSystemVa`: 0xffff9a04`9ae4c810
  - `StartVa`: 0xffff9a04`9ae4c000
  - `ByteCount`: 0x30
  - `ByteOffset`: 0x810

通过 `db 0xffff9a04`9ae4c810+0x8` 命令查看内存数据：
```
ffff9a04`9ae4c818  19 04 00 00 ff ff ff ff-5a 5a 5a 5a 5a 5a 5a 5a  ........ZZZZZZZZ
ffff9a04`9ae4c828  5a 5a 5a 5a 5a 5a 5a 5a-18 22 5a 5a 5a 5a 5a 5a  ZZZZZZZZ."ZZZZZZ
ffff9a04`9ae4c838  5a 5a 5a 5a 5a 5a 5a 5a-00 19 09 02 41 6c 65 70  ZZZZZZZZ....Alep
ffff9a04`9ae4c848  9a fe 7b 74 7b 4b cd b6-d0 a1 c9 99 04 9a ff ff  ..{t{K..........
ffff9a04`9ae4c858  20 01 22 01 00 00 00 00-70 d2 fe 9f 04 9a ff ff   .".....p.......
ffff9a04`9ae4c868  c0 08 65 9a 04 9a ff ff-a0 0f 00 00 00 00 00 00  ..e.............
ffff9a04`9ae4c878  00 00 00 00 00 00 00 00-fa ad db ba fa ad db ba  ................
ffff9a04`9ae4c888  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
```

此时，执行已经指向了 `\x18\x22`。通过 `dt ndis!_NET_BUFFER @r14` 和 `dt ndis!_MDL 0xffff9a04`9ae4c7d0` 再次获取结构体信息：

- **NET_BUFFER 结构**
  - `Next`: (null)
  - `CurrentMdl`: 0xffff9a04`9ae4c7d0
  - `CurrentMdlOffset`: 0x20
  - `DataLength`: 0x110
  - `stDataLength`: 0x110
  - `MdlChain`: 0xffff9a04`9c40a180
  - `DataOffset`: 0xb0
  - `ChecksumBias`: 0
  - `Reserved`: 0
  - `NdisPoolHandle`: 0xffff9a04`9aba28c0
  - `NdisReserved`: [2] (null)
  - `ProtocolReserved`: [6] 0x00000160`00000000
  - `MiniportReserved`: [4] (null)
  - `DataPhysicalAddress`: _LARGE_INTEGER 0x0
  - `SharedMemoryInfo`: (null)
  - `ScatterGatherList`: (null)

- **MDL 结构**
  - `Next`: 0xffff9a04`9ae4c8f0
  - `Size`: 0n56
  - `MdlFlags`: 0n4
  - `AllocationProcessorNumber`: 0xffff
  - `Reserved`: 0xffff
  - `Process`: (null)
  - `MappedSystemVa`: 0xffff9a04`9ae4c810
  - `StartVa`: 0xffff9a04`9ae4c000
  - `ByteCount`: 0x30
  - `ByteOffset`: 0x810

通过 `db 0xffff9a04`9ae4c810+0x20` 命令查看内存数据：
```
ffff9a04`9ae4c830  18 22 5a 5a 5a 5a 5a 5a-5a 5a 5a 5a 5a 5a 5a 5a  ."ZZZZZZZZZZZZZZ
ffff9a04`9ae4c840  00 19 09 02 41 6c 65 70-9a fe 7b 74 7b 4b cd b6  ....Alep..{t{K..
ffff9a04`9ae4c850  d0 a1 c9 99 04 9a ff ff-20 01 22 01 00 00 00 00  ........ .".....
ffff9a04`9ae4c860  70 d2 fe 9f 04 9a ff ff-c0 08 65 9a 04 9a ff ff  p.........e.....
ffff9a04`9ae4c870  a0 0f 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffff9a04`9ae4c880  fa ad db ba fa ad db ba-00 00 00 00 00 00 00 00  ................
ffff9a04`9ae4c890  00 00 00 00 00 00 00 00-03 00 00 00 01 00 00 00  ................
ffff9a04`9ae4c8a0  50 c8 e4 9a 04 9a ff ff-10 e3 10 2d 00 f8 ff ff  P..........-....
```

当 `Type` 为 `0x18` 时，会调用 `NdisGetDataBuffer` 函数，长度为 `0x22`，即 `0x22 * 8 = 0x110` 个字节。对于 `NdisGetDataBuffer` 函数来说，如果数据包是分片发送的，会被暂时存放到一个栈空间内。当前的栈空间不足，导致栈溢出。由于内核中存在 GS 保护机制，每次在函数结束时会验证初始阶段存放的 Cookie 值。如果 Cookie 值被修改，则会报错，从而导致蓝屏（BSOD）。

### 0x04 漏洞危害

该漏洞可以稳定地导致远程主机 BSOD，条件受限于必须在同一内网下并且对 RDNSS 包进行处理。对于远程代码执行，仅靠这一个漏洞基本不可能达到目的，因为内核中的保护机制很多。对于 GS 保护，需要与一个内存泄露的漏洞组合利用才能导致远程代码执行。

### 0x05 漏洞修复方案

#### 通用修复建议
下载并安装最新的补丁包进行更新修复。补丁链接如下：[补丁链接]

#### 临时修复建议
可以通过禁用 ICMPv6 RDNSS 来缓解漏洞。

1. 获取对应接口的接口号：
   ```shell
   netsh int ipv6 show int
   ```

2. 关闭 RDNSS：
   ```shell
   netsh int ipv6 set int <接口号> rabaseddnsconfig=disable
   ```

### 0x06 参考链接
1. [参考链接1]
2. [参考链接2]
3. [参考链接3]