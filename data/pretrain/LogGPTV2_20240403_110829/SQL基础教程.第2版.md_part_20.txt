第5章 复杂查询
5-1
视图
● 从SQL的角度来看，视图和表是相同的，两者的区别在于表中保存的是实
学习重点
际的数据，而视图中保存的是SELECT语句（视图本身并不存储数据）。
● 使用视图，可以轻松完成跨多表查询数据等复杂操作。
● 可以将常用的SELECT语句做成视图来使用。
● 创建视图需要使用CREATE VIEW语句。
● 视图包含“不能使用ORDER BY”和“可对其进行有限制的更新”两项限制。
● 删除视图需要使用DROP VIEW语句。
视图和表
KEYWORD 我们首先要学习的是一个新的工具——视图。
●视图
视图究竟是什么呢？如果用一句话概述的话，就是“从SQL的角度
来看视图就是一张表”。实际上，在SQL语句中并不需要区分哪些是表，
哪些是视图，只需要知道在更新时它们之间存在一些不同就可以了，这一
点之后会为大家进行介绍。至少在编写SELECT语句时并不需要特别在
意表和视图有什么不同。
那么视图和表到底有什么不同呢？区别只有一个，那就是“是否保存
了实际的数据”。
通常，我们在创建表时，会通过INSERT语句将数据保存到数据库
之中，而数据库中的数据实际上会被保存到计算机的存储设备（通常是硬
盘）中。因此，我们通过SELECT语句查询数据时，实际上就是从存储
设备（硬盘）中读取数据，进行各种计算之后，再将结果返回给用户这样
一个过程。
但是使用视图时并不会将数据保存到存储设备之中，而且也不会将数
据保存到其他任何地方。实际上视图保存的是SELECT语句（图5-1）。
我们从视图中读取数据时，视图会在内部执行该SELECT语句并创建出
一张临时表。
● 150 第5章 复杂查询
图5-1 视图和表
使用视图时会执行SELECT
语句并创建出一张临时表
存储设备（硬盘）
数据库
视图
表
SELECT …
执行SELECT FROM Product
语句 GROUP BY product_type;
表中保存的是实际 视图中保存的是
数据 SELECT语句
■视图的优点
视图的优点大体有两点。
第一点是由于视图无需保存数据，因此可以节省存储设备的容量。例
如，我们在4-1节中创建了用来汇总商品种类（product_type）的表。
由于该表中的数据最终都会保存到存储设备之中，因此会占用存储设备
的数据空间。但是，如果把同样的数据作为视图保存起来的话，就只需
要代码清单5-1那样的SELECT语句就可以了，这样就节省了存储设备
的数据空间。
代码清单5-1 通过视图等SELECT语句保存数据
SELECT product_type, SUM(sale_price), SUM(purchase_price)
FROM Product
GROUP BY product_type;
由于本示例中表的数据量充其量只有几行，所以使用视图并不会大幅
缩小数据的大小。但是在实际的业务中数据量往往非常大，这时使用视图
所节省的容量就会非常可观了。
法则5-1
表中存储的是实际数据，而视图中保存的是从表中取出数据所使用的SELECT语句。
5-1 视图 151 ●
第二个优点就是可以将频繁使用的SELECT语句保存成视图，这样
就不用每次都重新书写了。创建好视图之后，只需在SELECT语句中进
行调用，就可以方便地得到想要的结果了。特别是在进行汇总以及复杂的
查询条件导致SELECT语句非常庞大时，使用视图可以大大提高效率。
而且，视图中的数据会随着原表的变化自动更新。视图归根到底就是
SELECT语句，所谓“参照视图”也就是“执行SELECT语句”的意思，因
此可以保证数据的最新状态。这也是将数据保存在表中所不具备的优势A。
注A
数据保存在表中时，必须要显式
地执行SQL更新语句才能对数据
法则5-2
进行更新。
应该将经常使用的SELECT语句做成视图。
创建视图的方法
KEYWORD 创建视图需要使用CREATE VIEW语句，其语法如下所示。
●CREATE VIEW语句
语法5-1 创建视图的CREATE VIEW语句
CREATE VIEW 视图名称(, , ……)
AS
SELECT语句需要书写在AS关键字之后。SELECT语句中列的排列
顺序和视图中列的排列顺序相同，SELECT语句中的第1列就是视图中的
第1列，SELECT语句中的第2列就是视图中的第2列，以此类推。视图
的列名在视图名称之后的列表中定义。
备 忘
接下来，我们将会以此前使用的Product（商品）表为基础来创建视图。
如果大家已经根据之前章节的内容更新了Product表中的数据，请在创建视图
之前将数据恢复到初始状态。操作步骤如下所示。
① 删除Product表中的数据，将表清空
DELETE FROM Product;
memo
● 152 第5章 复杂查询
② 执行代码清单1-6（1.5节）中的SQL语句，将数据插入到空表Product中
②中的SQL语句（CreateTableProduct.sql）收录在示例程序\Sample\
CreateTable\PostgreSQL文件夹中。
下面就让我们试着来创建视图吧。和此前一样，这次我们还是将
Product表（代码清单5-2）作为基本表。
代码清单5-2 ProductSum视图
CREATE VIEW ProductSum (product_type, cnt_product) 视图的列名
AS
SELECT product_type, COUNT(*)
视图定义中的主体（内容
FROM Product
只是一条SELECT语句）
GROUP BY product_type;
这样我们就在数据库中创建出了一幅名为ProductSum（商品合计）
的视图。请大家一定不要省略第2行的关键字AS。这里的AS与定义别
名时使用的AS并不相同，如果省略就会发生错误。虽然很容易混淆，但
是语法就是这么规定的，所以还是请大家牢记。
接下来，我们来学习视图的使用方法。视图和表一样，可以书写在
SELECT语句的FROM子句之中（代码清单5-3）。
代码清单5-3 使用视图
SELECT product_type, cnt_product
FROM ProductSum; 在FROM子句中使用视图来代替表
执行结果
product_type | cnt_product
--------------+------------
衣服 | 2
办公用品 | 2
厨房用具 | 4
通过上述视图ProductSum定义的主体（SELECT语句）我们可
以看出，该视图将根据商品种类（product_type）汇总的商品数量
（cnt_product）作为结果保存了起来。这样如果大家在工作中需要
频繁进行汇总时，就不用每次都使用GROUP BY和COUNT函数写
SELECT语句来从Product表中取得数据了。创建出视图之后，就可
5-1 视图 153 ●
以通过非常简单的SELECT语句，随时得到想要的汇总结果。并且如前
所述，Product表中的数据更新之后，视图也会自动更新，非常灵活方便。
之所以能够实现上述功能，是因为视图就是保存好的SELECT语句。
定义视图时可以使用任何SELECT语句，既可以使用WHERE、GROUP
BY、HAVING，也可以通过SELECT *来指定全部列。
■使用视图的查询
在FROM子句中使用视图的查询，通常有如下两个步骤：
① 首先执行定义视图的SELECT语句
② 根据得到的结果，再执行在FROM子句中使用视图的SELECT语句
注A
但是根据实现方式的不同，也存 也就是说，使用视图的查询通常需要执行2条以上的SELECT语句A。
在内部使用视图的SELECT语句
本身进行重组的DBMS。 这里没有使用“2条”而使用了“2条以上”，是因为还可能出现以视图为
KEYWORD 基础创建视图的多重视图（图5-2）。例如，我们可以像代码清单5-4那样
●多重视图 以ProductSum为基础创建出视图ProductSumJim。
图5-2 可以在视图的基础上创建视图
视图D
视图A 视图C
视图B
表
● 154 第5章 复杂查询
代码清单5-4 视图ProductSumJim
CREATE VIEW ProductSumJim (product_type, cnt_product)
AS
SELECT product_type, cnt_product
FROM ProductSum 以视图为基础创建视图
WHERE product_type = '办公用品';
-- 确认创建好的视图
SELECT product_type, cnt_product
FROM ProductSumJim;
执行结果
product_type | cnt_product
--------------+------------
办公用品 | 2
虽然语法上没有错误，但是我们还是应该尽量避免在视图的基础上创
建视图。这是因为对多数DBMS来说，多重视图会降低SQL的性能。因此，
希望大家（特别是刚刚接触视图的读者）能够使用单一视图。
法则5-3
应该避免在视图的基础上创建视图。
除此之外，在使用时还要注意视图有两个限制，接下来会给大家详细
介绍。
视图的限制① ——定义视图时不能使用 子句
ORDER BY
虽然之前我们说过在定义视图时可以使用任何SELECT语句，但其
实有一种情况例外，那就是不能使用ORDER BY子句，因此下述视图定
义语句是错误的。
-- 不能像这样定义视图
CREATE VIEW ProductSum (product_type, cnt_product)
AS
SELECT product_type, COUNT(*)
FROM Product
GROUP BY product_type
ORDER BY product_type; 定义视图时不能使用ORDER BY子句
5-1 视图 155 ●
为什么不能使用ORDER BY子句呢？这是因为视图和表一样，数据
行都是没有顺序的。实际上，有些DBMS在定义视图的语句中是可以使
注A 用ORDER BY子句的A，但是这并不是通用的语法。因此，在定义视图
例如，在PostgreSQL中上述SQL
时请不要使用ORDER BY子句。
语句就没有问题，可以执行。
法则5-4
定义视图时不要使用ORDER BY子句。
视图的限制② ——对视图进行更新
之前我们说过，在SELECT语句中视图可以和表一样使用。那么，
对于INSERT、DELETE、UPDATE这类更新语句（更新数据的SQL）
来说，会怎么样呢？
实际上，虽然这其中有很严格的限制，但是某些时候也可以对视图进
行更新。标准SQL中有这样的规定：如果定义视图的SELECT语句能够
满足某些条件，那么这个视图就可以被更新。下面就给大家列举一些比较
具有代表性的条件。
①SELECT子句中未使用DISTINCT
②FROM子句中只有一张表
③ 未使用GROUP BY子句
④ 未使用HAVING子句
在前几章的例子中，FROM子句里通常只有一张表。因此，大家可能
会觉得②中的条件有些奇怪，但其实FROM子句中也可以并列使用多张表。
大家在学习完下一章“表结合”的操作之后就明白了。
其他的条件大多数都与聚合有关。简单来说，像这次的例子中使用的
ProductSum那样，使用视图来保存原表的汇总结果时，是无法判断
如何将视图的更改反映到原表中的。
例如，对ProductSum视图执行如下INSERT语句。
INSERT INTO ProductSum VALUES ('电器制品', 5);
● 156 第5章 复杂查询
但是，上述INSERT语句会发生错误。这是因为视图ProductSum
是通过GROUP BY子句对原表进行汇总而得到的。为什么通过汇总得到
的视图不能进行更新呢？
视图归根结底还是从表派生出来的，因此，如果原表可以更新，那么
视图中的数据也可以更新。反之亦然，如果视图发生了改变，而原表没有
进行相应更新的话，就无法保证数据的一致性了。
使用前述INSERT语句，向视图ProductSum中添加数据('电器
制品', 5)时，原表Product应该如何更新才好呢？按理说应该向表中
添加商品种类为“电器制品”的5行数据，但是这些商品对应的商品编号、
商品名称和销售单价等我们都不清楚（图5-3）。数据库在这里就遇到了麻烦。
图5-3 通过汇总得到的视图无法更新
视图ProductSum（商品合计） 视图ProductSum（商品合计）
product_type cnt_product product_type cnt_product
（商品种类） （商品数量） （商品种类） （商品数量）
衣服 2 INSERT 衣服 2
办公用品 2 办公用品 2
厨房用具 4 厨房用具 4
电器制品 5
INSERT语句
INSERT INTO ProductSum VALUES ('电器制品', 5);
INSERT
只清楚商
品种类和
添加行数
视图ProductSum（商品合计）
product_id product_name product_type sale_pricepurchase_price regist_date
（商品编号） （商品名称） （商品种类） （销售单价） （进货单价） （登记日期）
0001 T恤衫 衣服 1000 500 2009-09-20
0002 打孔器 办公用品 500 320 2009-09-11
0003 运动T恤 衣服 4000 2800
0004 菜刀 厨房用具 3000 2800 2009-09-20
0005 高压锅 厨房用具 6800 5000 2009-01-15
0006 叉子 厨房用具 500 2009-09-20
0007 擦菜板 厨房用具 880 790 2008-04-28
0008 圆珠笔 办公用品 100 2009-11-11
？ ？ 电器制品 ？ ？ ？
？ ？ 电器制品 ？ ？ ？
？ ？ 电器制品 ？ ？ ？
？ ？ 电器制品 ？ ？ ？
？ ？ 电器制品 ？ ？ ？
5-1 视图 157 ●
法则5-5
视图和表需要同时进行更新，因此通过汇总得到的视图无法进行更新。
■能够更新视图的情况
像代码清单5-5这样，不是通过汇总得到的视图就可以进行更新。
代码清单5-5 可以更新的视图
CREATE VIEW ProductJim (product_id, product_name, product_type, 
sale_price, purchase_price, regist_date)