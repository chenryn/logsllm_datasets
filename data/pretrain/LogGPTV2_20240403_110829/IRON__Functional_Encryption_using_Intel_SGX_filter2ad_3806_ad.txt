HW is that is describes the ideal functionality or oracle that models
the real (physical) world assumptions about the hardware security
properties of Intel SGX), and that an adversary shouldnâ€™t be able to
distinguish between interacting with the real world hardware and
the ideal functionality. This allows us to simulate the adversaryâ€™s
interaction with HW in a proof of security, but it is a very strong
assumption on the secure hardware being used, particularly since
the adversary has access to the physical hardware and can closely
monitor its behavior. A weaker assumption, stated informally, is
simply that the adversary gains no more â€œuseful" information from
querying the real hardware on some input beyond the outputs
specified by HW, without requiring that an adversaryâ€™s physical
interactions with HW cannot be simulated. Our security proof of
the main system/construction we have presented assumes the first
model. In Appendix D we explore the second model, though it turns
out that we cannot achieve the standard non-interactive notion of
functional encryption in this stronger security model.
Related models. Barbosa et. al. [7] define a similar interface/ideal
functionality to represent systems like SGX that perform attested
computation. Compared to their model, our model sacrifices some
generality for a simpler syntax that more closely models SGX. Their
security model uses a game-based definition of attested computa-
tion, similar to the second security model we discuss in the Appen-
dix.
Pass, Shi, and Tramer [48] also define an ideal functionality for
attested computation in the Universal Composability framework
[14]. The goal of their model is to explore composable security for
protocols using secure processors performing attested computation.
Similar to [7] their syntax is more abstract that ours, e.g. does
not distinguish between local and remote attestation. However,
their hardware security model is more similar in that it allows the
hardware functionality to be simulated. A key difference is that their
simulator does not possess the hardwareâ€™s secret signing key(s) used
to generate attestations. Our simulator will be given the hardwareâ€™s
secret keys, similar to trapdoor information in CRS-model proofs.
Bahmani et al [6] adapts the SGX model of [7] to deal with
sequences of SGX computations that may be stateful, asynchronous,
and interleaved with other computations. Their model is called
labelled attested computation, which refers to labels being appended
to every enclave input/output in order to track state. This capability
is implicitly captured in our model as well.
5.2 Functional Encryption
We adapt the definition of functional encryption to fit the com-
putational model of our system. Interaction with local enclaves is
modeled as calls to the HW functionality defined in Definition 5.1.
Communication with the remote KME is modeled with a sepa-
rate oracle KM(Â·). We allow for a preprocessing phase which runs
the setup for all HW instances. A functional encryption scheme
â„±â„° for a family of programs ğ’« and message space â„³ consists
of algorithms â„±â„° = (FE.Setup, FE.Keygen, FE.Enc, FE.DecSetup,
FE.Dec) defined as follows.
â€¢ FE.Setup(1Î» ): On input security parameter Î» (in unary), out-
put the master public key mpk and the master secret key
msk.
â€¢ FE.Keygen(msk, P ): On input the master secret key msk and
a program P âˆˆ ğ’«, output the secret key skP for P.
â€¢ FE.Enc(mpk, msg): On input the master public key mpk and
an input message msg âˆˆ â„³, output a ciphertext ct.
â€¢ FE.DecSetupKM(Â·),HW(Â·) (mpk): The decryption node setup
algorithm has access to the KM oracle and the HW oracles.
On input the master public key mpk, output a handle hdl to
be used by the actual decryption algorithm.
â€¢ FE.DecHW(Â·) (hdl, skP , ct): On input a handle hdl for an en-
clave, a secret key skP and a ciphertext ct and outputs P (msg)
or âŠ¥. This algorithm has access to the interface for all the
algorithms of the secure hardware HW.
(cid:17)
all P âˆˆ ğ’« and all msg âˆˆ â„³, the probability for FE.DecHW(Â·)(cid:16)
Correctness. A functional encryption scheme â„±â„° is correct if for
hdl,
to be not equal to P (msg) is negl(Î»), where (mpk, msk) â†
skP , ct
FE.Setup(1Î» ), skP â† FE.Keygen(msk, P ), ct â† FE.Enc(mpk, msg)
and hdl â† FE.DecSetupKM(Â·),HW(Â·) (mpk) and the probability is
taken over the random coins of the probabilistic algorithms FE.Setup,
FE.Keygen, FE.Enc, FE.DecSetup.
Session D1:  Functional Encryption and ObfuscationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA772Non-interaction. Non-interaction is central to the standard no-
tion of functional encryption. Our construction of hardware assisted
FE requires a one-time setup operation where the decryptorâ€™s hard-
ware contacts the KME to receive a secret key. However, this in-
teraction only occurs once in the setup of a decryption node, and
thereafter decryption is non-interactive. To capture this restriction
on interaction we add to the standard FE algorithms an additional
algorithm FE.DecSetup, which is given oracle access to a Key Man-
ager KM(Â·). The decryption algorithm FE.Dec is only given access
to HW.
Security definition. Here, we define a strong simulation-based
security of F E similar to [2, 11, 26]. In this security model, a polyno-
mial time adversary will try to distinguish between the real world
and a â€œsimulatedâ€ world. In the real world, algorithms work as
defined in the construction. In the simulated world, we will have
to construct a polynomial time simulator which has to do the ex-
periment given only the program queries P made by the adversary
and the corresponding results P (msg).
Definition 5.2 (SimSecurity-FE). Consider a stateful simulator ğ’®
and a stateful adversary ğ’œ. Let Umsg (Â·) denote a universal oracle,
such that Umsg (P ) = P (msg).
Both games begin with a pre-processing phase executed by the
environment. In the ideal game, pre-processing is simulated by ğ’®.
Now, consider the following experiments.
â„±â„° (1Î» ) :
Expreal
(mpk, msk) â† FE.Setup(1Î» )
(msg) â† ğ’œFE.Keygen(msk,Â·) (mpk)
ct â† FE.Enc(mpk, msg)
Î± â† ğ’œFE.Keygen(msk,Â·),HW,KM(Â·) (mpk, ct)
Output (msg, Î± )
Expideal
â„±â„° (1Î» ) :
mpk â† ğ’® (1Î» )
msg â† ğ’œğ’® (Â·) (mpk)
ct â† ğ’®Umsg (Â·) (1Î», 1|msg| )
Î± â† ğ’œğ’®Umsg (Â·) (Â·) (mpk, ct)
Output (msg, Î± )
In the above experiment, oracle calls by ğ’œ to the key-generation,
HW and KM oracles are all simulated by the simulator ğ’®Umsg (Â·) (Â·).
An F E scheme is simulation-secure against adaptive adversaries if
there is a stateful probabilistic polynomial time simulator ğ’® that
on each FE.Keygen query P queries its oracle Umsg (Â·) only on the
same P (and hence learn just P (msg)), such that for every proba-
bilistic polynomial time adversary ğ’œ the following distributions
are computationally indistinguishable.
Exprealâ„±â„° (1Î» )
câ‰ˆ Expidealâ„±â„° (1Î» )
Note that the above definition handles one message only. This
can be extended to a definition of security for many messages by
allowing the adversary to adaptively output many messages while
providing him the ciphertext for a message whenever he outputs
one. Here, the simulator will have an oracle Umsgi (Â·) for every msgi
output by the adversary.
Simulating HW. As previously discussed, we let the simulator
intercept all the adversaryâ€™s queries to HW and return simulated
responses, just as in [19]. If we do not allow simulation of HW, it
is impossible to achieve Definition 5.2. In Appendix D we provide
a modified FE definition to allow minimal interaction8 with an effi-
cient KM oracle during every run of FE.Dec, and give a construction
that realizes this modified FE in the stronger security model.
6 FORMAL CONSTRUCTION
We present here the formal description of our FE system using the
syntax of the HW model from Definition 5.1. The trusted authority
platform T A and decryption node platform DN each have access to
instances of HW. Let PKE denote an IND-CCA2 secure public key
encryption scheme (Definition B.3) and let S denote an existentially
unforgeable signature scheme (Definition B.2).
Pre-processing phase. T A and DN run HW.Setup(1Î» ) for their
HW instances and record the output params.
FE.SetupHW(1Î» ). The key manager enclave program QK ME
is defined as follows. The value tagDE, the measurement of the
program QDE, is hardcoded in the static data of QK ME. Let state
denote an internal state variable.
QK ME:
â€¢ On input (â€œinit", 1Î» ):
(1) Run (pkpke, skpke) â† PKE.KeyGen(1Î» ) and (vksign, sksign) â†
S.KeyGen(1Î» )
(cid:17)
(cid:16)
mdhdl, tagQ, in, out, Ïƒ
(2) Update state to (skpke, sksign, vksign) and output (pkpke, vksign)
â€¢ On input (â€œprovision", quote, params):
(1) Parse quote =
(2) Parse in = (â€œinit setupâ€, vksign) and check if vksign matches with
(3) Parse out = (sid, pk) and run b â† HW.QuoteVerify(params,
tagDE. If not, output âŠ¥.
the one in state. If not, output âŠ¥.
quote) on quote. If b = 0 output âŠ¥.
, check that tagQ =
(4) Retrieve skpke from state and compute ctsk = PKE.Enc(pk,
skpke) and Ïƒsk = S.Sign(sksign, (sid, ctsk )) and output (sid,
ctsk, Ïƒsk ).
â€¢ On input (â€œsign", msg):
Compute sig â† S.Sign(sksign, msg) and output sig.
Run hdlK ME â† HW.Load(params, QK ME ) and (pkpke, vksign) â†
HW.Run(hdlK ME , (â€œinit", 1Î» )). Output the master public key mpk :=
(pkpke, vksign) and the master secret key msk := hdlK ME.
FE.KeygenHW (msk, P ). Parse msk = hdlK ME as a handle to
HW.Run. Derive tagP and call sig â† HW.Run(hdlK ME , (â€œsign",
tagP )). Output skp := sig.
FE.Enc(mpk, msg). Parse mpk = (pk, vk). Compute ct â†
PKE.Enc(pk, msg) and output ct.
FE.DecSetupHW,KM(Â·) (skP , ct). The decryption enclave program
QDE is defined as follows. The security parameter Î» is hardcoded
into the program.
QDE:
â€¢ On input (â€œinit setup", vksign):
(1) Run (pkra, skra) â† PKE.KeyGen(1Î» ).
(2) Generate a session ID, sid â† {0, 1}Î».
(3) Update state to (sid, skra, vksign), and output (sid, pkra).
8Allowing unbounded interaction would lead to trivial constructions where KM simply
decrypts the ciphertext and returns the function of the message.
Session D1:  Functional Encryption and ObfuscationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA773exists for sid, output âŠ¥.
0, output âŠ¥.
â€¢ On input (â€œcomplete setup", sid, ctsk, Ïƒsk ):
(1) Look up the state to obtain the entry (sid, skra, vksign). If no entry
(2) Verify the signature b â† S.Verify(vksign, Ïƒsk, (sid, ctsk )). If b =
(3) Run m â† PKE.dec(skra, ctsk ) and parse m = (skpke).
(4) Add the tuple (skpke, vksign) to state9.
â€¢ On input (â€œprovision", report, sig):
(1) Check to see that the setup has been completed, i.e. that state
(cid:16)
(3) Parse report =
mdhdl, tagQ, in, out, mac
(2) Check to see that the report has been verified, i.e. that state
and compute b â†
contains the tuple (skpke, vksign). If not, output âŠ¥.
(cid:17)
contains the tuple (1, report). If not, output âŠ¥.
S.Verify(vksign, sig, tagQ ). If b = 0, output âŠ¥.
Else, output âŠ¥.
(4) Parse out as (sid, pk). If b = 1 output (sid, PKE.Enc(pk, skpke)).
Run hdlDE â† HW.Load(params, QDE ). Parse mpk = (skpke,
vksign) and call quote â† HW.Run&QuoteskHW (hdlDE , â€œinit setup",
vksign). Query KM(quote), which internally runs (sid, ctsk , Ïƒsk ) â†
HW.Run(hdlK ME , (â€œprovision", quote, params))10. And now, call
HW.Run(hdlDE , (â€œcomplete setup", sid, ctsk , Ïƒsk )). Output hdlDE.
FE.DecHW(Â·) (hdl, skP , ct). Define a function enclave program
parameterized by P.
QF E (P ):
â€¢ On input (â€œinit"):
(1) Run (pkla, skla) â† PKE.KeyGen(1Î» ).
(2) Generate a session ID, sid â† {0, 1}Î».
(3) Update state to (sid, skla), and output (sid, pkla).
â€¢ On input (â€œrun", reportsk, ctmsĞ´ ):
(1) Check to see that the report has been verified, i.e. that state
(cid:17)
contains the tuple (1, reportsk ). If not, output âŠ¥.
(cid:16)
(2) Parse reportsk =
mdhdl, tagQ, in, out, mac
. Parse out as (sid,
ctkey ).
for sid, output âŠ¥.
x â† PKE.dec(skpke, ctmsĞ´ ).
(3) Look up the state to obtain the entry (sid, skla). If no entry exists
(4) Compute skpke â† PKE.dec(skra, ctkey ) and use it to decrypt
(5) Run P on x and record the output out := P (x ). Output out.
Run hdlP â† HW.Load(params, QF E (P )) and call report â†
HW.Run&Reportskreport (hdlP , â€œinit"). Run HW.ReportVerifyskreport
(hdlDE , report) with hdlDE = hdl and then call reportsk â†
HW.Run&Report(hdlDE , (â€œprovision", report, sig)) with sig = skP .
Finally, run HW.ReportVerifyskreport (hdlP , reportsk ) and call out â†
HW.Run(hdlP , â€œrun", reportsk , ctmsĞ´ ) with ctmsĞ´ = ct. Output
out.
7 SECURITY
We first explain the crux of our security proof here. More details
will follow.
We construct a simulator ğ’® which can simulate FE.Keygen, HW,
KM oracles and simulate the challenge ciphertext for the challenge
message msgâˆ— provided by the adversary ğ’œ. The only information
9vksign is already in state as part of the outputs of the previous â€œinit setupâ€ phase, but
it is useful store and use this tuple as result of a successfully completed setup.
10We could use HW.Run&Quote here instead of explicitly creating the signature Ïƒk .
If we do that, the verification step in DE would involve using the Intel Attestation
Service.
that ğ’® will get about msgâˆ— other than its length is the access to
the Umsgâˆ— oracle which reveals P (msgâˆ—) for the Pâ€™s queried by ğ’œ
to FE.Keygen. At a high level, the proof idea is simple: ğ’® encrypts
zeros as the the challenge ciphertext ctâˆ— and FE.Keygen is simu-
lated honestly. In the ideal experiment, ğ’® intercepts ğ’œâ€™s queries to
HW and provides simulated responses. It can use its Umsgâˆ— oracle
to get P (msgâˆ—) and simply send this back to ğ’œ as the simulated
HW output. If ğ’œ queries HW on any ciphertexts that do not match
the challenge ciphertext ctâˆ—, ğ’® can decrypt them honestly since it
possesses msk. Since ğ’® has to modify the program descriptions in
enclaves, we provide ğ’® access to the HW keys skreport and skquote
to produce reports and quotes.
Despite the apparent simplicity, the following subtleties make
the proof of security more challenging than on first sight:
(1) The simple proof sketch does not account for all of ğ’œâ€™s
interaction with HW between sending ctâˆ— and receiving
back P (msgâˆ—). HW communicates through ğ’œ as a proxy. ğ’œ
might even tamper with these intermediate messages and