Let’s break down the important parts of the script. First, we define some helper
functions to read data from the file. The function read_bytes() ➊ reads a fixed number of
||||||||||||||||||||
||||||||||||||||||||
bytes from the file specified as a parameter. If not enough bytes are in the file to satisfy the
read, an exception is thrown to indicate an error ➋. We also define a function read_int() ➌
to read a 4-byte integer from the file in network byte order where the most significant byte
of the integer is first in the file, as well as define a function to read a single byte ➍. In the
main body of the script, we open a file passed on the command line and first read a 4-byte
value ➎, which we expect is the magic value BINX. Then the code enters a loop ➏ while
there’s still data to read, reading out the length, the two unknown values, and finally the
data and then printing the values to the console.
When you run the script in Listing 5-9 and pass it the name of a binary file to open, all
data from the file should be parsed and no errors generated if our analysis that the first 4-
byte block was the length of the data sent on the network is correct. Listing 5-10 shows
example output in Python 3, which does a better job of displaying binary strings than
Python 2.
$ python3 read_protocol.py bytes_outbound.bin
Magic: b'BINX'
Len: 15, Unk1: 1139, Unk2: 0, Data: b'\x03bob\x08user-box\x00'
Len: 18, Unk1: 1415, Unk2: 3, Data: b'\x03bob\x0cHow are you?'
Len: 28, Unk1: 2275, Unk2: 3, Data: b"\x03bob\x16This is nice isn't it?"
Len: 1, Unk1: 6, Unk2: 6, Data: b''
Len: 19, Unk1: 1145, Unk2: 5, Data: b'\x05alice\x00\x00\x00\x03\x03bob\x03Woo'
Len: 21, Unk1: 1677, Unk2: 2, Data: b"\x13I'm going away now!"
Listing 5-10: Example output from running Listing 5-9 against a binary file
Handling Inbound Data
If you ran Listing 5-9 against an exported inbound data set, you would immediately get an
error because there’s no magic string BINX in the inbound protocol, as shown in Listing 5-
11. Of course, this is what we would expect if there were a mistake in our analysis and the
length field wasn’t quite as simple as we thought.
$ python3 read_protocol.py bytes_inbound.bin
Magic: b'\x00\x00\x00\x02'
Length: 1, Unknown1: 16777216, Unknown2: 0, Data: b''
Traceback (most recent call last):
  File "read_protocol.py", line 31, in 
    data = read_bytes(f, length - 1)
  File "read_protocol.py", line 9, in read_bytes
    raise Exception("Not enough bytes in stream")
Exception: Not enough bytes in stream
Listing 5-11 Error generated by Listing 5-9 on inbound data
We can clear up this error by modifying the script slightly to include a check for the
magic value and reset the file pointer if it’s not equal to the string BINX. Add the following
line just after the file is opened in the original script to reset the file pointer to the start if
the magic value is incorrect.
if read_bytes(f, 4) != b'BINX': f.seek(0)
Technet24
||||||||||||||||||||
||||||||||||||||||||
Now, with this small modification, the script will execute successfully on the inbound
data and result in the output shown in Listing 5-12.
$ python3 read_protocol.py bytes_inbound.bin
Len: 2, Unk1: 1, Unk2: 1, Data: b'\x00'
Len: 36, Unk1: 3146, Unk2: 3, Data: b"\x03bob\x1eI've just joined from user-box"
Len: 18, Unk1: 1415, Unk2: 3, Data: b'\x03bob\x0cHow are you?'
Listing 5-12: Output of modified script on inbound data
Digging into the Unknown Parts of the Protocol
We can use the output in Listing 5-10 and Listing 5-12 to start delving into the unknown
parts of the protocol. First, consider the field labeled Unk1. The values it takes seem to be
different for every packet, but the values are low, ranging from 1 to 3146.
But the most informative parts of the output are the following two entries, one from the
outbound data and one from the inbound.
OUTBOUND: Len: 1, Unk1: 6, Unk2: 6, Data: b''
INBOUND:  Len: 2, Unk1: 1, Unk2: 1, Data: b'\x00'
Notice that in both entries the value of Unk1 is the same as Unk2. That could be a
coincidence, but the fact that both entries have the same value might indicate something
important. Also notice that in the second entry the length is 2, which includes the Unk2 value
and a 0 data value, whereas the length of the first entry is only 1 with no trailing data after
the Unk2 value. Perhaps Unk1 is directly related to the data in the packet? Let’s find out.
Calculating the Checksum
It’s common to add a checksum to a network protocol. The canonical example of a
checksum is just the sum of all the bytes in the data you want to check for errors. If we
assume that the unknown value is a simple checksum, we can sum all the bytes in the
example outbound and inbound packets I highlighted in the preceding section, resulting in
the calculated sum shown in Table 5-2.
Table 5-2: Testing Checksum for Example Packets
Unknown value
Data bytes
Sum of data bytes
6
6
6
1
1, 0
1
Although Table 5-2 seems to confirm that the unknown value matches our expectation
of a simple checksum for very simple packets, we still need to verify that the checksum
works for larger and more complex packets. There are two easy ways to determine whether
we’ve guessed correctly that the unknown value is a checksum over the data. One way is to
||||||||||||||||||||
||||||||||||||||||||
send simple, incrementing messages from a client (like A, then B, then C, and so on),
capture the data, and analyze it. If the checksum is a simple addition, the value should
increment by 1 for each incrementing message. The alternative would be to add a function
to calculate the checksum to see whether the checksum matches between what was
captured on the network and our calculated value.
To test our assumptions, add the code in Listing 5-13 to the script in Listing 5-7 and
add a call to it after reading the data to calculate the checksum. Then just compare the
value extracted from the network capture as Unk1 and the calculated value to see whether
our calculated checksum matches.
def calc_chksum(unk2, data):
    chksum = unk2
    for i in range(len(data)):
        chksum += ord(data[i:i+1])
    return chksum
Listing 5-13: Calculating the checksum of a packet
And it does! The numbers calculated match the value of Unk1. So, we’ve discovered the
next part of the protocol structure.
Discovering a Tag Value
Now we need to determine what Unk2 might represent. Because the value of Unk2 is
considered part of the packet’s data, it’s presumably related to the meaning of what is
being sent. However, as we saw at ➍ in Listing 5-7, the value of Unk2 is being written to the
network as a single byte value, which indicates that it’s actually separate from the data.
Perhaps the value represents the Tag part of a TLV pattern, just as we suspect that Length
is the Value part of that construction.
To determine whether Unk2 is in fact the Tag value and a representation of how to
interpret the rest of the data, we’ll exercise the ChatClient as much as possible, try all
possible commands, and capture the results. We can then perform basic analysis
comparing the value of Unk2 when sending the same type of command to see whether the
value of Unk2 is always the same.
For example, consider the client sessions in Listing 5-4, Listing 5-5, and Listing 5-6. In
the session in Listing 5-5, we sent two messages, one after another. We’ve already
analyzed this session using our Python script in Listing 5-10. For simplicity, Listing 5-14
shows only the first three capture packets (with the latest version of the script).
Unk2: 0➊, Data: b'\x03bob\x08user-box\x00'
Unk2: 3➋, Data: b'\x03bob\x0cHow are you?'
Unk2: 3➌, Data: b"\x03bob\x16This is nice isn't it?"
*SNIP*
Listing 5-14: The first three packets from the session represented by Listing 5-5
Technet24
||||||||||||||||||||
||||||||||||||||||||
The first packet ➊ doesn’t correspond to anything we typed into the client session in
Listing 5-5. The unknown value is 0. The two messages we then sent in Listing 5-5 are
clearly visible as text in the Data part of the packets at ➋ and ➌. The Unk2 values for both of
those messages is 3, which is different from the first packet’s value of 0. Based on this
observation, we can assume that the value of 3 might represent a packet that is sending a
message, and if that’s the case, we’d expect to find a value of 3 used in every connection
when sending a single value. In fact, if you now analyze a different session containing
messages being sent, you’ll find the same value of 3 used whenever a message is sent.
NOTE
At this stage in my analysis, I’d return to the various client sessions and try to correlate the
action I performed in the client with the messages sent. Also, I’d correlate the messages I
received from the server with the client’s output. Of course, this is easy when there’s likely to be
a one-to-one match between the command we use in the client and the result on the network.
However, more complex protocols and applications might not be that obvious, so you’ll have to
do a lot of correlation and testing to try to discover all the possible values for particular parts of
the protocol.
We can assume that Unk2 represents the Tag part of the TLV structure. Through
further analysis, we can infer the possible Tag values, as shown in Table 5-3.
Table 5-3: Inferred Commands from Analysis of Captured Sessions
Command
number
Direction
Description
0
Outbound
Sent when client connects to server.
1
Inbound
Sent from server after client sends command '0' to the
server.
2
Both
Sent from client when /quit command is used. Sent by server
in response.
3
Both
Sent from client with a message for all users. Sent from
server with the message from all users.
5
Outbound
Sent from client when /msg command is used.
6
Outbound
Sent from client when /list command is used.
7
Inbound
Sent from server in response to /list command.
||||||||||||||||||||
||||||||||||||||||||
NOTE
We’ve built a table of commands but we still don’t know how the data for each of these
commands is represented. To further analyze that data, we’ll return to Wireshark and develop
some code to dissect the protocol and display it in the GUI. It can be difficult to deal with simple
binary files, and although we could use a tool to parse a capture file exported from Wireshark,
it’s best to have Wireshark handle a lot of that work.
Developing Wireshark Dissectors in Lua
It’s easy to analyze a known protocol like HTTP with Wireshark because the software can
extract all the necessary information. But custom protocols are a bit more challenging: to
analyze them, we’ll have to manually extract all the relevant information from a byte
representation of the network traffic.
Fortunately, you can use the Wireshark plug-in Protocol Dissectors to add additional
protocol analysis to Wireshark. Doing so used to require building a dissector in C to work
with your particular version of Wireshark, but modern versions of Wireshark support the
Lua scripting language. The scripts you write in Lua will also work with the tshark
command line tool.
This section describes how to develop a simple Lua script dissector for the
SuperFunkyChat protocol that we’ve been analyzing.
NOTE
Details about developing in Lua and the Wireshark APIs are beyond the scope of this book. For
more 
information 
on 
how 
to 
develop 
in 
Lua, 
visit 
its 
official 
website 
at
https://www.lua.org/docs.html. The Wireshark website, and especially the Wiki, are the best
places to visit for various tutorials and example code (https://wiki.wireshark.org/Lua/).
Before developing the dissector, make sure your copy of Wireshark supports Lua by
checking the About Wireshark dialog at Help ▸ About Wireshark. If you see the word
Lua in the dialog, as shown in Figure 5-10, you should be good to go.
Technet24
||||||||||||||||||||
||||||||||||||||||||
Figure 5-10: The Wireshark About dialog showing Lua support
NOTE
If you run Wireshark as root on a Unix-like system, Wireshark will typically disable Lua
support for security reasons, and you’ll need to configure Wireshark to run as a nonprivileged
user to capture and run Lua scripts. See the Wireshark documentation for your operating
system to find out how to do so securely.
You can develop dissectors for almost any protocol that Wireshark will capture,
including TCP and UDP. It’s much easier to develop dissectors for UDP protocols than it
is for TCP, because each captured UDP packet typically has everything needed by the
dissector. With TCP, you’ll need to deal with such problems as data that spans multiple
packets (which is exactly why we needed to account for length block in our work on
SuperFunkyChat using the Python script in Listing 5-9). Because UDP is easier to work
||||||||||||||||||||
||||||||||||||||||||
with, we’ll focus on developing UDP dissectors.
Conveniently enough, SuperFunkyChat supports a UDP mode by passing the --udp
command line parameter to the client when starting. Send this flag while capturing, and
you should see packets similar to those shown in Figure 5-11. (Notice that Wireshark
mistakenly tries to dissect the traffic as an unrelated GVSP protocol, as displayed in the
Protocol column ➊. Implementing our own dissector will fix the mistaken protocol
choice.)
Figure 5-11: Wireshark showing captured UDP traffic
One 
way 
to 
load 
Lua 
files 
is 
to 
put 
your 
scripts 
in 
the
%APPDATA%\Wireshark\plugins 
directory 
on 
Windows 
and 
in 
the
~/.config/wireshark/plugins directory on Linux and macOS. You can also load a Lua script
by specifying it on the command line as follows, replacing the path information with the
location of your script:
wireshark -X lua_script:
If there’s an error in your script’s syntax, you should see a message dialog similar to
Figure 5-12. (Granted, this isn’t exactly the most efficient way to develop, but it’s fine as
long as you’re just prototyping.)
Technet24
||||||||||||||||||||
||||||||||||||||||||
Figure 5-12: The Wireshark Lua error dialog
Creating the Dissector
To create a protocol dissector for the SuperFunkyChat protocol, first create the basic shell
of the dissector and register it in Wireshark’s list of dissectors for UDP port 12345. Copy
Listing 5-15 into a file called dissector.lua and load it into Wireshark along with an
appropriate packet capture of the UDP traffic. It should run without errors.
dissector.lua
   -- Declare our chat protocol for dissection
➊ chat_proto = Proto("chat","SuperFunkyChat Protocol")
   -- Specify protocol fields
➋ chat_proto.fields.chksum = ProtoField.uint32("chat.chksum", "Checksum",
                                                base.HEX)
   chat_proto.fields.command = ProtoField.uint8("chat.command", "Command")
   chat_proto.fields.data = ProtoField.bytes("chat.data", "Data")
   -- Dissector function
   -- buffer: The UDP packet data as a "Testy Virtual Buffer"
   -- pinfo: Packet information
   -- tree: Root of the UI tree
➌ function chat_proto.dissector(buffer, pinfo, tree)
       -- Set the name in the protocol column in the UI
    ➍ pinfo.cols.protocol = "CHAT"
       -- Create sub tree which represents the entire buffer.
    ➎ local subtree = tree:add(chat_proto, buffer(),
                                "SuperFunkyChat Protocol Data")
       subtree:add(chat_proto.fields.chksum, buffer(0, 4))
       subtree:add(chat_proto.fields.command, buffer(4, 1))
       subtree:add(chat_proto.fields.data, buffer(5))
   end
   -- Get UDP dissector table and add for port 12345
➏ udp_table = DissectorTable.get("udp.port")
   udp_table:add(12345, chat_proto)
Listing 5-15: A basic Lua Wireshark dissector
When the script initially loads, it creates a new instance of the Proto class ➊, which
represents an instance of a Wireshark protocol and assigns it the name chat_proto. Although
||||||||||||||||||||
||||||||||||||||||||
you can build the dissected tree manually, I’ve chosen to define specific fields for the
protocol at ➋ so the fields will be added to the display filter engine, and you’ll be able to
set a display filter of chat.command == 0 so Wireshark will only show packets with command 0.
(This technique is very useful for analysis because you can filter down to specific packets
easily and analyze them separately.)
At ➌, the script creates a dissector() function on the instance of the Proto class. This
dissector() will be called to dissect a packet. The function takes three parameters:
• A buffer containing the packet data that is an instance of something Wireshark calls a
Testy Virtual Buffer (TVB).
• A packet information instance that represents the display information for the dissection.
• The root tree object for the UI. You can attach subnodes to this tree to generate your
display of the packet data.
At ➍, we set the name of the protocol in the UI column (as shown in Figure 5-11) to
CHAT. Next, we build a tree of the protocol elements ➎ we’re dissecting. Because UDP
doesn’t have an explicit length field, we don’t need to take that into account; we only need
to extract the checksum field. We add to the subtree using the protocol fields and use the
buffer parameter to create a range, which takes a start index into the buffer and an optional