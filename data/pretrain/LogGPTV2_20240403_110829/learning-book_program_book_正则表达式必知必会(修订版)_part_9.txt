6.3字符串边界
单词边界可以用来进行与单词有关的位置匹配（单词的开头、
单词的结束、整个单词等）。字符串边界有着类似的用途，只不过是
用来进行与字符串有关的位置匹配面已（字符串的开头、字符串的
结束、整个字符串等）。用来定义字符串边界的元字符有两个：一个
是用来定义字符串开头的^，另一个是用来定义字符串结尾的$。
注意还记得吗？我们在第3章里已经见识过元字符了，但那
时的它是一个用来对字符集合进行“求非”操作的元字符。那
它还怎么用来表明一个字符事的开头呢？
是几个有着多种用途的元字符之一。只有当它出现在一个字
符集合里（被放在[和]之间）并紧跟在左方括号[的后面时。
它才能发挥“求非”作用。如果是在一个字符集合的外面并位
于一个模式的开头，“将匹配字符事的开头。
为了演示字符串边界的用法，下面准备了一个例子。合法的XML文
档都必须以标签开头并有一些其他属性（比如一个版本号，如
）。下面这个简单的测试可以检查一段文本是
否是一篇XML文档：
文本
cwsdl:def initions targetNamespace=*http: //tips.cf *
xmlns:inp1=*http://tips,cf* xmlns:intf=*http: //tips cf*
deos-ax/6uo*ousede*tux/ / :d11u,=deosouoede:suwx
正则表达式
结果
匹配？>。
这是一个非常不准确的测试。在下面的例子里，上例中的模式虽然
匹配到了一个XML文档的开头部分，但位置却完全不对。它匹配到的语
句位于文档的第2行而不是第1行。
文本
This is bad, real bad!
结果
This is bad, real bad1
匹配到的是整个文本的第2行。虽然它也是XML文
档的开始标签，但因为出现在文本的第2行，所以这份文档肯定不是一份
合法的XML文档，把它当作一份XML文档来处理会导致种种间题。
这里需要的是一个能够确保被匹配到的标签出现在字符串最
开始处的测试，而这正是元字符大显身手的地方，如下所示：
文本
S1
---
## Page 66
56第6章位置匹配
结果
xnlns:impl=*http://tips.cf* xnlns:intf=*http://tips.of*
xnlns:apachesoap=*http: //xn1 apache org/xm1 -soap*
分析
匹配一个字符串的开头位置，所以~\s*将匹配一个字符串的开头位
置和随后的零个或多个空白字符（这解决了标签前允许有空格、
制表符、换行符等空白字符的问题）。作为一个整体，模式
^\s*不仅能正确地匹配一个位置正确的标签，还能
对合法的空白字符做出妥善处理。
?
提示虽然模式\s*解决了上例中的问题，但那
只是因为这个例子里的原始文本并不完整而已，如果这段原始
文本是一份完整的XML文档，这个例子将变成一个“贪要型”
元字符的典型示例，还好，我们已经知道解决“贪要型”元字
符问题的最佳办法是把.*替换为.*？。
除了位置上的差异，$的用法与完全一样。比如说，在一份Web页面
里，标签的后面不应该再有任何实际内容，而这一点可以用下面
这个模式来检查：
正则表达式
$$1
分析
我们用了4个字符集合来分别匹配H、T、M、L等4个字符（这样就可
以对这几个字符的各种大小写组合形式进行处理了），\s*$匹配一个字符
串结尾处的零个或多个空白字符。
注意模式.*$是一个在语法上完全正确的正则表达式：它儿
手总能找到一个匹配，但没有任何实际用途。你能分析出这个
模式将匹配什么以及它在什么情况下会我不到任何匹配吗？
---
## Page 67
6.3宇符事边界
57
分行匹配模式
我们刚刚讲过，匹配一个字符串的开头，$匹配一个字符串的结尾。
但这一结论并非绝对正确，它还有一个例外或者说有一种改变这种行为
的办法。
有许多正则表达式都支持使用一些特殊的元字符去改变另外一些元
字符行为的做法，用来启用分行匹配模式（multilinemode）的（?m）记号
就是一个能够改变其他元字符行为的元字符序列。分行匹配模式将使得
正则表达式引擎把行分隔符当作一个字符串分隔符来对待。在分行匹配
模式下，不仅匹配正常的字符串开头，还将匹配行分隔符（换行符）后
面的开始位置（这个位置是不可见的）：类似地，$不仅匹配正常的字符
串结尾，还将匹配行分隔符（换行符）后面的结束位置。
在使用时，（?m）必须出现在整个模式的最前面，就像下面这个例子
里那样。在这个例子里，我们将使用一个正则表达式把一段JavaScript代
码里的注释内容全部查找出来：
文本
function doSpel1check(form, field)(
正则表达式
(7n) ~1s*/ .*$
---
## Page 68
58
第6章
位置医配
结果
function doSpel1check(form,field){
分析
^\s*//.*$将匹配一个字符串的开始，然后是任意多个空白字符，再
后面是//（JavaScript代码里的注释标签），再往后是任意文本，最后是一
个字符串的结束。不过，这个模式只能找出第一条注释（并认为这条注
释将一直延续到文件的末尾，因为*是一个“贪婪型”元字符）。加上（?m）
前缓之后，（?m）~\s*//.*$将把换行符视为一个字符串分隔符，这样就可
以把每一行注释都匹配出来了。
警告有评多正则表达式实现不支持（?m）
注意有些正则表达式实现还支持使用\A来定义一个字符事
的开始，以\Z来定义一个字符事的结束的做法。此时，\A和\B
的作用将基本等价于和$，但请注意，VA和\B不会国为加上了
（Pm）前组而改变行为。换句话说，在跨行医配模式下使用\A
和\B的做法不会收到在分行匹配模式下使用~和$的效果
---
## Page 69
6.4小结59
6.4小结
正则表达式不仅可以用来匹配任意长度的文本块，还可以用来匹配
出现在字符串中特定位置的文本。\b用来指定一个单词边界（\B刚好相
反）。和$用来指定字符串边界（字符串的开头和字符串的结束）。如果
时，换行符将被视为一个字符串分隔符）。
---
## Page 70
第7章
使用子表达式
元字符和字符是正则表达式的基本构件，它们的用法我们已经在此
前的章节里演示过了。在这一章里，你们将学习如何运用子表达式
（subexpression）的概念对表达式进行分组和归类。
7.1什么是子表达式
我们在第5章学习了如何匹配一个字符的连续多次重复。正如之前讨
论的那样，\d+将匹配一个或多个数字字符，而https？：//将匹配http://
或https://.
在这两个例子里（事实上，是在此前见过的所有例子里），用来表明
重复次数的元字符（如？或*或（2}等）只作用于紧挨着它的前一个字符或
元字符。
我们来看一个例子。有些短语（例如Windows2000）虽然由多个单
词构成，但其实是一个整体。有许多HTML程序员喜欢让这类短语在测览
器里显示在同一行上。为了确保这一点，他们会在编写HTML文档时在这
些短语的单词之间使用非换行型空格（&nbsp;，nbsp是non-breaking space
的缩写，其含义是“不是换行符的空格”）而不是普通的空格。下面就是
一个这样的例子：
文本
He1lo, my nane is Ben&nbsp;Forta, and I am
the author of books on SOL, ColdFusion, WAP,
Windows&nbsp;&nbsp;2eee, and other subjects.
---
## Page 71
7.2子表达式61
正则表达式
&nbsp:(2,)
结果
Hello, my name is Ben&nbsp;Forta, and I an
the author of books on SOL, ColdFusion, WAP,
Windows&nbsp;&nbsp;2eee, and other subjects.
分析
&nbsp;是HTML语言中的非换行空格字符。在这里使用模式
&nbsp;{2，}的本意是希望它能把&nbsp;连续两次或更多次的重复出现
找出来，但它没能给出我们所预期的结果。为什么会这样？因为{2，}
只作用于紧挨着它的前一个字符，那是一个分号。如此一来，这个模式只
能匹配像&nbsp;;;;；这样的文本，但无法匹配&nbsp；&nbsp;
7.2子表达式
这就引出了子表达式的概念。子表达式是一个更大的表达式的一部
分：把一个表达式划分为一系列子表达式的目的是为了把那些子表达式
当作一个独立元素来使用。子表达式必须用（和）括起来。
?
提示（和）是元字符。如果需要匹配（和）本身，就必须使用它
的转又序列\（和\）。
为了演示子表达式的用法，我们来看看刚才的那个例子：
文本
Hello, my nane is Ben&nbsp;Forta, and I an
the author of books on SQL, ColdFusion, WAP
Windows&nbsp;&nbsp; 2eee, and other subjects.
正则表达式
(&nbsp;) (2,)
结果
Hello, my name is Ben&nbsp;Forta, and I am
the author of books on SQL, ColdFusion, wAP,
Windows&nbsp;&nbsp;2eee, and other subjects.
---
## Page 72
Z9
第7章使用子表达式
分析
（&nbsp;）是一个子表达式，它将被视为一个独立元素，面紧跟在它
后面的（2，）将作用于这个子表达式（不仅仅是分号）。这个模式解决了
我们的问题。
我们再来看一个例子，这次是用一个正则表达式来查找IP地址。IP
地址的格式是以英文句号分隔的四组数字，例如12.159.46.200。因为每组
数字由1个、2个或3个数字字符构成，所以这4组数字可以统一使用模式
\d（1，3）来匹配。下面就是这个例子：
文本
Pinging hog.forta.com [12.159.46.20e]
with 32 bytes of data:
正则表达式
1d(1,3)1, 1d{1,3)1.1d{1,3}1.1d{1,3}
结果
Pinging hog.forta.com [12.159.46.20e]
with 32 bytes of data:
分析
\d{1，3}在这个模式里重复了4次，它们分别匹配IP地址里的一组
数字。IP地址里的4组数字由，分隔，该字符由模式里的转义序列\.负责
匹配。