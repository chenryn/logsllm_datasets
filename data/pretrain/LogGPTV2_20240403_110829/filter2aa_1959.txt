TAKING WINDOWS 10 KERNEL 
EXPLOITATION TO THE NEXT 
LEVEL – LEVERAING WRITE-
WHAT-WHERE VULNERABILITIES 
IN CREATORS UPDATE
Whoami
• Morten Schenk
• Security Advisor, Improsec ApS
• Twitter - @blomster81
• Blog: https://improsec.com/blog/
• GitHub: https://github.com/MortenSchenk
• What to expect from this talk
• Windows 10 Kernel Exploitation on Creators Update from Low Integrity
• Lots of hex, C and memes
• 0-days!
Agenda
• Brief look at Kernel Exploitation history
• New Windows 10 Mitigations
• Arbitrary Kernel Read/Write Primitive
• KASLR information leak
• De-randomizing Page Table Entries
• Dynamic Function Location
• Executable Kernel Memory Allocation
Exploitation Concept
• Write-What-Where
• Vulnerability class
• Best case
• Write controlled value at controlled address
• Common case
• Write not controlled value at controlled address
• Leverage to obtain kernel-mode code execution
• Must know where and perhaps what
• Techniques presented may be used for other vulnerability classes as 
well
Kernel Exploitation History
Brief Look at Kernel Exploitation History
Windows 7
• Executable NonPagedPool was the default
• Kernel information leaks were available with 
NtQuerySystemInformation
• Overwrite HalDispatchTable function table with NonPagedPool
address
• Execute User-mode memory from Kernel-mode
Brief Look at Kernel Exploitation History
Windows 8.1 and Windows 10
• Windows 8.1 and Windows 10 before Anniversary Edition.
• Kernel information leaks with APIs blocked from Low Integrity.
• NonPagedPoolNx is the new standard.
• Supervisor Mode Execution Prevention is introduced.
• Kernel-mode read / write primitive is needed.
• GDI bitmap primitive.
• tagWND primitive.
Bitmap Primitive
• Information leak of Bitmap through GdiSharedHandleTable
• Overwrite size of Bitmap using Write-What-Where
• Consecutive Bitmaps can create a primitive
• SetBitmapBits overwrites data pointer of the
following Bitmap
• GetBitmapBits reads arbritrary kernel memory
• SetBitmapBits writes arbritrary kernel memory
tagWND primitive
• Information leak of Desktop Heap through 
• ulClientDelta from Win32ClientInfo
• UserHandleTable from User32!gSharedInfo
• Overwrite cbWndExtra using Write-What-Where
• Consecutive Windows can create a primitive
• SetWindowLongPtr overwrites adjacent 
tagWND.StrName pointer through ExtraBytes
• InternalGetWindowText reads arbitrary 
kernel memory
• NtUserDefSetText writes arbitrary kernel 
memory
SMEP and NX Bypass
• Page Table Entry overwrite using write primitive
KASLR Bypass
• Windows HAL Heap was in many cases static at 0xFFFFFFFFFD00000
• Offset 0x448 contained a pointer to
ntoskrnl.exe
• SIDT instruction leaks address of 
ntoskrnl.exe pointer
• Use read primitive to leak pointer 
and get base address. 
Mitigations Introduced in 
Windows 10 1607
Windows 10 Anniversary Update Mitigations
• Randomizes Page Table Entries
• Removes kernel addresses from
GdiSharedHandleTable
• Breaks bitmap primitive address 
leak
• SIDT KASLR bypass is mitigated
Windows 10 Anniversary Update Mitigations
• Limits the tagWND.strName to point inside Desktop heap.
• Breaks tagWND primitive
Locating Bitmap Object
• Bitmap objects are stored in the Large Paged Pool.
• Randomized on reboot
• Need a kernel information leak to locate
• Win32ThreadInfo in the TEB is close to the Large Paged Pool
Locating Bitmap Object
• Creating a number of large Bitmap objects stabilizes the Pool
• Large static offset will point into
Bitmaps
Locating Bitmap Object
• Delete the second large Bitmap object.
• Allocate ~10000 new Bitmap objects of 0x1000 bytes each.
• Will point to start of Bitmap object.
Locating Bitmap Object
• Overwrite size of leaked Bitmap
• Reuses two consecutive Bitmaps
•
Write-What-Where
simulation
tagWND Read/Write outside Desktop Heap
• Pointer verification is performed by DesktopVerifyHeapPointer.
• tagWND.strName must be within the Desktop Heap
tagWND Read/Write outside Desktop Heap
• Desktop Heap address and size comes from tagDESKTOP object.
• No validation on tagDESKTOP pointer.
• Pointer is taken from header of tagWND.
• Find tagDESKTOP pointer and replace it.
• Control Desktop Heap address and size
during verification.
tagWND Read/Write outside Desktop Heap
• SetWindowLongPtr can overwrite tagDESKTOP pointer.
• Verification succeeds everywhere.
Write-What-Where simulation
Mitigations Introduced in 
Windows 10 1703
Windows 10 Creators Update Mitigations
• UserHandleTable kernel addresses have been removed
• Windows 10 1607
• Windows 10 1703
Windows 10 Creators Update Mitigations
• ulClientDelta from Win32ClientInfo is gone
• Windows 10 1607
• Windows 10 1703
Windows 10 Creators Update Mitigations
• ExtraBytes modified by SetWindowLongPtr are moved to user-mode.
• Cannot overwrite adjacent tagWND.strName.
Windows 10 Creators Update Mitigations
• tagWND as Kernel-mode read/write primitive is broken again.
• Bitmap object header increased by 0x8 bytes.
• Change allocation size to retain allocation alignment.
• HAL Heap is randomized.
• No longer ntoskrnl.exe pointer at 0xFFFFFFFFFD00448.
tagWND Primitive Revival
• ulClientDelta in Win32ClientInfo has been replaced by user-mode 
pointer
• Inspecting new pointer reveals user-mode mapped Desktop Heap
tagWND Primitive Revival
• Manually search through Desktop heap to locate tagWND object
tagWND Primitive Revival
• Size of ExtraBytes is defined by cbWndExtra when Windows Class is 
registered  
• RegisterClassEx creates a tagCLS object
• tagCLS has ExtraBytes defined by
cbClsExtra
• SetWindowLongPtr sets ExtraBytes in 
tagWND
• SetClassLongPtr sets ExtraBytes in tagCLS
tagWND Primitive Revival
• ExtraBytes from tagCLS are still in the kernel
• Allocate tagCLS followed by tagWND.
• Use SetClassLongPtr to update
tagWND.strName
• Read/write kernel-mode primitive 
is back
Kernel ASLR
• Almost all kernel memory is randomized.
• Shared System Page – KUSER_SHARED_DATA is static
• Located at 0xFFFFF78000000000.
• Not executable.
• Does not contain interesting pointers.
• HAL Heap is randomized
• SIDT is mitigated
• Need new ntoskrnl.exe information leak
Kernel ASLR Bypass Idea
• KASLR bypass could be primitive related.
• Need a bypass for each primitive.
• Must leak ntoskrnl.exe pointer.
Bitmap KASLR Bypass 0-Day
• Surface structure from REACTOS
Bitmap KASLR Bypass 0-Day
• PDEVOBJ structure from REACTOS
Function Pointer
Bitmap KASLR Bypass 0-Day
Bitmap hdev field is empty
Bitmap KASLR Bypass 0-Day
• CompatibleBitmap is a variant
Bitmap KASLR Bypass 0-Day
• Free a Bitmap at offset 0x3000 from first Bitmap
• Spray CompatibleBitmaps to reallocate
Bitmap KASLR Bypass 0-Day
• Read cdd!DrvSyncronizeSurface pointer
• Find ntoskrnl.exe pointer
tagWND KASLR Bypass 0-Day
• tagWND structure from REACTOS
tagWND KASLR Bypass 0-Day
• Offset 0x2A8 of KTHREAD has ntoskrnl.exe pointer
Bonus Round
Bonus KASLR Bypass 0-Days
• Primitive independent ntoskrnl.exe leak
Bonus KASLR Bypass 0-Days
• Also kernel pool leak for Bitmap primitive
• Only works on Windows 10 1703
Bonus KASLR Bypass 0-Days
• ThreadLocalStoragePointer helps leak kernel pool
• Works on Windows 10 1607, but removed in 1703 
Bonus KASLR Bypass 0-Days
• Instead of using a tagWND we can leak ntoskrnl.exe directly from 
gSharedInfo
• Works on Windows 10 1607, but not in 1703 
Page Table Entry Overwrite
• Page Table Entries had static base address of 0xFFFFF68000000000
• Calculate Page Table Entry address easily
De-randomizing Page Table Entries
• The kernel must lookup PTE’s often
• Must have API which works despite randomization
• MiGetPteAddress in ntoskrnl.exe
• Static disassembly uses old base address
• Dynamic disassembly uses randomized base address
De-randomizing Page Table Entries
• MiGetPteAddress contains 
the randomized base address
• Locate MiGetPteAddress
dynamically using read primitive
• Collision free hash is four
QWORDS of function start
De-randomizing Page Table Entries
• Locate hash value of MiGetPteAddress
• Leak PTE base address
De-randomizing Page Table Entries
• Write shellcode to KUSER_SHARED_DATA + 0x800
• Flip the NX bit of the page
• Call shellcode by overwriting HalDispatchTable and calling 
NtQueryIntervalProfile
Recap of steps
Use vulnerability to create read / write primitive
Leak ntoskrnl.exe base address using either tagWND or Bitmap
Locate MiGetPteAddress
Use randomized PTE base address to calculate PTE for any page
Copy shellcode to page
Overwrite PTE of shellcode page and gain RWX kernel memory
Overwrite HalDispatchTable and execute shellcode
Dynamic Kernel Memory
• ExAllocatePoolWithTag allocates kernel pool memory
• Allocate NonPagedPoolExecute
pool memory
• Return pool memory
address
Dynamic Kernel Memory
• Need controlled arguments to call ExAllocatePoolWithTag
• NtQueryIntervalProfile takes two arguments
• Must have specific values to trigger HaliQuerySystemInformation
• Need a different system call
Dynamic Kernel Memory
• Enter NtGdiDdDDICreateAllocation
• Thin trampoline through win32k*.sys
Dynamic Kernel Memory
• Win32kbase!gDxgkInterface is function table into dxgkrnl.sys
• Arguments are not modified from system call to function table call
• Returns a QWORD
Dynamic Kernel Memory
• Inspecting win32kbase!gDxgkInterface shows it to be writable
Dynamic Kernel Memory
• Need to dynamically locate win32kbase!gDxgkInterface
• Can be found in win32kfull!DrvOcclusionStateChangeNotify
• Need to leak win32kfull.sys
Dynamic Kernel Memory
• PsLoadedModuleList is doubly-linked list of 
_LDR_DATA_TABLE_ENTRY structures.
• Search for Win32kful in Unicode at offset 0x60
• Read Win32kfull.sys base address at offset 0x30
Dynamic Kernel Memory
• Leak PsLoadedModuleList from KeCapturePersistentThreadState
• Get Win32kfull.sys base address
• Find win32kfull!DrvOcclusionStateChangeNotify
• Finally locate win32kbase!gDxgkInterface
Dynamic Kernel Memory
• Overwrite win32kbase!gDxgkInterface + 0x68 with 
nt!ExAllocatePoolWithTag
• Copy shellcode to allocated page
• Execute it by overwriting win32kbase!gDxgkInterface again
Recap of steps
Use vulnerability to create read / write primitive
Leak ntoskrnl.exe base address using either tagWND or Bitmap
Locate KeCapturePersistentThreadState and PsLoadedModuleList
Use PsLoadedModuleList to obtain base adress of Win32kfull.sys
Locate DrvOcclusionStateChangeNotify and gDxgkInterface
Overwrite gDxgkInterface with ExAllocatePoolWithTag
Allocate RWX kernel memory and copy shellcode to it
Overwrite gDxgkInterface with pool memory and execute shellcode
Summary
• Kernel read/write primitives can still be leveraged with Write-What-
Where vulnerabilities
• Page Table randomization can be bypassed with ntoskrnl.exe 
information leak
• Device Independent Bitmap can be used to leak ntoskrnl.exe
• tagWND can be used to leak ntoskrnl.exe
• Possible to allocate RWX pool memory with ExAllocatePoolWithTag
• Code on GitHub - https://github.com/MortenSchenk/BHUSA2017
Credits
• Alex Ionescu - https://recon.cx/2013/slides/Recon2013-Alex%20Ionescu-
I%20got%2099%20problems%20but%20a%20kernel%20pointer%20ain%27t%20o
ne.pdf
• Alex Ionescu - http://www.alex-ionescu.com/?p=231
• Diego Juarez - https://www.coresecurity.com/blog/abusing-gdi-for-ring0-exploit-
primitives
• Yin Liang & Zhou Li - https://www.blackhat.com/docs/eu-16/materials/eu-16-
Liang-Attacking-Windows-By-Windows.pdf
• Nicolas Economou - https://www.coresecurity.com/blog/getting-physical-
extreme-abuse-of-intel-based-paging-systems-part-3-windows-hals-heap
• David Weston & Matt Miller - https://www.blackhat.com/docs/us-
16/materials/us-16-Weston-Windows-10-Mitigation-Improvements.pdf
• Matt Oh & Elia Florio -
https://blogs.technet.microsoft.com/mmpc/2017/01/13/hardening-windows-10-
with-zero-day-exploit-mitigations/
Questions
?