  * 4P = (3, 91)
  * 5P = 0
  * 6P = (3, 6)
  * 7P = (80, 10)
  * …
乘积每5次一个循环，也就是说实际上该点的乘积只有5个可能的值，这个规律可以写成：
    k * P = (k mod 5) * P 
同时，这5个点本身也是封闭的，即这些点相加也是其中某个点：
    n * P + m * P = (m + n) * P 
因此， _P的乘积所组成的集合也是一个群_ ，称为 **循环子群** ，P称为该循环子群的生成器(generator)或者 **基点** (base
point)。循环子群是椭圆曲线加密的基础，在后面的章节会进行介绍。
循环子群的元素个数称为该子群的 _阶(order)_ ，比如上述子群的阶为5。通过给定椭圆曲线和基点P我们可以计算出子群的阶。
在椭圆曲线加密中一个常见需求就是找到一个阶比较高的子群。假设椭圆曲线的阶为N，子群的阶为n，想要寻找的基点为P。根据拉格朗日定理 _h = N / n_
总是一个整数，h称为子群的 **余因子** (cofactor)。考虑到椭圆曲线中所有点的和 _NP = 0_ ，我们可以写成：
    n(hP) = 0 
假设n是一个素数，该等式实际上告诉我们：对于一个随机的点P，以点 _G = hP_
为基点的子群阶的阶为n(当G不为0时，G为0则子群阶为1)。当然该算法也要求n是一个素数，否则G的阶只是n的其中一个除数而已。
介绍完了乘法，最后就让我们来看除法：给定点P和Q，并且 _Q = kP_
，如何求k的值？这个问题就是椭圆曲线的离散对数问题，这个问题是一个公认的难题，目前没有一个多项式时间的求解算法可以计算出来。与大数分解问题类似，这个难题也只是实践上的，并没有严谨的数学证明不可解。
实际的加密系统中，如DSA签名算法、DH秘钥交换算法和ElGamal算法等，使用的是指数形式而不是乘法形式，即已知a和b，求解k以满足 _b = a^k
mod p_ 。椭圆曲线加密相比于RSA加密而言的优点之一是我们只需要更少位数的k就可以获得和RSA相同甚至更高的安全性。
# ECC
ECC(Elliptic Curve
Cryptography)即椭圆曲线加密算法。在上文中我们说了，在有限域中的椭圆曲线乘法(指数)是相对容易计算的，但是除法(对数)则很难计算，这也是椭圆曲线得以实现非对称加密的难题假设和理论基础。
椭圆曲线加密算法主要基于椭圆曲线在有限域中的循环子群，因此定义下面一些参数(domain parameters)：
  * _p_ ：定义了有限域大小的素数
  * _a、b_ ：定义椭圆曲线的特征参数
  * _G_ ：生成循环子群的基点
  * _n_ ：循环子群的阶(order)
  * _h_ ：循环子群的余因子(cofactor)
其中，组成ECC椭圆曲线加密算法的秘钥定义如下：
  * 私钥：一个在 _{1, …, n - 1}_ 范围内的随机数 _d_
  * 公钥：一个椭圆曲线上的点 _H = dG_
就是这么的朴实无华。已知私钥d和G我们可以很容易通过乘法计算出公钥H，但是反过来从公钥计算私钥却要面临离散对数问题。虽然我们可以直接使用这个特性对信息(转换成数字)进行非对称加密，但实践上更多的是使用集成加密方案(IES,
Integrated Encryption
Scheme)，比如[ECIES](https://cryptobook.nakov.com/asymmetric-key-ciphers/ecies-public-key-encryption)混合加密方法和[EEECC](https://cse.unl.edu/~ssamal/crypto/EEECC.pdf) (EC-based ElGamal)方法。
在openssl中使用也是通过ECC私钥生成对称加密的秘钥：
    openssl ecparam -genkey -param_enc explicit -out priv.pem -name secp256k1 openssl pkeyutl -derive -inkey priv.pem -peerkey RecipientsPublicKey.pem -out SharedSecret.bin 
详见[Command Line Elliptic Curve
Operations](https://wiki.openssl.org/index.php/Command_Line_Elliptic_Curve_Operations)。
## ECDH
DH即 _Diffie–Hellman_ ，是两个提出者的名字， _Whitfield Diffie_ 和 _Martin Hellman_
。ECDH则为DH的其中一个实现，而DH是一个秘钥协商协议。秘钥协商问题可以简化为：如何在通信链路不安全的安全下安全交换秘钥。DH的实现有很多，但本质上也是基于某种不可逆的拆分操作，WiKi中有个比较直观的例子介绍了交换秘钥的过程：
其中所基于的就是颜色混合容易但是分离难的假设，在这个假设前提下，双方可以获得共同的秘钥。注意双方的secret
color是没有暴露在通信链路中的，因此即便被监听或者劫持也无法成功伪造对端进行中间人(MITM)攻击。
回到ECDH的实现上，这里的难题假设自然就是椭圆曲线的离散对数问题。假设通信双方还是Alice和Bob，则ECDH的工作流程为：
  1. Alice和Bob使用同样的椭圆曲线，并分别随机生成它们自己的私钥和公钥，其中Alice的私钥为da，公钥为 **Ha = da * G** ，Bob的私钥和公钥分别为db和Hb；
  2. Alice和Bob在不安全的信道中交换它们的公钥Ha和Hb；
  3. Alice和Bob分别计算自己私钥和收到的对方公钥的乘积，有：
    Sa = da * Hb = da * (db * G) = db * (da * G) = db * Ha = Sb 
双方计算出了同样的乘积，即为安全的共享秘钥S，这个秘钥就可以用来作为对称加密的秘钥进行后续通信从而保证安全性。中间人通过偷听只能获得双方的公钥，如果它想要在没有私钥的情况下计算出该乘积，就相当于需要解决这么一个问题：给定椭圆曲线上三个点
_P_ 、 _aP_ 和 _bP_ ，如何计算 _abP_ ？这个问题在DH中也称为 _Diffie-Hellman problem_
，即构成安全秘钥交换基石的难题。
## ECDSA
DSA([Digital Signature
Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm))即数字签名算法。我们之前介绍RSA的时候说过RSA的签名方法，即对数据进行hash然后将其使用私钥加密，对端公钥解密并成功校验hash可认为数据没有被篡改。使用椭圆曲线实现的数字签名算法则称为ECDSA。
与RSA类似，ECDSA主要针对所校验数据的hash而不是数据本身。不同的是hash结果需要被截断，从而保证hash的位数与 _n_
(子群的阶)的位数相同，截断后的hash同样是一个整数，记为 _z_ 。Alice使用私钥 _da_ 对数据签名的流程如下：
  1. 从 _{1,…,n-1}_ 中随机选取一个整数 _k_
  2. 计算点 _P = kG_
  3. 计算 _r = Px mod n_ (Px为点P的x坐标)
  4. 如果r=0，从新选一个k
  5. 计算 **s = k^-1 (z + r*da) mod n**
  6. 如果s=0，从新选一个k
运算的结果 _(r, s)_ 则为签名。从计算过程中我们可以看到，s是与哈希 _z_ 绑定的，而 _k_ 可以理解为一个临时私钥，用来生成临时公钥 _r_
。
Bob收到签名 _(r, s)_ 后，自己也计算一份数据的哈希 _z_ ， _Ha_ 是Alice的公钥，校验签名的过程如下：
  1. 计算整数 **u1 = s^-1 * z mod n**
  2. 计算整数 **u1 = s^-1 * r mod n**
  3. 计算点 **P = u1 * G + u2 * Ha**
  4. 当 **r = Px mod n** 时，表示签名有效，数据未被篡改。Px为点P的x坐标
说实话我也不是很清楚为什么要搞这么绕，但ECDSA就是这么实现的。
# 安全性
和RSA一样，椭圆曲线加密的安全性根本在于其难题假设的“难度”，一旦这个前提被打破，椭圆曲线的安全性也会在根本上被动摇。打破难题假定的方法有很多，且不去谈量子计算这种未来的可能性，即便聚焦于当下也依然存在。
## 椭圆曲线的选择
我们说椭圆曲线在有限域上的的离散对数问题是个难题，这并不完全正确。前面看到了根据a、b不同，椭圆曲线可能有不同的形状，事实上存在一些类型椭圆曲线，它们的安全性是相当脆弱的。对于这些椭圆曲线，可以使用特殊的算法来高效的求解离散对数问题。
比如，对于所有 _p=hn_