完毕，弹出自己
空间依次取指
转到func_A的代
令时，跳转到
中获得返同地址，
的栈帧并从中获
执行
码区地续执行
func_B的代码
皖回func_A代码区
得返同地址，
区续执行
续执行
网main代码区姚
铁执行
系统找空间：
系能找空间：为
系统找空间：为
系能找空间：弹
系统栈空间：弹
系统栈找顶为
配合func_A的执
配合func_B的执
出ifunc_B的找
当前正在执行
行，在系统栈中
行，在系统栈中
帧。对应于当前
出fumc_A的找
，对应于当前
的main函最栈
为其开牌新的栈
为其开辟新的找
正在执行的函
数，当前栈顶栈
正在执行的函
帧并压入
帧并压入
数，当前栈项栈
赖重新恢复成
帧意新恢复成
func_A函数栈
mmin函数找帧
图2.1.4系统栈在函数调用时的变化
在func_A调用func_B的时候，同样先在自己的栈顿中压入函数返回地址，然后为
func_B创建新栈帧并压入系统栈。
1
在func_B返回时，func_B的栈帧被弹出系统栈，func_A栈帧中的返回地址被“露”
在栈顶，此时处理器按照这个返回地址重新跳到func_A代码区中执行。
---
## Page 68
第
·在func_A返回时，func_A的栈帧被弹出系统栈，main函数栈帧中的返回地址被“露”
2
在栈顶，此时处理器按照这个返回地址跳到main函数代码区中执行。
章
题外话：在实际运行中，main函数并不是第一个被调用的函数，程序被装入内存前还
栈溢出原
有一些其他操作，图2.1.4只是栈在函数调用过程中所起作用的示意图
2.1.4寄存器与函数栈帧
理与实践
每一个函数独占自己的栈帧空间。当前正在运行的函数的栈帧总是在栈顶。Win32系统提
供两个特殊的寄存器用于标识位于系统栈顶端的栈顿。
（1）ESP：栈指针寄存器（extendedstackpointer)，其内存放着一个指针，该指针永远指向
系统栈最上面一个栈帧的栈顶。
（2）EBP：基址指针寄存器（extendedbasepointer)，其内存放着一个指针，该指针永远指向
系统栈最上面一个栈帧的底部。
注意：EBP指向当前位于系统栈最上边一个栈帧的底部，而不是系统栈的底部。严格
这一提法以示区别；ESP所指的栈帧顶部和系统栈的顶部是同一个位置，所以后面叙
述中并不严格区分“栈帧顶部”和“栈顶”的概念。请您注意这里的差异，不要产生
概念混清。
寄存器对栈帧的标识作用如图2.1.5所示。
视项以
栈项
上的来
上的来
使用的
使用的
内存空间
内存空间
顶以
上的米
ESP
使用的
栈顿1
内存空间
栈帧1
释放
EBP
ESP
找帧2被
栈帧2
栈帧2
释放
EBP
栈帧3
栈帧3
找帧3
EBP
栈帧
栈帧
栈帧
......
图2.1.5栈帧寄存器ESP与EBP的作用
函数栈帧：ESP和EBP之间的内存空间为当前栈帧，EBP标识了当前栈顿的底部，ESP
标识了当前栈帧的顶部。
43
---
## Page 69
0
day
在函数栈顿中，一般包含以下几类重要信息。
安
（1）局部变量：为函数局部变量并辟的内存空间。
全
（2）栈帧状态值：保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部
：
可以通过堆栈平衡计算得到），用于在本帧被弹出后恢复出上一个栈顿。
软
件
漏
以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令。
洞
题外话：函数栈帧的大小并不固定，一般与其对应函数的局部变量多少有关。在后面
分
析
调试实验中您会发现，函数运行过程中，其栈愤大小也是在不停变化的。
技
术
除了与栈相关的寄存器外，您还需要记住另一个至关重要的寄存器。
（第
EIP：指令寄存器（ExtendedInstructionPointer)，其内存放着一个指针，该指针永远指向下
一条等待执行的指令地址，其作用如图2.1.6所示。
2
可以说如果控制了EP寄存器的内容，就控制了进程一我们让ELP指向哪里，CPU就会
版
去执行哪里的指令。在本章第4节中我们会介绍控制EP劫持进程的原理及实验。
2.1.5函数调用约定与相关指令
函数调用约定描述了函数传递参数方式和栈协同工作的技术细节。不同的操作系统、不同
的语言、不同的编译器在实现函数调用时的原理虽然基本相同，但具体的调用约定还是有差别
的。这包括参数传递方式，参数入栈顺序是从右向左还是从左向右，函数返回时恢复堆栈平衡
的操作在子函数中进行还是在母函数中进行。表2-1-1列出了几种调用方式之间的差异。
表2-1-1调用方式之间的差异
BASIC
FORTRANPASCAL
参数入栈顺序
右→左
右→左
右→左
左→右
左一右
左一右
恢复栈平衡操作的位置
母函数
子函数
子函数
子函数
子函数
子函数
具体的，对于VisualC++来说，可支持以下3种函数调用约定，如表2-1-2所示。
表2-1-2函数调用约定
调用约定的声明
参数入栈顺序
恢复栈平衡的位置
cdecl
右→左
母函数
fastcall
右一左
子函数
_stdcall
右→左
子函数
如果要明确使用某一种调用约定，只需要在函数前加上调用约定的声明即可，否则默认情
况下，VC会使用二stdcall的调用方式。本篇中所讨论的技术在不加额外说明的情况下，都是
指这种默认的二stdcall调用方式。
除了上边的参数入栈方向和恢复栈平衡操作位置的不同之外，参数传递有时也会有所不
同。例如，每一个C++类成员函数都有一个this指针，在Windows平台中，这个指针一般是用
14
---
## Page 70
第
ECX寄存器来传递的，但如果用GCC编译器编译，这个指针会作为最后一个参数压入栈中。
2
章
注意：同一段代码用不同的编译选项、不同的编译器编译链接后，得到的可执行文件
会有很多不同。因此，请您在进行后续实验前务必注意实验环境的描述，否则所得结
栈
果可能会与实验指导有所差异。
溢
出
函数调用大致包括以下几个步骤。
原
（1）参数入栈：将参数从右向左依次压入系统栈中。
理
与
（2）返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继
实
续执行。
践
（3）代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。
（4）栈顿调整：具体包括。
保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP入栈）
将当前栈顿切换到新栈帧（将ESP值装入EBP，更新栈顿底部）；
给新栈帧分配空间（把ESP减去所需空间的大小，抬高栈顶）；
对于_stdcall调用约定，函数调用时用到的指令序列大致如下。
调用前
push参数3：假设该函数有3个参数，将从右向左依次入栈
push参数2
push参数1
call函数地址；cal1指令将同时完成两项工作：a）向栈中压入当前指令在内存
：中的位置，即保存返回地址，b）跳转到所调用函数的入口地址函
数入口处
dqausnd
：保存旧栈帧的底部
movebp,esp
：设壹新栈帧的底部（栈顿切换）
subesp,xxx
：设壹新栈帧的项部（拾高栈项，为新栈帧开辟空间）
上面这段用于函数调用的指令在栈中引起的变化如图2.1.7所示。
题外话：关于栈帧的划分，不同参考书中有不同的约定。有的参考文献中把返回地
址和前栈帧EBP值做为一个栈帧的顶部元素，而有的则将其做为栈帧的底部进行划
分。在后面的调试中，您会发现OllyDbg在栈区标示出的栈帧是按照前栈EBP值
进行分界的，也就是说，前栈帧EBP值既属于上一个栈帧，也属于下一个栈帧，这
样划分栈愤后，返回地址就成为了栈帧顶部的数据。出于前后概念一致的目的，在
本书中将坚持按照EBP与ESP之间的部分做为一个栈帧的原则进行划分。这样划分
出的栈帧如图2.1.7最后一幅图所示，栈帧的底部存放着前栈帧EBP，栈帧的顶部存
放着返回地址。划分栈帧只是为了更清晰地了解系统栈的运作过程，并不会影响它
实际的工作。
类似地，函数返回的步骤如下。
（1）保存返回值：通常将函数的返回值保存在寄存器EAX中。
45
---
## Page 71
day安全：
0
（2）弹出当前栈帧，恢复上一个栈帧。
具体包括：
在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈顿的空间。
软件漏洞分析技术
·将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复出上一个栈帧。
将函数返回地址弹给EIP寄存器。
ESP
（第2版
ESP
ESP
当前函
当前函
数栈
微栈赖
数找帧
FBA
EBR
EBA
PUSH arg_x
CALL
函数调用前
函数参数从右向左
指令引起的压找操
依次入栈
作。紧接CALL后面
那条指令的内存地
址将被压入栈中，
即返回地址入栈
ESP
ESP
ESP
EBP
EBP
FBP
EBP
TNNEBP
返回地址
地回地址
回地址
当前函
当前读
数栈
数找赖
首栈EBP
.HNEBP
Y
PUSH EBP
MOVEBP,ESP
SUB ESP,XX
保存当前栈帧的底部位
设置新栈帧的应
设置新找帧的项部，
置，已备栈恢复时使用
部开始栈切换
新找切换完毕
图2.1.7
函数调用时系统栈的变化过程
（3）跳转：按照函数返回地址跳回母函数中继续执行。
还是以C语言和Win32平台为例，函数返回时的相关的指令序列如下。
addesp，xxx；降低栈顶，回收当前的栈帧
46
---
## Page 72
第
popebp：将上一个栈帧底部位置恢复到ebp，
2
retn；这条指令有两个功能：a）弹出当前栈顶元素，即弹出栈帧中的返回地址
章
至此，
：栈顿恢复工作完成。b）让处理器跳转到弹出的返回地址，恢复调用前
栈
的代码区
溢
按照这样的函数调用约定组织起来的系统栈结构如图2.1.8所示。
出
原
题外话：Win32平台下有很多寄存器，Intel指令集中的指令也有很多，现在立刻逐
理
一介绍它们无疑相当于给已经满头雾水的您再浇一桶冷水。虽然这里仅仅列出了3
与
实
个寄存器和几条指令的作用，但只要您完全理解它们，就一定能顺利理解本书的后
践
续章节，因为它们是栈溢出利用的关键，也是计算机架构的核心所在。当然，入门
以后要想提高到一个新的层次，用《IBMX86汇编》或者《Win32汇编）恶补一下
汇编知识是非常必要的。
局部变量var_B2
RSP
func_B栈帧
局部变量varB1
前栈帧的EBP
【科自地址
（func_A代码区）
func_A栈帧
8第上价暂数41882
call func_B
首权输的BP
mov var_A, eax
国地址
funcA第个参数argAl
main栈帧
funcA第个参数argA2
局部变量varmala
首栈核的
（main代码区）
call func_A