![
](https://images.seebug.org/content/images/2018/12/e83b0877-d399-42bc-a414-7cf8048302c3.png-w331s)
HTTP 数据包格式如下：
    GET /cyt.php?code=AiVjdtlUjI9m45f6&file=1&size=0&sys=win&VERSION=4.4&status=begin HTTP/1.1
###### 文件筛选
在加密模块中，lucky 对指定后缀名的文件进行加密：
![
](https://images.seebug.org/content/images/2018/12/fc59a6e5-4024-41a4-9c01-9f402a299ae4.png-w331s)
被加密的后缀名文件包括：
    bak,sql,mdf,ldf,myd,myi,dmp,xls,xlsx,docx,pptx,eps,
    txt,ppt,csv,rtf,pdf,db,vdi,vmdk,vmx,pem,pfx,cer,psd
**6.AES_ECB 加密方法**  
lucky 使用先前生成的长度为 60 字节的密钥，取前 32 字节作为加密使用，依次读取文件，按照每 16 字节进行 `AEC_ECB` 加密。
![
](https://images.seebug.org/content/images/2018/12/6fb665c7-b421-4352-b681-fa23a2b3eaad.png-w331s)
除此之外，该勒索病毒对于不同文件大小有不同的处理，结合加密函数的上下文可以得知，这里我们假设文件字节数为 n：
  1. 对于文件末尾小于 16 字节的部分，不加密
  2. 若 n > 10000000 字节，且当 n > 99999999 字节时，将文件分为 n / 80 个块，加密前 n / 16 个块
  3. 若 n > 10000000 字节，且当 99999999  10000000 字节，且当 n > 499999999 字节时，将文件分为 n / 1280 个块，加密前 n / 16 个块
对于每个文件在加密完成后，lucky 病毒会将用于文件加密的 AES 密钥使用 RSA 算法打包并添加至文件末尾。
**7.加密完成**  
在所有文件加密完成后，lucky 再次向服务器发送消息，表示用户已经加密完成；并在
`c:\\_How_To_Decrypt_My_File_.Dic`，通知用户遭到了勒索软件加密。
加密前后文件对比：
![
](https://images.seebug.org/content/images/2018/12/229f1073-3732-470f-90ca-f72ef850d138.png-w331s)
### 0x04 密钥还原
在讨论密钥还原前，先来看看勒索病毒支付后流程。
如果作为一个受害者，想要解密文件，只有向攻击者支付 1BTC，并把被 RSA 算法打包后的 AES 密钥提交给攻击者，攻击者通过私钥解密，最终返回明文的
AES 密钥用于文件解密；可惜的是，受害者即便拿到密钥也不能立即解密，lucky 勒索病毒中并没有提供解密模块。
勒索病毒期待的解密流程：
![
](https://images.seebug.org/content/images/2018/12/36413941-d855-4345-bb02-5be5802e8bfe.png-w331s)
**那么，如果能直接找到 AES 密钥呢？**
在完整的分析加密过程后，有些的小伙伴可能已经发现了细节。AES 密钥通过 `generate_key()` 函数生成，再来回顾一下该函数：
利用当前时间戳作为随机数种子，使用随机数从预设的字符串序列中选取字符，组成一个长度为 60 字节的密钥。
**随机数= >伪随机数**  
有过计算机基础的小伙伴，应该都知道计算机中不存在真随机数，所有的随机数都是伪随机数，而伪随机数的特征是“对于一种算法，若使用的初值(种子)不变，那么伪随机数的数序也不变”。所以，如果能够确定
`generate_key()` 函数运行时的时间戳，那么就能利用该时间戳作为随机种子，复现密钥的生成过程，从而获得密钥。
**确定时间戳**
###### 爆破
当然，最暴力的方式就是直接爆破，以秒为单位，以某个有标志的文件(如 PDF 文件头)为参照，不断的猜测可能的密钥，如果解密后的文件头包含
`%PDF`(PDF 文件头)，那么表示密钥正确。
###### 文件修改时间
还有其他的方式吗？文件被加密后会重新写入文件，所以从操作系统的角度来看，被加密的文件具有一个精确的修改时间，可以利用该时间以确定密钥的生成时间戳：
![
](https://images.seebug.org/content/images/2018/12/140497f1-788c-4700-a127-da0a091096b8.png-w331s)
如果需要加密的文件较多，加密所花的时间较长，那么被加密文件的修改时间就不是生成密钥的时间，应该往前推移，不过这样也大大减少了猜测的范围。
###### 利用用户 session
利用文件修改时间大大减少了猜测的范围；在实际测试中发现，加密文件的过程耗时非常长，导致文件修改时间和密钥生成时间相差太多，而每次都需要进行检查密钥是否正确，需要耗费大量的时间，这里还可以使用用户
session 进一步缩小猜测的范围。
回顾加密过程，可以发现加密过程中，使用时间随机数生成了用户 session，这就成为了一个利用点。利用时间戳产生随机数，并使用随机数生成可能的用户
session，当找到某个 session 和当前被加密的用户 session 相同时，表示该时刻调用了 `generate_session()`
函数，该函数的调用早于文件加密，晚于密钥生成函数。
![
](https://images.seebug.org/content/images/2018/12/b785fbb4-460a-44b1-9d19-73f17c65299d.jpg-w331s)
找到生成用户session 的时间戳后，再以该时间为起点，往前推移，便可以找到生成密钥的时间戳。
补充：实际上是将整个还原密钥的过程，转换为寻找时间戳的过程；确定时间戳是否正确，尽量使用具有标志的文件，如以 PDF 文件头 `%PDF` 作为明文对比。
**还原密钥**  
通过上述的方式找到时间戳，利用时间戳就可以还原密钥了，伪代码如下：
    sequence = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    key = []
    timestamp = 1542511041
    srand(timestamp)
    for (i = 0; i   
绿盟:   
深信服:   
Python 的解密脚本: 
* * *