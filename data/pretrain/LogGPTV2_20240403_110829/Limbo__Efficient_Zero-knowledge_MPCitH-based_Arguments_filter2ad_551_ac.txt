the executions, we limit the corruption strategies that are available
against robustness. While independent challenges would possibly
reduce the robustness error further, using identical ones also al-
lows for implementation optimizations and we therefore establish
a theoretical basis for this practice.
Definition 3.5 (ğœ-parallel execution). Let Î ğ‘“ be a client-server
ğœŒ-phase MPC protocol for a functionality ğ‘“ with ğ‘› server parties.
For an integer ğœ, Î ğœ
is the ğœ-fold parallel execution of Î ğ‘“ as a
ğ‘“
client-server ğœŒ-phase protocol where there is only one sender ğ‘ƒğ‘†,
one receiver ğ‘ƒğ‘…, but ğœ independent sets of ğ‘› server parties.
The client parties ğ‘ƒğ‘† and ğ‘ƒğ‘… independently run an execution of
Î ğ‘“ with each set of servers who also do not communicate across
sets, excepted for the calls to RandomCoin which are shared across
the ğœ executions; i.e. the ğœ Â· ğ‘› servers receive the same output
from RandomCoin. If the ğœ executions output the same result, then
ğ‘ƒğ‘… outputs the same; if any one of the executions dissents, ğ‘ƒğ‘… aborts
the protocol.
We first argue that privacy and robustness properties of the
underlying protocol are maintained by the one run in parallel. The
proofs of Propositions 3.6 and 3.7 are given in the full version.
Proposition 3.6. If Î ğ‘“ is (ğ‘ƒğ‘…, ğ‘› âˆ’ 1)-private in the semi-honest
ğ‘“ is (ğ‘ƒğ‘…, ğœ(ğ‘› âˆ’ 1))-private in the semi-honest model
model, then Î ğœ
with the restriction that at most ğ‘› âˆ’ 1 servers are corrupted for each
of the ğœ executions.
Proposition 3.7. If Î ğ‘“ is (ğ‘ƒğ‘†, 0)-robust in the malicious model
ğ‘“ is (ğ‘ƒğ‘†, 0)-robust in the malicious model with
with error ğ›¿, then Î ğœ
error at most ğ›¿.
We then argue that the IOP construction equivalent to that of
instead of Î ğ‘“ is also a ZKIOP with improved
Figure 1 using Î ğœ
ğ‘“
soundness error.
Theorem 3.8. Let ğ‘¥ be a public statement, and ğ‘¤ an additional
input, let ğ‘“ be the functionality for ğ‘ƒğ‘†, ğ‘ƒ1, . . . , ğ‘ƒğ‘›, ğ‘ƒğ‘… that outputs
â„›(ğ‘¥, ğ‘¤) to ğ‘ƒğ‘…. Let Î ğ‘“ be a ğœŒ-phase MPC protocol in the client-server
model that correctly realizes ğ‘“ with (ğ‘ƒğ‘…, (ğ‘› âˆ’ 1))-privacy in the semi-
honest model and (ğ‘ƒğ‘†, 0)-robustness in the malicious model with
robustness error ğ›¿.
With Î ğœ
ğ‘“ constructed from Î ğ‘“ as in Definition 3.5, the protocol
ğ‘“ is a ZKIOP for â„› with
Î ğœŒâˆ’ZKIOP as described in Figure 1 using Î ğœ
soundness error
1 âˆ’ 1
ğ‘›ğœ
1
ğ‘›ğœ + ğ›¿
ğœ– =
.
(cid:18)
(cid:19)
ğ‘“
.
1))-privacy of Î ğœ
given by Proposition 3.6.
Proof: (Completeness) This follows from the completeness of Î ğ‘“
and the construction of Î ğœ
ğ‘“
(Honest verifier zero-knowledge) This follows from the (ğ‘ƒğ‘…, ğœ(ğ‘› âˆ’
(Soundness) The same strategy for a malicious prover ğ’«âˆ— applies
as for the first protocol: by first corrupting only ğ‘ƒğ‘†, it has a prob-
ability of at most ğ›¿ of causing Î ğœ
to output accept; if this fails,
ğ‘“
it can then corrupt at most one server for each of the ğœ indepen-
dent executions to make ğ‘ƒğ‘… accept, this is not detected by ğ’± with
probability 1/ğ‘›ğœ.
â–¡
4 MULTIPLICATIONS CHECK
In this section we describe an efficient MPC protocol in the client-
server model for checking multiplication triples. This protocol is
an adaptation of previous protocols described in [15, 16, 27], and
constitutes one of the main building block of our MPC component.
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3027Protocol Î MultCheck
We consider an extension field G âŠ‡ F. We assume access to a random
coin functionality, RandomCoin.
Phase 1 ğ‘ƒğ‘† sends the shares âŸ¨ğ‘¥â„“ âŸ©ğ‘–, âŸ¨ğ‘¦â„“ âŸ©ğ‘–, âŸ¨ğ‘§â„“ âŸ©ğ‘– for â„“ âˆˆ [ğ‘š], and the
shares âŸ¨aâŸ©ğ‘–, âŸ¨bâŸ©ğ‘–, âŸ¨ğ‘âŸ©ğ‘– of a random inner-product tuple to each
server ğ‘ƒğ‘– .
Sampling The parties call RandomCoin to obtain ğ‘… âˆˆ G and ğ‘  âˆˆ G.
Phase 2 The servers parties proceed as follows:
(1) Lift {âŸ¨ğ‘¥â„“ âŸ©, âŸ¨ğ‘¦â„“ âŸ©, âŸ¨ğ‘§â„“ âŸ©}â„“âˆˆ[ğ‘š] to G.
(2) Set
âŸ¨xâŸ© = (âŸ¨ğ‘¥1âŸ©, ğ‘… Â· âŸ¨ğ‘¥2âŸ©, . . . , ğ‘…ğ‘šâˆ’1 Â· âŸ¨ğ‘¥ğ‘šâŸ©),
âŸ¨yâŸ© = (âŸ¨ğ‘¦1âŸ©, âŸ¨ğ‘¦2âŸ©, . . . , âŸ¨ğ‘¦ğ‘šâŸ©)
âŸ¨ğ‘§âŸ© =â„“âˆˆ[ğ‘š] ğ‘…â„“âˆ’1 Â· âŸ¨ğ‘§â„“ âŸ©
(3) Compute âŸ¨ğˆâŸ© = ğ‘  Â· âŸ¨xâŸ© âˆ’ âŸ¨aâŸ© and âŸ¨ğ†âŸ© = âŸ¨yâŸ© âˆ’ âŸ¨bâŸ©.
(4) Open âŸ¨ğˆâŸ© and âŸ¨ğ†âŸ© using a broadcast channel.
(5) Compute âŸ¨ğ‘£âŸ© = ğ‘  Â· âŸ¨ğ‘§âŸ© âˆ’ âŸ¨ğ‘âŸ© âˆ’ âŸ¨bâŸ© âˆ— ğˆ âˆ’ âŸ¨aâŸ© âˆ— ğ† âˆ’ ğ† âˆ— ğˆ.
(6) Send âŸ¨ğ‘£âŸ© to ğ‘ƒğ‘….
The receiver party ğ‘ƒğ‘… accepts if ğ‘£ = 0 and rejects if not.
Figure 2: Protocol Î MultCheck
More concretely, the goal is for the server parties to verify the
correctness of ğ‘š multiplication tuples {ğ‘¥â„“, ğ‘¦â„“, ğ‘§â„“}â„“âˆˆ[ğ‘š] given by
the sender client; i.e. that ğ‘¥â„“ Â· ğ‘¦â„“ = ğ‘§â„“, for each â„“ âˆˆ [ğ‘š]. We de-
scribe two different MPC checking protocols; the first, Î MultCheck,
presents how to check multiplications using inner-products, the
second, Î CompressedMC extends this idea by repeating several com-
pression rounds to reduce the communication between the servers
and the recipient. While we do not prove the MPC security of these
protocols, we present several properties which we will use in the
next section.
4.1 First Multiplication Check Protocol
The first protocol, presented in Figure 2, checks the correctness
of ğ‘š secret-shared multuplication tuples by testing the correctness
of a single secret-shared inner product tuple of size ğ‘š.
It proceeds in two steps: first, given {âŸ¨xğ‘–âŸ©, âŸ¨yğ‘–âŸ©, âŸ¨zğ‘–âŸ©}ğ‘–âˆˆ[ğ‘š], the
parties call a random coin functionality, RandomCoin, to obtain
a random value ğ‘… in an extension field G of F. Using ğ‘…, the par-
ties construct the inner-product tuple âŸ¨xâŸ© âˆˆ Gğ‘š, âŸ¨yâŸ© âˆˆ Gğ‘š, and
âŸ¨ğ‘§âŸ© âˆˆ G, such that x âˆ— y = ğ‘§. In the second step, parties test the
correctness of this tuple using an auxiliary random inner-product
tuple (âŸ¨aâŸ©, âŸ¨bâŸ©, âŸ¨ğ‘âŸ©) and a random field element ğ‘  âˆˆ G.
if any, of the input tuples with high probability.
The idea here is that both steps will maintain the â€œincorrectnessâ€,
We note that the parties make use of a broadcast channel in the
second phase, which does not respect our restriction to servers
which communicate only with ğ‘ƒğ‘… in Phase ğœŒ of the protocol. This
broadcast channel will not be required by the next protocol.
The proofs of the following lemmas given in the full version.
Lemma 4.1. If at least one multiplication triple is incorrect, the re-
sulting inner-product tuple obtained in Step 2. of protocol Î MultCheck
is correct with probability at most ğ‘šâˆ’1
|G| .
Lemma 4.2. If at least one of the two inner-product tuples (x, y, ğ‘§)
and (a, b, ğ‘) is incorrect, the probability that the check passes is 2/|G|.
Combining the two previous lemma we obtain.
Compressed multiplication check, Î CompressedMC
We consider an extension field G âŠ‡ F. We assume access to a random
coin functionality, RandomCoin.
Phase 1 ğ‘ƒğ‘† sends the shares âŸ¨ğ‘¥â„“ âŸ©ğ‘–, âŸ¨ğ‘¦â„“ âŸ©ğ‘–, âŸ¨ğ‘§â„“ âŸ©ğ‘– in F to each server ğ‘ƒğ‘–
Sampling The parties call RandomCoin to obtain ğ‘… âˆˆ G.
Phase 2 The server parties proceed as follows:
for â„“ âˆˆ [ğ‘š].
(1) Lift {âŸ¨ğ‘¥â„“ âŸ©, âŸ¨ğ‘¦â„“ âŸ©, âŸ¨ğ‘§â„“ âŸ©}â„“âˆˆ[ğ‘š] to G.
(2) Set
âŸ¨x0âŸ© = (âŸ¨ğ‘¥1âŸ©, ğ‘… Â· âŸ¨ğ‘¥2âŸ©, . . . , ğ‘…ğ‘šâˆ’1 Â· âŸ¨ğ‘¥ğ‘šâŸ©),
âŸ¨y0âŸ© = (âŸ¨ğ‘¦1âŸ©, âŸ¨ğ‘¦2âŸ©, . . . , âŸ¨ğ‘¦ğ‘šâŸ©)
âŸ¨ğ‘§0âŸ© =â„“âˆˆ[ğ‘š] ğ‘…â„“âˆ’1 Â· âŸ¨ğ‘§â„“ âŸ©
For each compression round ğ‘— âˆˆ [âŒŠlogğ‘˜ (ğ‘š)âŒ‹]:
Phase 3 + ( ğ‘— âˆ’ 1) The server parties proceed as follows:
âŸ¨xğ‘—âˆ’1âŸ© = (âŸ¨ağ‘—
âŸ¨yğ‘—âˆ’1âŸ© = (âŸ¨bğ‘—
(1) Parse âŸ¨xğ‘—âˆ’1âŸ© and âŸ¨yğ‘—âˆ’1âŸ© as
ğ‘˜ âŸ©),
1âŸ©, . . . , âŸ¨ağ‘—
ğ‘˜ âŸ©),
1âŸ©, . . . , âŸ¨bğ‘—
ğ‘¢âŸ©, âŸ¨bğ‘—
ğ‘¢âŸ©) to obtain âŸ¨ğ‘ ğ‘—
(2) Call Î InnerProd(âŸ¨ağ‘—
(3) Set âŸ¨ğ‘ ğ‘—
(4) If ğ‘— â‰  âŒŠlogğ‘˜ ğ‘šâŒ‹, begin Î Compress on (âŸ¨ağ‘—
ğ‘˜ âŸ© = âŸ¨ğ‘§ ğ‘—âˆ’1âŸ© âˆ’ğ‘¢âˆˆ[ğ‘˜âˆ’1] âŸ¨ğ‘ ğ‘—
ağ‘—
ğ‘¢, bğ‘—
ğ‘¢ğ‘ âŸ©.
ğ‘— = âŒŠlogğ‘˜ ğ‘šâŒ‹, begin Î CompressRand instead.
ğ‘¢ âˆˆ Gğ‘š/ğ‘˜ ğ‘—
.
ğ‘¢âŸ©, for ğ‘¢ âˆˆ [ğ‘˜ âˆ’ 1].
ğ‘– âŸ©)ğ‘–âˆˆ[ğ‘˜]; if
ğ‘– âŸ©, âŸ¨bğ‘—
ğ‘– âŸ©, âŸ¨ğ‘ ğ‘—
Sampling Within Î Compress or Î CompressRand.
Phase 3 + ğ‘— Complete Î Compress
(âŸ¨xğ‘— âŸ©, âŸ¨yğ‘— âŸ©, âŸ¨ğ‘§ ğ‘— âŸ©) of dimension ğ‘š/ğ‘˜ ğ‘— .
or Î CompressRand
to
obtain
After the last compression round:
Phase 3 + âŒŠlogğ‘˜ (ğ‘š)âŒ‹ cont. Servers open the last tuple to ğ‘ƒğ‘… which
outputs either accept if it is correct, or abort if not.
Figure 3: Compressed multiplication check
Proposition 4.3. We have that if at least one of the ğ‘š triples
{(âŸ¨ğ‘¥ğ‘–âŸ©, âŸ¨ğ‘¦ğ‘–âŸ©, âŸ¨ğ‘§ğ‘–âŸ©)}ğ‘–âˆˆ[ğ‘š] is incorrect, the probability that the protocol
Î MultCheck outputs accept is at most ğ‘šâˆ’1
|G| ) Â· 2
|G| .
4.2 Second Multiplication Check Protocol
|G| + (1 âˆ’ ğ‘šâˆ’1
Here we describe a more efficient protocol which allows to com-
press the size of the inner-product to be tested in order to reduce
the communication complexity at the expense of (potentially) more
interactions.
The protocol Î CompressedMC, described in Figure 3, uses two
core subroutines, Î Compress and Î CompressRand given in Figure 4,
which compress a set of ğ‘˜ inner-product tuples down to only one
(of the same dimension) in such a way that, with high probability,
the output tuple is incorrect if one of the inputs is.
The difference between the two subroutines is that the second
introduces randomness in such a way that the compressed tuple can
be opened without leaking information about the input tuples. This
also enables the protocol to dispense with the broadcast channel
used in Î MultCheck.
The protocol assumes access to a RandomCoin functionality and
to two untrusted subroutines Î InnerProd and Î Rand, which we donâ€™t
instantiate. On input of two vectors âŸ¨aâŸ© and âŸ¨bâŸ©, Î InnerProd outputs a
possibly incorrect âŸ¨ğ‘âŸ©, with a âˆ— b = ğ‘. When queried by the servers,
Î Rand outputs a possibly biased random value. At a high level,
Î CompressedMC proceeds as follows. The first step is similar to the
first step in Î MultCheck, where parties produce the inner-product
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3028Sub-protocols Î Compress and Î CompressRand
Î CompressRand is identical to Î Compress except where highlighted below.
Input: ğ‘˜ inner-product tuples (âŸ¨xğ‘– âŸ©, âŸ¨yğ‘– âŸ©, âŸ¨ğ‘§ğ‘– âŸ©)ğ‘–âˆˆ[ğ‘˜], of dimension â„“.
(1) Define two dimension-â„“ vectors of degree-(ğ‘˜ âˆ’ 1) polynomials
âŸ¨f(Â·)âŸ©, âŸ¨g(Â·)âŸ© such that:
f(ğ‘¢) = xğ‘¢,
g(ğ‘¢) = yğ‘¢,
âˆ€ğ‘¢ âˆˆ [ğ‘˜].
In Î CompressRand, for ğ‘— âˆˆ [â„“], the ğ‘“ğ‘— and ğ‘”ğ‘— polynomials are of
degree ğ‘˜ and are defined by the additional points âŸ¨ğ‘“ğ‘— (ğ‘˜ + 1)âŸ© =
âŸ¨ğ‘£ğ‘— âŸ© and âŸ¨ğ‘”ğ‘— (ğ‘˜ + 1)âŸ© = âŸ¨ğ‘¤ğ‘— âŸ© where the shares of ğ‘£ğ‘— and ğ‘¤ğ‘— are
given by Î Rand.
(2) Define the polynomial â„(Â·) of degree 2(ğ‘˜ âˆ’ 1) such that:
âŸ¨â„(ğ‘¢)âŸ© = âŸ¨ğ‘§ğ‘¢âŸ©,
âˆ€ğ‘¢ âˆˆ [ğ‘˜],
âŸ¨â„(ğ‘¢)âŸ© = Î InnerProd(âŸ¨f(ğ‘¢)âŸ©, âŸ¨g(ğ‘¢)âŸ©),
In Î CompressRand, â„ is of degree 2ğ‘˜ and is defined by the two
additional points âŸ¨â„(2ğ‘˜)âŸ© and âŸ¨â„(2ğ‘˜ + 1)âŸ© defined as the other
points âŸ¨â„(ğ‘–)âŸ© for ğ‘– âˆˆ [ğ‘˜ + 1, 2ğ‘˜ âˆ’ 1].
âˆ€ğ‘– âˆˆ [ğ‘˜ + 1, 2ğ‘˜ âˆ’ 1].
Sampling Call RandomCoin to obtain ğ‘  âˆˆ G \ [ğ‘˜],
(3) Compute âŸ¨f(ğ‘ )âŸ©, âŸ¨g(ğ‘ )âŸ©, âŸ¨â„(ğ‘ )âŸ©.
Output: One tuple (âŸ¨f(ğ‘ )âŸ©, âŸ¨g(ğ‘ )âŸ©, âŸ¨â„(ğ‘ )âŸ©) of dimension â„“.
Figure 4: Compressing inner products
tuple (âŸ¨xâŸ©, âŸ¨yâŸ©, âŸ¨ğ‘§âŸ©) of dimension ğ‘š. To reduce the dimension of
this tuple, parties divide the vectors âŸ¨xâŸ© and âŸ¨yâŸ© into ğ‘˜ smaller
vectors of dimension â„“ and perform Î Compress. In this way parties
obtain a single inner-product tuple, but this time of dimension
â„“ = ğ‘š/ğ‘˜, for any divisor ğ‘˜ of ğ‘š. This step can then be repeated with
identical or different values of ğ‘˜ until a final inner-product tuple
(potentially of dimension 1) needs to be checked. (For identical
values of ğ‘˜, these steps need to be repeated logğ‘˜ ğ‘š times to check a
single multiplication triple at the end).
The proof of the following proposition is given in the full version.
Proposition 4.4. If at least one of the ğ‘š multiplication triples
{(âŸ¨ğ‘¥ğ‘–âŸ©, âŸ¨ğ‘¦ğ‘–âŸ©, âŸ¨ğ‘§ğ‘–âŸ©)}ğ‘–âˆˆ[ğ‘š] is incorrect, the probability that protocol
Î CompressedMC outputs accept is at most
(cid:18)
(cid:18)
ğ‘š âˆ’ 1
|G| +
1 âˆ’ ğ‘š âˆ’ 1
+
|G|
(cid:19)
(cid:18)
1 âˆ’ ğ‘š âˆ’ 1
|G|
Â·
(cid:19)
(cid:18)
ğµ Â·âˆ‘ï¸âŒŠlogğ‘˜ (ğ‘š)âŒ‹âˆ’2
Â· (1 âˆ’ ğµ) âŒŠlogğ‘˜ (ğ‘š)âŒ‹âˆ’1(cid:19)
(1 âˆ’ ğµ)ğ‘–(cid:19)
|G| âˆ’ ğ‘˜
2ğ‘˜
Â·
ğ‘–=0
where ğ‘˜ is the compression parameter and ğµ =
2(ğ‘˜âˆ’1)
|G|âˆ’ğ‘˜
5 OUR ZERO-KNOWLEDGE ARGUMENT FOR
ARITHMETIC AND BOOLEAN CIRCUITS
We describe now our ZK system for circuit satisfiability based
on the MPCitH paradigm. We combine a concrete MPC protocol
which verifies all the properties defined in Definition 3.2 and the
general ğœŒ-phase ZK interactive oracle protocol Î ğœŒâˆ’ZKIOP defined
in Section 3.2. Given an NP relation â„›, we consider a circuit ğ¶
over a finite field F such that ğ¶(ğ‘¤) = 1 if and only if (ğ‘¥, ğ‘¤) âˆˆ â„›.
Without loss of generality we assume that ğ¶ only contains linear
and multiplication gates.
Our MPC instantiation. Concretely, our MPC protocol Î ğ‘“ can be
divided in two phases. First, we have an input and evaluation phase
where the sender client ğ‘ƒğ‘† generates and distributes to the servers
ğ›¿ğ‘˜ =
(cid:18)
(cid:32)
(cid:19)
ğ‘š âˆ’ 1
1 âˆ’ ğ‘š âˆ’ 1
(cid:18)
|G| +
Â·
|G|
1 âˆ’ 2(ğ‘˜ âˆ’ 1)
2ğ‘˜
|G| âˆ’ 2 Â·
âŒŠlogğ‘˜ (ğ‘š)âŒ‹âˆ’2âˆ‘ï¸
|G| âˆ’ ğ‘˜
+ 2(ğ‘˜ âˆ’ 1)
|G| âˆ’ ğ‘˜
Â·
(cid:19) âŒŠlogğ‘˜ (ğ‘š)âŒ‹âˆ’1
(cid:18)
1 âˆ’ 2(ğ‘˜ âˆ’ 1)
|G| âˆ’ ğ‘˜
(cid:19)ğ‘–(cid:33)
ğ‘ƒğ‘–, ğ‘– âˆˆ [ğ‘›], an additive sharing of the input and sharings of the
output of each multiplication gate in the circuit. Given those, the
servers locally evaluate the circuit. In the second phase, parties
run the protocol Î CompressedMC described in the previous section
where ğ‘ƒğ‘† further plays the role of Î InnerProd and Î Rand.
Looking ahead, the protocol Î ğ‘“ , and therefore the MPCitH pro-
tocol based on it, will depend on several parameters: the size of the
circuit ğ¶, ğ‘š, i.e. the number of multiplication gates, the number ğ‘› of
servers parties in Î ğ‘“ , the size of the fields F and G, with |G| > ğ‘šâˆ’1,
and the compression parameter ğ‘˜ used in Î CompressedMC.