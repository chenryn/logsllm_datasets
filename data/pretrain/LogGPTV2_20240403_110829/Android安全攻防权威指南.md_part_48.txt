at
externa1/v8/src/bu11tins,cc:1120
[..-)
从中可以看出，调用栈非常完整，里面的一些函数调用最终导致了前溃。对于ARM架构，
可以通过查看LR寄存器的指向来明确程序是如何跳转到当前地址的。根据当前是Thumb模式还
是ARM模式，将LR指向的地址减去2或4，然后dump内存。如果LR的值是奇数，那么这个
地址一定指向Thumb指令。
(gdb)x/1 $1r - 2
0x5d46fee3 : blx  r2
这是一条跳转到R2寄存器的分支指令。查看R2寄存器的值可以确定程序为何在0处崩溃。
(gdb) 1 r r2
r2
0×0
0
上面的结果非常明显地解释了为何程序在崩溃的时候到达了地址0。
这当然还不是最终原因，所以要继续向后追踪数据流，查看R2为什么变成了0。分支语句
跳转到0显然是不正常的，所以继续查看调用函数的反汇编。
#10x5d46fee4 in webCore::Node1:parentNode (this=0x594134b0) at
(gdb)up
externa1/webki t/Souree/WelbCore/dom/Node .h : 731
731
return getFlag (IsShadowRootFlag) 11 isSVGShadowRoot() ? 0 :
parent () :
Dump of assenbler code for function WebCore::Node::parentNode (1 const:
(gdb)disa8
0x5646fed2 :
0x5d46fed0 1
push
(r4, 1r)
A0
r4, r0
0x5d46fed4
:
1dr
r3,
[r0, #36]
10x24
0x5d46fed6
0x5d46fed8
1
11
bp1.n 0x5d46fede
1818
r1, r3, #13
0x5d46feda
 1
novs
0x5d46fedc
:
(r4,pe)
r0,#0
0x5d46fede
1
pop
1dr
r1,
'0x]
[0#
0x5d46fee0 :
1dr
r2,
[r1, #112]
0x70
0x5d46fee2 :
b1x
---
## Page 215
7.9漏润分析
199
=> 0x5d46fee4 :
0x5d46fee6 1
cp
0x5d46feda 
r0,#0
0x5d46fee8 1
bne .n
1dr
r0, [r4, #12]
End of assembler dunp.
0x5d46feea 1
pop
(r4, pc)
这个反汇编列表展示了一个较短的函数，其中包含了跳转到R2的分支语句。这个函数并没
有接收任何参数，所以整个执行过程只依赖于对象的成员。向后分析可以看到，R2的值是从R1
指向的内存偏移112处取到的，面R1又是从R0指向的内存偏移0处取到的。现在确认一下是否
是这些内存使R2变为0。
(gdb) 1 r r1
(gdb)x/wx $r1 + 112
r1
0x5a621fa0
1516380064
0x5a622010: 0x00000000
0x5a621088: 0x5a621fa0
(gdb) ×/wx $x0
确认了！可以青定0x5a621fa0或者0x5a621088的内存块出了问题。继续检查这些内存块是
被释放状态还是被使用状态，只需查看0x5a621088处内存块的头部即可。
(gdb) x/2wox $r0 - 0x8
0x5a621080:0x000000000x00000031
查看第二个32位的值，它对应于当前内存块的大小，最低三位是标志位。第二位标志位为
0说明当前内存块是释放状态！所以可以肯定，这是一个释放后重用漏洞。
接下来，要知道这个内存块是在哪里被释放的。退出调试器，跟之前一样，再次让进程崩溃。
让shell脚本debugging.sh开始等待，然后启动浏览器，接下来用GDB服务器附加到进程。
注意对话框会间断性地出现，来询问是否要继续等待测览器响应。这是正常现象，因为调试
器让浏览器停止了执行。只需要点击等待（Wait）按钮（或者就忽略对话框）即可。
当浏览器再次启动时，用GDB客户端连接GDB服务器。这次，在调用函数中设置一个用于
道踪的断点，赶在前责之前与调试器进行交互：
(gdb) break *KebCore: :Node::parentNode () const *
Breakpoint 1 at 0x5d46fed2: file external/webkit/Source/WebCore/dom/Node .h,
line 730.
(gdb) commands
End with a 1ine saying just *end′.
>cont
>end
(gdb) cont
Continuing.
不幸的是，你会很快发现这个断点被命中得过于频繁了。这是因为WebKit代码里的很多地
方都调用了parentNode函数。为了解决这个间题，在更上一层的函数中下一个断点。
---
## Page 216
200
第7章调试与分析安全漏洞
WebCore1 : ReplacementFragment : :removeliode (WTF : : PassRefPtr) *
(gdb)break \
external/rebkit/Source/WebCore/editLng/ReplaceSelectionCommand. cpp, 1ine
Breakpoint 1 at 0x5d6748d4: fi1e
211.
(gdb) cont
Continuing.
设置断点之后，再次载入引发崩溃的页面。
Breakpoint 1, WebCore::ReplacementFragment::removeNode (this=0x5ea004a8,
node=...)
cpp:211
at external/webkit/Source/WebCore/editing/ReplaceSelectionCommand.
211
(gdb)
让程序在崩溃前停止，通过创建一个用来追踪的断点，就能够知道free函数是在哪里被调
用的了。为了减少干扰，可以把断点限制在当前线程中，但是需要事先知道当前的线程号。
(gdb)info threads
* 2
Thread 18733
WebCore: :Replacement.Fragment : :removeiode
(this=0x5e9004a8, node=...)
at externa1/webkit/Source/WebCore/editing/ReplaceSelectionCommand.
cpp:211
 = r
现在知道了当前的线程号是2，创建这个线程下的断点，然后设置一个在断点命中时执行一
些列命令的脚本。
(gdb) break d1free thread 2
Breakpoint 2 at 0x401259e2: fi1e
bionic/1ibc/bionic/../upstream-dlma1loc/malloc,c, 1ine 4711,
Type commands for breakpoint(s) 2. one per 1ine.
(gdb) comnands
>printf *free(0xkx)\n*, $r0
>silent
>printf *\n*
>back
>cont
>end
(gdb)cont
Continuing
继续执行后，就能立刻看到断点命中时的输出了。在浏览器再次崩溃之前，无需过于关注这
些输出。
注意在崩资之前，只需要告诉浏览器继续执行一次。如果调试器在此过程中发生了多次停顿，
那么最好杀掉浏览器进程并再次尝试。通过编写script.gdb脚本来完成整个步骤会让重启
整个过程变得不那么麻烦。
---
## Page 217
7.9淄洞分析
201
当浏览器再次崩溃，查看R0中的值：
(gdb) 1 r r0
r0
0x5a6a96d8
1516934872
然后向前查找调试器的输出，找到哪个free释放了这个地址处的内存块。
free (0x5a6a96d8)
#0d1free (mem=0x5a6a96d8) at
bionic/1ibc/bionic/ . /upstream-dlmal1oe/ma11oe,e:4711
10x401229c0 in free (men=) at
bionic/1ibc/bionic/na11oc_debug_common.cpp:230
#20x5d479b92 Ln WebCore11Text11~Text (thie=0x5a6a96d8, .in_
chrg=) at externa1/webkit/Source/webCore/dom/Text.h:30
WebCore::Containerlode> (container=)
30x5d644210 in WebCore: :removeA11Chi1drenInContainer)
60x5d651890 in WebCore::Element::-Element (this=0x5a8d36f0,
at external/webkit/Source/WebCore/dom/ContainerNode cpp:100
-in_chrg=)
0x5d65c5b4 in WebCore: :StyledElement:1~Styled81ement (this=0x5a8d36f0,
at externa1/webkit/Source/WebCore/dom/Element.cpp:118
-1n_chrg=coptimized out>)