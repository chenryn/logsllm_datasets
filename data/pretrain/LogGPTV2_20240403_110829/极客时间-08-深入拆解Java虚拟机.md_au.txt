## 逃逸分析逃逸分析是"一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针"（出处参见\[1\]）。在 Java虚拟机的即时编译语境下，逃逸分析将判断**新建**的对象是否**逃逸**。即时编译器判断对象是否逃逸的依据，一是对象是否被存入堆中（静态字段或者堆中对象的实例字段），二是对象是否被传入未知代码中。前者很好理解：一旦对象被存入堆中，其他线程便能获得该对象的引用。即时编译器也因此无法追踪所有使用该对象的代码位置。关于后者，由于 Java虚拟机的即时编译器是以方法为单位的，对于方法中未被内联的方法调用，即时编译器会将其当成未知代码，毕竟它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中。因此，我们可以认为方法调用的调用者以及参数是逃逸的。通常来说，即时编译器里的逃逸分析是放在方法内联之后的，以便消除这些"未知代码"入口。回到文章开头的例子。理想情况下，即时编译器能够内联对`ArrayList$Itr`构造器的调用，对`hasNext`以及`next`方法的调用，以及当内联了`Itr.next`方法后，对`checkForComodification`方法的调用。如果这些方法调用均能够被内联，那么结果将近似于下面这段伪代码：    public void forEach(ArrayList list, Consumer f) {  Itr iter = new Itr; // 注意这里是 new 指令  iter.cursor = 0;  iter.lastRet = -1;  iter.expectedModCount = list.modCount;  while (iter.cursor = list.size)      throw new NoSuchElementException();    Object[] elementData = list.elementData;    if (i >= elementData.length)      throw new ConcurrentModificationException();    iter.cursor = i + 1;    iter.lastRet = i;    Object obj = elementData[i];    f.accept(obj);  }}可以看到，这段代码所新建的`ArrayList$Itr`实例既没有被存入任何字段之中，也没有作为任何方法调用的调用者或者参数。因此，逃逸分析将断定该实例不逃逸。
## 基于逃逸分析的优化即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。我们先来看一下锁消除。如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没有意义。这是因为其他线程并不能获得该锁对象，因此也不可能对其进行加锁。在这种情况下，即时编译器可以消除对该不逃逸锁对象的加锁、解锁操作。实际上，传统编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。在介绍 Java内存模型时，我曾提过`synchronized (new Object()) {}`会被完全优化掉。这正是因为基于逃逸分析的锁消除。由于其他线程不能获得该锁对象，因此也无法基于该锁对象构造两个线程之间的happens-before 规则。`synchronized (escapedObject) {}`则不然。由于其他线程可能会对逃逸了的对象`escapedObject`进行加锁操作，从而构造了两个线程之间的happens-before关系。因此即时编译器至少需要为这段代码生成一条刷新缓存的内存屏障指令。不过，基于逃逸分析的锁消除实际上并不多见。一般来说，开发人员不会直接对方法中新构造的对象进行加锁。事实上，逃逸分析的结果更多被用于将新建对象操作转换成栈上分配或者标量替换。我们知道，Java虚拟机中对象都是在堆上分配的，而堆上的内容对任何线程都是可见的。与此同时，Java虚拟机需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么 Java虚拟机完全可以将其分配至栈上，并且在 new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过，由于实现起来需要更改大量假设了"对象只能堆分配"的代码，因此 HotSpot虚拟机**并没有**采用栈上分配，而是使用了标量替换这么一项技术。所谓的标量，就是仅能存储一个值的变量，比如 Java代码中的局部变量。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java 对象。标量替换这项优化技术，可以看成将原本对对象的字段的访问，替换为一个个局部变量的访问。举例来说，前面经过内联之后的forEach 代码可以被转换为如下代码：    public void forEach(ArrayList list, Consumer f) {  // Itr iter = new Itr; // 经过标量替换后该分配无意义，可以被优化掉  int cursor = 0;     // 标量替换  int lastRet = -1;   // 标量替换  int expectedModCount = list.modCount; // 标量替换  while (cursor = list.size)      throw new NoSuchElementException();    Object[] elementData = list.elementData;    if (i >= elementData.length)      throw new ConcurrentModificationException();    cursor = i + 1;    lastRet = i;    Object obj = elementData[i];    f.accept(obj);  }}可以看到，原本需要在内存中连续分布的对象，现已被拆散为一个个单独的字段`cursor`，`lastRet`，以及`expectedModCount`。这些字段既可以存储在栈上，也可以直接存储在寄存器中。而该对象的对象头信息则直接消失了，不再被保存至内存之中。由于该对象没有被实际分配，因此和栈上分配一样，它同样可以减轻垃圾回收的压力。与栈上分配相比，它对字段的内存连续性不做要求，而且，这些字段甚至可以直接在寄存器中维护，无须浪费任何内存空间。
## 部分逃逸分析C2 的逃逸分析与控制流无关，相对来说比较简单。Graal则引入了一个与控制流有关的逃逸分析，名为部分逃逸分析（partial escapeanalysis）\[2\]。它解决了所新建的实例仅在部分程序路径中逃逸的情况。举个例子，在下面这段代码中，新建实例只会在进入 if-then分支时逃逸。（对`hashCode`方法的调用是一个 HotSpotintrinsic，将被替换为一个无法内联的本地方法调用。）    public static void bar(boolean cond) {  Object foo = new Object();  if (cond) {    foo.hashCode();  }}// 可以手工优化为：public static void bar(boolean cond) {  if (cond) {    Object foo = new Object();    foo.hashCode();  }}假设 if 语句的条件成立的可能性只有 1%，那么在 99%的情况下，程序没有必要新建对象。其手工优化的版本正是部分逃逸分析想要自动达到的成果。部分逃逸分析将根据控制流信息，判断出新建对象仅在部分分支中逃逸，并且将对象的新建操作推延至对象逃逸的分支中。这将使得原本因对象逃逸而无法避免的新建对象操作，不再出现在只执行if-else 分支的程序路径之中。综上，与 C2 所使用的逃逸分析相比，Graal所使用的部分逃逸分析能够优化更多的情况，不过它编译时间也更长一些。
## 总结与实践今天我介绍了 Java 虚拟机中即时编译器的逃逸分析，以及基于逃逸分析的优化。在 Java虚拟机的即时编译语境下，逃逸分析将判断新建的对象是否会逃逸。即时编译器判断对象逃逸的依据有两个：一是看对象是否被存入堆中，二是看对象是否作为方法调用的调用者或者参数。即时编译器会根据逃逸分析的结果进行优化，如锁消除以及标量替换。后者指的是将原本连续分配的对象拆散为一个个单独的字段，分布在栈上或者寄存器中。部分逃逸分析是一种附带了控制流信息的逃逸分析。它将判断新建对象真正逃逸的分支，并且支持将新建操作推延至逃逸分支。------------------------------------------------------------------------今天的实践环节有两项内容。第一项内容，我们来验证一下`ArrayList.iterator`中的新建对象能否被逃逸分析所优化。运行下述代码并观察GC的情况。你可以通过虚拟机参数`-XX:-DoEscapeAnalysis`来关闭默认开启的逃逸分析。    // Run with// java -XX:+PrintGC -XX:+DoEscapeAnalysis EscapeTestimport java.util.ArrayList;import java.util.function.Consumer; public class EscapeTest {   public static void forEach(ArrayList list, Consumer f) {    for (Object obj : list) {      f.accept(obj);    }  }   public static void main(String[] args) {    ArrayList list = new ArrayList<>();    for (int i = 0; i  {});    }  }} 第二项内容，我们来看一看部分逃逸分析的效果。你需要使用附带 Graal编译器的 Java 版本，如 Java 10，来运行下述代码，并且观察 GC的情况。你可以通过虚拟机参数`-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler`来启用Graal。    // Run with// java -Xlog:gc Foo// java -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler -Xlog:gc Foopublic class Foo {  long placeHolder0;  long placeHolder1;  long placeHolder2;  long placeHolder3;  long placeHolder4;  long placeHolder5;  long placeHolder6;  long placeHolder7;  long placeHolder8;  long placeHolder9;  long placeHoldera;  long placeHolderb;  long placeHolderc;  long placeHolderd;  long placeHoldere;  long placeHolderf;  public static void bar(boolean condition) {    Foo foo = new Foo();    if (condition) {      foo.hashCode();    }  }  public static void main(String[] args) {    for (int i = 0; i ![](Images/a500044f1e4938fb43719f802cba82d8.png){savepage-src="https://static001.geekbang.org/resource/image/2a/d5/2a62e58cbdf56a5dc40748567d346fd5.jpg"}
# 【工具篇】 常用工具介绍在前面的文章中，我曾使用了不少工具来辅助讲解，也收到了不少同学留言，说不了解这些工具，不知道都有什么用，应该怎么用。那么今天我便统一做一次具体的介绍。本篇代码较多，你可以点击文稿查看。
## javap：查阅 Java 字节码javap 是一个能够将 class文件反汇编成人类可读格式的工具。在本专栏中，我们经常借助这个工具来查阅Java 字节码。举个例子，在讲解异常处理那一篇中，我曾经展示过这么一段代码。    public class Foo {  private int tryBlock;  private int catchBlock;  private int finallyBlock;  private int methodExit;   public void test() {    try {      tryBlock = 0;    } catch (Exception e) {      catchBlock = 1;    } finally {      finallyBlock = 2;    }    methodExit = 3;  }}编译过后，我们便可以使用 javap 来查阅 Foo.test 方法的字节码。    $ javac Foo.java$ javap -p -v FooClassfile ../Foo.class  Last modified ..; size 541 bytes  MD5 checksum 3828cdfbba56fea1da6c8d94fd13b20d  Compiled from "Foo.java"public class Foo  minor version: 0  major version: 54  flags: (0x0021) ACC_PUBLIC, ACC_SUPER  this_class: #7                          // Foo  super_class: #8                         // java/lang/Object  interfaces: 0, fields: 4, methods: 2, attributes: 1Constant pool:   #1 = Methodref          #8.#23         // java/lang/Object."":()V   #2 = Fieldref           #7.#24         // Foo.tryBlock:I   #3 = Fieldref           #7.#25         // Foo.finallyBlock:I   #4 = Class              #26            // java/lang/Exception   #5 = Fieldref           #7.#27         // Foo.catchBlock:I   #6 = Fieldref           #7.#28         // Foo.methodExit:I   #7 = Class              #29            // Foo   #8 = Class              #30            // java/lang/Object   #9 = Utf8               tryBlock  #10 = Utf8               I  #11 = Utf8               catchBlock  #12 = Utf8               finallyBlock  #13 = Utf8               methodExit  #14 = Utf8                 #15 = Utf8               ()V  #16 = Utf8               Code  #17 = Utf8               LineNumberTable  #18 = Utf8               test  #19 = Utf8               StackMapTable  #20 = Class              #31            // java/lang/Throwable  #21 = Utf8               SourceFile  #22 = Utf8               Foo.java  #23 = NameAndType        #14:#15        // "":()V  #24 = NameAndType        #9:#10         // tryBlock:I  #25 = NameAndType        #12:#10        // finallyBlock:I  #26 = Utf8               java/lang/Exception  #27 = NameAndType        #11:#10        // catchBlock:I  #28 = NameAndType        #13:#10        // methodExit:I  #29 = Utf8               Foo  #30 = Utf8               java/lang/Object  #31 = Utf8               java/lang/Throwable{  private int tryBlock;    descriptor: I    flags: (0x0002) ACC_PRIVATE   private int catchBlock;    descriptor: I    flags: (0x0002) ACC_PRIVATE   private int finallyBlock;    descriptor: I    flags: (0x0002) ACC_PRIVATE   private int methodExit;    descriptor: I    flags: (0x0002) ACC_PRIVATE   public Foo();    descriptor: ()V    flags: (0x0001) ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object."":()V         4: return      LineNumberTable:        line 1: 0   public void test();    descriptor: ()V    flags: (0x0001) ACC_PUBLIC    Code:      stack=2, locals=3, args_size=1         0: aload_0         1: iconst_0         2: putfield      #2                  // Field tryBlock:I         5: aload_0         6: iconst_2         7: putfield      #3                  // Field finallyBlock:I        10: goto          35        13: astore_1        14: aload_0        15: iconst_1        16: putfield      #5                  // Field catchBlock:I        19: aload_0        20: iconst_2        21: putfield      #3                  // Field finallyBlock:I        24: goto          35        27: astore_2        28: aload_0        29: iconst_2        30: putfield      #3                  // Field finallyBlock:I        33: aload_2        34: athrow        35: aload_0        36: iconst_3        37: putfield      #6                  // Field methodExit:I        40: return      Exception table:         from    to  target type             0     5    13   Class java/lang/Exception             0     5    27   any            13    19    27   any      LineNumberTable:        line 9: 0        line 13: 5        line 14: 10        line 10: 13        line 11: 14        line 13: 19        line 14: 24        line 13: 27        line 14: 33        line 15: 35        line 16: 40      StackMapTable: number_of_entries = 3        frame_type = 77 /* same_locals_1_stack_item */          stack = [ class java/lang/Exception ]        frame_type = 77 /* same_locals_1_stack_item */          stack = [ class java/lang/Throwable ]        frame_type = 7 /* same */}SourceFile: "Foo.java"这里面我用到了两个选项。第一个选项是 -p。默认情况下 javap会打印所有非私有的字段和方法，当加了 -p选项后，它还将打印私有的字段和方法。第二个选项是-v。它尽可能地打印所有信息。如果你只需要查阅方法对应的字节码，那么可以用-c 选项来替换 -v。javap 的 -v 选项的输出分为几大块。1\. 基本信息，涵盖了原 class 文件的相关信息。class 文件的版本号（minor version: 0，major version:54），该类的访问权限（flags: (0x0021) ACC_PUBLIC,ACC_SUPER），该类（this_class: #7）以及父类（super_class:#8）的名字，所实现接口（interfaces: 0）、字段（fields:4）、方法（methods: 2）以及属性（attributes: 1）的数目。这里属性指的是 class 文件所携带的辅助信息，比如该 class文件的源文件的名称。这类信息通常被用于 Java 虚拟机的验证和运行，以及Java 程序的调试，一般无须深入了解。    Classfile ../Foo.class  Last modified ..; size 541 bytes  MD5 checksum 3828cdfbba56fea1da6c8d94fd13b20d  Compiled from "Foo.java"public class Foo  minor version: 0  major version: 54  flags: (0x0021) ACC_PUBLIC, ACC_SUPER  this_class: #7                          // Foo  super_class: #8                         // java/lang/Object  interfaces: 0, fields: 4, methods: 2, attributes: 1class 文件的版本号指的是编译生成该 class 文件时所用的 JRE 版本。由较新的JRE 版本中的 javac 编译而成的 class 文件，不能在旧版本的 JRE上跑，否则，会出现如下异常信息。（Java 8 对应的版本号为 52，Java 10对应的版本号为 54。）    Exception in thread "main" java.lang.UnsupportedClassVersionError: Foo has been compiled by a more recent version of the Java Runtime (class file version 54.0), this version of the Java Runtime only recognizes class file versions up to 52.0类的访问权限通常为 ACC\_ 开头的常量。具体每个常量的意义可以查阅 Java虚拟机规范 4.1 小节 \[1\]。2\. 常量池，用来存放各种常量以及符号引用。常量池中的每一项都有一个对应的索引（如#1），并且可能引用其他的常量池项（#1 = Methodref #8.#23）。    Constant pool:   #1 = Methodref          #8.#23         // java/lang/Object."":()V...    #8 = Class              #30            // java/lang/Object...  #14 = Utf8                 #15 = Utf8               ()V...  #23 = NameAndType        #14:#15        // "":()V...  #30 = Utf8               java/lang/Object举例来说，上图中的 1 号常量池项是一个指向 Object类构造器的符号引用。它是由另外两个常量池项所构成。如果将它看成一个树结构的话，那么它的叶节点会是字符串常量，如下图所示。![](Images/500dbf2463954b38df15a9fc61f29785.png){savepage-src="https://static001.geekbang.org/resource/image/f8/8c/f87469e321c52b21b0d2abb88e7b288c.png"}3\. 字段区域，用来列举该类中的各个字段。这里最主要的信息便是该字段的类型（descriptor: I）以及访问权限（flags:(0x0002) ACC_PRIVATE）。对于声明为 final的静态字段而言，如果它是基本类型或者字符串类型，那么字段区域还将包括它的常量值。      private int tryBlock;    descriptor: I    flags: (0x0002) ACC_PRIVATE 另外，Java虚拟机同样使用了"描述符"（descriptor）来描述字段的类型。具体的对照如下表所示。其中比较特殊的，我已经高亮显示。4\. 方法区域，用来列举该类中的各个方法。除了方法描述符以及访问权限之外，每个方法还包括最为重要的代码区域（Code:)。      public void test();    descriptor: ()V    flags: (0x0001) ACC_PUBLIC    Code:      stack=2, locals=3, args_size=1         0: aload_0...        10: goto          35...        34: athrow        35: aload_0...        40: return      Exception table:         from    to  target type             0     5    13   Class java/lang/Exception             0     5    27   any            13    19    27   any      LineNumberTable:        line 9: 0...        line 16: 40      StackMapTable: number_of_entries = 3        frame_type = 77 /* same_locals_1_stack_item */          stack = [ class java/lang/Exception ]...代码区域一开始会声明该方法中的操作数栈（stack=2）和局部变量数目（locals=3）的最大值，以及该方法接收参数的个数（args_size=1）。注意这里局部变量指的是字节码中的局部变量，而非Java 程序中的局部变量。接下来则是该方法的字节码。每条字节码均标注了对应的偏移量（bytecodeindex，BCI），这是用来定位字节码的。比如说偏移量为 10 的跳转字节码 10:goto 35，将跳转至偏移量为 35 的字节码 35: aload_0。紧跟着的异常表（Exceptiontable:）也会使用偏移量来定位每个异常处理器所监控的范围（由 from 到 to的代码区域），以及异常处理器的起始位置（target）。除此之外，它还会声明所捕获的异常类型（type）。其中，any指代任意异常类型。再接下来的行数表（LineNumberTable:）则是 Java源程序到字节码偏移量的映射。如果你在编译时使用了 -g 参数（javac -gFoo.java），那么这里还将出现局部变量表（LocalVariableTable:），展示 Java程序中每个局部变量的名字、类型以及作用域。行数表和局部变量表均属于调试信息。Java 虚拟机并不要求 class文件必备这些信息。          LocalVariableTable:        Start  Length  Slot  Name   Signature           14       5     1     e   Ljava/lang/Exception;            0      41     0  this   LFoo;最后则是字节码操作数栈的映射表（StackMapTable: number_of_entries =3）。该表描述的是字节码跳转后操作数栈的分布情况，一般被 Java虚拟机用于验证所加载的类，以及即时编译相关的一些操作，正常情况下，你无须深入了解。