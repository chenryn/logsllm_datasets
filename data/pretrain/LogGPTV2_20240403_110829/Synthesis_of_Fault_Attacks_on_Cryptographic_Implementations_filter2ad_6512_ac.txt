are linear combinations of p and q with almost full coeﬃ-
cients. A variant of this fault condition is implicit in [14].
Proposition 2. Assume that N is a balanced RSA mod-
ulus, i.e. N = p · q such that p, q  0, one can eﬃciently factor the RSA modulus N .
The value of ε depends on n and impacts the eﬃciency and
success probability of the algorithm to recover the factoriza-
tion.
Relating this fault condition with [14]. In [14], the au-
thors force random faults on the modulus during CRT re-
combination and obtain a fault condition of the following
form.
−1 mod q)+β·q(q
−1 mod p)∧α, β < 2n/2.
(cid:98)S : ∃α, β.(cid:98)S = α·p(p
If our condition is similar to theirs, the algorithmic prob-
lem ours captures is more general. Indeed, in the analysis,
the crucial parameter is the ratio between the size of p, q
and the size of α, β in the relation S = α · p + β · q. The
larger this ratio is, the easier the attack is since the target
√
vector, called u above is larger. In our case, the size of this
vector is close to 2ε/
(cid:96) while [14] consider a much larger
one (their ratio is(cid:112)N/(cid:96)).
1020p, q
xi, yi
(cid:96)
512 (bits)
480
472
26
33
464
22
496
74
968
37
1024 (bits)
984
976
44
53
992
67
Figure 8: Minimal number of signatures (cid:96) to be
faulted depending on the bitsize of xi, yi. Almost
full linear combinations of p and q.
p, q
xi, yi
(cid:96)
512 (bits)
480
472
28
35
464
23
496
77
968
39
1024 (bits)
984
976
46
56
992
71
Figure 9: Minimal number of signatures (cid:96) to be
faulted depending on the bitsize of yi. Almost full
aﬃne transforms of p or q.
Finding “almost full” afﬁne transforms of p or q. Our
third fault condition considers faulted signatures that are
almost full aﬃne transforms of p or q. This condition is
implicit in [19].
Proposition 3. Assume that N is a balanced RSA mod-
ulus, i.e. p, q such that p, q < 2n/2. Given a suﬃcient num-
ber of values that satisfy the fault condition:
S : ∃x, y. S = x · p + y ∧ x < q,|y| < 2n/2−ε,
one can eﬃciently factor the RSA modulus N . The value ε
depends on n and impacts the eﬃciency and success proba-
bility of the algorithm to recover the factorization.
Implementation and evaluation of key recovery
We now describe how the attacks outlined above can be
performed in practice. Moreover, we estimate the number
of signatures required for recovering the factorization.
Implementation. We use the SAGE computer algebra sys-
tem [45] to implement the attacks. The attacks take as
input a suﬃcient number of signatures S1,··· , S(cid:96) satisfying
the fault condition given in Proposition 2 or Proposition 3.
The implementation heuristically recovers the factorization
of the RSA modulus N as follows.
• Compute an LLL-reduced basis {b1,··· , b(cid:96)−1} of the
lattice (S1,··· , S(cid:96))⊥. This is done by applying LLL
to the lattice in Z1+(cid:96) generated by the rows of the
following matrix: κS1
1
0
. . .
0
1
...
κS(cid:96)
where κ is a suitably large constant, and removing the
ﬁrst component of each resulting vector [37].
• Compute an LLL-reduced basis {x(cid:48), y(cid:48)} of the orthog-
onal lattice {b1,··· , b(cid:96)−2}⊥. Again, this is done by
applying LLL to the lattice in Z(cid:96)−2+(cid:96) generated by
the rows of κ(cid:48)b1,1
...
κ(cid:48)b1,(cid:96)
··· κ(cid:48)b(cid:96)−2,1
...
··· κ(cid:48)b(cid:96)−2,1
1
0
. . .
0
1
and keeping the last (cid:96) components of each resulting
vector.
• For all the linear combinations z of x(cid:48) and y(cid:48) that sat-
isfy the size constraints, compute the test gcd(z1S2 −
z2S1, N ) or gcd(y1 − S1, N ), depending on the fault
condition considered, which allows to recover the prime
factors p and q.
Evaluation. We use our SAGE implementation to evaluate
the number of signatures required for the attacks to succeed.
The results are given in Figures 8 and 9. We see for instance
that 35 values are required to retrieve the factorization of
N when p and q are 1024-bit and the size of the xis and yis
have size 960, i.e. 64 bits shorter than the full size.
3.2 Fault conditions for ECDSA signatures
For ECDSA signatures, we consider fault conditions of a
diﬀerent nature, that rely on partial knowledge of the nonce
k used in the computation. We ﬁrst consider a novel fault
condition focusing only on faulting the scalar multiplication.
Then, we discuss an already-exploited fault condition where
k can be faulted during both the scalar multiplication and
the computation of its inverse, as considered in [36]. In both
cases, knowing some bits of the nonce k is suﬃcient to mount
a classic lattice-based attack. In the following, we assume
that the message to be signed is known and its hash value is
h and we denote abs the abscissa of an elliptic curve point,
lsb(cid:96) k the (cid:96) least signiﬁcant bits of k and (cid:29) for the right-shift
operator.
Faulting r. Our fault condition considers faulted signatures
such that r is computed using only some of the bits of k:
Proposition 4. Given suﬃciently many values satisfy-
ing one of the fault conditions:
r, s : ∃k. r = abs([k (cid:29) (cid:96)] · P ) ∧ s = k
−1(h + rx) mod q
r, s : ∃k. r = abs(±[2(cid:96)] · [k (cid:29) (cid:96)] · P ) ∧ s = k
one can eﬃciently retrieve the secret key x.
(1)
−1(h + rx) mod q
(2)
The proof of this proposition can be done in two parts,
summed up by two facts. We do the proof for condition (1),
but a similar proof applies for condition (2). In particular,
Fact 2 tells us that it is suﬃcient to be able to recover (cid:96)
bits of k to recover the secret key x, and the proof of Fact 1
generalizes to condition (2), since it revolves around compu-
tations on curve points ±[2(cid:96)] · [k (cid:29) (cid:96)] · P .
Fact 1. Given a single pair (r, s) that satisﬁes the fault
condition:
r, s : ∃k. r = abs([k (cid:29) (cid:96)] · P ) ∧ s = k
−1(h + rx) mod q,
one can eﬃciently retrieve the (cid:96) least signiﬁcant bits of k.
Now, given suﬃciently many faulty signatures, the secret
x can be recovered using a technique based on lattices.
Fact 2. Given a suﬃcient number of ECDSA signatures
whose nonces k are partially known, one can eﬃciently re-
trieve the secret key x.
1021Note to conclude that a similar result holds for the most
signiﬁcant bits. For example, condition 1 in this case could
be written as follows.
r, s : r = abs([k mod 2n−(cid:96)]P ) ∧ s = k
−1(h + rx) mod q.
In this case, we retrieve the most signiﬁcant bits of the
nonces and adapt the lattice to this case without diﬃculty.
Using short randomness: faulting r and s.. We also con-
sider the following fault condition, implicitly used in the
original attack on ECDSA by Nguyen et al. [36], where both
the scalar multiplication and ﬁeld inversion are faulted to
simulated short values for k (that is, values whose most sig-
niﬁcant or least signiﬁcant bits are zero).
Proposition 5
([36]). Given a suﬃcient number of pairs
(r, s) that satisfy the fault condition:
r, s : ∃k. r = abs([lsb(k)] · P ) ∧ s = lsb(k)
one can eﬃciently recover the secret key x.
−1(h + rx) mod q,
Although we do not prove it, the validity of this fault
condition is justiﬁed by its use in existing attacks.
q
(cid:96)
d
160 (bits)
4
8
23
61 ( (cid:39)70%)
16
11
256 (bits)
8
38
16
17
32
9
384 (bits)
8
61
16
26
Figure 10: Minimal number of signatures d to
be faulted depending on (cid:96) using curves brain-
poolP160r1, brainpoolP256r1 and brainpoolP384r1.
The percentage given in one case represents the suc-
cess rate of the attack and could be increased by
increasing the value of d.
Implementation and evaluation.. We also implement our
key recovery attacks on ECDSA in Sage to evaluate their
performance. Some experimental values of ((cid:96), d) are given
in Figure 10.
3.3 Discussion
All the fault conditions considered above are intended to
predicate over the output of faulted signatures. However,
fault conditions may also relate outputs of faulted and valid
signatures, or inputs and outputs of signatures. Examples
of such fault conditions are given by the original Bellcore
attack and by Lenstra’s variant:
: S1 − S2 ≡ 0 mod p ∧ S1 − S2 (cid:54)≡ 0 mod q
S1, S2
M, S : S − M e ≡ 0 mod p ∧ S − M e (cid:54)≡ 0 mod q
Both conditions can be further reﬁned. For instance, the
fault condition for the Bellcore attack can be reﬁned to ex-
press that one of the Si, say for instance S1, is a valid sig-
nature of a message m, and S2 is a faulty signature of m. In
fact, one can deﬁne a partial order on fault conditions2 and
prove that the above fault conditions are less than the fault
condition given in Proposition 1.
2 (v1, . . . , vn : φ) ≤ (w1, . . . , wm : ψ) if there exists
an eﬃcient and public n-ary function f that returns m-
tuples of values and such that for every v1, . . . , vn such
that φ(v1, . . . , vn) holds and for every w1, . . . , wm such that
f (v1, . . . , vn) = (w1, . . . , wm), we also have ψ(w1, . . . , wm).
C ::= skip
| C; C
| V ← E
| V $← DE
|
| while E do C
| V ← P(E, . . . ,E)
| return E
if E then C else C conditional
while loop
procedure call
return expression
sequencing
deterministic assignment
random assignment
where V denotes the set of variables, E denotes the set of
expressions, DE denotes the set of distribution expressions
and P denotes the set of procedures.
Figure 11: Syntax of programs
4. SYNTHESIS OF FAULTED IMPLEMEN-
TATIONS
In this section, we present an automated tool that synthe-
sizes faulted implementations that verify a fault condition.
Our tool is built on top of EasyCrypt [8], a tool-assisted
framework for verifying the security of cryptographic con-
structions.
4.1 Programming and assertion language
We consider programs that are written in a core imper-
ative language with deterministic and probabilistic assign-
ments, conditionals, loops, procedure calls, and sequential
composition; the syntax of programs is given in Figure 11.
The programming language essentially subsumes the lan-
guage proposed in [11] and in particular is suﬃciently ex-
pressive to capture cryptographic implementations.
Expressions used in programs, for instance on the right-
hand side of assignments or as guards in conditional state-
ments and loops are built inductively from user-deﬁned con-
stants, operators, and variables. In this paper, we speciﬁ-
cally focus on expressions that are built from operations for
modular arithmetic, and ﬁnite ﬁeld and elliptic curve op-
erations. We use a simple type system for expressions and
programs, and we only consider well-typed programs.
Assertions are ﬁrst-order formulae over the theories inher-
ited from the expression language. Reasoning about asser-
tions is delegated to the EasyCrypt proof engine, which can
either use lemmas from libraries or invoke SMT solvers to
prove the validity of an assertion.
4.2 Fault models and fault policies
Fault models. Fault models are high-level speciﬁcations of
the type of faults that can be injected on embedded devices;