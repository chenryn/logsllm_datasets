11%
11%
9%
14%
10%
10%
4.3.2. Myrinet packet type corruption. Myrinet packet
types are determined by a four byte subsection of the packet
header. Because Myrinet packet headers are appended to
packets by the network hardware, they are not normally
accessible to higher-level
Although most
packet types are reserved for relatively obscure protocols
(the Myrinet website contains a complete list), we looked at
three of particular interest.
techniques.
Mapping packet corruption.
First, we examined the
behavior of a corrupted mapping packet header. Mapping
packets are designated with the 16-bit hexadecimal string
0005. This string was corrupted to read 000x, where x is
a random value. A node that receives the corrupted packet is
removed from the network. A node that replies to a mapping
query with a corrupted packet is also removed from the
network. This occurs because in both cases the mapper
does not detect a response to the mapping packet, and
updates the routing tables accordingly. The node will
remain out of the network until the next mapping packet is
received. This can cause a significant performance hit in a
high-speed network where hundreds of megabytes are
transmitted every second.
Data packet corruption.
The network response to
corrupted data packet headers (0004) was also examined.
In this case, the data packets are dropped by the receiving
node and not recognized as data packets. The internal
network structures, such as the routing table,
remain
unchanged after this failure, since they are not developed by
the results of data packet transmission, and are not affected
by data packet transmission failures.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:18:26 UTC from IEEE Xplore.  Restrictions apply. 
Source route corruption. The beginning of each Myrinet
header contains the routing information for the next link of
the journey. If the packet is being routed to a switch, the
MSB must be one. When the packet expects to reach its
destination, the MSB must be zero. If the packet reaches a
destination interface with the MSB set to one, the Myrinet
standard specifies that the packet be "consumed and handled
as an error". This assertion was tested by setting the MSB to
one when packets arrived at
interface. The
interface was observed to drop these packets without
incident, and without causing delays or other errors on the
target node.
the target
Other errors were also injected into the routing
subsection, directing packets to the wrong ports on the
switch, or directing them to the wrong host interface. These
errors resulted in the expected packet losses, but none of the
packets were accepted by the incorrect nodes. No bad data
was passed on to a higher level, and there was no error
propagation.
4.3.3. Physical address corruption. We also looked at the
impact of data-link layer
in the
corruption of the physical addresses themselves, which are
48-bit Ethernet addresses corresponding to individual
Myrinet ports.
faults which result
Destination corruption. One error campaign looked at
the network response to bad addressing. In the targeted
packets, we replaced the destination address with the
address of another node on the network. We observed that
the packets were dropped and not received by either the
intended destination node or the erroneously specified node.
This is a result of the incorrect CRC-8 included in the
Myrinet packets.
Sender's address corruption.
In a second experiment,
the target node's own address was corrupted to match the
address of another node on the network. The node became
unreachable to all Ethernet-based network traffic, because
the node drops incoming packets that are misaddressed.
Since the node does not see its own address, it drops all
packets as being misaddressed. However,
the node still
responds correctly to mapping packets, and the routing
information concerning the node remained unchanged. This
works because the network map is developed using relative
destination ports, instead of unique addresses like Ethernet
provides.
Address corrupted to match address of controller. Most
interesting is the case when a node's address is corrupted to
match the address of the controller (i.e. the node in charge
of network mapping). This causes the routing table to
become badly corrupted. Figure 9 shows the network map
after the routing table error (cf. the uncorrupted network
map of Figure 8).
The controller is confused by the
appearance of what it believes is another controller, and is
unable to generate a consistent map. Each attempt
to
resolve the network fails in an apparently random fashion,
and although the faulty map was not static, each subsequent
mapping attempt results in a similarly damaged map.
Figure 9: Network after address corruption
Address corruption to a non-existent address. Another
error mode occurs when a node's address is corrupted into a
non-existent address. In this case, packets in transition are
dropped, and the routing table is updated with the new
information. This is the expected Myrinet response, since it
is analogous to removing a computer and replacing it with
another.
4.3.4. UDP address corruption. The fault injector can
also emulate faults at higher network levels. We ran a fault
injection campaign that looked at UDP packet corruption.
Since UDP uses a 16-bit one's complement checksum,
corrupt packets should be detected and dropped by the UDP
layer. However, if the fault is manifested in a way that also
satisfies the checksum,
the incorrect packet should be
passed through. Because the checksum is 16 bits, this can be
done by swapping bits that are 16 bits apart.
In our case, we corrupted a UDP packet consisting of the
string "Have a lot of fun" to read instead "veHa a lot of
fun". The checksum was unable to detect
this, and the
incorrect message was passed on to the sending application.
When the corruption did not satisfy the checksum,
the
packets were dropped.
This campaign also demonstrated the ability of the fault
injector to examine various transmission protocols. Since
the expected behavior was seen in all cases, we were able to
conclude that
injector was indeed working as
intended.
the fault
4.4. Discussion – faults considered harmful
is
an important
The characterization of errors in hardware-generated
control packets
consideration when
designing new networking protocols and technologies.
FPGA-based fault injectors like the one used in this study
can provide useful insights into the behavior of networks
under faults that would otherwise be difficult to simulate,
for example using software-implemented fault-injection.
Specifically, the proposed design demonstrates the ability to
perform a fault injection campaign on control information
and other low level data-link layer faults by using precisely
determined bit flips and corruptions.
The fault injector gave us the ability to examine the
response of a high-speed Myrinet network to low-level
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:18:26 UTC from IEEE Xplore.  Restrictions apply. 
In general, the Myrinet network performed
control faults.
acceptably. Although Myrinet was not designed to be a
fault tolerant protocol, it does have some error protection.
For example, the control symbols were chosen such that a
single 1-to-0 bit flip would not change the interpretation of
the symbol. Although many of the exhibited responses to
faults were unexpected, the Myrinet protocols were able to
handle these faults with only transient downtime.
When considering a given design’s response to different
faults, it may be helpful to consider a difference between a
passive fault and an active fault. We consider a fault active
if it passes incorrect data or results to a higher system level.
Examples of active faults would be the successful receipt of
a message addressed to someone else, or an application
crash due to control symbol corruption. On the other hand,
we consider a fault to be passive if it puts the network into
an unexpected and incorrect state, allowing the affected
nodes
to make bad decisions based on erroneous
information. The routing table corruption discussed above is
an example of a passive fault. Using this terminology, the
faults observed in our injection campaigns were all passive.
Data were dropped and lost, but not incorrectly passed on.
This may still be of
concern to many distributed
applications, such as Chameleon [20], which provides a
software-implemented
environment.
Chameleon contains application processes that block while
waiting for certain messages.
If errors in the underlying
Myrinet network cause a node to hang [6], processes that
require the services of a blocking process will block as well,
causing correlated failures.
(Chameleon handles this
situation by diagnosing a hang, and initiating its recovery
protocol.)
tolerant
fault
5. Conclusions
This paper presents a configurable architecture for
performing data-link level network fault
injection. The
architecture is unique and enables synchronous injection on
high-speed networks. The proposed architecture employs
reconfigurable logic in the data path and therefore can
support a multitude of configurations. The fault injection
functionality was developed in hardware description
language, synthesized, and simulated. A high-speed PCB
was manufactured, assembled, and tested.
A fault injection campaign on a Myrinet network showed
the versatility and usefulness of the device. The campaign
included a variety of
faults inaccessible to traditional
SWIFI, such as control packet faults. The reconfigurable
nature of the device provides flexibility to conduct a wide
range of
injection campaigns, as well as future
research in testability, fault-tolerance, and other related
fields.
fault
Acknowledgments
This work was supported in part by NSF grants CCR-00-
86096ITR and CCR99-02026, and by a Motorola grant
under the Motorola Center for Communications.
References
of
Computer
Experimental Analysis
Iyer R. K., D. Tang, “Fault-Tolerant Computer System
System
[1] Boden N. et al., “Myrinet: A Gigabit-per-Second Local-Area
Network,” IEEE Micro, vol.15, no.1, 1995, pp.29-36.
[2] ANSI Standard X3.230:1994, “Fibre Channel - Physical and
Signaling Interface
(FC-PH), American National Standards
Institute, New York, NY, 1994.
[3] Karlsson J. et al., “Using Heavy-Ion Radiation to Validate
Fault-Handling Mechanisms,” IEEE Micro, vol.14, no.1, 1994,
pp.8-23.
[4] Arlat J. et al., “Fault Injection for Dependability Validation of
Fault-Tolerant Computing Systems,” Proc. 19th Int. Symp. on
Fault-Tolerant Computing (FTCS-19), 1989, pp.348-355.
[5] Madeira H. et al., “RIFLE: A General Purpose Pin-level Fault
Injector,
in Proc. 1st European Dependable Computing Conf.
(EDCC-1), 1994, pp.199-216.
[6] Stott D. et al., “NFTAPE: A Framework for Assessing
Dependability in Distributed Systems with Lightweight Fault
Injectors,” IEEE Int. Computer Performance and Dependability
Symp. (IPDS'00), 2000, pp.91-100.
[7] Hsueh M.-C. et al., “Fault Injection Techniques and Tools,”
Computer, vol.30, no.4, 1997, pp.75-82.
[8] Madeira H. et al., “On the Emulation of Software Faults by
Software Fault Injection”, Internatioal Conference on Dependable
Networks and Systems, 2000, pp. 417-427.
[9]
Design,”
Dependability, D. K. Pradhan, Prentice Hall, 1996.
[10] Kanawati N. A. et al., “Dependability Evolution using Hybrid
Fault/Error
Injection,” IEEE Int. Computer Performance and
Dependability Symp. (IPDS'95), 1995, pp.224-233.
[11] Kanawati G. A. et al., “FERRARI: A Tool for the Validation
of System Dependability Properties,” in Proc. 22nd Int. Symp. on
Fault-Tolerant Computing (FTCS-22),1992, pp.336-344.
[12] Martinez R.J. et al., “Experimental validation of high-speed
fault-tolerant systems using physical fault injection”, Dependable
Computing for Critical Applications 7, 1999, pp. 249-265.
[13] Folkesson P. et al, “Comparison of Simulation Based and
Scan Chain Implemented Fault Injection,” Proc. 28th Int. Symp. on
Fault-Tolerant Computing (FTCS-28), 1998, pp.284-293.
[14] Merenda A., E. Merenda, “Recovery/Serviceability System
Test Improvements for the IBM ES/9000 520 Based Models,”
the 22nd International Symposium on Fault-Tolerant
Proc. of
Computing, 1992. pp 463-467.
[15] Karlsson J. et al., “Application of Three Physical Fault
Injection Techniques to Experimental Assessment of the MARS
Architecture,” in Proc. 5th IFIP Int. Working Conf. Dependable
Computing for Critical Applications (DCCA-5), 1997, pp.267-287
[16] Miremadi G., J. Torin, “Evaluating Processor-Behavior and
Three Error-Detection Mechanisms Using Physical Fault-
Injection,” IEEE Trans. on Reliability, vol.44, no.3, 1995, pp.441-
454.
[17] Harboe-Sorenson R. et al., “Observation and Prediction of
SEU in Hitachi SRAMs in Low Altitude Polar Orbits,” IEEE
Trans. Nuclear Science, vol.40, no.6, 1993, pp.1498-1504.
[18] Samson J.R. et al., “A Technique for Automated Validation of
Fault Tolerant Designs Using Laser Fault Injection (LFI),” Proc.
28th Int. Symp. on Fault-Tolerant Computing (FTCS-28), 1998,
pp.162-167.
[19] Floering B., “An Adaptive Architecture for Network Based
Fault Injection and Measurement,” M.S. Thesis, University of
Illinois at Urbana-Champaign, 2000.
[20] Kalbarczyk Z. et al., “Chameleon: A Software Infrastructure
for Adaptive Fault Tolerance,”
and
Distributed Systems, vol.10, no.6, 1999, pp.560-579.
IEEE Trans. Parallel
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:18:26 UTC from IEEE Xplore.  Restrictions apply.