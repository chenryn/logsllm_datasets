the same source code, the resulting binary output cannot be
compared easily if the binaries were compiled for different
architectures. To illustrate this, Figure 2 shows a small code
snippet that has been compiled for three architectures. It can
be seen that not only the calling conventions and memory
711711
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:05:33 UTC from IEEE Xplore.  Restrictions apply. 
Binary Code
ldrb r3, [r1]
add  r1, r1, 1
cmp  r3, #0
strb r3, [r2]
bne  loc_A
lbu   v0, 0(a1)
addiu a1, 1
bnez  v0, loc_A
sb    v0, 0(v)
lodsb
stosb
test al, al
jnz short loc_A
M
R
A
S
P
I
M
6
8
x
Intermediate Representation
(=R3 (concat #x00 ((extract 7 0) (IND r1))))
(=R1 (bvadd R1 1)
...
(Terminator jump +2BB)
n
o
i
t
a
c
i
f
i
n
U
(=v0 (concat #x00 ((extract 7 0) (IND a1))))
(=a1 (bvadd a1 1)
...
(Terminator jump +3BB)
g
n
i
l
p
m
a
S
(=AL ((extract 7 0) (IND ESI)))
(=ESI (bvadd ESI DF))
...
(Terminator jump +2BB)
:
h
t
g
n
e
l
t
u
p
n
i
r
e
p
s
t
u
p
n
i
e
t
e
r
c
n
o
C
3
9
1
x
0
;
9
2
x
0
;
3
1
x
0
;
7
:
s
t
u
p
n
i
1
)
1
,
7
(
;
)
1
,
5
(
;
)
1
,
3
(
;
)
1
-
,
0
(
:
s
t
u
p
n
i
2
I/O Pairs
(7,7);
(0x13,0x13);
(0x29,0x29);
(0x193,0x93)
(7,8);
(0x13,0x14);
(0x29,0x2a);
(0x193,0x194)
(0x13,0x13);
(0x29,0x29);
(0x193,0x93)
(0x13,0x14);
(0x29,0x2a);
(0x193,0x194)
((0,-1),-1);
((3,1),4);
((5,1),6);
((7,1),8)
(0x13,0x13);
(0x29,0x29);
(0x193,0x93)
(7,7);
(7,7);
(7,8);
Semantic Hashes
0x1afc...5984 
0x2d1e...d2aa
0x2f1c...3fbe
0x4120...c079
0x1afc...5984 
0x2d1e...d2aa
0x2f1c...3fbe
0x4120...c079
0x1afc...5984 
0x12ec...f711
0x2abe...91fc
0x2d1e...d2aa
g
n
i
h
s
a
H
c
i
t
n
a
m
e
S
Fig. 1: Transformation phase: Three binaries (ARM, MIPS, x86) are ﬁrst uniﬁed from assembly to the intermediate
representation (S-Expressions), as illustrated for the ﬁrst instruction (ldrb, lbu and lodsb). Then, using the same random
concrete inputs among all formulas, we determine the input/output behavior of the expressions, resulting in a set of I/O pairs.
In the last step, we create semantic hashes over these I/O pairs in order to efﬁciently compare basic blocks.
l o c a l t i m e ( s t r u c t
s t a t i c void g e t
t i m e t
t i m e r ;
t i m e (& t i m e r ) ;
l o c a l t i m e r (& t i m e r , ptm ) ; }
tm ∗ptm ) {
[ esp +28h+ t i m e r ]
;
tm ∗
e s i
e s i , ptm
ebx
esp , 20h
ebx ,
ebx
t i m e
x86 assembly
t i m e r = dword ptr −0Ch
ptm = eax
push
mov
push
sub
l e a
push
c a l l
ptm = e s i
pop
pop
push
push
c a l l
add
pop
pop
r e t n
ecx
eax
ptm
ebx
l o c a l t i m e r
esp , 24h
ebx
ptm
tm ∗
;
ARM assembly
t i m e r = −0x14
ptm = R0
STMFD
SUB
ADD
MOV
MOV
ptm = R5
BL
MOV
MOV
BL
ADD
LDMFD
BX
tm ∗
;
SP ! , {R4,R5,LR}
SP, SP, #0xC
R4, SP, # 0x18+ t i m e r
R5, ptm
ptm, R4
tm ∗
;
t i m e
R0, R4
R1, ptm
l o c a l t i m e r
SP, SP, #0xC
SP ! , {R4,ptm,LR}
LR
MIPS assembly
$gp , 0xFFF9C
$gp , $ t 9
$sp , −0x30
$ra , 0 x30+ va r 8 ( $sp )
$s1 , 0 x30+var C ( $sp )
$s0 , 0 x30+ var 10 ( $sp )
$gp , 0 x30+ var 20 ( $sp )
$t9 ,
$s0 , $sp , 0 x30+ var 18
$s1 , $a0
$ t 9 ;
$a0 , $s0
$gp , 0 x30+ var 20 ( $sp )
$a0 , $s0
$t9 ,
l o c a l t i m e r
t i m e
t i m e
l o c a l t i m e r
$ t 9 ;
$a1 , $s1
$gp , 0 x30+ var 20 ( $sp )
$ra , 0 x30+ va r 8 ( $sp )
$s1 , 0 x30+var C ( $sp )
$s0 , 0 x30+ var 10 ( $sp )
$ r a
$sp , 0 x30
l i
addu
addiu
sw
sw
sw
sw
l a
addiu
move
j a l r
move
lw
move
l a
nop
j a l r
move
lw
lw
lw
lw
j r
addiu
Fig. 2: BusyBox v1.21.1: C source of get_localtime and the corresponding IDA disassemblies.
accesses (e.g., load/store), but also the general assembly com-
plexity/length, deviate between the architectures. Thus, at ﬁrst,