When the same source code is compiled for different architectures, the resulting binary outputs can vary significantly, making direct comparison difficult. To illustrate this point, Figure 2 presents a small code snippet that has been compiled for three distinct architectures: ARM, MIPS, and x86. It is evident that not only do calling conventions and memory access patterns (such as load and store operations) differ, but also the overall complexity and length of the assembly code vary across these architectures.

To address this challenge, the transformation phase, depicted in Figure 1, involves several steps. Initially, the binaries are unified from their respective assembly languages into an intermediate representation (S-Expressions). This process is demonstrated using the first instruction from each architecture (e.g., `ldrb` for ARM, `lbu` for MIPS, and `lodsb` for x86).

Next, the same set of random concrete inputs is applied to all the S-Expressions to determine their input/output (I/O) behavior, resulting in a set of I/O pairs. Finally, semantic hashes are generated from these I/O pairs, allowing for an efficient comparison of basic blocks.

Figure 2 provides a more detailed example, showing the C source code for the `get_localtime` function and its corresponding disassemblies in x86, ARM, and MIPS. The differences in the assembly code further highlight the variations in calling conventions, memory access, and overall complexity between the architectures.

In summary, the compilation of the same source code for different architectures results in binaries that are not easily comparable due to differences in calling conventions, memory access, and assembly complexity. The use of intermediate representations and semantic hashing helps to mitigate these challenges by providing a standardized and comparable format.