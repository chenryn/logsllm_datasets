Since they are ad hoc, there is a greater likelihood of missing
possible attack sources or identifying trusted sources as false
adversaries. Since they are one-dimensional (i.e., either fo-
cusing on trust or not), there is no basis to determine whether
adversaries are missing or misclassiﬁed.
We propose to develop a method for computing adversaries
that considers both the best-case and worst-case trust to derive
per-subject adversary sets. For the worst case, we leverage
the conservative integrity wall approach of Vijayakumar et
al. [50]. The integrity wall approach uses the insight that only
the subjects that can trivially compromise a subject’s program
must be trusted, thus computing a minimal trusted computing
base (TCB) (i.e., fewest subjects trusted) of subjects for each
program. For the best case, we use the process privilege lev-
els deﬁned by Google [17], which groups subjects in classes
by whether they should be mutually trustworthy. By examin-
ing trust from two directions, we can perform validation on
whether the combination is consistent. While this approach
enables just one type of limited validation, we are not aware
of any prior work validating adversary sets.
The integrity wall method computes per-subject TCBs by
detecting whether either one of two requirements are met:
(1) the subject must trust any other subjects that are authorized
to modify ﬁles that the subject may execute (i.e., its executable
and library ﬁles) and (2) the subject must trust any other
subjects that are authorized to modify kernel resources. We
compute worst-case per-subject TCBs from MAC TE policies.
On the other hand, Android speciﬁes "privilege levels" [17]
that describe which subjects should mutually trust one another,
implying a best-case TCB. Google deﬁnes six privilege levels
in an Android system [17], which we group into ﬁve levels
for evaluation in Section 7: (T5) root processes; (T4) system
processes; (T3) service processes; (T2) trusted application
processes; (T1) untrusted application processes and isolated
process. Isolated apps and untrusted apps are separated into
distinct privilege levels by Google, but in this paper, we do
not consider attacks on untrusted apps by the lower privileged
isolated apps. Table 1 lists these privilege levels based on
their UID and MAC labels.
Using Google’s privilege levels, we assume a subject trusts
all of the subjects at its level or higher. For example, untrusted
apps trust other untrusted apps and any subjects at higher
privilege levels, such as the Android system services (e.g.,
system server). Trusting subjects at higher privilege levels
is accepted because such subjects provide functionality that
the subjects at lower privilege levels depend upon. However,
assuming untrusted apps may be mutually trusting may be
harder to accept, but we are not looking for attacks between
untrusted apps in this paper. Resolving how to identify ad-
versaries among untrusted apps, such as determining whether
mutual trust for all is appropriate, is future work.
To produce an accurate adversary set, we validate consis-
tency between the best-case and worst-case trust sets to derive
an adversary set that is consistent with both trust sets. Specif-
ically, PolyScope validates whether the worst-case trust set
for each subject is a subset of that subject’s best-case trust set.
If so, then there does not exist an adversary of any subject rel-
ative to its best-case trust set (i.e., fewest adversaries) that is
not also an adversary relative to that subject’s worst-case trust
set (i.e., maximal adversaries). An inconsistency implies that
the Android privilege levels are missing a fundamental trust
requirement to prevent trivially compromising the subject.
5.3 Compute Permission Expansion
A key difﬁculty for OEMs is predicting which resources may
be accessible to adversaries and victims to derive attack op-
erations accurately. A problem is that while MAC policies
are essentially ﬁxed (i.e., between software updates), DAC
permissions may be modiﬁed by adversaries to increase the
attack operations that they could execute. We identify two
ways that adversaries may modify permission assignments
on Android systems: (1) adversaries may obtain Android
permissions that augment their own DAC permissions and
(2) adversaries may delegate DAC permissions for objects
that they own to potential victims. For some Android per-
missions, adversaries gain new DAC permissions to access
additional resources that may enable attacks. By delegating
DAC permissions to objects they own, adversaries may lure
potential victims to resources that adversaries control.
Adversary Permission Expansion: In Android systems,
some Android permissions are implemented using DAC
groups. As described above, a process is associated with a
single UID and GID, but also an arbitrarily large set of supple-
mentary groups that enable further "group" permissions. Thus,
USENIX Association
30th USENIX Security Symposium    2585
Table 1: Google’s Process Privilege Levels [17]
Process Level1
Root Process (T5)
System Process (T4)
Service Process (T3)
Trusted Application Process (T2)
Untrusted Application Process (T1)
Isolated Process (T0)
Level Membership Requirements
Process running with UID root (e.g., MAC labels kernel and init)
Process running with UID system (e.g., MAC label system server)
AOSP core service providers (e.g., MAC labels bluetooth and mediaserver)
AOSP default and vendor apps (e.g., MAC labels platform_app and priv_app)
Third-party applications (e.g., MAC label untrusted_app)
Processes that are expected to receive adversarial inputs (e.g., MAC label webview)
1 Listing types of processes based on their privilege level, from high to low with root processes being most privileged (T5) and isolated processes being the
least privileged (T0). We group T0 and T1 together calling the resultant level T1 in the evaluation in Section 7.
when a user grants an Android permission associated with one
or more DAC groups to an app, there is a direct expansion of
that app’s permissions in terms of its DAC permissions. Since
the MAC policies are generally lenient in Android systems,
these new DAC permissions may grant privileges that enable
attacks. For PolyScope, we assume that subjects can obtain
all of their "normal" Android permissions and are granted
all of their "dangerous" permissions by users for analysis, as
described in the previous section. One of the vulnerability
case studies we highlight in Section 7.6 exploits adversary
permission expansion.
Victim Permission Expansion: Researchers have long
known that allowing adversaries to administer DAC permis-
sions for their own objects can present difﬁculties in predict-
ing possible permission assignments. Researchers proved that
the safety problem of predicting whether a particular unsafe
permission will ever be granted to a particular subject for
a typical DAC protection system, i.e., an access matrix for
subjects and objects where objects and permissions may be
added in a single command, is undecidable in the general
case [21]. As a result, researchers explored alternative DAC
models for which the safety problem could be solved, such as
the take-grant model [26], the typed access matrix [38], and
policy constraints [45].
Using the ability to manage DAC permissions to objects
they own, adversaries can grant permissions to their resources
to victims, expanding the set of resources that victims may be
lured to use. In many cases, victims have MAC permissions
that grant them access to adversary directories, but vendors
use DAC permissions to block access. However, since ad-
versaries own these directories, they can simply grant the
removed permissions to potential victims themselves.
5.4 Compute Integrity Violations
In this section, we show how to compute integrity violations
for ﬁle-IVs, binding-IVs, and pathname-IVs deﬁned in Sec-
tion 4. Recall from Section 2.2 that integrity violations are
a tuple of resource, adversary, and victim, where the adver-
sary is authorized to modify the resource and the victim is
authorized to use (e.g., read, write, or execute) the resource.
Computing File Integrity Violations: A ﬁle vulnerability
may be possible if a subject uses (read, write, or execute) a
ﬁle that can be modiﬁed by an adversary. In practice, many
subjects read ﬁles their adversaries may write (read-IVs)
with adequate defenses, but risks are greater if the subject
executes (exec-IVs) or also modiﬁes such ﬁles (write-IVs).
For exec-IVs, executing input from an adversary enables an
adversary to control a victim’s executable code. For write-IVs,
if a subject writes to a ﬁle its adversaries also may write, then
adversaries may be able to undo or replace valid content.
{read|write|exec}(file, victim) && // victim can access file,
adv-expand(file, adversary) &&
write(file, adversary)
// but adv-expanded perms
// enables to modify file
-->
{read|write|exec}-IV(file, victim, adversary)
This rule determines whether the victim is authorized by
the combination of access control policies for reading, writing,
or executing ﬁles, using the {read|write|exec} predicate.
The rule accounts for the adversary’s expansion of their own
permissions, as indicated by the predicate adv-expand. If
the adversary also has write permission to the ﬁle (write
predicate), then the associated integrity violation is created.
Computing Binding Integrity Violations: A binding vul-
nerability is possible if a subject may use a binding in resolv-
ing a ﬁle name that adversaries can modify.
use(binding, victim) &&
adv-expand(file, adversary) &&
write(binding, adversary)
// victim can use binding,
// but adv-expanded perms
// enable to modify binding
-->
binding-IV(binding, victim, adversary)
This rule parallels the rule for ﬁle-IVs, except that this rule
applies to a victim having the permission to use a binding in
name resolution (use predicate).
Computing Pathname Integrity Violations: Pathname in-
tegrity violations are binding integrity violations that are pos-
sible when a subject uses input from an adversary to build
a ﬁle pathnames used in name resolution. First, adversaries
must be authorized to communicate with the victim. Second,
through their input, adversaries can lure victims to any bind-
ings they choose, enabling them to expand the IVs available
for exploitation by victim permission expansion.
// may send IPCs to victim
write(ipc, adv, vic) &&
vic-expand(binding, adv, vic) && // and expand victim perms
binding-IV(binding, vic, adv)
// to lure victim
-->
pathname-IV(binding, vic, adv)
Adversaries must be granted write privilege to communi-
cate to the victim, as deﬁned in the write predicate. Android
services may use Binder IPCs, and we further limit write
2586    30th USENIX Security Symposium
USENIX Association
to use IPCs that communicate URLs for Android services.
The adversary can use victim expansion to increase the set
of bindings the victim is authorized to use by vic-expand.
If that binding meets the requirements of a binding-IV (see
above), then a pathname-IV is also possible for this victim.
5.5 Compute Attack Operations
We deﬁne how PolyScope computes attack operations from
the integrity violations computed in the last section and the
relevant system conﬁgurations. We identify four types of
attack operations that an adversary could use to exploit the
three types of integrity violations: (1) ﬁle modiﬁcation for ﬁle
IVs; (2) ﬁle squatting for binding-IVs; (3) link traversal for
binding-IVs; and (4) luring traversal for pathname-IVs.
File Modiﬁcation Attacks: For read/write/exec IVs, the at-
tack operation is to modify the objects involved in each IV.
However, Android uses some read-only ﬁlesystems, so not
all ﬁles to which adversaries have write privilege are really
modiﬁable. Thus, the rule for ﬁle modiﬁcation operations ad-
ditionally checks whether the ﬁle is in a writable ﬁlesystem.
{read|write|exec}-IV(file, victim, adversary) &&
fs-writable(file)
// file's filesystem is writable
-->
file-mod(file, victim, adversary)
File Squatting Attack: In a ﬁle squatting attack, adversaries
plant ﬁles that they expect that the victim will access. The
adversary grants access to the victim to allow the victim to use
the adversary-controlled ﬁle. This attack operation gives the
adversary control of the content of a ﬁle that the victim will
use. To perform a ﬁle squatting attack operation, the adversary
must really be able to write to the directory to plant the ﬁle.
Thus, the rule for ﬁle squatting operations is essentially the
same as for ﬁle modiﬁcation, but applies to binding-IVs.
binding-IV(binding, victim, adversary) &&
fs-writable(binding)
// binding's filesystem is writable
-->
file-squat(binding, victim, adversary)
In this rule, we assume that the adversary predicts the ﬁle-
names used by the victim. In the future, we will explore
extending the rule to account for that capability.
Link Traversal: A link traversal attack is implemented by
planting a symbolic link at a binding modiﬁable by the adver-
sary, as described in Section 2.1. However, Android also uses
some ﬁlesystem conﬁgurations that prohibit symbolic links,
so not all bindings to which adversaries have write privilege
and are in writable ﬁlesystems allow the creation of the sym-
bolic links necessary to perform link traversals. Thus, the rule
for link traversal operations extends the rule for ﬁle squatting
to account for this additional requirement.
binding-IV(binding, victim, adversary) &&
fs-writable(binding)
symlink(binding) &&
// binding's filesystem is writable
// and allows symlinks
-->
link-traversal(binding, victim, adversary)
Luring Traversal: An adversary may lure a victim to a bind-
ing controlled by the adversary to launch an attack opera-
tion. However, the Android FileProvider class can prevent
such attacks. Speciﬁcally, the FileProvider class requires that
clients open ﬁles themselves and provide the FileProvider
with the resultant ﬁle descriptor. Since the clients open the
ﬁle, they perform any name resolution, so the potential vic-
tim is no longer prone to pathname vulnerabilities. Thus, the
rule for luring traversal operations extends the rule for link
traversal for pathname-IVs by requiring the absence of any
FileProvider class usage. OEMs still have many services and
privileged apps that do not employ the FileProvider class,
leaving opportunities for pathname-IVs to be attacked.
pathname-IV(binding, victim, adversary) &&
fs-writable(binding) &&
symlink(binding) &&
no-file-provider(victim)
// binding's filesystem is writable
// and allows symlinks
// victim does not use FileProvider
-->
luring-traversal(binding, file, victim, adversary)
Implementation
While it is possible that the victim has implemented an ex-
tra defense in Android middleware (e.g., Customized Android
Permission) to prevent IPCs, we do not yet account for these
defenses. Including these defenses is future work.
6
The PolyScope tool is implemented fully in Python in about
1500 SLOC and is compatible with Android version 5.0 and
above. After Data Collection gathers access control policies,
PolyScope implements the logical ﬂow shown in Figure 2 in
a slightly different manner described below. First, PolyScope
computes integrity violations in steps one to three in Figure 2,
but only for the SEAndroid TE policy, which we call TE IV
Computation. Next, PolyScope computes whether the TE in-
tegrity violations are authorized by the remaining Android
access control policies by re-running steps two and three in
Figure 2, but only for resources associated with the TE IVs,
which we call TE IV Validation. This separation enables us to
parallelize the validation step, which has a signiﬁcant perfor-
mance impact, see Section 7.7. Finally, PolyScope leverages
the validated IVs to Compute Attack Operations. Below, we
discuss these major phases of the implementation, and how
we use the results in Testing for Vulnerabilities.
Data Collection: We implemented multiple data collection
scripts that collect access control data for the subjects and
objects from an Android phone. The methods are relatively
straightforward for accessible ﬁles and processes, detailed in
Appendix A.1. However, we are not authorized to access all
ﬁles, particularly those owned by root, so we run these scripts
on rooted phones. Recent work by Hernandez et al. [22] is able
to extract MAC policy and part of DAC conﬁguration from
Android ﬁrmware images without rooting devices. However,