C 语言特有的调用方法称为 C 调用，默认编写的程序不使用 _stdcall，因为 C 语言所对应的函数传入参数是可变的，只有函数调用方才能知道到底有多少个参数，在这种情况下，栈的清理作业无法进行，不过当函数的参数和数量固定时，指定 _stdcall 是没有任何问题的。
C语言中，调用完函数后，需要人为执行栈清理指令，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去的操作叫做栈清理处理。例如
```c
//函数调用方
void main(){
    int a;
    a=Func(123,456);
}
//被调用方
int Func(int a,int b){
    ...
}
```
代码中，从 main 主函数调用到 Func() 方法，按照默认的设定，栈的清理处理会附加在 main 主函数这一方，在同一个程序中，有可能会多次调用，导致 Func() 进行多次清理，这会造成内存的浪费。
汇编之后的代码如下
```c
push 1C8h                       // 将参数 456(=1C8h)存入栈中
push 7Bh                        // 将参数 123(=7Bh)存入栈中
call @LTD+15 (Func)(00401014)   // 调用 Func 函数
add esp,8                       // 运行栈清理
```
C 语言通过栈来传递函数的参数，使用 push 是往栈中存入数据的指令，pop 是从栈中取出数据的指令。32 位 CPU 中，1 次 push 指令可以存储 4 个字节 (32 位) 的数据。上述代码进行了两次 push，存储了 8 个字节的数据，通过 call 指令调用函数，调用完毕后，栈中存储的数据就不需要了，通过 add esp,8 这个指令，使存储着栈数据的 esp 寄存器前进 8 位(设定为指向高 8 位的地址)，进行数据清理，由于栈在各种情况下都需要使用，因此使用完毕后需要恢复到原始状态，上述操作就是指向栈的清理工作，在 C 语言中，函数的返回值，是通过寄存器而非栈来返回的。
栈执行清理工作，在调用方法处执行清理工作和在反复调用方法处执行清理工作不同，使用 _stdcall 标准调用的方法称为反复调用方法, 在这种情况下执行栈清理开销比较小。
![](../../../assets/img/Develop/计算机基础/内存/25.png)
不同方式的调用，清理方式也不同。
---
## 地址空间(Address Space)
CPU 处理器要在执行指令并访问存储与内中的数据，它必须为要访问的数制定一个唯一性地址。地址空间指的就是一组大量的有效地址，可用于去识别存储与有限的内存分配空间中的数据。一个正在运行的程序可以访问的单个连续的地址空间一般称为线性地址空间。基于内存模型及采用的分页模式，我们有时将其称为线性地址，有时称为虚拟地址。通常我们使用物理地址空间来特指处理器请求访问物理内存的地址。这些地址是通过将线性地址转化为物理地址来获得。
---
## 内存分页(Paging)
从抽象意义上来讲页是一个具有固定尺寸的窗口，从逻辑意义上来讲页是具有固定大小的一组连续线性地址的集合。
分页可以将线性地址空间进行虚拟化。它创建了一个执行环境，大量线性地址空间通过用适量的物理内存和磁盘存储进行模拟。每一个 32 位的线性地址空间被分为固定长度的片段，称为页 (Page)，页可以任何顺序将线性地址空间映射为物理内存。当程序尝试访问线性地址时，这样的映射使用了驻留内存的页目录(Page Directory) 及页表 (Page Table) 来实现。
一个页的大小可以指定为 4KB(212=4KB) 的任意倍数，这根据不同的体系结构或操作系统的设置而定，而 x86 架构下的 Windows/Linux 均采用 4KB 大小的分页方式，这就说明 32 位线性地址中必定存在一个 12 位的指示页内偏移量的域。
![](../../../assets/img/Develop/计算机基础/内存/1.png)
**物理地址扩展**
Intel 公司的 32 位架构的内存分页机制支持物理地址扩展(Physical Address Extension ，简称 PAE), 该扩展支持允许处理器支持超过 4GB 的物理地址空间。
程序虽然仍只能拥有最高 4GB 的线性地址空间，但是内存管理单元可以将那些地址映射为扩展后的 64GB 物理地址空间。对于支持 PAE 功能的系统，线性地址分为四个索引：
- 页目录指针表 (Page directory pointer table, 简称 PDPT)
- 页目录 (Page directory，简称 PD)
- 页表 (Page table，简称 PT)
- 页偏移 (Page offset)
---
## 物理内存中数据的价值
计算机终端及移动终端均使用了 RAM 易失性存储，主要用于数据交换、临时存储等用途。操作系统及各种应用软件均经常需要与物理内存进行数据交互，此外由于内存空间有限，因此计算机系统还可能将内存中的数据缓存到磁盘中，如 pagefile.sys(页交换文件)及 hiberfil.sys(休眠文件)。
内存中有大量的各类数据，结构化及非结构化数据。通过对物理内存镜像可以提取出有价值的数据。常见有价值的数据，包含以下内容：
- 进程列表 (包括恶意程序进程、Rootkit 隐藏进程等)
- 动态链接库 (当前系统或程序加载的动态链接库)
- 打开文件列表 (当前系统打开的文件列表)
- 网络连接 (当前活动的网络连接)
- $MFT 记录 (常驻文件均可以直接提取恢复)
- 注册表 (部分注册表信息，包括系统注册表和用户注册表文件)
- 加密密钥或密码 (如 Windows 账户密码 Hash、BitLocker/SafeBoot/PGP/ TrueCrypt/VeraCrypt 等全盘加密或加密容器的恢复密钥等)
- 聊天记录 (如 QQ 聊天记录片段)
- 互联网访问 (上网记录 URL 地址、网页缓存及 InPrivate 隐私模式访问数据等)
- 电子邮件 (如网页邮件缓存页面)
- 图片及文档等 (尚未保存到磁盘中的图片、文档等文件)
**页交换文件(Pagefile.sys)**
除了使用物理内存 RAM 用于数据交换，Windows 为了能正常工作还使用了各种各样的文件。从 Windows 95 开始，Windows 开始引入了页交换文件 (Pagefile.sys) 来协助内存数据的交换。 Pagefile.sys 是磁盘中的一个文件，它用于将操作系统中的活动数据临时性地进行存储，在必要的情况下，Windows 可将 Pagefile.sys 文件的中数据移动到物理内存中或从内存中将数据移到该文件中，实现数据的临时交换或缓存。从 Pagefile.sys 中获得的数据通常是当前活动的相关信息，也通常与调查相关性较高。
Windows 操作系统最多支持 16 个页交换文件。启用物理地址扩展功能 (PAE) 的 Windows 32 位和 64 位系统的最大页交换文件大小为 16TB。64 位的安腾架构(Itanium)的系统的页交换文件可以支持高达 32TB。 页交换文件大小的默认值为计算机物理内存大小的 1.5 至 3 倍。
Pagefile.sys 用于存储从物理内存中转移过来的数据。 要获得一个正在运行的系统的活动全貌或快照，我们通常除了分析物理内存，还需要分析 pagefile.sys。 部分工具支持同时将物理内存和 pagefile.sys 进行检查分析。通常 pagefile.sys 文件放置于操作系统所在分区，当然用户也完全可能修改高级设置或注册表调整 pagefile.sys 的存储位置。
从 Windows 7 操作系统版本开始，Windows 系统开始支持页交换文件 pagefile.sys 的加密。
启用页交换文件加密
![](../../../assets/img/Develop/计算机基础/内存/2.png)
查询页交换文件加密状态
![](../../../assets/img/Develop/计算机基础/内存/3.png)
**休眠文件(HiberFil.sys)**
Hiberfil.sys 是当系统休眠时，Windows 将物理内存的数据写入到磁盘生成的一个文件。当系统进入休眠状态后，网络连接将会中断。 当系统重新加电时，hiberfil.sys 文件中的数据重新回写到物理内存中，这也使得从休眠状态恢复到原始状态变得相当快。
休眠文件包含了标准的头部 (PO_MEMORY_IMAGE)，包含了内核上下文与寄存器的相关信息及压缩的数据块。该文件采用了 Xpress 算法(带霍夫曼 Huffman 及 LZ 编码)。 文件头部通常包含了“hibr”、“HIBR”、“wake” 或“WAKE”等特征。 操作系统从休眠状态恢复后，头部就被清零了。清零后的文件头可能导致一些取证软件无法分析该文件。
通过分析 hiberfil.sys 文件的修改时间戳信息，我们可以了解到该系统最后一次休眠的时间。系统中的休眠文件 hiberfil.sys 只有一个。当系统重新休眠时，当前物理内存中的内容将会覆盖原有文件的数据。 要对 hiberfil.sys 进行分析，要求取证工具可以将休眠文件中的数据进行解压为原生数据并进行数据解析。Mattieu Suiche 的 Windows Memory Toolkit 工具 hibr2bin.exe 支持将休眠文件转为原生转储文件。
当取证人员在现场要制作 Windows 操作系统的物理内存镜像时，可能由于内存镜像工具不兼容操作系统导致无法获取物理内存数据。当无法成功制作物理内存镜像时，还可以让系统进入休眠模式，从而用变通的方式获得物理内存中的数据。
要进入休眠模式，首先要让系统启用休眠模式支持。Windows 8 及以上版本的操作系统，默认启用休眠模式支持。取证人员也可以管理员权限进入命令行模式，并输入 powercfg.exe /hibernate ON 来启用休眠模式支持。要让操作系统进入休眠模式，需要输入 shutdown /h .
Vista 以上操作系统在原有支持休眠模式 (Hibernate Mode) 的基础上增加了睡眠模式(Sleep Mode)。睡眠模式状态下，操作系统使用极少的电量保证内存可以继续工作，一旦系统电量不足，系统将保存所有内存数据到磁盘并关闭计算机。而休眠模式状态下，系统关闭，将内存中的数据写入休眠文件 hiberfil.sys 中。
在默认的 Windows 开始菜单中的 “电源” 找不到 “休眠”，可以通过按 Win+X 键，选择“控制面板”，找到“硬件和声音”->“电源选项”->“选择电源按钮的功能”，选择“更改当前不可用的设置”, 在“关机设置” 下将 “休眠” 选项勾选。后续在开始菜单选择 “电源” 即可直接看到 “休眠” 选项。
![](../../../assets/img/Develop/计算机基础/内存/4.png)
---
## Windows 内存管理
- 内容见 [Windows内存管理笔记](../../Integrated/Windows/笔记/内存管理.md)