is targetted at embedded and real-time operating system
environments. It appears to have rather few known vulner-
abilities, with only 5 being reported in the CVE database12
since 2005. The CyaSSL code13 does not perform proper
padding checks, but instead just examines the last byte of
plaintext and uses this to determine how many bytes to
remove. This approach renders the code vulnerable to the
old attack from [17] which recovers one byte of plaintext
per block. This was the only implementation that we found
that still contains this basic ﬂaw.
5) Java: We have examined the BouncyCastle14 and
OpenJDK15 Java implementations of TLS.
The BouncyCastle code does careful sanity checking of
the padding length (as indicated by the last byte of plaintext)
but treats the padding as having length 1 if the padding
format, when checked, is found to be incorrect (a variable
paddingsize is set to 0, but then the plaintext size is
reduced by an amount paddingsize+minLength where
minLength is set to be 1 larger than the MAC tag size).
This deviates slightly from the recommendation of the RFCs
to treat the padding as having length zero, but still allows
our attacks in Sections III and IV to be applied (for Case 3
of the main plaintext recovery attack in Section IV, MAC
veriﬁcation ends up being performed on a 56-byte message,
but this will still involve 5 evaluations of the compression
function for SHA-1).
The OpenJDK code appears follow the recommendation
of the RFCs in treating the padding as having zero length if
the padding format, when checked, is found to be incorrect.
This is because this case is trapped by exception handling,
during which the variable deﬁning the plaintext length is not
changed. This potentially renders it vulnerable to our attacks
in Sections III and IV.
VII. COUNTERMEASURES
A. Add Random Time Delays
A natural reaction to timing-based attacks is to add
random time delays to the decryption process to frustrate
statistical analysis. In fact, this countermeasure is surpris-
ingly ineffective, as we demonstrate in the full version [2].
11yassl.com/yaSSL/Home.html
12www.cvedetails.com/vulnerability-list/vendor id-3485/Yassl.html
13We worked with version 2.3.0 available at yassl.com/yaSSL/Source/
output/src/internal.c.html.
14www.bouncycastle.org/viewcvs/viewcvs.cgi/java/crypto/src/org/
bouncycastle/crypto/tls/TlsBlockCipher.java?view=markup
15hg.openjdk.java.net/jdk7/l10n/jdk/ﬁle/3598d6eb087c/src/share/classes/
sun/security/ssl/SSLSocketImpl.java and hg.openjdk.java.net/jdk7/2d/jdk/
ﬁle/85fe3cd9d6f9/src/share/classes/sun/security/ssl/CipherBox.java
B. Use RC4
The simplest countermeasure for TLS is to switch to using
the RC4 stream cipher in place of CBC-mode encryption.
However, this is not an option for DTLS. When a stream
cipher is used in TLS, no padding is required. Consequently
none of the attacks in this paper will work. RC4 is widely
supported in implementations of TLS, the same countermea-
sure is effective against the BEAST attack, and has been
fairly widely adopted in response to BEAST. The use of a
stream cipher in a MEE construction is well-supported by
theory [12]. But the ﬁrst bytes of keystream output by the
RC4 generator have certain small biases, and TLS does not
discard these before starting encryption. For this reason, we
do not recommend using RC4.
C. Use Authenticated Encryption
Another possibility is to switch from MEE-TLS-CBC to
using a dedicated authenticated encryption algorithm, such
as AES-GCM or AES-CCM which were standardised for use
in TLS in RFCs 5288 [24] and 6655 [15], respectively. In
theory, this should obviate all attacks based on weaknesses
in the MEE construction. However, we cannot rule out
implementation errors, and we are not aware of any detailed
analysis of implementations of these algorithms in (D)TLS
for potential side-channels. A further issue is that authenti-
cated encryption was only added in TLS 1.2, and this version
of TLS is not yet widely supported in implementations.
D. Careful implementation of MEE-TLS-CBC decryption
Our ﬁnal option is to implement MEE-TLS-CBC decryp-
tion more carefully.
The key requirement
is to ensure uniform processing
time for all MEE-TLS-CBC ciphertexts of a given size.
That is, the total processing time should depend only on
the ciphertext size, and not on any characteristics of the
underlying plaintext (including padding). The basic principle
to be followed in achieving this is quite simple: since
the major timing differences arise from MAC processing,
implementations should make sure the same amount of MAC
processing is carried out no matter what the underlying
plaintext
indicates the message length to be. However,
this simple principle is complicated by the need to also
perform careful sanity checking on the underlying plaintext
whilst avoiding the introduction of yet more timing side-
channels, and to make sure appropriate amounts of MAC
processing are performed even when these checks fail. A
further complication arises because the number of bytes to
be examined in the padding check depends on the last byte of
the last plaintext block, and so, even if the MAC processing
is made uniform, the running time of the padding check may
still leak a small amount of information about the plaintext.
With these remarks in mind, we now proceed to give a
detailed prescription of how to achieve constant-time pro-
cessing of MEE-TLS-CBC ciphertexts, incorporating suit-
538
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:50 UTC from IEEE Xplore.  Restrictions apply. 
2) Decrypt
able sanity checking. In what follows, we let plen denote
the length (in bytes) of the plaintext P obtained immediately
after CBC-mode decryption of the ciphertext, padlen
denote the last byte of that plaintext interpreted as an integer
between 0 and 255, and t denote the length of the MAC tags
(in bytes). Also, let HDR, SQN denote the (D)TLS record
header and the expected value of the sequence number for
this record. Our recommended procedure is then as follows:
1) First sanity check the ciphertext: check that its length
in bytes is a multiple of the block-size b and is at least
max{b, t + 1} (for chained IVs) or b + max{b, t + 1}
(for explicit IVs). If these conditions are not met, then
return fatal error.
to obtain plaintext P ; now
the ciphertext
plen will be a multiple of b and at least max{b, t+1}.
3) If t + padlen + 1 > plen, then the plaintext is not
long enough to contain the padding (as indicated by
the last byte of plaintext) plus a MAC tag. In this case,
run a loop as if there were 256 bytes of padding, with
a dummy check in each iteration. Then let P (cid:2) denote
the ﬁrst plen − t bytes of P , compute a MAC on
SQN||HDR||P (cid:2) and do a constant-time comparison of
the computed MAC with the last t bytes of P . Return
fatal error.
4) Otherwise (when t + padlen + 1 ≤ plen), check
the last padlen + 1 bytes of P to ensure they are all
equal (to the last byte of P ), ensuring that the loop
does check all the bytes (and does not stop as soon as
the ﬁrst mismatch is detected). If this fails, then run
a loop as if there were 256 − padlen − 1 bytes of
padding, with a dummy check in each iteration, and
then do a MAC check as in the previous step. Return
fatal error.
5) Otherwise (the padding is now correctly formatted)
run a loop as if there were 256−padlen−1 bytes of
padding, doing a dummy check in each iteration. Then
let P (cid:2) denote the ﬁrst plen−padlen−1−t bytes of
P , and let T denote the next t bytes of P (the remain-
der of P is valid padding). Run the MAC computation
on SQN||HDR||P (cid:2) to obtain a MAC tag T (cid:2). Then set
L1 = 13+plen−t, L2 = 13+plen−padlen−1−t,
(cid:5) MAC
and perform an additional (cid:4) L1−55
compression function evaluations (on dummy data).
Finally, do a constant-time comparison of T and T (cid:2).
If these are equal, then return P (cid:2). Otherwise, return
fatal error.
(cid:5) − (cid:4) L2−55
64
64
When implementing the above procedure, it would be
tempting to omit seemingly unnecessary computations that
are performed, for example when t + padlen + 1 > plen.
However, these are needed to prevent other timing side-
channels like those reported in [1] for the GnuTLS imple-
mentation of DTLS. Notice also that the dummy computa-
tions performed in the last step are compression function
539
0.00006
0.00005
0.00004
0.00003
0.00002
0.00001
y
t
i
l
i
b
a
b
o
r
P
0
1.54 (cid:2)106 1.55 (cid:2)106 1.56 (cid:2)106 1.57 (cid:2)106 1.58 (cid:2)106 1.59 (cid:2)106 1.60 (cid:2)106 1.61 (cid:2)106
Hardware Cycles Calculated by Attacker
Figure 9. Distribution of timing values (outliers removed) for distinguish-
ing attack on OpenSSL TLS, using our decryption procedure.
evaluations and not full MAC computations. These give a
MAC computation time that is the same irrespective of how
much padding is removed (and equal to that carried out in
earlier steps).
We have implemented the above procedure by modi-
fying OpenSSL version 1.0.1, the same version used for
our attacks. We then ran our distinguishing attack from
Section III against the modiﬁed code. Each packet in the
attack passes the padding check, but fails MAC veriﬁcation,
causing the server to close the TLS session and send an
encrypted alert message. Figure 9 shows the distribution of
timing values (in hardware cycles) after implementing our
procedure. This ﬁgure should be compared with Figure 2:
visual inspection alone shows that the timing difference is
substantially reduced. In fact, the separation between the
medians of the two distributions is reduced from about
8500 to about 1100 hardware cycles (from around 2.5μs
to 0.32μs). In turn, this small separation means that 128
sessions are needed to achieve a distinguishing success
probability of 0.68, whereas, prior to our modiﬁcations,
just 1 session was enough to give a success probability of
0.756. For the plaintext recovery attack, the adversary will
have access to timing differences roughly one quarter of
this, i.e. roughly 80ns on our hardware. Notice also that
the two distributions are reversed compared to Figure 2, i.e.
processing 0xFF packets now takes longer, on average, than
for 0x00 packets. We believe that this is caused by overhead
introduced by a SHA1_Update function call that occurs
for 0xFF packets but not 0x00 packets.
To achieve further reductions in timing difference would
require a more sophisticated “constant time” programming
approach. The OpenSSL patch in versions 1.0.1d, 1.0.0k
and 0.9.8y addressing the attacks in this paper provides an
example of how to do this. The complexity of the OpenSSL
patch is notable, with around 500 lines of new ‘C’ code
being required. For further discussion and explanation, see
www.imperialviolet.org/2013/02/04/luckythirteen.html.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:50 UTC from IEEE Xplore.  Restrictions apply. 
VIII. DISCUSSION
We have demonstrated a variety of attacks against im-
plementations of (D)TLS. We reiterate that the attacks are
ciphertext-only, and so can be carried out by the standard
MITM attacker, without a chosen-plaintext capability. The
attacks that are possible depend crucially on low-level imple-
mentation details, as well as factors such as the relationship
between the MAC tag size t and the block size b. All
implementations we examined were vulnerable to one or
more attacks. It is an interesting open question as to whether
similar timing attacks could be developed against the TLS
encryption operation using a variant of the CRIME attack.
For TLS, we need a multi-session attack, with, in some
cases, many sessions. This limits the practicality of the
attacks, but note that they be further improved using standard
techniques such as language models and sequential estima-
tion. They can also be enhanced in a BEAST-style attack
to enable efﬁcient recovery of HTTP cookies. The timing
differences we must detect are close to or below the levels
of jitter one typically ﬁnds in real networks. In particular,
our attacker needs to be positioned relatively close (in terms
of network hops) to the machine being attacked. Still, the
attacks should be considered as a realistic threat to TLS,
and we have described a range of suitable countermeasures.
The attacks are much more serious for DTLS, because
of this protocol’s tolerance of errors and because of the
availability of timing ampliﬁcation techniques from [1]. Very
careful implementation of the MEE-TLS-CBC decryption
algorithm is needed to thwart these ampliﬁcation techniques.
In view of this, we highly recommend the use of a suitable
authenticated encryption algorithm in preference to CBC-
mode for DTLS.
ACKNOWLEDGEMENTS
We thank Xuelei Fan, David McGrew, Adam Langley,
Brad Wetmore and the anonymous reviewers for useful
feedback. We also thank Eric Rescorla for pointing out
that our attacks can be enhanced in the web setting using
BEAST-like techniques.
REFERENCES
[1] N. AlFardan and K. G. Paterson. Plaintext-recovery attacks
against Datagram TLS. In NDSS, 2012.
[2] N. AlFardan and K. G. Paterson. Lucky thirteen: Breaking
the TLS and DTLS record protocols. Full version of this
paper, available from www.isg.rhul.ac.uk/tls, 2013.
[3] G. V. Bard. The vulnerability of SSL to chosen plaintext
attack. IACR Cryptology ePrint Archive, 2004:111, 2004.
[4] G. V. Bard. A challenging but feasible blockwise-adaptive
chosen-plaintext attack on SSL. In SECRYPT, pages 99–109,
2006.
[5] B. Canvel, A. P. Hiltgen, S. Vaudenay, and M. Vuagnoux.
Password Interception in a SSL/TLS Channel. In D. Boneh,
editor, CRYPTO, volume 2729 of LNCS, pages 583–599.
Springer, 2003. ISBN 3-540-40674-3.
Guidelines for
[6] C. M. Chernick, C. Edington III, M. J. Fanto, and R. Rosen-
the Selection and Use of Trans-
thal.
port Layer Security (TLS) Implementations.
In NIST Spe-
cial Publication 800-52, June 2005, National Institute of
Standards and Technology. Available at http://csrc.nist.gov/
publications/nistpubs/800-52/SP-800-52.pdf , 2005.
[7] T. Dierks and C. Allen. The TLS Protocol Version 1.0. RFC
2246, Internet Engineering Task Force, 1999.
[8] T. Dierks and E. Rescorla. The Transport Layer Security
(TLS) Protocol Version 1.1. RFC 4346, Internet Engineering
Task Force, 2006.
[9] T. Dierks and E. Rescorla. The Transport Layer Security
(TLS) Protocol Version 1.2. RFC 5246, Internet Engineering
Task Force, 2008.
[10] T. Duong and J. Rizzo. Here come the ⊕ Ninjas. Unpublished
manuscript, 2011.
[11] D. Eastlake 3rd. Transport Layer Security (TLS) Extensions:
Extension Deﬁnitions. RFC 6066, 2011.
[12] H. Krawczyk. The order of encryption and authentication
for protecting communications (or: How secure is SSL?). In
CRYPTO, pages 310–331, 2001.
[13] H. Krawczyk, M. Bellare, and R. Canetti. HMAC: Keyed-
Hashing for Message Authentication. RFC 2104 (Informa-
tional), 1997.
[14] U. Maurer and B. Tackmann.
On the soundness of
formalizing the malleability of
authenticate-then-encrypt:
symmetric encryption. In ACM CCS, pages 505–515, 2010.
[15] D. McGrew and D. Bailey. AES-CCM Cipher Suites for
Transport Layer Security (TLS). RFC 6655 (Proposed Stan-
dard), 2012.
[16] N. Modadugu and E. Rescorla. The Design and Implemen-
tation of Datagram TLS. In NDSS, 2004.
[17] B. Moeller.
Security of CBC ciphersuites in SSL/TLS:
Problems and countermeasures, 2004. http://www.openssl.
org/∼bodo/tls-cbc.txt.
[18] K. G. Paterson, T. Ristenpart, and T. Shrimpton. Tag size
does matter: Attacks and proofs for the TLS record protocol.
In ASIACRYPT, pages 372–389, 2011.
[19] A. Pironti, P.-Y. Strub, and K. Bhargavan. Identifying website
users by TLS trafﬁc analysis: New attacks and effective
countermeasures. Technical Report 8067, INRIA, September
2012.
[20] E. Rescorla and N. Modadugu. Datagram Transport Layer
Security. RFC 4347, Internet Engineering Task Force, 2006.
[21] E. Rescorla and N. Modadugu. Datagram Transport Layer
Security Version 1.2. RFC 6347, Internet Engineering Task
Force, 2012.
[22] T. Ristenpart, E. Tromer, H. Shacham, and S. Savage. Hey,
you, get off of my cloud: exploring information leakage in
third-party compute clouds.
In E. Al-Shaer, S. Jha, and
A. D. Keromytis, editors, ACM Conference on Computer and
Communications Security, pages 199–212. ACM, 2009.
[23] P. Rogaway.
Problems with proposed IP cryptography.
Unpublished manuscript, 1995. http://www.cs.ucdavis.edu/
∼rogaway/papers/draft-rogaway-ipsec-comments-00.txt.
[24] J. Salowey, A. Choudhury, and D. McGrew. AES Galois
Counter Mode (GCM) Cipher Suites for TLS. RFC 5288
(Proposed Standard), 2008.
[25] S. Vaudenay. Security Flaws Induced by CBC Padding -
In EUROCRYPT,
Applications to SSL, IPSEC, WTLS ...
pages 534–546, 2002.
540
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:50 UTC from IEEE Xplore.  Restrictions apply.