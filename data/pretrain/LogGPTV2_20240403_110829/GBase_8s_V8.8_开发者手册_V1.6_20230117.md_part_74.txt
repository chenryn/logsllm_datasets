 在分析类查询的场景下，参数max_active_statements的值设置为CPU的
核数除以数据库节点个数，一般可以设置5~8个。
局部并发队列
采用资源池局部并发控制机制的目的是控制在数据库主节点上同一资源池内的并发作
业数量。局部并发控制机制根据执行作业的cost，控制复杂查询的并发作业数量。
参数parctl_min_cost数值用于判断执行作业是否是复杂作业。
14.3.3 配置 SMP
介绍SMP模块的使用限制与适用场景，并给出SMP配置指南。
14.3.3.1 SMP 适用场景与限制
背景信息
SMP特性通过算子并行来提升性能，同时会占用更多的系统资源，包括CPU、内存、
I/O等等。本质上SMP是一种以资源换取时间的方式，在合适的场景以及资源充足的情况
下，能够起到较好的性能提升效果；但是如果在不合适的场景下，或者资源不足的情况下，
反而可能引起性能的劣化。SMP特性适用于分析类查询场景，这类场景的特点是单个查询
时间较长、业务并发度低。通过SMP并行技术能够降低查询时延，提高系统吞吐性能。然
而在事务类大并发业务场景下，由于单个查询本身的时延很短，使用多线程并行技术反而会
增加查询时延，降低系统吞吐性能。
适用场景
 支持并行的算子：计划中存在以下算子支持并行。
 Scan：支持行存普通表和行存分区表顺序扫描 、列存普通表和列存分区
表顺序扫描。
 Join：HashJoin、NestLoop。
 Agg：HashAgg、SortAgg、PlainAgg、WindowAgg（只支持partitionby，
不支持orderby）。
 Stream：LocalRedistribute、LocalBroadcast。
 其他：Result、Subqueryscan、Unique、Material、Setop、Append、VectoRow。
 SMP特有算子：为了实现并行，新增了并行线程间的数据交换Stream算子供SMP特
南大通用数据技术股份有限公司
537
GBase 8s V8.8开发者手册
性使用。这些新增的算子可以看做Stream算子的子类。
 LocalGather：实现实例内部并行线程的数据汇总。
 LocalRedistribute：在实例内部各线程之间，按照分布键进行数据重分布。
 LocalBroadcast：将数据广播到实例内部的每个线程。
 LocalRoundRobin：在实例内部各线程之间实现数据轮询分发。
 示例说明，以TPCHQ1的并行计划为例。
在这个计划中，实现了Scan以及HashAgg算子的并行，并新增了LocalGather数据交
换算子。其中3号算子为LocalGather算子，上面标有的“dop:1/4”表明该算子的发送端线
程的并行度为4，而接受端线程的并行度为1，即下层的4号HashAggregate算子按照4并
行度执行，而上层的1~2号算子按照串行执行，3号算子实现了实例内并行线程的数据汇总。
通过计划Stream算子上表明的dop信息即可看出各个算子的并行情况。
 非适用场景
 索引扫描不支持并行执行。
 MergeJoin不支持并行执行。
 WindowAggorderby不支持并行执行。
 cursor不支持并行执行。
 存储过程和函数内的查询不支持并行执行。
 不支持子查询subplan和initplan的并行，以及包含子查询的算子的并行。
 查询语句中带有median操作的查询不支持并行执行。
 带全局临时表的查询不支持并行执行。
 物化视图的更新不支持并行执行。
14.3.3.2 资源对 SMP 性能的影响
SMP架构是一种利用富余资源来换取时间的方案，计划并行之后必定会引起资源消耗
的增加，包括CPU、内存、I/O等资源的消耗都会出现明显的增长，而且随着并行度的增大，
资源消耗也随之增大。当上述资源成为瓶颈的情况下，SMP无法提升性能，反而可能导致
集群整体性能的劣化。下面对各种资源对SMP性能的影响情况分别进行说明。
 CPU资源
南大通用数据技术股份有限公司
538
GBase 8s V8.8开发者手册
在一般客户场景中，系统CPU利用率不高的情况下，利用SMP并行架构能够更充分地
利用系统CPU资源，提升系统性能。但当数据库服务器的CPU核数较少，CPU利用率已
经比较高的情况下，如果打开SMP并行，不仅性能提升不明显，反而可能因为多线程间的
资源竞争而导致性能劣化。
 内存资源
查询并行后会导致内存使用量的增长，但每个算子使用内存上限仍受到work_mem等参
数的限制。假设work_mem为4GB，并行度为2，那么每个并行线程所分到的内存上限为
2GB。在work_mem较小或者系统内存不充裕的情况下，使用SMP并行后，可能出现数据
下盘，导致查询性能劣化的问题。
 I/O资源
要实现并行扫描必定会增加I/O的资源消耗，因此只有在I/O资源充足的情况下，并行
扫描才能够提高扫描性能。
14.3.3.3 其他因素对 SMP 性能的影响
除了资源因素外，还有一些因素也会对SMP并行性能造成影响。例如分区表中分区数
据不均，以及系统并发度等因素。
 数据倾斜对SMP性能的影响
当数据中存在严重数据倾斜时，并行效果较差。例如某表join列上某个值的数据量远大
于其他值，开启并行后，根据join列的值对该表数据做hash重分布，使得某个并行线程的
数据量远多于其他线程，造成长尾问题，导致并行后效果差。
 系统并发度对SMP性能的影响
SMP特性会增加资源的使用，而在高并发场景下资源剩余较少。所以，如果在高并发
场景下，开启SMP并行，会导致各查询之间严重的资源竞争问题。一旦出现了资源竞争的
现象，CPU、I/O、内存都会导致整体性能的下降。因此在高并发场景下，开启SMP往往不
能达到性能提升的效果，甚至可能引起性能劣化。
14.3.3.4 SMP 使用建议
使用限制
想要利用SMP提升查询性能需要满足以下条件：
系统的CPU、内存、I/O和网络带宽等资源充足。SMP架构是一种利用富余资源来换取
南大通用数据技术股份有限公司
539
GBase 8s V8.8开发者手册
时间的方案，计划并行之后必定会引起资源消耗的增加，当上述资源成为瓶颈的情况下，SMP
无法提升性能，反而可能导致性能的劣化。在出现资源瓶颈的情况下，建议关闭SMP。
配置步骤
(1) 观察当前系统负载情况，如果系统资源充足（资源利用率小于50%），执行2；否则退
出。
(2) 设置query_dop=1（默认值），利用explain打出执行计划，观察计划是否符合SMP适
用场景与限制小节中的适用场景。如果符合，进入3。
(3) 设置query_dop=value，不考虑资源情况和计划特征，强制选取dop为1或value。
(4) 在符合条件的查询语句执行前设置合适的 query_dop 值，在语句执行结束后关闭
query_dop。举例如下。
gsql=#SETquery_dop=4;
gsql=#SELECTCOUNT(*)FROMt1GROUPBYa;
......
gsql=#SETquery_dop=1;
 资源许可的情况下，并行度越高，性能提升效果越好。
 SMP并行度支持会话级设置，推荐客户在执行符合要求的查询前，打开
smp，执行结束后，关闭smp。以免在业务峰值时，对业务造成冲击。
14.3.4 配置 LLVM
LLVM（LowLevelVirtualMachine）动态编译技术可以为每个查询生成定制化的机器码
用于替换原本的通用函数。通过减少实际查询时冗余的条件逻辑判断、虚函数调用并提高数
据局域性，从而达到提升查询整体性能的目的。
由于LLVM需要消耗额外的时间预生成IR中间态表示并编译成机器码，因此在小数据
量场景或查询本身耗时较少时，可能引起性能的劣化。
14.3.4.1 LLVM 适用场景与限制
适用场景
 支持LLVM的表达式
查询语句中存在以下的表达式支持LLVM优化：
南大通用数据技术股份有限公司
540
GBase 8s V8.8开发者手册
 Case…when… 表达式
 In表达式
 Bool表达式（And/Or/Not）
 BooleanTest 表 达 式
（ IS_NOT_KNOWN/IS_UNKNOWN/IS_TRUE/IS_NOT_TRUE/IS_FALSE/IS_NOT
_FALSE）
 NullTest表达式（IS_NOT_NULL/IS_NULL）
 Operator表达式
 Function表达式（lpad、substring、btrim、rtrim、length）
 Nullif表达式
表达式计算支持的数据类型包括bool、tinyint、smallint、int、bigint、float4、float8、numeric、
date、time、timetz、timestamp、timestamptz、interval、bpchar、varchar、text、oid。
仅当表达式出现在向量化执行引擎中Scan节点的filter，HashJoin节点中的complicate
hashcondition、hashjoinfilter、hashjointarget，NestedLoop节点中的filter、joinfilter，Merge
Join节点的mergejoinfilter、mergejointarget，Group节点中的filter表达式时，才会考虑是
否使用LLVM动态编译优化。
 支持LLVM的算子：
 Join：HashJoin
 Agg：HashAgg
 Sort
其中HashJoin算子仅支持HashInnerJoin，对应的hashcond仅支持int4、bigint、bpchar
类型的比较；HashAgg算子仅支持针对bigint、numeric类型的sum及avg操作，且groupby
语句仅支持int4、bigint、bpchar、text、varchar、timestamp类型操作，同时支持count(*)聚
集操作。Sort算子仅支持对int4、bigint、numeric、bpchar、text、varchar数据类型的比较操
作。除此之外，无法使用LLVM动态编译优化，具体可通过explainperformance工具进行显
示。
非适用场景
 不支持小数据量表使用LLVM动态编译优化。
南大通用数据技术股份有限公司
541
GBase 8s V8.8开发者手册
 不支持生成非向量化执行路径的查询作业。
14.3.4.2 其他因素对 LLVM 性能的影响
LLVM优化效果不仅依赖于数据库内部具体的实现，还与当前所选择的硬件环境等有关。
 表达式调用C-函数个数
数据库内部针对表达式计算并未实现全codegen，即在整个表达式计算中部分表达式实
现了codegen，部分直接调用原本的C代码。如果整个表达式计算中后者占据了主要部分，
使用 LLVM 动态编译优化，可能会导致性能劣化。通过设置 log_min_message 的级别为
DEBUG1可以查看到哪些表达式直接调用了C代码实现。
 内存资源
LLVM特性的一个重要思想是保障数据的局域特性，即数据应尽可能的存放在寄存器中。
同时应减少数据加载，因此在使用LLVM优化时应设置足够大的work_mem，保证对应使用
LLVM优化的执行代码整个过程在内存中实现，否则可能引起性能劣化。
 优化器代价估算
LLVM特性实现了简易的代价估算模型，即依据当前参与节点运算的表大小决定当前节
点是否考虑使用LLVM动态编译优化。如果优化器低估了实际参与运算的行数，则原本可
获得收益的未正常获得收益。反之亦然。
14.3.4.3 LLVM 使用建议
目前LLVM在数据库内核侧已默认打开，用户可结合上述的分析进行配置，总体建议
如下：
(1) 设置合理的work_mem，在允许的条件下尽可能设置较大的work_mem，如果出现大量
数据落盘，则建议关闭LLVM动态编译优化（通过设置enable_codegen=off实现）。
(2) 设置合理的codegen_cost_threshold（默认值为10000），确保小数据量场景下避免使用
LLVM动态编译优化。当codegen_cost_threshold的值设定后，因使用LLVM动态编译
优化引入性能劣化，则建议增加codegen_cost_threshold的取值。
(3) 对于表达式计算使用LLVM动态编译优化，如果存在大量的调用C-函数的场景，建议
关闭LLVM动态编译优化。
南大通用数据技术股份有限公司
542
GBase 8s V8.8开发者手册
在资源许可的情况下，数据量越大，可获得的性能提升效果越好。
14.4SQL 调优指南
SQL调优的唯一目的是“资源利用最大化”，即CPU、内存、磁盘IO三种资源利用最
大化。所有调优手段都是围绕资源使用开展的。所谓资源利用最大化是指SQL语句尽量高
效，节省资源开销，以最小的代价实现最大的效益。比如做典型点查询的时候，可以用
seqscan+filter（即读取每一条元组和点查询条件进行匹配）实现，也可以通过indexscan实
现，显然indexscan可以以更小的代价实现相同的效果。
根据硬件资源和客户的业务特征，确定合理的部署方案和表定义。这是数据库在多数情
况下满足性能要求的基础。在合理的数据库设计和安装基础上，进行下述调优操作。
14.4.1 Query 执行流程
SQL引擎从接受SQL语句到执行SQL语句，需要经历的步骤如图14-2和表1所示。
其中，红色字体部分为DBA可以介入实施调优的环节。
图 14-2SQL引擎执行查询类SQL语句的流程
表 14-3SQL引擎执行查询类SQL语句的步骤说明
南大通用数据技术股份有限公司
543
GBase 8s V8.8开发者手册
步骤 说明
1、语法&词法解析 按照约定的SQL语句规则，把输入的SQL语句从字符串转化为
格式化结构（Stmt）。
2、语义解析 将“语法&词法解析”输出的格式化结构转化为数据库可以识别
的对象。
3、查询重写 根据规则把“语义解析”的输出等价转化为执行上更为优化的结
构。
4、查询优化 根据“查询重写”的输出和数据库内部的统计信息规划SQL语句
具体的执行方式，也就是执行计划。统计信息和GUC参数对查
询优化（执行计划）的影响，请参见调优手段之统计信息和调优
手段之GUC参数。
5、查询执行 根据“查询优化”规划的执行路径执行SQL查询语句。底层存储
方式的选择合理性，将影响查询执行效率。详见调优手段之底层
存储。
调优手段之统计信息
GBase8s优化器是典型的基于代价的优化（Cost-BasedOptimization，简称CBO）。在
这种优化器模型下，数据库根据表的元组数、字段宽度、NULL记录比率、distinct值、MCV
值、HB值等表的特征值，以及一定的代价计算模型，计算出每一个执行步骤的不同执行方
式的输出元组数和执行代价（cost），进而选出整体执行代价最小/首元组返回代价最小的执
行方式进行执行。这些特征值就是统计信息。从上面的描述可以看出统计信息是查询优化的
核心输入，准确的统计信息将帮助规划器选择最合适的查询规划。一般来说我们会通过
ANALYZE语法收集整个表或者表的若干个字段的统计信息，周期性地运行ANALYZE，或
者在对表的大部分内容做了更改之后马上运行ANALYZE。
调优手段之GUC参数
查询优化的主要目的是为查询语句选择高效的执行方式。
如下SQL语句:
selectcount(1)
fromcustomerinnerjoinstore_saleson(ss_customer_sk=c_customer_sk);
在执行 customer innerjoin store_sales 的时候，GBase 8s 支持 Nested Loop、Merge Join
和HashJoin三种不同的Join方式。优化器会根据表customer和表store_sales的统计信息估
算结果集的大小以及每种join方式的执行代价，然后对比选出执行代价最小的执行计划。
南大通用数据技术股份有限公司
544
GBase 8s V8.8开发者手册
正如前面所说，执行代价计算都是基于一定的模型和统计信息进行估算，当因为某些原
因代价估算不能反映真实的cost的时候，我们就需要通过guc参数设置的方式让执行计划倾
向更优规划。
调优手段之底层存储
GBase8s支持行存表、列存表，底层存储方式的选择严格依赖于客户的具体业务场景。
一般来说计算型业务查询场景（以关联、聚合操作为主）建议使用列存表；点查询、大批量
UPDATE/DELETE业务场景适合行存表。
对于每种存储方式还有对应的存储层优化手段，这部分会在后续的调优章节深入介绍。
调优手段之SQL重写
除了上述干预SQL引擎所生成执行计划的执行性能外，根据数据库的SQL执行机制以
及大量的实践发现，有些场景下，在保证客户业务SQL逻辑的前提下，通过一定规则由DBA
重写SQL语句，可以大幅度的提升SQL语句的性能。
这种调优场景对DBA的要求比较高，需要对客户业务有足够的了解，同时也需要扎实
的SQL语句基本功，后续会介绍几个常见的SQL改写场景。
14.4.2 SQL 执行计划介绍
14.4.2.1 SQL 执行计划概述
SQL执行计划是一个节点树，显示GBase8s执行一条SQL语句时执行的详细步骤。每
一个步骤为一个数据库运算符。
使用EXPLAIN命令可以查看优化器为每个查询生成的具体执行计划。EXPLAIN给每
个执行节点都输出一行，显示基本的节点类型和优化器为执行这个节点预计的开销值。如图
14-3所示。
图 14-3SQL执行计划示例
 最底层节点是表扫描节点，它扫描表并返回原始数据行。不同的表访问模式有不同的扫
南大通用数据技术股份有限公司
545
GBase 8s V8.8开发者手册
描节点类型：顺序扫描、索引扫描等。最底层节点的扫描对象也可能是非表行数据（不
是直接从表中读取的数据），如VALUES子句和返回行集的函数，它们有自己的扫描
节点类型。
 如果查询需要连接、聚集、排序、或者对原始行做其它操作，那么就会在扫描节点之上
添加其它节点。 并且这些操作通常都有多种方法，因此在这些位置也有可能出现不同
的执行节点类型。
 第一行（最上层节点）是执行计划总执行开销的预计。这个数值就是优化器试图最小化
的数值。
执行计划显示信息
除了设置不同的执行计划显示格式外，还可以通过不同的EXPLAIN用法，显示不同详
细程度的执行计划信息。常见有如下几种，关于更多用法请参见EXPLAIN语法说明。
 EXPLAIN_statement_：只生成执行计划，不实际执行。其中statement代表SQL语句。