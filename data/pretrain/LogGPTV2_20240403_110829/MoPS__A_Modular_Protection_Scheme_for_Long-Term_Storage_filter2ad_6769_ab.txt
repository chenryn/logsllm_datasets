when receiving some input data, usually in hashed form, the
TSA generates a timestamp by signing the data together
with the current time. To verify the correctness of this at-
testation, the veriﬁer must check whether the signature gen-
erated by the TSA is correct and whether the certiﬁcate for
the used signature key was still valid at the time the at-
testation got renewed. It follows that the veriﬁcation data
should contain all data necessary to verify the certiﬁcate of
the TSA, including revocation information collected at the
time when the attestation got renewed.
Compared to WVM-based timestamps, this type of attes-
tation can also be used for applications where no witnesses
are available to testify the generation of attestations. How-
ever, on the downside, the TSA is trusted to include the
correct time, i.e. the time when the attestation was issued,
in the timestamp. Furthermore, a public key infrastructure
(PKI) is needed which binds the TSA to its public signature
key by means of certiﬁcates. Finally, it is necessary to trust
in the security of the employed signature scheme and the
hash function within the validity period of the attestation.
3.1.3 Notarial Attestation
Notarial attestations [6, 11] are issued by an instance that
is able to verify certain properties of the received input be-
fore signing the data together with a date. In the following
we will refer to this instance as notarial authority (NA).
Which properties are veriﬁed depends on the application
and can, for instance, be the signature(s), and/or the certiﬁ-
cate(s), and/or the attestation(s) of one or multiple signed
documents. This is also the main diﬀerence compared to
signature- and WVM-based timestamps which are generated
blindly for the received data.
More precisely, notarial attestations are generated as fol-
lows: During the initialization procedure, the required prop-
erties of the input data are veriﬁed and, if valid, the data
is signed together with the current time. For most of the
data structures presented in the next section, the attesta-
tions generated during the renewal procedure equal those
of the initialization procedure. The only exception is when
using this technique together with the notarial attestation
wrapper (see Section 3.2.6). In this case, after veriﬁcation,
the data is signed together with the time the proof of ex-
istence has been initialized. During veriﬁcation, the signa-
tures of all notarial attestations contained in the proof of
existence are veriﬁed and, if more than one attestation was
generated, it is checked whether the certiﬁcates for the used
signature keys were valid until the attestations got renewed.
Thus, like for signature-based timestamps, the veriﬁcation
data for attestations which got renewed should contain all
data necessary to verify the certiﬁcate of the NA, including
revocation information.
The advantage of notarial attestations is that since they
allow to verify, for example, the correctness of document
signatures before prolonging them and attestations before
renewing them, it is more likely to detect failures. However,
this requires that signiﬁcantly more and possibly sensitive
data is sent to the NA and leads to a much higher compu-
tation and communication complexity. Furthermore, since
the NA issuing the notarial attestations is not restricted to
include the current time in the attestations, it can, if ma-
438Table 2: Overview of the diﬀerent data structures
and the access patterns they are most suitable for.
SLS NAW
AS MTS MDS
Data Structure
Retrieval
Single documents
Ranges of documents
All documents
Storage
Few documents
Sets of documents
Documents added to
folders sequentially











licious, backdate documents. Thus, this instance must be
trusted to verify the properties of the data received correctly
and to include the appropriate time in the attestation. Fi-
nally, like for signature-based timestamps, a PKI is needed
which binds the NA to its public signature key. Also, the
employed signature scheme and hash function must be se-
cure within the validity period of the attestation.
3.2 Data Structures
Attestation techniques are used to generate proofs of exis-
tence for signed documents. These proofs allow a third party
to verify that a given document has been generated by a spe-
ciﬁc data owner and that no unauthorized changes have been
performed since. To provide an eﬃcient proof generation
and veriﬁcation process, several data structures were pro-
posed. However, whether a certain approach is indeed more
eﬃcient than another depends on the access pattern with
which documents are stored and opened and, correspond-
ingly, with which the proofs of existence for documents are
generated and veriﬁed. Furthermore, newer approaches pro-
pose improvements from which many schemes would beneﬁt,
but they were not retrospectively adapted. Thus, we ana-
lyzed existing long-term archiving schemes, identiﬁed the
individual data structures, and generalized and improved
them.
In the following we ﬁrst provide a generic description of
the procedures used to generate and verify proofs of ex-
istence. Then, we describe all identiﬁed data structures,
attestation sequence, Merkle tree sequence, multiple docu-
ments sequence, skip-list sequence, and notarial attestation
wrapper, compare them with related work, and highlight for
which access pattern which data structure is most suitable.
Table 2 summarizes the diﬀerent data structures and the ac-
cess patterns for which they are the most eﬃcient solution.
We assume that choosing a data structure not only deter-
mines the way resources (i.e. signed documents, attestations,
and veriﬁcation data) are stored, but also how the stored
resources are hashed during the initialization, renewal, and
veriﬁcation procedures.
While the notarial attestation wrapper can only be used
with notarial attestations, all attestation techniques can be
applied for the remaining data structures. While WVM-
based and signature-based timestamps are generated “blind-
ly”, the notarial attestation allows to check certain proper-
ties of the data before creating the attestation. However,
note that in this case the NA needs access to all data re-
quired to perform the checks.
3.2.1 Generation and Veriﬁcation Procedures
Each data structure comes with mainly three procedures:
the initialization procedure, the renewal procedure, and the
veriﬁcation procedure.
Initialization Procedure. During the initialization, an
attestation on input data d = D||s consisting of document D
and its signature s is generated as described in Section 3.1.
In the following we refer with Attest to a function that gen-
erates a WVM-based timestamp, a signature-based times-
tamp, or a notarial attestation by interacting with a third
party. This function is used to generate an initial attesta-
tion a0 for the hash of input data d and the current time t0.
The data stored for veriﬁcation is attestation a0 and hash
function H0.
Renewal Procedure. To prolong the security of the
proof of existence, a new attestation an is generated. Here
two cases are distinguished: If the validity period of an−1 is
about to end, the attestation renewal procedure is triggered
and a new attestation is generated similarly to the process
described for the initialization procedure.
If the security
of the hash function Hn−1 is about to fade out, the hash
renewal procedure is triggered. Here the document and, de-
pending on the data structure, also some additional data is
rehashed using a new hash function Hn and afterwards a
new attestation for this hash value is generated. Input to
both procedures are at least the old attestation an−1, up-
to-date veriﬁcation data vn−1, the time tn when the new
attestation is generated, and additional data that depends
on the concrete data structure.
Veriﬁcation. To verify the proof of existence for a signed
document, ﬁrst, all data that got attested by calling Attest is
recomputed using the signed document, the hash functions,
the veriﬁcation data, and additional data that depends on
the data structure. Then, the correctness of each attestation
is veriﬁed by using the recomputed attested data and the
veriﬁcation data. Finally, it is veriﬁed that each attestation
was renewed before its validity period ended. Since this
procedure is equal for all data structures, it is not further
detailed in the following descriptions.
3.2.2 Attestation Sequence (AS)
Using the data structure attestation sequence (AS), a proof
of existence for a signed document d is generated by creating
a sequence of attestations a0, . . . , an. This process is basi-
cally as described in Section 3.2.1 and a detailed description
in form of pseudocode is given in Listing 1.
Listing 1: Attestation Sequence Procedures
Initialization(InputData d, Time t0, HashFunction H0)
h0 = H0(d)
a0 = Attest(H0||h0, t0)
Store a0 and H0 for veriﬁcation
Renewal(InputData d, Attestations a0, ..., an−1, VeriﬁcationData
v0, ..., vn−1, Time tn, HashFunctions Hn−1, Hn)
If Hn = Hn−1
hn = AttestationRenewal(an−1, vn−1, Hn)
hn = HashRenewal(d, a0, ..., an−1, v0, ..., vn−1, Hn)
Else
an = Attest(Hn||hn, tn)
Store an, vn−1, and Hn for veriﬁcation
AttestationRenewal(an−1, vn−1, Hn)
Return Hn(an−1||vn−1)
HashRenewal(d, a0, ..., an−1, v0, ..., vn−1, Hn)
Return Hn(d||a0||v0||...||an−1||vn−1)
439A similar data structure is used by the AdES family that
even comes with ETSI standards (e.g. ETSI TS 101 903 [3]).
However, an important diﬀerence between their solution and
our component is that we distinguish whether only the va-
lidity period of the attestation or also of the hash function is
about to end. In the ﬁrst case it is not necessary to choose
a new hash function and to rehash all existing sequence ele-
ments when creating new attestations. This leads to a much
more eﬃcient solution when generating and verifying the
proof of existence.
Pros and Cons. The advantage of AS is that there
is no need to store additional information speciﬁc to the
data structure and there is also no need to hash additional
information. Thus, when single documents are protected,
this data structure is the most eﬃcient approach regarding
computation and space complexity. For a rigorous perfor-
mance evaluation and a comparison between this approach
and the other approaches see [10]2. The performance eval-
uations conﬁrmed that if a huge amount of data must be
protected, e.g. when storing or archiving medical records, a
huge amount of attestations must be generated and updated.
It follows that this is only a suitable approach if proofs of ex-
istence are generated for very few documents and the proofs
are veriﬁed individually.
3.2.3 Merkle Tree Sequence (MTS)
Using the data structure Merkle tree sequence (MTS), a
proof of existence for a set of signed documents is generated.
More precisely, instead of using a hash function to hash a
single document, a Merkle tree [9] is used to generate a sin-
gle hash value for a set of documents. Then, the attestation
a0 is generated for the computed Merkle tree root r0. Note
that when the hash function used to generate this Merkle
tree is about to become insecure, also the security of the
Merkle tree is about to fade out. Thus, when HashRenewal
is triggered, a new Merkle tree for the content, i.e. of the
previous Merkle tree, is computed and a new attestation is
generated for its root. The signed documents are stored to-
gether with the authentication paths of their leaves in the
diﬀerent Merkle trees to prevent that each Merkle tree must
be completely recreated to verify single documents. Fur-
thermore, this still allows one to maintain a separate proof
of existence for each signed document. The pseudocode of
this process can be found in Listing 2.
A similar data structure is used by ERS and its XML ver-
sion XMLERS which were standardized and can be found in
the RFC standards RFC 4998 [4] and RFC 6283 [2], respec-
tively. Their construction is diﬀerent from our component
with respect to the data used to compute the Merkle tree
leaves when the hash function is renewed during the hash
renewal procedure:
In our construction, we put only the
documents and their authentication paths in the leaves. The
previous attestations and their veriﬁcation data are rehashed
and attested together with the tree root. In ERS, also all
attestations and their veriﬁcation data are added to each
leaf. Since this data is equal for all documents, this leads
to hashing redundant information, making our component
more eﬃcient with respect to the hash renewal procedure.
Pros and Cons. Using our data structure MTS, a proof
of existence can be generated for a set of signed documents,
thereby making this technique a good solution when huge
amounts of documents need to be protected, since it speeds
up the initialization and renewal procedure. For an eﬃciency
analysis of the usage of Merkle trees in archiving systems and
a comparison with alternative techniques, see [12] and [10].
The performance evaluation also showed that for use cases
where only few data is protected, MTS is less eﬃcient with
respect to the renewal procedure and the space consumption
since authentication paths must be generated and stored3.
Furthermore, this approach only provides an eﬃcient solu-
tion if sets of documents are stored, but not for use cases
where multiple documents of diﬀerent sets are opened and
veriﬁed.
Listing 2: Merkle Tree Sequence Procedures
Initialization(InputData d0, ..., dm−1, Time t0, HashFunction H0)
MT0 = ComputeMerkleTree(d0, ..., dm−1) using H0
r0 = MT0.Root
a0 = Attest(H0||r0, t0)
Store a0 and H0 for veriﬁcation
For i = 0, ..., m − 1
pi,0 = MT0.AuthenticationPathi
Store pi,0 with di for recomputing r0
Renewal(InputData d0, ..., dm−1, Attestations a0, ..., an−1,
VeriﬁcationData v0, ..., vn−1, AuthenticationPaths p0,0,
..., pm−1,k−1, Time tn, HashFunctions Hn−1, Hn)
If Hn = Hn−1
AttestationRenewal(an−1, vn−1, tn, Hn)
Else
HashRenewal(d0, ..., dm−1, a0, ..., an−1, v0, ..., vn−1,
p0,0, ..., pm−1,k−1, tn, Hn)
AttestationRenewal(an−1, vn−1, tn, Hn)
hn = Hn(an−1||vn−1)
an = Attest(Hn||hn, tn)
Store an, vn−1, and Hn for veriﬁcation
HashRenewal(d0, ..., dm−1, a0, ..., an−1, v0, ..., vn−1,
p0,0, ..., pm−1,k−1, tn, Hn)
MTk = ComputeMerkleTree(d0||p0,0||...||p0,k−1, ...,
dm−1||pm−1,0||...||pm−1,k−1) using Hn
rk = MTk.Root
hn = Hn(a0||v0||...||an−1||vn−1)
an = Attest(Hn||rk||hn, tn)
Store an, vn−1, and Hn for veriﬁcation
For i = 0, . . . , m − 1
pi,k = MTk.AuthenticationPathi
Store pi,k with di for recomputing rk
3.2.4 Multiple Documents Sequence (MDS)
Using the multiple documents sequence (MDS), a proof of
existence for a batch of signed documents is generated where
the documents are added subsequently to the storage system
or archive. After a proof of existence for the initial signed
document has been generated, each time a new document
is added to the batch, it is appended to the proof and an
attestation for both, the new document and the proof, is gen-
erated. Like for MTS, the rehashing in HashRenewal is done
using Merkle trees to prevent that a veriﬁer needs access
to all signed documents, attestations, and their veriﬁcation
data contained in the chain in order to verify an. For sim-
plicity we assume that the time intervals in which documents