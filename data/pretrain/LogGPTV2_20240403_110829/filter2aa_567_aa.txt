Owning the LAN in 2018
Defeating MACsec and 802.1x-2010
DEF CON 26
Gabriel “solstice” Ryan
Disclaimers & Updates
These slides are an early version designed for pre-release prior to DEF CON 26. 
All content will be updated by the time of the presentation at DEF CON 26 in 
August. Final versions of all content will be available at:
§ https://www.digitalsilence.com/blog/
About: Digital Silence
Denver-based security consulting firm:
§
Penetration testers who give a !@#$
§
Red teaming
§
Penetration Testing
§
Reverse-engineering / advanced appsec / research
Twitter (for those of you who are into that sort of thing): @digitalsilence_
About: Gabriel Ryan (a.k.a. solstice)
Co-Founder / Senior Security Assessment Manager @ Digital Silence
§
Former Gotham Digital Silence, former OGSystems
§
Red teamer / Researcher / New Dad
Twitter: @s0lst1c3
LinkedIn: ms08067
Email: PI:EMAIL
Introduction to 802.1x
The 802.1x authentication protocol:
§ Authentication protocol
§ Used to protect a local area network (LAN) or wireless 
local area network (WLAN) with rudimentary authentication
What is 802.1x?
§ Authentication protocol
§ Used to protect a local area network (LAN) or wireless 
local area network (WLAN) with rudimentary authentication
802.1.x defines an exchange between three parties:
§ supplicant – the client device that wishes to connect to the 
LAN [1][2][9]
§ authenticator – a network device such as a switch that 
provides access to the LAN [1][2][9]
§ authentication server – a host that runs software that 
implements RADIUS or some other Authorization, 
Authentication, and Accounting (AAA) protocol [1][2][9]
§
authenticator can be thought of as a gatekeeper
§
supplicant connects to a switch port and provides the authenticator 
with its credentials [1][2][9]
§
authenticator forwards credentials to the authentication server [1][2][9]
§
Authentication server validates the credentials, and either allows or 
denies access the network [1][2][9]
802.1x is (typically) a four step sequence:
1. Initialization
2. Initiation
3. EAP Negotiation
4. Authentication
[1][2][9]
Ports have two states:
§
Authorized – traffic is unrestricted
§
Unauthorized – traffic is restricted to 802.1x
[1][2][9]
Step 1: Initialization
1. Supplicant connects to switch port, which is disabled
2. Authenticator detects new connection, enables switch port 
in unauthorized state
[1][2][9]
Step 2: Initiation
1. (optional) Supplicant sends EAPOL-Start frame [1][2][9]
2. Authenticator responds with EAP-Request-Identity frame 
[1][2][9]
3. Supplicant sends EAP-Response-Identity frame (contains 
an identifier such as a username) [1][2][9]
4. Authenticator encapsulates EAP-Response-Identity in a 
RADIUS Access-Request frame and forwards it to 
Authentication Server [1][2][9]
Step 3: EAP Negotiation
Long story short: 
supplicant and 
authentication 
server haggle until 
they decide on an 
EAP method that 
they’re both 
comfortable with. 
[1][2][9]
Step 4: Authentication
§
Specific details of how authentication should work are 
dependent on the EAP method chosen by the 
authentication server and supplicant [1][2][9]
§
Always will result in a EAP-Success or EAP-Failure 
message [1][2][9]
§
Port is set to authorized state if EAP-Success, otherwise 
remains unauthorized [1][2][9]
What is EAP?
Extensible Authentication Protocol (EAP):
It’s an authentication framework:
§
Not really a protocol, only defines message formats
§
Individual EAP implementations are called ”EAP methods”
§
Think of it as a black box for performing authentication
Notable EAP methods…
EAP-MD5
EAP-MD5: Security Issues
Entire process occurs over plaintext (bad bad bad bad bad) 
Brad Antoniewicz and Josh Wright in 2008: [13]
§
attacker can capture MD5-Challenge-Request and MD5-Challenge-
Response by passively sniffing traffic [13]
§
Dictionary attack can be used to obtain a password using captured 
data [13]
EAP-MD5: Security Issues
Fanbao Liu and Tao Xie in 2012: [19]
§ EAP-MD5 credentials can be recovered even more 
efficiently using length-recovery attack [19]
EAP-PEAP
EAP-PEAP: Security Issues
Remember – EAP also used for wireless authentication. 
Brad Antoniewicz and Josh Wright in 2008: [13]
§ attacker can use a rogue access point attack to force the supplicant 
to authenticate with a rogue authentication server [13][20]
§ So long as the supplicant accepts the certificate presented by the 
attacker’s authentication server, the supplicant will transmit an EAP 
challenge and response to the attacker [13][21]
§ can be cracked to obtain a plaintext username and password [13][21]
EAP-PEAP: Security Issues
MS-CHAPv2 is the strongest Inner Authentication protocol 
available for use with EAP-PEAP and EAP-TTLS:
§ vulnerable to a cryptographic weakness discovered by Moxie 
Marlinspike and David Hulton in 2012 [22]
§ MS-CHAPv2 challenge and response can be reduced to a single 56-
bits of DES encryption [22][23]
§ The 56-bits can be converted into a password-equivalent NT hash 
within 24 hours with a 100% success rate using FPGA-based 
hardware [22][23]
EAP-TLS
EAP-TLS
EAP-TLS was introduced by RFC 5216 in response to 
weaknesses in EAP methods such as EAP-PEAP and EAP-
TTLS:
§ strength lies in use of mutual certificate-based authentication during the 
outer authentication process [24]
§ prevents the kinds of MITM attacks that affect weaker EAP methods [24]
§ Poor adoption rate [25]
Brief History of Wired Port Security
Brief History of Wired Port Security
2001 –
the 802.1x-2001 standard is created to provided  
rudimentary authentication for LANs [1]
2004 –
the 802.1x-2004 standard is created as an 
extension of 802.1x-2001 to facilitate the use of 
802.1x in WLANs extended 802.1x-2001 for use 
in WLAN [2]
Brief History of Wired Port Security
2005 –
Steve Riley demonstrates that 802.1x-
2004 can be bypassed by inserting a hub 
between supplicant and authenticator [3]
§ Interaction limited to injecting UDP packets (TCP race 
condition) [4] 
Brief History of Wired Port Security
2011 – “Abb” of Gremwell Security creates Marvin: [5]
§ Bypasses 802.1x by introducing rogue device directly 
between supplicant and switch [5]
§ No hub necessary: rogue device configured as a bridge [5]
§ Full interaction with network using packet injection [5]
Brief History of Wired Port Security
2011 – Alva Duckwall’s 802.1x-2004 bypass: [4]:
§ Transparent bridge used to introduce rogue device 
between supplicant and switch [4]
§ No packet injection necessary: network interaction granted 
by using iptables to source NAT (SNAT) traffic originating 
from device [4]
§ More on this attack later...
Brief History of Wired Port Security
2017 – Valérian Legrand creates Fenrir: [6]:
§ Works similarly to Duckwall’s tool, but implements NATing
in Python using Scapy (instead of making calls to iptables / 
arptables / ebtables) [6]
§ Modular design, support for responder, etc…
MAC Filtering and MAC Authentication 
Bypass (MAB)
Fun fact: not all devices support 802.1x….
Not all devices support 802.1x:
§
Enterprise organizations with 802.1x protected networks 
need to deploy them anyways
§
Solution: disable 802.1x on the port used by the device –
this is known as a port security exception
§
802.1x usually replaced with MAC filtering or some other 
weak form of access control
Port security exceptions:
§
Historically, very prevalent due to widespread lack of 
802.1x support by peripheral devices (printers, IP 
cameras, etc)
§
Low hanging fruit for attackers – much easier than trying 
to actually bypass 802.1x using a bridge or hub
Demo: MAB
Current State of Wired Port Security
Relatively new technology: 802.1x-2010
Uses MACsec to provide:
§ hop-by-hop Layer 2 encryption [3][4][6][7] 
§ Packet-by-packet integrity check [3][4][6][7]
Mitigates bridge-based attacks that affect 802.1x-2004 [7] 
802.1x-2010: Vendor Support
Largest manufacturers of enterprise networking 
hardware now support 802.1x-2010 and MACsec:
§ Limited to high end equipment
§ Full support for all 802.1x-2010 features varies by make 
and model
802.1x-2010: Adoption Rates
Loaded question, since adoption rates for 802.1x 
itself remain low. With that said:
§ MACsec and 802.1x-2010 are just beginning to take off
§ adoption rate steadily increasing
Improvements in Peripheral Device Security
Most printer manufacturers offer at least one 
affordable model that supports 802.1x:
§ Legacy hardware phased out, replaced with 802.1x 
capable models
§ Port security exceptions becoming less prevalent (many 
sad red teamers)
Improvements in Peripheral Device Security
Goal of this project: tip the scales back in favor of 
attackers
§ explore ways in which 802.1x-2010 and MACsec can be 
bypassed 
§ Address the reduced prevalence of port security 
exceptions by identifying alternative methods for 
attacking peripheral devices
Improvements to Bridge-Based Bypass 
Techniques
Classical Bridge-based 802.1x Bypass
§ Developed by Alva Duckwall in 2014 [4] 
§ Uses transparent bridge to silently introduce rogue device between 
supplicant and authenticator [4]
§ Network interaction achieved by using iptables to source NAT (SNAT) 
traffic originating from device [4]
§ Hidden SSH service created on rogue device by forwarding traffic to 
the supplicant’s IP address on a specified port to bridge’s IP address 
on port 22 [4]
Improvement: Leveraging Native EAPOL Forwarding
Linux kernel will not forward EAPOL packets over a 
bridge. Existing tools deal with this problem by 
either:
§ patching the Linux kernel
§ Relying on high level libraries such as Scapy
Improvement: Leveraging Native EAPOL Forwarding
Problems with both of these approaches:
§ Relying on Kernel patches can become unwieldy: no 
publicly available Kernel patches for modern kernel 
versions
§ Relying on high level tools such as Scapy can make the 
bridge slow under heavy loads [17][18]
Improvement: Leveraging Native EAPOL Forwarding
Fortunately, the situation 
has dramatically improved 
since Duckwall’s
contribution:
§ as of 2012, EAPOL bridging can be enabled using the proc 
file system [11]
§ that means no more patching :D [11]
Improvement: Bypassing Sticky MAC
Most modern authenticators use some form of Sticky 
MAC:
§ dynamically associates the MAC address of the supplicant 
to the switch port once the supplicant has successfully 
authenticated [28][29]
§ if another MAC address is detected on the switch port, a 
port security violation occurs and the port is blocked [28][29]
Improvement: Bypassing Sticky MAC
Our updated 
implementation:
§ sets the bridge and PHY 