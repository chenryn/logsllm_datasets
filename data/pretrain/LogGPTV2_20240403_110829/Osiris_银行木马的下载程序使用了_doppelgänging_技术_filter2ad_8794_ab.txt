NTFS事务通常在数据库上运行时会使用到，也以类似的方式存在于NTFS文件系统中。 NTFS事务将一系列操作封装到一个单元中。
在事务内部创建文件时，直到提交事务之前它将不接受任何外部访问。 ProcessDoppelgänging使用它们来创建投放载荷的不可见文件。  
通过分析案例可以发现，他们使用NTFS事务的方法是完全相同的，只有所用的API有着细微的差别。加载程序会创建一个新事务，在该事务中创建一个新文件。最初的实现使用了来自Kernel32的CreateTransaction和CreateFileTransacted。而在这里，他们被低级别的其他方法取代了。  
首先，调用来自NTDLL的函数ZwCreateTransaction。然后，作者通过RtlSetCurrentTransaction和ZwCreateFile打开事务处理文件（创建的文件是％TEMP％
Liebert.bmp）。接着dropper将缓冲区写入文件，这里使用了具有ZwWriteFile的RtlSetCurrentTransaction。  
可以看到正在写入的缓冲区包含了第二阶段新的PE载荷。对于此技术，文件通常只在事务中可见，不能由其他进程（如AV扫描程序）打开。  
此事务文件会创建一个section。而要执行功能的话，只能通过低级API：ZwCreateSection / NtCreateSection来实现。  
创建该section后，即不再需要该文件。事务通过ZwRollbackTransaction被回滚，刚刚对文件的更改不会保存在磁盘上。  
因此，上述部分与ProcessDoppelgänging的对应部分是相同的。dropper的作者通过使用从 NTDLL的自定义副本调用的
低级函数的方式使其更加隐秘。  
此时，Osiris dropper创建了两个完全不相关的元素：  
一个进程（此时包含映射的、合法的可执行文件wermgr.exe）  
一个section（从事务处理文件创建并包含恶意载荷）  
如果这是典型的ProcessDoppelgänging则将不会产生上述情况，而是会根据带有映射载荷的部分直接创建进程。  
在恶意作者的两种方法结合点处，如果跟踪执行就可以看到在回滚事务之后，调用了以下函数（格式：RVA;函数）：  
4b1e6;ntdll_1.ZwQuerySection  
4b22b;ntdll.NtClose  
4b239;ntdll.NtClose  
4aab8;ntdll_1.ZwMapViewOfSection  
4af27;ntdll_1.ZwProtectVirtualMemory  
4af5b;ntdll_1.ZwWriteVirtualMemory  
4af8a;ntdll_1.ZwProtectVirtualMemory  
4b01c;ntdll_1.ZwWriteVirtualMemory  
4b03a;ntdll_1.ZwResumeThread  
因此，新创建的部分看起来只是作为附加模块映射到了新进程中。将载荷写入内存并设置为必要的补丁（例如入口点重定向）后，将恢复该过程：  
重定向执行的方式类似于Process
Hollowing的变体。远程进程的PEB已打补丁，新模块库也已经被设置为需添加的部分。（由于这个原因，当进程恢复时，导入将自动加载。）  
但是，入口点重定向仅由原始模块的入口点地址处的补丁完成。单个跳转重定向到注入模块的入口点：  
如果修补入口点失败，则加载程序包含的第二个入口点重定向变体，方法是在线程的上下文中设置新地址（ZwGetThreadContext – >
ZwSetThreadContext），这是Process Hollowing中使用的经典技术：  
## 两全其美的办法（两种技术的结合）
Process Hollowing的薄弱点是关于注入载荷的内存空间上设置的保护权限。Process
Hollowing通过VirtualAllocEx在远程进程中分配内存页，然后在那里写入载荷。它会产生一种不良影响：访问权限（MEM_PRIVATE）与正常加载的可执行文件（MEM_IMAGE）不同。将有效负载加载为映像的主要障碍是需要将其加载在磁盘上，但是一旦这么做就很容易被杀毒软件发现。  
Doppelgänging提供了一种解决方案：不可见的事务处理文件，可以安全地放入载荷而不会被发现。此技术假定事务处理文件将用于创建section（MEM_IMAGE），然后此section将成为新进程的基础（使用NtCreateProcessEx）。  
此解决方案运行良好，但要求所有流程参数必须手动加载：首先通过RtlCreateProcessParametersEx创建它们，然后将它们设置为远程PEB。这使得在64位系统上运行32位进程就变得很困难起来，因为在WoW64进程的情况下，有2个PEB需要填充。  
如果我们像Process
Hollowing那样创建流程，那么ProcessDoppelgänging的那些问题就可以轻松解决。作者使用来自Kernel32的文档化API，从合法文件中创建了一个进程。载有载荷的部分由于加载了适当的访问权限（MEM_IMAGE），可以在后续中被添加，且执行时重定向到它。
## 第二阶段装载
这里的Kernel32的DLL文件(8d58c731f61afe74e9f450cc1c7987be)并非核心部分，仅是加载器的下一个阶段。它唯一的作用是加载最终的有效载荷。步骤是将Osiris核心逐块解压缩，并将其依赖项手动加载到加载器进程中新分配的内存区域。在这次自注入之后，加载器跳转到有效负载的入口点：  
有趣的是，应用程序的入口点与标头中保存的入口点不同。因此，如果转储载荷并相互依赖地运行它，则无法执行相同的代码。  
标题中设置的入口点是RVA 0x26840：  
该调用会使应用程序进入无限的休眠之中：  
而执行恶意软件的真正入口点是0x25386，此入口点仅加载器知晓。  
原始的Kronos（2a550956263a22991c34f076f3160b49）也使用了隐藏入口点这种技巧，Kronos最终的载荷被注入进了svchost。通过修补svchost的入口点将执行重定向到核心部分：  
在这种情况下，载荷的入口点为RVA
0x13B90，而载荷头中保存的入口点（d8425578fc2d84513f1f22d3d518e3c3）为0x15002。  
真正的Kronos入口点的代码与Osiris有相似之处，但是并不完全相同：  
## IOC信息
第1阶段（原始样本）  
e7d3181ef643d77bb33fe328d1ea58f512b4f27c8e6ed71935a2e7548f2facc0  
第2阶段（第二阶段装载机）  
40288538ec1b749734cb58f95649bd37509281270225a87597925f606c013f3a  
Osiris（核心病毒）  
d98a9c5b4b655c6d888ab4cf82db276d9132b09934a58491c642edf1662e831e