Proof of Lemma 5.5. Suppose Pâˆ— and V run the CheckMult
protocol with inputs as described in the lemma. Since CheckZeroâ€²
is a variant of CheckZero from Î 
for the larger message
space Z2ğ‘˜+ğ‘  , we can apply Lemma 5.2 again: Hence, a Pâˆ— that tries to
cheat during CheckZeroâ€² is detected by V except with probability
ğœ€cz.
Now assume this does not happen, all the zero checks are correct,
and V accepts. Let ğ‘– be an index of an invalid triple such ğ‘ğ‘– Â·ğ‘ğ‘– (cid:46)ğ‘˜ ğ‘ğ‘–.
Then, P has chosen ğ‘§ğ‘– âˆˆ Zğ‘ ğ‘˜+ğ‘  such that
0 â‰¡ğ‘˜+ğ‘  ğœ‚ Â· ğ‘ğ‘– âˆ’ ğ‘§ğ‘– âˆ’ ğœ€ğ‘– Â· ğ‘ğ‘– â‰¡ğ‘˜+ğ‘  ğœ‚ Â· ğ‘ğ‘– âˆ’ ğ‘§ğ‘– âˆ’ ğœ‚ Â· ğ‘ğ‘– Â· ğ‘ğ‘– + ğ‘¥ğ‘– Â· ğ‘ğ‘–
Z2ğ‘˜
ComZK-a
â‡â‡’
ğ‘§ğ‘– âˆ’ ğ‘¥ğ‘– Â· ğ‘ğ‘– â‰¡ğ‘˜+ğ‘  ğœ‚ Â· (ğ‘ğ‘– âˆ’ ğ‘ğ‘– Â· ğ‘ğ‘–).
Table 6: Conversion tuples that must be checked by Î Conv to
ensure statistical security 2âˆ’ğ‘  and bucket size ğµ = ğ¶.
ğ‘ 
40
40
40
80
ğµ
3
4
5
5
# of conversion tuples
â‰¥1 048 576
â‰¥ 10 322
â‰¥
1024
â‰¥1 048 576
Let ğ‘£ âˆˆ N be maximal such that 2ğ‘£ divides ğ‘ğ‘– âˆ’ ğ‘ğ‘– Â· ğ‘ğ‘–. Since
(ğ‘ğ‘–, ğ‘ğ‘–, ğ‘ğ‘–) is an invalid triple modulo 2ğ‘˜, it is ğ‘£  ğ‘£, we have ğ‘˜+ğ‘ âˆ’ğ‘£ > ğ‘ , and the prover would have guessed
all ğ‘  bits of ğœ‚ âˆˆ Zğ‘ ğ‘  which happens only with probability 2âˆ’ğ‘ .
Therefore, by the union bound, Pâˆ— can make V output (success)
with probability at most ğœ€cz + 2âˆ’ğ‘ .
â–¡
F EXPERIMENTAL RESULTS
We benchmarked our conversion protocol Î Conv from Section 3, as
well as a variant which uses Quicksilver [33] to verify the multipli-
cations in bitADDcarry (instead of faulty multiplication triples). We
run Î Conv to verify ğ‘ = 1024, 10 322, 1 048 576 conversion tuples
yielding bucket sizes of ğµ = ğ¶ = 5, 4, 3 respectively, and measure
the run-time with different network network bandwiths (20 Mbit/s,
50 Mbit/s, 100 Mbit/s, 500 Mbit/s, and 1 Gbit/s).
Tables 7 and 8 show the measured communication and run-
times for our main protocol. Little to no difference is generally seen
between 500 Mbit/s and 1 Gbit/s, showing that the protocol has a
bottleneck regarding local computation (however tiny this may be).
Tables 9 and 10 show the measured communication and run-
times for the variant with QuickSilver [33]. Compared to our main
protocol, we see a reduction in not only communication, but also
the overall running time of the protocol, as both are roughly cut in
half. We estimate that this overall gain in efficiency comes from no
longer requiring multiplication triples to verify the multiplications,
leading to reduced communication and fewer preprocessed COTs.
Even if the multiplication triples may be faulty such that for a triple
(ğ‘¥, ğ‘¦, ğ‘§) it may not be true that ğ‘¥ Â·ğ‘¦ = ğ‘§, they still require additional
communication and COTs when used to verify the bitADDcarry
circuits, compared with QuickSilver.
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea210Table 7: The data transferred in Mbit by the prover P and the
verifier V when verifying ğ‘ conversion tuples of bit size ğ‘š
with bucket size ğµ = ğ¶, using our protocol from Section 3.
Table 9: The data transferred in Mbit by the prover P and
the verifier V when verifying ğ‘ conversion tuples of bit size
ğ‘š with bucket size ğµ = ğ¶ using QuickSilver [33] to verify
multiplications.
ğ‘š = 8
ğ‘š = 16
V
P
ğ‘š = 32
V
P
ğ‘š = 60
V
P
P
19.65
0.04
19.65
0.01
19.65
0.02
104.65
2.45
105.24
19.24
104.65
4.09
104.65
7.38
104.65
13.13
V
ğ‘ = 1024, ğµ = ğ¶ = 5
19.65
Init
0.10
Conv
ğ‘ = 10 322, ğµ = ğ¶ = 4
19.65
Init
0.10
Conv
ğ‘ = 1 048 576, ğµ = ğ¶ = 3
171.69
Init
Conv 1488.70
Table 8: Run-time in s when verifying ğ‘ conversion tuples
of bit size ğ‘š with bucket size ğµ = ğ¶ using our protocol from
Section 3.
19.65
32.98
57.77 2522.08 111.09 4591.06 222.17
105.24
107.37
105.24
58.89
105.24
32.46
19.65
0.02
19.65
0.01
19.65
4.48
178.38
173.92
24.09
20 Mbit/s
8
32
16
Init
Conv
Init
Conv
Init
Conv
Init
Conv
ğ‘š
ğ‘ = 1024, ğµ = ğ¶ = 5
13.6
0.6
13.6
1.2
13.6
2.0
13.6
4.2
60
ğ‘ = 10 322, ğµ = ğ¶ = 4
13.8
1.3
13.7
2.5
13.7
4.9
13.7
9.8
Init
Conv
Init
Conv
Init
Conv
Init
Conv
16
32
8
60
ğ‘ = 1 048 576, ğµ = ğ¶ = 3
8
16
32
Init
Conv
Init
Conv
Init
Conv
17.4
120.3
19.2
209.8
22.6
399.2
50 Mbit/s
100 Mbit/s
500 Mbit/s
1 Gbit/s
9.7
0.6
10.3
1.1
9.8
2.0
9.8
3.0
9.8
0.8
9.7
1.6
9.8
2.3
9.7
7.3
11.5
68.8
13.7
123.6
16.4
241.0
8.5
0.7
8.4
1.0
8.5
2.3
8.5
2.9
8.5
0.8
8.6
1.4
8.6
2.6
8.5
6.5
7.3
0.5
7.4
0.9
7.3
1.9
7.4
4.1
7.4
0.8
7.4
1.4
7.4
2.7
7.5