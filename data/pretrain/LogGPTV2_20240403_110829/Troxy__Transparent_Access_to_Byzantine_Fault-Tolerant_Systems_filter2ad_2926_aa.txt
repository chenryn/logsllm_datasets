title:Troxy: Transparent Access to Byzantine Fault-Tolerant Systems
author:Bijun Li and
Nico Weichbrodt and
Johannes Behl and
Pierre-Louis Aublin and
Tobias Distler and
R&quot;udiger Kapitza
2018 48th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
Troxy: Transparent Access to
Byzantine Fault-Tolerant Systems
Bijun Li1, Nico Weichbrodt1, Johannes Behl1, Pierre-Louis Aublin2, Tobias Distler3, and R¨udiger Kapitza1
1TU Braunschweig 2Imperial College London 3Friedrich-Alexander-Universit¨at Erlangen-N¨urnberg (FAU)
Abstract—Various protocols and architectures have been pro-
posed to make Byzantine fault tolerance (BFT) increasingly
practical. However, the deployment of such systems requires
dedicated client-side functionality. This is necessary as clients
have to connect to multiple replicas and perform majority voting
over the received replies to outvote faulty responses. Deploying
custom client-side code is cumbersome, and often not an option,
especially in open heterogeneous systems and for well-established
protocols (e.g., HTTP and IMAP) where diverse client-side
implementations co-exist.
We propose Troxy, a system which relocates the BFT-speciﬁc
client-side functionality to the server side, thereby making BFT
transparent to legacy clients. To achieve this, Troxy relies on a
trusted subsystem built upon hardware protection enabled by
Intel SGX. Additionally, Troxy reduces the replication cost of
BFT for read-heavy workloads by offering an actively maintained
cache that supports trustworthy read operations while preserv-
ing the consistency guarantees offered by the underlying BFT
protocol. A prototype of Troxy has been built and evaluated,
and results indicate that using Troxy (1) leads to at most 43%
performance loss with small ordered messages in a local network
environment, while (2) improves throughput by 130% with read-
heavy workloads in a simulated wide-area network.
I. INTRODUCTION
If high availability and resilience to arbitrary faults for
networked services is required, Byzantine fault-tolerant state
machine replication offers a solution. While initially Byzantine
fault tolerance (BFT) was considered impractical, the seminal
work of Castro and Liskov [1] enabled a stream of research
that improved the performance, lowered the complexity, and
reduced the resource usage of BFT [2], [3], [4], [5], [6].
Today, BFT can be considered as ready for custom deployments
and, for example,
is currently evaluated in the scope of
permissioned blockchain infrastructures [7]. However, when
it comes to user-facing offerings in open and heterogeneous
environments – such as the Internet – BFT faces a major, so far
largely overlooked hurdle: the client side. Here, standardized
protocols such as HTTP and IMAP are dominant and users
typically utilize diverse implementations. Thus, offering for
example a BFT-enabled web server is infeasible as Byzantine
fault tolerance is based on the assumption that a client contacts
multiple replicas and performs a majority voting over the
received replies to prevent the processing of faulty replies. Of
course, by means of extending the HTTP protocol and adding
Acknowledgments: The authors thank the anonymous reviewers for their
valuable feedback. This research was supported by the German Research Coun-
cil (DFG) under grant no. KA 3171/1-2 and DI 2097/1-2 (“REFIT”). Funding
was received from the EU’s Horizon 2020 research and innovation programme
under grant agreements 645011 (SERECA) and 690111 (SecureCloud).
custom software to browsers [8] one could consider the use of
BFT, but this would address only one of many standardized
protocols. Instead of this more or less unrealistic endeavor,
we propose to deploy BFT in a client-transparent fashion for
different kinds of protocols.
In this paper we present Troxy, a system which achieves
client-transparent BFT by relocating traditional client-side BFT
functionality such as connection handling, request distribution,
and majority voting to the server side, co-located to the replicas.
This is enabled by relying on a trusted subsystem that can
only fail by crashing and implements basic message handling,
majority voting, and transport encryption:
the Troxy. At
implementation level, Troxy utilizes trusted execution support
as offered by Intel’s Software Guard Extensions (SGX) [9], [10].
At its core, SGX provides a set of new instructions that allows
user-level code to allocate private and secure regions of memory
called enclaves. By executing the application’s code within
enclaves, SGX provides CPU-enhanced application security
and protects the enclaves from being manipulated by malicious
privileged code or even hardware attacks such as memory
probes. Hence, the functionality of Troxy is guaranteed to be
trustworthy even in the presence of Byzantine faults in the
surrounding replicas.
Based on trusted execution, Troxy offers a trusted proxy to
clients that can be accessed via the original legacy protocol.
Once a Troxy instance receives a client request, it forwards
the request to the BFT framework, which in turn orders the
request, executes it, and forwards the computed replies to the
requesting Troxy. As soon as the responsible Troxy instance
has received enough replies, it performs a voting over the
replies and returns the correct result to the client.
As a malicious replica may intercept the communication of
its Troxy, we ensure that the replica cannot alter messages with-
out being detected: Communication between clients and Troxy
instances is protected via secure, encrypted connections, which
are the norm for more and more Internet-based services [11]. In
addition, messages exchanged between Troxies and replicas are
authenticated using common message certiﬁcates, as they are
prevalent for BFT. Although immune to arbitrary or malicious
behaviors, it is still possible that a Troxy instance crashes or is
disconnected from its clients, and as a consequence becomes
unavailable. This case is equivalent to a failing service replica in
commodity infrastructures and can be handled by DNS round-
robin or load-balancing appliances that enable a fail-over to
another Troxy instance.
2158-3927/18/$31.00 ©2018 IEEE
DOI 10.1109/DSN.2018.00019
59
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:31:39 UTC from IEEE Xplore.  Restrictions apply. 
Troxy is speciﬁcally designed for user-facing Internet-based
services and therefore offers tailored support for read-heavy
workloads and distant clients. In particular, this is achieved
by enabling caching for Troxy instances. To not reduce the
consistency guarantees of state machine replication, Troxy
ensures linearizability [12] by offering a managed cache. In the
context of ordering write requests, a quorum of Troxy caches
is consulted and the affected data is invalidated. This way,
cached read requests can be directly answered by consulting
a quorum of f + 1 Troxy instances. Otherwise, requests are
ordered via the regular BFT protocol.
We implemented Troxy on top of Hybster [13], a hybrid
BFT system that already features a trusted subsystem to reduce
the number of replicas to 2f + 1. However, Troxy builds an
independent extension that can be applied to other hybrid
systems featuring a trusted subsystem [14], [15] as well as
traditional BFT agreement protocols.
This paper makes the following contributions:
• It introduces the concept of making BFT systems transpar-
ent to clients by utilizing trusted hardware to implement
a substitute of the client-side BFT library on the server
side (Section II).
• It presents Troxy, which uses Intel SGX to provide
transparent access to a BFT system while ensuring its
integrity and security (Section III).
• It introduces a fast managed cache for read-heavy work-
loads that transparently switches to traditional request
ordering in case of write contention (Section IV).
• It implements a prototype of Troxy that is fully transparent
to clients, secure, and provides the read-cache optimization
without sacriﬁcing linearizability (Section V).
In addition, Section VI presents detailed evaluation results
for Troxy gained from experiments with both microbenchmarks
as well as a web server. Finally, Section VII summarizes related
work and Section VIII concludes the paper.
II. BACKGROUND AND PROBLEM STATEMENT
In this section, we provide background on how the roles
of clients differ between non-fault-tolerant and crash-tolerant
systems on the one side, which currently constitute the vast
majority of systems used in production, and BFT systems on
the other side, which in recent years have been widely studied
and are now ready to be applied in practice. Based on this
comparison, we then discuss the implications of moving from
existing system architectures to BFT replication from a client-
implementation perspective, thereby explaining the inherent
difﬁculties that so far prevented the migration to BFT for many
real-world use-case scenarios. Finally, we outline our approach
to address these problems with Troxy by introducing a trusted
proxy component at the server side that allows legacy client
implementations to remain unchanged.
A. Clients in Different System Architectures
The means necessary for a client to access a network-based
service in general depend on how the service is implemented at
the server side. As illustrated in Figure 1a, in the most simple
60
Location
Location
Location
Client
Client
Protocol
Protocol
Client
Client
Protocol
Protocol
Voter
Client
Protocol
Voter
Server
Replica
Replica
Replica
Replica
Replica
Replica
(a) Unreplic.
(b) Crash-tolerant replication
(c) BFT replication
Replication protocol
Replication protocol
Fig. 1. Differences in client perspectives: While the client of an unreplicated
or crash-tolerant system usually only interacts with a single server/replica, a
BFT client communicates with all replicas in the system.
case of a non-fault-tolerant system containing only a single
server, a client ﬁrst queries a location service (e.g., DNS)
to obtain the server’s address and then directly establishes
a connection to the server. Using this connection, both
sides then subsequently interact with each other based on
a speciﬁc protocol, for example, HTTP for a web service.
Many services rely on secure channels to protect the client-
server communication. These channels, such as TLS, handle
authentication and encryption/decryption of the exchanged data.
In systems where the server side is replicated to provide re-
silience against crashes, each client usually also only maintains
a connection to a single server at a time (see Figure 1b). To
prevent bottlenecks, such systems typically ensure that client
connections are distributed across the different servers available.
One way to achieve this in a transparent manner for the client
is, for example, to introduce a load balancer [16], possibly
integrated with the location service. Such a mechanism also
ensures that in the event of a replica crash the affected clients
are automatically reassigned to other replicas once they try to
reconnect to the service.
In contrast to clients in unreplicated or crash-tolerant systems,
clients in BFT systems not only need to implement
the
service’s protocol but also require a voting component for
safely accessing the server side [1], [2], [3], [4], [6], [13]. This
is due to the fact that a BFT client cannot trust a single replica,
because the replica might be faulty and therefore possibly
ignores requests or provides erroneous replies. To address this
issue, as illustrated in Figure 1c, BFT clients do not only
contact a single replica but instead establish connections to all
replicas in the system. As a consequence, they are able to verify
the correctness of a result by comparing the replies of different
replicas. This means that, although the speciﬁc communication
patterns of clients and replicas vary between BFT systems, in
general a BFT client requires knowledge about the identity of
replicas in order to be able to distinguish their replies. Usually,
such information is provided to the client at conﬁguration
time. Many BFT systems exploit this knowledge to establish a
dedicated shared secret between each client and each replica,
which is then used to authenticate the exchanged messages and
therefore, amongst other things, allows a client to verify that a
received reply indeed originates from the presumed replica.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:31:39 UTC from IEEE Xplore.  Restrictions apply. 
B. Problem Statement
Most of the systems and services in production today are
either unable to tolerate faults or are only resilient against
crashes, resulting in outages or unwanted behavior in situations
where Byzantine faults actually occur [17], [18], [19]. One
reason for this, despite the recent advances in BFT research, is
the fact that there is a plethora of legacy client implementations
for which migrating to BFT would produce signiﬁcant costs. On
the one hand, this includes the efforts required for modifying
existing client libraries in order to allow them to tolerate
Byzantine faults; even worse, in many cases the necessary
changes are not limited to the client itself because, as discussed
in Section II-A, BFT clients have to be aware of both the
identity as well as the number of replicas, and providing this
information to clients is usually not straightforward if the
overall system has not been designed to publicly reveal such
knowledge. On the other hand, migrating to BFT also comes
with an increased network and processor usage at runtime
due to the client’s need to receive, authenticate, and compare
multiple replies for each operation. Such an increase in resource
usage especially poses a problem to clients with low-bandwidth
connections or limited processing power. This, for example,
includes clients running on mobile devices. To summarize,
making existing client implementations ready for BFT does
not only lead to costs for the actual migration, but also results
in runtime overhead, which explains why this step so far has
not been taken for many real-world systems.
C. The Troxy Approach
To circumvent the previously described problems associated
with adding and operating BFT mechanisms at the client side,
our approach is to introduce a trusted proxy, or Troxy for
short, into the system that acts as a representative of the client
at the server side and allows legacy client implementations
to beneﬁt from Byzantine fault tolerance without requiring
modiﬁcations. Furthermore, due to the fact that the Troxy is
transparent to the client and handles all BFT-related tasks such
as reply authentication and voting, this solution does not incur
additional network or processor usage at the client.
As shown in Figure 2, the unmodiﬁed client in a Troxy-
backed system only establishes a connection to a single Troxy
instance, which then handles the communication with the
replicas in the system for all of its clients. If at one point a Troxy
instance fails, the affected clients reestablish their connections
to the service as they would do in a traditional system, for
example using a location service (see Section II-A), thereby
switching to different Troxies. In contrast to all other replica
components, which are untrusted and may fail in arbitrary
ways, Troxies are trusted and assumed to only fail by crashing.
To justify this trust, we run each Troxy inside the trusted
subsystem that is provided by modern processors based on
technologies such as Intel SGX [9], which guarantees the
integrity of the executed program code. In addition, to protect
the communication of a client with the service, a Troxy supports
the establishment of secure channels using TLS.
Client
Protocol
Location
Requests & replies
Troxy
Replica
Troxy
Replica
Client
Protocol
Troxy
Replica
Replication protocol
Fig. 2. Architecture of a Troxy-backed BFT system.
In summary, by offering clients transparent access to
BFT systems, our approach greatly facilitates the migration of
existing services to Byzantine fault tolerance, because legacy
client implementations can be reused without modiﬁcations or
additional resource overhead. At the same time Troxy requires
only moderate integration effort into the underlying BFT system
at speciﬁc extension points.
III. TROXY SYSTEM DESIGN
In this section, we present details on the design of a Troxy-
backed BFT system in general and on the trusted proxy in
particular. For clarity, we postpone the discussion of the fast-
read optimization to Section IV.
A. Overview
Figure 3 shows an overview of the different components of
a Troxy and illustrates how they conceptually interact with
each other and with other system components outside the
Troxy. When a client issues a request to the service through
a secure channel, the Troxy ﬁrst decrypts the message ( 1 ).
For a read request, the Troxy then executes the fast path for
reads ( 2 ) and in case of success immediately returns the
cached reply (see Section IV). For a write request or in case
of a read-cache miss, the Troxy forwards the client request
to its local replication logic to invoke the BFT agreement
protocol ( 3 ), thereby itself assuming the role of a BFT client.
Having received the request, the BFT protocol distributes the
request to the other replicas in the system and ensures that
all correct replicas execute all client requests in the same
order. After processing the request, each replica returns the
corresponding reply to the replica the client is connected
to, where the Troxy’s voting component then determines the
correct result by comparing the replies of different replicas ( 4 ).
To tolerate f faults, the voter waits until having obtained
f + 1 matching replies from different replicas before returning
the result to the client ( 5 ) as this guarantees that at least
one of the replies stems from a non-faulty replica and is
therefore correct. In summary, by acting as a BFT client for the
replication protocol a Troxy already assumes all the additional
responsibilities necessary to access a BFT service, freeing the
client from the need to perform these tasks itself.
B. System Model
The Troxy approach relies on a hybrid fault model [13], [14],
[15], [20], [21], [22], [23] in which a system is a collection
of components with different resilience characteristics. All
Troxies in the system are assumed to either operate correctly
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:31:39 UTC from IEEE Xplore.  Restrictions apply. 
61
1
5
Secure Channel
Endpoint
2
Read Cache
Voter
4
Troxy
3
Secure Channel
Endpoint
Secure Channel
Endpoint
Read Cache
Read Cache
Voter
Troxy
Voter
Troxy
Replication
Replication