)
      +0x004 Vector       : 0x70
      +0x008 Irql         : 0x7 ''
      +0x00c Polarity     : 1 ( InterruptActiveHigh )
      +0x010 Mode         : 1 ( Latched )
      +0x018 TargetProcessors : 
         +0x000 Mask         : 0xff
         +0x008 Group        : 0
         +0x00a Reserved     : [3] 0
      +0x028 IntRemapInfo :
         +0x000 IrtIndex     : 
0y000000000000000000000000000000 (0)
         +0x000 FlagHalInternal : 0y0
         +0x000 FlagTranslated : 0y0
         +0x004 u            : 
      +0x038 ControllerInput :
         +0x000 Gsiv         : 1
The Type indicates that this is a traditional line/controller-based
input, and the Vector and Irql fields confirm earlier data seen in the
KINTERRUPT already. Next, by looking at the ControllerInput
structure, you can see that the GSIV is 1 (i.e., IRQ 1). If you’d
been looking at a different kind of interrupt, such as a Message
Signaled Interrupt (more on this later), you would dereference the
MessageRequest field instead, for example.
Another way to map GSIV to interrupt vectors is to recall that
Windows keeps track of this translation when managing device
resources through what are called arbiters. For each resource type,
an arbiter maintains the relationship between virtual resource usage
(such as an interrupt vector) and physical resources (such as an
interrupt line). As such, you can query the ACPI IRQ arbiter and
obtain this mapping. Use the !apciirqarb command to obtain
information on the ACPI IRQ arbiter:
Click here to view code image
6: kd> !acpiirqarb
Processor 0 (0, 0):
Device Object: 0000000000000000
Current IDT Allocation:
...
  000000070 - 00000070  D  ffffe50f9959baf0 (i8042prt) 
A:ffffce0717950280 IRQ(GSIV):1
...
Note that the GSIV for the keyboard is IRQ 1, which is a legacy
number from back in the IBM PC/AT days that has persisted to this
day. You can also use !arbiter 4 (4 tells the debugger to display
only IRQ arbiters) to see the specific entry underneath the ACPI
IRQ arbiter:
Click here to view code image
    6: kd> !arbiter 4
    DEVNODE ffffe50f97445c70 (ACPI_HAL\PNP0C08\0)
      Interrupt Arbiter "ACPI_IRQ" at fffff804575415a0
        Allocated ranges:
          0000000000000001 - 0000000000000001       
ffffe50f9959baf0  (i8042prt)
In this case, note that the range represents the GSIV (IRQ), not
the interrupt vector. Further, note that in either output, you are
given the owner of the vector, in the type of a device object (in this
case, 0xFFFFE50F9959BAF0). You can then use the !devobj
command to get information on the i8042prt device in this example
(which corresponds to the PS/2 driver):
Click here to view code image
6: kd> !devobj 0xFFFFE50F9959BAF0
Device object (ffffe50f9959baf0) is for:
 00000049 \Driver\ACPI DriverObject ffffe50f974356f0
Current Irp 00000000 RefCount 1 Type 00000032 Flags 00001040
SecurityDescriptor ffffce0711ebf3e0 DevExt ffffe50f995573f0 
DevObjExt ffffe50f9959bc40
DevNode ffffe50f9959e670
ExtensionFlags (0x00000800)  DOE_DEFAULT_SD_PRESENT
Characteristics (0x00000080)  FILE_AUTOGENERATED_DEVICE_NAME
AttachedDevice (Upper) ffffe50f9dfe9040 \Driver\i8042prt
Device queue is not busy.
The device object is associated to a device node, which stores all
the device’s physical resources. You can now dump these resources
with the !devnode command, and using the 0xF flag to ask for both
raw and translated resource information:
Click here to view code image
6: kd> !devnode ffffe50f9959e670 f
DevNode 0xffffe50f9959e670 for PDO 0xffffe50f9959baf0
  InstancePath is "ACPI\LEN0071\4&36899b7b&0"
  ServiceName is "i8042prt"
  TargetDeviceNotify List - f 0xffffce0717307b20  b 
0xffffce0717307b20
  State = DeviceNodeStarted (0x308)
  Previous State = DeviceNodeEnumerateCompletion (0x30d)
  CmResourceList at 0xffffce0713518330  Version 1.1  
Interface 0xf  Bus #0
    Entry 0 - Port (0x1) Device Exclusive (0x1)
      Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE
      Range starts at 0x60 for 0x1 bytes
    Entry 1 - Port (0x1) Device Exclusive (0x1)
      Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE
      Range starts at 0x64 for 0x1 bytes
    Entry 2 - Interrupt (0x2) Device Exclusive (0x1)
      Flags (LATCHED
      Level 0x1, Vector 0x1, Group 0, Affinity 0xffffffff
...
  TranslatedResourceList at 0xffffce0713517bb0  Version 1.1  
Interface 0xf  Bus #0
    Entry 0 - Port (0x1) Device Exclusive (0x1)
      Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE
      Range starts at 0x60 for 0x1 bytes
    Entry 1 - Port (0x1) Device Exclusive (0x1)
      Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE
      Range starts at 0x64 for 0x1 bytes
    Entry 2 - Interrupt (0x2) Device Exclusive (0x1)
      Flags (LATCHED
      Level 0x7, Vector 0x70, Group 0, Affinity 0xff
The device node tells you that this device has a resource list with
three entries, one of which is an interrupt entry corresponding to
IRQ 1. (The level and vector numbers represent the GSIV rather
than the interrupt vector.) Further down, the translated resource list
now indicates the IRQL as 7 (this is the level number) and the
interrupt vector as 0x70.
On ACPI systems, you can also obtain this information in a
slightly easier way by reading the extended output of the
!acpiirqarb command introduced earlier. As part of its output, it
displays the IRQ to IDT mapping table:
Click here to view code image
Interrupt Controller (Inputs: 0x0-0x77):
    (01)Cur:IDT-70 Ref-1 Boot-0 edg hi    Pos:IDT-00 Ref-0 
Boot-0 lev unk
    (02)Cur:IDT-80 Ref-1 Boot-1 edg hi    Pos:IDT-00 Ref-0 
Boot-1 lev unk
    (08)Cur:IDT-90 Ref-1 Boot-0 edg hi    Pos:IDT-00 Ref-0 
Boot-0 lev unk 
    (09)Cur:IDT-b0 Ref-1 Boot-0 lev hi    Pos:IDT-00 Ref-0 
Boot-0 lev unk
    (0e)Cur:IDT-a0 Ref-1 Boot-0 lev low   Pos:IDT-00 Ref-0 
Boot-0 lev unk
    (10)Cur:IDT-b5 Ref-2 Boot-0 lev low   Pos:IDT-00 Ref-0 
Boot-0 lev unk
    (11)Cur:IDT-a5 Ref-1 Boot-0 lev low   Pos:IDT-00 Ref-0 
Boot-0 lev unk
    (12)Cur:IDT-95 Ref-1 Boot-0 lev low   Pos:IDT-00 Ref-0 
Boot-0 lev unk
    (14)Cur:IDT-64 Ref-2 Boot-0 lev low   Pos:IDT-00 Ref-0 
Boot-0 lev unk
    (17)Cur:IDT-54 Ref-1 Boot-0 lev low   Pos:IDT-00 Ref-0 
Boot-0 lev unk
    (1f)Cur:IDT-a6 Ref-1 Boot-0 lev low   Pos:IDT-00 Ref-0 
Boot-0 lev unk
    (41)Cur:IDT-96 Ref-1 Boot-0 edg hi    Pos:IDT-00 Ref-0 
Boot-0 lev unk
As expected, IRQ 1 is associated with IDT entry 0x70. For more
information on device objects, resources, and other related
concepts, see Chapter 6 in Part 1.
Line-based versus message signaled–based
interrupts
Shared interrupts are often the cause of high interrupt latency and can also
cause stability issues. They are typically undesirable and a side effect of the
limited number of physical interrupt lines on a computer. For example, in the
case of a 4-in-1 media card reader that can handle USB, Compact Flash, Sony
Memory Stick, Secure Digital, and other formats, all the controllers that are
part of the same physical device would typically be connected to a single
interrupt line, which is then configured by the different device drivers as a
shared interrupt vector. This adds latency as each one is called in a sequence
to determine the actual controller that is sending the interrupt for the media
device.
A much better solution is for each device controller to have its own
interrupt and for one driver to manage the different interrupts, knowing
which device they came from. However, consuming four traditional IRQ
lines for a single device quickly leads to IRQ line exhaustion. Additionally,
PCI devices are each connected to only one IRQ line anyway, so the media
card reader cannot use more than one IRQ in the first place even if it wanted
to.
Other problems with generating interrupts through an IRQ line is that
incorrect management of the IRQ signal can lead to interrupt storms or other
kinds of deadlocks on the machine because the signal is driven “high” or
“low” until the ISR acknowledges it. (Furthermore, the interrupt controller
must typically receive an EOI signal as well.) If either of these does not
happen due to a bug, the system can end up in an interrupt state forever,
further interrupts could be masked away, or both. Finally, line-based
interrupts provide poor scalability in multiprocessor environments. In many
cases, the hardware has the final decision as to which processor will be
interrupted out of the possible set that the Plug and Play manager selected for
this interrupt, and device drivers can do little about it.
A solution to all these problems was first introduced in the PCI 2.2
standard called message-signaled interrupts (MSI). Although it was an
optional component of the standard that was seldom found in client machines
(and mostly found on servers for network card and storage controller
performance), most modern systems, thanks to PCI Express 3.0 and later,
fully embrace this model. In the MSI world, a device delivers a message to
its driver by writing to a specific memory address over the PCI bus; in fact,
this is essentially treated like a Direct Memory Access (DMA) operation as
far as hardware is concerned. This action causes an interrupt, and Windows
then calls the ISR with the message content (value) and the address where the
message was delivered. A device can also deliver multiple messages (up to
32) to the memory address, delivering different payloads based on the event.
For even more performance and latency-sensitive systems, MSI-X, an
extension to the MSI model, which is introduced in PCI 3.0, adds support for
32-bit messages (instead of 16-bit), a maximum of 2048 different messages
(instead of just 32), and more importantly, the ability to use a different
address (which can be dynamically determined) for each of the MSI
payloads. Using a different address allows the MSI payload to be written to a
different physical address range that belongs to a different processor, or a
different set of target processors, effectively enabling nonuniform memory
access (NUMA)-aware interrupt delivery by sending the interrupt to the
processor that initiated the related device request. This improves latency and
scalability by monitoring both load and the closest NUMA node during
interrupt completion.
In either model, because communication is based across a memory value,
and because the content is delivered with the interrupt, the need for IRQ lines
is removed (making the total system limit of MSIs equal to the number of
interrupt vectors, not IRQ lines), as is the need for a driver ISR to query the
device for data related to the interrupt, decreasing latency. Due to the large
number of device interrupts available through this model, this effectively
nullifies any benefit of sharing interrupts, decreasing latency further by
directly delivering the interrupt data to the concerned ISR.
This is also one of the reasons why you’ve seen this text, as well as most
of the debugger commands, utilize the term “GSIV” instead of IRQ because
it more generically describes an MSI vector (which is identified by a negative
number), a traditional IRQ-based line, or even a General Purpose Input
Output (GPIO) pin on an embedded device. And, additionally, on ARM and
ARM64 systems, neither of these models are used, and a Generic Interrupt
Controller, or GIC, architecture is leveraged instead. In Figure 8-16, you can
see the Device Manager on two computer systems showing both traditional
IRQ-based GSIV assignments, as well as MSI values, which are negative.
Figure 8-16 IRQ and MSI-based GSIV assignment.
Interrupt steering
On client (that is, excluding Server SKUs) systems that are not running
virtualized, and which have between 2 and 16 processors in a single
processor group, Windows enables a piece of functionality called interrupt
steering to help with power and latency needs on modern consumer systems.
Thanks to this feature, interrupt load can be spread across processors as
needed to avoid bottlenecking a single CPU, and the core parking engine,
which was described in Chapter 6 of Part 1, can also steer interrupts away
from parked cores to avoid interrupt distribution from keeping too many
processors awake at the same time.
Interrupt steering capabilities are dependent on interrupt controllers— for
example, on ARM systems with a GIC, both level sensitive and edge
(latched) triggered interrupts can be steered, whereas on APIC systems
(unless running under Hyper-V), only level-sensitive interrupts can be
steered. Unfortunately, because MSIs are always level edge-triggered, this
would reduce the benefits of the technology, which is why Windows also
implements an additional interrupt redirection model to handle these
situations.
When steering is enabled, the interrupt controller is simply reprogrammed
to deliver the GSIV to a different processor’s LAPIC (or equivalent in the
ARM GIC world). When redirection must be used, then all processors are
delivery targets for the GSIV, and whichever processor received the interrupt
manually issues an IPI to the target processor to which the interrupt should
be steered toward.
Outside of the core parking engine’s use of interrupt steering, Windows
also exposes the functionality through a system information class that is
handled by KeIntSteerAssignCpuSetForGsiv as part of the Real-Time Audio
capabilities of Windows 10 and the CPU Set feature that was described in the
“Thread scheduling” section in Chapter 4 of Part 1. This allows a particular
GSIV to be steered to a specific group of processors that can be chosen by
the user-mode application, as long as it has the Increase Base Priority
privilege, which is normally only granted to administrators or local service
accounts.
Interrupt affinity and priority
Windows enables driver developers and administrators to somewhat control
the processor affinity (selecting the processor or group of processors that
receives the interrupt) and affinity policy (selecting how processors will be
chosen and which processors in a group will be chosen). Furthermore, it
enables a primitive mechanism of interrupt prioritization based on IRQL
selection. Affinity policy is defined according to Table 8-5, and it’s
configurable through a registry value called InterruptPolicyValue in the
Interrupt Management\Affinity Policy key under the device’s instance key in
the registry. Because of this, it does not require any code to configure—an
administrator can add this value to a given driver’s key to influence its
behavior. Interrupt affinity is documented on Microsoft Docs at
https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/interrupt-
affinity-and-priority.
Table 8-5 IRQ affinity policies
Policy
Meaning
IrqPolicy
MachineD
efault
The device does not require a particular affinity policy. 
Windows uses the default machine policy, which (for 
machines with less than eight logical processors) is to 
select any available processor on the machine.
IrqPolicy
AllCloseP
rocessors
On a NUMA machine, the Plug and Play manager assigns 
the interrupt to all the processors that are close to the 
device (on the same node). On non-NUMA machines, this 
is the same as IrqPolicyAllProcessorsInMachine.
IrqPolicy
OneClose
Processor
On a NUMA machine, the Plug and Play manager assigns 
the interrupt to one processor that is close to the device (on 
the same node). On non-NUMA machines, the chosen 
processor will be any available processor on the system.
IrqPolicy
AllProces
sorsInMa
chine
The interrupt is processed by any available processor on 
the machine.
IrqPolicy
Specified
Processor
s
The interrupt is processed only by one of the processors 
specified in the affinity mask under the 
AssignmentSetOverride registry value.
IrqPolicy
SpreadMe
ssagesAcr
ossAllPro
cessors
Different message-signaled interrupts are distributed across 
an optimal set of eligible processors, keeping track of 
NUMA topology issues, if possible. This requires MSI-X 
support on the device and platform.
IrqPolicy
AllProces
sorsInGro
upWhenSt
eered
The interrupt is subject to interrupt steering, and as such, 
the interrupt should be assigned to all processor IDTs as 
the target processor will be dynamically selected based on 
steering rules.
Other than setting this affinity policy, another registry value can also be
used to set the interrupt’s priority, based on the values in Table 8-6.
Table 8-6 IRQ priorities
Priority
Meaning
IrqPriorit
yUndefin
ed
No particular priority is required by the device. It receives 
the default priority (IrqPriorityNormal).
IrqPriorit
yLow
The device can tolerate high latency and should receive a 
lower IRQL than usual (3 or 4).
IrqPriorit
yNormal
The device expects average latency. It receives the default 
IRQL associated with its interrupt vector (5 to 11).
IrqPriorit
yHigh
The device requires as little latency as possible. It receives 
an elevated IRQL beyond its normal assignment (12).
As discussed earlier, it is important to note that Windows is not a real-time
operating system, and as such, these IRQ priorities are hints given to the
system that control only the IRQL associated with the interrupt and provide
no extra priority other than the Windows IRQL priority-scheme mechanism.
Because the IRQ priority is also stored in the registry, administrators are free
to set these values for drivers should there be a requirement of lower latency
for a driver not taking advantage of this feature.
Software interrupts
Although hardware generates most interrupts, the Windows kernel also
generates software interrupts for a variety of tasks, including these:
■    Initiating thread dispatching
■    Non-time-critical interrupt processing
■    Handling timer expiration
■    Asynchronously executing a procedure in the context of a particular
thread
■    Supporting asynchronous I/O operations
These tasks are described in the following subsections.
Dispatch or deferred procedure call (DPC) interrupts
A DPC is typically an interrupt-related function that performs a processing
task after all device interrupts have already been handled. The functions are