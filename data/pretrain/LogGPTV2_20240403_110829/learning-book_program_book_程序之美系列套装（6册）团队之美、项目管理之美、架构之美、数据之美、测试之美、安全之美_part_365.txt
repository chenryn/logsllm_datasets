2079
---
## Page 2081
Stringcontents=in.readLineO;
in.closeO;
assertEquals("aString",contents);
最基本的变异测试就是在程序中植入大量人为的漏洞，并逐个对它
们进行测试，看哪些变异没有被检测出来。然后系统化地改进整个
测试集，直到所有的变异都能被检测出来。这个简单的方法有很多
好处。首先，通过它你可以评估整个测试集的质量而不仅仅是那些
被测试用例执行到的功能。其次，对于那些高风险的模块（所谓的
高风险的模块，指的是如果在这些模块中有缺陷，则会导致相当严
重的后果）在变异后也会表现出相同严重的后果，当然，如果测试
集不能发现这些，那表示你需要改进测试集。最后，如果变异越接
近真正的缺陷，那你也就更容易可以重现出程序中漏洞的分布情
况。变异测试能解决上述所有的问题。显然，作为衡量测试集质量
的一个标准，变异测试可以很好地涵盖现有的所有标准。一些变异
测试的框架，如针对FORTRAN语言的Mothra及针对Java语言的uJava
现在都可以免费得到。
既然变异测试如此之好，那为什么不是所有人都在使用它呢？在过
去的几年中，我们尝试了很多开源的变异测试的软件，我们得出的
结论是：虽然变异测试的基本概念非常简单，但是在具体的实践操
作中却并不是那么容易的。其中有许多难题需要去解决。不过好消
息是在这里我们会设法去解决所有的这些问题。
高效的变异测试
首先也是最明显的问题是变异测试非常耗时。在每一次变异之后，
整个程序都需要重新编译并再测试一次。很多情况下，我们会有上
千次的变异操作，那样我们就需要几千次的重新编译并执行整个测
试集。显然，变异测试必须被完全自动化，而且必须执行得很快。
另外从植入变异的角度，我们也有一些技巧来提高效率。
直接操作二进制代码
2080
---
## Page 2082
通过直接操作二进制代码而不是源代码，我们可以省去每次变异操
作后重新编译的时间。不过这么做的缺点是二进制代码非常难读
尤其是如果要进行一些复杂的变异操作的时候（我们会在下一节进
行详细的介绍）。
使用变异模板
传统上，变异测试框架会为每一组变异生成一个程序的版本。但是
我们也可以用同一个程序而通过控制运行时的条件来生成不同的变
异版本。
跳过测试集中没有涉及的代码
变异的代码只有被执行到，才会对程序的状态产生影响。因此，我
们在实际的操作中，可以只对测试集中涉及的代码进行变异，并且
只运行那些涉及变异代码的测试用例。只要把整个测试集执行一
次，我们就可以得到所需的代码覆盖信息。
所有的这些优化方式都可以帮助我们进行高效的变异测试。下一步
只要保持变异的数目即可。
选择变异操作
接下来的问题是：我们怎么来对程序进行变异呢？我们可以有无数
种方法来对程序来进行变异：改变常量的值，用常量来替代变量，
用变量来替换数组的引用，改变操作符，改变调用的方法（或者不
同类的方法），将某一条件置反等。但是通过研究发现，在如此多
的变异操作中，只需要其中一个很小的子集，就可以达到类似的效
果。
改变数字常量
对于常量X，尝试用X+1、X-1和0来替换X。对于指针也可以采用相
同的变异操作（指针的0表示mull）。
跳转条件取反
将分支判断条件c取反成为非c（-c）。
改变数字操作符
2081
---
## Page 2083
改变数字操作符，如把+改成-，*改成/，>等。
省略方法调用
将一个方法调用直接改为0。如果该方法不需要返回值，则可以直接
删除。
这些简单的变异操作可以很简单地在二进制代码上直接实现，并且
得到的只是很小的一个变异集合。我们在下面的实验中所用的就是
这些筛选过后的变异操作。
AspectJ的实验
作为实验，我们将这些变异操作应用到了一个中等规模的程序中
-AspectU的核心模块中。AspectI的核心模块是一个100000行代码
的Java包，它有321个单元测试，一次完整的执行需要21秒。根据前
面提到的要点，我们得到了47000个变异操作。估计共需要14个CPU
小时，如果在一个单核的机器上运行，那么就需要整整14个小时，
而如果是一台8核的机器，则可能只需要不到2个小时（如果你使用
的是更强大的机器，则可能只需要更短的时间）。
整个AspectU的单元测试集只能发现53%的变异。一些未检测出的变
异可能真的是程序的漏洞。例如，考虑AjProblemReporter类的
staticAndInstanceConflictO方法（例18-3），这个方法用来判断是否需
要报错，如果需要，则向它的父类报错。我们在实验中对此进行变
异操作，阻止super.staticAndInstanceConflictO的调用，也就阻止了报
告这个错误。
例18-3：阻正一个方法调用（AspectU的测试集不能发现这个变异）
public void staticAndInstanceConflict(MethodBinding
currentMethod,MethodBindinginheritedMethod)
if(currentMethodinstanceof InterTypeMethodBinding)
return;
if(inheritedMethodinstanceofInterTypeMethodBinding)
2082
---
## Page 2084
return;
super.staticAndInstanceConflict(currentMethod,
inheritedMethod);//Mutation:suppress this method call
遗憾的是，Aspectu的测试集并不能检测出这个变异。虽然测试集检
查了编译器是否对输入进行了有效性的检查，但是却没有检查在输
入出错的情况下，编译器是否生成了正确的错误报告。这并不是说
程序的错误报告有缺陷，但是如果程序的错误报告有缺陷，则测试
集无法发现它们。山]
[1]既然有这么多变异无法被检测到，那是不是表示在AspectU中很可
能有很多缺陷呢？答案是不一定。在实验中，我们只评估了单元测
试。在单元测试中，它们没有对一些条件进行检测。但是Aspectu还
包含一组系统测试集，在单元测试中未发现的问题，也可能在系统
测试中被发现。
等价变异
一旦我们发现测试集中无法检测出的一个变异，我们就需要增加一
个测试用例。但有时候，我们根本就做不到这一点，因为这个变异
操作根本就对程序没有造成任何的影响。这就是所谓的等价变异，
如例18-4所示。
例18-4：将+1改成+2，没有任何区别
public int compareTo(Object other)
if(!(other instanceof BcelAdvice))
return O;
BcelAdvice o=(BcelAdvice)other;
if(kind.getPrecedence()!=o.kind.getPrecedenceO)
2083
---
## Page 2085
if(kind.getPrecedence() >o.kind.getPrecedenceO)
return+1;/Mutation:replace+1with+2
else
return-1;
/More comparisons...
..
在Java中，compareToO方法将目标与另一个对象进行比较，根据大
于、小于或者等于这个对象，compareToO方法返回一个正数、负数
或者0。所有对compareToO方法的调用，最后都只检查返回值的符
号，当然也包括测试用例。通过变异操作将返回值从+1改成+2，对
整个程序完全没有影响。
（当然，我们可以改变测试用例，去判断它的返回值是不是+1，这
样就可以检测出这个变异，但是测试用例的这一改变对我们整个测
试集的质量毫无改进。）
问题在于，等价变异并非十分罕见，在我们针对JaxenXPath引擎做
的实验中，我们发现在所有未检测到的变异中，等价变异占了
40%。但是它们却对改进我们的测试集却毫无帮助。要判断一个变
异是否是等价变异，一般来说是一个很不确定的问题，因此只能通
过手工来操作，而且这还是一件非常耗时的事，通常对于任何一个
变异，你都要花上几分钟到几个小时的时间。
当然，在测试的时候花几个小时，最终却发现根本无法写出一个测
试用例也并不是完全不正常。当某测试人员想提高代码覆盖率，他
可能花了几个小时，却发现某些条件根本不可能达到。这些无用代
码当然也是缺陷，发现无用代码也算是有价值的回报。但是，等价
变异却纯粹是浪费时间。
更严重的是，随着测试集的改进，等价变异所占的比例将越来越
高。假设在Aspectu的实验中，所有未检测出的变异22000个中有
20%，也就是4400个是等价变异。无论我们怎么改进我们的测试
2084
---
## Page 2086
集，这些等价变异仍然无法被检测出。那么如果改进后的测试集可
以发现那17600个非等价的变异，结果将是还剩4400个变异未被检
测出，其中100%全部为等价变异。
侧重于影响
在实验中，我们发现了上千个未被检测出来的变异，令我们惊讶的
是其中有相当一部分是等价变异。我们希望能把注意力集中在那些
有价值的变异上（所谓有价值的变异，指的是可以帮助我们提高测
试集质量的变异），显然，等价变异并无价值。
还记得我们之前提到过的风险分布吗？我们定义如果组件C中的一个
变异可以影响多个组件，则称组件C是高风险的。它能影响的组件越
多，则风险越高。为了降低测试集的风险，我们把注意力侧重于那
些对其他组件影响很大而又未能被检测出的变异。如果一个变异会
对整个程序的表现行为产生影响，而我们的测试集又不能很好地检
测到它，那显然我们需要对测试集进行改进，
问题是到底怎样来衡量一个变异的影响呢？到目前为止，我们在这
里介绍两种方法：
对代码覆盖率的影响
如果一个变异会引起代码执行路径的改变，那么它很有可能会改变
整个程序的表现行为。我们可以统计加入变异后，代码覆盖率发生
变化的方法的个数。数目越多，则该变异的影响越大（Grun等
2009）。
对先决条件和后置条件的影响
每一个方法都会保存一组参数和返回值的状态。在执行中，我们可
以记录下这些值，然后在加入变异后再执行一次，并检查其中有多
少发生了改变。改变越多，则该变异的影响越大（Schuler等
2009)。
无论使用其中的哪一种方法，结果都是令人满意的。当我们把注意
力侧重于影响较大的变异之后，等价变异所占的比例下降到了很低
的比例（<3%）。而发现的缺陷往往都会对整个程序产生很大的损
处。换句话说，在整个程序中，因为这个小小的改变，有21处改变
2085