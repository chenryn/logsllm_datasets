—-创建一个表，分配一个大小为0x150的资源容器。此外，主机将分配大小为0x160的关联数据缓冲区。由于大小不同，这些数据缓冲区将位于低碎片堆（LFH）的单独区域中。每个0x150字节的资源容器将包含指向其关联的0x160字节数据缓冲区的指针。  
—-再创建两个表，分配另外两个大小为0x160的资源容器。由于它们的大小，在此步骤中分配的资源容器将位于上一步骤的0x160字节数据缓冲区附近的内存中。下面将解释这些“相邻”资源容器的目的。  
释放所有剩余容器，释放大小为0x158的块。这些大小为0x158的块将与大小为0x150的资源容器交替放置。
####  越界写入
在分析漏洞利用的结构之前，我们先看一下触发漏洞的WriteOOB函数。`WriteOOB`在整个漏洞利用期间，为了不同的目的会被多次调用，例如泄漏`vmware-vmx.exe`和`kernel32.dll`基址，以及最终的代码执行步骤。函数的参数如下：
`WriteOOB()(void * data, size_t data_size, uint32_t offset)`
该`data`参数是一个指向缓冲区的指针，该缓冲区包含我们打算写入主机堆栈的数据。该`size`参数指定数据的长度。最后，该`offset`参数指定要写入数据的位置，相对于将被损坏的资源容器的头部。
该函数首先分配和初始化帧列表和五个TD结构。此函数发送五个TD结构，因此堆上分配的缓冲区大小将为`5*0x40+0x18=0x158`。
`link`除了最后的TD结构之外，每个TD结构使用该字段链接到下一个TD结构。对于前三个TD结构，`MaxLen`子字段设置为0x40。前三个TD结构的分组ID子字段被设置为`USB_PID_SOF`，因此对于每个TD结构，cursor将被往前送0x41字节。第四TD结构的分组ID也被设置为`USB_PID_SOF`，但是对于该TD，`MaxLen`被设置为从`offset`参数计算的值。这使cursor前进了一个可控量。在第五TD中，分组ID被设置为`USB_PID_OUT`，以便将`data`缓冲器的内容写入cursor位置。
####  内存泄漏并绕过ASLR
既然漏洞利用原语已经写好，那么利用的第一步就是泄漏vmware-vmx.exe的基址。可以通过在TD之后立即破坏资源容器中数据缓冲区的指针来完成的。该指针位于资源容器内的偏移量0x138处，该漏洞通过将其替换为0x00来破坏数据指针的最低有效字节。当引用损坏的指针时，它不再指向数据缓冲区，它会指向位于数据缓冲区附近的0x160字节“相邻”资源容器之一。在这些资源容器中有一些函数指针，因此当数据被复制回guest虚拟机时，`vmware-vmx.exe`会显示基址：
为了精确修改数据指针，需要移动cursor 的字节数如下：  
·最初，cursor指向大小为0x158的缓冲区的开头，考虑到第一个0x18字节被保留为缓冲区头，我们只能控制0x140字节。  
·0x8字节由以下资源容器的堆块头占用。  
·资源容器中数据指针的偏移量为0x138。
总和为0x140 + 0x8 + 0x138 = 0x280，这是cursor必须移动的字节数，指向我们打算修改的字节。
为了将泄漏的函数指针写回到guest虚拟机，该漏洞利用迭代2400个字节堆喷并使用每个映射获取数据`SVGA_3D_CMD_SURFACE_COPY`。然后继续迭代，直到找到泄露的显示`vmware-vmx.exe`基址的函数指针。
为了找到`kernel32.dll`基址，该漏洞利用相同的过程和用于查找的vmware-vmx.exe基址偏移，有一些不同的是，它不是修改指针的单个字节，而是覆盖整个数据指针`vmware_vmx_base_address+0x7D42D8`，这是地址`Kernel32!MultiByteToWideCharStub`存储在导入地址表中的地方。这里就是`kernel32.dll`基地址。
####  代码执行
为了实现代码执行，漏洞再次覆盖堆上的资源容器。这次，漏洞会覆盖资源容器的0x120字节。这个过程完成了三件事：
​ 1 – 将字符串写入`calc.exe`资源容器。  
​ 2 – 填写资源容器的某些必要字段。  
​ 3 – 覆盖资源容器中偏移量0x120处的函数指针，指向`kernel32!WinExec`。
损坏的资源容器在损坏后的样子：
结果是当guest调用`SVGA_3D_CMD_SURFACE_COPY`此损坏的资源容器时，`WinExec`将调用函数指针，将`calc.exe`字符串的地址作为第一个参数传递。该漏洞必须遍历所有2400个表面，以确保使用损坏的资源容器。
####  漏洞利用总结
总结如下漏洞利用：
​ 1.堆风水：  
​ 分配大小为0x158的2400个shader。  
​ 释放大小为0x158的备用shader。  
​
对于每个解除分配的shader，使用大小为0x150的资源容器填充。在此资源容器中，将有一个指向大小为0x160的关联数据缓冲区的指针。还要创建另外两个shader，分配两个大小为0x160且与数据缓冲区相邻的资源容器。  
​ 2.泄漏vmware-vmx.exe基地址（迭代64次，直到找到地址）：  
​
调用`WriteOOB`破坏大小为0x150的资源容器并将指针的最低有效字节修改到其数据缓冲区，以便它指向相邻的0x160字节资源容器。该内存包含一些函数指针。  
​ 遍历2400个shader并使用数据将数据写回到客户端，`SVGA_3D_CMD_SURFACE_COPY`直到找到泄漏的指针。  
​ 3.泄漏kernel32.dll基地址（迭代64次，直到找到地址）：  
​
调用`WriteOOB`破坏大小为0x150的资源容器，并`kernel32.dll`使用导入表中的函数地址修改指向其数据缓冲区的指针VMWare的vmx.exe。  
​ 遍历2400个shader并使用数据将数据写回来`SVGA_3D_CMD_SURFACE_COPY`直到找到泄漏的指针。  
​ 4.虚拟机逃逸并获得代码执行权限（迭代64次，直到我们执行）：  
​ 调用`WriteOOB`以破坏大小为0x150的资源容器。编写“calc.exe”字符串并使用地址修补函数指针`kernel32!WinExec`。  
​ `WinExec`通过迭代穿过2400个shader并使用它们将它们写回guest来触发`SVGA_3D_CMD_SURFACE_COPY`。
###  漏洞总结
对于某些内存损坏漏洞，可以通过执行VMware guest-to-host，利用漏洞可以通过采用半暴力方式获得代码执行。在VMware中发现可利用的漏洞仍然是一个挑战，但一旦发现漏洞，利用难度也不会很大。VMware
SVGA提供各种操作和对象，例如资源容器和shader。根据它们的可调整大小以及它们存储的数据和函数指针，这些在漏洞利用的角度来看是很有用的。