这样使用：
dozen = +12;
编译器不会报错。但是在以前，这样做是不允许的。
250
图5.2 一元和二元运算符
5.2.5 乘法运算符：*
符号*表示乘法。下面的语句用2.54乘以inch，并将结果赋给cm：
cm = 2.54 * inch;
C没有平方函数，如果要打印一个平方表，怎么办？如程序清单5.4所
示，可以使用乘法来计算平方。
程序清单5.4 squares.c程序
251
/* squares.c -- 计算1～20的平方 */
#include 
int main(void)
{
int num = 1;
while (num 
#define SQUARES 64       // 棋盘中的方格数
int main(void)
{
const double CROP = 2E16; // 世界小麦年产谷粒数
double current, total;
int count = 1;
printf("square    grains     total    ");
printf("fraction of \n");
printf("       added     grains   ");
printf("world total\n");
total = current = 1.0;   /* 从1颗谷粒开始 */
printf("%4d %13.2e %12.2e %12.2e\n", count, current,
total, total / CROP);
while (count 
int main(void)
{
printf("integer division:  5/4  is %d \n", 5 / 4);
printf("integer division:  6/3  is %d \n", 6 / 3);
printf("integer division:  7/4  is %d \n", 7 / 4);
printf("floating division: 7./4. is %1.2f \n", 7. / 4.);
printf("mixed division:   7./4  is %1.2f \n", 7. / 4);
return 0;
}
程序清单5.6中包含一个“混合类型”的示例，即浮点值除以整型值。C相
对其他一些语言而言，在类型管理上比较宽容。尽管如此，一般情况下还是
要避免使用混合类型。该程序的输出如下：
integer division:  5/4   is 1
integer division:  6/3   is 2
integer division:  7/4   is 1
floating division: 7./4. is 1.75
mixed division:   7./4  is 1.75
注意，整数除法会截断计算结果的小数部分（丢弃整个小数部分），不
会四舍五入结果。混合整数和浮点数计算的结果是浮点数。实际上，计算机
256
不能真正用浮点数除以整数，编译器会把两个运算对象转换成相同的类型。
本例中，在进行除法运算前，整数会被转换成浮点数。
C99标准以前，C语言给语言的实现者留有一些空间，让他们来决定如
何进行负数的整数除法。一种方法是，舍入过程采用小于或等于浮点数的最
大整数。当然，对于3.8而言，处理后的3符合这一描述。但是-3.8 会怎样？
该方法建议四舍五入为-4，因为-4 小于-3.8.但是，另一种舍入方法是直接丢
弃小数部分。这种方法被称为“趋零截断”，即把-3.8转换成-3。在C99以前，
不同的实现采用不同的方法。但是C99规定使用趋零截断。所以，应把-3.8
转换成-3。
5.2.7 运算符优先级
考虑下面的代码：
butter = 25.0 + 60.0 * n / SCALE;
这条语句中有加法、乘法和除法运算。先算哪一个？是25.0加上60.0，
然后把计算的和85.0乘以n，再把结果除以SCALE？还是60.0乘以n，然后把
计算的结果加上25.0，最后再把结果除以SCALE？还是其他运算顺序？假设
n是6.0，SCALE是2.0，带入语句中计算会发现，第1种顺序得到的结果是
255，第2种顺序得到的结果是192.5。C程序一定是采用了其他的运算顺序，
因为程序运行该语句后，butter的值是205.0。
显然，执行各种操作的顺序很重要。C 语言对此有明确的规定，通过运
算符优先级来解决操作顺序的问题。每个运算符都有自己的优先级。正如普
通的算术运算那样，乘法和除法的优先级比加法和减法高，所以先执行乘法
和除法。如果两个运算符的优先级相同怎么办？如果它们处理同一个运算对
象，则根据它们在语句中出现的顺序来执行。对大多数运算符而言，这种情
况都是按从左到右的顺序进行（=运算符除外）。因此，语句：
butter = 25.0 + 60.0 * n / SCALE;
257
的运算顺序是：
60.0 
* 
n     首先计算表达式中的*或/（假设n的值是6，所以
60.0*n得360.0）
360.0 / SCALE   然后计算表达式中第2个*或/
25.0 + 180     最后计算表达式里第1个+或-，结果为205.0（假设
SCALE的值是2.0）
许多人喜欢用表达式树（expression tree）来表示求值的顺序，如图5.3
所示。该图演示了如何从最初的表达式逐步简化为一个值。
图5.3 用表达式树演示运算符、运算对象和求值顺序
如何让加法运算在乘法运算之前执行？可以这样做：
flour = (25.0 + 60.0 * n) / SCALE;
最先执行圆括号中的部分。圆括号内部按正常的规则执行。该例中，先
执行乘法运算，再执行加法运算。执行完圆括号内的表达式后，用运算结果
除以SCALE。
258
表5.1总结了到目前为止学过的运算符优先级。
表5.1 运算符优先级（从低至高）
注意正号（加号）和负号（减号）的两种不同用法。结合律栏列出了运
算符如何与运算对象结合。例如，一元负号与它右侧的量相结合，在除法中
用除号左侧的运算对象除以右侧的运算对象。
5.2.8 优先级和求值顺序
运算符优先级为表达式中的求值顺序提供重要的依据，但是并没有规定
所有的顺序。C 给语言的实现者留出选择的余地。考虑下面的语句：
y = 6 * 12 + 5 * 20;
当运算符共享一个运算对象时，优先级决定了求值顺序。例如上面的语
句中，12是*和+运算符的运算对象。根据运算符的优先级，乘法的优先级比
加法高，所以先进行乘法运算。类似地，先对 5 进行乘法运算而不是加法运
算。简而言之，先进行两个乘法运算6 * 12和5 * 20，再进行加法运算。但
是，优先级并未规定到底先进行哪一个乘法。C 语言把主动权留给语言的实
现者，根据不同的硬件来决定先计算前者还是后者。可能在一种硬件上采用
某种方案效率更高，而在另一种硬件上采用另一种方案效率更高。无论采用
哪种方案，表达式都会简化为 72 + 100，所以这并不影响最终的结果。但
是，读者可能会根据乘法从左往右的结合律，认为应该先执行+运算符左边
的乘法。结合律只适用于共享同一运算对象运算符。例如，在表达式12 / 3 *
2中，/和*运算符的优先级相同，共享运算对象3。因此，从左往右的结合律
在这种情况起作用。表达式简化为4 * 2，即8（如果从右往左计算，会得到
259
12/6，即2，这种情况下计算的先后顺序会影响最终的计算结果）。在该例
中，两个*运算符并没有共享同一个运算对象，因此从左往右的结合律不适
用于这种情况。
学以致用
接下来，我们在更复杂的示例中使用以上规则，请看程序清单5.7。
程序清单5.7 rules.c程序
/* rules.c -- 优先级测试 */
#include 
int main(void)
{
int top, score;
top = score = -(2 + 5) * 6 + (4 + 3 * (2 + 3));
printf("top = %d, score = %d\n", top, score);
return 0;
}
该程序会打印什么值？先根据代码推测一下，再运行程序或阅读下面的
分析来检查你的答案。
首先，圆括号的优先级最高。先计算-(2 + 5) * 6中的圆括号部分，还是
先计算(4 + 3 * (2 + 3))中的圆括号部分取决于具体的实现。圆括号的最高优
先级意味着，在子表达式-(2 + 5) * 6中，先计算(2 + 5)的值，得7。然后，把
一元负号应用在7上，得-7。现在，表达式是：
260
top = score = -7 * 6 + (4 + 3 * (2 + 3))
下一步，计算2 + 3的值。表达式变成：
top = score = -7 * 6 + (4 + 3 * 5)
接下来，因为圆括号中的*比+优先级高，所以表达式变成：
top = score = -7 * 6 + (4 + 15)
然后，表达式为：
top = score = -7 * 6 + 19
-7乘以6后，得到下面的表达式：
top = score = -42 + 19
然后进行加法运算，得到：
top = score = -23
现在，-23被赋值给score，最终top的值也是-23。记住，=运算符的结合
律是从右往左。
261
5.3 其他运算符
C语言有大约40个运算符，有些运算符比其他运算符常用得多。前面讨
论的是最常用的，本节再介绍4个比较有用的运算符。
5.3.1 sizeof运算符和size_t类型
读者在第3章就见过sizeof运算符。回顾一下，sizeof运算符以字节为单
位返回运算对象的大小（在C中，1字节定义为char类型占用的空间大小。过
去，1字节通常是8位，但是一些字符集可能使用更大的字节）。运算对象可
以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，
float），则必须用圆括号将其括起来。程序清单5.8演示了这两种用法。
程序清单5.8 sizeof.c程序
// sizeof.c -- 使用sizeof运算符
// 使用C99新增的%zd转换说明 -- 如果编译器不支持%zd，请将其改
成%u或%lu
#include 
int main(void)
{
int n = 0;
size_t intsize;
intsize = sizeof (int);
printf("n = %d, n has %zd bytes; all ints have %zd 
bytes.\n",
262
n, sizeof n, intsize);
return 0;
}
C 语言规定，sizeof 返回 size_t 类型的值。这是一个无符号整数类型，
但它不是新类型。前面介绍过，size_t是语言定义的标准类型。C有一个
typedef机制（第14章再详细介绍），允许程序员为现有类型创建别名。例
如，
typedef double real;
这样，real就是double的别名。现在，可以声明一个real类型的变量：
real deal; // 使用typedef
编译器查看real时会发现，在typedef声明中real已成为double的别名，于
是把deal创建为double 类型的变量。类似地，C 头文件系统可以使用 typedef
把 size_t 作为 unsigned int 或unsigned long的别名。这样，在使用size_t类型