protocol is approximately the same, which is why LEAF+ algorithm
performs better when ùëõ is large.
7 EVALUATION
In this section, we empirically evaluate our algorithm.
Experimental Setup. We implement the secure search algorithm
based on the open source homomorphic encryption library SEAL
(version 3.4.5) [27]. SEAL is a widely used HE library written in C++
and it implements two HE schemes, i.e., BFV [15] and CKKS [9].
We use the BFV implementation since CKKS works better with
fixed-point arithmetics while we only need Boolean operations for
our search algorithm. We run our algorithms on a server equipped
with Debian 10 (Buster) and Intel(R) Xeon(R) CPU E7-8867 v3 @
2.50GHz, 1, 536 GigaByte of RAM. The state-of-the-art AGHL algo-
rithm [2] is used as our baseline model. For fairness, no optimization
technique is used for these two algorithms, like ‚Äúbatching‚Äù.
Results. Figure 9 shows the results. Since our algorithm mainly
improves the searching part of the whole protocol, we conduct
our experiments in two scenarios. First, we measure the time cost
of the searching process alone, i.e., without matching, as shown
in Figure 9(a), this could give us a direct impression of how our
improvement works on the searching part. Second, we add the
matching part back and see the total improvement, the result is
shown in Figure 9(b). According to the experimental results, we
conclude that improving the searching process indeed significantly
accelerates the whole protocol. Note that in both scenarios, we
set error rate ùúÄ = 2‚àí80, and we assume the keyword‚Äôs length is
ùúá = 16-bits.
As shown by our formal analysis, our algorithm requires around
double depth compared to AGHL, this makes our multiplications
slower. According to our evaluation, the time cost per multiplication
operation for our algorithm is around 4.17 times higher than AGHL.
On the other hand, our algorithm requires a much less number of
operations. Specifically, our algorithm only requires 2‚àö
ùëõ times
RS-OR operation while AGHL requires ùëõ times RS-OR operation.
This drives our algorithm much faster than AGHL in general.
The searching algorithm alone starts to perform better than
AGHL when ùëõ is greater than 80, and the entire protocol outper-
forms the previous algorithm when ùëõ ‚â• 400. According to our
formal analysis in Section 5.2, the advantage of our algorithm will
increase further with the increase of the number of records ùëõ, not
only for the searching part but also for the entire protocol.
8 FURTHER OPTIMIZATION
Single instruction multiple data (SIMD) is an optimization tech-
nique proposed by Smart-Vercauteren[28], this technique allows us
(a) pure searching
(b) searching and matching
Figure 9: Server‚Äôs running time as a function of the number of records ùëõ. In the left figure, we show the time cost of the search
process, and in the right one, we depict the time consumption of the whole secure search, i.e., searching and matching. The
results show our work could achieve better efficiency even for a small number of records.
to pack many plaintext elements in a single ciphertext and apply
operations to them at the same time. Plaintext values in a single
ciphertext are referred to as ‚Äúplaintext slots‚Äù of that ciphertext.
We can use SIMD technology as an optimization tool, it is worth
noting that the selection of parameters will be a little different after
using this method. Since SIMD technique operates on the elements
in the slot simultaneously, we should choose the appropriate pa-
rameters so that the technique can be better combined with the
size of the segments we are dividing.
Therefore, when using this optimization technique, further pa-
rameter analysis is very important. We need to carry out detailed
analysis to weigh the multiple parallelism caused by more slots
against the single operation inefficiencies caused by more slots.
9 RELATED WORK
Secure Pattern Matching (SPM): The task of SPM is to deter-
mine whether the plaintext corresponding to the two encrypted
ciphertext meets certain conditions. Specifically, given an encrypted
lookup value, it returns a vector of ùëõ ciphertexts (ùëê1, . . . , ùëêùëõ), where
ùëêùëñ indicates whether the ùëñth data element is a match to the lookup
value (or sometimes returning only a YES/NO answer of whether a
match exists). There are many works about SPM on FHE encrypted
data, see [11, 12, 20, 21, 23, 31, 33] for details. The main drawback of
these protocols is that the communication complexity and client‚Äôs
running time are proportional to the number of stored elements.
Private Information Retrieval (PIR): PIR is a useful protocol to
retrieve at most a single record ùë•ùëñ in the encrypted array (as in SQL
UNIQUE constraint), it provides a restricted search functionality,
where the client‚Äôs lookup value must be a unique identier. Low
degree polynomials realizing secure data retrieval for these unique
identifier settings have been shown in prior works (see [5, 14, 16]).
We note that the server‚Äôs run-time in a single server PIR (whether
or not FHE based) is inherently linear in the size of dataset (ùëõ). This
protocol provides only a restricted search functionality, which is
incompatible in our setting.
Private Set Intersection (PSI): PSI refers to a setting where two
parties each hold a set of private items and wish to learn the inter-
section of their sets without revealing any additional information
except for the intersection itself. The most efficient works are shown
in [7, 22, 24, 25], however, the protocol is inefficient in the sense of
its communication complexity is at least linear dependence on the
smaller database size (ùëõ).
Searchable Encryption (SE): SE enables highly efficient search
over encrypted data. Specifically, SE focuses on achieving sublinear
search time. There are two main primitives for searchable encryp-
tion: searchable symmetric encryption (SSE) [30] and public key
encryption with keyword search (PEKS) [3]. However, the security
is weakened to leak vital search information, like access pattern.
10 CONCLUSION
In this paper, we propose an efficient algorithm ‚Äì LEAF (and its
variants LEAF+ ) ‚Äì with low communication complexity for FHE-
based secure search. Our scheme relies on three novel techniques
including localization, extraction, and reconstruction. LEAF only
requires the client to encrypt the lookup value and upload it to
the server, and the server will return the encrypted coordinates
corresponding to the matching items in the encrypted database.
In the whole process, the client only needs to encrypt the lookup
value and decrypt the output, which enables our algorithm to be
deployed on weak-power devices and embedded systems.
The security of the protocol is guaranteed by the semantic se-
curity feature of FHE. The server could only access the encrypted
data in the whole process, so the data privacy is enhanced. LEAF
can be performed over ùê∫ùêπ(2), which fits all current homomorphic
encryption algorithm. Meanwhile, our algorithm can support un-
restricted search function, which greatly expands its application
scenarios.
ACKNOWLEDGEMENT
Yu Yu was supported by the National Key Research and Devel-
opment Program of China (Grant No. 2018YFA0704701), National
Natural Science Foundation of China (Grant No. 61872236 and
61971192), the National Cryptography Development Fund (Grant
No. MMJJ20170209), and the Major Program of Guangdong Basic
and Applied Research (Grant No. 2019B030302008).
0200040006000800010000numberofrecords(n)0246810runningtime(x108microsecs)LEAFAGHL0200040006000800010000numberofrecords(n)024681012runningtime(x108microsecs)LEAFAGHL[4] Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. 2014.
REFERENCES
[1] Adi Akavia, Dan Feldman, and Hayim Shaul. 2018. Secure Search on Encrypted
Data via Multi-Ring Sketch. In ACM SIGSAC Conference on Computer and Com-
munications Security (CCS). ACM, 985‚Äì1001.
[2] Adi Akavia, Craig Gentry, Shai Halevi, and Max Leibovich. 2019. Setup-Free
Secure Search on Encrypted Data: Faster and Post-Processing Free. Symposium
on Privacy Enhancing Technologies Symposium (2019).
[3] Dan Boneh, Giovanni Di Crescenzo, Rafail Ostrovsky, and Giuseppe Persiano.
2004. Public Key Encryption with Keyword Search. In Annual International Con-
ference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT).
Springer, 506‚Äì522.
(Leveled)
Fully Homomorphic Encryption without Bootstrapping. ACM Transactions on
Computation Theory (2014).
[5] Zvika Brakerski and Vinod Vaikuntanathan. 2014. Efficient Fully Homomorphic
Encryption from (Standard) LWE. SIAM Journal on Computing (2014).
[6] Hao Chen and Kyoohyung Han. 2018. Homomorphic Lower Digits Removal and
Improved FHE Bootstrapping. In Annual International Conference on the Theory
and Applications of Cryptographic Techniques (EUROCRYPT). Springer, 315‚Äì337.
[7] Hao Chen, Kim Laine, and Peter Rindal. 2017. Fast Private Set Intersection
from Homomorphic Encryption. In ACM SIGSAC Conference on Computer and
Communications Security (CCS). ACM, 1243‚Äì1255.
[8] Jung Hee Cheon, Kyoohyung Han, and Duhyeong Kim. 2017. Faster Bootstrap-
ping of FHE over the Integers. Cryptology ePrint Archive, Report 2017/079 (2017).
[9] Jung Hee Cheon, Andrey Kim, Miran Kim, and Yongsoo Song. 2017. Homo-
morphic Encryption for Arithmetic of Approximate Numbers. In International
Conference on the Theory and Application of Cryptology and Information Security
(ASIACRYPT). Springer, 409‚Äì437.
[10] Jung Hee Cheon, Dongwoo Kim, Duhyeong Kim, Hun Hee Lee, and Keewoo
Lee. 2019. Numerical Method for Comparison on Homomorphically Encrypted
Numbers. In International Conference on the Theory and Application of Cryptology
and Information Security (ASIACRYPT). Springer, 415‚Äì445.
[11] Jung Hee Cheon, Miran Kim, and Myungsun Kim. 2016. Optimized Search-and-
Compute Circuits and Their Application to Query Evaluation on Encrypted Data.
IEEE Transactions on Information Forensics and Security (2016).
[12] Jung Hee Cheon, Miran Kim, and Kristin Lauter. 2015. Homomorphic Computa-
tion of Edit Distance. In International Conference on Financial Cryptography and
Data Security (FC). Springer, 194‚Äì212.
[13] Jack L. H. Crawford, Craig Gentry, Shai Halevi, Daniel Platt, and Victor Shoup.
2018. Doing Real Work with FHE: The Case of Logistic Regression. In Workshop
on Encrypted Computing & Applied Homomorphic Cryptography (WAHC). ACM,
1‚Äì12.
[14] Yarkƒ±n Dor√∂z, Berk Sunar, and Ghaith Hammouri. 2014. Bandwidth Efficient
PIR from NTRU. In International Conference on Financial Cryptography and Data
Security (FC). Springer, 195‚Äì207.
[15] Junfeng Fan and Frederik Vercauteren. 2012. Somewhat Practical Fully Homo-
morphic Encryption. Cryptology ePrint Archive, Report 2012/144 (2012).
Annual ACM Symposium on Theory of Computing (STOC). ACM, 169‚Äì178.
[17] Craig Gentry, Amit Sahai, and Brent Waters. 2013. Homomorphic Encryp-
tion from Learning with Errors: Conceptually-Simpler, Asymptotically-Faster,
Attribute-Based. In Annual International Cryptology Conference (CRYPTO).
Springer, 75‚Äì92.
[18] Oded Goldreich, Silvio Micali, and Avi Wigderson. 1987. How to Play Any
Mental Game. In Annual ACM Symposium on Theory of Computing (STOC). ACM,
218‚Äì229.
[19] Chun Guo, Jonathan Katz, Xiao Wang, and Yu Yu. 2019. Efficient and Secure
Multiparty Computation from Fixed-Key Block Ciphers. Cryptology ePrint Archive,
Report 2019/074 (2019).
[20] Myungsun Kim, Hyung Tae Lee, San Ling, Shu Qin Ren, Benjamin Hong Meng
Tan, and Huaxiong Wang. 2016. Better Security for Queries on Encrypted
Databases. Cryptology ePrint Archive, Report 2016/470 (2016).
[21] Myungsun Kim, Hyung Tae Lee, San Ling, Benjamin Hong Meng Tan, and Huax-
iong Wang. 2017. Private Compound Wildcard Queries Using Fully Homomorphic
Encryption. IEEE Transactions on Dependable and Secure Computing (2017).
[22] Vladimir Kolesnikov, Ranjit Kumaresan, Mike Rosulek, and Ni Trieu. 2016. Ef-
ficient Batched Oblivious PRF with Applications to Private Set Intersection. In
ACM SIGSAC Conference on Computer and Communications Security (CCS). ACM,
818‚Äì829.
[23] Kristin Lauter, Adriana L√≥pez-Alt, and Michael Naehrig. 2014. Private Computa-
tion on Encrypted Genomic Data. In International Conference on Cryptology and
Information Security in Latin America (LATINCRYPT). Springer, 3‚Äì27.
[24] Benny Pinkas, Mike Rosulek, Ni Trieu, and Avishay Yanai. 2019. SpOT-Light:
Lightweight Private Set Intersection from Sparse OT Extension. In Annual Inter-
national Cryptology Conference (CRYPTO). Springer, 401‚Äì431.
[25] Benny Pinkas, Thomas Schneider, and Michael Zohner. 2018. Scalable Private Set
Intersection Based on OT Extension. ACM Transactions on Privacy and Security
[16] Craig Gentry. 2009. Fully Homomorphic Encryption Using Ideal Lattices. In
(2018).
[26] A. A. Razborov. 1987. Lower Bounds on the Size of Bounded Depth Circuits over
a Complete Basis with Logical Addition. Mathematical notes of the Academy of
Sciences of the USSR (1987).
[27] SEAL 2020. Microsoft SEAL (release 3.5). https://github.com/Microsoft/SEAL.
Microsoft Research, Redmond, WA.
[28] Nigel P Smart and Frederik Vercauteren. 2014. Fully Homomorphic SIMD Opera-
tions. Designs, Codes and Cryptography (2014).
[29] Roman Smolensky. 1987. Algebraic Methods in the Theory of Lower Bounds for
Boolean Circuit Complexity. In Annual ACM Symposium on Theory of Computing
(STOC). ACM, 77‚Äì82.
[30] Dawn Xiaodong Song, David Wagner, and Adrian Perrig. 2000. Practical Tech-
niques for Searches on Encrypted Data. In IEEE Symposium on Security and
Privacy (S&P). IEEE, 44‚Äì55.
[31] Haixu Tang, Xiaoqian Jiang, Xiaofeng Wang, Shuang Wang, Heidi Sofia, Dov Fox,
Kristin Lauter, Bradley Malin, Amalio Telenti, Li Xiong, et al. 2016. Protecting
genomic data analytics in the cloud: state of the art and opportunities. BMC
medical genomics (2016).
[32] Andrew Chi-Chih Yao. 1986. How to Generate and Exchange Secrets. In Annual
Symposium on Foundations of Computer Science (FOCS). IEEE, 162‚Äì167.
[33] Masaya Yasuda, Takeshi Shimoyama, Jun Kogure, Kazuhiro Yokoyama, and
Takeshi Koshiba. 2013. Secure Pattern Matching Using Somewhat Homomorphic
Encryption. In ACM Cloud Computing Security Workshop (CCSW). ACM, 65‚Äì76.
Appendices
A SEQUENTIAL RETRIEVAL
In the main body, we provide a faster secure search algorithm that
takes as input an encrypted array, consisting of encrypted 0s and 1s,
and produces as output the first 1‚Äôs index and its corresponding item.
For completeness, we recall from Akavia et al. [2] how to extend
secure search functionality to return the rest matching elements.
Assume that we have obtained the first match‚Äôs index, say ùëñ, and
want to retrieve the second matching. The intuition is that once
we set the first non-zero term to 0, the second non-zero term now
becomes the first in the original encrypted array, so one just applies
the secure search algorithm and repeats the above process.
It‚Äôs not very hard to set the first non-zero term in the original
array to 0, since we obtain this encrypted binary array by applying
the matching method on each item in the database, we can change
the original matching criteria by adding additional requirement, i.e.,
output 1 if and only if the item in the database meets the following
two conditions simultaneously:
‚Ä¢ The item satisfies the original matching condition;
‚Ä¢ The item‚Äôs index is greater than ùëñ (the first matching‚Äôs index);
Then, apply this new matching method to the database to obtain
a new encrypted binary array, which differs only in that the first
non-zero term in the original array is set to 0. More details are found
in Akavia et al.‚Äôs work [2], which takes the same time complexity
(ùëÇ(ùëõ)) as a normal exact matching in the asymptotic sense.
To our best knowledge, retrieval following matching needs fur-
ther interaction as we have to send the encrypted index ùëñ to the
server and need to rerun the matching and searching algorithms,
which is time-consuming. However, at the same time it makes
adversary infeasible to find out the number of matchings in the
database, since the client can choose whether to continue fetching
the next matching or not, which enhances the privacy.
ùëúùë¢ùë°ùëùùë¢ùë° = Œ†ùëëùëîùëü
ùëñ=1ùë•ùëñ
depth:
logùêµ dgr
. . .
. . .
ùë•1 ùë•2 . . . ùë•ùêµ ùë•ùêµ+1 . . .
. . .
ùë•ùëëùëîùëü
Figure 10: An example that a polynomial of degree dgr, e.g.,
Œ†ùëëùëîùëü
ùëñ=1 ùë•ùëñ can be implemented by a balanced ùêµ-ary tree for min-
imized depth ‚âà logùêµ dgr.
B MULTIPLICATION STRUCTURE
C PROOF OF LEMMA 4.1
Lemma. (1 ‚àí ùúÄ
and only if ùëõ = 1.
ùëõ)ùëõ ‚â• 1 ‚àí ùúÄ, ‚àÄùëõ ‚àà N+, ùúÄ  ùëî(+‚àû) = 0
ùëì (ùëõ) ‚â• ùëì (1) = 1 ‚àí ùúÄ
that is, if ùëõ ‚â• 1, we have:
(1 ‚àí ùúÄ
ùëõ
)ùëõ ‚â• 1 ‚àí ùúÄ
‚ñ°