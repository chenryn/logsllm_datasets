Thumb指令需要将地址加1；而当我们使用Module.findExportByName
方法获取函数地址时，Frida会自动帮我们处理这种情况。
这里教大家一个通用的方法，首先，我们可以使用
Module.findBaseAddress方法我到自标lib库的初始地址，随后加上自
标函数的偏移（这个偏移可以根据IDAPro计算出来），然后使用正常
的步骤HOOK即可，示例代码如下：
var libc = Module.findBaseAddress(libc.so))
libc.add（ptr(0x1222))
Interceptor.attach(libc,callbacks)
---
## Page 962
CTF特训营：技术详解、解题方法与
25.3.3使用Frida框架HOOK进程
962/1144
除了上面介绍的基本的HOOK方法之外，还有另外一个很有用的
方法：hexdump，该方法的定义如下：
hexdump(target[,options])
其中，target是一个NativePointer对象，options是可选的，用于
指定效果，具体的效果可以查看官方文档，这里一般为空。
这个方法，顾名思义，就是打印内存所用的方法，非常好用。该
方法会返回一个hexdump格式的字符串，需要你自己使用send或者
console.log打印出来。
---
## Page 963
CTF特训营：技术详解、解题方法与
25.4OLLVM混淆及加固技术
963/1144
25.4OLLVM混淆及加固技术
AndroidNative层的混淆和加固技术非常多，因为C语言可以做出
非常多样的变化，但是我们在一般的比赛题目中，不会去加非常强的
混淆，要不然题自根本就没法做了，稍微难一点的题自可能会使用
OLLVM混淆，因此，本节将重点介绍OLLVM昆淆技术
OLLVM的全称是Obfuscator-LLVM，是以LLVM编译器为基础开
发的、增加了混淆功能的编译器。该编译器支持大部分语言（C、C+
+、Objective-C、Ada、Fortran），支持大部分处理器架构（x86、
x86-64、PowerPC、PowerPC-64、ARM、Thumb、SPARC、Alpha
CellSPU、MIPS、MSP430、SystemZ、XCore)，是一个功能非常强
大的编译器。
OLLVM的源码位于
https://github.com/obfuscator-llvm
obfuscator,
，有兴趣的读者可以自行研究。
OLLVM支持三种混淆方式，参数分别为-fla、-sub、-bcf，这三种
混淆方式是相互独立的，下面我们来深入讲解一下这三种混淆方式。
首先我们先看一下未混淆的代码是什么样的，原始代码真体如
---
## Page 964
CTF特训营：技术详解、解题方法与
25.4OLLVM混淆及加固技术
964/1144
下：
unsigned int target function(unsigned intn)
{
unsigned int mod = n % 4;
unsigned int result = 0;
if （mod ==0)
result=(n|OxBAAADOBF)*(2^n）;
else if (mod == 1)
result=（n&0xBAAADOBF)*(3+n);
else if (mod == 2)
result=（n^0xBAAADOBF)*（4|n）;
else
result=（n+OxBAAAD0BF)*（5&n）;
return result;
使用clang编译器或者未加混淆参数的OLLVM编译器编译出来的
汇编代码，其用IDAPro查看的流程图（去掉了栈溢出检测等无关代
码）如图25-13所示。
电
---
## Page 965
CTF特训营：技术详解、解题方法与
25.4OLLVM混清及加固技术
965/1144
图25-13IDAPro查看反编译流图
可以看到，流程非常容易识别，反汇编起来毫无压力。
下面就来看一下各个混淆方式的效果
---
## Page 966
CTF特训营：技术详解、解题方法与
25.4.1-fla966/1144
25.4.1-fla
fla是controlflowflattening的缩写，这里我们直译成“控制流扁
平化”，或者称为“fha混淆”，根据官方文档的说法，该混淆将代码
划分为许多基础块，将这些基础块放到一个无限循环中，并使用一个
新的变量和switch语句来控制循环的流程。
混淆后用IDAPro查看的流程图如图25-14所示
这种混淆方式乍一看很复杂，其实还是比较简单的。在一开始的
初始化流程中，OLLVM编译器会新建一个本地变量，同时赋予该本
地变量一个整数，这个本地变量可用于控制流程，在本例中，该本地
变量的值被存在寄存器LR中
代码中所有的基础块都可以分为两类，一类是存储在为寄存器
LR赋值的语句块中，另一类是存储在没有为寄存器LR赋值的块中：
随后我们可以根据对寄存器LR赋值和判断的情况，将为LR赋值的块
按照先后顺序排列，同时丢弃掉没有为LR赋值的块，形成一个有向
图，最后将图中没有意义的块全部去除，即可还原出混淆前的代码了。
---
## Page 967
CTF特训营：技术详解、解题方法与
25.4.1 -fla
967/1144
图25-14IDAPro查看混淆后的流图1
---
## Page 968
CTF特训营：技术详解、解题方法与
25.4.2 -bcf
968/1144
25.4.2-bcf
-bcf的全称是“BogusControlFlow”，这里直译为“虚假控制
流”。这个混淆方法的主要思想是将所有基础块的代码再复制一遍
再添加一个永远为真的虚假分支，使得你在查看代码的时候能够发现
有的流程重复出现了两次，例如，之前的代码使用“bcf混淆”后的
效果如图25-15所示。
---
## Page 969
CTF特训营：技术详解、解题方法与
25.4.2 -bcf
969/1144
10._50
R3,D
图25-15IDAPro查看混淆后的流图2
该混淆会使得你在使用上一步的溯源分析时，即试图将所有的基
础块划分成一个有向图的过程时进入一个无尽循环。因为我们在以基
---
## Page 970
CTF特训营：技术详解、解题方法与
25.4.2 -bcf
970/1144
础块为基本单位进行静态分析时，是看不到跳转的具体判断情况的。
因此对于bcf混淆，我们可以从源码中找出些许解决方法。源码
中有一段注释如下：
/Before:
entry
Original
return
I/After:
entry
condition*(false)
I/
(true)
>
Original*|
1(true)
(false)
->return
1/
A
Altered
K--!
1/
I/*Theresults of these terminator's branch's conditions are always true,but these
predicatesare
opacificated.For this,we declare two global values:x and y,and replace the
FCMP_TRUE
predicate with (y<10 Ilx*(x+1) % 2 == 0)（this could be improved,as the
global
//values give a hint on where are the opaque predicates)
---
## Page 971
CTF特训营：技术详解、解题方法与
25.4.2-bcf
971/1144
从上面的注释代码中可以看到，bcf混淆使用了一个永真式
"y<10lx*(x+1)%2==0”来作为判断的条件，结果为真则跳转到真正
的分支，结果为假则跳转到无尽的循环。
因此我们只要抓住这个跳转条件，将无尽循环的分支整个去掉
就能够绕过bcf混淆了。
---
## Page 972
CTF特训营：技术详解、解题方法与
25.4.3-sub972/1144
25.4.3-Sub
-sub是InstructionsSubstitution的缩写，这里直译为“指令替代”，
这种混淆的思想是将常见的基础指令，例如加、减、乘、除等价替换
成一些复杂的指令。之前的代码使用sub混淆之后使用iDApro查看的
流程图如图25-16所示。
由图25-16中可以看到，程序的主要流程并没有发生变化，只是
代码变得略微复杂一些。OLLVM对于代码替换的支持可以查看官方
的相关说明https://github.com/obfuscator-llvm/obfuscator/wiki
Instructions-Substitution，处理起来比之前两个混淆简单很多。
---
## Page 973
CTF特训营：技术详解、解题方法与
25.4.3 -sub
973/1144
.
图25-16IDAPro查看混淆后的流图3
本节介绍了OLLVM混淆的细节，希望能够帮助读者对OLLVM混
淆的细节有进一步的了解。
---
## Page 974
CTF特训营：技术详解、解题方法与
本筒小结974/1144
本篇小结
本篇主要从Android基础知识、Dalvik层逆向、Native层逆向三个
方面介绍了CTF中Android题目的类型和解法。
在第23章中，我们梳理了Android题目的类型、APK文件格式的
结构、Android系统的基本架构、ARM平台的基本属性以及ADB的基
本用法，补足了Android逆向的基础知识。
在第24章中，我们讲解了Dalvik虚拟机的基础知识，并且从静态
分析、动态调试两个方面讲解了Dalvik层的逆向分析方法，介绍了
Apktool、dex2jar、jd-gui、FernFlower、JEB等优秀的逆向工具，讲
解了Xposed、Frida等优秀的HOOK工具，分析了Proguard、APk伪加
密、DEX隐藏等常见的混淆及加密技术，具备了初步的Dalvik层逆向
能力。
在第25章中，我们讲解了Native调用的原理，介绍了使用IDA
Pro对APK进行逆向的技巧，重点讲解了使用IDAPro、GDB、Frida等
工具进行动态调试和HOOK的方法，最后我们简要介绍了常见的
OLLVM混淆的混淆思路，初步真备了对Native层的逆向能力
---
## Page 975
CTF特训营：技术详解、解题方法与
本筒小结
975/1144
希望本篇内容能够对喜爱Android逆向的同学提供一些帮助，谢
谢。
---
## Page 976
CTF特训营：技术详解、解题方法与
第六篇CTF之loT
976/1144
第六篇CTF之loT
本篇可以算是本书的一大特色，加入了近几年CTF比赛中逐渐开
始出现的loT类赛题。事实上，对于loT类题目，更专业的分类应该叫
作EmbeddedSystem，即嵌入式系统。传统安全主要研究的是互联网
上的安全，嵌入式系统近几年在传感器网络中大量应用，使得相关的
安全问题也日益凸显，即物联网安全
当然，嵌入式系统安全的范围要远比物联网更大，甚至包括物理
层上的攻防。由于本书主要讨论的是CTF竞赛中有关嵌入式系统的问
题，因此超出CTF比赛范围的内容在这里不会多做介绍，有兴趣的读
者可以参考相关的研究著作或论文
基于以上原因，在接下来的章节里，我们一律使用“loT”这个
名称来描述这类问题，以符合现在行业主流的认知。
在本篇中，你将学习到在解决loT类题自时要用到的一些必要的
基础知识，在CTF竞赛当中此类题自的应对办法和技巧，以及一些与
无线电通信相关的题目的应对技巧，最后还有一些实例讲解，帮助大
家培养解决loT相关题自的能力。
---
## Page 977
CTF特训营：技术详解、解题方法与
第六篇CTF之loT
977/1144
另外，本节所涉及的大部分例题，都可以在笔者开发的一个OJ
平台上找到，大家如果对平台上的其他题目感兴趣，也可以在上面练
习，oJ平台地址为：https://www.jarvisoj.com/
---
## Page 978
CTF特训营：技术详解、解题方法与
第26章loT基础知识
978/1144
第26章loT基础知识
本章不打算对loT的背景进行详细的介绍，一是因为loT是一个面
向应用场景的领域，场景错综复杂，若要讲清楚，其篇幅将远远超过
本书所能接受的范围。二是因为在CTF竞赛中我们并不需要去了解过
多的细节，了解太多的信息有时会适得其反。因此，本章将挑选一些
有必要的以及科普性质的内容为读者做一个简要介绍，读者只需要大
致理解loT的作用及用法即可，无须对其中的技术名词进行深究，重
在掌握解题方法，而非其概念。
---
## Page 979
CTF特训营：技术详解、解题方法与
26.1什么是loT979/1144
26.1什么是loT
之前我们已经提到过，oT安全的本质是以嵌入式系统为基础的
传感器网络上的安全问题，包括车联网、传感器网络、工控网络等
简单地说，物联网可以看作是一类特殊的网络，相比传统的互联网
功能简化很多，但数据交互的次数要比传统的互联网更加频繁。其核
心可以看成是由传感器技术、RFID技术、嵌入式系统技术这三大技
术所组成的一个复杂系统。
传感器技术：计算机应用中的关键技术。大家都知道，到自前
为止，绝大部分计算机处理的都是数字信号，需要传感器将模拟信号
转换成数字信号，这样计算机才能处理。
RFID标签：也是一种传感器技术，RFID技术是融合了无线射频
技术和嵌入式技未的综合技木，在自动识别、物品和物流管理方面有
着广阔的应用前景
嵌入式系统技术：是综合了计算机软硬件、传感器技术、集成
电路技术、电子应用技未的复杂技术。基于嵌入式系统的智能终端产
品随处可见，小到遥控器，大到卫星系统。嵌入式系统止在改变看人
---
## Page 980
CTF特训营：技术详解、解题方法与
26.1什么是loT
980/1144
们的生活，推动着工业生产以及国防工业的发展。
如果将物联网比作人体，那么传感器就相当于是人的眼睛、鼻子、
皮肤等感官，接收到信息后要进行分类处理，而承担数据处理工作的
就是嵌入式系统。这个例子很形象地描述了传感器、嵌入式系统在物
联网中的位置与作用。图26-1展示了物联网各大技术之间的关系。
短距离
两化融合
有线通信
短距离
物联网
长距离
M2M
物联网
RFID
无线通信
四大网络
无线通信
传感网
长距离
有线通信
图26-1loT领域各大技术之间的关系
说了这么多，大家对loT应该有了一个大致的了解，我对loT的定
义：loT就是一类以嵌入式系统为基础，承担主要用于数据感知与收
集（传感器）、控制指令传送的一种低功耗、协议简化的无线通信网
络。
---
## Page 981
CTF特训营：技术详解、解题方法与
26.1什么是loT
981/1144
根据以上定义，就可以比较清晰地将loT与传统互联网相互区分
开来。传统互联网要求高度互联，数据传输可靠，数据传送量大，大
多使用大型服务器和交换设备作为基础设施，多为星形网络，数据中
心化。而loT则与之相反，组成ioT的设备大多为处理能力较弱的低功
耗设备、微控制器，网络更偏向于网格化，每个节点作为数据源的同
时也会承担数据转发工作，整体组网比较自由，容错能力较强，传输
数据量比互联网要小很多，但数据实时性会比互联网更好。
---
## Page 982
CTF特训营：技术详解、解题方法与
26.2什么是嵌入式系统982/1144
26.2什么是嵌入式系统
什么是嵌入式系统呢？简单地说，嵌入式系统就是一类具有完整
计算能力的单板系统或者片上系统（SoC）。经常单独使用，或者以