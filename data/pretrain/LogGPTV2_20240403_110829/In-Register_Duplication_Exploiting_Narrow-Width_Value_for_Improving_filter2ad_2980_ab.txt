ues. Information redundancy is the basic idea for protecting
memory structures against soft errors. Instead of duplicat-
ing each register value into two registers, we exploit the ma-
jority of narrow-width values (≤ 32 bits and 34-bit memory
addresses) to perform in-register duplication.
(a)
(b)
Figure 2. (a) Performance sensitivity to the register ﬁle size. (b) Cumulative distribution of the regis-
ter value width.
It
5.1. Narrow-Width Value Detection
Based on the data-width analysis presented in the pre-
vious section, our design is particularly tuned to capture
three types of narrow-width values: 32-bit positive val-
ues (0320x31), 32-bit negative values (1321x31), and 34-bit
memory addresses (03001x32), where x can be either a “1”
or a “0”. From now on, we only refer to these three types as
narrow-width data.
To capture narrow-width values, we add a narrow-width
detector between the output of a functional unit and the in-
put of the pipeline latch. It detects whether the newly gener-
ated result from the functional unit is a 32-bit positive value,
a 32-bit negative value, or a 34-bit memory address (posi-
tive value). After detection, two ﬂag bits (n1n0) associated
with each register value are set to indicate the narrowness
of the current value. The meaning of these two n1n0 bits
is given in Figure 3 (b). The block diagram in Figure 3 (a)
shows the datapath augmented with the narrow-width value
detector. The detector consists of three sub-detectors: a 32-
bit positive value detector, a 32-bit negative value detector,
and a 34-bit memory address detector. Notice that a narrow-
width value will have ﬂag bit n0 set to 1. We utilize ﬂag
bit n0 to control in-register duplication for a narrow-width
value (by copying the lower 32-bit half into the higher 32-
bit half) or to bypass duplication for a regular value.
An alternative implementation to reduce the cycle time
impact is to incorporate the narrow-width detection within
the functional units by monitoring the narrowness of the in-
puts and the internal carry signals. However, such a design
requires modiﬁcation of the standard ALU implementation
as well as different detection circuitry for different opera-
tions, which is what we try to avoid here. In our design, the
functional units are not modiﬁed. Due to the simple detec-
tor circuit [6], the impact on the clock cycle time should be
negligible.
5.2. Exploiting In-Register Duplication for
Error Detection
Once a narrow-width register value is detected,
in-
register duplication is automatically performed by copying
the lower 32-bit half into its higher 32-bit half such that two
copies of the value will be latched into the pipeline regis-
ter. The incentive of our reliable register ﬁle design is not
only to protect the register ﬁle against soft errors, but also
to guarantee reliable data transmission over the writeback
and bypass networks. In-register duplication enforces at any
time two copies of the narrow-width value to be stored in the
register ﬁle, latched by the pipeline register, or transferred
between the register ﬁle and the functional units.
is important
to notice the signiﬁcant difference
in-register duplication and conventional
between our
redundancy-based reliable designs.
In-register duplica-
tion incurs much less hardware complexity compared to
schemes utilizing idle or predicted dead registers for dupli-
cating data value, where the register renaming logic is re-
designed for copy register allocation, the instruction queue
is augmented to hold copy register ids, and the number of
register ﬁle writeports is doubled or a set of copy ports is re-
quired [17]. In-register duplication needs none of the above
hardware modiﬁcations. More importantly, our scheme also
protects the result writeback bus and the bypass network by
transferring two copies of the value without increasing the
bandwidth requirement. In the schemes presented in [17],
a data value hit by errors when transferring over the write-
back bus will result in two corrupted copies being stored in
the register ﬁle due to the use of copy ports. Since around
50%-70% of the input operands are retrieved from the by-
pass network, hardening both the bypass network and the
writeback bus against soft errors is of critical importance,
which is naturally supported by in-register duplication.
Since the probability of the two copies of the narrow
value being corrupted at exactly the same bit positions is ex-
tremely low, the two copies can be compared against each
other to verify the absence of soft errors very effectively. A
follow-up question is when to perform this comparison. No-
tice that soft-error corrupted data only matters when used
later in computation or written out to the memory hierar-
chy. The probability of resulting in crashed execution or
erroneous outputs can be estimated by the architectural vul-
nerable factors (AVFs) [20] of the microarchitectural blocks
that the corrupted value is going through. We choose to per-
form error detection (comparing the upper 32 bits against
the lower 32 bits of the input operand) at the execution stage
when the operands are fed to the functional units. Figure
4 shows the slightly changed datapath back-end stages to
support in-register duplication and soft error detection. Af-
ter narrow-width detection, each value is augmented with
Narrow−Width Detector
3
4
−
b
m
a
d
d
r
3
2
−
b
p
o
s
.
(63..31)
33
32
(31..0)
3
2
−
b
n
e
g
.
32
(a)
n1
n0
0
1
pipeline
latches
n1
0
0
1
1
n0 meaning
0
1
1
0
regular value
32-bit pos./neg. narrow-width value
34-bit narrow-width memory address
reserved
(b)
Figure 3. (a) Augmented functional unit datapath with narrow-width detectors and value duplication.
(b) The meaning of the value of narrowness ﬂag bits n1n0.
Register
File
n1
n0
32
32
n1
n0
32
32
66
66
66
66
n1
n0
32
32
n1
n0
32
32
66
64
W
i
d
t
h
D
e
t
e
c
t
o
r
66
n1
n0
32
32
ERR
64
64
ERR
66
DCache
RF Read
Exec/Bypass
Dcache Acc.
Figure 4. Microarchitectural support for in-
register duplication and error detection.
the 2 additional ﬂag bits n1n0 indicating the narrowness of
the value. The data bus and the register ﬁle are extended
to transmit and store 66-bit values instead of the original
64-bit ones. The source operands retrieved either from the
register ﬁle or from the bypass network are in 66-bit format.
If the n1n0 bits indicate a narrow-width value, sign exten-
sion is performed to restore the original 64-bit value and
error detection is carried out simultaneously by comparing
the upper and lower 32-bit halves. If the two halves match
each other, no error is detected. Otherwise, an “ERR” sig-
nal is raised to denote errors. The data cache here is treated
in the same way as regular functional units; its data bus is
also protected by in-register duplication for narrow-width
values.
5.3.
Integrating In-Register Duplication
and Parity Coding
In-register duplication is expected to be very effective
in soft-error detection by comparing the two copies of the
narrow-width value stored within the same 64-bit data, how-
ever, is not capable of recovering from an error. Since in-
register duplication already maintains two redundant copies
of the value, providing ECC coding (e.g., Hamming coding)
for each 32-bit half is either over-designed or not feasible
considering the ECC coding/checking latency and power
consumption [11]. We choose to use simple and fast par-
ity coding to supplement each 32-bit half with an additional
parity bit. Notice that the ﬂag bits can be also covered by the
same parity bits for the data value or a separate parity bit,
which we do not explore further in this work. We assume
parity encoding/checking takes one clock cycle.
There are at least two strategies to perform error detec-
tion and recovery in our in-register duplication scheme with
parity coding. The ﬁrst strategy is to compare the two 32-
bit halves of the input operand to detect possible errors just
as in the base IRD scheme. Simultaneously, parity check-
ing is carried out for both halves. If the two 32-bit halves
match each other, no error is detected and the parity check-
ing result is ignored. Otherwise, if the lower half passes
the parity check, the error(s) is(are) considered only to have
corrupted the upper half which we do not care about and
no error recovery is needed. If the lower half fails parity
check and the upper half passes the check, then the upper
half is used to recover the detected errors.
In case both
halves fail the check, an exception is raised to inform the
upper levels of the system. The second strategy eliminates
the comparison and directly performs parity checking for
both halves. If the lower half passes the check, we do not
care about the duplicate in the upper half since the value is
restored from the lower half. Otherwise, we try to use the
upper half to recover the corrupted lower half in a similar
way as in the ﬁrst strategy. Effectively, these two strategies
are the same in terms of error recovery capability. However,
the ﬁrst strategy using comparison shall detect more errors
than the second one. This might not be always good; e.g.,
errors happening in the upper half of the operand have no
impact on the correctness of the execution, however, will be
detected and raised for action in the ﬁrst strategy. A simi-
lar problem exists in both of these two strategies as in any
protection scheme using parity coding: a successful parity
check does not guarantee the integrity of the data value and
a false recovery may be performed by using the corrupted
yet not detected redundant copy. Whether to recover the
erroneous data value in the register ﬁle or not after error de-
tection should be justiﬁed by the error rates in real applica-
tions due to the potentially signiﬁcant hardware complexity
needed for such a recovery.
Register
File
n1
n0
32
32
n1
n0
32
32
66
68
66
68
n1
n0
32
32
n1
n0
32
32
66
Parity Encoding
Parity Encoding
64
ERR
64
ERR
ERR
n1
n0
32
32
ERR
66
W
i
d
t
h
D
e
t
e
c