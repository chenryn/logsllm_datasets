0.61
1.58
0.03
9.12
KB
5153.77
None
21.91
9.79
231.28
928.82
2628.64
50.95
3849.48
s
1089.42
6.28
0.45
13.33
0.24
1.38
3.12
0.04
18.11
KB
10306.81
None
21.91
18.95
462.40
1851.06
5258.63
101.94
7692.98
Table 4. Running Time (seconds) and Bandwidth (KB) for Protocol Phases
all the core computation. This limits the scalability of their
system. The length of vectors is 12 in their system (com-
pared to 640 in our experiments). For a database of 320
faces, the whole system takes 18 seconds online computa-
tion to serve a query, and generates about 7.25MB network
trafÔ¨Åc.
Sadeghi et al. [20] improved the efÔ¨Åciency of Erkin‚Äôs
work by constructing a hybrid protocol that uses homomor-
phic encryption to compute Euclidean distances and garbled
circuits for minimum. They also devised the idea of pack-
ing, which, however, they use merely used to save commu-
nication cost. Our Euclidean distance protocol builds on
this protocol, but improves its efÔ¨Åciency by also incorpo-
rating packing in the computation steps. They do not use
any minimum circuit to identify the best match.
Instead,
matches were found by securely comparing distance values
with individual threshold values. In contrast to our work,
Sadeghi et al. [20] generated their garbled circuit using a
generic compiler FairplaySPF [17], which is in turn based
on Fairplay [11]. Such compilers are convenient, but cannot
take advantage of application-speciÔ¨Åc properties to develop
more efÔ¨Åcient custom circuits.
SCiFI [15] is a practical privacy-preserving face identi-
Ô¨Åcation system. It uses a component-based face identiÔ¨Åca-
tion technique with a binary index into a vocabulary repre-
sentation. The distance between faces is the Hamming dis-
tance between their bit-vectors. One notable design choice
the authors made for SCiFI is that both the secure Hamming
distance and secure minimum algorithms are purely based
on additive homomorphic encryption and oblivious trans-
fer. The authors present several optimization techniques
speciÔ¨Åc to their application.
In contrast, we argue that a
hybrid scheme combining both homomorphic encryption
and garbled circuits tends to be superior. They report that
identiÔ¨Åcation takes 31 seconds of online computation for a
database of size 100 (with 900-bit vectors, in comparison
to our 640-byte = 5120-bit vectors), while no bandwidth
consumption is reported. Rather than computing the global
minimum, their implementation produces the indexes of all
entries within a threshold value of the candidate.
The most similar work to ours is the privacy-preserving
Ô¨Ångerprint authentication by Barni et al. [1] which uses the
same FingerCode biometric as we do. Like Erkin et al.‚Äôs
approach, it is also a system based purely on homomorphic
encryption. They do not support the computation of global
minimum, but instead output the indexes of all matches
within some threshold. They report results from an exper-
iment with a database of 320x16 7-bit where their proto-
col completes in 16 seconds and uses 9.11MB bandwidth.
In contrast, our system‚Äôs performance results for the most
comparable but larger experiment are 3.47s and 3.76MB for
a database of 512x16 8-bit integers.
9 Conclusion
Privacy-preserving computation offers the promise of
obtaining results dependent on private data without expos-
ing that private data. The main drawback is that current pro-
tocols for privacy-preserving computations are very expen-
sive and impractical for real-scale problems. In this work,
we have shown that those costs can be substantially reduced
for a large class of biometric matching applications by de-
veloping efÔ¨Åcient protocols for Euclidean distance, Ô¨Ånding
the closest match, and retrieving the associated record. Our
approach involves using the normal by-products of a gar-
bled circuit evaluation to enable very efÔ¨Åcient oblivious in-
formation retrieval, and we believe this technique can be ex-
tended to many other applications. Our experimental results
support the hope that privacy-preserving biometrics are now
within reach for practical applications.
Acknowledgements
This work was partially supported by a MURI award
from the Air Force OfÔ¨Åce of ScientiÔ¨Åc Research, and grants
from the National Science Foundation and DARPA. The
contents of this paper do not necessarily reÔ¨Çect the posi-
tion or the policy of the US Government, and no ofÔ¨Åcial
endorsement should be inferred. The authors thank Yikan
Chen and Aaron Mackey for insightful discussions about
this work.
References
[1] M. Barni, T. Bianchi, D. Catalano, M. D. Raimondo,
R. D. Labati, P. Faillia, D. Fiore, R. Lazzeretti, V. Pi-
uri, F. Scotti, and A. Piva. Privacy-Preserving Finger-
In 12th ACM Multimedia and
code Authentication.
Security Workshop, 2010.
[2] A. Bazen and S. Gerez. Systematic Methods for the
Computation of the Directional Fields and Singular
Points of Fingerprints. IEEE Transactions on Pattern
Analysis and Machine Intelligence, 2002.
[10] Y. Lindell and B. Pinkas. A Proof of Security of
Yao‚Äôs Protocol for Two-Party Computation. Journal
of Cryptology, 22(2), 2009.
[11] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fair-
play ‚Äî A Secure Two-Party Computation System. In
USENIX Security Symposium, 2004.
[12] D. Maltoni, D. Maio, A. Jain, and S. Prabhakar. Hand-
book of Fingerprint Recognition. Springer, 2009.
[13] M. Naor and B. Pinkas. EfÔ¨Åcient Oblivious Transfer
Protocols. In ACM-SIAM Symposium on Discrete Al-
gorithms, 2001.
[14] M. Naor and B. Pinkas. Computationally Secure
Journal of Cryptology, 18(1),
Oblivious Transfer.
2005.
[15] M. Osadchy, B. Pinkas, A. Jarrous, and B. Moskovich.
SCiFI: A System for Secure Face IdentiÔ¨Åcation.
In
IEEE Symposium on Security and Privacy (Oakland),
2010.
[3] A. Bazen, G. Verwaaijen, S. Gerez, L. Veelenturf, and
B. van Der Zwaag. A Correlation-Based Fingerprint
In ProRISC2000 Workshop on
VeriÔ¨Åcation System.
Circuits, Systems and Signal Processing, 2000.
[16] P. Paillier. Public-key Cryptosystems Based on Com-
In 17th Interna-
posite Degree Residuosity Classes.
tional Conference on Theory and Application of Cryp-
tographic Techniques (EUROCRYPT), 1999.
[4] D. Beaver. Precomputing Oblivious Transfer. In 15th
International Conference on Cryptology (CRYPTO),
1995.
[5] Z. Erkin, M. Franz, J. Guajardo, S. Katzenbeisser,
I. Lagendijk, and T. Toft. Privacy-Preserving Face
Recognition. In 9th International Symposium on Pri-
vacy Enhancing Technologies, 2009.
[6] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank. Extend-
ing Oblivious Transfers EfÔ¨Åciently. In 23rd Interna-
tional Conference on Cryptology (CRYPTO), 2003.
[7] A. Jain, S. Prabhakar, L. Hong, and S. Pankanti.
Filterbank-Based Fingerprint Matching. IEEE Trans-
actions on Image Processing, 2000.
[8] V. Kolesnikov, A. Sadeghi, and T. Schneider.
Im-
proved Garbled Circuit Building Blocks and Applica-
tions to Auctions and Computing Minima. In Cryptol-
ogy and Network Security, 2009.
[9] V. Kolesnikov and T. Schneider.
Improved Garbled
Circuit: Free XOR Gates and Applications. In 35th In-
ternational Colloquium on Automata, Languages and
Programming (ICAPL), 2008.
[17] A. Paus, A. R. Sadeghi, and T. Schneider. Practical
Secure Evaluation of Semi-Private Functions. In In-
ternational Conference on Applied Cryptography and
Network Security (ACNS), 2009.
[18] S. Prabhakar and A. Jain. Decision-Level Fusion in
Fingerprint VeriÔ¨Åcation. Pattern Recognition, 2002.
[19] A. Ross, A. Jain, and J. Reisman. A Hybrid Finger-
print Matcher. Pattern Recognition, 2003.
[20] A. Sadeghi, T. Schneider, and I. Wehrenberg. EfÔ¨Åcient
Privacy-Preserving Face Recognition. In International
Conference on Information Security and Cryptology,
2009.
[21] H. Xu, R. Veldhuis, A. Bazen, T. Kevenaar, T. Akker-
mans, and B. Gokberk. Fingerprint VeriÔ¨Åcation us-
ing Spectral Minutiae Representations. IEEE Trans-
actions on Information Forensics and Security, 2009.
[22] A. C. Yao. How to Generate and Exchange Secrets. In
27th Symposium on Foundations of Computer Science,
1986.
Appendix: Oblivious Transfer Protocol
Our protocol is summarized in Figure 8. It combines
the protocols from Naor and Pinkas [13] (which we refer
to as NPOT) and Ishai et al. [6] using an aggressive pre-
computation strategy to produce an efÔ¨Åcient OT protocol.
We denote the ith column vector of a matrix T by ti,
and the ith row vector of T by ti. The preparation phase
can be done before any of the selection bits are known.
At the end of the preparation phase, SNDER has k1 keys
AOisi, and RCVER has k1 key pairs AOi0 AOi1, where
1 ‡£ò i ‡£ò k1. These keys are later used to transmit the ma-
trix 3 efÔ¨Åciently. By using pre-computation, the on-line
phase of our OT implementation requires only 2k1  m
symmetric encryptions and k1  m symmetric decryptions.
The correctness and security of this protocol follow di-
rectly from the proofs for NPOT [13] and Ishai et al.‚Äôs ex-
tended OT protocol [6].
Correctness. The RCVER can learn xiri for all 1 ‡£ò i ‡£ò m
following this case analysis:
1. If ri  0, then qi  ti no matter what value si takes.
Thus, RCVER knows the key ti, which is used to en-
crypt xi0.
2. When ri  1, the value of si selects whether qi 
ti or r ‡£∑ ti. However, this ‚Äúselection‚Äù effect is can-
celed by xor-ing s and qi, so that it is always true that
s‡£∑ qi  ti, which is the key used to encrypt xi1.
Security. The security of our protocol follows from these
two points:
1. The RCVER can never learn anything about xiri be-
cause it is encrypted using a different secret key which
differs from that used for xiri by s, the SNDER‚Äôs ran-
dom bit vector that is never revealed to the RCVER.
The security property of NPOT used in the preparation
phase guarantees that the selection bits of s are not re-
vealed to RCVER.
2. In the Ô¨Årst round of communication, either ti or r‡£∑ti is
sent to the SNDER, but not both. Thus, the fact that the
SNDER can never learn anything about the RCVER‚Äôs
selection bits r is derived directly from the security
property of NPOT used in the preparation phase [13].
The Oblivious Transfer Protocol
Input to SNDER: m pairs xi0xi1 of l-bit strings, where 1 ‡£ò i ‡£ò m.
Input to RCVER: m selection bits r  r1    rm.
Protocol Output: RCVER outputs x1r1 x2r2 xmrm while knowing nothing of x1r1 x2r2 xmrm. SNDER learns
nothing.
Preparation:
1. RCVER generates a m  k1 matrix 6 of random bits.
2. RCVER generates k1 pairs AOi AOi of k2-bit strings, where 1 ‡£ò i ‡£ò k1.
3. SNDER generates a vector s s1    sk1
 of random bits.
4. RCVER and SNDER execute NPOT for k1 times, where RCVER acts as the sender, SNDER as the receiver. At the ith
execution of OT2
1, the message pair to send is AOi AOi, and the selection bit is si.
Execution:
SNDER
RCVER
z SNDER derives a bit matrix 3,
where qi  DecAOisi
ICisi . Then
the SNDER prepares m pairs
ICﬂ∞
i0 ICﬂ∞
i1 
Encqi xi0Encs‡£∑qi xi1, where
1 ‡£ò i ‡£ò m.
i  ICﬂ∞
yIC1     ICk1
.
‡¢é‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§
x RCVER prepares k1 pairs
ICi  ICi0 ICi1 
EncAOi
1 ‡£ò i ‡£ò k1.
tiEncAOi
r‡£∑ ti, where
{ ICﬂ∞
1     ICﬂ∞
m.
‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢§‡¢ê | ‡¢ò1 ‡£ò i ‡£ò m, RCVER outputs
xiri  Decti ICﬂ∞
iri .
Figure 8. The Oblivious Transfer Protocol.