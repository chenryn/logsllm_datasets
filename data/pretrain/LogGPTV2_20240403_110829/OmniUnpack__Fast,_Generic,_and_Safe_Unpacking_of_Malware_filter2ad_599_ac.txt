grant execution permission to p
emit event x(p)
else if t = WRITE then
remove execution permission from p
grant write permission to p
emit event w(p)
else
restore the original permissions of p
invoke the OS page fault handler
1
2
3
4
5
6
7
8
9
10
11
12
13
error. If the error is due to the W ⊕ X policy, the algo-
rithm generates the appropriate event for processing by
the OmniUnpack-based malware detector.
Because the granularity of our memory-access
monitoring is at page level, on the ﬁrst faulty access the
required page permissions are granted such that further
accesses of the same type do not cause any fault. This
makes our system signiﬁcantly faster than techniques
that track memory accesses at instruction granularity.
A downside of our monitoring scheme is that it is not
possible to tell which addresses are really accessed on
the page. We have to assume that memory accesses po-
tentially affect all addresses on a page. This assump-
tion could lead to the identiﬁcation of spurious unpack-
ing stages if a page contains non-overlapping writable
data and code. Nonetheless, our experience shows that
OmniUnpack is overall signiﬁcantly faster than existing
ﬁne-grained unpackers (see the experimental evaluation
of Section 5).
4.3. Monitoring System Calls
We intercept the system calls of interest (the ones
considered dangerous) through interposition on the
system-call dispatch table. Although by enforcing
stricter permissions on memory pages we could deter-
mine the program point where this invocation origi-
nated, we do not distinguish between dangerous system
calls invoked from existing program code and those in-
voked from newly generated code. If newly generated
code is present in the program memory, the code is ex-
ecuted, and the execution is followed by a dangerous
system call, we consider the unpacking stage concluded
and we trigger malware detection. The system call is
consequently allowed only if no malicious code is de-
tected. If, instead, a dangerous system call is invoked
before a previously-written page is executed, memory
scanning will not be triggered because no execution
of previously generated code has been observed so far.
To guarantee the ability to intercept further unpacking
stages, at the end of scanning, write permissions are re-
voked from all scanned pages.
4.4. User-Space Malware Detector
The system does not depend on a particular detec-
tion technique. The only desirable quality is perfor-
mance, because scanning is performed during the ex-
ecution of the program. OmniUnpack only provides a
detector with data to analyze and then authorizes, or
denies, the execution of such data according to the re-
sponse of the detector. If the detector adopted fails to
identify the presence of malicious code in memory, our
system will resume the execution because the response
of the detector is assumed to be correct.
The advantage of running the malware detector in
user-space is that a bug in the malware detector will
not compromise the stability of the whole system. This
setup is compatible with current commercial virus scan-
ners, which could be thus used in combination with Om-
niUnpack without signiﬁcant reengineering. Because it
is run as a separate process, the malware detector does
not have direct access to the memory of the suspicious
program. To avoid the overhead of copying the data to
scan from the suspicious program to the malware detec-
tor, we share the memory containing such data between
the two processes. Before invoking the user-space de-
tector, the kernel component maps in the virtual ad-
dress space of the malware detector process the pages
for which the analysis is required and communicates to
the detector the address and the amount of data to an-
alyze. The malware detector then scans the memory
region part of its address space.
The detection is triggered during the execution to
scan only the pages that potentially contain the newly
generated malicious code. Therefore, pages executed
without prior modiﬁcation do not trigger detection.
Such pages are analyzed after the program is loaded in
memory, but before the execution is started. The main
advantage of such approach is that, if the program is not
packed or self-modifying (i.e., most benign programs),
its execution is not slowed down beyond an initial one-
time memory scan. Thus, the performance of the Om-
niUnpack-based malware detector is comparable to that
of current virus detectors that scan the program at the
beginning of execution.
4.5. Requirements for Signatures
We identify three requirements that the signatures
used by the malware detector have to satisfy to guaran-
tee accurate detection.
First, the signature needs to characterize the real
malicious payload, not the packed code or the unpack-
436436
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:38:39 UTC from IEEE Xplore.  Restrictions apply. 
ing routine. An attacker can easily modify the malware
by applying a new layer of packing, by substituting the
unpacking routine with an equivalent one (e.g., adopt-
ing polymorphism), or by modifying the packed pay-
load (e.g., encrypting it with a different key). To effec-
tively identify all the new instances of the malware gen-
erated using such techniques, the signature must cap-
ture the original malicious payload, which remains un-
changed during all these obfuscations. As the malware
detector is invoked to scan both the code as it is loaded
in memory and the code generated at run-time, the Om-
niUnpack-based malware detector guarantees that the
original malicious payload will be scanned.
Second, the signature must characterize the frag-
ments of the original code of the malware that are avail-
able at the time a dangerous system call is made. Stan-
dard malware detectors identify malicious programs
off-line, before the execution. Our system instead per-
forms real-time detection and therefore it is essential
that we detect that a program is malicious before it
causes any damage to the system. To guarantee that
the malware is blocked in time, the signature should de-
scribe code that is present in memory when a dangerous
system call is about to damage the system.
Third, the signature should characterize a fragment
of the malware payload that is not modiﬁed between the
time it executes and the time the malware detector scans
it. Because we delay scanning until a dangerous sys-
tem call is invoked, unpacked code (part of the payload)
could be executed up to that invocation. The unpacked
code can erase itself right before the system-call invoca-
tion, thus evading detection. To improve the effective-
ness of the detector and to avoid any evasion attempts,
the signature should describe code that is necessarily
present when the system call is made.
We suspect that some of the signatures used by
malware detectors do not satisfy the requirements of our
system. For example, most ClamAV [4] signatures de-
scribe the data representing the packed code instead of
the original malicious payload. For our evaluation we
developed a custom database of appropriate signatures.
We could not analyze the signatures used by the com-
mercial malware detectors as their format is not known.
If those signatures do not satisfy the requirements of our
system they have to be replaced with others that satisfy
our requirements.
5. Experimental Evaluation
To evaluate the effectiveness and the performance
of OmniUnpack we performed three different experi-
ments. To assess performance, we compared the un-
packing time for OmniUnpack, for PolyUnpack [15],
and for the ClamAV unpacker [4]. To assess effec-
tiveness, we measured the detection rate of standard
ClamAV against the detection rate of the OmniUnpack-
based ClamAV. To determine whether OmniUnpack is
practical for continuous, real-time use, we measured its
overhead on benign programs.
The authors of PolyUnpack could not provide us
with a command-line implementation of their tool be-
cause of intellectual-property reasons. The PolyUnpack
version that is available online (Stand-Alone Version
0.2 from http://polyunpack.cc.gt.atl.ga.us/polyunpack.
zip) is prohibitively slow because of its continuous GUI
updates (for some packers, it took several hours to un-
pack the program). We implemented a simpliﬁed ver-
sion of PolyUnpack, with the goal of making it as fast
as possible. We used the Microsoft Windows Debug-
ging API to single-step the program execution automat-
ically. No other analysis or computation was done by
our PolyUnpack implementation before or during un-
packing.
ClamAV is an open-source virus scanner that in-
cludes a set of specialized unpacking algorithms. At the
time of writing this paper, it handled the following pack-
ers: UPX (all versions), FSG versions 1.3, 1.31, 1.33,
and 2.0, Petite 2.x, NsPack, wwpack32 1.20, MEW, Up-
ack, SUE, and Y0da Cryptor 1.3. We isolated the un-
packing components of ClamAV 0.90.2 and used them
in our tests.
Our test platform was an Intel Pentium4 3GHz with
2GB of RAM running GNU/Linux 2.6.9. All experi-
ments were performed in a Qemu virtual machine with
no KQemu acceleration [2]. To accurately model the
IA-32 behavior, our custom version of Qemu imple-
ments separated TLBs for data and instructions. The
guest OS was a standard installation of Microsoft Win-
dows XP SP2 equipped with OmniUnpack.
Our results can be summarized as follows:
• OmniUnpack was signiﬁcantly faster than PolyUn-
pack, performing unpacking in a few seconds
(within one order of magnitude of the fastest un-
packer, ClamAV). This effectively reduced un-
packing time from more then 100 seconds to 5 sec-
onds.
• OmniUnpack handled 80% of packed malware,
while ClamAV handled only about 15%. The un-
handled cases were due to current implementation
limitations of OmniUnpack.
• The overhead for benign programs was relatively
small: 6% for non packed programs and 11% for
packed programs.
5.1. Time to Unpack
We evaluated the performance of OmniUnpack with
respect to two current techniques for malware unpack-
ing, execution monitoring through debugging and algo-
437437
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:38:39 UTC from IEEE Xplore.  Restrictions apply. 
Time (secs.)
PolyUnpack timed out
z
{
}|
400
200
100
50
25
10
5
2
1
0
t
c
a
p
m
o
C
E
P
X
P
U
i
e
n
h
p
r
o
M
X
P
U
k
c
a
P
S
A
i
e
n
h
p
r
o
M
i
e
n
h
p
r
o
M
A
D
O
Y
x
o
B
e
o
M
l
X
P
U
G
S
F
G
S
F
Packer
OmniUnpack
PolyUnpack
ClamAV
Figure 4: Comparison of the performance of OmniUn-
pack with respect to PolyUnpack and ClamAV. Note
that the Y axis shows time in seconds on a logarithmic
scale.
rithmic unpacking. We chose PolyUnpack [15] as a rep-
resentative implementation of unpacking based on exe-
cution monitoring through debugging, and ClamAV [4]
for algorithmic unpacking.
The evaluation proceeded as follows:
for each
packed malware sample in our test set, we executed it
under OmniUnpack and recorded the program point at
the end of each unpacking stage and the time to reach
this program point. Each malware under OmniUnpack
execution was bounded by a 90-second timeout. We
then executed the same malware sample under our im-
plementation of PolyUnpack and recorded the time it
took PolyUnpack to reach the same program point, with
a timeout of 300 seconds. We also measured the time
required by the algorithmic unpackers of ClamAV. All
times reported here are wall-clock (total) time.
The test set was composed by malicious programs
collected from the Offensive Computing website [1] and
contained programs packed with standard packers, pro-
grams packed with customized versions of the publicly
available packers, and programs packed with unknown
packers (i.e., that no tool could identify).
The experimental evaluation shows that OmniUn-
pack is able to correctly monitor all the malicious pro-
grams and to detect the end of each unpacking stage,
independent of the packing algorithm. Furthermore, the
average number of unpacking stages per malware de-
tected was 7.14, while the average number of unpack-
ing stages detected using na¨ıve coarse-grained memory-
access tracking was 2089.70 (cf. Figure 2).
The results of the comparison of OmniUnpack,
PolyUnpack, and the ClamAV unpacker are reported in
Figure 4. For the ease of presentation we report only
the time requested to reach the end of the ﬁrst unpack-
ing stage. Consider the chart entry for UPX (the sec-
ond entry from the left). The left bar shows the time it
took OmniUnpack to reach the end of the ﬁrst unpacking
stage, the middle bar shows the time for PolyUnpack to
reach the same point, and the right bar indicates the total
time ClamAV took to unpack the program. In this test,
OmniUnpack was 20.56 times faster than PolyUnpack,
and only 5 times slower than ClamAV. These numbers
reﬂect the overall trend observed in our experiments,
where OmniUnpack signiﬁcantly outperforms PolyUn-
pack and is at most one order of magnitude slower than
ClamAV.
In several cases PolyUnpack was not able to com-
plete unpacking before the timeout expired. Similarly,
ClamAV failed to unpack some of the test samples.
OmniUnpack handled all samples efﬁciently, with times
close to optimal (i.e., to ClamAV). There were few cases
when ClamAV appeared to be slower than OmniUnpack
(e.g., for packer UPX in Figure 4). This is due to our
result-reporting methodology, which shows the Omni-
Unpack and PolyUnpack times for unpacking one stage
and the ClamAV time for unpacking all stages. For ex-
ample, in the case of UPX, OmniUnpack took longer
than ClamAV to unpack all stages, although in the ﬁrst
stage it was quicker than ClamAV.
5.2. Ability to Handle Unknown Packing Algo-
rithms
The beneﬁt of a general unpacking technique such
as OmniUnpack is that it supports binaries packed with
any arbitrary algorithms applied any number of times.
This is in contrast with specialized unpacking algo-
rithms, which can only manipulate binaries packed with
particular versions of particular packers. We compared
the detection rate of ClamAV (used in its full capacity of
malware detector) with that of ClamAV enhanced with
OmniUnpack. The OmniUnpack-enhanced ClamAV ap-
plies the OmniUnpack algorithm to detect newly gen-
erated code and then invokes ClamAV on the memory