### Memory-Access Monitoring and Permission Management

1. **Grant execution permission to `p`**.
2. **Emit event `x(p)`**.
3. **Else if `t = WRITE` then**:
   - **Remove execution permission from `p`**.
   - **Grant write permission to `p`**.
   - **Emit event `w(p)`**.
4. **Else**:
   - **Restore the original permissions of `p`**.
   - **Invoke the OS page fault handler**.

If an error occurs due to the W âŠ• X policy, the algorithm generates the appropriate event for processing by the OmniUnpack-based malware detector.

### Page-Level Memory-Access Monitoring

Our memory-access monitoring operates at the page level. On the first faulty access, the required page permissions are granted to prevent further faults of the same type. This approach is significantly faster than techniques that track memory accesses at the instruction level. However, it has the downside of not being able to pinpoint which addresses within a page are actually accessed. We must assume that all addresses on a page could be affected, which may lead to false positives if a page contains non-overlapping writable data and code. Despite this, our experience shows that OmniUnpack is significantly faster than existing fine-grained unpackers (see Section 5 for experimental evaluation).

### System Call Monitoring

We intercept system calls of interest (considered dangerous) through interposition on the system-call dispatch table. Although we could determine the program point where the invocation originated by enforcing stricter permissions on memory pages, we do not distinguish between dangerous system calls invoked from existing program code and those from newly generated code. If newly generated code is present in the program memory and a dangerous system call follows its execution, we consider the unpacking stage concluded and trigger malware detection. The system call is allowed only if no malicious code is detected. If a dangerous system call is invoked before a previously-written page is executed, memory scanning will not be triggered because no execution of previously generated code has been observed. To ensure the ability to intercept further unpacking stages, write permissions are revoked from all scanned pages at the end of scanning.

### User-Space Malware Detector

The system does not depend on a specific detection technique; performance is the key requirement as scanning is performed during program execution. OmniUnpack provides the detector with data to analyze and authorizes or denies the execution based on the detector's response. If the detector fails to identify malicious code, the system resumes execution, assuming the detector's response is correct.

Running the malware detector in user-space ensures that a bug in the detector will not compromise the entire system. This setup is compatible with current commercial virus scanners, which can be used with OmniUnpack without significant reengineering. The malware detector runs as a separate process, so it does not have direct access to the suspicious program's memory. To avoid the overhead of copying data, we share the memory containing the data to be analyzed between the two processes. The kernel component maps the required pages into the virtual address space of the malware detector process and communicates the address and amount of data to analyze. The malware detector then scans the memory region part of its address space.

Detection is triggered during execution to scan only the pages that potentially contain newly generated malicious code. Pages executed without prior modification do not trigger detection and are analyzed after the program is loaded into memory but before execution starts. This approach ensures that benign programs (which are not packed or self-modifying) are not slowed down beyond an initial one-time memory scan, making the performance of the OmniUnpack-based malware detector comparable to that of current virus detectors.

### Requirements for Signatures

We identify three requirements for the signatures used by the malware detector to ensure accurate detection:

1. **Characterize the Real Malicious Payload**: The signature must capture the original malicious payload, not the packed code or the unpacking routine. Attackers can easily modify the malware by applying new packing layers, substituting the unpacking routine, or modifying the packed payload. To effectively identify new instances of the malware, the signature must capture the unchanged malicious payload. Since the malware detector scans both the code as it is loaded in memory and the code generated at run-time, OmniUnpack guarantees that the original malicious payload will be scanned.

2. **Characterize Code at the Time of Dangerous System Calls**: The signature must describe the fragments of the original malware code available when a dangerous system call is made. Our system performs real-time detection, so it is essential to detect malicious behavior before it causes damage. The signature should describe code present in memory when a dangerous system call is about to cause harm.

3. **Characterize Unmodified Fragments**: The signature should describe a fragment of the malware payload that remains unmodified between the time it executes and the time the malware detector scans it. Unpacked code (part of the payload) could be executed up to the system-call invocation and might erase itself, evading detection. To improve the effectiveness of the detector and prevent evasion, the signature should describe code that is necessarily present when the system call is made.

Some signatures used by malware detectors, such as those in ClamAV, may not meet these requirements. For our evaluation, we developed a custom database of appropriate signatures. We were unable to analyze the signatures used by commercial malware detectors due to their proprietary formats. If these signatures do not meet our requirements, they must be replaced with ones that do.

### Experimental Evaluation

To evaluate the effectiveness and performance of OmniUnpack, we conducted three experiments:

1. **Performance Comparison**: We compared the unpacking time of OmniUnpack with PolyUnpack [15] and the ClamAV unpacker [4].
2. **Detection Rate**: We measured the detection rate of standard ClamAV against the detection rate of the OmniUnpack-based ClamAV.
3. **Overhead on Benign Programs**: We measured the overhead of OmniUnpack on benign programs.

#### Implementation and Test Setup

- **PolyUnpack**: The authors could not provide a command-line version due to intellectual property reasons. The available online version is slow due to continuous GUI updates. We implemented a simplified version using the Microsoft Windows Debugging API to single-step the program execution.
- **ClamAV**: An open-source virus scanner with specialized unpacking algorithms. We isolated the unpacking components of ClamAV 0.90.2 for our tests.
- **Test Platform**: Intel Pentium4 3GHz with 2GB RAM running GNU/Linux 2.6.9 in a Qemu virtual machine without KQemu acceleration. The guest OS was Microsoft Windows XP SP2 equipped with OmniUnpack.

#### Results

- **Performance**: OmniUnpack was significantly faster than PolyUnpack, reducing unpacking time from over 100 seconds to 5 seconds. It handled 80% of packed malware, while ClamAV handled only about 15%.
- **Overhead**: The overhead for benign programs was relatively small: 6% for non-packed programs and 11% for packed programs.

#### Time to Unpack

We evaluated the performance of OmniUnpack against PolyUnpack and ClamAV. The test set included malicious programs collected from the Offensive Computing website, packed with standard and customized packers, and unknown packers.

- **Comparison**: OmniUnpack outperformed PolyUnpack and was at most one order of magnitude slower than ClamAV.
- **Timeouts**: PolyUnpack and ClamAV failed to complete unpacking in some cases, while OmniUnpack handled all samples efficiently.

#### Handling Unknown Packing Algorithms

OmniUnpack supports binaries packed with any arbitrary algorithms, unlike specialized unpacking algorithms. We compared the detection rate of ClamAV with that of ClamAV enhanced with OmniUnpack. The enhanced ClamAV applies the OmniUnpack algorithm to detect newly generated code and then invokes ClamAV on the memory.