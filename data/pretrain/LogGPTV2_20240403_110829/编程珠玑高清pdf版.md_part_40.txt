或者在一个表中（例如21=65536个元素的表）执行查找，可以找出16位整数中为1的
位数。高速缓存的大小对你时单元的选择有何影响？
第二个方法是计算输入中每个输入单元中的数值，然后将该数值乘以该单元中为1
的位数。
8.R.G.Dromey编写了下面的代码来计算x[0..n-1]中的最大元素，使用x[n]作为哨兵：
 = 0
while i= 0; i--)
y =x*y + a[i]
计算多项式。他使用n乘法，并且比前面的代码快两倍。
第10章的答案
1.将所有访问压缩字段的高级语言指令编译成很多机器指令，而访问未压缩字段值
需要很少的指令。将记录解压缩之后，Feldman稍微增加了数据空间，但是也大大减少
了代码空间和运行时间。
2.一些读者建议存储（x,y,pointmum）三元组时如果x相同则根据y排序，然后可
以使用二分查找来查找给定的（x，y）对。如果已经根据x值（如上，在x相同的情况
下根据y排序）排序输入，那么本书中介绍的数据结构很容易建立。在row数组的
firstincol[i]和firstincol[i+1]-1之间格式化二分查找能够更快地查找该结构。注意，这些
y值按递增顺序出现，而且二分查找必须正确处理查找空子数组的情况。
4.Almanacs将城市间的距离作为三角数组存储在表中，这能将它们的空间减少一
半。有时，数学表仅存储函数的最少有效位数字。并且对于每行值，仅一次给出最多有
效位数字。电视节目表仅仅说明节目开始时间，从而节省空间（没有按照每30分钟的间
隔列出所有的节目）。
5.在该表中，Brooks使用了两种表示方法。函数在真实的答案之间，并且存储在数
组中的单个十进制数字说明了它们之间的区别。阅读了这个问题和答案之后，该版本的
两个读者认为，最近他们通过增补不同表中的近似函数解决了一些问题。
6.原始文件需要300KB的磁盘容量。将两个数字压缩到一个字节中能够将容量减
盘的容量为184KB）。使用表查找替代昂贵的/和%操作，这将消耗200个字节的主存，
但是将读取时间基本上减少到原来的成本。因此，200字节的主存换取了150KB的磁查
容量。很多读者都建议我使用编码c=（a>4和b=c&0xF
解码。JohnLinderman观察到“移位和掩码不仅能够比乘和除快，而且hexdump这类常
用工具能够使用可读形式显示解码的数据”。
第11章的答案
1.通常会过度使用排序来查找n个浮点数中的最小值和最大值。答案9说明了如何
bbs.theithome.com
---
## Page 222
208
部分问题的答案
在不排序的情况下更加快速地找到中间值，但是在一些系统上，可能使用排序更为简单
一些。排序非常适合于查找模式，但是散列的速度更快。查找平均值的代码的执行时间
和n成正比，首先进行排序操作的方案可能具有更高的数值精确度：参见问题14.4.b。
2.BobSedgewick观察到能够使用下面的不变式修改Lomuto的划分方案，从而从右
到左执行：
=1; i++)
ifx[i]>=t
swap(--m,i)
因为终止时x[mj=t，所以可以使用参数（1,m-1）和（m+1,u）进行递归，不需要其他swap。
Sedgewick也使用x[]作为哨兵，从而删除内循环中的一个测试条件：
m = i = u+1
do
while x[--i]= U
for ↑=[1,u]
return
if x[1].1ength=h;j-±h)
if（x[j-h]n U
bbs.theithome.com
---
## Page 224
210
部分问题的答案
return
swap(1,randint(1,u))
t =x[1];=1;j=u+1
1oop
do 1++; while i t
if i >j
break
temp=x[1];x[1]=x[j];x[j]= temp
swap(1,j)
if jk
select1(1,j-1,k)
由于函数在最后部分执行递归，因此可以将它转变为一个while循环。在排序和查
找的问题5.2.2～5.2.32中，Knuth说明程序平均通过3.4n次比较才能找到n个元素的中
间值。概率参数类似于答案2.A中的最差情况下的参数。
14.该版本的快速排序使用指向数组的指针。由于它仅仅使用两个参数x和n，我
发现只要读者理解概念x+j+1表示数组从位置x[j+1]开始，它甚至比qsort1简单。
void qsort5(int x[].int n)
nt i，j；
if (n S;
set::iterator i;
for(int j =n-m;j<n; j++) (
int t=bigrand%（j+1）;
if (S.find(t) = S.endO)
S.insert(t);// t not in S
else
S.insert(j):// t in S
for (1=S.beginO;1=S.endO;1)
1
cout<<+i<<"\n";
答案13.1使用不同的集合接口实现了同一个算法。Floyd的算法最初出现在1986年
8月出版的《CommunicationsoftheACM》的ProgrammingPearls专栏中，在我1988年