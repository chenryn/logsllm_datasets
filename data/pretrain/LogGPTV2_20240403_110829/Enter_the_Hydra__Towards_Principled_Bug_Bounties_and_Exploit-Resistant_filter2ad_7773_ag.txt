g(y) .
(6)
Finally, to recover our deﬁnition of an exploit gap in
Equation (1), we deﬁne the probability ˜Pone that at least
one of the programs fails:
(cid:18)20
N
(cid:19)−1 N
∑
l=1
(cid:19)(cid:18)20− y
(cid:18)y
(cid:19)
l
N − l
˜Pone =
20
∑
y=0
g(y) .
(7)
We can then deﬁne two different exploit gaps, one for
traditional N-version programming with majority voting,
and one for NNVP (where we abort unless all programs
fail identically). We have
gapma j =
˜Pone
˜Pmaj
and
gapNNV P ≥ ˜Pone
˜Pall
,
(8)
where the inequality for gapNNV P is because NNVP only
fails if all programs fail identically (the results in [21]
only give us an upper bound for this probability).
Using the estimated values g(y) from [21], we obtain:
N
3
5
NNVP
Majority Voting
74 ≤ gapNNV P ≤ 14,845
5 ≤ gapma j ≤ 189
5544 ≤ gapNNV P ≤ 801,741
13 ≤ gapma j ≤ 3399
In all cases, the lowest exploit gap is obtained for the
third work-load (denoted S1,0 in [21]), which has the low-
est failure rate overall.
If we combine all work-loads into one, and assume
that hackers sample uniformly from the test inputs used
in the experiment, we obtain:
N Majority Voting
2 N.A.
3
5
gapma j = 7
gapma j = 709
NNVP
gapNNV P ≥ 79
gapNNV P ≥ 4409
gapNNV P ≥ 282,605
Note that NNVP makes sense even in the case N =
2, and yields gaps that are multiple orders of magnitude
greater than the ones obtained with majority voting.
B Submarine Commitment Constructions
In this section, we present two constructions for Subma-
rine Commitments. The ﬁrst, in Appendix B.1, is our
preferred construction. It is simple and efﬁcient, but only
realizable with changes to Ethereum awaiting adoption
of EIP-86. The second, in Appendix B.3 is more in-
volved and expensive, but realizable today.
We note that players could in principle conceal true
commitments by sending dummy (regular) commitments
with random values $val ≥ $deposit—so that they are
indistinguishable from real commitments—but have a
“dummy” ﬂag that can be revealed to trigger a refund.
This approach turns out to be complicated and unwork-
able, though. A community of users would not in gen-
eral have an incentive to generate dummy trafﬁc and in-
cur transaction fees. A would-be claimant could generate
dummy trafﬁc to conceal her true commitment, but then
the very inception of dummy trafﬁc would signal a pend-
ing claim and incentivize A to release its withheld bug.
These problems motivate the use of Submarine Commit-
ments instead.
B.1 EIP-86-Based Construction
Our simple realization of Submarine Commitments in
Ethereum leverages a new EVM opcode, CREATE2, in-
troduced in EIP-86 (EIP stands for “Ethereum Improve-
ment Proposal”) and scheduled to be included in the
upcoming “Constantinople” hardfork.
CREATE2 cre-
ates new smart contracts, much like an already existing
CREATE opcode. Unlike CREATE, which does not include
a user-supplied value, CREATE2 computes the address of
1350    27th USENIX Security Symposium
USENIX Association
the created contract C as H(addrCreator,salt,codeC),
where addrCreator is the address of the contract’s cre-
ator, salt is a 256-bit salt value chosen by the creator,
codeC is the EVM byte code of C’s initcode, and H is
Keccak-256.
To realize a Submarine Commitment, we can use salt
to encode the inputs to the commit, key and addr(P). Let
Forwarder be a contract that sends any money received at
its address to BountyContract. A Submarine Commit-
ment involves these functions:
• Commit: P selects a witness key ←${0,1}(cid:96) for suitable
(cid:100)addr = H(addr(BountyContract),H(addr(P), key),code),
(cid:96) (e.g., (cid:96) = 256). P sends $deposit to address
where addr(BountyContract) is BountyContract’s
address and code is Forwarder’s EVM initcode.
• Reveal: P sends key and commitBlk (the block
number in which P committed) to BountyContract.
BountyContract veriﬁes that the commit indeed oc-
curred in block commitBlk (e.g. using Appendix B.2).
• DepositCollection: BountyContract creates an in-
stance of Forwarder at address (cid:100)addr using CREATE2. A
call to Forwarder sends $deposit to BountyContract.
B.2 Merkle-Patricia Proof Veriﬁcation
In order for Submarine Commitments to be secure
against front-running attacks, we need to verify that the
commit transaction indeed occurred in block commitBlk.
Otherwise, an adversary can wait until she observes the
“reveal” transaction τ and then front-run τ by including a
backdated “commit” and corresponding “reveal” in front
of τ. We can prevent this attack by having Contract ver-
ify that “commit” was indeed sent in block commitBlk
and that at least ρ blocks have elapsed since commitBlk
upon receiving a “reveal”. (Recall that the adversary can
roll back the blockchain by at most ρ blocks.)
Unfortunately, Ethereum provides no native capability
for smart contracts to verify that a transaction occurred
in a speciﬁc block. However, Ethereum’s block structure
enables efﬁcient veriﬁcation of Merkle-Patricia proofs of
(non-)inclusion of a given transaction in a block [37]:
all transactions in a block are organized in a Merkle-
Patricia Tree [57] mapping transaction indices to trans-
action data. The root hash of this tree is included in
the block header and the block header is hashed into the
block hash, which can be queried from inside a smart
contract by means of the BLOCKHASH opcode.
We implemented this veriﬁcation procedure in a smart
contract that takes a block number, the transaction data,
and a Merkle-Patricia proof of transaction inclusion as
inputs, and outputs accept or reject. We benchmarked
the gas cost of this contract by verifying the inclusion
of 25 transactions from the Ethereum blockchain. The
proof veriﬁcation has a mean cost of 207,800 gas (ap-
proximately 2.08 USD2). Note that this cost is only in-
curred when a bounty is being claimed, and has no im-
pact on “normal” transactions.
Proof of Cheat. We can reduce the gas cost of our
Submarine Commitment scheme by not performing a
Merkle-Patricia proof veriﬁcation on every “reveal”: in-
stead of requiring parties to prove that their “commit”
occurred in commitBlk, we only require them to pro-
vide commitBlk and the transaction data, but no Merkle-
Patricia proof. A party P can then submit a Proof of
Cheat, a Merkle-Patricia proof demonstrating that an ad-
versary A backdated their transaction: A had to claim the
existence of a non-existing transaction; therefore, there
will either be a different transaction or no transaction at
the purported transaction index in block commitBlk. If
the proof of cheat is accepted, A’s $deposit is given to P
and A’s “commit” and “reveal” are voided.
Competing parties can easily check each other’s com-
mits for correctness off-chain and provide a Proof of
Cheat if they witness a cheat. In this setting, P beneﬁts
from catching a malicious competitor A in two ways:
A’s claim is voided (potentially netting P the $bounty)
and A’s $deposit is given to P.
B.3 CREATE-Based Construction
In Appendix B.1, we gave a construction of Subma-
rine Commitments that requires the yet-to-be-introduced
CREATE2 opcode. Hereafter, we show a different con-
struction relying on the CREATE opcode, available in
Ethereum today. However,
the CREATE2-based con-
struction is simpler and has 98.5% lower gas costs than
the CREATE-based construction during deposit collection
(75,000 gas vs 5,000,000 gas, or 0.75 USD vs 50.00
USD respectively2).
When a contract C creates a new contract Cnew us-
ing the CREATE opcode, Cnew’s address is computed
as H(addr(C),nonce(C)), where nonce(C) a mono-
tonic counter of the number of contracts created by C.
(Ethereum’s state records this nonce for each contract.)
By chaining a series of contract creations and encod-
ing information in the associated nonce values, we can
compute an address for Submarine Commitments. Let
Contract be the contract that will receive Submarine
Commitments. Let Forwarder be a simple contract that
has two functions both of which abort if they aren’t being
called by Contract:
• Clone uses CREATE to spawn another Forwarder in-
stance at address H(addr(Forwarder),nonce(Forwarder)).
• Forward sends all funds held by the contract
to
Contract.
USENIX Association
27th USENIX Security Symposium    1351
Algorithm CreateForwarder(P, key)
nonces ← E(H(cid:48)(addr(P), key))
address ← addr(Contract)
for i = 1 to k
while no contract at address H(address, noncesi + 1)
call Clone on contract at address
address ← H(address, noncesi + 1)
//address now equals (cid:100)addr
Figure 7: Algorithm to create a Forwarder at address (cid:100)addr.
We now describe the three functions that make up a
Submarine Commitment:
• Commit: P selects a witness key ←${0,1}(cid:96) and com-
putes x := H(cid:48)(addr(Contract), key) for a suitable (cid:96) and
hash function H(cid:48) with codomain {0,1}(cid:96). Let A :=
addr(Contract) and let E : {0,1}(cid:96) → {0, . . . ,b−1}k be
the function that takes an integer (encoded as a binary
string) and reencodes it as a string of length k in base
b. P sends $deposit to address
(cid:100)addr = H(H(. . .H(A,E(x)1 +1) . . . ,E(x)k−1 +1),E(x)k +1) .
• Reveal: P sends key and a Merkle-Patricia proof that
she committed in the correct block (see Appendix B.2)
to BountyContract.
• DepositCollection: BountyContract repeatedly calls
the Clone function of appropriate Forwarder instances
until a Forwarder is created at (cid:100)addr. (See Figure 7 for
details.) BountyContract then calls Forward to make
this instance send the the deposit to BountyContract.
Figure 8: Size of anonymity set for Submarine Commit-
ments. We show the number of transactions (left) and the
fraction of transactions (right) per block that are a part of the
anonymity set, as a function of ρ, the size of the commit win-
dow. Statistics are computed by averaging 48 block sequences
of length ρ, starting at (hourly-spaced) blocks 4430000 +i·240
for i ∈ [0,47].
Figure 9: Histogram of transaction values in anonymity
set for Submarine Commitments. We set ρ = 100 and take
all transactions in the anonymity sets of 48 sequences of 100
blocks, starting at blocks 4430000 + i· 240 for i ∈ [0,47].
• A has never received or sent any transactions.
• A has no associated code (i.e. A is not a contract).
• A is not involved in any other transactions (internal or
(cid:1).
logb(2n)(cid:0)1 + b−1
Choosing n and b. Since we aren’t concerned with
collision attacks on H(cid:48), n = 80 provides sufﬁcient se-
curity. For n = 80, in the ROM, a choice of b = 4
minimizes the expected number of contract creations
In practice, we instantiate H(cid:48) as a
truncated version of Keccak-256 as this is the cheapest
cryptographic hash function available in the EVM. In our
prototype, a DepositCollection call costs 5,000,000 gas
with these parameters.
2
B.4 Analysis of Anonymity Set Size
Submarine Commitments rely on concealing “commit”
transactions in an anonymity set of unrelated transac-
tions: to prevent bug-withholding attacks, the “commit”
of the Submarine Commitment scheme must remain con-
cealed until the “reveal” is broadcast. Since a “commit”
is indistinguishable from a benign transaction sending
ether to a fresh address, a transaction to an address A
is a part of the anonymity set if:
• The (external) transaction is a regular send of a non-
zero amount of ether with an empty data ﬁeld.
A
external) during the commit window.
In the experiment Expbntyrace
analyzed in Section 5.4,
a commitment is revealed after ρ blocks, where it is as-
sumed that the adversary can rewind up to ρ blocks in the
blockchain. Figure 8 shows the size of the anonymity
set as a function of this commitment window ρ. Even
for ρ = 100 (i.e. a 25 minute rewind window at 15 sec-
s/block), average blocks still contain two transactions in
the anonymity set. Furthermore, 34 of the 48 blocks we
studied (70%) contained at least one transaction that is
part of the anonymity set. In a full commit window of
size ρ = 100, we get an anonymity set of approximately
200 transactions, over 2% of all transactions in period.
As Figure 9 shows,
the transaction values in the
anonymity set span a wide range. Commitments with
an associated value between 0.0001 ether and 10 ether
(approximately 10,000 USD2) are easily concealed.
1352    27th USENIX Security Symposium
USENIX Association
020406080100ρ(blocks)012345txsperblocktxsinanonymitysetfractioninanonymityset02468fractionofblock(%)−3−2−101log10(valueinether)0.00.10.20.30.4relativefrequency