var(
readerFooReader
writerFooWriter
)
//Createbuffertoholdinput/output.
❼input:=make([]byte,4096)
//Usereadertoreadinput.
s,err:=reader.Read(input)❽
iferr!=nil{
log.Fatalln("Unabletoreaddata")
}
fmt.Printf("Read%dbytesfromstdin\n",s)
//Usewritertowriteoutput.
s,err=writer.Write(input)❾
iferr!=nil{
log.Fatalln("Unabletowritedata")
}
fmt.Printf("Wrote%dbytestostdout\n",s)
}
Listing2-9:Areaderandwriterdemonstration(/ch-2/io-example/main.go)
Thecodedefinestwocustomtypes:FooReader❶and
FooWriter❹.Oneachtype,youdefineaconcrete
implementationoftheRead([]byte)function❷forFooReaderand
theWrite([]byte)function❺forFooWriter.Inthiscase,both
functionsarereadingfromstdin❸andwritingtostdout❻.
NotethattheReadfunctionsonbothFooReaderandos.Stdin
returnthelengthofdataandanyerrors.Thedataitselfis
copiedintothebyteslicepassedtothefunction.Thisis
consistentwiththeReaderinterfaceprototypedefinition
providedearlierinthissection.Themain()functioncreatesthat
slice(namedinput)❼andthenproceedstouseitincallsto
FooReader.Read([]byte)❽andFooReader.Write([]byte)❾.
Asamplerunoftheprogramproducesthefollowing:
$gorunmain.go
in>helloworld!!!
Read15bytesfromstdin
out>helloworld!!!
Wrote4096bytestostdout
CopyingdatafromaReadertoaWriterisafairlycommon
pattern—somuchsothatGo’siopackagecontainsaCopy()
functionthatcanbeusedtosimplifythemain()function.The
functionprototypeisasfollows:
funcCopy(dstio.Writer,srcio.Reader)(writtenint64,error)
Thisconveniencefunctionallowsyoutoachievethesame
programmaticbehaviorasbefore,replacingyourmain()
functionwiththecodeinListing2-10.
funcmain(){
var(
readerFooReader
writerFooWriter
)
if_,err:=io.Copy(&writer,&reader)❶;err!=nil{
log.Fatalln("Unabletoread/writedata")
}
}
Listing2-10:Usingio.Copy(/ch-2/copy-example/main.go)
Noticethattheexplicitcallstoreader.Read([]byte)and
writer.Write([]byte)havebeenreplacedwithasinglecallto
io.Copy(writer,reader)❶.Underthecovers,io.Copy(writer,reader)calls
theRead([]byte)functionontheprovidedreader,triggeringthe
FooReadertoreadfromstdin.Subsequently,io.Copy(writer,reader)
callstheWrite([]byte)functionontheprovidedwriter,resulting
inacalltoyourFooWriter,whichwritesthedatatostdout.
Essentially,io.Copy(writer,reader)handlesthesequentialread-then-
writeprocesswithoutallthepettydetails.
Thisintroductorysectionisbynomeansacomprehensive
lookatGo’sI/Oandinterfaces.Manyconveniencefunctions
andcustomreadersandwritersexistaspartofthestandardGo
packages.Inmostcases,Go’sstandardpackagescontainall
thebasicimplementationstoachievethemostcommontasks.
Inthenextsection,let’sexplorehowtoapplythese
fundamentalstoTCPcommunications,eventuallyusingthe
powervestedinyoutodevelopreal-life,usabletools.
CreatingtheEchoServer
Asiscustomaryformostlanguages,you’llstartbybuildingan
echoservertolearnhowtoreadandwritedatatoandfroma
socket.Todothis,you’llusenet.Conn,Go’sstream-oriented
networkconnection,whichweintroducedwhenyoubuilta
portscanner.BasedonGo’sdocumentationforthedatatype,
ConnimplementstheRead([]byte)andWrite([]byte)functionsas
definedfortheReaderandWriterinterfaces.Therefore,Connis
bothaReaderandaWriter(yes,thisispossible).Thismakes
senselogically,asTCPconnectionsarebidirectionalandcan
beusedtosend(write)orreceive(read)data.
AftercreatinganinstanceofConn,you’llbeabletosend
andreceivedataoveraTCPsocket.However,aTCPserver
can’tsimplymanufactureaconnection;aclientmustestablish
aconnection.InGo,youcanusenet.Listen(network,addressstring)to
firstopenaTCPlisteneronaspecificport.Onceaclient
connects,theAccept()methodcreatesandreturnsaConnobject
thatyoucanuseforreceivingandsendingdata.
Listing2-11showsacompleteexampleofaserver
implementation.We’veincludedcommentsinlineforclarity.
Don’tworryaboutunderstandingthecodeinitsentirety,as
we’llbreakitdownmomentarily.
packagemain
import(
"log"
"net"
)
//echoisahandlerfunctionthatsimplyechoesreceiveddata.
funcecho(connnet.Conn){
deferconn.Close()
//Createabuffertostorereceiveddata.
b:=make([]byte,512)
❶for{
//Receivedataviaconn.Readintoabuffer.
size,err:=conn.Read❷(b[0:])
iferr==io.EOF{
log.Println("Clientdisconnected")
break
}
iferr!=nil{
log.Println("Unexpectederror")
break
}
log.Printf("Received%dbytes:%s\n",size,string(b))
//Senddataviaconn.Write.
log.Println("Writingdata")
if_,err:=conn.Write❸(b[0:size]);err!=nil{
log.Fatalln("Unabletowritedata")
}
}
}
funcmain(){
//BindtoTCPport20080onallinterfaces.
❹listener,err:=net.Listen("tcp",":20080")
iferr!=nil{
log.Fatalln("Unabletobindtoport")
}
log.Println("Listeningon0.0.0.0:20080")
❺for{
//Waitforconnection.Createnet.Connonconnectionestablished.
❻conn,err:=listener.Accept()
log.Println("Receivedconnection")
iferr!=nil{
log.Fatalln("Unabletoacceptconnection")
}
//Handletheconnection.Usinggoroutineforconcurrency.
❼goecho(conn)
}
}
Listing2-11:Abasicechoserver(/ch-2/echo-server/main.go)
Listing2-11beginsbydefiningafunctionnamed
echo(net.Conn),whichacceptsaConninstanceasaparameter.It
behavesasaconnectionhandlertoperformallnecessaryI/O.
Thefunctionloopsindefinitely❶,usingabuffertoread❷
andwrite❸datafromandtotheconnection.Thedataisread
intoavariablenamedbandsubsequentlywrittenbackonthe
connection.
Nowyouneedtosetupalistenerthatwillcallyour
handler.Asmentionedpreviously,aservercan’tmanufacture
aconnectionbutmustinsteadlistenforaclienttoconnect.
Therefore,alistener,definedastcpboundtoport20080,is
startedonallinterfacesbyusingthenet.Listen(network,address
string)function❹.
Next,aninfiniteloop❺ensuresthattheserverwill
continuetolistenforconnectionsevenafteronehasbeen
received.Withinthisloop,youcalllistener.Accept()❻,afunction
thatblocksexecutionasitawaitsclientconnections.Whena
clientconnects,thisfunctionreturnsaConninstance.Recall
fromearlierdiscussionsinthissectionthatConnisbothaReader
andaWriter(itimplementstheRead([]byte)andWrite([]byte)
interfacemethods).
TheConninstanceisthenpassedtotheecho(net.Conn)handler
function❼.Thiscallisprefacedwiththegokeyword,making
itaconcurrentcallsothatotherconnectionsdon’tblockwhile
waitingforthehandlerfunctiontocomplete.Thisislikely
overkillforsuchasimpleserver,butwe’veincludeditagain
todemonstratethesimplicityofGo’sconcurrencypattern,in
caseitwasn’talreadyclear.Atthispoint,youhavetwo
lightweightthreadsrunningconcurrently:
Themainthreadloopsbackandblocksonlistener.Accept()whileitawaits
anotherconnection.
Thehandlergoroutine,whoseexecutionhasbeentransferredtothe
echo(net.Conn)function,proceedstorun,processingthedata.
ThefollowingshowsanexampleusingTelnetasthe
connectingclient:
$telnetlocalhost20080
Trying127.0.0.1...
Connectedtolocalhost.
Escapecharacteris'^]'.
testoftheechoserver
testoftheechoserver
Theserverproducesthefollowingstandardoutput:
$gorunmain.go
2020/01/0106:22:09Listeningon0.0.0.0:20080
2020/01/0106:22:14Receivedconnection
2020/01/0106:22:18Received25bytes:testoftheechoserver
2020/01/0106:22:18Writingdata
Revolutionary,right?Aserverthatrepeatsbacktothe
clientexactlywhattheclientsenttotheserver.Whatauseful
andexcitingexample!It’squiteatimetobealive.
ImprovingtheCodebyCreatingaBufferedListener
TheexampleinListing2-11worksperfectlyfinebutrelieson
fairlylow-levelfunctioncalls,buffertracking,anditerative
reads/writes.Thisisasomewhattedious,error-proneprocess.
Fortunately,Gocontainsotherpackagesthatcansimplifythis
processandreducethecomplexityofthecode.Specifically,
thebufiopackagewrapsReaderandWritertocreateabufferedI/O
mechanism.Theupdatedecho(net.Conn)functionisdetailedhere,
andanexplanationofthechangesfollows:
funcecho(connnet.Conn){
deferconn.Close()
❶reader:=bufio.NewReader(conn)
s,err:=reader.ReadString('\n')❷
iferr!=nil{
log.Fatalln("Unabletoreaddata")
}
log.Printf("Read%dbytes:%s",len(s),s)
log.Println("Writingdata")
❸writer:=bufio.NewWriter(conn)
if_,err:=writer.WriteString(s)❹;err!=nil{
log.Fatalln("Unabletowritedata")
}
❺writer.Flush()
}
NolongerareyoudirectlycallingtheRead([]byte)and
Write([]byte)functionsontheConninstance;instead,you’re
initializinganewbufferedReaderandWritervia
NewReader(io.Reader)❶andNewWriter(io.Writer)❸.Thesecallsboth
take,asaparameter,anexistingReaderandWriter(remember,
theConntypeimplementsthenecessaryfunctionstobe
consideredbothaReaderandaWriter).
Bothbufferedinstancescontaincomplementaryfunctions
forreadingandwritingstringdata.ReadString(byte)❷takesa
delimitercharacterusedtodenotehowfartoread,whereas
WriteString(byte)❹writesthestringtothesocket.Whenwriting
data,youneedtoexplicitlycallwriter.Flush()❺toflushwriteall
thedatatotheunderlyingwriter(inthiscase,aConninstance).
Althoughthepreviousexamplesimplifiestheprocessby
usingbufferedI/O,youcanreframeittousetheCopy(Writer,
Reader)conveniencefunction.Recallthatthisfunctiontakesas
inputadestinationWriterandasourceReader,simplycopying
fromsourcetodestination.
Inthisexample,you’llpasstheconnvariableasboththe
sourceanddestinationbecauseyou’llbeechoingthecontents
backontheestablishedconnection:
funcecho(connnet.Conn){
deferconn.Close()
//Copydatafromio.Readertoio.Writerviaio.Copy().
if_,err:=io.Copy(conn,conn);err!=nil{
log.Fatalln("Unabletoread/writedata")
}
}
You’veexploredthebasicsofI/OandappliedittoTCP
servers.Nowit’stimetomoveontomoreusable,relevant
examples.
ProxyingaTCPClient
Nowthatyouhaveasolidfoundation,youcantakewhat
you’velearneduptothispointandcreateasimpleport
forwardertoproxyaconnectionthroughanintermediary
serviceorhost.Asmentionedearlierinthischapter,thisis
usefulfortryingtocircumventrestrictiveegresscontrolsorto
leverageasystemtobypassnetworksegmentation.
Beforelayingoutthecode,considerthisimaginarybut
realisticproblem:Joeisanunderperformingemployeewho
worksforACMEInc.asabusinessanalystmakinga
handsomesalarybasedonslightexaggerationsheincludedon
hisresume.(DidhereallygotoanIvyLeagueschool?Joe,
that’snotveryethical.)Joe’slackofmotivationismatched
onlybyhisloveforcats—somuchsothatJoeinstalledcat
camerasathomeandhostedasite,joescatcam.website,
throughwhichhecouldremotelymonitorthedander-filled
fluffbags.Oneproblem,though:ACMEisontoJoe.They
don’tlikethathe’sstreaminghiscatcam24/7in4Kultra
high-def,usingvaluableACMEnetworkbandwidth.ACME
hasevenblockeditsemployeesfromvisitingJoe’scatcam
website.
Joehasanidea.“WhatifIsetupaport-forwarderonan
internet-basedsystemIcontrol,”Joesays,“andforcethe
redirectionofalltrafficfromthathosttojoescatcam.website?”
Joechecksatworkthefollowingdayandconfirmshecan
accesshispersonalwebsite,hostedatthejoesproxy.com
domain.Joeskipshisafternoonmeetings,headstoacoffee
shop,andquicklycodesasolutiontohisproblem.He’ll
forwardalltrafficreceivedathttp://joesproxy.comto
http://joescatcam.website.
Here’sJoe’scode,whichherunsonthejoesproxy.com
server:
funchandle(srcnet.Conn){
dst,err:=net.Dial("tcp","joescatcam.website:80")❶
iferr!=nil{
log.Fatalln("Unabletoconnecttoourunreachablehost")
}
deferdst.Close()
//Runingoroutinetopreventio.Copyfromblocking
❷gofunc(){
//Copyoursource'soutputtothedestination
if_,err:=io.Copy(dst,src)❸;err!=nil{
log.Fatalln(err)
}
}()
//Copyourdestination'soutputbacktooursource
if_,err:=io.Copy(src,dst)❹;err!=nil{
log.Fatalln(err)
}
}
funcmain(){
//Listenonlocalport80
listener,err:=net.Listen("tcp",":80")
iferr!=nil{
log.Fatalln("Unabletobindtoport")
}
for{
conn,err:=listener.Accept()
iferr!=nil{
log.Fatalln("Unabletoacceptconnection")
}
gohandle(conn)
}
}
StartbyexaminingJoe’shandle(net.Conn)function.Joe
connectstojoescatcam.website❶(recallthatthisunreachable
hostisn’tdirectlyaccessiblefromJoe’scorporate
workstation).JoethenusesCopy(Writer,Reader)twoseparate
times.Thefirstinstance❸ensuresthatdatafromtheinbound
connectioniscopiedtothejoescatcam.websiteconnection.
Thesecondinstance❹ensuresthatdatareadfrom
joescatcam.websiteiswrittenbacktotheconnectingclient’s
connection.BecauseCopy(Writer,Reader)isablockingfunction,
andwillcontinuetoblockexecutionuntilthenetwork
connectionisclosed,Joewiselywrapshisfirstcallto
Copy(Writer,Reader)inanewgoroutine❷.Thisensuresthat
executionwithinthehandle(net.Conn)functioncontinues,andthe
secondCopy(Writer,Reader)callcanbemade.
Joe’sproxylistensonport80andrelaysanytraffic
receivedfromaconnectiontoandfromport80on
joescatcam.website.Joe,thatcrazyandwastefulman,
confirmsthathecanconnecttojoescatcam.websitevia
joesproxy.combyconnectingwithcurl:
$curl-i-XGEThttp://joesproxy.com
HTTP/1.1200OK
Date:Wed,25Nov202019:51:54GMT
Server:Apache/2.4.18(Ubuntu)
Last-Modified:Thu,27Jun201915:30:43GMT
ETag:"6d-519594e7f2d25"
Accept-Ranges:bytes
Content-Length:109
Vary:Accept-Encoding
Content-Type:text/html
--snip--
Atthispoint,Joehasdoneit.He’slivingthedream,
wastingACME-sponsoredtimeandnetworkbandwidthwhile
hewatcheshiscats.Today,therewillbecats!
ReplicatingNetcatforCommandExecution
Inthissection,let’sreplicatesomeofNetcat’smore
interestingfunctionality—specifically,itsgapingsecurityhole.
NetcatistheTCP/IPSwissArmyknife—essentially,a
moreflexible,scriptableversionofTelnet.Itcontainsafeature
thatallowsstdinandstdoutofanyarbitraryprogramtobe
redirectedoverTCP,enablinganattackerto,forexample,turn
asinglecommandexecutionvulnerabilityintooperating
systemshellaccess.Considerthefollowing:
$nc–lp13337–e/bin/bash
Thiscommandcreatesalisteningserveronport13337.
Anyremoteclientthatconnects,perhapsviaTelnet,wouldbe
abletoexecutearbitrarybashcommands—hencethereason
thisisreferredtoasagapingsecurityhole.Netcatallowsyou
tooptionallyincludethisfeatureduringprogramcompilation.
(Forgoodreason,mostNetcatbinariesyou’llfindonstandard
Linuxbuildsdonotincludethisfeature.)It’sdangerous
enoughthatwe’llshowyouhowtocreateitinGo!
First,lookatGo’sos/execpackage.You’llusethatfor
runningoperatingsystemcommands.Thispackagedefinesa
type,Cmd,thatcontainsnecessarymethodsandpropertiesto
runcommandsandmanipulatestdinandstdout.You’ll
redirectstdin(aReader)andstdout(aWriter)toaConninstance
(whichisbothaReaderandaWriter).
Whenyoureceiveanewconnection,youcanusethe
Command(namestring,arg...string)functionfromos/exectocreatea
newCmdinstance.Thisfunctiontakesasparametersthe
operatingsystemcommandandanyarguments.Inthis
example,hardcode/bin/shasthecommandandpass-iasan