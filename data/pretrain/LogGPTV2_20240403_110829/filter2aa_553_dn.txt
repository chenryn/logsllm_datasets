的系统。我们将以1字节为例，讨论这种方法。二进制补码用1字节中的后7
位表示0～127，高阶位设置为0。目前，这种方法和符号量的方法相同。另
外，如果高阶位是1，表示的值为负。这两种方法的区别在于如何确定负
值。从一个9位组合100000000（256的二进制形式）减去一个负数的位组
合，结果是该负值的量。例如，假设一个负值的位组合是 10000000，作为
一个无符号字节，该组合为表示 128；作为一个有符号值，该组合表示负值
（编码是 
7的位为1），而且值为100000000-10000000，即
1000000（128）。因此，该数是-128（在符号量表示法中，该位组合表示
−0）。类似地，10000001 是−127，11111111 是−1。该方法可以表示−128～
+127范围内的数。
要得到一个二进制补码数的相反数，最简单的方法是反转每一位（即0
变为1，1变为0），然后加1。因为1是00000001，那么−1则是11111110+1，
或11111111。这与上面的介绍一致。
二进制反码（one’s-complement）方法通过反转位组合中的每一位形成
一个负数。例如，00000001是1，那么11111110是−1。这种方法也有一个
−0：11111111。该方法能表示-127～+127之间的数。
15.1.3 二进制浮点数
浮点数分两部分储存：二进制小数和二进制指数。下面我们将详细介
绍。
1.二进制小数
1136
一个普通的浮点数0.527，表示如下：
5/10 + 2/100 + 7/1000
从左往右，各分母都是10的递增次幂。在二进制小数中，使用2的幂作
为分母，所以二进制小数.101表示为：
1/2 + 0/4 + 1/8
用十进制表示法为：
0.50 + 0.00 + 0.125
即是0.625。
许多分数（如，1/3）不能用十进制表示法精确地表示。与此类似，许
多分数也不能用二进制表示法准确地表示。实际上，二进制表示法只能精确
地表示多个1/2的幂的和。因此，3/4和7/8可以精确地表示为二进制小数，但
是1/3和2/5却不能。
2.浮点数表示法
为了在计算机中表示一个浮点数，要留出若干位（因系统而异）储存二
进制分数，其他位储存指数。一般而言，数字的实际值是由二进制小数乘以
2的指定次幂组成。例如，一个浮点数乘以4，那么二进制小数不变，其指数
乘以2，二进制分数不变。如果一份浮点数乘以一个不是2的幂的数，会改变
二进制小数部分，如有必要，也会改变指数部分。
1137
15.2 其他进制数
计算机界通常使用八进制记数系统和十六进制记数系统。因为8和16都
是2的幂，这些系统比十进制系统更接近计算机的二进制系统。
15.2.1 八进制
八进制（octal）是指八进制记数系统。该系统基于8的幂，用0～7表示
数字（正如十进制用0～9表示数字一样）。例如，八进制数451（在C中写
作0451）表示为：
4×82+ 5×81+ 1×80= 297（十进制）
了解八进制的一个简单的方法是，每个八进制位对应3个二进制位。表
15.1列出了这种对应关系。这种关系使得八进制与二进制之间的转换很容
易。例如，八进制数0377的二进制形式是11111111。即，用111代替0377中
的最后一个7，再用111代替倒数第2个7，最后用011代替3，并舍去第1位的
0。这表明比0377大的八进制要用多个字节表示。这是八进制唯一不方便的
地方：一个3位的八进制数可能要用9位二进制数来表示。注意，将八进制数
转换为二进制形式时，不能去掉中间的0。例如，八进制数0173的二进制形
式是01111011，不是0111111。
表15.1 与八进制位等价的二进制位
15.2.2 十六进制
十六进制（hexadecimal或hex）是指十六进制记数系统。该系统基于16
的幂，用0～15表示数字。但是，由于没有单独的数（digit，即0～9这样单
1138
独一位的数）表示10～15，所以用字母A～F来表示。例如，十六进制数
A3F（在C中写作0xA3F）表示为：
10×162+3×161+ 15×160= 2623（十进制）
由于A表示10，F表示15。在C语言中，A～F既可用小写也可用大写。
因此，2623也可写作0xa3f。
每个十六进制位都对应一个4位的二进制数（即4个二进制位），那么两
个十六进制位恰好对应一个8位字节。第1个十六进制表示前4位，第2个十六
进制位表示后4位。因此，十六进制很适合表示字节值。
表15.2列出了各进制之间的对应关系。例如，十六进制值0xC2可转换为
11000010。相反，二进制值11010101可以看作是1101 
0101，可转换为
0xD5。
表15.2 十进制、十六进制和等价的二进制
介绍了位和字节的相关内容，接下来我们研究C用位和字节进行哪些操
作。C有两个操控位的工具。第 1 个工具是一套（6 个）作用于位的按位运
算符。第 2 个工具是字段（field）数据形式，用于访问 int中的位。下面将
简要介绍这些C的特性。
1139
15.3 C按位运算符
C 提供按位逻辑运算符和移位运算符。在下面的例子中，为了方便读者
了解位的操作，我们用二进制记数法写出值。但是在实际的程序中不必这
样，用一般形式的整型变量或常量即可。例如，在程序中用25或031或
0x19，而不是00011001。另外，下面的例子均使用8位二进制数，从左往右
每位的编号为7～0。
15.3.1 按位逻辑运算符
4个按位逻辑运算符都用于整型数据，包括char。之所以叫作按位
（bitwise）运算，是因为这些操作都是针对每一个位进行，不影响它左右两
边的位。不要把这些运算符与常规的逻辑运算符（&&、||和！）混淆，常规
的逻辑运算符操作的是整个值。
1.二进制反码或按位取反：～
一元运算符～把1变为0，把0变为1。如下例子所示：
～(10011010) // 表达式
(01100101)  // 结果值
假设val的类型是unsigned 
char，已被赋值为2。在二进制中，00000010
表示2。那么，～val的值是11111101，即253。注意，该运算符不会改变val
的值，就像3 * val不会改变val的值一样， val仍然是2。但是，该运算符确实
创建了一个可以使用或赋值的新值：
newval = ～val;
printf("%d", ～val);
如果要把val的值改为～val，使用下面这条语句：
1140
val = ～val;
2.按位与：&
二元运算符&通过逐位比较两个运算对象，生成一个新值。对于每个
位，只有两个运算对象中相应的位都为1时，结果才为1（从真/假方面看，
只有当两个位都为真时，结果才为真）。因此，对下面的表达式求值：
(10010011) & (00111101)  // 表达式
由于两个运算对象中编号为4和0的位都为1，得：
(00010001)  // 结果值
C有一个按位与和赋值结合的运算符：&=。下面两条语句产生的最终结
果相同：
val &= 0377;
val = val & 0377;
3.按位或：|
二元运算符|，通过逐位比较两个运算对象，生成一个新值。对于每个
位，如果两个运算对象中相应的位为1，结果就为1（从真/假方面看，如果
两个运算对象中相应的一个位为真或两个位都为真，那么结果为真）。因
此，对下面的表达式求值：
(10010011) | (00111101) // 表达式
除了编号为6的位，这两个运算对象的其他位至少有一个位为1，得：
(10111111) // 结果值
C有一个按位或和赋值结合的运算符：|=。下面两条语句产生的最终作
用相同：
1141
val |= 0377;
val = val | 0377;
4.按位异或：^
二元运算符^逐位比较两个运算对象。对于每个位，如果两个运算对象
中相应的位一个为1（但不是两个为1），结果为1（从真/假方面看，如果两
个运算对象中相应的一个位为真且不是两个为同为1，那么结果为真）。因
此，对下面表达式求值：
(10010011) ^ (00111101) // 表达式
编号为0的位都是1，所以结果为0，得：
(10101110)  // 结果值
C有一个按位异或和赋值结合的运算符：^=。下面两条语句产生的最终
作用相同：
val ^= 0377;
val = val ^ 0377;
15.3.2 用法：掩码
按位与运算符常用于掩码（mask）。所谓掩码指的是一些设置为开
（1）或关（0）的位组合。要明白称其为掩码的原因，先来看通过&把一个
量与掩码结合后发生什么情况。例如，假设定义符号常量MASK为2 （即，
二进制形式为00000010），只有1号位是1，其他位都是0。下面的语句：
flags = flags & MASK;
把flags中除1号位以外的所有位都设置为0，因为使用按位与运算符
（&）任何位与0组合都得0。1号位的值不变（如果1号位是1，那么 1&1得
1142
1；如果 1号位是0，那么 0&1也得0）。这个过程叫作“使用掩码”，因为掩
码中的0隐藏了flags中相应的位。
可以这样类比：把掩码中的0看作不透明，1看作透明。表达式flags 
&
MASK相当于用掩码覆盖在flags的位组合上，只有MASK为1的位才可见（见
图15.2）。
图15.2 掩码示例
用&=运算符可以简化前面的代码，如下所示：
flags &= MASK;
下面这条语句是按位与的一种常见用法：
ch &= 0xff; /* 或者 ch &= 0377; */
前面介绍过oxff的二进制形式是11111111，八进制形式是0377。这个掩
码保持ch中最后8位不变，其他位都设置为0。无论ch原来是8位、16位或是
其他更多位，最终的值都被修改为1个8位字节。在该例中，掩码的宽度为8
1143
位。
15.3.3 用法：打开位（设置位）
有时，需要打开一个值中的特定位，同时保持其他位不变。例如，一台
IBM PC 通过向端口发送值来控制硬件。例如，为了打开内置扬声器，必须
打开 
1 
号位，同时保持其他位不变。这种情况可以使用按位或运算符
（|）。
以上一节的flags和MASK（只有1号位为1）为例。下面的语句：
flags = flags | MASK;
把flags的1号位设置为1，且其他位不变。因为使用|运算符，任何位与0
组合，结果都为本身；任何位与1组合，结果都为1。
例如，假设flags是00001111，MASK是10110110。下面的表达式：
flags | MASK
即是：
(00001111) | (10110110)  // 表达式
其结果为：
(10111111)         // 结果值
MASK中为1的位，flags与其对应的位也为1。MASK中为0的位，flags与
其对应的位不变。
用|=运算符可以简化上面的代码，如下所示：
flags |= MASK;
同样，这种方法根据MASK中为1的位，把flags中对应的位设置为1，其
1144
他位不变。
15.3.4 用法：关闭位（清空位）
和打开特定的位类似，有时也需要在不影响其他位的情况下关闭指定的
位。假设要关闭变量flags中的1号位。同样，MASK只有1号位为1（即，打
开）。可以这样做：
flags = flags & ～MASK;
由于MASK除1号位为1以外，其他位全为0，所以～MASK除1号位为0
以外，其他位全为1。使用&，任何位与1组合都得本身，所以这条语句保持
1号位不变，改变其他各位。另外，使用&，任何位与0组合都的0。所以无
论1号位的初始值是什么，都将其设置为0。
例如，假设flags是00001111，MASK是10110110。下面的表达式：
flags & ～MASK
即是：
(00001111) & ～(10110110) // 表达式
其结果为：
(00001001)         // 结果值
MASK中为1的位在结果中都被设置（清空）为0。flags中与MASK为0的
位相应的位在结果中都未改变。
可以使用下面的简化形式：
flags &= ～MASK;
15.3.5 用法：切换位
1145
切换位指的是打开已关闭的位，或关闭已打开的位。可以使用按位异或
运算符（^）切换位。也就是说，假设b是一个位（1或0），如果b为1，则
1^b为0；如果b为0，则1^b为1。另外，无论b为1还是0，0^b均为b。因此，
如果使用^组合一个值和一个掩码，将切换该值与MASK为1的位相对应的
位，该
值与MASK为0的位相对应的位不变。要切换flags中的1号位，可以使用
下面两种方法：
flags = flags ^ MASK;
flags ^= MASK;
例如，假设flags是00001111，MASK是10110110。表达式：
flags ^ MASK
即是：
(00001111) ^ (10110110)  // 表达式
其结果为：
(10111001)         // 结果值
flags中与MASK为1的位相对应的位都被切换了，MASK为0的位相对应
的位不变。
15.3.6 用法：检查位的值
前面介绍了如何改变位的值。有时，需要检查某位的值。例如，flags中
1号位是否被设置为1？不能这样直接比较flags和MASK：
if (flags == MASK)
puts("Wow!"); /* 不能正常工作 */
1146
这样做即使flags的1号位为1，其他位的值会导致比较结果为假。因此，
必须覆盖flags中的其他位，只用1号位和MASK比较：
if ((flags & MASK) == MASK)
puts("Wow!");
由于按位运算符的优先级比==低，所以必须在flags & MASK周围加上
圆括号。
为了避免信息漏过边界，掩码至少要与其覆盖的值宽度相同。
15.3.7 移位运算符
下面介绍C的移位运算符。移位运算符向左或向右移动位。同样，我们
在示例中仍然使用二进制数，有助于读者理解其工作原理。
1.左移：<<
左移运算符（<<）将其左侧运算对象每一位的值向左移动其右侧运算
对象指定的位数。左侧运算对象移出左末端位的值丢失，用0填充空出的位
置。下面的例子中，每一位都向左移动两个位置：
(10001010) << 2  // 表达式
(00101000)    // 结果值
该操作产生了一个新的位值，但是不改变其运算对象。例如，假设
stonk为1，那么 stonk<<2为4，但是stonk本身不变，仍为1。可以使用左移赋
值运算符（<<=）来更改变量的值。该运算符将变量中的位向左移动其右侧
运算对象给定值的位数。如下例：
int stonk = 1;