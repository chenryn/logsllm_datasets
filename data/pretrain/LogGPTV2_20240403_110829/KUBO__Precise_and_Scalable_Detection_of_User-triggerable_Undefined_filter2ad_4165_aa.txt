title:KUBO: Precise and Scalable Detection of User-triggerable Undefined
Behavior Bugs in OS Kernel
author:Changming Liu and
Yaohui Chen and
Long Lu
KUBO: Precise and Scalable Detection of User-triggerable
Undeﬁned Behavior Bugs in OS Kernel
Changming Liu
Northeastern University
PI:EMAIL
Yaohui Chen
Facebook Inc.
PI:EMAIL
Long Lu
Northeastern University
PI:EMAIL
Abstract—Undeﬁned Behavior bugs (UB) often refer to a wide
range of programming errors that mainly reside in software
implemented in relatively low-level programming languages e.g.,
C/C++. OS kernels are particularly plagued by UB due to their
close interactions with the hardware. A triggered UB can often
lead to exploitation from unprivileged userspace programs and
cause critical security and reliability issues inside the OS. The
previous works on detecting UB in kernels had to sacriﬁce
precision for scalability, and in turn, suffered from extremely
high false positives which severely impaired their usability.
We propose a novel static UB detector for Linux kernel, called
KUBO which simultaneously achieves high precision and whole-
kernel scalability. KUBO is focused on detecting critical UB that
can be triggered by userspace input. The high precision comes
from KUBO’s veriﬁcation of the satisﬁability of the UB-triggering
paths and conditions. The whole-kernel scalability is enabled by
an efﬁcient inter-procedural analysis, which incrementally walks
backward along callchains in an on-demand manner. We evaluate
KUBO on several versions of whole Linux kernels (including
drivers). KUBO found 23 critical UBs that were previously
unknown in the latest Linux kernel. KUBO’s false detection rate
is merely 27.5%, which is signiﬁcantly lower than that of the
state-of-the-art kernel UB detectors (91%). Our evaluation also
shows the bug reports generated by KUBO are easy to triage.
I .
I N T R O D U C T I O N
OS kernels provide critical system services and hardware
abstractions to applications. Its security and stability have
been the top priority for OS developers. However, bugs and
vulnerabilities are often inevitable in practice when developing
such large and complex codebases. As shown in the NVD
survey [1], on average over 400 new vulnerabilities are found
in the Linux kernel each year.
One class of the often exploited vulnerabilities in kernels
is Undeﬁned Behavior (UB) bugs, which, broadly speaking,
consist of all undeﬁned behaviors speciﬁed by the language
standard, for example, ANSI C [9] explicitly speciﬁes many
behaviors to be undeﬁned for softwares implemented in C
language. Typical examples of UB are integer overﬂow, division
by zero, null pointer deference, out-of-bound access, etc. UBs
are much broader in scope than many other speciﬁc bugs and
can cause a wide range of security and reliability issues [17],
[36].
Network and Distributed Systems Security (NDSS) Symposium 2021
21-25  February  2021, Virtual 
ISBN  1-891562-66-5
https://dx.doi.org/10.14722/ndss.2021.24461
www.ndss-symposium.org
When viewed individually out of program context, a UB
may seem fairly obvious and easy to detect because almost
every type of UB has its well-understood triggering condition
(i.e., UB condition) and is caused only by a few distinctive
instructions (i.e., UB instructions). For instance, an integer
overﬂow occurs when the result of an integer arithmetic
instruction goes out of the integer value range.
The previous works on detecting UB in the kernel mostly
followed the same basic idea. They focus on UB instructions in
code and try to determine if the corresponding UB conditions
can be satisﬁed. Some UB detectors [5] follow the dynamic
analysis approach and instrument every potential UB instruction
with runtime checks on the UB conditions. This approach
suffers from extra overhead and incompleteness i.e., struggle to
cover all code. Other UB detectors [38], [37] are purely static
and thus in theory can be complete. However, they trade preci-
sion for scalability by limiting themselves to intra-procedural
analysis. Therefore, these detectors produce extremely high
volumes of false positives (i.e., the majority of the detected
UBs are in fact infeasible or non-triggerable because the UB
conditions can never be met, which cannot be determined
by regional or intra-procedural analysis). Moreover, previous
works generally do not consider the actual consequence of
detected UBs. As shown in [13], many UBs, even if triggerable,
do not have a real harmful impact on programs as they are
often sanitized right after being triggered.
As a consequence, a scalable UB detector that can produce
high-quality bug reports is desired. However, the existing
detectors all fall short and often require an impractical amount
of manual efforts to validate reported bugs. For instance,
KINT [37] generated 125,172 bug reports on the Linux kernel
but only 17 of them were conﬁrmed after the team conducted
two bug review marathons that covered merely 838 of the
reports.
In this work, we propose KUBO (Kernel-Undeﬁned Behavior
Oracle), trying to bridge this gap that calls for scalable and
precise detection for critical UBs in the kernel.
KUBO focuses on critical UBs, which are triggerable by
userspace input. For instance, if the denominator of a division
operation is directly sourced from userspace input, it is con-
sidered a critical Denial-of-Service (DoS) bug as it can cause
an instant kernel panic. KUBO incorporates a new backward
userspace input tracking technique to check if a UB condition
is modiﬁed by such input.
To achieve scalable and high precision detection, KUBO
performs an on-demand incremental inter-procedural analysis,
starting from each UB instruction and tracing back to potential
userspace input sites. Named incremental call chain upwalk,
this analysis only backtracks to a selected caller function on a
callchain when needed. The need is determined by an empirical
UB triggerability indicator, called Bug Triggerability Indicator
(BTI). After BTI is analyzed to be true, KUBO then scans the
dependent parameters and only dive into the callers that taint
them. This design of inter-procedural analysis allows KUBO to
scale and analyze the entire kernel codebase without sacriﬁcing
the detection precession or ignoring inter-procedural data and
control dependencies as the previous work did.
KUBO collects path constraints along the way and solves
them together with the UB condition using an SMT solver[15],
which ensures that every detected UB is reachable and con-
trollable by userspace input. Thanks to the on-demand and
incremental nature of this analysis, KUBO overcomes the path-
explosion problem that prevents standard symbolic execution
from being scalable and analyzing large codebases. Finally,
KUBO analyzes the consequence of each detected UB via a
post-bug analysis, which checks if the value affected by a UB
instruction is later used in an unintended way.
Based on our evaluation § V, KUBO is able to scale to
the entire Linux kernel (including all drivers) and ﬁnishes
analyzing 27.8 million LoC in under 33 hours whilst 95%
of the subsystems are ﬁnished in 15 hours. We apply KUBO to
the latest Linux kernel. KUBO found 23 critical UB bugs that
are triggered by userspace inputs and pose a real impact on
the system. We report all these bugs to kernel developers and
received prompt and positive responses:
“Thanks for the bug report. The violating code enable
accessing the memory regions controlled by the BMC,
opening a security hole. It’s certainly not expected
behavior and should be ﬁxed...”
14 reported bugs have been conﬁrmed or patched so far.
Moreover, motivated by our report, one developer proposed to
replace all char with u8 in a module due to our ﬁndings of
the signed integer overﬂows directly triggerable by userspace
inputs.
We also evaluate KUBO in terms of its precision in two
controlled experiments using independently established ground
truth. When tested on an old kernel version, which contains 19
known UBs (CVEs), KUBO detects 12 of the 19 UBs (i.e., a
false negative rate of 36.8%). When tested on the latest kernel
version, KUBO reported a total of 40 UBs, among which 29 are
manually veriﬁed to be true bugs, scoring a false detection rate
of 27.5%. This is signiﬁcantly lower than that of the existing
UB detectors that can work on large codebases [37] (91%). A
false detection rate as low as ours was only achieved by some
UB detectors [29], [33], [43] that use much heavier analysis
techniques, solely focus on a subset of UB and cannot scale
to large codebases such as Linux kernels.
Overall, this paper makes the following contributions:
• Userspace triggerable bugs. KUBO focuses on detecting
UBs in OS kernel that can be triggered by userspace inputs.
It uses a light-weight, summary-based dataﬂow analysis to
track UB’s dependencies on data fetch from userspace. As
a result, 23 critical userspace-triggerable UBs were found
in the Linux kernel. 14 of them have been conﬁrmed or
patched so far.
• High-precision detection. Unlike the previous works on
detecting UB in the kernels, which suffer from high false
positives, KUBO features a new inter-procedural analysis
that tracks data and control dependencies across function
calls.
• Scalable inter-procedural analysis. The on-demand, in-
cremental call chain upwalk analysis, centering around
user-controlled data, allows KUBO to analyze entire Linux
kernels by tracking inter-procedural dataﬂows.
• Open source. The source code of KUBO is available at
https://github.com/RiS3-Lab/kubo.
The rest of the paper is organized as follows. §II provides
the background of UB in kernel and the motivation of KUBO.
§III and §IV present the system design and implementation
details. We evaluate the effectiveness and precision of KUBO
in §V and discuss the limitations of KUBO in §VI. Finally, we
compare KUBO with related works in §VII and conclude the
paper in §VIII.
I I . B A C K G R O U N D A N D M O T I VAT I O N
A. Undeﬁned behaviors in kernel
Undeﬁned behaviors(UBs) , especially UBSan [4] instru-
mentable UBs, introduce both security and reliability problems
into the kernel. As studied by Xi et al. [38], when a code frag-
ment exhibits behaviors designated as undeﬁned by language
standard, the compiler is entitled to do aggressive optimization
by falsely assuming that UB would never happen and cause
disastrous side effect.
Other security issues caused by UB are also frequently
reported. For instance, integer overﬂow may lead to kernel space
code execution(CVE-2018-8781 [3]). To get a full picture of
the damages UB can cause, we surveyed the CVEs in Linux
kernel directly linked to a UB. Although there is no speciﬁc
common weakness enumeration (CWE) entry dedicated for
UB-related vulnerabilities, we found a large part of CWE-682
and its children to be relevant. We further expanded the list to
CWE 128, 190-197, 369, 468, 681, 682. Then we ﬁltered out
the CVEs that either its patch is unavailable or it is not directly
caused by a UB. As a result, we collected a set of 78 CVEs
caused by UB in the Linux kernel. The consequences of these
CVEs are shown in Table I. As shown in the table, a good
many of them have security implications, they are either directly
exploitable (e.g., a malicious user may craft a malformed input
and exploit the bug) or causing the system to crash (e.g., nullptr
dereference).
We further divide these 78 CVEs into two different groups,
the ﬁrst group, Seval, contains 19 most recent CVEs which
we use as groud truth to evaluate our tool’s accuracy. The
remaining 59 CVEs forms Ssurvey which is used to help us
make informed design choices.
B. Prior efforts on ﬁnding UB
Due to the severe problems introduced by UB, previous
researches [38], [37], [13], [29] trying to eradicate such bugs
face major drawbacks: They either cannot scale to large
2
DoS
47
Privilege Escalation Memory Corruption
15
7
Arbitrary Code Execution
5
Information Leak
3
Unknown
1
TABLE I: Survey for consequences caused by 78 UB related CVE in the Linux kernel obtained from CVE vulnerability description.
codebases like the kernel or struggle to produce high precision
results, which contains large number of false positives or low
impact bugs.
The reasons for these limitations are two folds. Firstly,
static analysis based approaches [40], [37] struggle to balance
between scalability and precision. On one hand, expensive
inter-procedural analysis (that are ﬂow- and context- sensitive)
consume too much resource when analyzing the kernel. On
the other hand, light-weight analysis often has limited analysis
scope, thus suffers from a high volume of false positives due
to the loss of inter-procedural context. For instance, KINT [37]
focus on ﬁnding integer overﬂows in the kernel, reported over
125K cases, and only a fraction of them was conﬁrmed as true
bugs.
The second, which is unique to UB, is that the tool needs
to prove the triggered UB indeed has a real impact on the
program (e.g., correctness, stability, or security). Such impact
varies largely in different program contexts. For instance,
SAVIOR [13] is a hybrid fuzzing tool aiming to detect UB bugs.
It instruments the program under test with Undeﬁned Behavior
Sanitizer (UBSAN) [4]. As a result, all the UBs reported by
SAVIOR are considered true bugs1. However, out of the 481
UBSAN bug reports, 238 of them are deemed harmless by the
developers (i.e., triggering these bugs does not have any impact
on the affected program). We refer interested readers to their
paper for a more detailed discussion.
Due to this extra level of complexity, simply submitting
the bug reports from existing automatic tools without ﬁrst
conducting a non-trivial manual analysis may face strong
pushback from the developers. As one example:
“You need to make deep investigations on your own,
before sending mails to the developer mailing list.
Static analysis tools having too many false positive
are not worth the time spent by humans.”
Such experience motivates us to develop an automatic UB
detector for the kernel that only reports high precision and
critical UBs, namely, the UB is triggerable by userspace inputs
and once triggered, has real system impact.
C. Severity of kernel UBs
One major factor affecting the severity of UB in the kernel is
whether the UB can be easily triggered by malicious userspace
code, namely how much effort does it take for an ill-intent actor
to exploit the UB.
As mentioned in Section II-B, the impact of UBs varies
greatly under different program contexts, they range from
harmless low severity to critical exploitable bugs. For instance,
if an array index can be set to an arbitrary value without
checking via triggering an integer overﬂow, and the value is
directly passed in from userspace (e.g.,ioctl), such a bug is
considered high severity as the system can be easily exploited
by userspace code. On the contrary, if the triggering condition
is out of the user’s control or even purely random, such a bug
would be considered having less impact. For instance, Figure 1
shows a UB patch for CVE-2018-13053. In order to trigger
this bug, a large timeout is required to overﬂow this value. As
a result, this bug is rated as low severity–with very minimal
impact and exploitability [2].
Inspired by this observation, we aim to focus our automatic
analysis on ﬁnding UBs that are directly triggerable or con-
trolled by the most straightforward attack surface–user-facing
interfaces such as data fetch [40] and system calls (e.g.,ioctl).
As shown in Section V, this design choice allows us to ﬁnd
more critical UBs–those with security impact on the kernel.
I I I . KUBO S Y S T E M D E S I G N
A. Key concepts and terms
Before we discuss the design details of KUBO, here we
explain several key concepts and terms necessary for under-
standing our design.
Userspace input: This represents a range of inputs to the
kernel from userspace programs. Such inputs are untrusted
TABLE II: All types of supported UB, and their triggering conditions.
V denotes the value that is instrumented and checked by UBSan for
the corresponding UB. i,ii... are the different conditions that if anyone
is met, the UB is deemed triggered.
Supported UBs