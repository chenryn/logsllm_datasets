### 优化后的文本

#### 9.2 调试与纠错

在调试过程中，有时需要添加额外的代码以辅助测试。这些代码虽然不是程序功能所必需的，但对测试工作至关重要。我们需谨慎处理，确保新增代码不会引入新的缺陷。完成修改后，重新编译并运行程序：

```bash
$ gcc -o debug2 debug2.c
$ ./debug2
```

程序输出可能因使用的UNIX（或Linux）版本和配置不同而有所差异。以下是两位作者系统上的输出示例：

- 作者A的系统：
  ```
  array[0] = {john, 2}
  array[1] = {alex, 1}
  array[3] = {bill, 3}
  array[2] = {null, -1}
  array[4] = {neil, 4}
  ```

- 作者B的系统：
  ```
  Segmentation fault
  ```

读者在自己的UNIX系统上可能会看到上述两种情况之一。期望的结果是：

```
array[0] = {alex, 1}
array[2] = {bill, 3}
array[1] = {john, 2}
array[3] = {neil, 4}
array[4] = {rick, 5}
```

显然，这段代码存在重大隐患。即使它能顺利运行到底，排序结果也不正确。如果程序因内存段冲突被终止，则说明操作系统检测到了对无效内存地址的访问，并为防止内存崩溃而终止了程序。

操作系统的无效内存访问检测能力取决于其硬件配置和内存管理实现方式。大多数系统分配给程序的内存通常比实际需求多一些，因此某些无效访问可能无法被检测到。这也是为什么并非所有UNIX版本都会报告内存段冲突的原因。

某些库函数（如`printf`）在特定情况下（例如使用空指针时）也能防止无效内存访问。

为了查找数组访问错误，可以增加数组元素的大小，从而提高错误发生的概率。例如，将`item`成员`data`扩大为一个包含4096个字符的数组。这样，对不存在的数组元素进行访问时，内存地址可能落在程序分配的内存边界之外。每个数组元素有4K的长度，因此错误访问的内存将落在边界外的0~4K范围内。

经过如此修改后的文件名为`debug3.c`，在两位作者的Linux系统上都出现了内存段冲突错误。以下是需要添加的代码和执行情况：

```c
/* 修改后的代码 */
char data[4096];
```

```bash
$ gcc -o debug3 debug3.c
Segmentation fault (core dumped)
$ ./debug3
```

尽管如此，某些Linux或UNIX版本仍可能不会产生内存段冲突错误。当C语言的ANSI标准定义某种行为为“未定义”时，实际上允许程序执行某些操作。这里的情况就是如此：我们编写了一个不符合规范的C程序，导致了未定义行为。

#### 9.2.2 代码审查

当程序运行结果与预期不符时，重新阅读代码是一个好方法。假设代码已经过复查，明显的漏洞已被排除。

代码审查是指一组开发人员逐字逐句地检查数百行代码的过程。无论代码量多少，这仍然是有效的技巧。一些工具可以帮助进行代码复查，编译器是最明显的一个。如果程序中有语法错误，编译器会发现并报告出来。

有些编译器还提供选项来警告可疑行为，如未初始化变量、条件判断中的赋值操作等。例如，GNU编译器提供了以下选项：

```bash
$ gcc -Wall -Wextra -pedantic -std=c99
```

这些选项将激活许多警告性检查和不常用的检查，帮助追踪程序错误。建议养成使用这些选项的习惯，特别是`-Wall`选项。

稍后我们将介绍`lint`和`LClint`等工具，它们类似于编译器，用于分析源代码并报告可能不正确的代码。

#### 9.2.3 取样法

取样法是指在程序中添加代码以收集更多运行时信息。常见的做法是添加`printf`语句，打印变量在不同阶段的值。这些额外的`printf`语句通常会在错误修复后删除。

有两种取样法技巧可以使用。第一种是通过C预处理器有选择地添加调试代码，只需重新编译即可添加或移除调试代码。例如：

```c
#ifdef DEBUG
    // 添加调试代码
#endif
```

另一种方法是使用更复杂的数值调试宏定义：

```c
#define BASIC_DEBUG 1
#define EXTRA_DEBUG 2
#define SUPER_DEBUG 4

if (DEBUG & EXTRA_DEBUG) {
    // 添加调试代码
}
```

在这种情况下，可以通过编译标志`-DDEBUG=5`激活所有调试信息。另一种方法是在程序中添加以下语句，以便在不需要调试时不必在命令行上定义`DEBUG`宏：

```c
#ifndef DEBUG
#define DEBUG 0
#endif
```

C预处理器还定义了一些有助于调试的宏，如表9-1所示：

| 宏定义 | 说明 |
|--------|------|
| `__LINE__` | 当前行号 |
| `__FILE__` | 当前文件名 |
| `__DATE__` | 编译日期 |
| `__TIME__` | 编译时间 |

动手试试：调试信息

请看下面的`cinfo.c`程序，如果在编译时开启调试状态，它将打印编译日期和时间。程序清单如下：

```c
#include <stdio.h>

int main() {
#ifdef DEBUG
    printf("Compiled: %s at %s\n", __DATE__, __TIME__);
    printf("This is line %d of file %s\n", __LINE__, __FILE__);
#endif
    exit(0);
}
```

编译并运行程序：

```bash
$ gcc -o cinfo -DDEBUG cinfo.c
$ ./cinfo
This is line 7 of file cinfo.c
Compiled: Aug 8 1999 at 11:15:21
```

#### 不需要重新编译的调试技巧

在继续学习新内容之前，介绍一种使用`printf`函数帮助调试的方法，无需重新编译。这个方法是增加一个全局调试标志变量和一个调试信息记录函数，使用户能够在命令行上通过`-d`选项切换调试模式。例如：

```c
if (debug) {
    write_debug(msg);
}
```

调试信息应输出到标准错误输出`stderr`，或者使用`syslog`函数记录系统日志。这种方法的好处是即使程序已发行，用户也可以自行打开调试功能进行诊断。缺点是程序长度会增加，但在大多数情况下，这对用户来说是透明的，不会显著影响性能。

#### 9.2.4 程序的受控执行

回到示例程序，现在可以确定它有一个漏洞。我们可以修改程序，添加代码打印变量值，或者使用调试器控制程序执行并查看状态。

UNIX系统上有多种调试器，如`adb`、`sdb`和`dbx`。复杂的调试器如`sdb`、`dbx`和GNU的`gdb`可以在源代码级检查程序状态。`gdb`还有一些用户友好的前端，如`xxgdb`、`tgdb`和`DDD`。Emacs编辑器也有`gdb-mode`，允许用户在程序上运行`gdb`、设置断点和查看当前执行的源代码行。

为了调试程序，需要在编译时添加一些选项。常用的是`-g`标志，它将生成包含调试信息的可执行文件。例如：

```bash
$ gcc -g -o debug3 debug3.c
```

调试信息会使可执行文件增大（最多可达10倍），但程序运行所需的内存不变。调试完成后，最好从发行版本中删除调试信息，以节省磁盘空间。

#### 9.3 使用gdb进行调试

我们将使用GNU调试器`gdb`调试程序。`gdb`是一个开源软件，支持多种UNIX平台，也是Linux系统默认的调试器。以下是启动`gdb`并调试程序的步骤：

```bash
$ gcc -g -o debug3 debug3.c
$ gdb debug3
```

`gdb`有详细的在线帮助信息，可以通过`info`程序或在Emacs中查阅。例如：

```gdb
(gdb) help
```

`gdb`本身是基于文本的，支持命令行编辑和快捷键。空白命令（直接按回车键）将重复执行最近的命令。使用`step`或`next`命令逐行单步执行程序时，这种设置非常有用。

我们可以用`run`命令执行程序。在`run`命令中给出的任何参数都将传递给程序。我们的示例程序不需要参数。

假设读者的系统也出现了内存段冲突错误。如果情况并非如此，请继续阅读。如果读者遇到过内存段冲突错误，学完这一章后应该知道如何解决。如果读者没有遇到内存段冲突错误，但想使用示例程序继续学习，请继续阅读。