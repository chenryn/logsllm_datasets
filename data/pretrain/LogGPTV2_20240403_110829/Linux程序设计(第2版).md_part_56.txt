printf (*array[&d)= (ks,ed)\n*,
*
40
/
i,axray[i).data. array[i] .key):
41
这些额外的代码严格说来并不是程序功能所必需的。我们加上它们完全是出于测试工作的
需要。我们必须谨慎从事，不能让添加的测试用代码又引人新的缺陷。现在，再次进行编译，
然后运行程序：
Scc -0 debug2 debug2.c
$./debug2
这样做会发生什么样的事情与你使用的UNIX（或Linux）具体版本和该版本的具体配置有
关，它在作者之一的系统上运行时会给出如下所示的输出：
array10j=[john.2}
array(1) = {alex, 1)
array[3]-(biil. 3}
array[2] = {{nu111, -1)
azray[4]、(nei1,4}
但它在另一位作者的系统（运行着另外一种Linux内核）上运行时给出的输出却是下面这样的：
加入jaVa编程群：524621833
---
## Page 295
第9章调试与纠错277
Segmentation fault
在读者的UNIX系统上，你可能会看到这两种输出情况之一。我们希望看到的结果是：
array[0]={alex, 1}
array[2] = (bi11,
array[1]= {john,
array[3](ne11, 4)
{f
array[4] - (rick, 5)
很明显，这段代码存在着重大隐患。即使它能一气呵成地运行到底，给出的排序结果也不
正确：面如果它的运行因内存段冲突被强行终止了，就说明操作系统向程序发送了一个信号，
说操作系统检测到了对无效内存地址的访问操作，为防止内存崩溃，半路终止了该程序的运行。
操作系统监测无效内存访问操作的能力取决于它的硬件配置和它在实现内存管理功能时所
采取的某些具体做法。在大多数系统上，操作系统分配给这个程序的内存一般都会比实际使用
所需要的大一些。如果无效内存访问操作发生在内存的这一部分，硬件是检测不到这些无效访
问的。这就是为什么并非所有版本的UNIX都会报告出现内存段冲突的原因。
有的库函数（比如printf）在某些特殊情况下（比如正使用着一个空指针的时候）
也会防止无效内存访问操作的发生。
在查找数组访问方面的错误时，增加数组元素的尺寸不失为一个好办法，因为这样可以增
加出现错误的概率。如果我们只是在数组的字节尾读一个字符，可能会看不到有问题发生，因
为分配给程序的内存一般都会延续到由操作系统设定的内存边界上去，边界一般以8K为单位逐
步扩大。
如果我们增大了数组元素的尺寸，比如在这个例子里我们把item成员data扩大为一个4096个
字符组成的数组，对不存在的数组元素进行访问时内存地址就有可能落在这个程序分配到的内
存边界以外的地方。数组的每个元素有4K的长度，所以我们错用了的内存将落在边界以外0~4K
的范围里。
我们给如此加工过的文件起名为debug3.c，它在两位作者的Linux系统上都出现了内存段冲
突错误。下面是需要加到程序里去的语句和程序的执行情况：
/*2*/char data[4096]:
S cc0debug3 debug3.c
Segmentation fault (core durped)
$./dabug3
但还是存在着这样的可能性，即某些个系列的Linux或UNIX操作系统依然不会产生内存段
冲突错误。当C语言的ANSI标准把某种行为定义为“未定义”的时候，实际上它还是允许程序
做些事情的。现在就遇到了这样的情况：我们写出了一个不合规范的C语言程序，而这个不合
的范畴。
9.2.2代码审查
我们刚才已经提到过，当一个程序的运行情况与我们的预期不相吻合的时候，重新阅读这
加入jaVva编程群：524621833
---
## Page 296
278Linx程序设计
个程序将是一个很好的做法。根据这一章的学习目的，我们将假设程序代码都已经通过了复查，
那些比较明显的漏洞都已经被排除了。
代码审查这个术语还代表着一个更正规的过程：一组开发人员逐字逐句地推敲数百
行代码。但代码行的多少并不重要，它还是代码审查，并且它仍然是一直有效的技巧。
有一些工具可以帮助你完成代码复查的工作，编译器就是其中比较明显的一个。如果积序
中有语法错误，它就会发现并报告出来。
有些编译器还有用来对可疑行为产生报警的选项，这些行为包括没有对变量进行初
始化、在条件判断里使用了赋值操作等。就拿GNU编译器来说吧，它在运行时可以使
用下面这些选项；
这些选项将激活许多警告性检查和一些不常用的检查，它们将对程序是否符合C语
言标准进行检验。我们建议大家养成使用这些选项的习惯，特别是“Wall”选项。因
它而产生的信息在追踪程序错误时非常有用。
我们将在稍后对lint和LClint等工具进行介绍。它们的作用与编译器差不多，都是对源代码
进行分析并把可能不正确的代码报告出来。
9.2.3取样法
取样法指的是在程序里添加一些代码的行为，这样做的目的是为了进一步收集与程序运行
时的行为有关的信息。增加printf语句的做法是很常见的，我们在刚才的例子里就采用了这一措
施，这样做的目的是为了打印出变量在程序运行不同阶段的值。这些额外添加的printf语句往往
会有好几个。需要提醒大家的是：只要对程序进行了修改，这一过程的结局肯定是多一次编辑
多一次编译：而且，在错误得到补数之后需要把这些额外的代码删除掉。
有两种取样法技巧可以在这里帮到我们。第一个办法是通过C语言的预处理器有选择地添上
一些取样代码，这样我们只需重新编译程序就能达到添上或去掉调试代码的目的。这个办法实
行起来很简便，一个下面这样的结构就能满足我们的要求：
#1fdef DEBUG
进行定义，添上额外的调试代码；如果不加上这个标志，就去掉之。我们还可以使用更复杂的
数值调试宏定义，就象下面这样：
#define BASIC_DEBUG
define EXTRA_DEBUG
define SUPER_DEBUG 4
if (DBBUG & EXTRA_DEBUG)
加入jaVa编程群：524621833
---
## Page 297
第9章调试与纠错
279
此时，我们必须对DEBUG宏进行定义，但我们可以设置它来代表一组调试信息，或者代表
一个调试控制层次。比如说，在我们的这个例子里，编译标志“-DDEBUG=5”代表激活
一切调试信息。另外一个办法是给程序添上下面这些语句，这样，当不再需要调试工作时就不
必在命令行上定义DEBUG宏了。如下所示：
ifndef DEBUC
define DEBUG 0
#endif
C语言预处理器已经定义了几个对调试纠错有帮助作用的宏定义。这些宏定义在扩展时会提
供当前编译操作的有关信息。如表9-1所示：
表9-1
宏定义
说明
_LINE..
一个代表当前行号的十进制常数
_FILB.
一个代表当前文件名的字符串
_DATE...
一个“Mrmm dd yyyy”形式的字符串，当前日期
_TIME_
一个“hhmmss”形式的字符申，当前时间
注意：这些宏定义前后各有两个下划线字符。预处理器的标准记号经常采用这种形式，用
执行的那一时刻，也就是运行编译器对文件进行处理时的时间和日期。
动手试试：调试信息
请看下面的cinfo.c程序，如果在对它进行编译时开启了调试状态，它就会打印出编译时的日
期和时间。下面是它的程序清单：
#include cstdio.h>
int nain()
itdet DgBUG
printf(*Compiled:
printfirhis is line ed of file as\n*_LINE_ _FILE_.):
._DATE
at
TEME
*\n*) :
endif
exit(0) ;
1
激活调试功能（用“-DDEBUG”选项）编译这个程序，我们将看到如下所示的编译信息：
5cc -o cinfo-DDzauG cinfo.c
S./cinfo
This is line 7 of file cinfo.c
Compiled: Aug_8 1999 at 11:15:21
hello world
操作注释：
C预处理器是编译器的组成部分之一，它对正在编译的当前行和当前文件进行跟踪记录。只
加入jaVa编程群：524621833
---
## Page 298
280Linux程序设计
要它遇见记号“__LINE__”和”__FILE__"，就会替换这些变量（在编译过程里）的当前值。
以用printf的格式字符串把它们合并起来。ANSIC允许把紧挨着的多个字符串当做一个字符串来
对待。
不需要重新编译的调试技巧
在继续学习新的内容之前，我们认为值得向大家介绍一个用printf函数帮助调试工作的技巧，
这个办法用不着微“#ifdefDEBUG”这样的设置，也不象后者那样需要重新编译才能开始对程
序的调试。
这个方法的要旨是在程序里增加一个被用做调试标志的全局变量和增加一个调试信息记录
函数，这就使得用户能够在命令行上通过“-d”选项切换调试模式的开关状态，即使程序已经发
行也还是可以这样做。现在我们可以把下面这些内容加到程序代码里去：
if(dehsg)(
write_debug(msg)
！
调试信息需要输出到标准错误输出stderr去；或者，如果因为程序的原因不能这样做，还可
以使用syslog函数提供的系统日志功能
代码留在程序里。只要你比较谨慎在意，这样做将是相当安全的。它的好处体现在程序发行之
后：如果用户遇到了麻烦，他们自已就能在运行这个程序的时候打开调试功能，替你完成诊断
什么事情，面不仅仅是报告用户本人正在于什么了。两者的差距是很明显的。
当然，这样做也有一个明显的不足之处，就是程序的长度会有所增加。但在大多数情况下，
这个问题对程序的使用者来说是透明的，算不上是一个实际意义上的问题。程序的长度可能会
增加20%或30%，但往往并不会对程序的执行性能造成真正的影响。一般来说，只有在程序长度
9.2.4程序的受控执行
现在回到我们的示例程序上，现在可以肯定地说它有一个漏洞。我们对程序进行修改，增
加一些代码把程序运行时的变量值打印出来；我们还可以用一个调试器（debugger）来控制程序
的执行，随时查看程序的执行状态。
UNIX系统上有许多种调试器，提供调试器的厂商也很多。比较常见的有adb、sdb和dbx等。
比较复杂的调试器能够让我们在源代码级对程序的状态进行检查。sdb、dbx和GNU的调试器gdb
都能够做到这一点，Linux系统经常使用的是gdb。gdb还有一些对用户更加友好的“操作前端”，
xxgdb、tgdb和DDD等就是一些这样的程序。Emacs编辑器也有一个类似的功能（即“gdb-mode”
gdb调试模式），它允许用户在程序上运行gdb、设置断点、查看现在执行到哪一行源代码等。
为了能够对程序进行调试，需要在对它进行编译的时候加上一个或几个编译器操作选项。
加入jaVa编程群：524621833
---
## Page 299
第9章调试与纠错
281
行号：调试器将利用这些信息通知我们程序已经执行到源代码的什么位置了：
-g”标志是对程序进行调试性编译时常用的选项。我们需要给每一个需要调试的源文件都
加上这个选项，对链接器（linker）也要这样做，它将使用特殊版本的C语言标准库完成编译和
链接操作，给库函数加上程序调试方面的支持。编译器会把这些标志自动传递给链接器。有些
函数库在其自身被编译的时候并没有考虑到程序调试方面的需要，如果使用了这类的函数库，
调试工作虽然还能够进行，但灵活性就要差些了
调试信息将使可执行文件的长度成倍增加（最高可以达到10倍的水平）。但尽管可执行文件
增大了（并且占用了更多的磁盘空间），程序运行所需要的内存还是和原来的一样。在程序的调
试工作结束之后，最好还是把调试信息从程序的发行版本里删除掉，这将节省不少磁盘空间。
9.3用gdb进行调试纠错
我们将使用GNU的调试器gdb对我们的程序进行调试。这个功能强大的调试器是一个白出软
件，能够用在许多UNIX平台上。它也是Linux系统上缺省使用的调试器。gdb已经被移植到许多
其他的计算机平台上了，并且能够用来对嵌人式实时系统进行调试。
9.3.1启动gdb
现在对我们的示例程序做调试性编译并启动gdb，如下所示：
5cc-g -o debug3 debug3.c
GNU gdb 4.17.0.11 with Linux support
cBqep qp5 S
Copyright 1998 Free Software Poundation, Inc.
welcome to change it and/or distribute copies of it under certain conditions
G8 is free software, covered by the GNU General Public License, and you are
Type *show copying* to see the conditions.
There ig abgolutely no warranty Eor GDB. Type “show warranty* for details.
(gdb)
gdb有详细的在线帮助信息，它完整的使用手册由几个文件组成，这些文件可以用info程序
或者在emacs里查阅。如下所示：
(gdb) help
List of classes of commands:
breakpoints- Making progran stop at certain pointg
aliases -- Aliases of other commands
Eiles -- Specifying and examining files
data -- Exanining data
internals -- Maintenance conmands
obscure --Obscure features
running -- Running the progran
stack .- Examining the stack
support- Support focilities
status -- Status inquiries
user-defincd -- User-defined commands
trucepoints -
Tracing ot progran execution without stopping the program
加入iaVa编程群：524621833
---
## Page 300
282
Linux程序设计
Typv *help foilowed by a class name for a list of commands in that class.
Cosmand name abbreviations are allowed if unambiguous.
(qdb)
gdb本身是一个基于文本的软件，但它为一些重复性操作准备了一些快捷键。它的许多版本
都具备带历史记录的命令行编辑功能，用户可以（用光标移动键）卷回以前输人过的命令再次
执行之。所有版本都支持空白命令，即直接按下回车键将再次执行最近执行过的那条命令。用
slep或nexit命令逐行单步执行程序时就能体会到这种设置的好处了。
9.3.2运行一个程序
我们可以用run命令来执行一个程序。在run命令中给出的任何参数都将被传递到程序去，它
们将被用做那个程序的参数。我们的示例程序不需要参数。
在这里，我们必须假设读者的系统和两位作者的一样，都出现了内存段冲突错误。如果情
况并非如此，请继续往下读。如果读者在自已编写的程序里遇见过内存段冲突错误，学完这一
章后就该知道怎样才能解决它。如果读者没有遇到内存段冲突错误，但还想用这个示例程序继