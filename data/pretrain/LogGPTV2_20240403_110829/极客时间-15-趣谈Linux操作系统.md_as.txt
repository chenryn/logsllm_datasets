## 任务状态作为一个项目经理，另外一个需要关注的是项目当前的状态。例如，在 Jira里面，任务的运行就可以分成下面的状态。![](Images/2479245ffedbfdd64cfd5e3a7eb4cad8.png){savepage-src="https://static001.geekbang.org/resource/image/e0/21/e0019fcd11ff1ba33a3389e285b6a121.jpg"}在 task_struct 里面，涉及任务状态的是下面这几个变量：     volatile long state;    /* -1 unrunnable, 0 runnable, >0 stopped */ int exit_state; unsigned int flags;state（状态）可以取的值定义在 include/linux/sched.h 头文件中。    /* Used in tsk->state: */#define TASK_RUNNING                    0#define TASK_INTERRUPTIBLE              1#define TASK_UNINTERRUPTIBLE            2#define __TASK_STOPPED                  4#define __TASK_TRACED                   8/* Used in tsk->exit_state: */#define EXIT_DEAD                       16#define EXIT_ZOMBIE                     32#define EXIT_TRACE                      (EXIT_ZOMBIE | EXIT_DEAD)/* Used in tsk->state again: */#define TASK_DEAD                       64#define TASK_WAKEKILL                   128#define TASK_WAKING                     256#define TASK_PARKED                     512#define TASK_NOLOAD                     1024#define TASK_NEW                        2048#define TASK_STATE_MAX                  4096从定义的数值很容易看出来，flags 是通过 bitset的方式设置的也就是说，当前是什么状态，哪一位就置一。![](Images/5439af56452d5322579faec9496920cd.png){savepage-src="https://static001.geekbang.org/resource/image/e2/88/e2fa348c67ce41ef730048ff9ca4c988.jpeg"}TASK_RUNNING并不是说进程正在运行，而是表示进程在时刻准备运行的状态。当处于这个状态的进程获得时间片的时候，就是在运行中；如果没有获得时间片，就说明它被其他进程抢占了，在等待再次分配时间片。在运行中的进程，一旦要进行一些 I/O 操作，需要等待 I/O完毕，这个时候会释放 CPU，进入睡眠状态。在 Linux 中，有两种睡眠状态。一种是**TASK_INTERRUPTIBLE**，**可中断的睡眠状态**。这是一种浅睡眠的状态，也就是说，虽然在睡眠，等待I/O完成，但是这个时候一个信号来的时候，进程还是要被唤醒。只不过唤醒后，不是继续刚才的操作，而是进行信号处理。当然程序员可以根据自己的意愿，来写信号处理函数，例如收到某些信号，就放弃等待这个I/O 操作完成，直接退出，也可也收到某些信息，继续等待。另一种睡眠是**TASK_UNINTERRUPTIBLE**，**不可中断的睡眠状态**。这是一种深度睡眠状态，不可被信号唤醒，只能死等I/O 操作完成。一旦 I/O操作因为特殊原因不能完成，这个时候，谁也叫不醒这个进程了。你可能会说，我kill 它呢？别忘了，kill本身也是一个信号，既然这个状态不可被信号唤醒，kill信号也被忽略了。除非重启电脑，没有其他办法。因此，这其实是一个比较危险的事情，除非程序员极其有把握，不然还是不要设置成TASK_UNINTERRUPTIBLE。于是，我们就有了一种新的进程睡眠状态，**TASK_KILLABLE，可以终止的新睡眠状态**。进程处于这种状态中，它的运行原理类似TASK_UNINTERRUPTIBLE，只不过可以响应致命信号。从定义可以看出，TASK_WAKEKILL 用于在接收到致命信号时唤醒进程，而TASK_KILLABLE 相当于这两位都设置了。    #define TASK_KILLABLE           (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)TASK_STOPPED 是在进程接收到 SIGSTOP、SIGTTIN、SIGTSTP 或者 SIGTTOU信号之后进入该状态。TASK_TRACED 表示进程被 debugger等进程监视，进程执行被调试程序所停止。当一个进程被另外的进程所监视，每一个信号都会让进程进入该状态。一旦一个进程要结束，先进入的是 EXIT_ZOMBIE状态，但是这个时候它的父进程还没有使用 wait()等系统调用来获知它的终止信息，此时进程就成了僵尸进程。EXIT_DEAD 是进程的最终状态。EXIT_ZOMBIE 和 EXIT_DEAD 也可以用于 exit_state。上面的进程状态和进程的运行、调度有关系，还有其他的一些状态，我们称为**标志**。放在flags 字段中，这些字段都被定义称为**宏**，以 PF 开头。我这里举几个例子。    #define PF_EXITING0x00000004#define PF_VCPU0x00000010#define PF_FORKNOEXEC0x00000040**PF_EXITING**表示正在退出。当有这个 flag 的时候，在函数find_alive_thread 中，找活着的线程，遇到有这个 flag 的，就直接跳过。**PF_VCPU**表示进程运行在虚拟 CPU 上。在函数 account_system_time中，统计进程的系统运行时间，如果有这个 flag，就调用account_guest_time，按照客户机的时间进行统计。**PF_FORKNOEXEC**表示 fork 完了，还没有 exec。在 \_do_fork 函数里面调用copy_process，这个时候把 flag 设置为 PF_FORKNOEXEC。当 exec 中调用了load_elf_binary 的时候，又把这个 flag 去掉。
## 进程调度进程的状态切换往往涉及调度，下面这些字段都是用于调度的。为了让你理解task_struct进程管理的全貌，我先在这里列一下，咱们后面会有单独的章节讲解，这里你只要大概看一下里面的注释就好了。    // 是否在运行队列上inton_rq;// 优先级intprio;intstatic_prio;intnormal_prio;unsigned intrt_priority;// 调度器类const struct sched_class*sched_class;// 调度实体struct sched_entityse;struct sched_rt_entityrt;struct sched_dl_entitydl;// 调度策略unsigned intpolicy;// 可以使用哪些 CPUintnr_cpus_allowed;cpumask_tcpus_allowed;struct sched_infosched_info;
## 总结时刻这一节，我们讲述了进程管理复杂的数据结构，我还是画一个图总结一下。这个图是进程管理task_struct的的结构图。其中红色的部分是今天讲的部分，你可以对着这张图说出它们的含义。![](Images/dc3de6608a52ab8946cb71e7e7763a33.png){savepage-src="https://static001.geekbang.org/resource/image/01/e8/016ae7fb63f8b3fd0ca072cb9964e3e8.jpeg"}
## 课堂练习这一节我们讲了任务的状态，你可以试着在代码里面搜索一下这些状态改变的地方是哪个函数，是什么时机，从而进一步理解任务的概念。欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。![](Images/1a5564dd4e1c9f25d4772c7f844ca84a.png){savepage-src="https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg"}
# 13 \| 进程数据结构（中）：项目多了就需要项目管理系统上一节我们讲了，task_struct 这个结构非常长。由此我们可以看出，Linux内核的任务管理是非常复杂的。上一节，我们只是讲了一部分，今天我们接着来解析剩下的部分。