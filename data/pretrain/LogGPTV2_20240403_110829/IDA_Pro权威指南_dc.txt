23.8 小结
任何时候，如果你希望 IDA 能够执行某种任务，都应花时间考虑一下，其他人是否也有相同的愿望；以及是否有人已经采取行动，执行了 IDA 所缺乏的功能。许多 IDA 插件正是在这个过程中被开发出来。绝大多数公开发布的插件都非常简洁，专用于解决非常特殊的问题。除了可以为逆向工程问题提供可能的解决方案外，源代码可用的插件还可在你了解 IDA SDK 的有趣用法时提供有价值的参考。
第六部分 IDA调试器
本部分内容：
第24章 IDA调试器
第25章 反汇编器/调试器集成
第26章 其他调试功能
第24章 IDA 调试器
IDA 以反汇编器闻名，众所周知，它是对二进制文件执行静态分析的最佳工具之一。由于现代反静态分析技巧很复杂，人们常常将静态分析技巧与动态分析技巧结合起来，以利用它们二者的优势。在理想情况下，所有这些工具应集成在一个软件包中。IDA 在版本4.5中引入了一个调试器，从而巩固了 IDA 作为一种常用逆向工程工具的地位。在随后的版本中，IDA 的调试功能不断扩展。IDA 的最新版本能够在各种不同的平台上进行本地和远程调试，并支持许多不同的处理器。IDA 还可以配置为微软的 WinDbg调试器的前端，因而能够执行 Windows 内核调试。
在接下来的几章中，我们将介绍 IDA 调试器的基本功能，阐释如何使用调试器协助模糊代码分析，以及远程调试 Windows、Linux或OS X二进制文件。本书假定读者已经熟悉调试器的用法，但在逐步介绍 IDA 调试器的功能时，我们将复习调试器的许多基本功能。
24.1 启动调试器
调试器通常用于执行以下两种任务：分析与已崩溃进程有关的内存映像（内核转储），以一种完全受控的方式执行进程。调试会话以选择一个接受调试的进程为起点。通常，你可以通过两种方式选择一个进程。第一，大多数调试器能够依附到
 一个正在运行的进程上（假设用户拥有此权限）。根据你所使用的调试器，调试器本身也许能够提供一个可供它自己选择的可用进程列表。如果调试器不具备这样的能力，则用户必须确定想要依附的进程的ID，然后命令调试器依附到指定的进程上。调试器依附进程的具体方式因操作系统而异，这一内容不在本书的讨论范围之列。依附一个现有的进程时，你不可能监视或控制这个进程的初步启动顺序，因为在你有机会依附进程之前，它的所有启动和初始化代码已经执行完毕。
你使用IDA 调试器依附进程的方式取决于 IDA 当前是否打开一个数据库。如果没有数据库打开，那么你可以使用 Debugger ▶Attach 菜单，如图24-1 所示。
图24-1 依附到任意一个进程
通过这个菜单中的可用选项，可以选择不同的 IDA 调试器（远程调试将在第 26 章讨论）。这个菜单中的选项因运行 IDA 的平台而有所不同。选择本地调试器，IDA 将显示一个正在运行的进程列表，你可以依附这些进程。这个列表的一个例子如图 24-2 所示。
图24-2 调试器进程选择对话框
选择一个进程后，调试器将捕获该进程的内存快照，以此创建一个临时数据库。除这个正在运行的进程的内存映像外，临时数据库中还包含该进程加载的所有共享库，这使得这个数据库比我们常见的数据库要复杂得多。以这种方式依附于一个进程的缺点在于：在反汇编这个进程时，IDA 没有多少可用的信息。因为 IDA 的加载器绝不会处理对应的可执行文件映像，因而也不会对相关二进制文件进行自动分析。实际上，一旦调试器依附到这个进程，二进制文件中唯一被反汇编的指令只有指令指针当前指向的指令。依附一个进程会立即暂停这个进程，以便你在恢复进程执行之前设置断点。
依附于一个正在运行的进程的另一个方法是在依附之前，在 IDA 中打开相关的可执行文件。有数据库打开时，Debugger 菜单将呈现一种截然不同的形式，如图 24-3 所示。
图24-3 有数据库打开时的调试器菜单
如果此菜单（或与之非常相似的菜单）并未显示，则你可能尚未为用户当前打开的文件类型指定调试器。这时，Debugger ▶Select Debugger （调试器▶选择调试器）将根据当前的文件类型显示适合的调试器列表。一个典型的调试器选择对话框如图 24-4 所示。
图24-4 调试器选择对话框
通过选中该对话框底部的复选框，你可以为当前文件类型选择默认调试器。当前的默认调试器（如果有）将在该复选框上方显示。选择调试器后，你随时可以通过Debug▶Switch Debugger（调试▶切换调试器）菜单更改调试器。
选择Debugger ▶Attach to Process （调试器▶依附到进程）时，IDA 的行为各有不同，具体取决于在活动数据库中打开的文件的类型。如果打开的文件为可执行文件，IDA 将显示与数据库中打开的文件同名的所有进程的列表。如果 IDA 找不到名称相匹配的进程，IDA 将显示包含每一个正在运行进程的列表，让你自己来选择所要依附到的正确进程。你可以随时依附到任何显示的进程，但 IDA 无法保证启动该进程使用的是加载到打开的 IDA 数据库中的同一个二进制映像。
如果当前打开的数据库为共享库，则 IDA 的行为会有所不同。在 Windows 系统上，IDA 会对显示的进程列表进行过滤，只留下那些加载了对应的.dll 文件的进程。例如，如果你当前正在IDA 中分析 wininet.dll文件，那么当你选择 Debugger ▶Attach to Process 时，只会看到那些当前已加载wininet.dll的进程。在Linux和OS X系统中，IDA 不提供这种过滤功能，并且会显示你有权依附到的所有进程。
另外，要依附于一个正在运行的进程，你可以在调试器的控制下启动一个新进程。由于IDA没有打开数据库，你可以通过 Debugger ▶Run 来启动一个新进程。如果 IDA 打开了一个数据库，则可以通过 Debugger ▶Start Process或Debugger ▶Run to Cursor 启动一个新进程。如果使用前一个命令，新进程将继续执行，直到它遇到一个断点（你需要在选择 Debugger ▶Start Process之前设置），或者直到你选择使用Debugger ▶Pause Process 使该进程暂停。使用Debugger ▶Run to Cursor 将在启动新进程之前，在当前光标位置设置一个断点。这时，新进程将继续执行，直到它到达当前光标位置或者遇到一个较早的断点。如果执行永远无法到达当前光标位置（或任何其他断点），该进程将继续运行，直到你强制暂停或终止（Debugger ▶Terminate Process）该进程。
在调试器的控制下启动一个进程（而不是依附一个现有的进程）是监控该进程执行的每一项操作的唯一方法。在进程启动之前设置断点，你可以严密监控一个进程的整个启动顺序。如果你调试的是一个模糊程序，那么控制启动顺序就显得特别重要，因为你往往希望在去模糊程序完成任务之后，进程开始执行其正常操作之前，立即暂停该进程。
从IDA 数据库启动进程的另一个好处在于 IDA 会在启动该进程之前，对进程映像进行初步分析。与将调试器依附于现有进程相比，这样做得到的反汇编代码清单的质量将显著提高。
IDA 调试器可以进行本地调试和远程调试。对本地调试而言，你只能调试可在你的平台上运行的二进制文件。对于在其他平台或 CPU 上运行的二进制文件，没有模拟层允许它们在 IDA 的本地调试器中运行。至于远程调试，IDA 自带了许多调试服务器，包括用于Windows 32/64、Windows CE/ARM、Mac OS X 32/64、Linux 32/64/ARM和Android的服务器。调试服务器旨在与你要调试的二进制文件并行执行。运行远程调试服务器后，IDA 将能够与该服务器通信，在远程计算机上启动目标进程，或依附到该进程。对于 Windows CE ARM设备，IDA 使用 ActiveSync与远程设备通信，并远程安装调试服务器。IDA 还能够与 GUN Debugger（gdb）1
 的gdbserver2
 组件通信，或与链接到合适的 gdb 远程存根3
 的程序通信。最后，对于 Symbian 设备上的远程调试，你必须安装并配置 Metrowerk的App TRK4
 以便IDA 通过串行端口与该设备通信。任何时候，IDA只能作为在 x86、x64、MIPS、ARM和PPC 处理器上运行的进程的调试器前端。远程调试将在第26 章中讨论。
1. 参见http://www.gnu.org/software/gdb/
 。
2. 参见http://www.sourceware.org/gdb/current/onlinedocs/gdb/Server.html#Server
 。
3. 参见http://www.sourceware.org/gdb/current/onlinedocs/gdb/Remote-Stub.html#Remote-Stub
 。
4. 参见http://www.tools.ext.nokia.com/agents/index.htm
 。
和任何其他调试器一样，如果你想使用 IDA 的调试器启动新进程，需要在调试主机上提供原始的可执行文件，而且，你需要使用运行 IDA 的用户的完全权限执行这个原始的二进制文件。换句话说，只有一个加载要调试二进制文件的 IDA 数据库并不够。使用 IDA 调试器分析恶意软件时，了解这一点尤其重要。如果你无法正确控制恶意软件样本，你用于调试的机器可能很容易受到恶意软件的感染。任何时候，只要你选择 Debugger ▶Start Process（或者在打开数据库时选择Debugger ▶Attach to Process ），IDA 将显示如下所示的调试器警告消息，向你警告这种可能性。
您即将启动调试器。调试一个程序意味着它的代码将在您的系统上运行。
请小心恶意程序、病毒和木马。
注意：如果你选择 No，调试器将被自动禁用。
您确定想要继续吗？
对于这个警告，如果你选择 No，“调试器”菜单将从 IDA 主窗口中消失。除非你关闭当前打开的数据库，你才能恢复“调试器”菜单。
我们强烈建议你在一个沙盒环境中调试恶意软件。与之相比，我们在第21 章中讨论的 x86 模拟器插件既不需要原始的二进制文件，也不需要在实施模拟的机器上执行二进制文的任何指令。
24.2 调试器的基本显示
无论你以什么方式启动调试器，只要你感兴趣的进程在调试器的控制下被暂停，IDA 就会进入调试器模式（而非正常的反汇编模式），这时，IDA 将显示几个默认窗口。默认的调试器窗口如图24-5 所示。
图24-5 IDA 调试器窗口
如果你习惯于使用其他 Windows 调试器（如 OllyDbg1
 或Immunity Debugger2
 ），你的第一个念头可能是，这个屏幕并未显示太多信息。这主要是因为 IDA 默认使用一种实际可读的字体大小。如果你“想念”其他调试器使用的微型字体，你可以通过Options▶Font （选项▶字体）菜单来更改字体。如果你特别喜欢调试器窗口的某个布局，还可以使用已保存的 IDA 桌面（Windows▶Save Desktop）。
1. 参见http://www.ollydbg.de/
 。
2. 参见http://www.immunityinc.com/products-immdbg.shtml
 。
如图24-5 所示，调试器工具栏替代了反汇编工具栏，在调试方面，有大量标准工具可供使用，包括进程控制工具和断点操纵工具。
在调试器激活时，IDA View-EIP （➋）反汇编窗口是一个默认的反汇编风格的窗口，它与指令指针寄存器的当前值同步。如果 IDA 检测到一个寄存器指向反汇编窗口中的一个内存位置，该寄存器的名称（而不是该寄存器指向的地址）将在窗口左侧显示。在图24-5 中，EIP 指向的位置在IDA View-EIP 窗口中标记出来（注意，在这个例子中，EDX也指向这个位置）。默认情况下，IDA 以红色突出显示断点，以蓝色突出显示将要执行的下一条指令（指令指针指向的指令）。与调试器有关的反汇编代码清单通过标准反汇编模式下的反汇编过程生成。因此，IDA 调试器提供了调试器所能提供的最佳反汇编功能。此外，如果你从打开的IDA 数据库中启动调试器，IDA将能够基于在启动调试器之前执行分析来突出显示所有可执行的内容。IDA 反汇编由进程加载的任何库代码的能力将受到更大限制，因为 IDA 没有机会在启动调试器之前分析相关.dll 文件。
“栈视图”（ ➌ ）窗口是另一个标准的反汇编窗口，它主要用于显示进程运行时栈的数据内容。所有指向栈位置的寄存器（本例中为 ESP ）如“通用寄存器”窗口（➍ ）中所示。通过使用注释，IDA 尽一切努力为栈上的每一个数据项提供上下文信息。如果栈项为内存地址，IDA 会尝试将该地址解析为函数位置（这有助于强调调用函数的位置）。如果栈项为数据指针，则显示对相关数据项的引用。剩余的默认显示包括十六进制窗口（➎，该窗口提供内存的标准十六进制代码块）、Modules窗口（➏，其中显示进程镜像中当前加载的模块列表），以及Threads窗口（➐，其中显示当前进程中的线程列表）。双击列出的任何线程，IDA View-EIP 反汇编窗口将跳转到所选线程中的当前指令，并更新“通用寄存器”窗口以反映所选线程中寄存器的当前值。
“通用寄存器”（ ➍）窗口（见图 24-6 ）显示 CPU 的通用寄存器的当前内容。通过 Debugger菜单，你还可以打开显示 CPU 段、浮点或者 MMX寄存器内容的其他窗口
图24-6 “通用寄存器”窗口
在“通用寄存器”窗口中，寄存器内容在相关寄存器名的右边显示，后面显示对每个寄存器内容的说明，最右边的列中显示 CPU 标志位。右击一个寄存器值或标志位，将显示一个 Modify菜单项，你可以更改任何寄存器或 CPU 标志的值。使用菜单项可以快速将值归零，切换值，增大或减小值。切换值在更改CPU 标记位时特别有用。右击任何寄存器值，还可以访问 Open Register Window菜单项。选择 Open Register Window，IDA 将打开一个新的反汇编窗口，在其中显示以你选择的寄存器保存的内存位置为中心的内存位置。如果你无意中关闭了 IDA View-EIP或IDA View-ESP窗口，可以对相应的寄存器使用 Open Register Window命令，重新打开你关闭的窗口。如果一个寄存器指向一个有效的内存位置，那么该寄存器值右侧的直角箭头将处于活动状态，并以黑色突出显示。单击一个活动的箭头，当前的反汇编窗口将跳转到相应的内存位置。
Modules窗口显示所有加载到进程内存空间中的可执行文件和共享库。双击任何模块名称，将打开该模块导出的符号列表。图 24-7 显示的是kernel32.dll 的内容。如果你想在那些函数的入口处设置断点，符号列表将提供一种容易的方法来追踪加载库中的函数。
图24-7 模块窗口及相关模块内容
其他调试器窗口可以使用各种调试器菜单选项来访问，我们将在 24.3 节讨论与调试器操作有关的其他窗口。通过 Views▶Open Subviews 命令，你不仅可以打开特定于调试器的窗口，还可以打开所有传统的 IDA 子窗口，如函数和段。
24.3 进程控制
所有调试器最重要的功能都是它能够严密监控并修改（如有必要）它所调试的进程的行为。为达到这一目的，大多数调试器都提供了各种命令，用于在将控制权转交给调试器之前执行一条或多条指令。这些命令通常与断点结合起来使用，用户通过这些断点在到达一条指定的指令，或满足一个特定的条件时中断进程。
在调试器的控制下，一个进程的基本执行过程通过使用各种“单步执行”、“继续”和“运行”命令来完成。因为我们要频繁使用这些命令，因此熟悉与它们有关的工具栏按钮和热键组合将对我们有好处。与执行进程有关的工具栏按钮如图 24-8 所示。
图24-8 调试器进程控制工具
下面我们描述这些命令的行为。
继续（Continue ）
 。继续执行一个暂停的进程。执行将继续，直到遇到一个断点、用户暂停或终止执行或者该进程自行终止。
暂停（Pause）
 。暂停一个正在运行的进程。
终止（Terminate）
 。终止一个正在运行的进程。
步入（Step into ）
 。仅执行下一条指令。如果下一条指令是一个函数调用，则在目标函数的第一条指令上停止执行；这个命令叫做“步入”，是因为程序步入了任何被调用的函数。
跨过（Step over ）
 。仅执行下一条指令。如果下一条指令是一个函数调用，则将该调用作为一条指令处理，函数返回时立即停止执行。这个命令叫做“跨过”，是因为执行步骤是跳过函数，而不是像“步入”一样是经过函数。如果遇到一个断点，执行可能会在函数调用完成前中断。如果一个函数的行为十分常见，并且没有用处，这时“跨过”就非常有用，使用它可以节省大量时间。
运行至返回（Run Until Return ）
 。继续执行当前函数，直到该函数返回（或遇到一个断点）时才停止。如果你多次见到一个函数并希望离开它，或者如果你无意间进入了一个你希望跨过的函数，这时就可以使用这项操作。
运行至光标（Run to Cursor ）
 。继续执行进程，直到执行到达当前光标位置（或遇到一个断点）时才停止。这个命令用于运行大块的代码，而不必在你希望暂停的每个位置设置一个永久性的断点。请注意，如果光标位置被跳过或永远无法到达，则程序可能不会暂停。
除了工具栏和热键外，所有执行控制命令还可以通过 Debugger 菜单访问。无论进程在执行一个单步操作或遇到一个断点后是否暂停，每次进程暂停，所有与调试器有关的窗口都会更新，以反映该进程在暂停时的状态（CPU 寄存器、标志和内存内容）。
24.3.1 断点
断点
 是调试器的一个特性，它与进程执行和中断（暂停）关系密切。设置断点，是为了在程序中的特定位置中断正在执行的程序。在某种程度上说，断点是“运行至光标”这个概念的永久性扩展，因为在一个给定的地址上设置断点后，一旦执行到达这个位置，无论光标是否仍然位于这个位置，执行总是会立即中断。不过，虽然执行只能运行到一个光标位置，但我们却可以在整个程序中设置许多断点，到达任何一个断点都会使执行中断。在 IDA 中，我们通过导航到你希望使执行暂停的位置来设置断点，或使用 F2热键（或右击并选择 Add Breakpoint）设置断点。已经设置断点的地址将以一条跨越整个反汇编行的红（默认）带突出显示。你可以再次按下F2键关闭一个断点，从而删除它。你可以通过 Debugger ▶Breakpoints ▶Breakpoint List查看程序中当前已经设置的所有断点。
默认情况下，IDA 会使用软件断点
 ，它用一条软件断点指令替代断点地址所在位置的操作码字节。x86 二进制文件的软件断点指令为 int 3
 指令，它使用操作码值 0xCC
 。正常情况下，如果执行一条软件断点指令，操作系统会将控制权转交给任何监控被中断进程的调试器。如第 21 章所述，模糊代码可能会利用软件断点的这种行为来阻止任何附加的调试器的正常运行。
一些CPU（如x86，具体为 386 及更高版本）支持硬件辅助的断点
 （hardware-assisted breakpoint ）以替代软件断点。通常，硬件断点使用专用的 CPU 寄存器配置。在 x86 CPU 中，这些寄存器叫做DR0-7（调试寄存器 0～7）。使用 x86 寄存器DR0-3，最多可以指定 4 个硬件断点。剩下的 x86调试寄存器用于指定每个断点的其他限制。如果启用了一个硬件断点，也就没有必要替换被调试的程序中的某条特殊指令。CPU 会根据调试寄存器中包含的值，决定是否应中断执行。
设置一个断点后，你可以修改它行为的各个方面。除简单地中断进程外，调试器往往还支持条件断点
 （conditional breakpoint ）的概念，用户可指定一个条件，在实践断点之前，这个条件必须得到满足。如果到达了这样一个断点，而相关的条件没有得到满足，调试器会自动继续执行相关程序。这样做的总体想法是：相关条件会在将来的某个时候得到满足，因此，只有当你感兴趣的条件得到满足时，程序才会中断。
IDA 调试器支持条件断点和硬件断点。要修改一个断点的默认（无条件的基于软件的）行为，你必须在设置断点后对它进行编辑。要访问“断点编辑”对话框，你必须右击一个现有的断点，并在出现的菜单中选择 Edit Breakpoint。得到的“断点设置”对话框如图 24-9 所示。
图24-9 “断点设置”对话框
Location 框指定被编辑断点的地址，而 Enabled复选框说明该断点当前是否处于活动状态。如果一个断点被禁用，无论哪个与该断点有关的条件得到满足，该断点都不会被实践。Hardware复选框用于请求以硬件断点（而非软件断点）实现该断点。
警告
  关于硬件断点的一个警告：虽然任何时刻仅支持4 个硬件断点，但在编写本书时（IDA6.1），IDA 仍然允许你指定 4 个以上的硬件断点。但是，其中只有4 个断点被实践，其他的任何断点将被忽略。
在指定一个硬件断点时，你必须使用 Hardware 单选按钮指定断点的行为：是执行则中断、写入则中断，还是读取/写入则中断。后两类行为（写入则中断和读取/写入则中断）可以创建一类特殊的断点，它们只有在某个特定的内存位置（通常为一个数据位置）被访问时才会触发，而不论访问发生时到底执行的是什么指令。如果你更感兴趣的是程序何时访问一组数据，而不是这些数据在什么地方被访问，那么这类断点就非常有用。
除了为硬件断点指定一种模式外，你还必须指定一个大小。执行类断点的大小必须为1 字节，写入类或读取/写入类断点的大小可以设置为 1、2 或4 字节。如果将大小设置为 2 字节，则断点的地址必须为字对齐（2 字节的整数倍）。同样，4 字节断点的地址必须为双字对齐（4 字节的整数倍）。硬件断点的大小和它的地址共同构成了触发这类断点的地址范围。下面举例说明。以在地址0804C834h
 处设置的一个 4 字节写入式断点为例，这个断点将由 1 字节写入 0804C837h 、2 字节写入0804C836h
 、4 字节写入0804C832h
 等操作触发。在上述情形中，0804C834h
 与0804C837h
 间至少有一个字节被写入。有关 x86 硬件断点行为的更多信息，请参阅 Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B: System Programming Guide，Part 21
 。
1. 参见http://www.intel.com/products/processor/manuals/
 。
在“断点设置”对话框的 Condition 输入框中提供一个表达式，即可创建条件断点。条件断点是一种调试器特性，而不是一种指令集或 CPU 特性。如果一个断点被触发，这时调试器将对任何相关的条件表达式求值，决定是应暂停程序（条件得到满足），还是继续执行程序（条件未满足）。因此，你可以为软件和硬件断点指定条件。
IDA 断点条件使用 IDC （而非 Python ）表达式指定。值为非零的表达式被视为真，它们满足断点条件并触发断点。值为零的表达式被视为假，它们无法满足断点条件，因而无法触发相关断点。为了便于创建断点表达式，IDA 提供了一些特殊的寄存器变量，用于直接访问断点表达式中的寄存器内容。这些变量以寄存器本身的名称命名，包括 EAX
 、EBX
 、ECX
 、EDX
 、ESI
 、EDI
 、EBP
 、ESP
 、EFL
 、AX
 、BX
 、CX
 、DX
 、SI
 、DI
 、BP
 、SP
 、AL
 、AH
 、BL
 、BH
 、CL
 、CH
 、DL
 和DH