Generally, faster sweeping rates result in lower memory over-
head. This is because free requests are deferred shorter, and thus
memory can be freed faster. A faster sweeping rate is especially im-
portant to allocation-intensive applications. For instance, sweeping
at 500ms, compared to 1s, reduces the memory overhead of gcc by
an order of magnitude. Other sources of memory overhead include
MAS table, ObjList, PtrList and PLM table. We can see that these
metadata consumes acceptable amount of memory. In particular,
since several benchmarks allocate a small number of large objects
(Column 4 Table 3), the compression strategy used in MAS table
can greatly reduce memory overhead.
We also find that a large portion of memory overhead can be
attributed to a single benchmark dealII, which incurs about 1150%
memory overhead. The exceptionally high overhead is caused by
two factors. On the one hand, the baseline of dealII has a small
memory footprint and thus the relative memory consumption of
pSweeper’s metadata becomes high. On the other hand, the deferred
frees make pSweeper have a even larger overhead relative to the
baseline. Excluding dealII, the memory overhead can drop to
54.9% for pSweeper-nosleep, 81% for pSweeper-500ms, and 144.3%
for pSweeper-1s.
h264ref (C)lbm (C)omnetpp (C++)astar (C++)sphinx3 (C)AverageMedian0%10%20%30%40%50%60%70%80%90%100%110%120%perlbench (C)bzip2 (C)gcc (C)mcf (C)milc (C)namd (C++)dealII (C++)gobmk (C)soplex (C++)xalancbmk (C++)povray (C++)hmmer (C)sjeng (C)libquantum (C)h264ref (C)lbm (C)omnetpp (C++)astar (C++)sphinx3 (C)AverageMedianno sleep500ms1s0%20%40%60%80%100%120%140%160%180%perlbench (C)bzip2 (C)gcc (C)mcf (C)milc (C)namd (C++)dealII (C++)gobmk (C)soplex (C++)xalancbmk…povray (C++)hmmer (C)sjeng (C)libquantum (C)h264ref (C)lbm (C)omnetpp (C++)astar (C++)sphinx3 (C)AverageMedianDynamic Instruction CountL1 Data Cache MissBenchmark
perlbench (C)
libquantum (C)
h264ref (C)
omnetpp (C++)
lbm (C)
astar (C++)
xalancbmk (C++)
sphinx3 (C)
bzip2 (C)
gcc (C)
mcf (C)
milc (C)
namd (C++)
gobmk (C)
dealII (C++)
soplex (C++)
povray (C++)
hmmer (C)
sjeng (C)
# of Pointers
Neutralized
421,352
0
186,451
0
0
0
86
7,293
553
7,428
0
0
0
961
13,152
0
104
78,618
762
Table 3: Detailed results on SPEC CPU2006 benchmarks. pSweeper runs at 1s sweeping rate. †M for million.
# of
Allocations
358M†
7,182
28M
1,174
7,686
2,493
663,879
151M
312,951
2.4M
2.4M
1,174
1,348
182,784
267M
1,173
4.8M
135M
14M
Avg. Object
Size (Bytes)
514
1.6M
26,088
1.4M
11M
19,582
1,707
82
189,852
56
1,048
154,809
1.1M
7,735
174
367,047
922
466
1,136
Total # of
Pointers
40,490M
2.2M
7,170M
7,658M
2,585M
2.9M
607M
117M
836M
4,679M
3.8M
3
186
11M
13,099M
5,949
1,235M
2,387M
302M
# of Frees
356M
4,440
28M
721
7,184
2,038
658,695
151M
310,613
2.4M
2.4M
717
895
181,283
266M
720
4.8M
135M
14M
Peak # of
Pointers
971,353
1,184
438,016
173,625
76,254
1,746
28,841
329,194
76,278
128,525
2,237
0
8
3,674
589,145
28
34,519
418,924
24,923
Figure 12: Memory overhead on SPEC CPU2006.
5.2.3 Comparison to DangSan and Oscar.
We compare pSweeper with DangSan [54] and Oscar [24], two
state-of-the-art UaF defense systems with best performance. We
use two sweeping rates of pSweeper, 1s and nosleep. The geomet-
ric mean of DangSan is a 41% slowdown and Oscar is 40%, while
pSweeper-nosleep is 12.5% and pSweeper-1s is 17.2%. Figure 13
compares the eleven benchmarks on which pSweeper obviously
outperforms DangSan and Oscar. There is no remarkable differ-
ence on other benchmarks. In terms of memory overhead, DangSan
imposes an average overhead of 210%, while pSweeper-nosleep is
112.5% and pSweeper-1s is 247.3%. Oscar has 52% memory overhead,
which is more efficient than both DangSan and pSweeper. Since
the memory overhead of pSpweer is mainly due to deferred free,
our future direction is to design a memory efficient allocator for
Figure 13: Overhead comparison with DangSan and Oscar.
deferred free. pSweeper achieves much lower slowdown in applica-
tion performance mainly because the heavyweight security check
and enforcement have been outsourced to dedicated threads that
can leverage the spare cores in modern systems. In particular, the
workload induced to application threads is quite light.
5.3 Scalability on Multi-threaded Applications
We use PARSEC 3.0 [17] to evaluate the scalability of pSweeper
with respect to an increasing number of application threads. Our
baseline LLVM fails to compile four benchmarks and Figure 14
shows the results for nine succeeded ones. As we can see, pSweeper
scales nearly as well as the baseline on all benchmarks. This is
mainly because lock-free algorithms are devised to address almost
all races between pSweeper and application threads. As a result, the
incurred overhead does not increase significantly when systems be-
come more contended. For pSweeper-nosleep, the core running the
0%100%200%300%400%500%600%700%800%perlbench (C)bzip2 (C)gcc (C)mcf (C)milc (C)namd (C++)dealII (C++)gobmk (C)soplex (C++)xalancbmk…povray (C++)hmmer (C)sjeng (C)libquantum (C)h264ref (C)lbm (C)omnetpp (C++)astar (C++)sphinx3 (C)AverageMedianno sleep500ms1s1150%1766%2100%00.511.522.533.54Runtime OverheadpSweeper-nosleeppSweeper-1sDangSanOscar6.72Figure 15: pSweeper overhead on Lighttpd.
5.4.1 Lighttpd.
We first conduct experiments on Lighttpd 1.4.40. To generate client
requests, we run the ApacheBench [1] tool on a second desktop.
The tool makes 100,000 requests with 128 concurrent connections
to transfer a 50-byte file. We use a very small file to minimize the
potential variance caused by network and disk I/O. The results are
averaged over five runs.
Figure 15 shows the throughput of Lighttpd with respect to the
different number of worker processes. We can see that pSweeper
scales well on Lighttpd with overheads in ranges of 3.4%∼17.8%.
The highest overhead occurs when the number of worker processes
reach four which occupy all four hyperthreading in two cores.
When the number of worker processes become larger than four, the
baseline throughput also decreases because application processes
now contend with each other. This result is consistent with those in
§5.3. The memory overheads are about 158.7% (1s), 42.2% (500ms),
and 38.7% (no sleep) in all cases.
5.4.2 Mozilla Firefox.
We choose Firefox 47.0 as our second case study. Table 4 presents
the evaluation results on three popular browser benchmarks, Mo-
tionMark [11] assessing a browser’s capability to animate complex
scenes at a target frame rate, Speedometer [12] measuring simu-
lated user interactions in web applications, and JetStream 1.1 [8]
covering a variety of advanced Javascript workloads. In all three
benchmarks, larger scores indicate higher performance. We can see
that the induced runtime overhead is quite low, ranging from 2.3%
to 8.1%. The geometric means of memory overhead are 863%, 374%,
and 117%, for pSweeper-1s, -500ms, and -nosleep, respectively.
We further evaluate pSweeper by visiting Alexa Top 50 websites.
We encounter no error during the test of accessing the websites.
Table 5 lists the page load time (using app.telemetry [2]) when visit-
ing five popular websites. On average, the page load time increases
by 3.7%.
Benchmarks MotionMark
Baseline
Score
145.24
Speedometer
Runs /minute
48.5
44.4 (6.2%)
45.12 (6.9%)
44.7 (7.8%)
JetStream 1.1
Score
160.63
156.9 (2.3%)
156.6 (2.5%)
156.1 (2.8%)
1s
500ms
nosleep
133.98 (7.7%)
133.49 (8.1%)
134.13 (7.6%)
Table 4: Overhead of pSweeper(-1s, -500ms, -nosleep) on
three browser benchmarks. The percentage in parentheses
is the slowdown.
Figure 14: Scalability of pSweeper on PARSEC 3.0. The num-
ber of threads must be a power of two for fluidanimate.
pSweeper thread always has a utilization of 100%. For most bench-
marks, pSweeper consumes about 20% and less than 1% CPU under
500ms and 1s sweeping rates, respectively. The CPU utilization
increases to 90% (500ms) and 10∼30% (1s) for memory-allocation
intensive benchmarks, such as gcc, perlbench, and xalancbmk. We
also observe that the runtime of benchmarks does not decrease any-
more after the number of application threads reaches four. This is
because our CPU has only two cores with 2-thread hyperthreading
on each core (i.e., providing 4-thread hyperthreading in total). The
geometric means of overhead over all nine benchmarks range from
7.5% to 18.1% for all three configurations of pSweeper. We find that,
when the number of application threads grows larger than the num-
ber of CPU threads (four in our case), pSweeper-nosleep incurs rela-
tively larger overhead than pSweeper-1s because pSweeper-nosleep
exacerbates the CPU contention, while pSweeper-1s consumes rel-
atively lower CPU resources. The memory overhead basically does
not highly correlate with the number of application threads and
the geometric means of overheads are 1600% (1s), 840% (500ms),
and 49% (no sleep), respectively. The high overhead is mostly due
to swaptions that consumes 144x memory for pSweeper (1s). The
reason is that the memory footprint of baseline swaptions is quite
small. As a result, the memory consumption caused by pSweeper
becomes exceptionally large relative to the baseline. Excluding
swaptions which is not evaluated by DangSan, the memory over-
heads of pSweeper become 27% (1s), 22% (500ms), and 18% (no
sleep), respectively.
5.4 Macro Benchmarks
We now demonstrate that pSweeper works efficiently on modern
applications with two case studies, Lighttpd web server and Firefox
browser.
02040608010012014016018020012345678bodytrack02040608010012014016018020012345678blackscholes0408012016020024012345678canneal0408012016020024028032036012345678ferret040801201602002402803203604001248fluidanimate 06012018024030036042048054060012345678freqmine02040608010012012345678vips0408012016020024028032036040012345678streamcluster05010015020025030012345678swaptionsapplicationthreadsapplicationthreadsapplicationthreadsruntime 12345678baselinepSweeper (1s)pSweeper (500ms)pSweeper (nosleep)runtime runtime 040008000120001600020000240002800012345678Throughput (requests / second)Number of worker processes in Lighttpdbaselinepsweeper (1s)psweeper (500ms)psweeper (nosleep)Websites
google.com
youtube.com
facebook.com
amazon.com
yahoo.com
Baseline
0.55
1.95
0.64
2.42
3.51
1s
0.57
1.99
0.66
2.51
3.61
nosleep
pSweeper
500ms
0.56
2.02
0.66
2.52
3.63
0.58
2.01
0.67
2.50