通过重新编译手动更新内核的安装也很奏效。对许多用户来说，第二种情况远比预想的要常见
得多，因为重新编译MacOSX、RedHat（Linux发行版）或OpenSolaris内核只是一个额外的
负担（使自动修复和更新系统过程更复杂）。此外，基于系统版本信息（我们在本章的开始提
到过）探测一个所谓的默认内核十分容易。
虽然内核符号很有用，但这并不是我们寻找的唯一信息，而且令人遗憾的是，唯一信息会
使一个利用变得不可靠。事实上，这些符号可以提供针对触发步骤最后阶段的非常良好的提示
（如转到某些地址执行，或者具有任意的写权限），但是在早期阶段，也就是在试图发现漏洞的
阶段，这些符号的作用却不大。
我们把内存破坏漏洞分成两大主类：基于堆和基于栈。前面章节中提到过解决两类漏洞
的一个共同的（最后手段）技术，该技术基于重写相邻的页面。在所有这些情况下，如果要成
功，就需要收集一些相关资料，说明各种内存分配器如何工作。根据操作系统的不同，我们能
够得到更多的详细信息。第二部分将讨论这样做的实际方法。
此外，了解如何利用这些看似无害的细节是很有趣的事情。我们能收集到的有关堆分配器
的典型信息是每个缓冲器分配的对象数量和自由对象的数量。“触发阶段”部分曾提到过在攻
的。正如我们解释过的，为了做到这一点，需要填满所有缓存所使用的页（即推动所有可用对
象的分配），其结果是该分配程序将请求新的页，并开始像第一次分配那样地使用它们。内核
导出的信息是非常重要的，因为它让我们可以对分配程序进行间接管理，以及确定是否有副作
用。通过不断监测导出的信息，我们可以调整利用的方式，而且在大多数情况下，把它纳人永
久可靠的利用。
---
## Page 82
第3章成功内核利用进阶73
工具与策略
熟悉诊断工具
我们提供的例子并不能体现一个系统可能透露的所有信息；我们只是挑选了在开发中
最可能使用的信息。花一些时间熟悉一下某个操作系统提供的非权限诊断工具是非常值得
的。诸如附属物理设备的数量和类型（例如PCI设备）CPU的类型和型号或内核导出的数
据之类的信息可能会在以后的开发中派上用场。操作系统倾向于将此信息收集在一起，例
如，提供一个公共接口收集起来。我们提到过Linux内核上的/proc/kallsyms。在这样的系
统里，/proc（和/sys）虚拟文件系统将迅速给出一个您熟悉的信息。在第二部分我们将详
细讨论与利用相关的导出信息。
架构告诉我们什么
架构对我们也有很大帮助。总体上讲，在这一方面有两个信息来源颇为有趣：计数器和辅助
架构的软件表。前面提到的高精密时间戳计数器（RDTSC/TSC）是前者的一个很好的例子。在
这种情况下，我们获得了一个令人难以置信的准确的方法来同步攻击线程。
在一定程度上，辅助架构的软件表更有趣。这种结构背后的想法很简单。实现一些大
量使用的表（如连接特定中断和相应的处理程序的表）在纯硬件中代价过于昂贵。另一个方
面，纯软件支持将会极大地影响操作系统的性能。解决这个问题的办法就是软、硬件结合使
用。中断表就是一个极好的例子。该架构提供了一个寄存器来跟踪表的地址，并使用这些信
息自动执行从给定的中断号到指定的处理程序调用的内部过渡。如果每个架构还包含其他信
息（如调用特殊处理程序需要的权限级别），那么该架构可能会支持硬件上的信息处理（例
如，x86-64架构检测与CPL相关的DPL，并提供了在调用方没有足够的权限情况下的一个致
命异常）。
很明显，这种架构需要提供指示，以编写和检索存储在含有软件表指示器的寄存器中的地
址。虽然前者永远是一个权限操作，但后者通常不是。
在“执行阶段”部分，我们了解了如何精巧地利用中断向量表来可靠地达到触发shellcode
的目的。下面继续介绍x86-64架构，看看下面的代码：
/*makeIDTstructpacked*/
pragmapack(push)
#pragmapack(1)
structIDT
AH
USHORT1imit:
ULONG64base:
1：
pragmapack(pop)
typedefstructIDTTYPE_IDT;
ULONGgetIdt（）
---
## Page 83
74第一部分内核态
TYPE_IDTidt;
-asm1
sidtidt
returnidt.base;
当在MicrosoftVisualStudioC++中编译这段代码时，前面的代码会将IDT的地址返回到
无权限的程序。这里的关键点是一asm（）语句，它使用SIDT（存储中断描述符）指令。该指
令将IDTR的内容复制到由目标操作数指定的内存地址中。刚刚展示的一个例子是在Windows
平台上应用的，但这里真正重要的是能够执行的程序汇编指令。任何操作系统上的编译器都提
供了这种可能性。
一旦知道了中断向量表的地址，就可以计算出从表的起始位置到想要劫持的中断处理程序
处的确切偏移地址，然后应用在“执行阶段”部分描述的技术就可进行利用。
类似的方法适用于GDT和SGDT指令。这里我们不再细讲。
环境不想告诉我们的：信息泄露
正如前面提到的，有一类漏洞通常被低估，它从内核泄漏内存中的内容。除非泄漏的范围
非常宽（您可以从用户态中检索内核的内存）或可以控制（您可以决定内核的哪个区域泄漏。
注意，在这种情况下，通常可以通过重复利用尽可能多地泄漏内存），否则这种类型的漏洞不
会导致机器受攻击。这种类型的漏洞称作信息泄露。
提示大量的内核内存泄漏可以展示当前系统使用的物理页的内容。在这些页中您可
能会找到存储的SSH密钥、密码或映射文件，可能导致系统直接受攻击。
此类bug对提高利用效率非常有用，特别是当我们的目标是一个配置有很多安全保护的系
见内核中使用的地址，并可以让我们计算出shellcode的确切返回地址。
泄漏可能发生在几乎所有的内存分配里，因此可以返回关于以下内容的信息：
为可能没有任何其他方式能够推导出内核堆栈在内存中的位置。此外，一个被充分控制
的信息泄露可以揭示canary保护的存在，并揭露其价值所在（允许您轻松地绕过这种保
护）。考虑到内核栈一般不是随机的，栈信息泄露就更有趣了。因为内核栈分配一劳永
逸，多次调用相同的内核路径将导致每次栈布局相同。在这种情况下，信息泄露可以给
您一个精确的偏移以覆盖存储在某个地方的指针。
·堆地址/值这里的普遍情况是泄露一个对象周围的内存区，或前或后，或前后都有。这
种类型的泄漏会揭示之前或下一个对象的状态（它是否被分配）、类型（比如您有一个通
用的缓存器，从中分配出不同类型的对象）以及内容（对于自由对象，指的是in-object
控制结构（在使用的情况下）；对于分配对象，指的是其成员的值，以便于在溢出时复
---
## Page 84
第3章成功内核利用进阶75
制它们）。此外，如果堆用某种形式的随机的“红区”保护起来，可能会暴露使用的检查
值，并提供了一种绕过这种保护的方法，恰如stackcanary的情况。
·内核数据段它是存储（全局）内核变量，在编译时创建的区域。该数据的信息泄漏会
揭露某个内核配置的值（具体的保护是否活跃）。或者，在不能够检索出内核符号的情况
下，给您一个精确的偏移以用于开发利用中。
当今将内存区域映射为不可执行区域是非常普遍的（也是流行的趋势）。如果目标系统没
有这种保护（例如，在32位的x86环境中），内存区域内的一个泄漏可能也会显示出有趣的字
节序列，这些可以用作您的shellcode的一部分（您应该记得从返回到内核文本技术的这样一个
办法）。显然，这也是内核文本泄漏的一个优点，同时也能够检查存在某个具体漏洞的可能性。
如果需要待在目标机监视下，这样做是有用的。您可以检查是否有漏洞，并决定是否进行相应
的攻击，而不是对一个有补丁的内核进行攻击（可能留下痕迹）。
保卫自己
让攻击者的日子不好过
读完这部分，您应该清楚攻击者会在多大程度上使用这些看似无害的信息或信息泄露
漏洞。在一些项目中，如为Linux内核开发的GRSecurity，旨在尽量限制利用载体和攻击
者可以检索的信息。这方面的例子就是内核导出信息的过滤（不要向用户暴露符号表或堆
状态信息）和限制某些类型的攻击的对策（因为没有办法阻止用户编辑SIDT指令，只需将
IDT置于无法编写的映射中）。始终检查您的操作系统给出了什么样的选项来限制诊断工具
和导出信息的权限。请注意，删除这些工具是不可取的，因为它们所基于的内核输出接口，
可以很容易地被攻击者使用自已的工具销毁。此外，不要把一个可读的内核映像（攻击者
可以很容易地从中提取符号）或可读模块（攻击者可能触发其载入）乱丢。请注意，可读
（可能压缩）内核映像可用于大多数默认的系统安装。此处的核心思想是剥离任何用户不需
要的信息，无论这些信息看起来多么无关。
小结
本章内容相当丰富，讨论了内核利用的一个主要模块。其实，讲述了一些利用之前的基础
内容，重点是架构层次：运行操作系统的物理层。本章乃至全书的主要特征都是采用“先理论
后实践”的方法，遵循这种方法，我们讨论了支撑架构设计的普遍理论，以及在x86和x86-64
架构中如何应用这些理论。
了解架构会在开发利用的多个阶段提供帮助。第一个应用体现在shellcode开发中：您试图
跳转去执行的一系列指令。此外，架构限制和特征都会影响内核的性能（例如，在内存管理方
面），这决定了您在攻击代码内可以做什么，不可以做什么。该架构也在多个层面上辅助您，为
您的shellcode提供良好的切入点和重要信息，提高您的开发利用的可靠性。
从架构层次再前进一步，我们重点讨论了一个利用的执行阶段，以及在成功地劫持了执行
路径后会进行的操作。这里有两个关键点：提高权限（最终摆脱任何限制环境），将内核恢复到
---
## Page 85
76第一部分内核态
一个稳定的状态（释放目标路径可能获得的任何资源）。
为了成功启动执行阶段，需要生成漏洞，劫持执行流，并将其重定向到合适的位置。这是
触发阶段的任务，很明显，生成漏洞需要依靠漏洞。您已经了解了堆和栈内存破坏的漏洞及竞
态条件的技术。使用从栈中得到的已经修改过的返回地址的结果是：劫持执行流可能会立即发
生：而修改某个内核结构然后再调用一条路径的结果是上述情况可能会在稍后发生。
触发阶段的成功与否（及其可靠性）很大程度上受到收集到的目标系统相关信息多少的影
响。我们把这个准备阶段称为信息收集阶段。首先，操作系统会导出许多看似无害的信息。您
的目标就是组合这些信息，并利用这些信息增加利用的可靠性。诸如内核符号、可用的CPU数
量、内核地址及加载的模块之类的信息，特别是当目标是硬化环境时，这些信息可能会在将概
念上正确的代码转化为永久利用的过程中发挥重要作用。但是在这样的系统中会过滤掉大量的
信息。在这种情况下，需要寻找/依赖信息泄露漏洞，或者那些允许您或多或少窥视内核内存
的bug。
相关阅读
架构设计
Hennessy,John,andPatterson,David.2003.ComputerArchitecture—AQuantitativeApproach
(MorganKaufmann).
Tanenbaum,Andrew,S.2005.Structured Computer Organization(FifthEdition)(Prentice-Hall,
Inc.).
x86/×96-64架构手册
Intel64andIA-32ArchitecturesSoftwareDeveloper'sManual:Volume1:BasicArchitecture(www.
intel.com/products/processor/manuals/).
Intel64andIA-32ArchitecturesSoftwareDeveloper'sManualVolume2:InstructionSet
Reference(www.intel.com/products/processor/manuals/).
Intel64andIA-32ArchitecturesSoftrwareDeveloper'sManualVolume3:SystemProgramming
Guide(www.intel.com/products/processor/manuals/).
漏洞利用技术
Advancedreturn-into-lib(c)exploits;www.phrack.orghttp://www.phrack.com/issues.html?
issue=58&id=4/issues.html?issue=58&id=4.
Koziol,Jack,Litchfeld,David,Aitel,Dave,et al.2004.TheShellcoder'sHandbook:Discovering
andExploitingSecurityHoles（Wiley）
Krahmer,Sebastian.“x86-64buffer overflowexploits and theborrowed code chunks
---
## Page 86
第二部分
UNIX家族、MaCOSX和
Windows
学习理论概念的最佳方法是将它们应用于实践，这也正是本书第二部分的章节所要达到的
目标。第4～6章将深入探讨各种漏洞利用技术，以便在不同类型的操作系统上成功利用不同
子系统中的漏洞。除了剖析最终的利用代码，我们还将重点讨论一些技术的实现步骤（伴随着
问题和解决方法），这些步骤会引导特定技术的创建。按照这样的方法，我们实现了一些比开
发漏洞利用代码本身更重要的目标，即建立一套（漏洞利用开发的）方法论。
PDG
---
## Page 87
第4章
UNIX家族
本章主要内容
·UNIX家族成员
·执行步骤
·实战UNIX
引言
在前面的章节中，介绍了一些漏洞发掘利用的理论，在这一章中将开始应用这些概念。
本章主要关注UNIX操作系统家族，这个家族包含原始的UNIX操作系统本身以及众多的演
变版本，包括开源版本（如Linux、OpenSolaris、*BSD等）和商业版本（如AIX、HP-UX
等）。
本章将把目标锁定在Linuxx86/x86-64架构的系统，通过逐步实现漏洞的利用开发，而不
及第3章介绍的大部分理论性方法，并且，尽可能的瞄准一个真正的漏洞（本书出版之前的已
知漏洞）开发一个完全可用的内核利用程序。
构的关注，其大量漏洞也不断被公布和讨论。正由于Linux是开源的，而且不属于某个特定的
提供商，因此它是内核漏洞利用的最佳实验平台！
同时，为了开拓内核漏洞利用领域的视野，本章还将介绍Sun（www.sun.com）公司
SolarisOS的演进版开源操作系统OpenSolaris。之所以要介绍OpenSolaris有两方面的原因：
1）SlabAllocator（主要负责提供内核堆的子系统）是由Sun公司的Solaris引l进的，因此
用它来对现有的OpenSolaris实现进行漏洞挖掘利用很合适。
2）OpenSolaris系统包含一些非常出色的系统调试工具（如kmdb、DTrace），因此是引[入
这些工具使用的很好的场所，从而有助于内核利用。DTrace也已经被引人到许多不同的操作系
统中，比如FreeBSD、MacOSX等，因此，在这里学习这些工具将有助于今后在其他系统上
进行调试。
UNIX操作系统。本章将要讨论的栈利用和用于竞态条件的DirectI/O技术就是这方面很好的
例子。前者包含许多与架构相关的代码，而后者则延续了数据库对所有操作系统都兼容的设计
---
## Page 88
第4章UNIX家族79
理念。但必须要记住的一点是，在瞬息万变的漏洞利用战场，技术不断更替。在阅读本章
介绍的时候，子系统的重新设计、关闭特定传播媒介的一个补丁，或者是一个简单的内核
（安全）更新都有可能使本章介绍的技术过时（或不可用）。第9章将详细讨论这些问题。
再次重申，本章旨在介绍一些完善的方法和纯理论研究中鲜有提及和容易忽视的一些问题
的解决方案。
注意本章涉及的所有示例的源代码都可以在本书的网站www.attackingthecore.com
中获得。同时，针对第二部分所有章节（尤其是本章），我们还提供了一些额外的在
线资料，用于帮助读者深入了解其他操作系统和技术。我们将力所能及地提供与内核
利用相关的信息，并且及时更新提供的资料。如果可能的话，您也可以上传一些有注
释的漏洞利用、快速技巧、漏洞利用解决方案或者漏洞分析，我们将非常乐意寄存这
些资料。