User: I am writing a wrapper program to add features to a Windows command-line tool.  This program is made to run on a Windows server with py2exe.  In it, there are several lines which look like:
job = subprocess.Popen(syncCommand, stdout=myLog, stderr=myLog)
When I call this program from the command line, everything works fine, however, I wish to automate this script using Windows Task Scheduler (per a request from my manager).  When I register the executable and attempt to run it as a service, the logs are touched, but do not become populated with dialogue that would normally be returned.  I am unsure where precisely the error is occurring, as running it from the task scheduler does not call a terminal window with which to view debugging messages.  
Note that in previous versions, I had calls to subprocess.Popen() replaced by os.system(), and everything worked as it should have.
Is there an obvious obstacle/problem with this method?  Is there a compelling reason to use Popen() instead of system()?
Assistant: The error was caused by registering the task to run as a different user.  The task was registered as the "SYSTEM" user, but could not access remote files which were accessed by the Popen() call.  The solution was to run the task as another user, or run it as the "SYSTEM" user on the machine where the remote files are located.