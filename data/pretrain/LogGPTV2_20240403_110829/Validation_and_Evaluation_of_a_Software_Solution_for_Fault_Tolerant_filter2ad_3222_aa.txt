title:Validation and Evaluation of a Software Solution for Fault Tolerant
Distributed Synchronization
author:Paolo Ballarini and
Simona Bernardi and
Susanna Donatelli
Validation and evaluation of a software solution for fault tolerant distributed
synchronization
P. Ballarini, S. Bernardi and S. Donatelli
Dipartimento di Informatica, Universit`a di Torino, Corso Svizzera 185, 10149 Torino, Italy
E-mail:fballarin,bernardi,PI:EMAIL
Abstract
This paper presents a case study on the combined use of
different tools and techniques for the validation and eval-
uation, from the early stages of the design, of a fault tol-
erant software mechanism named distributed synchroniza-
tion The mechanism has been speciﬁed using UML state
charts and sequence diagrams. A number of Stochastic
Well-formed Nets (SWN) models have been derived from the
speciﬁcations: they have been composed using the tool al-
gebra, and the resulting model has been model-checked us-
ing the PROD tool for temporal logic properties, thanks to
a GreatSPN-to-PROD translator. The quantitative analy-
sis has been performed using the SWN solvers of the Great-
SPN tool.
1
Introduction
Modelling and evaluation is traditionally an activity that
takes place at the latest stages of the development of a sys-
tem, sometimes even after the system is already in the oper-
ational phase, although in recent years we have seen a num-
ber of papers that try to produce performance models from
(even partial) speciﬁcations of the system, most notably in
the ﬁeld that studies the generation of performance models
starting from various UML speciﬁcation diagrams (see for
example [2, 3, 4]). This paper follows this line of research
and reports on an effort conducted to support the design of a
software synchronization mechanism using a suite of tools
based on Petri nets.
The paper addresses the use of Stochastic Well-formed
Nets [12, 13] (SWN) and related tools to support the
validation and evaluation from the early stages of the
design. Peculiar aspects of the early-stage evaluation are:
1. frequent changes in the system being modelled (asking
for high ﬂexibility and reuse);
2. delays are usually unknown, or ﬁxed only by an order
of magnitude (so that typically sensitivity analysis is
performed);
3. need for quick macro models (to quickly evaluate
possible macro alternatives)
4. need for detailed models (to validate and evaluate the
chosen proposed solution).
The paper addresses points 1, 2 and 4, while an example
of analysis for point 3 can be found in [8]: point 3 and 4
are strictly related since it would be interesting to be able to
prove some sort of “consistency” between the macro models
and the detailed ones. As far as we know there are not many
attempts along this line.
We have taken a stochastic approach to evaluation, and
we use as our modelling formalism Stochastic Well-formed
Nets [12, 13] (SWN) a colored extension of Generalized
Stochastic Petri Nets[1] (GSPN). GSPN and SWN allow
delays to be exponentially distributed, and many tools al-
low also non exponential distributions, especially if the so-
lution method is simulation.
Indeed in our work we are
not much concerned with speciﬁc distributions (we are still
in the early stages of the design), but we assume that the
qualitative and quantitative models have the same behaviour
(same reachability graph), and a trivial condition for this to
be satisﬁed is that all distributions have inﬁnite support.
A number of tools allow the deﬁnition and solution of
GSPN models and of colored GSPN models of some sort,
like: APNNtoolbox [16], GreatSPN [11], SMART [14],
TimeNET [20], UltraSAN [18]. In this paper we use Great-
SPN since we want to take advantage of the efﬁcient solu-
tion methods of SWN (both analytical and simulation [5])
and of a number of additional tools/programs that have been
recently added to GreatSPN: Multisolve [6], algebra [7]
and GreatSPN-to-PROD [9].
Multisolve is a Java interface of GreatSPN to plan and
execute solution experiments (using any of the GreatSPN
solvers for GSPN and SWN) and to produce gnuplot and
postscript ﬁles of the results. Similar facilities are present
in most performance evaluation tools, and they are of great
help while performing the sensitivity analysis demanded by
the point 2 above.
algebra is a tool for composing SWN, and it allows
the composition over immediate and timed transitions (syn-
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:16:05 UTC from IEEE Xplore.  Restrictions apply. 
chronizing transitions) based on non-injective transition la-
belling, and the composition over places (communicating
places), again based on a non-injective place labelling. al-
gebra also allows us to select whether the variables on in-
put arcs from different models to a synchronized transition
should be uniﬁed or not. It is an essential tool when frequent
changes and reuse are needed, as for point 1 above.
Validation of Stochastic Petri Nets is usually supported
by the computation of a number of structural properties, like
P- and T-semiﬂows, conﬂict sets, structural deadlocks and
traps, while a much smaller number of properties are avail-
able, and implemented, for SWN. For example, to the best
of our knowledge, the only available computation of SWN
semiﬂows is the one in CPN- AMI, but for P-semiﬂows [15]
only and with a number of restrictions on the class of ac-
cepted models. Moreover there is in most tools a limited
possibility of examining the state space, for GSPN but es-
pecially for SWN: GreatSPN provides a textual description
of the reachability graph (possibly symbolic for SWN) to-
gether with the list of deadlock states, and number of live-
locks and of strongly connected components (for GSPN
only). These facilities are absolutely inadequate when mod-
els become very large and colors come into play.
PROD [19] is a tool for the deﬁnition and validation of
place/transition nets and of the high level Petri net class
known as Predicate/transition (Pr/T) nets. PROD allows
the construction of the reachability graph of a net and its in-
spection by means of the interactive program probe. It al-
lows the veriﬁcation of the RG by displaying paths between
RG nodes and by testing propositional logic formulae and
temporal logic formulae expressed in Computational Tree
Logic (CTL) [17]. An important characteristic of PROD is
that all formulae are expressed in terms of net elements like
marking of places and ﬁring of transitions, therefore using
a language that is similar (not too different may be) to the
one used for the deﬁnition of the performance indices.
GreatSPN-to-PROD [9] is a tool that allows the use
of the validation facilities of PROD by translating GSPN
and SWN nets into algebraic nets in PROD format. The
translation also produces a number of ad-hoc macros that
allow an easy check of the most common properties of nets,
like the computation of the minimum path to a deadlock or
the markings enabling a given set of transitions.
The case study of the paper is a software mechanism
called distributed synchronization (DS), that has been de-
veloped inside the EEC projects TIRAN [10], and its
follow-up DepAuDE, as part of a software framework that
allows the cheap addition of fault tolerance provision for
systems built from standard COTS components. DS allows
the synchronization of a number of user tasks over a number
of synchronization points, called levels. Both the user tasks
and the DS itself can be distributed over different nodes, to
tolerate crashes of a node or of a single DS task. In this
paper we concentrate on the case of a single DS. The vali-
dation and evaluation of the DS plays an important role in
the project since it is used by a number of other mechanisms
of the framework.
The emphasis of the paper is on the validation and eval-
uation process, and on the tools used in the process, since
we want to report on the combined use of evaluation and
validation from the early stages of the design, more than on
the speciﬁc performance results.
The paper is organized as follows: Section 2 introduces
the distributed synchronization mechanism. Section 3 in-
troduces the initial SWN models of the DS components and
their composition into a single SWN model. Section 4 in-
troduces a variation of the pattern of use of the DS by the
users. The “stochastic” evaluation of the system seems sat-
isfactory but a closer look shows that a deeper qualitative
analysis is needed to validate the model using GreatSPN-
to-PROD and PROD. Section 5 shows the new deﬁnition
of the DS as suggested by the problems detected in the pre-
vious section, and the corresponding SWN model, that is
again validated and ﬁnally evaluated. Section 6 concludes
the paper by taking a critical view point to this modelling
activity.
2 The DS mechanism
Distributed Synchronization (DS) is a software mecha-
nism whose objective is to allow tasks (possibly distributed
over a net) to synchronize on the execution of certain ac-
tivities. Different levels of synchronization are supported,
representing different, possibly parallel,
independent
activities for which synchronization is needed. We consider
n-tasks (t : : : tn) that require synchronization services on
m-levels (l : : : lm). Peculiar aspects of the DS behaviour
are:
(cid:15) synchronizing tasks and DS are executing on a
distributed architecture, made of a certain number of
node;
(cid:15) participants to synchronization depend on the level:
on different levels, participants may be different;
(cid:15) participating tasks may fail during their execution and
this must not block the other tasks that are waiting for
a synchronization.
DS has been speciﬁed as a UML class with an attribute
DST able and two methods, one for checking if a synchro-
nization is possible, according to the table, and one for
changing the state of the table according to the stimulus re-
ceived.
The DSTable is used by the DS to keep track of the evo-
lution of the activities (who’s ﬁnished, who’s participating,
who’s still executing). The entry DSTable[i][j] represents
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:16:05 UTC from IEEE Xplore.  Restrictions apply. 
task
failed
Not reached
task 
failed
NR
task 
ready
task 
ready
Last reached
LR
s
a
t
y
n
c
c
h
r
u
r
o
Not available
NA
task partecipates 
in synchronization
task
failed
task risen
and ready
task 
failed
r
e
r
e
n
t
a
c
l
h
e
e
v
d
Reached
R
Restart
RS
e
l
synchro reached
at current level
Figure 1. Automaton of the DS table
the state of task ti with respect to level lj. The possible val-
ues are: Not Reached (task ti participates in a synchroniza-
tion at level lj and has not yet completed), Reached (task
ti completed on level lj), Not Available (task ti fails and
it should not be taken in consideration for synchronization),
Restarted (task ti is alive again and ready to synchronize on
level lj), and Last Reached (level lj is the last one on which
synchronization has been reached).
The change of state of a single entry is described by the
automaton of Figure 1, while the behaviour of the DS is de-
picted by the automaton of Figure 2. To better describe a
system a number of sequence diagrams were also provided,
to show speciﬁc paths of execution, together with snapshots
of the DSTable during the path. As an example, let us con-
sider what happens when a ready message from a user task
t on level l is received by the DS: the state of the automaton
of Figure 2 changes to checking tasks, and the entry ([t][l])
of the DSTable changes from LR to R or from NR to R. If
instead a task t fails the automaton moves to the disconnect-
ing task state, and all entries of the table for task t are set to
Not Available.
A full description of the DS is beyond the scope of this
paper, but we hope that what has been described is enough
for the reader to appreciate (or depreciate) the analysis ef-
forts described in the remaining sections.
wait for
message
sending msg of
reached synchro
task 
failed
synchro 
not reached
task ready
synchro
reached
disconnecting
task
task 
disconnected
checking
tasks
Figure 2. Automaton of the DS states
3 The Petri net model of the DS
The SWN component models that we consider as basic
elements for the DS are:
tasks the user tasks requiring synchronization;
backbone the model that accounts for fault and repair (the
particular name come from the TIRAN project)
ds the distributed synchronization (translation of
the
automaton of Figure 2);
check synch represents the method for checking if a
synchronization has been reached.
DStab the DS table (translation of the automaton of
Figure 1);
All SWN models share the deﬁnition of two basic color
classes T and L, deﬁned as: T = u Tk and Tk= ft1, . . . , tng
meaning that the class T of tasks is made of a single static
subclass that contains n colors, representing the n tasks of
the system (the SWN formalism requires the deﬁnition of
basic color classes in terms of static subclasses, even if there
is a single one, like in this case) and L = o L1,: : :,Lm with
Li=flig meaning that the class of levels is made of m static
subclasses of one color each; the class is ordered, so that the
circular successor function can be applied to colors in this
class and the expression “next level” makes sense.
We now describe each model in isolation: these models
are later composed to form the SWN model of the whole
system. The composition operators are superposition over
place and transitions, based on place and transitions labels,
as deﬁned in [7]. Synchronizing transitions and commu-
nicating places are easily recognizable in the ﬁgures, since
labels are graphically represented by a sufﬁx “jlabel name”
to the place or transition tag. We also remind the reader
that in SWN syntax S is a constant function that means “all
colours of a (sub)class”, and that “!” indicates the succes-
sor function (for ordered classes only); in the SWN models
presented in this paper we have used x and l to indicate a
variable of colour T (tasks) and L (levels), respectively.
Figure 3(a) models the user tasks: each task performs
activities independently from the others and then requires a
synchronization on a given level by sending a “READY”
message to the DS through a mailbox (place with label
”TK DS R”): when the synchronization is reached, an ack
message is sent back to the task through another mailbox
(place with label “DS TK R”) that may proceed to the next
activity towards the next synchronization level (indeed there
is the successor function “!” on the arc from rcv-global-
synch to place tk1). A task may fail while working and
later be restarted. Failure and restart events are modeled
by timed transitions. This model interacts with the back-
bone through transition labels FAULT and RESTART, with
the DS through place labels TK DS R and DS TK R. The
initial marking is non null only in place tk1, where there
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:16:05 UTC from IEEE Xplore.  Restrictions apply. 
are two tokens, meaning that tasks t1 and t2 are working to
reach level l1.
The model is also tightly interfaced with the model of
the DSTable, as explained later in this section.