including important real-world attacks such as truncation attacks [35]. In Appendix A, we show how to
achieve plaintext-stream integrity (INT-PS) for this scheme. Loosely, what we show is that if we restrict
the adversary such that its SD-query responses ensure correct operation of the channel, then security in the
INT-CS sense implies INT-PS. (This reﬂects a result of FGMP.) Thus, security for CH follows from the INT
security of AE via Theorem 3. An interesting question is whether correctness of M, along with INT security
of AE, suﬃces for INT-PS of CH. We leave this for future work.
The subject of this paper is the mechanism by which data streams are protected in TLS 1.3. Our model
permits the study of the security of data transmitted between key changes. (See the discussion in Section 5.1.)
This is valid, since under appropriate assumptions about the underlying key-derivation function used in TLS,
the record-layer state is eﬀectively independent between key changes. However, one limitation of our model
is that we cannot say anything about the security of the concatenation of data sent across key changes. In
particular, consider the concatenation of the application-data stream sent in the early-data phase and in the
post-handshake phase. Early data is replayable, since the adversary can send this data to any number of
valid recipients in possession of a pre-shared key shared with the client. Our model cannot account for such
replay attacks. This also limits our ability to study truncation attacks [35], since these may involve data
sent across key changes. Finally, we note that since we have analyzed TLS 1.3 in isolation, our results say
nothing about the record layer speciﬁcations in TLS 1.2, 1.1, 1.0, SSL 3, and so on.
6 Conclusion
Despite these limitations, the preceding analysis oﬀers good news about TLS 1.3. We regarded the record
layer as a multiplexed, stream-based channel, a setting which accurately models secure channels as they
are used in practice. We formalized it as a partially speciﬁed channel, allowing us to encapsulate in one
scheme (see Figure 7) the myriad implementations that its standardizing document admits. We conﬁrm its
privacy and integrity in our strong adversarial model, but with two important caveats: ﬁrst, whether the
record layer hides the length, content, or type of input streams depends crucially on details left unspeciﬁed
by the standard. Nevertheless, our results—speciﬁcally, Theorems 2 and 4—provide guidance on how to
develop implementations that achieve a target security goal. Concretely, this goal is a property of the
stream multiplexer used to construct the channel. The second caveat is that draft 23 of the record layer
does not achieve security in the sense of ciphertext-stream integrity; we suggested a simple change to the
standard so that it provably does (Theorem 3), which was adopted in the ﬁnal version.
Our partial speciﬁcation of the record layer is simple and ﬂexible; our hope is that this paradigm will help
shape the standard-writing process. Thinking formally about what the protocol must get right and what it
may get wrong provides principled guidance in its development. Although the partially speciﬁed protocol
framework is not the only way to reason about how unspeciﬁed or under-speciﬁed matters aﬀect security,
we found it to be a useful tool for discovering what these security-critical matters are in the ﬁrst place. This
paper leaves open a number of directions for future work. Our notions of security apply to settings in which
an out-of-order packet is regarded as an attack (e.g., TLS and SSH); our framework can be applied to other
notions of security appropriate for settings in which packet loss is expected (e.g., DTLS and IPSec). Beyond
channels, we hope to see the Rogaway-Stegers framework applied more broadly. e.g., to the TLS handshake.
7 Acknowledgements
We thank Mihir Bellare and the CCS program committee for their useful feedback. This work was supported
by NSF grants CNS-1564444 and CNS-1816375.
26
References
[1] Albrecht, M.R., Degabriele, J.P., Hansen, T.B., Paterson, K.G.: A surfeit of SSH cipher suites. In:
Proceedings of the 23rd ACM SIGSAC Conference on Computer and Communications Security, ACM
(2016) 1480–1491
[2] Albrecht, M.R., Paterson, K.G., Watson, G.J.: Plaintext recovery attacks against SSH. In: Proceedings
of the 30th IEEE Symposium on Security and Privacy, IEEE (2009) 16–26
[3] AlFardan, N.J., Paterson, K.G.: Lucky thirteen: Breaking the TLS and DTLS record protocols. In:
2013 IEEE Symposium on Security and Privacy, IEEE (2013) 526–540
[4] Andreeva, E., Bogdanov, A., Luykx, A., Mennink, B., Mouha, N., Yasuda, K.: How to securely release
In: Advances in Cryptology – ASIACRYPT 2014,
unveriﬁed plaintext in authenticated encryption.
Springer Berlin Heidelberg (2014) 105–125
[5] Badertscher, C., Matt, C., Maurer, U., Rogaway, P., Tackmann, B.: Augmented secure channels and
the goal of the TLS 1.3 record layer. In: Provable Security, Springer International Publishing (2015)
85–104
[6] Barwell, G., Page, D., Stam, M.: Rogue decryption failures: Reconciling ae robustness notions. In: Pro-
ceedings of the 15th IMA International Conference on Cryptography and Coding, Springer International
Publishing (2015) 94–111
[7] Bellare, M., Kohno, T., Namprempre, C.: Breaking and provably repairing the SSH authenticated
encryption scheme: A case study of the Encode-then-Encrypt-and-MAC paradigm. ACM Trans. Inf.
Syst. Secur. 7(2) (2004) 206–241
[8] Bellare, M., Namprempre, C.: Authenticated encryption: Relations among notions and analysis of the
generic composition paradigm. Cryptology ePrint Archive, Report 2000/025 (2000) https://eprint.
iacr.org/2000/025.
[9] Bellare, M., Rogaway, P.: Encode-Then-Encipher encryption: How to exploit nonces or redundancy
in plaintexts for eﬃcient cryptography. In: Advances in Cryptology — ASIACRYPT 2000, Springer
Berlin Heidelberg (2000) 317–330
[10] Bellare, M., Rogaway, P.: The security of triple encryption and a framework for code-based game-playing
proofs. In: Proceedings of the 24th Annual International Conference on The Theory and Applications
of Cryptographic Techniques, Springer-Verlag (2006) 409–426
[11] Bellare, M., Tackmann, B.: The multi-user security of authenticated encryption: AES-GCM in TLS
1.3. In: Advances in Cryptology – CRYPTO 2016, Springer Berlin Heidelberg (2016) 247–276
[12] Bhargavan, K., Lavaud, A.D., Fournet, C., Pironti, A., Strub, P.Y.: Triple handshakes and cookie
cutters: Breaking and ﬁxing authentication over TLS. In: Proceedings of the 35th IEEE Symposium
on Security and Privacy, IEEE (2014) 98–113
[13] Boldyreva, A., Degabriele, J.P., Paterson, K.G., Stam, M.: Security of symmetric encryption in the
In: Advances in Cryptology – EUROCRYPT 2012, Springer
presence of ciphertext fragmentation.
Berlin Heidelberg (2012) 682–699
[14] Boldyreva, A., Degabriele, J.P., Paterson, K.G., Stam, M.: On symmetric encryption with distinguish-
able decryption failures. In: Fast Software Encryption, Springer Berlin Heidelberg (2014) 367–390
[15] Bck, H., Zauner, A., Devlin, S., Somorovsky, J., Jovanovic, P.: Nonce-disrespecting adversaries:
Practical forgery attacks on gcm in tls. Cryptology ePrint Archive, Report 2016/475 (2016) https:
//eprint.iacr.org/2016/475.
[16] Degabriele, J.P., Paterson, K., Watson, G.: Provable security in the real world.
IEEE Security &
Privacy 9(3) (2011) 33–41
27
[17] Degabriele, J.P., Paterson, K.G.: On the (in)Security of IPsec in MAC-then-encrypt Conﬁgurations.
In: Proceedings of the 17th ACM Conference on Computer and Communications Security, ACM (2010)
493–504
[18] Delignat-Lavaud, A., Fournet, C., Kohlweiss, M., Protzenko, J., Rastogi, A., Swamy, N., Zanella-
Beguelin, S., Bhargavan, K., Pan, J., Zinzindohoue, J.K.:
Implementing and proving the TLS 1.3
record layer. In: Proceedings of the 38th IEEE Symposium on Security and Privacy (SP), IEEE (2017)
463–482
[19] Fischlin, M., G¨unther, F., Marson, G.A., Paterson, K.G.: Data is a stream: Security of stream-based
channels. In: Advances in Cryptology – CRYPTO 2015, Springer Berlin Heidelberg (2015) 545–564
[20] Fischlin, M., G¨unther, F., Marson, G.A., Paterson, K.G.: Data is a stream: Security of stream-based
channels. Cryptology ePrint Archive, Report 2017/1191 (2017) https://eprint.iacr.org/2017/1191.
[21] Google: Quic, a multiplexed stream transport over udp https://www.chromium.org/quic, accessed
13 Feb 2018.
[22] Hoang, V.T., Krovetz, T., Rogaway, P.: Robust authenticated-encryption AEZ and the problem that
it solves. In: Advances in Cryptology – EUROCRYPT 2015, Springer Berlin Heidelberg (2015) 15–44
[23] Kent, S., Seo, K.: Security architecture for the internet protocol. RFC 4301, RFC Editor (December
2005) http://www.rfc-editor.org/rfc/rfc4301.txt.
[24] Krawczyk, H.: Cryptographic extraction and key derivation: The HKDF scheme.
In: Advances in
Cryptology – CRYPTO 2010, Springer Berlin Heidelberg (2010) 631–648
[25] McGrew, D.: An interface and algorithms for authenticated encryption. RFC 5116, RFC Editor
(January 2008) http://www.rfc-editor.org/rfc/rfc5116.txt.
[26] Namprempre, C., Rogaway, P., Shrimpton, T.: Reconsidering generic composition. In: Advances in
Cryptology – EUROCRYPT 2014, Springer Berlin Heidelberg (2014) 257–274
[27] Paterson, K.G., AlFardan, N.J.: Plaintext-recovery attacks against datagram TLS. In: 19th Annual
Network and Distributed System Security Symposium, NDSS. (2012)
[28] Paterson, K.G., Ristenpart, T., Shrimpton, T.: Tag size does matter: Attacks and proofs for the tls
record protocol. In: Advances in Cryptology – ASIACRYPT 2011, Springer Berlin Heidelberg (2011)
372–389
[29] Patton, C., Shrimpton, T.: Partially speciﬁed channels: The tls 1.3 record layer without elision. In:
Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security. CCS
18, New York, NY, USA, Association for Computing Machinery (2018) 14151428
[30] Rescorla, E.: The transport layer security (tls) protocol version 1.3. RFC 8446, RFC Editor (August
2018)
[31] Rescorla, E., Tschofenig, H., Modadugu, N.: The Datagram Transport Layer Security (DTLS) Protocol
Version 1.3. Internet-Draft draft-ietf-tls-dtls13-22, IETF Secretariat (2017) https://tools.ietf.org/
html/draft-ietf-tls-dtls13-22.
[32] Rescorla, E.: The Transport Layer Security (TLS) Protocol version 1.3. Internet-Draft draft-ietf-tls-
tls13-23, IETF Secretariat (2018) https://tools.ietf.org/html/draft-ietf-tls-tls13-23.
[33] Rogaway, P., Stegers, T.: Authentication without elision.
In: 2009 22nd IEEE Computer Security
Foundations Symposium, IEEE (2009) 26–39
[34] Rogaway, P.: Authenticated-encryption with associated-data. In: Proceedings of the 9th ACM Confer-
ence on Computer and Communications Security, ACM (2002) 98–107
28
Read (cid:48)O(C, var Re)
1 declare bool b
2 (Y, H, α) ←← Read O(C, var Re)
3 (cid:104)c(cid:105) ←← O((cid:104)read, output 1(cid:105))
4 return (Y, H (cid:107) c, α)
Demux (cid:48)O(X, H(cid:48), α, var De)
5 (cid:96) ← |H(cid:48)|; H ← H(cid:48)[1:(cid:96) − 1]; c ← H(cid:48)
6 (M, sc, γ) ←← Demux O(Y, H, α, var De)
7 if c = 1 then return (M, sc, γ)
8 F ←← O((cid:104)demux, frag, M(cid:105))
9 ϕ ←← O((cid:104)demux, ctx, sc(cid:105))
10 return (F, ϕ, γ)
(cid:96)
Figure 12: Procedures Read (cid:48) and Demux (cid:48).
[35] Smyth, B., Pironti, A.: Truncating TLS connections to violate beliefs in web applications. In: Presented
as part of the 7th USENIX Workshop on Oﬀensive Technologies, USENIX (2013)
[36] Vaudenay, S.: Security ﬂaws induced by CBC padding — Applications to SSL, IPSEC, WTLS... In:
Advances in Cryptology — EUROCRYPT 2002, Springer Berlin Heidelberg (2002) 534–545
[37] Ylonen, T., Lonvick, C.: The secure shell (SSH) protocol architecture. RFC 4251, RFC Editor (January
2006) http://www.rfc-editor.org/rfc/rfc4251.txt.
A Fully speciﬁed channels
Conspicuously absent from our treatment in Section 4 is a correctness condition for PSCs.
Indeed, it is
undesirable to require correctness in our setting; we want our results to hold up even when the SD is realized
by the adversary. But this choice is not without consequences, since we cannot assume correctness in proofs
of security, as is so often done in cryptography [8, 20]. In particular, contrary to prior settings, it is not
the case that ciphertext-stream integrity implies plaintext-stream integrity for PSCs. We show this with a
counter example, then show how to restrict the SD in order to recover the classic result.
INT-CS (cid:54)⇒ INT-PS for PSCs. Let CH = (Init , Mux , Write , Read , Demux ) be a PSC. We deﬁne from
this a new PSC CH(cid:48) = (Init , Mux , Write , Read (cid:48), Demux (cid:48)), where Read (cid:48) and Demux (cid:48) are given in Figure 12.
Whatever were the SD associated to PSC CH, we add to this a new reader speciﬁcation detail that on input
(cid:104)read, output 1(cid:105) returns a bit c. Under any correct realization of CH(cid:48) this bit must be 1. The Read (cid:48) algorithm
runs (Y, H, α) ←← Read O(C, var Re) and outputs (Y, H (cid:107) c, α). Likewise, we add two new demultiplexer SD
hooks: ﬁrst, one that inputs (cid:104)demux, frag, M(cid:105), where M is a string or ⊥, and returns a string F ; second, one
that inputs (cid:104)demux, ctx, sc(cid:105), where sc is a string or ⊥, and returns a string ϕ. The Demux (cid:48) algorithm, on
input (X, H(cid:48), α, var De) parses H(cid:48) into H and the extra bit, and executes Demux O(Y, H, α, var De). If the
extra bit is 1, then Demux (cid:48) returns whatever Demux did. Otherwise, the output fragment M is replaced
with F and the stream context sc gets replaced with ϕ.
CH(cid:48) (A(cid:48)). Consider
the following INT-PS attack: choose any string C and ask it of Recv. On SD request (cid:104)read, output 1(cid:105), the
attacker responds with (cid:104)0(cid:105). On SD request (cid:104)demux, frag, M(cid:105) for some M ∈ {0, 1}∗ ∪ {⊥}, if M (cid:54)= ⊥, then
choose any string F (cid:54)(cid:22) M and output it; otherwise, choose any string F (cid:54)= ε and output it. On SD request
(cid:104)demux, ctx, sc(cid:105) for some sc ∈ {0, 1}∗ ∪ {⊥}, if sc (cid:54)= ⊥, then output ϕ = sc; otherwise, choose any string ϕ
and output it. Then Sϕ = (cid:5) by deﬁnition, and the adversary ensures that Rϕ (cid:54)= (cid:5). Clearly Rϕ (cid:54)(cid:22) Sϕ, and
♦
the adversary wins with probability 1.
The attack just described exploits the fact that the adversary controls the SD. Note, too, that the
adversarial handling of the SD does not result in a correct realization of CH(cid:48). This raises the question of
whether or not there is a separation when the PSC is correctly realized.
A partially speciﬁed channel is transformed into a fully speciﬁed channel (FSC) by instantiating the SD
oracle. Given a PSC CH, we deﬁne an FSC as a triple (CH,S,R), where S(str I, var str Env ) (cid:55)→ str O
and R(str I, var str Env ) (cid:55)→ str O are randomized algorithms that instantiate the SD oracle for the sender
(Mux , Write ) and receiver (Read , Demux ), respectively. We may deﬁne correctness FSCs as follows:
It is easy to show that for every A, there exists A(cid:48) such that Advint-cs
CH (A) = Advint-cs
29
Gets (M , s, sc) // M , s ∈ {0, 1}∗∗
1 M(cid:48) ← ε
2 for i ← 1 to |s| do
4 return M(cid:48)
if si = sc then M(cid:48) ← M(cid:48) (cid:107) M i
3
Corr (C(cid:48), M , s)
5 declare Env [ ]
6 (Mu, Wr , Re, De) ←← Init
7 C ←← Sends (M , s, Mu, Wr )
8 (Y (cid:48), M(cid:48), s(cid:48)) ←← Recvs (C(cid:48), Re, De)
9 return (C, Y (cid:48), M(cid:48), s(cid:48))
G (A)
1 declare str Env , R[ ], S[ ], T
2 declare bool sync, win[ ]
3 (Mu, Wr , Re, De) ←← Init ( )
4 sync ← 1; ASend,Recv
1
5 return win 1
(var Env )
Send(M, sc)