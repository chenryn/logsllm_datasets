在所有可能的Chrome进程中，只有GPU进程和Audio
utility进程有权访问非沙箱令牌。这并不意外。渲染器进程比GPU或Audio沙箱具有更多的锁定功能，这是由于调用系统服务以使这些进程正常运行的限制。这确实意味着，由于大多数远程代码执行发生在呈现的HTML或JS内容中，因此大大降低了远程代码执行出现沙箱逃逸的可能性。也就是说，确实存在GPU漏洞，例如Lokihardt曾在Pwn2Own
2016上使用过的一个漏洞。
接下来，让我们集中讨论逃逸GPU进程沙箱。由于我现在没有GPU远程代码执行，因此我将DLL注入到进程中以实现逃逸。这并不像听起来那么简单，一旦GPU进程启动，该进程就被锁定为仅加载Microsoft签名的DLL。我使用了KnownDlls的技巧将DLL加载到内存中。
为了实现沙箱逃逸，我们需要执行以下操作：
1、打开一个不受限制的令牌；
2、复制令牌，以创建新的主令牌，并使令牌可写；
3、删除令牌的IL，以匹配当前令牌（对于GPU来说，这是低IL）；
4、使用新令牌调用`CreateProcessAsUser`；
5、逃逸低IL沙箱。
即使是第一步，我们也存在问题。获取不受限制令牌的最简单方法是为父进程（即主要的Chrome浏览器进程）打开令牌。但是，如果查看令牌列表，我们发现GPU进程可以访问，但其中不包括Chrome主浏览器进程。原因在于，GPU进程沙箱可以打开浏览器进程的令牌。使用这个令牌，可以创建一个新的受限令牌，该令牌将通过同级检查，以创建具有更多访问权限的新进程，并逃逸沙箱。为了缓解这种情况，我修改了对进程令牌的访问权限，以阻止较低IL的进程为`TOKEN_DUPLICATE`访问打开令牌。大家可以关注`HardenTokenIntegerityLevelPolicy`。在进行这一修复之前，我们不需要内核中的漏洞，即可逃逸Chrome
GPU沙箱，至少不需要正常的低级别IL令牌。
因此，我们无法使用简单的方法，但我们应该可以简单地枚举进程，并找到符合标准的一个进程。我们可以通过使用`NtGetNextProcess`系统调用来实现这一点，正如我在上一篇文章中所描述的一样。我们打开所有进程，以进行`PROCESS_QUERY_LIMITED_INFORMATION`访问，然后打开令牌，进行`TOKEN_DUPLICATE`和`TOKEN_QUERY`访问。然后，我们可以检查令牌，以确保其不受限制，然后再继续执行第二步。
要复制令牌，我们可以调用`DuplicateTokenEx`并请求传递`TOKEN_ALL_ACCESS`作为所需访问的主令牌。但是，有一个新问题，当我们尝试降低IL时，会从`SetTokenInformation`中得到`ERROR_ACCESS_DENIED`。这是由于Microsoft在WIndows
10中添加了沙箱缓解措施，并向后移植到了所有受支持的操作系统，包括Windows
7。下面的代码是`NtDuplicateToken`的摘要，其中已经引入了缓解措施：
    ObReferenceObjectByHandle(TokenHandle, TOKEN_DUPLICATE, 
        SeTokenObjectType, &Token, &Info);
    DWORD RealDesiredAccess = 0;
    if (DesiredAccess) {
        SeCaptureSubjectContext(&Subject);
        if (RtlIsSandboxedToken(Subject.PrimaryToken) 
         && RtlIsSandboxedToken(Subject.ClientToken)) {
            BOOLEAN IsRestricted;
            SepNewTokenAsRestrictedAsProcessToken(Token,
                Subject.PrimaryToken, &IsRestricted);
            if (Token == Subject.PrimaryToken || IsRestricted)
                RealDesiredAccess = DesiredAccess;
            else
                RealDesiredAccess = DesiredAccess 
                    & (Info.GrantedAccess | TOKEN_READ | TOKEN_EXECUTE);
        }
    } else {
        RealDesiredAccess = Info.GrantedAccess;
    }
    SepDuplicateToken(Token, &DuplicatedToken, ...)
    ObInsertObject(DuplicatedToken, RealDesiredAccess, &Handle);
当我们复制令牌时，内核会检查调用方是否已经沙箱化。如果将其沙箱化，则内核将检查要复制的令牌的限制是否小于调用方。如果限制较少，则代码会将所需的访问权限限制为`TOKEN_READ`和`TOKEN_EXECUTE`。这意味着，如果我们请求类似于`TOKEN_ADJUST_DEFAULT`这样的写访问权限，它将被从赋值调用返回给我们的句柄删除。反过来，这会阻止我们减少IL，以便可以将其分配给新进程。
这似乎导致我们的漏洞利用链彻底终结。如果我们无法写入令牌，就无法降低令牌的IL，从而无法对其进行分配。但是，这个实现有一个小缺陷，重复操作将会继续完成，并仅返回具有受限访问权限的句柄。当我们创建新的令牌对象时，默认安全性将授予调用方对令牌对象的完全访问权限。这意味着，一旦我们获得了新令牌的句柄，就可以调用普通的`DuplicateHandle`API将其转换为完全可写的句柄。目前我们还不清楚这是不是有意的，但应该注意的是，如果新令牌的限制没那么严格，那么`CreateRestrictedToken`中的类似检查会返回错误。无论如何，我们都可以滥用这个功能，以获得可写的、不受限制的令牌，以将其分配给具有正确IL的新进程。
现在，我们可以获得一个不受限制的令牌，可以调用`CreateProcessAsUser`来创建我们的新进程。但它的速度并不快，因为GPU进程仍然在受限Job对象中运行，这会阻止创建新进程。在将近5年前的一篇名为“In-Console-Able”的文章中，我详细介绍了Job对象如何阻止新进程的创建。我们不能在控制台驱动程序中使用相同的漏洞来逃逸Job对象吗？在Windows
8.1上，我们似乎可以，但是在Windows 10上，有两件事阻止我们对其的利用：
1、Microsoft更改了Job对象以支持辅助进程计数器。如果我们拥有`SeTcbPrivilege`，我们可以将一个标志传递给`NtCreateUserProcess`，以在Job内部创建一个新进程，该进程不计入进程总数。控制台驱动程序使用它来清除了逃逸Job的前置条件。由于我们在沙箱中没有`SeTcbPrivilege`，因此无法使用这个功能。
2、Microsoft为令牌添加了一个新的标志，以防止将其用于新的进程。Chrome会在所有沙箱进程中设置这个标志，以限制新的子进程。即使没有1，该标志也将阻止滥用控制台驱动程序以产生新的进程。
通过将这两个功能块进行组合，我们借助滥用控制台驱动程序的方式，在当前Job之外产生了一个新的进程。我们需要想出一种方式，既可以避免Job对象限制，也可以绕过子进程限制的标志。
Job对象是从父对象继承到子对象的，因此，如果我们可以在Job对象之外找到GPU进程可以控制的基础讷航，则可以将该进程用作新的父对象并逃逸Job。遗憾的是，在默认情况下，如果我们检查GPU进程可以访问哪些进程，会发现它只能自行打开。
    PS> Get-AccessibleProcess -ProcessIds 6804 -AccessRights GenericAll `
                 | Select-Object ProcessId, Name
    ProcessId Name
    --------- ----         6804 chrome.exe
打开其自身可能不会很有帮助，但我们不能依靠运气来实现漏洞利用，我们需要尝试别的方式。
我注意到一件事，在一个很小的竞争条件下，设置一个新的Chrome沙箱程序。首先创建进程，然后应用Job对象。如果我们可以让Chrome浏览器生成新的GPU进程，就可以在应用Job对象之前将其用作父进程。GPU进程的处理甚至支持崩溃时重新生成该进程。但是，我们找不到在不导致当前GPU进程终止的情况下，启动新GPU进程的方法，因此无法运行足够长的代码来利用竞争条件。
相反，我决定专注于寻找一个RPC服务，该服务将在Job之外创建一个新进程。有很多RPC服务将进程创建作为主要目标，而其他服务则将进程创建作为一个附加功能。例如，我们以前说过Secondary
Logon服务，其中RPC服务的全部目的是产生新进程。  
但是，这个想法有一个小缺陷，令牌中的子进程缓解标志是跨模拟边界继承的。由于通常使用模拟令牌作为新进程的基础，因此任何新的进程都将被阻止。但是，我们有一个未设置标志的非受限令牌，可以使用非受限令牌创建一个可以在RPC调用期间模拟的受限令牌，并且可以绕过子进程缓解标志。
我尝试列出可以通过这种方式利用的已知服务，如下所示：
Secondary Logon Service 不可访问 不可逃逸Job
WMI Win32_Process 不可访问 可以逃逸Job
用户帐户控制（UAC） 可访问 不可逃逸Job
后台智能传输服务（BITS） 不可访问 可以逃逸Job
DCOM Activator 可访问 可以逃逸Job
上表并不全面，可能还会有其他RPC服务允许创建进程。但是，正如我们在上面所看到的那样，我们无法从沙箱级别访问这些派生出Secondary
Logon、WMI、BITS的已知RPC服务。UAC服务是可以访问的，存在一种通过滥用调试对象来滥用服务，以运行任意特权代码的方法。但遗憾的是，当创建一个新的UAC进程时，该服务会将父进程设置为调用方进程。继承Job对象后，新进程将会被阻止。
列表中的最后一个服务是DCOM