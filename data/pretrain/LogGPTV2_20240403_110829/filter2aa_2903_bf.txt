在DR7寄存器中，有24位是被划分成4组分别与4个调试地址寄存器
相对应的，比如L0、G0、R/W0和LEN0这6位是与DR0相对应的，L1、
G1、R/W1和LEN1这6位是与DR1相对应的，其余的以此类推。表4-1列
出了DR7中各个位域的具体含义。
表4-1 调试控制寄存器（DR7）
简 
称
全  称
比 特 
位
描  述
R/W0
～
R/W3 读写域
R/W0：
16，17
R/W1：
20，21
R/W2：
分别与DR0～DR3这4个调试地址寄存器相对应，
用来指定被监控地址的访问类型，其含义如下。
● 00：仅当执行对应地址的指令时中断
● 01：仅当向对应地址写数据时中断
● 10：386和486不支持此组合。对于以后的
CPU，可以通过把CR4寄存器的DE（调试扩展）
24，25
R/W3：
28，29
位设为1启用该组合，其含义为“当向相应地址进
行输入输出（即I/O读写）时中断”
● 11：当向相应地址读写数据时都中断，但是
从该地址读取指令除外
LEN0
～
LEN3
长度域
LEN0：
18，19
LEN1：
22，23
LEN2：
26，27
LEN3：
30，31
分别与DR0～DR3这4个调试地址寄存器相对应，
用来指定要监控的区域长度，其含义如下。
● 00：1字节长
● 01：2字节长
● 10：8字节长（奔腾4或至强CPU）或未定义
（其他处理器）
● 11：4字节长 注意：如果对应的R/Wn为0（即
执行指令中断），那么这里的设置应该为0，参
见下文
L0～
L3
局部断点启用
L0：0
L1：2
L2：4
L3：6
分别与DR0～DR3这4个调试地址寄存器相对应，
用来启用或禁止对应断点的局部匹配。如果该位
设为1，当CPU在当前任务中检测到满足所定义
的断点条件时便中断，并且自动清除此位。如果
该位设为0，便禁止此断点
G0～
G3
全部断点启用
G0：1
G1：3
G2：5
G3：7
分别对应DR0～DR3这4个调试地址寄存器，用来
全局启用和禁止对应的断点。如果该位设为1，
当CPU在任何任务中检测到满足所定义的断点条
件时都会中断；如果该位设为0，便禁止此断
点。与L0～L3不同，断点条件发生时，CPU不会
自动清除此位
LE和
GE
启用局部或者
全局（精确）
断点（Local
and Global
(exact)
breakpoint
Enable）
LE：8
GE：9
从486开始的IA-32处理器都忽略这两位的设置。
此前这两位是用来启用或禁止数据断点匹配的。
对于早期的处理器，当设置有数据断点时，需要
启用本设置，这时CPU会降低执行速度，以监视
和保证当有指令要访问符合断点条件的数据时产
生调试异常
GD
启用访问检测
（General
Detect
Enable）
13
启用或禁止对调试寄存器的保护。当设为1时，
如果CPU检测到将修改调试寄存器（DR0～
DR7）的指令，CPU会在执行这条指令前产生一
个调试异常
通过表4-1的定义可以看出，调试控制寄存器的各个位域提供了很
多选项允许我们通过不同的位组合定义出各种断点条件。
下面进一步介绍读写域R/Wn，通过对它的设置，我们可以指定断
点的访问类型（又称访问条件），即以何种方式（读写数据、执行代码
还是I/O）访问地址寄存器中指定的地址时中断。读写域占两个二进制
位，可以指定4种访问方式，满足不同调试情况的需要。以下是3类典型
的使用方式，其中第一类又分两种情况。
（1）读/写内存中的数据时中断：这种断点又称为数据访问断点
（data access breakpoint）。利用数据访问断点，我们可以监控对全局变
量或局部变量的读写操作。例如，当进行某些复杂的系统级调试或者调
试多线程程序时，我们不知道是哪个函数或线程在何时修改了某一变
量，这时就可以设置一个数据访问断点。以WinDBG调试器为例，可以
通过ba命令来设置这样的断点，如ba w4 00401200。其中ba代表break on
access，w4 00401200的含义是对地址00401200开始的4字节内存区进行
写操作时中断。如果我们希望有线程或代码读这个变量时也中断，那么
只要把w4换成r4便可以了。现代调试器大多还都支持复杂的条件断点，
比如当某个变量等于某个确定的值时中断，这其实也可以用数据访问断
点来实现，其基本思路是设置一个数据访问断点来监视这个变量，当每
次这个变量的值发生改变时，CPU都会通知调试器，由调试器检查这个
变量的值，如果不满足规定的条件，就立刻返回让CPU继续执行；如果
满足，就中断到调试环境。
（2）执行内存中的代码时中断：这种断点又称为代码访问断点
（code access breakpoint）或指令断点（instruction breakpoint）。代码访
问断点从实现的功能上看与软件断点类似，都是当CPU执行指定地址开
始的指令时中断。但是通过寄存器实现的代码访问断点与软件断点相比
有个优点，就是不需要像软件断点那样向目标代码中插入断点指令。这
个优点在某些情况下非常重要。例如，在调试位于ROM（只读存储
器）上的代码（比如BIOS中的POST程序）时，我们根本没有办法向那
里插入软件断点（INT 3）指令，因为目标内存是只读的。此外，软件
断点的另一个局限是，只有当目标代码被加载进内存后，才可以向该区
域设置软件断点。而调试寄存器断点没有这些限制，因为只要把需要中
断的内存地址放入调试地址寄存器（DR0～DR3），并设置好调试控制
寄存器（DR7）的相应位就可以了。
（3）读写I/O（输入输出）端口时中断：这种断点又称为I/O访问断
点（Input/Output access breakpoint）。I/O访问断点对于调试使用输入输
出端口的设备驱动程序非常有用。也可以利用I/O访问断点来监视对I/O
空间的非法读写操作，提高系统的安全性，这是因为某些恶意程序在实
现破坏动作时，需要对特定的I/O端口进行读写操作。
读写域定义了要监视的访问类型，地址寄存器（DR0～DR3）定义
了要监视的起始地址。那么要监视的区域长度呢？这便是长度域
LENn（n=0，1，2，3，位于DR7中）的任务。LENn位段可以指定1、
2、4或8字节长的范围。
对于代码访问断点，长度域应该为00，代表1字节长度。另外，地
址寄存器应该指向指令的起始字节，也就是说，CPU只会用指令的起始
字节来检查代码断点匹配。
对于数据和I/O访问断点，有两点需要注意：第一，只要断点区域
中的任一字节在被访问的范围内，都会触发该断点。第二，边界对齐要
求，2字节区域必须按字（word）边界对齐，4字节区域必须按双字
（doubleword）边界对齐，8字节区域必须按4字（quadword）边界对
齐。也就是说，CPU在检查断点匹配时会自动去除相应数量的低位。因
此，如果地址没有按要求对齐，可能无法实现预期的结果。例如，假设
希望通过将DR0设为0xA003、将LEN0设为11（代表4字节长）实现任何
对0xA003～0xA006内存区的写操作都会触发断点，那么只有当0xA003
被访问时会触发断点，对0xA004、0xA005和0xA006处的内存访问都不
会触发断点。因为长度域指定的是4字节，所以CPU在检查地址匹配
时，会自动屏蔽起始地址0xA003的低2位，只是匹配0xA000。而
0xA004、0xA005和0xA006屏蔽低2位后都是0xA004，所以无法触发断
点。
4.2.4 指令断点
关于指令断点还有一点要说明。对于如下所示的代码片段，如果指
令断点被设置在紧邻MOV SS EAX的下一行，那么该断点永远不会被触
发。原因是为了保证栈段寄存器（SS）和栈顶指针（ESP）的一致性，
CPU执行MOV SS指令时会禁止所有中断和异常，直到执行完下一条指
令。
MOV SS, EAX
MOV ESP, EBP
类似地，紧邻POP SS指令的下一条指令处的指令断点也不会被触
发。例如，如果指令断点指向的是下面的第二行指令，那么该断点永远
不会被触发。
POP SS
POP ESP
但是，当有多个相邻的MOV SS或POP SS指令时，CPU只会保证对
第一条指令采取如上“照顾”。例如，对于下面的代码片段，指向MOV
ESP, EBP的指令断点是会被触发的。
MOV SS, EDX
MOV SS, EAX
MOV ESP, EBP
IA-32手册推荐使用LSS指令来加载SS和ESP寄存器，通过LSS指
令，一条指令便可以改变SS和ESP两个寄存器。
4.2.5 调试异常
IA-32架构专门分配了两个中断向量来支持软件调试，即向量1和向
量3。向量3用于INT 3指令产生的断点异常（breakpoint exception，即
#BP）。向量1用于其他情况的调试异常，简称调试异常（debug
exception，即#DB）。硬件断点产生的是调试异常，所以当硬件断点发
生时，CPU会执行1号向量所对应的处理例程。
表4-2列出了各种导致调试异常的情况及该情况所产生异常的类
型。
表4-2 导致调试异常的各种情况
异 常 情 况
DR6标志
DR7标
志
异常
类型