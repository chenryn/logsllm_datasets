双开IDA，用之前的动态破解so方式，来给dvmDexFileOpenPartial函数下断点，获取两个参数的值，然后使用一段脚本，将内存中的dex数据保存到本地磁盘中。
4.分析获取到的dex内容
得到了内存中的dex之后，使用dex2jar工具去查看源码，但是发现无法保存，以为是dump出来的dex格式有问题，但是最后使用baksmali工具进行处理，得到smali源码是可以的，然后就开始分析smali源码。
5.分析源码了解破解思路
通过分析源码得知，在WebViewActivity页面中会加载一个页面，然后那个页面中的JavaScript会调用本地的Java对象中的一个方法来展示toast信息。但是这里遇到了个问题：JavaScript的Java对象名称被混淆加密了，需要去分析那个加密函数，但是这个加密函数是native的，然后就是用IDA去静态分析了这个native函数，但是没有分析完成，因为不需要，其实很简单，只需要结果，不需要过程。现在解密的内容知道了，native方法的定义也知道了，那么就去写一个简单的demo去调用这个so的native方法即可，结果成功了，得到了正确的JavaScript对象名称。
6.了解WebView的安全性
WebView的早期版本的一个漏洞信息，在Android 4.2之前的版本WebView有一个漏洞，就是可以执行Java对象中所有的public方法，那么在JavaScript中就可以这么处理了，先获取getClass方法获取这个对象，然后调用这个对象中的一些特定方法即可，因为Java中所有的对象都有一个getClass方法，而这个方法是public的，同时能够返回当前对象。所以在Android 4.2之后有了一个注解@JavascriptInterface，只有这个注解标识的方法才能在JavaScript中调用。
7.获取输入的新技能
验证结果的过程中发现了一个技巧，就是在输入很长的文本的时候比较烦琐，可以借助adb shell input text命令来实现。
提示：
·通过dump出内存中的dex数据，可以佛挡杀佛了，不管apk如何加固，最终都是需要加载到内存中的。
·了解WebView的安全性相关知识，比如在WebView中JavaScript对象名称做一次混淆还是有必要的，防止被恶意网站调用我们的本地隐私方法。
·可以尝试调用so中的native方法，在知道了这个方法的定义之后。
·用adb shell input text命令来辅助输入。
23.7 本章小结
本章介绍了在Android中如何dump出那些加固的apk程序，核心方法就一个：不管上层怎么加固，最终加载到内存的dex文件肯定不是加固的，所以这个dex就是想要的。这里使用了IDA来动态调试libdvm.so中的dvmDexFileOpenPartial函数来获取内存中的dex文件，同时还可以使用gdb+gdbserver来获取，这个方法请自行搜索吧。前两章的内容，加上本章内容就是Android中大体的破解方式，当然这三种方式不是万能的，因为加固和破解是军备竞赛，不断升级，没有哪一方有绝对的优势。当然还有很多其他的破解方式，后面如果遇到的话，会再详细说明。
现在市场中的应用为了安全考虑采用了第三方平台进行应用的加固，加固的思想也是大同小异。在逆向加固应用的时候，其实只要遵循一个目标就是找到关键点函数，下好断点，dump出内存中的dex文件。问题就在于这个关键点函数了，这个关键点函数会很多，所以在逆向的时候需要多次进行尝试，而这些关键点函数也是随着逆向经验的增加而收集得更多。
第24章 逆向应用经典案例分析
本章介绍如何逆向市场中的一些加壳方案，现在市场中有很多加壳平台，这些加壳平台会做一些反调试操作，对so文件进行混淆加密等，让脱壳变得比较困难。本章将介绍加壳原理以及脱壳方法，并总结了脱壳经验。
24.1 加壳原理分析
先用一个案例来看看加壳原理。首先自己弄一个demo程序，然后去某加壳网站上加固一下，得到加固之后的apk，然后开始破解。
1.反编译apk
解压apk，看看大体的目录，得到classes.dex文件，然后用dex2jar+jd-gui得到Java源码，如图24-1所示。
图24-1 反编译之后的源码
看到这里只有Application的壳，而且这个是加固之后的特点，都是这两个Application的。
使用apktool来反编译apk，获取资源文件信息：
2.分析加密流程
加固程序把源程序进行加密操作然后隐藏到了一个地方，在之前一章中也说过了，隐藏的地方就那么几个：assets目录、libs目录、自己的dex文件。这里直接看assets目录，如图24-2所示。
图24-2 assets目录
多了这个文件，猜想这个可能就是处理之后的源apk了。在AndroidManifest.xml中看到了入口的SuperApplication类，下面来分析一下这个类：
这里一般都是在attachBaseContext方法中进行操作的，这里的时机比较早，首先会调用loadLibs方法进行加载libs：
这里区分不同的平台，然后拷贝不同的so文件，继续看copyLib方法：
可以看到，从assets目录下把增加的两个so文件libexec.so和libexecmain.so拷贝到应用程序的files目录下，可以去看看assets/ijm_lib目录下的so文件，如图24-3所示。
图24-3 so文件目录
到这里loadLibs方法就执行完了，下面就开始调用NativeApplication的load方法进行加载数据，继续看NativeApplication类：
开始从应用程序的files目录中加载这两个so文件，load方法也是一个native方法，继续看看这两个so文件内容。
首先用IDA打开libexecmain.so文件，如图24-4所示，但是发现，它里面并没有什么重要信息，连JNI_OnLoad函数都没有内容。
图24-4 IDA打开libexecmainso文件
继续查看libexec.so文件，如图24-5所示。
图24-5 IDA打开libexec.so文件
可惜的是，打开提示so文件格式错误，到这里就猜到了，这个so可能被加密处理了，ELF格式改了，点击Yes继续强制打开之后，再使用Ctrl+S查看so的各个段信息，如图24-6所示。
现在确定，没办法分析so文件了，分析到这里，也知道了大体加密流程：
1）按照惯例把源apk进行加密处理存放在一个地方，通过分析猜想是assets目录下的ijiami.dat文件。
图24-6 查看so中的段信息
2）添加壳Application：SuperApplication类在这个壳的attachContext方法中主要做了两件事：
·把assets/ijm_lib目录下的两个so文件copy到程序的files目录中。
·调用NativeApplication的load方法，在这个类中同时也把上面的两个so文件加载到内存中。
3）对apk的加密都是放在底层的两个so文件中操作的，通过IDA去分析这两个so文件之后，发现核心功能的so文件被加密了，IDA打开是看不到具体信息了。
到这里知道加固之后的特点是：在程序的assets目录下多了一个ijiami.dat文件和两个so文件，同时这两个so文件被加密处理了，增加破解难度。
24.2 脱壳过程
上面简单分析了加密的原理和流程，但是没有继续往下面分析了，因为这不是本章讲解的重点，本章的重点是如何脱掉加密的壳。脱壳的核心就一个：给dvmDexFileOpenPartial函数下断点，dump出内存的dex文件即可，那么下面就用IDA开始脱壳操作了。
第一步：启动设备中的android_server
进行端口转发：
第二步：用debug模式启动程序
代码如下：
这里的包名和入口Activity都可以在上面反编译之后的AndroidManifest.xml文件中找到：
第三步：双开IDA
一个用于静态分析libdvm.so，一个用于动态调试，如图24-7所示。
图24-7 获取函数相对地址
记录dvmDexFileOpenPartial函数的相对地址4777C，再次打开一个IDA，进行attach调试进程，如图24-8所示。
图24-8 附加进程
第四步：使用jdb命令attach上调试器
代码如下：
第五步：对dvmDexFileOpenPartial函数下断点
进入调试页面之后，用Ctrl+S键查找libdvm.so的内存基地址415BB000，如图24-9所示。
图24-9 获取so的基地址
将第三步中获取到的相对地址加上基地址4777C+415BB000=4160277C，得到了dvmDex-FileOpenPartial在内存中的绝对地址。
注意，这里还有一个更方便的办法，就是直接打开Modules View，如图24-10所示。
图24-10 Modules视图
在这里查找libdvm.so文件，如图24-11所示。
然后双击libdvm.so文件，如图24-12所示。
图24-11 查找libdvm.so文件
图24-12 获取函数的绝对地址
查找需要下断点的函数名称，看到这里的绝对地址也是4160277C。这里有两种方式可以得到一个函数在内存中的绝对地址。然后使用G键，直接跳转到函数处，下断点，如下所示：
第六步：设置Debugger Options选项
此操作能够让程序断在dvmDexFileOpenPartial函数处，如图24-13所示。
图24-13 设置Debugger Options选项
注意：上面的第四步、第五步、第六步没有顺序，只要在运行之前设置就可以了。
第七步：运行程序
出现这个对话框不要在意，一路点击Cancel即可，如图24-14所示。
图24-14 提示对话框
jdb也attach上了调试程序：
一直点击运行按钮，直到运行到dvmDexFileOpenPartial处的断点，但是可惜的是，这里遇到了错误，如图24-15所示。
图24-15 运行报错
点击OK之后，出现了下面对话框，如图24-16所示。
图24-16 报错对话框
再次点击任何一个按钮，都会退出调试页面，如图24-17所示。
图24-17 退出调试页面
再重新尝试一次上面的流程，开始调试，但是错误是一样的，到这里就立马想到了，之前第8章说的IDA调试so遇到的那个问题：反调试检测。其实这是现在加固平台必要选择的一种方式，反调试原理很简单，就是在程序运行最早的时机，比如so加载的时候即JNI_OnLoad方法中，读取本进程的status文件，查看TracerPid字段是否为0，如果不为0，那么就表示自己的进程被别人跟踪了，也就是attach了，这时候立马退出程序，下面使用IDA在attach进程成功之后，查看本进程的status信息：
看到这里的TracerPid为24336，不为0，表示被24336进程attach了，那么可以查看一下这个进程是谁：
这个进程就是在设备中安插的android_server，它用于和IDA进行通信。
到这里，可以看到应用做了反调试检测，按照上一章的内容，可以给JNI_OnLoad函数下断点，然后找到检测代码，把对应的ARM指令改成空指令，检测失效了，但是这里两个so文件被处理了，IDA没法分析了，那么该怎么办呢？
如何应对反调试呢？可以借助IDA修改寄存器和内存数据的特性来做到。首先上面分析了反调试的原理，一般在native代码去做检测的话，都是用fopen系统函数打开status文件，然后用fgets函数读取一行的内容，一般操作文件都是用fopen函数。
那么思路就有了，既然反调试肯定用到了fopen和fgets这两个函数，那么直接像给dvmDexFileOpenPartial下断点的方式一样，给这两个函数下断点，然后运行到fgets断点处的时候，发现如果是读取TracerPid这行内容的时候，就开始修改内存内容，把TracerPid字段的值改成0，或者修改R0寄存器的内容，跳过反调试检测。
这两个函数是在libc.so文件中的，可以把设备的/system/lib/libc.so使用adb pull到本地即可，然后用IDA得到相对地址，在调试页面得到基地址，然后相加得到绝对地址，跳转即可。但是这里不用这种复杂的方式，有两种方式可以进行跳转。
第一种方式：在Modules界面找到libc.so，然后再找到这两个函数，就可以得到它们的绝对地址了，如图24-18所示。
图24-18 查看fopen函数的绝对地址
然后使用G键，跳转下断点即可，如下所示：
第二种方式：也是最简单的方式，就是用G键，本身就有可以直接输入函数名进行跳转的功能，如图24-19所示。
图24-19 输入函数名跳转
下断点，如下所示：
到这里就给这两个函数下好了断点，当然这里还需要给dvmDexFileOpenPartial函数下断点，一切弄好了之后，这时候再次运行，如下所示：
停在了fopen断点处，使用F8键单步调试，看到R7寄存器中的内容是/proc/...，直接点击R7查看全部内容，如下所示：
内容有点长，大致的内容是/proc/self/cmdline.debug.atrace.app_cmdlines，这个是干什么的？看看这个目录内容：
发现没有这个文件内容，只有cmdline文件，但是可以先不管它了，知道这个肯定不是读取status文件的，那直接略过这个断点，点击F9键运行到下一个断点，中间过程先忽略，一路用F9键，直到运行到了fopen这个断点，如下所示：