(cid:75)(cid:105)n
(cid:104)(cid:74)τ l,∞
= n
= (cid:74)τ l,1
m ; τ l′,1
j=1(cid:74)τ l,1
[ T ∨ T ′ ]n = [ T ]n ∨ [ T ′ ]n
(cid:75)
m ; τ l′,1
pj (cid:75)
m ; τ l′,∞
; τ l′,1
mj
p
p
p
where l, l′ ∈ {LL, HH, HL}, k ∈ K. Note that the size of the expanded
type [ T ]n depends on n.
We need to adapt typing environments accordingly. For any
typing environment Γ, we define its renaming for session i as:
(DCheckH)
(DCheckL)
[ Γ ]i = {xi : T | Γ(x) = T} ∪ {k : T | Γ(k) = T}
m }
m | Γ(m) = τ l,1
∪ {m : τ l,1
| Γ(m) = τ l,∞
m }.
∪ {mi : τ l,1
mi
′
Γ(x) = T ∗ T
Γ ⊢ π1(x) : T
Γ(x) = LL
Γ ⊢ π1(x) : LL
(DFst)
(DFstL)
Γ(x) = T ∗ T
Γ ⊢ π2(x) : T
Γ(x) = LL
Γ ⊢ π2(x) : LL
′
′ (DSnd)
(DSndL)
Figure 7: Destructor Rules
or environments. We similarly assume that for all the variables x
appearing in the processes, the set X of all variables also contains
fresh variables {xi | i ∈ N} which do not appear in the processes
or environments.
Intuitively, whenever we can typecheck a process of the form
new n : τ l,1
n . new m : τ l,∞
m . P, we can actually typecheck
new n : τ l,1
n . (new m1 : τ l,1
m1 .P1 | . . . | new mk : τ l,1
mk .Pk)
Formally, we denote by [ t ]Γ
i
where in Pi, the nonce m has been replaced by mi and variables x
have been renamed to xi.
, the term t in which names n such
that Γ(n) = τ l,∞
for some l are replaced by ni, and variables x are
n
replaced by xi.
Similarly, when a term is of type(cid:74)τ l,∞
(cid:75), it can be of type
m ; τ l′,∞
(cid:74)τ l,1
pi (cid:75) for any i. The nonce type τ l,∞
; τ l′,1
m represents infinitely
mi
many nonces (one for each session). That is, for n sessions, the type
(cid:74)τ l,∞
pi (cid:75). Formally, given a type T ,
m ; τ l′,∞
; τ l′,1
(cid:75) represents all(cid:74)τ l,1
mi
p
p
and then its expansion to n sessions as
[ Γ ]n
i = {xi : [ T ]n | [ Γ ]i(xi) = T} ∪ {k : [ T ]n | [ Γ ]i(k) = T}
depends on n.
m | [ Γ ]i(m) = τ l,1
m }.
, due to the expansion, the size of the types
∪ {m : τ l,1
Note that in [ Γ ]n
i
By construction, the environments contained in the constraints
generated by typing do not contain union types. However, re-
finement types with infinite nonce types introduce union types
when expanded. In order to recover environments without union
types after expanding, which, as we will explain in the next subsec-
tion, is needed for our consistency checking procedure, we define
i ) as the set of all Γ′, with the same domain as [ Γ ]n
branches([ Γ ]n
,
such that for all x, Γ′(x) is not a union type, and either
i
i (x) = Γ′(x);
• [ Γ ]n
• or there exist types T1,...,Tk,T ′
[ Γ ]n
i (x) = T1 ∨ . . . ∨ Tk ∨ Γ
1,...,T ′
′(x) ∨ T
k′ such that
′
′
1 ∨ . . . ∨ T
k′
i ∼ [ v ]Γ
Finally, when typechecking two processes containing nonces
with infinite nonce types, we collect constraints that represent
families of constraints.
Given a set of constraints c, and an environment Γ, we define the
renaming of c for session i in Γ as [ c ]Γ
i = {[ u ]Γ
| u ∼ v ∈
c}. This is propagated to constraint sets as follows: the renaming
of C for session i is [ C ]i = {([ c ]Γ
i ,[ Γ ]i) | (c, Γ) ∈ C} and its
i , Γ′) | ∃Γ. (c, Γ) ∈ C ∧
expansion to n sessions is [ C ]n
Γ′ ∈ branches([ Γ ]n
Again, note that the size of [ C ]i does not depend on the number
of sessions considered, while the size of the types present in [ C ]n
does. For example, for C = {({h(x) ∼ h(x)},[x :(cid:74)τ HH,∞
(cid:75)])},
i
; τ HH,∞
i = {({h(xi) ∼ h(xi)},[xi :n
: (cid:74)τ HH,∞
(cid:75)])} and
; τ HH,∞
we have [ C ]i = {({h(xi) ∼ h(xi)},[xi
(cid:75)])}.
j=1(cid:74)τ HH,1
[ C ]n
mj
i = {([ c ]Γ
m
; τ HH,1
pj
i )}.
m
p
p
i
Session B4:  Privacy PoliciesCCS’17, October 30-November 3, 2017, Dallas, TX, USA418Our type system is sound for replicated processes provided that
the collected constraint sets are consistent, when instantiated with
all possible instantiations of the nonces and keys.
Assume that P and Q only bind nonces with infinite nonce types,
m for some label l; while P′ and Q′ only bind
Theorem 6.2. Consider P, Q, P′ ,Q′, C, C′, such that P, Q and P′,
Q′ do not share any variable. Consider Γ, containing only keys and
nonces with types of the form τ l,1
n .
i.e. using new m : τ l,∞
nonces with finite types, i.e. using new m : τ l,1
m .
nonce m ∈ dom(Γ). If
• Γ ⊢ P ∼ Q → C,
• Γ ⊢ P′ ∼ Q′ → C′,
• C′∪×(∪×1≤i ≤n[ C ]n
Let us abbreviate by new n the sequence of declarations of each
i ) is consistent for all n,
new n. ((!P) | P′) ≈t new n. ((!Q) | Q′).
then
Theorem 6.1 requires to check consistency of one constraint
set. Theorem 6.2 now requires to check consistency of an infinite
family of contraint sets. Instead of deciding consistency, we provide
a procedure that checks a slightly stronger condition.
6.3 Procedure for consistency
Checking consistency of a set of constraints amounts to check-
ing static equivalence of the corresponding frames. Our procedure
follows the spirit of [4] for checking computational indistinguisha-
bility: we first open encryption, signatures and pairs as much as
possible. Note that the type of a key indicates whether it is public
or secret. The two resulting frames should have the same shape.
Then, for unopened components, we simply need to check that they
satisfy the same equalities.
From now on, we only consider constraint sets that can actually
be generated when typing processes, as these are the only ones for
which we need to check consistency.
Formally, the procedure check_const is described in Figure 8. It
consists of four steps. First, we replace variables with refinements
of finite nonce types by their left and right values. In particular
a variable with a union type is not associated with a single value
and thus cannot be replaced. This is why the branching operation
needs to be performed when expanding environments containing
refinements with types of the form τ l,∞
. Second, we recursively
open the constraints as much as possible. Third, we check that the
resulting constraints have the same shape. Finally, as soon as two
constraints M ∼ M′ and N ∼ N ′ are such that M, N are unifiable,
we must have M′ = N ′, and conversely. The condition is slightly
more involved, especially when the constraints contain variables
of refined types with infinite nonce types.
n
Example 6.3. Continuing Example 3.1, when typechecked with
appropriate key types, the simplified model of Helios yields con-
straint sets containing notably the following two constraints.
{ aenc(⟨0, ra⟩, pk(ks)) ∼ aenc(⟨1, ra⟩, pk(ks)),
aenc(⟨1, rb⟩, pk(ks)) ∼ aenc(⟨0, rb⟩, pk(ks)) }
For simplicity, consider the set c containing only these two con-
straints, together with a typing environment Γ where ra and rb
step1Γ(c) :=(cid:74)c(cid:75)σF ,σ′
F
, with
and σF , σ′
F := {x ∈ dom(Γ) |
∃m, n, l, l′
F
defined by
 • dom(σF ) = dom(σ′
• ∀x ∈ F . ∀m, n, l, l′.
(cid:74)τ l,1
m ; τ l′,1
n (cid:75)}
m ; τ l′,1
. Γ(x) =(cid:74)τ l,1
F ) = F
n (cid:75) ⇒ σF (x) = m ∧ σ′
F (x) = n
step2Γ(c) is recursively defined by, for all M, N , M′, N ′:
• step2Γ({⟨M, N ⟩ ∼ ⟨M′, N ′⟩} ∪ c′) :=
step2Γ({M ∼ M′, N ∼ N ′} ∪ c′)
• For all k ∈ K, if ∃T .Γ(k) = keyLL(T):
• step2Γ({enc(M, k) ∼ enc(M′, k)} ∪ c, c′) :=
step2Γ({M ∼ M′} ∪ c′)
• step2Γ({aenc(M, pk(k)) ∼ aenc(M′, pk(k))} ∪ c, c′) :=
step2Γ({M ∼ M′} ∪ c′)
• step2Γ({sign(M, k) ∼ sign(M′, k)} ∪ c′) :=
step2Γ({M ∼ M′} ∪ c′)
• For all k ∈ K, if ∃T .Γ(k) = keyHH(T):
step2Γ({sign(M, k) ∼ sign(M′, k)} ∪ c′) :=
{sign(M, k) ∼ sign(M′, k)} ∪ step2Γ({M ∼ M′} ∪ c′)
• For all other terms M, N :
step2Γ({M ∼ N } ∪ c′) := {M ∼ N } ∪ step2Γ(c′).
step3Γ(c) := check that for all M ∼ N ∈ c, M and N are both
• a key k ∈ K such that ∃T .Γ(k) = keyLL(T);
• nonces m, n ∈ N such that
∃a ∈ {1, ∞}. Γ(n) = τ LL,a
n
∧ Γ(m) = τ LL,a
,
n
• or public keys, verification keys, or constants;
• or enc(M′, k), enc(N ′, k) such that ∃T .Γ(k) = keyHH(T);
• or either h(M′), h(N ′) or aenc(M′, pk(k)), aenc(N ′, pk(k)), where
∃T .Γ(k) = keyHH(T); such that M′ and N ′ contain directly under
pairs some n with Γ(n) = HH or k such that ∃T .Γ(k) = keyHH(T);
• or sign(M′, k), sign(N ′, k) such that ∃T .Γ(k) = keyHH(T).
step4Γ(c) := If for all M ∼ M′ and N ∼ N ′ ∈ c such that M, N are
unifiable with a most general unifier µ, and such that
∀x ∈ dom(µ).∃l, l′, m, p . (Γ(x) =(cid:74)τ l,∞
(x µ ∈ X ∨ ∃i . x µ = mi)
m ; τ l′,∞
p
(cid:75)) ⇒
we have
where
M′αθ = N ′αθ
(cid:75) ∧ µ(x) = mi) ⇒ θ(x) = pi
∀x ∈ dom(µ).∀l, l′, m, p, i .
(Γ(x) =(cid:74)τ l,∞
m ; τ l′,∞
p
and α is the restriction of µ to {x ∈ dom(µ) | Γ(x) = LL ∧ µ(x) ∈ N};
and if the symmetric condition for the case where M′, N ′ are unifiable
holds as well, then return true.
check_const(C) := for all (c, Γ) ∈ C, let c1 := step2Γ(step1Γ(c)) and
check that step3Γ(c1) = true and step4Γ(c1) = true.
Figure 8: Procedure for checking consistency.
Session B4:  Privacy PoliciesCCS’17, October 30-November 3, 2017, Dallas, TX, USA419and τ HH,1
rb
are respectively given types τ HH,1
, and ks is given type
ra
keyHH(T) for some T .
The procedure check_const({(c, Γ)}) can detect that the con-
straint c is consistent and returns true. Indeed, as c does not con-
tain variables, step1Γ(c) simply returns (c, Γ). Since c only con-
tains messages encrypted with secret keys, step2Γ(c) also leaves
c unmodified. step3Γ(c) then returns true, since the messages
appearing in c are messages asymmetrically encrypted with se-
cret keys, which contain a secret nonce (ra or rb) directly under
pairs. Finally step4Γ(c) trivially returns true, as the messages
aenc(⟨0, ra⟩, pk(ks)) and aenc(⟨1, rb⟩, pk(ks)) cannot be unified, as
well as the messages aenc(⟨1, ra⟩, pk(ks)) and aenc(⟨0, rb⟩, pk(ks)).
Consider now the following set c′, where encryption has not
been randomised:
c
′ = { aenc(0, pk(ks)) ∼ aenc(1, pk(ks)),
aenc(1, pk(ks)) ∼ aenc(0, pk(ks)) }
The procedure check_const({(c′, Γ)}) returns false. Indeed,
contrary to the case of c, step3Γ(c′) fails, as the encrypted message
do not contain a secret nonce. Actually, the corresponding frames
are indeed not statically equivalent since the adversary can recon-
struct the encryption of 0 and 1 with the key pk(ks) (in his initial
knowledge), and check for equality.
For constraint sets without infinite nonce types, check_const
entails consistency.
Theorem 6.4. Let C be a set of constraints such that
m ; τ l′,∞
, m, p. Γ(x) (cid:44)(cid:74)τ l,∞
∀(c, Γ) ∈ C. ∀l, l
If check_const(C) = true, then C is consistent.
p
′
(cid:75).
We prove this theorem by showing that, for each of the first