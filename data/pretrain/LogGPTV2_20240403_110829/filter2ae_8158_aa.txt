# 攻击代码指针完整性
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
代码指针完整性（CPI，更详细的介绍可以参考我之前的[文章](https://www.anquanke.com/post/id/193818)）是2014年提出的一种针对控制流劫持攻击的防御措施，CPI将进程内存划分为安全区和常规区，对敏感指针，尤其是代码指针放置到安全区做了保护。其作者认为该机制能够对控制流劫持攻击实现完全的防御，但遗憾的是，CPI（主要指基于信息隐藏的实现）做了两个并不总是成立的假设：
  1. 安全区的信息不会被泄露。
  2. 对安全区的暴力破解将会导致程序出现崩溃。
而实际上，安全区的信息可能被泄露，而精心构造的扫描策略能够在不导致程序崩溃的前提下对安全区地址进行破解，这就是我接下来要为大家介绍的攻击。
对于CPI的攻击是由MIT的Isaac Evans等人提出来的，攻击完全在CPI机制所假设的情景下进行：
  1. 攻击者对进程内存有完全的控制权，但不能修改代码段。
  2. 攻击者可以对任意地址（代码段外的）进行读写。
  3. 攻击者不能干涉程序加载。
实际攻击时是利用了栈溢出漏洞，对某一个数据指针实现了完全的控制，而这完全是在CPI的假设之内的。具体攻击步骤如下：
## 实施时间侧信道攻击，收集相关数据
侧信道攻击（side channel
attack），是针对目标运行过程中的时间消耗、功率、或者是物理化学特性（如电磁辐射）等信息对目标进行攻击的一种攻击手段，更准确的定义大家可以自行了解。而顾名思义，时间侧信道攻击关注的就是目标运行时的时间消耗。对于CPI的攻击就需要实施时间侧信道攻击。
比如如下代码片段：
如果指针被攻击者控制，使其指向内存中的某个位置，则此时可以通过改变ptr的值，读取出不同内存地址的值，造成代码执行时间不同，从而服务器的响应时间不同。根据响应时间，可以估计任意内存地址的值。示意图如下：
而此处显然是一个普通的数据指针，这样的指针在CPI机制中是不受保护的。这样一来，借由栈溢出漏洞，或者是堆污染漏洞（取决于目标指针在堆上还是栈上）就可以实现对目标指针的控制，进而得到相关信息。
实际攻击时是利用了nginx 1.6.2版本存在的栈溢出漏洞，控制了nginx_http_parse.c中的如下指针nelts：
攻击者将其指向了一个精心选择的位置。CPI虽然有48bit（AMD64架构高16位地址不可用）位置用于地址分配。在某些系统内可用位数可能更加少，如64位的ubuntu
14.04，其只有46.5bit可用于虚拟内存分配。因为其有8192（213）个段描述符，每段32位，另外有三个唯一标识符local、global、interrupt，则共有13+32+1.5（3个标志需要2比特，但其中一个需要共用）=46.5bit。但实际上内存分配（包括安全区）往往依赖于mmap函数和随机化，所以攻击者只需关注mmap为目标程序分配的基址，只有28个bit可供分配（这是由提出地址随机化ASLR的论文确定的）。所以该位置只需位于mmap函数为nginx分配的区域中即可。
实际进行时间侧信道攻击时，具体的时间消耗指标是0.6kb的一个静态网页在1Gbit线路下处理一次http请求的往返时间。可以通过响应时间来估计相应的值，时间侧信道攻击重点关注以下等式：
byte代表当前指针指向的内容，取值从0到255，是待估计的值。
c是一个待定常数（也就是样本量与累计响应时间的斜率）。
baseline是http请求的平均时间，反映了其他因素影响，应该去除。
di代表当前处理第i次请求，且byte不为0时的时间。
s代表样本容量，在此处也就是发送的请求数。实验中收集了10000个样本。
当byte=0时，显然有：
当byte=255时，则有：
实验中观测到的baseline为3.2ms。样本量和累计响应时间具体关系如下：
下图展示了实际值与估计值的关系：
可以看到，我们能以较高的准确度对目标值进行估计，接下来就是对安全区的定位了。
## 定位安全区
攻击者对现有的x86-64架构下的CPI实现进行了分析，发现0x7bfff73b9000到0x7efff73b9000之间可以确保处于安全区。可以让前述nelts指针指向这范围里的任何一个地址，实验中选取了0x7efff73b9000。安全区在内存中大体位置如下：
最高地址处是进程占用的栈，然后是一段至少为128MB的间隔，在之后是mmap函数分配的区域，mmap的基址是随机分配的（如果有随机化），其最大最小值已经在图中标出。动态链接库一旦被放入mmap机制处，安全区就紧随其后，大小为2^42字节。而注意到，图中大括号部分总是位于安全区，这也是上述0x7bfff73b9000到0x7efff73b9000的来源。
### 不会导致崩溃的算法
由上图可以很直观的看到，只要能定位到动态链接库（通常为libc,以下均使用libc描述），安全区也就能够定位了（上述的地址一般来说是无效的，只能用做扫描的开始）。开始已在上述安全区地址后，以一个libc的大小（实验得出的数量级为2^21字节）为单位，向高地址检查（通过时间侧信道），直到命中libc。
整个算法可以描述如下：
  1. 将数据指针指向0x7efff73b9000。
  2. 向高地址调整一个libc大小。