# CVE-2021-22555 2字节堆溢出写0漏洞提权分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
**影响版本** ：Linux v2.6.19-rc1~v5.12-rc7 v5.12-rc8已修补，漏洞存在了15年，评分7.8。 已修复的版本有
5.12，5.10.31, 5.4.113, 4.19.188, 4.14.231, 4.9.267, 4.4.267。
由syzkaller发现，参见[crash现场](https://github.com/google/security-research/security/advisories/GHSA-xxx5-8mvq-3528)。
**测试版本** ：Linux-5.11.14 [exploit及测试环境下载地址](https://github.com/bsauce/kernel-exploit-factory)—
**编译选项** ：所有 `CONFIG_IP_NF_**` 和 `CONFIG_NETFILTER_**` 相关的选项。
    CONFIG_USER_NS=y
    CONFIG_NET_NS=y
    CONFIG_COMPAT=y
    CONFIG_IP_NF_IPTABLES=y           // /net/ipv4/netfilter/ip_tables.c
    CONFIG_IP_NF_FILTER=y
    CONFIG_IP_NF_MANGLE=y
    CONFIG_IP_NF_NAT=y
    CONFIG_IP_NF_RAW=y
    CONFIG_IP_NF_SECURITY=y
    CONFIG_IP_NF_**=y
    CONFIG_NETFILTER_NETLINK=y
    CONFIG_NETFILTER_XTABLES=y        // /net/netfilter/x_tables.c
    CONFIG_NETFILTER_XT_MATCH_U32=y
    CONFIG_NETFILTER_**=y
在编译时将`.config`中的`CONFIG_E1000`和`CONFIG_E1000E`，变更为=y。[参考](https://blog.csdn.net/qq_16097611/article/details/104965045)
    $ wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.11.14.tar.xz
    $ tar -xvf linux-5.11.14.tar.xz
    # KASAN: 设置 make menuconfig 设置"Kernel hacking" ->"Memory Debugging" -> "KASan: runtime memory debugger"。
    $ make -j32
    $ make all
    $ make modules
    # 编译出的bzImage目录：/arch/x86/boot/bzImage。
**漏洞描述** ：`net/netfilter/x_tables.c` 中 `Netfilter` 模块的`ip_tables`子模块，
当调用`setsockopt()`和选项`IPT_SO_SET_REPLACE`（或
`IP6T_SO_SET_REPLACE`）时，内核结构需要从32位转换为64位，由于错误计算转换大小，导致在调用
[xt_compat_match_from_user()](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/x_tables.c#L731)
函数时 **堆溢出写 0**
。攻击者可用于提权，或者从docker、k8s容器（[kubernetes](https://zhuanlan.zhihu.com/p/29232090)）中逃逸。需要`CAP_NET_ADMIN`权限，或者支持`user+network`命名空间。
**补丁**
：[patch](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/x_tables.c?id=b29c457a6511435960115c0f548c4360d5f4801d)
取消pad对齐，也可以禁用非特权用户执行`CLONE_NEWUSER`、`CLONE_NEWNET`，以缓解该漏洞：`echo 0 >
/proc/sys/user/max_user_namespaces`。
    diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c
    index 6bd31a7a27fc5..92e9d4ebc5e8d 100644
    --- a/net/netfilter/x_tables.c
    +++ b/net/netfilter/x_tables.c
    @@ -733,7 +733,7 @@ void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
     {
         const struct xt_match *match = m->u.kernel.match;
         struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;
    -    int pad, off = xt_compat_match_offset(match);
    +    int off = xt_compat_match_offset(match);
         u_int16_t msize = cm->u.user.match_size;
         char name[sizeof(m->u.user.name)];
    @@ -743,9 +743,6 @@ void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
             match->compat_from_user(m->data, cm->data);
         else
             memcpy(m->data, cm->data, msize - sizeof(*cm));
    -    pad = XT_ALIGN(match->matchsize) - match->matchsize;
    -    if (pad > 0)
    -        memset(m->data + match->matchsize, 0, pad);
         msize += off;
         m->u.user.match_size = msize;
    @@ -1116,7 +1113,7 @@ void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
     {
         const struct xt_target *target = t->u.kernel.target;
         struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
    -    int pad, off = xt_compat_target_offset(target);
    +    int off = xt_compat_target_offset(target);
         u_int16_t tsize = ct->u.user.target_size;
         char name[sizeof(t->u.user.name)];
    @@ -1126,9 +1123,6 @@ void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
             target->compat_from_user(t->data, ct->data);
         else
             memcpy(t->data, ct->data, tsize - sizeof(*ct));
    -    pad = XT_ALIGN(target->targetsize) - target->targetsize;
    -    if (pad > 0)
    -        memset(t->data + target->targetsize, 0, pad);
         tsize += off;
         t->u.user.target_size = tsize;
**保护机制** ：开启KASLR/SMEP/SMAP。
**利用总结** ：
  * （1）构造4096个`msg_msg`主消息（0x1000）和辅助消息（0x400），利用2字节溢出写0来修改某个主消息的`msg_msg->m_list->next`低2字节，使得两个主消息指向同一个辅助消息，将 **2字节溢出写0转化为UAF** 。
  * （2）注意，spray对象采用skb对象，victim对象采用`pipe()`管道中的`pipe_buf_operations`结构。首先利用skb改大`msg_msg->m_ts`，泄露相邻辅助消息的 **`msg_msg->m_list->prev`**（主消息地址，也即0x1000堆块地址）；
  * （3）再利用skb伪造`msg_msg->next`指向泄露的主消息地址， **泄露`msg_msg->m_list->next`**（辅助消息地址，也即0x400堆块地址）；
  * （4）再利用skb伪造`msg_msg->m_list->next & prev`，以避免再次释放辅助消息时访问无效链表地址导致崩溃；
  * （5）使`pipe_buffer`结构占据释放后的0x400空闲块，利用读skb **泄露其`ops`指针**，也即内核基址；
  * （6）利用skb篡改`pipe_buffer->ops->release`指针， **劫持控制流** 。
  * （7）如果需要进行docker或k8s **容器逃逸** ，则ROP链在执行`commit_creds(prepare_kernel_cred(0))`提权后，需执行`switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)`，以 **替换exp进程的命名空间** 。
* * *
## 1\. Netfilter介绍
**简介** ：Natfilter 是集成到linux内核协议栈中的一套防火墙系统。
**数据结构的关系** ：
  * （1）Netfilter 中有包含一些表（table)，不同的表用来存储不同功能的配置信息，默认有4种table，还可以另外创建。
  * （2）每个table 里有多个chain，chain表示对报文的拦截处理点。例如网络层ipv4有5个拦截点，对应5个chain：报文路由前-`PREROUTING`，需三层转发的报文-FORWARD，本机生成的报文-OUTPUT，本机接收的报文-INPUT，路由后的报文-POSTROUTING。
  * （3）每个chain 包含一些用户配置的rule，一条rule包含了一个或多个 **匹配规则（match)** 和一个 **执行动作（target）** 。如果报文符合匹配规则后，需要根据该执行动作（target）来处理报文。标准的匹配元素包含源/目的IP地址、接收/发送设备、传输层协议这五个元素，标准的执行动作包含ACCEPT、DROP、QUEUE、RETURN。
**四大功能（table）** ：
  * （1）对报文的过滤（对应filter表），包含3个chain—INPUT/OUTPUT/FORWARD。
  * （2）对报文的修改（对应mangle表），包含以上5个chain。
  * （3）对会话的连接跟踪（connection track)，包含2个chain，OUTPUT/PREROUTING。
  * （4）网络地址转换（NAT)，包含3个chain，PREROUNGIN/OUTPUT/POSTROUTIN。
**`table->chain->rule`结构关系图示**：在内核空间，每个CPU上维护了一份rule的拷贝（有多少个CPU，就有多少个`entries`）。这样做是为了减少锁的使用及增加硬件L1
cache的命中次数，以空间换时间。
**`table->chain->rule`具体结构**：表用
[xt_table](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/netfilter/x_tables.h#L223)
->
[xt_table_info](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/netfilter/x_tables.h#L248)结构表示；每条rule用[ipt_entry](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter_ipv4/ip_tables.h#L106)结构表示；match匹配规则用[xt_entry_match](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L11)表示（用户空间和内核共享同一结构）；target执行动作用[xt_entry_target](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L34)表示（用户空间和内核共享同一结构）。
    //（1）xt_table —— 表
    struct xt_table {
        struct list_head list;
        /* What hooks you will enter on */
        unsigned int valid_hooks;
        struct xt_table_info *private;                // 指向真正存储rule的结构体
        /* Set this to THIS_MODULE if you are a module, otherwise NULL */
        struct module *me;
        u_int8_t af;                                                    // 表所属的协议族
        int priority;        /* hook order */
        /* called when table is needed in the given netns */
        int (*table_init)(struct net *net);
        const char name[XT_TABLE_MAXNAMELEN];    // 表的名字，如filter/nat/mangle
    };
    struct xt_table_info {
        unsigned int size;                                                    // 表中所有规则rule占用的内存大小
        unsigned int number;                                                // 表中存的rule个数
        unsigned int initial_entries;                                // 初始化表时创建的默认rule个数
        unsigned int hook_entry[NF_INET_NUMHOOKS];    // 各个hook(chain)在表中的偏移量
        unsigned int underflow[NF_INET_NUMHOOKS];        // 各个hook(chain)中默认规则在表中的偏移量
        unsigned int stacksize;
        void ***jumpstack;
        unsigned char entries[] __aligned(8);                // 数组，存储各个cpu上自己rule拷贝的内存首地址
    };
    //（2）ipt_entry —— 规则rule
    struct ipt_entry
    {
        struct ipt_ip ip;                                                        // 规则的基本匹配条件，源IP/目的IP、输入/输出网卡、协议
        unsigned int nfcache;
        u_int16_t target_offset;                                        // ipt_entry + matches 这条规则的target距离规则起点的偏移量
        u_int16_t next_offset;                                            // ipt_entry + matches + target 下一条规则距离这条规则起点的偏移量
        unsigned int comefrom;
        struct xt_counters counters;                                // 计数器，每条规则都有计数器，一旦skb匹配这条规则，那么计数器累加，计数器有字节数和包数两个统计量
        unsigned char elems[0];                                            //这条规则中的match和target，因为不确定到底有几个match，所以使用零长度数组
    };
    //（3）xt_entry_match —— 匹配规则match，用户空间和内核空间共享match_size和data字段
    #define ipt_entry_match xt_entry_match
    struct xt_entry_match
    {
        union {                        // 用户态和内核态使用不同的结构表示match。它们的第一个成员都是match的总大小
            struct {                                        // a. 用户态
                u_int16_t match_size;      
                char name[XT_FUNCTION_MAXNAMELEN-1];    // 该match的版本,通过match的名称与版本信息可以唯一确定一个match。
                u_int8_t revision;
            } user;
            struct {                                        // b. 内核态
                u_int16_t match_size;
                struct xt_match *match;                                // 指向扩展的match信息（每一个扩展match都是一个xt_match对象）。根据ipt_entry_match.u.user.name找到对应的match，将ipt_entry_match.u.kernel.match指针指向系统中已注册的struct xt_match对象
            } kernel;
            u_int16_t match_size;                // 整个match占用的内存空间
        } u;
        unsigned char data[0];
    };
    //（4）xt_entry_target —— 执行动作target，用户空间和内核空间共享match_size字段
    #define ipt_entry_target xt_entry_target
    struct xt_entry_target
    {
        union {
            struct {                                        // a. 用户态
                u_int16_t target_size;
                char name[XT_FUNCTION_MAXNAMELEN-1];
                u_int8_t revision;
            } user;
            struct {                                        // b. 内核态
                u_int16_t target_size;
                struct xt_target *target;                            // target信息，如果target->target()函数指针为NULL，那么是一个标准target，否则为扩展target。根据ipt_entry_target.u.user.name找到对应的target，将ipt_entry_target.u.kernel.target指针指向系统中已注册的struct xt_target对象
            } kernel;
            u_int16_t target_size;
        } u;
        unsigned char data[0];                // 对于扩展target，该指针指向内容会传给其target()回调，这个指针内容由扩展target自由使用，只要内核态和用户态保持一致就可以
    };
**应用层与Netfilter的通信机制**
：netfilter和用户空间进行通信使用的是两个socket的系统调用，`setsockopt()`和`getsockopt()`，把用户空间的地址传给内核，内核使用`copy_from_user()`
和
`copy_to_user()`来进行数据的传递。基于setsockopt和getsockopt系统调用的机制，Netfilter提供了一个基本框架，允许不同协议的防火墙来自己实现自己和用户空间的通信函数，涉及两个函数，调用`nf_register_sockopt()`将`nf_sockopt_ops`结构实例注册到netfilter管理的全局链表上，调用`nf_sockopt_find()`查找对应命令字的`nf_sockopt_ops`结构。
* * *
## 2\. 漏洞分析
####  2-1 漏洞原因
**漏洞**
：[xt_compat_target_from_user()](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/x_tables.c#L1114)函数，将`xt_entry_match->data`指向的缓冲区进行8字节对齐，不足8字节的空间清0，但如果`target->targetsize`没有8字节对齐，这里会越界将pad个字节清0。`target->targetsize`并不由用户直接控制，可以通过选择不同的target结构体类型来控制`targetsize`大小。
    #ifdef CONFIG_COMPAT
    int xt_compat_target_offset(const struct xt_target *target)
    {
        u_int16_t csize = target->compatsize ? : target->targetsize;
        return XT_ALIGN(target->targetsize) - COMPAT_XT_ALIGN(csize);
    }
    EXPORT_SYMBOL_GPL(xt_compat_target_offset);
    void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
                    unsigned int *size)
    {
        const struct xt_target *target = t->u.kernel.target;
        struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;    // ct=t的副本
        int pad, off = xt_compat_target_offset(target);
        u_int16_t tsize = ct->u.user.target_size;
        char name[sizeof(t->u.user.name)];
        t = *dstptr;
        memcpy(t, ct, sizeof(*ct));        // ct 拷贝到 dstptr
        if (target->compat_from_user)
            target->compat_from_user(t->data, ct->data);
        else
            memcpy(t->data, ct->data, tsize - sizeof(*ct));
        pad = XT_ALIGN(target->targetsize) - target->targetsize;    // [1] 对缓冲区进行8字节对齐，target->targetsize 用来指定t->data实际使用长度
        if (pad > 0)
            memset(t->data + target->targetsize, 0, pad);            // [2] 将不足8字节的剩余空间清0，存在越界写0
        tsize += off;
        t->u.user.target_size = tsize;
        strlcpy(name, target->name, sizeof(name));
        module_put(target->me);