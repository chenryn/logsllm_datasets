[root@linuxbox -]# nkdir /nmt/cdron
186
---
## Page 188
最后，我们把这个CD-ROW挂载到一个新的挂载点上。这个-t选项用来指定文件系统类
型：
[root@linuxbox -]# mount =t iso9660 /dev/hdc /nnt/cdrom
之后，我们可以通过这个新挂载点来查看CD-ROW的内容：
[rootQlinuxbox -]#cd /mmt/cdron
[rootQlinuxbox cdron]# 1s
注意当我们试图卸载这个CD-ROW时，发生了什么事情。
[rootQlinuxbox cdron] # umount /dev/hdc
unount: /znt/cdron: device is busy
这是怎么回事呢？原因是我们不能卸载一个设备，如果某个用户或进程正在使用这个设备
的话。在这种情况下，我们把工作目录更改到了CD-ROW的挂载点，这个挂载点导致设备忙
[root@linuxbox cdron] # cd
[rootQlinuxbox -]# umount /dev/hdc
现在这个设备成功卸载了。
为什么卸载重要
如果你看一下free命令的输出结果，这个命令用来显示关于内存使用情况的统
计信息，你会看到一个统计值叫做”buffers”计算机系统旨在尽可能快地运行。系
统运行速度的一个阻碍是缓慢的设备。打印机是一个很好的例子。即使最快速的打
印机相比于计算机标准也极其地缓慢。一台计算机确实会运行得非常慢，如果它要
停下来等待一台打印机打印完一页。在早期的个人电脑时代（多任务之前），这真
187
---
## Page 189
是个问题。如果你正在编辑电子表格或者是文本文档，每次你要打印文件时，计算
机都会停下来而且变得不能使用。计算机能以打印机可接受的最快速度把数据发送
给打印机，但由于打印机不能快速地打印，这个发送速度会非常慢。由于打印机缓
存的出现，这个问题被解决了。打印机缓存是一个包含一些RAM内存的设备，位
于计算机和打印机之间。通过打印机缓存，计算机把要打印的结果发送到这个级存
区，数据会迅速地存储到这个RAM中，这样计算机就能回去工作，而不用等待。
与此同时，打印机缓存将会以打印机可接受的速度把缓存中的数据缓慢地输出给打
印机。
缓存被广泛地应用于计算机中，使其运行得更快。别让偶尔地的读取或写入慢
设备的需求阻碍了系统的运行速度。在真正与比较慢的设备交互之前，操作系统会
尽可能多的读取或写入数据到内存中的存储设备里。以Linux操作系统为例，你会
注意到系统看似填充了多于它所需要的内存。这不意味着Linux正在使用所有的内
存，它意味着Linux正在利用所有可用的内存，来作为缓存区。
这个缓存区允许非常快速地对存储设备进行写入，因为写入物理设备的操作被延
迟到后面进行。同时，这些注定要传送到设备中的数据正在内存中堆积起来。时不
时地，操作系统会把这些数据写入物理设备。
卸载一个设备需要把所有剩余的数据写入这个设备，所以设备可以被安全地移
除。如果没有卸载设备，就移除了它，就有可能没有把注定要发送到设备中的数据
输送完毕。在某些情况下，这些数据可能包含重要的目录更新信息，这将导致文件
系统损坏，这是发生在计算机中的最坏的事情之一。
16.3确定设备名称
有时很难来确定设备名称。在以前，这并不是很难。一台设备总是在某个固定的位置，也不会
挪动它。类Unix的系统喜欢设备那样安排。退回到Unix系统的时代，“更改一个磁盘驱动器”
史像是要用一辆叉车从机房中移除一台如洗衣机大小的设备那样困难。最近儿年，典型的桌面
硬件配置已经变得相当动态，并且Linux已经发展地比其祖先更加灵活。在以上事例中，我们
利用现代Linux桌面系统的功能来“自动地”挂载设备，然后再确定设备名称。但是如果我们
正在管理一台服务器或者是其它一些（这种自动挂载功能）不会发生的环境，我们又如何能查
清设备名呢？
首先，让我们看一下系统怎样来命名设备。如果我们列出目录/dev（所有设备的住所）的内
容，我们会看到许许多多的设备：
188
---
## Page 190
[ne@linuxbox -]$ 1s /dev
这个列表的内容揭示了一些设备命名的模式。这里有几个：
模式
设备
/dev/fd*
软盘驱动器
/dev/hd*
老系统中的IDE(PATA)磁盘。典型的主板包含两个IDE
连接器或者是通道，每个连接器带有一根缆线，每根缆线上
有两个硬盘驱动器连接点。缆线上的第一个驱动器叫做主
设备，第二个叫做从设备。设备名称这样安排，/dev/hda
是指第一通道上的主设备名；/dev/hdb是第一通道上的从
设备名：/dev/hdc是第二通道上的主设备名，等等。末尾
的数字表示硬盘驱动器上的分区。例如，/dev/hdal是指系
统中第一硬盘驱动器上的第一个分区，而/dev/hda则是指
整个硬盘驱动器。
/dev/lp*
打印机
/dev/sd*
SCSI磁盘。在最近的Linux系统中，内核把所有类似于磁
盘的设备（包括PATA/SATA硬盘，闪存，和USB存储设
备，比如说可移动的音乐播放器和数码相机）看作SCSI磁
盘。剩下的命名系统类似于上述所描述的旧的/dev/hd*命
名方案。
/dev/sr*
光盘（CD/DVD读取器和烧写器）
表16-2:Linux存储设备名称
另外，我们经常看到符号链接比如说/dev/cdrom，/dev/dvd和/dev/floppy，它们指向实际
的设备文件，提供这些链接是为了方便使用。如果你工作的系统不能自动挂载可移动的设备
你可以使用下面的技巧来决定当可移动设备连接后，它是怎样被命名的。首先，启动一个实时
查看文件/var/log/messages（你可能需要超级用户权限）：
so3essou/3ot/zea/ J- [te1 opns s[- xoqxnustgou]
189
---
## Page 191
这个文件的最后几行会被显示，然后停止。下一步，插入这个可移动的设备。在这个例子
里，我们将使用一个16MB闪存。瞬间，内核就会发现这个设备，并且探测它：
Jul 23 10:07:53 linuxbox kernel: usb 3-2: nev fu11 speed USB device
using uhci_hcd and address 2
Jul 23 10:07:53 linuxbox kernel: usb 3-2: configuration #1 chosen
fron 1 choice
Jul 23 10:07:53 linuxbox kernel: scsi3 : SCSI emulation for USB Mass
Storage devices
Jul 23 10:07:58 linuxbox kernel: scsi scan: INQUIRY result too short
(5), using 36
Jul 23 10:07:58 linuxbox kernel: scs1 3:0:0:0: Direct-Access Easy
Disk 1.00 PQ: 0 ANSI: 2
Jul 23 10:07:59 1inuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-byte
hardvare sectors (16 MB)
Jul 23 10:07:59 1inuxbox kernel: sd 3:0:0:0: [sdb] Write Protect is
off
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Assuning drive
cache: write through
Jul 23 10:07:59 1inuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-byte
hardvare sectors (16 MB)
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [adb] Write Protect is
off
Jul 23 10:07:59 1inuxbox kernel: sd 3:0:0:0: [sdb] Assuming drive
Jul 23 10:07:59 1inuxbox kernel: sdb: sdb1
Jul 23 10:07:59 1inuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
renovable disk
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: Attached scs1 gener1c
g3type 0
显示再次停止之后，输入Ctrl-c，重新得到提示符。输出结果的有趣部分是一再提及“[sdb]”，
这正好符和我们期望的SCSI磁盘设备名称。知道这一点后，有两行输出变得颜具启发性：
Jul 23 10:07:59 1inuxbox kernel: sdb: sdb1
Jul 23 10:07:59 1inuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
renovable disk
190
---
## Page 192
这告诉我们这个设备名称是/dev/sdb指整个设备，/dev/sdb1是这个设备的第一分区。正
如我们所看到的，使用Linux系统充满了有趣的监测工作。
小贴士：使用这个tail-f/var/log/messages技巧是一个很不错的方法，可以实时观察系统
的一举一动。
既然知道了设备名称，我们就可以挂载这个闪存驱动器了：
[nedlinuxbox -]$ sudo nkdir /nnt/flash
[ne@linuxbox -]$ sudo nount /dev/sdb1 /nnt/flash
[ne@linuxbox -]$ df
Filesystem
1Kblocks
Available
Mounted on
/dev/sda2
15115452
5186944
9775164
35%
/
/dev/sda5
59631908
31777376
24776480
57%
/hone
/dev/sda1
147764
17277
122858
13%
/boot
tapfs
776808
0
776808
%0
/dev/shn
/dev/sdb1
15560
0
15560
0%
/nnt/f1ash
这个设备名称会保持不变只要设备与计算机保持连接并且计算机不会重新启动。
16.4创建新的文件系统
假若我们想要用Linux本地文件系统来重新格式化这个闪存驱动器，而不是它现用的FAT32
系统。这涉及到两个步骤：1.（可选的）创建一个新的分区布局若已存在的分区不是我们喜欢
的。2.在这个闪存上创建一个新的空的文件系统。
注意！在下面的练习中，我们将要格式化一个闪存驱动器。拿一个不包含有用数据的驱动
器作为实验品，因为它将会被擦除！再次，请确定你指定了正确的系统设备名称。未能注意此
警告可能导致你格式化（即擦除）错误的驱动器！
16.5用fdisk命令操作分区
这个fdisk程序允许我们直接在底层与类似磁盘的设备（比如说硬盘驱动器和闪存驱动器）进
行交互。使用这个工具可以在设备上编辑，删除，和创建分区。以我们的闪存驱动器为例，首
先我们必须卸载它（如果需要的话），然后调用fdisk程序，如下所示：
[neglinuzbox -]$ sudo umount /dev/sdb1
[ne@linuxbox -]$ sudo fdisk /dev/sdb
191
---
## Page 193
注意我们必须指定设备名称，就整个设备而言，而不是通过分区号。这个程序启动后，我们
将看到以下提示：
Conmand (m for help) :
输入“m”会显示程序菜单：
Cormand action
toggle a bootable flag
我们想要做的第一件事情是检查已存在的分区布局。输入“p”会打印出这个设备的分区表：
Cormand (± for help) : P
Disk /dev/sdb: 16 MB, 16006656 bytes
1 heads, 31 sectors/track, 1008 cylinders
Units = cylinders of 31 * 512 = 15872 bytes
Device Boot
Start
End
Blocks
System
/dev/sdb1
2
1008
15608+b
v95 FAT32
在此例中，我们看到一个16MB的设备只有一个分区（1），此分区占用了可用的1008个柱
面中的1006个，井被标识为Windows95FAT32分区。有些程序会使用这个标志符来限制一些
可以对磁盘所做的操作，但大多数情况下更改这个标志符没有危害。然而，为了叙述方便，我
们将会更改它，以此来表明是个Linux分区。在更改之前，首先我们必须找到被用来识别一个
Linux分区的ID号码。在上面列表中，我们看到ID号码“b”被用来指定这个已存在的分区
要查看可用的分区类型列表，参考之前的程序菜单。我们会看到以下选项：
1list knovn partition types
192
---
## Page 194
如果我们在提示符下输入“1”，就会显示一个很长的可能类型列表。在它们之中会看到“b”
为已存在分区类型的ID号.而“s3”是针对Linux系统的ID号。
回到之前的菜单，看到这个选项来更改分区ID号：
pT wosfs s,uotarared e asueqp
我们先输入“t"，再输入新的ID号：
Cormand (± for help): t
Selected partition 1
Hex code (type L to list codes): 83
Changed system type of partition 1 to 83 (Linux)
这就完成了我们需要做得所有修改。到目前为止，还没有接触这个设备（所有修改都存储在
内存中，而不是在此物理设备中），所以我们将会把修改过的分区表写入此设备，再退出。为
此，我们输入在提示符下输入“w”：
Conmand (m for help) : V
The partition table has been altered!
Calling ioctl() to re-read partition table.
WARNING: If you have created or nodified any DOS 6.x
partitions, please see the fdisk manual page for additional
infornation.
Syncing disks.
[ne@linuxbox -]$
如果我们已经决定保持设备不变，可在提示符下输入“q”。这将退出程序而没有写更改。我
们可以安全地忽略这些不祥的警告信息。
16.6用mkfs命令创建一个新的文件系统
完成了分区编辑工作（它或许是轻量级的），是时候在我们的闪存驱动器上创建一个新的文件系
统了。为此，我们会使用mkfs（“makefilesystem”的简写），它能创建各种格式的文件系统。
193
---
## Page 195
在此设备上创建一个ext3文件系统，我们使用“-t”选项来指定这个“ext3”系统类型，随后是
我们要格式化的设备分区名称：
Iqps/aop/ gaxa 4-spyu opns s[- xoqxnuttgou]
nite2fs 1.40.2 (12-Ju12007)
Filesystem label=
0S type: Linux
Block size=1024 (log=0)
Fragnent size=1024 (1og=0)
3904 inodes, 15608 blocks
780 blocks (5.00%) reserved for the super user
First data block=1
Maxinum filesysten blocks=15990784
2 block groups
8192 blocks per group, 8192 fragnents per group
1952 inodes per group
Superblock backups stored on blocks:
8193
Writing inode tables: done