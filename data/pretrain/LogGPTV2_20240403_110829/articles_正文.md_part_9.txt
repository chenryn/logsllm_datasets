|                                                                       |
| create database tempdb                                                |
|                                                                       |
| /\*!\*/;                                                              |
|                                                                       |
| \# at 194                                                             |
|                                                                       |
| #141003 14:09:36 server ID 1 end_log_pos 304 Query thread_ID=1        |
| exec_time=0 error_code=0                                              |
|                                                                       |
| use \`tempdb\`/\*!\*/;                                                |
|                                                                       |
| SET TIMESTAMP=1412316576/\*!\*/;                                      |
|                                                                       |
| create table tb1(ID smallint,val varchar(10))                         |
|                                                                       |
| /\*!\*/;                                                              |
+-----------------------------------------------------------------------+
图6-4 查看二进制日志文件解析后的内容
（2）使用show binlog
events命令查看MySQL二进制日志文件中的事件，如图6-5所示。
+-----------------------------------------------------------------------+
| root@localhost\[tempdb\]\> show binlog events in \'binlog.000004\';   |
|                                                                       |
| +\-\-\-\-\-\-\-\-\-\-\-\-\-\--                                        |
| +\-\-\-\--+\-\-\-\-\-\-\-\-\-\-\-\--+\-\-\-\-\-\-\-\-\-\--+\-\-\-\-\- |
| \-\-\-\-\-\-\--+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\ |
| -\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--+ |
|                                                                       |
| \| Log_name \| Pos \| Event_type \| Server_ID \| End_log_pos \| Info  |
| \|                                                                    |
|                                                                       |
| +---------                                                            |
| ------------+\-\-\-\--+\-\-\-\-\-\-\-\-\-\-\-\--+\-\-\-\-\-\-\-\-\-\- |
| -+\-\-\-\-\-\-\-\-\-\-\-\--+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\ |
| -\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--+ |
|                                                                       |
| \| binlog.000004 \| 4 \| Format_desc \| 1 \| 107 \| Server ver:       |
| 5.5.39-log, Binlog ver: 4 \|                                          |
|                                                                       |
| \| binlog.000004 \| 107 \| Query \| 1 \| 194 \| create database       |
| tempdb \|                                                             |
|                                                                       |
| \| binlog.000004 \| 194 \| Query \| 1 \| 304 \| use\'tempdb\'; create |
| table tb1(ID smallint,val varchar(10)) \|                             |
|                                                                       |
| \| binlog.000004 \| 304 \| Query \| 1 \| 374 \| BEGIN \|              |
|                                                                       |
| \| binlog.000004 \| 374 \| Query \| 1 \| 471 \| use\'tempdb\'; insert |
| into tb1 values(1,\'jack\') \|                                        |
|                                                                       |
| \| binlog.000004 \| 471 \| XID \| 1 \| 498 \| COMMIT /\* xID=25 \*/   |
| \|                                                                    |
|                                                                       |
| +\-\-\-\-\-\-\-\-\-\-\-\-\-\--                                        |
| +\-\-\-\--+\-\-\-\-\-\-\-\-\-\-\-\--+\-\-\-\-\-\-\-\-\-\--+\-\-\-\-\- |
| \-\-\-\-\-\-\--+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\ |
| -\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--+ |
|                                                                       |
| \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--                             |
|                                                                       |
| 作者：Leshami                                                         |
|                                                                       |
| 来源：CSDN                                                            |
|                                                                       |
| 原文：https://blog.csdn.net/leshami/article/details/39801867          |
+-----------------------------------------------------------------------+
图6-5 查看二进制日志文件中的事件
### 6.2.3 压缩文本
当日志文件积累到一定程度时，存储日志文件需要耗费大量磁盘空间。有些日志虽已过时，但仍有留存的必要；有些日志虽多余，但需要作为备份。这些不常被访问、与当前信息关联较弱但又需要保存的日志文件可以通过压缩来进行存储，以节省磁盘空间。
日志压缩可以使用UNIX或Linux系统自带的压缩工具，也可以使用压缩算法的脚本。压缩工具如logrotate命令，可以将压缩后的日志发送到指定邮箱。压缩算法有gzip算法、bz2算法等，其中bz2算法支持分片，可以结合MapReduce提升压缩效率。
logrotate命令是一个日志切割工具，可以自动对庞大的日志文件进行截断、压缩，以及删除旧的日志文件。
gzip算法是一种很常见的文件压缩算法，作者是Jean-loup Gailly和Mark
Adler，该算法将LZ77算法和Huffman编码算法相结合对数据进行压缩。
bz2算法是一种按照[自由软件](https://baike.baidu.com/item/%25E8%2587%25AA%25E7%2594%25B1%25E8%25BD%25AF%25E4%25BB%25B6/405190)/[开源软件](https://baike.baidu.com/item/%25E5%25BC%2580%25E6%25BA%2590%25E8%25BD%25AF%25E4%25BB%25B6/8105369)协议发布的数据压缩算法，作者是Julian
Seward，该算法基于Burrows-Wheeler变换来进行无损压缩，效果比传统的LZ77算法好，具有高质量的数据压缩能力。
MapReduce是一种编程模型，通常用于大规模数据集的并行运算，Map是映射，Reduce是规约，即将任务划分为多个独立小块进行处理，最终合并为一个运算集。
### 6.2.4 加密文本
日志记录的信息包含调试信息、提示信息和错误信息等，有时还会包含一些敏感信息。这些敏感信息是保密且不希望他人看到的。在当今互联网时代的背景下，网络发达，日志文件经常被存储在云服务器上，日志信息安全问题更加突出，一旦用户合法身份被黑客冒用，或者用户在合法授权下获取敏感信息并将所得数据非法散播给他人，后果将不堪设想。因此，对日志进行加密处理是必要的，这也是对用户和系统隐私进行保护的措施之一。例如，Java程序一般采用AES（Advanced
Encryption
Standard）加密算法。这是最常见的对称加密算法，即加密和解密使用相同的密钥。这种加密算法的数据加密速度非常快，适合频繁发送数据的场合，但其密钥传输不是很方便。
## 6.3 日志存储方式
随着系统的运行和接入设备的增加，日志信息与日俱增。尤其是进入物联网时代，各种设备之间的关联都会产生大量的日志信息。
对于简单的程序，在程序所在的服务器中直接存储日志，用命令访问查询即可；但对于结构复杂的大型系统来说，其日志量巨大，会增大存储和查询的难度。
有些重要程度不高的日志，可以在实时查询和处理后及时清理。但在某些场景下，一些日志需要保留一段时间以供日后回顾和查询统计，这就涉及如何合理地存储日志。本节就介绍日志存储方式。
### 6.3.1 数据库存储
数据库是存储数据的通用工具，分为关系型数据库（如MySQL、Oracle和SQL
Server等）和非关系型数据库（如MongoDB、Redis和HBase等）。
1\. 存储和查询
关系型数据库是由二维表及其之间的关系组成的一个数据组织。程序员可以将日志文件中的有用信息截取为字段并存入数据库表格，之后从数据库表格中获取所需要的日志信息，还可以备份和导入相关信息。
非关系型数据库（NoSQL）主要是指非关系型、分布式、不提供ACID（数据库事务处理的四个基本要素）的数据库设计模式。日志文件可以是key-value、文档等形式，将其分布式存储在不同的机器上，这种存储方式可以很方便地被面向对象的语言所使用。这类数据库可实现在海量数据中快速查询数据。
2\. 优点和缺点
1）优点
（1）易用性。
将日志文件存储在数据库中，可以方便地通过SQL等方式进行增、删、改、查。
（2）具有权限控制和备份恢复功能。
数据库具有权限控制和备份恢复功能，可确保数据的安全性和稳定性。
（3）方便部署。
数据库的部署是很方便的，因为目前的系统基本都会用到数据库，所以只需要在数据库中新增几个与日志相关的表格或文件目录即可完成部署。
2）缺点
（1）读写耗时。
数据库的读写开销远大于内存，一次记录请求的时间大部分花费在数据库操作上。
（2）查询速度有限。
当数据量较大或进行联表查询时，查询速度是一个瓶颈，可以通过优化查询语句或创建索引来提升查询速度，但查询速度依旧有限且创建索引还会占用一定空间，压缩也有限。
（3）删除开销大。
当积累的数据量过大时，对于可以清除的部分历史日志记录，删除耗时巨大且容易造成事务过大，即过了很久也没有删除成功。
（4）存在数据丢失风险。
数据库通常不会只用于记录日志信息，还会记录系统其他的功能信息，当功能改变、系统升级或数据库出现故障时，数据将面临丢失的风险。
3\. 应用场景
使用数据库进行日志信息存储，大多是因为产品需要展示日志信息，如审计功能、分析功能。产品的前端需要通过后端获取日志记录的信息，以供用户查看。在从多种日志中提取相同的关键信息，以及多种日志进行关联查询的情况下，使用数据库方便快捷。
以MySQL为例，假设某款产品需要一个页面来展示用户操作记录。
操作记录原始日志如图6-6所示。
+-----------------------------------------------------------------------+
| 2019-03-11 20:50:20 --- No.33 user view the alert list success!       |
|                                                                       |
| 2019-03-12 15:07:12 --- No.35 user update the user password failed,   |
| because origin password input wrong.                                  |
+-----------------------------------------------------------------------+
图6-6 操作记录原始日志
首先，提取产品所需的关键信息，包括用户ID、用户名称、操作类型、操作对象、操作时间、成功与否及问题原因。
然后，根据提取的关键信息创建数据库表格，如图6-7所示。
+-----------------------------------------------------------------------+
| CREATE TABLE \'operation_record\' (                                   |
|                                                                       |
| \'ID\' int(11) NOT NULL AUTO_INCREMENT,                               |
|                                                                       |
| \'account_ID\' int(11) NOT NULL,                                      |
|                                                                       |
| \'account_name\' varchar(45) NOT NULL,                                |
|                                                                       |
| \'operation_type\' varchar(45) NOT NULL,                              |
|                                                                       |
| \'operation_target\' varchar(255) NOT NULL,                           |
|                                                                       |
| \'timestamp\' bigint(20) NOT NULL,                                    |
|                                                                       |
| \'is_success\' tinyint(1) NOT NULL,                                   |
|                                                                       |
| \'error\' varchar(255) NOT NULL,                                      |
|                                                                       |
| PRIMARY KEY (\'ID\')                                                  |
|                                                                       |
| ) ENGINE=InnoDB DEFAULT CHARSET=utf8                                  |
+-----------------------------------------------------------------------+
图6-7 创建操作记录数据库表格
接下来，将关键信息存入数据库表格，如图6-8所示。
+-----------------------------------------------------------------------+
| INSERT INTO \'my_try\'. \'operation_record\' (\'account_ID\',         |
| \'account_name\', \'operation_type\', \'operation_target\',           |
| \'is_success\') VALUES (\'33\', \'张三\', \'read\', \'ALERTLIST\',    |
| \'1\');                                                               |
|                                                                       |
| INSERT INTO \'my_try\'.\'operation_record\' (\'account_ID\',          |
| \'account_name\', \'operation_type\', \'operation_target\',           |
| \'is_success\', \'error\`) VALUES (\'35\', \'王五\', \'update\',      |
| \'PASSWORD\', \'0\', \'origin password input wrong.\');               |
+-----------------------------------------------------------------------+
图6-8 将关键信息存入数据库表格
最后，在数据库表格（operation_record）中显示日志操作记录，如图6-9所示。
![pasted-image.png](media/image8.png){width="5.260218722659667in"
height="0.6435400262467191in"}
图6-9 显示日志操作记录
### 6.3.2 分布式存储
对于大规模日志的存储，单机容量往往无法满足要求，采用分布式系统是一个很好的选择。分布式存储的典型代表是Hadoop。分布式系统的容量和规模不受限制，可以按需扩展，查询和检索信息的速度也可以通过算法大幅提升，还可以备份节点信息，从而保障数据的安全性。
1\. 存储和查询
Hadoop分布式文件系统（Hadoop Distributed File
System，HDFS）是一种可运行在通用硬件上的分布式文件系统。HDFS支持文件的"一次写入、多次读取"，其中读取采用流式访问方法，并结合了MapReduce的思想。
HDFS采用Master/Slave架构，HDFS集群由一个Namenode和一定数目的Datanode组成。Namenode是一个中心服务器，负责管理文件系统的名称空间及客户端对文件的访问。文件被分成一个或多个数据块，数据块的大小可以是64MB或128MB，这些数据块被存储在一组Datanode中。Namenode执行文件系统的名称空间操作，如对文件或目录进行打开、关闭或重命名等，同时负责确定数据块到具体Datanode的映射。Datanode负责处理文件系统客户端的读写请求，在Namenode的统一调度下进行数据块的创建、删除和复制。
2\. 优点和缺点