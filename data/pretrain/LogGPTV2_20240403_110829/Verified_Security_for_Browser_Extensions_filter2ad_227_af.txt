### 3. 实验评估总结

图8展示了我们的实验结果。它列出了我们编写的17个扩展程序，每个扩展程序的代码行数、策略规则（假设）的数量、验证和编译所需的时间，以及在验证过程中发出的定理证明器查询数量。这些扩展程序是针对我们精炼的API中的某些子集编写的。图9显示了我们API中的各个组件及其代码行数。

尽管我们的大多数扩展程序只使用了少数几个策略假设，但如第四章-B节所述，基于逻辑的策略并不总是比代码更容易理解—我们的可视化工具在这方面提供了一些帮助。

**图9：扩展程序API**

我们的扩展程序可以分为三类。第一组包括五个从头开始编写并经过访问控制属性验证的扩展程序。Magnifier是一个可访问性扩展程序：它可以在任何网页上放大鼠标下的文本—其策略确保仅更改页面样式。PrintNewYorker将链接重写为直接指向打印视图，去除了广告和多页布局—其策略确保链接主机不会被更改，并且只有已知常量可以附加到URL的查询字符串中。Dictionary查询在线词典以获取所选单词—仅允许发送所选单词到网络。Bib Parser使用自己的XML模式语言将作者之一的参考文献从网页格式解析为bibtex—其策略保证仅从特定URL读取数据。

**第二组扩展程序同时验证了授权和信息流属性。** 这些矿工和个人化扩展程序是在一个专门研究通过挖掘用户行为来个性化网页内容的浏览器扩展程序项目中开发的[11]。下一节将详细讨论其中一个扩展程序的变体—其他扩展程序具有类似的风格。最后一组扩展程序包括5个部分移植到Fine的Chrome扩展程序。我们在第七章-C节中详细讨论这些扩展程序。

### B. NewsPers：控制数据流和浏览历史

NewsPers是一个个性化新闻网站的扩展程序。它重新排列首页上的新闻故事，使其链接到更可能吸引用户的新闻故事。具体步骤如下：

1. 当用户浏览新闻网站时，NewsPers会读取本地文件系统中的配置文件，该文件指定了用户的新闻偏好。
2. 它将来自此偏好文件的数据发送到一个社交新闻网站，并获得当前热门故事的响应。
3. 它会查阅用户的浏览历史记录，确定哪些热门故事尚未被用户阅读。
4. 最后，它重新排列新闻网站的页面，将未读的热门故事放在顶部。

对于这个扩展程序，我们的目标是强制执行以下策略：
1. 社交新闻网站只能从配置文件中获取数据；
2. 不向新闻网站泄露任何关于浏览历史的信息（除了它可能已经知道的信息）。

图10显示了NewsPers的一个片段。

我们首先展示了一个超出DOM功能的API片段。我们从一个访问本地文件系统的API开始，使用readFile函数，该函数受CanReadFile特权保护。接下来，我们展示了处理URL和进行网络请求的API。最后，我们展示了访问本地浏览历史的API。我们的API提供了更细粒度的控制，使扩展程序可以请求查看用户在特定站点上可能访问过的URL的历史记录。

使用这个API，我们的策略授予NewsPers读取所需配置文件和仅对新闻网站的浏览历史的特权。第15行的假设说明了如何使用安全性策略来强制执行流控制。这里，我们声明只有从偏好文件中派生的信息才能发送到社交新闻网站。

第16-17行指定NewsPers有特权将元素e2作为另一个元素e1的子元素添加，但前提是e1是新闻网站的节点，并且e2是从同一域的节点派生的。换句话说，这个假设允许NewsPers重新排序新闻网站页面上的节点结构，但不允许添加任何新内容。这种规范尤为重要，因为NewsPers可以访问用户的浏览历史记录。如果它可以向新闻网站写入任意元素，例如插入图像标签来向第三方发送请求，则可能会泄露浏览历史记录。当然，通过重新排列新闻网站页面的结构，NewsPers确实会向新闻网站本身揭示用户的浏览历史记录—但这不是一个严重的问题。

在第20-26行，我们展示了从本地偏好文件读取数据并将其发送到社交新闻网站的函数实现。第27-36行展示了重新排列新闻网站的高级结构代码。我们省略了几个辅助函数的实现，但展示了它们的签名—这些函数大多不涉及安全敏感操作。请注意，实现本身几乎没有类型注释。虽然为API装饰精确类型需要一些努力，但这种负担由我们（API开发者）一次性承担。

最后，我们采用的流控制模型自然地融入了安全性框架。然而，与基于非干扰性的信息流控制方法相比，我们获得的安全属性相对较弱。特别是，我们获得的是语法保密性，而不是观察等价性属性。实际上，这意味着扩展程序可以通过根据浏览历史中的URL选择发送各种用户偏好信息片段来向社交新闻网站泄露浏览历史信息，即通过隐式流的形式。虽然先前的工作表明如何使用值索引类型消除这种泄漏，但为了简单起见，我们在这里不讨论这种方法。其他扩展程序，包括一些矿工，采用了这种方法（增加了程序员的工作量）来防止通过隐式流泄漏信息。

### C. 为Chrome扩展程序提供回顾性安全性

在第二章-C节中，我们指出许多Chrome扩展程序因Chrome的访问控制系统过于粗粒度而过度特权。我们还描述了八个过度特权扩展程序的无害行为（图3）。现在我们有了细粒度的安全系统，可以考虑保护它们。

图8的最后一部分列出了五个全功能扩展程序。Chrome扩展程序分为两个组件—内容脚本和扩展核心—它们通过消息传递进行通信。扩展核心的大小范围从500到20,000行JavaScript代码（括号中所示）。扩展核心可以执行各种特权操作（例如，本地存储、跨域请求等），但不能直接读写网页。另一方面，内容脚本可以修改网页，但无法访问扩展核心可以访问的资源。当然，这两个组件可以合作，使扩展核心能够访问网页，反之亦然，或者使内容脚本能够访问存储。尽管如此，这种分离确实提供了一定程度的隔离。

原则上，我们可以将整个Chrome扩展程序移植到Fine并验证其端到端属性。然而，我们选择仅用Fine重写内容脚本，而将扩展核心留在JavaScript中。这种方法虽然涉及较少的工作量，但仍为Chrome扩展程序提供了细粒度DOM授权策略的一些好处。

如图3所示，这些扩展程序与网页的交互方式有限。然而，它们的有限行为无法在Chrome清单中精确表达，因此需要“所有网站上的您的数据”的访问权限。我们可以精确地声明这些扩展程序实际需要的有限特权，并自动验证其合规性。

我们的策略语言和API保持不变，除了添加了一些简单的Chrome特定的消息传递函数，以便我们的Fine内容脚本能够与扩展核心通信。在Chrome中部署这些扩展程序涉及将用Fine编写的内容脚本编译为JavaScript—我们将在下一部分讨论这一点。

### 第八章：跨浏览器扩展程序

IBEX的一个重要优势在于，一旦扩展程序经过验证，就可以重新定位到多种现代浏览器上运行。到目前为止，我们已经在四个不同的Web浏览器上运行了我们的扩展程序：Internet Explorer、Google Chrome和C3（微软研究院正在开发的研究型Web浏览器）。此外，由于可以从.NET编译到JavaScript，我们还将一些扩展程序重新定位到了Firefox上运行。每个浏览器都采用了不同的后端和TCB。在本节中，我们将讨论这些浏览器提供的系统级安全保证。

**Internet Explorer: BHOs**：为了支持Internet Explorer，我们将Fine扩展程序编译为.NET库。这些库随后由单个原生IE扩展程序或BHO加载。