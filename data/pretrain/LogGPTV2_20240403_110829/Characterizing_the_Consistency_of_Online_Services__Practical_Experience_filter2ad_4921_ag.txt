experimentally observed that violating these rate limits can lead the service to
either block further access by the application, or introduce noticeable delays in
processing requests issued by the application. The existence of operation rate
limits imposes a requirement on our protocols: for each application operation,
a single service operation can be issued. This is important to guarantee that an
application using our middleware faces the same rate limits as an application
using the service directly.
54
4.2. SYSTEM OVERVIEW
Figure 4.3: Middleware architecture
4.2 System overview
In this section we discuss the general architecture of our solution, which is
materialized in a library implementing a middleware layer. We then provide
an overview of the operation of our protocols, explaining how they enforce the
consistency guarantees of session properties in a transparent way for the client
applications.
4.2.1 Architecture
Our system consists of a thin layer that runs on the client side and intercepts
every call made by the third-party client application on the service, mediating
access to the service. In particular, our layer is responsible for contacting the
service on behalf of the client application, process the responses returned by
the service and generate responses to the client applications with the session
guarantees being enforced. Figure 4.3 provides a simple representation of this
architecture.
Our solution can be conﬁgured by the third-party application developer
55
ApplicationMiddlewareServiceRead Your WritesMonotonic WritesMonotonic ReadsWrite Follows Readinsert(Lst, ElementId, Value)List get(Lst)insert(Lst, ElementId, Value)List get(Lst)ClientCHAPTER 4. FINE-GRAINED CONSISTENCY FOR ONLINE SERVICES
to enforce any combination of the individual session guarantees, deﬁned in
Section 3.2.1, namely: i) Read Your Writes, ii) Monotonic Reads, iii) Monotonic
Writes, and iv) Writes Follow Reads. In order to enforce these guarantees,
our system is required to maintain information regarding previous operations
executed by the client application, namely previous writes that were issued or
previous values that were observed by the client. In addition, our layer can
also insert metadata that is stored alongside the data in the original system,
but stripped by the library before the ﬁnal response is conveyed to the client.
4.2.2 Overview
As mentioned above, our system intercepts each request performed by the
client application, executes the request in the service, and then processes the
answer generated by the service to provide a (potentially diﬀerent) answer to
the client application. This answer is computed based on a combination of the
internal state that records the previous operations that were executed by that
particular client, and the actual response that was returned by the service.
Tracking application activity. In order to keep track of user activity, our
system maintains in memory a set of data structures for each part of the service
state that is accessed by the application. These data structures are updated ac-
cording to the activity of the application (i.e., the operations that were invoked)
and the state that is returned by the service. These data structures are: i) the
insertSet, which stores the elements inserted by the client and ii) the localView,
which stores the elements returned to the client.
Enforcing session guarantees. Enforcing session guarantees entails achiev-
ing two complementary aspects. First, and depending on the session guaran-
tees being enforced, some additional metadata must be added when inserting
operations. As mentioned, this metadata can be either added to a specialized
metadata ﬁeld (if the API exposed by the service allows this) or directly en-
coded within the body of the element being added to the list. Such metadata
has to be extracted by our library when retrieving the elements of a list, thus
ensuring transparency towards client applications. Second, our system might
be required to either remove or add elements to the list that is returned by the
56
4.3. ALGORITHMS
service when the application issues an operation to obtain the current service
state, in order to ensure that the intended session guarantees are not violated.
In the next section, we discuss the concrete algorithms executed by our system
upon receiving an insert or get operation for a particular list, in order to ensure
that the values observed by the client application adhere to the semantics of
each of the session guarantees that are intended to be provided.
4.3 Algorithms
We now discuss in more detail the algorithms that are employed by our Mid-
dleware layer to enforce session guarantees, and the rationale for their design.
Throughout the presentation, we brieﬂy remind what each of the four session
guarantees entails and we extend the deﬁnitions previously presented in Sec-
tion 3.2.1 (maintaining the same semantic) to guarantee safety in Web APIs
that have the restrictions mention previously. Then we explain why our algo-
rithms ensure that the anomalies associated with each of the session guarantees
are prevented by it.
We explain our algorithms assuming that the service oﬀers an interface
with the following two functions, which are in practice easily mapped to
functions that are supported by the various services that we analyzed: the
insertion of an element in a given list Lst, denoted by the execution of func-
tion insert(Lst,ElementID,V alue), where Lst identiﬁes the list being accessed,
ElementID denotes the identiﬁer of the element being added (which can be an
identiﬁer generated by the centralized service or a unique identiﬁer generated
by our Middleware), and V alue stands for the value of the element being added
to the list; and the access to the contents of a list, denoted by the execution of
function get(Lst), where Lst identiﬁes the list being read by the client.
When the client accesses a list Lst for the ﬁrst time, a special initialization
procedure is triggered internally by our Middleware (Algorithm. 1), which
initializes the local state regarding the accesses to Lst. The initialization is
straightforward: it creates the object lstState that maintains all relevant infor-
mation to manage the accesses to Lst (line 2). This state is composed by the
57
CHAPTER 4. FINE-GRAINED CONSISTENCY FOR ONLINE SERVICES
Algorithm 1: Initialization of local state
1: upon init(Lst) do
lstState ← init()
2:
lstState.insertSet ← {}
3:
lstState.localView ← {}
4:
lstState.lastTimestamp ← 0
5:
lstState.lastSessionTimestamp ← 0
6:
lstState.insertCounter ← 0
7:
lstState.lastInsertTimestamp ← 0
8:
listStates[Lst] ← lstState
9:
sets insertSet and localView that were discussed previously in 4.2.2, and that
are initially empty (lines 3− 4). Furthermore, four other variables are initial-
ized, lastTimestamp and lastSessionTimestamp, which are used to maintain
information regarding elements that were removed from the insertSet and the
localView, insertCounter, which tracks the number of inserts performed by
the local client in the context of the current session, and lastInsertTimestamp
that has the timestamp of the last inserted element in the session. All these
variables have an initial value of zero (lines 5− 8). Finally, the lstState variable
is stored in a local map, associated to the list Lst (line 9). Next, we explain
how this local state is leveraged by our algorithms to enforce the various ses-
sion guarantees. In order to easily combine the algorithms, we divided the
get operation in three execution blocks: the read block, that is responsible for
obtaining the local state of the list and the data from the service; the transfor-
mation block, that is responsible for applying the necessary transformations
over the list returned by the service, and the store block, that is responsible for
updating the local state.
4.3.1 Read Your Writes
As mentioned in Chapter 3, the Read Your Writes (RYW) session guarantee
requires that, in a session, any read observes all writes previously executed
by the same client. More precisely, for every set of insert operations W made
by a client c over a list L in a given session, and set S of elements from list L
returned by a subsequent get operation of c over L, we say that RYW is violated
if ∃ x ∈ W : x (cid:60) S.
58
4.3. ALGORITHMS
Algorithm 2: Read Your Writes
1: function insert(Lst, ElementId, V alue) do
2:
3:
4:
5:
6:
7:
8:
9:
lstState ← listStates[Lst]
Element e ← (ElementId, V alue)
e.timestamp ← obtainServiceTimeStamp(lstState.lastInsertTimestamp)
e.clientSession ← getClientSessionID()
lstState.lastInsertTimestamp ← e.timestamp
service.insert(Lst, ElementId, e)
lstState.insertSet ← addElementToInsertSet(e, lstState.insertSet)
listStates[Lst] ← lstState
10: function get(Lst) do
Read
11:
12:
Transform
13:
14:
15:
16:
Store
17:
18:
19:
20:
lstState ← listStates[Lst]
sl ← service.get(Lst)
sl ← orderByTimestamp(sl)
sl ← addMissingSessionElementsToSL(sl, lstState.insertSet, lstState.lastSessionTimestamp)
sl ← purgeOldSessionElementsFromSL(sl, lstState.lastSessionTimestamp)
sl ← subList(sl, 0, N )
lstState.lastSessionTimestamp ← getLastSessionTimestamp(sl)
lstState.insertSet ← purgeOldElements(lstState.insertSet, lstState.lastSessionTimestamp)
listStates[Lst] ← lstState
return removeMetadata(sl)
This deﬁnition, however, does not consider the case where only the N el-
ements of a list are returned by a get operation. In this case, some writes of
a given client may not be present in the result if more than N other insert
operations have been performed (by client c or any other client). Consider-
ing that the list must hold the session elements in the order they were issued,
a RYW anomaly happens when a get operation returns an older write per-
formed by the client but misses a more recent one. More formally, given two
writes x, y over list L executed in the same client session, where x was exe-
cuted before y, an anomaly of RYW happens in a get that returns S when
∃ x, y ∈ W : x ≺ y ∧ y (cid:60) S ∧ x ∈ S.
Algorithm 2 presents our algorithm for providing RYW. To avoid the
anomaly described above, the idea is to store, locally at the client, all elements
that are inserted by the local client in the list and add them to the result of get
operations. In the insert operation, the inserted element is stored locally by the
client (line 8). Additionally, our algorithm stores some metadata in the object
before performing the insert operation over the service (lines 3− 4). This infor-
mation represents, respectively, the identiﬁer of the element and a timestamp
59
CHAPTER 4. FINE-GRAINED CONSISTENCY FOR ONLINE SERVICES
for the insert operation (from the perspective of the service, and retrieved as
described in Section 4.1). The element identiﬁer is used to uniquely identify
the writes. The timestamp and the element identiﬁer allow for totally ordering
all entries in the insertSet, with the order being approximately that of the real-
time order of execution. The operation in line 4 also checks if the timestamps
retrieved from the service in the same session are monotonically increasing,
and, if not, enforces that property by overwriting the returned timestamp with
an increment of the most recent one, that is stored in the lastInsertedTimes-
tamp; this is important to avoid reordering events from the same session in case
the timestamp provided by the server does not increase monotonically for some
reason. Note that it is not necessary to always obtain the time from the service
before each insert operation, we can retrieve the time only on the ﬁrst time the
service is accessed and calculate the clock delta by taking into consideration
the passing of time from the perspective of the clock in the client machine, and
then use this value and the client clock to calculate a new timestamp.
All of our operations are split into three blocks: read, transformation, and
store. In particular, for executing a get operation (line 10) our algorithm starts
by executing the get operation over the service (line 12), in the read block of the
algorithm. Then, the returned list (sl) is ordered (line 13) and all elements of
the local insertSet that are missing in the list are added to the list, keeping the
list ordered (line 14), this is done in the transformation block of the algorithm.
Before returning the most recent N elements (with no metadata) (line 20),
our algorithm removes old session elements from the sl list and updates the
lastSessionTimestamp variable with the timestamp of the oldest element of
the client session returned to the client (lines 17), this last operation is done in
the store block of the algorithm.
To avoid the insertSet to grow indeﬁnitely, we use the timestamp of each el-
ement to remove from the insertSet any element older than lastSessionTimes-
tamp (line 18). We also need to include the session identiﬁer in the metadata
of each element to avoid old elements of the session to reappear (line 15).
60
4.3. ALGORITHMS
Algorithm 3: Monotonic reads
1: function insert(Lst, ElementID, V alue) do
Element e ← (ElementID, V alue)
2:
e.timestamp ← obtainServiceTimeStamp()
3:
service.insert(Lst, ElementID, e)
4:
5: function get(Lst) do
Read
6:
7:
Transform
8:
9:
10:
11:
Store
12:
13:
14:
15:
16:
lstState ← listStates[Lst]
sl ← service.get(Lst)
sl ← orderByTimestamp(sl)
sl ← addLocalViewElementsToSL(sl, lstState.localView)
sl ← purgeOldElementsFromSL(sl, lstState.lastTimestamp)
sl ← subList(sl, 0, N )
lstState.lastTimestamp ← getLastTimestamp(sl)
lstState.localView ← addNewElements(sl, lstState.localView)
lstState.localView ← purgeOldElements(lstState.localView, lstState.lastTimestamp)
listStates[Lst] ← lstState
return removeMetadata(sl)
4.3.2 Monotonic Reads
This session guarantee requires that all writes reﬂected in a read are also re-
ﬂected in all subsequent reads performed by the same client. To deﬁne this
in our scenario where a truncated list of N recent elements is returned, we
say that Monotonic Reads (MR) is violated when a client c issues two read
operations that return sequences S1 and S2 (in that order) and the following
property holds: ∃x, y ∈ S1 : S1(x) ≺ S1(y)∧ y (cid:60) S2 ∧ x ∈ S2, where S1(x) ≺ S1(y)
means that element x appears in S1 before y.
To avoid this anomaly, our algorithm (presented in Algorithm 3) resorts to
the localView variable to maintain information regarding the elements (and
their respective order) observed by the client in previous get operations. There-
fore, when the client issues a get operation, our Middleware issues the get
command over the centralized service and then updates the contents of sl with
the elements that are in the localView that are missing. The algorithm termi-