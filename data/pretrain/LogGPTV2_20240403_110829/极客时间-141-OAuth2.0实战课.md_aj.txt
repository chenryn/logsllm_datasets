# 07 如何在移动App中使用OAuth 2.0？

大家好，我是王新栋。在前面的几讲中，我主要讨论了基于Web应用场景下的OAuth 2.0。然而，在实际环境中，还有许多移动应用程序也需要安全认证和授权。那么，移动App是否可以使用OAuth 2.0？如果可以，又该如何正确地使用它呢？

### OAuth 2.0的灵活性

尽管OAuth 2.0最初是为Web应用设计的，但其核心协议框架足够灵活，允许我们在不同领域进行适当的扩展。因此，无论是在桌面还是移动环境中，OAuth 2.0同样适用。鉴于授权码许可类型（Authorization Code Grant）提供了最全面的安全保障，本讲将以该模式为基础，探讨移动App如何利用OAuth 2.0。

### 移动App架构分类

当开发一款移动App时，根据是否有服务端支持，我们可以将其分为两类：

- **无服务端**：这类App不需要与自己的服务器通信，或者可以直接调用其他开放的HTTP接口。
- **有服务端**：除了客户端功能外，还具备服务器端能力，比如记录用户操作日志等。

![两类移动App](https://static001.geekbang.org/resource/image/4c/99/4c034e019467aafae511f16055b57b99.png)

这两类App在采用OAuth 2.0时的主要区别在于获取访问令牌的方式：
- 如果存在后端服务器，则推荐通过服务器与授权服务交互来换取访问令牌；
- 若无后端支持，则只能依靠前端直接与授权服务沟通，这通常意味着采用隐式许可类型，但这会降低整体安全性。

### 无服务端App的应用

对于没有独立服务器支持的纯客户端App来说，实现OAuth 2.0的关键挑战是如何安全地处理`app_secret`。将`app_secret`嵌入到客户端代码中显然不是一个好主意，因为一旦泄露，后果不堪设想。为此，引入了PKCE (Proof Key for Code Exchange) 协议，这是一种专门为公共客户端设计的方法，旨在增强授权码流程的安全性。

#### PKCE工作原理
1. 客户端生成一个随机字符串`code_verifier`。
2. 基于`code_verifier`计算出`code_challenge`。具体算法有两种选择：直接传递或经过SHA256哈希+Base64编码。
3. 在请求授权码时附带`code_challenge`及对应的生成方法。
4. 当需要兑换访问令牌时，提供原始的`code_verifier`供验证。

这样即使授权码被截获，攻击者也无法仅凭`code_challenge`逆向获得`code_verifier`，从而有效防止未经授权的访问令牌获取行为。

### 有服务端App的应用

相比之下，拥有自己服务器的移动App能够更安全地执行OAuth 2.0流程。例如微信登录就明确指出推荐使用`authorization_code`模式，并且建议配合后端服务以确保整个过程的安全性。

![微信登录流程](https://static001.geekbang.org/resource/image/86/b1/86d3yy8fa419c94b7e3766fe0a4e3db1.png)

在这种情况下，整个认证流程类似于传统的Web应用：
- 用户通过第三方App发起登录请求。
- 跳转至微信App完成身份验证。
- 微信服务器返回授权码给第三方App。
- 第三方App服务器使用此授权码加上`app_secret`从微信服务器获取访问令牌。

### 总结

总之，在移动App中实施OAuth 2.0时，请牢记以下几点：
- 确保遵循最佳实践，特别是在处理敏感信息如`app_secret`时。
- 对于没有专门后端的App，考虑采用PKCE机制加强安全性。
- 尽可能为你的App配备后端基础设施，以便更安全地管理认证流程。

希望今天的分享对你有所帮助！如果你对移动App中OAuth 2.0的安全使用有任何想法或疑问，欢迎留言讨论。同时别忘了把这篇文章分享给更多感兴趣的朋友哦！

---

思考题：除了上述提到的方法之外，在移动App中还有哪些相对安全的方式来使用OAuth 2.0呢？期待你的精彩回答！