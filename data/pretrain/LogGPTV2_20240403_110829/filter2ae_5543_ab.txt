## 非常规Rootkit以及检测方案
#### 使用了命名空间技术的HorsePILL
在讲述该Rootkit之前，有必要简单介绍一下命名空间的含义。命名空间是Linux的一个非常重要的系统特性，Linux的命名空间机制提供了一种资源隔离的解决方案。PID,IPC,Network等系统资源不再是全局性的，而是属于特定的Namespace，不同命名空间的资源是
**互相隔离** 的，在一个命名空间所做的事情不会影响另一个命名空间。各命名空间在Linux的引入版本如下:
由于命名空间的隔离特性，这给恶意文件的隐藏提供了新的思路。将恶意文件和恶意文件运行过程中的进程、网络置于一个 **与系统不同命名空间的环境中**
，可以非常有效的隐藏自身，在一定程度上来说，难以发现。
HorsePILL这个Rootkit就利用了这种命名空间的特性，该Rootkit会感染系统的initramfs，被感染的系统在启动过程中加载initramfs就会执行Rootkit的恶意代码。恶意代码执行之后，会将整个系统置于一个新创建的子命名空间之中，而恶意代码本身运行于更上级的命名空间。这种Rootkit隐藏方式可谓是别具一格，对系统的性能影响可以说忽略不计。是一个非常棒的Rootkit，美中不足的是该Rootkit需要重启系统才能够执行其恶意代码。
这种Rootkit也是有非常有效的运行时检测方案，首先，该Rootkit需要感染initramfs，基于这一点可以修改grub，给grub新增一个
**启动过程中校验initramfs和vmlinuz文件完整性**
的功能，避免启动不受信任的系统。当系统不幸感染了这种基于命名空间的Rootkit，整个系统用户空间的数据已经不在可信的情况下，可以
**从内核态中测绘各个命名空间的信息** ，并且从中发现异常的命名空间数据。
感染horsepill，攻击者拿到了设备的shell，攻击者视角下真实的1号进程的命名空间数据如下:
感染horsepill之后设备管理员视角下，可以非常直观的看到命名空间信息已经出现了异常，而这种异常信息通常是被人忽略的。
对于这种Rootkit，受害主机运行时可以通过命名空间测绘的方式发现Rootkit的存在。
#### 使用kprobe技术的Rootkit
在上文中讲Elkeid的时候提到了kprobe这个机制，这个机制可以用来采集系统的行为信息，当然也可以用来编写Rootkit。Kprobe、jprobe以及kretprobe可以在内核符号的函数序言和函数尾声插桩，一旦内核符号注册了kprobe，就会修改函数序言，被修改的函数序言会执行一个跳转指令，跳转到一个新的内核符号trace_spurious_interrupt，然后由trace机制跳转到中断处理函数，中断处理函数再调用kprobe的回调函数，使用kprobe技术可以
**篡改部分内核符号的入参和返回值** ，这能够非常容易的达到隐藏恶意程序相关信息的目的，并且这种Rootkit隐蔽性也同样很强。
这类Rootkit的检测方法也是同样不同于前面的方案的。最简单的判断方法就是查看/sys/kernel/debug/kprobes/list这个文件的内容。
但是该方案有一个非常致命的缺陷，系统感染了kprobe的Rootkit之后，/sys/kernel/debug/kprobes/list文件的内容已经是不可信的了，因此需要从其他途径获取Rootkit检测的线索。
内核中有这么一个数据结构kprobe_table，该数据结构维护了所有注册的kprobe的表，遍历这张表，可以发现感染这类Rootkit的kprobe数据结构。
内核符号在vmlinuz、挂载kprobe之前和挂载kprobe之后其数据都是存在非常明显的差异性的。例如:
内核符号SyS_ptrace经过kprobe挂载前后的内存数据对比如下图:
左边是挂载kprobe之后的内存数据，右边是挂载kprobe之前的内存数据，根据两者对比，可以发现前4个字节存在差异。同样也是这个内核符号，在/boot/vmlinuz文件中的二进制数据也和上面两者不同，相关数据如下图所示:
其差异同样体现在符号的前4个字节。这三者之间的差异主要由两方面因素所导致。首先是
**vmlinuz加载到内存时，会动态的修改其代码内容，这种修改主要通过.altinstructions这个段中的数据完成的。**
加载到内存之后，再对其挂载kprobe，修改的同样是前4个字节，将这部分差异性较强的代码进行反汇编，可以得出其汇编代码。
**Vmlinuz：**  
**Before kprobe:**  
**After kprobe:**  
反汇编这部分数据，可以看到其具体的操作码也有较强差异。首先，符号SyS_ptrace的内存地址为0xffffffff8108a1b0，挂载kprobe之后，其执行的第一个指令为call
0x5bd300。因此可以计算，其跳转地址为:'0xffffffff816474b0'。查询该地址对应的符号如下:
根据上述分析内容，kprobe Rootkit会在执行过程中修改内核符号的函数序言，因此要检测这种类型的Rootkit，还可以对
**运行时的内核代码进行完整性检测。**
#### 基于ebpf的rootkit
基于bpf的Rootkit并不是什么新鲜事物，bpf技术于1993年就被提出，bpf的指令集并非是一种图灵完全的指令集，因此使用bpf指令开发Rootkit似乎是一种天方夜谭。但是APT组织Equation
Group做到了，在shadow brokers于2016年公开方程式的工具包中，有这么一个不太引人瞩目的Rootkit
DewDrops。这么长时间以来，大多数人眼里看到的可能只有永恒系列漏洞利用和doublepulsar后门，而对于其中的Dewdrops
Rootkit，却是很少有人关注。尽管他的知名度并不高，但并不影响我对这个Rootkit设计者的佩服。
但是DewDrops并非此次的主要内容，这一段的主角rootkit是ebpfkit，这个Rootkit于2021年在多个世界顶级安全会议上亮相。该Rootkit可以hook内核态函数，篡改内核态返回用户态缓冲区数据，达到用户态欺骗的目的。用户态进程拿到被篡改的数据，从而被骗通过认证。在此过程，不改变任何文件、进程、网络行为，不产生日志。
**常规HIDS、HIPS产品无法感知。**
eBPF还支持kprobe/kretprobe、uprobe/uretprobe、XDP、TC、socket、cgroup等程序类型，覆盖文件、网络、socket、syscall等事件，都是可以被黑客利用的地方。
面对这么复杂的威胁，从安全防御的视角，该怎样处理这种类型的威胁呢？这个Rootkit的作者给出了这么一份答卷(业界良心啊)。作者开源了针对这种Rootkit的检测工具ebpfkit-monitor。该工具可用于 **静态分析eBPF字节码** 或在 **运行时监控可疑的eBPF活动**
，尽管当前该检测工具仅仅针对ebpfkit，但是这无疑给研究基于ebpf技术的Rootkit检测工具的人提供了良好的思路。
## 结语
在攻防对抗愈加激烈的时代，在APT攻击逐渐进入大众视野的当下，Rootkit的攻防也将会愈加激烈，而安全从业者乃至安全企业，也需要重新审视一下，是否已经具备了针对未知威胁的检测能力，是否已经具备了针对新型攻击技术的检测防御能力。
## 参考资料
1.
2.
3.
4.
5.
6.
7.
8.
9.
* * *