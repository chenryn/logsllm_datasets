都使用程序中的方法 M和一个上下文C 来标识。在原调用图的边上
合，其中n≥0。
实际上表示了对应于调用串(s1，s3，（s5，s3）"，s4）的无穷集
的调用到达t。这么做给出了两个新的上下文（s1，s6，s7）和
下文(s1,s4)。
对方。我们把这个环打开：
因此，两个可能的调用串是(s2，s7)和（s2，s8）。
和s5 处。
的所有调用点的列表。函数α和r 之间的递归调用就发生在 s3
根本不会递归调用。因此，我们的上下文将是除了 s3 和 s5 之外
检查一下这些调用就会发现，q和r是相互递归的。但是 p、s 和 t
例12.26
调用发生时，我们把该调用点记录为这个上下文的一部分。
用串，如果下面情况成立就删除一个调用点的出现：
(sl,s6,s8)。
单个非递归函数组成的 SCC 是平凡 SCC。
递
数
中就存在一条从结点p 到α的边。这个图的强连通分量(SCC)就是相互递归调用函数的集合。
这里不再详细讨论。考虑一个以程序中各个函数为结点的图。如果函数p调用了函数α，那么i
“难以分拆"的内容。我们首先找出程序中相互递归调用的函数的集合。这个过程很简单，因I
个确定的有穷状态自动机。之后，各个上下文就可以使用这个自动机的状态来标识。
前面有一个规则说任何调用串都是一个上下文，我们对这个规则做如下修改。给定一个调
鱼归调用的情况），或者它包含唯一一个递归成员，我们就说这个SCC 是非平凡的（nontrivial）。
p本身是一个SCC，而所有的非递归函数本身也是 SCC。如果一个 SCC 具有多个成员（即相互
面的这个特例很常见。一个函数p调用了它自身，但是它不在包含了其他函数的 SCC 中，那么函
这里，我们将采用--个更简单的方案，它包含非递归调用的全部历史，但是把递归调用当作
号一个描述了所有可能调用串的正则表达式，然后使用3.7节中的方法把这个表达式转化成为一
② 在 s6 处，r.调用s。这里，我们可以通过在 s7 处或 s8 处
过程间分析
现在我们描述一下如何得到克隆调用图。每一个被克隆的方法
① 在 s4 处，t直接被α调用。这个选择可以得到唯一的上
因此，总共有五个不同的上下文调用了t。请注意，所有这些
2）p可以在 s1 处调用q。然后，q和r可以多次递归地调用
1）p可以在 s2 处调用s，然后s可以在 s7或者 s8 处调用t
让我们考虑从p 到t的所有路径，也就是所有调用了t 的上下文:
这么做的结果是，当一个非平凡 SCC 的成员 S被调用时，这个调用的调用点变成了上下文的
3） p和q位于同一个强连通分量中(即p和g 相互递归调用，或者 p=g 且p 是递归函数)。
2）函数α在调用点s处被调用(有可能=p)。
1）s在一个函数p中。
，图12-28 中给出了五个函数的略图，图中给出了一些调用点和这些函数中的调用。
口
void s(T y){
L
void p(）{
例对应的函数和调用点
图12-28与一个运行实
t(T z){
r(T x){
} (μL)
s2:
i：
return e;
return d;
=r(w);
= new T();
s(e) ;
s(b);
599
区
此
作
---
## Page 616
代码上，我们能够区分的上下文有哪些？
12.6.412.6节的练习
相关性更加有用。
接收对象分别进行分析。
指向不同的对象。如果不区分接收对象，在由 this 对象引用的
个类的两个不同的接收对象。这两个不同的接收对象的字段可能
的场景：在某个调用点所处的上下文中有一个变量可能指向同一
术可以区分在不同的接收对象上调用的方法。我们考虑一下这样
相应的分析方法能够被用于大规模程序则是另一个问题了。
很容易向 Datalog 规则中加人对象的上下文相关信息，但是要使得
应
所
个简化处理可能引起一些问题。考虑一下对象工厂设计设计模式，这个设计模式中同一类型的
能处理量
12.6.3 关于相关性的更多讨论
可以指向堆对象 H。所有这些规则都是不解自月
数。断言 pts( V,C，H)表示上下文C 中的变量
我们相应地修正了所有的 Datalog 规则。为简单起
文
文
的
图
应
三
12.6.2在 Datalog 规则中加入上下文信息
上下文C中的调用点S调用了方法M的上下文 D。
克隆调用图中的例程，我们可以定义--个相应的断言CSinuohes，CSinvokes（S，C，M，D)为真的条件是
用图中有一条连接调用点S 和方法 M的边的条件是断言 inuokes(S，M)为真。为了增加上下文以标识
段之间的复制语句将产生虚假的指向关系，除非我们对不同的
一般性的情况时，我们期望提高对象命名的上下文相关性。虽然
应对这一情况的比较容易的方法是把相应的对象创建代码进行实质上的内联处理。在处理更具
斤有对象都由同一个例程分配。当前的表示方案会使得那个类的所有对象都共享同一个名字。
-节将要描述的一些技巧，它就能够处理很多真实的大型Java 程序。虽然如此，这个算法还是不
上下文 D 的方法M的形式参数可能指向由上
C中的调用点S调用了上下文D的方法M，那
为，但规则5是-一-个例外。规则5 表示，如果上
，下面的规则不包括类型约束，且符号“_”表矛
图中的方法是用原方法和它的上下文来表示的，
练习12.6.1：如果我们把本节中的方法应用到图 12-30中的
C 中的相应实在参数指向的对象。
用到克隆的调用图上。因为在这个克隆的调
 另一-个相关性的重要形式是对象相关性。一个对象相关的技
在这个表示方法中，堆对象是通过它们的调用点来命名的，但是却不具有上下文相关性。
IDB 断言 pts 中必须增加--个表示上下文的参
为了找出上下文相关的指针指向关系，我们
600
上面我们描述的是一个上下文相关性的公式化表示。这个方法已经体现出实用性。使用下
直接把相同的上下文无关指针指向分析技
最大型的 Java 应用。
，在有些分析中，对象相关性要比上下文
下
明
示
用
术
1
图12-29
亿
二
hpts(H,F, G)
pts(V, D,H)
pts(V,C, H)
pts(V,C,H)
pts(V,C,H)
上下文相关的指针指向分析的 Datalog 图
图12-30练习12.6.1 和练习
void p(）{
：
r(T z) {
q(T x, T y){
12.6.2的代码
CSinvokes(S,C, M, D) &
hpts(G,F,H)
pts(W, C,G) &
"V.F = W" g
"H : T V =new T() &
actuat
= W.F" &
J：
1
h:
return z;
 return d;
Td
d= q(x,d);
&
8
第12章
I
q(d,y);
 new T();
的
这
---
## Page 617
到标号为x;的子结点的边就意味着i<j。我们将看到，操作排序 BDD 相对容易，并且从现在开
虽然这并不是一个绝对的要求，但把我们的讨论范围限制在排序 BDD 之内会带来方便。在一个
数的简洁表示方法的理由之一。
结点0。也就是说，我们不仅知道真假赋值0101使得这个函数为假，而且因为不需要查看或者
w=0，我们还是移动到最左边的标号为x的结点。但这一次因为x=1，我们沿着高边直接跳到叶子
最左的标号为的结点。现在，因为z=1，我们将选择高边并最后到达标号为1的叶子结点。我
x=0，我们还是从这个结点沿着低边到达最左的标号为的结点。因为y=0，我们下一步移动到
比如说标号为×的结点上，分别根据x的真假值为0或1来决定沿着相应的低边或高边前进。如
变量取值为0 时的情况，而高边对应于相应变量取值为1时的情况。
内部结点有两条指向子结点的边，这两条边分别称为“低边”和“高边”。低边对应于该结点对应
表示函数的－个变量作为标号。在图的底部是两个叶子，一个标号为0，另一个标号为1。每个
alog 程序时需要进行某些运算。我们也指出了如何操作 BDD 来完成这些运算。最后，我们描述了如
理系统是为了在典型商业数据中出现的更加不规则的数据模式而设计的。
BDD。值得--提的是，它比使用传统数据库管理系统的方法具有更好的性能，因为传统数据库管
过商业 BDD 操作程序包中的一些启发式规则或技术才可以找到用以表示程序信息的简洁的
数也不例外，也可以使用 BDD 简洁地表示。BDD 方法在实践中是相当成功的，虽然我们需要
表示的布尔函数。
出现的布尔函数常常具有很多规律。因此，人们常常可以找到一个 BDD 来简洁地表示他们想要
变量有22"个布尔函数，没有哪种表示方法能够很简洁地表示所有的布尔函数。但是，在实践中
12.7使用 BDD 的 Datalog 的实现
的值，任何形如0lyz的真假赋值都会使得这个函数取值为0。这个“短路”能力是BDD 成为布尔函
们的结论是，这个函数相对于这个真假赋值取真值。
=0，=1。从根结点开始，因为w=0，我们选取低边，从而走到最左的标号为x的结点。因为
例12.27
12.7.1二分决策图
何在 BDD 中表示指数量级的上下文。这种表示法是在上下文相关性分析中成功应用 BDD 的关键。
表示方法。然后，指出如何把--个关系数据表示成为 BDD。在用诸如算法12.18 的算法来执行 Dat-
把所有的“低"边标记为0，所有的“高"边标记为1。考虑对于变量 wxyz的真假赋值：w=x=
过程间分析
现在考虑真假赋值 uwxyz=0101，也就是说w==0，=z=1。我们还是从根结点开始。因为
我们最后到达标号为1的叶结点，那么被表示的函数对于这个真假赋值取真值，否则该函数取
给定这些变量的一个真假赋值，我们可以从 DAG的根开始确定函数的取值。在每个结点上
讨论经过多年开发才得到的所有 BDD 技术已经超出了本书的范围。我们将在这里介绍 BDD 的
我们为了分析程序而开发了--些 Datalog 程序。事实表明，用这些 Datalog 程序描述的布尔函
 图12-31中内部结点分为多个层次—每个层中的结点都使用同一个特定的变量作为标号
一个 BDD 把一个布尔函数表示成为－个带根的 DAG 图。这个 DAG 的每个内部结点都用被
二分决策图（Binary Decision Diagram，BDD)是一-个用图来表示布尔函数的方法。因为对 n 个
！练习12.6.3：按照 12.5节中的方法，扩展本节中的 Datalog 规则，使之包含类型和子类型信息。
！练习12.6.2：对图12-30中的代码进行上下文相关性分析。
在图12-31中，我们看到一个 BDD。稍后会看到它所表示的函数。请注意，我们已
601
---
## Page 618
图12-32给出了这两个转换的图示。
的结点。但是请注意，新结点的标记变量必须是按照排序处于 N和 M 之间的某一个变量。
点。从引人结点流出的高边和低边都到达结点 M，而原来从 N 到 M 的边现在到达这个刚被引人
一个结点，那么我们可以把N和 M 合并。原来进人 N或者 M的边都进人合并后的结点。
进人 N的边直接进入 M。
12.7.2对BDD的转换
结点。把得到同样结果的多个结点合并起来也是BDD 通常比较简洁的理由之一。