IACR
Cryptology ePrint Archive 2014 (2014).
[36] Ducas, L., Durmus, A., Lepoint, T., and Lyubashevsky, V. Lattice signatures
and bimodal gaussians. In CRYPTO (2013).
[37] Ezerman, M. F., Lee, H. T., Ling, S., Nguyen, K., and Wang, H. A provably
secure group signature scheme from code-based assumptions. In Advances in
Cryptology - ASIACRYPT (2015), pp. 260–285.
[38] Faugère, J., Gauthier-Umaña, V., Otmani, A., Perret, L., and Tillich, J. A
IEEE Trans. Information
distinguisher for high-rate mceliece cryptosystems.
Theory 59, 10 (2013), 6830–6844.
[39] Feo, L. D., Jao, D., and Plût, J. Towards quantum-resistant cryptosystems from
supersingular elliptic curve isogenies. J. Mathematical Cryptology 8, 3 (2014),
209–247.
[40] Fiat, A., and Shamir, A. How to prove yourself: Practical solutions to identifi-
cation and signature problems. In CRYPTO (1986), pp. 186–194.
[41] Galbraith, S. D., Petit, C., and Silva, J. Signature schemes based on supersin-
gular isogeny problems. IACR Cryptology ePrint Archive 2016 (2016), 1154.
[42] Gennaro, R., Gentry, C., Parno, B., and Raykova, M. Quadratic span programs
and succinct nizks without pcps. In EUROCRYPT (2013).
[43] Gentry, C., Peikert, C., and Vaikuntanathan, V. Trapdoors for hard lattices
and new cryptographic constructions. In STOC (2008).
boolean circuits. In USENIX Security (2016).
[45] Giacomelli, I., Madsen, J., and Orlandi, C. ZKBoo: Faster zero-knowledge
for boolean circuits. Cryptology ePrint Archive, Report 2016/163, 2016. http:
//eprint.iacr.org/2016/163.
[46] Goldfeder, S., Chase, M., and Zaverucha, G. Efficient post-quantum zero-
knowledge and signatures. Cryptology ePrint Archive, Report 2016/1110, 2016.
http://eprint.iacr.org/2016/1110.
[47] Goldreich, O. Two remarks concerning the goldwasser-micali-rivest signature
scheme. In CRYPTO (1986).
[48] Goldreich, O., Micali, S., and Wigderson, A. How to prove all np-statements
in zero-knowledge, and a methodology of cryptographic protocol design. In
CRYPTO (1986).
[49] Goldwasser, S., Micali, S., and Rackoff, C. The knowledge complexity of
interactive proof-systems (extended abstract). In STOC (1985).
[50] Grosso, V., Leurent, G., Standaert, F., and Varici, K. Ls-designs: Bitslice
encryption for efficient masked software implementations. In FSE (2014).
[51] Groth, J., and Sahai, A. Efficient Non-interactive Proof Systems for Bilinear
Groups. In EUROCRYPT (2008).
[52] Grover, L. K. A fast quantum mechanical algorithm for database search. In
STOC (1996).
[44] Giacomelli, I., Madsen, J., and Orlandi, C. ZKBoo: Faster zero-knowledge for
(1991).
[53] Güneysu, T., Lyubashevsky, V., and Pöppelmann, T. Practical lattice-based
cryptography: A signature scheme for embedded systems. In CHES (2012).
[54] Hellman, M. A cryptanalytic time-memory trade-off.
IEEE transactions on
Information Theory 26, 4 (1980), 401–406.
[55] Hu, Z., Mohassel, P., and Rosulek, M. Efficient zero-knowledge proofs of
non-algebraic statements with sublinear amortized cost. In CRYPTO (2015).
[56] Hülsing, A., Rijneveld, J., Samardjiska, S., and Schwabe, P. From 5-pass
mq-based identification to mq-based signatures. In Cryptology ePrint Archive,
Report 2016/708, to appear in Asiacrypt 2016 (2016).
Ishai, Y., Kushilevitz, E., Ostrovsky, R., and Sahai, A. Zero-knowledge proofs
from secure multiparty computation. SIAM Journal on Computing 39, 3 (2009),
1121–1152.
Jawurek, M., Kerschbaum, F., and Orlandi, C. Zero-knowledge using garbled
circuits: how to prove non-algebraic statements efficiently. In ACM CCS (2013).
[59] Kaplan, M., Leurent, G., Leverrier, A., and Naya-Plasencia, M. Quantum
[58]
[57]
Differential and Linear Cryptanalysis. ArXiv e-prints (Oct. 2015).
[60] Kaplan, M., Leurent, G., Leverrier, A., and Naya-Plasencia, M. Breaking
symmetric cryptosystems using quantum period finding. In CRYPTO (2016).
[61] Katz, J. Digital Signatures. Springer, 2010.
[62] Kiltz, E., Masny, D., and Pan, J. Optimal security proofs for signatures from
identification schemes. In CRYPTO (2016).
[63] Lamport, L. Constructing digital signatures from one-way functions. Tech. Rep.
SRI-CSL-98, SRI Intl. Computer Science Laboratory, 1979.
[64] Landais, G., and Sendrier, N. Cfs software implementation. Cryptology ePrint
Archive, Report 2012/132, 2012.
[65] Lyubashevsky, V. Fiat-shamir with aborts: Applications to lattice and factoring-
based signatures. In ASIACRYPT (2009).
[66] Lyubashevsky, V. Lattice signatures without trapdoors. In EUROCRYPT (2012).
[67] McEliece, R. J. A public-key cryptosystem based on algebraic coding theory.
Tech. Rep. DSN PR 42-44, 1978.
[68] McGrew, D. A., Kampanakis, P., Fluhrer, S. R., Gazdag, S., Butin, D., and
In Security
Buchmann, J. A. State management for hash-based signatures.
Standardisation Research (2016).
[69] Méaux, P., Journault, A., Standaert, F., and Carlet, C. Towards stream
ciphers for efficient FHE with low-noise ciphertexts. In EUROCRYPT (2016).
[70] Melchor, C. A., Gaborit, P., and Schrek, J. A new zero-knowledge code based
identification scheme with reduced communication. In ITW (2011).
[71] Merkle, R. C. A certified digital signature. In CRYPTO (1989).
[72] Niederreiter, H. Knapsack-type cryptosystems and algebraic coding theory.
Problems of Control and Information Theory (1986).
[73] Ohta, K., and Okamoto, T. On concrete security treatment of signatures derived
from identification. In CRYPTO (1998).
[74] Patarin, J., Courtois, N., and Goubin, L. Quartz, 128-bit long digital signatures.
In CT-RSA (2001).
[75] Peikert, C. A decade of lattice cryptography. Foundations and Trends in Theo-
retical Computer Science 10, 4 (2016).
[76] Petzoldt, A., Chen, M., Yang, B., Tao, C., and Ding, J. Design principles for
hfev- based multivariate signature schemes. In ASIACRYPT (2015).
[77] Pointcheval, D., and Stern, J. Security proofs for signature schemes.
In
EUROCRYPT (1996).
[78] S. Ames, C. Hazay, Y. I., and Venkitasubramaniam, M. Ligero: Lightweight
sublinear arguments without a trusted setup. In Proceedings of the 2017 ACM
SIGSAC Conference on Computer and Communications Security (2017), ACM.
[79] Sakumoto, K., Shirai, T., and Hiwatari, H. Public-key identification schemes
based on multivariate quadratic polynomials. In CRYPTO (2011).
[80] Schnorr, C. Efficient signature generation by smart cards. J. Cryptology 4, 3
[81] Shor, P. W. Polynominal time algorithms for discrete logarithms and factoring
on a quantum computer. In ANTS-I (1994).
[82] Stern, J. A new identification scheme based on syndrome decoding. In CRYPTO
[83] Unruh, D. Quantum proofs of knowledge. In EUROCRYPT 2012 (Apr. 2012),
D. Pointcheval and T. Johansson, Eds., vol. 7237 of LNCS, Springer, Heidelberg,
pp. 135–152.
[84] Unruh, D. Non-interactive zero-knowledge proofs in the quantum random
oracle model. In EUROCRYPT 2015, Part II (Apr. 2015), E. Oswald and M. Fischlin,
Eds., vol. 9057 of LNCS, Springer, Heidelberg, pp. 755–784.
[85] Unruh, D. Computationally binding quantum commitments. In EUROCRYPT
(1993).
(2016).
[86] Véron, P. Improved identification schemes based on error-correcting codes.
Appl. Algebra Eng. Commun. Comput. 8, 1 (1996).
[87] Yoo, Y., Azarderakhsh, R., Jalali, A., Jao, D., and Soukharev, V. A post-
quantum digital signature scheme based on supersingular isogenies. Cryptology
ePrint Archive, Report 2017/186, 2017. http://eprint.iacr.org/2017/186.
13
A ADDITIONAL MATERIAL ON ZKBOO
In Scheme 3 we restate the full ZKBoo protocol.
A.1 (2,3)-Decomposition
(ϕ,x)
We define the experiment EXP
decomp in Scheme 4, which runs the
decomposition over a circuit ϕ on input x: We say that D is a
(2, 3)-decomposition of ϕ if the following two properties hold when
running EXP
(Correctness) For all circuits ϕ, for all inputs x and for the yi’s
produced by , for all circuits ϕ, for all inputs x,
(ϕ,x)
decomp:
Pr[ϕ(x) = Reconstruct(y1, y2, y3)] = 1
(2-Privacy) Let D be correct. Then for all e ∈ {1, 2, 3} there exists
a PPT simulator Se such that for any probabilistic polynomial-time
(PPT) algorithm A, for all circuits ϕ, for all inputs x, and for the
(ϕ,x)
decomp we have that
distribution of views and ki’s produced by EXP
(cid:12)(cid:12) Pr[A(x, y, ke , Viewe , ke +1, Viewe +1, ye +2) = 1]−Pr[A(x, y,Se(ϕ,
y)) = 1](cid:12)(cid:12) is negligible.
A.2 Linear Decomposition of a Circuit
ZKBoo uses an explicit (2,3)-decomposition, which we recall here.
Let R be an arbitrary finite ring and ϕ a function such that ϕ :
Rm → Rℓ can be expressed by an n-gate arithmetic circuit over the
ring using addition by constant, multiplication by constant, binary
addition and binary multiplication gates. A (2, 3)−decomposition of
ϕ is given by the following functions. In the notation below, arith-
metic operations are done in Rs where the operands are elements
of Rs):
(n)
i
x3 ∈ Rm such that x1 + x2 + x3 = x.
(n)
circuit as stored in the view view
i
• (x1, x2, x3) ← Share(x, k1, k2, k3) samples random x1, x2,
• yi ← Outputi(view
) selects the ℓ output wires of the
• y ← Reconstruct(y1, y2, y3) = y1 + y2 + y3
• view
.
(j)
i +1, ki , ki +1) computes
Pi’s view of the output wire of gate дj and appends it to the
view. Notice that it takes as input the views and random
tapes of both party Pi as well as party Pi +1. We use wk to
(i)
refer to the k-th wire, and we use w
k to refer to the value
of wk in party Pi’s view. The update operation depends on
the type of gate дj.
(j+1)
i ← Update
(j)
(view
i
, view
(j)
i
The gate-specific operations are defined as follows.
(cid:40)
Addition by Constant (wb = wa + k).
if i = 1,
otherwise.
Multiplication by Constant (wb = wa · k).
(i)
a + k
(i)
a
(i)
b
w
w
w
=
w
(i)
b
= k · w
(i)
a
Binary Addition (wc = wa + wb).
(i)
b
(i)
c = w
(i)
a + w
w
Blocksize
n
256
256
256
S-boxes
m
1
10
42
Keysize
k
256
256
256
Rounds
r
316
38
14
Table 2: A range of different parameter sets for LowMC. All
parameters are computed for data complexity d = 1
Binary Multiplication (wc = wa · wb).
(i +1)
· w
a
(i)
c = w
w
(i)
a
(i)
a
w
· w
· w
(i)
b
(i +1)
b
(i)
b
+
+ w
+ Ri(c) − Ri +1(c),
where Ri(c) is the c-th output of a pseudorandom generator
seeded with ki.
Note that with the exception of the constant addition gate, the gates
are symmetric for all players. Also note that Pi can compute all gate
types locally with the exception of binary multiplication gates as
this requires inputs from Pi +1. In other words, for every operation
except binary multiplication, the Update function does not use the
inputs from the second party, i.e., view
(j)
i +1 and ki +1.
While we do not give the details here, [45] shows that this de-
composition meets the correctness and 2-privacy requirements of
Definition 3.1.
B DESCRIPTION OF LOWMC
LowMC by Albrecht et al. [4, 6] is very parameterizable symmetric
encryption scheme design enabling instantiation with low AND
depth and low multiplicative complexity. Given any blocksize, a
choice for the number of S-boxes per round, and security expecta-
tions in terms of time and data complexity, instantiations can be
created minimizing the AND depth, the number of ANDs, or the
number of ANDs per encrypted bit. Table 2 lists the choices for the
parameters which are also highlighted in the figures.
The description of LowMC is possible independently of the
choice of parameters using a partial specification of the S-box and
arithmetic in vector spaces over F2. In particular, let n be the block-
size, m be the number of S-boxes, k the key size, and r the number
of rounds, we choose round constants Ci ←R Fn
2 for i ∈ [1, r], full
rank matrices Ki ←R Fn×k
indepen-
dently during the instance generation and keep them fixed. Keys for
LowMC are generated by sampling from Fk
2 uniformly at random.
LowMC encryption starts with key whitening which is followed
by several rounds of encryption. A single round of LowMC is com-
posed of an S-box layer, a linear layer, addition with constants and
addition of the round key, i.e.
and regular matrices Li ←R Fn×n
2
2
LowMCRound(i) = KeyAddition(i)
◦ ConstantAddition(i)
◦ LinearLayer(i) ◦ SboxLayer.
SboxLayer is an m-fold parallel application of the same 3-bit
S-box on the first 3 · m bits of the state. The S-box is defined as
S(a, b, c) = (a ⊕ bc, a ⊕ b ⊕ ac, a ⊕ b ⊕ c ⊕ ab).
The other layers only consist of F2-vector space arithmetic.
LinearLayer(i) multiplies the state with the linear layer matrix Li,
ConstantAdditon(i) adds the round constant Ci to the state, and
14
output share y
(i)
j
Commit [C
(i)