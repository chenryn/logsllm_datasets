000000000000000000000000000363626262535353535353526262626543535353544444444445353535307000000000000
000000000000000000000000000024535353535353535353535444444414435444435353535353535353527000000000715
000000000000000000000000000026353535353535353535353535353563535353535353535353535353535107000000000
000000000000000000000000000025435444444444444444444444444404444444444444444444444444430000007170160
000000000000000000000000000104535353535353535353535444444433535353535353544354444444417000000000076
000000000000000017000100000026353535353535353535353535353673535353535353535353535444436000000000070
000000000000000000000000000114535353535353535444444444444433535353535353535444444444427000000000030
000000000000000000000100071272626262626262626262626262626433535353544444444444444444407000000000040
000000000000000010000000000272626262626262626262626262626635353535353535353535353535370000000000070
000000000000000000000000000015444444444444444444444444444424444444444444444444444444432000000000010
000000000000000000107010070203626262626262626263535353544433535353535353535353535353517000000000060
000000000000000000000000000103626262626262535354444444444524444444444444444444444444407000000007111
000000000000000000000000100013617265353535353526262626262602626262626253535353535353526000000000002
000000000000000000001000000111717007171626262626262626262673625353535353535353535353527700000000005
Section 1-3 Symbols
• Section 1: 21 x 99 symbols 
• Timing?
• Section 2: 2 copies of 44 symbols 
• Preamble!
• Section 3: 4 x 56 symbols 
• Timing?
44404040246000006420004000000000210000000005
44404040246000006420004000000000210000700000
4000000000000000300000000000
2100000000000000300000000000
1100000000000000300000000000
02000000000000002100000000000
Section 4 Symbols
• Section 4: 271 copies of 110 symbols
• Not all identical copies dues to noise
• Wrote a Python tool to count packet variations
• Outputs 1 copy of the most common packet in this section
00735350305015510000552000442775576644063173443234570742120043137542513031530202076616413144077352775447244044
51714440404024600000642000442774675644063173443233670732120043137542513031530202076616413144077352775447244044
61704440404024600000642000442774675644063173443233670732120043137542513031530202076616413144077352775447244044
50724440404024600000642000442774675644063173443233670732120043137542513031530202076616413144077352775447244044
62004440404024600000642000442774675644063173443233670732120043137542513031530202076616413144077352775447244044
50724440404024600000642000442774675644063173443233670732120043137542513031530202076616413144077352775447244044
61704440404024600000642000442774675644063173443233670732120043137542513031530202076616413144077352775447244044
50014440404024600000642000442774675644063173443233670732120043137542513031530202076616413144077352775447244044
61704440404024600000642000442774675644063173443233670732120043137542513031530202076616413144077352775447244044
50724440404024600000642000442774675644063173443233670732120043137542513031530202076616413144077352775447244044
51004440404024600000642000442774675644063173443233670732120043137542513031530202076616413144077352775447244044
50104440404024600000642000442774675644063173443233670732120043137542513031530202076616413144077352775447244044
Preambles
• 20 fixed symbols, then 12 that form 1 of 3 patterns
• Section 2: alternates randomly between 2 sequences 
• 4440 4040 2460 0000 6420 0040 0000 0000
• 4440 4040 2460 0000 6420 0042 3133 4224
• Section 4: All 271 copies start (after null junk) with:
• 4440 4040 2460 0000 6420 0044 2774 6756
Structure of Section 4 Data Symbols
Header:
• 4 bytes null/primer
• Preamble 8x4 symbols
• 20 fixed, 12 variable
Counter
Size
8 Bytes of User Data
Unused Data
4277235742232167  0732  12004313754251303153020207661641  31440773527
Packet Data
Null Preamble
Packet Data
Checksum
5001 44404040246000006420004427746756 4406317344323367073212004313754251303153020207661641314407735277 5447244044
Packet Data 16x4 symbols:
• 16 symbol counter
• Changes every burst, seems to increment
• 4 symbols for user data size
• Learned this by modifying badge firmware
• 44 symbols for 11 bytes of user data
• 12 symbols/3 bytes unused by badge
Packet Footer
• 10 symbols
Finding the Mask Symbols for Data 5-11
• So now we have a stream of differential symbols, do we have data?
• Not even close
• Every symbol after the preamble* are masked.
• Setting the badge to transmit 8 bytes of 0x00 confirmed this
• This gave me 32 symbols of the mask
• Modified badge firmware to send 11 bytes of 0x00
• That gives us the mask for those 11 user bytes (packet data bytes 5 though 15):
5 4 3 5 7 0 3 6 4 0 7 3 0 4 1 4 4 2 7 4 6 2 0 2 0 7 6 6 1 6 4 1 5 2 3 4 4 7 5 1 1 2 5 5
• I don’t see a pattern.
* and maybe the last 12 symbols of the preamble are masked, too.
Finding the Mask Symbols for Data 0-4
• The symbols changed with every burst -- alternated between changing 1 
symbol and (usually) 7 
• Every 8 packets: 8 symbols changed. Every 32: 9 changed. Every 128: 10 changed
• Conclusion: it’s a counter, 2 bits per symbol, with convolution on half(?!) of the bits
• After some reboots, the first symbol alternated between 0 and 4, on others 
between 2 and 6
• Every other location could be any symbol 0-7
• The first group of 4 symbols had 128 patterns, the next group of 4 had 256 patterns
• Conclusion: the counter increments by 2, and sometimes starts odd, sometimes even
• I didn’t know which was odd or even, so I guessed 0/4 was even. I guessed… poorly.
• Tail of 6 changed symbols obfuscates other symbols
• Even if I assume byte3 == 0 and know byte 4, I can only compute the last 2 of 8 symbols
0000 1111 2222 XXXX XX44
Finding Mask Symbols for Data 0-4
• I Recorded the counter for a week, observed transitions
• This gave me a mask for the first 10 symbols
• Confirmed the count doesn’t start at zero
• Took 19.1 hours to get 9th symbol, 76.5 hours get 10th
• At this rate it will take 51 days for 12 symbols
• 36 years for 16
• 9139 years for 20
• Didn’t understand well enough to brute force them
• Needed a smarter method
4 2 1 0  7 0 6 1  3 2 2 3  4 4 7 6  6 3 3 2
Last symbol to increment 
plus its tail of 6 changes
Confirmed mask
1M
256k
64k
16k
4k
1k
256
64
16
4
.
.
.
.
.
.
2
Last changed symbol indicates:
Finding the Mask Symbols for Data 0-4
• Then I got lucky by getting unlucky – I broke a badge
• Badge became very angry
• Instead of 271 x 110 symbol packets, it transmitted a pattern of 
108-symbols followed by 108 nulls
• Counter moved over 16 symbols!?!
• Transmitted around 1.4 MHz?
• Conclusions:
• Mask is 4210 7061 3242 2275 0332
• Assuming my 0/1 guess was right…
• It’s better to be lucky than smart
Finishing up the Data Mask
• Discovered counter moves at ludicrous speed when updating Tx packet
• That’s why counter starts at 346,637
• Wrote a script to update the Tx packet repeatedly then capture packets
• Got mask and proved counter is 4 bytes
• In case you want to send 2 billion packets over 41 years
• Data mask resulted in some erratic values when decoding sequential 
counts
• Wrong guess about what 1 and 0 
• The broken badge locked the first (unused!) byte at 1 just to screw with me?
• Mask for 1: 4210 7061 3242 2275 0332
• Mask for 0: 2336 7701 3203 2275 0332
Checksum Mask
• That left only the mask for the Checksum/CRC
• No way to get that until I know the algorithm and all data values
• To get the values I had to understand the convolution
• So I guessed and moved on
• As the counter increments, it either changes:
• 1 symbol for odd bits
• 6 of the next 7 symbols for even bits
• This means a 1-bit change is being spread out over 7 symbols
• They are using convolution, possibly like the one used on the 
Voyager space probe
• Voyager shift registers[1]:
• 1111001
• 1011011
• But only for half of the bits…?!?
[1] https://en.wikipedia.org/wiki/Convolutional_code
Counter Indicates Values are Convolved
Counter
427723574223
027723574223
446543654223
046543654223
467723574223
067723574223
406543654223
006543654223
421413701423 
021413701423
444233061423
044233061423
Reverse Engineering Convolution Code
• Started by changing 1 bit at a time
• Any 1 odd bit always changed 1 symbol, and always by 4
• Any 1 even bit changed 6 of the next 7 symbols
• Amount of change depended on mask and distance from the 
set bit
• Even bit change (show in code and mask-bit logic)
• Symbol positions 0, 2, 3, 6: mask in [1,2,5,6]) * 4 + 2; 
• [bit0^bit1, 1, 0]
• Symbol position 1: (mask mod 4) * 2 + 3 
• [bit0^bit1, ~bit0, 1]
• Symbol position 5: mask in [1,3,5,7]) * 6 + 1
• [bit0, bit0, 1]
0 1 2 3 4 5 6
0 2 3 2 2 0 1 2
1 6 5 6 6 0 7 6
2 6 7 6 6 0 1 6
3 2 1 2 2 0 7 2
4 2 3 2 2 0 1 2
5 6 5 6 6 0 7 6
6 6 7 6 6 0 1 6
7 2 1 2 2 0 7 2
Symbol position after even bit
Mask (or previous)
Reversing Convolution Code, Multiple Bits
• That math worked for decoding 1 even bit set in any position
• But multiple even bits were a mess
• After a lot of ugly math and dead ends, I realized the math that 
worked for a mask worked for any precious value
Reversing Convolution Code, Even Bits
• We can now convolve (or de-convolve) any number of even bits
0x00    0x00
0x01    0x00
0x05    0x00
Value of each byte:
Even bits of that byte:
Mask of 0:
Convolved value:
All math is
modulo 8
Even bits
Even bits
Even bits
Convoluted Convolution
• Now I could decode the counter and it was sequential… mostly
• Sometimes multiple odd bits convolved
• I looked for patterns, added rules until it worked right
• All the rules don’t care what the current bit is, only look at previous 
bits
• Up to 2 bytes ago!
• Some rules are triggered by 0 bits, not just 1s
• Rules are:
• xxx011x
• xxx101x
• 1xxxx1x
• 11xxxxx
 Time →
Convolution
• Convolution of even bits might be Trellis 
Code Modulation TCM*
• I ended up figuring it out in a spreadsheet and 
writing some ugly python code, but it works
• Easier than deciphering GNURadio documentation
• Convolution of odd bits is… odd
• xxx011x
• xxx101x
• 1xxxx1x
• 11xxxxx
Rate = 2/3, m = 7?
*Can TCM convolve 1 bit into a pattern like 2322012? Is that middle 0 possible?
CRC Reverse Engineering
• Each packet ended with 10 unknown symbols, equivalent of 20 bits
• 220 possible combinations, yet only 212 patterns were common/real
• 12 bits stored in 20 bits?!?
• Changing 1 symbol can alter the next 6, won’t that overwrite the nulls and primer?
• All 10 symbols, “20 bits,” had to be correct
• Altering any in a packet replay attack caused it to be rejected by the NFMI chip
• Must reverse engineer this in order to craft custom packets
• Tried the tool “CRC Reveng” but it didn’t seem to work
• Wrote Python programs to try all possible 12-bit algorithms, didn’t work?!?
CRC Reverse Engineering, Continued
• Observed 1-bit difference in counter resulted in predictable checksum 
change
• Checksum values were built up by XORing values from a table, just like a 
CRC!
• I used counter values to get the CRC table values for the low bits
• Noticed that updating a TX packet would fast-forward the counter by ~300,000 ticks
• Wrote a program to speed the counter through more bits
• Wrote another program to “bit walk” every byte I could control
• Set 1 bit per packet
• Wrote a program to ingest all this data and compute almost the entire CRC table
CRC Reverse Engineering, Continued
• I eyeballed a pattern in the 10 symbols that revealed a how the 12-bit CRC was 