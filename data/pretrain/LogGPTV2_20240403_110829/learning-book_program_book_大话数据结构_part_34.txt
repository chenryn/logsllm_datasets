/·将边表置为空表*/
231
---
## Page 256
大话数据结构
for（k=0;knumEdges;k++）
1·建立边表
1
printf（“输入边（vi，vj）上的顶点序号：\n"）；
scanf（“d，%d"，6i，6j）：/输入边（v，v）上的顶点序号*/
e=（EdgeNode*）malloc（sizeof（EdgeNode））：/*向内存中请空间，*/
/*生成边表结点*/
CmxeACDec-e
部接序号为j*/
e->next=G->adjLiat[i].firstedge:/*将e指针指向当前项点指向的结点*/
G->adjList[i].firstedge=e：/*将当前顶点的指针指向e*/
e=（EdgeNode*）malloc（sizeof（EdgeNode））：/*向内存中请空间，*/
/*生成边表结点*/
e->adjvex=i;
1邻接序号为*/
G->adjList[j].firstedgome：/·将当前顶点的指针指向e*/
1
这里加粗代码，是应用了我们在单链表创建中讲解到的头插法”，由于对于无向
图，一条边对应都是两个顶点，所以在循环中，一次就针对1和1分别进行了插入。
本算法的时间复杂度，对于n个顶点e条边来说，很容易得出是0（n+e)。
7.4.3十字链表
记得看过一个创意，我非常喜欢。说的是在美国，晚上需要保安通过视频监控对
如商场超市、码头仓库、办公写字楼等场所进行安保工作，如图7-4-9所示。值夜班
代价总是比较大的，所以人员成本很高。我们国家的一位老兄在国内经常和美国的朋
友视频聊天，但总为白天黑夜的时差苦恼，突然灵感一来，想到一个绝妙的点子。他
创建一家公司，承接美国客户的视频监控任务，因为美国的黑夜就是中国的白天，利
用互联网，他的员工白天上班就可以监控到美国仓库夜间的实际情况，如果发生了像
火灾、偷盗这样的突发事件，及时电话到美国当地相关人员处理。由于利用了时差和
人员成本的优势，这位老兄发了大财。这个创意让我们知道，充分利用现有的资源，
正向思维、逆向思维、整合思维可以创造更大价值。
注”：详细进解参见本多39节内容：
232
---
## Page 257
第7章图
A
图 7-4-9
那么对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须
要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况。有没有可
能把邻接表与逆邻接表结合起来呢？答案是肯定的，就是把它们整合在一起。这就是
我们现在要讲的有向图的一种存储方法：十字链表（OrthogonalList）。
我们重新定义顶点表结点结构如表7-4-1所示。
表7-4-1
datafirstinfirstout
其中firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout表示
出边表头指针，指向该顶点的出边表中的第一个结点。
重新定义的边表结点结构如表7-4-2所示。
表7-4-2
tailvexheadvexheadlinktaillink
其中tailvex是指弧起点在顶点表的下标，headvex是指弧终点在顶点表中的下
标，headink是指入边表指针域，指向终点相同的下一条边，taillink是指边表指针
域，指向起点相同的下一条边。如果是网，还可以再增加一个weight城来存储权值。
比如图7-4-10，顶点依然是存入一个一维数组（voVV2V3），实线箭头指针的图示
完全与图7-4-7的邻接表相同。就以顶点vo来说，frstout指向的是出边表中的第一
个结点V3。所以vo边表结点的headvex=3，而tailvex其实就是当前顶点vo的下标
0，由于vo只有一个出边顶点，所以headlink和tailink都是空。
233
---
## Page 258
大据数据结构
和当前项点下标相同。
下标 data firstin firstout
0v。
v有两个出边，所以
在v的firstou指向v
后,taillink指问v
V
。
vv
2
V
2
一
④
v
v有两个入边，所以在v的firstin指向v
后v的headink指向v，v后再无v的入
边项点，所以其illnk为空
图7-4-10
我们重点需要来解释虚线箭头的含义，它其实就是此图的逆邻接表的表示。对于
vo来说，它有两个顶点v和v的入边。因此vo的firstin指向顶点v的边表结点中
headvex为0的结点，如图7-4-10右图中的①。接着由入边结点的headlink指向下
一个入边顶点v2，如图中的②。对于顶点v，它有一个入边顶点vz，所以它的frstin
指向顶点v2的边表结点中headvex为1的结点，如图中的③。顶点vz和vs也是同样
有一个入边顶点，如图中④和。
十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以
v为尾的弧，也容易找到以v为头的弧，因而容易求得顶点的出度和入度。面且它除
了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向
图的应用中，十字链表是非常好的数据结构模型。
7.4.4邻接多重表
讲了有向图的优化存储结构，对于无向图的邻接表，有没有问题呢？如果我们在
无向图的应用中，关注的重点是顶点，那么邻接表是不错的选择，但如果我们更关注
边的操作，比如对已访问过的边做标记，删除某一条边等操作，那就意味着，需要找
到这条边的两个边表结点进行操作，这其实还是比较麻烦的。比如图7-4-11，若要删
除左图的（veV2）这条边，需要对邻接表结构中右边表的阴影两个结点进行删除操
作，显然这是比较烦琐的。
234
---
## Page 259
第7章图
下标data f
adjvex next
Vo
V
2
V
0
3V
2
图 7-4-11
因此，我们也仿照十字链表的方式，对边表结点的结构进行一些改造，也许就可
以避免刚才提到的问题。
重新定义的边表结点结构如表7-4-3所示。
表7-4-3
ivexilinkjivexjlink
其中ivex和jvex是与某条边依附的两个顶点在顶点表中下标。ilink指向依附顶
点ivex的下一条边，jlink指向依附顶点jvex的下一条边。这就是邻接多重表结构。
我们来看结构示意图的绘制过程，理解了它是如何连线的，也就理解邻接多重表
构造原理了。如图7-4-12所示，左图告诉我们它有4个顶点和5条边，显然，我们
就应该先将4个顶点和5条边的边表结点画出来。由于是无向图，所以ivex是0、
jvex是1还是反过来都是无所谓的，不过为了绘图方便，都将ivex值设置得与一旁的
顶点下标相同。
下标 data firstedge
ivex ilink jvex jlink
v。
v
2
2V2
23
V2
3v
3
02
图7-4-12
我们开始连线，如图7-4-13。首先连线的①②③④就是将顶点的firstedge指向一
条边，顶点下标要与ivex的值相同，这很好理解。接着，由于顶点vo的（vovi）边的
235
---
## Page 260
大语数据结构
邻边有（vvs）和（veV2）。因此5的连线就是满足指向下一条依附于顶点vo的边
的目标，注意ilink指向的结点的jvex一定要和它本身的ivex的值相同。同样的道
理，连线就是指（vvo）这条边，它是相当于顶点v指向（vv2）边后的下一条。
v2有三条边依附，所以在③之后就有了③。连线的就是顶点v在连线④之后的下
一条边。左图一共有5条边，所以右图有10条连线，完全符合预期。
下标data finstedge
ivex ilink jvex jlink
2
v23
v3
0
Vv
图 7-4-13
到这里，大家应该可以明白，邻接多重表与邻接表的差别，仅仅是在于同一条边
在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。这样对边的操作就方
便多了，若要删除左图的（vV2）这条边，只需要将右图的9的链接指向改为A即
可。由于各种基本操作的实现也和邻接表是相似的，这里我们就不讲解代码了。
7.4.5边集数组
边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信
息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权
（weight）组成，如图7-4-14所示。显然边集数组关注的是边的集合，在边集数组中
要查找一个顶点的度需要扫描整个边数组，效率并不高。因此它更适合对边依次进行
处理的操作，而不适合对顶点相关的操作。关于边集数组的应用我们将在本章7.6.2
节的克鲁斯卡尔（Kruskal）算法中有介绍，这里就不再详述了。
236
---
## Page 261
第7章图
顶点数组：
Vovv2vv
边数组：
begin
end
veight
edges[0]
0
4
edges[1]
1
0
edges[2]
1
2
edges[3]
2
3
5
edges[4]
3
4
edges(5)]
2
0
2
图7-4-14
定义的边数组结构如表7-4-4所示。
表7-4-4
begin
end
weight
其中begin是存储起点下标，end是存储终点下标，weight是存储权值。
7.5图的遍历
我有天早晨准备出门，发现钥匙不见了。昨晚还看到它，所以确定钥匙在家里。
一定是我那三岁不到的儿子拿着玩，不知道丢到哪个椅角晃去了，问他也说不清
楚。我现在必须得找到它，你们说，我应该如何找？介绍我们家的结构，如图7-5-1
所示，是最典型的两室两厅一厨一卫一阳台。
GC-3-A
RKAI 74.07m
GC-4-A
图7-5-1
237
---
## Page 262
大适数据结构
有人说，往小孩子经常玩的地方找找看。0K，我照做了，可惜没找到。然后怎么
办？有人说一间一间找，可怎么个找法？是把一间房间翻个底朝天再找下一间好呢，
还是先每个房间的最常去的位置找一找，然后再一步一步细化到每个房间的角落？
这是一个大家都可能会面临的问题，不找的东西时常见，需要的东西寻不着。找
东西的策略也因人而异。有些人因为找东西没有规划，当一样东西找不到时，往往会
反复地找，甚至某些抽屉找个四五遍，另一些地方却一次也没找过。找东西是没有什
么标准方法的，不过今天我们学过了图的遍历以后，你至少应该在找东西时，更加科
学地规划寻找方案，而不至于手忙脚乱。
图的遍历是和树的遍历类似，我们希望从图中某一顶点出发访遍图中其余顶点，
且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（TraversingGraph）。
树的遍历我们谈到了四种方案，应该说都还好，毕竞根结点只有一个，遍历都是
从它发起，其余所有结点都只有一个双亲。可图就复杂多了，因为它的任一顶点都可
能和其余的所有顶点相邻接，极有可能存在沿着某条路径搜索后，又回到原顶点，面
有些顶点却还没有遍历到的情况。因此我们需要在遍历过程中把访间过的顶点打上标
记，以避免访问多次面不自知。具体办法是设置一个访问数组visited[n]，n是图中顶
点的个数，初值为0，访问过后设置为1。这其实在小说中常常见到，一行人在迷宫
中迷了路，为了避免找寻出路时屡次重复，所以会在路口用小力刻上标记。
对于图的遍历来说，如何避免因回路陷入死循环，就需要科学地设计遍历方案，
通常有两种遍历次序方案：它们是深度优先遍历和广度优先遍历。
7.5.1深度优先遍历
深度优先遍历（Depth_FirstSearch），也有称为深度优先搜索，简称为DFS。它
的具体思想就如同我刚才提到的找钥匙方案，无论从哪一间房间开始都可以，比如主
卧室，然后从房间的一个角开始，将房间内的墙角、床头柜、床上、床下、衣柜里、
衣柜上、前面的电视柜等挨个寻找，做到不放过任何一个死角，所有的抽屉、储藏柜
中全部都找遍，形象比喻就是翻个底朝天，然后再寻找下一间，直到找到为止。
为了更好的理解深度优先遍历，我们来做一个游戏。
假设你需要完成一个任务，要求你在如图7-5-2左图这样的一个迷宫中，从顶点
A开始要走遍所有的图顶点并作上标记，注意不是简单地看着这样的平面图走哦，而
是如同现实般地在只有高墙和通道的迷宫中去完成任务。
238
---
## Page 263