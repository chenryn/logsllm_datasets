        strncpy(t->u.user.name, name, sizeof(t->u.user.name));
        *size += off;
        *dstptr += tsize;
    }
    EXPORT_SYMBOL_GPL(xt_compat_target_from_user);
####  2-2 漏洞触发流程跟踪
**ip_tables模块初始化流程**
：[ip_tables_init()](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1899)
->
[nf_register_sockopt()](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/nf_sockopt.c#L25)
-> struct
[nf_sockopt_ops](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/netfilter.h#L159)
[ipt_sockopts](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1848)
注册`setsockopt`。这样用户调用`setsockopt`时，才能找到对应的处理函数，也即`do_ipt_set_ctl()`。
    static int __init ip_tables_init(void)
    {
        int ret;
        ret = register_pernet_subsys(&ip_tables_net_ops);
        ret = xt_register_targets(ipt_builtin_tg, ARRAY_SIZE(ipt_builtin_tg));
        ret = xt_register_matches(ipt_builtin_mt, ARRAY_SIZE(ipt_builtin_mt));
        /* Register setsockopt */
        ret = nf_register_sockopt(&ipt_sockopts);                // 
[nf_setsockopt()](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/nf_sockopt.c#L92)
->
[do_ipt_set_ctl()](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1621)
->
[compat_do_replace()](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1511)
->
[translate_compat_table()](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1440)
->
[compat_copy_entry_from_user()](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1376)
->
[xt_compat_match_from_user](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/x_tables.c#L731)
&
[xt_compat_target_from_user()](https://elixir.bootlin.com/linux/v5.11.14/source/net/netfilter/x_tables.c#L1114)
总之就是将用户传入的rule规则进行转换存储时，出现堆溢出写0。构造用户参数data，通过控制pad大小，控制溢出字节数。`data->ipt_replace->size
= 0xFB6`，导致分配`sizeof(xt_table_info) + ipt_replace->size` = `0x40+0xfB6` =
`0xff6`的堆块，转换用户传入规则时错误对齐，刚好溢出覆盖下一个0x1000堆块的前2 字节，造成指针的指向错误。
**用户参数** ：综上，用户传入的参数结构为
[ipt_replace](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter_ipv4/ip_tables.h#L179)
\+
[ipt_entry](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter_ipv4/ip_tables.h#L106)
\+
[xt_entry_match](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L11)
\+ pad +
[xt_entry_target](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L34)。注意，
[compat_ipt_replace](https://elixir.bootlin.com/linux/v5.11.14/source/net/ipv4/netfilter/ip_tables.c#L1203)
等同于
[ipt_replace](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter_ipv4/ip_tables.h#L179)
结构。
    // do_ipt_set_ctl()
    static int do_ipt_set_ctl(struct sock *sk, int cmd, sockptr_t arg, unsigned int len)
    {
        int ret;
        if (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))            // [1] 需满足 CAP_NET_ADMIN 权限，可以在启动脚本赋予exp权限，或者支持namespace就行
            return -EPERM;
        switch (cmd) {
        case IPT_SO_SET_REPLACE:
    #ifdef CONFIG_COMPAT                                                // 编译内核时需设置 CONFIG_COMPAT
            if (in_compat_syscall())
                ret = compat_do_replace(sock_net(sk), arg, len);        // [2] = INT_MAX / sizeof(struct xt_counters))
            return -ENOMEM;
        if (tmp.num_counters == 0)
            return -EINVAL;
        tmp.name[sizeof(tmp.name)-1] = 0;
        newinfo = xt_alloc_table_info(tmp.size);                        // [4] 分配空间 kvmalloc(sz, GFP_KERNEL_ACCOUNT);    sz = sizeof(xt_table_info) + ipt_replace->size = 0x40 + (0xFB8 - 0x2) = 0xFF8 - 0x2  注意两点，一是分配采用 GFP_KERNEL_ACCOUNT 标志（与GFP_KERNEL相同，除了分配记入kmemcg），二是分配的堆块属于0x1000。  分配之后赋值 xt_table_info->size = ipt_replace->size = 0xFB6
        if (!newinfo)
            return -ENOMEM;
        loc_cpu_entry = newinfo->entries;
        if (copy_from_sockptr_offset(loc_cpu_entry, arg, sizeof(tmp),    // [5] 拷贝用户参数， 从偏移arg+sizeof(ipt_replace) 开始拷贝，跳过 ipt_replace 结构
                tmp.size) != 0) {
            ret = -EFAULT;
            goto free_newinfo;
        }
        ret = translate_compat_table(net, &newinfo, &loc_cpu_entry, &tmp); // [6] size;
        info->number = compatr->num_entries;        // 传入的是1
        ... ...
        newinfo = xt_alloc_table_info(size);                            // [7] 分配新的 xt_table_info 结构 —— newinfo
        if (!newinfo)
            goto out_unlock;
        newinfo->number = compatr->num_entries;
        for (i = 0; i hook_entry[i] = compatr->hook_entry[i];
            newinfo->underflow[i] = compatr->underflow[i];
        }
        entry1 = newinfo->entries;                    // 
        pos = entry1;
        size = compatr->size;                        // size = 0xFB8 - 0x2 = 0xfb6
        xt_entry_foreach(iter0, entry0, compatr->size)
            compat_copy_entry_from_user(iter0, &pos, &size,                // [8] counters, &e->counters, sizeof(e->counters));        //     包和字节计数
        *dstptr += sizeof(struct ipt_entry);
        *size += sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
        xt_ematch_foreach(ematch, e)
            xt_compat_match_from_user(ematch, dstptr, size);            // [10] 再拷贝 xt_entry_match 结构, off=4, pad=4, msize=u.user.match_size+off=0xf26+4=0xf2a（用户传入的）, match->matchsize=4, 拷贝完成后*dstptr+= msize = 0xffff888006e010b0+0xf2a = FFFF888006E01FDA, size+=off = 0xfba
        de->target_offset = e->target_offset - (origsize - *size);        // target_offset 原来是 ipt_entry + matches 结构的大小，现在减小了 4
        t = compat_ipt_get_target(e);
        xt_compat_target_from_user(t, dstptr, size);                    // [11] next_offset = e->next_offset - (origsize - *size);
        ... ...
    }
    // [11] xt_compat_target_from_user() —— 拷贝 xt_entry_target 结构，对齐导致溢出
    void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
                    unsigned int *size)
    {
        const struct xt_target *target = t->u.kernel.target;
        struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
        int pad, off = xt_compat_target_offset(target);            // off = target->targetsize = 4
        u_int16_t tsize = ct->u.user.target_size;                // tsize = 0x20
        char name[sizeof(t->u.user.name)];
        t = *dstptr;                                            // t = 0xffff888006e01fda
        memcpy(t, ct, sizeof(*ct));                                // 拷贝0x20
        if (target->compat_from_user)
            target->compat_from_user(t->data, ct->data);
        else
            memcpy(t->data, ct->data, tsize - sizeof(*ct));
        pad = XT_ALIGN(target->targetsize) - target->targetsize;// pad = 4
        if (pad > 0)
            memset(t->data + target->targetsize, 0, pad);        // [12] t+0x20+4 处填充pad个0，也就是 0xffff888006e01ffe处填4个0，溢出2个字节, u.user.target_size = tsize;                            // 
        strlcpy(name, target->name, sizeof(name));
        module_put(target->me);
        strncpy(t->u.user.name, name, sizeof(t->u.user.name));
        *size += off;                                            // *size= 0xfba+4 = 0xfbe
        *dstptr += tsize;                                        // *dstptr = 0xffff888006e01ffe
    }
    EXPORT_SYMBOL_GPL(xt_compat_target_from_user);
**漏洞对象**
：[xt_table_info](https://elixir.bootlin.com/linux/v5.11.14/source/include/linux/netfilter/x_tables.h#L248)
变长结构，`entries`为用户传入，每个`entries` 包含
[ipt_entry](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter_ipv4/ip_tables.h#L106)
\+
[xt_entry_match](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L11)
\+ pad +
[xt_entry_target](https://elixir.bootlin.com/linux/v5.11.14/source/include/uapi/linux/netfilter/x_tables.h#L34)，第一节中已经介绍过。
    struct xt_table_info {
        unsigned int size;            // entries 总大小, 不包括 xt_table_info 结构大小0x40
        unsigned int number;        // entries 数目
        unsigned int initial_entries;
        unsigned int hook_entry[NF_INET_NUMHOOKS];
        unsigned int underflow[NF_INET_NUMHOOKS];
        unsigned int stacksize;
        void ***jumpstack;
        unsigned char entries[] __aligned(8);    // 每个`entries` 包含 `ipt_entry` + `xt_entry_match` + pad + `xt_entry_target`
    };