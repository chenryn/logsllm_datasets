## **一、XXE 是什么**
介绍 XXE 之前，我先来说一下普通的 XML 注入，这个的利用面比较狭窄，如果有的话应该也是逻辑漏洞
**如图所示：**
既然能插入 XML 代码，那我们肯定不能善罢甘休，我们需要更多，于是出现了 XXE
XXE(XML External Entity Injection) 全称为 XML
外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是什么？XML外部实体。(看到这里肯定有人要说：你这不是在废话)，固然，其实我这里废话只是想强调我们的利用点是
**外部实体** ，也是提醒读者将注意力集中于外部实体中，而不要被 XML 中其他的一些名字相似的东西扰乱了思维( **盯好外部实体就行了**
)，如果能注入 外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面（这可能就是为什么单独说 而没有说 XML 注入的原因吧，或许普通的
XML 注入真的太鸡肋了，现实中几乎用不到）
## **二、简单介绍一下背景知识：**
XML是一种非常流行的标记语言，在1990年代后期首次标准化，并被无数的软件项目所采用。它用于配置文件，文档格式（如OOXML，ODF，PDF，RSS，...），图像格式（SVG，EXIF标题）和网络协议（WebDAV，CalDAV，XMLRPC，SOAP，XMPP，SAML，
XACML，...），他应用的如此的普遍以至于他出现的任何问题都会带来灾难性的结果。
在解析外部实体的过程中，XML解析器可以根据URL中指定的方案（协议）来查询各种网络协议和服务（DNS，FTP，HTTP，SMB等）。
外部实体对于在文档中创建动态引用非常有用，这样对引用资源所做的任何更改都会在文档中自动更新。 但是，在处理外部实体时，可以针对应用程序启动许多攻击。
这些攻击包括泄露本地系统文件，这些文件可能包含密码和私人用户数据等敏感数据，或利用各种方案的网络访问功能来操纵内部应用程序。
通过将这些攻击与其他实现缺陷相结合，这些攻击的范围可以扩展到客户端内存损坏，任意代码执行，甚至服务中断，具体取决于这些攻击的上下文。
## **三、基础知识**
XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的，他就是长得下面这个样子
**示例代码：**
    //这一行是 XML 文档定义
上面这个 DTD 就定义了 XML 的根元素是 message，然后跟元素下面有一些子元素，那么 XML 到时候必须像下面这么写
**示例代码：**
    Myself
    Someone
    TheReminder
    This is an amazing book
其实除了在 DTD 中定义元素（其实就是对应 XML 中的标签）以外，我们还能在 DTD 中定义实体(对应XML 标签中的内容)，毕竟 ML
中除了能标签以外，还需要有些内容是固定的
**示例代码：**
    ]>
这里 定义元素为 ANY 说明接受任何元素，但是定义了一个 xml
的实体（这是我们在这篇文章中第一次看到实体的真面目，实体其实可以看成一个变量，到时候我们可以在 XML 中通过 & 符号进行引用），那么 XML
就可以写成这样
**示例代码：**
    &xxe;
    mypass
我们使用 &xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 &xxe 就会被 "test" 替换。
### **重点来了：**
**重点一：**
实体分为两种，内部实体和 **外部实体** ，上面我们举的例子就是内部实体，但是实体实际上可以从外部的 dtd 文件中引用，我们看下面的代码：
**示例代码：**
    ]>
        &xxe;
        mypass
这样对引用资源所做的任何更改都会在文档中自动更新,非常方便（ **方便永远是安全的敌人** ）
当然，还有一种引用方式是使用 引用 **公用 DTD** 的方法，语法如下：
这个在我们的攻击中也可以起到和 SYSTEM 一样的作用
**重点二：**
我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体），别晕。。
**1.通用实体**
用 &实体名; 引用的实体，他在DTD 中定义，在 XML 文档中引用
**示例代码：**
     ]> 
        Joe  
        &file;  
        ... 
**2.参数实体：**
(1)使用 `% 实体名`( **这里面空格不能少** ) 在 DTD 中定义，并且 **只能在 DTD 中使用`%实体名;` 引用**  
(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体  
(3)和通用实体一样，参数实体也可以外部引用
**示例代码：**
    "> 
    %an-element; %remote-dtd;
**抛转：**
参数实体在我们 Blind XXE 中起到了至关重要的作用
## **四、我们能做什么**
上一节疯狂暗示了 **外部实体** ，那他究竟能干什么？
实际上，当你看到下面这段代码的时候，有一点安全意识的小伙伴应该隐隐约约能觉察出什么
    ]>
    &xxe;
    mypass
既然能读 dtd 那我们是不是能将路径换一换，换成敏感文件的路径，然后把敏感文件读出来？
### **实验一：有回显读本地敏感文件(Normal XXE)**
这个实验的攻击场景模拟的是在服务能接收并解析 XML 格式的输入并且有回显的时候，我们就能输入我们自定义的 XML
代码，通过引用外部实体的方法，引用服务器上面的文件
本地服务器上放上解析 XML 的 php 代码：
**示例代码：**
**xml.php**
    loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); 
        $creds = simplexml_import_dom($dom);
        echo $creds;
    ?>
**payload:**
     ]> 
    &goodies;
**结果如下图：**
但是因为这个文件没有什么特殊符号，于是我们读取的时候可以说是相当的顺利， **那么我么要是换成下面这个文件呢？**
**如图所示：**
我们试一下：
**结果如下图：**
可以看到，不但没有读到我们想要的文件，而且还给我们报了一堆错，怎么办？这个时候就要祭出我们的另一个神器了------CDATA
，简单的介绍如下(引用自我的一片介绍 XML 的博客)：
> 有些内容可能 **不想让解析引擎解析** 执行，而是当做原始的内容处理，用于把整段数据解析为纯字符数据而不是标记的情况包含大量的 <> & 或者  
>  " 字符，CDATA节中的所有字符都会被当做元素字符数据的常量部分，而不是 xml标记
>  
>  
>     
>  
>  XXXXXXXXXXXXXXXXX  
>  
>  ]]>
>
> 可以输入任意字符除了 ]]> 不能嵌套
>
> 用处是万一某个标签内容包含特殊字符或者不确定字符，我们可以用 CDATA包起来
那我们把我们的读出来的数据放在 CDATA 中输出就能进行绕过，但是怎么做到，我们来简答的分析一下：
首先，找到问题出现的地方，问题出现在
    ...
     ]>
    &goodies;
引用并不接受可能会引起 xml
格式混乱的字符(在XML中，有时实体内包含了些字符，如&,,",'等。这些均需要对其进行转义，否则会对XML解释器生成错误)，我们想在引用的两边加上
"”,但是好像没有任何语法告诉我们字符串能拼接的，于是我想到了能不能使用多个实体连续引用的方法
**结果如下图：**
注意，这里面的三个实体都是字符串形式，连在一起居然报错了，这说明我们不能在 xml 中进行拼接，而是需要在拼接以后再在 xml 中调用，那么要想在 DTD  
中拼接，我们知道我们只有一种选择，就是使用 参数实体
**payload:**
    ">  
    %dtd; ]> 
    &all;
**evil.dtd**
**结果如下图：**
感兴趣的童鞋可以分析一下整个调用过程，因为我在下面的例子中有分析一个类似的例子，于是出于篇幅考虑我这里就不分析了。
> **注意：**
>
> 这里提一个点，如果是在 java 中 还有一个协议能代替 file 协议 ，那就是 netdoc ，使用方法我会在后面的分析 微信的 XXE  
>  的时候顺带演示
### **新的问题出现**
但是，你想想也知道，本身人家服务器上的 XML 就不是输出用的，一般都是用于配置或者在某些极端情况下利用其他漏洞能恰好实例化解析 XML
的类，因此我们想要现实中利用这个漏洞就必须找到一个不依靠其回显的方法------外带
### **新的解决方法**
想要外带就必须能发起请求，那么什么地方能发起请求呢？
很明显就是我们的外部实体定义的时候，其实光发起请求还不行，我们还得能把我们的数据传出去，而我们的数据本身也是一个对外的请求，也就是说，我们需要在请求中引用另一次请求的结果，分析下来只有我们的参数实体能做到了(并且根据规范，我们必须在一个
DTD 文件中才能完成“请求中引用另一次请求的结果”的要求)
### **实验二：无回显读取本地敏感文件(Blind OOB XXE)**
**xml.php**
    loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); 
    ?>
**test.dtd**
    ">
**2019.5.8 更新**