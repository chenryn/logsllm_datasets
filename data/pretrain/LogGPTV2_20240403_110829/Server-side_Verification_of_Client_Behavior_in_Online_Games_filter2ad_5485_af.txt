### 优化后的文本

#### 图6. 验证2,000轮的《吃豆人》游戏日志
- **成本每轮（懒惰模式）**
- **成本每轮（积极模式）**
- **可满足的累积约束每轮**

当宣布炸弹爆炸时，验证者可以丢弃所有当前累积的、不包含在第i-4轮放置炸弹的约束。同时，也可以丢弃那些包含在第i-3到i+1轮之间放置炸弹的累积约束，因为玩家在同一时间只能有一个待处理的炸弹。这条规则并不是手动配置到验证器中的，而是从客户端代码中自动推断出来的。

### 结论
在过去十几年里，检测在线游戏中的作弊行为已经对游戏设计产生了重大影响。作弊促使游戏开发者尽量减少或消除客户端上的权威状态管理。这些措施直接影响了游戏运营商的利润，尤其是由于带宽成本的增加以及服务器端对客户端行为进行编程检查所需的手动和启发式（因此是持续的）努力。

本文提出了一种新的方法来验证游戏客户端的服务器可见行为。我们的方法验证游戏客户端的行为是被批准的游戏客户端软件可能表现出的行为的一个子集，考虑到客户端之前的行为和发送给该客户端的游戏状态。我们的技术利用了游戏客户端中的常见结构，即一个循环，该循环接受服务器和用户的输入，管理客户端状态，并向服务器更新多人游戏所需的信息。我们通过对这个循环进行符号执行来生成描述其效果的约束条件。然后，游戏运营商可以离线并以自动化的方式检查客户端更新与这些约束的一致性。我们探讨了约束生成的懒惰和积极两种方法，并研究了它们在两个案例研究中的程序员工作量及其性能表现。

在第一个案例研究中，我们将验证方法应用于现有的开源多人游戏XPilot。我们详细介绍了如何调整我们的技术，无论是懒惰还是积极变体，以实现高效的约束生成和服务器端检查。尽管这项工作展示了我们的方法在实际游戏中的应用，但作为对我们技术的测试却不太令人满意，因为XPilot是按照现代游戏的模式开发的——几乎没有任何客户端上的权威状态。因此，我们还将其应用于我们自己设计的一款简单游戏中，以更清晰地展示我们技术的优势。

我们认为，本文中的进展可以改变游戏开发者今天应对重要类型游戏作弊的方式，并在此过程中开辟了允许更低带宽使用和更好性能的新游戏设计途径。我们计划在未来的工作中探索将此技术应用于其他类型的分布式应用程序。

### 致谢
我们衷心感谢Cristian Cadar、Daniel Dunbar和Dawson Engler的有益讨论，并允许我们访问KLEE的早期版本。Srinivas Krishnan、Alana Libonati、Andy White和匿名审稿人提供了关于本文草稿的宝贵意见。本研究部分得到了NSF奖项CT-0756998和TC-0910483的支持。

### 参考文献
[此处列出参考文献]

### 附录A：XPilot确认方案
如§5.2所述，一个高效的确认方案允许服务器（以及验证者）了解客户端处理服务器消息和发送自身消息的顺序（以及循环迭代）。下面描述了一种针对大部分按序到达的消息进行了优化的确认方案。

在这种方案中，XPilot客户端在发送给服务器的每条消息上都包含一个序列号c2sNbr，同样，服务器在发送给客户端的每条消息上也包含一个序列号s2cNbr。每个从服务器到客户端的消息还包括从该客户端接收到的最大c2sNbr值。在每个客户端消息中，客户端包括c2sAckd（迄今为止从服务器消息中接收到的最大c2sNbr值）、一个lateMsgs[]序列（服务器消息序列号）和一个eventSeq[]序列（编码事件发生的顺序）。

这样，lateMsgs[]包含了每个迟到的消息的序列号，而eventSeq[]则高效地编码了事件发生的顺序，例如使用Huffman编码或其他编码方案，在最坏的情况下每个符号最多只需要三位。注意，服务器可以根据从客户端接收到的先前消息确定s2cAckd和loopAckd。