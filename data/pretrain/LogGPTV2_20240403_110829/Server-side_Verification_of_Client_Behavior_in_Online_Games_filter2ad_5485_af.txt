0
0
0
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
500
1000
1500
2000
0
500
1000
1500
2000
0
500
1000
1500
2000
Round
Round
Round
(a) Cost per round (lazy)
(b) Cost per round (eager)
(c) Satisﬁable
accumulated
con-
straints per round
Figure 6. Verifying a 2,000(cid:173)round Cap-Man game log
announcement of a bomb explosion, the veriﬁer can discard
not only all current accumulated constraints which do not
include a bomb placement at round i − 4 but also those ac-
cumulated constraints which do include bomb placements
in rounds i − 3 through i + 1, because players can only have
one pending bomb at a time. This rule was not manually
conﬁgured into the veriﬁer— it was inferred automatically
from the client code itself.
7 Conclusion
The need to detect cheats in online games has heavily in-
ﬂuenced game design for well more than a decade. Cheat-
ing has driven game developers to minimize or eliminate the
management of authoritative state at game clients. These
measures have direct impact on the game operator’s bottom
line, in particular due to the inﬂated bandwidth costs that
result and to the manual and heuristic (and hence ongoing)
effort of programming server-side checks on client behav-
iors.
In this paper we have developed a new approach to val-
idate the server-visible behavior of game clients. Our ap-
proach validates that game-client behavior is a subset of
the behaviors that would be witnessed from the sanctioned
game-client software, in light of both the previous behav-
iors from the client and the game state sent to that client.
Our technique exploits a common structure in game clients,
namely a loop that accepts server and user inputs, manages
client state, and updates the server with information nec-
essary for multiplayer game play. Our technique applies
symbolic execution to this loop to produce constraints that
describe its effects. The game operator can then check the
consistency of client updates with these constraints ofﬂine,
in an automated fashion. We explored both lazy and ea-
ger approaches to constraint generation, and investigated
the programmer effort each entails and their performance
in two case studies.
In our ﬁrst case study, we applied our validation ap-
proach to XPilot, an existing open-source multiplayer game.
We detailed the ways we adapted our technique, in both the
lazy and eager variants, to allow for efﬁcient constraint gen-
eration and server-side checking. While this effort demon-
strated the application of our approach to a real game, it was
less satisfying as a test for our technique, in that XPilot was
developed in the mold of modern games — with virtually
no authoritative state at the client. We thus also applied our
technique to a simple game of our own design that illus-
trated the strengths of our technique more clearly.
We believe that the advance in this paper can change how
game developers address an important class of game cheats
today, and in doing so opens up new avenues of game design
that permit lower bandwidth utilization and better perfor-
mance. We plan to examine the application of this technique
to other types of distributed applications in future work.
Acknowledgements
We are deeply grateful to Cristian Cadar, Daniel Dunbar,
and Dawson Engler for helpful discussions and for permit-
ting us access to an early release of KLEE. Srinivas Kr-
ishnan, Alana Libonati, Andy White and the anonymous
reviewers provided helpful comments on drafts of this pa-
per. This work was supported in part by NSF awards CT-
0756998 and TC-0910483.
References
[1] L. Alexander. World of warcraft hits 10 million sub-
scribers, Jan. 2008. http://www.gamasutra.com/
php-bin/news_index.php?story=17062.
[2] N. E. Baughman and B. N. Levine. Cheat-proof playout for
centralized and distributed online games. In Proceedings of
IEEE INFOCOM, Apr. 2001.
[3] D. Brumley, J. Newsome, D. Song, H. Wang, and S. Jha.
Towards automatic generation of vulnerability-based signa-
tures. In Proceedings of the 2006 IEEE Symposium on Se-
curity and Privacy, May 2006.
[4] D. Brumley, H. Wang, S. Jha, and D. Song. Creating vul-
nerability signatures using weakest pre-conditions. In Pro-
ceedings of the 2007 Computer Security Foundations Sym-
posium, July 2007.
[5] C. Cadar, D. Dunbar, and D. Engler. KLEE: Unassisted
and automatic generation of high-coverage tests for complex
systems programs. In Proceedings of the 8th USENIX Sym-
posium on Operating Systems Design and Implementation,
Dec. 2008.
[6] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R.
Engler. EXE: Automatically generating inputs of death. In
Proceedings of the 13th ACM Conference on Computer and
Communications Security, Nov. 2006.
[7] K.-T. Chen, J.-W. Jiang, P. Huang, H.-H. Chu, C.-L. Lei, and
W.-C. Chen. Identifying MMORPG bots: A trafﬁc analysis
approach. In Proceedings of the 2006 ACM SIGCHI Interna-
tional Conference on Advances in Computer Entertainment
Technology, June 2006.
[8] K.-T. Chen, H.-K. K. Pao, and H.-C. Chang. Game bot
identiﬁcation based on manifold learning.
In Proceedings
of the 7th ACM SIGCOMM Workshop on Network and Sys-
tem Support for Games, pages 21–26, Oct. 2008.
[9] S. Chong, J. Liu, A. C. Myers, X. Qi, N. Vikram, L. Zheng,
and X. Zheng. Secure web applications via automatic par-
titioning.
In Proceedings of the 21st ACM Symposium on
Operating Systems Principles, pages 31–44, Oct. 2007.
[10] E. Cronin, B. Filstrup, and S. Jamin. Cheat-prooﬁng dead
reckoned multiplayer games. In Proceedings of the 2nd In-
ternational Conference on Application and Development of
Computer Games, Jan. 2003.
[11] M. DeLap, B. Knutsson, H. Lu, O. Sokolsky, U. Sammapun,
I. Lee, and C. Tsarouchis. Is runtime veriﬁcation applicable
to cheat detection? In Proceedings of 3rd ACM SIGCOMM
Workshop on Network and System Support for Games, Aug.
2004.
[12] W. Feng, E. Kaiser, and T. Schluessler. Stealth measure-
ments for cheat detection in on-line games. In Proceedings
of the 7th ACM SIGCOMM Workshop on Network and Sys-
tem Support for Games, pages 15–20, Oct. 2008.
[13] V. Ganesh and D. L. Dill. A decision procedure for bit-
vectors and arrays.
In Computer Aided Veriﬁcation, 19th
International Conference, CAV 2007, pages 519–531, July
2007.
[14] J. T. Gifﬁn, S. Jha, and B. P. Miller. Detecting manipulated
In Proceedings of the 11th USENIX
remote call streams.
Security Symposium, Aug. 2002.
[15] J. Goodman and C. Verbrugge. A peer auditing scheme for
cheat elimination in MMOGs.
In Proceedings of the 7th
ACM SIGCOMM Workshop on Network and System Support
for Games, pages 9–14, Oct. 2008.
[16] A. Guha, S. Krishnamurthi, and T. Jim. Using static analy-
sis for Ajax intrusion detection. In Proceedings of the 18th
International World Wide Web Conference, pages 561–570,
Apr. 2009.
[17] S. Hawkins, consultant for Sega of America. Quoted [29,
p. 182].
[18] G. Hoglund and G. McGraw. Exploiting Online Games:
Cheating Massively Distributed Systems. Addison-Wesley
Professional, 2007.
[19] D. A. Huffman. A method for the construction of minimum-
redundancy codes. Proceedings of the Institute of Radio En-
gineers, 40(9):1098–1101, Sept. 1952.
[20] T. Izaiku, S. Yamamoto, Y. Murata, N. Shibata, K. Ya-
sumoto, and M. Ito. Cheat detection for MMORPG on
P2P environments. In Proceedings of 5th ACM SIGCOMM
Workshop on Network and System Support for Games, Oct.
2006.
[21] S. Jha, S. Katzenbeisser, C. Schallhart, H. Veith, and
Enforcing semantic integrity on untrusted
S. Chenney.
clients in networked virtual environments (extended ab-
stract).
In Proceedings of the 2007 IEEE Symposium on
Security and Privacy, pages 179–186, May 2007.
[22] P. Kabus, W. W. Terpstra, M. Cilia, and A. P. Buchmann.
Addressing cheating in distributed MMOGs. In Proceedings
of 4th ACM SIGCOMM Workshop on Network and System
Support for Games, Oct. 2005.
[23] E. Kaiser, W. Feng, and T. Schluessler. Fides: Remote
In
anomaly-based cheat detection using client emulation.
Proceedings of the 16th ACM Conference on Computer and
Communications Security, Nov. 2009.
[24] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and G. Vigna.
Automating mimicry attacks using static binary analysis. In
Proceedings of the 14th USENIX Security Symposium, pages
161–176, July 2005.
[25] Y. Lyhyaoui, A. Lyhyaoui, and S. Natkin. Online games:
Categorization of attacks. In Proceedings of the 2005 Inter-
national Conference on Computer as a Tool (EUROCON),
Nov. 2005.
[26] M. Magiera. Videogames sales bigger than DVD-Blu-ray for
ﬁrst time, Jan. 2009. http://www.videobusiness.
com/article/CA6631456.html.
[27] S. Mitterhofer, C. Platzer, C. Kruegel, and E. Kirda. Server-
side bot detection in massive multiplayer online games.
IEEE Security and Privacy, 7:18–25, 3 2009.
[28] C. M¨onch, G. Grimen, and R. Midtstraum. Protecting on-
In Proceedings of 5th ACM
line games against cheating.
SIGCOMM Workshop on Network and System Support for
Games, Oct. 2006.
[29] J. Mulligan and B. Patrovsky. Developing Online Games:
An Insider’s Guide. New Riders Publishing, 2003.
[30] M. Rosenblum and J. K. Ousterhout. The design and imple-
mentation of a log-structured ﬁle system. ACM Transactions
on Computer Systems, 10(1):26–52, 1992.
symbols that encode events in the order they happened at
the client. The symbols in eventSeq[] can be any of the
following. Below, s2cAckd is the largest sequence num-
ber s2cNbr received by the client before sending message
c2sAckd , and similarly loopAckd is the largest client loop
iteration completed at the client prior to it sending c2sAckd .
• Loop denotes a completed loop iteration. The j-th oc-
currence of Loop in eventSeq[] denotes the completion
of loop iteration loopAckd + j.
• Send denotes the sending of a message to the server. The
j-th occurrence of Send in eventSeq[] denotes the send-
ing of client message c2sAckd + j.
• Recv and Skip denote receiving or skipping the next
server message in sequence. The j-th occurrence of
Recv or Skip in eventSeq[] denotes receiving or skip-
ping, respectively, server message s2cAckd + j. Here,
a message a skipped if it has not arrived by the time a
server message with a larger sequence number arrives,
and so a series of one or more Skip symbols is followed
only by Recv in eventSeq[].
• Late denotes the late arrival of a message, i.e., the ar-
rival of a message that was previously skipped. The j-th
occurrence of Late in eventSeq[] denotes the arrival of
server message lateMsgs[j].
As such, lateMsgs[] contains a sequence number for
each server message that arrives after another with a larger
sequence number, and so lateMsgs[] should be small.
eventSeq[] may contain more elements, but the symbols can
be encoded efﬁciently, e.g., using Huffman coding [19] or
another coding scheme, and in at most three bits per sym-
bol in the worst case. Note that the server can determine
s2cAckd and loopAckd based on the previous messages re-
ceived from the client.
[31] T. Schluessler, S. Goglin, and E. Johnson.
Is a bot at the
controls? Detecting input data attacks.
In Proceedings of
the 6th ACM SIGCOMM Workshop on Network and System
Support for Games, pages 1–6, Sept. 2007.
[32] D. Schubert,
former
lead designer
for Meridian 59.
Quoted [29, p. 221].
[33] D. Spohn.
Cheating in online games.
http://
internetgames.about.com/od/gamingnews/
a/cheating.htm.
[34] G. Staff.
Analyst:
Online games now $11b
2009.
game market,
$44b worldwide
of
http://www.gamasutra.com/php-bin/news_
index.php?story=23954.
June
[35] K. Vikram, A. Prateek, and B. Livshits. Ripley: Automat-
ically securing Web 2.0 applications through replicated ex-
ecution.
In Proceedings of the 16th ACM Conference on
Computer and Communications Security, Nov. 2009.
[36] R. Wang, X. Wang, Z. Li, H. Tang, M. K. Reiter, and
Z. Dong. Privacy-preserving genomic computation through
program specialization.
In Proceedings of the 16th ACM
Conference on Computer and Communications Security,
Nov. 2009.
[37] M. Ward. Warcraft game maker in spying row, Oct. 2005.
http://news.bbc.co.uk/2/hi/technology/
4385050.stm.
[38] S. Webb and S. Soh. A survey on network game cheats and
P2P solutions. Australian Journal of Intelligent Information
Processing Systems, 9(4):34–43, 2008.
[39] R. V. Yampolskly and V. Govindaraju. Embedded nonin-
teractive continuous bot detection. Computers in Entertain-
ment, 5(4):1–11, Oct. 2007.
[40] J. Yan and B. Randell. A systematic classiﬁcation of cheat-
ing in online games. In Proceedings of 4th ACM SIGCOMM
Workshop on Network and System Support for Games, Oct.
2005.
[41] J. Yang, C. Sar, P. Twohey, C. Cadar, and D. Engler. Au-
tomatically generating malicious disks using symbolic ex-
ecution.
In Proceedings of the 2006 IEEE Symposium on
Security and Privacy, May 2006.
A An XPilot Acknowledgement Scheme
As discussed in §5.2, an efﬁcient acknowledgement
scheme allows the server (and hence veriﬁer) knowledge of
the order (and loop iterations) in which the client processed
server messages and sent its own messages. Below we de-
scribe one such scheme that is optimized for messages that
arrive at the client mostly in order.
In this scheme, the XPilot client includes a sequence
number c2sNbr on each message it sends to the server, and
similarly the server includes a sequence number s2cNbr on
each message it sends to the client. Each message from the
server to a client also includes the largest value of c2sNbr
received from that client. In each client message, the client
includes c2sAckd , the largest value of c2sNbr received in
a server message so far; a sequence lateMsgs[] of server
message sequence numbers; and a sequence eventSeq[] of