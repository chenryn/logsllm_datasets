years to reconstruct at least one secret with probability 0.1 for
both NAIVE and CYCLIC.
Table I also shows the numbers of shares generated by
these schemes for the same scenario. As expected, SIMPLE
produces the fewest shares (less than 1/10 of NAIVE) but this
comes at the expense of security. CYCLIC with an overlap of
13 increases the number of shares by about 65% over SIMPLE.
However, CYCLIC 13 uses less than 1/7 the number of shares
of NAIVE, while providing far greater security than SIMPLE.
2) Reconstructing all secrets with one secret reconstructed:
A major weakness of SIMPLE is that if the adversary is able to
to reconstruct one secret, even a fake one, they know that n‚àí1
of those shares must appear in all other secrets of the same
object. This dramatically reduces the number of combinations
the adversary must try to reveal all remaining secrets. Even
if this happens, we note that the adversary will not be able
to tell which is the correct secret but they will know that the
correct secret is among the ones that they have found. In some
scenarios, this could be highly undesirable. Next, we will show
that CYCLIC, with a reasonable choice of overlap, is far more
secure in terms of this second security measure.
For both CYCLIC and SIMPLE, once one secret is recon-
structed, some information is revealed so that the adversary
can reconstruct more secrets in a more efÔ¨Åcient way than
simply attempting random combinations. Since secrets have
overlap of shares, the adversary can focus on secrets that
are neighbors of the reconstructed secret in the schemes to
more efÔ¨Åciently reconstruct additional secrets. Note, however,
that the security of remaining secrets in NAIVE is affected
very little by reconstruction of other secrets. This is because
there is no share overlap between secrets in NAIVE and
so the adversary can still only try random combinations of
the remaining shares. Since NAIVE is affected very little by
the Ô¨Årst secret reconstruction, in this section, we focus on a
comparison between CYCLIC and SIMPLE.
We Ô¨Årst calculate how many attempts an adversary needs
to guarantee they can reconstruct all remaining secrets in the
SIMPLE scheme, given one secret. Since the number of shares
in SIMPLE is m + n ‚àí 1, if one secret is known, there are
! !





	
 

	
! !




	


! !



	


Fig. 6. Different cases for reconstructing all secrets with one leaked secret
for the CYCLIC scheme
m ‚àí 1 shares left. We know that n ‚àí 1 of the n shares of the
Ô¨Årst secret are also part of every other secret. To Ô¨Ånd those
n ‚àí 1 shares only takes n attempts, since the adversary can
pick one share from all remaining shares, and use it to replace
each share in the reconstructed secret to see if a new secret
is revealed. After that, the adversary can easily use the n ‚àí 1
identiÔ¨Åed common shares to reconstruct the remaining secrets
with the last m ‚àí 2 shares. The overall process takes only
n + m ‚àí 2 attempts, which is highly insecure.
In the CYCLIC scheme, some information is also leaked
from the Ô¨Årst secret, but we will show that the adversary
still needs a lot of attempts to guarantee reconstruction of the
remaining secrets as long as the overlap between secrets is
not too high. Since in CYCLIC, a secret shares r shares with
its neighboring secret, with one reconstructed secret, the best
choice is to try to reconstruct the neighboring secret next, to
maximize the information from the Ô¨Årst secret.
The Ô¨Årst case, e.g. Figure 6a,
Let the secret that is known be Sc and let the next secret
to be reconstructed be Sn, where Sc and Sn are neighbors in
the CYCLIC scheme. The number of remaining shares that
are not part of the known secret is Nshare ‚àí n. The idea
to reconstruct Sn with information from Sc is to Ô¨Ånd the
overlapping shares from Sc, to reduce the number of attempts.
Based on the speciÔ¨Åc parameters for CYCLIC, we divide the
process into three cases, as shown in Figure 6.
is r < n
2 , where the
overlapping shares cannot be precisely determined from Sc.
For example, 2 out of the 5 non-overlapping shares in the right
circled secret will be part of the next secret but the adversary
has no way to know which of the 5 are the correct ones.
The adversary needs to pick the r overlapping shares from all
shares of Sc other than the ones that Sc had in common with
the previous secret, which means choosing r shares out of
n‚àí r shares (2 out of 5 in the Ô¨Ågure). The adversary must put
those r shares together with n ‚àí r shares from all remaining
shares that are not part of any reconstructed secret. Summing
these two expressions over all the remaining secrets gives the
number of combinations for this case as:
Nshare‚àín
n‚àír ‚àí1(cid:4)
(cid:2)
k=0
(cid:3) √ó (cid:2)
n‚àír
r
Nshare‚àín‚àík(n‚àír)
n‚àír
(cid:3)
447
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:50:43 UTC from IEEE Xplore.  Restrictions apply. 
is r ‚â• n
2 , and
The second case, e.g. Figure 6b,
n
mod n ‚àí r = 0. In this case, there is an initial period where
the adversary does not know exactly which shares from the
previous secret will be reused in the next secret. However,
after a small number of consecutive secrets are reconstructed,
the common shares can be exactly identiÔ¨Åed, which reduces
the number of combinations that must be attempted. In the
Figure 6b example, when reconstructing the 2nd secret, the
adversary knows there are 6 shares that overlap with the 1st
secret, but he has no idea which 6 of the 7 shares in the 1st
(cid:3)
7
secret those are, which means he needs to consider up to
6
combinations to Ô¨Ånd the correct common shares and, for each
of those, he needs to combine them with combinations of the
remaining unused shares. However, after the Ô¨Årst 6 secrets
are revealed, the 6 overlapping shares between the 6th and
7th secrets can be deÔ¨Ånitively identiÔ¨Åed since the other share
was already known to be part of the 5th and 6th secrets. So,
from this point forward, the adversary only needs to consider
the combinations of the remaining unused shares each time.
Generalizing this logic yields the number of combinations as:
(cid:2)
(cid:3) r
n‚àír (cid:4)(cid:4)
(cid:2)
k=0
n‚àík(n‚àír)
r‚àík(n‚àír)
(cid:3) √ó (cid:2)
Nshare‚àín‚àík(n‚àír)
n‚àír
(cid:3)
+
Nshare‚àín
n‚àír ‚àí1(cid:4)
(cid:2)
k=(cid:3) r
n‚àír (cid:4)+1
Nshare‚àín‚àík(n‚àír)
n‚àír
(cid:3)
is r ‚â• n
2 , and
The third case, e.g. Figure 6c,
n
mod n‚àí r (cid:7)= 0. Similar to the previous case, some shares are
determined from Sc, while some shares cannot be determined
from Sc. In the Ô¨Ågure‚Äôs example, when reconstructing the
2nd secret, the adversary knows that 5 of 7 shares from the
Ô¨Årst secret are included. However, when reconstructing the 5th
secret, 4 shares are predetermined from the 4th secret, while
1 share cannot be determined (1 of the 2 orange shares should
be included and the other should not). Generalizing this yields
the following number of combinations:
(cid:3) r
n‚àír (cid:4)(cid:4)
(cid:2)
k=0
n‚àík(n‚àír)
r‚àík(n‚àír)
(cid:3) √ó (cid:2)
Nshare‚àín‚àík(n‚àír)
n‚àír
(cid:3)
+
(cid:2)
n‚àír
r mod n‚àír
(cid:3) √ó
Nshare‚àín
n‚àír ‚àí1(cid:4)
(cid:2)
k=(cid:3) r
n‚àír (cid:4)+1
Nshare‚àín‚àík(n‚àír)
n‚àír
(cid:3)
Fig. 7. Number of attempts needed to reconstruct all secrets given one secret
in CYCLIC scheme (m = 50, n = 15, log scale on y-axis)
huge number of attempts an adversary needs. However, if
we also are concerned about the security after one secret is
reconstructed, we need to further reduce the overlap, which
again increases the number of shares. Recall that, with the
SIMPLE scheme, the adversary only needs n + m ‚àí 2 = 113
attempts with these parameter values to reconstruct all secrets
given the Ô¨Årst secret. We can conclude that, after one secret is
retrieved by an adversary, SIMPLE provides almost no security
for the remaining secrets, while CYCLIC can still provide very
strong security with a properly chosen overlap, at the expense
of an additional increase in the number of shares.
D. Discussion
As we showed in Subsection IV-C1, reconstructing the Ô¨Årst
secret is hard for any of the three schemes. The computation
time depends on many factors including not only the param-
eters of the schemes but also the computational power of the
adversary and the size of the secret. In some scenarios, it
might be that the computational difÔ¨Åculty yielded by SIMPLE
for reconstruction of the Ô¨Årst secret with a small probability is
high enough. However, in other scenarios, the system designer
might not be satisÔ¨Åed that the SIMPLE‚Äôs computational dif-
Ô¨Åculty is high enough or they might not be comfortable with
the probabilistic nature of the computational effort required.
In these situations, CYCLIC allows the designer to, with a
modest increase of overhead, signiÔ¨Åcantly increase the overall
security in the event that one secret is revealed.
V. NOTCHED CYCLIC POLYNOMIAL-BASED DSS
We again give an example to make the number of combina-
tions concrete. As before, assume there are 50 secrets, each has
15 shares, and the overlap is varied from 0 to n‚àí1. The results
are shown in Figure 7. We can see that when we choose an
overlap of 13 as in the previous subsection, the adversary needs
about 106 attempts to retrieve all secrets. When we choose an
overlap of 9, the number of combinations reaches 1015, which
is 10 years using the computational numbers from the earlier
example. This is another example of the overhead/security
trade-off. If we only consider retrieving the Ô¨Årst secret, r = 13
provides very strong security as shown in Table I by the
In this section, we investigate a deception scheme that works
with Shamir‚Äôs secret sharing scheme [18], which is a (k, n)
threshold-based scheme, where k < n and any k of the n
shares allow the secret to be reconstructed, while any k ‚àí 1
shares do not reveal any information about the secret. (k, n) se-
cret sharing can offer better fault tolerance than (n, n) schemes
such as XOR, because the secret can still be reconstructed
even if some shares are not available. We present and analyze
a scheme, which we call Notched Cyclic Polynomial-Based
Deceptive Secret Sharing (or NCP for short) that performs
deceptive secret sharing using Shamir‚Äôs scheme.
448
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:50:43 UTC from IEEE Xplore.  Restrictions apply. 
A. Deception and Shamir‚Äôs Scheme
In Shamir‚Äôs scheme, each secret corresponds to a degree
k ‚àí 1 polynomial q(x) = a0 + a1 ¬∑ x + a2 ¬∑ x2 + . . . + ak‚àí1 ¬∑
xk‚àí1, where a0 is the value of the secret. The n shares that
make up the secret are n points (i, Di), i = 1, 2, ..., n, on the
polynomial, i.e.
D1 = q(1), D2 = q(2), . . . , Dn = q(n)
Share i is represented by the pair (i, Di) and we call i the
share‚Äôs index. The secret can be expressed as D0. Any k shares
with k different indexes from 1, 2, ..., n determine the secret‚Äôs
polynomial and can therefore be used to recover the secret‚Äôs
value, and any k ‚àí 1 shares reveal no information since there
are an inÔ¨Ånite number of degree k ‚àí 1 polynomials that go
through the k ‚àí 1 points corresponding to the share values.
Analogous to NAIVE for XOR secret sharing, with Shamir‚Äôs
scheme, we could simply choose independent polynomials for
each secret. We call this scheme P NAIVE and it requires mn
shares, just as NAIVE did. An analogous scheme to SIMPLE,
with Shamir‚Äôs scheme, is to choose k ‚àí 1 polynomial points
to be the same for all secrets. Each of the m secrets is then
deÔ¨Åned by a distinct kth point, which is the secret value. To
complete the (k, n) scheme, we would then generate n‚àí k +1
additional points on the corresponding polynomial for each
secret. We refer to this scheme as P SIMPLE.
We assume throughout this section that an adversary who
compromises a share knows its index. This comports with
our assumption of a powerful adversary and also reduces the
amount of information that we assume a valid user is able to
determine but is not available to the adversary. This would
also simplify implementation of the approach considerably
since a share‚Äôs index can simply be stored with the share
as is the case in many implementations of Shamir‚Äôs scheme.