carded frames on the overall BER. One could also use
a much more optimistic decoder so that partial frames
are not discarded completely but parts of their contents
are recovered. This would most likely need to be com-
bined with an error correction coding scheme for the
data within the frame. Coding schemes based on either
the Hamming distance metric (to handle substitutions) or
Levenshtein distance metric [42] (to handle deletions as
well) could be used. Another approach would be to mod-
ify the framing scheme to reduce the chance of frame
corruption. For example, using two frame delimiters at
the start of every frame instead of one. This way if only
one of the delimiters gets deleted or corrupted, the frame
can still be decoded correctly.
6.3.6 Encoding Scheme
Our results for smaller window sizes indicate that for
many environments in which the Keyboard JitterBug
might be deployed, one could use a more efﬁcient sym-
bol encoding scheme by packing more than one bit of
information with each transmitted symbol. To con-
ﬁrm this hypothesis, we implemented a 16 symbol (four
bits/symbol) encoding scheme with an additional symbol
acting as the frame delimiter. The results of our experi-
ments are summarized in Table 7. The frame size used
is 16 bits (four symbols). The Average Correct Frame
BER stays at above acceptable levels for all the nodes
tested. The results show that it is possible to optimize the
framing and encoding schemes to increase the bandwidth
of the channel and at the same time maintain acceptable
channel performance.
6.4 Summary of the results
Our experimental results indicate that a conservative
choice of the window size as 20 ms is small enough to
be undetectable by a normal user and at the same time
gives good channel performance under a variety of sys-
tem loads, operating systems and network conditions.
One can also increase the bandwidth of the channel by
choosing a more aggressive encoding scheme as our re-
sults for the high bit rate encoding show. However, our
primary goal was to design an encoding scheme that is
robust and general enough to work under any unknown
environment without affecting user perception. The bi-
nary encoding scheme with a timing window of 20 ms
serves that purpose quite well.
6.5 Detection
The detection of covert network timing channels is a sep-
arate research problem of its own and as such, quite dif-
ﬁcult. Thus we do not focus on the detectability aspects
of the channel in this paper. However, we brieﬂy analyze
some of the issues.
It has been suggested in previous studies that covert
network timing channels can be detected by looking at
the inter-arrival times of network packets [11, 7]. These
detection algorithms rely on the notion of regularity, a
channel-speciﬁc property that can be used to distinguish
normal trafﬁc from certain kinds of covert channel trafﬁc.
None of these techniques work for detecting the presence
of any covert timing channel. The Keyboard JitterBug is
a low-bandwidth timing channel and has a different form
of regularity. Hence, these techniques are unlikely to be
able to detect the exploitation of our timing channel.
However, it might be possible to detect Keyboard Jit-
terBug activity by directly observing the inter-arrival
times of network packets. The inter-arrival times tend
to cluster around multiples of the window size or half
the window size. This is because the symbol encoding
scheme relies on using an inter-arrival time of 0 (modulo
w) for sending a ‘0’ and w/2 (modulo w) for sending a
‘1’. We collected an SSH trace without the use of a Key-
board JitterBug. We then modiﬁed the trace by adding
simulated jitter so that packet timings corresponded to
the case when a Keyboard JitterBug is being used. Be-
cause we do not model the effect of noise added by net-
work jitter, this gives us a worst case analysis of the de-
tectability of our channel.
Figure 6 shows the inter-arrival times for 550 packets
in the original trace for a range between 0.2s and 0.3s.
In Figure 7, we show the same trace except now with
simulated jitter that would be added by a Keyboard Jit-
terBug. Notice the banding around multiples of 10 ms,
which corresponds to a window size of 20 ms. Thus, a
simple plot of the inter-arrival times reveals that that a
covert timing channel is being exploited.
To evade such a simple detection scheme, an approach
based on rotating the timing window used for symbol en-
coding is described below. Note, however, that we do
72
Security ’06: 15th USENIX Security Symposium
USENIX Association
Figure 6: Original SSH Trace
Figure 8: JitterBug applied to the original SSH Trace
(rotating time windows)
Figure 7: JitterBug applied to the original SSH Trace
(stationary time windows)
not claim that the use of the following technique makes
our channel undetectable using any other technique. It is
simply a countermeasure against the most direct way of
detecting our covert timing channel. The timing channel
might still be susceptible to other forms of analysis that
detect its presence in network trafﬁc.
The method works as follows. As before, let us de-
note by {bi} the binary sequence to be transmitted using
jitters, and by {ti} the sequence of the times when the
keys are pressed. Assume there exists {si}, a pseudo-
random sequence of integers that range from 0 to w − 1,
where w is, as before, the length of the timing window.
The sequence {si} is assumed to be known by the sender
and the receiver but not by anyone else, and works as a
shared secret. Rather than encoding bits by adding de-
lays so that the inter-arrival distances cluster around 0
and its antipode, the source adds jitter such that they clus-
ter around the sequence {si} and its associated antipodal
sequence.
More precisely, in order to transmit the bit bi, the Jit-
Figure 9: Rotating timing windows: The symbol encod-
ing window is rotated for sending each bit
terBug adds a delay such that:
(δi − si) mod w =(cid:26) 0
bw/2c
if bi = 0;
if bi = 1;
0
i − t
0
where δi = t
i−1, as before are the difference in
times when adjacent keystrokes are sent to the keyboard
controller by the Keyboard JitterBug.
Consider an example where Bob wants to send 3-bits
of information {1, 0, 1} to Eve using JitterBug. Assume
that the window size is 20 ms, and that they agreed on
the sequence {s0, s1, s2} = {3, 9, 5}. Figure 9 illustrates
how the timing window is rotated at each step before de-
ciding on the amount of jitter to add.
Figure 8 shows the inter-arrival times for the same
SSH trace with packet timing adjusted for JitterBug but
this time using rotating windows during symbol encod-
ing instead of the original static scheme. The sequence
{si} is chosen to be a pseudo-random sequence of in-
tegers between 0 and 19. The inter-arrival times are no
longer clustered now and there are no new noticeable pat-
terns compared to the original SSH trace.
USENIX Association
Security ’06: 15th USENIX Security Symposium
73
 0.1 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.2 0 50 100 150 200 250 300 350 400 450 500 550Inter-arrival timesPacket NumberOriginal Trace 0.1 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.2 0 50 100 150 200 250 300 350 400 450 500 550Inter-arrival timesPacket NumberJitterBug Trace 0.1 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.2 0 50 100 150 200 250 300 350 400 450 500 550Inter-arrival timesPacket NumberJitterBug with Rotating timing windows15139Decode as 0Decode as 1Original TimingwindowBit sent = 1; s2  = 5Bit sent = 0; s1  = 9Bit sent = 1; s0 = 3Packet sent atsequence {bδi} on the receiver’s side looks as arbitrary
The intuition behind this approach is that the resulting
as {si}. The choice of {si} is obviously important and
should be sufﬁciently random . Note that when {si = 0
; ∀ i}, this reduces to the original case with a stationary
time window.
7 Conclusions and Future Work
Compromising an input channel is useful not only for
learning secrets, but, as we have seen, is also often sufﬁ-
cient for leaking them over the network. We introduced
loosely-coupled network timing channels and JitterBugs,
through which covert network timing channels can be ex-
ploited to leak sensitive information in general-purpose
computing systems. We described the Keyboard Jitter-
Bug, our implementation of such a network timing chan-
nel. The Keyboard JitterBug is a keylogger that does
not require physical retrieval to exﬁltrate its captured
data. It can leak previously captured sensitive informa-
tion such as user passphrases over interactive network
applications by adding small and unnoticeable delays to
user keypresses. It is even possible to use the Keyboard
JitterBug, at low-bandwidth with other, non-interactive,
network applications, such as web browsers and instant
messaging systems.
Our experiments suggest that the distance over the net-
work between the receiver and the JitterBug doesn’t mat-
ter very much. The timing window size w is the basic
parameter of the symbol encoding scheme.
Its choice
is dictated by the expected amount of jitter in the net-
work and by the maximum delay that can be tolerated.
A conservative choice of the window size as 20 ms is
small enough to be unnoticeable to a human user and at
the same time gives good channel performance over a
wide range of network conditions and operating systems
tested. This makes a Keyboard JitterBug very robust and
less susceptible to major changes in the environment in
which it is installed. We also described experimental re-
sults with some simple framing schemes and more ag-
gressive encoding mechanisms. Our results show that
the symbol encoding and framing could be further op-
timized for better performance in certain environments.
Finally, we showed simple techniques for defeating the
most direct ways of detecting our attacks.
The most obvious extension to this work is the de-
velopment of better framing and encoding schemes with
higher bandwidth, by making less conservative assump-
tions that take advantage of speciﬁc channel properties.
In this paper, however, we deliberately avoided optimiz-
ing for any particular channel, operating system, or net-
worked application, instead identifying parameters that
give satisfactory performance and that remain highly ro-
bust under varied conditions.
All covert timing channels represent an arms race be-
tween those who exploit such channels and those who
want to detect their use. This necessitates the use of
countermeasures by a covert channel to elude detection
by network wardens. We suggested only very simple
countermeasures in this paper. Our initial results with
rotating encoding timing windows indicate that the use
of cryptographic techniques to hide the use of encoded
jitter channels may be a promising approach. We plan to
explore this direction in the future.
Acknowledgments
This research was supported in part by grants from NSF
Cybertrust (CNS-05-24047) and NSF SGER (CNS-05-
04159). Jutta Degener suggested the name “JitterBug”.
The idea of using a PIC chip to add jitters emerged
from discussions with John Ionannidis. We thank Mad-
hukar Anand, Sandy Clark, Eric Cronin, Chris Marget
and Micah Sherr for the many helpful discussions during
the course of this research. We are grateful for the facil-
ities of PlanetLab to perform our experiments. Finally,
we thank the anonymous reviewers and David Wagner
for many helpful suggestions and comments.
References
[1] The stress project. http://weather.ou.edu/ apw/projects/stress/.
[2] Trusted computer system evaluation. Tech. Rep. DOD 5200.28-
STD, U.S. Department of Defense, 1985.
[3] United States v. Scarfo, Criminal No. 00-404 (D.N.J.), 2001.
[4] ACHARYA, A., AND SALZ, J. A Study of Internet Round-Trip
Delay. Tech. Rep. CS-TR-3736, University of Maryland, 1996.
[5] AGAT, J. Transforming out timing leaks. In POPL ’00: Proceed-
ings of the 27th ACM SIGPLAN-SIGACT symposium on Prin-
ciples of programming languages (New York, NY, USA, 2000),
ACM Press, pp. 40–53.
[6] ANANTHARAM, V., AND VERDU, S. Bits Through Queues. In
IEEE Transactions On Information Theory (1996), vol. 42.
[7] BERK, V., GIANI, A., AND CYBENKO, G. Detection of Covert
Channel Encoding in Network Packet Delays. Tech. rep., Darth-
mouth College, 2005.
[8] BROIDO, A., HYUN, Y., AND KC CLAFFY. Spectroscopy of
traceroute delays. In Passive and active measurement workshop
(2005).
[9] BROIDO, A., KING, R., NEMETH, E., AND KC CLAFFY. Radon
spectroscopy of inter-packet delay. In IEEE high-speed network-
ing workshop (2003).
[10] BRUMLEY, D., AND BONEH, D. Remote Timing Attacks are
Practical. In Proceedings of the 12th USENIX Security Sympo-
sium (August 2003).
[11] CABUK, S., BRODLEY, C. E., AND SHIELDS, C. IP covert tim-
ing channels: design and detection.
In CCS ’04: Proceedings
of the 11th ACM conference on Computer and communications
security (New York, NY, USA, 2004), ACM Press, pp. 178–187.
74
Security ’06: 15th USENIX Security Symposium
USENIX Association
[12] CHUN, B., CULLER, D., ROSCOE, T., BAVIER, A., PETER-
SON, L., WAWRZONIAK, M., AND BOWMAN, M. Planetlab: an
overlay testbed for broad-coverage services. SIGCOMM Comput.
Commun. Rev. 33, 3 (2003), 3–12.
[32] MILLER, R. B. Response time in man-computer conversational
transactions. In AFIPS Fall Joint Computer Conference (1968),
vol. 33.
[33] MOSKOWITZ, I. S., AND KANG, M. H. Covert Channels – Here
[13] DAEMON9. Project Loki. Phrack Magazine 7, 49 (August 1996).
to Stay ? In COMPASS (1994).
[34] MOSKOWITZ, I. S., AND MILLER, A. R. The Inﬂuence of Delay
Upon an Idealized Channel’s Bandwidth. In SP ’92: Proceedings
of the 1992 IEEE Symposium on Security and Privacy (Washing-
ton, DC, USA, 1992), IEEE Computer Society, p. 62.
[35] MOSKOWITZ, I. S., AND MILLER, A. R. Simple timing chan-
nels. In IEEE Symposium on Security and Privacy (1994).
[36] MURDOCH, S., AND DANEZIS, G. Low-cost trafﬁc analysis of
tor. In Proceedings of the 2005 IEEE Symposium on Security and
Privacy (2005).
[37] NAGLE, J. RFC 896 - Congestion Control in IP/TCP Internet-
works.
[38] PROCTOR, N. E., AND NEUMANN, P. G. Architectural Impli-
cations of Covert Channels. In 15th National Computer Security
Conference (1992).
[39] RATZER, E. A., AND MACKAY, D. J. C. Codes for channels
with insertions, deletions and substitutions.
In Proceedings of
2nd International Symposium on Turbo Codes and Related Top-
ics, Brest, France, 2000 (2000), pp. 149–156.
[40] SHANNON, C. E. A mathematical theory of communication. Bell
System Technical Journal (1948), 379–423 and 623–656.
[41] SONG, D. X., WAGNER, D., AND TIAN, X. Timing analysis
In USENIX Security
of keystrokes and timing attacks on ssh.
Symposium (2001).
[42] TANAKA, E., AND KASAI, T. Synchronization and substitution
error-correcting codes for the Levenshtein metric. In IEEE Trans-
actions on Information Theory (March 1976), vol. 22, pp. 156–
162.
[43] VENKATRAMAN, B. R., AND NEWMAN-WOLFE, R. Capac-
ity Estimation and Auditability of Network Covert Channels. In
IEEE Symposium on Security and Privacy (1995).
[44] WANG, X., CHEN, S., AND JAJODIA, S. Tracking anonymous
peer-to-peer VoIP calls on the internet. In CCS ’05: Proceedings
of the 12th ACM conference on Computer and communications
security (New York, NY, USA, 2005), ACM Press, pp. 81–91.
[45] WANG, X., AND REEVES, D. Robust Correlation of Encrypted
Attack Trafﬁc Through Stepping Stones by Manipulation of In-
terpacket Delays. In Proceedings of the 10th ACM Conference on
Computer and Communications Security (CCS 2003) (2003).
[46] WRAY, J. C. An Analysis of Covert Timing Channels. In Pro-
ceedings of the IEEE Symposium on Research in Security and
Privacy, Oakland, California (1991).
[14] DAVEY, M. C., AND MACKAY, D. J. Reliable communication
over channels with insertions, deletions, and substitutions. IEEE
Transactions on Information Theory 47 (2001).
[15] F. F. SELLERS, J. Bit loss and gain correction code. In IEEE
Transactions on Information Theory (1962), vol. 8, pp. 35–38.
[16] GILES, J., AND HAJEK, B. An Information-Theoretic and
In IEEE Transac-
Game-Theoretic Study of Timing Channels.
tions on Information Theory (2002), vol. 48.
[17] HELOUET, L., JARD, C., AND ZEITOUN, M. Covert chan-
nels detection in protocols using scenarios.
In Proceed-
ings of SPV ’2003, Workshop on Security Protocols Ver-
iﬁcation (2003).
Satellite of CONCUR’03. Available at
http://www.loria.fr/˜rusi/spv.pdf.
[18] HU, W.-M. Reducing Timing Channels with Fuzzy Time.
In
IEEE Symposium on Security and Privacy (1991).
[19] JACOBSON, V., BRADEN, R., AND BORMAN, D. RFC 1323 -
TCP Extensions for High Performance.
[20] KANG, M. H., AND MOSKOWITZ, I. S. A Data Pump for Com-
munication. Tech. rep., Naval Research Laboratory, 1995.
[21] KANG, M. H., MOSKOWITZ, I. S., AND LEE, D. C. A Net-
work Version of the Pump. In IEEE Symposium on Security and
Privacy (1995).
[22] KANG, M. H., MOSKOWITZ, I. S., MONTROSE, B. E., AND
PARSONESE, J. J. A Case Study Of Two NRL Pump Prototypes.
In ACSAC ’96: Proceedings of the 12th Annual Computer Se-
curity Applications Conference (Washington, DC, USA, 1996),
IEEE Computer Society, p. 32.
[23] KELSEY, J., SCHNEIER, B., WAGNER, D., AND HALL, C. Side
In ESORICS ’98
Channel Cryptanalysis of Product Ciphers.
(1998).
[24] KEMMERER, R. A. A Practical Approach to Identifying Stor-
age and Timing Channels: Twenty Years Later. In ACSAC ’02:
Proceedings of the 18th Annual Computer Security Applications
Conference (Washington, DC, USA, 2002), IEEE Computer So-
ciety, p. 109.
[25] KOCHER, P. C. Timing Attacks on Implementations of Difﬁe-
In CRYPTO (1996),
Hellman, RSA, DSS, and Other Systems.
pp. 104–113.
[26] KOHNO, T., BROIDO, A., AND KC CLAFFY. Remote Physical
Device Fingerprinting. In IEEE Symposium on Security and Pri-
vacy (2005).
[27] LAMPSON, B. W. A Note on the Conﬁnement Problem. In Com-
munications of the ACM (1973), vol. 16.
[28] LEE, P. Combined error-correcting/modulation recording codes.
PhD thesis, Univesity of California, San Diego, 1988.
[29] LEVENSHTEIN, V. I. Binary codes capable of correcting dele-
tions, insertions and reversals. In Soviet Physics Doklady (1966),
vol. 10, pp. 707–710.
[30] LEVINE, B., REITER, M., WANG, C., AND WRIGHT, M. Tim-
ing Attacks in Low-Latency Mix Systems. In Proceedings of Fi-
nancial Cryptography: 8th International Conference (FC 2004):
LNCS-3110 (2004).
[31] MILLEN, J. 20 years of covert channel modeling and analysis.
In IEEE Symposium on Security and Privacy (1999).
USENIX Association
Security ’06: 15th USENIX Security Symposium
75