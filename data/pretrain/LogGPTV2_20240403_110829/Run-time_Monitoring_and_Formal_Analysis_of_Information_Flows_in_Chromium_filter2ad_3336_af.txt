13
considered the same, and the pages will be allowed to access
each other’s DOM.
Domain relaxation can be implemented in our system in
several ways. One is for proﬁle.a.com to have the secrecy
tag F ({proﬁle.a.com},{proﬁle.a.com, login.a.com}), which
allows it to receive secrets from login.a.com; and for login.a.com
to have a corresponding secrecy label.
Another option is to give each page the name.a.com→a.com
reclassiﬁcation capability. This would allow such pages to talk
to a.com, but not yet to each other (because we currently apply
reclassiﬁcation only if necessary to complete a request, and
only on the source entity). To accomplish that, their respective
secrecy tags name.a.com would additionally need to be replaced
with a.com, which could be accomplished by the browser
crawling over the page’s DOM and changing the secrecy tags
of any nodes with the appropriate labels from name.a.com to
a.com.
CSP
A CSP allows a page to specify from where page
resources (e.g., third-party scripts) can be loaded. The policy
applies to images, scripts, etc. CSPs can be broadly interpreted
as policies that a host page sets to constraint the information
ﬂow between the host page and remote servers from which
external resources originate. When the request (e.g., HTTP
GET) is sent
information ﬂows from
the browser to the remote server. The host page can send
arbitrary information to the remote server in this way by, e.g.,
embedding it in the URL string of the HTTP GET request.
Once loaded, external resources such as scripts can interact
with the rest of the page as well as with remote servers.
Our generalized CSP (GCSP) (Section III-B2) can be used
to specify the above-mentioned information-ﬂow constraints
present in CSPs.
to a remote server,
There are two main differences between our GCSP and
the existing CSP. First, the existing CSP takes effect only
at resource-loading time and does not constrain transitive
information ﬂows. E.g.,
if url’s CSP forbids scripts from
ad.com,
it doesn’t mean that an extension’s content script
running in the same page is prevented from sending to or
receiving information from ad.com. GCSP enforces a stricter
policy: Any information tagged with a url secrecy tag cannot
be sent to components that do not have that tag. Second, CSPs
also enforce policies other than information ﬂow. For instance,
not loading resources from an external resource also prevents
the external resource from using local resources such as the
screen or CPU. This will effectively protect the user from
seeing offensive ads, prevent scripts from draining the laptop
battery, etc.
In modern browsers, web pages are allowed to embed third-
party content with little restriction. Our modiﬁed browser has
stricter constraints. To allow web pages to load third-party
content, we explicitly enable two-way communication between
the page and the external resources. For example, the DOM
label from Section III-D explicitly allows the cnn.com page to
receive secrets from ad.com and to reclassify its own secrets to
allow requests to ad.com.
(cid:96)doc1 S = F ({cnn.user},{cnn.∗, ad.∗, google.∗}),
I = {}, D = {+network, cnn.∗→ ad.∗, cnn.∗→ google.∗}
If we wish all label checks to succeed, we can assign
the permissive label (F ({}, allS), allI ,{−allS, +allI}) to ex-
tensions and DOM elements. Here, allS and allI denote all the
secrecy and integrity tags. This label allows an entity to access
and declassify all private data.
postMessage postMessage is a JavaScript API which allows
web pages to communicate across domains on the client side.
postMessage works in two conditions: A parent page embeds
another page in an iframe or a parent page opens another
page in a new tab. In both cases, the API allows two-way
communication. The postMessage send needs to specify the
destination, and the receiver can check the source.
To allow communications using postMessage APIs in our
system, the sender and receiver’s labels need to be adjusted.
If a host page were to send data directly to an iframe from a
different origin, the request would be denied by our browser.
To allow postMessages to work, labels are assigned to the host
and iframed page in similar ways as discussed for the SOP and
CSP.
iframe policies
iframes were introduced as an isolation
mechanism for a parent page to conﬁne untrusted pages. How-
ever, iframes have been abused to embed trusted pages within
malicious pages, which then mount phishing and clickjacking
attacks.
To prevent such attacks, a server can specify, using the
X-Frame-Options header, that the page should not be ren-
dered inside a iframe at all, or should only be rendered inside
an iframe of a page from a speciﬁed origin.
In a pure information-ﬂow approach, disallowing a page
from loading in an iframe cannot easily be done. We can,
however, prevent the parent from gaining information from a
loaded iframe. For example, if a.com tries to place victim.com in
an iframe on its page and receive information from the iframe,
it would have to have a secrecy label that can ﬂoat to include
victim.com’s secrets. To prevent a.com from having a label that
allows this, the browser would have to generate a.com’s label
from something other than a.com’s (self-supplied) CSP. Such
restrictions could be expressed cleanly using our composition
operators (Section III-B2).
VII. CONCLUSION
We develop an approach for reasoning about the informa-
tion ﬂows in a fully ﬂedged web browser. Our approach can
support common browser policies, such as the same-origin
policy, as well as more ﬂexible, practically useful policies that
current browsers cannot. We apply our approach to Chromium,
developing a formal model and corresponding, functional pro-
totype system. A proof of noninterference provides assurance
of the model’s correctness. At the same time, a formal analysis
reveals some limits to the provided protections. Using the
prototype, we experimentally validate the ability of our design
to offer additional protection while continuing to support
standard browsing functionality.
We believe our approach and model show one way to strike
a balance between practicality and formal guarantees. As such,
the approach we explored serves as a step towards developing
rich information-ﬂow enforcement models that acknowledge
practical constraints.
14
ACKNOWLEDGMENT
This
research was
supported in part by US Navy
grant N000141310156; NSF grants 0917047, 1018211, and
1320470; and the Singapore National Research Foundation
under its International Research Centre @ Singapore Funding
Initiative and administered by the IDM Programme Ofﬁce.
REFERENCES
[1]
64px.com.
https://chrome.google.com/webstore/detail/facebook-for-
chrome/gdalhedleemkkdjddjgfjmcnbpejpapp.
Facebook
for
Chrome,
2014.
[2] S. A. Zdancewic. Programming Languages for Information Security.
PhD thesis, Cornell University, 2002.
[3] S. Agarwal.
Session hijacking or cookie stealing using PHP and
JavaScript, 2011. http://www.martani.net/2009/08/xss-steal-passwords-
using-javascript.html.
[4] O. Arden, M. D. George, J. Liu, K. Vikram, A. Askarov, and A. C.
Myers. Sharing mobile code securely with information ﬂow control. In
Proc. IEEE S&P, 2012.
[5] T. H. Austin and C. Flanagan. Efﬁcient purely-dynamic information
ﬂow analysis. In Proceedings of the ACM SIGPLAN Fourth Workshop
on Programming Languages and Analysis for Security, PLAS ’09, 2009.
[6] T. H. Austin and C. Flanagan. Multiple facets for dynamic information
ﬂow. In Proc. POPL, 2012.
[7] S. Bandhakavi, N. Tiku, W. Pittman, S. T. King, P. Madhusudan, and
M. Winslett. Vetting browser extensions for security vulnerabilities with
VEX. Commun ACM, 54(9):91–99, Sept. 2011.
[8] A. Barth, A. P. Felt, P. Saxena, and A. Boodman. Protecting browsers
from extension vulnerabilities. In Proc. NDSS, 2010.
[9] A. Barth, C. Jackson, and J. C. Mitchell. Robust defenses for cross-site
request forgery. In Proc. CCS, 2008.
[10] A. Barth, C. Jackson, C. Reis, and T. G. C. Team. The security
architecture of the Chromium browser. Technical report, 2008.
[11] L. Bauer, S. Cai, L. Jia, T. Passaro, M. Stroucken, and Y. Tian.
Run-time monitoring and formal analysis of information ﬂows in
Chromium. Technical Report CMU-CyLab-14-015, CyLab, Carnegie
Mellon University, 2014.
[12] L. Bauer, S. Cai, L. Jia, T. Passaro, and Y. Tian. Analyzing the dangers
posed by Chrome extensions. In Proc. IEEE CNS, 2014.
[13] A. Bichhawat, V. Rajani, D. Garg, and C. Hammer. Information ﬂow
control in WebKit’s JavaScript bytecode. In POST, 2014.
[14] K. Boda, ´A. M. F¨oldes, G. G. Guly´as, and S. Imre. User tracking
In Information Security
on the web via cross-browser ﬁngerprinting.
Technology for Applications. 2012.
[15] A. Bohannon and B. C. Pierce. Featherweight Firefox: Formalizing the
core of a web browser. In Proc. USENIX WebApps, 2010.
[16] A. Chudnov and D. A. Naumann. Information ﬂow monitor inlining.
In Proc. IEEE CSF, 2010.
[17] R. Chugh, J. A. Meister, R. Jhala, and S. Lerner. Staged information
ﬂow for JavaScript. In Proc. PLDI, 2009.
[18] R. S. Cox, S. D. Gribble, H. M. Levy, and J. G. Hansen. A safety-
oriented platform for web applications. In Proc. IEEE S&P, 2006.
[19] W. De Groef, D. Devriese, N. Nikiforakis, and F. Piessens. FlowFox:
A web browser with ﬂexible and precise information ﬂow control. In
Proc. ACM CCS, 2012.
[20] D. Devriese and F. Piessens. Noninterference through secure multi-
execution. In Proc. IEEE S&P, 2010.
[21] E. W. Felten and M. A. Schneider. Timing attacks on web privacy. In
Proc. ACM CCS, 2000.
[22] D. Fett, R. K¨usters, and G. Schmitz. An expressive model for the
Web infrastructure: Deﬁnition and application to the Browser ID SSO
system. In Proc. IEEE S&P, 2014.
Google
[23] Google.com.
checker,
2014.
mail
https://chrome.google.com/webstore/detail/google-mail-
checker/mihcahmgecmbnbcchbopgniﬂfhgnkff.
[24] W. Gordon. Many browser extensions have become adware or mal-
http://lifehacker.com/many-browser-
ware. Check yours now, 2014.
extensions-have-become-adware-or-malware-1505117457.
[25] C. Grier, S. Tang, and S. T. King. Designing and implementing the OP
and OP2 web browsers. ACM Trans Web, 5(2):11:1–11:35, May 2011.
J. Grossman. XSS Attacks: Cross-site scripting exploits and defense.
Syngress, 2007.
[26]
[27] D. Hedin, A. Birgisson, L. Bello, and A. Sabelfeld. JSFlow: Tracking
information ﬂow in JavaScript and its APIs. In Proc. ACM SAC, 2014.
Information-ﬂow security for a core of
[28] D. Hedin and A. Sabelfeld.
JavaScript. In Proc. IEEE CSF, 2012.
[29] L.-S. Huang, A. Moshchuk, H. J. Wang, S. Schechter, and C. Jackson.
Clickjacking: attacks and defenses. In Proc. USENIX Security, 2012.
IETF.
2013.
header
http://tools.ietf.org/html/rfc7034.
X-Frame-Options,
HTTP
ﬁeld
[30]
[31] D. Jang, R. Jhala, S. Lerner, and H. Shacham. An empirical study of
privacy-violating information ﬂows in JavaScript web applications. In
Proc. ACM CCS, 2010.
Jia,
[32] L.
J. Aljuraidan, E. Fragkaki, L. Bauer, M. Stroucken,
K. Fukushima, S. Kiyomoto, and Y. Miyake. Run-time enforcement
of information-ﬂow properties on Android. In Proc. ESORICS, 2013.
[33] M. Krohn, A. Yip, M. Brodsky, N. Cliffer, M. F. Kaashoek, E. Kohler,
and R. Morris. Information ﬂow control for standard OS abstractions.
In Proc. SOSP, 2007.
[34] L. Liu, X. Zhang, and S. Chen. Botnet with browser extensions.
Proc. IEEE SocialCom, 2011.
In
[35] R. S. Liverani and N. Freeman. Abusing Firefox extensions, 2009.
http://www.defcon.org/images/defcon-17.
[36] F. Martani.
http://www.martani.net/2009/08/xss-steal-passwords-using-
javascript.html.
XSS, Passwords
theft using JavaScript, 2009.
[37] S. Moore and S. Chong. Static analysis for efﬁcient hybrid information-
ﬂow control. In Proc. IEEE CSF, 2011.
[38] A. C. Myers. Practical mostly-static information ﬂow control. In Proc.
POPL, 1999.
[39] F. Roesner, T. Kohno, A. Moshchuk, B. Parno, H. J. Wang, and
C. Cowan. User-driven access control: Rethinking permission granting
in modern operating systems. In Proc. IEEE S&P, 2012.
[40] A. Russo and A. Sabelfeld. Dynamic vs. static ﬂow-sensitive security
analysis. In Proc. IEEE CSF, 2010.
[41] A. Sabelfeld and A. C. Myers. Language-based information-ﬂow
security. IEEE J Sel Area Comm, 21(1):5–19, 2003.
[42] D. Stefan, E. Z. Yang, B. Karp, P. Marchenko, A. Russo, and
D. Mazi`eres. Protecting users by conﬁning JavaScript with COWL.
In Proc. OSDI, 2014.
[43] S. Tang, H. Mai, and S. T. King. Trust and protection in the Illinois
browser operating system. In Proc. OSDI, 2010.
[44] W3C. Content Security Policy 1.1, 2014.
/CSP11/.
http://www.w3.org/TR
[45] H. J. Wang, C. Grier, A. Moshchuk, S. T. King, P. Choudhury, and
H. Venter. The multi-principal OS construction of the Gazelle web
browser. In Proc. USENIX Security, 2009.
J. Wang, X. Li, X. Liu, X. Dong, J. Wang, Z. Liang, and Z. Feng. An
empirical study of dangerous behaviors in Firefox extensions. In ISC,
2012.
[46]
[47] Y.-M. Wang, D. Beck, X. Jiang, R. Roussev, C. Verbowski, S. Chen,
In
and S. King. Automated web patrol with strider honeymonkeys.
Proc. NDSS, 2006.
[48] E. Z. Yang, D. Stefan, J. Mitchell, D. Mazi`eres, P. Marchenko, and
B. Karp. Toward principled browser security. In Proc. HotOS, 2013.
[49] A. Yip, N. Narula, M. Krohn, and R. Morris. Privacy-preserving
browser-side scripting with BFlow. In Proc. EuroSys, 2009.
15