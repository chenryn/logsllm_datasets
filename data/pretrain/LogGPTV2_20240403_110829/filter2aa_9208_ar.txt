\&\s-1VERSION\s0 may be either a numeric argument such as 5.006, which will be
compared to \f(CW$]\fR, or a literal of the form v5.6.1, which will be compared
to \f(CW$^V\fR (aka \f(CW$PERL_VERSION\fR).  A fatal error is produced at run time if
\&\s-1VERSION\s0 is greater than the version of the current Perl interpreter.
Compare with \*(L"use\*(R", which can do a similar check at compile time.
.Sp
Specifying \s-1VERSION\s0 as a literal of the form v5.6.1 should generally be
avoided, because it leads to misleading error messages under earlier
versions of Perl which do not support this syntax.  The equivalent numeric
version should be used instead.
.Sp
.Vb 3
\&    require v5.6.1;     # run time version check
\&    require 5.6.1;      # ditto
\&    require 5.006_001;  # ditto; preferred for backwards compatibility
.Ve
.Sp
Otherwise, demands that a library file be included if it hasn't already
been included.  The file is included via the do-FILE mechanism, which is
essentially just a variety of \f(CW\*(C`eval\*(C'\fR.  Has semantics similar to the following
subroutine:
.Sp
.Vb 20
\&    sub require {
\&        my($filename) = @_;
\&        return 1 if $INC{$filename};
\&        my($realfilename,$result);
\&        ITER: {
\&            foreach $prefix (@INC) {
\&                $realfilename = "$prefix/$filename";
\&                if (-f $realfilename) {
\&                    $INC{$filename} = $realfilename;
\&                    $result = do $realfilename;
\&                    last ITER;
\&                }
\&            }
\&            die "Can't find $filename in \e@INC";
\&        }
\&        delete $INC{$filename} if $@ || !$result;
\&        die $@ if $@;
\&        die "$filename did not return true value" unless $result;
\&        return $result;
\&    }
.Ve
.Sp
Note that the file will not be included twice under the same specified
name.  The file must return true as the last statement to indicate
successful execution of any initialization code, so it's customary to
end such a file with \f(CW\*(C`1;\*(C'\fR unless you're sure it'll return true
otherwise.  But it's better just to put the \f(CW\*(C`1;\*(C'\fR, in case you add more
statements.
.Sp
If \s-1EXPR\s0 is a bareword, the require assumes a "\fI.pm\fR\*(L" extension and
replaces \*(R"\fI::\fR\*(L" with \*(R"\fI/\fR" in the filename for you,
to make it easy to load standard modules.  This form of loading of
modules does not risk altering your namespace.
.Sp
In other words, if you try this:
.Sp
.Vb 1
\&        require Foo::Bar;    # a splendid bareword
.Ve
.Sp
The require function will actually look for the "\fIFoo/Bar.pm\fR" file in the
directories specified in the \f(CW@INC\fR array.
.Sp
But if you try this:
.Sp
.Vb 4
\&        $class = 'Foo::Bar';
\&        require $class;      # $class is not a bareword
\&    #or
\&        require "Foo::Bar";  # not a bareword because of the ""
.Ve
.Sp
The require function will look for the "\fIFoo::Bar\fR\*(L" file in the \f(CW@INC\fR array and
will complain about not finding \*(R"\fIFoo::Bar\fR" there.  In this case you can do:
.Sp
.Vb 1
\&        eval "require $class";
.Ve
.Sp
Now that you understand how \f(CW\*(C`require\*(C'\fR looks for files in the case of
a bareword argument, there is a little extra functionality going on
behind the scenes.  Before \f(CW\*(C`require\*(C'\fR looks for a "\fI.pm\fR\*(L" extension,
it will first look for a filename with a \*(R"\fI.pmc\fR" extension.  A file
with this extension is assumed to be Perl bytecode generated by
B::Bytecode.  If this file is found, and it's modification
time is newer than a coinciding "\fI.pm\fR\*(L" non-compiled file, it will be
loaded in place of that non-compiled file ending in a \*(R"\fI.pm\fR" extension.
.Sp
You can also insert hooks into the import facility, by putting directly
Perl code into the \f(CW@INC\fR array.  There are three forms of hooks: subroutine
references, array references and blessed objects.
.Sp
Subroutine references are the simplest case.  When the inclusion system
walks through \f(CW@INC\fR and encounters a subroutine, this subroutine gets
called with two parameters, the first being a reference to itself, and the
second the name of the file to be included (e.g. "\fIFoo/Bar.pm\fR").  The
subroutine should return \f(CW\*(C`undef\*(C'\fR or a filehandle, from which the file to
include will be read.  If \f(CW\*(C`undef\*(C'\fR is returned, \f(CW\*(C`require\*(C'\fR will look at
the remaining elements of \f(CW@INC\fR.
.Sp
If the hook is an array reference, its first element must be a subroutine
reference.  This subroutine is called as above, but the first parameter is
the array reference.  This enables to pass indirectly some arguments to
the subroutine.
.Sp
In other words, you can write:
.Sp
.Vb 5
\&    push @INC, \e&my_sub;
\&    sub my_sub {
\&        my ($coderef, $filename) = @_;  # $coderef is \e&my_sub
\&        ...
\&    }
.Ve
.Sp
or:
.Sp
.Vb 7
\&    push @INC, [ \e&my_sub, $x, $y, ... ];
\&    sub my_sub {
\&        my ($arrayref, $filename) = @_;
\&        # Retrieve $x, $y, ...
\&        my @parameters = @$arrayref[1..$#$arrayref];
\&        ...
\&    }
.Ve
.Sp
If the hook is an object, it must provide an \s-1INC\s0 method, that will be
called as above, the first parameter being the object itself.  (Note that
you must fully qualify the sub's name, as it is always forced into package
\&\f(CW\*(C`main\*(C'\fR.)  Here is a typical code layout:
.Sp
.Vb 7
\&    # In Foo.pm
\&    package Foo;
\&    sub new { ... }
\&    sub Foo::INC {
\&        my ($self, $filename) = @_;
\&        ...
\&    }
.Ve
.Sp
.Vb 2
\&    # In the main program
\&    push @INC, new Foo(...);
.Ve
.Sp
Note that these hooks are also permitted to set the \f(CW%INC\fR entry
corresponding to the files they have loaded. See \*(L"%INC\*(R" in perlvar.
.Sp
For a yet-more-powerful import facility, see \*(L"use\*(R" and perlmod.
.IP "reset \s-1EXPR\s0" 8
.IX Item "reset EXPR"
.PD 0
.IP "reset" 8
.IX Item "reset"
.PD
Generally used in a \f(CW\*(C`continue\*(C'\fR block at the end of a loop to clear
variables and reset \f(CW\*(C`??\*(C'\fR searches so that they work again.  The
expression is interpreted as a list of single characters (hyphens
allowed for ranges).  All variables and arrays beginning with one of
those letters are reset to their pristine state.  If the expression is
omitted, one-match searches (\f(CW\*(C`?pattern?\*(C'\fR) are reset to match again.  Resets
only variables or searches in the current package.  Always returns
1.  Examples:
.Sp
.Vb 3
\&    reset 'X';          # reset all X variables
\&    reset 'a-z';        # reset lower case variables
\&    reset;              # just reset ?one-time? searches
.Ve
.Sp
Resetting \f(CW"A\-Z"\fR is not recommended because you'll wipe out your
\&\f(CW@ARGV\fR and \f(CW@INC\fR arrays and your \f(CW%ENV\fR hash.  Resets only package
variables\*(--lexical variables are unaffected, but they clean themselves
up on scope exit anyway, so you'll probably want to use them instead.
See \*(L"my\*(R".
.IP "return \s-1EXPR\s0" 8
.IX Item "return EXPR"
.PD 0
.IP "return" 8
.IX Item "return"
.PD
Returns from a subroutine, \f(CW\*(C`eval\*(C'\fR, or \f(CW\*(C`do FILE\*(C'\fR with the value
given in \s-1EXPR\s0.  Evaluation of \s-1EXPR\s0 may be in list, scalar, or void
context, depending on how the return value will be used, and the context
may vary from one execution to the next (see \f(CW\*(C`wantarray\*(C'\fR).  If no \s-1EXPR\s0
is given, returns an empty list in list context, the undefined value in
scalar context, and (of course) nothing at all in a void context.
.Sp
(Note that in the absence of an explicit \f(CW\*(C`return\*(C'\fR, a subroutine, eval,
or do \s-1FILE\s0 will automatically return the value of the last expression
evaluated.)
.IP "reverse \s-1LIST\s0" 8
.IX Item "reverse LIST"
In list context, returns a list value consisting of the elements
of \s-1LIST\s0 in the opposite order.  In scalar context, concatenates the
elements of \s-1LIST\s0 and returns a string value with all characters
in the opposite order.
.Sp
.Vb 1
\&    print reverse <>;           # line tac, last line first
.Ve
.Sp
.Vb 2
\&    undef $/;                   # for efficiency of <>
\&    print scalar reverse <>;    # character tac, last line tsrif
.Ve
.Sp
This operator is also handy for inverting a hash, although there are some
caveats.  If a value is duplicated in the original hash, only one of those
can be represented as a key in the inverted hash.  Also, this has to
unwind one hash and build a whole new one, which may take some time
on a large hash, such as from a \s-1DBM\s0 file.
.Sp
.Vb 1
\&    %by_name = reverse %by_address;     # Invert the hash
.Ve
.IP "rewinddir \s-1DIRHANDLE\s0" 8
.IX Item "rewinddir DIRHANDLE"
Sets the current position to the beginning of the directory for the
\&\f(CW\*(C`readdir\*(C'\fR routine on \s-1DIRHANDLE\s0.
.IP "rindex \s-1STR\s0,SUBSTR,POSITION" 8
.IX Item "rindex STR,SUBSTR,POSITION"
.PD 0
.IP "rindex \s-1STR\s0,SUBSTR" 8
.IX Item "rindex STR,SUBSTR"
.PD
Works just like \fIindex()\fR except that it returns the position of the \s-1LAST\s0
occurrence of \s-1SUBSTR\s0 in \s-1STR\s0.  If \s-1POSITION\s0 is specified, returns the
last occurrence at or before that position.
.IP "rmdir \s-1FILENAME\s0" 8
.IX Item "rmdir FILENAME"
.PD 0
.IP "rmdir" 8
.IX Item "rmdir"
.PD
Deletes the directory specified by \s-1FILENAME\s0 if that directory is
empty.  If it succeeds it returns true, otherwise it returns false and
sets \f(CW$!\fR (errno).  If \s-1FILENAME\s0 is omitted, uses \f(CW$_\fR.
.IP "s///" 8
.IX Item "s///"
The substitution operator.  See perlop.
.IP "scalar \s-1EXPR\s0" 8
.IX Item "scalar EXPR"
Forces \s-1EXPR\s0 to be interpreted in scalar context and returns the value
of \s-1EXPR\s0.
.Sp
.Vb 1
\&    @counts = ( scalar @a, scalar @b, scalar @c );
.Ve
.Sp
There is no equivalent operator to force an expression to
be interpolated in list context because in practice, this is never
needed.  If you really wanted to do so, however, you could use
the construction \f(CW\*(C`@{[ (some expression) ]}\*(C'\fR, but usually a simple
\&\f(CW\*(C`(some expression)\*(C'\fR suffices.
.Sp
Because \f(CW\*(C`scalar\*(C'\fR is unary operator, if you accidentally use for \s-1EXPR\s0 a
parenthesized list, this behaves as a scalar comma expression, evaluating
all but the last element in void context and returning the final element
evaluated in scalar context.  This is seldom what you want.
.Sp