# 系统调用
> 原文：
## 介绍
系统调用是进入内核的受控入口点，允许进程请求内核代表进程执行某些操作。内核通过系统调用应用编程接口(API)使程序可以访问一系列服务。应用开发人员通常不能直接访问系统调用，但是可以通过这个 API 访问它们。例如，这些服务包括创建新进程、执行 I/O 和创建进程间通信管道。系统调用集是固定的。每个系统调用都有一个唯一的编号。不同系统调用的列表可以在[这里](https://man7.org/linux/man-pages/man2/syscall.2.html)找到。
系统调用将处理器状态从用户模式更改为内核模式，因此 CPU 可以访问受保护的内核内存。每个系统调用可以具有一组参数，这些参数指定要从用户空间(即，进程的虚拟地址空间)传输到内核空间的信息，反之亦然。从编程的角度来看，调用系统调用看起来很像调用 C 函数。
## 系统调用的类型
主要有 5 种不同的系统调用。它们是:
*   流程控制:这些系统调用用于处理与流程相关的任务，如流程创建、终止等。
*   文件管理:这些系统调用用于文件操作，比如读/写文件。
*   设备管理:这些系统调用用于处理设备，比如读取/写入设备缓冲区。
*   信息维护:这些系统调用处理信息及其在操作系统和用户程序之间的传输。
*   通信:这些系统调用对于进程间通信非常有用。它们还用于创建和删除通信连接。
| 系统调用的类型 | Linux 中的例子 |
| --- | --- |
| 过程控制 | fork()，exit()，wait() |
| 文件管理 | 打开()，读取()，写入() |
| 设备管理 | ioctl()，read()，write() |
| 信息维护 | getpid()，alarm()，sleep() |
| 沟通 | pipe()、shmget()、mmap() |
## 用户模式、内核模式及其转换
现代处理器架构通常允许 CPU 在至少两种不同的模式下运行:用户模式和内核模式。相应地，虚拟内存区域可以被标记为用户空间或内核空间的一部分。当在用户模式下运行时，CPU 只能访问标记为在用户空间中的内存；试图访问内核空间中的内存会导致硬件异常。
在任何给定的时间，进程可能在用户模式或内核模式下执行。可以执行的指令类型取决于模式，这是在硬件级别强制执行的。CPU 模式(也称为处理器模式、CPU 状态、CPU 特权级别)是一些计算机体系结构的中央处理单元的操作模式，其对由 CPU 运行的某些进程可以执行的操作的类型和范围进行限制。内核本身不是进程，而是进程管理器。内核模型假设需要内核服务的进程使用称为系统调用的特定编程结构。
当程序在用户模式下执行时，它不能直接访问内核数据结构或内核程序。然而，当应用在内核模式下执行时，这些限制不再适用。程序通常在用户模式下执行，只有在请求内核提供的服务时才切换到内核模式。如果应用需要访问系统上的硬件资源(如外设、内存、磁盘)，它必须发出一个系统调用，这将导致从用户模式到内核模式的上下文切换。当从/向文件等读取/写入时，遵循该过程。在内核模式下运行的只是系统调用本身，而不是应用代码。当系统调用完成时，进程返回到用户模式，并使用反向上下文切换返回返回值。除了系统调用，内核例程也可以通过以下方式激活:
*   执行该进程的 CPU 发出异常信号，这是一种异常情况，如无效指令。内核代表引发异常的进程处理异常。
*   外围设备向 CPU 发出一个中断信号，通知它一个事件，如请求注意、状态改变或 I/O 操作完成。每个中断信号都由一个称为中断处理程序的内核程序处理。由于外围设备相对于 CPU 异步运行，中断会在不可预知的时间发生。
*   执行内核线程。因为它运行在内核模式，相应的程序必须被认为是内核的一部分。
![ ](img/dd41e671461383baafc1f0974d16be85.png)
在上图中，用户模式下的进程 1 发出一个系统调用，之后进程切换到内核模式，系统调用得到服务。然后，进程 1 继续在用户模式下执行，直到定时器中断发生，并且调度程序在内核模式下被激活。发生进程切换，进程 2 在用户模式下开始执行，直到硬件设备发出中断。作为中断的结果，进程 2 切换到内核模式并处理该中断。
## *write()* 系统调用的工作方式
系统调用 *write()* 将数据写入一个打开的文件。
```sh
# include 
ssize_t write(int fd, void *buffer, size_t count); 
```
*buffer* 是要写入的数据的地址； *count* 是从缓冲区写入的字节数；并且 *fd* 是指数据将被写入的文件的文件描述符。
*write()* 调用从缓冲区向由 *fd* 引用的打开文件写入多达*计数*字节。成功时， *write()* 调用返回实际写入的字节数，可能小于*计数*，出错时返回-1。当对磁盘文件执行 I/O 时，从 *write()* 成功返回并不保证数据已经传输到磁盘，因为内核执行磁盘 I/O 缓冲是为了减少磁盘活动并加快 *write()* 调用。它只是在用户空间缓冲区和内核缓冲区缓存中的缓冲区之间复制数据。稍后，内核会将其缓冲区写入(刷新)到磁盘。
如果在此期间，另一个进程试图读取文件的这些字节，那么内核会自动从缓冲区缓存中提供数据，而不是从文件(过时的内容)中提供数据。这种设计的目的是让 *write()* 更快，因为它们不需要等待(缓慢的)磁盘操作。这种设计也很有效，因为它减少了内核必须执行的磁盘传输次数。
## 用 strace 在 Linux 中调试
strace 是一个用来跟踪用户进程和 Linux 内核之间转换的工具。为了使用该工具，我们需要通过运行以下命令来确保它已安装在系统中:
```sh
$ rpm -qa | grep -i strace
strace-4.12-9.el7.x86_64 
```
如果上述命令没有给出任何输出，您可以通过以下方式安装该工具:
`$ yum install strace`
作为标准 C 库一部分的函数被称为库函数。这些函数的用途非常广泛，包括打开文件、将时间转换为人类可读的格式以及比较两个字符串等任务。一些库函数位于系统调用之上。通常，库函数被设计成提供一个比底层系统调用更友好的接口。例如， *printf()* 函数提供输出格式化和数据缓冲，而 *write()* 系统调用只输出一个字节块。Linux 上最常用的标准 C 库实现是 GNU C 库 [glibc](http://www.gnu.org/software/libc/) 。
C 编程语言提供了 *printf()* ，让用户以多种不同的格式编写数据。因此，printf()作为一个函数将您的数据转换成格式化的字节序列，并调用 *write()* 将这些字节写入输出。让我们看看当使用 *strace* 命令:`strace printf %s “Hello world”`执行 *printf()* 语句时会发生什么
```sh
 ~]$ strace printf %s "Hello world"
execve("/usr/bin/printf", ["printf", "%s", "Hello world"], [/* 47 vars */]) = 0
brk(NULL)                               = 0x90d000
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f8fc672f000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=98854, ...}) = 0
mmap(NULL, 98854, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f8fc6716000
close(3)                                = 0
open("/lib64/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\20&\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2156160, ...}) = 0
mmap(NULL, 3985888, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f8fc6141000
mprotect(0x7f8fc6304000, 2097152, PROT_NONE) = 0
mmap(0x7f8fc6504000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c3000) = 0x7f8fc6504000
mmap(0x7f8fc650a000, 16864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f8fc650a000