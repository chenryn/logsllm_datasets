根结点的子树的最优程序组成，最后是计算根结点值的指令。这个性质支持我们使用一个动
后处理右子树的－-部分，再处理左子树的另一部分，如此往复。使用本节中的机器对任意－一个
这些树的最优机器语言程序必须首先对根的左子树的一部分进行求值并把结果存放到寄存器中，
为了计算结点n的代价 C[订，我们像8.9节中那样把指令看作是树重写规则。考虑和结点
吉果存放在一个寄存器中（而不是内存中），然后计算T2，然后再回过来计算T，的其余部分。
1
3）使用每个结点的代价向量和相关指令来遍历各棵子树并生成最终的目标代码。在这个过
 2）遍历T，使用代价向量(数组)来决定T的哪棵子树应该被计算并保存到内存中。
上面定义的连续求值的性质保证了对于任何表达式树 T，总是存在一个最优程序。这个程序
对于本节中的寄存器机器，我们可以证明对于任何一-个计算表达式树T的机器语言程序 P,
我们说--个程序 P连续计算--棵树T，如果它首先计算那些需要计算值并将其存放到内存中
计算一个结点n的代价包括在给定寄存器数量的情况下对S求值时所需要的全部加载和保
上述每一个步骤都可以高效地实现，运行所需时间与表达式树的大小成线性关系。
动态规划算法有三个步骤(假设目标机器具有个寄存器)：
相对而言，使用偶数－奇数寄存器对的计算机不一定总是具有最优的连续求值过程。x86 体
这
3）
2）
1）P'的代价不高于P的代价。
这个结果表明，每个表达式树可以用一个连续程序最优地求值。.
P'连续地对该树求值。
P"使用的寄存器不多于P使用的寄存器，而且
369
老
只
扣
---
## Page 386
在根结点处的代价向量是(8,8,7)。
价再加上1。也就是说，我们首先计算根结点并将其存放到－-个寄存器中，然后保存结果。因此
5 +2+1=8。
并存放到 RO 中，并使用指令 ADD R0，RO，R1计算根结点。这个指令序列的代价为4+2+1=7。
价是5+2+1=8。
子树的值并放到寄存器 R1中，并使用指令 ADD RO，RO，R1来计算根结点。这个指令序列的代
以及对根结点的左右子树求值的不同顺序，需要考虑三种情况。
只有--个可用寄存器的情况下对根结点求值的最小代价是5+2+1=8。
指令的代价1。不存在其他的最小代价的计算方式。在根结点的左右子结点上的代价向量说明在
右子树求值并存放到内存的最小代价，加上计算其左子树并保存到寄存器的最小代价，再加上该
使用这个指令，在只有一个可用寄存器的情况下对根结点求值的最小代价的计算方法如下：对其
结点所需的最小代价。因为根结点的标号是+，所以机器指令 ADD RO，RO，M和根结点匹配。
一个可用寄存器的情况下的代价是一样的。因此，在叶子结点a上的代价向量是(0，1，1)。
-个寄存器中。C[2]（即在有两个可用寄存器的情况下把a加载到一个寄存器中的代价)和只有
C[1](即计算α并保存到-个寄存器的代价)是1，因为我们可以使用指令 LD RO，a 把它加载到
子结点a处的代价向量。C[0］（即计算a 并保存到内存的代价)是0，因为它已经在内存中了
个结点的代价向量。这些向量在图中各个结点的旁边显示。为了说明代价计算方法，考虑在叶
运算符。
例8.28
3）计算右子树的值并保存到内存位置M中，使用两个可用寄存器计算左子树的值并保存到
2）使用两个可用寄存器计算右子树的值并存放到 R1中，使用一个可用寄存器计算左子树的值
1）使用两个可用寄存器计算左子树的值并放到寄存器 RO中，使用一个可用寄存器计算右
计算根结点的值并保存到内存中的代价等于使用所有可用寄存器计算根结点的值的最小代
现在考虑有两个可用寄存器时对根结点求值的最小代价。根据用于计算根结点的不同指令
让我们应用动态规划算法为图8-26 中的语法树生成最优的代码。在第一步中，我们计算每
370
可见，第二种选择给出了最小的代价7。
考虑一下根结点处的代价向量。我们首先确定在有一个及两个可用寄存器的情况下计算根
在这些指令中，Ri 可以是 RO 或者 R1，而 yj则是--个内存位置。运算符 op 对应于某个算术
R2
，
考虑有两个寄存器 RO、R1及下列的指令的机器。每个指令的代价是一个成本单位：
(0,1,1)
3
图8-26表达式(a-b）+C*（d/e)的语法树，每个结点都标有代价向量
(3,2,2)
二
"
2.2.
① (0,1,1)
(8,8,7) 
 (0. 1, 1)
@(0, 1,1)
(5,5,4) 
 (0, 1, 1)
第8章
---
## Page 387
8.12第8章总结
练习 8.9.1中的语句生成代码。
8.11.38.11节的练习
因为动态规划技术可以用到很多类型的机器上，这个技术促进了编译器的可重定向特性的发展。
器
代码生成
●代码生成是编译器的最后一个步骤。代码生成器把前端生成的中间表示形式映射为目标
！！练习8.11.2：你将如何扩展动态规划技术，以便在DAG 的基础上生成最优代码？
动态规划技术已经在很多编译器中使用，这些编译器包括可移植C 编译器版本2，即 PCC2。
根据代价向量，我们可以很容易地通过对树的遍历构造出代码序列。假设有两个可用寄存
LD
33
网
）Ershov 数指出了如果不把任何临时值保存回内存中，对一个表达式求值需要多少个寄
CISC 机器通常是一个二地址机器。它的寄存器相对较少，有几种寄存器类型，并具有复
程序。如果存在一个代码优化阶段，那么代码生成器的输入就是代码优化器生成的中间
18-26的树的最优代码序列是：
存器。
态规划技术来为多种类型的机器和表达式生成最优的覆盖方式。
来逐步覆盖一棵语法树。我们可以把树重写规则和相应的指令代价关联起来，并应用动
指令选择可以通过一个树重写过程完成。在这个过程中，对应于机器指令的树模式被用
窥孔优化是一种提高代码质量的局部变换。它通常通过一个滑动窗口作用于一个程序。
基本块的 DAG 表示是一个有向无环图。DAG 中的结点表示基本块中的语句，而一个结点
流图中的循环是一个强连通的区域。这个区域只有一个被称为循环首结点的人口。
何在基本块之间流动。
基本块是一个三地址语句的最大连续序列。控制流只能从它的第一个语句进入，并从最
杂寻址模式的可变长指令。
言生成。
虚拟机是一些字节代码中间语言的解释程序，这些字节代码是为诸如Java 和C#这样的语
可重定向编译器是能够为多个指令集生成代码的编译器。
寄存器指派是决定用哪个寄存器来存放一个给定的 IR值的过程。
完成寄存器分配的有效技术。
指令选择是为每个中间表示语句选择目标语言指令的过程。
表示形式。
二
=
371
---
## Page 388
在他们的简单有效的代码生成器的生成器中进一步精化了这些思想。
Tjiang[2]把高效的树模式匹配技术和动态规划技术结合起来。Fraser、Hanson 和 Proebsting[10]
展成为多个基于树模式匹配的代码生成工具［14］。在代码生成工具twig 中，Aho、Ganapathi 和
和 Graham[11]使用 LR 语法分析器生成技术来处理指令的自动选择。表格驱动的代码生成器发
存器分配的图分划和重写技术的讨论。
描述了他们的可用于寄存器分配的基于优先级的着色算法。在[6］中可以见到针对最新的用于寄
种图着色算法的变体。我们处理图着色的方法来自于 Chaitin[3］[4］。Chow 和 Hennessy在[5］中
存器分配技术是由 Cocke、Ershov[8］和 Schwartz[15]提出的。针对寄存器分配，人们提出了很多
实现中[13］。
循环执行时用固定数量寄存器存放变量的策略。这个策略被 Lowry 和 Medlock 用在 Fortran H的
（比如 Pentium 芯片）的体系结构。在1963 年交付的 Burroughs B5000是--个早期的栈计算机。
多数在1990 年之后安装的通用计算机仍然是 CISC 机器，因为它们都基于 Intel 80x86 或其后代
指令集时需要做出的权衡进行了很好的讨论。
最优代码。Hennessy 和Patterson[12］对 CISC 和 RISC 机器体系结构的发展，以及在设计一个好的
术表达式生成最优代码。Aho 和Johnson[1]使用动态规划技术来为 CISC 机器上的表达式树生成
8.13第8 章参考文献 
体系结构在1990 年之后才流行起来。在1990 年之前设计的很多计算机都是CISC机器，然而大
[7］。Sethi 和 Ullman[16]在--个算法中使用了这种标号方法。他们还证明了这种算法可以为算
词法分析器和语法分析器的自动生成工具刺激了模式制导的指令选择技术的发展。Glanville
高效的寄存器分配技术在编译器出现的最早时代就开始研究了。把图着色算法作为一种寄
本章中给出的很多关于代码生成的启发式规则已经被用到不同的编译器中。我们描述了在
虽然RISC的历史可以追溯到更早的计算机中，比如最先在1964年交付的CDC6600，但 RISC
本章中讨论的很多技术在最早的编译器中就出现了。Ershov 的加标号算法出现在1958 年
72
存器中腾出空间，以保存另一个值。
1. Aho, A. V. and S. C. Johnson, “Optimal code generation for expression 
register allocation,"
 SIGPLAN Notices 17:6 (1982), pp. 201-207.
trees," J. ACM 23:3, pp. 488-501.
12:4 (1990), pp. 501-536.
Languages 6:1 (1981), pp. 47-57.
第8章
---
## Page 389
代码生成
16. Sethi, R. and J. D. Ullman, "The generation of optimal code for arithmetic
15.
12.
10.
8. Ershov, A. P., The Alpha Automatic Prograrnming Systen, Academie
 6. Cooper, K. D. and L. Torczon, Engineering a Conpiler, Morgan Kauf-
expressions," J. ACM 17:4 (1970), pp. 715-728.
Hennessy, J. L. and D. A. Patterson, Computer Architecture: A Quanti
Press, New York, 1971.
 mann, San Francisco CA, 2004.
New York, 1973.
Schwartz, J. T.,
ACM 12:1 (1969), Pp. 13-22.
tative Approach, Third Edition, Morgan Kaufman, San Francisco, 2003.
Languages (1978), pp. 231--240.
Glanville, R. S. and S. L. Graham, "A new methiod for compiler code gen-
Languages and Systems 1:3 (1992), pp. 213-226.
Fischer, C. N. and R. J. LeBlanc,
pp.294-308.
Lowry,
1:8 (1958), pp. 3-6. Also, Comm. ACM 1:9 (1958), p. 16.
E. S. and C. W. Medlock, "Object code optimization,” Comm.
Rec. Fifth ACM Symposium on Principles of Programming
 Crafting a Compiler with C, Benjamin-
373
---
## Page 390
的计算。但更多的时候，冗余性是使用高级程序设计语言编程的副产品。在大部分程序设计语
9.1.1 余的原因
运算必然得到同样的结果)。
见的性质，比如像i+0=i这样的代数恒等式或使用一些程序语义（如在同样的值上进行同样的
价算法。编译器只知道如何应用一些相对低层的语义转换。在进行转换时，编译器用到一些常
实现了某种算法，编译器不可能完全理解这个程序并把它替换为一个全然不同且更加高效的等
9.1优化的主要来源
些由常用程序设计语言书写的程序所做的最重要的改进之一。
（归纳变量本质上就是用来对循环的迭代次数进行计数的变量）。这种代码改进是我们能够对那
流问题的算法族。这些算法基于一个结构良好的(即可归约的)程序中的循环的层次结构。这个
这个问题的解决方案由不同的数据流分析问题的解决方案通过组合而得到。
被称为“部分冗余消除”的功能强大的技术。这个技术可用于优化程序中各个表达式求值的位置
是总体框架的一个例子，它的分析功能比前面的例子更强大。然后，我们将在9.5节中考虑一个
流分析技术是这个框架的特例。我们实际上可以使用同一个算法来解决这些数据流分析的实例。
局范围内收集到的信息来改进代码。9.3 节将介绍一个数据流框架的总体思想，9.2 节中的数据
们就不需要在寄存器或内存位置上保留这个值。
确定在程序的每个点上，在某个变量中存放的值是否一定会在被读取之前被覆盖掉。如果是，我
如，对于常量传播分析而言，要判断在程序的每个点上，程序使用的各个变量是否在该点上具有
用以收集程序相关信息的算法。所有数据流分析的结果都具有相同的形式：对于程序中的每个
9.1节中讨论一些主要的代码改进机会。
全局代码优化问题。在全局优化中，代码的改进将考虑在多个基本块内发生的事情。我们将在
的开销。本章讨论如何消除这样的低效率因素。在目标代码中消除不必要的指令，或者把一个指令
在一个典型的程序中会存在很多冗余的运算。有时，在源代码中会用到冗余。比如，程序员
我们将在9.2节介绍数据流分析技术。其中还包括几个重要的例子，说明我们如何使用在全
一的常量值。比如，这个信息可以用于把变量引用替换为常量值。另一个例子是，活跃性分析
令，它们描述了该指令每次执行时必然成立的一些性质。不同性质的分析方法各不相同。比