k
eyb
oard
ma
y
con
tain
a
bit
more
than
16
k
eystrok
es.
Fig.
3.
Elemen
ts
of
the
BIOS
Data
Area
relev
an
t
to
k
eyb
oard
handling.
the
BIOS
k
eyb
oard
buer
w
ould
go
through
the
follo
wing
states
b
et
w
een
k
eystrok
es
:
cf
:
gur
e
4.
Fig.
4.
P
oin
ters
ev
olution
while
en
tering
k
eystrok
es
(using
the
k
eyb
oard...).
The
main
problem
of
this
mec
hanism
is
that
this
buer
is
not
ushed
after
a
k
ey
has
b
een
queried
via
in
terruption
0x16,
function
ah=0x00[19℄,
while
programmers
ma
y
assume
it
is,
only
the
p
oin
ter
to
the
next
k
ey
is
up
dated
:
cf
:
gur
e
5.
1.4
V
erifying
there
is
a
vulnerabilit
y
in
a
BIOS
P
assw
ord
c
hec
king
routine
T
o
demonstrate
the
fact
that
most
programmers
will
not
b
e
a
w
are
of
this
problem,
let's
v
erify
ho
w
the
programmers
of
the
BIOS
ha
v
e
imple-
men
ted
the
user
BIOS
passw
ord
feature
inside
the
BIOS
ash
memory
Fig.
5.
P
oin
ters
ev
olution
while
reading
k
eystrok
es
(using
in
t
0x16).
itself
5
.
T
o
do
so,
w
e
will
need
a
small
16
b
ytes
BIOS
shellco
de
(cf:
A
nnexe
B
:
Shel
lc
o
de.S
)
to
access
ph
ysical
memory
via
real
addressing,
in
Real
Mo
de,
and
displa
y
the
con
ten
t
of
memory
at
lo
cation
0x0040:0x001e.
Since
this
shellco
de
cannot
b
e
run
from
protected
mo
de,
w
e
will
craft
a
small
USB
b
o
otloader
to
load
and
run
it
at
b
o
ot
time
in
real
mo
de
(cf:
A
nnexe
C
:
SploitOS.S
)
:
cf:
gur
e
6.
Fig.
6.
Our
simple
b
o
otloader
running
the
16b
shellco
de
in
real
mo
de
and
rev
ealing
the
Bios
passw
ord.
As
w
e
can
see,
the
programmers
of
the
BIOS
itself
fail
at
prop
erly
ush-
ing
the
BIOS
k
eyb
oard
buer
after
use.
Ob
viously
,
programmers
of
pre-
b
o
ot
authen
tication
soft
w
are
w
on't
b
e
m
uc
h
more
a
w
are
of
the
problem...
5
I
am
using
an
In
tel
BIOS,
v
ersion
PE94510M.86A.0050.2007.0710.1559
(07/10/2007).
1.5
P
assw
ords
c
haining
A
t
this
p
oin
t,
a
careful
reader
ma
y
ask
:
What
happ
ens
if
the
user
has
to
t
yp
e
t
w
o
passw
ords
b
efore
the
b
o
otloader
loads
and
transfers
con
trol
to
the
k
ernel
?
This
is
a
p
erfectly
v
alid
question
since
it
is
absolutely
p
ossible
to
protect
a
computer
with,
for
instance,
b
oth
a
BIOS
passw
ord
and
a
pre-b
o
ot
authen
tication
b
o
otloader,
or
ev
en
to
c
hain
b
o
otloaders.
Because
the
BIOS
k
eyb
oard
buer
is
a
rotativ
e
buer,
lik
e
explained
in
gur
e
5,
if
the
user
en
ters
m
ultiple
input
during
the
b
o
ot
sequence,
the
k
eystrok
es
will
simply
b
e
concatedated
in
the
BIOS
k
eyb
oard
buer
(separated
b
y
a
0x1a
c
haracter
corresp
onding
to
the
carriage
return
k
eystrok
e).
Practically
,
it
means
that
w
e
can
retriev
e
m
ultiple
passw
ords
or
commands
in
the
v
ery
same
w
a
y
w
e
w
ould
retriev
e
a
single
passw
ord.
No
w
that
w
e
ha
v
e
a
b
etter
understanding
of
the
vulnerabilit
y
,
let's
mo
v
e
to
actual
exploitation
under
Microsoft
Windo
ws,
and
then
under
*nix
platforms.
2
Retrieving
pre-b
o
ot
authen
tication
passw
ords
under
Windo
ws
Windo
ws
(from
Windo
ws
95
to
Vista)
is
running,
lik
e
ev
ery
mo
dern
OS,
under
Protected
Mo
de
to
enable
paging,
segmen
tation,
and
m
ultitasking.
It
is
therefore
imp
ossible
to
access
ph
ysical
addresses
directly
:
if
w
e
w
an
t
to
get
access
to
a
memory
lo
cation,
w
e
will
ha
v
e
to
use
virtual
adressing
and
only
the
Memory
Managemen
t
Unit[26℄
will
b
e
able
to
translate
it
in
to
a
ph
ysical
address
whic
h
w
e
will
not
ev
en
kno
w...
T
o
circum
v
en
t
protections
of
Protected
Mo
de
and
segmen
tation,
a
rst
strategy
could
b
e
to
switc
h
the
OS
bac
k
to
Real
Mo
de.
This
w
ould
re-
quire
mo
difying
the
v
alue
of
con
trol
register
cr0,
hence
require
ring
0
privileges[12℄.
It
could
b
e
implemen
ted
as
a
k
ernel
driv
er,
but
w
ould
b
e
highly
non
p
ortable
across
v
ersions
of
the
Windo
ws
k
ernel,
plus
it
w
ould
require
sp
ecial
privileges.
Another
strategy
,
to
disable
segmen
tation
and
access
the
full
ph
ysical
memory
in
read
or
ev
en
write
mo
de
w
ould
b
e
to
switc
h
to
System
Man-
agemen
t
Mo
de
to
run
our
shellco
de
in
16
bits
mo
de.
Suc
h
an
attac
k
has
b
een
pro
v
ed
to
b
e
practical,
assuming
the
attac
k
er
has
ro
ot
privileges,
under
Op
enBSD[6℄,
GNU/Lin
ux
and
other
arc
hitectures[7℄.
But
actually
,
all
w
e
need
is
a
small
shell
allo
wing
us
to
access
the
rst
few
kilob
ytes
of
ph
ysical
memory
in
read
mo
de,
and
optionally
to
do
a
few
ra
w
calls
to
BIOS
in
terruptions
to
displa
y
the
con
ten
t
of
the
BIOS
k
eyb
oard
buer.
F
ortunatelly
,
the
MS-DOS
compatibilit
y
mo
de
of
Mi-
crosoft
Windo
ws
pro
vides
just
that
:
it
tak
es
adv
an
tage
of
In
tel
CPU's
V86
Mo
de[12℄,
to
allo
w
16
bits
programs
execution
under
ring
3.
Some
privileged
op
erations
lik
e
ra
w
access
to
disks
via
In
terruptions
0x13
will
b
e
disabled,
but
w
e
ha
v
e
access
to
In
t
0x10
and
ev
en
MS-DOS's
In
t
0x21
without
restrictions.
And
since
this
mo
de
uses
Real
A
ddressing
and
al-
lo
ws
access
to
the
rst
1
MB
of
ph
ysical
memory
in
read
mo
de[11℄,
w
e
can
run
our
previous
16b
BIOS
shellco
de
(Shellco
de.S)
without
an
y
mo
d-
ication.
It
is
really
just
a
matter
of
compiling
the
co
de
and
placing
it
in
a
le
with
an
exten
tion
.COM,
after
v
erifying
that
it
is
4b
aligned
6
,
and
run
our
binary
7
:
cf
:
gur
e
7.
Fig.
7.
Successful
exploitation
under
Windo
ws
2003.
The
b
enets
of
this
metho
d
are
ob
vious
:
it
is
p
ortable
across
ev
ery
v
ersion
of
Windo
ws
from
95
to
Vista
8
.
And
more
imp
ortan
tly
,
this
ex-
ploitation
tec
hnique
requires
no
sp
ecial
privileges.
Notably
,
Microsoft
Vista
Ultimate
edition
with
Bitlo
c
k
er's
disk
encryption
and
TPM
en-
abled
is
vulnerable
to
this
attac
k.
3
Retrieving
pre-b
o
ot
authen
tication
passw
ords
under
*nix
Retrieving
the
con
ten
t
of
the
BIOS
k
eyb
oard
buer
from
Windo
ws
w
as
quite
easy
b
ecause
its
MS-DOS
em
ulation
wrapp
er
around
V86
mo
de
let
us
access
the
rst
megab
yte
of
ph
ysical
memory
in
read
mo
de
without
restrictions.
Unfortunately
,
there
is
no
suc
h
real
mo
de
+
ph
ysical
memory
read
shell
under
most
Unixes.
Virtual
mac
hines
and
em
ulators
running
from
user-
land
em
ulate
the
In
terruptions
en
tirely
,
and
will
not
allo
w
us
to
retriev
e
actual
information
from
the
BIOS
k
eyb
oard
buer.
In
fact,
under
Lin
ux,
there
is
a
library
,
lrmi[27℄
(Lin
ux
Real
Mo
de
In-
terface),
whic
h
is
merely
a
wrapp
er
around
syscall
113
sys_vm86old.
6
...
since
w
e
are
not
really
using
a
16
bits
CPU,
but
em
ulating
it
o
v
er
a
32
bits
arc
hitecture.
7
W
e
are
here
using
a
F
renc
h
v
ersion
of
Windo
ws
Serv
er
2003
SP2
En
treprise
Edition.
8
A
ctually
,
b
ecause
of
the
imp
erfect
em
ulation
of
16
bits
CPUs,
there
is
one
b
yte
to
c
hange
to
mak
e
it
w
ork
under
the
real
16
bits
mo
de
of
the
actual
MS-DOS
and
Windo
ws
95,
so
that
the
memory
read
actually
p
oin
ts
to
the
desired
lo
cation.
Assuming
w
e
ha
v
e
IOPL(3)
-
i.e.:
ro
ot
privileges
in
practice,
unless
w
e
nd
an
arbitrary
co
de
execution
bug
in
a
service
who
has
b
een
gran
ted
IOPL(3),
lik
e
Xorg
-,
b
y
lling
a
dedicated
datastructure
sp
ecifying
the
v
alues
of
input
registers
and
calling
this
syscall,
w
e
can,
from
userland,
ha
v
e
the
k
ernel
switc
h
to
V86
mo
de,
issue
an
arbitrary
BIOS
In
terrupt
and
presen
t
us
the
result
in
the
form
of
the
same
datastructure.
But
w
e
do
not
ha
v
e
read
access
to
ph
ysical
memory
in
real
mo
de
through
this
metho
d,
so
w
e
will
not
b
e
able
to
read
the
BIOS
k
eyb
oard
buer
so
easily
9
...
cf
:
gur
e
8.
Fig.
8.
Lin
ux
Real
Mo
de
In
terface
(lrmi)
data
structure
to
V86
syscall
as
dened
in
lrmi.h.
That
b
eing
said,
there
are
other
w
a
ys
to
access
memory
under
Unix
to
b
ypass
segmen
tation
protections
and
read
arbitrary
ph
ysical
memory
lo
cations.
W
e
will
rst
fo
cus
on
userland
attac
ks
and
presen
t
a
generic
attac
k
amongst
Unix
platforms
from
userland
with
ro
ot