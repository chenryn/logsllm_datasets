1
.NET MALWARE THREAT: 
INTERNALS AND 
REVERSING
DEF CON USA 2019
DEF CON USA 2019
by Alexandre Borges
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
2
Malware and Security Researcher. 
Speaker at DEF CON USA 2018
Speaker at DEF CON China 2019
Speaker at CONFidence Conference 
2019 (Poland)
Speaker at HITB 2019 Amsterdam
Speaker at BSIDES 
2019/2018/2017/2016
Speaker at H2HC 2016/2015
Speaker at BHACK 2018
Consultant, Instructor and Speaker on 
Malware Analysis, Memory Analysis, 
Digital Forensics and Rootkits. 
Reviewer member of the The Journal 
of Digital Forensics, Security and Law.
Referee on Digital Investigation: The 
International Journal of Digital 
Forensics & Incident Response
Agenda:
 Introduction
 Managed executable structures
 CLR and Assembly Loader details
 .NET internals metadata
 Modules, assemblies and manifest
 .NET program structures
 Malicious code through MSIL
 .NET debugging
 Few GC and synchronous aspects
 Conclusion
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
3
 Last talks in conferences: 
 CONFidence Conference 2019:
 https://confidence-conference.org/2019/bio.html#id=37486
 slides: 
http://www.blackstormsecurity.com/CONFIDENCE_2019_ALEXANDRE.pdf
 DEF CON China 2019:
 https://www.defcon.org/html/dc-china-1/dc-cn-1-speakers.html#Borges 
 slides: 
http://www.blackstormsecurity.com/docs/DEFCON_CHINA_ALEXANDRE.pdf
 HITB Amsterdam 2019: 
https://conference.hitb.org/hitbsecconf2019ams/speakers/alexandre-borges/ 
 slides: http://www.blackstormsecurity.com/docs/HITB_AMS_2019.pdf
 DEF CON USA 2018: 
 https://www.defcon.org/html/defcon-26/dc-26-speakers.html#Borges 
 slides: http://www.blackstormsecurity.com/docs/DEFCON2018.pdf
 Malwoverview Tool: https://github.com/alexandreborges/malwoverview
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
INTRODUCTION
DEF CON USA 2019
4
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
5
 Motivations to talk about .NET reversing and internals:
 Most of the time, professionals are interested in unpacking embedded 
resources from a .NET sample.  
 In another moment, the concern is dumping the unpacked binary from 
memory. 
 Sometimes, we have looked for any unpacking routine to dynamically unpack 
the encrypted content. 
 All of these actions are correct and recommended.
 However....
 Many people don’t understand .NET metadata components. 
 Most people based their analysis on the decompiled code, but never on IL.
 Malware’s authors have manipulated the IL to attack and even the runtime. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
6
 There are many available methods to infect a system using .NET malware. Most of 
the time, a .NET code decrypts and loads a native code (or injects a code into a 
target process). 
 However, there are few approaches that use indirect techniques: 
 An e-mail comes from the Internet and a first dropper is downloaded. 
 This dropper fetches a encrypted payload, which contains a native payload 
and a managed code.
 The payload 1 executes and injects a DLL into a remote chosen process.  
 This DLL loads (and sometime decrypts) the malicious managed code. 
 The malicious managed code drops the payload 2 (real and advanced).
 The true infection starts. 
dropper
(unmanaged)
payload 1
(unmanaged)
vector
(managed)
inject a DLL in 
a remote 
process
payload 2
Infection
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
7
 It is not necessary to comment about how to inject a code because the steps are 
the same ever-sequence: 
 CreateToolhelp32Snapshot( )  Module32First( )  Module32Next( ) 
comparison (wcscmp( ))
 VirtualAllocEx( )  WriteProcessMemory( )  CreateRemoteThread( ) 
WaitForSingleObject  VirtualFreeEx( ).
 Find the offset of injected DLL from the base module  (any testing module). 
 Use this offset to invoke functions from any injected remote process through 
GetProcessAddress( ) + CreateRemoteThread( ). 
 Thi injected DLL can load the next stage and, eventually, decrypt it. 
 Obviously, the .NET managed code can be loaded from any process or, even 
worse, from an natived injected code (DLL). 
 After loading it, it is easy to execute it. Our simple case above. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
8
 We should remember that a typical native application can also load a .NET runtime 
and execute a managed code: 
 CLRCreateInstance( ): provides the ICLRMetaHost interface.
 ICLRMetaHost::GetRunTime( ): gets the ICLRRuntimeInfo. 
 ICLRRuntimeInfo::GetInterface( ): Loads the CLR into the current process and 
returns runtime interface pointers. 
 ICLRRuntimeHost::ExecuteApplication( ): specifies the application to be 
activated in a new domain. 
 ICLRRuntimeHost::Start( ): starts the the runtime. 
 ICLRRuntimeHost::ExecuteInDefaultAppDomain( ): invokes a method in the 
.NET managed assembly (this steps does not work for all .NET assembly’s 
method). Thus, in this case, starts the managed assembly. 
 Finally, the real infection starts. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
9
 We know that .NET malware samples can be very complicated to analyze when 
packed and obfuscated. 
 The .NET framework is composed by: 
 CLR (Common Language Runtime), which is the .NET engine. 
 Libraries (System.IO, System.Reflection, System.Collections, ...).
 Basically:
 source code is written in C#, F#, VB.NET and Powershell.
 compiled to CLI (Common Language Infrastruture Code).
 executed by the  CLR. 
 Tools used to reverse and analyze .NET malware threats are completely different 
than ones used to reverse native language: 
 dnSpy (excellent)
 ILSpy (excellent)
 RedGate .NET Reflector
 De4dot (deobfuscator)
 Microsoft Visual Studio
 WinDbg (including SOS.dll extension)
 DotPeek
 IDA Pro
 Microsoft ILASM/ILDASM (Intermediate 
Language Assembly/Disassembler) 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
10
 Other interesting tools to analyze and understand .NET runtime are available: 
 MemoScope.Net: https://github.com/fremag/MemoScope.Net
 Shed -- a .NET runtime inspector: https://github.com/enkomio/shed
 SuperDump, for automated crash dump analysis: 
https://github.com/Dynatrace/superdump
 DumpMiner: https://github.com/dudikeleti/DumpMiner
 MemAnalyzer: https://github.com/Alois-xx/MemAnalyzer
 Sharplab: https://sharplab.io/
 ObjectLayoutInspector to analyze internal structures of the CLR types at 
runtime (https://github.com/SergeyTeplyakov/ObjectLayoutInspector)
 Tools are excellent to help us, but most .NET malware threats have deployed the 
same tricks from native code to make our job harder: packers, obfuscation and 
anti-reversing techniques.
 .NET Reactor
 Salamander .NET Obfuscator
 Dotfuscator
 Smart Assembly
 CryptoObfuscator for .NET
 Agile
 ArmDot
 babelfor.NET
 Eazfuscator.NET
 Spice.Net
 Skater.NET
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
11
 There are many obfuscators, which perform: 
 Control flow obfuscation and Dead/Junk code insertion. 
 Renaming: methods signatures, fields, methods implementation, namespaces, 
metadata, external references. 
 Re-encoding: changing printable to unprintable characters
 Simple encryption of methods and strings. 
 Cross reference obfuscation.
 Yes, I know... I’ve already talked about obfuscation in DEF CON China 2019. 
 Most time, the real and encoded malicious code (payload) is downloaded and 
decrypted/loaded into the memory for execution: 
 System.Reflection.Assembly.Load( )
 System.Reflection.Assembly.LoadFile()
 System.Reflection.MethodInfo.Invoke( )
 As we already know, Load( )/LoadFile( ) function are usually followed by: 
 GetType ( )  GetMethod( )  Invoke( )  (this is a typical Reflection approach)
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
12
 Another possible approach would be: 
 GetAssemblyName( ) + GetType( ) + GetMethod( ) + Invoke( )
 Some “encrypted content” is loaded from as a resource, so it is usual finding the 
following sequence: 
 FindResource( ) + SizeOfResource( ) + LoadResource( ) + LockResource( )
 Resources.ResourceManager.GetObject( )
 Additionally, we’ve seen techniques using embedded references such as DLLs as 
resources through a sequence of calls using: 
 AssemblyLoader.Attach( ) + AssemblyLoader.ResolveAssembly( ). 
 As you’ve guessed, AssemblyLoader.ResolveAssembly( ) is used to resolving 
assemblies that are not available at the exact time of calling other methods, which 
are external references to the binary itself.
 Similar to resources mentioned previously, these “external references” (DLL 
required by the binary) must be first “decompressed” at most of the time. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
13
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
14
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
15
MemberRef  Table
(check slide 27)
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
16
Manifest
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
17
 As every single malware code, this one is using Reflection to retrieve information in 
runtime. In this case also calls the GetExecutingAssembly( ) method to get the 
Assembly object, which represents the current assembly.
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
18
 Therefore, we can extract these resources (DLLs, for example) by using either dnSpy 
or ILSpy , decrypt and load them again into the managed code. 
 Of course, in this case, we’ll be able to see all “hidden” references, finally. 
 To load the “decrypted” resources into the managed code, we can use ILSpy + 
Reflexil plugin (http://reflexil.net/). 
 Finally, it is necessary to remove the “old” references to the embedded resources 
(performed by AssemblyLoader.Attach( )) from the initializer (or removing the whole 
initializer) because, at this time, they are “decrypted”. 
 By the way, Reflexil is able to handle different obfuscators such as Babel NET, 
CodeFort, Skater NET, SmartAssembly, Spices Net, Xenocode, Eazfuscator NET, 
Goliath NET, ILProtector, MaxtoCode, MPRESS, Rummage, CodeVeil,CodeWall, 
CryptoObfuscator, DeepSea, Dotfuscator, dotNET Reactor, CliSecure and so on.
 Another interesting point is that calling Win32 APIs through P/Invoke (Platform 
Invoke) is always possible. 
 At end, gaining knowledge in .NET internals and metadata can be interesting. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
19
 Most time, there are module/type initializers (similar to TLS in native code) 
executing before classes and entry point methods.
 .NET protectors hardly change the entry point and, usually, the trick is in the 
initializer. 
 .cctor( ) method is a static class constructor: 
 called before the Main( ) method (usually set as entry point), for example.
 when the module has a .cctor (::.cctor( )), so it is run before 
executing any other class initializers or even an entry point.  
 It is common finding  unpackers, decrypters and hooks in the .cctor( ) 
method. 
 Hijacking the ICorJitCompiler::compileMethod( ) is an interesting and useful way to 
take the control of the JIT engine because this method is used to create a native 
code, so we find managed and native code together. 
 In this case:  .cctor( )  hooking compileMethod( )  hiding/encryting user code.
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
.NET details
DEF CON USA 2019
20
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
21
 Malware authors have written malware threats in ILAsm and using constructions 
that are not compliance to CLS (Common Language Specification). 
 In this case, the malware is valid to the runtime engine, though it is not always able 
to communicate to other applications. 
 Metadata works as descriptors for each structure component of the application: 
classes, attributes, members, and so on. 
 Remember that a .NET application is composed by: 
 managed executable files, which each one contains metadata
 managed code (optionally)
 .NET Assembly: managed .NET application  (modules) + class libraries + resources 
files (more information later)
 CLR runtime environment: loaders + JIT compiler. 
 .NET source code  .NET compiler  module (IL + metadata)  CLR ( loaders +  
JIT compiler)   native instruction  Execution Engine
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
22
 Managed module is composed by: 
 PE header: If the module contains only IL code, so most of information of 
header is ignored. However, if the module also contains native code, so things 
are different. 
 CLR header: contains the version of the CLR, token of Main( ) (natural entry 
poiint), resources and so on. 
 Metadata: describe types and members. Additionally, it helps the GC to track 
the life time of objects. 
 IL (Intermediate Language) code: the managed code.
Managed Modules 
Resource Files
Compiler (C#, VB, F#) 
+ Linker
Managed Modules 
Resource Files