Copyright 
  © 
  2015 
  Splunk 
  Inc. 
Op:mizing 
  Splunk 
Knowledge 
  Objects 
Mar:n 
  Müller 
Professional 
  Services 
  Consultant 
Consist 
  SoAware 
  Solu:ons 
  GmbH 
Disclaimer 
During 
  the 
  course 
  of 
  this 
  presenta:on, 
  we 
  may 
  make 
  forward 
  looking 
  statements 
  regarding 
  future events 
  or 
  the 
  expected 
  performance 
  of 
  the 
  company.performance 
  of 
  the 
  company. 
  We 
  cau:on 
  you 
  that 
  such 
  statements 
  reflect 
  our current 
  expecta:ons 
  and 
  es:mates 
  based 
  on 
  factors 
  currently 
  known 
  to 
  us 
  and 
  that 
  actual 
  events 
  or results 
  could 
  differ 
  materially. 
  For 
  important 
  factors 
  that 
  may 
  cause 
  actual 
  results 
  to 
  differ 
  fromresults 
  to 
  differ 
  from 
  those contained 
  in 
  our 
  forward-­‐looking 
  statements, 
  please 
  review 
  our 
  filings 
  with 
  the 
  SEC. 
  The 
  forward-­‐looking 
  statements 
  made 
  in 
  the 
  this 
  presenta:on 
  are 
  being 
  made 
  as 
  of 
  the 
  :me 
  and 
  date 
  of 
  its 
  live presenta:on. 
  If 
  reviewed 
  aAer 
  its 
  live 
  presenta:on,aAer 
  its 
  live 
  presenta:on, 
  this 
  presenta:on 
  may 
  not 
  contain 
  current 
  or accurate 
  informa:on. 
  We 
  do 
  not 
  assume 
  any 
  obliga:on 
  to 
  update 
  any 
  forward 
  looking 
  statements 
  we may 
  make. 
In 
  addi:on, 
  any 
  informa:on 
  about 
  our 
  roadmap 
  outlines 
  our 
  general 
  product 
  direc:on 
  and 
  is 
  subjectdirec:on 
  and 
  is 
  subject 
  to change 
  at 
  any 
  :me 
  without 
  no:ce. 
  It 
  is 
  for 
  informa:onal 
  purposes 
  only 
  and 
  shall 
  not 
  be 
  incorporated into 
  any 
  contract 
  or 
  other 
  commitment. 
  Splunk 
  undertakes 
  no 
  obliga:on 
  either 
  to 
  develop 
  the 
  features or 
  func:onality 
  described 
  or 
  to 
  include 
  any 
  suchor 
  to 
  include 
  any 
  such 
  feature 
  or 
  func:onality 
  in 
  a 
  future 
  release. 
2 
Why 
  are 
  we 
  here? 
3 
Why 
  are 
  we 
  here? 
“Oversized 
  litsearch 
  is 
  the 
  largest 
  performance 
problem 
  we 
  face 
  in 
  our 
  environment.” 
-­‐ 
  Jacob 
  Wilkins, 
  General 
  Electric 
4 
Why 
  are 
  we 
  here? 
 Observed 
  search 
  run 
  :me Observed 
  search 
  run 
  :me 
  progression 
  during 
  development 
  Massive 
  growth 
  in 
  job 
  startup 
  :me 
  Knowledge 
  Object 
  op:miza:on 
  reduced 
  that 
  overhead 
  by 
  80% 
5 
Who‘s 
  that 
  guy? 
  Professional 
  Services 
  Consultant, 
  Cer:fied 
  Architect, 
  Splunk-­‐It-­‐All 
 Five 
  years 
  at 
  EMEA 
  Splunk 
  Partner 
  Heavy 
  SplunkerPartner 
  Heavy 
  Splunker 
  since 
  2012 
 Get 
  in 
  touch 
  with 
  me: 
  mar:PI:EMAIL
 Give 
  karma 
  at 
  Splunk 
  Answers: 
  Hang 
  in 
  #splunk 
  on 
  Efnet: 
  mar:n_m 
6 
Session 
  Objec:ves 
 Understand 
  how 
  Splunk 
  turns 
  a 
  search 
  into 
  results 
 Learn 
  how 
  to 
  recognize 
  if 
  you 
  have 
  a 
  problem 
  (Spoilerhave 
  a 
  problem 
  (Spoiler 
  Alert: 
  You 	do!) 
  Use 
  this 
  to 
  your 
  advantage 
  when 
  specifying 
  search-­‐:me 
  knowledge 
 Covered 
  knowledge 
  objects: 
–Fields 
–Reverse 
  Lookups 
–Evenmypes 
–Tags 
7 
Let’s 
  dive 
  in… 
…but 
  first, 
  to 
  the 
  Job 
  Inspector! 
 normalizedSearch: 
  Ultra-­‐verbose 
  stage 
  of 
  search 
  assemblystage 
  of 
  search 
  assembly 
  Performance 
  stats, 
  e.g. 
  :me 
  spent 
  assembling 
  the 
  normalizedSearch 
  Links 
  to 
  search.log 
  to 
  look 
  for 
  more 
  hidden 
  performance 
  hogs   More 
  at 
	hmp://docs.splunk.com/Documenta:on/Splunk/latest/ 
  Knowledge/ 	Viewsearchjobproper:eswiththeJobInspector
9 
Fields 
10 
Calculated 
  Fields 
  (1) 
  TA-­‐splunk,Fields 
  (1) 
  TA-­‐splunk, 
  props.conf: 
  [audittrail] 
	EVAL-action=case(condN, valN, 1=1, action)
 Splunk‘s 
  assump:on 
  about 
  looking 
  for 
  indexed 
  tokens 
  doesn‘t 
  hold 
 No 
  way 
  to 
  translate 
  the 
  eval 
  expression 
  into 
  tokens 
 Plain 
  Search: 
  index=_audit action=search 
	normalizedSearch: 
  index=_audit (action=search 	 OR (sourcetype=audittrail))  Load 
  all 
  events 
  for 
  that 
  stanza 
  plus 
  events 
  with 
  the 
  token, 
  filter 
  later 
11 
	Calculated 
  Fields 
  (2)  What 
  if 
  you‘re 
  not 
  searching 
  for 
  that 
  sourcetype? 
 index=_internal sourcetype=splunk* 
	 action=logout 
	index=_internal sourcetype="splunk*" 
	 (action=logout OR (sourcetype=audittrail))  Splunk 
  expands 
  each 
  segmentexpands 
  each 
  segment 
  of 
  your 
  search 
  on 
  its 
  own 
  For 
  each 
  calculated 
  field, 
  add 
  stanza 
  to 
  every 
  search 
  for 
  that 
  field   This 
  is 
  only 
  the 
  beginning 
  of 
  normalizedSearch 
  overhead! 
12 
Field 
  Aliases 
 Sourcetype 
  A 
  has 
  field 
  username, 
  sourcetype 
  B 
  has 
  field 
  uid, 
  …   Field 
  aliasesuid, 
  …   Field 
  aliases 
  can 
  normalize 
  this 
  to 
  user 
  over 
  all 
  sourcetypes  sourcetype=A user=martin 
  yields 
  this 
  normalizedSearch: 	sourcetype=A ( 
	 ((sourcetype=A) AND ((username=martin))) OR 	 ((sourcetype=B) AND ((uid=martin))) OR 
	 ((sourcetype=audittrail) AND ((uid=martin))) 	) OR (user=martin) 
  All 
  field 
  aliases 
  for 
  all 
  sourcetypesaliases 
  for 
  all 
  sourcetypes 
  are 
  used 
  in 
  all 
  searches! 
13 
A 
  real-­‐world 
  example 
  Splunk 
  App 
  for 
  Enterprise 
  Security 
  3.3.1 
  The 
  TAs 
  shipped 
  define 
  19 
  field 
  aliases 
  for 
  user 
 Your 
  environment 
  will 
  have 
  addi:onal 
  TAs 
  Watch 
  your 
  normalizedSearch 
  strings 
  and 
  search 
  startup 
  :me 
  growsearch 
  startup 
  :me 
  grow 
 Let‘s 
  not 
  forget 
  the 
  upside 
  though: 
  Without 
  standardized 
  field 	names, 
  searching 
  over 
  different 
  sourcetypes 
  would 
  be 
  impossible   Are 
  you 
  building 
  a 
  TA? 
  Extract 
  standardized 
  field 
  names 
  directly! 
14 
A 
  real-­‐world 
  example 
 Searching 
  for 
  user=martin 
  yields 
  2kB 
  ofuser=martin 
  yields 
  2kB 
  of 
  normalizedSearch: 
((((sourcetype="*") AND ((username=martin))) OR ((sourcetype=A) AND ((username=martin))) OR ((sourcetype=B) AND ((uid=martin))) OR ((sourcetype="WMI:UserAccounts") AND ((Name=martin))) OR ((sourcetype="WinEventLog:Application:sophos") AND ((User=martin))) OR((sourcetype="WinEventLog:SophosPatch") AND ((User=martin))) OR ((sourcetype=airdefense) AND ((suser=martin))) OR ((sourcetype=audittrail) AND ((uid=martin))) OR 
((sourcetype="aws:cloudtrail") AND (("sourceIdentity.userName"=martin) OR 
("userIdentity.sessionContext.sessionIssuer.userName"=martin) OR 
("userIdentity.userName"=martin))) OR ((sourcetype=cef) AND ((suser=martin))) OR((sourcetype="cisco:sourcefire:appliance:syslog") AND ((User=martin))) OR 
((sourcetype="cisco:wsa:w3c") AND ((cs_username=martin))) OR 
((sourcetype="f5:bigip:asm:syslog") AND ((username=martin))) OR((sourcetype="f5:bigip:management:usermanagement:icontrol") AND ((get_fullname=martin))) OR ((sourcetype=fs_notification) AND ((uid=martin))) OR ((sourcetype="oracle:session") AND ((USERNAME=martin))) OR ((sourcetype=ps) AND ((USER=martin))) OR ((sourcetype=sav) AND ((LI_USER=martin))) OR ((sourcetype="sophos:appcontrol") AND ((UserName=martin))) OR ((sourcetype="sophos:devicecontrol") AND ((UserName=martin))) OR((sourcetype="sophos:firewall") AND ((UserName=martin))) OR ((sourcetype="sophos:sec") AND ((UserName=martin))) OR ((sourcetype="sophos:tamperprotection") AND ((UserName=martin))) OR ((sourcetype="sophos:threats") AND ((UserName=martin))) OR ((sourcetype="sophos:utm:ips") AND ((username=martin)))) OR (user=martin) OR (sourcetype="cisco:asa") OR(sourcetype="cisco:fwsm") OR (sourcetype="cisco:pix") OR (sourcetype="oracle:audit:text") OR (sourcetype="oracle:audit:xml")) 
15 
DEMO 
	16 
	Fields 
  Recap 
 Each 
  search 
  segment 
  is 
  expanded 
  on 
  its 
  own 
  without 
  context  props.conf 
  for 
  one 
  sourcetype 
  will 
  radiate 
  into 
  normalizedSearch 
  of 	other 
  sourcetypes 
  when 
  field 
  names 
  matchwhen 
  field 
  names 
  match 
 Avoid 
  calculated 
  fields 
  and 
  field 
  aliases 
  en:rely 
  where 
  possible 	–Extract 
  fields 
  using 
  standardized 
  names 
  in 
  the 
  first 
  place! 
–Some 
  calculated 
  fields 
  can 
  be 
  replaced 
  with 
  lookups   Monitor 
  their 
  effects 
  where 
  unavoidable 
 Both 
  are 
  fine 
  for 
  fields 
  you 
  onlyfine 
  for 
  fields 