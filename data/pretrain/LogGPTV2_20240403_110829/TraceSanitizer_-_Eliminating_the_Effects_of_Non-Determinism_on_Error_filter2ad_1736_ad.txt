12 T_0_0 load 3 g0
13 T_0_1 call-dec 0
14 T_0_1 alloca o8 1 8
15 T_0_0 store 4 g0
16 T_0_1 alloca o9 1 8
17 T_0_1 store 0 o9
18 T_0_1 load 6 g0+4
call-pthread_join 0 T_0_0 0
19 T_0
load T_0_1 o5
20 T_0
21 T_0_1 store 5 g0+4
22 T_0
...
call-pthread_join 0 T_0_1 0
0
...
1
2
...
3
4
5
6
0 store 3 603d74
0 store 6 603d78
0 call-pthread_create 0 7ffcfe3282e8
(cid:2)→ 0 400ae0 0
(cid:2)→ 0 4012c0 0
0 call-pthread_create 0 7ffcfe3282e0
1 call-inc 0
1 alloca 7f0ccbc55d58 8
0 load 7f0ccbc56700 7ffcfe3282e8
7
8
9
10 1 alloca 7f0ccbc55d50 8
11 1 store 0 7f0ccbc55d50
12 1 load 3 603d74
13 2 call-dec 0
14 2 alloca 7f0ccb454d58 8
15 1 store 4 603d74
16 2 alloca 7f0ccb454d50 8
17 2 store 0 7f0ccb454d50
18 2 load 6 603d78
19 0 call-pthread_join 0 7f0ccbc56700 0
20 0 load 7f0ccb455700 7ffcfe3282e0
21 2 store 5 603d78
22 0 call-pthread_join 0 7f0ccb455700 0
...
g0 := {ba=603d74, t=_, l_idx=0, s=8, v=[0,33]}
...
l_idx=0, s=8, v=[0,33]}
o0 := {ba=7ffcfe3287e8, t=T_0,
l_idx=1, s=8, v=[1,33]}
o4 := {ba=7ffcfe3282e8, t=T_0,
o5 := {ba=7ffcfe3282e0, t=T_0,
l_idx=2, s=8, v=[2,33]}
o6 := {ba=7f0ccbc55d58, t=T_0_0, l_idx=0, s=8, v=[8,15]}
o7 := {ba=7f0ccbc55d50, t=T_0_0, l_idx=1, s=8, v=[10,15]}
o8 := {ba=7f0ccb454d58, t=T_0_1, l_idx=0, s=8, v=[14,21]}
o9 := {ba=7f0ccb454d50, t=T_0_1, l_idx=1, s=8, v=[16,21]}
M(0) := T_0
M(1) := T_0_0
M(2) := T_0_1
(cid:1)(cid:2)(cid:3)
(cid:1)(cid:2)(cid:3)(cid:2)(cid:3)
(cid:1)(cid:2)(cid:3)(cid:2)(cid:4)
Fig. 4. Trace sanitizing example. Execution trace from Figure 2 after sanitizing
(upper left). We show the ﬁrst trace on the upper right side along with the
generated memory object set and thread identity mapping on the bottom left.
At the bottom right we present the thread tree generated by our algorithm.
added to the set of memory objects O. The object structure
contains information about the base address returned by the
LLVM-IR alloca instruction (7ffcfe3287e8), the size of
the allocated object (8), the thread executing the instruction
(0), the local index reﬂecting the position of the instruction in
the sequence executed by the thread (1) and the initial validity
range of the object ([1,33]) where 33 is the total number
of instructions in the trace.
At the invocation of the inc function (line 7), a new scope
is created and the stack pointer for thread 1 is updated to the
index of the event where the scope was entered (7). This value
will be used later to update the validity range of every new
object created within the new scope. Similarly, at the call to
dec in line 13, the algorithm updates the stack pointer for
thread 2 to 13. At the end of each of the functions, the scope
for both inc and dec ends and the validity range for the
objects created within that scope has to be updated. Every
object that has been added to O after the value in the stack
pointer has to be updated. For instance, the validity range of
object o6, added at line 8 within inc’s scope, is updated be
to [8,15] where 8 is the index of its allocation instruction in
the trace and 15 the end of the scope. The stack pointer also
has to be updated to the start of the previous scope. However,
thit is unnecessary since only one scope has been created by
this thread.
Finally, TraceSanitizer replaces the concrete addresses with
the generated objects in every instruction in the trace. In this
example there are also global variables that are accessed by the
program. While Algorithm 1 does not include the handling of
global variables, our implementation, however, handles these
variables separately. Before iterating over the instructions, we
add a memory object with maximal validity range for each
global variable. The object g0 in Figure 4 (bottom left) repre-
sents the global array arr deﬁned in the example. Note that
accesses to g0 are not always at the base address. For instance,
the access at line 18, occurs on the second element in the array,
hence the reference g0+4 with an int type of byte length 4.
Encountering an address that has not been explicitly allocated
leads to the creation of a new object with default size, e.g.,
the argument of the main function results in the creation of
object o0 (bottom left).
6) Thread Identity Abstraction: The algorithm ﬁrst fetches
the set of threads in the trace 0, 1, and 2 and adds nodes
for these threads to G. We show the resulting spawning tree
at the bottom right of Figure 4 (The nodes are renamed by
their canonical IDs). Since thread 0 spawns threads 1 and 2,
edges (0, 1) and (0, 2) are added to G. Next, the algorithm
traverses the generated tree G to map concrete thread IDs
to deterministically calculated thread IDs. The initial thread
0 is mapped to ID T_0. Every time a new node is reached
in the tree, its child nodes are traversed in the order of the
corresponding threads’ creation. For instance, since thread 1
was created before 2, it will be traversed ﬁrst. Following the
renaming pattern presented in Algorithm 2, thread 1 is mapped
to an ID consisting of its parent node ID (T_0) concatenated
with an index indicating its creation order 0: T_0_0. Likewise,
thread 2 is mapped to ID T_0_1 as shown in Figure 4. Finally,
TraceSanitizer replaces every reference to a thread’s ID in the
program using the generated map M.
(cid:2)
7) Reversibility Check: To build the reversibility check for-
mula, a unique variable is assigned to every instruction in the
trace. First, we encode the allowed interleavings of the trace
by imposing constraints on the order of the formula variables.
In addition to the constraints encoding the sequentiality of ev-
ery thread, we add constraints for inter-thread synchronization.
The call pthread_join at line 19 in Figure 4, for instance,
forces the invoking thread 0 to wait for the termination of
thread 2 before executing the next instruction. In this case, we
add a constraint x
< x for the call e to pthread_join and
(cid:2) being the last instruction executed by thread 2.
e
Next, we identify all the dependencies between load and
store instructions that read from or write to the same memory
(cid:2) at lines 4 and 18,
location. Consider the instructions e and e
(cid:2) reads from the same memory object
respectively. Instruction e
g0, with the same offset, that e writes to. Therefore, both
instructions are dependent on each other. Since e occurs before
(cid:2) ≤ x to the reversibility
(cid:2) in the trace, we add the constraint x
e
formula to check whether the two dependent instructions can
occur in the reverse order. However, the formula does not allow
any interleaving of the trace where instruction e occurs after
(cid:2) as that would mean that the thread executing e
(cid:2) would start
e
executing before it has been spawned. Since no such pair of
instruction can be found for the trace, the generated reversibility
formula cannot be satisﬁed and the trace will be declared to
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:30:10 UTC from IEEE Xplore.  Restrictions apply. 
58
satisfy the reversibility condition. Note that our check ignores
dependencies between instruction from the same thread as
these can obviously not be reversed. Moreover, the reversibility
formula only considers instructions that have “global” effects
in the trace such as a synchronizing events and writes/reads on
memory objects that are accessible by more than one thread.
8) Trace Comparison: After passing the reversibility check,
we can safely compare the sanitized fault-free trace against
sanitized traces from fault injection experiments with the same
program processing the same input. The second trace, referred
to as the faulty trace, is obtained by performing fault injection
on the original program and re-executing it with the same in-
put parameters. Since the threads are renamed systematically,
the set of created thread ids in both traces are guaranteed to
be the same. We start by dividing the sanitized traces into
subsequences where each sequence contains only instructions
belonging to a single thread. Next, we match the subsequences
belonging to the same thread and compare every instruction.
Since the threads are renamed identically in traces from dif-
ferent executions with the same input, the set of created IDs
in both traces should match in a comparison of fault-free
executions. Furthermore, if the ﬁrst trace had passed the re-
versibility check and the second trace is a re-execution of
the same program with the same input, then every pair of
two such subsequences should be identical unless one of the
traces is affected by an injected fault. This is guaranteed by
the local determinism property of every thread induced by
the pseudo-deterministic condition of the ﬁrst trace. If depen-
dent instructions cannot occur in a reversed order, every thread
will be created in the same order by the same parent thread,
and memory objects will also be allocated in the same order
and by the same thread. Therefore, a deviation between both
traces implies that the injected fault has been activated in the
experiment and its effects on the execution show in the com-
parison. Concretely, the comparison algorithm checks whether
instructions in both subsequences occur in the same order and
whether they access the same objects with the same offsets.
Applying the sanitizing algorithms on both traces from ﬁg. 2
results in pairs of identical subsequences for every thread in
the trace (T_0, T_0_0 and T_0_1) since the ﬁrst trace satis-
ﬁes the pseudo-deterministic condition and the second trace is
not faulty.
V. TRACESANITIZER IMPLEMENTATION
The publicly available TraceSanitizer implementation2 con-
sists of two modules: (1) an instrumentation and fault injection
module that is implemented as an extension of the LLFI EPA
tool [17], and (2) a sanitization and trace comparison mod-
ule. The ﬁrst module adds more logging information in the
trace generation process and thread safety to the LLFI tool.
The instrumentation and fault injection parts are performed
at the level of the intermediate level representation of the
LLVM compiler infrastructure. We implemented the second
module in the Rust programming language and used the Z3
2https://github.com/DEEDS-TUD/TraceSanitizer
TABLE I
OVERVIEW OF THE BENCHMARK PROGRAMS. SLOC REPORTS THE SOURCE
LINES OF CODE, #TH THE SUM OF SPAWNED THREADS AND #INST THE
NUMBER OF EXECUTED INSTRUCTIONS IN ONE RUN.
MEM-SOUND/SCHED-SOUND WHETHER FALSE POSITIVES OCCURRED DUE
TO MEMORY/CPU NON-DETERMINISM () OR NOT ().
Program
SLOC #Th
quicksort
pca
kmeans
blackscholes
swaptions
198
301
425
393
1118
#Inst Mem-Sound Sched-Sound
Na¨ıve TSAN Na¨ıve TSAN




















45 k
72
89 k
17
44 k
65
91 k
3
4 1.1 M
SMT solver [22], [23] for the reversibility check. Since the
reversibility formula we generate uses the standard SMT-LIB
format [24], TraceSanitizer can use most existing solvers.
VI. EVALUATION
We ﬁrst enumerate the research questions we aim to answer,
followed by the experimental setup and obtained results. We
conducted all of the experiments on machines with an Intel Core
i7-4790 CPU, 16 GiB of RAM, and a 500 GB SSD running
Debian 8.11 with a Linux 3.16 kernel.
A. Research Questions
The goal of our evaluation is to show that the TraceSanitizer
approach eliminates all false positives in EPA due to execution
non-determinism, and to measure the performance overhead
of TraceSanitizer. Four research questions (RQs) are pertinent.
RQ 1 What are the false positive rates resulting from non-
determinism in dynamic memory allocations with and
without TraceSanitizer?
RQ 2 What false positive rates result from CPU scheduling
non-determinism with and without TraceSanitizer?
RQ 3 What is the rate of false negatives with TraceSanitizer?
RQ 4 What is the performance overhead of TraceSanitizer?
B. Target Programs and Execution Environment
Our evaluation targets ﬁve C/C++ programs listed in Table I,