policy languages, such as RT [28], and are appropriate for
privacy languages.
Finally, our current language faces a limitation common
to many policy languages. Consider SB 1386, a California
law requiring businesses that inappropriately disclose per-
sonal information to notify the subjects of the information.
This provision cannot be expressed properly in the language
because it takes effect only when an agent violates norms.
In our model, agents never violate norms and thus would
never be required to notify individuals. However, such no-
tiﬁcations are common in California. To express such “de-
fense in depth” provisions, we plan to extend our model to
account for agents who occasionally (perhaps unintention-
ally) violate the norms. We expect this to require modiﬁca-
tions to the current logic.
Acknowledgments. We thank A. Bradley, C. S´anchez,
and M. Slanina for helpful discussions about LTL. This
work was partially supported by the NSF Cybertrust Pro-
gram through the PORTIA project and the NSF Science and
Technology Center TRUST.
References
[1] M. S. Ackerman, L. F. Cranor, and J. Reagle. Privacy in
e-commerce: examining user scenarios and privacy prefer-
ences. In Proceedings of the 1st ACM Conference on Elec-
tronic Commerce, pages 1–8. ACM Press, 1999.
[2] R. Agrawal, J. Kiernan, R. Srikant, and Y. Xu. An XPath-
based preference language for P3P. In Proceedings of the
Twelfth International Conference on World Wide Web, pages
629–639. ACM Press, 2003.
[3] R. Agrawal, R. Srikant, and D. Thomas. Privacy preserving
OLAP.
In SIGMOD ’05: Proceedings of the 2005 ACM
SIGMOD international conference on Management of data,
pages 251–262, New York, NY, USA, 2005. ACM Press.
[4] A. Anderson. Key differences between XACML and EPAL.
Ottawa new challenges for access control, 2005.
[5] A. Anderson, A. Nadalin, B. Parducci, D. Engovatov,
E. Coyne, F. Siebenlist, H. Lockhart, M. McIntosh,
M. Kudo, P. Humenn, R. Jacobson, S. Proctor, S. Godik,
S. Anderson, and T. Moses. Extensible access control
markup language (XACML) version 2.0, 2004.
[6] M. Backes, M. D¨urmuth, and R. Steinwandt. An algebra for
composing enterprise privacy policies. In European Sympo-
sium on Research in Computer Security (ESORICS), volume
3193 of LNCS. Springer–Verlag, 2004.
[7] M. Backes, G. Karjoth, W. Bagga, and M. Schunter. Efﬁ-
cient comparison of enterprise privacy policies. In Proceed-
ings of the 2004 ACM Symposium on Applied Computing,
pages 375–382. ACM Press, 2004.
[8] M. Backes, B. Pﬁtzmann, and M. Schunter. A toolkit for
managing enterprise privacy policies. In European Sympo-
sium on Research in Computer Security (ESORICS), volume
2808 of LNCS, pages 101–119. Springer–Verlag, 2003.
[9] A. Barth and J. C. Mitchell. Enterprise privacy promises
and enforcement.
In WITS ’05: Proceedings of the 2005
Workshop on Issues in the Theory of Security, pages 58–66,
New York, NY, USA, 2005. ACM Press.
[10] A. Barth, J. C. Mitchell, and J. Rosenstein. Conﬂict and
combination in privacy policy languages.
In Proceedings
of the 2004 Workshop on Privacy in the Electronic Society.
ACM Press, 2004.
[11] M. Y. Becker and P. Sewell. Cassandra: Flexible trust man-
agement, applied to electronic health records.
In CSFW
’04: Proceedings of the 17th IEEE Computer Security Foun-
dations Workshop (CSFW’04), page 139, Washington, DC,
USA, 2004. IEEE Computer Society.
[12] M. Bishop. Computer Security: Art and Science. Addison
Wesley Professional, 2003.
[13] S. Byers, L. F. Cranor, and D. Kormann. Automated analysis
of P3P-enabled web sites. In Proceedings of the 5th Interna-
tional Conference on Electronic Commerce, pages 326–338.
ACM Press, 2003.
[14] J. Crampton. On permissions, inheritance and role hier-
archies.
In Proceedings of the 10th ACM Conference on
Computer and Communication Security, pages 85–92. ACM
Press, 2003.
[15] L. F. Cranor. Web Privacy with P3P. O’Reilly and Asso-
ciates, Inc., 2002.
[16] L. F. Cranor, M. Langheinrich, M. Marchiori, M. Presler-
The platform for pri-
2002.
Marshall,
vacy preferences 1.0 (P3P1.0)
http://www.w3.org/TR/P3P/.
and J. Reagle.
speciﬁcation,
[17] N. Damianou, N. Dulay, E. Lupu, and M. Sloman. The
ponder policy speciﬁcation language. In POLICY ’01: Pro-
ceedings of the International Workshop on Policies for Dis-
tributed Systems and Networks, pages 18–38, London, UK,
2001. Springer-Verlag.
[18] S. Demri and P. Schnoebelen. The complexity of proposi-
tional linear temporal logics in simple cases.
In Procced-
ing of the 15th Annual Symposium on Theoretical Aspects
of Computer Science (STACS’98), volume 1373 of LNCS.
Springer–Verlag, 1998.
[19] J. DeTreville. Binder, a logic-based security language. In SP
’02: Proceedings of the 2002 IEEE Symposium on Security
and Privacy, page 105, Washington, DC, USA, 2002. IEEE
Computer Society.
[20] C. Dwork and K. Nissim. Privacy-preserving datamining
on vertically partitioned databases. In CRYPTO 2004: 24th
Annual International Cryptology Conference, volume 3152
of LNCS, pages 528–544. Springer–Verlag, 2004.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:47:00 UTC from IEEE Xplore.  Restrictions apply. 
[21] Electronic Privacy Information Center. The Gramm–Leach–
Bliley Act, 2005. http://www.epic.org/privacy/glba/.
[22] Federal Trade Commission.
How to comply with
the children’s online privacy protection rule, 1999.
http://www.ftc.gov/bcp/conline/pubs/buspubs/coppa.htm.
[23] Federal Trade Commission.
the ﬁnancial pri-
vacy requirements of the Gramm–Leach–Bliley Act, 2002.
http://www.ftc.gov/bcp/conline/pubs/buspubs/glbshort.htm.
[24] G. J. Holzmann. The SPIN Model Checker: Primer and
In brief:
Reference Manual. Addison Wesley Professional, 2004.
[25] S. Jajodia, P. Samarati, M. L. Sapino, and V. S. Subrahma-
nian. Flexible support for multiple access control policies.
ACM Trans. Database Syst., 26(2):214–260, 2001.
[26] W. Jamroga, W. van der Hoek, and M. Wooldridge. On obli-
gations and abilities.
In Deontic Logic: 7th International
Workshop on Deontic Logic in Computer Science, volume
3065 of LNCS, pages 165–181. Springer–Verlag, 2004.
[27] G. Karjoth and M. Schunter. A privacy policy model for
enterprises. In 15th IEEE Computer Security Foundations
Workshop. IEEE Computer Society Press, 2002.
[28] N. Li and J. C. Mitchell. RT: A role-based trust-management
framework.
In The Third DARPA Information Survivabil-
ity Conference and Exposition, pages 201–212, Washington,
DC, USA, 2003. IEEE Computer Society.
[29] Z. Manna and A. Pnueli. Temporal Veriﬁcation of Reactive
Systems: Safety. Springer–Verlag, 1995.
[30] H. Nissenbaum. Privacy as contextual integrity. Washington
Law Review, 79(1):119–158, 2004.
[31] Ofﬁce for Civil Rights. Summary of the HIPAA privacy
rule. United States Department of Health & Human Ser-
vices, 2003.
[32] J. Prins. The propertization of personal data and identities.
Electronic Journal of Comparative Law, 8.3, October 2004.
[33] J. Rachels. Why privacy is important. In F. D. Schoeman,
editor, Philosophical Dimensions of Privacy: An Anthology,
pages 290–294. 1984.
[34] J. Reagle and L. F. Cranor. The platform for privacy prefer-
ences. Communications of the ACM, 42(2):48–55, 1999.
[35] G. Rosu and K. Havelund. Synthesizing dynamic program-
ming algorithms for linear temporal logic formulae. Techni-
cal Report TR 01-15, RIACS, May 2001.
[36] F. Schoeman. Privacy and intimate information.
In F. D.
Schoeman, editor, Philosophical Dimensions of Privacy: An
Anthology, pages 403–408. 1984.
[37] F. Schoeman. Gossip and privacy. In R. F. Goodman and
A. Ben-Zeev, editors, Good Gossip, pages 403–408. 1994.
[38] M. Schunter,
P. Ashley,
authorization
and M. Schunter.
C. Powers,
vacy
http://www.zurich.ibm.com/security/enterprise-
privacy/epal/Speciﬁcation/.
language
S. Hada, G. Karjoth,
pri-
2003.
Enterprise
(EPAL
1.1),
[39] A. P. Sistla and E. M. Clarke. The complexity of propo-
the ACM,
linear temporal
Journal of
logics.
sitional
32(3):733–749, July 1985.
[40] L. Sweeney.
k-Anonymity: a model for protecting pri-
vacy. International Journal on Uncertainty, Fuzziness and
Knowledge-based Systems, 10(5):557–570, 2002.
A Temporal logic
Syntax. Formulas free of temporal modalities refer to sin-
gle states in the trace history of the agent world. Our sorts
are P , T , M, R, and C (denoting agents, attributes, mes-
sages, roles, and contexts), with carriers P, T , M, R, and
C, respectively. Our relations are as follows:
send : P × P × M
inrole : P × R
∈ : T × T.
contains : M × P × T
incontext : P × C
Intuitively, send(p1, p2, m) holds in a state of a trace if
agent p1 just sent message m to agent p2; contains(m, q, t)
holds if message m contains the value of attribute t of agent
q; inrole(p, r) holds in a state if agent p is active in role
r; incontext(p, c) holds in a state if agent p is active in a
role of context c; Finally, t ∈ t(cid:2) holds if attribute t can be
computed from (is a component of) attribute t(cid:2).
To generate the syntax of the logic, we use a sort as-
signment Γ.
that records the sorts of variables bound by
quantiﬁers. The recursive deﬁnition ensures that variables
are used only as permitted by their sort. Formally, the set
of terms Termsτ (Γ) of sort τ under sort assignment Γ is
generated as follows:
p ∈ TermsP (Γ)
m ∈ TermsM (Γ)
c ∈ TermsC(Γ)
t ∈ TermsT (Γ)
r ∈ TermsR(Γ)
x ∈ Termsτ (Γ)
for all p ∈ P, t ∈ T , m ∈ M, r ∈ R, c ∈ C, and x : τ ∈ Γ.
Notice we have constant symbols for each element of each
carrier. Formulas for sort assignment Γ are generated using
the following grammar:
ϕΓ ::= send(p1, p2, m) | contains(m, q, t) |
inrole(p, r) | incontext(p, c) | t ∈ t(cid:2) |
ϕΓ ∧ ϕΓ | ¬ϕΓ | ϕΓUϕΓ | ϕΓSϕΓ |
ϕΓ | ∃x : τ.ϕΓ(cid:2)
where p1, p2, q ∈ TermsP (Γ), m ∈ TermsM (Γ), t, t(cid:2) ∈
TermsT (Γ), r ∈ TermsR(Γ), c ∈ TermsC(Γ), x is a vari-
able, τ is a sort, and Γ(cid:2) is the sort assignment that agrees
with Γ on all variables except x, to which Γ(cid:2) assigns sort τ.
We also include equality, deﬁned in the usual manner.
Intuitively, ϕUψ holds just in case ϕ holds until ψ holds,
ψ will eventually hold. The modality “since,” written S is
the past version of U. The formula ϕSψ holds just in case
ϕ has held since ψ held, and ψ has held in the past.
ϕ
holds just in case ϕ holds in the next state. Finally, ∃ is
rigid existential quantiﬁcation.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:47:00 UTC from IEEE Xplore.  Restrictions apply. 
Notation. To simplify notation, we use the following
standard symbols:
ϕ1 ∨ ϕ2 ≡ ¬(¬ϕ1 ∧ ¬ϕ2) ϕ1 → ϕ2 ≡ ¬ϕ1 ∨ ϕ2
ϕ ≡ ¬ ¬ϕ
ϕ ≡ ¬ ¬ϕ
ϕ ≡ (cid:18)Uϕ
ϕ ≡ (cid:18)Sϕ
ϕ1Bϕ2 ≡ ϕ1Sϕ2 ∨ ϕ1
ϕ1Wϕ2 ≡ ϕ1Uϕ2 ∨ ϕ1
∀x : τ.ϕ ≡ ¬∃x : τ.¬ϕ
ϕ is read “eventually ϕ,” and indicates that
The formula
ϕ will eventually hold. Its dual modality,
, is read “hence-
forth.” The modalities
, respectively. We will often write σ |= ϕ in place of
and
σ, 0, η |= ϕ when ϕ has no free variables (and thus does not
depend on η).
are the past forms of
and
Semantics. An environment is a function η from variables
to P ∪ T ∪ M ∪ R ∪ C. We write η |= Γ if, for all x :
τ ∈ Γ, η(x) ∈ Aτ , where Aτ is the carrier for sort τ. If
x ∈ Termsτ (Γ) and η |= Γ,
(cid:4)
[[x]]η =
η(x)
x
if x : τ ∈ Γ,
otherwise.
For all inﬁnite traces σ = (κ0, ρ0, a0), (κ1, ρ1, a1), . . . and
all environments η |= Γ such that p1, p2, q ∈ TermsP (Γ),
t, t(cid:2) ∈ TermsT (Γ), m ∈ TermsM (Γ), r ∈ TermsR(Γ),
and c ∈ TermsC(Γ),
σ, i, η |= send(p1, p2, m)
⇐⇒ ai = ([[p1]]η, [[p2]]η, [[m]]η)
σ, i, η |= contains(m, q, t)
⇐⇒ ([[q]]η, [[t]]η) ∈ content([[m]]η)
σ, i, η |= inrole(p, r)
⇐⇒ ([[p]]η, [[r]]η) ∈ ρi
σ, i, η |= incontext(p, c)
σ, i, η |= t ∈ t(cid:2)
⇐⇒ exists r ∈ [[c]]η such that ([[p]]η, r) ∈ ρi
⇐⇒ ({[[t(cid:2)]]η}, [[t]]η) is a computation rule
We extend |= to formulas in the usual manner:
σ, i, η |= ϕ1 ∧ ϕ2⇐⇒ σ, i, η |= ϕ1 and σ, i, η |= ϕ2
σ, i, η |= ¬ϕ
⇐⇒ σ, i, η (cid:15)|= ϕ
σ, i, η |= ϕ1Uϕ2⇐⇒ exists k ≥ i such that σ, k, η |= ϕ2 and,
for all j, i ≤ j  k implies σ, j, η |= ϕ1
σ, i, η |= ϕ1⇐⇒ σ, i + 1, η |= ϕ1
σ, i, η |= ∃x : τ.ϕ
⇐⇒ exists a ∈ Aτ such that σ, i, η[x → a] |= ϕ
Aτ is the carrier of sort τ, and η[x → a] is the environment
that agrees with η on all variable except x, where η[x → a]
takes on value a.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:47:00 UTC from IEEE Xplore.  Restrictions apply.