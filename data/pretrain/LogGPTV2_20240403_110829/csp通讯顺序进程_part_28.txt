---
## Page 216
不幸的是，这两个通信可能被另一个进程的类似的一对通信叉
事件发生时，进程P或Q川-组通信来更新计数变元
X1T扰
单元，例妇
施，所用的方法称作分时技术；单处理机交替地执行各个进程，
已信服这一论点，则可既过不读。
开，出现
些危险也是已有法则无法处理的。
允许不同进程对同·变元任意穿插地赋值，会带来很多危险，这
则是很简活的，其原因在于每个变元至多只能被一个进程更新，
共享存储不同于5.5节中的局部存储。有关顺序进程的推理的法
程中可以使用通常的机器指分存取共享的存储单元。
发。这种实施方法自然允许并发进程享用公共存储区，在各个进
进程间的交替由外部设备的中断所引发，或由常规的时间片引
全文，就可确定资源的获取和释放是否遵循这类规定。
源时，按标准大序在其后的所有资源都已释放。扫描用户进程的
的。用户也可不按规定次序获取资源，但要保证在获取某一资
在我们的理论中；是用共享变元（4.2节X7）模拟共享存储
此享变元count用于记录某一重要事仲的发生次数。每当该
这类危险可世下列例子说明
并发进程系统的行为可在单个传统的程序内存计算机上实
本节的目的是说明为何要反对使用共享的存储区；如果你亦
count.right?x-→count.right?y->count,left!(y +1)
(count:VAR/(count.left10→(PQ)))
count.right?x;count.left!(x+1)
-→count,leftI(x + 1)-…*
6.3
存储共享
193
---
## Page 217
.计数器的更新。但若有进程不执行P或V，或执行的次序有误，
则会出现乱七八糟的情形，有时甚而无法捉摸。
只要所有进程都遵从这个规定，就不会出现两个进程被此于扰对
计数器增值的临界区就应写成
而在退出临界区时，必须执行事件
在进入临界区时，进程必须发出信号
信号量用作共享的资源
个信号量亦可看作是一个进程，它交替地执行P动作和V动作
更坏的是，如果计算机上有两个处理部件，这个方法就完全不灵
断，从而达到互斥的要求。这样做就大大延迟了对中断的响应；
上实施这一方法时，往往要求在进人临界区后，禁止所有的中
中，确保不出现进程的交替。这串操作称作临界区。在单处理机
确的。
怀疑态度，因为它们输出的统计数字、帐单和-·览表总不是很准
用传统的测试技术去诊断。我对-一些已普使用的操作系统仍持
种错误的出现是极其不确定的；很难让它再现，因此几乎不可能
称为于扰，在设计共享存储的进程时，很易犯这种错误。而且这
其结果是，计数变元的值只增加了1，而未增加2。这类错误就
194
阻止于扰的更强有力的方法是将保护机制植入共享存储的设
更好的解决办法是用E.W,Dijkstra 的二值互斥信号量。一
解决的方法之一是，在不允许被穿插的-串操作执行的过程
mutex.P→
mutex.V -.".
count.right?x-count.left1(x +1)→
SEM=(P→V→SEM)
(W3s:xomu)
mutex,P
mutex.V
—
---
## Page 218
X1重入子程序
期的。例如
确保已获取资源的进程可安全地与其通信。
地获取和释放。这类资源称为串行式重用资源。本节中，我们介
个共享进程必须遵从某些纪律，如交替地输出和输入，或者交替
的附庸进程。为了保证任何时刻至多只有一个进程占用资源，每
施，也可以在带有共享存储装置的单处理机或者多处理机上有
一般的存储器则不应由并发系统共享。这样，不仅可以避免出现
很多很有力的论据表明，共享的资源应该按专门的要求设计，而
而共享资源就可设计为CT（见1.1.4节X2）
增值操作就应是单个原子操作
计中，就存储的使用方式不同而不同。例如，用于计数的变元的
1是1-1函数，故分支的选择完全由环境决定。
效地实施。
干扰事故，而且使你的设计可以用分布式处理部件的网络实
我们将大量使用下标和带下标的算子，它们的含义是不言自
6.2节中我们讨论了，如何使多个行为不同的进程共享单一
举例
313
P;=(P.P,I.)
P;=(P.IP1-P1)
6.4多重资源
count,up
195
---
## Page 219
重人次数不作限制的子程序叫作过程。
这里的D可以只用于一次调用，用后就停止，即
接收结果时所用的指标是相同的。
这个结构仍遵从主要的规定，即发送参数慎时所用的指标和以后
外的实例，也不会形成干扰。消息同的可能穿插如
参数值的doub的实例：即使同时还有另外的并发进程在调用另
穷数组以避免给实例个数以任意限制。如
让一个处理器同时处理更多个进程，因之需要引入并发进程的无
定特定的指标，如2或3，而应使用下列结构，从而可任意选择
由于使用了指标3，故可确保所得到的调用的结果值是来自接受
对这个子程序的典型的调用是
指标
无关紧要的；只要是没被占用都可响应。故在调别进程中不应规
序，可用并发进程数组来定义，如
处理器上并发地运行。可有多个并发实例的子程序叫作重人子程
程。在多处理器的情况下，应允许使用多个子程序实例，在不同
程所调用。如果子程序的计算量较大，则会相应地阻滞调用进
196
每个过程调用
在上例中，子程序的同时动作的实例数不超过27。但很容易
当进程调用重入子程序时，数组的哪个元素响应这个调用是
共享的子程序是串行式可重用的，即每个时刻只能被一个进
(doub.3.left!30->doub.3.right?y→SK1P)
daub.3.left.30,.-doub.2.left.20,
D=left?x→right!(r+x)→STOP
.-doub.3.right.60,..doub.2.right.40,...
一
---
## Page 220
X1)，而不象VAR进程（4.2节X7)。
读出-次。这样，每个扇形区就如同一个COPY进程（4.2节
存储等，由于太昂贵而无法在运行调用进程的机器上设置。
守过程软件的秘密，或者在带有昂贵的专用设备的机器上才能执
相同，使用远程调用往往出自政治的或经济的原因，例如，为保
程在同一个处理器内执行；而共享的过程的调用称为远程调用，
的效果完全相同。但后者是一个本地过程调用，即过程和调用进
的效果，应该和调用附庸进程D
使用方式促使我们以COPY进程模拟扇形区的行为，至于读出
形区i的内容，并释放该扇形区以备其它进程使用。这种简单的
类似地，back.i.righilx作为单个动作，却也同时完成了读出扇
表示获取任意一个编号为：的自由的属形区，并同时写入值b。
来使用该存储器。后备存储亦可出并发进程所共享。这时，动作
在主进程中，通过通信
形区的数组，其下标值小于B，即
是，这个存储介质用的是读出破坏技术，因此写入的信息块只能
每个扇形区贮存一个信息块，由左边输入，向右边输出。遗的
X2后备存储的共享
行过程等。典型的贵重设备如大容量的后备存储器，磁盘或磁泡
即过程可能在一个远处的处理器上执行。远程和本地调用的效果
这个存储用作附进程
一个存储介质分为B个扇形区，各扇形区可被独立地读写。
back.i.left!bl->..baok.i.right?y->...
(back:BSTORE/..)
BSTORE=
I i:COPY
，整个后备存储器就是属
197
---
## Page 221
值，而以后的通信就能正确无误地导向这个资源。
的方式任选一个。获取后，约束变元1以所选的资源的指标为其
一进程。若没有响应者，则等待；若两者都能响应，则以非确定
第一个lp.i.acquire为获取两个 LP进程中的能响应该事件的任
都是可接受的。可用一般的选择结构来表示这种任意的选择，如
时，选中哪一个数组元案是无碍的。所有能响应获取信号的元素
户进程的通信由三个或四个成分构成，例如
LP的每个实例现有两个前缀，一个是名字，
数组本身亦给以名字，这样可用作共享的资源
指出它在数组中的位置，即有
所组成的数组来表示这两台打印机，每个实例标以一个自然数，
6.2节X4中的LP提供了这种保护。我们就使用LP的两个实例
印机都需要保护，以免打印过程中不同文件间的数据相互穿插，
X3两台行式打印机
设计中详尽解释。
绍完例子后，就介绍这种方法，并将在6.5节的操作系统的模块
乱局面。不需付很多代价，就可对共享进程加之上述约束；在介
的输入。
形区输入信息；而且每个这样的输出，必须或早或晚跟随有这样
有在逃程向扇形区输山的信息块未被破坏前，该进程求能从该属
破坏的说法只是一种借口而已。
198
为顺利地共享后备存储，要求共享进程遵守严格的规定。
两台一模一样的行式打印机为若干个用乒进程服务。每台打
如同调用重入过程，当进程需要获取资源数组中的一个资源
，不遵从这类规定，会导致死锁，甚至出现更为糟糕的混
Ip.0.acquire, Ip.1.lefl."A,JONES",.
LP2 = (0:LP I 1:LP)
(lp:LP2/.…*)
，一个是指标；和用
只
[
门
---
## Page 222
须反卷。信号empty如同记号eof（文件末)，表示为
不能再读写了。杂凑文件很象向磁带上输出的文件，在读以前必
故事（6.2节X5)是一样的。
发进程都要使用两台打印机，也会导致死锁，
致死锁，因为这里只有两台打即机可供使用。类似地，若两个拜
的打印机上打印。若用户同时要用三台打即机，这将无疑地会导
用户进程穿插地输出两个文件中成行数据；而且每--行都在相应
f和f2，写成
X4两个输出文件
程进程数组的名字。
记号“；”不同，在它的右边不是-·个完整的进程，
信息块叉从头读一逼。读完后，就给出一个empty信号；然后就
放等也被删去了。新记号“：：”叫作远程附庸关系；它和原来的
其中，局部名myfile表示带有指标的名字lp.i，而术语获取和释
改写成
X5
复杂的结构
程，
杂凑文件用于输出一串信息块。输完后，文件就反卷，整串
(f1::ip //(f2:tp // -·f1left1s1→f2.left!s2→))
只和该进程通信。我们现在修改一下附庸进程的记法，并将
杂凑文件
一个用户进程同时使用两台行式打印机，同时输出两个文件
当进程已获取某共享资源，该资源就应如其本地的附庸进
(myfile::lp / ..myfile,left!x..)
SCRATCH = WRITE :
[rewind-→READ,)
这和安妮和玛丽的
而是一个远
199
---
## Page 223
SCRATCHB叉可用作非共享的附席进程，其用法同于X5中的杂
器就成了它的附庸进程。为提供这样的附庸进程，合
BSCRATCH使用名称back称呼后备存储器（X2），
BSCRATCH= (pagetable:SCRATCH I
X2中的读出破坏的后备存储器。在七存中再存放一个不大的
备存储装中。杂凑文作中的信息块只能读写--逼，故可朵用
X6后备存储中的杂凑文件
后面将别此作为一个共享的进程的模型。
杂凑文件亦可用作非共享的附庸进程，如
件，用卢象使用共享的行式打印机(6.2节X3)那样，朵用获取，
和SCRATCH进程的雕一不同处是规定了最多只允许有B个信息
凑文件，即
标，这样就可按所要次序将信息块再正确地读入主存。表示为
杂凑文件，保留有后备存储器中贮存相应信息块的扇形区的指
若这些块很大，串也很长，存在主存中很不经济了，
X7
块
200
(myfile, SCRATCH !...myfile.lefty ..-myfile.rewind...
X5中的杂凑文件可实施为计算机主存中的“串信息块。但
设想在多个穿插使用的用后中共享后备存储器中的杂凑文
串行重用杂奏文件
SCRATCHB - (back:BSTORE BSCRATCH)
μY.(pagetabte.right?i->back.i,right?x-→right!x→Y
rewind→pagetable,rewind
(myfile:SCRATCHB /.-myfile.lefti...)
[pagetable.empty-empty-→Y)))
READ,=(empty→READ)
..-(myfile,right?x->...
|myfile.empty...)...)
这样后备存储
最好存到后
口
□
---
## Page 224
在每个用户进程中，可用远程附庸关系获取，.使用和释放一个新
享。写为
此处N={ii≥0},
技术（2.6.4节），将构造共享进程数组时的指标（自然数）作为标
块时，又自动地释放扇形区，为共享后备存储，可用多重标记的
凑文件在输出信息块时，先获取一个扇形区，而在输入这个信息
扇形区。后备存储区故可由杂凌文件的无界数组所共享。每个杂
常大的，足可以容纳多个杂奏文件，它们占据着互不相重的一些
它以BSTORE作为其附唐进程