# Title: seL4: From General Purpose to a Proof of Information Flow Enforcement

## Authors:
- Toby C. Murray
- Daniel Matichuk
- Matthew Brassil
- Peter Gammie
- Timothy Bourke
- Sean Seefried
- Corey Lewis
- Xin Gao
- Gerwin Klein

**Affiliations:**
- NICTA
- University of New South Wales, Sydney, Australia

**Email:** [Contact Email]

## Abstract
In contrast to testing, mathematical reasoning and formal verification can demonstrate the absence of entire classes of security vulnerabilities. This paper presents, to our knowledge, the first complete, formal, and machine-checked verification of information flow security for the implementation of a general-purpose microkernel, specifically seL4. Unlike previous proofs, this verification applies to the actual 8,830 lines of C code that implement seL4, thereby eliminating the possibility of invalidation by implementation errors in this code. We assume the correctness of the compiler, assembly code, hardware, and boot code, and we prove everything else. This proof provides strong evidence of seL4’s utility as a separation kernel and describes precisely how the general-purpose kernel should be configured to enforce isolation and mandatory information flow control. We detail the information flow security statement we proved (a variant of intransitive noninterference), including the assumptions on which it rests, and the modifications made to seL4 to ensure enforcement. We also discuss the practical limitations and implications of this result, including covert channels not covered by the formal proof.

## I. Introduction
Provably secure operating systems have been a research topic for over 30 years, with several small, high-assurance separation kernels like INTEGRITY-178B in deployment. However, even the strongest levels of security evaluation schemes, such as Common Criteria, do not demand implementation-level proofs, which were previously thought to be infeasible. Modern mainstream operating systems are often riddled with security problems, and even hypervisors like Xen, proposed as a solution, have exhibited critical vulnerabilities.

This paper presents the first fully machine-checked, mathematical proof that a high-performance, general-purpose microkernel C code implementation enforces strong information flow control. Together with existing proofs of seL4’s functional correctness and integrity enforcement, this work shows that seL4 provably enforces strong access control mechanisms, particularly the high-level security properties of confidentiality and integrity. Our proof explicitly states how to configure the general-purpose OS kernel to enforce isolated partitions with controlled communication channels. Unlike previous information flow verifications, ours applies to the actual 8,830 lines of C code that implement seL4, rather than to a manually abstracted model of its behavior. Our main proof assumptions stem from the foundational work on functional correctness. We assume the correctness of the compiler, assembly code, hardware, and boot code; we prove everything else. The verified seL4 kernel runs on commodity ARMv6 and ARMv7 hardware and is available commercially under the product name OKL4:verified, as well as freely in binary form for academic use.

The information flow property we prove for seL4 is a variant of intransitive noninterference, which enforces confidentiality on storage channels and logical time. As is typical for noninterference results, fine-grained timing behavior of the hardware is not covered by the formal baseline model and thus not by the proof. This means covert timing channels still need to be mitigated by complementary techniques. We argue that for modern commodity hardware, the absence of such channels is not fully enforceable, and the best that can be expected is to reduce channel bandwidth based on the risk profile of a particular deployment.

We analyze the limitations and strengths of the proof statement in detail in Section V. By formally stating the assumptions under which seL4 enforces information flow security, this result also provides an unambiguous description of how seL4 should be configured to enforce a particular information flow policy. The strongest restriction on such configurations is the absence of direct memory access (DMA) for devices, a common restriction shared with commercial separation kernels in deployment. New hardware mechanisms such as IOMMUs may enable us to relax this in the future.

In detail, the technical contributions of this work are:
- To our knowledge, the most detailed and extensive machine-checked formal verification of information flow security ever for a general-purpose OS kernel.
- A formal, precise, and unambiguous description of how to configure the general-purpose seL4 microkernel to enforce a given information flow policy.
- Achieving the above results without sacrificing performance or preventing the use of the dynamic general-purpose microkernel API inside partitions.

To achieve this result, we extended the seL4 API minimally by adding a static partition-based scheduler common to separation kernels. We disallow none of the seL4 API other than requiring that seL4 be configured to prevent asynchronous interrupt delivery to user-space partitions, which would introduce an information channel. This means device drivers must poll for device interrupts via memory-mapped I/O, a typical behavior for separation kernels and high-assurance systems.

While traditional separation kernels typically provide no system calls at all after initial configuration, in our general-purpose seL4 setting, all other kernel facilities are available within partitions, including dynamic memory allocation and revocation, intra-partition inter-thread messaging, capability transfer, and shared memory. Between partitions, seL4 provides asynchronous notifications and shared memory to facilitate unidirectional communication. The information flow security theorem implies that these primitives are free of storage back-channels, and that the dynamic intra-partition services do not violate information flow security either. A modified version of the paravirtualized Linux system Wombat allows an entire Linux instance and its applications to run within a partition, enabling mandatory information flow control policies to be enforced between untrusted and legacy applications, with guarantees on information flow provided by a strong machine-checked theorem.

During the proof of noninterference, we did not find any information-flow problems in the seL4 kernel that required code changes, as we had hoped given the previous intensive work on proving functional correctness and integrity. However, we did find several API features that had to be explicitly forbidden for inter-partition use. For experts, most of these were not surprising. For instance, it is well-known that synchronous IPC will introduce an information flow back-channel, but the proof clearly identified all instances, including some that were not immediately obvious, such as capability deletion potentially and observably crossing partition boundaries. All of these could be excluded by reasonable restrictions on supported seL4 configurations, detailed in Section IV and summarized in Section V.

Our security proof—like all others—is not an iron-clad statement of general security for seL4, but rather a powerful piece of evidence about seL4’s security mechanisms and its suitability as a separation kernel. Importantly, any system-level security evaluation can now concentrate its effort on validating proof assumptions, which is a much simpler job than asserting information flow security, and on using complementary techniques for the remaining items not covered by our proof (detailed in Section V). Furthermore, the proof statement addresses whole high-level classes of attack, such as information leakage to confined subjects without access to timing sources, and the evaluation can be guided by precise formal statements of policy and system deployment assumptions. The security proof gives precise predictions about the strength of mechanisms; the previous functional correctness proof shows that these mechanisms will be reliably enforced by the implementation.

The remainder of this paper is organized as follows. We briefly summarize the attacker/threat model in Section II. We then discuss background material in Section III, including the seL4 API and how it can be used to implement separation and information flow control, as well as past formal seL4 verification work that our proof builds upon. We present our formal statement of information flow security and discuss its proof in Section IV. We consider its implications and limitations in Section V. Section VI situates our result in the context of related work before we conclude.

## II. Threat Model
Our target deployment scenario is a physically secured, high-assurance, uni-processor system with trusted hardware. The system may potentially have access to untrusted networks and run mutually distrusting application software. The security goal for the kernel is to only permit information flows according to the partitions and information flow policy it was configured with.

The threat model assumes that all user-level code after system initialization is malicious and acting in concert to break the information flow policy. The attacker’s goal is to read or indirectly infer the contents (i.e., private state) of a partition that, according to the information flow policy, should remain secret to it. The attacker is assumed to know the configuration and code of the entire system, including the kernel, but not the contents of other partitions.

As mentioned, timing channels are not in the scope of this proof and must be analyzed by complementary techniques. The channels that are in scope are storage channels and causal deduction. The attacker may run any sequence of instructions or attempt any kernel call to break the information flow policy. Our proof statement is that, subject to the limitations and assumptions discussed in Section V, the attacker will not succeed.

## III. Background

### A. The seL4 Kernel API
The seL4 microkernel provides a minimal set of mechanisms for implementing secure systems: threads, capability management, virtual address spaces, inter-process communication (IPC), and interrupt delivery. The state of each instance of a service is maintained within the kernel by data structures termed kernel objects. For example, for each thread in a system, there is a thread object that stores the information relevant to scheduling, execution, and access control. User-space programs can only refer to kernel objects indirectly through capabilities, each of which combines a reference to a specific object with a set of access rights. For example, a thread cannot start, stop, or read or modify the registers of another unless it possesses a capability for the corresponding thread object.

Capabilities are managed by the kernel and stored in kernel objects called CNodes. Each thread object also contains several distinguished capabilities. One of these defines the root of a thread’s CSpace: a directed graph of the CNodes the thread can access. A user-space program refers to capabilities in its CSpace via addresses that specify paths relative to its CSpace root. It is possible to fabricate an address but never a capability; invalid addresses are simply rejected during decoding. We say that a thread invokes a capability when it passes the address of that capability to a system call. For instance, a CNode capability can be invoked to copy, move, delete, or derive (reduce the associated access rights of) the capabilities contained within it.

Besides access control, capabilities also serve to manage memory. Unallocated memory is made available through Untyped memory capabilities that can be retyped into kernel objects like CNodes or thread objects. Retyping creates fresh capabilities that refer to the newly created objects, and which are derived from the original Untyped capability. The revoke system call deletes all capabilities derived from the invoked Untyped capability, effectively reclaiming all resources allocated from within it and providing a useful way of destroying an entire subsystem in a single system call.

Untyped memory can also be allocated to kernel objects representing page directories, page tables, and pages. Another of the distinguished capabilities stored in each thread object refers to the page directory at the root of the associated thread’s virtual address space (VSpace). By invoking this capability, and those for the associated page tables and pages, a thread can direct the kernel to configure the memory management unit of the underlying platform. In particular, multiple threads that each possess capabilities to the same physical pages may each map those pages into their respective VSs and thereafter communicate by reading and writing to the shared memory.

Threads can also communicate and synchronize by sending messages through IPC endpoints. There are two types of endpoint: synchronous, where a sender blocks waiting for a receiver; and asynchronous, where a sender never blocks. Capabilities to either kind of endpoint may carry the Send and Receive access rights; a thread with a Send capability to an endpoint can use it to transmit messages to any thread that has a Receive capability to the same endpoint. In addition, capabilities for synchronous endpoints may also carry the Grant right that allows senders to transmit capabilities to receivers in the style of classical take-grant systems. Interrupts are polled at these points, and if necessary, an active system call may be suspended until the requesting thread is next scheduled to run.

### B. Using seL4 as a Separation Kernel
As a microkernel, seL4 is designed to provide mechanisms for implementing secure systems.