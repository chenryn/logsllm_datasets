to log in to an account he doesn’t own. Considering some
leniency for typing errors, this creates a reliable system for
triggering alerts. The vouching site is in a position to notify
the target site that a speciﬁc user is failing to authenticate
even through he has managed to do so at the target site.
At the same time, the target site will notice repeated SAuth
sessions failing at the vouching parties even though local au-
thentication goes through. Overall, the nature of the SAuth
design oﬀers indications of anomalous activity that would
otherwise go unnoticed.
4.
IMPLEMENTATION
We deﬁne the SAuth protocol messages as a set of URIs
[21] which makes it easier to project them on a URI-oriented
application-level protocol such as HTTP [11]. We assume
that the user is represented by an agent program, e.g., a web
browser. Although we focus on HTTP, as it is employed
by web services, our design can be applied to any other
application-level protocol provided it supports the concept
of end-point redirection. We group our messages into two
categories; registration and authentication messages deﬁned
as registration and authentication URIs respectively.
For a target service and a vouching service to engage in
an SAuth session, they need to be aware of each other’s end-
points. Registration and authentication end-points may be
explicitly exchanged oﬄine upon prior agreement, or they
may be retrieved automatically from an XML ﬁle, named
sauth.xml by convention, hosted under the domain of each
service and served over a secure network layer such as SSL,
e.g., https://www.example.org/sauth.xml. This enables
users of a target service to include a vouching service of
their choosing by supplying the voucher’s domain name in
the target service’s SAuth activation page. Alternatively,
users can select one of the pre-conﬁgured vouching services.
To realize the technical issues from the adoption of our
protocol by a web application we have implemented it in
its entirety in PHP and subsequently developed adopting
sample applications including both a front and back end.
We argue that once SAuth is oﬀered as a module or library
it requires eﬀort comparable to the use of OAuth and similar
authorization protocols, something which a plethora of sites
today uses. Our implementation is less than 1000 LoC.
Registration. A user who registers with S selects a
vouching party from a list of cooperating services or may
specify one of his choosing by specifying its domain name
as described earlier (Listing 1, line 1). Note that selection
of a vouching service or introduction of a new one is only
1
2
3
4
5
1
2
3
4
5
6
7
8
9
10
11
schema :// T A R G E T _ S E R V I C E _ S/ r e g i s t r a t i o n
[ username , password , v o u c h i n g _ s e r v i c e]
schema :// T A R G E T _ S E R V I C E _ S/ r e g i s t r a t i o n
[ action =" commit " , service =
V O U C H I N G _ S ERV IC E_V , alias =
FOREIGN_ALIAS , nonce = NONCE , signature ,
s i g n e d _ f i e l d s=" action , service , alias ,
nonce "]
Listing 1: SAuth registration messages as URIs.
schema :// V O U C H I N G _ S E R V I C E _ V/ a u t h e n t i c a t i o n
[ action =" r e g i s t e r _ a l i a s" , alias =
FOREIGN_ALIAS , service =
TARGET_SERVICE_S , nonce = NONCE ,
signature , s i g n e d _ f i e l d s=" action ,
alias , service , nonce "]
schema :// T A R G E T _ S E R V I C E _ S/ a u t h e n t i c a t i o n
[ username , password , v o u c h i n g _ s e r v i c e]
schema :// V O U C H I N G _ S E R V I C E _ V/ a u t h e n t i c a t i o n
[ action =" vouch " , service = TARGET_SERVICE_S ,
nonce = NONCE , signature , s i g n e d _ f i e l d s="
action , service , nonce "]
schema :// T A R G E T _ S E R V I C E _ S/ a u t h e n t i c a t i o n
[ action =" verify " , alias = FOREIGN_ALIAS ,
service = V O U C H I N G _ S ER VIC E_ S , nonce =
NONCE , signature , s i g n e d _ f i e l d s="
action , alias , service , nonce "]
Listing 2: SAuth authentication messages as URIs.
possible upon registering a new account with the target ser-
vice or after successfully authenticating to an existing one,
through SAuth if enabled. The response of service S to the
user-agent’s registration request is a redirection towards the
authentication end-point of the selected vouching service V
(Listing 2, line 1) with the parameter action set to instruct
the vouching service to ﬁrst authenticate the user and then
associate the resulting account with an anonymous alias that
has been just generated. Service S also binds that alias with
the newly registered account once it receives conﬁrmation
from V . Assuming the current user has an account with
service V , he provides his credentials to authenticate.
If
the current user has enabled SAuth on service V , a synergy-
enhanced authentication process will follow. Note that if the
user does not have an account with V , he can optionally cre-
ate one at this point, but even if he does not, such cases can
be handled in the manner discussed in Sec. 3.2. Eventually
the user successfully authenticates or creates a new account
with V . Service V then redirects the user’s agent back to
service S while setting parameter action to signal service S
that it should bind the generated alias to the current user’s
account. This conveys to S that the alias has been associ-
ated with the user’s account on V and it will be part of a
future vouching authentication process (Listing 1, line 4).
This completes the registration process under SAuth. Note
that activating SAuth is not strongly tied to creating a user
account on S and can take place independently.
Authentication. To authenticate under the enhanced
process of SAuth a user initially visits the service he wants
to access, labeled as target service S. He is prompted for
his name and password. He is also asked to select a vouch-
ing service V (Listing 2, line 4). This selection may either
1921
2
3
4
5
6
7
8
9
10
11
12
13
14
15
[ A u t h e n t i c a t i o n Request to example . com ( S ) ]
POST / login HTTP /1.1
Host : www . example . com
username = bob & password = password & v o u c h i n g _ s e r v i c e=
example . org
[ A u t h e n t i c a t i o n Response from example . com ]
HTTP /1.1 303 See other
Location : https :// www . example . org / login ? action =
vouch & service = example . com & nonce =...& s i g n a t u r e
=...& s i g n e d _ f i e l d s= action %2 Cservice %2 Cnonce
[ A u t h e n t i c a t i o n Request to example . org ( V ) ]
GET / login HTTP /1.1
Host : www . example . org ? action = vouch & service = example
. com & nonce =...& s i g n a t u r e =...& s i g n e d _ f i e l d s=
action %2 Cservice %2 Cnonce
...
Listing 3: Example use of HTTP redirection to relay
the ﬁrst message of the SAuth protocol between the
target and vouching service through the user agent.
take place in the same screen as the log-in form or after his
credentials are authenticated by S.
In the ﬁrst case he is
given the option of selecting any of the vouching services S
supports. This is to avoid revealing to attackers the vouch-
ing service(s) a given user employs. In the second case, he is
given the option of selecting only from the vouching services
that have already been associated with his account through
a foreign alias. Note that if the user speciﬁed a vouching
party of his choosing through its domain name that party
will be available as an option at this point. Target service
S then redirects the user’s agent to V while setting the pa-
rameter action to signal that a vouching for current user is
expected from the remote service (Listing 2, line 7).
The user then presents his credentials in an authentica-
tion request towards service V for his respective account.
On successful local authentication with V , the service’s re-
sponse to the user agent redirects it to the target service S
while setting parameter action to signal that current user
has successfully authenticated with some account, that the
associated foreign alias is included in the response, and that
service S should verify this vouching response and decide
whether the returned foreign alias matches the alias bound
to the user’s account on S. On match, service S has success-
fully authenticated the user using SAuth and can optionally
return a persistent authentication token, such as an HTTP
cookie, to the user’s agent so that future interactions with
service S can skip the enhanced authentication in a manner
similar to the way users don’t have to type their password
for each HTTP request their web browser makes.
HTTP User-agent redirection. To facilitate message
relaying through the user agent in HTTP we employ 3xx
redirection messages [11]. For service S to redirect the user
agent to service V , it responds to the user agent’s request
with the 303 “See other” status code. It also includes the
Location header with its value being that of a URI under
the service V domain that targets the desired end-point and
carries the information it wants to communicate to V in the
form of parameters. Listing 3 presents an example where
the user agent is redirected to service V with a vouching
request after successfully authenticating to service S.
Cryptographic Signatures. As the user agent is re-
sponsible for relaying messages between the target service
and vouching services, it is necessary to ensure the integrity
of those messages. We assume that the secrecy of the mes-
sages is preserved as long as the user agent maintains SSL
connections with the two services and that there is no need
for the messages to be hidden from the user agent. We im-
plement cryptographic signatures using 1024-bit RSA key
pairs and the SHA-1 digest algorithm. Each protocol mes-
sage must contain the parameters service, signature and
signed_fields. The ﬁrst parameter identiﬁes the sender
and is used to retrieve the necessary information for veri-
fying the signature. The last parameter speciﬁes which pa-
rameters are contained in the signature.
Web services use the same private key that supports their
HTTPS connections with clients and thus the correspond-
ing public key is protected under an X.509 public key certiﬁ-
cate. For a service to verify a signature in SAuth, it uses the
service identiﬁer to locate the corresponding URL for the
sender. If the hostname of the sender service is used as the
identiﬁer, the service connects to the sender and downloads
its public-key certiﬁcate. There are other ways to resolve
an identiﬁer to a hostname or URL but they are outside
the scope of this paper. After retrieving the certiﬁcate, the
service tries to verify the signature over the parameters spec-
iﬁed by the signed_fields parameter. On success, the pa-
rameters are committed to the current user session. HTTP
parameters not covered by the signature are discarded. If
a parameter is speciﬁed twice, only the instance carrying a
value which causes the signature veriﬁcation to succeed is
kept. Finally, if a signature fails the request is terminated
immediately and no processing takes place.
Apart from the integrity of protocol messages, it is very
important to ensure their freshness and avoid replay attacks.
For that matter, a nonce is generated per message and per
user and is bound to the current user’s session state that a
service maintains. That nonce is included as a parameter
to the protocol message sent to a remote service and the
respective response is expected to carry the same nonce.
Nonces do not survive the termination of a user session.
5. PASSWORD REUSE
SAuth is rendered moot when a user is sharing the same
password across web sites acting as vouching services. Un-
fortunately this is quite common in practice where a pass-
word is reused across six diﬀerent web sites [40] on average.
In essence reuse intensiﬁes the problem of password leak-
age [17, 34]. Password managing software, nowadays oﬀered
natively by web browsers, could remedy the situation but
usability issues are presently obstructing wide adoption.
5.1 Decoys
In the spirit of recent research [27, 43], we propose plac-
ing decoy passwords in databases to introduce uncertainty
about the actual passwords chosen by users. In other words,
anyone examining the password database, including an at-
tacker who has compromised it, will discover that every user
account has N passwords instead of one. Any of those pass-
words can successfully authenticate the user to the service
and that is a key diﬀerence between our proposal and Kam-
ouﬂage [27] as well as Honeywords [43]. That is because
decoy passwords carry no marks and receive no special treat-
193(1) Single-site authentication
(2) Two-site authentication without decoys
(3) Two-site authentication with decoys
P S−1
(P S 2)−1
K1 · K2 · (P S 2)−1
(pwd reuse)
P S−1
P S−1
P S−1
(a) normal login
(b) normal login
(c) leaked
(d) leaked
(pwd reuse)
1 ✗
P S−1 ✓
1 ✗
1 ✗
K2 · P S−1 ✓
K1−1 ✓
Table 1: Probabilities of diﬀerent log-in events under current and our proposed authentication systems. Case
(a) refers to the normal scenario where someone without any prior knowledge of the password attempts to log
in to a service while case (b) is a special sub-case where the user of the target account is reusing his password
in more than one services. Cases (c) and (d) refer to the scenario where a service has been compromised and
the user’s password for that service leaked. Our approach (2) oﬀers a signiﬁcant increase in the security of
cases (a), (b) and (c) but not (d). For that matter we couple our proposed system with decoys which overall
decreases the probability of an attacker logging in all four cases.
ment from the service to eliminate heuristics that could dis-
tinguish them from the actual user-set passwords.
Decoy Generation. Generating decoys indistinguish-
able from actual data is an interesting research area. Bowen
et al. have worked on providing believable decoys at the