# 四、设计微服务和多层应用
让我们详细介绍一下我们在上一章中看到和了解到的关于更高级的微服务和 N 层应用的开发和部署。本章将介绍这些设计方法的底层架构，并解决构建这些类型的应用时面临的典型问题。我们将在本章中讨论以下主题:
*   整体建筑模式
*   n 层应用架构
*   构建、测试和自动化 N 层应用
*   微服务架构模式
*   构建、测试和自动化微服务
*   将多层应用分离成多个映像
*   让不同的应用层工作
如今，作为服务构建的现代软件正在引起应用设计方式的转变。今天的应用不是使用 web 框架来调用服务和生成网页，而是通过消费和生成 API 来构建的。业务应用的开发和部署已经发生了很大的变化，有些变化非常显著，有些变化是通过对过去设计方法的修改或扩展实现的，这取决于您的观点。存在几种体系结构设计方法，它们可以通过为企业构建的应用、网络和云来区分。
尤其是在过去几年中，发展趋势充斥着诸如**微服务架构** ( **MSA** )这样的术语，它们适用于作为独立可部署服务套件的特定应用设计和开发方式。微服务架构风格的迅速崛起显然是当今部署发展中不可辩驳的力量；从单片架构到 N 层应用和微服务，已经有了相当大的转变，但这其中到底有多少是炒作，又有多少可以磨练？
# 炒作还是狂妄
在我们开始深入故障排除之前，我们应该提供现代应用以及 N 层和微服务架构风格的基本上下文概述。了解这些架构风格的优点和局限性将有助于我们规划潜在的故障排除领域，以及我们如何避免它们。容器非常适合这两种架构方法，我们将分别讨论每一种方法，以给出它们应有的结果。
在所有这些噪音中，我们有时会忘记，要在这些域中部署系统，仍然需要在工作的分布式应用中创建服务并组合多个服务。在这里，重要的是理解术语应用的现代含义。应用现在主要被构造为异步消息流或同步请求调用(如果不是两者都有)，用于形成由这些连接联合的组件或服务的集合。参与的服务高度分布在不同的机器和不同的云(私有、公共和混合)中。
至于架构风格，我们不会过多地比较自己，也不会过于详细地讨论微服务实际上是什么，以及它们与**面向服务架构** ( **SOA** )是否有任何不同——在其他地方肯定有很多论坛和相关的辩论供您选择。设计原则至少可以追溯到 Unix，因此我们不会在本书中提供任何权威的观点，即当前的微服务趋势要么在概念上是单一的，要么是完全巧妙的。相反，我们将提出实现这种体系结构方法的主要考虑因素，以及为现代应用获得的好处。
用例仍然驱动和支配架构方法(或者，在我看来，应该如此)，因此在所有主要架构风格之间进行某种程度的比较分析是有价值的:**单体**、 **N 层**和**微服务**。
# 单片架构
单片基本上是一个包含所有服务和依赖项的部署单元，使它们易于开发、易于测试、相对易于部署，并且最初易于扩展。然而，这种风格不能满足大多数现代企业应用(N 层)和大规模 web 开发的必要需求，当然也不能满足部署到云中的(微服务)应用的需求。变更周期是紧密耦合的——所做的任何变更，即使是对应用的最小部分，都需要对整个整体进行大规模的重建和重新部署。随着整体的成熟，任何扩展的尝试都需要扩展整个应用，而不是单个部分，这特别需要更多的资源，变得非常可怕，如果不是不可能的话。在这一点上，一个单一的应用已经变得过于复杂，被越来越难以破译的大量代码所占据，以至于像 bug 修复或实现新特性这样的关键业务项目变得太耗费时间而无法尝试。随着代码库变得不可理解，期望所做的任何更改都可能是不正确的才是合理的。应用规模的迅速增长不仅减缓了开发速度，还阻碍了持续开发；要更新整块的任何部分，必须重新部署整个应用。
![Monolithic architecture](img/Untitled.jpg)
整体建筑模式
单片的其他问题比比皆是，资源无法满足更好的需求，例如，中央处理器或内存需求。由于所有模块都在运行相同的进程，任何错误都可能导致整个进程停止。最后，采用更新的框架或语言变得更加困难，这为采用新技术制造了巨大的障碍——你可能会被项目开始时所做的任何技术选择所困扰。不用说，你的需求可能从一开始就发生了相当大的变化。使用过时的非生产性技术使得留住和引进新人才变得更加困难。该应用现在已经变得非常难以扩展并且不可靠，使得应用的敏捷开发和交付变得不可能。一块巨石最初的轻松和简单很快成为它自己的致命弱点。
由于这些单体架构基本上是一个无所不用其极的部署单元，因此出现了 N 层和微服务架构来满足现代化应用(主要是基于云和移动的应用)的专业服务需求。
# N 层应用架构
为了理解 N 层应用及其与微服务解耦的潜力，我们将把它与单片风格进行比较，因为 N 层应用的开发和微服务的激增都是为了解决我们在单片架构方法中发现的过时条件下发现的许多问题。
N 层应用架构，也称为**分布式应用**或**多层**，提供了一个开发人员可以创建灵活和可重用应用的模型。由于应用被分成多个层，开发人员可以选择修改或添加一个或多个特定的层，而不需要像单片系统那样对整个应用进行必要的返工。多层应用是在多个层中开发和分布的任何应用。它在逻辑上将不同的应用特定层和操作层分开。层数因业务和应用需求而异，但三层是最常用的架构。多层应用用于将企业应用分成两个或多个组件，这些组件可以分别开发、测试和部署。
n 层应用本质上是 SOA，试图解决过时的单一设计架构的一些问题。正如我们在前面几章中看到的，Docker 容器是 N 层应用开发的完美匹配。
![N-tier application architecture](img/Untitled-1.jpg)
n 层应用架构
一个普通的 N 层应用由三层组成:一个 **PRESENTATION TIER** (提供基本的用户界面和应用服务访问) **DOMAIN LOGIC TIER** (提供用于访问和处理数据的机制)和一个 **DATA STORAGE TIER** (保存和管理静态数据)。
### 注
虽然层和层的概念经常互换使用，但一个相当普遍的观点是，它们实际上是有区别的。这种观点认为*层*是组成软件解决方案的元素的逻辑结构化机制，而*层*是系统基础设施的物理结构化机制。除非在我们的书中特别指出，我们将交替使用层和层。
在 N 层应用中分离各个层的最简单方法是为您希望包含在应用中的每个层创建离散的项目。例如，表示层可能是 Windows 窗体应用，而数据访问逻辑可能是位于中间层的类库。此外，表示层可能通过服务与中间层的数据访问逻辑进行通信。将应用组件分成不同的层增加了应用的可维护性和可伸缩性。它通过更容易地采用新技术来做到这一点，新技术可以应用于单个层，而不需要重新设计整个解决方案。此外，N 层应用通常将敏感信息存储在中间层，中间层与表示层保持隔离。
大概 N 层应用开发最常见的例子就是网站；这方面的一个例子可以在我们上一章使用的`cloudconsulted/joomla`映像中看到，Joomla、Apache、MySQL 和 PHP 都是*将*分层为单个容器中的层。
对我们来说，简单地递归使用我们的`cloudconsulted/joomla`映像(从前面开始)已经足够容易了，但是让我们构建一个经典的三层 web 应用来展示一些其他的应用潜力，并为我们的开发团队引入另一个单元测试工具。
## 构建三层网络应用
让我们借助以下容器来开发和部署一个真实世界的三层 web 应用:
NGINX > Ruby on Rails > PostgreSQL:
NGINX Docker 容器(Dockerfile)，如下所示:
```
## AngularJS Container build  
FROM nginx:latest 
# Download packages 
RUN apt-get update 
RUN apt-get install -y curl   \ 
                   git    \ 
                   ruby \ 
                   ruby-dev \     
                   build-essential 
# Copy angular files 
COPY . /usr/share/nginx 
# Installation 
RUN curl -sL https://deb.nodesource.com/setup | bash - 
RUN apt-get install -y nodejs \ 
                  rubygems 
RUN apt-get clean 
WORKDIR /usr/share/nginx 
RUN npm install npm -g 
RUN npm install -g bower 
RUN npm install  -g grunt-cli 
RUN gem install sass 
RUN gem install compass 
RUN npm cache clean 
RUN npm install 
RUN bower -allow-root install -g 
# Building 
RUN grunt build 
# Open port and start nginx 
EXPOSE 80 
CMD ["/usr/sbin/nginx", "-g", "daemon off;"]
```
Rails 上的 Rails Docker 容器(Dockerfile)，如图所示:
```
## Ruby-on-Rails Container build 
FROM rails:onbuild 
# Create and migrate DB 
RUN bundle exec rake db:create 
RUN bundle exec rake db:migrate 
# Start rails server 
CMD ["bundle", "exec", "rails", "server", "-b", "0.0.0.0"]
```
PostgreSQL Docker 容器，如图所示:
```
 ## PostgreSQL Containers build 
# cloudconsulted/postgres is a Postgres setup that accepts remote connections from Docker IP (172.17.0.1/16).  We can therefore make use of this image directory so there is no need to create a new Docker file here. 
```
前面的 Dockerfiles 可用于部署三层 web 应用，并帮助我们开始使用微服务。
# 微服务架构
为了开始解释微服务架构风格，再次与单片进行比较将是有益的，就像我们对 N 层所做的那样。您可能还记得，单个应用是作为单个单元构建的。此外，回想一下，单体企业应用通常围绕三个主要层构建:客户端用户界面(由在用户机器上的浏览器中运行的 HTML 页面和 JavaScript 组成)、数据库(由插入到公共且通常是关系型数据库管理系统中的许多表组成)和服务器端应用(处理 HTTP 请求、执行域逻辑、从数据库中检索和更新数据，以及选择和填充要发送到浏览器的 HTML 视图)。单片企业应用的这个经典版本是一个单一的逻辑可执行文件。对系统的任何更改都涉及构建和部署服务器端应用的新版本，底层技术的更改可能并不谨慎。
## 通往现代性的道路
微服务代表了现代云和现代应用开发的融合，围绕以下内容构建:
*   组件化服务
*   围绕业务能力的组织
*   产品，而不是项目
*   智能端点和哑管道
*   分散治理和数据管理
*   基础设施自动化
在这里，单片一般侧重于**企业服务总线** ( **ESB** )用来集成单片应用，现代应用设计是 API 驱动的。这些现代应用在各个方面都包含 API:在前端用于连接富客户端，在后端用于与内部系统集成，在侧面允许其他应用访问其内部数据和流程。许多开发人员发现，与其利用更复杂的传统企业机制，还不如利用同样的轻量级应用编程接口服务，这些服务已被证明对前端、后端和应用到应用的场景具有弹性、可伸缩性和敏捷性。同样引人注目的是，容器，尤其是在微服务架构方法中，减轻了开发人员被排除在架构决策之外的长期问题，同时仍然实现了可重复性的好处。使用预先批准的容器配置。
### 微服务架构模式
在这里，我们说明了我们已经将应用分成了更小的、互连的服务(即微服务)，实现了应用的每个功能领域，而不是一个单一的、巨大的单个应用。这使我们能够直接部署，以满足特定用例或特定设备或用户的需求/或者/微服务方法，简而言之，规定不是拥有一个所有开发人员都接触的庞大代码库，这通常变得难以管理，而是有许多由小型敏捷团队管理的更小的代码库。这些代码库相互之间唯一的依赖是它们的 API:
![Microservices architectural pattern](img/Untitled-2.jpg)
微服务架构模式
### 注
围绕微服务的一个常见讨论是关于这是否只是 SOA 的争论。在这一点上存在一些有效性，因为微服务风格确实分享了 SOA 的一些优点。实际上，SOA 意味着许多不同的东西。因此，我们提交并将试图表明，虽然共享的相似性确实存在，但是 SOA 仍然与这里呈现的微服务架构风格有很大不同。
### 微服务的共同特征
虽然我们不会尝试微服务架构风格的正式定义，但是我们肯定可以使用一些共同的特征来识别它。微服务通常围绕业务能力和优先级进行设计，包括多个组件服务，这些服务可以独立自动化部署，而不会影响应用、智能端点以及对语言和数据的分散控制。