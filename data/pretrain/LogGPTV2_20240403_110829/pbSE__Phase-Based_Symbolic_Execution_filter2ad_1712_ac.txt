1239
1163
621
619
569
569
652
644
1125
413
644
652
1h
1687
1801
sym-10000
10h
1h
1051
1013
1206
1141
621
603
571
571
641
641
1103
413
634
662
10h
2455
2597
From the table we can see, KLEE covers no more than
1239 BBs with different search strategies in 10 hours, while
pbSE can cover 2597 BBs in 10 hours. There are less than
10 minutes cost in the concolic execution and phase analysis
steps, so we do not consider the time cost in our experiments
that consume more than 10 hours.
pbSE ﬁrst divides the execution into phases, and the results
are shown in Fig 4(b). And then pbSE performs symbolic
execution on every phase according to the schedule strategy
mentioned in Section III. Finally, pbSE can perform symbolic
execution to cover the basic blocks in different phases that
not covered by KLEE, and more new code is also covered,
which enhances code coverage by 109% compared with the
best results of KLEE.
139
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:01:47 UTC from IEEE Xplore.  Restrictions apply. 
In the second experiment, We apply pbSE and KLEE to the
other three programs mentioned above to perform evaluation of
coverage. For libpng and libtiff, we select seeds from the test
cases provided by the project randomly. We choose random-
path and covnew search strategy for KLEE, because they are
generally considered to be the best ones.
Table II gives the results of code coverage for each program.
The ﬁrst column gives the name of the program and test
driver we used. Columns from the second column to the
ninth give the results of random-path search strategy of KLEE
with different size of symbolic ﬁle. Columns from the tenth
to seventeenth give the coverage results of covnew strategy.
The eighteenth and nineteenth columns represent the number
of bbs covered by pbSE. The twentieth column shows the
enhancement achieved by pbSE over the best result of KLEE.
Table II shows the results of code coverage. In the libdwarf
testing, KLEE covers 491 BBs in the best case, while pbSE
cover 1045 BBs, which is 112%more than KLEE. For libpng,
the number of BBs covered by pbSE is higher than that of
KLEE by 121%. And for libtiff, 134% higher. For libpng in
the experiment we can see that the results of code coverage
for KLEE in performing the 1-hour test and 10-hour test are
almost the same. This is because in the 1-hour test of libpng,
symbolic execution has already entered a trap phase, and code
coverage naturally stops increasing. Our method can perform
test to each individual phase, therefore can cover far more
code.
It is noteworthy that pbSE can identify more trap phases
than previous approaches. Phases division of gif2tiff are
showed in Fig 4, in which different colors represent different
phases, and the identiﬁed trap phases are marked by text(tp
represents trap phase). Fig 4(a) gives the phase results obtained
by dividing BBVs without code coverage. Fig 4(b) gives
the results by combining BBVs and code coverage. From the
ﬁgures it can be seen that phases obtained by BBVs only are
more widely dispersed, so only two trap phases are identiﬁed.
While four trap phases are obtained by combining BBV and
code coverage for more continuously distributed code grouped.
(a) Trap phases identiﬁed by using BBVs without code coverage
(b) Trap phases identiﬁed by combining BBVs and code coverage
Fig. 4. Different results of phase division, different colors show different
phases.
C. Bug Detection
Due to more new code is covered, pbSE can ﬁnd more
bugs. In our experiments, we discover 21 unknown bugs, 2 in
140
libpng, 5 in libtiff, 4 in readelf, and 10 in libdwarf. Of the 21
bugs, 7 are assigned CVE ID. Table III presents the details.
The ﬁrst column gives the name of the tested packet. The
second column shows test drivers used in the experiment. The
third column (s-size) gives the size of seeds used by pbSE. The
fourth column (t-p) shows the number of trap phases identiﬁed
in the tests. The ﬁfth column (b-p) shows index of the phase
in which the bug is found. The rightest column shows CVE
ID of the bug if assigned.
We describe below two representative errors found by pbSE,
and compare its bug-ﬁnding ability against standard symbolic
execution.
(a) Concrete execution using normal seed
(b) Concrete execution using buggy seed
Fig. 5.
Code distribution of concrete execution using normal and buggy
seed of tiff2rgba, (a) shows the code distribution using a normal seed, and its
phases divded by pbSE are showed on top portion of the ﬁgure, (b) shows
the code distribution using a buggy seed.
libtiff case study: libtiff is a library program to read tag
information of TIFF image ﬁles, and it includes 24 test tools
such as gif2tiff, tiff2pdf, tiff2rgba, etc. These tools analyze
TIFF image ﬁles by calling libtiff. The version we tested in
our experiments is libtiff-4.0.6, which has 62373 lines of code
counted by cloc.
In the test of libtiff, pbSE reports more than 20 errors, which
include at least 5 unknown bugs according to our analysis. Of
them, 3 are error of memory-out-of-bound-read, 1 memory-
out-of-bound-write, and 1 integer-overﬂow. Here we take one
memory-out-of-bound-read as example. This bug is detected
when tiff2rgba is being tested, and the seed is chosen randomly
from internet.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:01:47 UTC from IEEE Xplore.  Restrictions apply. 
RESULTS OF BASIC BLOCKS’ NUMBER COVERED IN TESTING libtiff, libpng AND libdwarf
TABLE II
program
binutils-2.26
readelf
libtiff-4.06
gif2tiff
libpng-1.2.56
pngtest
libdwarf-20150115
dwarfdump
sym-10
1h
10h
914
541
606
460
916
541
606
465
random-path
sym-100
1h
10h
sym-1000
1h
10h
sym-10000
1h
10h
sym-10
1h
10h
sym-100
1h
10h
sym-1000
1h
10h
covnew
sym-10000
1h
10h
1h
pbSE
10h
inc
1162
1205
1163
1239
1141
1206
573
843
462
573
843
495
567
846
465
567
848
492
567
846
453
567
848
482
662
541
606
460
662
541
606
470
604
558
825
455
604
561
843
488
569
566
843
453
569
567
843
506
571
544
825
457
571
544
835
502
1801
2597
109%
1012
1457
134%
1445
1878
121%
932
1045
112%
TABLE III
BUGS FOUND BY PBSE
package
test-driver
libpng
libtiff
pngtest
gif2tiff
tiff2rgba
tiff2bw
libdwarf
dwarfdump
binutils
readelf
s-size
8796
407
243
1428
1428
9456
8336
6908
8200
43600
7960
8336
t-p
9
4
4
5
5
11
10
7
9
9
5
7
b-p
3
5
3
3
3
3
3
3
2
5
6
3
5
5
5
4
3
3
4
5
4
CVEID
CVE-2015-7981
CVE-2015-8540
CVE-2015-8538
CVE-2015-8750
CVE-2016-2050
N
N
N
N
N
N
N
N
N
N
N
N
N
N
CVE-2016-2091
CVE-2014-9482
The code which includes the bug is shown in Fig 6. In
function putconig8bitCIELab(at line 1647), the w and h values
can be read from the ﬁle and can be a symbolic value when
symbolic execution is performed. The size of memory which
pp points to is a ﬁxed value. In our test it is 257 bytes. When
h*w*3 is larger than 257, the memory read by the pp will be
out of bound.
Here we mention this bug because the test of this bug is
an excellent illustration of the advantage of pbSE. In our
experiment, pbSE identiﬁes 4 trap phases, and it is in testing
the third phase that this bug is found. Fig 5(a) gives BB
distribution in concrete execution with a normal seed and the
division of phases. Fig 5(b) gives BB distribution in concrete
execution with a seed which triggers the bug.
A comparison of Fig 5(a) and Fig 5(b) shows that the bug
is not triggered until the program has been executed for some
time (about 4 seconds). From the phases divided by pbSE(top
portion of Fig 5(a)) we can see that it is the third trap phase
that triggers the bug. In the test using KLEE, after 10 hours
of testing KLEE only reaches the second phase; while pbSE
detects the bug in one hour.
libpng case study: libpng is an ofﬁcial PNG image library,
which is widely used in many operating systems and applica-
tions. In the test of libpng we use pngtest program as the test
driver, and pngtest.png as the seed. Both of them are provided
by the project.
1 #define DECLAREContigPutFunc(name) \
2 static void name(\
3
4
5
6
7
8
9 )
TIFFRGBAImage* img, \
uint32* cp, \
uint32 x, uint32 y, \
uint32 w, uint32 h, \
int32 fromskew, int32 toskew, \
unsigned char* pp \
for (x = w; x-- > 0;) {
TIFFCIELabToXYZ(img->cielab,
float X, Y, Z;
uint32 r, g, b;
(void) y;
fromskew *= 3;
while (h-- > 0) {
1640 DECLAREContigPutFunc(putcontig8bitCIELab)
1641 {
1642
1643
1644
1645
1646
1647
1648
1649
1650