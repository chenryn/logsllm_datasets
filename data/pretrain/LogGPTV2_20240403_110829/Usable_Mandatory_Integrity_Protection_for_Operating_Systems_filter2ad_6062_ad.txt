In our experiments, we use the NetCat tool to offer an
interactive root shell to the attacker in the experiment. We
execute NetCat in “listen” mode on the test machine as root.
When the attacker connects to the listening port, NetCat
spawns a shell process, which takes input from the attacker
and also directs output to him. From the root shell, we per-
form the following three attacks and compare what happens
without our protection system with what happens when our
protection system is enabled.
1. Installing a rootkit: rootkits can operate at two different
levels. User-mode rootkits manipulate user-level operating
system elements, altering existing binary executables or li-
braries. Kernel-mode rootkits manipulate the kernel of the
operating system by loading a kernel module or manipu-
lating the image of the running kernel’s memory in the ﬁle
system (/dev/kmem).
We use two methods to determine whether a system
has been compromised after installing a rootkit. The ﬁrst
method is to try to use the rootkit and see whether it is
successfully installed. The second method is to calculate
the hash values for all the ﬁles (content, permission bits,
last modiﬁed time) in the local ﬁle system before and af-
ter installing the rootkit. For the calculation we reboot the
machine using an external operating system (e.g., from a
CD) and mount the local ﬁle system. This ensures that
the running kernel and the programs used in the calcula-
10
Services and
Path of the Binary
SSH Daemon
/usr/sbin/sshd
Automated Update:
/usr/bin/yum
/usr/bin/vim
/usr/bin/cat
FTP Server
/usr/sbin/vsftpd
Web Server
/usr/sbin/httpd
Samba Server
/usr/sbin/smbd
NetBIOS name server
/usr/sbin/nmbd
Version control server
/usr/bin/svnserve
Name Server for NT
/usr/sbin/winbindd
SMTP Server
/usr/sbin/sendmail
Mail Processor
/usr/bin/procmail
NTP Daemon
/usr/sbin/ntpd
Printing Daemon
/usr/sbin/cupsd
System Log Daemon
/usr/sbin/syslogd
NSF RPC Service
/sbin/rpc.statd
IP Table
/sbin/iptables
Type
RAP
RAP
FPP
FPP
NONE
NONE
NONE
NONE
NONE
NONE
NONE
NONE
NONE
NONE
NONE
File Exceptions
Capability Exceptions
Executing
Relationships
(/var/log/xferlog, full)
(/etc/vsftpd, full, R)
(/etc/shadow, read)
(/var/log/httpd, full, R)
(/etc/pki/tls, read, R)
(/var/run/httpd.pid, full)
(/var/cache/samba, full, R)
(/etc/samba, full, R)
(/var/log/samba, full, R)
(/var/run/smbd.pid, full)
(/var/log/samba, full, R)
(/var/cache/samba, full, R)
(/usr/local/svn, full, R)
(/var/cache/samba, full, R)
(/var/log/samba, full, R)
(/etc/samba/secrets.tdb, full)
(/var/spool/mqueue, full, R)
(/var/spool/clientmqueue,
full, R)
(/var/spool/mail, full, R)
(/etc/mail, full, R)
(/etc/aliases.db, read)
(/var/log/mail, full, R)
(/var/run/sendmail.pid, full)
(/var/spool/mail, full, R)
(/var/lib/ntp, full, R)
(/etc/ntp/keys, read)
(/etc/cups/certs, full, R)
(/var/log/cups, full, R)
(/var/cache/cups, full, R)
(/var/run/cups/certs, full R)
(/var/log, full, R)
CAP SYS CHROOT
CAP SYS SETUID
CAP SYS SETGID
CAP NET BIND SERVICE
CAP SYS RESOURCE
CAP SYS SETUID
CAP SYS SETGID
CAP NET BIND SERVICE
CAP DAC OVERRIDE
CAP NET BIND SERVICE
/usr/sbin/procmail
CAP SYS TIME
CAP NET BIND SERVICE
CAP DAC OVERRIDE
NONE
(/var/lib/nfs/statd, full, R)
NONE
CAP NET ADMIN
CAP NET RAW
Figure 3. Sample policy
11
tion are clean. A comparison between the hash results can
tell whether the system has been compromised.
We tried two well-known rootkits. The ﬁrst one is
Adore-ng, a kernel-mode rootkit that runs on Linux Kernel
2.2 / 2.4 / 2.6. It is installed by loading a malicious kernel
module. The supported features include local root access,
ﬁle hiding, process hiding, socket hiding, syslog ﬁltering,
and so on. Adore-ng also has a feature to replace an existing
kernel module that is loaded during boot with the trojaned
module, so that adore-ng is activated during boot. When our
protection was not enabled, we were able to successfully
install Adore-ng in the remote root shell and activat it. We
were also able to replace any existing kernel module with
the trojaned module so that the rootkit module would be
automatically loaded during booting. When our protection
system was enabled, the request to load the kernel module
of Adore-ng from the remote root shell was denied, getting
an “Operation not permitted” error. We got the same er-
ror when trying to replace the existing kernel module with
the trojaned module. When trying to use the rootkit, we
received a response saying “Adore-ng not installed”. We
checked the system integrity using the methods described
above. The result showed that the system remained clean.
The second is Linux Rootkit Family (LRK). It is a well-
known user-mode rootkit and replaces a variety of exist-
ing system programs and introduce some new programs, to
build a backdoor, to hide the attacker, and to provide other
attacking tools. When our protection was not enabled, we
were able to install the trojaned SSH daemon and replace
the existing SSH daemon in the system. After that we suc-
cessfully connected to the machine as root using a prede-
ﬁned password. When our protection was enabled, installa-
tion of the trojaned SSH daemon failed, getting the “Oper-
ation not permitted” error. The system remained clean.
2. Stealing the shadow File: Without our protection sys-
tem, we were able to steal /etc/shadow by send an email
with the ﬁle as an attachment, using the command “mutt -a
/etc/shadow PI:EMAIL < /dev/null”. When our pro-
tection was enabled, the request to read the shadow ﬁle was
denied, getting an error saying “/etc/shadow: unable to at-
tach ﬁle” .
3. Altering user’s web page ﬁles: Another common attack
is to alter web ﬁles after getting into a web server. In our
experiment, we put the user’s web ﬁles in a sub directory
of the user’s home directory “/home/Alice/www/”. That di-
rectory and all the ﬁles under the directory were set as not
writable by the world. When our protection was enabled,
from the remote root shell, we could not modify any web
ﬁles in the directory “/home/Alice/www/”. We could not
create a new ﬁle in that directory. Our module successfully
prevented user’s protected ﬁles from being changed by low-
integrity processes.
Performance We have conducted benchmarking tests to
compare performance overhead incurred by our protection
system. Our performance evaluation uses the Lmbench 3
benchmark and the Unixbench 4.1 benchmark suites. These
microbenchmark tests were used to determine the perfor-
mance overhead incurred by the protection system for vari-
ous process, ﬁle, and socket low-level operations.
We set up a PC conﬁgured with RedHat Linux Fedora
Core 5, running on Intel Pentium M processor with 1400Hz,
and having 120 GB hard drive and 1GB memory. Each
test was performed with two different kernel conﬁgurations.
The base kernel conﬁguration corresponds to an unmodi-
ﬁed Linux 2.6.11 kernel. The enforcing conﬁguration corre-
sponds to a Linux 2.6.11 kernel with our protection system
loaded as a kernel module.
The test results are given in Figure 4 and Figure 5. We
compare our performance result with SELinux. The perfor-
mance data of SELinux is taken from [14]. For most bench-
mark results, the percentage overhead is small (≤ 5%). The
performance of our module is signiﬁcantly better than the
data for SELinux.
5 Related Work
In Section 3.7 we have compared UMIP with Biba [4]
and LOMAC [10]. Another well-known integrity model is
the Clark-Wilson model [7], which divides data items into
constrained data items (CDI’s) and unconstraint data items
(UDI’s). CDI’s are considered to have high integrity, and
can be changed only by transformation procedures (TP’s)
that are certiﬁed to change the CDI’s in ways that preserve
their integrity. The Clark-Wilson model requires that, for
each TP, the system lists which CDI’s the TP is certiﬁed to
access. PACL [23] also uses the idea of limiting the pro-
grams that can access certain objects.
It uses an access
control list for each ﬁle to store the list of programs that
are allowed to access the ﬁle. Later approaches store such
information with programs. As we have discussed in Sec-
tion 3.1, determining access based just on the user id and
the program that is running (without considering the his-
tory) is limited. While the policy exception part has its root
in Clark-Wilson, UMIP is fundamentally different in that it
maintains dynamic integrity levels for subjects and objects.
Our work differs from previous work that add MAC into
UNIX, such as Trusted Solaris and IX [15], in that our
goal is not multi-level security, but rather to preserve sys-
tem integrity when the softwares running on the system are
buggy and there are network-based attackers. Other sys-
tems that are closely related to ours include SELinux [16],
systrace [17], LIDS [13], securelevel [11], and AppAr-
mor [8, 1]. As we discussed in Section 1, SELinux, sys-
trace, and LIDS, while ﬂexible and powerful, require exten-
sive expertise to conﬁgure. These systems focus on mech-
anisms, whereas our approach focuses on providing a pol-
12
Benchmark
Dhrystone
Double-Precision
Execl Throughput
File Copy 1K
File Copy 256B
File Copy 4K
Pipe Throughput
Process Creation
Shell Scripts
System Call
Overall
Base
335.8
211.9
616.6
474.0
364.0
507.5
272.6
816.9
648.3
217.9
446.6
Enforcing Overhead (%)
334.2
211.6
608.3
454.2
344.1
490.4
269.6
801.2
631.2
217.4
435.0
0.5
0.1
1
4
5
3
1
2
0.7
0.2
3
SELinux(%)
5
5
10
2
16
2
4
Figure 4. The performance results of Unixbench 4.1 measurements.
Microbenchmark
syscall
read
write
stat
fstat
open/close
select on 500 fd’s
select on 500 tcp fd’s
signal handler installation
signal handler overhead
protection fault
pipe latency
pipe bandwidth
AF UNIX sock stream latency
AF UNIX sock stream bandwidth
fork+exit
fork+execve
for+/bin/sh-c