Generic
Chosen Preﬁx
Chosen Preﬁx
239
239
248
2128−X
277
265
0
277
2128
2128
296
2128
2160
2128
2160
2160
2X conn.
277
TABLE I.
SUMMARY OF TRANSCRIPT COLLISION ATTACKS ON INTERNET PROTOCOLS
48 core hours
48 core hours
80 GPU days
REFERENCES
[1] D. Adrian, K. Bhargavan, Z. Durumeric, P. Gaudry, M. Green,
J. A. Halderman, N. Heninger, D. Springall, E. Thom´e, L. Va-
lenta, B. VanderSloot, E. Wustrow, S. Zanella-B´eguelin,
,
and P. Zimmermann. Imperfect forward secrecy: How difﬁe-
hellman fails in practice. In ACM CCS, 2015.
J. Altman, N. Williams, and L. Zhu. Channel bindings for TLS.
IETF RFC 5929, 2010.
[2]
[3] S. Bellovin and E. Rescorla. Deploying a new hash algorithm.
In NDSS, 2006.
[4] F. Bergsma, B. Dowling, F. Kohlar, J. Schwenk, and D. Stebila.
Multi-ciphersuite security of the secure shell (ssh) protocol. In
ACM CCS, pages 369–381, 2014.
[5] K. Bhargavan, A. Delignat-Lavaud, and A. Pironti. Veriﬁed
contributive channel bindings for compound authentication. In
NDSS, 2015.
[6] K. Bhargavan, A. D. Lavaud, C. Fournet, A. Pironti, and P.-
Y. Strub. Triple handshakes and cookie cutters: Breaking and
ﬁxing authentication over TLS. In IEEE S&P (Oakland), 2014.
I. B. Damg˚ard. A design principle for hash functions.
In
CRYPTO’89, 1990.
[7]
[8] T. Dierks and E. Rescorla. The Transport Layer Security (TLS)
Protocol Version 1.2. IETF RFC 5246, 2008.
[9] T. Dierks and E. Rescorla. The Transport Layer Security (TLS)
Protocol Version 1.3. Internet Draft, 2014.
[10] M. Friedl, N. Provos, and W. Simpson. Difﬁe-Hellman Group
Exchange for the Secure Shell (SSH) Transport Layer Protocol.
IETF RFC 4419, 2006.
[11] F. Giesen, F. Kohlar, and D. Stebila. On the security of TLS
renegotiation. In ACM CCS, 2013.
[12] D. Gillmor. Negotiated Finite Field Difﬁe-Hellman Ephemeral
Parameters for TLS. Internet Draft, 2015.
[13] S. Halevi and H. Krawczyk. Strengthening digital signatures
via randomized hashing. In CRYPTO, 2006.
[14] B. Hill, D. Baghdasaryan, B. Blanke, R. Lindemann, and
J. Hodges. FIDO UAF Application API and Transport Binding
Speciﬁcation v1.0. Draft Speciﬁcation, 2015.
[15] P. Hoffman. Use of Hash Algorithms in Internet Key Exchange
(IKE) and IPsec. IETF RFC 4894, 2007.
[16] P. Hoffman and B. Schneier. Attacks on Cryptographic Hashes
in Internet Protocols. IETF RFC 4270, 2005.
[17] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk. On the security
of TLS-DHE in the standard model. In CRYPTO, 2012.
[18] A. Joux. Multicollisions in iterated hash functions. application
to cascaded constructions. In CRYPTO, 2004.
J. Kelsey and T. Kohno. Herding hash functions and the
nostradamus attack. In EUROCRYPT, 2006.
[19]
[20] D. Knuth. Seminumerical algorithms, volume 2 of the art of
computer programming, 1981.
[21] H. Krawczyk.
SIGMA: The SIGn-and-MAc approach to
authenticated Difﬁe-Hellman and its use in the IKE protocols.
In CRYPTO. 2003.
[22] H. Krawczyk, K. G. Paterson, and H. Wee. On the security of
the TLS protocol: A systematic analysis. In CRYPTO, 2013.
[23] A. Langley. Transport Layer Security (TLS) Snap Start. Internet
Draft, 2010.
[24] A. Langley. Transport Layer Security (TLS) Next Protocol
Negotiation Extension. Internet Draft, 2012.
[25] G. Leurent. Practical key-recovery attack against APOP, an
MD5-based challenge-response authentication. IJACT, 1(1):32–
46, 2008.
[26] N. Mavrogiannopoulos, F. Vercauteren, V. Velichkov, and
B. Preneel. A cross-protocol attack on the TLS protocol. In
ACM CCS, 2012.
[27] F. Mendel, C. Rechberger, and M. Schl¨affer. MD5 is weaker
than weak: Attacks on concatenated combiners. In ASIACRYPT,
2009.
[28] A. Menon-Sen, N. Williams, A. Melnikov, and C. New-
man. Salted Challenge Response Authentication Mechanism
(SCRAM) SASL and GSS-API Mechanisms. IETF RFC 5802,
2010.
[29] R. C. Merkle. A certiﬁed digital signature.
In CRYPTO’89,
[30]
[31]
1990.
J. M. Pollard. A monte carlo method for factorization. BIT
Numerical Mathematics, 15(3):331–334, 1975.
J. M. Pollard. Monte carlo methods for index computation.
Mathematics of computation, 32(143):918–924, 1978.
[32] A. Popov, M. Nystroem, D. Balfanz, and A. Langley. The
Token Binding Protocol Version 1.0. Internet Draft, 2015.
[33] M. Stevens. Hashclash. https://marc-stevens.nl/p/hashclash/.
[34] M. Stevens. Counter-cryptanalysis. In CRYPTO, 2013.
[35] M. Stevens. New collision attacks on SHA-1 based on optimal
joint local-collision analysis. In EUROCRYPT, 2013.
[36] M. Stevens, A. K. Lenstra, and B. de Weger. Chosen-preﬁx
IJACT, 2(4):322–359,
collisions for MD5 and applications.
2012.
[37] P. C. van Oorschot and M. J. Wiener. Parallel collision search
J. Cryptology, 12(1):1–28,
with cryptanalytic applications.
1999.
[38] X. Wang and H. Yu. How to break MD5 and other hash
functions. In EUROCRYPT, 2005.
[39] T. Ylonen and C. Lonvick. The Secure Shell (SSH) Transport
Layer Protocol. RFC 4253 (Proposed Standard), 2006.
[40] P. Zimmermann. ZRTP: Media Path Key Agreement for Unicast
Secure RTP. IETF RFC 6189, 2012.
15
M
M(cid:48)
M(cid:48)
M
Fig. 9. Multi-collision attack
SHA-1
MD5
IV (cid:48)
1
IV1
IV (cid:48)
2
IV2
x(cid:48)
0
x0
x(cid:48)
0
x0
h1
h2
h1
h2
H
Generic
H1|H2
MD5
SHA-1
MD5 | SHA-1
Collision
2N/2
CPC
2N/2
2N1 /2N2/2 + 2N2 /2
2N1/2N2/2 + 2N2/2
216
261
267
239
277
277
TABLE II.
COMPLEXITY OF FINDING COLLISIONS IN VARIOUS
HASH CONSTRUCTIONS
H1
IV1
H2
IV2
x0
x1
x2
x3
x4
x5
x(cid:48)
0
x(cid:48)
1
x(cid:48)
2
x(cid:48)
3
x(cid:48)
4
x(cid:48)
5
APPENDIX
A. Attacks against Hash Functions
We now give more details about attacks against hash
function, considering both generic attacks and dedicated
attacks against widely-used functions MD5 and SHA-1.
The main results are summarizex in Table II.
Generic collision attacks While a basic collision
attack requires to compute and store 2N/2 images of
the hash function, it is possible to mount a parallel and
memory-less attack with a very small overhead. The
main idea was introduced by Pollard as the Rho algo-
rithm for factorization [30] and discrete logarithms [31],
and was later generalized to collision search. The hash
function is ﬁrst restricted from {0, 1}∗ → {0, 1}N to
{0, 1}N → {0, 1}N , so that it can be iterated. After
some number of steps, a chain of iterations reaches a
cycle, and the graph will have the shape of the greek
letter ρ. On average, the cycle has length O(2N/2) and
is reached after O(2N/2) steps. The point where the
tail of the meets with the cycle reveals a collision in
the hash function. It can be detected in time O(2N/2)
with little or no memory, using various cycle detection
methods, such as Floyd’s algorithm [20] (also known as
tortoise and hare).
Some variants of this attack using distinguished
points can be parallelized efﬁciently. We now describe
a parallel version of Pollard’s Lambda algorithm, as
described by van Oorschot and Wiener [37], using c
CPUs. Each CPU will compute iteration chains of the
function H, and stop when reaching a distinguished
point, that is a point with some easy to test property. For
instance, we stop a computation when the ending point
satisﬁes x < 2N/2αc for some small constant α, so that
the expected length of a chain is 2N/2/αc. When a chain
is ﬁnished, we store the starting point, the length, and
the ending point. We generate αc chains in this way, so
that the function has been evaluated about 2N/2 times,
and there is a high probability that there was a collision.
The important idea of this attack is that if a given point
is reached by two different chains, both chain will stop
at the same distinguished point. Therefore, we look at
the ending points of the chains, and when a collision is
detected, we restart the chains from the starting point in
Fig. 10. CPC attack against MD5 | SHA-1
order to locate the collision. This attack requires about
2N/2 evaluations of H, and a memory of αc when using
c CPUs.
This attack can be tweaked for a chosen-preﬁx col-
lision attack using an auxiliary function g : {0, 1}N →
{0, 1}N deﬁned as:
if x is even
if x is odd.
(cid:26)H(P|x)
H(P (cid:48)|x)
g(x) =
Collisions in g can be found with the previous
techniques. With probability 1/2 a collision is g is
between an even x and an odd x(cid:48) (or vice versa), this
implies a chosen-preﬁx collision H(P|x) = H(P (cid:48)|x(cid:48)).
An accurate complexity analysis is provided in [37]:
a collision is expected to be found after (cid:112)π2N /2
evaluations. For a chosen-preﬁx collision, we expect to
ﬁnd two collisions in g after
π2N evaluations.
√
Concatenation Collisions in the concatenation of two
hash functions H1|H2 can be found with roughly the
same effort as breaking the strongest one of the two,
using the multi-collision technique of Joux [18].
The adversary ﬁrst ﬁnds a collision pair (x0, x(cid:48)
0)
for H1, starting from the initialization value of H1.
Then it ﬁnds a collision pair (x1, x(cid:48)
1) starting from
H1(x0) = H1(x(cid:48)
0). This deﬁnes 4 messages with the
same H1-digest: x0|x1, x0|x(cid:48)
0|x1, x(cid:48)
0|x(cid:48)
1. After N2/2
steps, this deﬁnes a set of 2N2/2 messages with the
1, x(cid:48)
16
same H1-digest. With high probability, two of these
messages have the same H2-digest as well (see Fig-
ure 9). Therefore, one can ﬁnd a collision in H1|H2
with a complexity only N2/2 × 2N1/2 + 2N2/2. For
MD5| SHA-1, this translates to 280, roughly as much
as a generic collision attack on SHA-1.
Better attacks against MD5| SHA-1 result from the
combination of Joux’s multicollision technique with
shortcut attacks against SHA-1. A collision attack can
be build for a cost of 64 × 261 + 264 ≈ 267 (building
sequentially 64 collisions for MD5). For a chosen-
preﬁx collision, we ﬁrst perform a chosen-preﬁx col-
lision against SHA-1, to generate messages (x, x(cid:48)) such
that SHA-1(P|x) = SHA-1(P (cid:48)|x(cid:48)). Then we build
a multicollision in SHA-1 starting from this value,
and we evaluate MD5 over a set of 264 messages
in order to ﬁnd a collision. The total cost is about
277 + 64 × 261 + 264 ≈ 277 (see Figure 10).
Moreover it has been shown that it is possible to
combine cryptanalytic shortcuts both on SHA-1 and
MD5, assuming that collision attacks against SHA-1
improve in the future [27]. This may allow collision
attacks against MD5| SHA-1 with less than 264 work.
Table II summarizes the currently-known complexities
for computing various hash collisions.
B. Transcript Collision Attacks on IKEv2 and SSH-2
Fig. 11. Man-in-the-middle initiator impersonation attack on IKEv2.
The initiator I connects to the responder R but a man-in-the-middle
attacker A intercepts and tampers with some messages (shown in
red). A pecomputes a collision (C1, C2) between the preﬁxes of two
SA INIT messages that both begin with a cookie payload. Then by
sending a carefully crafted cookie to I, A can trigger a transcript
collision on the initiator signature, which it can then forward to R,
thereby impersonating I on a connection that it controls.
Fig. 12. Man-in-the-middle downgrade attack on SSH-2. The client
C connects to a server S, but a network attacker A tampers with the
key exchange messages (shown in red) to downgrade them to a weak
ciphersuite. To succeed, A must compute a chosen-preﬁx collision on
the session hash H after receiving C’s key exchange message.
17