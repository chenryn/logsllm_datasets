title:DREBIN: Effective and Explainable Detection of Android Malware in
Your Pocket
author:Daniel Arp and
Michael Spreitzenbarth and
Malte Hubner and
Hugo Gascon and
Konrad Rieck
Drebin: Effective and Explainable Detection
of Android Malware in Your Pocket
Daniel Arp⇤, Michael Spreitzenbarth†, Malte H¨ubner⇤, Hugo Gascon⇤, and Konrad Rieck⇤
⇤University of G¨ottingen, Germany
Email: ﬁPI:EMAIL
†Siemens AG, Munich, Germany
Email: PI:EMAIL
Abstract—Malicious applications pose a threat to the security
of the Android platform. The growing amount and diversity of
these applications render conventional defenses largely ineffective
and thus Android smartphones often remain unprotected from
novel malware. In this paper, we propose DREBIN, a lightweight
method for detection of Android malware that enables identifying
malicious applications directly on the smartphone. As the limited
resources impede monitoring applications at run-time, DREBIN
performs a broad static analysis, gathering as many features
of an application as possible. These features are embedded in
a joint vector space, such that typical patterns indicative for
malware can be automatically identiﬁed and used for explaining
the decisions of our method. In an evaluation with 123,453
applications and 5,560 malware samples DREBIN outperforms
several related approaches and detects 94% of the malware
with few false alarms, where the explanations provided for each
detection reveal relevant properties of the detected malware.
On ﬁve popular smartphones, the method requires 10 seconds
for an analysis on average, rendering it suitable for checking
downloaded applications directly on the device.
I.
INTRODUCTION
Android is one of the most popular platforms for smart-
phones today. With several hundred thousands of applications
in different markets,
it provides a wealth of functionality
to its users. Unfortunately, smartphones running Android are
increasingly targeted by attackers and infected with malicious
software. In contrast to other platforms, Android allows for
installing applications from unveriﬁed sources, such as third-
party markets, which makes bundling and distributing applica-
tions with malware easy for attackers. According to a recent
study over 55,000 malicious applications and 119 new malware
families have been discovered in 2012 alone [18]. It is evident
that there is a need for stopping the proliferation of malware
on Android markets and smartphones.
The Android platform provides several security measures
that harden the installation of malware, most notably the
Android permission system. To perform certain tasks on the
device, such as sending a SMS message, each application
has to explicitly request permission from the user during
the installation. However, many users tend to blindly grant
Permission(cid:1) to(cid:1) freely(cid:1) reproduce(cid:1) all(cid:1) or(cid:1) part(cid:1) of(cid:1) this(cid:1) paper(cid:1) for(cid:1) noncommercial(cid:1)
purposes(cid:1)is(cid:1)granted(cid:1)provided(cid:1)that(cid:1)copies(cid:1)bear(cid:1)this(cid:1)notice(cid:1)and(cid:1)the(cid:1)full(cid:1)citation(cid:1)
on(cid:1)the(cid:1)ﬁrst(cid:1)page.(cid:1)Reproduction(cid:1)for(cid:1)commercial(cid:1)purposes(cid:1)is(cid:1)strictly(cid:1)prohibited(cid:1)
without(cid:1)the(cid:1)prior(cid:1)written(cid:1)consent(cid:1)of(cid:1)the(cid:1)Internet(cid:1)Society,(cid:1)the(cid:1)ﬁrst-named(cid:1)author(cid:1)
(for(cid:1) reproduction(cid:1) of(cid:1) an(cid:1) entire(cid:1) paper(cid:1) only),(cid:1) and(cid:1) the(cid:1) author’s(cid:1) employer(cid:1) if(cid:1) the(cid:1)
paper(cid:1)was(cid:1)prepared(cid:1)within(cid:1)the(cid:1)scope(cid:1)of(cid:1)employment.
NDSS(cid:1)’14,(cid:1)23-26(cid:1)February(cid:1)2014,(cid:1)San(cid:1)Diego,(cid:1)CA,(cid:1)USA
Copyright(cid:1)2014(cid:1)Internet(cid:1)Society,(cid:1)ISBN(cid:1)1-891562-35-5
http://dx.doi.org/(cid:18)(cid:17)(cid:15)(cid:18)(cid:21)(cid:24)(cid:19)(cid:19)(cid:16)(cid:79)(cid:69)(cid:84)(cid:84)(cid:15)(cid:19)(cid:17)(cid:18)(cid:21)(cid:15)(cid:19)(cid:20)(cid:19)(cid:21)(cid:24)
permissions to unknown applications and thereby undermine
the purpose of the permission system. As a consequence,
malicious applications are hardly constrained by the Android
permission system in practice.
A large body of research has thus studied methods for
analyzing and detecting Android malware prior to their in-
stallation. These methods can be roughly categorized into
approaches using static and dynamic analysis. For example,
TaintDroid [11], DroidRanger [40] and DroidScope [37] are
methods that can monitor the behavior of applications at run-
time. Although very effective in identifying malicious activity,
run-time monitoring suffers from a signiﬁcant overhead and
can not be directly applied on mobile devices. By contrast,
static analysis methods, such as Kirin [13], Stowaway [15]
and RiskRanker [21], usually induce only a small run-time
overhead. While these approaches are efﬁcient and scalable,
they mainly build on manually crafted detection patterns which
are often not available for new malware instances. Moreover,
most of these methods do not provide explanations for their
decisions and are thus opaque to the practitioner.
In this paper, we present DREBIN, a lightweight method
for detection of Android malware that infers detection patterns
automatically and enables identifying malware directly on
the smartphone. DREBIN performs a broad static analysis,
gathering as many features from an application’s code and
manifest as possible. These features are organized in sets of
strings (such as permissions, API calls and network addresses)
and embedded in a joint vector space. As an example, an
application sending premium SMS messages is cast
to a
speciﬁc region in the vector space associated with the cor-
responding permissions, intents and API calls. This geometric
representation enables DREBIN to identify combinations and
patterns of features indicative for malware automatically using
machine learning techniques. For each detected application the
respective patterns can be extracted, mapped to meaningful
descriptions and then provided to the user as explanation for
the detection. Aside from detection, DREBIN can thus also
provide insights into identiﬁed malware samples.
Experiments with 123,453 applications from different mar-
kets and 5,560 recent malware samples demonstrate the efﬁ-
cacy of our method: DREBIN outperforms related approaches
[13, 26, 33] as well as 9 out of 10 popular anti-virus scanners.
The method detects 94% of the malware samples with a false-
positive rate of 1%, corresponding to one false alarm in 100
installed applications. On average the analysis of an application
requires less than a second on a regular computer and 10
seconds on popular smartphone models. To the best of our
Feature sets
Used permissions
Suspicious API calls
Network addresses
...
Malicious 
(+)
Benign 
(–)
Linear
model
Feature sets
Used permissions
Suspicious API calls
Network addresses
...
(a) Broad static analysis
(b) Embedding in vector space
(c) Learning-based detection
(d) Explanation
Fig. 1: Schematic depiction of the analysis steps performed by DREBIN.
Android app
(apk)
knowledge, DREBIN is the ﬁrst method which provides effec-
tive and explainable detection of Android malware directly on
smartphone devices.
In summary, we make the following contributions to the
detection of Android malware in this paper:
•
•
•
Effective detection. We introduce a method combining
static analysis and machine learning that is capable
of identifying Android malware with high accuracy
and few false alarms, independent of manually crafted
detection patterns.
Explainable results. The proposed method provides an
explainable detection. Patterns of features indicative
for a detected malware instance can be traced back
from the vector space and provide insights into the
detection process.
Lightweight analysis. For efﬁciency we apply linear-
time analysis and learning techniques that enable
detecting malware on the smartphone as well as ana-
lyzing large sets of applications in reasonable time.
We need to note here that DREBIN builds on concepts
of static analysis and thus cannot rule out the presence of
obfuscated or dynamically loaded malware on mobile devices.
We speciﬁcally discuss this limitation of our approach in
Section IV. Due to the broad analysis of features however,
our method raises the bar for attackers to infect smartphones
with malicious applications and strengthens the security of the
Android platform, as demonstrated in our evaluation.
The rest of this paper is organized as follows: DREBIN
and its detection methodology are introduced in Section II.
Experiments and a comparison with related approaches are
presented in Section III. Limitations and related work are
discussed in Section IV and Section V, respectively. Section VI
concludes the paper.
II. METHODOLOGY
To detect malicious software on a smartphone, DREBIN
requires a comprehensive yet
lightweight representation of
applications that enables determining typical indications of
malicious activity. To this end, our method employs a broad
static analysis that extracts feature sets from different sources
and analyzes these in an expressive vector space. This process
is illustrated in Figure 1 and outlined in the following:
a) Broad static analysis. In the ﬁrst step, DREBIN statically
inspects a given Android application and extracts different
feature sets from the application’s manifest and dex code
(Section II-A).
b) Embedding in vector space. The extracted feature sets are
then mapped to a joint vector space, where patterns and
combinations of the features can be analyzed geometrically
(Section II-B).
c) Learning-based detection. The embedding of the featue sets
enables us to identify malware using efﬁcient techniques of
machine learning, such as linear Support Vector Machines
(Section II-C).
d) Explanation. In the last step, features contributing to the
detection of a malicious application are identiﬁed and
presented to the user for explaining the detection process
(Section II-D).
In the following sections, we discuss these four steps in
more detail and provide necessary technical background of the
analysis.
A. Static Analysis of Applications
As the ﬁrst step, DREBIN performs a lightweight static
analysis of a given Android application. Although apparently
straightforward, the static extraction of features needs to run in
a constrained environment and complete in a timely manner.
If the analysis takes too long, the user might skip the ongoing
process and refuse the overall method. Accordingly, it becomes
essential to select features which can be extracted efﬁciently.
We thus focus on the manifest and the disassembled dex
code of the application, which both can be obtained by a linear
sweep over the application’s content. To allow for a generic
and extensible analysis, we represent all extracted features as
sets of strings, such as permissions, intents and API calls. In
particular, we extract the following 8 sets of strings.
1) Feature sets from the manifest: Every application devel-
oped for Android must include a manifest ﬁle called Android-
Manifest.xml which provides data supporting the installation
and later execution of the application. The information stored
in this ﬁle can be efﬁciently retrieved on the device using the
Android Asset Packaging Tool that enables us to extract the
following sets:
S1 Hardware components: This ﬁrst feature set contains re-
quested hardware components. If an application requests
access to the camera, touchscreen or the GPS module
of the smartphone, these features need to be declared in
the manifest ﬁle. Requesting access to speciﬁc hardware
has clearly security implications, as the use of certain
combinations of hardware often reﬂects harmful behavior.
An application which has access to GPS and network
2
modules is, for instance, able to collect location data and
send it to an attacker over the network.
S2 Requested permissions: One of the most important secu-
rity mechanisms introduced in Android is the permission
system. Permissions are actively granted by the user at in-
stallation time and allow an application to access security-
relevant resources. As shown by previous work [13, 33],
malicious software tends to request certain permissions
more often than innocuous applications. For example, a
great percentage of current malware sends premium SMS
messages and thus requests the SEND_SMS permission.
We thus gather all permissions listed in the manifest in a
feature set.
S3 App components: There exist four different types of com-
ponents in an application, each deﬁning different inter-
faces to the system: activities, services, content providers
and broadcast receivers. Every application can declare
several components of each type in the manifest. The
names of these components are also collected in a feature
set, as the names may help to identify well-known compo-
nents of malware. For example, several variants of the so-
called DroidKungFu family share the name of particular
services [see 24].
S4 Filtered intents: Inter-process and intra-process commu-
nication on Android is mainly performed through in-
tents: passive data structures exchanged as asynchronous
messages and allowing information about events to be
shared between different components and applications.
We collect all intents listed in the manifest as another
feature set, as malware often listens to speciﬁc intents. A
typical example of an intent message involved in malware
is BOOT_COMPLETED, which is used to trigger malicious
activity directly after rebooting the smartphone.
2) Feature sets from disassembled code: Android appli-
cations are developed in Java and compiled into optimized
bytecode for the Dalvik virtual machine. This bytecode can be
efﬁciently disassembled and provides DREBIN with informa-
tion about API calls and data used in an application. To achieve
a low run-time, we implement a lightweight disassembler
based on the dex libraries of the Android platform that can
output all API calls and strings contained in an application.
We use this information to construct the following feature sets.
S5 Restricted API calls: The Android permission system
restricts access to a series of critical API calls. Our
method searches for the occurrence of these calls in the
disassembled code in order to gain a deeper understanding
of the functionality of an application. A particular case,
revealing malicious behavior, is the use of restricted API
calls for which the required permissions have not been
requested. This may indicate that the malware is using
root exploits in order to surpass the limitations imposed
by the Android platform.
S6 Used permissions: The complete set of calls extracted
in S5 is used as the ground for determining the sub-
set of permissions that are both requested and actually
used. For this purpose, we implement the method in-
troduced by Felt et al. [15] to match API calls and
permissions. In contrast to S5, this feature set provides
a more general view on the behavior of an application
as multiple API calls can be protected by a single
permission (e.g., sendMultipartTextMessage() and
sendTextMessage() both require that the SEND_SMS
permission is granted to an application).
S7 Suspicious API calls: Certain API calls allow access to
sensitive data or resources of the smartphone and are
frequently found in malware samples. As these calls can
specially lead to malicious behavior, they are extracted
and gathered in a separated feature set. In particular, we
collect the following types of API calls:
•
•
•
•
•
API calls for accessing sensitive data, such as
getDeviceId() and getSubscriberId()
API calls for network communication, for example
execHttpRequest() and setWifiEnabled()
API calls for sending and receiving SMS mes-
sages, such as sendTextMessage()
API calls for execution of external commands like
Runtime.exec()
API calls frequently used for obfuscation, such as
Cipher.getInstance()
S8 Network addresses: Malware regularly establishes net-
work connections to retrieve commands or exﬁltrate data
collected from the device. Therefore, all IP addresses,
hostnames and URLs found in the disassembled code
are included in the last set of features. Some of these
addresses might be involved in botnets and thus present
in several malware samples, which can help to improve
the learning of detection patterns.
B. Embedding in Vector Space
Malicious activity is usually reﬂected in speciﬁc patterns
and combinations of the extracted features. For example, a
malware sending premium SMS messages might contain the
permission SEND_SMS in set S2, and the hardware component
android.hardware.telephony in set S1. Ideally, we would
like to formulate Boolean expressions that capture these de-
pendencies between features and return true if a malware is
detected. However, inferring Boolean expressions from real-
world data is a hard problem and difﬁcult to solve efﬁciently.
As a remedy, we aim at capturing the dependencies be-
tween features using concepts from machine learning. As most
learning methods operate on numerical vectors, we ﬁrst need
to map the extracted feature sets to a vector space. To this end,
we deﬁne a joint set S that comprises all observable strings
contained in the 8 feature sets
S := S1 [ S2 [···[ S8.
We ensure that elements of different sets do not collide by
adding a unique preﬁx to all strings in each feature set. In
our evaluation the set S contains roughly 545,000 different
features (see Section III).
Using the set S, we deﬁne an |S|-dimensional vector space,
where each dimension is either 0 or 1. An application x is
mapped to this space by constructing a vector '(x), such that
for each feature s extracted from x the respective dimension
3
is set to 1 and all other dimensions are 0. Formally, this map
' can be deﬁned for a set of applications X as follows
' : X !{ 0, 1}|S|,' (x) 7! I(x, s) s2S
where the indicator function I(x, s) is simply deﬁned as
I(x, s) =⇢1
0
if the application x contains feature s
otherwise.
Applications sharing similar features lie close to each other in
this representation, whereas applications with mainly different
features are separated by large distances. Moreover, directions
in this space can be used to describe combinations of features
and ultimately enable us to learn explainable detection models.
Let us, as an example, consider a malicious application that
sends premium SMS messages and thus needs to request cer-
tain permissions and hardware components. A corresponding
vector '(x) for this application looks like this
'(x) 7!
0BBBBBB@
···0
1
···1