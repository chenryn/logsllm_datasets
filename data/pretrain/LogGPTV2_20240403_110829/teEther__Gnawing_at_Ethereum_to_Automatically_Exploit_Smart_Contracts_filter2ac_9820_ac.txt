256-bit variable to model the result of the Keccak-256
computation. At the same time we record the relation
between this new variables and the input data given to
the SHA3 instruction. We will later show in Section 4.5.1
how this mapping can be used to solve path constraints
which include hash-dependent constraints.
Figure 6: Infeasible Paths Example
4.4.3 Symbolic-Length Memory Access
path, the value of x at line 5 will always be a concrete
value and, since the path skipped the assignment in line
3, will have value 0. Thus the branch to line 6 will not be
taken going directly to line 7 instead, leading to a mis-
match between the program counter (7) and the next step
of the intended path (6). Therefore, we consider a path
infeasible, as soon as the program counter deviates from
the desired path. To prevent expensive symbolic execu-
tion of further paths that would also be infeasible due
to the same conditions, we extract a minimal infeasible
subpath. As such deviations can only occur following
a JUMP or JUMPI instruction, we consider the backward
slices of the last executed instruction. These slices con-
tain all instructions contributing to the jump target and in
case of JUMPI also to the branch condition. The minimal
infeasible subpath is then the subpath of the execution
trace starting from the ﬁrst instruction that is contained
in any of the slices. In case a value loaded from memory
or storage is contained in the path, the entire execution
trace is taken as the minimal infeasible subpath, to keep
the analysis sound. This minimal infeasible subpath is
then passed back to the path generation module, which
will stop exploring paths containing this subpath.
4.4.2 Hash Computation
While symbolic translation of most EVM instructions is
relatively straight-forward, special care has to be taken
to symbolically model the EVM’s SHA3 instruction. The
SHA3 instruction takes a memory region as input (speci-
ﬁed through two arguments, address and size) and com-
putes the Keccak-256 hash over the memory contents
stored therein. This instruction is, for example, used
by the Solidity compiler for the mapping data structure,
which provides a key-value store. Accessing a value
stored in a mapping is commonly implemented by com-
puting the Keccak-256 hash of the key and using the
resulting value as an index into the contract’s storage.
Since such mappings are a common data structure in
Ethereum contracts, TEETHER needs to be able to reason
about such storage accesses, which requires a symbolic
modeling of the SHA3 instruction.
To this end, whenever we want to symbolically exe-
Another issue of symbolic execution is that some EVM
instructions can copy to/from variable-length elements.
For example, the SHA3 instruction can compute hashes
over variable length data. Similarly, the CALLDATACOPY
instruction, which copies bytes from the given call data
into memory, operates on variable-length data. This
makes symbolic execution non-trivial, as the length is
not a concrete value but a symbolic expression instead.
TEETHER uses two approaches to address these issues.
First, whenever data of symbolic length is copied to
memory, e.g., when using CALLDATACOPY, we use Z3’s
If expression to model conditional assignments. For ex-
ample, a common pattern seen in smart contracts is copy-
ing the entire input data into memory. TEETHER will
execute this using assignments of the form
µ(cid:48)
m[a + i] ← If(i 
n
∑
i=0
I pi
v
4.5.1 Satisfying Assignment
Having assembled the combined path constraints of a
path sequence, including their state inter-dependencies
and the attacker’s goals, the next step is to ﬁnd a sat-
isfying assignment, which will give us concrete values
to build the transactions required for successful exploita-
tion. We leverage the constraint solver Z3. Yet we cannot
simply pass our set of collected constraints as is, as the
constraint solver is unaware of the special semantics of
Keccak-256 results and symbolic-read objects.
To overcome this problem we apply the iterative ap-
proach shown in Figure 7. The algorithm keeps a set Q of
unresolved variables, which is initially set to all elements
of H and M. As long as this queue is non-empty, we com-
pute the subset D of constraints that is not dependent on
any of the variables in Q and use a constraint solver to
USENIX Association
27th USENIX Security Symposium    1325
Q ← H ∪ M
A ← /0
while (cid:107)Q(cid:107) > 0 do
D ← {c ∈ C|Vars(c)∩ Q = /0}
A ← Sat(D)
for all x ∈ Q do
if x ∈ H then
e ← H[x]
if e∩ Q = /0 then
ve ← A(e)
vx ← Keccak-256(ve)
C ← C∪{e = ve,x = vx}
Q ← Q\{x}
end if
else if x ∈ M then
a,l, µm ← M[x]
if (Vars(a)∪ Vars(l))∩ Q = /0 then
va ← A(a)
vl ← A(l)
vx ← A(µm[va : va + vl])
C ← C∪{a = va,l = vl,x = vx}
Q ← Q\{x}
end if
end if
end for
end while
return Sat(C)
Figure 7: Iterative Constraint Solving Algorithm
ﬁnd a satisfying variable assignment A for D. Next, the
algorithm attempts to resolve unresolved variables from
Q. A variable can be resolved, if it does not depend on
other unresolved variables. To resolve a Keccak-256 re-
sult, we ﬁrst evaluate the hash’s input data expression
(according to H) in the assignment A. This gives us a
concrete value for the input data, over which we can then
compute a Keccak-256 hash. To “ﬁx” this relation be-
tween Keccak-256 result variable and input data, we add
two new constraints that bind the input-data to its cur-
rent valuation and the Keccak-256 result variable to the
computed hash value. A symbolic-memory read object
is resolved similarly by computing concrete value for the
start address and length. Once a variable has been re-
solved, it is removed from Q. This process is repeated
until all variables are resolved.
The key insight here is that, since the mappings H and
M deﬁne dependencies between the elements of H and M
and the variables involved in their corresponding expres-
sions, they also implicitly deﬁne a topological ordering
on H and M. Furthermore, as these mappings can never
deﬁne a cycle, this ordering is well-deﬁned.
Consider,
for example,
the Solidity statement
sha3(sha3(msg.sender)) which takes the address of
the message sender and hashes it twice. This will lead
to two entries in H, h0 and h1 with H[h0] = Is and
H[h1] = h0, which gives the dependency chain h1 → h0
→ Is. This means we ﬁrst have to ﬁx the value of Is to
compute h0, which will then allow us to compute h1.
4.5.2 Exploiting Transactions
If a satisfying assignment A can be found, TEETHER
will then output a list of transactions t0, . . . ,tn an attacker
would have to perform in order to exploit the contract.
Transaction value and data content for each transaction ti
are given by
valuei = A(Iv)
datai = A(Id)
Implementation
4.6
TEETHER is implemented in 4,300 lines of Python, using
Z3 [13] as constraint solver. We will release TEETHER
as open source 180 days after paper publication.
5 Evaluation
To demonstrate the utility of TEETHER, we downloaded
a snapshot of the Ethereum blockchain and scanned it
for contracts. Using a snapshot from Nov 30 2017, we
found a total of 784,344 contracts. Interestingly, many
contracts share the same bytecode, with the most popu-
lar code being shared by 247,654 contracts. On the other
hand, 32,401 contracts were only deployed on a single
address. Removing duplicates left us with a total num-
ber of 38,757 unique contracts. We executed TEETHER
on all these 38,757 contracts. To avoid the situation that
our code analysis gets stuck too long in a single con-
tract, we allowed up to 30 minutes for CFG reconstruc-
tion plus 30 minutes for ﬁnding each a CALL, CALLCODE,
DELEGATECALL, and SELFDESTRUCT-based exploit. We
furthermore assumed a contract’s storage was empty at
the beginning, such that we can treat duplicate contracts
the same. All experiments were performed on a virtu-
alized Intel Xeon E5-2660 system with 16 threads and
192 GB of memory, however, we never observed a mem-
ory usage of more than 32 GB.
5.1 Results
For 33,195 (85.65%) contracts,
the analysis ﬁnished
within the given time limit. Out of these, TEETHER
was able to generate an exploit for 815 (2.10%), which
we will analyze in detail below. To put this into per-
spective, about two thirds of all contracts, 24,331 or
1326    27th USENIX Security Symposium
USENIX Association
exploit
independent
dependent
critical path
no critical path
Sum
CALL
547
413
134
7,039
25,689
33,275
CALLCODE
2
2
0
6
37,826
37,834
DELEGATECALL
8
8
0
60
37,748
37,816
SELFDESTRUCT Contracts
815
630
189
8,049
24,331
33,195
298
241
57
2,357
34,533
37,188
Table 1: Detailed exploit generation results