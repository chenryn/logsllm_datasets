ware’s behavior that are largely independent of common
forms of nondeterminism.
After normalizing two graphs for comparison, we use
the VFlib2 graph isomorphism algorithm [6]. Although
isomorphism is a difﬁcult problem and may be inefﬁcient
to compute on large graphs, we point out that the normal-
ized behavior graphs resulting from real-world programs
are typically quite small, comprising no more than a few
dozen nodes.
4.2.3 Behavior Generalization
After clustering, we have several sets of behaviors
grouped by semantic similarity but still differing in cer-
tain details. For example, when we build clusters we
group together behaviors that differ in the speciﬁc re-
sources they identify. The goal of behavior generaliza-
tion is to produce a single canonical behavior that rep-
resents all of the members of a given cluster, as well as
variations of the members that are likely to result from
other executions of the malware.
In terms of the def-
initions presented in Section 4.1, behavior generaliza-
tion produces high-level behaviors with arguments con-
structed to accurately represent the resources modiﬁed
by observed executions, while generalizing to potential
future executions.
Algorithm 2 presents Generalize, our procedure for
generalizing a behavior cluster. Intuitively, generaliza-
9
Algorithm 1 Cluster(B,Bmax)
Require: B is
set
of
behavior
high-level
a
traces
{B1,B2, . . . ,Bm}
Bmax is the high-level behavior trace containing the maxi-
mum number of high-level behaviors
Result: A set of clusters of high-level behaviors of
{B1,B2, . . . ,Bm}
C ← ∅
∈ Bmax do
for bmax
add new cluster {bi
j} to C
j
end for
for all Bi ∈ B/Bmax do
{Traces are enumerated in the order of collection.}
j ∈ Bi do
for all bi
{Behaviors are enumerated in execution order.}
for all Ck ∈ C do
j, bk) where bk is a behavior in Ck
if isomorphic(bi
then
Ck ← Ck ∪ {bi
j}
j is not in any cluster then
j} to C
add new cluster {bi
end if
end for
if bi
end if
end for
end for
return (C)
tion is performed on each high-level behavior argument
individually, and the individual results are eventually
combined to produce the generalized behavior. Because
each cluster member represents the same high-level be-
havior, and therefore has the same number of arguments
as the others, we are assured that all of the relevant infor-
mation is included in the generalization. Furthermore,
because all arguments for the behaviors that we are inter-
ested in have straightforward canonical representations
as strings, the problem of generalizing each argument
can be reduced to the problem of generalizing sets of
strings. Generalize proceeds in this vein, iterating over
each argument for the behaviors in a given cluster C. Af-
ter collecting each string for a given argument in a set Ai,
a probabilistic ﬁnite-state automaton (PSFA) that accepts
all of the strings in Ai is constructed using the simulated
beam annealing algorithm [17]. By merging states that
are probabilistically very similar, the resulting automaton
accepts a superset of Ai, thus resulting an initial gener-
alization.
After building the PFSA, certain regions of the state
transition diagram are examined for reduction using a set
G of generalization rules, which are templates for gen-
erating regular expressions that overapproximate high-
level behavior arguments. We refer to a single-entry
single-exit region as one whose entry is composed of a
node n1 that is the immediate dominator of the exit node
10
Algorithm 2 Generalize(C,G, δ)
Require: C is a cluster of behaviors that differ only in argu-
ment values, G is a set of generalization rules, δ is the density
threshold.
{Loop through all arguments for behaviors in cluster C}
for i = 0 to |args(C0)| do
Result: A generalized high-level behavior.
Ai ← ∅
{Gather all values for current argument}
for c in C do
Ai ← Ai ∪ args i(c)
end for
{Generate PFSA that captures argument values}
(V, E) ← PFSA(Ai)
{Find dense regions in the PFSA}
for (n1, n2) in V × V − {(n, n) | n ∈ V } do
¬ipdom(n2, n1)
if ¬idom(e1, e2)
numpaths(n1, n2) < δ then
or
or
continue
end if
for r in G do
E0 ← r(paths(n1, n2))
E ← (E − paths(n1, n2)) ∪ E0
end for
end for
{Build regular expression for the current arguments}
Gi ← regexp(E)
end for
{Return new behavior with type matching C, and gen-
eralized reg. exp. arguments}
return name(C0)(G0, . . . , G), 0 ≤ n < |args(C0)|
n2, which is the immediate postdominator of n1. Fur-
thermore, we require that the number of paths between
n1 and n2 be at least δ. The actual value of δ is es-
timated empirically. This information is represented in
Algorithm 2 with the relations idom E and ipdom E, as
well as the function numpaths E. When a suitable single-
entry single-exit region is found, each rule in G is applied
in an attempt to generalize it. The generalization rules
that we use have been chosen on the basis of experience
and consider information such as the number of paths in
the region, the probabilities associated with the paths, the
lengths of the paths, and the characters composing the
strings associated with each path. If a rule is able to gen-
eralize the region, then it returns a smaller set of edges
that are used to replace the original region. Otherwise,
the rule returns the original region, and the next rule is
applied. After all rules in G have been applied, a reg-
ular expression is built from the resulting PFSA, which
is eventually used as an argument in the ﬁnal general-
ized behavior. The ﬁnal behavior is represented in Algo-
rithm 2 by name(C0)(G0, . . . , Gn). Here, name(C0)
returns the behavior name of the high-level behavior C0,
which is used to build the ﬁnal generalized behavior from
1 DropAndAutostart("c:\windows\...poagp.exe",data,"...Windows\CurrentVersion\Run","vq","poagp.exe")
2 DropAndAutostart("c:\windows\...pobxz.exe",data,"...Windows\CurrentVersion\Run","vq","pobxz.exe")
3 DropAndAutostart("c:\windows\...pocra.exe",data,"...Windows\CurrentVersion\Run","qv","pocra.exe")
4 DropAndAutostart("c:\windows\...pomfq.exe",data,"...Windows\CurrentVersion\Run","vq","pomfq.exe")
5 DropAndAutostart("c:\windows\...pommp.exe",data,"...Windows\CurrentVersion\Run","qv","pommp.exe")
6 DropAndAutostart("c:\windows\...popwz.exe",data,"...Windows\CurrentVersion\Run","qv","popwz.exe")
7 DropAndAutostart("c:\windows\...pouwk.exe",data,"...Windows\CurrentVersion\Run","vq","pouwk.exe")
Figure 5: Sample cluster grouping seven different occurrences of the DropAndAutostart behavior manifested by
our sample malware (the corresponding graphs are omitted for conciseness).
the individual argument generalizations.
As an illustration of this algorithm, consider the clus-
ter presented in Figure 5. We apply the PFSA algorithm
to the ﬁrst argument to arrive at the minimal automaton
shown in Figure 6. The automaton contains a single-
entry single-exit region with several paths, as highlighted
in the ﬁgure, that encodes the variable substring of the
ﬁlename. One of the generalization rules that we use
is triggered by the fact that this region is dense, i.e. it
contains many paths from entry to exit, as well as the
fact that it contains only alphabetic characters. Thus, it
returns a single edge labeled [[: alpha :]]{3}, which is a
wildcard sequence that denotes all alphabetic strings of
length three. The generalized PFSA results in the reg-
ular expression c : \windows\po[[: alpha :]]{3}.exe,
which is capable of
the names of
the ﬁles that our sample malicious program could
touch on the system. After applying Generalize to
all arguments of DropAndAutostart, we obtain a
generic model of the cluster behavior represented by
DropAndAutostart(“c : \windows\po[[: alpha :]]{3}
.exe”, data, “...Windows\CurrentVersion\Run”,
“(vq|qv)”).
identifying all
4.2.4 Generating Concrete Remediation Procedures
Each generalized high-level behavior must be remediated
differently. Our approach to generating executable re-
mediation procedures may be understood conceptually
in two parts. First, the generalized high-level behaviors
for each cluster are used to construct an approximate in-
fection relation R as discussed in Section 4.1. Then, we
use a generic procedure that scans the infection relation,
and changes the state of the system based on the contents
of each entry. When constructing the infection relation,
our procedure uses a model of a clean, bare installation
of the operating system installed on the machine for the
ﬁrst system state component of each tuple. The use of
a bare installation enables us to remediate infected sys-
tem resources up to the correct service pack installed on
the system, but not personal or application-speciﬁc re-
sources.
The remainder of this section details the way that spe-
ciﬁc high-level behaviors are translated into entries in the
abstract infection relation, as well as the way that the
Algorithm 3 Remediate(S, R)
(Sabs , Nrem , Sadd , Smut ) ← (Sabs , Nrem , Sadd , Smut ) ∈
R such that S has the same operating system version as Sabs
for s in Sadd do
cases s:
(name, data) : if ﬁle name exists, with contents
matching data then remove name.
((key, value), data) : if (key, value) exists with
contents matching data
then remove (key, value).
((ﬁle, key, value), (data, regdata)) :
if ﬁle exists and is a sufﬁx of some element of
Dregdata that also exists in a key matching
(key, value) then remove ﬁle and
(key, value).
((ﬁle, procname), data) :
if procname and (ﬁle, data) exist matching
ﬁle, data, procname and procname is a
sufﬁx of ﬁle then remove ﬁle and
kill procname.
end cases
end for
for i in Imut do
cases i:
(ﬁle, data) : Remove (ﬁle, data) and replace it
with (ﬁle, data0) ∈ β(S)
((key, value), data) : Remove ((key, value), data)
and replace it with
((key, value), data) ∈ β(S).
end cases
end for
abstract infection relation is used to generate a concrete
(executable) remediation procedure.
Newly-Created Resources: Remediating resources
that are created by malware is straightforward, because
the remediation procedure only needs information re-
garding the names and data of newly-created resources
to completely remove the corresponding resources from
the system. Our remediation procedures are capable of
removing ﬁles and registry keys. To account for the pos-
sibility that the infection could create resources that were
not observed in a high-level behavior trace during anal-
ysis, we instead use generalized high-level behaviors in
the infection relation R.
11
c
:
\
w
i
n
. . .
p
o
Single-entry-single-exit region
q
b
m
d
c
u
w
x
f
m
g
r
w
z
q
p
a
k
.
e
x
e
Figure 6: A fragment of
DropAndAutostart behavior, starting from the occurrences of the argument reported in Figure 5.
the minimized automaton constructed to generalize the ﬁrst argument of
the
the
ﬁle
For
creation
high-level
behavior
FileCreation(name, data), we ﬁnd the resource
for name and data and append this pair to Sadd .
Similarly, for the high-level registry creation behavior
RegistryCreation (key, value, data), we associate
the key/value pair to the corresponding data and add
them as a pair to Sadd . As shown in Algorithm 3, the
remediation procedure processes these entries in the
infection relation R by checking for the existence of the
resource names on the system and removing them if they
exist with the contents speciﬁed by Rα.
the
Remediating
DropAndAutostart
and
DropAndExecute behaviors
is more complicated,
as doing so involves multiple resources that are related
in a constrained manner. To handle a high-level behavior
of the form:
DropAndAutostart(ﬁle, data, key, value, regdata)
we group the resource names: ﬁle, key, value together as
a compound resource name for a new element in Sadd ,
and group data and regdata together for the correspond-
ing data component. The remediation procedure acts on
such an entry by scanning system resources for names
that match the ﬁle name and registry key/value pairs. If a
match is found, the corresponding resources are removed
only if the concrete ﬁlename is a sufﬁx of the concrete
registry data and the concrete data matches the abstract
data.
For example, when the procedure encounters the gen-
eralized DropAndAutostart from Figure 5, it will aug-
ment Sadd with the following resource:
(c : \windows\po[[: alpha :]]{3}\.exe,
(...\CurrentVersion, Run),
(data, po[[: alpha :]]{3}\.exe))
The
search
remediation
the
system for
procedure
a
ﬁle
will
then
that matches
12
c : \windows\po[[: alpha :]]{3}.exe,
as
the registry key (...\CurrentVersion, Run), and will
remove the resources only if the value of the registry key
matches the name of any ﬁle that matches the regular
expression.
as well