(cid:2)
F ) → {Fri , πri
(cid:2)
• Setup(F ) → (
F , digest). P encodes F using an era-
sure code. Then P computes a Merkle tree whose leaves
are segments of the encoded F (with their indices) and
whose root is digest. Let (cid:2)
F denote the encoded form of
F and its accompanying Merkle tree.
• Prove(puz, R,
Let R :=
{r1, . . . , rk} ∈ [n]k denote a set of random challenge
indices selected by V . P outputs a proof that for each
challenge index ri ∈ R, (cid:2)
F contains Fri and the accom-
panying path πri in the Merkle tree.
• Verify(digest, R,{Fri , πri}ri∈R) → {0, 1}. V vali-
dates the Merkle path πri for each segment Fri against
digest.
}ri∈R.
PORs provide a strong guarantee, namely that with over-
whelming probability, if P provides correct responses, F can
be retrieved completely from P . That is, thanks to erasure-
coding, every bit of F can be recovered.
Our adaptation of PORs for Permacoin, however, differs
from previously proposed PORs in two main ways. First, in
our case, V is the entire Bitcoin / Permacoin network. Unlike
previous schemes, however, we let the challenge c be gener-
ated non-interactively by a client executing Guess.
Second, in our setting, every client can act as a prover
(if it successfully mines blocks). So the number of possi-
ble provers is large (thousands of clients). Additionally, the
target dataset F is quite large, so each client j holds only a
portion of F . Thus we distribute F across multiple provers.
The POR generated by a prover / client is partial, in the sense
477
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:14 UTC from IEEE Xplore.  Restrictions apply. 
that it covers only the client’s stored portion of F . While dis-
tributed PORs have been previously explored in, e.g., [10],
previous schemes have involved small numbers of provers
acting synchronously. In our setting, not only is the number
of provers large, but proofs are generated asynchronously, as
a byproduct of mining.
Another distinctive feature of our setting is that most PORs
aren’t explicitly veriﬁed. In order to try to solve an SOP, a
client must generate PORs on its blocks of F . But a client that
never mines a block successfully may never release any POR.
In this sense, PORs implicitly incentivize correct storage: a
client stores Fi in order to be able to generate a correct POR,
whether or not the POR is ever in fact veriﬁed.
In Section 4, we specify how POR functions are integrated
into Guess and IsWinningTicket to construct Permacoin’s
SOP.
3 Security Assumptions
In the Bitcoin system, clients are pseudonymous. Each client
j has a key pair (skj, pkj) used to sign (validate) her trans-
actions. Additionally, there are no pre-established identities,
and clients may create new identities as desired at any time.
We retain these properties in our proposed scheme.
Permacoin makes use of an extremely large archival data
ﬁle F (notionally, F may be 1 petabyte in size). Conse-
quently, F is too large for storage by individual peers, which
must instead store fragments of F . A beneﬁt of distributing
F across peers, however, is that it becomes more durable, i.e.,
able to survive infrastructure damage, as speciﬁcally desired
for high-value ﬁles. Even if a fraction of peers go ofﬂine or
behave maliciously, F remains recoverable.
Globally, therefore, our security goal is to preserve F even
in the face of failures, benign or malicious, of a fraction of
clients in the Bitcoin network.
We make the following three important assumptions in Per-
macoin that are distinct from those in Bitcoin.
File distribution. We assume (for the sake of presentation)
that F emanates from a single authoritative dealer that digi-
tally signs ﬁle blocks. We assume that newly created clients
can download fragments of F on demand. The dealer might
remain continuously online to serve these blocks. In this case,
storage of F in Bitcoin provides a hedge against a dealer fail-
ure. (For example, the Library of Congress might serve out its
collection F . But in case of a failure, as during the recent U.S.
government shutdown [11], F would be recoverable from the
Bitcoin network.)
In brief, we assume that fragments of an authoritatively
generated ﬁle F may be downloaded on demand by clients.
We make no further assumptions of centralization. In prac-
tice, we imagine that the functionality of the trusted dealer
will be provided by the Bitcoin network itself; we discuss
possible mechanisms for this in Section 8.
Limited adversary. We assume an adversary that controls a
small (minority) fraction of clients. Given a recent result [12]
showing that an adversary that controls 1/4 of clients can sub-
vert the Bitcoin network, limited adversarial control is a fun-
damental requirement of Bitcoin, and not just of our scheme.
We assume that the remaining clients act independently and,
in particular, assume that they behave in an economically ra-
tional manner. That is, they seek to maximize their gain in
Bitcoin mining and limit their resource investment.
Local private-key storage. We assume that a substantial
fraction of clients do not share their private signing keys with
external entities. It is the signing key skj of a client j that en-
titles him to the reward of Bitcoins associated with successful
block mining. Consequently, sharing this key means sharing
a client’s coins—and exposing them to theft with no ability to
trace them and thus no recourse or indemniﬁcation should a
provider be breached or embezzle coins. Additionally, many
Bitcoin miners today perform mining on special-purpose lo-
cal devices, such as ASIC miners [13]. Thus, we assume that
a substantial fraction of clients in the Bitcoin network store
their private keys locally.
We construct our SOP such that efﬁciently solving it re-
quires continuous use of a miner’s private key. Given our
assumption of local key storage, therefore, we are able to
show that clients in Permacoin perform mining locally and
thus that fragments of F are distributed across distinct clients
and enjoy the full physical distribution and robustness of a
true peer-to-peer network.
4 Scheme
Our idea, at a high level, is to build a scratch-off-puzzle out
of a Proof-of-Retrievability, such that the only way effective
way to solve the puzzle is to store portions of the public
dataset. In the following sections, we describe how we de-
sign the puzzle to ensure that (a) users reliably store a subset
of the data, (b) participants assign themselves mostly non-
overlapping subsets of data to ensure good diversity, and (c)
the entire dataset is recoverable with high probability from
the contents of participants’ local storage devices.
4.1 A Simple POR Lottery
To reduce the energy wasted by Bitcoin’s current proof-
of-computation lottery, we propose replacing it in Perma-
coin with a POR lottery. In a POR lottery, every scratch-off
attempt can be associated with the effort of computing a POR.
There are at least two issues that must be addressed:
• Choosing a random subset of segments based on each
participant’s public key. Since each participant may not
have sufﬁcient storage to store the entire dataset, we
have each participant choose a random subset of seg-
ments of the data to store, based on the hash of their
public key.
• Non-interactive challenge generation.
In traditional
PORs, a veriﬁer sends a random challenge to a prover,
and the prover answers the challenge. In our system, the
veriﬁer is the entire Bitcoin network, and the challenge
must be generated non-interactively.
478
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:14 UTC from IEEE Xplore.  Restrictions apply. 
Thus, we have the participants generate challenges based
on the publicly known epoch-dependent puzzle ID puz.
A valid challenge is computed as H(puz||s) for some
string s of the prover’s choice.
NOHDYHVUHYHDOHG
GXULQJVFUDWFK
3XEOLFNH\
PHNOHURRW
T¶OHDYHV
T¶ OHD¶
UHYHUHYH
UHYHDOHGWR
FODLP
FODLPUHZDUG
Our strawman protocol is described in Figure 1.
ı
ı
ı
ı ı
ı
ı
ııı
ı ı
ııı

ıQ ıQ
ıQıı
4.2 Local-POR Lottery
6HFUHWNH\OHDYHV
One drawback of the strawman POR lottery (Figure 1) is that
it does not incentivize distributed storage, which undermines
our goal of long-term, resilient data-storage.
In particular, participants can potentially beneﬁt from
economies of scale if they outsource the puzzle solving pro-
cess to a cloud server, including the storage and computa-
tion necessary. In fact, several companies have begun to offer
hosted Bitcoin mining services [14].
If most users outsource the puzzle solving process to the
cloud, then Permacoin’s distributed computational and stor-
agee network would effectively become centralized with a
few companies. To increase our resilience against correlated
disasters, we wish to increase the geographical diversity of
the storage. Therefore, we wish to disincentivize users from
outsourcing their storage to cloud providers.
We now propose a new local-POR lottery mechanism (see
Figure 2) that discourages users from outsourcing puzzle
solving to the cloud.
Idea 1: Tie the payment private key to the puzzle solution.
Our ﬁrst idea is to tie to the puzzle solution to the private key
to which the lottery reward is paid out. This key must be kept
private in order to claim the reward for oneself. By tying the
payment private key to the puzzle solution, a user must reveal
her private key to the cloud if she wishes to reduce her own
costs by outsourcing the puzzle to the cloud.
As mentioned earlier (Section 3), we assume that at least a
fraction of the users will choose not to entrust the cloud with
their payment private keys.
Idea 2: Sequential and random storage access. We also
need to discourage a user from outsourcing storage to the
cloud, but performing computation locally on her own ma-
chine. To achieve this goal, we craft our puzzle such that
access to storage is sequentialized during the scratch-off at-
tempt. Furthermore, the storage access pattern is random
(based on outcomes of calling a random oracle) and cannot be
precomputed ahead of time. Thus, if the data is stored in the
cloud and the computation is performed locally, many round-
trips must be incurred during the scratch-off attempt, which
will reduce the user’s chance of ﬁnding a winning ticket.
Boosting recoverability with erasure codes. As in stan-
dard proof-of-retrievability schemes, we boost the probability
of successful recovery through erasure coding. In the setup
phase, we erasure code a dataset containing f segments into
rf segments, where r > 1, such that any f segments sufﬁce
to recover the dataset.
Figure 3: Illustration of the ﬂoating preimage signature sig-
nature scheme.
4.3 Floating-Preimage Signature Scheme
For the signing operation in Figure 2, one simple op-
tion would be to use the commonly adopted RSA signa-
ture scheme. However, RSA signatures (and most other
commonly-used signatures) require asymmetric operations,
which impose a high computational overhead. This is un-
desirable for our purposes; for every dollar a participant in-
vests in mining equipment, we would prefer as much of it
as possible to be spent on storage devices (which simultane-
ously provide additional utility through our scheme) rather
than signature-computing processors (which do not). From
a back-of-the-envelope calculation, if an RSA signature were
used, and if we choose parameters to ensure half of each in-
vested dollar is spent on storage, then each puzzle iteration
would have to add a half-megabyte of data to the correspond-
ing proof (see Section 7), which would place an impractical
burden on the Bitcoin network.
Instead, we propose a highly efﬁcient multi-use hash-based
signature scheme which we call a ﬂoating preimage signature
(FPS). This scheme is an instance of the generalized Bos-
Chaum signature scheme [15], to which we refer for a better
description of standard hash-based signatures. In brief, the
secret key consists of a set of randomly generated strings;
the public key is the root digest of a Merkle tree with these
strings at the leaves. A message is signed by pseudorandomly
selecting a subset of leaves to reveal.
Our puzzle requires a multi-use signature scheme allow-
ing k + 1 signed messages, where the ﬁrst k are performed
during the k iterations of the scratch-off, and the additional
(k + 1)-th is used to spend the Bitcoin reward after successful
mining. However, we cannot directly employ any standard
multi-use signature scheme (e.g., those based on Merkle sig-
natures [15]), since we require a special non-outsourceable
property.
[Non-outsourceability:] During a scratch-off, successfully
computing the k signatures necessary for a ticket requires
possession of a large fraction of the private keys (preimages),
such that with high probability, anyone able to produce k sig-
natures will be able to produce the (k + 1)-th signature (used
to pay the reward).
Our basic, stateful FPS signature scheme is illustrated in
479
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:14 UTC from IEEE Xplore.  Restrictions apply. 
• Setup. The dealer computes and publishes the digest of the entire dataset, consisting of n segments
A participant with public key pk chooses a subset Spk of segments to store:
∀i ∈ [(cid:3)] : let u[i] := H0(pk||i) mod n,
Spk := {u[i]}i∈[(cid:2)]
where (cid:3) is the number of segments stored by each participant. The participant stores {(F[j], πj)|j ∈ Spk}, where πj is
the Merkle proof for the corresponding segment F[j].
• Scratch-off. Every scratch-off attempt is seeded by a random string s chosen by the user. Let puz denote a publicly
known, epoch-dependent, and non-precomputable puzzle ID. A participant computes k random challenges from its stored
subset Spk:
∀i = 1, 2, . . . , k :
ri := u[H(puz||pk||i||s) mod (cid:3)]
(1)
The ticket is deﬁned as:
ticket := (pk, s,{F[ri], πi}i=1,2,...,k)
where πi is the Merkle proof for the ri-th segment F[ri].
• Verify. The Veriﬁer is assumed to hold the digest of F . Given a ticket := (pk, s,{F[ri], πri}i=1,2,...,k) veriﬁcation ﬁrst