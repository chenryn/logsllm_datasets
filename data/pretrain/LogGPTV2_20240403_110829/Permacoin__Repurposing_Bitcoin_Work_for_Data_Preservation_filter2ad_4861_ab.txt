(cid:2)
F ) ‚Üí {Fri , œÄri
(cid:2)
‚Ä¢ Setup(F ) ‚Üí (
F , digest). P encodes F using an era-
sure code. Then P computes a Merkle tree whose leaves
are segments of the encoded F (with their indices) and
whose root is digest. Let (cid:2)
F denote the encoded form of
F and its accompanying Merkle tree.
‚Ä¢ Prove(puz, R,
Let R :=
{r1, . . . , rk} ‚àà [n]k denote a set of random challenge
indices selected by V . P outputs a proof that for each
challenge index ri ‚àà R, (cid:2)
F contains Fri and the accom-
panying path œÄri in the Merkle tree.
‚Ä¢ Verify(digest, R,{Fri , œÄri}ri‚ààR) ‚Üí {0, 1}. V vali-
dates the Merkle path œÄri for each segment Fri against
digest.
}ri‚ààR.
PORs provide a strong guarantee, namely that with over-
whelming probability, if P provides correct responses, F can
be retrieved completely from P . That is, thanks to erasure-
coding, every bit of F can be recovered.
Our adaptation of PORs for Permacoin, however, differs
from previously proposed PORs in two main ways. First, in
our case, V is the entire Bitcoin / Permacoin network. Unlike
previous schemes, however, we let the challenge c be gener-
ated non-interactively by a client executing Guess.
Second, in our setting, every client can act as a prover
(if it successfully mines blocks). So the number of possi-
ble provers is large (thousands of clients). Additionally, the
target dataset F is quite large, so each client j holds only a
portion of F . Thus we distribute F across multiple provers.
The POR generated by a prover / client is partial, in the sense
477
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:14 UTC from IEEE Xplore.  Restrictions apply. 
that it covers only the client‚Äôs stored portion of F . While dis-
tributed PORs have been previously explored in, e.g., [10],
previous schemes have involved small numbers of provers
acting synchronously. In our setting, not only is the number
of provers large, but proofs are generated asynchronously, as
a byproduct of mining.
Another distinctive feature of our setting is that most PORs
aren‚Äôt explicitly veriÔ¨Åed. In order to try to solve an SOP, a
client must generate PORs on its blocks of F . But a client that
never mines a block successfully may never release any POR.
In this sense, PORs implicitly incentivize correct storage: a
client stores Fi in order to be able to generate a correct POR,
whether or not the POR is ever in fact veriÔ¨Åed.
In Section 4, we specify how POR functions are integrated
into Guess and IsWinningTicket to construct Permacoin‚Äôs
SOP.
3 Security Assumptions
In the Bitcoin system, clients are pseudonymous. Each client
j has a key pair (skj, pkj) used to sign (validate) her trans-
actions. Additionally, there are no pre-established identities,
and clients may create new identities as desired at any time.
We retain these properties in our proposed scheme.
Permacoin makes use of an extremely large archival data
Ô¨Åle F (notionally, F may be 1 petabyte in size). Conse-
quently, F is too large for storage by individual peers, which
must instead store fragments of F . A beneÔ¨Åt of distributing
F across peers, however, is that it becomes more durable, i.e.,
able to survive infrastructure damage, as speciÔ¨Åcally desired
for high-value Ô¨Åles. Even if a fraction of peers go ofÔ¨Çine or
behave maliciously, F remains recoverable.
Globally, therefore, our security goal is to preserve F even
in the face of failures, benign or malicious, of a fraction of
clients in the Bitcoin network.
We make the following three important assumptions in Per-
macoin that are distinct from those in Bitcoin.
File distribution. We assume (for the sake of presentation)
that F emanates from a single authoritative dealer that digi-
tally signs Ô¨Åle blocks. We assume that newly created clients
can download fragments of F on demand. The dealer might
remain continuously online to serve these blocks. In this case,
storage of F in Bitcoin provides a hedge against a dealer fail-
ure. (For example, the Library of Congress might serve out its
collection F . But in case of a failure, as during the recent U.S.
government shutdown [11], F would be recoverable from the
Bitcoin network.)
In brief, we assume that fragments of an authoritatively
generated Ô¨Åle F may be downloaded on demand by clients.
We make no further assumptions of centralization. In prac-
tice, we imagine that the functionality of the trusted dealer
will be provided by the Bitcoin network itself; we discuss
possible mechanisms for this in Section 8.
Limited adversary. We assume an adversary that controls a
small (minority) fraction of clients. Given a recent result [12]
showing that an adversary that controls 1/4 of clients can sub-
vert the Bitcoin network, limited adversarial control is a fun-
damental requirement of Bitcoin, and not just of our scheme.
We assume that the remaining clients act independently and,
in particular, assume that they behave in an economically ra-
tional manner. That is, they seek to maximize their gain in
Bitcoin mining and limit their resource investment.
Local private-key storage. We assume that a substantial
fraction of clients do not share their private signing keys with
external entities. It is the signing key skj of a client j that en-
titles him to the reward of Bitcoins associated with successful
block mining. Consequently, sharing this key means sharing
a client‚Äôs coins‚Äîand exposing them to theft with no ability to
trace them and thus no recourse or indemniÔ¨Åcation should a
provider be breached or embezzle coins. Additionally, many
Bitcoin miners today perform mining on special-purpose lo-
cal devices, such as ASIC miners [13]. Thus, we assume that
a substantial fraction of clients in the Bitcoin network store
their private keys locally.
We construct our SOP such that efÔ¨Åciently solving it re-
quires continuous use of a miner‚Äôs private key. Given our
assumption of local key storage, therefore, we are able to
show that clients in Permacoin perform mining locally and
thus that fragments of F are distributed across distinct clients
and enjoy the full physical distribution and robustness of a
true peer-to-peer network.
4 Scheme
Our idea, at a high level, is to build a scratch-off-puzzle out
of a Proof-of-Retrievability, such that the only way effective
way to solve the puzzle is to store portions of the public
dataset. In the following sections, we describe how we de-
sign the puzzle to ensure that (a) users reliably store a subset
of the data, (b) participants assign themselves mostly non-
overlapping subsets of data to ensure good diversity, and (c)
the entire dataset is recoverable with high probability from
the contents of participants‚Äô local storage devices.
4.1 A Simple POR Lottery
To reduce the energy wasted by Bitcoin‚Äôs current proof-
of-computation lottery, we propose replacing it in Perma-
coin with a POR lottery. In a POR lottery, every scratch-off
attempt can be associated with the effort of computing a POR.
There are at least two issues that must be addressed:
‚Ä¢ Choosing a random subset of segments based on each
participant‚Äôs public key. Since each participant may not
have sufÔ¨Åcient storage to store the entire dataset, we
have each participant choose a random subset of seg-
ments of the data to store, based on the hash of their
public key.
‚Ä¢ Non-interactive challenge generation.
In traditional
PORs, a veriÔ¨Åer sends a random challenge to a prover,
and the prover answers the challenge. In our system, the
veriÔ¨Åer is the entire Bitcoin network, and the challenge
must be generated non-interactively.
478
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:14 UTC from IEEE Xplore.  Restrictions apply. 
Thus, we have the participants generate challenges based
on the publicly known epoch-dependent puzzle ID puz.
A valid challenge is computed as H(puz||s) for some
string s of the prover‚Äôs choice.
NOHDYHVUHYHDOHG
GXULQJVFUDWFK
3XEOLFNH\
PHNOHURRW
T¬∂OHDYHV
T¬∂ OHD¬∂
UHYHUHYH
UHYHDOHGWR
FODLP
FODLPUHZDUG
Our strawman protocol is described in Figure 1.
ƒ±
ƒ±
ƒ±
ƒ± ƒ±
ƒ±
ƒ±
ƒ±ƒ±ƒ±
ƒ± ƒ±
ƒ±ƒ±ƒ±

ƒ±Q ƒ±Q
ƒ±Qƒ±ƒ±
4.2 Local-POR Lottery
6HFUHWNH\OHDYHV
One drawback of the strawman POR lottery (Figure 1) is that
it does not incentivize distributed storage, which undermines
our goal of long-term, resilient data-storage.
In particular, participants can potentially beneÔ¨Åt from
economies of scale if they outsource the puzzle solving pro-
cess to a cloud server, including the storage and computa-
tion necessary. In fact, several companies have begun to offer
hosted Bitcoin mining services [14].
If most users outsource the puzzle solving process to the
cloud, then Permacoin‚Äôs distributed computational and stor-
agee network would effectively become centralized with a
few companies. To increase our resilience against correlated
disasters, we wish to increase the geographical diversity of
the storage. Therefore, we wish to disincentivize users from
outsourcing their storage to cloud providers.
We now propose a new local-POR lottery mechanism (see
Figure 2) that discourages users from outsourcing puzzle
solving to the cloud.
Idea 1: Tie the payment private key to the puzzle solution.
Our Ô¨Årst idea is to tie to the puzzle solution to the private key
to which the lottery reward is paid out. This key must be kept
private in order to claim the reward for oneself. By tying the
payment private key to the puzzle solution, a user must reveal
her private key to the cloud if she wishes to reduce her own
costs by outsourcing the puzzle to the cloud.
As mentioned earlier (Section 3), we assume that at least a
fraction of the users will choose not to entrust the cloud with
their payment private keys.
Idea 2: Sequential and random storage access. We also
need to discourage a user from outsourcing storage to the
cloud, but performing computation locally on her own ma-
chine. To achieve this goal, we craft our puzzle such that
access to storage is sequentialized during the scratch-off at-
tempt. Furthermore, the storage access pattern is random
(based on outcomes of calling a random oracle) and cannot be
precomputed ahead of time. Thus, if the data is stored in the
cloud and the computation is performed locally, many round-
trips must be incurred during the scratch-off attempt, which
will reduce the user‚Äôs chance of Ô¨Ånding a winning ticket.
Boosting recoverability with erasure codes. As in stan-
dard proof-of-retrievability schemes, we boost the probability
of successful recovery through erasure coding. In the setup
phase, we erasure code a dataset containing f segments into
rf segments, where r > 1, such that any f segments sufÔ¨Åce
to recover the dataset.
Figure 3: Illustration of the Ô¨Çoating preimage signature sig-
nature scheme.
4.3 Floating-Preimage Signature Scheme
For the signing operation in Figure 2, one simple op-
tion would be to use the commonly adopted RSA signa-
ture scheme. However, RSA signatures (and most other
commonly-used signatures) require asymmetric operations,
which impose a high computational overhead. This is un-
desirable for our purposes; for every dollar a participant in-
vests in mining equipment, we would prefer as much of it
as possible to be spent on storage devices (which simultane-
ously provide additional utility through our scheme) rather
than signature-computing processors (which do not). From
a back-of-the-envelope calculation, if an RSA signature were
used, and if we choose parameters to ensure half of each in-
vested dollar is spent on storage, then each puzzle iteration
would have to add a half-megabyte of data to the correspond-
ing proof (see Section 7), which would place an impractical
burden on the Bitcoin network.
Instead, we propose a highly efÔ¨Åcient multi-use hash-based
signature scheme which we call a Ô¨Çoating preimage signature
(FPS). This scheme is an instance of the generalized Bos-
Chaum signature scheme [15], to which we refer for a better
description of standard hash-based signatures. In brief, the
secret key consists of a set of randomly generated strings;
the public key is the root digest of a Merkle tree with these
strings at the leaves. A message is signed by pseudorandomly
selecting a subset of leaves to reveal.
Our puzzle requires a multi-use signature scheme allow-
ing k + 1 signed messages, where the Ô¨Årst k are performed
during the k iterations of the scratch-off, and the additional
(k + 1)-th is used to spend the Bitcoin reward after successful
mining. However, we cannot directly employ any standard
multi-use signature scheme (e.g., those based on Merkle sig-
natures [15]), since we require a special non-outsourceable
property.
[Non-outsourceability:] During a scratch-off, successfully
computing the k signatures necessary for a ticket requires
possession of a large fraction of the private keys (preimages),
such that with high probability, anyone able to produce k sig-
natures will be able to produce the (k + 1)-th signature (used
to pay the reward).
Our basic, stateful FPS signature scheme is illustrated in
479
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:14 UTC from IEEE Xplore.  Restrictions apply. 
‚Ä¢ Setup. The dealer computes and publishes the digest of the entire dataset, consisting of n segments
A participant with public key pk chooses a subset Spk of segments to store:
‚àÄi ‚àà [(cid:3)] : let u[i] := H0(pk||i) mod n,
Spk := {u[i]}i‚àà[(cid:2)]
where (cid:3) is the number of segments stored by each participant. The participant stores {(F[j], œÄj)|j ‚àà Spk}, where œÄj is
the Merkle proof for the corresponding segment F[j].
‚Ä¢ Scratch-off. Every scratch-off attempt is seeded by a random string s chosen by the user. Let puz denote a publicly
known, epoch-dependent, and non-precomputable puzzle ID. A participant computes k random challenges from its stored
subset Spk:
‚àÄi = 1, 2, . . . , k :
ri := u[H(puz||pk||i||s) mod (cid:3)]
(1)
The ticket is deÔ¨Åned as:
ticket := (pk, s,{F[ri], œÄi}i=1,2,...,k)
where œÄi is the Merkle proof for the ri-th segment F[ri].
‚Ä¢ Verify. The VeriÔ¨Åer is assumed to hold the digest of F . Given a ticket := (pk, s,{F[ri], œÄri}i=1,2,...,k) veriÔ¨Åcation Ô¨Årst