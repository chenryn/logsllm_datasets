cution time of 1.37. The higher coverage techniques, SWIFT-
R and TRUMP/SWIFT-R, have normalized execution times
of 1.99 and 1.98 respectively.
TRUMP/SWIFT-R’s execution time is closer to that of
SWIFT-R than TRUMP. This implies that TRUMP/SWIFT-
R’s protection choices track more closely with SWIFT-R than
TRUMP, i.e. there are many more instructions protected by
SWIFT-R than instructions protected by TRUMP. This is
in agreement with the reliability evaluation, showing that
the reliability of TRUMP/SWIFT-R was much closer to that
of SWIFT-R than that of TRUMP. The performance of
TRUMP/SWIFT-R is highly dependent, much like its relia-
bility, on the particular tradeoffs between SWIFT-R protec-
tion and TRUMP protection that TRUMP/SWIFT-R makes.
The SWIFT-R technique is more expensive than TRUMP in
terms of redundancy, because two additional versions of the
computation are required instead of one. TRUMP, on the
other hand, is more expensive in terms of veriﬁcation because
the AN-encoded and original data must be converted to the
same form for comparison. Depending on the ratio of re-
dundant computation to comparison, a TRUMP dependence
chain may actually be more costly than a SWIFT-R depen-
dence chain, which accounts for SWIFT-R occasionally out-
performing TRUMP/SWIFT-R.
TRUMP/MASK’s performance is typically much higher
than that of either TRUMP/SWIFT-R or SWIFT-R, but also
signiﬁcantly lower than MASK and on par with TRUMP.
This is to be expected as the performance impact of MASK is
nearly negligible. The performance is slightly worse than the
simple sum of MASK and TRUMP, because each technique
alone is able to use some of the previously unused resources,
but there are not enough unused resources to support both
the MASK and TRUMP protections, thus creating a super-
additive performance penalty. Note that in some cases, most
notably mpeg2dec, TRUMP/MASK outperforms TRUMP,
just as MASK occasionally outperforms NOFT. Once again,
this is due to unpredictable changes in the scheduler and reg-
ister allocator as a result of inserting extra instructions.
One interesting observation is that the normalized execu-
tion time of all of our techniques, even SWIFT-R, averages
far less than three, what one might na¨ıvely expect after tripli-
cating the code. In benchmarks dominated by ﬂoating-point
instructions which we do not protect, such as 179.art, we
would expect little difference in performance between the
various versions of the code, and this is exactly the case.
However, the normalized execution time is also far less than
three for most integer benchmarks. All of our techniques take
advantage of the well-documented existence of unused ILP
resources in most modern processors. Since most of the in-
structions added in SWIFT-R and TRUMP are independent of
the original instructions, the reliable code is typically able to
make use of previously unused ILP resources. This effect is
especially visible in benchmarks which already exhibit poor
ILP in NOFT, such as 181.mcf. 181.mcf spends a large
fraction of its time in memory stalls, consequently, our trans-
formations have a very small impact on the performance. The
variety in available ILP leads to wide variations in the perfor-
mance cost for each benchmark.
In addition to the effect of ILP, the instruction mix of the
various benchmarks affects the performance cost of added
reliability. Recall that for both TRUMP and SWIFT-R, the
protection for most instructions is simply replication. How-
ever, whenever there are checks, another more complex se-
quence of instructions is executed. Although the veriﬁcation
code differs for each technique, in benchmarks where there
are many checks, such as 255.vortex due to a prepon-
derance of loads, the performance impact is typically much
higher than benchmarks with smaller numbers of checks and
more of their time dedicated to pure computation, such as
300.twolf.
In summary, SWIFT-R, which has a normalized execution
time of 1.99, can signiﬁcantly improve reliability, increas-
ing unACE to 97.27%. SWIFT-R should be used in situa-
tions where high reliability requirements warrant this level
of performance degradation. The performance of SWIFT-
R can be improved slightly by moving to the hybrid tech-
nique TRUMP/SWIFT-R. When the reliability requirements
of the system are not stringent enough to warrant SWIFT-
R or TRUMP/SWIFT-R, TRUMP or TRUMP/MASK can be
used. TRUMP has the much lower normalized runtime of
1.36, while still managing to increase the unACE to 87.73%
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:27:54 UTC from IEEE Xplore.  Restrictions apply. 
Figure 9. Execution time of MASK, TRUMP, TRUMP/MASK, TRUMP/SWIFT-R, and SWIFT-R normalized
to NOFT. The GeoMean is across all benchmarks.
versus 74.18% for NOFT. TRUMP/MASK improves on this
slightly, increasing reliability further while having a negli-
gible impact on performance. Finally, when almost no per-
formance degradation can be tolerated, the MASK technique
can be used. While MASK does not improve reliability in
many cases, it does on some occasions, and since it is essen-
tially free in terms of performance cost, it is almost certainly
worthwhile to apply it.
8 Relation to Prior Work
The techniques presented in this paper are the ﬁrst low-
level software-only recovery methods. Previous works have
proposed single-threaded fault mitigation techniques both at
the source code level [21] and the instruction level [17, 23,
31], but these techniques only address fault detection, not
fault recovery. Techniques have also been previously devised
which use arithmetic codes, however, they either only address
fault detection [16] or require some hardware [5, 6].
There has also been previous work on the notion of mul-
tiple execution and majority reconciliation to enable fault re-
covery. N-version programming (NVP), the process of us-
ing N independent modules to do the same task, was origi-
nally created to reduce faults in the system design process,
by using different teams and compilation tools to develop a
software system [1, 2, 4]. While our techniques create mul-
tiple versions of the computation, it is notably different from
NVP in that NVP attempts to address software programmer
errors, while our technique addresses transient faults. Con-
sequently, NVP requires programs to be independently de-
veloped multiple times, whereas our techniques are fully-
automated, compiler-driven approaches.
Techniques using software-only N-way redundancy have
also been applied to parallel systems [7, 9, 12]. In those sys-
tems, an application was split into independent tasks and each
task was assigned to multiple computation nodes. The results
of the computations were compared from the multiple nodes,
and a ﬁnal output was determined, usually by majority vot-
ing. These techniques used software recovery, but at a much
higher level. By targeting thread-level parallelism rather
than instruction-level parallelism, these high-level techniques
under-utilize available ILP resources, resulting in a lower
transistor efﬁciency than our techniques. Furthermore, their
techniques are only applicable in multi-processor environ-
ments, whereas our techniques are all single-threaded.
9 Conclusion
As faults become more commonplace, it will be critical for
designers, especially at the embedded and commodity level,
to maintain the reliability of their systems without adding
hardware and increasing the design complexity of already
baroque hardware.
This paper demonstrates that software-only recovery in the
face of transient faults is a reliable option. Three novel tech-
niques are introduced – SWIFT-R, an augmentation of the
software-only detection scheme, SWIFT; TRUMP, a new re-
covery system which makes use of AN-codes for implement-
ing redundancy more cost-effectively; and MASK, which en-
forces program invariants with minimal intrusiveness. The
experimental evaluation shows that the techniques represent
a wide spectrum of performance and reliability tradeoffs.
SWIFT-R offers nearly total protection against faults by re-
ducing the amount of SDC and SEGV events by 89.39%,
while MASK offers nearly negligable performance degrada-
tion. TRUMP offers an attractive middle ground, reducing
SDC and SEGV by 52.48% while only costing 36% in execu-
tion time overhead. Combining these techniques into hybrid
techniques offers even more options to designers.
Our implementation of these software-only recovery tech-
niques in a production compiler demonstrates that fault re-
covery can indeed be added into today’s designs and today’s
processors.
Acknowledgments
We thank the entire Liberty Research Group, Shubhendu
Mukherjee, and the anonymous reviewers for their support
during this work. This work has been supported by the In-
tel Corporation. Opinions, ﬁndings, conclusions, and recom-
mendations expressed throughout this work are not necessar-
ily the views of Intel Corporation.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:27:54 UTC from IEEE Xplore.  Restrictions apply. 
MASKTRUMPTRUMP/MASKTRUMP/SWIFT-RSWIFT-R123NormalizedExecutionTime099.go124.m88ksim129.compress130.li132.ijpeg134.perl164.gzip179.art181.mcf183.equake186.crafty197.parser254.gap255.vortex256.bzip2300.twolfadpcmdecadpcmencepicdecepicencg721encgsmdecgsmencjpegdecjpegencmpeg2decmpeg2encGeoMeanReferences
[1] A. Avizienis. The methodology of N-version programming.
Chapter 2 of Software Fault Tolerance, M. R. Lyu (ed.), Wiley,
23-46, 1995., 1995.
[2] A. Avizienis and L. Chen. On the implementation of N-
version programming for software fault tolerance during ex-
ecution. In COMPSAC, pages 149–155, 1997.
[3] R. C. Baumann.
Soft errors in advanced semiconductor
devices-part I: the three radiation sources. IEEE Transactions
on Device and Materials Reliability, 1(1):17–22, March 2001.
[4] S. S. Brilliant, J. C. Knight, and N. G. Leveson. Analysis of
faults in an n-version software experiment. IEEE Trans. Softw.
Eng., 16(2):238–247, 1990.
[5] J.-L. Dufour. Safety computations in integrated circuits. In
VTS ’96: Proceedings of the 14th IEEE VLSI Test Sympo-
sium (VTS ’96), page 169, Washington, DC, USA, 1996. IEEE
Computer Society.
[6] P. Forin. Vital coded microprocessor principles and applica-
tion for various transit systems. In IFAC/IFIP/IFORS Sympo-
sium, pages 79–84, September 1989.
[7] R. Guerraoui and A. Schiper. Software-based replication for
fault tolerance. IEEE Computer, 30:68–74, April 1997.
[8] R. W. Horst, R. L. Harris, and R. L. Jardine. Multiple instruc-
tion issue in the NonStop Cyclone processor. In Proceedings
of the 17th International Symposium on Computer Architec-
ture, pages 216–226, May 1990.
[9] Z. T. Kalbarczyk, R. K. Iyer, S. Bagchi, and K. Whisnant.
Chameleon: A software infrastructure for adaptive fault toler-
ance. IEEE Transactions on Parallel and Distributed Systems,
10:560–579, June 1999.
[10] C. Lee, M. Potkonjak, and W. Mangione-Smith. Mediabench:
A tool for evaluating and synthesizing multimedia and com-
munications systems. In Proceedings of the 30th Annual In-
ternational Symposium on Microarchitecture, pages 330–335,
December 1997.
[11] J. Levon. Oproﬁle - a system proﬁler for linux. Web site:
http://oproﬁle.soruceforge.net/, 2005.
[12] M. Li, D. Goldberg, W. Tao, and Y. Tamir. Fault-tolerant
cluster management for reliable high-performance computing.
In 13th International Conference on Parallel and Distributed
Computing Systems, 2001.
[13] S. S. Mukherjee, C. Weaver, J. Emer, S. K. Reinhardt, and
T. Austin. A systematic methodology to compute the archi-
tectural vulnerability factors for a high-performance micro-
processor. In Proceedings of the 36th Annual IEEE/ACM In-
ternational Symposium on Microarchitecture, page 29. IEEE
Computer Society, 2003.
[14] T. J. O’Gorman, J. M. Ross, A. H. Taber, J. F. Ziegler, H. P.
Muhlfeld, I. C. J. Montrose, H. W. Curtis, and J. L. Walsh.
Field testing for cosmic ray soft errors in semiconductor mem-
ories. In IBM Journal of Research and Development, pages
41–49, January 1996.
[15] N. Oh, P. P. Shirvani, and E. J. McCluskey. Control-ﬂow
In IEEE Transactions on
checking by software signatures.
Reliability, volume 51, pages 111–122, March 2002.
[16] N. Oh, P. P. Shirvani, and E. J. McCluskey. ED4I: Error de-
tection by diverse data and duplicated instructions. In IEEE
Transactions on Computers, volume 51, pages 180 – 199,
February 2002.
[17] N. Oh, P. P. Shirvani, and E. J. McCluskey. Error detection
by duplicated instructions in super-scalar processors. In IEEE
Transactions on Reliability, volume 51, pages 63–75, March
2002.
[18] W. W. Peterson and M. O. Rabin. On codes for checking log-
ical operations. IBM Journal of Research and Development,
3(2):163, 1959.
[19] R. Phelan. Addressing soft errors in ARM core-based SoC.
ARM White Paper, December 2003.
[20] M. Rebaudengo, M. S. Reorda, and M. Violante. An accu-
rate analysis of the effects of soft errors in the instruction and
data caches of a pipelined microprocessor. In DATE ’03: Pro-
ceedings of the Conference on Design, Automation and Test
in Europe, page 10602, Washington, DC, USA, 2003. IEEE
Computer Society.
[21] M. Rebaudengo, M. S. Reorda, M. Violante, and M. Torchi-
ano. A source-to-source compiler for generating dependable
In IEEE International Workshop on Source Code
software.
Analysis and Manipulation, pages 33–42, 2001.
[22] S. K. Reinhardt and S. S. Mukherjee. Transient fault detection
via simultaneous multithreading. In Proceedings of the 27th
Annual International Symposium on Computer Architecture,
pages 25–36. ACM Press, 2000.
[23] G. A. Reis, J. Chang, N. Vachharajani, R. Rangan, and D. I.
In
August. SWIFT: Software implemented fault tolerance.
Proceedings of the 3rd International Symposium on Code
Generation and Optimization, March 2005.
[24] G. A. Reis, J. Chang, N. Vachharajani, R. Rangan, D. I. Au-
gust, and S. S. Mukherjee. Design and evaluation of hybrid
fault-detection systems. In Proceedings of the 32th Annual In-
ternational Symposium on Computer Architecture, pages 148–
159, June 2005.
[25] P. P. Shirvani, N. Saxena, and E. J. McCluskey. Software-
implemented EDAC protection against SEUs. In IEEE Trans-
actions on Reliability, volume 49, pages 273–284, 2000.
[26] P. Shivakumar, M. Kistler, S. W. Keckler, D. Burger, and
L. Alvisi. Modeling the effect of technology trends on the
soft error rate of combinational logic. In Proceedings of the
2002 International Conference on Dependable Systems and
Networks, pages 389–399, June 2002.
[27] T. J. Slegel, R. M. Averill III, M. A. Check, B. C. Giamei,
B. W. Krumm, C. A. Krygowski, W. H. Li, J. S. Liptay, J. D.
MacDougall, T. J. McPherson, J. A. Navarro, E. M. Schwarz,
K. Shum, and C. F. Webb. IBM’s S/390 G5 Microprocessor
design. In IEEE Micro, volume 19, pages 12–23, March 1999.
[28] M. Tremblay and Y. Tamir. Support for fault tolerance in VLSI
processors. volume 1, pages 388–392, May 1989.
[29] R. Venkatasubramanian, J. P. Hayes, and B. T. Murray. Low-
cost on-line fault detection using control ﬂow assertions. In
Proceedings of the 9th IEEE International On-Line Testing
Symposium, pages 137–143, July 2003.
[30] N. J. Wang, J. Quek, T. M. Rafacz, and S. J. Patel. Charac-
terizing the effects of transient faults on a high-performance
processor pipeline. In Proceedings of the 2004 International
Conference on Dependable Systems and Networks, pages 61–
72, June 2004.
[31] J. Yan and W. Zhang. Compiler-guided register reliability im-
provement against soft errors. pages 203–209, 2005.
[32] Y. Yeh. Triple-triple redundant 777 primary ﬂight computer.
In Proceedings of the 1996 IEEE Aerospace Applications
Conference, volume 1, pages 293–307, February 1996.
[33] Y. Yeh. Design considerations in Boeing 777 ﬂy-by-wire com-
puters. In Proceedings of the Third IEEE International High-
Assurance Systems Engineering Symposium, pages 64 – 72,
November 1998.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:27:54 UTC from IEEE Xplore.  Restrictions apply.