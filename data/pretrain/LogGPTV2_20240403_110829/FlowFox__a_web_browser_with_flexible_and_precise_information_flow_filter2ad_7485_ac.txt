0
0
%
%
%
%
0
%
Figure 7: Distribution of the relative amount of the
visual diﬀerence between FlowFox and the masked
Firefox for the top-500 web sites.
distribution of the relative size of the area that is diﬀerent.
Diﬀerences are usually small to non-existent: 0% means that
the FlowFox browser renders the page exactly as the two
Firefox browsers for the unmasked area.
The main reasons for a larger deviation – identiﬁed af-
ter manual inspection – were (i) non-displayed content, (ii)
diﬀerently-positioned content, (iii) network delays (loaded
in FlowFox but not yet in Firefox or vice versa) or (iv)
varying images not captured by the mask. In one case, the
site was violating the policy but by providing an appropriate
default value in the policy, FlowFox could still render the
site correctly.
We conclude from this experiment that FlowFox is com-
patible with the current web in the sense that it does not
break sites that comply with the policy being enforced. This
is a non-trivial observation, given that FlowFox handles
scripts radically diﬀerently (executing each script twice un-
der the SME regime) and supports our claim that FlowFox
is a fully functional web browser.
This ﬁrst experiment is an automatic crawl. It just visits
the homepages of websites. Even though these home pages
in most cases contain intricate JavaScript code, the experi-
ment could not interact intensely with the websites visited.
Hence, we performed a second experiment, where FlowFox
is used to complete several complex, interactive web scenar-
ios with a random selection of popular sites.
We identiﬁed 6 important categories of web sites / web ap-
plications amongst the Alexa top-15: web mail applications,
online (retail) sales, search engines, blogging applications,
social network sites and wikis. For each category, we ran-
domly picked a prototypical web site from this top-15 list
for which we worked out and recorded a speciﬁc, complex
use case scenario of an authenticated user interacting with
that web site. We played these in FlowFox with the ses-
sion cookie policy. In addition, we selected some sites that
perform behavior tracking, and browsed them in a way that
triggers this tracking (e.g. selecting and copying text) with
a policy that protects against tracking (see Section 5.2.2).
Appendix A contains an overview of a representative sample
of our use cases recordings.
For all scenarios, the behavior of FlowFox was for the
user indistinguishable from the Firefox browser. For the
behavior tracking sites, the information leaks were closed
– i.e. FlowFox ﬁxed the executions in the sense that the
original script behavior was preserved, except the leakage of
sensitive information was replaced with default values. This
has no impact on user experience, as the user does not notice
these leaks in Firefox either.
This second experiment conﬁrms our conclusions from the
ﬁrst experiment: FlowFox is compatible with the current
web, and can ﬁx interferent executions in ways that do not
impact user experience.
5.2 Security
We evaluate two aspects of the security of FlowFox. In
order for the theoretical properties of SME to hold, we need
(i) a deterministic scheduler and (ii) a deterministic lan-
guage.
Because of the total order of our lattice and the semi-
serial execution (see Section 4.1), the scheduler is eﬀec-
tively deterministic. Although there are some source of
non-determinism in JavaScript3, we consider them merely
as technical issues – in practice they will not exist, except
for setTimeout, that is handled like a regular event – result-
ing in a deterministic JavaScript execution.
5.2.1
There are two reasons our prototype could fail to be
(1) if it violates the assumptions under-
non-interferent:
lying the soundness proof [18, §III.B], or (2) if there are
implementation-level vulnerabilities in our prototype.
Is FlowFox Non-interferent?
For (1), an important assumption is that no information
output to an API method classiﬁed as high can be input
again through an API call classiﬁed as low. In other words,
for soundness, policies should be compatible with the browser
API implementation in the sense that scripts should not be
able to leak information to lower levels through the API im-
plementation. It is non-trivial to validate this assumption in
our prototype: browser API calls are treated as I/O chan-
nels, and the implementation of the browser API is large and
complex. Checking whether a given policy is compatible in
this sense is a non-trivial task in general, and investigat-
ing this more thoroughly is an interesting avenue for future
work. However, the relatively simple policies that we used
in our experiments are compatible.
For (2), – given the size and complexity of the code base
of our prototype – we can’t formally guarantee the absence
of any implementation vulnerabilities. However, we can pro-
vide some assurance: the ECMAScript speciﬁcation assures
us that I/O can only be done in JavaScript by means of
the browser API. Core JavaScript – as deﬁned by the EC-
MAScript speciﬁcation – doesn’t provide any input or out-
3http://code.google.com/p/google-caja/wiki/
SourcesOfNonDeterminism
754put channel to the programmer [20, §I]. Since all I/O op-
erations have to pass the translation layer to be used by
the DOM implementation (see Section 4.2), we have high
assurance that all operations are correctly intercepted and
handled according to the SME I/O rules.
Finally, we have extensively manually veriﬁed whether
FlowFox behaves as expected on malicious scripts attempt-
ing to leak information (we discuss some example policies
in Section 5.2.2). We believe all these observations together
give a reasonable amount of assurance of the security of
FlowFox.
5.2.2 Can FlowFox Enforce Useful Policies?
FlowFox guarantees non-interference with respect to an
information ﬂow policy. But not all such policies are neces-
sarily useful. In this section, we demonstrate how some of
the concrete threats we discussed in Section 2 are eﬀectively
mitigated.
Leaking session cookies.
In Section 2 we discussed how malicious scripts can leak
session cookies to an attacker. A simple solution would be
to prevent scripts from accessing cookies. However, consider
the following code snippet:
1 new Image().src = "http://host/?=" + document.cookie;
2 document.body.style.backgroundColor = cookieValue("color");
In order for the script above to work, only the color value
from the cookie is needed. By assigning a high security level
to both the DOM call for the cookie and the background
color, and a low level to API calls that trigger network out-
put, we allow the script access to the cookies, but prevent
them from leaking.
Executing the above code snippet with FlowFox, results
in the following two executions:
1 new Image().src = "http://host/?=" + document.cookieundefined;
2 document.body.style.backgroundColor = cookieValue("color");
The high execution:
1 new Image().src = "http://host/?=" + document.cookie;
2 document.body.style.backgroundColor = cookieValue("color");
Hence, the script executes correctly, but does not leak the
cookie values to the attacker.
This policy subsumes ﬁne-grained cookie access control
systems, such as SessionShield [33] that use heuristic tech-
niques to prevent access to session cookies but allow access
to other cookies.
History snifﬁng.
History sniﬃng [23, §4] is a technique to leak the browsing
history of a user by reading the color information of links to
decide if the linked sites were previously visited by the user:
1 var l = document.createElement("a");
2 l.href = "http://web.site.com"
3 new Image().src = "http://attacker/?=" +
4 (document.defaultView.getComputedStyle(l, null)
5
.getPropertyValue("color") == "rgb(12, 34, 56)")
Baron [6] suggested a solution for preventing direct sniﬀ-
ing by modifying the behavior of the DOM style API to
pretend as if all links were styled as if they were unvisited.
In FlowFox, one can assign a high security level to the
getPropertyValue method, and set an appropriate default
color value. If all API calls that trigger network output are
low, scripts can still access the color, but can’t leak it.
Tracking libraries.
Tynt4 is a web publishing toolkit, that provides web sites
with the ability to monitor the copy event. Whenever a
user copies content from a web page, the library appends
the URL of the page to the copied content and transfers
this to its home page via the use of an image object [23, §5].
To block the leakage of copied text, we construct policy rule
R6 to contain the Tynt software by assigning a high security
label to the DOM call for receiving the selected text:
R6[window.getSelection] : true → H (cid:44)→ 
FlowFox now always reports that empty strings are copied.
Other web sites covertly track the user’s click events. By
assigning a high security label to the DOM calls for access-
ing mouse coordinates, we contain those behavior tracking
scripts. Policy rules R7 and R8 could be representative for
such a security policy:
(cid:40)
R7[MouseEvent.clientX] : true → H (cid:44)→ 0
R8[MouseEvent.clientY] : true → H (cid:44)→ 0
FlowFox will now always report the default position of the
mouse to external parties.
The examples above are only the tip of the iceberg. Flow-
Fox supports a wide variety of useful policies. We consider
three classes of policies to be interesting for further investi-
gation:
1. Policies that classify the entire DOM API low, except
for some selected calls that return sensitive informa-
tion. The three examples above fall in this category.
Such policies could be oﬀered by the browser vendor
as a kind of privacy proﬁle.
2. Policies that approximate the SOP, but close some of
its leaks. Writing such a policy is an extensive task, as
each DOM API method must receive an appropriate
policy rule that ensures that information belonging to
the document origin is high and other information is
low. However, such a policy must be written only once,
and should only evolve as the DOM API evolves.
3. Server-driven policies, where a site can conﬁgure
FlowFox to better protect the information returned
from that site.
Note that none of these cases requires the end-user to write
policies. Policy writing is obviously too complex for browser
end-users.
5.3 Performance and Memory Cost
All experiments reported in this section were performed
on a MacBook notebook with a 2GHz Intel R(cid:13)CoreTM2 Duo
processor and 2GB RAM.
5.3.1 Micro Benchmarks
The goal of the ﬁrst performance experiment is to quan-
tify the performance cost of our implementation of SME for
JavaScript.
4http://www.tynt.com/
755Unmodiﬁed SpiderMonkey
SpiderMonkey with SME disabled
SpiderMonkey with SME enabled
Mozilla Firefox
σ
FlowFox
σ
200%
150%
100%
50%
0%
c
d
e
r
r
r
s
r
y
p
t
o
e
a
l
t
r
l
a
e
a
e
y
g
t
e
i
c
h
p
l
a
r
x
a
y
b
a
y
l
-
u
b
c
e
p
r
d
s
i
o
e
o
y
e
r
Figure 8: Experimental results for the micro bench-
marks.
We used the Google Chrome v8 Benchmark suite ver-
sion 6 5 – a collection of pure JavaScript benchmarks used
to tune the Google Chrome project – to benchmark the
JavaScript interpreter of our prototype. To simulate I/O
intensive applications, we reused the I/O test from Devriese
and Piessens [18, §V.B]. This test simulates interleaved in-
puts and outputs at all available security levels while simu-
lating a 10ms I/O latency.
We measured timings for three diﬀerent runs:
(i) the
original unmodiﬁed SpiderMonkey, (ii) SpiderMonkey with
our modiﬁcations but without multi-executing (every bench-
mark was essentially executed at a low security level with all
available DOM calls assigned a low security level) and (iii)
SpiderMonkey with SME enabled.
The results of this experiment in Figure 8 show that our
modiﬁcations have the largest impact – even when not multi-
executing – for applications that extensively exploit data
structures, like splay and raytrace. The results also con-
ﬁrm our expectations that our prototype implementation
more or less doubles execution time when actively multi-
executing with two security levels. The io test shows only a
negligible impact overhead, because while one security level
blocks on I/O, the other level can continue to execute. The
results are in line with previous research results of another
SME implementation [18].
Since web scripts can be I/O intensive, the small perfor-
mance impact on I/O intensive code is important, and one
can expect macro-benchmarks for web scenarios to be sub-
stantially better than 200%.
5.3.2 Macro Benchmarks
The goal of the second performance experiment is to mea-
sure the impact on the latency perceived by a browser user.
We used the web application testing framework Selenium
to record and automatically replay six scenarios from our
5http://v8.googlecode.com/svn/data/benchmarks/v6/
revision 10404.
160%
140%
120%
100%
80%
60%
40%
20%
0%
a
m
f
a
c
e
a
g
o
g
z
b
g
o
o
o
n
o
k
e
r
l
e
i
p
e
d
i
a
y
b
g
a
l
o
o
w
i
h
o
k
Figure 9: Latency induced by FlowFox on scenarios.
second compatibility experiment for both the unmodiﬁed
Mozilla Firefox 8.0.1 browser and FlowFox. The results
in Figure 9 show the average execution time (including the
standard deviation) of each scenario for both browsers. In
order to realistically simulate a typical browsing environ-
ment, caching was enabled during browsing, but cleared be-
tween diﬀerent browser runs. The results show that the
user-perceived latency for real-life web applications is at an
acceptable scale.
5.3.3 Memory Benchmarks
Finally, we provide a measurement of the memory