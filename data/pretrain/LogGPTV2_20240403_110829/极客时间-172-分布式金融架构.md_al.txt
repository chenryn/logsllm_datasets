# 第 08 讲 | 如何确保计算结果的正确性

你好，我是任杰。在这一讲中，我们将探讨如何确保系统计算结果的正确性。

在前面几节课里，我们学习了如何保证数据输入的正确性以及如何利用事件溯源架构来确保数据计算的准确性。然而，这些措施只能确保单个组件的正确性。一个完整的系统由多个组件构成，因此我们需要一个全面的方案来确保各个组件之间的交互也是正确的。

从抽象的角度来看，任何计算过程都可以分为三个阶段：接收请求、处理请求和输出结果。接下来，我们将从这三个方面逐一分析，探讨如何系统地保证最终结果的正确性。

## 事前准备
### 数据内容的正确性
如果输入的数据不正确，那么计算的结果也很难准确。数据不正确可能有两种情况：一是单个数据的内容错误；二是多个数据之间的顺序关系不正确。下面我们来看看如何解决这两方面的问题。

#### 单个数据内容的正确性
假设上游系统负责将数据传输给下游系统，那么**上游系统需要确保数据内容的正确性**。在第 6 节课中提到，在数据可以被修改的情况下，我们很难保证所有人都能使用到正确的数据。因此，金融公司通常会采用双时序数据库来确保查询到的数据是正确的。即便如此，数据在读取或传输过程中仍有可能出现问题（如部分数据丢失或损坏）。为此，我们需要为数据增加完整性校验功能，例如在存储时添加 HMAC 验证，这都是常规操作。此外，还需要给数据**增加版本号**，以便下游系统进行格式验证。这种做法在系统升级后的向下兼容处理中非常有效。

#### 多个数据顺序的正确性
顺序正确性是指上游发给下游的多条消息之间必须保持正确的顺序。这不仅要求上游系统的配合，也需要下游系统的参与。简单来说，如果上游按顺序发送了 1、2、3 这三条消息，下游也应按同样的顺序收到它们。这意味着接收端必须满足以下三点：**顺序不能乱、个数不能少也不能多**。

TCP 协议提供了一种解决方案，即每个消息都包含一个自增 ID，并且接收方会将所有收到的消息先存入一个缓冲区，直到所需的消息出现再取出。但在云计算环境中，由于发送方可能会通过多个 TCP 链接向接收方发送消息，即使单个 TCP 内部消息是有序的，但不同链接间仍可能出现乱序现象。解决办法是，**发送方与接收方之间实现类似 TCP 的机制，通过自增 ID 和消息缓冲区来解决乱序问题**。

### 消息至少一次投递
“至少一次”意味着消息不应丢失。理想情况下，发送方只需发送一次消息即可，但实际上网络环境并不稳定。为了确保消息能够成功送达，发送方需要持续重发消息，直到收到接收方的确认回执为止。此过程可以通过独立的消息中间件来实现，该中间件拥有自己的数据库，用于存放待发送的消息及其对应的回执状态。当某个消息的回执位为空时，消息中间件将持续尝试将其发送给下游系统。整个流程包括六个步骤：
1. 业务系统将消息传递给进程内的消息中间件。
2. 消息中间件将消息保存至数据库，并设置回执位为空。
3. 消息保存后，消息中间件通知业务系统发送成功。
4. 消息中间件将消息转发给下游系统。
5. 下游系统返回确认回执。
6. 收到回执后，消息中间件更新数据库中的回执状态。

这个架构依赖于**数据库事务**和**幂等性**来确保消息至少被投递一次。

## 事中处理
对于消息处理而言，准备工作至关重要。而实际处理过程则更多地涉及软件工程而非架构设计。我们可以从函数式编程和计算精度两个角度理解它。

### 函数式编程
函数式编程语言不允许修改数据或引入随机性，使得函数组合成为可能。这种特性有助于维持程序的正确性。尽管学习成本较高，但从长远看，函数式编程语言在维护正确性方面的优势明显。许多金融机构都在使用这类语言，例如高盛的 Slang、摩根士丹利的 A+ 等。

### 计算精度
随着金额增大，精度问题变得愈发重要。设计金融系统时需考虑业务边界，避免因大额交易导致的精度误差。

## 事后验证
计算完成后还需对结果进行验证。验证可以在不同的环境下进行，以降低结果间的相关性。常见的方法包括选择不同的编程语言、开发者及架构设计。根据场景的重要性，验证次数也会有所不同，一般情况下验证一次就足够了。验证方式可分为实时验证和异步验证两种。前者可预防潜在问题但会增加延迟；后者虽可能导致负面影响，却提供了更灵活的时间安排。在金融领域，日切或对账就是典型的异步验证手段。

总之，确保单个组件的正确性并不能保证整个系统的可靠性。我们需要通过合理的架构设计使组件间的交互行为变得确定，并在软件工程层面选择不易出错的方法来实现这一点。

思考题：假设你设计了一个预期运行超过十年的系统，由于数据库容量有限，旧数据会被归档并删除。在这种情况下，如何防止已删除 ID 导致的消息重复处理？欢迎在评论区分享你的想法！