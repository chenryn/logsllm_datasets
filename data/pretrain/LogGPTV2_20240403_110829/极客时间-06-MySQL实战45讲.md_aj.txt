# 从两阶段锁说起我先给你举个例子。在下面的操作序列中，事务 B 的 update语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。\![](Images/8b3c554cc6619376c102de08b8140c5b.png){savepage-src="https://static001.geekbang.org/resource/image/51/10/51f501f718e420244b0a2ec2ce858710.jpg"}这个问题的结论取决于事务 A 在执行完两条 update语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务 B 的update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。``{=html}知道了这个答案，你一定知道了事务 A 持有的两个记录的行锁，都是在 commit的时候才释放的。也就是说，**在 InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**知道了这个设定，对我们使用事务有什么帮助呢？那就是，[如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。]{.orange}我给你举个例子。假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B购买电影票。我们简化一点，这个业务需要涉及到以下操作：1.  从顾客 A 账户余额中扣除电影票价；2.  给影院 B 的账户余额增加这张电影票价；3.  记录一条交易日志。也就是说，要完成这个交易，我们需要 update 两条记录，并 insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？试想如果同时有另外一个顾客 C 要在影院 B买票，那么这两个事务冲突的部分就是语句 2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句2 安排在最后，比如按照 3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是，这并没有完全解决你的困扰。如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的MySQL 就挂了。你登上服务器一看，CPU 消耗接近100%，但整个数据库每秒就执行不到 100 个事务。这是什么原因呢？这里，我就要说到死锁和死锁检测了。
# 死锁和死锁检测当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。\![](Images/c7070b4daa40bee574580d1d868a8213.png){savepage-src="https://static001.geekbang.org/resource/image/4d/52/4d0eeec7b136371b79248a0aed005a52.jpg"}这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放id=1 的行锁。 事务 A 和事务 B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：-   一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数    innodb_lock_wait_timeout 来设置。-   另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数    innodb_deadlock_detect 设置为 on，表示开启这个逻辑。在 InnoDB 中，innodb_lock_wait_timeout 的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且innodb_deadlock_detect 的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。那如果是我们上面说到的所有事务都要更新同一行的场景呢？每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n) 的操作。假设有 1000个并发线程要同时更新同一行，那么死锁检测操作就是 100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。根据上面的分析，我们来讨论一下，[怎么解决由这种热点行更新导致的性能问题呢？]{.orange}问题的症结在于，死锁检测要耗费大量的CPU 资源。**一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。**但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。**另一个思路是控制并发度。**根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有600 个客户端，这样即使每个客户端控制到只有 5个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到 3000。因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改MySQL 源码的人，也可以做在 MySQL里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB内部就不会有大量的死锁检测工作了。可能你会问，**如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？**你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如10 个记录，影院的账户总额等于这 10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0 的时候，代码要有特殊处理。
# 小结今天，我和你介绍了 MySQL的行锁，涉及了两阶段锁协议、死锁和死锁检测这两大部分内容。其中，我以两阶段协议为起点，和你一起讨论了在开发的时候如何安排正确的事务语句。这里的原则/我给你的建议是：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。但是，调整语句顺序并不能完全避免死锁。所以我们引入了死锁和死锁检测的概念，以及提供了三个方案，来减少死锁对数据库的影响。减少死锁的主要方向，就是控制访问相同资源的并发事务量。最后，我给你留下一个问题吧。如果你要删除一个表里面的前 10000行数据，有以下三种方法可以做到：-   第一种，直接执行 delete from T limit 10000;-   第二种，在一个连接中循环执行 20 次 delete from T limit 500;-   第三种，在 20 个连接中同时执行 delete from T limit 500。你会选择哪一种方法呢？为什么呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。
# 上期问题时间上期我给你留的问题是：当备库用--single-transaction做逻辑备份的时候，如果从主库的 binlog 传来一个 DDL 语句会怎么样？假设这个 DDL 是针对表 t1 的， 这里我把备份过程中几个关键的语句列出来：    Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；/* other tables */Q3:SAVEPOINT sp;/* 时刻 1 */Q4:show create table `t1`;/* 时刻 2 */Q5:SELECT * FROM `t1`;/* 时刻 3 */Q6:ROLLBACK TO SAVEPOINT sp;/* 时刻 4 *//* other tables */在备份开始的时候，为了确保 RR（可重复读）隔离级别，再设置一次 RR隔离级别 (Q1);启动事务，这里用 WITH CONSISTENT SNAPSHOT确保这个语句执行完就可以得到一个一致性视图（Q2)；设置一个保存点，这个很重要（Q3）；show create 是为了拿到表结构 (Q4)，然后正式导数据 （Q5），回滚到SAVEPOINT sp，在这里的作用是释放 t1 的 MDL 锁（Q6）。当然这部分属于"超纲"，上文正文里面都没提到。DDL从主库传过来的时间按照效果不同，我打了四个时刻。题目设定为小表，我们假定到达后，如果开始执行，则很快能够执行完成。参考答案如下：1.  如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL    后的表结构。2.  如果在"时刻 2"到达，则表结构被改过，Q5 执行的时候，报 Table    definition has changed, please retry transaction，现象：mysqldump    终止；3.  如果在"时刻 2"和"时刻 3"之间到达，mysqldump 占着 t1 的 MDL    读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。4.  从"时刻 4"开始，mysqldump 释放了 MDL    读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。评论区留言点赞板：> \@Aurora 给了最接近的答案；\> \@echo＿陈 问了一个好问题；\> \@壹笙☞漂泊 做了很好的总结。![](Images/d7767a95fa59b270d692441e706a6dce.png){savepage-src="https://static001.geekbang.org/resource/image/ce/d9/ce7f4e35916ed1aa49206a53a0547bd9.jpg"}
# 08 \| 事务到底是隔离的还是不隔离的？> 你好，我是林晓斌。\> 你现在看到的这篇文章是我重写过的。在第一版文章发布之后，我发现在介绍事务可见性规则时，由于引入了太多概念，导致理解起来很困难。随后，我索性就重写了这篇文章。\> 现在的用户留言中，还能看到第一版文章中引入的 up_limit_id> 的概念，为了避免大家产生误解，再此特地和大家事先说明一下。我在第 3篇文章和你讲事务隔离级别的时候提到过，如果是可重复读隔离级别，事务 T启动的时候会创建一个视图 read-view，之后事务 T执行期间，即使有其他事务修改了数据，事务 T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。但是，我在上一篇文章中，和你分享行锁的时候又提到，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？我给你举一个例子吧。下面是一个只有两行的表的初始化语句。    mysql> CREATE TABLE `t` (  `id` int(11) NOT NULL,  `k` int(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB;insert into t(id, k) values(1,1),(2,2);![](Images/c812a098f71c23a66b2409fd535c88b3.png){savepage-src="https://static001.geekbang.org/resource/image/82/d6/823acf76e53c0bdba7beab45e72e90d6.png"}```{=html}```图 1 事务 A、B、C 的执行流程```{=html}```这里，我们需要注意的是事务的启动时机。begin/start transaction命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 starttransaction with consistent snapshot 这个命令。``{=html}> 第一种启动方式，一致性视图是在第执行第一个快照读语句时创建的；\> 第二种启动方式，一致性视图是在执行 start transaction with consistent> snapshot 时创建的。还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认autocommit=1。在这个例子中，事务 C 没有显式地使用 begin/commit，表示这个 update语句本身就是一个事务，语句完成的时候会自动提交。事务 B在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务B 的查询之后。这时，如果我告诉你事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是1，你是不是感觉有点晕呢？所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能够帮助你对InnoDB 的事务和锁有更进一步的理解。在 MySQL 里，有两个"视图"的概念：-   一个是    view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是    create view ... ，而它的查询方法与表一样。-   另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read    view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable    Read，可重复读）隔离级别的实现。它没有物理结构，作用是事务执行期间用来定义"我能看到什么数据"。在第 3篇文章[《事务隔离：为什么你改了我还看不见？》](https://time.geekbang.org/column/article/68963)中，我跟你解释过一遍MVCC 的实现逻辑。今天为了说明查询和更新的区别，我换一个方式来说明，把read view 拆开。你可以结合这两篇文章的说明来更深一步地理解 MVCC。