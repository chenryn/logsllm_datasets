Each candlestick shows 5 measurements of throughput (re-
quest/sec) for a percentage of tainted packets.
tainted bytes do not linearly decrease with taint_perc. Second,
these even seemingly small taint_perc values represent the
real world scenarios. For instance for security applications,
the attacks are anomaly cases and the percentage of suspicious
packets are well below 1%. Overall, DECAF++ achieves an
average (geometric) 60% throughput improvement in compar-
ison to DECAF. When there are no tainted bytes, our system
is still around 18% slower than QEMU because of the network
callbacks.
6.4 Elastic Instrumentation Overhead
In this section, we evaluate DECAF++ to answer (3) and
understand whether we could address the shortcomings of the
previous works that are high overhead in the check mode of
LIFT [25] or high transition overhead of [13].
Check mode overhead Elastic taint analysis imposes an
overhead even when there are no tainted bytes. In case of
LIFT [25], it’s the registers taint tag check at the beginning
of every basic block and further memory tag checks before
memory instructions. For DECAF++, our evaluation using
SPEC CPU2006 and nbench illustrated in Figure 10 and Fig-
465534570679698374385432482528564561295312316353354365367100%10%1%0.1%0.05%0.02%0.01%throughput (request/sec)taint percentageDECAF++ optmization feature:FullMemoryPropagationUSENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 41Figure 10: SPEC CPU2006 for different implementations
Figure 11: DECAF++ check mode overhead on nbench
the time it takes to change the mode and execute the same
instruction that was executing before the transition occurred.
Our measurement was performed during nbench execution,
and every input byte was tainted. We repeated the measure-
ment 10 times. The average transition time is 0.031% of the
overall benchmark execution time with 0.007% relative stan-
dard deviation.
7 Conclusion
In this work, we introduced elastic tainting for whole-system
dynamic taint analysis. Elastic tainting is based on elastic taint
propagation and elastic taint status checking that accordingly
address DECAF taint propagation and taint status checking
overhead by removing unnecessary taint analysis computa-
tions when the system is in a safe state. We successfully
designed and implemented this idea on top of DECAF in a pro-
totype dubbed DECAF++ via pure software optimization. We
showed that elastic tainting helps DECAF++ achieve a sub-
stantial better performance even when all inputs are tainted.
Further, we showed how elastic taint propagation and elastic
taint checking optimization each and together contribute to
the performance improvement for different applications.
Our elastic tainting addresses the shortcomings of the pre-
vious works that are either high overhead when there’s no
tainted bytes or high transition cost when there is some. As a
result, DECAF++ has an elastic property for both information
ﬂow within a process and information ﬂow of a network input
throughout the system. We believe whole-system dynamic
taint analysis applications like intrusion detection systems
and honeypots can greatly beneﬁt from the elastic property.
On one hand, this is because these systems are constantly
online and taint analysis affects the entire system constantly.
On the other hand, these systems can ﬁlter benign trafﬁc and
focus on the taint analysis of a small portion of the trafﬁc that
are likely to be malicious.
Acknowledgement
We thank the anonymous reviewers for their insightful com-
ments on our work. This work is partly supported by Ofﬁce
of Naval Research under Award No. N00014-17-1-2893. Any
opinions, ﬁndings, and conclusions or recommendations ex-
pressed in this paper are those of the authors and do not
necessarily reﬂect the views of the funding agencies.
References
[1] apache HTTP server benchmarking tool. https://
httpd.apache.org/docs/2.4/programs/ab.html.
0123456789Runtime ratioTainting disabled (only VMI)PropagationMemoryFull optimizationDECAF05101520Normalized iterations/secFull tainting disabledMemoryFullDECAFPropagationQemu 1.042          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Association[2] Fabrice Bellard. Qemu, a fast and portable dynamic
translator. In Proceedings of the USENIX Annual Tech-
nical Conference (ATC ’05), pages 41–41, 2005.
platform. In Proceedings of the 2014 International Sym-
posium on Software Testing and Analysis (ISSTA’14),
pages 248–258. ACM, July 2014.
[3] Edson Borin, Cheng Wang, Youfeng Wu, and Guido
Araujo. Software-based transparent and comprehen-
sive control-ﬂow error detection. In Proceedings of the
International Symposium on Code generation and Opti-
mization (CGO ’06), pages 333–345. IEEE Computer
Society, March 2006.
[4] Erik Bosman, Asia Slowinska, and Herbert Bos.
Minemu: The world’s fastest taint tracker. In Proceed-
ings of the 14th International Symposium On Recent
Advances in Intrusion Detection (RAID’11), pages 1–20,
Berlin, Heidelberg, September 2011. Springer.
[5] Juan Caballero, Heng Yin, Zhenkai Liang, and Dawn
Song. Polyglot: Automatic extraction of protocol mes-
sage format using dynamic binary analysis. In Proceed-
ings of the 14th ACM Conferences on Computer and
Communication Security (CCS’07), October 2007.
[6] Jim Chow, Ben Pfaff, Tal Garﬁnkel, Kevin Christopher,
and Mendel Rosenblum. Understanding data lifetime
In Proceedings of the
via whole system simulation.
13th USENIX Security Symposium (Security ’04), pages
321–336, August 2004.
[7] James Clause, Wanchun Li, and Alessandro Orso. Dy-
tan: A generic dynamic taint analysis framework. In
Proceedings of the 2007 International Symposium on
Software Testing and Analysis (ISSTA ’07), pages 196–
206, New York, NY, USA, July 2007. ACM.
[8] Ali Davanian. Effective granularity in internet badhood
detection: Detection rate, precision and implementation
performance. Master’s thesis, University of Twente,
August 2017.
[9] Peter J Denning. The locality principle. In Communi-
cation Networks And Computer Systems: A Tribute to
Professor Erol Gelenbe, pages 43–67. World Scientiﬁc,
2006.
[10] Brendan Dolan-Gavitt, Josh Hodosh, Patrick Hulin, Tim
Leek, and Ryan Whelan. Repeatable reverse engineering
with panda. In Proceedings of the 5th Program Protec-
tion and Reverse Engineering Workshop (PPREW-5),
page 4. ACM, December 2015.
[11] Cornelia Cecilia Eglantine. Nbench. 2012.
[12] Andrew Henderson, Aravind Prakash, Lok Kwong Yan,
Xunchao Hu, Xujiewen Wang, Rundong Zhou, and Heng
Yin. Make it work, make it right, make it fast: building a
platform-neutral whole-system dynamic binary analysis
[13] Alex Ho, Michael Fetterman, Christopher Clark, An-
drew Warﬁeld, and Steven Hand. Practical taint-based
protection using demand emulation. In Proceedings of
the 1st ACM SIGOPS/EuroSys European Conference
on Computer Systems 2006 (EuroSys ’06), pages 29–41,
New York, NY, USA, 2006. ACM.
[14] Kangkook Jee, Vasileios P Kemerlis, Angelos D
Keromytis, and Georgios Portokalidis. Shadowreplica:
efﬁcient parallelization of dynamic data ﬂow tracking.
In Proceedings of the 2013 ACM SIGSAC Conference
on Computer & Communications Security (CCS ’13),
pages 235–246. ACM, 2013.
[15] Yang Ji, Sangho Lee, Evan Downing, Weiren Wang, Mat-
tia Fazzini, Taesoo Kim, Alessandro Orso, and Wenke
Lee. Rain: Reﬁnable attack investigation with on-
demand inter-process information ﬂow tracking. In Pro-
ceedings of the 2017 ACM SIGSAC Conference on Com-
puter and Communications Security (CCS ’17), pages
377–390, New York, NY, USA, October 2017. ACM.
[16] Vasileios P Kemerlis, Georgios Portokalidis, Kangkook
Jee, and Angelos D Keromytis. libdft: Practical dynamic
data ﬂow tracking for commodity systems. In Proceed-
ings of the 8th ACM SIGPLAN/SIGOPS conference on
Virtual Execution Environments (VEE ’12), volume 47,
pages 121–132. ACM, 2012.
[17] David Korczynski and Heng Yin. Capturing malware
propagations with code injections and code-reuse at-
In Proceedings of the 24th ACM Conference
tacks.
on Computer and Communications Security (CCS’17),
pages 1691–1708, New York, NY, USA, October 2017.
ACM.
[18] Yonghwi Kwon, Dohyeong Kim, William Nick Sum-
ner, Kyungtae Kim, Brendan Saltaformaggio, Xiangyu
Zhang, and Dongyan Xu. Ldx: Causality inference
by lightweight dual execution. In Proceedings of the
Twenty-First International Conference on Architectural
Support for Programming Languages and Operating
Systems (ASPLOS ’16), pages 503–515. ACM, March
2016.
[19] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish
Patil, Artur Klauser, Geoff Lowney, Steven Wallace, Vi-
jay Janapa Reddi, and Kim Hazelwood. Pin: building
customized program analysis tools with dynamic instru-
mentation. In Proceedings of the 2005 ACM SIGPLAN
Conference on Programming Language Design and Im-
plementation (PLDI’05), pages 190–200. ACM, June
2005.
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 43[20] Darek Mihocka and Stanislav Shwartsman. Virtual-
ization without direct execution or jitting: Designing a
portable virtual machine infrastructure. In 1st Workshop
on Architectural and Microarchitectural Support for Bi-
nary Translation in ISCA’08, Beijing, page 32, 2008.
[21] Jiang Ming, Dinghao Wu, Jun Wang, Gaoyao Xiao, and
Peng Liu. Straighttaint: Decoupled ofﬂine symbolic
taint analysis. In Proceedings of the 31st IEEE/ACM
International Conference on Automated Software Engi-
neering (ASE’16), pages 308–319. IEEE, August 2016.
[22] Jiang Ming, Dinghao Wu, Gaoyao Xiao, Jun Wang, and
Peng Liu. Taintpipe: Pipelined symbolic taint analysis.
In Proceedings of the 24th USENIX Security Symposium
(Security ’15), pages 65–80, August 2015.
[23] Nicholas Nethercote and Julian Seward. Valgrind: a
framework for heavyweight dynamic binary instrumen-
tation. In Proceedings of the 28th ACM SIGPLAN Con-
ference on Programming Language Design and Imple-
mentation (PLDI ’07), volume 42, pages 89–100. ACM,
June 2007.
[24] James Newsome and Dawn Xiaodong Song. Dynamic
taint analysis for automatic detection, analysis, and sig-
nature generation of exploits on commodity software. In
Proceedings of the 12th Annual Network and Distributed
System Security Symposium (NDSS’05), volume 5, pages
3–4, 2005.
[25] Feng Qin, Cheng Wang, Zhenmin Li, Ho-seop Kim,
Yuanyuan Zhou, and Youfeng Wu. Lift: A low-overhead
practical information ﬂow tracking system for detect-
ing security attacks. In Proceedings of the 39th Annual
IEEE/ACM International Symposium on Microarchitec-
ture (MICRO’06), pages 135–148. IEEE, 2006.
[26] Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Co-
jocar, Cristiano Giuffrida, and Herbert Bos. VUzzer:
Application-aware Evolutionary Fuzzing. In Network
and Distributed System Security Symposium (NDSS’17),
February 2017.
[27] LK Yan, A Henderson, X Hu, H Yin, and S McCamant.
On soundness and precision of dynamic taint analysis.
Dep. Elect. Eng. Comput. Sci., Syracuse Univ., Tech.
Rep. SYR-EECS-2014–04, 2014.
[28] Heng Yin, Zhenkai Liang, and Dawn Song. Hook-
Finder: Identifying and understanding malware hooking
behaviors. In Proceedings of the 15th Annual Network
and Distributed System Security Symposium (NDSS’08),
February 2008.
[29] Heng Yin, Dawn Song, Manuel Egele, Christopher
Kruegel, and Engin Kirda. Panorama: capturing system-
wide information ﬂow for malware detection and analy-
sis. In Proceedings of the 14th ACM Conference on Com-
puter and Communications Security (CCS ’07), pages
116–127. ACM, 2007.
A QEMU
DECAF is built on top of QEMU [2]. Therefore, to under-
stand DECAF and DECAF++, Qemu knowledge is required.
QEMU provides binary instrumentation functionality in an
architecture agnostic way via emulation. Qemu emulates the
execution of a target binary e.g. a virtual machine image. This
means CPU, memory and other hardware are emulated for
the target binary. CPU is represented using a vcpu data struc-
ture that contains all the CPU registers. Providing Memory
Management Unit (MMU) is more complicated but the idea
is to emulate memory for the target through a software ap-
proach known as software MMU (softMMU). We elaborate
on softMMU at the end of this section.
Binary translation Qemu ﬁrst needs to translate the tar-
get binary to understand how to emulate it. QEMU loads a
guest executable, and translates the binary one block at a time.
QEMU translates the binary into an Intermediate Represen-
tation (IR) named Tiny Code Generator (tcg). The result of
this translation is stored in a data structure called Translation
Block (TB).
Code generation After the translation, Qemu generates an
executable code from the translation block. This generated
code is written to a data structure called code cache. In
essence, code cache is an executable page that allows dynamic
execution of code. After code generation, Qemu executes the
code and updates emulated CPU and memory.
Cache table Qemu stores the result of code translation and
generation in a cache to speedup the emulation. Then, before
future execution of the same program counter, the cache table
would be consulted and the request would be resolved using
cache.
Block chaining
In addition to the above, Qemu employs an-
other optimization to speed up the emulation. We mentioned
that the unit of translation and execution for Qemu is basic
blocks. However, after translation of consecutive code blocks,
Qemu chains them together and forms a trace. This process
is known as block chaining and is implemented by placing a
direct jump from the current block to the next one. A trace
can be executed without interruption for translation.
44          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX AssociationQEMU implements a software Translation Look-aside
Buffer (TLB). Hardware TLB maps virtual pages within a
process to their corresponding physical pages in the memory.
In the Qemu software TLB, the mapping is indeed between
the GVA to the HVA. Through address translation and soft-
ware TLB, QEMU ensures that every guest virtual address
(regardless of the process) is addressable in the host QEMU
process space.
Figure 12 depicts what happens at runtime in the QEMU
memory load and store operations. QEMU needs to make sure
that the software TLB contains a valid entry for the following
page that will be accessed. To this end, it checks whether the
page index portion of the address is valid in the software TLB.
If yes, and the page is not registered as a memory mapped
I/O, it can be safely (without page fault) accessed. This is
the fastest case, and it is expected that based on the locality
principle [9], a majority of memory operations go through
this path. If the page is not present, or the page is registered
as memory mapped I/O then the memory operation is much
slower.
B DECAF Garbage Collection
A memory address may become tainted, and then may be
overwritten through a non-tainted data propagation. In such a
case, the shadow memory can be de-allocated. DECAF does
not reclaim it immediately for performance reasons. Imme-
diate reclaiming requires DECAF to explore all the leaves
(memory addresses) of a parent node (a physical page) for
every memory operation that is very costly.
DECAF relies on a garbage collector to reclaim the unused
shadow memory. DECAF will handle the unused memory
by calling the garbage collector based on an interval. The
garbage collector is called in the QEMU main_loop that runs
in a separate thread. Experimentally, garbage collector is set
to walk the shadow memory pages every 4096 times the main
loop runs.
The garbage collector walks through the shadow memory
and checks every parent and all its leaves. It will return an
unused leaf to a memory pool. This pool will use the leaf for
another taint status storage. Finally, the garbage collector will
return a parent to the memory pool if none of its children is
in use.
Figure 12: QEMU software memory management through
op_qemu_ld|st* operations.
Cache invalidation The generated code blocks may be in-
validated to stop further fast execution using cache table.
There are different reasons for this. Two main reasons that a
code cache would be invalidated are (a) the code cache is full,
and (b) the code has been modiﬁed and the previous generated
code is not valid for re-execution.
Software MMU QEMU software memory management
unit (softMMU) translates Guest Virtual Addresses (GVA)
to the Host Virtual Address (HVA). This process happens at
runtime and within guest memory operations. QEMU gener-
ates load and store IR operations for machine level memory
operations. QEMU tcg IR store operation, i.e., op_qemu_st,
stores the content of a register to a given virtual guest address.
Qemu tcg load operation, i.e., op_qemu_ld, loads the content
of a memory address to a given register.
StartTLB-CheckStartTLB entry valid?Registered I/O handler?Fill TLB with the PageEndInvoke the handler for the operationComplete the translationTLB miss handlerVirtual guest addressHost virtual addressQEMU memory Load/StoreAddress translationHitMissYesNoYesNoFastSlowUSENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 45