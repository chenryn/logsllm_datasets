tradecraft to activities that create anonymous pipes only.
Evading Minifilters
Most strategies for evading an EDR’s minifilters rely on one of three tech-
niques: unloading, prevention, or interference. Let’s walk through exam-
ples of each to demonstrate how we can use them to our advantage.
Unloading
The first technique is to completely unload the minifilter. While you’ll need 
administrator access to do this (specifically, the SeLoadDriverPrivilege token 
privilege), it’s the most surefire way to evade the minifilter. After all, if the 
driver is no longer on the stack, it can’t capture events.
Unloading the minifilter can be as simple as calling fltmc.exe unload, but 
if the vendor has put a lot of effort into hiding the presence of their mini-
filter, it might require complex custom tooling. To explore this idea further, 
let’s target Sysmon, whose minifilter, SysmonDrv, is configured in the regis-
try, as shown in Listing 6-9.
Evading EDR (Early Access) © 2023 by Matt Hand
Filesystem Minifilter Drivers   119
PS > Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\SysmonDrv" | Select * 
-Exclude PS* | fl
Type  : 1
Start  : 0
ErrorControl : 1
ImagePath : SysmonDrv.sys
DisplayName : SysmonDrv
Description : System Monitor driver
PS > Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\SysmonDrv\Instances\
Sysmon Instance\" | Select * -Exclude PS* | fl
Altitude : 385201
Flags : 0
Listing 6-9: Using PowerShell to view SysmonDrv’s configuration
By default, SysmonDrv has the altitude 385201, and we can easily 
unload it via a call to fltmc.exe unload SysmonDrv, assuming the caller has 
the required privilege. Doing so would create a FilterManager event ID of 1, 
which indicates that a filesystem filter was unloaded, and a Sysmon event ID 
of 255, which indicates a driver communication failure. However, Sysmon 
will no longer receive events.
To complicate this process for attackers, the minifilter sometimes uses 
a random service name to conceal its presence on the system. In the case of 
Sysmon, an administrator can implement this approach during installation 
by passing the -d flag to the installer and specifying a new name. This pre-
vents an attacker from using the built-in fltmc.exe utility unless they can also 
identify the service name.
However, an attacker can abuse another feature of production mini-
filters to locate the driver and unload it: their altitudes. Because Microsoft 
reserves specific altitudes for certain vendors, an attacker can learn these 
values and then simply walk the registry or use fltlib!FilterFindNext() to 
locate any driver with the altitude in question. We can’t use fltmc.exe to 
unload minifilters based on an altitude, but we can either resolve the driver’s 
name in the registry or pass the minifilter’s name to fltlib!FilterUnload() for 
tooling that makes use of fltlib!FilterFindNext(). This is how the Shhmon 
tool, which hunts and unloads SysmonDrv, works under the hood.
Defenders could further thwart attackers by modifying the minifilter’s 
altitude. This isn’t recommended in production applications, however, 
because another application might already be using the chosen value. EDR 
agents sometimes operate across millions of devices, raising the odds of 
an altitude collision. To mitigate this risk, a vendor might compile a list of 
active minifilter allocations from Microsoft and choose one not already in 
use, although this strategy isn’t bulletproof.
In the case of Sysmon, defenders could either patch the installer to 
set the altitude value in the registry to a different value upon installation 
or manually change the altitude after installation by directly modifying 
the registry value. Since Windows doesn’t place any technical controls on 
Evading EDR (Early Access) © 2023 by Matt Hand
120   Chapter 6
altitudes, the engineer could move SysmonDrv to any altitude they wish. 
Bear in mind, however, that the altitude affects the minifilter’s position in 
the stack, so choosing too low a value could have unintended implications 
for the efficacy of the tool.
Even with all these obfuscation methods applied an attacker could 
still unload a minifilter. Starting in Windows 10, both the vendor and 
Microsoft must sign a production driver before it can be loaded onto 
the system, and because these signatures are meant to identify the driv-
ers, they include information about the vendor that signed them. This 
information is often enough to tip an adversary off to the presence of the 
target minifilter. In practice, the attacker could walk the registry or use 
the fltlib!FilterFindNext() approach to enumerate minifilters, extract 
the path to the driver on disk, and parse the digital signatures of all 
enumerated files until they’ve identified a file signed by an EDR. At that 
point, they can unload the minifilter using one of the previously covered 
methods.
As you’ve just learned, there are no particularly great ways to hide a 
minifilter on the system. This doesn’t mean, however, that these obfusca-
tions aren’t worthwhile. An attacker might lack the tooling or knowledge 
to counter the obfuscations, providing time for the EDR’s sensors to detect 
their activity without interference.
Prevention
To prevent filesystem operations from ever passing through an EDR’s 
minifilter, attackers can register their own minifilter and use it to force the 
completion of I/O operations. As an example, let’s register a malicious pre-
operation callback for IRP_MJ_WRITE requests, as shown in Listing 6-10.
PFLT_PRE_OPERATION_CALLBACK EvilPreWriteCallback;
FLT_PREOP_CALLBACK_STATUS EvilPreWriteCallback(
 [in, out] PFLT_CALLBACK_DATA Data,
 [in] PCFLT_RELATED_OBJECTS FltObjects,
 [out] PVOID *CompletionContext
)
{
}
Listing 6-10: Registering a malicious pre-operation callback routine
When the filter manager invokes this callback routine, it must return 
an FLT_PREOP_CALLBACK_STATUS value. One of the possible values, FLT_PREOP 
_COMPLETE, tells the filter manager that the current minifilter is in the pro-
cess of completing the request, so the request shouldn’t be passed to any 
minifilters below the current altitude. If a minifilter returns this value, it 
must set the NTSTATUS value in the Status member of the I/O status block to 
the operation’s final status. Antivirus engines whose minifilters communi-
cate with user-mode scanning engines commonly use this functionality to 
Evading EDR (Early Access) © 2023 by Matt Hand
Filesystem Minifilter Drivers   121
determine whether malicious content is being written to a file. If the scan-
ner indicates to the minifilter that the content is malicious, the minifilter 
completes the request and returns a failure status, such as STATUS_VIRUS 
_INFECTED, to the caller.
But attackers can abuse this feature of minifilters to prevent the secu-
rity agent from ever intercepting their filesystem operations. Using the ear-
lier callback we registered, this would look something like what’s shown in 
Listing 6-11.
FLT_PREOP_CALLBACK_STATUS EvilPreWriteCallback(
 [in, out] PFLT_CALLBACK_DATA Data,
 [in] PCFLT_RELATED_OBJECTS FltObjects,
 [out] PVOID *CompletionContext
)
{
 --snip--
 if (IsThisMyEvilProcess(PsGetCurrentProcessId())
 {
--snip--
1 Data->IoStatus.Status = STATUS_SUCCESS;
return FLT_PREOP_COMPLETE
 }
   --snip--
}
Listing 6-11: Intercepting write operations and forcing their completion
The attacker first inserts their malicious minifilter at an altitude higher 
than the minifilter belonging to the EDR. Inside the malicious minifilter’s 
pre-operation callback would exist logic to complete the I/O requests com-
ing from the adversary’s processes in user mode 1, preventing them from 
being passed down the stack to the EDR.
Interference
A final evasion technique, interference, is built around the fact that a mini-
filter can alter members of the FLT_CALLBACK_DATA structure passed to its call-
backs on a request. An attacker can modify any members of this structure 
except the RequestorMode and Thread members. This includes the file pointer 
in the FLT_IO_PARAMETER_BLOCK structure’s TargetFileObject member. The only 
requirement of the malicious minifilter is that it calls fltmgr!FltSetCallback 
DataDirty(), which indicates that the callback data structure has been mod-
ified when it is passing the request to minifilters lower in the stack.
An adversary can abuse this behavior to pass bogus data to the mini-
filter associated with an EDR by inserting itself anywhere above it in the 
stack, modifying the data tied to the request and passing control back to 
the filter manager. A minifilter that receives the modified request may 
evaluate whether FLTFL_CALLBACK_DATA_DIRTY, which is set by fltmgr!FltSet 
CallbackDataDirty(), is present and act accordingly, but the data will still 
be modified.
Evading EDR (Early Access) © 2023 by Matt Hand
122   Chapter 6
Conclusion
Minifilters are the de facto standard for monitoring filesystem activity on 
Windows, whether it be for NTFS, named pipes, or even mailslots. Their 
implementation is somewhat more complex than the drivers discussed ear-
lier in this book, but the way they work is very similar; they sit inline of some 
system operation and receive data about the activity. Attackers can evade 
minifilters by abusing some logical issue in the sensor or even unloading 
the driver entirely, but most adversaries have adapted their tradecraft to 
drastically limit creating new artifacts on disk to reduce the chances of a 
minifilter picking up their activity.
Evading EDR (Early Access) © 2023 by Matt Hand
Sometimes an EDR must implement its 
own sensor to capture the telemetry data 
generated by certain system components. 
Filesystem minifilters are one example of this. 
In Windows, the network stack is no different.
A host-based security agent might wish to capture network telemetry 
for many reasons. Network traffic is the most common way for an attacker 
to gain initial access to a system (for example, when a user visits a malicious 
website). It’s also how they tend to perform lateral movement to jump from 
one host to another. If an endpoint security product wishes to capture and 
perform inspection on network packets, it’ll most likely implement some 
type of network filter driver.
This chapter covers one of the most common driver frameworks used 
to capture network telemetry: Windows Filtering Platform (WFP). The 
Windows network stack and driver ecosystem can be a little overwhelm-
ing for newcomers, so to reduce the likelihood of headaches, we’ll briefly 
introduce core concepts and then focus only on the elements relevant to an 
EDR’s sensor.
7
N E T WOR K F ILT E R DR I V E R S
Evading EDR (Early Access) © 2023 by Matt Hand
124   Chapter 7
Network-Based vs. Endpoint-Based Monitoring
You might assume that the best way to detect malicious traffic is to use a 
network-based security appliance, but this isn’t always the case. The effi-
cacy of these network appliances depends on their position in the network. 
For example, a network intrusion detection system (NIDS) would need to 
sit between host A and host B in order to detect lateral movement between 
the two.
Imagine that the adversary must cross core network boundaries (for 
example, to move from the VPN subnet into the data-center subnet). In those 
situations, the security engineers can strategically deploy the appliance at a 
logical choke point through which all that traffic must flow. This boundary-
oriented architecture would look similar to the one shown in Figure 7-1.
Host 1
Host 2
Host 3
Host A
Host B
Host C
Net 2
Net 1
NIDS
Figure 7-1: A NIDS between two networks
But what about intra-subnet lateral movement, such as movement from 
workstation to workstation? It wouldn’t be cost-effective to deploy a network-
monitoring appliance between every node on the local network, but secu-
rity organizations still need that telemetry to detect adversarial activities in 
their networks.
This is where an endpoint-based traffic-monitoring sensor comes into 
play. By deploying a monitoring sensor on every client, a security team can 
solve the problem of where in the network to insert their appliance. After 
all, if the sensor is monitoring traffic on a client, as shown in Figure 7-2, it 
effectively has a man-in-the-middle relationship between the client and all 
other systems the client may communicate with.
Host 1
Net 1
Endpoint
monitor
Host 2
Endpoint
monitor
Figure 7-2: Endpoint network monitoring
Evading EDR (Early Access) © 2023 by Matt Hand
Network Filter Drivers   125
Using endpoint-based monitoring offers another valuable advantage 
over network-based solutions: context. Because the agent running on the 
endpoint can collect additional host-based information, it can paint a 
more complete picture of how and why the network traffic was created. 
For example, it could determine that a child process of outlook.exe with a 
certain PID is communicating with a content distribution network end-
point once every 60 seconds; this might be command-and-control beacon-
ing from a process tied to initial access.
The host-based sensor can get data related to the originating process, 
user context, and activities that occurred before the connection happened. 
By contrast, an appliance deployed on the network would be able to see 
only the metrics about the connection, such as its source and destina-
tion, packet frequency, and protocol. While this can provide valuable data 
to responders, it misses key pieces of information that would aid their 
investigation.
Legacy Network Driver Interface Specification  
Network Filters
There are many types of network drivers, most of which are backed by 
the Network Driver Interface Specification (NDIS). NDIS is a library that 
abstracts a device’s network hardware. It also defines a standard interface 
between layered network drivers (those operating at different network layers 
and levels of the operating system) and maintains state information. NDIS 
supports four types of drivers:
Miniport  Manages a network interface card, such as by sending and 
receiving data. This is the lowest level of NDIS drivers.
Protocol  Implements a transport protocol stack, such as TCP/IP. This 
is the highest level of NDIS drivers.
Filter  Sits between miniport and protocol drivers to monitor and 
modify the interactions between the two subtypes.
Intermediate  Sits between miniport and protocol drivers to expose 
both drivers’ entry points for communicating requests. These drivers 
expose a virtual adapter to which the protocol driver sends its packets. 
The intermediate driver then ships these packets to the appropriate 
miniport. After the miniport completes its operation, the intermediate 
driver passes the information back to the protocol driver. These drivers 
are commonly used for load-balancing traffic across more than one net-
work interface card.
The interactions of these drivers with NDIS can be seen in the (grossly 
oversimplified) diagram in Figure 7-3.
For the purposes of security monitoring, filter drivers work best, as 
they can catch network traffic at the lowest levels of the network stack, just 
before it is passed to the miniport and associated network interface card. 
However, these drivers pose some challenges, such as significant code 
Evading EDR (Early Access) © 2023 by Matt Hand
126   Chapter 7
complexity, limited support for the network and transport layers, and a dif-
ficult installation process.
But perhaps the biggest issue with filter drivers when it comes to secu-
rity monitoring is their lack of context. While they can capture the traf-
fic being processed, they aren’t aware of the caller context (the process 
that initiated the request) and lack the metadata needed to provide valu-
able telemetry to the EDR agent. For this reason, EDRs nearly always use 
another framework: the Windows Filtering Platform (WFP).
The Windows Filtering Platform
WFP is a set of APIs and services for creating network-filtering applica-
tions, and it includes both user-mode and kernel-mode components. It 
was designed to replace legacy filtering technologies, including the NDIS 
filters, starting in Windows Vista and Server 2008. While WFP has some 
downsides when it comes to network performance, it is generally consid-
ered the best option for creating filter drivers. Even the Windows firewall 
itself is built on WFP.
The platform offers numerous benefits. It allows EDRs to filter traffic 
related to specific applications, users, connections, network interface cards, 
and ports. It supports both IPv4 and IPv6, provides boot-time security until 
the base filtering engine has started, and lets drivers filter, modify, and 
reinject traffic. It can also process pre- and post-decryption IPsec packets 
and integrates hardware offloading, allowing filter drivers to use hardware 
for packet inspection.
WFP’s implementation can be tricky to understand, as it has a complex 
architecture and uses unique names for its core components, which are 
distributed across both user mode and kernel mode. The WFP architecture 
looks something like what is shown in Figure 7-4.
To make sense of all this, let’s follow part of a TCP stream coming from 
a client connected to a server on the internet. The client begins by calling 
a function such as WS2_32!send() or WS2_32!WSASend() to send data over a con-
nected socket. These functions eventually pass the packet down to the net-
work stack provided by tcpip.sys for IPv4 and tcpip6.sys for IPv6.
As the packet traverses the network stack, it is passed to a shim associ-
ated with the relevant layer of the stack, such as the stream layer. Shims 
are kernel components that have a few critical jobs. One of their first 
NDIS
Protocol
drivers
Filter
drivers
Intermediate
drivers
Miniport
drivers
Client
application
Service
provider
interface
NIC
Figure 7-3: NDIS driver relationships
Evading EDR (Early Access) © 2023 by Matt Hand
Network Filter Drivers   127
responsibilities is to extract data and properties from the packet and pass 
them to the filter engine to start the process of applying filters.
The Filter Engine
The filter engine, sometimes called the generic filter engine to avoid confu-
sion with the user-mode base filtering engine, performs filtering at the net-
work and transport layers. It contains layers of its own, which are containers 
used to organize filters into sets. Each of these layers, defined as GUIDs 
under the hood, has a schema that says what types of filters may be added 
to it. Layers may be further divided into sublayers that manage filtering 
conflicts. (For example, imagine that the rules “open port 1028” and “block 
all ports greater than 1024” were configured on the same host.) All layers 
inherit default sublayers, and developers can add their own.
Filter Arbitration
You might be wondering how the filter engine knows the order in which to 
evaluate sublayers and filters. If rules were applied to traffic in a random 
order, this could cause huge problems. For example, say the first rule was a 
default-deny that dropped all traffic. To address this problem, both sublay-