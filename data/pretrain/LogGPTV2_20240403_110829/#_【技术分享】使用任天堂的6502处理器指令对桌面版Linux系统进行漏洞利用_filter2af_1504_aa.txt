# 【技术分享】使用任天堂的6502处理器指令对桌面版Linux系统进行漏洞利用
|
##### 译文声明
本文是翻译文章，文章来源：scarybeastsecurity.blogspot.com
原文地址：[ https://scarybeastsecurity.blogspot.com/2016/11/0day-exploit-compromising-linux-desktop.html](
https://scarybeastsecurity.blogspot.com/2016/11/0day-exploit-compromising-linux-desktop.html)
译文仅供参考，具体内容表达以及含义原文为准。
****
****
**翻译：**[ **babyimonfire**
****](http://bobao.360.cn/member/contribute?uid=2815007941)
**预估稿费：260RMB**
******投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿******
**  
**
**概览**
gstreamer 0.10.x
播放器在播放NSF格式的音乐文件的时候，存在一个漏洞和单独的逻辑错误。两者结合，可以实现非常稳定的漏洞利用方法，并且能过绕过64位ASLR，DEP等等。所谓的稳定是因为该音乐播放器里提供一个图灵完备的“脚本语言”。[NSF文件](https://en.wikipedia.org/wiki/NES_Sound_Format)是任天堂游戏机中的音乐文件。有意思吧？那就继续往下看。。。
**漏洞演示及受影响的发行版本**
下图是触发该漏洞的一个截图。比较让人揪心的是，漏洞触发不需要用户打开恶意文件——只需要打开恶意文件所在位置，就可实现。下面有更多内容。
你可以从exploit_ubuntu_12.04.5_xcalc.nsf下载这个文件。在上图中，文件被重命名为“time_bomb.mp3”，下面我们会解释为什么要这么做。
从文件名中可以看出，这个漏洞可以在Ubuntu
12.04.5下进行利用。这是一个较老但仍然有官方支持的发行版本。此外，在重现漏洞方面，该PoC可在未进行相关更新的Ubuntu
12.04.5下直接执行。如果你进行了全部更新，会安装一个新版本的glibc，而里面一些代码的偏移量发生了改变，因此该PoC一定会失效崩溃，但仍然可以通过编写新的PoC代码实现适配任意版本的glibc。这项工作就留给读者当做练习了。
漏洞存在于gstreamer-0.10版本的一个音频解码器libgstnsf.so里。Ubuntu
12.04使用gstreamer-0.10处理所有音频处理需求。而Ubuntu
14.04显然也受到该漏洞的影响，因为gstreamer-0.10是默认安装的，但大部分多媒体软件使用同样被安装的gstreamer-1.0进行相关的处理。目前还不清楚Ubuntu
14.04中何时使用存在漏洞的gstreamer-0.10进行媒体处理的具体情况。Ubuntu
16.04默认只安装了gstreamer-1.0，因此不受此漏洞的影响。
这个漏洞存在于所谓的“默认”安装。在Ubuntu系统安装时，会有出现一个提示信息：“hey, do you want mp3s to
work?”，当然，正确答案是“yes”。随后许多额外的包，包括gstreamer0.10-plugins-bad就被安装了，而其中就包含了libgstnsf.so。
等等，你说什么？0day？还有PoC？
是的，0day。
作为一个学习实验，我未来公开的大部分漏洞都会是0day。我在参与所谓的“协作公开”中获得了大量经验，即让收到漏洞预警的厂商花费他们需要的时长进行修复（为了让苹果公司修复一个Safari浏览器漏洞，我曾经等了一年！）而在“全面公开”方面，即厂商和公众同时获取到漏洞的细节，我明显缺乏更多的经验。声明一点，我非常确定在“协作公开”和“全面公开”上的正确平衡就是在两者之间做出妥协。Project
Zero的90天期限策略似乎能较好地实现这个妥协，并且有很多的数据可以支持这一策略。
不要担心，这个0day并不严重，只影响到非常老的Linux发行版本（见上述）。这个0day更多的是好玩而不是影响。未来的0day影响可能才会更加广泛。;-)
**  
**
**关于0day的哲学问题**
如果补丁和0day同时发布，那还能算是0day么？下面就是针对Ubuntu 12.04的补丁：
    sudo rm /usr/lib/x86_64-linux-gnu/gstreamer-0.10/libgstnsf.so
第一眼的话，这个“补丁”似乎是直接删掉了这个功能，其实不是。你的NSF文件仍然能够播放。WTF？你能相信Ubuntu
12和14为了播放NSF文件都装载了两个不同的代码库么？为一个很少见的格式配备的那么多播放器似乎显得多余。第二个NSF播放器基于libgme，并且没有像第一个播放器那样存在该漏洞。
**攻击面**
这个漏洞利用了gstreamer-0.10中播放NSF音乐文件的插件。这些NSF音乐文件跟其他大多数能在系统上播放的音乐文件不一样。典型的音乐文件是基于数学计算进行压缩和解码的，但是NSF音乐文件却是通过实时模拟任天堂（NES）CPU和音频硬件来播放的，厉害了！gstreamer插件创建了一个虚拟的6502
CPU硬件环境，然后通过在一段时间里运行一些6502指令，再到虚拟出的音频硬件寄存器中找到指令运行的结果，基于这个方法，实现音频的播放。
如果你对真正播放一个NSF文件感兴趣的话，可以下载这个文件：cv2.nsf，这是游戏恶魔城2中的音频文件，你还可以通过谷歌“nsf music
files”等关键字，很容易就能找出类似的音频文件。如果你的桌面版Linux支持NSF文件，你就应该能通过执行一些命令实现播放，例如“totem
cv2.nsf”。（如果不支持的话，你的Linux系统可能会自动安装一个合适的插件进行播放。）这个文件只有17264字节，对于文件中包含的音频数量来说，文件占用空间显得太小了，不足以存放那些内容，但是这个大小却足以容纳一些小程序通过向基本的NES硬件发出序列请求，从而发出一系列简单的声音。
**实现这个漏洞利用，有多种精巧而不同的方法：**
通过邮件附件形式发送。如果目标用户下载并打开了附件，就遭到了该攻击。注意，为了让恶意文件正常执行，你可能需要重命名exploit.nsf为exploit.mp3。因为大多数桌面版Linux系统无法识别NSF文件类型，但却会把MP3文件的字节序列传递给媒体播放器。大部分基于gstreamer的播放器都会忽略文件的后缀名，而使用自动检测出的文件格式选择合适的解码器。
依靠部分路过式下载。利用谷歌Chrome浏览器文件下载的UX（用户体验），当访问一个陷阱网页时，有可能将该恶意文件直接转储到目标用户的下载文件夹中。而当之后通过文件管理器（例如nautilus）浏览到该下载文件夹时，系统会自动尝试为已知后缀名的文件生成缩略图（所以，需要将恶意NSF文件后缀名改为.mp3）。而为恶意NSF文件生成缩略图时，会触发该漏洞。
依靠完整路过式下载。还是利用谷歌Chrome浏览器的下载UX，有一种方法可以利用完整的路过式下载实现漏洞利用，具体方法会在另外一篇博文中描述。
基于USB设备进行。打开USB存储设备时，仍然会自动生成已知后缀名文件的缩略图，同上。
**6502 CPU介绍和任天堂ROM加载以及分页崩溃过程**
6502 CPU本身是一个传奇，同时被大量也堪称传奇的系统所使用，如任天堂，Commodore 64，BBC
Micro等。这是一个8位的CPU，但是有着16位寻址能力，并且拥有64kB的地址空间。在任天堂应用中，高32kB的地址空间（0x8000 –
0xffff）保留给了ROM，即插入的游戏卡中的只读数据。
现在有个有趣的问题：如果你想制作一个大于32kB的游戏该怎么办？
例如，你有一个16关的游戏，每一关都有16kB大小的视频和音频数据。那么32kB的空间是不可能放得下的。为了解决这个问题，便出现了“库（bank）”和“库切换（banks
switching）”的概念。所谓库，就是ROM上一块对齐、连续的4kB区域。一共有8个库，分布在6502地址0x8000 –
0xffff上。每个库都可以映射为游戏卡ROM（可以远大于32kB）上一个连续、对齐的4kB区域。在运行时，任天堂程序可以对魔法内存（magic
memory）位置（0x5ff8 – 0x5fff）进行写操作。这一位置包含控制将ROM中哪一部分映射到哪个库中的硬件寄存器。
例如：如果6502 CPU向0x5ff9写入数值10，那么6502内存位置0x9000 –
0x9fff就会被映射为游戏卡ROM中的索引（10*4096）处。
**漏洞**
1：在映射到6502内存和库切换时，缺少对ROM大小的检查（此处没有CVE，可以当做是CESA-2016-0001。）
在提到的ROM映射上，几乎是完全没有边界检查。不仅是初始加载ROM时是这样，后续的一系列库切换操作同样没有边界检查。所有对ROM映射的处理都在gst-plugins-bad/gst/nsf.c，包括：
    nsf_bankswitch (uint32 address, uint8 value)
    {
      ...
      cpu_page = address & 0x0F;
      roffset = -(cur_nsf->load_addr & 0x0FFF) + ((int) value data + roffset;