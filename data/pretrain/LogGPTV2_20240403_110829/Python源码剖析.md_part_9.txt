---
## Page 65
2.2.2
译出新的Python来。
供的这种方法非常原始，为了达到动态调整的目的，你只有自已修改源代码，然后重新编
应该有多少个小整数对象。咂，但是，老实说，坏消息可能会打击你的积极性，Pyhon提
过这种方法，用户可以调整小整数与大整数的分界点，从而动态确定小整数对象池中到底
在哪里？Pyhon的回答是：你的地盘你做主，你想这个分界点在哪里它就在哪里。
大的喜讯，即对象池里的每一个PyIntobjecE对象都能够被任意地共享。
了对象池技术。刚才我们说了，PyIntobject对象是不可变对象，这个信息预示着一个天
造成大量的内存碎片，严重影响Python的整体性能。
并且不厌其烦地一次次free。这样的操作不仅大大降低了运行效率，而且会在系统堆上
对于这些频繁使用的小整数对象，Pyhon将一次又一次地使用ma11oc在堆上申请空间，
场合。在Pyhon中，所有的对象都存活在系统堆上。这就是说，如果没有特殊的机制，
地使用。想一想C语言中的for循环，就可以了解为什么这些小整数会有那么频繁的使用
Python中整数对象系统的结构。
并不是独立存在，单兵作战的，而是形成了一个整数对象系统。我们首先就重点考察一下
对象在内存中的组织方式。前面我们已经提到，在运行期间，
Pyobject*
[intobject.c]
小整数对象
现在，我们有一个好消息和一个坏消息。好消息是，Pyhon确实提供了一种方法，通
显然，Guido是决不能容许这样的方案存在的，于是在Python中，对小整数对象使用
在实际的编程中，数值比较小的整数，比如1、2、29等，可能在程序中会非常频繁
为了深刻地理解PyIntobject对象的创建过程，首先必须要深入了解Pyhon中整数
return PyInt_FromLong(x);
else
long x:
将字符串转换为1ong值
char
x=Pyos_strtol（s，&end,base）
x=(long) Pyos_strtoul（s,kend,base）;
end;
PyInt_FromString(char *s,char **pend, int base)
2.2PylntObject 对象的创建和维护
Python源码剖析
一个个的整数对象在内存中
深度探素动态语言核心技术
---
## Page 66
Python源码剖析
2.2.3
36
之苦，又在一定程度上考虑了效率问题。下面将详细剖析其实现机制。
由这些大整数轮流使用，也就是说，谁需要的时候谁就使用。这样免去了不断地malloc
PyIntobject对象。而对其他整数，Python运行环境将提供一块内存空间，这些内存空间
域最基本的矛盾就在这里浮出水面了。
便胆大如牛者，也不敢在内存使用上出此下策吧。时间与空间的两难选择，这个计算机领
被视为败家子的，难免遭人鄙视。开放源码是放在公共空间供无数人检阅批判的，恐怕即
PyIntobject对象都缓存在内存池中，自然是再理想不过了，但是这样对内存的使用是会
常多的东西，谁敢拍胸脯保证只有小整数才会被频繁地使用呢。如果将所有的整数对应的
struct
#detine
[intobject.c]
表。
其指针存放在smal1_ints中。那么对于大整数呢？很显然，整数对象是编程中使用得非
重新编译Pyhon，从而将这个范围向两端伸展或收缩。
合的范围默认设定为[-5，257）。但是你完全可以修改NSMALLPOSINTS和NSMALLNEGINTS，
池，不过没有关系，我们就打算以小整数对象池来称呼它。在Python2.5中，将小整数集
Smal1_ints就是举足轻重的小整数对象的对象池，准确地说，应该是一个pyIntobject*
#define
#endif
#ifNSMALLNEGINTS+NSMALLPOSINTSO
#IfndeE NSMALLNEGINTS
#endlf
#endif
[intobject.c]
在Python中，有一个PyIntBlock结构，在这个结构的基础上，实现了的一个单向列
PyIntoblect obJectsIN_INTOBJEcrsl
Pyton的设计者们所做出的妥协是，对于小整数，在小整数对象池中完全地缓存其
大整数对象
对于小整数对象，Python直接将这些整数对应的pyIntobject缓存在内存中，并将
第2章
“大隐隐于市，小隐隐于野”，在intobject.c超过1000行的代码中，这个毫不起眼的
static PyIntObject small_intsINSMALLNEGINTS +NSMALLPOSINTSI:
#define:NSMALLNEGINTS
#define NSMALuPOSTNTS
_intblock（
N_INTOBJECTS
一深度探索动态语言核心技术
Python中的整数对象
OCK_SIZE
0001
((BLOCK_SIZE-BHEAD_SIZE)/sizeof（PyIntObject))
257
for
a
---
## Page 67
2.2.4
1主st。当然，最开始的时候，这两个指针都被设置为空指针，如图2-3所示。
表来管理全部block的objects中所有的空闲内存，这个自由内存链表的表头就是free
存来存储新的PyIntobject对象时，才能快速获得所需的内存。Python使用一个单向链
些内存则处于空闲状态。这些空闲状态的内存必须组织起来，这样，Pyhon在需要新的内
在Pyhon运行的某个时刻，某个block的objects中，有一些内存已经被使用了，而另一
设计者留给你的可以动态调整的地方，不过，你需要再一次地修改源代码并重新编译。
BJECTS个对象，做一个简单的计算，就可以知道是82个。显然，这个地方也是Pyhon的
表示free_list。
PyIntObject对象。从PyIntBlock的定义中可以看到，在一个PyIntBlock中维护着N_INTO
对象是如何从无到有地产生，并融入到Python的整数对象系统中的（见代码清单2-2）。
下面我们将通过对PyInt_FromLong进行细致入微的考察，真实地展现一个个pyIntobject
数组一
static PyIntobject free_list= Nuubz
Cypedef stauct_intblock PylatBlock,
代码清单2-2
[intobject.c]
添加和删除
PylntBlock，顾名思义，就是说这个结构里维护了一块内存（block），其中保存了一些
好了，现在大体上可以想象Pyhon中整数对象系统在内存中是一种怎样的结构了。
注：在此后的图示中，我们将统一用实线菱尾箭头表示block_list：虚线菱尾箭头
register PyIntobiect
objects，这就是真正用于存储被缓存的PyIntObject对象的内存。可以想象，
return (PyObject*）V
V=small
：尝试使用小整数对象池
NCREF(V)
图2-3free_list和block_list的初始状态
block list
free_list
+NSMALINEGINTSI;
2.2PylntObject对象的创建和维护
Python源码剖析
NSMAILPOSINTS)(
NULL
一深度探索动态语言核心技术
---
## Page 68
Python源码剖析
2.2.4.2
2.2.4.1
static Pyintobject*fill_free_Iist (void)
[intobject.c]
代码清单2-3
的调用。
free_1ist变为NULL，从而在下一次PyInt_FromLong的调用时激发对Ei11_free_1ist
的首次调用时，在Python运行期间，只要所有block的空闲内存被都使用完了，就会导致
存。需要注意的是，Python对fi11_Eree_list的调用不光会发生在对pyInt_FromLong
代码清单2-2的[21处调用fi11_Eree_list，创建新的block，从而也就创建了新的空闲内
任就落在了free_list身上。
块block的objects中，寻找一块可用于存储新的pyIntobject对象的内存，于是，重
会转向由block_1ist维护的通用整数对象池。正如前面我们所描述的，Python需要在某
池中的对应的对象就可以了。
属于小整数的范围，如果确实属于小整数，一切就变得简单了，只需要返回在小整数对象
池机制被激活了，PyInt_FromLong会首先在代码清单2-2的[1]处检查传入的long值是否
#endif
如果小整数对象池机制没有被激活，或者传入的long值不是属于小整数，Python就
创建通用整数对象池
如果NSMALLNEGINTS+NSMALLPOSINTS>O成立，那么Python认为小整数对象
使用小整数对象池
如果不能使用小整数对象池，则使用通用的整数对象池。
如果小整数对象池机制被激活，则尝试使用小整数对象池；
PyIntobject对象的创建通过两步完成：
第2章Python中的整数对象
return (Pyobjeet *)v;
PyObject_INIr(v.
1/[3]:(inline）内联Pyobject_New的行为
/7[2]：为通用整数对象池申请新的内存空间
free_
if
一深度探索动态语言核心技术
(bree
(Pyintobject
&PyInt_Type);
fin1_freeIist（）==NULE)
*)v->ob_type;
---
## Page 69
PyIntBlock中的所有空闲的为PyIntobject准备的内存了。
在它该出现的位置了。从free_list开始，沿着ob_type指针，就可以遍历刚刚创建的
头展示了[2]开始时p和g的初始状态。可以看到，当链表转换完成之后，ree_1ist也
指针。可以看到，Python的设计者为了解决问题，在某个局部点，放弃了对类型安全的坚
始链接的过程，在整个链接过程中，Python使用了Pyobject中的obtype指针作为连接
向链表，这就是代码清单2-3的[2]处的行为。Python从objects数组的最后一个元素开
将objects中的所有PyIntobject对象通过指针依次连接起来，从而将数组转变成一个单
如图2-4所示：
，如同政治一样，程序的开发也是一门妥协的艺术。
图2-5展示了代码清单2-3的[2]处的链表转换动作完成之后的block，其中用虚线箭
这时block中的objects还仅仅是一个PyIntObject对象的数组，接下来，Pyhon
注：图中的虚线并不表示指针关系，虚线表示objects的更详细的表示方式，下同。
在Fi11_free_list中，会首先在代码清单2-3的[1]处申请一个新的PylntBlock结构，
block_list
PyIntobjedtp.
((PyIntBlock
q->ob_type
人--
N_INTOBJECTS;
NUIL:
*)p)->next=block_1ist;
图2-5
objects
next
objects
nixt
图2-4
完成链表转换过程后的PyIntBlock
PyintBlock的内存布局
1
NULL
2.2
Python源码剖析
NINTOBJECTS个PyIntObjeet
PylntObject对象的创建和维护
-obiects-
一深度探索动态语言核心技术
一转变成单向链表
8
---
## Page 70
Python源码剖析
2.2.4.3
系。实际上，不同PylntBlock对象的objects中的空闲内存块是被链接在一起的，形成了
对象间的objects没有任何联系，显然不可能实现这样的功能，所以它们之间一定存在联
区别了。
中的这块内存。倘若不然，就意味着所有的内存只能使用一次，这跟内存泄漏也就没什么
中出现了一块空闲的内存，那么下次创建新的pyIntobject对象时应该使用pyIntBlock1
PyIntBlock1.objects中的一个PyIntobject 对象被删除了，这意味着PyIntBlock1
所以现在free_list指针指向的是PyIntBiock2.objects中空闲的内存块。假设现在
objects已经被PyIntobject对象填满，而pyIntBlock2种的object只填充了一部分。
考虑这样的情况：
中至关重要的存放PyIntobject对象的objects却是分离的。这样的结构存在着隐惠，
list指针，使其指向下一块还没有被使用的内存。
同时，还会对PyIntobject对象完成必要的初始化工作。当然，Python还将调整free
维护的自由内存链表中划出一块，并在这块内存上创建所需要的新的ryTntobjeat对象，
一个单向链表，指向表头的指针正是free_l1st。
维护的链表的情况。值得注意的是，block_list始终是指向最新创建的PylntBlock对象。
代码清单2-3的[1]处完成。作为一个例子，图2-6显示了两次申请block后b1ock_1st所
然，这里新创建的block也必须加入到biock_1ist所维护的链表中，这个链入的动作在
间，为新的PyIntobject创造新的家园。
block中的内存都被占用了，PyInt_FromLong才会再次调用fil1_free_list申请新的空
指向NULL。所以在这种情况下调用PyInt_FromLong不会申请新的block。只有在所有
如何才能使Pyhon意识到这块重获自由的内存呢？如果像图2-6所示的PyIntBlock
现在有两个PyIntBlock 对象，PyIntBlock1和PyIntBlock2，PyIntBlocki 中的
在图2-6中我们发现，两个PylntBlock处于同一个链表当中，但是每一个PyIntBlock
在PyIntFromLong中，在必要的空间被申请之后，Pyhon会从当前由free_list所
使用通用整数对象池
当一个block中还有剩余的内存没有被一个pyIntobect古用时，free_list就不会
第2章Python中的整数对象
前面我们提到，Python是通过biock_list来维护整个整数对象的通用对象池的。显
一深度探索动态语言核心技术
图2-6PylntBlock的链表
objects
next
objects
next
---
## Page 71
同对象在销毁时会进行不同的动作，销毁动作在与对象对应的类型对象中被定义，这个关
意味着这个世上再也没有谁需要它了，于是Pyhon会负责将这个对象销毁。Pyhon中不
们已经看到，每一个对象都有一个引用计数与之相关联，当这个引用计数减少到0时，就
个pyIntobject对象在被销毁时都发生了什么事。在对Pyhon中对象机制的分析中，
生在一个pyIntobject对象被销毁的时候。
们的目的仅仅是为了展示通用整数对象池的动态变化，没有考虑2、3、4实际使用的内存。
创建2、3、4这样的整数对象，使用的实际上是sma11_ints这个小整数对象池，在这里我
PyIntobject对象以及free_list指针的变化情况。请注意，在Python的实际行为中，
PyIrntobject对象时发生的。如果删除的对象是一个整数的派生类的对象，那么
这么一个简单的指针维护的王作。当然，这些动作是在销毁的对象确实是一个
以Python应该将其链入了free_list所维护的自由内存链表。int_deal1oc完成的就是
这一块内存在整数对象被销毁后变为了自由内存，将来可供别的pyIntobject使用，所
销毁时，它所占有的内存并不会被释放，归还给系统，而是继续被Pyton保留着。但是
整数对象共同分享的。俗话说，皇帝轮流坐，明年到我家。当一个PyIntobject对象被
statie void Int_dealloc(PyIntobject *y)
键的操作就是类型对象中的tpdealloco
下面看一看PyIntobject对象的tp_dealloc操作：
在图2-7中我们相继创建和删除pyIntObject对象，并展示了这一过程中，内存中的
列位看官，花开两朵，各表一枝，这里我们先放下自由内存链表，仔细考察一下一
那么，不同PylntBlock中的空闲内存块是在什么时候被链接在一起的呢，这一切都发
在前面我们说了，由block_1ist维护的PyIntBlock链表中的内存实际是所有的大
else
v->ob_type->tp_free((pyobiect*)v):
(EyInt_CheckExact(v))
free_list
typeobject*)free_list;
2.2
Python源码剖析
PylntObject 对象的创建和维护
一深度探索动态语言核心技术
41
---
## Page 72
Python源码剖析
的整数对象，坦白说，这个值，对于希望利用这一实现漏洞的人来说，并不大。
题。其实很简单，不同ryIntBlock对象中空闲内存的互连也是在int_dealloc被调用时
是12个字节，假如系统有1GB内存，那么这1GB的内存仅仅可容纳从0到89478486
的内存全部吃光做一个简单的计算就可以看到这一点，一个PyIntobject对象的大小
共存的整数对象个数的最大值有关，但是，从理论上，我们仍然可以利用这一漏洞将系统
Pyton用于实现该对象池的内存与历史上创建的整数对象的个数无关，而仅仪与同一时刻
存泄漏极为相似，尽管从Pyhon的通用整数对象池的实现我们可以看到，由于内存共享
申请用于整数对象，那么这块内存在Pyhon结束之前，永远不会被释放。这听上去跟内
int_dealloc中，永远不会向系统堆交还任何内存。一旦系统堆中的某块内存被Python
正如图2-8所示，仅仅是将该整数对象的内存重新加入到自由内存链表中。也就是说，在
了，当一个整数对象的引用计数变为0时，就会被Pyhon回收，但是在int_dealloc中，
实现的。图2-8展示了这个过程（白色表示空闲内存）。
图2-8中隐藏着Python的整数对象系统实现中的一个惊天隐秘，细心的读者一定发现