protocol, this work applies the so-called Generalized-Selective-
Decryption (GSD) paradigm to UPKE. Specifically, we prove GSD
security of IND-CPA-secure UPKE in the random oracle model, by
first defining a GSD game that models UPKE based executions, in
the presence of bad randomness and group splitting attacks, and
then appropriately adapting the framework of [1]. The security of
RTreeKEM itself is established by reduction to the GSD security of
the underlying UPKE scheme. The safety predicate *CGKA-priv
considers the commit secret of an epoch vid secure if (informally)
the following conditions are satisfied: (1) There is no â€œcorruptedâ€
ancestor epoch in the history graph, where an epoch can be cor-
rupted if either a party gets added with leaked initial keys or if the
state of a party in the epoch is leaked; (2) no information about
vid is known to the attacker as the result of splitting the group (cf.
full version [4]); (3) good randomness was used by the commiter
creating vid. More details can be found in the full version [4].
TreeKEM is secure w.r.t. a weaker security predicate than RTreeKEM.
Namely, it is required that either there is no post-challenge compro-
mise (the notion of PCS in [3]), or if there is, compromise happens
after the party has already updated itâ€™s state (the FSU notion of [3]).
Then, security proof for TreeKEM is similar to that of RTreeKEM
and proceeds in two steps: first, we consider a reduction from GSD
for standard public-key encryption to the IND-CPA security of the
underlying scheme, and then we reduce the security of TreeKEM
to that of GSD.
4.2 Forward-Secure Group AEAD
FS-GAEAD schemes provide the convenient abstraction of an â€œepoch
of group messaging.â€ That is, they capture the sending and receiving
of application messages within a single epoch of a full SGM scheme.
In an execution of FS-GAEAD, all participating group members
are initialized with the same random group key (i.e., that key is
assumed to be generated and distributed among the group members
by the higher-level protocol).
An FS-GAEAD scheme protects the authenticity and privacy of
messages sent. Furthermore, it provides forward secrecy, i.e., the
security of messages received will not be affected by state compro-
mise. Note that FS-GAEAD is not required to provide any form
of post-compromise security, which allows to design completely
deterministic schemes (apart from the initial key).
Security definition. The security of FS-GAEAD is captured via a
corresponding game, in which ğ‘› parties share the same initial key.
The attacker can have parties send and receive messages arbitrarily,
ask for challenges, and leak the state of any party at any time. The
game keeps track of the entire execution, but crucially of which
messages have been received by which parties. When the state of
some party ID is leaked, the set of messages received by ID is stored:
these are the messages that must remain secure even given IDâ€™s
leaked state. This information is used by a safety predicate *FS-
sec to avoid trivial wins by A, be it w.r.t. privacy or authenticity.
More details can be found in Section B of the Appendix and the full
version [4].
Instantiation and security results. We show how to build FS-GAEAD
from a forward-secure key-derivation function (FS-KDF). An FS-KDF
keeps state ğ‘ â€”initially set to a uniformly random stringâ€”and, upon
request, derives keys corresponding to labels lab. After each such
request, the FS-KDF also updates its own state. For each initial state,
there a unique key corresponding to each label, irrespective of the
order in which the labels were queried. The FS-KDF is forward-
secret because even if its state is leaked, all keys output up to that
point remain secure. An FS-KDF itself can be obtained via a tree
construction based on a normal PRG.
Given an FS-KDF, the construction of FS-GAEAD is as follows:
messages and AD are encrypted/authenticated with a normal AEAD
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1472scheme, where the key for the ğ‘–th message by party ID is derived
using the label (ID, ğ‘–).
The safety predicate *FS-sec achieved by our construction con-
siders a message secure if no partyâ€™s state is leaked before it receives
the message. For more information see Section B of the Appendix
and the full version [4].
4.3 PRF-PRNGs
A PRF-PRNG resembles both a pseudo-random function (PRF) and
a pseudorandom number generator with input (PRNG)â€”hence the
name. On the one hand, as a PRNG would, a PRF-PRNG (1) repeat-
edly accepts inputs ğ¼ and context information ğ¶ and uses them to
refresh its state ğœ and (2) occasionally uses the state, provided it
has sufficient entropy, to derive a pseudo-random pair of output
ğ‘… and new state; for the purposes of secure messaging, it suffices
to combine properties (1) and (2) into a single procedure. On the
other hand, a PRF-PRNG can be used as a PRF in the sense that if
the state has high entropy, the answers to various pairs (ğ¼, ğ¶) on
the same state are indistinguishable from random and independent
values.
Security definition. The intuitive security properties for PRF-PRNGs
mentioned above must also hold in the presence of state compro-
mise. In particular, a PRF-PRNG must satisfy PCFS (cf. Section 3.2)
and deal with splitting (cf. Section C of the Appendix and the full
version [4]). Therefore, the security game for PRF-PRNGs follows
the same history-graph approach as the definitions of SGM and
CKGA. However, since the game only consists of the state of the
PRF-PRNG and there are no parties, it suffices to keep track of
a much smaller amount information. Formal definitions for PRF-
PRNGs are provided in Section C of the Appendix.
Instantiation and security results. The MLS protocol uses HKDF [22]
as PRF-PRNG. This work models HKDF as a random oracle and
shows that it achieves achieves security w.r.t. safety predicate *PP-
secure, which captures that in order for a value ğ‘… to be considered
secure in a particular epoch ğ‘’, (1) ğ‘’ must have an ancestor ğ‘’â€² (pos-
sibly itself) that was reached via a random input ğ¼ not known to
A, and (2) there must have been no corruptions on the path from
ğ‘’â€² to ğ‘’â€™s parent. More details can be found in the full version [4].
4.4 Plugging things together
The protocol is based on the following primitives: A CGKA scheme
K = (K-Gen-IK, K-Create, K-Add, K-Remove, K-Update, K-Commit,
K-Proc-Com, K-Join), an FS-GAEAD scheme F = (F-Init, F-Send,
F-Rcv), a CPA-secure public key encryption scheme PKE = (E-KeyGen,
E-Enc, E-Dec), an existentially unforgeable signature scheme S =
(S-KeyGen, S-Sign, S-Ver), a message authentication scheme M =
(M-Tag, M-Ver), a PRF-PRNG PP, a collision resistant hash function
H. The initialization and PKI algorithms of our construction are
depicted on Figure 6. The helper functions are formally presented
in the full version. Below we describe the main SGM algorithms
depicted on Figure 7, in which we use different colors to high-
light the use of the underlying primitives: CGKA, FS-GAEAD, PKE,
Signatures, MAC, PRF-PRNG, Hash.
Group creation. The group creation operation, Create, receives
(possibly bad) randomness ğ‘Ÿ, a signature verification key, spk, which
is the key that will be used by the group members to verify messages
sent by the group creator, as well as the welcome key material wpk.
It adds the group creatorâ€™s id to the roster (s.G â† [ME]), executes
the CGKA group creation operation, absorbs the output ğ¼ into the
PRF-PRNG PP. PP outputs the new PRF-RPNG state s.ğœ, the FS-
GAEAD key ğ‘˜ğ‘’, a MAC key s.km (used to authenticate control
messages), and the current epoch id, s.C-epid. Next, the FS-GEAD
init operation F-Init, is executed with inputs ğ‘˜ğ‘’, the group size,
which is 1, and the id ME of the group creator.
Proposals. To add a party IDğ‘, Add recovers the key bundle kbâ€²
for that ID from the contact list, and runs the CGKA add-proposal
algorithm with keys from kbâ€², getting a CGKA proposal Â¯P, which it
then uses to construct and authenticate (with MAC and signature)
the SGM proposal message Pâ€². Remove and Update are similar
(where Update takes the new signing key of the updater as input).
When processing any proposal, algorithm Proc-PM simply attempts
to authenticate the proposal and stores it locally. Proc-PM returns
proposal information: the operation op, the origin of the proposal,
orig, and the data data, as computed by *get-propInfo(Pâ€²) (cf.
Section E of the Appendix).
Committing. To commit to a set P of proposals, Commit calls
the CGKA commit operation to obtain CGKA welcome messages
ğ‘Špub and WPrv as well as CGKA control message Â¯T and update
secret ğ¼. Â¯T is used to construct and authenticate (with MAC and
signature) the SGM control message Tâ€² (which includes a hash
of the proposals). Then, Commit creates and authenticates (with
MAC and signature) the SGM welcome messages for joining parties
by adding an encryption of the PRF-PRNG state s.ğœ to the CGKA
welcome messages. The MAC key used for authenticating control
and welcome messages is derived by absorbing ğ¼ into the PRF-PRNG
(with context information that depends on Tâ€²). Note that s.ğœ is not
updated yet, however.
Process commit/welcome messages. Algorithm Proc-CM first verifies
the authentication information (MAC and signatures) of a commit
message Tâ€² = ("com", epid, ID, h, Â¯T). However, in order to obtain the
MAC key, (1) the CGKA control message Â¯T has to be processed by
Proc-Com, which (2) recovers the update secret ğ¼, which in turn (3)
must be absorbed into the PRF-PRNG (this time updating its state).
The last step also produces the shared key for the new FS-GAEAD
session.
Algorithm Proc-WM, used by joining parties to processes wel-
come messages Wâ€² proceeds similarly, except that the state of the
PRF-PRNG must first be obtained by decrypting the corresponding
ciphertext in Wâ€².
Send message. To send associated data ğ‘ and plaintext ğ‘š, Send
passes ğ‘ and ğ‘š to the current epochâ€™s FS-GAEAD send operation,
and, additionally, also signs the resulting ciphertext, ğ‘, and the iden-
tifier s.C-epid of the current epoch. Receiving works analogously,
with the caveat that the appropriate FS-GAEAD session must be
used.
Security. Main idea: The authenticity property of our con-
4.4.1
struction relies on the EU-CMA security of signatures, the unforge-
ability of MACs, and the authenticity of the FS-GAEAD scheme. In
particular, if the senderâ€™s signing key is secure, then an injection
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1473w.r.t. that key fails with overwhelming probability. If this is not
the case, an honest commit operation provides post-compromise
authenticity, by producing a secure CGKA update secret, ğ¼, which
feeds the PRF-PRNG with good randomness, which in turn outputs
secure MAC and FS-GAEAD keys, used for the authentication of
future control (via MAC security) and application (via FS-GAEAD
security) messages (this requires the adversary to remain passive
for one epoch). PCFS with respect to privacy is similar and relies
on the PCFS security CGKA and the FS of FS-GAEAD.
Simplified properties. Proving SGM security is facilitated by consid-
ering three simplified properties, namely correctness, authenticity,
and privacy. In the full version of the paper [4] we prove that these
properties together imply full SGM security. Besides modularity,
simplified properties facilitate the transition from selective to fully
adaptive security, as the individual â€œsimplifiedâ€ games, defined in
the full version [4], consider selective adversaries that commit to the
challenge (e.g., the challenge or the last healing, epoch, the message
sender and index used for the challenge) at the beginning of the
game. In the reduction from the simplified properties to full SGM
security, the adversarial strategy is being guessed and the success
probability is bounded by values that relate to the running time of
the adversary. After proving the simplified properties theorem, one
can prove authenticity and privacy, individually, against selective
adversaries that commit to their strategy before the security game
begins.
Safety predicates. Using safety predicates, we provide a generic
theorem (cf. Theorem 4.1), that considers any CGKA, FS-GAEAD,
and PRF-PRNG scheme. Those schemes come along with their se-
curity predicates, Î CGKA, Î FS and Î PP, respectively, and we prove
that as long as the attackerâ€™s actions are not violating those predi-
cates, then the resulting SGM construction is secure w.r.t. the SGM
predicate Î SGM = Î SGM(Î CGKA, Î FS, Î PP). Our SGM safety predi-
cate Î SGM (explained below) is depicted in Figure 8 and operates
over history graph information, generated by the SGM security
game. Here, we consider Î CGKA = *CGKA-priv, Î FS = *FS-sec,
Î PP = *PP-secure (cf. Figure 8).
Proof idea. The adversary breaks authenticity if it manages to make
a non-trivial injection, which implies that either of the following
holds: (1) injects a (proposal, welcome, commit or key bundle) mes-
sage in epoch vid that is signed with a non-compromised signing
key of the party ID (determined by *SK-compr(vid, ID)), (2) injects
a (proposal, welcome, commit) message when *auth-compr(vid)
holds, which implies that *PP-secure(vid, *Proj-PP(SGM-Data)),
i.e., PP is secure, and (3) injects an application message when the FS-
GAEAD state is not trivially compromised (determined by *FS-sec).
Clearly, security against (1) reduces to the EU-CMA security of
S. For (2) the output of the PRF-PRNG, PP, in epoch vid is secure,
therefore that MAC key (output by PP) is secure and we can rely
on the security of PP and the unforgeability of M. This requires
the following hybrids: (A) In the first hybrid, if the attacker finds a
collision against H, the execution aborts (reduces to the collision
resistance property of H). This hybrid is required for the protection
of the PP state in the presence of group splitting attacks in which
the adversary can split the group, corrupt in one branch to recover
the PP state, and challenge on another branch in which the PP state
is related to the corrupted one. Here, collision resistance ensures
that different control messages have different hash values, therefore
lead to independent PP states. (B) In the next hybrid, in the last
healing epoch before the challenge, substitute the CGKA update
secret (which feeds PP) with a uniformly random value (required
for the reduction to the PRF-PRNG security). Note that, by the defi-
nitions of *PP-secure, *Proj-PP, a good healing epoch before the
challenge epoch, exists, and this epoch satisfies *CGKA-priv. (C)
In the next hybrid we use the CPA security of PKE. In particular, in
the commit operation that creates the target epoch, encrypt the zero
message instead of encrypting the PP state, as part of the welcome
message (requires a reduction to the CPA security of PKE). (D) Next,
substitute the output of the PRF-PRNG PP in a commit message
for the target epoch, with a uniformly random value (reduces to
PRF-PRNG security). Finally, since the output of PP is substituted
by a uniformly random value, so does that MAC key, thus we have
a reduction to the unfogeability of the MAC scheme M for case (2).
Case (3) is similar, however in the last step we have a reduction to
the FS-GAEAD authenticity property of F. For privacy we consider
the same sequence of hybrids, however the final reduction is against
the FS-GAEAD privacy property of F. For that reduction we use
the fact that *FS-sec is satisfied.
We ultimately prove the following theorem:
Theorem 4.1. Let SGM = SGM(K, F, PKE, S, M, PP, H) be the
SGM scheme presented above and let Î SGM = Î SGM(Î CGKA, Î FS, Î PP)
be predicates such that: (1) K is a CGKA scheme with respect to predi-
cate Î CGKA, (2) F is an FS-GAEAD scheme with respect to predicate
Î FS, (3) PKE is a CPA secure public-key encryption scheme, (4) S is
an existentially unforgeable signature scheme, (5) M is a message
authentication code, (6) PP is a PRF-PRNG with respect to predicate
Î PP, (7) H is a collision resistant hash. Then, SGM is an SGM scheme
with respect to predicate Î SGM.
// Initialization
Init(ID)
//
// Generate Signature Keys
Gen-SK
â€“ Global State â€“
(spk, ssk) â† S-KeyGen
SK-sk[spk] â† ssk
return spk
// Delete Signing Key
Rem-SK(spk)
SK-sk[spk] â† ğœ€
// Store Signing Key for Contact
Get-SK(ID, spk)
CL-S[ID] +â† spk
// Generate Key Bundle
Gen-KB(spk)
(ipk, isk) â† K-Gen-IK
(epk, esk) â† E-KeyGen
(wpk, wsk) â† ((epk, ipk), (esk, isk))
WK-wk[wpk] â† wsk
ssk â† SK-sk[spk]
sig â† S-Sign(ssk, wpk)
return (wpk, spk, sig)