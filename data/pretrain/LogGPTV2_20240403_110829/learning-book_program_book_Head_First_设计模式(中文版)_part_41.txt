合中删除由next（）方法返回的最后一个
项。
这一切都太简单了：我们只需将煎饼屋菜单选代器和餐厅菜单选代器所扩展的接口，由
我们自已的选代器接口，改成java.util的选代器接口即可，对吧？差不多就这样.实
际上，甚至更简单。其实不只java.util有选代器接口，连ArrayList也有一个返回一个迭
代器的iterator（）方法。换句话说，我们并不需要为ArrayList实现自己的选代器。然而，
我们仍然需要为餐厅菜单实现一个选代器，因为餐厅菜单使用的是数组，而数组不支持
iteratorO方法（或其他创建数组选代器的方法）。
DumbQuestions
删除的能力，该怎么办？
运行时异常。
能会有多个选代器引用同一个对象集
答：
Iterator的APl文件提到可以让
合。remove（）会造成怎样的影响？
remove()方法其实是remove()抛出这样的异常，而任何良
可有可无的，不一定要提供删除的好的客户程序只要调用了remove()方
合：后果并没有指明，所以
功能。但是，很明显的，你需要提法，就应该检查是否会发生这个异很难预料。当你的程序在多线程的代
供这样的方法、因为毕竞它被声明常。
码中使用到选代器时、必须特别小
在Iterator接口中。如果你不允许
心。
remove(）的话、可以抛出一个java.
这看起来就和我们之前的定义一样。
332第9章
---
## Page 369
选代器与组合模式
利用java.util.lterator来清理
让我们先从煎饼屋菜单开始，先把它改用java.util.Iterator，这很容易，只需
要删除煎饼屋菜单选代器类，然后在煎饼屋菜单的代码前面加上importjava.
util.Iterator，再改变下面这一行代码就可以了：
public Iterator createIterator()
K
不创建自己的进代器，而是调用
return menuItems.iterator();
莱单项Azaylist的iterator（）方法。
1
这样PancakeHouseMenu就完成了。
接着，我们处理DinerMenu，以符合java.util.Iterator的需求。
首先，导入java.util.Sterator，我们
import java.util.Iterator;
需要实现这个接口。
public class DinerMenuIterator implements Iterator {
MenuItem[] list;
int position = 0;
public DinerMenuIterator (MenuItem[] list)
this.list = list;
这部分都没有定动·
public Object next(){
//在这里实现
….…但是我们需要实现remove（）方法。因
为使用的是固定长度的数组，所以在
public boolean hasNext (){
remove（）被调用时，我们将后面的所有元素
//在这里实现
往前移动一个位置。
public void remove(）(
if （position >
Menu
Waitress
>
printMenu(
Iterator
hasNext(
nextt
()8A0xwe
PancakeHouseMenu
DinerMenu
menultems
tultems
Dinerl
hasNext()
hasNexti
createlterator()
next()
nextp
7]
煎屋莱单和馨厅莱单现在都实现了莱
餐厅莱单的cteateJcerator）方
单接口，也就是说，它们都必须实现新
法金返回一个馨厅莱单进代
的ceateterator(）方法。
器，这种选代器常要速历菜
我们现在使用java.util提供的
单项数组，每个具体的集单
T
Arraylist选代器，所以我们不
都要勇责创建道当的具体送
再需要这个类了。
代器类。
每个具体的莱单都要负责建立适
当的具体进代器。
你现在的位置
335
---
## Page 372
定义选代器模式
定义送代器模式
你已经知道了如何用自己的选代器来实现选代器模
式，也看到了Java是如何在某些面向聚合的类中（如
ArrayList）支持选代器的。现在我们就来看看这个模
选代器模式让我们能游
式的正式定义：
走于聚合内的每一个元
选代器模式提供一种方法顺序访问一个
素，而又不暴露其内部
聚合对象中的各个元素，而又不暴露其内部
的表示。
的表示。
这很有意义：这个模式给你提供了一种方法，可以顺序
把游走的任务放在送代
访问一个聚集对象中的元素，而又不用知道内部是如
何表示的。你已经在前面的两个菜单实现中看到了这
器上，而不是聚合上。
一点。在设计中使用选代器的影响是明显的：如果你
这样简化了聚合的接口
有一个统一的方法访问聚合中的每一个对象，你就可
以编写多态的代码和这些聚合搭配，使用一—如同前
和实现，也让责任各得
面的printMenu(方法一样，只要有了选代器这个方法
根本不管菜单项究竞是由数组还是由ArrayList（或者
其所。
其他能创建选代器的东西）来保存的。
另一个对你的设计造成重要影响的，是选代器模式把
在元素之间游走的责任交给选代器，而不是聚合对象。
这不仅让聚合的接口和实现变得更简洁，也可以让聚
合更专注在它所应该专注的事情上面（也就是管理对
象集合），而不必去理会遍历的事情。
让我们检查类图，将来龙去脉拼凑出来.
336第9章
---
## Page 373
选代器与组合模式
有一个共同的接口供所有的聚合使用，这
这是所有选代器都必须
对客户代码是很方便的：将客户代码从集
实现的蕴口.它包含一
合对象的实现解耦了。
些方法，利用这些方法
可以在集合元素之间游
走。在这里，我们使用
>
Cllent
的是java.util,Jterato1。
Aggregate
Iterator
hasNext(
如果你不想使用2aa的选
teltorator)
next)
代器，也可以自己设计
remove(]
一个接口。
ConcreteAggregate
Concretelterator
hasNext0
next)
每一个具体聚合都要负
责实例化一个具体选代
器，此选代器能够遍历
这个具体聚合持有一
对象集合。
个对象的集合，并实
这个具体进代器负费管理
现一个方法，利用此
目前逸历的位置。
方法返图集合的选代
BRAIN
VPOWER
选代器模式的这张类图看起来很像我们所学过的另一个模式，你知道是哪个模式吗？提示：
子类决定要创建哪个对象。
你现在的位置
337
---
## Page 374
选代器问答
在使用多态的选代，也就是说，我们
器比外部选代器更没有弹性。然而，
所写出的代码，可以在不同的集合中
选代器类提供一些方法叫做first(）、
某些人可能认为内部的选代器比较容
游走，只要这个集合支持选代器即
next().isDone()和currentitem()。
易使用，因为只需将操作告诉它，它
可。我们不在乎这个集合是如何被实
为什么这些方法不一样？
就会帮你做完所有事情。
现的，但依然可以编程在它内部的元
素之阅游走。
合：这些是“经典的”方法
可：
选代器可以被实现成向
名称，它们随着时间的流逝渐渐改变
后移动吗，就像向前移动一样？
如果我使用Java，我不
了，而现在我们在java.util.Iterator 中
见得总是想要利用java.uti.lterator，
所使用的名称有next(）、hasNext(）甚
合：
绝对可以。在这样的情
可能想要使用自己的选代器实现，和
至remove()。
况下，你可能要加上两个方法，一个
这些已经使用Java标准的选代器的
我们来看看这些经典的方法。java.
方法取得前一个元素，而另一个方法
类做整合，这做得到吗？
util.Iterator将next（）（移到下个位
告诉你是否已经到了集合的最前端。
合：
Java的Collection Framework 提供另
或详可以吧。如果你
置）和currentItem（）（取出目前
的项目）合并成一个方法next（）；
-种选代器接口，称为ListIterator。
有一个通用的选代器接口，那么让
这个选代器在标准的选代器接口上多
你自己的集合和Java的集合（例如
isDone（）变成了hasNext(）；至于
加了一个previousO和一些其他的方
first(）则不存在对应，这是因为在
ArrayList、Vector）混合使用就会比
法。任何实现了List接口的集合，都
Java中，我们倾向于取得一个新的选
较客易。但是请记住，如果你需要在
代器，而不是让目前的选代器跳到一
支持这样的做法。
选代器接口为你的集合新增功能，你
开始的位置。所以，其实这些接口没
可以随时扩展选代器接口。
什么太大的差异。事实上，你还可以
合，元素之间并没有明显的次序关
在选代器内加入许多的方法，例如
系，我们该怎么办？
Enumeration（枚举）接口：它实现
remove(方法。
问：
合：
了选代器模式吗？
选代器意味着没有次
我听说过“内部的”选
合：
序。只是取出所有的元素，并不表示
我们曾经在适配器的
代器和“外部的”选代器。这是什
取出元素的先后就代表元素的大小次
那一章中提到过这个接口，还记得
么？我们在前面例子中实现的是哪一
序。对于选代器来说，数据结构可以
吗？java.util.Enumeration是一个有次
种？
是有次序的，或是没有次序的，甚至
序的选代器实现，它有两个方法，
答：我们实现的是外部的选代器，也
数据可以是重复的。除非某个集合的
hasMoreElements(）类似hasNext(),
就是说，客户通过调用next（）取得下
文件有特别说明，否则不可以对选代
而nextElement(类似nextO。然而，
一个元素。而内部的选代器则是由选
器所取出的元素大小顺序作出假设。
你应该比较想使用选代器，而不是枚
问：
代器自已控制。在这种情况下，因为
举，因为大多数的Java类都支持选代
你说可以用选代器写
是由选代器自行在元素之间游走，所
器。如果你想把这两者互相转换，请
出“多态的代码”，可以再多做一些
以你必须告诉选代器在游走的过程
复习适配器那一章，在那一章里你实
中，要做些什么事情，也就是说、你
解释吗？
现了枚举和速代器的适配器。
必须将操作传入给选代器，因为客户
含：
当我们写了一个需要以
无法控制遍历的过程，所以内部选代
选代器当做参数的方法时，其实就是
338第9章
---
## Page 375
选代器与组合模式