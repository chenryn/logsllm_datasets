### 1. 服务器对输入脚本进行过滤或转码不管是反射型还是存储型 XSS攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的：    code:这段代码过滤后，只留下了：    code:这样，当用户再次请求该页面时，由于``标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：    code:&lt;script&gt;alert(&#39; 你被 xss 攻击了 &#39;)&lt;/script&gt;经过转码之后的内容，如``标签被转换为`&lt;script&gt;`，因此即使这段脚本返回给页面，页面也不会执行这段脚本。
### 2. 充分利用 CSP虽然在服务器端执行过滤或者转码可以阻止 XSS攻击的发生，但完全依靠服务器端依然是不够的，我们还需要把 CSP等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：-   限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript    文件，这个 JavaScript 文件也是无法被加载的；-   禁止向第三方域提交数据，这样用户数据也不会外泄；-   禁止执行内联脚本和未授权的脚本；-   还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS    攻击，以便尽快修复问题。因此，利用好 CSP 能够有效降低 XSS 攻击的概率。
### 3. 使用 HttpOnly 属性由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly属性来保护我们 Cookie 的安全。通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：    set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly我们可以看到，set-cookie 属性值最后使用了 HttpOnly 来标记该Cookie。顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。我们还可以通过Chrome 开发者工具来查看哪些 Cookie 被标记了 HttpOnly，如下图：![](Images/de20ffa96715be93ce6e7152be6096c2.png){savepage-src="https://static001.geekbang.org/resource/image/de/bb/defa78c90a4e8f0debb09564561ab9bb.png"}```{=html}```HttpOnly 演示]{.reference}```{=html}```从图中可以看出，NID 这个 Cookie 的 HttpOlny 属性是被勾选上的，所以 NID的内容是无法通过 document.cookie 是来读取的。由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。
## 总结好了，今天我们就介绍到这里，下面我来总结下本文的主要内容。XSS攻击就是黑客往页面中注入恶意脚本，然后将页面的一些重要数据上传到恶意服务器。常见的三种XSS 攻击模式是存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击。这三种攻击方式的共同点是都需要往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户数据上传到黑客的恶意服务器上。而三者的不同点在于注入的方式不一样，有通过服务器漏洞来进行注入的，还有在客户端直接注入的。针对这些 XSS攻击，主要有三种防范策略，第一种是通过服务器对输入的内容进行过滤或者转码，第二种是充分利用好CSP，第三种是使用 HttpOnly 来保护重要的 Cookie 信息。当然除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大XSS 攻击的难度。
## 思考时间今天留给你的思考题是：你认为前端开发者对 XSS 攻击应该负多大责任？欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/7e91bd5c116048de87e68468f727fc3c.png){savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}
# 34 \| CSRF攻击：陌生链接不要随便点在上一篇文章中我们讲到了 XSS 攻击，XSS的攻击方式是黑客往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户页面的数据上传到黑客的服务器上，最后黑客再利用这些数据进行一些恶意操作。XSS攻击能够带来很大的破坏性，不过另外一种类型的攻击也不容忽视，它就是我们今天要聊的CSRF 攻击。 相信你经常能听到的一句话："别点那个链接，小心有病毒！"点击一个链接怎么就能染上病毒了呢？ 我们结合一个真实的关于 CSRF 攻击的典型案例来分析下，在 2007年的某一天，David 无意间打开了 Gmail邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David就发现他的域名被盗了。不过几经周折，David还是要回了他的域名，也弄清楚了他的域名之所以被盗，就是因为无意间点击的那个链接。 **那 David的域名是怎么被盗的呢？** 我们结合下图来分析下 David域名的被盗流程： ![](Images/ff1f6ef243b5336e7ff8ad44fac1ee72.png)savepage-src="https://static001.geekbang.org/resource/image/3d/6b/3d7f097b1d6a8f93a960a12892f1556b.png"}David 域名被盗流程slate-object="mark"} 1.  首先 David 发起登录 Gmail 邮箱请求，然后 Gmail    服务器返回一些登录状态给 David 的浏览器，这些信息包括了    Cookie、Session 等，这样在 David 的浏览器中，Gmail    邮箱就处于登录状态了。        2.  接着黑客通过各种手段引诱 David 去打开他的链接，比如    hacker.com，然后在 hacker.com    页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP    设置接口设置好了新的邮件过滤功能，该过滤器会将 David    所有的邮件都转发到黑客的邮箱中。        3.  最后的事情就很简单了，因为有了 David    的邮件内容，所以黑客就可以去域名服务商那边重置 David    域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。        以上就是 David 的域名被盗的完整过程，其中前两步就是我们今天要聊的CSRF 攻击。David在要回了他的域名之后，也将整个攻击过程分享到他的站点上了，如果你感兴趣的话，可以参考该链接slate-object="inline"（放心这个链接是安全的）。 什么是 CSRF 攻击CSRF 英文全称是 Cross-site requestforgery，所以又称为"跨站请求伪造"，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，**CSRF攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事**。 通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF攻击。 下面我们以极客时间官网为例子，来分析这三种攻击方式都是怎么实施的。这里假设极客时间具有转账功能，可以通过POST 或 Get来实现转账，转账接口如下所示：     
# 同时支持 POST 和 Get    