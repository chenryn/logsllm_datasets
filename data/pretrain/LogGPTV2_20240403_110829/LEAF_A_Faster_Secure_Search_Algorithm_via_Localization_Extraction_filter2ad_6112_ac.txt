= 1 âˆ’
ğ‘—=1
The parity bit ğ‘(ğ‘Ÿ ğ‘—) is always zero when ğ‘£ = 0ğ‘˜ and it is one with
probability half when ğ‘£ â‰  0ğ‘˜. Therefore, when ğ‘ (ğœ€) random variables
ğ‘Ÿğ‘– are selected, the error probability of RS-OR is:
ğ‘ƒğ‘Ÿ(cid:2)OR(ğ‘£[1], . . . , ğ‘£[ğ‘˜]) â‰  RS-OR(ğ‘£[1], . . . , ğ‘£[ğ‘˜])(cid:3)  ğ‘), for ğ‘, ğ‘ âˆˆ
{0, 1}ğœ‡, is:
IsGrtğœ‡(ğ‘, ğ‘) =

(cid:0)(ğ‘[ğ‘–] Â· (ğ‘[ğ‘–] + 1))
Â· IsEqualğœ‡âˆ’ğ‘–(suffixğ‘–(ğ‘), suffixğ‘–(ğ‘))(cid:1)
+(cid:0)ğ‘[ğœ‡] Â· (ğ‘[ğœ‡] + 1)(cid:1) mod 2
ğ‘–âˆˆ[ğœ‡âˆ’1]

ğ‘–âˆˆ[ğœ‡]
with degree ğœ‡ + 1 and 2ğœ‡ overall multiplications.
4 OUR SECURE SEARCH SCHEME (LEAF)
We introduce LEAF in this section. For ease of description, all of
our operations are done by default under homomorphic encryption,
unless otherwise specified.
Following previous works [1, 2], we mainly focus on locating
the first non-zero item, and once it is done, all the matches can be
retrieved via similar processing. We defer the details on how to
retrieve all records to Appendix A for completeness. Further, we
only focus on the algorithm of returning the index ğ‘– instead of the
value array(ğ‘–). As shown in Section 4.4, with the encrypted index ğ‘–
we just need to pay ğ‘‚(ğ‘›) multiplications and without incrementing
the depth to get the encrypted value.
4.1 Overview
We will briefly introduce the three main steps of the algorithm, i.e.,
Localization, Extraction, and Reconstruction, following which we
obtain an encrypted array with only a single 1 whose coordinate
locates the first non-zero term. For completeness, we explain how
to get the encrypted binary representation of the non-zero termâ€™s
index in this encrypted array without increasing the number of
multiplications in Section 4.2.4.
In the Localization step, our goal is to find the interval contain-
ing the first non-zero item. We divide the original array ğ‘£ into
ğ‘¡ smaller intervals, each of which has length ğ‘˜, we create a new
array ind to indicate whether the first ğ‘– intervals contain a non-
zero item, which could be implemented as follows: Let ğ‘–ğ‘›ğ‘‘[1] =
RS-OR(ğ‘£[1], ğ‘£[2], . . . , ğ‘£[ğ‘˜]), ğ‘–ğ‘›ğ‘‘[2] = RS-OR(ğ‘£[1], ğ‘£[2], . . . , ğ‘£[2ğ‘˜]),
and so on. Suppose that the first non-zero item in the original ar-
ray has coordinate between ( ğ‘— âˆ’ 1)ğ‘˜ + 1 and ğ‘—ğ‘˜, then we have
ğ‘–ğ‘›ğ‘‘[1] = ğ‘–ğ‘›ğ‘‘[2] = Â· Â· Â· = ğ‘–ğ‘›ğ‘‘[ ğ‘— âˆ’ 1] = 0 and ğ‘–ğ‘›ğ‘‘[ ğ‘—] = ğ‘–ğ‘›ğ‘‘[ ğ‘— + 1] =
Â· Â· Â· = ğ‘–ğ‘›ğ‘‘[ğ‘¡] = 1 for any ğ‘— âˆˆ [ğ‘¡], by computing pairwise differences
of adjacent indexes, we can get an array ğ‘“ ğ‘™ğ‘ğ‘” âˆˆ {0, 1}ğ‘¡ with only
one 1 at ğ‘“ ğ‘™ğ‘ğ‘”[ ğ‘—], which indicates that the first non-zero itemâ€™s index
in the original array ğ‘£ is between ( ğ‘— âˆ’ 1)ğ‘˜ + 1 and ğ‘—ğ‘˜.
In the Extraction step, our goal is to extract the interval that
contains the first non-zero item. The difficulty of the problem is
that although we have coordinates of the target interval, these
coordinates are homomorphically encrypted, so we cannot directly
use these coordinates to get the target interval. The good news is
that we can use PIR to solve this problem without further interaction
with the client under this situation, but using PIR will introduce an
additional log ğ‘› degrees. In this paper, we propose a new technique
for extracting complete interval, which only increases the depth
by 1 to get the target interval. The basic idea of this technique is
to make use of the richer position information in the interval than
the encrypted coordinates. More specifically, we can change all the
elements in the non-target interval to 0 through a method we put
forward. Finally, we add the elements in the corresponding position
to get the target interval. See Section 4.2.2 for details.
In the Reconstruction step, our goal is to integrate the position
information from the two steps above into one final output. The
above two steps output the starting coordinate of the target interval
(index1) in which the first non-zero item is located and the offset of
the non-zero item within the target interval (index2), respectively.
In theory, we can output the two position information to the client,
and then calculate the coordinate of the first non-zero item in the
original array by the client after decrypting (index = (index1 âˆ’
1)ğ‘˜ + index2). However, we want to output the final result directly
for two purposes:
1
0
0
0
0
0
1
0
1
0
1
0
0
0
0
1
0
ğ‘£
Degree : ğ‘‘
Step 1
ğ‘–ğ‘›ğ‘‘
Degree : ğ‘‘ Â· log ğ‘›
ğœ€
Step 2
ğ‘“ ğ‘™ğ‘ğ‘”
Degree : ğ‘‘ Â· log ğ‘›
ğœ€
0
0
1
1
1
0
1
0
Figure 5: Localization step: divide the array to be searched
into many intervals to determine the specific interval in
which the first non-zero entry occurs
one 1 indicating the interval where the first non-zero item appears.
Step 2: For a stepped array containing only 0s and 1s (theyâ€™re all
0 before the first 1 and 1 after the first 1), we do the difference
operation on the array, that is, we change the value of the ğ‘–-th
element in the array to the value at ğ‘– minus the value at ğ‘– âˆ’ 1:
âˆ€ğ‘– âˆˆ [2, ğ‘¡] : ğ‘“ ğ‘™ğ‘ğ‘”[ğ‘–] â† ğ‘–ğ‘›ğ‘‘[ğ‘–] âˆ’ ğ‘–ğ‘›ğ‘‘[ğ‘– âˆ’ 1]
ğ‘“ ğ‘™ğ‘ğ‘”[ğ‘¡ + 1] â† 1 âˆ’ ğ‘–ğ‘›ğ‘‘[ğ‘¡]
After this operation, ğ‘“ ğ‘™ğ‘ğ‘” only have one 1. If its index is ğ‘—(â‰  ğ‘¡ +1),
it means that the first 1 is located in (ğ‘£[( ğ‘— âˆ’ 1) Â· ğ‘˜ + 1], . . . , ğ‘£[ ğ‘— Â· ğ‘˜]),
if its index is ğ‘¡ + 1, it means there is no 1 in the original array.
Through this process, we locate the position of the first non-zero
item in a smaller interval.
(1) We hope the client only needs to decrypt, thus reducing
the requirement of the protocol on the clientâ€™s computing
power;
(2) Output the coordinate of the output non-zero item in the
whole array can increase the compatibility of our algorithm,
as this output could be adapted to any existing retrieval
algorithm.
4.2 Algorithm Description
Localization. The goal of this step is to locate the target item
4.2.1
into a smaller interval, then we can ignore non-target intervals and
only apply search operation on target interval, thereby reducing
the number of RS-OR operations, which is the main source of
multiplication operation.
Step 1: The process is shown in Figure 5. We first divide the original
array into ğ‘¡ smaller intervals, the size of the partition interval is ğ‘˜
(determined by the parameter in section 5.2). By calculating RS-OR
result of all elements in one chunk, we can determine whether this
chunk contains the non-zero element. Specifically, we apply the
RS-OR method to the first ğ‘–ğ‘˜ elements in array ğ‘£ and put the result
at the position of the ğ‘–-th element in array ğ‘–ğ‘›ğ‘‘.
ğ‘–ğ‘›ğ‘‘[ğ‘–] â† RS-OR(ğ‘£[1], ğ‘£[2], . . . , ğ‘£[ğ‘– Ã— ğ‘˜])
Depending on the nature of the RS-OR operation, if the ğ‘–-th
element in ğ‘–ğ‘›ğ‘‘ is 1, all elements after this element are 1 (Because
the result of 1 OR any number is 1). We don not calculate OR of
each interval separately since we want to derive an array with only
4.2.2 Extraction. The purpose of this subroutine is to extract the
interval containing the first non-zero element for subsequent search
operations on the interval. The reason for this step is that the loca-
tion information obtained in the previous step is homomorphically
encrypted, so we need an extraction method while increasing the
computing depth as less as possible.
Step 1: The second part is shown in Figure 6, the result of the
previous step is the output of a new array ğ‘“ ğ‘™ğ‘ğ‘”, this array only
contains one 1 represents the interval in which the first non-zero
element located, the purpose of step 1 is to use the array ğ‘“ ğ‘™ğ‘ğ‘” to
build a new array ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘ of the same length as the original array ğ‘£,
where all the elements in the interval without the first non-zero item
are 0, and all the elements in the interval where the first non-zero
element appears are 1:
âˆ€ğ‘— âˆˆ [ğ‘¡],âˆ€ğ‘– âˆˆ [ğ‘˜] ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘[( ğ‘— âˆ’ 1) Â· ğ‘˜ + ğ‘–] â† ğ‘“ ğ‘™ğ‘ğ‘”[ ğ‘—]
We call this new array "ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘", as weâ€™ll see later, it acts as a shield.
Step 2: We multiply array ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘ and initial array ğ‘£ bit by bit:
âˆ€ğ‘– âˆˆ [ğ‘›], ğ‘£[ğ‘–] â† ğ‘£[ğ‘–] Â· ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘[ğ‘–]
It is like covering a newspaper with a piece of paper with a hole
in it, all we can see is the text under the hole. That is, after this
operation, only the interval contained the first 1 in ğ‘£ is not all 0â€²ğ‘ .
Step 3: In order to extract the target interval, we define a new array
ğ‘“ ğ‘–ğ‘› âˆˆ {0, 1}ğ‘˜:
âˆ€ğ‘— âˆˆ [ğ‘˜], ğ‘“ ğ‘–ğ‘›[ ğ‘—] â† ğ‘£[ ğ‘—] + ğ‘£[ğ‘˜ + ğ‘—] + Â· Â· Â· + ğ‘£[(ğ‘¡ âˆ’ 1) Â· ğ‘˜ + ğ‘—]
ğ‘“ ğ‘™ğ‘ğ‘”
Degree : ğ‘‘ Â· log ğ‘›
ğœ€
0
1
0
0
Step 1
ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘
Degree : ğ‘‘ Â· log ğ‘›
ğœ€
ğ‘£
Degree : ğ‘‘
0
Ã—
0
0
Ã—
0
0
0
Ã— . . .
0
0
1
0
Step 2
. . .
ğ‘£
Degree : ğ‘‘ Â· (log ğ‘›
ğœ€ + 1)
Step 3
ğ‘“ ğ‘–ğ‘›
Degree : ğ‘‘ Â· (log ğ‘›
ğœ€ + 1)
0
0
0
0
0
0
1
1
1
1
1
0
0
0
1
1
1
1
0
0
0
1
0
0
0