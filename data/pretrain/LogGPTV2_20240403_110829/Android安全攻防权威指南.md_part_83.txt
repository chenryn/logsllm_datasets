-rwxrwxrwx1 97staff1048576 Mar 142013 Stm32_firmware.bin
/var/fo1ders/jb/d1pdf3ns181blcddnxs7g1sc0000gn/T/tmprDZue9, 734:
Warning: Nev continuation level 2 i8 more than one larger than current
DBCIHAL
leve1 0
HEX
DESCRIPTION
[87ephenexip -]$
---
## Page 385
13.4窃取机密和固件
369
在这个例子中，面对一个从STM32微处理器中提取出的IMB的二进制镜像，binwalk没
能识别出任何东西。这种时候除了人工查看镜像以外，就几乎没有别的什么方法了。
2.导入IDA
如果已经充分了解二进制镜像的格式、足以将其中没用的字节全部剔除，或者用其他办法得
到要分析的可执行代码，接下来就可以把它导人IDA了。将来自嵌人式系统的二进制镜像导入
IDA通常需要一些额外的操作，不像分析ELF、Mach-O和PE文件时那么直接简单。换个角度说。
IDA提供了许多额外的功能来协助逆向工程师加载和解析固件镜像。
将固件镜像加载到IDA中通常需要三步。第一步是用IDA打开文件，选择BinaryFile或者
Dump File，如图 13-44所示。
iewdiaisenbly database
00SUx
DunpFR
图13-44在IDA中选择二进制文件
接下来，在对话框中选择目标文件的体系结构，如图13-45所示。需要预先知道待分析处理
器的架构，并且在这里选择它（或者最接近的一个）。
inaryRwFllefle lagizard
AMe
图13-45在IDA中选择处理器架构
3
---
## Page 386
370
第13章硬件层的攻击
最后，在如图13-46所示的表单中填写目标文件的各类信息。通过这个对话框，IDA可以得
知该二进制文件的入口点地址。这里所需的信息可以从目标处理器的规格说明书中获得。
Disassembly memory organization
Oe RAMcto
RAMsiatoddess
000000000
PAM12
000000
]Ceate ROM sector
ROM
ROM dart addess
bFCO000
ROMs9
0022030
rputle
Losdng eddres
DeFCooo00
Fliecthet
Losdngsie
ighFLA
Cenoel
图13-46在IDA中指定加载地址
如果运气好，IDA此时就会顺利加载这个二进制文件。用IDA来逆向PE、ELF或Mach-O
文件时，它会自动进行FLIRT（快速库定位与识别技术）分析，只有出错时（比如人口点反汇编
失败或者识别结构出错）才会弹出对话框，让我们意识到这个分析的存在。它在逆向固件时不会
有什么反应。如图13-47所示，可以在工具栏上选择花朵形状的图标来访间FLIRT对话框。
-+X3BP=
打开签名窗口（快捷点Shin+F5)
图13-47IDAFLIRT签名识别的工具栏图标
FLIRT和binwalk的工作原理类似，都是遍历文件寻找特征。找到以后，可以将其用到该
二进制文件的逆向中。但是与binwalk识别常见文件格式和文件系统不同，FLIRT的特征用于
识别生成代码的编译器。如果有些FLIRT特征与固件相匹配，就会弹出如图13-48所示的对话框，
以供选择正确的签名。
---
## Page 387
13.5陪阱
371
X口口
ofPE El
CascelHeoSeach
Line 1 of 6
图13-48在IDA中使用某个FLIRT签名
整个过程可能不太完美，但是在网上有不少成功案例（一般是逆向游戏机ROM）。配置IDA
所花费的时间可能会稍微超出预期。即使这个二进制文件看起来已经加载成功，在汇编过程中可
能还需要作一些额外的修复。尤其是ARM的代码，IDA会在函数人口点识别以及指令模式判断
（ARM还是THUMB）上遇到困难，需要进一步改进。这些操作可以手动进行，也可以写一个IDC
或者IDAPython脚本。
13.5陷阱
基于硬件的逆向工程和漏洞研究会让人受益额丰，但是一些难以解决的复杂情况也会让人沮
丧。这里列举一些常见的陷阱。
13.5.1定制的接口
面对设备时遇到的最耗时间、最讨厌的情况，也许是一个看起来具有标准引脚分布的硬件接
口其实是定制的。通常情况下，如果定制接口在PCB上的位置很靠近主处理器，就会引起我们
的兴趣。跟踪这些接口与处理器引脚之间的连线可以得到许多有用的信息。例如，如果跟踪到许
多线路都连上了用于USART（通用同步和异步收发器）或者TAG的引I脚，就可以推断它们是
调试接口。这类接口也经常出现在目标处理器附近。
然而，由于并不熟悉这些接口，我们经常要寻找存疑接口的交配连接器并破除引脚，将其变
或更标准的接头。
一家名为SchmartBoard的公司生产了数百种小板子，用于对奇怪的连接器和表面贴装元件
进行破除。
13.5.2二进制私有数据格式
UART、PC和SPI这样的标准接口通常使用明文数据来实现交互式终端、系统引导信息和调
试输出等。但是总线也会使用私有协议，尤其是当系统运行的既不是Linux也不是Android时（如
RTOS）这有时候是可控的，比如完全基于ASCII的私有协议。对于完全基于ASCII的协议，可
13
---
## Page 388
372第13章硬件层的攻击
以马上判断出它是私有的，因为能直接看到其中的文本。有时候还能判断出一些循环字符是协议
中的定界符或者用于格式对齐（比如在浮点数中）的字符。
然面，有时总线上传输的数据全部是二进制的。此时很难确定是否接错了线，也不确定是否
弄错了波特率和数据编码方法。这种情况下，结合其他方法（比如直接访问固件）有助于确定这
些问题。
如果在组件之间的总线上观察到奇怪的数据，用前面介绍的方法噢探并编写一些简单的协议
应答来答复这些数据会很有帮助，甚至有可能找出bug。
13.5.3熔断调试接口
防止JTAG调试的方法有很多，最常见的是JTAG熔丝。这种熔丝有物理的（在处理器内部
物理地断开TAG线），也有基于软件的。对抗这两种保护机制都需要一些高级的技术，超出了
本章的范围。不过对付它们还是有可能的，尤其是软件熔丝。Ralph Phillip Weinmann 在其USENIX
论文 “Baseband Attacks: Remote Exploitation of Memory Corruptions in Cellular Protocol Stacks" 
介绍了这些技术，用于在他的HTCDream手机上重新启动基带处理器的JTAG调试。Kurt
Rosenfeld和 RameshKami也写过一篇关于JTAG 保护机制的深入文章，名为“JTAG：Atacks and
Defenses”，不过这篇文章主要针对的是攻防理论。此外，在一些开发者论坛里，还可以找到许多
软件熔丝相关的资源。
13.5.4芯片密码
在有些微处理器厂商生产的设备中，只有正确输入用户预先指定的密码才能对设备进行刷
写。这种密码通常是多个字节的字符申表示，会被发送到芯片的自启加载器（bootstraploader）
中。该方法可以防止设备被刷写。另外，一些微处理器厂商的芯片只有配置了“物理”密码，才
能启用一些调试功能。
13.5.5bootloader密码、热键和哑终端
一些bootloader（如U-Boot）会为嵌人式开发者提供一些安全选项。U-Boot中有儿个这样的
安全特性，开发者可以通过它们将U-Boot输出隐藏起来，或者需要输入特殊的热键组合、正确
密码或通过UART输人一串特殊的字节序列，才可以进人交互式的U-Boot会话。这种情况越来
越少见，因为有安全意识的厂商并非不知道这种方法，面是更倾向于直接将UART接口隐藏起来。
通常情况下，同一个公司的固件开发和硬件设计这两项工作是分开进行的，甚至可能被转包出去。
对抗这些保护机制涉及一些超出本文范围的高级技术。
有时候，来自bootloader和操作系统的引导信息是可见的，但是之后连线就变得沉默了，或
者开始喷出一些垃圾信息。有时很幸运，问题只是由不常见的波特率改变导致；但有时需要附着
到一个定制的调试接口，或者需要一个驱动程序使用二进制数据将调试信息传给监控UART接口
的定制软件。
---
## Page 389
13.5路阱373
13.5.6已定制的引导过程
有时候，我们很开心地找到并连上了UART或其他调试输出口，观察到bootloader被加载，
然后引导进了内核。接下来还看到驱动初始化，然后开始摩拳擦掌地等待登录提示符出现一但
是它到最后都没有出现，为什么？
这通常是由于Linux或者Android版本已经定制过了，不再执行登录进程。许多时候，嵌人
式开发者选择在引导完成后直接启动其核心进程。这类软件通常会通过一个私有的协议（经常是
二进制的）与定制的远程控制客户端或者调试/诊断客户端进行通信。这种客户端在PC端运行，
通过UART与设备相连。
这种情况下，虽然无法得到登录提示符，但是可以试试别的方法来攻破设备。比如说，也许
可以攻人bootloader来访问到固件镜像；或者通过物理访问闪存，得到文件系统镜像的副本，然
后进一步调查。如果这些简单的方法还不奏效，就需要其他方法了。
13.5.7未暴露的地址线
本章介绍过，有些厂商会在PCB板上将NAND闪存这样的组件像堆三明治一样放在微处理
器上，从面节省空间，也就是所谓的堆叠式封装结构（PoP）。这种结构不仅让我们难以识别微处
理器的序列号，还会带来另一类问题。
如果闪存芯片以PoP结构覆盖在微处理器上，其引脚就不再暴露出来了。事实上，连引脚都
没有了。因此，无法简单地通过去掉焊锡将其取下来并读取其中内容。除了一些高级面长的芯
片分离技术，唯一的办法就是通过下面的微处理器来访问上层闪存的内容。如果这个微处理器没
有禁掉调试功能，就还有可能。但是如果连JTAG熔丝位也烧断了，那就没什么简单的方法读出
13.5.8防止逆向的环氧树脂
有时候会在PCB板上发现想拆除的元件被一层光滑的或者无光泽的黑色或者蓝色材料所覆
盖。厂商这么做，可能是为了保护元件不被天气原因或者冷凝问题影响；但更可能的原因是，他
们就是想阻止其他人轻易地用探针连接到元件上或者去掉其焊锡开从中读取数据。这种问题有时
候用剃须刀或剃须刀加热风枪组合就能搞定。
但是有时候，厂商们会使用更贵的、混合了硅化合物的环氧树脂。这样做可以挫败那些试图
用化学溶剂溶解环氧树脂的人，因为可以溶解这些硅添加剂的化学溶剂也会溶解掉PCB里的硅
以及环氧树脂要保护的元件，这样就会彻底损毁设备。
13.5.9镜像加密、混淆和反调试
我们没有碰到过几个采用这类技术的消费级设备。对PC和移动恶意代码比较熟悉的逆向工
程师们看到这个标题，可能会马上联想到在计算机恶意软件中用到的各类加密和混淆技术，比如
13
---
## Page 390
374第13章硬件层的攻击
跳转加无效代码、运行时反混消等。在嵌人式设备中，可能也有一些聪明的定制方法，即便受到
组件的局限，依然可以像到这些。但这个情况并不常见，因为还有计算空间和电力的限制存在。
比如说，加密裸机执行文件，让它在运行起来以后解密自身，这看起来是一个很简单的解决
方案。然面，在嵌人式系统中也许并没有足够多的内存空间来加载整个镜像。另一方面，闪存在
每一次写入时，寿命都会有衰减，因此嵌人式开发者一般都避免在运行时对闪存进行写操作。如
果可执行文件镜像无法在内存中脱壳，就只能在闪存中进行自修改了，这不仅导致设备启动过程
变慢，还会更快地磨损存储媒介。
13.6小结
本章旨在带领没有任何相关经验的读者了解如何通过物理访问来攻击Android设备这样的嵌
人式硬件。我们介绍了嵌人式设备中经常暴露出来的各类接口，包括UART、JTAG、PC、SPI、
USB和SD卡。接下来，介绍了如何识别这些接口并与其进行通信。通过这些接口，研究人员可
以对目标设备有更深的理解。
对硬件进行物理攻击的一个主要目标是进一步发现、设计和实现不需要物理接触的攻击。我
们介绍了如何借助一系列商业工具和免费工具，通过访问这些接口来读取设备中的固件。对固件
进行逆向和深入分析可以了解设备的工作运转原理，进而有可能找出其中存在的严重漏洞。
最后，讨论了在实践中使用这些工具和技术可能遇到的各类陷阱，以及其中一些问题的应对