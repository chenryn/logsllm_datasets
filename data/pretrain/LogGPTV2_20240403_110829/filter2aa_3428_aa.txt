““SHADOW WALKER
SHADOW WALKER””
Raising The Bar For Rootkit Detection
Raising The Bar For Rootkit Detection
by Sherri Sparks & Jamie Butler
What Is A Rootkit?
What Is A Rootkit?
• Defining characteristic is stealth.
– Viruses reproduce, but rootkits hide!
• Greg Hoglund, author of NT Rootkit 
defines a rootkit as “a set of programs 
which patch and trojan existing execution 
paths within the system”.
What is a rootkit used for?
What is a rootkit used for?
• It is usually used by a hacker to conceal 
his / her presence on a compromised 
system and make it possible to return 
undetected at some later date.
• Indirect overlap with parental control 
software and spyware.
Rootkits & x86 Hardware Architecture: 
Rootkits & x86 Hardware Architecture: 
Pentium Protection Rings
Pentium Protection Rings
• Ring 0 – full access to all 
memory and the entire 
instruction set.
– Kernel Rootkits
• Ring 3 –restricted 
memory access and 
instruction set availability.
– User Rootkits
Rootkits & The Operating System
Rootkits & The Operating System
• The user / application 
view of the system is 
defined by what the OS 
provides to it via the API 
interface.
• A rootkit hides by 
intercepting and altering 
communications at the 
interfaces between 
various OS components.
• Rootkits are a form of 
“man in the middle 
attack”.
OS Components Attacked By 
OS Components Attacked By 
Rootkits
Rootkits
• I/O Manager
– Logging keystrokes or network activity
• Device & File System Drivers
– Hiding files
• Object Manager
– Hiding object (process / thread) handles.
• Security Reference Monitor
– Disable security policies governing runtime access checks on 
objects.
• Process & Thread Manager
– Hiding processes & threads
• Configuration Manager
– Hiding registry entries
First Generation Rootkits
First Generation Rootkits
• Replaced / modified system files on the 
victim’s hard disk
• Example: UNIX login program
Second Generation Rootkits
Second Generation Rootkits
•
Modify static OS components / 
structures loaded in memory.
–
Table based hooking approaches (IAT, 
EAT, SSDT, IDT)
–
Inline function hooking
–
Kernel and user mode rootkits
Third Generation Rootkits
Third Generation Rootkits
• Modify dynamic OS objects loaded in 
memory.
– Direct Kernel Object Manipulation (DKOM)
• Example: FU Rootkit
– Unlinks process objects from the Windows dynamically 
linked list of active process objects.
– Kernel objects represent just about everything 
in the system (processes, threads, drivers, 
security tokens, ect.) so the possibilities are 
virtually unlimited.
– Exclusively kernel mode rootkits.
Process Hiding w/ DKOM
Process Hiding w/ DKOM
Current Rootkit Detection 
Current Rootkit Detection 
Methods
Methods
• Behavioral Detection
• Integrity Detection
• Signature Based Detection
• Diff Based Detection
Rootkit File System 
Rootkit File System 
Detection
Detection
•
Signature Scanners – AV Products
•
Integrity Checkers – Tripwire
•
Diff Based Approach
–
Microsoft Strider GhostBuster
–
System Internals Rootkit Revealer
–
F-Secure Blacklight
Behavioral Detection
Behavioral Detection
•
Attempts to detect the effects of a rootkit on 
the victim system which means it may detect 
previously unknown rootkits.
–
Detecting diverted execution paths.
•
Deviations in executed instructions – PatchFinder by 
Joanna Rutkowska
•
Detecting Hooks – VICE by Jamie Butler
–
Detecting alterations in the number, order, and 
frequency of system calls.
•
May suffer from a high false positive rate.
–
Most end users don’t have the skill to screen out 
false positives.
Integrity Checking
Integrity Checking
• Detects unauthorized changes to system files or 
to loaded OS components in memory.
• Creates an initial baseline database containing 
their CRC values. 
• Periodically calculates and compares the CRC’s 
of these files against the initial trusted baseline.
– Example: Tripwire
• Files system integrity checks are ineffective against most 
modern rootkits which make their changes to memory rather 
than system files on the disk.
Signature Based Detection
Signature Based Detection
• “Fingerprint Identification”
– Searches memory or the file system for 
unique byte patterns (signatures) found in the 
rootkit’s code.
– Tried N’ True Approach - Has been used by 
AV scanners for many years.
– Highly accurate, but ineffective against 
unknown rootkit / malware variants (for which 
a signature does not exist) or deliberately 
obsfucated code.
Motivations
Motivations
Shortcomings Of Current Rootkit Technology
Shortcomings Of Current Rootkit Technology
•
The most advanced public kernel rootkits are 
sitting ducks for primitive signature scans and 
integrity checking techniques.
–
Large parts of rootkit drivers themselves sit in non 
paged memory leaving them vulnerable to simple 
signature scans of system memory.
–
Rootkit modifications to operating system 
components in memory give them away to memory 
integrity checkers heuristic checkers like VICE.
–
Need a method to hide the rootkit driver code and 
its modifications to kernel memory.
Early Viruses Faced A 
Early Viruses Faced A 
Similar Problem 
Similar Problem 
•
Viruses sought to hide their code from file 
system signature scanners. 
–
Their solution: Polymorphism / Metamorphism
–
Attempts to vary the appearance of the viral code 
from one variant to another.
•
Functionally equivalent, but semantically different 
copies of the code.
–
Few rootkits have integrated viral polymorphic 
techniques.
Introducing Shadow Walker
Introducing Shadow Walker
Prototype For A 4
Prototype For A 4th
th Generation Rootkit?
Generation Rootkit?
•
An alternative to viral polymorphism – Virtual 
Memory Subversion!
•
Proof of concept demonstration that a rootkit is 
capable of transparently controlling the 
contents of memory viewed by other 
applications and kernel drivers.
•
Minimal performance impact !
Implications Of Virtual 
Implications Of Virtual 
Memory Subversion
Memory Subversion
•
In-memory security scanners rely upon the 
integrity of their view of memory even if they don’t 
rely upon Operating System API’s (which may 
potentially be hooked).
•
If we can control a scanner’s memory reads we 
can fool signature scanners and potentially make 
a known rootkit, virus, or worm’s code immune to 
in-memory signature scans!
•
We  can also fool integrity checkers and other 
heuristic scanners which rely upon their ability to 
detect modifications to code (i.e. VICE).
Review
Review
• Windows virtual address space layout
• Virtual Memory 
– Paging vs. Segmentation
– Page Tables & PTE’s
– Virtual To Physical Address Translation
– The Role Of The Page Fault Handler
– The Paging Performance Problem & the 
Translation Lookaside Buffer
– Memory Access Types
Windows Virtual Address 
Windows Virtual Address 
Space Layouts
Space Layouts
Application code
Global variables
Per-thread stacks
DLL code
Ntoskrnl
HAL
Boot drivers
Process page tables
System cache
Paged pool
Nonpaged pool
0xFFFFFFFF
0xc0800000
0x80000000
0x7FFFFFFF
0x00000000
System 
Space
User 
Space
3-GB 
User space
1-GB
System space
0xFFFFFFFF
0xC0000000
0xBFFFFFFF
0x00000000
Virtual Memory 
Virtual Memory 
• Separate virtual and physical address spaces.
• Virtual & physical address spaces are managed 
by dividing them into fixed size blocks.
– Paging: All blocks are the same size.
– Segmentation: Blocks may be different sizes.
• The OS handles virtual  physical block 
mappings.
• Virtual address space may be larger than 
physical address space.
• Virtually contiguous memory blocks do not have 
to be physically contiguous.
Virtual To Physical Memory 
Virtual To Physical Memory 
Mapping (Paging)
Mapping (Paging)
Physical Address Space
Virtual Address Space
Page 1
Page 2
Page 3
Page 24
Page n
Frame 1
Frame 2
Frame n
• Paging - virtual and physical 
memory address spaces are 
divided into same size blocks.
– Virtual blocks known as “pages”.
– Physical blocks known as “frames”.
– Virtually contiguous blocks are not 
necessarily physically contiguous!
X86 PTE Format
X86 PTE Format
• Virtual to physical mapping information is kept in 
page tables in structures called PTE’s.
Reserved
Reserved
Reserved
Global
Reserved (large page if PDE)
Dirty
Accessed
Cache disabled
Write through
Owner
Write
Valid
Page frame #
U P Cw Gl L D A Cd Wt O W V
0
1
2
3
4
5
6
7
8
9
12 11 10
31
The Big Picture
The Big Picture
Physical
Frame
0xFFFFFFFF
0xc0800000
0x80000000
0x7FFFFFFF
0x00000000
Virtual Memory
Application code
Global variables
Per thread stacks
DLLs
Ntoskrnl
HAL
Paged Pool
Nonpaged Pool
Process Page Tables
Virtual Pages
Virtual Pages
Page Table 
Entries
Physical Memory
X86 Virtual Address
X86 Virtual Address
• Virtual addresses form indexes into page tables.
• Page tables may be single or multi-level.
• X86 uses a 2 level page table structure w/ 
support for 4K and 4MB sized pages.
Page directory index
Page table index
Byte index
Virtual Page Number
10 bits
10 bits
12 bits
31
0 (LSB)
X86 Virtual To Physical
X86 Virtual To Physical
Address Translation
Address Translation
Page Table
Page Table Index Byte Index
Physical Memory
Virtual Address
Page Directory Index
Page Directory
KPROCESS
CR3
PFN
PFN
Page
Frame
Physical 
address
(1 per process)
(up to 512 per process)
Page Faults
Page Faults
• Because physical memory may be smaller than 
the virtual address space, the OS may move 
less recently used pages to disk (the pagefile) to 
satisfy current memory demands.
• A page fault occurs on:
– An attempted access to a virtual address whose PTE 