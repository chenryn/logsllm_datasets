    NULL,                           // Use the MIDL generated entry-po
int vector. 
    NULL,                           // Use the MIDL generated entry-po
int vector. 
    RPC_IF_ALLOW_LOCAL_ONLY,        // Only allow local connections 
    RPC_C_LISTEN_MAX_CALLS_DEFAULT, // Use default number of concurren
t calls. 
    (unsigned)-1,                   // Infinite max size of incoming d
ata blocks. 
    SecurityCallback                // No security callback. 
); 
This callback function can be implemented in any way you like, you could for
example allow/deny connections based on IPs.
Security Callbacks
Authenticated Bindings
Alright we’re getting closer to the end of the RPC terminology and background
section… Stay with me while we dig into the last concepts. 
As I can feel the pain to follow up for people who are new to all these terms, let’s
take a moment to recap:
Okay so far you should know that you can create implicit and explicit interfaces and
use a few Windows API calls to setup your RPC server. In the previous section I’ve
added that once you register your server you can set registration ags and (if you
want to) also a callback function to secure you server and lter the clients who can
access your server. The last piece in the puzzle is now an extra Windows API that
allows the server and client to authenticate your binding (remember that one of the
benets of having a binding handle is that you can authenticate your binding, like
‘painting your cord for your can phone’). 
… But why would/should you do that? 
Authenticated Bindings in combination with the right registration ag
(RPC_IF_ALLOW_SECURE_ONLY) enables your RPC Server to ensure that only
authenticated users can connect; And - in case the client allows it - enables the
server to gure out who connected to it by impersonating the client. 
To backup what you learned before: You could as well use the SecurityCallback to
deny any anonymous client from connecting, but you would need to implement the
lter mechanism on your own, based on attributes you control. 
Example: You wouldn’t be able to determine if the client is for example a valid
domain user, because you don’t have any access to these account information.
Okay so how do you specify an authenticated binding? 
You can authenticate your binding on the server and on the client side. On the
server side you want to implement this to ensure a secured connection and on the
client side you might need to have this in order to be able to connect to your server
(as we’ll see shortly in the Access Matrix)
Authenticating the binding on the Server side: [Taken from my example code here]
RPC_STATUS rpcStatus = RpcServerRegisterAuthInfo( 
    pszSpn,             // Server principal name 
    RPC_C_AUTHN_WINNT, // using NTLM as authentication service provid
er 
    NULL,               // Use default key function, which  is ignored 
for NTLM SSP 
    NULL                // No arg for key function 
); 
Authenticating the binding on the client side: [Taken from my example code here]
RPC_STATUS status = RpcBindingSetAuthInfoEx( 
    hExplicitBinding, 
// the client's binding handle 
    pszHostSPN,  
// the server's service principale nam
e (SPN) 
    RPC_C_AUTHN_LEVEL_PKT, 
// authentication level PKT 
    RPC_C_AUTHN_WINNT,  
// using NTLM as authentication servic
e provider 
    NULL, 
// use current thread credentials 
    RPC_C_AUTHZ_NAME, 
// authorization based on the provided 
SPN 
    &secQos 
// Quality of Service structure 
); 
The interesting bit on the client side is that you can set a Quality of Service (QOS)
structure with your authenticated binding handle. This QOS structure can for
example be used on the client side to determine the Impersonation Level (for
background information check out my previous IPC post ), which we’ll later cover in
section Client Impersonation.
Important to note: 
Setting an authenticated binding on the server side, does not enforce an
authentication on the client side. 
If for example no ags are set on the server side or only the
RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH is set, unauthenticated clients can still
connect to the RPC server. 
Setting the RPC_IF_ALLOW_SECURE_ONLY ag however prevents unauthenticated
client bindings, because the client can’t set an authentication level (which is what is
checked with this ag) without creating an authenticated binding.
Last but not least we have to clarify one last important aspect of RPC
communication: Well-known vs Dynamic endpoints. 
I’ll try to make this one short as it’s also quite easy to understand…
When you spin up your RPC server, the server registers an interface (as we’ve seen
already in the code sample above with RpcServerRegisterIf2) and it also needs to
dene on which protocol sequence (e.g. ‘ncacn_ip_tcp’, ‘ncacn_np’, …) it wants to
listen to. 
Now the protocol sequence string that you specify in your server is not quite
enough to open a RPC port connection. Imagine you specify ‘ncacn_ip_tcp’ as your
protocol sequence, meaning you instruct your server to open up an RPC connection
that accepts connections via TCP/IP… but … on which TCP port should the server
actually open up a connection? 
Similar to ncacn_ip_tcp other protocol sequences also need a little more information
about where to open a connection object:
>> ncacn_ip_tcp needs a TCP port number, e.g. 9999
>> ncacn_np needs a Named Pipe name, e .g. “\pipe\FRPC-NP”
>> ncalrpc needs an ALPC port name, e.g. “\RPC Control\FRPC-LRPC”
Let’s assume for a moment you specied ncacn_np as the protocol sequence and
chose the Named Pipe name to be “\pipe\FRPC-NP”. 
Your RPC server will happily spin up and is now waiting for clients to connect. The
client on the other hand needs to know where it should connect to. You tell your
Well-known vs Dynamic Endpoints
client the server’s name, specify the protocol sequence to be ncacn_np and set the
Named Pipe name to the same name you dened in your server (“\pipe\FRPC-NP”).
The client connects successfully and just like that you’ve built a RPC client and
server based on a Well-known endpoint… which in this case is: “\pipe\FRPC-NP”. 
Using Well-known RPC endpoints just means you know all the binding information
(protocol sequence and endpoint-address) upfront and could - if you want to - also
hardcode those information in your client and server. Using Well-known endpoints
is the easiest way to build up your rst RPC client/server connection.
What are Dynamic endpoints then and why should one use them? 
In the example above we choose ncacn_np and just picked any arbitrary Named Pipe
name to open our server and that worked just ne, because we knew (well at least
we hoped) the Named Pipe that we’ve opened up with this name didn’t already
exist on the server side, because we just made a name up. If we now choose
ncacn_ip_tcp to be the protocol sequence how do we know which TCP port is still
available for us? Well we could just specify that our program needs port 9999 to be
functional and leave it to the Admins to ensure that this port is unused, but we
could also ask Windows to assign us a port that is free. And that is what Dynamic
endpoints are. Easy … case closed, let’s go for beers 
Wait a minute: If we get assigned a port dynamically, how does the client know
where to connect to ?!… 
And that is the other thing with Dynamic endpoints: If you chose dynamic endpoints
you need someone to tell your client what port you got and that someone is the
RPC Endpoint Mapper service (started and running by default on your Windows
system). If your server is using Dynamic Endpoints it will need to call the RPC
Endpoint Mapper to tell it to register its Interface and functions (specied in the IDL
le). Once the client attempts to create the binding it will query the server’s RPC
Endpoint Mapper for matching interfaces and the Endpoint Mapper will ll in the
missing information (e.g. the TCP port) to create the binding.
The main advantage of Dynamic Endpoints is to automatically nd an available
endpoint-address when the endpoint-address space is limited, as it is the case with
TCP ports. Named Pipes and ALPC based connections can also safely be done with
Well-known endpoints, because the address space (aka. the arbitrary pipe or port
name that you’ve chosen) is large enough to avoid collisions.
We’ll wrap this up with code snippets from the server side to nail our understanding
of Well-known and Dynamic endpoints.
Well-Known Endpoint Implementation
RPC_STATUS rpcStatus; 
// Create Binding Information 
rpcStatus = RpcServerUseProtseqEp( 
    (RPC_WSTR)L"ncacn_np",          // using Named Pipes here 
    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // Ignored for Named Pipes (only u
sed for ncacn_ip_tcp, but set this anyway) 
    (RPC_WSTR)L"\\pipe\\FRPC-NP",   // example Named Pipe name 
    NULL                            // No Secuirty Descriptor 
); 
// Register Interface 
rpcStatus = RpcServerRegisterIf2(...) // As shown in the examples abov
e 
// OPTIONAL: Register Authentication Information 
rpcStatus = RpcServerRegisterAuthInfo(...) // As shown in the example
 above 
// Listen for incoming client connections 
rpcStatus = RpcServerListen( 
    1,                              // Recommended minimum number of t
hreads. 
    RPC_C_LISTEN_MAX_CALLS_DEFAULT, // Recommended maximum number of t
hreads. 
    FALSE                           // Start listening now. 
); 
Dynamic Endpoint Implementation
RPC_STATUS rpcStatus; 
RPC_BINDING_VECTOR* pbindingVector = 0;
// Create Binding Information 
rpcStatus = RpcServerUseProtseq( 
    (RPC_WSTR)L"ncacn_ip_tcp",      // using Named Pipes here 
    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // Backlog queue length for the nc
acn_ip_tcp protocol sequenc 
    NULL                            // No Secuirty Descriptor 
); 
// Register Interface 
rpcStatus = RpcServerRegisterIf2(...) // As shown in the examples abov
e 
// OPTIONAL: Register Authentication Information 
rpcStatus = RpcServerRegisterAuthInfo(...) // As shown in the example
 above 
// Get Binding vectors (dynamically assigend) 
rpcStatus = RpcServerInqBindings(&pbindingVector); 
// Register with RPC Endpoint Mapper 
rpcStatus = RpcEpRegister( 
    Example1_v1_0_s_ifspec,             // your interface as defined v
ia IDL 
    pbindingVector,                     // your dynamic binding vector
s 
    0,                                  // We don't want to register t
he vectors with UUIDs 
    (RPC_WSTR)L"MyDyamicEndpointServer" // Annotation used for informa
tion purposes only, max 64 characters       
); 
// Listen for incoming client connections 
rpcStatus = RpcServerListen( 
    1,                              // Recommended minimum number of t
hreads. 
    RPC_C_LISTEN_MAX_CALLS_DEFAULT, // Recommended maximum number of t
hreads. 
    FALSE                           // Start listening now. 
); 
Note: If you’re using Well-known endpoints you could as well register your RPC
server with your local RPC Endpoint Mapper by calling RpcServerInqBindings &
RpcEpRegister if you want to. You don’t need to do that for your client to be able to
connect, but you could.
If you want to read more on this, the Microsoft documentation on this topic can be
found here: 
https://docs.microsoft.com/en-us/windows/win32/rpc/specifying-endpoints
To wrap up all of the above, the communication ow can be summarized as follows:
1. Server registers Interface(s), e.g. using RpcServerRegisterIf2
2. Server creates Binding Information using RpcServerUseProtseq &
RpcServerInqBindings (RpcServerInqBindings is optional for Well-known
Endpoints)
3. Server registers Endpoints using RpcEpRegister (optional for Well-known
Endpoints)
4. Server can register Authentication Information using
RpcServerRegisterAuthInfo (optional)
5. Server listens for client connection(s) using RpcServerListen
6. Client creates a Binding Handle, using RpcStringBindingCompose &
RpcBindingFromStringBinding
7. Client RPC runtime library nds the server process by querying the Endpoint
Mapper on the server host system (only necessary for Dynamic Endpoints)
8. Client can authenticate binding handle using RpcBindingSetAuthInfo
(optional)
9. Client makes an RPC call by calling one of the functions dened in the used
interface
10. Client RPC runtime library marshals the arguments in an NDR format with the
help of the NDR runtime and send them to the server,
11. The Server’s RPC run time library gives the marshaled arguments to the stub,
which unmarshals them, and then passes them to the server routines.
12. When the Server routines return, the stub picks up the [out] and [in, out]
parameters (dened in the interface IDL le) and the return value, marshals
them, and sends the marshaled data to the Server’s RPC run time library,
which transfers them back to the client.
RPC Communication Flow
As mentioned in the beginning the examples above are taken from my sample
implementation, publicly available at:  
https://github.com/csandker/InterProcessCommunication-
Samples/tree/master/RPC/CPP-RPC-Client-Server. 
In this repo you will nd the following sample implementations:
>> Basic unauthenticated Server supporting unauthenticated Implicit Bindings
>> Basic unauthenticated Client supporting unauthenticated Implicit Bindings
>> Basic Server supporting unauthenticated Explicit Bindings
>> Basic Server supporting authenticated Explicit Bindings
>> Basic Client supporting authenticated Explicit Bindings without QOS
>> Basic Client supporting authenticated Explicit Bindings with QOS
An example how these PoCs look can be seen below:
Alright if you understood all of the terminology above, here’s the access matrix that
visualizes which client can connect to which server. 
Note: You can only connect an implicit clients to implicit servers, and explicit clients to
explicit servers. Otherwise you get an Error 1717 (RPC_S_UNKNOWN_IF)
Sample Implementation
Access Matrix
Finally… after all that talk about RPC internals, let’s talk about RPC’s attack surface. 
Obviously there could be bugs and 0-days anywhere in the RPC communication
chain, which always comes down to a case-by-case analysis to understand its
exploit potentials, but there is also some exploitation potential of general RPC
design concepts, which I’ll highlight below. 
Side note: If you are aware of interesting RPC CVEs, ping me at /0xcsandker
Okay so before we can think what offensive games we can play with RPC, we need
to nd suitable targets rst. 
Let’s dive into how we can nd RPC Servers and clients on your systems.
To recap a server is built by specify the required information (protocol sequence &
endpoint-address) and calling Windows APIs to built the necessary internal objects
and start the server. With that in mind the easiest way to nd RPC servers on your
local system is by looking for programs that import those RPC Windows APIs. 
One easy way to do that is by using the DumpBin utility that nowadays ships with
Visual Studio.
A sample Powershell snippet searching through C:\Windows\System32\  on a
recent Windows10 can be found below:
Get-ChildItem -Path "C:\Windows\System32\" -Filter "*.exe" -Recurse -E
rrorAction SilentlyContinue | % { $out=$(C:\"Program Files (x86)"\"Mic
rosoft Visual Studio 14.0"\VC\bin\dumpbin.exe /IMPORTS:rpcrt4.dll $_.V
ersionInfo.FileName); If($out -like "*RpcServerListen*"){ Write-Host "
[+] Exe starting RPC Server: $($_.VersionInfo.FileName)"; Write-Output 
"[+] $($_.VersionInfo.FileName)`n`n $($out|%{"$_`n"})" | Out-File -Fil
ePath EXEs_RpcServerListen.txt -Append } } 
This snippet prints the names of the executables to console and the entire DumpBin
output to the le EXEs_RpcServerListen.txt (so that you can review what DumpBin
actually gives you).
Attack Surface
Finding Interesting Targets
RPC Servers