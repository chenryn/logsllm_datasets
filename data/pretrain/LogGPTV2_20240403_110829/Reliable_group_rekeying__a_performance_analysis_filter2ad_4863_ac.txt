users. From this ﬁgure, we observe that over a wide range of J and
L values, the average of {zr} for R-BFA and DFA is smaller than
that of BFA. Since both R-BFA and DFA put related keys together,
they achieve similar performance. We also observe from this ﬁg-
ure that for R-BFA and DFA, on the average, users only need to
N=2048, d=4, #keys/packet=25
BFA
DFA
R-BFA
avg #packets
5
4
3
2
1
0
0
500
1000
J
1500
2000
2000
1000
1500
L
500
Figure 8: Average of {zr} for different J and L values
N=2048, L=1000, d=4, #keys/packet=25
s
t
e
k
c
a
p
#
g
v
a
6
5
4
3
2
1
0
BFA
DFA
R-BFA
0
500
1000
1500
2000
Figure 9: Average of {zr} for L = 1000
J
receive 3 to 4 packets even when J and L have been varied over a
wide range. For clarity, Figure 9 shows the results for L = 1000.
N=2048, d=4, #keys/packet=25
BFA
DFA
R-BFA
stdev of #packets
2
1.5
1
0.5
0
0
500
1000
L
1500
2000
2000
1000
1500
J
500
Figure 10: Variance of {zr} for different J and L values
N=2048, L=1000, d=4, #keys/packet=25
s
t
e
k
c
a
p
#
f
o
v
e
d
t
s
1
0.8
0.6
0.4
0.2
0
0
500
1000
1500
2000
BFA
DFA
R-BFA
Figure 11: Variance of {zr} for L = 1000
J
Next, we consider the variance of {zr}. From Figure 10, we ob-
serve that DFA has large variance while the variances of R-BFA and
BFA are smaller. This is expected because we know that R-BFA
and BFA treat users more fairly, and therefore will have smaller
variances. For clarity, Figure 11 shows the results for L = 1000.
N=2048, d=4, #encs/packet=25
R-BFA
#packets
180
150
120
90
60
30
0
0
500
1000
J
1500
2000
2000
1000
1500
L
500
Figure 12: Average rekey message size
For comparison purpose, Figure 12 shows the average number
of packets in one rekey message over a wide range of J and L
values for a rekey subtree with 2048 users. Comparing Figure 12
with Figure 8, we observe that a user only needs to receive a small
fraction of the packets in a rekey message. We refer to the property
that each user only needs to receive a small fraction of the packets
in a rekey message as the sparseness property.
3.2 Reliable rekey transport protocol
Given the rekey workload generated by a rekey subtree, we next
investigate rekey transport protocol. Following the convention of
reliable multicast, we also refer to a group user as a receiver.
To determine the rekey transport protocol, we need to ﬁrst con-
sider its properties. Although many reliable multicast protocols
have been proposed and analyzed in the past few years [6], we can-
not consider rekey transport as a conventional reliable multicast be-
cause of its speciﬁc properties. Besides its sparseness workload, we
observe that rekey transport also has the following requirements:
• Eventual reliability. By eventual reliability, we mean that
a receiver should be able to receive all of its encrypted keys.
This requirement comes from the inter-dependencies discussed
in Section 2.
• Soft real-time requirement. By soft real-time requirement,
we mean that the transport of a rekey message is ﬁnished
with a high probability before the start of the next rekey in-
terval. The objective of the soft real-time requirement is to
alleviate the out-of-sync problems.
We address the eventual reliability requirement by allowing re-
ceivers to send re-synchronization requests [23] when they cannot
recover a rekey message in time. To provide soft real-time rekey
transport, we use proactive FEC which can reduce recovery latency.
In [9, 16], the authors have shown that round-based proactive FEC
approaches can reduce delivery latency. Furthermore, it has been
shown in [13] that a hybrid approach combining FEC and ARQ
can signiﬁcantly reduce the bandwidth requirements of a large re-
liable multicast session. In [14], the authors compare the beneﬁts
of combining local recovery with an FEC/ARQ hybrid technique
and conclude that for many multicast scenarios, such a combina-
tion offers little improvement over an FEC/ARQ hybrid technique
without local recovery. Given above, our performance evaluation
of rekey transport is based on a simple round-based proactive FEC
protocol.
One potential scalability problem of a reliable multicast proto-
col is the feedback implosion problem, and mechanisms such as
tree-based feedback aggregation or NACK avoidance can be used
to reduce feedback trafﬁc [6]. Furthermore, for a proactive FEC
based reliable multicast protocol, Rubenstein, Kurose and Towsley
have observed that the number of NACK packets can be reduced by
increasing proactivity factor [16]. In [26], we have proposed and
investigated an adaptive proactive FEC algorithm, and our evalua-
tions show that the number of NACK packets to the key server can
be controlled by adjusting the proactivity factor at the beginning of
each rekey interval. Given these results, in this paper, we assume
that each receiver unicasts its feedback packets directly to the key
server.
send k original and (cid:10)k(ρ − 1)(cid:11) FEC packets
at the end of each round:
collect amax as the largest ar
at the beginning of next round:
generate amax FEC packets, and multicast to all receivers
Figure 13: Key server protocol
First, consider the key server protocol as speciﬁed in Figure 13.
At the beginning of a rekey interval, the key server ﬁrst runs a key
assignment algorithm to assign the keys in a rekey subtree into k
packets. Following the convention, we refer to the k packets in
a rekey message as a block and k as the block size. After gener-
ating the k original packets, the key server makes each of the k
packets individually veriﬁable by ﬂow signing [22], and generates
(cid:10)(ρ − 1)k(cid:11) proactive FEC packets, where ρ ≥ 1 is the proactivity
factor at the current rekey interval. To generate the FEC packets,
the key server uses the Reed Solomon codes [15] when block size
k is small and uses the Tornado codes [3] when k is large. The
advantage of Reed Solomon code is that it allows a user to recover
the k original packets from any k distinct packets, and therefore
we base our analysis on Reed Solomon code. The Tornado codes,
which may require a slightly higher number of packets to recover
all of the original packets, also have advantages because they have
smaller encoding time, and they may also allow a user to recover its
packets without recovering all of the original packets. After multi-
casting the original and proactive FEC packets, the key server waits
for the duration of a round, which is the largest round-trip time of
all receivers, and collects feedbacks from the receivers. The feed-
back of each receiver is a NACK packet containing the number of
packets ar that it needs in order recover its packets. At the begin-
ning of the next round, the key server calculates amax, the largest
of all ar, generates amax new FEC repair packets, and multicasts
the repair packets to receivers. This process continues until the
end of this rekey interval. We notice that it is possible that the
key server may still receive NACK packets from some receivers
at the end of a rekey interval. In this case, the key server consid-
ers the NACK packets as re-synchronization requests and sends re-
synchronization packets to these users via reliable unicast. Since
the design objective of keygem is to make sure that this scenario
will rarely happen, we do not discuss this scenario in this paper.
For a strategy in which the key server targets to multicast for only
one or two rounds instead of until the end of a rekey interval, please
see [26].
Next, consider the receiver protocol as speciﬁed in Figure 14.
Assume the encrypted keys of a receiver r are assigned into zr
packets. Then, during the ﬁrst round, the receiver checks whether
it has received the zr packets. If the receiver has received the zr
packets or is able to recover the zr packets using FEC because it
has received at least k distinct packets, the receiver extracts its en-
crypted keys and does not participate in the following rounds. Oth-
erwise, the receiver will need to participate in the following rounds
to receive a total of at least k distinct packets to recover the k orig-
for the ﬁrst round:
if receive its speciﬁc zr or at least k distinct packets
done
else at the end of this round
set ar = k − (the number of distinct packets received)
report ar to key server
for each of the following rounds:
if receive at least k distinct packets
recover the encrypted keys
done
else at the end of this round
set ar = k − (the number of distinct packets received)
report ar to the key server
Figure 14: Receiver protocol I (with sparseness property)
inal packets, including its zr packets. For this case, the receiver
sets ar = k − y, where y is the number of distinct packets that
it has received, and reports ar to the key server. For comparison
purpose, we have also shown in Figure 15 a receiver protocol in
which a receiver needs to receive all of the k packets in a block,
that is, a workload that does not have the sparseness property. To
distinguish these two protocols, we call the ﬁrst protocol, which
considers sparseness property, as Protocol I, and the second proto-
col, which can be seen as a conventional reliable multicast protocol,
as Protocol II.
if receive at least k distinct packets
construct the k original packets
done
else at the end of each round
set ar = k − (the number of distinct packets received)
report ar to the key server
Figure 15: Receiver protocol II (conventional reliable multi-
cast)
3.3 Performance of reliable rekey transport
Given the workload of rekey transport and the rekey transport
protocol, we analyze in this section the performance of reliable
rekey transport. To determine the guidelines for system design, we
are interested in two performance metrics. Our ﬁrst metric is band-
width overhead, which we deﬁne as the ratio of k(cid:2)/k, where k(cid:2)
is
the total number of packets that the key server sends for a block of
packets, including the repair packets to provide reliability, and k is
the block size. Our second metric is latency, which we deﬁne as the
number of rounds to deliver a rekey message to all receivers.
3.3.1 Analysis assumptions
For performance analysis, instead of considering a speciﬁc key
assignment algorithm, we consider general key assignment algo-
rithms and assume the distribution of {zr} as an input to the anal-
ysis. Furthermore, for all numerical results in this section, we as-
sume that the number of receivers N is equal to 2048, and that all
receivers have a zr value of 6. For a balanced key tree of degree
4 with 2048 users, we know that 6 is the maximum number of en-
crypted keys that a user needs to receive. Thus, the value of zr for
a user r will be less than or equal to 6. As a result, the reported
numerical results are upper bounds for the results of any speciﬁc
key assignment algorithm.
As for the N receivers, we assume that nh of them have a high
packet loss rate of ph, and the other nl = N − nh have a low
loss rate of pl. For simplicity of analysis, we assume that receivers
have independent losses, and that the losses of different packets
are independent (for simulation results of correlated losses, please
see [26]). For numerical results, we use the default values of nh =
615, ph = 20%, nl = 1433, and pl = 2%.
3.3.2 Conversion from protocol I to protocol II
Since a receiver does not need to receive all of the packets in
a rekey message, we observe that previous analyses [19, 10, 13,
8, 14] of reliable multicast cannot be directly applied. Our key
observation, however, is that we can convert the analysis of rekey
transport workload into the analysis of conventional reliable multi-
cast workload. In particular, we can convert one protocol instance
where receivers run Protocol I to another protocol instance where
receivers run Protocol II. Here, by a protocol instance, we mean a
session with a given number of receivers running a given protocol.
Consider the following condition C0 at the end of the ﬁrst round:
C0: A receiver r has received its speciﬁc zr packets,
and the total number of packets it has received is less
than k.
We observe that if we remove the receivers who satisfy condition
C0 at the end of the ﬁrst round, we have converted the analysis of
an instance of Protocol I to an instance of Protocol II with reduced
number of receivers, and therefore we can reuse the results of pre-
vious analyses for conventional reliable multicast. To be more spe-
ciﬁc, let nh and nl denote the numbers of high loss and low loss
receivers in an instance of Protocol I. Let N high
de-
note the random variables of the numbers of high loss and low loss
receivers who do not satisfy condition C0 at the end of the ﬁrst
round, where 0 ≤ N high
≤ nl. Thus, our
analysis of an instance of receiver Protocol I with nh high loss re-
ceivers and nl low loss receivers has been converted to the analysis
of an instance of Protocol II with N high
low
loss receivers.
nl = l}. Since we
assume the losses of the receivers are independent, we have that
Let Qnh,nl (h, l) denote P r{N high
≤ nh, and 0 ≤ N low
high loss and N low
nh = h, N low
and N low
nh
nh
nh
nl
nl
nl
Qnh,nl (h, l) = Qhigh
nh (h) denotes P r{N high
where Qhigh
of h of the nh high loss receivers do not satisfy C0, and Qlow
denotes P r{N low
nl = l}.
nl (l)
nh (h) · Qlow
nh = h}, that is, the probability
nl (l)
nh (h), where 0 ≤ h ≤
nh ], and E[N low
]. The