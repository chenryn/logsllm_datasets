title:Tracing your roots: exploring the TLS trust anchor ecosystem
author:Zane Ma and
James Austgen and
Joshua Mason and
Zakir Durumeric and
Michael Bailey
Tracing Your Roots: Exploring the TLS Trust Anchor Ecosystem
Zane Ma
Georgia Institute of Technology
USA
PI:EMAIL
James Austgen
University of Illinois at
Urbana-Champaign
USA
PI:EMAIL
Joshua Mason
University of Illinois at
Urbana-Champaign
USA
PI:EMAIL
Zakir Durumeric
Stanford University
USA
PI:EMAIL
Michael Bailey
University of Illinois at
Urbana-Champaign
USA
PI:EMAIL
ABSTRACT
Secure TLS server authentication depends on reliable trust anchors.
The fault intolerant design of today’s system—where a single com-
promised trust anchor can impersonate nearly all web entities—
necessitates the careful assessment of each trust anchor found in
a root store. In this work, we present a first look at the root store
ecosystem that underlies the accelerating deployment of TLS. Our
broad collection of TLS user agents, libraries, and operating systems
reveals a surprisingly condensed root store ecosystem, with nearly
all user agents ultimately deriving their roots from one of three
root programs: Apple, Microsoft, and NSS. This inverted pyramid
structure further magnifies the importance of judicious root store
management by these foundational root programs.
Our analysis of root store management presents evidence of
NSS’s relative operational agility, transparency, and rigorous in-
clusion policies. Unsurprisingly, all derivative root stores in our
dataset (e.g., Linuxes, Android, NodeJS) draw their roots from NSS.
Despite this solid footing, derivative root stores display lax update
routines and often customize their root stores in questionable ways.
By scrutinizing these practices, we highlight two fundamental ob-
stacles to existing NSS-derived root stores: rigid on-or-off trust and
multi-purpose root stores. Taken together, our study highlights
the concentration of root store trust in TLS server authentication,
exposes questionable root management practices, and proposes
improvements for future TLS root stores.
ACM Reference Format:
Zane Ma, James Austgen, Joshua Mason, Zakir Durumeric, and Michael
Bailey. 2021. Tracing Your Roots: Exploring the TLS Trust Anchor Ecosystem.
In ACM Internet Measurement Conference (IMC ’21), November 2–4, 2021,
Virtual Event, USA. ACM, New York, NY, USA, 16 pages. https://doi.org/
10.1145/3487552.3487813
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
IMC ’21, November 2–4, 2021, Virtual Event, USA
© 2021 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9129-0/21/11...$15.00
https://doi.org/10.1145/3487552.3487813
179
1 INTRODUCTION
TLS web server authentication functions through the web public
key infrastructure (PKI). In the Web PKI, clients rely on a set of trust
anchors (also called a root store) to verify web identities (e.g., DNS
names and IP addresses) and their corresponding cryptographic
public keys. Due to the design of the existing Web PKI, each indi-
vidual trust anchor is a single point of widespread failure; a single
compromised trust anchor can maliciously impersonate nearly all
web identities. Thus, the security of the PKI system hinges on judi-
cious trust: carefully deciding what roots to include and exclude
from a root store. In this work, we identify the root stores utilized
by popular TLS clients and how these root stores compare in their
trust anchor decisions.
A wide range of applications rely on the Web PKI for TLS au-
thentication, but it is not immediately obvious which root stores
they utilize. To identify the root store providers for popular web
clients, we manually investigate the top 200 most common user
agent strings seen across a major CDN and definitively collect the
default root stores for more than three-quarters of them. We supple-
ment this data with additional root store providers found in other
popular software, ultimately collecting the root store histories of
thirteen providers. Our dataset corroborates the traditional assump-
tion that many clients rely on the roots provided by the operating
system, but we also find several libraries that provide their own
root stores, such as Mozilla’s NSS, NodeJS, and Java. Ordiantion
analysis of these providers shows that they condense into just four
independent root programs—Apple, Microsoft, Mozilla/NSS, and
Java—that underlie the vast majority of TLS user agents.
Our findings demonstrate that the TLS root store ecosystem is
an inverted pyramid, where hundreds of user agents rely on about
a dozen root store providers that stem from three root programs
(excluding Java since it is not widely used). As a result, each root
program has an outsized effect on a wide range of end users. Given
this reach and the fault-intolerant fragility of root stores, we dili-
gently evaluate each root program to assess their management
practices and placement of trust. We find NSS to have the best
operational hygiene, followed by Apple, and then Microsoft and
Java. With regards to trust decisions, we find that Apple, and Mi-
crosoft especially, place their trust in a wider range of CAs than
NSS/Java. In several cases, Microsoft trusts government operated
“super-CAs” that are not included by other root store programs, and
actively rejected from NSS inclusion. These comparisons suggest
that Microsoft has an especially permissive root store program.
Each root program serves different users and applications, so we
do not expect their root stores to match or operate identically, but
understanding these differences can provide insight into potential
vulnerability exposure.
Possibly due to NSS’s relative transparency, operational hygiene,
and strictness, we find that all derivative root store providers (e.g.,
NodeJS, Linux distributions, Android) base their roots off of NSS.
Although copying NSS simplifies root store management, this sta-
ble foundation does not necessarily imply root store security. We
find that NSS derivatives do a poor job of keeping up-to-date with
NSS, falling behind by almost two years in some instances. Further-
more, we observe poor NSS copying due to a fundamental design
difference between NSS and derivatives: derivative root stores can
only implement on-or-off root trust and cannot match NSS’s ca-
pabilities for partial distrust. This results in messy trust copying,
such as the re-trusting of partially distrusted Symantec roots by
Debian/Ubuntu, amongst others.
Ultimately, our analysis sheds light on the modern TLS root store
ecosystem, highlighting its current inverted pyramid structure,
the operational practices of the foundational root programs, and
existing pain points around derivative root stores. We conclude
with a discussion of the future of the Web PKI, making suggestions
to guide the expansion of root stores to more devices and clients as
TLS deployment continues to grow.
A CA’s digital identity is a public-key and name mapping, and
root stores typically represent these identities as X.509 digital certifi-
cates. In addition to storing identity, these certificates also contain
constraints on the functionality of a trust anchor. For example, all
X.509 certificates contain a validity period that limit the duration of
a root CA’s utility. Additionally, the Key Usage (KU) and Extended
Key Usage (EKU) X.509 extensions specify the permitted roles (e.g.,
certificate signature, key agreement) and trust purposes (e.g., TLS
server / client authentication) of the certificate. As suggested by the
presence of EKU, the Web PKI is used for more than just TLS server
authentication. CAs that are used for TLS server authentication
often issue certificates for other common purposes, namely email
signatures (i.e., S/MIME) and code signing. The BRs only apply to
publicly-trusted TLS server certificates, and the identity verifica-
tion requirements and procedures for other trust purposes differ. A
root CA that is trusted for one form of identity verification is not
necessarily qualified or trusted for other forms. For this paper, we
focus on TLS server authentication certificates that are primarily
used for HTTPS but can also be used for secure email transport
(STARTTLS).
CAs dictate the constraints found within a certificate, but end
entities such as browsers can also specify their own restrictions.
For instance, Mozilla’s Network Security Services (NSS) and Mi-
crosoft root stores contain additional trust constraints, external to
their trusted root certificates. The BRs only permit CA-specified
EKU trust purposes for intermediate CA certificates, not roots, so
root programs without their own external trust policies have poor
visibility into what their roots are trusted for.
2 BACKGROUND
The Web Public Key Infrastructure (PKI) provides a scalable solu-
tion to TLS authentication by delegating identity verification to a
set of trusted certification authorities (CAs). CAs are third-party
businesses, governments, and non-profit organizations that special-
ize in identity verification of subscribers, which are any entities that
request a CA’s services. CAs generate signed digital certificates
that attest to the binding between a subscriber’s identity (e.g., DNS
name) and cryptographic public key. During TLS authentication,
this attestation is accepted if the CA is trusted by the authenticator.
In this section, we outline the role of CAs, trust anchors, and root
stores, and refer the reader to [87] for a broader overview of TLS.
All user agents that utilize the Web PKI rely on one or more
trusted “root” CAs that comprise its trust anchor store, or root store.
Common expectations for CA behavior, such as secure identity
verification procedures and strict operational security practices
(e.g., hardware-secured cryptographic keys), are codified by the
CA/Browser Forum in its Baseline Requirements (BRs). The BRs
standardize CA requirements, but stop short of prescribing how
root programs should decide which CAs to trust. This role is filled
by the custom CA inclusion and removal policies of each root store
operator. For instance, Mozilla runs a relatively rigorous policy that
requires roots to publicly disclose unconstrained intermediates in
its Common CA Database (CCADB) [99], while other root stores do
not. CAs demonstrate their policy compliance through Certificate
Policies (CP) and Certification Practice Statements (CPS), and many
root stores require regular CA audits to confirm policy adherence.
2
180
3 ROOT STORE PROVIDERS
The first challenge with understanding the landscape of HTTPS
trust anchor stores is to determine who provides them. Operating
systems provide a system-wide store, but HTTPS libraries and
HTTPS clients can supplant these system roots by shipping their
own root store. In order to determine the providers of root stores
used by TLS clients, we took a two pronged approach: looking
at popular user agents in the wild and investigating well-known
operating systems, TLS libraries, and TLS clients.
As a starting point, we collected the top 200 User Agent HTTP
headers (with bots removed) seen during a 10 minute sample of
traffic from a major CDN on April 7, 2021 around 18:00 UTC. We
were unable to acquire multiple/longer samples, and cannot test the
representativeness of our time period. However, we note that a prior
study [94] found that “broadly speaking, this list [of prevalent UAs]
is stable over time.” Table 1 groups User Agents (i.e., client software)
with operating system, and we use this data as a guide for collecting
root stores in common use on the web. In total, we collected the
root stores for 77% of the top 200 UAs. The 23% of user agents for
which we have unknown or no coverage consist of ChromeOS,
less common browsers (e.g., Yandex, Samsung Internet), custom
applications making API calls, or clients that cannot be identified
by their User Agent header. We exclude Yandex and Chrome on
ChromeOS because the source history is not publicly available.
We supplement the popular user agent dataset by expanding
our data collection process (Appendix A) to consider a total of
nine popular mobile and desktop operating systems, which all
OS/User Agent
Android
Chrome Mobile
Samsung Internet
Android
Firefox Mobile
Chrome Mobile WebView
Chrome
Windows
Chrome
Firefox
Electron
Opera
Edge
Yandex Browser
IE
iOS
Mobile Safari
WKWebView
Chrome Mobile iOS
Google
Mac OS X
Safari
Chrome
Firefox
Apple Mail
Electron
ChromeOS
Chrome
Linux
Chrome
Safari
Firefox
Samsung Internet
Unknown
okhttp
Unknown
CryptoAPI
API Clients
Total included
# versions
Included?
48
2
3
1
1
1
23
7
6
4
4
3
3
18
4
2
2
15
14
2
1
1
8
2
1
1
1
3
2
1
16
154 (77.0%)
yes
no
no
yes
no
yes
yes
yes
yes
yes
yes
no
yes
yes
yes
yes
no
yes
yes
yes
no
yes
no
no
no
yes
no