图6.6 Tab补全
这是因为在你按下Tab键的时候，bash会去PATH变量所设置的所有目录里遍历一遍，检查了里面所有的有执行权限的文件，查到了ifconfig文件（命令其实就是个可执行文件嘛）。之所以这么快，是因为他早就把这些重要的东西缓冲进内存了，所以下次别抱怨我们Linux动不动就把你内存占满了哦。
![alt](images/00011.jpeg){.tpzz}**提示：**[Linux系统的内存管理机制是尽量多地使用内存。将空闲的内存用来做缓存。因此bash遍历PATH中的路径时并不是去硬盘读取，而是直接在内存中处理。]{.kai1}
那么如果你再少写个字母呢？比如你只写了if，然后就按Tab键，Bash遍历了一遍PATH中的路径后发现，有4个命令是以if开头的，所以他不知道你要的是哪个命令，于是就不做任何动作。这时候如果你再按一下Tab，他就会提示你：以if开头的命令有if、ifconfig、ifup、ifdown、ifquery。然后你自己看需要的是哪个，照着输入就行了，很交互吧？如果没明白，可以看图6.7所示的效果。
![alt](images/00260.jpeg){.calibre3}
图6.7 Tab提示
这样除了减少按键次数以外，还有一个好处就是你可以不必完全记住整个命令，能够记住前几个字母就可以通过Tab把整个命令回忆出来。
6.2.3 翻旧账------命令的history
有了Tab，用户输入新命令的时候省事了不少，还有一个history功能，可以让用户重复以前输入过的命令的时候省心。
在终端里，如果你想输入上一次输入的命令，按一下向上箭头，就看到了；如果想要再上一次的命令，就再按一下；如果想要再再上一次的命令，就再再按一下；如果想要再再再再再上一次的命令......不怕键盘坏掉你就按吧。
好了，总该有些更靠谱的方法吧。如果想查看很久远以前的命令怎么办？请输入history。这是一个命令，可以显示之前运行过的n条命令，默认情况下n=1000。现在图形界面越来越发达，输入命令的机会越来越少，估计1000条记录都能把去年的命令显示出来了。
![alt](images/00011.jpeg){.tpzz}**提示：**[也可以指定显示最近的n条命令。例如运行：]{.kai1}
![alt](images/00261.jpeg){.calibre3}
[显示最近的20条命令。]{.kai1}
说起来history命令也没啥神奇的，他之所以能够显示曾经运行过的命令，不是因为他有啥水晶球，而是负责接收用户命令的bash会把每一条命令记录下来，写在～/.bash_history文件中。用户输入history的时候，bash再把这个文件打开，显示出里面的内容。
![alt](images/00011.jpeg){.tpzz}**提示：**[history并不像ls那样是独立的命令，而是bash的关键字。即history是否可用与所用的Shell有关，本文所述仅针对bash。]{.kai1}
懒蜗牛输入了fdi这3个字母，然后按了一下Tab键，bash赶紧给他把命令补全，fdi变成了fdisk，懒蜗牛同学感觉省事了不少（其实就少输入了俩字母）。听说这个fdisk是用来给硬盘分区的命令，可不能瞎玩，还是先问问纯爷们儿吧。于是，一阵嚯哈哈哈的笑声又从硬盘里传来了。
![alt](images/00011.jpeg){.tpzz}**提示：**[fdisk需要操作硬盘设备，因此需要加上sudo提升权限才能运行。]{.kai1}
6.2.4 more or less------命令的分页显示
懒蜗牛学习到查看当前进程，运行了一下：
![alt](images/00262.jpeg){.calibre3}
这个命令会列出当前运行着的所有进程。以前在图形界面的伪终端中，懒蜗牛也运行过这个命令，列出了好多进程，一屏显示不下，滚屏滚上去了。懒蜗牛当时拖着伪中端的滚动条看了一下，这个动作如此自然，没有任何异样的感觉。然而这回他是在黑漆漆的、没有图形界面的终端里运行的这个命令，懒蜗牛同学发现了一个严重的问题------滚上去的信息怎么看啊？没有滚动条啊！有木有滚动条啊！有木有！！
【more】
好，我们让懒蜗牛同学自己咆哮一会儿去，咆哮的蜗牛我伤不起啊。不就是想向上滚屏嘛，很简单，有快捷键，Shift+PageUP组合键是向上翻页，Shift+PageDown组合键是向下翻页，就这样。
当然，可能光滚屏还不够，有时候想把命令输出的东西翻来覆去慢慢看，有什么办法没？办法肯定是有的，当初的前辈们都是生活在命令行下的。他们没事编译个软件，运行个测试脚本，输出的提示动不动就好几百行，一屏根本显示不下，除非用的是32寸宽屏液晶显示器，还得竖着放。
如果显示不下了，后面的内容就会把前面的内容"顶"上去。"楼主"固然是看不见了，什么"沙发"、"板凳"、"地板"的也一样没希望，只能看到最后那几十条。那么想看前面的内容怎么办？虽然可以用Shift+PageUP组合键来向上翻页，但也麻烦。一般人都是习惯从上往下看的，倒着往上翻就别扭了。那么怎么办呢？这时候more就该出场了。
![alt](images/00011.jpeg){.tpzz}**提示：**[使用Shift+PageUP组合键向上翻看的页数受缓冲区大小的限制。修改缓冲区大小需要重新编译内核，此处不做讨论。]{.kai1}
more是一个用来阅读文本的命令行软件，他有分页显示的功能。他可以从文件或数据流中获取数据，把所有要输出的内容先显示出一屏来，等着用户按回车键，之后再显示第2屏，直到显示完全部内容。当然，用户也可以不等显示完全部就中途按q键退出。
那么具体怎么用呢？就比如刚才懒蜗牛同学这种情况，运行下面的命令：
![alt](images/00263.jpeg){.calibre3}
其中有个"\|"符号，这个符号叫做管道符，就在你键盘上的"\\"键处。这个符号的意思就是把前面一个命令的输出内容交给后面一个命令作为数据输入。于是，ps
-A命令输出的那些字符就像一大堆泔水一样哗啦啦地都流到more这里了，more就把这些东西先整个大桶缓存起来，然后盛出一碗来给你看："您看有没有想吃的？"，你看完了之后，他再去盛第2碗，第3碗......直到你把一大桶泔水都检阅完了，more才结束工作（当然，你要是坚持不到最后就吐了，记得按q键退出）。
有了more就满足了么？不，还有他的死对头，less。
【less】
less实现的功能和more基本一样，也是用来分屏输出的，同行是冤家嘛。不同的是，less比more强大，因此，在我们这里流行着这样一句逻辑混乱的话：less
is more than more。
more只能一页一页往下看，看完了就退出，不能向上翻。less可以上下翻页，看过去的东西可以按向上键或者PageUp键翻回去看，比more更人性化一点。另外，都看完了之后less是不会自动退出的，一定要按q键退出。
![alt](images/00011.jpeg){.tpzz}**提示：**[less和more都可以直接查看文件，运行命令：]{.kai1}
![alt](images/00264.jpeg){.calibre3}
[或者]{.kai1}
![alt](images/00265.jpeg){.calibre3}
[就可以查看文件内容，前提是该文件是一个文本文件。]{.kai1}
【只做一个功能，但要做到最好】
通过这两个命令，您大概可以感受到我们Linux系统和微软公司的系统的不同理念。用过DOS系统的都知道里面有个dir命令，和我们的ls一样，都是显示文件用的。当文件很多的时候，dir命令有专门的参数可以实现分屏显示，而ls命令就没有，只能一下子显示出来。为什么？因为分屏显示的事情是由more和less负责的，完全可以通过ls\|more这样的组合实现分屏显示的功能。
![alt](images/00011.jpeg){.tpzz}**提示：**[Ubuntu系统中也有dir命令，与ls命令完全一样，仅为照顾用户习惯。]{.kai1}
Linux软件的设计理念是"只做一个功能，但要做到最好"。每个程序只专注于一种功能的实现，而通过多个程序的组合可以实现任何功能。
试想如果没有more和less命令，ls就要有负责分屏显示的功能。那么history命令是不是也要处理分屏显示的问题呢？和ps命令一样，也得处理分屏显示的问题。那么所有输出行比较多的命令都要自己负责分屏显示，这些命令的源代码中就都要有负责分屏显示的部分，这是一种无谓的重复劳动。而且各自分别实现分屏显示，效果多半也不一样（因为这些命令多半不是同一个人写的），可能有的命令是按空格显示下一行，有的是按n键显示下一行等。与其这样，不如把相同的功能独立出来，成为一个统一的、单独的命令。
好了，说了这么多，这回懒蜗牛也终于结束了咆哮，回到图形界面找狐狸妹妹去查怎么在命令行下翻页了。
6.2.5 通配符
说起命令行下省事的办法，还有个东西不能不提，就是通配符。
【DOS的通配符处理】
过去用过DOS系统的同学可能知道，通配符就是"\*"和"?"两个符号。"\*"号可以代表任意多个任意的字符，"?"号代表任意一个字符。不过DOS系统下通配符的实现是需要每一个命令对通配符都理解的。
比如说用户在DOS系统里运行：
![alt](images/00266.jpeg){.calibre3}
这个命令的意图是，把当前目录下所有以.jpg结尾的文件复制到aaa目录中。那么这个命令DOS系统是怎么处理的呢？DOS这个懒得要死的家伙肯定啥也不管，只把copy叫醒，然后告诉他："用户让我告诉你复制'\*.jpg'到'aaa'，快干活去吧！"他根本不管\*.jpg是什么意思，只能由copy去理解：\*.jpg就是所有的以.jpg为扩展名的文件，所以用户给他的任务就是复制（因为他只会复制，别的任务不会叫他来）当前目录下的所有.jpg文件，以及.JPG文件，以及.Jpg文件，以及.jPg文件，以及......（谁让DOS不区分大小写呢）复制到当前目录下的aaa目录去。
这样做有什么不好呢？这跟刚才分屏显示的问题一样，每一个可能需要支持通配符的命令都要自己实现对通配符的处理。重复开发，浪费资源。
【Linux的通配符处理】
我们Linux下的Shell们就不这么懒了。就拿bash来说吧，也一样支持通配符，也是用"\*"代表任意个任意字符，用"?"代表某一个任意字符。不过，通配符的解释都是由bash来做的。
还比如复制文件，用户运行：
![alt](images/00267.jpeg){.calibre3}
这条命令输入进去之后，先交到bash这里，bash一看有通配符，就需要自己进行解释。"\*"代表任意长个任意字符嘛，那么把通配符进行替代之后，得到真正要执行的命令其实是（这里假设当前目录下有11111.jpg、22222.jpg、33333.jpg、44444.jpg这4个以.jpg结尾的文件）：
![alt](images/00268.jpeg){.calibre3}
也就是说，bash用当前目录下的所有JPG文件的文件名代替了\*.jpg这个字段，然后再叫醒cp，把扩展后的参数传给他。cp看到的就是没有星号的命令了，他接收到的就是明确的命令："复制当前目录下的11111.jpg、22222.jpg、33333.jpg、44444.jpg这4个文件，到当前目录下的aaa目录下。"这样做的好处是明显的：bash下的各种软件都不需要自己处理通配符的问题，减少了不必要的重复开发。
当然，也有的时候是不需要bash对特殊符号进行扩展的。比如懒蜗牛可能就有个文件叫做"\*.jpg"，就叫这么个特殊的名字。要想复制这个文件而不是所有的jpg文件，该怎么办呢？也好办，就这样：
![alt](images/00269.jpeg){.calibre3}
在"\*"前面加上一个"\\"就可以了，"\\"的意思就是后面的字符是个普通字符，告诉bash不要进行任何处理。
[6.3 Shell编程]{.kai}
懒蜗牛同学经过一段时间的学习，已经对我们Ubuntu系统里面的基本命令了如指掌了。接下来他又想要干点什么更有意思的事情呢？
6.3.1 把命令打包执行
【日复一日】