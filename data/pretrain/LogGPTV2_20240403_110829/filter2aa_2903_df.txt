DSL）[8]。
Igfxdbg内部会通过IOCTL接口与自己的内核态搭档Igfxdcd建立通
信。Igfxdcd的全称是英特尔图形调试伙伴驱动（Intel(R) Graphics Debug
Companion Driver），是专门用来支持Gen GPU调试的，它在内部会与
英特尔显卡驱动的内核态模块IGDKMD一起管理GPU硬件的调试设施，
并与运行在GPU上的系统过程通信，接收调试事件。
在开源的Gdbserver代码中，intel-gen-low.c中包含了较多的新增逻
辑，包括调用igfxdbg函数，比如用于初始化的igfxdbg_Init函数。
如果遇到Gdbserver无法启动，那么一个常见的原因是igfxdcd驱动
没有加载，可以尝试在具有管理员权限的控制台窗口执行net start
igfxdcd命令启动该驱动。
启动GdbServer后，Code-Builder插件会启动定制过的GDB。GDB启
动后一方面会通过网络套接字（socket）与GdbServer连接，另一方面会
通过GDB/MI接口（GDB与图形前端通信的接口）与Visual Studio进程和
Code-Builder通信。
为了便于检查上述过程可能出现的问题，Code-Builder会在Visual
Studio的输出（Output）窗口输出一些调试信息，如清单11-7所示。
清单11-7 GT调试器在Visual Studio中输出的调试信息
INTEL_GT_DEBUGGER:(148960848)Received a program load complete event for pi
d: 14168
INTEL_GT_DEBUGGER:(148960868)Attempting to start a debug session...
INTEL_GT_DEBUGGER:(148960868)Verifying environment settings on host...
INTEL_GT_DEBUGGER:(148960868)Verifying environment settings on target loca
lhost...
INTEL_GT_DEBUGGER:(148961933)Verifying registry settings on target localho
st...
INTEL_GT_DEBUGGER:(148962721)Starting gdbserver on localhost
INTEL_GT_DEBUGGER:(148964238)Attempt 1/3 failed: One or more errors occurr
ed.
INTEL_GT_DEBUGGER:(148964287)Successfully launched gdbserver on localhost,
 pid = 12856
INTEL_GT_DEBUGGER:(148964287)Starting gdb on the host machine
在上面的调试信息中，第1列代表GT调试器的全名，括号当中是时
间戳，而后是具体的消息。第1行和第2行表示Code-Builder接收到Visual
Studio的通知，尝试开始新的调试会话。第3～5行验证主机端和目标端
的环境设置。GT调试器调试时需要禁止GPU的抢先调度
（EnablePreemption = 0），并禁止Windows系统的超时检测和复位机
制，将代表检测级别的TdrLevel设置为0。这两个表项中，后者就在如
下表键下。
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\GraphicsDrivers
前者在上面表键的Scheduler子键下。
第6行显示启动GdbServer。第7行表示启动成功。第8行启动GDB。
11.13.2 调试事件
GT调试器也使用了“调试事件驱动”的设计思想。目前定义的调试
事件有7种，见表11-5。
表11-5 GT调试器的调试事件
事 件 名
枚举常量值
说  明
eGfxDbgEventDeviceExited
1
被调试任务退出
eGfxDbgEventThreadStopped
2
算核线程因为遇到断点等原因中断
eGfxDbgEventThreadStarted
3
算核线程开始
eGfxDbgEventKernelLoaded
4
算核加载
eGfxDbgEventThreadExited
5
算核线程退出
eGfxDbgEventKernelUnloaded
6
算核卸载
eGfxDbgEventStepCompleted
7
单步完成
表11-5中的事件定义可以分为4类。算核模块加载和卸载代表空间
的变化，与CPU端调试时的模块加载和卸载事件非常类似。调试器根据
这两个事件维护断点和模块信息。线程的开始和结束代表GPU线程的开
始和结束。任务退出相当于CPU调试中的进程退出。剩下的两个
eGfxDbgEventThreadStopped和eGfxDbgEventStepCompleted都属于异常
（Exception）类事件，底层关联密切，把二者定义为异常事件应该更合
理一些。
调试支持库（DSL）中包含了等待调试事件的函数，名为
igfxdbg_WaitForEvent。也有用于恢复执行的函数，名为
igfxdbg_ContinueExecution。还有一个名叫igfxdbg_StepOneInstruction的
函数，用于以单步方式恢复执行。
11.13.3 符号管理
调试符号是沟通二进制世界和源程序的桥梁，是很多调试功能的基
础。与Nvidia和AMD的做法类似，英特尔的OpenCL编译器也使用
DWARF格式的调试符号。在DSL中，一个名为igfxdbginfo的模块专门
用于处理符号信息，包括从ELF格式的GPU代码模块中提取DWARF信
息，以及解析符号等。
可能是为了某种便利，在使用GT调试器时，它会产生一个名为
default.gtelf的临时文件。比如在VS的模块列表中，有时可以看到如下模
块。
default.gtelf    C:\Users\ge\default.gtelf    N/A    Yes    Symbols not lo
aded.        1                Intel GPU Stub
在GDB中，也可以使用file命令加载这个文件，然后使用info func等
命令观察这个模块中的算核函数信息。
11.13.4 主要功能
在GT调试器中，可以访问Gen的所有通用寄存器文件（GRF）和架
构寄存器文件（ARF）。其工作原理是调用DSL中的
igfxdbg_ReadGrfBlock 和igfxdbg_WriteRegisters等接口。
使用GT调试器的反汇编功能，可以观察Gen的EU指令，这是通过
igfxdisasmstub64.dll模块启动单独的反汇编程序igfxdisasm.exe来实现
的。GT调试器也支持在EU汇编级别单步跟踪。
GT调试器支持各种形式的代码类断点，在内部像下面这样调用
DSL函数。
igfxdbg_SetBreakpoint (td.kernel_handle, (unsigned)addr, &breakpoint);
另外，当在Visual Studio中调试OpenCL程序时，使用图11-16这样
的调试模型，可以同时调试CPU端的代码和GPU端的代码，比如可以在
两种类型的代码里设置断点。
11.13.5 不足
GT调试器的第一个不足是不支持对数据设置监视点，在GDB的监
视点函数中，可以看到一条“目前不支持监视点”的注释。
static int
intel_gen_stopped_by_watchpoint (void)
{
  /* No support for watchpoints for the time being.  */
  return 0;
}
另外，GT调试器支持的最低硬件版本是Gen7.5。虽然在igfxdcd驱
动中支持更老一些的版本，但是运行时和SR模块只支持Gen7.5或者更高
版本。
上面所描述的GT调试器来自2017 R2版本的英特尔OpenCL SDK。
发布时间是2017年12月，在作者写作本章的几个月时间中（截至2018年
5月25日），一直没有新的版本。目前版本给作者的印象是不够稳定，
设置在算核函数中的断点时常成为徒劳，不能落实和命中。总体来说，
目前的版本只能算是可以工作了，离稳定可靠还有较大距离，距离简
洁、高效和优雅就更远了。
11.14 本章小结
本章从英特尔GPU的简要历史开始，按照从硬件到软件，再到调试
设施的顺序进行了深入讨论。11.2节比较全面地介绍了Gen架构GPU的
硬件结构，然后介绍了多种编程接口。11.8介绍了EU的指令集，随后介
绍了Gen的内存管理和异常机制。11.11节开始介绍Gen GPU的调试设
施，包括断点支持、单步机制等。最后通过GT调试器介绍了交叉调试
模型和顶层的调试功能。
80386的诸多开创性设计为英特尔在CPU时代的领先打下坚实基
础。某种程度上说，G965在GPU历史上也具有里程碑的意义，包含很
多开创性的设计，但出于种种原因，英特尔在GPU时代没能占据头号位
置。不过，这个芯片巨头已经清醒地认识到GPU的意义，如本章开篇所
言，英特尔正在集结力量开发新的GPU，让我们拭目以待。
参考资料
[1] List of Intel graphics processing units.
[2] Intel’s Next Generation Integrated Graphics Architecture –Intel®
Graphics Media Accelerator X3000 and 3000.
[3] The Compute Architecture of Intel Processor Graphics Gen9.
[4] HARDWARE SPECIFICATION – PRMS.
[5] Intel Processor Graphics (Presented by Intel).
[6] Intel Xeon Processor E3-1585L v5.
[7] GPU Debugging: Challenges and Opportunities.
第12章 Mali GPU及其调试设施
智能手机、数码相机、网络摄像头等移动设备的流行，让可以集成
到SoC中的低功耗GPU得到了充分发展。ARM公司旗下的Mali GPU便是
其中之一。本章前半部分介绍Mali GPU的概况和架构特征，包括2010年
推出至今还在广泛使用的Midgard架构，以及2016年推出的Bifrost架
构。后半部分先介绍Mali GPU的图形调试器，然后介绍在调试和调优中
都使用的Gator系统、Kbase驱动的调试设施，以及Caiman、devlib和离
线编译器等。
12.1 概况
为了帮助读者理解后面的技术内容，本节将简要介绍Mali GPU的发
展经历和概况，包括它的起源、架构演进路线和团队等。
12.1.1 源于挪威
Mali GPU起源于挪威科技大学的一个研究项目，时间是在20世纪90
年代那个诞生了3dfx和Nvidia的时代。2001年，研究Mali的小组从挪威
科技大学独立出来，成立了一家叫Falanx微系统的公司。Falanx最初的
目标是进军PC显卡市场，与ATI、Nvidia等大牌一争高下。然而，在迎
来辉煌之前资金就出了问题。
在资金困难的境况下，Falanx调整了方向，从竞争激烈的PC显卡市
场转到门槛较低的SoC领域，用有限的资源设计低功耗的GPU。他们努
力优化设计，尽可能减少晶体管的数量，占用尽可能小的芯片面积，以
便他们的设计可以更容易地集成到移动设备中。方向调整后，第一代
Mali GPU诞生了，Falanx也有了第一批客户。Zoran公司在它的Approch
5C SoC中使用了Mali-55。这个芯片曾被LG用在Viewty系列手机产品
中。Viewty手机的最大亮点是带有500万像素的数字相机，并具有强大
的录像和多媒体能力，能以每秒120帧的速度录像，然后慢动作回放。
这些功能很可能都有Mali的贡献。
12.1.2 纳入ARM
随着移动设备和SoC市场的不断升温，ARM公司的业绩日益上升。
2006年6月，ARM收购了Falanx。从此，Falanx变为“ARM挪威”（Arm
Norway），Mali GPU被纳入ARM旗下。
12.1.3 三代微架构
纳入ARM旗下后的第一个新设计名叫Mali-200，与后来的Mali-
300、Mali-400、Mali-450和Mali-470都属于Utgard微架构。Utgard微架
构的设计风格还属于固定功能加速流水线，内部包含多个分立的着色
器，不是统一结构的通用着色器。
2010年11月，ARM宣布Mali-T604 GPU[11]，很快被三星的猎户座
SoC（Exynos 5250）采用，并于2011年第四季度产品化，用在三星的智
能手机和平板电脑中。T604内部采用了统一的通用着色器设计，支持1
～4个着色器核心。T604与后来推出的T624、T628、T658、T678等GPU
统称T600系列[2]。T600与其后的T700、T800都属于Midgard微架构。自
2010年发布后，包含Midgard微架构GPU的SoC和产品从2011年起陆续推
出，仅仅2013年的发售数量就接近4亿[3]。
在2016年5月的Computex技术大会上，ARM公开了新一代的Mali
GPU微架构，名叫Bifrost。与上一代Midgard相比，Bifrost最大的改变是
把指令集从原来的SIMD格式改为标量指令。第9章介绍过，Nvidia的
GPU从G80开始便使用标量指令集。
图12-1归纳了纳入ARM旗下后的三代Mali GPU微架构，以及每一
代的主要GPU，箭头下的文字概括了每一代微架构的关键特征。这幅图
来自ARM公司官方的技术资料。
图12-1 Mali GPU的三代微架构和主要产品
从图12-1中也可以看出 Mali GPU 的命名规则，三种微架构的 GPU
名称格式分别为Mali-XXX、Mali-TXXX和Mali-GXX，X代表阿拉伯数
字，前两者是三位数字，后者是两位数字。