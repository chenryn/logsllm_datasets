This file contains the layout of the UI. The Design View window shows
two representations of this file:
Download from finelybook PI:EMAIL
65
Note XAML stands for eXtensible Application Markup Language,
which is the language that Universal Windows Platform
applications use to define the layout for the GUI of an application.
You will learn more about XAML as you progress through the
exercises in this book.
At the top is a graphical view depicting the screen of, by default, a
Surface Book. The lower pane contains a description of the contents of
this screen using XAML. XAML is an XML-like language used by
UWP applications to define the layout of a form and its contents. If you
have knowledge of XML, XAML should look familiar.
Download from finelybook PI:EMAIL
66
In the next exercise, you will use the Design View window to lay out the
UI for the application, and you will examine the XAML code that this
layout generates.
Tip Close the Output and Error List windows to provide more
space for displaying the Design View window.
Note Before going further, it is worth explaining some
terminology. In traditional Windows applications, the UI consists
of one or more windows, but in a Universal Windows Platform
app, the corresponding items are referred to as pages. For the sake
of clarity, I will simply refer to both items by using the blanket
term form. However, I will continue to use the word window to
refer to items in the Visual Studio 2017 IDE, such as the Design
View window.
In the following exercises, you will use the Design View window to add
three controls to the form displayed by your application. You will also
examine some of the C# code automatically generated by Visual Studio 2017
to implement these controls.
Create the user interface
1. Click the Toolbox tab that appears in the margin to the left of the form
in the Design View window.
The Toolbox appears and displays the various components and controls
that you can place on a form. By default, the General section of the
toolbox is selected, which doesn’t contain any controls (yet).
2. Expand the Common XAML Controls section.
Download from finelybook PI:EMAIL
67
This section displays a list of controls that most graphical applications
use.
TipThe All XAML Controls section displays a more extensive list
of controls.
3. In the Common XAML Controls section, click TextBlock, and then drag
the TextBlock control onto the form displayed in the Design View
window.
Tip Be sure that you select the TextBlock control and not the
TextBox control. If you accidentally place the wrong control on a
form, you can easily remove it by clicking the item on the form
and then pressing Delete.
A TextBlock control is added to the form (you will move it to its correct
location in a moment), and the Toolbox disappears from view.
Tip If you want the Toolbox to remain visible but not hide any part
of the form, at the right end of the Toolbox title bar, click the Auto
Hide button (it looks like a pin). The Toolbox is docked on the left
side of the Visual Studio 2017 window, and the Design View
window shrinks to accommodate it. (You might lose a lot of space
if you have a low-resolution screen.) Clicking the Auto Hide
button once more causes the Toolbox to disappear again.
Download from finelybook PI:EMAIL
68
4. The TextBlock control on the form is probably not exactly where you
want it. You can click and drag the controls you have added to a form to
reposition them. Using this technique, move the TextBlock control so
that it is positioned toward the upper-left corner of the form. (The exact
placement is not critical for this application.) Notice that you might need
to click away from the control and then click it again before you can
move it in the Design View window.
The XAML description of the form in the lower pane now includes the
TextBlock control, together with properties such as its location on the
form, governed by the Margin property, the default text displayed by
this control in the Text property, the alignment of text displayed by this
control as specified by the HorizontalAlignment and VerticalAlignment
properties, and whether text should wrap if it exceeds the width of the
control.
Your XAML code for the TextBlock will look similar to this (your
values for the Margin property might be slightly different, depending on
where you positioned the TextBlock control on the form):
Click here to view code image
The XAML pane and the Design View window have a two-way
relationship with each other. You can edit the values in the XAML pane,
and the changes will be reflected in the Design View window. For
example, you can change the location of the TextBlock control by
modifying the values in the Margin property.
5. On the View menu, click Properties Window (it is the last item in the
menu).
If it was not already displayed, the Properties window appears at the
lower right of the screen, under the Solution Explorer pane. You can
specify the properties of controls by using the XAML pane under the
Design View window, but the Properties window provides a more
convenient way for you to modify the properties for items on a form, as
Download from finelybook PI:EMAIL
69
well as other items in a project.
The Properties window is context sensitive in that it displays the
properties for the currently selected item. If you click the form displayed
in the Design View window (outside the TextBlock control), you can see
that the Properties window displays the properties for a Grid element. If
you look at the XAML pane, you should see that the TextBlock control
is contained within a Grid element. All forms contain a Grid element
that controls the layout of displayed items; for example, you can define
tabular layouts by adding rows and columns to the Grid.
6. In the Design View window, click the TextBlock control. The Properties
window displays the properties for the TextBlock control again.
7. In the Properties window, expand the Text property of the TextBlock
control. Change the FontSize property to 20 pt and then press Enter.
This property is located next to the drop-down list box containing the
name of the font, which will show Segoe UI:
Note The suffix pt indicates that the font size is measured in
points, where 1 point is equal to 1/72 of an inch.
Download from finelybook PI:EMAIL
70
8. In the XAML pane below the Design View window, examine the text
that defines the TextBlock control. If you scroll to the end of the line,
you should see the text FontSize=”26.667”. This is an approximate
conversion of the font size from points to pixels (3 points is assumed to
be roughly 4 pixels, although a precise conversion would depend on
your screen size and resolution). Any changes that you make using the
Properties window are automatically reflected in the XAML definitions,
and vice versa.
Type over the value of the FontSize attribute in the XAML pane and
change it to 24. The font size of the text for the TextBlock control in the
Design View window and the Properties window changes.
9. In the Properties window, examine the other properties of the TextBlock
control. Feel free to experiment by changing them to see their effects.
Notice that as you change the values of properties, these properties are
added to the definition of the TextBlock control in the XAML pane.
Each control that you add to a form has a default set of property values,
and these values are not displayed in the XAML pane unless you change
them.
10. Change the value of the Text property of the TextBlock control from
TextBlock to Please enter your name. You can do this either by editing
the Text element in the XAML pane or by changing the value in the
Properties window (this property is located in the Common section in
the Properties window).
Notice that the text displayed in the TextBlock control in the Design
View window changes.
11. Click the form in the Design View window, and then display the
Toolbox again.
12. In the Toolbox, click and drag the TextBox control onto the form. Move
the TextBox control so that it is directly below the TextBlock control.
Download from finelybook PI:EMAIL
71
Tip When you drag a control on a form, alignment indicators
appear automatically. These give you a quick visual cue to ensure
that controls are lined up neatly. You can also manually edit the
Margin property in the XAML pane to set the left-hand margin to
the same value of that for the TextBlock control.
13. In the Design View window, place the mouse over the right edge of the
TextBox control. The mouse pointer should change to a double-headed
arrow, indicating that you can resize the control. Drag the right edge of
the TextBox control until it is aligned with the right edge of the
TextBlock control above.
14. While the TextBox control is selected, at the top of the Properties
window, change the value of the Name property from textBox to
userName, as illustrated here:
Download from finelybook PI:EMAIL
72
Note You will learn more about naming conventions for controls
and variables in Chapter 2, “Working with variables, operators,
and expressions.”
15. Display the Toolbox again, and then click and drag a Button control onto
the form. Place the Button control to the right of the TextBox control on
the form so that the bottom of the button is aligned horizontally with the
bottom of the text box.
16. Using the Properties window, change the Name property of the Button
control to OK and change the Content property (in the Common section)
from Button to OK, and then press Enter. Verify that the caption of the
Button control on the form changes to display the text OK.
The form should now look similar to the following figure:
Download from finelybook PI:EMAIL
73
Note The drop-down menu in the upper-left corner of the Design
View window enables you to view how your form will render on
different screen sizes and resolutions. In this example, the default
view of a 13.5-inch Surface Book with a 3000 x 2000 resolution is
selected. To the right of the drop-down menu, two buttons enable
you to switch between portrait view and landscape view. The
projects used in subsequent chapters will use a 13.3-inch Desktop
view as the design surface, but you can keep the Surface Book
form factor for this exercise.
17. On the Build menu, click Build Solution, and then verify that the project
builds successfully.
18. Ensure that the Debug Target drop-down list is set to Local Machine as
shown below. (It might default to Device and attempt to connect to a
Windows phone device, and the build will probably fail). Then, on the
Debug menu, click Start Debugging.
The application should run and display your form. The form looks like
this:
Download from finelybook PI:EMAIL
74
Note When you run a Universal Windows Platform app in debug
mode, a debug toolbar appears near the top of the form. You can
use this toolbar to track how the user is navigating through the
form and monitor how the contents of the controls on the form
change. You can ignore this menu for now; click the double bar at
the bottom of the toolbar to minimize it.
In the text box, you can overtype the existing text with your name, and
then click OK, but nothing happens yet. You need to add some code to
indicate what should happen when the user clicks the OK button, which
is what you will do next.
19. Return to Visual Studio 2017. On the Debug menu, click Stop
Download from finelybook PI:EMAIL
75
Debugging.
Note You can also click the Close button (the X in the upper-right
corner of the form) to close the form, stop debugging, and return to
Visual Studio.
You have managed to create a graphical application without writing a
single line of C# code. It does not do much yet (you will have to write some
code soon), but Visual Studio 2017 actually generates a lot of code for you
that handles routine tasks that all graphical applications must perform, such
as starting up and displaying a window. Before adding your own code to the
application, it helps to have an understanding of what Visual Studio has
produced for you. The following section describes these automatically
generated artifacts.
Examining the Universal Windows Platform app
In Solution Explorer, expand the MainPage.xaml node. The file
MainPage.xaml.cs appears; double-click this file. The following code for the
form is displayed in the Code and Text Editor window:
Click here to view code image
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;
// The Blank Page item template is documented at
Download from finelybook PI:EMAIL
76
http://go.microsoft.com/fwlink/?LinkId=402352&clcid=0x409
namespace Hello
{
    /// 
    /// An empty page that can be used on its own or navigated to
within a Frame.
    /// 
    public sealed partial class MainPage : Page
    {
        public MainPage()
        {
            this.InitializeComponent();
        }
    }
}
In addition to a good number of using directives bringing into scope some
namespaces that most UWP apps use, the file contains the definition of a
class called MainPage but not much else. There is a little bit of code for the
MainPage class known as a constructor that calls a method named
InitializeComponent. A constructor is a special method with the same name
as the class. It runs when an instance of the class is created and can contain
code to initialize the instance. You will learn about constructors in Chapter 7.
The class actually contains a lot more code than the few lines shown in the
MainPage.xaml.cs file, but much of it is generated automatically based on the
XAML description of the form and is hidden from you. This hidden code
performs operations such as creating and displaying the form and creating
and positioning the various controls on the form.
Tip You can also display the C# code file for a page in a UWP app by
clicking Code on the View menu when the Design View window is
displayed.
At this point, you might be wondering where the Main method is and how
the form gets displayed when the application runs. Remember that in a
Download from finelybook PI:EMAIL
77
console application Main defines the point at which the program starts. A
graphical application is slightly different.
In Solution Explorer, you should notice another source file called
App.xaml. If you expand the node for this file, you will see another file called
App.xaml.cs. In a UWP app, the App.xaml file provides the entry point at
which the application starts running. If you double-click App.xaml.cs in
Solution Explorer, you should see some code that looks similar to this:
Click here to view code image
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.ApplicationModel;
using Windows.ApplicationModel.Activation;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;
namespace Hello
{
    /// 
    /// Provides application-specific behavior to supplement the
default Application class.
    /// 
    sealed partial class App : Application
    {
        /// 
        /// Initializes the singleton application object.  This is
the first line of authored code
        /// executed, and as such is the logical equivalent of main()
or WinMain().
        /// 
        public App()
        {
            this.InitializeComponent();
            this.Suspending += OnSuspending;
        }
Download from finelybook PI:EMAIL
78
        /// 
        /// Invoked when the application is launched normally by the
end user.  Other entry points
        /// will be used such as when the application is launched to
open a specific file.
        /// 
        /// Details about the launch request and
process.
        protected override void OnLaunched(LaunchActivatedEventArgs
e)
        {
            Frame rootFrame = Window.Current.Content as Frame;
            // Do not repeat app initialization when the Window
already has content,
            // just ensure that the window is active
            if (rootFrame == null)
            {
                // Create a Frame to act as the navigation context
and navigate to the first page
                rootFrame = new Frame();
                rootFrame.NavigationFailed += OnNavigationFailed;
                if (e.PreviousExecutionState ==
ApplicationExecutionState.Terminated)
                {
                    //TODO: Load state from previously suspended
application
                }
                // Place the frame in the current Window
                Window.Current.Content = rootFrame;
            }
            if (e.PrelaunchActivated == false)
            {
                if (rootFrame.Content == null)
                {
                    // When the navigation stack isn't restored
navigate to the first page,
                    // configuring the new page by passing required
information as a navigation
                    // parameter
                    rootFrame.Navigate(typeof(MainPage),
Download from finelybook PI:EMAIL
79
e.Arguments);
                }
                // Ensure the current window is active
                Window.Current.Activate();
            }
        }
        /// 
        /// Invoked when Navigation to a certain page fails
        /// 
        /// The Frame which failed
navigation
        /// Details about the navigation
failure
        void OnNavigationFailed(object sender,
NavigationFailedEventArgs e)
        {
            throw new Exception("Failed to load Page " +
e.SourcePageType.FullName);
        }
        /// 
        /// Invoked when application execution is being
suspended.  Application state is saved
        /// without knowing whether the application will be
terminated or resumed with the contents
        /// of memory still intact.
        /// 
        /// The source of the suspend request.
        /// Details about the suspend request.
        private void OnSuspending(object sender, SuspendingEventArgs
e)
        {
            var deferral = e.SuspendingOperation.GetDeferral();
            //TODO: Save application state and stop any background
activity
            deferral.Complete();
        }
    }
}
Much of this code consists of comments (the lines beginning “///”) and
other statements that you don’t need to understand just yet, but the key
elements are located in the OnLaunched method, highlighted in bold. This
method runs when the application starts and the code in this method causes
the application to create a new Frame object, display the MainPage form in
Download from finelybook PI:EMAIL
80
this frame, and then activate it. It is not necessary at this stage to fully
comprehend how this code works or the syntax of any of these statements,
but it’s helpful that you simply appreciate that this is how the application
displays the form when it starts running.
Adding code to the graphical application
Now that you know a little bit about the structure of a graphical application,
the time has come to write some code to make your application actually do
something.
Write the code for the OK button
1. In the Design View window, open the MainPage.xaml file (double-click
MainPage.xaml in Solution Explorer).
2. While still in the Design View window, click the OK button on the form
to select it.
3. In the Properties window, click the Event Handlers button for the
selected element.