user space tool, wg(8), is used for this purpose, but future
plans involve integrating this functionality directly into ip(8).
The RTNL subsystem allows for moving the WireGuard
virtual interface between network namespaces. This enables the
sending and receiving sockets (for the outer UDP packets) to
be created in one namespace, while the interface itself remains
in another namespace. For example, a docker(1) or rkt(1)
container guest could have as its sole network interface a
WireGuard interface, with the actual outer encrypted packets
being sent out of the real network interface on the host, creating
end-to-end authenticated encryption in and out of the container.
D. Data Structures and Primitives
While the Linux kernel already includes two elaborate
routing table implementations—an LC-trie [21] for IPv4 and a
radix trie for IPv6—they are intimately tied to the FIB routing
layer, and not at all reusable for other uses. For this reason, a
very minimal routing table was developed. The authors have
had success implementing the cryptokey routing table as an
allotment routing table [10], an LC-trie [21], and a standard
radix trie, with each one giving adequate but slightly diﬀerent
performance characteristics. Ultimately the simplicity of the
venerable radix trie was preferred, having good performance
characteristics and the ability to implement it with lock-less
lookups, using the RCU system [18]. Every time an outgoing
packet goes through WireGuard, the destination peer is looked
up using this table, and every time an incoming packet reaches
WireGuard, its validity is checked by consulting this table, so
performance is in fact important here.
For all handshake initiation messages (section V-D2), the
responder must lookup the decrypted static public key of the
initiator. For this, WireGuard employs a hash table using the
extremely fast SipHash2-4 [1] MAC function with a secret, so
that upper layers, which may provide the WireGuard interface
with public keys in a more complicated key distribution scheme,
cannot mount a hash table collision denial of service attack.
While the Linux kernel’s crypto API has a large collection of
primitives and is meant to be reused in several diﬀerent systems,
the API introduces needless complexity and allocations. Several
10
revisions of WireGuard used the crypto API with diﬀerent
integration techniques, but ultimately, using raw primitives
with direct, non-abstracted APIs proved to be far cleaner
and less resource intensive. Both stack and heap pressure
were reduced by using crypto primitives directly, rather than
going through the kernel’s crypto API. The crypto API also
makes it exceedingly diﬃcult to avoid allocations when using
multiple keys in the multifaceted ways required by Noise. As
of writing, WireGuard ships with optimized implementations
of ChaCha20Poly1305 for the various Intel Architecture vector
extensions, with implementations for ARM/NEON and MIPS on
their way. The fastest implementation supported by the hardware
is selected at runtime, with the ﬂoating-point unit being used
opportunistically. All ephemeral keys and intermediate results
of cryptographic operations are zeroed out of memory after
use, in order to maintain perfect forward secrecy and prevent
against various potential leaks. The compiler must be specially
informed about this explicit zeroing so that the “dead-store”
is not optimized out, and for this the kernel provides the
memzero_explicit function.
In contrast to crypto primitives, the existing kernel im-
plementations of token bucket hash-based rate limiting, for
rate limiting handshake initiation and response messages when
under-load after cookie IP attribution has occurred, have been
very minimal and easy to reuse in WireGuard. WireGuard uses
the Netﬁlter hashlimit matcher for this.
E. FIB Considerations
In order to avoid routing loops, one proposed change for
the Linux kernel—currently posted by the authors to the Linux
kernel mailing list [8]—is to allow for FIB route lookups that
exclude an interface. This way, the kernel’s routing table could
have 0.0.0.0/1 and 128.0.0.1/1, for a combined coverage
of 0.0.0.0/0, while being more speciﬁc, sent to the wg0
interface. Then, the individual endpoints of WireGuard peers
could be routed using the device that a FIB lookup would return
if wg0 did not exist, namely one through the actual 0.0.0.0/0
route. Or more generally, when looking up the correct interface
for routing packets to particular peer endpoints, a route for
an interface would be returned that is guaranteed not to be
wg0. This is preferable to the current situation of needing to
add explicit routes for WireGuard peer endpoints to the kernel
routing table when the WireGuard-bound route has precedence.
This work is ongoing.
Another approach, allude to above, is to use network
namespaces to entirely isolate the WireGuard interface and
routing table from the physical interfaces and routing tables.
One namespace would contain the WireGuard interface and a
routing table with a default route to send all packets over the
WireGuard interface. The other namespace would contain the
various physical interfaces (Ethernet devices, wireless radios,
and so forth) along with its usual routing table. The incoming
and outgoing UDP socket for the WireGuard interface would
live in the second physical interface namespace, not the ﬁrst
WireGuard interface namespace. This way, packets sent in the
WireGuard interface namespace are encrypted there, and then
sent using a socket that lives in the physical interface namespace.
This prevents all routing loops and also ensures total isolation.
Processes living in the WireGuard interface namespace would
have as their only networking means the WireGuard interface,
preventing any potential clear-text packet leakage.
F. Potential Userspace Implementations
In order for WireGuard to have widespread adoption, more
implementations than our current one for the Linux kernel must
be written. As a next step, the authors plan to implement a cross-
platform low-speed user space TUN-based implementation in
a safe yet high-speed language like Rust, Go, or Haskell.
VIII. Performance
WireGuard was benchmarked alongside IPsec in two modes
and OpenVPN, using iperf3(1) between an Intel Core i7-
3820QM and an Intel Core i7-5200U with Intel 82579LM and
Intel I218LM gigabit Ethernet cards respectively, with results
averaged over thirty minutes. The results were quite promising:
Protocol
WireGuard
IPsec #1
IPsec #2
OpenVPN
Conﬁguration
256-bit ChaCha20, 128-bit Poly1305
256-bit ChaCha20, 128-bit Poly1305
256-bit AES, 128-bit GCM
256-bit AES, HMAC-SHA2-256, UDP mode
Throughput
OpenVPN
258
881
825
1,011
1,000
1.541
IPsec #2
IPsec #1
WireGuard
0
200
400
Megabits per Second
600
800
Ping Time
OpenVPN
IPsec #2
IPsec #1
WireGuard
0.508
0.501
0.403
0
0.2
0.4
0.6
0.8
1
Milliseconds
1.2
1.4
1.6
For both metrics, WireGuard outperformed OpenVPN and
both modes of IPsec. The CPU was at 100% utilization during
the throughput tests of OpenVPN and IPsec, but was not
completely utilized for the test of WireGuard, suggesting that
WireGuard was able to completely saturate the gigabit Ethernet
link.
While the AES-NI-accelerated AES-GCM IPsec ci-
pher suite appears to outperform the AVX2-accelerated
ChaCha20Poly1305 IPsec cipher suite, as future chips in-
crease the width of vector instructions—such as the upcoming
AVX512—it is expected that over time ChaCha20Poly1305
11
will outperform AES-NI [3]. ChaCha20Poly1305 is especially
well suited to be implemented in software, free from side-
channel attacks, with great eﬃciency, in contrast to AES, so
for embedded platforms with no dedicated AES instructions,
ChaCha20Poly1305 will also be most performant.
Furthermore, WireGuard already outperforms both IPsec
cipher suites, due to the simplicity of implementation and
lack of overhead. The enormous gap between OpenVPN and
WireGuard is to be expected, both in terms of ping time and
throughput, because OpenVPN is a user space application,
which means there is added latency and overhead of the
scheduler and copying packets between user space and kernel
space several times.
IX. Conclusion
In less than 4,000 lines, WireGuard demonstrates that it
is possible to have secure network tunnels that are simply
implemented, extremely performant, make use of state of
the art cryptography, and remain easy to administer. The
simplicity allows it to be very easily independently veriﬁed
and reimplemented on a wide diversity of platforms. The
cryptographic constructions and primitives utilized ensure high-
speed in a wide diversity of devices, from data center servers
to cellphones, as well as dependable security properties well
into the future. The ease of deployment will also eliminate
many of the common and disastrous pitfalls currently seen
with many IPsec deployments. Described around the time of its
introduction by Furguson and Schneier [9], “IPsec was great
disappointment to us. Given the quality of the people that [sic]
worked on it and the time that was spent on it, we expected
a much better result. [. . .] Our main criticism of IPsec is its
complexity.” WireGuard, in contrast, focuses on simplicity and
usability, while still delivering a scalable and highly secure
system. By remaining silent to unauthenticated packets and
by not making any allocations and generally keeping resource
utilization to a minimum, it can be deployed on the outer edges
of networks, as a trustworthy and reliable access point, which
does not readily reveal itself to attackers nor provide a viable
attack target. The cryptokey routing table paradigm is easy to
learn and will promote safe network designs. The protocol is
based on cryptographically sound and conservative principles,
using well understood yet modern crypto primitives. WireGuard
was designed from a practical perspective, meant to solve real
world secure networking problems.
Acknowledgments
WireGuard was made possible with the great advice and
guidance of many, in particular: Trevor Perrin, Jean-Philippe
Aumasson, Steven M. Bellovin, and Greg Kroah-Hartman.
References
[1]
[2]
J.-P. Aumasson and D. J. Bernstein, Progress in Cryptology - IN-
DOCRYPT 2012: 13th International Conference on Cryptology in India,
Kolkata, India, December 9-12, 2012. Proceedings. Berlin, Heidelberg:
Springer Berlin Heidelberg, 2012, ch. SipHash: A Fast Short-Input PRF,
pp. 489–508.
J.-P. Aumasson, S. Neves, Z. Wilcox-O’Hearn, and C. Winnerlein,
“Blake2: Simpler, smaller, fast as md5,” in Proceedings of the 11th
International Conference on Applied Cryptography and Network Security,
ser. ACNS’13. Berlin, Heidelberg: Springer-Verlag, 2013, pp. 119–135.
[3] D. J. Bernstein. Cpus are optimized for video games. [Online]. Available:
https://moderncrypto.org/mail-archive/noise/2016/000699.html
[4] ——. Tai64,
tai64n,
and tai64na.
[Online]. Available: https:
//cr.yp.to/libtai/tai64.html
[5] ——, “The poly1305-aes message-authentication code,” in Fast Software
Encryption: 12th International Workshop, FSE 2005, Paris, France,
February 21-23, 2005, Revised Selected Papers, ser. Lecture Notes in
Computer Science, vol. 3557. Springer, 2005, pp. 32–49.
[6] ——, “Curve25519: new Diﬃe-Hellman speed records,” in Public Key
Cryptography – PKC 2006, ser. Lecture Notes in Computer Science,
M. Yung, Y. Dodis, A. Kiayias, and T. Malkin, Eds., vol. 3958. Berlin,
Heidelberg: Springer-Verlag Berlin Heidelberg, 2006, pp. 207–228.
[7] ——, “Chacha, a variant of salsa20,” in SASC 2008, 2008.
[8]
J. A. Donenfeld. Inverse of ﬂowi{4,6}_oif: ﬂowi{4,6}_not_oif. [Online].
Available: http://lists.openwall.net/netdev/2016/02/02/222
[9] N. Ferguson and B. Schneier, “A cryptographic evaluation of ipsec,”
Counterpane Internet Security, Inc, Tech. Rep., 2000.
[10] Y. Hariguchi. (2002) Allotment routing table: A fast free multibit trie
based routing table. [Online]. Available: https://github.com/hariguchi/
art/blob/master/docs/art.pdf
[11] T. Hoeiland-Joergensen, P. McKenney, D. Taht, J. Gettys, and E. Dumazet,
“The ﬂowqueue-codel packet scheduler and active queue management
algorithm,” Internet Research Task Force, Internet Engineering Task
Force, RFC, March 2016.
[12] C. Kaufman, P. Hoﬀman, Y. Nir, and P. Eronen, “Internet key exchange
protocol version 2,” Internet Research Task Force, RFC Editor, RFC
5996, September 2010.
[13] S. Kent and R. Atkinson, “Security architecture for ip,” Internet Research
Task Force, RFC Editor, RFC 2401, November 1998.
[14] H. Krawczyk, “Sigma: The ‘sign-and-mac’ approach to authenticated
diﬃe-hellman and its use in the ike-protocols,” in Advances in Cryptology
- CRYPTO 2003, 23rd Annual International Cryptology Conference,
Santa Barbara, California, USA, August 17-21, 2003, Proceedings, ser.
Lecture Notes in Computer Science, vol. 2729. Springer, 2003, pp.
400–425.
[15] ——, Advances in Cryptology – CRYPTO 2010: 30th Annual Cryptology
Conference, Santa Barbara, CA, USA, August 15-19, 2010. Proceedings.
Berlin, Heidelberg: Springer Berlin Heidelberg, 2010, ch. Cryptographic
Extraction and Key Derivation: The HKDF Scheme, pp. 631–648.
[16] A. Langley and Y. Nir, “Chacha20 and poly1305 for ietf protocols,”
Internet Research Task Force, RFC Editor, RFC 7539, May 2015.
[17] K. Lauter and A. Mityagin, Public Key Cryptography - PKC 2006:
9th International Conference on Theory and Practice in Public-Key
Cryptography, New York, NY, USA, April 24-26, 2006. Proceedings.
Berlin, Heidelberg: Springer Berlin Heidelberg, 2006, ch. Security
Analysis of KEA Authenticated Key Exchange Protocol, pp. 378–394.
[18] P. E. McKenny, D. Sarma, A. Arcangeli, A. Kleen, O. Krieger, and
R. Russell, “Read-copy update,” in Ottawa Linux Symposium, Jun 2002,
pp. 338–367.
[19] R. Moskowitz, T. Heer, P. Jokela, and T. Henderson, “Host identity
protocol version 2,” Internet Research Task Force, RFC Editor, RFC
7401, April 2015.
[20] K. Nichols and V. Jacobson, “Controlling queue delay,” Commun. ACM,
vol. 55, no. 7, pp. 42–50, July 2012.
[21] S. Nilsson and G. Karlsson, “Ip-address lookup using lc-tries,” IEEE
Journal on Selected Areas in Communications, vol. 17, no. 6, pp. 1083–
1092, Jun 1999.
[22] T. Perrin. (2016) The noise protocol framework. [Online]. Available:
http://noiseprotocol.org/noise.pdf
[23] E. Rescorla and N. Modadugu, “Datagram transport layer security version
1.2,” Internet Research Task Force, RFC Editor, RFC 6347, January
2012.
[24] K. Winstein and H. Balakrishnan, “Mosh: An interactive remote shell
for mobile clients,” in USENIX Annual Technical Conference, Boston,
MA, June 2012.
[25] X. Zhang and T. Tsou, “Ipsec anti-replay algorithm without bit shifting,”
Internet Research Task Force, RFC Editor, RFC 6479, January 2012.
12