7
2
3
4
5
6
7
2
3
4
5
6
7
∗
# w MEV
2
1
1
1
1
1
2
2
1
1
1
1
1
1
1
1
2
1
2
3
3
2
4
1
2
6
6
7
5
19
1
7
10
8
57
20
# w d∗
3
2
2
2
2
2
5
2
1
1
1
1
8
1
1
14
166
10
11
91
35
14
542
11890
15
180
35
12
1338
118130
19
328
28
10
2610
965097
∗
A parity submatrix w MEV
1, 3
1, 3, 3
1, 3, 3, 3
1, 3, 3, 3, 3
1, 3, 3, 3, 3, 3
1, 3, 3, 3, 3, 3, 3
3, 5
3, 5, 6
3, 5, 6, 7
3, 5, 6, 7, 7
3, 5, 6, 7, 7, 7
3, 5, 6, 7, 7, 7, 7
7, 11
7, 11, 13
7, 11, 13, 14
3, 5, 9, 14, 15
3, 5, 7, 9, 14, 15
3, 5, 7, 11, 13, 14, 15
7, 27
7, 11, 29
7, 11, 19, 29
7, 11, 19, 29, 30
3, 5, 15, 23, 25, 30
7, 11, 13, 14, 19, 21, 25
15, 51
7, 27, 45
7, 27, 45, 56
7, 25, 42, 52, 63
7, 27, 30, 45, 53, 56
7, 11, 21, 25, 45, 51, 62
31, 103
15, 51, 85
15, 54, 90, 113
7, 57, 90, 108, 119
7, 46, 56, 75, 85, 118
7, 27, 45, 51, 86, 110, 120
∗
MEV
(0, 1)
(0, 0, 1)
(0, 0, 0, 1)
(0, 0, 0, 0, 1)
(0, 0, 0, 0, 0, 1)
(0, 0, 0, 0, 0, 0, 1)
(0, 2)
(0, 0, 4)
(0, 0, 0, 3)
(0, 0, 0, 0, 3)
(0, 0, 0, 0, 0, 3)
(0, 0, 0, 0, 0, 0, 3)
(0, 3)
(0, 0, 7)
(0, 0, 0, 14)
(0, 0, 0, 6, 1)
(0, 0, 0, 2, 2, 1)
(0, 0, 0, 0, 1, 2, 1)
(0, 5)
(0, 1, 10)
(0, 0, 4, 14)
(0, 0, 0, 10, 16)
(0, 0, 0, 4, 14, 1)
(0, 0, 0, 1, 8, 0, 1)
(0, 7)
(0, 2, 14)
(0, 0, 8, 18)
(0, 0, 0, 25, 0)
(0, 0, 0, 6, 24, 16)
(0, 0, 0, 2, 16, 18, 1)
(0, 9)
(0, 3, 19)
(0, 0, 12, 26)
(0, 0, 0, 38, 0)
(0, 0, 0, 14, 28, 24)
(0, 0, 0, 3, 24, 36, 16)
d∗
2
3
4
5
6
7
2
3
4
5
6
7
2
3
4
4
4
5
2
2
3
4
4
4
2
2
3
4
4
4
2
2
3
4
4
4
|EL|
|MEL|
1.8
2.9
4.9
8.4
14.2
24.0
2.0
2.8
6.7
13.9
26.4
47.7
2.0
3.4
6.3
16.2
36.7
75.5
2.3
4.0
7.6
14.7
36.3
84.9
2.4
4.6
8.8
16.9
31.8
75.3
2.6
5.1
10.1
19.1
35.7
65.3
Table 3. Evaluation of all (k , m)-code corpi for 1 ≤ k , m ≤ 7.
EV in our work; it counts the number of erasure sets of size
j that are not an erasure pattern, whereas the EV counts the
number of erasure patterns of size j.
Hafner and Rao claim to compute sj by “straightfor-
ward calculation” using techniques they previously devel-
oped [6]. (We note that those previous techniques are based
on the pseudo-inverse of the Generator matrix and efﬁ-
ciently determines if a set of erasures is an erasure pattern
or not, and if not, outputs how to reconstruct data.) The ME
Algorithm efﬁciently calculates the MEL and MEV. We ran
mela and mel2el on the Tanner code from Plank’s RAID
tutorial [12] that Hafner and Rao analyze in §3.2 of [7]. Our
analysis took less than one second and produced an EV com-
patible with the sj they produce.
Plank et al. analyzed the read overhead for LDPC con-
structions [14]. Read overhead is the expected number of
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:52 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007[6] J. L. Hafner, V. Deenadhayalan, K. Rao, and J. A. Tomlin.
Matrix methods for lost data reconstruction in erasure codes.
In FAST-2005: 4th USENIX Conference on File and Storage
Technologies, pages 183–196. USENIX Association, De-
cember 2005.
[7] J. L. Hafner and K. Rao. Notes on reliability models for
non-MDS erasure codes. Technical Report RJ–10391, IBM,
October 2006.
[8] M. G. Luby, M. Mitzenmacher, M. A. Shokrollahi, D. A.
Spielman, and V. Stemann. Practical loss-resilient codes. In
STOC 1997: Proceedings of the 29th annual ACM Sympo-
sium on Theory of Computing, pages 150–159. ACM Press,
1997.
http://cs.anu.edu.au/∼bdm/nauty/.
nauty version 2.2 (including gtools).
[9] B. McKay.
[10] B. McKay. Practical graph isomorphism. Congressus Nu-
merantium, 30:45–87, 1981.
[11] D. A. Patterson, G. Gibson, and R. H. Katz. A case for re-
dundant arrays of inexpensive disks (RAID). In ACM SIG-
MOD International Conference on Management of Data,
pages 109–116, June 1988.
[12] J. S. Plank. Erasure codes for storage applications. Tutorial
slides, presented at FAST-2005: 4th Usenix Conference on
File and Storage Technologies, http://www.cs.utk.
edu/∼plank/plank/papers/FAST-2005.html,
December 2005.
[13] J. S. Plank, A. L. Buchsbaum, R. L. Collins, and M. G.
Thomason. Small parity-check erasure codes - exploration
and observations.
In DSN-2005: The International Con-
ference on Dependable Systems and Networks. IEEE, July
2005.
[14] J. S. Plank and M. G. Thomason. A practical analysis of
low-density parity-check erasure codes for wide-area stor-
age applications. In DSN-2004: The International Confer-
ence on Dependable Systems and Networks, pages 115–124.
IEEE, June 2004.
[15] K. Rao, J. L. Hafner, and R. A. Golding. Reliability for
networked storage nodes. In DSN-2006: The International
Conference on Dependable Systems and Networks, pages
237–248. IEEE, June 2006.
[16] Y. Saito, S. Frølund, A. Veitch, A. Merchant, and S. Spence.
FAB: Building distributed enterprise disk arrays from com-
modity components.
In ASPLOS-XI: 11th International
Conference on Architectural Support for Programming Lan-
guages and Operating Systems, pages 48–58. ACM Press,
2004.
[17] M. Schwartz and A. Vardy. On the stopping distance and the
stopping redundancy of codes. IEEE Trans. on Inf. Theory,
52(3):922–932, 2006.
symbols that must be read to recover all of the data symbols,
assuming a random read order. Read overhead is a good
performance metric for irregular XOR-based erasure codes
deployed in grid storage environments; in LAN settings, we
expect that storage systems would employ systematic codes
and read data symbols (“stripes”) before reading any parity
symbols. More recently, Plank et al. [13] analyzed the read
overhead for codes with small m. Our analyses overlap for
the (k , m)-code corpi with k , m ≤ 5. We believe that the
EV can be transformed into a read overhead metric, but have
not yet determined this transformation.
6. Conclusions
We identiﬁed a new fault tolerance metric for XOR-based
erasure codes, the minimal erasures list (MEL), a concise
representation of that metric, the minimal erasures vector
(MEV), and the Minimal Erasures (ME) Algorithm which
efﬁciently determines the MEL. We applied the implemen-
tation of the ME Algorithm to all systematic XOR-based era-
sure codes with 1 ≤ k , m ≤ 7, and so identiﬁed the most
fault tolerant such codes. We presented empirical evidence
that the ME Algorithm requires less work (over a factor of
80×) than an algorithm that directly generates all erasure
patterns.
Acknowledgements
We thank our colleagues Vinay Deolalikar, Xiaozhou Li,
Craig Soules, Krishnamurthy Viswanathan, and Pascal Von-
tobel for their feedback. We also thank the anonymous DSN
reviewers for their thorough reviews and suggestions.
References
[1] M. Blaum, J. Brady, J. Bruck, and J. Menon. EVENODD:
An efﬁcient scheme for tolerating double disk failures in
RAID architectures. IEEE Trans. Comput., 44(2):192–202,
1995.
[2] P. Corbett, B. English, A. Goel, T. Grcanac, S. Kleiman,
J. Leong, and S. Sankar. Row-diagonal parity for dou-
ble disk failure correction.
In FAST-2004: 3rd USENIX
Conference on File and Storage Technologies, pages 1–14.
USENIX Association, 2004.
[3] R. G. Gallager. Low density parity-check codes. MIT Press,
1963.
[4] J. L. Hafner. WEAVER Codes: Highly fault tolerant era-
sure codes for storage systems. In FAST-2005: 4th USENIX
Conference on File and Storage Technologies, pages 212–
224. USENIX Association, December 2005.
[5] J. L. Hafner. HoVer erasure codes for disk arrays. In DSN-
2006: The International Conference on Dependable Systems
and Networks, pages 217–226. IEEE, June 2006.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:52 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007