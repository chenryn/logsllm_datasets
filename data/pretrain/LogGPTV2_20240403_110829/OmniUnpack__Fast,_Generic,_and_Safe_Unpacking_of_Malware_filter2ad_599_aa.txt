title:OmniUnpack: Fast, Generic, and Safe Unpacking of Malware
author:Lorenzo Martignoni and
Mihai Christodorescu and
Somesh Jha
23rd Annual Computer Security Applications Conference
23rd Annual Computer Security Applications Conference
OmniUnpack: Fast, Generic, and Safe Unpacking of Malware
Lorenzo Martignoni
Universit`a degli Studi di Milano
PI:EMAIL
Mihai Christodorescu
IBM Research∗
PI:EMAIL
Somesh Jha
University of Wisconsin
PI:EMAIL
Abstract
Malicious software (or malware) has become a growing
threat as malware writers have learned that signature-
based detectors can be easily evaded by “packing” the
malicious payload in layers of compression or encryp-
tion. State-of-the-art malware detectors have adopted
both static and dynamic techinques to recover the pay-
load of packed malware, but unfortunately such tech-
niques are highly ineffective. In this paper we propose a
new technique, called OmniUnpack, to monitor the ex-
ecution of a program in real-time and to detect when
the program has removed the various layers of packing.
OmniUnpack aids malware detection by directly provid-
ing to the detector the unpacked malicious payload. Ex-
perimental results demonstrate the effectiveness of our
approach. OmniUnpack is able to deal with both known
and unknown packing algorithms and introduces a low
overhead (at most 11% for packed benign programs).
1. Introduction
Packed malicious programs (malware) pose a sig-
niﬁcant problem in malware analysis, detection, and
forensics. Such programs consist of a decompression
or decryption routine that extracts the garbled payload
from memory and then executes it. We use the term
packed and its variations to refer to malware whose pay-
load is either compressed or encrypted. This unpacking
routine can be invoked once, in which case the whole
payload is extracted to memory in a single step, or mul-
tiple times, when parts of the payload are extracted to
memory at different times. For a security analyst, this
means that the program has to be executed in a con-
tained yet accurate environment before an analysis of
the payload can be performed. For a malware detector,
this means that the scanning for malicious code has to
be postponed until after the start of execution, i.e., when
the program has unpacked its payload.
∗The work presented in this paper was done at University of Wis-
consin.
Malware writers have learned that binary packers
are effective at bypassing signature-based detectors and
at keeping the malware undetected for longer [16]. The
numerous packers available online, each with a vari-
ety of settings, can generate many variants from the
same executable. The percentage of new malware that is
packed is on the rise, from 29% in 2003 to 35% in 2005
up to 80% in 2007 [5, 6, 12]. This situation is further
complicated by the ease of obtaining and modifying the
source code for various packers (e.g., UPX [11]). Mod-
iﬁcations to the source code can introduce changes in
the compression or encryption algorithm, create multi-
ple layers of encryption, or add protection against re-
verse engineering. Currently, new packers are created
from existing ones at a rate of 10–15 per month [16].
As a result, malware writers have a large selection of
tools to pack their malware, to the point that more than
50% of malware samples are simply repacked versions
of existing malware [16].
The traditional approach adopted by malware de-
tectors is to use speciﬁc unpacking routines to recover
the original program, one routine per packing algo-
rithm, before scanning it for malicious code [18] (e.g.,
with ClamAV [4]). This approach is of course lim-
ited to a ﬁxed set of known packers. A technique built
on process emulation was then introduced to perform
generic unpacking, i.e., without requiring knowledge
of the speciﬁc packer. As any other dynamic-analysis
technique, emulation places a time limit on the exe-
cution of the packed program and is restricted by the
ﬁdelity of the emulation environment [18, 16]. Other
forms of generic unpacking use instruction-level trac-
ing inside a real system to determine when the unpacked
code is executed, but incur several orders of magnitude
Desirable feature
Fast for interactive use
Handles unknown packers
Incremental detection
Resilient to anti-debugging
Resilient to SEH attacks
OmniUnpack PolyUnpack ClamAV
X
X
X
X
X
-
X
X
-
-
X
-
-
X
X
Table 1: Unpacker feature comparison.
1063-9527/07 $25.00 © 2007 IEEE
1063-9527/07 $25.00 © 2007 IEEE
DOI 10.1109/ACSAC.2007.15
DOI 10.1109/ACSAC.2007.15
431
431
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:38:39 UTC from IEEE Xplore.  Restrictions apply. 
slowdown due to the use of single-step debugging (e.g.,
PolyUnpack [15]) or whole-system emulation [3].
We present an unpacking technique called Om-
niUnpack that addresses the shortcomings of existing
systems and integrates efﬁciently with any malware-
detection engine (Table 1). Our approach is generic,
being able to handle any type of packer and any type
of self-modifying code. OmniUnpack monitors the pro-
gram execution and tracks written as well as written-
then-executed memory pages. When the program
makes a potentially damaging system call, OmniUn-
pack invokes a malware detector on the written memory
pages. If the detection result is negative (i.e., no mal-
ware found), execution is resumed. We achieve near-
native efﬁciency by tracking memory accesses at the
page level (using non-executable pages or equivalent
hardware mechanisms) instead of the instruction level.
The resulting low overhead of OmniUnpack means that
it can be used for continuous monitoring of a produc-
tion system. Furthermore, OmniUnpack handles any
number of unpacking and self-modiﬁcation layers, each
time communicating to the malware-detection engine
only the newly generated code that needs to be scanned.
The unpacker is implemented with a limited amount of
changes to the operating system and does not use debug-
ging, virtual machine, or emulation, making it immune
to the vast majority of self-protection tricks employed
by malware [18].
This paper makes the following contributions:
• A fast, general-purpose unpacker resilient to anti-
debugging, anti-VM, and anti-emulation tech-
niques. Our unpacker integrates with any oper-
ating system (e.g., Microsoft Windows) and any
malware detector (e.g., ClamAV) without trading
off efﬁciency or unpacking capability.
• An in-memory malware detection strategy inde-
pendent of packing and self-modiﬁcation. Our
unpacker requires the malware detector to decide
whether the program memory contains malicious
code. The malware detector needs no knowledge
of any packing approaches.
• A set of experimental results indicate the 20 times
speedup over existing unpacking tools. Our un-
packer imposes only a small overhead (approxi-
mately 6%) on programs which are not packed and
a slightly higher overhead (approximately 11%) on
packed programs.
2. Overview
Our algorithm follows a simple strategy to han-
dle packed code. All memory writes and the pro-
gram counter are tracked.
If the program counter
reaches a written memory address, we know that
some form of unpacking, self-modiﬁcation, or code
generation occurs in the program. All written-then-
executed (or written-and-about-to-be-executed) mem-
ory locations should then be analyzed by a malware
detector. Starting from this strategy, the goal of our re-
search is to design an unpacking algorithm that achieves
low overhead yet does not compromise the security of
the system.
Consider a program that was packed three times.
An execution trace of the program can be divided into
four different stages, one per unpacking routine and one
for the original code. Figure 1(a) illustrates such an
execution trace, with the unpacking stages in various
xxxxx
shades of gray and the original code indicated by xxxxx
.
xxxxx
xxxxx
OmniUnpack monitors the execution of the program and
records the memory locations that were written and, of
those, the memory locations that were written and then
executed. As long as there are no memory locations that
are written and executed, there is no reason to invoke a
malware detector. If a memory location is written and
is about to be executed, it is a candidate for malware de-
tection. We avoid the overhead of monitoring individ-
ual memory locations by tracking accesses to memory
pages, which group multiple locations into one logical
unit (e.g., memory pages contain 4096 bytes on most
Intel IA-32-based operating systems).
The monitoring of memory accesses is done efﬁ-
ciently inside OmniUnpack through the use of hardware
mechanisms. On systems that provide virtual memory
capabilities, the hardware manages the translation be-
tween virtual and physical addresses, while the oper-
ating system (OS) manages the address mapping used
by the hardware. Additionally, the hardware provides
memory-protection facilities at the page level. When
the virtual-physical address mapping needs to be up-
dated or when the memory protection is violated, the
hardware signals to the OS through an exception and
allows the OS to repair the memory state before con-
tinuing execution. We use these existing features to in-
tercept the ﬁrst moment when a page is written and the
ﬁrst moment when a page is about to be executed after
a write.
Imprecision of page-level tracking. Page-level track-
ing decreases the granularity of monitoring while sig-
niﬁcantly reducing the overhead of memory-access
tracking. As a downside, it is less precise, often result-
ing in spurious detected unpacking stages. The spuri-
ous unpacking stages are caused by multiple layers of
packing and by anti-disassembly and anti-static analy-
sis techniques (which build on self-modifying code and
thus appear to mark the end of an unpacking stage).
Furthermore, code that executes from the same page on
which it writes, even though non-self-modifying, also
generates multiple spurious unpacking stages. Figure 2
432432
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:38:39 UTC from IEEE Xplore.  Restrictions apply. 
(a) Trace of thrice-packed program.
(b) Na¨ıve unpacking & detection.
(c) OmniUnpack-enhanced detection.
t
S
a
r
t
t
S
a
r
t
t
S
a
r
t
xxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxx
H
a
l
t
Scan
Scan
xxx
xxx
xxx
xxx
xxx
xxx
xxx
Scan
Scan
xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
H
a
l
t
xxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxx
H
a
l
t
Packing stages:
xxxxx
xxxxx
xxxxx
xxxxx
xxxxx
xxxxx
Original malicious payload:xxxxx
xxxxx
xxxxx
Invocation of malware detector: Scan
Figure 1: Execution traces for a packed executable: (a) unmonitored, (b) monitored by a simple detector, and (c) mon-
itored by OmniUnpack. The arrow on trace (a) indicates the ideal location for invoking the malware detector. By
approximating this ideal location, OmniUnpack reduces the number of detector invocations and the overall overhead.
shows a comparison of the number of unpacking stages
detected using ﬁne-grained memory-access tracking
(i.e., every machine instruction and every memory byte)
and those detected using coarse-grained memory-access
tracking (every memory page).
It would be unneces-
sarily expensive to invoke the malware detector every
time a written memory page is executed, because such
an event (written-then-executed) is frequent. Written-
then-executed pages are indicative of unpacking but not
indicative of the end of unpacking. In our example from
Figure 1(a), the ideal moment to invoke the malware de-
tector is at end of all three unpacking stages, marked by
the arrow. Unfortunately, the problem of determining
when unpacking is completed is undecidable [15].
Approximation of the end of an unpacking stage. We
approximate the solution using the following heuristic:
if the current execution trace indicates unpacking (i.e.,
memory pages were written and then executed), and if
the program is about to invoke a dangerous system call,
then we assume that an unpacking stage has completed
and we invoke the malware detector. The effect on
the thrice-packed program is illustrated in Figure 1(c),
where the malware detector is invoked only once to scan
all written memory pages. The overhead is thus reduced
by invoking the detector only once, not three times as
in the case of the na¨ıve strategy that scans the memory
every time a written-then-executed page occurs (Fig-
ure 1(b)).
Choice of dangerous system calls. A dangerous sys-
tem call is a system call whose execution can leave
the system in an unsafe state. To achieve its malicious
goal, the malware has to interact with the system. Sys-
tem calls are the mechanism offered by the OS to inter-
act with the host system. For example, a malware that
wants to be executed automatically at system boot has to
replicate itself into a new ﬁle and create the appropriate
registry keys to run the new ﬁle at every boot. All the
system calls in this sequence are mandatory to achieve
the goal, but only a small subset of them are danger-
ous to the system. For example it is not dangerous to
open and read ﬁles, but it is dangerous to create and set
registry keys. Table 2 lists examples of Microsoft Win-
dows system calls we deﬁne as dangerous and monitor.
Any system call that modiﬁes OS state was considered
dangerous in our evaluation.
Continuous monitoring of the execution. Because of
the possibility of multiple unpacking stages and of the
approximation we are using to detect them, it is insufﬁ-
cient to monitor and scan the program only once during
an execution. OmniUnpack implements a continuous-
monitoring approach, where the execution is observed
in its entirety. We note that this is a necessary departure
105
104
103
102
10
1
Observed unpacking stages
I
P
Z
E
G
S
F
W
E
M
k
c
a
P