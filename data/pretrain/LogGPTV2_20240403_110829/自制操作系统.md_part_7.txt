13
是8位呢？这是因为指令里指定了“BYTE”。同样，我们还可以写成：
MOV WORD [678],123
14
在这种情况下，内存地址中的678号和旁边的679号都会做出反应，一共是16位。这时，123
被解释成一个16位的数值，也就是0000000001111011，低位的01111011保存在678号，高位的
15
00000000保存在旁边的679号。
像这样在汇编语言里指定内存地址时，要用下面这种方式来写：
16
图灵社区会员 metorm 专享 尊重版权
36 …… 第2天：用C语言编写应用程序
数据大小 [地址]
这是一个固定的组合。如果我们指定“数据大小”为BYTE，那么使用的存储单元就只是地
址所指定的字节。如果我们指定“数据大小”为WORD，则相邻的一个字节也会成为这个指令的
操作对象。如果指定为DWORD，则与WORD相邻的两个字节，也都成为这个指令的操作对象（共
4个字节）。这里所说的相邻，指的是地址增加方向的相邻。
至于内存地址的指定方法，我们不仅可以使用常数，还可以用寄存器。比如“BYTE [SI]”、
“WORD [BX]”等等。如果SI中保存的是987的话，“BYTE [SI]”就会被解释成“BYTE [987]”，
即指定地址为987的内存。
虽然我们可以用寄存器来指定内存地址，但可作此用途的寄存器非常有限，只有BX、BP、
SI、DI这几个。剩下的AX、CX、DX、SP不能用来指定内存地址，这是因为CPU没有处理这种
指令的电路，或者说没有表示这种处理的机器语言。没有对应的机器语言当然也就不能进行这样
的处理了，如果有意见的话，就写邮件找英特尔的大叔们吧（笑）。笔者没有勇气找英特尔的大
叔们抱怨，所以想把DX内存里的内容赋值给AL的时候，就会这样写：
MOV BX, DX
MOV AL, BYTE [BX]
■■■■■
根据以上说明我们知道可以用下面这个指令将SI地址的1字节内容读入到AL。
MOV AL, BYTE [SI]
图灵社区会员 metorm 专享 尊重版权
2 继续开发 …… 37
可是MOV指令有一个规则①，那就是源数据和目的数据必须位数相同。也就是说，能向AL
1
里代入的就只有BYTE，这样一来就可以省略BYTE，即可以写成：
MOV AL, [SI] 2
哦，这样就与程序中的写法一样了。现在总算把这个指令解释清楚了，所以这个指令的意思
就是“把SI地址的1个字节的内容读入AL中”。 2
■■■■■
20
ADD是加法指令。若以C语言的形式改写“ADD SI,1”的话，就是SI=SI+1。“add”的英文
原语意为“加”。
21
CMP是比较指令。或许有人想，比较指令是干什么的呢？简单说来，它是if语句的一部分。
譬如Ｃ语言会有这种语句：
22
if(a==3){ 处理; }
即对a和3进行比较，将其翻译成机器语言时，必须先写“CMP a,3”，告诉CPU比较的对象， 7
然后下一步再写“如果二者相等，需要做什么”。
这里是“CMP AL,0”，意思就是将AL中的值与0进行比较。这个指令源自英文中的compare， 8
意为“比较”。
JE是条件跳转指令中之一。所谓条件跳转指令，就是根据比较的结果决定跳转或不跳转。就 9
JE指令而言，如果比较结果相等，则跳转到指定的地址；而如果比较结果不等，则不跳转，继续
执行下一条指令。因此， 10
CMP AL, 0
JE fin
11
这两条指令，就相当于：
12
if (AL == 0) { goto fin; }
这条指令源自于英文“jump if equal”，意思是如果相等就跳转。顺便说一句，fin是个标号，
它表示“结束”（finish）的意思，笔者经常使用。 13
■■■■■ 14
INT是软件中断指令。如果现在就讲中断机制的话，肯定会让人头昏脑胀的，所以我们暂时
先把它看作一个函数调用吧。这个指令源自英文“interrupt”，是“中途打断”的意思。 15
——————————
16
①如果违反这一规则，比如写“MOV AX,CL”的话，汇编语言就找不到相对应的机器语言，编译时会出错。
图灵社区会员 metorm 专享 尊重版权
38 …… 第2天：用C语言编写应用程序
电脑里有个名为BIOS的程序，出厂时就组装在电脑主板上的ROM①单元里。电脑厂家在BIOS
中预先写入了操作系统开发人员经常会用到的一些程序，非常方便。BIOS是英文“basic input
output system”的缩写，直译过来就是“基本输入输出系统（程序）”。
最近的BIOS功能非常多，甚至包括了电脑的设定画面，不过它的本质正如其名，就是为操
作系统开发人员准备的各种函数的集合。而INT就是用来调用这些函数的指令。INT的后面是个
数字，使用不同的数字可以调用不同的函数。这次我们调用的是0x10（即16）号函数，它的功能
是控制显卡。
虽然制造厂家给我们准备好了BIOS，但其用法鲜为人知。不过这些很容易查到，笔者就做
了一个关于BIOS的网页，下面给大家介绍一下。
http://community.osdev.info/? (AT)BIOS
比如我们现在想要显示文字，先假设一次只显示一个字，那么具体怎么做才能知道这个功能
的使用方法呢？
首先，既然是要显示文字，就应该看跟显卡有关的函数。这么看来，INT 0x10好像有点关系，
于是在上面网页上搜索，然后就能找到以下内容（网页的原文为日语）。
显示一个字符
 AH=0x0e;
 AL=character code;
 BH=0;
 BL=color code;
 返回值：无
 注：beep、退格（back space）、CR、LF都会被当做控制字符处理
所以，如果大家按照这里所写的步骤，往寄存器里代入各种值，再调用INT 0x10，就能顺利
地在屏幕上显示一个字符出来②。
■■■■■
最后一个新出现的指令是HLT。这个指令很少用，会让它在第2天的内容里就登台亮相的，
估计全世界就只有笔者了。不过由于笔者对它的偏好，就让笔者在这里多说两句吧（笑）。
HLT是让CPU停止动作的指令，不过并不是彻底地停止（如果要彻底停止CPU的动作，只能
切断电源），而是让CPU进入待机状态。只要外部发生变化，比如按下键盘，或是移动鼠标，CPU
——————————
① 只读存储器，不能写入，切断电源以后内容不会消失。ROM是“read only memory”的缩写。
② 因为这里的BL中放入了彩色字符码，所以一旦这里变更，显示的字符的颜色也应该变化。但笔者试了试，颜色并没
有变。尚不清楚为什么只能显示白色，只能推测现在这个画面模式下，不能简单地指定字符颜色。
图灵社区会员 metorm 专享 尊重版权
2 继续开发 …… 39
就会醒过来，继续执行程序。说到这，请大家再仔细看看这个程序，我们会发现其实不管有没有 1
HLT指令，JMP fin都是无限循环，不写HLT指令也可以。所以很少有人一开始就向初学者介绍HLT
指令，因为这样只会让话变得很长。
2
然而笔者讨厌让CPU毫无意义地空转。如果没有HLT指令， CPU就会不停地全力去执行
JMP指令，这会使CPU的负荷达到100%，非常费电。这多浪费呀。我们仅仅加上一个HLT指
2
令，就能让CPU基本处于睡眠状态，可以省很多电。什么都不干，还要耗费那么多电，这就
是浪费。即便是初学者，最好也要一开始就养成待机时使用HLT指令的习惯。或者说，恰恰应
20
该在初学阶段，就养成这样的好习惯。这样既节能环保，又节约电费，或许还能延长电脑的
使用寿命呢。
21
对了，HLT指令源自英文“halt”，意思是“停止”。
■■■■■ 22
说了这么多，终于把这个程序从头到尾都讲完了。总结一下就是这样的：
7
用C语言改写后的helloos.nas程序节选
entry:
8
AX = 0;
SS = AX;
SP = 0x7c00;
DS = AX; 9
ES = AX;
SI = msg;
putloop:
10
AL = BYTE [SI];
SI = SI + 1;
if (AL == 0) { goto fin; }
AH = 0x0e; 11
BX = 15;
INT 0x10;
goto putloop;
12
fin:
HLT;
goto fin;
13
就是有了这个程序，我们才能够把msg里写的数据，一个字符一个字符地显示出来，并且数
据变成0以后，HLT指令就会让程序进入无限循环。“hello, world”就是这样显示出来的。 14
■■■■■
15
对了，我们还没有说ORG的0x7c00是怎么回事呢。ORG指令本身刚才已经讲过，就不再重复
了，但这个0x7c00又是从哪儿冒出来的呢？换成1234是不是就不行啊？嗯，还真是不行，我们要
16
图灵社区会员 metorm 专享 尊重版权
40 …… 第2天：用C语言编写应用程序
是把它换成1234的话，程序马上就不动了。
大家所用的电脑里配置的，大概都是64MB，甚至512MB这样非常大的内存。那是不是这些
内存我们想怎么用就能怎么用呢？也不是这样的。比如说，内存的0号地址，也就是最开始的部
分，是BIOS程序用来实现各种不同功能的地方，如果我们随便使用的话，就会与BIOS发生冲突，
结果不只是BIOS会出错，而且我们的程序也肯定会问题百出。另外，在内存的0xf0000号地址附
近，还存放着BIOS程序本身，那里我们也不能使用。
内存里还有其他不少地方也是不能用的，所以我们作为操作系统开发者，不得不注意这一点。
在我们作为一般用户使用Windows或Linux时，不用想这些麻烦事，因为操作系统已经都处理好
了，而现在，我们成了操作系统开发者，就需要为用户来考虑这些问题了。只用语言文字来讲解
内存哪个部分不能用的话，不够清楚直观，所以还是要画张地图。正好这里就有一张内存分布图，
让我们一起来看看。
http://community.osdev.info/?(AT)memorymap
虽然称之为地图，可实际上根本就不像地图，网页的作者也太会偷工减料了吧。话说这个网
页的作者，其实就是笔者本人，不好意思啦。大家要是仔细看的话，会发现其中很多东西都是不
知所云（都是笔者不好，真是对不起），不过在“软件用途分类”这里，有一句话可是非常重要
的，一定不能漏掉。
0x00007c00-0x00007dff ：启动区内容的装载地址
程序中ORG指令的值就是这个数字。而且正是因为我们使用的是这个同样的数字，所以程序
才能正常运行。
看到这，大家可能会问：“为什么是0x7c00呢？ 0x7000不是更简单、好记吗？”其实笔者也
是这么想的，不过没办法，当初规定的就是0x7c00。做出这个规定的应该是IBM的大叔们，不过
估计他们现在都成爷爷了。
一旦有了规定，人们就会以此为前提开发各种操作系统，因此以后就算有人说“现在地址变
成0x7000-0x71ff了，请大家跟着改一下”，也只是空口号，不可能实现。因为硬要这么做的话，
那现有的操作系统就必须全部加以改造才能在这台新电脑上运行，这样的电脑兼容性不好，根本
就卖不出去。
今后也许大家还会提出很多疑问：“为什么是这样呢？”这些都是当年IBM和英特尔的大叔
们规定的。如果非要深究的话，我们倒是也能找到一些当时时代背景下的原因，不过要把这些都
说清楚的话，这本书恐怕还要再加厚一倍，所以关于这些问题我们就不过多解释了。
33 先制作启动区
考虑到以后的开发，我们不要一下子就用nask来做整个磁盘映像，而是先只用它来制作512
图灵社区会员 metorm 专享 尊重版权
4 Makefile入门 …… 41
字节的启动区，剩下的部分我们用磁盘映像管理工具来做，这样以后用起来就方便了。 1
如此一来，我们就有了projects/02_day的helloos4这个文件夹。
首先我们把heloos.nas的后半部分截掉了，这是因为启动区只需要最初的512字节。现在这个 2
程序就仅仅是用来制作启动区的，所以我们把文件名也改为ipl.nas。
然后我们来改造asm.bat，将输出的文件名改成ipl.bin。另外，也顺便输出列表文件ipl.lst。这 2
是一个文本文件，可以用来简单地确认每个指令是怎样翻译成机器语言的。到目前为止我们都没
有输出过这个文件，那是因为1440KB的列表文件实在太大了，而这次只需要输出512字节，所以 20
没什么问题。
另外我们还增加了一个makeimg.bat。它是以ipl.bin为基础，制作磁盘映像文件helloos.img的 21
批处理文件。它利用笔者自己开发的磁盘映像管理工具edimg.exe，先读入一个空白的磁盘映像文
件，然后在开头写入ipl.bin的内容，最后将结果输出为名为helloos.img的磁盘映像文件。详情请
22
参考makeimg.bat的内容。
这样，从编译到测试的步骤就变得非常简单了，我们只要双击!cons，然后在命令行窗口中按
7
顺序输入asm→makeimg→run这3个命令就完成了。
8
44 Makefile 入门
到helloos4为止，做出来的程序与笔者最初开发时所写的源程序是完全一样的。在开发的过 9
程中，笔者使用了一个名为Makefile的东西，在这里给大家介绍一下。
Makefile就像是一个非常聪明的批处理文件。 10
■■■■■
11
Makefile的写法相当简单。首先生成一个不带扩展名的文件Makefile，然后再用文本编辑器
写入以下内容。
12
#文件生成规则
13
ipl.bin : ipl.nas Makefile
../z_tools/nask.exe ipl.nas ipl.bin ipl.lst
14
helloos.img : ipl.bin Makefile
../z_tools/edimg.exe imgin:../z_tools/fdimg0at.tek \
wbinimg src:ipl.bin len:512 from:0 to:0 imgout:helloos.img
15
#号表示注释。下一行“ipl.bin : ipl.nas Makefile”的意思是，如果想要制作文件ipl.bin，就
先检查一下ipl.nas和Makefile这两个文件是否都准备好了。如果这两个文件都有了，Make工具就
16
图灵社区会员 metorm 专享 尊重版权
42 …… 第2天：用C语言编写应用程序
会自动执行Makefile的下一行。
至于helloos.img，Makefile的写法也是完全一样的。其中的“\”是续行符号，表示这一行太
长写不下，跳转到下一行继续写。
我们需要调用make.exe来让这个Makefile发挥作用。为了能更方便地从命令行窗口运行这个工
具，我们来做个make.bat。make.bat就放在tolset的z_new_w文件夹中，可以直接把它复制过来用。
■■■■■
做好以上这些准备后，用!cons打开一个命令行窗口（console），然后输入“make -r ipl.bin”。
这样make.exe就会启动了，它首先读取Makefile文件，寻找制作ipl.bin的方法。因为ipl.bin的做法
就写在Makefile里，make.exe找到了这一行就去执行其中的命令，顺利生成ipl.bin。然后我们再输
入“make -r helloos.img”看看，果然它还是会启动make.exe，并按照Makefile指定的方法来执行。
到此为止好像也没什么特别的，我们再尝试一下把helloos.img和ipl.bin都删除后，再输入
“make -r helloos.img”命令。make 首先很听话地试图生成helloos.img，但它会发现所需要的ipl.bin
还不存在。于是就去Makefile里寻找ipl.bin的生成方法，找到后先生成ipl.bin，在确认ipl.bin顺利
生成以后，就回来继续生成helloos.img。它很聪明吧。
下面，我们不删除文件，再输入命令“make -r helloos.img”执行一次的话，就会发现，仅仅
输出一行“‘helloos.img’已是最新版本（‘helloos.img’is up to date）”的信息，什么命令都不执
行。也就是说，make知道helloos.img已经存在，没必要特意重新再做一次了。它越来越聪明了吧。
让我们再考验考验make.exe。我们来编辑ipl.nas中的输出信息，把它改成“How are you?”并
保存起来。而ipl.bin 和helloos.img保持刚才的样子不删除，在这种情况下我们再来执行一次“make-
r helloos.img”。本以为这次它还会说没必要再生成一次呢，结果我们发现，make.exe又从ipl.bin
开始重新生成输出文件。这也就是说，make.exe不仅仅判断输入文件是否存在，还会判断文件的
更新日期，并据此来决定是否需要重新生成输出文件，真是太厉害了。