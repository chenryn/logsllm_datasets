实质上，该函数接收两个堆栈分配的缓冲区，其中源缓冲区预期格式为SIZE1-BUF1，SIZE2-BUF2，SIZE3-BUF3等。“。”用作条目分隔符。
读取源缓冲区的第一个字节并将其用作复制操作的大小。然后，该函数将该字节数复制到目标缓冲区中。完成后，读取源缓冲区的下一个字节并将其用作新大小。当要复制的大小等于零时，此循环结束。未进行验证以确保数据适合目标缓冲区，从而导致堆栈溢出。
## 写exp
如何处理利用取决于目标设备和架构的细节。在这里，我们只对Cloud Hosted Router x86二进制文件感兴趣。
值得一提的是，可能有几种不同的方法来实现对此漏洞的可靠利用，因此我们将审查我们使用的那个，这可能不是最优雅或最有效的方法。
Tobias Klein的checksec脚本是一个很好的资源，可以检查我们需要采取哪些缓解措施。可以从PEDA调用此脚本。
stack
canaries的缺乏可能是最缺失的最相关的缓解，使得基于堆栈的缓冲区溢出很容易被利用。如果程序是用堆栈金丝雀编译的，那么我们以前的测试会产生非常不同的结果。堆栈canaries将随机值放在分配缓冲区的每个函数帧中的重要数据之前，并在函数返回之前检查这些值。如果发生溢出，将终止执行并且不再进一步利用。
PIE禁用意味着我们可以依赖程序代码的固定位置，禁用RELRO意味着我们可以覆盖全局偏移表中的条目。
总而言之，我们将只处理NX，它限制从可写区域（如堆栈或堆）执行。
在系统级实施的另一项缓解措施是ASLR。这是一个32位系统，因此部分覆盖或甚至暴力强制可被视为ASLR的可行旁路。在这种情况下，这是没有必要的。
检查RouterOS中任何程序的内存映射表明堆栈基本确实是随机的，但堆不是。这可以验证运行cat / proc / self / maps几次并比较结果。
构建我们的漏洞的第一步是获得精确的偏移以获得对EIP的控制。为了做到这一点，我们可以使用PEDA生成一个独特的模式，命令模式创建256并将其插入到我们的漏洞利用框架中。请注意，标头之后的第一个字节将是易受攻击的函数解析的大小，因此我们指定0xFF以不变地读取256个字节，并避免将“。”字符放置在有效负载的中间。
发生崩溃时，可以使用伴随的模式偏移VALUE命令来确定覆盖EIP的确切位置。
更改有效负载并验证EIP是否可以设置为任意值。
我们没有观察到烦人的“。”字符，这很好。
既然我们控制了EIP和堆栈的其余部分，我们就可以使用借用的代码块技术，这种技术更好地称为返回导向编程或ROP（有些人似乎对那些使用后者的人非常恼火，所以很可能更好地提及所有替代方案）。
主要思想是我们将链接以RET指令结尾的各种代码片段来执行或多或少的任意代码。如果有足够的这些小工具，我们应该能够运行我们想要的任何东西。但在这种特殊情况下，我们只想将堆区域标记为可执行文件。最终目标是在堆中存储某些东西（已经包含从客户端读取的消息）并利用静态基址跳转到那里。
这里的相关功能是mprotect，如下所示：
int mprotect（void * addr，size_t len，int prot）;  
地址将是0x8072000，这是堆的基础。这需要页面对齐才能工作。
Len可以是我们想要的任何东西，但让我们改变整个0x14000字节的保护。
最后，prot指的是执行的按位或所需的保护措施。7指的是PROT_READ | PROT_WRITE | PROT_EXEC，本质上是我们的目标RWX。
有迹象表明，可以尝试自动创建链的各种工具，如ROPGadget和Ropper。我们将使用ropper但手动构建ROP链以显示它是如何完成的。
根据Linux系统调用约定，EAX将包含系统调用号，对于mprotect为0x7d。EBX将包含地址参数，ECX的大小和EDX所需的保护。
让我们开始将EBX设置为0x8072000。我们寻找包含POP EBX指令的小工具，并尽可能减少副作用。
我们选择较小的小工具并开始构建我们的链。这看起来如下。执行将被重定向到0x804c39d，它将首先执行POP
EBX指令，将EBX设置为所需的值0x8072000。接下来，将执行POP
EBP，因此我们需要提供一些虚拟值，以便从堆栈中弹出一些东西。最后，执行RET指令，弹出堆栈中的下一个并跳转到那里。这需要成为我们链中的下一步。
所有值都打包为little-endian无符号整数。
我们使用相同的过程在ECX中设置所需的大小。重要的是要理解顺序很重要，因为如果我们不小心，我们可能会在不知不觉中覆盖我们已经设置的寄存器。此外，有时小工具看起来不如POP
DESIRED_REG好; RET和我们将不得不处理需要额外调整的潜在副作用。
在这里，我们将选择更加良性的0x080664f5。这个小工具改变了EAX的值，但我们目前不依赖于EAX中的任何特定设置，因此它非常有用。我们将此附加到我们的ROP链。
我们重复这个过程，这次将EDX设置为7，这是RWX保护级别。
这次我们在0x08066f24处选择小工具，这不会弄乱我们之前设置的寄存器。
最后，我们需要将EAX设置为系统调用号0x7d。我们搜索包含POP EAX的小工具，但找不到任何不会改变我们当前设置的内容。
我们可以尝试以不同的方式重新排序我们的小工具，但我们只会搜索另一个执行XCHG EAX，EBP并使用无处不在的POP EBP链接它的小工具; RET。
从这里我们取0x804f94a和0x804c39e并追加它们
现在可以根据需要配置寄存器以执行mprotect系统调用。为此，我们需要调用INT 0x80，它通知内核我们要执行系统调用。
但是，当我们查找包含此指令的小工具时，我们找不到任何内容。这可能会使事情变得更加困难。
幸运的是，还有另一个地方我们可以找到这种小工具。所有用户空间应用程序都有一个小型共享库，由内核映射到其地址空间，称为vDSO（虚拟动态共享对象）。这是出于性能原因而存在的，并且是内核将某些功能导出到用户空间并避免对经常调用的函数进行上下文切换的方法。如果我们看一下手册页，我们会看到一些有趣的东西：
这意味着vDSO中有一个可能知道如何执行系统调用的函数。我们可以检查这个函数在GDB中的作用。
从上面的屏幕截图中可以看出，__
kernel_vsyscall包含一个有用的小工具。我们执行该过程几次，并意识到此映射不受ASLR的影响，这允许我们使用此小工具。EBX，ECX和EBP的值现在并不重要，因为它们将在执行系统调用后设置。
我们更新漏洞利用代码以发送我们构建的链并将GDB附加到正在运行的SMB二进制文件
EIP会将执行重定向到我们的第一个小工具，因此最好将断点放在0x804c39d，这是链的起点。
使用stepi观察寄存器如何设置为所需的值。在INT 0x80之后，我们可以列出映射区域，如果一切正常，堆将被标记为RWX。
剩下的部分包括将堆中的任意代码存储在已知位置，这样我们就可以跳转到那里获得一个shell，但是我们怎么能这样做呢？
当我们在read（）中放置一个断点时，我们发现请求数据存储在堆中的某个地方。此外，我们有各种协商协议请求请求的样本，因此可以确定如果消息类型字节设置为0x00，那么我们将到达程序中的某个路径，其中有效负载将被处理并存储在堆。
为了测试这个假设，让我们再次在read（）中放置一个断点，并更改PoC有效负载，以发送一个带有512“A”作为内容的良性协商协议请求消息。提醒一下，格式是：
消息类型（1字节） - 标志（1字节） - 消息长度（2字节） - 消息  
此时消息类型将设置为NETBIOS_SESSION_MESSAGE（0x00）。我们没有使用另一个会话请求消息（0x81）来避免意外触发漏洞并且必须处理易受攻击的函数所在的“。”字符。
逐步执行读取功能，直到从网络读取0x204字节（512“A”s + 4字节标头）。如前所述，ECX包含缓冲区的地址。
检查指定地址处的内存内容会显示我们的有效负载。
按c键允许执行正常继续并发送新请求以检查前一个请求是否被覆盖，或者它是否刚刚留在堆中。
当再次到达断点时，我们尝试打印读缓冲区的内容，不幸的是我们意识到它已被清零。
但是，如果应用程序制作了未归零的副本，则之前的请求仍可能在其他位置挥之不去。它是可以通过使用搜索与PEDA当前地址空间的发现或searchmem命令。我们的消息由512“A”组成，因此我们试图找到一个连续的“A”块。这些命令采用由空格分隔的可选参数，以将搜索限制在特定区域。我们只对堆中可能存在的结果感兴趣。
这意味着正在复制请求的内容并将其保留在未清除的某个缓冲区中。我们需要进行一些测试，以便能够信任此位置来存储我们的有效负载。特别是，如果我们将脚本更改为发送512“B”而不是“A”，我们将看到0x8085074将在处理请求后最终包含“B”。我们需要数据在其他请求中持续存在，因此这并不好。
但是，如果我们首先发送512“A”然后再说256“B”，那么很明显前半部分被覆盖但后半部分仍然包含前一个请求的字节。奇怪的0x00000e89是来自堆控制结构的块元数据，与我们的场景无关。
知道数据将至少在两个请求中保持不变，我们可以制定以下计划：
使用我们要执行的代码发送协商协议请求。第一部分将是几百个NOP指令，因为当我们发出第二个请求时，这些字节将被覆盖，并带有触发漏洞的相应会话请求消息。  
发送破坏堆栈的会话请求消息，将ROP保护为mprotect，将堆标记为可执行文件并跳转到存储＃1负载的硬编码位置，滥用堆基不随机化的事实。  
我们决定为第二个请求留下512个字节，因此我们将跳转到0x8085074 + 512 =
0x8085270的硬编码位置。此地址需要附加到我们的ROP链中。之前的小工具将执行其最终的RET指令，将从堆栈中弹出0x8085270，然后执行程序。
shellcode的第一个版本将只包含INT3指令，因此调试器在执行时会中断。INT3的操作码是CC。
该脚本也被修改为打开两个连接，每个连接一个。
![](https://xzfile.aliyuncs.com/media/upload/picture/20190311174505-59a2
!\[图片.png\]\(./img/3914487077359499967.png)  
456c-43e2-1.png)
附加到新的SMB流程并运行漏洞利用程序
我们现在正在执行任意代码。让我们使用msfvenom生成反向shell有效负载。
我们修改第一阶段以存储此有效负载并再次运行该漏洞。
这次我们在指定的端口打开一个netcat监听器，以便我们可以接收连接。
## 结论
使用基于突变的方法对网络服务进行模糊化可以很少的努力完成，并且可以产生很好的结果。
如果您正在寻找那些谈论神秘专有协议的应用程序中的漏洞，或者只是懒得构建一个全面的模板，那么就给愚蠢的模糊测试。您可以在应用忍者逆向工程技能的同时以最小的努力使模糊器运行，以了解协议并构建更好的东西。
RouterOS驱动的设备现在无处不在，缺乏现代（对现代的任意定义）漏洞利用缓解有点令人担忧。启用完整的ASLR会使漏洞利用编写器的生命变得更加困难，并且如果二进制文件是使用堆栈canaries支持编译的，那么在没有info-leak漏洞的情况下，大多数堆栈溢出将变得无法开发。
值得一提的是MikroTik的响应和补丁时间都很棒。起初，更改日志没有暗示存在安全漏洞：
What's new in 6.41.3 (2018-Mar-08 11:55):  
*) smb - improved NetBIOS name handling and stability;
但是，它们现在看起来更严重了。它们在其有关安全漏洞的更改日志中包含更详细的评论，并且似乎有一个博客，他们也发布有关这些类型问题的官方公告。
精明的读者可能已经注意到，如果你再现了这篇文章中概述的步骤，你甚至可能在RouterOS SMB中找到了一些额外的0天。
玩得开心！
其他资源  
Core Security的原始咨询（  
chimay-red的详细分析（WWW漏洞中的漏洞7）  
MIPS利用BigNerd95在这篇文章中描述的bug   
Jacob Baines发布了  
对去年着名的Winbox漏洞的分析很简单  
0ki MikroTik工具  
0ki的研究中心，有数十个视频/幻灯片格式的演示文稿