errno.h头文件支持较老式的错误报告机制。该机制提供一个标识符（或
有时称为宏）ERRNO可访问的外部静态内存位置。一些库函数把一个值放
进这个位置用于报告错误，然后包含该头文件的程序就可以通过查看
ERRNO的值检查是否报告了一个特定的错误。ERRNO机制被认为不够艺
术，而且设置ERRNO值也不需要数学函数了。标准提供了3个宏值表示特殊
的错误，但是有些实现会提供更多。表B.5.5列出了这些标准宏。
表B.5.5 errno.h宏
B.5.5 浮点环境：fenv.h（C99）
C99标准通过fenv.h头文件提供访问和控制浮点环境。
浮点环境（floating-point environment）由一组状态标志（status flag）和
1556
控制模式（control 
mode）组成。在浮点计算中发生异常情况时（如，被零
除），可以“抛出一个异常”。这意味着该异常情况设置了一个浮点环境标
志。控制模式值可以进行一些控制，例如控制舍入的方向。fenv.h头文件定
义了一组宏表示多种异常情况和控制模式，并提供了与环境交互的函数原
型。头文件还提供了一个编译指令来启用或禁用访问浮点环境的功能。
下面的指令开启访问浮点环境：
#pragma STDC FENV_ACCESS on
下面的指令关闭访问浮点环境：
#pragma STDC FENV_ACCESS off
应该把该编译指示放在所有外部声明之前或者复合块的开始处。在遇到
下一个编译指示之前、或到达文件末尾（外部指令）、或到达复合语句的末
尾（块指令），当前编译指示一直有效。
头文件定义了两种类型，如表B.5.6所示。
表B.5.6 fenv.h类型
头文件定义了一些宏，表示一些可能发生的浮点异常情况控制状态。其
他实现可能定义更多的宏，但是必须以FE_开头，后面跟大写字母。表B.5.7
列出了一些标准异常宏。
表B.5.7 fenv.h中的标准异常宏
1557
表B.5.8中列出了fenv.h头文件中的标准函数原型。注意，常用的参数值
和返回值与表B.5.7中的宏相对应。例如，FE_UPWARD是fesetround()的一个
合适参数。
表B.5.8 fenv.h中的标准函数原型
B.5.6 浮点特性：float.h
float.h头文件中定义了一些表示各种限制和形参的宏。表B.5.9列出了这
1558
些宏，C11新增的宏以斜体并缩进标出。许多宏都涉及下面的浮点表示模
型：
如果第1个数f1是非0（且x是非0），该数字被称为标准化浮点数。附录
B的参考资料VIII中将更详细地解释一些宏。
表B.5.9 float.h宏
1 FLT_RADIX用于表示3种浮点数类型的基数。——译者注
续表
1559
B.5.7 整数类型的格式转换：inttypes.h
1560
该头文件定义了一些宏可用作转换说明来扩展整数类型。参考资料
VI“扩展的整数类型”将进一步讨论。该头文件还声明了这个类型：
imaxdiv_t。这是一个结构类型，表示idivmax()函数的返回值。
该头文件中还包含 
stdint.h，并声明了一些使用最大长度整数类型的函
数，这种整数类型在stdint.h中声明为intmax。表B.5.10列出了这些函数。
表B.5.10 使用最大长度整数的函数
B.5.8 可选拼写：iso646.h
该头文件提供了11个宏，扩展了指定的运算符，如表B.5.11所列。
表B.5.11 可 选 拼写
B.5.9 本地化：locale.h
1561
本地化是一组设置，用于控制一些特定的设置项，如表示小数点的符
号。本地值储存在struct lconv类型的结构中，定义在 locale.h 头文件中。可
以用一个字符串来指定本地化，该字符串指定了一组结构成员的特殊值。默
认的本地化由字符串"C"指定。表 B.5.12 列出了本地化函数，后面做了简要
说明。
表B.5.12 本地化函数
setlocale()函数的locale形参所需的值可能是默认值"C"，也可能是""，表
示实现定义的本地环境。实现可以定义更多的本地化设置。category形参的
值可能由表B.5.13中所列的宏表示。
表B.5.13 category宏
表B.5.14列出了struct lconv结构所需的成员。
表B.5.14 struct lcconv所需的成员
1562
续表
1563
B.5.10 数学库：math.h
C99为math.h头文件定义了两种类型：float_t和double_t。这两种类型分
别与float和double类型至少等宽，是计算float和double时效率最高的类型。
该头文件还定义了一些宏，如表B.5.15所列。该表中除了HUGE_VAL
外，都是C99新增的。在参考资料VIII：“C99数值计算增强”中会进一步详细
介绍。
表B.5.15 math.h宏
续表
1564
数学函数通常使用double类型的值。C99新增了这些函数的float和long
double版本，其函数名为分别在原函数名后添加f后缀和l后缀。例如，C语言
现在提供这些函数原型：
double sin(double);
float sinf(float);
long double sinl(long double);
篇幅有限，表B.5.16仅列出了数学库中这些函数的double版本。该表引
用了FLT_RADIX，该常量定义在float.h中，代表内部浮点表示法中幂的底
数。最常用的值是2。
表B.5.16 ANSI C标准数学函数
续表
1565
续表
1566
1 NaN 分为两类：quite NaN 和 singaling NaN。两者的区别是：quite NaN 的尾数部分最高位定义为
1，而singaling NaN最高位定义为0。——译者注
续表
1567
B.5.11 非本地跳转：setjmp.h
setjmp.h 
头文件可以让你不遵循通常的函数调用、函数返回顺序。
setjmp()函数把当前执行环境的信息（例如，指向当前指令的指针）储存在
jmp_buf类型（定义在setjmp.h头文件中的数组类型）的变量中，然后
longjmp()函数把执行转至这个环境中。这些函数主要是用来处理错误条件，
并不是通常程序流控制的一部分。表B.5.17列出了这些函数。
表B.5.17 setjmp.h中的函数
B.5.12 信号处理：signal.h
信号（signal）是在程序执行期间可以报告的一种情况，可以用正整数
表示。raise()函数发送（或抛出）一个信号，signal()函数设置特定信号的响
应。
标准定义了一个整数类型：sig_atomic_t，专门用于在处理信号时指定
原子对象。也就是说，更新原子类型是不可分割的过程。
标准提供的宏列于表B.5.18中，它们表示可能的信号，可用作raise()和
signal()的参数。当然，实现也可以添加更多的值。
表B.5.18 信 号 宏
1568
signal()函数的第2个参数接受一个指向void函数的指针，该函数有一个
int类型的参数，也返回相同类型的指针。为响应一个信号而被调用的函数称
为信号处理器（signal handler）。标准定义了3个满足下面原型的宏：
void (*funct)(int);
表B.5.19列出了这3种宏。
表B.5.19 void (*f)(int)宏
如果产生了信号sig，而且 func指向一个函数（参见表B.5.20中signal()原
型），那么大多数情况下先调用 signal(sig, SIG_DFL)把信号重置为默认设
置，然后调用(*func)(sig)。可以执行返回语句或调用abort()、exit()或
longjmp()来结束func指向的信号处理函数。
表B.5.20 信 号 函 数
B.5.13 对齐：stdalign.h（C11）
stdalign.h头文件定义了4个宏，用于确定和指定数据对象的对齐属性。
1569
表B.5.21中列出了这些宏，其中前两个创建的别名与C++的用法兼容。
表B.5.21 void (*f)(int)宏
B.5.14 可变参数：stdarg.h
stdarg.h 头文件提供一种方法定义参数数量可变的函数。这种函数的原
型有一个形参列表，列表中至少有一个形参后面跟有省略号：
void f1(int n, ...);       /* 有效 */
int f2(int n, float x, int k, ...);/* 有效 */
double f3(...);         /* 无效 */
在下面的表中，parmN是省略号前面的最后一个形参的标识符。在上面
的例子中，第1种情况的parmN为n，第2种情况的parmN为k。
头文件中声明了va_lis类型表示储存形参列表中省略号部分的形参数据
对象。表B.5.22中列出了3个带可变参数列表的函数中用到的宏。在使用这
些宏之前要声明一个va_list类型的对象。
表B.5.22 可变参数列表宏
1570
B.5.15 原子支持：stdatomic.h（C11）
stdatomic.h和threads.h头文件支持并发编程。并发编程的内容超过了本
书讨论的范围，简单地说，stdatomic.h 头文件提供了创建原子操作的宏。编
程社区使用原子这个术语是为了强调不可分割的特性。一个操作（如，把一
个结构赋给另一个结构）从编程层面上看是原子操作，但是从机器语言层面
上看是由多个步骤组成。如果程序被分成多个线程，那么其中的线程可能读
或修改另一个线程正在使用的数据。例如，可以想象给一个结构的多个成员
赋值，不同线程给不同成员赋值。有了stdatomic.h头文件，就能创建这些可
以看作是不可分割的操作，这样就能保证线程之间互不干扰。
B.5.16 布尔支持：stdbool.h（C99）
stdbool.h头文件定义了4个宏，如表B.5.23所列。
表B.5.23 stdbool.h宏
B.5.17 通用定义：stddef.h
该头文件定义了一些类型和宏，如表B.5.24和表B.5.25所列。
表B.5.24 stddef.h类型
表B.5.25 stddef.h宏
1571
示例
#include 
struct car
{
char brand[30];
char model[30];
double hp;
double price;
};
int main(void)
{
size_t into = offsetof(struct car, hp); /* hp成员的偏移量 */
...
B.5.18 整数类型：stdint.h
stdint.h头文件中使用typedef工具创建整数类型名，指定整数的属性。
stdint.h头文件包含在inttypes.h中，后者提供输入/输出函数调用的宏。参考资
料VI的“扩展的整数类型”中介绍了这些类型的用法。
1572
1.精确宽度类型
stdint.h头文件中用一组typedef标识精确宽度的类型。表B.5.26列出了它
们的类型名和大小。然而，注意，并不是所有的系统都支持其中的所有类
型。
表B.5.26 确切宽度类型
2.最小宽度类型
最小宽度类型保证其类型的大小至少是某数量位。表B.5.27列出了最小
宽度类型，系统中一定会有这些类型。
表B.5.27 最小宽度类型
3.最快最小宽度类型
在特定系统中，使用某些整数类型比其他整数类型更快。为此，stdint.h
1573
也定义了最快最小宽度类型，如表B.5.28所列，系统中一定会有这些类型。
表B.5.28 最快最小宽度类型
4.最大宽度类型
stdint.h 
头文件还定义了最大宽度类型。这种类型的变量可以储存系统
中的任意整数值，还要考虑符号。表B.5.29列出了这些类型。
表B.5.29 最大宽度类型
5.可储存指针值的整数类型
stdint.h头文件中还包括表B.5.30中所列的两种整数类型，它们可以精确
地储存指针值。也就是说，如果把一个void 
*类型的值赋给这种类型的变
量，然后再把该类型的值赋回给指针，不会丢失任何信息。系统可能不支持
这类型。
表B.5.30 可储存指针值的整数类型
6.已定义的常量
1574
stdint.h头文件定义了一些常量，用于表示该头文件中所定义类型的限定
值。常量都根据类型命名，即用_MIN或_MAX代替类型名中的_t，然后把所
有字母大写即得到表示该类型最小值或最大值的常量名。例如，int32_t类型
的最小值是INT32_MIN、unit_fast16_t的最大值是UNIT_FAST16_MAX。表
B.5.31总结了这些常量以及与之相关的intptr_t、unitptr_t、intmax_t和uintmax_t
类型，其中的N表示位数。这些常量的值应等于或大于（除非指明了一定要
等于）所列的值。
表B.5.31 整 型 常 量
该头文件还定义了一些别处定义的类型使用的常量，如表B.5.32所示。
表B.5.32 其他整型常量
1575
7.扩展的整型常量
stdin.h头文件定义了一些宏用于指定各种扩展整数类型。从本质上看，
这种宏是底层类型（即在特定实现中表示扩展类型的基本类型）的强制转
换。
把类型名后面的_t 
替换成_C，然后大写所有的字母就构成了一个宏
名。例如，使用表达式UNIT_LEAST64_C(1000)后，1000就是unit_least64_t
类型的常量。
B.5.19 标准I/O库：stdio.h
ANSI 
C标准库包含一些与流相关联的标准I/O函数和stdio.h头文件。表
B.5.33列出了ANSI中这些函数的原型和简介（第13章详细介绍过其中的一些
函数）。stdio.h头文件定义了FILE类型、EOF和NULL的值、标准I/O流
（stdin、stdout和stderr）以及标准I/O库函数要用到的一些常量。
表B.5.33 C标准I/O函数
1576
续表
1577
B.5.20 通用工具：stdlib.h
ANSI 
C标准库在stdlib.h头文件中定义了一些实用函数。该头文件定义
了一些类型，如表B.5.34所示。
表B.5.34 stdlib.h中声明的类型
1578
stdlib.h头文件定义的常量列于表B.5.35中。
表B.5.35 stdlib.h中定义的常量
表B.5.36列出了stdlib.h中的函数原型。
表B.5.36 通 用 工 具
1579
续表
1580
续表