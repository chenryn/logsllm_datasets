# 06 \| 长参数列表：如何处理不同类型的长参数？你好，我是郑晔。前面两讲，我们分别讲了长函数和大类，它们都是那种"我一说，你就知道是怎么回事"的坏味道，而且都让我们深恶痛绝，唯恐避之不及。这样典型的坏味道还有一个，就是长参数列表。好吧，我知道你的脑子里已经出现了一个长长的参数列表了。每个程序员只要想到，一个函数拥有几十甚至上百个参数，内心就难以平静下来。那么，函数为什么要有参数呢？我们知道，不同函数之间需要共享信息，于是才有了参数传递。其实，函数间共享信息的方式不止一种，除了参数列表，最常见的一种方式是全局变量。但全局变量会带给我们太多意想不到的问题，所以，在初学编程的时候，老师就会告诉我们，不要使用全局变量。从程序设计语言发展的过程中，我们也可以看到，取消全局变量已经成为了大势所趋。但函数之间还是要传递信息的，既然不能用全局变量，参数就成了最好的选择，于是乎，只要你想到有什么信息要传给一个函数，就自然而然地把它加到参数列表中，参数列表也就越来越长了。那么，长参数列表有啥问题呢？这个问题其实我在上一讲已经说过了，人脑能够掌握的内容有限，一旦参数列表变得很长，作为普通人，我们就很难对这些内容进行把控了。既然长参数列表的问题是数量多，秉承我们一以贯之的思路，解决这个问题的关键就在于，减少参数的数量。既然知道了解决方案的方向，那我们接下来就具体看看，有哪些方法可以减少参数的数量。聚沙成塔我们来看一段代码：    public void createBook(final String title,                            final String introduction,                           final URL coverUrl,                           final BookType type,                           final BookChannel channel,                           final String protagonists,                           final String tags,                           final boolean completed) {      ...      Book book = Book.builder        .title(title)         .introduction(introduction)        .coverUrl(coverUrl)        .type(type)        .channel(channel)        .protagonists(protagonists)        .tags(tags)        .completed(completed)        .build();              this.repository.save(book);    }这是一个创建作品的函数，我们可以看到，这个函数的参数列表里，包含了一部作品所要拥有的各种信息，比如：作品标题、作品简介、封面URL、作品类型、作品归属的频道、主角姓名、作品标签、作品是否已经完结等等。如果你阅读这段代码，只是想理解它的逻辑，你或许会觉得这个函数的参数列表还挺合理，它把创建一部作品所需的各种信息都传给了函数，这是大部分人面对一段代码时理解问题的角度。不过，虽然这样写代码容易让人理解，但这不足以让你发现问题。比如，如果你现在要在作品里增加一项信息，表明这部作品是否是签约作品，也就是这部作品是否可以收费，那你该怎么办？顺着前面的思路，我们很自然地就会想到给这个函数增加一个参数。但正如我在讲"长函数slate-object="inline""那节课里说到的，很多问题都是这样，每次只增加一点点，累积起来，便不忍直视了。如果我们有了"坏味道"的视角，我们就会看到这里面的问题：这个函数的参数列表太长了。怎么解决这个问题呢？这里所有的参数其实都是和作品相关的，也就是说，所有的参数都是创建作品所必需的。所以，我们可以做的就是将这些参数封装成一个类，一个创建作品的参数类：    public class NewBookParamters {      private String title;      private String introduction;      private URL coverUrl;      private BookType type;      private BookChannel channel;      private String protagonists;      private String tags;      private boolean completed;      ...    }这样一来，这个函数参数列表就只剩下一个参数了，一个长参数列表就消除了：    public void createBook(final NewBookParamters parameters) {      ...    }这里你看到了一个典型的消除长参数列表的重构手法：**将参数列表封装成对象**。或许你还有个疑问，只是把一个参数列表封装成一个类，然后，用到这些参数的时候，还需要把它们一个个取出来，这会不会是多此一举呢？就像这样：    public void createBook(final NewBookParamters parameters) {      ...      Book book = Book.builder        .title(parameters.getTitle())         .introduction(parameters.getIntroduction())        .coverUrl(parameters.getCoverUrl())        .type(parameters.getType())        .channel(parameters.getChannel())        .protagonists(parameters.getProtagonists())        .tags(parameters.getTags())        .completed(parameters.isCompleted())        .build();              this.repository.save(book);    }如果你也有这样的想法，那说明一件事：你还没有形成对软件设计的理解。我们并不是简单地把参数封装成类，站在设计的角度，我们这里引入的是一个新的模型。我在《软件设计之美》讨论模型封装slate-object="inline"的时候曾经说过，**一个模型的封装应该是以行为为基础的。**之前没有这个模型，所以，我们想不到它应该有什么行为，现在模型产生了，它就应该有自己配套的行为，那这个模型的行为是什么呢？从上面的代码我们不难看出，它的行为应该是构建一个作品对象出来。你理解了这一点，我们的代码就可以进一步调整了：    public class NewBookParamters {      private String title;      private String introduction;      private URL coverUrl;      private BookType type;      private BookChannel channel;      private String protagonists;      private String tags;      private boolean completed;            public Book newBook() {        return Book.builder          .title(title)           .introduction(introduction)          .coverUrl(coverUrl)          .type(type)          .channel(channel)          .protagonists(protagonists)          .tags(tags)          .completed(completed)          .build();      }    }创建作品的函数就得到了极大的简化：    public void createBook(final NewBookParamters parameters) {      ...      Book book = parameters.newBook();              this.repository.save(book);    }好，这里我们讨论消除长参数列表的一种方法，将参数列表封装成类。还记得我们前面提到的"如何扩展需求"这个问题吗？如果需求扩展，需要增加创建作品所需的内容，那这个参数列表就是不变的，相对来说，它就是稳定的。或许你会问，那这个类就会不断膨胀，变成一个大类，那该怎么办呢？关于这一点，你可以回顾一下我们的前一讲slate-object="inline"，看看怎么解决大类的问题。动静分离把长参数列表封装成一个类，这能解决大部分的长参数列表，但并不等于所有的长参数列表都应该用这种方式解决，因为不是所有情况下，参数都属于一个类。我们再来看一段代码：    public void getChapters(final long bookId,                             final HttpClient httpClient,                            final ChapterProcessor processor) {      HttpUriRequest request = createChapterRequest(bookId);      HttpResponse response = httpClient.execute(request);      List chapters = toChapters(response);      processor.process(chapters);    }这个函数的作用是根据作品 ID获取其对应的章节信息。如果，单纯以参数个数论，这个函数的参数数量并不算多。如果你只是看这个函数，可能很难发现直接的问题。即便我们认为有问题，也可以用一个类把这个函数的参数都封装起来。不过，秉承我在这个专栏里讨论的一贯原则，绝对的数量并不是关键点，参数列表也应该是越少越好。针对这个函数，我们需要稍微分析一下这几个参数。在这几个参数里面，每次传进来的 bookId都是不一样的，是随着请求的不同而改变的。但 httpClient 和 processor两个参数都是一样的，因为它们都有相同的逻辑，没有什么变化。换言之，bookId 的变化频率同 httpClient 和 processor这两个参数的变化频率是不同的。一边是每次都变，另一边是不变的。我在《软件设计之美》中讲分离关注点slate-object="inline"时曾经讲到过，不同的数据变动方向也是不同的关注点。这里表现出来的就是典型的动数据（bookId）和静数据（httpClient和processor），它们是不同的关注点，应该分离开来。具体到这个场景下，静态不变的数据完全可以成为这个函数所在类的一个字段，而只将每次变动的东西作为参数传递就可以了。按照这个思路，代码可以改成这个样子：    public void getChapters(final long bookId) {      HttpUriRequest request = createChapterRequest(bookId);      HttpResponse response = this.httpClient.execute(request);      List chapters = toChapters(response);      this.processor.process(chapters);    }这个坏味道其实是一个软件设计问题，代码缺乏应有的结构，所以，原本应该属于静态结构的部分却以动态参数的方式传来传去，无形之中拉长了参数列表。这个例子也给了我们一个提示，长参数列表固然可以用一个类进行封装，但能够封装出这个类的前提条件是：**这些参数属于一个类，有相同的变化原因。**如果函数的参数有不同的变化频率，就要视情况而定了。对于静态的部分，我们前面已经看到了，它可以成为软件结构的一部分，而如果有多个变化频率，我们还可以封装出多个参数类来。告别标记我们再来看一个例子：    public void editChapter(final long chapterId,                             final String title,                             final String content,                             final boolean apporved) {      ...    }这是我们在前面课程"重复代码slate-object="inline""那一讲里提到过的一个函数，我们稍微复习一下，这几个参数分别表示，待修改章节的ID、标题和内容，最后一个参数表示这次修改是否直接审核通过。前面几个参数是修改一个章节的必要信息，而这里的重点就在最后这个参数上。之所以要有这么个参数，从业务上说，如果是作者进行编辑，之后要经过审核，而如果编辑来编辑的，那审核就直接通过，因为编辑本身扮演了审核人的角色。所以，你发现了，这个参数实际上是一个标记，标志着接下来的处理流程会有不同。使用标记参数，是程序员初学编程时常用的一种手法，不过，正是因为这种手法实在是太好用了，造成的结果就是代码里面彩旗（flag）飘飘，各种标记满天飞。不仅变量里有标记，参数里也有。很多长参数列表其中就包含了各种标记参数。这也是很多代码产生混乱的一个重要原因。在实际的代码中，我们必须小心翼翼地判断各个标记当前的值，才能做好处理。解决标记参数，一种简单的方式就是，将标记参数代表的不同路径拆分出来。回到这段代码上，这里的一个函数可以拆分成两个函数，一个函数负责"普通的编辑"，另一个负责"可以直接审核通过的编辑"。    // 普通的编辑，需要审核    public void editChapter(final long chapterId,                             final String title,                             final String content) {      ...    }    // 直接审核通过的编辑    public void editChapterWithApproval(final long chapterId,                                        final String title,                                        final String content) {     ...    }标记参数在代码中存在的形式很多，有的是布尔值的形式，有的是以枚举值的形式，还有的就是直接的字符串或者整数。无论哪种形式，我们都可以通过拆分函数的方式将它们拆开。**在重构中，这种手法叫做移除标记参数（Remove FlagArgument）。**最近这三节课，我们讲了长函数、大类和长参数列表三种不同的坏味道，但在我们阐述了对于这些坏味道的理解之后，仔细想想这些坏味道，其实背后都是一件事：**我们应该编写"短小"的代码。**这是由人类理解复杂问题的能力决定的，只有短小的代码，我们才能有更好地把握，而要写出短小的代码，需要我们能够"分离关注点"。总结时刻今天我们讲解的坏味道是长参数列表，它同样是一个"我一说，你就知道是怎么回事"的坏味道。应对长参数列表主要的方式就是减少参数的数量，一种最直接的方式就是将参数列表封装成一个类。但并不是说所有的情况都能封装成类来解决，我们还要分析是否所有的参数都有相同的变动频率。1.  变化频率相同，则封装成一个类。        2.  变化频率不同的话：        3.  静态不变的，可以成为软件结构的一部分；        4.  多个变化频率的，可以封装成几个类。        除此之外，参数列表中经常会出现标记参数，这是参数列表变长的另一个重要原因。对于这种标记参数，一种解决方案就是根据这些标记参数，将函数拆分成多个函数。如果今天的内容你只能记住一件事，那请记住：**减小参数列表，越小越好**。![](Images/c4c3a4e42a532abae8ca44f7dedbd262.png)savepage-src="https://static001.geekbang.org/resource/image/9e/6d/9e1ce13379855142f535f999feaa5e6d.jpg"}思考题你曾经遇到的长参数列表有多长呢？你是怎样解决它的呢？欢迎在留言区分享你的经历。也建议你"在教中学"，充分吸收理解这一讲的内容，并讲给自己的团队听。感谢阅读，我们下一讲再见。参考资料：slate-object="mark"}02 \|分离关注点：软件设计至关重要的第一步14 \|面向对象之封装：怎样的封装才算是高内聚？
# 07 \| 滥用控制语句：出现控制结构，多半是错误的提示你好，我是郑晔。在前面几讲，我们已经讲了不少的坏味道，比如长函数、大类等。对于有一定从业经验的程序员来说，即便不能对这些坏味道有一个很清楚的个人认知，但至少一说出来，通常都知道是怎么回事。但这节课我要讲的坏味道对于很多人来说，可能就有点挑战了。这并不是说内容有多难，相反，大部分人对这些内容简直太熟悉了。所以，当我把它们以坏味道的方式呈现出来时，这会极大地挑战很多人的认知。这个坏味道就是滥用控制语句，也就是你熟悉的 if、for等等，这个坏味道非常典型，但很多人每天都用它们，却对问题毫无感知。今天我们就先从一个你容易接受的坏味道开始，说一说使用控制语句时，问题到底出在哪。嵌套的代码我给你看一张让我印象极其深刻的图，看了之后你就知道我要讲的这个坏味道是什么了。![](Images/b68a67051ad9e4fe54f7c9259e6e3c27.png)savepage-src="https://static001.geekbang.org/resource/image/20/4f/207d60ffb815dff3272090f876503a4f.jpeg"}图片来源于网络相信不少同学在网上见过这张图，是的，我们接下来就来讨论**嵌套的代码**。考虑到篇幅，我就不用这么震撼的代码做案例了，我们还是从规模小一点的代码开始讨论：    public void distributeEpubs(final long bookId) {      List epubs = this.getEpubsByBookId(bookId);      for (Epub epub : epubs) {        if (epub.isValid()) {          boolean registered = this.registerIsbn(epub);          if (registered) {            this.sendEpub(epub);          }        }                                                  }    }这是一段做 EPUB 分发的代码，EPUB是一种电子书格式。在这里，我们根据作品 ID 找到要分发的 EPUB，然后检查EPUB 的有效性。对于有效的 EPUB，我们要为它注册 ISBN信息，注册成功之后，将这个 EPUB发送出去。 代码逻辑并不是特别复杂，只不过，在这段代码中，我们看到了多层的缩进，for循环一层，里面有两个 if，又多加了两层。即便不是特别复杂的代码，也有这么多的缩进，可想而知，如果逻辑再复杂一点，缩进会成什么样子。这段代码之所以会写成这个样子，其实就是我在讲"长函数slate-object="inline""那节课里所说的："**平铺直叙地写代码**"。这段代码的作者只是按照需求一步一步地把代码实现出来了。从实现功能的角度来说，这段代码肯定没错，但问题在于，在把功能实现之后，他停了下来，而没有把代码重新整理一下。那我们就来替这段代码作者将它整理成应有的样子。既然我们不喜欢缩进特别多的代码，那我们就要消除缩进。具体到这段代码，一个着手点是for 循环，因为通常来说，for循环处理的是一个集合，而循环里面处理的是这个集合中的一个元素。所以，我们可以把循环中的内容提取成一个函数，让这个函数只处理一个元素，就像下面这样：    public void distributeEpubs(final long bookId) {      List epubs = this.getEpubsByBookId(bookId);      for (Epub epub : epubs) {        this.distributeEpub(epub)；      }    }    private void distributeEpub(final Epub epub) {      if (epub.isValid()) {        boolean registered = this.registerIsbn(epub);        if (registered) {          this.sendEpub(epub);        }      }    }这里我们已经有了一次拆分，分解出来 distributeEpub函数每次只处理一个元素。拆分出来的两个函数在缩进的问题上，就改善了一点。第一个函数 distributeEpubs只有一层缩进，这是一个正常函数应有的样子，不过，第二个函数distributeEpub则还有多层缩进，我们可以继续处理一下。if 和 else在 distributeEpub 里，造成缩进的原因是 if 语句。通常来说，if语句造成的缩进，很多时候都是在检查某个先决条件，只有条件通过时，才继续执行后续的代码。这样的代码可以使用卫语句（guardclause）来解决，也就是设置单独的检查条件，不满足这个检查条件时，立刻从函数中返回。这是一种典型的重构手法：**以卫语句取代嵌套的条件表达式（Replace Nested Conditionalwith Guard Clauses）**。我们来看看改进后的 distributeEpub函数：     private void distributeEpub(final Epub epub) {      if (!epub.isValid()) {        return;      }            boolean registered = this.registerIsbn(epub);      if (!registered) {        return;      }            this.sendEpub(epub);    }改造后的 distributeEpub就没有了嵌套，也就没有那么多层的缩进了。你可能已经发现了，经过我们改造之后，代码里只有一层的缩进**。**当代码里只有一层缩进时，代码的复杂度就大大降低了，理解成本和出现问题之后定位的成本也随之大幅度降低。**函数至多有一层缩进**，这是"对象健身操（《ThoughtWorks文集  slate-object="inline"》书里的一篇）"里的一个规则。前面讲"大类slate-object="inline""的时候，我曾经提到过"对象健身操"这篇文章，其中给出了九条编程规则，下面我们再来讲其中的一条：**不要使用 else关键字**。没错， **else也是一种坏味道，这是挑战很多程序员认知的**。在大多数人印象中，if 和 else是亲如一家的整体，它们几乎是比翼齐飞的。那么，else可以不写吗？可以。我们来看看下面的代码：    public double getEpubPrice(final boolean highQuality, final int chapterSequence) {      double price = 0;      if (highQuality && chapterSequence > START_CHARGING_SEQUENCE) {        price = 4.99;      } else if (sequenceNumber > START_CHARGING_SEQUENCE            && sequenceNumber  FURTHER_CHARGING_SEQUENCE) {        price = 2.99;      } else {        price = 0.99;      }            return price;    }这是一个根据 EPUB信息进行定价的函数，它的定价逻辑正如代码中所示。1.  如果是高品质书，而且要是章节序号超过起始付费章节，就定价    4.99；    2.  对一般的书而言，超过起始付费章节，就定价    1.99；超过进一步付费章节，就定价    2.99。    3.  缺省情况下，定价 0.99。        就这段代码而言，如果想不使用else，一个简单的处理手法就是让每个逻辑提前返回，这和我们前面提到的卫语句的解决方案如出一辙：    public double getEpubPrice(final boolean highQuality, final int chapterSequence) {      if (highQuality && chapterSequence > START_CHARGING_SEQUENCE) {        return 4.99;      }             if (sequenceNumber > START_CHARGING_SEQUENCE            && sequenceNumber  FURTHER_CHARGING_SEQUENCE) {        return 2.99;      }       return 0.99;对于这种逻辑上还比较简单的代码，这么改造还是比较容易的，而对于一些更为复杂的代码，也许就要用到多态来改进代码了。不过在实际项目中，大部分代码逻辑都是逐渐变得复杂的，所以，最好在它还比较简单时，就把坏味道消灭掉。这才是最理想的做法。无论是嵌套的代码，还是 else语句，我们之所以要把它们视为坏味道，本质上都在追求简单，因为一段代码的分支过多，其复杂度就会大幅度增加。我们一直在说，人脑能够理解的复杂度是有限的，分支过多的代码一定是会超过这个理解范围。在软件开发中，有一个衡量代码复杂度常用的标准，叫做圈复杂度（Cyclomatic complexity，简称CC），圈复杂度越高，代码越复杂，理解和维护的成本就越高。在圈复杂度的判定中，循环和选择语句占有重要的地位。圈复杂度可以使用工具来检查，比如，在Java 世界中，有很多可以检查圈复杂度的工具，我们之前提到过的 Checkstyle就可以做圈复杂度的检查slate-object="inline"，你可以限制最大的圈复杂度，当圈复杂度大于某个值的时候，就会报错。只要我们能够消除嵌套，消除else，代码的圈复杂度就不会很高，理解和维护的成本自然也就会随之降低。重复的 Switch通过前面内容的介绍，你会发现，循环和选择语句这些你最熟悉的东西，其实都是坏味道出现的高风险地带，必须小心翼翼地使用它们。接下来，还有一个你从编程之初就熟悉的东西，也是另一个坏味道的高风险地带。我们来看两段代码：    public double getBookPrice(final User user, final Book book) {      double price = book.getPrice();      switch (user.getLevel()) {        case UserLevel.SILVER:          return price * 0.9;        case UserLevel.GOLD:           return price * 0.8;        case UserLevel.PLATINUM:          return price * 0.75;        default:          return price;      }    }    public double getEpubPrice(final User user, final Epub epub) {      double price = epub.getPrice();      switch (user.getLevel()) {        case UserLevel.SILVER:          return price * 0.95;        case UserLevel.GOLD:           return price * 0.85;        case UserLevel.PLATINUM:          return price * 0.8;        default:          return price;      }    }这两段代码，分别计算了用户在网站上购买作品在线阅读所支付的价格，以及购买EPUB格式电子书所支付的价格。其中，用户实际支付的价格会根据用户在系统中的用户级别有所差异，级别越高，折扣就越高。显然，这两个函数里出现了类似的代码，其中最类似的部分就是switch，都是根据用户级别进行判断。事实上，这并不是仅有的根据用户级别进行判断的代码，各种需要区分用户级别的场景中都有类似的代码，而这也是一种典型的坏味道：**重复的 switch（RepeatedSwitch）**。之所以会出现重复的switch，通常都是缺少了一个模型。所以，应对这种坏味道，重构的手法是：**以多态取代条件表达式（Relace Conditional withPolymorphism）**。具体到这里的代码，我们可以引入一个 UserLevel 的模型，将switch 消除掉：    interface UserLevel {      double getBookPrice(Book book);      double getEpubPrice(Epub epub);    }    class RegularUserLevel implements UserLevel {      public double getBookPrice(final Book book) {        return book.getPrice();      }            public double getEpubPrice(final Epub epub) {        return epub.getPrice();    }    class GoldUserLevel implements UserLevel {      public double getBookPrice(final Book book) {        return book.getPrice() * 0.8;      }            public double getEpubPrice(final Epub epub) {        return epub.getPrice() * 0.85;      }    }    class SilverUserLevel implements UserLevel {      public double getBookPrice(final Book book) {        return book.getPrice() * 0.9;      }            public double getEpubPrice(final Epub epub) {        return epub.getPrice() * 0.85;      }    }    class PlatinumUserLevel implements UserLevel {      public double getBookPrice(final Book book) {        return book.getPrice() * 0.75;      }            public double getEpubPrice(final Epub epub) {        return epub.getPrice() * 0.8; 有了这个基础，前面的代码就可以把 switch去掉了：     public double getBookPrice(final User user, final Book book) {      UserLevel level = user.getUserLevel()      return level.getBookPrice(book);    }    public double getEpubPrice(final User user, final Epub epub) {      UserLevel level = user.getUserLevel()      return level.getEpubPrice(epub);    }我在《软件设计之美》讲开放封闭原则slate-object="inline"的时候，用的例子和这段代码是类似的，里面也有调整的过程，你有兴趣的话，不妨去看一下。只不过，在那个例子里面，我们看到的是一连串的"if..else"。我们都知道，switch 其实就是一堆" if..else"的简化写法，二者是等价的，所以，这个重构手法，以多态取代的是条件表达式，而不仅仅是取代switch。 其实，关于控制语句还有一个坏味道，那就是循环语句。没错，循环本身就是一个坏味道，但讲解它还需要一些知识的铺垫，所以，我会把它放到后面第13节，讲"落后的代码风格"时再来讲解。这里，你只要知道循环语句也是一个坏味道就够了。总结时刻今天我们讲了程序员们最熟悉的控制语句：选择语句和循环语句。遗憾的是，这些语句今天都成了坏味道的高发地带，以各种形态呈现在我们面前：1.  嵌套的代码；        2.  else 语句；        3.  重复的 switch；        4.  循环语句。        嵌套的代码也好，else语句也罢，二者真正的问题在于，它们会使代码变得复杂，超出人脑所能理解的范畴。我们可以通过提取单个元素操作，降低循环语句的复杂度，而用卫语句来简化条件表达式的编写，降低选择语句的复杂度。一个衡量代码复杂度的标准是圈复杂度，我们可以通过工具检查一段代码的圈复杂度。重复的 switch本质上是缺少了一个模型，可以使用多态取代条件表达式，引入缺少的模型，消除重复的switch。 如果今天的内容你只能记住一件事，那请记住：**循环和选择语句，可能都是坏味道。**![](Images/e92cd818337ab06ddfe4a9ea139ccd79.png)savepage-src="https://static001.geekbang.org/resource/image/6c/9f/6c9aedb0d5d58a0eaf08c7fe36040a9f.jpg"}思考题今天讨论的坏味道挑战了很多人习以为常的编码方式，我想请你谈谈你和这些语句的故事，是不舍也好，是纠结也罢，欢迎在留言区分享你的看法。如果这节课的内容确实颠覆了你的认知，也欢迎你把它分享出去，让更多人知道。感谢阅读，我们下一讲再见！参考资料：开放封闭原则：不改代码怎么写新功能？