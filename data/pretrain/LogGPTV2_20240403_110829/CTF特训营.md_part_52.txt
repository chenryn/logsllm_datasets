"3":
"4"."
"5":
"6”:"-.
"7"; **
---
## Page 635
CTF特训营：技术详解、解题方法与
19.3 morsecode
635/1144
"8"."...."
“9":“
m.
m,m, 
",n, "
"?". "
"_=.
"=;"-
"7:"-
“@”:"
morse_to_alphabet ={v:k for k,v in alphabet_to_morse.iteritems()})
def_morseremoveunusablecharacters(uncorrected_string):
return filter(lambda char: char in alphabet_to_morse,uncorrected_string.upper())
def morseencode(decoded):
:param decoded:
:return:
morsestring =
decoded = _morseremoveunusablecharacters(decoded)
decoded = decoded.upper()
words=decoded.split("")
for word in words:
letters=list(word)
forletterinletters:
morseletter=alphabet_to_morse[letter]
morseword.append(morseletter)
word ="/.join(morseword)
morsestring.append(word)
return""join(morsestring)
---
## Page 636
CTF特训营：技术详解、解题方法与
19.3 morsecode
636/1144
def morsedecode(encoded):
:param encoded:
:return:
characterstring =
words = encoded.split(" ")
for word in words:
letters = word.split("/")
characterword=
forletterinletters:
characterletter=morse_to_alphabet[letter]
characterword.append(characterletter)
word = ".join(characterword)
characterstring.append(word)
return""join(characterstring)
---
## Page 637
CTF特训营：技术详解、解题方法与
19.4jsfuck
637/1144
19.4  jsfuck
jsfuck是一种非常有意思的编码方式，仅使用6个字符就可以书写
任意的JavaScript代码。比如：
alert(1)
经过jsfuck编码后，就变成了：
D[（+)[+]+([]+D)[+!+[+[+]+（!+)[++!+]+（！!+)[+]+（!+)[++!++!+]+（！
D+0[++m（0[（0+[++（[+m）[++0+[++（0+0+0+1++（！!+0[++（！!+D!+0
+1++1+]+（+0）[+|+]+)[++1++1+]+（1+[（(+0）[+]+（[]+）[+++[++（+
)[++!+]+（+0)[+]+（！0+0)[++1++1+]+（1+0)[++0】)[+1+0+[+D]+（00]+0)[++]+
+i+](（+[□]）)+[0+]（□+i）]0）+[□+](0+[0）+[0+i+]（0+□i）+[□+]（□+□i1）+[0+i+□+i+□+i]（0+
D+[+0]+（0+0)[+0+1+]+（110+0)[+0]+（110+0)[++1+0+1+]+（110+0)[+1+0]+0)[+0+1++1+[
]+（！!+)[+]+(！!+[（！+□)[+]+([]+)[+!++[+]+（!+)[!++!+]+（！!+D)[+]+（！!+
+[□+i+□+i](□+□i）+[□+i+]（□+□i）)[+i+]（0+□i1）+[+]+□+i+]（[□+i+](□+□1）+[□+i++i+□+i]（D
！+□）[+□+!++!+]+（！+□)[+!+]+（！!+□）[+]+（1+D[（!+□）[+]+（[]+D【)[+!++[+]+（！
D+0)[+0+!+0]+（!!0+D)[+0]+（1!0+0)[+0+!+0+!+0]+（1!0+0)[+!+0)[+0+!+0+[+0]+[+1+0]+（!!
+[0+i+□+i+□+i]（□+□ii）+[□+]（□+□ii）+[0+i++i](□+□i）+[+]+□+i+]（[+[□i）+[□+](0+□i）]+
0（[+]+0+j+0+i]（[+j+]（0+□i）
从直观上非常容易辨识出这种编码方式，只需要“+！这6个
字符组成的字符串。jsfuck的编码和解码与morsecode类似，只不过
其表示的是Javascript的语句。可以使用下面列举的在线解码网站解
码。
---
## Page 638
CTF特训营：技术详解、解题方法与
19.4jsfuck
638/1144
http://www.jsfuck.com
http://utf-8.jp/public/jsfuck.html
举个例子，如图19-2所示，可以对如下的jsfuck进行解码：
D[（!+0)[+]+([]+D])[+!+[+[+】]+（!+D)[!++!+]+（！+D)[+]+（！!+D)[!++!++!+]+（!
+)[+|+[（[(+)[+]+(]+D)[+++[+]+（+D)[+++]+（+0)[++（+0)[+
+i）+[+]+□+i+]（[+[□i）+[+](0+□i)]+□ii）+[□+i++i+□+i]（□+[+i+]（□+□ii）+[0+i+□+i+
)+[0+1+]（0+[0】0）+[10+]+0+1+]（[1□+1+](0+□1）+[0++0+1+0+1]（0+011）+[0+](0+011）+[0+1+0+1]（[
+i+]（[□0+[0]）+[0+]（0+0）】0）+[0+]（□+[00）+[0+i+]（0+□i）+[0+]（0+i）+[0+i++i+□+i]（0+0i
]+i++i++i](□+[+i+]（+□ii）+[+i++i+□+i]（□+□ii）+[+](+□ii）+[+i++i]（□+□i）+[□+]+
1+（110+0)+0+（110+0【（0+0）+0]+（0)+00)+1+0++0+（0+0)+0+1+0]+（110+0+0)+（10+
)+[0+i+□+i1（0+□i）+[0+i+]（0+□i）+j+1（0+□ii）+[0+]+0+i+1（[+i+]（0+i）+[0+j+□+i+0+i1（0
i）+[1+]+0+i+]([+[□i]）+[□+](0+□i）]+□i）+[0+]（□+□ii）+[□+i+](0+□i）+[+i++j++i](□+□
+□i)]（□+□）+[+]+□+j+□+1]（1+j+](0+□1)+[0+1++j+□+1]（□+□1)+[□+]（□+□1）+[0+j+□+j]（0+□
D)[+]+（!!0+[（D+D)[+]+（[0]+)[+1+0+[+】]+（1+D)[!+0+1+]+（!!0+D)[+D]+（!!+D)[!+0+
！++!+]+（!+D)[+!+m)[+!++[+】]+（D]+D)[+!+]+（!!+D)[+]+（[（!+D)[+]+([！]+D])
[+!++[+]+（!+D)[++!+]+（+D)[+]+（！+D)[!++!++!+]+（！+D)[+!+]+D)[!++!+
++]+（！+[（+）++（]+）[+++[++（+）[+++]+（！+)[+]+（！+□)++!
++1+]+(！+)[++)[+1++[+]+(+)[++1+]+(+D[（+)[+]+([]+)[+1++[+
（(0+□ii）+[+]++i+]（+i+]（0+□ii）+[+i++i++i]（□+□ii)+[0+]（□+□ii）++i++i]（□+□i）+[
+!+]([+!++[!++!+]+(!+D)[+]+（！+)[！++!+]+（!+D)[+!+]+(+!+[!]+（□+D)[（[（
+0)[+]+([0]+00)[+1+0+[+0]+（10+0)[+0+1+]+（110+0)[+0]+(110+0)[+0+++1+]+(10+0）
[++]+D)[+++++]+（！+D[（+0)[++(+D)+++[+]+(+D)[++++（+
)[+]+（！!+□)[++!++!+]+（□+□)[+!+[】)[+!++[+]+（]+□)[+!+]+（+□)[!++!+[+!+
]+（！!+）[+]+（!+□[+!+]+（D]+□)[+]+（D[（+□）[+]+（[]+）)[+|++[+]+（！+□[!+
]+1+]+（！+D)[+]+（!!+)[!++!++!+]+（！!+D)[+!+D]+D)[++!++!+]+（+D[+D]+（!
+[（+0)[++(+0)+++[++(+D)[++++（+0)[+]+（1+0)[+++++]+
0+0）+1+0)+1+0++0+（110+0[+1+0m)[+0+1+0++0]+（0+0)（0+0)+0]+（10+0【（0+0)+
0]+（[0]+00]）[+1+0+[+0】]+（10+0)[+0+1+0]+（10+0)[+0]+（10+0)[+0+1+0+1+0]+（10+0）[+1+0
11)[+++[++（+0）[+++（1+0）[++（（+0）+]+（[+）[+++[++（+)+
+1+]+（+□）[+]+（+□）[+[+!+[+!+]+（！+□)[+!+]+□)[+□+1++!+]+（1+[（+□)[+
[0+i+]（0+□）+[0+1+□+i+0+i]（0+□1）+[0+]（0+01）+[0+i+0+1](0+□1）+[10+]+0+i+](0】0+[01])+[
1)[+!++[+]+（!+D)[++!+]+（！!+[（!+D)[+]+([！]+D)[+!++[+】]+（!+)[!++!+]+
！!+□)[+]+（！+□)[!++!+[+!+]+（！!+□)[+!+)[+!++[+]+（！+□)[+!+([+!+□+[！++!+
0]+（0+0[（0+0)[+0]+（[0]+00])[+1+0+[+0]+（10+0)[+0+1+0]+（10+0)[+0]+（110+0)[+0+1+0
+!+]+（!+□)[+!+)[!++!++[+)
---
## Page 639
CTF特训营：技术详解、解题方法与
19.4 jsfuck
639/1144
[]+[+[]1]+(1[]+[]] [1+[]+1+[]+(11[]+[]} [+[3]+(11[]+[)[1+[]+1+[]+1+[]]+(
D+[口])+[目+]（口+D）]][[+1+](+日1]+[++目+++]（+11)
www.jsfuck.com显示：
[+1[+）[+1D++[]（1+00+）++（[0]+【0）[+0
[]+}[1+[+1+[]+（11[]+[）[+]+（11+）[+[]+1+[+1+[]+（11[]+）[+1
flag
0+1+0]]+（1（0]+0）（+1+[0]+（10+0）[+0+1+[+1+0）+（110+0）[+0]+（11
[1]+(（0]+[）[+[]+(0[(1[+）[+[]+（[]+[]0])[+1+[+[+[1]+(10
确定
[++[]+（1[+[）[+]+（+[（[+）[+]+（[+）[+1++[+++
[]+1+[]+（1![+[]][+[]+（！1[]+）[1+[]+1+[]+1+[]+（1！[+[][+1+]]+[）[
[）[1+++[]+(110++]+（11[+)[+++[+1+[]+（110+0)[++[1[]
3095cbaze
Bus_ This
图19-2jsfuck解码示意图
---
## Page 640
CTF特训营：技术详解、解题方法与
19.5 uuencode
640/1144
19.5uuencode
uuencode是将二进制文件转化为可见字符文本的文件的一种编
码，转换后的文件可以通过纯文本的email进行传输，因为转换之后
仅包含可见字符。uuencode的运算法则是将连续的3字节扩展成4字
节，这一点与base64很像。该编码的效率高于hex。
uuencode也有在线编解码的网站：
http://www.qqxiuzi.cn/bianma/uuencode.php
我们观察uuencode的原文和编码：
flag{uuencode}
9FQA9WMU=65N8VJD97T
可以看到，编码之后的代码是非常杂乱无章的，什么可见字符都
有可能出现，其取值为32（空白）到95（底线），也就是没有小写字
母，因此uuencode也非常容易识别。
---
## Page 641
CTF特训营：技术详解、解题方法与
19.6base家族641/1144
19.6base家族
很多人都知道base64，但是除了base64，还有base32、base16
等很多隶属于base家族的编码方式。base家族的编码可以说是cTF竞
赛中的明星，不论是哪种类型、难度和模式的题目，都可以围绕或者
附带base家族的编码展开，其中base64出镜率极高。
与前面儿种编码的功能类似，base64以及base家族的其他各类
编码的功能，主要还是将特殊字符和不可见字符转换成常见字符，用
于网络传输。在使用hex的时候可以看到，一个字符变成了两个字符
这是因为我们需要用4bit的内容去表达16bit的内容所导致的，也就是
用16个字符去表达256个字符。如果我们用更多的字符去表达呢，比
如用32个字符和64个字符。因此base64、base32应运而生，base16
就是hex
下面就最常见的base64、base32，以及base16来进行介绍，如
表19-1所示。
表19-1三种编码字符集
---
## Page 642
CTF特训营：技术详解、解题方法与
19.6base家族
642/1144
编码方式
字符集
base64
a-z,A-Z.0-9,+，/共64个以及补位的
=’
base32
A-Z,2-7共32个以及补位的‘=’
base16
0-9,A-F共16个以及补位的‘=’
要想识别出一个编码是不是base家族的编码，一个是看最后有
没有“=”，如果有则一定是，如果没有，再看一下编码中包含的字
母，是否都在base家族对应的字符集上，如果完全对应则证明其是
base家族的编码。表19-2中列举了三个例子。
表19-2flag的三种basexx编码
flag
666C6167
flag
MZWGCZY=
flag
ZmxhZw==
从字符集的取值上可以很明显地看出，第一行使用的是
base16，第二行使用的是base32，第三行使用的是base64。
当然，使用Python进行base家族编码时，如果只是base64，我
---
## Page 643
CTF特训营：技术详解、解题方法与
19.6base家族
643/1144
们可以很方便地使用字符串的encode和decode进行编解码。如果是
base32和base16，则需要用到base64库中的函数来进行编解码，示
例代码：
import base64
print base64.b16encode(*flag")
print base64.b32decode(“MzWGCzY=")
print base64.b32encode(*flag")
print base64.b64encode(*flag")
结果如下：
结果如下：
ZmxhZw=
flag
666C6167
flag
MZWGCZY=
flag
Zmxhzw==
flag
这里需要注意，在Python中使用字符串的encode时，会多出一
个空行。
下面我们来看表19-3所示的另外一个对比。
表19-3flag的base16和hex
“flag”的basel6
666C6167
“flag”的hex
666c6167
在Python中，两者只相差一个大小写，也就是说：
---
## Page 644
CTF特训营：技术详解、解题方法与
19.6base家族
644/1144
base64 .b16encode(*f1ag*) .1ower()
“flag".encode(“hex")
在Python中这两者是等价的。
我们都知道，base64等编码存在的意义是将所有字符的表达集
中在一些常见的、可见的字符集上。理解base64编码的方式也是很
有意义的，因为在很多分析base64算法的情况中，base64的算法是
修改后的，也就是私有base64。
首先我们都知道字符的天小是1byte，也就是8bit，3byte就有
24bit。然后，我们将这24bit切成4份，每份大小为6bit，转换成数字
后，在base64编码表中找到对应字母表示出来就行了，6bit正好能够
表达64个字符，正好对应base64字符集的取值范围，也就是说通过
这种变换方式每3个字符变成了4个字符。
下面列举一个例子，如图19-3所示。
---
## Page 645
CTF特训营：技术详解、解题方法与
19.6base家族
645/1144
A
S
T
65
83
84
01000001
01010011
01010100
010000
010101
001101
010100
16
21
13
20
图19-3
3base64编码示意图
如图19-3所示，三个连在一起的字符“AST”，分别对应数字
65、83、84。数字转换为二进制bit表示后，共24bit，然后6bit一组
切分成4组，并将6bit组成的数字转换为十进制，得到4个数字，然后
进行查表，如图19-4所示。
---
## Page 646
CTF特训营：技术详解、解题方法与
19.6base家族
646/1144
数值
字符
数值
字符
数值
字符
数值
字符
0
A
16
Q
32
g
48
W
1
B
17
R
33
h
49
X
2
C
18
S
34
50
y
3
D
19
T
35
i
51
Z
4
E
20
U
36
k
52
0
5
F
21
V
37
1
53
1
6
D
22
W
38
Im
54