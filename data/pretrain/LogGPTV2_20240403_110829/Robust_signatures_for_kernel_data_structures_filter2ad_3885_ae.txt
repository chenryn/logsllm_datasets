these constraints from our signature, we were able to ﬁnd the ter-
minated processes reported by other tools without introducing false
positives. We note that our scanner remains resistant to evasions,
as the remaining ﬁelds are all robust. The terminated processes
demonstrate the importance of generating signatures from a train-
ing set that represents the full range of objects one wishes to detect.
7. OTHER STRUCTURES
Although our experiments have only been run on EPROCESS,
we are conﬁdent that the technique will generalize to other data
structures. Certain structures in particular, such as threads (rep-
resented by ETHREAD in Windows) and ﬁles (FILE_OBJECT),
would be good candidates for signature generation, as they contain
a wealth of information about the runtime state of the system that is
useful for forensic analysis. We will brieﬂy consider what changes
might be needed to generate signatures for these structures.
The proﬁling stage is essentially the same for any structure: the
objects are created by some user-level program (i.e., by spawning
a thread or opening a ﬁle), their location in memory is determined,
and the memory region is monitored to log access to the structure.
In the fuzzing stage, the only signiﬁcant challenge is creating an ap-
propriate functionality test φ. As threads contain executable code,
one could simply use the same test as for processes: attempt to
create a ﬁle and ensure that the ﬁle is created successfully. For
ﬁle objects, one could test functionality by performing a range of
operations on the open ﬁle, such as reading, writing, seeking, and
closing the ﬁle. Finally, our signature generator is not speciﬁc to
any one object type and could be used as-is: the only input required
is a list of observed values for each ﬁeld in the data structure.
One ﬁnal complication may arise if the target structure is fairly
small. In this case, it may be that after eliminating weak features,
there will not be enough left to create a reliable signature (in the
sense of having few false positives). In this case, we might employ
a more sophisticated search technique: rather than simply using
basic pattern matching to ﬁnd instances of the structure, we could
take advantage of information such as the types of objects to which
it points. This technique has previously been used successfully in
other work to identify the types of objects on the heap [32], and
this additional contextual information could improve signature ac-
curacy.
8. FUTURE WORK
As discussed in Section 4.4, obtaining full coverage during fuz-
zing is impractical; however, but it may be possible to improve our
coverage through more judicious selection of random data. For
example, we might incorporate mutation fuzzing [29], which gen-
erates fuzz data by creating small, random variations on existing
values. This would help us more efﬁciently explore the space of
possible values, as for many ﬁelds legal values will be clustered
fairly close together.
The proﬁling stage could also be made more accurate by switch-
ing from simply monitoring whether a ﬁeld is accessed to attempt-
ing to determine how it is used. This would involve the use of taint
tracking [4] to ﬁnd out whether the value of a given ﬁeld actually
inﬂuences the execution of the OS. We expect that this could sig-
niﬁcantly reduce the number of ﬁelds that would need to be fuzzed.
Finally, although the automatically generated signatures from
our method appear to work well, they are based on dynamic anal-
ysis and may therefore suffer from coverage problems. Gaps in
coverage could lead to false negatives and evasions in the signature
matching process: a constraint inferred on a small number of sam-
ples may not be representative of the full range of values that ﬁeld
uses, and thus be overly restrictive. To improve conﬁdence in such
constraints, one could also use static analysis to attempt to prove
that the inferred constraints do, indeed, hold in all cases.
9. CONCLUSIONS
We have successfully demonstrated that it is possible to automat-
ically select robust features of data structures and generate evasion-
resistant signatures based on them. More importantly, we have
described a systematic way of determining which features to use
when creating a data structure signature. To our knowledge, no
such method was previously available, and we believe that many
applications will beneﬁt from this technique.
Our work resulted in a new signature for process data structures
on Windows, which can be used immediately by applications which
require the ability to locate processes in memory. We also showed
that existing signatures used by memory analysis applications were
575vulnerable to evasion, and in the case of PTFinder we described
precisely which constraints could be violated by an attacker. These
concrete contributions signiﬁcantly increase the difﬁculty of hiding
process objects from signature scans on Windows systems.
Acknowledgements
We would like to thank our anonymous reviewers and Matt Fredrik-
son for their helpful comments on earlier drafts of this paper. This
work is supported in part by NSF contract CNS-0831300 and DHS
contract FA8750-08-2-0141. The views and conclusions contained
herein are those of the authors and should not be interpreted as
necessarily representing the ofﬁcial policies or endorsements, ei-
ther expressed or implied, of the above governmental agencies or
the U.S. Government.
10. REFERENCES
[1] 90210. Bypassing Klister 0.4 with no hooks or running a
controlled thread scheduler. https://www.rootkit.
com/newsread.php?newsid=235.
[2] A. Baliga, V. Ganapathy, and L. Iftode. Automatic inference
and enforcement of kernel data structure invariants. In
Proceedings of the 24th Annual Computer Security
Applications Conference (ACSAC), Anaheim, California,
USA, 2008.
[3] P. Barham, B. Dragovic, K. Fraser, S. Hand, T. Harris,
A. Ho, R. Neugebauer, I. Pratt, and A. Warﬁeld. Xen and the
art of virtualization. In Proceedings of the 19th ACM
Symposium on Operating systems principles (SOSP), Bolton
Landing, NY, 2003.
[4] D. E. Bell and L. J. LaPadula. Secure computer systems:
Mathematical foundations. Technical Report MTR-2547,
MITRE Corp., Bedford, MA, 1973.
[5] C. Betz. MemParser. http:
//sourceforge.net/projects/memparser.
[6] bugcheck. GREPEXEC: Grepping executive objects from
pool memory. Uninformed Journal, 4, 2006.
[7] J. Butler. FU rootkit.
http://www.rootkit.com/project.php?id=12.
[8] T. M. Chilimbi, B. Davidson, and J. R. Larus.
Cache-conscious structure deﬁnition. In Proceedings of the
ACM SIGPLAN 1999 conference on Programming language
design and implementation (PLDI), Atlanta, GA, 1999.
[9] M. Christodorescu and S. Jha. Testing malware detectors. In
Proceedings of the 2004 ACM SIGSOFT International
Symposium on Software Testing and Analysis (ISSTA),
Boston, MA, 2004.
[10] A. Cozzie, F. Stratton, H. Xue, and S. T. King. Digging for
data structures. In Proceedings of the 8th USENIX
Symposium on Operating Systems Design and
Implementation (OSDI), 2008.
[11] T. Detristan, T. Ulenspiegel, Y. Malcom, and M. S. von
Underduk. Polymorphic shellcode engine using spectrum
analysis. http://www.phrack.com/issues.html?
issue=61&id=9, 2003.
[12] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamant,
C. Pacheco, M. S. Tschantz, and C. Xiao. The Daikon
system for dynamic detection of likely invariants. Science of
Computer Programming, 69(1–3), 2007.
[13] F-Secure. A different twist on the path to the kernel.
http://www.f-secure.com/weblog/archives/
00001507.html, 2008.
[14] P. Fogla and W. Lee. Evading network anomaly detection
systems: formal reasoning and practical techniques. In
Proceedings of the 13th ACM conference on Computer and
communications security (CCS), Alexandria, VA, 2006.
[15] J. E. Forrester and B. P. Miller. An empirical study of the
robustness of Windows NT applications using random
testing. In Proceedings of the 4th conference on USENIX
Windows Systems Symposium (WSS), Seattle, WA, 2000.
[16] M. V. Gundy, H. Chen, Z. Su, and G. Vigna. Feature
omission vulnerabilities: Thwarting signature generation for
polymorphic worms. In Proceedings of the 23rd Annual
Computer Security Applications Conference (ACSAC),
Miami Beach, FL, 2007.
[17] X. Jiang, X. Wang, and D. Xu. Stealthy malware detection
through VMM-based “out-of-the-box” semantic view
reconstruction. In Proceedings of the 14th ACM conference
on Computer and communications security (CCS),
Alexandria, VA, 2007.
[18] S. T. Jones, A. C. Arpaci-Dusseau, and R. H.
Arpaci-Dusseau. Antfarm: tracking processes in a virtual
machine environment. In Proceedings of the USENIX Annual
Technical Conference (ATEC), Boston, MA, 2006.
[19] S. T. Jones, A. C. Arpaci-Dusseau, and R. H.
Arpaci-Dusseau. VMM-based hidden process detection and
identiﬁcation using lycosid. In Proceedings of the fourth
ACM SIGPLAN/SIGOPS international conference on Virtual
execution environments (VEE), Seattle, WA, 2008.
[20] J. Kephart and W. Arnold. Automatic extraction of computer
virus signatures. In Proceedings of the 4th International
Virus Bulletin Conference (VB), Jersey, Channel Islands, UK,
1994.
[21] H.-A. Kim and B. Karp. Autograph: Toward automated,
distributed worm signature detection. In Proceedings of the
13th conference on USENIX Security Symposium,
volume 13, San Diego, CA, 2004.
[22] C. Kreibich and J. Crowcroft. Honeycomb: creating
intrusion detection signatures using honeypots. ACM
SIGCOMM Computer Communication Review, 34(1), 2004.
[23] Z. Li, M. Sanghi, Y. Chen, M.-Y. Kao, and B. Chavez.
Hamsa: Fast signature generation for zero-day polymorphic
worms with provable attack resilience. In Proceedings of the
2006 IEEE Symposium on Security and Privacy, Oakland,
CA, 2006.
[24] B. P. Miller, L. Fredriksen, and B. So. An empirical study of
the reliability of UNIX utilities. Communications of the
ACM, 33(12), 1990.
[25] B. P. Miller, D. Koski, C. Pheow, and L. V. Maganty. Fuzz
revisited: A re-examination of the reliability of UNIX
utilities and services. Technical report, 1995.
[26] S. Narayanasamy, G. Pokam, and B. Calder. Bugnet:
Continuously recording program execution for deterministic
replay debugging. In Proceedings of the 32nd annual
international symposium on Computer Architecture (ISCA),
Washington, DC, USA, 2005.
[27] National Institute of Standards and Technology (NIST). The
CFReDS project. http://www.cfreds.nist.gov/.
[28] J. Newsome, B. Karp, and D. Song. Polygraph:
Automatically generating signatures for polymorphic worms.
In Proceedings of the 2005 IEEE Symposium on Security and
Privacy, Oakland, CA, 2005.
[29] P. Oehlert. Violating assumptions with fuzzing. IEEE
Security and Privacy, 3(2), 2005.
576[30] B. D. Payne, M. Carbone, and W. Lee. Secure and ﬂexible
monitoring of virtual machines. In Proceedings of the 23rd
Annual Computer Security Applications Conference
(ACSAC), Miami Beach, FL, 2007.
[31] N. L. Petroni, Jr. and M. Hicks. Automated detection of
persistent kernel control-ﬂow attacks. In Proceedings of the
14th ACM conference on Computer and communications
security (CCS), Alexandria, VA, 2007.
[32] M. Polishchuk, B. Liblit, and C. W. Schulze. Dynamic heap
type inference for program understanding and debugging.
SIGPLAN Not., 42(1):39–46, 2007.
[33] M. Roesch. Snort: Lightweight intrusion detection for
networks. In Proceedings of the 13th USENIX conference on
System administration (LISA), Seattle, WA, 1999.
[34] J. Rutkowska. Klister v0.3. https:
//www.rootkit.com/newsread.php?newsid=51.
[35] J. Rutkowska. modGREPER - hidden kernel modules
detector. https://www.rootkit.com/newsread.
php?newsid=315, 2005.
[36] A. Schuster. Searching for processes and threads in
Microsoft Windows memory dumps. In Proceedings of the
6th Annual Digital Forensic Research Workshop (DFRWS),
Lafayette, IN, 2006.
[37] A. Seshadri, M. Luk, N. Qu, and A. Perrig. SecVisor: a tiny
hypervisor to provide lifetime kernel code integrity for
commodity OSes. In Proceedings of 21st ACM SIGOPS
symposium on Operating systems principles (SOSP),
Stevenson, WA, 2007.
[38] S. Singh, C. Estan, G. Varghese, and S. Savage. Automated
worm ﬁngerprinting. In Proceedings of the 6th USENIX
Symposium on Operating Systems Design and
Implementation (OSDI), San Francisco, CA, 2004.
[39] Solar Eclipse. Tiny PE. http:
//www.phreedom.org/solar/code/tinype/,
2006.
[40] Y. Song, M. Locasto, A. Stavrou, A. Keromytis, and
S. Stolfo. On the infeasibility of modeling polymorphic
shellcode. In Proceedings of the 14th ACM conference on
Computer and communications security (CCS), Alexandria,
VA, 2007.
[41] D. Spinellis. Reliable identiﬁcation of bounded-length
viruses is NP-complete. IEEE Transactions on Information
Theory, 49(1), 2003.
[42] P. Ször and P. Ferrie. Hunting for metamorphic. In
Proceedings of the 11th International Virus Bulletin
Conference, Prague, Czech Republic, 2001.
[43] valerino. Please don’t greap me! https://www.
rootkit.com/newsread.php?newsid=316, 2005.
[44] A. Vasudevan and R. Yerraballi. Stealth breakpoints. In
Proceedings of the 21st Annual Computer Security
Applications Conference (ACSAC), Tucson, AZ, 2005.
[45] VMWare. VMWare Server.
http://www.vmware.com/products/server/.
[46] A. Walters. The Volatility framework: Volatile memory
artifact extraction utility framework. https://www.
volatilesystems.com/default/volatility.
[47] A. Walters and N. Petroni. Volatools: Integrating volatile
memory forensics into the digital investigation process. In
Blackhat Federal, Washington, DC, 2007.
577