在前些天研究的时候，恰巧 **mengchen@知道创宇404实验室**
也发表了[协议层的攻击——HTTP请求走私](https://paper.seebug.org/1048/)文章，也带给了自己更多的启示，师傅的文章写的非常的不错，墙裂建议阅读，这里我结合师傅的文章跟自己的一些理解进行一些整理，本文亦可理解为那篇文章的补充与更详细的描述。
整篇文章由于自己时间问题，前前后后拖了两个月左右，中间时间间隔可能比较久，所以文章会有比较多的疏漏，还请师傅们看后直接指出斧正。写作不易，还请师傅们多多担待。最近也一直在关注这方面的安全问题，欢迎一起学习讨论:
) 联系方式：emVkZHl1Lmx1QGdtYWlsLmNvbQ==
后续如果有新的总结发现也会发自己的[垃圾博客](https://blog.zeddyu.info)或者先知（就看国际黑客陈师傅给不给过了）
# TL;NR
Pic from 
# TimeLine
在我们提 HTTP Smuggling 之前我们首先来看看其中的演变过程：
@Amit Klein 在 2004 年提出 [HTTP Response
Splitting](https://dl.packetstormsecurity.net/papers/general/whitepaper_httpresponse.pdf)
技术，是 HTTP Smuggling 攻击的雏形。
关于 HTTP Smuggling 这种攻击方式在 2005 年已由 @Watchfire 首次提出 [HTTP Request
Smuggling](https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf) 。
HTTP Parameter Pollution (HPP)，也就是 HTTP 参数污染，这其实也算是一种"特殊"的 HTTP Smuggling 攻击，在
2009 年由 @Stefano di Paola & @Luca Carettoni 在 OWASP Poland conference
上首次提出，一经提出就引起了比较大的轰动，被广泛运用在绕过 WAF 当中。
2016 年 Defcon 24 ，@regilero 提出了 [Hiding Wookiees In
Http](\[https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf\]\(https://media.defcon.org/DEF CON 24/DEF CON 24
presentations/DEF CON 24 - Regilero-Hiding-Wookiees-In-Http.pdf))，进一步揭示了 HTTP
Smuggling 这种攻击方式。
2019 年 Defcon 27， @James Kettle 提出了 [HTTP Desync Attacks: Smashing into the
Cell Next
Door](\[https://media.defcon.org/DEF%20CON%2027/DEF%20CON%2027%20presentations/DEFCON-27-albinowax-HTTP-Desync-Attacks.pdf\]\(https://media.defcon.org/DEF CON 27/DEF CON 27
presentations/DEFCON-27-albinowax-HTTP-Desync-Attacks.pdf))，讲解了如何用 HTTP
Smuggling 技术挖掘到了 Paypal 的漏洞。
# Causes
然而@James Kettle 的 PPT 里面也并没有非常详细细致地讲述这个攻击是什么，以及怎么形成的，当初自己看完还是抱着非常大的疑惑的，后来学习了
@regilero 博客中关于 [HTTP Smuggling
的文章](https://regilero.github.io/tag/Smuggling/)，我才有了清晰的认识。
## HTTP Connection Mod
> ​
> 在`HTTP1.0`之前的协议设计中，客户端每进行一次HTTP请求，就需要同服务器建立一个TCP链接。而现代的Web网站页面是由多种资源组成的，我们要获取一个网页的内容，不仅要请求HTML文档，还有JS、CSS、图片等各种各样的资源，这样如果按照之前的协议设计，就会导致HTTP服务器的负载开销增大。于是在`HTTP1.1`中，增加了`Keep-> Alive`和`Pipeline`这两个特性。
### Keep-Alive
根据 [RFC7230](https://tools.ietf.org/html/rfc7230#section-6) 我们可以知道
> ​ HTTP/1.1 defaults to the use of "persistent connections", allowing
> multiple requests and responses to be carried over a single connection. The
> "close" connection option is used to signal that a connection will not
> persist after the current request/response. HTTP implementations SHOULD
> support persistent connections.
在 HTTP/1.1 中默认使用`Keep-Alive`，从而允许在单个连接上承载多个请求和响应。
> 所谓`Keep-Alive`，就是在HTTP请求中增加一个特殊的请求头`Connection: Keep-> Alive`，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接，这样只需要进行一次TCP握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。当然，这个特性在`HTTP1.1`中是默认开启的。
当然，有些请求带着`Connection: close`的话，通信完成之后，服务器会中断 TCP 连接。
### Pipline
> 有了`Keep-> Alive`之后，后续就有了`Pipeline`，在这里呢，客户端可以像流水线一样发送自己的HTTP请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。
>
> 现如今，浏览器默认是不启用`Pipeline`的，但是一般的服务器都提供了对`Pipleline`的支持。
在 HTTP/1.1 中比较重要的引入就是 pipeline 技术了，以下是使用以及不使用 piepeline 技术的对比图：
我们可以清晰地看到，使用了 pipeline 之后不必再需要等待前一个请求完成其响应再处理第二个请求了，这个有点异步处理的意思在里面。
## Message Body
### Transfer-Encoding
> ​ Transfer-Encoding is analogous to the Content-Transfer-Encoding field of
> MIME, which was designed to enable safe transport of binary data over a
> 7-bit transport service ([RFC2045], Section 6). However, safe transport has
> a different focus for an 8bit-clean transfer protocol. In HTTP's case,
> Transfer-Encoding is primarily intended to accurately delimit a dynamically
> generated payload and to distinguish payload encodings that are only applied
> for transport efficiency or security from those that are characteristics of
> the selected resource.
Transfer-Encoding 是一种被设计用来支持 7-bit 传输服务安全传输二进制数据的字段，有点类似于 MIME (Multipurpose
Internet Mail Extensions) Header 中的 Content-Transfer-Encoding
。在HTTP的情况下，Transfer-Encoding 的主要用来以指定的编码形式编码 payload body 安全地传输给用户。在 HTTP/1.1
中引入，在 HTTP/2 中取消。
[MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding) 列举了几种属性：
    chunked | compress | deflate | gzip | identity
我们这里主要关注 chunked 这一种传输编码方式，它在网络攻击中也不是第一次提及了，之前就有师傅利用这个字段去绕过一些 WAF，可以参考
[利用分块传输吊打所有WAF](https://www.freebuf.com/articles/web/194351.html)，也是比较有意思的
bypass 技巧。
我们可以在[RFC7230](https://tools.ietf.org/html/rfc7230#section-4.1)中查看到有关分块传输的定义规范。
> 4.1. Chunked Transfer Coding
>
> The chunked transfer coding wraps the payload body in order to  
>  transfer it as a series of chunks, each with its own size indicator,  
>  followed by an OPTIONAL trailer containing header fields. Chunked  
>  enables content streams of unknown size to be transferred as a  
>  sequence of length-delimited buffers, which enables the sender to  
>  retain connection persistence and the recipient to know when it has  
>  received the entire message.
>  
>  
>     chunked-body   = *chunk
>                       last-chunk
>                       trailer-part
>                       CRLF
>
>  
>  chunk = chunk-size [ chunk-ext ] CRLF  
>  chunk-data CRLF  
>  chunk-size = 1 _HEXDIG  
>  last-chunk = 1_("0") [ chunk-ext ] CRLF  
>  
>  chunk-data = 1*OCTET ; a sequence of chunk-size octets
>
> The chunk-size field is a string of hex digits indicating the size of  
>  the chunk-data in octets. The chunked transfer coding is complete  
>  when a chunk with a chunk-size of zero is received, possibly followed  
>  by a trailer, and finally terminated by an empty line.
>
> A recipient MUST be able to parse and decode the chunked transfer  
>  coding.
>
> 4.1.1. Chunk Extensions
>
> The chunked encoding allows each chunk to include zero or more chunk  
>  extensions, immediately following the chunk-size, for the sake of  
>  supplying per-chunk metadata (such as a signature or hash),  
>  mid-message control information, or randomization of message body  
>  size.
>  
>  
>     chunk-ext      = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
>
>  
>  chunk-ext-name = token  
>  chunk-ext-val = token / quoted-string
>
> The chunked encoding is specific to each connection and is likely to  
>  be removed or recoded by each recipient (including intermediaries)  
>  before any higher-level application would have a chance to inspect  
>  the extensions. Hence, use of chunk extensions is generally limited
>
> to specialized HTTP services such as "long polling" (where client and  
>  server can have shared expectations regarding the use of chunk  
>  extensions) or for padding within an end-to-end secured connection.
>
> A recipient MUST ignore unrecognized chunk extensions. A server  
>  ought to limit the total length of chunk extensions received in a  
>  request to an amount reasonable for the services provided, in the  
>  same way that it applies length limitations and timeouts for other  
>  parts of a message, and generate an appropriate 4xx (Client Error)  
>  response if that amount is exceeded.
这里如果你不想看的太仔细，我们只需要了解它是怎么一种结构就行了，这里也可以参考 [Wiki: Chunked transfer
encoding](https://en.wikipedia.org/wiki/Chunked_transfer_encoding) ，比如说我们如果要使用
chunked 发送以下消息
    Wikipedia in\r\n\r\nchunks.
我们可以这么去发送：
    POSTT /xxx HTTP/1.1
    Host: xxx
    Content-Type: text/plain 
    Transfer-Encoding: chunked
    4\r\n
    Wiki\r\n
    5\r\n
    pedia\r\n
    e\r\n
     in\r\n\r\nchunks.\r\n
    0\r\n
    \r\n
这里做个简单解释， **我们使用`\r\n`表示 CRLF ，所以这里的`\r\n`是两个字节**；第一个数字 4 表示的是接下来会有 4
个字节的数据，也就是 Wiki 这 4 个字母，然后按照 RFC 文档标准，字母 Wiki 部分后面需要跟`\r\n`表示 chunk-data 部分，数字
4 后面需要跟`\r\n`表示 chunk-size 部分，而且这个数字是个十六进制数，比如第三个数据，
    e\r\n
    in\r\n\r\nchunks.\r\n
这里第一个存在空格，数据当中的`\r\n`算两个字符，最后一个`\r\n`表示数据结束，这样的话，第一个空格 1 个字节 + in 2个字节 + 2 个
`\r\n` 算 4 个字节 + chunks. 7个字节 = 14 个字节，十六进制表示 14 也就是 e 。
最后一个`0\r\n\r\n`表示 chunk 部分结束。
## Background
本身这些东西是没有什么危害的，都是通过各种方式提高网络传输速率，但是在一些特殊的情况下就会出现了一些相应的安全问题。
> ​
> 为了提升用户的浏览速度，提高使用体验，减轻服务器的负担，很多网站都用上了CDN加速服务，最简单的加速服务，就是在源站的前面加上一个具有缓存功能的反向代理服务器，用户在请求某些静态资源时，直接从代理服务器中就可以获取到，不用再从源站所在服务器获取。这就有了一个很典型的拓扑结构。
这里引用 @mengchen 师傅发的图：
一般来说，反向代理与后端服务器不会使用 pipeline 技术，甚至也不会去使用 Keep-Alive ，更多时候反向代理采取的措施是重用 TCP
链接，因为对于反向代理与后端服务器来说，反向代理服务器与后端服务器 IP 相对固定，不同用户的请求通过代理服务器与后端服务器建立链接，将这两者之间的 TCP
链接进行重用，也就顺理成章了。
> ​
> 当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。
HTTP Smuggling 攻击正是基于反向代理与后端服务器对于 HTTP 请求解析处理不一致，利用这种差异性我们可以在一个 HTTP 请求中 “嵌入”
另一个 HTTP 请求，以达到我们“走私”请求的目的，直接表现为我们可以访问内网服务，或者造成一些其他的攻击。
## Attack Method
既然是基于解析差异，那我们会有什么解析差异呢？场景仍然是上述构架的场景，只不过我们简化一下，把后端服务器固定为一台，就不存在某些概率的情况了。也就是说，架构类似于如下示意图：
    User            Front           Backend
    |               |               |
    |------A------->|               | 
    |               |-------A------>| 
    |               | ​ If a message is received with both a Transfer-Encoding and a Content-> Length header field, the Transfer-Encoding overrides the Content-Length.
> Such a message might indicate an attempt to perform request smuggling
> (Section 9.5) or response splitting (Section 9.4) and ought to be handled as
> an error. A sender MUST remove the received Content-Length field prior to
> forwarding such a message downstream.
虽然这里是指出了 TL 优先于 CL ，但是我们仍然可以通过一些方式绕过，又或者说，那个中间件的也没有依照这个 RFC
标准规范实现，这就导致了差异性的存在。
例如我们使用以下代码来发送 HTTP 请求：
    printf 'GET / HTTP/1.1\r\n'\
    'Host:localhost\r\n'\
    'Content-length:56\r\n'\
    'Transfer-Encoding: chunked\r\n'\
    'Dummy:Header\r\n\r\n'\
    '0\r\n'\
    '\r\n'\
    'GET /tmp HTTP/1.1\r\n'\
    'Host:localhost\r\n'\
    'Dummy:Header\r\n'\
    '\r\n'\