out, schedules  a recovery process  and returns.  Thus, 
the delay to ongoing computations is minimal. 
If the Voter-Driver  is a Slave and finds that  it agrees 
with  the Master  but another  Slave disagrees,  it takes 
an  identical  action  as  the  Master  above  - thus 
keeping in step with the Master. 
The  important  things  to  note  here,  is  that  the 
agreeing  Master  and  Slave  will  command 
the 
disagreeing  module  to  drop  out  immediately,  and 
0 
477 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:01 UTC from IEEE Xplore.  Restrictions apply. 
r 
aglee 
Slave 
Figure 3: A  “Nominal” 
C om pa ris on Operation 
The transaction  is over and the modules continue - being 
brought  back into tighter synchronization. Figure 3  shows 
a timeline of the process under error-free conditions. 
Input  Comparison 
-  All  Master  and  Slave  modules 
execute  the  same  inputs  independently.  But  inputs  are 
done at slightly different times, and modules may receive 
slightly different values  (e.g., on-chip A/D converters), so 
an  exchange  is needed  to obtain  interactive  consistency. 
The Master sends the value it received  as  via the Master 
Channel,  and  the  Slaves  compare.  The  Slaves  signal 
agree  via  the  stuatus  channel  if  the  Master’s  value  is 
acceptably close to the value  they obtained on input, and 
they  signal  disagree  otherwise.  If  at  least  one  Slave 
agrees with  the Master, all  Slaves use the Master’s input 
value. 
Recovery of Well Behaved Errors 
Single  Slave  Error  - If  a  Slave  disagrees  during  the 
comparison interval, the comparison result  completes and 
is unambiguous,  If  a Slave fails to respond, the  Master 
waits  until  the  end  of  its  time  out  interval  to  drop  its 
compare  request  which  cause the statuses  to be  sampled 
by the error-free Slave(s) -thus  forcing completion of  the 
comparison  process.  (For this reason, the Slave time-out 
counts are set longer than the time out of the Master). The 
agreeing  Master  and  Slave  command  the  non-agreeing 
module  to  drop  out  and  schedule  its  reinitialization  as 
described  above. 
Muster Error - In the case of  a Master error there will  be 
In  fact,  when  a  comparison  point  is 
no  agreement. 
reached by  the other modules, the Master may  not request 
a comparison at all, or it may request  a comparison  at an 
unexpected time.  Here,  we must  depend  upon  the Slaves 
to detect  the problem  and  quickly assign  a  new  Master. 
This 
the  Slaves 
recognizing that they have all timed out, resulting in rapid 
selection  of  a  new  Master  from  amongst  them  by 
changing their Assignment Channel Vote. 
is  done,  as  described  above,  by 
Note  that  there are also checks to see that  a  module 
has not  changed  its assignment channel setting before  an 
I/O  comparison  is  started,  and  provisions  are  made  to 
check  for  stuck-at-agree modules. Space does not  permit 
discussing these in detail. 
Recovery of  Ill-Behaved Errors 
The  type  of  comparison  approach  described  here  is 
subject to complex  error  detection  conditions. A  module 
may  signal  false  agreement  or  disagreement,  and 
Byzantine  errors  are  possible  [6].  Even  if  Byzantine 
errors occur only a tiny fraction of the time, the expected 
large  number  of  transient  faults  will  guarantee  their 
happening  occasionally.  A  noise  on  a  status  line  may 
cause  the  Master  and  Slaves  to  see  different  status 
symbols from the same module.  There are also a variety 
of  “falling-in-the cracks” errors  where  a  faulty module’s 
status  value  changes  between 
it  is 
sampled by the other units, causing them to get a different 
view of the error state. 
the  times  when 
Our  approach,  simply  stated,  is  that  if  any  module 
docs  not  see  that  it  is  making  progress  as  part  of  an 
agreeing set of  modules, it drops out and sets assignment 
chanriel  symbol  to  “unavailable”.  This  is  buttressed  by 
hardware  in  each module  that  expects periodic  heartbeat 
messages  from  an  agreeing  Master  and  Slave  and  will 
force the module to drop out. 
After  dropping  out  to  an  “unavailable  status,’’  each 
module runs a hardware  diagnostic program  and  checks 
the consistency of  the programs  in  its  memory.  If  this  is 
successful, the module sets its assignment channel symbol 
to  “off-line”  (to  signal  that  it  is  ready  for  use).  It  also 
checks the assignment channel at  the occurrence of  each 
RTI to see if there is still a Master with  a Slave voting for 
it.  If this is the case, the module assumes  that the system 
is working and waits to be configured and restarted  by the 
Master.  If  not,  this  off-line  module  can  signal  via  its 
assignment  channel 
lines  that  it  intends  to  become 
involved  in  a  system  restart.  When  two  modules  are 
478 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:01 UTC from IEEE Xplore.  Restrictions apply. 
A 
I” il Slave 
Timeout 
No 
Figure 4: The Distributed recovery Algorithm as seen by each Module 
Disable 
Node-Level Fault-Inserting Testing 
Initial testing has ,used a software filter as a real-time 
application program to provide a synthetic workload.  The 
approach  taken  is  to  first  run  the  programs  in  a  node 
without errors and record the inputs and outputs, using the 
Testbed  Control  Computer  and  it’s  digital  acquisition 
found, they vote for one of  them as a new Master and the 
other as a Slave, and the system is restarted. 
The recovery algorithm, as seen  by  a  single module, 
is  shown  in  Figure 4.  The top  half  of  the  figure  shows 
what  happens  in  straightforward  cases,  where  a  single 
error  occu~s in  a  different  module  and  the  module 
attempts 
to  continue  operation.  The  bottom  half 
represents conditions causing the module to go off-line. 
We  tabulated  and  studied many  cases  of  Byzantine 
errors, and often their specific effects depended upon  the 
timing  of  U 0  events  in  working  and  faulty  modules. 
Although there were too may possible cases to enumerate, 
the  effects  of  Byzantine  conditions  were  found  are  to 
move modules in  the system further from agreement and 
cause properly  functioning modules to  drop  out  - either 
the 
reducing 
Master/Slave(s) set or forcing a restart. 
the  number  of  agreeing  modules 
in 
The Testbed 
A  testbed  has  been  constructed,  consisting  of  eight 
modules  using  the  Intel  87C196CA microcontroller  [7]. 
They are currently configured as three nodes  of  4, 3, and 
1 modules respectively  (see  Figure  5). The modules  are 
interconnected  via  two  redundant  CAN  buses.  Each 
microcontroller  has  a  built-in  CAN  bus  controller.  An 
attached  PC,  designated  the  Testbed  Control  Computer 
contains data acquisition boards that enable it to generate 
inputs  and  sample  outputs  from  selected  nodes.  It  is 
capable  of  loading  and  interrogating  individual  Modules 
and it generates the Real Time Interrupt (RTI) signal that 
cause the foreground processes to advance. 
Figure 5: The Distributed Microcontroller Testbed 
boards.  Then  the  programs  are  re-run  while  faults  are 
inserted into the various microcontroller modules. 
The first fault-insertion tests were primarily done for 
debugging.  After  getting  multiple  modules  running 
redundantly within  a node, specitic error conditions were 
inserted  to  test  key  aspects  of  the  design.  As  examples, 
outputs were purposely  modified  in  a  Master  or  Slave to 
cause  a disagreement,  while the program  flow  (and thus 
I/O timing between modules) was not  disturbed. Modules 
were prevented from generating an output to test the time- 
479 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:01 UTC from IEEE Xplore.  Restrictions apply. 
out mechanism. etc.  These faults identified some design, 
software,  and  wiring  errors  that  were  corrected  over  a 
period of months. 
The second phase, consisted of  inserting single faults 
by:  ( I )   halting  the  node  by  failing  to  issue  an  RTI,  (2) 
modifying  random  data  memory 
locations  and  (3) 
restarting  the P.TI  and observing  the effects  on  program 
execution. This was  undertaken  for  continued debugging 
and  to  get  experience  needed  to  develop  a  strategy  for 
extensive testing. An automated program was  written that 
randomly  inserts  errors  in  memory  Master  and  Slave 
modules  and observes the effects  on  program  execution 
by  sampling  the  output  results  and  the  status  and 
assignment  channels of  all  the modules.  After  inserting 
thousands  of  errors  of  this  type,  in  triplicated  and  quad 
module  nodes,  we  found  that  only  a  small  fraction  of 
these  insertions  (-3%)  affected  the  output  results  -- 
probably  reflecting  the  simplicity  of  the  initial  test 
program and the fact that many variables are re-computed 
at the beginning of  each RTI. A set of  memory locations 
was found to be sensitive to errors, and we have analyzed 
128 error  conditions  by  hand  - examining  the  outputs, 
status  channel  settings,  and  assignment  channel  settings 
after the error occurred.  Of these,  126 caused one module 
to  go off-line,  allowing  the  computation  to  continue  by 
the  remaining  Master  and  spare(s).  The  remaining  two 
resulted in a system restart for error recovery. 
be 
expanded 
The  results  so  far  are  encouraging,  but  extensive 
testing  will  be  necessary to obtain  conclusive  results.  A 
more  elaborate  synthetic  applications  program  will  be 
implemented.  The  automatic  error  insertion  and  data 
collection  program  will  be  extended 
to  perform 
automated analysis of error recovery actions - tallying the 
types  we  expect  and  reporting  unusual  cases.  The  error 
a  more 
insertion  will 
comprehensive  set  of  errors.  Here  we  plan  to  take 
advantage of  the multiple interval timers that are available 
in the microcontroller chips. When the node is stopped by 
withholding’an RTI, an  interval timer  will  be  set on  one 
or  more  microprocessor  modules  for  a  random  time. 
When  it  overflows,  a  short Trojan horse routine  will  be 
executed within the module that can modify registers and 
memory.  We also plan  to insert  zeros and indeterminate 
logic values for brief intervals on the interconnection pins 
on the testbed. 
insert 
to 
Conclusion 
and 
recovery 
An architecture has been  developed  for fault-tolerant 
nodes.  Fault-detection 
largely 
implemented by  software, but  special hardware protection 
is added to protect hard core functions - specifically (1) 
to  limit  shared  bus  access  to a  Master,  (2)  to  prevent  a 
Master 
system  without 
concurrence by a Slave, and (3) to prevent a module from 
reconfiguring 
from 
are 
the 
corning back  on-line  if  it! cannot  pass  a  diagnostic  test.. 
The fault-tolerance approach depends upon  knowing that 
a Master and Slave are operating together and agreeing on 
their computations. Thus,:special timeout hardware is also 
added 
if  software  recovery 
techniques  fail  and  the Master  and  Slave  are  no  longer 
maintaining the computations. 
the  system 
to  restart 
This approach depends upon  the fact that availability 
is  the main  objective,  and  the  vast  majority  of  recovery 
events will  be cause by radiation-induced  transient errors 
thiit can be cleared by roll-forwards of single modules and 
occasional  system  restarts.  Thus,  the  strategy  is  to 
demonstrate stability of the recovery algorithms. 
time-triggered 
A set of eight microcontroller modules were built and 
integrated  into  a  testbed  of  the  proposed  architecture. 
System  executive  software  has  been  developed  that 
supports 
foreground  and  background 
application  processes  on  the  nodes.  It  also  schedules 
voting  and  recovery  procedures.  Voting  and  recovery 
algorithms  have  been  implemented  and have  undergone 
preliminary  testing  in  nodes  of  triplicated  and  quad 
microcontrollers.  The  results, 
far,  are  highly 
encouraging  and an extensive fault-insertion  campaign  is 
planned. 
so 
We expect  that  the results  will  enable  use  of  a  new 
class of ultra-low-cost  fault-tolerant embedded systems. It 
will  also  shed  new 
fault-tolerant  design 
techniques  where  the  individual components are highly- 
integrated  systems-on-a-chip,  and  on 
the  degree  of 
resilience that can be achieved. 
light  on 
References 
[I] G. C. Messenger, M. S. Ash.  “The Effects of  Radiation on 
Electronic  Systems.”  Second  Edition.  Van  Nostrand 
Reinhold, New York, 1992. 
[ 21  Project  Plan:  Remote  Exploration  and  Experimentation 
(REE)  Project,  July  6,  2000,  Jet  Propulsion  Laboratory, 
Pasadena, CA 
[3]  Douglas  Caldwell  and  D.  Rennels,  “Minimalist  Recovery 
techniques  for  Single  Event  Effects 
in  Spacecraft 
Microcontrollers,”  Dependable  Computing  foe  Critical 
Applications (DCCA99), San Jose, CA, Jan. 6-8, 1999. 
141  Avizienis, A., Gilley, G., Mathur, F., Rennels, D., Rohr, J., 
Rubin,  D.,-”The-STAR  (Self  Testing  and  Repairing) 
Computer: An  Investigation of  the  Theory and  Practice  of 
Fault-Tolerant  Computer  Design”, 
IEEE-Trans.  On 
Computers], Vol. C20, No.-11, November  1971, pp.  1312- 
1321. 
[SI David  Ju,  “Software for  a Microcontroller Network,”  MS 
Thesis,  Computer  Science  Department,  University  of 
California, Los Angeles, June 1999. 
[6] Richard  Harper, “Critical  Issues  in  Ultra Reliable Parallel 
Processing,” Ph.D. Dissertation, Massachussets  Institute of 
Technology, June 1987. 
[7] 8XC196Kx, 8XC196Jx, 8XC196CA Microcontroller Family 
User’s Manual by Intel June 1995. 
480 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:01 UTC from IEEE Xplore.  Restrictions apply.