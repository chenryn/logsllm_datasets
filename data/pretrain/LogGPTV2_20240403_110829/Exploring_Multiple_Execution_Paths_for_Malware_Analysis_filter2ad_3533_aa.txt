title:Exploring Multiple Execution Paths for Malware Analysis
author:Andreas Moser and
Christopher Kr&quot;ugel and
Engin Kirda
Exploring Multiple Execution Paths for Malware Analysis
Andreas Moser, Christopher Kruegel, and Engin Kirda
Secure Systems Lab
{andy,chris,ek}@seclab.tuwien.ac.at
Technical University Vienna
Abstract
Malicious code (or malware) is deﬁned as software that
fulﬁlls the deliberately harmful intent of an attacker. Mal-
ware analysis is the process of determining the behavior
and purpose of a given malware sample (such as a virus,
worm, or Trojan horse). This process is a necessary step
to be able to develop effective detection techniques and re-
moval tools. Currently, malware analysis is mostly a man-
ual process that is tedious and time-intensive. To miti-
gate this problem, a number of analysis tools have been
proposed that automatically extract the behavior of an un-
known program by executing it in a restricted environment
and recording the operating system calls that are invoked.
The problem of dynamic analysis tools is that only a sin-
gle program execution is observed. Unfortunately, how-
ever, it is possible that certain malicious actions are only
triggered under speciﬁc circumstances (e.g., on a particu-
lar day, when a certain ﬁle is present, or when a certain
command is received). In this paper, we propose a system
that allows us to explore multiple execution paths and iden-
tify malicious actions that are executed only when certain
conditions are met. This enables us to automatically ex-
tract a more complete view of the program under analysis
and identify under which circumstances suspicious actions
are carried out. Our experimental results demonstrate that
many malware samples show different behavior depending
on input read from the environment. Thus, by exploring
multiple execution paths, we can obtain a more complete
picture of their actions.
1 Introduction
Malware is a generic term used to describe all kinds of
malicious software (e.g., viruses, worms, or Trojan horses).
Malicious software not only poses a major threat to the se-
curity and privacy of computer users and their data, but is
also responsible for a signiﬁcant amount of ﬁnancial loss.
Unfortunately, the problem of malicious code is likely to
continue to grow in the future, as malware writing is quickly
turning into a proﬁtable business [26]. Malware authors of-
ten sell their creations to miscreants, who then use the ma-
licious code to compromise large numbers of machines that
are linked together in so-called botnets. These botnets are
then abused as platforms to launch denial-of-service attacks
or as spam relays. An important indication of the signiﬁ-
cance of the problem is that even people without any par-
ticular interest in computers are aware of worms such as
CodeRed or Sasser. This is because security incidents af-
fect millions of users and regularly make the headlines of
mainstream news sources.
The most important line of defense against malicious
code are virus scanners. These scanners typically rely on
a database of signatures that characterize known malware
instances. Whenever an unknown malware sample is found
in the wild, it is usually necessary to update the signature
database accordingly, so that this novel malware piece can
be detected by the scan engine. To this end, it is very im-
portant to be able to quickly analyze an unknown malware
sample and understand its behavior and effect on the sys-
tem. In addition, the knowledge about the functionality of
malware is important for its removal. That is, to be able to
effectively remove a piece of malware from an infected ma-
chine, it is usually not sufﬁcient to delete the binary itself.
Often, it is also necessary to remove the residues left behind
by the malicious code (such as undesirable registry entries,
services, or processes) and undo changes made to legitimate
ﬁles. All these actions require a detailed understanding of
the malicious code and its behavior.
The traditional approach to analyze the behavior of an
unknown program is to execute the binary in a restricted
environment and observe its actions. The restricted environ-
ment is often a debugger, used by a human analyst to man-
ually step through the code in order to understand its func-
tionality. Unfortunately, anti-virus companies receive up to
several hundred new malware samples each day. Clearly,
the analysis of these malware samples cannot be performed
completely manually.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007In a ﬁrst step towards an automated solution, a number
of dynamic malware testing systems were proposed. These
systems, such as CWSandbox [29],
the Norman Sand-
Box [25], TTAnalyze [2], or Cobra [28] automatically load
the sample to be analyzed into a virtual machine environ-
ment and execute it. While the program is running, its inter-
action with the operating system is recorded. Typically, this
involves recording which system calls are invoked, together
with their parameters. The result of an automated analysis
is a report that shows what operating system resources (e.g.,
ﬁles or Windows registry entries) a program has created or
accessed. Some tools also allow the system to connect to
a local network (or even the Internet) and monitor the net-
work trafﬁc. Usually, the generated reports provide human
analysts with an overview on the behavior of the sample and
allow them to quickly decide whether a closer, manual anal-
ysis is required. Hence, these automated systems free the
analysts of the need to waste time on already known mal-
ware. Also, some tools are already deployed on the Internet
and act as live analysis back-ends for honeypot installations
such as Nepenthes [1]. Unfortunately, current analysis sys-
tems also suffer from a signiﬁcant drawback: their analysis
is based on a single execution trace only. That is, their re-
ports only contain the interaction that was observed when
the sample was run in a particular test environment at a cer-
tain point in time. Unfortunately, this approach has the po-
tential to miss a signiﬁcant fraction of the behavior that a
program might exhibit under varying circumstances.
Malware programs frequently contain checks that deter-
mine whether certain ﬁles or directories exist on a machine
and only run parts of their code when they do. Others re-
quire that a connection to the Internet is established or that
a speciﬁc mutex object does not exist. In case these condi-
tions are not met, the malware may terminate immediately.
This is similar to malicious code that checks for indications
of a virtual machine environment, modifying its behavior
if such indications are present in order to make its analysis
in a virtual environment more difﬁcult. Other functionality
that is not invoked on every run are malware routines that
are only executed at or until a certain date or time of day.
For example, some variants of the Bagle worm included a
check that would deactivate the worm completely after a
certain date. Another example is the Michelangelo virus,
which remains dormant most of the time, delivering its pay-
load only on March 6 (which is Michelangelo’s birthday).
Of course, functionality can also be triggered by other con-
ditions, such as the name of the user or the IP address of the
local network interface. Finally, some malware listens for
certain commands that must be sent over a control channel
before an activity is started. For example, bots that automat-
ically log into IRC servers often monitor the channel for a
list of keywords that trigger certain payload routines.
When the behavior of a program is determined from a
single run, it is possible that many of the previously men-
tioned actions cannot be observed. This might lead a human
analyst to draw incorrect conclusions about the risk of a cer-
tain sample. Even worse, when the code fails at an early
check and immediately exits, the generated report might
not show any malicious activity at all. One possibility to
address this problem is to attempt to increase test coverage.
This could be done by running the executable in different
environments, maybe using a variety of operating system
versions, installed applications, and data/time settings. Un-
fortunately, even with the help of virtual machines, creating
and maintaining such a testing system can be costly. Also,
performing hundreds of tests with each sample is not very
efﬁcient, especially because many environmental changes
have no inﬂuence on the program execution. Moreover, in
cases where malicious code is expecting certain commands
as input or checking for the existence of non-standard ﬁles
(e.g., ﬁles that a previous exploit might have created), it is
virtually impossible to trigger certain actions.
In this paper, we propose a solution that addresses the
problem of test coverage and that allows automated mal-
ware analysis systems to generate more comprehensive re-
ports. The basic idea is that we explore multiple execution
paths of a program under test, but the exploration of differ-
ent paths is driven by monitoring how the code uses certain
inputs. More precisely, we dynamically track certain input
values that the program reads (such as the current time from
the operating system, the content of a ﬁle, or the result of
a check for Internet connectivity) and identify points in the
execution where this input is used to make control ﬂow de-
cisions. When such a decision point is identiﬁed, we ﬁrst
create a snapshot of the current state of the program execu-
tion. Then, the program is allowed to continue along one of
the execution branches, depending on the actual input value.
Later, we return to the snapshot and rewrite the input value
such that the other branch is taken. This allows us to explore
both program branches. In addition, we can determine un-
der which conditions certain code paths are executed.
For a simple example, consider a program that checks for
the presence of a ﬁle. During execution, we track the result
of the operating system call that checks for the existence
of that ﬁle. When this result is later used in a conditional
branch by the program, we store a snapshot of the current
execution state. Suppose, for example, that the ﬁle does
not exist, and the program quickly exits. At this point, we
rewind the process to the previously stored state and rewrite
the result such that it does reports the ﬁle’s existence. Then,
we can explore the actions that the program performs under
the condition that the ﬁle is there.
We have developed a system for Microsoft Windows that
allows us to dynamically execute programs and track the in-
put that they read. Also, we have implemented a mechanism
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007to take snapshots of executing processes and later revert to
previously stored states. This provides us with the means to
explore the execution space of malware programs and to ob-
serve behavior that is not seen by traditional malware anal-
ysis environments. To demonstrate the feasibility of our ap-
proach, we analyzed a large number of real-world malware
samples. In our experiments, we were able to identify time
checks that guarded damage routines and different behavior
depending on existence of certain ﬁles. Also, we were able
to automatically extract a number of command strings for a
bot with their corresponding actions.
To summarize, the contributions of this paper are as follows:
• We propose a dynamic analysis technique that allows
us to create comprehensive reports on the behavior of
malicious code. To this end, our system explores mul-
tiple program paths, driven by the input that the pro-
gram processes. Also, our system reports the set of
conditions on the input under which particular actions
are triggered.
• We developed a tool that analyzes Microsoft Windows
programs by executing them in a virtual-machine-
based environment. Our system keeps track of user
input and can create snapshots of the current process
at control ﬂow decision points. In addition, we can re-
set a running process to a previously stored state and
consistently modify its memory such that the alterna-
tive execution path is explored.
• We evaluated our system on a large number of real-
world malware samples and demonstrate that we were
able to identify behavior that cannot be observed in
single execution traces.
2 System Overview
The techniques described in this paper are an extension
to an existing system for automated malware analysis [2].
This tool is based on Qemu [3], a fast virtual machine em-
ulator. Using Qemu’s emulation of an Intel x86 host sys-
tem, a Windows 2000 guest operating system is installed.
The choice of Windows and the Intel x86 architecture was
motivated by the fact that the predominant fraction of mal-
ware is developed for this platform. The analysis works by
loading the (malware-)program into the emulated Windows
environment, starting its execution, and subsequently mon-
itoring its activity. To this end, the analysis tool analyzes all
operating system calls that are invoked by the binary. For
each system call, the analysis tool records the type of ser-
vice requested and the corresponding arguments. Based on
the system calls observed during execution, a report is gen-
erated that summarizes the security-relevant actions. These
actions currently include the creation and modiﬁcation of
ﬁles and Windows registry entries, interprocess communi-
cation, and basic network interaction.
The existing analysis tool implements some virtual ma-
chine introspection capabilities; in particular, it is able to
attribute each instruction that is executed by the emulated
processor to an operating system process (or the kernel) of
the guest system. This allows us to track only those sys-
tem calls that are invoked by the code under analysis. Also,
the system provides a mechanism to copy the content of
complex data structures, which can contain pointers to other
objects in the process’ virtual address space, from the Win-
dows guest system into the host system. This is convenient
in order to be able to copy the system call arguments from
the emulated system into the analysis environment. Unfor-
tunately, the existing system only collected a single execu-
tion trace.
Multiple execution paths. To address the problem that a
single execution trace typically produces only part of the
complete program behavior, we extended the analysis tool
with the capability to explore multiple execution paths. The
goal is to obtain a number of different execution paths, and
each path possibly reveals some speciﬁc behavior that can-
not be observed in the other traces. The selection of branch-
ing points – that is, points in the program execution where
both alternative continuations are of interest – is based on
the way the program processes input data. More precisely,
when a control ﬂow decision is based on some input value
that was previously read via a system call, the program takes
one branch (which depends on the outcome of the concrete
check). At this point, we ask ourselves the following ques-
tion: Which behavior could be observed if the input was
such that the other branch was taken?
To answer this question, we label certain inputs of inter-
est to the program and dynamically track their propagation
during execution. Similar to the propagation of taint infor-
mation used by other authors in previous work [12, 23], our
system monitors the way these input values are moved and
manipulated by the process. Whenever we detect a control
ﬂow decision based on a labeled value, the current content
of the process address space is stored. Then, execution con-
tinues normally. When the process later wishes to termi-
nate, it is automatically reset to the previously stored snap-
shot. This is done by replacing the current content of the
process address space with the previously stored values. In
addition, we rewrite the input value that was used in the
control ﬂow decision such that the outcome of this deci-
sion is reversed. Then, the process continues its execution
along the other branch. Of course, it is possible that mul-
tiple branching in a row are encountered. In this case, the
execution space is explored by selecting continuation points
in a depth-ﬁrst order.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:55:25 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007  0:   int x; 
  1:   x = read_input();
  2:   if (x > 0) 
  3:       if (x  0
x = 2
x < 2
x = 0
exit
x = 2
exit
x = 1
print
exit