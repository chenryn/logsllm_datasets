properly distinguishes information ﬂows into them because
each of them has its own heap location ((cid:104) E(cid:13) ← H(cid:13) ← N(cid:13)(cid:105)
and (cid:104) E(cid:13) ← H(cid:13) ← S(cid:13)(cid:105), respectively).
VIII. EVALUATION
This section presents experimental results that characterize
the effectiveness of DroidSafe’s information-ﬂow analysis. Our
results indicate:
1) DroidSafe achieves both higher precision and accuracy than
FlowDroid [8] + IccTA [14] a current state-of-the-art An-
droid information-ﬂow analysis. [8] and [14] demonstrate
that FlowDroid + IccTA achieve both higher precision and
accuracy than commercially available tools such as IBM’s
AppScan Source [33] (which was speciﬁcally designed to
analyze Android apps) and HP’s FortifySCA [34].
2) DroidSafe successfully reports all malicious leaks of sen-
sitive information in a suite of malicious Android applica-
tions developed by independent, motivated, and sophisti-
cated attackers from three hostile Red Team organizations.
3) DroidSafe successfully scales to analyze large Android
applications analyzed in the context of our ADI.
there
are
Across
the APAC applications,
131
ContentProvider operations. Of
the operations, 66.4%
use Uri objects that DroidSafe resolves. Of the resolved
operations, 35.6% target a components of the application, and
each resolved operation targets 1.0 components. Epicc does
not resolve Uri values, and consequently FlowDroid does not
link ﬂows through ContentProvider operations.
IX. RELATED WORK
Object-Sensitive Points-To Analysis: For robustness and ﬂex-
ibility, typical whole-program object-sensitive analysis imple-
mentations reduce program facts into representations appropri-
ate for general solvers; examples include logic relations [18],
constraints [31], and binary decision diagrams [29, 38]. Our
implementation differs from these systems in that it operates
directly on the pointer assignment graph (PAG) representation
of the program [30], an explicit representation of the program.
Previous work has demonstrated that direct implementations
of points-to analysis problems, when they ﬁt in memory, are
typically faster than general solvers [29, 31]. Today main
memory sizes are large enough to accommodate our direct im-
plementation of a context sensitive analysis of large programs.
Tuning context-sensitivity of an analysis for precision
and scalability has also received much work. Hybrid context
sensitivity treats virtual and static method calls differently, and
in addition to object sensitivity, attempts to emulate call-site
sensitivity for static calls [39]. Our analysis implements hybrid
context sensitivity by cloning static method calls for calls to
application methods, and certain API factory methods. Type
sensitivity is a form of object sensitivity that merges contexts
based on types [18]. We tried type sensitivity for our client, but
it did not provide adequate precision. An introspective analysis
drops context sensitivity from program elements that could
blow-up the analysis [19], without regard for precision of the
client. In client-driven approaches [40], a client analysis asks
for more precision from the points-to analysis when needed.
In contrast, our technique pre-calculates the set of classes
(and thus allocations and methods calls) for which precision
is historically not helpful for our problem.
Information-Flow Security Analysis: DroidSafe follows a
long history of information-ﬂow analysis (sometimes called
taint analysis) systems for security. Livshits and Lam [41]
present an approach for taint analysis of Java EE applications
that is demand-driven, uses call-site context sensitivity, and
shallow object sensitivity via inlining. TAJ [42] focuses on
Java web application and employs a program slicing technique
combined with a selective object-sensitive analysis. F4F [16] is
a taint analysis for Java applications built on web frameworks
that uses a speciﬁcation language to describe the semantics of
the underlying framework.
Focusing on information-ﬂow analysis for Android, Flow-
Droid [8] is a sophisticated, open-source static information
ﬂow analysis for Android applications. FlowDroid’s analysis
is ﬂow-sensitive, and thus, is more precise than DroidSafe,
however the FlowDroid model of Android is not nearly as
complete as DroidSafe’s. FlowDroid attempts to compensate
with inaccurate blanket ﬂow policies on unmodeled API
methods. From testing, we discovered that FlowDroid does
not accurately model all possible combinations of life-cycle
15
or callback events, demonstrating the difﬁculty of modeling
Android execution in a ﬂow-sensitive system. FlowDroid’s
analysis is on-demand and ﬂow-sensitive as opposed to Droid-
Safe. However, each instantiation of the analysis is expensive;
in preliminary experiments running FlowDroid with our ADI,
the analysis completed only 7 of 24 applications given a 2
hour timeout for each application.
Epicc [36] is a tool that resolves Intent destinations in
an application. Epicc developed a model of commonly-used
classes and methods involved in the Android Intent imple-
mentation. Their analysis is on-demand and ﬂow-sensitive. The
DroidSafe system includes a more comprehensive model of
classes and mechanisms used in inter-component and inter-
application communication (for example Uri and Service
messages). DroidSafe’s resolution can also reason about values
created in and passed through API methods.
IccTA [14] combines FlowDroid with Epicc and seeks to
identify sensitive inter-component and inter-application infor-
mation ﬂows. DidFail [43] also combines FlowDroid and Epicc
to discover sensitive ﬂows across applications. Though not
discussed here, DroidSafe includes an analysis to capture inter-
application ﬂows via a database of previously resolved Intent
values and reachable source ﬂows. This database is consulted
and appropriate ﬂows are injected before information analysis.
There are other many other examples of static information
ﬂow analyses for Android. CHEX [7] detects information
ﬂow vulnerabilities between components. ScanDal [9] is a
static analysis implemented as an abstract interpretation of
Dalvik bytecode. CHEX and ScanDal employ analysis with
k = 1 call-site context sensitivity. SCanDroid [11] resolves
data ﬂows between components using a limited model of
Android, and conservative ﬂow policies for API methods.
LeakMiner [12] tracks ﬂows with a context-insensitive anal-
ysis. AndroidLeaks [13] combines both context-sensitive and
context insensitive analyses, but models ﬂows through API
methods with a blanket policy that reduces precision. Droid-
Safe includes a more precise analysis and has a more accurate
and precise model of the Android API than these other tools.
Dynamic testing and monitoring approaches engender dif-
ferent tradeoffs compared to static analysis. Examples include
the sophisticated dynamic taint-tracking tool TaintDroid [5],
and Tripp and Rubin [44] who describe an approach for
classifying information leakages by considering values that
ﬂow through sources and sinks. They do not have issues with
reﬂection and dynamic class loading. But, if employed for
triage, they require adequate test coverage. If used for dynamic
monitoring they are susceptible to denial-of-service attacks if
malware is activated during execution and the application is
killed or functionality is disabled. This might be unacceptable
for mission-critical applications. Similar to static analysis, they
require user-mediated judgment for reported sensitive ﬂows.
DroidSafe’s list of sources and sinks was compiled man-
ually. SuSi [24] employs supervised machine learning to au-
tomatically designate source and sink methods in the Android
API. Merlin [45] is a probabilistic approach that employs a
potentially incomplete list of sources, sinks, and sanitizers
to calculate a more comprehensive list. Merlin automatically
infers an information ﬂow speciﬁcation for an application
from its propagation graph using probabilistic inference rules.
While SuSi’s list proved incomplete for the APAC applications,
Merlin’s technique is complementary to ours and a possible
next step for helping the results of DroidSafe.
X. CONCLUSION
Malicious leaks of sensitive information pose a signiﬁcant
threat to the security of Android applications. Static analysis
techniques offer one way to detect and eliminate such ﬂows.
The complexity of modern application frameworks, however,
can pose a major challenge to the ability of static analyses to
deliver acceptably accurate and precise analysis results.
Our experience developing DroidSafe shows that 1) there
is no substitute for an accurate and precise model of the
application environment, and 2) using the model to drive the
design decisions behind the analysis and supporting techniques
(such as accurate analysis stubs) is one effective but (in-
evitably) labor-intensive way to obtain an acceptably precise
and accurate analysis. As long as there are complex application
frameworks, we anticipate that making an appropriate set of
design decisions (such as the use of a scalable ﬂow insensitive
analysis) to successfully navigate the trade-off space that the
application framework implicitly presents will be a necessary
prerequisite for obtaining acceptable accuracy and precision.
Our results indicate that the ﬁnal DroidSafe system, with
its combination of a comprehensive model of the Android
runtime and an effective set of analyses and techniques tailored
for that model, takes a signiﬁcant step towards the ﬁnal goal
of an information ﬂow analysis that can eliminate malicious
information leaks in Android applications.
ACKNOWLEDGMENT
We would like to thank our shepherd, Ben Livshits, and
our anonymous reviewers for their insightful comments. This
material is based on research sponsored by DARPA under
agreement number FA8750-12-X-0110. The U.S. Government
is authorized to reproduce and distribute reprints for Gov-
ernmental purposes notwithstanding any copyright notation
thereon.
REFERENCES
[1] A. P. Felt et al., “A survey of mobile malware in the wild,” Security,
vol. 55, p. 3, 2011.
[2] M. C. Grace, W. Zhou, X. Jiang, and A.-R. Sadeghi, “Unsafe exposure
analysis of mobile in-app advertisements,” in WISEC, 2012.
[3] A. P. Felt et al., “Android Permissions Demystiﬁed,” CCS, 2011.
[4] N. J. Percoco and S. Schulte, “Adventures in Bouncerland,” 2012.
[5] W. Enck, P. Gilbert, B. Chun, and L. Cox, “TaintDroid: an information
ﬂow tracking system for real-time privacy monitoring on smartphones,”
in OSDI, 2010.
[6] A. Reina, A. Fattori, and L. Cavallaro, “A System Call-Centric Anal-
ysis and Stimulation Technique to Automatically Reconstruct Android
Malware Behaviors,” in EuroSec, 2013.
[7] L. Lu et al., “CHEX: Statically Vetting Android Apps for Component
Hijacking Vulnerabilities,” in CCS, 2012.
[8] S. Arzt et al., “FlowDroid: Precise Context, Flow, Field, Object-sensitive
and Lifecycle-aware Taint Analysis for Android Apps,” in PLDI, 2014.
[9] J. Kim, Y. Yoon, K. Yi, and J. Shin, “Scandal: Static Analyzer for
Detecting Privacy Leaks in Android Applications,” in MoST, 2012.
[10] E. Chin, A. Felt, K. Greenwood, and D. Wagner, “Analyzing inter-
application communication in Android,” in MobiSys, 2011.
[11] A. P. Fuchs, A. Chaudhuri, and J. S. Foster, “ScanDroid: Automated
Security Certiﬁcation of Android Applications,” Tech. Rep., 2010.
16
[12] Z. Yang and M. Yang, “Leakminer: Detect
information leakage on
android with static taint analysis,” in WCSE, 2012, p. 104.
[13] C. Gibler, J. Crussell, J. Erickson, and H. Chen, “AndroidLeaks: auto-
matically detecting potential privacy leaks in android applications on a
large scale,” Trust and Trustworthy Computing, 2012.
[14] L. Li et al., “I know what leaked in your pocket: uncovering privacy
leaks on Android Apps with Static Taint Analysis,” CoRR, 2014.
[15] Google, “Android Open Source Project.” [Online]. Available: https:
//source.android.com/
[16] M. Sridharan et al., “F4F:
taint analysis of framework-based web
applications,” in OOPSLA, 2011.
[17] K. Z. Chen et al., “Contextual Policy Enforcement in Android Applica-
tions with Permission Event Graphs,” in NDSS, 2013.
[18] Y. Smaragdakis, M. Bravenboer, and O. Lhoták, “Pick Your Contexts
Well: Understanding Object-Sensitivity,” in POPL, 2011.
[19] Y. Smaragdakis, G. Kastrinis, and G. Balatsouras, “Introspective analy-
sis: context-sensitivity, across the board,” in PLDI, 2014.
[20] Google, “Intent and Intent Filters.” [Online]. Available: http://developer.
android.com/guide/components/intents-ﬁlters.html
[21] D. King, B. Hicks, M. Hicks, and T. Jaeger, “Implicit ﬂows: Can’t live
with ’Em, can’t live without ’Em,” in ICISS, 2008.
[22] Y. Smaragdakis, G. Kastrinis, G. Balatsouras, and M. Bravenboer, “More
Sound Static Handling of Java Reﬂection,” Tech. Rep., 2014.
[23] B. Livshits, J. Whaley, and M. S. Lam, “Reﬂection Analysis for Java,”
in APLAS, 2005.
[24] S. Rasthofer, S. Arzt, and E. Bodden, “A machine-learning approach for
classifying and categorizing android sources and sinks,” NDSS, 2014.
[25] L. O. Andersen, “Program Analysis and Specialization for the C Pro-
gramming Language,” Ph.D. dissertation, U. of Copenhagen, 1994.
[26] M. Bravenboer and Y. Smaragdakis, “Strictly declarative speciﬁcation of
sophisticated points-to analyses,” in OOPSLA.
[27] O. Lhotak, “Program analysis using binary decision diagrams,” Ph.D.
dissertation, McGill University, Montreal, 2006.
[28] M. Sridharan et al., Aliasing in Object-Oriented Programming. Springer
Berlin Heidelberg, 2000.
[29] M. Berndl et al., “Points-to analysis using BDDs,” PLDI, 2003.
[30] O. Lhotak, “SPARK: A Flexible Points-To Analysis Framework for
Java,” Ph.D. dissertation, McGill University, Montreal, 2002.
[31] J. Kodumal and A. Aiken, “Banshee: A scalable constraint-based analysis
toolkit,” in SAS, 2005.
[32] A. S. Christensen, A. Mø ller, and M. I. Schwartzbach, “Precise Analysis
of String Expressions Static Analysis,” in SAS, 2003.
[33] IBM, “IBM Security AppScan.” [Online]. Available: http://www-03.
ibm.com/software/products/de/appscan
[34] HP, “Enterprise Security Intelligence.” [Online]. Available: http:
//www8.hp.com/us/en/software-solutions/enterprise-security.html
[35] R. Vallée-Rai, E. Gagnon, and L. Hendren, “Optimizing Java bytecode
using the Soot framework: Is it feasible?” CC, 2000.
[36] D. Octeau et al., “Effective inter-component communication mapping in
android with epicc: An essential step towards holistic security analysis,”
in Usenix Security, Washington D.C., USA, 2013.
[37] A. Jordan, A. Gladd, and A. Abramov, “Android Malware Survey,”
Raytheon BBN Technologies, Tech. Rep. April, 2012.
[38] P. Liang and M. Naik, “Scaling abstraction reﬁnement via pruning,” ACM
SIGPLAN Notices, vol. 47, no. 6, p. 590, 2012.
[39] G. Kastrinis and Y. Smaragdakis, “Hybrid Context-Sensitivity for Points-
To Analysis,” in PLDI, 2013.
[40] S. Guyer and C. Lin, “Client-driven pointer analysis,” SAS, 2003.
[41] V. B. Livshits and M. S. Lam, “Finding Security Vulnerabilities in Java
Applications with Static Analysis,” in USENIX Security, 2005.
[42] O. Tripp et al., “TAJ: Effective Taint Analysis of Web Applications,” in
PLDI, 2009.
[43] W. Klieber et al., “Android taint ﬂow analysis for app sets,” in SOAP,
2014.
[44] O. Tripp and J. Rubin, “A Bayesian Approach to Privacy Enforcement
in Smartphones,” in USENIX Security, 2013.
[45] B. Livshits, A. V. Nori, S. K. Rajamani, and A. Banerjee, “Merlin:
Speciﬁcation Inference for Explicit Information Flow Problems,” in
PLDI, 2009.