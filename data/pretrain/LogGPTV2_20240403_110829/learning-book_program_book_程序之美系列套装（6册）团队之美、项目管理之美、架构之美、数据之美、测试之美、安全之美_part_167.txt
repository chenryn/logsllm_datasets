照相馆中的设计来合成的。根据不同的合成方式，渲染的过程可能
包含6～10个步骤。简单的演染需要2～5分钟，但大照片的复杂渲
染需要超过10分钟的时间。
同时，打印机每分钟都会输出一些完成打印的照片。让打印机保持
工作是“生产控制系统”（PCS）的职责，这是一个复杂的系统，它
负责处理任务调度、协调渲染工厂、管理图像存储，并将图像提供
给打印队列。
当完成的订单送达照相馆时，经理会告知客户可以过来取照片了。
936
---
## Page 938
这个工作流部分来自于LPS的业务背景，部分来自于我们对于如何
划分系统的考虑。接下来让我们来看看图4-1中不同的关注点。
4.3架构关注点
将一个多维的、动态的系统简化为一种线性的描述形式总是一项挑
战，不论我们是在谈论对还不存在的系统的愿景，还是试图解释已
经构建好的系统中各个部分的交互。超链接让我们可以从多个角度
来处理这个复杂问题，也许会让事情变得容易一些，但是纸张对超
链接的支持还不是很好。
当我们研究每一个架构关注点时，要记住它们是研究整个系统的不
同方式。例如，我们使用模块化的架构来支持不同的部署场景。同
时，每个模块义是按分层架构来创建的。它们是正交的、相互穿插
的考虑。每个模块都按照相同的方式来分层，每个层都可以在所有
模块中找到。
实际上，我们感到非常满意，因为我们既能够保持这些关注点的分
离，同时义让它们互相支持。
4.3.1模块和加载程序
一直以来，我们都在考虑“产品家族”而不是单个“应用程序”，因为
我们必须支持儿种不同的部署场景，而这些场景使用同样的底层代
码。特别是，我们从一开始就知道会有以下儿种配置：
照相馆客户端
照相馆有2～4台这样的工作站。摄影师使用它们来参与整个工作
流，从加载图像到创建订单。
照相馆服务器
每个照相馆的中心服务器上运行着MySQL，保存客户和订单等结构
化数据。服务器的存储也比工作站更健壮，使用了RAID来实现可恢
复性。我们也利用照相馆服务器将每天的订单刻录到DVD中。
渲染引擎
937
---
## Page 939
在生产过程中，我们决定构建自己的渲染引擎。渲染照相馆屏幕和
准备打印的图像使用的是相同的代码，所以我们绝对可以肯定客户
会拿到他们期望的照片。
最初，我们认为这些不同的部署配置只是一些不同的.iar文件集。我
们创建了一些顶层目录来保存每种部署的代码，还有一个Common
目录。每个顶层目录都有自己的source、test和bin目录。
没过多久，这种结构就让我们遭遇了挫折。例如，我们有一个庞大
的/1ib目录，里面积累了许多构建时的库和运行时的库。我们也苦
于寻找地方存放那些非代码文件，如图像、颜色描述、Hibermate配
置文件、测试图像等。我们中的一些人也觉得必须通过手工的方式
来维护jar文件的依赖关系是不舒服的事情。在刚并始那些日子里，
我们常常发现很多包放在了错误的目录中。而在运行时，有些类文
会加载失败，因为它依赖于另一个jar文件中的类。
大约在项目的第3次迭代时我们引入了Spring!l，这时转折点出现
了。我们采用“敏捷架构"的方式：保持最小的架构，只有当避免新
架构特性的代价超过实现它的代价时，才采用新的架构。这在“精
益软件开发"中称为“最后负责时刻”。在此之前，我们对Spring只有
一些不全面的了解，所以我们决定不依赖它，但是我们都预计后来
会用到它。
当我们加入Spring时，jar文件的依赖问题被配置文件问题放大了。
每个部署配置都需要它自己的beans.xml，但大约超过一半的beans会
在这些文件中重复出现，这明显违反了“不要重复你自己”[2的原
则，而且是缺陷的必然来源。所有人都不应该手工同步几千行XMIL
文件中的bean定义。此外，几千行的XML文件本身难道不是一种坏
味道吗？我们需要一个解决方案，让我们能够模块化Spring的beans
文件、管理.jar文件的依赖关系、使库贴近使用它们的代码，并管理
构建时和运行时的classpath。
ApplicationContext
学习Spring就像探索一片广阔的、不熟悉的地域。它是框架中的
NetHack游戏，他们考虑了所有的事情。浏览javadoc文档常常有巨
大的收获，在这个项目中，当我无意中看到“应用上下文"类时，我
们发现了非常有价值的东西。
938
---
## Page 940
所有Spring应用程序的核心都是“bean工厂”（bean factory）。bean工
厂支持按名字查找对象，根据需要创建对象，并向其他bean注入配
置和引用。简而言之，它管理了一些Java对象和它们的配置。最常
用的bean工厂实现会读取XML文件。
应用上下文扩展了bean工厂，提供了一项关键的功能：创建嵌套的
上下文链，就像《DesignPatterns》（设计模式）（Gamma等1994）
一书中描述的“职责链"模式。
ApplicationContext对象正是我们所需要的：将我们的所有bean分
并，放到多个文件中，将每个文件装入各自的应用上下文。
然后我们需要利用一种方法来建立应用上下文链，最好是不用巨大
的shell脚本。
模块依赖关系
将每个顶层目录看成一个模块，我认为让每个模块包含它自己的元
数据是很自然的。通过这种方式，模块只需要声明它用到的
classpath和配置文件，并声明它需要哪些其他模块。
我为每个模块提供了自己的manifest文件。例如，下面是StudioClient
模块的manifest文件：
Required-Components: Common StudioCommon
Class-Path: bin/classes/lib/StudioClient.jar
Spring-Config: config/beans.xml config/screens.xm]
config/forms.xm1
config /navigation . xml
Purpose: Selling station.Workflow.User Interface.Load
images.Burn DVDs.
这个格式显然是源自于jar文件中的manifest文件。我发现，使用熟
悉格式来表示概念上的"manifest文件”是很有用的。
939
---
## Page 941
请注意，这个模块使用了4个独立的bean文件。按功能分离bean的定
义有额外的好处。它减少了对主配置文件的修改和冲突，而且提供
了很好的关注点分离。
我们的团队很喜欢自动生成文档，所以我们在构建过程中包含了一
些报告生成步骤。由于所有模块依赖关系明确写入了manifest文件，
所以在自动化构建中添加报告生成步骤是很容易的。只需要进行一
些文本解析，然后提供给Graphviz，生成图4-2中的依赖关系图。
将订单DVD加
载进PC
生产中需要
的工具
存储过程的
适配器
为打印渲染
领域层、UI框
轮询PC的
渲染任务，调用
架、渲染核心、
RenderInterface
持久、XML
框架
销售工作站、
工作流、用户
界面、加载图
共享的代码
像、刻录DVD
图像文件服务
器、提取高分
辨率的JPEG
图4-2：模块和依赖关系
有了这些manifest文件，我们只需要通过一种方法来解析它们，然后
做一些有用的事。
我写了一个加载程序，你可以猜到它就叫“加载程序”
（Launcher），来做这些事情。
加载程序
940
---
## Page 942
我看到过许多桌面Java应用，它们带有大量的shell脚本或批处理脚
本来定位JRE，设置环境变量，设置classpath等。天啊！
对于给定的模块名，加载程序将解析manifest文件，构建模块依赖关
系的传递闭包。加载程序很小心，不会将一个模块加载2次，同时
它也将一组偏序关系变成全序关系。图4-3展示了StudioClient的全部
依赖关系。StudioClient同时将StudioCommon和Common声明为依赖
包，但加载程序只会将每个包加载一次。
StudioClient
StudioCommon
Common
Classpath
Classpath
Classpath
bin/classes
Configpath
bin/classes
lib/StudioClient.jar
ib/Common.jar
Configpath
config/beans.xm
lib/cglib-full-2.0.jar
config/beans.xml
lib/commons-collections.jar
config/screens.xml
config/forms.xml
lib/hibemate2.jar
config/navigation.xml
lib/spring-1.1.5.jar
Configpath
config/beans.xml
config/studio.xml
图4-3：StudioClient的依赖关系
为了避免来自于主机环境的classpath"污染”（构建机器上的ANT，
或工作站上的JREclasspath），加载程序从组合的classpath中创建它
自己的类加载器。加载程序将配置路径传递给初始化程序，由初始
化程序来创建所有的应用上下文对象。当应用上下文创建好了之
后，我们就可以启动并运行应用了。
OSGi框架
当我们在2004年下半年开始这个项目时，OSGi框架刚开始得到较多
的关注，这要感谢Eclipse采用了它。我们简单地看了一下，但没有
采用它，因为缺少大量可以获得的知识、专家和指导。
但是OSGi的目标却很符合我们所面临的问题。相同的代码集支持多
种部署配置，管理模块间的依赖关系，以正确的顺序激活它们....
很明显解决的是相同的问题。
941