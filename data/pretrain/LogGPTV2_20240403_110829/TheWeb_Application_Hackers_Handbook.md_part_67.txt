sensitive functions, such as the ability to open all ports on the Internet-facing
fi rewall. Since these functions are often not protected against CSRF, and since
most users do not modify the device’s default internal IP address, they are
vulnerable to CSRF attacks delivered by malicious external sites. However, the
devices concerned often require authentication to make sensitive changes, and
most users generally are not logged in to their device.
If the device’s web interface uses forms-based authentication, it is often possible
to perform a two-stage attack by fi rst logging the user in to the device and then
performing the authenticated action. Since most users do not modify the default
credentials for devices of this kind (perhaps on the assumption that the web
interface can be accessed only from the internal home network), the attacker’s
web page can fi rst issue a login request containing default credentials. The device
then sets a session token in the user’s browser, which is sent automatically in
any subsequent requests, including those generated by the attacker.
In other situations, an attacker may require that the victim user be logged
in to the application under the attacker’s own user context to deliver a specifi c
attack. For example, consider an application that allows users to upload and store
fi les. These fi les can be downloaded later, but only by the user who uploaded
them. Suppose that the function can be used to perform stored XSS attacks,
because no fi ltering of fi le contents occurs (see Chapter 12). This vulnerability
might appear to be harmless, on the basis that an attacker could only use it to
attack himself. However, using CSRF techniques, an attacker can in fact exploit
the stored XSS vulnerability to compromise other users. As already described,
the attacker’s web page can make a CSRF request to force a victim user to log
in using the attacker’s credentials. The attacker’s page can then make a CSRF
request to download a malicious fi le. When the user’s browser processes this fi le,
the attacker’s XSS payload executes, and the user’s session with the vulnerable
application is compromised. Although the victim is currently logged in using
cc1133..iinndddd 550077 88//1199//22001111 1122::1133::5588 PPMM
Stuttard c13.indd V4 - 08/17/2011 Page 508
508 Chapter 13 n Attacking Users: Other Techniques
the attacker’s account, this need not be the end of the attack. As described in
Chapter 12, the XSS exploit can persist in the user’s browser and perform arbi-
trary actions, logging the user out of her current session with the vulnerable
application and inducing her to log back in using her own credentials.
Preventing CSRF Flaws
CSRF vulnerabilities arise because of how browsers automatically submit cookies
back to the issuing web server with each subsequent request. If a web applica-
tion relies solely on HTTP cookies as its mechanism for tracking sessions, it is
inherently at risk from this type of attack.
The standard defense against CSRF attacks is to supplement HTTP cookies
with additional methods of tracking sessions. This typically takes the form
of additional tokens that are transmitted via hidden fi elds in HTML forms.
When each request is submitted, in addition to validating session cookies, the
application verifi es that the correct token was received in the form submission.
Assuming that the attacker has no way to determine the value of this token,
he cannot construct a cross-domain request that succeeds in performing the
desired action.
NOTE Even functions that are robustly defended using CSRF tokens may
be vulnerable to user interface (UI) redress attacks, as described later in this
chapter.
When anti-CSRF tokens are used in this way, they must be subjected to the
same safeguards as normal session tokens. If an attacker can predict the values
of tokens that are issued to other users, he may be able to determine all the
parameters required for a CSRF request and therefore still deliver an attack.
Furthermore, if the anti-CSRF tokens are not tied to the session of the user to
whom they were issued, an attacker may be able to obtain a valid token within his
own session and use this in a CSRF attack that targets a different user’s session.
TRY IT!
http://mdsec.net/auth/395/
http://mdsec.net/auth/404/
WARNING Some applications use relatively short anti-CSRF tokens on the
assumption that they will not be subjected to brute-force attacks in the way
that short session tokens might be. Any attack that sent a range of possible
values to the application would need to send these via the victim’s browser,
involving a large number of requests that might easily be noticed. Furthermore,
cc1133..iinndddd 550088 88//1199//22001111 1122::1133::5588 PPMM
Stuttard c13.indd V4 - 08/17/2011 Page 509
Chapter 13 n Attacking Users: Other Techniques 509
the application may defensively terminate the user’s session if it receives too
many invalid anti-CSRF tokens, thereby stalling the attack.
However, this ignores the possibility of performing a brute-force attack purely on
the client side, without sending any requests to the server. In some situations,
this attack can be performed using a CSS-based technique to enumerate a user’s
browsing history. For such an attack to succeed, two conditions must hold:
n The application must sometimes transmit an anti-CSRF token within the
URL query string. This is often the case, because many protected func-
tions are accessed via simple hyperlinks containing a token within the
target URL.
n The application must either use the same anti-CSRF token throughout the
user’s session or tolerate the use of the same token more than once. This
is often the case to enhance the user’s experience and allow use of the
browser’s back and forward buttons.
If these conditions hold, and the target user has already visited a URL that
includes an anti-CSRF token, the attacker can perform a brute-force attack from
his own page. Here, a script on the attacker’s page dynamically creates hyper-
links to the relevant URL on the target application, including a different value
for the anti-CSRF token in each link. It then uses the JavaScript API getCom-
putedStyle to test whether the user has visited the link. When a visited link is
identifi ed, a valid anti-CSRF token has been found, and the attacker’s page can
then use it to perform sensitive actions on the user’s behalf.
Note that to defend against CSRF attacks, it is not suffi cient simply to perform
sensitive actions using a multistage process. For example, when an administra-
tor adds a new user account, he might enter the relevant details at the fi rst stage
and then review and confi rm the details at the second stage. If no additional
anti-CSRF tokens are being used, the function is still vulnerable to CSRF, and
an attacker can simply issue the two required requests in turn, or (very often)
proceed directly to the second request.
Occasionally, an application function employs an additional token that is
set in one response and submitted in the next request. However, the transition
between these two steps involves a redirection, so the defense achieves nothing.
Although CSRF is a one-way attack and cannot be used to read tokens from
application responses, if a CSRF response contains a redirection to a different
URL containing a token, the victim’s browser automatically follows the redirect
and automatically submits the token with this request.
TRY IT!
http://mdsec.net/auth/398/
cc1133..iinndddd 550099 88//1199//22001111 1122::1133::5588 PPMM
Stuttard c13.indd V4 - 08/17/2011 Page 510
510 Chapter 13 n Attacking Users: Other Techniques
Do not make the mistake of relying on the HTTP Referer header to indicate
whether a request originated on-site or off-site. The Referer header can be
spoofed using older versions of Flash or masked using a meta refresh tag. In
general, the Referer header is not a reliable foundation on which to build any
security defenses within web applications.
Defeating Anti-CSRF Defenses Via XSS
It is often claimed that anti-CSRF defenses can be defeated if the application
contains any XSS vulnerabilities. But this is only partly true. The thought behind
the claim is correct—that because XSS payloads execute on-site, they can perform
two-way interaction with the application and therefore can retrieve tokens from
the application’s responses and submit them in subsequent requests.
However, if a page that is itself protected by anti-CSRF defenses also contains
a refl ected XSS fl aw, this fl aw cannot easily be used to break the defenses. Don’t
forget that the initial request in a refl ected XSS attack is itself cross-site. The
attacker crafts a URL or POST request containing malicious input that gets copied
into the application’s response. But if the vulnerable page implements anti-CSRF
defenses, the attacker’s crafted request must already contain the required token
to succeed. If it does not, the request is rejected, and the code path containing
the refl ected XSS fl aw does not execute. The issue here is not whether injected
script can read any tokens contained in the application’s response (of course
it can). The issue is about getting the script into a response containing those
tokens in the fi rst place.
In fact, there are several situations in which XSS vulnerabilities can be exploited
to defeat anti-CSRF defenses:
n If there are any stored XSS fl aws within the defended functionality, these
can always be exploited to defeat the defenses. JavaScript injected via
the stored attack can directly read the tokens contained within the same
response that the script appears in.
n If the application employs anti-CSRF defenses for only part of its func-
tionality, and a refl ected XSS fl aw exists in a function that is not defended
against CSRF, that fl aw can be exploited to defeat the anti-CSRF defenses.
For example, if an application employs anti-CSRF tokens to protect only
the second step of a funds transfer function, an attacker can leverage a
refl ected XSS attack elsewhere to defeat the defense. A script injected via
this fl aw can make an on-site request for the fi rst step of the funds trans-
fer, retrieve the token, and use this to request the second step. The attack
is successful because the fi rst step of the transfer, which is not defended
against CSRF, returns the token needed to access the defended page. The
reliance on only HTTP cookies to reach the fi rst step means that it can be
leveraged to gain access to the token defending the second step.
cc1133..iinndddd 551100 88//1199//22001111 1122::1133::5588 PPMM
Stuttard c13.indd V4 - 08/17/2011 Page 511
Chapter 13 n Attacking Users: Other Techniques 511
n In some applications, anti-CSRF tokens are tied only to the current user,
and not to his session. In this situation, if the login form is not protected
against CSRF, a multistage exploit may still be possible. First, the attacker
logs in to his own account to obtain a valid anti-CSRF token that is tied
to his user identity. He then uses CSRF against the login form to force
the victim user to log in using the attacker’s credentials, as was already
described for the exploitation of same-user stored XSS vulnerabilities.
Once the user is logged in as the attacker, the attacker uses CSRF to cause
the user to issue a request exploiting the XSS bug, using the anti-CSRF
token previously acquired by the attacker. The attacker’s XSS payload
then executes in the user’s browser. Since the user is still logged in as the
attacker, the XSS payload may need to log the user out again and induce
the user to log back in, with the result that the user’s login credentials
and resulting application session are fully compromised.
n If anti-CSRF tokens are tied not to the user but to the current session,
a variation on the preceding attack may be possible if any methods are
available for the attacker to inject cookies into the user’s browser (as
described later in this chapter). Instead of using a CSRF attack against
the login form with the attacker’s own credentials, the attacker can
directly feed to the user both his current session token and the anti-
CSRF token that is tied to it. The remainder of the attack then proceeds
as previously described.
These scenarios aside, robust defenses against CSRF attacks do in many situa-
tions make it considerably harder, if not impossible, to exploit some refl ected XSS
vulnerabilities. However, it goes without saying that any XSS conditions in an
application should always be fi xed, regardless of any anti-CSRF protections in place
that may, in some situations, frustrate an attacker who is seeking to exploit them.
UI Redress
Fundamentally, anti-CSRF defenses involving tokens within the page aim to
ensure that requests made by a user originate from that user’s actions within the
application itself and are not induced by some third-party domain. UI redress
attacks are designed to allow a third-party site to induce user actions on another
domain even if anti-CSRF tokens are being used. These attacks work because,
in the relevant sense, the resulting requests actually do originate within the
application being targeted. UI redress techniques are also often referred to as
“clickjacking,” “strokejacking,” and other buzzwords.
In its basic form, a UI redress attack involves the attacker’s web page load-
ing the target application within an iframe on the attacker’s page. In effect,
the attacker overlays the target application’s interface with a different interface
cc1133..iinndddd 551111 88//1199//22001111 1122::1133::5588 PPMM
Stuttard c13.indd V4 - 08/17/2011 Page 512
512 Chapter 13 n Attacking Users: Other Techniques
provided by the attacker. The attacker’s interface contains content to entice the
user and induce him to perform actions such as clicking the mouse in a par-
ticular region of the page. When the user performs these actions, although it
appears that he is clicking the buttons and other UI elements that are visible in
the attacker’s interface, he is unwittingly interacting with the interface of the
application that is being targeted.
For example, suppose a banking function to make a payment transfer involves
two steps. In the fi rst step, the user submits the details of the transfer. The response
to this request displays these details, and also a button to confi rm the action
and make the payment. Furthermore, in an attempt to prevent CSRF attacks,
the form in the response includes a hidden fi eld containing an unpredictable
token. This token is submitted when the user clicks the confi rm button, and the
application verifi es its value before transferring the funds.
In the UI redress attack, the attacker’s page submits the fi rst request in this
process using conventional CSRF. This is done in an iframe within the attacker’s
page. As it does normally, the application responds with the details of the user
to be added and a button to confi rm the action. This response is “displayed”
within the attacker’s iframe, which is overlaid with the attacker’s interface
designed to induce the victim to click the region containing the confi rm but-
ton. When the user clicks in this region, he is unwittingly clicking the confi rm
button in the target application, so the new user gets created. This basic attack
is illustrated in Figure 13-1.
Figure 13-1: A basic UI redress attack
The reason this attack succeeds, where a pure CSRF attack would fail, is
that the anti-CSRF token used by the application is processed in the normal
way. Although the attacker’s page cannot read the value of this token due to
the same-origin policy, the form in the attacker’s iframe includes the token
cc1133..iinndddd 551122 88//1199//22001111 1122::1133::5588 PPMM
Stuttard c13.indd V4 - 08/17/2011 Page 513
Chapter 13 n Attacking Users: Other Techniques 513
generated by the application, and it submits this back to the application when
the victim unwittingly clicks the confi rm button. As far as the target application
is concerned, everything is normal.
To deliver the key trick of having the victim user see one interface but interact
with a different one, the attacker can employ various CSS techniques. The iframe
that loads the target interface can be made an arbitrary size, in an arbitrary loca-
tion within the attacker’s page, and showing an arbitrary location within the
target page. Using suitable style attributes, it can be made completely transpar-
ent so that the user cannot see it.
TRY IT!
http://mdsec.net/auth/405/
Developing the basic attack further, the attacker can use complex script code
within his interface to induce more elaborate actions than simply clicking a but-
ton. Suppose an attack requires the user to enter some text into an input fi eld
(for example, in the amount fi eld of a funds transfer page). The attacker’s user
interface can contain some content that induces the user to type (for example,
a form to enter a phone number to win a prize). A script on the attacker’s page
can selectively handle keystrokes so that when a desired character is typed,
the keystroke event is effectively passed to the target interface to populate the
required input fi eld. If the user types a character that the attacker does not want
to enter into the target interface, the keystroke is not passed to that interface,
and the attacker’s script waits for the next keystroke.
In a further variation, the attacker’s page can contain content that induces
the user to perform mouse-dragging actions, such as a simple game. Script
running on the attacker’s page can selectively handle the resulting events in
a way that causes the user to unwittingly select text within the target applica-
tion’s interface and drag it into an input fi eld in the attacker’s interface, or vice
versa. For example, when targeting a web mail application, the attacker could
induce the user to drag text from an e-mail message into an input fi eld that
the attacker can read. Alternatively, the user could be made to create a rule to
forward all e-mail to the attacker and drag the required e-mail address from
the attacker’s interface into the relevant input fi eld in the form that defi nes the
rule. Furthermore, since links and images are dragged as URLs, the attacker
may be able to induce dragging actions to capture sensitive URLs, including
anti-CSRF tokens, from the target application’s interface.
A useful explanation of these and other attack vectors, and the methods by
which they may be delivered, can be found here:
http://ui-redressing.mniemietz.de/uiRedressing.pdf
cc1133..iinndddd 551133 88//1199//22001111 1122::1133::5588 PPMM
Stuttard c13.indd V4 - 08/17/2011 Page 514
514 Chapter 13 n Attacking Users: Other Techniques
Framebusting Defenses
When UI redress attacks were fi rst widely discussed, many high-profi le web
applications sought to defend against them using a defensive technique known
as framebusting. In some cases this was already being used to defend against
other frame-based attacks.
Framebusting can take various forms, but it essentially involves each relevant
page of an application running a script to detect if it is being loaded within an
iframe. If so, an attempt is made to “bust” out of the iframe, or some other
defensive action is performed, such as redirecting to an error page or refusing
to display the application’s own interface.
A Stanford University study in 2010 examined the framebusting defenses used
by 500 top websites. It found that in every instance these could be circumvented in
one way or another. How this can be done depends on the specifi c details of each
defense, but can be illustrated using a common example of framebusting code:
This code checks whether the URL of the page itself matches the URL of the
top frame in the browser window. If it doesn’t, the page has been loaded within
a child frame. In that case the script tries to break out of the frame by reloading
itself into the top-level frame in the window.
An attacker performing a UI redress attack can circumvent this defense to
successfully frame the target page in several ways:
n Since the attacker’s page controls the top-level frame, it can redefi ne the
meaning of top.location so that an exception occurs when a child frame
tries to reference it. For example, in Internet Explorer, the attacker can
run the following code:
var location = ‘foo’;
This redefi nes location as a local variable in the top-level frame so that
code running in a child frame cannot access it.
n The top-level frame can hook the window.onbeforeunload event so that