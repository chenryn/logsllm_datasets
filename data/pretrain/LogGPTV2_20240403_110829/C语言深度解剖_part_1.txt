# C 语言深度解剖
## 揭开程序员面试与笔试的奥秘

本书以高质量的内容勇敢挑战国内外同类书籍。

**编著者：陈正冲**  
**审阅者：石虎**

---

### 版权声明
本书尚未正式出版，现免费提供电子版下载和阅览。在正式出版前，读者可以自由研读和传阅此书的电子版本，但禁止私自大量印刷和销售。出版社若有意出版，请通过电子邮件或博客留言联系作者商讨出版事宜。
对于任何非法盗印或盗版行为，作者将坚持不懈地采取法律行动，直至获得公正裁决。

---

### 序言
最近在面试过程中，无论是应届毕业生还是有多年工作经验的程序员，在面对C语言相关问题时，很少有人能够完全回答正确。甚至有些自称“精通C语言”的求职者也无法全面作答。这让我想起了去年闲暇之余所撰写的这本小册子。

该书稿已在我的电脑中沉睡了一年之久。尽管多家大型出版社认可其内容质量，但由于篇幅较短（利润较低），他们建议我扩充至300页以上。然而，我认为经典之作应当精炼且无冗余。鉴于近期的面试经历，我决定将其免费发布于网络，并为此专门开设了一个博客（<http://blog.csdn.net/dissection_c>）以便与读者交流互动。

#### 作者简介
- **陈正冲**：湖南沅江人，毕业于长春理工大学数学系。目前从事嵌入式软件开发及管理工作。
- **石虎**：湖南沅江人，吉林大学计算机系毕业。现任大连交通大学计算机系讲师。

---

### 目录
1. 前言
2. 关键字
   - 1.1 `auto`：最宽泛的关键字
   - 1.2 `register`：最快的关键字
     - 1.2.1 寄存器：皇帝身边的小太监
     - 1.2.2 使用`register`修饰符的注意事项
   - 1.3 `static`：最名不副实的关键字
     - 1.3.1 修饰变量
     - 1.3.2 修饰函数
   - 1.4 基本数据类型：`short`、`int`、`long`、`char`、`float`、`double`
     - 1.4.1 数据类型与“模子”
     - 1.4.2 变量命名规则
   - 1.5 `sizeof`：最冤枉的关键字
     - 1.5.1 常被误认为是函数
     - 1.5.2 `sizeof(int)*p`表示什么？
   - 1.6 `signed`、`unsigned`关键字
   - 1.7 `if`、`else`组合
     - 1.7.1 `bool`变量与零值比较
     - 1.7.2 `float`变量与零值比较
     - 1.7.3 指针变量与零值比较
     - 1.7.4 `else`到底与哪个`if`配对？
     - 1.7.5 `if`语句后的分号
     - 1.7.6 使用`if`语句的其他注意事项
   - 1.8 `switch`、`case`组合
     - 1.8.1 不要用青龙偃月刀削苹果
     - 1.8.2 `case`关键字后面的值有什么要求？
     - 1.8.3 `case`语句的排列顺序
     - 1.8.4 使用`case`语句的其他注意事项
   - 1.9 `do`、`while`、`for`关键字
     - 1.9.1 `break`与`continue`的区别
     - 1.9.2 循环语句的注意点
   - 1.10 `goto`、`return`关键字
     - 1.10.1 `goto`关键字
     - 1.10.2 `return`关键字
   - 1.11 `void`关键字
     - 1.11.1 `void a?`
     - 1.11.2 `void`修饰函数返回值和参数
     - 1.11.3 `void`指针
     - 1.11.4 `void`不能代表一个真实的变量
   - 1.12 `const`关键字
     - 1.12.1 `const`修饰的只读变量
     - 1.12.2 节省空间，避免不必要的内存分配，提高效率
     - 1.12.3 修饰一般变量
     - 1.12.4 修饰数组
     - 1.12.5 修饰指针
     - 1.12.6 修饰函数的参数
     - 1.12.7 修饰函数的返回值
   - 1.13 `volatile`：最易变的关键字
   - 1.14 `extern`：最会带帽子的关键字
   - 1.15 `struct`关键字
     - 1.15.1 空结构体多大？
     - 1.15.2 柔性数组
     - 1.15.3 `struct`与`class`的区别
   - 1.16 `union`关键字
     - 1.16.1 大小端模式对`union`类型数据的影响
     - 1.16.2 如何用程序确认当前系统的存储模式？
   - 1.17 `enum`关键字
     - 1.17.1 枚举类型的使用方法
     - 1.17.2 枚举与`#define`宏的区别
   - 1.18 `typedef`关键字：伟大的缝纫师
     - 1.18.1 关于马甲的笑话
     - 1.18.2 历史的误会—也许应该是`typerename`
     - 1.18.3 `typedef`与`#define`的区别
     - 1.18.4 `#define a int[10]`与`typedef int a[10]`

3. 符号
   - 2.1 注释符号
     - 2.1.1 几个似非而是的注释问题
     - 2.1.2 `y = x/*p`
     - 2.1.3 怎样才能写出出色的注释
   - 2.2 接续符和转义符
   - 2.3 单引号、双引号
   - 2.4 逻辑运算符
   - 2.5 位运算符
     - 2.5.1 左移和右移
     - 2.5.2 `0x01<<2+3`的值为多少？
   - 2.6 花括号
   - 2.7 `++`、`--`操作符
     - 2.7.1 `++i+++i+++i`
     - 2.7.2 贪心法
   - 2.8 `2/(-2)`的值是多少？
   - 2.9 运算符的优先级
     - 2.9.1 运算符的优先级表
     - 2.9.2 一些容易出错的优先级问题

4. 预处理
   - 3.1 宏定义
     - 3.1.1 数值宏常量
     - 3.1.2 字符串宏常量
     - 3.1.3 用`#define`宏定义注释符号？
     - 3.1.4 用`#define`宏定义表达式
     - 3.1.5 宏定义中的空格
   - 3.2 条件编译
   - 3.3 文件包含
   - 3.4 `#error`预处理
   - 3.5 `#line`预处理
   - 3.6 `#pragma`预处理
     - 3.6.1 `#pragma message`
     - 3.6.2 `#pragma code_seg`
     - 3.6.3 `#pragma once`
     - 3.6.4 `#pragma hdrstop`
     - 3.6.5 `#pragma resource`
     - 3.6.6 `#pragma warning`
     - 3.6.7 `#pragma comment`
     - 3.6.8 `#pragma pack`
   - 3.7 `#`运算符
   - 3.8 `##`运算符

5. 指针和数组
   - 4.1 指针
     - 4.1.1 指针的内存布局
     - 4.1.2 `*`与防盗门的钥匙
     - 4.1.3 `int *p = NULL`和`*p = NULL`有什么区别？
     - 4.1.4 如何将数值存储到指定的内存地址
     - 4.1.5 编译器的bug？
     - 4.1.6 如何达到手中无剑、胸中也无剑的地步
   - 4.2 数组
     - 4.2.1 数组的内存布局
     - 4.2.2 省政府和市政的区别：`&a[0]`和`&a`的区别
     - 4.2.3 数组名`a`作为左值和右值的区别
   - 4.3 指针与数组之间的恩恩怨怨
     - 4.3.1 以指针的形式访问和以下标的形式访问
     - 4.3.2 `a`和`&a`的区别
     - 4.3.3 指针和数组的定义与声明
     - 4.3.4 指针和数组的对比
   - 4.4 指针数组和数组指针
     - 4.4.1 指针数组和数组指针的内存布局
     - 4.4.2 `int (*)[10] p2`—也许应该这么定义数组指针
     - 4.4.3 再论`a`和`&a`之间的区别
     - 4.4.4 地址的强制转换
   - 4.5 多维数组与多级指针
     - 4.5.1 二维数组
     - 4.5.2 二级指针
   - 4.6 数组参数与指针参数
     - 4.6.1 一维数组参数
     - 4.6.2 一级指针参数
     - 4.6.3 二维数组参数与二维指针参数
   - 4.7 函数指针
     - 4.7.1 函数指针的定义
     - 4.7.2 函数指针的使用
     - 4.7.3 `(*(void(*) ())0)()`—这是什么？
     - 4.7.4 函数指针数组
     - 4.7.5 函数指针数组的指针

6. 内存管理
   - 5.1 什么是野指针
   - 5.2 栈、堆和静态区
   - 5.3 常见的内存错误及对策
     - 5.3.1 指针没有指向一块合法的内存
     - 5.3.2 为指针分配的内存太小
     - 5.3.3 内存分配成功，但并未初始化
     - 5.3.4 内存越界
     - 5.3.5 内存泄漏
     - 5.3.6 内存已经被释放了，但是继续通过指针来使用

7. 函数
   - 6.1 函数的由来与好处
   - 6.2 编码风格
   - 6.3 函数设计的一般原则和技巧
   - 6.4 函数递归
     - 6.4.1 一个简单但易出错的递归例子

---

希望这份优化后的文本能更好地传达您的意图，并提升整体的专业性和可读性。