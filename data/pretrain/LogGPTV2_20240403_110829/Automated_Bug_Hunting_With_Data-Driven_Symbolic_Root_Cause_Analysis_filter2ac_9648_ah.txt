(USENIX).
[90] Koushik Sen, Darko Marinov, and Gul Agha. 2005. CUTE: a concolic unit
testing engine for C. In ACM SIGSOFT Software Engineering Notes, Vol. 30. ACM,
263â€“272.
[91] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitriy
Vyukov. 2012. AddressSanitizer: A fast address sanity checker. In 2012 USENIX
Annual Technical Conference (USENIX ATC). 309â€“318.
[92] Hashim Sharif, Muhammad Abubakar, Ashish Gehani, and Fareed Zaffar. 2018.
TRIMMER: application specialization for code debloating. In Proceedings of the
33rd ACM/IEEE International Conference on Automated Software Engineering.
329â€“339.
[93] Yan Shoshitaishvili, Antonio Bianchi, Kevin Borgolte, Amat Cama, Jacopo Cor-
betta, Francesco Disperati, Audrey Dutcher, John Grosen, Paul Grosen, Aravind
Machiry, et al. 2018. Mechanical phish: Resilient autonomous hacking. IEEE
Security & Privacy 16, 2 (2018), 12â€“22.
[94] Yan Shoshitaishvili, Ruoyu Wang, Christophe Hauser, Christopher Kruegel, and
Giovanni Vigna. 2015. Firmalice-automatic detection of authentication bypass
vulnerabilities in binary firmware.. In NDSS.
[95] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario
Polino, Audrey Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher
Kruegel, and Giovanni Vigna. 2016. SoK: (State of) The Art of War: Offensive
Techniques in Binary Analysis. In Proceedings of the 37th Symposium on Security
and Privacy (Oakland). San Jose, CA.
[96] Xiaokui Shu, Danfeng (Daphne) Yao, Naren Ramakrishnan, and Trent Jaeger.
2017. Long-Span Program Behavior Modeling and Attack Detection. ACM
Transactions on Privacy and Security 20, Article Article 12 (2017).
[97] Asia Slowinska and Herbert Bos. 2007. The age of data: pinpointing guilty
bytes in polymorphic buffer overflows on heap or stack. In Twenty-Third Annual
Computer Security Applications Conference (ACSAC 2007). IEEE, 487â€“500.
[98] Dawn Song, David Brumley, Heng Yin, Juan Caballero, Ivan Jager, Min Gyung
Kang, Zhenkai Liang, James Newsome, Pongsin Poosankam, and Prateek Saxena.
Session 2A: Fuzzing and Bug Finding CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3342008. BitBlaze: A new approach to computer security via binary analysis. In
International Conference on Information Systems Security. Springer, 1â€“25.
[99] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution.. In
Proceedings of the 2016 Annual Network and Distributed System Security Sympo-
sium (NDSS). San Diego, CA.
[100] sudo. 2012. Format String Vulnerability. https://bugs.gentoo.org/401533. [On-
line; accessed 25-October-2019].
[101] Rijnard van Tonder, John Kotheimer, and Claire Le Goues. 2018. Semantic
Crash Bucketing. In 33rd IEEE International Conference on Automated Software
Engineering. IEEE, 612â€“622.
[102] Qi Wang, Wajih Ul Hassan, Ding Li, Kangkook Jee, Xiao Yu, Kexuan Zou, Jung-
whan Rhee, Zhengzhang Zhen, Wei Cheng, Carl A. Gunter, and Haifeng chen.
2020. You Are What You Do: Hunting Stealthy Malware via Data Provenance
Analysis. In 27th ISOC Network and Distributed System Security Symposium
(NDSSâ€™20).
[103] C. Warrender, S. Forrest, and B. Pearlmutter. 1999. Detecting intrusions using
system calls: alternative data models. In Proceedings of the 1999 IEEE Symposium
on Security and Privacy (Cat. No.99CB36344). 133â€“145.
[104] Andreas Wespi, Marc Dacier, and HervÃ© Debar. 2000. Intrusion Detection Using
Variable-Length Audit Trail Patterns. In Recent Advances in Intrusion Detection.
Springer, 110â€“129.
[105] K. Xu, K. Tian, D. Yao, and B. G. Ryder. 2016. A Sharper Sense of Self: Proba-
bilistic Reasoning of Program Behaviors for Anomaly Detection with Context
Sensitivity. In 2016 46th Annual IEEE/IFIP International Conference on Dependable
Systems and Networks (DSN). 467â€“478.
[106] Carter Yagemann, Matthew Pruett, Simon P. Chung, Kennon Bittick, Brendan
Saltaformaggio, and Wenke Lee. 2021. ARCUS: Symbolic Root Cause Analysis
of Exploits in Production Systems. In USENIX Security Symposium.
[107] Carter Yagemann, Salmin Sultana, Li Chen, and Wenke Lee. 2019. Barnum:
Detecting Document Malware via Control Flow Anomalies in Hardware Traces.
In Proceedings of the 25th Information Security Conference (ISC). New York, NY,
USA.
[108] Attila Altay Yavuz and Peng Ning. 2009. BAF: An efficient publicly verifiable
secure audit logging scheme for distributed systems. In Proceedings of the Annual
Computer Security Applications Conference (ACSAC).
[109] Attila A Yavuz, Peng Ning, and Michael K Reiter. 2012. Efficient, compromise
resilient and append-only cryptographic schemes for secure audit logging. In
Proceedings of the International Conference on Financial Cryptography and Data
Security (FC).
[110] Wei You, Peiyuan Zong, Kai Chen, XiaoFeng Wang, Xiaojing Liao, Pan Bian, and
Bin Liang. 2017. Semfuzz: Semantics-based automatic generation of proof-of-
concept exploits. In Proceedings of the 2017 ACM SIGSAC Conference on Computer
and Communications Security. ACM, 2139â€“2154.
[111] Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and Taesoo Kim. 2018. QSYM: A
practical concolic execution engine tailored for hybrid fuzzing. In 27th USENIX
Security Symposium (USENIX Security 18). 745â€“761.
[112] Michal Zalewski. 2017. American Fuzzy Lop. http://lcamtuf.coredump.cx/afl
(2017).
[113] Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and isolating failure-
inducing input. IEEE Transactions on Software Engineering 28, 2 (2002), 183â€“200.
Figure 10: Example root cause report for CVE-2018-12326.
Trace : openhost +0 x2a4 in ntpq ( 0 xbae4 )
Trace : openhost +0 x218 in ntpq ( 0 xba58 )
Trace : openhost +0 x3bc in ntpq ( 0 xbbfc )
Trace : _ _ s t a c k _ c h k _ f a i l +0 x0
We' ve t r i g g e r e d a bug
Analyzing e x i t
Blaming : openhost +0 x2dd in ntpq ( 0 xbb1d )
to
Recommendation : Add [ argv [ 2 3 2 ] == ' ] ' ]
a t openhost +0 x218
V u l n e r a b i l i t y Hooks D e t a i l s :
Hash : 1 c f a d
Addr : 0 x55857b000028 => _ _ s t a c k _ c h k _ f a i l +0 x0
0 x55857a27dc01 => openhost +0 x3c1
Table 5: Manually Verified APIs for Binary-Only Recovery
Library
libpng
libz
glib
libc
libbabl
libx11
libjpeg-turbo
libcyrus-sasl
libpoppler
libgegl
libghostpdl
libgimp
libgtk
libkeyutils
libidn2
libXpm
libopenjpeg
Total:
# Functions
71
11
125
22
70
5
25
1
3
33
29
36
21
4
1
5
22
484
# Variables
183
14
283
29
163
247
15
3
7
52
47
50
41
8
2
18
40
1,202
# Pointers Match?
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
117
2
202
19
104
137
12
1
4
44
40
48
26
6
1
5
24
792
Session 2A: Fuzzing and Bug Finding CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea335end
ğ‘… â† ğ‘… âˆª {ğ‘ .ğ‘Ÿğ‘’ğ‘”ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘Ÿ }
if ğ‘ .ğ‘‘ğ‘ğ‘¡ğ‘.ğ‘¡ğ‘šğ‘ âˆˆ ğ‘‡ then
if Type(s) = Put and Type(s.data) = RdTmp then
Result: Addresses ğ´ and registers ğ‘… used to calculate ğ‘›.
Algorithm 3: Tainting algorithm to obtain the registers
and addresses used to calculate a VEX IR temporary vari-
able.
1 Input: VEX IR statements ğ‘† starting from last executed.
2 Tmp ğ‘› to taint initially.
3 ğ´, ğ‘… â† âˆ…
4 ğ‘‡ â† {ğ‘›}
5 foreach ğ‘  in ğ‘† do
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24 end
end
if Type(s) = WrTmp and ğ‘ .ğ‘¡ğ‘šğ‘ âˆˆ ğ‘‡ then
end
if Type(a) = RdTmp then
end
if Type(a) = Load then
ğ´ â† ğ´ âˆª EvalTmp(a.address)
foreach ğ‘ in ğ‘ .ğ‘‘ğ‘ğ‘¡ğ‘.ğ‘ğ‘Ÿğ‘”ğ‘  do
ğ‘… â† ğ‘… âˆª {ğ‘.ğ‘Ÿğ‘’ğ‘”ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘Ÿ }
ğ‘‡ â† ğ‘‡ âˆª {ğ‘.ğ‘¡ğ‘šğ‘}
if Type(a) = Get then
end
end
end
Algorithm 1: Retrieve all memory reads and writes for a
VEX IRSB ğ¼, using successor state ğ‘†, producing ğ´.
1 ğ´,ğ‘‡ â† âˆ…
2 foreach ğ‘– âˆˆ ğ¼ do
3
4
if Type(i.addr) = Const then
if Type(i) = Store then
// Write to constant address
ğ´ â† ğ´ âˆª ğ‘–.ğ‘ğ‘‘ğ‘‘ğ‘Ÿ
end
else
// Write to variable address
ğ‘‡ â† ğ‘‡ âˆª ğ‘–.ğ‘ğ‘‘ğ‘‘ğ‘Ÿ
end
end
if Type(i) = WrTmp âˆ§ Type(i.data) = Load then
if Type(i.data.addr) = Const then
// Read from constant address
ğ´ â† ğ´ âˆª ğ‘–.ğ‘‘ğ‘ğ‘¡ğ‘.ğ‘ğ‘‘ğ‘‘ğ‘Ÿ
end
else
5
6
7
8
9
10
11
12
13
14
15
// Read from variable address
ğ‘‡ â† ğ‘‡ âˆª ğ‘–.ğ‘‘ğ‘ğ‘¡ğ‘.ğ‘ğ‘‘ğ‘‘ğ‘Ÿ
end
end
16
17
18
19 end
20 foreach ğ‘¡ âˆˆ ğ‘‡ do
21
22 end
ğ´ â† ğ´âˆª EvalTmp(S,t)
// Use S to avoid recomputing ASTs
end
end
if IsTmpStore(i) then
foreach ğ‘– âˆˆ ğ‘ .ğ‘–ğ‘Ÿğ‘ ğ‘.ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘  do
ğ¼ [ğ‘–.ğ‘ğ‘‘ğ‘‘ğ‘Ÿ] â† ğ¼ [ğ‘–.ğ‘ğ‘‘ğ‘‘ğ‘Ÿ] âˆª ğ‘–.ğ‘ğ‘‘ğ‘‘ğ‘Ÿ .ğ‘¡ğ‘šğ‘
Algorithm 2: Detect stepping behavior in a sequence of
states ğ‘†, iterating a loop. IsTmpStore is true when the VEX
IRSB instruction is a WrTmp and its expression is Store.
1 ğ‘… â† ğ¹ğ‘ğ‘™ğ‘ ğ‘’
2 ğ¼ â† âˆ…
3 foreach ğ‘  âˆˆ ğ‘† do
4
5
6
7
8
9 end
10 foreach ğ‘ âˆˆ ğ¼ do
ğ‘™ â† ğ¼ [ğ‘].ğ‘ ğ‘–ğ‘§ğ‘’
11
if ğ‘™ > 1 then
12
13
14
15
16
17
18
19
20 end
end
if ğ¼ [ğ‘][0] â‰¥ ğ¼ [ğ‘][1] â‰¥ ... â‰¥ ğ¼ [ğ‘][ğ‘™] then
if ğ¼ [ğ‘][0] â‰¤ ğ¼ [ğ‘][1] â‰¤ ... â‰¤ ğ¼ [ğ‘][ğ‘™] then
ğ‘… â† ğ‘‡ ğ‘Ÿğ‘¢ğ‘’
ğ‘… â† ğ‘‡ ğ‘Ÿğ‘¢ğ‘’
end
end
Session 2A: Fuzzing and Bug Finding CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea336