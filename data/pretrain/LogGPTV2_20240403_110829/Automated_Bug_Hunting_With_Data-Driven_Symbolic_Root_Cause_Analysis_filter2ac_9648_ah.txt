(USENIX).
[90] Koushik Sen, Darko Marinov, and Gul Agha. 2005. CUTE: a concolic unit
testing engine for C. In ACM SIGSOFT Software Engineering Notes, Vol. 30. ACM,
263–272.
[91] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitriy
Vyukov. 2012. AddressSanitizer: A fast address sanity checker. In 2012 USENIX
Annual Technical Conference (USENIX ATC). 309–318.
[92] Hashim Sharif, Muhammad Abubakar, Ashish Gehani, and Fareed Zaffar. 2018.
TRIMMER: application specialization for code debloating. In Proceedings of the
33rd ACM/IEEE International Conference on Automated Software Engineering.
329–339.
[93] Yan Shoshitaishvili, Antonio Bianchi, Kevin Borgolte, Amat Cama, Jacopo Cor-
betta, Francesco Disperati, Audrey Dutcher, John Grosen, Paul Grosen, Aravind
Machiry, et al. 2018. Mechanical phish: Resilient autonomous hacking. IEEE
Security & Privacy 16, 2 (2018), 12–22.
[94] Yan Shoshitaishvili, Ruoyu Wang, Christophe Hauser, Christopher Kruegel, and
Giovanni Vigna. 2015. Firmalice-automatic detection of authentication bypass
vulnerabilities in binary firmware.. In NDSS.
[95] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario
Polino, Audrey Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher
Kruegel, and Giovanni Vigna. 2016. SoK: (State of) The Art of War: Offensive
Techniques in Binary Analysis. In Proceedings of the 37th Symposium on Security
and Privacy (Oakland). San Jose, CA.
[96] Xiaokui Shu, Danfeng (Daphne) Yao, Naren Ramakrishnan, and Trent Jaeger.
2017. Long-Span Program Behavior Modeling and Attack Detection. ACM
Transactions on Privacy and Security 20, Article Article 12 (2017).
[97] Asia Slowinska and Herbert Bos. 2007. The age of data: pinpointing guilty
bytes in polymorphic buffer overflows on heap or stack. In Twenty-Third Annual
Computer Security Applications Conference (ACSAC 2007). IEEE, 487–500.
[98] Dawn Song, David Brumley, Heng Yin, Juan Caballero, Ivan Jager, Min Gyung
Kang, Zhenkai Liang, James Newsome, Pongsin Poosankam, and Prateek Saxena.
Session 2A: Fuzzing and Bug Finding CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea3342008. BitBlaze: A new approach to computer security via binary analysis. In
International Conference on Information Systems Security. Springer, 1–25.
[99] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution.. In
Proceedings of the 2016 Annual Network and Distributed System Security Sympo-
sium (NDSS). San Diego, CA.
[100] sudo. 2012. Format String Vulnerability. https://bugs.gentoo.org/401533. [On-
line; accessed 25-October-2019].
[101] Rijnard van Tonder, John Kotheimer, and Claire Le Goues. 2018. Semantic
Crash Bucketing. In 33rd IEEE International Conference on Automated Software
Engineering. IEEE, 612–622.
[102] Qi Wang, Wajih Ul Hassan, Ding Li, Kangkook Jee, Xiao Yu, Kexuan Zou, Jung-
whan Rhee, Zhengzhang Zhen, Wei Cheng, Carl A. Gunter, and Haifeng chen.
2020. You Are What You Do: Hunting Stealthy Malware via Data Provenance
Analysis. In 27th ISOC Network and Distributed System Security Symposium
(NDSS’20).
[103] C. Warrender, S. Forrest, and B. Pearlmutter. 1999. Detecting intrusions using
system calls: alternative data models. In Proceedings of the 1999 IEEE Symposium
on Security and Privacy (Cat. No.99CB36344). 133–145.
[104] Andreas Wespi, Marc Dacier, and Hervé Debar. 2000. Intrusion Detection Using
Variable-Length Audit Trail Patterns. In Recent Advances in Intrusion Detection.
Springer, 110–129.
[105] K. Xu, K. Tian, D. Yao, and B. G. Ryder. 2016. A Sharper Sense of Self: Proba-
bilistic Reasoning of Program Behaviors for Anomaly Detection with Context
Sensitivity. In 2016 46th Annual IEEE/IFIP International Conference on Dependable
Systems and Networks (DSN). 467–478.
[106] Carter Yagemann, Matthew Pruett, Simon P. Chung, Kennon Bittick, Brendan
Saltaformaggio, and Wenke Lee. 2021. ARCUS: Symbolic Root Cause Analysis
of Exploits in Production Systems. In USENIX Security Symposium.
[107] Carter Yagemann, Salmin Sultana, Li Chen, and Wenke Lee. 2019. Barnum:
Detecting Document Malware via Control Flow Anomalies in Hardware Traces.
In Proceedings of the 25th Information Security Conference (ISC). New York, NY,
USA.
[108] Attila Altay Yavuz and Peng Ning. 2009. BAF: An efficient publicly verifiable
secure audit logging scheme for distributed systems. In Proceedings of the Annual
Computer Security Applications Conference (ACSAC).
[109] Attila A Yavuz, Peng Ning, and Michael K Reiter. 2012. Efficient, compromise
resilient and append-only cryptographic schemes for secure audit logging. In
Proceedings of the International Conference on Financial Cryptography and Data
Security (FC).
[110] Wei You, Peiyuan Zong, Kai Chen, XiaoFeng Wang, Xiaojing Liao, Pan Bian, and
Bin Liang. 2017. Semfuzz: Semantics-based automatic generation of proof-of-
concept exploits. In Proceedings of the 2017 ACM SIGSAC Conference on Computer
and Communications Security. ACM, 2139–2154.
[111] Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and Taesoo Kim. 2018. QSYM: A
practical concolic execution engine tailored for hybrid fuzzing. In 27th USENIX
Security Symposium (USENIX Security 18). 745–761.
[112] Michal Zalewski. 2017. American Fuzzy Lop. http://lcamtuf.coredump.cx/afl
(2017).
[113] Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and isolating failure-
inducing input. IEEE Transactions on Software Engineering 28, 2 (2002), 183–200.
Figure 10: Example root cause report for CVE-2018-12326.
Trace : openhost +0 x2a4 in ntpq ( 0 xbae4 )
Trace : openhost +0 x218 in ntpq ( 0 xba58 )
Trace : openhost +0 x3bc in ntpq ( 0 xbbfc )
Trace : _ _ s t a c k _ c h k _ f a i l +0 x0
We' ve t r i g g e r e d a bug
Analyzing e x i t
Blaming : openhost +0 x2dd in ntpq ( 0 xbb1d )
to
Recommendation : Add [ argv [ 2 3 2 ] == ' ] ' ]
a t openhost +0 x218
V u l n e r a b i l i t y Hooks D e t a i l s :
Hash : 1 c f a d
Addr : 0 x55857b000028 => _ _ s t a c k _ c h k _ f a i l +0 x0
0 x55857a27dc01 => openhost +0 x3c1
Table 5: Manually Verified APIs for Binary-Only Recovery
Library
libpng
libz
glib
libc
libbabl
libx11
libjpeg-turbo
libcyrus-sasl
libpoppler
libgegl
libghostpdl
libgimp
libgtk
libkeyutils
libidn2
libXpm
libopenjpeg
Total:
# Functions
71
11
125
22
70
5
25
1
3
33
29
36
21
4
1
5
22
484
# Variables
183
14
283
29
163
247
15
3
7
52
47
50
41
8
2
18
40
1,202
# Pointers Match?
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
117
2
202
19
104
137
12
1
4
44
40
48
26
6
1
5
24
792
Session 2A: Fuzzing and Bug Finding CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea335end
𝑅 ← 𝑅 ∪ {𝑠.𝑟𝑒𝑔𝑖𝑠𝑡𝑒𝑟 }
if 𝑠.𝑑𝑎𝑡𝑎.𝑡𝑚𝑝 ∈ 𝑇 then
if Type(s) = Put and Type(s.data) = RdTmp then
Result: Addresses 𝐴 and registers 𝑅 used to calculate 𝑛.
Algorithm 3: Tainting algorithm to obtain the registers
and addresses used to calculate a VEX IR temporary vari-
able.
1 Input: VEX IR statements 𝑆 starting from last executed.
2 Tmp 𝑛 to taint initially.
3 𝐴, 𝑅 ← ∅
4 𝑇 ← {𝑛}
5 foreach 𝑠 in 𝑆 do
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24 end
end
if Type(s) = WrTmp and 𝑠.𝑡𝑚𝑝 ∈ 𝑇 then
end
if Type(a) = RdTmp then
end
if Type(a) = Load then
𝐴 ← 𝐴 ∪ EvalTmp(a.address)
foreach 𝑎 in 𝑠.𝑑𝑎𝑡𝑎.𝑎𝑟𝑔𝑠 do
𝑅 ← 𝑅 ∪ {𝑎.𝑟𝑒𝑔𝑖𝑠𝑡𝑒𝑟 }
𝑇 ← 𝑇 ∪ {𝑎.𝑡𝑚𝑝}
if Type(a) = Get then
end
end
end
Algorithm 1: Retrieve all memory reads and writes for a
VEX IRSB 𝐼, using successor state 𝑆, producing 𝐴.
1 𝐴,𝑇 ← ∅
2 foreach 𝑖 ∈ 𝐼 do
3
4
if Type(i.addr) = Const then
if Type(i) = Store then
// Write to constant address
𝐴 ← 𝐴 ∪ 𝑖.𝑎𝑑𝑑𝑟
end
else
// Write to variable address
𝑇 ← 𝑇 ∪ 𝑖.𝑎𝑑𝑑𝑟
end
end
if Type(i) = WrTmp ∧ Type(i.data) = Load then
if Type(i.data.addr) = Const then
// Read from constant address
𝐴 ← 𝐴 ∪ 𝑖.𝑑𝑎𝑡𝑎.𝑎𝑑𝑑𝑟
end
else
5
6
7
8
9
10
11
12
13
14
15
// Read from variable address
𝑇 ← 𝑇 ∪ 𝑖.𝑑𝑎𝑡𝑎.𝑎𝑑𝑑𝑟
end
end
16
17
18
19 end
20 foreach 𝑡 ∈ 𝑇 do
21
22 end
𝐴 ← 𝐴∪ EvalTmp(S,t)
// Use S to avoid recomputing ASTs
end
end
if IsTmpStore(i) then
foreach 𝑖 ∈ 𝑠.𝑖𝑟𝑠𝑏.𝑠𝑡𝑎𝑡𝑒𝑚𝑒𝑛𝑡𝑠 do
𝐼 [𝑖.𝑎𝑑𝑑𝑟] ← 𝐼 [𝑖.𝑎𝑑𝑑𝑟] ∪ 𝑖.𝑎𝑑𝑑𝑟 .𝑡𝑚𝑝
Algorithm 2: Detect stepping behavior in a sequence of
states 𝑆, iterating a loop. IsTmpStore is true when the VEX
IRSB instruction is a WrTmp and its expression is Store.
1 𝑅 ← 𝐹𝑎𝑙𝑠𝑒
2 𝐼 ← ∅
3 foreach 𝑠 ∈ 𝑆 do
4
5
6
7
8
9 end
10 foreach 𝑎 ∈ 𝐼 do
𝑙 ← 𝐼 [𝑎].𝑠𝑖𝑧𝑒
11
if 𝑙 > 1 then
12
13
14
15
16
17
18
19
20 end
end
if 𝐼 [𝑎][0] ≥ 𝐼 [𝑎][1] ≥ ... ≥ 𝐼 [𝑎][𝑙] then
if 𝐼 [𝑎][0] ≤ 𝐼 [𝑎][1] ≤ ... ≤ 𝐼 [𝑎][𝑙] then
𝑅 ← 𝑇 𝑟𝑢𝑒
𝑅 ← 𝑇 𝑟𝑢𝑒
end
end
Session 2A: Fuzzing and Bug Finding CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea336