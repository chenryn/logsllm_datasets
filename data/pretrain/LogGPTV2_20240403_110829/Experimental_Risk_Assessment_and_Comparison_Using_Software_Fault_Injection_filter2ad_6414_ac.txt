Progr. Length 
Vocab. Size 
Max. Nest. Depth 
39604 
10778 
13268 
1172521 
171408 
3963 
0.0072393 
-0.0051718 
0.0431363 
-0.0001692 
0.0011511 
0.3746203 
6.51 E-11 
0.185622 
1.75 E-52 
0.001896 
3.69 E-05 
1.0 E-140 
Table 2: Metrics and Logistic Regression Coefficients
RTLinux 
Global Values  Coefficients  p-value 
RTEMS 
Global Values 
28536 
8454 
10240 
787949 
108550 
2478 
Coefficients 
0.0063537 
0.0117627 
0.0161907 
-0.0005537 
0.0104020 
0.2354918 
p-value 
7.09 E-05 
0.012413 
0.000616 
7.9 E-20 
2.48 E-47 
3.88 E-27 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:32:36 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007 
Software fault 
Interface faults 
Injection 
at the API calls 
(G-SWFIT) 
( Xception ) 
PRPR
PRPR
PLPL…
PLPL…
x 
DHS 
DHS 
DHS 
DHS 
x 
RTEMS  or RTLinux
RTEMRTEM
RTEM
CDMS 
CDMS 
Commands
Commands
Telemetry
Ground 
Ground 
Ground 
Ground 
Control
Control
Control
Control
Linux
Linux
Linux
Linux
RS232
RS232
Figure 1: Satellite Data Handling System
Figure  1  shows  the  satellite  data  handling  system 
setup.  The  CDMS  system 
is  composed  by  six 
subsystems  (only  partially  shown):  Packet  Router 
(PR),  Power  Conditioning  System  (PCS),  On  Board 
Storage 
(DHS), 
Reconfiguration Manager (RM), and Payload (PL).  
(OBS),  Data  Handling  System 
starts  when 
The CDMS runs a mission scenario where a space 
telescope is being controlled and the data collected is 
sent  to  ground  system.  All  data  involved  in  this 
scenario  is  predetermined  which  allows  deterministic 
experiments.  The  workload 
an 
acknowledgement command is sent from the CDMS to 
the ground control. After that, the ground control sends 
a  series  of  commands  for  the  CDMS  requesting 
telemetry 
information.  The  CDMS  sends  back 
telemetry  information  for  each  command  sent.  The 
timing  of  the  commands  and  the  contents  of  the 
telemetry  information  are  used  to  detect  the  system 
correctness/failure during the experiments. The ground 
control  software  is  hosted  in  a  computer  running 
Linux.  
The  remainder  of  this  section  describes  the  static 
and  dynamic  aspects  of  the  risk  assessment  for  the 
case-study. 
3.1. Estimation of prob(f) 
RTLinux is composed by 2211 modules with a total 
of 85108 lines of code, and the interception coefficient 
(α) is equal to -7.8443977 (calculated by regression as 
explained  in  section  2.1).  RTEMS  is  composed  by 
1257 modules with a total of 63258 lines of code. The 
interception coefficient for RTEMS is -7.944308. 
Table  2  presents  a  summary  of  metrics  evaluation 
and  coefficients  for 
two  operating  systems, 
showing  the  global  values  for  each  metric  for  both 
components  and  the  coefficients  (βi)  obtained.  These 
coefficients were applied in the logistic equation (refer 
to equation (4)) to obtain the estimated prob(f) of each 
component. The global probg(f) estimated for RTLinux 
the 
is 6.50% and for  RTEMS is 7.49 %. These values are 
calculated  using  equation  (5)  as  explained  in  section 
2.1. 
A  close  observation  of  Table  2  shows  that  the 
complexity  metrics  of  RTLinux  are  higher  than  the 
RTEMS metrics. It is then surprising why the probg(f) 
estimated  for  RTEMS  is  higher  than  the  probg(f) 
estimated  for  RTLinux.  An  in  depth  analysis  shows 
that RTEMS has a higher percentage of modules with 
high  complexity  when  compared 
to  RTLinux. 
Although 
the  global  complexity 
(i.e.,  sum  of 
complexity  metrics  of  all  modules)  of  RTEMS  is 
smaller  than  the  global  complexity  for  RTLinux,  the 
large  number  of  modules  with  high  complexity  in 
RTEMS  is  responsible  for  the  higher  probg(f)  of 
RTEMS  when  compared to  RTLinux.  Table  3  shows 
the complexity distribution of modules for the LoC and 
Complexity metrics. 
3.2. Estimation of cost(f) 
The  cost  of  the  activation  of  residual  faults  is 
assessed through the injection of realistic faults in the 
components under observation (RTEMS or RTLinux) 
using the G-SWFIT technique as explained in section 
2.2. 
The identifications of the set of faults to inject in the 
components  under  evaluation  is  based  on  a  simple 
algorithm: taking into account the fault types presented 
in Table 1, the target code is analyzed in an automated 
manner  by  yielding  the  identification  of  all  locations 
were  a  given  fault  can  be  realistically  emulated  (by 
realistically emulated we mean that the intended fault 
could  indeed  be  present  at  the  original  source-code 
construct  relative 
target 
executable code). 
location 
We identified 231 faults for the RTEMS setup and 
341 faults for the RTLinux (the targets for the injection 
of  fault  in  the  code  are  the  components  used  by  the 
mission scenario, not all components in the system).  
that 
to 
in 
the 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:32:36 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007Table 3: Metrics Distribution and Global probg(f) 
C. Complexity 
LoC 
# Module 
Application  
RTEMS 
RTLinux 
 400 
 40 
1257 
2212 
87,0% 
11,0% 
90,0% 
9,0% 
2,0% 
1,0% 
80,0% 
84,0% 
6,0% 
6,0% 
14,0% 
10,0% 
Global  
 probg(f) 
7,5% 
6,5% 
Each  fault  is  injected  separately  from  the  others. 
Additionally, each fault is present from the beginning 
of the experiment to its end. This is in accordance to 
the  notion  that  a  software  fault  is  a  permanent  fault 
(i.e., it is not a transient fault). Thus, each fault implies 
a completely new experiment (involving the execution 
of the entire workload). 
RTEMS Results
12%
9%
5%
Correct
Wrong
Crash
Hang
74%
Figure 2: RTEMS Results 
RTLinux Results
24%
25%
1%
50%
Correct
Wrong
Crash
Hang
Figure 3: RTLinux Results 
Figure 2 and 3 present the failure modes obtained in 
the fault injection campaigns in both operating systems 
and  Table  4  shows  the  risk  evaluation.  The  risk  is 
evaluated considering each failure mode that represents 
erroneous  and  the  combination  of  all  the  erroneous 
failure modes (Incorrect Behavior column in Table 4). 
As  we  can  see,  RTLinux  represents  a  higher  risk 
than RTEMS for most of the failure modes considered, 
and  RTEMS  seems  to  be  a  better  choice  for  this 
application.  
One exception is related to the wrong results failure 
mode,  as  the  CDMS  version  running  on  RTLinux 
represents  a 
lower  risk  of  wrong  results  when 
compared  to  the  RTEMS  version  (i.e.,  the  RTLinux 
version shows fail silent behavior more frequently).  It 
is  worth  noting  that,  as  both  operating  systems  have 
Posix  compliant  API,  the  CDMS  is  practically  the 
same for both operating systems. Thus, the differences 
observed  in  the  measured  risk  do  account  for  the 
operating system. 
4. Related Work 
to 
[4,  34,  38]. 
Risk  assessment  approaches  typically  address  risk 
management in software development projects [27, 19] 
and  relate  the  risk  estimation  to  quality  models  of 
software  development,  heuristics,  and  developers’ 
experience 
In  highly  demanding 
application  areas,  such  as  avionics  or  nuclear  power 
plants, the risk estimation is tightly associated to safety 
and  reliability  assessment  and  is  regulated  by  strict 
industrial  standards  [15].  Modeling  approaches  based 
on  architectural-level  risk  analysis  are  also  quite 
popular,  especially  when  applied 
the  early 
development phases [37, 32, 45].  
Despite  the  extensive  research  in  risk  assessment, 
the  estimation  of  the  risk  associated  to  the  use  of  a 
given component remains a hard problem. One factor 
that  contributes  to  this  difficulty  is  the  fact  that  the 
dynamic  behaviour  of  the  component  is  difficult  to 
assess  without  experimentation  using 
the  actual 
component or a prototype.  
The method proposed in the work at hand is based on 
recent  software  fault  injection  techniques  [10,  11], 
combined  with  the  use  of  well  established  software 
complexity  metrics  [25,  40].  We  address  the  two 
classical terms of the risk equation (the probability of 
occurrence  of  an  undesired  event  and  the  cost  of 
resulting  consequences)  by  using  complexity  metrics 
of  the  component  under  analysis  to  estimate  the 
Table 4: The Risk Evaluation – Failure Mode 
Crash 
Wrong 
Hang 
Component  prob(f) 
0.0749 
RTEMS 
RTLinux 
0.0650 
cost(f) 
0.09 
0.25 
risk 
0.67% 
1.62% 
cost(f) 
0.05 
0.01 
risk 
0.37% 
0.06% 
cost(f) 
0.12 
0.24 
risk 
0.89% 
1.56% 
Incorrect Behavior 
cost(f) 
0.26 
0.50 
risk 
1.94% 
3.25% 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:32:36 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007to 
in 
faults 
residual  software 
that 
probability  of 
component,  and  by  using  software  fault  injection  to 
evaluate the cost of possible component failures in the 
whole  system  (we  use  the  term  cost  to  refer  to  the 
impact  of  a  component  failure,  as  the  term  cost  is 
generally used in risk works). 
The  approach  proposed  in  our  work  is  related  to 
three  main  research  lines:  risk  evaluation,  the  use  of 
software metrics to estimate component fault density, 
and  injection  of  software  faults  to  evaluate  cost  of 
component failures. In this section we summarize the 
most relevant works for our proposal. 
risk  analysis 
Software  risk  is  often  assessed  based  on  rigorous 
risk  analysis  methods  or  by  using  heuristics  [4]. 