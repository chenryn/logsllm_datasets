Well, really, just SRCDS, but who really cares? 
Bruce Potter, Logan Lodge 
PI:EMAIL, PI:EMAIL  
 Gaming is a USD47 billion global market.  
 Console gaming alone is estimated to be USD27 billion in size. 
 PC online games is a USD6.5 billion industry. Projected to be 
USD13 billion by 2012. 
 Online MMOGs is a USD3.5 billion industry. 
 Casual gaming is a USD1.5 billion industry. 
 Read more: 
http://www.techvibes.com/blog/gameon-finance-2.0-key-gaming-
industry-trends-and-market-overview#ixzz0Ch84uUJ0&B 
 At least not talking about them in a coherent 
fashion 
 There are a lot of reviews that focus on gameplay 
 There are industry analysis sites 
 There are many reviews of gaming hardware 
 Few public discussions of security 
 Few public discussions regarding the merits and impact 
of underlying technology 
 Beginning to see cultural/anthropological discussions 
 Publisher provided game servers 
 Pretty much all console gaming 
 Some PC games such as WoW 
 Community driven game servers 
 What drives people to run game servers? 
 It’s a lot like OSS 
 Convenience, fame, money, fun 
Call of Duty 
• CoD2 
• CoD4 
• CoD WW 
Half-Life 
• Half Life 
• TFC 
• Counter 
Strike 
Source 
Engine 
• HL2DM 
• TF2 
• Left4Dead 
• CS:Source 
Battlefield 
• BF 
• BF2 
There are 
others.. Quake, 
UT, etc.. 
 Why? 
 Valve has created a platform that not only supports 
their needs, but allows for massive amounts of 
customization 
 Huge number of servers deployed 
 Gametracker.com has CS:S as #2 (10700 Servers, 25000 
players), L4D as #6 (3000 Servers, 3000 Users), TF2 as #9 
(2300 Servers, 8500 Users) at 8pm on a Monday 
 Steam has ~1.5Million active users each day… many of them 
playing Source-based games 
 The real reason: I play a LOT of TF2 
 150 hours on demoman.. Yeah, it’s a problem 
 The big challenge: provide a good gaming 
experience for the person with a 1.6GHz PIV on a 
256k DSL line and a person with an i7 on the ass 
end of a 25Mbps FIOS connection 
256kbps 
768kbps 
 SRDS is a complex piece of software 
 Tries to provide Real Time service on OS’s that aren’t RTOS 
 Enforces complex mathematical models of where players are, 
where they are going, and what they’re doing 
 Distributes content to clients that need it 
 Attempts to control cheating 
 Allows spectating of the matches 
 Supports remote administration 
 Is highly extensible 
 Pretty impressive for free 
 But then again, the better it is, the more people will stand up 
servers, and the more people will buy the client and play 
 Simple premise 
 Simple premise is key 
 Pong had 8 words on front… “Avoid missing ball for high 
score” and “Insert coin” 
 Red team?  Kill Blue. 
 Blue team?  Kill Red. 
 Sometimes there’s a cart, or flag, or something.. But 
mostly it’s about destroying the other side 
 Attention to detail on art direction and 
supporting technology 
 Seriously, take a look at this 
 http://www.valvesoftware.com/publications/2007/
NPAR07_IllustrativeRenderingInTeamFortress2_Slides.pdf 
 You can’t always be sitting in front of your 
server to change the settings 
 RCON is the SRCDS mechanism for sending game 
commands to the server 
 Change number of rounds, rates, level, ban, kick, etc.. 
 Can be sent through the game via console 
 Also third party scripts like SRCDS.py 
 DANGER: RCON access is functionally equivalent 
to shell access 
 Can execute programs and save files with the 
privilege of the user running SRCDS 
 Don’t run as root! 
 SRCDS has a robust set of third party plug-ins 
 Custom sounds 
 Gameplay modifications 
 Protection mechanisms 
 Server administration 
 Kicks/bans 
 MetaMod, as an example, provides a clean 
interface for plugin writers to the SRCDS 
engine 
 SourceMod is a popular admin and gameplay mod 
engine that uses MetaMod 
 Rather than giving out RCON passwords, use 
something like SourceMod 
 Valve releases patches that can be applied 
automatically via their update tool 
 Valve releases patches… uh.. “whenever”  Can be 
disruptive to server admins 
 SRCDS is highly optimized for different 
platforms 
 Patches can cause issues on AMD but not Intel, for 
example 
 Different games can be broken by different 
patches 
 Over time, the games bloat.. Count on it 
 Cheating comes in many shapes and sizes 
 With SRCDS, there are many cheating mechanisms 
“built in” 
 Materials, sounds, etc can all be customized on both 
the server and the client side 
 Obviously, can be used to make the game more unique 
and fun 
 It can also be used to give yourself an advantage 
 It’s a movie… doesn’t work in a PDF.  Download 
this preso from www.nomoose.org to watch 
 It’s a movie… doesn’t work in a PDF.  Download 
this preso from www.nomoose.org to watch 
 It’s a movie… doesn’t work in a PDF.  Download 
this preso from www.nomoose.org to watch 
 It’s a movie… doesn’t work in a PDF.  Download 
this preso from www.nomoose.org to watch 
 It’s a movie… doesn’t work in a PDF.  Download 
this preso from www.nomoose.org to watch 
 Valve implemented a game variable, sv_pure, to 
try and control this 
 Sv_pure=0 is the default.  No enforcement 
 Sv_pure=1 causes the client to scan the materials, 
sounds, and models to verify they’re the same as the 
original Valve content 
 Some custom content is allowed (sprays and such) 
 Custom materials can be whitelisted server side 
 Sv_pure=2 results in no custom content 
 Sv_pure increases load time 
 Sv_pure uses CRC32 
 Finding a collision in CRC32 is a bit easier than MD5 ;) 
 Darkstorm is a publicly available cheat written by 
Kalvin (http://www.projectvdc.com/wordpress/) and 
other members from the Game-Deception web 
forum Credits to: (Patrick, wav, tabris, Lawgiver, 
aVitamin, gir489, CampStaff, and s0beit)  
 Open source code 
 Written in C++ 
 Lots of cheats available 
 Load our DLL 
 Standard DLL injection techniques apply 
 Get Process ID (via: name of Window or Process name)  
 Allocate space in process' virtual address space  
 Create a remote thread in the target's process space and 
have it kick off your DLL 
 Darkstorm injects into the hl2.exe process 
 Remove the PE header 
 Unlink our module from the PEB linked list 
 Detours to hook various API calls 
 PE Randomizer to make signature based 
detection more challenging (credit: cht1) 
 These methods sound familiar…where have we 
seen them before? Virus? Userland rootkit? 
 Darkstorm only uses one of these methods 
(contains code for PEB unlinking, but not in use) 
void  CMemoryTools::RemovePEHeader( DWORD dwModuleBase ) 
{ 
   PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwModuleBase; 
   PIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)( (DWORD)pDosHeader + (DWORD)pDosHeader->e_lfanew ); 
   if(pDosHeader->e_magic != IMAGE_DOS_SIGNATURE)
 //valid PE header? 
       return; 
   if(pNTHeader->Signature != IMAGE_NT_SIGNATURE)
 //valid PE header? 
       return; 
   if(pNTHeader->FileHeader.SizeOfOptionalHeader) 
   { 
       DWORD dwProtect; 
       WORD Size = pNTHeader->FileHeader.SizeOfOptionalHeader;
 //pointer  to the optional header portion of the PE 
       VirtualProtect( (PVOID)dwModuleBase, Size, PAGE_EXECUTE_READWRITE, &dwProtect );
 //allow us to write 
       RtlZeroMemory( (PVOID)dwModuleBase, Size );
 //zero it out 
       VirtualProtect( (PVOID)dwModuleBase, Size, dwProtect, &dwProtect );  
 //reset the permissions 
   } 
} 
void UnprotectCvars( void ) 
{ 
 ConCommand *pVar = (ConCommand*)g_pCvar->GetCommands( ); 
 //pointer to list of commands 
 ConVar *pConsistency = g_pCvar->FindVar( "sv_consistency" );
 //pointer to sv_consistency 
 ConVar *pCheats = g_pCvar->FindVar( "sv_cheats" );  
 //pointer to sv_cheats 
 while( pVar )
 //cycle through commands 
 { 
 if( pVar->IsFlagSet( FCVAR_CHEAT ) ) 
 pVar->m_nFlags &= ~FCVAR_CHEAT;
 /flip the bit for fcvar_cheat 
 if( pVar->IsFlagSet( FCVAR_REPLICATED ) ) 
 pVar->m_nFlags &= ~FCVAR_REPLICATED;
 //flip the bit for fcvar_replicated 
 if( pVar->IsFlagSet( FCVAR_PROTECTED ) ) 
 pVar->m_nFlags &= ~FCVAR_PROTECTED;
 //flip the bit for fcvar_protected 
 if( pVar->IsFlagSet( FCVAR_SPONLY ) ) 
 pVar->m_nFlags &= ~FCVAR_SPONLY;
 //flip the bit for fcvar_sponly 
 pVar = (ConCommand*)pVar->GetNext( ); 
 } 
 pConsistency->SetValue( 0 ); 
 pCheats->SetValue( 1 );
 //allow 'cheat' commands to be run server side 
} 
void __stdcall Hooked_CreateMove( int sequence_number, float input_sample_frametime, bool active ) 
 Called on every tick of the game 
 Essentially the entry point for our code to run  
 From here it cycles through the enabled cheats 
and executes the appropriate routines  
 This is the first stop for this cheat code  
 (Un)fortunately the most recent update to TF2 
broke this cheat  
 There was a class method (EyeAngles()) that was 
made private in the latest update  
 The AIMBOT relied on this method to 'Aim'  
 Source code for this is too long, so a quick 
overview: 
 Get list of entities (players & objects)  
 Found a player? not me? Solid? other team? 
 Get my loc and fov, get vector from me to target. Is target 
in my fov? 
 Change my Eyeposition to face target's hitbox  
 There are 5 to choose from. But really, who's going to 
choose one other than the head...  
 Fire!  
if( gCvars.misc_speed_on && g_pCvar )
 //is the speed hack enabled and do we have an interface to console commands 
{ 
   ConVar* pSpeed = g_pCvar->FindVar( "host_timescale" );
 //pointer to CVAR host_timescale 
   if( pSpeed ) 
   { 
       if( gCvars.misc_speed > 1 && bIsSpeedKey( gCvars.misc_speed_key ) )  //hack enabled? button pushed? 
       { 
           pSpeed->SetValue( gCvars.misc_speed );
 //set the CVAR to the specified value 
       } 
       else 
       { 
           pSpeed->SetValue( 1.0f );
 //set CVAR to 1 
       } 
   } 
} 
if( gCvars.misc_autopistol && pCommand->buttons & IN_ATTACK &&
 //cheat enabled, do we have access to the required interface 
  ( iGetWeaponID( pBaseWeapon ) == WEAPONLIST_SCOUTPISTOL ||
 //are we holding the right weapon? 
    iGetWeaponID( pBaseWeapon ) == WEAPONLIST_ENGINEERPISTOL || 
    iGetWeaponID( pBaseWeapon ) == WEAPONLIST_SPYPISTOL ) ) 
{ 
   static bool bInAttack = false;
 //stores whether we're attacking or not, set externally 
   if ( bInAttack )
 //if we're attacking (i.e. pushing the left mouse button) 
       pCommand->buttons |=  IN_ATTACK;
 //flip the bit that says you're firing (rapid fire) 
   else 
       pCommand->buttons &= ~IN_ATTACK;
 //else, flip it back 
   bInAttack = !bInAttack;
 //reset our state 
} 
 __asm 
 { 
 mov ecx, pBaseWeapon;
 //structure containing weapon info (crit chance, etc.) 
 mov eax, [ecx+0x16B4];
 //grab persistent seed 
 push eax;  
 //save it 
 mov eax, [ecx];         
 mov eax, [eax+0x528];
 //IsShotCritical 
 call eax; 
 mov iResult, eax;
  //Save value at AL - 1 for crit, 0 for sad panda 
 pop eax; 
 mov ecx, pBaseWeapon; 
 mov [ecx+0x16B4], eax;
 //restore persistent seed 
 } 
 if( pCommand->buttons & IN_ATTACK ) 
 { 
 pCommand->buttons &= ~IN_ATTACK;
 //not crit time, cry some twinkletoes 
 bWaitFire = true; 
 } 
 if( bWaitFire && (BYTE)iResult ) 
 { 
 pCommand->buttons |= IN_ATTACK;
 //crit time, attack! 
 bWaitFire = false;     
 } 
 Demo of Wireshark dissector for SRCDS traffic 
 http://www.shmoo.com/srcds/ 
 There’s a lot more here.. But it’s a start 
 Interested?  Capture what you learn and share 
it b/c there are others who re inventing the 
wheel every day 
 www.nomoose.org 
 PI:EMAIL, PI:EMAIL