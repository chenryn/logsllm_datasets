state (i, τ ), C locates the unique subtree that covers the
Pt
(i + 1)-th leaf x in the ordering of τ . In particular, it ﬁnds
ρ=1 2dρ ≤ i  1, a pair of non-negative
integral sequences D = ((k1, . . . , kc), (l1, . . . , ld)) is called a
decomposition of r, if the following hold:
(i) Pc
i=1 2ki +Pd
j=1 2lj = r, and
(ii) k1 > ··· > kc and l1 > ··· > ld.
A decomposition of r D = ((k1, . . . , kc), (l1, . . . , ld)) is a
worst-case decomposition (w.c.d.) of r if it is of maximum
size, i.e., for every decomposition of r D(cid:48) = ((k(cid:48)
1, . . . , k(cid:48)
c(cid:48) ),
d(cid:48) )), we have that c(cid:48) + d(cid:48) ≤ c + d. We deﬁne MD (cid:44)
(l(cid:48)
1, . . . , l(cid:48)
max{k1, l1} as the maximum integer that appears in D.
By the description of algorithm TBRC in BRC for ﬁxed
range size r, the depths in the trapdoor can be separated
into two sequences that form a decomposition of r, unless the
input range is exactly covered by a single subtree. Each se-
quence corresponds to a set of full binary subtrees of decreas-
ing size that cover leaves in the range predicate. The usage
of the worst case decomposition will become clear soon.
The next lemma shows that the maximum integer that
appears in any decomposition of r (hence, the maximum
depth of a subtree in a cover of a range of size r), can only
take on one of two consecutive values that depend only on r.
Lemma 1 Let D = ((k1, . . . , kc), (l1, . . . , ld)) be a decompo-
sition of r. Deﬁne B(r) (cid:44) (cid:100)log(r + 2)(cid:101) − 2. Then MD ∈
{B(r), B(r) + 1}. In addition, if MD = B(r) + 1 then the
second largest value is less than MD.
Proof. By the two properties of D, we have that
≤ 2MD +2 − 2 ⇔ 2MD +2 ≥ r + 2 ⇒ MD ≥ B(r) .
Since 2B(r)+2 ≥ 2log(r+2) > r ≥ 2k1 + 2l1 , we have that the
maximum value MD ∈ {k1, l1} is less than B(r) + 2 and
k1, l1 cannot be both equal to B(r) + 1.
By Lemma 1, the trapdoor that is generated by BRC for a
range P = [a, b] of size |AP| = r, even if this trapdoor corre-
sponds to a w.c.d. of r, consists of at most |{0, . . . , B(r)}| +
|{0, . . . , B(r) + 1}| = 2B(r) + 3 pairs. Hence, the trap-
door size is O(log(r)), which complies with the bound we
676
cX
i=1
dX
j=1
r =
2ki +
2lj ≤ 2k1+1 + 2l1+1 − 2 ≤
described in Section 4.1. Moreover, since |AP| ≤ λγ, every
trapdoor has no more than 2(cid:100)log(λγ + 2)(cid:101) − 1 pairs.
Observe that two trapdoors with depths that form the
same decomposition appear indistinguishable. Moreover, we
have proven that a trapdoor following a w.c.d. retains the
logarithmic size in r. Therefore, our goal for the trapdoor
algorithm T in URC, hereafter referred to as TURC, is to
construct a converter that takes as input a BRC trapdoor,
and produces an alternative trapdoor that complies with a
ﬁxed worst-case decomposition. Before proceeding to the
details of TURC, we must prove the following vital theorem.
Theorem 2 Let D = ((k1, . . . , kc), (l1, . . . , ld)) be a decom-
position of r. Then all the elements in {0, . . . , MD} appear
in D iﬀ D is a w.c.d. of r.
For the converse, let D(cid:48) = ((k(cid:48)
Proof. Assume that the implication does not hold and
let x be the maximum integer in {0, . . . , MD} that does not
appear in D. Since x  k1, then the decomposition of
r, ((x, k1, . . . , kc), (l1, . . . , lj−1, x, lj+1, . . . , ld)), is of greater
size than that of D. Similarly, if i = min{i | x  zρ. Then we have the contradiction
1, . . . , k(cid:48)
1, . . . , l(cid:48)
c(cid:48) ), (l(cid:48)
i=1 2yi =Pt
X
2yi + 2yρ >
integers such thatPs
2yi ≥X
≥X
sX
i 1, a w.c.d. of r is a proper re-arrangement
of the integers that appear in the w.c.d. of r where the
ﬁrst sequence is (B(r), . . . , 0) and the second sequence is the
remaining integers in the decomposition in decreasing order.
We term this unique w.c.d. as the uniform decomposition
of r. The main idea in URC is to always generate a trapdoor
that complies with the uniform decomposition of r.
We are ready to describe algorithm TURC in URC, whose
pseudocode is provided below. The process starts with in-
voking the TBRC algorithm of BRC to get an initial trap-
door τ (Line 1). If the input range is covered by a single
subtree, then τ is reformed into two pairs that correspond
to the child subtrees, so that the dephs in τ always form
a decomposition (Lines 2-3). Let D be the decomposition
implied by τ (Line 4). The loop in Lines 5-7 utilizes The-
orem 2 and works as follows. It ﬁnds the highest depth x
677
i , x), (y1
that does not exist in D, and “splits” the partial PRF value
yi in the rightmost pair in τ with depth x+1, producing two
new partial PRF values with depth x, i.e., y0
i = G0(yi) and
y1
i = G1(yi) (Line 6). Note that these values correspond to
the two children of the subtree of yi. Thus, if we substitute
element (yi, x + 1) by (y0
i , x) in τ , then the trapdoor
can still produce the same leaf PRF values as before. How-
ever, at all times we wish the sequence of depths in τ to form
a decomposition. Hence, after removing (yi, x + 1), we ap-
propriately insert (y0
i , x)
in the right pair sequence of τ (Line 7). Upon termination
of the loop, all the values in {0, . . . , MD} appear in D and,
thus, we have reached a w.c.d. according to Theorem 2. The
process terminates, after properly re-arranging the elements
of τ , such that they comply with the unique uniform decom-
position of r (Lines 8-9). This is done deterministically, by
simply ﬁlling the missing depths from {0, . . . , B(r)} in the
left sequence with the unique appropriate pair that exists
(by Theorem 2) in the right sequence.
i , x) in the left pair sequence and (y1
The Trapdoor Generation Algorithm TURC
Input: a, b : 0 ≤ a < b ≤ a + λγ ≤ 2n − 1 and k ∈ {0, 1}λ
Output: Trapdoor τ for computing {fk(x)|x ∈ [a, b]}
τ ← (cid:104)(G0(y), d − 1), (G1(y), d − 1)(cid:105)