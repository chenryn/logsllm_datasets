    // Init initializes chaincode
    // ===========================
    func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {
    return shim.Success(nil)
    }
    Invoke
    所有的调用都进入到这里，然后分发出去。
    // Invoke - Our entry point 
    // ========================================
    func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
    function, args := stub.GetFunctionAndParameters()
    fmt.Println("invoke is running " + function)
    // Handle different functions
    if function == "initProvider" { // create Provider
    return t.initProvider(stub, args)
    } else if function == "initBeneficiary" { // create beneficiary
    return t.initBeneficiary(stub, args)
    } 
    fmt.Println("invoke did not find func: " + function) //error
    return shim.Error("Received unknown function ")
    }
在链码中，我们首先需要`init`函数进行初始化，之后可以调用`invoke`函数进行数据的查询或者插入。
#### 3 Fabric权限系统
在Fabric系统中，我们要知道它是依照什么机制来保证安全性的。我们知道Fabric拥有多通道的机制，那其安全性应该如何保证呢？对此，我们这里讲述一下其权限系统。
Fabric与其他区块链最大的区别就是其网络是不公开的，如想进入网络中必须获得授权，因此Fabric是联盟链的唯一代表。而我们知道比特币、以太坊是没有身份验证系统的，任何人都可以在任何时间、任何地点连接入网络中。而连入后就可以遵循Pow机制同其他人一起竞争记账权。
而在Fabric中却没有类似Pow这样的机制存在，因此成员如果想加入网络必须获取到合法的授权，否则无论你有多大的算力都不可能进入网络。为了解决成员授权的问题，Fabric中存在会员服务系统MSP。MSP是基于PKI规范的一个用户证书与私钥体系。MSP是Fabric中非常重要的内容，其包括了Fabric账号体系，并依据此生成了相应的私钥签名来保证能够顺利获得联盟的认证，并顺利收到区块链中的相应交易信息。
### 四、Casper共识
Casper是以太坊提出的下一代的共识机制，从原理上说，Casper属于POS。Casper的共识是按块达成的，而不是像POS那样按照链来生产。  
Casper核心是基于保证金的经济激励共识协议。协议中的节点在参加系统的正常流程过程中，需要作为“锁定保证金的验证人”，必须先缴纳保证金(这一步叫做锁定保证金，"bonding")才可以参与出块和共识形成。
而保证金在这里的作用巨大。协议中的节点会通过对这些保证金的控制来直接约束参与验证人的行为举止。简单来说，如果一个验证人作出了任何Casper认为“无效”的事情，他的保证金将被罚没，出块和参与共识的权利也会被取消。这样对于节点来说代价是十分巨大的。在经典的Pos协议中做坏事的代价很低，然而保证金的引入很好的解决了"nothing
at stake"问题。如今有了代价，那些做坏事的节点将会为自己的行为付出相应的代价。
在Casper共识中，我们不得不提到： **下注共识 (Gambling on Consensus)的概念。**
Casper共识要求参与验证的验证人将交出的大部分保证金对共识结果进行下注。共识结果又通过验证人的下注情况进行形成。类似于博弈行为，验证人需要猜测其他人会赌哪个块胜出，同时也下注这个块。如果赌对了，他们就可以拿回保证金外加交易费用，也许还会有一些新发的货币作为收益。倘若下注的结果并没有迅速达成，他们也可以拿回部分保证金。
为了防止验证人在不同世界提供不同的投注，这里还有一个简单严格的条款：如果你有两次投注序号相同，或者说你提交了一个无法让Casper合约处理的投注，你将失去所有的保证金。这种惩罚机制时刻对节点带来警示。
在经过上述的过程后，整个合约来到了最后一步：交易最终确认。
当锁定保证金的验证人中的绝大多数（满足协议定义阈值的一群验证人：保证金比例达到67%到90%之间某个百分比）以非常高的概率（例如，>
99.9%）下注某个块时，此时其他的分叉块都不可能有胜出的可能，也就是说此块已经被最终确认。
此时，所有的客户端均会接受到高度为H的块被最终确认的消息。那么用户倘若接收到高度小于H的块和顺序执行这些完全块得到的状态不一样的分叉，此时节点可以对其不采取信任的态度。
### 五、时间戳依赖详解
简单来讲述一下时间戳的概念：
时间戳通常是一个字符序列，能够唯一地标识某一刻时间，并能表示一份数据在某个特定时间之前是否已经存在、 是否完整、 是否是可验证的。
项目数据时间戳通常被用来调用随机性函数、根据时间戳来锁定一段时间的资金以及根据时间的各种变化的条件语句。
而根据以太坊规定，矿工处理一个新的区块时，如果新的区块的时间戳大于上一个区块，并且时间戳之差小于900秒，那么这个新区块的时间戳就是合法的。时间戳依赖顾名思义就是指智能合约的执行依赖当前区块的时间戳，随着时间戳的不同，合约的执行结果也有差别。
而矿工可以对区块的时间进行篡改，并通过设置区块的时间戳来尽可能满足有利于他的条件，从中获利。例如：
    function play() public {
        require(now > 999999 && neverPlayed == true);
        //规定了时间要>999999，所以这里需要进行篡改处理。
        neverPlayed = false;
        msg.sender.transfer(999 ether);
        }
下面我们可以举相关例子进行论述：
假如有一个抽奖的合约，其规则规定要根据当前的时间戳和一些变量来计算出一个“幸运数字”。而奖励规则是此数字与官方提出的数字相同则可以获得奖品。那么矿工在挖矿过程中可以提前尝试不同的时间戳来计算好这个“幸运数”，从而将奖品送给自己想给的获奖者。
对于其检测方法：我们可以为时间戳变量设置特殊符号，检测是否有依赖于该符号的路径。而时间通常用于条件判断或随机数生成，编程时用不可更改的属性来替代时间戳
（如block index）。
### 六、贪婪合约漏洞
余额被锁死在合约中无法分发 ： Ether分发函数所依赖的库函数失效。
简单来说，这是指那些永远停留在以太坊的智能合约。例如 Parity
漏洞正是一种贪婪合约，它会把智能合约所涉及的商品以及加密货币锁定在以太坊中，交易双方均无法得到，也不能取消。
漏洞特征：合约余额大于0 时没有调用`CALL`函数（或调用CALL但没有发生Ether交换）,`DELEGATECALL`或`SUICIDE`。
### 七、遗嘱合约漏洞
在那些已完成或者被关闭的智能合约中，虽然他们的代码和全局变量被清楚了，但是其中一部分仍然在继续执行。遗嘱合约和贪婪合约一样，均是由以太坊的错误引起，目前并不能被黑客利用。
### 八、参考资料
  * 1 
  * 2 [https://blog.csdn.net/btqszl/article/details/78212504?locationNum=7&fps=1](https://blog.csdn.net/btqszl/article/details/78212504?locationNum=7&fps=1)
  * 3 
  * 4 
  * 5 