“in the past.” Therefore, execution of normal transactions
does not corrupt recovery transactions.
Please note that ﬂow dependencies cannot be broken,
which guarantees that the semantics of execution are cor-
rect. From the point of view of recovery transactions (or
normal transactions), there is only a single version for each
data object to ensure correct semantics.
By introducing multiple revision histories, the actual ex-
ecution will work on the working history and all backup
executions operate on caching histories. Once the actual
execution is determined to be discarded, a caching his-
tory corresponding to the selected backup execution will be
switched to the working history.
4 Branch cutting and garbage collection
Most IDSs have delays that are corresponding to their
detection windows. After the detection window, IDSs usu-
ally do not check back. Then it will be safe to remove all
results generated by backup executions to save computing
resources. However, the IDS delay could be a random vari-
able that subjects to a probability distribution. Furthermore,
an IDS may detect intrusions not in a temporal order, which
complicates the decision on the proper time to remove un-
necessary results. We will address this problem in this sec-
tion.
4.1 General cases
After a speciﬁc period, if the probability that a backup
path will be used is low enough, we can remove the backup
execution. We call such operation as branch cutting.
Proper branch cutting can beneﬁt consequent execution
greatly. For example, after a IDS detection window, if no
intrusion has been detected in the path t1t2t5 of the process
in Figure 1, we can remove the backup execution t2t3. The
branch cutting is marked as phase 1 in the ﬁgure. In the
consequent execution, it is not necessary to run t3t4 as a
back up execution again, which reduce the cost of defensive
execution.
Similarly, after t7 is done, the IDS may ﬁnd no intrusions
in the execution path t1t2t5t7. We can safely cut the backup
executing branch t5t6t7. Therefore, the backup execution
t6t8t12 will be not necessary in the following steps.
In the above example, the total extra cost of defensive ex-
ecution were t3 and t6, which has been signiﬁcantly reduced
by branch cutting operations.
Garbage collection will be done whenever branch cutting
happens. The garbage collection operation simply removes
all revision histories generated by cut branches to save the
storage.
Let us assume that the IDS delay is normally distributed
with parameter T and σ (If the IDS delay has a different
probability distribution, our following equations can be re-
vised accordingly). The probability density function is as
follows.
−(x−T )2/2σ2
The expected value of IDS delay is
E(X) = 1√
−(x−T )2/2σ2dx = T
e
f (x) = 1√
2πσe
(cid:11) ∞
2πσ
−∞
(4)
(5)
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:05:44 UTC from IEEE Xplore.  Restrictions apply. 
5
0.5
0.45
0.4
0.35
0.3
0.25
0.2
0.15
0.1
0.05
y
t
i
l
i
b
a
b
o
r
P
Missing probability (T=3, σ=3)
S1
t1
t2
t3
t4
t5
t6
t7
t8
S2
Figure 3. Overlap of Two Segments
We can take a smaller k for a risky branch cutting, which
greatly reduces the cost of defensive execution but has the
risk of cutting useful backup execution. We can also take a
larger k for a conservative branch cutting with more cost and
less risks. Our equations provide the missing probability
guideline for selections with different strategies.
0
3
4
5
6
7
8
Time (in seconds)
9
10
11
12
Figure 2. An example of the relationship be-
tween the waiting and the missing probability
4.2 Time wrapping reports of the IDS
and the variation of IDS delay is
Var(X) = E[(X − T )2] = σ2
The cumulative distribution function will be
(cid:13)
(cid:12)
a− T
σ
where
F(a) = Φ
Φ(x) = 1√
2π
(cid:11)
x
−∞
−y2/2dy
e
(6)
(7)
(8)
is the cumulative distribution of a standard normal distribu-
tion (a normal distribution with parameter 1 and 0).
If we wait for time a and no intrusion is reported by
the IDS, the probability that we mistakenly cut a branch in
which the IDS may report an intrusion later is 1− F(a). We
deﬁne 1− F(a) as the missing probability.
The missing probability is the probability that users will
not be beneﬁted from defensive execution since the useful
backup execution has been mistakenly discarded. A branch
cut by mistake will not affect the correctness of recovery
in a self-healing system. The user has to suffer a recovery
delay, which is normal in current self-healing systems.
Given the IDS delay is normally distributed with param-
eter T = 3 seconds and σ2 = 9. Figure 2 shows the relation-
ship between the waiting time and the missing probability.
If we wait for 4T = 12 seconds and no intrusion has been
reported, then the missing probability will be 0.0013 ac-
cording to the above discussion.
We can select a proper k and wait kT for the IDS reports.
The missing probability will be
1− F(a) = 1− Φ
(cid:13)
(cid:12)
k− 1
σ T
(9)
6
In a distributed system, message may arrive the desti-
nation not in the same order as they were sent. An IDS
may identify damage not in the same order as the damage
happened. These situations affect the progress of recovery
analysis.
Deﬁnition 1 If an IDS reports an incidents sequence
i1i2···in, where for any i j and ik, 1 ≤ j  0, such that for any defensive execution with α > β,
the situation will be worse than that without defensive ex-
ecutions. After ﬁnding out β, we can select an 0 < α≤
min(|V−P|
,β) to make sure that the defensive execution is
|P|
worth doing.
5.2 Measurements of effectiveness
Since we need to compare our techniques in this paper
to that without defensive executions, we ﬁrstly did experi-
ments on a prototype recovery system that was built based
on our techniques developed in [15, 14] to create relation-
ships between critical parameters.
All our experiments were done on a computer with a
Pentium 4 2.4Ghz CPU and 512MB RAM. The database
management system was PostSQL 7.4.5 under a Debian
Linux with kernel version 2.6.8-2. The prototype sys-
tem was developed with Java(TM) 2 Runtime Environment,
Standard Edition, build 1.4.2 04-b04. To get stable results,
each experiment lasts more than 300 seconds for given pa-
rameters, e.g., throughput.
The experimental results shown in Figure 4 demonstrates
the relationship between the turnaround time (the duration
)
d
n
o
c
e
s
i
l
l
i
m
(
e
m
i
t
d
n
u
o
r
a
n
r
u
T
0.75
0.7
0.65
0.6
0.55
0.5
0.45
0.4
0.35
0
Experimental results
   linear
100
200
300
400
500
600
Throughput (transactions/second)
Figure 4. Turnaround time with a ﬁtting func-
tion y1 = 0.00062191x+ 0.35454 and the norm of
residuals = 0.38164
time from the moment that a transaction enters the system
to the moment that the transaction leaves the system) and
the throughput (the number of transactions that the system
processes in each second) of the system.
For simplicity, we can use a linear expression f1(x) =
0.00062191x + 0.35454 to describe the relationship in Fig-
ure 4. Please note that we can also use other functions in
stead of f1(x) for better accuracy. Function f1(x) can be
determined by experimental study and curve ﬁtting for any
given system as we did.
We deﬁne f2(x) = x f1(x) as the system load function.
We can get the corresponding system load shown in Fig-
ure 5. For example, when the system has throughput 100
transactions/second, the turnaround time for each transac-
tion is about 0.4 milliseconds. Therefore, 100 transactions
can be done in 40 milliseconds. In each second, the system
spends around 40/1000 = 4% time on processing transac-
tions. Hence the system load is 4% according to our deﬁni-
tion.
Because most systems are running under unsaturated
system load (< 100%), in this paper, we are more interested
in the linear part of the system load as shown in Figure 5.
The measurements of effectiveness are shown in Fig-
ure 6.
The top part of the ﬁgure shows an execution without
defensive executions. After time Te, if the execution was
identiﬁed by the IDS as intruded, we need time Tr to re-
cover the execution, which includes necessary damage as-
sessment, undo tasks, and redo tasks [14, 15].
Figure 7 shows the experimental results of Tr
Te
, where we
deﬁne attacking density as the number of malicious trans-
7
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:05:44 UTC from IEEE Xplore.  Restrictions apply. 
)
%
(
d
a
o
L
m