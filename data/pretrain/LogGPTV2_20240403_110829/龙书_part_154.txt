中，而函数返回运算把存储返回值的变量复制到被赋予调用结果的
间分析技术。也就是说，-
！练习12.4.3：如果我们用图12-21中的规则2所描述的复制运
过程间分析
2）方法m的形式参数被赋予了实在参数所指向的对象。实在参数不仅仅包括直接传递的
2）某些在问题1中做出的推导实际上是“假冒的”，也就是说它们
1）对这个代码进行控制流无关的分析。
练习12.4.1：在图12-24中，h和g 用于表示新创建对象的标号，它们
1）确定接收对象的类型，也就是y所指向对象的类型。假设它的类型是t。令m 是最低的具有名
在 Java 中，一个形如 ×=y. n(z)的方法调用对指针指向关系的影响可以计算如下：
现在我们考虑方法调用。我们首先解释如何使用指针指向分析技术来获得精确的调用图
！练习12.4.2：对下列代码
this 变量。
TC
Ta
=
b:
区
一个调用把实在参数复制到相应的形式参
图12-25指针指向分析
void main(） {
t p(tx){
图12-24练习12.4.1
的示例代码
return a;
a.f
的代码
a
=
.= new T();
?
new
595
作
---
## Page 612
H，并且 M是在调用 T类型的对象时所使用的方法，
子目标表示，如果V可以指向实际类型为T的堆对象
它调用了由V指向的接收对象的名为 N的方法。这
说，“S：V.N(...)"表明存在一个标号为S的调用点，
中的规则。
来越多的指针指向关系。这个效果被总结为图 12-27
据参数被传入及返回值被传出的情况，我们会得到越
class hierarchy analysis(类层次结构分析)的缩写）。
够从源代码中轻易获得：
12.5.2在 Datalog 中发现调用图
标，这个分析过程终止了。它既没有分析第2行中声明的方法，也没有断定α可能指向h。
方
指向j，而j是一个类型为的对象。
h和i。
类型。不仅如此，看起来在第5 行之后α可以指向对象g、
是
向
本身又是：的一个子类。如果只使用声明类型的信息进行
例12.24在图12-26的代码中，r是s的-个子类，而s
新的指针指向关系为止。
方
计算指针指向集合的同时找出调用目标。这个分析需要不断进行，直到找不到新的调用目标和
知道了调用目标，否则无法找出所有这些变量会指向什么样的对象。这个递归关系要求我们在
又不精确。
包含了大型类库的实际程序中，这个方法可能会得到很多虚假的调用目标，使得分析过程既缓慢
量的类型为 Object，那么所有名为n 的方法都是可能的调用目标。在密集使用对象层次结构和
变量的类型为t，那么只有t的某个子类型中名字为n 的方法会被调用。遣憾的是，如果被声明变
如何确定接收对象的类型。我们可以根据这个变量的声明保守地确定它的类型。比如，被声明
是另一个类型为‧的对象。因为没有发现更多的新调用目
法也可能是--个调用目标，且现在α可能也指向i，而i
g，而g是一个类型为r的对象。因此，第3行中声明白
法是一个调用目标。分析第1行，我们确定α也可能指
法中的任何-个，因为s和r都是α的声明类型t的子
第一个规则计算了调用点的调用目标。也就是
调用图的每个边都被表示为一个 IDB 断言invokes。
 通过分析程序中指针指向关系，我们首先确定α可以
我们需要知道被分析的变量可能指向什么样的对象，以便计算出调用目标。但是，除非我们
596
3） cha(T，N,M)表示在一个类型为 T的接收对象上调用 N时实际调用的方法是 M(cha 是
2）formal（M，I，V)表示V是方法M中声明的第I 个形式参数。
1）actual(S，I，V)表示 V是调用点 S上的第I个实在参数。
为了写出上下文无关的过程间分析的 Datalog 规则，我们引人三个 EDB 断言，每个断言都能
在上下文无关分析中，参数和返回值都由复制语句建模。尚待解决的一个有意思的问题是
3）方法m的返回对象被赋给这个赋值语句的左部变量。
，因此，第1行中声明
当我们找到的调用图的边越来越多时，根
的
的
图 12-27发现调用图的 Datalog 程序
invokes(S, M)
3)i:
2) h:
1)g:
图12-26
pts(V. H)
main（）{
class r extends s {
class s extends t {
class t{
t a= new t();
t n() { return new r();}
t n() {return new s();}
[()I mau uinaar } ()u 2.
一个虚拟方法调用
：-
pts(W,H)
inuokes(S, M) &
pts(V,H)&
“S : V.N()" &
第12章
8
）&
口
---
## Page 613
任何用以存放返回值的变量所指向的任何对象。
理下面的情况：如果一个方法调用返回了--个对象，那么被赋值为这个调用结果的变量可能指向
12.5.4 12.5节的练习
象的类型。假设没有重新定义强制类型转换的异常处理程序，那么这个对象必然属于类型T的
个值是在哪里输人的，而开发者就可以限定这个值的取值范围。
析的另一个应用。如果className 的值是基于用户输人的，那么指针指向分析可以帮助确定
不可变的，那么知道className 指向什么值就可以知道这个类的名字。这个技术是指针指向分
值时指出这个对象所属的类。如果className 的值是在程序中定义的，因为Java 中的字符串是
12.25 中给出的用法。只要这个应用没有重新定义类加载器，我们就可以在知道className 的
是直接把 cbject 当作o的类型。
newInstance 返回该类的一个实例。对象o的类型被强制转换成为所有预期类的超类 T，而不
例12.25
因此一般情况下唯一可能的近似估算就是假设什么都有可能。
以及被访问的字段名。这些类型、方法和字段名可以通过计算获得，也可以根据用户输人获得，
守分析：反射机制。反射机制允许程序动态地决定将要创建的对象的类型、被调用的方法的名字
的源代码。这个选项非常重要，因为Java 程序常常使用很多的类库。
可能静态地给出任何对调用图和指针别名的保守的估算。静态分析只能基于被分析代码给出-
12.5.3动态加载和反射
上下文无关和控制流无关的指针指向分析生成了一个调用图。相对于那个只根据类型声明和语
关的指针指向分析方法。其中的调用图是在分析的同时动态生成的。这个分析的副作用是使用
用中相应的实在参数所指向的任何对象。处理返回值的规则留作练习请读者自行完成。
那么调用点S 可能调用方法 M。
某
其一个子类。
类似地，我们可以利用类型强制转换语句，即例子12.25 中的第4行，来估算动态创建的对
即使假设已经分析了所有被执行的代码，还有一个更加复杂的机制使得我们不可能进行
近似。请记住，这里描述的所有分析都可以在Java 字节码的层次上应用，因此不需要检查它们
分析得到的调用图，这个调用图要精确得多。
把这两个规则和 12.4节中解释的规则组合起来，我们就建立了…--个使用调用图的上下文无
第二个规则说明，如果调用点S可以调用方法 M,那么 M的每个形式参数都可能指向本次调
过程间分析
虽然很多大的Java 应用使用反射机制，但它们通常使用--些常见的习惯用法，比如例子
Java 这样的语言支持类的动态加载。因此分析--个程序执行的所有代码是不可能的，也就不
！练习12.5.2：你将如何向12.5.2节中的EDB断言和规则中加人附加的断言和规则来处
2）推导出所有可能的 pts 和 htps 事实。
1）构造 EDB 关系 actual、formal 和 chae
练习12.5.1：对于图12-26中的代码
23
Tt
下面的例子给出了反射机制的常见用法：
‘o（L）=
597
---
## Page 614
用串来表示不同的上下文。可以使用多个方法来限制不同的上下文的数目。比如，我们可以编
可能是程序中函数数量的指数级。
示。同时它也是一个可接受的表示方式，因为只有有限多个不同的上下文。虽然上下文的个数
中。如果栈中没有递归函数，那么这个调用串(即调用了栈中函数的位置的序列)是一-个完全
看待上下文的方法是把它看作一个调用序列的摘要。这些调用的活动记录当前位于运行时刻栈
何创建克隆的调用图。
无关的指针指向分析过程。12.5节讨论过，这个分析过程同时生成了调用图。现在我们描述如
助于我们使用紧凑的方式来表示多个调用上下文。为了得到调用图，我们首先运行一次上下文
12.6.1上下文和调用串
得正确写出这个分析方法的任务变得容易得多，因为它利用了很多行经过充分调试的代码。
分析结果进行深度分析的技术。无论如何，指针指向分析结果本身并不令人感兴趣。第二，它
码。这个方法具有多个重要的优势。首先，它使得人们能够比较容易地表示那些利用指针指向
示一个上下文相关的指针指向分析。而这个程序利用了已有的几千行用于 BDD 数据操作的代
多年来在 BDD 抽象方面所做的工作来消除算法的复杂性。我们可以用很少几行 Datalog 程序来表
是一
图应月
也并不少见。把这么多上下文的分析结果用某种方式表示出来是我们所面临的挑战。
12.1.3 中讨论的那样把所有递归调用环塌缩为一个点，在一个Java 应用中找到1014个上下文的情况
个方法看起来简单，但最大的难点在于如何处理大量克隆的细节。有多少个上下文？即使我们像
上下文都给出一个对应方法的克隆。然后，我们对克隆得到的调用图进行上下文无关分析。虽然这
于一
指针指向集合是一个更大的问题。因为上下文环境的数量可能按照指数级增长。这样的信息对
数据的指向集合，以及由该方法及被调用方法所创建的全部对象的指向集合。虽然人们已经给
示。也就是说，一个方法可能改变的指向集合包括：所有可通过静态变量及输人参数到达的所有
括这个函数和所有被调用者可能做出的所有更新所产生的影响。这些影响需要用输人参数来表
节）。那么我们应该使用哪一个方法呢？
程间分析的方法，--种基于克隆的方法（见12.1.4节），另一种是基于摘要的方法（见12.1.5
12. 6
但如果程序中存在递归函数，那么可能的调用串的数目是无穷的，我们不能用所有可能的调
了复杂的解决方案，但是现在还没有解决方法可以被应用到大型程序中。即使摘要可以通；
在计算指针指向信息的摘要时有几个难点。首先，这些摘要很大。每个方法的摘要必须
598
调用串形成了活跃的函数调用的历史，而--个上下文就是一个调用串的表示形式。另一个
这个处理上下文相关性的方法很好地说明了抽象方面的重要性。我们将说明如何应用人们
2）如何表示指数量级的上下文？方法之一是把这个信息表示为一个二分决策图（BDD）。这
我们把对上下文相关性的讨论分成两个部分：
在本节中，我们将讨论基于克隆的上下文相关分析技术。基于克隆的分析直接为每个感兴趣白
 12.1.2节中讨论过，上下文相关性可以大大提高过程间分析的精确性。我们讨论了两种过
个经过高度优化的数据结构，曾经用于很多其他的应用。
用上下文无关的分析算法。
1）如何在逻辑上处理上下文相关性？这个部分较为简单，因为可以直接对克隆得到的调用
-些全局性查询是必须的，比如在代码中找出指向某个特定对象的所有指针。
上下文相关指针分析
第12章
表
使
这
包
---
## Page 615
加上相应的上下文就可以得到克隆后的调用图的边。请注意，在原调