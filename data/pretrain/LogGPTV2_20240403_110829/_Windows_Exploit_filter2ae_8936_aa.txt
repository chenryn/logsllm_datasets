# 【技术分享】Windows Exploit开发系列教程——堆喷射（二）
|
##### 译文声明
本文是翻译文章，文章来源：fuzzysecurity.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
翻译：[lufei](http://bobao.360.cn/member/contribute?uid=168367515)
预估稿费：260RMB
投稿方式：发送邮件至[linwei#360.cn](mailto:PI:EMAIL)，或登陆[网页版](http://bobao.360.cn/contribute/index)在线投稿
传送门：[【技术分享】Windows
Exploit开发系列教程——堆喷射（一）](http://bobao.360.cn/learning/detail/3548.html)
**前言**
大家好，欢迎回到本部分教程堆喷射2部分。本教程将引导您在IE8上使用精密堆喷射。
**有两种基本的场景下，需要你使用非常精确的堆喷射：**
(1)你必须处理DEP防护情况下，你需要将执行流程从你的ROP链开始。
(2)你利用Use-After-Free，需要满足虚函数的一些数据处理流程。
我想找到一个处理这两个问题的例子，但是许多这样的漏洞是一个相当复杂，不一定适合作为教程。
应该明白两个道理。首先，实践动手才是最好，找到漏洞，把它们的难点分开，解决一些难点，尝试更难的，再减少难点，循环下去继续。其次，本教程不关注漏洞分析，因为这些教程是关于在编写漏洞攻击和如何克服它们时你将面临的障碍。
今天我们来看看MS13-009这个漏洞，你可以在[这里](http://www.exploit-db.com/exploits/24495/)找到metasploit模块。 如果你想更好地掌握本章的教程内容，我强烈推荐下面添加的一些链接阅读材料。
**调试机器：**
Windows XP SP3 with IE8
**链接：**
Exploit writing tutorial part 11 : Heap Spraying Demystified (corelan) –
[here](https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/)
Heap Feng Shui in JavaScript (Alexander Sotirov) –
[here](http://www.phreedom.org/presentations/heap-feng-shui/)
Post-mortem Analysis of a Use-After-Free Vulnerability (Exploit-Monday) –
[here](http://www.exploit-monday.com/2011/07/post-mortem-analysis-of-use-after-free_07.html)
Heap spraying in Internet Explorer with rop nops (GreyHatHacker) –[
here](http://www.greyhathacker.net/?p=549l)
CVE-2013-0025 MS13-009 IE SLayouRun (Chinese analysis of ms13-009, you will
probably need to load this from the google cache) –
[here](http://www.hackdig.com/wap/?id=2239)
**  
**
**介绍**
我想这个课题需要一些介绍，但你会发现，许多障碍，对你不陌生。我不会深入到所有更细微的点，因为这将需要很多时间。如果这里的一些技术不熟悉，我建议你阅读本教程系列的第7部分（面向返回编程）和第8部分（堆喷射[第1章：可控EIP]）。
我们谈论Use-After-Free时，需要了解什么是虚表。C++语言允许基类定义虚函数。基类派生类也可以定义自己的函数(与虚函数同名)。因此，虚拟函数允许派生类替换基类函数。编译器会确保每当调用的对象实际上是派生类时，总是调用替换。所有这一切发生在运行时。虚表包含指向基类中定义函数的指针。当需要在运行时调用函数时，根据需要它的派生类从虚表中选择适当的指针。我们可以看到下面的图形表示。
**1.1**
Use-After-Free漏洞通常相当复杂，其原因因案例而异。通常执行流程的工作原理是这样的：
（1）在某个时刻一个对象被创建并与一个vtable相关联；
（2）该对象被一个vtable指针调用。如果我们释放对象在它被调用之前，程序将崩溃，当它后来试图调用对象（例如：它尝试使用对象后它被释放 – UAF）。
为了利用这个问题，我们将一般地执行以下步骤：
（1）在某个点创建一个对象；
（2）我们对这个对象触发后释放；
（3）创建我们自己的对象，对象大小尽可能与上次创建的对象大小接近；
（4）以后当vtable指针被调用时，我们自己创建的假对象将被使用，我们获得代码执行。
这听起来非常复杂，但通过实例演示将变成简单。首先，我们将创建一个可靠的堆喷射，然后我们将专注于ms13-009！
**  
**
**堆的Shellcode**
正如我们在第8部分中所做的那样，我想从IE8上获得可靠的喷喷射开始。 继续我们之前做的工作，修改我们之前的POC。
这个POC已经从第8部分中的版本略有修改。这里的主要区别是我已经添加了一个alloc函数，它将我们的缓冲区作为输入，调整分配的大小，使它们匹配BSTR规范（我们需要
减去6以补偿BSTR头和尾，并除以2，因为我们使用unicode unescape）。
让我们用windbg调试器，看看当我们执行这个喷射时会发生什么。
下面的图像是我们的喷射表示。 我们已经填充了150mb的我们自己的数据，这150mb被分成150块1mb（每个块被存储为一个单独的BSTR对象）。
这个BSTR对象又填充了包含我们的shellcode和我们的NOP的0x1000十六进制（4096字节）的块。
**  
**
**1.2**
到现在为止还挺好！ 接下来，我们需要重新调整我们的堆喷射，以便shellcode变量完全指向0x0c0c0c0c，这将是我们的ROP链的开始。
考虑如果0x0c0c0c0c被分配在内存中的某个地方，因为我们的堆喷射，那么它必须有一个特定的偏移量在我们的0x1000块。
我们要做的是计算从块开始到0x0c0c0c0c的偏移，并将其作为填充添加到我们的喷射。
如果你重新运行上面的喷射，你会注意到0x0c0c0c0c不会总是指向相同的堆，但是从我们的0x1000十六进制块的开始到0x0c0c0c0c的偏移将始终保持不变。
我们已经拥有了计算填充大小所需的所有信息。
让我们修改POC并在调试器中重新运行喷射。
正如我们在下面可以看到的，我们已经设法将我们的shellcode重新对齐到0x0c0c0c0c。
事实上，当我们在内存中搜索字符串“FuzzySecurity”时，我们可以看到所有位置都在相同的字节结尾0x?????c0c。
所以我们现在用这样的方法调整我们的堆喷射，我们可以使我们的shellcode指向我们选择的任意地址（在这种情况下为0x0c0c0c0c）。
堆喷射在IE7-8上工作，并已在Windows XP和Windows 7上测试。通过一些修改，它可以在IE9上工作，但这不在本教程的范围。
**  
**
**详解MS13-009**
如前所述，本教程的主要目标不是分析漏洞，而是要理解在编写exploit时您面临的障碍。 然而，我们将快速查看该漏洞，以了解发生了什么。
以下POC是触发错误的最精简的案例文件。