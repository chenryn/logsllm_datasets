# 【技术分享】Windows Exploit开发系列教程——堆喷射（二）

### 译文声明
本文为翻译文章，原文来源：fuzzysecurity.com。译文仅供参考，具体内容及含义请以原文为准。
- 翻译：[lufei](http://bobao.360.cn/member/contribute?uid=168367515)
- 预估稿费：260 RMB
- 投稿方式：发送邮件至 [linwei#360.cn](mailto:PI:EMAIL) 或访问 [网页版](http://bobao.360.cn/contribute/index) 在线投稿
- 相关链接：[【技术分享】Windows Exploit开发系列教程——堆喷射（一）](http://bobao.360.cn/learning/detail/3548.html)

## 前言
大家好，欢迎回到本教程的第二部分，我们将继续探讨如何在IE8上使用精密堆喷射进行漏洞利用。

在以下两种情况下，您需要使用非常精确的堆喷射：
1. 当面对DEP防护时，您需要将执行流程从您的ROP链开始。
2. 当利用Use-After-Free漏洞时，您需要满足虚函数的数据处理流程。

尽管许多这样的漏洞相对复杂且不适合用作教学案例，但通过实践和逐步解决难题，您可以逐渐掌握这些技巧。请注意，本教程的重点不在于漏洞分析，而是在于编写漏洞攻击代码并克服遇到的障碍。

今天我们将研究MS13-009漏洞，您可以在这里找到相应的Metasploit模块：[Exploit-DB](http://www.exploit-db.com/exploits/24495/)。为了更好地理解本章内容，强烈推荐阅读以下参考资料：

### 调试环境
- Windows XP SP3 with IE8

### 参考资料
- [Exploit writing tutorial part 11 : Heap Spraying Demystified (corelan)](https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/)
- [Heap Feng Shui in JavaScript (Alexander Sotirov)](http://www.phreedom.org/presentations/heap-feng-shui/)
- [Post-mortem Analysis of a Use-After-Free Vulnerability (Exploit-Monday)](http://www.exploit-monday.com/2011/07/post-mortem-analysis-of-use-after-free_07.html)
- [Heap spraying in Internet Explorer with rop nops (GreyHatHacker)](http://www.greyhathacker.net/?p=549l)
- [CVE-2013-0025 MS13-009 IE SLayouRun (中文分析, 您可能需要通过Google缓存查看)](http://www.hackdig.com/wap/?id=2239)

## 引言
虽然这个主题需要一些介绍，但你会发现其中很多概念并不陌生。我们不会深入到所有细节，因为这会花费大量时间。如果你对这里提到的一些技术不太熟悉，建议先阅读本教程系列的第7部分（面向返回编程）和第8部分（堆喷射：可控EIP）。

当我们讨论Use-After-Free漏洞时，需要了解虚表的概念。C++允许基类定义虚函数，派生类可以重写这些虚函数。编译器确保当调用的对象实际上是派生类时，总是调用重写的函数。这一切都在运行时发生。虚表包含指向基类中定义函数的指针。当需要调用函数时，根据需要从虚表中选择适当的指针。下图展示了这一过程。

### Use-After-Free漏洞概述
Use-After-Free漏洞通常较为复杂，原因因具体情况而异。其一般工作原理如下：
1. 在某个时刻创建一个对象，并将其与一个虚表关联。
2. 该对象被一个虚表指针调用。如果在调用之前释放了该对象，程序将在稍后尝试使用已释放的对象时崩溃（即UAF）。

为了利用这个问题，我们通常会执行以下步骤：
1. 创建一个对象。
2. 触发对该对象的释放。
3. 创建一个新的对象，使其大小尽可能接近之前的对象。
4. 当虚表指针被调用时，我们创建的假对象将被使用，从而获得代码执行权限。

这听起来可能很复杂，但通过实例演示会变得简单。首先，我们将创建一个可靠的堆喷射，然后专注于MS13-009漏洞。

## 堆喷射Shellcode
正如我们在第8部分所做的那样，我们希望从IE8上获得可靠的堆喷射。我们继续修改之前的POC。这个POC已经略有改动，主要区别是添加了一个`alloc`函数，它接受我们的缓冲区作为输入，调整分配大小以符合BSTR规范（我们需要减去6以补偿BSTR头和尾，并除以2，因为我们使用Unicode转义）。

让我们用Windbg调试器来看看执行这个喷射时会发生什么。下图显示了我们的喷射表示。我们已经填充了150MB的数据，分成150个1MB的块（每个块存储为单独的BSTR对象）。每个BSTR对象又填充了包含我们的shellcode和NOP的4096字节的块。

### 重新调整堆喷射
接下来，我们需要重新调整堆喷射，使shellcode变量完全指向0x0c0c0c0c，这是我们的ROP链的起始地址。考虑如果0x0c0c0c0c在内存中的某个地方，由于我们的堆喷射，它必须有一个特定的偏移量在我们的0x1000块中。

我们要做的是计算从块开始到0x0c0c0c0c的偏移，并将其作为填充添加到我们的喷射中。如果您重新运行上面的喷射，会注意到0x0c0c0c0c不会总是指向相同的堆，但从0x1000十六进制块的开始到0x0c0c0c0c的偏移将始终保持不变。

我们已经有了计算填充大小所需的所有信息。让我们修改POC并在调试器中重新运行喷射。如下图所示，我们已经成功地将shellcode重新对齐到0x0c0c0c0c。实际上，当我们在内存中搜索字符串“FuzzySecurity”时，可以看到所有位置都在相同的字节结尾0x?????c0c。

因此，我们现在可以用这种方法调整堆喷射，使shellcode指向我们选择的任意地址（在这种情况下为0x0c0c0c0c）。这种堆喷射方法在IE7-8上有效，并已在Windows XP和Windows 7上测试。通过一些修改，它也可以在IE9上工作，但这不在本教程的范围内。

## 详解MS13-009漏洞
如前所述，本教程的主要目标不是分析漏洞，而是要理解在编写exploit时您面临的障碍。然而，我们将快速查看该漏洞，以了解发生了什么。以下是最精简的POC文件，用于触发该错误。