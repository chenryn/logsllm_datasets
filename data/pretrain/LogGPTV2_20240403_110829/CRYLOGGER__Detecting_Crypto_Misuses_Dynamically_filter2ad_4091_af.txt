RSA key (R-19) does not pose concrete risks. L-09 is a popular
library for advertisements. The library uses the same (key, IV)
pairs to store data locally. The same (key, IV) pairs are reused
across different apps, i.e., all the apps using this library end up
using the same sequence of (key, IV) pairs. About 30% of the
apps in our dataset share the same sequence of pairs which are
used to encrypt data in the private folder of each app. The library
developers conÔ¨Årmed this issue, but they classiÔ¨Åed it as out-of-
scope. Note that this experiments cannot be replicated by static
tools and it is an example of how CRYLOGGER can perform
inter-app analysis. L-10 is a common library for advertisements.
The library employs weak encryption practices to store data
locally. We talked with the library developers. They were aware
of the issue and said that the data are not security critical.
This analysis reveals that the threat model of CRYLOGGER
and all the other static tools is not aligned with the develop-
ers‚Äô threat model. Developers claim that sensitive data can
be encrypted poorly if they are stored only locally because
privilege escalation is required to access them. Unfortunately,
side-channel attacks can also access the data [56]. While we
recommend to always adopt safe crypto practices, one way to
to avoid such types of warnings in CRYLOGGER is to log when
data are stored on the local storage (e.g., in classes such as
File or KeyStore) and discard the corresponding violations.
Developers are also more interested to rules that, if violated, pose
concrete security threats as also reported in [6]. For example,
while setting a minimum size for keys (R-19) is important, the
effects of its violation are hard to assess. Since the feedback we
received from developers is limited to a few apps, we decided to
analyze some apps manually to determine if the vulnerabilities
of Fig. 7 are exploitable.
B. Analysis of Vulnerabilities
We reverse engineered 28 apps with APKTool and JADX12.
We chose half of the apps among the most popular apps of our
dataset (Section VII) with the highest number of violations. We
chose the remaining half randomly. The apps characteristics are
shown in Fig. 8. We performed the following steps for reverse
engineering: (i) we used APKTool and JADX to obtain the Java
code from the binary (apk) of the app, (ii) we analyzed the app
with CRYLOGGER, which we extended to log the stack trace
for each rule violation, and (iii) we manually analyzed the code
starting from the Ô¨Çagged API call to understand its purpose in
the app. We spent on average 6 hours per app for code analysis.
A signiÔ¨Åcant number of these apps (14/28) are vulnerable to
attacks, even though some may be considered out-of-scope by
developers. Most of the rules (22/26) are effective in detecting
at least one vulnerable app. App A-13 violates many rules related
to encryption. This app uses encryption to manage subscriptions
to premium features and users data. The subscription and the
users data are stored locally on the app and attacker can read
the data as well as fake subscriptions. Similarly, apps A-18, A-
20, A-24, A-25, A-33, and A-34 store critical users data (emails,
answers to security questions, etc.) by using weak encryption
algorithms. A-22, A-29, and A-30 store SSL/TLS certiÔ¨Åcates
with weak password-based encryption. A-14 uses a constant seed
(R-17) to randomly generate keys used for encryption of users
data, so the keys can be easily obtained. Apps A-31,A-32, and
12https://github.com/skylot/jadx; vers: 1.1.0, commit: cc29da8.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:27:57 UTC from IEEE Xplore.  Restrictions apply. 
1983
DEVELOPERS FEEDBACK
REVERSE ENGINEERING
ID Type (#Downloads)
A-01 File Manager (100M+)
Analyzed Violations
R-02, R-03, R-05, R-07,
R-08, R-09, R-10, R-12,
R-19
R-16, R-23
A-02 Data Transfer (10M+)
A-03 Video Streaming (10M+) R-09, R-20, R-22
A-04 Newspaper App (5M+)
A-05 Social & News (5M+)
R-01, R-19, R-20, R-23
R-05, R-06, R-07, R-08
R-10, R-16, R-19
A-06 Language Learning (1M+) R-16
A-07 Music Streaming (1M+)
A-08 Video Streaming (1M+)
L-01 Advertisement (N.A.)
L-02 Advertisement (N.A.)
R-01, R-05, R-06, R-09
R-16, R-23
R-09
R-07, R-08, R-10
Analyzed Violations
ID Type (#Downloads)
A-09 Messaging (100M+)
A-10 Entertainment (100M+) R-18, R-22
A-11 Movie Reviews (100M+) R-18, R-19, R-21
A-12 Book Reading (50M+)
R-02, R-03, R-05, R-06
A-13 Passw. Manager (50M+) R-02, R-03, R-04, R-05
R-01
R-06, R-07, R-08
A-14 Passw. Manager (50M+) R-17
A-15 Screen Utils (10M+)
R-01
A-16 File Manager (10M+)
R-01
A-17 Video Streaming (10M+) R-04
A-18 Video Streaming (10M+) R-04, R-07, R-08, R-21,
R-23
A-19 Video Streaming (10M+) R-09, R-20, R-22
A-20 Live Events Info (10M+) R-11, R-16
A-21 Video Streaming (10M+) R-11, R-13
A-22 Video Streaming (10M+) R-14, R-15, R-16
A-23 Newspaper App (5M+)
R-01, R-19, R-20, R-21
ID Type (#Downloads)
A-24 Mail Manager (5M+)
A-25 Video Streaming (5M+)
Analyzed Violations
R-04, R-05, R-06, R-10
R-12, R-13, R-16
R-19, R-21, R-24, R-25
R-26
R-22
R-23
R-10, R-16
R-14, R-15, R-16
R-14, R-15, R-16
R-24, R-25, R-26
R-24, R-25, R-26
A-26 Stocks Manager (5M+)
A-27 Authentication (5M+)
A-28 Video Streaming (1M+)
A-29 Blog Reading (1M+)
A-30 Book Reading (1M+)
A-31 Healthcare Info (1M+)
A-32 Music Streaming (1M+)
A-33 Newspaper App (500K+) R-03, R-05, R-06, R-10
R-13, R-16, R-24, R-25
R-26
R-10, R-11, R-13, R-16
A-34 Entertainment (100K+)
A-35 Passw. Manager (100K+) R-13
A-36 Video Streaming (100K+) R-22
Fig. 8. The Ô¨Årst table from the left reports the characteristics of the Android apps for which we received feedback from their developers. The other tables report the
characteristics of the apps that we reverse engineered. The rules reported in the last column of each table are those that were analyzed by the developers or by us.
A-33 are vulnerable to man-in-the-middle attacks because they
violate R-24, R-25, and R-26. These apps download copyrighted
videos/music as well as ads, which can be intercepted by
attackers. The other violations can be considered false positives.
Some are caused by ‚Äòimprecise‚Äô rules. For example, on 3 apps
each, rules R-01 and R-18 Ô¨Çag secure uses of hash algorithms
and random number generators for non-sensitive data. Similarly,
R-04 Ô¨Çags 3 apps that use CBC encryption for scenarios different
from client/server. Other violations come from (i) employing
weak encryption schemes to obfuscate non-sensitive data and
(ii) legacy practices such as using PCKS#1 as padding scheme
in SSL/TLS instead of more secure alternatives such as OAEP.
This analysis conÔ¨Årms that the threat model of CRYLOGGER
and all the other static tools does not completely align with the
developers‚Äô threat model and some rules produce false positives.
X. DISCUSSIONS AND LIMITATIONS
In this section, we discuss the advantages of dynamic ap-
proaches over static approaches and our current limitations.
Why a Dynamic Approach? To date, most of the approaches
to detect crypto misuses are based on static analysis, which
provides many beneÔ¨Åts. Static analysis can analyze the code
without executing it, and this is especially important for Android
apps since UI test generators are not required. Static analysis can
scale up to a large number of applications and, thanks to recent
improvements [6], it can analyze massive code bases. Static
analysis has, however, some limitations. It can produce false
positives, i.e., alarms can be raised on correct calls to crypto
APIs due to imprecise slicing algorithms. These alarms add up
to those raised on parts of the applications that are not security
critical (see Section IX). This makes it hard to analyze a large
number of applications. Some static approaches [6] also incur in
many false negatives. Some misuses escape detection because
the exploration is pruned prematurely to improve scalability. In
addition, static analysis misses some crypto misuses in the code
that is loaded dynamically. This prevents analyses on critical
code [20]. Also, static analysis can be inherently done on a single
application only. It is not possible to perform inter-application
analysis, as the one we did with CRYLOGGER on an Android
library (Section IX). On the other hand, dynamic analysis is
not a perfect antidote. Dynamic analysis is as good as the test
generator that is used to run the applications. We discuss the
main limitations of dynamic analysis in the next paragraphs.
False Positives. Although dynamic analysis, theoretically,
should avoid false positives, these are possible when detecting
crypto misuses (Section IX). It is hard to distinguish critical
parts of the application, which should obey to the rules, from
less critical parts where the data are not sensitive. In addition,
the threat model adopted by app developers can differ from the
one adopted in the research community. This requires complex
manual analyses. One possible solution is to log additional
information in other classes (e.g., File) to determine if rule
violations can be discarded. This would greatly reduce the false
positives, but it is hard to implement with general solutions.
False Negatives. Crypto misuses escape detection if they
are not exercised during the execution. In Section VIII, we
showed that for many Android apps, CRYLOGGER conÔ¨Årmed the
results reported by CryptoGuard and found misuses missed by
CryptoGuard. In other contexts, it might be harder to trigger the
crypto APIs depending on the speciÔ¨Åc application. One possible
solution is to complement CRYLOGGER with a static tool in
order to expose the misuses that cannot be triggered at runtime.
XI. CONCLUDING REMARKS
We presented CRYLOGGER, the Ô¨Årst tool that detects crypto
misuses dynamically, while supporting a large number of rules.
We released CRYLOGGER open-source to allow the community
to use a dynamic tool alongside static analysis. We hope that
application developers will adopt it to check their applications
as well as the third-party libraries that they use.
ACKNOWLEDGMENTS
This work was supported in part by the NSF (A#: 1527821 and
1764000), a gift from Bloomberg, DARPA HR0011-18-C-0017,
and N00014-17-1-2010.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:27:57 UTC from IEEE Xplore.  Restrictions apply. 
1984
REFERENCES
[1] ‚Äú[GitHub] lucapiccolboni/crylogger: CRYLOGGER (Version v1.0),
Zenodo.‚Äù [Online]. Available: https://doi.org/10.5281/zenodo.3911285
[2] R. L. Rivest, ‚ÄúHandbook of Theoretical Computer Science,‚Äù 1990.
[3] J. C. Zinzindohou¬¥e, K. Bhargavan, J. Protzenko, and B. Beurdouche,
‚ÄúHACL*: A VeriÔ¨Åed Modern Cryptographic Library,‚Äù in Proc. of the ACM
Conference on Computer & Communications Security (CCS), 2017.
[4] B. B. Brumley, M. Barbosa, D. Page, and F. Vercauteren, ‚ÄúPractical
Realisation and Elimination of an ECC-Related Software Bug Attack,‚Äù
in Cryptographer‚Äôs Track at the RSA Conference, 2012.
[5] M. Egele, D. Brumley, Y. Fratantonio, and C. Kruegel, ‚ÄúAn Empirical
Study of Cryptographic Misuse in Android Applications,‚Äù in Proc. of the
ACM Conference on Computer & Communications Security (CCS), 2013.
[6] S. Rahaman, Y. Xiao, S. Afrose, F. Shaon, K. Tian, M. Frantz, M. Kantar-
cioglu, and D. Yao, ‚ÄúCryptoGuard: High Precision Detection of Crypto-
graphic Vulnerabilities in Massive-sized Java Projects,‚Äù in Proc. of the
ACM Conference on Computer & Communications Security (CCS), 2019.
[7] M. Stevens, E. Bursztein, P. Karpman, A. Albertini, Y. Markov, A. P.
Bianco, and C. Baisse, ‚ÄúThe First Collision for Fully SHA-1,‚Äù in Proc. of
the International Cryptology Conference (CRYPTO), 2017.
[8] F. Fischer, K. B¬®ottinger, H. Xiao, C. Stransky, Y. Acar, M. Backes, and
S. Fahl, ‚ÄúStack OverÔ¨Çow Considered Harmful? The Impact of Copy Paste
on Android Application Security,‚Äù in Proc. of the IEEE Symposium on
Security and Privacy (SP), 2017.
[9] S. Nadi, S. Krger, M. Mezini, and E. Bodden, ‚ÄúJumping Through Hoops:
Why do Java Developers Struggle with Cryptography APIs?‚Äù in Proc. of
the International Conference on Software Engineering (ICSE), 2016.
[10] Y. Acar, M. Backes, S. Fahl, S. GarÔ¨Ånkel, D. Kim, M. L. Mazurek, and
C. Stransky, ‚ÄúComparing the Usability of Cryptographic APIs,‚Äù in Proc.
of the IEEE Symposium on Security and Privacy (SP), 2017.
[11] I. Muslukhov, Y. Boshmaf, and K. Beznosov, ‚ÄúSource Attribution of
Cryptographic API Misuse in Android Applications,‚Äù in Proc. of the Asia
Conference on Computer & Communications Security (ASIA CCS), 2018.
[12] S. Vaudenay, ‚ÄúSecurity Flaws Induced by CBC Padding - Applications
to SSL, IPSEC, WTLS ...‚Äù in Proc. of the International Conference on
the Theory and Applications of Cryptographic Techniques: Advances in
Cryptologyi (EUROCRYPT), 2002.
[13] E. B. Barker and A. L. Roginsky, ‚ÄúTransitions: Recommendation for
Transitioning the Use of Cryptographic Algorithms and Key Lengths,‚Äù in
NIST Special Publication 800-131A, 2018.
[14] ‚ÄúPassword-Based Cryptography SpeciÔ¨Åcation, IETF (RFC 8018),‚Äù https:
//tools.ietf.org/html/rfc8018.
[15] S. Kr¬®uger, J. Sp¬®ath, K. Ali, E. Bodden, and M. Mezini, ‚ÄúCrySL: An
Extensible Approach to Validating the Correct Usage of Cryptographic
APIs,‚Äù in Proc. of the ACM European Conference on Object-Oriented
Programming (ECOOP), 2019.
[16] S. Fahl, M. Harbach, T. Muders, L. Baumg¬®artner, B. Freisleben, and
M. Smith, ‚ÄúWhy Eve and Mallory Love Android: An Analysis of Android
SSL (in)Security,‚Äù in Proc. of the ACM Conference on Computer &
Communications Security (CCS), 2012.
[17] S. Kr¬®uger, S. Nadi, M. Reif, K. Ali, M. Mezini, E. Bodden, F. G¬®opfert,
F. G¬®unther, C. Weinert, D. Demmler, and R. Kamath, ‚ÄúCogniCrypt:
Supporting Developers in Using Cryptography,‚Äù in Proc. of the ACM/IEEE
International Conference on Automated Software Engineering (ASE),
2017.
[18] S. Shuai, D. Guowei, G. Tao, Y. Tianchang, and S. Chenjie, ‚ÄúModelling
Analysis and Auto Detection of Cryptographic Misuse in Android
Applications,‚Äù in Proc. of the International on Dependable, Automatic
and Secure Computing (DASC), 2013.
[19] M. Weiser, ‚ÄúProgram Slicing,‚Äù in Proc. of the International Conference on
Software Engineering (ICSE), 1981.
[20] S. Poeplau, Y. Fratantonio, A. Bianchi, C. Kruegel, and G. Vigna, ‚ÄúExecute
This! Analyzing Unsafe and Malicious Dynamic Code Loading in Android
Applications,‚Äù in Proc. of the Network and Distributed System Security
Symposium (NDSS), 2014.
[21] A. Braga, R. Dahab, N. Antunes, N. Laranjeiro, and M. Vieira, ‚ÄúUnder-
standing How to Use Static Analysis Tools for Detecting Cryptography
Misuse in Software,‚Äù IEEE Transactions on Reliability, 2019.
[22] D. Sounthiraraj, J. Sahs, G. Greenwood, Z. Lin, and L. Khan, ‚ÄúSMV-
HUNTER: Large Scale, Automated Detection of SSL/TLS Man-in-the-
Middle Vulnerabilities in Android Apps,‚Äù in Proc. of the Network and
Distributed System Security Symposium (NDSS), 2014.
[23] F. Gagnon, M. F. M. Fortier, S. Desloges, J. Ouellet, and C. Boileau,
‚ÄúAndroSSL: A Platform to Test Android Applications Connection Security,‚Äù
in Proc. of the International Symposium on Foundations and Practice of
Security (FPS), 2015.
[24] J. Li, Z. Lin, J. Caballero, Y. Zhang, and D. Gu, ‚ÄúK-Hunt: Pinpointing
Insecure Cryptographic Keys from Execution Traces,‚Äù in Proc. of the ACM
Conference on Computer & Communications Security (CCS), 2018.
[25] Y. Li, Y. Zhang, J. Li, and D. Gu, ‚ÄúiCryptoTracer: Dynamic Analysis on
Misuse of Cryptography Functions in iOS Applications,‚Äù in Proc. of the
Network and Distributed System Security Symposium (NDSS), 2014.
[26] S. Afrose, S. Rahaman, and D. Yao, ‚ÄúCryptoAPI-Bench: A Comprehensive
Benchmark on Java Cryptographic API Misuses,‚Äù in Proc. of the IEEE
Secure Developement (SecDev), 2019.
[27] B. Johnson, Y. Song, E. Murphy-Hill, and R. Bowdidge, ‚ÄúWhy Don‚Äôt
Software Developers Use Static Analysis Tools to Find Bugs?‚Äù in Proc. of
the International Conference on Software Engineering (ICSE), 2013.
[28] C. Zheng, S. Zhu, S. Dai, G. Gu, X. Gong, X. Han, and W. Zou,
‚ÄúSmartDroid: An Automatic System for Revealing UI-based Trigger
Conditions in Android Applications,‚Äù in Proc. of the ACM Workshop
on Security and Privacy in Smartphones and Mobile Devices (SPSM),
2012.
[29] F. Fischer, H. Xiao, C. Kao, Y. Stachelscheid, B. Johnson, D. Razar,
P. Fawkesley, N. Buckley, K. B¬®ottinger, P. Muntean, and J. Grossklags,
‚ÄúStack OverÔ¨Çow Considered Helpful! Deep Learning Security Nudges
Towards Stronger Cryptography,‚Äù in Proc. of the USENIX Security
Symposium, 2019.
[30] Y. Wang, P. Leon, K. Scott, X. Chen, A. Acquisti, and L. Cranor, ‚ÄúPrivacy
Nudges for Social Media: An Exploratory Facebook Study,‚Äù in Proc. of
the International Conference on World Wide Web (WWW), 2013.
[31] M. Green and M. Smith, ‚ÄúDevelopers are Not the Enemy!: The Need for
Usable Security APIs,‚Äù IEEE Securityi & Privacy, 2016.
[32] D. C. Nguyen, D. Wermke, Y. Acar, M. Backes, C. Weir, and S. Fahl, ‚ÄúA
Stitch in Time: Supporting Android Developers in Writing Secure Code,‚Äù
in Proc. of the ACM Conference on Computer & Communications Security
(CCS), 2017.
[33] S. Ma, D. Lo, T. Li, and R. H. Deng, ‚ÄúCDRep: Automatic Repair of
Cryptographic Misuses in Android Applications,‚Äù in Proc. of the Asia
Conference on Computer & Communications Security (ASIA CCS), 2016.
[34] S. Ma, F. Thung, D. Lo, C. Sun, and R. H. Deng, ‚ÄúVuRLE: Automatic
Vulnerability Detection and Repair by Learning from Examples,‚Äù in Proc.
of the European Symposium on Research in Computer Security (ESORICS),
2017.
[35] L. Singleton, R. Zhao, M. Song, and H. Siy, ‚ÄúFireBugs: Finding and
Repairing Bugs with Security Patterns,‚Äù in Proc. of the International
Conference on Mobile Software Engineering and Systems (MOBILESoft),
2019.
[36] S. Kr¬®uger, K. Ali, and E. Bodden, ‚ÄúCogniCryptGEN: Generating Code for
the Secure Usage of Crypto APIs,‚Äù in Proc. of the ACM/IEEE International
Symposium on Code Generation and Optimization (CGO), 2020.
[37] S. R. Choudhary, A. Gorla, and A. Orso, ‚ÄúAutomated Test Input Generation
for Android: Are We There Yet?‚Äù in Proc. of the IEEE/ACM International
Conference on Automated Software Engineering (ASE), 2015.
[38] H. Zheng, D. Li, B. Liang, X. Zeng, W. Zheng, Y. Deng, W. Lam,
W. Yang, and T. Xie, ‚ÄúAutomated Test Input Generation for Android:
Towards Getting There in an Industrial Case,‚Äù in Proc. of the International
Conference on Software Engineering: Software Engineering in Practice
Track (ICSE-SEIP), 2017.
[39] S. Y. Yerima, M. K. Alzaylaee, and S. Sezer, ‚ÄúMachine Learning-based
Dynamic Analysis of Android Apps with Improved Code Coverage,‚Äù in
EURASIP Journal on Information Security, 2019.
[40] Y. Li, Z. Yang, Y. Guo, and X. Chen, ‚ÄúDroidBot: A Lightweight UI-Guided
Test Input Generator for Android,‚Äù in Proc. of the ACM/IEEE International
Conference on Software Engineering Companion (ICSE-C), 2017.
[41] A. Machiry, R. Tahiliani, and M. Naik, ‚ÄúDynodroid: An Input Generation
System for Android Apps,‚Äù in Proc. of the Joint Meeting on Foundations
of Software Engineering (ESEC/FSE), 2013.
[42] H. Krawczyk, ‚ÄúCryptographic Extraction and Key Derivation: The HKDF
Scheme,‚Äù in Proc. of the International Cryptology Conference (CRYPTO),
2010.
[43] J. Katz and Y. Lindell, Introduction to Modern Cryptography, 2014.
[44] ‚ÄúCryptographic Message Syntax, IETF (RFC 5652),‚Äù https://tools.ietf.org/
html/rfc5652.
[45] T. Jager, S. A. Kakvi, and A. May, ‚ÄúOn the Security of the PKCS#1 V1.5
Signature Scheme,‚Äù in Proc. of the ACM Conference on Computer &
Communications Security (CCS), 2018.
[46] P. Favre-Bulle, ‚ÄúSecurity Best Practices: Symmetric Encryption with AES
in Java and Android,‚Äù in ProAndroidDev (online), 2018.
[47] D. L. Wheeler, ‚Äúzxcvbn: Low-Budget Password Strength Estimation,‚Äù in
Proc. of the USENIX Security Symposium, 2016.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:27:57 UTC from IEEE Xplore.  Restrictions apply. 
1985
[48] P. A. Grassi, M. E. Garcia, and J. L. Fenton, ‚ÄúDigital Identity Guidelines,‚Äù
in NIST Special Publication 800-63-3, 2017.
[49] L. E. Bassham, ‚ÄúA Statistical Test Suite for Random and Pseudorandom
Number Generators for Cryptographic Applications,‚Äù in NIST Special
Publication 800-22, 2010.
[50] D. Boneh, A. Joux, and P. Q. Nguyen, ‚ÄúWhy Textbook ElGamal and RSA
Encryption Are Insecure,‚Äù in Proc. of the International Conference on
the Theory and Applications of Cryptographic Techniques: Advances in
Cryptologyi (ASIACRYPT), 2000.
[51] D. Bleichenbacher, ‚ÄúChosen Ciphertext Attacks Against Protocols Based
on the RSA Encryption Standard PKCS #1,‚Äù in Proc. of the International
Cryptology Conference on Advances in Cryptology (CRYPTO), 1998.
[52] S. Goldwasser and S. Micali, ‚ÄúProbabilistic Encryption & How to Play
Mental Poker Keeping Secret All Partial Information,‚Äù in Proc. of the ACM
Symposium on Theory of Computing (STOC), 1982.
[53] A. Lex, N. Gehlenborg, H. Strobelt, R. Vuillemot, and H. PÔ¨Åster, ‚ÄúUpSet:
Visualization of Intersecting Sets,‚Äù IEEE Transactions on Visualization
and Computer Graphics (TVCG), 2014.
[54] J. R. Conway, A. Lex, and N. Gehlenborg, ‚ÄúUpSetR: an R Package for
the Visualization of Intersecting Sets and their Properties,‚Äù Bioinformatics,
2017.
[55] A. Pilgun, O. Gadyatskaya, S. Dashevskyi, Y. Zhauniarovich, and A. Kush-
niarou, ‚ÄúAn Effective Android Code Coverage Tool,‚Äù in Proc. of the ACM
Conference on Computer & Communications Security (CCS), 2018.
[56] A. Tang, S. Sethumadhavan, and S. Stolfo, ‚ÄúCLKSCREW: Exposing the
Perils of Security-Oblivious Energy Management,‚Äù in Proc. of the USENIX
Security Symposium, 2017.
Package
java.security
Class
MessageDigest
javax.crypto
Cipher
Cipher
java.security
Signature
javax.crypto.spec
PBEKeySpec
javax.crypto.spec
PBEParameterSpec
java.security
SecureRandom
java.util
SecureRandom
Random
Random
java.security
KeyStore
java.net
URL
javax.net.ssl
HttpsURLConnection
javax.net.ssl
javax.net.ssl
SSLContext
SocketFactory
Function
byte[] digest (void)
int digest (byte[], int, int)
void init (int, Key, SecureRandom)
void init (int, Key, AlgorithmParameters, SecureRandom)
void init (int, Key, AlgorithmParameterSpec, SecureRandom)
void init (int, CertiÔ¨Åcate, SecureRandom)
byte[] doFinal (void)
int doFinal (byte[], int)
byte[] doFinal (byte[])
byte[] doFinal (byte[], int, int)
int doFinal (byte[], int, int, byte[])
int doFinal (byte[], int, int, byte[], int)
int doFinal (ByteBuffer, ByteBuffer)
void initVerify (PublicKey)
void initVerify (CertiÔ¨Åcate)
void initSign (PrivateKey)
void initSign (PrivateKey, SecureRandom)
PBEKeySpec (char[])
PBEKeySpec (char[], byte[], int)
PBEKeySpec (char[], byte[], int, int)
PBEParameterSpec (byte[], int)
PBEParameterSpec (byte[], int, AlgorithmParameterSpec)
SecureRandom (void)
SecureRandom (byte[])
void setSeed (byte[])
void nextBytes (byte[])
void setSeed (byte[])
Random (void)
int next (int)
void nextBytes (byte[])
Key getKey (String, char[])
void load (InputStream, char[])
void load (LoadStoreParameter)
void store (OutputStream, char[])
void store (LoadStoreParameter)
URL (String, String, int, String)
URL (URL, String, URLStreamHandler)
void setHostnameVeriÔ¨Åer (HostnameVeriÔ¨Åer)
void setDefaultHostnameVeriÔ¨Åer (HostnameVeriÔ¨Åer)
void init (KeyManger[], TrustManager[], SecureRandom)
SocketFactory getDefault (void)
Logged Data
alg
alg, mode,
pad, key,
iv
out
alg, key
pass, salt,
iter
salt, iter
seed, out
constructor
out
pass
urlprotl
allhost
sethost
allcert
sethost
Java functions that have been instrumented and the parameters that are logged as deÔ¨Åned in Fig. 2.
TABLE III
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:27:57 UTC from IEEE Xplore.  Restrictions apply. 
1986
UXOH5√≠
WSLQVXEVHW
WRWDO
UXOH5√≠
WSLQVXEVHW
WRWDO
YXOQHUDEOHDSSV