redirects the user’s browser to the IdP. The user then authenticates
to the IdP, e.g., by providing her user name and password, and
ﬁnally is redirected back to the RP along with an authorization
code generated by the IdP. The RP can now contact the IdP with
this authorization code (along with the client id and client secret)
and receive an access token, which the RP in turn can use as a
credential to access the user’s protected resources at the IdP.
Step-by-Step Protocol Flow. In what follows, we describe the pro-
tocol ﬂow of the authorization code mode step-by-step (see also
Figure 1). First, the user starts the OAuth ﬂow, e.g., by clicking
on a button to select an IdP, resulting in request 1 being sent to the
RP. The RP selects one of its redirection endpoint URIs redirect_uri
(which will be used later in 7 ) and a value state (which will serve as
a token to prevent CSRF attacks). The RP then redirects the browser
to the so-called authorization endpoint URI at the IdP in 2 and 3
with its client_id, redirect_uri, and state appended as parameters to
the URI. The IdP then prompts the user to provide her username
and password in 4 . The user’s browser sends this information to
the IdP in 5 . If the credentials are correct, the IdP creates a nonce
code (the authorization code) and redirects the user’s browser to
RP’s redirection endpoint URI redirect_uri in 6 and 7 with code
and state appended as parameters to the URI. If state is the same
as above, the RP contacts the IdP in 8 and provides code, client_id,
client_secret, and redirect_uri. Then the IdP checks whether this
information is correct, i.e., it checks that code was issued for the RP
identiﬁed by client_id, that client_secret is the secret for client_id,
that redirect_uri coincides with the one in Step 2 , and that code
has not been redeemed before. If these checks are successful, the
IdP issues an access token access_token in 9 . Now, the RP can
use access_token to access the user’s protected resources at the IdP
(authorization) or log in the user (authentication), as described next.
When OAuth is used for authorization, the RP uses the access
token to view or manipulate the protected resource at the IdP (illus-
trated in Steps 10 and 11 ).
For authentication, the RP fetches a user id (which uniquely
identiﬁes the user at the IdP) using the access token, Steps 12 and 13 .
The RP then issues a session cookie to the user’s browser as shown
in 14 .4
Tracking User Intention. Note that in order for an RP which sup-
ports multiple IdPs to process Step 7 , the RP must know which
IdP a user wanted to use for authorization. There are two different
approaches to this used in practice: First, the RP can use different
redirection URIs to distinguish different IdPs. We call this naïve
user intention tracking. Second, the RP can store the user intention
in a session after Step 1 and use this information later. We call this
explicit user intention tracking. The same applies to the implicit
mode of OAuth presented below.
Implicit Mode. This mode is similar to the authorization code
mode, but instead of providing an authorization code, the IdP di-
rectly delivers an access token to the RP via the user’s browser.
More speciﬁcally, in the implicit mode, Steps 1 – 5 (see Figure 1)
are the same as in the authorization code mode. Instead of creating
an authorization code, the IdP issues an access token right away and
redirects the user’s browser to RP’s redirection endpoint with the
access token contained in the fragment of the URI. (Recall that a
fragment is a special part of a URI indicated by the ‘#’ symbol.)
As fragments are not sent in HTTP requests, the access token
is not immediately transferred when the browser contacts the RP.
Instead, the RP needs to use a JavaScript to retrieve the contents of
the fragment. Typically, such a JavaScript is sent in RP’s answer at
the redirection endpoint. Just as in the authorization code mode, the
4Authentication is not part of RFC6749, but this method for
authentication is commonly used in practice, for example by Ama-
zon, Facebook, LinkedIn, and StackExchange, and is also deﬁned
in OpenID Connect [31].
1206RP can now use the access token for authorization or authentication
(analogously to Steps 10 – 14 of Figure 1).5
Resource Owner Password Credentials Mode. In this mode, the
user gives her credentials for an IdP directly to an RP. The RP can
then authenticate to the IdP on the user’s behalf and retrieve an ac-
cess token. This mode is intended for highly-trusted RPs, such as
the operating system of the user’s device or highly-privileged appli-
cations, or if the previous two modes are not possible to perform
(e.g., for applications without a web browser).
Client Credentials Mode. In contrast to the modes shown above,
this mode works without the user’s interaction. Instead, it is started
by an RP in order to fetch an access token to access the resources
of RP at an IdP. For example, Facebook allows RPs to use the client
credentials mode to obtain an access token to access reports of their
advertisements’ performance.
3. ATTACKS
As mentioned in the introduction, while trying to prove the secu-
rity of OAuth based on the FKS web model and our OAuth model,
we found four attacks on OAuth, which we call 307 redirect attack,
IdP mix-up attack, state leak attack, and naïve RP session integrity
attack, respectively. In this section, we provide detailed descriptions
of these attacks along with easily implementable ﬁxes. Our formal
analysis of OAuth (see Section 5) then shows that these ﬁxes are
indeed sufﬁcient to establish the security of OAuth. The attacks also
apply to OpenID Connect (see Section 3.5). Figure 2 provides an
overview of where the attacks apply. We have veriﬁed our attacks
on actual implementations of OAuth and OpenID Connect and re-
ported the attacks to the respective working groups who conﬁrmed
the attacks (see Section 3.6).
3.1 307 Redirect Attack
In this attack, which breaks our authorization and authentication
properties (see Section 5.2), the attacker (running a malicious RP)
learns the user’s credentials when the user logs in at an IdP that uses
the wrong HTTP redirection status code. While the attack itself is
based on a simple error, to the best of our knowledge, this is the
ﬁrst description of an attack of this kind.
Assumptions. The main assumptions are that (1) the IdP that is
used for the login chooses the 307 HTTP status code when redi-
recting the user’s browser back to the RP (Step 6 in Figure 1), and
(2) the IdP redirects the user immediately after the user entered her
credentials (i.e., in the response to the HTTP POST request that
contains the form data sent by the user’s browser).
Assumption (1). This assumption is reasonable because neither the
OAuth standard [20] nor the OAuth security considerations [26]
(nor the OpenID Connect standard [31]) specify the exact method
of how to redirect. The OAuth standard rather explicitly permits
any HTTP redirect:
While the examples in this speciﬁcation show the use
of the HTTP 302 status code, any other method avail-
able via the user-agent to accomplish this redirection
is allowed and is considered to be an implementation
detail.
5The response from the IdP in Step 13 includes the RP’s OAuth
client id, which is checked by the RP when authenticating a user
(cf. RFC7662 [30]). This check prevents re-use of access tokens
across RPs in the OAuth implicit mode, as explained in [37]. This
check is not needed for authorization.
Assumption (2). This assumption is reasonable as many examples
for redirects immediately after entering the user credentials can
be found in practice, for example at github.com (where, however,
assumption (1) is not satisﬁed.)
Attack. When a user uses the authorization code or implicit mode
of OAuth to log in at a malicious RP, then she is redirected to the
IdP and prompted to enter her credentials. The IdP then receives
these credentials from the user’s browser in a POST request. It
checks the credentials and redirects the user’s browser to the RP’s
redirection endpoint in the response to the POST request. Since
the 307 status code is used for this redirection, the user’s browser
will send a POST request to RP that contains all form data from the
previous request, including the user credentials. Since the RP is run
by the attacker, he can use these credentials to impersonate the user.
Fix. Contrary to the current wording in the OAuth standard, the
exact method of the redirect is not an implementation detail but
essential for the security of OAuth. In the HTTP standard [18],
only the 303 redirect is deﬁned unambiguously to drop the body
of an HTTP POST request. Therefore, the OAuth standard should
require 303 redirects for the steps mentioned above in order to ﬁx
this problem.
3.2 IdP Mix-Up Attack
In this attack, which breaks our authorization and authentica-
tion properties (see Section 5.2), the attacker confuses an RP about
which IdP the user chose at the beginning of the login/authorization
process in order to acquire an authentication code or access token
which can be used to impersonate the user or access user data.
This attack applies to the authorization code mode and the im-
plicit mode of OAuth when explicit user intention tracking6 is used
by the RP. To launch the attack, the attacker manipulates the ﬁrst
request of the user such that the RP thinks that the user wants to use
an identity managed by an IdP of the attacker (AIdP) while the user
instead wishes to use her identity managed by an honest IdP (HIdP).
As a result, the RP sends the authorization code or the access token
issued by HIdP to the attacker. The attacker then can use this in-
formation to login at the RP under the user’s identity (managed by
HIdP) or access the user’s protected resources at HIdP.
We here present the attack in the authorization code mode. In
the implicit mode, the attack is very similar and is shown in detail
in [17].
Assumptions. For the IdP mix-up attack to work, we need three
assumptions that we further discuss below: (1) the presence of a
network attacker who can manipulate the request in which the user
sends her identity to the RP as well as the corresponding response
to this request (see Steps 1 and 2 in Figure 1), (2) an RP which
allows users to log in with identities provided by (some) HIdP and
identities provided by AIdP, and (3) an RP that uses explicit user
intention tracking and issues the same redirection URI to all IdPs.7
We emphasize that we do not assume that the user sends any secret
(such as passwords) over an unencrypted channel.
Assumption (1). It would be unrealistic to assume that a network
attacker can never manipulate Steps 1 and 2 in Figure 1.
First, these messages are sent between the user and the RP, i.e.,
the attacker does not need to intercept server-to-server communica-
tion. He could, e.g., use ARP spooﬁng in a wiﬁ network to mount
the attack.
6Recall the meaning of “user intention tracking” from Section 2.
7Alternatively, the attack would work if the RP issues different
redirection URIs to different IdPs, but treats them as the same URI.
1207attack on OAuth
applicable to OpenID Connect
auth code mode
implicit mode
auth code mode
implicit mode
hybrid mode
307 Redirect Attack
IdP Mix-Up Attack
State Leak Attack
Naïve RP Session Integrity Attack
az + an
az* + an
si
si
az + an
az + an
si
si
az + an
az* + an
si
si
az + an
–
si
si
az + an
az + an**
si
si
az: breaks authorization. an: breaks authentication. si: breaks session integrity. –: not applicable. * if client secrets are not used.
** restriction: if client secrets are used, either authorization or authentication is broken, depending on implementation details.
Figure 2: Overview of attacks on OAuth 2.0 and OpenID Connect.
Browser
RP
Attacker (AIdP)
HIdP
1 POST /start
idp
2 POST /start
attacker
3 Response
Redirect to Attacker /authEP with
client_id(cid:48), redirect_uri, state
4 Response
Redirect to HIdP /authEP with client_id,
redirect_uri, state
5 GET /authEP
client_id, redirect_uri, state
6 Response
7 POST /authEP
username, password
8 Response
Redirect to RP redirect_uri with code,
state
9 GET redirect_uri
code, state
10 POST /tokenEP
code, client_id(cid:48), redirect_uri,
client_secret(cid:48)
Continued attack to break authorization:
11 POST /tokenEP
code, client_id, redirect_uri
12 Response
access_token
13 GET /resource
access_token
14 Response
protected resource
/Browser
/RP
/Attacker (AIdP)
/HIdP
Figure 3: Attack on OAuth 2.0 authorization code mode
Second, the need for HTTPS for these steps is not obvious to
users or RPs, and the use of HTTPS is not suggested by the OAuth
security recommendations, since the user only selects an IdP at this
point; credentials are not transferred.
Third, even if an RP intends to use HTTPS also for the ﬁrst re-
quest (as in our model), it has to protect itself against TLS stripping
by adding the RP domain to a browser preloaded Strict Transport
Security (STS) list [11]. Other mitigations, such as the STS header,
can be circumvented (see [32]), and do not work on the very ﬁrst
connection between the user’s browser and RP. For example, when
a user enters the address of an RP into her browser, browsers by
default try unencrypted connections. It is therefore unrealistic to
assume that all RPs are always protected against TLS stripping.
Our formal analysis presented in Section 5 shows that OAuth can
be operated securely even if no HTTPS is used for the initial request
(given that our ﬁx, presented below, is applied).
Assumption (2). RPs may use different IdPs, some of which might
be malicious, and hence, OAuth should provide security in this
case. Using a technique called dynamic client registration, OAuth
RPs can even allow the ad-hoc use of any IdP, including malicious
ones. This is particularly relevant in OpenID Connect, where this
technique was ﬁrst implemented.
Assumption (3). Typically, RPs that use explicit user intention track-
ing do not register different redirection URIs for different IdPs, as
in this case the RP records the IdP a user wants to authenticate
with. In particular, for RPs that allow for dynamic registration, us-
ing the same URI is an obvious implementation choice. This is for
example the case in the OAuth/OpenID Connect implementations
mod_auth_openidc and pyoidc (see below).
Attack on Authorization Code Mode. We now describe the IdP
Mix-Up attack on the OAuth authorization code mode. As men-
tioned, a very similar attack also applies to the implicit mode. Both
attacks also work if IdP supports just one of these two modes.
The IdP mix-up attack for the authorization code mode is de-
picted in Figure 3. Just as in a regular ﬂow, the attack starts when