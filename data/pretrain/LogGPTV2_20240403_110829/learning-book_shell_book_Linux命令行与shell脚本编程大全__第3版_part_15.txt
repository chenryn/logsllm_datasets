述
显示所有的进程，甚至包括未分配任何终端的进程
Uuaez2igc
显示归userlist列表中某用户ID所有的进程
9FIPTd d
显示PID在pidlist列表中的进程
t ctyliat
显示所关联的终端在ctyIiat列表中的进程
O format
除了默认输出的列之外。还输出由format指定的列
按过去的Linux i386寄存器格式显示
将安全信息添加到输出中
显示任务信息
采用长模式
oformat
仅显示由format指定的列
采用信号格式显示
u
采用基于用户的格式显示
V
采用虚拟内存格式显示
 namellst
宠义在WCHAX列中使用的值
zepzo 0
定义显示信息列的期序
将数值信息从子进程加到父进程上，比如CPU和内存的使用情况
显示真实的命令名称（用以启动进程的程序名称）
显示命令使用的环境变量
f
用分层格式来显示进程，表明哪些进程启动了哪些进程
h
不显示头信息
k sort
指定用以将输出排序的列
和MCHAW信息一起显示出来，用数值来表示用户ID和组ID
为较宽屏幕显示宽输出
H
将线程校进程来显示
在进程后显示线程
L
列出所有格式指定符
V
显示pa命令的版本号
如你所见，Unix和BSD类型的参数有很多重叠的地方。使用其中某种类型参数得到的信息也
同样可以使用另一种获得。大多数情况下，你只要选择自己所喜欢格式的参数类型就行了（比如
你在使用Linux之前就已经习惯BSD环境了）。
在使用BSD参数时，ps命令会自动改变输出以模仿BSD格式。下例是使用1参数的输出：
$ ps 1
FUID
ZSA IN IYd GIdd 0Id
RSS NCHAN STAT TTY
0: 00 -bash
TIME COMMAND
0500 5104 3081 20
0
500 3081 3080
20
04468844 -
04692
1432 vait
R+
Pts/0
pts/0
0:00 ps 1
注意，其中大部分的输出列跟使用Unix风格参数时的输出是一样的，只有一小部分不同。
---
## Page 84
4.1监测程序
69
口VSZ：进程在内存中的大小，以千字节（KB）为单位。
口RSS：进程在未换出时占用的物理内存。
口STAT：代表当前进程状态的双字符状态码。
许多系统管理员都喜欢BSD风格的1参数。它能输出更详细的进程状态码（STAT列）。双字
符状态码能比Unix风格输出的单字符状态码更清楚地表示进程的当前状态。
第一个字符采用了和Unix风格s列相同的值，表明进程是在休眠、运行还是等待。第二个参
数进一步说明进程的状态。
：该进程运行在高优先级上。
N：该进程运行在低优先级上。
口L：该进程有页面锁定在内存中。
口s：该进程是控制进程。
口1：该进程是多线程的。
：该进程运行在前台。
从前面的例子可以看出，bash命令处于休眠状态，但同时它也是一个控制进程（在我的会
话中，它是主要进程），而ps命令则运行在系统的前台。
3.GNU长参数
最后，GNU开发人员在这个新改进过的ps命令中加人了另外一些参数。其中一些GNU长参数
复制了现有的Unix或BSD类型的参数，而另一些则提供了新功能。表4-3列出了现有的GNU长参数。
表4-3GNU风格的ps命令参数
参数
描
deselect
显示所有进程，命令行中列出的进程
-Gxoup gzpIfat
显示组ID在grplist列表中的进程
--User userlfst
显示用户ID在uaerliac列表中的进程
1e7rdz6 dno.x6-
显示有效组ID在grplist列表中的进程
-pid pidlist
显示PID在pid2isc列表中的进程
-ppid pidliat
显示父PID在pi42iac列表中的进程
--81d aidllac
显示会话ID在sidlist列表中的进程
显示终端设备号在tty2iac列表中的进程
-user userIlat
显示有效用户D在uaarliac列表中的进程
--forrat foznat
仅显示由fozmac指定的列
-context
显示额外的安全信息
-=co1α 
将屏幕宽度设置为列
-colunns n
将屏幕宽度设置为列
-=cumulative
包含已停止的子进程的信息
--forest
用层级结构显示出进程和父进程之间的关系
--headers
在每页输出中都显示列的头
g.repeeu-ou-
不显示列的头
---
## Page 85
70
第4章更多的bash shell命令
(续）
参数
描
--1ines n
将屏募高度设为n行
--row8
将屏募高度设为n排
--sort. order
指定将输出按列排序
-vidth 
将屏募宽度设为=列
-he1p
显示帮助信息
--in.fo
显示调试信息
-vexsion
显示ps命令的版本号
可以将GNU长参数和Unix或BSD风格的参数混用来定制输出。GNU长参数中一个着实让人
喜爱的功能就是--forest参数。它会显示进程的层级信息，并用ASCII字符绘出可爱的图表。
19817
00:00:00 sshd
30787
00 :00 : 00
3080?
00 : 00 : 00
_ Bshd
3081 pts/0
00 :00 : 00
_ rshd
16676 pts/0
^_ bash
00 : 00 : 00
_ D5
这种格式让跟踪子进程和父进程变得十分容易。
4.1.2实时监测进程
ps命令虽然在收集运行在系统上的进程信息时非常有用，但也有不足之处：它只能显示
某个特定时间点的信息。如果想观察那些频繁换进换出的内存的进程趋势，用ps命令就不方
便了。
而top命令刚好适用这种情况。top命令跟ps命令相似，能够显示进程信息，但它是实时显
示的。图4-1是top命令运行时输出的截图。
输出的第一部分显示的是系统的概况：第一行显示了当前时间、系统的运行时间、登录的用
户数以及系统的平均负载。
平均负载有3个值：最近1分钟的、最近5分钟的和最近15分钟的平均负载。值越大说明系统
的负载越高。由于进程短期的突发性活动，出现最近1分钟的高负载值也很常见，但如果近15分
钟内的平均负载都很高，就说明系统可能有问题。
说明Limux系统管理的要点在于定义究竞到什么程度才算是高负载。这个值取决于系统的硬件
配置以及系统上通常运行的程序。对某个系统采说是高负载的值可能对另一系统来说就
是正常值。通常，如果系统的负载值超过了2，就说明系统比较繁忙了。
第二行显示了进程概要信息—top命令的输出中将进程叫作任务（task）：有多少进程处在
运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）
---
## Page 86
4.1监测程序
71
 4  404% @ 10 0
.
8.0%5
PIF
5
 42368 338 120 5
113
r00
11
root
00.0
0:00_09 events/b
图4-1top命令运行时的输出
下一行显示了CPU的概要信息。top根据进程的属主（用户还是系统）和进程的状态（运行、
空闲还是等待）将CPU利用率分成几类输出。
紧跟其后的两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存，
当前用了多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间（如果分配
了的话）的状态而言的。
最后一部分显示了当前运行中的进程的详细列表，有些列跟ps命令的输出类似。
PID：进程的ID
口USER：进程属主的名字。
口PR：进程的优先级。
NI：进程的谦让度值。
口VIRT：进程占用的虚拟内存总量。
口RES：进程占用的物理内存总量。
口SHR：进程和其他进程共享的内存总量。
口S：进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表
跟踪状态或停止状态，Z代表僵化状态）。
口%CPU：进程使用的CPU时间比例。
口%MEM：进程使用的内存占可用内存的比例。
---
## Page 87
72
第4章更多的bash shell命令
口TIME+：自进程启动到目前为止的CPU时间总量。
口COMMAND：进程所对应的命令行名称，也就是启动的程序名。
默认情况下，top命令在启动时会按照sCPu值对进程排序。可以在top运行时使用多种交互
命令重新排序。每个交互式命令都是单字符，在top命令运行时键人可改变top的行为。键人f允
许你选择对输出进行排序的字段，键人d允许你修改轮询间隔。键人q可以退出top。用户在top
命令的输出上有很大的控制权。用这个工具就能经常找出占用系统大部分资源的罪魁祸首。当然
了，一旦找到，下一步就是结束这些进程。这也正是接下来的话题。
4.1.3结束进程
作为系统管理员，很重要的一个技能就是知道何时以及如何结束一个进程。有时进程挂起了，
只需要动动手让进程重新运行或结束就行了。但有时，有的进程会耗尽CPU且不释放资源。在这
两种情景下，你就需要能控制进程的命令。Linux沿用了Unix进行进程间通信的方法。
在Linux中，进程之间通过信号来通信。进程的信号就是预定义好的一个消息，进程能识别
它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。大多数编写完
善的程序都能接收和处理标准Unix进程信号。这些信号都列在了表4-4中。
表4-4Linux进程信号
信号
名称
描述
1
HUP
挂起
2
INT
中断
QUTT
结束运行
9
KILL
无条件终止
11
SEGV
段错误
1.5
TERX
尽可能终止
17
STOP
无条件停止运行，但不终止
1.8
TSTP
停止或暂停，但继续在后台运行
19
coBT
在STOP成TSTP之后恢复执行
在Linux上有两个命令可以向运行中的进程发出进程信号。
1.ki11命令
ki11命令可通过进程ID（PID）给进程发信号。默认情况下，ki11命令会向命令行中列出的
全部PID发送一个TERM信号。遗憾的是，你只能用进程的PID而不能用命令名，所以ki11命令有
时并不好用。
要发送进程信号，你必须是进程的属主或登录为root用户。
$ki11 3940
bash: ki11: (3940) - Operation not permitted
TERM信号告诉进程可能的话就停止运行。不过，如果有不服管教的进程，那它通常会忽略
---
## Page 88
4.2监测磁盘空间
这个请求。如果要强制终止，-s参数支持指定其他信号（用信号名或信号值）。
你能从下例中看出，kil1命令不会有任何输出。
06E H B-T #
要检查kil1命令是否有效，可再运行ps或top命令，看看问题进程是否已停止。
2.killal1命令
killal1命令非常强大，它支持通过进程名而不是PID来结束进程。ki1la11命令也支持通
配符，这在系统因负载过大而变得很慢时很有用。
ki1lall http*
上例中的命令结束了所有以http开头的进程，比如Apache Web服务器的httpd服务。
警告以root用户身份登录系统时，使用ki1lal1命令要特别小心，因为很容易就会误用通配符
而结束了重要的系统进程。这可能会破坏文件系统
4.2监测磁盘空间
系统管理员的另一个重要任务就是监测系统磁盘的使用情况。不管运行的是简单的Linux台
式机还是大型的Linux服务器，你都要知道还有多少空间可留给你的应用程序。
在Linux系统上有几个命令行命令可以用来帮助管理存储媒体。本节将介绍在日常系统管理
中经常用到的核心命令。
4.2.1挂载存储媒体