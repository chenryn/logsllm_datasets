title:MCI : Modeling-based Causality Inference in Audit Logging for Attack
Investigation
author:Yonghwi Kwon and
Fei Wang and
Weihang Wang and
Kyu Hyung Lee and
Wen-Chuan Lee and
Shiqing Ma and
Xiangyu Zhang and
Dongyan Xu and
Somesh Jha and
Gabriela F. Ciocarlie and
Ashish Gehani and
Vinod Yegneswaran
MCI: Modeling-based Causality Inference in Audit
Logging for Attack Investigation
Yonghwi Kwon1, Fei Wang1, Weihang Wang1, Kyu Hyung Lee2, Wen-Chuan Lee1, Shiqing Ma1, Xiangyu Zhang1,
Dongyan Xu1, Somesh Jha3, Gabriela Ciocarlie4, Ashish Gehani4, and Vinod Yegneswaran4
1Department of Computer Science, Purdue University
{kwon58, feiwang, wang1315, lee1938, ma229, xyzhang, dxu}@cs.purdue.edu
2Department of Computer Science, University of Georgia
3Department of Computer Sciences, University of Wisconsin-Madison
PI:EMAIL
PI:EMAIL
4SRI International
{gabriela, gehani, vinod}@csl.sri.com
Abstract—In this paper, we develop a model based causality
inference technique for audit logging that does not require any
application instrumentation or kernel modiﬁcation. It leverages
a recent dynamic analysis, dual execution (LDX), that can infer
precise causality between system calls but unfortunately requires
doubling the resource consumption such as CPU time and mem-
ory consumption. For each application, we use LDX to acquire
precise causal models for a set of primitive operations. Each
model is a sequence of system calls that have inter-dependences,
some of them caused by memory operations and hence implicit at
the system call level. These models are described by a language
that supports various complexity such as regular, context-free,
and even context-sensitive. In production run, a novel parser
is deployed to parse audit logs (without any enhancement) to
model instances and hence derive causality. Our evaluation on
a set of real-world programs shows that the technique is highly
effective. The generated models can recover causality with 0%
false-positives (FP) and false-negatives (FN) for most programs
and only 8.3% FP and 5.2% FN in the worst cases. The models
also feature excellent composibility, meaning that the models
derived from primitive operations can be composed together to
describe causality for large and complex real world missions.
Applying our technique to attack investigation shows that the
system-wide attack causal graphs are highly precise and concise,
having better quality than the state-of-the-art.
I.
INTRODUCTION
Cyber-attacks are becoming increasingly targeted and so-
phisticated [2]. A special kind of these attacks, called Ad-
vanced Persistent Threat (APT), can inﬁltrate into target sys-
tems in stages and reside inert for a long time to remain
undetected. It
to trace back attack steps and
understand how an attack unfolds [4]. In the mean time,
identifying the entry point of the attack and understanding
the damage to the victim can be critical to recovering the
victim system from the intrusion and also preventing future
is important
Network and Distributed Systems Security (NDSS) Symposium 2018
18-21 February 2018, San Diego, CA, USA
ISBN 1-1891562-49-5
http://dx.doi.org/10.14722/ndss.2018.23xxx
www.ndss-symposium.org
compromises.
Causality analysis techniques [25], [16], [24], [26], [29]
are widely used in attack investigation. They analyze audit
logs generated by operating system level audit logging tools
(e.g., Linux Audit [17], Event Tracing for Windows [38], and
DTrace [13]) and correlate system events, e.g., system calls
(syscalls) to identify causal relations between system subjects
(e.g., processes) and system objects (e.g., ﬁles, network sock-
ets). Such capability is particularly important in cyber-attack
investigation where causality of malicious events reveals attack
provenance. For example, when an attacker exploits vulnerabil-
ities and executes malicious payloads, causality analysis can
identify such vulnerable interfaces including input channels
that accept malicious inputs from the user or the network.
Moreover, given a set of malicious or suspicious events, it can
identify all the events that are causally related to the given
set of events. Essentially, these events depict the source of the
attack and/or the damage induced by the attacker. However,
syscall based analysis has a major limitation: dependence ex-
plosion [32]. For a long-running process, an output event (e.g.,
creating a malicious ﬁle) is assumed to be causally related
to all the preceding input events (e.g., ﬁle read and network
receive). This conservative assumption causes signiﬁcant false
causal relations.
Some recent works [32], [37], [35], [36] focus on collecting
enhanced information at run-time to avoid dependence explo-
sion and enable accurate attack investigation. For instance,
BEEP [32] and ProTracer [37] train and instrument
long-
running applications to capture information of ﬁne-grained
execution units in addition to syscalls. MPI [36] asks the
user to annotate important data structures in applications’
source code to enable semantic aware execution partitioning.
Additionally, Bates at el. [6] propose a general provenance-
aware framework called Linux Provenance Module (LPM) that
allows users to deﬁne custom provenance rules. The major
hindrance of these techniques in practice is their requirements
of changing end-user systems, such as instrumenting user
applications, installing new runtime support, kernel modules,
and even changing the kernel itself.
Taint analysis [22], [21], [20] is another approach that can
track causal relations (e.g., information ﬂow) between system
components (e.g., memory objects, ﬁles, and network sockets).
However, whole system tainting is too computationally expen-
sive (over 3x slow down [19], [39]) to be deployed on pro-
duction systems. Additionally most taint analysis techniques
cannot handle implicit ﬂow, resulting in false-negatives.
In this paper, we propose MCI, a novel causality inference
technique on audit logs. Our technique does not require any
changes on the end-user system, nor any special operations
during system execution. The end-user only needs to turn
on the audit logger shipped with the operating system (e.g.,
Linux Audit, Event Tracing for Windows, and DTrace). If the
user detects a security incident, she only needs to provide the
syscall log and program binaries from the victim system (or a
disk image) to a forensic expert.
In off-line attack investigation, which is often done by the
forensic expert, MCI precisely infers causality from a given
system call log by constructing causal models and parsing the
log with the models. Fig. 1 shows a high level overview of how
MCI works. MCI consists of two phases: (1) causality anno-
tated model generation, and (2) model parsing. First, MCI gen-
erates causal models by leveraging LDX [31] which is a dual-
execution based system that can infer causality by mutating
input syscalls and then observing output changes. In this phase,
MCI takes two inputs: a program binary and typical workloads.
MCI’s model constructor automatically runs LDX and analyzes
its results to construct models. Models are expressive and
capable of representing ﬁne-grained dependencies including
invisible at the syscall level (e.g., dependencies induced by
memory operations). The models can be pre-generated (for
widely used applications) or generated on demand after an
incident. Second, during investigation MCI identiﬁes causal
relations between events in a given syscall log collected from a
victim system by parsing the log with the models. The derived
precise dependencies are critical for attack investigation. In
summary, we make the following contributions:
• We propose a novel technique for precise causality
inference that directly works on audit logs without
requiring any changes or setup on end-user systems.
We only require program binaries and the audit log
from the victim system after the incident.
• We perform a comparative study using a real-world
example to illustrate the merits and limitations of
existing approaches.
• We propose to leverage LDX [31] to identify ﬁne-
grained causality from program execution. Using the
generated causality information, we construct causal
models annotated with ﬁne-grained dependencies. We
study the model complexity needed to describe causal-
ities in audit logging.
• We develop a novel model parsing algorithm that
can handle multiple model complexity levels and
substantially mitigate the ambiguity problem inherent
in model based parsing.
• We perform thorough evaluation of MCI on a set
of real-world applications. The results show that the
generated models can recover causality with close
to 0% FP and FN for most applications and the
worst FP rate 8.3% and the worst FN rate 5.2%.
Model construction and model parsing have reason-
able overhead and scale to week-long and even month-
long workloads. Applying MCI to attack investigation
shows that our models have very nice composibility
such that small models can be composed together to
describe complex system-wide attack behaviors. Our
attack causal graphs are even more precise than those
generated by a state-of-the-art system [32].
II. BACKGROUND AND MOTIVATION
In this section, we use an insider information leak attack
case to illustrate the limitations of existing attack provenance
analysis techniques, and then to motivate our work.
A. Motivating Example
We use a data exﬁltration of conﬁdential company data by
an employee. Insider attacks are the dominant reason for data
breach incidents in 2016 [1], [18].
Assume John is a project manager who has access to
conﬁdential data. John was bribed by a competitor company
and attempts to breach some conﬁdential data. However,
John’s company forbids copying data to removable media
such as USB stick. Furthermore, the company inspects all
incoming/outgoing network trafﬁc via deep packet inspection
(DPI) [30], [44], [45] to prevent exﬁltration of conﬁdential data
and to block malicious network trafﬁc from outside. To bypass
the packet inspection, John decides to use the GPG encryption
algorithm [27] to encrypt data before sending it.
GnuPG Vim plug-in. To use GPG encryption, John installed
a Vim plug-in GnuPG [7], which enables transparent editing
of gpg encrypted ﬁles. When he opens a ﬁle encrypted by
gpg [27] which is an encryption utility supported by most
operating systems with the GNU library (e.g., Linux, FreeBSD,
and MacOS), the GnuPG plug-in automatically decrypts and
passes the decrypted data to Vim so that the user can edit
the contents of the encrypted ﬁle. The plug-in automatically
encrypts the contents when the user saves the gpg ﬁle.
Attack Scenario. John uses Vim equipped with the GnuPG
plug-in to open three conﬁdential ﬁles, data1, data2, and
data3. He also opens out.gpg in order to store conﬁdential
data in an encrypted format. Then he copies a few lines from
data2 using the Vim command ‘v’ to select characters and
‘y’ to copy them to the clipboard buffer (i.e., Vim’s default
register). Then he ﬁnds out the information in data3 is more
up-to-date. He thus copies lines from data3 that overwrite
the contents from data2. Later, he pastes the copied lines to
out.gpg, saves the ﬁle in an encrypted format and terminates
Vim. Note that, when he saves out.gpg, the GnuPG plug-in
actually creates a new ﬁle (inode:8) and renames it to out.gpg
so that the original out.gpg ﬁle (inode:4) is replaced by a new
ﬁle (inode:8). Observe that the inode numbers of the original
out.gpg ﬁle and the new ﬁle are different. Finally, he sends the
encrypted out.gpg to a server outside the enterprise network.
This data breach incident is later detected, and a forensic
analysis team starts to investigate the incident. Now, we
introduce existing causal analysis based forensic techniques
and discuss how they work on this attack.
B. Existing Approaches and Limitations
System Call based Analysis. Most causal analysis techniques
use syscall logging tools to record important system events at
2
Fig. 1. Overview of MCI’s off-line causality inference. Audit Logs and Program Binaries are provided from the end-user, workloads and input speciﬁcations
are generated by an attack investigator (e.g., a forensic expert), and other components are automatically generated by MCI.
Fig. 2. Motivating Example: Insider theft breaches conﬁdential data using VIM and gpg
runtime and then analyze recorded events to identify causal
relations between system subjects (e.g., process) and system
objects (e.g., ﬁle or network socket). Syscall logging tools are
shipped with most operating systems. For example, Linux Au-
dit [17] is a default package in Linux and MacOS distributions,
DTrace [13] is available in FreeBSD, and Event Tracing for
Windows (ETW) [38] comes with Windows.
.
Syscall based analysis has been studied in a number
of works [25], [16], [24], [26], [29]. For instance, Back-
Tracker [25] and Taser [16] propose backward and forward
analysis techniques in order to analyze syscall logs and con-
struct causal graphs for effective attack investigation. The
constructed causal graphs show system subjects and objects
that involved in attacks, and their causal relations.
Fig. 2-(a) shows a provenance graph generated from the
syscall log collected during the data breach incident discussed
in the previous section. To understand the incident in detail, a
security analyst ﬁrst identiﬁes the out.gpg ﬁle (inode:8) which
contains conﬁdential data. Then the analyst ﬁnds the system
components that are causally related to the ﬁle from the graph
in the backward direction (time-wise). Observe that it was Vim
that wrote the ﬁle ( 1111 ). Before that, Vim read /tmp/tmpﬁle ( 1010
10
) which was written by “gpg” ( 99 ). The “gpg” process (pid:2)
was forked by Vim ( 88 ). Before the fork, Vim read /tmp/tmpﬁle
( 77 ) which was written by another “gpg” process (pid:1) ( 66 ).
7
“Gpg” previously read the original out.gpg ﬁle with a different
inode number (inode:4) ( 55 ) and the “gpg” process (pid:1) was
forked by Vim ( 44 ) as well. There are also other ﬁles that Vim
read, including data3 ( 33 ), data2 ( 22 ), and data1 ( 11 ).
11
8
5
4
3
2
9
6
1
Note that Fig. 2-(a) contains many false dependencies such
as dependencies between the Vim process and ﬁles data1,
data2, and /tmp/.X11-unix which is a socket for XWindow. The
coarse-granularity of processes leads to this false dependency
problem as it simply considers an output event is dependent
on all the preceding input events in the process.
Execution Unit based Analysis. False dependencies in syscall
based analysis are a major obstacle for attack investigation as
it often causes the dependency explosion problem [32], which
is a problem of having an excessive number of dependencies,
with most of them being bogus. It makes investigation chal-
lenging, often leading to wrong conclusions. To address the
3
problem, BEEP [32] and ProTracer [37] propose to divide a
long-running process to autonomous execution units. In this
way, an output event is only dependent on the preceding input
events within the same execution unit. BEEP and ProTracer
also detect
inter-unit dependencies introduced via memory
objects. ProTracer is a variant of BEEP that can signiﬁcantly
reduce runtime and space overhead while the effectiveness of
attack analysis remains the same because they share the same
mechanism to partition a long process.
Unfortunately, BEEP and ProTracer require complex binary
program analysis in order to instrument a target application
for execution partitioning at runtime. To detect the inter-unit
dependencies,
they need to identify memory dependencies
across units by analyzing training runs, and instrument the
target program to monitor the relevant memory accesses in
production runs. Note that identifying all relevant memory
accesses that induce dependencies across execution units in
complex binary programs via training is challenging. Missing
memory accesses in training leads to false-negatives in attack
investigation. They also generate a large number of additional
syscalls to denote unit boundaries and memory accesses,
increasing the storage pressure.