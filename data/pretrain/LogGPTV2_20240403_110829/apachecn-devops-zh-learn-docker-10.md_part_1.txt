# 十、Docker Swarm 简介
在最后一章，我们介绍了编排器。就像编排器中的指挥一样，编排器确保我们所有的容器化应用服务能够很好地协同工作，并和谐地为一个共同的目标做出贡献。这样的编排器有相当多的职责，我们已经详细讨论过了。最后，我们简要概述了市场上最重要的容器编排器。
本章介绍 Docker 的原生管弦乐手 **SwarmKit** 。它详细阐述了 SwarmKit 用来在本地集群或云中部署和运行分布式、弹性、健壮和高可用性应用的所有概念和对象。本章还介绍了如何通过使用**软件定义的网络** ( **SDN** )来隔离容器，从而确保应用的安全性。此外，本章还演示了如何在云中安装高可用性的 Docker Swarm。它引入了提供第 4 层路由和负载平衡的路由网格。最后，它演示了如何将由多个服务组成的第一个应用部署到群中。
这些是我们将在本章中讨论的主题:
*   体系结构
*   群集节点
*   栈、服务和任务
*   多主机联网
*   创建 DockerSwarm
*   部署第一个应用
*   群体路由网格
完成本章后，您将能够:
*   在白板上勾画高度可用的 Docker Swarm 的基本部分
*   用两三句简单的话向感兴趣的外行解释什么是(群体)服务
*   在 AWS 中创建一个高可用性的 Docker Swarm，它由三个管理节点和两个工作节点组成
*   在 Docker Swarm 上成功部署了一个复制服务，如 Nginx
*   向上和向下扩展正在运行的 Docker Swarm 服务
*   检索复制的 Docker Swarm 服务的聚合日志
*   为至少包含两个交互服务的示例应用编写一个简单的栈文件
*   将栈部署到 DockerSwarm 中
# 体系结构
从 30，000 英尺的视角来看，Docker Swarm 的架构由两个主要部分组成——奇数个管理节点组成的 raft 共识组，以及通过八卦网络(也称为**控制平面**)相互通信的一组工作节点。下图说明了这种体系结构:
![](img/c2a66570-80ca-477a-b040-d3e918b8a77a.jpg)
High-level architecture of a Docker Swarm
管理节点管理群，而工作节点执行部署到群中的应用。每个经理都有一份完整的本地筏式商店的蜂群状态副本。经理们以同步的方式相互交流，筏式商店总是同步的。
另一方面，出于可伸缩性的原因，工作人员彼此异步通信。一个群中可能有数百个(如果不是数千个)工作节点。现在我们已经对什么是 DockerSwarm 有了一个高层次的概述，让我们更详细地描述 DockerSwarm 的所有单个元素。
# 群集节点
群是节点的集合。我们可以将节点分类为物理计算机或**虚拟机** ( **虚拟机**)。如今，物理计算机通常被称为*裸机*。人们说*我们在裸机上运行*以区别于在虚拟机上运行。
当我们在这样一个节点上安装 Docker 时，我们称这个节点为 **Docker 主机**。下图更好地说明了什么是节点，什么是 Docker 主机:
![](img/0b263d61-afcd-4c62-8f27-7ae741b679f1.jpg)
Bare metal and VM type Docker Swarm nodes
要成为 Docker Swarm 的成员，节点还必须是 Docker 主机。Docker Swarm 中的节点可以有两种角色之一。可以是经理，也可以是工人。管理器节点顾名思义；他们管理蜂群。工作节点依次执行应用工作负载。
从技术上讲，管理器节点也可以是工作节点，因此可以运行应用工作负载，尽管不建议这样做，尤其是当群是运行任务关键型应用的生产系统时。
# 群体经理
每个 Docker Swarm 需要至少有一个管理器节点。出于高可用性的原因，群集中应该有多个管理器节点。对于生产或类似生产的环境尤其如此。如果我们有多个管理器节点，那么这些节点使用 **Raft 共识协议**一起工作。Raft 共识协议是一种标准协议，当多个实体需要一起工作并且总是需要就下一步执行哪个活动达成一致时，通常会使用该协议。
为了更好地工作，Raft 共识协议要求在所谓的**共识组**中有奇数个成员。因此，我们应该总是有 1、3、5、7 等管理器节点。在这样一个共识团体中，总有一个领导者。在 Docker Swarm 的情况下，启动群的第一个节点最初会成为领导者。如果领导者离开了，那么剩下的管理者节点会选出一个新的领导者。共识组中的其他节点称为**追随者**。
现在假设我们出于维护原因关闭了当前的 leader 节点。剩余的经理节点将选举新的领导。当前一个领导者节点重新上线时，他现在将成为一个追随者。新领导人仍然是领导人。
共识小组的所有成员以同步的方式相互交流。每当共识小组需要做出决定时，领导者会要求所有追随者达成一致。如果大多数管理者节点给出肯定的答案，那么领导者执行任务。这意味着，如果我们有三个经理节点，那么至少有一个追随者必须同意领导者的意见。如果我们有五个经理节点，那么至少有两个追随者必须同意。
由于所有的管理者追随者节点都必须与领导者节点同步通信才能在集群中做出决策，因此决策过程越慢，我们形成共识组的管理者节点就越多。Docker 的建议是为开发、演示或测试环境使用一个管理器。在小型到中型集群中使用三个管理器节点，在大型到特大型集群中使用五个管理器。在一群人中使用五个以上的经理几乎是不合理的。
管理节点不仅负责管理群，还负责维护群的状态。我们这样说是什么意思？当我们谈论群的状态时，我们指的是关于它的所有信息——例如，*群中有多少个节点*，*每个节点的属性是什么，例如名称或 IP 地址*。我们还指的是什么容器在群中的哪个节点上运行等等。另一方面，群的状态中不包括的是在群的容器中运行的应用服务产生的数据。这称为应用数据，绝对不是由管理器节点管理的状态的一部分:
![](img/73be23c2-11d0-43d2-ae6c-4f197cfd3c90.jpg)
A swarm manager consensus group
所有群状态都存储在每个管理器节点上的高性能键值存储( **kv-store** )中。没错，每个管理器节点都存储了整个群状态的完整副本。这种冗余使得群体高度可用。如果一个管理器节点关闭，剩余的管理器都具有手边的完整状态。
如果一个新的管理器加入了共识组，那么它会将群状态与该组的现有成员同步，直到有一个完整的副本。这种复制在典型的集群中通常非常快，但是如果集群很大并且许多应用正在其上运行，则可能需要一段时间。
# 成群的工人
正如我们前面提到的，一个群工作节点意味着托管和运行包含我们感兴趣的在集群上运行的实际应用服务的容器。他们是群体中的主力。理论上，管理节点也可以是工作者。但是，正如我们已经说过的，不建议在生产系统上这样做。在生产系统中，我们应该让经理成为经理。
工作节点通过所谓的控制平面相互通信。他们使用八卦协议进行交流。这种通信是异步的，这意味着在任何给定的时间，不是所有的工作节点都必须完全同步。
现在您可能会问— *工作节点交换什么信息？*主要是服务发现和路由所需的信息，即关于哪些容器与节点一起运行的信息，等等:
![](img/bdd9d4b3-e8a3-443a-88eb-d4f8453b4426.jpg)
Worker nodes communicating with each other
在上图中，您可以看到工作人员如何相互交流。为了确保八卦在一个大群中能够很好地扩展，每个工作节点只与三个随机邻居同步自己的状态。对于那些熟悉大 0 符号的人来说，这意味着使用流言协议的工作节点的同步随着 O(0)而扩展。
工作者节点有点被动。除了运行管理节点分配给他们的工作负载，他们从不主动做其他事情。但是，工作人员确保尽最大能力运行这些工作负载。在本章的后面，我们将更详细地了解管理器节点具体分配给工作节点的工作负载。
# 栈、服务和任务
当使用 Docker Swarm 相对于单个 Docker 主机时，会有一个范例变化。我们不再谈论运行流程的单个容器，而是抽象出代表每个流程的一组副本的服务，并使之变得高度可用。我们也不再谈论我们部署容器的具有众所周知的名称和 IP 地址的单个 Docker 主机；我们现在指的是我们部署服务的主机集群。我们不再关心单个主机或节点。我们没有给它取一个有意义的名字；每个节点对我们来说都是一个数字。我们也不再关心单个容器以及它们部署在哪里——我们只关心通过服务定义一个期望的状态。我们可以尝试描述如下图所示:
![](img/c3443ada-554a-4713-986c-94003c532631.jpg)
Containers are deployed to well known servers
我们将容器 **web** 部署到带有 IP 地址`52.120.12.1`的服务器 **alpha** ，将容器**支付**部署到带有 IP 地址`52.121.24.33`的服务器 **beta** ，而不是将单个容器部署到像前面这样众所周知的服务器，而是切换到这种新的服务和集群范式(或者更一般地说，集群):
![](img/a0dd4272-f222-4e65-aa19-3580c5f1c261.jpg)
Services are deployed to swarms
在上图中，我们看到一个服务 **web** 和一个服务**库存**都被部署到由许多节点组成的集群中。每个服务都有一定数量的副本；六个用于网络，五个用于库存。我们并不真正关心副本将在哪个节点上运行，我们只关心请求数量的副本总是在群调度器决定将它们放在的任何节点上运行。
# 服务
群服务是一个抽象的东西。它是对我们希望在集群中运行的应用或应用服务的期望状态的描述。swarm 服务就像一个清单，描述了这样的事情:
*   服务名称
*   从中创建容器的映像
*   要运行的副本数量
*   服务容器所连接的网络
*   应该映射的端口
然后，让这个服务显示群管理器，确保所描述的期望状态总是一致的，如果实际状态偏离它的话。因此，例如，如果服务的一个实例崩溃，那么群管理器上的调度器在具有空闲资源的节点上调度服务的新实例，以便重新建立期望的状态。
# 工作
我们已经了解到，服务对应于应用服务应该一直处于的期望状态的描述。描述的一部分是服务应该运行的副本数量。每个副本由一个任务表示。就这一点而言，swarm 服务包含一组任务。在 Docker Swarm 上，任务是部署的原子单元。服务的每个任务都由群调度器部署到工作节点。该任务包含工作节点运行基于映像的容器所需的所有必要信息，这是服务描述的一部分。任务和容器之间是一对一的关系。容器是在工作节点上运行的实例，而任务是作为群服务的一部分的这个容器的描述。
# 堆
既然我们已经很好地了解了什么是群服务，什么是任务，我们就可以引入栈了。栈用于描述相关的群服务的集合，很可能是因为它们是同一个应用的一部分。从这个意义上说，我们也可以说栈描述了一个应用，它由一个到多个服务组成，我们希望在集群上运行这些服务。
通常，我们在使用 YAML 格式化的文本文件中声明性地描述栈，该文件使用与已知的 Docker 编写文件相同的语法。这就导致了人们有时会说栈是由`docker-compose`文件描述的情况。一个更好的措辞应该是——一个栈被描述在一个栈文件中，该文件使用类似于`docker-compose`文件的语法。
让我们尝试在下图中说明栈、服务和任务之间的关系，并将其与栈文件的典型内容联系起来:
![](img/6c214183-17ed-4ba1-a6de-e8daafed8815.jpg)
Diagram showing the relationship between stack, services and tasks
在上图中，我们在右侧看到了示例栈的声明性描述。这个栈由三个服务组成，分别是**网络**、**支付**和**库存**。我们还看到服务 **web** 使用了映像**示例/web:1.0** 并且有四个副本。
在图的左侧，我们看到栈包含了提到的三个服务。每个服务又包含一组任务，和副本一样多。在服务 **web** 的情况下，我们有四个任务的集合。每个任务都包含映像的名称，一旦任务在群节点上被调度，它将从映像实例化一个容器。
# 多主机联网
在第 7 章、*单主机网络、*中，我们讨论了容器如何在单个 Docker 主机上通信。现在，我们有一个由一群节点或 Docker 主机组成的集群。位于不同节点上的容器需要能够相互通信。有许多技术可以帮助人们实现这个目标。Docker 已选择为 Docker Swarm 实现覆盖网络驱动程序。这个覆盖网络允许连接到同一个**覆盖网络**的容器彼此发现并自由地相互通信。以下是覆盖网络的工作模式:
![](img/359cfc09-901a-44df-8f62-491fc03bdf96.jpg)
Overlay network
我们有两个节点或 Docker 主机，其 IP 地址为`172.10.0.15`和`172.10.0.16`。我们为 IP 地址选择的值并不重要；重要的是，两台主机都有一个不同的 IP 地址，并通过一个物理网络(网络电缆)连接，该网络称为底层网络。
在左侧的节点上，我们有一个使用 IP 地址`10.3.0.2`运行的容器，在右侧的节点上有另一个使用 IP 地址`10.3.0.5`的容器。现在，前一个容器想要与后一个容器通信。*这怎么可能发生？*在[第 7 章](07.html)、*单主机联网、*中，我们看到了当两个容器位于同一个节点上时，这是如何工作的；通过使用 Linux 桥。但是 Linux 桥只在本地运行，不能跨节点。所以，我们需要另一种机制。Linux VXLAN 来拯救。自从容器出现之前，VXLAN 就已经出现在 Linux 上了。
当左侧容器发送数据包时，网桥意识到数据包的目标不在该主机上。现在，参与覆盖网络的每个节点都获得一个所谓的 **VXLAN 隧道端点** ( **VTEP** )对象，该对象拦截数据包(此时的数据包是 OSI 第 2 层数据包)，用包含运行目标容器的主机的目标 IP 地址的报头包裹它(这使它现在成为 OSI 第 3 层数据包)，并通过 VXLAN 隧道发送它。隧道另一端的 VTEP 将数据包解包并转发给本地网桥，网桥再将数据包转发给目标容器。
叠加驱动程序包含在 SwarmKit 中，并且在大多数情况下是 Docker Swarm 推荐的网络驱动程序。第三方还有其他支持多节点的网络驱动程序，可以作为插件安装到每个参与的 Docker 主机上。经认证的网络插件可从 Docker 商店获得。
# 创建 DockerSwarm
创建一个 Docker Swarm 几乎是微不足道的。这太容易了，如果一个人知道编排器是怎么回事，那就显得不真实了。但这是真的，Docker 在使群集简单而优雅地使用方面做得非常出色。同时，Docker Swarm 已被大型企业证明非常健壮且可扩展。