# 自增锁的优化可以看到，自增 id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在MySQL 5.1 版本之前，并不是这样的。接下来，我会先给你介绍下自增锁设计的历史，这样有助于你分析接下来的一个问题。在 MySQL 5.0版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。MySQL 5.1.22 版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值是 1。1.  这个参数的值被设置为 0 时，表示采用之前 MySQL 5.0    版本的策略，即语句执行结束后才释放锁；2.  这个参数的值被设置为 1 时：    -   普通 insert 语句，自增锁在申请之后就马上释放；    -   类似 insert ... select        这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；3.  这个参数的值被设置为 2    时，所有的申请自增主键的动作都是申请后就释放锁。你一定有两个疑问：**为什么默认设置下，insert ... select要使用语句级的锁？为什么这个参数的默认值不是 2？**答案是，这么设计还是为了数据的一致性。我们一起来看一下这个场景：![](Images/24ff4911ebde0fd8153d480d798e6106.png){savepage-src="https://static001.geekbang.org/resource/image/e0/df/e0a69e151277de54a8262657e4ec89df.png"}```{=html}```图 4 批量插入数据的自增锁]{.reference}```{=html}```在这个例子里，我往表 t1 中插入了 4 行数据，然后创建了一个相同结构的表t2，然后两个 session 同时执行向表 t2 中插入数据的操作。你可以设想一下，如果 session B是申请了自增值以后马上就释放自增锁，那么就可能出现这样的情况：-   session B 先插入了两个记录，(1,1,1)、(2,2,2)；-   然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；-   之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。你可能会说，这也没关系吧，毕竟 session B 的语义本身就没有要求表 t2的所有行的数据都跟 session A 相同。是的，从数据逻辑上看是对的。但是，如果我们现在的binlog_format=statement，你可以设想下，binlog 会怎么记录呢？由于两个 session 是同时执行插入数据命令的，所以 binlog 里面对表 t2的更新日志只有两种情况：要么先记 session A 的，要么先记 session B 的。但不论是哪一种，这个 binlog拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的。这时，这个库就发生了数据不一致。你可以分析一下，出现这个问题的原因是什么？其实，这是因为原库 session B 的 insert 语句，生成的 id不连续。这个不连续的 id，用 statement 格式的 binlog来串行执行，是执行不出来的。而要解决这个问题，有两种思路：1.  一种思路是，让原库的批量插入数据语句，固定生成连续的 id    值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。2.  另一种思路是，在 binlog    里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是    innodb_autoinc_lock_mode 设置为 2，同时 binlog_format 设置为 row。因此，**在生产上，尤其是有 insert ... select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode=2，并且 binlog_format=row**.这样做，既能提升并发性，又不会出现数据一致性问题。需要注意的是，我这里说的**批量插入数据，包含的语句类型是 insert ...select、replace ... select 和 load data 语句。**但是，在普通的 insert 语句里面包含多个 value 值的情况下，即使innodb_autoinc_lock_mode 设置为1，也不会等语句执行完成才释放锁。因为这类语句在申请自增 id的时候，是可以精确计算出需要多少个 id的，然后一次性申请，申请完成后锁就可以释放了。也就是说，批量插入数据的语句，之所以需要这么设置，是因为"不知道要预先申请多少个id"。既然预先不知道要申请多少个自增id，那么一种直接的想法就是需要一个时申请一个。但如果一个 select ...insert 语句要插入 10 万行数据，按照这个逻辑的话就要申请 10万次。显然，这种申请自增 id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。因此，对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：1.  语句执行过程中，第一次申请自增 id，会分配 1 个；2.  1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；3.  2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；4.  依此类推，同一个语句去申请自增 id，每次申请到的自增 id    个数都是上一次的两倍。举个例子，我们一起看看下面的这个语句序列：    insert into t values(null, 1,1);insert into t values(null, 2,2);insert into t values(null, 3,3);insert into t values(null, 4,4);create table t2 like t;insert into t2(c,d) select c,d from t;insert into t2 values(null, 5,5);insert...select，实际上往表 t2 中插入了 4行数据。但是，这四行数据是分三次申请的自增 id，第一次申请到了id=1，第二次被分配了 id=2 和 id=3， 第三次被分配到 id=4 到 id=7。由于这条语句实际只用上了 4 个 id，所以 id=5 到 id=7就被浪费掉了。之后，再执行 insert into t2 values(null,5,5)，实际上插入的数据就是（8,5,5)。**这是主键 id 出现自增 id 不连续的第三种原因。**
# 小结今天，我们从"自增主键为什么会出现不连续的值"这个问题开始，首先讨论了自增值的存储。在 MyISAM 引擎里面，自增值是被写在数据文件上的。而在 InnoDB中，自增值是被记录在内存的。MySQL 直到 8.0 版本，才给 InnoDB表的自增值加上了持久化的能力，确保重启前后一个表的自增值不变。然后，我和你分享了在一个语句执行过程中，自增值改变的时机，分析了为什么MySQL 在事务回滚的时候不能回收自增 id。MySQL 5.1.22 版本开始引入的参数innodb_autoinc_lock_mode，控制了自增值申请时的锁范围。从并发性能的角度考虑，我建议你将其设置为2，同时将 binlog_format 设置为row。我在前面的文章中其实多次提到，binlog_format 设置为row，是很有必要的。今天的例子给这个结论多了一个理由。最后，我给你留一个思考题吧。在最后一个例子中，执行 insert into t2(c,d) select c,d from t;这个语句的时候，如果隔离级别是可重复读（repeatableread），binlog_format=statement。这个语句会对表 t 的所有记录和间隙加锁。你觉得为什么需要这么做呢？你可以把你的思考和分析写在评论区，我会在下一篇文章和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。
# 上期问题时间上期的问题是，如果你维护的 MySQL系统里有内存表，怎么避免内存表突然丢数据，然后导致主备同步停止的情况。我们假设的是主库暂时不能修改引擎，那么就把备库的内存表引擎先都改成InnoDB。对于每个内存表，执行    set sql_log_bin=off;alter table tbl_name engine=innodb;这样就能避免备库重启的时候，数据丢失的问题。由于主库重启后，会往 binlog 里面写"delete fromtbl_name"，这个命令传到备库，备库的同名的表数据也会被清空。因此，就不会出现主备同步停止的问题。如果由于主库异常重启，触发了HA，这时候我们之前修改过引擎的备库变成了主库。而原来的主库变成了新备库，在新备库上把所有的内存表（这时候表里没数据）都改成InnoDB 表。所以，如果我们不能直接修改主库上的表引擎，可以配置一个自动巡检的工具，在备库上发现内存表就把引擎改了。同时，跟业务开发同学约定好建表规则，避免创建新的内存表。评论区留言点赞板：> 大家在春节期间还坚持看专栏，并且深入地思考和回复，给大家点赞。\> \@长杰 同学提到的将数据保存到 InnoDB> 表用来持久化，也是一个方法。不过，我还是建议釜底抽薪，直接修改备库的内存表的引擎。\> \@老杨同志> 提到的是主库异常重启的场景，这时候是不会报主备不一致的，因为主库重启的时候写了> delete from tbl_name，主备的内存表都清空了。![](Images/48edcb93fb03e3e52d7e7099be6b5cb3.png){savepage-src="https://static001.geekbang.org/resource/image/09/77/09c1073f99cf71d2fb162a716b5fa577.jpg"}
# 40 \| insert语句的锁为什么这么多？在上一篇文章中，我提到 MySQL 对自增主键锁做了优化，尽量在申请到自增 id以后，就释放自增锁。因此，insert 语句是一个很轻量的操作。不过，这个结论对于"普通的 insert语句"才有效。也就是说，还有些 insert语句是属于"特殊情况"的，在执行过程中需要给其他资源加锁，或者无法在申请到自增id 以后就立马释放自增锁。那么，今天这篇文章，我们就一起来聊聊这个话题。
# insert ... select 语句我们先从昨天的问题说起吧。表 t 和 t2的表结构、初始化数据语句如下，今天的例子我们还是针对这两个表展开。    CREATE TABLE `t` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `c` int(11) DEFAULT NULL,  `d` int(11) DEFAULT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `c` (`c`)) ENGINE=InnoDB; insert into t values(null, 1,1);insert into t values(null, 2,2);insert into t values(null, 3,3);insert into t values(null, 4,4); create table t2 like t现在，我们一起来看看为什么在可重复读隔离级别下，binlog_format=statement时执行：    insert into t2(c,d) select c,d from t;这个语句时，需要对表 t 的所有行和间隙加锁呢？其实，这个问题我们需要考虑的还是日志和数据的一致性。我们看下这个执行序列：![](Images/20b44991955d15a9a6a13ee75da254b3.png){savepage-src="https://static001.geekbang.org/resource/image/33/86/33e513ee55d5700dc67f32bcdafb9386.png"}```{=html}```图 1 并发 insert 场景]{.reference}```{=html}```实际的执行效果是，如果 session B 先执行，由于这个语句对表 t 主键索引加了(-∞,1\] 这个 next-key lock，会在语句执行完成后，才允许 session A 的insert 语句执行。但如果没有锁的话，就可能出现 session B 的 insert 语句先执行，但是后写入binlog 的情况。于是，在 binlog_format=statement 的情况下，binlog里面就记录了这样的语句序列：``{=html}    insert into t values(-1,-1,-1);insert into t2(c,d) select c,d from t;这个语句到了备库执行，就会把 id=-1 这一行也写到表 t2中，出现主备不一致。