take. Then you must examine the implementation of each function to identify any 
vulnerabilities. 
In addition to defining just the interfaces, objects themselves can also be expressed. 
The coclass keyword is used to represent a COM object. The class definition contains 
a list of interfaces the object implements. Returning to the previous example of the 
bank interface, the class definition would follow the interface definition and look 
something like this: 
[ 
    uuid(87654321-4321-4321-4321-210987654321), 
    version(1.0), 
    helpstring("Bank Account Class") 
] 
coclass CBankAccount 
{ 
    [default] interface IBankAccountObject; 
} 
This simple example shows the definition of the COM class CBankAccount. This object's 
CLSID is indicated by the uuid attribute. This class implements only one interface: 
IBankAccountObject. 
Note 
The default attribute listed before the interface definition is optional and doesn't need 
to be there. It simply indicates that IBankAccountObject is the default interface for the 
CBankAccount class. Other interface-specific attributes can be used; for more 
information, read the COM section of the MSDN. 
Reviewing the code for a class exposing multiple interfaces requires examining each 
interface separately because the interfaces' functionality might be exposed to 
untrusted (or semitrusted) clients. 
Type library information is also generated by using MIDL. Specifically, the library 
keyword can be used to create a .tlb file, like so: 
library libname 
{ 
   importlib("stdole.tlb"); 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
756 
   interface IMyInterface1; 
   coclass CClass; 
   ... other stuff you want to appear in the TLB ... 
} 
This section doesn't delve into the syntax for library definitions. When you have the 
source code, the type library doesn't offer much additional information. After all, you 
already know the available objects and their interfaces from looking at the rest of the 
IDL data. 
Active Template Library 
The Active Template Library (ATL) is another approach developers can use for 
developing COM applications. It allows developers to define interfaces in their code 
and automatically takes care of many of the more tedious aspects of implementing 
COM interfaces. For example, ATL can be used to automatically generate the IUnknown 
member functions QueryInterface(), AddRef(), and Release(). It can also be used to 
generate code for several other interfaces, such as IClassFactory. 
ATL is used extensively, so you need to be able to identify COM interfaces in 
ATL-generated code. As it turns out, this is easy. All you need to be familiar with is the 
COM_MAP macro used to define a COM object; a COM object definition using COM_MAP 
looks something like this: 
BEGIN_COM_MAP(CObjectName) 
    COM_INTERFACE_ENTRY(IMyInterface1) 
    COM_INTERFACE_ENTRY(IMyInterface2) 
END_COM_MAP() 
Simple, right? You can easily see that the COM object CObjectName is being declared, 
and it exposes two interfaces: IMyInterface1 and IMyInterface2. From there, all you 
need to do is locate the methods for each interface entry in the COM MAP. Each 
COM_INTERFACE_ENTRY() in the COM_MAP is an interface definition from an IDL file, which 
is generated by the development environment when ATL wizards are used. When ATL 
is used to auto-generate COM objects, you have the IDL data at your disposal as well. 
Auditing DCOM Applications 
Now that you're familiar with the general structure of COM programming and security 
measures, you need to walk through the most effective ways of auditing COM client 
and server programs. Auditing COM servers isn't too different from auditing RPC 
servers; you need to address the following questions: 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
757 
Are sufficient access controls in place to restrict the interface to authorized 
parties? 
Are the exposed interface functions secure? 
Is impersonation being used properly, or does it pose a risk? 
What launching rights are granted to the server? 
Are there any threading or synchronizations issues that could be exploited? 
You can break down this list of requirements into the following steps: 
1.  Check DCOM application security settings programmatically or by using the 
DCOM Configuration utility. 
2.  Examine how CoInitializeSecurity() is called (if it's called) to back up your 
findings from the registry. This step also sheds some light on what sort of 
impersonation defaults are enforced. 
3.  Locate the interface routines exposed by the COM server and apply the standard 
vulnerability-auditing methods you've learned in this book. 
When determining the security of interface functions, you should look for the issues 
described in the following sections. 
COM Registration Review 
Now that you know how access controls can be applied to COM objects, it should be 
evident that determining whether access controls aren't secure is a two-step process: 
examining the activation access controls and examining the call-level access controls. 
Activation access controls aren't in the application code; they reside in the registry. 
Although you might not have access to the target machines the application will be 
installed on, an install procedure should be in place to govern who can activate the 
object. 
COM applications are often self-registering. That is, they can perform their own 
registration automatically so that manual setup isn't required. To do this, they export 
a pair of functions, DllRegisterServer() and DllUnregisterServer(), in one of the 
binary files bundled with the application. The DllRegisterServer() function contains 
code to make registration settings. The DllUnregisterServer() function does the 
reciprocalremoving all registration established in DllRegisterServer(). 
A COM application providing this interface is installed and removed with the 
regsvr32.exe program. When this program starts, it locates the DllRegisterServer() 
routine in the specified binary and runs it, thus removing the requirement for manual 
registration. 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
758 
Note 
ActiveX controls are self-registering COM objects. This just means users don't need to 
run the regsvr32 application because Internet Explorer does so automatically when 
downloading a new component. ActiveX controls are covered in "ActiveX Security" 
later in this chapter. 
After the application is installed, you can use standard Windows utilities to inspect 
security settings. The easiest approach is to use the DCOM Configuration utility; 
however, the associated registry keys can be manipulated directly. These keys are 
located at HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AppID\. Table 12-6 
lists the MSDN-provided values that affect a server's DCOM security parameters. 
Table 12-6. COM Registry Values 
Named Value 
Description 
AccessPermission 
Sets an ACL that determines access. 
ActivateAtStorage 
Configures client to activate on the same system as 
persistent storage. 
AppID 
Identifies the AppID GUID that corresponds to the named 
executable. 
AuthenticationLevel 
Sets the authentication level for the AppID, overriding 
LegacyAuthenticationLevel. Available only on Windows NT 
4.0 SP4 and later versions. 
DllSurrogate 
Specifies that a DLL server is to use a surrogate.exe file. If 
the path is not specified, the system-provided surrogate is 
used. 
DllSurrogateExecutable Specifies that a DLL server is to use a custom surrogate.exe 
file. If the custom file is not specified, the system-provided 
surrogate is used. 
Endpoints 
Configures a COM application to use a specified TCP port 
number for DCOM communications. 
LaunchPermission 
Sets an ACL that determines who can launch the application. 
LocalService 
Sets the application as a Win32 service. 
RemoteServerName 
Sets the name of the remote server. 
RunAs 
Sets an application to run only as a given user. 
ServiceParameters 
Sets parameters to be passed to a LocalService on call. 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
759 
Table 12-6. COM Registry Values 
Named Value 
Description 
SRPTrustLevel 
Sets the trust level of the software restriction policy (SRP). 
Available only on Windows XP and later versions. 
You have already seen that you can determine the launching identity of a COM 
application by checking the RunAs and LocalService keys listed in Table 12-6. These 
keys are usually absent, so the default action is taken, which causes the COM 
application to run in the context of the launching user. Running in this context roughly 
equates to a standard local process execution and generally requires no further 
inspection. However, further inspection is needed if the COM subsystem allows 
remote users to launch COM objects, as vulnerabilities in these methods could result 
in remote process execution. The remaining options might require far more 
inspection, particularly long-lived DCOM applications that run inside services. 
Auditing COM Interfaces 
Auditing the actual implementation of COM objects is one of the most critical 
components of auditing a COM-based application. After all, a vulnerability in the 
implementation of the functions could allow attackers to undermine all external 
access controls and the underlying system's integrity. The choice of authentication 
and impersonation parameters can reduce the impact of attacks. However, all 
exposed interfaces still need to be audited for the general classes of vulnerabilities 
discussed elsewhere in this book. 
COM Source Audits 
Auditing the source code makes your review easier because you can read interface 
definitions from IDL files or read the ATL definitions. From there, you can refer to the 
source code to find the implementation of relevant functions and determine whether 
the object exposes any vulnerabilities. 
COM Binary Audits 
You might be required to perform binary audits of COM applications. The principles for 
auditing a COM application (and indeed any application) are the same whether you 
have the binary or source code. However, the extra steps in the binary audit can be a 
major hurdle. With that in mind, this section gives you a brief summary of identifying 
and auditing COM interfaces as they appear in binary files. 
Say you're auditing a COM application, and you want to identify which interfaces the 
object exposes, what methods are available in each interface, and what type of 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
760 
arguments they take. The most useful source of information is type libraries, if they 
are available. 
Note 
Type libraries are always available for automation objects because the IDispatch 
interface needs to publish the information in them. 
As mentioned previously, the type library information might be stored in a separate 
file. However, most often it's stored as a resource in the executable or DLL that 
implements the object. You can find the location of a type library by consulting the 
HKEY_CLASSES_ROOT\CLSID\\TypeLib key. 
Note 
The HKEY_CLASSES_ROOT\Interface key can also contain a TypeLib key. 
This key provides a TypeID GUID value that matches a subkey in 
HKEY_CLASSES_ROOT\TypeLib. This key has a version subkey indicating the location 
of the type library. If it's embedded in an executable, you can simply view it with a PE 
resource viewer (such as PE Editor at www.heaventools.com). This library 
information is especially useful because it gives you GUIDs, structure definitions, 
methods exposed by interfaces, and even type information for arguments to those 
methods. 
After you have this information, you need to determine how to find the methods to 
audit in the binary. The first method is by locating entry points. An executable that 
implements a COM object must register each class object by using the 
CoRegisterClassObject() function. This requires indicating a CLSID along with a 
pointer to the class's IUnknown interface. By locating instances of 
CoRegisterClassObject(), you can find the vtable for IUnknown and then read the 
QueryInterface() function to learn about other interfaces the object exposes. 
In fact, the QueryInterface() function exported by an object is always useful because 
it must return pointers to all its supported interfaces. So another way to locate 
functions exported by an object is to find the QueryInterface() implementation in the 
COM server to see how it handles requests for different IIDs. Remember, access to 
any interface other than IUnknown is done via the QueryInterface() function, so the 
implementation always looks something like this: 
HRESULT QueryInterface(REFIID iid, void **ppvObject) 
{ 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
761 
    if(iid == IID_IMyInterface1) 
    { 
        *(IMyInterface1 *)ppvObject = this; 
        AddRef(); 
        return NOERROR; 
    } 
    *ppvObject = NULL; 
    return E_NOINTERFACE; 
} 
Because the second argument always points to an interface upon success, you can 
find every assignment for this argument and deduce which functions are exported. 
Take a look at a practical example. The following disassembly is taken from 
C:\Windows\System32\wiaacmgr.exe, which hosts a COM server on a Windows XP 
machine (CLSID 7EFA65D9-573C-4E46-8CCB-E7FB9E56CD57). The code is divided 
into parts so that you can see what's going on more easily. 
In this first part, the QueryInterface() function is initialized. As you can see, all that's 
done at this point is setting the ppvObject parameter to NULL so that it doesn't initially 
point to any interface: 
.text:010054C5 QueryInterface proc near ; CODE XREF: 
.text:0100A7F7j 
.text:010054C5                 ; DATA XREF: 
.text:off_100178Co 
.text:010054C5 
.text:010054C5 this_ptr       = dword ptr 8 
.text:010054C5 riid           = dword ptr 0Ch 
.text:010054C5 ppvObject      = dword ptr 10h 
.text:010054C5 
.text:010054C5    mov    edi, edi 
.text:010054C7    push   ebp 
.text:010054C8    mov    ebp, esp 
.text:010054CA    mov    edx, [ebp+ppvObject] 
.text:010054CD    push   ebx 
.text:010054CE    push   esi 
.text:010054CF    mov    esi, [ebp+riid] 
.text:010054D2    push   edi 
.text:010054D3    xor    ebx, ebx 
.text:010054D5    push   4 
.text:010054D7    pop    ecx 
.text:010054D8    mov    edi, offset IID_IUnknown 
.text:010054DD    xor    eax, eax 
.text:010054DF    mov    [edx], ebx     ; *ppvObject = NULL; 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
762 
This next part of the code compares the riid argument against IID_IUnknown. If the 
comparison succeeds ppvObject is set to point to the current (this) object. The jmp 
instruction at the end jumps to the function epilogue, which returns a successful 
result: 
.text:010054E1    repe cmpsd 
.text:010054E3    jnz  short loc_10054F2 
                             ; test for IID_IUnknown 
.text:010054E5 
.text:010054E5 loc_10054E5:  ; CODE XREF: QueryInterface+3Cj 
.text:010054E5    mov  eax, [ebp+this_ptr] 
.text:010054E8 
.text:010054E8 loc_10054E8:  ; CODE XREF: QueryInterface+5Bj 
.text:010054E8    mov   [edx], eax    ; *ppvObject = this; 
.text:010054EA    mov   ecx, [eax] 
.text:010054EC    push  eax 
.text:010054ED    call  dword ptr [ecx+4] ; call AddRef() 
.text:010054F0    jmp   short loc_100552A 
Evidently, this object has two interfaces in addition to IUnknown. This next part of the 
code compares the riid argument against two more interface IDs. If there's a match, 
the ppvObject parameter is set to the this object pointer and a successful return 
happens: 
.text:010054F2 loc_10054F2:    ; CODE XREF: QueryInterface+1Ej 
.text:010054F2    mov    esi, [ebp+riid] 
.text:010054F5    push   4 
.text:010054F7    pop    ecx 
.text:010054F8    mov    edi, offset IID_Interface1 
.text:010054FD    xor    eax, eax 
.text:010054FF    repe cmpsd 
.text:01005501    jz     short loc_10054E5 ;test IID_Interface1 
.text:01005503    mov    esi, [ebp+riid] 
.text:01005506    push   4 
.text:01005508    pop    ecx 
.text:01005509    mov    edi, offset IID_Interface2 
.text:0100550E    xor    eax, eax 
.text:01005510    repe cmpsd             ; test IID_Interface2 
.text:01005512    jnz    short loc_1005522 ; go to failure 
.text:01005514    mov    eax, [ebp+this_ptr] 
.text:01005517    lea    ecx, [eax+4] 
.text:0100551A    neg    eax 
The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 
763 
.text:0100551C    sbb    eax, eax 
.text:0100551E    and    eax, ecx 
.text:01005520    jmp    short loc_10054E8 ; *ppvObject = this; 
Note 
The second interface causes ppvObject to be set to the this pointer with 4 added to it. 
If there's no match, the riid argument is deemed invalid, and the jnz instruction 
bolded in the previous code causes a jump to an error epilogue that returns the error 
E_NOINTERFACE, as shown in the following code snippet: 
.text:01005522 loc_1005522:    ; CODE XREF: QueryInterface+4Dj 
.text:01005522    and    dword ptr [edx], 0 
.text:01005525    mov    ebx, 80004002h ; E_NOINTERFACE 
.text:0100552A 