286
223
0
181
Kernel-space User-space Processes
RPCSS
SQL Name Res. (Slammer)
SQL Authentication
Zotob
IIS (Code Red II)
wu-ftpd Format String
rpc.statd
innd
Apache Chunk Handling
ntpd
Turkey
38
1
7
271
107
2288
44
329
3499
17
347
2
0
0
177
0
0
0
41
4
0
98
Multiple
Threads
Yes
Yes
Yes
Predicates
82
120
105
36
1
7
94
107
2288
44
288
3495
17
249
Involved
SYSTEM and lsass.exe
svchost.exe
SYSTEM, svchost.exe,
??, ??, and lsass.exe
Yes
SYSTEM and svchost.exe
Yes
SQL Server
SQL Server
Yes
SYSTEM, services.exe, and ?? Yes
No
IIS Web Server
wu-ftpd
No
No
portmap and rpc.statd
No
innd and nnrpd
No
httpd
No
ntpd
ftpd
No
Table 4: Where exploits are discovered.
Exploit Name
LSASS
DCOM RPC
Workstation Service
RPCSS
SQL Name Res. (Slammer)
SQL Authentication
Zotob
IIS (Code Red II)
wu-ftpd Format String
rpc.statd
innd
Apache Chunk Handling
ntpd
Turkey
Longest Token Token length histogram as “Number(Size in bytes)”
36
92
23
18
1
4
36
17
283
16
27
32
8
21
1(36),1(34),3(18),2(14),1(12),5(9),5(8),2(5),15(4),2(3),39(2),19(1)
1(92),1(40),1(20),2(18),1(14),5(8),15(4),2(3),13(2),8(1)
1(23),5(18),1(16),2(14),1(12),4(10),8(8),1(6),5(5),8(4),1(3),42(2),22(1)
2(18),2(8),5(4),9(2),8(1)
1(1)
3(4),3(1)
1(36),1(34),2(18),1(16),1(14),1(12),2(8),3(5),11(4),2(3),32(2),6(1)
1(17),3(5),23(2),1(1)
4(283),4(119),4(11),1(10),1(9),1(6),4(5),3(4),4(3),10(2),41(1)
2(16),1(8),2(4),10(2),13(1)
1(27),1(21),1(13),1(11),2(10),2(9),2(6),6(5),9(4),12(3)
1(32),24(13),23(11),1(8),1(6),2(5),1(3),3(2),3(1)
1(8),2(4),2(2)
2(21),1(12),2(6),6(5),16(4),23(2),14(1)
Table 5: Signature Tokens.
4.3.1 Processing of Network Data in the Kernel
lsass.exe,
The most salient feature of the LSASS exploit is the
amount of protocol that the attack must traverse through
in the kernel
itself before it even is able to reach the
vulnerable process,
through the named pipe
“\\PIPE\lsarpc”. For a step-by-step explanation of the
LSASS exploit see the eEye advisory [48]. The Windows ker-
nel space contains a great deal of executable code that han-
dles network traﬃc including Transport Device Interfaces
(TDIs), Remote Procedure Calls (RPC), Ancillary Function
Driver File System Drivers (AFD FSDs), Named Pipe FSDs,
Mailslot FSDs, NetBIOS emulation drivers, and more [36].
Today, even HTTP requests are being processed in the ker-
nel space with a network driver contained in IIS 6.0 [2]. Thus
attack analysis must include the kernel.
Furthermore, it is not necessary for a remote exploit to
ever involve a user-space process. A remote memory cor-
ruption vulnerability in the kernel may allow an attacker
to execute arbitrary code directly in “CPL==0” (the kernel
space). Such an exploit is described by Barnaby Jack [2] that
exploits a kernel-space buﬀer overﬂow in a popular ﬁrewall
program. Microsoft recently released an advisory describ-
ing a heap corruption vulnerability in the kernel-space SMB
driver that could allow remote code execution [50, MS05-
027]. Linux and BSD do much less processing of network
data in kernel space but are nonetheless susceptible to the
same problem [52, bid 11695].
4.3.2 Multiple Processes Involved
The rpc.statd exploit is interesting because it is possi-
ble that the vulnerable service, rpc.statd, may be listening
on a diﬀerent port for every vulnerable host. This is only
probable if the diﬀerent vulnerable hosts are running diﬀer-
ent operating system distributions. Nonetheless, the initial
connection to portmap to ﬁnd the rpc.statd service is an
important part of the exploit to analyze.
The innd exploit works by posting a news message to a
newsgroup, in this case “test”, and then canceling that mes-
sage by posting a cancellation message to the group called
“control”. The buﬀer overﬂow occurs when a log message is
generated by the nnrpd service, which is invoked by the innd
process, because the e-mail address of the original posting
is longer than the buﬀer reserved for it.
In this particu-
lar exploit the entire exploit is carried out through a single
TCP connection, but it is possible that the attacker could
upload the payload and bogus return pointer onto the vul-
nerable host’s hard drive using one TCP connection from
one remote host and then invoke the buﬀer overﬂow via a
diﬀerent TCP connection coming from a diﬀerent remote
host.
4.3.3 Multithreading and Multiple Ports
In addition to multi-stage attacks like the innd exploit,
many Windows services are multithreaded and listen on
multiple ports. The SQL Server is multithreaded and listens
on ports 1434 UDP and 1433 TCP. The DCOM RPC, Work-
station Service, RPCSS, and Zotob exploits have the same
property. The Windows Security Bulletin for the LSASS
buﬀer overﬂow [50, MS04-011] recommends blocking UDP
ports 135, 137, 138, and 445, and TCP ports 135, 139, 445,
and 593; plus, the lsass.exe process is multithreaded mean-
ing that, for example, the payload and the exploit could be
introduced into the process’ address space simultaneously
through two diﬀerent connections on two diﬀerent ports.
Most exploits allow some form of arbitrary memory cor-
ruption such as writing an arbitrary value to an arbitrary
location or writing a predictable value to an arbitrary lo-
cation. Even simple stack-based buﬀer overﬂows can have
this property, like the RPC DCOM exploit or the Slammer
exploit. In Slammer, a certain word just beyond the bogus
return pointer can point to any writable address where the
value 0 is written just before the bogus control ﬂow transfer
occurs.
Any open TCP port 1433 connection can be turned into
what appears to be a port 1433 buﬀer overﬂow by exploit-
ing the name resolution vulnerability (used by Slammer) on
UDP port 1434 and using the “write the value zero to any
writable location” primitive. Such an attack would open
enough port 1433 TCP connections to tie up all but one
thread of the SQL server, load a bogus stack frame com-
plete with executable payload on one connection, and load
fake junk to all of the others. The stacks for these threads
could be held in a suspended state by not closing the TCP
connections.
Then through UDP port 1434 the attacker would send
SQL name resolution exploits that only overwrote the re-
turn pointer with its original value but, more importantly,
changed the address where the value 0 is written to point
to each successive stack. A well placed zero that overwrites
the least signiﬁcant byte of a base pointer on a stack en-
ables linking in a bogus stack frame (this is how the Turkey
exploit works). Then by closing the port 1433 TCP connec-
tion with the exploit code in it, the stack is unwound until
the bogus stack frame hijacks control ﬂow. Because the in-
coming 0 would not be labeled, and because the row spaces
of γ and π would have been mapped from packets for TCP
port 1433, it would be easy for DACODA-based analysis to
assume that there had been a buﬀer overﬂow on port 1433.
Fortunately, DACODA records when labeled data is used as
addresses so the connection with UDP port 1434 could be
identiﬁed.
4.3.4 Side Channels
The innd exploit shares something in common with both
of the ftp exploits presented here in that the process being
attacked does a reverse DNS entry lookup on the IP address
of the attacker.
It is not clear whether DACODA should
include this in the analysis of the attack or not because the
attacker could use their DNS name to inject part of the
attack into the address space of the vulnerable process but
typically will not do so. For all results presented in this
paper the DNS traﬃc is included in the analysis.
Also, parts of the UDP header for Slammer, the source
IP address and port, are present in the address space when
the bogus control ﬂow transfer occurs. Thus not all of the
various parts of an attack can be found in the data ﬁelds
of TCP and UDP packets; they may come from the packet
headers as well.
4.3.5 Encodings and Encryption
The various ASN.1 vulnerabilities found in Microsoft Win-
dows over the past two years [52, bids 9633, 9635, 9743,
10118, 13300], none of which were tested with DACODA,
are exposed through several services. They can be exploited
through Kerberos on UDP port 88, SSL on TCP port 443,
or NTLMv2 authentication on TCP ports 135, 139, or 445.
The malicious exploit and code can be encoded or encrypted
with Kerberos, SSL, IPSec, or Base64 encoding (on top of
the malicious ASN.1 encoding) [52, bid 9635]. A more ad-
vanced exploit for this vulnerability could encrypt most of ,
and all of γ and π, and the decryption would be performed
by the vulnerable host. The fact that not many vulnerabil-
ities have this property should not be taken to mean that
it will be a rare property for zero-day vulnerabilities. Zero-
day vulnerabilities will be found in the places that attackers
look for them.
Encodings or encryptions of  and γ that are decoded
or decrypted by protocol implemented on the machine be-
ing attacked are only a challenge for DACODA if the sym-
bolic expressions become too large to handle eﬃciently or
too complex to be useful. In either case DACODA reports
this fact, so that a diﬀerent response than content ﬁltering
can be mounted. When symbolic expressions exceed a cer-
tain size they become idempotent expressions that denote
that a large symbolic expression has been dropped.
4.3.6 Undesirable Predicates
The wu-ftpd format string attack helps illustrate what fu-
ture work is needed before DACODA can consistently an-
alyze real attacks with a high degree of assurance. We
used the Hannibal attack from Crandall and Chong [12]
where the major portion of the format string is of the form,
“%9f%9f%9f%9f%9f...”. DACODA should, and does, dis-
cover predicates for “%” and “f” but should not discover a
strong equality predicate for “9” because the format string
attack could take the form “%11f%4f%132f...”.
The IO default xsputn() function from glibc sets a vari-
able to 0 and increments that variable for every character
printed. When it is done printing the ﬂoating point num-
ber it subtracts this count from the value 9 calculated by
taking the ASCII value 0x39 for “9” and subtracting 0x30
(basically, although, as is often the case, reverse engineer-
ing by DACODA reveals the actual decoding implementa-
tion to be much more convoluted).
If this value is equal
to zero a strong, explicit equality predicate is discovered
by DACODA and the IO default xsputn() function moves
printf fp() function does a similar check on the
on (The
same byte so two predicates are actually discovered). Oth-
erwise the diﬀerence is used as the number of trailing zeroes