### 应用程序安全隐患与被动攻击

尽管浏览器的同源策略为抵御被动攻击提供了一定的保护，但如果应用程序本身存在安全漏洞，仍可能遭受被动攻击。跨站脚本攻击（XSS）就是一个典型的例子。

#### 跨站脚本攻击（XSS）

在下一章中，我们将详细讨论跨站脚本攻击（XSS）。这里，我们先通过一个实验示例来解释其攻击方式。当使用外层 JavaScript 访问 iframe 内部（不同主机）的数据时，由于违反了同源策略，访问会被拒绝。然而，攻击者可以通过一些特殊手段将恶意 JavaScript 代码注入到 iframe 的内部执行。由于在 iframe 内部不受同源策略限制，因此可以成功访问文档信息。这种攻击被称为跨站脚本攻击（XSS）。详细的 XSS 攻击将在 4.3 节中进一步探讨。

**图 3-29**：XSS 通过将 JavaScript 放置在内层并在同源环境中执行

#### 第三方 JavaScript

虽然 XSS 是由恶意第三方执行 JavaScript 引起的问题，但在某些情况下，我们也需要执行可信的第三方 JavaScript。为了确保安全，网站运营者或网页浏览者通常只会执行他们信任的第三方 JavaScript。

##### 网站运营者执行第三方 JavaScript

网站运营者有时会将第三方 JavaScript 嵌入到自己的网站中，例如用于访问解析、横幅广告或博客插件等。在这种情况下，运营者会有意将第三方 JavaScript 嵌入网页。然而，如果嵌入的 JavaScript 是恶意代码，网站就有可能面临信息泄露或篡改的风险。因此，选择可信赖的 JavaScript 提供方是前提条件。尽管如此，现实中仍然存在多种威胁，导致安全问题频发：

- 提供方有意收集个人信息
- 提供方服务器存在安全隐患，JavaScript 代码被替换
- 提供方的 JavaScript 代码存在漏洞，被迫运行其他脚本

从技术角度来看，网站横幅广告和 XSS 使用的 JavaScript 具有相同的危险性。唯一的区别在于网站运营者是否信任提供方。因此，即使有意嵌入第三方 JavaScript，也应在充分调查提供方信誉的基础上慎重决策。

##### 网页浏览者信任第三方 JavaScript

Firefox 插件 Greasemonkey 就是一个网页浏览者信任第三方并嵌入 JavaScript 的例子。Greasemonkey 允许用户安装各种脚本来改变网页内容。由于 Greasemonkey 通常拥有比普通 JavaScript 更高的权限，如果脚本作者心怀不轨，可能会进行盗取密码等非法操作。

#### JavaScript 以外的跨域访问

前面讨论了 JavaScript 的跨域访问受到同源策略的严格限制。下面我们来看一些能够进行跨域访问的其他浏览器功能。

##### frame 元素与 iframe 元素

通过之前的实验可知，iframe 和 frame 元素可以进行跨域访问，但通过 JavaScript 却不能跨域访问 iframe 中的文档内容。

**专栏：X-FRAME-OPTIONS**

X-FRAME-OPTIONS 是微软提出的一种限制 frame 和 iframe 访问权限的方案，已被主流浏览器采用。该选项定义在响应头中，值为 DENY 或 SAMEORIGIN。DENY 表示不允许在 frame 或 iframe 中显示，SAMEORIGIN 则仅允许同源显示。

在 PHP 中设置 X-FRAME-OPTIONS 为 SAMEORIGIN 的方法如下：
```php
header('X-FRAME-OPTIONS: SAMEORIGIN');
```

X-FRAME-OPTIONS 还可用于防范点击劫持（Clickjacking）。通过将不使用 frame 或 iframe 的网站设置为 DENY，或将单一主机的网站设置为 SAMEORIGIN，可以更好地防御利用 frame 执行的各种攻击。

##### img 元素

img 元素的 src 属性可以指定其他域名。请求图像时会附带 Cookie，因此可能导致恶意网站上的图像显示为“此图像需要认证”。JavaScript 无法访问图像文件内部，所以跨域图像访问通常不会造成问题。如果不想让自己的图像被贴到特定网站上，可以针对图像检查 Referer 头信息。不过这会使关闭了 Referer 的用户无法看到图像。

##### script 元素

通过指定 script 元素的 src 属性可以从其他网站读取 JavaScript。假设 A 网站读取 B 网站的 JavaScript，如图 3-30 所示。

**图 3-30**：跨域读取 script

JavaScript 的源代码位于 B 网站的服务器中，但读取后的作用范围变为 A 网站。因此，执行 `document.cookie` 后得到的是 A 网站的 Cookie 信息。A 网站向 B 网站发送获取 JavaScript 的请求时，也会发送 Cookie。根据用户在 B 网站的登录状态，B 网站的 JavaScript 代码可能会发生变化，从而影响 A 网站的内容。

这种情况也可能伴随 JSONP（JSON with padding）出现。JSONP 用于从 Ajax 应用访问不同来源服务器的数据，但由于认证状态不同，JavaScript 代码（JSONP 数据）可能会变化，导致意外的信息泄漏。因此，JSONP 不应用于传输隐私信息。

##### CSS

CSS 可以跨域读取，具体来说，除了 HTML 的 link 元素外，还可以在 CSS 中使用 `@import` 或 JavaScript 的 `addImport` 方法。一般来说，即使读取不良网站的 CSS 也不会造成问题，但在 Internet Explorer 中曾出现过 CSSXSS 漏洞，使 HTML 或 JavaScript 被当作 CSS 读取，并且部分代码被执行。由于 CSSXSS 属于浏览器漏洞，建议用户使用最新版本的浏览器并安装安全补丁。

##### form 元素的 action 属性

form 元素的 action 属性也可以跨域指定。无论 action 目标是否跨域，表单提交都可以通过 JavaScript 操作。恶意利用 form 元素特性实施的攻击称为跨站请求伪造（CSRF），即让用户在不知情的情况下提交表单，从而滥用应用功能。关于 CSRF 的详细内容将在 4.5 节中介绍。

#### 总结

本节讨论了被动攻击及浏览器用来防御被动攻击的同源策略。被动攻击是通过用户的浏览器攻击 Web 应用的手法。JavaScript 的同源策略是防御被动攻击的主要对策。然而，若浏览器或 Web 应用存在安全隐患，攻击者可以绕过同源策略进行攻击。下一章将重点讨论 Web 应用的防御对策。

---

### 第 4 章 Web 应用的安全隐患

本章将详细讲解 Web 应用中的各种安全隐患，包括其产生原理、影响范围和防范策略。

#### 4.1 Web 应用的功能与安全隐患的对应关系

在详细讨论 Web 应用的安全隐患之前，让我们先对安全隐患有一个整体认识。图 4-1 展示了 Web 应用的各项功能与安全隐患的对应关系。图中使用经典的“输入-处理-输出”模型表示 Web 应用。从 HTTP 请求的输入开始，经过应用的各种处理，最后由 HTTP 响应进行输出。此外，“输出”还包括数据库访问、文件读写、邮件收发等外部交互操作。

**图 4-1**：Web 应用的功能与安全隐患的对应关系

从另一个角度看，图 4-1 中的“输出”也可以理解为向外部媒介输出脚本。Web 应用常见的脚本输出及其对应的安全隐患如下：

- 输出 HTML（跨站脚本）
- 输出 HTTP 消息头（HTTP 消息头注入）
- 调用 SQL 语句（SQL 注入）
- 调用 Shell 命令（OS 命令注入）
- 输出邮件头和正文（邮件头注入）

各隐患的详细内容将在后续章节中介绍。从图 4-1 中我们可以得出以下结论：

- 处理过程和输出过程会产生安全隐患
- 输入过程不会产生安全隐患
- 输出过程产生的安全隐患名称多数带有“注入”

实际上，跨站脚本有时也被称为“HTML 注入”或“JavaScript 注入”，因此，图 4-1 中输出过程产生的安全隐患全部为注入型隐患。

综上所述，安全隐患与 Web 应用的功能密切相关。因此，在程序设计或编写代码时，可以根据正在实现的功能了解应警惕哪些安全隐患。接下来，我们将按 Web 应用的各项功能分类，详细阐述与其对应的安全隐患。

#### 注入型隐患

Web 应用中传递的信息多为文本格式，如 HTML、HTTP 和 SQL 等。这些文本格式由各自的语法构成，包含命令、运算符和数据。数据部分通常通过引号（单引号或双引号）或分隔符（逗号、Tab 或换行符等）加以区分。Web 应用的普遍形式是首先确定文本框架，然后填充数据。例如，以下 SQL 语句中，`$id` 是被填入的数据：
```sql
SELECT * FROM users WHERE id='$id';
```
如果应用存在安全隐患，攻击者可以更改此 SQL 语句的结构。例如，假设 `$id` 的值为：
```sql
'; DELETE FROM users -- 
```
填入数据后的 SQL 语句如下：
```sql
SELECT * FROM users WHERE id=''; DELETE FROM users -- ';
```
外界传入的单引号和分号迫使 SELECT 语句结束后，添加了 DELETE FROM 语句，这就是 SQL 注入攻击。详情将在 4.4.1 节讲述。

SQL 注入攻击的原因是在被认为是“数据”的位置插入单引号，使得数据部分结束，从而更改了 SQL 语句的构造。这一原理同样适用于其他注入型隐患。通过插入引号或分隔符等表示“数据部分边界”的字符，可以改变文本结构。

**表 4-1** 列举了各种注入型攻击的恶意手段和表示“数据部分边界”的字符。详细了解将在后续章节中进行。

| 隐患名 | 接口 | 恶意手段 | 数据部分边界 |
| --- | --- | --- | --- |
| 跨站脚本 | HTML | 注入 JavaScript 等 | `<`、`"` 等 |
| HTTP 消息头注入 | HTTP | 注入 HTTP 响应消息头 | 换行符 |
| SQL 注入 | SQL | 注入 SQL 命令 | `'` 等 |
| OS 命令注入 | Shell 脚本 | 注入系统命令 | `;`、`|` 等 |
| 邮件头注入 | sendmail 命令 | 注入或更改邮件头或正文 | 换行符 |

总结
本节作为讲解安全隐患的序幕，介绍了安全隐患产生地点和安全隐患种类的关联性。此外，还介绍了由输出引发的安全隐患，即注入型隐患的产生原理。下一节开始，我们将把 Web 应用以功能为单位进行细分，并详细讲解每一功能容易产生的安全隐患。

#### 4.2 输入处理与安全性

本节专门讨论 Web 应用中对“输入值”的处理及其在安全性策略中的地位。虽然校验输入值本身不是安全性策略，但在安全性对策存在缺陷的情况下，通过校验输入值可以防止危害发生或减轻损害程度。

##### 什么是 Web 应用的输入处理

Web 应用中的输入指由 HTTP 请求传入的信息，如 GET、POST 和 Cookie 等。Web 应用接收到这些值时所做的处理称为“输入处理”。在图 4-2 所示的“输入-处理-输出”模型中，Web 应用的输入处理是业务逻辑处理前的数据准备阶段。

**图 4-2**：“输入-处理-输出”模型

输入处理主要包括以下步骤：
- 检验字符编码的有效性

**注**：本章不深入讲解字符编码。详情请参考第 6 章。