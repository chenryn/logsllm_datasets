title:Almost Universal Forgery Attacks on the COPA and Marble Authenticated
Encryption Algorithms
author:Jiqiang Lu
Almost Universal Forgery Attacks on the COPA and Marble
Authenticated Encryption Algorithms∗
Jiqiang Lu
Institute for Infocomm Research,
Agency for Science, Technology and Research
1 Fusionopolis Way, Singapore 138632
PI:EMAIL, PI:EMAIL
ABSTRACT
The COPA authenticated encryption mode was proved to
have a birthday-bound security on integrity, and its instanti-
ation AES-COPA (v1/2) was claimed or conjectured to have
a full security on tag guessing. The Marble (v1.0/1.1/1.2)
authenticated encryption algorithm was claimed to have a
full security on authenticity. Both AES-COPA (v1) and
Marble (v1.0) were submitted to the Competition for Au-
thenticated Encryption: Security, Applicability, and Ro-
bustness (CAESAR) in 2014, and Marble was revised twice
(v1.1/1.2) in the ﬁrst round of CAESAR, and AES-COPA
(v1) was tweaked (v2) for the second round of CAESAR. In
this paper, we cryptanalyse the basic cases of COPA, AES-
COPA and Marble, that process messages of a multiple of
the block size long; we present collision-based almost univer-
sal forgery attacks on the basic cases of COPA, AES-COPA
(v1/2) and Marble (v1.0/1.1/1.2), and show that the ba-
sic cases of COPA and AES-COPA have roughly at most a
birthday-bound security on tag guessing and the basic case
of Marble has roughly at most a birthday-bound security
on authenticity. The attacks on COPA and AES-COPA do
not violate their birthday-bound security proof on integrity,
but the attack on AES-COPA violates its full security claim
or conjecture on tag guessing. Therefore, the full security
claim or conjecture on tag guessing of AES-COPA and the
full security claim on authenticity of Marble are incorrectly
far overestimated in the sense of a general understanding
of full security of these security notions. Designers should
pay attention to these attacks when designing authenticated
encryption algorithms with similar structures in the future,
and should be careful when claiming the security of an ad-
vanced form of a security notion without making a corre-
∗
Earlier versions of the materials of this paper appeared
in 2015 in the forum of the Competition for Authenticated
Encryption: Security, Applicability, and Robustness (CAE-
SAR) [16, 17] and in IACR Cryptology ePrint Archive Re-
port 2015/079 [18].
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ASIA CCS ’17, April 02-06, 2017, Abu Dhabi, United Arab Emirates
c⃝ 2017 ACM. ISBN 978-1-4503-4944-4/17/04. . . $15.00
DOI: http://dx.doi.org/10.1145/3052973.3052981
sponding proof after proving the security of the security no-
tion only under its most fundamental form.
Keywords
Cryptology; Authentication, Authenticated encryption al-
gorithm; COPA; Marble; Universal forgery attack
1.
INTRODUCTION
In symmetric cryptography, an authenticated encryption
algorithm is an algorithm that transforms an arbitrary-length
data stream (below an upper bound generally), called a mes-
sage or plaintext,
into another data stream of the same
length, called a ciphertext, and generates an (authentica-
tion) tag for the message at the same time, under the control
of a secret key [19]. It combines the functionalities of a sym-
metric cipher and a message authentication code (MAC),
and achieves data conﬁdentiality and integrity/authenticity
at one pass. We refer the reader to Bellare and Namprem-
pre’s work [6] for an introduction to authenticated encryp-
tion and a few security notions under provable security,
such as privacy/conﬁdentiality, integrity/authenticity, and
unforgeability, although one may use a diﬀerent deﬁnition
for a security notion.
Like existential and universal forgery attacks [20, 25] on
a MAC, an existential forgery attack on an authenticated
encryption algorithm is to produce a correct ciphertext-tag
pair which is not given before (under the secret key and
some public nonce if any. Thus, during the decryption and
tag veriﬁcation phase, the message resulted from decrypting
the forged ciphertext can result in the forged tag under the
same key and nonce if any.), while a universal forgery attack
on an authenticated encryption algorithm is to produce the
correct ciphertext-tag pair for any speciﬁed message whose
ciphertext-tag pair is not given before (under the secret key
and public nonce if any. Thus, during the decryption and
tag veriﬁcation phase, the speciﬁed message will be gener-
ated from decrypting the forged ciphertext, and result in the
forged tag under the same key and nonce if any). Note that
a universal forgery attack implies an existential forgery at-
tack, and thus an algorithm secure against existential forgery
attacks is also secure against universal forgery attacks, but
not vice versa — a universal forgery attack represents a more
serious security threat and usually has a higher complexity
level than an existential forgery attack. Besides, Dunkel-
man, Keller and Shamir [9] recently introduced the notion
of almost universal forgery attack on MAC, which works for
almost any speciﬁed message although not for any.
789COPA
variable
constant
variable
AES-COPA v1/2
(nonce-respecting)
constant
(nonce-misuse)
Marble v1.1/1.2
Marble v1.0/1.1/1.2
variable
variable
2σ + 2φqueries
(1 ≤ σ, φ ≤ n
2 )
2θ + 2ϕqueries
( n
2 < θ, ϕ < n)
264queries
∼ 263queries
(∼ 264blocks)
2124queries
∼ 263 queries
(∼ 264blocks)
265queries
265queries
(266.6blocks)
Memory
n · 2σbits
3n · 2ϕbits
Time
2φmemory accesses
Success Rate
1 − e
(cid:0)2σ+φ(cid:0)n
Source
Sect. 3.1
2ϕsimple operations
See Sect. 3.2
Sect. 3.2
269.6bytes
266bytes
264memory accesses
262memory accesses
2120.6bytes 2124simple operations
268.6bytes
263memory accesses
20%
6%
32%
6%
x
Sect. 3.3
Sect. 3.1.4
Sect. 3.2.4
x
Sect. 3.3
Table 1: Main (almost) universal forgery attacks on COPA and Marble, where n is the block length of the
underlying block cipher and e is the base of the natural logarithm.
Algorithm
Associated Data
Data
y
[10, 11]
z
Sect. 4
z
[18]
†: A forgery is based on modifying associated data. ‡: A forgery is based on modifying message or associated data.
§: Suggested by an anonymous reviewer.
265memory accesses
265memory accesses
268bytes
268bytes
32%
32%
Proposed for parallel architectures such as general-purpose
graphics processing units (GPGPUs), COPA [3] is a block-
cipher-based authenticated encryption mode; and its instan-
tiation with the AES [24] block cipher under 128 key bits is
called AES-COPA (v1) [1]. Marble (v1.0) [12] is an AES-
based COPA-like authenticated encryption algorithm. For
both COPA and Marble, the key length is equal to the
tag length.
In March 2014, AES-COPA (v1) and Marble
(v1.0) were submitted to the Competition for Authenticated
Encryption: Security, Applicability, and Robustness (CAE-
SAR) [7]. Shortly later, a revision (v1.1) [13] to Marble was
made in the ﬁrst round of CAESAR.
The COPA designers [3,4] proved that COPA has (roughly)
a birthday-bound security on integrity (which is mainly as-
sociated with existential forgery) under the assumption that
the underlying block cipher is a strong pseudorandom per-
mutation, put a birthday-bound constraint on the maximum
number of data blocks that AES-COPA (v1) can process
with a single key, and claimed that AES-COPA (v1) had a
full (i.e. 128-bit) security against tag guessing (which is as-
sociated with universal forgery) by writing ‘security against
tag guessing is 128 bits’, in addition to a birthday-bound (i.e.
64-bit) security on integrity. The Marble designer claimed
that Marble achieved a full (i.e. 128-bit) security on pri-
vacy and authenticity. However, in January 2015, Fuhr et
al. [10] presented universal forgery and key recovery attacks
on the revised version (i.e. v1.1) of Marble, and the Mar-
ble designer made another revision (v1.2) [14] to Marble.
In May 2015, Nandi [22] presented an existential forgery
attack on the case of COPA that processes fractional mes-
sages (that is, messages are not a multiple of the block size
long, and thus message padding is required), basing it on
his earlier cryptanalysis result [21] on the XLS [26] pseudo-
random permutation construction. In September 2015, the
AES-COPA designers made a tweak (v2) [2] to the case of
fractional messages for the second round of CAESAR, and
conjectured that ‘security against tag guessing is 128 bits.’
1.1 Our Contributions
In this paper, we cryptanalyse the basic cases of COPA
(as well as AES-COPA v1/2) and Marble (v1.0/1.1/1.2),
that process messages of a multiple of the block size long,
against almost universal forgery, and obtain the following
main cryptanalytic results on COPA, AES-COPA and Mar-
ble, with only chosen queries to their message encryption
and tag generation oracles:
• We present collision-based almost universal forgery at-
tacks on the basic case of COPA under variable associ-
ated data, each of which has a complexity that is very
near the birthday bound, by using an idea similar to
but much simpler than Fuhr et al.’s attack on Marble.
More importantly, when applied to the basic case of
AES-COPA (v1/2) in the nonce-respecting scenario,
each attack requires slightly less than 263 encryption
queries with the total (associated data, message) pairs
having a length slightly less than the maximum block
number 264 that AES-COPA can process with a single
key, and a memory of about 266 bytes, and has a time
complexity of about 262 memory accesses and a success
probability of about 6%. Though the success proba-
bility 6% is not very high, it is not negligible even in
reality, and the attack is of semi-practical signiﬁcance.
• We present a (multi-)collision-based almost universal
forgery attack on the basic case of COPA under con-
stant or no associated data, by using a novel idea.
When applied to the basic case of AES-COPA (v1/2)
in the nonce-misuse scenario, it requires about 2124 en-
cryption queries and a memory of 2120.6 bytes and has
a computational complexity of about 2124 simple op-
erations and a success probability of about 32%. The
attack is mainly of academic interest, due to its large
data complexity that is far beyond the birthday bound.
Anyway, there is an eﬃcient birthday-bound attack
suggested by an anonymous reviewer.
790• We present collision-based almost universal forgery at-
tacks on the basic case of Marble (v1.0/1.2) under vari-
able associated data (in our earlier work [17, 18]), fol-
lowing Fuhr et al.’s attack [10] on Marble v1.1. Each
attack has a data/time/memory complexity of about
265. However, since Fuhr et al.
recently extended
their attack on Marble v1.1 to Marble v1.2 in the ﬁnal
publication version [11] of the earlier work [10], who
acknowledged our attacks by writing ‘as shown inde-
pendently by ourselves and Lu’, we only focus on a
diﬀerent forgery way for an almost universal forgery
on Marble v1.0/1.1 in this ﬁnal publication version of
our work.
Table 1 summarises previously published and our main
(almost) universal forgery attacks on COPA and Marble.
Our attacks on COPA and AES-COPA do not violate their
birthday-bound security proof on integrity, but the attack
on AES-COPA violates its full (i.e. 128-bit) security claim
or conjecture on tag guessing. In summary, our attacks sug-
gest that the full security claim and conjecture on tag guess-
ing of AES-COPA and the full security claim on authentic-
ity of Marble are incorrectly far overestimated in the sense
of a general understanding of full security of these security
notions. More speciﬁcally, our attacks have the following
meanings: