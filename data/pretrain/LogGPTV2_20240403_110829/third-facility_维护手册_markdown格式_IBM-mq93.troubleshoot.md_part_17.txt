sib.test.svt.lite.mdb.xa.MDBProxyQueueReceiver_37ea5ce9.onMessage(MDBProxyQueueReceiver_37ea5ce9.j
ava:-1)
:
com.ibm.mq.jakarta.connector.inbound.MessageEndpointWrapper.onMessage(MessageEndpointWrapper.java:
151)
:
com.ibm.mq.jms.MQSession$FacadeMessageListener.onMessage(MQSession.java:129)
:
com.ibm.msg.client.jms.internal.JmsSessionImpl.run(JmsSessionImpl.java:3236)
: com.ibm.mq.jms.MQSession.run(MQSession.java:937)
:
com.ibm.mq.jakarta.connector.inbound.ASFWorkImpl.doDelivery(ASFWorkImpl.java:104)
:
com.ibm.mq.jakarta.connector.inbound.AbstractWorkImpl.run(AbstractWorkImpl.java:233)
: com.ibm.ejs.j2c.work.WorkProxy.run(WorkProxy.java:668)
: com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1892)
Caused by [2] --> Message : com.ibm.websphere.ce.j2c.ConnectionWaitTimeoutException:
CWTE_NORMAL_J2CA1009
Class : class
com.ibm.websphere.ce.j2c.ConnectionWaitTimeoutException
Stack : com.ibm.ejs.j2c.FreePool.createOrWaitForConnection(FreePool.java:1783)
:
com.ibm.ejs.j2c.PoolManager.reserve(PoolManager.java:3840)
: com.ibm.ejs.j2c.PoolManager.reserve(PoolManager.java:3116)
:
com.ibm.ejs.j2c.ConnectionManager.allocateMCWrapper(ConnectionManager.java:1548)
:
com.ibm.ejs.j2c.ConnectionManager.allocateConnection(ConnectionManager.java:1031)
:
com.ibm.ejs.jms.JMSContextHandle.setupInternalContext(JMSContextHandle.java:222)
:
com.ibm.ejs.jms.JMSManagedConnection.getConnection(JMSManagedConnection.java:783)
:
com.ibm.ejs.j2c.MCWrapper.getConnection(MCWrapper.java:2336)
:
com.ibm.ejs.j2c.ConnectionManager.allocateConnection(ConnectionManager.java:1064)
:
com.ibm.ejs.jms.JMSConnectionFactoryHandle.createContextInternal(JMSConnectionFactoryHandle.java:4
43)
:
com.ibm.ejs.jms.JMSConnectionFactoryHandle.createContext(JMSConnectionFactoryHandle.java:335)
:
sib.test.svt.lite.mdb.xa.SVTMDBBase.sendReplyMessage(SVTMDBBase.java:554)
:
sib.test.svt.lite.mdb.xa.QueueReceiverBean.onMessage(QueueReceiverBean.java:128)
:
sib.test.svt.lite.mdb.xa.MDBProxyQueueReceiver_37ea5ce9.onMessage(MDBProxyQueueReceiver_37ea5ce9.j
ava:-1)
:
com.ibm.mq.jakarta.connector.inbound.MessageEndpointWrapper.onMessage(MessageEndpointWrapper.java:
151)
:
com.ibm.mq.jms.MQSession$FacadeMessageListener.onMessage(MQSession.java:129)
:
com.ibm.msg.client.jms.internal.JmsSessionImpl.run(JmsSessionImpl.java:3236)
: com.ibm.mq.jms.MQSession.run(MQSession.java:937)
:
IBM MQ troubleshooting and support 103
com.ibm.mq.jakarta.connector.inbound.ASFWorkImpl.doDelivery(ASFWorkImpl.java:104)
:
com.ibm.mq.jakarta.connector.inbound.AbstractWorkImpl.run(AbstractWorkImpl.java:233)
: com.ibm.ejs.j2c.work.WorkProxy.run(WorkProxy.java:668)
: com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1892)
Lower-level pool example (JMS 2.0)
***********************
[8/19/16 9:44:44:754 UTC] 000000ac SibMessage W [:] CWSJY0003W: MQJCA4004: Message delivery to
an MDB
'sib.test.svt.lite.mdb.xa.MDBProxyQueueReceiver_37ea5ce9@505d4b68
(BeanId(SibSVTLiteMDB#SibSVTLiteMDBXA_RecoveryEJB_undeployed.jar#QueueReceiver, null))' failed
with exception:
'nested exception is: javax.jms.JMSRuntimeException: Failed to set up new JMSContext'.
ˆC[root@username-instance-2 server1]# vi SystemOut.log
:com.ibm.ejs.j2c.work.WorkProxy.run(WorkProxy.java:668)
: com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1892)
Caused by [1] --> Message : javax.jms.JMSRuntimeException: Failed to set up new
JMSContext
Class : class javax.jms.JMSRuntimeException
Stack :
com.ibm.ejs.jms.JMSCMUtils.mapToJMSRuntimeException(JMSCMUtils.java:522)
:
com.ibm.ejs.jms.JMSContextHandle.setupInternalContext(JMSContextHandle.java:241)
:
com.ibm.ejs.jms.JMSManagedConnection.getConnection(JMSManagedConnection.java:783)
:
com.ibm.ejs.j2c.MCWrapper.getConnection(MCWrapper.java:2336)
:
com.ibm.ejs.j2c.ConnectionManager.allocateConnection(ConnectionManager.java:1064)
:
com.ibm.ejs.jms.JMSConnectionFactoryHandle.createContextInternal(JMSConnectionFactoryHandle.java:4
43)
:
com.ibm.ejs.jms.JMSConnectionFactoryHandle.createContext(JMSConnectionFactoryHandle.java:335)
:
sib.test.svt.lite.mdb.xa.SVTMDBBase.sendReplyMessage(SVTMDBBase.java:554)
:
sib.test.svt.lite.mdb.xa.QueueReceiverBean.onMessage(QueueReceiverBean.java:128)
:
sib.test.svt.lite.mdb.xa.MDBProxyQueueReceiver_37ea5ce9.onMessage(MDBProxyQueueReceiver_37ea5ce9.j
ava:-1)
:
com.ibm.mq.connector.inbound.MessageEndpointWrapper.onMessage(MessageEndpointWrapper.java:151)
:
com.ibm.mq.jms.MQSession$FacadeMessageListener.onMessage(MQSession.java:129)
:
com.ibm.msg.client.jms.internal.JmsSessionImpl.run(JmsSessionImpl.java:3236)
: com.ibm.mq.jms.MQSession.run(MQSession.java:937)
:
com.ibm.mq.connector.inbound.ASFWorkImpl.doDelivery(ASFWorkImpl.java:104)
:
com.ibm.mq.connector.inbound.AbstractWorkImpl.run(AbstractWorkImpl.java:233)
: com.ibm.ejs.j2c.work.WorkProxy.run(WorkProxy.java:668)
: com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1892)
Caused by [2] --> Message : com.ibm.websphere.ce.j2c.ConnectionWaitTimeoutException:
CWTE_NORMAL_J2CA1009
Class : class
com.ibm.websphere.ce.j2c.ConnectionWaitTimeoutException
Stack : com.ibm.ejs.j2c.FreePool.createOrWaitForConnection(FreePool.java:1783)
:
com.ibm.ejs.j2c.PoolManager.reserve(PoolManager.java:3840)
: com.ibm.ejs.j2c.PoolManager.reserve(PoolManager.java:3116)
:
com.ibm.ejs.j2c.ConnectionManager.allocateMCWrapper(ConnectionManager.java:1548)
:
com.ibm.ejs.j2c.ConnectionManager.allocateConnection(ConnectionManager.java:1031)
:
com.ibm.ejs.jms.JMSContextHandle.setupInternalContext(JMSContextHandle.java:222)
:
com.ibm.ejs.jms.JMSManagedConnection.getConnection(JMSManagedConnection.java:783)
:
com.ibm.ejs.j2c.MCWrapper.getConnection(MCWrapper.java:2336)
:
com.ibm.ejs.j2c.ConnectionManager.allocateConnection(ConnectionManager.java:1064)
:
com.ibm.ejs.jms.JMSConnectionFactoryHandle.createContextInternal(JMSConnectionFactoryHandle.java:4
104 Troubleshooting and Support for IBM MQ
43)
:
com.ibm.ejs.jms.JMSConnectionFactoryHandle.createContext(JMSConnectionFactoryHandle.java:335)
:
sib.test.svt.lite.mdb.xa.SVTMDBBase.sendReplyMessage(SVTMDBBase.java:554)
:
sib.test.svt.lite.mdb.xa.QueueReceiverBean.onMessage(QueueReceiverBean.java:128)
:
sib.test.svt.lite.mdb.xa.MDBProxyQueueReceiver_37ea5ce9.onMessage(MDBProxyQueueReceiver_37ea5ce9.j
ava:-1)
:
com.ibm.mq.connector.inbound.MessageEndpointWrapper.onMessage(MessageEndpointWrapper.java:151)
:
com.ibm.mq.jms.MQSession$FacadeMessageListener.onMessage(MQSession.java:129)
:
com.ibm.msg.client.jms.internal.JmsSessionImpl.run(JmsSessionImpl.java:3236)
: com.ibm.mq.jms.MQSession.run(MQSession.java:937)
:
com.ibm.mq.connector.inbound.ASFWorkImpl.doDelivery(ASFWorkImpl.java:104)
:
com.ibm.mq.connector.inbound.AbstractWorkImpl.run(AbstractWorkImpl.java:233)
: com.ibm.ejs.j2c.work.WorkProxy.run(WorkProxy.java:668)
: com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1892)
Troubleshooting JMSCC0108 messages
There are a number of steps that you can take to prevent a JMSCC0108 message from occurring when
you are using activation specifications and WebSphere Application Server listener ports that are running
in Application Server Facilities (ASF) mode.
When you are using activation specifications and WebSphere Application Server listener ports that are
running in ASF mode, which is the default mode of operation, it is possible that the following message
might appear in the application server log file:
JMSCC0108: The IBM MQ classes for JMS had detected a message, ready for asynchronous delivery to
an application.
When delivery was attempted, the message was no longer available.
Use the information in this topic to understand why this message appears, and the possible steps that you
can take to prevent it from occurring.
How activation specifications and listener ports detect and process messages
An activation specification or WebSphere Application Server listener port performs the following steps
when it starts up:
1.Create a connection to the queue manager that they have been set to use.
2.Open the JMS destination on that queue manager that they have been configured to monitor.
3.Browse that destination for messages.
When a message is detected, the activation specification or listener port performs the following steps:
1.Constructs an internal message reference that represents the message.
2.Gets a server session from its internal server session pool.
3.Loads the server session up with the message reference.
4.Schedules a piece of work with the application server Work Manager to run the server session and
process the message.
The activation specification or listener port then goes back to monitoring the destination again, looking for
another message to process.
The application server Work Manager runs the piece of work that the activation specification or listener
port submitted on a new server session thread. When started, the thread completes the following actions:
• Starts either a local or global (XA) transaction, depending on whether the message-driven bean requires
XA transactions or not, as specified in the message-driven bean's deployment descriptor.
• Gets the message from the destination by issuing a destructive MQGET API call.
• Runs the message-driven bean's onMessage() method.
IBM MQ troubleshooting and support 105
• Completes the local or global transaction, once the onMessage() method has finished.
• Return the server session back to the server session pool.
Why the JMSCC0108 message occurs, and how to prevent it
The main activation specification or listener port thread browses messages on a destination. It then asks
the Work Manager to start a new thread to destructively get the message and process it. This means that
it is possible for a message to be found on a destination by the main activation specification or listener
port thread, and no longer be available by the time the server session thread attempts to get it. If this
happens, then the server session thread writes the following message to the application server’s log file:
JMSCC0108: The IBM MQ classes for JMS had detected a message, ready for asynchronous delivery to
an application.
When delivery was attempted, the message was no longer available.
There are three reasons why the message is no longer on the destination when the server session thread
tries to get it:
• Reason 1: The message has been consumed by another application
• Reason 2: The message has expired
• Reason 3: ReadAhead is enabled for the destination from which the activation specification or listener
port is consuming messages
Reason 1: The message has been consumed by another application
If two or more activation specifications and/or listener ports are monitoring the same destination, then it
is possible that they could detect the same message and try to process it. When this happens:
• A server session thread started by one activation specification or listener port gets the message and
delivers it to a message-driven bean for processing.
• The sever session thread started by the other activation specification or listener port tries to get the
message, and finds that it is no longer on the destination.
If an activation specification or listener port is connecting to a queue manager in any of the following
ways, the messages that the main activation specification or listener port thread detects are marked:
• A queue manager on any platform, using IBM MQ messaging provider normal mode.
• A queue manager on any platform, using IBM MQ messaging provider normal mode with restrictions
• A queue manager running on z/OS, using IBM MQ messaging provider migration mode.
Marking a message prevents any other activation specification or listener port from seeing that message,
and trying to process it.
By default, messages are marked for five seconds. After the message has been detected and marked, the
five second timer starts. During these five seconds, the following steps must be carried out:
• The activation specification or listener port must get a server session from the server session pool.
• The server session must be loaded with details of the message to process.
• The work must be scheduled.
• The Work Manager must process the work request and start the server session thread.
• The server session thread needs to start either a local or global transaction.
• The server session thread needs to destructively get the message.
On a busy system, it might take longer than five seconds for these steps to be carried out. If this happens,
then the mark on the message is released. This means that other activation specifications or listener
ports can now see the message, and can potentially try to process it, which can result in the JMSCC0108
message being written to the application server’s log file.
In this situation, you should consider the following options:
106 Troubleshooting and Support for IBM MQ
• Increase the value of the queue manager property Message mark browse interval (MARKINT), to give
the activation specification or listener port that originally detected the message more time to get it.
Ideally, the property should be set to a value greater than the time taken for your message-driven beans
to process messages. This means that, if the main activation specification or listener port thread blocks
waiting for a server session because all of the server sessions are busy processing messages, then
the message should still be marked when a server session becomes available. Note that the MARKINT
property is set on a queue manager, and so is applicable to all applications that browse messages on
that queue manager.
• Increase the size of the server session pool used by the activation specification or listener port.
This would mean that there are more server sessions available to process messages, which should
ensure that messages can be processed within the specified mark interval. One thing to note with this
approach is that the activation specification or listener port will now be able to process more messages
concurrently, which could impact the overall performance of the application server.
If an activation specification or listener port is connecting to a queue manager running on
IBM MQ for Multiplatforms, using IBM MQ messaging provider migration mode, the marking functionality
is not available. This means that it is not possible to prevent two or more activation specifications and/or
listener ports from detecting the same message and trying to process it. In this situation, the JMSCC0108
message is expected.
Reason 2: The message has expired
The other reason that a JMSCC0108 message is generated is if the message has expired in between being
detected by the activation specification or listener port and being consumed by the server session. If this
happens, when the server session thread tries to get the message, it finds that it is no longer there and so
reports the JMSCC0108 message.
Increasing the size of the server session pool used by the activation specification or listener port can
help here. Increasing the server session pool size means that there are more server sessions available
to process messages, which can potentially mean that the message is processed before it expires. It is
important to note that the activation specification or listener port is now able to process more messages
concurrently, which could impact the overall performance of the application server.
Reason 3: ReadAhead is enabled for the destination from which the activation
specification or listener port is consuming messages
ReadAhead operates:
• On Non-persistent messages outside of syncpoint
• When browsing messages
Browsing messages is what an IBM MQ activation specification or WebSphere Application Server listener
port does, before destructively consuming the message.
As a consequence, rather than browsing just a single message when the activation specification browsing
thread starts, it might browse (for example) 100 messages in one go, and then slowly feed them to
threads to destructively be consumed from the queue, and given to the application message driven bean
class to process.
As the default value of the queue manager property Message mark browse interval (MARKINT), for
browsed messages to be consumed before being browsed again, is five seconds, this typically results in
the same message being browsed a second time by the activation specification, or by another browsing
thread if there are multiple Java Extended Edition servers running an activation specification against the
same queue, before the message driven bean has had time to process all of the messages which were
initially browsed.
Only the first destructively consuming thread gets the message. All subsequent destructively consuming
threads are given an MQRC 2033 return code from the queue manager, which is turned into the
JMSCC0108 message. Also, before returning the 2033 return code, the queue manager searches for
IBM MQ troubleshooting and support 107
the message across the entire queue which, if the queue is deep - some thousands of messages, can take
a significant amount of time.
CWSJY0003W warning messages in WebSphere Application Server
SystemOut.log file
A CWSJY0003W warning message is logged in the WebSphere Application Server SystemOut.log file
when an MDB processes JMS messages from IBM MQ.
Symptom