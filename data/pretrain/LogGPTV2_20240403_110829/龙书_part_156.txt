父结点，内部结点也可能具有多个父结点。比如，在图 12-31中最右的标号为z的结点有两个父
始我们假设所有的 BDD 都是排序的。
602
也可以在相反的方向上进行这两个转换。特别地，我们可以在从 N到 M的边上引人一个结
2）结点合并：如果两个结点N和M的两条低边都到达同一个结点，并且两条高边也到达同
1）短路：如果一个结点N的低边和高边都到达同--个结点M，那么我们可以消除N。原来
在上面的讨论中，我们提到了两个简化 BDD 的方法，它们可以使得 BDD 更加简洁：
还需要注意的是，BDD 是有向无环图（DAG），而不是树。不仅仅叶子结点0和1通常有很多
a)短路
图12-31
图12-32BDD的转换
一个二分决策图
b)结点合并
第12章
---
## Page 619
组所蕴含的头断言的关系。从表示这个关系的 BDD 的角度来说，我们需要消除其中的一些结点，
运算不仅用来构造初始关系，也用于把具有相同头断言的多个规则的结果合并起来，还会用于把
号。也就是说，如果使用上述编码方法，在那个图中的 BDD 表示了这个关系。
函数。请注意，这三个二进制序列恰巧就是图12-31中从根结点到达叶子结点1的路径上的标
码。那么关系就变成了：
作为α的编码，01 对应于 b，10 对应于c以及11 对应于 d。令关系的元组为：
些表示单个元组的 BDD 集成到表示大型关系的 BDD 中去。
成的主要的关系运算：
12.7.4用BDD 操作实现关系运算
例12.28
的例子可以说明这个想法。
数。该函数对于某个真假赋值返回真值，当且仅当这个赋值表示了此关系中的一个元组。下面
可以被看作是这组布尔变量的真假赋值。我们可以把关系看作是这组布尔变量上的一个布尔函
2^个可能值，那么它需要n个二进制位(或者说布尔变量)来表示这个域中的值。
变量，而第二个分量的域为所有对象创建语句。如果一个域具有多于2"-1个可能取值且不多于
的各个元组的相应分量的可能取值的集合。比如，关系 pts(V，H)的第一个分量的域为所有程序
12.7.3用BDD表示关系
“连接"起来。比如，假设我们有两个子目标r(A，B)&s(B，C)。这些子目标的关系的连接是满足下列
重新命名，以使得它们和头关系分量的布尔变量相对应。
这些结点的布尔变量标号没有用来表示头关系中的分量。我们可能还需要对 BDD 中的某些变量
新的断言事实合并到老事实的集合中去。算法12.18要求实现这些运算。
式求值)那样的算法，我们还需要能够操作BDD 以反映相应关系上的运算。下面给出了我们要完
4）连接：为了找出令－一个规则体为真的变量的赋值组合，我们需要把对应于各个子目标的关系
2）合并：为了表示关系的合并，我们使用布尔函数的逻辑OR运算来表示得到的关系。这个
1）初始化：我们需要创建一个 BDD 来表示一个关系的单个元组。我们将通过合并运算把这
因此，我们可以用一组布尔变量来表示关系元组的各个分量的域中的值。关系的一个元组
我们至今为止处理的关系都具有从“域”中取值的分量。
过程间分析
3）投影：当我们对--个规则体求值的时候，我们需要构造出由那些使得规则体取真值的元
现在，我们看到了如何把关系表示成 BDD。但是，要实现像算法12.18（Datalog 程序的增量
也就是说，关系r被转换成为一-个对三个真假赋值 wxyz= 0001、0010和1110 取真值的布尔
我们使用布尔变量 ux 来对第一个分量(A)进行编码，使用变量 yz 为第二个分量(B)进行编
考虑一个关系r(A,B)，其中A 和B的域都是α，b，c，d}。我们将把二进制位 00
x
P
Y
一个关系的某个分量的域是该关系
603
厂
---
## Page 620
二个 BDD 表示函数
例12.30
叶子结点合并。
的根结点，而它的高边子结点是第二个BDD 的根结点。
BDD 表示同样的函数，不过其中的y=1。
条件是：相应的真假赋值中y=0，并且它使得两个输人 BDD 中的一个或全部取真值。第二个
和 M为根的两个 BDD 应用这个算法。在得到的两个 BDD 中，第一个 BDD 表示的函数取真值的
别为 N, 和 M。对分别以 No和 Mg为根的两个 BDD 递归地应用这个算法。同时也对分别以 N,
是1，那么输出就是标号为1的叶子结点；如果两个输人都是0，那么输出叶子结点的标号是0。
大小进行归纳。
算法12.29
合并。
为00时)才取真值的函数。
后到达叶子结点1处。
到不正确的值，我们就直接跳转到叶子结点0。只有当所有变量的取值都正确时，我们才会在最
和低边顺序相反。
0或1。相应的 BDD 对于每个x;有一个结点 N;。如果α;=0，那么N;的高边直接到达叶子结点
和逻辑AND 运算类似，而逻辑AND 运算和在 BDD 上实现关系合并的逻辑OR 运算类似。
们将看到，在对 BDD 中的布尔变量重新命名，使得对应于两个B 分量的变量同名之后，这个BDD 操作
条件的三元组(α，b，c)的集合：(α,b)是r的关系中的--个元组，且(b，c)是s的关系的一个元组。我
5）在可能的时候应用合并和短路转换，简化得到的 BDD。
4）在刚刚通过合并得到的 BDD 中把两个标号为0的叶子结点合并，同时把两个标号为1的
 3）创建一个新的标号为y 的根结点。它的低边子结点是通过递归构造得到的第一个 BDD
归纳基础：零个变量。这两个 BDD 必然都是叶子结点，其标号是1或0。如果两个输人中有一-个
作为例子，可以回到前面的图 12-33b。这个 BDD 表示了一个当且仅当×=y=0（即真假赋值
604
输入：两个排序的 BDD，它们的变量集合相同，且排序也相同。
我们将详细地给出一-个算法来计算 BDD 的逻辑 OR，也就是这两个 BDD 所表示的关系的
这个策略给出了一个 BDD，它能够检查每个x;(=1，2，，n)是否具有正确的值。一旦找
2）设两个 BDD 的根为 N和 M，令它们的低边子结点分别为 N。和 M。，它们的高边子结点分
1）如果必要，使用反向的短路转换加人一个新的根，使得两个 BDD 的根的标号都是1o
方法：我们将描述一个合并两个 BDD 的递归过程。这个过程按照 BDD 中出现的变量集合的
输出：一个 BDD，它表示的函数是两个输人 BDD 所表示的布尔函数的逻辑 OR。
合并
为了初始化一个关系，我们需要使用一种方法来为那些只对单个真假赋值取真值的函数构
单一元组的BDD
在图 12-33a 和图12-33b 中有两个简单的 BDD。第一个 BDD 表示函数x OR y，而第
BDD 的合并。
NOT x AND NOT y
第12章
口
---
## Page 621
α)和(b，α)组成的关系。你可以用任意方式对布尔变量进行排序，以获取最简洁的 BDD。
12. 7.612. 7 节的练习
重
析
量级的上下文。特别是，如果我们随意使用编号来表示一个调用图中的上下文，那么我们甚至
也包括尝试和犯错。
地影响表示的大小。要得到一个能够使得分析很快结束的 BDD 变量排序，需要各种各样的考虑,
12.7.5在指针指向分析中使用BDD
BDD 就是叶子1 本身。
的叶子结点。当我们加人新的根结点×后，我们得到图12-33c中的 BDD。
BDID。这两个结点的低边子结点的标号分别为0和1，因此它们的低边子结点的合并是标号为1
点都在叶子层次上，所以不需要在每条边上插人标号为y的结点，尽管我们这么做会得到同样的
时，我们考虑两个根的低边子结点和它们的高边子结点。我们先考虑后者。
用
每个调用者－被调用者对之间的编码的数值总是相差--个常数。
月者对之间具有很多相似之处，所以我们希望对上下文进行编码的方式可以使得一个调用点
个方法的n个上下文连续编码是比较合适的。类似地，因为同一个调用点上的调用者－被
中的编码变得非常紧凑。同一方法的调用路径相似的两个上下文之间有很多共同点，因此对
处理很小的Java 程序。按照适当的方式对上下文进行编号是很重要的，它可以使指针指向分
使得上下文相关的指针指向分析能够有效执行是一件更加困难的事情，因为程序中有指娄
都是叶子结点1，因此我们可以消除根结点。也就是说，表示这个合并操作结果的最简单的
（1，因此我们可以把结点y删除，并把1当作根结点的低边子结点。现在，根结点的两个子结
子结点将成为新的根结点的高边结点。
！练习12.7.2：如果用最简洁的 BDD 来表示n个变量上的异或函数，那么这个 BDD 中有多
果。结点0和1的合并是算法中归纳基础的情况，合并后生成一个标号为1的叶子结点。这<
过程间分析
练习12.7.1：使用例子 12.28中的符号编码方式，生成一个 BDD 来表示由元组(6，6）、（c,
，人们发现，主动机器学习有助于获取较好的变量排序，使得算法能够高效地处理大型应用。
 我们还没有完成，因为图 12-33c 还可以进一步简化。标号为的结点的两个子结点都是结
图 12-33a 和图 12-33b 中的根的低边结点的标号都是y，因此我们递归地计算它们的合并
在图12-33a中，根的高边子结点是1，而在图 12-33b 中的相应子结点是0。因为这两个子结
要使上下文无关的指针指向分析能够正确工作已经很不容易了。BDD 变量的排序可以极大
请注意，它们的逻辑 OR 的结果是常量函数1，即永真函数。对这两个 BDD 应用算法12.29
图12-33
为逻辑OR构造BDD
605
奇
上
调
楼
---
## Page 622
12.8第12章总结
的情况就足够了：这两个关系都只有两个分量，且它们有一个公共分量。也就是说，这两个关系
是
属性上具有相同的值，这两个元组就组合起来成为新关系的一个元组。实际上，只需要考虑下面
真
被保留变量的真假赋值α，如果存在被消除变量的任何一个真假赋值，它和α一起使得原函数取
数个变量为真，那么这个函数就为真；如果有偶数个变量为真，那么函数值为假。
r(A,B)和s(B,C)。
2）把两个关系r和s连接起来，只要一个来自的元组和一个来自s的元组在和s的共同
值，那么结果函数的取值也是真。
606
●调用点：程序中调用其他过程的程序点称为调用点。在一个调用点上被调用的过程可能
●过程间分析：对跨越过程边界的信息进行跟踪的数据流分析称为过程间分析。很多分析
?调用图：一个程序的调用图是--个二分图，图的结点分为对应于调用点的结点和对应于
1）通过投影消除某些布尔变量。也就是说，运算得到的 BDD 所表示的函数如下：给定一个
！！练习12.7.4：找出在表示关系的排序 BDD 之上的进行下列关系运算的算法：
练习12.7.3：修改算法12.29，使之能够生成两个BDD 的交集（即逻辑AND）
Datalog 规则：一个 Datalog 规则由一个规则体（前提）和一个规则头(结果)组成。规则体
?
数的值可以是变量或常量。规则体的多个原子通过逻辑 AND 连接，而规则体中的原子可
是一个或多个原子，而规则头则是一-个原子。原子就是作用于一组参数的断言，这些参
Datalog：Datalog 语言是 if-then 规则的简单表示方式，它可以用于在高层次上描述数据流
被利用的方式使用这个输人。
这些漏洞的常见特性是一个过程从某个不可信的输人源读取数据，而另一个过程以可能
过程间分析技术的应用：需要过程间分析技术的重要应用之一是检测软件的安全漏洞。
的基于区域的分析技术。每个过程有一个传递函数，并且在每一个调用该过程的地方它
基于摘要的上下文相关分析：另一个过程间分析的方法，扩展原来为过程内分析而设计
进行求值。
术可以用来进行上下文相关分析。
以想象对于每个上下文都有一个该过程的克隆。按照这种方法，一个上下文无关分析技
基于克隆的上下文相关分析：从原则上讲，一旦我们建立了过程调用的不同上下文，就可
相关或者都不相关。
那么它就是控制流相关的。如果--个数据流分析得到的事实和过程调用的历史相关，那
控制流相关性和上下文相关性：如果--个数据流分析得到的事实和程序中的位置相关
拷贝，并对得到的程序使用过程内分析技术。从效果上看，这个分析是过程间分析。
内联：只要一个程序中没有递归，原则上我们可以把所有的过程调用替换为过程代码的
这个过程结点的边。
过程的结点。如果一个过程在一个调用点上被调用，那么就有--条从这个调用点结点到
的虚方法，那么被调用的过程也可能是不明确的。
是显然的。但是，如果这个调用是通过指针间接进行的，或者它调用的是具有多个实现
被
、它就是上下文相关的。一个数据流分析可以是控制流相关的、上下文相关的、两者都
当作一个区域处理。
第12章
---
## Page 623
间常量传播算法。
12.9第12章参考文献
过程间分析
过程间分析的一些基本概念可以在[1,6,7,21]中找到。Callahan 等[11］描述了－个过程
·IDB 和 EDB 断言：--个 Datalog 程序中的 EDB 断言的真值事实在事先给出。在一个数据
BDD 上的操作来实现。这些 BDD 表示了规则所涉及的断言。这个表示方法经常会得到
归调用的另一个过程(可能是调用者本身)的调用点。使用这样的表示方式，我们可以修
进行多轮求值。在每一轮中，我们只考虑如下的变量到常量的替换方法：它使得规则体
后得到的断言也为真。这个操作不断重复，直到不能推导出更多的事实为止。
取真值的常量。当我们做了这样的替换后，就可以推断将规则头中的变量进行相同替换
规则定义的。在一个数据流分析中，它们对应于我们想从被分析代码中抽取的信息。
流分析中，这些断言对应于那些可以从被分析代码中获取的事实。IDB 断言本身是通过
能是断言的否定形式。
一个比其他已知方法更加高效的实现。
使用 BDD 实现数据流分析：任何可以被表示为 Datalog 规则的数据流分析都可以使用