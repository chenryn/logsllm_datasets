between tainting and logging and the pruning of events (e.g.,
through ﬁle deletions) do not affect completeness. According
to the rules in Table I, within a unit, all input events are
captured and propagated to the taint set of the unit. With the
assumption that all the inter-unit workﬂows through memory
accesses are captured1, the taint set is properly propagated
across units. Upon an outgoing syscall, the set is logged. Dur-
ing ofﬂine analysis, causal edges are introduced by connecting
a log entry containing a taint (of an input ﬁle), such as taint F1
on edge 2 in Fig. 5, and a preceding log entry containing the
provenance set corresponding to the taint (e.g., the log entry
generated by the action on edge 1 in Fig. 5). This ensures not
only that the set of external sources is complete, but also the
history of the object is captured (by the causal graph). The way
1We will discuss situations where our assumptions may not hold in
Section VI.
that ProTracer prunes log entries related to temporary ﬁles is
safe because only the log entries related to a ﬁle owned by the
process are removed. When the ﬁle is owned, its information
cannot reach other processes. In the case that a temporary ﬁle is
copied to another permanent ﬁle, its provenance is completely
inherited by the permanent ﬁle so that the temporary ﬁle
log entries are no longer useful. ProTracer also precludes
syscalls caused by application logging as they introduce bogus
causality across units. Note that application log usually records
a subset of what ProTracer is already recording and is hence
redundant.
V. EVALUATION
In this section, we will show the evaluation results of
ProTracer. The experiments were conducted on ﬁve identical
machines with four cores and 4GB RAM. Most of the bina-
ries in our experiment machines have been instrumented by
BEEP [27].
A. Effectiveness
Daily Usage: In the ﬁrst experiment, we emulated the daily
(24 hours including break time) usage of ﬁve computer users,
and collected logs. To compare the space consumption, we run
both ProTracer and BEEP [27] at the same time during the
experiment. After the logs were generated, we also applied
LogGC [28] to garbage collect the BEEP logs to acquire the
reduced logs. To create workload diversity, we emulated users
exhibiting different usage patterns: User 1 uses the system to
run a web server for a group project. An FTP server is also
running in the same system; User 2 is new to Linux. He just
tries out various applications in the system and accesses his
personal emails and the Internet; User 3 is preparing for an
exam. She is mainly reading documents and watching video
lectures; User 4 uses vim a lot to ﬁnish his course project
report besides accessing the Internet; User 5 mainly uses the
system for watching movies and communicating with friends.
In addition, we performed an extended 3-month emulation of
user 1, whose machine is used as a server; and user 4, who
actively uses client programs.
We compare the number of log entries and the log ﬁle sizes
for BEEP, LogGC, and ProTracer. The results are presented
in Table. II. Columns 8 and 9 show the ratios between the
ProTracer logs and the BEEP logs, whereas the last
two
columns show the same ratios between the LogGC logs and
the BEEP logs. Observe that ProTracer can signiﬁcantly reduce
the number of events that need to be logged. On average,
ProTracer only needs to log 1.85%(Daily)/1.45%(3 months)
of the entries in BEEP. Since ProTracer records taint IDs,
our log ﬁle format is slightly more efﬁcient than BEEP and
LogGC. On average, ProTracer’s disk space consumption is
only 1.28%(Daily)/1.02%(3 months) of BEEP’s. The results
vary for different users because of the different workloads
and use patterns. Even in the worst case (user 1 that hosted
servers), ProTracer generated less than 4% of the log entries,
and consumed less than 2% of the disk space.
Compared to LogGC, ProTracer has better space efﬁciency
in most cases. This is reasonable because LogGC garbage-
collects events based on their reachability from live system
objects. In other words, events that do not contribute to any
10
3 Months
Daily
Applications
Logs
Server
Client
Average
1
2
3
4
5
Average
Apache
Vim
Firefox
W3M
ProFTPD
Wget
Mplayer
Pine
Xpdf
MC
BEEP
ProTracer
LogGC
# Items
Size(KB)
# Items
Size(KB)
# Items
Size(KB)
ProTracer/BEEP
# Item
Size
LogGC/BEEP
Size
# Item
274,242,874
500,928,294
387,585,584
157,839,158.66
168,269,687.89
163,054,423.27
3,610,501
1,730,339
2,221,662
3,768,783
2,471,859
2,760,629
3,262,452
1,089,732
3,672,740
368,752
48,374
873,205
858,236
59,125
56,083
7,823
1,673,830.40
581,389.08
743,986.67
1,265,993.45
829,968.11
1019033.54
4,570,766.23
370,508.82
4,655,331.54
259,001.72
12,183.53
189,782.34
188,811.93
21,285.72
9,534.20
9,026.81
3,371,453
7,844,783
5,608,118
133,159
37,205
9,558
52,009
23,998
51,186
47,305
11,215
302,873
25,793
689
7,938
240
648
64
26
880,584.40
2,437,009.51
1,658,796.95
45,429,888
30,449,339
37,939,614
21,311,715.08
10,037,472.39
15,674,593.74
30,830.20
8,873.10
2,245.02
16,078.02
7,226.04
13,086
31,380.62
3,053.91
288,344.52
18,068.22
124.80
897.81
16.00
286.72
16.00
8.00
637,596
293,957
3,382
183,947
22,248
228226
288,482
99,452
352,587
82,959
4,539
4212,847
0
642
0
0
280,576.00
98,768.73
1,351.68
60,139.52
8,970.24
89961.23
404,797.44
34,017.28
447,406.08
57,671.68
1,228.80
88,811.52
0.00
327.68
0.00
0.00
1.23%
1.57%
1.45%
3.69%
2.15%
0.43%
1.38%
0.97%
1.85%
1.45%
1.03%
7.70%
6.99%
1.42%
0.91%
0.03%
1.10%
0.11%
0.33%
0.56%
1.45%
1.02%
1.84%
1.53%
0.33%
1.27%
0.87%
1.28%
0.69%
0.82%
6.62%
6.98%
1.02%
0.47%
0.01%
1.35%
0.17%
0.09%
16.57%
6.08%
9.79%
17.66%
16.99%
0.15%
4.88%
0.90%
8.27%
8.84%
9.13%
9.60%
22.50%
9.38%
47.28%
0.00%
1.09%
0.00%
0.15%
13.50%
5.97%
9.61%
16.76%
16.99%
0.18%
4.75%
1.08%
8.83%
8.86%
9.18%
9.61%
22.27%
10.09%
46.80%
0.00%
1.54%
0.00%
0.00%
TABLE II: Comparison of effectiveness of various systems with different duration (3 months and 24 hours); users, and
applications.
live system objects are removed. ProTracer not only avoids
logging such dead events (Section IV), but also precludes
redundant events that affect live system objects (e.g. repetitive
socket reads from the same session and execution units that
do not access any taint sources but rather serve as part of the
information ﬂow path). In some cases, LogGC is more space
efﬁcient (e.g. user 3). This is mainly due to temporary ﬁles.
LogGC is an ofﬂine log reduction method, which has sufﬁcient
information to precisely decide if a ﬁle is temporary. ProTracer
uses the log buffer to delay writing log entries to the disk,
hoping that the temporary ﬁle related entries will be removed
by the time the buffer is ﬂushed. However, some temporary
ﬁles related log entries will be ﬂushed to disk if the ﬁles are not
deleted by the time the buffer is ﬂushed. Besides, ProTracer
also logs events that belong to the start and end phases of
an execution, whereas BEEP/LogGC ignores those events. For
user 3, MPlayer and Xpdf were frequently used and they
produced a large number of temporary ﬁles. LogGC was able
to remove all the records that belong to these two programs,
whereas ProTracer keeps some of them. Also observe that on
average, ProTracer only generates 13MB log per day, which
is very affordable.
Application Perspective: We also compare the space con-
sumption of the different systems on various applications.
The logs speciﬁc to applications are extracted from the whole
system logs. The results are presented in the lower half of
Table II. Observe that the ProTracer logs are signiﬁcantly
smaller compared to BEEP Logs. The number of records is
reduced to less than 8%, and the log size shrinks to less
than 7% for all programs. The results vary across different
applications due to the different behavioral patterns of the
applications. For browsers like Firefox, accessing a single
web page can introduce many taints as it may access the web
server, advertisement server, image storage server and so on.
Since each resource request will cause a log entry, the log
buffer is ﬁlled up much faster and more frequently, compared
to other applications. As a result, ProTracer records more
temporary ﬁles related events. Programs like Xpdf interact
with ﬁles and the screen. There is no outgoing information
via sockets or other ﬁles. ProTracer only needs to record a
small number of events in the start and the end phases. For
most programs, ProTracer occupies less space than LogGC.
But for some of them (e.g. Xpdf), LogGC performs better.