3
Figure 7: (a) Average block coverage rate of running FDg and
FDm with or without merging to fuzz WebKit for 24 hours;
(b) Number of basic blocks covered by the PoCs of seven
security-related crashes that are not visited by FDm at dif-
ferent times during a 24-hour fuzzing process.
2.62% coverage improvement, FDm finds nearly 3.8× fewer unique
crashes on average compared to FDg. FDm misses around 75%
unique crashes, including seven security-related ones found by FDg
during three 24-hour runs. To further study the failure of coverage-
guided fuzzing, we determine the minimal basic blocks required
to be covered for triggering the seven crashes and observe how
FDm approaches the crashes (i.e., covers those code blocks) during a
fuzzing run. Figure 7(b) presents the result, which shows that FDm
is extremely close to most of the crashes after four hours. However,
due to an increasing number of interesting testcases waiting to be
mutated, FDm tries to expand its coverage without any particular
direction and thus fails to make a final push to trigger any of the
crashes in the remaining 20 hours. Though FDg blindly generates
the documents that can never explore the browser code thoroughly
in process of time, at least FDg consistently tests certain deep code
paths through every execution due to the fact that a generated
document has a large size and rich semantics. By contrast, code
coverage makes FDm that starts with a blank document wander
around numerous shallow code paths and cannot move downward
for a long time because of the extreme complexity of a DOM engine.
In general, blackbox generation is not comprehensive but is still
recommended for discovering a vast number of bugs in a DOM
engine in a reasonable time. Meanwhile, coverage-driven mutation
is also considered an irreplaceable approach, especially for finding
the bugs that occur with exacting conditions. One more advantage
of mutation-based fuzzing is that minimizing its crashing docu-
ments of much smaller sizes is less time consuming. We also believe
that its performance can be largely improved with more computing
resources and better seeding inputs (see §7.2).
6.4 High-Throughput Executions
We finally present several micro-benchmarks to evaluate the effi-
ciency and effectiveness of our self-terminating browser.
Performance. Table 4 shows that the throughput of an optimized
browser arrives at most 74.7 executions per second when used in
the coverage-guided fuzzing. Considering using a 5-second hard
time limit, the maximum throughput in theory is only 20 executions
per second with 100 cores, which is 3.74× fewer. We also perform a
stress test by running the optimized browser with large documents
generated by FDg to understand the least throughput improvement
we can achieve. In particular, FDg fuzzes our custom WebKit build
under the same setting used in §6.2. The evaluation result shows that
FDg can test around 26.92 documents per second with a dynamic
alarm, which is 1.48× more than the throughput of fuzzing the
original WebKit with a 5-second limit.
False negatives. We then justify that the dynamic alarm rarely
makes a browser instance terminate too early to trigger an expected
crash in practice. Regarding a total of 112 unique crashes found by
FDg in the original WebKit, our optimized WebKit can trigger 97%
of them, including all of the 11 security-related crashes. Particularly,
we observe two types of crashes that are not reproduced by the
optimized WebKit. First, one missed crash involves an SVG ani-
mation with specific timing control. The PoC of the crash sets the
attribute max="1s" for an SVG  element [51], which specifies
the maximum animation duration. If we set the attribute value be-
low 300ms, the crash can be triggered again under the optimization.
Generating relatively small timing values is considered practical
to avoid such a case. The other type of missed crashes involve a
window.requestAnimationFrame(f) call, which registers a function
f that is invoked by the browser before repainting the window [50].
Due to the unique feature of the API, it is infeasible to control
when f starts to execute. Therefore, we cannot find a general way
to prevent such a missed crash with optimization. Based on our
finding, one workaround is to use setTimeout(f, delay) instead,
which allows us to schedule the execution of f to a certain extent.
7 DISCUSSION
We now discuss the limitations and future directions of FreeDom.
7.1 More Discussions on FD-IR
Limitations of FD-IR. First, FreeDom currently does not support
parsing an existing HTML document into FD-IR. Developing a tran-
spiler to achieve this is technically feasible, as FD-IR strictly follows
the specification. Next, FD-IR does not cover various web APIs such
as Canvas, Audio and IndexedDB APIs [27, 29, 32]. As they are also
used with JavaScript, we can support them with minimal efforts. In
addition, different browsers do not provide exactly the same sup-
port of certain character encodings, HTML tags, CSS functions, and
DOM APIs [10, 30, 31], which are not handled by FD-IR. Thanks
to its strong programmability, it is possible to make FD-IR to se-
lectively enable or disable DOM features depending on the target
browser. Lastly, FreeDom involves a great deal of engineering effort
to implement numerous FD-IR Values (see §4.2). To minimize the
manual labor, the code of the Values that are context-independent
can be automatically emitted from existing grammars.
0.00.20.40.60.81.0Time(h)0.00.20.40.60.81.001020404244464850Blockcoveragerate(%)(a)CoverageFDgFDm(w/omerge)FDm01020050100150200250300350Numberofunvisitedblocks(a)DistancetowardthecrashesSession 3E: Fuzzing/Trusted Execution Environments CCS '20, November 9–13, 2020, Virtual Event, USA981CCS ’20, November 9–13, 2020, Virtual Event, USA
Wen Xu, Soyeon Park, and Taesoo Kim
Generalizability of FD-IR. Besides HTML documents, FD-IR
can be generalized to fuzz other complicated file formats by mainly
adding new Value instances with custom generation, mutation, and
lowering methods. FD-IR is mostly suitable for targeting the tree-
like formats that consist of interdependent fields, such as PDF [6],
Microsoft Office Open XML [40], Apple property list files [3], and
hierarchical filesystems [2, 45]. Meanwhile, extending FD-IR to
describe the API calls of other systems like RPC services and OS
kernels is also practicable by adding new API formats and lowering
methods for other languages or encodings besides JavaScript.
7.2 Potentials of Coverage-driven DOM fuzzing
Our performance comparison between FDm and FDg does not nec-
essarily justify one approach is superior than the other. In particular,
we propose future research directions for coverage-driven DOM
fuzzing, which can be implemented by using FDm.
Corpus-based fuzzing. Recent mutation-based fuzzers [20, 22,
41] achieve great success by leveraging a high-quality corpus. With
respect to DOM engines, all the mainstream browsers maintain their
regression and unit test suites that contain thousands of HTML
documents. Once we support lifting documents in plaintext into
FD-IR, FDm is likely to have better performance by starting with
these existing testcases.
Intelligent seed scheduling. FDm now simply prefers to further
mutate the testcases that are generated more recently. Nevertheless,
it is worthwhile to extend FDm with various recent testcase sched-
uling algorithms [8, 9, 43, 44], which are proven to be effective in
discovering more deep program paths in many general applications.
Non-compliant document fuzzing. FD-IR now strictly observes
the DOM standard. Nevertheless, all the mainstream browsers try
to load even a non-standard document as much as possible with
automatic repair in their own ways. For instance, some browsers
automatically complete non-closing HTML tags in a document or
still display an SVG document that involves incorrect transform
functions to a certain extent. FreeDom based on FD-IR is thus un-
able to find the bugs in the related code. On the one hand, the design
principle of FD-IR is still essential to FDg, which will blindly pro-
duce numerous invalid documents with common errors if FD-IR’s
non-complicance with the standard cannot be fully handled by the
browser. On the other hand, FDm can work effectively with modi-
fied FD-IR that describes and mutates documents in a non-standard
manner, because code coverage helps to self-correct its mutation
directions for avoiding repetitive loading errors and effectively
explore autocorrection in the browser.
8 RELATED WORK
DOM fuzzing. The pioneering DOM fuzzers [23, 28, 47, 58] em-
bedded themselves in a page loaded by the target browser and called
random DOM APIs on-the-fly. For example, domfuzz [28] randomly
acts on the DOM tree of a web page with 35 fuzzing modules.
Cross_fuzz [58] focuses on visiting DOM tree nodes and creating
circular references among them to stress memory management.
SDF [23] proposes an integration of several DOM fuzzers for better
performance. All of those dynamic fuzzers are no longer maintained
and the generate-and-test fuzzers have become mainstream. Qu et
al. [7] find more than 100 use-after-free bugs by generating paired
DOM operations based on static rules. Domato [11], Dharma [34],
Avalanche [33], and Wadi [47] are recent generation-based fuzzers
based on context-free grammars. FreeDom is also a static DOM
fuzzer but works in a context-aware manner.
Generation-based versus mutation-based fuzzing. Generation-
based fuzzing has been long established, especially for a structural
input format not limited to HTML documents. For example,
Peach [42] is known for generating the inputs of any format that
can be expressed as a grammar definition. Jsfunfuzz [38] constructs
random code chunks for testing JavaScript engines. Csmith [56]
generates random C source text for stress-testing compilers. On the
other side, more and more fuzzers nowadays also mutate existing
testcases. A series of JavaScript engine fuzzers [4, 19, 21, 53, 54]
transform existing JavaScript programs into new ones for testing.
Syzkaller [18] mutates system calls for fuzzing OS kernels. As
a font fuzzer, BrokenType can generate valid TTF files and also
mutate them in a structure-aware manner. In the DOM fuzzing
field, FreeDom is considered the first static fuzzer to work both
generatively and mutationally guided by coverage.
Structure-aware versus context-aware fuzzing. To generate
valid payload for testing, smart fuzzers are aware of input format
or grammar. For example, the aforementioned DOM and JavaScript
engine fuzzers always produce syntactically correct HTML files and
JavaScript programs. Nevertheless, recent research reveals the im-
portance of leveraging context information for reducing semantic
errors in generated inputs. For example, CodeAlchemist [20] assem-
bles JavaScript code with guaranteed type correctness. Janus [55],
a filesystem fuzzer, maintains the status of every file and directory
on an image for generating valid file operations.
9 CONCLUSION
In this work, we propose FreeDom, an evolutionary static DOM
fuzzer, that supports fuzzing HTML documents generatively and
mutationally. FreeDom relies on a newly designed IR to describe
both structures and context information of a document so as to
avoid semantic errors. In addition, FreeDom also utilizes a dynamic
timeout mechanism to largely improve the browser throughput
by 1.48–3.74×. We have reported 24 bugs found by FreeDom in
mainstream browsers. In particular, FreeDom that adopts context-
aware generation can find 3× more unique crashes than the state-of-
the-art fuzzer, Domato. FreeDom also finds several bugs in WebKit’s
SVG renderer, where another recent fuzzer, Dharma, fails to trigger
any crash. Compared to blackbox generation, FreeDom guided
by coverage covers 2.62% more code blocks and discovers several
new bugs, but meanwhile triggers a total of 3.8× fewer crashes.
Nevertheless, we expect further research based on FreeDom for an
improved utilization of code coverage in DOM fuzzing.
10 ACKNOWLEDGMENT
We thank the anonymous reviewers for their helpful feedback. This
research was supported, in part, by the NSF award CNS-1563848,
CNS-1704701, CRI-1629851 and CNS-1749711 ONR under grant
N00014-18-1-2662, N00014-15-1-2162, N00014-17-1-2895, DARPA
AIMEE, and ETRI IITP/KEIT[2014-3-00035], and gifts from Face-
book, Mozilla, Intel, VMware, and Google.
Session 3E: Fuzzing/Trusted Execution Environments CCS '20, November 9–13, 2020, Virtual Event, USA982FreeDom: Engineering a State-of-the-Art DOM Fuzzer
CCS ’20, November 9–13, 2020, Virtual Event, USA
REFERENCES
[1] Aldeid. Bf3. https://www.aldeid.com/wiki/Bf3 (visited on September 12, 2020).
[2] Apple Inc. HFS Plus Volume Format. https://developer.apple.com/library/archive/
technotes/tn/tn1150.html (visited on September 12, 2020).
[3] Apple Inc.
Property List Programming Topics for Core Foundation.
https://developer.apple.com/library/archive/documentation/CoreFoundation/
Conceptual/CFPropertyLists/CFPropertyLists.html (visited on September 12,
2020).
[4] Aschermann, C., Frassetto, T., Holz, T., Jauernig, P., Sadeghi, A.-R., and
Teuchert, D. Nautilus: Fishing for deep bugs with grammars. In Proceedings
of the 2019 Annual Network and Distributed System Security Symposium (NDSS)
(San Diego, CA, Feb. 2019).
[5] Beterke, F., Geshev, G., and Plaskett, A. Apple Safari - PWN2OWN Desktop
Exploit. https://labs.f-secure.com/assets/BlogFiles/apple-safari-pwn2own-vuln-
write-up-2018-10-29-final.pdf (visited on September 12, 2020).
[6] Bienz, T., Cohn, R., and Systems, A. Portable document format reference manual.
Citeseer, 1993.
[7] Bo, Q., and Lu, R. POWER IN PAIRS: How one fuzzing template revealed over 100
IE UAF vulnerabilities. In Black Hat USA Briefings (Black Hat USA) (Amsterdam,
The Netherlands, Oct. 2014).
[8] Böhme, M., Pham, V.-T., Nguyen, M.-D., and Roychoudhury, A. Directed
greybox fuzzing. In Proceedings of the 24th ACM Conference on Computer and
Communications Security (CCS) (Dallas, TX, Oct.–Nov. 2017).
[9] Böhme, M., Pham, V.-T., and Roychoudhury, A. Coverage-based greybox
fuzzing as markov chain. In Proceedings of the IEEE Transactions on Software
Engineering (2017).
[10] Deveria, A. WebGL 2.0. https://caniuse.com/#feat=webgl2 (visited on September
12, 2020).
[11] Fratric, I. DOM fuzzer. https://github.com/googleprojectzero/domato (visited
on September 12, 2020).
[12] Fratric, I. The Great DOM Fuzz-off of 2017. https://googleprojectzero.blogspot.
com/2017/09/the-great-dom-fuzz-off-of-2017.html (visited on September 12,
2020).
[13] Fratric, I. WebKit Fuzzing. https://github.com/googleprojectzero/p0tools (vis-
ited on September 12, 2020).
[14] Google. Chrome Vulnerability Reward Program Rules. https://www.google.
com/about/appsecurity/chrome-rewards/index.html (visited on September 12,
2020).
[15] Google. ClusterFuzz. https://google.github.io/clusterfuzz (visited on September
12, 2020).
[16] Google. Issue 666246. https://bugs.chromium.org/p/chromium/issues/detail?id=
666246 (visited on September 12, 2020).
[17] Google. Issue 671328. https://bugs.chromium.org/p/chromium/issues/detail?id=
671328 (visited on September 12, 2020).
[18] Google. syzkaller is an unsupervised, coverage-guided kernel fuzzer. https:
//github.com/google/syzkaller (visited on September 12, 2020).
[19] Gross, S. Fuzzil: Coverage guided fuzzing for javascript engines. Master’s thesis,
TU Braunschweig, 2018.
[20] Han, H., Oh, D., and Cha, S. K. CodeAlchemist: Semantics-aware code generation
to find vulnerabilities in javascript engines. In Proceedings of the 2019 Annual
Network and Distributed System Security Symposium (NDSS) (San Diego, CA, Feb.
2019).
[21] Holler, C., Herzig, K., and Zeller, A. Fuzzing with code fragments. In Pro-
ceedings of the 21st USENIX Security Symposium (Security) (Bellevue, WA, Aug.
2012).
[22] Lee, S., Han, H., Cha, S. K., and Son, S. Montage: A Neural Network Language
In Proceedings of the 29th USENIX
Model-Guided JavaScript Engine Fuzzer.
Security Symposium (Security) (Boston, MA, Aug. 2020).
[23] Lin, Y.-D., Liao, F.-Z., Huang, S.-K., and Lai, Y.-C. Browser fuzzing by scheduled
mutation and generation of document object models. In Proceedings of the 49th
IEEE International Carnahan Conference on Security Technology (Taipei, Taiwan,
Sept. 2015).
[24] Liu, J., and Xu, C. Pwning Microsoft Edge Browser: From Memory Safety
Vulnerability to Remote Code Execution. POC.
[25] LLVM Project. libFuzzer - a library for coverage-guided fuzz testing. https:
//llvm.org/docs/LibFuzzer.html (visited on September 12, 2020).
[26] Microsoft Security Research and Defense.
VulnScan - Auto-
mated Triage and Root Cause Analysis of Memory Corruption Issues.
https://msrc-blog.microsoft.com/2017/10/03/vulnscan-automated-triage-and-
root-cause-analysis-of-memory-corruption-issues/ (visited on September 12,
2020).
[27] Mozilla. Canvas API. https://developer.mozilla.org/en-US/docs/Web/API/
Canvas_API (visited on September 12, 2020).
[28] Mozilla. DOM fuzzers. https://github.com/MozillaSecurity/domfuzz (visited on
September 12, 2020).
[29] Mozilla. IndexedDB API. https://developer.mozilla.org/en-US/docs/Web/API/
IndexedDB_API (visited on September 12, 2020).
[30] Mozilla. Localizations and character encodings. https://developer.mozilla.
org/en-US/docs/Web/Guide/Localizations_and_character_encodings (visited on
September 12, 2020).
[31] Mozilla. Vendor Prefix. https://developer.mozilla.org/en-US/docs/Glossary/
Vendor_Prefix (visited on September 12, 2020).
[32] Mozilla. Web Audio API. https://developer.mozilla.org/en-US/docs/Web/API/
Web_Audio_API (visited on September 12, 2020).
[33] Mozilla Security. Avalanche. https://github.com/MozillaSecurity/avalanche
(visited on September 12, 2020).
[34] Mozilla Security. dharma. https://github.com/MozillaSecurity/dharma (visited
on September 12, 2020).
[35] Mozilla Security. FFPuppet. https://github.com/MozillaSecurity/ffpuppet
(visited on September 12, 2020).
[36] Mozilla Security. Grizzly Browser Fuzzing Framework. https://blog.mozilla.
org/security/2019/07/10/grizzly (visited on September 12, 2020).
[37] Mozilla Security. Introducing the ASan Nightly Project. https://blog.mozilla.
org/security/2018/07/19/introducing-the-asan-nightly-project/ (visited on Sep-
tember 12, 2020).
[38] Mozilla Security.
JavaScript engine fuzzers.
MozillaSecurity/funfuzz (visited on September 12, 2020).
https://github.com/
[39] Mozilla Security. Writing an Adapter. https://github.com/MozillaSecurity/
grizzly/wiki/Writing-an-Adapter (visited on September 12, 2020).
[40] Paoli, J., Valet-Harper, I., Farqhar, A., and Sebestyen, I. Ecma-376 office
open xml file formats. http://www.ecmainternational.org/publications/standards/
Ecma-376.htm (visited on September 12, 2020).
[41] Park, S., Xu, W., Yun, I., Jang, D., and Kim, T. Fuzzing JavaScript Engines
with Aspect-preserving Mutation (to appear). In Proceedings of the 41st IEEE
Symposium on Security and Privacy (Oakland) (San Francisco, CA, May 2020).
[42] Peach Tech. Peach Fuzzer. https://sourceforge.net/projects/peachfuzz (visited
on September 12, 2020).
[43] Pham, V.-T., Böhme, M., Santosa, A. E., Caciulescu, A. R., and Roychoudhury,
A. Smart greybox fuzzing. In Proceedings of the IEEE Transactions on Software
Engineering (2019).
[44] Rebert, A., Cha, S. K., Avgerinos, T., Foote, J., Warren, D., Grieco, G., and
Brumley, D. Optimizing seed selection for fuzzing. In Proceedings of the 23rd
USENIX Security Symposium (Security) (San Diego, CA, Aug. 2014).
[45] Rodeh, O., Bacik, J., and Mason, C. Btrfs: The linux b-tree filesystem. ACM