### Frontend Enhancements for McSema
We have equipped McSema with IDA-Pro [60], a commercial decompiler, to fully leverage its potential. Additionally, we evaluated RetDec [68] and mctoll [80].

### Evaluation of RetDec and mctoll
**RetDec** is a reverse engineering toolchain developed by Avast that converts executables into LLVM IR and then decompiles the lifted IR into C code using llvmir2hll. Its design emphasizes support for static analysis and facilitates decompilation by reconstructing high-level C/C++ language features [22]. For the remainder of this paper, "RetDec" refers to the lifter component, and "llvmir2hll" refers to the decompiler.

**mctoll** is an open-source project maintained by Microsoft. Although not explicitly documented [81], we found that its code generation paradigm is similar to RetDec, indicating strong support for analysis-related tasks.

Both RetDec and mctoll generate LLVM IR that closely resembles compiled LLVM IR. We categorize the IR generated by these tools as high-level IR (HIR), distinct from the EIR lifted by McSema. While the visual representation of the IR from both lifters is similar, RetDec primarily recovers local variables and types, whereas mctoll emulates the computation of some CPU registers. This difference likely stems from the challenges in recovering certain local variables, making mctoll-lifted IR more challenging for static (data flow) analysis, as discussed in Section VI-B.

### BinRec: A Dynamic Lifter
We also examined BinRec (EuroSys â€™20 [18]), a recently released dynamic lifter. BinRec takes an executable as input and uses S2E [35], a symbolic execution engine, to discover program inputs leading to new execution paths. S2E runs executables within QEMU and generates LLVM IR traces for each logged execution path. S2E also provides RevGen [34] to lift executables into LLVM IR code, using IDA-Pro and McSema as front-ends [10]. Since our benchmark setup already includes McSema, we did not evaluate RevGen separately.

BinRec is the latest dynamic lifter in this field, with functional correctness as a primary design goal. Our study confirms that recompiled lifted IR code can be reused effectively as standalone executables. However, decompilation and other static analysis tasks are not explicit design goals of BinRec. BinRec performs emulation-style lifting, merging lifted IR traces into a single large LLVM IR function named "wrapper." This approach simplifies whole-program rewriting and recompilation but deprecates original function information and the call graph, which can cause confusion during downstream tasks such as binary code analysis (e.g., BinDiff [2]).

Despite the typical limitations of dynamic lifters, S2E has shown excellent support for comprehensive path discovery [33]. Our observations indicate that BinRec achieves very good coverage for most C programs, including highly complex SPEC C programs.

### Exploration of Other Lifters
We explored other lifters, such as bin2llvm [4], which produced too many broken IR pieces and is no longer actively maintained. Rev.ng [95] performed worse than other lifters and was omitted. Instrew [48], another recently released dynamic lifter, also yielded a large volume of broken outputs. Some popular frameworks, like angr [99], convert binary code into customized low-level IR (VEX IR). Our study focuses on binary lifters that convert assembly programs into compiler IR, allowing the reuse of rich resources provided by the compiler framework without reinventing the wheel [19], [47], [18]. In summary, the four tools we evaluated represent the best static and dynamic lifters for converting binary code into LLVM IR at the time of writing.

### Test Program Statistics
| **Category** | **Count** |
|--------------|-----------|
| Total # of SVF test cases | 84 |
| Total # of alias facts | 169 |
| Total # of POJ-104 programs | 44,912 |
| Total # of SPEC INT 2006 C programs | 9 |

### Changes Made to Binary Lifters and Relevant Tools
| **Tool** | **Changes** |
|----------|-------------|
| McSema | Remove compiler and linker inserted functions; create McSema0 by disabling all optimizations |
| BinRec | Several enhancements and bug fixes; support for 20 new external function calls |
| mctoll | Completely rewritten in PyTorch [89]; add ten unsupported LLVM IR instructions |
| ncc | N/A |
| llvmir2hll | Patched to support all encountered statements |

### Downstream Task Setup and Test Case Selection
**Pointer Analysis:** We used all 24 flow-sensitive test cases from SVF, annotated with MustAlias, MayAlias, or NoAlias. These are the ground truths for pointer analysis. We also generated 60 additional programs with more complex structures using equivalence modulo inputs (EMI)-based mutation [69]. The 84 test programs contain 169 pointer alias facts.

**Discriminability Analysis:** We split POJ-104 programs into training, validation, and testing sets using the default settings in the ncc paper [26]. Each dataset was compiled or lifted into LLVM IR, creating five training, validation, and testing datasets. We trained one ncc LLVM IR embedding model and one classification model using the training/validation datasets, tested with the corresponding test datasets. Model training was completed at 50 epochs with default hyperparameters.

**C Decompilation:** We fed lifted and compiled IR code into llvmir2hll to measure decompilation quality. We collected all C programs from the SPEC INT 2006 test suite, excluding three C++ programs due to the complexity and lack of support in llvmir2hll.

### Pointer Analysis Evaluation Results
| **Tool** | **MustAlias Accuracy** | **MayAlias Accuracy** | **NoAlias Accuracy** | **#Pointers** | **#Objects** | **#SVFG Nodes** | **#SVFG Edges** | **Processing Time (CPU Seconds)** |
|----------|------------------------|-----------------------|----------------------|---------------|--------------|-----------------|-----------------|----------------------------------|
| Clang | 100.0% | 100.0% | 100.0% | 345.9 | 73.0 | 934.8 | 3393.1 | 2.5 |
| RetDec | 0.0% | 0.0% | 17.8% | 96646.2 | 879.4 | 68.6 | 14.2 | 3.9 |
| mctoll | 0.0% | 0.0% | 0.0% | 2682.5 | 41.9 | 164.7 | 25.2 | 5.7 |
| McSema | 0.0% | 0.0% | 0.0% | 168.8 | 953.5 | 26686.1 | 166.7 | 19.8 |
| McSema0 | 0.0% | 0.0% | 0.0% | 116.4 | 8.8 | 102.0 | 817.6 | 463.5 |
| BinRec | 0.0% | 0.0% | 0.0% | 20802.8 | 127.7 | N/A | N/A | 5.7 |

### Total Test Cases and Failed Lifting Cases
| **Dataset** | **Total Test Cases** | **RetDec** | **mctoll** | **McSema** | **McSema0** | **BinRec** |
|-------------|----------------------|------------|------------|------------|-------------|------------|
| SVF | 84 | 0 | 14 | 0 | 0 | 2 |
| POJ-104 | 44,912 | 23,351 | 2 | 85 | 72 | 9,668 |
| SPEC | 9 | 0 | 9 | 0 | 0 | 0 |

### Findings
#### Binary Lifting Results
We compiled all test cases into 64-bit x86 executables. Table V shows the statistics of lifting failures. mctoll threw exceptions for seven SVF cases and generated seven broken LLVM IR codes. RetDec threw two exceptions for POJ-104 test cases, and mctoll failed to process C++ programs, leading to 23,351 failures. Static lifting of SVF and POJ-104 programs took a few seconds, while SPEC programs took several minutes to a few hours. BinRec, using symbolic execution, was slower but achieved 93% function coverage for successfully lifted programs. For SPEC programs, we conducted symbolic execution for 50 hours, achieving an average function coverage of 23%.

#### Pointer Analysis
Table IV reports the evaluation results. Compiled IR supports robust analysis, but lifted IR has limited support. No MayAlias or MustAlias relations were correctly recognized. SVF reported the number of pointers, memory objects, nodes, and edges on the sparse value flow graph (SVFG), indicating the complexity of static analysis. Processing times were consistent with graph complexity.