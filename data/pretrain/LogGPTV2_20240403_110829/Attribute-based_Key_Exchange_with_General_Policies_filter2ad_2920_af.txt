—
—
—
3 (Unlink)
—
— 78 ms
4 (Vrfy)
—
—
4 (Enc)
—
—
5 (Dec)
28 ms
— 28 ms
5 (Ev)
—
3 ms
3 ms
6 (commit)
— <1 ms <1 ms
7 (Enc)
42 ms
— 42 ms
7 (Ve)
—
8 ms
8 ms
8 (cointoss) <1 ms <1 ms <1 ms <1 ms
5 ms
—
857 ms
82 ms
—
—
—
—
—
Total
944 ms
241 ms
159 ms
81 ms
Table 10.1: Breakdown of server (S) and client (P) computation
times for the various steps of Πabke for a 100,000 gate policy with
200 attributes.
[opt] denotes the optimized computation time
(i.e., pushing computation to an oﬄine stage and batching veri-
ﬁcation). See Figure 6.1 for a description of each step. The total
cost is slightly less than that reported elsewhere due to rounding
errors and not accounting for initialize/cleanup steps.
As we can see, the computation time is fairly consistent for a
ﬁxed m, but grows as m increases. This validates our claim
that the pairings and exponentiations account for most of
the overhead as opposed to the garbling and evaluating of
the policy. The computation time varies from 67 ms for the
server and 11 ms for the client for a 1,000 gate policy with
10 attributes, to 957 ms for the server and 176 ms for the
client for a 100,000 gate policy with 200 attributes.
Looking at the case of a 100,000 gate policy with 200
attributes (see also Table 10.1), we see that most of the
overhead on the server side comes from verifying the pub-
lic key sent by the client (857 ms), due to the 2m pairings
needed. The next largest operation is encryption, which ac-
counts for 82 ms. Meanwhile, garbling the policy takes only
5 ms. Regarding the client, the costliest operation is check-
ing that the encryption sent by the server is correct, which
requires re-encrypting the m unopened wire-labels (42 ms),
followed by randomizing its public key (78 ms). Decryption
is relatively cheap, requiring 28 ms. Meanwhile, evaluating
the garbled circuit takes 3 ms, again demonstrating that the
garbled circuit is not the bottleneck (at least with regards
to computation).
Looking at the communication time (cf. Figure 10.2), we
see that as both the number of attributes and number of
gates grows so does the running time. We stress that this
growth impacts previous ABE formula-based solutions to
a much greater degree. Importantly, for all but extremely
large policies of millions of gates, communication will typi-
cally not be a bottleneck of our system. Most of the server’s
communication time is spent sending the garbled circuit,
whereas most of the client’s time is spent receiving the gar-
bled circuit and the ciphertext, this latter case due to the
client blocking while the server veriﬁes the (randomized)
public key. We note that our network bandwidth of 200 Mbps
is pessimistic, and running our protocol on Amazon EC2 or
other networks with 1 Gbps bandwidth will all but elimi-
nate the communication overhead of sending/receiving the
garbled circuit (e.g., when running over localhost, the com-
munication time is essentially the time spent blocking wait-
ing for the other party to complete some computation).
Note that with regards to computation, most of the ex-
Operation
BLS∗
BLS∗
sign
verify
BLS∗
batch verify
Cycles
522,767
12,316,919
22,635,625
Table 10.2: Benchmarking BLS∗ signing and veriﬁcation, along
with the batch veriﬁcation approach of Ferrara et al. [24] for ten
messages.
pensive operations (such as randomizing and verifying the
public key) can be either done oﬄine or batched. Thus,
we also calculated an optimized computation time; see Fig-
ure 10.3.
In these experiments, we ignore the cost of the
client randomizing its public key and the server garbling its
policy, as both of these can be done in an oﬄine stage. To
account for the batching optimization, we implemented and
benchmarked the batching techniques of Ferrara et al. [24],
see Table 10.2. We see a roughly 5.4× improvement when
batch verifying ten messages. Thus, in our experiments we
model a server operating over ten clients at a time by divid-
ing the public key veriﬁcation time by 5.4. We see upwards
of a 4.4× and 2× improvement in running time for the server
and client, respectively. This makes sense in light of the fact
that randomizing and verifying the public key are the two
most expensive operations.
A policy cost example.
In light of the above results,
we provide a rough calculation of the cost of a realistic
policy, where the client succeeds if its geolocation (xU , yU )
is within distance d of the server’s location (xS, yS). The
client’s geolocation credential may be issued with a certi-
ﬁed timestamp, which may simultaneously be checked by
a policy. Such a policy would require a circuit computing
(xU − xS)2 + (yU − yS)2<?d2 and a (much smaller) circuit
verifying that the timestamp is in an acceptable time in-
terval. Using a 64-bit input and the CBMC circuit com-
piler [33], we can compile this function as a circuit contain-
ing approximately 20,000 gates. Thus, as demonstrated by
our performance results, the cost of the corresponding gar-
bled circuit would be unnoticeable relative to the public key
operations required by the server and client.
In contrast,
an ABE-based solution would require converting the policy
circuit into a (very large) formula, and performing pairings
proportional to its size, which is not practical in most set-
tings.
Acknowledgments
This work was supported by the Oﬃce of Naval Research
(ONR) contract number N00014-14-C-0113. This work was
done in part while the authors were visiting the Simons Insti-
tute for the Theory of Computing, supported by the Simons
Foundation and by the DIMACS/Simons Collaboration in
Cryptography through NSF grant #CNS-1523467. Work of
Alex J. Malozemoﬀ conducted in part with Government sup-
port through the National Defense Science and Engineering
Graduate (NDSEG) Fellowship, 32 CFG 168a, awarded by
DoD, Air Force Oﬃce of Scientiﬁc Research.
11. REFERENCES
[1] ABC4Trust EU project. https://www.abc4trust.eu.
[2] Global IP network latency. http://ipnetwork.bgtmo.ip.
att.net/pws/network delay.html. Retrieved February
8, 2016.
1462[3] Identity mixer. http://idemix.wordpress.com.
[4] Microsoft U-Prove. http://www.microsoft.com/uprove.
[5] M. Abe and S. Fehr. Perfect NIZK with adaptive
soundness. In TCC, 2007.
[6] D. F. Aranha and C. P. L. Gouvˆea. RELIC is an
Eﬃcient LIbrary for Cryptography.
https://github.com/relic-toolkit/relic.
[7] M. Belenkiy, J. Camenisch, M. Chase, M. Kohlweiss,
A. Lysyanskaya, and H. Shacham. Randomizable
proofs and delegatable anonymous credentials. In
Crypto, 2009.
[8] M. Bellare, V. T. Hoang, and P. Rogaway.
Foundations of garbled circuits. In CCS, 2012.
[9] J. Bethencourt, A. Sahai, and B. Waters.
Ciphertext-policy attribute-based encryption. In S&P,
2007.
[10] N. Bitansky, R. Canetti, A. Chiesa, S. Goldwasser,
H. Lin, A. Rubinstein, and E. Tromer. The hunting of
the SNARK. Cryptology ePrint Archive, Report
2014/580, 2014.
[11] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer.
From extractable collision resistance to succinct
non-interactive arguments of knowledge, and back
again. In ITCS, 2012.
[12] D. Boneh and X. Boyen. Eﬃcient selective-ID secure
identity based encryption without random oracles. In
Eurocrypt, 2004.
[13] D. Boneh and M. K. Franklin. Identity-based
Pedersen. Practical short signature batch veriﬁcation.
In CT-RSA, 2009.
[25] T. K. Frederiksen, J. B. Nielsen, and C. Orlandi.
Privacy-free garbled circuits with applications to
eﬃcient zero-knowledge. In Eurocrypt, 2015.
[26] S. Garg, C. Gentry, S. Halevi, A. Sahai, and
B. Waters. Attribute-based encryption for circuits
from multilinear maps. In Crypto, 2013.
[27] R. Gennaro, J. Katz, H. Krawczyk, and T. Rabin.
Secure network coding over the integers. In PKC,
2010.
[28] M. C. Gorantla, C. Boyd, and J. M. Gonz´alez Nieto.
Attribute-based authenticated key exchange. In
ACISP, 2010.
[29] S. Gorbunov, V. Vaikuntanathan, and H. Wee.
Predicate encryption for circuits from LWE. In
Crypto, 2015.
[30] V. Goyal, O. Pandey, A. Sahai, and B. Waters.
Attribute-based encryption for ﬁne-grained access
control of encrypted data. In CCS, 2006.
[31] J. Groth. Short pairing-based non-interactive
zero-knowledge arguments. In Asiacrypt, 2010.
[32] D. Gupta and A. Sahai. On constant-round concurrent
zero-knowledge from a knowledge assumption. In
Indocrypt, 2014.
[33] A. Holzer, M. Franz, S. Katzenbeisser, and H. Veith.
Secure two-party computations in ANSI C. In CCS,
2012.
encryption from the Weil pairing. In Crypto, 2001.
[34] M. Jawurek, F. Kerschbaum, and C. Orlandi.
Zero-knowledge using garbled circuits: how to prove
non-algebraic statements eﬃciently. In CCS, 2013.
[35] V. Kolesnikov, H. Krawczyk, Y. Lindell,
A. Malozemoﬀ, and T. Rabin. Attribute-based key
exchange with general policies.
https://eprint.iacr.org/2016/518.
[36] A. Sahai and B. R. Waters. Fuzzy identity-based
encryption. In Eurocrypt, 2005.
[37] Y. Sakai, N. Attrapadung, and G. Hanaoka.
Attribute-based signatures for circuits from bilinear
map. In PKC, 2016.
[38] B. Waters. Ciphertext-policy attribute-based
encryption: An expressive, eﬃcient, and provably
secure realization. In PKC, 2011.
[39] S. Zahur, M. Rosulek, and D. Evans. Two halves make
a whole - reducing data transfer in garbled circuits
using half gates. In Eurocrypt, 2015.
[14] D. Boneh, D. Freeman, J. Katz, and B. Waters.
Signing a linear subspace: Signature schemes for
network coding. In PKC, 2009.
[15] D. Boneh and D. M. Freeman. Homomorphic
signatures for polynomial functions. In Eurocrypt,
2011.
[16] D. Boneh, B. Lynn, and H. Shacham. Short signatures
from the Weil pairing. Journal of Cryptology,
17(4):297–319, Sept. 2004.
[17] S. Brands. Rethinking Public Key Infrastructures and
Digital Certiﬁcates: Building in Privacy. MIT Press,
2000.
[18] J. Camenisch, N. Casati, T. Groß, and V. Shoup.
Credential authenticated identiﬁcation and key
exchange. In Crypto, 2010.
[19] J. Camenisch and A. Lysyanskaya. An eﬃcient system
for non-transferable anonymous credentials with
optional anonymity revocation. In Eurocrypt, 2001.
[20] J. Camenisch and A. Lysyanskaya. Signature schemes
and anonymous credentials from bilinear maps. In
Crypto, 2004.
[21] R. Canetti, A. Cohen, and Y. Lindell. A simpler
variant of universally composable security for standard
multiparty computation. In Crypto, 2015.
[22] M. Chase, C. Ganesh, and P. Mohassel. Eﬃcient
zero-knowledge proof of algebraic and non-algebraic
statements with applications to privacy preserving
credentials. In Crypto, 2016.
[23] D. Chaum. Untraceable electronic mail, return
addresses, and digital pseudonyms. Communications
of the ACM, 24(2):84–88, 1981.
[24] A. L. Ferrara, M. Green, S. Hohenberger, and M. Ø.
1463