– VerCommit(ck, c, u, o) → b takes as input a commitment c, a value u and an opening o, and accepts
descriptions of the input space D, commitment space C and opening space O.
c and an opening o.
(b = 1) or rejects (b = 0).
Correctness. For all λ ∈ N and any input u ∈ D we have:
Pr(cid:2)ck ← Setup(1λ), (c, o) ← Commit(ck, u) : VerCommit(ck, c, u, o) = 1(cid:3) = 1.
(cid:34)
(cid:35)
Binding. For every polynomial-time adversary A:
ck ← Setup(1λ)
(c, u, o, u(cid:48), o(cid:48)) ← A(ck)
:
u (cid:54)= u(cid:48) ∧ VerCommit(ck, c, u, o) = 1
∧ VerCommit(ck, c, u(cid:48), o(cid:48)) = 1
Pr
= negl
Hiding. For ck ← Setup(1λ) and ∀ u, u(cid:48) ∈ D, the following two distributions are statistically close:
Commit(ck, u) ≈ Commit(ck, u(cid:48))
2.3 Zero-Knowledge SNARKs
We recall the deﬁnition of (pre-processing) zero-knowledge succinct non-interactive arguments of
knowledge (zkSNARKs, for short) [BCCT12, BCC+17].
Deﬁnition 2.2 (SNARK). A SNARK for {Rλ}λ∈N is a triple of algorithms Π = (KeyGen, Prove,
VerProof) that work as follows and satisfy the notions of completeness, succinctness and knowledge
soundness deﬁned below. If Π also satisﬁes zero-knowledge we call it a zkSNARK.
10
common reference string consisting of an evaluation and a veriﬁcation key.
– KeyGen(R) → (ek, vk) takes the security parameter λ and a relation R ∈ Rλ, and outputs a
– Prove(ek, x, w) → π takes an evaluation key for a relation R, a statement x, and a witness w such
– VerProof(vk, x, π) → b takes a veriﬁcation key, a statement x, and either accepts (b = 1) or rejects
that R(x, w) holds, and returns a proof π.
(b = 0) the proof π.
Completeness. For any pair (x, w) satisfying the relation, the veriﬁer always accepts the corre-
sponding proof. Formally, ∀λ ∈ N, R ∈ Rλ and (x, w) such that R(x, w), it holds:
Pr[(ek, vk) ← KeyGen(R), π ← Prove(ek, x, w) : VerProof(vk, x, π) = 1] = 1
Succinctness. Π is said succinct if the running time of VerProof is poly(λ) (λ + |x| + log |w|) and
the proof size is poly(λ) (λ + log |w|).
Knowledge Soundness. Let RG be a relation generator such that RGλ ⊆ Rλ. Π has knowledge
soundness for RG and auxiliary input distribution Z, denoted KSND(RG,Z) for brevity, if for
every (non-uniform) eﬃcient adversary A there exists a (non-uniform) eﬃcient extractor E such
that Pr[GameKSNDRG,Z,A,E = 1] = negl. We say that Π is knowledge sound if there exists benign RG and
Z such that Π is KSND(RG,Z).
GameKSNDRG,Z,A,E → b
(cid:0)x, π(cid:1) ← A(R, crs, auxR, auxZ ) ; w ← E(R, crs, auxR, auxZ ) ; b = VerProof(vk, x, π) ∧ ¬R(x, w)
(R, auxR) ← RG(1λ) ; crs := (ek, vk) ← KeyGen(R) ; auxZ ← Z(R, auxR, crs)
Composable Zero-Knowledge. A scheme Π satisﬁes composable zero-knowledge for a relation
generator RG if there exists a simulator S = (Skg,Sprv) such that both following conditions hold for
all adversaries A:
Keys Indistinguishability.
Pr(cid:2)(R, auxR) ← RG(1λ), crs ← KeyGen(R) : A(crs, auxR) = 1]
≈ Pr(cid:2)(R, auxR) ← RG(1λ), (crs, tdk) ← Skg(R) : A(crs, auxR) = 1(cid:3)
Proof Indistinguishability. For all (x, w) such that R(x, w) = 1,
Pr(cid:2)(R, auxR) ← RG(1λ), (crs, tdk) ← Skg(R) : π ← Prove(ek, x, w),A(crs, auxR, π) = 1(cid:3)
≈ Pr(cid:2)(R, auxR) ← RG(1λ), (crs, tdk) ← Skg(R) : π ← Sprv(crs, tdk, x),A(crs, auxR, π) = 1(cid:3)
Remark 2.1. In the notion of knowledge soundness deﬁned above we consider two kinds of auxiliary
inputs, auxR generated together with the relation by RG, and auxZ that is generated from some
distribution Z that may depend on the common reference string that in turn depends on R. An
example of this appears in our proof of Theorem B.1. Notice that although our notion is implied
by a notion where auxiliary inputs can be arbitrary, our aim is a precise formalization of auxiliary
inputs; this is useful to justify why certain auxiliary inputs should be considered benign, as required
to avoid known impossibility results [BCPR14, BP15]. Finally, we also note that our notion is also
implied by SNARKs that admit black-box extractors (as may be the case for those relying on
random oracles [Mic00]).
11
zkSNARKs with Specializable Universal CRS
In the SNARK notion presented above, the common reference string generated by KeyGen is tied
to a speciﬁc relation R ∈ Rλ. A variant of this notion is that of SNARKs for universal relations in
which the output of KeyGen depends only on the family Rλ and can be used to prove and verify
statements about any R ∈ Rλ. Due to the practical concerns on the execution of KeyGen, SNARKs
for universal relations are more convenient as one can reuse and amortize the cost of one setup. In a
recent work, Groth et al. [GKM+18] introduced the notion of zkSNARK with specializable universal
common reference string. In a nutshell, this notion formalizes the idea that key generation for R can
be seen as the sequential combination of two steps: a ﬁrst probabilistic algorithm that generates a
CRS for the universal relation, and a second deterministic algorithm that specializes this universal
CRS into one for a speciﬁc R. We remark that our UC SNARKs follow this model.
More formally, let Rλ be a family of relations. The universal relation R∗ for Rλ deﬁnes a language
with instances (R, x) such that R∗(R, x, w) holds iﬀ R ∈ Rλ and R(x, w) holds.
ence string [GKM+18] if there exist algorithms Derive, Prove∗, VerProof∗ such that:
– Derive(crs, R) → crsR is a deterministic algorithm that takes as input a crs := (ek, vk) pro-
duced by KeyGen(R∗) and a relation R ∈ Rλ, and outputs a specialized common reference string
crsR := (ekR, vkR).
A Π = (KeyGen, Prove, VerProof) is said a zkSNARK with specializable universal common refer-
– Prove(ek, (R, x), w) → π runs (ekR, vkR) ← Derive(crs, R) and returns π ← Prove∗(ekR, x, w).
– VerProof(vk, (R, x), π) → b runs (ekR, vkR) ← Derive(crs, R) and returns b ← VerProof∗(vkR, x, π).
3 Building the LegoSNARK Framework
3.1 Commit and Prove SNARKs
In a nutshell, a commit-and-prove SNARK (CP-SNARK) is a SNARK that can prove knowledge
of (x, w) such that R(x, w) holds w.r.t. a witness w = (u, ω) and u opens a commitment cu.10 Our
formal deﬁnitions below add some syntactic sugar to this idea to explicitly handle relations where
the input domain Du is more ﬁne grained and splits over (cid:96) subdomains. For reasons that will shortly
become clear, we call these subdomains commitment slots. This splitting is often natural (e.g., if u is
a binary string, one can think of u := (u1, . . . , u(cid:96)) for suitable substrings), and it is crucial to exploit
the compositional power of CP-SNARKs, as we show in Section 3.2. We assume the description of
the splitting is part of R’s description.
Deﬁnition 3.1 (CP-SNARKs). Let {Rλ}λ∈N be a family of relations R over Dx × Du × Dω
such that Du splits over (cid:96) arbitrary domains (D1 × ··· × D(cid:96)) for some arity parameter (cid:96) ≥ 1. Let
Com = (Setup, Commit, VerCommit) be a commitment scheme (as per Deﬁnition 2.1) whose input
space D is such that Di ⊂ D for all i ∈ [(cid:96)]. A commit and prove zkSNARK for Com and {Rλ}λ∈N
is a zkSNARK for a family of relations {RCom
– every R ∈ RCom is represented by a pair (ck, R) where ck ∈ Setup(1λ) and R ∈ Rλ;
– R is over pairs (x, w) where the statement is x := (x, (cj)j∈[(cid:96)]) ∈ Dx × C(cid:96), the witness is
w := ((uj)j∈[(cid:96)], (oj)j∈[(cid:96)], ω) ∈ D1 × ··· × D(cid:96) × O(cid:96) × Dω, and the relation R holds iﬀ
}λ∈N such that:
λ
(cid:94)
VerCommit(ck, cj, uj, oj) = 1 ∧ R(x, (uj)j∈[(cid:96)], ω) = 1
j∈[(cid:96)]
10 Our notion assumes that only a portion of the witness is explicitly committed in cu.
12
Furthermore, when we say that CP is knowledge-sound for a relation generator RG and auxiliary
input generator Z (denoted KSND(RG,Z), for short) we mean it is a knowledge-sound SNARK for
the relation generator RGCom(1λ) that runs ck ← Setup(1λ) and (R, auxR) ← RG(1λ), and returns
((ck, R), auxR).
We denote a CP-SNARK as a triple of algorithms CP = (KeyGen, Prove, VerProof). For ease of
exposition, in our constructions we adopt the syntax for CP’s algorithms deﬁned below.
– KeyGen(ck, R) → crs := (ek, vk) generates the common reference string.
– Prove(ek, x, (cj)j∈[(cid:96)], (uj)j∈[(cid:96)], (oj)j∈[(cid:96)], ω) → π outputs the proof of correct commitment.
– VerProof(vk, x, (cj)j∈[(cid:96)], π) → b ∈ {0, 1} rejects or accepts the proof.
Remark 3.1 (Comparing with existing deﬁnitions). To deﬁne the Geppetto scheme [CFH+15] the
authors deﬁne a notion of commit-and-prove SNARKs. Here we highlight the main diﬀerences
between their deﬁnition and ours. First, our commitment key can be generated without ﬁxing
a priori a relation (or a set of relations, e.g., a multi-QAP). Second, in their model one needs
to commit to data using a commitment key corresponding to a speciﬁc portion of the input (in
their lingo a “bank”), whereas in our model one can just commit to a vector of data, and only at
proving time one assigns that data to a speciﬁc input slot. Third, we do not require commitments
to have a trapdoor. Our notion is closer to the one given by Lipmaa [Lip16] (although [Lip16]
uses trapdoor commitments) and is in fact a specialized SNARK notion when considering relation
families including verifying openings of commitments.
3.2 Composition Properties of CP-SNARKs
In this section, we formally show how the commit-and-prove capability can be used to combine
diﬀerent CP-SNARKs securely.
Conjunction of relations with shared inputs. Let {R(0)
λ }λ∈N be two families
of relations such that, for every λ ∈ N the input domains D(0)
u of relations R0 ∈ R(0)
λ and
R1 ∈ R(1)
:= D1 × D(cid:48)
2 with D2 = D(cid:48)
2.11
In other words we require these relations to share a commitment slot that we call the shared slot.
λ}λ∈N as the family of relations where for every
(x0, x1, u0, u1, u2, w∗) is deﬁned as follows:
Given the above relation families, we deﬁne {R∧
λ } and R∧
respectively can split as follows: D(0)
λ }λ∈N and {R(1)
u and D(1)
: R0 ∈ R(0)
λ , R1 ∈ R(1)
:= D0 × D2 and D(1)
u
λ
λ ∈ N, R∧
λ = {R∧
R0,R1
u
R0,R1
R0,R1(x0, x1, u0, u1, u2, (w0, w1)) := R0(x0, u0, u2, w0) ∧ R1(x1, u1, u2, w1)
R∧
Let Com be a commitment scheme, for b ∈ {0, 1} let CPb be a CP-SNARK for Com and
{R(b)
λ}λ∈N. It
λ }λ∈N. In Figure 1 we show a construction of a CP-SNARK CP∧ for Com and {R∧
is also easy to see that if both CP0 and CP1 are CP-SNARKs with specializable universal CRS, then
so is the resulting CP∧ .
Theorem 3.1. If Com is a computationally binding commitment and, for b ∈ {0, 1}, CPb is a
zero-knowledge CP-SNARK for Com and relation family {R(b)
λ }λ∈N, then there is a zero-knowledge
CP-SNARK CP∧ for Com and {R∧
11 Note such a splitting is rather general, as D2 and D(cid:48)
2, or D0, or D1 may be empty.
λ}λ∈N.
13
R0,R1 ) :
CP∧.KeyGen(ck, R∧
(ek0, vk0) ← CP0.KeyGen(ck, R0)
(ek1, vk1) ← CP1.KeyGen(ck, R1)
ek
:= (ekb)b∈{0,1}
:= (vkb)b∈{0,1}
)
∗
, vk
∗
∗
vk
∗
return (ek
CP∧.Prove(ek∗, x0, x1, (cj)j∈[:3],
(uj)j∈[:3], (oj)j∈[:3], ω0, ω1) :
π0 ← CP0.Prove(
ek0, x0, (c0, c2), (u0, u2), (o0, o2), ω0)
π1 ← CP1.Prove(
ek1, x1, (c1, c2), (u1, u2), (o1, o2), ω1)
return π
:= (πb)b∈{0,1}
∗
CP∧.VerProof(vk∗, x0, x1, (cj)j∈[:3], π∗) :
ok ← CP0.VerProof(vk0, x0, (c0, c2), π0)
b(0)
ok ← CP1.VerProof(vk1, x1, (c1, c2), π1)
b(1)
return b(0)
ok ∧ b(1)
ok
Figure 1: CP-SNARK construction for AND composition
R0,R1
Correctness and succinctness follow by inspection. Knowledge-soundness and zero-knowledge
follow rather easily from the respective properties of the underlying schemes. In particular, for
knowledge-soundness the basic idea is that in order for an adversary to break CP∧ it must break
either one of the two underlying schemes, CP0, CP1, or the binding of the commitment scheme. We
give a full proof of knowledge-soundness and zero-knowledge in Appendix A.
Functions composition. A CP-SNARK for conjunction of relations can be easily used for proving
correctness of composed functions, e.g., proving that ∃(y, w) : z = f (x, y, w), where f (x, y, w) :=
h(g(x, w), y). Indeed, let Rh(x(cid:48), y, z) = 1 iﬀ ∃(x(cid:48), y) : h(x(cid:48), y) = z, and Rg(x, x(cid:48)) = 1 iﬀ ∃(x(cid:48), w) :
g(x, w) = x(cid:48), then ∃ (y, w) : z = f (x, y, w) can be expressed as Rh(x(cid:48), y, z) ∧ Rg(x, x(cid:48)).
Disjunction of relations with shared inputs. We can reduce the case of OR composition to
the conjunction construction above. For this we assume relations are deﬁned over elements of a
ring. For a relation R(u) denote by ˆR(u, t) the relation such that ˆR(u, 0) = 1 iﬀ R(u) = 1 and
ˆR(u, t) = 1 iﬀ R(u) = 0 whenever t (cid:54)= 0. We can now express the disjunction of R0(u0), R1(u1)
(u0, u1, t0, t1) := ˆR0(u0, t0) ∧ ˆR1(u1, t1) ∧ t0t1 = 0. For this approach to work we need
as R∨
the proof systems for the two relations R0, R1 to support their modiﬁed version ˆR0, ˆR1, which is
the case for proof systems supporting general arithmetic or boolean circuits. Finally, we need a
simple eﬃcient proof system for the relation Rmul(t0, t1) = 1 iﬀ t0 · t1 = 0, where both t0 and t1 are
committed in two diﬀerent slots.
Composing more than two relations. By iterating the application of our Theorem 3.1 we
can build CP-SNARKs that handle conjunctions and/or disjunctions of more than two relations.
In order to maintain the succinctness property, one should apply composition only a small (e.g.,
constant, logarithmic) number of times. However, this is arguably the case when we deal with
real-world heterogeneous computations. The following example scenarios consider heterogeneous
computations that can be split naturally into two “homogeneous” components: square-and-multiply
algorithms (splitting the relation into the conjunction of all the iterated squarings and the ﬁnal
inner product), aggregation queries to a database (that can be split in a “ﬁlter” and an “aggregate”
component), proving a property P for a datum in a Merkle tree, as done in Zcash [BCG+14] (that
can be split in a membership veriﬁcation component and the property P , which could in turn be
decomposed further).
3.3 Commit-Carrying SNARKs
In this section we deﬁne a variant of SNARKs that lies in between standard SNARKs and CP-
SNARKs. We call these schemes SNARKs with commit-carrying proofs (or commit-carrying SNARKs,
14
cc-SNARKs for short). In a nutshell, a cc-SNARK is like a SNARK in which the proof contains
a commitment to the portion u of the witness. Essentially the diﬀerence is that in cc-SNARKs
we assume the extractor outputs the opening of the commitment returned along with the proof.