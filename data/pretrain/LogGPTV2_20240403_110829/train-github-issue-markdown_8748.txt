For a future metaprogramming module, I would like to have a
`deparse(ex::Expr)` function that produces a reasonable string that could have
been parsed to produce `ex`. I implemented a simplistic version of this in the
Calculus package to make the results of symbolic differentiation more
readable:
    function deparse(ex::Expr)
        if ex.head != :call
            return string(ex)
        else
            if contains([:+, :-, :*, :/, :^], ex.args[1])
                if length(ex.args) == 2
                    return strcat(ex.args[1], deparse(ex.args[2]))
                else
                    return join(map(x -> deparse(x), ex.args[2:end]),
                                strcat(" ", string(ex.args[1]), " "))
                end
            else
                return strcat(ex.args[1],
                              "(",
                              join(map(x -> deparse(x), ex.args[2:end]), ", "),
                              ")")
            end
        end
    end
    deparse(other::Any) = string(other)