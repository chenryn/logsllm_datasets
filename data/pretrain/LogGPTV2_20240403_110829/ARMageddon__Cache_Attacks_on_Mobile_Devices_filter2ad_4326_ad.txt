0
0
8
3
6
6
x
0
Addresses
Figure 9: Cache template matrix for the default AOSP
keyboard.
400
200
e
m
i
t
s
s
e
c
c
A
Tap
Tap
Tap
Swipe
Swipe
Swipe
0
2
4
6
Time in seconds
8
e
m
i
t
s
s
e
c
c
A
300
200
100
Key
Space
t h i
s
Space
i
s
Space
a Space m e s
s
a g
e
0
1
2
3
4
5
6
7
Time in seconds
Figure 7: Monitoring address 0xDC5C of libinput.so
on the Samsung Galaxy S6 reveals tap and swipe events.
1,000
800
600
400
200
e
m
i
t
s
s
e
c
c
A
Tap
Tap
Tap
0
2
Swipe
4
Swipe
Swipe
6
Time in seconds
Figure 8: Monitoring address 0xBFF4 of libinput.so
on the OnePlus One reveals tap and swipe events.
5.2 Attacking ART Binaries
Instead of attacking shared libraries, it is also possible
to apply this attack to ART (Android Runtime) executa-
bles [1] that are compiled ahead of time. We used this
attack on the default AOSP keyboard and evaluated the
number of accesses to every address in the optimized ex-
ecutable that responds to an input of a letter on the key-
board. It is possible to find addresses that correspond to
a key press and more importantly to distinguish between
taps and key presses. Figure 9 shows the correspond-
ing cache template matrix. We summarize the letter keys
in one line (alphabet) as they did not vary significantly.
These addresses can be used to monitor key presses on
the keyboard. We identified an address that corresponds
only to letters on the keyboard and hardly on the space
bar or the return button. With this information it is pos-
Figure 10: Evict+Reload on 2 addresses in custpack@
app@PI:EMAIL@classes.dex on
the Alcatel One Touch Pop 2 while entering the sentence
“this is a message”.
sible to precisely determine the length of single words
entered using the default AOSP keyboard.
We illustrate the capability of detecting word lengths
in Figure 10. The blue line shows the timing measure-
ments for the address identified for keys in general, the
red dots represent measurements of the address for the
space key. The plot shows that we can clearly determine
the length of entered words and monitor user input accu-
rately over time.
5.3 Discussion and Impact
Our proof-of-concept attacks exploit shared libraries and
binaries from Android apk files to infer key strokes. The
cache template attack technique we used for these attacks
is generic and can also be used to attack any other li-
brary. For instance, there are various libraries that han-
dle different hardware modules and software events on
the device, such as GPS, Bluetooth, camera, NFC, vi-
brator, audio and video decoding, web and PDF viewers.
Each of these libraries contains code that is executed and
data that is accessed when the device is in use. Thus,
an attacker can perform a cache template attack on any
of these libraries and spy on the corresponding device
events. For instance, our attack can be used to monitor
activity of the GPS sensor, bluetooth, or the camera. An
attacker can record such user activities over time to learn
more about the user.
558  25th USENIX Security Symposium 
USENIX Association
10
We can establish inter-keystroke timings at an ac-
curacy as high as the accuracy of cache side-channel
attacks on keystrokes on x86 systems with a physi-
cal keyboard. Thus,
the inter-keystroke timings can
be used to infer entered words, as has been shown by
Zhang et al. [61]. Our attack even has a higher res-
olution than [61], i.e., it is sub-microsecond accurate.
Furthermore, we can distinguish between keystrokes on
the soft-keyboard and generic touch actions outside the
soft-keyboard. This information can be used to enhance
sensor-based keyloggers that infer user input on mobile
devices by exploiting, e.g., the accelerometer and the gy-
roscope [7,11,12,39,59] or the ambient-light sensor [49].
However, these attacks suffer from a lack of knowledge
when exactly a user touches the screen. Based on our at-
tack, these sensor-based keyloggers can be improved as
our attack allows to infer (1) the exact time when the user
touches the screen, and (2) whether the user touches the
soft-keyboard or any other region of the display.
Our attacks only require the user to install a malicious
app on the smartphone. However, as shown by Oren et al.
[42], Prime+Probe attacks can even be performed from
within browser sandboxes through remote websites using
JavaScript on Intel platforms. Gruss et al. [16] showed
that JavaScript timing measurements in web browsers
on ARM-based smartphones achieve a comparable ac-
curacy as on Intel platforms. Thus, it seems likely that
Prime+Probe through a website works on ARM-based
smartphones as well. We expect that such attacks will be
demonstrated in future work. The possibility of attack-
ing millions of users shifts the focus of cache attacks to
a new range of potential malicious applications.
In our experiments with the predecessor of ART, the
Dalvik VM, we found that the just-in-time compilation
effectively prevents Evict+Reload and Flush+Reload at-
tacks. The just-in-time compiled code is not shared and
thus the requirements for these two attacks are not met.
However, Prime+Probe attacks work on ART binaries
and just-in-time compiled Dalvik VM code likewise.
6 Attack on Cryptographic Algorithms
this
section we
show how Flush+Reload,
In
Evict+Reload,
and Prime+Probe can be used to
attack AES T-table implementations that are still in use
on Android devices. Furthermore, we demonstrate the
possibility to infer activities within the ARM TrustZone
by observing the cache activity using Prime+Probe. We
perform all attacks cross-core and in a synchronized
setting, i.e., the attacker triggers the execution of cryp-
tographic algorithms by the victim process. Although
more sophisticated attacks are possible, our goal
is
to demonstrate that our work enables practical cache
attacks on smartphones.
6.1 AES T-Table Attacks
Many cache attacks against AES T-table implementa-
tions have been demonstrated and appropriate counter-
measures have already been proposed. Among these
countermeasures are, e.g., so-called bit-sliced implemen-
tations [29, 32, 46]. Furthermore, Intel addressed the
problem by adding dedicated instructions for AES [20]
and ARM also follows the same direction with the
ARMv8 instruction set [4]. However, our investiga-
tions showed that Bouncy Castle, a crypto library widely
used in Android apps such as the WhatsApp messen-
ger [2], still uses a T-table implementation. Moreover,
the OpenSSL library, which is the default crypto provider
on recent Android versions, uses T-table implementa-
tions until version 1.0.1.3 This version is still officially
supported and commonly used on Android devices, e.g.,
the Alcatel One Touch Pop 2. T-tables contain the pre-
computed AES round transformations, allowing to per-
form encryptions and decryptions by simple XOR oper-
ations. For instance, let pi denote the plaintext bytes,
ki the initial key bytes, and si = pi ⊕ ki the initial state
bytes. The initial state bytes are used to retrieve pre-
computed T-table elements for the next round. If an at-
tacker knows a plaintext byte pi and the accessed ele-
ment of the T-table, it is possible to recover the key bytes
ki = si ⊕ pi. However, it is only possible to derive the
upper 4 bits of ki through our cache attack on a device
with a cache line size of 64 bytes. This way, the attacker
can learn 64 key bits. In second-round and last-round at-
tacks the key space can be reduced further. For details
about the basic attack strategy we refer to the work of
Osvik et al. [43, 54]. Although we successfully mounted
an Evict+Reload attack on the Alcatel One Touch Pop
2 against the OpenSSL AES implementation, we do not
provide further insights as we are more interested to per-
form the first cache attack on a Java implementation.
Attack on Bouncy Castle. Bouncy Castle is imple-
mented in Java and provides various cryptographic prim-
itives including AES. As Bouncy Castle 1.5 still employs
AES T-table implementations by default, all Android de-
vices that use this version are vulnerable to our presented
attack. To the best of our knowledge, we are the first to
show an attack on a Java implementation.
During the initialization of Bouncy Castle, the T-tables
are copied to a local private memory area. Therefore,
these copies are not shared among different processes.
Nevertheless, we demonstrate that Flush+Reload and
Evict+Reload are efficient attacks on such an implemen-
3Later versions use a bit-sliced implementation if ARM NEON is
available or dedicated AES instructions if ARMv8-A instructions are
available. Otherwise, a T-table implementation is used. This is also the
case for Google’s BoringSSL library.
USENIX Association  
25th USENIX Security Symposium  559
11
s
s
e
r
d
d
A
s
s
e
r
d
d
A
0
0
x
0
0
1
x
0
0
2
x
0
0
3
x
0
0
4
x
0
0
5
x
0
0
6
x
0
0
7
x
0
0
8
x
0
0
9
x
0
0
A
x
0
0
B
x
0
0
C
x
0
0
D
x
0
0
E
x
0
0
F
x
0
Plaintext byte values
0
0
x
0
0
1
x
0
0
2
x
0
0
3
x
0
0
4
x
0
0
5
x
0
0
6
x
0
0
7
x
0
0
8
x
0
0
9
x
0
0
A
x
0
0
B
x
0
0
C
x
0
0
D
x
0
0
E
x
0
0
F
x
0
Plaintext byte values
6,000
4,000
2,000
s
e
s
a
c
f
o
r
e
b
m
u
N
Victim access
No victim access
0
1,500
2,500
3,000
2,000
Execution time in CPU cycles
3,500
Figure 11: Attack on Bouncy Castle’s AES using
Evict+Reload on the Alcatel One Touch Pop 2 (left) and
Flush+Reload on the Samsung Galaxy S6 (right).
Figure 12: Histogram of Prime+Probe timings depend-
ing on whether the victim accesses congruent memory
on the ARM Cortex-A53.
tation if shared memory is available. Further, we demon-
strate a cross-core Prime+Probe attack without shared
memory that is applicable in a real-world scenario.
Figure 11 shows a template matrix of the first T-table
for all 256 values for plaintext byte p0 and a key that
is fixed to 0 while the remaining plaintext bytes are
random. These plots reveal the upper 4 key bits of
k0 [43, 51]. Thus, in our case the key space is reduced
to 64 bits after 256–512 encryptions. We consider a first-
round attack only, because we aim to demonstrate the
applicability of these attacks on ARM-based mobile de-
vices. However, full-key recovery is possible with the
same techniques by considering more sophisticated at-
tacks targeting different rounds [47, 54], even for asyn-
chronous attackers [22, 26].
We can exploit the fact that the T-tables are placed on