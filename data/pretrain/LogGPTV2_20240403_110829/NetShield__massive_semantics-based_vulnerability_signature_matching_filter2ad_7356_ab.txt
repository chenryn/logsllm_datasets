is not enough. NIDS/NIPS vendors also realize this problem and
add limited semantic processing power to their products. However,
these add-ons are relatively ad-hoc and work as “patches” to the
systems. These systems are still limited by the regex engines and
cannot take the full beneﬁt of vulnerability signatures. In this paper,
we advocate that a systematic and clean slate design is necessary
for protocol parsing and vulnerability signature matching.
3. NETSHIELD FRAMEWORK
Figure 3 depicts the framework of NetShield. There are efﬁcient
hardware techniques for trafﬁc snifﬁng [3], TCP reassembly [14]
and protocol identiﬁcation (classify the trafﬁc to different applica-
tion protocols) [5]. Our work is focused on the design of an efﬁcient
core engine for matching vulnerability signatures rather than build-
ing a full-featured NIDS/NIPS, which requires an additional heavy
hardware/software engineering effort.
For each application protocol, we invoke the corresponding pro-
tocol parser which is generated by UltraPAC (our automated parser
generator) from the protocol speciﬁcation. Provided the required
protocol ﬁelds, the matching engine matches all the vulnerabil-
ity signatures for the given protocol simultaneously. The proto-
col parser and the matching engine are tightly coupled and work
in a pipelined fashion. Whenever a protocol ﬁeld is parsed, it is
immediately sent to the matching engine where the incremental
matching process is invoked. The pipelined processing helps re-
duce the memory consumption, processing delay and maximize the
throughput. A full-featured NIDS/NIPS also needs to handle proto-
col normalization. The current design of UltraPAC only considers
the application-level reassembly normalization. Encoding normal-
ization can be incorporated to our design but will remain as part of
the future work.
4. EFFICIENT MATCHING DESIGN
We ﬁrst formulate the vulnerability signature matching prob-
lems. After analyzing the nature of the problem, we present the
idea of our CS (Candidate Selection) algorithm, followed by the
attack resilience analysis and the further enhancement to the ba-
sic scheme. Finally, we extend our algorithm to the multiple PDU
(Protocol Data Unit) cases. Moreover, in this paper, we use signa-
ture and rule interchangeably.
4.1 The Vulnerability Signature Matching
Problem
Characteristics and challenges of vulnerability signature
matching: Five major characteristics make the vulnerability sig-
nature matching problem unique: (i) NIDSes/NIPSes have to keep
per-ﬂow state as small as possible, because they need to support a
large number of sessions and avoid state-holding attacks. Buffer-
ing a PDU or even a single string-type ﬁeld is uneconomical (up
to hundreds of KB) and sometimes is subject to state-holding at-
tacks (§4.3). Many variable-length string ﬁelds do not have length
upper-bounds deﬁned in the protocol. Buffering them is dangerous
because an attacker can generate crafted trafﬁc with very long ﬁelds
to overwhelm the NIDS/NIPS. Moreover, we want to make the de-
cision as soon as possible; thus, it is better to parse a PDU (or a par-
tial PDU) and match the signatures in a streaming fashion, instead
of waiting for all the ﬁelds available together.
(ii) Vulnerability
signatures require integer range checking or string length check-
ing. Handling arbitrarily overlapping ranges is non-trivial.
(iii)
In a signature, different operations, such as integer range check-
ing, string matching and regex matching, operate on different ﬁelds
and have different nature.
(iv) For
NIDSes/NIPSes, when multiple rules match a single session, the
reporting order of matched rules does not matter. This behavior is
different from ﬁrewall rules. (v) We have to handle the ﬁeld depen-
dencies as well as a large number of ﬁelds. Furthermore, different
signatures may depend on a different set of ﬁelds.
It is hard to combine them.
These ﬁve characteristics in the same time are also research chal-
lenges. For example, (i) requires us to design a scheme keeping the
per-ﬂow memory usage as small as possible. (ii) and (iii) make the
problem a hard multi-ﬁeld matching problem.
Tabular signature representation: To tackle the problem, we
convert the set of signatures to a two-dimensional table, namely
signature table. This transformation is the key to unlock the poten-
tial of matching multiple vulnerability signatures simultaneously.
We take two steps to achieve this. First, we normalize signa-
tures to only use && (AND). Any signature that uses || (OR) op-
erator is split into multiple signatures. Second, we convert the
normalized signatures to the signature table. Each unique two-
tuple ( ) is a matching dimension (called
a matcher), where  is a protocol ﬁeld (deﬁned in §2.1)
and  is the corresponding operator. For example, the
(ﬁlename ==) is a matcher deﬁned by the ﬁlename ﬁeld in the
HTTP URI and the exact string matching operator. Different sig-
natures may require different right operands for the ﬁlename ﬁeld,
281Method == Filename == Filename RE VARS ==RE
RuleID RB Matcher 1 Matcher 2 Matcher 3 Matcher 4
1
2
3
4
5
6
7
8
9
*
*
*
*
*
*
.*\.id[aq]$
*
*
1 DELETE
1
TRACE
POST
1
*
2
*
2
*
2
3
*
*
4
5
*
Table 1: A simpliﬁed example with nine HTTP signatures on ﬁve matchers (matching dimensions).
Matcher 5
Headers ==LEN
*
*
*
*
*
*
name=“ﬁle"; value ∼ “.*\.\./"
*
name=“conﬁgdir"; value ∼ “.*7C"
*
name=“host"; len(value)>300
*
*
*
name=“name"; value ∼ “.*GLOBAL" *
*
*
*
header.php
ads.cgi
awstats.pl
fp40reg.dll
*
*
*
name=“User-Agent"; len(value)>512
e.g., ﬁlename==“header.php” or ﬁlename==“ads.cgi”. One excep-
tion is that some protocol ﬁelds may form an associative array (Perl
Hash). For example, the HTTP headers are name and value pairs,
which can be treated as an associative array. First, the name of a
header needs to be matched. If it is matched, we then match the
value condition. Although it is possible to treat them as separate
matchers, we ﬁnd that treating them as a single matcher is easier
since most of rules have binding relationships between the names
and values.
For N signatures deﬁned on K matchers, we build an N × K
table. This applies to both the single PDU and the multiple PDU
case. A row represents a signature, a column represents a matcher,
and a cell represents the right operand of the matcher on the sig-
nature. If the signature j does not depend on matcher i, we use a
wildcard “*” to indicate in the cell. Since both N and K are large,
the signature table is usually sparse and has many wildcards. A
simpliﬁed example is given in Table 12. This example includes ﬁve
matchers on four protocol ﬁelds. Here, operator “==” means ex-
act matching, operator “RE” means regex-matching, while operator
“LEN” means string length checking. VARS is the list of variable
assignments (name and value pairs) in the HTTP URI, VARS and
Headers can be treated as associative arrays; thus, they are four
tuples.
SPMSM: To simplify the discussion, we ﬁrst deﬁne the single PDU
multiple signature matching problem (SPMSM)—given a set of
signature S = {S1, S2, . . .} and a PDU P, ﬁnd the signatures in S
that match P. Once solving SPMSM, we extend the solution to the
multiple PDU case in §4.5.
Hardness of SPMSM: It is known that general multidimensional
range search over N ranges in K dimensions (NKQUERY) has
) worst-case time with linear memory, or O(N K )
Ω((log N )
memory for linear search time [11]. This problem can be reduced
to the SPMSM problem. Therefore, the SPMSM problem’s worst
case bound will be at least as bad as that of the NKQUERY prob-
lem. This implies for the worst case rulesets it is impossible to have
a fast linear time algorithm.
Observation on real-world rulesets: Since the worst case rulesets
have bad theoretical results, we study the nature of real-world rule-
sets, because, after all, the attackers do not have control over the
vulnerabilities in a ruleset. Vulnerabilities are solely determined
by the bugs in programs. To design an algorithm with good perfor-
mance on real-world rulesets is still very important.
K−1
After examining a protocol ﬁeld against a given matcher for all
the signatures in the ruleset, the signatures that match the protocol
ﬁeld on the matcher except those with wildcard are called candi-
dates. Our observation is that, for a real-world vulnerability ruleset,
most matchers are selective, i.e., producing small candidate sets.
The observation is made by studying real-world vulnerabili-
ties, mainly the vulnerability signatures corresponding to Snort
2Please note that since we reduce the number of matchers from 31
to 5 for simplifying the example, these rules are not 100% accurate
and can only be used as illustration.
and Cisco rulesets. String-related matchers are selective, because
strings used in signatures are usually long and unique. For the
number-related matchers, in most cases this observation still holds.
However, it is not true for some matchers that are not crucial to the
signatures and are used solely for reducing false positives, e.g., the
matcher for checking the WINRPC version ﬁeld. In other words,
they are not rule ﬁlters but trafﬁc ﬁlters. Fortunately, the protocol
ﬁelds of such non-selective matchers usually take little space, e.g.,
four bytes or less. We can always buffer the ﬁelds and match them
later. In §4.2.3, we show that buffering and matching them later
will reduce the matching overhead.
4.2 The Candidate Selection Algorithm
Based on the characteristics of vulnerability signature matching
and the observation from real-world rulesets, we design the CS al-
gorithm with the goal of keeping the per-ﬂow state small. We adopt
a decomposition design, i.e., to match each matcher separately and
then combine the results. For each matcher, we search the candi-
dates for all the rules simultaneously. The key challenge is how to
efﬁciently merge candidates from different matchers.
One possible approach is to use bit-vector to encode matching
results. However, for a large ruleset, e.g., 1000 signatures, it needs
1000 bits (125 bytes) per connection, which is memory inefﬁcient.
Alternatively, we propose the CS algorithm. By exploiting the rule
order, the CS algorithm tracks the rules with “*” cases without
explicit states, and thus saves the per-ﬂow memory usage. The
CS algorithm only needs to track a small number of candidates for
each matcher. We match each matcher separately upon the protocol
ﬁeld’s arrival and then iteratively merge the possible candidate rules
to produce the ﬁnal result. Our experiments show the CS algorithm
has good throughput and memory usage.
The CS algorithm consists of the pre-computation to decide rule
order, the pre-computation to decide matcher order and the runtime
process. The pre-computation helps reduce the overhead at run-
time. We assume the protocol ﬁeld arriving order as the matcher
order when we introduce rule ordering in §4.2.1. We defer the de-
scription of matcher ordering to §4.2.3, because it requires a deep
understanding of the candidate selection process at run time shown
in §4.2.2.
4.2.1 Pre-Computation: Deciding the Rule Order
Based on the characteristic (i) mentioned in §4.1, we exploit the
degree of freedom in signature ID order. The key advantage of rule
ordering is to track the don’t care cases implicitly and leads to a
reduction in the per-ﬂow states.
Algorithm 1 RuleOrdering()
R is the list of rules;
For Mi in AllM atchers
RBi ← the rules in R requiring Mi;
R ← R − RBi;
Endfor
N R ← [];
For i from 1 to K append the rules in RBi to N R;
Return N R;
282PDU={Method=POST, Filename=fp40reg.dll, VARs: name="file"; value~".*\.\./.*", 
            Headers: name="host"; len(value)=450}
RB1: 1   2   3
Matcher 1: (Method,==)
Don’t care of Matcher 1
S1 = {3}
RB1: 1   2   3
RB2: 4   5   6
Matcher 2: (Filename, ==)
Don’t care of Matcher 1-2
S2 = S1 A2+B2 = {3}   {}+{6} = {}+{6} = {6}
RB1: 1   2   3
RB2: 4   5   6
RB3: 7
Matcher 3: (Filename, RE)
S3 = S2 A3+B3 = {6}   {}+{} = {6}+{} = {6}
Don’t care of 
Matcher 1-3
RB1: 1   2   3
RB2: 4   5   6
RB3: 7 RB4: 8
Matcher 4: (VAR, ==RE)
S4 = S3 A4+B4 = {6}   {4}+{} = {6}+{} = {6}
Don’t care of 
Matcher 1-4
RB1: 1   2   3
RB2: 4   5   6
RB3: 7 RB4: 8 RB5: 9
Matcher 5: (Headers, ==LEN)
S5 = S4 A5+B5 = {6}   {6}+{} = {6}+{} = {6}
Figure 4: Rule ordering and candidate selection process of
rules in Table 1.
We use Mi to denote the ith matcher, i.e., the ith column in the
signature table. We call the rules that do not have wildcard in Mi
the rules requiring Mi. Algorithm 1 shows the rule ordering pro-
cess. R is initialized as the complete list of rules. We iterate over
each matcher. At the beginning of the ith iteration, the remain-
ing rules in R have wildcards in all the previous matchers M1 to
Mi−1. We select all the rules in R that requiring Mi to construct
RBi, which is the ith rule block. We remove the selected rules
from R before the next iteration starts. Finally, we concatenate the
RBi to form the list of ordered rules. Table 1 shows the rules after
rule ordering. the RB column is the rule block ID. For example, the
rules 1–3 require Matcher 1, so they form the ﬁrst rule block. Then,
because the rules 4–6 require Matcher 2, they form the second rule
block.
DataType Operation
number
number
string
string
string