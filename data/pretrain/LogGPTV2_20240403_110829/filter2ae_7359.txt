# Bytectf web sp-oauth 题解

在ByteCTF比赛中，`sp-oauth`是唯一一道无人解出的题目。我在比赛过程中遇到了不少困难，但最终还是磕磕绊绊地完成了部分挑战。这个题目主要考察了对Spring OAuth的理解，而我在这方面的知识相对匮乏。

## 题目背景
题目提供了两个端口：
- 30003：初始访问端口
- 30002：名为“ice cream”的服务端口

访问链接如下：
```
http://39.105.175.150:30002/oauth/authorize?response_type=code&client_id=62608e08adc29a8d6dbc9754e659f125&redirect_uri=http://39.105.175.150:30003/zwo/callback
```

## 正常流程
首先，在30003端口注册一个用户（例如cxcsec），然后在30002端口注册另一个用户（例如cxctest）。登录后，访问上述链接，会发现页面跳转到30003端口的`bind`接口。此时输入30003端口用户的账号密码，即可将30002和30003端口的用户绑定。再登录30002端口的用户，可以切换到30003端口的用户。

## 漏洞利用
### 成为管理员
通过设置`redirect_uri`为我们的服务器地址，可以使请求携带`code`重定向到我们控制的服务器。验证时，可以看到服务器接收到了`code`，并且该`code`只能使用一次。

在正常流程中，成功跳转后会获得一个`Set-Cookie`头部，其中包含`JSESSIONID`。使用此cookie可以直接访问30003端口对应的用户。因此，可以通过向bot提供恶意URL来获取bot的`code`。

实际操作中，需要将host设置为`redirect_uri`的值，否则会出现错误。拿到cookie后，登录管理员界面，可以看到一个查看客户端信息的功能。这里存在SQL注入漏洞，可以使用sqlmap进行拖库。尝试SSTI攻击未果，直到最后提示pom.xml中的thymeleaf依赖，继续尝试SSTI直到比赛结束。

### 反序列化
后来发现Spring OAuth的一些数据以序列化形式存储在数据库中。通过SQL注入更新自己的token为恶意payload，触发反序列化。需要注意的是，触发反序列化需要再次访问正常的授权链接。

实际测试中，ldap协议无法正常使用，具体原因尚不清楚。

## 总结
虽然我在比赛中未能完全解决这道题，但通过不断尝试和学习，我对Spring OAuth有了更深入的理解。希望未来能更好地应对类似挑战。