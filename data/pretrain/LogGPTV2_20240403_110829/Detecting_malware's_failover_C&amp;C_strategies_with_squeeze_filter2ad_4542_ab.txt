eled as the exploration of a binary tree. The observant reader will
notice that Figure 1 is in fact a directed acyclic graph, rather than
a tree, since the node www.yahoo.com can be reached from two
different paths. However, malware may exhibit different behavior
depending on the sequence of endpoints it was able to contact. For
instance, the two ﬁle servers in Figure 1 may in fact deliver differ-
ent payloads. Strictly speaking, each node in the execution tree is
therefore identiﬁed by the sequence of endpoints that the malware
has attempted to contact so far, rather than by the latest endpoint
only. Note that an endpoint may be identiﬁed by its domain name
or by its IP address. We use the IP address only in cases where
the IP was not previously obtained by the analyzed sample through
DNS resolution.
Since we can analyze each malware sample for a limited amount
of time, it is unlikely that we can explore all possible branches of
the execution tree during an analysis run. In fact, some malicious
behavior (most obviously, scanning) involves attempting to contact
a practically unlimited number of endpoints. Therefore we need to
develop a strategy for exploring the execution tree that will reveal
the largest amount of C&C activities, given the time constraints.
Standard approaches for traversing a tree include depth-ﬁrst and
breadth-ﬁrst search algorithms. As we will see, neither approach is
directly suitable to the problem at hand. Instead, we will need to
develop exploration strategies that make use of domain knowledge
on C&C communication.
In a breadth-ﬁrst search, each node is completely expanded be-
fore proceeding to the next node. This would allow us to explore
many branches of a sample’s initial network behavior, but would
not lead us very deep within the execution tree. Since C&C end-
points, tried one after the other by the malware, typically form a
deep branch in the tree, depth is more important to us than breadth.
A depth-ﬁrst search would therefore seem better suited to our needs,
but in fact it also has its pitfalls. With a depth-ﬁrst search, explo-
ration can easily get “stuck” in a branch where a lot of uninteresting
network activity is occurring (such as port scanning or click fraud).
A solution to this problem is to enrich the search strategy with
additional knowledge on C&C communication. Such knowledge
can contribute to the decision whether a branch is of interest and its
nodes should be expanded or not. Ideally, we would exactly know
which nodes of the tree correspond to C&C endpoints. In practice,
however, we may not be able to automatically identify all C&C
communication. Nonetheless, since our goal is to automatically
build a blacklist of C&C endpoints, it is necessary to have some
means of identifying C&C trafﬁc. For SQUEEZE, we use domain
knowledge in the form of a set of network-based C&C signatures
that were provided to us by a security company. These signatures
have been vetted by human experts, so we have high conﬁdence that
they can identify C&C communication without generating false
positives (though they may not cover all forms of C&C communi-
cation, leading to false negatives). Furthermore, by matching these
signatures against the trafﬁc observed during malware execution in
our Anubis sandbox in the past, we can identify a set of known
C&C endpoints. The C&C signatures and the set of known C&C
endpoints constitute our initial knowledgebase on malware Com-
mand and Control.
There is a signiﬁcant difference between these two types of in-
formation: A known C&C endpoint can be blocked before a con-
nection is actually established, while a C&C signature can only
be matched after trafﬁc has already been transmitted. Hence, the
former can be used with a block-ﬁrst strategy while the latter re-
quires an allow-ﬁrst strategy. Another aspect to take into account
is that each component of the malware – bot, spam engine, etc. –
is typically executed in a separate process. Using our C&C knowl-
edgebase, we are able to identify the process or processes that are
carrying out C&C communication. We will call these processes the
bot component. With this information, we can focus our efforts on
exploring the parts of the execution tree that represent endpoints
contacted by the bot component.
For SQUEEZE, we developed two alternative strategies for ex-
ploring the execution tree. Both can be seen as depth-ﬁrst search
algorithms, but they differ in the type of C&C knowledge that they
leverage. Figure 2 provides an example for both approaches.
(a) Strategy A
(b) Strategy B
Figure 2: The two exploration strategies. A node represents an endpoint. A
solid line represents an allowed connection, a crossed line a blocked con-
nection and dotted lines backtracking before another endpoint is discovered.
Strategy A takes advantage of the set of known C&C endpoints.
When using this strategy, SQUEEZE initially allows all connec-
tions. Once the analyzed malware attempts to contact a known
(cid:1)(cid:2)
C&C endpoint, SQUEEZE blocks the connection, and switches to
a block-ﬁrst, depth-ﬁrst search. After each decision to block or
allow an endpoint, a timeout is restarted. If no further endpoints
are contacted within the timeout, the search backtracks. Further-
more, whenever the tool detects a connection to a known C&C
endpoint, it identiﬁes the responsible process, and adds it to the bot
component. The exploration strategy only takes into account end-
points contacted by the bot component, and always allows trafﬁc to
other endpoints. The idea behind this strategy is to allow the mal-
ware to perform connectivity checks or other network behavior that
needs to be successfully completed before C&C communication is
triggered. Once the malware attempts a ﬁrst C&C connection, it
is blocked, leading the bot to attempt to contact its backup C&C
servers, one after the other. Note that this strategy will fail if no
known C&C endpoints are observed.
Figure 2(a) shows an example of Strategy A in action: After
allowing the connection to E1, the system recognizes the known
C&C endpoint E2. Blocking E2 causes the malware to perform
an intermediate connection check on endpoint E3. The connection
is initially blocked, and the sample performs no further network
behavior. After a timeout, we track back and unblock E3. Follow-
ing the now successful connection check, the malware contacts its
backup C&C server at endpoint E4.
Strategy B takes advantage of the set of C&C signatures. When us-
ing this strategy, SQUEEZE performs a depth-ﬁrst, allow-ﬁrst search.
However, the C&C signatures are matched against all observed net-
work trafﬁc. As soon as a signature matches the trafﬁc going to a
speciﬁc endpoint, SQUEEZE backtracks, blocking communication
with this C&C endpoint. This strategy is aimed at efﬁciently dis-
covering endpoints that can be detected with the available C&C
signatures.
Figure 2(b) shows an example of Strategy B: When a signature
match is detected in trafﬁc to E1, the system tracks back and blocks
this endpoint. Since the following connection check on endpoint
E2 is successful, the malware immediately proceeds to the backup
C&C server E3. Trafﬁc from E3 also matches a C&C signature.
Blocking this endpoint reveals E4.
The two strategies have different advantages and disadvantages.
By using a block-ﬁrst approach, strategy A tends to reveal more
endpoints overall. However, unless the exploration backtracks far
enough to allow the malware to connect to an initially blocked end-
point, we do not observe trafﬁc to it and are therefore unable to
conﬁrm if it is in fact a C&C server. Strategy B has the advantage
that it will trigger on a C&C connection even if the contacted C&C
endpoint is not known. Finally, an advantage of strategy A is that it
is more ﬂexible, and can leverage knowledge of C&C endpoints re-
gardless of how they were detected. Strategy B, on the other hand,
relies on the ability to detect C&C communication on the ﬂy. It
cannot be as easily combined with C&C detection approaches that
rely on observing the behavior of a bot after it receives a command,
such as those from Wurzinger et al. [23].
4 System Description
Figure 3 shows an overview of SQUEEZE’s architecture. SQUEEZE
takes as input a malware sample and a knowledgebase on C&C
communication. Depending on the exploration strategy used, this
knowledgebase can contain C&C network signatures or C&C server
endpoints. While the sample is executing in the sandbox, its net-
work activity is constantly monitored and compared with the C&C
information. Whenever a new endpoint is encountered, we take a
snapshot of the current state of the system. The exploration strategy
then determines when to backtrack in the execution tree by revert-
ing to a previous snapshot. Furthermore, the sandbox’s network
environment is dynamically modiﬁed by re-conﬁguring a DNS re-
cursor and a ﬁrewall. Finally, a delay analysis module within the
sandbox tries to avoid delays between the malware’s network con-
nections by manipulating time (as observed from within the sand-
box), to “fast-forward” malware execution.
Figure 3: SQUEEZE Architecture
4.1 Sandbox
To build our analysis sandbox we leveraged our Anubis dynamic
malware analysis system [21, 27]. Anubis is a dynamic malware
analysis service that has been operating since early 2007, and has
since analyzed over ten million malware samples. At its core is an
instrumented full system emulator for the Windows XP operating
system [21] and is built upon Qemu [28].
Snapshotting. To be able to backtrack in our exploration of the
execution tree, we need to be able to revert the state not only of
the malware being analyzed, but also of the operating system and
analysis environment that it runs in. While it would in principle be
possible to simply restart a sample’s analysis with a different net-
work conﬁguration every time we need to backtrack, this would be
extremely inefﬁcient. Furthermore, in the new execution the mal-
ware might exhibit completely different behavior, confusing our
exploration algorithms.
Since Anubis is a full system emulator, it is possible to take a
snapshot of the state of the entire system (disk, memory and pro-
cessor state), and to restore such a snapshot to revert the execution
to the previous state. In fact, Qemu provides such a snapshotting
mechanism. However, the Anubis instrumentation also keeps some
execution state. For instance, it tracks which processes are under
analysis and what resources operating system handles correspond
to. To use Qemu snapshotting in Anubis, we therefore extend it to
also save and restore the state of the Anubis instrumentation.
To reduce the time spent saving and restoring snapshots, we keep
all generated snapshots in main memory, rather than save them to
disk. Since we only have a limited amount of memory available,
this imposes an upper bound on the number of snapshots that can be
stored simultaneously. Since we use depth-ﬁrst exploration strate-
gies, this essentially corresponds to a limit to the depth of the exe-
cution tree that we can explore. With a suitable amount of memory
this limit is seldom reached during SQUEEZE analysis.
Delay skipping. A general problem of dynamic analysis is that,
for practical reasons, we are only able to execute each binary for a
limited amount of time. For instance, in its default conﬁguration,
Anubis executes each sample for four minutes. As a consequence,
malware could evade dynamic analysis by simply waiting a certain
amount of time before performing any interesting behavior. For
(cid:1)(cid:2)
SQUEEZE, this problem is exacerbated by the fact that malware
frequently waits for some time before trying to contact a backup
C&C server or resorting to a failover C&C strategy.
While this problem is hard to solve in general, in practice most
malware samples can be tricked into skipping such delays. For this,
we modify the behavior of system calls that can be used to delay
a process’ execution. As a ﬁrst countermeasure, we intercept the
undocumented NtDelayExecution native Windows API func-
tion, which returns after a speciﬁed time interval, and limit the de-
lay to a maximum of half a second. Furthermore, we tamper with
instructions and system calls, such as GetTickCount, that can
serve as local sources of timing information, and could be used to
busy-wait until a certain time has elapsed. Speciﬁcally, we send
time forward by an interval that grows exponentially with the num-
ber of invocations of GetTickCount, up to a maximum value
(currently set to ﬁve hours).
Trafﬁc Interception. To be able to trigger the generation of snap-
shots and the dynamic re-conﬁguration of the network environment
required by our exploration strategy, SQUEEZE needs to match the
network trafﬁc generated by the malware against C&C endpoints
and signatures on the ﬂy. For this, we hook into the appropriate op-
erating system interfaces and inspect their parameters before the ac-
tual functions are executed. Note that in Anubis, hooking happens
from “outside the box” by instrumenting the emulator, rather than
by modifying the operating system “inside the box”. Speciﬁcally,
we hook the NtDeviceIoControlFile function which is used
to send data to device drivers. The driver used to transmit data over
sockets is afd.sys, which is the Ancillary Function Driver for
WinSock. Of the various I/O control codes used to handle connec-
tions, two are important for us: AFD_CONNECT which is used to
establish a connection to a port at an IP address and AFD_SEND
which sends input data out over an established link. To keep track
of and be able to react to DNS queries, we additionally intercept the
Windows DNS client’s DnsQuery function that is implemented in
dnsapi.dll.
4.2 Network Environment
SQUEEZE needs to dynamically adapt the network environment to
block or allow connections to speciﬁc endpoints in accordance with
the selected exploration strategy. For endpoints identiﬁed by a host-
name, we want to block the hostname at the DNS level rather than
the IP addresses associated with it. To this end we redirect all DNS
queries to a local recursor. We use the popular PowerDNS recur-
sor2, because it allows ﬁne-grained dynamic conﬁguration using
LUA scripts. This enables us to create an NXDOMAIN reply for
DNS queries for hostnames we wish to block. To block IP ad-
dresses that are directly contacted by the malware (without a DNS
lookup), we leverage the netﬁlter ﬁrewall3 and conﬁgure it to re-
ject the connection attempt and reply to a TCP SYN packet with
a TCP reset, and to a UDP packet with an ICMP destination un-
reachable packet. This is more efﬁcient than simply dropping the
packet, because it avoids unnecessary delays caused by waiting for
connection time-outs on the client side.
In addition to the dynamic network blocking required for SQUEEZE,
we also need to prevent the analyzed samples from causing harm to
the internet at large. For this, we deploy the same countermeasures
employed by Anubis. These include preventing SPAM by redirect-
ing SMTP connections to a local mail server (that does not actually
send the mail), limiting a malware sample’s contribution to denial
of service attacks by throttling network throughput and number of
connections, and blocking frequent attack vectors by redirecting
trafﬁc on a number of ports (such as TCP ports 139 and 445) to a
2http://www.powerdns.com
3http://www.netﬁlter.org
local honeypot. These measures cannot completely guarantee that
the malware will not cause any harm (0-day attacks in particular are
hard to block). However, experience from the Anubis deployment
shows that they are in practice sufﬁcient for the safe operation of
a malware analysis sandbox. Over four years running Anubis, we
have received only a single abuse complaint, which was promptly
addressed.
5 Evaluation
To evaluate SQUEEZE, we tested it on several thousand malware
samples that had generated C&C trafﬁc in Anubis. As we will