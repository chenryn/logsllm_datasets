最近看了一些加密货币中使用的签名算法，其中IOTA使用的`Winternitz`一次性签名（WOTS）确实很有趣，这是一种hash签名，虽然几十年前就已经提出来了，不过一直没什么人用，因为生成的签名实在太长了，而且也看不到什么明显的优点，不过近几年因为量子密码的研究以及区块链技术倒是捞了这类签名一把，因为这种基于hash的签名算法被认为是可以抵抗量子计算的，不过这种算法也存在地址不能重用的问题，每次签名都会暴露私钥的一半，下面我们就介绍一下WOTS在IOTA中的应用以及存在的问题
# IOTA简介
在这里先简单说一下IOTA，这是个瞄准了物联网市场的项目，有别于传统的区块链项目，IOTA使用的结构是有向无环图（DAG），比如下面就是一个包含了20个块的IOTA结构
在IOTA中这样的结构被称为Tangle，不同于比特币那样的链式结构，这是一个网状的结构，所以也有一些人质疑IOTA这样的技术是否能被称之为区块链
此外IOTA还有几个特点，首先它的交易是免交易费的，也没有什么矿工之类的，在整个网络里每个块就代表一个交易，你自己签署一笔交易后在Tangle中找两个还未得到确认的块（Tips）验证其交易后使自己的交易指向这两个块，然后进行适当的POW计算过程使交易的hash满足要求，所以你可以将用户当成这个系统中的矿工，大家自己开采包含自己交易的块，这个POW过程的难度很小，所以大家基本上几分钟内都可以完成。这种模式也是为了物联网而设计，适用于高并发但数据量较小的系统。
其中IOTA的共识达成的过程也很有意思，包含新的交易如何选择其要指向的交易以及IOTA如何防止双花等等，因为不是本文的重点，在这里就不展开说了，有兴趣的可以看这一系列文章，[how
IOTA works under the hood](https://blog.iota.org/the-tangle-an-illustrated-introduction-4d5eae6fe8d4)
不过需要指出的是因为在IOTA中发送垃圾交易的成本非常低，所以限于网络的规模以及IOTA的技术还不够成熟，目前的IOTA为了防止51%攻击还是要靠一个协调节点（coordinator
node）来对网络进行审查，被它的交易确认的块才是主链，现在的IOTA事实上还是一个偏向于中心化的系统，按照其负责人的说法等未来网络规模扩大，节点数量足够多时就会撤销这一协调节点。
另外在IOTA中比较特别的就是它采用的是三进制，因为三进制架构的电路功耗是较低的，IOTA的创始人认为未来将会是三进制电路的世界，不得不说IOTA确实是走在了前列，包括采用三进制以及抗量子的算法。
顺带一提三进制系统可以分为平衡三进制和非平衡三进制这两种，在三进制系统里对应我们二进制系统中的bit的是叫trit，在平衡三进制中可取的三个值为-1（T），0和1，而非平衡系统中则取0，1和2。
在IOTA中我们使用的是平衡三进制，在这个系统里一个字节表示Tryte，其中包含3个trits，也就是说可取的范围是3^3=27，这跟2进制世界里一个byte包含8个bit还是有较大区别，IOTA为Tryte构建了对应的字母系统，由26个英文字母与数字9组成，如下表
下面提到的公私钥以及hash算法等都是基于这样的三进制系统，不得不说就目前而言直接采用三进制还是带来了很多麻烦，毕竟目前的机器还都是2进制的，跑它的算法并木有什么加成，而且软件层面还是得先进行转换，这样就牺牲了一定的效率，只能说IOTA的团队还是比较有想法吧
# hash签名
下面我们简单介绍一下hash签名，其实它非常简单，至少其原理是比RSA和ECC等其他公钥密码要简单的多，首先我们从最简单的Lamport一次性签名来认识一下
## Lamport One Time Signature (OTS)
首先我们随机生成一对私钥，每个私钥都包含256个随机数，这里每个随机数都取256bit大小，确实私钥是非常长的，如下
然后我们将这一对私钥中每个随机数都进行hash，得到了公钥对
然后我们就可以开始签名了，对于文件M，首先计算得到它的hash值，H(M)，这里H(M)也是256bit长的，然后我们检查H(M)的每一个bit，对于第n个bit，当其为0时，我们就取私钥串1的第n个数，当其值为1时，我们就取私钥串2的第n个数，比如当文件M的hash为`110...10`时，情况就如下
将红色块的数字合并就得到了文件M的签名，至于该签名的验证也非常简单，我们计算出M的hash后依据同样的算法再从公钥对中取值，将公钥中的hash合并后看是否跟签名相同即可
观察上面的签名过程，我们不难发现发布签名后实际上我们将私钥的一半公布出去了，哪怕是这样其实这种算法也是很安全的，因为攻击者并不知道另一半的私钥，除非他能破解该hash函数，从公钥推出私钥
不过如果你再次使用该私钥进行签名的话，那么又会随机暴露一半的私钥，相当于在之前没暴露的一半里再随机显示一半，这样你暴露的私钥就达到了75%，这样就非常危险了，攻击者已经有能力根据这暴露的私钥信息伪造签名了，所以说hash签名的地址一般都是一次性的，重复使用是不可取的，当然，也不是说就不存在地址可重复使用的hash签名技术，比如基于Merkle树的Merkle
OTS方案，该方案使用的公钥是一串公钥对的根hash，事实上每次签名使用的依然是不同的私钥，而且该方案的签名长度更长，公钥对较多的话签名长度可能是Lamport方案的几倍，有兴趣的可以看看这篇文章，[Hash
based signatures](https://www.imperialviolet.org/2013/07/18/hashsig.html)
# Winternitz One Time Signature (WOTS)
下面我们进入正题，在IOTA中使用的签名方案是WOTS，跟Lamport方案一样，它每次签名也会暴露私钥的一半，不过它的暴露形式却不那么一样，还是比较有趣的
## IOTA的私钥与地址
我们先简要了解一下IOTA中的私钥与地址的产生模式，因为每个地址都只使用一次，所以在钱包中每次都会产生一个新的地址来进行交易，一般是使用一个种子来生成这一系列的私钥
IOTA的种子也是遵循三进制的，其使用的字母就是我们前面提到的26个字母加9，长度为81，按照官方推荐的种子生成方法，我们也可以自己产生安全的种子，在linux和mac上可以分别使用下面的命令
    >>>cat /dev/urandom |tr -dc A-Z9|head -c${1:-81} //linux
    >>>cat /dev/urandom |LC_ALL=C tr -dc 'A-Z9' | fold -w 81 | head -n 1 //Mac
如下
由种子我们可以产生私钥，值得一提的是在IOTA中还包含了三种安全等级，代表了不同的私钥长度
总的私钥长度为`2187 * 安全等级 trytes`
在官方钱包中默认的安全等级为2，所以一般我们在Tangle中看到的交易都是使用的安全等级为2的地址，在不同的安全等级下给种子加上对应的index即可得到不同的私钥，结构如下
然后我们来看看派生出私钥后如何得到公钥地址
首先将私钥划分成L份，每份都是81 trytes，所以L = 安全等级 * 27
然后我们将每一块都hash 26次，然后再合并得到digest，这是IOTA的说法，然后hash digest两次即可得到地址，也就是公钥，过程如下
## IOTA中的WOTS签名
下面我们来看看IOTA中的签名过程
对于消息M，我们首先计算出它的hash
H(M)，不过这里使用的是IOTA中的基于三进制的hash算法，跟前面使用的hash算法一样，所以它的输出也是三进制的Tryte字母串
此外值得一提的是IOTA一开始使用的Curl哈希算法是[存在问题](https://medium.com/@neha/cryptographic-vulnerabilities-in-iota-9a6a9ddc4367)的，后来就换成了目前的Kerl算法，当时也发生了一些纠葛，有兴趣的可以去了解了解
对于要签署的hash值H，首先我们依然是按照前面计算地址的方法将私钥分成L份，然后根据H中第N个Tryte的值来计算第N份的hash次数Ni，计算方式如下
> Ni = 13 - TtoD(H[N])
TtoD表示将该Tryte转换为10进制，转换表即为前面那个Tryte的字母表
比如我们随便取一串hash，`ABC......`
之后的验证过程也很简单
我们将签名划分为L份，然后根据H中第N个Tryte的值来计算第N份的hash次数Nj，计算方式如下
> Ni = 13 + TtoD(H[N])
对于上面的签名验证过程如下
当签名值正确时我们验证过后得到的digest就相当于把私钥hash了26次，所以这样与公钥验证就是符合的
看到这里你可能有些奇怪，貌似在这个过程里并没有直接暴露私钥啊，不过严格来说还是会暴露一部分的，当要签名的hash中包含Tryte字符M时，因为其对应的十进制为13，所以在签名时相当于对应位置的私钥并没有hash，这一块的私钥就暴露了，不过这并不是对WOTS的真正威胁所在
在继续之前我们有必要先了解一下IOTA的交易结构
## IOTA的bundle结构
之前我们也提到了在IOTA中每个块都是一笔交易，事实上如果按照其他传统的区块链系统的标准来看，这些交易是不完全的，在IOTA中真正的交易其实是bundle
IOTA中的交易模型类似于比特币的UTXO，我们不妨来看看一个[bundle](https://thetangle.org/bundle/ERZXWGBF9YFDTSGQBTHRJJLQP9YQL9BDCGHSKDTURLTAHVO9DAXOSENRJMIJJFAVX9NKBECIIEYYDECAX)的例子
从图中我们可以看出一个bundle类似于比特币，可以有多个`Vin`和`Vout`，我们来看看bundle中一个交易的基本结构
    { 
      hash: 'WCWHEXQXTEWYSGGPTITZVJNENDGXVF9KTEJMLSEGQEMOJHJJKFXVRENQWARBFLXOBPMWAUQYRDCTZ9999',
      signatureMessageFragment: 'ASQNBNJCJXJIITXEWFDIXEEROSDITNETRMETJWHLNEVXBXSHJWV......',
      address: 'TDIJAKIZYMBFUHRXXPTOFNMC9UPJQJBPELGMQWJOULAYSNKRPYKTMBZOEITGBMMGI9JMAVDNO9QNGOMFY',
      value: -6062321,