a Horn clause a1, . . . , an → a0 in T such that a0σ = bi and
for every j ∈ {1, . . . , n} there exists k ∈ {1, . . . , i − 1} with
ajσ = bk. In what follows, we sometimes refer to bi by π(i)
and to b1, . . . , bi by π≤i. The length l of a derivation π is
referred to by |π|.
We call a sequence b1, . . . , bl of ground atoms an in-
complete syntactic derivation of a from T if bl = a and
T ∪ {b1, . . . , bi−1} (cid:96) bi for every i ∈ {1, . . . , bl}.
Similarly, we write T (cid:96)⊕ a if there exists a derivation
i.e., there exists a sequence
of a from T modulo XOR,
b1, . . . , bl of ground atoms such that bl ∼ a and for ev-
ery i ∈ {1, . . . , l} there exists a substitution σ and a Horn
clause a1, . . . , an → a0 in T such that a0σ ∼ bi and for every
j ∈ {1, . . . , n} there exists k ∈ {1, . . . , i − 1} with ajσ ∼ bk.
Incomplete derivations modulo XOR are deﬁned analogously
to the syntactic case.
Given T and a, we call the problem of deciding whether
T (cid:96) a (T (cid:96)⊕ a) is true, the deduction problem (modulo
XOR). In case T models a protocol and the intruder (as
described below), the fact that T (cid:96)⊕ a, with a = I(t), is not
true means that the term t is secret, i.e., the intruder cannot
get hold of t even when running an unbounded number of
sessions of the protocol and using algebraic properties of the
XOR operator.
Modeling Protocols by Horn theories. Following [2],
we now illustrate how Horn theories can be used to analyze
cryptographic protocols, where, however, we take the XOR
operator into account. While here we concentrate on secrecy
properties, authentication is discussed in Section 5. As men-
tioned in the introduction, the Horn theory approach allows
us to analyze the security of protocols w.r.t. an unbounded
number of sessions and with no bound on the message size in
a fully automatic and sound way. However, the algorithms
are not guaranteed to terminate and may produce false at-
tacks.
A Horn theory for modeling protocols and the (Dolev-
Yao) intruder uses only the predicate I. The fact I(t) means
that the intruder may be able to obtain the term t. The
fundamental property is that if I(t) cannot be derived from
the set of clauses, then the protocol preserves the secrecy of
t. The Horn theory consists of three sets of Horn clauses:
the initial intruder facts, the intruder rules, and the protocol
rules. The set of initial intruder facts represents the initial
I(x) → I(hash(x))
I((cid:104)x, y(cid:105)) → I(x)
I(x), I(y) → I({x}y),
I(x), I(pub(y)) → I({|x|}pub(y)),
I(x), I(y) → I(x ⊕ y)
I(x), I(y) → I((cid:104)x, y(cid:105))
I((cid:104)x, y(cid:105)) → I(y)
I({x}y), I(y) → I(x)
I({|x|}pub(y)), I(y) → I(x)
Figure 1: Intruder Rules.
intruder knowledge, such as names of principals and public
keys. The clauses in this set are facts, e.g., I(a) (the intruder
knows the name a) and I(pub(ska)) (the intruder knows the
public key of a, with ska being the corresponding private
key). The set of intruder rules represents the intruders abil-
ity to derive new messages. For the cryptographic primitives
mentioned above, the set of intruder rules consists of the
clauses depicted in Figure 1. The last clause in this ﬁgure
will be called the ⊕-rule. It allows the intruder to perform
the XOR operation on arbitrary messages. The set of pro-
tocol rules represents the actions performed in the actual
protocol. The ith protocol step of a principal is described
by a clause of the form I(r1), . . . , I(ri) → I(si) where the
terms rj, j ∈ {1, . . . , i}, describe the (patterns of) messages
the principal has received in the previous i−1st steps plus
the (pattern of the) message in the ith step. The term I(si)
is the (pattern of) the ith output message of the principal.
Given a protocol P , we denote by TP the Horn theory that
comprises all three sets mentioned above.
Let us illustrate the above by a simple example proto-
col, which we will use as a running example throughout this
paper. Applications of our approach to more complex pro-
tocols are presented in Section 6.2. We emphasize that the
kind of Horn theories outlined above are only an example
of how protocols and intruders can be modeled. As already
mentioned in the introduction, our methods applies to all
⊕-linear Horn theories.
Running example. We consider a protocol that was pro-
posed in [7]. It is a variant of the Needham-Schroeder-Lowe
protocol in which XOR is employed. The informal descrip-
tion of the protocol, which we denote by PNSL⊕ , is as follows:
1. A → B : {|(cid:104)N, A(cid:105)|}pub(skB )
2. B → A : {|(cid:104)M, N ⊕ B(cid:105)|}pub(skA)
3. A → B : {|M|}pub(skB )
where N and M are nonces generated by A and B, respec-
tively. As noted in [7], this protocol is insecure; a similar
attack as the one on the original Needham-Schroeder pro-
tocol can be mounted, where, however, now the algebraic
properties of XOR are exploited.
To illustrate how this protocol can be modeled in terms
of Horn theories, let P be a set of participant names and
H ⊆ P be the set of names of the honest participants. As
proved in [11], for the secrecy property it suﬃces to consider
the case P = {a, b} and H = {a} (for authentication three
participants are needed). In the following, ska, for a ∈ P,
denotes the private key of a, n(a, b) denotes the nonce sent
by a ∈ P to b ∈ P in message 1., and m(b, a) denotes the
nonce generated by b and sent to a in message 2.
The initial intruder knowledge is the set {I(a) | a ∈ P} ∪
{I(pub(ska)) | a ∈ P} ∪ {I(ska) | a ∈ P \ H} of facts. The
intruder rules are those depicted in Figure 1. The ﬁrst step
of the protocol performed by an honest principal is modeled
by the facts:
I({|(cid:104)n(a, b), a(cid:105)|}pub(skb))
for a ∈ H, b ∈ P. Note that it is not necessary to model
messages sent by dishonest principals, since these are taken
care of by the actions that can be performed by the intruder.
The second step of the protocol performed by an honest
principal is modeled by the clauses:
I({|(cid:104)x, a(cid:105)|}pub(skb)) → I({|(cid:104)m(b, a), x ⊕ b(cid:105)|}pub(ska))
(3)
for b ∈ H, a ∈ P. The third step of the protocol performed
by an honest principal is modeled by the clauses:
I({|(cid:104)y, n(a, b) ⊕ b(cid:105)|}pub(ska)) → I({|y|}pub(skb))
(4)
for a ∈ H, b ∈ P. The set of Horn clauses deﬁned above is
denoted by TPNSL⊕ . It is not hard to verify that we have
TPNSL⊕ (cid:96)⊕ m(b, a) for every a, b ∈ H. In fact, secrecy of the
nonces sent by an honest responder to an honest initiator is
not guaranteed by the protocol [7].
3. DOMINATED DERIVATIONS
In Section 4, we show how to reduce the deduction prob-
lem modulo XOR to the one without XOR for ⊕-linear Horn
theories, introduced below. This reduction allows us to re-
duce the problem of checking secrecy for protocols that use
XOR to the case of protocols that do not use XOR. (The au-
thentication problem will be considered in Section 5.) The
latter problem can then be solved by tools that cannot deal
with XOR, such as ProVerif. The class of protocol and in-
truder capabilities that we can handle this way is quite large:
It contains all protocol and intruder rules that are ⊕-linear.
In this section, we prove a proposition that will be the key
to the reduction. Before we can state the proposition, we
need to introduce ⊕-linear Horn theories and some further
terminology.
A term is ⊕-linear if for each of its subterms of the form
t⊕ s, where t and s may be standard or non-standard terms,
it is true that t or s is ground. In other words, if a term t
contains a subterm of the form t1 ⊕ ··· ⊕ tn with n ≥ 2,
ti standard for every i, and there exists i and j, i (cid:54)= j,
such that ti and tj are not ground, then t is not ⊕-linear.
For example, for variables x, y, z and a constant a, the term
ex = (cid:104)a, a ⊕ (cid:104)x, y(cid:105)(cid:105) is ⊕-linear, but the term t2
ex = (cid:104)a, a ⊕
t1
(cid:104)x, y(cid:105) ⊕ z(cid:105) is not. A Horn clause is called ⊕-linear if each
term occurring in the clause is ⊕-linear. A Horn theory is
⊕-linear if each clause in this theory, except for the ⊕-rule
(see Fig. 1), is ⊕-linear. In particular, given a protocol P ,
the induced theory TP is ⊕-linear if the sets of protocol and
intruder rules, except for the ⊕-rule, are.
Our running example is an example of a protocol with
an ⊕-linear Horn theory (note that, in (3) and (4), b is
a constant); other examples are mentioned in Section 6.2.
Also, many intruder rules are ⊕-linear.
In particular, all
those that do not contain the XOR symbol. For example, in
addition to the cryptographic primitives mentioned in Fig-
ure 1, other primitives, such as various kinds of signatures,
encryption with preﬁx properties, and MACs have ⊕-linear
intruder rules.
Besides ⊕-linearity, we also need a more ﬁne-grained no-
tion: C-domination. Let C be a ﬁnite set of standard ⊕-
reduced ground terms such that C does not contain two ele-
ments m, m(cid:48) with m (cid:54)= m(cid:48) and m ∼ m(cid:48). (For the eﬃciency
of our reduction (Section 4), it is important to keep C as
small as possible.) Let C⊕ = {t | there exist c1, . . . , cn ∈ C
such that t ∼ c1 ⊕···⊕ cn} be the ⊕-closure of C. Note that
0 ∈ C⊕. Finally, let ˜C = {t | t ∼ t(cid:48) ∈ C, t standard}.
Now, a term is C-dominated if, for each of its subterms
of the form t ⊕ s, where t and s may be standard or non-
standard, it is true that t or s is in C⊕. For example, the
ex from above is {a}-dominated, but is is not {b}-
term t1
ex is not {a}-dominated. A Horn
dominated. The term t2
clause is C-dominated, if the terms occurring in this clause
are C-dominated; similarly for derivations. Finally, a Horn
theory T is C-dominated if each clause in T , except for the
⊕-rule, is C-dominated. For example, we have that the Horn
theory TPNSL⊕ of our running example is {a, b}-dominated.
(Recall that P = {a, b}.)
C-dominated terms can also be characterized in terms of
what we call bad terms. We call a non-standard term t bad
(w.r.t. C), if t ∼ c ⊕ t1 ⊕ . . . ⊕ tn for c ∈ C⊕, pairwise ⊕-
distinct standard terms t1, . . . , tn /∈ ˜C, and n > 1, where t
and t(cid:48) are ⊕-distinct if t (cid:54)∼ t(cid:48). A non-standard term which is
not bad is called good. The following lemma is easy to see:
Lemma 1. An ⊕-reduced term is C-dominated iﬀ it con-
tains no bad subterms.
There is an obvious connection between ⊕-linearity and C-
domination:
Lemma 2. For every ⊕-linear term/Horn theory/deriva-
tion there exists a ﬁnite set C of standard ⊕-reduced mes-
sages such that the term/Horn theory/derivation is C-dom-
inated.
The set C mentioned in the lemma could be chosen to be the
set of all ground standard terms occurring in the term/Horn
theory/derivation. However, C should be chosen as small as
possible in order to make the reduction presented in Sec-
tion 4 more eﬃcient.
As mentioned, the following proposition is the key to our
reduction. The proposition states that C-dominated Horn
theories always allow for C-dominated derivations. Because
of Lemma 2, the proposition applies to all ⊕-linear Horn
theories.
Proposition 1. Let T be a C-dominated Horn theory
and b be a C-dominated fact. If T (cid:96)⊕ b, then there exists
a C-dominated derivation modulo XOR for b from T .
Before we present the proof of this proposition, we introduce
some terminology, which is also used in subsequent sections,
and sketch the idea of the proof. We write t (cid:39)C t(cid:48) if t(cid:48) ∼ c⊕t
(or equivalently, c ⊕ t(cid:48) ∼ t), for some c ∈ C⊕.
For the rest of this section we ﬁx a derivation π modulo
XOR for b from T . W.l.o.g. we may assume that each term
occurring in π is in ⊕-reduced form and that each term in a
substitution applied in π is in ⊕-reduced form as well.
The key deﬁnitions for the proof of Proposition 1 are the
following ones:
Deﬁnition 1. For a standard term t, the set C, and the
derivation π, we deﬁne the type of t (w.r.t. π and C), written
˜t, to be an ⊕-reduced element c of C⊕ such that π(i) ∼
I(c ⊕ t) for some i, and for each j < i, it is not true that
π(j) ∼ I(c(cid:48) ⊕ t) for some c(cid:48) ∈ C⊕. If such an i does not exist,
we say that the type of t is undeﬁned.
Note that the type of a term is uniquely determined modulo
AC and that equivalent terms (w.r.t. ∼) have equivalent
types.
In the following deﬁnition, we deﬁne an operator which
replaces standard terms in bad terms which are not in ˜C
by their types. This turns a bad term into a good one.
To deﬁne the operator, we use the following notation. We
write ϕ⊕[x1, . . . , xn] for a term which is built only from ⊕,
elements of ˜C, and the pairwise distinct variables x1, . . . , xn
such that each xi occurs exactly once in ϕ⊕[x1, . . . , xn]. An
example is ϕex⊕ [x1, x2, x3] = ((x1⊕ x2)⊕ (a⊕ x3)), where a ∈
˜C. For messages t1, . . . , tn, we write ϕ⊕[t1, . . . , tn] for the
message obtained from ϕ⊕[x1, . . . , xn] by replacing every xi
by ti, for every i ∈ {1, . . . , n}. Note that each non-standard
term can be expressed in the form ϕ⊕[t1, . . . , tn] for some
ϕ⊕ as above and standard terms t1, . . . , tn /∈ ˜C.
Deﬁnition 2. For a message t, we deﬁne ∆(t) as follows:
If t is a bad term of the form ϕ⊕[t1, . . . , tn] for some ϕ⊕
as above and standard terms t1, . . . , tn /∈ ˜C, then ∆(t) =
ϕ⊕[˜t1, . . . , ˜tn]; ∆(t) is undeﬁned, if one of those ˜ti is unde-