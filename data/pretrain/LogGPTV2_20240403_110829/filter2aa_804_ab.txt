Userland cmds
þ A dynamic library. 
§  Use Xcode's template. 
§  Add a constructor. 
§  Fork, exec, system, thread(s), whatever you need. 
§  Don't forget to cleanup library traces! 
I never leave 
footprints! 
Userland cmds
§  Problems with this technique: 
§  Requires library at disk (can be unpacked from 
rootkit and removed if we want). 
§  Needs to kill a process (but can be used to infect 
specific processes when started). 
§  Proc structure is not stable (get fields offset 
using the disassembler). 
Hide & seek
§  OS X is “instrumentation” rich: 
§  DTrace. 
§  FSEvents. 
§  kauth. 
§  kdebug. 
§  TrustedBSD. 
§  Auditing. 
§  Socket filters. 
Hide & seek
§  Let’s focus on DTrace's syscall provider. 
§  Nemo presented DTrace rootkits at Infiltrate. 
§  Siliconblade with Volatility "detects" them. 
§  But Volatility is vulnerable to an old trick. 
Get the f*ck 
outta here! 
Hide & seek
§  Traces every syscall entry and exit. 
§  mach_trap is the mach equivalent provider. 
§  DTrace's philosophy of zero probe effect when 
disabled. 
§  Activation of this provider is equivalent to sysent 
hooking. 
§  Modifies the sy_call pointer inside sysent struct. 
Hide & seek
Hide & seek
§  Not very useful to detect sysent hooking. 
§  fbt provider is better for detection (check SyScan 
slides). 
§  Nemo's DTrace rootkit uses syscall provider. 
§  Can be detected by dumping the sysent table and 
verifying if _dtrace_systrace_syscall is present. 
§  False positives? Low probability. 
Hide & seek
Hide & seek
Hide & seek
" Nemo's presentation has shown again that 
known tools can be used for subverting a 
system and won't be easy to spot by a novice 
investigator, but then again nothing can hide 
in memory ;) " 
@ http://siliconblade.blogspot.com/2013/04/hunting-d-trace-rootkits-with.html 
Hide & seek
§  It's rather easy to find what you know. 
§  How about what you don't know? 
§  Sysent hooking is easily detected by memory 
forensics (assuming you can get memory dump!). 
§  But fails at old sysent shadowing trick. 
§  Check http://siliconblade.blogspot.pt/2013/07/
offensive-volatility-messing-with-os-x.html 
I don't know 
anything! 
Hide & seek
No hooking! 
Not fun L 
Hide & seek
Sysent hooking, 
meh! 
Hide & seek
Shadow sysent. 
U can't see me! 
Hide & seek
§  Volatility plugin can easily find sysent table 
modification(s). 
§  But fails to detect a shadow sysent table. 
§  Nothing new, extremely easy to implement with 
the kernel disassembler! 
§  Hindsight is always easy! 
Hide & seek
§  How to do it in a few steps: 
§  Find sysent table address via IDT and bruteforce, 
or some other technique. 
§  Warning: Mavericks has a modified sysent table. 
§  Use the address to find location in __got section. 
§  Disassemble kernel and find references to __got 
address. 
Hide & seek
§  Allocate memory and copy original sysent table. 
§  Find space inside kernel to add a pointer 
(modifying __got is too noisy!). 
§  Install pointer to our sysent copy. 
§  Modify found references to __got pointer to our 
new pointer. 
§  Hook syscalls in the shadow table. 
Hide & seek
§  Many instrumentation features available! 
§  Do not forget them if you are the evil rootkit 
coder. 
§  Helpful for a quick assessment if you are the 
potential victim. 
§  Be very careful with tool's assumptions. 
Checkpoint 
Zombies
Otterz? 
Zombies? 
Zombies
§  Create a kernel memory leak. 
§  Copy rootkit code to that area. 
§  Fix permissions and symbols offsets. 
§  That’s easy, we have a disassembler! 
§  Redirect execution to the zombie area. 
§  Return KERN_FAILURE to rootkit's start function. 
Idea! 
Zombies
þ Create a kernel memory leak. 
§  Using one of the dynamic memory functions. 
§  kalloc, kmem_alloc, OSMalloc, MALLOC/FREE, 
_MALLOC/_FREE, IOMalloc/IOFree. 
§  No garbage collection mechanism. 
§  Find rootkit’s Mach-O header and compute its 
size (__TEXT + __DATA segments). 
Zombies
q Fix symbols offsets. 
§  Kexts have no symbol stubs as most userland 
binaries. 
§  Symbols are solved when kext is loaded. 
§  RIP addressing is used (offset from kext to 
kernel). 
§  When we copy to the zombie area those offsets 
are wrong. 
Zombies
q Fix symbols offsets. 
§  We can have a table with all external symbols or 
dynamically find them (read rootkit from disk). 
§  Lookup each kernel symbol address. 
§  Disassemble the original rootkit code address 
and find the references to the original symbol. 
§  Find CALL and JMP and check if target is the 
symbol. 
Zombies
þ  Fix symbols offsets. 
§  Not useful to disassemble the zombie area because 
offsets are wrong. 
§  Compute the distance to start address from CALLs in 
original and add it to the zombie start address. 
§  Now we have the location of each symbol inside the 
zombie and can fix the offset back to kernel symbol. 
Zombies
q Redirect execution to zombie. 
§  We can’t simply jump to new code because 
rootkit start function must return a value! 
§  Hijack some function and have it execute a 
zombie start function. 
§  Or just start a new kernel thread with 
kernel_thread_start. 
Zombies
þ Redirect execution to zombie. 
§  To find the zombie start function use the same 
trick as symbols: 
§  Compute the difference to the start in the original 
rootkit. 
§  Add it to the start of zombie and we get the 
correct pointer. 
Zombies
þ Return KERN_FAILURE. 
§  Original kext must return a value. 
§  If we return KERN_SUCCESS, kext will be loaded 
and we need to hide or unload it. 
§  If we return KERN_FAILURE, kext will fail to load 
and OS X will cleanup it for us. 
§  Not a problem because zombie is already 
resident. 
Zombies
§  No need to hide from kextstat. 
§  No kext related structures. 
§  Harder to find (easier now because I'm telling you). 
§  Wipe out zombie Mach-O header and there’s only 
code/data in kernel memory.  
§  It’s fun! 
Advantages 
I eat zombies 
for breakfast! 
Zombies
Demo 
(Dear Spooks: all code will be made public, 
don't break my room! #kthxbay) 
Fire the 
drones!!! 
Zombies
Zombies
Zombies
Problems
q Unstable internal structures! 
§  Proc structure is one of those. 
§  We just need a few fields. 
§  Find offsets by disassembling stable functions. 
§  Possible, you just need to spend some time 
grep'ing around XNU source code and IDA. 
Problems
q Memory forensics. 
§  A worthy rootkit enemy. 
§  But with its own flaws. 
§  In particular the acquisition process. 
§  Some assumptions are weak. 
§  Needs more features. 
Problems
§  And so many others. 
§  It's a cat & mouse game. 
§  Any mistake can be costly. 
§  When creating a rootkit, reduce the number of 
assumptions you have. 
§  Defenders face the unknown. 
§  Very hard game – abuse their assumptions. 
Conclusions
Conclusions
§  Improving the quality of OS X kernel rootkits is 
very easy. 
§  Stable and future-proof requires more work. 
§  Prevention and detection tools must be 
researched & developed. 
§  Kernel is sexy but don't forget userland. 
§  OS.X/Crisis userland rootkit is powerful! 
§  Easier to hide in userland from memory forensics. 
Conclusions
§  Attackers have better incentives to be creative. 
§  Defense will always lag and suffer from 
information asymmetry. 
§  Economics didn't solve this problem and I doubt 
InfoSec will (because it's connected to 
Economics aka MONEY). 
§  Always question assumptions. This presentation 
has a few ;-). 
Pratice makes 
perfection! 
nemo, noar, snare, saure, od, emptydir, korn, g0sh, 
spico and all other put.as friends, everyone at 
COSEINC, thegrugq, diff-t, #osxre, Gil Dabah from 
diStorm, A. Ionescu, Igor from Hex-Rays, NSA & 
friends, and you for spending time of your life 
listening to me J. 
Greets
We are hiring!
§  Software Engineers. 
§  Based in Singapore. 
§  2 years experience. 
§  You know C and Python better than me! 
§  Can communicate in English. 
§  $80000NT monthly salary. 
§  Housing provided. 
§  2 Years contract. 
http://reverse.put.as 
http://github.com/gdbinit 
PI:EMAIL 
PI:EMAIL 
@osxreverser 
#osxre @ irc.freenode.net 
And iloverootkits.com maybe soon! 
Contacts
End! At last… 
Have fun! 
A day full of possibilities! 
Let's go exploring!