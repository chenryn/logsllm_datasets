title:Automatically Detecting SSL Error-Handling Vulnerabilities in Hybrid
Mobile Web Apps
author:Chaoshun Zuo and
Jianliang Wu and
Shanqing Guo
Automatically Detecting SSL Error-Handling Vulnerabilities
in Hybrid Mobile Web Apps
Chaoshun Zuo
Shandong University
PI:EMAIL
Jianliang Wu
Shandong University
PI:EMAIL
Shanqing Guo
Shandong University
PI:EMAIL
ABSTRACT
Today, there are many hybrid apps in which both native An-
droid app UI and WebView UI are used. To protect the se-
curity and privacy of the communications, these hybrid apps
all use HTTPS by WebView, a key component in modern
web browser. In this paper, we show there is another type of
SSL vulnerability that stems from the error-handling code
in the hybrid mobile web apps. At a high level, this error-
handling code should have stopped the communication but it
still proceeds regardless of certi(cid:12)cate errors, thereby leading
to the MITM attacks. To automatically identify these vul-
nerable apps, we present a hybrid approach that combines
both static analysis and dynamic analysis. We have imple-
mented our approach and evaluated with 13,820 real world
mobile web apps from a third party market, of which 645
are con(cid:12)rmed truly vulnerable, with an average overhead of
60.8 seconds per app.
Categories and Subject Descriptors
D.2.4 [Software Engineering]: Software/Program Veri(cid:12)-
cation; D.2.5 [Software Engineering]: Testing and De-
bugging
Keywords
Android Security, HTTPS, SSL, WebView
1.
INTRODUCTION
Increasingly, there are hybrid apps that combine both na-
tive Android UI and WebView UI, because of the easier de-
velopment and lower maintaining complexity. Speci(cid:12)cally,
mobile web apps use WebViews to present web pages and
communicate with web servers. Some web pages may trans-
fer sensitive information, like user name and password, to
a server, which causes that the communication should be
protected. For this reason, they all use HTTPS connections
instead of HTTP connections. Under normal circumstances,
the attackers couldn’t attack HTTPS connections even if
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ASIA CCS’15, April 14 - 17, 2015, Singapore, Singapore
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3245-3/15/04 ...$15.00.
http://dx.doi.org/10.1145/2714576.2714583.
Figure 1: The State Machine of error handling pro-
cess.
they sni(cid:11)ed the network tra(cid:14)c unless they have the cryp-
tographic keys. However, developers’ incorrect implementa-
tion of HTTPS in WebView can allow Android WebView to
present a web page with illegal certi(cid:12)cate, which can thus
be attacked by Man-in-the-middle [1, 2] or phishing attacks.
Figure 1 shows how this vulnerability happened. When
an app opens an HTTPS web page with an illegal certi(cid:12)-
cate, the app passes the HTTPS URL to Android to verify
the certi(cid:12)cate. With an illegal certi(cid:12)cate Android will get a
veri(cid:12)cation failure, then it will call error handling procedure
implemented by the developer. Often times this error han-
dler code just ignores the error and calls proceed to show
the HTTPS web page (even though the certi(cid:12)cate is illegal).
This is a particular type of implementation vulnerability we
aim to (cid:12)nd in this paper.
More speci(cid:12)cally, it’s possible to analyze this vulnerabili-
ty manually for a particular app. However, it is impractical
to detect this vulnerability on a large scale, given the huge
amount of such apps in the market. Meanwhile, unlike na-
tive apps, mobile web apps bring new challenges because we
have to test not only the normal native app activities but
also the web pages. For static analysis, the existing tools
such as androguard [3] are not suitable to detect this vul-
nerability because they cannot track variables. In addition,
we can’t determine whether an app is vulnerable or not by
static analysis only (because it is often an over approxima-
tion, leading to false positives). Dynamic analysis is needed
to verify whether the WebView would eventually load an
HTTPS page and its error handling is vulnerable.
As such, we have designed a new system to automatically
identify these vulnerable apps. Our system consists of both
static analysis and dynamic analysis. In particular, we (cid:12)rst
employ static analysis to determine whether these apps are
1
HTTPS URLproceedCertificate VerificationError-HandlingPassFail591potential vulnerable or not. If so, the potential vulnerable
apps will be further analyzed through our dynamic analy-
sis, which is guided by the static analysis information to
drive the native Android UI as well as the WebView UI to
trigger the vulnerability. In summary, this paper makes the
following contributions:
- We have discovered a new type of SSL vulnerability
which could lead to insecure WebView HTTPS con-
nection.
- We have designed a hybrid Android web app test frame-
work using multi emulators. This framework contains
both static analysis and dynamic analysis. It can in-
stall and run a mobile web app automatically without
any user involvement. Besides, not only could the sys-
tem stimulate jumps between Activities but also it is
able to drive jumps between web pages within Web-
View.
- We have implemented our framework and tested with
13,820 apps collected in July 2014. Experimental re-
sults show that our static analysis found 1,360 poten-
tial vulnerable apps and our dynamic analysis con-
(cid:12)rmed that 645 of them are vulnerable.
2. SYSTEM OVERVIEW
2.1 Problem Statement
For hybrid mobile web apps, when an HTTPS URL is
passed to WebView, it will (cid:12)rst verify the certi(cid:12)cate of the
HTTPS server:
if passed WebView will show the page. If
veri(cid:12)cation failure occurs and the app has rewritten the er-
ror handling process, WebView will pass the error handling
process to the app and wait for the result. Once the error
handling passed to the app, it will handle the error in its
own way including ignoring the error and proceed and re-
turn the result to WebView. If error handling process has
not been rewritten, WebView would shield the page direct-
ly. However, programmers often rewrite the error handling
process.
It’s obvious that this is a serious security prob-
lem, especially for apps that always use HTTPS to transfer
sensitive information such as the login information, user in-
formation, payment information, authorization information,
etc. With this vulnerability un(cid:12)xed, attackers could easily
get all these information by MITM attack.
2.2 Challenges and Solutions
2.2.1 Is the potential vulnerable code reachable?
To identify the app is vulnerable or not, we have to make
sure it contains potential vulnerable code. We assume the
class inherits from WebViewClient which overrides the error
handling method (i.e. onReceivedSslError) and has the ig-
nore code is potential vulnerable. Any app without this kind
of code is invulnerable. It’s not easy to make sure if onRe-
ceivedSslError is reachable because it’s called by system
callbacks rather than called directly. We locate the method
call setWebViewClient and (cid:12)nd out whether a potential vul-
nerable WebViewClient has been registered or not. If yes,
then we (cid:12)nd the Activity that loads the WebView which reg-
isters this WebViewClient. So we consider this Activity as
a target Activity. This helps us to make sure this potential
vulnerable code is reachable when the Activity is reachable.
2.2.2 How to record Activity jump relations with trig-
ger events?
To con(cid:12)rm if potential app is vulnerable we need to jump
to the target Activity from launcher Activity by triggering
related events which have been recorded during static analy-
sis. To ful(cid:12)ll this we build an ACG[4] based on which a path
from launcher Activity to target Activity is found, which
could guide the dynamic test. ACG is a directed Activity
Call Graph of which vertexes represents Activities. And we
put information on the edge because we need to know what
event triggers the jump from one Activity to another.
Vertexes are not hard to (cid:12)nd but edges (i.e. how to (cid:12)nd
the view and event) are not easy to add. We take view and
the event triggered by the view that cause Activity jump
as an edge. Here goes how we (cid:12)nd edges. First, we (cid:12)nd
all the methods that could cause activity jump and locate
these functions in MCG (Method Call Graph). By traveling
within MCG we can (cid:12)nd method that causes activity jump
and which activity jump to. Then we locate event method
(such as onClick) the method belongs to. This view which
owns the event method and the event would be the edge.
With ACG, we are able to (cid:12)nd a path on which a series of
trigger events are recorded from launcher Activity to target
WebView.
2.2.3 How to simulate human operations to both na-
tive Android UI and WebView UI ?
Manual analysis is enough for a particular app, but for
large dataset, it’s impossible. We need to make it possi-
ble to detect automatically thus making large scale analysis
possible. Along the process from launcher Activity to load
an illegal page, human operations are needed. To make it
automatic, we need to simulate human operations. To miti-
gate this, we have made our own test system Android Tester
by modifying the Android framework and we use Robotium
developed a general test script app for the target apps .
With this framework, we could know which Activity is ac-
tive, which views are on this Activity, their IDs and how to
trigger one speci(cid:12)c event all of which other test tools cannot
do. Once we jumped to the target Activity, how to jump to
the HTTPS page within WebView if the default page is not
an HTTPS page? Here in test script we adopt a strategy
like a crawler. We (cid:12)rst load the default page and extract
all the links from the initial page and load every link and
extract links again until we have found an HTTPS link or
the crawl layer depth is up to 3.
2.3 System Overview
We present the overview of our system in Figure 2. Our
system takes APK (cid:12)le as input, and outputs the app is vul-
nerable or not. First, our system carries out a static anal-
ysis to determine if apps are potential vulnerable. Second,
we need to dynamically run them and to con(cid:12)rm if it’s real-
ly vulnerable, which is requisite because of the di(cid:14)culty of
validness veri(cid:12)cation of the self-implemented error handling
process and the uncertainty that if the WebView would load
an HTTPS page that cannot be solved during static analysis.
So we need to build the app’s ACG for dynamic analyzing.
Dynamic analysis starts with installing and running the
app on emulator. Then our system would (cid:12)nd a path from
launcher Activity to target Activity. When the path is
found, the system triggers an event and jumps to next Ac-
tivity till the target Activity. After each jump, our system
2
592Figure 2: System Overview
calculates the path again in order to avoid the situation that
the path found earlier is not applicable because of some ex-
tra conditions. During this process, we may not be able to
(cid:12)nd e(cid:14)cacious path, because there are some views that need
conditions to appear (e.g. some app may have an advanced
panel that would appear only under advanced mode). Un-
der this condition we jump to target activity directly. At the
same time, we built an attack environment (shown in Fig-
ure 2) which could redirect HTTPS connections to our fake
server who has an illegal certi(cid:12)cate. We modi(cid:12)ed Android
framework to print log once an illegal page are presented.
At last our system will generate log information and tell us
which app is vulnerable and what URL the app has visited.
3. DETAILED DESIGN
3.1 Static Analysis Module
Static Detection. We decompile APK into Smali (cid:12)le by
apktool[5]. The static analysis starts once the decompilation
process (cid:12)nished. We scan all the smali (cid:12)les to (cid:12)nd if there
is any class inherits from the WebViewClient class. If not