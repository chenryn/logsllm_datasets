## 合成和显示一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令------"DrawQuad"，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad命令，然后根据 DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript等文件，经过浏览器就会显示出漂亮的页面了。
## 渲染流水线大总结好了，我们现在已经分析完了整个渲染流程，从 HTML 到DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：![](Images/640939d3607eb93d4fab09c3c6c9cf8c.png){savepage-src="https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png"}```{=html}```完整的渲染流水线示意图]{.reference}```{=html}```结合上图，一个完整的渲染流程大致可总结为如下：1.  渲染进程将 HTML 内容转换为能够读懂的**DOM 树**结构。2.  渲染引擎将 CSS 样式表转化为浏览器可以理解的**styleSheets**，计算出    DOM 节点的样式。3.  创建**布局树**，并计算元素的布局信息。4.  对布局树进行分层，并生成**分层树**。5.  为每个图层生成**绘制列表**，并将其提交到合成线程。6.  合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。7.  合成线程发送绘制图块命令**DrawQuad**给浏览器进程。8.  浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。
## 相关概念有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念------**"重排""重绘"和"合成"**。理解了这三个概念对于你后续Web 的性能优化会有很大帮助。
### 1. 更新了元素的几何属性（重排）你可先参考下图：![](Images/4394b8e264d4fe74e443965834e3cbbc.png){savepage-src="https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png"}```{=html}```更新元素的几何属性]{.reference}```{=html}```从上图可以看出，如果你通过 JavaScript 或者 CSS修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫**重排**。无疑，**重排需要更新完整的渲染流水线，所以开销也是最大的**。
### 2. 更新元素的绘制属性（重绘）接下来，我们再来看看重绘，比如通过 JavaScript更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：![](Images/304c87d910b9f55cf5f33dc5e22e165f.png){savepage-src="https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png"}```{=html}```更新元素背景]{.reference}```{=html}```从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫**重绘**。相较于重排操作，**重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些**。
### 3. 直接合成阶段那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做**合成**。具体流程参考下图：![](Images/2a5309a5ac0c023bbd2122f59900cdf5.png){savepage-src="https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png"}```{=html}```避开重排和重绘]{.reference}```{=html}```在上图中，我们使用了 CSS 的 transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以**相对于重绘和重排，合成能大大提升绘制效率**。至于如何用这些概念去优化页面，我们会在后面相关章节做详细讲解的，这里你只需要先结合"渲染流水线"弄明白这三个概念及原理就行。
## 总结通过本文的分析，你应该可以看到，Chrome的渲染流水线还是相当复杂晦涩，且难以理解，不过 Chrome团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是**让整体渲染架构变得更加简单和高效**，正所谓大道至简。通过这么多年的生活和工作经验来看，无论是做架构设计、产品设计，还是具体到代码的实现，甚至处理生活中的一些事情，能够把复杂问题简单化的人都是具有大智慧的。所以，在工作或生活中，你若想要简化遇到的问题，就要刻意地练习，练就抓住问题本质的能力，把那些复杂的问题简单化，从而最终真正解决问题。
## 思考时间在优化 Web性能的方法中，减少重绘、重排是一种很好的优化方式，那么结合文中的分析，你能总结出来为什么减少重绘、重排能优化Web 性能吗？那又有那些具体的实践方法能减少重绘、重排呢？欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/7e91bd5c116048de87e68468f727fc3c.png){savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}