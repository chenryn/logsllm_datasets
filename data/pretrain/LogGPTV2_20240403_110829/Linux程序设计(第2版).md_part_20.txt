einclude cunistd.h>
include 
off_t lseek(int fildes,oft_t offeet, int vbance);
Iseek系统调用对文件描述符fides的读写指针进行设置，你可以用它设置文件的下一个读写
位置。既可以把指针设置到文件中的某个绝对位置，也可以把它设置到相对于当前位置或文件
尾的某个相对位置。offset参数用来指定位置，面whence参数定义该偏移值的用法。whence可以
是下列取值之；
·SEEK_SET
offset是一个绝对位置。
·SEEK_CUR
offset是从当前位置算起的一个相对位置。
加入java编程群：524621833
---
## Page 98
第3章如何使用和处理文件
79
•SEEK_END
offset是从文件尾算起的一个相对位置。
lseek的返回值是从文件头到文件指针被设置处的字节偏移值；操作失败时返回“-1”.指针
移动操作中偏移值offset的类型off_t是一个与操作系统具体实现有关的类型，它的定义在文件
sys/types.h里。
2.fstat、stat和lstat系统调用
#include 
#include 
#include
int fatat（int fildes,atruct stat *buf);
int latat(const char *path, etruct stat *buf);
注意加上sys/types.h文件的包括操作被认为是“可选但叉明智的”。
fstat系统调用返回的是与一个打开的文件描述符关联着的文件的状态信息。这些信息将被写
到一个buf结构里，其地址作为一个参数被传递过去：
同一系列的stat和lstat函数返回的是通过文件名查到的文件状态信息。它们的结果基本-一致，
但在文件是一个符号链接的情况下，lstat返回的是该符号链接本身的信息，而stat返回的是该链
接指向的文件的信息。
stat结构的构成在不同UNIX系统上会有所变化，但肯定会有表3-4所示这些内容：
表3-4
stat数据项
说明
st._node
文件权限和文件类短信息
st_1no
与该文件关联的inode
st_dev
文件保存在其上的设备
st_uid
文件属主的用户身份标识
st_gid
文件属主的分组身份标识
st_atime
st_ctime
文件权限、城主、分组或内容方面的上次被修改时间
st_mtime
文件内容方面的上次被修改时间
st_nlink
该文件上硬键接的个数
stat结构中返回的st_mode标志还有一些与之关联的宏定义，它们是在头文件sys/stat.h里被定
义的。其中包括对访问权限、文件类型标志以及部分掩码的定义，它们能够帮助我们对特定的
类型和权限进行测试。
访问权限标志与刚才在open系统调用里介绍过的内容是一致的。文件类型标志包括：
·S_IFBLK
文件是·-个特殊的块设备。
·S_IFDIR
文件是一个子目录。
•S_IFCHR
文件是一个特殊的字符设备。
·S_IFIFO
文件是一个FIFO设备（有名字的管道）
·S_IFREG
文件是个普通文件。
·S_IFLNK
文件是一个符号链接。
加入jaVva编程群：524621833
---
## Page 99
08
Linux程序设计
其他模式标志包括：
·S_ISUID
文件在执行时置位了setUID位。
·S_ISGID
文件在执行时置位了setGID位。
用来解释st_mode标志的掩码包括：
• S_IFMT
文件类型。
·S_IRWXU
属主的读/写/执行权限。
•S_IRWXG
分组的读/写/执行权限
·S_IRWXO
其他用户的读/写/执行权限。
还有一些用来帮助确定文件类型的宏定义。它们对经过掩码处理的模式标志和适当的设备
类型标志进行比较。它们包括：
•S_ISBLK
测试是否是特殊的块设备文件。
·S_ISCHR
测试是否是特殊的字符设备文件、
·S_ISDIR
测试是否是子目录。
•S_ISFIFO
测试是否是FIFO设备。
·S_ISREG
测试是否是普通文件。
•S_ISLNK
测试是否是符号链接。
举例来说，如果想对“文件代表的不是一个子目录、设置了属主的执行权限、不再有其他
权限”这种情况进行测试，我们可以使用下面的代码：
st.ruct stat statbuf:
nodc_t modes:
modes · statbuf.st_node;
stat(*t1lenane′,&statbuf) :
1f(1S_ISD1R(aodes) k (nodes & S_IRWXU) x= S_IXUSR)
3.dup和dup2系统调用
#include 
int dup2(int fildes,int fildes2);
int dup(int fi1des)1
dup系统调用提供了复制文件描述符的一个办法，使人们能够通过两个或者更多个不同的描
述符来访问同一个文件，在文件的不同位置对数据进行读写。dup系统调用对作为它参数的一个
文件描述符fildes进行复制，返回一个新的描述符。dup2系统调用是明确地把一个文件描述符复
制为另外一个，它必须给出一个描述符作为复制品参数。
当我们通过管道在多个进程间进行通信的时候，这些调用也很有用。我们还将在第11章对
dup系统调用进行研究。
3.5标准/O库
标准I/O库及其头文件stdio.h提供了一个全面的面向底层I/O系统调用的操作界面。这个库现
在已经成为ANSI标准下的C语言组成部分，面我们前面见到的系统调用还没有被包括在ANSI标
加入jaVa编程群：524621833
---
## Page 100
第3章如何使用和处理文件
81
准之内。标准I/O库提供了许多精密复杂的函数，使我们能够设置输出数据的格式和扫描处理输
人数据。它还负责协调设备的数据缓冲。
在很多方面，我们可以像使用底层文件描述符那样使用这个库。用户需要先打开一个文件
注意不要把这里的文件流与C++语言中的iostreams（输入输出流）或者AT&TUNIX
SystemVRelease3中引入的进程间通信用的STREAMS模型混为一该，进程间通信方面
的问题已经超出本书的讨论范围了。如果读者打算进一步了解STREAMS的情况，请自
行查阅X/Open技术规范和随SystemV版本--起提供的“AT&T STREAMS Prograrmming
Guide”（《AT&TSTREAMS程序设计指南》）
在一个程序开始运行的时候，有三个文件流是自动打开好了的。它们是stdin、stdout和stderr。
它们都是在stdio.h文件里定义的，分别代表着标准输入、标准输出和标准错误输出，即分别对应
着底层文件描述符0、1和2。
在接下来的内容里，我们将学习标准I/O库中的下列库函数：
·fopen和fclose。
fread和fwrite。
fflush。
·fsecko
fgetc、getc和getchar
·fputc、putc和putchar。
fgets和gets。
printf、fprintf和sprintf。
 scanf、fscanff和sscanf。
3.5.1fopen函数
#include
PILg *fopen(const char *fllenane, const char *aoed);
fopen库函数的作用相当于底层的open系统调用。它主要用于文件和终端的输入输出方面。
使用这个函数的前提条件是用户对准备读写的设备有明确的控制权，但这要比底层系统调用要
方便多了，因为它们把用户可能不太喜欢的辅助操作（比如输入输出的缓冲安排）交给函数库
去负责了。
fopen打开由filename参数给出名字的文件，并把它与一个文件流关联在一起。mode参数规
定了文件的打开方式，它是下列字符串中的一个：
·"r"或"rb"
以只读方式打开。
·”w”或”wb”
以写方式打开，并把文件长度截短为零。
·“a”或"ab”
以写方式打开，新内容追加在文件尾。
加入jaVa编程群：524621833
---
## Page 101
82
Linux程序设计
q++q.+*
以修改方式打开（读和写）
q+M+qm2+M
以修改方式打开，并把文件长度截短为零。
·"a+"或"ab+"或"a+b"
以修改方式打开，新内容追加在文件尾。
字每“b”表示文件是一个二进制文件面不是一个文本文件。请注意，UNIX与DOS的一个
不同之处就在于它并不明确区分文本文件和二进制文件。它对文件一视同仁，把它们都看做是
二进制文件。另一个需要重点注意的地方是mode参数必须是一个字符串，不是一个字符。所以
永远要使用"r"而不是r。
如果操作成功，fopen返回一个非空的“FILE*”指针。如果失败，它返回NULL空值，
NULL空值的定义也在stdio.h文件里。
3.5.2 fread函数
#include 
size_t fread(void *ptr, siso_t sizo.sizo_t nitems, PILg *strean)1
fread阵函数的作用是从一个文件流里读取数据。数据从文件流stream被读到由ptr指定的数
据缓冲区里。fread和fwrite都是对数据记录进行操作的，size参数指定每个数据记录的长度，计
数器nitems给出将要传输的记录个数。它的返回值是成功地读到数据缓冲区里去的记录个数（而
不是字节数）。当接近文件尾的时候，它的返回值可能会小于nitems，甚至可以是零。对所有向
缓冲区里写数据的标准I/O函数来说，为数据分配空间和检查有无出错的工作是由程序员负责的。
参见本章对ferror和feof函数的介绍。
3.5.3fwrite函数
1nclude 
slze_t fwrite(const void *ptr, size_t alze, elze_t nitems, ILg *stream);
fwrite库函数的接口与fread的接口差不多。它从指定的数据缓冲区里取出数据并把它们写到
输出流去。它的返回值是写操作成功的记录个数。
请注意，我们不推荐把fread和fwrite用在使用了结构化数据的场合。问题的部分原
因是用fwrite写的文件在不同的计算机之间可能不具备可移植性。我们将在附录A里对
可移植性做进一步研究。
3.5.4fclose函数
#include 
Int fclose(PILg *stream);
fclose库函数关闭指定的文件流stream，使所有尚未写出的数据都写到文件里去。因为stdlio
函数库会对数据进行缓冲，所以使用fclose是很重要的。如果程序需要确保数据已经全部写人文
件，就必须调用fclose函数。但是，当程序正常结束时，会自动对所有还打开着的文件流调用
加入jaVa编程群：524621833
---
## Page 102
第3章如何使用和处理文件
8
fclose关闭它们，可这样做就没有机会检查由fclose报告出来的错误了。可用文件流的个数是有
上限的，就像文件描述符的个数也有个上限一样。这个上限值叫做FOPEN_MAX，也在stdio.h
文件里定义，最少要设置为8。
3.5.5flush函数
#include 
int fflush(PILE *strean)1
ffush库函数的作用是把文件流里的现有数据立刻写人文件。举个例子，你可以用这个函数
来保证在试图读人一个用户响应之前先送出了一个交互操作的提示符。如果想在程序继续执行
之前确保重要的数据已经被写到磁盘上，也可以使用这个函数。在调试某个程序的时候，你还
可以用它来核查程序是正在写数据还是被挂起了。调用fclose函数隐含着执行一次“立刻写”操
作，所以我们不必在fclose的前面调用fush函数。
3.5.6fseek函数
#include 
int fseek（rrLg *strean, long int offset, int whence);
fseek库函数是lscek系统调用的文件流对应版。它在文件流里为下一次读或写操作设置偏移
位置。offset和whence参数的含义和取值与前面介绍lseek时给出的内容完全一样。但lseek返回的
是一个off_t数值，面fseck返回的是一个整数：“0”表示操作成功：“-1”表示失败并设置errno
指出错误的类型。这就是人们说的标准化！
3.5.7 tgetc、getc、getchar函数
tinclude 
int fgetc（7ILz *atream）;
Int getcbar()1
int getc（rrLz*streun);
fgetc库函数从文件流里取出下一个字节并把它当做一个字符返回。当它到达文件尾或出现
/
错误时，它返回EOF。用户必须通过ferror或feof来区分这两种情况。
getc函数的作用相当于fgetc，但我们可以在stream参数不允许有副作用的情况下（即它既不
能影响非本地的局部变量也不能影响将做为参数传递到函数里去的变量时）把getc实现为一个宏。
当然，在这种情况下，用户也就不能使用getc的地址做为一个函数指针。
getchar函数相当子getc（stdin），它从标准输入里读取下一个字符。
3.5.8tputc、putc、putchat函数
sinclude 
int fputc（int c,rIlz*stream);
int putc（int c,rrLz *streun）)
int putcbar(int c)1
加入jaVa编程群：524621833