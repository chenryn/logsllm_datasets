title:Catch You With Cache: Out-of-VM Introspection to Trace Malicious Executions
author:Chao Su and
Xuhua Ding and
Qingkai Zeng
5
4
0
0
0
.
1
2
0
2
.
7
8
9
8
4
N
S
D
/
9
0
1
1
.
0
1
:
I
O
D
|
E
E
E
I
1
2
0
2
©
0
0
.
1
3
$
/
1
2
/
7
-
2
7
5
3
-
4
5
6
6
-
1
-
8
7
9
|
)
N
S
D
(
s
k
r
o
w
t
e
N
d
n
a
s
m
e
t
s
y
S
e
l
b
a
d
n
e
p
e
D
n
o
e
c
n
e
r
e
f
n
o
C
l
a
n
o
i
t
a
n
r
e
t
n
I
P
I
F
I
/
E
E
E
I
l
a
u
n
n
A
t
s
1
5
1
2
0
2
2021 51st Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)
Catch You With Cache: Out-of-VM Introspection to
Trace Malicious Executions
Chao Su
Xuhua Ding
Qingkai Zeng
State Key Lab for Novel Software Tech.
School of Information Systems
State Key Lab for Novel Software Tech.
Nanjing University
PI:EMAIL
Singapore Management University
PI:EMAIL
Nanjing University
PI:EMAIL
Abstract—Out-of-VM introspection is an imperative part of
security analysis. The legacy methods either modify the system,
introducing enormous overhead, or rely heavily on hardware
features, which are neither available nor practical in most cloud
environments. In this paper, we propose a novel analysis method,
named as Catcher, that utilizes CPU cache to perform out-of-
VM introspection. Catcher does not make any modiﬁcations to
the target program and its running environment, nor demands
special hardware support. Implemented upon Linux KVM, it na-
tively introspects the target’s virtual memory. More importantly,
it uses the cache-based side channel to infer the target control
ﬂow. To deal with the inherent limitations of the side channel, we
propose several heuristics to improve the accuracy and stability of
Catcher. Our experiments against various malware armored with
packing techniques show that Catcher can recover the control
ﬂow in real time with around 67% to 97% accuracy scores.
Catcher incurs a negligible overhead to the system and can be
launched at anytime to monitor an ongoing attack inside a virtual
machine.
Index Terms—Out-of-VM Introspection, Cache, Malware
Analysis, Non-intrusiveness, Transparency
I. INTRODUCTION
Control ﬂow tracing is one of the fundamental goals of
dynamic malware analysis as it reveals malicious behaviors
some of which are hardly available with static analysis. Typical
ways to capture the control ﬂow are either software instrumen-
tation or the use of hardware facility. Code instrumentation
places hooks to the target program and records control transfer
destinations, especially system calls and function calls. Inser-
tion of foreign instructions inevitably alters the target’s virtual
address space. Hardware facility for performance proﬁling and
debugging purposes, e.g., Intel’s Performance Monitor Unit
(PMU), Processor Tracing, and ARM’s TreadMill, has the
capability of logging control transfers without modifying the
target. Nonetheless, since this type of facility is often disabled
in a production or end-user system, its activation strongly
indicates the presence of malware analysis. To turn on the
needed facility, the OS hosting the malware needs to explicitly
set it up and handle events (if any) triggered by the facility in
use. Moreover, certain facility also has noticeable performance
slowdown. For instance, BTS is reported to introduce 6.1%
overhead [34].
Malware nowadays inﬁltrates defense mechanisms by de-
vising advanced evasion techniques. It might check debugger
or other system artifacts to infer whether it is under analysis.
Introspection for malware with anti-analysis abilities requires
more transparency. Most analysis methods, working with a
debugger or dynamic binary instrumentation, can be detected
by the malware. We characterize existing methods as environ-
mental intrusive approaches, because environmental changes
(e.g., address space alternation, hardware setting changes,
and performance slowdown) would not exist if the malware
execution were not under analysis. Clearly, environmental
intrusiveness is undesirable for malware analysis since it im-
pairs transparency. Advanced malware may detect the presence
of analysis, especially after it obtains the kernel privilege.
Unlike x86 virtualization, those changes are strong evidence
of analysis and malware will prohibit its malevolent behaviors.
In addition, the necessity of environmental variation hinders
smooth and “silent” deployment of those analysis tools in
scenarios wherein there is no prior setup or users cannot
securely login to the concerned system. Although there are
ways to impose the change on the system (e.g., by trapping
it to the hypervisor [10]), they often contaminate the attack
scene and may even cause malware execution to terminate.
Out-of-VM introspection [7], [9], [23], [31], [37], [39]
examines a target virtual machine’s virtual or physical memory
and is especially known for its non-intrusiveness to the target
as compared to in-VM introspection. However, the introspec-
tion scheme is limited to read the target memory and is not
capable of capturing control ﬂows in the VM. In this paper, we
propose a novel out-of-VM introspection technique (termed as
Catcher) to trace malicious execution without environmental
variability.
A. System & Adversary Models
II. SYNOPSIS
We consider a multicore platform with CPU and MMU
virtualization extensions. It is managed by Linux KVM. To
specify different systems in this paper, the virtual machine
hosting the OS with target malware to analyze is deﬁned as the
target VM. We assume hardware security and cache latency
cannot be manipulated by OS or malware. We also assume
the host OS (i.e., the hypervisor) managing the target VM
is trusted. The malware in study may contain anti-analysis
techniques that check if it is under monitoring.
We focus on how to trace malware execution in a non-
intrusive and transparent fashion. Applications of the tracing
978-1-6654-3572-7/21/$31.00 ©2021 IEEE
DOI 10.1109/DSN48987.2021.00045
326
Authorized licensed use limited to: Tsinghua University. Downloaded on October 11,2021 at 09:25:25 UTC from IEEE Xplore.  Restrictions apply. 
data are not of our interest. Reverse engineering techniques
are used as a building block in our scheme. Their accuracy is
also out of our study scope.
B. Idea Sketch
The design of Catcher is based on the fact that cache states
are closely related to control ﬂow. Different execution paths
result in different cache states. Figure 1 depicts two possible
execution traces of a process with dashed and solid arrows.
Recently executed code blocks will show “hit” while non-
executed code blocks will show “miss” when we test their
cache states. The two cache states A and B are tightly bound
with their execution paths. Hence, if the states of the cache
can be obtained, the control ﬂow of the program can probably
be inferred.
g1, g2 ← different branches from g0
s1 ←PROBECACHELINESTATE(g1)
s2 ←PROBECACHELINESTATE(g2)
if s1 == hit && s2 == miss then
Algorithm 1 Core scheme of Catcher
1: get a starting code block g0
2: while g0! = end do
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
end if
14:
15: end while
16: return P
g0 ← g1
add g0 to execution path P
g0 ← g2
add g0 to execution path
else if s1 == miss&& s2 == hit then
else
get another starting code block g0
with control ﬂow, and thus this provides a non-intrusive way
to monitor target malware.
A. Cache Access
Monitoring the target process from across VMs non-
intrusively through CPU cache is hard. In most cases, the
analyzer cannot obtain cache states directly across VMs.