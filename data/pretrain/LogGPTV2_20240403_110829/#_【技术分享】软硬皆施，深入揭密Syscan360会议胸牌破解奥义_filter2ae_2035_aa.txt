# 【技术分享】软硬皆施，深入揭密Syscan360会议胸牌破解奥义
|
##### 译文声明
本文是翻译文章，文章来源：阿里先知
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
**  
**
**作者：阿里安全IoT安全研究 谢君**
**背景**
有幸参加今年11月份的上海Syscan360安全会议，会议期间有一个亮点就是360的独角兽团队设计了一款电子badge(胸牌)供参加人员进行破解尝试，类似于美国Defcon上面的那种解密puzzle的比赛，在参会现场的人都可以参加这种破解，总共9道题，规则是现场会给每道题谜面，在这块胸牌上面输入正确的谜底才能进入下一题，解题需要开脑洞，有好些人参与破解，而且有好些人都解出来了，今天笔者从这块胸牌的硬件和软件层面去揭密这个胸牌的一些有意思的功能和如何在不需要知道谜面的情况下，快速解密答案，算是硬件破解方面抛砖引玉。
**初识篇**
我这边看到有两块板，一块黑色一块红色，其中黑色如下：
**硬件配置如下：**
MCU: 德州仪器TI CC1310 型号（CC1310F64RGZ）VQFN (48) 7.00 mm × 7.00 mm
ARM Cortex-M3处理器,时钟速度高达48Mhz
64KB片上可编程flash，20KB静态内存SRAM，30个GPIO口
RF Core支持收发1Ghz以下的无线信号
外置存储器: Winbond 25Q32bvsig
32Mbits存储空间
一个LCD液晶屏
四个led灯，若干电阻和电容，6个按键和开关，所有的这些构成一个小型的嵌入式系统
**使用方法：**
6个按键，分别负责切换不同的可打印的ASCII码，删除，进入和返回等功能。
只有所有的关卡通过后才能出现控制闪灯和产生红外信号去关闭遥控电视的功能，这是后话，后面细讲。
**硬件篇**
要想了解里面的原理和功能，必须得拿到里面的代码逻辑。通过查阅MCU
CC1310芯片的数据手册，我们发现它支持jtag仿真调试，我们只需要外挂支持ARM的仿真器，就可以进行整个内存空间的访问和片上动态调试，这一点对于我们逆向来讲非常有帮助，CC1310芯片布局如下。
    DIO_16 26 Digital I/O GPIO, JTAG_TDO, high-drive capability
    DIO_17 27 Digital I/O GPIO, JTAG_TDI, high-drive capability
我们知道要进行jtag调试需要至少4根信号线分别是TMS,TCK,TDI,TDO，(RST可选)最后是GND(接地),
具体JTAG的定义和各个信号线的定义大家可以网上搜索，我就不赘述了，找到这几个信号线接到相应的仿真器上就可以进行调试了。
从该MCU的电子手册我们得知这四个信号线的Pin脚位置如下。
     TMS                     24
              TCK                    25
              TDO                    26
              TDI                     27
然后我们可以通过万电表量出这几个引脚引出来的位置，刚好这板子已经把这几个信号脚引出来了，也省去我们不少麻烦。
好了，焊好线后，需要我们的仿真器出场了，笔者使用的ft2232h mini
module，当然大家也可以选用别的仿真器，像jlink之类的，简单说一下这个mini
module，它是一个多硬件协议(MPSSE)集一身的小模块，比如SPI/JTAG/I2C等，共用GPIO口，非常方便，接下来就是连线了，连接图如下。
右边是mini module CN-2接口Pin脚，左边是CC1310的引脚，GND随便找一个板子接地的地方接上就好了。
下面就是ft2232h mini module。
好了，接下来就是激动人心的时刻了。
**软件篇**
硬件连接准备就绪后，我们开始驱动仿真器来进行片上调试。
调试工具准备如下：
OpenOCD (开源的硬件调试软件)
Arm-none-eabi-gdb (arm版的gdb)
在使用openocd之前需要准备好cc1310的调试配置文件cc1310.cfg，在
[http://openocd.zylin.com/gitweb?p=openocd.git;a=blob;f=tcl/target/cc1310.cfg;h=8f86bd4b965a02922ae1abc98f53c8a4c65f9711;hb=27c749394270555698e3f5413082d5c6898d8151
](http://openocd.zylin.com/gitweb?p=openocd.git;a=blob;f=tcl/target/cc1310.cfg;h=8f86bd4b965a02922ae1abc98f53c8a4c65f9711;hb=27c749394270555698e3f5413082d5c6898d8151%BF%C9%D2%D4%D5%D2%B5%BD)
可以找到。
一切准备妥当，接下来就可以开始见证奇迹的时刻了。
运行telnet localhost 4444进行命令行来控制操作cpu或者内存空间，在这里我们可把cpu halt暂停下来，cpu重置，设置断点等操作。
在这里我们执行halt命令，cpu就断下来了，效果如下
这个时侯我的gdb就可以远程attach上去进行动态调试与内存空间访问了。
运行arm-none-eabi-gdb，gdb里面执行target remote localhost:3333
进行远程调试连接，可以内存空间访问与动态调试。
好了，我们可以内存空间访问了，先把固件，flash，和内存数据dump出来，静态分析一下吧。
如下是cc13xx芯片的内存空间地址映射表，它可以让我们知道dump哪些有用的数据。
0地址开始到0x10000是我们CC1310F64型号的flash的地址空间
BootROM是从0x10000000到0x10020000
SRAM地址从0x20000000到0x20005000
好了，我们就dump这三块位置。
在gdb里面运行如下命令：
    dump binary memory cc1310_flash.bin 0 0x10000
    dump binary memory cc1310_brom.bin 0x10000000 0x10020000
    dump binary memory cc1310_sram.bin 0x20000000 0x20005000
好了，合并这三个文件用IDA进行反汇编，不同的段进行地址重定位，可以做到地址精确引用，如下。
好了，接下来就是逆向篇了，如何找到答案和分析其代码逻辑等等。
**逆向篇**
我们通过IDA里面的一些字符串获得一些线索。
然后我们很快找到每一道题的答案了。
解释一下这里面的一些逻辑。
这里面每一道题的提示和答案，还有用户自定义ID存储在flash
0xe000开始的区域里面，总共长度0xe2个字节，运行时会把这块区域数据读到SRAM里面，在SRAM里面进行操作，然后把SRAM结果写回到0xe000这块区域里，以保证下次设备重启数据和进度不会丢失，其结构如下。
0xe000 —0xe010 存储用户设置的ID
0xe014 — 0xe015
存储用户过了多少关了（直接改成9就通关了：），修改SRAM里面相应的存储的数据，然后通过ID设置来触发写回到0xe014，这样就生效了）
如下是不同关卡的提示和答案：
比较每一个关卡的用户输入答案，并进行更新
0x20001060存储着flash地址0xe000里面的数据
偏移0x14就是用户当前所在关卡数，如果答案比较相等，这个关卡数加1并写回到flash里面，并在屏幕上显示‘right!’。
**总共9道题的答案分别是：**
    UR1NMYW0RLD!
    42
    ORDREDUTEMPLE
    FQJPVDPOK
    VYTX
    LOYAL
    GNILCS
    FIBONACHI
    WORLD
通关最后的结果如下：
如果你只想知道答案，看到这里就可以了，接下来会讲讲里面的一些其它功能。
**探密TVB Gone功能篇**
当所有的关卡都通过后，会多出来两项列表，分别是：  
6\. Led Light
7\. TVB Gone
进入Led Light前置的两个led灯可以显示3种颜色，这里是通过设置12号GPIO和19号GPIO口，对应在芯片上的引脚是18和29.
这里我们重点关注这个TVB
Gone功能，这个一个可以通过红外信号远程关闭很多不同品牌的电视的小应用，具体介绍参考[https://en.wikipedia.org/wiki/TV-B-Gone](https://en.wikipedia.org/wiki/TV-B-Gone)
我们知道我们家里面使用的电视的遥控器，一般都是发射的红外信号，来控制电视的开关，调台等操作，这个TVB
Gone的功能就是通过发射不同品牌和不同频率的控制信息来达到关闭遥控电视的目的。
红外控制信号通过一定频率的PWM(脉冲宽度调制)调制方式输出给led灯，led灯产生的红外信号影响遥控电视。
研究发现这个板子里面存储了80组红外控制信号源数据，通过特定的数据结构来存储，例如如下。
如下是存储每一组数据的地方指针列表
我们挑选其中一组来看
解释一下每个字段的含义：
0x9600：表示这种数据的发射频率38400Hz
0x1a：表示有多少对数据需要发送出去
0x02：表示每发送一对信号里面承载着2个bit数据
0x9e38：表示存储时间对的指针地址
0x97b4：表示要发送的数据的指针地址
地址0x97b4在存储的数据如下：
{0xe2, 0x20, 0x80,0x78,0x88,0x20,x10}