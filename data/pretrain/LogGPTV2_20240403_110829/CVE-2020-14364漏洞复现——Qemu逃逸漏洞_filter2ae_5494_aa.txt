# CVE-2020-14364漏洞复现——Qemu逃逸漏洞
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
这篇文章中的任意地址读写和利用思路主要借鉴于参考链接中的文章，中间找调用链和绕过检测是自己的思路，这个漏洞相比于CVE-2016-4952难了很多花了挺长时间，而且这个漏洞不仅仅只有本文这种利用方法，还可以使用其余的usb协议来进行利用，如果文章出现什么错误，恳请各位师傅斧正。
## 环境搭建
环境搭建参照CVE-2015-5165漏洞复现———QENU信息泄露漏洞那篇文章：[http://www.resery.top/2020/10/13/CVE-2015-5165%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0——QENU%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/](http://www.resery.top/2020/10/13/CVE-2015-5165%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0
------QENU%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/)
qemu版本：4.0.0
启动脚本：
    qemu-system-x86_64 \
        -enable-kvm \
        -m 1G \
        -hda /home/resery/QEMU/Resery.img \
        -device e1000,netdev=net0 \
        -netdev user,id=net0,hostfwd=tcp::33333-:22 \
        -usb \
        -drive if=none,format=raw,id=disk1,file=./usb.img \
        -device ich9-usb-ehci1,id=usb \
        -device usb-storage,drive=disk1 \
调试脚本：
    gdb --args qemu-system-x86_64 \
        -enable-kvm \
        -m 1G \
        -hda /home/resery/QEMU/Resery.img \
        -device e1000,netdev=net0 \
        -netdev user,id=net0,hostfwd=tcp::33333-:22 \
        -usb \
        -drive if=none,format=raw,id=disk1,file=./usb.img \
        -device ich9-usb-ehci1,id=usb \
        -device usb-storage,drive=disk1 \
        -nographic
## 漏洞成因
首先我们直接先去看官网patch的内容，下面就是patch的全部内容，可以在第7行看到新增了一个setup_len的局部变量，然后可以看到第15行到18行做的操作是，把原先代码中的`s->setup_len`换成了新的局部变量`setup_len`，然后后面patch的部分都是把原来的`s->setup_len`换成`setup_len`，所以说问题就肯定是出来setup_len这里了，下面我们就需要仔细来查看一下没打patch前的`do_token_setup`代码
    --- a/hw/usb/core.c
    +++ b/hw/usb/core.c
    @@ -129,6 +129,7 @@ void usb_wakeup(USBEndpoint *ep, unsigned int stream)
     static void do_token_setup(USBDevice *s, USBPacket *p)
     {
         int request, value, index;
    +    unsigned int setup_len;
         if (p->iov.size != 8) {
             p->status = USB_RET_STALL;
    @@ -138,14 +139,15 @@ static void do_token_setup(USBDevice *s, USBPacket *p)
         usb_packet_copy(p, s->setup_buf, p->iov.size);
         s->setup_index = 0;
         p->actual_length = 0;
    -    s->setup_len   = (s->setup_buf[7] setup_buf[6];
    -    if (s->setup_len > sizeof(s->data_buf)) {
    +    setup_len = (s->setup_buf[7] setup_buf[6];
    +    if (setup_len > sizeof(s->data_buf)) {
             fprintf(stderr,
                     "usb_generic_handle_packet: ctrl buffer too small (%d > 
    %zu)\n",
    -                s->setup_len, sizeof(s->data_buf));
    +                setup_len, sizeof(s->data_buf));
             p->status = USB_RET_STALL;
             return;
         }
    +    s->setup_len = setup_len;
         request = (s->setup_buf[0] setup_buf[1];
         value   = (s->setup_buf[3] setup_buf[2];
    @@ -259,26 +261,28 @@ static void do_token_out(USBDevice *s, USBPacket *p)
     static void do_parameter(USBDevice *s, USBPacket *p)
     {
         int i, request, value, index;
    +    unsigned int setup_len;
         for (i = 0; i setup_buf[i] = p->parameter >> (i*8);
         }
         s->setup_state = SETUP_STATE_PARAM;
    -    s->setup_len   = (s->setup_buf[7] setup_buf[6];
         s->setup_index = 0;
         request = (s->setup_buf[0] setup_buf[1];
         value   = (s->setup_buf[3] setup_buf[2];
         index   = (s->setup_buf[5] setup_buf[4];
    -    if (s->setup_len > sizeof(s->data_buf)) {
    +    setup_len = (s->setup_buf[7] setup_buf[6];
    +    if (setup_len > sizeof(s->data_buf)) {
             fprintf(stderr,
                     "usb_generic_handle_packet: ctrl buffer too small (%d > 
    %zu)\n",
    -                s->setup_len, sizeof(s->data_buf));
    +                setup_len, sizeof(s->data_buf));
             p->status = USB_RET_STALL;
             return;
         }
    +    s->setup_len = setup_len;
         if (p->pid == USB_TOKEN_OUT) {
             usb_packet_copy(p, s->data_buf, s->setup_len);
    --    
`do_token_setup`代码内容如下，可以看到我在代码中标注为bug的地方，这里会根据`s->setup_buf`中的内容来给setup_len来赋值，然后会对`s->setup_len`进行检测，如果超过`s->data_buf`的大小那么就会直接返回，但是返回的时候我们没有给`s->setup_len`的值清零，这也就意味着我们可以控制`s->setup_len`的值为任意值
    static void do_token_setup(USBDevice *s, USBPacket *p)
    {
        int request, value, index;
        if (p->iov.size != 8) {
            p->status = USB_RET_STALL;
            return;
        }
        usb_packet_copy(p, s->setup_buf, p->iov.size);
        s->setup_index = 0;
        p->actual_length = 0;
        s->setup_len   = (s->setup_buf[7] setup_buf[6];    setup_len > sizeof(s->data_buf)) {         %zu)\n",
                    s->setup_len, sizeof(s->data_buf));
            p->status = USB_RET_STALL;
            return;        setup_buf[0] setup_buf[1];
        value   = (s->setup_buf[3] setup_buf[2];
        index   = (s->setup_buf[5] setup_buf[4];
        if (s->setup_buf[0] & USB_DIR_IN) {
            usb_device_handle_control(s, p, request, value, index,
                                      s->setup_len, s->data_buf);
            if (p->status == USB_RET_ASYNC) {
                s->setup_state = SETUP_STATE_SETUP;
            }
            if (p->status != USB_RET_SUCCESS) {
                return;
            }
            if (p->actual_length setup_len) {
                s->setup_len = p->actual_length;
            }
            s->setup_state = SETUP_STATE_DATA;
        } else {
            if (s->setup_len == 0)
                s->setup_state = SETUP_STATE_ACK;
            else
                s->setup_state = SETUP_STATE_DATA;
        }
        p->actual_length = 8;
    }
之后这个`setup_len`还会被`do_token_in`和`do_token_out`使用，并且在这两个函数中会调用`usb_packet_copy`函数，从而实现越界读或越界写
## 漏洞调用链
现再为了调用到漏洞函数，我们需要了解一下漏洞调用链，这个调用链还是可以很容易的找到的，在最开始开启虚拟机的时候直接在漏洞函数下断点，运行就可以直接在漏洞函数断下来从而获得到漏洞调用链，调用链如下，但是在`ehci_advance_async_state`这个函数下了断点之后，在我们想恢复函数运行的时候还是会多次断在这个函数，调试及其不方便，所以我们选择另一条调用链，在源代码中可以找到还有一个函数会调用`ehci_advance_state`，并且这个函数也会被`ehci_work_bh`调用，所以我们就选择这个函数来替换调用链中的`ehci_advance_async_state`，新的调用链如下
    ---------------------------------------------------------------------------------------------------------------------------    OLD:
    #0  do_token_setup (s=0x555556d7c7d0, p=0x55555721dcd0) at hw/usb/core.c:131
    #1  0x0000555555b9d144 in usb_process_one (p=0x55555721dd10) at hw/usb/core.c:375
    #2  0x0000555555b9d357 in usb_handle_packet (dev=0x5555573ff0a0, p=0x55555721dd10) at hw/usb/core.c:420
    #3  0x0000555555bb5a89 in ehci_execute (p=0x55555721dcd0, action=0x555555f7b35a "process") at hw/usb/hcd-ehci.c:1378
    #4  0x0000555555bb6ea9 in ehci_state_execute (q=0x555556d7c7d0) at hw/usb/hcd-ehci.c:1936
    #5  0x0000555555bb73c1 in ehci_advance_state (ehci=0x5555573783c0, async=1) at hw/usb/hcd-ehci.c:2077
    #6  0x0000555555bb760a in ehci_advance_async_state (ehci=0x5555573783c0) at hw/usb/hcd-ehci.c:2148
    #7  0x0000555555bb7c20 in ehci_work_bh (opaque=0x5555573783c0) at hw/usb/hcd-ehci.c:2316
    #8  0x0000555555da5d2d in aio_bh_call (bh=0x5555573fea30) at util/async.c:90
    #9  0x0000555555da5dc9 in aio_bh_poll (ctx=0x5555566b6620) at util/async.c:118
    #10 0x0000555555daacd1 in aio_dispatch (ctx=0x5555566b6620) at util/aio-posix.c:460
    #11 0x0000555555da6182 in aio_ctx_dispatch (source=0x5555566b6620, callback=0x0, user_data=0x0) at util/async.c:261
    #12 0x00007ffff7d48fbd in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
    #13 0x0000555555da95a5 in glib_pollfds_poll () at util/main-loop.c:213
    #14 0x0000555555da9623 in os_host_main_loop_wait (timeout=0) at util/main-loop.c:236
    #15 0x0000555555da9734 in main_loop_wait (nonblocking=0) at util/main-loop.c:512
    #16 0x00005555559efe91 in main_loop () at vl.c:1970
    #17 0x00005555559f7268 in main (argc=18, argv=0x7fffffffdbb8, envp=0x7fffffffdc50) at vl.c:4604
    #18 0x00007ffff799d0b3 in __libc_start_main (main=0x5555559f38b0 , argc=18, argv=0x7fffffffdbb8, init=, fini=, rtld_fini=,8
    #19 0x00005555558007be in _start ()
    ---------------------------------------------------------------------------------------------------------------------------    NEW:
    #0  do_token_setup (s=0x5555566b7e20, p=0x555556b5c3a0) at hw/usb/core.c:131
    #1  0x0000555555b9d144 in usb_process_one (p=0x555556b5c3e0) at hw/usb/core.c:375
    #2  0x0000555555b9d357 in usb_handle_packet (dev=0x5555573ff060, p=0x555556b5c3e0) at hw/usb/core.c:420
    #3  0x0000555555bb5a89 in ehci_execute (p=0x555556b5c3a0, action=0x555555f7b35a "process") at hw/usb/hcd-ehci.c:1378
    #4  0x0000555555bb6ea9 in ehci_state_execute (q=0x5555566b7e20) at hw/usb/hcd-ehci.c:1936
    #5  0x0000555555bb73c1 in ehci_advance_state (ehci=0x5555573783c0, async=0) at hw/usb/hcd-ehci.c:2077
    #6  0x0000555555bb781a in ehci_advance_periodic_state (ehci=0x5555573783c0) at hw/usb/hcd-ehci.c:2209
    #7  0x0000555555bb7b25 in ehci_work_bh (opaque=0x5555573783c0) at hw/usb/hcd-ehci.c:2295
    #8  0x0000555555da5d2d in aio_bh_call (bh=0x5555573fea10) at util/async.c:90
    #9  0x0000555555da5dc9 in aio_bh_poll (ctx=0x5555566b6620) at util/async.c:118
    #10 0x0000555555daacd1 in aio_dispatch (ctx=0x5555566b6620) at util/aio-posix.c:460
    #11 0x0000555555da6182 in aio_ctx_dispatch (source=0x5555566b6620, callback=0x0, user_data=0x0) at util/async.c:261
    #12 0x00007ffff7d48fbd in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
    #13 0x0000555555da95a5 in glib_pollfds_poll () at util/main-loop.c:213
    #14 0x0000555555da9623 in os_host_main_loop_wait (timeout=0) at util/main-loop.c:236
    #15 0x0000555555da9734 in main_loop_wait (nonblocking=0) at util/main-loop.c:512
    #16 0x00005555559efe91 in main_loop () at vl.c:1970
    #17 0x00005555559f7268 in main (argc=18, argv=0x7fffffffdbb8, envp=0x7fffffffdc50) at vl.c:4604
    #18 0x00007ffff799d0b3 in __libc_start_main (main=0x5555559f38b0 , argc=18, argv=0x7fffffffdbb8, init=, fini=, rtld_fini=,8
    #19 0x00005555558007be in _start ()
    ---------------------------------------------------------------------------------------------------------------------------    
## 漏洞涉及到的数据结构
**USBDevice**
    struct USBDevice {
        DeviceState qdev;
        USBPort *port;
        char *port_path;
        char *serial;
        void *opaque;
        uint32_t flags;
        /* Actual connected speed */
        int speed;
        /* Supported speeds, not in info because it may be variable (hostdevs) */
        int speedmask;
        uint8_t addr;
        char product_desc[32];
        int auto_attach;
        bool attached;
        int32_t state;
        uint8_t setup_buf[8];
        uint8_t data_buf[4096];
        int32_t remote_wakeup;
        int32_t setup_state;
        int32_t setup_len;
        int32_t setup_index;
        USBEndpoint ep_ctl;
        USBEndpoint ep_in[USB_MAX_ENDPOINTS];
        USBEndpoint ep_out[USB_MAX_ENDPOINTS];
        QLIST_HEAD(, USBDescString) strings;
        const USBDesc *usb_desc; /* Overrides class usb_desc if not NULL */
        const USBDescDevice *device;
        int configuration;
        int ninterfaces;
        int altsetting[USB_MAX_INTERFACES];
        const USBDescConfig *config;
        const USBDescIface  *ifaces[USB_MAX_INTERFACES];
    };
**EHCIState**
    struct EHCIState {
        USBBus bus;
        DeviceState *device;
        qemu_irq irq;
        MemoryRegion mem;
        AddressSpace *as;
        MemoryRegion mem_caps;
        MemoryRegion mem_opreg;
        MemoryRegion mem_ports;
        int companion_count;
        bool companion_enable;
        uint16_t capsbase;
        uint16_t opregbase;
        uint16_t portscbase;
        uint16_t portnr;
        /* properties */
        uint32_t maxframes;
        /*
         *  EHCI spec version 1.0 Section 2.3
         *  Host Controller Operational Registers
         */
        uint8_t caps[CAPA_SIZE];