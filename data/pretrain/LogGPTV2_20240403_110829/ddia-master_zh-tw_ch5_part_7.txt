要正确排序这些事件，可以使用一种称为 **版本向量（version vectors）** 的技术，本章稍后将讨论这种技术（请参阅 “[检测并发写入](#检测并发写入)”）。然而，许多多主复制系统中的冲突检测技术实现得并不好。例如，在撰写本文时，PostgreSQL BDR 不提供写入的因果排序【27】，而 Tungsten Replicator for MySQL 甚至都不做检测冲突【34】。
如果你正在使用基于多主复制的系统，那么你应该多了解这些问题，仔细阅读文件，并彻底测试你的资料库，以确保它确实提供了你想要的保证。
## 无主复制
我们在本章到目前为止所讨论的复制方法 —— 单主复制、多主复制 —— 都是这样的想法：客户端向一个主库传送写请求，而资料库系统负责将写入复制到其他副本。主库决定写入的顺序，而从库按相同顺序应用主库的写入。
一些资料储存系统采用不同的方法，放弃主库的概念，并允许任何副本直接接受来自客户端的写入。最早的一些的复制资料系统是 **无主的（leaderless）**【1,44】，但是在关系资料库主导的时代，这个想法几乎已被忘却。在亚马逊将其用于其内部的 Dynamo 系统 [^vi] 之后，它再一次成为资料库的一种时尚架构【37】。Riak，Cassandra 和 Voldemort 是受 Dynamo 启发的无主复制模型的开源资料储存，所以这类资料库也被称为 *Dynamo 风格*。
[^vi]: Dynamo 不适用于 Amazon 以外的使用者。令人困惑的是，AWS 提供了一个名为 DynamoDB 的托管资料库产品，它使用了完全不同的体系结构：它基于单主复制。
在一些无主复制的实现中，客户端直接将写入传送到几个副本中，而另一些情况下，由一个 **协调者（coordinator）** 节点代表客户端进行写入。但与主库资料库不同，协调者不执行特定的写入顺序。我们将会看到，这种设计上的差异对资料库的使用方式有著深远的影响。
### 当节点故障时写入资料库
假设你有一个带有三个副本的资料库，而其中一个副本目前不可用，或许正在重新启动以安装系统更新。在基于领导者的配置中，如果要继续处理写入，则可能需要执行故障切换（请参阅“[处理节点宕机](#处理节点宕机)”）。
另一方面，在无主配置中，不存在故障转移。[图 5-10](../img/fig5-10.png) 演示了会发生了什么事情：客户端（使用者 1234）并行传送写入到所有三个副本，并且两个可用副本接受写入，但是不可用副本错过了它。假设三个副本中的两个承认写入是足够的：在使用者 1234 已经收到两个确定的响应之后，我们认为写入成功。客户简单地忽略了其中一个副本错过了写入的事实。
![](../img/fig5-10.png)
**图 5-10 法定写入，法定读取，并在节点中断后读修复。**
现在想象一下，不可用的节点重新联机，客户端开始读取它。节点关闭期间发生的任何写入都不在该节点上。因此，如果你从该节点读取资料，则可能会从响应中拿到陈旧的（过时的）值。
为了解决这个问题，当一个客户端从资料库中读取资料时，它不仅仅把它的请求传送到一个副本：读请求将被并行地传送到多个节点。客户可能会从不同的节点获得不同的响应，即来自一个节点的最新值和来自另一个节点的陈旧值。版本号将被用于确定哪个值是更新的（请参阅 “[检测并发写入](#检测并发写入)”）。
#### 读修复和反熵
复制方案应确保最终将所有资料复制到每个副本。在一个不可用的节点重新联机之后，它如何赶上它错过的写入？
在 Dynamo 风格的资料储存中经常使用两种机制：
* 读修复（Read repair）
  当客户端并行读取多个节点时，它可以检测到任何陈旧的响应。例如，在 [图 5-10](../img/fig5-10.png) 中，使用者 2345 获得了来自副本 3 的版本 6 值和来自副本 1 和 2 的版本 7 值。客户端发现副本 3 具有陈旧值，并将新值写回到该副本。这种方法适用于读频繁的值。
* 反熵过程（Anti-entropy process）
  此外，一些资料储存具有后台程序，该程序不断查询副本之间的资料差异，并将任何缺少的资料从一个副本复制到另一个副本。与基于领导者的复制中的复制日志不同，此反熵过程不会以任何特定的顺序复制写入，并且在复制资料之前可能会有显著的延迟。
并不是所有的系统都实现了这两种机制，例如，Voldemort 目前没有反熵过程。请注意，如果没有反熵过程，很少被读取的值可能会从某些副本中丢失，从而降低了永续性，因为只有在应用程式读取值时才执行读修复。
#### 读写的法定人数
在 [图 5-10](../img/fig5-10.png) 的示例中，我们认为即使仅在三个副本中的两个上进行处理，写入仍然是成功的。如果三个副本中只有一个接受了写入，会怎样？以此类推，究竟多少个副本完成才可以认为写入成功？
如果我们知道，每个成功的写操作意味著在三个副本中至少有两个出现，这意味著至多有一个副本可能是陈旧的。因此，如果我们从至少两个副本读取，我们可以确定至少有一个是最新的。如果第三个副本停机或响应速度缓慢，则读取仍可以继续返回最新值。
更一般地说，如果有 n 个副本，每个写入必须由 w 个节点确认才能被认为是成功的，并且我们必须至少为每个读取查询 r 个节点。（在我们的例子中，$n = 3，w = 2，r = 2$）。只要 $w + r > n$，我们可以预期在读取时能获得最新的值，因为 r 个读取中至少有一个节点是最新的。遵循这些 r 值和 w 值的读写称为 **法定人数（quorum）**[^vii] 的读和写【44】。你可以认为，r 和 w 是有效读写所需的最低票数。
[^vii]: 有时候这种法定人数被称为严格的法定人数，其相对 “宽松的法定人数” 而言（见 “[宽松的法定人数与提示移交](#宽松的法定人数与提示移交)”）
在 Dynamo 风格的资料库中，引数 n、w 和 r 通常是可配置的。一个常见的选择是使 n 为奇数（通常为 3 或 5）并设定 $w = r = (n + 1) / 2$（向上取整）。但是你可以根据需要更改数字。例如，写入次数较少且读取次数较多的工作负载可以从设定 $w = n$ 和 $r = 1$中受益。这会使得读取速度更快，但缺点是只要有一个不可用的节点就会导致所有的资料库写入都失败。
> 丛集中可能有多于 n 个的节点（丛集的机器数可能多于副本数目）。但是任何给定的值只能储存在 n 个节点上。这允许对资料集进行分割槽，从而可以支援比单个节点的储存能力更大的资料集。我们将在 [第六章](ch6.md) 继续讨论分割槽。
法定人数条件 $w + r > n$ 允许系统容忍不可用的节点，如下所示：
* 如果 $w  n$，读取 r 个副本，至少有一个副本必然包含了最近的成功写入。**
如果可用的节点少于所需的 w 或 r，则写入或读取将返回错误。节点可能由于多种原因而不可用，比如：节点关闭（异常崩溃，电源关闭）、操作执行过程中的错误（由于磁碟已满而无法写入）、客户端和伺服器节点之间的网路中断或任何其他原因。我们只需要关心节点是否返回了成功的响应，而不需要区分不同型别的错误。
### 法定人数一致性的局限性