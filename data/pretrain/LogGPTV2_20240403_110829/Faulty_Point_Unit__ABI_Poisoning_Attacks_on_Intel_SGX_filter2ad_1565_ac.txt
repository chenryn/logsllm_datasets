more, is still relevant for calculations that require the high precision
of long double variables or for legacy applications.
3 POISONING FPU STATE REGISTERS
This section first elaborates on the assumed attacker capabilities and
system model. Thereafter, we analyze the different attack avenues
that may arise in case of insufficient ABI-level sanitization, and we
provide a toy example that illustrates their impact on the integrity
of exemplary enclave computations. Finally, we conclude with a
systematic vulnerability assessment of this attack surface across 7
widely used SGX shielding runtimes.
3.1 Attacker and system model
We assume the standard Intel SGX threat model [10] where only
the processor and the software executing inside the enclave are
to be trusted. Notably, while Intel SGX explicitly excludes the OS
from the trusted computing base and aims to protect even against
adversaries who have gained root access to the target platform [44],
we demonstrate our exploits with a considerably weaker attacker
model. Particularly, we only assume user-space code execution in
the untrusted host application so as to invoke the enclave with
custom ABI-level register settings and to optionally install signal
handlers via the OS interface. This falls within the capabilities of
any unprivileged user who has access to the enclave binary.
Following widespread industry practice [2, 4, 13, 15, 19, 30, 35,
39], we assume the use of a shielding runtime that intervenes on
enclave entry and exit to transparently protect the enclaved ap-
plication binary from its untrusted environment. Specifically, we
consider the explicit security objective of the shielding runtime to
be to (i) make sure that an enclaved application behaves exactly
like on a trusted OS, and (ii) prevent any avoidable information
leakage beyond what is allowed through explicit interaction with
the application. As an example of the first requirement, previous
research has shown that the shielding runtime should clear the
direction flag in the x86 status register on enclave entry to avoid
unexpected memory corruption for string operations [43]. As an
example of the second requirement, runtimes should scrub low-
level CPU registers that do not form part of the calling convention
before exiting the enclave to avoid leaking intermediary state [43].
We assume that the Intel SGX TEE is properly patched against
microarchitectural vulnerabilities [6, 41, 42], such that the shielding
system can provide enclaved computation results to remote parties
as if they were executed on a trusted OS. In this respect, we con-
sider it to be the objective of the shielding runtime to transparently
protect any ABI-compliant x86 application binary. The latter can
include legacy libraries and can be generated by an arbitrary com-
piler, as long as ABI-level calling conventions [12] are respected,
that can hence make use of the full power of the x86 instruction
set permitted inside SGX enclaves. In some of our case studies,
only when explicitly mentioned, we may emphasize this point by
instrumenting the compiler to make increased use of the x87 FPU in-
stead of more modern SSE features by means of the -mfpmath=387
5
gcc compiler flag. It should be stressed, however, that the result-
ing application binaries remain fully legit ABI-compliant x86 code
that may for instance also have been generated by older or more
specialized compilers [14].
3.2 ABI poisoning attacks
While trusted code can be relied on to respect ABI calling con-
ventions [12, 26], this does not hold anymore for ecall functions
exposed to the untrusted world. The shielding runtime hence has
the crucial responsibility to bridge this trust semantics gap by sani-
tizing the ABI on enclave entry. Before showing in Section 3.3 that
this requirement is not sufficiently understood in today‚Äôs widely
used SGX shielding runtimes, we first elaborate below on what are
the exact security implications of insufficient initialization of x87
and SSE registers, respectively.
Poisoning x87 FPU state. When the shielding system does not
cleanse the x87 control word, attackers may execute the unprivi-
leged fldcw instruction before entering the enclave to control all
bits described in Section 2.2 and Figure 2. In fact, executing this
instruction at any point before entering the enclave suffices to suc-
cessfully implement the attack as long as the x87 control word
does not get modified in-between. Since programs rarely modify
the x87 control word as long as they are not performing floating
point operations, the attack may often be performed in advance
instead of right before the actual ecall. In the following, we assume
however that the attacker loads the desired x87 control word as the
last instruction before switching into the enclave which ensures
that the x87 control register is in the desired state. The immediately
obvious impactful fields the attacker can target are bits 8-9 to de-
grade the precision and bits 10-11 to alter the rounding mode for
enclaved x87 floating-point operations. We will show in Sections 5
and 6 that the impact of a maliciously downgraded x87 precision
can be especially devastating in larger applications. Additionally,
by selectively unmasking floating-point exceptions and registering
a signal handler, attackers may be informed of certain, possibly
secret-dependent, FPU events that would otherwise pass unnoticed.
Furthermore, when the shielding runtime does not explicitly
initialize the x87 register stack, it may be incorrectly left in MMX
mode. For this, it suffices that the attacker executes any MMX oper-
ation that is not followed by an emms instruction before entering the
enclave. Since an ABI-compliant enclave application expects the
CPU to be in x87 mode with all registers available, any following
attempt to load data into an x87 register will cause an unexpected
FPU register stack overflow event, as the CPU still is incorrectly in
MMX mode with all eight floating-point registers marked as in-use.
The exact behavior in this case will depend on the corresponding
exception mask bit in the FPU control word. In the default case
where exceptions are masked, the processor will silently replace
the intended x87 destination register with an indefinite value (NaN)
and continue execution. We experimentally confirmed that such
attacker-injected unintended NaN values are silently propagated
further, which is a clear violation of computational integrity and
may further cause unexpected or incorrect behavior depending on
the victim application.
Alternatively, in the case where exception bits in the x87 control
word are craftily unmasked before enclave entry, the attacker will
ACSAC 2020, December 7‚Äì11, 2020, Austin, USA
Alder et al.
be notified by means of an FPU exception signal whenever the
enclave loads an x87 register. This technique is somewhat similar to
prior controlled-channel attacks on Intel SGX, which have abused
memory contention through page-fault exceptions [48] to spy on
enclave-private page accesses. Essentially, by adversely filling the
FPU register stack with MMX instructions before enclave entry,
the attacker causes unexpected contention that can be used as side
channel to learn subsequent use of the FPU by the enclave. We
experimentally verified that this technique can be abused as an
innovative controlled channel to deterministically recognize x87
instructions in a secret-dependent code path. We note that privi-
leged attackers could further improve the temporal resolution of
this novel FPU controlled channel by relying on the SGX-Step [44]
enclave execution control framework to exactly pinpoint on which
instruction the exception has been raised. SGX-Step leverages care-
fully scheduled timer device interrupts and has been shown to de-
terministically advance production enclaves exactly one instruction
at a time [32, 44]. FPU poisoning adversaries can, hence, precisely
establish the relative instruction offset of enclaved x87 operations
by merely counting the number of SGX-Step interrupts before de-
tecting the FPU exception signal.
We finally note that the above x87 FPU poisoning attacks can
even impact programs that were never explicitly compiled as x87
FPU programs. Section 2.3 indeed explained that some compilers,
including gcc, still utilize the x87 FPU in certain scenarios such as
for long double data types.
Poisoning SSE state. Compared to the x87 FPU, the more recent
SSE floating-point extensions include less configuration bits and
hence also expose a smaller ABI-level attack surface. However, we
found that when the shielding system does not sanitize the control
bits in the MXCSR register, attackers may execute the unprivileged
ldmxcsr instruction before entering the enclave to control all bits
described in Section 2.3 and Figure 3. Similar to the FPU attacks
described above, this allows the attacker to maliciously alter the
in-enclave rounding mode through bits 13-14 and to arbitrarily
unmask floating-point exceptions through bits 7-12. Unlike the x87
FPU, the precision of SSE floating-point operations is fixed and can
hence not be overridden by the attacker.
We demonstrate below that poisoning the SSE rounding mode
may adversely impact the integrity (i.e., the expected outcome) of
certain in-enclave floating-point computations. Section 4 further-
more introduces a case study which exploits the adversary‚Äôs control
over the denormal-operand SSE exception mask as an innovative
controlled channel to reconstruct secret in-enclave multiplication
operands.
A toy example. We exemplify the threat of ABI-level poisoning
attacks on the integrity of enclaved floating-point computations by
means of two types of math operations: one complex operation that
relies on the standard math library included in the Intel SGX-SDK,
and one example of a simple multiplication of two floating-point
numbers. The complex example is an approximation of the number
œÄ by calculating arccos(-1) with the acosl function provided by
math.h and the second example is a calculation of 2.1‚àó3.4. To
achieve a maximum precision, the code utilizes variables of the
long double type, which the compiler translates to predominantly
x87 FPU instructions. For completeness, both the minimal C code
6
Table 1: Proof-of-concept attack executed inside an enclave.
and the resulting assembly instructions can be viewed in Section A.
The enclave was compiled with a recent gcc v7.4.0 with standard
compilation flags under Ubuntu 18.04.1 and with the Intel SGX-SDK
v2.7.1. All evaluations were performed on an Intel i5-1035G1.
Table 1 shows the attack in practice by listing the results of an
executed enclave with attacker-primed FPU registers before the
ecall into the enclave. For all depicted values, the FPU CW and the
MXCSR were set to the desired value via the fldcw and the ldmxcsr
instruction respectively right before the enclave was entered. Illus-
trated are four FPU groups of possible attack modes available to an
ABI poisoning adversary, with the expected (unpoisoned) default
mode highlighted. In the first three FPU groups, the attacker sets the
x87 FPU control word to operate in either single-precision, double-
precision, or extended-precision mode. These precision modes are
then combined with each of the four available rounding modes set
in both the FPU control word and the MXCSR register to affect the
operation of the x87 FPU as well as SSE instructions. The last FPU
group targets the MMX mode by marking all x87 registers as in-use,
as described above, which always yields NaN independent of the
rounding mode. For readability, all computation results are listed
with a precision of 10‚àí30 and cut off after the last digit.
As a first interesting observation, the results of the calculation
of œÄ listed in the middle column remain unaffected by the choice
of the x87 precision mode. Up to the order of 10‚àí19, the calculated
approximation is identical with the actual value of œÄ across all
possible x87 precision modes. Only the rounding mode can degrade
the precision of this single math library calculation in the order of
10‚àí19. Specifically, the rounding modes to nearest and upward both
achieve the baseline precision while the rounding modes down-
ward and towards zero have a degraded performance. This example
shows that even when relying on standard math libraries, the at-
tacker can partly degrade the quality of calculations. At the same
time, it is evident that although the compiler relied on the x87 FPU
to satisfy the precision requirements of the long double data type,
the results remain unaffected by the modified precision mode. The
reason for this is the fact that the acosl library function is inter-
nally implemented using SSE instructions, and hence the actual
computation is not performed by the x87 FPU in this case. Listing 3
in Section A shows that the compiler-generated code transfers the
x87 data into the SSE registers and similarly retrieves the data after
ACSAC2020,December7‚Äì11,2020,Austin,USAAlderetal.benotifiedbymeansofanFPUexceptionsignalwhenevertheenclaveloadsanx87register.Thistechniqueissomewhatsimilartopriorcontrolled-channelattacksonIntelSGX,whichhaveabusedmemorycontentionthroughpage-faultexceptions[48]tospyonenclave-privatepageaccesses.Essentially,byadverselyfillingtheFPUregisterstackwithMMXinstructionsbeforeenclaveentry,theattackercausesunexpectedcontentionthatcanbeusedassidechanneltolearnsubsequentuseoftheFPUbytheenclave.Weexperimentallyverifiedthatthistechniquecanbeabusedasaninnovativecontrolledchanneltodeterministicallyrecognizex87instructionsinasecret-dependentcodepath.Wenotethatprivi-legedattackerscouldfurtherimprovethetemporalresolutionofthisnovelFPUcontrolledchannelbyrelyingontheSGX-Step[44]enclaveexecutioncontrolframeworktoexactlypinpointonwhichinstructiontheexceptionhasbeenraised.SGX-Stepleveragescare-fullyscheduledtimerdeviceinterruptsandhasbeenshowntode-terministicallyadvanceproductionenclavesexactlyoneinstructionatatime[32,44].FPUpoisoningadversariescan,hence,preciselyestablishtherelativeinstructionoffsetofenclavedx87operationsbymerelycountingthenumberofSGX-Stepinterruptsbeforede-tectingtheFPUexceptionsignal.Wefinallynotethattheabovex87FPUpoisoningattackscanevenimpactprogramsthatwereneverexplicitlycompiledasx87FPUprograms.Section2.3indeedexplainedthatsomecompilers,includinggcc,stillutilizethex87FPUincertainscenariossuchasforlongdoubledatatypes.PoisoningSSEstate.Comparedtothex87FPU,themorere-centSSEfloating-pointextensionsincludelessconfigurationbitsandhencealsoexposeasmallerABI-levelattacksurface.How-ever,wefoundthatwhentheshieldingsystemdoesnotsanitizethecontrolbitsintheMXCSRregister,attackersmayexecutetheunprivilegedldmxcsrinstructionbeforeenteringtheenclavetocontrolallbitsdescribedinSection2.3andFig.3.SimilartotheFPUattacksdescribedabove,thisallowstheattackertomaliciouslyalterthein-enclaveroundingmodethroughbits13-14andtoarbitrarilyunmaskfloating-pointexceptionsthroughbits7-12.Unlikethex87FPU,theprecisionofSSEfloating-pointoperationsisfixedandcanhencenotbeoverriddenbytheattacker.WedemonstratebelowthatpoisoningtheSSEroundingmodemayadverselyimpacttheintegrity(i.e.,theexpectedoutcome)ofcertainin-enclavefloating-pointcomputations.Section4further-moreintroducesacasestudywhichexploitstheadversary‚Äôscontroloverthedenormal-operandSSEexceptionmaskasaninnovativecontrolledchanneltoreconstructsecretin-enclavemultiplicationoperands.Atoyexample.WeexemplifythethreatofABI-levelpoisoningattacksontheintegrityofenclavedfloating-pointcomputationsbymeansoftwotypesofmathoperations:onecomplexoperationthatreliesonthestandardmathlibraryincludedintheIntelSGX-SDK,andoneexampleofasimplemultiplicationoftwofloating-pointnumbers.Thecomplexexampleisanapproximationofthenumberùúãbycalculatingarccos(-1)withtheacoslfunctionprovidedbymath.handthesecondexampleisacalculationof2.1‚àó3.4.Toachieveamaximumprecision,thecodeutilizesvariablesofthelongdoubletype,whichthecompilertranslatestopredominantlyx87FPUinstructions.Forcompleteness,boththeminimalCcodeandTable1:Proof-of-conceptattackexecutedinsideanenclave.FPURoundingarccos(-1)=ùúã2.1‚àó3.4=7.14SingleprecisionTonearest3.14159265358979323851280897.1399998664855957031250000Downward3.14159265358979323829596857.1399998664855957031250000Upward3.14159265358979323851280897.1400003433227539062500000Tozero3.14159265358979323829596857.1399998664855957031250000DoubleprecisionTonearest3.14159265358979323851280897.1399999999999996802557689Downward3.14159265358979323829596857.1399999999999996802557689Upward3.14159265358979323851280897.1400000000000005684341886Tozero3.14159265358979323829596857.1399999999999996802557689ExtendedprecisionTonearest3.14159265358979323851280897.1400000000000001156713613Downward3.14159265358979323829596857.1400000000000001152376805Upward3.14159265358979323851280897.1400000000000001156713613Tozero3.14159265358979323829596857.1400000000000001152376805MMXAny-NaN-NaNtheresultingassemblyinstructionscanbeviewedinAppendixA.Theenclavewascompiledwitharecentgccv7.4.0withstandardcompilationflagsunderUbuntu18.04.1andwiththeIntelSGX-SDKv2.7.1.AllevaluationswereperformedonanInteli5-1035G1.Table1showstheattackinpracticebylistingtheresultsofanexecutedenclavewithattacker-primedFPUregistersbeforetheecallintotheenclave.Foralldepictedvalues,theFPUCWandtheMXCSRweresettothedesiredvalueviathefldcwandtheldmxcsrinstructionrespectivelyrightbeforetheenclavewasentered.Illus-tratedarefourFPUgroupsofpossibleattackmodesavailabletoanABIpoisoningadversary,withtheexpected(unpoisoned)defaultmodehighlighted.InthefirstthreeFPUgroups,theattackersetsthex87FPUcontrolwordtooperateineithersingle-precision,double-precision,orextended-precisionmode.TheseprecisionmodesarethencombinedwitheachofthefouravailableroundingmodessetinboththeFPUcontrolwordandtheMXCSRregistertoaffecttheoperationofthex87FPUaswellasSSEinstructions.ThelastFPUgrouptargetstheMMXmodebymarkingallx87registersasin-use,asdescribedabove,whichalwaysyieldsNaNindependentoftheroundingmode.Forreadability,allcomputationresultsarelistedwithaprecisionof10‚àí30andcutoffafterthelastdigit.Asafirstinterestingobservation,theresultsofthecalculationofùúãlistedinthemiddlecolumnremainunaffectedbythechoiceofthex87precisionmode.Uptotheorderof10‚àí19,thecalculatedapproximationisidenticalwiththeactualvalueofùúãacrossallpossiblex87precisionmodes.Onlytheroundingmodecandegradetheprecisionofthissinglemathlibrarycalculationintheorderof10‚àí19.Specifically,theroundingmodestonearestandupwardbothachievethebaselineprecisionwhiletheroundingmodesdown-wardandtowardszerohaveadegradedperformance.Thisexampleshowsthatevenwhenrelyingonstandardmathlibraries,theat-tackercanpartlydegradethequalityofcalculations.Atthesametime,itisevidentthatalthoughthecompilerreliedonthex87FPUtosatisfytheprecisionrequirementsofthelongdoubledatatype,theresultsremainunaffectedbythemodifiedprecisionmode.Thereasonforthisisthefactthattheacosllibraryfunctionisinter-nallyimplementedusingSSEinstructions,andhencetheactualcomputationisnotperformedbythex87FPUinthiscase.Listing3inAppendixAshowsthatthecompiler-generatedcodetransfersthex87dataintotheSSEregistersandsimilarlyretrievesthedata6Faulty Point Unit: ABI Poisoning Attacks on Intel SGX
ACSAC 2020, December 7‚Äì11, 2020, Austin, USA
acosl has returned. In summary, the attack surface is somewhat
limited whenever the victim code utilizes library functions that are
not compiled to x87 instructions.
The capabilities of an attacker that targets victim code which
solely relies on x87 calculations, however, can be seen in the right