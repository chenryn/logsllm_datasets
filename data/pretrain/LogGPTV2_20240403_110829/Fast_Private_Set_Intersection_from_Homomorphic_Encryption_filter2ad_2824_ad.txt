### 优化后的文本

#### 表3：协议运行时间（秒），线程数 T ∈ {1, 4, 16, 64}；参数 λ = 40, σ = 32, h = 3。

| 线程数 | 接收方 (s) | 发送方预处理 (s) | 发送方在线处理 (s) |
|--------|------------|-----------------|--------------------|
| 1      | 72.2       | 9.1             | 3.6                |
| 4      | 70.9       | 6.9             | 6.3                |
| 16     | 76.8       | 6.4             | 12.7               |
| 64     | 64.1       | 5.1             | 3.2                |

由于我们通过将 α 分区均匀分配给线程来实现多线程，当 T > α 时，性能不会进一步提升。这些情况在表中用“—”表示。

#### 发送方预处理
表3中的“发送方预处理”列衡量了发送方计算多项式 \( r \prod_{x \in X} (y - x) \) 的系数的计算成本。具体来说，发送方的预处理工作包括其数据的哈希和批处理、计算公式 (3) 右侧的系数以及随机向量的采样。此外，发送方还对其明文多项式进行数论变换 (NTT)，以促进第4.3节描述的同态乘法操作。

我们注意到，预处理可以在离线状态下完全由发送方完成，无需接收方参与。具体而言，给定接收方集合大小的上限，发送方可以本地选择参数并执行预处理。在得知接收方的实际集合大小后，发送方选择的参数将被传达给接收方。为了实现基于模拟的安全性，所选的哈希函数只能使用一次。因此，每个协议实例必须有一个独立的预处理阶段。如果在多个实例之间使用单个预处理阶段，则控制某一方集合的对手可能会迫使哈希失败。然而，如果不考虑此类对手，预处理阶段可以重用，从而显著提高性能。

#### 支持更长项目的PSI
在实现我们的PSI协议时，我们将项目长度限制为32位。虽然原则上我们可以支持任意大小的项目（如第4.2节所述），但这样做会需要大幅增加加密参数，从而对性能产生负面影响。我们将使协议对任意大小项目高效的任务留给未来的工作。

#### 与Pinkas等人[PSZ16]的比较
我们的主要比较对象是Pinkas等人的PSI协议[PSZ16]，该协议既考虑了对称集合大小的情况，也考虑了接收方集合远小于发送方集合的情况。尽管我们的协议可以轻松处理对称集合大小，但在不对称设置下，我们的主要优势在于此。为了便于比较这两种协议，我们在同一台机器上运行它们，并在表5中总结了总运行时间。我们选择了以下参数：

| 参数        | 值          |
|-------------|--------------|
| Nx          | 224, 220, 216, 11041 |
| Ny          | SEAL16384-2, SEAL16384-1, 5535 SEAL8192-1, 11041 SEAL16384-1, 5535 SEAL8192-2, 11041 SEAL16384-3, 5535 SEAL8192-2 |
| FHE参数     | α (cid:96)    |
| 通信大小 (MB) | S → R, R → S |
| 通信时间 (秒) | 10 Gbps, 100 Mbps, 10 Mbps, 1 Mbps |

### 总结
通过对以上内容的优化，文本更加清晰、连贯和专业，有助于读者更好地理解协议的运行时间和性能特点。