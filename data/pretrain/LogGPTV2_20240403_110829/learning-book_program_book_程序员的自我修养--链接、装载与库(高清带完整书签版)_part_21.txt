的链接过程，我们将在“库”这一章再来详细讲述。符号跟链接器的COMMON块概念
联系很紧密，我们在后面“深入静态链接”这一章中的“COMMON块”一节还会国顾弱符
号的概念。
个外部函数的引用为弱引用，比如下面这段代码：
_attribute_((weakref))  void foo (1 ;
int nain[)
foo (} ;
我们可以将它编译成一个可执行文件，GCC并不会报链接错误。但是当我们运行这个
可执行文件时，会发生运行错误。因为当main函数试图调用foo函数时，foo函数的地址为
0，于是发生了非法地址访问的错误。-个改进的例子是：
_attribute__ ( (weakref)1 void foo() ;
int main()
if (foo) foo () ;
这种弱符号和弱引用对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强
符号所覆盖，从而使得程序可以使用自定义版本的库函数：或者程序可以对某些扩展功能模
块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时，功能模块就可以正常使用；
如果我们去掉了某些功能模块，那么程序也可以正常链接，只是缺少了相应的功能，这使得
程序的功能更加容易裁剪和组合。
在Linux程序的设计中，如果一个程序被设计成可以支持单线程或多线程的模式，就可
以通过弱引用的方法来判断当前的程序是链接到了单线程的Glibc库还是多线程的Glibc库
（是否在编译时有-lpthread选项），从而执行单线程版本的程序或多线程版本的程序。我们
可以在程序中定义--个pthread_create函数的弱引用，然后程序在运行时动态判断是否链接
到pthread库从而决定执行多线程版本还是单线程版本；
#include 
#1nc1ude 
程序员的自我修养一链接、装载与库
---
## Page 117
94
第3章目标文件里有什么
int pthread_create(
pthread_t*,
'(PTOA) (+)•PTOA
((weak)) ;
int main()
if(pthread_create) (
printf (*This i8 multi-thread version:\n*);
// run the multi-thread version
/ / nain_multi_thread()
}else {
printf (*rhis i8 single-thread vereion!\n*1:
// run the single-thread version
/ / main_single_thread()
编译运行结果如下：
$ gcc pthread.c -o pt
This is single-thread version!
$./pt
$gcc pthread.c -1pthread -o pt
This i8 multi-thread version!
$./pt
3.6
调试信息
目标文件里面还有可能保存的是调试信息。几乎所有现代的编译器都支持源代码级别的
调试，比如我们可以在函数里面设置断点，可以监视变量变化，可以单步行进等，前提是编
译器必须提前将源代码与目标代码之间的关系等，比如目标代码中的地址对应源代码中的哪
一行、函数和变量的类型、结构体的定义、字符串保存到目标文件里面，甚至有些高级的编
译器和调试器支持查看STL容器的内容，即程序员在调试过程中可以直接观察STL容器中
的成员的值。
信息，我们通过readelf等工具可以看到，目标文件里多了很多“debug”相关的段：
[Nr]  Name
Type
Addr
off
Size &S Flg Lk Inf A1
[4]
.debug_abbrev
PROGBITS
000000000000740000af00
00000000000040000034000
PROGBITS
0
[ 5]
.debug_info
i.
.rel.debug_info
00000000 000738000038 08
1
[ 7]
[9]
REL
PROGBITS
00000000
000123 000037 00
9
5
.debug_line
0
0
4
[ 8]
.rel.debug_line
REL
00000000
000770 000008 08
19
7
.debug_frame
PROGBITS
00000000
00015c 000034 00
0
0
4
[10]
[6]
.rel.debug_frame
REL
00000000
000778 000010 08
19
6
4
[11] .debug_loc
PROGBITS
00000000 00019000002c 000
1
4
程序员的自我修养一—链接、装载与库
---
## Page 118
3.7本章小结
95
[12]  .debug_pubnames PROCBITS(
000000000001bc00001a00001
[13]
re1 debug_pubnan REL
.debug_aranges
000000000007880000080819124
[15] ,rel.debug_arange REL
[14 ]
PROGBITS
00000000 0001d6 000020 00
00000000 000790000010 081914 4
D
01
 +1
这些段中保存的就是调试信息。现在的 ELF 文件采用一个叫DWARF（Debug With
Arbitrary Record Format）的标准的调试信息格式，现在该标准已经发展到了第三个版本，
即 DWARF 3，由DWARF 标准委员会由 2006年颁布。Microsoft 也有白己相应的调试信息
格式标准，叫CodeView，关于调试信息的其体内容我们在这里不再详细展开了，它将是另
外一个独立的并且很大的话题，对我们理解整个系统软件的意义不大，有兴趣的读者可以参
照相应的格式标准。但是值得一提的是，调试信息在目标文件和可执行文件中占用很大的空
间，往往比程序的代码和数据本身大好儿倍，所以当我们开发完程序并要将它发布的时候，
须要把这些对于用户没有用的调试信息去掉，以节省大量的空间。在Linux下，我们可以使
用“strip”命令来去掉ELF文件中的调试信息：
$atrip foo
3.7本章小结
在这一章中我们深入分析了各种目标文件格式，主要介绍了ELF文件的代码段、数据
段和BSS段等与程序运行密切相关的段结构。除此之外，我们还详细介绍了ELF文件的文
件头、段表、重定位表、字符串表、符号表、调试表等相关结构。
从这一章中我们了解到，无论是可执行文件、目标文件或库，它们实际上都是一样基于
段的文件或是这种文件的集合，程序的源代码经过编译以后，按照代码和数据分别存放到相
应的段中，编译器（汇编器）还会将一些辅助性的信息，诸如符号、重定位信息等也按照表
的方式存放到目标文件中，而通常情况下，一个表往往就是一个段。
有了这些目标文件之后，接下来的问题就是如何将它们组合起来，形成一个可以使用的
程序或一个更大的模块，这就是静态链接所要解决的问题，我们将在下一章中详细介绍。
程序员的自我修养一链接、装载与库
---
## Page 120
静态链接
4.1空间与地址分配
4.2符号解析与重定位
4.3COMMON块
4.4C++相关问题
4.5静态库链接
4.6链接过程控制
4.7BFD库
4.8本章小结
程序员的自我修养一链接、装载与库
---
## Page 121
86
第4章静态链接
通过前面对ELF文件格式的介绍，使我们对ELF目标文件从整体轮廊到某些局部的细
节都有了一定的了解。接下来的问题是：当我们有两个目标文件时，如何将它们链接起来形
成一个可执行文件？这个过程中发生了什么？这基本上就是链接的核心内容：静态链接。在
这一节里，我们将使用下面这两个源代码文件“ac”和“b.c”作为例子展开分析：
extern int shared;
/* a.c */
int shared = 1;
/* b.c */
int main()
void swap( int* a, int* b )
int a = 100;
*a ^=*b ^= *a ^=*b;
swap( &a, &shared );
，
分别编译成目标文件“ao”和“b.o”：
$ gcc -c a.c b.c
经过编译以后我们就得到了“a.o”和“b.o”这两个目标文件。从代码中可以看到，“b.c”
我们接下来要做的就是把“ao”和“b.o”这两个目标文件链接在一起并最终形成一个可执
行文件“ab”。
4.1空间与地址分配
对于链接器来说，整个链接过程中，它就是将儿个输入目标文件加工后合并成一个输出
文件。那么在这个例子里，我们的输入就是目标文件“ao”和“b.o”，输出就是可执行文件
“ab”。我们在前面详细分析了ELF文件的格式，我们知道，可执行文件中的代码段和数据
段都是由输入的目标文件中合并而来的，那么我们链接过程就很明显产生了第一个问题：对
于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？或者说，输出文件中的
空间如何分配给输入文件？
4.1.1按序叠加
一个最简单的方案就是将输入的目标文件按照次序叠加起来，如图4-1所示。
图4-1中的做法的确很简单，就是直接将各个目标文件依次合并。但是这样做会造成一
程序员的自我修养一一链接、装载与库
---
## Page 122
4.1空间与地址分配
66
Object Flle A
Output File
File Header
File Header
uogoes jxieg
Jeat secton
data section
data section
Object Flle A
Object File B
text section
Flle Header
data sectlon
Otject File B
text sectlon
data section
Jaxt sectlion
.bsssoction
data section
Object File C
Object Flile C
File Header
text section
图4-1简单的空间分配策路
个问题，在有很多输入文件的情况下，输出文件将会有很多零散的段。比如一个规模稍大的
应用程序可能会有数百个目标文件，如果每个目标文件都分别有.text段、data段和.bss段，
那最后的输出文件将会有成百上千个零散的段。这种做法非常浪费空间，因为每个段都须要
有一定的地址和空间对齐要求，比如对于x86的硬件来说，段的装载地址和空间的对齐单位
是页，也就是4096字节（关于地址和空间对齐，我们在后面还会有专门的章节详细介绍）。
那么就是说如果一个段的长度只有1个字节，它也要在内存中占用4096字节，这样会造成
内存空间大量的内部碎片，所以这并不是一个很好的方案。
4.1.2
相似段合并
到输出文件的“.text”段，接着是“.data”段、“.bss”段等，如图4-2所示。
程序员的自我修养一链接、装载与库