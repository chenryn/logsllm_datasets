# chrome exploitation解读：CVE-2020-16040漏洞分析与利用
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
本篇主要是对zer0con2021上chrome exploitation议题v8部分的解读。
这个漏洞发生在Simplified Lowering
phase的VisitSpeculativeIntegerAdditiveOp函数中，该函数是用来处理SpeculativeSafeIntegerAdd/SpeculativeSafeIntegerSubtract节点，对其重新计算类型并将其转化或者降级到更底层的IR。  
这个函数非常有趣，据我所知它已经出了三个可以RCE的漏洞了
## Simplified lowing phase和Root Cause
  * propagating truncations: 反向数据流分析，传播truncation，并设置restriction_type
  * retype: 正向数据流分析，重新计算类型，并设置representation。
  * lower: 降级(lower)节点或者插入转换(conversion)节点
###  重要的数据结构和函数
  * NodeInfo，记录数据流分析中节点的各种类型信息，主要包括truncation(指明该节点在使用的时候的截断信息)，restriction_type(在truncation传播阶段设置它的值，用于在retype的时候设置feedback_type)，feedback_type（用于在Retype phase重新计算type信息），representation（节点retype完成之后最终的表示类型，可以用于指明应该如何lower到更具体的节点，是否需要Convert）等。
      // Information for each node tracked during the fixpoint.
      class NodeInfo final {
       public:
        // Adds new use to the node. Returns true if something has changed
        // and the node has to be requeued.
        bool AddUse(UseInfo info) {
          Truncation old_truncation = truncation_;
          truncation_ = Truncation::Generalize(truncation_, info.truncation());
          return truncation_ != old_truncation;
        }
        void set_queued() { state_ = kQueued; }
        void set_visited() { state_ = kVisited; }
        void set_pushed() { state_ = kPushed; }
        void reset_state() { state_ = kUnvisited; }
        bool visited() const { return state_ == kVisited; }
        bool queued() const { return state_ == kQueued; }
        bool pushed() const { return state_ == kPushed; }
        bool unvisited() const { return state_ == kUnvisited; }
        Truncation truncation() const { return truncation_; }
        void set_output(MachineRepresentation output) { representation_ = output; }
        MachineRepresentation representation() const { return representation_; }
        // Helpers for feedback typing.
        void set_feedback_type(Type type) { feedback_type_ = type; }
        Type feedback_type() const { return feedback_type_; }
        void set_weakened() { weakened_ = true; }
        bool weakened() const { return weakened_; }
        void set_restriction_type(Type type) { restriction_type_ = type; }
        Type restriction_type() const { return restriction_type_; }
       private:
        enum State : uint8_t { kUnvisited, kPushed, kVisited, kQueued };
        State state_ = kUnvisited;
        MachineRepresentation representation_ =
            MachineRepresentation::kNone;             // Output representation.
        Truncation truncation_ = Truncation::None();  // Information about uses.
        Type restriction_type_ = Type::Any();
        Type feedback_type_;
        bool weakened_ = false;
      };
  * ProcessInput  
这是一个模板函数，根据不同的phase调用不同的实现，对于truncation propagate phase，它将直接调用EnqueueInput。
    template <>
    void RepresentationSelector::ProcessInput(Node* node, int index,
                                                         UseInfo use) {
      DCHECK_IMPLIES(use.type_check() != TypeCheckKind::kNone,
                     !node->op()->HasProperty(Operator::kNoDeopt) &&
                         node->op()->EffectInputCount() > 0);
      EnqueueInput(node, index, use);
    }
    template <>
    void RepresentationSelector::ProcessInput(Node* node, int index,
                                                      UseInfo use) {
      DCHECK_IMPLIES(use.type_check() != TypeCheckKind::kNone,
                     !node->op()->HasProperty(Operator::kNoDeopt) &&
                         node->op()->EffectInputCount() > 0);
    }
    template <>
    void RepresentationSelector::ProcessInput(Node* node, int index,
                                                     UseInfo use) {
      DCHECK_IMPLIES(use.type_check() != TypeCheckKind::kNone,
                     !node->op()->HasProperty(Operator::kNoDeopt) &&
                         node->op()->EffectInputCount() > 0);
      ConvertInput(node, index, use);
    }
    ...
     // Converts input {index} of {node} according to given UseInfo {use},
      // assuming the type of the input is {input_type}. If {input_type} is null,
      // it takes the input from the input node {TypeOf(node->InputAt(index))}.
      void ConvertInput(Node* node, int index, UseInfo use,
                        Type input_type = Type::Invalid()) {
        // In the change phase, insert a change before the use if necessary.
        if (use.representation() == MachineRepresentation::kNone)
          return;  // No input requirement on the use.
        Node* input = node->InputAt(index);
        DCHECK_NOT_NULL(input);
        NodeInfo* input_info = GetInfo(input);
        MachineRepresentation input_rep = input_info->representation();
        if (input_rep != use.representation() ||
            use.type_check() != TypeCheckKind::kNone) {
          // Output representation doesn't match usage.
          TRACE("  change: #%d:%s(@%d #%d:%s) ", node->id(), node->op()->mnemonic(),
                index, input->id(), input->op()->mnemonic());
          TRACE("from %s to %s:%s\n",
                MachineReprToString(input_info->representation()),
                MachineReprToString(use.representation()),
                use.truncation().description());
          if (input_type.IsInvalid()) {
            input_type = TypeOf(input);
          }
          Node* n = changer_->GetRepresentationFor(input, input_rep, input_type,
                                                   node, use);
          node->ReplaceInput(index, n);
        }
      }
  * EnqueueInput  
这个函数先从全局数组里取出node的指定index的输入节点对应的NodeInfo信息，然后调用AddUse来更新info的`truncation_`字段，从而将truncation反向传播。
        // Enqueue {use_node}'s {index} input if the {use_info} contains new information
    // for that input node.
    template <>
    void RepresentationSelector::EnqueueInput(Node* use_node, int index,
                                                       UseInfo use_info) {
    Node* node = use_node->InputAt(index);
    NodeInfo* info = GetInfo(node);
    #ifdef DEBUG
    // Check monotonicity of input requirements.
    node_input_use_infos_[use_node->id()].SetAndCheckInput(use_node, index,
                                                           use_info);
    #endif  // DEBUG
    if (info->unvisited()) {
      info->AddUse(use_info);
      TRACE("  initial #%i: %s\n", node->id(), info->truncation().description());
      return;
    }
    TRACE("   queue #%i?: %s\n", node->id(), info->truncation().description());
    if (info->AddUse(use_info)) {
      // New usage information for the node is available.
      if (!info->queued()) {
        DCHECK(info->visited());
        revisit_queue_.push(node);
        info->set_queued();
        TRACE("   added: %s\n", info->truncation().description());
      } else {
        TRACE(" inqueue: %s\n", info->truncation().description());
      }
    }
    }
      bool AddUse(UseInfo info) {
        Truncation old_truncation = truncation_;
        truncation_ = Truncation::Generalize(truncation_, info.truncation());
        return truncation_ != old_truncation;
      }
  * SetOutput  
这个函数也是模板函数，根据不同phase调用不同的偏特化实现
    * 对于truncation propagate phase，它将更新节点对应的nodeinfo的`restriction_type_`，并用于后续的retype phase上。
    * 对于retype phase，它将更新节点的representation表示。
    template <>
    void RepresentationSelector::SetOutput(
        Node* node, MachineRepresentation representation, Type restriction_type) {
      NodeInfo* const info = GetInfo(node);
      info->set_restriction_type(restriction_type);
    }
    template <>
    void RepresentationSelector::SetOutput(
        Node* node, MachineRepresentation representation, Type restriction_type) {
      NodeInfo* const info = GetInfo(node);
      DCHECK(restriction_type.Is(info->restriction_type()));
      info->set_output(representation);
    }
    template <>
    void RepresentationSelector::SetOutput(
        Node* node, MachineRepresentation representation, Type restriction_type) {
      NodeInfo* const info = GetInfo(node);
      DCHECK_EQ(info->representation(), representation);
      DCHECK(restriction_type.Is(info->restriction_type()));
      USE(info);
    }
###  PoC
  * Issue  
    // test/mjsunit/compiler/regress-1150649.js 
    function foo(a) {
        var y = 0x7fffffff;
        if (a == NaN) y = NaN;
        if (a) y = -1;
        const z = (y + 1)|0;
        return z op()->ValueInputCount());
        ProcessInput(node, 0, left_use);