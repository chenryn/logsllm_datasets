对这个想法，有一个巧妙的扩充套件被 C-Store 发现，并在商业资料仓库 Vertica 中被采用【61,62】：既然不同的查询受益于不同的排序顺序，为什么不以几种不同的方式来储存相同的资料呢？反正资料都需要做备份，以防单点故障时丢失资料。因此你可以用不同排序方式来储存冗余资料，以便在处理查询时，呼叫最适合查询模式的版本。
在一个列式储存中有多个排序顺序有点类似于在一个面向行的储存中有多个次级索引。但最大的区别在于面向行的储存将每一行储存在一个地方（在堆档案或聚集索引中），次级索引只包含指向匹配行的指标。在列式储存中，通常在其他地方没有任何指向资料的指标，只有包含值的列。
### 写入列式储存
这些最佳化在资料仓库中是有意义的，因为其负载主要由分析人员执行的大型只读查询组成。列式储存、压缩和排序都有助于更快地读取这些查询。然而，他们的缺点是写入更加困难。
使用 B 树的就地更新方法对于压缩的列是不可能的。如果你想在排序表的中间插入一行，你很可能不得不重写所有的列档案。由于行由列中的位置标识，因此插入必须对所有列进行一致地更新。
幸运的是，本章前面已经看到了一个很好的解决方案：LSM 树。所有的写操作首先进入一个记忆体中的储存，在这里它们被新增到一个已排序的结构中，并准备写入硬碟。记忆体中的储存是面向行还是列的并不重要。当已经积累了足够的写入资料时，它们将与硬碟上的列档案合并，并批次写入新档案。这基本上是 Vertica 所做的【62】。
查询操作需要检查硬碟上的列资料和记忆体中的最近写入，并将两者的结果合并起来。但是，查询最佳化器对使用者隐藏了这个细节。从分析师的角度来看，透过插入、更新或删除操作进行修改的资料会立即反映在后续的查询中。
### 聚合：资料立方体和物化检视
并非所有资料仓库都需要采用列式储存：传统的面向行的资料库和其他一些架构也被使用。然而，列式储存可以显著加快专门的分析查询，所以它正在迅速变得流行起来【51,63】。
资料仓库的另一个值得一提的方面是物化聚合（materialized aggregates）。如前所述，资料仓库查询通常涉及一个聚合函式，如 SQL 中的 COUNT、SUM、AVG、MIN 或 MAX。如果相同的聚合被许多不同的查询使用，那么每次都透过原始资料来处理可能太浪费了。为什么不将一些查询使用最频繁的计数或总和快取起来？
建立这种快取的一种方式是物化检视（Materialized View）。在关系资料模型中，它通常被定义为一个标准（虚拟）检视：一个类似于表的物件，其内容是一些查询的结果。不同的是，物化检视是查询结果的实际副本，会被写入硬碟，而虚拟检视只是编写查询的一个捷径。从虚拟检视读取时，SQL 引擎会将其展开到检视的底层查询中，然后再处理展开的查询。
当底层资料发生变化时，物化检视需要更新，因为它是资料的非规范化副本。资料库可以自动完成该操作，但是这样的更新使得写入成本更高，这就是在 OLTP 资料库中不经常使用物化检视的原因。在读取繁重的资料仓库中，它们可能更有意义（它们是否实际上改善了读取效能取决于使用场景）。
物化检视的常见特例称为资料立方体或 OLAP 立方【64】。它是按不同维度分组的聚合网格。[图 3-12](../img/fig3-12.png) 显示了一个例子。
![](../img/fig3-12.png)
**图 3-12 资料立方的两个维度，透过求和聚合**
想象一下，现在每个事实都只有两个维度表的外来键 —— 在 [图 3-12](../img/fig-3-12.png) 中分别是日期和产品。你现在可以绘制一个二维表格，一个轴线上是日期，另一个轴线上是产品。每个单元格包含具有该日期 - 产品组合的所有事实的属性（例如 `net_price`）的聚合（例如 `SUM`）。然后，你可以沿著每行或每列应用相同的汇总，并获得减少了一个维度的汇总（按产品的销售额，无论日期，或者按日期的销售额，无论产品）。
一般来说，事实往往有两个以上的维度。在图 3-9 中有五个维度：日期、产品、商店、促销和客户。要想象一个五维超立方体是什么样子是很困难的，但是原理是一样的：每个单元格都包含特定日期 - 产品 - 商店 - 促销 - 客户组合的销售额。这些值可以在每个维度上求和汇总。
物化资料立方体的优点是可以让某些查询变得非常快，因为它们已经被有效地预先计算了。例如，如果你想知道每个商店的总销售额，则只需检视合适维度的总计，而无需扫描数百万行的原始资料。
资料立方体的缺点是不具有查询原始资料的灵活性。例如，没有办法计算有多少比例的销售来自成本超过 100 美元的专案，因为价格不是其中的一个维度。因此，大多数资料仓库试图保留尽可能多的原始资料，并将聚合资料（如资料立方体）仅用作某些查询的效能提升手段。
## 本章小结
在本章中，我们试图深入了解资料库是如何处理储存和检索的。将资料储存在资料库中会发生什么？稍后再次查询资料时资料库会做什么？
在高层次上，我们看到储存引擎分为两大类：针对 **事务处理（OLTP）** 最佳化的储存引擎和针对 **线上分析（OLAP）** 最佳化的储存引擎。这两类使用场景的访问模式之间有很大的区别：
* OLTP 系统通常面向终端使用者，这意味著系统可能会收到大量的请求。为了处理负载，应用程式在每个查询中通常只访问少量的记录。应用程式使用某种键来请求记录，储存引擎使用索引来查询所请求的键的资料。硬碟查询时间往往是这里的瓶颈。
* 资料仓库和类似的分析系统会少见一些，因为它们主要由业务分析人员使用，而不是终端使用者。它们的查询量要比 OLTP 系统少得多，但通常每个查询开销高昂，需要在短时间内扫描数百万条记录。硬碟频宽（而不是查询时间）往往是瓶颈，列式储存是针对这种工作负载的日益流行的解决方案。
在 OLTP 这一边，我们能看到两派主流的储存引擎：
* 日志结构学派：只允许追加到档案和删除过时的档案，但不会更新已经写入的档案。Bitcask、SSTables、LSM 树、LevelDB、Cassandra、HBase、Lucene 等都属于这个类别。
* 就地更新学派：将硬碟视为一组可以覆写的固定大小的页面。B 树是这种理念的典范，用在所有主要的关系资料库和许多非关系型资料库中。
日志结构的储存引擎是相对较新的技术。他们的主要想法是，透过系统性地将随机访问写入转换为硬碟上的顺序写入，由于硬碟驱动器和固态硬碟的效能特点，可以实现更高的写入吞吐量。
关于 OLTP，我们最后还介绍了一些更复杂的索引结构，以及针对所有资料都放在记忆体里而最佳化的资料库。
然后，我们暂时放下了储存引擎的内部细节，查看了典型资料仓库的高阶架构，并说明了为什么分析工作负载与 OLTP 差别很大：当你的查询需要在大量行中顺序扫描时，索引的重要性就会降低很多。相反，非常紧凑地编码资料变得非常重要，以最大限度地减少查询需要从硬碟读取的资料量。我们讨论了列式储存如何帮助实现这一目标。
作为一名应用程式开发人员，如果你掌握了有关储存引擎内部的知识，那么你就能更好地了解哪种工具最适合你的特定应用程式。当你调整资料库的最佳化引数时，这种理解让你能够设想增减某个值会产生怎样的效果。
尽管本章不能让你成为一个特定储存引擎的调参专家，但它至少大机率使你有了足够的概念与词汇储备去读懂你所选择的资料库的文件。
## 参考文献
1.  Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman: *Data Structures and Algorithms*. Addison-Wesley, 1983. ISBN: 978-0-201-00023-8