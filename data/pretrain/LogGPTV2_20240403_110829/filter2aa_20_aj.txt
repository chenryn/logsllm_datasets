### 文本优化

#### 字符编码与正则表达式
- **UTF-8 编码**：仅在字符编码为 UTF-8 的情况下，`preg_*` 函数能正常处理中文字符。相比之下，`mb_ereg` 适用于多种字符编码。
- **控制字符校验**：通过在程序的开头使用 `preg_*` 或 `mb_ereg` 进行包含空字节的控制字符校验，可以同时完成应用规格中的字符种类校验和空字节校验。

关于正则表达式的详细信息，请参考 PHP 官方文档或相关手册。接下来，我们将通过具体示例来探讨 PHP 中输入校验时需要注意的事项。

#### 示例1：1到5个字母数字字符的校验
以下代码展示了如何使用 `preg_match` 函数来校验“1-5 个字符的字母数字”：

```php
// 代码清单 /42/42-010.php
$p = '...'; // 待检验的字符串
if (preg_match('/^\p{L}\d{1,5}$/u', $p)) {
    echo "匹配成功";
} else {
    echo "匹配失败";
}
```

传递给 `preg_match` 的正则表达式可以按照如下方式进行解释：
- **u 修饰符**：在中文环境中使用 `preg_match` 时，无论检验对象是否含有中文，都必须指定表示字符编码为 UTF-8 的 `u` 修饰符。
- **i 修饰符**：`i` 修饰符表示匹配时不区分大小写。
- **全体一致匹配**：使用 `\A` 和 `\z` 来代表数据的开头和结尾。有时也可以使用 `^` 和 `$` 来代替 `\A` 和 `\z`，但由于 `^` 和 `$` 分别代表“行的”开头和结尾，因此可能会导致换行符被误匹配。
- **字符集合**：`[...]` 表示允许的字符集合。例如 `[a-zA-Z0-9]` 表示字母和数字。
- **数量修饰符**：`{1,5}` 表示字符数大于等于 1 且小于等于 5。若允许为空（0 字符），则指定为 `{0,5}`。

#### 使用 `mb_ereg`
如果选择使用 `mb_ereg` 函数而不是 `preg_match`，需要对脚本进行如下修改：

```php
// 代码清单 /42/42-012.php（选摘）
mb_regex_encoding('UTF-8'); // 指定 mb_ereg 函数的字符编码
if (mb_ereg('^[a-zA-Z0-9]{1,5}$', $p) === true) {
    echo "匹配成功";
} else {
    echo "匹配失败";
}
```

`mb_ereg` 与 `preg_match` 的主要区别在于：
- `mb_ereg` 的正则表达式不需要用 `/` 括起来。
- 不需要使用 `u` 修饰符。
- 当没有找到匹配项时，`mb_ereg` 返回 `false`。
- 由于 `mb_ereg` 的返回值为整数或布尔型，比较时应使用严格类型比较运算符 `===`。

#### 示例2：住址栏的校验
对于住址和姓名等输入框，多数情况下只限制字符长度而不限制字符种类。但是，即使不限制字符种类，也应当检查是否有控制字符混入，以防范空字节攻击。例如，下面的脚本使用 POSIX 字符集合 `[[:^cntrl:]]` 来表示“非控制字符的字符”。

```php
// 代码清单 /42/42-013.php
$name = '...'; // 待检验的字符串
if (mb_ereg('^[[:^cntrl:]]{1,50}$', $name) === true) {
    echo "匹配成功";
} else {
    echo "匹配失败";
}
```

在 `getParam` 函数中进行了读取字符串、校验字符编码、转换字符编码以及输入校验等操作。定义此类可复用的通用方法，可以使后续开发过程更加轻松。

范例代码中也存在一些不足之处，如错误消息过于简陋难以理解等。这里希望将代码的改进工作作为练习留给读者。