Clear CR.∗
Clear hP K .K+
po bind
else
CR.K−1
po bind ← DecCR.Kpo encr (hP K .{K−1
po bind}CR.Kpo encr )
return hP K .K+
po bind
Function 3. This function is very eﬃcient as it only re-
quires symmetric cryptographic operations.
In particular,
f_read_asym_keys[] checks tag hP K .τ to ensure that in-
put data has not been tampered with.
If this veriﬁcation
passes, the function decrypts the private binding key to
CR.K −1
po bind, using the symmetric key CR.Kpo encr. Note
that the corresponding read functions, for create functions 2a
and 2b, are the same except for the sizes of the operands,
outputs, and registers required to store private and public
keys.
4.1.2
Instruction Descriptions
Inst 1 {he, H(pe, he)} ← init[]
R
←−{0, 1}ℓ
pe ← f_read_PUF[]
rand
{he, H(pe, he)} ← f_init_PUF[pe, rand]
Clear pe, rand
return {he, H(pe, he)}
Instruction 1. This instruction initializes the helper data
he used to de-noise the raw SRAM PUF value pe. The func-
tions f_read_PUF[] and f_init_PUF[] read the raw PUF
value and instantiate the helper data, as described in Sec-
tion 4.1.1. The hash value H(pe, he) will be used by later
instructions to prevent modiﬁed helper data from being used
in attempts to learn information about the PUF. Observe
that a hardware-generated random number, rand, is used to
introduce entropy in the resulting helper data’s value.
The variable rand needs to remain secret and exposed
It is also assumed that he can
only inside the processor.
only be set once (or a limited number of times) to prevent
exposing the output of the fuzzy extractor. This can be
achieved during the initialization, which is performed by
the HWM. Because of our use of robust fuzzy extractors
[5, 9], we do not require any secure non-volatile memory.
All data is stored outside the chip, either locally or ex-
ternally published on a website. An additional step, not
shown and not performed as part of Instruction 1 is the
−1
T T P
signing of he||H(pe, he) by the HWM or a TTP with output
σhe ← SignK
(he||H(pe, he)). This guarantees to any
third party (users, system integrators, device owners, etc.)
that the helper data was created by the HWM and not some
other (untrusted) party. Notice this is done only once during
the lifetime of the device.
Inst 2 hP K ← create[So, he, H(pe, he), σhe , K +
T T P ]
if Verify
K
+
T T P
(he||H(pe, he), σhe ) = accept then
Spo bind ← f_create_sym_keys[So, he, H(pe, he)]
hP K ← f_create_asym_keys[Spo_bind]
Clear Spo bind
return hP K
else
ABORT
Instruction 2. This instruction generates a hierarchy of
cryptographic keys from the raw PUF response pe. Symmet-
ric and asymmetric keys are generated by f_create_sym_
keys[] (Function 1) and f_create_asym_keys[] (Function 2a
or 2b), respectively.
po bind, K −1
The hP K variable is assigned the {K +
po bind} key-
pair generated by f_create_asym_keys[]. Observe that
hP K is encrypted and contains authentication information,
which is veriﬁed internally by OASIS using a key derived
from the internal PUF key and the seed So. Lastly, note
that veriﬁcation of the signature σhe is most eﬃcient if the
signature algorithm is based on RSA using a small exponent
(e.g., 3, 17, or 216 + 1). Regardless of the latency due to sig-
nature veriﬁcation, we expect that this step is performed
rarely – e.g., whenever the device changes ownership or if a
user desires to setup the environment for future use.
Inst 3 launch[C, C.inputs, So, he, H(pe, he), hP K ]
Conﬁgure CPU into CAR Mode
Load C into the CPU cache
Spo bind ← f_create_sym_keys[So, he, H(pe, he)]
K+
CR.P CR ← H (C)
CR.KC ← KDFCR.Kpo code (H (C))
if (Spo bind =⊥) then
po bind ← f_read_asym_keys[hP K ]
Clear CR.∗
ABORT
Clear Spo bind
Transfer control to C’s entry point
Instruction 3. The launch[] instruction is designed to
setup the OASIS environment for code C and populate all
necessary registers.
It begins by setting up a clean-slate
CAR environment, including disabling interrupts and hard-
ware debugging access. It then reads and loads CR.∗ regis-
ters with cryptographic key material for further processing
by other instructions.4
4A possible optimization is to conditionally invoke f_cre-
ate_sym_keys[] and f_read_asym_keys[]. For example,
launch[] can be modiﬁed to only invoke f_create_sym_
keys[] once after the processor reboots and maintain the re-
sulting keys in CR.* during successive OASIS sessions. This
optimization must be carefully considered and constructed
by the implementer to manage the security trade-oﬀ (PUF-
derived secrets persisting between invocations). Addition-
18To avoid the expensive operations performed in create[]
for asymmetric key generation (e.g., prime generation), an
encrypted data store hP K is returned by f_create_asym_
keys[] and f_read_asym_keys[hP K] is used on subsequent
invocations. This function’s overhead is equivalent to a few
eﬃcient symmetric-key operations.
Observe that if we want to make the public binding key
available outside the environment, Instruction 2 must be
called ﬁrst. Also note that Instruction 2 veriﬁes the signa-
ture σhe every time it executes, whereas Instruction 3 does
not. We expect that signature veriﬁcation will be performed
at most once per session, where each session might call the
launch[] instruction multiple times. Notice that even if
the signature veriﬁcation function is performed every time,
the overhead should be minimal, assuming RSA signatures.
Refer to Figure 1 for details on when instructions are called.
Next, launch[] stores a hash of the target code C to the
platform conﬁguration register CR.P CR. Finally, a sym-
metric key KC is generated using a key derivation function
based on CR.Kpo code and a hash of target code C. KC is
used for encrypting and authenticating the executing code’s
state for local storage to untrusted memory.
At the end of launch[], the following registers have been
populated: CR.Kpo, CR.Kpo auth, CR.Kpo encr, CR.Kpo code,
CR.K −1
po bind, CR.P CR, and CR.KC .
po bind
, which
generate a related ciphertext {X, P CR ver′}K+
the device would be willing to decrypt for diﬀerent code
with measurement P CR ver′. To prevent this, the encryp-
tion scheme must be non-malleable – i.e., an attacker can-
not use one ciphertext to generate a second ciphertext that
decrypts to a plaintext related to the original plaintext.
The formal deﬁnition of non-malleable is known as Cho-
sen Ciphertex Attack of type 2 or CCA2. Examples of
CCA2 (non-malleable) asymmetric encryption schemes in-
clude RSA-OAEP and RSA-OAEP+ [39].5 An alternative
strategy to using a non-malleable public-key encryption scheme
is to use the secret encrypted with the asymmetric primitive
to derive two keys: an encryption key and a MAC key. The
MAC key should be used to compute a MAC over the bulk-
encrypted ciphertext, and the receiver should reject cipher-
texts with an inconsistent MAC. This is the strategy used
in the Integrated Encryption Scheme [38]. In this work, we
simply assume that we are using a CCA2 public-key encryp-
tion scheme regardless of its particular implementation.
Inst 5 out ← bind[KV P , stateOS, hashInputs, resultV, update]
Inst 4 X ← unbind[{X1, P CR_ver}K+
po_bind
, {X2, P CR_ver}KC ]
if {X1, P CR ver}
K
+
po bind
6= N U LL then
X, P CR ver ← Dec
CR.K
−1
po bind
({X1, P CR ver}
K
+
po bind
)
else if {X2, P CR ver}KC 6= N U LL then
X, P CR ver ← AuthDecCR.KC ({X2, P CR ver}KC )
else
X ←⊥
if CR.P CR 6= P CR ver then
X ←⊥
return X
Instruction 4. Inputs X1 and X2 contain data values that
should only be released to the code that generated the data.
The unbind instruction provides assurance to the veriﬁer
that the inputs will only be released to the code with mea-
surement P CR ver. Note that unbind[] can decrypt data
encrypted under either of the binding key K +
po bind or the
application secret key KC .
In the protocol described in Section 5, included in X2 is a
symmetric key KV P , which is generated by the veriﬁer V for
bulk encryption of data to be transferred between V and the
platform P . Notice that we do not suggest using the public
binding key, K +
Instead, sym-
metric keys should be used for bulk encryption operations
and the public binding key for storing bulk encryption keys.
This is a common practice used to avoid the performance
cost of public key cryptography.
po bind, for bulk encryption.
In choosing the asymmetric encryption scheme, some care
must be taken to prevent an attacker from using the ci-
phertext {X, P CR ver}K+
, which is intended to be de-
crypted only by the code with measurement P CR ver, to
po bind
ally, the call to f_read_asym_keys[] may be skipped for
sessions that only require symmetric keys.
if update 6= N U LL then
C′ ← AuthDecKV P (update)
if C′ 6=⊥ then
CR.P CR ← H (C′)
CR.KC ← KDFCR.Kpo code (CR.P CR)
out.OS ← AuthEncCR.KC (stateOS, CR.P CR)
V.hosstate ← H(stateOS)
V.hinp ← hashInputs
V.encK ← AuthEncCR.KC (KV P , CR.P CR)
V.res ← resultV
out.V ← AuthEncKV P (V )
Clear CR.∗
Clear all state
return out
Instruction 5. The bind[] instruction prepares data for
transfer to the untrusted code. This instruction should be
called by the executing code right before returning. Inputs
to this instruction include a shared secret KV P , the applica-
tion state stateOS, a hash of application input hashInputs,
and the application results results. The variables out.OS
and out.V are ciphertext to be stored in local memory and
sent to the veriﬁer, respectively. Please note that out.OS
and V.encK bind stateOS and KV P to the launch point
measurement of executing code C. Finally, observe that
bind[] enables program code C updates. This is enabled
by checking whether the update has been encrypted and au-
thenticated with the shared secret KV P and upon successful
veriﬁcation, updating CR.P CR and CR.KC , accordingly.
5Note that it is possible for an encryption scheme to be
semantically secure while still being malleable [11]. For ex-
ample, in a hybrid scheme where RSA is used to encrypt
a symmetric key, which is in turn used in a block cipher
to encrypt the bulk data, then clearly the last block of the
bulk-encrypted data can be modiﬁed without changing the
decryption of the preceding plaintext blocks. This could al-
low the attacker to change the speciﬁed PCR if it appears
at the end of bulk encrypted data. Even if the authorized
PCR is at the beginning, the attacker would still be able to
modify the end of the bulk data without changing the value
of the preceding ciphertext.
195. SECURE REMOTE EXECUTION
Figure 2 shows the protocol for the initial and subsequent
executions of security sensitive application f oo(). We as-
sume that the remote veriﬁer V has a copy of the public
platform binding key, K +
po bind. Similarly, the veriﬁer can
keep a certiﬁcate that is used to conﬁrm the authenticity of
the public key it receives from the platform. We also assume
that the veriﬁer has access to the plaintext code.
In Step 1, the veriﬁer V initiates an isolated execution
session with the platform. V generates an encryption key
KV P , and binds the hash of the code f oo() with KV P . Bind
allows the veriﬁer to encrypt data using the public part of
the platform key while ensuring that only the correct code
running in a correctly setup execution environment can ac-
cess the data. The inputs along with the code are sent to
the platform.
In Step 2, the OS calls the hardware instruction launch[]
using the plaintext code f oo(), the veriﬁer inputs V.inp, and
the previously stored state OS.inp as inputs. If it is the ﬁrst
code execution OS.inp is empty.
In Step 3, the isolated execution environment IEE ﬁrst
checks inputs received from the veriﬁer. If a “setup” com-
mand was received from the veriﬁer the IEE attempts to
unbind the encrypted inputs from V as follows. The IEE
releases shared encryption key KV P , using the unbind[]
instruction, and decrypts any private inputs, aborting exe-
cution if either operation fails. These checks prevent unau-
thorized code from proceeding. After the checks, the ap-
plication logic is executed. For example, if the application
is a secure counter, during the ﬁrst iteration the counter is
set to zero. In the case of an encrypted database, the ﬁrst
records could be stored in the database or all records could
be initialized to zero.
Steps 4 and 5 show the parameters returned to the OS
and the veriﬁer, respectively. Step 5 is critical as it pro-
vides evidence to the veriﬁer that the computation has been
performed on the correct inputs and, in particular, that the
inputs have not been manipulated prior to entering OASIS.
6. DISCUSSION
6.1 Linkable Code Blocks
So far, we have presented how an application C that is
fully contained within the CPU cache is executed in OASIS.
Recall that the unbind[] instruction guarantees that only
C can access its protected state during future invocations
by verifying that the loaded application has measurement
H(C) before decrypting.
Now we consider the case of an application that has size
greater than the cache (e.g., application C = C0|C1| . . . |Cn
where Ci refers to the ith application code block). Execu-
tion of more complex applications is achieved by computing
a Merkle hash tree over the entire program, and binding
the resulting tree’s root value to the application state. The
loaded code block Ci is accepted if and only if the hash tree
validation succeeds.
The hash tree construction provides several nice proper-
ties. First, it extends state protection and load-time in-
tegrity checking to applications of arbitrary size. Second, it
maintains a small TCB. Third, it enables eﬃcient execution
because code block Ci may be safely executed before the
entire application C has been hashed.
Setup Session
1. V
: V.inp.cmd ← command
: V.inp.pubdata ← pubInputs
: if (V.inp.cmd = “setup”)
R
←−{0, 1}ℓ
: KV P
:
:
V.inp.privdata ← AuthEncKV P (privInputs)