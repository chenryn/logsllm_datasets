outgoing traﬃc. The latter use assumes that the shield is
installed at a higher privilege level than the malicious or
compromised sender of the vulnerability-exploiting traﬃc.
Otherwise, the sender could simply disable the shield before
attacking the other hosts.
Shield policies are active as soon as they are received by
end host Shield and do not require restarting the vulnera-
ble service or rebooting the system. Once a software patch
is applied to the vulnerable application, the corresponding
policy can be removed from Shield.
3. SHIELD ARCHITECTURE
3.1 Goals and Overview
The objective of Shield is to emulate the part of the ap-
plication level protocol state machine that is relevant to its
vulnerabilities with intercepted messages and counter any
exploits at runtime.
We identify three main goals for the Shield design:
1. Minimize and limit the amount of state maintained
by Shield: Shield must be designed to resist any re-
source consumption (“Denial-Of-Service”, or “DoS”)
attacks. Therefore, it must carefully manage its state
space. For an end-host-based Shield, the bar is not
high: Shield only needs to be as DoS-resilient as the
service it is shielding.
2. Enough ﬂexibility to support any application level pro-
tocol: Flexibility must be designed into Shield so that
vulnerabilities related to any application level proto-
col can be protected by Shield. Moreover, the Shield
system design itself should be independent of speciﬁc
application level protocols, because the Shield system
design and implementation would simply not scale if
it were necessary to add individual application level
protocols to the core system one at a time.
3. Design Fidelity: We must design Shield in such a way
that Shield does not become an easier alternative at-
tack target. A robust Shield design must ensure that
Shield’s state machine emulation is consistent with the
actual state machine running in the vulnerable appli-
cation under all conditions. In other words, it is cru-
cial for us to defend against carefully crafted malicious
messages that may lead to Shield’s misinterpretation
of the application’s semantics.
Shield achieves goal 2 by applying the well-known princi-
ple of “separating policy from mechanism”. Shield’s mecha-
nism is generic, implementing operations common among all
application level protocols. Shield policies specify the vary-
ing aspects of individual application level protocol design as
S0V4S3S2S1S5S0V4S5S2Vulnerability State MachineProtocol State MachineEmbedded Application State Machine in State S2VulnerableEventwell as the corresponding vulnerabilities. This separation
enables the ﬂexibility of Shield to adapt to various applica-
tion level protocols.
We identify the following mechanisms as the necessary
generic elements of an application level protocol implemen-
tation:
(Less obvious generic elements will be explained
throughout the next section.)
• Application level protocols between two parties (say, a
client and a server) are implemented using ﬁnite state
automata.
• To carry out state machine transitions, each party
must perform event identiﬁcation and session dispatch-
ing. Session is the unit of communication that is mod-
eled by the protocol state machine. A session contains
one or more application messages and one or more pro-
tocol states. As a result, application-level messages
must indicate a message type and session ID when the
number of states exceeds one.
• Implementations of datagram-based protocols must han-
dle out-of-order application datagrams for their ses-
sions. (See Section 4.2.)
• Implementations of application-level protocols that al-
low message fragments must handle fragmentation. (See
Section 4.3.)
The policy speciﬁes the following:
• Application identiﬁcation: how to identify which pack-
ets are destined for which application. The service port
number typically serves this purpose.
• Event identiﬁcation: how to extract the message type
from a received message.
• Session identiﬁcation (if applicable): how to determine
which session a message belongs to.
• State machine speciﬁcation:
the states, events, and
transitions deﬁning the protocol automaton.
In our
setting, the speciﬁcation is for the vulnerability state
machine, a subgraph of a complete protocol state ma-
chine (see Section 2).
We ﬁrst present the Shield mechanisms,
including the
policy-enabling mechansims, in Section 3.2. Then, we present
our policy language in Section 5.
3.2 Components and Data Structures
In this section, we describe the essential components and
data structures of an end-host Shield system. Figure 2 de-
picts the Shield architecture.
3.2.1 Data Structures
There are two main data structures: the application vul-
nerability state machine speciﬁcations (“Spec”) and the run-
time session states.
The Policy Loader transforms Shield policies into Specs.
Multiple vulnerability state machines for the same applica-
tion are compiled into one application vulnerability state
machine speciﬁcation. Therefore, there is eﬀectively one
state machine speciﬁcation or Spec per application. Merg-
ing vulnerability state machines is easy if an entire protocol
had been speciﬁed in our Shield language (Section 5) ahead
of time: Newly discovered vulnerabilities can be expressed
by annotating the already-speciﬁed protocol state machine.
Figure 2: Shield Architecture
The purpose of a Spec is to instruct Shield how to emulate
the application vulnerability state machines at runtime. As
mentioned in Section 3.1, the Spec contains the state ma-
chine speciﬁcation, port number(s) for application identiﬁ-
cation, and event and session identiﬁcation information.
For event and session identiﬁcation, a Spec indicates the
location (i.e., oﬀset and size) vector for the event type and
session ID information in the packet, as well as the event
type values that are of concern to Shield. For application
protocols with only one state, the session ID is unnecessary
and left unspeciﬁed. Sometimes, an application-level proto-
col may involve negotiating for a dynamically selected port
number as a session ID for further communications (e.g.,
FTP [30] and RTP [36]). In this case, the port negotation
part of the protocol state machine must be speciﬁed, and
the new port number would be registered with Shield at
runtime for application identiﬁcation from that point on.
The session ID would be speciﬁed as “PORT”, indicating
that all communication on this port is considered as a single
session. Upon termination of the session, the dynamic port
is de-registered with Shield.
To generalize the event dispatching abstraction to text-
based application level protocols such as HTTP [12] and
SMTP [17], we allow the units of “oﬀset” and “size” to be
deﬁned as words (made of characters), in addition to bytes.
For example, in HTTP and SMTP, the message type is in-
dicated at oﬀset 0, with a size of 1 word.
In HTTP, this
ﬁeld contains the request-line method, such as ”GET” or
”POST”; when it is an HTTP version, it represents a status
message type [12]. In SMTP, this ﬁeld contains the SMTP
command, such as “MAIL”, “RCPT”, or “DATA”. (Please
see Figure 4 for example.) Using words as a unit requires us
to include an additional policy element: maximum word size
— otherwise attackers could attack Shield using extremely
long words. Of course, we could generalize the unit even
further by making unit delimiters and maximum unit size
part of the Spec, beyond bytes and space-delimited words.
However, we have not yet found this to be necessary for the
handful of protocols we have examined.
Some application-level protocols (such as HTTP) allow
multiple application-level messages to be received in a single
buﬀer. Therefore, in addition to the session ID and message
type, the Spec also speciﬁes the application level message
boundary marker, if any. For example, for HTTP, the mes-
sage boundary marker is CRLF CRLF.
One key challenge is that application level messages may
SessionDispatcherPer-AppVulnerability State Machine Specification(Spec)New PoliciesSessionIDLocationMessageTypeLocationMessage boundaryRaw bytesPort #Raw bytesSpec IDEvent for Session iInterpret (Handler)ParsePayloadDropShield ArchitectureTearDownSessionPolicyLoaderApplicationDispatcherSessionStateSessionStateSessionState iCurStateHandlerAt(State, Event)State MachineInstance iState MachineInstance iState MachineInstance iShieldInterpreterSetNextStatenot be received in their entirety (due to congestion control
or application-speciﬁc socket usage) or in order (due to us-
ing UDP, for example). Even the essential event-identifying
parts of a message, such as event type and session ID, may
not arrive together. We address this problem using DoS-
resilient copying or buﬀering, which is detailed in Section 4.
Note that the session is an important abstraction for packet
dispatching and as a unit of shielding, apart from socket de-
scriptors or host pairs. This is because one socket descriptor
may be used for multiple sequential sessions; and multiple
sockets may be used to carry out communications over one
session (e.g., FTP [30]). Similarly, one pair of hosts may
be carrying out multiple sessions. In these cases, the use of
sessions eliminates any ambiguities on which packets belong
to which session.
The other data structure in Shield is session state. At run-
time, Shield maintains session state for each potentially vul-
nerable communication session. The session state includes
the current state of the session and other context informa-
tion needed for shielding.
3.2.2
Shield Modules
We now describe each Shield module in turn:
Policy Loader: Whenever a new Shield policy arrives
or an old policy is modiﬁed, the Policy Loader integrates
the new policy with an existing Spec if one exists, or cre-
ates a new one otherwise. The Shield policy is expressed in
the Shield policy language. Policy loading involves syntax
parsing, and the resulting syntax tree is also stored in the
Spec for the purpose of run-time interpretation of shield-
ing actions For details on the policy language design and
interpretation, please see Section 5.
Application Dispatcher: When raw bytes arrive at
Shield from a port, the Application Dispatcher is invoked
to determine which Spec to reference for the arrived data,
based on the port number. The Application Dispatcher for-
wards the raw bytes and the identiﬁed Spec to the Session
Dispatcher for event and session identiﬁcation.
Session Dispatcher: On obtaining the locations of the
session ID, message type, and message boundary marker
from the corresponding Spec, the Session Dispatcher ex-
tracts multiple messages (if applicable), recognizes the event
type and session ID, and then dispatches the event to the
corresponding state machine instance.
State Machine Instance (SMI): There is one state
machine instance per session. Given a newly-arrived event
and the current state maintained by the corresponding ses-
sion state, the SMI consults the Spec regarding which event
handler to invoke. (Event handlers are included in Shield
policies; please see Section 5.) Then the SMI calls the Shield
Interpreter to interpet the event handler.
Shield Interpreter: The Shield Interpreter interprets
the event handler, which speciﬁes how to parse the application-
level protocol payload and examine it for exploits. It also
carries out actions like packet-dropping, session tear-down,
registering a newly-negotiated dynamic port with Shield, or
setting the next state for the current SMI.
4. DETAILED DESIGN ISSUES
4.1 Scattered Arrivals
Although Shield intercepts traﬃc above the transport layer
and does not need to cope with network-layer fragments,
each data arrival perceived by Shield does not necessarily
represent a complete application level message that is inde-
pendently interpretable by the application. The scattered
arrivals of a single application level message could be due to
TCP congestion control or some speciﬁc message-handling
implementations of an application. For instance, a UDP
Server may make multiple calls to recvf rom() to receive a
single application level message. In this case, Shield would
recognize multiple data arrivals for such messages. This
complicates session dispatching when session ID or message
type are not received “in one shot”. It also complicates pay-
load parsing in the event handlers when not enough data has
arrived for an event-handler to ﬁnish parsing and checking.
Here, we must copy (i.e., buﬀer and pass on) part of the
incompletely-arrived data in the Shield system, and wait for
the rest of the data to arrive, before we can interpret it.
In addition, we need to index copy-buﬀers so that later ar-
rivals of the same message for a given session can be stitched
together properly. Although socket descriptors are not ap-
propriate to identify sessions (Section 3.2), they are safe for
indexing copy-buﬀers: While multiple sockets could be used
for one session (e.g., FTP [30]), a single application message
is typically2 not scattered over multiple sockets — otherwise
the application would not be able to interpret the parts of
the message due to the lack of information such as session
ID or message type; similarly, although one socket descriptor
could be used for multiple parallel sessions, an application
message has to be received on a socket continuously to its
completion without interruptions from any other applica-
tion messages. Therefore, we can apply per-socket copying
for incomplete message arrivals.
We diﬀerentiate between pre-session copying and in-session
copying. Pre-session copying happens when the session ID
information has not completely arrived, while in-session copy-
ing refers to the copying of the data whose session is known.
A copy-buﬀer is associated with a socket initially before a
session ID fully arrives. Once the session ID is received, the
copy-buﬀer is associated with both a socket and its respec-
tive session. Once a complete application message has been
received, the copy-buﬀer is de-allocated.
We do not need to save the entire partially arrived mes-
sage, but only the partially arrived ﬁeld. For example, when
a Session ID ﬁeld has not arrived completely — say only 2
out of 4 bytes — Shield only needs to remember that it is
parsing the Session ID ﬁeld, and saves the received two bytes
only. This reduces the overhead of copying in Shield.
We now introduce another runtime data structure that
needs to be maintained by Shield: parsing state. This state
is per application-level message, and it records which ﬁeld of
an application message is being parsed, and how many bytes
have already been received for that ﬁeld. The ﬁeld has to
be a “terminal” ﬁeld rather than a structure of ﬁelds; for a
ﬁeld nested in other structures or an array, the ﬁeld is rep-
resented as something like “someStructure.ﬁelds[i]”. This
restriction minimizes the amount of copying needed, since
terminal ﬁelds are typically small.
2pTCP [15] proposes the use of TCP-v as an abstraction of
a connection which can use multiple sockets instead of one
as in TCP. If pTCP were deployed, Shield would use TCP-v
to index the copy-buﬀer instead.
For a vulnerable application, we must maintain the state
of the current ﬁeld being parsed for each of the application
messages, even when Shield had already determined that
the session to which the message belongs would not lead to
any exploit. (However, we do not maintain session state and
the copy-buﬀer for such sessions.) This prevents ambiguity:
If we do not keep the parsing state for the message, other
parts of the message would be treated as new application
messages. Attackers could then easily craft parts of a single
application-level message [32], send them separately, and
cause inconsistencies between the emulated state machine
in Shield and the actual state machine in the application.
For Shield to be able to parse application messages, pars-
ing instructions (or payload formats) for all of an applica-
tion’s message types must be speciﬁed to Shield in policy
descriptions. Therefore, payload formats must also be part
of the Spec. Fortunately, Shield does not need to parse all
messages in detail, but only the parts necessary for detecting
the presence of an exploit. Therefore, we can aggressively
bundle many ﬁelds of an application message into one ﬁeld
with a total byte count or word count, which will be the
number of bytes or words to skip during parsing. When
Shield determines the innocence of a session, the goal of