### Implementation of Component Creation, State Management, and Event Handling

Our implementation models the creation of components, shared and saved state, lifecycle event firing, and argument context. Additionally, it handles callback event firing and associated argument context.

#### Callback Handlers
For callback handlers, we implement a registration method that invokes the application's callback handler with the appropriate arguments. For instance, in Android, a component can register to be notified of database changes, which are then handled in a specific method within a new thread. The application defines a callback handler object and registers it for database change notifications. Our ADI (Android Device Implementation) implements this registration via a stub that directly creates the thread and calls the callback method on the registered database. 

Since our analysis is flow-insensitive and our harness is wrapped in a loop, DroidSafe considers all possible event orderings, even though the stub API method directly invokes the callback handler from the registration method with the appropriate context.

For arguments generated by the runtime system, our model creates a new object and passes it to the registered callback handler in the app. For example, to model a key press, our runtime system creates a new object representing the key press and calls the callback handler with this object for each component.

### Package for Component Creation and Lifecycle Event Modeling

We developed a separate package to handle component creation and lifecycle event modeling. This package includes stubs for registration methods for each Android component type: Activity, Service, BroadcastReceiver, and ContentProvider. The harness (discussed below) instantiates each application component and passes the component object to the appropriate registration method. These registration methods model shared preferences, saved state, global context classes, and device configuration, ensuring accurate context is passed to the lifecycle events of components.

Since our runtime system explicitly calls all lifecycle events of each component, a flow-insensitive analysis can capture the flow between two lifecycle events. Accurate modeling of saved state through the API and back into a callback handler enables the analysis to report the flow as shown in Figure 1(b).

### Identifying and Classifying Sensitive Sources and Sinks

We manually identified 4,051 sensitive source methods and 2,116 sensitive sink methods in the Android API. Each source and sink was classified with a high-level classification (e.g., location, device ID, file, network, and database) to group analysis results for verification or human consumption. For example, an analysis might report: "Location data can flow to the network."

Initially, we tested SuSi, a tool that automatically identifies sources and sinks in the Android API [24]. However, the automatically identified sources and sinks were incomplete. Comparing our identifications with SuSi, we found that SuSi missed hundreds of important sources. For example, SuSi did not identify 53% of source calls as "sensitive sources" and 32% of sink calls as "sinks" for malicious flows in the APAC malicious applications (see Section VIII). These omissions highlight the challenges of automatic identification.

### ADI Coverage and Keeping Current with Android Updates

Our core model includes 550 commonly-used Android API implementation classes, which we manually reviewed, added accurate analysis stubs, and verified. Verification ensured that class implementations were not missing semantics for data flow, object instantiation, and aliasing, and that event callbacks were called explicitly with the proper context.

For classes not in our core set, we maintain high accuracy by analyzing the actual Java implementation with accurate analysis stubs, although complex implementations may introduce some imprecision.

To measure ADI coverage, we acquired a list of Android API method call frequencies from 95,910 applications downloaded from the Google Play Store. Calls to the core 550 verified classes account for 98.1% of total calls across these applications.

We initially seeded the ADI with AOSP version 4.0.3 and verified the core based on this version. We have since upgraded our model to Android 4.4.3, reviewing changes to the core 550 classes and verifying any updates. This process required one person-week of work for an experienced Java and Android developer. The update process for the rest of the ADI classes involved copying them from AOSP 4.4.3 and creating accurate analysis stubs for native methods, requiring another person-week. We expect future updates to be relatively fast due to minimal changes in the core Android between versions.

### Harness

Each analyzed application must be hooked into the ADI via a harness. In its first pass, DroidSafe generates this harness method automatically. It scans the application source code for all classes that subclass one of Android's four component types and instantiates objects in the harness for all such classes. We cannot rely solely on the Android manifest for the complete list of components, as it only lists exported and available components. Each component is represented by a single heap object to account for the complexities of the Android component memory model.

In the harness, each instantiated component object is passed to the appropriate runtime method to exercise all lifecycle events. The harness method is wrapped in a loop to capture all possible orderings for callbacks.

The harness also includes the instantiation of GUI objects defined in XML resources, setting their attributes, and registering event handlers like `onClick`. It incorporates String values defined in XML resources.

### Object-Sensitive Points-to Analysis

Points-to analysis (PTA) computes a static abstraction of all heap locations that a pointer (reference) variable may point to during program execution. It also constructs a call graph, essential for modern languages to calculate targets for dynamic dispatch and functional lambda calculations. Our goal was to use much of the AOSP Android API implementation without modification while achieving precise results for client analyses.

There is a trade-off between scalability and precision in static analyses. Appropriate control-flow and data-flow abstractions must be chosen to avoid intractability and achieve acceptable precision.

Consider the difficulties of analyzing complex Java code with precision. Figure 2 shows simplified ADI source code for two commonly used classes in the Android API: `android.os.Bundle` and `java.util.HashMap`. `Bundle` allocates a `HashMap`, and the example provides relevant code for two Android activities, each creating a `Bundle` and storing values. `Activity1` puts non-sensitive data in its `Bundle`, while `Activity2` puts sensitive data.

To precisely separate the two `Bundle` objects created, a PTA must distinguish multiple levels of allocations. For example, an analysis must separate the array of entries created in the two `HashMap` objects of the two `Bundle` objects. Otherwise, sensitive data put in one `Bundle` could be conflated with data retrieved from the other `Bundle`, decreasing precision.

Our PTA algorithm is based on a whole-program, flow-insensitive, subset-based foundation [25] for Java, enhanced with context sensitivity. Context sensitivity allows a PTA to separate analysis facts for a method `m` at multiple call sites. DroidSafe implements object sensitivity, which is the best choice for object-oriented languages [18, 26–28].

Object sensitivity uses object allocation sites (new expressions in Java) as context elements. In our analysis, a heap object `o` is represented by the allocation site of `o`, plus the allocation site of the object that allocated `o`, and so on, to a parameterized depth `k`.

For the example in Figure 2, our analysis can separate analysis facts calculated for the array table of two `HashMap` objects allocated from the two `Bundle` objects. When `Bundle` objects are created, a series of allocations is performed via constructors. The object-sensitive heap abstraction will have two separate elements representing the two table arrays, with context being their allocation history:

- `T1 ← H1 ← N1`
- `T1 ← H1 ← S1`

Where `a ← b` denotes “a allocated in b”.

The new expression on line 3 of `Activity1` creates a heap object `N1`, and the cascading allocations create `H1 ← N1` and `T1 ← H1 ← N1`, respectively.

When `Bundle.put(...)` of `Activity2` is called, the method context (receiver) for the call is `S1`, triggering a call to `HashMap.put(...)` with context `H1 ← S1`. In this context, the points-to set result for the reference to the field `table` on line 7 of `HashMap` is the array object `T1 ← H1 ← S1`. Any elements placed in this array via the assignment on line 7 will only be reflected in this array heap object.

Thus, our PTA can separate analysis facts between the two `Bundle` objects in the two activities via deep object-sensitivity, requiring a heap context depth of 3.

Object sensitivity has powerful precision but presents scalability challenges. Our example requires a depth of 3, and other commonly used classes require deeper depths. For example, `Intent` allocates a `Bundle` (that allocates a `HashMap...`) requiring a depth of 4 to disambiguate items placed in the `Bundle` of two `Intent` objects.

We tested other whole-program object-sensitive frameworks but found they could not scale to the required context depth [29] or did not maintain program information required for our client [18].

### Solving Scalability Challenges

To address scalability, our PTA implementation operates on the pointer assignment graph (PAG) representation of the program [30], an explicit representation. While explicit implementations previously exhausted main memory for large programs, today's larger and increasing main memory sizes allow for better scalability.

Our implementation is flexible and parameterized, enabling us to implement client-specific and Android-specific optimizations. Without these optimizations, 3 out of 24 APAC applications (see Section VIII) could not finish analysis in DroidSafe given a limit of 64GB of heap memory. With optimizations, all applications now run in under 34GB of heap memory, providing a 5.1x savings in total analysis time.

#### Selectively Applying Context

Typically, a PTA keeps the same base context depth for all allocated objects. Initially, we tried this policy at a depth of 3, but our analysis failed on 3 APAC applications due to memory exhaustion. Instead, we implemented a targeted approach, adding context for an abstract heap location at the minimum depth required for precision. The context depth varies from 0 to 4.

By analyzing 211 Android applications, we learned which API classes from our ADI could be analyzed content-insensitively without significant loss of precision. We determined that 1489 Android API classes (26% of our ADI) could be analyzed without context, as they never reach a `String` value or a value tainted with sensitive information flow. For these classes, our clients' analyses yield the same results regardless of context.

Conversely, with a maximum context depth of 3, our PTA could not disambiguate many important analysis facts. To address this, we automatically increase the context depth to 4 for all heap objects of Array type. This ensures that we can disambiguate the `Bundle` between separate `Intent` objects, as discussed earlier.