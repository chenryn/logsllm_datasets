implementation that models component creation, shared and
saved state, life-cycle event ﬁring and argument context, and
callback event ﬁring and argument context.
For callback handlers, we implement the callback regis-
tration method to invoke the application’s callback handler
method with the appropriate arguments. For example, Android
deﬁnes the ability for a component to register to be notiﬁed
if a database has changed, and handle this change in a given
method in a new thread. The application will deﬁne a callback
handler object, and register this to be notiﬁed of database
changes. The ADI implements this registration method via
a stub that creates the thread directly, and calls the callback
method on the registered database. Since our analysis is ﬂow
insensitive and our harness is wrapped in a loop (see below),
DroidSafe considers all event orderings even though the stub
API method invokes the callback handler method directly from
the callback registration method (with the appropriate context).
For arguments to callback handlers that are generated by
the runtime system, our model creates a new object and passes
it to the registered callback handler in the app. For example,
to model a key press, our runtime system will create a new
object to represent the key press, and call the callback handler
with this object on each component.
6
We developed a separate package for implementing compo-
nent creation and life-cycle event modeling. This package con-
tains stubs for registration methods for each Android compo-
nent type: Activity, Service, BroadcastReceiver, and
ContentProvider. The harness (discussed below) instanti-
ates each application component and passes the component
object to the appropriate registration method. The registration
methods model shared preferences, saved state, global con-
text classes, and device conﬁguration. This context is passed
accurately to the life-cycle events of components.
Since our runtime system makes explicit calls to all life-
cycle events of each component, a ﬂow-insensitive analysis
can capture the ﬂow between the two life-cycle events in the
component in Figure 1(a). Also, since we accurately model
saved state through the API and back into a callback handler,
our model enables an analysis to report the ﬂow in Figure 1(b).
C. Identifying and Classifying Sources and Sinks
We manually identiﬁed 4,051 sensitive source methods and
2,116 sensitive sink methods in the Android API. We also
classiﬁed each source and sink with a high-level classiﬁcation
(e.g., location, device ID, ﬁle, network, and database) so that
analysis results can be grouped for veriﬁcation or consumption
by a human. For example, a ﬂow reported by the tool might
be: “Location data can ﬂow to the network.”
Initially, we tested SuSi, a tool that automatically identi-
ﬁes sink and source methods in the Android API [24]. The
automatically identiﬁed sources and sinks were incomplete.
We compared our identiﬁcations of sources and sinks with the
results of SuSi.1 and found that SuSi is missing hundreds of
important sources. For example, SuSi did not identify 53%
of source calls as “sensitive sources” and 32% of sink calls
as “sinks” for the malicious ﬂows in the APAC malicious
applications (see Section VIII). These missing sources and
sinks indicate the challenge of automatic identiﬁcation.
D. ADI Coverage and Keeping Current with Android Updates
The core of our model includes 550 commonly-used An-
droid API implementation classes. We manually reviewed,
added accurate analysis stubs, and veriﬁed these 550 classes.
For veriﬁcation, we manually conﬁrmed that the class im-
plementation is not missing semantics for data ﬂow, object
instantiation, and aliasing; and that event callbacks deﬁned
in the classes are called explicitly by our model (with the
proper context). For classes not
in our core set, we still
maintain high accuracy because we analyze the actual Java
implementation (with accurate analysis stubs), however we
may experience a higher level of imprecision for these classes
if their implementation is complex.
To measure the coverage of the ADI, we acquired a list of
Android API method call frequencies accumulated over 95,910
Android applications downloaded from the Google Play Store.
This list reports the number of invoke expressions to each
Android API method over all the applications. Calls to the
core 550 veriﬁed classes account for 98.1% of the total calls
over these applications.
1We used the source and sink lists for Android 4.2 in the SuSi public
repository under the directory SourceSinkLists/Android 4.2/
SourcesSinks.
We initially seeded the ADI with the AOSP version 4.0.3,
and veriﬁed the core based on this version. We have since
upgraded our model to Android 4.4.3. This process included
reviewing changes to classes in our core 550 classes between
these versions; and accounting for and verifying any changes in
the ADI. This process required one person-week of work, for
an experienced Java and Android developer. For the update, the
rest of the ADI classes were copied over from AOSP 4.4.3, and
accurate analysis stubs were created for native methods. This
process required another person-week. We expect the update
process for our ADI to continue to be relatively fast since
there are few changes to the core of Android between version
updates; historically new implementation has been contained
in new packages.
E. Harness
Each analyzed application must be hooked into the ADI
via a harness. In its ﬁrst pass, DroidSafe generates this harness
method automatically. DroidSafe scans the application source
code for all classes that subclass one of Android’s four com-
ponent types. It instantiates objects in the harness for all such
classes found. We cannot rely solely on the Android manifest
for the complete list of components, since the manifest is
required to list only components that are exported and available
to other applications. We represent each component with a
single heap object
to account for the complexities of the
Android component memory model (see Section II-A). In our
harness, each instantiated component object is passed to the
appropriate runtime method to exercise all of its life-cycle
events. The harness method is wrapped in a loop; the loop
is present to capture all possible orderings for callbacks that
are called in the harness.
Though details are beyond the scope of this paper, the
harness also includes instantiation of GUI objects deﬁned
in XML resources (including programmatically setting their
attributes, and registering event handlers, such as onClick), and
the incorporation of String values deﬁned in XML resources.
V. OBJECT-SENSITIVE POINTS-TO ANALYSIS
Points-to analysis (PTA) is a foundational static program
analysis that computes a static abstraction of all the heap
locations that a pointer (reference) variable may point to during
program execution. In addition to the points-to relation, points-
to analysis also constructs a call graph as modern languages re-
quire points-to results to calculate targets for dynamic dispatch
and functional lambda calculations. Our goal was to employ
much of the AOSP Android API implementation without mod-
iﬁcation, and achieve precise results for our client analyses.
However, as with many static analyses there is a trade-off
between scalability and precision; appropriate control-ﬂow and
data-ﬂow abstractions must be chosen to avoid intractability
and to calculate acceptably precise results.
Let us consider the difﬁculties of analyzing complex Java
code with precision. Figure 2 lists simpliﬁed ADI source code
for two commonly used classes in the Android API: android
.os.Bundle and java.util.HashMap. Bundle allocates a
HashMap. The example also provides relevant code for two
Android activities that each create a Bundle and store values
to their Bundle; Activity1 puts non-sensitive data in its
7
Fig. 2. Example source code for our ADI and two Activity objects illustrating the challenges of points-to and information ﬂow analysis.
Bundle while Activity2 puts sensitive data in its Bundle.
Consider the difﬁculty presented to an analysis given this code.
To precisely separate the two Bundle objects created ( N(cid:13) and
S(cid:13)), a PTA must separate multiple levels of allocations started
at each Bundle allocation (Bundle allocates a HashMap, H(cid:13),
which allocates an array to store entries, T(cid:13)). In other words,
an analysis must be able separate analysis facts between the
array of entries created in the two HashMaps objects of the
two Bundle objects in this code. Otherwise, sensitive data put
in one Bundle is conﬂated with data that can be retrieved from
the other Bundle, decreasing precision.
Our PTA algorithm is based on a whole-program, ﬂow-
insensitive, subset-based foundation [25] for Java on which
we have added context sensitivity. Context sensitivity is a
general approach where a PTA is able to separate analysis
facts for a method m that arise at multiple call sites of m.
There are multiple choices for context, and the DroidSafe
PTA implements object sensitivity. Accumulating evidence
demonstrates that object sensitivity is the best choice for
object-oriented languages [18, 26–28].
Object sensitivity is notoriously difﬁcult to understand and
implement [18]. Here we give the reader an intuitive descrip-
tion of object sensitivity and its scalability challenges. For a
rigorous description of object sensitivity see [18] (note that our
PTA implements a 3Full+2Heap analysis modiﬁed as described
below). An object-sensitive analysis uses object allocation sites
(new expressions in Java) as context elements. In our analysis,
a heap object, o, is represented by the allocation site of o, plus
the allocation site of the object that allocated o, and so on,
to a parameterized depth, k. For a given method, our analysis
is able to separate facts depending on the heap object of the
receiver on which the method is called.
Considering again the example in Figure 2, our analysis is
able to separate analysis facts calculated for the array table of
two HashMap objects allocated from the two Bundle objects.
When the Bundle objects are created on line 3 and line
4 of Activity1 and Activity2, respectively, a series of
allocations is performed via constructors. The object-sensitive
heap abstraction will have two separate elements representing
the two table arrays, with context being their allocation
history:
(cid:104) T(cid:13) ← H(cid:13) ← N(cid:13)(cid:105)
(cid:104) T(cid:13) ← H(cid:13) ← S(cid:13)(cid:105)
Where a ← b denotes “a allocated in b”.
The new expression on line 3 of Activity1 creates a
heap object (cid:104) S(cid:13)(cid:105), and the cascading allocations from the
constructors of Bundle and HashMap create (cid:104) H(cid:13) ← S(cid:13)(cid:105) and
(cid:104) T(cid:13) ← H(cid:13) ← S(cid:13)(cid:105), respectively.
When the Bundle.put(...) method of Activity2 is
called (line 5), the method context (receiver) for the call is
(cid:104) S(cid:13)(cid:105), this triggers a call to HashMap.put(...) (line 7 of
HashMap) with context (cid:104) H(cid:13) ← S(cid:13)(cid:105). In this context, the points-
to set result for the reference to the ﬁeld table on line 7 of
HashMap is the array object (cid:104) T(cid:13) ← H(cid:13) ← S(cid:13)(cid:105). Any elements
placed in this array via the assignment of line 7 will only be
reﬂected in this array heap object.
Thus, for the example, our PTA is able to separate analysis
facts between the two Bundle objects in the two Activities via
deep object-sensitivity. For this example, the analysis requires
a heap context depth of 3 (to distinguish (cid:104) T(cid:13) ← H(cid:13) ← N(cid:13)(cid:105)
from (cid:104) T(cid:13) ← H(cid:13) ← S(cid:13)(cid:105)).
Object sensitivity has powerful precision but scalability
presents a challenge. Our example requires a depth of 3, and
other commonly used classes require deeper depths, e.g., in
the AOSP implementation, Intent allocates a Bundle (that
allocates a HashMap...) requiring a depth of 4 to disambiguate
8
package android.os;public class Bundle ... {  private Map mMap = new HashMap();      public void put(String k, Object v) {    mMap.put(k,v);  }  public Object get(String k) {    return mMap.get(k);  }}package java.util;public class HashMap... {  private Entry[] table = new Entry[size];  public void put(K key, V value) {    ...    table[index] = new Entry(key, value);   }  public V get(Object key) {    ...    e = table[indexFor(hash, table.length)];    ...    return e;  }}public class Activity2 extends Activity {  ...  double sensitive = location.getLatitude(); //source  Bundle bundle2 = new Bundle();   bundle2.put("data", sensitive);  ...  sink(bundle2);  //flow of sensitive -> sink}public class Activity1 extends Activity {  ...  Bundle bundle1 = new Bundle();   bundle1.put("data", );  ...  sink(bundle1);  //not a sensitive flow}Android Device Implementation (ADI) Android Application Source Code 1234567891011121312345678910111213141516123456712345678NSHTEthe items placed in the Bundle of two Intent objects. We
tested other whole-program object-sensitive frameworks, but
found they could not scale to the required context depth [29]
or did not maintain program information required for our
client [18].
analysis analyzes m without context, conﬂating the analysis
results of all calls to m on objects of c. For information-ﬂow
analysis, this relaxation means that, in m, if a sensitive taint
ﬂows to a ﬁeld f of an object of a class c, the taint will
(imprecisely) ﬂow to f for all heap objects of class c.
To solve this scalability challenge, our points-to analysis
implementation operates on the pointer assignment graph
(PAG) representation of the program [30], an explicit represen-
tation of the program. In the past, while explicit implementa-
tions provided the fastest running times, they would typically
exhaust main memory for large programs [29, 31]. However,
today, with the large and increasing size of available main
memory, we found that an explicit implementation can now
scale to large programs.
Furthermore, our implementation is ﬂexible and parameter-
ized. This ﬂexibility enables us to implement a series of client
analysis-speciﬁc and Android-speciﬁc optimizations of our
object-sensitive points to analysis. Without our optimizations 3
of the 24 APAC applications (see Section VIII) could not ﬁnish
analysis in DroidSafe given a limit of 64GB of heap memory.
With optimizations, all applications now run in under 34GB of
heap memory. The optimizations provide a savings of 5.1x in
total analysis time. We highlight the important optimizations
here.
A. Selectively Applying Context
Typically, a points-to analysis keeps the same base context
depth for all allocated objects. Initially, we tried this policy, at
a depth of 3, for the applications in our APAC suite. However,
our analysis would fail on 3 of our APAC applications because
it exhausted 64GB of allocated heap memory. Instead we
implement a targeted approach: we add context for an abstract
heap location at the minimum depth that is required to achieve
precision for one of our client analyses. The depth of context
on abstract heap objects varies from 0 to 4. The context depth
is calculated based on the following.
By analyzing a suite of 211 Android applications for which
we had source, we learned which API classes from our ADI
could be analyzed content-insensitively without signiﬁcant loss
of precision for clients of the PTA. We performed our points-to
analysis on our suite, and determined API classes that could
never reach (via a series of local or ﬁeld references) a String
value our Intent resolution analysis was tracking, and could
never reach a value that was tainted with sensitive information
ﬂow (across all Android applications in our suite).
This set, S, contains 1489 Android API classes. Most of
these classes are Android GUI objects and libraries through
which sensitive data should never ﬂow. For all c ∈ S, our
clients analyses will calculate the same results regardless of
whether an object of c in the heap abstraction of our PTA has
context or not (for the 211 Android applications analyzed).
This set represents 26% of the total classes of our ADI. We
extrapolate that context-insensitivity analyzing the classes of
S in our will give us an acceptable loss of precision across all
Android applications.
Conversely with a maximum context depth of 3, our points-
to analysis is unable to disambiguate many important analysis
facts. For example, we could not disambiguate the Bundle
between separate Intent objects (as discussed above). To
address this issue, we automatically increase the context depth
to 4 for all heap objects of Array type. In the example of