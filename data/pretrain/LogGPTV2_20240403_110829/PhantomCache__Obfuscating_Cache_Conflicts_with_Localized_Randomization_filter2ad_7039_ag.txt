on the system conﬁguration. Consider a system using r-degree
PhantomCache, an m-way set associative cache, and physical
addresses with t-bit tags and i-bit index bits.
Logic overhead. The logic overhead in LLC mostly stems
from the mapping logic. The mapping function contains a
hash with 2 × t × i 2-input AND gates and (t + 2 × i) 2-
input XOR gates (Figure 5). Thus, all r mapping units contain
r × (t + 2× t× i + 2× i) 2-input gates, consisting of r × t× i
AND gates and r × (t × i + t + 2i) XOR gates.
Under our default LLC with t = 44, i = 14, m = 16,
and r = 8, the total logic overhead is 10,432 2-input gates.
Speciﬁcally, it includes 4,928 AND gates and 5,504 XOR gates.
In terms of gate equivalent (GE), an AND gate typically has
the same size as 1.5 NAND gates and an XOR gate typically
has the same size as 2 NAND gates. The logic overhead of the
mapping function is around 18,400 GEs.
The logic overhead of PhantomCache is less than two times
of the logic overhead of 128-bit AES encryption, which is
around 10,000 GEs [4]. This is considered affordable in modern
CPUs.
Storage overhead. PhantomCache needs extra storage space
for salts, cache set indices, and LFSR state values. The r salts
take up r× (t + i) bits, the r cache set indices take up r× i bits,
and the t state values take up t× i bits. Using our default LLC
with t = 44, i = 14, and r = 8, the extra storage overhead is
only 1,192 bits (149 bytes). Besides, each cache line stores
an extra (cid:100)log2 r(cid:101)-bit random number for indexing salts. When
r = 8, it takes up 3 bits and introduces around 0.50% storage
overhead per cache line.
J. Energy Overhead
Energy overhead is a major concern of PhantomCache
because it multiplies the number of requests in every access.
The energy consumption of a cache is mainly composed of two
parts: static power and dynamic power. Static power is generally
referred as leakage power of the cache and dynamic power is
consumed when the cache is accessed [7]. PhantomCache only
affects the dynamic power of LLC because it only increases the
cache activity during cache access. Regarding dynamic power,
PhantomCache is similar to a normal set-associative cache with
an r times higher associativity. We evaluate the case of 16MB,
8-bank, 16-way LLC with 8 candidate sets and compare it with
a baseline LLC with no candidate sets.
15
bwavescactuBSSNcam4deepsjengexchange2fotonik3dgccimagicklbmleelamcfnabomnetppperlbenchpop2romswrfx264xalancbmkxzAverage90919293949596979899100101102103104105106Normalized IPC (%)IPCMPKIMiss RateMix0Mix1Mix2Mix3Mix4Mix5Mix6Mix7Mix8Mix9Average90919293949596979899100101102103Normalized Metrics (%)(a) 4-core CPU, 8 MB LLC, 2-channel DRAMIPCMPKIMiss RateMix0Mix1Mix2Mix3Mix4Mix5Mix6Mix7Mix8Mix9Average90919293949596979899100101102103Normalized Metrics (%)(b) 8-core CPU, 16 MB LLC, 2-channel DRAMIPCMPKIMiss RateTABLE IV.
POWER CONSUMPTION OF PHANTOMCACHE IN
COMPARISON WITH BASELINE USING A 16 MB 8-BANK, AND 16-WAY LLC.
PHANTOMCACHE USES 8 CANDIDATE SETS.
LLC
Baseline
PhantomCache
Power Consumption (watt)
static power
7.69
7.91
dynamic power
1.21
6.97
overall power
8.89
14.87
We use Xilinx Vivado 2018.2 [14] to estimate static energy
overhead of PhantomCache. Without loss of generality, we
choose the device xc7k325tffg676 of the Xilinx Kintex-7 family
as an instance. The static energy overhead arises from the
mapping circuit PhantomCache introduces for mapping an
address to r candidate sets. The static power consumption
of the introduced mapping circuit is only 0.22 W (r = 8),
which is marginal in comparison with 7.69 W consumed by
the entire baseline 8-bank LLC. Note that the analysis using
Xilinx Vivado emulates an FPGA while PhantomCache is to
be implemented on an ASIC. This means that the estimation
result is an overestimation.
We then use CACTI 6.0 [31] to estimate dynamic energy
overhead of PhantomCache. To estimate the dynamic power
consumption of PhantomCache, we use CACTI to evaluate
the energy consumption of read and write operations in a
128-way set-associative LLC. It depends on two factors. One
is the respective power consumption of a single read or
write access. The other is the respective count of read or
write accesses generated by a benchmark. In general, more
accesses consumer more power for any LLC including both the
baseline and PhantomCache. Since PhantomCache performs
each read access by searching all r candidate sets, the more read
accesses a benchmark contains, the more power PhantomCache
consumes than the baseline does. Based on the performance
measurement in Section VII-G, we use ten mixed workloads
with each includes 1-billion instructions from 8 randomly
selected benchmarks. They are sufﬁciently generic in terms
of both diversity and scale. In total, these workloads generate
51,686,150 read accesses and 34,842,011 write accesses over
the baseline LLC. For PhantomCache, the number of read
accesses is 51,844,724 and the number of write accesses is
34,701,023. It introduces 0.31% more read accesses and 0.40%
less write accesses. On average, a mixed workload consumes
1.21 W on the baseline LLC and 6.97 W on PhantomCache.
Table IV summarizes the power consumption of Phan-
tomCache in comparison with the baseline. PhantomCache
consumes 67.27% more power than the baseline LLC.
This result is counterintuitive because it seems that Phan-
tomCache should have consumed multiple times of energy. Two
reasons may account for the result. First, the extra requests
produced by PhantomCache only access the tag array in the
cache to search for the target block while data array is not
accessed. Second, the static power of PhantomCache remains
nearly the same as the traditional cache, which mitigates the
impact of increased dynamic power.
VIII. CONCLUSION
We have studied the idea of exploiting localized random-
ization against conﬂict-based cache timing attacks. It proves
to have the same strong defense effect as global randomiza-
tion countermeasures and avoids the inefﬁcient mechanisms
in preceding global randomization designs such as random
replacement and dynamic remapping. We implement localized
randomization through PhantomCache. The analysis of its
security shows that the attacker cannot successfully launch
a conﬂict-based cache timing attack within 100 years when the
degree of PhantomCache is set to 8. Finally, we implement
PhantomCache using ChampSim and the evaluation shows that
PhantomCache only brings a 0.50% performance degradation
and affordable hardware overhead.
ACKNOWLEDGMENT
The work is supported in part by The Natural Science Foun-
dation of Zhejiang Province under Grant No. LY19F020050, Na-
tional Natural Science Foundation of under Grant No. 61772236,
Zhejiang Key R&D Plan under Grant No. 2019C03133, Alibaba-
Zhejiang University Joint Institute of Frontier Technologies,
Research Institute of Cyberspace Governance in Zhejiang
University, and Leading Innovative and Entrepreneur Team
Introduction Program of Zhejiang. We would like to sincerely
thank NDSS 2020 Chairs and Reviewers for their review
efforts and helpful feedback. All the thoughtful and constructive
comments have guided us toward a much higher paper quality.
We would also like to extend our gratitude to Bowen Huang
and Seetal Potluri for insightful discussions on PhantomCache
performance. Finally and foremost, Kai Bu wholeheartedly
appreciates all the students from the Computer Architecture
classes for their support and encouragement.
REFERENCES
[1]
[2]
“The champsim simulator. https://github.com/champsim/champsim.”
“Intel digital random number generator (drng) software implementa-
tion guide. https://software.intel.com/en-us/articles/intel-digital-random-
number-generator-drng-software-implementation-guide.”
“Spec cpu2017 home page: www.spec.org/cpu2017.”
[3]
[4] S. Banik, A. Bogdanov, and F. Regazzoni, “Exploring energy efﬁciency
of lightweight block ciphers,” in International Conference on Selected
Areas in Cryptography. Springer, 2015, pp. 178–194.
[5] D. J. Bernstein, “Cache-timing attacks on aes,” 2005.
[6] D. J. Bernstein, T. Lange, and P. Schwabe, “The security impact of a
new cryptographic library,” in Latincrypt, 2012, pp. 159–176.
[7] S. Chakraborty, D. Deb, D. Buragohain, and H. K. Kapoor, “Cache
capacity and its effects on power consumption for tiled chip multi-
processors,” in 2014 International Conference on Electronics and
Communication Systems (ICECS).
IEEE, 2014, pp. 1–6.
[9]
[8] A. Chen, W. B. Moore, H. Xiao, A. Haeberlen, L. T. X. Phan, M. Sherr,
and W. Zhou, “Detecting covert timing channels with time-deterministic
replay.” in OSDI, 2014, pp. 541–554.
J. Chen and G. Venkataramani, “Cc-hunter: Uncovering covert timing
channels on shared processor hardware,” in MICRO, 2014, pp. 216–228.
J. Daemen and V. Rijmen, “Aes proposal: Rijndael,” 1999.
[10]
[11] P. Damaschke, “Threshold group testing,” in General theory of informa-
tion transfer and combinatorics, 2006, pp. 707–718.
[12] P. Deepthi and P. Sathidevi, “Design, implementation and analysis
of hardware efﬁcient stream ciphers using lfsr based hash functions,”
Computers & Security, vol. 28, no. 3-4, pp. 229–241, 2009.
[13] H. Fang, S. S. Dayapule, F. Yao, M. Doroslovaˇcki, and G. Venkataramani,
“Prefetch-guard: Leveraging hardware prefetches to defend against cache
timing channels,” in HOST, 2018, pp. 187–190.
[14] T. Feist, “Vivado design suite,” White Paper, vol. 5, p. 30, 2012.
[15] D. Gruss, J. Lettner, F. Schuster, O. Ohrimenko, I. Haller, and M. Costa,
“Strong and efﬁcient cache side-channel protection using hardware
transactional memory,” in USENIX Security Symposium, 2017, pp. 217–
233.
16
[16] D. Gruss, R. Spreitzer, and S. Mangard, “Cache template attacks:
Automating attacks on inclusive last-level caches.” in USENIX Security
Symposium, 2015, pp. 897–912.
[17] G. Hamerly, E. Perelman, J. Lau, and B. Calder, “Simpoint 3.0: Faster
and more ﬂexible program phase analysis,” Journal of Instruction Level
Parallelism, vol. 7, no. 4, pp. 1–28, 2005.
[18] Z. He and R. B. Lee, “How secure is your cache against side-channel
attacks?” in Proceedings of the 50th Annual IEEE/ACM International
Symposium on Microarchitecture. ACM, 2017, pp. 341–353.
[19] G. Irazoqui, T. Eisenbarth, and B. Sunar, “Cross processor cache attacks,”
in Proceedings of the 11th ACM on Asia conference on computer and
communications security. ACM, 2016, pp. 353–364.
[20] H. Krawczyk, “Lfsr-based hashing and authentication,” in CRYPTO,
1994, pp. 129–139.
[21] D. Levinthal, “Performance analysis guide for intelr core (tm) i7
processor and intel xeon (tm) 5500 processors,” Intel Performance
Analysis Guide, 2009.
[22] M. Lipp, D. Gruss, R. Spreitzer, C. Maurice, and S. Mangard, “Armaged-
don: Cache attacks on mobile devices.” in USENIX Security Symposium,
2016, pp. 549–564.
[23] F. Liu, Q. Ge, Y. Yarom, F. Mckeen, C. Rozas, G. Heiser, and R. B.
Lee, “Catalyst: Defeating last-level cache side channel attacks in cloud
computing,” in HPCA, 2016, pp. 406–418.
[24] F. Liu and R. B. Lee, “Random ﬁll cache architecture,” in MICRO, 2014,
pp. 203–215.
[25] F. Liu, H. Wu, K. Mai, and R. B. Lee, “Newcache: Secure cache
architecture thwarting cache side-channel attacks,” IEEE Micro, vol. 36,
no. 5, pp. 8–16, 2016.
[26] F. Liu, Y. Yarom, Q. Ge, G. Heiser, and R. B. Lee, “Last-level cache
side-channel attacks are practical,” in S&P, 2015, pp. 605–622.
[27] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V. J. Reddi, and K. Hazelwood, “Pin: building customized
program analysis tools with dynamic instrumentation,” in Acm sigplan
notices, vol. 40, no. 6, 2005, pp. 190–200.
[28] R. Martin, J. Demme, and S. Sethumadhavan, “Timewarp: rethinking
timekeeping and performance monitoring mechanisms to mitigate side-
channel attacks,” ACM SIGARCH Computer Architecture News, vol. 40,
no. 3, pp. 118–129, 2012.
[29] C. Maurice, N. Le Scouarnec, C. Neumann, O. Heen, and A. Francillon,
“Reverse engineering intel last-level cache complex addressing using
performance counters,” in International Workshop on Recent Advances
in Intrusion Detection. Springer, 2015, pp. 48–65.
[30] C. Maurice, M. Weber, M. Schwarz, L. Giner, D. Gruss, C. A. Boano,
S. Mangard, and K. R¨omer, “Hello from the other side: Ssh over robust
cache covert channels in the cloud,” NDSS, 2017.
[31] N. Muralimanohar, R. Balasubramonian, and N. P. Jouppi, “Cacti 6.0:
A tool to model large caches,” HP laboratories, vol. 27, p. 28, 2009.
[32] K. Olukotun, T. Mudge, and R. Brown, “Performance optimization of
pipelined primary cache,” in ISCA, 1992, pp. 181–190.
[33] Y. Oren, V. P. Kemerlis, S. Sethumadhavan, and A. D. Keromytis,
“The spy in the sandbox: Practical cache attacks in javascript and their
implications,” in CCS, 2015, pp. 1406–1418.
[34] M. K. Qureshi, “Ceaser: Mitigating conﬂict-based cache attacks via
encrypted-address and remapping,” in MICRO, 2018.
[35] ——, “New attacks and defense for encrypted-address cache,” in ISCA,
2019, pp. 360–371.
[36] A. Seznec, “A case for two-way skewed-associative caches,” 1993, pp.
169–178.
[37] A. Sodani, R. Gramunt, J. Corbal, H.-S. Kim, K. Vinod, S. Chinthamani,
S. Hutsell, R. Agarwal, and Y.-C. Liu, “Knights landing: Second-
generation intel xeon phi product,” IEEE MICRO, vol. 36, no. 2, pp.
34–46, 2016.
[38] V. Varadarajan, T. Ristenpart, and M. M. Swift, “Scheduler-based de-
fenses against cross-vm side-channels.” in USENIX Security Symposium,
2014, pp. 687–702.
[39] B. C. Vattikonda, S. Das, and H. Shacham, “Eliminating ﬁne grained
timers in xen,” in CCSW, 2011, pp. 41–46.
[40] P. Vila, B. K¨opf, and J. F. Morales, “Theory and practice of ﬁnding
eviction sets,” in S&P, 2019.
[41] Y. Wang, A. Ferraiuolo, D. Zhang, A. C. Myers, and G. E. Suh, “Secdcp:
secure dynamic cache partitioning for efﬁcient timing channel protection,”
in DAC, 2016.
[42] Z. Wang and R. B. Lee, “New cache designs for thwarting software
cache-based side channel attacks,” in ISCA, 2007, pp. 494–505.
[43] ——, “A novel cache architecture with enhanced performance and
security,” in MICRO, 2008, pp. 83–93.
[44] M. Weiß, B. Heinz, and F. Stumpf, “A cache timing attack on aes in
virtualization environments,” in FC, 2012, pp. 314–328.
[45] M. Werner, T. Unterluggauer, L. Giner, M. Schwarz, D. Gruss, and
S. Mangard, “Scattercache: Thwarting cache attacks via cache set
randomization,” in USENIX Security, 2019.
[46] M. Yan, B. Gopireddy, T. Shull, and J. Torrellas, “Secure hierarchy-
aware cache replacement policy (sharp): Defending against cache-based
side channel attacks,” in ISCA, 2017, pp. 347–360.
[47] M. Yan, Y. Shalabi, and J. Torrellas, “Replayconfusion: detecting cache-
based covert channel attacks using record and replay,” in MICRO, 2016.
[48] Y. Yarom and K. Falkner, “Flush+ reload: A high resolution, low noise,
l3 cache side-channel attack.” in USENIX Security, vol. 1, 2014, pp.
22–25.
17