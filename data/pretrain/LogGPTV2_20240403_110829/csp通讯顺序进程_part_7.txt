延伸，也就是说，不存在事件x，能使
来的，即在这台机器所有可能的迹中，不存在－个迹是这个迹的
这个迹并没记录机器的损坏。机器的损坏是通过下述事实表现出
X5如果第一位颐客没理睬那条注意事项，邢么VMC的迹可以
决定了。
发生。
2
迄今最重要的迹运算是迹与迹之间的连接，即把一对操作数
在对进程行为进行记录、表述以及正确理解过程中，迹扮演
至于选择哪--个，就要由第一位使月这台售货机的顾客来
f, 0, h 
S, T, U
S，t，#
1.6迹的运算
SAt
表示函数
表示迹的集合
表示迹
---
## Page 46
有不属于4的符号去掉后留下的迹。例如
L9
可由它们推导证明的法则
上逃两项很有用的法则，
7+1
行归纳，即有结果
则说函数了是分配的。所有可分配的函数都是严格的。
则函数被称作是严格的。如果
空迹，即
1.6.2局限
L8
L6
L3
以下法则是很显然的，而且非常有用
L2
=<>
设n为-自然数，我们定义t"为t的n次自相连接。对n进
s（)=（s)
表达式（t}A)长示迹局限于集合A中的符号，即把中所
假设为迹到迹之间的函数。如果它对空迹的作用结果仍为
s=<>=<>^===S
连接的最重要的性质是，连接是结合的，且其单位元素为<>。
<>=
^=
^=
{up,down} =
f(st)=f(s)f(t)
实际上就是定义本身：以下是另外两个
f()=s)=x
这两个运算对空序列无定义。
的结果记为s"。
1.6.3首郡与尾部
6
纳，就能严格证明这几项法则
个迹受限于这两个集合的交集的结果相同。对迹的长度进行归
号集的结果是一个空迹，连续受限于两个集合的迹的结果就跟这
以下是关于局限与集合运算间的关系的法则。一个迹局限于空符
接起来，就可得到我们所要的结果。例如，如果x≠y
我们总可以使它分别作用于序列的每个元素。然后把各项结果连
么这个函数也就唯一地确定了。因为当它作用于更长的序列时，
一个可分配的函数，如果定义了它对单元素序列的作用效果，那
L<>A=<>
局限运算是可分配的，因此也是严格的，有法则
L2
s }=
(^s)=S
假设s为一非空序列，取它的第一个符号记为s，去掉后
A=
(s}A)}B=S(A!B)
↑A=
对于单元案序列，显然有
(S)A(SA)(A)
[x}(v)={x}
如
=
=
=(x})(x})(x})
如果yA
如果x∈A
'=
=x
>
由L2
由L3,4
---
## Page 48
并且说8是的-·个前缀。例如
{(V)<>==*
个扩展序列，使s^u=t。因此，我们定义一种次序关系
下一法则可作为A*的-·个递归定义。
这些法很有力，足以确定一个迹是否是A*的一个元素。例如，
可引出--个简单定义
的集合。因此，当局限于A时，这些迹都保持不变。由这一事实
1.6.5次序
如果x∈A且yA，则有
G
5
以下法则是这个定义的推论。
1.6.4星号
((=sV=s)/^=1=s)=1=s 
L3
L3
(St)∈A*=S∈A*AtEA*
<>∈A
我们定义集合A*是由A中符号构成的所有有穷迹（包括<>)
假设&是序列t的-个初始子序列，则我们总能找到s的某
法则L4给出证明两个迹相等的简便方法。
=（<>s')
∈A*=(^)∈A*
x=
≤
s≤t=(3u,s^=t)
如果s≠<>
=false
=(∈A*)A(∈A*)
A*={s|sA=s}
=trueAfalse
由L2
由L3
---
## Page 49
定义长度运算井的法则如下
1.6.6长度
对所有自变量均为单调的函数称为单调函数。
L9t≤u→(s)≤(su)
另一个自变量不变）。
[8 s≤t>(sA)≤(tA)
所有可分配的函数都是单调函数，例如
这个关系也是个偏序关系，满足上述L1至L4。它还满足下述法则
一个）是单调的。
一个二元函数对它的两个自变量中的一个可能是单调的（这时合
是说
L7
sint；定义记为
对一给定序列，它的前缀是全序的。
L5（^s)≤t=t≠<>Ax=tAs≤t
下一法则与L1并用，给出计算s≤是否成立的方法。
4.6
nsenVs
G
26
(^s)in t=t≠A((t=xAs≤t)V(^s)in t)
称迹到迹的函数f是单调的，如果它保持次序关系≤，也就
假设S为的--个子序列（不一定是初始子序列)，我们就说
迹的长度记做#。例如
如法则L1至L4所逃，关系≤是个偏序关系，其最小元为<>。
SMS
=3
如果有s≤
传递性
反对称性
自反性
最小元
---
## Page 50
append(s, t)=if s= NIL then t
函数是由下述递归式给出定义的
我们用大家熟悉的append 函数来实现一般的连接运算。append
和尾部是由原函数car和cdr给出的
其含义为 cons("COIN,cons("CHOC,NIL))
表事件的原子组成的表就能容易地把迹表示出来。
级的表加工语言。有幸的是，LISP 就能 满足我们的需要。用代
符号×在迹8中出现的次数定义为
L6.#(t")=nx(#t)
A中符号在t中出现的个数为#（A)。
14
迹的运算可如表的函数一样实施。例如，
“#"∧#
(())#-（#+(#=（（))#
#=（#s)+（#t)
为了在计算机内表示迹并实施对它的运算，我们需要一种高
#=
#<>=
else cons(car(s),append(edr(s),t))
="(COIN,CHOC)
s^t=append(s,t)
^s=cons(x,s)
 = cons("COIN,NIL)
1.7迹的实施
<>=NIL
s↓x=#(s{x})
t'=cdr(t)
t=car(t)
一个非空表的首部
2
---
## Page 51
LISP的append 函数的计算终止性由以下事实保证，即每次递归
这个定文的正确性出下逃法则为依据
isprefix(s,t)=if s = NIL then true 
据1.6.5节的L1和L5这个函数可定义为
来实现，（s卜B）可由下列函数实现
身，检验(x∈B)可通过调用函数
自变量的类似特性也保证以下定义的其它运算实施的正确性。
调用时用作第一个自变量的表都要比它前一级递归调用时的短。
数 traces(P),
而，进程P的所有可能的迹的至集是能事先知道的，我们定义函
来：这个选择就要由不受进程约束的外部环境因素来决定了。然
记录。进程开始前，谁也不知道进程的哪个可能的迹将被记录下
restrict(s,B) = if s = NIL then NIL
为实施局限运算，我们用有限集合B的元素的表代表B本
28
检验（s≤t)可由给出结果是true或false的函数来实现：根
ismember(x,B) = if B = NIL then false
在1.6节中，进程的迹是进程到某个时刻为止的行为的顺序
else if t = NIL then false
else if ismember(car(s),B)
，用它可产生这个集合。
else if x = car(B)then true
else car(s) = car(t) Aisprefix(cdr(s),cdr(t))
=<>
<>=
else restrict(cdr(s),B)
then cons(car(s),restrict(cdr(s),B))
1.8进程的迹
else ismember(x,cdr(B))
s<>
---
## Page 52
把这三项法则归结为选择算子必须遵从的一项一般法则，即
L3 traces(c→P|d-→Q)= 
对初始事件有选择的进程的行为的迹，！
L4 
L2 traces(c→P)={t|t=V(to=cAt'∈+races(P))}
迹以c开始，这个迹的尾部也必须是P的一个可能的迹，故有
动作的时刻，<>都是它的行为的一个迹。（c→P)的每个非
空迹是（c→P)的一个迹，因为每个进程，到它开始实行第一个
L1 traces(STOP)={t[t=}={}
号不变。如前所逝，进程STOP只有一个迹，则有
X4对一台简单自动售货机，
的，其迹的集合却是无穷的。
就象很多非常有趣的逃程一样，尽管这个进程的每个迹都是有限
X3
X2在接受--枚硬币后就毁坏的机器只能有两个迹
察员的笔记本只好永远是空白，即
X1进程STOP的行为只有·一个迹，即<>。记录这个进程的观
1.8.1
traces(μX,coin-choc-→X)=[s| n,s≤}
traces(x:B-P(x))={t|t=<>
在这一节里，我们讲讲如何计算进程的迹的集合，使用的记
traces(μX,tick→X)={<>，,.….)}
只是滴嗒地走着的钟，它的迹是
举例
1法则
{t|t=<>V(t=cAt'∈traces(P))V
-{<>}U{<>t|∈traces(P)}
traces(STOP)={}
(to=dAt'∈traces(Q))}
=[tick}*
有
一定为儿种可能的迹之一
3