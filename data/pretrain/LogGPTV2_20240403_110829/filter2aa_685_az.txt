.nim file.
The renderTimeline procedure, shown next, is also fairly straightforward, even
though it takes two parameters. Add this procedure to the bottom of general.nim, and
make sure that you also import "../database" and user at the top of the file.
#proc renderTimeline*(username: string, messages: seq[Message]): string =
#
result = ""
${$!username}'s timeline
New message
Listing 7.23
The implementation of renderLogin
Listing 7.24
The implementation of renderTimeline
Login
Figure 7.16
The rendered login page
Licensed to   
209
Developing the web application’s view
${renderMessages(messages)}
#end proc
The preceding implementation is fairly simple. It first creates a  tag that holds
the title, and then a  tag that allows the user to tweet a new message. Finally, the
renderMessages procedure defined in the user module is called.
 For completeness, here’s the full general.nim code.
#? stdtmpl(subsChar = '$', metaChar = '#')
#import "../database"
#import user
#import xmltree
#
#proc `$!`(text: string): string = escape(text)
#end proc
#
#proc renderMain*(body: string): string =
#
result = ""
Tweeter written in Nim
${body}
#end proc
#
#proc renderLogin*(): string =
#
result = ""
Login
Please type in your username...
#end proc
#
#proc renderTimeline*(username: string, messages: seq[Message]): string =
Listing 7.25
The final code of general.nim
The $! operator is
used here to ensure
that username is
escaped.
The renderMessages 
procedure is called, and its 
result is inserted into the 
generated HTML.
Licensed to   
210
CHAPTER 7
Building a Twitter clone
#
result = ""
${$!username}'s timeline
New message
${renderMessages(messages)}
#end proc
With that, the view components are complete, and Tweeter is very close to being fin-
ished. All that’s left is the component that ties the database and views together. 
7.5
Developing the controller
The controller will tie the database module and the two different views together.
Compared to the three modules you’ve already implemented, the controller will be
much smaller. The bulk of the work is now essentially behind you.
 You’ve already created a file, tweeter.nim, that implements the controller. Open
this file now, so that you can begin editing it.
 This file currently contains one route: the / route. You’ll need to modify this route so
that it responds with the HTML for the login page. To do so, start by importing the differ-
ent modules that you implemented in the previous section: database, views/user, and
views/general. You can use the following code to import these modules:
import database, views/user, views/general
Once you’ve done that, you can modify the / route so that it sends the login page to
the user’s web browser:
get "/":
resp renderMain(renderLogin())
Save your newly modified tweeter.nim file, and then compile and run it. Open a new
web browser tab and navigate to http://localhost:5000. You should see a login form,
albeit a very white one. It might look similar to figure 7.17.
 Let’s add some CSS style to this page. If you’re familiar with CSS and are confident
in your web design abilities, I encourage you to write some CSS yourself to create a
nice design for Tweeter’s login page.
SHARE YOUR CSS
If you do end up designing your own Tweeter, please share
what you come up with on Twitter with the hashtag #NimInActionTweeter.
I’d love to see what you come up with. If you don’t have Twitter, you can also
post it on the Nim forums or the Manning forums at http://forum.nim-lang
.org and https://forums.manning.com/forums/nim-in-action, respectively.
Licensed to   
211
Developing the controller
If you’re more like myself and don’t have any web design abilities whatsoever, you can
use the CSS available at the following URL: https://github.com/dom96/nim-in-action-
code/blob/master/Chapter7/Tweeter/public/style.css.
 The CSS file should be placed in a directory named public. Create this directory
now, and save your CSS file as style.css. When a page is requested, Jester will check the
public directory for any files that match the page requested. If the requested page
exists in the public directory, Jester will send that page to the browser.
STATIC FILE DIRECTORY
The public directory is known as the static file direc-
tory. This directory is set to public by default, but it can be configured using
the setStaticDir procedure or in a settings block. For more information on
static file config in Jester, see the documentation on GitHub: https://github
.com/dom96/jester#static-files.
Once you’ve placed the CSS file in the public directory, refresh the page. You should see
that the login page is now styled. It should look something like the screen in figure 7.18
(or it may look better if you wrote your own CSS).
 Type in a username, and click the Login button. You’ll see an error message read-
ing “404 Not Found.” Take a look at your terminal and see what Jester displayed there.
You should see something similar to figure 7.19.
 Note the last line, which reads as follows:
DEBUG post /login
DEBUG
404 Not Found {Content-type: text/html;charset=utf-8, Content-Length: 178}
This specifies that an HTTP post request was made to the /login page. A route for the
/login page hasn’t yet been created, so Jester responds with a “404 Not Found” error.
Figure 7.17
The unstyled login form
Licensed to   
212
CHAPTER 7
Building a Twitter clone
7.5.1
Implementing the /login route
Let’s implement the /login route now. Its implementation is short.
post "/login":
setCookie("username", @"username", getTime().getGMTime() + 2.hours)
redirect("/")
Listing 7.26
The /login route
Figure 7.18
The login page
Figure 7.19
Debug information from Jester
Specifies a new POST route on 
the path /login. Any HTTP POST 
requests on /login will activate 
this route, and the code in its 
body will be executed.
Sets a new cookie with a key of
"username" and tells it to
expire in 2 hours. The cookie’s
value is set to the username
that the user typed into the
login box on the front page.
Asks Jester to redirect 
the user’s web browser 
to the front page
Licensed to   
213
Developing the controller
Add the code in listing 7.26 to tweeter.nim, and make sure it’s indented just like the
other route. You’ll also need to import the times module. The preceding code may
seem a bit magical, so let me explain it in more detail.
 The code does two simple things: it sets a cookie and then redirects the user to the
front page of Tweeter.
 A cookie is a piece of data stored in a user’s browser. It’s composed of a key, a
value, and an expiration date. The cookie created in this route stores the username
that was typed in by the user just before the Login button was clicked. This username
was sent together with the HTTP request when the Login button was clicked. It’s
referred to by "username" because that’s the name of the  tag that was created
in the renderLogin procedure. The value of "username" is accessed in Jester using the
@ operator.
 The expiration date of the cookie is calculated using a special + operator that adds
a TimeInterval to a TimeInfo object. In this case, it creates a date that’s 2 hours in the
future. At the end of the code, the route finishes by redirecting the user to the front
page.
 Recompile tweeter.nim, run it, and test it out. You should now be able to type in a
new username, click Login, and see the web browser navigate to the front page auto-
matically. Notice what’s happening in your terminal, and particularly the following
line:
DEBUG post /login
DEBUG
303 See Other {Set-Cookie: username=test; Expires=Wed,
➥02 Mar 2016 21:57:29 UTC, Content-Length: 0, Location: /}
The last line is actually the response that Jester sent, together with the HTTP headers,
which include a Set-Cookie header. Figure 7.20 shows this in action. The cookie is
set, but the user is redirected back to the front page.   
303 See Other 
Set-Cookie: username=test 
Location: / 
username=test 
Figure 7.20
The current login process
Licensed to   
214
CHAPTER 7
Building a Twitter clone
7.5.2
Extending the / route
The cookie is set, but the user is still shown the front page without actually being
logged in. Let’s fix that. The following listing shows a modified version of the / route
that fixes this problem.
let db = newDatabase()
routes:
get "/":
if request.cookies.hasKey("username"):
var user: User
if not db.findUser(request.cookies["username"], user):
user = User(username: request.cookies["username"], following: @[])
db.create(user)
let messages = db.findMessages(user.following)
resp renderMain(renderTimeline(user.username, messages))
else:
resp renderMain(renderLogin())
Modify tweeter.nim by replacing the / route with the code in listing 7.27. Then recom-
pile and run Tweeter again. Navigate to http://localhost:5000, type test into the
Login text box, and click Login. You should now be able to see test’s timeline, which
should look similar to the screenshot in figure 7.21.
 Congratulations, you’ve almost created your very own Twitter clone!
Listing 7.27
The / route
Creates a new database instance that will open the 
database saved in tweeter.db. This is done inside a 
global variable so that every route can access it.
Checks if the cookie has been set
Checks if the username
already exists in the
database
If the username doesn’t exist 
in the database, creates it
Retrieves the messages posted 
by the users that the logged-in 
user is following
Uses the renderTimeline
procedure to render the
user’s timeline, and then
passes the result to
renderMain, which returns a
fully rendered web page
If the cookie isn’t set,
shows the login page
Figure 7.21
A simple timeline
Licensed to   
215
Developing the controller
7.5.3
Implementing the /createMessage route
Let’s keep going. The next step is to implement the tweeting functionality. Clicking
the Tweet button will try to take you to the /createMessage route, resulting in another
404 error.
 The following listing shows how the /createMessage route can be implemented.
post "/createMessage":
let message = Message(
username: @"username",
time: getTime(),
msg: @"message"
)
db.post(message)
redirect("/")
This route initializes a new Message and uses the post procedure defined in the data-
base module to save the message in the database. It then redirects the browser to the
front page.
 Add this code to the bottom of your routes. Then recompile, run Tweeter, and nav-
igate to http://localhost:5000. After logging in, you should be able to start tweeting.
Unfortunately, you’ll quickly notice that the tweets you create aren’t appearing. This is
because your username isn’t passed to the findMessages procedure in the / route.
 To fix this problem, change let messages = db.findMessages(user.following)
to let messages = db.findMessages(user.following & user.username). Recom-
pile and run Tweeter again. You should now be able to see the messages you’ve cre-
ated. Figure 7.22 shows an example of what that will look like.   
Listing 7.28
The /createMessage route
Figure 7.22
A timeline 
with messages
Licensed to   
216
CHAPTER 7
Building a Twitter clone
7.5.4
Implementing the user route
The username in the message is clickable; it takes you to the user page for that specific
username. In this example, clicking the test username should take you to
http://localhost:5000/test, which will result in a 404 error because a route for /test
hasn’t yet been created.
 This route is a bit different, because it should accept any username, not just test.
Jester features patterns in route paths to support such use cases. The following listing
shows how a route that shows any user’s timeline can be implemented.
get "/@name":
var user: User
if not db.findUser(@"name", user):
halt "User not found"
let messages = db.findMessages(@[user.username])
resp renderMain(renderUser(user) & renderMessages(messages))
Add the route in listing 7.29 into tweeter.nim, recompile, run Tweeter again, and nav-
igate to the front page: http://localhost:5000/.
 You’ll note that the page no longer has any style associated with it. What hap-
pened? Unfortunately, the route you’ve just added also matches /style.css, and
because a user with that name doesn’t exist, a 404 error is returned.
 This is easy to fix. Jester provides a procedure called cond that takes a Boolean
parameter, and if that parameter is false, the route is skipped. Simply add cond '.'
notin @"name" at the top of the route to skip the route if a period (.) is inside the
value of the name variable. This will skip the route when /style.css is accessed, and it
will fall back to responding with the static file.
 Test this by recompiling tweeter.nim and running it again. You should see that the
stylesheet has been restored when you navigate to http://localhost:5000/. Log in
using the test username, and click on the username in your message again. You
should see something resembling figure 7.23.
Listing 7.29
The user route
Anything that follows the @ character in a 
path is a variable. Jester will activate this 
route when the path is /test, or /foo, or 
/.
Inside the route, the @ operator is used 
to retrieve the value of the "name" 
variable in the path. The User object for 
that username value is then retrieved.
The renderUser procedure is used to render
the timeline of the specified user, and the
renderMessages procedure is then used to
generate the HTML for the user’s messages.
If the user isn’t found, the route finishes
early with the specified message. The halt
procedure is similar to a return.
Licensed to   
217
Developing the controller
7.5.5
Adding the Follow button
There’s one important feature missing from the user’s timeline page. That’s the Fol-
low button, without which users can’t follow each other. Thankfully, the user view
already contains support for it. The route just needs to check the cookies to see if a
user is logged in.
 This operation to check if a user is logged in is becoming common—the / route
also performs it. It would make sense to put this code into a procedure so that it’s
reusable. Let’s create this procedure now. Add the following userLogin procedure
above your routes and outside the routes block, inside the tweeter.nim file.
proc userLogin(db: Database, request: Request, user: var User): bool =
if request.cookies.hasKey("username"):
if not db.findUser(request.cookies["username"], user):
user = User(username: request.cookies["username"], following: @[])
db.create(user)
return true
else:
return false
The userLogin procedure checks the cookies for a username key. If one exists, it reads
the value and attempts to retrieve the user from the database. If no such user exists,
the user will be created. The procedure performs the same actions as the / route.
 The new implementations of the / and user routes are fairly easy. The following
listing shows the new implementation of the two routes.
get "/":
var user: User
Listing 7.30
The userLogin procedure
Listing 7.31
The new implementations of the / and user routes
Figure 7.23
Another user’s 
timeline
Licensed to   
218
CHAPTER 7
Building a Twitter clone
if db.userLogin(request, user):
let messages = db.findMessages(user.following & user.username)
resp renderMain(renderTimeline(user.username, messages))
else:
resp renderMain(renderLogin())
get "/@name":
cond '.' notin @"name"
var user: User
if not db.findUser(@"name", user):
halt "User not found"
let messages = db.findMessages(@[user.username])
var currentUser: User
if db.userLogin(request, currentUser):
resp renderMain(renderUser(user, currentUser) & renderMessages(messages))
else:
resp renderMain(renderUser(user) & renderMessages(messages))
Now the Follow button should appear when you navigate to a user’s page, but clicking
it will again result in a 404 error. 
7.5.6
Implementing the /follow route
Let’s fix that error by implementing the /follow route. All that this route needs to do
is call the follow procedure defined in the database module. The following listing
shows how the /follow route can be implemented.
post "/follow":
var follower: User
var target: User
if not db.findUser(@"follower", follower):
halt "Follower not found"
if not db.findUser(@"target", target):
halt "Follow target not found"
db.follow(follower, target)
redirect(uri("/" & @"target"))