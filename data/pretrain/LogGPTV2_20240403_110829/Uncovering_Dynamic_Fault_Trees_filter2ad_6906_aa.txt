title:Uncovering Dynamic Fault Trees
author:Sebastian Junges and
Dennis Guck and
Joost-Pieter Katoen and
Mari&quot;elle Stoelinga
2016 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
Uncovering Dynamic Fault Trees
Sebastian Junges∗, Dennis Guck†, Joost-Pieter Katoen∗†, Mari¨elle Stoelinga†
∗Software Modeling and Veriﬁcation, RWTH Aachen University, Germany
†Formal Methods and Tools, University of Twente, The Netherlands
Abstract—Fault tree analysis is a widespread industry stan-
dard for assessing system reliability. Standard (static) fault trees
model the failure behaviour of systems in dependence of their
component failures. To overcome their limited expressive power,
common dependability patterns, such as spare management, func-
tional dependencies, and sequencing are considered. A plethora
of such dynamic fault trees (DFTs) have been deﬁned in the
literature. They differ in e.g., the types of gates (elements), their
meaning, expressive power, the way in which failures propagate,
how elements are claimed and activated, and how spare races are
resolved. This paper systematically uncovers these differences and
categorises existing DFT variants. As these differences may have
huge impact on the reliability assessment, awareness of these
impacts is important when using DFT modelling and analysis.
I.
INTRODUCTION
Current innovation in IT systems, like robots, the Internet-
of-Things, autonomous cars, and 3D printing rapidly increase
our dependence on computer-based systems. Reliability engi-
neering is an important ﬁeld that provides methods, tools and
techniques to evaluate and mitigate the risks related to complex
systems. Fault tree analysis (FTA) is one of the most important
techniques in that ﬁeld, and is commonly deployed in industry
ranging from railway and aerospace system engineering to
nuclear power plants. A fault tree (FT) describes how failures
propagate through the system, and how component failures
lead to system failures. An FT is a tree (or rather, a directed
acyclic graph) whose leaves model component failures, and
whose gates model failure propagation. Standard (or: static)
FTs (SFTs) contain a few basic gates, like AND and OR,
making them easy to use and analyse, but also limited in
expressivity. To cater for more complex dependability patterns,
like spare management and causal dependencies, a number of
extensions to FTs have been proposed.
Dynamic Fault Trees (DFTs) [1], [2] are the most common
extension and are widely used. Since the original proposal
by Dugan et al. [1], a plethora of variants of DFTs have
been proposed in the literature. An overview of extensions has
recently been given in [3]. Table I summarises an overview
of the various features of existing DFT dialects1. They differ
in e.g., the types of supported gates (elements) and the way
in which failures propagate. In addition to having different
expressive power, the various DFT dialects provide different
interpretations to syntactically identical DFT models. As the
differences between these interpretations are rather subtle,
they are mostly not recognised. This is highly undesirable,
since it can easily lead to different analysis results and wrong
conclusions about
the system’s reliability—if an FTA tool
interprets a model differently from its user, then one may
1The ﬁrst row indicates the different formalisms used for providing a DFT
semantics, e.g., FTA = Fault Tree Automaton and DBN = Dynamic Bayesian
Network. A detailed account is given in Sect. IV.
conclude that the system meets its dependability requirements,
whereas in reality it does not.
TABLE I.
COMPARING DIFFERENT SEMANTICS FOR DFTS.
FTA CTBN
[4]
[5]
DBN
[6], [7]
SWN
[8]
GSPN
[9]
IMC
[10], [11]
AE
[12], [13]
Spare modules
Dep. events
PAND
POR
SEQ
PDEP
Replication
Evidence
BEs
BE
≤
no
yes
no
event
no
BEs
BE
≤
no
no
no
no
no
BEs
BE
≤
no
cold
spares
yes
no
yes
BEs
BE
<
no
yes
subtrees
no
no
BEs
BE
<
no
no
no
no
no
subtrees
BE+gates
<
<
cold
spares
no
no
no
BEs
BE
≤
≤
no
no
no
yesa
Legend:
Spare modules = the type of spare modules supported of a SPARE gate.
Dep. events = the type of the events that an FDEP gate can trigger.
PAND = whether the interpretation of priority-AND is inclusive (≤) or exclusive (<).
POR = whether priority-ORs are supported.
SEQ = whether sequence enforcers are supported or can be modelled via a cold spare.
PDEP = whether PDEPs are supported.
Replication = what subtrees are allowed to be replicated.
a Modelled directly within the framework.
Awareness of these semantic issues is thus important to
achieve faithful and reliable DFT modelling and analysis.
This paper systematically uncovers the semantic differences
and subtleties of DFT variants. We extensively discuss and
illustrate the possible pitfalls, and categorise existing DFT
variants in the literature so as to enable their systematic
comparison. Our study focusses on the following issues:
1) Can we apply minimal cut sets to DFTs? Minimal cut
sets (MCSs) are sets of basic events whose failure cause
the failure of the DFT. They are at the core of many
analysis techniques for SFTs. We will show that they are
insufﬁcient to the analysis of DFTs.
2) Is there a notion of causal or temporal ordering in failure
propagation? In addition to failure combination as present
in SFTs (e.g., an AND-gate fails if all its children do fail),
DFTs allow for failure forwarding in which failures may
trigger other failures. This complicates the understanding
of DFTs, and requires causality. The same applies for
modelling the behaviour of spare elements.
3) Expressive power. In particular, we investigate whether
sequence enforcers—that enforce the order of failed
elements—add expressivity. Many DFT variants incorpo-
rate priority gates whose failure depends on the ordering
of their children to fail. We study the subtle interplay
between simultaneous failures and priority-gates. Finally,
we study whether constantly failed elements can be
expressed by existing gates.
4) How should spare races be resolved? DFTs incorporate
spare gates that model the usage of spare components
978-1-4673-8891-7/16 $31.00 © 2016 IEEE
DOI 10.1109/DSN.2016.35
299
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:41:23 UTC from IEEE Xplore.  Restrictions apply. 
representing redundant parts. As spare components may
be shared by various spare gates, so-called spare races
may occur in which simultaneously failed gates “claim”
the same redundant part. We study this phenomenon in
more depth, and provide solutions.
5) What is the difference between activation and claiming?
All modules of a SPARE can be in active (i.e., in use) or
dormant mode (not in use, being redundant, and having a
lower failure rate). It is the responsibility of the SPARE
gate to switch modules from dormant to active. This
activation of redundant parts is related to “claiming”. We
give an in-depth study of the interplay between these
mechanisms.
in [4], [14], some subtleties in DFTs are
As pointed out
in [15]. We do not repeat
due to undeﬁned semantics; e.g.
issues that are due to missing semantics. Instead, we discuss
the possible choices in the semantics and the issues that
arise if these choices are not carefully accounted for. The
presented intricacies are not independent of choices made in
the semantics. However, great care was taken to present a
broad range of possible choices for semantics. All intricacies
originate from possibly undesired behaviour of, or claims made
about, existing semantics. In this work, we omit the concept of
repairs, which give rise to several other open questions [16].
Organisation of the paper. Sect. II introduces DFTs and
their common interpretation. Sect. III is the main body of the
paper and extensively discusses the aforementioned ﬁve issues
with DFTs. Sect. IV discusses the existing DFT semantics.
Sect. V presents a case study collection and indicates which
intricacies occur in them.
II. DFTS: THE GENERAL RECIPE
A. Static Fault Trees
PC
FTs [2] are trees that model how com-
ponent failures propagate to system fail-
ures. Since subtrees can be shared, FTs are
directed acyclic graphs (DAGs) rather than
trees. The leaves of the tree (or rather sinks
of the DAG) model component failures.
They are called basic events (BEs) and are
usually equipped with a failure rate, i.e.,
the parameter of an exponential probability
Fig. 1. Fault Tree
distribution indicating the probability for
the component to fail within a deadline T . Other probability
distributions, like Weibull, are often supported as well.
M2
P
M1
Various names and symbols exist for sinks that either
have already failed or never fail. We call them constants and
denote them by CONST((cid:2)) and CONST(⊥) respectively, see
Figure 2(b)-(c). All non-sink nodes of the FT,
i.e., nodes
with one or more children (a.k.a. inputs of the node), are
equipped with gates. Static fault trees feature three types of
gates, depicted in Figure 2(d)-(f): AND, OR, and VOT(k).
These fail if respectively all, one, or k of their children fail.
The latter is also known as the k out of n, where n refers to the
number of children. Clearly, the VOT(1) gate is equivalent to
an OR-gate and a VOT(k) gate with k children is equivalent to
an AND-gate. Sometimes other gates are considered, like the
XOR (exclusive OR) and the NOT gate [2], [17]. Adding such
gates makes fault trees non-coherent, i.e. an additional event
300
causes the TLE to switch from failed to operational again. We
exclude them here, but brieﬂy discuss them in Sect. III-C. The
root of the tree is called the top level event (TLE, denoted
by an underlined identiﬁer). It represents the failure condition
of interest, such as the stranding of a train, or the unplanned
unavailability of a satellite. The DFT fails if the TLE fails. A
sample SFT is depicted in Fig. 1. The fault tree encodes that
a computer either fails if both memory units M1, M2 fail or
if the processor P fails.
As the failure of the TLE is determined by the (unordered)
set of failed BEs, these FTs are static. SFTs are appealing
as they are a relatively simple, useful modelling tool. SFTs
however cannot model several important failure patterns in
safety-critical systems, such as:
• Order-dependent failures, i.e. failures that only occur if
BEs occur in a particular order. For example, a water
leakage in a pump only leads to a short-circuit if the
power supply has not failed before.
• Simple support for feedback loops. Although systems with
feedback loops in the error behaviour and cascaded errors
can be modelled with SFTs, doing so requires verbose
work-arounds which makes modelling error prone, cf. [2].
• Sequencing expressing that an event can only happen after
another one, e.g. a short circuit in a pump can only occur
after a leakage.
• Spare management and spare parts. A spare part is an
interchangeable part that is used for the replacement of
failed elements, e.g. spare car wheels. Cold spare parts
can only fail while used. Warm spare parts can always
fail but when being spare they fail with a reduced failure
rate. Hot spare parts always have the same failure rate.
• Mutual exclusion, as e.g. a valve can either fail by being
stuck open or stuck closed, but not both.x
B. Dynamic Fault Trees
We discuss six additional element types (see Fig. 2(g)-(l)).
The priority-AND gate, SPARE, functional dependency and
SEQ are commonly included. Priority-ANDs are also discussed
as single extension to static fault trees in, among others, [18],
[19] or in combination with other gates, e.g. in [20]. As DFTs
support passive standby, e.g. in spare wheels, each BE has now
two failure rates: active and passive. Also in the presence of
these gates, DFTs are coherent.
a) A priority-and gate (pand-gate, PAND) is an AND-
gate which fails only if its children fail from left to right. The
literature does not agree what happens in case two children
fail simultaneously, see Sect. III-C.
Example 1: We model two pumps and a valve, see the
DFT in Fig. 3a. Consider a pump (PA) with a backup pump
(PB). Pump PB can only replace PA after valve V has opened
the pipe to PB. Starting from the top, two conditions lead to
the system failure SF. Either (left subtree) V fails before PA
fails. Upon failure of PA, it is then impossible to switch to PB.
Or (right subtree) both PA and PB fail (in arbitrary order).
Extending SFTs with PAND gates makes the CONST(⊥)
element syntactic sugar. In Fig. 3b, using that two BEs do not
fail simultaneously, either A or B fail before both A and B
have failed, i.e. D always fails before C, thus T never fails.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:41:23 UTC from IEEE Xplore.  Restrictions apply. 
(cid:3)
⊥
(a) BE
(b) CONST((cid:3))
(c) CONST(⊥)
. . .
. . .
k
. . .
. . .
. . .
→
. . .
p