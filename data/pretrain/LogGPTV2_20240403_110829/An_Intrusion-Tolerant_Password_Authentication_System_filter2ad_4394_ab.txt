PVD server n
Figure 1. The intrusion-tolerant password authentication system
Well-Known Group 2 of the modular exponentiation
groups (MODP) (given in Section E.2 of [25]), where
N is a 1024 bit safe prime whose primality is rigor-
ously proved. That is, q = (N − 1)/2 is also a prime.
• The selection of g1 and g2. Note that in our system, g1
and g2 were not generators of FN and instead, their or-
ders are q. FN has (q − 1) elements of order q. That is,
almost half of the elements in FN has order q. Thus,
one can simply pick a random number in FN and test
if its order is q. By repeating this process a couple of
times g1 and g2 can be found.
The management server also generates another parame-
α mod N where α is a random number in ﬁ-
ter, β = g1
nite ﬁeld Fq. A Shamir secret sharing is run on δ, δ =
−1 mod q, to generate shares (δ1, δ2, . . . , δn) and δi, 1 ≤
α
i ≤ n, is securely distributed to PVD server i
. The pub-
δi mod N, 1 ≤ i ≤ n, are also dis-
lic values βi = g1
tributed to the PVD servers. Moreover, each PVD server is
also equipped with a 1024-bit RSA public/private key pair
(for SSL connections).
The values (g1, g2, q, N, β) are hard coded into the client
program which is also conﬁgured with the IP address of the
service server. The service server is conﬁgured with the IP
addresses of the PVD servers.
‡
In the intrusion-tolerant password-based system, for
each user, the system has two phases, the user enroll-
ment phase and the user log-in phase. A user will ﬁrst
register himself with the management server in the user en-
rollment phase. The user log-in phase is used when an
enrolled user wants to access the service server.
‡ α and β can also be generated distributively by the PVD servers, as
described in [14], so that the overall values of α and δ never appear at
any single location throughout their lifetime. In our implementation,
α is generated by the management server and then shared among the
PVD servers. The management server erases δ from its memory after
its shares are distributed.
Enrollment and PVD Sharing. When a user registers
himself with the management server, he picks a password
p and a user ID, I. The management server picks a ran-
dom value, s, as the salt and the user’s PVD is computed
as x = H(s, I, p) where H is the secure hash algorithm.
Then, a (t, n) Shamir secret sharing is performed on the
PVD and PVD shares, (x1, x2, . . . , xn), are generated. The
values (I, s, xi), 1 ≤ i ≤ n, are securely sent (via the se-
cure SSL connections between the management server and
PVD servers) to PVD server i.
User Log-in. After a user is registered with the system,
he can perform a distributed PAKE computation (described
in Section 5) to log into the system using the client software
in which (g1, g2, N, q, β) are hard coded. For this step, what
a user needs is his password and the client software.
5. Data Flow
In this section we give the data ﬂow details for the user
log-in scenario, which is summarized in Table 1. Uninter-
ested readers can skip the remainder of this section without
losing the high-level view of the described system.
In the ﬁrst step of the user log-in, the user types in his ID,
I, and password p to the client program. The client program
sends I to the service server, which forwards I to the avail-
able PVD servers. (Recall that only t PVD servers are re-
quired for a user authentication.) Using I as index, the par-
ticipating PVD servers look up the user’s salt s and PVD
share xi. Salt s is then sent to the service server, which
forwards it to the client. In Step 2, the client computes
x = H(s, I, p). In Step 3, on the server side, with the help
of a subset of the PVD servers, the service server computes
B (see the following paragraph for details) and passes it to
the client. At the same time, the client program generates a
random number, a, in Fq and computes A = g1
a mod N.
In Step 4, the client computes Sc, W1, W2 using the given
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:45:51 UTC from IEEE Xplore.  Restrictions apply. 
formula (k is a random number in Fq) and sends them to
the service server, which forwards them to the participat-
ing PVD servers. The service server uses the subset of PVD
servers to compute Ss (see the following paragraph for de-
tails). Note that in step 4, each participating PVD server
contributes to the value of Ss and Ss is combined only at the
service server. At this point, the client has Sc and the service
server has Ss. The client and the service server use steps 5,
6 and 7 to conﬁrm that Sc and Ss are equal. In Step 5, the
client computes M1 and sends it to the service server, which
1 = H(A, B, W1, W2, Ss). If M1 (cid:2)=
(cid:2)
checks M1 against M
(cid:2)
1, the service server aborts the protocol. Otherwise, the
M
service server computes M2 and sends it to the client. The
(cid:2)
2 = H(A, M1, Sc).
client program checks M2 against M
The client program aborts the protocol if M2 (cid:2)= M
(cid:2)
2. Other-
wise, both sides are sure that they share a common value,
S, S = Sc = Ss, and the session key K is derived as
K = H(S). K can be used to protect subsequent commu-
nication between the client and the service server.
The server-side computation of step 3. Let the participating
PVD server set be Γ ⊆ {1, 2, . . . , n}, |Γ| ≥ t (i.e., the size
of Γ is not less than t). B is computed by the participating
PVD servers as follows:
1. Each participating PVD server j generates a random
xj×λj,Γ mod N
bj in Fq and computes Bj = g1
where λj,Γ are the Lagrange coefﬁcients. PVD server
j then sends Bj to the service server.
bj × g2
2. The service server computes B as B =
N and sends B back to the client.
(cid:1)
i∈Γ Bi mod
t or more PVD servers are needed to perform the above
steps. We stress that PVD x is not reconstructed in this step.
The server-side computation of step 4. In this step, the par-
ticipating servers compute Ss = Ab mod N where b =
(cid:2)
i∈Γ bi. The computation proceeds as follows:
1. Each participating PVD server j, j ∈ Γ, computes
Sj = Abj mod N. Server j also picks a random kj,
kj , µj = βkj ×
1 ≤ kj ≤ q, computes (σj = g1
Sj) mod N and broadcasts them to all participating
PVD servers.
2. Each participating PVD server j, j ∈ Γ, computes
j∈Γ µj)/W2. It then
ζ = (
computes ηj = ξδj and broadcasts it. Besides ηj,
PVD server j also generates a random rj, computes
vj = g1
rj , ωj = ξrj , τj = H(g1, ξ, βj, ηj, vj, ωj),
zj = δj × τj + rj. (vj, ωj, τj, zj) allows other PVD
servers to verify that ηj is indeed ξδj by checking if
τj
?= H(g1, ξ, βj, ηj, g1
j∈Γ σj)/W1, ξ = (
3. Each participating PVD server j, j ∈ Γ, veriﬁes the
correctness of all ηi that it receives and then computes
?= ζ mod N. If the
γ =
λi,Γ and checks if γ
−τj
, ξzj η
j
−τj
zj β
j
(cid:1)
(cid:1)
(cid:1)
).
i∈Γ ηi
above equation holds, it will securely send Sj to the
service server. Otherwise, it aborts the protocol.
(cid:1)
i∈Γ Si mod N.
4. The service server computes Ss =
We have the following observations about the above data
ﬂow:
• (W1, W2) is the ElGamal encryption of Sc. ElGamal
encryption is multiplicative, which allows the partici-
pating PVD servers to verify that value A does come
from a user who knows x before revealing Sj =
Abj mod N. Technically, A could be g1 (or some g1
c
and thus Ab
originated from an attacker who knows c)
b, which, if revealed to the attacker, could
would be g1
x mod N (sent out in step
be used with B = g1
3) by the attacker to mount an off-line dictionary at-
tack. To prevent this attack, in step 4 of the protocol,
before revealing Ab, the participating PVD servers ver-
ify that (W1, W2) is the ElGamal encryption of Ab.
Note that only the user who knows x can construct a
valid set (A, W1, W2) where (W1, W2) is the encryp-
tion of A under β.
• (vj, ωj, τj, zj) prevents a (possibly corrupted) partici-
pating PVD server from cheating to bias the decision
of γ
?= ζ mod N.
b × g2
§
• Compared to [29], x is shared among the PVD servers
via a Shamir secret sharing, instead of a DDB94 secret
sharing. As such, for each password, each PVD server
is assigned only one PVD share and this reduces the
management load. g2 is used to prevent an active at-
tacker who can spoof the service server from mount-
ing off-line dictionary attacks.
• In the protocol, none of the Sc, password p and PVD x
is exposed at any single PVD server.
• In the protocol, the client side authentication is accom-
x and the server-side au-
plished through the use of g2
thentication is accomplished through β.
• A passive eavesdropper may be able to observe (B =
k, W2 = βk × Sc). How-
b× g2
g1
ever, this does not give him/her any knowledge about
the session key S = g1
• For an attacker who wants to impersonate a user whose
PVD is x, since the attacker does not know x, he will
a, W1, W2),
not be able to generate a valid set (A = g1
where (W1, W2) is the ElGamal encryption of g1
ab
and the protocol will stop at Step 5.
• For an attacker who tries to spoof the service server,
b × g2
x
he cannot generate a value B in the form of g1
and at the same time knows b. In this way, the attacker
a, W1 = g1
x, A = g1
ab.
§
Say, an attacker has corrupted the service server and thus can manipu-
late the value of A.
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:45:51 UTC from IEEE Xplore.  Restrictions apply. 
1
2
3
4
Client
x = H(s, I, p)
A = g1
Sc = (B/g2
W1 = g1
a mod N
x)a mod N
k mod N
W2 = βk × Sc mod N
5 M1 = H(A, B, W1, W2, Sc)
6
7
(verify M2)
K = H(Sc)
I→
s←
B←
A,W1,W2−→
M1→
M2←
Service Server
I→
s←
B←
A,W1,W2−→
Ss⇐=
PVD Server 1
(lookup s, x1)
. . .
PVD Server n
(lookup s, xn)
Collectively compute
B = g1
x mod N
b × g2
Collectively compute
Ss = Ab mod N
(verify M1)
M2 = H(A, M1, Ss)
K = H(Ss)
Table 1. The Data Flow
will not be able to generate a valid message M2 and as
such the protocol halts at Step 6.
• If the service server is corrupted, the current session
is compromised. However, from the compromised ses-
sion key Ss = g1
ab, the attacker will get no knowledge
about the corresponding password p.
• If an attacker compromises up to (t − 1) PVD servers,
he will not be able to mount off-line dictionary attacks.
6. Implementation Details and Performance
In this section, we will give some implementation details
and performance data about our system.
6.1. Some details
All
the service server
the client program,
inter-
face, the PVD servers and the management server are
implemented in Java language and wrapped in the
sci.crypt.pake package. The SSL connections are im-
plemented through the IAIK-iSaSiLk toolkit, a SSL pack-
age by IAIK. (More details about IAIK-iSasiLk can be
found at http://jce.iaik.tugraz.at/products/index.php.) To
improve the performance, SSL caching is turned on. The
1024-bit RSA private keys stored on the PVD servers, used
for the SSL connections, are stored as PKCS12 soft to-
kens and are protected by passwords.
6.2. Performance
We ran some tests on the described system and got some
indicative results. Our testing environment comprised sev-
eral PCs with Intel Pentium 4 CPUs. These PCs ran vari-
ous types of Microsoft Windows operating systems includ-
ing Windows XP and Windows 2000 Professional and were
(t, n)
Log-in Time
(seconds)
Test over the Internet Test over LAN
(3, 4)
(2, 4)
(3, 4)
(2, 4)
4.313
5.683
2.697
4.216
Table 2. Sample Performance