解释：由于我们是把counter.inc的值作为函数来调用。因此this是全局对象，我们执行的是window.count++。而window.count不存在，且值是undefined。对它使用++操作符，会把它设置为NaN：
遇到警告怎么办
如果inc()方法是在严格模式中，你会得到警告：
原因是调用严格模式的func2函数时，this是undefined，导致错误。
如何正确地提取方法
幸好有bind()，我们可以确保inc不会与counter失去联系：
回调函数与提取方法
JavaScript有很多函数和方法可以接收回调函数。例如浏览器中的setTimeout()和事件处理。如果我们把counter.inc当作回调函数传入某个函数，该函数会把它当作函数来调用，就会导致刚才描述的同样的问题。我们使用简单的callback-invoking函数来说明这个现象：
通过callIt执行counter.count会触发一个警告（由于严格模式）：
和之前一样，我们使用bind()解决问题：
警告：
 每次调用bind()会创建一个新函数。当你注册或取消注册回调函数时都会有影响（例如，事件处理）。你需要把注册回调函数的值存储到某个地方，并使用该值来取消注册。
17.3.5 缺陷：方法中的函数会掩盖this
在JavaScript中，你会经常定义嵌套函数。这是因为函数可以作为参数（例如，回调函数），并在适当的时候可以通过函数表达式创建。这会带来一个问题，如果一个方法包含一个普通函数，而你想要在后者的内部访问前者，方法的this却被普通函数的this掩盖（即使没有使用任何this）。下面的列子中，（1）处的函数试图在（2）处访问loop方法的this：
显然，结果失败了，因为（1）处的函数拥有自己的this，而this的值是undefined。
解决这个问题有三种方案。
方案1：that = this
我们把this赋值给变量that，这样this就不会在嵌套函数中被掩盖：
执行结果：
方案2：bind()
使用bind()给回调函数的this绑定固定值，即函数的this（行（1））：
方案3：forEach()的thisValue
这个方案特定于forEach()（详见18.12.1“检测方法”）中，是在回调函数后提供第二个参数，该参数成为回调函数的this：
17.4 第2层：对象间的原型关系
两个对象间的原型关系类似继承：每个对象都可以把另一个对象作为它的原型，并继承原型的所有属性。对象通过内部属性[[Prototype]]指定它的原型。每个对象都有这个属性，而它也可以是null。通过[[Prototype]]属性连接成的对象链称为原型链（图17.1）。
图17.1 原型链
想要了解基于原型的（或原型的）继承如何工作，我们可以看这个例子（用新引入的符号来指定[[Prototype]]属性）：
对象obj从proto继承了describe属性。它还有个称为“自有的”（非继承的、直接的）属性name。
17.4.1 继承
obj继承了属性describe。你可以访问这个属性，就像对象本身拥有该属性一样。
当你通过obj访问属性时，JavaScript首先从本对象中查找，接着是它的原型，以及原型的原型，以此类推。这就解释了为什么我们可以通过obj.describe访问proto.describe。原型链的行为就好像它是一个单独的对象。当你调用一个方法时，容易出错是因为this的值总是开始查找方法时所在的那个对象，而不是找到方法时所在的对象。这就允许方法访问原型链的所有属性。例如：
在describe()中，this是obj，它允许方法访问obj.name。
17.4.2 覆写
在一个原型链中，一个对象的属性可以覆写“之后”对象的相同键的属性：前者的属性最先被找到。它隐藏了后者的属性，这样后者的属性就不能被访问了。作为例子，我们来重写obj的proto.describe()方法：
这种工作原理类似于基于类的语言中的方法重写。
17.4.3 通过原型在对象间共享数据
原型对于对象间数据共享十分有用：多个对象可以有相同的原型，这个原型持有所有的共享属性。我们来看一个例子。对象jane和tarzan都含有相同的方法describe()。我们可以使用共享来避免这样做：
两个对象都是描述人。虽然它们的name属性不同，但这两个对象可以共享describe方法。我们可以创建名为PersonProto的公共原型，并为它设置describe方法（图17.2）。
图17.2 对象jane和tarzan共享原型PersonProto，并因此共享属性describe
下面的代码创建了对象jane和tarzan，它们共享原型PersonProto：
下面是执行结果：
这是一种常见模式：数据保存在原型链的第一对象中，而方法保存在后面的对象中。JavaScript原型继承的独特设计用来支持这种模式：设置属性只会影响原型链中第一个对象，而获取属性需要考虑整个原型链（详见17.4.6“设置和删除仅影响自有属性”）。
17.4.4 获取和设置原型
到目前为止，我们都在假设可以访问JavaScript内部属性[[Prototype]]。但语言并不支持这种方式。不过，我们可以使用读取原型的函数和通过给定的prototype创建新对象的函数。
使用给定prototype创建新对象
调用方法：
创建原型为proto的对象。可以选择通过描述符添加属性（详见17.8.2“属性描述符”）。下面的例子中，对象jane获得原型PersonProto和值为'Jane'的可变属性name（通过属性描述符声明）：
下面是运行结果：
但你通常只需先创建一个空对象，然后手动添加属性，因为描述符比较繁琐。
读取对象原型
调用方法：
返回obj的原型。继续前面的例子：
检查一个对象是否是另一个对象的原型
语法是：
检查方法的接收者是否是obj的（直接或间接）原型。换句话说，接收者和obj是否在同一原型链上，且obj是否在接受者之前？例如：
找到定义属性的对象
下面的函数遍历对象obj的原型链。该函数返回键为propKey的自有属性的第一个对象，如果没有则返回null：
在上面的代码中，我们通常调用方法Object.prototype.hasOwnProperty（详见17.16“泛型方法：借用原型方法”）。
17.4.5 特殊属性__proto__
某些JavaScript引擎有特殊属性可以获取和设置对象的原型：__proto__。这样可以直接访问[[Prototype]]
关于__proto__，你需要知道以下几点。
__proto__读作“dunder proto”，“double underscore proto”的缩写。这个发音借鉴了Python编程语言（Ned Batchelder于2006年推荐）。Python中带有双下划线的特殊变量很常见。
__proto__不属于ECMAScript 5标准。因此，如果你希望代码遵循这个标准，且在当前的JavaScript引擎中稳定运行，那么就不能使用__proto__。
然而，越来越多的引擎开始支持__proto__，而它也将成为ECMAScript 6的一部分。
下面的表达式检测引擎是否支持特殊属性__proto__：
17.4.6 设置和删除仅影响自有属性
只有获取属性才需要考虑对象的完整原型链。设置和删除会忽略继承的属性，仅影响自有属性。
设置属性
设置属性会创建一个自有属性，即使已存在继承了该key的属性。例如，下面的代码：
obj从proto继承了foo：
设置foo得到期望的结果：
然而，我们已经创建了一个自有属性，且不会改变proto.foo：
理由是，原型属性会由多个对象共享。这种方式不会让我们破坏、“改变”原有属性，而只是影响当前对象。
删除继承的属性
你只能删除自有属性。下面我们用原型proto再创建一个对象obj：
删除obj继承的属性foo，不起作用：
关于delete操作符的更多信息，请查阅17.1.3小节的“删除属性”。
在原型链的任何位置改变属性
如果你希望改变继承的属性，首先要找到拥有这个属性的对象（详见17.4.4小节的“找到定义属性的对象”），然后改变这个对象的相应属性。例如，我们继续前面的例子，删除属性foo：
17.5 遍历和检测属性
遍历和检测属性的相关操作受如下情况影响。
（1）继承（自有属性与继承属性）
一个对象的自有属性直接存储在该对象中。继承的属性存储在该对象的其中一个原型中。
（2）枚举（枚举属性与非枚举属性）
属性的枚举性是一个特性（详见17.8“属性特性和属性描述符”），标识为true或false。枚举性影响较小，通常可以忽略（详见17.8.7“枚举性：最佳实践”）。
你可以列出自有的属性键（keys），也可以列出所有的可枚举的属性键，并检查这个属性是否存在。下面的小节会介绍这些。
17.5.1 列出自有的属性键
你可以列出所有自有的属性键，也可以只列出可枚举的属性键：
Object.getOwnPropertyNames(obj)返回obj的所有自有的属性键。
Object.keys(obj)返回obj的所有可枚举的属性键。
注意，属性通常都是可枚举的（详见17.8.7“枚举性：最佳实践”），因此你可以使用Object.keys()，特别是对已经创建的对象。
17.5.2 列出所有的属性键
如果想列出一个对象的所有属性（包括自有的和继承的），那么你有两个选择。
选择1，使用循环：
可以遍历object的所有可枚举的属性键。更全面的描述参考13.3.5“for-in”。
选择2，自己实现一个函数，遍历所有属性（不仅是可枚举的）。例如：
17.5.3 检测属性是否存在
你可以检查一个对象是否具有某个属性，或者一个属性是否直接存在于某个对象中：
propKey in obj
如果obj拥有一个键为propKey的属性，则返回true。这个测试也包括继承的属性。
Object.prototype.hasOwnProperty(propKey)
如果接受者（this）拥有一个键为propKey的自有（非继承）属性，则返回true。
警告：
 避免在一个对象上直接调用hasOwnProperty()，因为它可能会被重写（例如，被一个键为hasOwnProperty的自有属性重写）：
相反，最好通过泛型调用（详见17.15“泛型方法：借用原型方法”）：
17.5.4 示例
下面的例子基于上面的这些定义：
Object.defineProperties()会在17.8.3“通过描述符获取和定义属性”中介绍，显然它应该是这样工作的：proto拥有自有属性protoEnumTrue和protoEnumFalse，而obj拥有自有属性objEnumTrue和objEnumFalse（并继承了proto的所有属性）。
注解：
 注意，对象（如前面例子中的proto）通常至少都有原型Object.prototype方法（标准方法，如已定义的toString()和hasOwnProperty()）：
枚举的影响
在属性相关的操作中，枚举只影响for-in循环和Object.keys()（也会影响JSON.stringify()，详见22.2“JSON.stringify(value, replacer?, space?)”）。
for-in循环遍历所有可枚举属性的键，包括继承来的属性的键（注意，Object.prototype的非枚举属性不会显示）：
Object.keys()返回所有自有（非继承）可枚举属性的键：
如果想要得到所有自有属性的键，需要使用Object.getOwnProperty Names()：
继承的影响
只有for-in循环（参考前面的示例）和in操作符和继承有关：
计算对象自有属性的个数
对象没有类似length或size的方法，因此需要使用下面这种方式：
17.6 最佳实践：遍历自有属性
遍历属性键：
结合for-in和hasOwnProperty()，详见13.3.5“for-in”。这种方式甚至可以在以前的JavaScript引擎上运行。例如：
Object.keys()或Object.getOwnPropertyNames()与forEach()结合遍历数组：
遍历属性值或键值（key，value）对：
遍历所有的键，然后用每个键获得对应的值。其他语言提供了简单的处理方法，但JavaScript没有。
17.7 访问器（getter和setter）
依据ECMAScript 5，你写的方法在调用时看起来像获取和设置属性。这意味着属性是虚拟的且没有存储空间。例如，你可以禁止设置某个属性，而读取时，也可以对返回值进行一些计算。
17.7.1 通过对象字面量定义访问器
下面的例子使用对象字面量为属性foo定义setter和getter：
下面是执行结果：
17.7.2 通过属性描述符定义访问器
另一种方法是通过属性描述符指定getter和setter（详见17.8.2“属性描述符”）。下面的代码与前面字面量定义了相同的对象：
17.7.3 访问器和继承
getter和setter继承自原型：
17.8 属性特性和属性描述符
提示：
 属性特性和属性描述符属于更深入的话题。你通常不需要知道它们是如何工作的。
本节中，我们来看看属性的内部结构。
属性特性是属性的原子构建块。
属性描述符是一种数据结构，用于编程处理特性。
17.8.1 属性特性
所有的属性状态，包括它的数据和元数据，都存储在特性中。它们是属性拥有的字段，就像对象拥有的属性。特性的键通常写在双方括号中。特性与普通属性和访问器（getter和setter）有关。
下面是普通属性具有的特性。
[[Value]]持有属性的值，即它的数据。
[[Writable]]持有布尔类型的值，表示属性值是否可以改变。
下面是访问器具有的特性：
[[Get]]持有getter，读取属性时调用的函数。该函数计算读取的结果。
[[Set]]持有setter，为属性设置值时调用的函数。该函数接收设置的值作为参数。
所有的属性都有如下特性：
[[Enumerable]]持有一个布尔值。设置一个属性不可枚举，那么在某些操作中会隐藏此属性（详见17.5“遍历和检测属性”）。
[[Configurable]]持有一个布尔值。如果它是false，那么你不能删除、改变属性的任何特性（除了[[Value]]），也不能把它从数据属性转换为访问器属性，反之亦然。换句话说，[[Configurable]]控制属性元数据的可写性。由于历史原因，该规则有一个例外，JavaScript允许把非配置属性从可写状态变成只读状态（http://bit.ly/1fwlIQI）。数组的属性length总是可写的，且不可配置。如果没有这个例外，就无法冻结数组（详见17.9.3“冻结”）。
默认值
如果没有指定特性，会使用表17.2所示的默认值。
表17.2
属性键
默认值