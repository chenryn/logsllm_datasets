spection engine with protocol parsing would signiﬁcantly improve
the scanning throughput by inspecting each protocol ﬁeld sepa-
rately.
5.4 Real-world Deployment
We have deployed Gene in two University networks, where it
has been operational since 25 November 2009. In these two de-
ployments, Gene scans the trafﬁc between the internal network and
the Internet, as well as the trafﬁc between selected internal subnets.
As of 17 April 2010, Gene has detected 116,513 code injection at-
tacks against internal and external hosts in these two networks. Al-
though we cannot know how many of the attacks actually infected
the targeted host, since many systems might had been previously
patched, in all cases the attacker was able to connect and send the
malicious input to the potentially vulnerable service. Almost one
third of the attacks were launched from internal PCs, probably al-
ready infected by malware. About 86% of the attacks targeted port
445, while there were also attacks against ports 80, 135, 139, and
2967.
In both deployments, Gene uses the four new heuristics pre-
sented in this paper, as well as the GetPC heuristic used in existing
polymorphic shellcode detectors, allowing us to compare the detec-
tion coverage of both approaches. The PEB heuristic matched in all
of the attacks, supporting the fact that this is the most widely used
technique for resolving kernel32.dll. However, the GetPC
heuristic was triggered only by 85,144 attacks, i.e., 31,369 attacks
(27%) did not use any form of self-decrypting shellcode. This
means that the ability of Gene to detect plain shellcode increased
the detection coverage for server-side code injection attacks by 37%
compared to existing polymorphic shellcode detection approaches.
By statically analyzing the identiﬁed machine code [22] we con-
ﬁrmed that in all cases it corresponds to actual shellcode, and so far
we have not encountered any false positives.
6. DISCUSSION
The runtime heuristics presented in this paper allows Gene to
detect a broad range of different shellcode classes. Of course, we
cannot exclude the possibility that there are other kinds of Win-
dows shellcode, or alternative techniques to those on which the
heuristics are based, that may have missed our attention or have
not been publicly released yet. Nevertheless, the architecture of
Gene allows the parallel evaluation of multiple heuristics, and thus
the detection engine can be easily extended with more heuristics
for other shellcode types. For example, for our experimental eval-
uation, we have already implemented a ﬁfth heuristic based on the
widely used GetPC code technique used in existing polymorphic
shellcode detectors [23, 24, 38]. In our future work, we plan to im-
plement heuristics for the detection of the code required in a swarm
attack [13], Linux-speciﬁc plain shellcode, Windows shellcode that
uses hard-coded addresses, and so on.
A well known evasion technique against dynamic code analysis
systems is the use of very long loops that force the detector to spend
countless cycles until reaching the execution threshold, before any
signs of malicious behavior are shown [32]. Gene uses inﬁnite loop
squashing [23] to reduce the number of inputs that reach the exe-
cution threshold. As stated in the literature [23, 24], the percentage
of inputs with an instruction sequence that reaches the execution
threshold ranges between 3–6%, which we also veriﬁed during the
experiments of this paper. Since this is a small fraction of all in-
spected inputs, the endless loops in these sequences can potentially
be analyzed further at a second stage using other techniques such
as static analysis or symbolic execution [25].
Another inherent limitation of emulation-based shellcode detec-
tion is the lack of an accurate view of the system’s state at the time
the injected code would run on the victim system. This information
includes the values of the CPU registers, as well as the complete ad-
dress space of the particular exploited process [10, 23]. Although
register values can sometimes be inferred [24], and Gene augments
the emulator with the complete address space of a typical Windows
process, which includes the most common system DLLs used by
Windows shellcode, the shellcode may perform memory accesses
to application-speciﬁc DLLs that are not known in advance, and
thus cannot be followed by the emulator [16]. Fortunately, when
protecting speciﬁc services, exact memory images of each service
can be used in place of the generic process image. However, as
already discussed, since the linear addresses of DLLs change quite
often across different systems, and due to the increasing adoption
of address space layout randomization and DLL rebasing, the use
of absolute addressing results to less reliable shellcode. On the
other hand, when the emulator runs within the context of a pro-
tected application, as for example in the browser-embedded detec-
tor proposed by Egele et al. [14], the emulator can have full access
to the complete address space of the process.
Some of the operations matched by the heuristics, such as the
registration of a custom exception handler, might also be found in
legitimate executables. However, Gene is tailored for scanning in-
puts that otherwise should not contain executable IA-32 code. In
case of ﬁle uploads, Gene can easily be extended to identify and
extract executable ﬁles by looking for executables’ headers in the
inspected trafﬁc, and then pass them on to a virus scanner.
7. RELATED WORK
Having realised the limitations of signature-based approaches in
the face of polymorphic code and targeted attacks, several research
efforts turned to static binary code analysis for identifying the pres-
ence of shellcode in network streams. One of the ﬁrst such ap-
proaches by Toth and Kruegel uses code disassembly on network
streams to identify the NOP-sled that sometimes precedes the shell-
code [33]. Focusing on the shellcode itself, Anderson et al. [8]
propose to scan each input for multiple occurrences of instruction
sequences that end with an int 0x80 instruction for the identiﬁ-
cation of Linux shellcode, with the rationale that the shellcode will
have to execute several system calls. Other detection methods that
use static code analysis aim to detect previously unknown polymor-
phic shellcode based on the identiﬁcation of structural similarities
among different worm instances [17], control and data ﬂow analy-
sis [12, 34, 35], or neural networks [20].
However, methods based on static analysis can be easily evaded
by malicious code that uses obfuscation methods such as indirect
jumps and self-modiﬁcations [23], which are widely used by cur-
rent malware packers and polymorphic shellcode engines. In con-
trast, emulation-based detection can correctly handle even exten-
sively obfuscated malicious code [23]. Polychronakis et al. pro-
pose the use of code emulation for the detection of self decrypt-
ing shellcode at the network level [23, 24]. The detection algo-
rithm is based on the identiﬁcation of the GetPC code and the
self-references that take place during the execution of the shell-
code. Zhang et al. propose to combine network-level emulation
with static and data ﬂow analysis for improving the runtime perfor-
mance of the GetPC heuristic [38].
Libemu [9] is an open-source x86 emulation library tailored to
shellcode analysis and detection. Shellcode execution is identiﬁed
using the GetPC heuristic. Libemu can also emulate the execution
of Windows API calls by creating a minimalistic process environ-
ment that allows the user to install custom hooks to API functions.
Although the actual execution of API functions can be used as an
indication for the execution of shellcode, these actions will be ob-
served only after kernel32.dll has been resolved and the re-
quired API functions have been located through the EDT or IAT.
Compared to the kernel32.dll resolution heuristics presented
in Section 3.1, this technique would require the execution of a much
larger number of instructions until the ﬁrst API function is called,
and also the emulation of the actual functionality of each API call
thereafter. This means that the execution threshold of the detector
should be set much higher, resulting to degraded runtime perfor-
mance. For applications in which the emulator can spend more
cycles on each input, both heuristics can coexist and operate in par-
allel, e.g., along with all other heuristics used in Gene, offering
even better detection accuracy.
Besides the detection of code injection attacks against network
services [22], emulation-based shellcode detection using the GetPC
heuristic has been used for the detection of drive-by download at-
tacks and malicious web sites. Egele et al. [14] propose a technique
that uses a browser-embedded CPU emulator to identify javascript
string buffers that contain shellcode. Wepawet [15] is a service for
web-based malware detection that scans and identiﬁes malicious
web pages based on various indications, including the presence of
shellcode. The CPU emulator in both projects is based on libemu.
Shellcode analysis systems help analysts study and understand
the structure and functionality of a shellcode sample. Ma et al. [18]
used code emulation to extract the actual runtime instruction se-
quence of shellcode samples captured in the wild. Spector [11] uses
symbolic execution to extract the sequence of library calls made by
the shellcode, along with their arguments, and at the end of the
execution generates a low-level execution trace. Yataglass [25] im-
proves the analysis capabilities of Spector by handling shellcode
that uses memory-scanning attacks.
8. CONCLUSION
The increasing professionalism of cyber criminals and the vast
number of malware variants and malicious websites make the need
for effective code injection attack detection a critical challenge.
To this end, shellcode detection using payload execution offers
important advantages, including generic detection without exploit
or vulnerability-speciﬁc signatures, practically zero false positives,
while it is effective against targeted attacks.
In this paper we present a comprehensive shellcode detection
method based on code emulation. Our approach expands the range
of malicious code types that can be detected by enabling the parallel
evaluation of multiple runtime heuristics that match inherent low-
level operations during the execution of different shellcode types.
The runtime heuristics presented in this work enable the effective
detection of plain and metamorphic shellcode, both of which are
not identiﬁed by existing shellcode detectors. This is achieved re-
gardless of the use of self-modifying code or dynamic code gen-
eration, on which existing emulation-based polymorphic shellcode
detectors are exclusively based.
Our experimental evaluation shows that the proposed approach
can effectively detect a broad range of diverse shellcode types and
implementations, increasing signiﬁcantly the detection coverage
compared to existing emulation-based detectors, while extensive
testing with a large set of benign data did not produce any false
positives. Gene, our prototype implementation of the proposed
technique for the detection of server-side code injection attacks de-
tected 116,513 attacks against production systems in a period of
almost ﬁve months without false positives.
Although Gene currently operates at the network level, the pro-
posed detection heuristics can be readily implemented in emulation-
based systems in other domains, including host-level or application-
speciﬁc detectors. As part of our future work, we plan to implement
more heuristics to cover the detection of less widely used shellcode
types, such as shellcode that uses hard-coded addresses, and ex-
plore the design of a description language that would expedite the
development of new heuristics.
Acknowledgments
We would like to thank Periklis Akritidis and Angelos Keromytis for their
valuable feedback on earlier versions of this paper. This work was sup-
ported in part by the Marie Curie FP7-PEOPLE-2009-IOF project MAL-
CODE and the FP7 project SysSec, funded by the European Commission
under Grant Agreements No. 254116 and No. 257007, and by the project
i-Code, funded by the Prevention, Preparedness and Consequence Manage-
ment of Terrorism and other Security-related Risks Programme of the Eu-
ropean Commission—Directorate-General for Home Affairs under Grant
Agreement No. JLS/2009/CIPS/AG/C2-050. This publication reﬂects the
views only of the authors, and the Commission cannot be held responsi-
ble for any use which may be made of the information contained herein.
Michalis Polychronakis is also with FORTH-ICS. Evangelos Markatos is
also with the University of Crete.
9. REFERENCES
[1] Goodfellas security research team.
http://goodfellas.shellcode.com.ar/.
[2] The metasploit project. http://www.metasploit.com/.
[3] milw0rm. http://milw0rm.com/shellcode/win32/.
[4] Packet storm. http://www.packetstormsecurity.org/.
[5] Win32 assembly components, Dec. 2002.
http://lsd-pl.net.
[6] Common shellcode naming initiative, 2009.
http://nepenthes.carnivore.it/csni.
[7] Retrieving kernel32’s base address, June 2009. http:
//www.harmonysecurity.com/blog/2009/06/retrieving-
kernel32s-base-address.html.
[8] S. Andersson, A. Clark, and G. Mohay. Network-based
buffer overﬂow detection by exploit code analysis. In
Proceedings of the Asia Paciﬁc Information Technology
Security Conference (AusCERT), 2004.
[9] P. Baecher and M. Koetter. libemu, 2009.
http://libemu.carnivore.it/.
[10] P. Bania. Evading network-level emulation, 2009.
http://piotrbania.com/all/articles/pbania-evading-
nemu2009.pdf.
[11] K. Borders, A. Prakash, and M. Zielinski. Spector:
Automatically analyzing shell code. In Proceedings of the
Annual Computer Security Applications Conference
(ACSAC), 2007.
[12] R. Chinchani and E. V. D. Berg. A fast static analysis
approach to detect exploit code inside network ﬂows. In
Proceedings of the 8th International Symposium on Recent
Advances in Intrusion Detection (RAID), Sept. 2005.
[13] S. P. Chung and A. K. Mok. Swarm attacks against
network-level emulation/analysis. In Proceedings of the 11th
International Symposium on Recent Advances in Intrusion
Detection (RAID), September 2008.
[14] M. Egele, P. Wurzinger, C. Kruegel, and E. Kirda. Defending
browsers against drive-by downloads: Mitigating
heap-spraying code injection attacks. In Proceedings of the
6th international conference on Detection of Intrusions and
Malware, & Vulnerability Assessment (DIMVA), 2009.
[15] S. Ford, M. Cova, C. Kruegel, and G. Vigna. Wepawet, 2009.
http://wepawet.cs.ucsb.edu/.
[16] I)ruid. Context-keyed payload encoding. Uninformed, 9, Oct.
2007.
[17] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and G. Vigna.
Polymorphic worm detection using structural information of
executables. In Proceedings of the 8th International
Symposium on Recent Advances in Intrusion Detection
(RAID), Sept. 2005.
[18] J. Ma, J. Dunagan, H. J. Wang, S. Savage, and G. M. Voelker.
Finding diversity in remote code injection exploits. In
Proceedings of the 6th Internet Measurement Conference
(IMC), 2006.
[19] J. Mason, S. Small, F. Monrose, and G. MacManus. English
shellcode. In Proceedings of the 16th ACM conference on
Computer and communications security (CCS), 2009.
[20] U. Payer, P. Teuﬂ, and M. Lamberger. Hybrid engine for
polymorphic shellcode detection. In Proceedings of the
Conference on Detection of Intrusions and Malware &
Vulnerability Assessment (DIMVA), pages 19–31, July 2005.
[21] M. Pietrek. A crash course on the depths of
Win32TMstructured exception handling, 1997. http://www.
microsoft.com/msj/0197/exception/exception.aspx.
[22] M. Polychronakis, K. G. Anagnostakis, and E. P. Markatos.
An empirical study of real-world polymorphic code injection
attacks. In Proceedings of the 2nd USENIX Workshop on
Large-scale Exploits and Emergent Threats (LEET), April
2009.
[23] M. Polychronakis, E. P. Markatos, and K. G. Anagnostakis.
Network-level polymorphic shellcode detection using
emulation. In Proceedings of the Third Conference on
Detection of Intrusions and Malware & Vulnerability
Assessment (DIMVA), July 2006.
[24] M. Polychronakis, E. P. Markatos, and K. G. Anagnostakis.
Emulation-based detection of non-self-contained
polymorphic shellcode. In Proceedings of the 10th
International Symposium on Recent Advances in Intrusion
Detection (RAID), September 2007.
[25] M. Shimamura and K. Kono. Yataglass: Network-level code
emulation for analyzing memory-scanning attacks. In
Proceedings of the 6th international conference on Detection
of Intrusions and Malware, & Vulnerability Assessment
(DIMVA), 2009.
[26] sk. History and advances in windows shellcode. Phrack,
11(62), July 2004.
[27] Skape. Understanding windows shellcode, 2003. http://
www.hick.org/code/skape/papers/win32-shellcode.pdf.
[28] Skape. Safely searching process virtual address space, 2004.
http://www.hick.org/code/skape/papers/
egghunt-shellcode.pdf.
[29] SkyLined. Finding the base address of kernel32 in Windows
7. http://skypher.com/index.php/2009/07/22/
shellcode-finding-kernel32-in-windows-7/.
[30] SkyLined. SEH GetPC (XP SP3), July 2009.
http://skypher.com/wiki/index.php/Hacking/Shellcode/
Alphanumeric/ALPHA3/x86/ASCII/Mixedcase/SEH_GetPC_
(XP_sp3).
[31] Y. Song, M. E. Locasto, A. Stavrou, A. D. Keromytis, and
S. J. Stolfo. On the infeasibility of modeling polymorphic
shellcode. In Proceedings of the 14th ACM conference on
Computer and communications security (CCS), 2007.
[32] P. Ször. The Art of Computer Virus Research and Defense.
Addison-Wesley Professional, February 2005.
[33] T. Toth and C. Kruegel. Accurate buffer overﬂow detection
via abstract payload execution. In Proceedings of the 5th
Symposium on Recent Advances in Intrusion Detection
(RAID), Oct. 2002.
[34] X. Wang, Y.-C. Jhi, S. Zhu, and P. Liu. Still: Exploit code
detection via static taint and initialization analyses. In
Proceedings of the Annual Computer Security Applications
Conference (ACSAC), 2008.
[35] X. Wang, C.-C. Pan, P. Liu, and S. Zhu. Sigfree: A
signature-free buffer overﬂow attack blocker. In Proceedings
of the USENIX Security Symposium, Aug. 2006.
[36] B.-J. Wever. SEH Omelet Shellcode, 2009.
http://code.google.com/p/w32-seh-omelet-shellcode/.
[37] G. Wicherski. Win32 egg search shellcode, 33 bytes.
http://blog.oxff.net/2009/02/win32-egg-search-
shellcode-33-bytes.html.
[38] Q. Zhang, D. S. Reeves, P. Ning, and S. P. Lyer. Analyzing
network trafﬁc to detect self-decrypting exploit code. In
Proceedings of the 2nd ACM Symposium on Information,
Computer and Communications Security (ASIACCS), 2007.