    target = sys.argv[1]
    prefix = int(sys.argv[2])
    for subnet in ipaddress.ip_network(target).subnets(new_prefix=prefix):
        print(subnet)
运行命令如下：
    python3 split.py TARGET_SUBNET 20 | parallel -j JOBS "sudo nmap -sSV -p- -v --open -Pn -n --randomize-hosts -T4 {} -oA {//}"
对于这个测试用例，我决定使用两个并发任务实例，如下所示：
***使用5个并发任务：**** /16的目标子网拆分为/20的子网*
_观察：_
  * 也很慢。扫了2.8天，仍然没扫完，所以我取消了。
***使用64个并发任务：**** /16的目标子网拆分为/24的子网*
_观察：_
  * 五天过去了，扫描仍然没有完成，所以我也取消了。
##### 测试用例 #3: 扫描Masscan识别出的开放端口和主机的组合列表
这个测试用例背后的想法是，首先获得一个主机列表和一个由Masscan扫描出的开放端口的组合列表。这个开放端口的组合列表被用作基线（如下图图表中的绿色条所示），以确定下面的Nmap测试用例能否能检测出更多或更少的k开放端口。
例如，Masscan检测到300个开放端口，而常规Namp扫描检测到320个开放端口。但是，当使用5个并发Nmap任务扫描时，仅检测到295个开放端口。这意味着常规的Nmap扫描是更好的选择。
要从Masscan的扫描结果中获得主机列表，使用如下命令：
    grep "Host:" MASSCAN_OUTPUT.gnmap | cut -d " " -f2 | sort -V | uniq > HOSTS
下图显示了上述命令的运行情况：  
下面的命令用于获取Masscan检测到的所有开放端口的组合列表：
    grep "Ports:" MASSCAN_OUTPUT.gnmap | cut -d " " -f4 | cut -d "/" -f1 | sort -n | uniq | paste -sd, > OPEN_PORTS
下图显示了上述命令的运行情况：  
下面的命令用户Nmap的常规扫描：
    sudo nmap -sSV -p OPEN_PORTS -v --open -Pn -n --randomize-hosts -T4 -iL HOSTS -oA OUTPUT
以下命令用于运行并发的Nmap扫描任务。使用上面命令生成的主机列表和开放端口的组合列表。
    cat HOSTS | parallel -j JOBS "sudo nmap -sSV -p OPEN_PORTS -v --open -Pn -n --randomize-hosts -T4 {} -oA {}"
**_使用的并发任务数：_**
  * 0 (这是常规的nmap扫描)
  * 10
  * 50
  * 100
**_图表如下：_**  
**_观察：_**
运行常规的Nmap扫描时，CPU的利用率仅为10%左右；
常规的Nmap扫描发现了更多的开放端口，而并发的Nmap扫描发现的开放端口较少一些。
与基线（上面图表中的绿色条）相比，在某些目标网络（子网A）上识别出更多的开放端口，而在其他的网络目标（子网B和子网C）上检测到的开放端口较少，在某些网络目标（子网D）上没有太大差异。
###### Nmap检测到的其他开放端口
先看下面的表格。例如，让我们假设Masscan在每台主机上检测到以下的开放端口（表格第2列）。在运行Nmap扫描时，Masscan检测到的所有开放端口将用作Nmap的目标端口（表格第3列）。
在我们的示例中，Nmap在完成扫描后检测到的新开放的端口（第4列中的 **粗体文字**
）。这种情况是怎么发生的？Masscan是一个异步的扫描器，主机192.168.1.2和192.168.1.3上可能丢失了22端口。由于我们合并了每个主机上检测到的开放端口，并将它们作为Nmap的目标端口，因此这个丢失的22端口将再次进行探测。需要注意的是，无法保证Nmap能够将其检测为开放状态，因为还有其他可能影响扫描结果的因素。
主机 | Masscan检测到的端口 | Nmap扫描的目标端口 | Nmap运行后检测到的开放端口  
---|---|---|---  
192.168.1.1 | 22,80,443 | 22,80,443,8080,8888 | 22,80,443  
192.168.1.2 | 8080,8888 | 22,80,443,8080,8888 | **22** ,8080,888  
192.168.1.3 | 80,443 | 22,80,443,8080,8888 | **22** ,80,443  
##### 测试用例 #4 扫描由Masscan识别的特定主机上的特定开放端口
这个与之前的测试用例有点类似。在这个用例中，我没有将Masscan检测到的所有开放端口与每个主机组合在一起。无论Masscan在特定主机上检测到哪些开放端口，Nmap都将使用相同的端口作为目标端口。下表说明了我们这个测试用例中的操作：
主机 | Masscan检测到的端口 | Nmap扫描的目标端口  
---|---|---  
192.168.1.1 | 22,80,443 | 22,80,443  
192.168.1.2 | 8080,8888 | 8080,8888  
192.168.1.3 | 80,443 | 80,443  
以下命令用于获取主机列表：
    cat MASSCAN_OUTPUT.gnmap | grep Host | awk '{print $2,$5}' | sed 's@/.*@@' | sort -t' ' -n -k2 | awk -F' ' -v OFS=' ' '{x=$1;$1="";a[x]=a[x]","$0}END{for(x in a) print x,a[x]}' | sed 's/, /,/g' | sed 's/ ,/ /' | sort -V -k1 | cut -d " " -f1 > HOSTS
下图显示了上述命令的运行情况：  
要从每个主机获取打开的端口列表，执行以下命令：
    cat MASSCAN_OUTPUT.gnmap | grep Host | awk '{print $2,$5}' | sed 's@/.*@@' | sort -t' ' -n -k2 | awk -F' ' -v OFS=' ' '{x=$1;$1="";a[x]=a[x]","$0}END{for(x in a) print x,a[x]}' | sed 's/, /,/g' | sed 's/ ,/ /' | sort -V -k1 | cut -d " " -f2 > OPEN_PORTS
下图显示了上述命令的运行情况：  
可以看到，上图输出的内容于测试用例 #3中的不同，而且使用的命令也不一样。我们查询出每个主机的开放端口列表，而不是所有开放端口的组合。
然后使用parallel命令的`::::`选项将上面两个命令查询出的列表，并发执行Nmap扫描。
> _如果您不熟悉GNU
> Parallel，请查看本[教程](https://www.gnu.org/software/parallel/parallel_tutorial.html)。_
    parallel -j JOBS --link "sudo nmap -sSV -p {2} -v --open -Pn -n -T4 {1} -oA {1}" :::: HOSTS :::: OPEN_PORTS
这是个例子，当执行上述parallel命令后，并扫描时会发生什么（多条命令同时执行）。
    sudo nmap -sSV -p 443 -v --open -Pn -n -T4 192.168.1.2 -oA 192.168.1.2
    sudo nmap -sSV -p 80,443,1935,9443 -v --open -Pn -n -T4 192.168.1.5 -oA 192.168.1.5
    sudo nmap -sSV -p 80 -v --open -Pn -n -T4 192.168.1.6 -oA 192.168.1.6
    sudo nmap -sSV -p 80,443 -v --open -Pn -n -T4 192.168.1.7 -oA 192.168.1.7
    sudo nmap -sSV -p 08,443 -v --open -Pn -n -T4 192.168.1.9 -oA 192.168.1.9
下图展示了测试用例执行时，发生的一个片段。如下图所示，使用parallel运行10个并发的Nmap扫描。  
**_使用的并发任务数：_**
  * 10
  * 50
  * 100
**_图表如下：_**  
**_观察：_**
  * 更多的并发任务和以100%的CPU利用率进行扫描时，检测出更少的开放端口。
  * 10个和50个Nmap并发任务，扫描结果差别不大，因此建议可以运行50个并发任务，以减少扫描时间。
  * 此测试用例比测试用例 #3的扫描速度略快，但是检测出的开放端口较少。
**_原始数据_**
下表显示了使用上述不同的Nmap测试用例进行实验的原始数据：  
##### Nmap结论：
根据使用Nmap进行的实验结果，得出以下结论：
  * 测试用例 #3（扫描Masscan识别出的开放端口和主机的组合列表）可获得最佳的结果。这也是推荐的方法，因为可以发现额外的端口开放；
  * 以100%的CPU利用率进行扫描，会导致检测出更少的开放端口；
  * 使用并发任务时，更少的任务数会导致检测出更多的开放端口；
#### 0x09 研究结论
##### 推荐的扫描方法
根据对Masscan和Nmap进行的多个测试用例的测试结果，建议采用以下方法在端口扫描期间实现速度和精度之间的平衡：
  1. 首先运行2或3个并发的Masscan任务，所有的65535个端口分为4-5个更小的范围；
  2. 获取主机列表以及Masscan扫描出的开放端口的组合列表；
  3. 使用这些列表作为Nmap的扫描目标并执行常规Nmap扫描。
##### 注意事项
对于这两种扫描端口的工具，应采用以下的预防措施进行规避，因为它们会导致检测到的开放端口更少：
  * 扫描时避免CPU过载。
  * 不要使用扫描机器的最大速率容量。
  * 避免运行太多并行任务。
#### 0x10 最后的想法
虽然这项研究提供了一种如何在互联网端口扫描期间平衡速度和准确性的方法，但读者不应将此结论视为100％可靠。由于时间和预算有限，研究期间没有涵盖其他的影响因素。最值得注意的是，在整个研究期间仅使用一个IP地址进行扫描并不是一个好的设置。因为在我多次扫描相同的目标网络后，机器的IP地址可能会以某种方式被拉黑，这可能导致检测到的开放端口数量不太一致。
请重新查看 **0x06 范围和限制** 部分，因为从中可以很好的理解影响本研究结果的一些因素。