0 
30 
0 
Due  to  the  dynamic  recovery  plan  generation,  our  method  can  recover  from  errors  without 
known cause – as long as the error cause is included in the resource space and can be recovered 
111 
through API calls. If the cause is not included or the API cannot be reached (e.g. cloud system 
disconnected), our method cannot recover from the error. Hence, the cause of the error does not 
affect the recovery although it may affect whether the error remains or reoccurs. 
F.  Dealing with False Positives of Error Detection 
1)  Experimental Procedure 
To  test  the  reaction  of  POD-Recovery  to  false  positives  of  error  detection,  we  trigger  the 
recovery  service  without  injecting  an  error,  and  observe  whether  POD-Recovery  takes  any 
action.  For  each  recovery  point  (RP)  we  do  this  50  times.  Since  error  detection  triggers  the 
recovery  service,  and  since  POD-Recovery  does  not  consider  any  causes  offered  by  the 
triggering  message,  we  do  not  investigate  any  more  complex  false  positives.  Also,  as  argued 
above, if a transient error disappears before recovery starts, we consider it to be a false positive 
from the viewpoint of recovery. 
2)  Experimental Results 
Table 25 shows the recovery service’s ability to handle false positives from the error detection 
service. We can see that all the false positives were successfully detected: in all 100 runs of our 
experiment, no recovery action was taken. 
Table 25.  Handling False Positives of Error Detection 
Recovery Point 
# False Positives 
# No Recovery 
RP 1 
RP 2 
50 
50 
50 
50 
3)  Satisfying Recovery Requirement R6 
Due  to  the  design  of  our  recovery  method,  with  its  dynamic  plan  generation,  false  positives 
from error detection will not cause unnecessary recovery actions. 
G.  Recovery for Recovery Itself  
1)  Experimental Procedure 
To test POD-Recovery’s behaviour when errors occur during the execution of the recovery plan, 
I  performed  the  installation  operation,  injected  faults  into  each  determined  recovery  point  to 
trigger  POD-Recovery,  waited  for  the  selected  recovery  action  to  execute,  and  then  manually 
injected additional faults into the recovery action to trigger the “recovery of recovery” block. I 
performed  30  runs  of  this test  of  “recovery  for  recovery  itself”  for  each  recovery  point  of  the 
installation operation. 
112 
2)  Experimental Results 
Table 26 shows the recovery time of “recovery for recovery” on the installation operation. The 
relative standard deviation is at most 2.1%. 
Table 26.  Recovery Time of “Recovery for Recovery” 
Recovery 
Point 
Process Step 
Errors 
Selected Recovery 
Action(Pareto Set) 
Recovery 
Point 1 
Recovery 
Point 2 
Step 1. 
Launch a web 
instance 
Step 2. 
Assign an 
elastic IP to 
the web 
instance 
Step 3. launch 
a database 
instance  
Step 4. assign 
an elastic IP 
to the 
database 
instance 
Web instance 
not launched  
Database 
instance not 
launched  
Restart the web 
instance; 
Assign elastic IP to 
the web instance; 
(Reparation) 
Restart the database 
instance; 
Assign elastic IP to 
the database 
instance; 
(Reparation) 
Time of 
Recovery 
for 
Recovery(
Pareto 
Set) 
65.71 s 
67.34 s 
Selected 
Recovery 
Action(User 
Constraints) 
Restart the web 
instance; 
Assign elastic 
IP to the web 
instance; 
(Reparation) 
Restart the 
database 
instance; 
Assign elastic 
IP to the 
database 
instance; 
(Reparation) 
Time of 
Recovery for 
Recovery 
(User 
Constraints) 
77.09 s 
61.66 s 
3)  Satisfying Recovery Requirement R7 
We can see that the maximum recovery time of “recovery for recovery” is 77.09 seconds. Hence, 
the time for the original recovery and the “recovery for recovery” in total is much less than the 
specified  time  gap  between  two  adjacent  recovery  points.  Thus,  the  requirement  of  “recovery 
for recovery” is achieved by POD-Recovery. 
8.3  Case Study 3-Recovery for Scale-up Operation on Cloud 
In  this  section,  we  present  the  evaluation  results  of  POD-Recovery  by  using  the  scale-up 
operation on cloud as the case study. The purposes of this experiment are three-fold: 1) showing 
the result of recovery points determination for scale-up; 2) presenting the workload of resource 
state  management  for  scale-up;  3)  demonstrating  POD-Recovery’s  capability  of  satisfying 
recovery  requirements  using  scale-up.  The  experimental  environment  is  described  in  Fig.  26 
above. 
8.3.1  Recovery Points Determination 
The scale-up operation has 3 steps: 1) increase auto scaling group’s desired capacity by 12; 2) 
wait  for  the  auto  scaling  group  to  start  additional  12  instances;  3)  register  these  12  instances 
with  the  load  balancer.  Fig.  33  shows  the  sections  resulting  from  recovery  points  at  different 
113 
levels of granularity. First, Fig. 33(a) is obtained by applying Recovery Actions Identifiable to 
the steps of  scale-up operation. Fig. 33(b) combines some sections with low failure rates.  The 
recovery  points  are  determined  to  be  after  step  2  and  step  3  based  on  the  recovery  point 
determination criterion and failure rate consideration. 
Fig. 33.  Determining Recovery Points for Scale-up Operation. 
8.3.2  Workload of Resource Space Determination 
The  determined  resource  space  contains  four  resource  types:  Instance  (i.e.  VM),  Launch 
Configuration  (LC),  Auto  Scaling  Group  (ASG),  and  Elastic  Load  Balancer  (ELB).  Each 
resource  type  has  attributes  (e.g.  instances  have  an  instance  id,  instance  type,  machine  image, 
etc.).  The  dependency  relationships  among  those  resources  are:  1)  an  ASG  is  associated  with 
one LC; 2) an ASG contains a (possibly empty) set of instances; 3) an ELB links to a (possibly 
empty) set of instances; 4) each instance belongs to at most one ASG; and 5) each instance can 
be  linked  to  a (possibly  empty)  set  of  ELBs. The  workload  of  determining  resource space  for 
scale-up  operation is  shown  in  Fig.  34,  which shows the execution  time  of the  resource space 
determination algorithm based on 30 times of runs. The average execution time is calculated to 
be 48.40ms, and the relative standard deviation is calculated to be 12.64%. The value of the 75th 
percentile point (75% percentile) is also calculated, which is 53ms. 
Fig. 34.  Workload of Resource Space Determination for Scale-up Operation. 
114 
8.3.3  Workload of Expected Resource State Templates Generation 
The workload of generating the expected resource state templates for the  scale-up operation is 
shown  in  Fig.  35,  which  shows  the  execution  time  of  expected  resource  state  templates 
generation algorithm based on 30 times of runs. The average execution time is calculated to be 
51.04ms,  and  the  relative  standard  deviation  is  calculated  to  be  5.55%.  The  value  of  the  75th 
percentile point (75% percentile) is also calculated, which is 52.75ms. 
Fig. 35.  Workload of Expected Resource State Templates Generation for Scale-up Operation. 
8.3.4  Recovery Satisfying Requirements 
POD-Recovery  is  designed  to  achieve  the  goal  of  satisfying  all  of  the  eight  recovery 
requirements  described  in  section  3.5.  Therefore,  experimental  evaluations  are  required  to 
justify  POD-Recovery’s  capability  of  satisfying  all  the  recovery  requirement  The  experiments 
conducted below are constructed in such a way that it can demonstrate how POD-Recovery is 
able to fulfil each of the recovery requirements using the scale-up operation.  
A.  Runtime Recovery (Satisfying Recovery Requirement R1) 
As  should  be  clear  from  the  descriptions  in  chapters  4-7,  our  method  is  inherently  a  runtime 
recovery solution.  
B.  Recovery Satisfying RTO 
1)  Experimental Procedure 
This  recovery  requirement  concerns  the  time  the  recovery  takes  for  the  system  to  go  to  a 
consistent state. We therefore measure recovery time by performing the scale-up operation on a 
cloud  application.  There  are  initially  12  instances  in  the  cloud  application.  The  instances  are 
attached  to  an  auto  scaling  group  and  are  registered  in  an  elastic  load  balancer.  The  cloud 
application  running  in  the  instances  is  TPC-W  which  is  a  3-tier  web  benchmark  application 
115 
running  in  Tomcat  service.  The  average  workload  on  each  instance  is  50  query  requests  per 
second.  We  used  our  own  proprietary  fault  injection  tool  to  inject  faults  for  each  of  the  two 
determined  recovery  points  in  the  scale-up  operation,  automatically  determined  the  applicable 
recovery patterns based on the applicable recovery patterns filtering method described in section 
7.3, and performed recovery using the selected acceptable recovery action based on each of the 
two  recovery  action  selection  methods.  The  selected  recovery  action  by  the  first  selection 
method is the optimal one; the selected recovery action by the second selection  method is not 
necessarily the optimal one, but it is an acceptable one. Therefore, the selected recovery actions 
by  both  of  these  two  optimization  methods  are  both  acceptable  ones.  The  faults  injected  are 
described in Table 27. The selection of injected faults is based on our interviews with industry 
and  failure  reports,  and  hence  representative.  The  recovery  time  is  calculated  by  summing  up 
the  execution  time  of  each  function  in  the  recovery  action.  We  ran  the  experiment  30  times, 
measuring the recovery time.  
Table 27.  Faults injected for Scale-up Operation 
Recovery Point 
Fault injected 
Recovery Point 1 (After Step 2) 
6 instances with wrong AMI 
Recovery Point 2 (After Step 3) 
6 instances not in ELB 
2)  Experimental Results 
Table 28 shows the recovery time of the recovery for the scale-up operation. Recovery time here 
refers  to  exclusively  the  time  for  executing  the  recovery  plan.  The  recovery  time  in  the  table 
represents  the  average  value  of  the  recovery  time  for  30  runs.  The  highest  relative  standard 
deviation is 2.1%. For each recovery point, the execution time of the recovery action selected by 
the Pareto set search based optimization method is no greater than the other applicable recovery 
actions;  the  execution  time  of  the  selected  recovery  action  by  the  user  constraints  based 
optimization  method  is  not  necessarily  less  than  all  the  other  ones,  but  it  is  within  the  time 
constraint set by business stakeholders. 
116 
Table 28.  Recovery Time for Scale-up 
Legends 
Recovery Pattern ID 
Recovery Pattern 
Recovery Pattern ID 
Recovery Pattern 
RP1 
RP2 
RP3 
RP4 
Compensated Undo & Redo 
Compensated Undo & Alternative 
Rewind & Replay 
Rewind & Alternative 
RP5 
RP6 
RP7 
RP8 
Reparation 
Direct Redo 
Direct Alternative 
Farther Undo & Redo 
Recovery 
Point 
Process Step 
Errors 
Applicable 
Recovery 
Patterns 
Selected 
Recovery 
Action(Pareto 
Set) 
Recovery 
Time 
(Pareto 
Set) 
Selected 
Recovery 
Action(User 
Constraints) 
Recovery 
Time (User 
Constraints) 
Recovery 
Point 1 
Step 1. 
Increase auto 
scaling 
group’s 
desired 
capacity by 12 
Step 2. Wait 
for the auto 
scaling group 
to start 
additional 12 
instances 
6 instances 
with wrong 
AMI 
RP1, RP2, 
RP3, RP4, 
RP5 
Recovery 
Point 2 