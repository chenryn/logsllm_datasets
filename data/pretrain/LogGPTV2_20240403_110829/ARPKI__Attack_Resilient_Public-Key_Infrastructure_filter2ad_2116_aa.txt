title:ARPKI: Attack Resilient Public-Key Infrastructure
author:David A. Basin and
Cas J. F. Cremers and
Tiffany Hyun-Jin Kim and
Adrian Perrig and
Ralf Sasse and
Pawel Szalachowski
ARPKI: Attack Resilient Public-Key Infrastructure
David Basin
Inst. of Information Security
Dept. of Computer Science
ETH Zurich, Switzerland
PI:EMAIL
Cas Cremers
Dept. of Computer Science
University of Oxford, UK
PI:EMAIL
Tiffany Hyun-Jin Kim
Carnegie Mellon University
Pittsburgh, USA
PI:EMAIL
Adrian Perrig
Inst. of Information Security
Dept. of Computer Science
PI:EMAIL
ETH Zurich, Switzerland
Ralf Sasse
Inst. of Information Security
Dept. of Computer Science
ETH Zurich, Switzerland
PI:EMAIL
Pawel Szalachowski
Inst. of Information Security
Dept. of Computer Science
ETH Zurich, Switzerland
PI:EMAIL
ABSTRACT
We present ARPKI, a public-key infrastructure that ensures
that certiﬁcate-related operations, such as certiﬁcate issuance,
update, revocation, and validation, are transparent and ac-
countable. ARPKI is the ﬁrst such infrastructure that sys-
tematically takes into account requirements identiﬁed by
previous research. Moreover, ARPKI is co-designed with a
formal model, and we verify its core security property using
the Tamarin prover. We present a proof-of-concept imple-
mentation providing all features required for deployment.
ARPKI eﬃciently handles the certiﬁcation process with low
overhead and without incurring additional latency to TLS.
ARPKI oﬀers extremely strong security guarantees, where
compromising n− 1 trusted signing and verifying entities is
insuﬃcient to launch an impersonation attack. Moreover, it
deters misbehavior as all its operations are publicly visible.
Categories and Subject Descriptors
K.6.5 [MANAGEMENT OF COMPUTING AND IN-
FORMATION SYSTEMS]: Security and Protection—
Authentication; C.2.0 [COMPUTER-COMMUNICATION
NETWORKS]: General—Security and protection
General Terms
Security
Keywords
Public-Key Infrastructure; TLS; certiﬁcate validation; public
log servers; formal validation; attack resilience
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660298 .
1.
INTRODUCTION
In the current trust model of TLS PKI, a single compro-
mised (or malicious) Certiﬁcation Authority (CA) can issue a
certiﬁcate for any domain [9,21,23,26]. Moreover, such bogus
certiﬁcates can go unnoticed over long periods of time. This
glaring vulnerability is widely recognized.
In response, the research community has proposed diﬀer-
ent approaches to mitigate this problem. Recent proposals
include Certiﬁcate Transparency (CT) [18], which adds ac-
countability by using log servers to make compromises visi-
ble, and the Accountable Key Infrastructure (AKI) [15] that
prevents attacks by using checks-and-balances to prevent a
compromised CA from impersonating domains. Although
such proposals provide good starting points and building
blocks, they require many interacting features to be viable
and thus are inherently highly complex. History has shown
that humans will miss cases when considering the security
of such complex systems. Moreover, they must satisfy eﬃ-
ciency requirements and ﬁt with existing business models,
as well as oﬀer improved security. Finally, even advanced
proposals such as CT and AKI are still incomplete and have
been designed in an ad-hoc fashion, without a formal proof
of correctness. We will discuss limitations of the existing
state-of-the-art further in Section 2.
We now need to take the next step and get assurance
of both completeness of features as well as correctness of
the security claims, which can only be achieved by using a
principled approach.
security against a strong adversary capable of compromis-
Contributions. We present ARPKI, the ﬁrst co-designed
model, veriﬁcation, and implementation that provides ac-
countability and security for public-key infrastructures. In
contrast to other PKI proposals, ARPKI oﬀers:
● substantially stronger security guarantees, by providing
ing n− 1 entities at any time, where n≥ 3 is a system
● formal machine-checked veriﬁcation of its core security
● a complete proof-of-concept implementation that provides
parameter that can be set depending on the desired level
of security;
property using the Tamarin prover; and
all the features required for deployment and demonstrates
its eﬃcient operation.
The full implementation, formal model and security proper-
ties, and the analysis tools are available [1].
Organization. In Section 2 we review the state-of-the-art
in PKI and in Section 3 we motivate properties that all PKI
architectures should have. We introduce ARPKI in detail in
Section 4 and describe its modeling and formal analysis in
Section 5. We present its implementation and evaluation in
Section 6 before we draw conclusions in Section 7.
2. PKI BACKGROUND
A variety of proposals have been made to address the
security issues in X.509 PKIs and to reduce trust in the
CAs. As illustrated in Figure 1, existing approaches can
be classiﬁed as being client-centric, CA-centric, or domain-
centric. We ﬁrst look at these diﬀerent approaches from a
high level and then focus on AKI, which is closest to our
work.
2.1 Alternative Approaches
Client-centric approaches. Proposals in this class em-
power clients to select dedicated entities to evaluate a cer-
tiﬁcates’ correctness before accepting it. Policy engine [5]
supports clients in deﬁning local policies (e.g., cryptographic
requirements, consistency of certiﬁcates based on an observed
history, etc.) for trust decisions. This proposal is at an early
stage and may rely on other proposals.
There are several proposals to create public repositories of
domain certiﬁcates and enable clients to select repositories
to compare the received key (of a domain) with the version
stored in the repositories. Perspectives [29] and Conver-
gence [2] fall in this category.
Although servers need no modiﬁcations, client-centric ap-
proaches require additional connections to query the reposi-
tories. This increases latency when establishing an HTTPS
connection.
CA-centric approaches. X.509 PKI includes standards
for Certiﬁcate Revocation Lists (CRL) [13] that are issued by
CAs to prevent clients from establishing a TLS connection
with domains with revoked certiﬁcates. Unfortunately, clients
must be able to access the current CRLs. To resolve this
online validation requirement, the Online Certiﬁcate Status
Protocol (OCSP) [22] allows clients to check domains’ certiﬁ-
cate status by querying CAs’ OCSP servers. However, OCSP
has security, privacy, and performance concerns. Another
approach is Short-lived certiﬁcates (SLC) [28] with which
domains acquire certiﬁcates with short validity lifetimes and
update them daily. SLC provides similar security beneﬁts
to OCSP while eliminating the need for online validation.
The major drawback with CA-centric approaches is their
heavy reliance on browser vendors to detect and blacklist
certiﬁcates issued by compromised CAs.
Domain-centric approaches. Three approaches allow
domain owners to actively control and protect their public
keys despite CAs’ potential vulnerabilities. They are based
on (1) pinning, (2) DNSSEC, or (3) log servers.
Pinning-based approaches, such as Public Key Pinning
(PKP) [3,4] and Trust Assertions for Certiﬁcate Keys
(TACK) [19], allow a domain to declare which keys are
valid for that domain such that clients “pin” the keys. How-
ever, these approaches have security vulnerabilities, such as
providing no protection on the ﬁrst visit to domains.
Figure 1: Classiﬁcation of PKI proposals.
The DNSSEC-based proposal called DNS-based Authenti-
cation of Named Entities (DANE) [12] enables domain owners
to assert certiﬁcate-speciﬁc ﬁelds on DNSSEC entries, such as
a list of acceptable CAs for issuing their domain’s certiﬁcates,
speciﬁc acceptable certiﬁcates, or speciﬁc trust anchors to
validate certiﬁcates. However, the security of DANE heavily
relies on the security of DNS operators, which historically is
not one of their concerns.
Log server-based approaches allow domain owners to record
their certiﬁcates to public log servers, creating accountability
for the CAs’ actions. For example, Sovereign Keys (SK) [10]
require domain owners to generate a sovereign key pair to
sign their TLS public key and to log the sovereign key pair
to read- and append-only timeline servers. Unfortunately
SK requires clients to query servers, increasing latency and
sacriﬁcing privacy.
Certiﬁcate Transparency (CT) [18] proposes that each
domain owner registers the CA-issued certiﬁcate to append-
only log servers with a Merkle hash tree structure. The
servers return a non-repudiable audit proof to the domain
such that the domain can provide its certiﬁcate along with the
audit proof to clients for a TLS connection setup. However,
as CT’s goal is only to make used certiﬁcates visible, it is still
vulnerable to attacks when an adversary compromises a CA
to create and register the fraudulent certiﬁcates, and CT does
not prevent clients from accepting these certiﬁcates. Because
CT itself is not designed to address certiﬁcate revocation, a
supplementary system called Revocation Transparency was
proposed [17]. Also Certiﬁcate Issuance and Revocation
Transparency (CIRT) [24] proposes eﬃcient revocation for
CT, but it requires a client to create a new identity once its
key is lost.
PoliCert [27] extends the Accountable Key Infrastructure
(discussed below) by giving the domain a way to describe
its own certiﬁcates and properties of TLS connections. It
also includes a revocation system and a new certiﬁcate val-
idation model. However, in this approach (as well as in
previously mentioned ones), the mechanisms for detecting
and disseminating log misbehavior are unspeciﬁed.
2.2 Accountable Key Infrastructure
We review the Accountable Key Infrastructure (AKI) [15]
in more detail for two reasons. First, ARPKI is inspired
by AKI’s design and employs some of its concepts. Second,
ARPKI addresses several shortcomings that we identiﬁed in
AKI.
AKI proposes to protect domains and clients from vulnera-
bilities caused by single points of failure, such as a CA’s root
key compromise [9,21,23,26]. Through checks-and-balances
among independent entities, AKI successfully distributes
trust over multiple parties and detects misbehaving entities
while eﬃciently handling certiﬁcate operations.
The AKI operates with the following three entities:
PKICA-centricClient-centricDomain-centricSLCOCSPPolicy engineRepositoriesPerspectivesConvergencePinningDNSSECLog serverPKPTACKDANESKCT/CIRTAKICRL1. A Certiﬁcation Authority, called Certiﬁcation Agency
in [15], authenticates domains and issues X.509 certiﬁcates.
2. To make CA-issued certiﬁcates publicly visible, an In-
tegrity Log Server (ILS) maintains an Integrity Tree
that logs certiﬁcates. Each ILS updates its Integrity Tree
at a given interval, called ILS_UP.
3. Along with CAs, validators monitor ILS operations and
detect misbehavior, such as the sudden (dis)appearance of
certiﬁcates.
With these entities, the owner of a domain A.com deﬁnes
X.509 certiﬁcate extension ﬁelds, including:
● CA_LIST: List of trusted CAs to sign the certiﬁcate;
● ILS_LIST: List of trusted ILSes to register the certiﬁcate;
● ILS_TIMEOUT: Timeout of an ILS’s registration conﬁrma-
● CA_MIN: Minimum number of CA signatures needed to
tion;
initially register and update a certiﬁcate to ILSes.
The domain owner then contacts at least CA_MIN trusted CAs
to acquire certiﬁcates, the combination of which becomes
an AKICert. After receiving a conﬁrmation (i.e., signature)
from a trusted ILS that promises to add this AKICert to its
log and another conﬁrmation from at least one validator that
veriﬁes the correct operation of the trusted CAs and ILSes,
A.com uses the two conﬁrmations along with the AKICert to
establish TLS connections with clients.
Integrity Trees. Figure 2 illustrates the Integrity Tree
maintained by ILSes. Integrity Trees ensure that the ILS
cannot make false claims about any certiﬁcate it has or has
not stored. It is implemented as a Merkle hash tree, whose
leaves are lexicographically sorted by the domains’ names
and each parent node is computed as the hash of its two child
nodes. Every leaf stores the AKICert corresponding to the
given domain. After each ILS_UP period, the ILS updates the
tree by (1) adding new entries, (2) replacing updated entries,
and (3) deleting revoked and expired entries. Moreover, the
ILS computes the new root hash for the current version of
the tree.
This structure enables the ILS to create eﬃcient proofs
about its own content, including presence and absence proofs.
To prove that AKICert exists for A.com, the ILS provides
h1, AKICertA.com, h10, and h14. To prove that E.com does
not have any registered AKICerts, the ILS provides the
presence proofs for the immediate neighbors D.com and F.com:
h9, AKICertD.com, AKICertF.com, and h14. Along with presence
and absence proofs, the ILS provides the current signed root
hash rooti accompanied by the timestamp i (i.e., the last
time the tree was updated).
AKI weaknesses.
AKI leaves several questions unan-
swered. First, AKI’s setup suggests that validators can be
non-proﬁt organizations whose only incentive is to check
the correctness of ILS operations. However, AKI’s design
implies that if validators are not continuously online or have
rooti
h13
h14
h9
h10
h11
h12
h1
rooti−1
h2
h3
h4
h5
h6
h7
h8
A.com
D.com
F.com
K.com