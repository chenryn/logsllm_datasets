      ...
      cur_nsf->cpu->mem_page[cpu_page] = offset;
      …
上面的代码片段中，cur_nsf->data指向实际的ROM数据即音频文件的内容。文件格式非常简单：128字节的头（以“NESM”四个字母开始），剩下的就是ROM。所以，举个例子，假如你有一个200字节的文件，那么就是128字节的头和72字节的ROM。通过单个malloc()函数，即可将所有ROM的数据都保存在主机模拟器的堆中。可以看出，offset指针可以指向ROM堆内存中的任意位置，而没有对任何类型的长度进行检查！
再举个更具体的例子：我们对200字节的文件进行最简单的ROM加载，虚拟ROM加载地址会是0x8000，而加载代码仍会多次调用nsf_bankswitch()，对应的参数分别是：地址（address）从0x5ff8
– 0x5fff，库索引（value）从0 – 7。这会导致6502虚拟地址0x8000被映射为nsf->data +
0，0x9000被映射为nsf->data + 4096，……一直到0xf000被映射为nsf->data + (7 *
4096)。所以即使在这个非常简单的例子中，从6502模拟器中线性地读取0x8000 –
0xffff就会导致实际读取到72字节的ROM数据和32696字节的越界堆数据。
但这只是一个越界读取，因为模拟器中的虚拟地址0x8000 –
0xffff是只读的。在模拟器下，一个越界（OOB）读取漏洞并不是特别严重。或许可以将其用作绕过ASLR的工具，但任何从主机堆中读取到的敏感数据都只能用来产生声音。这个模拟器没有任何高级功能，例如通过网络连接传出堆数据的能力。最严重的情况，也就是该模拟器运行在一个提供音频格式转换的网络服务器上，攻击者可以将部分越界读取到的堆的内容输出到转换文件中的音频内容，从而获取到服务器中的堆数据。
但是，这个特殊的模拟器中的另外一个逻辑处理错误加重了事态的严重性：
2：能够通过加载或者库切换操作，使ROM映射到可写的内存位置（本身或许算不上一个真正的漏洞；no identified assigned.）
我其他的任天堂音乐播放器上发现，都不允许在0x8000地址以下进行ROM加载或者库切换。但是这个特殊的播放器，通过在文件头中写入低于0x8000的ROM加载地址，或者通过向库寄存器0x5ff6或0x5ff7中写入（其他的模拟器甚至没有0x5ff6或0x5ff7这么低的库寄存器），却可以实现在0x8000地址以下进行写入：
    static nes6502_memwrite default_writehandler[] = {
      {0x0800, 0x1FFF, write_mirrored_ram},
      {0x4000, 0x4017, apu_write},
      {0x5FF6, 0x5FFF, nsf_bankswitch},
      {(uint32) - 1, (uint32) - 1, NULL}
    };
例如，向0x5ff6处写入0x00，会使得ROM中的前4096字节在6502虚拟地址0x6000处映射为可读可写。在我们200字节的文件样例中，这个操作意味着通过向虚拟地址0x6048写入一串0x41，会导致这一串0x41被越界写到对应的主机上模拟器的堆中。
可以发现，现在我们对主机上模拟器的堆，有了很多读写方面的控制，一些经验丰富的漏洞挖掘人员或许已经意识到一次漏洞利用已经可以确定了。
**漏洞利用：概览**
下面是在okteta（一个16进制编辑器）中查看的漏洞利用文件：
图上可以看到的是一个完整的漏洞利用文件，文件被压缩到仅仅416字节。途中标出了三种颜色的线条，表示漏洞利用文件中的不同部分。
蓝色，表示128字节的文件头。文件头大部分的字节都与漏洞利用不相关，因此实际上，一些高明的漏洞利用技术会把一些payload压缩到文件头中，以增大空间利用率。你也可以尝试将这种方法应用到这个漏洞中来，使用尽可能少的字节实现相同的功能，这将会是一个很有意思的挑战:)而文件头中重要的字段列举如下：
位于0x08偏移的0x8000（使用小端存储，下面也是）。表示ROM虚拟加载地址。
位于0x0A偏移的0x8070。表示6502初始例程（调用一次）的虚拟地址。
位于0x0C偏移的0x80a0。表示6502每帧例程的虚拟地址。
位于0x6E偏移的0x41A1。表示帧对时。为了确保音频引擎正常工作，需要保留该数值。
橘色，表示元数据，位于ROM的开始，紧随文件头之后。这些元数据会被加载到虚拟地址0x8000处，可以由6502程序获取和使用。元数据中包含字符串“xcalc”，即我们的payload，一个用来在堆中搜索定位的常量（使漏洞利用更可靠），和一个向堆中执行读取、增加、写入的操作表，以实现漏洞利用。
绿色，表示真正的6502操作指令。漏洞利用会通过一个使用6502汇编语言编写的程序继续进行。由于上述的漏洞细节，音频播放模拟器会在主机上模拟器的堆中模拟这些指令。
**漏洞利用：细节**
到底漏洞利用文件是怎么做到在如此小的体积下实现弹出一个计算器的呢？文件大小是416字节：128字节的文件头和288字节的ROM，其中ROM被映射到虚拟6502地址0x8000。ROM中包含一些元数据和一些6502指令。
为了探索6502以及“编译”6502汇编代码，推荐这个网站：Easy 6502。这个网页声称“6502 is
fun！”——我也这么认为。详细注释指令操作的6502汇编代码可以从这里找到：asm_final_main.asm。还有一些附加小程序：asm_final_init.asm，asm_final_adder.asm。
漏洞利用后续步骤：
**1：在堆中定位nes6502_context类型的重要元数据对象**
因为上面提到的漏洞，任何从0x8120 –
0xffff的读操作都会导致越界读取，所以我们因此可以一直进行越界读取，直到找到主机的堆中对应nes6502_context的对象，nes6502_context的定义如下：
    typedef struct
    {
       uint8 * mem_page[NES6502_NUMBANKS];  /* memory page pointers */
       ...
       nes6502_memread *read_handler;
       nes6502_memwrite *write_handler;
       int dma_cycles;
       uint32 pc_reg;
       uint8 a_reg, p_reg, x_reg, y_reg, s_reg;
       uint8 int_pending;
    } nes6502_context;
为什么非要定位这个对象？有两个原因。第一，它控制6502虚拟内存如何访问到主机堆的内存映射。通过控制映射，我们能够获取到主机进程的虚拟内存上任何位置的读写权限。第二，它包含指向BSS段的指针。而定位BSS段在之后的漏洞利用中很重要。
**2：重新映射6502可读写的虚拟地址0x6000，使其指向nes6502_context::mem_page[6]**
下面的代码是通过写入魔法硬件寄存器，将0x6000映射到越界ROM外：
    ; 一些非常简单的计算和内存库的重映射。
    ; 匹配的地址存储在0x02。例如：0x91b0
    ; 从匹配的地址减去0x60。
    ; 这将更早地索引到堆中的元数据对象。
    ; 即索引到一个指向6502 0x6xxx RAM的堆指针
    ; 减去0x8000，得到距离ROM基址的偏移量。
    LDA $02
    SEC
    SBC #$60
    STA $02
    LDA $03
    SBC #$80
    STA $03
    ; 现在，0x02包含了结果。即与例子相对应的0x1160。
    ; 进行移位操作，获取ROM对应的库号，即最高位的值。
    ; 每个库的大小都是0x1000
    LSR
    LSR
    LSR
    LSR
    ; 在这个例子中，我们的库号是1。