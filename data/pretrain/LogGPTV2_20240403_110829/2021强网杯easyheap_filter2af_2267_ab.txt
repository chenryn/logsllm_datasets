    def RevSwap2(Out):
        res = [0]*16
        swap_tab = [0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11]
        for i in range(16):
            res[swap_tab[i]] = Out[i]
        return res
    Out = RevSwap2(Out)
  * 字母表变换
    # [144, 41, 26, 235, 230, 3, 232, 248, 31, 129, 16, 133, 73, 81, 174, 54]
    Out = [96, 165, 162, 233, 142, 123, 155, 65, 192, 12, 202, 151, 59, 209, 228, 5]
    Alpha = [ 99, 124, 119, 123, 242, 107, 111, 197,  48,   1, 
      103,  43, 254, 215, 171, 118, 202, 130, 201, 125, 
      250,  89,  71, 240, 173, 212, 162, 175, 156, 164, 
      114, 192, 183, 253, 147,  38,  54,  63, 247, 204, 
       52, 165, 229, 241, 113, 216,  49,  21,   4, 199, 
       35, 195,  24, 150,   5, 154,   7,  18, 128, 226, 
      235,  39, 178, 117,   9, 131,  44,  26,  27, 110, 
       90, 160,  82,  59, 214, 179,  41, 227,  47, 132, 
       83, 209,   0, 237,  32, 252, 177,  91, 106, 203, 
      190,  57,  74,  76,  88, 207, 208, 239, 170, 251, 
       67,  77,  51, 133,  69, 249,   2, 127,  80,  60, 
      159, 168,  81, 163,  64, 143, 146, 157,  56, 245, 
      188, 182, 218,  33,  16, 255, 243, 210, 205,  12, 
       19, 236,  95, 151,  68,  23, 196, 167, 126,  61, 
      100,  93,  25, 115,  96, 129,  79, 220,  34,  42, 
      144, 136,  70, 238, 184,  20, 222,  94,  11, 219, 
      224,  50,  58,  10,  73,   6,  36,  92, 194, 211, 
      172,  98, 145, 149, 228, 121, 231, 200,  55, 109, 
      141, 213,  78, 169, 108,  86, 244, 234, 101, 122, 
      174,   8, 186, 120,  37,  46,  28, 166, 180, 198, 
      232, 221, 116,  31,  75, 189, 139, 138, 112,  62, 
      181, 102,  72,   3, 246,  14,  97,  53,  87, 185, 
      134, 193,  29, 158, 225, 248, 152,  17, 105, 217, 
      142, 148, 155,  30, 135, 233, 206,  85,  40, 223, 
      140, 161, 137,  13, 191, 230,  66, 104,  65, 153, 
       45,  15, 176,  84, 187,  22]
    def revAlpha(Out):
        res = []
        for C in Out:
            res.append(Alpha.index(C))
        return res
  * 接着式10次组合变换, 可以概括为
    do 
    {
        字典变换16B: input[i] = Alpha[input[i]]
        位移变换;
        Func()的变换;
        XOR_Buf2(input, i)
        ++i;
    }
    while ( 10 != i );
  * 逆向逻辑
    for i in range(9, 0, -1):
        revXOR_Buf2(input, i)
        reFunc()
        re位移变换
        re字典变换
代码:
    # [8, 7, 6, 5, 4, 3, 2, 1, 116, 111, 95, 81, 87, 66, 50, 49]
    Out = [144, 41, 26, 235, 230, 3, 232, 248, 31, 129, 16, 133, 73, 81, 174, 54]
    for i in range(9, 0, -1):
        Out = revXOR_Buf2(Out, i)
        Out = Solve16B(Out)
        Out = RevSwap2(Out)
        Out = revAlpha(Out)
  * 然后别忘了一开始还有一个异或变换
###  逆向exp
  * 把上面的综合起来, 就得到了函数sub_EC0()的逆函数, 拿来逆向题目中保存的HEX字符串  
    from z3 import *
    Out = [0x95, 0x86, 0xda, 0x81, 0xf6, 0xf7, 0x56, 0xda, 0x45, 0xf2, 0x03, 0xa9, 0x57, 0x9a, 0xcc, 0xde]
    def HEX(arr):
        a = ''
        for C in arr:
            a+= hex(C)
            a+= ' '
        print(a)
    def Str(Arr):
        res = ''
        for c in Arr:
            res+=chr(c)
        return res
    def Hex2Arr(Hex):
        res = []
        for i in range(0, len(Hex), 2):
            C = int(Hex[i: i+2], 16)
            res.append(C)
        return res
    def FuckEC0(Out):
        buf2 = [87, 51, 49, 67, 48, 77, 51, 95, 116, 111, 95, 81, 87, 66, 50, 49, 
                122, 16, 246, 24, 74, 93, 197, 71, 62, 50, 154, 22, 105, 112, 168, 
                39, 41, 210, 58, 225, 99, 143, 255, 166, 93, 189, 101, 176, 52, 205, 
                205, 151, 144, 111, 178, 249, 243, 224, 77, 95, 174, 93, 40, 239, 154, 
                144, 229, 120, 248, 182, 14, 65, 11, 86, 67, 30, 165, 11, 107, 241, 
                63, 155, 142, 137, 252, 175, 169, 52, 247, 249, 234, 42, 82, 242, 129, 
                219, 109, 105, 15, 82, 37, 217, 169, 8, 210, 32, 67, 34, 128, 210, 194, 
                249, 237, 187, 205, 171, 143, 100, 203, 93, 93, 68, 136, 127, 221, 150, 
                74, 134, 48, 45, 135, 45, 215, 115, 19, 89, 138, 55, 155, 38, 87, 161, 
                209, 160, 103, 140, 86, 141, 168, 194, 78, 220, 34, 245, 213, 250, 117, 
                84, 4, 90, 18, 216, 82, 215, 255, 194, 64, 21, 221, 55, 149, 239, 168, 
                99, 145, 181, 186, 187, 195, 98]
        Alpha = [ 99, 124, 119, 123, 242, 107, 111, 197,  48,   1, 
          103,  43, 254, 215, 171, 118, 202, 130, 201, 125, 
          250,  89,  71, 240, 173, 212, 162, 175, 156, 164, 
          114, 192, 183, 253, 147,  38,  54,  63, 247, 204, 
           52, 165, 229, 241, 113, 216,  49,  21,   4, 199, 
           35, 195,  24, 150,   5, 154,   7,  18, 128, 226, 
          235,  39, 178, 117,   9, 131,  44,  26,  27, 110, 
           90, 160,  82,  59, 214, 179,  41, 227,  47, 132, 
           83, 209,   0, 237,  32, 252, 177,  91, 106, 203, 
          190,  57,  74,  76,  88, 207, 208, 239, 170, 251, 
           67,  77,  51, 133,  69, 249,   2, 127,  80,  60, 
          159, 168,  81, 163,  64, 143, 146, 157,  56, 245, 
          188, 182, 218,  33,  16, 255, 243, 210, 205,  12, 
           19, 236,  95, 151,  68,  23, 196, 167, 126,  61, 
          100,  93,  25, 115,  96, 129,  79, 220,  34,  42, 
          144, 136,  70, 238, 184,  20, 222,  94,  11, 219, 
          224,  50,  58,  10,  73,   6,  36,  92, 194, 211, 
          172,  98, 145, 149, 228, 121, 231, 200,  55, 109, 
          141, 213,  78, 169, 108,  86, 244, 234, 101, 122, 
          174,   8, 186, 120,  37,  46,  28, 166, 180, 198, 
          232, 221, 116,  31,  75, 189, 139, 138, 112,  62, 
          181, 102,  72,   3, 246,  14,  97,  53,  87, 185, 
          134, 193,  29, 158, 225, 248, 152,  17, 105, 217, 
          142, 148, 155,  30, 135, 233, 206,  85,  40, 223, 
          140, 161, 137,  13, 191, 230,  66, 104,  65, 153, 
           45,  15, 176,  84, 187,  22]
        def revXOR_Buf2(Out, num):
            arr = []
            for i in range(16):
                arr.append(Out[i]^buf2[num*16+i])
            return arr
        def RevSwap2(Out):
            res = [0]*16
            swap_tab = [0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11]
            for i in range(16):
                res[swap_tab[i]] = Out[i]
            return res
        def revAlpha(Out):
            res = []
            for C in Out:
                res.append(Alpha.index(C))
            return res
        def Solve4B(I0, I1, I2, I3):
            A, B, C, D = BitVecs("A B C D", 8)
            FA, FB, FC, FD = BitVecs("FA FB FC FD", 8)
            s = Solver()
            s.add(FA == (A*2)^(((A&0x80)/0x80)*0x1B))
            s.add(FB == (B*2)^(((B&0x80)/0x80)*0x1B))
            s.add(FC == (C*2)^(((C&0x80)/0x80)*0x1B))
            s.add(FD == (D*2)^(((D&0x80)/0x80)*0x1B))
            s.add(I0 == FA^FB^B^C^D)
            s.add(I1 == A^FB^C^FC^D)
            s.add(I2 == A^B^FC^FD^D)
            s.add(I3 == FA^A^B^C^FD)
            s.check()
            m = s.model()
            return m[A].as_long(), m[B].as_long(), m[C].as_long(), m[D].as_long()
        def Solve16B(R):
            res = []
            for i in range(0, 16, 4):
                A, B, C, D = Solve4B(R[i+0], R[i+1], R[i+2], R[i+3])
                res.append(A)
                res.append(B)
                res.append(C)
                res.append(D)
            return res
        Out = revXOR_Buf2(Out, 10)
        Out = RevSwap2(Out)
        Out = revAlpha(Out)
        for i in range(9, 0, -1):
            Out = revXOR_Buf2(Out, i)
            Out = Solve16B(Out)
            Out = RevSwap2(Out)
            Out = revAlpha(Out)
        Out = revXOR_Buf2(Out, 0)
        return Out
    encs = ['cdb71018a63272140c7c8645eb7d6f5c',
           '11be0ce48d20e2eaee1eac4d5c16827b',
           '39c16e79920d5d584d0c1a1b7c14f363',
           '6c37c505b19256687b0dd9ed42ccf2d0',
           'c5d6c1af456d1a48f2fe46b35f9a4f2c']
    for h in encs:
        E = Hex2Arr(h)
        D = FuckEC0(E)
        print(D)
    '''
    [81, 87, 66, 95, 67, 114, 51, 52, 116, 51, 0, 0, 0, 0, 0, 0]
    [81, 87, 66, 95, 68, 51, 108, 51, 84, 101, 0, 0, 0, 0, 0, 0]
    [81, 87, 66, 95, 67, 104, 51, 67, 107, 0, 0, 0, 0, 0, 0, 0]
    [81, 87, 66, 95, 77, 48, 100, 49, 70, 121, 0, 0, 0, 0, 0, 0]
    [81, 87, 66, 95, 71, 48, 48, 100, 66, 121, 101, 0, 0, 0, 0, 0]
    '''
## 程序分析
  * 本题是两级界面, 先是最开始的界面, 然后Prepare中又有一个界面
  * Prepare: 
    * Create: 
      * 最多20个
      * 读入num: num<=0x23
      * NumBufArr[idx].cnt = num
      * NumBufArr[idx].ptr = calloc(4*(num+1))作为缓冲区
      * 并读入num个数字
      * 随机化+ – * 计算所有数字得到最后一个数字
    * Delete: 
      * 读入idx, idx<=19
      * free(NumBufArr[idx].ptr)
      * NumBufArr[idx].ptr = NULL
      * NumBufArr[idx].cnt = 0
    * Check: 
      * 读入idx, idx<=19
      * %d输出所有的num
    * Edit 
      * 读入cnt+1个数字, 最后的随机数会产生堆溢出 
  * Challenge 
    * 遍历所有游戏, 每局可以有三个选择, 每局的结果记录在GAME_Res缓冲器中, 属于mmap出来的 
      * next_next: 直接调过这一局, 每次challenge可以用两次
      * whos_your_daddy: 直接写入nump_ptr中指定位置数字, 全局可用两次
      * 数字: 再GAME_Res中记录下来
    * 然后遍历所有结果, 检验猜的对不对: NumBuf[level].ptr[cnt] == GAME_Res[level]
    * 如果全部猜对并且比上一个更多更快就可以 记录成绩, 写入name,
  * 记录成绩:
    struct Record{
        size len;
        char Name[len];
        size_t padding;
        Grade* grade;
    };
## 思路
  * 根据之前学习的musl-1.2的chunk结构, 一个chunk需要4B元数据记录offset与index等, 本题可以溢出一个int, 那么如果前一个chunk为0x2C的话, 那么溢出4B就会覆盖掉后一个chunk的元数据, 然后伪造offset, idx, 伪造meta, 从而通过nontrivial_free()触发dequeue()操作, 最终可以达到一个指针任意写的效果