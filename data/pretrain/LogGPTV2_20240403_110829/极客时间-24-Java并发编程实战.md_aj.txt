## 安全性问题相信你一定听说过类似这样的描述：这个方法不是线程安全的，这个类不是线程安全的，等等。那什么是线程安全呢？其实本质上就是正确性，而正确性的含义就是**程序按照我们期望的执行**，不要让我们感到意外。在[第一篇《可见性、原子性和有序性问题：并发编程Bug的源头》](https://time.geekbang.org/column/article/83682)中，我们已经见识过很多诡异的Bug，都是出乎我们预料的，它们都没有按照我们**期望**的执行。那如何才能写出线程安全的程序呢？[第一篇文章](https://time.geekbang.org/column/article/83682)中已经介绍了并发Bug的三个主要源头：原子性问题、可见性问题和有序性问题。也就是说，理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题。那是不是所有的代码都需要认真分析一遍是否存在这三个问题呢？当然不是，其实只有一种情况需要：**存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据**。那如果能够做到不共享数据或者数据状态不发生变化，不就能够保证线程的安全性了嘛。有不少技术方案都是基于这个理论的，例如线程本地存储（ThreadLocalStorage，TLS）、不变模式等等，后面我会详细介绍相关的技术方案是如何在Java 语言中实现的。``{=html}但是，现实生活中，**必须共享会发生变化的数据**，这样的应用场景还是很多的。当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发Bug，对此还有一个专业的术语，叫做**数据竞争**（DataRace）。比如，前面[第一篇文章](https://time.geekbang.org/column/article/83682)里有个add10K() 的方法，当多个线程调用时候就会发生**数据竞争**，如下所示。    public class Test {  private long count = 0;  void add10K() {    int idx = 0;    while(idx++  amt) {      this.balance -= amt;      target.balance += amt;    }  } }所以你也可以按照下面这样来理解**竞态条件**。在并发场景中，程序的执行依赖于某个状态变量，也就是类似于下面这样：    if (状态变量 满足 执行条件) {  执行操作}当某个线程发现状态变量满足执行条件后，开始执行操作；可是就在这个线程执行操作的时候，其他线程同时修改了状态变量，导致状态变量不满足执行条件了。当然很多场景下，这个条件不是显式的，例如前面addOne 的例子中，set(get()+1) 这个复合操作，其实就隐式依赖 get()的结果。那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用**互斥**这个技术方案，而实现**互斥**的方案有很多，CPU提供了相关的互斥指令，操作系统、编程语言也会提供相关的API。从逻辑上来看，我们可以统一归为：**锁**。前面几章我们也粗略地介绍了如何使用锁，相信你已经胸中有丘壑了，这里就不再赘述了，你可以结合前面的文章温故知新。
## 活跃性问题所谓活跃性问题，指的是某个操作无法执行下去。我们常见的"死锁"就是一种典型的活跃性问题，当然**除了死锁外，还有两种情况，分别是"活锁"和"饥饿"**。通过前面的学习你已经知道，发生"死锁"后线程会互相等待，而且会一直等待下去，在技术上的表现形式是线程永久地"阻塞"了。但**有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的"活锁"**。可以类比现实世界里的例子，路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。这种情况，基本上谦让几次就解决了，因为人会交流啊。可是如果这种情况发生在编程世界了，就有可能会一直没完没了地"谦让"下去，成为没有发生阻塞但依然执行不下去的"活锁"。解决"**活锁**"的方案很简单，谦让时，尝试等待一个随机的时间就可以了。例如上面的那个例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。"等待一个随机时间"的方案虽然很简单，却非常有效，Raft这样知名的分布式一致性算法中也用到了它。那"**饥饿**"该怎么去理解呢？**所谓"饥饿"指的是线程因无法访问所需资源而无法执行下去的情况**。"不患寡，而患不均"，如果线程优先级"不均"，在CPU繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程"饥饿"；持有锁的线程，如果执行的时间过长，也可能导致"饥饿"问题。解决"**饥饿**"问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。
## 性能问题使用"锁"要非常小心，但是如果小心过度，也可能出"性能问题"。"锁"的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能。所以我们要尽量减少串行，那串行对性能的影响是怎么样的呢？假设串行百分比是5%，我们用多核多线程相比单核单线程能提速多少呢？有个阿姆达尔（Amdahl）定律，代表了处理器并行运算之后效率提升的能力，它正好可以解决这个问题，具体公式如下：```{=html}```]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[S[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.049em;"}]{#09.html#MathJax-Span-3.mistyle="font-family: MathJax_Math-italic;"}[=]{#09.html#MathJax-Span-4.mostyle="font-family: MathJax_Main; padding-left: 0.285em;"}[1]{#09.html#MathJax-Span-6.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.391em, 1000.28em, 4.144em, -999.998em); top: -4.374em; left: 50%; margin-left: -0.186em;"}(]{#09.html#MathJax-Span-8.mostyle="font-size: 70.7%; font-family: MathJax_Main;"}[1]{#09.html#MathJax-Span-9.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}[−]{#09.html#MathJax-Span-10.mostyle="font-size: 70.7%; font-family: MathJax_Main;"}[p]{#09.html#MathJax-Span-11.mistyle="font-size: 70.7%; font-family: MathJax_Math-italic;"}[)]{#09.html#MathJax-Span-12.mostyle="font-size: 70.7%; font-family: MathJax_Main;"}[+]{#09.html#MathJax-Span-13.mostyle="font-size: 70.7%; font-family: MathJax_Main;"}[p]{#09.html#MathJax-Span-15.mistyle="font-size: 50%; font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.626em, 1000.24em, 4.238em, -999.998em); top: -4.421em; left: 50%; margin-left: -0.139em;"}[[n]{#09.html#MathJax-Span-16.mistyle="font-size: 50%; font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.626em, 1000.28em, 4.144em, -999.998em); top: -3.762em; left: 50%; margin-left: -0.139em;"}[[]{style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.426em; height: 0px;"}[]{style="display: inline-block; width: 0px; height: 1.085em;"}]{style="position: absolute; clip: rect(0.896em, 1000.43em, 1.226em, -999.998em); top: -1.221em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.426em; height: 0px; margin-right: 0.144em; margin-left: 0.144em;"}]{#09.html#MathJax-Span-14.mfrac}]{#09.html#MathJax-Span-7.mrow}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1003.01em, 4.379em, -999.998em); top: -3.433em; left: 50%; margin-left: -1.504em;"}[[]{style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 3.155em; height: 0px;"}[]{style="display: inline-block; width: 0px; height: 1.085em;"}]{style="position: absolute; clip: rect(0.896em, 1003.15em, 1.226em, -999.998em); top: -1.315em; left: 0em;"}]{style="display: inline-block; position: relative; width: 3.155em; height: 0px; margin-right: 0.144em; margin-left: 0.144em;"}]{#09.html#MathJax-Span-5.mfrac style="padding-left: 0.285em;"}]{#09.html#MathJax-Span-2.mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.367em, 1005.46em, 3.296em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 5.461em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -1.056em; border-left: 0px solid; width: 0px; height: 2.179em;"}]{#09.html#MathJax-Span-1.mathstyle="width: 6.826em; display: inline-block;"}``{=html}[$S = \frac{1}{(1 - p) + \frac{p}{n}}$]{.MJX_Assistive_MathMLrole="presentation"}]{#09.html#MathJax-Element-1-Frame .MathJaxtabindex="0" style="position: relative;"mathml="S=1(1−p)+pn"role="presentation"}$$```{=html}```公式里的 n 可以理解为 CPU 的核数，p可以理解为并行百分比，那（1-p）就是串行百分比了，也就是我们假设的5%。我们再假设 CPU 的核数（也就是 n）无穷大，那加速比 S 的极限就是20。也就是说，如果我们的串行率是5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。所以使用锁的时候一定要关注对性能的影响。那怎么才能避免锁带来的性能问题呢？这个问题很复杂，**Java SDK并发包里之所以有那么多东西，有很大一部分原因就是要提升在某个特定领域的性能**。不过从方案层面，我们可以这样来解决这个问题。第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储(Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java并发包里面的原子类也是一种无锁的数据结构；Disruptor则是一个无锁的内存队列，性能都非常好......第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是Java 并发包里的ConcurrentHashMap，它使用了所谓分段锁的技术（这个技术后面我们会详细介绍）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。性能方面的度量指标有很多，我觉得有三个指标非常重要，就是：吞吐量、延迟和并发量。1.  吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。2.  延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。3.  并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是    1000 的时候，延迟是 50 毫秒。
## 总结并发编程是一个复杂的技术领域，微观上涉及到原子性问题、可见性问题和有序性问题，宏观则表现为安全性、活跃性以及性能问题。我们在设计并发程序的时候，主要是从宏观出发，也就是要重点关注它的安全性、活跃性以及性能。安全性方面要注意数据竞争和竞态条件，活跃性方面需要注意死锁、活锁、饥饿等问题，性能方面我们虽然介绍了两个方案，但是遇到具体问题，你还是要具体分析，根据特定的场景选择合适的数据结构和算法。要解决问题，首先要把问题分析清楚。同样，要写好并发程序，首先要了解并发程序相关的问题，经过这7章的内容，相信你一定对并发程序相关的问题有了深入的理解，同时对并发程序也一定心存敬畏，因为一不小心就出问题了。不过这恰恰也是一个很好的开始，因为你已经学会了分析并发问题，然后解决并发问题也就不远了。
## 课后思考Java 语言提供的 Vector是一个线程安全的容器，有同学写了下面的代码，你看看是否存在并发问题呢？    void addIfNotExist(Vector v,     Object o){  if(!v.contains(o)) {    v.add(o);  }}欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/f2ae29f2a91a0266d9d86db774df526d.png){savepage-src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg"}
# 08 \| 管程：并发编程的万能钥匙并发编程这个技术领域已经发展了半个世纪了，相关的理论和技术纷繁复杂。那有没有一种核心技术可以很方便地解决我们的并发问题呢？这个问题如果让我选择，我一定会选择**管程**技术。Java语言在 1.5 之前，提供的唯一的并发原语就是管程，而且 1.5 之后提供的 SDK并发包，也是以管程技术为基础的。除此之外，C/C++、C#等高级语言也都支持管程。可以这么说，管程就是一把解决并发问题的万能钥匙。
## 什么是管程不知道你是否曾思考过这个问题：为什么 Java 在 1.5 之前仅仅提供了synchronized 关键字及 wait()、notify()、notifyAll()这三个看似从天而降的方法？在刚接触 Java的时候，我以为它会提供信号量这种编程原语，因为操作系统原理课程告诉我，用信号量能解决所有并发问题，结果我发现不是。后来我找到了原因：Java采用的是管程技术，synchronized 关键字及 wait()、notify()、notifyAll()这三个方法都是管程的组成部分。而**管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程**。但是管程更容易使用，所以Java 选择了管程。管程，对应的英文是 Monitor，很多 Java领域的同学都喜欢将其翻译成"监视器"，这是直译。操作系统领域一般都翻译成"管程"，这个是意译，而我自己也更倾向于使用"管程"。``{=html}所谓**管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发**。翻译为Java领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。那管程是怎么管的呢？