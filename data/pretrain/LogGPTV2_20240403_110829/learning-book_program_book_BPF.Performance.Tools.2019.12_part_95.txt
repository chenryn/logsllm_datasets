18.8
MissingStacksTraces
This is where printed stack traces look incomplete or are completely missing. It may also involve
missing symbols (covered Section 18.9) so that frames appear as * [unknown] °.
Here is some example output, using BCC trace(8) to print user-level stack traces for the execvel)
tracepoint (new process execution):
+ trace -0 t:syscalls:sys_enter_execve
PID
TID
COMN
FUNC
E599Z
qseg 589
sya_enter_execve
[unknox]
[unknoxn]
26854
qseg 589z
sys_enter_execve
[unknoxm]
[unknoxn]
[...]
This is another opportunity to use perf(1) for cross-checks before dligging deeper into
BCC/BPF debugging. Reproducing this task using perf(1):
"C[ perf recozd: Noken up l tines to vzlte data ]
I perf zecord: Captured and vrote 3.246 MB perf.data (2 sarples) 1
qdtass gzed +
bash 26967 [007] 2209173 .697359: sysca1lls:sys_enter_execve: filename: 0x56172df05030
axqv: 0x56172df3b680, envp: 0x56172af2df00
e4e37 _G1_execve (/lib/x8_641inux=gnu/1ibc=2.27-so)
561T2dr05010 [unknoun]([unknown]]
argv: 0x56172df04440, envp : 0x56172df2df00
e4e37 GI__execve (/11b/x86_641inux=gnu/1ibc=2.27_so1
56172df05070[unknon]([unknoxn]]
This shows similar broken stacks. There are three problems:
Stacks are incomplete. They are tracing the bash(1) shell calling a new program: I know
from prior experience that it is several frames deep, yet only two frames (lines) are shown
above. If your stack traces are one or two lines long and don’t end with an initial frame
(e.g., *main° or *star_thread°), it's reasonable to assume that they may be incomplete
as well.
---
## Page 775
3 Chapter 18 Tips, Tricks, and Common Problems
•The last line is [unknown]. Even perf(1) could not resolve the symbol. There may be a
problem with symbols in bash(1), or libc's _GI__execve() may have trampled the frame
pointer, breaking further walking
• The libc _GI_exceve() call was seen by perf(1) but is not in BCC's output. This points
to another problem with BCC's trace(8) that should be fixed.°
18.8.1 How to Fix Broken Stack Traces
Incomplete stack traces are unfortunately common and are usually caused by a confluence of tvo
factors: (1) the observability tool using a frame pointer-based approach for reading the stack trace
and (2) the target binary not reserving a register (RBP on x86_64) for the frame pointer, instead
reusing it as a general-purpose register, as a compiler performance optimization. The observability
tool reads this register expecting it to be a frame pointer, but in fact it now could contain
anything: numbers, object address, pointers to strings. The observability tool tries to resolve this
number in the symbol table and, if it is lucky, it doesn’t find it and can print “[unknown]°. If it is
unlucky, that random number resolves to an unrelated symbol, and now the printed stack trace
has a function name that is wrong, confusing the end user.
The easiest fix is usually to fix the frame pointer register:
 For C/C++ software and other software compiled with gcc or LLVM: Recompile the
 For Java: Run java(1) with XX : +PreserveFranePo.inter.
This may come with a performance cost, but it has often been measured at less than 1%; the bene
fits of being able to use stack trace to find performance wins usually far outweigh this cost. These
are also discussed in Chapter 12.
The other approach is to switch to a stack walking technique that is not frame pointer based.
perf(1) supports DWARF-based stack walking, ORC, and last branch record (LBR). At the time of
writing, DWARF-based and LBR stack walking are not available from BPE, and ORC is not yet avail-
able for user-level software. For more on this topic, see Section 2.4 in Chapter 2.
18.9MissingSymbols(Function Names)WhenPrinting
This is where symbols are not printed correctly in stack traces or via symbol lookup functions:
One culprit is broken stacks, explained in the previous section. Another is short-lived processe
instead of function names, they are shown as hexadecimal numbers or the string *[unknown]°
that exit before the BPF tool can read its address space and look up symbol tables. A third is that
the symbol table information is not available. How to fix this differs between JIT runtimes and
ELF binaries.
6 1 would guess that perf(1) may have used debuginfo to get thst frame. See 8 similer inestigation in bpfrace #646 [179]
---
## Page 776
18.10 Missing Functions When Tracing  739
18.9.1 How to Fix Missing Symbols: JIT Runtimes (Java, Node.js, )
Missing symbols commonly occur for just-in-time (JIT) compiler runtimes like Java and Node.js.
In those cases, the JIT compiler has its own symbol table that is changing at runtime and is not
part of the pre-compiled symbol tables in the binary. The common fix is to use supplemental
symbol tables generated by the runtime, which are placed in /tmp/perf-.map files read by
both perf(1) and BCC. This approach, some caveats, and future work are discussed in Section 12.3
of Chapter 12.
18.9.2 How to Fix Missing Symbols: ELF binaries (C, C++, )
pue paleqoed are peq asoq Aepadsa saseunq pagdtuoo uos Sussuu aq Aewu sjoqus
distributed, as they have been processed using strip(1) to reduce their file size. One fix is to
adljust the build process to avoid stripping symbols; another is to use a different source of symbol
information, such as debuginfo or BTE BCC and bpftrace support debuginfo symbols. These
approaches, caveats, and future work are discussed in Section 12.2 of Chapter 12.
18.10MissingFunctions When Tracing
This is where a known function cannot be traced with uprobes, uretprobes, kprobes, or
kretprobes: it appears to be missing or doesn’t fire. The problem may be missing symbols
(covered earlier). It may also be due to compiler optimizations, or other reasons:
• Inlining: With inlining, the function instructions have been included in the calling
function. This can happen for functions with few instructions, to save making call, ret, and
aq Aeu n no aaduoo auo aq eu poqs uooung au1 suoonstu anooad uooun
present but not fire for that code path.
• Tail-call optimization: When the code flow is A()->B()->C0, and C0 is called last in B(),
then the compiler may have C( return directly to A() as an optimization. This means the 
uretprobe or kretprobe for the function does not fire.
• Static and dynamic linking: This is where a uprobe defines a function to be in a library,
but the target software has switched from dynamic to static linking, and the function
location has changed: it is now in the binary. The same is possible in reverse, where a
uprobe defines a function to be in a binary, but it has since moved to a shared library.
Dealing with this may mean tracing a different event: the parent function, a child function, or
a neighboring function. kprobes and uprobes also support instruction offset tracing (bpftrace
should support this in the future), so the location of an inlined function can be instrumented if
you know its offset.
---
## Page 777
740
Chapter 18 Tips, Tricks, and Common Problems
18.11FeedbackLoops
If you trace yourself tracing, you can create a feedback loop
Examples of things to avoid:
# bpftrace -e 'k:ext4_file_vrite_iter[ printf(-..) )' > /ext4fs/out.file
The first two will accidentally trace the bpftrace printf() event by creating another printf() event,
which is traced and creates another. The event rate will explode, creating a performance issue
until you can kill bpftrace.
The third does the same as bpftrace triggers ext4 writes to save the output, which causes more
output to be generated and saved, and so on.
You can avoid this by using filters to exclude tracing your own BPF tool or just trace the target
process of interest.,
18.12Dropped Events
Be aware of dropped events rendering the tool output incomplete.
BPF tools can emit output so quickly that it overflows the perf output buffer, or can try to save too
many stack IDs and overflow the BPF stack map, etc.
For example:
+ profile
[.--]
WARNING: 5 stack traces could not be displayed.
The tools should tel you when events have been dropped, as the output above shows. These drops
can often be fixed by tuning. profile(8), for example, has the stack=s toxagesize option
  es ab e'a aros u p q s de ses a jo as a aseu o
tuning becomes commonplace, the tool defaults should be updlated so that users do not need to
change them.
---
## Page 778
Appendix A
bpftrace One-Liners
This is a selection of one-liners used throughout this book.
Chapter6CPUs
New processes with arguments:
Syscall count by process:
Sample running process name at 99 Hertz:
Sample user-level stacks at 49 Hertz, for PID 189:
(11un0 =[xoe1en]8)/68t *= ptd/ 6f:zg:e11goxd, 8-8oexado
Trace new threads via pthread_create():
printf (*$s by gs lidln*。 probe, conn, pidl: }*
Chapter7Memory
:qμed apoo q (0sμq) uogsuredxa deaq ssaoosd quno
bpftrace -e tracepointisyscalls:sys_enter_brk ( 8[ustack, comm] = countll: )
Count page faults by process:
1 ()qunoo =[ptd uuoo] e 1 Tianegsbedianengos, a-aoesngdg
Count user page faults by user-level stack trace:
opftrace -e
tracepointiexceptionsipage_faul t_ua
count () ;I*
e[ustack
---
## Page 779
742
Appendix A
Count vmscan operations by tracepoint:
[1++ [eqoxd]a1+1ueosus:sutodeoexs. 8-8oexsgdg
Chapter8FileSystems
Trace files opened via open(2) with process name:
uxoo *0)5s 5s)uxd 1usdoxexuess1s1te0ss1a。8-8oexadg
str (args=>filenanel) : )*
Show the distribution of read() syscallrequest sizes:
Show the distribution of read() syscall read bytes (and errors):
bpftrace -e *tracepointiayscallsiays_exit_read  θ = hist(args->ret) : 
Count VFS calls:
bpftrace -e *kprobeivfs_* I@[probe] = count () : 1*
Count ext4 tracepoints:
Chapter9Disk1/0
Count block I/O tracepoints:
Summarize block I/O size as a histogram:
bpftrace -e *t:block:block_rg_issue [ Bbytes = hist (args->bytes); ) 
Count block I/O request user stack traces:
Count block I/O type flags:
Trace block 1/O errors with device and I/O type:
1/2oaadev, args->zwbs, axgs->exror
Count SCSI opcodes:
[opoodoresult] = count ll: )′
---
## Page 780
bpftrace One-Liners
743
Count scsi driver funcitons:
Chapter10Networking
Count socket accept(2)s by PID and process name:
Count socket conneet(2)s by PID and process name:
Count socket sendl/receive bytes by on-CPU PID and process name
1/0saddr)]
count (); 1*
UDP send bytes as a histogram:
1[z6xe]1etg =seqAqpuesg ) bsupuesdpnix。 8-eoexaydo
Count transmit kernel stack traces:
Chapter 11 Security
Count security audit events for PID 1234:
1f(1uno=[oung]e]EZt=prdanesx。88oexado
Trace pluggable authentication module (PAM) session starts:
xeas"wed:o*osuedqtt/muhxnutT→99gx/att/in。8- eoexagdog
printf(*es: $sn", str(arg01。 strlarg1)1= *
Trace kernel module loads:
bpftrace -e *tinodualermodule_load / printf(*load: $s^n", str(args=>nanell: )*
---
## Page 781
744
Appendix A
Chapter13Applications
Sum malloc( requested bytes by user stack trace (high overhead):
=[1s)oesn]e 1ootteu:oscz*zogtt/nu6-xnutt-#99ex/att/in。88oexagdo
10be)uns
Trace kilI0 signals showing sender process name, target PID, and signal number:
bpftrace -e *trsyscallsiays_enter_kill [ printf ("es -> PID ed SIG edn",
conm, axgs=>pid, args=>sig) ;F
Count libpthread mutex lock functions for one second:
1xoot,xesnu peeauad:g*os*peexuadatt/nuh-xnutt-#s9ex/att/in。8- eoexagdo
B[probe] = count(l: / interval:s:l ( exit(l: /*
Count libpthread conditional variable functions for one second:
bpftrace -e *u:/1ib/x86_64=1inux=gnu/1ibpthread.so.0:pth.read_cond_*(
B[pzobe] = count (1]) Intexval:a:1 [ exlt(1 )*
Chapter14Kernel
Count system calls by syscall function:
1xeques/sistteossxexiautodeoexa. 8-8oexagdo
B[ksym(* (kaddr I*ays_call_table*) + arga=>id * B) 1] = count 1) : )
Count kernel function calls starting with *attach":
bpftrace -e *kprobe:attach* 8 [probe] = count1/; }'
Time the kernel function vfs_read() and summarize as a histogram:
}/[pTa]sae/ peaa"sga1ax ( reoso = [pr]sag ) peaa"sga:), a- aoeagdg
B = hiat naecs - Bta[tid]); delete (ets[tid]l; ]'
Frequency count the first integer argument to kernel function *func1°:
Frequency count the return value from kernel function *func1°:
Sample kernel-level stacks at 99 Hertz, excluding idle:
:(f1um0o = [xoe15x]8 1/ptd/ 661zq:e1Tgoxd, 8-80exsgdg
Count context switch stack traces:
bpftrace -a *tisched:sched_svitch ( B[katack, ustack, conm] = count(1]; )
Count work queue requests by kernel function:
opftrace -e *t:voxkqueue :workqueue_execute_start ( B[kayn (arga=>function)] 
count()}
---
## Page 782
pendix
traceCheatSheet
Synopsis
(fuor2oe )/xe2z7g/ eqo.rd, 8-8oexgdq
Probes
BEGIN, END
Program start and end
tracepoint:syscalls:sys_enter_execve
execve(2) syscall
tracepoint:sysca11s:sys_enter_open
open(2) syscall(also trace openat(2)
tracepoint:syscalls:sys_exit_read
trace read(2) syscall return (one variant)
tracepoint:rav_syscalls:sys_enter
All syscalls
block:block_rq_Lnsezt
Queue block I/0 request
block:block_rq_lssue
Issue block I/0 request to storage device
block:block_rq_conplete
Block I/O completion
sock:inet_sock_set_state
Socket state change
sched:sched_process_exec
Process execution
sched: sched_sv1 tch
Context switch
sched:sched_vakeup
Thread wakeup event
software:faults: 1
Page faults
hardvare:cache-mlsses: 1000000
Once every 1,000,000 LLC cache miss
kprobe:vfs_read
Trace vfs_read() kemel function entry
kretprobe:vfs_read
Trace return of vfs_read() kernel function
uprobe: /bin/bash:read1ine
Trace readline0 from /bin/bash
uretprobe:/bin/bash:readline
Trace return of readline() from /bin/bash
usdt:path:probe
Trace USDT probe from path
prof11e:hz:99
Sample on all CPUs at 99 Hertz
Interval:s:1
Run on one CPU once per second
Probe Aliases
tracepoint
U
1psn
k.
kprobe
kr
kretprobe
P
profile
software
uprobe
ur
uretprobe
interval
---
## Page 783
746
Appendix B
Vars
comm
On-CPU process name
usernane
Username string
p1d,
t1d
On-CPU PID, Thread ID
uid
User ID
cpu
CPU ID
kstack
Kermel stack trace
n.sec.s
Time, nanoseconds
ustack
User stack trace
elapsed
Time since program start,
probe
Current full probe name
nsecs
argo..
[uk]probe arguments
func
Current function name 
axgs=>
Tracepoint args
$1._SN
CLI args, int
retva1
[uk]retprobe return value
str [51) ...
CLI args, string
cgroup
Current cgroup ID
curtask
Pointer to current task struct 
Actions
8nap key1,
...] = count()
Frequency count
gmap [ReyI,
...] =
sun [var)
Sum variable
@map [key],
... ]= hist [var)
Power of two histogram
gmap [ReyI,
...] = 1hist(var,
Linear histogram
min, nax,
step)
gmap [ReyI,
..]= stats (var)
Statistics: count, average, and total
min (vaz) , max (vaz) , avg (vaz)
Min, max, average
printf (*format",var0. - varn)
Print vars; use print() for aggregations
kstack (num) , ustack [num)