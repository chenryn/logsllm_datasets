### 18.8 Missing Stack Traces

This section addresses the issue of incomplete or missing stack traces. This problem may also involve missing symbols (covered in Section 18.9), leading to frames appearing as `* [unknown]`.

#### Example Output

Here is an example output using BCC's `trace` tool to print user-level stack traces for the `execve` tracepoint (new process execution):

```bash
$ trace -o t:syscalls:sys_enter_execve
PID    TID    COMM           FUNC
26854  589    qseg           sys_enter_execve
[unknown]
[unknown]
26854  589    qseg           sys_enter_execve
[unknown]
[unknown]
...
```

#### Cross-Checking with `perf`

Before diving deeper into BCC/BPF debugging, it's a good practice to use `perf` for cross-checks. Hereâ€™s how you can reproduce this task using `perf`:

```bash
$ perf record -e 'syscalls:sys_enter_execve' -a sleep 10
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 3.246 MB perf.data (2 samples) ]

$ perf script
...
bash 26967 [007] 2209173.697359: syscalls:sys_enter_execve: filename: 0x56172df05030, argv: 0x56172df3b680, envp: 0x56172af2df00
_GI_execve (/lib/x86_64-linux-gnu/libc-2.27.so)
0x56172df05010 [unknown]([unknown])
argv: 0x56172df04440, envp: 0x56172df2df00
_GI_execve (/lib/x86_64-linux-gnu/libc-2.27.so)
0x56172df05070 [unknown]([unknown])
...
```

This shows similar broken stacks. There are three main problems:

1. **Incomplete Stacks**: The stacks are incomplete. They should trace several frames deep, but only two frames are shown.
2. **Unknown Last Line**: Even `perf` could not resolve the symbol, indicating a problem with symbols in `bash` or `libc`.
3. **Missing `libc` Call**: The `libc` `_GI_execve()` call is seen by `perf` but not in BCC's output, pointing to another issue with BCC's `trace` tool.

### 18.8.1 How to Fix Broken Stack Traces

Incomplete stack traces are common and usually caused by two factors:

1. **Frame Pointer-Based Approach**: The observability tool uses a frame pointer-based approach to read the stack trace.
2. **Compiler Optimization**: The target binary does not reserve a register (RBP on x86_64) for the frame pointer, instead reusing it as a general-purpose register.

To fix this, you can:

- **Recompile with Frame Pointers**:
  - For C/C++ software and other software compiled with GCC or LLVM: Recompile with `-fno-omit-frame-pointer`.
  - For Java: Run `java` with `XX:+PreserveFramePointer`.

- **Switch to Non-Frame Pointer-Based Stack Walking**:
  - `perf` supports DWARF-based stack walking, ORC, and last branch record (LBR). At the time of writing, these options are not available in BPF.

### 18.9 Missing Symbols (Function Names) When Printing

This section covers issues where symbols are not printed correctly in stack traces or via symbol lookup functions.

#### Common Causes

1. **Broken Stacks**: As explained in the previous section.
2. **Short-Lived Processes**: These processes exit before the BPF tool can read their address space and look up symbol tables.
3. **Unavailable Symbol Table Information**: This can be due to JIT runtimes or stripped ELF binaries.

#### How to Fix

- **JIT Runtimes (Java, Node.js, etc.)**:
  - Use supplemental symbol tables generated by the runtime, placed in `/tmp/perf-*.map` files read by both `perf` and BCC.

- **ELF Binaries (C, C++, etc.)**:
  - Adjust the build process to avoid stripping symbols.
  - Use debuginfo or BTF symbols. BCC and bpftrace support debuginfo symbols.

### 18.10 Missing Functions When Tracing

This section deals with scenarios where a known function cannot be traced with uprobes, uretprobes, kprobes, or kretprobes.

#### Common Causes

- **Inlining**: The function instructions are included in the calling function.
- **Tail-Call Optimization**: The compiler optimizes the return path, bypassing the expected probe.
- **Static and Dynamic Linking**: The function location changes due to linking differences.

#### Solutions

- **Trace Different Events**: Trace the parent, child, or neighboring functions.
- **Instruction Offset Tracing**: Use instruction offset tracing if you know the offset of the inlined function.

### 18.11 Feedback Loops

Tracing yourself tracing can create feedback loops. Examples to avoid:

```bash
# bpftrace -e 'k:ext4_file_write_iter { printf("..") }' > /ext4fs/out.file
```

To avoid this, use filters to exclude tracing your own BPF tool or trace only the target process of interest.

### 18.12 Dropped Events

Be aware that BPF tools can drop events, rendering the output incomplete. For example:

```bash
+ profile
WARNING: 5 stack traces could not be displayed.
```

These drops can often be fixed by tuning. For instance, `profile(8)` has the `stack=stacksize` option. As tuning becomes more common, tool defaults should be updated to minimize user intervention.

---

### Appendix A: bpftrace One-Liners

This appendix provides a selection of one-liners used throughout the book.

#### Chapter 6: CPUs

- **New processes with arguments**:
  ```bash
  bpftrace -e 'tracepoint:syscalls:sys_enter_execve { printf("%s %s\n", comm, str(args->filename)) }'
  ```

- **Syscall count by process**:
  ```bash
  bpftrace -e 'tracepoint:syscalls:sys_enter_* { @[comm] = count() }'
  ```

- **Sample running process name at 99 Hertz**:
  ```bash
  bpftrace -e 'profile:hz:99 { printf("%s\n", comm) }'
  ```

- **Sample user-level stacks at 49 Hertz, for PID 189**:
  ```bash
  bpftrace -e 'profile:hz:49 / pid == 189 / { ustack; }'
  ```

- **Trace new threads via pthread_create()**:
  ```bash
  bpftrace -e 'uprobe:/lib/x86_64-linux-gnu/libpthread-2.27.so:pthread_create { printf("Thread created by %s, tid %d\n", comm, tid) }'
  ```

#### Chapter 7: Memory

- **Count page faults by process**:
  ```bash
  bpftrace -e 'tracepoint:exceptions:page_fault_user { @[comm] = count() }'
  ```

- **Count user page faults by user-level stack trace**:
  ```bash
  bpftrace -e 'tracepoint:exceptions:page_fault_user { ustack; }'
  ```

- **Count vmscan operations by tracepoint**:
  ```bash
  bpftrace -e 'tracepoint:vmscan:mm_vmscan_direct_reclaim_begin { @[probe] = count() }'
  ```

#### Chapter 8: File Systems

- **Trace files opened via open(2) with process name**:
  ```bash
  bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s %s\n", comm, str(args->filename)) }'
  ```

- **Show the distribution of read() syscall request sizes**:
  ```bash
  bpftrace -e 'tracepoint:syscalls:sys_enter_read { @ = hist(args->count) }'
  ```

- **Show the distribution of read() syscall read bytes (and errors)**:
  ```bash
  bpftrace -e 'tracepoint:syscalls:sys_exit_read { @ = hist(args->ret) }'
  ```

- **Count VFS calls**:
  ```bash
  bpftrace -e 'kprobe:vfs_* { @[probe] = count() }'
  ```

- **Count ext4 tracepoints**:
  ```bash
  bpftrace -e 'tracepoint:block:block_rq_issue { @[probe] = count() }'
  ```

#### Chapter 9: Disk I/O

- **Count block I/O tracepoints**:
  ```bash
  bpftrace -e 'tracepoint:block:block_rq_issue { @[probe] = count() }'
  ```

- **Summarize block I/O size as a histogram**:
  ```bash
  bpftrace -e 'tracepoint:block:block_rq_issue { @bytes = hist(args->bytes) }'
  ```

- **Count block I/O request user stack traces**:
  ```bash
  bpftrace -e 'tracepoint:block:block_rq_issue { ustack; }'
  ```

- **Count block I/O type flags**:
  ```bash
  bpftrace -e 'tracepoint:block:block_rq_issue { @[args->rwbs] = count() }'
  ```

- **Trace block I/O errors with device and I/O type**:
  ```bash
  bpftrace -e 'tracepoint:block:block_rq_complete / args->error / { printf("Error on %s, %s, error %d\n", devname, args->rwbs, args->error) }'
  ```

- **Count SCSI opcodes**:
  ```bash
  bpftrace -e 'tracepoint:scsi:scsi_dispatch_cmd_start { @[args->opcode] = count() }'
  ```

- **Count SCSI driver functions**:
  ```bash
  bpftrace -e 'kprobe:scsi_* { @[probe] = count() }'
  ```

#### Chapter 10: Networking

- **Count socket accept(2)s by PID and process name**:
  ```bash
  bpftrace -e 'tracepoint:syscalls:sys_enter_accept { printf("%d %s\n", pid, comm) }'
  ```

- **Count socket connect(2)s by PID and process name**:
  ```bash
  bpftrace -e 'tracepoint:syscalls:sys_enter_connect { printf("%d %s\n", pid, comm) }'
  ```

- **Count socket send/receive bytes by on-CPU PID and process name**:
  ```bash
  bpftrace -e 'tracepoint:syscalls:sys_enter_sendto { @ = sum(args->len) }'
  ```

- **UDP send bytes as a histogram**:
  ```bash
  bpftrace -e 'tracepoint:syscalls:sys_enter_sendto / args->addr.sport == 0 / { @ = hist(args->len) }'
  ```

- **Count transmit kernel stack traces**:
  ```bash
  bpftrace -e 'kprobe:tcp_transmit_skb { kstack; }'
  ```

#### Chapter 11: Security

- **Count security audit events for PID 1234**:
  ```bash
  bpftrace -e 'tracepoint:audit:syscall_entry / pid == 1234 / { printf("%s\n", comm) }'
  ```

- **Trace pluggable authentication module (PAM) session starts**:
  ```bash
  bpftrace -e 'usdt:/lib/x86_64-linux-gnu/security/pam_unix.so:pam_sm_authenticate { printf("PAM auth: %s %s\n", str(arg0), str(arg1)) }'
  ```

- **Trace kernel module loads**:
  ```bash
  bpftrace -e 'tracepoint:module:module_load { printf("load: %s\n", str(args->name)) }'
  ```

#### Chapter 13: Applications

- **Sum malloc() requested bytes by user stack trace (high overhead)**:
  ```bash
  bpftrace -e 'uprobe:/usr/lib/x86_64-linux-gnu/libc-2.27.so:malloc { @ = sum(args->size); ustack; }'
  ```

- **Trace kill(2) signals showing sender process name, target PID, and signal number**:
  ```bash
  bpftrace -e 'tracepoint:syscalls:sys_enter_kill { printf("%s -> PID %d SIG %d\n", comm, args->pid, args->sig) }'
  ```

- **Count libpthread mutex lock functions for one second**:
  ```bash
  bpftrace -e 'u:/lib/x86_64-linux-gnu/libpthread-2.27.so:pthread_mutex_lock { @[probe] = count(); interval:s:1 { exit() } }'
  ```

- **Count libpthread conditional variable functions for one second**:
  ```bash
  bpftrace -e 'u:/lib/x86_64-linux-gnu/libpthread-2.27.so:pthread_cond_wait { @[probe] = count(); interval:s:1 { exit() } }'
  ```

#### Chapter 14: Kernel

- **Count system calls by syscall function**:
  ```bash
  bpftrace -e 'kprobe:__x64_sys_* { @[ksym((kaddr "__ia32_sys_call_table") + args->id * sizeof(void *)) ] = count() }'
  ```

- **Count kernel function calls starting with "attach"**:
  ```bash
  bpftrace -e 'kprobe:attach* { @[probe] = count() }'
  ```

- **Time the kernel function vfs_read() and summarize as a histogram**:
  ```bash
  bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read { @ = hist(nsecs - @start[tid]); delete(@start[tid]) }'
  ```

- **Frequency count the first integer argument to kernel function "func1"**:
  ```bash
  bpftrace -e 'kprobe:func1 { @ = count(args->arg1) }'
  ```

- **Frequency count the return value from kernel function "func1"**:
  ```bash
  bpftrace -e 'kretprobe:func1 { @ = count(retval) }'
  ```

- **Sample kernel-level stacks at 99 Hertz, excluding idle**:
  ```bash
  bpftrace -e 'profile:hz:99 / comm != "swapper" / { kstack; }'
  ```

- **Count context switch stack traces**:
  ```bash
  bpftrace -e 'tracepoint:sched:sched_switch { @[kstack, ustack, comm] = count() }'
  ```

- **Count work queue requests by kernel function**:
  ```bash
  bpftrace -e 'tracepoint:workqueue:workqueue_execute_start { @[kfunc(args->function)] = count() }'
  ```

---

### Appendix B: bpftrace Cheat Sheet

#### Synopsis

```bash
bpftrace [options] <script>
```

#### Probes

- **BEGIN, END**: Program start and end.
- **tracepoint:syscalls:sys_enter_execve**: `execve(2)` syscall.
- **tracepoint:syscalls:sys_enter_open**: `open(2)` syscall (also trace `openat(2)`).
- **tracepoint:syscalls:sys_exit_read**: Trace `read(2)` syscall return (one variant).
- **tracepoint:raw_syscalls:sys_enter**: All syscalls.
- **block:block_rq_insert**: Queue block I/O request.
- **block:block_rq_issue**: Issue block I/O request to storage device.
- **block:block_rq_complete**: Block I/O completion.
- **sock:inet_sock_set_state**: Socket state change.
- **sched:sched_process_exec**: Process execution.
- **sched:sched_switch**: Context switch.
- **sched:sched_wakeup**: Thread wakeup event.
- **software:faults:1**: Page faults.
- **hardware:cache-misses:1000000**: Once every 1,000,000 LLC cache miss.
- **kprobe:vfs_read**: Trace `vfs_read()` kernel function entry.
- **kretprobe:vfs_read**: Trace return of `vfs_read()` kernel function.
- **uprobe:/bin/bash:readline**: Trace `readline()` from `/bin/bash`.
- **uretprobe:/bin/bash:readline**: Trace return of `readline()` from `/bin/bash`.
- **usdt:path:probe**: Trace USDT probe from path.
- **profile:hz:99**: Sample on all CPUs at 99 Hertz.
- **interval:s:1**: Run on one CPU once per second.

#### Probe Aliases

- **tracepoint**: `tp`
- **kprobe**: `k`
- **kretprobe**: `kr`
- **uprobe**: `u`
- **uretprobe**: `ur`
- **interval**: `i`

#### Vars

- **comm**: On-CPU process name.
- **username**: Username string.
- **pid, tid**: On-CPU PID, Thread ID.
- **uid**: User ID.
- **cpu**: CPU ID.
- **kstack**: Kernel stack trace.
- **nsec**: Time, nanoseconds.
- **ustack**: User stack trace.
- **elapsed**: Time since program start.
- **probe**: Current full probe name.
- **args->...**: [uk]probe arguments.
- **func**: Current function name.
- **args->...**: Tracepoint args.
- **$1..$N**: CLI args, int.
- **retval**: [uk]retprobe return value.
- **str($1)...**: CLI args, string.
- **cgroup**: Current cgroup ID.
- **curtask**: Pointer to current task struct.

#### Actions

- **@map[key,...] = count()**: Frequency count.
- **@map[key,...] = sum(var)**: Sum variable.
- **@map[key,...] = hist(var)**: Power of two histogram.
- **@map[key,...] = lhist(var, min, max, step)**: Linear histogram.
- **@map[key,...] = stats(var)**: Statistics: count, average, and total.
- **min(var), max(var), avg(var)**: Min, max, average.
- **printf("format", var0, ... varn)**: Print vars; use `print()` for aggregations.
- **kstack(num), ustack(num)**: Print kernel and user stack traces.