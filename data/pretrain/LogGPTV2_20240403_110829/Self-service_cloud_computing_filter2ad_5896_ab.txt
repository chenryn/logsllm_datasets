ileges over UdomUs. SSC prevents Sdom0 from inspecting the
contents of client meta-domains.
One of the main contributions of the SSC model is that it
splits the TCB of the cloud infrastructure in two parts, a system-
level TCB, which consists of the hypervisor, domB, BIOS and the
bootloader, and is controlled by the cloud provider, and a client-
level TCB, which consists of the client’s Udom0, SDs, and MTSDs.
Clients can verify the integrity of the system-level TCB using
trusted hardware. They are responsible for the integrity of their
client-level TCBs. Any compromise of a client-level TCB only
aﬀects that client.
Sdom0 runs all device drivers that perform actual I/O and wields
authority over scheduling and allocation decisions. Although these
privileges allow Sdom0 to perform denial-of-service attacks, such
attacks are not in our threat model (Section 2); consequently,
Sdom0 is not part of the TCB.
The components of SSC must be able to communicate with each
other for tasks such as domain creation and delegating privileges. In
our prototype, VMs communicate using traditional TCP/IP sockets.
However, domB receives directives for domain creation through
hypervisor-forwarded hypercalls (see Figure 2 and Figure 3). Im-
ages of domains to be created are passed by attaching storage vol-
umes containing this information.
3.2 Bootstrapping
Hosts in the cloud infrastructure are assumed to be equipped with
TPM and IOMMU hardware, which is available on most modern
chipsets. We assume that the TPM is virtualized, as described in
prior work [5]. The supporting user-level daemons for the virtu-
alized TPM (vTPM) run within domB, which is in the TCB, and
interact with the hardware TPM on the physical host. The pro-
tocols described in this section assume client interaction with a
vTPM instance. We use the vTPM protocols as described in the
original paper [5], although it may also be possible to use recently-
proposed variants [15]. The vTPM can cryptographically attest the
list of software packages loaded on a system in response to client
requests; such attestations are called measurements [39].
During system boot, the BIOS passes control to a bootloader,
and initializes the hardware TPM’s measurement. In turn, the boot-
loader loads our modiﬁed version of the Xen hypervisor, Sdom0’s
kernel and ramdisk, and domB’s kernel and ramdisk. It also adds
entries for the hypervisor and domB to the measurement stored in
the TPM’s PCR registers. The hypervisor then builds Sdom0 and
domB. Finally, it programs the IOMMU to allow Sdom0 access
to only the pages that it owns. Following bootstrap and initializa-
tion, the hypervisor unpauses Sdom0 and schedules it for execu-
tion. Sdom0 then unpauses domB, which awaits client requests to
initialize meta-domains. SSC forbids Sdom0 from directly inter-
acting with the TPM; all TPM operations (both with the hardware
TPM and vTPM instances) happen via domB.
Sdom0 starts the XenStore service, which is a database used
traditionally by Xen to maintain information about virtual device
conﬁguration. Each user VM on the system is assigned its own
subtree in XenStore with its virtual device conﬁgurations.
3.3 Building Client Meta-Domains
In SSC, domB receives and processes all requests to create new
domains, including Udom0s, UdomUs, SDs, and MTSDs. Client
requests to start new meta-domains are forwarded to domB from
Sdom0. In response, domB creates a Udom0, which handles cre-
ation of the rest of the meta-domain by itself sending more re-
quests to domB (e.g., to create SDs and UdomUs). To allow clients
to verify that their domains were built properly, domB integrates
domain building with standard vTPM-based attestation protocols
developed in prior work [5, 39].
Udom0. Upon receiving a client request to create a new meta-
domain, Sdom0 issues the C U0 hypercall containing
a handle to the new domain’s bootstrap modules (kernel image,
ramdisk, etc.). DomB builds the domain and returns to the client
an identiﬁer of the newly-created meta-domain. In more detail, the
construction of a new meta-domain follows the protocol shown in
Figure 3(a). This protocol achieves two security goals:
(1) Veriﬁed boot of Udom0. At the end of the protocol, the client
can verify that the Udom0 booted by the SSC platform corresponds
to the image supplied in step 1 of Figure 3(a). To achieve this
goal, in step 1, the client supplies a challenge (nTPM) and also
provides hash(Udom0 image), encrypted under the vTPM’s public
key (AIK). These arguments are passed to domB, as part of the C-
 U0 hypercall in step 2. In turn, DomB requests the vTPM to
decrypt the content enciphered under its public key, thereby obtain-
ing hash(Udom0 image). DomB then creates the domain after ver-
ifying the integrity of the VM image (using hash(Udom0 image)
and Sigclient), thereby ensuring that Sdom0 has not maliciously al-
tered the VM image supplied by the client. It then returns to the
client an identiﬁer of the newly-created meta-domain, a digitally-
signed measurement from the vTPM (containing the contents of the
vTPM’s PCR registers and the client’s challenge) and the measure-
ment list. The client can use this to verify that the domain booted
with the expected conﬁguration parameters.
(2) Bootstrapping SSL channel with client. In SSC, the network
driver is controlled by Sdom0, which is untrusted, and can eaves-
drop on any cleartext messages transmitted over the network.
Therefore, the protocol in Figure 3(a) also interacts with the client
to install an SSL private key within the newly-created Udom0.
This SSL private key is used to authenticate Udom0 during the
SSL handshake with the client, and helps bootstrap an encrypted
channel that will then be used for all further communication with
the client.
Installation of the SSL private key proceeds as follows. In
step 1, the client supplies a fresh symmetric key (freshSym), and
a nonce (nSSL), both encrypted under the vTPM’s public key. In
step 2, domB creates Udom0 after checking the integrity of the
Udom0 image (using Sigclient). When domB creates Udom0, it re-
255• C U0 ( , , E P, SC)
Description: This hypercall is issued by Sdom0 to initiate a client meta-domain by creating a Udom0. The   argument is a
handle to a block device provided by Sdom0 to the client to pass Udom0 kernel image, ramdisk and conﬁguration to domB. The 
supplied by the client is combined with the vTPM’s measurement list, which is returned to the client for veriﬁcation following domain
creation. E P denotes a set of parameters that are encrypted under the vTPM’s AIK public key. SC is the client’s digital
signature of key parameters to the C U0 call. These parameters are used by the protocol in Figure 3(a) to bootstrap a secure
communication channel with the client after Udom0 creation.
• C U ( , )
Description: Issued by Udom0 to provide VM images of SDs or UdomUs to domB. The parameters   and  are as
described above.
• C MTSD ( ,  ,  ,  ,  )
Description: Sdom0 uses this hypercall to start an MTSD within a client’s meta-domain. The conﬁguration parameters, which are
included in the block device speciﬁed by  , contain the command-line arguments used to initiate the service provided by
the MTSD. MTSDs are also assigned speciﬁc privileges over UdomUs in the client meta-domain. This hypercall returns an identiﬁer
for the newly-created MTSD. It also returns two signed vTPM measurements, each appended with the nonces of the provider and the
client.
• G P (SD , UU ,  )
Description: This hypercall is used by Udom0s to delegate speciﬁc privileges to a SD over an UdomU. Udom0s can issue this
hypercall only on SDs and UdomUs within their own meta-domain.
Figure 2. Summary of new hypercalls introduced to enable SSC. Figure 3 shows their usage.
(a) Protocol for Udom0 creation (initializing a new meta-domain) and bootstrapping an SSL communication channel
nTPM, Udom0 image, EncAIK(freshSym||nSSL||hash(Udom0 image)), Sigclient
IDclient, TPMSign(nTPM||PCR), ML
nSSL
EncfreshSym(SSLpriv)
:
: C U0(Udom0 image, nTPM, EncAIK(freshSym||nSSL||hash(Udom0 image)), Sigclient) → IDclient
:
: Unpause Udom0 (denoted by IDclient) and schedule it for execution
:
:
1. client → Sdom0
2. Sdom0 → domB
3. domB → client
4. domB → Sdom0
5. Udom0 → client
6. client → Udom0
Notes: In step 1, Udom0 image is passed via a block device provided by Sdom0 to the client. The key AIK denotes the public part of
the vTPM’s AIK (attestation identity key), freshSym is a fresh symmetric key chosen by the client, and Sigclient is the digital signature,
under the client’s private key, of freshSym||nSSL||hash(Udom0 image)||nTPM. In step 2, when domB executes C U0, it requests
the vTPM to decrypt EncAIK(. . .), checks the hash of Udom0 image, veriﬁes the client’s digital signature Sigclient, and places freshSym
and nSSL into Udom0’s memory. In step 3, ML denotes the measurement list, while PCR denotes the content of the vTPM’s platform
control register (storing the measurements); TPMSign(. . .) denotes that the corresponding content is signed with the private part of
the vTPM’s AIK key. IDclient is a unique identiﬁer assigned to the newly created Udom0 (and meta-domain). In steps 5 and 6, Udom0
interacts with the client, who sends it the SSL private key (denoted by SSLpriv) encrypted under freshSym. Udom0 decrypts this to
obtain SSLpriv, which is then used for all future SSL-based communication with the client.
1. client → Udom0
2. Udom0 → domB
3. domB → Udom0
4. Udom0
5. domB → Sdom0
1. Udom0 → Sdom0
2. Sdom0 → domB
3. domB → Sdom0
4. domB → Udom0
5. domB → Sdom0
Notes: In step 2, IDclient is the meta-domain identiﬁer obtained during Udom0 creation.
nclient, VM image (this message is sent via SSL)
:
: C UD(VM image, nclient) → IDV M
IDV M, TPMSign(nclient||PCR), ML
:
: G P(IDV M, IDUdomU, SD privileges) (this step is necessary only for VMs that are SDs)
: Unpause IDV M and schedule it for execution
nclient, identiﬁer of the MTSD to be installed (VM image resides with provider)
IDMTS D, TPMSign(nprovider||PCR), ML
IDMTS D, TPMSign(nclient||PCR), ML
:
: C MTSD(IDclient, MTSD image, nprovider, nclient, MTSD privileges) → IDMTS D
:
:
: Unpause IDMTS D and schedule it for execution
(b) Protocol for UdomU and SD creation
(c) Protocol for MTSD creation
Figure 3. Protocols used in SSC for the creation of Udom0, UdomUs, SDs and MTSDs.
quests the vTPM to decrypt this content, and places freshSym
and nSSL in Udom0’s memory, where SSC’s privilege model pre-
vents them from being accessed by Sdom0. Recall from Section 3.2
that Sdom0 cannot directly access the TPM or vTPM (only domB
can do so), and therefore cannot obtain the value of freshSym. In
step 5, Udom0 sends nSSL to the client, which responds in step 6
with the SSL private key encrypted under freshSym. Udom0 can
now decrypt this message to obtain the SSL private key. Assuming
that both freshSym and nSSL are random and generated afresh, the
protocol allows the client to detect replay attempts.
This protocol signiﬁcantly restricts the power of evil twin at-
tacks launched by a malicious Sdom0. In such an attack, Sdom0
would coerce domB to create a malicious Udom0 domain, and trick
the client into installing its SSL private key within this domain.
This malicious domain would then transfer the SSL private key to
Sdom0, thereby compromising client conﬁdentiality. In our proto-
col, domB checks the integrity of Udom0 image before booting
the domain, thereby ensuring that the only “evil” twin that Sdom0
can create will have the same VM image as supplied by the client.
Sdom0 therefore cannot include arbitrary malicious functionality
256in the evil twin (e.g., code to transmit secret keys to it) without
being detected by the client. Further, SSC’s privilege model pre-
vents Sdom0 from directly inspecting the memory of the twin VM,
thereby protecting the the value of freshSym that is installed in it
during creation. Finally, steps 5 and 6 of the protocol detect replay
attempts, thereby ensuring that even if a twin VM is created, ex-
actly one of the twins can interact with the client to obtain its SSL
private key. This twin VM then becomes the Udom0 of the client’s
meta-domain, while the other twin can no longer interact with the
client.
UdomUs and SDs. Udom0 accepts and processes client requests
to start UdomUs and SDs. Clients establish an SSL connection with
Udom0, and transmit the kernel and ramdisk images of the new
domain to Udom0. Udom0 forwards this request to domB, which
then builds the domain. See Figure 3(b).
We aim for Udom0s and SDs to be stateless. They perform spe-
cialized tasks, and do not need persistent state for these tasks. The
lack of persistent state eases the clients’ task of verifying the in-
tegrity of these domains (e.g., via inspection of their code), thereby
minimizing risk even if they are compromised via attacks directed
against them. The lack of state also allows easy recovery upon com-
promise; they can simply be restarted [9]. In our design, we do not
assign persistent storage to SDs. They are neither extensible nor are
they allowed to load kernel modules or extensions outside of the
initial conﬁguration. All relevant conﬁguration values are passed
via command line parameters. This design does require greater
management eﬀort on the part of clients, but is to be expected in
SSC, because it shifts control from the provider to clients.
We have implemented SDs and Udom0s in our prototype using
a carefully-conﬁgured paravirtualized Linux kernel; they only use
ramdisks. The ﬁle system contains binaries, static conﬁguration
and temporary storage. SSC elides any unnecessary functionality in
SDs and Udom0s to minimize their attack surface. Udom0s in our
prototype integrates a replica of the xend Python-based toolstack
for end-user interaction and to provide an administrative interface
to the meta-domain. It may be possible to reduce the size of the
client-level TCB using a simpler software stack (e.g., based on
Mini-OS, which is part of the Xen distribution). However, we have
not done so in our current prototype.
MTSDs. Like SDs, each MTSD belongs to a client meta-domain.
MTSDs can be given speciﬁc privileges (via the C MTSD hy-
percall) to map the state of client VMs, checkpoint, ﬁngerprint, or
introspect them. This allows the cloud provider to inspect client do-
mains for regulatory compliance. Section 3.6 discusses regulatory
compliance with MTSDs in further detail.
Both the cloud provider and client cooperate to start the MTSD,
as shown in the protocol in Figure 3(c). The client initiates the
protocol after it has agreed to start the MTSD in its meta-domain.
DomB creates the MTSD, and both the provider and the client
can each ensure that the MTSD was initialized properly using
signed measurements from the vTPM. The provider or the client
can terminate the protocol at this point if they ﬁnd that the MTSD
has been tampered with.
3.4 SSC Privilege Model
At the heart of SSC is a new privilege model enforced by the
hypervisor. This model enables clients to administer their own VMs
securely, without allowing cloud administrators to eavesdrop on
their data. For purposes of exposition, we broadly categorize the
privileged operations performed by a VMM into six groups.
(1) VM control operations include pausing/unpausing, schedul-
ing, and destroying VMs.
(2) Privacy-sensitive operations allow the mapping of memory
and virtual CPU registers of a VM.