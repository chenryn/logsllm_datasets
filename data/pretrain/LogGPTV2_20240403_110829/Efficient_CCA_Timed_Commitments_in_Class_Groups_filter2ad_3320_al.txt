= ğ¾0 Â· ğ»ğ‘’
1 . If unsuccessful, output 0.
Figure 7: Prover and Verifier routine for NIZK proof for statements in language L2
â€¢ ğ‘’ğ‘– = (ğ‘‘ğ‘–,1 + ğ‘‘ğ‘–,2) mod 2ğœ†
â€¢ ğ´ğ‘–,1 := ğºğ‘Ÿğ‘–,1 Â· (ğ‘ğ‘–,0)ğ‘‘ğ‘–,1
â€¢ ğµğ‘–,1 := ğ¾ğ‘Ÿğ‘–,1 Â· (ğ‘ğ‘–,1)ğ‘‘ğ‘–,1
â€¢ ğ´ğ‘–,2 := ğºğ‘Ÿğ‘–,2 Â· (ğ‘ğ‘–,0)ğ‘‘ğ‘–,2
â€¢ ğµğ‘–,2 := ğ¾ğ‘Ÿğ‘–,2 Â· (ğ‘ğ‘–,1/ğº)ğ‘‘ğ‘–,2
â€¢ Ëœğ´ğ‘–,1 := Ëœğº Ëœğ‘Ÿğ‘–,1 Â· ( Ëœğ‘ğ‘–,0)ğ‘‘ğ‘–,1
â€¢ Ëœğµğ‘–,1 := Ëœğ¾ Ëœğ‘Ÿğ‘–,1 Â· ( Ëœğ‘ğ‘–,1)ğ‘‘ğ‘–,1
â€¢ Ëœğ´ğ‘–,2 := Ëœğº Ëœğ‘Ÿğ‘–,2 Â· ( Ëœğ‘ğ‘–,0)ğ‘‘ğ‘–,2
â€¢ Ëœğµğ‘–,2 := Ëœğ¾ Ëœğ‘Ÿğ‘–,2 Â· ( Ëœğ‘ğ‘–,1/ Ëœğº)ğ‘‘ğ‘–,2 .
It sets the random oracle H3 accordingly at the ğ‘–-th point with
ğ‘’ğ‘–. The values (ğ´ğ‘–,1, ğµğ‘–,1, ğ´ğ‘–,2, ğµğ‘–,2, Ëœğ´ğ‘–,1, Ëœğµğ‘–,1, Ëœğ´ğ‘–,2, Ëœğµğ‘–,2) output by the
simulator are statistically close to that in a honestly generated proof.
This is because ğ‘¤ğ‘– if sampled uniformly from Zğ‘„ is distributed
statistically close to ğ‘Ÿğ‘–,1 + ğ‘ ğ‘– Â· ğ‘‘ğ‘–,1 (Lemma E.1).
â–¡
Theorem E.7 (Simulation Soundness). The protocol in Figure 8
satisfies simulation soundness provided the 2ğœ†-low order assumption
and the strong root assumption holds in G, in the random oracle
model.
Proof of Theorem E.7. As before, we assume without loss of
generality that the false statement (and the index ğ‘– where the state-
ment fails) is fixed ahead of time. This assumption can be lifted
with a polynomial loss in the success probability of the reduction by
guessing the correct query to the random oracle. In what follows,
we assume that the false statement only pertains to the prime-order
group ËœG. For the case of the class group elements, the argument
is similar to the proof of Theorems E.3 and E.5. Our reduction R
computes simulated proofs up until the point where the adversary
made the random oracle query on the false statement. Here the
reduction forks the execution and sets the ğ‘–-th output of the random
oracle to two different values (ğ‘’ğ‘– â‰  ğ‘’â€²
ğ‘–). By the forking Lemma [63],
with inverse polynomial probability the adversary outputs two ac-
cepting proofs containing Ëœğ´ğ‘–,1, Ëœğ´ğ‘–,2, Ëœğµğ‘–,1, Ëœğµğ‘–,2, ğ‘‘ğ‘–,1, ğ‘‘ğ‘–,2, Ëœğ‘Ÿğ‘–,1, Ëœğ‘Ÿğ‘–,1 and
Ëœğ´ğ‘–,1, Ëœğ´ğ‘–,2, Ëœğµğ‘–,1, Ëœğµğ‘–,2, ğ‘‘â€²
ğ‘–,1, ğ‘‘â€²
ğ‘–,1 (among other elements from G).
Since ğ‘’ğ‘– â‰  ğ‘’â€²
ğ‘–,1 or ğ‘‘ğ‘–,2 â‰ 
ğ‘‘â€²
ğ‘–,2. If we have ğ‘‘ğ‘–,1 â‰  ğ‘‘â€²
ğ‘–,2, Ëœğ‘Ÿâ€²
ğ‘– , it must be the case that either ğ‘‘ğ‘–,1 â‰  ğ‘‘â€²
ğ‘–,1, then the reduction computes
ğ‘–,1 Ëœğ‘Ÿâ€²
(cid:16)Ëœğ‘Ÿğ‘–,1 âˆ’ Ëœğ‘Ÿâ€²
(cid:16)ğ‘‘â€²
ğ‘–,1
ğ‘–,1 âˆ’ ğ‘‘ğ‘–,1
(cid:17)
(cid:17)
Ëœğ‘ ğ‘– :=
from Ëœğ´ğ‘–,1, such that Ëœğ‘ğ‘–,0 = Ëœğº Ëœğ‘ ğ‘– . Similarly from Ëœğµğ‘–,1 we have Ëœğ‘ğ‘–,1 = Ëœğ¾ Ëœğ‘ ğ‘– ,
therefore we have extracted the witness to the relation. If ğ‘‘ğ‘–,2 â‰  ğ‘‘â€²
ğ‘–,2,
then the reduction computes
(cid:16)Ëœğ‘Ÿğ‘–,2 âˆ’ Ëœğ‘Ÿâ€²
(cid:16)ğ‘‘â€²
ğ‘–,2
ğ‘–,2 âˆ’ ğ‘‘ğ‘–,2
(cid:17)
(cid:17)
Ëœğ‘ ğ‘– :=
from Ëœğ´ğ‘–,2, such that Ëœğ‘ğ‘–,0 = Ëœğº Ëœğ‘ ğ‘– . From Ëœğ‘ğ‘–,2 we have that ğ¾ Ëœğ‘ ğ‘– = ( Ëœğ‘ğ‘–,1/ Ëœğº)
and therefore Ëœğ‘ ğ‘– is a valid witness for the relation. It is not possible
for both ğ‘‘ğ‘–,1 â‰  ğ‘‘â€²
ğ‘–,2, since this would mean we have
Ëœğ‘ğ‘–,1 = Ëœğ¾ Ëœğ‘ ğ‘– = Ëœğ¾ Ëœğ‘ ğ‘– Â· ğº. Therefore we are able to extract a valid witness
in one of the branches, which contradicts the fact that the statement
was false.
â–¡
ğ‘–,1 and ğ‘‘ğ‘–,2 â‰  ğ‘‘â€²
F SECURITY ANALYSIS OF DISTRIBUTED
RANDOMNESS GENERATION PROTOCOL
Proof of Theorem 6.3. We assume for simplicity that the ad-
versary corrupts all but one parties and the honest party is ğ‘ƒ1. We
define the following series of hybrid distributions.
Hyb0: Is identical to the IND-RAN experiment with the bit ğ‘ fixed
to ğ‘ = 0, i.e. A is given the honestly computed ğ‘Ÿ0.
Hyb1: This is identical to the previous hybrid except that now each
of the commitments output by the adversary are individually force-
opened using TForceOp. Let (ğ‘ 2, . . . , ğ‘ ğ‘›) be the resulting integers
and let ğ‘ 1 the integer sampled by the honest ğ‘ƒ1 (in the call to the
RGen protocol). Then the adversary is given
ğ‘Ÿ0 =
ğ‘ ğ‘– .
ğ‘›
ğ‘›
ğ‘–=1
ğ‘–=2
ğ‘Ÿ0 =
ğ‘ ğ‘– + Ëœğ‘ 
Hyb2: This is identical to the previous hybrid except that we com-
pute
where Ëœğ‘  â† Zğ‘ is sampled uniformly and independently from ğ‘ 1.
Hyb3: Here the adversary is given a uniformly sampled integer.
Note that the latter hybrid is identical to the experiment IND-RAN
with the bit ğ‘ fixed to ğ‘ = 1. We now argue the indistinguishability
of the hybrids.
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2682PrvL3(crs, stmt, wit): The prover routine does the following:
â€¢ For ğ‘– âˆˆ [ğ›¼], do the following:
â€“ If ğ‘Ÿğ‘– = 1, i.e.,(cid:16)(ğ‘ğ‘–,0, ğ‘ğ‘–,1) = (ğºğ‘ ğ‘– , ğ¾ğ‘ ğ‘– Â· ğº)( Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1) = ( Ëœğº Ëœğ‘ ğ‘– , Ëœğ¾ Ëœğ‘ ğ‘– Â· Ëœğº)(cid:17), do the following:
âˆ— Sample ğ‘¤ğ‘–, ğ‘Ÿğ‘–,1 â† Zğ‘„, Ëœğ‘¤ğ‘–, Ëœğ‘Ÿğ‘–,1 â† Z Ëœğ‘ and ğ‘‘ğ‘–,1 â† Z2ğœ†
âˆ— Set ğ´ğ‘–,1 := ğºğ‘Ÿğ‘–,1 Â· (ğ‘ğ‘–,0)ğ‘‘ğ‘–,1, ğµğ‘–,1 := ğ¾ğ‘Ÿğ‘–,1 Â· (ğ‘ğ‘–,1)ğ‘‘ğ‘–,1
âˆ— Set Ëœğ´ğ‘–,1 := Ëœğº Ëœğ‘Ÿğ‘–,1 Â· ( Ëœğ‘ğ‘–,0)ğ‘‘ğ‘–,1, Ëœğµğ‘–,1 := Ëœğ¾ Ëœğ‘Ÿğ‘–,1 Â· ( Ëœğ‘ğ‘–,1)ğ‘‘ğ‘–,1
âˆ— Set ğ´ğ‘–,2 := ğº ğ‘¤ğ‘– , ğµğ‘–,2 := ğ¾ ğ‘¤ğ‘–
âˆ— Set Ëœğ´ğ‘–,2 := Ëœğº Ëœğ‘¤ğ‘– , Ëœğµğ‘–,2 := Ëœğ¾ Ëœğ‘¤ğ‘–
â€“ If ğ‘Ÿğ‘– = 0, i.e.,(cid:16)(ğ‘ğ‘–,0, ğ‘ğ‘–,1) = (ğºğ‘ ğ‘– , ğ¾ğ‘ ğ‘–)( Ëœğ‘ğ‘–,0Ëœ,ğ‘ğ‘–,1) = ( Ëœğº Ëœğ‘ ğ‘– , Ëœğ¾ Ëœğ‘ ğ‘–)(cid:17), do the following:
âˆ— Sample ğ‘¤ğ‘–, ğ‘Ÿğ‘–,2 â† Zğ‘„, Ëœğ‘¤ğ‘–, Ëœğ‘Ÿğ‘–,2 â† Z Ëœğ‘ and ğ‘‘ğ‘–,2 â† Z2ğœ†
âˆ— Set ğ´ğ‘–,1 := ğº ğ‘¤ğ‘– , ğµğ‘–,1 := ğ¾ ğ‘¤ğ‘–
âˆ— Set Ëœğ´ğ‘–,1 := Ëœğº Ëœğ‘¤ğ‘– , Ëœğµğ‘–,1 := Ëœğ¾ Ëœğ‘¤ğ‘–
âˆ— Set ğ´ğ‘–,2 := ğºğ‘Ÿğ‘–,2 Â· (ğ‘ğ‘–,0)ğ‘‘ğ‘–,2, ğµğ‘–,2 := ğ¾ğ‘Ÿğ‘–,2 Â· (ğ‘ğ‘–,1/ğº)ğ‘‘ğ‘–,2
âˆ— Set Ëœğ´ğ‘–,2 := Ëœğº Ëœğ‘Ÿğ‘–,2 Â· ( Ëœğ‘ğ‘–,0)ğ‘‘ğ‘–,2, Ëœğµğ‘–,2 := Ëœğ¾ Ëœğ‘Ÿğ‘–,2 Â· ( Ëœğ‘ğ‘–,1/ Ëœğº)ğ‘‘ğ‘–,2
â€¢ Compute (ğ‘’1, . . . , ğ‘’[ğ›¼]) â† H3(stmt, {ğ´ğ‘–,1, ğµğ‘–,1, ğ´ğ‘–,2, ğµğ‘–,2, Ëœğ´ğ‘–,1, Ëœğµğ‘–,1, Ëœğ´ğ‘–,2, Ëœğµğ‘–,2}ğ‘–âˆˆ[ğ›¼])
â€¢ For ğ‘– âˆˆ [ğ›¼], do the following:
â€“ If ğ‘Ÿğ‘– = 1, do the following:
â€“ If ğ‘Ÿğ‘– = 0, do the following:
âˆ— Compute ğ‘‘ğ‘–,2 := (ğ‘’ğ‘– âˆ’ ğ‘‘ğ‘–,1) mod 2ğœ†
âˆ— Compute ğ‘Ÿğ‘–,2 := ğ‘¤ğ‘– âˆ’ ğ‘ ğ‘– Â· ğ‘‘ğ‘–,2,
âˆ— Compute ğ‘‘ğ‘–,1 := (ğ‘’ğ‘– âˆ’ ğ‘‘ğ‘–,2) mod 2ğœ†
âˆ— Compute ğ‘Ÿğ‘–,1 := ğ‘¤ğ‘– âˆ’ ğ‘ ğ‘– Â· ğ‘‘ğ‘–,1,
Ëœğ‘Ÿğ‘–,2 := ( Ëœğ‘¤ğ‘– âˆ’ Ëœğ‘ ğ‘– Â· ğ‘‘ğ‘–,2) mod Ëœğ‘
Ëœğ‘Ÿğ‘–,1 := ( Ëœğ‘¤ğ‘– âˆ’ Ëœğ‘ ğ‘– Â· ğ‘‘ğ‘–,1) mod Ëœğ‘
â€¢ Output ğœ‹ := {ğ‘’ğ‘–, ğ´ğ‘–,1, ğµğ‘–,1, ğ´ğ‘–,2, ğµğ‘–,2, Ëœğ´ğ‘–,1, Ëœğµğ‘–,1, Ëœğ´ğ‘–,2, Ëœğµğ‘–,2, ğ‘‘ğ‘–,1, ğ‘‘ğ‘–,2, ğ‘Ÿğ‘–,1, ğ‘Ÿğ‘–,2, Ëœğ‘Ÿğ‘–,1, Ëœğ‘Ÿğ‘–,2}ğ‘–âˆˆ[ğ›¼]
VfyL3(crs, stmt, ğœ‹): The verifier routine does the following:
â€¢ Parse ğœ‹ := {ğ‘’ğ‘–, ğ´ğ‘–,1, ğµğ‘–,1, ğ´ğ‘–,2, ğµğ‘–,2, Ëœğ´ğ‘–,1, Ëœğµğ‘–,1, Ëœğ´ğ‘–,2, Ëœğµğ‘–,2, ğ‘‘ğ‘–,1, ğ‘‘ğ‘–,2, ğ‘Ÿğ‘–,1, ğ‘Ÿğ‘–,2, Ëœğ‘Ÿğ‘–,1, Ëœğ‘Ÿğ‘–,2}ğ‘–âˆˆ[ğ›¼]
â€¢ Check if (ğ‘’1, . . . , ğ‘’ğ›¼) ?
â€¢ For ğ‘– âˆˆ [ğ›¼], check if all the following hold, and output 0 otherwise:
= H3(stmt, {ğ´ğ‘–,1, ğµğ‘–,1, ğ´ğ‘–,2, ğµğ‘–,2, Ëœğ´ğ‘–,1, Ëœğµğ‘–,1, Ëœğ´ğ‘–,2, Ëœğµğ‘–,2}ğ‘–âˆˆ[ğ›¼])
â€“ ğ‘’ğ‘–
â€“ ğ´ğ‘–,1
â€“ ğµğ‘–,1
â€“ ğ´ğ‘–,2
â€“ ğµğ‘–,2
â€“ Ëœğ´ğ‘–,1
â€“ Ëœğµğ‘–,1
â€“ Ëœğ´ğ‘–,2
â€“ Ëœğµğ‘–,2
?
= (ğ‘‘ğ‘–,1 + ğ‘‘ğ‘–,2) mod 2ğœ†
?
= ğºğ‘Ÿğ‘–,1 Â· (ğ‘ğ‘–,0)ğ‘‘ğ‘–,1
?
= ğ¾ğ‘Ÿğ‘–,1 Â· (ğ‘ğ‘–,1)ğ‘‘ğ‘–,1
?
= ğºğ‘Ÿğ‘–,2 Â· (ğ‘ğ‘–,0)ğ‘‘ğ‘–,2
?
= ğ¾ğ‘Ÿğ‘–,2 Â· (ğ‘ğ‘–,1 Â· ğºâˆ’1)ğ‘‘ğ‘–,2
?
= Ëœğº Ëœğ‘Ÿğ‘–,1 Â· ( Ëœğ‘ğ‘–,0)ğ‘‘ğ‘–,1
?
= Ëœğ¾ Ëœğ‘Ÿğ‘–,1 Â· ( Ëœğ‘ğ‘–,1)ğ‘‘ğ‘–,1
?
= Ëœğº Ëœğ‘Ÿğ‘–,2 Â· ( Ëœğ‘ğ‘–,0)ğ‘‘ğ‘–,2
?
= Ëœğ¾ Ëœğ‘Ÿğ‘–,2 Â· ( Ëœğ‘ğ‘–,1 Â· Ëœğºâˆ’1)ğ‘‘ğ‘–,2
â€¢ If all the above conditions hold, output 1, else output 0.
Figure 8: Prover and Verifier routine for NIZK proof for statements in language L3
Hyb0 â‰ˆğ‘ Hyb1: By the perfect correctness of the commitment sche-
me, the hybrids only differ in the case where one of the commit-
ments output by the adversary is not well-formed. However, such
a commitment is always rejected unless the adversary computes a
proof ğœ‹ for a false statement, which contradicts the verifiability of
the CCA timed commitment scheme.
Hyb1 â‰ˆTğœ– Hyb2: We show this indinstinguishability via a reduction
to the CCA security of the timed commitment scheme. Let A be
a PPT adversary with depth less than Tğœ– (for some ğœ– < 1) that
distinguishes between the two hybrids. The reduction R against
the CCA security of the timed commitment proceeds as follows. The
reduction obtains crs of the timed commitment scheme. When the
adversary queries the RGen oracle, the reduction locally samples
(ğ‘ 0, ğ‘ 1) â† Zğ‘ and sends (ğ‘ 0, ğ‘ 1) to its challenger. It receives (ğ‘, ğœ‹)
from its challenger and sends (ğ‘, ğœ‹) to the adversary as reply to the
oracle query. The adversary outputs ğ‘‰ := {(ğ‘2, ğœ‹2), . . . , (ğ‘ğ‘›, ğœ‹ğ‘›)}.
The reduction forwards each of these to its own oracle O. If the
oracle responds with âŠ¥ for any of the pairs (ğ‘ğ‘–, ğœ‹ğ‘–), the reduction
sets ğ‘šğ‘– = 0. Otherwise, the reduction receives ğ‘šğ‘– as a response and
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2683defines a set {ğ‘š2, . . . , ğ‘šğ‘›}. The reduction sets
ğ‘›
ğ‘–=2
ğ‘Ÿ =
ğ‘šğ‘– + ğ‘ 0
and returns ğ‘Ÿ to the adversary. The adversary responds with a bit
ğ‘â€² and the reduction outputs ğ‘â€² as its own answer to the challenger.
This concludes the description of R.
Notice that the reduction is efficient and it running time is only a
polynomial (in ğœ†) factor slower than A. The reduction violates the
CCA security of the timed commitments with the same probability
as A violates the IND-RAN security. To see this, observe that we
have two cases where (ğ‘, ğœ‹) embeds ğ‘ 0 or ğ‘ 1. If (ğ‘, ğœ‹) indeed embeds
ğ‘ 0, then ğ‘Ÿ is distributed as in hybrid Hyb1, otherwise ğ‘Ÿ is distributed
uniformly, as in Hyb2. This is a contradiction to the CCA security
of the timed commitments.
Hyb2 â‰¡ Hyb3: Since Ëœğ‘  is uniformly chosen and Zğ‘ defines a field,
the two hybrid distributions are identical.
â–¡
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2684