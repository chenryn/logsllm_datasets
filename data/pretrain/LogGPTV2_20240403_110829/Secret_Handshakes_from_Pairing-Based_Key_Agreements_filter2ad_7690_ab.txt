but he would not have been in possession of a secret point
TI that corresponds to that pseudonym, and would therefore
not have been able to calculate the correct session key.
Alice gets away with a warning and drives off to her
meeting. The pro-democracy movement also has a master
secret m, and has issued all its members credentials. Alice’s
credential looks like this:
(“y23987447y”, MA)
where MA = mH1(“y23987447y-member”). At the meet-
ing she runs into Claire. Alice has never met Claire be-
fore and is worried that she might be with the secret police,
rather than the pro-democracy movement. Naturally, Claire
(who in fact is a legitimate member of the movement) has
the same worries about Alice. Neither of them wants to au-
thenticate herself as a member of the movement unless the
other one is a legitimate member herself. So Alice sends
her pseudonym to Claire, and receives Claire’s pseudonym
in return. Let’s say Claire’s pseudonym is k61932843u.
Alice calculates a session key as follows:
KA = ˆe(H1(“k61932843u-member”), MA)
Claire, on the other side, does the corresponding calculation
with Alice’s pseudonym and her own secret point MC. Alice
and Claire then verify that they can communicate with each
other using their respective session keys, and are thus each
convinced that the other is a member of the secret move-
ment.
Alice now meets Dolores, and follows the same protocol
with her. Once she generates the session key with Dolores,
she encrypts a number N under that session key, and asks
Dolores to send her back N + 1. The reply she receives,
however, does not decrypt to N + 1. Alice has now reason
to believe that Dolores is not, in fact, a legitimate member
of the movement. Alice can nonetheless rest assured that
Dolores learned nothing about Alice’s membership in any
secret organization. In fact, from Dolores’ point of view, the
secret handshake was indistinguishable from one in which
Alice had used, say, her driver’s license instead of her mem-
bership credentials for the secret movement.
We end this section with a few observations about the
above example. First, we point out that the protocol as pre-
sented above is a simpliﬁcation of the actual protocol we’re
proposing in this paper. For a more detailed treatment of
our protocol, see Section 4. Second, our protocol can han-
dle mutual authentication of different roles (e.g., “cop” vs.
“driver”).
In the driver’s license example, Bob presum-
ably has little incentive to hide his role from Alice, so a
more traditional authentication protocol would have done
the trick. Imagine, however, a scenario in which both roles
want to hide their identities. Let’s say Radio Liberty oper-
ates streaming audio servers inside Alice’s country, and Al-
ice is a subscriber to that service. The servers don’t want to
authenticate themselves as Radio Liberty outlets unless it’s
to a legitimate subscriber, and the subscribers don’t want
to authenticate themselves as Radio Liberty listeners unless
it’s to a real Radio Liberty server. It’s easy to see how our
protocol can handle this case. Lastly, in our example we did
not address such issues as revocation or linkability, which
are instead addressed in Section 7.
4. Secret-Handshake Schemes
4.1. Deﬁnitions
In this section we introduce the basic deﬁnition of a
secret-handshake scheme. A secret-handshake scheme op-
erates in a universe consisting of a set U of possible users,
a set G of groups in which users may be enrolled, and a set
A of administrators who create groups and enroll users in
Proceedings of the 2003 IEEE Symposium on Security and Privacy (SP(cid:146)03) 
1081-6011/03 $17.00 ' 2003 IEEE 
1. A
2. A
3. A
The various symbols denote:
idA, nA
−−−−−−−−−−−−−→ B
←−−−−−−−−−−−−− B
−−−−−−−−−−−−−→ B
idB, nB,V0
V1
idA, idB : A’s and B’s chosen pseudonyms
nA, nB :
random nonces, generated by A and B
V0 : H2( ˆe(H1(idA), privB)(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)0)
V1 : H2( ˆe(privA, H1(idB))(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)1)
H1 : Collision-resistant hash function from strings to G1
H2 : Collision-resistant hash function from strings to strings with ﬁxed-length output, e.g. SHA-1
privA, privB : A’s and B’s secret points
Figure 1. PBH.Handshake
groups. (We note that the term “group” refers to a grouping
of users, rather than the mathematical deﬁnition of a group.)
These sets can be inﬁnite, and do not need to be speciﬁed in
advance. A secret-handshake scheme SHS consists of the
following algorithms:
• SHS.CreateGroup : G → {0,1}∗
When SHS.CreateGroup(G) is executed by an admin-
istrator A ∈ A, a group secret GroupSecretG ∈ {0,1}∗
is output for the group G;
• SHS.AddUser : U × G ×{0,1}∗ → {0,1}∗
an
When
input
(U, G, GroupSecretG),
enrolls U in the group
G (denoted U ∈ G) by creating a user secret
UserSecretU,G ∈ {0,1}∗
• SHS.Handshake(A, B)
to be given to the user U;
administrator
run
by
on
Speciﬁes a protocol to be executed between users A
and B, which, upon completion2 ensures that B dis-
covers A ∈ G if and only if A also discovers B ∈ G;
• SHS.TraceUser : {0,1}∗ → U
An algorithm run by the system administrator, which,
given a transcript T of interaction of a user U with one
or more users, outputs the identity of the user whose
keys were used by U during the interaction.
• SHS.RemoveUser : {0,1}∗ × U → {0,1}∗
On input
RevokedUserList.
(RevokedUserList,U),
inserts U into
2Note that this deﬁnition does not guarantee fairness: If A aborts the
protocol before sending his ﬁnal message, he may learn whether or not
B ∈ G without revealing corresponding information about himself. This
will not a serious issue, however, as the security deﬁnitions in Section 5.1
will guarantee that A must be a member of G to learn anything about B in
this fashion.
Proceedings of the 2003 IEEE Symposium on Security and Privacy (SP(cid:146)03) 
1081-6011/03 $17.00 ' 2003 IEEE 
To keep the presentation clear, we assume here that each
user is a member of exactly one group. All results gener-
alize to the case where users are allowed to join multiple
groups.
Ideally, if the execution of SHS.Handshake(A, B) estab-
lishes that A and B are members of the same group, it should
also have set up a temporary session key for securing further
communication between A and B. Although not required for
the security deﬁnitions below, this additional requirement is
satisﬁed by our schemes.
4.2. A Concrete Secret-Handshake Scheme
We now present a concrete secret-handshake scheme
based on bilinear pairings. We call this scheme Pairing-
Based Handshake (PBH).
Our system uses a computable, non-degenerate bilin-
ear map ˆe : G1 × G1 −→ G2 for which the Bilinear Difﬁe-
Hellman Problem is assumed to be hard (see Section 3 for
deﬁnitions of these terms). Modiﬁed Weil or Tate pairings
on supersingular elliptic curves are examples for such maps.
We also assume there are two hash functions H1, H2 avail-
able: H1 : {0,1}∗ → G1 maps arbitrary strings to points in
G1, and H2 is a collision-resistant hash function taking ar-
bitrary strings as input (such as SHA-1).
PBH.CreateGroup. The administrator A sets the group se-
cret GroupSecretG to be a random number sG ∈ Zq (where
q is the order of both G1 and G2).
PBH.AddUser. To add a user U to the group G, the admin-
istrator A does the following: First, it generates a list of ran-
dom “pseudonyms” idU1, . . ., idUt ∈ {0,1}∗
for U, where
t is chosen to be larger than the number of handshakes U
will execute before receiving new user secrets. Since only
the administrator and the user itself know the identity U,
Administrator
(s)
Alice
idA = “x54321da”,
privA = sH1(“x54321da.air-marshal”)
id
priv
B= “k82931lf”,
B= sH
1(“k82931lf.air-m
Bob
arshal-service”)
Alice
Bob
idA, nA
idB, nB, V0
V1
…
Figure 2. Pairing-Based Handshake with Roles. The administrator issues credentials to users (left),
who then perform secret handshakes (right).
only the administrator and the user can link any idUi back
to U. The administrator then calculates a corresponding list
of secret points privU1, . . ., privUt as
privUi = sGH1(idUi)
where sG = GroupSecretG. This list of pseudonyms to-
gether with the list of secret points is given as UserSecretU,G
to U.
PBH.Handshake. Let A and B be two users who wish to
conduct a secret handshake. A pulls from his user secret an
unused pseudonym idA ∈ {idAi, . . . , idAt}, together with the
corresponding secret point privA. B likewise pulls idB and
privB. First, A sends his pseudonym, along with a random
nonce nA, to B (see Figure 1). B replies with her pseudonym,
a nonce nB of her choosing, and a value V0. A veriﬁes that
V0 = H2( ˆe(privA, H1(idB))(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)0)
and replies with V1 (message 3 in Figure 1) . B veriﬁes
?= H2( ˆe(H1(idA), privB)(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)1)
V1
If both veriﬁcations succeed3, then A and B can create a
shared secret S for future communication. A calculates the
shared secret like this:
S = H2( ˆe(privA, H1(idB))(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)2)
B calculates the same shared secret S as:
S = H2( ˆe(H1(idA), privB)(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)2)
PBH.TraceUser. Given a transcript of a handshake be-
tween user A and B, the administrator can easily recover
3They will either both succeed or both fail.
Proceedings of the 2003 IEEE Symposium on Security and Privacy (SP(cid:146)03) 
1081-6011/03 $17.00 ' 2003 IEEE 
the pseudonyms idA and idB and look up which users these
pseudonyms had been issued to.
PBH.RemoveUser. To remove a user U from the group G,
the administrator looks up the user secret (idU1, . . . ,idUt,
privU1, . . . , privUt) it has issued to U and alerts every other
user to abort any handshake should they ﬁnd themselves
performing the handshake with a user using any pseudonym
idU ∈ {idU1, . . . , idUt}.
4.3. A Concrete Secret-Handshake Scheme with
Roles
While we deﬁned secret-handshake schemes in terms of
group membership, we can easily extend the PBH scheme
to handle roles in the sense described in Section 1 and Sec-
tion 3. Here is a pairing-based secret-handshake scheme
with roles (PBH-R):
to
This
step is
identical
PBH-R.CreateGroup.
PBH.CreateGroup.
PBH-R.AddUser. Let R ∈ {0,1}∗
be an arbitrary string de-
scribing a role within group G. To add a user U to the group
G in role R, the administrator A does the following: First, it
generates random pseudonyms idUi ∈ {0,1}∗
for i = 1, . . . ,t
(this is identical to PBH.AddUser). The administrator then
calculates the secret points privUi as
privUi = sGH1(idUi(cid:10)R)
where sG = GroupSecretG. The list of pseudonyms together
with the secret points is given as UserSecretU,G to U.
PBH-R.Handshake. Let A and B be using respective
pseudonyms idA and idB, their respective secret points privA
and privB, and their respective roles RA and RB. First, A
sends his pseudonym, along with a random nonce nA, to B:
−−−−−−−−−−−−−→ B
idA, nA
A
B decides that she only wants to perform a secret handshake
(cid:11)
with someone in role R
A. She replies with her pseudonym,
a nonce nB of her choosing, and a value V0:
←−−−−−−−−−−−−− B
idB, nB,V0
A
where
A), privB)(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)0)
V0 = H2( ˆe(H1(idA(cid:10)R
(cid:11)
A decides that he only wants to perform the handshake with
(cid:11)
someone in role R
B. He veriﬁes that
V0 = H2( ˆe(privA, H1(idB(cid:10)R
B))(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)0)
(cid:11)
and replies with V1:
−−−−−−−−−−−−−→ B
V1
A
where
B))(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)1)
V1 = H2( ˆe(privA, H1(idB(cid:10)R
(cid:11)
B veriﬁes
V1
A), privB)(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)1)
?= H2( ˆe(H1(idA(cid:10)R
(cid:11)
The two veriﬁcations either both succeed or both fail.
If
they both succeed, then B has authenticated A as a member
(cid:11)
= RA, and A has authenticated B as a
of group G in role R
(cid:11)
A
= RB. A and B can now create
member of group G in role R
B
a shared secret for future communication. A calculates the
shared secret like this:
S = H2( ˆe(privA, H1(idB(cid:10)R
B))(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)2)
(cid:11)
B calculates the shared secret like this:
A), privB)(cid:10)idA(cid:10)idB(cid:10)nA(cid:10)nB(cid:10)2)
S = H2( ˆe(H1(idA(cid:10)R
(cid:11)
See Figure 2 for examples of PBH-R.AddUser and
PBH-R.Handshake.
PBH-R.TraceUser and PBH-R.RemoveUser. These steps
are identical to PBH.TraceUser and PBH.RemoveUser.
In the following formal treatment of secret handshakes,
we will only consider secret schemes without roles. All our
deﬁnitions, arguments, and security proofs, however, easily
extend to handshake schemes with roles.
Proceedings of the 2003 IEEE Symposium on Security and Privacy (SP(cid:146)03) 
1081-6011/03 $17.00 ' 2003 IEEE 
A ↔ B
A ↔ R
A
B
A
R
M1
M2
M3
...