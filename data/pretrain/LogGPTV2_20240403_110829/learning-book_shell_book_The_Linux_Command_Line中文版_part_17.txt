注意，为什么我们的shell提示符还没有返回？这是因为shell正在等待这个程序结束，就像
到目前为止我们用过的其它所有程序一样。如果我们关闭xlogo窗口，shell提示符就返回了。
11.5中断一个进程
我们再运行xlogo程序一次，观察一下发生了什么事。首先，执行xlogo命令，并且证实这个
程序正在运行。下一步，回到终端窗口，按下Ctrl-c“
[ne0linuxbox -]$ x1ogo
[ne@linuxbox -]$
在一个终端中，输入Ctrl-c，中断一个程序。这意味着，我们礼貌地要求终止这个程序。输
入Ctrl-c之后，xlogo窗口关闭，shell提示符返回。
127
---
## Page 129
通过这个技巧，许多（但不是全部）命令行程序可以被中断。
11.6把一个进程放置到后台 (执行)
假如说我们想让shell提示符返回，却不终止xlogo程序。我们可以把这个程序放到后台
（background）执行。把终端想象是一个有前台（包含在表层可见的事物，像shell提示符）和
后台（包含表层之下的隐藏的事物）（的设备）。为了启动一个程序并让它立即在后台运行，我
们在程序命令之后，加上“&”字符：
ofotx s[- xoqxnutgou]
[1]  28236
[neglinuxbox -]$
执行命令之后，这个xlogo窗口出现，并且shell提示符返回，同时打印一些有趣的数字
这条信息是shell 特性的一部分，叫做任务控制（job control)。通过这条信息，shell告诉我们，
可以看到我们的进程：
[nellinuzbox -]$ ps
PID TTY
TIYE CHD
10603 pts/1
52q00:00:00
28236 pts/1
100:00:00x1ogo
28239 pts/1
100:00:00ps
shell的任务控制功能给出了一种列出从我们终端中启动了的任务的方法。执行jobs 命令，
我们可以看到这个输出列表：
[ne@linuxbox -]$ jobs
[1]+ Running
xlogo &
结果显示我们有一个任务，编号为“1”，它正在运行，并且这个任务的命令是xlogo&。
128
---
## Page 130
11.7进程返回到前台
一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用Ctrl-c来中断它。为了让一个
进程返回前台（foreground)，这样使用fg命令：
[neglinuxbox -]$ jobs
[1]+ Running
xlogo k
[nellinuxbox -]$ fg %1
x1ogo
fg命令之后，跟随着一个百分号和任务序号（叫做jobspec，如此处的%1）就可以了。如
果我们只有一个后台任务，那么jobspec(job specification）是可有可无的。输入Ctrl-c来终止
xlogo程序。
11.8停止一个进程
有时候，我们想要停止一个进程，而不是终止它。我们这么做通常是为了允许前台进程被移动
到后台。输入Ctrl-z.可以停止一个前台进程。让我们试一下。在命令提示符下，执行xlogo
命令，然后输入Ctrl-z:
[ne@linuxbox -]$ xlogo
[1]+ Stopped
xlogo
[ne@linuxbox -]$
停止xlogo程序之后，通过调整xlogo的窗口大小，我们可以证实这个程序已经停止了。它
看起来像死掉了一样。使用fg命令，可以恢复程序到前台运行，或者用bg命令把程序移到后
台。
T Bq $[-xoqxmurtoou]
[1]+ xlogo &
[ne@linuxbox -]$
和fg命令一样，如果只有一个任务的话，jobspec参数是可选的。
129
---
## Page 131
如果我们从命令行启动一个图形程序，但是忘了在命令后加字符“&”，将一个进程从前台
移动到后台也是很方便的。
为什么要从命令行启动一个图形界面程序呢？有两个原因。第一个，你想要启动的程序，可
能没有在窗口管理器的菜单中列出来（比方说xlogo）。第二个，从命令行启动一个程序，你能
够看到一些错误信息，如果从图形界面中运行程序的话，这些信息是不可见的。有时候，一个
程序不能从图形界面菜单中启动。通过从命令行中启动它，我们可能会看到能揭示问题的错误
信息。一些图形界面程序还有许多有意思并且有用的命令行选项。
11.9 Signals
kill命令被用来“条死”程序。这样我们就可以终止需要条死的程序。这里有一个例子：
[ne@linuxbox-]$x1ogo &
[1]  28401
[ne@linuxbox -]$ ki11 28401
[1]+ Terninated
xlogo
首先，我们在后台启动xlogo程序。shell打印出这个后台进程的jobspec和PID。下一步，
我们使用kill命令，并且指定我们想要终止的进程PID。也可以用jobspec（例如，“%1"）来
代替PID。
虽然这个命令看上去很直白，但是它的含义不正于此。这个kill命令不是真的“条死”程
序，而是给程序发送信号。信号是操作系统与程序之间进行通信时所采用的几种方式中的一
种。在使用Ctrl-c和Ctrl-z的过程中我们已经看到信号的实际用法。当终端接受了其中一个
按键组合后，它会给在前端运行的程序发送一个信号。在使用Ctrl-c的情况下，会发送一个叫
做INT（Interrupt，中断）的信号：当使用Ctrl-z时，则发送一个叫做TSTP（Terminal Stop,
终端停止）的信号。程序，相应地，监听信号的到来，当程序接到信号之后，则做出响应。一
个程序能够监听和响应信号这件事允许一个程序做些事情，比如，当程序接到一个终止信号时
它可以保存所做的工作。
11.10通过kill命令给进程发送信号
kill命令被用来给程序发送信号。它最常见的语法形式看起来像这样：
130
---
## Page 132
ki11[-signal] PID...
如果在命令行中没有指定信号，那么默认情况下，发送TERM（Terminate，终止）信号。
kill命令被经常用来发送以下命令：
编号
名字
含义
1
HUP
挂起（Hangup）·这是美好往昔的残留部分，那时候终
端机通过电话线和调制解调器连接到远端的计算机。
这个信号被用来告诉程序，控制的终端机已经“挂
断”。通过关闭一个终端会话，可以展示这个信号的作
用。在当前终端运行的前台程序将会收到这个信号并
终止。许多守护进程也使用这个信号，来重新初始化。
这意味着，当一个守护进程收到这个信号后，这个进
程会重新启动，并且重新读取它的配置文件。Apache
网络服务器守护进程就是一个例子。
2
INT
中断。实现和Ctrl-c一样的功能，由终端发送。通常，
它会终止一个程序。
9
KILL
杀死。这个信号很特别。尽管程序可能会选择不同的
方式来处理发送给它的信号，其中也包含忽略信号，
但是KILL信号从不被发送到目标程序。而是内核立
即终止这个进程。当一个进程以这种方式终止的时候，
它没有机会去做些“清理”工作。或者是保存工作。
因为这个原因，把KILL信号看作最后一招，当其它
终止信号失败后，再使用它。
15
TERM
终止。这是kill命令发送的默认信号。如果程序仍然
“活着”，可以接受信号，那么这个它会终止。
18
CONT
继续。在一个停止信号后，这个信号会恢复进程的运
行。
19
STOP
停止。这个信号导致进程停止运行，而不是终止。像
KILL信号，它不被发送到目标进程，因此它不能被
忽略。
131
---
## Page 133
表11-4:常用信号
让我们试一下kill命令：
[ne@linuxbox -]$ xlogo &
[1] 13546
9991 I- T s[- xoqxnuteou]
[1]+ Hangup
x1ogo
在这个例子里，我们在后台启动xlogo程序，然后通过kill命令，发送给它一个HUP信
号。这个xlogo程序终止运行，并且shell指示这个后台进程已经接受了一个挂起信号。在看
到这条信息之前，你可能需要多按几次enter键。注意，信号既可以用号码，也可以用名字来
指定，包括在前面加上字母“SIG”的名字。
[ne@linuxbox -]$ x1ogo 1] 13601
[ne@linuxbox -]$ ki11 INT 13601
[1]+ Interrupt
x1ogo
[nellinuxbox -]$xlogo 
[1]13608
[ne@linuxbox -]$ ki11SIGINT 13608
[1]+ Interrupt
x1ogo
重复上面的例子，试着使用其它的信号。记住，你也可以用jobspecs来代替PID。
进程，和文件一样，拥有所有者，所以为了能够通过kill命令来给进程发送信号，你必须是
进程的所有者（或者是超级用户）。
除了上表列出的kill命令最常使用的信号之外，还有一些系统频繁使用的信号。以下是其
它一些常用信号列表：
编号
名字
含义
3
QUIT
退出
11
SEGV
段错误（SegmentationViolation）·如果一个程序非法
使用内存，就会发送这个信号。也就是说，程序试图
写入内存，而这个内存空间是不允许此程序写入的。
132
---
## Page 134
20
TSTP
终端停止（Terminal Stop）。当按下Ctrl-z组合键后，
终端发送这个信号。不像STOP信号.TSTP信号由
目标进程接收，且可能被忽略。
28
WINCH
改变窗口大小（WindowChange）。当改变窗口大小
时，系统会发送这个信号。一些程序，像top和less
程序会响应这个信号，按照新窗口的尺寸，刷新显示
的内容。
表11-5:其它常用信号
为了满足读者的好奇心，通过下面的命令可以得到一个完整的信号列表：
[ne@linuxbox -]$ ki11l -1
11.11通过killall命令给多个进程发送信号
也有可能通过killall命令，给匹配特定程序或用户名的多个进程发送信号。下面是killall命令
的语法形式：
ki1lal1[-u user] [signal] nan
为了说明情况，我们将启动一对xlogo程序的实例，然后再终止它们：
[ne@linuxbox -]$ xlogo 
[1]18801
[ne@linuxbox -]$ xlogo 
[2] 18802
[nedlinuxbox -]$ ki1lall xlogo
[1]- Terninated
x1ogo
[2]+ Terninated
x1ogo
记住，和kill命令一样，你必须拥有超级用户权限才能给不属于你的进程发送信号。
133
---
## Page 135
11.12
更多和进程相关的命令
因为监测进程是一个很重要的系统管理任务，所以有许多命令与它相关。玩玩下面几个命令：
命令名
命令描迹
pstree
输出一个树型结构的进程列表（processtree），这个列表展示
了进程间父/子关系。
vmstat
输出一个系统资源使用快照，包括内存，交换分区和磁盘1/
0。为了看到连续的显示结果，则在命令名后加上更新操作
延时的时间（以秒为单位）。例如.“vmstat5”。按下Ctrl-c
组合键，终止输出。
xload
一个图形界面程序，可以画出系统负载随时间变化的图形。
tload
terminal load与xload程序相似，但是在终端中画出图形。
使用Ctrl-c，来终止输出。
表11-6:其它与进程相关的命令
134
---
## Page 136
12
”shell环境
恰如我们之前所讲的，shell在shell会话中保存着大量信息。这些信息被称为（shell的）环境。
程序获取环境中的数据（即环境变量）来了解本机的配置。虽然大多数程序用配置文件来存储
程序设置，一些程序会根据环境变量来调整他们的行为。知道了这些，我们就可以用环境变量
来自定制shell体验。
在这一章，我们将用到以下命令：
·printenv-打印部分或所有的环境变量
·set-设置shell 选项
·export一导出环境变量，让随后执行的程序知道。
·alias-创建命令别名
12.1什么存储在环境变量中？
shell在环境中存储了两种基本类型的数据，虽然bash几乎无法分辨这些数据的类型。它们
是环境变量和shell变量。Shell变量是bash存放的少量数据。剩下的都是环境变量。除了变
量，shell也存储了一些可编程的数据，即别名和shell函数。我们已经在第六章讨论了别名
而shell函数（涉及到shell脚本）将会在本章第五部分叙远。
12.2检查环境变量
我们可以用bash的内建命令set，或者是printenv程序来查看环境变量°set 命令可以显示
shell或环境变量，而printenv只是显示环境变量。因为环境变量列表比较长，最好把每个命令
的输出通过管道传递给less来阅读：
135
---
## Page 137
[ne@linuxbox -]$ printenv | less