在逆序环视被匹配之后，字符类w+>会尝试去匹配一个或者多个单词字符。它会匹配
cat。（w+>并不属于任何类型的环视或者分组，因此它会正常地匹配文本cat。我们说（w+>
匹配并且消耗（consume）了cat，而环视则只能匹配内容，却从来不会消耗任何东西。
向前看的环视，也就是照正则表达式通常遍历的方向看的情形，被称作顺序环视
（lookahead）。顺序环视在本书中的所有正则流派中都拥有相同的支持。肯定型顺序环
视（positivelookahead）的语法是来表示。
72第2章
www.TopSage.com
---
## Page 89
当在)\w+(?=))中的匹配了Mycatisfurry中的cat的时候，
正则引擎就进人了顺序环视。在这个时候顺序环视唯一特殊的行为是正则引擎会记住
它已经匹配了的文本部分，并把它同顺序环视关联起来。接着（>会被正常匹配。
现在正则引擎会退出顺序环视。在环视中正则表达式产生了匹配，因此环视自身也就
匹配成功了。正则引擎接着会丢弃由环视匹配的文本，恢复在进人环视的时候它记住
的正在匹配的内容。这样我们整体上的匹配进程就回到了ca。因为这是我们正则表达
式的结束，所以cat就成为了最终的匹配结果。
否定型环视
把环视中的相等符号换成感叹号的话，（?!regex)就成为了一个否定型顺序环视
(negativelookahead)。否定型顺序环视与肯定型顺序环视用起来是一样的，唯一的区别
是肯定型顺序环视会在顺序环视中的正则式匹配时产生匹配，而否定型顺序环视则正
好相反，它在当顺序环视内的正则式匹配时，会匹配失败。
匹配的过程则是完全相同的。引擎会在进人否定型顺序环视的时候保存当前匹配，然
后试图正常地匹配顺序环视中的正则表达式。如果这个子表达式匹配的话，那么顺序
环视会失败，而正则引擎会进行回溯。如果这个子表达式不能匹配的话，那么引擎会
恢复当前匹配，然后继续处理正则表达式的剩余部分。
类似的，(?。
在内部，Perl、Python和Ruby1.9会把这个表达式扩展为6个逆序环视的测试。首先，
它们会回跳3个字符来检查和）之
外的所有东西。在内部实现中，PCRE和Java会计算在逆序环视中的正则表达式部分
可能会匹配的文本的最小和最大长度。如果它匹配失败的话，那么它们会回跳一个字
符再试，直到逆序环视产生匹配或者是尝试到了最大可能的字符数目。
如果这些听起来都不是很高效，事实上也正是如此。逆序环视用起来是非常方便的结
构，但是它的速度就很一般了。稍后我们会讲解在根本不支持逆序环视的JavaScript和
Ruby1.8中的一个解决方案。这个解决方案实际上会比使用逆序环视的效率要高很多。
.NET框架中的正则表达式引擎是唯一可以实际上从右向左应用一个完整正则表达式的
引擎”。.NET允许在逆序环视中使用任何东西，而且它会实际上从右向左来应用正则表
达式。在逆序环视中的正则表达式和目标文本都是按照从右向左来进行扫描的。
两次匹配相同的文本
如果在正则表达式的开始处使用逆序环视，或者在正则表达式的结尾处使用顺序环视，
那么这样做的效果就是要求在正则匹配之前或者之后出现一些东西，但不要把它们包
含到匹配中。如果在正则表达式的中间使用环视的话，那么就可以对同一段文本应用
多次检查。
国语的数字。只有在.NET和Java中才会支持字符类的差。
如果一个字符既是泰国语字符（任何类型），又是数字（任意字符集），那么它就是一
个泰国语数字。如果使用顺序环视，你可以在同一个字符上检查这两个要求：
(?=\p(Thai}) \p (N)
正则选项：无
正则流派：PCRE、Per1、Ruby1.9
这个正则表达式只能用于支持Unicode字符集的3种流派，如实例2.7所示。但是使用
顺序环视来匹配同一个字符多次的思想则可以用于本书中讨论的所有流派。
当正则引擎查找?=p{Thai})p{N}）的时候，它先是会在开始进行匹配的字符串中的每
一个位置进入顺序环视。如果在该位置的字符不在泰国语字符集（也就是说产生匹配。因此，环视（?=p{Thai))）：
RegexBuddy的正则引擎也允许在逆序环视中使用一个完整的正则表达式，但是它（还）没提供类似
于.NET中的RegexOptions.RightToLeft的功能来把整个正则表达式都倒过来。
74第2章
www.TopSage.com
---
## Page 91
也会匹配成功。当引擎退出环视的的时候，它会恢复当前匹配进程。在这个例子中，
也就是在刚找到泰国语字符之前的长度为0的匹配。接下来要匹配的是p{N}>。因为
顺序环视已经丢弃了它的匹配，因此p{N}>会同p{Thai}已经匹配了的那个字符进
行比较。如果该字符拥有Unicode属性Number的话，那么p{N}>会匹配成功。因为
并不位于一个环视之内，所以它会消耗掉这个字符，同时我们也就找到了想要的泰国
语数字。
环视是原子分组
当正则表达式引擎退出一个环视分组的时候，它会丢弃掉环视匹配的文本。因为该文
本被丢弃了，所以由位于环视之内的多选结构或者量词所记住的任意回溯位置也都会
被丢弃。这样实际上就会把顺序环视和逆序环视都变成了原子分组。实例2.15中详细
讲解了原子分组的概念。
在大多数情形下，环视的原子特性是无关紧要的。环视只是一个用来检查位于环视中
的正则表达式是匹配成功还是失败的一个断言。它可以通过多少种方式产生匹配并不
重要，因为它不会消耗目标文本中的任何字符。
当你在顺序环视（以及逆序环视，如果你的正则流派支持）之内使用捕获分组的时候，
它的原子特性才会产生意义。虽然顺序环视不会消耗任何文本，但是正则引擎会记住
文本中哪些部分被位于顺序环视中的任何捕获分组匹配了。如果顺序环视位于正则表
达式的结尾处，那么你实际上所得到的捕获分组所匹配的文本是正则表达式自身所不
能匹配的。如果这个顺序环视位于正则表达式中间，那么你所得到的多个捕获分组可
能会匹配到目标文本中的重叠部分。
环视的原子特性也可能会改变整个正则表达式的匹配，出现这种情况的唯一可能是当
你在环视之外使用-个反向引用来指向在环视之内所创建的捕获分组。下面来看一下
这个正则表达式：
(?=（\d+))\w+\1
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
一眼看过去，你可能会认为这个正则表达式能够匹配123x12。会把12捕获到第
一个捕获分组中，接着会再次匹配12。
但这不可能发生。正则表达式会进人环视并捕获分组。贪心的会匹配123。这个匹配被
存储到第一个捕获分组中。引擎接着退出顺序环视，把当前匹配重新设置为字符串的开始，
并且丢弃由贪心的加号所记住的回溯位置，但是会在第一个捕获分组中保留所存储的123。
现在，贪心的会在字符串开始处进行尝试。它会把123x12都吃掉。这时指向123
的1>在字符串结尾处匹配失败。（w+>会回溯一个字符。还是会失败。（w+会继
续回溯，直到它放弃了除了目标文本中第-一个1之外的所有字符。1>在第一个1之后
正则表达式的基本技巧75
www.TopSage.com
---
## Page 92
还是会匹配失败。
如集正则引擎能够返回到顺序环视中，放弃123而选择12，那么最后的12会匹配。
但是正则引擎并不会这样做。
正则引擎此时并不存在可以选择的任何回溯位置。（w+）已经回退到头了，而环视迫使
\d+>把它的回溯位置都丢掉了。因此匹配尝试会宣告失败。
不使用逆序环视的解决方案
虽然我们在前面讲了这么多内容，但是如果你用的是Python或者JavaScript，那么这些
对你都毫无用处，因为你根本就不能使用逆序环视。使用这两种正则流派无法恰好解
决前面所给出的问题，但是你可以通过使用捕获分组来模仿逆序环视。下面给出的这
个可选方案也可以在所有其他正则流派中使用：
()(\w+) (?=)
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
作为逆序环视的替代，我们使用了一个捕获分组来匹配起始tag：（。我们还把感兴
趣的匹配部分，也就是w+)，放到了捕获分组中。
当把这个正则表达式应用到Mycatisfurry之上的时候，这个正则表达式的匹
配会是b>cat。第一个捕获分组会保存，而第二个会保存cat。
如果题目的要求是只匹配cat（在两个tag之间的单词），因为你只想提取文本中的
内容，那么可以通过只保存第二个捕获分组所匹配的文本，而不是整个正则表达式匹
配的文本来达到这一目标。
如果要求是想要进行查找和替换，而只替换在两个tag之间的单词的话，那么可以使用
一个反向引用来指向第-一个捕获分组，把起始tag重新添加到替代文本中。在这个例子
中，实际上并不需要捕获分组，因为起始tag总是相同的。但是当它可变的时候，捕获
分组会重新插人与前面匹配到的一模一样的内容。实例2.21对此有更详细的讲解。
最后，如果你真的想要模拟逆序环视的话，那么可以使用两个正则表达式来完成。首
先，不使用逆序环视来查找你的正则表达式。当它匹配成功时，把在匹配之前的目标
文本子串复制到一个新的字符串变量中。然后用第二个正则表达式，加上字符串结束
定位符（z>或S>），检查你在逆序环视中所做的事情。这个定位符会确保第二个正则
的地方，所以这样就会把第二个匹配刚好放到第一个匹配的左边。
在JavaScript中，可以使用如下的代码来完成这项任务：
var mainregexp =/\w+(?=)/;
var 1ookbehind=/$/;
/>>x.x
76第2章
www.TopSage.com
---
## Page 93
//Foundawordbeforeaclosingtag
var potentialmatch = match[0];
var leftContext =match.input.substring(0,match.index);
if (lookbehind.exec(leftContext))(
// Lookbehind matched:
//potentialmatch occursbetweenapair oftags
}else{
// Lookbehind failed: potentialmatch is no good
}else{
//Unable tofind a word beforea closing tag
参见
实例5.5和5.6。
2.17
根据条件匹配两者之一
问题描述
创建一个正则表达式，匹配一个由逗号分隔的单词列表one、two和three。每个单词可
以在该列表中出现任意多次，但是每个单词必须至少出现一次。
解决方案
\b(?:(?:(one)1(two) 1(three))(?:,1\b)) {3,}(?(1) 1(?!))(?(2)1(?!))(?(3)1(
?!))
正则选项：无
正则流派：.NET、JavaScript、PCRE、Perl、Python
Java和Ruby并不支持条件判断。在Java或Ruby（或者其他任何语言）中进行编程的
时候，你可以使用不带有条件判断的正则表达式，然后再编写一些额外的代码来检查
其中的三个捕获分组是否都匹配了相应的内容。
\b(?:(?:（one)1(two)1(three))(?:,I\b))(3,)
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
.NET、JavaScript、PCRE、Perl和Python支持使用编号捕获分组的条件判断（conditional）。
。如果捕获分组到目前为止还没有参与匹配尝试，
那么就会去尝试匹配（else)。
这里的括号、问号和竖线都是属于条件判断语法的一部分。它们在这里并不拥有平时
正则表达式的基本技巧
77
www.TopSage.com
---
## Page 94
的含义。你可以在（then>和else>部分中使用任意种类的正则表达式。唯一的限制是如
果想要在其中一个部分之内使用多选结构，那么你必须使用一个分组来把它包到一起。
在条件判断中只充许直接出现一个竖线。
如果愿意，也可以省略掉（then>或（else>的部分。空的正则表达式总是会找到一个长度
部分。如果捕获分组参与了匹配，那么这个条件判断只会简单地产生匹配。
一个空的否定型顺序环视(?!)被用在了《else>部分。因为空的正则表达式总是会产生
匹配，所以包含空正则表达式的否定型顺序环视则总是会匹配失败。因此，当第一个
捕获分组没有匹配到任何东西的时候，条件判断?（1?!)总是会失败。
通过把这三个必需的多选结构放到自已的捕获分组中，我们可以在正则表达式的结尾
使用3个条件判断来检查是否所有的捕获分组都捕获到了内容。
NET还支持命名的条件判断。（?（name）thenlelse）会检查命名的捕获分组name是否参
与了匹配尝试。
为了更好地理解条件判断是如何工作的，我们来看一个正则表达式(a)？b(？(1)cld)>。它
本质上是与（abcbd等价的一种更为复杂的形式。