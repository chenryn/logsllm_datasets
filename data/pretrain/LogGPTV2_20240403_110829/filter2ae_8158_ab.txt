  3. 扫描一些字节值，如果全为0，说明仍在安全区，返回第2步。
  4. 结束。
在最坏的情形下，我们需要2^28*page_size(通常是4KB)次读取，但由于内存是页对齐的，所以实际上只需要2^28次即可。由于安全区大小有2^42字节，十分稀疏，几乎全由0构成，故可以取足够多的值，通过当前值是否为0判断是否命中libc，这又能进一步较少读取次数。为了保证准确性，选取libc每页偏移为1272和1672的字节（这两者至少有一个不为0）和另外5个字节，同时为每个字节准备30个样本进行时间侧信道攻击来估计数据。下图展示了样本量和误报率（将0识别为非0，可能导致将安全区误认为libc）的关系。
可以看到，在前述发送10000个请求的前提下，每个字节采集30个样本已经能保证误报率为0。
这样一来，实际的最大读取次数就进一步被降低为228 * 212/221 =
219次。不会导致崩溃的算法在定位libc阶段需要进行7*219*30=110100480次读取，约耗时97小时。图示如下：
现在已经定位到libc,但我们仍不知道我们具体在libc的什么位置，所以，攻击者从页内偏移3333的位置再取70个字节，与本地libc进行匹配，又要再耗时1小时，总计耗时98小时。
### 会导致崩溃的算法
如果我们可以接受程序崩溃的话，就可以引入二分查找算法。任何在mmap基址之上的地址将会导致崩溃，那么我们只要找到这样一个地址X即可：
X本身安全,但X向高地址调整一个libc大小后导致崩溃。
这说明X位于libc中。在二分查找算法下，我们只需最多读19次，并最多造成19次崩溃即可定位到上述X。给定可以接受的崩溃次数T，则扫描可以覆盖的最大内存数量f(i,
j)和崩溃次数i,页读取数j有如下递推关系：
T与读取次数关系可绘制图像如下：
可能导致崩溃的算法如下：
会导致崩溃的算法则要快得多，在平均12次崩溃之后，耗费几秒就能定位到libc的具体位置。
实施以上两个算法，可以很方便的定位到libc基址libc_base，而安全区基址safe_region_address可以计算如下：
至此，安全区的定位就完成了。
## 攻击安全区
现在，攻击者已经明确了安全区基址，某个代码指针ptr_address的地址只需要与掩码cpi_addr_mask（0x00fffffffff8）进行运算即可。接下来要做的就是使用前述nelts指针，改变安全区的read_handler入口，然后就可以修改代码指针的相关元数据（存储有其值，地址上下界等信息），是目标代码指针指向系统调用sysenter。而x86-64环境下借由sysenter进行的攻击就是老生常谈了。这里简单介绍一下。攻击者可修改相关寄存器的值，使sysenter直接执行某个命令，或者是让控制流转向某个ROP链的开头。实际攻击时，耗费了6s完成整个攻击。接下来我简单的为大家介绍一下攻击过程。（涉及到的脚本暂时还没有开放）
开启nginx服务器，启动攻击脚本：
服务器显示有10次崩溃：
libc具体位置和安全区的起始位置已经被定位到：
继续进行，成功开启shell:
### 回头看：CPI的设计缺陷
在已有的x86-64架构下的CPI实现中，段保护已经不可用。而其使用以地址为下标的数组来实现元数据，所以该数组地址被存储在一个静态表__llvm__cpi_table中，使得默认设置下没有任何特殊保护。这可能是由于是早期版本的关系。另外，不管有没有实施随机化，安全区的分配总是依赖于mmap来进行，这使得整个CPI无法防御经由内存泄露进行的攻击。而很多系统暂不支持地址随机化，或者是只能实施局部的随机化，这都会削弱CPI的安全性。而在32位系统内，CPI使用了段寄存器（gs寄存器），这可能会导致TLS（thread
local
storage，线程本地存储）冲突，以libc为例，其中使用了gs寄存器的指令约有3000条。而简单的换用其他寄存器，如fs寄存器，有可能导致兼容性问题，比如wine就需要使用到fs寄存器。而当CPI向其作者提出的那样用以保护系统内核的话，由于操作系统对这些寄存器有着特殊的用途，使用这样的寄存器更是会造成不可避免的冲突。
### 改进CPI
对CPI的改进要立足于增加攻击过程中的崩溃次数，但必须指出的是，这些改进都无法百分百防御对不支持段保护的系统的攻击。
  1. 扩充安全区大小。这是一个最直接，最简单的想法，但遗憾是的是，单纯的扩充安全区大小并不能抵抗前述进行的侧信道攻击。所以必须增加额外的寄存器来保护偏移量，并为相关操作设计专门的指令。
  2. 对安全区实施严格地址随机化。这将会使得没有映射的内存块变大，增加攻击时访问到这些区域的机会，进而触发崩溃。但正如前述二分查找算法所显示的，攻击者能够在有限的崩溃里达到目标。类似堆喷射进行大量的堆分配和泄露任何动态链接库的地址都能破解随机化。
  3. 使用哈希函数。这会来巨大的开销，同时哈希函数的安全性没有绝对的保证。
  4. 缩减安全区。这和第1点恰恰相反，看似有道理，但是如果mmap仍然是连续的，则其实质没有改变。所以必须同时搭配不连续的mmap。更小的安全区会引入额外开销，并且有可能没有足够空间用以保护敏感指针。
  5. 使用不连续的随机mmap。这一方案必须搭配第4点使用，否则任何破解随机化的技术（如第2点当中提及的两项）都将削弱其安全性。
### CPI作者的回应
攻击公开后，CPI作者做了正式的回应。有趣的是，回应的标题是Getting The Point(er)，而攻击论文的标题是Missing the
Point(er)。回应重申，CPI的正确性是经过形式化证明的，攻击只是针对其中最简单的一种实现。其他更复杂的实现会导致更多的程序崩溃（约51000次，对CPS来说约867000次），而作者相信这样的崩溃是能被检测到的。
## 结语
信息安全的发展从来就不是攻击或者是防御单方面能够推动的。道高一尺魔高一丈在信安领域体现的最为明显。一个人造出了坚固的盾，就有千百人想要用一把锋利的矛来攻破它（有些人选择绕开持盾者，更有甚者，直接看准时机杀死拿盾的人）。反之亦然。信息安全就在这样的发展过程中，从无到有，由小而大。
## 一点八卦
提出攻击的论文是由美国国防部及美国空军赞助的。具体可见如下论文注释：
    “此项工作由国防部国防研究与工程办公室副主任在空军FA8721-05-C-0002号合同框架内赞助。本文任何意见，解释，结论和建议是作者的观点，不一定得到美国政府的认可。”