在基本内联汇编中，我们只有指令。然而在扩展汇编中，我们可以同时指定操作数。它允许我们指定输入寄存器、输出寄存器以及修饰寄存器列表。GCC 不强制用户必须指定使用的寄存器。我们可以把头疼的事留给 GCC ，这可能可以更好地适应 GCC 的优化。不管怎么说，基本格式为：
```
asm ( 汇编程序模板 
    : 输出操作数                   /* 可选的 */
    : 输入操作数                  /* 可选的 */
    : 修饰寄存器列表             /* 可选的 */
    );
```
汇编程序模板由汇编指令组成。每一个操作数由一个操作数约束字符串所描述，其后紧接一个括弧括起的 C 表达式。冒号用于将汇编程序模板和第一个输出操作数分开，另一个（冒号）用于将最后一个输出操作数和第一个输入操作数分开（如果存在的话）。逗号用于分离每一个组内的操作数。总操作数的数目限制在 10 个，或者机器描述中的任何指令格式中的最大操作数数目，以较大者为准。
如果没有输出操作数但存在输入操作数，你必须将两个连续的冒号放置于输出操作数原本会放置的地方周围。
示例：
```
asm ("cld\n\t"
     "rep\n\t"
     "stosl"
     : /* 无输出寄存器 */
     : "c" (count), "a" (fill_value), "D" (dest)
     : "%ecx", "%edi" 
     );
```
现在来看看这段代码是干什么的？以上的内联汇编是将 `fill_value` 值连续 `count` 次拷贝到寄存器 `edi` 所指位置（LCTT 译注：每执行 stosl 一次，寄存器 edi 的值会递增或递减，这取决于是否设置了 direction 标志，因此以上代码实则初始化一个内存块）。 它也告诉 gcc 寄存器 `ecx` 和 `edi` 一直无效（LCTT 译注：原文为 eax ，但代码修饰寄存器列表中为 ecx，因此这可能为作者的纰漏。）。为了更加清晰地说明，让我们再看一个示例。
```
int a=10, b;
asm ("movl %1, %%eax; 
      movl %%eax, %0;"
     :"=r"(b)        /* 输出 */
     :"r"(a)         /* 输入 */
     :"%eax"         /* 修饰寄存器 */
     );       
```
这里我们所做的是使用汇编指令使 ’b’ 变量的值等于 ’a’ 变量的值。一些有意思的地方是：
* "b" 为输出操作数，用 %0 引用，并且 "a" 为输入操作数，用 %1 引用。
* "r" 为操作数约束。之后我们会更详细地了解约束（字符串）。目前，"r" 告诉 GCC 可以使用任一寄存器存储操作数。输出操作数约束应该有一个约束修饰符 "=" 。这修饰符表明它是一个只读的输出操作数。
* 寄存器名字以两个 % 为前缀。这有利于 GCC 区分操作数和寄存器。操作数以一个 % 为前缀。
* 第三个冒号之后的修饰寄存器 %eax 用于告诉 GCC %eax 的值将会在 "asm" 内部被修改，所以 GCC 将不会使用此寄存器存储任何其他值。
当 “asm” 执行完毕， "b" 变量会映射到更新的值，因为它被指定为输出操作数。换句话说， “asm” 内 "b" 变量的修改应该会被映射到 “asm” 外部。
现在，我们可以更详细地看看每一个域。
#### 5.1 汇编程序模板
汇编程序模板包含了被插入到 C 程序的汇编指令集。其格式为：每条指令用双引号圈起，或者整个指令组用双引号圈起。同时每条指令应以分界符结尾。有效的分界符有换行符（`\n`）和分号（`;`）。`\n` 可以紧随一个制表符（`\t`）。我们应该都明白使用换行符或制表符的原因了吧（LCTT 译注：就是为了排版和分隔）？和 C 表达式对应的操作数使用 %0、%1 ... 等等表示。
#### 5.2 操作数
C 表达式用作 “asm” 内的汇编指令操作数。每个操作数前面是以双引号圈起的操作数约束。对于输出操作数，在引号内还有一个约束修饰符，其后紧随一个用于表示操作数的 C 表达式。即，“操作数约束”（C 表达式）是一个通用格式。对于输出操作数，还有一个额外的修饰符。约束字符串主要用于决定操作数的寻址方式，同时也用于指定使用的寄存器。
如果我们使用的操作数多于一个，那么每一个操作数用逗号隔开。
在汇编程序模板中，每个操作数用数字引用。编号方式如下。如果总共有 n 个操作数（包括输入和输出操作数），那么第一个输出操作数编号为 0 ，逐项递增，并且最后一个输入操作数编号为 n - 1 。操作数的最大数目在前一节我们讲过。
输出操作数表达式必须为左值。输入操作数的要求不像这样严格。它们可以为表达式。扩展汇编特性常常用于编译器所不知道的机器指令 ;-)。如果输出表达式无法直接寻址（即，它是一个位域），我们的约束字符串必须给定一个寄存器。在这种情况下，GCC 将会使用该寄存器作为汇编的输出，然后存储该寄存器的内容到输出。
正如前面所陈述的一样，普通的输出操作数必须为只写的； GCC 将会假设指令前的操作数值是死的，并且不需要被（提前）生成。扩展汇编也支持输入-输出或者读-写操作数。
所以现在我们来关注一些示例。我们想要求一个数的5次方结果。为了计算该值，我们使用 `lea` 指令。
```
asm ("leal (%1,%1,4), %0"
     : "=r" (five_times_x)
     : "r" (x) 
     );
```
这里我们的输入为 x。我们不指定使用的寄存器。 GCC 将会选择一些输入寄存器，一个输出寄存器，来做我们预期的工作。如果我们想要输入和输出放在同一个寄存器里，我们也可以要求 GCC 这样做。这里我们使用那些读-写操作数类型。这里我们通过指定合适的约束来实现它。
```
asm ("leal (%0,%0,4), %0"
     : "=r" (five_times_x)
     : "0" (x) 
     );
```
现在输出和输出操作数位于同一个寄存器。但是我们无法得知是哪一个寄存器。现在假如我们也想要指定操作数所在的寄存器，这里有一种方法。
```
asm ("leal (%%ecx,%%ecx,4), %%ecx"
     : "=c" (x)
     : "c" (x) 
     );
```
在以上三个示例中，我们并没有在修饰寄存器列表里添加任何寄存器，为什么？在头两个示例， GCC 决定了寄存器并且它知道发生了什么改变。在最后一个示例，我们不必将 'ecx' 添加到修饰寄存器列表（LCTT 译注： 原文修饰寄存器列表这个单词拼写有错，这里已修正），gcc 知道它表示 x。因此，因为它可以知道 `ecx` 的值，它就不被当作修饰的（寄存器）了。
#### 5.3 修饰寄存器列表
一些指令会破坏一些硬件寄存器内容。我们不得不在修饰寄存器中列出这些寄存器，即汇编函数内第三个 ’**:**’ 之后的域。这可以通知 gcc 我们将会自己使用和修改这些寄存器，这样 gcc 就不会假设存入这些寄存器的值是有效的。我们不用在这个列表里列出输入、输出寄存器。因为 gcc 知道 “asm” 使用了它们（因为它们被显式地指定为约束了）。如果指令隐式或显式地使用了任何其他寄存器，（并且寄存器没有出现在输出或者输出约束列表里），那么就需要在修饰寄存器列表中指定这些寄存器。
如果我们的指令可以修改条件码寄存器（cc），我们必须将 "cc" 添加进修饰寄存器列表。
如果我们的指令以不可预测的方式修改了内存，那么需要将 "memory" 添加进修饰寄存器列表。这可以使 GCC 不会在汇编指令间保持缓存于寄存器的内存值。如果被影响的内存不在汇编的输入或输出列表中，我们也必须添加 **volatile** 关键词。
我们可以按我们的需求多次读写修饰寄存器。参考一下模板内的多指令示例；它假设子例程 \_foo 接受寄存器 `eax` 和 `ecx` 里的参数。
```
asm ("movl %0,%%eax;
      movl %1,%%ecx;
      call _foo"
     : /* no outputs */
     : "g" (from), "g" (to)
     : "eax", "ecx"
     );
```
#### 5.4 Volatile ...?
如果你熟悉内核源码或者类似漂亮的代码，你一定见过许多声明为 `volatile` 或者 `__volatile__`的函数，其跟着一个 `asm` 或者 `__asm__`。我之前提到过关键词 `asm` 和 `__asm__`。那么什么是 `volatile` 呢？
如果我们的汇编语句必须在我们放置它的地方执行（例如，不能为了优化而被移出循环语句），将关键词 `volatile` 放置在 asm 后面、()的前面。以防止它被移动、删除或者其他操作，我们将其声明为 `asm volatile ( ... : ... : ... : ...);`
如果担心发生冲突，请使用 `__volatile__`。
如果我们的汇编只是用于一些计算并且没有任何副作用，不使用 `volatile` 关键词会更好。不使用 `volatile` 可以帮助 gcc 优化代码并使代码更漂亮。
在“一些实用的诀窍”一节中，我提供了多个内联汇编函数的例子。那里我们可以了解到修饰寄存器列表的细节。
### 6. 更多关于约束
到这个时候，你可能已经了解到约束和内联汇编有很大的关联。但我们对约束讲的还不多。约束用于表明一个操作数是否可以位于寄存器和位于哪种寄存器；操作数是否可以为一个内存引用和哪种地址；操作数是否可以为一个立即数和它可能的取值范围（即值的范围），等等。
#### 6.1 常用约束
在许多约束中，只有小部分是常用的。我们来看看这些约束。
1. **寄存器操作数约束（r）**
当使用这种约束指定操作数时，它们存储在通用寄存器（GPR）中。请看下面示例：
`asm ("movl %%eax, %0\n" :"=r"(myval));`
这里，变量 myval 保存在寄存器中，寄存器 eax 的值被复制到该寄存器中，并且 myval 的值从寄存器更新到了内存。当指定 "r" 约束时， gcc 可以将变量保存在任何可用的 GPR 中。要指定寄存器，你必须使用特定寄存器约束直接地指定寄存器的名字。它们为：
```
+---+--------------------+
| r |    Register(s)     |
+---+--------------------+
| a |   %eax, %ax, %al   |
| b |   %ebx, %bx, %bl   |
| c |   %ecx, %cx, %cl   |
| d |   %edx, %dx, %dl   |
| S |   %esi, %si        |
| D |   %edi, %di        |
+---+--------------------+
```
2. **内存操作数约束（m）**
当操作数位于内存时，任何对它们的操作将直接发生在内存位置，这与寄存器约束相反，后者首先将值存储在要修改的寄存器中，然后将它写回到内存位置。但寄存器约束通常用于一个指令必须使用它们或者它们可以大大提高处理速度的地方。当需要在 “asm” 内更新一个 C 变量，而又不想使用寄存器去保存它的值，使用内存最为有效。例如，IDTR 寄存器的值存储于内存位置 loc 处：
`asm("sidt %0\n" : :"m"(loc));`
3. **匹配（数字）约束**
在某些情况下，一个变量可能既充当输入操作数，也充当输出操作数。可以通过使用匹配约束在 "asm" 中指定这种情况。
`asm ("incl %0" :"=a"(var):"0"(var));`
在操作数那一节中，我们也看到了一些类似的示例。在这个匹配约束的示例中，寄存器 "%eax" 既用作输入变量，也用作输出变量。 var 输入被读进 %eax，并且等递增后更新的 %eax 再次被存储进 var。这里的 "0" 用于指定与第 0 个输出变量相同的约束。也就是，它指定 var 输出实例应只被存储在 "%eax" 中。该约束可用于：
	* 在输入从变量读取或变量修改后且修改被写回同一变量的情况