cmp
0x11,
0xa
0xa
299
cmp
0x11,
300
cmp0x11,
0xa
TOE
cmp 0x11,
302
0xa
cmp 0x11,
Oxa
0xa
cmp 0x11,
304
cmp
Oxaaaaaaaa,
0x53dc2c9f
:00401428
：0040142A
cal1
moV
dword ptr [edx*4]
esi,eax
：00401420
mb
short 1oc_401438
eax, esi
:0048142F
：00401431
：e84e1438
nov
dword ptr [edi+14h],eFFFFFFfFh
:ee4e1438 1oc_481438:
eax,[edi]
 CODE XREF: sub_4814e8+2Ftj
:8040143A
Aou
：00401430
cal1
BOV
dword ptr [eax+ech]
ecx, edi
：0040143F
BOV
edx,[edi]
：00401441
nov
ecx,
edi
:ee481443
:00401445
cal1
mov
esi,
dword ptr
eax
：00481448
add
dword ptr [edi+24h],2
[edx+4]
:e040144C
:0040144E
eax, esi
dword ptr [edi+14h], 1
short 1oc_401457
:00401450
：00401457
nov
：00401457
1oc_401457:
edi
:CODE XREF: sub_401400+4Et§
:00481457
::e8481458
pop
pop
esi
:ee4e1459 sub_4814eB
:00401459
retn
endp
Fig, 5.136 The second half of code for sub_401400
doesn’t report segmentation faults when it encounters inaccessible addresses. Ana-
lyzing the assembly code and you will find that the memory address of v1[5] is edi
+0x14, if the data currently compared is the read flag, set the v1[5] to zero to let the
program compare correctly to get the following flag. As the flag is compared
reversely, you need also to reverse the flag when outputting it.
The challenge was then pinned with the newly generated Pintool, see Fig. 5.139.
---
## Page 435
5.7 Modern Reverse Engineering Techniques
421
string flag;
veld logCMP(ADORINT eax, ADDRINT es1) {
snprintf(tnp, sizeof(tmp),“cmp %p, %p”,eax, esi);
char tmp[1024];
out= oxff) (
snprintf(tmp, sizeof(tmp), "xx"， esi);
flag += string(tmp);
void insTrace(INS ins, voTD +v) {
if (translateIP(INs_Address(ins)) = ex4θ1412) (
INS_InsertCa11(ins,IPOINT_AFTER,(AFUNPTR)logCMP,
IARG_REG_VALUE, REG_EAX,
IARG_REG_VALUE, REG_ESI,
IARG_END);
else if (translateIP(INS_Address(ins)) * 8xee4e1457)(
INS_InsertCal1(ins, IPOINT_BEFORE,(AFUNPTR)editResult,
IARG_REG_VALUE, REG_EAX,
IARG_REG_VALUE, REG_EDI,
IARG_END);
Fig, 5.137 Instrumentation code
Here the program already assumes that the input flag is correct because Pintool
has set the comparison variable of the flag to be correct.
The log file generated by Pintool is shown in Fig. 5.140.
It can be seen that the flag has been written to the log file, and using the calculated
flag to enter the challenge without instrumentation, the verification is passed, see
Fig. 5.141.
Pin can trace instruction execution information, modify memory, and its appli-
cation scenarios are not limited to virtual machines, but the reader should
explore more.
5.7.3.7 Pin Summary
Pin is a very powerful tool for instrumentation, and like IDA, the same software will
work differently in different hands. As the old saying goes, *To do a good job, one
---
## Page 436
422
5Reverse Engineering
reverse(flag.begin(),flag.end());
*out = exff)
PIN_SafeCopy((vo5d*)(edi+0x14),&tmp2, sizeof(ADoRINT));
snprintf(tmpStr, sizeof(tnpStr),“old Data: %p*, *(AcoRINT+)（edi + ex14));
out pin32tVHyPinToo1.d11*0 1og.10gb0x04
GreattAd Flag（）to hash and submit
Fig, 5.139 Run pin32
1og.1og
661
cp Oxaaaaaaaa,
0x8e39b869
662
old
Data:
0x0
99
duo
0x11,
Oxa
664
old
Data:
0x1
565
cmp
0x11,
999
Oxa
PTO
0x1
567
cmp
0x11,
Oxa
668
PTO
Data:
0x1
569
cnp
0x11,
Oxa
570
old
Data1
0x1
671
dao
old
0x11,
Data:
Oxa
572
0x1
573
cmp
0x11,
0x1
0xa
674
old Data:
575
old Data:
cmp
0x11,
Oxa
576
0x1
678
577
cp
0x11,
Oxa
old Data: 0x1
6L9
cmp
Oxaaaaaaaa,
0x9ad8443a
680
681
A3448DA9968B93E88CD1ACE7D576BCE6F9C2CD35D48AABBE
old Data: 0x0
Z89
lenoth:10.151Iines: 682
In:284Col:14Sel:010
Uni(LF)
Fig, 5.140 The result of pin32
---
## Page 437
5.8 Special Techniques in Reverse
423
C:\Users\plusls\Desktop>aaa\task,
Greatt Add flag() to hash and submit
Fig, 5.141 Verify the fag
must first sharpen one's tools". Due to the limited space, the usage of Pin introduced
in this section is only the *tip of the iceberg". The real CTF has no routine, and only
by diligently checking documents and developing ideas can Pin play the biggest role
in CTF.
5.8 Special Techniques in Reverse
In the reverse process, certain techniques that are normally applied in other fields can
play an unexpected role. Challenges that examine such techniques are more appro-
priately classified as miscellaneous. The following is a brief overview of the
techniques that have been used in CTF.
5.8.1Hook
Suoedau pue suoung ueao Suqoou, o siajan Suaanua asuan u xoo
them with functions you write yourself. As you can see, this is somewhat similar to
instrumentation, but without the need for a complex instrumentation framework and
with minimal loss of execution speed.
The following is an example of TMCTF 2017's Reverse 400. The first level of the
challenge is an on-screen keyboard (see Fig. 5.142), where the order of the charac-
ters changes every few seconds, and then the mouse moves to a button. The program
is protected by VMProtect, so it is highly unlikely that it will reverse in a short
period, so other operations are needed to get all the values.
E
Fig, 5.142 The challenge is an on-screen keyboard
---
## Page 438
424
5  Reverse Engineering
VMProtect exits the VM when it encounters API calls of the system, so we can
use Hook. with the Hook SleepEx function, we can speed up the changes, and since
moving the mouse requires the use of the SetCursorPos API, we Hook it to get the
data for each tum. This way, all the data can be obtained. After the reorganization,
you can get the second layer of files of the program.
5.8.2MakingSmart Use ofExistingProgram Code
When the compiler is not optimized sufficiently, the entire library is compiled into
the binary when the program containing the library is compiled, which results in
some functions appearing in the program even though they are not used. Because
libraries are writen with completeness in mind, many encryption functions are often
found in pairs, and they are often compiled together in a program.
For example, for the *CTF 2019 reverse fanoGo challenge, the author wrote an
algorithm for Shannon Fano encoding in Golang but included the decoding function,
see Fig. 5.143.
Even more, coincidentally, the prototypes of these two functions are extremely
similar.
void
_cdecl fano__Fano__Decode (fano_Fano_o *f, string Bytes, string
_cdec1 fano__Fano__Bncode (fano_Fano_o f, string plain, string
_1)
You can see that the second argument is all string. we can even just change call
fano_ ._Fano__Decode to call fano_ ._Fano__Encode to get the correct input.
tano.._.Fono__Fono_inlt
.tex
fano_
-_Fano__fano_sort
.tex
fano.._Fono__tinesofChars
tono___Fono__tono_generate
.tex
fono_Bytes2Str
.tex
tano___Fono__Oecode
.tex
.tex
tano_Str2Bytes
.tex
fano__Fono__.Encode
.tex
tano_lolt
,tex
Fig, 5.143 Encode function and decode function
---
## Page 439
5.8 Special Techniques in Reverse
425
5.8.3DumpMemory
This approach is actually “downscaling": the environment in which each program
runs is provided by a corresponding higher-level system, e.g., the environment in
which the executable files are run is provided by the operating system, and the
environment in which the operating system is run is provided by the virtual machine
(if it is a Virtual machine system). In CTF, it is possible to look at the memory of a
program using a tool with higher privileges and a higher level of hierarchy to see the
intermediate results of the program's execution, to see if it has flags or if it contains
the required program data. This is a very interesting approach, and there are many
ways to do it.
For Windows systems, to view user-state program memory, you can use a
debugger; to view kemel driver memory, you can use an advanced kernel-level
system maintenance tool such as PCHunter. In the HCTF on-site competition, there
is a reverse challenge where the driver is protected by VMProtect, an extremely
complex shell with a high degree of protection. This prevents the player from
reverse-engineering the algorithm in a short period. This challenge seems extremely
3 jo aoeds Auouau au dunp o1 Apaup saumHd asn ue no Kenoe inq °pue
driver. (Note: The PCHunter software can be found at http:/www.xuetr.com/?
p=191. Note that although PCHunter supports Windows 10, the author is often
unable to update the software on time due to the rapid pace of Windows 10 updates.
As of this writing, Windows 10 has been updated to version 1909, while the version
supported by PCHunter is still at 1809. It is recommended that you always have a
lower version of Windows virtual machine.)
For Mac and Linux systems, the debugger can also be used to check the memory
of user-state applications, but to check the memory of the kermel, for various
historical reasons, these systems lack the appropriate kernel-level system mainte-
nance tools, so we have to use a more “*high-level” system, the virtual machine. In
the case of Mac systems, for example, one of the miscellaneous challenges in CISCN
2018 is memory-forensic, which provides a complex kemel extension (kext) for
macOS that calculated flag and then panic, but we do not know how to dump kernel-
space memory in macOS. We can enable debug logging and disable auto-reboot by
modifying
macOS
boot-args:
nvram
boot-args="debug=0x546
kcsuffix=development
pmuflags=1
kext-dev-mode=1
slide=0
kdp
match_name=en0 -v*, which keeps the system in this state for us to debug after
the application triggers the panic, and allows us to grab the memory contents more
easily. The virtual memory file of VMWare is saved in the vmem file on the disk, so
you can open the vmem file directly and get the flag by using “CISCN{".
Sometimes you will encounter a program that uses the kermel driver to prevent
itself from being debugged. For example, one challenge in the mimic defense on-site
competition contains a driver. The driver modifies a maze array on the process stack 
and does some similar operations as Rootkit, such as hiding the process, driver anti-
debugging, Hooking and preventing the process from opening, etc. The subsequent
verification algorithm of the program is simple: use WASD keys to walk the maze,
---
## Page 440
426
5  Reverse Engineering
7540
LFEF359000
100x00...MSAS...389
Fig, 5.144 Get the address of the TEB
Fig, 5.145 The struct of
NT_TIB
struct NT_TIB
typedef struct _NT_TIB
PENCEPTION_REGISTRATION_RECORD Exceptionlist:
PVOID StackLinit;
PVOID StackBase:
PVOID SubSystemTib:
union
PVOID FiberData:
ULONG Version:
PVoID ArbitraryUserPointer:
：
} NT_TIB, *PNT_TIB;
PNTTIB Se1f:
so the key is to get the real maze array. We can either use kemel debugging, or we
can bypass the driver protection using PCHunter, which looks at the thread list of a
process and gets the address of the TEB, see Fig. 5.144.
The StackBase member at the TEB+8 offset is the address of the stack
corresponding to this thread, see Fig. 5.145. We can Dump the memory of the
TEB to get the address information of the Stack and continue Dumping the stack
with the corresponding address of the program, i.e. we get the target maze array.
5.9 Summary
This chapter introduces the common reverse engineering tools and methods used in
CTF, but the reverse challenges in CTF may be much more than that, sometimes
there may even be some non-running, not-decompilable programs, these challenges
may be IoT firmware, or very rare architectures, such as nanoMIPS. The basic skills
and resilience of the participants will be tested.