function,  which explains the  presence of  the  “Invalid
Argument” error code alone.
Figures 4a and 4b refine the results  of  Figures  3a and
3b respectively and show that, for a given  kernel call,
except  for  the  nanosleep  case,  all  error  codes
generated by  the  two  injection  techniques at  the  API
level are of the same nature. Even though,  the  overall
error  code  rate  is  almost  similar  and  the  generated
error  codes  are  the  same,  they  are  not  always
statistically  equivalent, except  for  certain  cases  such
as  setpriority,  gettimeofday  and  wait4.
Thus,  more  refinement  is  needed  to  derive  relevant
insights. The dominant error code is “Bad Address”. It
is present in the same five kernel calls out  of  six,  for
the two  techniques. These five kernel calls use either
a read pointer data type or a write pointer data type.
a- API Invalid parameters
100%
100%
83%
81%
47%
43%
50% 50%
17%
10%
15%
4%
b- Bit-flip in API parameters
57%
58%
43%
31%
11%
100%
Invalid Argument
Bad Address
Non Existent Process
Interrupted kernel Call
No Child Process
47%
48% 52%
37%
16%
14%
1%
setitimer
sched_setscheduler
gettimeofday
nanosleep
setpriority
wait4
Figure 4- Returned error codes provoked
by injection at the API level
A  more  detailed  analysis  further  supports 
this
statement.  Figure  5  provides an example of  the  type
of  in  depth  insight  that  can  be  obtained  from  the
experiments.  This  figure  shows  that  two  kinds  of
error  codes  (“Non  Existent  Process”  and  “Invalid
[-1 
two 
values 
invalid 
Argument”) were observed when flipping  bits  in  the
first  parameter  of  the  Permission  flag  class  of  the
setpriority  kernel  call.  The  “Non  Existent
Process” error code was provoked by  flipping  one  of
the  two  first  bits  (0  and 1).  The “Invalid  Argument”
was provoked by  flipping  any of  the  remaining  bits
(2-31).  Only 
and
ULONG_MAX]  injected  in  this  parameter  provoked
the  “Invalid  Argument”  and  none  of  them  provoked
the  “Non  Existent  process”  error  code.  Indeed,  the
setpriority  kernel  call  defines  the  scheduling
priority of either a process, a process group or  a user
processes.  The 
first  parameter  defines  which
scheduling priority will be modified by setting  one of
these flags:  PRIO_PROCESS  (0),  PRIO_PGRP  (1)
or PRIO_USER (2),  which are coded in  the  two  first
bits. The  second parameter is  interpreted with  respect
to  the  value  of  the  first  one,  thus  it  could  be:  a
process identifier, a process group identifier or  a user
identifier  for  which  the  scheduling  priority  of  its
processes  is  to  be  change.  The  workload  uses  the
setpriority kernel call to  modify the  scheduling
priority  of  one  process  (PRIO_PROCESS).  So,  by
flipping one of the two first bits of the first  parameter
(that are the  most  significant  bits),  we  obtain  either
PRIO_PGRP  or  PRIO_USER  instead.  The  second
parameter no  longer matches  the  resulting  values  of
the  first  parameter. Also,  it  is  important  to  note  the
impact  of  the  system  state.  In  fact,  if  the  second
parameter  contains  a  valid  process  group  after
corrupting 
to
PRIO_PGRP, the kernel will not be able to detect  the
error,  and  the  application  result,  if  not  the  entire
system state, will surely be corrupted.
the  value  of  PRIO_PROCESS 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
-1, ULONG_MAX
Non Existent Process
Invalid Argument
85%
Figure 5- Bit-flip / invalid parameter mapping
(setpriority first parameter case)
The above observations further support  the  view that
flipping  single  bits  in  kernel  call  parameters at  the
API  level  produces  more  erroneous  behaviors  than
applying invalid parameters.
5.  Conclusion
In this  paper, we compared the  impact  of  three types
of  SWIFI  techniques. Two  of them  target  the  kernel
call  parameters  with  two  different  fault  models,
namely: i) bit-flip  and ii)  invalid parameters, and the
third  one  targets  the  parameters  of  the  kernel  calls
underlying  functions.  We  have  developed  a  fault
injection  environment 
three
injection  techniques.  The  results  presented  in  this
that  supports 
the 
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:15:42 UTC from IEEE Xplore.  Restrictions apply. 
in 
are 
call 
injection 
in  kernel 
internal  function 
paper target the  Linux-kernel  scheduling  component.
They  concern  six  kernel  calls  invoked  by 
this
component.  The comparison of  the  results  relies  on
typical  kernel  failure  modes  (e.g.,  exceptions  and
kernel hangs) and on  the  error  detection  mechanisms
provided by the kernel.
The  bit-flip 
injection
technique  showed  different  erroneous  behaviors
compared to the two other techniques. Many hardware
exceptions were triggered  by  this  technique,  and  the
rate of the generated error codes was lower than for the
other  techniques.  This  tends  to  indicate  that  it  is
unlikely  that  internal software faults  (residual  design
faults  or  device drivers caused faults) could  be  easily
emulated by  injecting  only  at  the  API  level,  at  least
for the  Linux  kernel. Further work is  in  progress  to
better study this issue.
The  bit-flip 
parameter
injection  technique  is  an easy task  and  does  not
need any a priori analysis of the  parameter data types.
However,  it  requires  a  lot  of  time,  as  it  needs  32
injections per parameter.
The  invalid  parameter 
technique
takes less time  for a complete campaign compared to
a complete bit-flip one.  But is  a difficult issue,  since
it  needs a priori  analysis,  though  this  analysis  could
be done only  once such  as  the  Ballista based POSIX
test  suite,  which could be applied  to  all  the  POSIX
compliant  systems.  From  the  efficiency  point  of
view,  the  single  bit-flip  injections  provoked  more
erroneous  behaviors 
invalid  parameter
injection  technique.  We  presented  a  detailed  case
where the invalid parameter injections  were unable to
reproduce an error code that was provoked by bit-flips.
This might indicates that we have to enrich the  set  of
invalid parameters.
We 
error  detection
mechanisms  such  as  assertions  into  the  kernel  to
enrich  the  erroneous  behavior  observation  and  to
obtain  more detailed traces allowing  analysis  of  error
propagation channels.  Also,  we  are  analyzing  errors
produced  by  real  faults,  already  activated  in  Linux,
that  have  been  published.  Our  ultimate  aim  is  to
compare the  set  of  errors produced  by  injected  faults
to the set of errors produced by real faults to identify a
set  of  representative faults  to  be  injected  in  order  to
characterize  the  OS  behavior  in  presence  of  faults,
i.e., benchmark the OS dependability.
Acknowledgment
The work  presented  in  this  paper  is  partially  supported
by  the  European  Community  (Project  IST-2000-25425
DBench:  Dependability  Benchmarking).  This  work  has
largely  benefited  from  many  fruitful  discussions  with
Jean-Claude  Laprie  from  LAAS.  Also,  we  would  like  to
implementing  more 
than 
the 
thank  Moslem  Belkhiria,  Benjamin  Lussier,  and Thomas
Marteau who contributed  to  the  experiments  during  their
training period at LAAS.
References
[1]
J.  V.  Carreira,  D.  Costa  and  J.  G.  Silva,  “Fault
Injection 
System
Dependability”,  IEEE  Spectrum,  vol.  36,  pp.  50-
55,  1999.
Spot-checks 
Computer 
[2] D. T. Stott,  G. Ries,  M.-C.  Hsueh and  R.  K.  Iyer,
“Dependability  Analysis  of  a High-Speed  Network
Using  Software-Implemented  Fault  Injection  and
Simulated  Fault 
IEEE  Trans.  o n
Computers,  vol.  47,  no. 1,  pp.  108-119,  1998.
Injection”, 
[3] E. Fuchs, “Validating the Fail-Silence of  the  MARS
in  Proc.  DCCA-6,  Grainau,
Architecture”, 
Germany,  1998,  pp. 225-247.
[4] H.  Madeira,  D.  Costa  and  M.  Vieira,  “On  the
Emulation  of  Software  Faults  by  Software  Fault
Injection”,  in  Proc.  DSN-2000,  New  York,  NY,
USA,  2000,  pp. 417-426.
J.-C. Fabre, F. Salles, M. Rodríguez Moreno and  J .
Arlat, “Assessment of COTS  Microkernels  by  Fault
Injection”,  in  Proc.  DCCA-7,  San  Jose,  CA,  USA,
1999,  pp.  25-44.
[5]
[6] P.  Koopman  and  J.  DeVale,  “Comparing 
the
Robustness of POSIX Operating Systems”,  in  Proc.
FTCS-29,  Madison,  WI,  USA,  1999,  pp.  30-37.
J.  E. Foster  and B.  P.  Miller,  “An Empirical  Study
of  the  Robustness  of  Windows  NT  Applications
Using  Random  Testing”, 
in  Proc.  4th  USENIX
Windows  System  Symposium,  Seattle,  WA,  USA,
2000.
I.  T.  Bowman,  R.  C.  Holt  and  N.  V.  Brewster,
“Linux  as  a  Case  Study:  Its  Extracted  Software
Architecture”, in Proc.  21st  Int.  Conf.  on  Software
Engineering,  Los Angeles, CA, USA, 1999.
[7]
[8]
[9] R.  Chillarege  & 
al., 
“Orthogonal  Defect
Classification 
In-Process
Measurements”, 
Software
Engineering,  vol.  18,  no.  11,  pp.  943-956,  1992.
-  A  Concept 
IEEE  Trans. 
for 
on 
[10] http://www.wi.leidenuniv.nl/~wichert/strace.
[11] A. D. Alexandrov, M. Ibel, K. E. Schauser  and C.  J .
Scheiman, “Extending the  Operating  System  at  the
User Level:  the  Ufo Global  File  System”,  in  Proc.
USENIX,  Anaheim, CA, USA, 1997, pp. 77-90.
[12] M.  Rodríguez,  F.  Salles,  J.-C.  Fabre  and  J.  Arlat,
“MAFALDA:  Microkernel  Assessment  by  Fault
Injection  and  Design  Aid”, 
in  Proc.  EDCC-3,
Prague,  Czech  Republic,  1999,  pp.  143-160.
[13] J.  Christmansson,  M.  Hiller  and  M.  Rimén,  “An
Experimental  Comparison  of  Fault  and  Error
Injection”, 
Paderborn,
Germany,  1998,  pp.  369-378.
in  Proc. 
ISSRE'98, 
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:15:42 UTC from IEEE Xplore.  Restrictions apply.