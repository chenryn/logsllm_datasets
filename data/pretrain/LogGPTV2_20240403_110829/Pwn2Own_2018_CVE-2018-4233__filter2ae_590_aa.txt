# Pwn2Own 2018 CVE-2018-4233 分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
JavaScriptCore是Apple的WebKit浏览器内核中的JS引擎，最近学习JavaScriptCore引擎的漏洞利用，在此以CVE-2018-4233为例来学习JavaScriptCore引擎的漏洞利用一般思路
## 0x01 前置知识
###  JSC引擎执行流程
JSC引擎执行JS代码的流程如下
Lexer：词法分析，提取单词  
Parser：语法分析，生成语法树，并从语法树中构建ByteCode  
LLInt：Low Level Interpreter执行Parser生成的ByteCode，其代码位于源码树中的llint/文件夹  
Baseline JIT: 在函数调用了 6
次，或者某段代码循环了大于100次会触发该引擎进行JIT编译，其编译后的代码仍然为中间码，而不是汇编代码。其代码位于源码树中的jit/文件夹  
DFG JIT:
在函数被调用了60次或者代码循环了1000次会触发。DFG是基于控制流图分析的优化器，将低效字节码进行优化并转为机器码。它利用LLInt和Baseline
JIT阶段收集的一些信息来优化字节码，`消除一些类型检查`等。其代码位于源码树中的dfg/文件夹  
FTL: Faster Than Light，更高度的优化，在函数被调用了上千次或者代码循环了数万次会触发。通过一些更加细致的优化算法，将DFG
IR进一步优化转为 FTL 里用到的 B3 的 IR，然后生成机器码
可以知道，Baseline JIT->DFG
JIT->FTL每一个过程都进行了更加深入的优化，优化一般就是通过类型收集和判断，消除一些不必要的类型检查，并生成机器码，从而可以节省运行时间。由于js是动态类型语言，当类型优化推断错误时，便可以返回上一级，比如DFG
JIT优化错误，则返回Baseline JIT运行同时重新进行类型收集以便下一次优化。这个执行过程的转移使用的方法是`堆栈替换 on-stack
replacement，简称 OSR`。这个技术可以将执行转移到任何 statement 的地方。
###  clobberWorld
在DFG的遍历优化中，会进行类型收集，如果要之前推断的类型不正确，则调用`clobberWorld`函数放弃之前推断信息，如果不调用该函数，那么前面的类型信息继续保留。
###  JSC断点调试
与V8不同的是，JSC没有提供用于断点调试的js函数，一种简便的方法是在printInternal函数上进行断点
    b *printInternal
然后在js代码中调用print，即可断下。如果我们要打印信息，利用`debug`函数来打印，因为`print`已经被我们拿去断点用了。另一种方法是我们自己在`Source/JavaScriptCore/jsc.cpp`源码中增加一个`dbg`函数，并在函数中实现`int3`指令，然后就能在js中调用。
###  JSC对象内存模型
首先使用这段代码进行调试，其中`describe`函数是用来打印对象结构的，`debug`是用于输出文字的,`print`用于断点
    var obj = {};
    var a = {a:1,b:2,c:2.2,d:obj,e:3,f:4,g:5,h:6,i:7,j:8,k:9,l:10};
    debug(describe(a));
    print();
输出如下
    --> Object: 0x7fffaf8ac000 with butterfly (nil) (Structure 0x7fffaf870460:[Object, {a:0, b:1, c:2, d:3, e:4, f:5, g:6, h:7, i:8, j:9, k:10, l:11}, NonArray, Proto:0x7fffaf8c8020, Leaf]), StructureID: 297
使用gdb打印对象地址处的内容
    pwndbg> x /20gx 0x7fffaf8ac000
    0x7fffaf8ac000:    0x0100150000000129    0x0000000000000000
    0x7fffaf8ac010:    0x0000000000000000    0xffff000000000001
    0x7fffaf8ac020:    0xffff000000000002    0x400299999999999a
    0x7fffaf8ac030:    0x00007fffaf8b0100    0xffff000000000003
    0x7fffaf8ac040:    0xffff000000000004    0xffff000000000005
    0x7fffaf8ac050:    0xffff000000000006    0xffff000000000007
    0x7fffaf8ac060:    0xffff000000000008    0xffff000000000009
    0x7fffaf8ac070:    0xffff00000000000a    0x0000000000000000
    0x7fffaf8ac080:    0x0000000000000000    0x0000000000000000
    0x7fffaf8ac090:    0x0000000000000000    0x0000000000000000
可以看到，我们的数据都依次按照顺序存入了对象的内存中，并且可以发现不同类型之间的存储，其最前面有一些标志数据，总结起来如下：
    Pointer： [0000][xxxx:xxxx:xxxx]（前两个字节为0，后六个字节寻址）
    Double： [0001～FFFE][xxxx:xxxx:xxxx]
    Integer： [FFFF][0000:xxxx:xxxx]（只有低四个字节表示数字）
    False： [0000:0000:0000:0006]
    True： [0000:0000:0000:0007]
    Undefined： [0000:0000:0000:000a]
    Null： [0000:0000:0000:0002]
可以发现，对于对象类型，由于标记为0，所以直接存储着的就是指针，而Double和Integer最前面都加了标记。  
现在我们将代码修改一下并测试
    var obj = {};
    var a = {a:1,b:2,c:2.2,d:obj,e:3,f:4,g:5,h:6,i:7,j:8,k:9,l:10};
    a.m = 11;
    a.n = 12;
    a.o = 13;
    a.p = 14;
    a.q = 15;
    a[0] = 16;
    a[1] = 17;
    debug(describe(a));
    print();
打印如下
    --> Object: 0x7fffaf8ac000 with butterfly 0x7ff0000fe5a8 (Structure 0x7fffaf870700:[Object, {a:0, b:1, c:2, d:3, e:4, f:5, g:6, h:7, i:8, j:9, k:10, l:11, m:12, n:13, o:14, p:15, q:16}, NonArrayWithInt32, Proto:0x7fffaf8c8020, Leaf]), StructureID: 303
可以看到`butterfly`已经不是null了，我们查看一下对象内存
    pwndbg> x /30gx 0x7fffaf8ac000
    0x7fffaf8ac000:    0x010015040000012f    0x00007ff0000fe5a8
    0x7fffaf8ac010:    0x0000000000000003    0xffff000000000001
    0x7fffaf8ac020:    0xffff000000000002    0x400299999999999a
    0x7fffaf8ac030:    0x00007fffaf8b0100    0xffff000000000003
    0x7fffaf8ac040:    0xffff000000000004    0xffff000000000005
    0x7fffaf8ac050:    0xffff000000000006    0xffff000000000007
    0x7fffaf8ac060:    0xffff000000000008    0xffff000000000009
    0x7fffaf8ac070:    0xffff00000000000a    0xffff00000000000b
    0x7fffaf8ac080:    0xffff00000000000c    0xffff00000000000d
    0x7fffaf8ac090:    0xffff00000000000e    0xffff00000000000f
    pwndbg> x /20gx 0x00007ff0000fe5a8
    0x7ff0000fe5a8:    0xffff000000000010    0xffff000000000011
    0x7ff0000fe5b8:    0x0000000000000000    0x00000000badbeef0
可以看到，`butterfly`里存储着数组的元素，而其他属性则仍然存储于对象中，我们称这些为内联属性，因为其存储于对象内部。现在测试代码再修改一下
    var obj = {};
    var a = {a:1,b:2,c:2.2,d:obj,e:3,f:4,g:5,h:6,i:7,j:8,k:9,l:10};
    a.m = 11;
    a.n = 12;
    a.o = 13;
    a.p = 14;
    a.q = 15;
    a[0] = 16;
    a[1] = 17;
    a['r'] = 18;
    debug(describe(a));
    print();
输出如下
    --> Object: 0x7fffaf8ac000 with butterfly 0x7fec000f8468 (Structure 0x7fffaf870770:[Object, {a:0, b:1, c:2, d:3, e:4, f:5, g:6, h:7, i:8, j:9, k:10, l:11, m:12, n:13, o:14, p:15, q:16, r:100}, NonArrayWithInt32, Proto:0x7fffaf8c8020, Leaf]), StructureID: 304
    pwndbg> x /20gx 0x7fec000f8468-0x10
    0x7fec000f8458:    0xffff000000000012    0x0000000300000002
    0x7fec000f8468:    0xffff000000000010    0xffff000000000011
可以知道`a['r'] =
18;`这句代码，18存储于`butterfly`上方，由于其是数组的操作方式，因此其不再归为内联属性，同时我们还注意到`butterfly-0x8处的`数据`0x0000000300000002`，这代表数组的大小和容量。  
总结出JSC的对象结构如下：
其中JSCell是一个结构体，其中有`StructureID`等成员，在源码目录中的`Tools/gdb/webkit.py`文件是用于gdb调试的脚本插件，我们导入gdb，然后进行调试查看。
    pwndbg> p *(JSC::JSCell *)0x7fffaf8b42d0
    $2 = {
       = {}, 
      members of JSC::JSCell: 
      static StructureFlags = 0, 
      static needsDestruction = false, 
      static TypedArrayStorageType = JSC::NotTypedArray, 
      m_structureID = 284, 
      m_indexingTypeAndMisc = 0 '\000', 
      m_type = JSC::FinalObjectType, 
      m_flags = 0 '\000', 
      m_cellState = JSC::CellState::DefinitelyWhite
    }
其中`JSCell`的作用类似于V8中的`Map`，用于表示对象类型，与V8不同的是，类型的关键在于`JSCell`使用`StructureID`来区分类型，`StructureID`是一个类似于`index`下标的作用，真正的`Structure`指针存储在一个`StructureTable`中，判断对象的时候通过index从`StructureTable`取出`Structure`的地址，进而访问`Structure`，`Structure`表明了对象的原型，对象结构相同则具有相同的`StructureID`。
    JSC::StructureIDTable::get(JSC::StructureID)
使用如下代码测试
    var a = {x:1,y:2};
    var b = {x:3,y:4};
    var c = {a:5,b:6};
    debug(describe(a));
    debug(describe(b));
    debug(describe(c));
    print();
输出如下
    --> Object: 0x7fffaf8b42d0 with butterfly (nil) (Structure 0x7fffaf8a7d40:[Object, {x:0, y:1}, NonArray, Proto:0x7fffaf8c8020, Leaf]), StructureID: 284
    --> Object: 0x7fffaf8b4300 with butterfly (nil) (Structure 0x7fffaf8a7d40:[Object, {x:0, y:1}, NonArray, Proto:0x7fffaf8c8020, Leaf]), StructureID: 284
    --> Object: 0x7fffaf8b4330 with butterfly (nil) (Structure 0x7fffaf8a7e20:[Object, {a:0, b:1}, NonArray, Proto:0x7fffaf8c8020, Leaf]), StructureID: 286
可以看到a和b具有相同的`StructureID`和`Structure`。
####  伪造对象
从上述可以知道，`JSCell`就是一串数值，包含着`StructureID`，而不是指针，并且在一些版本中，`StructureID`不是随机的，而是按照不同对象创建的顺序递增，因此我们想要伪造数组对象的话，可以先申请N个数组对象，然后稍微添加一个不同的属性，则它们的`StructureID`不同，然后我们猜测一个`StructureID`，只要确保其很大概率落在已有的这些`StructureID`之中即可。
###  查看优化的数据
与V8中的`--trace-turbo`类似的，JSC中提供了`-p`选项用于输出`profiling
data`，里面包含一些优化时的数据、字节码等。`profiling
data`格式为json，JSC没有提供像V8那样的可视化工具用于查看流图，我们就只能看看JSON数据。
## 0x02 漏洞分析利用
###  patch分析
    index e7f1585..fc1a7c5 100644 (file)
    --- a/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h
    +++ b/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h
    @@ -1,5 +1,5 @@
     /*
    - * Copyright (C) 2013-2017 Apple Inc. All rights reserved.
    + * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
      *
      * Redistribution and use in source and binary forms, with or without
      * modification, are permitted provided that the following conditions
    @@ -2274,6 +2274,7 @@ bool AbstractInterpreter::executeEffects(unsigned clobberLimi
                     }
                 }
             }
    +        clobberWorld(node->origin.semantic, clobberLimit);
             forNode(node).setType(m_graph, SpecFinalObject);
             break;
         }
该patch修复了漏洞，patch位于文件`Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h`中的`executeEffects`函数，从文件路径可以知道，这个漏洞与`DFG
JIT`有关，`executeEffects`是当`DFG JIT`做优化时处理`side Effects`时用的,与v8一个道理，`side
Effects`即一些潜在的侧链影响，通俗来讲就是判断某个操作是否会影响类型变化，如果会影响，放弃之前的类型推断，如果不影响，继续使用之前的类型。patch位于函数中switch的`case
CreateThis:`分支，主要就是遍历字节码，遇到CreateThis时，调用`clobberWorld`函数放弃前面的类型推断。那么这也就是说，原来的漏洞点在于`CreateThis`是存在会影响对象类型的，但是`DFG
JIT`没有判断出来，这就导致类型混淆。
###  POC构造
首先，要得到`create_this`字节码，使用的是`this`
    function foo() {
       this.x = 1;
    }
    var b = new foo();
    print(b.x);
得到的字节码如下
    [   0] enter             
    [   1] get_scope         loc3