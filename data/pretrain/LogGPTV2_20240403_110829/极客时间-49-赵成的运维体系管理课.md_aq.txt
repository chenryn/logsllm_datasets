## 非功能测试 {#20.html#-}在功能验证的同时，还需要并行进行一些非功能性验证，包括安全审计、性能测试和容量评估。分别介绍如下：-   **安全审计**，由安全团队提供的源代码扫描工具，在构建的同时，对源代码进行安全扫描，支持    Java 和 PHP 语言。可以对源代码中的跨站脚本、伪造请求、SQL    注入、用户名密码等敏感信息泄露、木马以及各类远程执行等常见漏洞进行识别，对于高危漏洞，一旦发现，是不允许构建出的软件包发布的。而且实际情况是，不审不知道，一审吓一跳，我们前面几次做代码扫描时，各种漏洞触目惊心，但是随着工具的支持和逐步改进，基本已经将这些常见漏洞消灭在萌芽状态。下面是扫描结果的简单示例（目前扫描工具已经开源，请见文末链接）：![](Images/4a00cd2d08669372db5c71f19d812e3a.png){savepage-src="https://static001.geekbang.org/resource/image/f2/ba/f23e8221f44961933cea0cf17404c8ba.png"}-   **性能和容量压测**，主要针对核心应用，进行发布前后的性能和容量比对，如果出现性能或容量差异较大，就会终止发布。关于这一点，我在后面稳定性保障的文章中会详细介绍到。这个验证工作，会在预发或    Beta 环境下进行验证，因为这两个环境是最接近线上真实环境的。下图是一张发布前后的效果比对示意图，正常情况下，性能曲线应该是基本重叠才对，不应该出现较大的偏差。![](Images/e9350cb9d89aea802210a59eed2bf434.png){savepage-src="https://static001.geekbang.org/resource/image/f0/a9/f0f7fb90f2b67b9136aeebebfe987ba9.jpeg"}
## 最后 {#20.html#-}到这里，我们稍作一个总结。关于持续交付中的流水线模式，我们在前面两期文章以及本期的分享中，相对完整地介绍了从需求分解开始，到代码提交、软件构建，再到功能和非功能测试验证的整个过程。这个过程就是我们常说的持续集成。之所以我没有在一开始引入这个概念，是因为，如果我们将注意力集中到这一过程中具体的动作和问题上，会更有利于我们理解，而不是一开始就被概念性的术语和框架束缚住。流水线模式功能测试和非功能测试的整个过程可以总结如下：![](Images/cc7b646df33a1548dee2e7e0d8e87f32.png){savepage-src="https://static001.geekbang.org/resource/image/0b/83/0b305f4deb787c3f272c5267c22c6683.jpeg"}同时，我们在上面持续集成的过程中，要基于前面介绍的各类环境和基础配置管理，比如功能验证就需要在线下环境中的开发环境、项目环境以及集成测试环境上进行验收。而非功能验证的性能和容量评估，就需要在线上环境里的预发或 beta环境中完成。这里就已经涉及到了软件的部署发布。下一期文章，我将分享线上发布的整个过程，并对整个持续交付体系内容做一个收尾。欢迎你留言与我讨论。如果今天的内容对你有帮助，也欢迎你分享给身边的朋友，我们下期见！附：源代码安全审计工具]{.reference}]{.reference}![](Images/3ef6e72a283656e2668a23a796e1acca.png){savepage-src="https://static001.geekbang.org/resource/image/60/0e/60151e9d25d6751800506e2460f5660e.jpg"}
# 24 \| 做持续交付概念重要还是场景重要？看"笨办法"如何找到最佳方案上期文章中我们讲到，在经过严格的依赖规则校验和安全审计之后，构建出的软件包才可以部署发布。在开发环境、项目环境、集成测试环境以及预发环境下，我们还要进行各类的功能和非功能性测试，最后才能发布到正式的生产环境之上。通常状况下，做一次软件版本发布，必须经过以下几个环境（如下图所示）。需要明确的是，项目环境和"小蘑菇"（内部叫法）环境，只有特殊版本才会配备，这里我们不做强制。![](Images/4d12e0636cd9fa9ebd4a0a1bc2cdd68d.png){savepage-src="https://static001.geekbang.org/resource/image/36/6e/36066f4cc87bf4337a4f84e42cfd256e.jpg"}上述这些环境我们在之前都介绍过。而历经如此多的环境，高效的自动化持续部署和发布就变得尤为重要。特别是最后的线上发布环节，还需要确保业务连续稳定、无间断，所以，在复杂的微服务架构环境下，我们对软件的发布策略选择、自动化程度和稳定性要求就更高了。今天，我们一起看看整个流水线软件部署和发布的细节。
## 软件的持续部署发布 {#21.html#-}这里，我们直接以生产环境的发布过程来讲解。软件的部署发布，简单来说就是：**将构建完成和验证通过的应用软件包，发布到该应用对应环境下的 IP主机上的指定目录下，并通过应用优雅上下线，来实现软件最新版本对外提供服务的过程。**这个过程会包含的环节，我以图示整理如下：![](Images/5022b7d653b6c6e3940c4387d3a40c7f.png){savepage-src="https://static001.geekbang.org/resource/image/71/b0/71bf16155f4071bda146db69a3ac67b0.jpg"}我们可以看到，软件部署发布，听上去就是把软件部署一下，然后启动起来。这样的操作方式对于单体架构软件没有问题，但是在微服务架构下就满足不了要求了。单体架构软件启动起来就可以提供服务，但是对于微服务应用，无论停止还是启动，都需要考虑到对周边其它依赖和被依赖应用的影响才可以，考虑的点也就相对较多。我们针对单机发布，分环节来看一下：1\. 从 CMDB 中，拿到线上生产环境下的应用主机 IP列表去对应关系，目的是要将软件包发布到应用对应的 IP 主机上。2\.检查每台机器上的服务是否正常运行，如果是正常服务的，说明可以发布，但是服务本身异常，就要记录或跳过。3\. 下载 war包到指定目录。这里要依赖前期我们介绍的应用配置管理，在这一步要获取到该应用的源代码目录。4\.关闭该应用在这台主机上的监控，以免服务下线和应用终止产生线上错误告警。5\. 优雅下线。RPC 服务从软负载下线，如果该应用还提供了 http 的 Web调用，就需要从 Nginx 这样的七层负载下线，下线动作均通过 API接口调用方式实现。6\. 下线后经过短暂静默，重启应用。对于 Java应用来说，重启时可以自动解压，启停命令等还是之前从应用配置管理中获取响应路径和命令脚本名称。7\.优雅上线，进行健康监测，检查进程和应用状态是否正常，如果全部监测通过，则开始上线服务，开启监控。上述是一个应用的单机发布过程，过程比较长，但是可以看出，每个环节并不复杂。这里我们需要注意两个关键点：-   **针对场景，进行细分，这样就可以化整为零，把一个乍看上去很复杂的过程，分解成一个个可执行的步骤。**-   与服务化的软负载和注册中心进行交互，确保应用是可以优雅上下线的，而不是简单粗暴地启动和停止。``{=html}
## 发布策略 {#21.html#-}上述过程是针对单机的操作步骤。但是，如果我们有上百台主机，甚至一些大的集群有上千台主机，这时应该怎么发布呢？这里就涉及到发布策略问题。业界常见的几种模式，如蓝绿发布、灰度发布（金丝雀发布）、滚动发布等等，这几种模式网上资料丰富，在这里我们就不逐一展开详细介绍了。这里，我们主要以**灰度发布和滚动发布的组合方式**为例，详细分析一下这种发布模式。前面介绍的线上 Beta环境，选择的就是金丝雀发布模式，我们内部称之为灰度发布或 Beta发布。后来国外 Netflix持续交付经验传播比较广，所以我们经常可以听到金丝雀发布这种方式，而其本质上还是灰度发布模式。Beta 环境下，我们会保留 1-2台应用主机，引入较少的线上真实用户流量。发布到这个环境上时，对于核心应用和大规模的集群，我们会静默较长时间，以观察应用的新版本运行状态。如果没有严重的报错或崩溃，静默期过后，我们认为软件质量和稳定性是没有问题的，接下来就会发布到正式的生产环境上。因为生产环境上大的集群可能会有上百台甚至上千台主机，如果每台主机逐一单独发布，这样会导致发布效率过低；但是一次性发布数量太多，又会对线上应用容量大幅度缩减，极有可能会导致服务雪崩或业务中断。所以我们选择的方式就是滚动发布，或者可以理解为分批次发布：即每批次发布10 台或 20台，升级完成后，再启动下一批次发布。这样每次发布的机器数量可以自行设定，但是必须低于50%。至此，一个应用的滚动发布流程就结束了。根据我们实践的具体情况，这种灰度加滚动的发布模式，相对平稳和可控。相比于蓝绿发布，不需要额外再独立一个环境出来，且不需要每次发布都要做一次整体的流量切换，避免产生较大的操作风险。对于回滚，我们会根据上个版本的 war包名称记录，在发布过程中或发布后出现严重情况时，直接快速回滚。因为这个操作是在紧急和极端的情况下才执行，所以提供一键操作，过程跟上述的发布过程相似，在此也不再赘述。
## 持续交付体系的收益 {#21.html#-}持续交付体系运作起来后，整个流水线过程完全自助发布，运维无需介入，达到了DevOps，或者说是 NoOps 的效果。如下图所示：![](Images/8090b237214cf45027070cf57cd01a39.png){savepage-src="https://static001.geekbang.org/resource/image/e5/2f/e5970628742eda8e67e2b9509fcde02f.jpg"}