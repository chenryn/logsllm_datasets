--snip--
# Walk the entire folder tree and compress the files in each folder.
 for foldername, subfolders, filenames in os.walk(folder):
print('Adding files in %s...' % (foldername))
# Add the current folder to the ZIP file.
 backupZip.write(foldername)
# Add all the files in this folder to the ZIP file.
 for filename in filenames:
newBase / os.path.basename(folder) + '_'
if filename.startswith(newBase) and filename.endswith('.zip')
continue # don't backup the backup ZIP files
backupZip.write(os.path.join(foldername, filename))
backupZip.close()
print('Done.')
b ackupToZip('C:\\delicious')
可以在 for 循环中使用 os.walk()，在每次迭代中，它将返回这次迭代当前的
文件夹名称、这个文件夹中的子文件夹，以及这个文件夹中的文件名。
在这个 for 循环中，该文件夹被添加到 ZIP 文件。嵌套的 for 循环将遍历
filenames列表中的每个文件。每个文件都被添加到ZIP文件中，以前生成的备份
ZIP文件除外。
如果运行该程序，它产生的输出看起来像这样：
Creating delicious_1.zip...
Adding files in C:\delicious...
Adding files in C:\delicious\cats...
Adding files in C:\delicious\waffles...
Adding files in C:\delicious\walnut...
Adding files in C:\delicious\walnut\waffles...
Done.
第二次运行它时，它将 C:\delicious 中的所有文件放进一个 ZIP 文件，命名为
delicious_2.zip，以此类推。
第4步：类似程序的想法
你可以在其他程序中遍历一个目录树，将文件添加到压缩的ZIP归档文件中。
例如，你可以编程做下面的事情：
• 遍历一个目录树，将特定扩展名的文件归档，诸如.txt或.py，并排除其他文件。
170 Python编程快速上手——让繁琐工作自动化
• 遍历一个目录树，将除.txt和.py文件以外的其他文件归档。
• 在一个目录树中查找文件夹，它包含的文件数最多，或者使用的磁盘空间最大。
9.6 小结
即使你是一个有经验的计算机用户，可能也会用鼠标和键盘手工处理文件。现
在的文件浏览器使得处理少量文件的工作很容易。但有时候，如果用计算机的浏览
器，你需要完成的任务可能要花几个小时。
os和shutil模块提供了一些函数，用于复制、移动、改名和删除文件。在删除
文件时，你可能希望使用 send2trash 模块，将文件移动到回收站或垃圾箱，而不是
永久地删除它们。在编程处理文件时，最好是先注释掉实际会复制/移动/改名/删除
文件的代码，添加print()调用，这样你就可以运行该程序，验证它实际会做什么。
通常，你不仅需要对一个文件夹中的文件执行这些操作，而是对所有下级子文
件夹执行操作。os.walk()函数将处理这个艰苦工作，遍历文件夹，这样你就可以专
注于程序需要对其中的文件做什么。
zipfile模块提供了一种方法，用Python压缩和解压ZIP归档文件。和os和shutil
模块中的文件处理函数一起使用，很容易将硬盘上任意位置的一些文件打包。和许
多独立的文件相比，这些ZIP文件更容易上传到网站，或作为E-mail附件发送。
本书前面几章提供了源代码让你拷贝。但如果你编写自己的程序，可能在第一
次编写时不会完美无缺。下一章将聚焦于一些Python模块，它们帮助你分析和调试
程序，这样就能让程序很快正确运行。
9.7 习题
1．shutil.copy()和shutil.copytree()之间的区别是什么？
2．什么函数用于文件改名？
3．send2trash和shutil模块中的删除函数之间的区别是什么？
4．ZipFile对象有一个close()方法，就像File对象的close()方法。ZipFile对象
的什么方法等价于File对象的open()方法？
9.8 实践项目
作为实践，编程完成下面的任务。
9.8.1 选择性拷贝
编写一个程序，遍历一个目录树，查找特定扩展名的文件（诸如.pdf 或.jpg）。
第9章 组织文件 171
不论这些文件的位置在哪里，将它们拷贝到一个新的文件夹中。
9.8.2 删除不需要的文件
一些不需要的、巨大的文件或文件夹占据了硬盘的空间，这并不少见。如果你
试图释放计算机上的空间，那么删除不想要的巨大文件效果最好。但首先你必须找
到它们。
编写一个程序，遍历一个目录树，查找特别大的文件或文件夹，比方说，超过
100MB的文件（回忆一下，要获得文件的大小，可以使用 os 模块的os.path.getsize()）。
将这些文件的绝对路径打印到屏幕上。
9.8.3 消除缺失的编号
编写一个程序，在一个文件夹中，找到所有带指定前缀的文件，诸如spam001.txt,
spam002.txt等，并定位缺失的编号（例如存在spam001.txt和spam003.txt，但不存
在spam002.txt）。让该程序对所有后面的文件改名，消除缺失的编号。
作为附加的挑战，编写另一个程序，在一些连续编号的文件中，空出一些编号，
以便加入新的文件。
172 Python编程快速上手——让繁琐工作自动化
10
第 章
调 试
既然你已学习了足够的内容，可以编写更复杂的程序，可
能就会在程序中发现不那么简单的缺陷。本章介绍了一些工具
和技巧，用于寻找程序中缺陷的根源，帮助你更快更容易地修
复缺陷。
程序员之间流传着一个老笑话：“编码占了编程工作量的
90%，调试占了另外90%。”
计算机只会做你告诉它做的事情，它不会读懂你的心思，做你
想要它做的事情。即使专业的程序员也一直在制造缺陷，所以如果你的程序有问题，
不必感到沮丧。
好在，有一些工具和技巧可以确定你的代码在做什么，以及哪儿出了问题。首
先，你要查看日志和断言。这两项功能可以帮助你尽早发现缺陷。一般来说，缺陷发
现的越早，就越容易修复。
其次，你要学习如何使用调试器。调试器是 IDLE 的一项功能，它可以一次执
行一条指令，在代码运行时，让你有机会检查变量的值，并追踪程序运行时值的变
化。这比程序全速运行要慢得多，但可以帮助你查看程序运行时其中实际的值，而
不是通过源代码推测值可能是什么。
10.1 抛出异常
当Python试图执行无效代码时，就会抛出异常。在第 3 章中，你已看到如何使
用try和except语句来处理Python的异常，这样程序就可以从你预期的异常中恢复。
但你也可以在代码中抛出自己的异常。抛出异常相当于是说：“停止运行这个函数
中的代码，将程序执行转到except语句 ”。
抛出异常使用raise语句。在代码中，raise语句包含以下部分：
• raise关键字；
• 对Exception函数的调用；
• 传递给Exception函数的字符串，包含有用的出错信息。
例如，在交互式环境中输入以下代码：
>>> raise Exception('This is the error message.')
Traceback (most recent call last):
File "", line 1, in 
raise Exception('This is the error message.')
Exception: This is the error message.
如果没有try和except语句覆盖抛出异常的raise语句，该程序就会崩溃，并显
示异常的出错信息。
通常是调用该函数的代码知道如何处理异常，而不是该函数本身。所以你常常
会看到 raise 语句在一个函数中，try 和 except 语句在调用该函数的代码中。例如，
打开一个新的文件编辑器窗口，输入以下代码，并保存为boxPrint.py：
def boxPrint(symbol, width, height):
if len(symbol) != 1:
 raise Exception('Symbol must be a single character string.')
if width 
spam()
File "errorExample.py", line 2, in spam
bacon()
File "errorExample.py", line 5, in bacon
raise Exception('This is the error message.')
Exception: This is the error message.
通过反向跟踪，可以看到该错误发生在第5行，在bacon() 函数中。这次特定的
bacon() 调用来自第 2 行，在 spam() 函数中，它又在第 7 行被调用的。在从多个位
置调用函数的程序中，调用栈就能帮助你确定哪次调用导致了错误。
第10章 调试 175
只要抛出的异常没有被处理，Python 就会显示反向跟踪。但你也可以调用
traceback.format_exc()，得到它的字符串形式。如果你希望得到异常的反向跟踪的信
息，但也希望except语句优雅地处理该异常，这个函数就很有用。在调用该函数之
前，需要导入Python的traceback模块。
例如，不是让程序在异常发生时就崩溃，可以将反向跟踪信息写入一个日志文
件，并让程序继续运行。稍后，在准备调试程序时，可以检查该日志文件。在交互
式环境中输入以下代码：
>>> import traceback
>>> try:
raise Exception('This is the error message.')
except:
errorFile = open('errorInfo.txt', 'w')
errorFile.write(traceback.format_exc())
errorFile.close()
print('The traceback info was written to errorInfo.txt.')
116
The traceback info was written to errorInfo.txt.
write() 方法的返回值是 116，因为 116 个字符被写入到文件中。反向跟踪文本
被写入errorInfo.txt。
Traceback (most recent call last):
File "", line 2, in 
Exception: This is the error message.
10.3 断言
“断言”是一个心智正常的检查，确保代码没有做什么明显错误的事情。这些
心智正常的检查由assert语句执行。如果检查失败，就会抛出异常。在代码中，assert
语句包含以下部分：
• assert关键字；
• 条件（即求值为True或False的表达式）；
• 逗号；
• 当条件为False时显示的字符串。