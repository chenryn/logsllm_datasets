2 ) = gxy
1 , gy
t
Public key aggregation. The aggregate public key for individual
and sets its public key to pk ← gx
2 .
public keys pk 1, . . . , pk n is apk =(cid:81)n
i=1 pk i.
Signing. The signature on a message m is α ← (H(m)x,∅) if
m = M and is α ← (H(m)x,{(m,{pk})}) otherwise.
Signature aggregation. Aggregating two aggregate signatures
α1 = (τ1,B1) and α2 = (τ2,B2) can be done by computing
τ ← τ1 · τ2 and “merging” B1 and B2 into B ← B1 (cid:116) B2.
The resulting aggregate is α = (τ,B).
Veriﬁcation. To verify an aggregate signature α = (τ,B =
{(m1, S1), . . . , (mµ, Sµ)}) under aggregate public key apk,
non-contributing public keys S⊥, and default message M , let
(1)
apk
apk M ←
Verify that
.
pk
i=1(cid:81)pk∈Si
(cid:81)pk∈S⊥ pk ·(cid:81)µ
µ(cid:89)i=1
e(cid:0)H(mi), (cid:89)pk∈Si
e(τ, g2) = e(cid:0)H(M ), apk M(cid:1) ·
If so, then return B, otherwise return ⊥.
pk(cid:1) . (2)
As mentioned earlier, and as is the case for other multi-signature
schemes [9, 20], the signers’ keys either have to be generated by
a trusted entity, or the signers have to prove possession of their
secret keys. For our scheme, the latter is most easily achieved by
signing an arbitrary message using a different hash function than
for normal signatures [28]1 and adding it to the public key, or by
including a Schnorr signature from which the corresponding secret
keys can be extracted by applying the generalized forking lemma of
Bagherzandi et al. [6].
5. PROTOCOL DESCRIPTION
SANA consists of algorithms and protocols executed by a veriﬁer
V, the owner O, and a set of aggregators and provers in the network
G. Table 1 provides an overview of the variables and parameters
used in the protocol speciﬁcation.
At its core, SANA distributes a challenge, asks each prover to
produce a signed attestation, and aggregates the resulting attestation
signatures. Since Denial of Service (DoS) attacks on tiny devices
are easy, SANA additionally provides an authorization scheme that
allows only authorized veriﬁers to execute this protocol.
Initialization. Each prover Pi is initialized in a trusted environment
by the network owner O with an OAS key pair (sk i ←R Zp, pk i ←
2 ), and an identity certiﬁcate cert(pk i), signed by O, certifying
gsk i
that pk i is a valid OAS public key of Pi with identity id i. Formally:
init(1(cid:96)) → (sk i, pk i, cert(pk i)) .
Token request. In order to attest a network G, a veriﬁer V must
possess a valid authorization token T generated and signed by the
1The same hash function also works as long as the message space
for proofs of possession is separated from that of regular signatures.
Table 1: Variables, parameters and procedures
Entities
O
V
Di
(cid:101)Pi
(cid:98)Pi
Ai
Network G parameters
a
n
gi
pi ≤ gi − 1
Prover Pi parameters
id i
h
(sk i, pk i)
skO (resp. V )
pkO (resp. V )
cert(pk i)
cert(pkO) (resp. V )
(c1, v1) . . . (cs, vs)
SANA parameters
T
N
H
texp
δt
Ch
apk
Si
S⊥
mi
M
α
Procedures
Enc(), Dec()
Sign()
Verify()
checkPolicy()
getFreeCounter()
checkCounter()
getSoftConf()
getGoodConﬁgs()
Owner or operator of the network
Veriﬁer (entity attesting the network)
Device i
Good prover i, i.e., a prover with one of the latest non-
compromised software conﬁgurations
Bad prover i, i.e., a prover with an outdated or malicious
software conﬁguration.
Untrusted aggregator i
Total number of aggregators in G
Total number of provers in G
Number of neighbors of Ai
Number of children of Ai in the aggregation tree
ID of Pi
Platform software conﬁguration (e.g., hash digest of bi-
nary code)
OAS secret and public key pair of Pi
Secret signing key of O (resp. V) (not based on OAS)
Public signature veriﬁcation key O (resp. V) (not based
on OAS)
Identity certiﬁcate of Pi (issued by O)
Public key certiﬁcates for O (resp. V) (issued by a
trusted third party)
List of attestation counters and corresponding values
Token used by V to perform attestation (T =
{H, cl , vl , texp , σ1})
A random nonce
The set of software conﬁgurations for the latest software
versions of all devices in G
Expiry time of a token T
Expiry period of a token T
An attestation challenge (Ch = {N, T})
Aggregate public key of all provers in G
Set of public keys grouped by same message signed mi
Set of public keys that did not participate in generating
the OAS signature
Software conﬁguration on which public keys are
grouped
The default message signed by OAS
An OAS signature
Public key encryption and decryption
Creating a digital (or OAS) signature
Veriﬁcation of a digital (or OAS) signature
Application speciﬁc procedure that determines whether
to accept a token request. Outputs δt > 0 if the request
is accepted
Searches for an unused counter cl in c1 . . . cs. Sets cl
status to “busy”, increments vl and outputs cl and vl
Checks whether the value of the received counter is
greater than the value of the local counter; in this case,
sets value of local counter to value of received ones
Measures the software conﬁguration
Retrieves the set H of software conﬁguration for the
latest software versions of all devices in G
owner O of the network. V acquires T = {H, cl , vl , texp, σ1} by
executing an ofﬂine protocol tokenReq (see Figure 2) with O. The
main purpose of tokenReq is at the same time mitigating DoS at-
tacks (that are based on the attestation protocol, and can be launched
through one single device on the entire network), while allowing
attestation service to be public.
The network owner O keeps a list of counters c1, . . . , cs with
values v1, . . . , vs. A counter can be assigned by O to a valid token
request until an expiry time texp, associated to the request, i.e., the
counter is marked as “busy” until texp. After receiving a valid token
Figure 2: Protocol tokenReq
request from V, O searches for a free (i.e., not busy) counter cl,
with value vl, increments vl by one, and returns the tuple (cl , vl ) to
the requesting veriﬁer – getFreeCounter(). Counters are necessary
to protect the network against replay attacks: Indeed, each prover
Pi also keeps a list of s counters with corresponding values; once it
received an attestation request, Pi checks whether the counter value
associated with the request is greater than the value locally stored,
and, only in this case, updates its local value and proceeds with the
evaluation of the attestation request – checkCounter().
The details of tokenReq are as follows: V initiates the protocol by
sending O a random challenge NV, showing its interest in attesting
G. Upon receiving NV, O creates a random challenge NO and
sends it to V. V then creates a signature σV
2 on NO and a protocol
parameter δt and sends it back to O along with δt, and its identity
certiﬁcate cert(pk
). Parameter δt indicates the required expiration
period of the requested T . Based on idV and the requested δt, O
decides whether to accept V’s request, according to an application
speciﬁc policy – checkPolicy().
If the request is accepted and
σV veriﬁed correctly, O retrieves the set H = {h1, . . . , hz} of
software conﬁguration of benign software in G (i.e., the software
conﬁguration of latest software version on different devices in G)
– getGoodConﬁgs(). The list is then hashed into one single good
conﬁguration hg = hash(h1| . . .|hz). Finally, O sends to V: (1)
the aggregate public key apk of all provers in G; (2) A signature
σ2 over apk; and (3) An encrypted 3 token . Finally, V veriﬁes σ2,
decrypts and veriﬁes T , and stores it along with apk. Formally:
V
tokenReq[V : δt , skV ; O : skO, apk ;
∗ : cert(pkO), cert(pkV )] → [V : T , apk ; O : texp] .
Attestation: After obtaining an attestation token T , V can attest the
network. Before texp, V chooses a random (gateway) aggregator A1,
through which it runs the collective attestation attest of the whole
network (see Figure 3). In detail, V sends A1 an attestation request
2Signatures in tokenReq are not based on our OAS scheme, but use
an existing public key infrastructure (PKI) between O and V.
3Encryption is based on the public key pk
of V.
V
Ch = {N, T} including a random challenge N. Upon receiving
this request, A1 veriﬁes the counter value vl – checkCounter(),
and the signature σO using owner’s O public key. We denote this
procedure by verifyChallenge(). If the veriﬁcation succeeds, A1
forwards the request to its neighbors. Each neighbor, in turn, veriﬁes
and forwards the request to its neighbors, and so forth, until the
request is received by all provers in the network. Consequently an
aggregation tree rooted at A1 is formed.
As a next step in the protocol, each prover Pi (at the leaf nodes)
in the generated aggregation tree, generates its own software conﬁg-
uration hi – getSoftConf(). If hi is a benign software conﬁguration
(i.e., hi ∈ H), Di creates an Optimistic Aggregate Signature (OAS)
αi over the good software conﬁguration hg, the challenge N, the
counter id cl, and the counter value vl (using its OAS secret key
ski), Otherwise (if hi /∈ H), αi is created over Di’s software con-
ﬁguration hi. αi is then sent to Di’s parent in the aggregation tree.
We denote this procedure as createResponse().
Aggregators at intermediate nodes of the tree aggregate responses
coming from their children according to the procedure AggSig de-
ﬁned in Deﬁnition 1, which we denote as aggregateResponse(),
i.e., signatures are aggregated by M = hg|N|cl|vl being the de-
fault message. Consequently, attestation responses from provers are
propagated, in reverse, along the aggregation tree toward the root
A1. Upon receiving all the responses from its children, node A1
forwards the ﬁnal aggregated signature α1 to V.
Finally, V veriﬁes α1 according to Verify in Deﬁnition 1. If the
veriﬁcation succeeds and B = φ, V concludes that the network
is trustworthy. If B (cid:54)= φ, V learns the identity and the software
conﬁguration of all bad devices (i.e., with malicious or outdated
software). Formally: