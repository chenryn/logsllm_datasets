### Public Key Aggregation and Signature Scheme

#### Public Key Aggregation
The aggregate public key for individual public keys \( pk_1, \ldots, pk_n \) is computed as:
\[ apk = \prod_{i=1}^{n} pk_i. \]

#### Signing
The signature on a message \( m \) is generated as follows:
- If \( m = M \), the signature is \( \alpha \leftarrow (H(m)x, \emptyset) \).
- Otherwise, the signature is \( \alpha \leftarrow (H(m)x, \{(m, \{pk\})\}) \).

#### Signature Aggregation
To aggregate two aggregate signatures \( \alpha_1 = (\tau_1, B_1) \) and \( \alpha_2 = (\tau_2, B_2) \):
- Compute \( \tau \leftarrow \tau_1 \cdot \tau_2 \).
- Merge \( B_1 \) and \( B_2 \) into \( B \leftarrow B_1 \cup B_2 \).
- The resulting aggregate signature is \( \alpha = (\tau, B) \).

#### Verification
To verify an aggregate signature \( \alpha = (\tau, B = \{(m_1, S_1), \ldots, (m_\mu, S_\mu)\}) \) under the aggregate public key \( apk \), non-contributing public keys \( S_\perp \), and default message \( M \):
1. Compute:
   \[
   apk_M \leftarrow \left( \prod_{i=1}^{\mu} \prod_{pk \in S_i} pk \right) \cdot \prod_{pk \in S_\perp} pk.
   \]
2. Verify that:
   \[
   e(\tau, g_2) = e(H(M), apk_M) \cdot \prod_{i=1}^{\mu} e(H(m_i), \prod_{pk \in S_i} pk).
   \]
3. If the verification succeeds, return \( B \). Otherwise, return \( \perp \).

#### Key Generation and Proof of Possession
As with other multi-signature schemes, the signers' keys must either be generated by a trusted entity or the signers must prove possession of their secret keys. For our scheme, this can be achieved by:
- Signing an arbitrary message using a different hash function than for normal signatures and adding it to the public key.
- Including a Schnorr signature from which the corresponding secret keys can be extracted using the generalized forking lemma of Bagherzandi et al. [6].

### Protocol Description: SANA

SANA involves algorithms and protocols executed by a verifier \( V \), the owner \( O \), and a set of aggregators and provers in the network \( G \). Table 1 provides an overview of the variables and parameters used in the protocol specification.

#### Initialization
Each prover \( P_i \) is initialized in a trusted environment by the network owner \( O \) with an OAS key pair \( (sk_i \leftarrow_R Z_p, pk_i \leftarrow g^{sk_i}) \) and an identity certificate \( cert(pk_i) \), signed by \( O \), certifying that \( pk_i \) is a valid OAS public key of \( P_i \) with identity \( id_i \). Formally:
\[ \text{init}(1^\lambda) \rightarrow (sk_i, pk_i, cert(pk_i)). \]

#### Token Request
To attest a network \( G \), a verifier \( V \) must possess a valid authorization token \( T \) generated and signed by the network owner \( O \). The token \( T \) is acquired by executing an offline protocol \( \text{tokenReq} \) with \( O \). The main purpose of \( \text{tokenReq} \) is to mitigate DoS attacks while allowing the attestation service to be public.

The network owner \( O \) maintains a list of counters \( c_1, \ldots, c_s \) with values \( v_1, \ldots, v_s \). A counter can be assigned to a valid token request until an expiry time \( t_{\text{exp}} \), after which the counter is marked as "busy." After receiving a valid token request from \( V \), \( O \) searches for a free counter \( c_l \) with value \( v_l \), increments \( v_l \) by one, and returns the tuple \( (c_l, v_l) \) to the requesting verifier. Counters are necessary to protect the network against replay attacks.

#### Detailed Token Request
1. \( V \) initiates the protocol by sending \( O \) a random challenge \( N_V \), showing its interest in attesting \( G \).
2. Upon receiving \( N_V \), \( O \) creates a random challenge \( N_O \) and sends it to \( V \).
3. \( V \) creates a signature \( \sigma_{V2} \) on \( N_O \) and a protocol parameter \( \delta_t \), and sends it back to \( O \) along with \( \delta_t \) and its identity certificate \( cert(pk_V) \). Parameter \( \delta_t \) indicates the required expiration period of the requested \( T \).
4. Based on \( id_V \) and the requested \( \delta_t \), \( O \) decides whether to accept \( V \)'s request according to an application-specific policy.
5. If the request is accepted and \( \sigma_{V2} \) is verified correctly, \( O \) retrieves the set \( H = \{h_1, \ldots, h_z\} \) of software configurations of benign software in \( G \) and hashes them into a single good configuration \( h_g = \text{hash}(h_1 | \ldots | h_z) \).
6. Finally, \( O \) sends to \( V \): (1) the aggregate public key \( apk \) of all provers in \( G \); (2) a signature \( \sigma_2 \) over \( apk \); and (3) an encrypted token \( \tilde{T} \). \( V \) verifies \( \sigma_2 \), decrypts and verifies \( T \), and stores it along with \( apk \). Formally:
   \[
   \text{tokenReq}[V : \delta_t, sk_V; O : sk_O, apk; * : cert(pk_O), cert(pk_V)] \rightarrow [V : T, apk; O : t_{\text{exp}}].
   \]

#### Attestation
After obtaining an attestation token \( T \), \( V \) can attest the network. Before \( t_{\text{exp}} \), \( V \) chooses a random (gateway) aggregator \( A_1 \) through which it runs the collective attestation \( \text{attest} \) of the whole network. In detail:
1. \( V \) sends \( A_1 \) an attestation request \( Ch = \{N, T\} \) including a random challenge \( N \).
2. Upon receiving this request, \( A_1 \) verifies the counter value \( v_l \) and the signature \( \sigma_O \) using the owner's public key. This procedure is denoted by \( \text{verifyChallenge} \).
3. If the verification succeeds, \( A_1 \) forwards the request to its neighbors. Each neighbor, in turn, verifies and forwards the request to its neighbors, and so forth, until the request is received by all provers in the network, forming an aggregation tree rooted at \( A_1 \).

Next, each prover \( P_i \) (at the leaf nodes) in the generated aggregation tree generates its own software configuration \( h_i \). If \( h_i \) is a benign software configuration (i.e., \( h_i \in H \)), \( P_i \) creates an Optimistic Aggregate Signature (OAS) \( \alpha_i \) over the good software configuration \( h_g \), the challenge \( N \), the counter id \( c_l \), and the counter value \( v_l \) (using its OAS secret key \( sk_i \)). Otherwise, \( \alpha_i \) is created over \( P_i \)'s software configuration \( h_i \). \( \alpha_i \) is then sent to \( P_i \)'s parent in the aggregation tree. This procedure is denoted as \( \text{createResponse} \).

Aggregators at intermediate nodes of the tree aggregate responses coming from their children according to the procedure \( \text{AggSig} \) defined in Definition 1, which we denote as \( \text{aggregateResponse} \). Signatures are aggregated with \( M = h_g | N | c_l | v_l \) being the default message. Consequently, attestation responses from provers are propagated, in reverse, along the aggregation tree toward the root \( A_1 \). Upon receiving all the responses from its children, node \( A_1 \) forwards the final aggregated signature \( \alpha_1 \) to \( V \).

Finally, \( V \) verifies \( \alpha_1 \) according to the \( \text{Verify} \) procedure in Definition 1. If the verification succeeds and \( B = \emptyset \), \( V \) concludes that the network is trustworthy. If \( B \neq \emptyset \), \( V \) learns the identity and the software configuration of all bad devices (i.e., with malicious or outdated software). Formally:
\[ \text{attest}[V : T, apk; A_1 : \text{aggregation tree}; P_i : \text{provers}] \rightarrow [V : \text{verification result}]. \]