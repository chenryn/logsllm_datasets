Nanosecond Duration = 1//纳秒
Microsecond = 1000*Nanosecond //微秒
Millisecond =1000*Microsecond //毫秒
Second =1000*Millisecond //秒
Minute =60*Second //分钟
Hour =60*Minute//小时
)
常量的作用:在程序中可用于获取指定时间单位的时间，比如想得到 100毫秒
100*time.Millisecond
6) 结合Sleep 来使用一下时间常量
7) time的Unix 和UnixNano 的方法
得到的结果是：
6.24.2 时间和日期的课堂练习
编写一段代码来统计 函数test03 执行的时间
6.25 内置函数
6.25.1 说明：
Golang 设计者为了编程方便，提供了一些函数，这些函数可以直接使用，我们称为 Go 的内置函
数。文档：https://studygolang.com/pkgdoc ->builtin
1) len：用来求长度，比如 string、array、slice、map、channel
2) new：用来分配内存，主要用来分配值类型，比如int、float32,struct...返回的是指针
举例说明 new 的使用：
上面代码对应的内存分析图：
3) make：用来分配内存，主要用来分配引用类型，比如channel、map、slice。这个我们后面讲解。
6.26 错误处理
6.26.1 看一段代码，因此错误处理
对上面代码的总结
1) 在默认情况下，当发生错误后(panic) ,程序就会退出（崩溃.）
2) 如果我们希望：当发生错误后，可以捕获到错误，并进行处理，保证程序可以继续执行。还可
以在捕获到错误后，给管理员一个提示(邮件,短信。。。）
3) 这里引出我们要将的错误处理机制
6.26.2 基本说明
1) Go 语言追求简洁优雅，所以，Go语言不支持传统的 try…catch…finally 这种处理。
2) Go 中引入的处理方式为：defer,panic,recover
3) 这几个异常的使用场景可以这么简单描述：Go 中可以抛出一个 panic 的异常，然后在 defer 中
通过recover捕获这个异常，然后正常处理
6.26.3 使用 defer+recover 来处理错误
6.26.4 错误处理的好处
进行错误处理后，程序不会轻易挂掉，如果加入预警代码，就可以让程序更加的健壮。看一个
案例演示：
6.26.5 自定义错误
6.26.6 自定义错误的介绍
Go程序中，也支持自定义错误， 使用errors.New 和 panic 内置函数。
1) errors.New("错误说明") , 会返回一个error 类型的值，表示一个错误
2) panic内置函数 ,接收一个 interface{}类型的值（也就是任何值了）作为参数。可以接收 error 类
型的变量，输出错误信息，并退出程序.
6.26.7 案例说明
第 章 数组与切片
7
7.1 为什么需要数组
 看一个问题
一个养鸡场有 6 只鸡，它们的体重分别是 3kg,5kg,1kg,3.4kg,2kg,50kg 。请问这六只鸡的总体重是
多少?平均体重是多少? 请你编一个程序。=》数组
 使用传统的方法来解决
对上面代码的说明
1) 使用传统的方法不利于数据的管理和维护.
2) 传统的方法不够灵活，因此我们引出需要学习的新的数据类型=>数组.
7.2 数组介绍
数组可以存放多个同一类型数据。数组也是一种数据类型，在Go 中，数组是值类型。
7.3 数组的快速入门
我们使用数组的方法来解决养鸡场的问题.
对上面代码的总结
1) 使用数组来解决问题，程序的可维护性增加.
2) 而且方法代码更加清晰，也容易扩展。
7.4 数组定义和内存布局
 数组的定义
var 数组名 [数组大小]数据类型
vara[5]int
赋初值 a[0]=1a[1]=30....
 数组在内存布局(重要)
对上图的总结:
1) 数组的地址可以通过数组名来获取 &intArr
2) 数组的第一个元素的地址，就是数组的首地址
3) 数组的各个元素的地址间隔是依据数组的类型决定，比如int64-> 8 int32->4...
7.5 数组的使用
 访问数组元素
数组名[下标] 比如：你要使用a 数组的第三个元素 a[2]
 快速入门案例
从终端循环输入5个成绩，保存到 float64 数组,并输出.
 四种初始化数组的方式
7.6 数组的遍历
7.6.1方式 1-常规遍历:
前面已经讲过了，不再赘述。
7.6.2方式 2-for-range 结构遍历
这是Go语言一种独有的结构，可以用来遍历访问数组的元素。
 for--range 的基本语法
 for-range的案例
7.7 数组使用的注意事项和细节
1) 数组是多个相同类型数据的组合,一个数组一旦声明/定义了,其长度是固定的, 不能动态变化
2) vararr []int 这时 arr 就是一个slice 切片，切片后面专门讲解，不急哈.
3) 数组中的元素可以是任何数据类型，包括值类型和引用类型，但是不能混用。
4) 数组创建后，如果没有赋值，有默认值(零值)
数值类型数组：默认值为 0
字符串数组： 默认值为 ""
bool数组： 默认值为 false
5) 使用数组的步骤 1. 声明数组并开辟空间 2 给数组各个元素赋值(默认零值)3 使用数组
6) 数组的下标是从0开始的
7) 数组下标必须在指定范围内使用，否则报 panic：数组越界，比如
vararr [5]int 则有效下标为 0-4
8) Go 的数组属值类型， 在默认情况下是值传递， 因此会进行值拷贝。数组间不会相互影响
9) 如想在其它函数中，去修改原来的数组，可以使用引用传递(指针方式)
10) 长度是数组类型的一部分，在传递函数参数时 需要考虑数组的长度，看下面案例
7.8 数组的应用案例
1) 创建一个byte 类型的26个元素的数组，分别 放置'A'-'Z‘。使用 for循环访问所有元素并打印
出来。提示：字符数据运算 'A'+1 -> 'B'
2) 请求出一个数组的最大值，并得到对应的下标。
3) 请求出一个数组的和和平均值。for-range
4) 要求：随机生成五个数，并将其反转打印 , 复杂应用.
7.9 为什么需要切片
先看一个需求：我们需要一个数组用于保存学生的成绩，但是学生的个数是不确定的，请问怎么
办？解决方案：-》使用切片。
7.10 切片的基本介绍
1) 切片的英文是slice
2) 切片是数组的一个引用，因此切片是引用类型，在进行传递时，遵守引用传递的机制。
3) 切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度len(slice)都一样。
4) 切片的长度是可以变化的，因此切片是一个可以动态变化数组。
5) 切片定义的基本语法:
var 切片名 []类型
比如：vara[]int
7.11 快速入门
演示一个切片的基本使用：
运行结果是：
7.12 切片在内存中形式(重要)
 基本的介绍：
为了让大家更加深入的理解切片，我们画图分析一下切片在内存中是如何布局的，这个是一个非
常重要的知识点：(以前面的案例来分析)
 画出前面的切片内存布局
 对上面的分析图总结
1.slice的确是一个引用类型
2.slice 从底层来说，其实就是一个数据结构(struct 结构体)
type slicestruct {
ptr *[2]int
len int
cap int
}
7.13 切片的使用
 方式1
第一种方式：定义一个切片，然后让切片去引用一个已经创建好的数组，比如前面的案例就是这
样的。
 方式2
第二种方式：通过make来创建切片.
基本语法：var 切片名 []type= make([]type, len,[cap])
参数说明: type: 就是数据类型 len: 大小 cap ：指定切片容量，可选， 如果你分配了 cap,则要
求cap>=len.
案例演示：
对上面代码的小结:
1) 通过make方式创建切片可以指定切片的大小和容量
2) 如果没有给切片的各个元素赋值，那么就会使用默认值[int , float=> 0 string =>”” bool =>
false]
3) 通过 make 方式创建的切片对应的数组是由 make 底层维护，对外不可见，即只能通过 slice 去
访问各个元素.
 方式3
第3种方式：定义一个切片，直接就指定具体数组，使用原理类似make的方式
案例演示：
 方式1和方式2的区别(面试)
7.14 切片的遍历
切片的遍历和数组一样，也有两种方式
 for 循环常规方式遍历
 for-range 结构遍历切片
7.15 切片的使用的注意事项和细节讨论
1) 切片初始化时 varslice =arr[startIndex:endIndex]
说明：从arr 数组下标为startIndex，取到 下标为endIndex 的元素(不含arr[endIndex])。
2) 切片初始化时，仍然不能越界。范围在 [0-len(arr)] 之间，但是可以动态增长.
varslice =arr[0:end] 可以简写 varslice =arr[:end]
varslice =arr[start:len(arr)] 可以简写： var slice=arr[start:]
varslice =arr[0:len(arr)] 可以简写: var slice=arr[:]
3) cap 是一个内置函数，用于统计切片的容量，即最大可以存放多少个元素。
4) 切片定义完后，还不能使用，因为本身是一个空的，需要让其引用到一个数组，或者 make 一
个空间供切片来使用
5) 切片可以继续切片[案例演示]
6) 用append 内置函数，可以对切片进行动态追加
对上面代码的小结
切片append操作的底层原理分析:
切片append 操作的本质就是对数组扩容
go 底层会创建一下新的数组newArr(安装扩容后大小)
将slice原来包含的元素拷贝到新的数组newArr
slice 重新引用到newArr
注意newArr 是在底层来维护的，程序员不可见.
7) 切片的拷贝操作
切片使用copy 内置函数完成拷贝，举例说明
对上面代码的说明:
(1) copy(para1, para2) 参数的数据类型是切片
(2) 按照上面的代码来看,slice4 和slice5 的数据空间是独立，相互不影响，也就是说 slice4[0]=999,
slice5[0] 仍然是 1
8) 关于拷贝的注意事项
说明: 上面的代码没有问题，可以运行, 最后输出的是 [1]
9) 切片是引用类型，所以在传递时，遵守引用传递机制。看两段代码，并分析底层原理
7.16 string 和 slice
1) string底层是一个byte 数组，因此string 也可以进行切片处理 案例演示：
2) string和切片在内存的形式，以 "abcd" 画出内存示意图
3) string是不可变的，也就说不能通过 str[0]='z' 方式来修改字符串
4) 如果需要修改字符串，可以先将string-> []byte / 或者 []rune -> 修改 -> 重写转成string
7.17 切片的课堂练习题
说明：编写一个函数 fbn(n int) ，要求完成
1) 可以接收一个 nint
2) 能够将斐波那契的数列放到切片中
3) 提示, 斐波那契的数列形式:
arr[0]= 1;arr[1] =1; arr[2]=2; arr[3]= 3;arr[4]=5; arr[5]=8
代码+思路：
第 章 排序和查找
8
8.1 排序的基本介绍
8.2 冒泡排序的思路分析
8.3 冒泡排序实现
8.4 课后练习
要求同学们能够，不看老师的代码，可以默写冒泡排序法(笔试题)
8.5 查找
 介绍：
在Golang 中，我们常用的查找有两种:
1) 顺序查找
2) 二分查找(该数组是有序)
 案例演示：
1) 有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王
猜数游戏：从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】
代码：
2) 请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存
在此数，并且求出下标，如果没有就提示"没有这个数"。【会使用到递归】
二分查找的思路分析：
二分查找的代码实现：
package main
import(
"fmt"
)
//二分查找的函数
/*
二分查找的思路: 比如我们要查找的数是 findVal
1.arr 是一个有序数组，并且是从小到大排序
2. 先找到 中间的下标 middle = (leftIndex + rightIndex) / 2, 然后让 中间下标的值和 findVal 进行
比较
2.1 如果 arr[middle]>findVal , 就应该向 leftIndex ---- (middle-1)
2.2 如果 arr[middle] rightIndex {
// 找不到..
return ..
}
*/
funcBinaryFind(arr *[6]int,leftIndex int, rightIndex int, findValint){
//判断 leftIndex 是否大于 rightIndex
ifleftIndex > rightIndex {
fmt.Println("找不到")
return
}
//先找到 中间的下标
middle:=(leftIndex +rightIndex)/ 2
if(*arr)[middle] >findVal {
//说明我们要查找的数，应该在 leftIndex --- middel-1
BinaryFind(arr,leftIndex,middle-1,findVal)
} elseif(*arr)[middle]<findVal {
//说明我们要查找的数，应该在 middel+1 --- rightIndex
BinaryFind(arr,middle+1,rightIndex, findVal)
} else{
//找到了
fmt.Printf("找到了，下标为%v \n",middle)
}
}
funcmain() {
arr :=[6]int{1,8, 10,89,1000,1234}
//测试一把
BinaryFind(&arr,0,len(arr) -1,-6)
}
8.6 二维数组的介绍
多维数组我们只介绍二维数组
8.7 二维数组的应用场景
比如我们开发一个五子棋游戏，棋盘就是需要二维数组来表示。如图
8.8 二维数组快速入门
快速入门案例：
 请用二维数组输出如下图形
000000
001000
020300
000000
 代码演示
8.9 使用方式 1: 先声明/定义,再赋值
 语法:var 数组名 [大小][大小]类型
 比如:var arr [2][3]int ， 再赋值。
 使用演示
 二维数组在内存的存在形式(重点)
8.10 使用方式 2: 直接初始化
 声明：var 数组名 [大小][大小]类型 =[大小][大小]类型{{初值..},{初值..}}
 赋值(有默认值，比如int 类型的就是0)
 使用演示
 说明：二维数组在声明/定义时也对应有四种写法[和一维数组类似]
var 数组名 [大小][大小]类型 =[大小][大小]类型{{初值..},{初值..}}
var 数组名 [大小][大小]类型 =[...][大小]类型{{初值..},{初值..}}
var 数组名 = [大小][大小]类型{{初值..},{初值..}}
var 数组名 = [...][大小]类型{{初值..},{初值..}}
8.11 二维数组的遍历