# 10 \| 到底应不应该返回对象？你好，我是吴咏炜。前几讲里我们已经约略地提到了返回对象的问题，本讲里我们进一步展开这个话题，把返回对象这个问题讲深讲透。F.20《C++ 核心指南》的 F.20 这一条款是这么说的\[1\：>  > F.20: For "out" output values, prefer return values to output> parameters> > >翻译一下：>  > 在函数输出数值时，尽量使用返回值而非输出参数> > >这条可能会让一些 C++ 老手感到惊讶------在 C++11之前的实践里，我们完全是采用相反的做法的啊！在解释 F.20之前，我们先来看看我们之前的做法。调用者负责管理内存，接口负责生成一种常见的做法是，接口的调用者负责分配一个对象所需的内存并负责其生命周期，接口负责生成或修改该对象。这种做法意味着对象可以默认构造（甚至只是一个结构），代码一般使用错误码而非异常。示例代码如下：    MyObj obj;    ec = initialize(&obj);    …这种做法和 C 是兼容的，很多程序员出于惯性也沿用了 C的这种做法。一种略为 C++点的做法是使用引用代替指针，这样在上面的示例中就不需要使用 `&`运算符了；但这样只是语法略有区别，本质完全相同。如果对象有合理的析构函数的话，那这种做法的主要问题是啰嗦、难于组合。你需要写更多的代码行，使用更多的中间变量，也就更容易犯错误。假如我们已有矩阵变量 ]{.strutstyle="height:0.68611em;vertical-align:0em;"}[[A]{.mord.mathbf}]{.mord}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}slate-type="inline-katex" slate-object="inline"、]{.strutstyle="height:0.68611em;vertical-align:0em;"}[[B]{.mord.mathbf}]{.mord}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}slate-type="inline-katex"  和 [[[]{.strutstyle="height:0.68611em;vertical-align:0em;"}[[C]{.mord.mathbf}]{.mord}]{.base}]{.katex-html aria-hidden="true"}]{.katexslate-string="true"}]}slate-type="inline-katex" slate-object="inline"，要执行一个操作  .ps} {slate-type="block-katex" ]{.strut style="height:0.68611em;vertical-align:0em;"}[[R]{.mord.mathbf}]{.mord}[]{.mspacestyle="margin-right:0.2777777777777778em;"}[=]{.mrel}[]{.mspacestyle="margin-right:0.2777777777777778em;"}]{.base}[[]{.strutstyle="height:0.76944em;vertical-align:-0.08333em;"}[[A]{.mord.mathbf}]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[×]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:0.76944em;vertical-align:-0.08333em;"}[[B]{.mord.mathbf}]{.mord}[]{.mspacestyle="margin-right:0.2222222222222222em;"}[+]{.mbin}[]{.mspacestyle="margin-right:0.2222222222222222em;"}]{.base}[[]{.strutstyle="height:0.68611em;vertical-align:0em;"}[[C]{.mord.mathbf}]{.mord}]{.base}]{.katex-htmlaria-hidden="true"}]{.katex}]{.katex-display} {.ps__rail-x style="left: 0px; bottom: 0px;"} {.ps__thumb-x tabindex="0" style="left: 0px; width: 0px;"} {.ps__rail-y style="top: 0px; right: 0px;"} {.ps__thumb-y tabindex="0" style="top: 0px; height: 0px;"}那在这种做法下代码大概会写成：    error_code_t add(      matrix* result,      const matrix& lhs,      const matrix& rhs);    error_code_t multiply(      matrix* result,      const matrix& lhs,      const matrix& rhs);    …      error_code_t ec;      …      matrix temp;      ec = multiply(&temp, a, b);      if (ec != SUCCESS) {        goto end;      }      matrix r;      ec = add(&r, temp, c);      if (ec != SUCCESS) {        goto end;      }      …    end:      //  返回  ec  或类似错误处理理论上该方法可以有一个变体，不使用返回值，而使用异常来表示错误。实践中，我从来没在实际系统中看到过这样的代码。接口负责对象的堆上生成和内存管理另外一种可能的做法是接口提供生成和销毁对象的函数，对象在堆上维护。`fopen` 和 `fclose`就是这样的接口的实例。注意使用这种方法一般不推荐由接口生成对象，然后由调用者通过调用 `delete`来释放。在某些环境里，比如 Windows上使用不同的运行时库时，这样做会引发问题。同样以上面的矩阵运算为例，代码大概就会写成这个样子：    matrix* add(      const matrix* lhs,      const matrix* rhs,      error_code_t* ec);    matrix* multiply(      const matrix* lhs,      const matrix* rhs,      error_code_t* ec);    void deinitialize(matrix** mat);    …      error_code_t ec;      …      matrix* temp = nullptr;      matrix* r = nullptr;      temp = multiply(a, b, &ec);      if (!temp) {        goto end;      }      r = add(temp, c, &ec);      if (!r) {        goto end;      }      …    end:      if (temp) {        deinitialize(&temp);      }      //  返回  ec  或类似错误处理可以注意到，虽然代码看似稍微自然了一点，但啰嗦程度却增加了，原因是正确的处理需要考虑到各种不同错误路径下的资源释放问题。这儿也没有使用异常，因为异常在这种表达下会产生内存泄漏，除非用上一堆 `try` 和`catch`，但那样异常在表达简洁性上的优势就没有了，没有实际的好处。不过，如果我们同时使用智能指针和异常的话，就可以得到一个还不错的变体。如果接口接受和返回的都是`shared_ptr`，那调用代码就简单了：    shared_ptr add(      const shared_ptr& lhs,      const shared_ptr& rhs);    shared_ptr multiply(      const shared_ptr& lhs,      const shared_ptr& rhs);    …      auto r = add(multiply(a, b), c);调用这些接口必须要使用 `shared_ptr`，这不能不说是一个限制。另外，对象永远是在堆上分配的，在很多场合，也会有一定的性能影响。接口直接返回对象最直接了当的代码，当然就是直接返回对象了。这回我们看实际可编译、运行的代码：    #include     #include     using arma::imat22;    using std::cout;    int main()    {      imat22 a{{1, 1}, {2, 2}};      imat22 b{{1, 0}, {0, 1}};      imat22 c{{2, 2}, {1, 1}};      auto r = a * b + c;      cout     using namespace std;    // Can copy and move    class A {    public:      A() { cout   > `Create A`>>>  > `Destroy A`>我们把代码稍稍改一下：    A getA_named()    {      A a;      return a;    }    int main()    {      auto a = getA_named();    }这回结果有了一点点小变化。虽然 GCC 和 Clang 的结果完全不变，但 MSVC在非优化编译的情况下产生了不同的输出（优化编译------使用命令行参数`/O1`、`/O2` 或 `/Ox`------则不变）：>  > `Create A`>>>  > `Move A`>>>  > `Destroy A`>>>  > `Destroy A`>也就是说，返回内容被移动构造了。我们继续变形一下：    #include     A getA_duang()    {      A a1;      A a2;      if (rand() > 42) {        return a1;      } else {        return a2;      }    }    int main()    {      auto a = getA_duang();    }这回所有的编译器都被难倒了，输出是：>  > `Create A`>>>  > `Create A`>>>  > `Move A`>>>  > `Destroy A`>>>  > `Destroy A`>>>  > `Destroy A`>关于返回值优化的实验我们就做到这里。下一步，我们试验一下把移动构造函数删除：      A(A&&) = delete;我们可以立即看到"CopyA"出现在了结果输出中，说明目前结果变成拷贝构造了。如果再进一步，把拷贝构造函数也删除呢？是不是上面的`getA_unnamed`、`getA_named` 和 `getA_duang`都不能工作了？在 C++14 及之前确实是这样的。但从 C++17 开始，对于类似于 `getA_unnamed`这样的情况，即使对象不可拷贝、不可移动，这个对象仍然是可以被返回的！C++17要求对于这种情况，对象必须被直接构造在目标位置上，不经过任何拷贝或移动的步骤\[3\。回到 F.20理解了 C++ 里的对返回值的处理和返回值优化之后，我们再回过头看一下F.20里陈述的理由的话，应该就显得很自然了：>  > A return value is self-documenting, whereas a> > `&` could be> either in-out or out-only and is liable to be> misused.> >>>  > 返回值是可以自我描述的；而> > `&`> 参数既可能是输入输出，也可能是仅输出，且很容易被误用。> > >我想我对返回对象的可读性，已经给出了充足的例子。对于其是否有性能影响这一问题，也给出了充分的说明。我们最后看一下 F.20里描述的例外情况：1.  "对于非值类型，比如返回值可能是子对象的情况，使用        `unique_ptr`    或     `shared_ptr`    来返回对象。"也就是面向对象、工厂方法这样的情况，像        [\[第 1    讲\]             里给出的         `create_shape`    应该这样改造。        2.  "对于移动代价很高的对象，考虑将其分配在堆上，然后返回一个句柄（如           `unique_ptr`），或传递一个非 const    的目标对象的引用来填充（用作输出参数）。"也就是说不方便移动的，那就只能使用一个    RAII    对象来管理生命周期，或者老办法输出参数了。        3.  "要在一个内层循环里在多次函数调用中重用一个自带容量的对象：将其当作输入    /    输出参数并将其按引用传递。"这也是个需要继续使用老办法的情况。        内容小结C++里已经对返回对象做了大量的优化，目前在函数里直接返回对象可以得到更可读、可组合的代码，同时在大部分情况下我们可以利用移动和返回值优化消除性能问题。课后思考请你考虑一下：1.       你的项目使用了返回对象了吗？如果没有的话，本讲内容有没有说服你？        2.       这讲里我们没有深入讨论赋值；请你思考一下，如果例子里改成赋值，会有什么样的变化？        欢迎留言和我交流你的想法。参考资料\[1\] Bjarne Stroustrup and Herb Sutter (editors), "C++ coreguidelines", item F.20. slate-object="mark"}https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-outslate-object="mark"} (非官方中文版可参见https://github.com/lynnboy/CppCoreGuidelines-zh-CNslate-object="mark"}) \[2\] Conrad Sanderson and Ryan Curtin, Armadillo.http://arma.sourceforge.net/slate-object="mark"} \[3\] cppreference.com, "Copy elision".https://en.cppreference.com/w/cpp/language/copy_elisionslate-object="mark"} \[3a\] cppreference.com, "复制消除".https://zh.cppreference.com/w/cpp/language/copy_elisionslate-object="mark"} 