A CTF-Style Escape Journey 
on VMware Workstation
PI:EMAIL
About us
●
Beijing Chaitin Tech Co., Ltd(@ChaitinTech)
○
https://chaitin.cn/en
○
https://realworldctf.com/
●
Chaitin Security Research Lab
○
Pwn2Own 2017 3rd place
○
GeekPwn 2015/2016/2018/2019 awardees
■
PS4 Jailbreak, Android rooting, IoT Offensive Research, ESXi Escape
○
CTF players from team b1o0p, Tea Deliverers
■
2nd place at DEFCON 2016
■
3rd place at DEFCON 2019
■
1st place at HITCON 2019
Before we start
●
VMM(Hypervisor)：Virtual Machine Monitor
●
Guest OS
●
Host OS
What is Virtual Machine Escape
VMM
Guest OS
0
Guest OS
1
Guest OS
N
...
Host OS
...
Normally, all of the sensitive behaviors of guest OS will be sanitized by the hypervisor
What is Virtual Machine Escape
VMM
Guest OS
0
Guest OS
1
Guest OS
N
...
Host OS
...
What is Virtual Machine Escape
VMM
Guest OS
0
Guest OS
1
Guest OS
N
...
Host OS
exploitation
...
What is Virtual Machine Escape
VMM
Guest OS
0
Guest OS
1
Guest OS
N
...
Host OS
exploitation
Execute arbitrary codes 
on the host
network connectio
...
Introduction of 
VMware Workstation
Architecture
Host OS
Physical Hardware
User mode
Architecture after vmware runs
Host OS
Physical Hardware
User mode
VM Monitor
vmware-vmx
vmmon
VM
VM
VM
Host World
VM World
Architecture after vmware runs
Host OS
Physical Hardware
User mode
VM Monitor
vmware-vmx
vmmon
VM
VM
VM
Host World
VM World
Architecture after vmware runs
Host OS
Physical Hardware
User mode
VM Monitor
vmware-vmx
vmmon
VM
VM
VM
Host World
VM World
Attack Surface
Graphic
Ethernet
USB
SATA
SCSI
COM
Attack in Recent Years
(Pwn2Own 2019)
Graphic
Ethernet
USB
SATA
SCSI
COM
(TianfuCup 2018)
(Pwn2Own 2017)
Our Target
(Pwn2Own 2019)
Graphic
Ethernet
USB
SATA
SCSI
COM
(TianfuCup 2018)
(Pwn2Own 2017)
CVE-2019-5541
Analysis
How e1000e works?
Guest OS
TDT
TDH
TDBAL
TDBAH
e1000e virtual network card
registers
How e1000e works?
Guest OS
TDT
TDH
TDBAL
TDBAH
e1000e virtual network card
registers
write
How e1000e works?
Guest OS
TDT
TDH
TDBAL
TDBAH
e1000e virtual network card
registers
write
mem = registers[TDBAH]prop;
prop->ipcss = transfer.prop_desc.ipcss;
...
How e1000e works?
e1000e virtual network card
mem = registers[TDBAH]prop;
prop->ipcss = transfer.prop_desc.ipcss;
...
CVE-2019-5541
void __usercall e1000_process_TXD_CMD_DEXT() {
  ...
  packet = e1000_init_packet(...);
  if(packet){
...
e1000_send_packet(...,packet);
  }
  ...
}
CVE-2019-5541
void __usercall e1000_init_packet(...) {
  ...
  if(flag_if_not_ipv6_GSO){
ip_checsum_start = ipcss;
if(ipcss > hdr_size || 
   ipcso > hdr_size ||
   ipcse > hdr_size-ipcse ||
   hdr_size - ipcso  hdr_size || 
   ipcso > hdr_size ||
   ipcse > hdr_size-ipcse ||
   hdr_size - ipcso  hdr_size || 
   ipcso > hdr_size ||
   ipcse > hdr_size-ipcse ||
   hdr_size - ipcso prop;
prop->ipcss = transfer.prop_desc.ipcss;
...
where does ipcss come from
Preliminary Exploit Primitive
void __usercall e1000_init_packet(...) {
  ...
    hdr_size = hdr_len + vlan_size; //vlan_size will be 4 or 0
    sigment_num = (mss + pay_size - 1) / mss;
  ...
    simple_segment_size = (mss+hdr_size+0x11)&0xfffffff8;
    packet = malloc(sigment_num * simple_segment_size);
  ...
    if(mss){
        buf = &packet[ipcss+10];
        data = hdr + mss - ipcss;
        if(flag_0)
            *(buf+2) = htons(data);
    }
  ...
}
Preliminary Exploit Primitive
void __usercall e1000_init_packet(...) {
  ...
    hdr_size = hdr_len + vlan_size; //vlan_size will be 4 or 0
    sigment_num = (mss + pay_size - 1) / mss;
  ...
    simple_segment_size = (mss+hdr_size+0x11)&0xfffffff8;
    packet = malloc(sigment_num * simple_segment_size);
  ...
    if(mss){
        buf = &packet[ipcss+10];
        data = hdr + mss - ipcss;
        if(flag_0)
            *(buf+2) = htons(data);//heap overflow write happens!
    }
  ...
}
Preliminary Exploit Primitive
void __usercall e1000_init_packet(...) {
  ...
    ...
  cur_buffer = packet;
  transfer_pay_size = pay_size;
  while(idx prop;
prop->ipcss = transfer.prop_desc.ipcss;
...
where does ipcss come from
Limitations
e1000e virtual network card
mem = registers[TDBAH]<<32|registers[TDBAL];
mem = mem + registers[TDH]*sizeof(transfer);
ReadGuestMem(mem,&transfer);
//Handle transfer struct
...
...
registers[TDH]++;
if(registers[TDH]==registers[TDT])
return;
else
loop;
packet transfer
union{
struct{
uint64_t buf_addr;
uint64_t size;
}transfer_data;
struct{
uint8_t ipcss;
//IP checsum start
uint8_t ipcso;
//IP checsum offset
uint16_t ipcse;
//IP checsum end
uint8_t tucss;
//TCP checsum start
uint8_t tucso;
//TCP checsum offset
uint16_t tucse;
//TCP checsum end
uint32_t cmd_and_length;
uint8_t status;
//Descriptor status
uint8_t hdr_len;
//Header length
uint16_t mss;
//Maximum segment 
size
}prop_desc;
}tranfer;
Limitations
e1000e virtual network card
mem = registers[TDBAH]<<32|registers[TDBAL];
mem = mem + registers[TDH]*sizeof(transfer);
ReadGuestMem(mem,&transfer);
//Handle transfer struct
...
...
registers[TDH]++;
if(registers[TDH]==registers[TDT])
return;
else
loop;
packet transfer
union{
struct{
uint64_t buf_addr;
uint64_t size;
}transfer_data;
struct{
uint8_t ipcss;
//IP checsum start
uint8_t ipcso;
//IP checsum offset
uint16_t ipcse;
//IP checsum end
uint8_t tucss;
//TCP checsum start
uint8_t tucso;
//TCP checsum offset
uint16_t tucse;