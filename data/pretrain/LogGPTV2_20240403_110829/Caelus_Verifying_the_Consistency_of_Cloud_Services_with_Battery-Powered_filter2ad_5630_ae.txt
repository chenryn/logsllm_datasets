require the device to wake up and send keep-alive messages
every 5-10 minutes. As a result, we generally expect that TR
is set to coincide with these keep-alive periods.
V. SECURITY ANALYSIS
Now that we have presented the design of Caelus we
describe how the individual guarantees that Caelus provides
are upheld by elements in its design. These guarantees hold
when either the cloud service is malicious or clients are
malicious. We further show that even if several malicious
clients collude, they do not gain any abilities beyond those
that a single malicious client has.
A. Analysis of guarantees
SRV1. Since all clients encrypt data before sending it to the
cloud provider and the encryption key is not known to the
cloud service, a malicious cloud provider cannot read user
data.
SRV2. A cryptographic hash of data sent in Puts is computed
and included in the header of the Put. The header is signed
by the device making the update. The same header is returned
by the cloud service to a client performing a Get on the same
key. The client then veriﬁes the signature on the header and
then uses the hash to verify the integrity of the returned data.
Since the cloud service cannot forge the signatures, the data
stored on the cloud is protected from tampering by a malicious
cloud provider.
SRV3. The scheduled attestations produced by the AA in
combination with the consistency model-speciﬁc veriﬁcation
checks guarantee that consistency violations are detected
within TCaelus. Scheduled attestations ensure that all clients
are notiﬁed of the history of an operation within TCaelus after
the operation occurs. Since all clients see the same history, one
can view the attested history as a “global history” of all oper-
ations. The veriﬁcation checks then guarantee two properties:
1) each client’s observed history of operations matches the
attested global history and 2) the global history is consistent
with the promised consistency model. For the second property,
the veriﬁcation checks verify that all operations are made
visible within the promised time bound by comparing the
timestamps on operations (i.e., no stale data is read) and
that operations are made visible according to the ordering
constraints speciﬁed by the promised consistency model (i.e.,
no malicious reordering).
CLT1. Because all key-value updates must be signed by the
client making them, a client cannot later deny that it made the
update. As a result, data modiﬁcations are non-repudiable.
CLT2. To falsely accuse the cloud service of a consistency
violation, a client must show that one of the veriﬁcation checks
has failed even when in reality it hasn’t. This can only happen
in one of two ways: either the accusing client is able to alter
the contents of the attested history so that a check fails, or it
can convince the user that a veriﬁcation check has failed even
when it hasn’t.
All attested history segments are signed twice, once initially
by the cloud service and then again by the attestor. As a
result, a regular client would have to forge the signatures of
both the cloud service and the attestor to tamper with the
attested history. If either the RA or the AA is malicious, it
could try to tamper with the attested history before signing it.
However, to successfully tamper with it, the malicious attestor
would still need to forge the cloud service’s signature, which
is not possible according to our attack model. As a result, no
malicious client can tamper with the attested history to falsely
accuse an honest cloud service.
The other alternative is for the client to incorrectly evaluate
a veriﬁcation check and declare that a check has failed.
However, since all consistency violations can be publicly
audited, a malicious client on its own cannot falsely accuse
the cloud service.
AV1. Clients expect the AA to sign an attestation every TA.
If this does not happen, then clients will halt, affecting the
availability of the system. Similarly, a malicious RA can
refuse to select AA and also refuse to sign attestations. If
the cloud service is malicious, it can also affect availability
by simply refusing to respond to requests for clients. Thus a
single malicious client, if it happens to be the AA or RA, or
a malicious cloud service can invalidate Guarantee AV1.
Under normal circumstances, where there are no failures
and all components adhere to the protocol, an attestation is
produced every TA. If all clients are asleep and a new client
joins, it must wake up the RA. Normally, the new client would
890
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:07:39 UTC from IEEE Xplore.  Restrictions apply. 
have to wait for up to TR for the RA to wake up, thus affecting
availability. However, because Caelus uses push notiﬁcations,
this waiting period is shortened to the latency of a push
notiﬁcation, which is on the order of 1 second. Thus, under
normal circumstances, Caelus does not affect availability.
consistency key-value store. As a result, our prototype doesn’t
implement causal consistency at this time. However, if one
were available, we believe it would be fairly straight forward
to integrate it with our prototype as our prototype only assumes
a Put and Get interface.
B. Colluding clients
Multiple colluding clients do not have any capabilities
beyond a single malicious client. Like a single client, they are
only able to corrupt or leak data by virtue of their ability to
access and modify the data. However, both guarantees against
malicious clients, CLT1 and CLT2, hold.
CLT1. Malicious clients could share their signing keys thus
allowing any malicious client to forge signatures that could
have been made by another malicious client. Thus, malicious
actions can no longer be traced to the client
that made
them, but only to a member of the group of colluding
malicious clients. While this changes the actual
terms of
Guarantee CLT1, it doesn’t change the intent – actions made
by an adversary in control of several clients are still traceable
back to that group of clients. Thus, Guarantee CLT1 still holds
in the face of client collusion.
CLT2. To falsely accuse the cloud service, clients must be
able to forge cloud service signatures. Having more than one
malicious client does not make it any more possible to forge
signatures, so Guarantee CLT2 will also hold against colluding
clients.
In summary, colluding clients, regardless of whether they
are regular clients or include the AA or RA, do not invalidate
any guarantees except Guarantee AV1, which can already be
invalidated by a single malicious client if that client happens
to be an AA or RA.
VI. IMPLEMENTATION
In this section, we describe our Caelus prototype, which
implements the cloud server and history server components in
the cloud service and clients for PCs and Android devices.
A. Cloud service
The cloud server and history server components are im-
plemented in 3K lines of Java and communication between
the server components as well as clients is implemented
using Apache XML-RPC. To implement different consistency
models, our prototype is modular and can use different key-
value store backends. For strong consistency, our prototype
uses a single cloud server with a local key-value store im-
plemented with the LevelDB library [30]. Because all clients
communicate with a single server, the server can make all
client operations atomic, thus providing strong consistency.
To implement eventual consistency, our prototype uses Ama-
zon’s cloud infrastructure. Multiple cloud servers run as EC2
instances and use Amazon’s S3 service as the key-value store
backend. A single history server typically shares one of the
EC2 nodes with a cloud server but could also run on a
dedicated node. We are currently not aware of any open-
source or commercial cloud service that implements a causally
It is possible to implement Caelus without cloud server
components by having clients communicate directly with the
key-value store and history server. However, having the cloud
server allowed us to easily abstract the different LevelDB and
S3 interfaces from the clients, allowing us to have identical
client code for all experiments.
B. Clients
We implement two different types of clients for our pro-
totype, one for PCs and one for Android devices. Both are
written in Java and consist of about 7K lines of code. To reduce
the number of client-server round trips the server piggy backs
recent attestations on the responses to Puts and Gets.
Each time a client performs a Put, it is enqueued on a
deferred veriﬁcation list. Occasionally, a Get can be veriﬁed
at the time it occurs because it reads the latest attested value,
but other times, it reads a value that has yet to be attested, so
it must also be enqueued on the deferred veriﬁcation list. Ver-
iﬁcation of deferred operations is performed asynchronously
by a veriﬁcation thread, which periodically wakes up every
TA, processes any new log segments that have been received
and then veriﬁes operations on the deferred veriﬁcation list.
Operations that remain unveriﬁed for longer than TCaelus are
ﬂagged as violations. Any delays between when the AA posts
attestations and when clients process them must be accounted
for in ǫ. Thus, we synchronize both the period and phase of
the veriﬁcation thread with that of the AA.
We use the Google Cloud Messaging (GCM) service to
implement push messages on Android clients. GCM generally
takes about 1 second to deliver a message to the phone
because it requires an additional network hop to Google’s
servers. This latency could be reduced by implementing our
own dedicated push service and collocating the notiﬁcation
server with the cloud server the phone is connected to, but
for the purposes of our prototype, we found the 1 second
latency to be reasonable and perhaps more realistic since most
cloud services would more likely use a third-party notiﬁcation
service than implement their own. GCM does not use a ﬁxed
period for keep-alive messages, but instead varies their timing
depending on network conditions. Caelus can be modiﬁed to
allow for a variable TR by having the phone embed the length
of the current AA selection period in each selection message,
but our prototype does not implement this. As a result, we
currently do not synchronize TR with the GCM heartbeat
period.
VII. EVALUATION
We evaluate four properties of our Caelus prototype. First,
we evaluate Caelus’ effectiveness at detecting consistency vio-
lations. Second, we evaluate the computational costs of Caelus
on clients. Third, we evaluate the battery costs of Caelus on
891
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:07:39 UTC from IEEE Xplore.  Restrictions apply. 
100%
s
t
e
G
f
o
e
g
a
t
n
e
c
r
e
P
90%
80%
70%
60%
50%
40%
30%
20%
10%
0%
Violations
GT-Caelus
GT-Service
s
t
e
G
f
o
e
g
a
t
n
e
c
r
e
P
100%
90%
80%
70%
60%
50%
40%
30%
20%
10%
0%
Violations
GT-Caelus
GT-Service
0
0.5
1
1.5
2
2.5
3
0
0.5
1
1.5
2
2.5
3
TS (seconds) 
TA (seconds) 
Fig. 5. Percentage of Gets with consistency violations on S3 as a function
of TS . GT-Caelus represents the true number of TCaelus violations and GT-
Service represents the true number of TS violations.
the smartphone, as well as the battery savings of attestor-
partitioning. Finally, we evaluate the network bandwidth over-
head of sending and retrieving attestations in Caelus.
A. Detecting consistency violations
We begin by evaluating Caelus’ effectiveness at detecting
consistency violations using our eventual consistency proto-
type on S3. Amazon does not publish a visibility time bound
for S3. Thus, we vary TS and measure the effect on the
number of consistency violations detected by Caelus. Using a
TS smaller than what S3 supports simulates a malicious cloud
provider who tries to claims a shorter visibility time bound
than what they can deliver.
We deploy Caelus on S3 in the US Standard Region, which
automatically replicates data across Amazon data centers in the
USA. We then deploy cloud servers on EC2 in the Oregon data
center on the west coast using a t1.micro instance with 2GHz
Intel Xeon E5-2650 cores and 600MB memory and the North-
ern Virginia data center on the east coast using a m3.2xlarge
instance with an 8-core 2.5GHz Intel Xeon E5-2670 Processor
and 30GB of memory. Four “writer” clients are running on
the Northern Virginia server and repeatedly perform Puts
of non-repeating 1MB values on a key. A “reader” client is
connected to the Oregon server and repeatedly performs Gets