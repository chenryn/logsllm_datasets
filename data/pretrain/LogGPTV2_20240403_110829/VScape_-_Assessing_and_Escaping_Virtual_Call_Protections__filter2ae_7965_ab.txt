字节左右，范围不够大。
## 五、VScape
###  1\. 简介
若给定 **一个目标程序** 、 **一个漏洞** 以及 **当前使用的虚拟调用保护方式** ，判断能否通过发起 COOPlus 来绕过 CFI
保护是比较艰难的，尤其是目标程序很大的时候。
这是因为若想发起 COOPlus 攻击，则需要找到适当的攻击原语元组 **（vcall, victim class, counterfeit
class）** ，同时
  * 虚拟调用所调用的函数必须是 **基类虚函数**
  * counterfeit 类和 victim 类均派生自某个基类，但却有不同的虚函数实现方式
  * 可以利用漏洞来破坏 victim 类
除此之外，我们还需要生成适当的输入，使得可以触发目标 vcall，接着触发 counterfeit
函数并最终导致内存越界操作，这整个过程同样也是一项较为艰难的任务。
因此 该论文提出 VSCape 这样的一个解决方案，用来自动编译候选的原语，并过滤出实用且可达的原语，辅助生成最终的漏洞利用来绕过 vcall 保护。
这是 VScape 的整体架构，接下来将分别在下面详细说明每个模块：
> 这个工具虽然在实际中我们可能不会太用到，但是了解一下整体的设计也是一个学习的过程。
###  2\. 原语生成
####  Info Collecting
VScape 将使用传入的目标程序源码，在编译期间收集与 vcall 相关的信息：
  * 虚函数调用点：记录目标程序的 **所有虚拟函数调用点** ，以及预期虚拟函数静态声明的基本接口类信息。
  * 类布局：在编译过程中记录下 **所有类的布局** ，包括类大小，成员变量字段偏移量以及基类等等。
  * 虚函数信息：记录每个虚函数调用点的 **所有符合类型的虚函数** ，以及每个虚函数中的 **最大字段访问偏移量** ，以便于在今后的检查中找到潜在的越界访问。
####  Primitive Searching
从上一步获取到的信息中，VScape 将继续筛选出可用于攻击的攻击原语元组。
  * 首先，VScape 将构建 **类继承（class inheritance hierarchy ，CHI） 树**
  * 初始化 **全局编号** ， 该编号用于记录 **目标虚拟函数** （注意不是所有虚拟函数）的版本，从0开始
  * 在 CHI 树中运用 BFS，给每个类节点编号，以记录目标虚拟函数的版本。若子类使用的虚函数是父类版本，则将父类的 ID 分配给子类，否则将全局编号自增1并赋给子类。
这样操作后，VScape 就可以获得对应 vcall 的带版本号的 CHI 树。即最终可以形成可用的攻击原语 **（vcall, victim class,
counterfeit class）** 。
但这里存在一个问题，由于 vcall 数量规模非常的大，而且类也很多，因此这样一套搜索可能会消耗非常长的时间，不过这还是取决于具体实现。
####  Primitive Capability Analysis
在有了多组攻击原语后，接下来需要判断这些原语在漏洞利用中所能起到的作用。
正如上面将 vfgadget 分成多种类型一样，VScape 在这里也将对不同类型的 vfgadget 进行不同的处理。
  * 对于OOB-read，分析读取的值用作加载 PC 还是用作写入目标内存地址。如果是后者则还会通过污染分析来判断待写入的值能否被敌手控制。
  * 对于 OOB-write，分析写入的值是否是指针，如果是则进一步查找中继对象的使用方式，来尝试找到绕过 ASLR 的地方。
###  3\. 检测原语结构
在获取到大量攻击原语后，需要进一步过滤出可用的原语。
####  Vulnerability Matching
在给定漏洞描述之后，VScape 还会了解目的堆分配器的相关信息，并过滤出那些：
> victim object 与 **可触发漏洞的 buf** 分配在同一个堆中的 候选原语。
因为若分配不在同一个堆，则自然这些攻击原语将无法利用。
####  Exploitable Memory States Inference
若想触发 vcall 中的特定目的（例如写入数据或读取），则必须在 **特定内存状态** 下运行，例如类的某些字段必须为某些特殊值，否则将不满足 vcall
的条件判断，进而无法执行到目标位置。
VScape 将通过污点分析和符号执行来进一步确认。VScape将把 **victim object** 和相邻的 **中继对象**
标记为符号值，并以符号方式执行那些 **会越界访问到中继对象** 的伪造函数。
> 很容易理解为什么要将 **中继对象也作为符号值** ，这是因为伪造函数可能会 **使用到一些越界内存上的值** ，而这些内存上存放的是中继对象。
###  4\. 约束求解
在上面 VScape 已经对原语结构进行了简单的过滤，接下来仍然有三个问题需要解决：
  * 能否使控制流到达目标 vcallsite 上并执行 victim 类的 vcall。
  * 伪造函数上的 OOB 操作能否成功执行
  * 满足上述两点的数据约束是什么
####  Virtual Callsite Reachability Testing
首先对于第一点，VScape 通过定向 fuzz 技术，使用给定的基准测试数据， **尽可能地得到一个不完整的可达 victim 函数列表**
。VScape 将在目标 vcallsite 后插入 callback 以记录调用的 victim function 和 testcase。
####  OOB Instruction Reachability Solving
对于第二点，VScape 把经过上面第一点处理后的 testcase 作为输入，在目标程序执行至目标 vcallsite
后保存此时的执行上下文，并让符号执行引擎在此时的上下文对 **伪函数** 进行符号执行操作，以获取 **执行伪函数 OOB 操作** 的数据依赖。
> 类似的，中转对象也会被作为符号值一并用于符号执行中。
####  Exploit Assembling
VScape 无法自动化生成漏洞利用，它必须依赖用户给定的 exploit 模板来构成完整的漏洞利用链。
用户必须手动：
  * 在 exploit 中手动操作堆风水
  * 在 exploit 中，利用 POC 更改 victim object 的 vptr 为特定值
  * 根据 VScape 提供的信息进行后续的漏洞利用
以这个漏洞模板为例：
main 函数中的黑色字体函数调用是必须由人工手动完成，而红色字体的函数调用是 VScape 可以辅助完成的工作。
## 六、评估
VScape 的评估主要基于三个层面：
  * 在真实世界中的 C++ 程序中，COOPlus 攻击是否实用
  * COOPlus 在绕过 vcall 保护机制上效果如何
  * VScape 在生成真实完整漏洞利用链的过程中表现如何
根据 slides 中给定的结论，我们可以看到 COOPlus 攻击在大项目中比较实用。
而对于那些 vcall 保护机制，COOPlus 可以绕过满足既定攻击条件的保护。
> 既定攻击条件，即不破坏C++ ABI，不保证 vptr 完整性以及允许在 vcallsite 上调用多个目标。
论文中还给出了对于 PyQt 和 Firefox 的利用评估，这里不再展开。