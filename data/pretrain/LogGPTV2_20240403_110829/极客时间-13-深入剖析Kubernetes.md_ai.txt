# 将当前目录下的所有内容复制到 /app 下ADD . /app 
# 使用 pip 命令安装这个应用所需要的依赖RUN pip install --trusted-host pypi.python.org -r requirements.txt 
# 允许外界访问容器的 80 端口EXPOSE 80 
# 设置环境变量ENV NAME World 
# 设置容器进程为：python app.py，即：这个 Python 应用的启动命令CMD ["python", "app.py"通过这个文件的内容，你可以看到**Dockerfile的设计思想，是使用一些标准的原语（即大写高亮的词语），描述我们所要构建的Docker 镜像。并且这些原语，都是按顺序处理的。**比如 FROM原语，指定了"python:2.7-slim"这个官方维护的基础镜像，从而免去了安装Python 等语言环境的操作。否则，这一段我们就得这么写了：    FROM ubuntu:latestRUN apt-get update -yRUN apt-get install -y python-pip python-dev build-essential...其中，RUN 原语就是在容器里执行 shell 命令的意思。而 WORKDIR，意思是在这一句之后，Dockerfile 后面的操作都以这一句指定的/app 目录作为当前目录。```{=html}```所以，到了最后的 CMD，意思是 Dockerfile 指定 python app.py为这个容器的进程。这里，app.py 的实际路径是 /app/app.py。所以，CMD\["python", "[app.py](http://app.py)"\] 等价于 \"docker run```{=html}`````{=html} python [app.py](http://app.py)\"。```{=html}```另外，在使用 Dockerfile 时，你可能还会看到一个叫作 ENTRYPOINT的原语。实际上，它和 CMD 都是 Docker容器进程启动所必需的参数，完整执行格式是："ENTRYPOINT CMD"。但是，默认情况下，Docker 会为你提供一个隐含的 ENTRYPOINT，即：/bin/sh-c。所以，在不指定 ENTRYPOINT时，比如在我们这个例子里，实际上运行在容器里的完整进程是：/bin/sh -c"python [app.py](http://app.py)"，即 CMD 的内容就是 ENTRYPOINT 的参数。> 备注：基于以上原因，**我们后面会统一称 Docker 容器的启动进程为> ENTRYPOINT，而不是 CMD。**需要注意的是，Dockerfile 里的原语并不都是指对容器内部的操作。就比如ADD，它指的是把当前目录（即 Dockerfile所在的目录）里的文件，复制到指定容器内的目录当中。读懂这个 Dockerfile之后，我再把上述内容，保存到当前目录里一个名叫"Dockerfile"的文件中：    $ lsDockerfile  app.py   requirements.txt接下来，我就可以让 Docker 制作这个镜像了，在当前目录执行：    $ docker build -t helloworld .其中，-t 的作用是给这个镜像加一个 Tag，即：起一个好听的名字。dockerbuild 会自动加载当前目录下的 Dockerfile文件，然后按照顺序，执行文件中的原语。而这个过程，实际上可以等同于Docker 使用基础镜像启动了一个容器，然后在容器中依次执行 Dockerfile中的原语。**需要注意的是，Dockerfile中的每个原语执行后，都会生成一个对应的镜像层**。即使原语本身并没有明显地修改文件的操作（比如，ENV原语），它对应的层也会存在。只不过在外界看来，这个层是空的。docker build 操作完成后，我可以通过 docker images 命令查看结果：    $ docker image ls REPOSITORY            TAG                 IMAGE IDhelloworld         latest              653287cdf998通过这个镜像ID，你就可以使用在[《白话容器基础（三）：深入理解容器镜像》](https://time.geekbang.org/column/article/17921)中讲过的方法，查看这些新增的层在AuFS 路径下对应的文件和目录了。**接下来，我使用这个镜像，通过 docker run 命令启动容器：**    $ docker run -p 4000:80 helloworld在这一句命令中，镜像名 helloworld 后面，我什么都不用写，因为在Dockerfile 中已经指定了 CMD。否则，我就得把进程的启动命令加在后面：    $ docker run -p 4000:80 helloworld python app.py容器启动之后，我可以使用 docker ps 命令看到：    $ docker psCONTAINER ID        IMAGE               COMMAND             CREATED4ddf4638572d        helloworld       "python app.py"     10 seconds ago同时，我已经通过 -p 4000:80 告诉了 Docker，请把容器内的 80端口映射在宿主机的 4000 端口上。这样做的目的是，只要访问宿主机的 4000端口，我就可以看到容器里应用返回的结果：    $ curl http://localhost:4000Hello World!Hostname: 4ddf4638572d否则，我就得先用 docker inspect 命令查看容器的 IP地址，然后访问"http://\:80"才可以看到容器内应用的返回。至此，我已经使用容器完成了一个应用的开发与测试，如果现在想要把这个容器的镜像上传到DockerHub 上分享给更多的人，我要怎么做呢？为了能够上传镜像，**我首先需要注册一个 Docker Hub 账号，然后使用 dockerlogin 命令登录**。接下来，我要**用 docker tag 命令给容器镜像起一个完整的名字**：    $ docker tag helloworld geektime/helloworld:v1> 注意：你自己做实验时，请将 \"geektime\" 替换成你自己的 Docker Hub> 账户名称，比如 zhangsan/helloworld:v1其中，geektime 是我在 Docker Hub上的用户名，它的"学名"叫镜像仓库（Repository）；"/"后面的 helloworld是这个镜像的名字，而"v1"则是我给这个镜像分配的版本号。**然后，我执行 docker push：**    $ docker push geektime/helloworld:v1这样，我就可以把这个镜像上传到 Docker Hub 上了。此外，我还可以使用 docker commit指令，把一个正在运行的容器，直接提交为一个镜像。一般来说，需要这么操作原因是：这个容器运行起来后，我又在里面做了一些操作，并且要把操作结果保存到镜像里，比如：    $ docker exec -it 4ddf4638572d /bin/sh