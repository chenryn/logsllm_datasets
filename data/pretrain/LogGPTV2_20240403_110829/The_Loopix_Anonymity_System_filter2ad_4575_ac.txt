originates and ends in a mix server (shown as the lower
four green arrows in Figure 1). In Section 4 we exam-
ine how these loops and the drop cover messages help
protect against passive and active attacks.
Processing messages. Upon receiving a packet, each
node, i.e., each mix and provider, performs the opera-
tion of processing the Sphinx packet. While processing
the packet, the server recomputes the shared secret and
checks the MAC’s correctness. If this integrity test fails,
the packet is dropped. Otherwise, the unwrapping func-
tion returns the replay detection tag and the vector of
routing commands, as well the new packet. The vector
of routing commands includes, among others, the rout-
ing ﬂag, the address of the next hop and the delay. After
unwrapping the packet, the node checks whether the re-
turned replay detection tag has been already seen and if
so, drops the packet. This allows for detection and pro-
tection against replay attacks. Otherwise, the node saves
the tag in a data structure that stores previously observed
tags. Next, it checks whether the routing ﬂag is set to
Relay or Dest. The Dest ﬂag means that the received
message is a loop message transferred back to the node.
In the case of the Relay ﬂag, we consider two scenarios
depending on whether the processing node is a mix or a
provider. In the case of a mix, the decrypted new packet
is send to the next hop, speciﬁed by address, after the de-
lay has elapsed. In the case of a provider, the new packet
is either forwarded as before or saved in the inbox of one
of the provider’s clients speciﬁed by the address.
Message storing and retrieving. Providers do not for-
ward the incoming mix packets to users but instead
buffer them in clients’ inboxes. Users, when online, poll
providers or register their online status to download a
ﬁxed subset of stored messages, allowing for the recep-
tion of the off-line messages. Recall that cover loops are
generated by users and traverse through the network and
come back to the sender. Cover loops serve as a cover
set of outgoing and incoming real messages. Whenever
a user requests messages, their provider responds with a
constant number of messages, which includes their cover
loop messages and real messages. If the inbox of a par-
ticular user contains fewer messages than this constant
number, the provider generates and sends dummy mes-
sages to the sender up to that number.
3.3 The Poisson Mix Strategy
Loopix leverages cover trafﬁc to resist trafﬁc analysis
while still achieving low- to mid-latency. To this end
Loopix employs a mixing strategy that we call a Pois-
son Mix, to foil observers from learning about the cor-
respondences between input and output messages. The
Poisson Mix is a simpliﬁcation of the Stop-and-go mix
strategy [29]. A similar strategy has been used to model
trafﬁc in onion routing servers [12]. In contrast, recall
that in Loopix each message is source routed through an
independent route in the network.
The Poisson Mix functions as follows: mix servers lis-
ten for the incoming mix packets and received messages
are checked for duplication and decoded using the mix
1204    26th USENIX Security Symposium
USENIX Association
Event i− 1
Event i + 1
Pool i− 1
Pool i
Pool i + 1
Event i
Event i + 2
Figure 3: The Poisson Mix strategy mapped to a Pool mix
strategy. Each single message sending or receiving event leads
to a new pool of messages that are exchangeable and indistin-
guishable with respect to their departure times.
node’s private keys. The detected duplicates are dropped.
Next, the mix node extracts a subsequent mix packet.
Decoded mix packets are not forwarded immediately,
but each of them is delayed according to a source pre-
determined delay di. Honest clients chose these delays,
independently for each hop, from an exponential distri-
bution with a parameter µ that is assumed to be public
and the same for all mix nodes. This parameter deter-
mines how long the message is queued in the mix. Thus,
the end-to-end latency of the messages depends on the
selected parameter µ.
Mathematical model of a Poisson Mix. Honest
clients and mixes generate drop cover trafﬁc, loop traf-
ﬁc, and messaging trafﬁc following a Poisson process.
Aggregating Poisson processes results in a Poisson pro-
cess with the sum of their rates, therefore we may model
the streams of trafﬁc received by a Poisson mix as a Pois-
son process. It is the superposition of trafﬁc streams from
multiple clients. It has a rate λn depending on the number
of clients and the number of mix nodes.
Since this input process is a Poisson process and each
message is independently delayed using an exponential
distribution with parameter µ, the Poisson Mix may be
modeled as an M/M/∞ queuing system – for which we
have a number of well known theorems [5]. We know
that output stream of messages is also a Poisson process
with the parameter λn as the the input process. We can
also derive the distribution of the number of messages
within a Poisson Mix in a steady state [34]. By the steady
state we mean the state of the system in which all entities
have already generated and processed messages for some
reasonable period of time. By the convergence of the sys-
tem to the equilibrium, this guarantees that the observed
trafﬁc closely follows the assumed distribution.
Lemma 1. The mean number of messages in the Poisson
Mix with input Poisson process Pois(λ ) and exponential
delay parameter µ at a steady state follows the Poisson
distribution Pois (λ /µ).
These characteristics, which give the Poisson Mix its
name, allow us to calculate the mean number of mes-
sages perfectly mixed together at any time, as well as the
probability that the number of messages falls below or
above certain thresholds.
The Poisson Mix, under the assumption that it approx-
imates an M/M/∞ queue is a stochastic variant of a pool
mixing strategy [42]. Conceptually, every message sent
or received leads to a pool within which messages are
indistinguishable due to the memoryless property of the
exponential delay distribution.
Lemma 2 (Memoryless property [34]). For an exponen-
tial random variable X with parameter µ holds Pr[X >
s +t|X > t] = Pr[X > s].
Intuitively, any two messages in the same pool are
emitted next with equal probability – no matter how long
they have been waiting. As illustrated in Figure 3, the
receiving event i− 1 leads to a pool of messages i− 1,
until the sending event i. From the perspective of the ad-
versary observing all inputs and outputs, all messages in
the pool i−1 are indistinguishable from each other. Only
the presence of those messages in the pool is necessary to
characterize the hidden state of the mix (not their delay
so far). Relating the Poisson mix to a pool mix allows
us to compute easily and exactly both the entropy metric
for the anonymity it provides [40] within a trace (used in
Section 4.1.3). It also allows us to compute the likelihood
that an emitted message was any speciﬁc input message
used in our security evaluation.
Synchronous variant of Loopix. While Loopix oper-
ates asynchronously by design, we now consider a syn-
chronous Loopix variant that operates in discrete rounds
and thus cannot use the exponential mixing strategy,
where delays attached to the packets are drawn from a
continuous distribution. However, note that in a sin-
gle round of the synchronous system the mixes gather
packets - thus creating pools of packets - which are then
ﬂushed following the mixing strategy. All the messages
gathered in the pool during a single round are indistin-
guishable from each other. Hence, since we have shown
earlier that the Poisson mix can be modeled as a pool
mix, the security analysis of mixing we present next can
be applied both in the asynchronous and synchronous de-
sign.
4 Analysis of Loopix security properties
In this section we present the analytical and experimental
evaluation of the security of Loopix and argue its resis-
tance to trafﬁc analysis and active attacks.
USENIX Association
26th USENIX Security Symposium    1205
4.1 Passive attack resistance
4.1.1 Message Indistinguishability
Loopix relies on the Sphinx packet format [16] to provide
bitwise unlinkability of incoming and outgoing messages
from a mix server; it does not leak information about the
number of hops a single message has traversed or the
total path length; and it is resistant to tagging attacks.
For Loopix, we make minor modiﬁcations to Sphinx
to allow auxiliary meta-information to be passed to dif-
ferent mix servers. Since all the auxiliary information is
encapsulated into the header of the packet in the same
manner as any meta-information was encapsulated in the
Sphinx design, the security properties are unchanged. An
external adversary and a corrupt intermediate mix node
or a corrupt provider will not be able to distinguish real
messages from cover messages of any type. Thus, the
GPA observing the network cannot infer any information
about the type of the transmitted messages, and interme-
diate nodes cannot distinguish real messages, drop cover
messages or loops of clients and other nodes from each
other. Providers are able to distinguish drop cover mes-
sage destined for them from other messages, since they
learn the drop ﬂag attached in the header of the packet.
Each mix node learns the delay chosen by clients for this
particular mix node, but all delays are chosen indepen-
dently from each other.
4.1.2 Client-Provider unobservability
In this section, we argue the sender and receiver un-
observability against different adversaries in our threat
model. Users emit payload messages following a Pois-
son distribution with parameter λP. All messages sched-
uled for sending by the user are placed within a ﬁrst-in-
ﬁrst-out buffer. According to a Poisson process, a sin-
gle message is popped out of the buffer and sent, or a
drop cover message is sent in case the buffer is empty.
Thus, from an adversarial perspective, there is always
trafﬁc emitted modeled by Pois (λP). Since clients send
also streams of cover trafﬁc messages with rates λL for
loops and λD for drop cover messages, the trafﬁc sent by
the client follows Pois (λP + λL + λD). Thus, we achieve
perfect sender unobservability, since the adversary can-
not tell whether a genuine message or a drop cover mes-
sage is sent.
When clients query providers for received messages,
the providers always send a constant number of messages
to the client. If the number of messages in client’s inbox
is smaller than a constant threshold, the provider gen-
erates additional dummy messages. Thus, the adversary
observing the client-provider connection, as presented on
Figure 4, cannot learn how many messages were in the
user’s inbox. Note that, as long as the providers are hon-
Inbox I
Inbox II
Inbox III
Figure 4: Provider stores messages destined for assigned
clients in a particular inbox. When users pull messages from
the mix node, the provider generates cover messages to guar-
antee that the adversary cannot learn how many messages are
in the users inbox. The messages from the inbox and dummies
are indistinguishable.
est, the protection and receiver unobservability is perfect
and the adversary cannot learn any information about the
inbox and outbox of any client.
Corrupt providers: We distinguish the sender’s and
recipient’s providers by calling them the ingress and
egress providers respectively. If the ingress provider is
compromised, all security properties of the Loopix sys-
tem are still preserved, since the ingress provider ob-
serves a rate of trafﬁc shaped by the Poisson distribution
coming from the client and cannot distinguish whether
the received packets carry real, loop or drop messages.
If the egress provider is malicious it can reveal to the
adversary whether a particular client is receiving mes-
sages or not since the provider is responsible for man-
aging the clients’ inboxes. However, even an egress
provider is still uncertain whether a received message is
genuine or the result of a client loop – this cannot be
determined from their bit pattern alone. Further statis-
tical attacks may be possible, and we leave quantifying
the exact information leakage against this threat model
as future work. Thus, Loopix does not guarantee perfect
receiver unobservability in the presence of a corrupted
egress provider.
4.1.3 Poisson mix security
We ﬁrst show that a single honest Poisson mix provides a
measure of sender-receiver unlinkability. From the prop-
erties of Poisson mix, we know that the number of mes-
sages in the mix server at a steady state depends on the
ratio of the incoming trafﬁc (λ ) and the delay parameter
(µ) (from Section 3.3). The number of messages in each
mix node at any time will on average be λ
µ . However, an
adversary observing the messages ﬂowing into and out
of a single mix node could estimate the exact number of
1206    26th USENIX Security Symposium
USENIX Association
messages within a mix with better accuracy – hindered
only by the mix loop cover trafﬁc.
We ﬁrst consider, conservatively, the case where a mix
node is not generating any loops and the adversary can
count the exact number of messages in the mix. Let us
deﬁne on,k,l as an adversary A observing a mix in which
n messages arrive and are mixed together. The adversary
then observes an outgoing set of n− k messages and can
infer that there are now k < n messages in the mix. Next,
l additional messages arrive at the mix before any mes-
sage leaves, and the pool now mixes k + l messages. The
adversary then observes exactly one outgoing message
m and tries to correlate it with any of the n + l messages
which she has observed arriving at the mix node.
The following lemma is based on the memoryless
property of the Poisson mix. It provides an upper bound
on the probability that the adversary A correctly links the
outgoing message m with one of the previously observed
arrivals in observation on,k,l.
Theorem 1. Let m1 be any of the initial n messages in
the mix node in scenario on,k,l, and let m2 be any of the l
messages that arrive later. Then
Pr(m = m1) =
Pr(m = m2) =
,
k
n(l + k)
1
l + k
.
(1)
(2)
Note that the last l messages that arrived at the mix
node have equal probabilities of being the outgoing mes-
sage m, independently of their arrival times. Thus, the
arrival and departure times of the messages cannot be
correlated, and the adversary learns no additional infor-
1
mation by observing the timings. Note that
l+k is an
upper bound on the probability that the adversary A cor-
rectly links the outgoing message to an incoming mes-
sage. Thus, continuous observation of a Poisson mix
leaks no additional information other than the number
of messages present in the mix. We leverage those re-
sults for a single Poisson Mix to simulate the information
propagated withing a the whole network observed by the
adversary (c.f. Section 4.3).
We quantify the anonymity of messages in the mix
node empirically, using an information theory based met-
ric introduced in [40, 18]. We record the trafﬁc ﬂow
for a single mix node and compute the distribution of
probabilities that the outgoing message is the adversary’s
target message. Given this distribution we compute the
value of Shannon entropy (see Appendix A), a measure
of unlinkability of incoming to outgoing messages. We