images, sound, and more. For example, let’s say you’re creating a video game. Video
games require a plethora of resources to function, and these need to be bundled
together with the game’s executable. A package offers a convenient way to bundle
such files together with the software.
 In the simplest sense, a minimal Nimble package is a directory containing a .nimble
file and one or more Nim modules.
Available
commands
Command
params
Command
information
Nimble
command
syntax
Figure 5.3
Some commands that Nimble supports
Licensed to   
132
CHAPTER 5
Package management
A .nimble file contains metadata about a package. It specifies a package’s name, ver-
sion, author, dependencies, and more. The .nimble part is just a file extension, and the
filename of every .nimble file is the same as the name of the package. The following
listing shows a simple example of a .nimble file.
# Package information
version
= "0.1.0"
author
= "Andreas Rumpf, Dominik Picheta"
description
= "Example .nimble file."
license
= "MIT"
# Dependencies
requires "nim >= 0.12.0"
The .nimble files use a Nim-based format that supports a subset of Nim’s features. In
addition, the format contains some shortcuts for defining information about the pack-
age. You can freely define variables, procedures, and more within your .nimble files,
and you can even import other modules into them.
Listing 5.1
MyPkg.nimble
Package
metadata
Versions of this package
that can be installed.
Only shown with --ver flag.
Package 
name
The URL and type 
of the repository 
storing this
package
Figure 5.4
Searching for a “linux” package with version information
The name of the package is not specified here; 
instead, the filename of the .nimble file is used.
Version strings usually consist of three 
digits separated by periods, and they 
follow the semantic versioning specification 
available at http://semver.org. You can 
specify as many digits as you want, but 
other characters aren’t supported.
Identifies one or 
more authors who 
created this package
Specifies that the package requires at 
least version 0.12.0 of the Nim 
compiler to be successfully compiled
Licensed to   
133
What is a Nimble package?
 Nimble also supports the definition of tasks, as follows:
task test, "Run the packages tests!":
exec "nim c -r tests/mytest.nim"
Placing this snippet of code at the end of your .nimble file will allow you to execute
nimble test to run your package’s tests.
 Figure 5.5 shows what the contents of a typical standalone Nimble package look
like. The data specified in this MyPkg.nimble file is mandatory, and there are many
other options you can specify in a .nimble file as well. I can’t list them all here, but
you’ll learn about some of them later in this chapter. For a full list, check out the Nim-
ble documentation on GitHub: https://github.com/nim-lang/nimble#readme.
Assuming you have a Nimble package somewhere on your local filesystem, you can
easily open a terminal in the directory of that package and execute nimble install.
When you do this, Nimble will attempt to install the package contained in the current
directory. This is useful for local packages that you’ve created yourself. But what about
packages that have been created by other developers? Do you need to download these
manually?
 Thankfully, the answer to that question is no. As part of the install command, a
URL can be specified that points to the package you want to install. Currently, this URL
must point to either a Git or Mercurial repository, which brings us to the definition of
an external package: one that can be accessed over the internet. An external Nimble
package is either a Git or Mercurial repository containing a .nimble file and one or
more Nim modules.
MyPkg.nimble
src/mypkg.nim
...
Package name: MyPkg
Version: 0.1.0
Author: Dominik Picheta
Description: ...
License: MIT
Dependencies:
             Nim >= 0.12.0
Figure 5.5
A typical Nimble 
package
What are Git and Mercurial?
Git and Mercurial are examples of distributed version control systems (DVCSs). A
DVCS enables a team of software developers to work together on a software project,
and by keeping track of the history of each file, it helps deal with situations where
two or more developers end up editing the same files.
Licensed to   
134
CHAPTER 5
Package management
Git and Mercurial repositories may contain additional information, such as tags.
Repositories containing Nimble packages must contain a tag that identifies each ver-
sion of that package. Figure 5.6 shows how an external Nimble package’s content can
change between revisions.
In the previous section, I showed you how the search command works. With the
--ver flag, the search command lists the tags of each of the package repositories.
Nimble interprets each tag as a version.
 Nimble packages are coupled to repositories because most libraries and applica-
tions are already stored in repositories. Turning a repository into a Nimble package is
easy—the repository just needs a .nimble file. Other package managers store their
packages on a single centralized server, which has its advantages; this is something
that Nimble will eventually also support. 
(continued)
A repository is where the history of a software project is stored. These repositories
can be uploaded to a remote server and then subsequently downloaded using the
git or hg command-line tools, for Git and Mercurial, respectively. This allows other
developers to work on the project and upload their changes, which you can then
download.
After a repository is downloaded, the histories of the files can be explored. You can,
for example, see what the state of the repository was a week ago, or back when the
repository was first created.
Package name: MyPkg 
Version: 0.1.1 
...
https://github.com/dom96/MyPkg.git
HEAD
v0.1.0
77fff838c
ef889a10a
6c6d39d56
c6b4d0e5c
405b86068
MyPkg.nimble
Package name: MyPkg 
Version: 0.1.0 
...
MyPkg.nimble
Commit
tag
Commit
hash
Reference to the
latest commit in the
current branch
The Nimble package’s 
version is updated in the 
.nimble file. It can change 
together with the package’s 
source files between commits.
Figure 5.6
An external Nimble package’s evolution
Licensed to   
135
Installing Nimble packages
5.5
Installing Nimble packages
The installation of Nimble packages is likely the most common task that you’ll use
Nimble for. You saw an example of the install command in the previous section.
This command is the primary means of installing packages.
5.5.1
Using the install command
The install command is powerful. It can do any of the following:
 Install packages on your local filesystem
 Install packages from a specified URL
 Install a package by name
 Install a specific version of a package
 Install multiple packages at once
Installing local packages is simple. Just open a new terminal, cd into the directory
of your local package (by typing cd /home/user/MyPkg, for example), and execute
nimble install.
 To install a package from a URL, open a new terminal and execute nimble
install , replacing the  with the URL of the pack-
age you want to install. Currently, the URL must point to a non-empty Git or Mercurial
repository.
 Nimble saves you the trouble of remembering a bunch of URLs for different pack-
ages. A package repository that contains a listing of packages created by the Nim com-
munity is available. Nimble downloads this listing, which contains some basic
information about each package, such as the package’s URL and name. Remember
the search command? It searches through this listing, so any of the packages listed in
your search results can be installed by specifying their names after the install com-
mand. For example, to install the daemonize package seen in the search results in fig-
ure 5.4, execute nimble install daemonize.
 A specific version of a package can be installed by using the special @ character
after the name of a package. For example, to install version 0.0.1 of the daemonize
package, execute nimble install daemonize@0.0.1. Alternatively, instead of a spe-
cific version, you can specify a version range. For example, if you want to install the lat-
est version that’s greater than version 0.0.1, you can execute nimble install
daemonize@>=0.0.1. Specifying a repository revision is also supported by using the #
character after the @ character, such as nimble install daemonize@#b4be443.
WARNING: SPECIAL CHARACTERS IN SHELLS
Depending on your shell, some of
the characters, such as @, >, or =, may be treated as part of the shell’s syntax.
You may need to escape them or quote the package name and version like so:
nimble install "daemonize@>=0.1.0".
Specifying multiple parameters to the install command will cause Nimble to install
more than one package. The parameters just need to be separated by a space. 
Licensed to   
136
CHAPTER 5
Package management
5.5.2
How does the install command work?
To learn about what the install command does, let’s look at the previous example
command: nimble install daemonize. Try executing it now if you haven’t already.
You should see output similar to that in figure 5.7.
Nimble’s output is currently rather verbose, but it tries to give as much information
about the installation as possible. The output that you see in your version of Nimble
may be a bit different from figure 5.7, but the key information should remain the
same. The messages shown in figure 5.7 show each of the files from the daemonize
package being copied into /Users/dom/.nimble/pkgs/daemonize-0.0.2/.
 Scroll up in your terminal window, and you’ll see what Nimble does first: it begins
downloading the package. But before that, Nimble needs to know where to download
the daemonize package from, and it determines this by consulting the package list.
Figure 5.8 shows the full installation process and its many subprocesses.
 The package list is currently hosted in a Git repository, and it can be accessed on
GitHub at the following URL: https://github.com/nim-lang/packages. The package-list
repository stores a packages.json file that lists metadata for different packages, including
each package’s name, URL, description, and more. Nimble can read this list, find the
package you specified on the command line, and retrieve that package’s URL. That way
Nimble can determine the location of that package’s repository and can easily download
it. Figure 5.9 shows how the daemonize package is found in the packages.json file.
Shows the files that
are being installed as
part of the package.
This wouldn’t be 
shown without the 
--verbose flag.
Installation
status message
The --verbose flag
is necessary to show
the additional
status message.
Destination
filename
The filename
being copied
Figure 5.7
The output of nimble install daemonize
Licensed to   
137
Installing Nimble packages
$ nimble install daemonize 
https://github.com/rgv151/daemonize.nim 
Find download URL
and repo type for
daemonize package
Download the
repository
$ git clone https://github.com/rgv151/daemonize.nim 
Find .nimble ﬁle.
Parse it. 
Verify version requirements.
Check dependencies.
If dependencies
are not installed,
install them.
daemonize
daemonize.nim
daemonize.nimble
~/.nimble/pkgs/daemonize-0.2.0
daemonize.nim
daemonize.nimble
Copy
Copy
...
...
Copy ﬁles in package directory to installation directory 
$ nimble install  
Figure 5.8
The Nimble installation process
$ nimble install daemonize 
packages.json  
...
{
  "name": "daemonize",
  "url": "https://github.com/rgv151/daemonize.nim", 
  "method": "git",
  "tags": ["daemonize", "background", "linux"],
  "description": "This library makes your code run  
                  as a daemon process on Unix-like systems", 
  "license": "MIT",
  "web": "https://github.com/rgv151/daemonize.nim" 
}, 
...
"url": "https://github.com/rgv151/daemonize.nim"
"method": "git"
https://github.com/rgv151/daemonize.nim (git)
Find download URL
and repo type for
daemonize package
Figure 5.9
Finding information about the daemonize package in the packages.json file
Licensed to   
138
CHAPTER 5
Package management
PACKAGE LISTS
The package list stored in https://github.com/nim-lang/ pack-
ages is the official Nimble package list. As of version 0.7.0, Nimble supports
multiple package lists, so you can easily create and use your own package list
in conjunction with the official one. The “Configuration” section of the Nim-
ble readme explains how this can be done: https://github.com/nim-
lang/nimble#configuration.
The download is done using either Git or Mercurial. As part of the download process,
Nimble parses the tags on the remote repository and determines which satisfies the
version requirements specified by the user. If more than one tag satisfies the version
requirements, it picks the highest version. Figure 5.10 shows how Nimble decides
which commit of a Nimble package to install.
Once the download is complete, the package’s .nimble file is read, and Nimble verifies
the validity of this file. Before installation can commence, the following must be
checked:
 The version field specified in the .nimble file must correspond to the version
that was tagged on the repository.
 The files that will be installed must follow a specific directory layout.
 The correct dependencies specified in the .nimble file must be installed.
Those are some of the most common checks that Nimble performs. If the first two fail,
they’ll result in an error and the package won’t be installed. Missing dependencies will
be installed automatically by Nimble. You’ll learn more about these checks in the next
section, where I’ll show you how to create your own Nimble package.
 Once the package is successfully validated, the installation commences, and Nim-
ble copies all the files in the package to ~/.nimble/pkgs/pkg-ver, where ver is the ver-
sion of the package and pkg is the name of the package.
HEAD
v0.1.0
77fff838c
ef889a10a
6c6d39d56
c6b4d0e5c
405b86068
$ nimble install pkg
v0.2.0
pkg
HEAD
v0.1.0
77fff838c
ef889a10a
6c6d39d56
c6b4d0e5c
405b86068
$ nimble install pkg@#head
pkg
v0.2.0
Reference 
explicitly 
selected
Latest commit, but
latest tagged version
takes precedence
Not latest
tagged version
Latest
tagged version
Figure 5.10
How Nimble decides which version of a package to install
Licensed to   
139
Creating a Nimble package
 That’s a simple overview of the process involved in installing a Nimble package.
This process can become more complicated depending on the options specified in
the .nimble file. 
5.6
Creating a Nimble package
You’ve likely encountered situations where some functionality in your application
could be reused in another application. For example, in chapter 3, you developed a
protocol module that defines procedures for encoding and decoding chat messages.
You might want that module to be usable in other applications.
 The easiest way to do so is to create a package out of that module. Your applica-
tions can then add that package as a dependency and use the same module easily.
 Creating a Nimble package out of your Nim library or application has a number of
advantages, such as making the installation of dependencies much easier and allowing
others to use your package as a dependency for their own packages.
 Creating a Nimble package is also fairly straightforward. All you need to do is cre-
ate a .nimble file and you’re good to go. Nimble’s init command makes the creation
of this file easy. The command will ask you some questions about the package and will
create a .nimble file based on your responses. You’ll likely still need to edit the result-
ing .nimble file manually to customize the options further, but once you understand
what those options do, that’s fairly straightforward.
 Once you’ve created a local Nimble package, you might also want to open source it
and publish it in Nimble’s package list. To do this, you’ll need to initialize a new Git or
Mercurial repository. Later in this chapter, I’ll show you how a Nimble package can be
published.
 Let’s create a simple Nimble package.
5.6.1
Choosing a name
A package’s name is very important. It needs to be as short as possible and ideally
should describe what functionality the package implements.
PACKAGE NAME UNIQUENESS
When picking a package name, it’s a good idea
to ensure that it’s unique, especially if you intend to publish it to the Nimble
package repository.
You must pick a name that doesn’t contain any hyphens or at symbols (- or @). Those
characters are treated uniquely by Nimble, so they’re disallowed in package names.
 The package that you’ll create as part of this chapter will implement some very sim-
ple procedures for manipulating numbers. You can choose whatever package name
you wish, but throughout this chapter I’ll use the name NimbleExample. If you choose
a different name, you’ll need to adjust the chapter’s example code accordingly.
 To get started, create a NimbleExample directory somewhere on your filesystem. It
will contain the Nimble package. 
Licensed to   
140
CHAPTER 5
Package management
5.6.2
A Nimble package’s directory layout
All Nimble packages must adhere to a specific directory
layout. This layout is more important for libraries than
applications because an application will be compiled,
and in most cases all that needs to be installed will be
the application’s executable.
 For libraries, the most important rule is to place all
modules in a separate directory named after the package.
So you need to create another NimbleExample directory
inside the NimbleExample directory you’ve already cre-
ated. Any modules placed inside that directory will be
importable with the NimbleExample/ prefix, like this: