characters that were encrypted with the same single-byte key ˆKi.
170
C. Wressnegger, F. Boldewin, and K. Rieck
y
c
n
e
u
q
e
r
F
0.20
0.15
0.10
0.05
0.00
English
y
c
n
e
u
q
e
r
F
0.20
0.15
0.10
0.05
0.00
Byte Value
Windows PE
Byte Value
(a) Distribution of English text
(b) Distribution of PE ﬁles
Fig. 3. The byte frequency distributions of English text and Windows PE ﬁles
Although eﬀective in decrypting natural language text, key recovery using
frequency analysis is not suitable for deobfuscating embedded malware. If the
obfuscated code corresponds to regular PE ﬁles, the byte frequencies are almost
equally distributed and can hardly be discriminated, because executable code,
header information and other types of data are mixed in this format. As an
example, Figure 3 shows the byte frequency distributions of English text and PE
ﬁles, where except for a peak at \x00 the distribution of PE ﬁles is basically ﬂat.
The presented ciphertext-only attacks thus only provide means for determining
the key length of Vigen`ere-based obfuscation, but without further reﬁnements
are not appropriate for actually recovering the key.
2.4 Probable-Plaintext Attacks
To eﬀectively determine the key used in a Vigen`ere-based obfuscation, we con-
sider classic attacks based on known and probable plaintexts. We refer to these
attacks as probable-plaintext attacks, as we cannot guarantee that a certain plain-
text is indeed contained in an obfuscated malware binary.
Key Elimination. In particular, we consider the well-known technique of key
elimination. The idea of this technique is to determine a relation between the
plaintext and ciphertext that does not involve the key: Namely, the diﬀerence
of bytes that are encrypted with the same part of the key. Formally, for a key
byte ˆKi this diﬀerence can be expressed using the inverse operation ◦−1 as:
Ci ◦−1 Ci+l = (Mi ◦ ˆKi) ◦−1 (Mi+l ◦ ˆKi) = Mi ◦−1 Mi+l.
Note that this relation of diﬀerences only applies if the operator used for the Vi-
gen`ere cipher induces a commutative group. For example, if we plug in the pop-
ular instructions XOR and ADD from Table 1, the diﬀerence of the obfuscated
bytes Ci and Ci+l allows to reason about the diﬀerence of the corresponding
plaintext bytes:
Ci ⊕ Ci+l = (Mi ⊕ ˆKi) ⊕ (Mi+l ⊕ ˆKi) = Mi ⊕ Mi+l
Ci − Ci+l = (Mi + ˆKi) − (Mi+l + ˆKi) = Mi − Mi+l.
Based on this observation, we can implement an eﬃcient probable-plaintext
attack against Vigen`ere ciphers. Given a plaintext P = P1 . . . Pm, we introduce
Deobfuscating Embedded Malware Using Probable-Plaintext Attacks
171
the diﬀerence streams ΔP and ΔC. If the diﬀerence streams match at a speciﬁc
position and the plaintext P is suﬃciently large, we have successfully determined
the occurrence of a plaintext in the obfuscated data. In particular, we compute
the diﬀerence stream
ΔP = (P1 ◦−1 P1+l) . . . (Pm−l ◦−1 Pm)
for the plaintext P and compare it against each position i of the ciphertext C
using the corresponding stream
ΔC = (Ci ◦−1 Ci+l) . . . (Ci+m−l ◦−1 Ci+m).
Using this technique, we can eﬃciently search for probable plaintexts in data
obfuscated using a Vigen`ere cipher without knowing the key. This enables us to
check for common strings in the obfuscated code, such as header information,
API functions and code stubs. Once the position of a probable plaintext is found
it is possible to derive the used key by applying the appropriate inverse operation:
Kj = Ci+j ◦−1 Pi+j with i being the position where the diﬀerence stream of a
probable plaintext matches. The more plaintexts match in the obfuscated code,
the more reliably the key can ﬁnally be determined.
3 Deobfuscating Embedded Malware
After describing attacks against Vigen`ere ciphers, we now present our method
Kandi that combines and extends these attacks for deobfuscating embedded
malware. The three basic analysis steps of Kandi are described in the following
sections and outlined in Figure 4. First, our method extracts probable plaintexts
from a representative set of code (Section 3.1). Applied to an unknown document,
it then attempts to estimate the key length (Section 3.2) and ﬁnally break any
Vigen`ere-based obfuscation if present in the ﬁle (Section 3.3).
Frequent substrings
BC
A
BC
A BC
Code
Code
Code
Code
A
Plaintexts
A
BC
Gaps between 
recurring substrings
Key 
length
DOC
S
S
DOC
(a) 
(b) 
Probable plaintexts
A
Z
BC
XY
(c) 
Key
Fig. 4. Schematic depiction of Kandi and its analysis steps: (a) Extraction of plain-
texts, (b) derivation of the key length and (c) probable-plaintext attack.
In particular, we are using the Kasiski examination for determining the
key length in step (b) and the technique of key elimination against XOR and
ADD/SUB substitutions in step (c). Additionally, we are testing each possible
transposition for ROL/ROR instructions. We consider this a legit compromise
since there exists only a few combinations to check.
172
C. Wressnegger, F. Boldewin, and K. Rieck
3.1 Extraction of Plaintexts
The deobfuscation performance of Kandi critically depends on a representative
set of probable plaintexts. In the scope of this work, we focus on Windows PE
ﬁles, as these are frequently used as initial step of an attack based on infected
documents. However, our method is not restricted to this particular type of data
and can also be applied to other representations of code from which probable
plaintexts can be easily extracted, such as DEX ﬁles and ELF objects.
In the ﬁrst step, we thus extract the most common binary strings found in
PE ﬁles distributed with oﬀ-the-shelf Windows XP and Windows 7 installations.
Proﬁtable plaintexts are, for instance, the DOS stub and its text, API strings,
library names or code patterns such as push-call sequences. To determine these
strings eﬃciently, we process the collected PE ﬁles using a suﬃx array and
extract all binary strings that appear in more than 50% of the ﬁles. Additionally,
we ﬁlter the plaintexts according to the following constraints:
– Plaintext length. In order to ensure an expressive set of probable plaintext,
we require that each plaintext is at least 4 bytes long.
– Zero bytes. As described in Section 2.2, a disadvantage of common heuris-
tics is that they are not able to deal with malware that does not obfuscate
\x00 byte regions. In order not to suﬀer from the very same drawback, we
completely exclude \x00 bytes and reject plaintexts containing them.
– Byte repetitions. We also exclude plaintexts that contain more than four
repetitions of a single byte. These might negatively inﬂuence the key elimi-
nation as described in Section 2.4.
We are well aware and acknowledge that there exist more sophisticated ways
to extract probable plaintexts. This for instance is day-to-day business of the
anti-virus industry when generating signatures for their detection engines. Also,
well-known entrypoint stubs as well as patterns from speciﬁc compilers, packers
and protectors might represent valuable probable plaintexts.
3.2 Deriving the Key Length
In the second step, Kandi uses the Kasiski examination (Section 2.3) to inspect
the raw bytes of a document—without any further parsing or processing of the
ﬁle. The big advantage of this method over the index of coincidence proposed by
Friedman [9] is that we neither need to rely on the byte distribution of the original
binary nor do we have to precisely locate the embedded malware. Furthermore,
the Kasiski examination allows us to take multiple candidates of the key length
into consideration. Depending on the amount of identical substrings that suggest
a particular key length, we construct a ranking of candidates for later analysis.
That way, it is possible to compensate for and recover from misinterpretations.
However, ﬁnding pairs of identical substrings in large amounts of data needs
careful algorithm engineering in order to work eﬃciently. We again make use
of suﬃx arrays for determining identical substrings in linear time in the length
Deobfuscating Embedded Malware Using Probable-Plaintext Attacks
173
of the analyzed document. Since the Kasiski examination only states that the
distances between identical substrings in the ciphertext refer to multiples of
the key length, it is necessary to also examine the integer factorization thereof.
Fortunately, there exists a shortcut to this factorization step that works very well
in practice: If Kandi returns a key that repeats itself, e.g. 13 37 13 37, this
indicates that we correctly derived the key but under an imprecise assumption
of the key length (l = 4 rather than 2). In such cases we simply collapse the
repeating key and correct the key length accordingly.
3.3 Breaking the Obfuscation
Equipped with an expressive set of probable plaintexts and an estimation of the
key length, it is now possible to mount a probable-plaintext attack against Vi-
gen`ere-based obfuscation. The central element of this step is the key elimination
introduced in Section 2.4. It enables us to look for probable plaintexts within the
obfuscated data and derive the used key automatically. Again, Kandi directly
operates on the raw bytes of a document and thereby avoids parsing the ﬁle.
Robust Key Recovery. If a probable plaintext is longer than the estimated
key length, the overlapping bytes can be used to reinforce our assumption about
the key. To this end, we deﬁne the overlap ratio r that is used to specify how
certain we want to be about a key candidate. The larger r is, the stricter Kandi
operates and the more reliable is the key. If we set r = 0.0, a usual match of
plaintexts is enough to support the evidence of a key candidate. This means
that we will end up with a larger amount of possibly less reliable hints. Our
experiments show that for the grand total incorrect guesses will average out and
in many cases it is possible to reliably deobfuscate embedded malware.
If a more certain decision is desired the overlap ratio r can be increased.
However, for larger values of r we require longer probable plaintexts: r = 0.0
only requires a minimal overlap, r = 0.5 already half of the probable plaintext’s
length and r = 1.0 twice the size. As an example, if the estimated key length is 4
and r = 0.5, only plaintexts of at least 6 bytes are used for the attack. Depending
on the approach chosen to gather probable plaintexts, it might happen that
the length of the available plaintexts ends up being the limiting factor for the
deobfuscation. We will evaluate this in the next section.
Incorporating ROL and ROR. Finally, in order to increase the eﬀectiveness
of Kandi, we additionally consider transpositions using ROL and ROR instruc-
tions. ROL and ROR are each others inverse function, that is, when iterating
over all possible shift oﬀsets they generate exactly the same output but in diﬀer-
ent order. Furthermore, in most implementations these instructions operate on
8 bits only such that the combined overall number of transpositions to be tested
is very small. Consequently, we simply add a ROL shift as a preprocessing step
to Kandi. Although we attempt to improve over a plain brute-force approach
for breaking obfuscation, we consider the 7 additional tests as a perfectly legit
tradeoﬀ from a pragmatic point of view.
174
C. Wressnegger, F. Boldewin, and K. Rieck
We are also well aware that it is possible to render our method less eﬀective
by making use of chaining or adding other computational elements that are not
deﬁned in the scope of Vigen`ere ciphers and therefore out of reach for Kandi. We
discuss this limitation in Section 5. Nevertheless, our evaluation shows that we
are able to deobfuscate a good deal of embedded malware in the wild, including
recent samples of targeted attack campaigns, such as MiniDuke [6]. Thereby,
Kandi proves to be of great value for day-to-day business in malware analysis.
4 Evaluation
We proceed to evaluate the deobfuscation capabilities and runtime performance
of Kandi empirically. Since it is hard to determine whether embedded malware
in the wild is actually using Vigen`ere-based obfuscation or not, we start oﬀ with
a series of controlled experiments (Section 4.1). We then continue to evaluate
Kandi on real-world malware in Word, Powerpoint and RTF documents as well
as diﬀerent image formats (Section 4.2). We need to stress that this collection
contains malware with unknown obfuscation. Nonetheless, Kandi is able to ex-
pose obfuscated malware in every fourth ﬁle, thereby empirically proving that
(a) Vigen`ere ciphers are indeed used in the wild and (b) that our method is able
to reliably reveal the malicious payload in these cases.
4.1 Controlled Experiments
To begin with, we evaluate Kandi in a controlled setting with known ground
truth, where we are able to exactly tell if a deobfuscation attempt was suc-
cessful or not. In particular, we conduct two experiments: First, we obfuscate
plain Windows PE ﬁles and apply Kandi to them. In the course of that, we
measure the runtime performance and throughput of our approach. Second, the
obfuscated PE ﬁles are embedded in benign Word documents in order to show
that Kandi not only works on completely encrypted data, but is also capable of
deobfuscating ﬁles embedded inside of documents.
Evaluation Datasets. In order to create a representative set of PE ﬁles for the
controlled experiments, we simply gather all PE ﬁles in the system directories
of Windows XP SP3 (system and system32) and Windows 7 (System32 and
SysWOW64). This includes stand-alone executables as well as libraries and drivers
and yields a total of 4,780 ﬁles. We randomly obfuscate each of the PE ﬁles with
a Vigen`ere cipher using either XOR, ADD or SUB. We draw random keys for
this obfuscation and vary the key length from 1 to 32 bytes, such that we ﬁnally
obtain 152,960 (32 × 4,780) unique obfuscated PE ﬁles.
To study the deobfuscation of embedded code, we additionally retrieve one
unique and malware-free Word document for each PE ﬁle from VirusTotal and
use it as host for the embedding. Malware appearing in the wild would be em-
bedded at positions compliant with the host’s ﬁle format. This theoretically
provides valuable information where to look for embedded malware. As Kandi
Deobfuscating Embedded Malware Using Probable-Plaintext Attacks
175
does not rely on parsing the host ﬁle, we simply inject the obfuscated PE ﬁles
at random positions. We end up with a total of 152,960 unique Word documents
each containing an obfuscated PE ﬁle.
100
80
60
40
20
t
n
e
c
r
e
p
n
i
e
t
a
r
n
o
i
t
a
c
s
u
f
b
o
e
D
Kandi (r = 0.0)
0
0
5
10
15
20
Key length
25
30
100
90
80
70
60
50
40
t
n
e
c
r
e
p