# 针对FinFisher的详细分析报告
|
##### 译文声明
本文是翻译文章，文章来源：cloudblogs.microsoft.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 一、前言
Office 365高级威胁防护（[Office 365 ATP](https://products.office.com/en-us/exchange/online-email-threat-protection?ocid=cx-blog-mmpc)）在2017年阻止了许多知名的[0day漏洞利用技术](https://cloudblogs.microsoft.com/microsoftsecure/2017/11/21/office-365-advanced-threat-protection-defense-for-corporate-networks-against-recent-office-exploit-attacks/)。在我们的分析过程中，有一个活跃的组织脱颖而出：[NEODYMIUM](https://blogs.technet.microsoft.com/mmpc/2016/12/14/twin-zero-day-attacks-promethium-and-neodymium-target-individuals-in-europe/)。这个团伙之所以引入注目，有以下两个原因：
1、可以有效利用Microsoft以及Adobe软件的复杂0day漏洞；
2、使用了政府级别的监控间谍软件，即FinFisher（也称为FinSpy），Microsoft安全产品将其标记为[Wingbird](https://www.microsoft.com/en-us/wdsi/threats/malware-encyclopedia-description?Name=Backdoor:Win32/Wingbird.A!dha)。
FinFisher是一款非常复杂的恶意软件，因此我们与其他研究人员一样，也必须设计复杂的方法才能破解它。之所以要这么做，是因为我们想理解FinFisher如何突破某主机并实现本地持久化，也想验证Office
365 ATP沙箱、Windows Defender Advanced Threat Protection（[Windows Defender
ATP](https://www.microsoft.com/en-us/windowsforbusiness/windows-atp?ocid=cx-blog-mmpc)）通用检测功能以及其他Microsoft安全解决方案的有效性。
这是一个非常艰巨的任务。FinFisher用到了各种技巧，比如花指令、“意大利面条式代码（spaghetti
code）”、多层虚拟机以及许多已知的或者鲜为人知的反调试及防护技术。安全分析人员手头上通常掌握一些工具，可以在恶意软件调查过程中解决大量类似的技术。然而，在反调试防护技术方面，FinFisher与其他恶意软件相比属于另一个级别。只有技术娴熟的逆向分析工程师，花费大量时间、使用各种代码、自动化处理技术，同时富有创造力，才能揭开FinFisher这个难题。从这方面我们可以看出，FinFisher的开发者为了保持恶意软件的隐蔽性以及复杂性付出了许多努力。
在这个研究过程中，我们掌握了FinFisher所使用的技术，可以利用这些信息使Office 365 ATP的沙箱检测能力以及Windows Defender
ATP的能力更加全面，能够检测类似技术以及通用行为。利用我们深入研究所收集的情报，Windows Defender
ATP可以告警FinFisher在攻击链条不同阶段所使用的恶意行为（比如通过内存注入实现本地持久化）。Windows Defender
ATP中的[机器学习](https://cloudblogs.microsoft.com/microsoftsecure/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/)功能可以进一步标记出篡改合法Windows文件的可疑行为。
图1. Windows Defender ATP通用检测规则可以告警FinFisher相关行为
虽然我们的分析结果可以第一时间保护我们的客户，但我们更希望能够分享自己的成果，加入其他研究人员（下文会详细列出）公开的研究成果中。我们希望这篇博客能帮助其他研究人员理解并分析FinFisher样本，也希望这种行业内的信息共享能够帮助更多的客户。
## 二、意大利面条式代码以及垃圾代码
分析FinFisher时，我们碰到的一个代码混淆问题就是要移除恶意软件中的垃圾代码以及“意大利面条式代码”（一种用来迷惑反汇编程序的技术）。意大利面条式代码添加了连续的代码跳转，使恶意软件的程序流很难阅读，这也是这种代码名字的来源。FinFisher中的意大利面条式代码样例如下所示：
图2. FinFisher释放器中的意大利面条式代码
这种方法并不新奇，在许多情况下，已经有一些逆向插件能够解决这个问题。然而对于FinFisher而言，我们无法找到可以规范化代码流的现有的任何交互式反汇编器（IDA）插件。因此我们决定使用IDA
Python自己编写插件。装配这段代码后，我们可以剔除FinFisher所采用的第一个反分析保护层。
剔除垃圾指令后，我们看到了一段可读的代码块。这段代码首先分配了两个内存块：一个1MB全局缓冲区以及每个线程所对应的一个64KB缓冲区。第一个大缓冲区用作多个并发线程的索引。恶意软件从自身PE文件中提取了一大块数据，然后使用自定义的XOR（异或）算法两次解密这个数据块。我们发现这部分数据中包含一组操作码（opcode）指令，可由FinFisher开发者定制的虚拟机程序（下文简称为“VM”）进行解释。
图3. FinFisher所使用的多层保护机制
## 三、Stage 0—采用自定义虚拟机的释放器
主释放器（dropper）中实现了一个VM调度器（dispatcher）循环，可以使用32个不同的操作码（opcode）处理函数。恶意软件将64KB缓冲区用作VM描述符（descriptor）数据结构，可以存放数据以及需要运行的JIT（just-in-time）代码。VM调度器循环例程会在结尾处通过一条JMP指令跳转到另一个例程。程序中总共有32个不同的例程，每个例程实现了不同的操作码以及某些基本的功能，恶意程序可能会用到这些代码及功能。
图4. 处理每个VM操作码以及相关解释器的代码片段
这些VM以及虚拟化指令块可以用更加简单的术语来描述，也就是说：FinFisher的开发者实际上插入了一层动态代码转换（虚拟机）机制，使采用常规工具的分析方法基本不可能完成任务，而类似IDA之类的静态分析工具在分析通过VM以及一套新的指令集所解释和执行的自定义代码时可能也帮助不大。从另一方面来看，动态分析工具（如调试器以及沙箱）可能会面临虚拟化代码中隐藏的反调试以及反分析技巧，当代码检测到沙箱环境时会改变恶意软件的行为。
在这个阶段，我们只能手动调查各个代码块以及操作码处理程序（这些都经过高度混淆处理，也用到了意大利面条式代码）才能进一步分析下去。我们再一次使用了自己的去混淆工具，配合上一些技巧后，我们可以逆向分析这些操作码，将其映射到一个列表中，后续分析过程中可以利用该列表，配合一些脚本来实现自动化分析处理。
这个自定义VM所生成的操作码指令可以分为如下几个不同的类别：
1、逻辑操作码，实现了位逻辑运算符（OR、AND、NOT以及XOR）以及算术运算符；
2、条件分支操作码，实现了基于条件的代码分支（等同于JC、JE、JZ以及其他类似的分支操作码）；
3、加载/存储操作码，可以写入或者读取进程虚拟地址空间的特定地址。
4、用于各种用途的特定操作码，比如执行未经虚拟化处理的特定的机器指令。
我们公布了在分析过程中收集到的FinFisher VM所使用的完整版操作码列表（希望已经分析完整），将其集成到我们的去虚拟化脚本中，完整列表如下：
**序号** | **等效符号** | **功能描述**  
---|---|---  
0x0 | EXEC | 执行机器码  
0x1 | JG | 大于/大于或等于则跳转  
0x2 | WRITE | 将某个值写入解除引用的内部VM值（相当于一个指针）  
0x3 | JNO | 不溢出则跳转  
0x4 | JLE | 小于或等于则跳转  
0x5 | MOV | 将寄存器的值移动到VM 描述符（与0x1F操作码一样）  
0x6 | JO | 溢出则跳转  
0x7 | PUSH | 将内部VM的值推入栈  
0x8 | ZERO | 将内部VM的值重置为0（zero）  
0x9 | JP | 偶校验（parity even）则跳转  
0xA | WRITE | 写入某个地址  
0xB | ADD | 将某个寄存器的值与内部VM的值相加  
0xC | JNS | 为正值则跳转  
0xD | JL | 小于则跳转  
0xE | EXEC | 执行机器码以及分支  
0xF | JBE | 小于或等于则跳转  
0x10 | SHL | 将内部值左移若干位  
0x11 | JA | 大于/不小于或等于则跳转  
0x12 | MOV | 将内部VM值移动到某个寄存器  
0x13 | JZ | 为零则跳转  
0x14 | ADD | 将内部VM描述符与某个立即数相加  
0x15 | JB | 低于则跳转  
0x16 | JS | 结果为负则跳转  
0x17 | EXEC | 执行机器码（与0x0操作码一样）  
0x18 | JGE | 大于或等于则跳转/不小于则跳转  
0x19 | DEREF | 将某个寄存器的值写入解除引用的某个指针  
0x1A | JMP | 小于则跳转（经过混淆的特定操作码）  
0x1B | * | 解析某个指针  
0x1C | LOAD | 将某个值加载入内部VM描述符  
0x1D | JNE | 不等于则跳转/非零则跳转  
0x1E | CALL | 调用外部函数或者释放器中的某个函数  
0x1F | MOV | 将寄存器的值移动到VM描述符中  
0x20 | JNB | 不低于则跳转/大于等于则跳转/无进位则跳转  
0x21 | JNP | 奇偶位为零则跳转  
每条虚拟指令都存储在一个特定的数据结构中，该数据结构包含VM需要正确读取以及执行的所有信息。这个数据结构大小为24字节，由某些固定字段以及一个可变部分所组成（可变部分取决于具体的操作码）。在解释操作码之前，VM会解密操作码的内容（通过简单的XOR算法），然后使用重定位字段进行重定位（如果需要的话）。
操作码数据结构的示例图如下所示：
图5. 存放每条VM操作码数据结构的示意图
VM处理函数完全能够生成不同的代码块，也能处理由于地址空间布局随机化（ASLR）所带来的重定向代码。如果需要的话，处理函数也能将代码执行移动到不同的位置。比如，对于“Execute”操作码（0x17）而言，待运行的32位代码存放在变量区域中，在地址为5的偏移量处指定待复制和执行的字节数。对于条件操作码而言，变量区域会包含下一个JIT的数据包ID或者代码执行所需的下一个相对虚拟地址（relative
virtual address，RVA）。
当然，由于开发者在恶意软件中采用了一些额外的处理步骤，增大了分析过程的复杂度，因此并不是所有的操作码都可以很容易阅读以及理解。比如，0x1A操作码代表的应该是一个JB（小于则跳转）函数，但开发者先使用了一条STC（set
carry）指令，然后通过JMP指令跳转到调度器代码，调度器代码会验证STC指令所设置进位标志条件。
图6. 恶意软件开发者在VM操作码调度器中使用的一种混淆技巧
即使掌握了这些知识，我们也需要消耗许多小时才能写出完整的操作码解释器，利用这个解释器重构FinFisher所执行的实际代码。
## 四、Stage 1—针对沙箱以及调试器的加载器恶意软件