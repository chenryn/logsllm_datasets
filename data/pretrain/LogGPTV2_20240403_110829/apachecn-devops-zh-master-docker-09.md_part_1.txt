# 九、Docker 和 Kubernetes
在这一章中，我们将看一看 Kubernetes。像 Docker Swarm 一样，您可以使用 Kubernetes 来创建和管理运行基于容器的应用的集群。
本章将涵盖以下主题:
*   《Kubernetes 的概论》
*   启用 Kubernetes
*   使用库比涅斯
*   库柏人和其他 Docker 工具
# 技术要求
Docker 中的 Kubernetes 仅受 Mac Docker 和 Windows 桌面客户端 Docker 的支持。和前几章一样，我将使用我喜欢的操作系统，也就是 macOS。和以前一样，一些支持命令可能只适用于 macOS，而且数量很少。
查看以下视频，了解《行动守则》:
[http://bit.ly/2q6xpwl](http://bit.ly/2q6xpwl)
# 《Kubernetes 的概论》
如果您一直在考虑查看容器，那么您可能会在旅途中的某个时候遇到 Kubernetes，所以在我们在 Docker 桌面安装中启用它之前，让我们花点时间看看 Kubernetes 是从哪里来的。
**Kubernetes** (发音为 **koo-ber-net-eez** )源于希腊对舵手或船长的称呼。 **Kubernetes** (也称为 **K8s** )，一个起源于谷歌的开源项目，允许您自动部署、管理和扩展您的容器化应用。
# 谷歌容器简史
谷歌研究基于 Linux 容器的解决方案已经有相当长的时间了。它于 2006 年通过开发名为**控制组** ( **控制组**)的 Linux 内核特性迈出了第一步。这个特性在 2008 年 2.6.24 版本中被合并到 Linux 内核中。该功能允许您隔离资源，如中央处理器、内存、网络和磁盘输入/输出，或一个或多个进程。控制组仍然是 Linux 容器的核心要求，不仅 Docker 使用，其他容器工具也使用。
接下来，谷歌用一个名为 **lmctfy 的容器堆把脚趾伸进了容器水域，这个容器堆代表**让我为你装这个**。这是 T4 LXC T5 工具和图书馆收藏的替代品。这是他们自己内部工具的开源版本，他们用它来管理自己应用中的容器。**
谷歌下一次报道他们的容器使用情况是在 2014 年 5 月乔·贝达在 Gluecon 的一次演讲之后。在谈话中，贝达透露，谷歌内部几乎所有的东西都是基于容器的，他们每周推出大约 20 亿个容器。据称，这一数字不包括任何长时间运行的容器，这意味着容器只在短时间内有效。然而，经过一些快速的计算，这意味着谷歌平均每秒钟推出大约 3000 个容器！
在随后的谈话中，贝达提到谷歌正在使用一个调度程序，这样他们就不必每周手动管理 20 亿个容器，甚至不用担心它们在哪里推出，以及在较小程度上每个容器的可用性。
谷歌还发表了一篇名为《谷歌与博格的大规模集群管理》的论文。这篇文章不仅让谷歌之外的人知道了他们正在使用的调度程序的名字，博格，而且还详细介绍了他们在设计调度程序时所做的设计决策。
该报提到，除了他们的内部工具，谷歌还在运行面向客户的应用，如谷歌文档、谷歌邮件和谷歌搜索，这些应用在运行集群的容器中运行，由博格管理。
**博格人**是根据《T2》星际迷航:下一代电视节目中的外星种族博格人命名的。在电视节目中，博格人是一个控制论种族，他们的文明建立在一个被称为集体的蜂群思维之上。这不仅使他们能够分享同样的想法，而且通过一个子空间网络，确保集体的每个成员都从集体意识中得到指导和监督。我相信你会同意，博格比赛的特点与你希望你的容器集群运行的方式非常匹配。
博格在谷歌内部运行了几年，最终被一个更现代的名为 **Omega 的调度程序所取代。**正是在这个时候，谷歌宣布将把博格的一些核心功能作为一个新的开源项目进行复制。这个项目，内部称为**七**，由博格的几个核心贡献者参与。它的目标是创造一个更友好的博格版本，而不是与谷歌自己的内部程序和工作方式紧密相连。
**七个**，以*星际迷航:航海家*角色命名，九个中的七个，是一个脱离集体的博格人，最终将在第一次公开承诺时被命名为**Kubernetes**。
# Kubernetes 斯概述
所以，现在我们知道了 Kubernetes 是如何形成的，我们可以更深入地了解 Kubernetes 是什么。该项目的大部分，准确地说是 88.5%是用 **Go** 编写的，这应该不足为奇，因为 Go 是一种编程语言，在 2011 年开源之前，它是在谷歌内部开发的。项目文件的其余部分由 Python 和 Shell 帮助脚本以及 HTML 文档组成。
典型的 Kubernetes 集群由承担主服务器或节点角色的服务器组成。您也可以运行同时承担这两种角色的独立安装。
主角色是魔法发生的地方，它是集群的大脑。它负责决定在何处启动吊舱，并负责监控集群本身以及集群内运行的吊舱的运行状况。看完这两个角色后，我们将讨论豆荚。
通常，部署到被赋予主机角色的主机的核心组件是:
*   `kube-apiserver`:这个组件公开了主要的 Kubernetes API。它是为水平扩展而设计的，这意味着您可以不断添加更多的实例，以使集群高度可用。
*   `etcd`:这是一个高度可用的一致键值存储。它用于存储集群的状态。
*   `kube-scheduler`:这个组件负责决定发射吊舱的位置。
*   `kube-controller-manager` **:** 该组件运行控制器。这些控制器在 Kubernetes 中有几个功能，例如监视节点、监视复制、管理端点以及生成服务帐户和令牌。
*   `cloud-controller-manager`:该组件承担各种控制器的管理，控制器与第三方云交互，启动和配置支持服务。
现在我们已经涵盖了管理组件，我们需要讨论它们管理的是什么。节点由以下组件组成:
*   `kubelet`:该代理运行在集群内的每个节点上，是管理人员与节点交互的手段。它还负责管理豆荚。
*   `kube-proxy`:该组件管理节点和吊舱的所有请求和流量的路由。
*   `container runtime`:这可能是 Docker RKT 或任何其他 OCI 兼容的运行时。
你可能已经注意到，到目前为止，我还没有怎么提到容器。这是因为 Kubernetes 实际上并不直接与您的容器交互；相反，它与一个吊舱通信。将 pod 视为一个完整的应用；有点像我们使用 Docker Compose 启动一个由多个容器组成的应用。
# 库柏人和 Docker 人
Kubernetes 最初被视为 Docker Swarm 的竞争技术，Docker 自己的集群技术。然而，在过去的几年里，Kubernetes 已经成为容器编排的事实标准。
所有主要的云提供商都提供 Kubernetes 即服务。我们有以下内容:
*   谷歌云:**谷歌库柏发动机** ( **GKE**
*   微软 Azure: **Azure Kubernetes 服务** ( **AKS** )
*   亚马逊网络服务:亚马逊**Kubernetes 斯弹性容器服务** ( **EKS** )
*   IBM: IBM 云库服务
*   甲骨文云:Kubernetes 的甲骨文容器引擎
*   digital ocean:digital ocean 上的立方结构
从表面上看，所有支持 Kubernetes 斯的主要玩家似乎都没那么重要。然而，考虑到我们现在知道了跨多个平台部署容器化应用的一致方式。传统上，这些平台是围墙花园，有非常不同的互动方式。
虽然 Docker 于 2017 年 10 月在 DockerCon Europe 发布的公告最初令人惊讶，但一旦尘埃落定，该公告就完全有意义了。为开发人员提供一个环境，让他们可以使用 Docker for Mac 和 Docker for Windows 在本地处理他们的应用，然后使用 Docker Enterprise Edition 部署和管理他们自己的 Kubernetes 集群，甚至使用前面提到的云服务之一，这与我们在[第 1 章](01.html) *、Docker 概述*中讨论的试图解决“在我的机器上工作”的问题相吻合。
现在让我们看看如何在 Docker 软件中启用支持，并坚持使用它。
# 启用 Kubernetes
Docker 使安装过程变得极其简单。要启用 Kubernetes 支持，您只需打开首选项并单击 Kubernetes 选项卡:
![](img/f8afeef8-84b7-4a46-9736-c66e4c55fad1.png)
如您所见，有两个主要选项。勾选**启用 Kubernetes** 框，然后选择 **Kubernetes** 作为默认编排器。暂时不要打开**展示系统容器**；启用服务后，我们会更详细地了解这一点。点击**应用**会弹出如下信息:
![](img/05f430c4-01bf-4762-b57b-73baa62a256c.png)
点击**安装**按钮将下载在 Docker 安装中启用 Kubernetes 支持所需的容器:
![](img/da563414-8ffb-4c6c-80a8-b6ddd796ef84.png)
如第一个对话框中所述，Docker 下载、配置和启动集群需要一段时间。完成后，您应该会看到 Kubernetes 旁边的绿点正在运行:
![](img/50d81853-7da1-42ac-bbb2-bff9d816bda9.png)
打开终端并运行以下命令:
```
$ docker container ls -a
```
这应该向你表明，没有什么不寻常的运行。运行以下命令:
```
$ docker image ls
```
这将向您显示与 Kubernetes 相关的映像列表:
*   `docker/kube-compose-controller`
*   `docker/kube-compose-api-server`
*   `k8s.gcr.io/kube-proxy-amd64`
*   `k8s.gcr.io/kube-scheduler-amd64`
*   `k8s.gcr.io/kube-apiserver-amd64`
*   `k8s.gcr.io/kube-controller-manager-amd64`
*   `k8s.gcr.io/etcd-amd64`
*   `k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64`
*   `k8s.gcr.io/k8s-dns-sidecar-amd64`
*   `k8s.gcr.io/k8s-dns-kube-dns-amd64`
*   `k8s.gcr.io/pause-amd64`
这些图片来源于 Docker 和官方的 Kubernetes 图片，这些图片可以从谷歌容器注册处获得。
正如您可能已经猜到的，勾选**显示系统容器(高级)**框，然后运行以下命令，将向您显示在本地 Docker 安装上启用 Kubernetes 服务的所有正在运行的容器的列表:
```
$ docker container ls -a
```
由于运行前面的命令时会有很多输出，下面的屏幕截图只显示了容器的名称。为此，我运行了以下命令:
```
$ docker container ls --format {{.Names}}
```
运行该命令给了我以下信息:
![](img/1e714f65-62af-41da-8cca-59d3b6cea891.png)
有 18 个运行的容器，这就是为什么你可以选择隐藏它们。如您所见，几乎涵盖了我们在上一节中讨论的所有组件以及一些附加组件，它们提供了与 Docker 的集成。我建议取消勾选**显示系统容器框**，因为我们不需要每次查看正在运行的容器时都看到 18 个容器的列表。
此时需要注意的另一件事是，Kubernetes 菜单项现在包含了内容。该菜单可用于在 Kubernetes 集群之间切换。由于目前只有一个集群处于活动状态，因此只列出了一个集群:
![](img/ebc6ad44-b922-4b56-9512-072df178d34c.png)
现在我们已经启动并运行了本地 Kubernetes 集群，我们可以开始使用它了。
# 使用库比涅斯
现在我们已经在 Docker 桌面安装上启动并运行了 Kubernetes 集群，我们可以开始与它交互了。首先，我们将查看安装在 Docker 桌面组件`kubectl`旁边的命令行。
如前所述，`kubectl`安装在旁边。以下命令将显示有关客户端及其所连接的群集的一些信息:
```
$ kubectl version
```
![](img/5005937f-00f6-4be5-a2a8-06ddbfdb23d1.png)
接下来，我们可以运行以下命令来查看`kubectl`是否可以看到我们的节点:
```
$ kubectl get nodes
```
![](img/05607ef3-a64a-4c33-96bf-8ead71987a7b.png)
现在我们已经让客户端与我们的节点进行交互，我们可以通过运行以下命令来查看默认情况下在 Kubernetes 中配置的`namespaces`:
```
$ kubectl get namespaces
```
然后我们可以使用以下命令查看命名空间内的`pods`:
```
$ kubectl get --namespace kube-system pods
```
![](img/f5f27507-e03d-458a-aca5-341fdda41a14.png)
Kubernetes 中的名称空间是隔离集群内资源的一种很好的方式。从终端输出可以看出，我们的集群中有四个名称空间。有`default`命名空间，通常是空的。主要的 Kubernetes 服务有两个名称空间:`docker`和`kube-system`。这些包含了组成我们集群的单元，最终的名称空间`kube-public`和默认的名称空间一样，是空的。