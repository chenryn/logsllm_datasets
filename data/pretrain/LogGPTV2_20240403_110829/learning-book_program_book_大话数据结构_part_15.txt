已实现它：
/除在L中第i个数据元素e*/
Status ListDelete （StaticLinkList L,int i)
75
---
## Page 100
大语数据结构
intj,k;
if（iListLength（L））
return ERROR;
k=MAX_SIZE-1;
for（j-1:next
是否为空，现在则是p>next不等于头结点，则循环未结束。
在单链表中，我们有了头结点时，我们可以用0（1）的时间访问第一个结点，但对
于要访问到最后一个结点，却需要0（n）时间，因为我们需要将单链表全部扫描一遍。
有没有可能用0（1）的时间由链表指针访问到最后一个结点呢？当然可以。
不过我们需要改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指
---
## Page 104
大话数据结构
针来表示循环链表（如图3-13-5所示），此时查找开始结点和终端结点都很方便了。
1
尾指针
图3-13-5
从上图中可以看到，终端结点用尾指针rear指示，则查找终端结点是0（1），而开
始结点，其实就是rear->next>next，其时间复杂也为0(1）。
举个程序的例子，要将两个循环链表合并成一个表时，有了尾指针就非常简单
了。比如下面的这两个循环链表，它们的尾指针分别是rearA和rearB，如图3-13-6
所示。
rearA->next
rearB
rearB-> next rearB-> next-> next
图 3-13-6
要想把它们合并，只需要如下的操作即可，如图3-13-7所示。
rearA
rearA-> next
rearB
rearB-> next-> next
图3-13-7
p-rearA->next;
保存A表的头结点，即①/
rearA->next=rearB->next->next;/*将本是指向B表的第一个结点（不是头结点）*/
/*赋值给reaA->next，即②·/
---
## Page 105
第3章线性表
rearB->next=p;
/将原A表的头结点赋值给rearB->next，即③·/
free(p）:
1·释放p·/
3.14双向链表
继续我们刚才的例子，你平时都是从上海一路停留到北京的，可是这一次，你得
先到北京开会，谁叫北京是首都呢，会就是多。开完会后，你需要例行公事，走访各
个城市，此时你怎么办？
上苏
无
济
天
海
京
图 3-14-1
有人又出主意了，你可以先飞回上海，一路再乘火车走遍这几个城市，到了北京
后，你再飞回上海。
你会感慨，人生中为什么总会有这样出傻主意的人存在呢？真要气死人才行。哪
来这么麻烦，我一路从北京坐火车或汽车回去不就完了吗。
常无苏
上
州
埠
江
州
锡
海
图 3-14-2
对呀，其实生活中类似的小智慧比比皆是，并不会那么的死板教条。我们的单链
表，总是从头到尾找结点，难道就不可以正反遍历都可以吗？当然可以，只不过需要
加点东西而已。
我们在单链表中，有了next指针，这就使得我们要查找下一结点的时间复杂度为
0（1）。可是如果我们要查找的是上一结点的话，那最坏的时间复杂度就是0（n）了，因
为我们每次都要从头开始遍历查找。
为了克服单向性这一缺点，我们的老科学家们，设计出了双向链表。双向链表
（doublelinkedlist）是在单链表的每个结点中，再设置一个指向其前驱结点的指针
域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接
前驱。
/线性表的双向链表存储结构*/
81
---
## Page 106
大诺数据结构
typedef struct DulNode
ElenType data;
struct DuLNode *prior;
·直接前驱指针*/
/*直接后继指针*/
1DulNode，*DuLinkList;
既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。
双向链表的循环带头结点的空链表如图3-14-3所示。
头指针
图3-14-3
非空的循环的带头结点的双向链表如图3-14-4所示。
头指针
a
a2
图3-14-4
由于这是双向链表，那么对于链表中的某一个结点p，它的后继的前驱是谁？当
然还是它自己。它的前驱的后继自然也是它自己，即：
这就如同上海的下一站是苏州，那么上海的下一站的前一站是哪里？哈哈，有点
废话的感觉。
双向链表是单链表中扩展出来的结构，所以它的很多操作是和单链表相同的，比
如求长度的ListLength，查找元素的GetElem，获得元素位置的LocateElem等，这些
操作都只要涉及一个方向的指针即可，另一指针多了也不能提供什么帮助。
就像人生一样，想享乐就得先努力，欲收获就得付代价。双向链表既然是比单链
表多了如可以反向遍历查找等数据结构，那么也就需要付出一些小的代价：在插入和
删除时，需要更改两个指针变量。
82
---
## Page 107
第3章线性表
插入操作时，其实并不复杂，不过顺序很重要，千万不能写反了。
我们现在假设存储元素e的结点为s，要实现将结点s插入到结点p和p>next
之间需要下面几步，如图3-14-5所示。
p->next
2
S
图3-14-5
d-oTdnext赋值给s的后继，如图中②*/
p->next->prior=s;
/*s赋佳给p->next的前驱，如图中③*/
=xeu<-d
/把s赋值给p的后继，如图中④/