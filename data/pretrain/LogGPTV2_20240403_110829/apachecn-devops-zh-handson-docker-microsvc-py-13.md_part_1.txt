# 十三、答案
# 第一章
1.  **什么是独石？**
整体是在单个块中创建的软件应用。该应用作为单个进程运行。它只能统一部署，尽管可以创建多个相同的副本。
2.  **巨石会遇到什么问题？**
随着它们的成长，单片可能会遇到以下问题:
*   代码变得太大，难以阅读。
*   可扩展性问题。
*   协调部署的需要。
*   资源使用不当。
*   不可能在不同的情况下使用冲突的技术(例如，同一个库的不同版本，或者两种编程语言)。
*   一个错误和部署可能会影响整个系统。
3.  **能否描述一下微服务架构？**
微服务架构是松散耦合的专门服务的集合，这些服务协同工作以提供全面的服务。
4.  **微服务最重要的属性是什么？**
微服务最重要的属性是它们可以独立部署，因此可以独立开发。
5.  **从整体迁移到微服务时，我们需要克服的主要挑战是什么？**
可能的挑战包括以下方面:
6.  **我们如何进行这样的迁移？**
我们需要分析系统，测量，相应地计划，并执行计划。
7.  **描述我们如何使用负载平衡器从旧服务器迁移到新服务器，而不中断系统。**
首先，我们必须配置负载平衡器，使其指向旧的 web 服务器，这将使流量穿过 web 服务器。然后，我们必须更改 DNS 记录，使其指向负载平衡器。流量通过负载均衡器后，我们需要为新服务创建一个新条目，以便负载均衡器在两者之间分配流量。在确认一切正常后，我们需要从旧服务中移除条目。现在，所有流量都将被路由到新服务。
# 第二章
1.  **RESTful 应用的特点是什么？**
虽然 RESTful 应用被理解为一个网络接口，它将 URIs 转换成对象表示，并通过 HTTP 方法对它们进行操作(通常用 JSON 格式化请求)，但是 REST 体系结构的教科书特征如下:
*   统一界面
*   客户端-服务器
*   无国籍的
*   可缓冲的
*   分层系统
*   按需编码(可选)
你可以在[https://restfulapi.net/](https://restfulapi.net/)找到更多关于 REST 架构的信息。
2.  **使用 Flask-RESTPlus 有哪些优势？**
使用 Flask-RESTPlus 的一些优势如下:
*   自动斯瓦格生成。
*   可以定义和解析输入并封送输出的框架。
*   它允许我们在名称空间中构造代码。
3.  **Flask-RESTPlus 有哪些替代品？**
其他替代方案包括 Flask-RESTful(这类似于 Flask-RESTPlus，但不支持 Swagger)和 Django REST 框架，后者有一个丰富的生态系统，其中充满了第三方扩展。
4.  命名测试中用来修正时间的 Python 包。
`freezegun`。
5.  **描述认证流程。**
认证系统(用户后端)会生成一个编码令牌。该令牌使用只有用户后端拥有的私钥进行编码。该令牌在 JWT 编码，包含用户标识以及其他参数，例如，告诉我们令牌的有效期。该令牌包含在`Authentication`头中。
令牌从头部获得，并使用相应的公钥解码，公钥存储在思想后端。这允许我们独立地获得用户标识，并确信它已经被用户后端验证。
6.  **我们为什么选择 SQLAlchemy 作为数据库接口？**
SQLAlchemy 在 Flask 中得到很好的支持，允许我们定义已经存在的数据库。它是高度可配置的，允许我们在较低的层次上工作，也就是说，接近底层的 SQL，在较高的层次上工作，这消除了对任何样板代码的需要。在我们的用例中，我们从遗留系统继承了一个数据库，因此需要与现有的模式无缝地工作。
# 第三章
1.  **FROM 关键字在 Dockerfile 中做什么？**
它从一个现有的映像开始，增加了更多的层。
2.  **如何用预定义的命令启动容器？**
您可以运行以下命令:
```
docker run image
```
3.  **为什么创建一个从 Dockerfile 中移除文件的步骤不会创建一个更小的映像？**
由于 Docker 使用的文件系统的分层结构，Docker 文件中的每一步都会创建一个新的层。文件系统是所有操作协同工作的结果。最终映像包括所有现有图层；添加图层永远不会减小映像的大小。删除的新步骤不会出现在最终映像中，但它将始终作为上一层的一部分。
4.  **多级 Dockerfile 是如何工作的？**
多级 Dockerfile 包含多个阶段，每个阶段都以`FROM`命令开始，该命令指定作为起点的映像。数据可以在一个阶段生成，然后复制到另一个阶段。
如果我们希望减小最终映像的尺寸，多阶段构建是有用的；只有结果数据将被复制到最后阶段。
5.  **run 和 exec 命令有什么区别？**
`run`命令从一个映像开始一个新的容器，而`exec`命令连接到一个已经存在的运行容器。请注意，如果容器在您执行时停止，会话将被关闭。
Stopping a container can occur in an `exec` session. The main process that is keeping the container running is the `run` command. If you kill the command or stop it in any other way, the container will stop and the session will be closed.
6.  **我们应该什么时候使用-it 标志？**
当您需要保持终端打开时，例如，交互式运行`bash`命令。记住助记符*互动终端*。
7.  **除了使用 uWSGI 为 web Python 应用提供服务，还有哪些替代方案？**
任何支持 WSGI 网络协议的网络服务器都可以作为替代。最受欢迎的替代品是 Gunicorn 和 CherryPy，guni corn 旨在易于使用和配置，`mod_wsgi`是受欢迎的 Apache 网络服务器的扩展，支持 WSGI Python 模块，CherryPy 包括自己的网络框架。
8.  **docker-compose 是用来做什么的？**
`docker-compose`允许简单的编排，也就是说，我们可以协调几个互连的 Docker 容器，以便它们协同工作。它还帮助我们配置 Docker 命令，因为我们可以使用`docker-compose.yaml`文件来存储所有受影响容器的配置参数。
9.  **你能描述一下什么是 Docker 标签吗？**
Docker 标记是一种标记映像的方式，同时保留它们的根名称。它通常标记同一应用或软件的不同版本。默认情况下，`latest`标记将应用于映像构建。
10.  **为什么我们需要将映像推送到远程注册表？**
我们将映像推送到远程注册表，这样我们就可以与其他系统和其他开发人员共享映像。Docker 在本地构建映像，除非需要将它们推送到另一个存储库，以便其他 Docker 服务可以使用它们。
# 第四章
1.  **增加部署数量是否会降低部署质量？**
没有；事实表明，部署数量的增加与其质量的提高有很强的相关性。一个能够快速部署的系统必须依赖强大的自动化测试，这增加了系统的稳定性和整体质量。
2.  **什么是管道？**
管道是用于执行构建的一系列有序的步骤或阶段。如果其中一个步骤失败，构建将停止。步骤的顺序应该旨在最大限度地尽早发现问题。
3.  **我们如何知道我们的主分支是否可以部署？**
如果我们在每次提交时自动运行我们的管道来生成一个构建，我们应该在提交后立即检测主分支上的问题。构建应该向我们保证可以部署主分支的顶部提交。主枝断裂应该尽快修复。
4.  **Travis CI 的主要配置来源是什么？**
`.travis.yml`文件，可以在存储库的根目录中找到。
5.  **默认情况下，Travis CI 什么时候发送通知邮件？**
Travis CI 在构建中断时以及之前中断的分支成功通过时发送通知电子邮件。当前一次提交成功但未报告时，就会成功生成。
6.  **如何避免一个断枝合并到我们的主枝？**
我们可以通过在 GitHub 中进行配置来避免这种情况，这样可以确保分支在我们将其合并到受保护的分支之前通过构建。为了确保特性分支没有偏离主分支，我们需要强制它与构建合并。要做到这一点，它需要与主分支保持同步。
7.  **为什么我们要避免将机密存储在 Git 存储库中？**
由于 Git 的工作方式，任何引入的机密都可以通过查看提交历史来检索，即使它已经被移除。由于提交历史可以在任何克隆的存储库中复制，这使得我们无法验证它是否正确——我们不能将提交历史重写到克隆的存储库中。机密不应该存储在 Git 存储库中，除非它们被正确加密。任何错误存储的机密都应该删除。
# 第五章
1.  **什么是容器编导？**
容器编排器是一个系统，我们可以在其中部署多个协同工作的容器，并以有序的方式管理供应和部署。
2.  **在 Kubernetes 中，什么是节点？**
节点是属于群集的物理服务器或虚拟机。可以在集群中添加或删除节点，Kubernetes 将相应地迁移或重新启动正在运行的容器。
3.  **豆荚和容器有什么区别？**
一个容器可以包含多个共享相同 IP 的容器。要在 Kubernetes 中部署一个容器，我们需要将其与一个 pod 相关联。
4.  **工作和豆荚有什么区别？**
预计吊舱会持续运行。一个作业或 cron 作业执行一个操作，然后所有 pod 容器完成它们的执行。
5.  **我们应该什么时候添加入口？**
当我们需要能够从集群外部访问服务时，我们应该添加一个入口。