the multilinearity degree of 25 (in contrast to 20 in [27] for
365
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:30 UTC from IEEE Xplore.  Restrictions apply. 
TABLE V: Runtimes and program size for conjunction pro-
grams at w=1, t = 220, and λ > 80
Σexp (Πv) KeyGen Obfuscate
L
5
6
8
10
12
14
16
18
19
20
21
22
23
24
n
k
8192
8192
16384
16384
16384
32768
32768
32768
32768
32768
32768
32768
32768
32768
240
300
420
480
600
720
780
900
960
960
1020
1080
1140
1200
(GB)
1.08
2.36
13.2
28.6
60.4
227
363
565
723
825
994
1232
1459
1774
(s)
1.1
1.7
7.6
11
18
62
81
115
134
148
172
199
212
257
(min)
1.1
1.8
8.2
12
22
103
135
198
237
252
310
350
404
510
Evaluate
(s)
0.39
0.72
3.7
5.5
12
74
101
158
188
213
230
247
286
379
a comparable computing environment). For the degree of 20,
our obfuscation time is 237 minutes (vs 4,060 minutes in [27])
and our evaluation is 188 seconds (vs 1,514 seconds in [27]).
Our main experimental limitation was memory in the server
computing environment. Results in Table V show that our
implementation would be able to support at most 24-bit
conjunction programs if the word encoding optimization were
not applied. Also, the runtimes for this 24-bit scenario are
substantially higher than our results for 32-bit conjunction
programs in Table III.
E. Parallelization experiments
Table VI shows the runtime results for a 32-bit pattern with
53 bits of security on a 4-core desktop commodity CPU as a
function of the number of threads. The total program size and
all input parameters are the same as in the ﬁrst row of Table III.
As expected, runtimes for 4 and 8 threads are approximately
the same. There is no major beneﬁt of hyper-threading, as the
number of physical cores is 4.
When increasing the number of threads from 1 to 4, the
key generation time decreases by a factor of 3.2, suggesting
that key generation beneﬁts from loop parallelization. The
obfuscation procedure scales well with more threads. Runtime
improvement is a factor of 3.2 (and even 3.5 when 8 threads
are considered). This implies that further obfuscation runtime
improvements can be achieved using more CPU cores. The
evaluation procedure also beneﬁts from loop parallelization.
The runtime improvement in this case is 3.4 (3.7 for 8 threads).
The evaluation runtime of 43 ms on a commodity desktop
environment implies that a 32-bit conjunction obfuscator is
already practical.
We also ran the evaluation of an obfuscated 64-bit con-
junction program (with 73 bits of security) on the commodity
desktop computer for the scenario where the obfuscation
is previously performed in a high-performance computing
environment (corresponds to the last row in Table IV). This ﬁts
the scenario where the obfuscated program would be stored
on SSD drives (or other fast access media.) The average time
of evaluation was 3.5 sec.
TABLE VI: Runtimes for 32-bit conjunction patterns at n =
1024 as a function of number of threads in a 4-core commodity
desktop computing environment
# threads KeyGen Obfuscate
(s)
0.179
0.106
0.056
0.053
(min)
24.3
13.8
7.7
7.0
1
2
4
8
Evaluate
(ms)
161
90
48
43
IX. CONCLUDING REMARKS
Our work presents an improved design and software imple-
mentation for the secure obfuscation of conjunction programs,
which are signiﬁcantly more complex than simple point obfus-
cation functions supported by prior obfuscation implementa-
tions. The obfuscation construction we implement is based on
a reasonable hardness variant of a standard lattice assumption
(entropic Ring-LWE) and distributional VBB,
in constrast
to previous implementations of non-trivial obfuscators based
on IO via multilinear maps [25], [26], [27] or the heuristic
techniques not derived from the computational hardness of
mathematical problems [2], [3], [4], [5], [6], [7].
Through our optimizations, we are able to reduce the
program size, obfuscation runtime, and evaluation runtime by
multiple orders of magnitude. This allows us to execute the
obfuscation and evaluation of 32-bit conjunction programs in
a commodity desktop environment. Our implementation can
also run secure obfuscation of 64-bit conjunction programs
in a commercially available server computing environment
and execute evaluation in a commodity desktop environment,
achieving the evaluation runtime of 3.5 seconds.
A major challenge not addressed by this work is the encod-
ing of real practical programs as conjunctions chosen from a
distribution having sufﬁcient entropy. A potential approach to
this problem is to use the obfuscation technique for compute-
and-compare programs, a recently proposed generalization of
conjunction obfuscators, based on LWE [50]. Note that many
design elements and optimizations presented in this study can
also be applied to this more general obfuscation technique.
X. ACKNOWLEDGEMENTS
We gratefully acknowledge the input and feedback from
Sean Al-Gattas, David Archer, Lisa Bahler, Brian Coan,
Nicholas Genise, Shaﬁ Goldwasser, Michael Hsieh, Daniele
Micciancio, Michael Naehrig, Rafail Ostrovsky, David Re-
nardy, Carey Schwartz, Nigel Smart, Vinod Vaikuntanathan,
and Michael Walter. We also thank the S&P’18 reviewers for
helpful comments.
This work was sponsored by the Defense Advanced Re-
search Projects Agency (DARPA) and the Army Research
Laboratory (ARL) under Contract Numbers W911NF-15-C-
0226 and W911NF-15-C-0233. The views expressed are those
of the authors and do not necessarily reﬂect
the ofﬁcial
policy or position of the Department of Defense or the U.S.
Government.
366
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:30 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] Z. Brakerski, V. Vaikuntanathan, H. Wee, and D. Wichs, “Obfuscating
conjunctions under entropic ring lwe,” in Proceedings of the 2016 ACM
Conference on Innovations in Theoretical Computer Science, ser. ITCS
’16, 2016, pp. 147–156.
[2] D. Low, “Protecting java code via code obfuscation,” Crossroads, vol. 4,
no. 3, pp. 21–23, Apr. 1998.
[3] G. Wroblewski, “General method of program code obfuscation,” Ph.D.
dissertation, Citeseer, 2002.
[4] C. Linn and S. Debray, “Obfuscation of executable code to improve
resistance to static disassembly,” in Proceedings of
the 10th ACM
Conference on Computer and Communications Security, ser. CCS ’03,
2003, pp. 290–299.
[5] S. Schrittwieser, S. Katzenbeisser, P. Kieseberg, M. Huber, M. Leithner,
M. Mulazzani, and E. Weippl, “Covert computation: Hiding code in
code for obfuscation purposes,” in Proceedings of the 8th ACM SIGSAC
Symposium on Information, Computer and Communications Security,
ser. ASIA CCS ’13, 2013, pp. 529–534.
[6] M. I. Sharif, A. Lanzi, J. T. Gifﬁn, and W. Lee, “Impeding malware
analysis using conditional code obfuscation.” in NDSS, 2008.
[7] Y. Zhou, A. Main, Y. X. Gu, and H. Johnson, “Information hiding in
software with mixed boolean-arithmetic transforms,” in Proceedings of
the 8th International Conference on Information Security Applications,
ser. WISA’07, 2007, pp. 61–75.
[8] C. S. Collberg and C. Thomborson, “Watermarking, tamper-profﬁng, and
obfuscation: Tools for software protection,” IEEE Trans. Softw. Eng.,
vol. 28, no. 8, pp. 735–746, Aug. 2002.
[9] N. Eyrolles, L. Goubin, and M. Videau, “Defeating mba-based ob-
fuscation,” in Proceedings of the 2016 ACM Workshop on Software
PROtection, ser. SPRO ’16, 2016, pp. 27–38.
[10] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna, “Static disassembly
of obfuscated binaries,” in USENIX Security Symposium, 2004.
[11] A. H. Sung, J. Xu, P. Chavez, and S. Mukkamala, “Static analyzer
of vicious executables (save),” in 20th Annual Computer Security
Applications Conference, Dec 2004, pp. 326–334.
[12] S. K. Udupa, S. K. Debray, and M. Madou, “Deobfuscation: reverse
engineering obfuscated code,” in 12th Working Conference on Reverse
Engineering (WCRE’05), Nov 2005, p. 10.
[13] B. Barak, “Hopes, fears, and software obfuscation,” Commun. ACM,
vol. 59, no. 3, pp. 88–96, Feb. 2016.
[14] S. Hada, Zero-Knowledge and Code Obfuscation. Berlin, Heidelberg:
Springer Berlin Heidelberg, 2000, pp. 443–457.
[15] B. Barak, O. Goldreich, R. Impagliazzo, S. Rudich, A. Sahai, S. Vadhan,
and K. Yang, “On the (im)possibility of obfuscating programs,” J. ACM,
vol. 59, no. 2, pp. 6:1–6:48, May 2012.
[16] N. Bitansky, R. Canetti, H. Cohn, S. Goldwasser, Y. T. Kalai, O. Paneth,
and A. Rosen, The Impossibility of Obfuscation with Auxiliary Input or
a Universal Simulator. Berlin, Heidelberg: Springer Berlin Heidelberg,
2014, pp. 71–89.
[17] S. Goldwasser and Y. T. Kalai, “On the impossibility of obfuscation
with auxiliary input,” in 46th Annual IEEE Symposium on Foundations
of Computer Science (FOCS’05), Oct 2005, pp. 553–562.
[18] B. Applebaum and Z. Brakerski, Obfuscating Circuits via Composite-
Order Graded Encoding. Berlin, Heidelberg: Springer Berlin Heidel-
berg, 2015, pp. 528–556.
[19] B. Barak, S. Garg, Y. T. Kalai, O. Paneth, and A. Sahai, Protecting
Obfuscation against Algebraic Attacks. Berlin, Heidelberg: Springer
Berlin Heidelberg, 2014, pp. 221–238.
[20] S. Garg, C. Gentry, S. Halevi, M. Raykova, A. Sahai, and B. Waters,
“Candidate indistinguishability obfuscation and functional encryption
for all circuits,” SIAM Journal on Computing, vol. 45, no. 3, pp. 882–
929, 2016.
[21] C. Gentry, S. Gorbunov, and S. Halevi, Graph-Induced Multilinear Maps
from Lattices. Berlin, Heidelberg: Springer Berlin Heidelberg, 2015,
pp. 498–527.
[22] H. Lin, Indistinguishability Obfuscation from SXDH on 5-Linear Maps
and Locality-5 PRGs. Cham: Springer International Publishing, 2017,
pp. 599–629.
[23] H. Lin, R. Pass, K. Seth, and S. Telang, Indistinguishability Obfusca-
tion with Non-trivial Efﬁciency. Berlin, Heidelberg: Springer Berlin
Heidelberg, 2016, pp. 447–462.
[24] H. Lin and S. Tessaro, Indistinguishability Obfuscation from Trilinear
Cham: Springer International
Maps and Block-Wise Local PRGs.
Publishing, 2017, pp. 630–660.
[25] D. Apon, Y. Huang, J. Katz, and A. J. Malozemoff, “Implementing
cryptographic program obfuscation,” Cryptology ePrint Archive, Report
2014/779, 2014, http://eprint.iacr.org/2014/779.
[26] K. Lewi, A. J. Malozemoff, D. Apon, B. Carmer, A. Foltzer, D. Wagner,
D. W. Archer, D. Boneh, J. Katz, and M. Raykova, “5gen: A framework
for prototyping applications using multilinear maps and matrix branch-
ing programs,” in Proceedings of the 2016 ACM SIGSAC Conference
on Computer and Communications Security, ser. CCS ’16, 2016, pp.
981–992.
[27] S. Halevi, T. Halevi, V. Shoup, and N. Stephens-Davidowitz, “Im-
plementing bp-obfuscation using graph-induced encoding,” Cryptology
ePrint Archive, Report 2017/104 [to appear in ACM CCS 2017], 2017,
http://eprint.iacr.org/2017/104.
[28] J.-S. Coron, C. Gentry, S. Halevi, T. Lepoint, H. K. Maji, E. Miles,
M. Raykova, A. Sahai, and M. Tibouchi, Zeroizing Without Low-Level
Zeroes: New MMAP Attacks and their Limitations. Berlin, Heidelberg:
Springer Berlin Heidelberg, 2015, pp. 247–266.
[29] J.-S. Coron, M. S. Lee, T. Lepoint, and M. Tibouchi, Cryptanalysis
Berlin, Heidelberg: Springer Berlin
of GGH15 Multilinear Maps.
Heidelberg, 2016, pp. 607–628.
[30] J. H. Cheon, K. Han, C. Lee, H. Ryu, and D. Stehl´e, Cryptanalysis of
the Multilinear Map over the Integers. Berlin, Heidelberg: Springer
Berlin Heidelberg, 2015, pp. 3–12.
[31] J. H. Cheon, P.-A. Fouque, C. Lee, B. Minaud, and H. Ryu, Crypt-
analysis of the New CLT Multilinear Map over the Integers. Berlin,
Heidelberg: Springer Berlin Heidelberg, 2016, pp. 509–536.
[32] Y. Hu and H. Jia, Cryptanalysis of GGH Map. Berlin, Heidelberg:
Springer Berlin Heidelberg, 2016, pp. 537–565.
[33] E. Miles, A. Sahai, and M. Zhandry, Annihilation Attacks for Multilinear
Maps: Cryptanalysis of Indistinguishability Obfuscation over GGH13.
Berlin, Heidelberg: Springer Berlin Heidelberg, 2016, pp. 629–658.
[Online]. Available: http://dx.doi.org/10.1007/978-3-662-53008-5 22
[34] J.-S. Coron, M. S. Lee, T. Lepoint, and M. Tibouchi, Zeroizing Attacks
on Indistinguishability Obfuscation over CLT13. Berlin, Heidelberg:
Springer Berlin Heidelberg, 2017, pp. 41–58.
[35] Y. Chen, C. Gentry, and S. Halevi, Cryptanalyses of Candidate
Branching Program Obfuscators.
International
Publishing, 2017, pp. 278–307. [Online]. Available: https://doi.org/10.
1007/978-3-319-56617-7 10