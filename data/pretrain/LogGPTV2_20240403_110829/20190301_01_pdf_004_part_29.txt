-------+-------+-----+-----+----------+-----+------+--------
(0 rows)
SELECT TO_CHAR(AUDIT_DATE,'DD-MON-YY HH24:MI:SS') AS "audit date",
audit_user, audit_desc FROM empauditlog ORDER BY 1 ASC;
audit date | audit_user | audit_desc
--------------------+--------------+-------------------
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 247
Database Compatibility for Oracle® Developers Guide
23-AUG-18 07:12:27 | enterprisedb | Added employee(s)
23-AUG-18 07:12:27 | enterprisedb | Added employee(s)
(2 rows)
Autonomous Transaction Object Type Method
The following example shows the effect of declaring an object method with PRAGMA
AUTONOMOUS_TRANSACTION.
The following object type and object type body are created. The member procedure
within the object type body contains the PRAGMA AUTONOMOUS_TRANSACTION in the
declaration section along with COMMIT at the end of the procedure.
CREATE OR REPLACE TYPE insert_dept_typ AS OBJECT (
deptno NUMBER(2),
dname VARCHAR2(14),
loc VARCHAR2(13),
MEMBER PROCEDURE insert_dept
);
CREATE OR REPLACE TYPE BODY insert_dept_typ AS
MEMBER PROCEDURE insert_dept
IS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
INSERT INTO dept VALUES (SELF.deptno,SELF.dname,SELF.loc);
COMMIT;
END;
END;
In the following anonymous block, an insert is performed into the dept table, followed
by invocation of the insert_dept method of the object, ending with a ROLLBACK
command in the anonymous block.
BEGIN;
DECLARE
v_dept INSERT_DEPT_TYP :=
insert_dept_typ(60,'FINANCE','CHICAGO');
BEGIN
INSERT INTO dept VALUES (50,'HR','DENVER');
v_dept.insert_dept;
ROLLBACK;
END;
Since insert_dept has been declared as an autonomous transaction, its insert of
department number 60 remains in the table, but the rollback removes the insertion of
department 50.
SELECT * FROM dept ORDER BY 1;
deptno | dname | loc
--------+------------+----------
10 | ACCOUNTING | NEW YORK
20 | RESEARCH | DALLAS
30 | SALES | CHICAGO
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 248
Database Compatibility for Oracle® Developers Guide
40 | OPERATIONS | BOSTON
60 | FINANCE | CHICAGO
(5 rows)
3.7 Dynamic SQL
Dynamic SQL is a technique that provides the ability to execute SQL commands that are
not known until the commands are about to be executed. Up to this point, the SQL
commands that have been illustrated in SPL programs have been static SQL - the full
command (with the exception of variables) must be known and coded into the program
before the program, itself, can begin to execute. Thus using dynamic SQL, the executed
SQL can change during program runtime.
In addition, dynamic SQL is the only method by which data definition commands, such
as CREATE TABLE, can be executed from within an SPL program.
Note, however, that the runtime performance of dynamic SQL will be slower than static
SQL.
The EXECUTE IMMEDIATE command is used to run SQL commands dynamically.
EXECUTE IMMEDIATE 'sql_expression;'
[ INTO { variable [, ...] | record } ]
[ USING expression [, ...] ]
sql_expression is a string expression containing the SQL command to be
dynamically executed. variable receives the output of the result set, typically from a
SELECT command, created as a result of executing the SQL command in
sql_expression. The number, order, and type of variables must match the number,
order, and be type-compatible with the fields of the result set. Alternatively, a record can
be specified as long as the record’s fields match the number, order, and are type-
compatible with the result set. When using the INTO clause, exactly one row must be
returned in the result set, otherwise an exception occurs. When using the USING clause
the value of expression is passed to a placeholder. Placeholders appear embedded
within the SQL command in sql_expression where variables may be used.
Placeholders are denoted by an identifier with a colon (:) prefix - :name. The number,
order, and resultant data types of the evaluated expressions must match the number, order
and be type-compatible with the placeholders in sql_expression. Note that
placeholders are not declared anywhere in the SPL program – they only appear in
sql_expression.
The following example shows basic dynamic SQL commands as string literals.
DECLARE
v_sql VARCHAR2(50);
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 249
Database Compatibility for Oracle® Developers Guide
BEGIN
EXECUTE IMMEDIATE 'CREATE TABLE job (jobno NUMBER(3),' ||
' jname VARCHAR2(9))';
v_sql := 'INSERT INTO job VALUES (100, ''ANALYST'')';
EXECUTE IMMEDIATE v_sql;
v_sql := 'INSERT INTO job VALUES (200, ''CLERK'')';
EXECUTE IMMEDIATE v_sql;
END;
The following example illustrates the USING clause to pass values to placeholders in the
SQL string.
DECLARE
v_sql VARCHAR2(50) := 'INSERT INTO job VALUES ' ||
'(:p_jobno, :p_jname)';
v_jobno job.jobno%TYPE;
v_jname job.jname%TYPE;
BEGIN
v_jobno := 300;
v_jname := 'MANAGER';
EXECUTE IMMEDIATE v_sql USING v_jobno, v_jname;
v_jobno := 400;
v_jname := 'SALESMAN';
EXECUTE IMMEDIATE v_sql USING v_jobno, v_jname;
v_jobno := 500;
v_jname := 'PRESIDENT';
EXECUTE IMMEDIATE v_sql USING v_jobno, v_jname;
END;
The following example shows both the INTO and USING clauses. Note the last execution
of the SELECT command returns the results into a record instead of individual variables.
DECLARE
v_sql VARCHAR2(60);
v_jobno job.jobno%TYPE;
v_jname job.jname%TYPE;
r_job job%ROWTYPE;
BEGIN
DBMS_OUTPUT.PUT_LINE('JOBNO JNAME');
DBMS_OUTPUT.PUT_LINE('----- -------');
v_sql := 'SELECT jobno, jname FROM job WHERE jobno = :p_jobno';
EXECUTE IMMEDIATE v_sql INTO v_jobno, v_jname USING 100;
DBMS_OUTPUT.PUT_LINE(v_jobno || ' ' || v_jname);
EXECUTE IMMEDIATE v_sql INTO v_jobno, v_jname USING 200;
DBMS_OUTPUT.PUT_LINE(v_jobno || ' ' || v_jname);
EXECUTE IMMEDIATE v_sql INTO v_jobno, v_jname USING 300;
DBMS_OUTPUT.PUT_LINE(v_jobno || ' ' || v_jname);
EXECUTE IMMEDIATE v_sql INTO v_jobno, v_jname USING 400;
DBMS_OUTPUT.PUT_LINE(v_jobno || ' ' || v_jname);
EXECUTE IMMEDIATE v_sql INTO r_job USING 500;
DBMS_OUTPUT.PUT_LINE(r_job.jobno || ' ' || r_job.jname);
END;
The following is the output from the previous anonymous block:
JOBNO JNAME
----- -------
100 ANALYST
200 CLERK
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 250
Database Compatibility for Oracle® Developers Guide
300 MANAGER
400 SALESMAN
500 PRESIDENT
You can use the BULK COLLECT clause to assemble the result set from an EXECUTE
IMMEDIATE statement into a named collection. See Section 3.12.4, EXECUTE
IMMEDIATE BULK COLLECT for information about using the BULK COLLECT clause.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 251
Database Compatibility for Oracle® Developers Guide
3.8 Static Cursors
Rather than executing a whole query at once, it is possible to set up a cursor that
encapsulates the query, and then read the query result set one row at a time. This allows
the creation of SPL program logic that retrieves a row from the result set, does some
processing on the data in that row, and then retrieves the next row and repeats the
process.
Cursors are most often used in the context of a FOR or WHILE loop. A conditional test
should be included in the SPL logic that detects when the end of the result set has been
reached so the program can exit the loop.
3.8.1 Declaring a Cursor
In order to use a cursor, it must first be declared in the declaration section of the SPL
program. A cursor declaration appears as follows:
CURSOR name IS query;
name is an identifier that will be used to reference the cursor and its result set later in the
program. query is a SQL SELECT command that determines the result set retrievable by
the cursor.
Note: An extension of this syntax allows the use of parameters. This is discussed in more
detail in Section 3.8.8.
The following are some examples of cursor declarations:
CREATE OR REPLACE PROCEDURE cursor_example
IS
CURSOR emp_cur_1 IS SELECT * FROM emp;
CURSOR emp_cur_2 IS SELECT empno, ename FROM emp;
CURSOR emp_cur_3 IS SELECT empno, ename FROM emp WHERE deptno = 10
ORDER BY empno;
BEGIN
...
END;
3.8.2 Opening a Cursor
Before a cursor can be used to retrieve rows, it must first be opened. This is accomplished
with the OPEN statement.
OPEN name;
name is the identifier of a cursor that has been previously declared in the declaration
section of the SPL program. The OPEN statement must not be executed on a cursor that
has already been, and still is open.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 252
Database Compatibility for Oracle® Developers Guide
The following shows an OPEN statement with its corresponding cursor declaration.
CREATE OR REPLACE PROCEDURE cursor_example
IS
CURSOR emp_cur_3 IS SELECT empno, ename FROM emp WHERE deptno = 10
ORDER BY empno;
BEGIN
OPEN emp_cur_3;
...
END;
3.8.3 Fetching Rows From a Cursor
Once a cursor has been opened, rows can be retrieved from the cursor’s result set by
using the FETCH statement.
FETCH name INTO { record | variable [, variable_2 ]... };
name is the identifier of a previously opened cursor. record is the identifier of a
previously defined record (for example, using table%ROWTYPE). variable,
variable_2... are SPL variables that will receive the field data from the fetched row.
The fields in record or variable, variable_2... must match in number and order,
the fields returned in the SELECT list of the query given in the cursor declaration. The
data types of the fields in the SELECT list must match, or be implicitly convertible to the
data types of the fields in record or the data types of variable, variable_2...
Note: There is a variation of FETCH INTO using the BULK COLLECT clause that can
return multiple rows at a time into a collection. See Section 3.12.4 for more information
on using the BULK COLLECT clause with the FETCH INTO statement.
The following shows the FETCH statement.
CREATE OR REPLACE PROCEDURE cursor_example
IS
v_empno NUMBER(4);
v_ename VARCHAR2(10);
CURSOR emp_cur_3 IS SELECT empno, ename FROM emp WHERE deptno = 10
ORDER BY empno;
BEGIN
OPEN emp_cur_3;
FETCH emp_cur_3 INTO v_empno, v_ename;
...
END;
Instead of explicitly declaring the data type of a target variable, %TYPE can be used
instead. In this way, if the data type of the database column is changed, the target variable
declaration in the SPL program does not have to be changed. %TYPE will automatically
pick up the new data type of the specified column.
CREATE OR REPLACE PROCEDURE cursor_example
IS
v_empno emp.empno%TYPE;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 253
Database Compatibility for Oracle® Developers Guide
v_ename emp.ename%TYPE;
CURSOR emp_cur_3 IS SELECT empno, ename FROM emp WHERE deptno = 10
ORDER BY empno;
BEGIN
OPEN emp_cur_3;
FETCH emp_cur_3 INTO v_empno, v_ename;
...
END;
If all the columns in a table are retrieved in the order defined in the table, %ROWTYPE can
be used to define a record into which the FETCH statement will place the retrieved data.
Each field within the record can then be accessed using dot notation.
CREATE OR REPLACE PROCEDURE cursor_example
IS
v_emp_rec emp%ROWTYPE;
CURSOR emp_cur_1 IS SELECT * FROM emp;
BEGIN
OPEN emp_cur_1;
FETCH emp_cur_1 INTO v_emp_rec;
DBMS_OUTPUT.PUT_LINE('Employee Number: ' || v_emp_rec.empno);
DBMS_OUTPUT.PUT_LINE('Employee Name : ' || v_emp_rec.ename);
...
END;
3.8.4 Closing a Cursor
Once all the desired rows have been retrieved from the cursor result set, the cursor must
be closed. Once closed, the result set is no longer accessible. The CLOSE statement
appears as follows:
CLOSE name;
name is the identifier of a cursor that is currently open. Once a cursor is closed, it must
not be closed again. However, once the cursor is closed, the OPEN statement can be
issued again on the closed cursor and the query result set will be rebuilt after which the
FETCH statement can then be used to retrieve the rows of the new result set.
The following example illustrates the use of the CLOSE statement:
CREATE OR REPLACE PROCEDURE cursor_example
IS
v_emp_rec emp%ROWTYPE;
CURSOR emp_cur_1 IS SELECT * FROM emp;
BEGIN
OPEN emp_cur_1;
FETCH emp_cur_1 INTO v_emp_rec;
DBMS_OUTPUT.PUT_LINE('Employee Number: ' || v_emp_rec.empno);
DBMS_OUTPUT.PUT_LINE('Employee Name : ' || v_emp_rec.ename);
CLOSE emp_cur_1;
END;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 254
Database Compatibility for Oracle® Developers Guide
This procedure produces the following output when invoked. Employee number 7369,
SMITH is the first row of the result set.
EXEC cursor_example;
Employee Number: 7369
Employee Name : SMITH
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 255
Database Compatibility for Oracle® Developers Guide
3.8.5 Using %ROWTYPE With Cursors
Using the %ROWTYPE attribute, a record can be defined that contains fields corresponding
to all columns fetched from a cursor or cursor variable. Each field takes on the data type
of its corresponding column. The %ROWTYPE attribute is prefixed by a cursor name or
cursor variable name.
record cursor%ROWTYPE;
record is an identifier assigned to the record. cursor is an explicitly declared cursor
within the current scope.
The following example shows how you can use a cursor with %ROWTYPE to get
information about which employee works in which department.
CREATE OR REPLACE PROCEDURE emp_info
IS
CURSOR empcur IS SELECT ename, deptno FROM emp;
myvar empcur%ROWTYPE;
BEGIN
OPEN empcur;
LOOP
FETCH empcur INTO myvar;
EXIT WHEN empcur%NOTFOUND;
DBMS_OUTPUT.PUT_LINE( myvar.ename || ' works in department '
|| myvar.deptno );
END LOOP;
CLOSE empcur;
END;
The following is the output from this procedure.
EXEC emp_info;
SMITH works in department 20
ALLEN works in department 30
WARD works in department 30
JONES works in department 20
MARTIN works in department 30
BLAKE works in department 30
CLARK works in department 10
SCOTT works in department 20
KING works in department 10
TURNER works in department 30
ADAMS works in department 20
JAMES works in department 30
FORD works in department 20
MILLER works in department 10
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 256
Database Compatibility for Oracle® Developers Guide
3.8.6 Cursor Attributes
Each cursor has a set of attributes associated with it that allows the program to test the
state of the cursor. These attributes are %ISOPEN, %FOUND, %NOTFOUND, and
%ROWCOUNT. These attributes are described in the following sections.
3.8.6.1 %ISOPEN
The %ISOPEN attribute is used to test whether or not a cursor is open.
cursor_name%ISOPEN
cursor_name is the name of the cursor for which a BOOLEAN data type of TRUE will be
returned if the cursor is open, FALSE otherwise.
The following is an example of using %ISOPEN.
CREATE OR REPLACE PROCEDURE cursor_example
IS
...
CURSOR emp_cur_1 IS SELECT * FROM emp;
...