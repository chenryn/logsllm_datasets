denotes the kth execution of Fi. A task Ti appears exactly
once in Fi and tasks belonging to different graph iterations
may execute within a single frame.
ri
The valid scheduling range for Tj within the frame is
given by [rj, dj] where rj and dj denote its release time and
deadline, respectively. In addition to the task folding dis-
cussed earlier, these parameters are also determined by a
combination of precedence and performance constraints as
follows:
wij
→
T i
T j
Release time: If
, then the message (data) pro-
duced by Ti must be consumed by Tj only after a delay
wij. This minimum timing separation between tasks
determines Tj’s release time. Production and consump-
tion of messages may also occur between folded tasks.
Deadline: A task’s deadline is determined by a combi-
nation of cyclical task dependencies and performance/
diagnosis requirements:
wij
→
T i
T j
Cyclical task dependencies: Consider
where
the ith iteration of Tj is folded and executes with the (i
+ 1)th iteration of Ti in a frame. Task Tj must consume
the message generated by its predecessor Ti before
being overwritten by a newer version. Therefore,
pipelining causes cyclical dependencies between a
task and its predecessor(s) even in an acyclic graph
which must be addressed during frame generation.
For example, in Fig. 5(b), the ith iteration of T4 must
complete before its input data is overwritten by the (i
+ 1)th iteration of T6.
Performance/Diagnosis constraints: Prior to folding
the tasks, each Tj in the graph has a deadline dj,
derived from designer-speciﬁed performance and
diagnosis constraints. This task deadline must be
transformed during the scheduling process to account
for task folding.
3.3 Task Scheduling
This section presents a static list-scheduling algorithm
which maps the task graph on a set of processors. List
scheduling is a general class of scheduling heuristics
where tasks are assigned priorities and placed in a list in
decreasing order of priority. Whenever tasks compete for
processors, those with higher priorities are scheduled first
Procedure LIST (Gi) /* Gi := Task graph */
/* Initialization */
sP := Set of kmin processors;
s := ∅;
s := s ∪ {Ti | Ti is an entry task in Gi};
for (each Ti ∈ s) begin
Compute scheduling range [ri, di];
end;
/* Task selection and frame generation */
while (unscheduled tasks remain in Gi) begin
while (s ≠ ∅) begin
Select random Ti;
FRAME (Ti, sP);/* Schedule Ti on processor */
end;
s := s ∪ {Ti | Ti’s immediate predecessors in Gi
 have been scheduled};
/* Updating */
for (each Ti ∈ s) begin
Compute [ri, di] using a combination of folding,
precedence and performance constraints;
end;
end;
return frames;
Figure 6. The list scheduling algorithm
[22]. The proposed algorithm accommodates pipelining
and schedules tasks in a level-based fashion starting with
the entry tasks. It can be extended in a straightforward
manner to handle multiple task graphs.
The lower bound kmin on the number of processors
needed to schedule Gi is given by its workload and fault-
tolerance requirements. Clearly, no two redundant copies
of a control or diagnostic task in Gi should be allocated to
the same processor. For example, since G1 is realized in
triple-modular fashion in Fig. 4, at least three processors
are needed. We also assume that the designer-specified
constraints are applied to a sub-portion of the graph to
obtain the corresponding task deadlines. In the case of
graph G1, task deadlines within the actuator-control por-
tion are derived from its period. The scheduling algorithm
shown in Fig. 6 consists of the following major steps:
(1) Initialization: The scheduling ranges of all entry
tasks in Gi are determined.
(2) Task selection: This step computes the set of ready
tasks. A task Ti is ready to be scheduled if it is an entry
task having no successors, or its predecessors have all
been scheduled. Each Ti has a scheduling range [ri, di].
(3) Frame generation: A ready task is scheduled as
soon as possible (ASAP) within a frame. This step is
discussed in more detail later in this section.
(4) Updating: Once all ready tasks from step (2) are
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:24:42 UTC from IEEE Xplore.  Restrictions apply. 
Procedure FRAME (Ti, sP) /* Ti := Task to be scheduled; sP := Processor list */
if (Ti is a sensing or actuation task) schedule Ti on Si (Ai);
if (Ti is a control or buffering task) begin
scand := {Pi ∈ sP | Ti is potentially schedulable on Pi};
while (scand ≠ ∅) begin
Pi := Processor with minimum task load in scand;
Fi := Frame obtained by ASAP scheduling of Tj;
if (Fi ≠ ∅) return frame;
/* Feasible frame found on Pi; return */
/* Ti is a control or buffering task */
/* Frame is infeasible; remove Pi and continue search */
end;
scand := scand − Pi;
end;
if (scand = ∅) begin
sP := sP ∪ Pi;
/* Pi is new processor */
Fi := New frame obtained by ASAP scheduling of Tj;
end;
if (Ti is a diagnosis task) begin
Pi := Processor on which corresponding buffering task Tj is scheduled;
Fi := Frame obtained by ASAP scheduling of Ti;
if (Fi ≠ ∅) return frame;
else begin
/* Feasible frame found on Pi; return */
/* Ti is a diagnosis task */
Unschedule buffering task Tj and place it back in the ready-task list of LIST;
Remove Pi from list of potential candidates for Tj;
end;
end;
Figure 7. The frame generation algorithm
scheduled, the scheduling range of each successor task
Ti in the graph is computed taking into account the pos-
sibility that Ti may have to be folded on to the next
graph iteration, i.e., wrapped around the frame. There-
fore, Ti’s scheduling range [ri, di] is determined appro-
priately taking into account any cyclical precedence
constraints with its predecessors and its deadline from
the original graph. Steps (2), (3), and (4) are repeated
until the graph is completely scheduled.
The FRAME procedure shown in Fig. 7 implements
step (3) of the list-scheduling algorithm. It schedules a task
Ti within an existing frame Fi such that tasks previously
scheduled within that frame continue to satisfy their cor-
rectness constraints. Allocation and scheduling of Ti on a
hardware resource is performed in a single step depending
on the task type.
Sensing and actuation: The task is scheduled on sensor
(actuator) Si (Ai).
Control/buffering: For Ti, we obtain a list of candidate
processors scand in increasing order of utilization. The
procedure returns the ﬁrst processor Pj within this list
which results in a feasible frame. If scand = ∅ or no
member of scand provides a feasible schedule, FRAME
adds a new processor to the system and schedules Ti.
Diagnosis: If Ti is a diagnosis task, its corresponding
buffering task Tj must have been previously scheduled
on some Fk. Therefore, Ti is allocated to Pk and sched-
uled. If however, a feasible frame is not obtained, then
Tj is unscheduled from Fk and placed back in the ready
list for rescheduling on a different processor. The pro-
cessor Pk is removed as a potential candidate for Tj.
Each task Tj is scheduled in preemptive and ASAP fash-
ion within a frame. A task spill occurs when the execution
of task Tj continues across a frame boundary. In such
cases, Tj’s overflow portion is considered a separate task
Tspill which is then scheduled within Fi after suitably
adjusting its scheduling range. Figure 5(d) shows the spill
occurring when T4 is scheduled within F2. After appropri-
ate handling, in the ﬁnal schedule, T4 executes in F2 during
the [600, 700], is preempted by T2, and continues its exe-
cution across the frame boundary from [0, 400].
For multiple graphs G1,..., Gk, the lower bound on the
number of processors kmin is determined using:
kmin max
=
ci
∑
∈
T i Gi
--------------------- max FT Gi
φ
,
(
(
)
)
This formula takes into account the number of processors
needed to accommodate the corresponding workload as
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:24:42 UTC from IEEE Xplore.  Restrictions apply. 
System unsafe!
Ai fails
Diagnose
Diagnose
Diagnose
Ai
Ai
Ai
Shutdown
Ai
ai(k + 1)
ai(k + 2)
ai(k + 3)
ai(k + 4)
ai(k + 5)
ai(k)
...
φ
td
φ
φ
tunsafe
Time
tr
Figure 8. Timeline of events leading to an unsafe
condition
the fault
well as