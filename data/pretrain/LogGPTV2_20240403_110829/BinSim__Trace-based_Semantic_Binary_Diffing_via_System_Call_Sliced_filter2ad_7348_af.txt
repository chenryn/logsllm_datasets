以下是经过优化后的文本，使其更加清晰、连贯和专业：

---

### 参考文献

1. LU, K., ZOU, D., WEN, W., AND GAO, D. deRop: 从恶意软件中移除返回导向编程。第27届年度计算机安全应用会议论文集 (ACSAC'12) (2012).
2. LUO, L., MING, J., WU, D., LIU, P., AND ZHU, S. 基于语义的混淆抵抗二进制代码相似性比较及其在软件剽窃检测中的应用。第22届ACM SIGSOFT国际软件工程基础研讨会论文集 (FSE'14) (2014).
3. MENG, X., AND MILLER, B. P. 二进制代码并不简单。第25届国际软件测试与分析研讨会论文集 (ISSTA'16) (2016).
4. MING, J., PAN, M., AND GAO, D. iBinHunt: 具有跨过程控制流的二进制搜索。第15届信息安全与密码学国际会议论文集 (ICISC'12) (2012).
5. MING, J., XIN, Z., LAN, P., WU, D., LIU, P., AND MAO, B. 替换攻击：自动阻碍基于行为的恶意软件规范。第13届应用密码学与网络安全国际会议论文集 (ACNS'15) (2015).
6. MING, J., XU, D., WANG, L., AND WU, D. LOOP: 在混淆二进制代码中检测逻辑导向的不透明谓词。第22届ACM计算机与通信安全会议论文集 (CCS'15) (2015).
7. MING, J., XU, D., AND WU, D. 基于缓存语义的二进制差异分析及其在恶意软件谱系推断中的应用。第30届ICT系统安全与隐私保护国际会议论文集 (IFIP SEC'15) (2015).
8. MOSER, A., KRUEGEL, C., AND KIRDA, E. 探索多执行路径以进行恶意软件分析。2007年IEEE安全与隐私研讨会论文集 (S&P'07) (2007).
9. MOSER, A., KRUEGEL, C., AND KIRDA, E. 静态分析在恶意软件检测中的局限性。第23届年度计算机安全应用会议论文集 (ACSAC'07) (2007年12月).
10. NG, B. H., AND PRAKASH, A. Exposé: 发现潜在的二进制代码重用。第37届IEEE年度计算机软件与应用会议论文集 (COMPSAC'13) (2013).
11. OH, J. W. 抵抗一天内漏洞利用：二进制差异分析 vs 反二进制差异分析。Black Hat USA 2009, 2009.
12. OKANE, P., SEZER, S., AND MCLAUGHLIN, K. 混淆：隐藏的恶意软件。IEEE安全与隐私 9, 5 (2011).
13. OREANS TECHNOLOGIES. 代码虚拟化器：全面防反编译。http://oreans.com/codevirtualizer.php, 最后审查日期: 2017年2月16日.
14. PANDA SECURITY. 2016年第一季度每天发现227,000个恶意软件样本。http://www.pandasecurity.com/mediacenter/pandalabs/pandalabs-study-q1/.
15. PEWNY, J., GARMANY, B., GAWLIK, R., ROSSOW, C., AND HOLZ, T. 二进制可执行文件中的跨架构漏洞搜索。第36届IEEE安全与隐私研讨会论文集 (S&P'15) (2015).
16. POULIOS, G., NTANTOGIAN, C., AND XENAKIS, C. ROPInjector: 使用返回导向编程实现多态性和反病毒规避。Black Hat USA 2015, 2015.
17. RAMOS, D. A., AND ENGLER, D. R. 实用的低努力等价验证真实代码。第23届国际计算机辅助验证会议论文集 (CAV'11) (2011).
18. ROUNDY, K. A., AND MILLER, B. P. 流行打包工具中的二进制代码混淆。ACM计算调查 46, 1 (2013).
19. SCAIFE, N., CARTER, H., TRAYNOR, P., AND BUTLER, K. R. CryptoLock (并丢弃它)：阻止针对用户数据的勒索软件攻击。第36届IEEE分布式计算系统国际会议论文集 (ICDCS'16) (2016).
20. SCHRITTWIESER, S., KATZENBEISSER, S., KIESEBERG, P., HUBER, M., LEITHNER, M., MULAZZANI, M., AND WEIPPL, E. 隐蔽计算：为混淆目的将代码隐藏在代码中。第8届ACM SIGSAC信息、计算机和通信安全研讨会论文集 (ASIACCS'13) (2013).
21. SHACHAM, H. 无辜肉体上的几何：无需函数调用的返回到库 (x86平台)。第14届ACM计算机与通信安全会议论文集 (CCS'07) (2007).
22. SHARIF, M., LANZI, A., GIFFIN, J., AND LEE, W. 自动逆向工程恶意软件模拟器。2009年IEEE安全与隐私研讨会论文集 (S&P'09) (2009).
23. SHI, Y., GREGG, D., BEATTY, A., AND ERTL, M. A. 虚拟机对决：栈 vs 寄存器。第1届ACM/USENIX虚拟执行环境国际会议论文集 (VEE'05) (2005).
24. SIKORSKI, M., AND HONIG, A. 使用FakeNet 2.0伪造管道。BlackHat EUROPE 2014, 2014.
25. SMITH, J., AND NAIR, R. 虚拟机：系统和进程的多功能平台 (The Morgan Kaufmann Series in Computer Architecture and Design). Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 2005.
26. SMITH, T. F., AND WATERMAN, M. 常见分子子序列的识别。分子生物学杂志 147, 1 (1981).
27. SONG, D., BRUMLEY, D., YIN, H., CABALLERO, J., JAGER, I., KANG, M. G., LIANG, Z., NEWSOME, J., POOSANKAM, P., AND SAXENA, P. BitBlaze：通过二进制分析的新计算机安全方法。第4届信息系统安全国际会议论文集 (ICISS'08) (2008).
28. SOOS, M., NOHL, K., AND CASTELLUCCIA, C. 将SAT求解器扩展到密码学问题。第12届可满足性测试理论与应用国际会议论文集 (SAT'09) (2009).
29. UGARTE-PEDRERO, X., BALZAROTTI, D., SANTOS, I., AND BRINGAS, P. G. SoK: 深度打包检查：运行时打包器复杂性的纵向研究。第36届IEEE安全与隐私研讨会论文集 (2015).
30. VMPROTECT SOFTWARE. VMProtect软件保护。http://vmpsoft.com, 最后审查日期: 2017年2月16日.
31. VMRAY. VMRay Analyzer. https://www.vmray.com/, 最后审查日期: 2017年2月16日.
32. WANG, C., HILL, J., KNIGHT, J. C., AND DAVIDSON, J. W. 基于软件的生存能力机制的保护。2001年国际依赖系统和网络会议论文集 (2001).
33. WANG, T., WEI, T., GU, G., AND ZOU, W. 结合动态污点分析和符号执行的校验和感知模糊测试。ACM信息与系统安全事务 (TISSEC) 14, 15 (2011年9月).
34. WANG, X., JHI, Y.-C., ZHU, S., AND LIU, P. 基于行为的软件盗版检测。第16届ACM计算机与通信安全会议论文集 (CCS'09) (2009).
35. WARREN, H. S. 黑客的乐趣。Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 2002.
36. XU, D., MING, J., AND WU, D. 通过位精确符号循环映射在混淆二进制文件中检测加密函数。第38届IEEE安全与隐私研讨会论文集 (S&P'17) (2017).
37. XU, Z., ZHANG, J., GU, G., AND LIN, Z. AUTOVAC: 自动提取系统资源约束并生成恶意软件免疫疫苗。第33届分布式计算系统国际会议论文集 (ICDCS'13) (2013).
38. XU, Z., ZHANG, J., GU, G., AND LIN, Z. GoldenEye: 高效有效地揭示针对环境的恶意软件。第17届攻击、入侵和防御研究国际研讨会论文集 (RAID'14) (2014).
39. YADEGARI, B., AND DEBRAY, S. 混淆代码的符号执行。第22届ACM SIGSAC计算机与通信安全会议论文集 (CCS'15) (2015).
40. YADEGARI, B., JOHANNESMEYER, B., WHITELY, B., AND DEBRAY, S. 一种通用的自动去混淆可执行代码的方法。第36届IEEE安全与隐私研讨会论文集 (S&P'15) (2015).
41. ZHANG, X., GUPTA, R., AND ZHANG, Y. 精确的动态切片算法。第25届国际软件工程会议论文集 (ICSE'03) (2003).

### 附录

#### 表7：示例：关键系统调用/Windows API

| 对象 | 关键系统调用/Windows API |
| --- | --- |
| 文件 | NtCreateFile, NtOpenFile, NtClose, NtQueryDirectoryFile, NtSetInformationFile |
| 注册表 | NtCreateKey, NtOpenKey, NtSaveKey |
| 内存 | NtAllocateVirtualMemory, NtMapViewOfSection, NtWriteVirtualMemory |
| 进程 | NtCreateProcess, NtOpenProcess, NtTerminateProcess |
| 线程 | NtCreateThread, NtResumeThread, NtTerminateThread |
| 网络 | connect, bind, send, recv, gethostname |
| 桌面 | CreateDesktop, SwitchDesktop, SetThreadDesktop |
| 其他 | LoadLibrary, GetProcAddress, GetModuleHandle |

#### 表8：具有隐式分支逻辑的指令

| 指令 | 含义 |
| --- | --- |
| CMOVcc | 条件移动 |
| SETcc | 根据条件设置操作数为1或0 |
| CMPXCHG | 比较并交换 |
| REP-前缀 | 重复操作，上限存储在ecx寄存器中 |
| JECXZ | 如果ecx寄存器为0则跳转 |
| LOOP | 使用ecx作为计数器进行循环操作 |

#### 图12：两种不同的isPowerOfTwo算法

```c
int isPowerOfTwo_1(unsigned int x) {
    while (((x % 2) == 0) && x > 1)
        x /= 2;
    return (x == 1);
}

int isPowerOfTwo_2(unsigned int x) {
    unsigned int numberOfOneBits = 0;
    while (x) {
        if (x & 1)
            numberOfOneBits++;
        x >>= 1;
    }
    return (numberOfOneBits == 1);
}
```

#### 图11：图3所示三种BitCount算法的反汇编代码

```
(a)
cmp     [ebp+8], 0
jnz    loc_8000016
loc_8000016:
mov     eax, [ebp+8]
and     eax, 1
add     [ebp-0xC], eax
shr     [ebp+8], 1
printf ("%d", count)

(b)
cmp     [ebp+8], 0
jnz    loc_800004D
printf ("%d", count)
loc_800004D:
mov     eax, [ebp+8]
sub     eax, 1
and     [ebp+8], eax
add     [ebp-0xC], 1

(c)
mov     eax, [ebp+8]
mov     edx, eax
and     edx, 55555555h
mov     eax, [ebp+8]
shr     eax, 1
and     eax, 55555555h
add     eax, edx
mov     [ebp+8], eax
...
printf ("%d", n)
```

#### 图13：三种不同的flp2算法

```c
unsigned flp2_1(unsigned x) {
    x = x | (x >> 1);
    x = x | (x >> 2);
    x = x | (x >> 4);
    x = x | (x >> 8);
    x = x | (x >> 16);
    return x - (x >> 1);
}

unsigned flp2_2(unsigned x) {
    unsigned y = 0x80000000;
    while (y > x) {
        y = y >> 1;
    }
    return y;
}

unsigned flp2_3(unsigned x) {
    unsigned y;
    do {
        y = x;
        x = x & (x - 1);
    } while (x != 0);
    return y;
}
```

这些算法用于查找小于给定整数x的最大2的幂。

---

希望这些改进对您有所帮助！如果有任何进一步的需求，请随时告诉我。