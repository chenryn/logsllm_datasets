原文：
这篇博客是年度的[12 Days of HaXmas](https://blog.rapid7.com/tag/haxmas/)系列博客中的第11篇。
Executable and Linkable Format ( ELF )
是许多类Unix操作系统（如Linux，大多数现代BSD和Solaris）的基础。ELF文件有许多技巧，比如我们在[our *nix Meterpreter
implementation](https://www.slideshare.net/BrentCook2/static-pie-how-and-why-metasploits-new-posix-payload-mettle)中使用的那些，但那些技巧需要使用我们的特殊 toolchain
或带有`-static-pie`标志的GCC
8+来构建每个可执行文件。如果环境不同怎么办呢？内核加载和运行代码时并不需要磁盘上的文件，下面我们看下如何在没有execve的情况下运行Linux可执行文件。
## 手工制作镜像
也许最有效的可执行格式技巧是`反射加载(reflective loading)`。
`反射加载`是后渗透阶段的一种重要技术，用于逃避检测和在受限制的环境中执行复杂命令。 它通常有三个广泛的步骤：
  1. 使代码执行（如：利用漏洞或网络钓鱼）
  2. 从某个地方抓取自己的代码
  3. 使操作系统运行你自己的代码（但是不像普通进程那样加载）
最后一步是反射加载的关键。 环境限制越来越多，普通的进程启动方式目标非常明显。
传统的防病毒会扫描磁盘上的文件，新进程启动时会进行代码签名完整性检查，行为监控会不断检查以确保进程没有恶意行为。
背后的思想是，如果攻击者无法运行任何程序，他们就无法做任何事情，系统也是安全的。这不完全正确，阻挡常见的攻击路径只是让事情变得更加困难。
特别是，对于使用可移植可执行（PE）格式的Windows环境，我们已经看到过很多关于这个主题的研究，因为Windows使用广泛，而且操作系统中内置了非常有用的反射构造模块。
事实上，它具有这类工作的黄金标准API：`CreateRemoteThread`及其他相关API，这不仅仅允许攻击者加载代码，而且可以将代码注入其他正在运行的进程。
尽管缺乏如Windows中的`CreateRemoteThread`这样有趣的反射注入API，最近几年我们依然看到了一些有趣的研究，通过非常规的方法来使以开发者中心的Linux特性为安全所用。比如这是一个很好的命令行途径的案例：
Linux上的这些方法可以分为五类：  
**· 写入临时文件：** 这与典型代码没有太大区别，但它不会留下磁盘成品文件。  
**· 注入`ptrace`：**这需要一些精巧的控制，比如经典的`process-hopping`。  
**· 自修改可执行文件：**`dd`是经典之作，它需要一些比较小的定制shellcode。  
**· 脚本语言中集成的FFI：** Python和Ruby都可以，当前技术只能加载shellcode。  
**· 创建非文件系统的临时文件：** 这使用2014年添加的系统调用，因此它即将广泛使用。
## 严格的工作条件
很少有人密切关注他们的Linux机箱（如果你这样做了，那么恭喜！），但这些技术风格除了上面提到的各自的技术挑战外，还有安全/操作方面的考虑。
如果您处于安全对抗中的防守方，可以考虑用以下方式阻止远程攻击者：
### 临时文件
越来越常见的是查找`/tmp`和`/dev/shm`挂载了`noexec`（即，该树中没有文件可以执行），特别是在移动和嵌入式系统上。
说到嵌入式系统，那些嵌入式系统通常也只有只读的持久文件存储，所以你甚至无法回退来阻止别人查看磁盘。
### 自修改可执行文件和`ptrace`
访问`ptrace`和`/proc/`中的大多数有趣的自检由`kernel.yama.ptrace_scope`
`sysctl`变量[控制](https://linux-audit.com/protect-ptrace-processes-kernel-yama-ptrace_scope/)。在未用于开发的盒子上，应将其设置至少为2以删除非特权用户的访问权限。
这在许多移动和嵌入式系统上是默认的，而现代桌面/服务器发行版默认至少为1，这降低了它在跨进程中疯狂跳跃的实用性。
此外，它是特定用于Linux，所以没有可爱的BSD shells。
### FFI（Foreign Function Interface）集成
[Ruby](https://ruby-doc.org/stdlib-2.5.0/libdoc/fiddle/rdoc/Fiddle.html)的`fiddle`和[Python](https://docs.python.org/3/library/ctypes.html)的`ctypes`特别灵活，并且很多小东西都可以灵活的像解释型的C语言一样运行。但是，它们没有汇编程序，所以任何使用寄存器或引导到不同可执行文件的细节都需要使用shellcode来完成。
您也永远不知道目标系统会安装哪个版本的环境。
### 非文件系统的临时文件
同样是Linux特有的技巧。我能调用一对新的syscalls，它们组合起来可以绕过任何`noexec`标志（内核4.19.10测试通过）。
第一个系统调用是`memfd_create`（2），在内核3.17版本中添加，它分配一个具有默认权限的新临时文件系统，并在其中创建一个文件，除`/proc`目录，该文件不会显示在其他任何已挂载的文件系统中。第二个系统调用是`execveat`（2），在内核版本3.19中添加。它可以采用文件描述符并将其传递给内核以供执行。缺点是创建的文件可以很容易地通过`find
/proc/*/fd -lname
'/memfd:*'`找到，因为所有的`memfd_create`（2）文件都表示为具有常量前缀的符号链接。这个功能在普通软件中很少使用，我仅找到过一个这种用法的普通程序，那是在2016年被添加到PulseAudio中的。