：对应到MakeStingRequest的实际字段：
，在此整理如下：
---
## Page 321
Result 类有两个子类。Future 参与者 FutureResult 类与 RealData 参与者 RealResult 类、
“主动对象”端：Result类
回值"，所以不需要使用 Future Patterm（第9章）。
建立 DisplayStringRequest 实例的，则是Proxy 类的 displayString 万法。
“主动对象”端：DisplayStringRequest 类
Result类（List 12-12）相当丁Future Pattern（第9章）的VirtualData 参与者。
package activeobjecr;
DisplaySiringRequest 类对应的是 ActiveObjeci 接口的 displayString 方法。实际
DisplayStringRequest类（List12-11）表示“显示字符串”。
List 12-11
public vo:d execute() !
pubiic JisplaystringRequest(Servant servant, String string)
private final String string;
pub-ic vo.d exerit=()f
public MakeStringRequest (servant servant, FutureResult future,
private fi:al char fillchar;
private firal inc count;
servant..displaystrirg(string):
this.strirg = strirg:
super(servant, Iull);
future.setResuit(resut);
Resuil result v servant.makeString(count, fillchar):
this.tilichar = [illchar;
this.count = ccunt;
superiservant, future);
DisplayStringRequest 类(DisplayStringRequest.java)
Active Object-
接受异步消息的主动对象
12#
---
## Page 322
308
回值已经设置了”
“返回值”时则可使用getResultvalue方法，
就是川来管理“返回值”的类。要设置“返回值”时可使用 setResult方法，要获取
“主动对象”端：FutureResult类
就是可以轻松地与知道这个Pattem 的程序员互相沟通。
FutureResult类（List 12-13）是Future Pattern（第9章）的Future参与者，也
若您L经了解Future Patterm，上述的说明应该已经足够了。使用Patterm 的好处
Result 的 getResultValue方法是抽象方法，也就是希望由子类实现。
private Result result;
class FutureResult extends Result
package activeobject;
public abstract class Result {
package activecbject;
List 12-13
'List 12-12
 public abstract Object getResultvalue();
public syachronized object getResultVaiue() l
public synchronized void setResult(Result result)
private boolean ready = faise;
return resuit.getResultvalue():
while (!ready)
notifyail();
Lhis.result - result;
this.ready = true;
Result 类(Resultjava)
try {
FutureResult 类(FutureResuit.java)
catch (:nterruptedExceptior e) ↑
wait ();
1
---
## Page 323
类、Servant 类这些实现的部分，是隐藏在 activeobject 包里的。
类与 Servant类，都实现了相同的ActiveObject接口。
明成 java.lang.String 也可以。
“主动对象”端：Servant类
程序通月性，resulivalue 的类型设置成 java.lang.Object。就范例程序而言，其实声
Tt
是为了使用Future Pattern，而将resultValue字段包装（wrap）起来的类。为了增加
“主动对象”端：RealResult类
makeString 方法与displayString 方法，在里而进行实际的处理。
而这里iF是精彩的地方，Servant类实现了ActivcObject接口。也就是说，Proxy
Scrvant类（List 12-15）是ActiveObject 端实际进行处理的部分。Servant 类具
不过，请揉操眼睛吧，这里是很重要的地方。
“动对象”的接口（API），以 ActiveObject 接口的形式对包外公开。而 Proxy
●Servant 类
●Proxy 类
●ActiveObjeci 接口
再进一步，请注意对包外公开的部分：
上述两者“各种方法”，可在程序代码1明确长现出都是一致的。
●实际执行“主动对象”的各种方法（由Servant类实现），
这样一米，
因为这一·章的范例种序中类数量真的很多，或许有些读者已经看到快要打哈欠
class RealResult exterds Result I
package activeobject;
List 12-14. :
private firal Obgect resultvalue;
1 (1anteastnsaaiab ioalao oitand
public RealResult(object resultValue)
 this.resultValue = resultvalue:
return resultvalue;
ReaiResult 类 ( RealResultjava)
非 public（默认访问权限）。
甘public（默认访问权限）：
public 的部分；
Active Object-
一接受异步消息的主动对象
12
---
## Page 324
示字符串）也渐渐连在－起出现，
明显看出处理所花的时间也渐渐增加。所以从执行结果可以看出，Chris 的部分（显
Chris 线程传米的显示字符中请求。因为Alice与 Bobby 建立的字符串越来越长，可
displayString 方法重复显示 Chris 0、Chris 1、Chris 2、
立连续B字母的字符串（空字符串、B、BB、BBB、…….)）。另一边，Chris 会以
字母的字符出（空字符串、A、AA、AAA、……….），Bobby会以makeString 方法建
执行范例程序
310
执行范例程序后，结果如图12-3所示。
class Servant implemenzs Activeobject {
package activeobject;
List 12-15
public void displayString(String string) {
public Resuit makestring(int count, char fillchar) f
try i
return new RealResuit(new String(buffer));
char[] buffer = new char[count];
catch (InterruptedException e) {
 Thread.sleepli0);
Systen.out.println("displayString: " + string);
try l
buffer[ii - fillcbar;
Servant 类(Servant.java)
Bobby: value =BB
displayString: Chris 1
Bobby: value
displaystring: Chris 0
catch (InterruptedException e) [
Alice: value =
Bobby: vaiue
Alice: value
Alice: value
Thread.sleep(lc0);
1
2
Alice 会以 makeString 方法建立连续 A
、…..….字符串。
---
## Page 325
考，
方法。这里使用了Future Pattern（第9章），
参与者：
者还没积满的情况下），控制权马上会回来。
使用的ActiveObject 参!者提供的方法。调用这些方法后（在 ActivationQueue 参与
Client（委托人）参与者
他章节学过的 Pattern，建议读者在阅读时可以边确认。
图 12-4的类图对照阅读，会比较容易理解。另外，这个 Patterm 融入了一些本书其
Active ObjectPattern的所有参与者
范例程I序甲，MakerClientThread类与DisplayClicntThread 类都是 Client 参
Client参上者要获取执行结果时，必须调用VirtualRcsult参与者的getResultValue
Client 参与者只知道 ActiveObject 参与者的存在，不过实际调用到的是 Proxy
Client参与者会调川ActiveObjcct 参与者，将工作委托别人。Client参与者可以
Active Object Patem 的所有参与者如下所示。因为参与者非常的多，所以请与
diaplaystring: Chris 15
dieplaystring: Chris 14
displaystring:
Alice: vaiue -
displays:ring:
displaystring:
Bobhy: value
displaystr:rg:
displaystring:
Alice: valre -
dispiaystring:
（以下省略，CTRL+C结束程序）
dispieystring:
Bobby: value=
displaystring:
displaystring:
Alire: va-ue
Robby: vaiuc-
displaystring: 
displayst:ing: Chris
Alice: value - AAA
dlspiayslring: Chris 2
图12-3执行范例
： Chris
Active Object
crris 13
AAAAAA
BBBBB
(hris
BBBB
chris
AAAA
Chr!s
Chris
AAAAA
Chris
Chris
Chris
11
10
L
一接受异步消息的主动对象
（续上图）
12
---
## Page 326
Java象线精谐研模式
处理这个请求的 Servant 参与者、用来写入返回值的Future 参与者，与用来“执行”
MethodReguest 参易者
没有定义特殊的调度方式，只使用了一般的FIFO。
已实现请求调度算法，就要写在这里。这就是名为 Scheduler 参与者的原因。
者）来执行。所以 Scheduler 参与者可以判断下一个要进行的仆么任务。如果要自
已的线程在进行的。在 Active Object Patterm 里，只有 Client 参与者与 Scheduler 参
者的线程进行的。
MethodRequest 参与者来执行。
与者传给ActivationQueue参与者，
Scheduler泰易者
Scheduler参与者这部分的工作，是山 Client 参与者的线程进行的。
Proxy（代理者）参与者
ActiveObject（重动对象）参易者
与者是线程。
  甲   
注4：附录E的[POSA2]书中，本|的execute方法使用了 call 方法的名称。
注3:本书中为了明确定义出界面（AP1)，所以加入了ActiveObject 参与者，附录E的[POSA2]
MethodRequest 参与者是Client 参与者的请求所对应的对象形式。规定了用来
范例程序中，Scheduler 参'者是 SchedulerThread 类。SchedulerThread 类里，
Scheduler 参与者会从ActivationQueue 参与者里取出任务（MethodRequest 参与
而从ActivationQueue参与者取出MethodRequest参与者来执行的工作，则是自
Scheduler 参与j者做两件事，
Proxy 参与者的I.作是将方法调用转换为 MethodRequest 参!与j者的对象形式.转
范例程序中，Proxy参与者是Proxy接。
会调用 Proxy 参与者的是 Client 参与者：转换成 MethodRequest 参与者、传给
Proxy参与者会实现ActvieObject 参与者所提供的接口（API）。
范例程序中，ActiveObject 参与者是ActiveObject 接口"3。
ActiveObject 参与者规定了“主动对象”要对Client 参与者公开的接口（API)。
[POSA2]中,
-是将从 Proxy 参与者处传入的 MethodRequest 参
Client 参与者是直接调用Proxy参与者。
一.是从ActivationQueue参与j者取出
---
## Page 327
Pattern（第9章）。
VirtuaiResuit（虚拟韵结果）参与者
参与者的线程。这里使用了Producer-Consumer Patterm（第5章）。
ActivationQueue（活性化队列）参岛者
请求的顺序。
实际执行。在 Proxy 参与者与 Servant 参与者之间加上 Scheduler 参与者，管理执行
并调用 MethodRequest 参与者的 execute 万法。在 execute 方法望调用了 Servant 参
参与者里取出MethodRequest 参与者（实际上是ConcreteMethodRequest参与j者），
Servant（人）参易者
立字符串），而 DisplayStringRequest类对应到displayString 方法（显示字符串）。
ConcreteMethodRequest 参与者。 MakeStringRequest 类对应到 makeString 方法（建
MethodAlphaRequesl、 MethodBetaRequest.
者。ActiveObject参与者里所定出的方法，要逐一卢明成MethodAlphaRequest、
ConcreteMethodRequest 参易者
与者的方法。
VirtualResult 参与者与 Future 参与者、RealResult 参与者合在一起构成了 Future
范例程序中，ActivationQueue 参与者是ActivationQueue 类。
范例程序中，Servant 参与者是 Servant 类。
请求会先由 Proxy 参与者转换成 MethodRequcst 参号者，而li Servant 参与者米
Servant 参j者实现“ActivcObject参与者提供的接口（API）。
调用putRequest 的是Client参者的线程，而调用 takeRequest 的则是Scheduler
调用Servant 参与者的是 Scheduler参与者。Seheduler参者会从ActivationQueue
Servant 参与者实际负责处理请求。
ConcreteMethodRequest 参与者里定义的字段，就是方法的参数。
ConcreteMethodRequest 参与者是实际对应到具体的方法的 MethodRequest 参与j
ActivationQueue 参与者是用来存放MethodRequest参与者的类。
范例程序I中，MethodRequest 参与者是MethodReqeust 类。
Active Object-
接受异步消息的主动对象
12
---
## Page 328
是说，Active Object Pattern作到了“异步的方法”。这也可以说是作到了“异步的消息”
要使用 Future Pattern 张取“返回值".
包里的所有参与者。Client 参与者会调用ActiveObject 参与者的“方法"，并配合需
一步，来重新看过-一-次整体轮廓吧，左边是Client 参与者，而右边是 activeobject
到底是在做什么啊？”。
到底做了什么事呢
参与者，作为实际的处理结果，并设置给Future参与者，
扩展思考方向的提示
ReaiResuft（实际的结果）参与者
者的线程等待。
果还没有运算出来，会使用Guarded Suspension Pattern（第3章），要求Client 参与
Future（期货）参乌者
参与者）的getResultValue方法。
这·章读到这里，相信一定有读者觉得“－-次用到很多Pattem 虽然很有趣，但
接下来我们要看的是activeobject 包的属性。我们可看出，通过activeobject 包
与平常不同的是，在这里“方法”是由IClient 参与者以外的线程在执行的。也就
Active Object Pattern的类图（图12-4）真的十分复杂。可是，我们就在此后退
●具有接口（API）一一
范例程序中，RealResult 参与者是RealResult 类。
RealResult参与者用来表示实际的处理结果。Servant 参与者会建立山RealResult
范例程序中，Future 参与者是FutureResult类。
Future 参'与者是在想要获取处理结果时，实际被调用的参与者。如果处理的结
范例程I序l，VirtualResult 参与者是Result类。
可以执行处理——Servant 参与者可以单线程执行处理：
与Client 参与者拥有不同的线程一—-Scheduler参与者提供线程;
与者，存放在ActivationQueue参与者里：
—ActiveObject 参与者里定义了API：
---
## Page 329
R
[
图12-5
图12-4
Active Objeci Pattern 的顺序图
Active Object Patern 的类图
Active Object
接受异步消息的主动对象
12
315
---
## Page 330
Pattern是否适合使用要考虑问题的规模
Guarded Suspension Pattem（第3章），程序性能还会比较高。
解释时，问题规模缩小有助十促进理解）。
示字符中”，问题的规模都太小，其实都不适合使用Active Object Pattern（当然书中
这个Pattern 的时候，必须注意问题的规模。所谓问题的规模，是指问题的大小，为
Object Patterm 则是协调许多对象，构成一个“上动对象”。
当规模太小时，与其使用ActivationQueue 参与者将处理线程单一化，还不如使用
参与者与ActivationQueue 参与者进行沟通，这些上作的需要花的时间也不容忽视。
写的范例）等。
明文而自动加I以编码化的模块、进行大量数据收发的网关（这是附录E[POSA2]所
了解决问题所需的处理量，到底有多大，范例程序里用来举例的“建立字符串”、“显
之所以规模太小不适合使用，是因为Proxy参与者建立ConcreteMethodRequest
较人型的间题规模，例如从大量网页查找特定字符串的查找服务、给予密码与
Active Object Pattern 的组成元素很多，是·个大型的Patterm。考虑是否要使用
请回想这一章最前面的比喻。许多个人丘相协调，可以构成一个“法人”。Active
调用
Alpha
methodAlphaProx |
图 12-6Active Object Pattern 的时绪图
gerReul vahue
-- -it-
takeRequrst.
puRequest:
exccute.
:MethodAlp
:MethodAIphaRequest
MethodAlphaReuest
:ActivationQueue
setRealResult
methodAlpha
Servant
---
## Page 331