title:Request and Conquer: Exposing Cross-Origin Resource Size
author:Tom van Goethem and
Mathy Vanhoef and
Frank Piessens and
Wouter Joosen
Request and Conquer:  
Exposing Cross-Origin Resource Size
Tom Van Goethem, Mathy Vanhoef, Frank Piessens, and Wouter Joosen,  
Katholieke Universiteit Leuven
 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/goethem
This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX Request and Conquer: Exposing Cross-Origin Resource Size
Tom Van Goethem, Mathy Vanhoef, Frank Piessens, Wouter Joosen
iMinds-DistriNet, KU Leuven, 3001 Leuven, Belgium
PI:EMAIL
Abstract
Numerous initiatives are encouraging website owners to
enable and enforce TLS encryption for the communica-
tion between the server and their users. Although this en-
cryption, when configured properly, completely prevents
adversaries from disclosing the content of the traffic, cer-
tain features are not concealed, most notably the size of
messages. As modern-day web applications tend to pro-
vide users with a view that is tailored to the information
they entrust these web services with, it is clear that know-
ing the size of specific resources, an adversary can easily
uncover personal and sensitive information.
In this paper, we explore various techniques that can
be employed to reveal the size of resources. As a re-
sult of this in-depth analysis, we discover several design
flaws in the storage mechanisms of browsers, which al-
lows an adversary to expose the exact size of any re-
source in mere seconds. Furthermore, we report on a
novel size-exposing technique against Wi-Fi networks.
We evaluate the severity of our attacks, and show their
worrying consequences in multiple real-world attack sce-
narios. Furthermore, we propose an improved design for
browser storage, and explore other viable solutions that
can thwart size-exposing attacks.
1
Introduction
In 1996, Wagner and Schneier performed an analysis of
the SSL 3.0 protocol [67].
In their research, the au-
thors make the observation that although the content is
encrypted, an observer can still obtain the size of the re-
quested URL as well as the corresponding response size.
The researchers further elaborate that because it is pos-
sible to make an inventory of all publicly available data
on a website, knowing the size of requests and responses
allows an attacker to determine which web page was vis-
ited. Although content is increasingly being served over
secure SSL/TLS channels [55], the length of requests
and responses remains visible to a man-in-the-middle at-
tacker. Consequently, the attack that was described by
Wagner and Schneier two decades ago remains univer-
sally applicable. However, due to the various transitions
the web underwent, the consequences of uncovering the
size of remote resources have shifted drastically.
With the advent of online social networks, the dy-
namic generation of web pages goes even further. When
browsing, each user is now presented with a personalized
version, tailored to their personal preferences and infor-
mation they, or members of their online environment,
(un)willingly shared with these online services. Conse-
quently, the resource that is returned when a user requests
a certain URL will often reflect the state of that user.
Two types of size-exposing attacks, namely traffic
analysis and timing attacks, have been widely studied.
In traffic analysis, an adversary passively observes the
network traffic that is generated by the victim’s brows-
ing behavior. Based on the observed size, sequence, and
timing of requests and responses, an attacker can learn
which website was visited by the victim [13, 25, 68], or
uncover which search queries the user entered [12, 40].
In contrast to traffic analysis, where the threat model is
typically defined as a passive network observer, launch-
ing a web-based timing attack requires the adversary to
trick the victim in making requests to certain endpoints,
which is typically achieved by running JavaScript code
in the victim’s browser. The attacker then measures
the time needed for the victim to download the spec-
ified resources, which, depending on the victim’s net-
work condition, allows him to approximate the resource
size, and ultimately obtain information on the state of the
user [19, 7, 14].
Motivated by the severe consequences on the online
privacy of a vast amount of users, we present a systematic
analysis of possible attack vectors that allow an adver-
sary to uncover the size of a resource. As a result of this
evaluation, we discover design flaws in various browser
features that allow an adversary to uncover the exact size
USENIX Association  
25th USENIX Security Symposium  447
of any resource. Furthermore, we demonstrate that by in-
tercepting and manipulating encrypted Wi-Fi traffic, an
adversary can uncover the exact size of an HTTP re-
sponse. By leveraging these techniques, we show that
when an attacker can make the victim send requests to
arbitrarily chosen endpoints, the potential consequences
of traffic monitoring become significantly more severe.
In contrast to prior attacks, where adversaries could typ-
ically only obtain a rough estimate of the resource size,
or were unable to attribute network traffic to specific re-
quests, our size-exposing attacks show that the capabili-
ties of an adversary are worryingly extensive, as we ex-
emplify by the means of several real-world attack sce-
narios. Finally, we explore the viability of several de-
fense mechanisms, leading to an improved browser de-
sign and a variety of possibilities for websites to thwart
size-exposing attacks.
Our main contributions are:
• We perform an in-depth analysis at the level of the
browser, network and operating system, and explore
techniques that can expose the size of resources ei-
ther directly or through a side-channel attack.
• We introduce several new attack vectors that can be
leveraged to uncover the exact response size of ar-
bitrarily chosen endpoints.
• By the means of several attack scenarios on high-
profile websites, we demonstrate that an adversary
can reveal the unique identity of an unwitting visitor
within mere seconds, and extract sensitive informa-
tion that the user shared with a trusted website.
• We propose an improvement to the specification of
the Storage API, and explore various existing solu-
tions that can be used to mitigate all variations of
size-exposing attacks.
The remainder of the paper is structured as follows: in
Section 2 we provide a high-level overview of the tech-
nical aspects related to recently introduced browser fea-
tures. In Section 3 we present an in-depth analysis on
potential size-exposing techniques, and elaborate on how
these can be used in various attack scenarios.
In Sec-
tion 4, we discuss how adversaries can leverage these
techniques against a number of real-world services. Fur-
thermore, in Section 5 we propose and explore methods
that can thwart size-exposing attacks. Section 6 covers
related work, and Section 7 concludes this paper.
2 Background
One of the most important security concepts of modern
browsers, is the notion of Same-Origin Policy [64, 73].
Despite what its name may suggest, it is not strictly de-
fined as a policy, but rather represented as certain prin-
ciples that ensure websites are restricted in the way they
can interact with resources from a different origin. Al-
though it is possible to initiate a cross-origin request, the
Same-Origin Policy prevents reading out the content of
the associated response, which is obviously imperative
in order to provide online security. Naturally, the content
of resources is not the only part that should be shielded
off from other origins; the size of a resource should also
be considered sensitive, as evidenced by the several case
studies presented in Section 4 and prior work [7, 20, 60].
As such, it comes as no surprise that the browser APIs
that are responsible for making HTTP requests will only
report the length of a response when the associated re-
quest was to the same origin.
The Fetch API, which is currently implemented by
Google Chrome, Firefox and Opera, and is under devel-
opment by other browser vendors [39, 69], introduces a
set of new semantics that aim to unify the fetching pro-
cess in browsers. In short, the fetch() method is given
a Request object, and a second, optional parameter that
specifies additional options for the request. For instance,
when the credentials option is set to "include", the
user’s cookies will be sent along with the request, even
when it is cross-origin. The fetch() operation will re-
turn a Promise that yields a Response object as soon as
the response has been fetched. In case the request was
authenticated, cross-origin, and did not use the CORS
mechanism, i.e., the mode was set to its default value
"no-cors", the Response will be marked as "opaque",
which will mask all information (status code, response
headers, cache state, body and length) of the response to
prevent cross-origin information leakage. In the follow-
ing sections we will show how certain browser mecha-
nisms can be abused to uncover the length of cross-origin
responses.
Although the content of an opaque Response can not
be accessed, it is possible to force the browser to cache
that resource. The Cache API, which is part of the Ser-
vice Worker API [66], can be used to place Response
objects in the browser’s cache. For security purposes,
the cache that is accessed by the Cache API is com-
pletely isolated from the browser’s HTTP cache, and is
not shared across different origins. The cache is accessed
by opening a Cache object, which can then be used to
store Response objects with their associated Requests.
Note that any response can be stored, regardless of the
Cache-Control headers sent out by the web server. To
prevent a malicious entity from completely filling up the
user’s hard disk, certain quota rules apply. The details
of these rules will be explained in more detail in Sec-
tion 3.4.
448  25th USENIX Security Symposium 
USENIX Association
3 Size-exposing Techniques
As demonstrated by prior research, the size of a website’s
resources is often related to the state of the user at that
website [7, 38, 60]. Consequently, knowing the size of
these resources allows an adversary to (partially) uncover
the state of the user, which often yields sensitive infor-
mation. In order to detect the presence of size-exposing
attack vectors, we performed an in-depth analysis on all
operations in which resources are involved. In this sec-
tion, we present the results of this analysis and discuss
the various techniques that can be used to infer the size of
cross-origin resources. Next to the size-exposing meth-
ods that were discovered in prior research, we also intro-
duce various novel techniques and re-evaluate methods
in the light of recent protocol evolutions.
Throughout this section, we consider different attacker
models based on the evaluated resource operation. As a
rule of thumb, for each resource operation we consid-
ered all the attacker models in which the adversary is
able to make observations about the operation. For in-
stance, when analysing the transfer of a resource over
the network, multiple attacker models were taken into
account: an eavesdropper might inspect the encrypted
network traffic directly, or Wi-Fi packets could be ex-
amined when the adversary is in physical proximity of
the victim, or the attacker might simply use JavaScript to
measure the time it took to complete the request.
Our evaluation mainly focuses on attacks in which the
adversary infers sensitive information from the size of
the resources that are returned to the victim when re-
questing specific endpoints. As such, we evaluate poten-
tial attack techniques under the assumption that an ad-
versary can trigger the victim’s browser to send authen-
ticated requests to arbitrarily chosen endpoints. This can
be easily achieved by a moderately motivated attacker
due to the plethora of methods that can be used to execute
arbitarary JavaScript code in a cross-origin context (with
regard to the target endpoint). For instance, an attacker
can trick the user in visiting his website using phishing
via e-mail or social networks [29], register a typosquat-
ting domain [41], launch an advertising campaign where
JavaScript code or an iframe containing the attacker’s
web page is included [54], register a stale domain from
which a JavaScript file is included [43], redirect insecure
HTTP requests [37], ... Note that recent attacks on TLS
also assume an attacker can execute JavaScript code in
the victim’s browser [16, 1, 62].
3.1 Operations Involving Resources
By looking at their typical “lifetime”, we identified six
different operations that involve resources, as shown in
Figure 1. In the first step, a resource is generated at the
Operating System
4. Receive
Web server host 
Browser
2. Send
3. Transfer
Web server
5. Process
6. Store
1. Generate
Figure 1: Overview of operations that involve resources.
side of the web server, as a result of the request initi-
ated by the browser. Here the web server will associate
the user’s state with the included cookie, produce the re-
quested content, and pour it into an HTML structure. Al-
though several attacks have been presented that can ex-
tract sensitive information from this generation process,
e.g., direct timing attacks [7], our research focuses on
methods that can expose the size of the generated con-
tent. Since the length of the response is only known after
it has been generated, attacks against the resource gener-
ation process are excluded from our evaluation.
Once a resource has been dynamically generated, the
machine where the web server is hosted on will send it
back to the user that requested it. This means that if an
adversary is able to observe the amount of traffic gener-
ated by the web server, he could use this information to
infer the size of the response. We discuss size-exposing
techniques in this context in more detail in Section 3.2.
When the resource leaves the web server, it is sent over
several networks before it reaches the client. In any of
these networks, an adversary capable of intercepting or
passively observing the network traffic could be present.
Because size-exposing attacks can be considered to be
superfluous when an adversary can inspect the contents
of a resource, we only consider encrypted traffic in our
evaluation. Prior work has shown that popular encryp-
tion schemes such as SSL and TLS do not conceal the
length of the original HTTP request and response, lead-
ing to various attacks [67, 12]. In our analysis, we ex-
tend this existing work by re-evaluating the feasibility of
size-exposing attack methods when the new HTTP ver-
sion (HTTP/2) is used. Furthermore, we explore possible
size-exposing attack techniques in the context of Wi-Fi
networks, where another layer of encryption is added,
and elaborate on our findings in Section 3.3.
As soon as the response reaches the client’s machine,
it is first received by the network interface, and then sent
to the browser, where it is processed and possibly cached.
Similar to the server-side, an adversary with a foothold
in the operating system, can leverage traffic statistics to
uncover the resource’s length. In Section 3.2, we investi-
gate these types of attack techniques under various threat
models, both for mobile devices as well as desktops.
USENIX Association  
25th USENIX Security Symposium  449
Table 1: An overview of size-exposing attack techniques
with their associated resource operations (as per Fig-
ure 1) and whether the techniques can be used to obtain
the exact size of a resource.
Size-exposing technique
Cache timing attacks
Traffic statistics pseudo-files
SSL/TLS traffic analysis
Wi-Fi traffic analysis
Cross-site timing attacks
Browser-based timing attacks
Storage side-channel leaks
Resource
operation
2, 4
2, 4
3
3
3
5
6
Exact
size




References
[48, 76, 72, 44]
[77], Section 3.2
[67], Section 3.3
Section 3.3
[7, 20]
[60]
Section 3.4
After receiving the response, the browser will first sig-
nal the completion of the request by firing an Event. In
the threat model we consider, the request is initiated by
the malicious JavaScript code, and thus, its completion is
signaled to the attacker. It is known that the time it takes
for a request to complete is correlated with its size, giving
rise to so-called timing attacks. However, these attacks
have several limitations, and can only be used to obtain a
rough estimate of a resource’s size. While a rough esti-
mate is sufficient to perform certain attacks [7, 20], most
of the real-world attacks we present in Section 4 require
knowing the exact size of resources.
In a recent study, Van Goethem et al. found that the
next step of a resource’s lifetime, i.e., parsing by the
browser, is susceptible to timing attacks as well [60]. In
contrast to classic timing attacks, these browser-based at-
tacks do not suffer from network irregularities, and thus
provide attackers with a more accurate and reliable esti-