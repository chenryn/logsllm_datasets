In this section we discuss several modiﬁcations that
can be made to improve the performance of the key re-
covery attack on WEP. While not necessary for the com-
promise to be effective, they can decrease both time and
space requirements for an attacker.
8We eventually traced this back to RFC 1042 [8].
9Some vendors, such as Cisco use a proprietary OID [2]. Fortu-
nately, it also beings with 0xAA.
10Other cards have been reported to choose IVs at random, to count
in big endian order, or to switch between two IVs. This last class are
cards are not vulnerable to the attack in this paper, although they break
badly under the attacks of Borisov et al. [1].
RecoverWEPKey()
Key[0 . . . KeySize] = 0
for KeyByte = 0 . . . KeySize
Counts[0 . . .255] = 0
foreach packet → P
if P.IV ∈ {(KeyByte + 3,0xFF, N) | N ∈ 0x00 . . .0xFF}
Counts[SimulateResolved(P, Key)]+ = 1
Key[KeyByte] = IndexOfMaximumElement(Counts)
return Key
Figure 1. The basic attack on WEP. Depending on the actual key used, this attack can take between 4,000,000 and 6,000,000
packets to recover a 128-bit key. The SimulateResolved function computes the value described in section 7.1 of Fluhrer et
al.
4.1 Choosing IVs
In the baseline attack (the one described in Ap-
pendix A of Fluhrer et. al.), only IVs of a particular
form are considered (those corresponding to (KeyByte+
3,0xFF, N) where KeyByte is the current KeyByte we
are guessing and N is unrestricted). However, we found
that there are other IVs that can result in a resolved state,
and that testing all IVs instead of only the subset sug-
gested by the Fluhrer et. al. paper can be done in paral-
lel with receiving packets. This conclusion was veriﬁed
by Adi Shamir [10], who also noted that these packets
appear more often for higher key bytes.
4.2 Guessing Early Key Bytes
As the Fluhrer, Mantin, and Shamir attack works by
building on previously discovered key bytes, recovering
early key bytes is critical. There are two approaches that
we tried both separately and together. The ﬁrst utilized
the way that the IVs were generated, namely that we
would receive packets that resolved for lots of different
key bytes before necessarily receiving enough resolv-
ing packets to predict the early key bytes.11 We would
therefore use the resolving cases that we had received
to narrow down the possibilities for the early key bytes.
We were then able to test candidate keys by determining
if the WEP checksum on a decrypted packet turned out
correctly.
The second approach exploited the poor key manage-
ment available in WEP implementations. Since WEP
keys have to be entered manually, we assumed that in-
stead of giving clients a long string of hex digits, a user
memorable passphrase would be used. After examining
the test wireless cards at our disposal, we determined
that the user-memorable passphrase is simply used raw
as the key (i.e. the ASCII is used; no hashing is done).
Although hashing does not protect against a dictionary
attack, it would have helped in this circumstance, as we
were able to determine directly whether each key byte
11See Figure 6 of Fluhrer et. al.; resolved cases are much more
likely to occur for later key bytes.
was likely to be part of a user memorable passphrase
by checking whether the byte value corresponded to an
ASCII letter, number, or punctuation symbol.
This pair of optimizations turned out to provide an
astounding decrease in the number of packets required.
In parallel with receiving packets (on another machine,
though this is not really necessary), we were continu-
ally attempting to guess the key by choosing the most
likely candidates based on the resolved cases we had al-
ready gathered. In the event of ”ties” for the next most
likely byte, we gave priority ﬁrst to (in order): lowercase
letters, uppercase letters, numbers, symbols, other byte
values.
4.3 Special Resolved Cases
As Shamir pointed out to us, there are cases when a
resolved case can provide an even better indication as to
a particular key byte. If there is a duplication among the
three values at positions S[1], S[S[1]], and S[S[1]+S[S[1]]
(i.e. these are only two distinct values), then the prob-
ability that these positions in the S permutation remain
−2 ≈ 13%. We can
unchanged jumps from e
thus treat the evidence from these cases as about three
times more convincing as a standard resolved case.
−3 ≈ 5% to e
4.4 Combining the Optimizations
Figure 2 shows the key recovery algorithm after all
of the improvements described above. The improve-
ments drop the number of packets required from around
5,000,000 to around 1,000,000.
5 Discussion
There are many variables that can affect the perfor-
mance of the key recovery attack on WEP. In this section
we summarize the effect of some of these variables and
look at how the WEP design could be slightly altered to
prevent this particular attack.
RecoverWEPKeyImproved(CurrentKeyGuess, KeyByte)
Counts[0 . . .255] = 0
foreach packet → P
if Resolved?(P.IV )
Counts[SimulateResolved(P,CurrentKeyGuess)]+ = Weight(P,CurrentKeyGuess)
foreach SelectMaximalIndexesWithBias(Counts) → ByteGuess
CurrentKeyGuess[KeyByte] = ByteGuess
if Equal?(KeyByte, KeyLength)
if CheckChecksums(CurrentKeyGuess)
return CurrentKeyGuess
else
Key = RecoverWEPKeyImproved(CurrentKeyGuess, KeyByte + 1)
if notEqual?(Key,Failure)
return Key
return Failure
Figure 2. The improved attack on WEP. Depending on the actual key used, this attack can take between 1,000,000 and
2,000,000 packets to recover a 128-bit key. The SimulateResolved function computes the value described in section 7.1 of
Fluhrer et al., the CheckChecksums checks to see if a key causes the checksums in the WEP packets to come out correctly, and
the Resolved? predicate checks to see if a given packet results in a resolved condition. The SelectMaximalIndicesWith-
Bias function corresponds to the optimization in section 4.2. The Weight function returns 3 if the resolved case corresponds
to a special resolved case as described in section 4.3, and 1 otherwise.
5.1
IV Selection
Since the WEP standard does not specify how IVs
should be chosen, there are a variety of IV generation in
use in current 802.11 cards. The majority of cards seem
to use one of three methods: counters, random selection,
or value-ﬂipping (i.e. switching between two IV values).
This attack is possible with either of the ﬁrst two types
of IV selection. Value-ﬂipping prevents this attack at
the expense of reusing the pseudorandom stream every
other packet. This is not a reasonable trade-off.
Counter modes are the most accommodating of this
attack. In these cards, the IV is incremented with each
packet sent (starting either at 0 or at some random value
when the card is powered on). With counter mode cards,
an attacker is practically guaranteed a nice distribution
of resolving packets among the key bytes. Random se-
lection of each IV is not much better, as there are enough
expected resolved cases that although the distribution
might not be quite as good as the counter modes, it won’t
be much worse.
In short, there does not seem to be a way of choos-
ing IVs to mitigate the effects of this attack without ex-
plicitly testing each IV and key pair to see if it resolves
before sending it. This would require extra processing
power and would decrease the already small space of
IVs.
5.2 Key Selection
The lack of key management in WEP certainly con-
tributes to the ease of the key recovery attack. Most net-
works use a single shared key between the basestation
and all mobile nodes. Besides the suite of ”disgruntled
ex-employee who knows the key” style attacks, there is
also the problem of distributing this key to the users.
Many sites use a human memorable password to easy
this key distribution. There is however no standard way
of mapping these passwords to a WEP key. The cur-
rent solution is mapping the ASCII value directly to a
key byte. We would recommend switching to either us-
ing a secure (non-memorable) WEP key or having the
key setup software hash the password to the key using a
cryptographic hash function. Note that neither of these
solutions prevent the attack, only make it slightly more
difﬁcult.
There do exist proprietary solutions that allow each
mobile node to use a distinct WEP key, most notably
Cisco’s LEAP protocol. LEAP sets up a per-user, per-
session WEP key when a user ﬁrst authenticates to the
network. This complicates the attack, but does not pre-
vent it so long as a user’s ”session” lasts sufﬁciently
long. We would recommend securely rekeying each user
after every approximately 10,000 packets.
5.3 RC4
RC4 is an efﬁcient stream cipher that can be used se-
curely. The implementation of RC4 in SSL is not af-
fected by the Fluhrer et. al. attack. The reasons are that
SSL pre-processes the encryption key and IV by hashing
with both MD5 and SHA-1 [3]. Thus different sessions
have unrelated keys. In addition, in SSL, RC4 state from
previous packets is used in future packets, so that the al-
gorithm does not rekey after each packet.
A further recommendation (RSA Security Inc.’s stan-
dard recommendation) is for applications to discard the
ﬁrst 256 bytes of RC4 output. This may be a bit expen-
sive for very small packets, but if session state is main-
Acknowledgments
We thank Bill Aiello, Steve Bellovin, Scott Fluhrer,
Bob Miller, Ron Rivest, Adi Shamir, Dave Wagner, and
Dan Wallach for helpful comments and discussions.
We informed Stuart Kerry, the 802.11 Working Group
Chair, that we successfully implemented the Fluhrer, et
al. attack. Stuart replied that the 802.11 Working Group
is in the process of revising the security, among other
aspects, of the standard and appreciates this line of work
as valuable input for developing robust technical speci-
ﬁcations.
References
[1] N. Borisov, I. Goldberg, and D. Wagner.
mobile communications: The insecurity of 802.11.
MOBICOM 2001, Rome, Italy, July 2001.
Intercepting
In
[2] D. Cafarelli. Personal communications, 2001.
[3] T. Dierks and C. Allen.
The TLS Protocol,
Internet Engineering Task Force,
RFC-2246, ftp://ftp.isi.edu/
Version 1.0.
Jan. 1999.
in-notes/rfc2246.txt.
[4] S. Fluhrer, I. Mantin, and A. Shamir. Weaknesses in
the key scheduling algorithm of RC4. In Eighth Annual
Workshop on Selected Areas in Cryptography, Toronto,
Canada, Aug. 2001.
[5] M. Hamrick. Personal communications, 2001.
[6] S. Kent and R. Atkinson. Security architecture for the
Internet protocol. Request for Comments 2401, Internet
Engineering Task Force, November 1998.
[7] L. M. S. C. of the IEEE Computer Society. Wireless
LAN medium access control (MAC) and physical layer
(PHY) speciﬁcations. IEEE Standard 802.11, 1999 Edi-
tion, 1999.
[8] J. Postel and J. K. Reynolds. Standard for the transmis-
sion of IP datagrams over IEEE 802 networks. Request
for Comments 1042, Internet Engineering Task Force,
Feb. 1988.
[9] B. Schneier. Applied Cryptography - Protocols, Algo-
rithms, and Source Code in C. John Wiley & Sons, Inc.,
1994.
[10] A. Shamir. Personal communications, 2001.
[11] T. Ylonen. SSH - secure login connections over the In-
ternet. USENIX Security Conference VI, pages 37–42,
1996.
tained across packets, that cost is amortized.
In summary, RC4 can be used as part of a security so-
lution. However, care must be taken when implement-
ing it so that key material is not leaked. One of the risks
of algorithms that have such caveats is that protocol de-
signers without a strong grounding in cryptography and
security may not be aware of the correct way to imple-
ment them, and this is exactly what happened in the case
of WEP.
6 Conclusions and recommendations
We implemented the attack described by Fluhrer et.
in several hours. It then took a few days to ﬁgure
al.
out which tools to use and what equipment to buy to
successfully read keys off of 802.11 wireless networks.
Our attack used off of the shelf hardware and software,
and the only piece we provided was the implementation
of the RC4 attack, along with some optimizations. We
believe that we have demonstrated the ultimate break of
WEP, which is the recovery of the secret key by obser-
vation of trafﬁc.
Since the inital report of our attack appeared, oth-
ers have duplicated our results. Although we did not
release our code, there are now two publicly available
tools for breaking WEP keys. As always, once security
attacks become known, exploits are available to script
kiddies, who do not need to understand the technical de-
tails to break systems. The two tools that we know of
are Airsnort and WEPCrack.
Given this attack, we believe that 802.11 networks
should be viewed as insecure. We recommend the fol-
lowing for people using such wireless networks.
• Assume that the link layer offers no security.
• Use higher-level security mechanisms such as
IPsec [6] and SSH [11] for security, instead of re-
lying on WEP.
• Treat all systems that are connected via 802.11 as
external. Place all access points outside the ﬁre-
wall.
• Assume that anyone within physical range can
communicate on the network as a valid user. Keep
in mind that an adversary may utilize a sophisti-
cated antenna with much longer range than found
on a typical 802.11 PC card.
The experience with WEP shows that it is difﬁcult to
get security right. Flaws at every level, including proto-
col design, implementation, and deployment, can render
a system completely vulnerable. Once a ﬂawed system
is popular enough to become a target, it is usually a short
time before the system is defeated in the ﬁeld.