Liar! Macs have 
no viruses! 
-[ OS X Kernel Rootkits ]- 
§  Don't take me too seriously, I fuzz the Human brain! 
§  The capitalist "pig" degrees: Economics & MBA. 
§  Worked for the evil banking system! 
§  Security Researcher at COSEINC. 
§  "Famous" blogger. 
§  Wannabe rootkits book writer. 
§  Love a secondary curvy road and a 911. 
Who Am I
Prologue
§  OS X Kernel rootkits. 
§  Ideas to improve them. 
§  Sample applications. 
§  Raise awareness and interest in this area. 
Today's subject 
Prologue
§  Reaching to uid=0 is your problem! 
§  The same with startup and persistency aka APT. 
§  Should be easier to find the necessary bugs. 
§  Less research = Less audits = More bugs. 
§  Main target is Mountain Lion. 
§  Also works with Mavericks (tested with DP1). 
Assumptions 
(the economist’s dirty secret that makes everything possible) 
Prologue
§  OS X rootkits are a rare "species". 
§  Interesting hardware rootkits (Dino's Vitriol and 
Snare's EFI) but NO full code available L. 
§  Commercial rootkits: Crisis from Hacking Team and 
maybe FinFisher (iOS yes, OS X never saw). 
§  Crisis is particularly bad. 
§  Not many detection tools available. 
Current state of the “art” 
Simple Ideas
Simple Ideas
§  Many interesting kernel symbols are not exported. 
§  Some are available in Unsupported & Private KPIs. 
§  Not acceptable for stable rootkits. 
§  Solving kernel symbols from a kernel extension is 
possible since Lion. 
§  Not in Snow Leopard and previous versions. 
Problem #1 
Simple Ideas
§  __LINKEDIT segment contains the symbol info. 
§  Zeroed up to Snow Leopard. 
§  OS.X/Crisis solves the symbols in userland and 
sends them to the kernel rootkit. 
Simple Ideas
§  One easy solution is to read the kernel image 
from disk and process its symbols. 
§  The kernel does this every time we start a new 
process. 
§  Possible to implement with stable KPI functions. 
§  Kernel ASLR slide is easy to obtain in this 
scenario. 
Simple Ideas
Simple Ideas
§  Virtual File System – VFS. 
§  Read and write any file using VFS functions. 
§  Using only KPI symbols. 
§  Recipe for success: 
q  Vnode. 
q  VFS context. 
q  Data buffer. 
q  UIO structure/buffer. 
Idea #1 
Simple Ideas
q How to obtain the vnode information. 
§  vnode_lookup(const char* path, int flags, 
vnode_t *vpp, vfs_context_t ctx). 
§  Converts a path into a vnode. 
Pay attention to 
that NULL! 
Simple Ideas
§  Apple takes care of the ctx for us! 
Still works in 
Mavericks DP1! 
Simple Ideas
q Data buffer. 
§  Statically allocated. 
§  Dynamically, using one of the many kernel 
functions: 
§  kalloc, kmem_alloc, OSMalloc, IOMalloc, MALLOC, 
_MALLOC. 
§  __LINKEDIT size is around 1Mb. 
Simple Ideas
q UIO buffer. 
§  Use uio_create and uio_addiov. 
§  Both are available in BSD KPI. 
Simple Ideas
§  Recipe for success: 
þ vnode of /mach_kernel. 
þ VFS context. 
þ Data buffer. 
þ UIO structure/buffer. 
§  We can finally read the kernel from disk… 
Simple Ideas
§  Reading from the filesystem: 
§  VNOP_READ(vnode_t vp, struct io* uio, int ioflag, 
vfs_context_t ctx). 
§  “Call down to a filesystem to read file data”. 
§  Once again Apple takes care of the vfs context. 
§  If call was successful the buffer will contain 
data. 
§  To write use VNOP_WRITE. 
Simple Ideas
§  To solve the symbols we just need to read the 
Mach-O header and extract some information: 
§ __TEXT segment address (to find KASLR). 
§ __LINKEDIT segment offset and size. 
§ Symbols and strings tables offset and size 
from LC_SYMTAB command. 
Simple Ideas
§  Read __LINKEDIT into a buffer (~1Mb). 
§  Process it and solve immediately all the symbols 
we (might) need. 
§  Or just solve symbols when required to obfuscate 
things a little. 
§  Don't forget that KASLR slide must be added to 
the retrieved values. 
Simple Ideas
§  To compute the KASLR value find out the base 
address of the running kernel. 
§  Using IDT or a kernel function address and then 
lookup Mach-O magic value backwards. 
§  Compute the __TEXT address difference to the 
value we extracted from disk image. 
§  Or use some other method you might have. 
Simple Ideas
§  We are able to read and write any file. 
§  For now the kernel is the interesting target. 
§  We can solve any available symbol - function or 
variable, exported or not in KPIs. 
§  Compatible with all OS X versions. 
Checkpoint #1 
Simple Ideas
§  Many interesting functions & variables are static. 
§  Cross references not available (IDA spoils us!). 
§  Hex search is not very reliable. 
§  Internal kernel structures fields offsets, such as 
proc and task. 
Problem #2 
Simple Ideas
§  Integrate a disassembler in the rootkit! 
§  Tested with diStorm, my personal favorite. 
§  Works great. 
§  Be careful with some inline data. 
§  One second to disassemble the kernel. 
§  In a single straightforward sweep. 
Idea #2 
Earth calling 
ESET, hello? 
Simple Ideas
§  Ability to search for static functions, variables, 
and structure fields. 
§  We still depend on patterns. 
§  These are more common between all versions. 
§  Possibility to hook calls by searching references 
and modifying the offsets. 
Checkpoint #2 
Simple Ideas
§  We can have full control of the kernel. 
§  Everything can be dynamic. 
§  Stable and future proof rootkits. 
Simple Ideas
§  Can Apple close the VFS door? 
§  That would probably break legit products that use 
them. 
§  We still have the disassembler(s). 
§  Kernel anti-disassembly ? J 
§  Imagination is the limit! 
LSD helps, they 
say! 
Simple Ideas
§  Executing userland code. 
§  Playing with DTrace’s syscall provider & Volatility. 
§  Zombie rootkits. 
§  Additional applications in the SyScan slides and 
Phrack paper (whenever it comes out). 
Practical applications 
Dude, where’s 
the paper? 
Userland cmds
§  It can be useful to execute userland binaries from 
the rootkit or inject code into them. 
§  Many different possibilities exist: 
§  Modify binary (at disk or runtime). 
§  Inject shellcode. 
§  Inject a library. 
§  Etc… 
§  This particular one uses last year's Boubou trick. 
§  Not the most efficient but fun. 
Kernel calls 
userland, hello? 
Userland cmds
§  Kill a process controlled by launchd. 
§  Intercept the respawn. 
§  Inject a dynamic library into its Mach-O header. 
§  Dyld will load the library, solve symbols and 
execute the library's constructor. 
§  Do whatever we want! 
Idea! 
Userland cmds
q  Write to userland memory from kernel. 
q  Kernel location to intercept & execute the injection. 
q  A modified Mach-O header. 
q  Dyld must read modified header. 
q  A dynamic library. 
q  Luck (always required!). 
Requirements 
I play Russian 
roulette! 
Userland cmds
q Write to userland memory from kernel. 
§  Easiest solution is to use vm_map_write_user. 
§  vm_map_write_user(vm_map_t map, void 
*src_p, vm_map_address_t dst_addr, 
vm_size_t size); 
§  "Copy out data from a kernel space into space in 
the destination map. The space must already 
exist in the destination map." 
Userland cmds
q Write to userland memory from kernel. 
§  Map parameter is the map field from the task 
structure. 
§  proc and task structures are linked via void *. 
§  Use proc_find(int pid) to retrieve proc struct. 
§  Or proc_task(proc_t p). 
§  Check kern_proc.c from XNU source. 
Userland cmds
þ Write to userland memory from kernel. 
§  The remaining parameters are buffer to write 
from,  destination address, and buffer size. 
Userland cmds
q  Kernel location to intercept & execute the injection. 
§  We need to find a kernel function within the new 
process creation workflow. 
§  Hook it with our function responsible for modifying 
the target's header. 
§  We are looking for a specific process so new proc 
structure fields must be already set. 
§  Vnode information can also be used. 
Userland cmds
Userland cmds
§  There's a function called proc_resetregister. 
§  Located near the end so almost everything is 
ready to pass control to dyld. 
§  Easy to rip and hook! 
§  Have a look at Hydra (github.com/gdbinit/hydra). 
Purrfect!!! 
Userland cmds
þ Modified Mach-O header. 
§  Very easy to do. 
§  Check last year's HiTCON slides. 
§  OS.X/Boubou source code 
(https://github.com/gdbinit/osx_boubou). 
Userland cmds
Userland cmds
þ Dyld must read modified header. 
§  Adding a new library to the header is equivalent 
to DYLD_INSERT_LIBRARIES (LD_PRELOAD). 
§  Kernel passes control to dyld. 
§  Then dyld to target's entrypoint. 
§  Dyld needs to read the Mach-O header. 
§  If header is modified before dyld's control we can 
inject a library (or change entrypoint and so on). 