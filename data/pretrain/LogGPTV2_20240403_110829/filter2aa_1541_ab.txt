installed on a target for record keeping but also in case there are multiple operators attacking one 
network. By generating a number of target machines we determined that the KiSu module root 
location changes between hosts with the section “OemMgmt” varying between hosts, below is an 
example of a variant module root being displayed using DoubleFeature.
F-Secure  |  Killsuit research
11
Through experimenting with OS version, IP address, MAC address, time of OS initialisation, 
various system identification values and many other factors we were unable to determine the 
variable that was used to select the masquerading registry value where the modules were stored. 
Even when two separate OS instances were made with seemingly identical criteria the location 
would vary, therefore concluding it must not be a standard configurable value. However, after 
many attempts we began to see repetition in the location selected for installation in parts of the 
path generated which led to the speculation this location is generated from two separate words 
spliced together (Oem & Mgmt or Driv & Mgmt e.g). Analysis of the deployed PC operation 
proved this to be the case as two strings values  are observed being concatenated together and 
appended to the default registry directory during installation. As such we began to work on 
tracking down when the hive location was selected and where the two names were selected from 
with the belief that two lists must exist within the framework.
Figure 16 –Observation of concatenation function for Killsuit module root location variable string components
Hunting for the list & into the rabbit hole
We needed to determine if the registry location was decided by the DdSz operator on the 
attacker machine via received information, configured as part of the PC agent payload generation 
for that host or generated by the PC agent once installed on the host. By utilising the same PC 
payload on multiple hosts we were able to quickly rule out the value being coded into the payload 
as reuse of the payload resulted in varying registry addresses.
Therefore we moved to the operator to examine the Alias and Commands of the framework for all 
functions related to installation. From this we were able to find scripts that were directly called in 
order to facilitate KiSu operations and gather a better understanding of how these functions are 
processed in the framework. Essentially the GUI of the framework translated command line input 
through the Alias and Command filters to the appropriate scripts, these (for KiSu) then are fed 
to Dsz script files which interact with a _dsz object type which seemingly allocates, controls and 
manages PC agents in the field. 
F-Secure  |  Killsuit research
12
Examples of these scripts include “Mcl_Cmd_DiBa_Tasking.py” which handles KiSu module 
installation/maintenance operations for instances, and “Mcl_Cmd_KisuComms_Tasking.pyo” 
which is used to dynamically load and unload modules/drivers from an instance and initiate 
connection between and agent and an instance. Both these scripts are called through the 
command line and relay & format the operators input to the Dsz resource libraries to perform 
operations against the agent specified,  in the image below this can be seen as the command 
“mcl.tasking.RpcPerformCall()”.
Figure 17 – Mcl_Cmd_KisuComms_Tasking.pyo extracted function utilising library functions with _dsz component
Figure 18 –Radare2 output for search and cross reference of data location relative to _dsz function output
By following the script commands for installation back through their associated libraries we found 
the command was issued to the agent through the Dsz resource folder “mcl_platform/tasking” 
library. In this and associated libraries the use of a “_dsz” import is utilised to create objects and 
in order to carry out the interactions with the agents, however no corresponding library file was 
found for the private library. 
As this import seemed pivotal to the frameworks operations and KiSu interaction we investigated 
its use within the “ddsz_core.exe” binary file by searching for any instace of any of the associated 
scripts or their functions. Through this method we successfully found calls to the function “dsz_
task_perform_rpc”, by cross referencing this function we were able to uncover data locations for 
related data objects. 
F-Secure  |  Killsuit research
13
Analysis of the binary showed that the relevant data was not in the binary as standard and was 
instead loaded as an external C module at runtime, making any attempt to analyse the command 
functions statically impossible, therefore we moved on to dynamic analysis. Attempting to 
analyse the binary dynamically produced issues as the binary is aware of debugger hooks and 
automatically terminates. By hiding the debugger we were able to gain monitoring of the binary 
but this led to more complications when referencing the function index table as a number 
of loaded functions are dummy functions with no purpose, a static alternative to the dummy 
operation seen during KiSu installation.
Further analysis of the discovered memory locations showed several variations most of which 
remained empty, additionally the values seemed to be loaded and unloaded immediately after 
use. From these elements it is clear that analysis of this binary was designed to be as difficult 
as possible. Attempting to analyse the PC payload showed its contents to be encrypted and 
impossible to analyse as deployed. We attempted to use PcPrep.exe which is included within the 
framework which provides additional information on PC payloads. However, the information 
listed does not include the root location and therefore was not conclusive. 
Figure 19 –PcPrep.exe output for configured PeddleCheap payload and associated configuration file
F-Secure  |  Killsuit research
14
When trying to analyse the PC payload dynamically for operations relating to registry creating/
edit/adding, the values appear not to be loaded into the stack of the running process but 
instead into the kernel in such a way which we were unable to recover. As such, due to these 
complications during analysis, we were unable to find the lists for the registry locations within  
the framework.
Refocus and results
As the list location eluded us we re-examined the installation process again for any further 
abnormal behaviour. Careful investigation of the operations called during installation did reveal 
an identifiable registry query that can be used to identify the process across hosts and is uniform. 
The operation queries a default cryptography provider type within the registry, a value which 
does not exist in typical systems. The value queried by the installation is “HKLM\Software\
Microsoft\Cryptography\Defaults\Provider Types\Type 023” which, without additional action 
within the framework, results in “NAME NOT FOUND”. This query operation was found in every 
experimental installation of a KiSu instance. 
Cryptography provider types typically are the definition of cryptographic function with specific 
criteria so that an encryption algorithm such as RSA can be used in various ways for different 
effects. Although it is possible for a custom provider type to be defined, it is extremely unlikely 
that they will be stored as part of the Microsoft defaults within the HKLM hive. Research into a 
legitimate instance of the entry “Type 023” in that location generated no results. 
Figure 20 –Observation of uniform Killsuiit installation activity, registry query for “Type 023” cryptography 
default provider type
F-Secure  |  Killsuit research
15
HOW TO DETECT AND REMEDIATE A KILLSUIT 
COMPROMISE
How to detect KillSuit installation
From our analysis of the installation and persistence mechanisms employed by KiSu there is a 
defined list of consistent identifiers for installation. In addition to these examples we also found 
an extensive list of drivers within the framework packages. This list seemed to consist of drivers 
known to be used for specific legitimate applications, known pieces of malware and frameworks 
components themselves including KiSu specific drivers. From the information available several of 
the drivers are labelled for removal, however one driver (mpdkg32) is not labelled for removal and 
should be present if any instances are installed. As such, presence of this driver or any of the other 
related drivers directly indicates installation on the host. A full list of the drivers associated with 
DdSz framework capabilities, including KiSu installation, can be found in the appendix. 
Figure 21 –Detection methods for KillSuit stages
As such, the conclusion of our research and the specified driver list above indicates three possible 
methods of detecting installation of KiSu on a monitored host. First, the unusual use of the 
“systemfunction007” Kernel call followed almost immediately by registry write operations from an 
executable that is not meant to perform such actions. As the operator of DdSz can designate which 
running executable to reflect into this may be very difficult. By default the tool injects into lsass.exe, 
therefore the Kernel call for encryption generation is not unusual. Although an identifiable criteria, 
a clever operator will choose a process with such actions as standard to blend in.
Second, installation of any of the specified drivers related to KiSu in the list provided. Detection 
of the installation and removal of any KiSu drivers in the list is a clear indicator of the framework 
being used against a host. A scan across an estate for the presence of driver “mpdkg32” will be 
a very easy way to quickly sweep for legacy installation of the tool that may not be detectable 
during operation due to the lengths put in place to disguise the frameworks activity (custom TCP 
channel, full encryption etc.). 
Installation
Operation
“Type 023” default 
cryptography provider 
type registry query
Presence of any 
permutation of 
registry Dir in HKLM 
CurrentVersion
SystemFunction007 
Kernel call for NTLM  
hash generation in 
obscure process
KillSuit related driver 
installed on the host
F-Secure  |  Killsuit research
16
Finally, registry operations related to installation can be monitored for to detect live attacks 
or legacy installations. Sweeping/monitoring for registry keys under the HKLM matching 
any permutation of the two lists provided in the appendix may lead to the detection of KiSu 
installation or running operations. As this list is not certain to be conclusive this is only a partial 
measure but if paired with driver monitoring should create a high certainty of the presence 
of an instance on the host. However, monitoring for registry query operations against the 
cryptography default provider type “Type 023” is a very confident way to detect installation 
attempts on a host. If monitoring for such operations is available, the installation of a rule to 
monitor for that one registry key could provide clear evidence of malicious actions as part of a 
live monitoring system.
How to remove Killsuit from your host
Experimentation with remediation for KiSu showed that removal was most effective when the 
encrypted DB location for the module root had been identified. Removal of this registry location 
terminated all KiSu capabilities on a host including installed persistence through any of the 
mechanisms available. Removal of this directory instantly terminates any KiSu operations and 
removes the attacker’s capability to persist.
As the KiSu persistence method relies on a special instance being loaded and then configured 
with the appropriate mechanism (typically post XP is SOTI), removal of the associated module 
root disables this instance and neuters the associated PC agent on reboot. 
However, this remediation is only relevant for KiSu instance on a target machine and will not 
remove other persistent methods used by DdSz  or other such frameworks   for other payloads/
tools. Additionally, there are multiple methods to persist PC agents on a target machine and 
therefore this method will not guarantee remediation of a DdSz foothold.
F-Secure  |  Killsuit research
17
Our research into KillSuit’s indicators of compromise at installation yielded a variety of 
information, including active installation detection through the abnormal cryptographic provider 
type and a semi-conclusive legacy installation detection using the registry locations collected. 
Other identifiers found, although viable, are more difficult to verify and apply to live systems.
In addition to the indicators discovered, we also encountered a number of the methods put in 
place by the developers to prevent analysis and their development practices. This gave a unique 
insight into the level of effort and sophistication placed into this tool in order for it be successful 
for as long as possible. In fact it was this complexity that prevented us from easily retrieving the 
hard-coded registry installation values, although hopefully the analysis provided will give other 
researchers a solid starting point for further investigation.
The analysis presented in this report focused on the 2013 version of this tooling as such any 
indicators can be used to detect legacy Equation Group breaches or more recent breaches by 
groups reusing legacy tooling. However it is highly likely that the Equation Group themselves 
have redeveloped their tooling since the Shadowbrokers release and the indicators may no 
longer apply to current breaches. As always this emphasises the need for defensive teams to 
focus on continuous research, hunting and response to stay ahead of attackers.
CONCLUSION
F-Secure  |  Killsuit research
18
APPENDIX
Killsuit instance ID list
• PC (PeddleCheap)
• UR (UnitedRake)
• STLA (StrangeLand)
• SNUN (SnuffleUnicorn)
• WRWA (WraithWrath)
• SLSH (SleepySheriff)
• WORA (WoozyRamble)
• TTSU (TiltTsunami)
• SOKN (SoberKnave)
• MAGR (MagicGrain)
• DODA (DoubleDare)
• SAAN (SavageAngel)
• MOAN (MorbidAngel)
• DEWH (DementiaWheel)
• CHMU (ChinMusic)
• MAMO (MagicMonkey)
• MABE (MagicBean)
Full Danderspritz driver list
• "1394ohci","*** SENTRYTRIBE MENTAL ***"
• "ac98intc","*** DARKSKYLINE MENTAL ***"
• "adpkprp","*** KILLSUIT LOADER DRIVER - REMOVE ME ***"