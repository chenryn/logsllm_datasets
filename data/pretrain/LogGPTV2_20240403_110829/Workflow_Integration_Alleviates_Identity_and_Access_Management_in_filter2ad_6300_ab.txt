### Communications and Function Notations
Communications are encoded in the parentheses next to the function, e.g., `f1(WD1)` denotes that function `f1` writes to datastore `D1`, whereas `RD1` would denote a read from the datastore.

### Limitations in Existing Serverless Access Control Techniques
Serverless cloud platforms offer access control policy enforcement at the granularity of functions to ensure the proper security of the application. Each function must be configured with the least-privilege IAM roles and policies. For example, function `f3` only requires read access to the photographer registry `D1`, and function `f4` should only be able to add new assignments to `D4` but not access existing records. While these are the obvious permissions, there are several implicit permissions (e.g., access to the function source files stored in the cloud) that, if misconfigured, can allow attackers to access the function code. The complex policy evaluation logic employed by cloud providers for each function makes defining IAM policies more unintuitive and cumbersome. Even with correctly configured IAM policies, attackers can still leverage leaked cloud access keys for nefarious purposes, such as breaching a cloud data store.

Returning to the example in Figure 1, consider a common scenario where the IAM role for `f3` has been misconfigured, granting it the ability to invoke any function in the application. An attacker invokes `f2`, passing in malicious data that exploits a vulnerability in `f3`. After gaining control of `f3`, they relay commands to invoke `f12`, passing a bad argument that causes the entirety of `D4` to be returned to the function and subsequently transmitted to site visitors by `f13`. Since traditional IAM authorizes each function in isolation, the platform does not detect the violation of information flow, even though the attacker reaches the credit card registry from a completely disjointed application workflow. This motivated us to create our system, `will.iam`, which associates requests with workflow-level permissions to reduce the attack surface of serverless applications.

### Threat Model & Assumptions
In this work, we consider an attacker whose primary goal is to exploit a security vulnerability in a serverless function or misconfigured IAM roles to use the function for malicious purposes. The abundance of accidental access key leakage makes it easier for such attackers to leverage leaked or stolen keys to exfiltrate sensitive data stored in cloud data stores. We assume that the cloud provider employs an IAM service to define cloud resource access policies to prevent data breaches. The cloud provider is trusted and will not mishandle or tamper with the security policies defined by the tenants. We also assume the presence of an API gateway in the cloud platform to handle external requests originating from the public internet and a trusted authentication service that properly authorizes ingress requests. Components like IAM and API gateway are part of the standard cloud design paradigm, confirming the validity of the assumptions. We further assume that all serverless functions are invoked through REST API calls or other forms of Remote Procedure Calls (event triggers, asynchronous callbacks). This assumption is valid because web and API serving are the most popular use cases in the serverless paradigm.

### Policy Design
In this section, we present the design of the access control model and policy representation. In Section 6, we provide additional details of the `will.iam` architecture, including how it is integrated into the cloud platform.

In `will.iam`, access control roles are assigned to workflows, not individual functions. This means that a web request is assigned a role at its point of ingress and is bound to the role's associated permissions throughout its lifecycle in the serverless application.

The security policy consists of two components: the Labeling State and the Protection State. An example policy is given in Figure 2. The Labeling State specifies the permissions associated with a given role, while the Protection State specifies the required permissions to complete a logical routine within the application. Critically, the Protection State does not describe function-by-function permission requirements but instead the end-to-end permission requirements of the workflow. This allows authorization to be performed proactively at the earlier stages of a workflow, reducing the unnecessary use of compute resources.

#### 5.1 Labeling State
We represent the Labeling State as a directed acyclic graph of the form \( G = (V, E) \). Each \( v \in V \) is of the form \( v = (label, type) \), where `label` is an arbitrary string and `type` is one of `"token"`, `"role"`, or `"data"`. Token vertices correspond to authentication tokens, role vertices to RBAC roles, and data vertices to explicit data permissions in the application. The permissible edges in \( E \) are constrained by vertex types: `{token → role, role → role, role → data}`. Each token is associated with at most one role, each role is associated with zero to many data permissions, and for space efficiency, roles can be hierarchical such that parent roles encompass all permissions of their children.

The design of our security policy is intentionally vague on the authentication method to be employed. This is because authentication is ultimately an orthogonal problem best resolved by the application developers. For example, developers may wish to use a password gateway or an OAuth-based approach for role assignment. In our proof-of-concept implementation of `will.iam`, we use a token-based authentication scheme where clients transmit their token in the "Authorization" HTTP header. The `will.iam` framework then hands the token off to an authentication service to determine the role to be associated with the request. Web service authentication is well-researched, so we will not explore it in greater detail in the remainder of this paper.

#### 5.2 Protection State
The Protection State is also represented as a directed acyclic graph of the form \( G = (V, E) \). Each \( v \in V \) is of the form \( v = (label, type) \), where `label` is an arbitrary string and `type` is one of `"ingress"`, `"function"`, or `"data"`. Each edge \( e \in E \) is of the form \( (v_1, v_2) \). Ingress vertices correspond to ingress points of the serverless applications, functions correspond to individual computation components of the application, and data vertices correspond to required explicit data permissions. The permissible edges in \( E \) are constrained by vertex types: `{ingress → function, function → function, function → data}`.

Each ingress vertex is linked to at most one function, each function can link from zero to many intermediate functions, and each last-level function is linked with zero to many data permissions. The protection state graph can be used to perform authorization as follows: a function \( v_{f1} \) may only invoke the API of a function \( v_{f2} \) if there exists an edge \( (v_{f1}, v_{f2}) \). This is comparable to a traditional IAM role on Amazon Lambda, where only "single hop" transitions can be specified. Each path from an ingress vertex to a last-level function vertex encodes a programmed workflow in the application. The end-to-end workflow is authorized if the request is associated with a role that carries all of the required permissions encoded by the children of the last-level function. Thus, in this policy, it is possible to proactively deny a request at the point of ingress if it lacks a necessary permission, even if that permission is not required until deep into the function workflow.

Despite their simplicity, functions often have complex internal workflows, to the point that some functions may only conditionally invoke downstream functions depending on the context of the request. As a result, it may be that the permission set of a workflow is undecidable at the point of ingress. Allowing the request to proceed only if it contained all possibly necessary permissions would be overly restrictive. Instead, to account for this, we introduce a type attribute to each edge in the Protection State where `e.type` is one of `"Mandatory"` or `"Conditional"`. If a conditional edge exists in a workflow, we perform conditional authorization on the request at the point of ingress, checking only the data permissions required by mandatory paths. At each intermediary function in the workflow, we check to see if any conditional requirements have been resolved, potentially re-authorizing the request if they have. The request is only fully authorized to continue once all conditional requirements have been resolved.

#### 5.3 Example Policy Walkthrough
Figure 2 depicts an example security policy for a simple and imaginary human resources application. The application contains five functions (`onboard-employee`, `add-employee`, `add-to-payroll`, `get-employee`, and `view-employee-directory`) and two datastores (`employee` and `payroll`), each with read and write permissions. Requests can be assigned to one of three roles (`employee`, `hr`, or `admin`). The `employee` role only possesses permission to read the `employee` datastore, while the `admin` role is permitted to write to the `employee` datastore and to read and write to `payroll`. The `admin` role possesses all permissions, which is expressed in Figure 2a by positioning `admin` as the parent of both the `employee` and `hr` roles.

Consider the workflow associated with Ingress Point 3. If a request is issued that authenticates and is assigned the `admin` role, it is possible to make an authorization decision for the entire workflow at the point of ingress. This is because the `admin` role possesses the `payroll-read` and `employee-read` permissions. On the other hand, if the request is assigned the `employee` role, it is possible to proactively deny this request at the point of ingress. This role technically has the necessary permissions to execute `view-employee-directory`, but not the permissions required to execute `get-employee`. Allowing the request to execute a portion of the workflow both wastes computation and expands the attack surface of the application, and should thus be avoided.

Let us now consider the workflow associated with Ingress Point 1. This workflow relates to an employee onboarding routine performed by the Human Resources department. The `onboard-employee` function calls the `add-employee` function to register the new employee, as well as the `get-employee` function to return the new record for confirmation. If the employee has already completed and uploaded their direct deposit paperwork, the employee is added to the payroll system as well; otherwise, they are permitted to do so at a later date. As a result, the `onboard-employee` function contains a conditional dependency to `add-to-payroll`, which impacts the permission set of the entire workflow. Therefore, at the ingress point, we can only conditionally authorize the workflow, comparing the role’s permission set to the mandatory permissions `employee-write` and `payroll-read`. If `add-to-payroll` is invoked, the mandatory permission set changes to include `payroll-write`, which must then be verified.

### `will.iam` Architecture
In this section, we present the design of the `will.iam` architecture, which manages and enforces the security policies described above.

#### 6.1 Overview
A diagram of `will.iam` is presented in Figure 3. `will.iam` is comprised of three main components: the API gateway, the policy evaluation service, and the request handler. The API gateway is built into the FaaS platforms to provide an external route to the deployed functions. In `will.iam`, the API gateway is augmented to forward externally generated requests to the policy evaluation service and to forward internally generated invocation requests to the proper function instances. The policy evaluation service is the enforcement point of the access control policies defined for various serverless workflows deployed on the cloud. There is a request handler running in each function instance (i.e., container) that transparently adjusts `will.iam`-specific headers in the invocation request before passing it to the function, making `will.iam` function-agnostic. These three components collaborate to enforce access control in serverless cloud platforms as described in Figure 3.

When an external function execution request arrives at the API gateway (1) in a FaaS platform with `will.iam` enabled, the request is forwarded to an authentication server (2) to assign the designated role to the request based on the authorization header information in the request (3). Next, the request is passed to the policy evaluation service (4) to verify whether the assigned role possesses the necessary data permissions to successfully execute the workflow activated by this request. The policy evaluation service fetches the protection state associated with the request and the labeling state associated with the role and invokes the mandatory policy evaluation routine (5-8). This routine accepts the request if it has the data permissions for executing absolute function invocations in its trajectory through the workflow and forwards the request to the appropriate function container (9-10). Otherwise, the request is denied right at the ingress point even before any function executes. For each of the subsequent function invocations in the workflow, the policy evaluation service fires the conditional policy evaluation routine (11-13). If the function invocation is absolute, then no further processing is necessary, and the request is forwarded to the function container. For a conditional invocation, the data permissions required for that particular invocation are verified before forwarding (14-16).

#### 6.2 API Gateway
In FaaS platforms, the API Gateway handles all incoming requests from the public internet. `will.iam` extends the API gateway to introduce a centralized workflow-aware access control enforcement point in the lifecycle of an incoming request. Upon receiving an external request, the `will.iam` API gateway uses an authentication service to exchange the request’s authorization token for an IAM role, which can be passed along with the request to the policy evaluation service. The API gateway is also responsible for forwarding pre-approved internal requests to their destination function containers. Requests rejected by `will.iam` generate an unauthorized error, and the API gateway propagates the error to the user with necessary information for debugging purposes following the standard design practice of FaaS. The API gateway introduces no additional overhead in executing its tasks and transmits all access control information in-band with the requests that flow between the cloud components, thus avoiding TCP and HTTP overheads.

#### 6.3 Policy Evaluation Service
The policy evaluation service is the centralized access control enforcement point in `will.iam`. This component is designed as a plug-in with defined interfaces to interact with existing serverless platforms. In `will.iam`, the API gateway forwards all externally originated requests to the policy evaluation service, which proactively denies requests with insufficient permissions from executing the entire workflow associated with the ingress request. It also enforces access control for conditional policy violations in internal function requests. The policy evaluation service employs the following methods to achieve its goal.

##### 6.3.1 Mandatory Policy Evaluation
The mandatory policy evaluation routine takes care of denying ingress requests with insufficient permissions. It reads the Protection State graph to obtain the set of permissions \( M \) required to execute the workflow and the Labeling State graph associated with the corresponding IAM role to obtain the set of permissions \( P \) granted to the role. If \( P \subseteq M \), the request is accepted; otherwise, it is denied.