nications are encoded in the parenthesis next to the function, e.g.,
f1(WD1) denotes function f1 writes to datastore D1, whereas RD1
would denote a read from the datastore.
Limitations in existing serverless access control techniques. Server-
less cloud platforms offer access control policy enforcement at the
granularity of functions to ensure proper security of the application.
Each function needs to be configured with the least privilege IAM
roles and policies. For example, function f3 only requires read access
to the photographer registry D1 and function f4 should only be able
to add new assignments to D4, but is barred from accessing existing
records. While these are the obvious permissions to be granted, there
are several implicit permissions (e.g., access to the function source
files stored in a cloud [26]) that if misconfigured can allow attackers
access to the function code [19, 64]. The complex policy evaluation
logic (e.g., [29]) employed by the cloud providers at every function
to authorize a request makes the task of defining IAM policies even
more unintuitive and cumbersome. Even with correctly configured
IAM policies in place, attackers can still leverage leaked cloud access
keys [27, 30, 74] for nefarious purposes, such as a cloud data store
breach [28].
Returning to the example in Figure 1, consider a common sce-
nario [19, 64] in which the IAM role for f3 has been misconfigured,
granting it the ability to invoke any function in the application. The
attacker invokes f2, passing in malcrafted data that exploits a vul-
nerability in f3. After gaining control of f3, they relay commands
to invoke f12, passing a bad argument that causes the entirety of
D4 to be returned to the function and subsequently transmitted to
site visitors by f13. Since traditional IAM authorizes each function
in isolation, it is not clear to the platform that an information flow
has been violated as f13 executes, in spite of the fact that the at-
tacker reaches the credit card registry from a completely disjointed
application workflow. This is what has motivated us to create our
system, will.iam, which associates requests with workflow-level
permissions to reduce serverless applications’ attack surface.
f1RegisterPhotographerf3AssignPhotographerD1Photographer RegistryD2Photo Storagef5MessagePhotographerf4RecordAssignmentf6ReceivePhotof8UpdateStatusf7PhotoSuccessf2Create Productin Catalogf10Browse ProductCatalogD4Credit Card RegistryD3Product Catalogf9PurchaseProductf11Get Pricef12AuthorizeCredit Cardf13PublishPurchase StatusFunctioninvocation triggerPossible attack pathData store readCloud datastoreServerlessfunctioninstancesDData store writeffApplication ingress pointACSAC 2020, December 7–11, 2020, Austin, USA
Arnav Sankaran, Pubali Datta, and Adam Bates
4 THREAT MODEL & ASSUMPTIONS
In this work, we consider an attacker whose primary goal is to exploit
some security vulnerability in a serverless function or misconfigured
IAM roles to use the function for malicious motives. The abundance
of accidental access key leakage [27, 28, 74] makes it easier for such
attackers to leverage leaked or stolen keys to launder sensitive data
stored in cloud data stores. We assume that the cloud provider em-
ploys an IAM service to define cloud resource access policies to
prevent data breaches. The cloud provider is trusted and will not
mishandle or tamper with the security policies defined by the ten-
ants. We also assume the presence of an API gateway in the cloud
platform to handle external requests originating from the public
internet and a trusted authentication service which properly autho-
rizes ingress requests. Components like IAM and API gateway are
part of the standard cloud design paradigm confirming the validity of
the assumptions. We further make the assumption that all serverless
functions are invoked through the use of REST API calls or other
forms of Remote Procedure Calls (event triggers, asynchronous call-
backs). This assumption is valid because web and API serving are
the most popular use cases in the serverless paradigm [62].
5 POLICY DESIGN
In this section, we present the design of the access control model
and policy representation. In Section 6, we present additional details
of the will.iam architecture, including how it is integrated into the
cloud platform.
In will.iam, access control roles are assigned to workflows, not
individual functions. In practice, this means that a web request is as-
signedaroleatitspointofingressandisboundtotherole’sassociated
permissions throughout its lifecycle in the serverless application.
The security policy is comprised of two components, a Labeling
State and a Protection State. An example policy is given in Figure 2.
The Labeling State specifies the permissions associated with a given
role, while the Protection State specifies the required permissions
to complete a logical routine within the application. Critically, the
Protection State does not describe function-by-function permission
requirements, but instead the end-to-end permission requirements
of the workflow. As we will later show, this allows authorization
to be performed proactively at the earlier stages of a workflow to
reduce the unnecessary use of compute resources.
5.1 Labeling State
We represent the Labeling State as a directed acyclic graph of the
form G =. Each v ∈V is of the form v =, where
label is an arbitrary string and type ∈{“token”, “role”, “data”}. Token
vertices correspond to authentication tokens, roles vertices to RBAC
roles, and data vertices to explicit data permissions in the application.
The permissible edges in E are constrained by vertex types:{token→
role, role →role, role →data}. Each token is associated with at most
one role, each role is associated with zero to many data permissions,
and for space efficiency roles can be hierarchical such that parent
roles encompass all permissions of their children.
The design of our security policy is intentionally vague on the
authentication method that should be employed. This is because au-
thentication is ultimately an orthogonal problem that is best resolved
by the application developers. For example, the developers may wish
to use a password gateway or an OAuth-based approach for role as-
signment. In our proof-of-concept implementation of will.iam, we
makeuseofatoken-basedauthenticationschemewhereclientstrans-
mit their token in the "Authorization" HTTP header. The will.iam
framework then hands the token off to an authentication service to
determine the role to be associated with the request. The problem of
web service authentication is well researched (e.g., [43]) so we will
not explore it in greater detail in the remainder of this paper.
5.2 Protection State
The Protection State is also represented as a directed acyclic graph
of the form G =. Each v ∈V is of the form v =,
where label is an arbitrary string and type ∈ {“ingress”, “function”,
“data”}. Each edge e ∈ E is of the form . Ingress
vertices correspond to ingress points of the serverless applications,
functions correspond to individual computation components of the
application,anddataverticescorrespondtorequiredexplicitdataper-
missions. The permissible edges in E are constrained by vertex types:
{inдress → f unction, f unction → f unction, f unction → data}.
Each ingress vertex is linked to at most one function, each func-
tion can link from zero to many intermediate functions, and each
last-level function is linked with zero to many data permissions.
The protection state graph can be used to perform authorization
as follows. A function vf1
may only invoke the API of a function vf2
→vf2
if there exists an edge vf1
; this is comparable to a traditional
IAM role on Amazon Lambda, where only “single hop” transitions
can be specified. Each path from an ingress vertex to a last-level
function vertex encodes a programmed workflow in the application.
The end-to-end workflow is authorized if the request is associated
with a role that carries all of the required permissions encoded by
the children of the last-level function. Thus, in this policy it is pos-
sible to proactively deny a request at the point of ingress if it lacks
a necessary permission, even if that permission is not required until
deep into the function workflow.
Despite their simplicity, functions often complex internal work-
flows,tothepointthatsomefunctionsmayonlyconditionallyinvoke
downstream functions depending on the context of the request. As
a result, it may be that the permission set of a workflow is undecid-
able at the point of ingress. Allowing the request to proceed only
if it contained all possibly necessary permissions would be overly
restrictive; instead, to account for this we introduce a type attribute
to each edge in the Protection State where e.type ∈ {“Mandatory”,
“Conditional”}.Ifaconditionaledgeexistsinaworkflow,weperform
conditional authorization on the request at the point of ingress in
which only the data permissions required by mandatory paths are
checked. At each intermediary function in the workflow, we then
check to see if any conditional requirements have been resolved,
potentially re-authorizing the request if they have. The request is
only fully authorized to continue once all conditional requirements
have been resolved.
5.3 Example Policy Walkthrough
Figure 2 depicts an example security policy for a simple and imag-
inary human resources application. The application contains five
functions (onboard-employee, add-employee, add-to-payroll,
Workflow Integration Alleviates Identity and Access Management in Serverless Computing
ACSAC 2020, December 7–11, 2020, Austin, USA
(a) Labeling State Graph
(b) Protection State Graph
Figure 2: Example will.iam Security Policy. In Figure 2a, trapezoids are authentication tokens, octagons are the roles associated
with those tokens, and diamonds are the permissions associated with those roles. Traversing the graph from a token to
its terminal children specifies the token’s permission set. In Figure 2b, rectangles are application ingress points, ovals are
functions, and diamonds are permissions. Each path between an ingress point and a terminal child represents an application
workflow, with the terminal children of the last function specifying the required permissions of the entire workflow.
get-employee, and view-employee-directory) and two datas-
tores (employee and payroll), each with read and write permis-
sions. Requests can be assigned to one of three roles (employee, hr,
or admin). The employee role only possesses permission to read the
employee datastore, while the admin role is permitted to write to the
employee datastore and to read and write to payroll. The admin
role possesses all permissions, which is expressed in Figure 2a by
positioning admin as the parent of both the employee and hr roles.
Consider the workflow associated with Ingress Point 3. If a re-
quest is issued that authenticates and is assigned the admin role, it
is possible to make an authorization decision for the entire work-
flow at the point of ingress. This is because the admin role pos-
sesses the payroll-read and employee-read permissions. On the
other hand, if the request is assigned the employee role, it is pos-
sible to proactively deny this request at the point of ingress. This
role technically has the necessary permissions to execute view-
employee-directory, but not the permissions required to execute
get-employee. Allowing the request to execute a portion of the
workflow both wastes computation and expands the attack surface
of the application, and should thus be avoided.
Let us now consider the workflow associated with Ingress Point 1.
Thisworkflowrelatestoanemployee-onboardingroutineperformed
by the Human Resources department. The onboard-employee func-
tion calls the add-employee function to register the new employee,
as well as the get-employee function to return the new record for
confirmation. If the employee has already completed and uploaded
their direct deposit paperwork, the employee is added to the pay-
roll system as well, but if not they are permitted to do so at a later
date. As a result, the onboard-employee function contains a condi-
tional dependency to add-to-payroll, which impacts the permis-
sion set of the entire workflow. Therefore, at the ingress point we
can only conditionally authorize the workflow, comparing the role’s
permission set to the mandatory permissions employee-write and
payroll-read. If add-to-payroll is invoked, the mandatory per-
mission set changes to include payroll-write, which must then be
verified.4
6 WILL.IAM ARCHITECTURE
In this section, we present the design of the will.iam architecture,
which manages and enforces the security policies described above.
6.1 Overview
A diagram of will.iam is presented in Figure 3. will.iam is com-
prised of three main components: the API gateway, the policy eval-
uation service and the request handler. The API gateway is built
into the FaaS platforms to provide an external route to the deployed
functions. In will.iam, the API gateway is augmented to forward
externally generated requests to the policy evaluation service and
to forward internally generated invocation requests to the proper
function instances. The policy evaluation service is the enforcement
point of the access control policies defined for various serverless
workflows deployed on the cloud. There is a request handler running
in each function-instance (i.e. container) that transparently adjusts
will.iam-specific headers in the invocation request before passing
it to the function, thus making will.iam function-agnostic. These
three components collaborate to enforce access control in serverless
cloud platforms as described in Figure 3.
When an external function execution request arrives at the API
gateway ( 1 ) in a FaaS platform with will.iam enabled, the request is
forwarded to an authentication server ( 2 ) to assign the designated
role to the request as per the authorization header information in
the request ( 3 ). Next, the request is passed to the policy evaluation
service ( 4 ) to verify whether the assigned role possesses necessary
data permissions to successfully execute the workflow activated by
this request. The policy evaluation service fetches the protection
state associated with the request and the labeling state associated
4Note that, in our simplified example, only the hr role can execute this workflow
regardless of whether the conditional branch is taken.
Authentication Token 1role:employeeAuthentication Token 2role:adminAuthentication Token 3role:hrdata:employee-readdata:payroll-writedata:payroll-readdata:employee-writeIngress Point 1func:onboard-employeeIngress Point 2func:get-employeeIngress Point 3func:view-employee-directoryfunc:add-employeefunc:add-to-payrolldata:employee-writedata:payroll-writedata:payroll-readdata:employee-readACSAC 2020, December 7–11, 2020, Austin, USA
Arnav Sankaran, Pubali Datta, and Adam Bates
Figure 3: An overview of the will.iam architecture and its authorization workflow.
with the role and invokes the mandatory policy evaluation routine
( 5 - 8 ). This routine accepts the request if it has the data permissions
for executing absolute function invocations in its trajectory through
the workflow and forwards the request to the appropriate function
container( 9 - 10 ).Otherwisetherequestisdeniedrightattheingress
point even before any function executes. For each of the subsequent
function invocations in the workflow, the policy evaluation service
fires the conditional policy evaluation routine ( 11 - 13 ). If the function
invocation is absolute, then no further processing is necessary and
the request is forwarded to the function container, whereas for a
conditional invocation data permissions required for that particular
invocation are verified before forwarding ( 14 - 16 ).
6.2 API Gateway
In FaaS platforms, the API Gateway handles all incoming requests
from the public internet. will.iam extends the API gateway to intro-
duce a centralized workflow-aware access control enforcement point
in the lifecycle of an incoming request. Upon receiving an external
request, the will.iam API gateway uses an authentication service to
exchange the request’s authorization token for an IAM role which
can be passed along with the request to the policy evaluation service.
The API gateway is also responsible for forwarding pre-approved
internal requests to their destination function containers. Requests
rejected by will.iam generate an unauthorized error, and the API
gateway propagates the error to the user with necessary information
for debugging purposes following the standard design practice of
FaaS. The API gateway introduces no additional overhead in exe-
cuting its tasks and transmits all access control information in-band
with the requests that flow between the cloud components, thus
avoiding TCP and HTTP overheads.
6.3 Policy Evaluation Service
The policy evaluation service is the centralized access control en-
forcementpointinwill.iam.Thiscomponentisdesignedasaplug-in
with defined interfaces to interact with existing serverless platforms.
In will.iam, the API gateway forwards all externally originated
requests to the policy evaluation service that proactively denies
requests with insufficient permissions from executing the entire
workflow associated with the ingress request. It also enforces ac-
cess control for conditional policy violations in internal function
requests. The policy evaluation service employs the following meth-
ods to achieve its goal.
6.3.1 Mandatory Policy Evaluation. The mandatory policy evalua-
tion routine takes care of denying ingress requests with insufficient
permissions. It reads the Protection State graph to obtain the set of
permissions M required to execute the workflow, and the Labeling
State graph associated with the corresponding IAM role to obtain the