g
n
s
s
e
c
o
r
p
r
e
v
r
e
S
 0.35
 0.3
 0.25
 0.2
 0.15
 0.1
 0.05
 0
 0
Figure 5 (a)
Figure 5 (b)
)
s
(
e
m
i
t
n
o
i
t
a
r
a
p
e
r
p
t
n
e
i
l
C
 0.09
 0.08
 0.07
 0.06
 0.05
 0.04
 0.03
 0.02
 0.01
 0
 5
 10
 15
 20
 0  2  4  6  8  10  12  14  16  18
Data privacy level, τ
Privacy level, t
Figure 5 (c)
)
s
(
e
m
i
t
n
o
i
t
c
u
r
t
s
n
o
c
e
r
a
t
a
D
 0.25
 0.2
 0.15
 0.1
 0.05
 0
 0  2  4  6  8  10  12  14  16  18
Privacy level, t
Figure 5. Performance measurements for the τ -independent version of the protocol.
References
[1] D. Asonov. Private Information Retrieval: An overview and
current trends. In Proceedings of the ECDPvA Workshop,
Informatik 2001, September 2001.
[2] A. Beimel and Y. Stahl. Robust Information-Theoretic
Private Information Retrieval. In Third Conference on
Security in Communication Networks, Lecture Notes in
Computer Science 2576, pages 326–341. Springer-Verlag,
2002.
[3] B. Chor and N. Gilboa. Computationally Private
Information Retrieval. In 29th Annual ACM Symposium on
Theory of Computing, pages 304–313, 1997.
[4] B. Chor, O. Goldreich, E. Kushilevitz, and M. Sudan.
Private Information Retrieval. In 36th Annual Symposium
on Foundations of Computer Science, pages 41–50, 1995.
[5] Y. Gertner, S. Goldwasser, and T. Malkin. A Random
Server Model for Private Information Retrieval. In 2nd
International Workshop on Randomization and
Approximation Techniques in Computer Science, Lecture
Notes in Computer Science 1518, pages 200–217.
Springer-Verlag, 1998.
[6] I. Goldberg. Percy++ project on SourceForge.
http://percy.sourceforge.net/.
[7] V. Guruswami and M. Sudan. Improved Decoding of
Reed-Solomon and Algebraic-Geometry Codes. IEEE
Transactions on Information Theory, 45(6):1757–1767,
September 1999.
[8] E. Kushilevitz and R. Ostrovsky. Replication is Not
Needed: Single Database, Computationally Private
Information Retrieval. In 38th Annual Symposium on
Foundations of Computer Science, pages 364–373, October
1997.
[9] S. Micali, C. Peikert, M. Sudan, and D. A. Wilson. Optimal
Error Correction Against Computationally Bounded Noise.
In Theory of Cryptography, Second Theory of
Cryptography Conference, Lecture Notes in Computer
Science 3378, pages 1–16. Springer-Verlag, February 2005.
[10] P. Paillier. Public-Key Cryptosystems Based on Composite
Degree Residuosity Classes. In Advances in
Cryptology—Eurocrypt ’99, Lecture Notes in Computer
Science 1592, pages 223–238. Springer-Verlag, 1999.
[11] L. Sassaman, B. Cohen, and N. Mathewson. The Pynchon
Gate: A Secure Method of Pseudonymous Mail Retrieval.
In Workshop on Privacy in the Electronic Society (WPES
2005), pages 1–9, November 2005.
[12] L. Sassaman and B. Preneel. The Byzantine Postman
Problem: A Trivial Attack against PIR-based Nym Servers.
Technical Report ESAT-COSIC 2007-001, Katholieke
Universiteit Leuven, February 2007.
[13] SciFace Software. Mathematics Mastered with MuPAD
Pro. http://www.sciface.com/products/mupadpro.php.
[14] A. Shamir. How to Share a Secret. Communications of the
ACM, 22(11):612–613, 1979.
[15] V. Shoup. NTL: A Library for doing Number Theory.
http://shoup.net/ntl/.
[16] M. Tompa and H. Woll. How to Share a Secret with
Cheaters. J. Cryptology, 1(2):133–138, 1988.
[17] E. Y. Yang, J. Xu, and K. H. Bennett. Private Information
Retrieval in the Presence of Malicious Failures. In
Computer Software and Applications Conference 2002
(COMPSAC 2002), August 2002.
A Detailed proofs
Proof of Theorem 1. In step P2, the client deﬁnes r polyno-
mials f1, . . . , fr of degree t. Deﬁne the s polynomials Fc
fjWjc for 1 ≤ c ≤ s, where the Wjc are
the words in the database as deﬁned as in step S2. Note that
these polynomials Fc are also of degree (at most) t, and also
to be Fc = X1≤j≤r
δjβWjc = Wβc.
that Fc(0) = X1≤j≤r
fj(0)Wjc = X1≤j≤r
β
β
)}, where B(xw)
Suppose server i is one of the servers that responds. In
step S1, it receives [f1(αi), . . . , fr(αi)] from the client. In
fj(αi)Wjc = Fc(αi) for
step S3, it computes Ric = X1≤j≤r
1 ≤ c ≤ s, and returns these values to the client in step S4.
The client initializes H to be {(G, ǫ)} in step C1, where
G is the set of server numbers that responded. We claim
that after x iterations of the loop at C4, H will be the set
{(G, B(xw)
is a string consisting of the
ﬁrst xw bits of the database block Bβ. We proceed by
induction: we have already shown that this is the case for
x = 0. Suppose it is true for x = c− 1 for some 1 ≤ c ≤ s.
Now consider iteration c.
the client calls
EASYRECOVER(S, w, t, h, H, [R1c, . . . , Rℓc], [α1, . . . , αℓ])
where Rjc = Fc(αj) for each j ∈ G.
By the induction hypothesis, there is exactly one ele-
ment of H, so the loop at E2 will execute only once. In
step E4, the client will necessarily ﬁnd φ = Fc, since
φ(αj) = Rjc = Fc(αj ) for each j ∈ G, and so for each
j ∈ I ⊆ G. Since these two polynomials φ and Fc of de-
gree at most t agree on at least t + 1 points of I, they must
be equal. Therefore the W in step E5 will just be the w-bit
representation of Fc(0) = Wβc, which is the cth w-bit word
of block β of the database.
In step C5,
Then in step E6, Γ(φ) ∩ G will equal G, so H′ will be
set to {(G, σ||W )}. By the induction hypothesis, σ is the
ﬁrst (c − 1)w bits of Bβ, so σ||W is the ﬁrst cw bits of Bβ,
and the proof of the claim is complete.
Therefore, after all s = b/w iterations of the loop at C4,
β
h , B(xw)
) where G(x)
H will equal {(G, Bβ)}, as required.
Proof of Theorem 2. As above, we will prove that after x
iterations of the loop at C4, H will be a set containing the
element (G(x)
h is the set of server num-
bers that both replied at all, and also replied honestly in the
ﬁrst x words of its reply, and B(xw)
is deﬁned as before. For
x = 0, this is trivially true. Suppose it is true for x = c − 1
for some 1 ≤ c ≤ s. Now consider iteration c. We can
assume the client calls HARDRECOVER in step C6, since
as we noted earlier, EASYRECOVER produces the same an-
swer as HARDRECOVER when it produces an answer at all.
HARDRECOVER will produce a set of polynomials in
step H2, one of which will necessarily be Fc (as deﬁned
β
above). This set may have polynomially (in k) many el-
ements, but we will see in section 3.4 that the probability
that this set contains elements other than the desired one
can be made arbitrarily small, ensuring that the entire pro-
tocol runs in (probabilistic) polynomial time. When the
loop at H3 encounters the element Fc, Wi will be set to
Fc(0) = Wβc (as deﬁned above). By the induction hypothe-
sis, step H5 will ﬁnd the element (G(c−1)
) ∈ H.
But also Γ(Fc) ⊇ Gh, so Γ(Fc) ∩ G(c−1)
⊇ Gh, so
|Γ(Fc) ∩ G(c−1)
| ≥ h. Then step H5 will add (Γ(Fc) ∩
G(c−1)
, B((c−1)w)
||Wβc) = (G(c)
) to H′, and the
proof is complete.
, B((c−1)w)
h , B(cw)
h
h
h
h
β
β
β
Proof of Fact 3. We start with the following Lemma:
it
|Γ(φ)| ≥ h,
Lemma. There is a polynomial PS(k), depending only on
whether S is a ring or a ﬁeld, such that the size of the set
of candidate polynomials {φi} output in step H2 is at most
PS(k).
Proof of Lemma. For ﬁelds S, the algorithm of [7] works
by constructing a bivariate polynomial Q(x, y) over S
with the property that for any (univariate) polynomial
is the case that (y −
φ such that
φ(x)) is a factor of Q. This polynomial Q has degree
t (cid:18)h − 1 + h(cid:22) kt+√(kt)2+4(h2−kt)
(cid:23)(cid:19)(cid:23) in y, so the num-
(cid:22) 1
of this value is what produces the restriction that h > √kt.)
With some simple algebra, it is easy to see that if 1 ≤ t < k
and √kt < h ≤ k, that value is bounded by 2k2.
For rings S = Zpq, we proceed modulo p and q sepa-
rately, and combine the results using the Chinese Remain-
der Theorem, matching factors using Γ(φ). This can poten-
tially increase the bound on the number of possible results
to (2k2)2.
ber of such factors is at most that value. (The denominator
2(h2−kt)
Note that neither of these bounds is tight.
Each of the at most s calls to HARDRECOVER will pro-
duce a set of at most PS(k) polynomials in step H2. Each
of these polynomials φ will have |Γ(φ)| ≥ h. But since
h, the number of honest servers, is more than half the total
number of servers that replied, at least some of the elements
of Γ(φ) must be server numbers of honest servers. For each
φ, there must be at least one such element, and for each φ
other than the correct one, there must be at most t (other-
wise, φ would agree with the correct polynomial in more
than t places, and so it would indeed be the correct polyno-
mial). The key observation, similar to that in [16], is that if
the Byzantine servers cannot know the values of αj for hon-
est server numbers j, then they only have a small chance of
producing incorrect polynomials that agree with the correct
polynomial at one of the honest αj.
Let Z be the set {αj : server j is not honest}, and Y be
the set {αj : server j is honest}. We want to bound the
probability that, of the ≤ sPS(k) polynomials returned in
step H2, and of the ≤ t points of I\Z at which each of these
polynomials agree with the correct polynomials, the result-
ing ≤ stPS(k) points have non-trivial intersection with the
set Y . But |I\Z| = |I| − (ℓ − h), and |Y | = h, so that
probability is at most hstPS(k)
|I|−ℓ+h , as required.