cated by a trusted authority. Two nodes can authenticate
each other and establish a secure and reliable end-to-end
connection by employing, e.g., IPsec [20, 21, 22]. For sim-
plicity, we assume the nodes’ public keys have a unform size,
e.g., 1024 bits.
We assume the adversary can eavesdrop all network traf-
ﬁc. The adversary may also control a fraction of nodes in
the network, and it may modify/replay/drop a transmitted
message. The objective of the adversary may be to iden-
tify the sender/recipient of a given message, or trace the
end-to-end communication relationship.
Table 1 shows the major notation used throughout the
paper.
4. THE PROPOSED PROTOCOL
In the proposed protocol, the participating nodes are or-
SID
BID
P KA
P KA{M}
KAi{M}
K−1
{M}
KAi
Ai
MAi
M ACAi
RAB
RABi
H()
f ()
KFi
CK
RF
Ni
Table 1: Notation
session ID
message batch ID
the public key of node A
encryption of message M using public key P KA
the ith secret key generated by node A
encryption of message M using secret key KAi
decryption of message M using secret key KAi
the ith message sent by node A
message authentication code computed using
secret key KAi
one-way key chain generated by node A and
assigned to node B
the ith key-chain key in key chain RAB
the function used to generate one-way key chain
a secure one-way function whose output is
1024-bit long
key chain update ﬂag with value i, where i = 0
means the ﬂag is not set
commitment of key chain update. Contains a
node ID and a commitment of new key chain if
KF is set. Otherwise, it is a random value
a receiver ﬂag
a random number
ganized with a collection of logical ring structures. Within
each ring, a transmission mechanism using message batching
ensures a node can anonymously send messages to any other
member node without disclosing its identity. To anony-
mously communicate with a recipient that may reside in
another ring, a sender follows the transmission mechanism
and sends its messages to a randomly selected agent node in
the local ring. These messages contain an ID of the desti-
nation ring in which the recipient resides. If the destination
ring is the local ring, i.e., the sender and the recipient are
in the same ring, the agent node broadcasts the messages
locally, i.e., to all member nodes in the ring. Otherwise,
it forwards the messages to a node in the destination ring.
The latter broadcasts the received messages locally. The
recipient thus receives the messages without disclosing its
identity.
If each ring has at least k honest nodes, as we
will show through our analysis, the proposed protocol will
provide provable k-anonymity protection to both the sender
and the recipient.
In the following subsections, we will present the proposed
protocol in detail. We ﬁrst introduce its network topology.
Next, we describe the transmission mechanism that allows a
node to anonymously send messages to other member node
in the local ring. After that, we show the solution that is
based on the above transmission mechanism and allows ar-
bitrary two nodes to communicate anonymously. Finally, we
discuss the update of key chains used by the nodes to anony-
mously identify the origin and the order of their messages
in the proposed protocol.
4.1 Network Topology
As illustrated by ﬁgure 1, the proposed protocol adopts
a hierarchical topology used in many peer-to-peer systems
(or protocols), e.g., KaZaa [4], Gnutella v0.6 [3] and Herbi-
vore [16], to organize the network. That is the participating
nodes are classiﬁed into a set of small subgroups. Since the
nodes in each subgroup are further organized with a logical
ring structure, each subgroup is also referred to as a ring in
this paper. Each ring is uniquely identiﬁed by a ring ID.
47
the solution that allows arbitrary two nodes to anonymously
exchange messages to the next subsection.
4.2.1 Transmission Initialization
A ring needs a two-stage initialization once a new ses-
sion is triggered. The purpose of such an initialization is
two-fold. First, the nodes need to set up a message batch
that contains exactly one message from each node in the
ring without disclosing the sender’s identity of each mes-
sage. A node’s message is thus mixed with the other nodes’
messages in the message batch. Second, each node secretly
assigns one unique one-way key chain to each of the other
nodes in the ring without disclosing its identity. These key
chains are used to identify the order of received messages
and thus prevent the message replay attacks. They also al-
lows a node to verify whether the received message batch
contains exactly one message from each node in the ring.
Our later analysis will show these key chains will not aﬀect
the anonymity provided by the proposed protocol.
After the two-stage initialization, a node can send data
to any other node in the ring anonymously by replacing its
old message in the received message batch. Figures 2 and 3
illustrate the procedure of transmission initialization.
Stage One: Message Batch Construction To start the
initialization, a speciﬁc super node that is referred to as the
starting node (e.g., the super node A in ﬁgure 2) sends an
initialization packet (PA1) to its next hop in the clockwise
direction of the ring (referred to as the ring direction). This
initialization packet is signed by node A. It consists of a n-
slot key vector and an encrypted dummy message, where n is
the number of nodes in the ring. Each slot conceals a secret
key, a session ID and a message authentication code. For
instance, the ﬁrst slot is P K0{K1, SID, M AC1} and the ith
slot is Ki−1{...K1{P Ki{Ki, SID, M ACi}}...}. The dummy
message is used to for two purposes: (i) to construct the
message batch, and (ii) to anonymously assign each member
node a unique one-way key chain used in later anonymous
communication. It has a standard size and a strict format,
i.e., a n-slot key vector plus the anonymizing payload, where
the elements in a key vector slot of the dummy message are
diﬀerent from those in the key vector slot of the initialization
packet. Such standard message size and message format
are two public parameters of the ring and are applied to
all transmitted messages in the ring. We will discuss the
message format and how the key chains are distributed later.
Once receiving the initialization packet from the starting
node, the immediate downstream node (e.g., node B in ﬁg-
ure 2) uses its private key to decrypt the ﬁrst key vector slot.
It thus gets the secret key, session ID and message authenti-
cation code concealed in this slot. The node then checks the
packet signature, decrypted session ID, and message authen-
tication code to ensure the correctness and integrity of the
packet, while the message authentication code is calculated
based on the concealed secret key and the rest part of the
packet. If the checking result proves correct, the node re-
moves the signature and the ﬁrst key vector slot, and it uses
the previously resulting secret key to decrypt the remaining
slots and the dummy message. After that, the node sends
the changed initialization packet and a new one generated
by itself to the next hop at a random order. These two ini-
tialization packets are digitally signed by the node, and they
have the same number of key vector slots (i.e., n − 1) and
the packet size.
Figure 1: An illustration of network topology of the
proposed protocol.
It has at least ϑ nodes, where ϑ > k and k is a predeter-
mined parameter representing the least degree of anonymity
provided by the ring. We will discuss how to determine the
value of ϑ later.
For convenience, we classify the member nodes of a ring
into two categories, regular node and super node. A regular
node is a node that has no direct connection to the nodes in
other rings, and it relies on the local super node(s) to for-
ward packets across rings. A super node is one that provides
the message forwarding service across rings. It also has the
responsibility for local ring management, such as accepting
new nodes. Each ring may have multiple super nodes in
order to avoid a single point of failure.
It is worth noting that (i) we adopt the admission rule
used in many peer-to-peer systems to group the nodes, i.e.,
the lower υ bits of the hash value of a member node’s ID
should be equal to those of the ring ID, where υ is the num-
ber of bits used for representing the ring ID. It ensures that
the rings are approximately the same size, and also pre-
vents attackers from crowding out all but one honest node
in a targeted ring. (ii) Even though many super node se-
lection mechanisms e.g., [10, 25, 36], have been presented,
we suggest adopting the election mechanism in [10], since
it ensures all nodes have equal probability to be elected as
the super node by using Byzantine fault-tolerant method
when less than 1/3 nodes are malicious. And (iii) the su-
per node should inform all nodes (in the local ring) about
the ring conﬁguration information, e.g., the list of member
nodes, their positions in the ring and their public keys, and
other parameters, including the current session ID, uniform
message size, and encryption algorithms. A session is de-
ﬁned by the event of ring structure changing, e.g., nodes
joining/leaving or the position changing of a node.
4.2 Anonymous Transmission in a Local Ring
The anonymous transmission mechanism in a local ring
is the cornerstone of the proposed protocol.
It eﬀectively
hides the sender of an anonymous message (from the other
nodes including the super node forwarding this message).
In this subsection, we present the detail of this transmission
mechanism: the transmission initialization and the message
transmission along the ring, and the detection of adversaries
that do not follow this transmission mechanism. We defer
48
Ring YRing XRing Zrectly. This node is identiﬁed as the attacker. The nodes
revoke the attacker from the ring and restart the transmis-
sion initialization.
Lemma 1. A polynomial time adversary cannot link an
honest node with a speciﬁc (received) initialization packet or
reversely, if there are more than one received initialization
packets originated from honest nodes.
Proof. (Sketch) Suppose an honest node A receives l ini-
tialization packets while only one of them (M0) originated
from an honest node (suppose node B). Node A decrypts
M0 with a secret key K concealed in the ﬁrst key vector slot
of M0. The resulting new packet is denoted as M1. Node A
sends M1 and its own initialization packet M2 (at a random
order) to the next hop. Since K is encrypted using node
A’s public key, it is computationally infeasible for a polyno-
mial time adversary A to calculate K from M0. Without
knowing K, A cannot link M0 with M1 with a probability
signiﬁcantly better than 1/2 (i.e., random guessing), recall-
ing the semantic security of symmetric key encryption. In
other words, A cannot link node A with M2 or link node
B with M1 with a probability signiﬁcantly better than 1/2,
even A can link node B with M0. Similarly, if there are r
received initialization packets originated from diﬀerent hon-
est nodes, A cannot successfully identify the sender of each
(honest) initialization packet with a probability signiﬁcantly
greater than 1/r.
Stage Two: Message Batch Checking and Key Chain
Distribution As an intermediate node may maliciously re-
place the received initialization packets in stage one, the
nodes need to verify whether the resulting message batch
contains exactly one dummy message from each node in the
ring. Therefore, the nodes need to assign a unique key chain
to each member node secretly in stage two. These key chains
are used to identify the origin and the order of the nodes’
messages without disclosing the latter’s identities. They not
only prevent the potential replay attacks in later anonymous
communication but also allow a node to verify whether a
received message batch contains exactly one message from
each member node in the ring. Figure 3 illustrates the proce-
dure of message batch checking and key chain distribution
by showing the propagation of node E’s dummy message
without losing universality.
The starting node (e.g., node A in ﬁgure 3) forwards the
message batch (formed at stage one) to the next hop, while
each message is digitally signed by the starting node. As
stated earlier, a dummy message and the later transmitted
anonymous data message consist of a n-slot key vector and
the ﬁxed-lengthed anonymizing payload. Each key vector
slot has a standard size decided by the key length of the
employed public key encryption algorithm. As illustrated in
ﬁgure 3, each slot contains a receiver ID, a session ID (SID),
a recipient ﬂag (RF ), a key chain update ﬂag (KF ), a new
key-chain key (Rn) in the assigned key chain, a key chain
update commitment (CK), a one-time secret key (Ki), a
random number (Ni), and a message authentication code
(M ACi).
When a node receives a message in the message batch,
e.g., node B receives ME1, it decrypts the ﬁrst key vector
slot and checks the integrity of ME1 based on the value of
each ﬁeld in the slot. If the checking result proves negative,
node B starts the detection of modiﬁcation as described in
Figure 2: An illustration of message batching.
The sender precalculates the M ACs in a reversed
order, e.g., M ACA8 ﬁrst, then M ACA7, and so on.
M AC in a key vector slot is calculated based on
the secret key concealed in this slot and the rest
part of the packet assuming this slot becomes the
ﬁrst slot, e.g., M ACA2 is computed based on KA2 and
KA2{P KD{KA3, SID, M ACA3}}..||KA2{..{DummyM essage}..}.
The digital signature is not shown in the ﬁgure.
The other member nodes in the ring follow the same steps,
i.e., after receiving d initialization packets from the previous
hop, decrypt each of them, remove the ﬁrst key vector slot,
and then forward d + 1 initialization packets to the next hop
at a random order, where d is the number of hops between
a node and the starting node. As a result, the number of