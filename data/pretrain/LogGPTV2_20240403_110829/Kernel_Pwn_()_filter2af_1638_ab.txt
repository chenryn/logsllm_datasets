Open | fopen | file_operations: open  
Close | fread | file_operations: read  
Write | fwrite | file_operations: write  
Close | fclose | file_operations: release  
Remove | rmmod | module_exit()  
    #include 
    #include 
    #include 
    MODULE_LICENSE("Dual BSD/GPL");
    static int hello_init(void) 
    {
        printk(" Hello world!n");
        return 0;
    }
    static void hello_exit(void) 
    {
        printk(" Bye, cruel worldn");
    }
    module_init(hello_init);
    module_exit(hello_exit);
    struct file_operations module_fops = 
    {
        read: module_read,
        write: module_write,
        open: module_open,
        release: module_release
    };
å…¶ä¸­ï¼Œmodule_init/module_exitæ˜¯åœ¨è½½å…¥/å¸è½½è¿™ä¸ªé©±åŠ¨æ—¶è‡ªåŠ¨è¿è¡Œï¼›è€Œfopç»“æ„ä½“å®ç°äº†å¦‚ä¸Šå››ä¸ªcallbackï¼Œå†’å·å³ä¾§çš„å‡½æ•°åæ˜¯ç”±å¼€å‘è€…è‡ªå·±èµ·çš„ï¼Œåœ¨é©±åŠ¨ç¨‹åºè½½å…¥å†…æ ¸åï¼Œå…¶ä»–ç”¨æˆ·ç¨‹åºç¨‹åºå°±å¯ä»¥å€ŸåŠ©
**æ–‡ä»¶æ–¹å¼** åƒè¿›è¡Œç³»ç»Ÿè°ƒç”¨ä¸€æ ·è°ƒç”¨è¿™äº›å‡½æ•°å®ç°æ‰€éœ€åŠŸèƒ½ã€‚
## 0x04 ç¯å¢ƒé…ç½®
ä¸åŒäºç”¨æˆ·æ€çš„pwnï¼ŒKernel-Pwnä¸å†æ˜¯ç”¨pythonè¿œç¨‹é“¾æ¥æ‰“payloadæ‹¿shellï¼Œè€Œæ˜¯ç»™ä½ ä¸€ä¸ªç¯å¢ƒåŒ…ï¼Œä¸‹è½½åqemuæœ¬åœ°èµ·ç³»ç»Ÿã€‚å¯¹äºä¸€ä¸ªKernel-Pwnæ¥è¯´ï¼Œé¢˜ç›®é€šå¸¸ä¼šç»™å®šä»¥ä¸‹æ–‡ä»¶ï¼š
    boot.sh: ä¸€ä¸ªç”¨äºå¯åŠ¨ kernel çš„ shell çš„è„šæœ¬ï¼Œå¤šç”¨ qemuï¼Œä¿æŠ¤æªæ–½ä¸ qemu ä¸åŒçš„å¯åŠ¨å‚æ•°æœ‰å…³
    bzImage: kernel binary
    rootfs.cpio: æ–‡ä»¶ç³»ç»Ÿæ˜ åƒ
è§£é‡Šä¸€ä¸‹ qemu å¯åŠ¨çš„å‚æ•°ï¼š
  * -initrd rootfs.cpioï¼Œä½¿ç”¨ rootfs.cpio ä½œä¸ºå†…æ ¸å¯åŠ¨çš„æ–‡ä»¶ç³»ç»Ÿ
  * -kernel bzImageï¼Œä½¿ç”¨ bzImage ä½œä¸º kernel æ˜ åƒ
  * -cpu kvm64,+smepï¼Œè®¾ç½® CPU çš„å®‰å…¨é€‰é¡¹ï¼Œè¿™é‡Œå¼€å¯äº† smep
  * -m 64Mï¼Œè®¾ç½®è™šæ‹Ÿ RAM ä¸º 64Mï¼Œé»˜è®¤ä¸º 128M å…¶ä»–çš„é€‰é¡¹å¯ä»¥é€šè¿‡ â€”help æŸ¥çœ‹ã€‚
æœ¬åœ°å†™å¥½ exploit åï¼Œå¯ä»¥é€šè¿‡ base64 ç¼–ç ç­‰æ–¹å¼æŠŠç¼–è¯‘å¥½çš„äºŒè¿›åˆ¶æ–‡ä»¶ä¿å­˜åˆ°è¿œç¨‹ç›®å½•ä¸‹ï¼Œè¿›è€Œæ‹¿åˆ° flagã€‚åŒæ—¶å¯ä»¥ä½¿ç”¨ musl,
uclibc ç­‰æ–¹æ³•å‡å° exploit çš„ä½“ç§¯æ–¹ä¾¿ä¼ è¾“ã€‚
ä½†æ˜¯ä¸ºäº†æˆ‘ä»¬è°ƒè¯•Demoæ–¹ä¾¿ï¼Œæˆ‘ä»¬æœ€å¥½åœ¨æœ¬åœ°ä¹Ÿç¼–è¯‘ä¸€ä¸ªbzImageã€‚
âš ï¸ï¼šéƒ¨åˆ†Kernelæ¼æ´åªå½±å“ä½ç‰ˆæœ¬ï¼Œé«˜ç‰ˆæœ¬çš„Kernelå·²å¯¹è„†å¼±çš„æœºåˆ¶è¿›è¡Œäº†ä¸€å®šç¨‹åº¦çš„éåˆ¶ä¹ƒè‡³è¿›è¡Œäº†æ¶ˆé™¤ï¼Œä½†æ˜¯å’ŒGlibcç›¸åŒï¼Œéƒ¨åˆ†ä¸­ä½ç‰ˆæœ¬çš„å†…æ ¸ä»æœ‰å¾ˆé«˜çš„ç”¨æˆ·é‡ï¼Œå› æ­¤æˆ‘ä»¬å¯¹äºä½ç‰ˆæœ¬Kernelçš„æ¼æ´ç ”ç©¶å¹¶éæ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼ŒåŒæ—¶ï¼Œåœ¨å®é™…è°ƒè¯•Demoæ—¶ï¼Œè¯·ç‰¹åˆ«æ³¨æ„Demoæ¼æ´å½±å“çš„Kernelç‰ˆæœ¬ã€‚
âš ï¸ï¼šä»¥ä¸‹å®‰è£…æ­¥éª¤ä»…åœ¨`Ubuntu 16.04`å®Œæˆäº†æµ‹è¯•ã€‚
###  ä¸‹è½½Linux Kernelæºç å¹¶è§£å‹
`wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.5.6.tar.xz`
###  é…ç½®ç¯å¢ƒ
ç¼–è¯‘kerneléœ€è¦å¾ˆå¤šlibï¼Œæ‰€ä»¥è¯·æ‰§è¡Œä»¥ä¸‹å‘½ä»¤å®‰è£…ç›¸å…³ç¯å¢ƒï¼š
`sudo apt-get install bison libncurses* build-essential openssl zlibc minizip
libidn11-dev libidn11 libssl-dev flex ncurses-devel libncurses5-dev`
###  Kernelç¼–è¯‘é…ç½®
è¿è¡Œä»¥ä¸‹å‘½ä»¤è¿›è¡Œé…ç½®å³å¯
`make menuconfig`
é…ç½®ç»“æŸä¼šåœ¨å½“å‰ç›®å½•ç”Ÿæˆ`.config`ï¼Œè‹¥éœ€è¦ä¹‹åä¿®æ”¹é…ç½®ï¼Œå¯ä»¥ç›´æ¥ç¼–è¾‘`.config`åå†æ¬¡ç¼–è¯‘å³å¯ã€‚
###  ç¼–è¯‘
ä½¿ç”¨`make`è¿›è¡Œç¼–è¯‘å³å¯ï¼Œè‹¥éœ€è¦æ›´å¿«çš„ç¼–è¯‘ï¼Œè¯·ä½¿ç”¨`make -j8`ã€‚
## 0x05 Kernel Stackoverflow
ğŸ“šï¼šæœ¬éƒ¨åˆ†å…¨æ–‡ç¿»è¯‘è‡ª[Exploiting Stack Overflows in the Linux Kernel â€“ Jon
Oberheide](https://jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/)çš„ç›¸å…³å†…å®¹ã€‚
æ­¤å¤„å°†ä»‹ç»Linuxå†…æ ¸ä¸­å †æ ˆæº¢å‡ºçš„åˆ©ç”¨æŠ€æœ¯ã€‚è¯·æ³¨æ„ï¼Œè¿™å¹¶ä¸æ˜¯æŒ‡å†…æ ¸å †æ ˆä¸Šçš„ç¼“å†²åŒºæº¢å‡ºï¼Œè€Œæ˜¯å†…æ ¸å †æ ˆçš„ä¸æ­£ç¡®æ‰©å±•ï¼Œè¿™å¯¼è‡´å…¶å¯èƒ½ä¸æŸåçš„å…³é”®ç»“æ„é‡å ã€‚
è¿™æ˜¯Linuxå†…æ ¸ä¸­çš„ä¸€ä¸ªæ¼æ´ç±»ã€‚
###  å†…æ ¸æ ˆå¸§(Kernel Stack Layout)
åœ¨Linuxä¸Šï¼Œæ¯ä¸ªç³»ç»Ÿçº¿ç¨‹éƒ½åœ¨å†…æ ¸å†…å­˜ä¸­åˆ†é…äº†ç›¸åº”çš„å†…æ ¸å †æ ˆã€‚ x86ä¸Šçš„Linuxå†…æ ¸å †æ ˆçš„å¤§å°ä¸º4096æˆ–8192å­—èŠ‚ï¼Œè¿™å…·ä½“å–å†³äºæ‚¨çš„å‘è¡Œç‰ˆã€‚
å°½ç®¡æ­¤å¤§å°ä¼¼ä¹å°åˆ°æ— æ³•åŒ…å«å®Œæ•´çš„è°ƒç”¨é“¾å’Œç›¸å…³çš„æœ¬åœ°å †æ ˆå˜é‡ï¼Œä½†å®é™…ä¸Šå†…æ ¸è°ƒç”¨é“¾ç›¸å¯¹è¾ƒæµ…ï¼Œå¹¶ä¸”åœ¨Kernelä¸­ä¸é¼“åŠ±æ»¥ç”¨å¸¦æœ‰å¤§å±€éƒ¨å †æ ˆå˜é‡çš„å†…æ ¸å‡½æ•°æ¥å ç”¨å®è´µç©ºé—´ï¼Œå½“ä½¿ç”¨é«˜æ•ˆçš„åˆ†é…å™¨(å¦‚SLUB)æ—¶ï¼Œè¿™ä¸ªå¤§å°æ˜¯å®Œå…¨å¤Ÿç”¨çš„ã€‚
å†…æ ¸å †æ ˆä¸thread_infoç»“æ„å…±äº«4k / 8kçš„æ€»å¤§å°ï¼Œè¯¥ç»“æ„åŒ…å«æœ‰å…³å½“å‰çº¿ç¨‹çš„ä¸€äº›å…ƒæ•°æ®ï¼Œå¦‚`include/linux/sched.h`ä¸­æ‰€ç¤ºï¼š
    union thread_union {
        struct thread_info thread_info;
        unsigned long stack[THREAD_SIZE/sizeof(long)];
    };
thread_infoç»“æ„åœ¨x86ä¸‹æœ‰å¦‚ä¸‹å®šä¹‰ï¼š(`arch/x86/include/asm/thread_info.h`)
    struct thread_info {
        struct task_struct *task;
        struct exec_domain *exec_domain;
        __u32      flags;
        __u32      status;
        __u32      cpu;
        int          preempt_count;
        mm_segment_t  addr_limit;
        struct restart_block restart_block;
        void __user     *sysenter_return;
    #ifdef CONFIG_X86_32
        unsigned long  previous_esp;
        __u8      supervisor_stack[0];
    #endif
        int          uaccess_err;
    };
å†…æ ¸å †æ ˆåœ¨å†…å­˜ä¸­å‘ˆç°å¦‚ä¸‹æ‰€ç¤ºçš„ç»“æ„ï¼š
é‚£ä¹ˆï¼Œå½“å†…æ ¸å‡½æ•°éœ€è¦è¶…è¿‡4k / 8kçš„å †æ ˆç©ºé—´æˆ–ä½¿ç”¨äº†é•¿è°ƒç”¨é“¾ä»¥è‡³äºè¶…å‡ºå¯ç”¨å †æ ˆç©ºé—´æ—¶ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ
**é€šå¸¸æƒ…å†µä¸‹ï¼Œè¿™ä¼šå¯¼è‡´å †æ ˆæº¢å‡ºçš„å‘ç”Ÿï¼Œå¹¶ä¸”å¦‚æœthread_infoç»“æ„æˆ–è¶…å‡ºæ›´ä½åœ°å€å¤„çš„å…³é”®å†…å­˜æŸåï¼Œåˆ™ä¼šå¯¼è‡´å†…æ ¸å´©æºƒã€‚
ä½†æ˜¯ï¼Œå¦‚æœå†…å­˜å¯¹é½å¹¶ä¸”å­˜åœ¨å®é™…å¯ä»¥æ§åˆ¶å†™å…¥å †æ ˆåŠå…¶ä»¥å¤–çš„æ•°æ®çš„æƒ…å†µï¼Œåˆ™å¯èƒ½å­˜åœ¨å¯åˆ©ç”¨çš„æ¡ä»¶ã€‚**
###  Kernelæ ˆæº¢å‡ºæ”»å‡»
æ¥ä¸‹æ¥è®©æˆ‘ä»¬çœ‹ä¸€çœ‹æ ˆæº¢å‡ºå’Œthread_infoç»“æ„çš„ç ´åæ˜¯å¦‚ä½•å¯¼è‡´ææƒçš„å‘ç”Ÿçš„ã€‚
    static int blah(int __user *vals, int __user count)
    {
        int i;
        int big_array[count];
        for (i = 0; i restart_block;
        return restart->fn(restart);
    }
è€Œ`restart_syscal`låœ¨`arch/x86/kernel/syscall_table_32.S`ä¸­è¢«å®šä¹‰ï¼š
    .long sys_restart_syscall /* 0 - old "setup()" system call, used for restarting */
å®é™…ä¸Šå®ƒçš„ç³»ç»Ÿè°ƒç”¨å·ç ä¸ºé›¶ã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼ä»ç”¨æˆ·æ€ä¸­è°ƒç”¨å…¶åŠŸèƒ½ï¼š
    syscall(SYS_restart_syscall);
è¿™å°†ä½¿å†…æ ¸è°ƒç”¨è°ƒç”¨åœ¨restart_blockç»“æ„ä¸­çš„å‡½æ•°æŒ‡é’ˆã€‚
**å¦‚æœæˆ‘ä»¬å¯ä»¥ç ´åthread_infoçš„restart_blockæˆå‘˜ä¸­çš„å‡½æ•°æŒ‡é’ˆï¼Œåˆ™å¯ä»¥å°†å…¶æŒ‡å‘æˆ‘ä»¬æ§åˆ¶ä¸‹çš„ç”¨æˆ·ç©ºé—´ä¸­çš„å‡½æ•°ï¼Œé€šè¿‡è°ƒç”¨sys_restart_syscallè§¦å‘å…¶æ‰§è¡Œï¼Œå¹¶æå‡ç‰¹æƒã€‚**
###  Linux ææƒæ€è·¯
ä¹‹å‰è¯´è¿‡ï¼Œæ‰§è¡Œ`commit_creds(prepare_kernel_cred(0))`ï¼Œå¯ä»¥ä½¿è¿›ç¨‹çš„æƒé™æå‡ä¸º`root`ï¼Œç„¶åæˆ‘ä»¬è¿”å›åˆ°ç”¨æˆ·æ¨¡å¼ï¼Œæ‰§è¡Œ`iret`æŒ‡ä»¤ã€‚
#### å…³äº`iret`æŒ‡ä»¤
å½“ä½¿ç”¨IRETæŒ‡ä»¤è¿”å›åˆ°ç›¸åŒä¿æŠ¤çº§åˆ«çš„ä»»åŠ¡æ—¶ï¼ŒIRETä¼šä»å †æ ˆå¼¹å‡ºä»£ç æ®µé€‰æ‹©å­åŠæŒ‡ä»¤æŒ‡é’ˆåˆ†åˆ«åˆ°CSä¸IPå¯„å­˜å™¨ï¼Œå¹¶å¼¹å‡ºæ ‡å¿—å¯„å­˜å™¨å†…å®¹åˆ°EFLAGSå¯„å­˜å™¨ã€‚
å½“ä½¿ç”¨IRETæŒ‡ä»¤è¿”å›åˆ°ä¸€ä¸ªä¸åŒçš„ä¿æŠ¤çº§åˆ«æ—¶ï¼ŒIRETä¸ä»…ä¼šä»å †æ ˆå¼¹å‡ºä»¥ä¸Šå†…å®¹ï¼Œè¿˜ä¼šå¼¹å‡ºå †æ ˆæ®µé€‰æ‹©å­åŠå †æ ˆæŒ‡é’ˆåˆ†åˆ«åˆ°SSä¸SPå¯„å­˜å™¨ã€‚
æ ˆä¸Šä¿å­˜äº†`trap frame`ï¼Œè¿”å›åˆ°ç”¨æˆ·æ¨¡å¼çš„æ—¶å€™ï¼Œæ¢å¤ä¿¡æ¯ä»ä»¥ä¸‹å¾—å¾—ç»“æ„è¯»å–ï¼š
    struct trap_frame 
    {
        void* eip;                // instruction pointer +0
        uint32_t cs;              // code segment    +4
        uint32_t eflags;          // CPU flags       +8
        void* esp;                // stack pointer       +12
        uint32_t ss;              // stack segment   +16
    } __attribute__((packed));
## 0x06 Kernel Null Pointer Dereference
ğŸ“šï¼šæœ¬éƒ¨åˆ†éƒ¨åˆ†ç¿»è¯‘è‡ª[A Kernel Exploit Step by Step â€“
akliilias](https://www.coursehero.com/file/49274885/kernel-exploit-step-by-steppdf/)çš„ç›¸å…³å†…å®¹ã€‚
2009å¹´8æœˆï¼ŒTavis Ormandyå’ŒJulien Tinneså‘ç°äº†ä¸€ä¸ªæ¼æ´ï¼Œè¯¥æ¼æ´å½±å“äº†è‡ª2001å¹´ä»¥æ¥çš„æ‰€æœ‰2.4åˆ°2.6Linuxå†…æ ¸ã€‚  
é—®é¢˜çš„æ ¹æºæ˜¯å› ä¸ºä»¥ä¸‹æœºåˆ¶ï¼šåœ¨Linuxæ“ä½œç³»ç»Ÿä¸­ï¼Œè™šæ‹Ÿå†…å­˜åˆ†é…äºå†…æ ¸ç©ºé—´å’Œç”¨æˆ·ç©ºé—´ä¹‹é—´ã€‚
åœ¨x86ä¸Šï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ä¸€ä¸ªå†…å­˜æ˜ å°„ï¼Œè¯¥å†…å­˜æ˜ å°„åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç”¨æˆ·ç©ºé—´æœ€å¤§ä¸º3GBï¼ˆåœ°å€0xC0000000ï¼‰ï¼Œæœ€åä¸€ä¸ªGBæ˜¯ä¸ºå†…æ ¸ä¿ç•™çš„ã€‚
å°½ç®¡å­˜åœ¨ç‰¹æƒåˆ†ç¦»ï¼Œä½†å®ƒä»¬éƒ½å…±äº«ç›¸åŒçš„åœ°å€ç©ºé—´ã€‚
###  Demo
    #include 
    #include 
    #include 
    #include 
    int main(){
        uint32_t *mem=NULL;
        mem=mmap(NULL, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
        if (mem != NULL) {
            fprintf(stdout,"[âˆ’] UNABLE TO MAP ZERO PAGE!n");
            exit(0);
        }
        fprintf(stdout, "[+] MAPPED ZERO PAGE!n");
        printf("0x%08X: 0x%08X n",(uint32_t)mem, *(uint32_t*)0);
        mem[0] = 0xDEADBEAF;
        printf("0x%08X: 0x%08X n",(uint32_t)mem, *(uint32_t*)0);
        printf("[+] It worked !!n");
        munmap(mem,0x1000);
        mem[0] = 0xDEADBEAF;
        return 0;
    }
è¿™ä¸ªDemoè¯•å›¾ä½¿ç”¨`mmap`åœ¨`NULL`å¤„åˆ†é…0x1000å¤§å°çš„å†…å­˜æ˜ å°„ï¼Œæ­£å¸¸æƒ…å†µä¸‹ï¼Œç¨‹åºåº”å½“è¿”å›`[âˆ’] UNABLE TO MAP ZERO
PAGE!n`ã€‚
ä½†æ˜¯ï¼Œåœ¨æŸäº›ç‰ˆæœ¬çš„Kernelä¸Šï¼Œè¿™ä¸ªDemoå´å¯ä»¥å‘ä¸‹è¿è¡Œï¼Œè¿›è€Œä½¿æˆ‘ä»¬åˆ†é…åˆ°0åœ°å€çš„æ˜ å°„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ç›´æ¥åœ¨0åœ°å€å¤„æ„å»ºshellcodeå¹¶æ‰§è¡Œã€‚
## 0x07 ä»¥[Root-Me]LinKern x86 â€“ Buffer overflow basic 1ä¸ºä¾‹
é¢˜ç›®ç»™å®šäº†`bzImageã€ch1.cã€initramfs.imgã€runã€run.c`è¿™å‡ ä¸ªæ–‡ä»¶
å…¶ä¸­`bzImage`ä¸ºå†…å­˜æ˜ åƒï¼Œé‚£ä¹ˆ`initramfs.img`å¿…å®šä¸ºæ–‡ä»¶ç³»ç»Ÿï¼Œè§£å‹å¯ä»¥å‘ç°åŠ è½½åˆ°å†…æ ¸çš„æ¨¡å—æ–‡ä»¶ã€‚
äº‹å®ä¸Šï¼Œæ­¤æ—¶æˆ‘ä»¬å·²ç»å¯ä»¥é€šè¿‡å¦‚ä¸‹å‘½ä»¤ï¼š
    qemu-system-i386 -kernel bzImage 
    -s 
    -append nokaslr 
    -initrd initramfs.img 
    -fsdev local,security_model=passthrough,id=fsdev-fs0,path=/home/error404/Desktop/CTF_question/Kernel/Buffer_overflow_basic_1/Share 