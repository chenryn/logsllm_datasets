1"
反击恶意软件: 
源头做起不不挖坑 
DEF"CON"CHINA"1.0"(2019)"
DEF CON CHINA 1.0 (2019) 
by Alexandre Borges 
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
DEF"CON"CHINA"1.0"(2019)"
2"
ü  Malware and Security 
Researcher. "
ü  Speaker at DEFCON USA 2018 
ü  Speaker at HITB 2019 
Amsterdam 
ü  Speaker at CONFidence Conf. 
2019 
ü  Speaker at BSIDES 
2018/2017/2016 
ü  Speaker at H2HC 2016/2015 
ü  Speaker at BHACK 2018 
ü  Consultant, Instructor and 
Speaker on Malware Analysis, 
Memory Analysis, Digital 
Forensics and Rookits. "
ü  Reviewer member of the The 
Journal of Digital Forensics, 
Security and Law."
ü
R f
Di i
l
⽬目录: 
"
v  介绍 
v  反逆向和虚拟封装器器 
v  METASM 
v  MIASM 
v  DTRACE on Windows 
v  反虚拟化 
v  结论 
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
介绍 
DEF"CON"CHINA"1.0"(2019)"
3"
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
DEF"CON"CHINA"1.0"(2019)"
4"
ü  我们⽇日常处理理的恶意软件样本中都会使⽤用⼏几个已知的包例例如：ASPack, Armadillo, 
Petite, FSG, UPX, MPRESS, NSPack, PECompact, WinUnpack 等等. 他们中的⼤大多数很容
易易⽤用⼀一个脚本来解压缩。 
ü  我们也知道⼀一些经常⽤用来创建和分配内存的API，例例如： 
ü  VirtualAlloc/Ex( ) 
ü  HeapCreate( ) / RtlCreateHeap( ) 
ü  HeapReAlloc( ) 
ü  GlobalAlloc( ) 
ü  RtlAllocateHeap( ) 
ü  此外，我们还知道如何使⽤用调试器器、断点和从内存中转储未打包的内容来解压缩
它们。来自Hasherezade的pe-sieve⾮非常优秀。J 
ü  当我们意识到恶意软件使⽤用了了⼀一些定制的打包技术时，仍然可以从内存中转储它，
用Python代码修复ImageAddress字段，并在IDA Pro中使用impscan插件对各自的IAT进
⾏行行分析: 
ü  export VOLATILITY_PROFILE=Win7SP1x86 
ü  python vol.py -f memory.vmem procdump -p 2096 -D . --memory  (to keep slack space) 
ü  python vol.py -f memory.vmem impscan --output=idc -p 2096 
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
DEF"CON"CHINA"1.0"(2019)"
5"
//############################################################# 
// ⽂文件名字      :  dumpexe.txt (first draft) 
//  注释              :  转储包含可执⾏行行程序的内存段 
//  作者              :  Alexandre Borges 
//  ⽇日期              :  today 
//############################################################# 
entry: 
msg "转储包含可执⾏行行程序的模块." 
msg "在继续之前，您必须在EP" 
bc
 // 清楚已有断点 
bphwc
 // 清楚已有硬件断点 
bp VirtualAlloc
 // 在VirtualAlloc设置断点 
erun
 // 运行并将所有的第⼀一个异常传递给应⽤用程序 
core: 
sti
 // 单步执⾏行行 
sti
 // 单步执⾏行行 
sti
 // 单步执⾏行行 
sti
 // 单步执⾏行行 
sti
 // 单步执⾏行行 
x64dbg  
script 
1/3 
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
DEF"CON"CHINA"1.0"(2019)"
6"
find cip,"C2 1000“  // 找到VirtualAlloc的返回点 
bp $result
 // 设置断点 
erun
 // 运⾏行行并将所有的第⼀一个异常传递给应⽤用程序 
cmp eax,0
 // 测试eax(没有分配内存)是否等于零 
je pcode  
 // 跳转到pcode标签 
bpm eax,0,x
 // 设置可执⾏行行内存断点，如果中断并恢复它。 
erun
 //运⾏行行并将所有的第⼀一个异常传递给应⽤用程序 
//尝试查找模块内存中是否有“This program”字符串.  
findall $breakpointexceptionaddress,"546869732070726F6772616D”   
cmp $result,0
 // 检查是否找到 
je pcode  
 // 跳转到pcode标签 
$dumpaddr = mem.base($breakpointexceptionaddress)
 //找到存储基址.  
$size = mem.size($breakpointexceptionaddress)   
 //找到存储的⼤大⼩小. 
savedata :memdump:,$dumpaddr,$size 
 //转储段. 
msgyn "Memory dumped! Do you want continue?“   
 //显示会话 
cmp $result,1
 //检查选择 
je scode  
 // 跳转到Scode标签 
bc
 // 清除已有断点 
bphwc
 // 清除已有硬件断点 
ret
 // 退出 
x64dbg  
script 2/3 
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
DEF"CON"CHINA"1.0"(2019)"
7"
pcode: 
msgyn "没有PE文件!要继续吗?" 
cmp $result,0
 // 检查我们是否不不想继续 
je final 
sti
 //单步执⾏行行 
erun
 // 运⾏行行并将所有第⼀一个异常传递给应⽤用程序 
jmp core  
 // 跳转到core标签 
scode: 
msg "Let's go to next dump“  // 显示会话 
erun
 // 运⾏行行并将所有第⼀一个异常传递给应⽤用程序 
jmp core  
 // 跳转到core标签 
final: 
bc
 // 清除已有断点 
bphwc
 // 清除已有硬件断点 
ret
 // 退出 
!
x64dbg  
script 3/3 
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
"反逆向 
DEF"CON"CHINA"1.0"(2019)"
8"
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
DEF"CON"CHINA"1.0"(2019"
9"
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
ü  混淆的目的是保护软件不不被逆向分析，知识产权不不被侵犯，对我们⽽而⾔言是保
护恶意代码。J 事实上, 混淆并不不能真正保护软件, 但它可以增加逆向⼈人员的
难度。 
ü  因此，混淆通过强制逆向⼈人员花费资源和时间来破译代码。 
ü  分析恶意⼈人员⽤用VBA和Powershell编写的常⻅见的⽤用户恶意软件时，我们都会看
到混淆的代码，所以这似乎没什什么⼤大不不了了的。  
ü  我们可以使用IDA Pro SDK编写插件来扩展IDA Pro的功能，分析一些代码和数
据流，甚至⾃自动解压奇怪的恶意⽂文件。 
ü  此外，如果您在分析修改后的MBR时遇到问题，那么您甚⾄至可以编写⼀一个加
载器器来加载MBR结构并在IDA Pro中分析它。 J 
ü  不幸的是，有些打包程序和保护程序，如VMprotect、Themida、Arxan和Agile . 
Net，使用了现代的混淆技术，因此代码的逆向过程⾮非常复杂。 
DEF"CON"CHINA"1.0"(2019)"
10"
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
ü ⼤大多数保护程序在64位代码中使⽤用(恶意软件)。 
ü 原始IAT从原始代码中删除（通常适⽤用于任何包装器器）。然而，像
Themida这样的包装商的IAT只保留一个功能(TlsSetValue)。 
ü 他们中⼏几乎全部包含字符串串加密.  
ü 它们保护和检查内存完整性。因此，不不可能从内存中转储⼲干净的可执
⾏行行⽂文件(例例如，使⽤用波动性)，因为原始指令没有在内存中解码。 
ü 指令(x86/x64代码)被虚拟化并转换为虚拟机指令(RISC指令)。 
ü .NET 保护器器重命名类, ⽅方法, 域和外部引⽤用.  
DEF"CON"CHINA"1.0"(2019)"
11"
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
ü 一些包装器可以使用指令加密内存作为额外的内存层。 
ü 混淆是基于堆栈的，因此很难静态地处理理虚拟化代码。 
ü 虚拟化代码是多态的，所以有许多表示引⽤用相同的CPU指令。 
ü 有很多假的push指令。 
ü 有许多死代码和⽆无⽤用代码。 
ü 有⼀一些代码使⽤用⽆无条件跳转重新排序。 
ü 所有的混淆器都使用代码扁平化。 
ü 打包器⼏几乎没有反调试器器和反虚拟化技巧。然而，几个月前，我看到
了⼀一个不不太常⻅见的基于温度的anti-vmware技巧(稍后会详细介绍)。 
DEF"CON"CHINA"1.0"(2019)"
12"
int defcon(int x) 
“Virtualizer” 
(bytecodes) 
vm_call_1(opcodes, x) 
获取字节，将其解码为指
令并将其分派给处理理程序 
v  使⽤用虚拟机的保护器器引⼊入模糊代码: 
ü  上下⽂文切换组件，它将注册表和标志信息“传输”到VM上下文(虚拟机)。相反的
移动稍后从VM机器和本机(x86/x64)上下文中完成(适合在解包过程中保持在C结
构中 J) 
ü  从本机寄存器器到虚拟寄存器器的这种“转换”可以是⼀一对⼀一的，但并不不总是这样。 
ü  在虚拟机内部，循环是: 
ü  获取指令 
ü  解码 
ü  找到指向指令的指针，并在处理理程序表中查找关联操作码 
ü  调⽤用⽬目标处理理程序  
ALEXANDRE"BORGES"–"MALWARE"AND"SECURITY"RESEARCHER"
DEF"CON"CHINA"1.0"(2019)"
13"
B 
C 
H 