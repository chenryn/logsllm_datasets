创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行
很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造
的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并
从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资
源。
4.1.3.2. newFixedThreadPool
创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大
多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，
则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何
线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之
前，池中的线程将一直存在。
13/04/2018 Page 57 of 283
4.1.3.3. newScheduledThreadPool
创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。
ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3);
scheduledThreadPool.schedule(newRunnable(){
@Override
public void run() {
System.out.println("延迟三秒");
}
}, 3, TimeUnit.SECONDS);
scheduledThreadPool.scheduleAtFixedRate(newRunnable(){
@Override
public void run() {
System.out.println("延迟1秒后每三秒执行一次");
}
},1,3,TimeUnit.SECONDS);
4.1.3.4. newSingleThreadExecutor
Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程
池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！
4.1.4. 线程生命周期(状态)
当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。
在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞
(Blocked)和死亡(Dead)5种状态。尤其是当线程启动以后，它不可能一直"霸占"着CPU独自
运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换
4.1.4.1. 新建状态（NEW）
当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配
内存，并初始化其成员变量的值
13/04/2018 Page 58 of 283
4.1.4.2. 就绪状态（RUNNABLE）：
当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和
程序计数器，等待调度运行。
4.1.4.3. 运行状态（RUNNING）：
如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状
态。
4.1.4.4. 阻塞状态（BLOCKED）：
阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。
直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状
态。阻塞的情况分三种：
等待阻塞（o.wait->等待对列）：
运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)
中。
同步阻塞(lock->锁池)
运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线
程放入锁池(lock pool)中。
其他阻塞(sleep/join)
运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，
JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O
处理完毕时，线程重新转入可运行(runnable)状态。
4.1.4.5. 线程死亡（DEAD）
线程会以下面三种方式结束，结束后就是死亡状态。
正常结束
1. run()或call()方法执行完成，线程正常结束。
异常结束
2. 线程抛出一个未捕获的Exception或Error。
调用stop
3. 直接调用该线程的stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用。
13/04/2018 Page 59 of 283
4.1.5. 终止线程 4种方式
4.1.5.1. 正常运行结束
程序运行结束，线程自动结束。
4.1.5.2. 使用退出标志退出线程
一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的
运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：
最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false来控制while
循环是否退出，代码示例：
public class ThreadSafe extends Thread {
public volatile boolean exit = false;
public void run() {
while (!exit){
//do something
}
}
}
定义了一个退出标志exit，当exit为true时，while循环退出，exit的默认值为false.在定义exit
时，使用了一个 Java 关键字 volatile，这个关键字的目的是使 exit 同步，也就是说在同一时刻只
能由一个线程来修改exit的值。
4.1.5.3. Interrupt方法结束线程
使用interrupt()方法来中断线程有两种情况：
13/04/2018 Page 60 of 283
1. 线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，
会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。
阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让
我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实
际上是错的， 一定要先捕获InterruptedException异常之后通过break来跳出循环，才能正
常结束run方法。
2. 线程未处于阻塞状态：使用isInterrupted()判断线程的中断标志来退出循环。当使用
interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。
public class ThreadSafe extends Thread {
public void run() {
while (!isInterrupted()){ //非阻塞过程中通过判断中断标志来退出
try{
Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出
}catch(InterruptedException e){
e.printStackTrace();
break;//捕获到异常之后，执行break跳出循环
}
}
}
}
4.1.5.4. stop方法终止线程（线程不安全）
程序中可以直接使用thread.stop()来强行终止线程，但是stop方法是很危险的，就象突然关
闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：
thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子
线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用
thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈
现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因
此，并不推荐使用stop方法来终止线程。
4.1.6. sleep与wait 区别
1. 对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于
Object类中的。
13/04/2018 Page 61 of 283
2. sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然
保持者，当指定的时间到了又会自动恢复运行状态。
3. 在调用sleep()方法的过程中，线程不会释放对象锁。
4. 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此
对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。
4.1.7. start与 run区别
1. start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，
可以直接继续执行下面的代码。
2. 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运
行。
3. 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运
行run函数当中的代码。 Run方法运行结束， 此线程终止。然后CPU再调度其它线程。
4.1.8. JAVA后台线程
1. 定义：守护线程--也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公
共服务，在没有用户线程可服务时会自动离开。
2. 优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。
3. 设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程
的方式是在 线程对象创建 之前 用线程对象的setDaemon方法。
4. 在Daemon线程中产生的新线程也是Daemon的。
5. 线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的
生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程
依旧是活跃的。
6. example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,
程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线
程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统
中的可回收资源。
7. 生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周
期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依
赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退
出了；如果还有一个或以上的非守护线程则JVM不会退出。
13/04/2018 Page 62 of 283
4.1.9. JAVA锁
4.1.9.1. 乐观锁
乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为
别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数
据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），
如果失败则要重复读-比较-写的操作。
java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入
值是否一样，一样则更新，否则失败。
4.1.9.2. 悲观锁
悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人
会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。
java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，
才会转换为悲观锁，如RetreenLock。
4.1.9.3. 自旋锁
自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁
的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），
等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。
线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程
也不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。
如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁
的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。
自旋锁的优缺点
自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来
说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会
导致线程发生两次上下文切换！
但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合
使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量
线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，
其它需要cup的线程又不能获取到cpu，造成cpu的浪费。所以这种情况下我们要关闭自旋锁；