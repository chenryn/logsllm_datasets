avionics task set ( Table 6 in Appendix) and the resulting frequency
14https://www.msoon.com/high-voltage-power-monitor
(a) Outstanding peak count
(b) Average slot entropy
Figure 8: The results indicate (a) Vanilla EDF yields a large
number of peaks that are useful for adversaries to learn the
schedule while there are no significant amount of peaks de-
tected with ğœ–-Scheduler and (b) ğœ–-Scheduler generates diver-
sified schedules with higher entropy (i.e., more randomness).
spectra are shown in Figure 7. As revealed by the peaks displayed
in Figure 7(a), the task periods are easily identifiable in the sched-
ule generated by the vanilla EDF scheduler because of its work-
conserving nature. Itâ€™s worth pointing out that the 100ğ‘šğ‘  (i.e., 10ğ»ğ‘§)
value does not show up as a peak in the spectrum because the cor-
responding task has a very small execution time (i.e., 0.002ğ‘šğ‘ ).
Figure 7(b) shows the spectrum of the same task set scheduled
under the TaskShuffler EDF scheduler and the result is similar to
the vanilla EDF scheduler except with more base noise. This is due
to the high task set utilization (i.e., 0.64 in this case) that provides
fewer opportunities for obfuscating the schedule. While the task set
may not be exhaustive, it does demonstrate the shortcoming of the
TaskShufflerâ€™s randomization protocol â€“ it gets less effective when
the system utilization is high. This shortcoming can also be seen in
later experiments. On the other hand, Figure 7(c) and (d) show the
spectra when scheduled using the ğœ–-Scheduler with ğœ– = 103 and
ğœ– = 10, respectively. Both settings add significant noise across the
entire frequency domain. As a result, no peaks stand out, especially
ones that match the task frequencies.
The green lines shown in Figure 7 are the moving peak threshold
calculated using the Z-score based peak detection algorithm (see
Appendix F for details). From the figures we can see that the thresh-
old is useful for identifying the outstanding peaks while filtering
out background noise. The outstanding peaks represent the true
periodicity coming out of the schedule and thus are particularly
useful for attackers to reconstruct timing information. Intuitively,
the more outstanding peaks that are collected, the more precise
information the attackers have available to them.
Next we use the aforementioned peak detection algorithm to
count the number of outstanding peaks and test with extensive
simulations to get a broader understanding of the effectiveness
of ğœ–-Scheduler in obscuring the task periodicity. The experiment
results are presented in Figure 8(a) where each point represents the
result of a task set for the corresponding scheduler. As expected,
the vanilla EDF scheduler yields systems with stronger periodicity
and more peaks that stand out. On the other hand, the TaskShuf-
fler EDF scheduler can effectively obscure the task periodicity for
most of the task sets except those with higher utilization. With ğœ–-
Scheduler, no significant peaks are detected due to the addition of
larger overall noise in both ğœ– = 103 and ğœ– = 10 settings. The result
also demonstrates that the efficacy of ğœ–-Scheduler is independent
of the task utilization, in contrast with Vanilla and TaskShuffler.
0102030405060708090100110120130140150160170180190200Frequency(Hz)0.00.20.40.60.81.0Amplitude(Normalized)FrequencyAmplitudePeakThreshold0102030405060708090100110120130140150160170180190200Frequency(Hz)0.00.20.40.60.81.0Amplitude(Normalized)FrequencyAmplitudePeakThreshold0102030405060708090100110120130140150160170180190200Frequency(Hz)0.00.20.40.60.81.0Amplitude(Normalized)FrequencyAmplitudePeakThreshold0102030405060708090100110120130140150160170180190200Frequency(Hz)0.00.20.40.60.81.0Amplitude(Normalized)FrequencyAmplitudePeakThresholdSession 3A: Side Channel CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea676Figure 9: The inference precision results of 10 Â· ğ¿ğ¶ğ‘€(ğ‘‡ğ‘œ,ğ‘‡ğ‘£)
grouped by the task set utilization. The experiment suggests
that ğœ–-Scheduler can offer effective protection against the
ScheduLeak attack. Such an effect is independent to the at-
tack duration and the task set utilization.
8.2.2 Average Slot Entropy. Next we analyze the schedules by mea-
suring their average slot entropy. The notion of Schedule Entropy
was first introduced to calculate the randomness given to a task
schedule by the TaskShuffler scheduling algorithm [61]. They then
proposed the Upper-Approximated Schedule Entropy,(cid:101)ğ»Î“(S), to em-
pirically estimate the schedule entropy of a given task set. A bound
is then derived by Vreman et al. [57] showing the legitimacy of
such estimation. As the scale of the entropy depends on the length
of the schedule under analysis, in this paper we use Average Slot
Entropy [57] that calculates the mean slot entropy based on the
upper-approximated schedule entropy.
âˆ’ 1
ğ‘£ =
ğ‘‡ğ‘£
2
The results are shown in Figure 8(b). Similar to Figure 8(a), a
point represents the average slot entropy of a task set under the cor-
responding scheduler. The results indicate that ğœ–-Scheduler yields
higher entropy than the other two schedulers even when the system
utilization is high (note that TaskShuffler EDF fails to obfuscate the
schedules in these instances). For the ğœ–-Scheduler, ğœ– = 10 generally
performs better than ğœ– = 103 w.r.t. the entropy as the former has a
wider variation range for the noise-enhanced inter-arrival times.
Inference Precision. To understand the effectiveness of our
8.2.3
mechanisms against scheduler side-channel attacks, we carry out
the ScheduLeak attacks [14] against the simulation tasks. The met-
ric, inference precision [14, Definition 2], denoted by Iğ‘œ
ğ‘£, was intro-
duced to evaluate the effectiveness of a side-channel attack w.r.t.
the task phase inference. It represents the precision of the inferred
phase(cid:102)ğœ™ğ‘£ compared to the true phase of a target task ğœ™ğ‘£. The infer-
(cid:12)(cid:12)(cid:12)(cid:12) A larger Iğ‘œ
that the inference(cid:102)ğœ™ğ‘£ is more precise in inferring ğœ™ğ‘£.
3(cid:5)+1)-th task and the victim task is selected as the (ğ‘›âˆ’(cid:4) ğ‘›
the ((cid:4) ğ‘›
3(cid:5))-
To illustrate, let us consider a task set consisting of ğ‘ tasks
Î“ = {ğœ1, ğœ2, ...ğœğ‘›} whose task IDs are ordered by their periods (i.e.,
ğ‘‡1 > ğ‘‡2 > ... > ğ‘‡ğ‘›). The observer (attacker) task is then selected as
ence precision is calculated by Iğ‘œ
(cid:12)(cid:12)(cid:12)(cid:12) Î”ğœ™
th task. This assignment ensures that there exist other tasks with
diverse periods (i.e., some with smaller periods and some with larger
periods compared to ğ‘‡ğ‘œ and ğ‘‡ğ‘£.)
We first run experiments for achieving task indistinguishabil-
ity. The results suggest that ScheduLeak shows better inference
precision as attack duration increases for both vanilla EDF and
TaskShuffler. On the other hand, ğœ–-Scheduler offers consistent pro-
tection throughout the entire course of the attack (a plot for this
ğ‘£ indicates
Figure 10: Results of the mean frequency error ratio grouped
by the system utilization. It shows that a large ğœ– value can
lead to greater mean frequency error and also cause some
tasks to miss deadlines when the utilization is high, as dis-
played by the plot at the top section that shows the number
of task sets that have experienced deadline misses in each
utilization group with ğœ– = 10.
experiment result is provided in Appendix Figure 15). Figure 9
shows the breakdown of the inference precision results grouped
by the utilization. It reveals that the TaskShuffler scheduler offers
less effective protection when the utilization is high due to limited
possible randomization. On the other hand, our ğœ–-Scheduler yields
consistent performance across all task utilizations leading to an
average inference precision (0.498 and 0.501 for ğœ– = 103 and ğœ– = 10
respectively) that is close to the outcome produced by a random guess.
Next, we test if job indistinguishability for the victim task is
sufficient to protect it against ScheduLeak. Here, all tasks have con-
sistent inter-arrival times based on their periods (i.e., ğœ–ğ‘– = âˆ) except
the victim task. The results are presented as the 5ğ‘¡â„ (ğœ–-ğ‘†ğ‘â„ğ‘’ğ‘‘(103)âˆ—)
and 6ğ‘¡â„ (ğœ–-ğ‘†ğ‘â„ğ‘’ğ‘‘(10)âˆ—) bars in each group shown in Figures 9 and
15. As shown, the victim task is protected by job indistinguishability.
The ScheduLeak attack fails to take advantage of the side channels
and yields inference precision at a level similar to a random guess.
8.2.4 QoS-Based Results. While the above results show that the ğœ–-
Scheduler is effective in increasing the noise in the schedule, we are
interested in the impact on the QoS of the tasks. We first examine
deadline misses in our experiments. As expected, both Vanilla EDF
and TaskShuffler EDF obey strict real-time constraints and thus do
not experience any deadline misses. In ğœ–-Scheduler, no deadline
miss has been observed when ğœ– = 103. However, with ğœ– = 10, we
observe intermittent deadline misses in some of task sets with high
utilization. The number of task sets encountering deadline misses in
such a setting is plotted at the top of Figure 10. As the result shows,
only 1.37% of the tested task sets have deadline misses. Among
these cases, no consecutive deadline miss has been observed.
We next examine how close to the indistinguishable tasks per-
form to the desired frequencies. A taskâ€™s frequency error is calcu-
lated as the difference between the taskâ€™s mean and desired fre-
quencies. The mean of the frequency errors (grouped by task set
utilization) is shown in the bar chart in Figure 10. The result in-
dicates that task sets scheduled by ğœ–-Scheduler with ğœ– = 10 has
frequency error significantly larger than that with ğœ– = 103. It is
expected as ğœ– = 10 yields a wider inter-arrival range (more noise
[0.0,0.1][0.1,0.2][0.2,0.3][0.3,0.4][0.4,0.5][0.5,0.6][0.6,0.7][0.7,0.8][0.8,0.9][0.9,1.0]TaskSetUtilization0.00.20.40.60.81.0InferencePrecisionofeÏ†vVanillaEDFTaskShuï¬„erEDFâˆ’Sched(103)âˆ’Sched(10)âˆ’Sched(103)âˆ—âˆ’Sched(10)âˆ—TheNumberofTaskSetsthatHaveDeadlineMissesinâˆ’Sched(10)86001660058600[0.0,0.1][0.1,0.2][0.2,0.3][0.3,0.4][0.4,0.5][0.5,0.6][0.6,0.7][0.7,0.8][0.8,0.9][0.9,1.0]TaskSetUtilization0.00.20.40.60.81.0MeanFrequencyErrorRatioâˆ’Sched(103)âˆ’Sched(10)Session 3A: Side Channel CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea677Vanilla EDF
Table 3: Summary of Scheduling Overhead Measurement
ğœ– = 103
ğœ– = 10
Mean of Measurement
0.696
Context Switch Count Ratio
0.914
pick_next_dl_entity()
1.39ğ‘¢ğ‘ 
1.44ğ‘¢ğ‘ 
5.79ğ‘¢ğ‘ 
5.41ğ‘¢ğ‘ 
ğœ–-Scheduler function*
2.38ğ‘Š 2.36ğ‘Š
Power Usage (performance)
2.08ğ‘Š 2.05ğ‘Š
Power Usage (ondemand)
* get_next_inter_arrival_time()
T.S. EDF
2.525
4.3ğ‘¢ğ‘ 
2.37ğ‘Š
2.20ğ‘Š
2.39ğ‘Š
2.3ğ‘Š
1.25ğ‘¢ğ‘ 
1
-
-
added). It is also worth pointing out that the frequency error is
due to the bounds in generating the noise-added inter-arrival times
that can lead to an asymmetric distribution (as an example, see the
distribution for ğœ‡ = 33.3ğ‘šğ‘  in Figure 4(b)).
While the mean task frequency gives us an insight into the
overall performance of the service delivery, it is crucial to know how
often the task is performing at a frequency below what is expected
(i.e., with inter-arrival times larger than the desired period) as such
execution usually has a direct impact on the taskâ€™s commitment
to the service delivery. We measure such a property for a task
by calculating the ratio of the number of under-performing inter-
arrival times to the total number of generated inter-arrival times.
In this experiment, we first compute the worst under-performance
ratio for each task set (by measuring it for each task and selecting
the worst in the task set) and then calculate the mean of the worst
under-performance ratios. From our experiment results, the under-
performance ratio can be biased towards 0.5 and above, leading to
a degradation in the execution frequency (a detailed experiment
plot is provided in Appendix, Figure 16). This usually happens to
the task that has a small target period and hence, an asymmetric
distribution that tends to generate larger inter-arrival times (again,
see Figure 4(b) for an example). It hints that one should expect a
degradation in the service when using ğœ–-Scheduler, particularly
with a small ğœ– value (i.e., larger noise and variation in the schedule).
Scheduling Overhead. We next evaluate the scheduling over-
8.2.5
head of the ğœ–-Scheduler, together with the Vanilla EDF and TaskShuf-
fler EDF schedulers as a comparison. The measurement results are
summarized in Table 3. We set Vanilla EDF as the base and calcu-
late the context switch count ratio compared to TaskShuffler EDF
and ğœ–-Scheduler in simulation. The result suggests that TaskShuf-
fler EDF generates a twofold increase in the number of context
switches. This matches the design of the TaskShufflerâ€™s randomiza-
tion protocol that aims to obfuscate the schedule by introducing
more scheduling points (i.e., more context switches). On the other
hand, ğœ–-Scheduler produces fewer context switches as the generated
inter-arrival times can be greater than Vanilla EDF. This measure-
ment generally matches the result shown in Figure 16.
Next, we execute a set of tasks (with parameters given in Table 6)
on RT Linux on the RPi4 platform to measure the mean cost of
scheduling. We first measure the execution time overheads of the
main scheduling function pick_next_dl_entity() that picks the
next task at a scheduling point. The result shows that TaskShuf-
fler EDF has larger overhead as it invokes get_random_bytes()
that takes an average 2.23ğ‘¢ğ‘  to generate a 64-bit random number.
On the other hand, the ğœ–-Scheduler has overheads that are very
similar to Vanilla EDF as the scheduling mechanism is identical
in pick_next_dl_entity(). To evaluate the true overhead of ğœ–-
Scheduler, we measure get_next_inter_arrival_time() where
randomized inter-arrival times are generated in our ğœ–-Scheduler
implementation. As shown in the table, the time cost is around