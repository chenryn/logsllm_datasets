1,000
s
e
t
a
g
d
n
a
0
0
60
40
20
s
e
t
a
g
d
n
a
e
g
a
r
e
v
A
0
0
500
1,000 1,500 2,000 2,500 3,000 3,500 4,000 4,500 5,000 5,500 6,000
Operation number
500
1,000 1,500 2,000 2,500 3,000 3,500 4,000 4,500 5,000 5,500 6,000
Operation number
Figure 2: The top plot shows the exact number of AND gates in ith cpush operation. The bottom
plot show a running average number of gates for the ﬁrst i operations, which ﬁts closely the
amortized O(log n) complexity we analyze.
Crossover for pop.
In the section we compare the performance of our predicate versus the
pop operation for producing the jth bit of the binary expansion of a bias p. We compute the
average number of gates required for pop operations, and the size of our predicate solution for
increasingly long binary expansions of the bias. Our data is summarized in Table 2.
20
λ
64
128
192
256
320
384
448
512
576
640
pop Method Predicate method
43.6
52.2
60.8
60.8
60.8
69.3
69.3
69.3
69.3
69.3
16
24
32
39
47
54
61
69
77
84
Table 2: Amortized number of AND gates for pop vs predicate as the length of the bias λ
increases. For pop we took the average of 10000 iterations of calling pop and conditionally
resetting on a random bit. The crossover point is roughly λ > 512 which is a highly secure
setting, but certainly a reasonable parameter setting.
5.2 Two Party d-Sample Benchmarks
We benchmarked the action of generating d samples from Geo(2/ε) using the second version of
make-batch, which uses a predicate function to generate the bias. For comparison purposes,
we also benchmarked the ODO implementation. For both implementations we varied the number
of samples to make between 212 and 219. We also sampled with two diﬀerent ε: one of the
form ε = 2−i ln 2 (ε = 2−3 ln 2), and one not in that form (ε = 0.1). For each value of ε,
we benchmarked for δ = 2−60 and δ = 2−80. We recorded the wall-clock time for the two
aforementioned network settings and present our results for this in Figures 3a and 3c. The total
number of bytes transmitted among both parties and the sum of the number of non-free Yao
gates and the number of unbiased coins used are shown in Figures 3b and 3d, respectively. We
note that cost and communication are static across diﬀerent networks.
As we expected, our protocol scales very well with d in all categories. Despite the asymptotic
behavior with the second make-batch being sub-optimal, it is understandable that it scales well,
as for lower values of λ + log d the cost of the predicate function is roughly constant, meaning
the complexity is just as good as our protocol with the ﬁrst make-batch.
5.3 Two Party Noisy Max Benchmarks
Next we report on our full implementation of the noisy max algorithm using our improved
biased coin sampling procedure. We expect the performance for noisy-max to be dominated by
the cost of the sampling, and the data below supports this claim. In our two-party setup, we
have each party contribute half of the dataset. We vary the size of the dataset from 212 = 4096 to
219, using 32-bit integer entries for the data. The benchmarks are run with 2 machines running
in the same us-east1 datacenter. The results are presented in Table 3.
As predicted by our analysis, the cost grows slowly between δ = 2−60 and δ = 2−80; at
d = 219, the diﬀerence is only 10s or 2%. We note that the communication overhead is quite
high but feasible for moderate-sized domains.
21
)
s
d
n
o
c
e
s
(
i
e
m
T
n
o
i
t
u
c
e
x
E
)
s
d
n
o
c
e
s
(
i
e
m
T
n
o
i
t
u
c
e
x
E
1,000
800
600
400
200
0
·1010
)
s
e
t
y
b
(
n
o
i
t
a
c
i
n
u
m
m
o
C
l
a
t
o
T
3
2
1
0
212
216
214
Size of Dataset
218
212
216
214
Size of Dataset
218
(a) d-Sample Wall-clock Time, east-east
(b) d-Sample Communication
3,000
2,000
1,000
0
212
216
214
Size of Dataset
218
s
t
i
B
m
o
d
n
a
R
+
s
e
t
a
G
e
e
r
f
-
n
o
N
1 · 109
5 · 108
0
212
214
216
218
Number of Dataset Entries
(d) d-Sample Yao Gates + Random Bits