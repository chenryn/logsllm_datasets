title:FPValidator: Validating Type Equivalence of Function Pointers on the
Fly
author:Hua Wang and
Yao Guo and
Xiangqun Chen
2009 Annual Computer Security Applications Conference
FPValidator: Validating Type Equivalence of Function Pointers On The Fly
Key Laboratory of High Conﬁdence Software Technologies (Ministry of Education),
Hua Wang, Yao Guo, Xiangqun Chen
Institute of Software, School of EECS, Peking University
{wanghua04, yaoguo, cherry}@sei.pku.edu.cn
Beijing, China
Abstract—Validating function pointers dynamically is very
useful for intrusion detection since many runtime attacks
exploit function pointer vulnerabilities. Most current solutions
tackle this problem through checking whether function pointers
target the addresses within the code segment or, more strictly,
valid function entries. However, they cannot detect function
entry attacks that manipulate function pointers to target valid
function entries but invoke them maliciously.
This paper proposes FPValidator, a new solution capable of
dynamically validating the type equivalence between function
pointers and target functions, which can detect all function
entry attacks that violate type equivalence. An effective and
efﬁcient type matching approach based on labeled type signature
is proposed to perform fast type equivalence checking. The
validation code and necessary type information are inserted
by a compilation-stage instrumentation mechanism, bringing
no extra burden to developers. We integrate FPValidator into
GCC and evaluation shows that its performance overhead is
only about 2%.
I. INTRODUCTION
Adversaries often intend to change the control ﬂow in a
program, so that they can take programs under their control.
For programs written in languages that support function
pointers, manipulating function pointers is an often-used
attacking method. An adversary could modify a function
pointer to target an illegal address in order to serve his mali-
cious purpose. A well-known attack to tamper with function
pointers is to exploit buffer overﬂow vulnerabilities [1]. Ad-
versaries could also modify function pointers from outside,
for example by using procfs. Since function pointers may
be maliciously changed during execution, validating their
values on the ﬂy is clearly useful for intrusion detection.
A key problem with dynamic function pointer validation
is how to judge that the value of a pointer is a valid address.
We need to deﬁne for each pointer a set of addresses that
the pointer is allowed to point to during execution. Ideally,
a set should satisfy the following two requirements, used to
avoid false-positives and false-negatives separately.
• Completeness: The set should contain all addresses that
the pointer may target in correct execution.
This work has been supported by the National High Technology Research
and Development Program (863) of China under Grant No. 2007AA010304
and 2007AA01Z462, the National Basic Research Program of China (973)
under Grant No. 2009CB320703, and the Science Fund for Creative
Research Groups of China under Grant No. 60821003.
To some extent
• Precision: The set should only contain the addresses
that the pointer probably targets in correct execution.
the two requirements are conﬂicting.
Perfectly meeting both of them is very hard. It is usually
considered that completeness is prior to precision in that
users do not like to be interrupted by fake errors [2]. Existing
solutions, after guaranteeing completeness, try to improve
precision as far as possible. Several solutions deﬁne the set
as all addresses in code segments, or more strictly, valid
function entries [3], [4]. Although these solutions can meet
completeness well, they are not precise enough to detect
function entry attacks. Function entry attacks mean that an
adversary manipulates a function pointer to target a valid
function which however should not be invoked by that
pointer. This kind of attacks could cause serious security
problems. For example, an adversary could modify a pointer
to invoke the system function, which is contained in libc.so
and linked into the address spaces of most programs, to
execute an arbitrary command.
Some solutions try to ﬁnd out accurate points-to sets.
Inlined CFI [5] deduces the sets from a CFG obtained by
static analysis. Unfortunately, such a CFG is usually not
accurate due to indirect branches. WIT [6] uses the static
points-to analysis [7] to compute the sets, but the result can
hardly be precise [8]. In the worst case, the set for a pointer
could contain all function entries.
In this paper we propose a new solution called FPVal-
idator, which uses a new method of deﬁning the set of
possible targets, being precise enough to effectively detect
function entry attacks, as well as having no false-positives.
Our method is based on the fact
in a statically-
typed language (e.g. C and C++), a function pointer should
only invoke functions of compatible types; otherwise the
program’s behavior could be unpredictable. Consequently,
we deﬁne the set for a function pointer as all functions whose
types are compatible with the pointer. With our method, an
adversary, if succeeding in tampering with a function pointer,
can only abuse compatible functions, making function entry
attacks much harder.
that,
FPValidator validates function pointers through a fast
type matching method. In terms of programs developed with
statically-typed languages, efﬁciency is often an important
factor that needs to be considered. We should therefore
1063-9527/09 $26.00 © 2009 IEEE
DOI 10.1109/ACSAC.2009.15
51
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:14:01 UTC from IEEE Xplore.  Restrictions apply. 
minimize the cost caused by dynamic type matching. In
fact, we do not need to adopt a complete and complicated
dynamic type system like those for dynamically-typed or
hybrid languages (e.g. [9], [10], [11], [12], [13]) which
usually causes considerable runtime overhead. Instead, we
propose a lightweight, fast type matching method based on
labeled type signature. Our method calculates the hashes of
type signatures of function pointers and functions during
compilation, and compares them during validation. Type
information and validation code fragment are inserted into
programs automatically by a compilation-stage instrumenta-
tion technique, causing no extra burden to developers. The
evaluation shows that the increased time cost is only about
2%, and the increased space cost is less than 8%.
The rest of this paper is organized as follows. Section
2 analyzes function pointer attacks, and demonstrates an
example of function entry attack. Section 3 describes the
details of our validation method, including the type matching
and the instrumentation. Section 4 describes the implemen-
tation and evaluation, as well as the security analysis. The
related work is discussed in Section 5. Finally we conclude
this paper in Section 6.
II. FUNCTION POINTER ATTACKS
When attacking function pointers, adversaries usually
modify function pointers to point to the code that could
serve their malicious purposes. Depending on where the
modiﬁed function pointers target, we divide function pointer
attacks into data region attacks (DRA), which target the code
injected into data segments, and code region attacks (CRA),
which target the addresses within code segments. CRA could
be further divided into function entry attack (FEA) and non
function entry attack (NFEA) (also known as arc injection
attack [1], [14]), according to whether the function pointers
target function entries.
On the other hand, function pointer validation, according
to precision, can be divided into four levels [4], listed as
follows.
• L1: the target must be in code segments.
• L2: the target must be a predeﬁned position such as a
function entry.
• L3: the type of the function pointer and that of the
target function must match.
• L4: the target must belong to an accurate points-to
address set.
As the level increases, the validation becomes more pre-
cise and can detect more attacks. The L1 can only detect
DRA, while the L2 can detect both DRA and NFEA. The
L3, stepping further, can detect all FEA that involves type
violation, and the L4 can detect almost all function pointer
attacks.
FEA could cause serious security problems. Programs
often contain sensitive functions which should be called at
i n t ) ;
t y p e ) {
i n t
l e n ) {
. . .
i n t
1 t y p e d e f void (∗ f u n c t ) ( char ∗ ,
2
3 void f o o ( char ∗name ,
4
5 }
6
7 void f u n c ( char∗ i n b u f ,
8
9
10
11
12
13
14
15
16
17 }
f u n c t
f p ;
i n t param ;
char b u f [ 1 6 ] ;
. . .
f p = f o o ;
param = IPV4 ;
memcpy ( buf ,
f p ( buf , param ) ;
. . .
i n b u f ,
l e n ) ;
Figure 1. A buggy function and malicious input
right time and with right parameters. Besides, some func-
tions, although contained in code segments, should never
be called in normal execution. For example, shared libraries
(e.g. libc.so) are linked as a whole into address spaces of
programs, but many functions they contain are never used.
Some of these functions are “dangerous”, such as system
and execve, which may be invoked to execute arbitrary
commands. These functions may be abused by adversaries
through FEA.
Figure 1 shows a buggy function that could be exploited
by FEA. Line 8 declares a local function pointer, fp, followed
by a declaration of an local variable. Both may be overwrit-
ten by the buffer operation of line 14. Normally fp will point
to foo, and at line 15 foo gets to run. An adversary, however,
could deliberately construct a “bad” input to change fp,
calling another function instead. For example, assuming
the program is running on a 32-bit platform, an adversary
can construct an input buffer as in Figure 1. The size of
the input buffer is 24 bytes, containing at most 16 bytes
of a shell command string and the address of the system
function. The command string will be copied to buf, and
fp will be modiﬁed to point to system. Later when system
is called through fp, the adversary’s command is executed.
In this example, because the new target of fp is a legal
function entry, the attack can not be detected by the ﬁrst
two validation levels.
In addition to the buffer overﬂow vulnerability, adver-
52
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:14:01 UTC from IEEE Xplore.  Restrictions apply. 
saries could also use other attacking methods to tamper with
function pointers, such as writing memory directly through
procfs. As long as they only exploit “legal” functions, their
attacks can not be detected by the L1 and L2 validation.
III. VALIDATING TYPE EQUIVALENCE
To mitigate the threat of FEA, FPValidator conﬁnes
function pointers to targeting only compatible functions. To
enforce this constraint, FPValidator compares at runtime the
type that a function pointer should point to and the type it
actually targets. Hereafter the former type is called point-to
type and the latter is called target type. If the two types do
not match, an exception is raised. With FPValidator, for an
adversary, only when the point-to type matches the type of
the function he wants to abuse does he have chances to carry
out a successful attack, making attacking much harder.
For statically-typed languages, this constraint is safe, that
is, it does not cause false-positives. When using statically-
typed languages, a developer exactly knows what
type
of functions are desired for each indirect call statement.
Invoking a function of incompatible type is obviously an
error. Note that sometimes a developer could perform type
casting on a pointer in order to invoke functions of other
types. In this case the type after casting is treated as the
point-to type of this pointer. Consequently, type casting has
no impact on the safety of the constraint.
We propose a fast type matching approach to satisfy the
efﬁciency requirement of critical programs. This section de-
scribes the design of our approach, as well as the supporting
compilation-stage instrumentation mechanism. We use the C
language as the example, but our solution can also be applied
to other statically-typed languages.
A. Type Matching
In order to detect type violations, we need to deﬁne
criteria to determine whether the point-to type of a function
pointer matches its target type. Considering that function
pointers are usually used to invoke functions of exactly iden-
tical types, and compilers will generate warning information
if their types are different, we require that the point-to type
and target type must be equivalent. In general there are two
notions of type equivalence, namely structural equivalence
and name equivalence [15], but both of them have weak
points for function pointer validation.
Intuitively, structural equivalence suggests that the expres-
sions of two types are structurally identical. We can express
it in a more formal way. Types, except for basic types, are
composed by type constructors using other types. In fact
basic types can also be regarded as being composed by
special constructors using no other types. The composing
relationship can be expressed as
τ = T (τ1, τ2, ..., τn)
(cid:2)
1, τ
(cid:2)
2, ..., τ
(cid:2) = T (cid:2)(τ
where T is a type constructor, such as function and record,
and τ1 to τn are depended types. Then τ = T (τ1, τ2, ..., τn)
n) are structurally equivalent if T =
(cid:2)
and τ
T (cid:2)
, and ∀1 , , ..., )
where N (τ) is τ’s name and li is the label for τi. N (τ)
is empty if τ is an anonymous type. N (τ) and li carry
application-speciﬁc information of τ. For some constructors
the labels are ﬁxed, such as function which is expressed as
f unction(N (τ), , , ..., 
); while for others they depend on how the type is deﬁned,
such as record which is expressed as record(N (τ), , ..., ) where fi is the name of the ith
ﬁeld.
Based on the modiﬁed type constructors we can establish
a labeled type graph G = (V, E). V is the set of vertices,
each of which is a pair  standing for a type τ
built by the constructor T with the name N (τ). E is the set
of directed edges denoting the building relationship. For a
constructor T , the edge connecting τ and τi is labeled with
li. Figure 2 shows a simple list interface and its labeled type
graph.
To simplify the type matching, type qualiﬁers, e.g. const
and volatile, are not taken into account, and we also do
not distinguish signed and unsigned types, because this kind
of type violations can hardly be exploited. We also do not
consider type names declared by typedef statements. They
are simply treated as aliases and replaced by its original type
in the type graph, because in practice typedefed types and
their origins are usually interchangeable.
53
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:14:01 UTC from IEEE Xplore.  Restrictions apply. 
l i s t {
l i s t ∗ n e x t ;
s t r u c t
void ∗ v a l u e ;
1 s t r u c t
2
3
4 } ;
5
6 t y p e d e f
7
8 void w a l k l i s t ( s t r u c t
9
10 }
i n t
. . .
(∗ w a l k e r ) ( void ∗ ) ;
l i s t ∗ l s t , w a l k e r w) {