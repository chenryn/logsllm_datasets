data with the same value, which could lead to false posi-
tives. However, we have not encountered any in practice
and expect them to be rare.
A false negative is when the same vulnerability is ex-
ploited without being reported. This can occur if the tainted
input is propagated along a different code path than in the
sample exploit, or if the overwritten sensitive value is mis-
used at a different location. Note polymorphic variants cre-
ated by tools such as MetaSploit [3] will be detected from
a single ﬁlter. The reason is such polymorphic variants dif-
fer in the payload, which would be executed strictly after
the exploit point. Only an exploit that is polymorphic in the
execution path exploited could be missed. Speciﬁcally, it
would be missed if and only if different instructions propa-
gate the tainted data to the exploit point, or there is a differ-
ent exploit point. We expect that there is a relatively small
number of such possible variants for a particular vulnerabil-
ity, and that the attacker must identify them manually or by
static analysis of the vulnerable binary. Naturally, we can
apply the same static analysis techniques to preemptively
identify the other paths that should be instrumented. This is
discussed further in Section 3.3.
Combining ﬁlters. We may want to combine several differ-
ent taint-based VSEF ﬁlters. For example, a single binary
may have several vulnerabilities that are not all discovered
simultaneously. We want to harden the binary as each new
vulnerability is discovered. Another example is vulnerabil-
ities that can be exercised via several different code paths.
We want to be able to re-harden the binary as each new code
path is discovered by the detector.
We combine taint-based VSEF ﬁlters by a simple union:
any instruction listed in either of the ﬁlters should be instru-
mented. The simplicity and efﬁciency of combining ﬁlters
is a nice property for defense systems using our approach
since it means the system does not become complex as new
vulnerabilities and attackers are discovered.
tion immediately available.
3.2. Destination-based VSEF
Overview. We next consider an optimistic ﬁlter that focuses
on instrumenting the point where sensitive data was ille-
gitimately overwritten, rather than the point where tainted
data was illegitimately used. Conceptually, a taint-based
VSEF ﬁlter consists of a chain of data movement opera-
tions, and the instruction at the exploit point, which mis-
uses the tainted data. The taint-based VSEF ﬁlter detects
when the tainted data is misused, which is a very accu-
rate detection method. However, the actual security vio-
lation is the data movement instruction in the chain that
wrote to an illegitimate destination, copying the tainted data
to the overwrite target. We refer to this instruction as the
overwrite point. Therefore, we propose destination-based
VSEF, which monitors only the overwrite point, i.e., the
speciﬁc instruction that illegitimately wrote to a speciﬁc
destination (such as a speciﬁc function pointer). We use the
term optimistic because of cases where destination-based
VSEF may have false positives. Destination-based VSEF is
based on the idea that an overwrite attack results in the in-
struction at the overwrite point writing to a destination that
it would not normally write to. This idea is supported by
Zhou et. al. [44], who built a system that successfully de-
tects many memory faults (and overwrite attacks) by detect-
ing when an instruction writes to a destination that it hasn’t
written to during normal execution.
It is not enough to specify the overwrite point only by
the position of the instruction that performed the overwrite.
For example, suppose that the instruction that performed the
overwrite was a mov inside memcpy. Because of a bug in
the way memcpy was called, it wrote past the end of a buffer
and overwrote a sensitive value, such as a function pointer.
However, a different call to memcpy in another part of the
program may be used to intentionally copy legitimate data
to the same location. Therefore, we specify the overwrite
point as the position of the instruction that performed the
overwrite, plus the context in which it was executed, which
we call the vulnerable context. We specify the context to be
the list of return addresses on the stack, which indicates the
sequence of function calls that led to the exploit.
Destination-based VSEF Filter Generation. To generate
a destination-based VSEF ﬁlter, the VSEF Filter Genera-
tor needs to determine (1) which data movement instruction
illegitimately wrote to a sensitive location (the overwrite
point), (2) the vulnerable stack conﬁguration when that data
movement takes place (the vulnerable context), and (3) what
destination(s) should not be overwritten by that instruction,
in that context. The VSEF Filter Generator can extract this
information from an execution log of a general purpose de-
tector, or use a specialized detector that makes this informa-
To identify the data movement instruction that performed
the illegitimate write, the VSEF Filter Generator ﬁrst iden-
tiﬁes the chain of instructions that propagated the tainted
data to the exploit point, in the same manner as to generate
a taint-based VSEF ﬁlter. The VSEF Filter Generator then
identiﬁes which of the instructions in that taint propagation
chain is the overwrite point.
When available, the VSEF Filter Generator can use de-
bug information compiled into the program to help iden-
tify the overwrite point. Debug information can be used to
determine the allocated size of a buffer. Hence, for buffer
overﬂows, the VSEF Filter Generator can identify the over-
write point as a data movement instruction that calculates
an address as a base plus an offset, where the offset causes
the calculated address to point outside of the buffer that the
base pointer points to.
Debug information also provides information about the
type of each memory object. Hence, the VSEF Filter Gener-
ator can use this information to identify the overwrite point
as the the data movement instruction that caused a type vio-
lation, e.g., a string copied over a function pointer. For pro-
grams that have not been compiled with debug information,
type information can sometimes be inferred at run time. For
example, return addresses can be identiﬁed for programs
that obey normal stack conventions. It is possible to infer
the types of other locations based on how the data is used
during normal execution [8].
When neither debug information nor type information is
available, the VSEF Filter Generator identiﬁes the overwrite
point as the last instruction in the propagation chain that
writes to a dynamically calculated memory address. Heuris-
tically this will usually be true, given the assumptions that
overwrite attacks are the result of such a memory address
taking on an unintended value, and that there are not any
other such copies that occur between the overwrite point
and the exploit point.
Using our previous example in Table 1, any of these tech-
niques correctly identiﬁes the overwrite point as instruction
D. Using buffer size information: While the base address
used at that point points to dummy->buf, the offset causes
the calculated address to point to dummy->fnptr. Using
type information: Instruction D is the ﬁrst instruction in the
chain where tainted data is written to a data type that should
not be tainted. Using neither: Instruction D is the last in-
struction in the chain to write to a dynamically calculated
address. Instructions E and G write to processor registers.
Instruction F writes to a hard-coded offset within the current
stack frame.
Once the overwrite point has been identiﬁed, the vul-
nerable context in which it was executed can be found by
examining the calls and returns up to that point in the ex-
ploit execution trace. Alternatively, a specialized detector
such as TaintCheck can log the call-stack state along with
each tainted data propagation, so that the call-stack is al-
ready on-hand when the overwrite point is reached in the
backwards trace of the exploit execution trace. In our previ-
ous example from Table 1, the stack context at the overwrite
point (instruction D) is [main+47; vuln+68; strcpy+25].
That is, the instruction at offset 47 from the start of main
called vuln, the instruction at offset 68 from the start of
vuln called strcpy, and the instruction at offset 25 from
the start of strcpy is the mov that overwrote the function
pointer. This example demonstrates why we need to keep
track of the vulnerable context, and not just the overwrite
point instruction. Here, as in many cases, there is nothing
wrong with the instruction at the overwrite point, or even
the function it is in (strcpy). The problem is that vuln
called strcpy in an unsafe way.
The sensitive value overwritten is the destination
operand of the data movement instruction at the overwrite
point. We express this location in a robust way in our ﬁl-
ter. For example, this can be done by denoting as an offset
from an activation record for stack-based locations, or as an
offset from a buffer allocated in a certain stack-context for
heap-based locations. In the example from Table 1, the lo-
cation is offset 16 in dummy. This is expressed as offset 16
from the buffer allocated at context [main + 14].
In the case of buffer overruns, we would ideally like to
specify that the write does not continue past the end of the
buffer, so that future exploits against the vulnerability are
not able to overwrite data in between the end of the buffer
and the data that was detected as being misused. The VSEF
Filter Generator can do this if the binary was compiled
with debug information (hence the length of the buffer is
known). When this information is not available, the VSEF
Filter Generator can still sometimes create a tighter bound
for what area should not be overwritten. For example, it rec-
ognizes when the value overwritten was the return address.
Instead of only protecting the return address, it also protects
the saved ebp, which is adjacent to the return address, and
could be overwritten without overwriting the return address.
Destination-based VSEF Binary Instrumentation. We
instrument the binary program to check that the data move-
ment instruction at the overwrite point does not write to the
sensitive destination when it is in the vulnerable stack con-
text. Our experiments in Section 4.2 show that this can be
done by instrumenting a small number of instructions- the
data movement instruction, and the call instruction corre-
sponding to each activation record in the vulnerable context.
We also show how this could be reduced to only instrument-
ing the data movement instruction by making copies of each
function in the vulnerable context.
Accuracy. When the program is run with the sample ex-
ploit, it will again reach the overwrite point, in the vulnera-
ble stack context. At that point, the instrumentation detects
that the destination address is illegitimate, signalling an at-
tack.
As with taint-based VSEF ﬁlters, exploits that automat-
ically alter their content while using the same attack vector
will still be caught. However, it is possible that an attacker
could alter the exploit so that the vulnerability is exploited
in a different vulnerable context (i.e.
there may be multi-
ple functions that call the vulnerable function), or so that
it overwrites a different sensitive value. There are unlikely
to be many such possible variations, and we may be able
to ﬁnd some of them automatically using static analysis.
For example, manual analysis of the vulnerable ATPhttpd
shows that there are only two contexts in which the vulner-
able function is called in an exploitable way.
We expect that most destination-based VSEF ﬁlters will
have zero false positives. There are a few cases where a
destination-based VSEF ﬁlter may have false positives, all
of which we expect to be very rare. A destination-based
VSEF could have false positives if 1) The VSEF Filter
Generator identiﬁed the wrong instruction as the overwrite
point, and hence the write to that address occurs in normal
usage. This problem should be straight-forward to detect
and ﬁx after using the ﬁlter. 2) The instruction at the over-
write point can legitimately write to the monitored location
in the vulnerable context. This can be true if the source is
sometimes a legitimate (non-tainted) value, or if the desti-
nation isn’t always used in a sensitive way (e.g., a C union
that could be a function pointer or a string buffer). In this
case a low-false-positive destination-based VSEF ﬁlter for
that vulnerability is not possible, and a taint-based VSEF
ﬁlter should be used instead.
Combining Filters.
It is straightforward to instrument a
program with multiple destination-based VSEF ﬁlters. The
instrumentation for each ﬁlter can be added independently
of the other instrumentation. In some cases multiple ﬁlters
will instrument the same instruction. Each ﬁlter can add
its own instrumentation independently, without interfering
with the other.
Performance. Destination-based VSEF allows the ﬁlter to
be created almost instantaneously. The length of the ﬁlter
(as well as the total number of instructions instrumented),
however, is bound by the depth of the call stack at the over-
write point of sample exploit, plus the address of the over-
write point, plus the identiﬁer of the sensitive data to be
guarded. In Section 4.2 we describe how we can instrument
even fewer instructions, further improving performance.
3.3. Static analysis extensions
Our adversarial model requires ﬁlters be generated
quickly, and requires them to be small enough to distribute
rapidly. As a result, ﬁlter creation for both schemes relies
only on information already on-hand when the exploit is de-
tected. However, if we relax the speed requirement we may
be able to generate more accurate ﬁlters by performing more
analysis.
Backward slicing. The ﬁlter we create recognizes the sam-
ple exploit along with variants polymorphic in the exploit
payload. However, an exploit may be polymorphic in the
execution path followed. For example, the ATPhttpd web-
server vulnerability we investigate can be exploited along
two different code paths: one where the requested ﬁle is
found but not readable and one if the ﬁle is not found at
all. The destination-based VSEF ﬁlter generated from one
will not detect the other, because the overwrite occurs in
a different vulnerable context. In this case, the taint-based
VSEF ﬁlter for one will detect the other because the same in-
structions are involved in copying the tainted data in either
case. However, if ATPhttpd had been implemented to use
memcpy to copy the tainted data on one path, and strcpy
to copy the tainted data on the other path, then the taint-
based VSEF ﬁlter generated from one path would not detect
the other.
One can perform static analysis to recognize these al-
ternate code paths, and identify the additional instructions
that would need to be instrumented to detect the correspond-
ing attacks. That is, alternate data propagation paths can be
identiﬁed and instrumented in taint-based VSEF ﬁlters, and
alternate vulnerable contexts can be identiﬁed and instru-
mented in destination-based VSEF ﬁlters. Note the static
analysis is sound but imprecise, so it is possible that more
instructions will be instrumented than necessary. How-
ever, including instrumentation for potential alternate ex-
ploit paths, will result in a ﬁlter that detects future exploits
polymorphic both in the path taken and in the exploit pay-
load.
4. Implementation & Evaluation
In this section we present our implementation and exper-
imental evaluation of the taint-based and destination-based
VSEF Filter Generators and VSEF Binary Instrumentation
Engines. In our experiments we use TaintCheck [27] as the
Exploit Detector, and to record the exploit execution trace.