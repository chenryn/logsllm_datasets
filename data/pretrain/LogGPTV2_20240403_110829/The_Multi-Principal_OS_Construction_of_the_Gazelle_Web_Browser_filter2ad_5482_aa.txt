title:The Multi-Principal OS Construction of the Gazelle Web Browser
author:Helen J. Wang and
Chris Grier and
Alexander Moshchuk and
Samuel T. King and
Piali Choudhury and
Herman Venter
The Multi-Principal OS Construction of the Gazelle Web Browser
Helen J. Wang∗, Chris Grier†, Alexander Moshchuk‡, Samuel T. King†, Piali Choudhury∗, Herman Venter∗
∗Microsoft Research
‡ University of Washington
† University of Illinois at Urbana-Champaign
{helenw,pialic,hermanv}@microsoft.com, {grier,kingst}@uiuc.edu, PI:EMAIL
Abstract
Original web browsers were applications designed to
view static web content. As web sites evolved into dy-
namic web applications that compose content from mul-
tiple web sites, browsers have become multi-principal
operating environments with resources shared among
mutually distrusting web site principals. Nevertheless,
no existing browsers, including new architectures like IE
8, Google Chrome, and OP, have a multi-principal oper-
ating system construction that gives a browser-based OS
the exclusive control to manage the protection of all sys-
tem resources among web site principals.
In this paper, we introduce Gazelle, a secure web
browser constructed as a multi-principal OS. Gazelle’s
browser kernel is an operating system that exclusively
manages resource protection and sharing across web site
principals. This construction exposes intricate design is-
sues that no previous work has identiﬁed, such as cross-
protection-domain display and events protection. We
elaborate on these issues and provide comprehensive so-
lutions.
Our prototype implementation and evaluation expe-
rience indicates that it is realistic to turn an existing
browser into a multi-principal OS that yields signiﬁ-
cantly stronger security and robustness with acceptable
performance.
1 Introduction
Web browsers have evolved into a multi-principal oper-
ating environment where a principal is a web site [43].
Similar to a multi-principal OS, recent proposals [12,
13, 23, 43, 46] and browsers like IE 8 [34] and Fire-
fox 3 [16] advocate and support programmer abstrac-
tions for protection (e.g.,  in addition to
 [43]) and cross-principal communication
(e.g., PostMessage [24, 43]). Nevertheless, no exist-
ing browsers, including new architectures like IE 8 [25],
Google Chrome [37], and OP [21], have a multi-principal
OS construction that gives a browser-based OS, typically
called the browser kernel, the exclusive control to man-
age the protection and fair sharing of all system resources
among browser principals.
In this paper, we present a multi-principal OS con-
struction of a secure web browser, called Gazelle.
Gazelle’s browser kernel exclusively provides cross-
principal protection and fair sharing of all system re-
sources. In this paper, we focus only on resource pro-
tection in Gazelle.
In Gazelle, the browser kernel runs in a separate pro-
tection domain (an OS process in our implementation),
interacts with the underlying OS directly, and exposes a
set of system calls for web site principals. We use the
same web site principal as deﬁned in the same-origin
policy (SOP), which is labeled by a web site’s origin,
the triple of . In
this paper, we use “principal” and “origin” interchange-
ably. Unlike previous browsers, Gazelle puts web site
principals into separate protection domains, completely
segregating their access to all resources. Principals can
communicate with one another only through the browser
kernel using inter-process communication. Unlike all ex-
isting browsers except OP, our browser kernel offers the
same protection to plugin content as to standard web con-
tent.
Such a multi-principal OS construction for a browser
brings signiﬁcant security and reliability beneﬁts to the
overall browser system: the compromise or failure of a
principal affects that principal alone, leaving other prin-
cipals and the browser kernel unaffected.
Although our architecture may seem to be a straight-
forward application of multi-principal OS construction to
the browser setting, it exposes intricate problems that did
not surface in previous work, including display protec-
tion and resource allocation in the face of cross-principal
web service composition common on today’s web. We
will detail our solutions to the former and leave the latter
as future work.
We have built an Internet-Explorer-based prototype
that demonstrates Gazelle’s multi-principal OS archi-
tecture and at the same time uses all the backward-
compatible parsing, DOM management, and JavaScript
interpretation that already exist in IE. Our prototype ex-
perience indicates that it is feasible to turn an existing
browser into a multi-principal OS while leveraging its
existing capabilities.
With our prototype, we successfully browsed 19 out
of the top 20 Alexa-reported popular sites [5] that we
tested. The performance of our prototype is acceptable,
and a signiﬁcant portion of the overhead comes from IE
instrumentation, which can be eliminated in a production
implementation.
We expect that the Gazelle architecture can be made
fully backward compatible with today’s web. Neverthe-
less, it is interesting to investigate the compatibility cost
of eliminating the insecure policies in today’s browsers.
We give such a discussion based on a preliminary analy-
sis in Section 9.
For the rest of the paper, we ﬁrst give an in-depth
comparison with related browser architectures in Sec-
tion 2. We then describe Gazelle’s security model 3. In
Section 4, we present our architecture, its design ratio-
nale, and how we treat the subtle issue of legacy pro-
tection for cross-origin script source. In Section 5, we
elaborate on the problem statement and design for cross-
principal, cross-process display protection. We give a
security analysis including a vulnerability study in Sec-
tion 6. We describe our implementation in Section 7. We
measure the performance of our prototype in Section 8.
We discuss the tradeoffs of compatibility vs. security for
a few browser policies in Section 9. Finally, we conclude
and address future work in Section 10.
2 Related Work
In this section, we discuss related browser architectures
and compare them with Gazelle.
2.1 Google Chrome and IE 8
In concurrent work, Reis et al. detailed the various pro-
cess models supported by Google Chrome [37]: mono-
lithic process, process-per-browsing-instance, process-
per-site-instance, and process-per-site. A browsing in-
stance contains all interconnected (or inter-referenced)
windows including tabs, frames and subframes regard-
less of their origin. A site instance is a group of same-
site pages within a browsing instance. A site is deﬁned
as a set of SOP origins that share a registry-controlled
domain name: for example, attackerAd.socialnet.com,
alice.proﬁles.socialnet.com, and socialnet.com share the
same registry-controlled domain name socialnet.com,
and are considered to be the same site or principal
by Chrome. Chrome uses the process-per-site-instance
model by default. Furthermore, Reis et al. [37] gave
the caveats that Chrome’s current implementation does
not support strict site isolation in the process-per-site-
instance and process-per-site models: embedded princi-
pals, such as a nested iframe sourced at a different ori-
gin from the parent page, are placed in the same process
as the parent page.
The monolithic and process-per-browsing-instance
models in Chrome do not provide memory or other re-
source protection across multiple principals in a mono-
lithic process or browser instance. The process-per-
site model does not provide failure containment across
site instances [37]. Chrome’s process-per-site-instance
model is the closest to Gazelle’s two processes-per-
principal-instance model, but with several crucial differ-
ences: (1) Chrome’s principal is site (see above) while
Gazelle’s principal is the same as the SOP principal. (2)
A web site principal and its embedded principals co-exist
in the same process in Chrome, whereas Gazelle places
them into separate protection domains. Pursuing this de-
sign led us to new research challenges including cross-
principal display protection (Section 5). (3) Plugin con-
tent from different principals or sites share a plugin pro-
cess in Chrome, but are placed into separate protection
domains in Gazelle.
(4) Chrome relies on its render-
ing processes to enforce the same-origin policy among
the principals that co-exist in the same process. These
differences indicate that in Chrome, cross-principal (or -
site) protection takes place in its rendering processes and
its plugin process, in addition to its browser kernel. In
contrast, Gazelle’s browser kernel functions as an OS,
managing cross-principal protection on all resources, in-
cluding display.
IE 8 [25] uses OS processes to isolate tabs from one
another. This granularity is insufﬁcient since a user may
browse multiple mutually distrusting sites in a single tab,
and a web page may contain an iframe with content from
an untrusted site (e.g., ads).
Fundamentally, Chrome and IE 8 have different goals
from that of Gazelle. Their use of multiple processes is
for failure containment across the user’s browsing ses-
sions rather than for security. Their security goal is to
protect the host machine from the browser and the web;
this is achieved by process sandboxing [9]. Chrome and
IE 8 achieved a good milestone in the evolution of the
browser architecture design. Looking forward, as the
world creates and migrates more data and functionality
into the web and establishes the browser as a dominant
application platform, it is critical for browser designers
to think of browsers as operating systems and protect
web site principals from one another in addition to the
host machine. This is Gazelle’s goal.
2.2 Experimental browsers
The OP web browser [21] uses processes to isolate
browser components (i.e., HTML engine, JavaScript in-
terpreter, rendering engine) as well as pages of the same
origin.
In OP, intimate interactions between browser
components, such as JavaScript interpreter and HTML
engine, must use IPC and go through its browser ker-
nel. The additional IPC cost does not add much bene-
ﬁts: isolating browser components within an instance of
a web page provides no additional security protection.
Furthermore, besides plugins, basic browser components
are fate-shared in web page rendering: the failure of any
one browser component results in most web pages not
functioning properly. Therefore, process isolation across
these components does not provide any failure contain-
ment beneﬁts either. Lastly, OP’s browser kernel does
not provide all the cross-principal protection needed as
an OS because it delegates display protection to its pro-
cesses.
Tahoma [11] uses virtual machines to completely iso-
late (its own deﬁnition of) web applications, disallowing
any communications between the VMs. A web appli-
cation is speciﬁed in a manifest ﬁle provided to the vir-
tual machine manager and typically contains a suite of
web sites of possibly different domains. Consequently,
Tahoma doesn’t provide protection to existing browser
principals. In contrast, Gazelle’s browser kernel protects
browser principals ﬁrst hand.
The Building a Secure Web Browser project [27, 28]
uses SubOS processes to isolate content downloading,
display, and browser instances. SubOS processes are
similar to Unix processes except that instead of a user
ID, each process has a SubOS ID with OS support for
isolation between objects with different SubOS IDs. Su-
bOS instantiates a browser instance with a different Su-
bOS process ID for each URL. This means that the prin-
cipal in SubOS is labelled with the URL of a page (pro-
tocol, host name plus path) rather than the SOP origin
as in Gazelle. Nevertheless, SubOS does not handle em-
bedded principals, unlike Gazelle. Therefore, they also
do not encounter the cross-principal display-sharing is-
sue which we tackle in depth. SubOS’s principal model
would also require all cross-page interactions that are
common within a SOP origin to go through IPC, incur-
ring signiﬁcant performance cost for many web sites.
3 Security model
3.1 Background: security model in existing
browsers
Today’s browsers have inconsistent access and protec-
tion model for various resources. These inconsistencies
present signiﬁcant hurdles for web programmers to build
robust web services.
In this section, we give a brief
background on the relevant security policies in existing
browsers. Michal Zalewski gives an excellent and per-
haps the most complete description of existing browsers’
security model to date [48].
Script. The same-origin policy (SOP) [39] is the
central security policy on today’s browsers. SOP gov-
erns how scripts access the HTML document tree and
remote store. SOP deﬁnes the origin as the triple of
. SOP mandates
that two documents from different origins cannot access
each other’s HTML documents using the Document Ob-
ject Model (DOM), which is the platform- and language-
neutral interface that allows scripts to dynamically ac-
cess and update the content, structure and style of a doc-
ument [14]. A script can access its document origin’s
remote data store using the XMLHttpRequest object,
which issues an asynchronous HTTP request to the re-
mote server [45]. (XMLHttpRequest is the cornerstone
of AJAX programming.) SOP allows a script to issue
an XMLHttpRequest only to its enclosing page’s origin.
A script executes as the principal of its enclosing page
though its source code is not readable in a cross-origin
fashion.
For example, an  with source http://a.com
cannot access any HTML DOM elements from another
 with source http://b.com and vice versa.
http://a.com’s scripts (regardless of where the scripts
are hosted) can issue XMLHttpRequests to only a.com.
Furthermore, http://a.com and https://a.com are different
origins because of the protocol difference.
Cookies. For cookie access, by default, the principal
is the host name and path, but without the protocol [19,
32]. For example, if the page a.com/dir/1.html creates a
cookie, then that cookie is accessible to a.com/dir/2.html
and other pages from that directory and its subdirec-
tories, but is not accessible to a.com/. Furthermore,
https://a.com/ and http://a.com/ share the cookie store
unless a cookie is marked with a “secure” ﬂag. Non-
HTTPS sites may still set secure cookies in some im-
plementations, just not read them back [48]. A web pro-
grammer can make cookie access less restrictive by set-
ting a cookie’s domain attribute to a postﬁx domain or
the path name to be a preﬁx path. The browser ensures
that a site can only set its own cookie and that a cookie
is attached only to HTTP requests to that site.
The path-based security policy for cookies does not
play well with SOP for scripts: scripts can gain access
to all cookies belonging to a domain despite path restric-
tions.
Plugins. Current major browsers do not enforce any
security on plugins and grant plugins access to the local
operating system directly. The plugin content is subject
to the security policies implemented in the plugin soft-
ware rather than the browser.
3.2 Gazelle’s security model
Gazelle’s architecture is centered around protecting prin-
cipals from one another by separating their respective re-
sources into OS-enforced protection domains. Any shar-
ing between two different principals must be explicit us-
ing cross-principal communication (or IPC) mediated by
the browser kernel.
We use the same principal as the SOP, namely, the
triple of . While
it is tempting to have a more ﬁne-grained principal,
we need to be concerned with co-existing with current
browsers [29, 43]:
the protection boundary of a more
ﬁne-grained principal, such as a path-based principal,
would break down in existing browsers. It is unlikely that
web programmers would write very different versions of
the same service to accommodate different browsers; in-
stead, they would forego the more ﬁne-grained principal
and have a single code base.
The resources that need to be protected across princi-
pals [43] are memory such as the DOM objects and script
objects, persistent state such as cookies, display, and net-
work communications.
We extend the same principal model to all content
types except scripts and style sheets (Section 4): the el-
ements created by , , , and
certain types of 1 are treated the same as an
:
the origin of the included content labels
the principal of the content. This means that we en-
force SOP on plugin content2. This is consistent with the
existing movement in popular plugins like Adobe Flash
Player [20]. Starting with Flash 7, Adobe Flash Player
uses the exact domain match (as in SOP) rather than
the earlier “superdomain” match (where www.adobe.com
and store.adobe.com have the same origin) [2]; and
starting with Flash 9, the default ActionScript behavior
only allows access to same-origin HTML content unlike
the earlier default that allows full cross-origin interac-
tions [1].
Gazelle’s architecture naturally yields a security pol-
icy that partitions all system resources across the SOP