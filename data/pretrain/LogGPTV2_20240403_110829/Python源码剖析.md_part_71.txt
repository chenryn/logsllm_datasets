IN_RANGE(p,DOOl))
=pool->freeblock;
---
## Page 483
仅是将poo1重新链回到usedpools中即可，看下面的代码：
链表中，并调整了pool中的ref，count这个引用计数，确实非常简单。
代码清单16-7
freepools中去（见代码清单16-7）。
下，我们来看看Python的处理。首先Python要做的是将empty 状态的pool 链入到
[obmal1oc.c]
void PyobjectFnee（void*p)
[obmalloc.c]
void Pyobjeat_Free(voidp)
如果释放block之前，block所属的pool处于ful状态呢？这种情况也比较简单，仅
最复杂的情况发生在pool在收回block前后状态从used状态转为empty状态的情形
在pol的状态保持used状态这种情况下，Python仅仅将block重新放入到自由block
uint size;
block
POOl=POOL_ADDR（p）;
uint size;
block
pool=
poolp
return;
next-
Dool->nextpool
next
/当前pool处于ful1状态，
*lastfree;
pool:
Po01-
*lastfree;
POOL_ADDR(P）:
pool;
ADDRESS_IN_RANGE(D.DOOL))
struct arena_object ao:
->prevpool
>nextpool
next
usedpools[slze +sizel)
before
pool;
=prev;
next:
pool
next:
在释放一块block后，需将其转换为usea状态，并重新
/xanToodne1d
Python源码剖析
16.2小块空间的内存池
深度探索动态语言核心技术
453
---
## Page 484
Python源码剖析
454
Pyhon就是我们花了这么多精力剖析的Python2.5。
这几句广告语获得的）将这个patch整理，并入到了Pyhon代码中。加入了这个patch的
位老兄的名号了吧，thezenof python的创造者，当然，他在Pyhon社区的地位可不是靠
老兄的名头在Python社区也是响当当的，在Python的交互环境下键入import this，看到这
团队一直没有将这个patch并入到Pyhon代码中，一直到2006年，才由TimPeters（这位
解决方案，并在PyCon2005上做了个报告，引起了强烈的反响。但是Python的核心开发
苦，这位老兄一番探索，终于发现问题的根源在arena这里，于是一鼓作气，搞出了一套
小块内存，这导致Pyuon占用的内存冲上1GB后就再也掉不下来。想一想，确实相当痛
Jones的老兄不能忍受下去了。他在对一些巨大的图做某种算法操作时必须持续申请大量
这种情况，所以这个问题也就一直留在了Python中，但是在2004年的时候，一个叫Evan
行中再也不需要160MB如此巨大的内存，这点内存不是就浪费了？
会释放它维护的pool集合，所以这160MB的内存始终被Python占用，如果以后程序运
MEMORY_LIMITs编译符号打开，所以Pyhon会完全使用arena来满足你的需求。这都没有
问题，关键的问题在于过了一段时间，
着必须使用160MB的内存：由于Python没有默认将前面提到的限制内存池的WITH
泄漏的现象呢。考虑这样一种情形，申请10×1024X1024个16字节的小内存，这就意味
这种情况只在极少数情况下会发生。
类似于内存泄漏的问题。很多人也都意识到这个问题，但都没有太大的动力去修改，因为
作，似乎这样就可以了，
arena的控制中，似乎也没有问题。但是问题恰恰就在这时出现了。因为arena始终不
在Pyhon2.4中，实际上对arena是没有区分“未使用”和“可用”两种状态的，到了
当然，
这个问题就是：Python的arena从来不释放pool。这个问题为什么会引起类似于内存
确实，在Python2.5之前，包括2.4，Python就是这么做的，但是这样做隐藏着一个
第16章Python的内存管理机制
代码清单16-7的[1]完成了将empty状态的poo1放入freepools维护的链表中的工
，这种情形必须在大量持续申请小内存对象时才会出现，平时大家几乎不会碰到
深度探索动态语言核心技术
/1将pool放入freepoola维护的健表中
return;
一切都能够正常运转了，所有的内存始终都在掌握之中。
//ao->nfreepools
你将所有16字节的内存都释放了，这些内存都回
---
## Page 485
2.如果之前arena 中没有了empty的 pool，那么在usablearenas链表中就找不到该
usable_arenas和unused_arena_object链表，将arena 的状态转到了“未使用”状态，
当Python处理完pool之后，就要开始处理arena了。
用”状态转为“未使用”状态，这也是必须要两种状态的原因。在前面那段代码的11之后，
Python2.5中，arena可以将自已维护的pool集合释放，返回给操作系统，从而必须从“可
以及一些其他的维护工作。
void Pyobject_Free(void *p)
[obmalloc.e]
如果arena中所有的pool都是empty的，释放pool集合占用的内存。
可以看见，除了将arena 维护的pools的内存归还给系统之外，Python 还调整了
poolp next, prev
对arena的处理实际上分为了4种情况。
pool->nextpool
uint nf:
struct
pool
uint size;
bloek
BO
//设置adaress
//释放内存
//调整unuseaarena_objects链表
--narenas_currently_allocated:
elsef
++ao-
&arenas[pool
ao->prevarena+>nextanena = ao->nextarema;
*lastfree;
>nextarena
ao->nextarena->prevarena
(ab->nextarena
usable_arenas= ao->nextarena;
arena_object*
POOL_ADDR(p):
ao->ntotalpoola)
//ao->nfreepools
arena_objects= ao;
=pool:
ao->freepools;
将arena的状态转为“未使用”
umused_amena_objects;
NULL)
#ao->pnevarenag
Python源码剖析
16.2
小块空间的内存池
深度探索动态语言核心技术
455
---
## Page 486
Python源码剖析
16.2.4.4
456
我们只需记住，所有的内存都在arenas的掌控之中。
把握整个内存池。这就是下面的图16-9希望完成的目标。尽管各种不同的链表变幻无常
种情况下组成的各式各样的链表，非常复杂。但是，我们还是有可能从一个整体的尺度上
杂最繁琐的部分了，这里我们看到了对不同尺度内存的不同的抽象，看到了这些抽象在各
4.其他情况，不进行任何对arena的处理。
前面我们已经提到了，对于一个用C开发的庞大的软件，其中的内存管理可能是最复
释放其维护的pool集合的内存的机会就越大，这样就能保证多余的内存会被归还给系
能保证如果一个arena的empty pool数量越多，它被使用的机会就越少。因此，它最终
因是分配block时，是从usablearenas的表头开始寻找可用的arena的，这样，就
nfreepools，都不能大于前面的arena，也不能小于前面的arena。保持这种有序性的原
上是一个有序的链表，从表头开始往后，每一个arena中的empty的pool的个数，
若arena中的empty的pool个数为n，则从usable_arenas开始寻找arena可以插入的
链表的表头。
arena，由于现在arena中有了一个pool，所以需要将这个aerna链入到usable_arenas
第16章Python的内存管理机制
统。
后面三种情况的代码这里就不一
内存池全景
深度探索动态语言核心技术
pool_addres
9
usable_arenas.
（用）
0011223
ree
图16-9Python的小块内存的内存池全景
unused arenaobjects
arena.freeponis
（来使用
一列出了，建议读者自行到Pyhon源码中去探索一
usedipools
e用
Tee
free
3
来使
free
---
## Page 487
16.3.1
16.3
因为这些技术所带来的额外操作基本上只与待回收的内存数量有关。为了与引用计数机制
—清除（Mark——Sweep）、停止——复制（Stop——Copy）等方法相比，是—个弱点，
和释放，引用赋值的次数是成正比的，这一点，相对于主流的垃圾回收技术，比如标记
即实时性，任何内存，一旦没有指向它的引用，就会立即被回收。而其他的垃圾收集技术
我们已经多次提到。从广义上来说，引用计数也是一种垃圾收集机制，而且也是一种最直
多数对象的生命周期都是通过对象的引用计数来管理的，这一点，在本书前面的分析中，
解放出来。然而Pyhon中的动态内存管理与Java、C#有着很大的不同。在Pyton中，大
甚至以替代C++为目标的D语言，都在语言层面引入了垃圾收集机制。
硬件环境的发展，垃圾收集几乎已经成了现代主流开发语言不可或缺的特性，Java、C#，
年代初，垃圾收集机制才随着Iava的兴起，开始逐渐为工业界所接受。时至今日，随着软
象征。然而与手动管理内存相伴随的bug也因此绵延儿十年，无法根绝。直到上世纪90
有将引用计数包含在内。这个致命的弱点就是循环引用。
圾收集技术中的“死刑”。也正是由于这一致命的弱点，使得狭义的垃圾收集研究从来没
在着一个致命的弱点，这一点虽然看似很小，然而其存在却几乎宣判了引用计数机制在垃
与各种对象相关的内存池机制。这些大量使用的面向特定对象的对象内存池机制正是为了
第2节中我们就看到了小块内存的内存池。而在之前对Python对象机制的剖析中，我们
搭配，在内存的分配和释放上获得最高的效率，Py山on因此设计了大量的内存池机制，在
必须在某种特殊条件下（比如内存分配失败）才能进行无效内存的回收。
用计数的动作，然而与其他主流的垃圾收集技术相比，引用计数方法有一个最大的优点，
观，最简单的垃圾收集技术。虽然引用计数必须在每次分配和释放内存的时候加入管理引
田，管理一个又一个的字节，不仅是某些应用所必需的，更成为了程序员自身技术水平的
受限于当时的软硬件环境，垃圾收集还仅仅是一种看上去很美的技术。挽起裤管，亲自下
竭力弥补引用计数机制的软肋。
引用计数机制所带来的维护引用计数的额外操作与Pyhon运行中所进行的内存分配
Python同样也在语言层实现了内存的动态管理，从而将开发人员从管理内存的噩梦中
如果说执行效率还仅仅是引用计数机制的一个软肋的话，那么很不幸，引用计数还存
循环引用的垃圾收集
尽管学术界对于垃圾收集技术的研究早在上个世纪60年代左右就拉开了帷幕，然而
引用计数与垃圾收集
Python源码剖析
16.3循环引用的垃圾收集
一深度探索动态语言核心技术
457
---
## Page 488
Python源码剖析
16.3.2
458第16章Python的内存管理机制
过程如下：
中的垃圾收集正是基于这个模型完成的。
清除（Mark一Sweep）方法是如何实现的，并为这个过程建立一个三色标记模型。Python
重新掌握在垃圾检测阶段所标识出来的可回收内存块。在本节，我们将来看一看标记一
所有的已分配的内存中区别出可以回收的内存和不可回收的内存，而垃圾回收则是使系统
也是最致命的漏洞。
流垃圾收集技术中的标记一
证不出现循环引用。这一点将立刻把所有的Python开发者都推到Java、C#的阵营中。
将精力放到问题域的建模、实现上时，还需要花费额外的精力来精心设计代码结构，以保
然在实际中，可以通过某种方法在语言一级保证不出现循环引用，然而这就要求开发者在
此这些对象所占用的内存永远不会被回收。图16-10展示了Python中的一个循环引用。
这些对象所占用的内存，然而由于互相引用的存在，每一个对象的引用计数都不为0，因
何外部变量引用，它们之间只是互相引用。这意味着不会再有人使用这组对象，应该回收
就在于，循环引用可以使一组对象的引用计数都不为0，然而这些对象实际上并没有被任
为0，那么意味着对象已经不会被任何人使用，可以将其所占用的内存释放。问题的关键
计数加1；当一个对象的引用被销毁时，对象的引用计数减1。如果对象的引用计数减少
从具体的实现上来讲，标记一
无论何种垃圾收集机制，
要解决这个问题，必须引|入其他的垃圾收集技术来打破循环引用，Py出on中引入了主
三色标记模型
毫无疑问，这一点是致命的，这与手动进行内存管理所产生的内存泄露毫无区别。虽
我们知道，引用计数机制非常简单，
一深度探索动态语言核心技术
>>>
>>
12
12.append(11)
11
图16-10Python中的循环引用
一般都分为两个阶段：垃圾检测和垃圾回收。垃圾检测是从
一清除和分代收集两种技术来填补其内存管理机制中最后的
一清除方法同样遵循垃圾收集的两个阶段，其简要工作
当一个对象的引用被创建或复制时，对象的引用
ref=1
ref=1
---
## Page 489
16.4
分代收集只是为了打破循环引用而引入的补充技术。这一事实意味着Pyhon中的垃圾收
也就意味着垃圾检测阶段结束了。图16-11展示了垃圾收集的某个时刻有向图的一个局部。
集合就如同一个波的阵面一样，不断向外扩散，随着所有的灰色节点都变为了黑色节点，
灰色。假如我们从rootobject集合出发，采用先广搜索的策略，可以想象，灰色节点对象
示其包含的所有引用已经被检查过了。显然，这时，A中引用所引用的对象则被标记为了
引用还没有检查。当我们检查了对象A中所包含的所有引用之后，A将被标记为黑色，以
到达了对象A，那么我们将A标记为灰色，灰色表示一个对象是可达的，但是其所包含的
从垃圾收集的动作开始，沿着始于rootobject集合中的某个object的引用链，在某个时刻
设系统中的所有对象都是不可达的，对应在有向图上，即所有的节点都标注为白色。随后，
建立一个三色标注模型，更形象地展示垃圾收集的整个动作。当垃圾收集开始时，我们假
有向图，其中对象是图中的节点，而对象间的引用是图的边。我们在这个有向图的基础上
Python中的垃圾收集
如前所述，在Pyhon中，主要的内存管理手段是引用计数机制，而标记—清除和
在垃圾收集动作被激活之前，系统中所分配的所有对象和对象之间的引用组成了一张
V
V
被回收，这就是垃圾回收阶段
部分，所有的可达对象都必须予以保留，而所有的不可达对象所占用的内存将
当垃圾检测阶段结束后，所有的对象分为了可达的和不可达的（unreachable）两
是垃圾检测阶段
对象A，则A称为可达的（reachable），
从rootobject集合出发，沿着rootobject集合中的每一个引用，如果能到达某个
垃圾检测动作的起点
栈中的引用。这些引用所用的对象是不可被删除的。而这个rootobject集合也是
寻找根对象（rootobject）的集合，所谓的rootobject即是一些全局引用和函数
图16-11垃圾收集过程中某个时刻的多个对象组成的有向图
Python游码剖析
可达的对象也不可被删除。这个阶段就
16.4Python中的垃圾收集
深度探索动态语言核心技术
459
---