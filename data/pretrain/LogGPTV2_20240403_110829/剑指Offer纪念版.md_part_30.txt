---
## Page 205
int
int InversePairs(int*data,int length)
就是归并排序。我们可以基于归并排序写出如下代码：
进行排序。如果对排序算法很熟悉，我们不难发现这个排序的过程实际上
相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组
分隔成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个
的指针向前移动一位，接下来进行下一轮比较。
组中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应
候，我们都把较大的数字从后往前复制到一个辅助数组中去，确保辅助数
个数组中的数字，则不构成逆序对（如图5.2（b）所示）。每一次比较的时
图5.2（a）和图5.2（c）所示）。如果第一个数组中的数字小于或等于第二
构成逆序对，
指向的数字。如果第一个子数组中的数字大于第二个子数组中的数字，则
细分图5.1（d）的合并子数组及统计逆序对的过程。
int length =(end - start)/ 2;
if(start == end)
InversePairsCore(int* data,int* copy,int start, int end)
return count;
delete[] copy;
int count = InversePairsCore(data, copy, 0, length - 1);
int* copy
if(data == NULLI1 length = start +length +1;--j)
for（;i>=start;--i)
?
while(i>=start&&j>=start+length+1)
int
intj=end;
//i初始化为前半段最后一个数字的下标
int right=InversePairsCore(copy,data,start +length +1,end);
int
copy[indexCopy--]= data[j];
copy[indexCopy--]=data[i];
初始化为后半段最后一个数字的下标
功能测试（输入未经排序的数组、递增排序的数组、递减排序的
if(data[i]>data[j])
数组，输入的数组中包含重复的数字)。
left
一名企面试官精讲典型编程题（纪念版）
se
copy[indexCopy--]=data[j--];
count +=j-start-length;
copy[indexCopy--]=data[i--];
start+length;
：InversePairsCore(copy,
,data,start，
start +length);
---
## Page 207
状看起来像一个Y，而不可能像X（如图5.3所示）。
的，不可能再出现分叉。所以两个有公共结点而部分重合的链表，拓扑形
的 m_pNext 都指向同一个结点。但由于是单向链表的结点，每个结点只有
如果两个单向链表有公共的结点，那么这两个链表从某一结点开始，它们
个链表有哪些特点。从链表结点的定义可以看出，这两个链表是单向链表。
杂度是O(mn)。
如果第一个链表的长度为m，第二个链表的长度为n，显然该方法的时间复
一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。
序遍历每个结点。如果在第二个链表上有一个结点和第一个链表上的结点
链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺
struct ListNode
面试题37：两个链表的第一个公共结点
通常蛮力法不会是最好的办法，我们接下来试着分析有公共结点的两
面试的时候碰到这道题，很多应聘者的第一反应就是蛮力法：在第一
ListNode* m_pNext;
int
题目：输入两个链表，找出它们的第一个公共结点。链表结点定义如下：
本题考点：
题思路，那通过这轮面试的几率就很高了。
的过程中发现问题与归并排序的相似性，并能基于归并排序形成解
考查应聘者对归并排序的掌握程度。如果应聘者在分析统计逆序对
序对的规律，是应聘者解决这个题目的关键。
考查分析复杂问题的能力。统计逆序对的过程很复杂，如何发现逆
特殊输入测试（表示数组的指针为NULL指针)。
数字）
边界值测试（输入的数组中只有两个数字、数组的数组只有一个
，因此从第一个公共结点开始，之后它们所有结点都是重合
m_nKey;
第5章优化时间和空间效率193
---
## Page 208
194
剑指Offer
ListNode*FindFirstCommonNode(ListNode *pHeadl,ListNode *pHead2)
之后，就可以动手写代码了。下面是一段参考代码：
需要辅助的栈，因此提高了空间效率。当面试官首肯了我们最后一种思路
两个结点，直到找到它们第一个相同的结点6，这就是我们想要的结果。
的链表上走1步，到达结点2。接下来分别从结点2和结点4出发同时遍历
为5和4，也就是较长的链表与较短的链表相比多一个结点。第二次先在长
两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点。
结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在
它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个
一致。其实解决这个问题还有一个更简单的办法：首先遍历两个链表得到
两个链表的长度不相同时，如果我们从头开始遍历到达尾结点的时间就不
间效率。
开始的蛮力法相比，时间效率得到了提高，相当于是用空间消耗换取了时
结点就位于两个栈的栈顶，接下来比较两个栈顶的结点是否相同。如果相
解决这个问题：分别把两个链表的结点放入两个栈里，这样两个链表的尾
点开始按顺序遍历，最后才能到达尾结点。最后到达的尾结点却要最先被
同的结点就是我们要找的结点。可问题是在单向链表中，我们只能从头结
两个链表的尾部。如果我们从两个链表的尾部开始往前比较，最后一个相
图5.3两个链表在值为6的结点处交汇
日TT
0，
那么空间复杂度是O(m+n)。这种思路的时间复杂度也是O(m+n)。和最
unsigned intnLength2
unsigned int nLengthl = GetListLength(pHeadl);
//得到两个链表的长度
第三种思路和第二种思路相比，时间复杂度都是O(m+n)，但我们不再
比如在图5.3的两个链表中，我们可以先遍历一次得到它们的长度分别
之所以需要用到栈，是因为我们想同时遍历到达两个栈的尾结点。当
：则把栈顶弹出接着比较下一个栈顶，直到找到最后一个相同的结点。
在上述思路中，我们需要用两个辅助栈。如果链表的长度分别为m和
经过分析我们发现，如果两个链表有公共结点，那么公共结点出现在
一名企面试官精讲典型编程题（纪念版）
=GetListLength(pHead2);
---
## Page 209
unsigned int
return nLength;
while（pNode!=NULL)
ListNode*pNode = pHead;
unsigned int nLength = 0;
本题完整的源代码详见37_FirstCommonNodesInLists项目。
return pFisrtCommonNode;
ListNode*
//得到第一个公共结点
while(（pListHeadLong != NULL)&&
for（inti
1/先在长链表上走几步，
if(nLength2
ListNode*
ListNode*
int nLengthDif =nLength1-
源代码：
++nLength;
pListHeadShort =pListHeadShort->m_pNext;
pListHeadLong = pListHeadLong->m_pNext;
pListHeadLong
（pListHeadLong !=pListHeadShort))
(pListHeadShort!=NULL)&&
nLengthDif =nLength2
pListHeadShort
GetListLength(ListNode*pHead)
pFisrtCommonNode = pListHeadLong;
pListHeadShort= pHead2
pListHeadLong=pHeadl;
0；
>nLengthi)
im_pNext;
=pHeadl;
再同时在两个链表上遍历
nLengthl;
nLength2;
++i）
第
5章
优化时间和空间效率
195
---
## Page 210
196剑指Offer-
力
并且一般情况下面试官更加关注时间复杂度。
本章小结
本书7.2节，我们将详细讨论如何求两个结点的最低公共祖先。
链表的第一个公共结点正好就是二叉树中两个叶节点的最低公共祖先。在
一棵树的形状非常相似，只是这里的指针是从叶结点指向根结点的。两个
降低时间复杂度的第一个方法是改用更加高效的算法。比如我们用动
编程面试的时候，面试官通常对时间复杂度和空间复杂度都会有要求，
如果把图5.3逆时针旋转90°，我们就会发现两个链表的拓扑形状和
测试用例：
相关题目：
本题考点：
考查应聘者对链表的编程能力。
考查应聘者对时间复杂度和空间复杂度的理解及分析能力。解决这
特殊输入测试（输入的链表头结点是NULL指针）
功能测试（输入的两个链表有公共交点：第一个公共结点在链表的
优化的地方。
快分析出这种思路的时间复杂度和空间复杂度是多少，并找到可以
道题有多种不同的思路。每当应聘者想到一种思路的时候，都要很
结点；输入的两个链表没有公共结点)。
中间，第一个公共结点在链表的末尾，第一个公共结点是链表的头
-名企面试官精讲典型编程题（纪念版）
---
## Page 211
格外留心，因为通常嵌入式系统的内存很有限。
要关注问题的背景。如果面试题是有关嵌入式开发的，那对空间消耗就要
意需要的辅助空间的大小，消耗太多的内存可能得不偿失。另外，我们还
面试题9“斐波那契数列”。
问题的结果来避免重复计算。更多关于递归的讨论请参考本书的2:4.2节及
求解问题的时候，如果有重复的子问题，同样我们也可以通过保存求解子
重复的计算。面试题34“丑数”就是这方面的一个例子。在用递归的思路
型的题目。另外，我们可以创建一个缓存保存中间的计算结果，从而避免
是用0(1)时间就能知道任意字符出现的次数。这种思路可以解决很多同类
一个只出现一次的字符”的时候，我们用数组实现一个简单的哈希表，于
值得注意的是，以空间换取时间并不一定都是可行的方案。我们要注
降低时间复杂度的第二个方法是用空间换取时间。在解决面试题35“第
第5章优化时间和空间效率197
---
## Page 212
的沟通能力及求知欲。”
时的反应，在他们回答不出时会有人员提供解答，在解答过程中观察他
面试官谈能力
个能力都很重要，基本能够起到一票否决的作用。”
对面试题能够快速寻找解决方法是判断应聘者学习能力的一个方法。这两