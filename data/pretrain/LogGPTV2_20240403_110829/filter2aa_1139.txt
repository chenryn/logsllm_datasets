Breaking Samsung's Root of Trust: 
Exploiting Samsung S10 S-Boot
Jeffxx
#BHUSA   @BLACKHATEVENTS 
Jeff Chao (Jeffxx)
◆ Researcher at TrapaSecurity
◆ Ex-senior Researcher at TeamT5
◆ Member of HITCON CTF Team
◆ Member of Chroot
◆ Focus on Mobile and IoT Vulnerabilities
AGENDA
01
02
03
04
05
Samsung Security Framework - Knox
Related Work
Vulnerabilities in Secure Boot 
Demo
After Code Execution on S-boot
Demo Video
Samsung Security Framework 
Knox
Knox - Root of Trust
Knox – Trusted Boot
◆ Hardware PBL
◆ Verify secure boot(S-Boot) & load
◆ S-Boot 
◆ Set handler for Monitor mode, drop privilege
◆ Request EL3 to initial TEEOS
◆ Verify & Load Hypervisor (uh.bin)
◆ Verify & Load Kernel (boot.img)
◆ Kernel with DM-Verity
◆ Verify system.img & mount
◆ Verify vendor.img & mount
Knox bit (warranty bit)
◆ One-time fuse, can’t restore
◆ Blow the fuse when trying to boot a custom image and prevent further booting
Sensitive Data Protection
◆ The storage (Sensitive Data) is encrypted when the device is locked
◆  Encrypted Keys are stored in trustzone
Sensitive Data Protection cont
◆ Some critical information can only be decrypted by trustlet
ARM Trustzone
Non-secure World
User Mode
Kernel Mode
Hypervisor Mode
Secure World
User Mode
Kernel Mode
Monitor Mode
EL0
EL1
EL2
EL3
Related Work
BH17 – Defeating Samsung KNOX 
with zero privilege by returnsme
◆ EL0 -> EL1
Non-secure World
User Mode
Kernel Mode
Hypervisor Mode
Secure World
User Mode
Kernel Mode
Monitor Mode
EL0
EL1
EL2
EL3
BH17 EU - How Samsung Secures 
Your Wallet by Tencent Lab
◆ EL0 -> Secure EL0 (kinibi)
Non-secure World
User Mode
Kernel Mode
Hypervisor Mode
Secure World
User Mode
Kernel Mode
Monitor Mode
EL0
EL1
EL2
EL3
BH19 – Breaking Samsung’s Arm 
Trustzone
◆  EL0 -> Secure-EL3 (kinibi, S8 and before)
Non-secure World
User Mode
Kernel Mode
Hypervisor Mode
Secure World
User Mode
Kerne Mode
Monitor Mode
EL0
EL1
EL2
EL3
What if the device is turned off & 
we don’t know the passcode?
In this talk
◆  out-side the box(locked phone) -> Non-Secure EL1
Non-secure World
User Mode
SVC/Sys/Abort Mode
Hypervisor Mode
Secure World
User Mode
SVC/Sys/Abort Mode
Monitor Mode
EL0
EL1
EL2
EL3
S-Boot Boot Flow 
Init
Verify boot image
Boot into kernel
Set monitor mode
Check boot mode
ODIN mode
volumn down + power
ODIN mode
◆ Flash stock firmware
◆ Rollback prevention
Vulnerability I
Odin Request
◆ opCode 
◆ 0x64 Odin mode initial & settings
◆ 0x65 Flash PIT
◆ 0x66 Flag image
◆ subOp
◆ Depends on opCode
◆ Maybe initialize, set, get …etc
◆ arg1 ~ arg4
◆ assign size or some value
Odin Flash Image Command
◆ No check for provided size
◆ Integer overflow
◆ Use 0xC0000000 if less then 0x1e00000
◆ Otherwise use 0xB0000000  
◆ Copy to buffer
◆ S8 and before at 0xC0000000
◆ S9 and later at 0x880000000
Overflow the physical memory
0xC0000000
0xC9000000
sboot code 
segment
sboot data 
segment
stack
heap 
heap 
buffer for flash 
image
0xC0000000
0xC9000000
data overwritten
filled with null
Bypass MMU
◆ S-Boot code segment at 0xC9000000 but read only
◆ USB devices have direct memory access
◆ Ignores mmu control
Cache Incoherency
◆ While receiving data, the CPU keeps tracking the USB event
◆ This code is cached
◆ Only the heap will not be cached
Code Execution
◆ The heap is not cached, the code accesses a pointer in the heap…
◆ Trigger data-abort as soon as we overwrite heap data with NULL
◆ Overwrite the error handler code with jump sled
◆ Put shellcode in front of the code segment 
Overflow the physical memory
0xC0000000
0xC9000000
sboot code 
segment
sboot data 
segment
stack
heap 
heap 
buffer for flash 
image
modified sboot 
code segment
filled with null
filled with null
shellcode
0xC0000000
0xC9000000
But
◆ S9 and later are not exploitable
◆ The default buffer is changed to 0x880000000
◆ Spent half a year trying to exploit S10
Potential Exploit Path on S10
◆ In S9 and later, ODIN has parallel & compressed download mode
◆ It will boot up another 2 cpu cores, and set the image buffer to 0x880000000
◆ Fallback to normal download if boot cpu failure
◆ Buffer change back to 0xC0000000
Potential Exploit Path on S10
◆ Make CPU boot fail
Potential Exploit Path on S10
◆ Uart mode
◆ Cmd – smp_test
◆ Test Boot up a cpu core and shutdown immediately
◆ But count of booted cores will not decrease
◆ Cmd – download
◆ Enter Odin mode
Potential Exploit Path on S10
◆ Enter Uart Mode
◆ We need a debug cable to make S-Boot detect RID_523K
◆ Tried TypeC VDM mode, accessory mode, pull-down pull-up resistor
◆ All failed
 We reported the bug on Aug 2019 
Result: Duplicated
Patch Note
◆ Samsung Security Update - October 2019
◆ SVE-2019-15230 Potential Integer overflow in Bootloader
The Patch
Vulnerability II
Aligned Size?
Odin - packet data size
◆ We can set packet data size with opCode 0x64, subOp 0x05
Exploit
◆ Bypass the check
◆ The usb receive size can be larger than 0x10000000 again
◆ Achieve code execution in the same way as the previous vulnerability
I reported the bug immediately
Patch Note
◆ Samsung Security Update - Jan 2020 
The Patch
Vulnerability III
ODIN – PIT flash command
◆ opCode = 0x65
◆ PIT is very small, odin store it to heap buffer
◆ With the size 0x2000 
The patch of vulnerability II
◆ Size of packet data can be upto 0xFFFFFF
◆ > 0x2000  => heap overflow
Pseudo code - receive data
◆ This is a pseudocode representation of the receive operation
◆ In our test, the usb_recv function will receive until the passed size is reached
◆ Even if we send data with a huge interval
We thought this was 
un-exploitable, so I stuck to 
vulnerability I
How About Interrupting the USB
◆ Remove and Re-insert the USB cable
◆ the usb_recv returns with insufficient size
Heap overflow
◆ We can overwrite the metadata 
of heap chunk
◆ House of Spirit
Heap
size
unused
prev
next
data
size
unused
prev
next
data
size
unused
prev
next
data
Fake Chunk
No check for double linked list
faked chunk
size
unused
prev
next
data
size
unused
prev
next
data
size
unused
prev
next
data
Limited Overwrite Data
◆ *prev + 4 = 1
◆ It aarch64, integer 64 bit
◆ Code at 0xC9000000
◆ We can not point to
◆ Got
◆ Function pointer
faked chunk
size
unused
prev
next
data
size
unused = 1
prev
next
data
size
unused
prev
next
data
Free
Overwrite RIP in stack
◆ The only chance is to overwrite a return 
address on stack
◆ Only 3 function calls 
◆ Fortunately
◆ Odin cmd buf is the first local variable
Stack
SP
PC
local variable
local variable
SP
PC
local variable
SP
PC
Stack
SP
PC
local variable
local variable
SP
PC
local variable
SP
PC
size
unused
prev
next
data
size
unused
prev
next
data
Odin cmd buf
After Code Execution in S-boot
Boot the phone 
◆ We smashed the stack & heap
◆ Hard to recover
◆ Call the boot functions one by one
sboot code 
segment
sboot data 
segment
stack
heap 
heap 
buffer for 
flash image
modified 
sboot code 
segment
filled with null
filled with null
shellcode
Skip Trustzone related calls
◆ We only have EL1 privilege
◆ Some smc calls to trustzone can not be called twice
◆ Skip the smc calls and set the related parameters
Load Custom Kernel
◆ After loading the kernel to memory (the function cmd_load_kernel)
◆ Replace the image with a custom one
◆ Boot the kernel (call the function cmd_boot)
Exploit
◆ Set the size of packet data to a big number
◆ Send Odin PIT flash command
◆ Send payload after Interrupt the usb_recv(), leads to heap overflow 
◆ Send Another Odin command to trigger malloc & free the buffer
◆ Overwrite RIP on stack, jump to shellcode 
◆ Re-init heap and stack
◆ Continue booting
◆ Before boot into kernel, replace the boot image
We got el1 in normal world
Non-secure World
User Mode
Kernel Mode
Hypervisor Mode
Secure World
User Mode
Kernel Mode
Monitor Mode
EL0
EL1
EL2
EL3
But the phone is still locked
Can not read sensitive data
◆ Storage is still encrypted if we didn’t provide the screen passcode
◆ Encryption key can only be decrypted in the gatekeeper trustlet
◆ Some data in trustlet can not be reached
Man in the Non-secure EL1
◆ Wait for the user to unlock the phone
◆ Hijack / Sniff everything between non-secure world and secure world
Non-secure World
User Mode
Kernel Mode
Hypervisor Mode
Secure World
User Mode
Kernel Mode
Monitor Mode
EL0
EL1
EL2
EL3
Exposed Attacking surface
◆ Attacking secure world trustlet
◆ Gatekeeper trustlet
◆ Samsung Pay trustlet
◆ Keystore trustlet
◆ …
◆ Many vulnerabilities in the past
Non-secure World
User Mode
Kernel Mode
Hypervisor Mode
Secure World
User Mode
Kernel Mode
Monitor Mode
EL0
EL1
EL2
EL3
Attack the gatekeeper trustlet to decrypt storage
◆ SVE-2019-14575
◆ With this vulnerability, we can try all the possible pattern codes in a few hours.
Sensitive Data unlocked
Conclusion
◆ Even if the data is stored in secure world, it doesn’t mean it’s 100% secure
◆ But it’s made exploiting complex, multiple actions are needed to retrieve the data
◆ Landing - RCE / Local USB Exploit / Social Engineering
◆ Privilege escalation to non-secure EL1
◆ Vulnerabilities in trustlet to get into secure-world EL0
◆ Privilege escalation from secure-world EL0 to secure-world EL1 or EL3 
◆ Without all of this, especially the points in red, the data in the phone is still safe
Disclosure Timeline
◆ 2019-10-02 Report Vulnerability I
◆ 2019-10-08 Informed Vulnerability I duplicated
◆ 2019-10-11 Report Vulnerability II
◆ 2020-01-06 Samsung Patched, SVE-2019-15872
◆ 2020-01-21 Report Vulnerability III
◆ 2020-05-06 Samsung Patched, SVE-2020-16712
Jeffxx
PI:EMAIL
THANK YOU!