# Firefox IPC消息处理越界写漏洞（CVE-2018-5129）分析
##### 译文声明
本文是翻译文章，文章原作者 loopsec，文章来源：infinite.loopsec.com.au
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 一、概述
本文主要对我在去年年底发现的Firefox漏洞进行分析。在深入到细节之前，首先要聊聊在我开发漏洞利用程序过程中的体会，以及在过去几个月中发生的事情。
从去年11月开始，我决定想要做一些更加“现实”的漏洞利用。我希望选择一个在调试和漏洞利用方面都实际可行的目标，并且相关的学习资料最好能易于获得。基于此，我挑选了一个浏览器，也就是Firefox进行漏洞研究。不止是因为这款浏览器在开发和维护过程中都有大量的文档可做参考，还因为这是一个完全开源的软件，此前也有一些漏洞利用的研究成果，并且看起来非常有趣！
我认真分析了Firefox此前被发现的所有漏洞，并选择了其中一个比较有趣的CVE-2017-5428。这个漏洞的有趣之处在于，它曾经在Pwn2Own
2017中被使用过，而且这一漏洞可以通过JavaScript进行利用。既然如此，我的目标就是弹出calc.exe（针对Windows）或calc.app（针对macOS）。
在度过了几个不眠之夜，尝试对CVE-2017-5428进行漏洞利用之后，我开始意识到，我实际上已经针对一个完全不同的漏洞实现了漏洞利用。大家可能想问，你是怎么根据原有漏洞发现另一个漏洞的？其实，这个新漏洞其实是我在尝试进行原有漏洞利用过程中无意发现的，我甚至一开始没有意识到它本身就是一个漏洞。事实证明，这是一次非常有趣的体验。
## 二、漏洞概览
###  2.1 CVE-2017-5428（Pwn2Own）
2017年3月17日，Firefox发布了一份报告（ 
），详细说明了Chaitin安全研究实验室发现的一个漏洞（CVE-2017-5428），该漏洞影响52.0.1版本以下的火狐浏览器。由于Pwn2Own
2017上的演示（  ），趋势科技的Zero Day
Initiative随即报告了这一漏洞。该漏洞的Firefox参考（Bug#1348168，
）中包含了有关漏洞利用、漏洞分析和缓解方案的内部讨论。
CVE-2017-5428是由于createImageBitmap()函数中存在整型溢出漏洞。具体来说，ImageBitmap对象接受ArrayBuffer或ArrayBufferView作为参数的构造函数发生了重载。
###  2.2 CVE-2018-5129
2018年3月13日，Firefox发布了一份咨询报告（ 
），披露了我在CVE-2017-5428漏洞利用过程中发现的新漏洞。该漏洞可以在52.0.1版本以下的Firefox中从非特权JavaScript中触发。但在较新版本的Firefox中，需要使用一些加密视频文件元数据来制作触发器，这一过程比较棘手。
本文将重点介绍CVE-2018-5129的技术细节以及触发器的制作过程。
## 三、理解漏洞：一些重要的对象
在我们进入到对漏洞的技术分析之前，我认为首先了解一些重要对象的用途，并弄清它们在浏览器中的工作方式，这一点是至关重要的。
###  3.1 ImageBitmap
第一个重要的对象是ImageBitmap对象，这一对象是用于存储位图图像的接口，可以绘制到元素上，并且不会有任何明显的渲染时间。有很多方法可以使用createImageBitmap()工厂方法模式（Factory
Method）创建对象，但由于CVE-2017-5428漏洞的存在，一些重载的构造函数已经失效。ImageBitmap对象还提供了一种异步的、资源友好的方式，准备用于在WebGL中呈现的纹理。
该对象具有两个属性：width和height，同时只有一个方法close()，该方法负责处理与ImageBitmap对象关联的所有图形资源。
###  3.2 ImageBitmapFormat
ImageBitmapFormat是一个包含许多成员的枚举类。枚举成员表示ImageBitmap对象可以采用多种不同的uint32_t内部格式。这些不同的格式，在枚举类中定义如下：
    enum class ImageBitmapFormat : uint32_t {
      RGBA32,
      BGRA32,
      RGB24,
      BGR24,
      GRAY8,
      YUV444P,
      YUV422P,
      YUV420P,
      YUV420SP_NV12,
      YUV420SP_NV21,
      HSV,
      Lab,
      DEPTH,
      EndGuard_
    };
###  3.3 RecyclingPlanarYCbCrImage & PlanarYCbCrImage
RecyclingPlanarYCbCrImage和PlanarYCbCrImage表示原始图像数据。
PlanarYCbCrImage和Recycling对象之间的区别在于，Recycling对象使用内部缓冲区分配机制。它有一个简单的Array，用于存储当前分配或释放的每个缓冲区。这样以来，初始化和分配的新对象将从空闲缓冲区数组中得到缓冲区，从而实现对旧内存的回收，而不是继续请求更多内存空间。
## 四、漏洞详情
首先，我们来看看脱离上下文环境的漏洞。所谓脱离上下文环境，就是我们首先了解存在漏洞的函数和类，但暂时不关注如何从JavaScript实现对漏洞的利用。我们将在下一章中对代码库进行跟踪，并开发JavaScript触发器。
###  4.1 函数#1 – RecyclingPlanarYCbCrImage::CopyPlane
第一个相关的函数是下面展示的CopyPlane函数。这一函数名称直接说明了它的功能——将aSrc缓冲区复制到aDst缓冲区中。但是，该函数会根据aSkip参数的不同，执行以下两种复制类型中的一种：
如果aSkip == 0，将采用“快速路径（Fast
Path）”。这一路径使用memcpy函数将aSrc缓冲区复制到aDst缓冲区中。大小计算基于aSize.height *
aStride的结果，它们都是由调用函数提供的。
如果aSkip != 0，将采用“慢速路径（Slow Path）”。这一路径使用嵌套的for循环对aSrc和aDst缓冲区进行循环，每次循环复制一个字节。
    CopyPlane(uint8_t *aDst, const uint8_t *aSrc, const gfx::IntSize &aSize, int32_t aStride, int32_t aSkip)
    {
      if (!aSkip) { /* 1 */
        // Fast path: planar input.
        memcpy(aDst, aSrc, aSize.height * aStride);
      } else { /* 2 */
        int32_t height = aSize.height;
        int32_t width = aSize.width; 
        for (int y = 0; y < height; ++y) {
          const uint8_t *src = aSrc;
          uint8_t *dst = aDst;
          // Slow path
          for (int x = 0; x < width; ++x) {
            *dst++ = *src++;
            src += aSkip; /* Nuance 1 */
          }
          /* Nuance 2 */
          aSrc += aStride; 
          aDst += aStride;
        }
      }
    }
CopyPlane提供的功能并不是始终不变的，通常DOM和JavaScript引擎会提供经优化后的“Fast”路径和一个较慢的“Slow”路径，以便在满足特定条件的情况下提高处理速度。在这种情况下，我们还需要了解二者的一些细微差别。
如果在“Slow Path”中使用aSkip参数，就意味着如果aSkip =
1（或任何非0数值），那么内层x循环内的每次循环都将跳过aSrc缓冲区的1个字节。这一点非常重要，需要在后续利用。
在内层x循环完成后，每次循环都会使用aStride参数。同样，如果aStride =
1，那么外层y循环的每次迭代都将跳过aSrc和aDst缓冲区的1个字节。
现在，我们对于CopyPlane函数的运行方式有了一定了解，接下来让我们来看看调用函数。
###  4.2 函数#2 – RecyclingPlanarYCbCrImage::CopyData
在这种情况下，我们调用的函数是CopyData，该函数只有一个参数aData。CopyData充当CopyPlane函数的包装器，用于计算大小、分配目标缓冲区，并通过3次调用CopyPlane，在3个独立的通道上执行复制操作。为简单起见，我们只展示了与漏洞相关的代码部分。
    RecyclingPlanarYCbCrImage::CopyData(const Data& aData){
      mData = aData;
      /* 1 */
      // update buffer size
      size_t size = mData.mCbCrStride * mData.mCbCrSize.height * 2 + mData.mYStride * mData.mYSize.height;
      /* 2 */
      // get new buffer
      mBuffer = AllocateBuffer(size);
      /* 3 */
      if (!mBuffer)
        return false;
      // update buffer size
      mBufferSize = size;
      mData.mYChannel = mBuffer.get();
      mData.mCbChannel = mData.mYChannel + mData.mYStride * mData.mYSize.height;
      mData.mCrChannel = mData.mCbChannel + mData.mCbCrStride * mData.mCbCrSize.height;
      /* 4 */
      CopyPlane(mData.mYChannel, aData.mYChannel, mData.mYSize, mData.mYStride, mData.mYSkip);
      CopyPlane(mData.mCbChannel, aData.mCbChannel, mData.mCbCrSize, mData.mCbCrStride, mData.mCbSkip);
      CopyPlane(mData.mCrChannel, aData.mCrChannel, mData.mCbCrSize, mData.mCbCrStride, mData.mCrSkip);
     ...
      }
最初，在跟踪CVE-2017-5428的代码时，整型溢出体现得非常明显。变量size被定义为size_t（默认情况下为无符号整数），在64位系统上存储为最大的ULONG_MAX类型，在32位系统上存储为UINT_MAX。Firefox默认为64位，因此需要一些计算，来精确算出其每个组件的大小，以便让我们能够控制溢出。但是，经计算，我们可以轻松地对大小变量进行溢出。然后，得到的整数值可以用于缓冲区分配。这一整型溢出是Chaitin安全研究实验室在Pwn2Own上展示的基础，但我还是建议各位读者阅读该团队的漏洞报告并对其尝试利用。
在计算大小之后，我们从RecycleBin中分配一个缓冲区。这样就意味着，我们的缓冲区将被RecyclingPlanarYcbCrImage对象中这个实例分配的预先存在的缓冲区列表所使用。
在有了缓冲区之后，就会继续为每个通道计算适当的偏移量。每一个通道代表不同的色彩空间，共同作为YCbCr色彩空间系列的一部分。最后，使用相关参数调用我们的CopyPlane函数。
需要注意的一件事是，这个函数是mData成员。在第二行，mData被设置为等于aData参数，这就意味着在我们的3个CopyPlane调用中，包含aData参数的任何内容都不会被CopyData函数所修改。反过来，任何未被修改的mData成员都与aData成员相同（例如每个通道成员变量）。
###  4.3 越界访问写入
作为漏洞利用开发过程的一部分，我对两个函数执行了相同级别的分析，并确定了其中的关键点。就是在这个过程中，我发现了CVE-2018-5129的存在，但直到我通过触发器成功实现堆喷射（Heap-spray）和信息泄露，我才意识到这是一个新的漏洞。
此漏洞的第一部分，是计算CopyData函数中的size变量。这一计算过程会用到mData的以下成员：
    mData.mCbCrStride <--- CbCr Stride
    mData.mCbCrSize.height <--- CbCr Height
    mData.mYStride <--- Y Stride
    mData.mYSize.height <--- Y Height
计算过程会使用两个单独的“Channel”对象的跨度（Stride）和高度（Height）来计算总缓冲区大小，因此要分别计算mYChannel、mCbChannel和mCrChannel每个目标mBuffer的大小。
起初，我认为这个计算过程除了已被发现的整型溢出漏洞之外没有问题。但直到我仔细研究了CopyPlane函数的慢速路径，我才注意到这个微妙的问题。
        int32_t height = aSize.height;
        int32_t width = aSize.width; 
        for (int y = 0; y < height; ++y) {
          const uint8_t *src = aSrc;
          uint8_t *dst = aDst;
          // Slow path
          for (int x = 0; x < width; ++x) { <----- HERE!!
            *dst++ = *src++;
            src += aSkip;
          }
          /* b */
          aSrc += aStride; 
          aDst += aStride;