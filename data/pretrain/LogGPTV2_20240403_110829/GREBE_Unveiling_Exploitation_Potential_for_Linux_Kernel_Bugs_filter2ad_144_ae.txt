WARNING: refcount bug in crypto destroy tfm
6.69 2.62 0.06
1.25
KASAN: use-after-free Read in crypto alg extsize
KASAN: use-after-free Read in free netdev
KASAN: use-after-free Read in netif napi add
KASAN: use-after-free Read in release sock
KASAN: use-after-free Read in nr release
KASAN: use-after-free Read in nr insert socket
KASAN: use-after-free Write in nr insert socket
KASAN: use-after-free Read in lock sock nested
KASAN: use-after-free Read in delayed uprobe remove
KASAN: use-after-free Read in uprobe mmap
general protection fault in uprobe mmap
KASAN: use-after-free Read in update ref ctr
-
-
-
-
-
-
-
-
-
-
-
-
-
83.69
- 155.76 30.30
77.41 9.08
-
4.39
-
0.03
-
20.00
0.06
-
126.82
-
18.20
-
3.83
-
6.66
-
12.69 4.10
89.49
-
-
157.46
-
-
-
-
-
-
-
bdeea91[23]
aead instance, crypto aead, ,
crypto spawn, pcrypt instance ctx
crypto aead spawn, crypto type
5d3cce3[8]
napi struct, tun ﬁle
general protection fault in hrtimer active
521a764[24]
ax25 address, nr sock
WARNING: refcount bug in nr insert socket
229e0b7[25]
delayed uprobe
general protection fault in delayed uprobe remove
TABLE II: The performance of Syzkaller, Syzkaller variant, GREBE and GREBE without mutation optimization under some
sampled kernel bugs. The “SYZ ID” column is the case ID. The “Critical Structures Identiﬁed” means the structures that are
identiﬁed by the static analysis tools then are utilized by GREBE. The “Initial Error Behavior” column indicates the error
behavior manifested in the corresponding bug report. The “Discovered New Error Behaviors” column is the error behaviors
newly discovered. Note that, for each case, we sample only some of its newly identiﬁed error behaviors for illustration purposes.
For more complete performance information across all 60 selected kernel bugs, the readers could ﬁnd at [26]. In the “Time”
column, T1 represents the number of hours Syzkaller took, T2 is for Syzkaller’s variant, T3 is for GREBE without optimization,
and T4 stands for GREBE. The dash “-” means the corresponding error behavior is not discovered by the corresponding tool.
kernel structures, and  focusing on less popular structures
can still allow our fuzzer to reach out to popular structures
because of the strong dependence between them. In Table II,
we list some kernel object types that GREBE uses for fuzzing
guidance. For more complete kernel object types identiﬁed for
each kernel bug, readers could ﬁnd them at [26].
Efﬁciency. Table II and the table at [26] show the time that
each fuzzer spent on ﬁnding a new kernel error behavior.
First, we observe that both Syzkaller and its variant have
comparable efﬁciency (21546 hours vs 21528 hours). How-
ever, GREBE without mutation optimization spends less time
than Syzkaller on identifying the new error behavior (15011
vs. 21546 hours)4. After applying the mutation optimization,
GREBE further reduces the time spent on new error behavior
identiﬁcation (5445 vs. 15011 hours). This discovery indicates
mutation optimization alone provides minimum beneﬁts to
the improvement of fuzzing efﬁciency whereas object-driven
component alone or the combination of both brings signiﬁcant
improvement in fuzzing efﬁciency.
Second, we observe that GREBE succeeds in disclosing 79
new error behaviors for 32 test cases within 24 hours. Take
the case #5d3cce3 in Table II as an example. GREBE found the
use-after-free read error in netif_napi_add in 9 hours. On the
contrary, GREBE without mutation optimization spent more
than 3 days. The original Syzkaller and its variant performed
even worse, failing to ﬁnd this error behavior within the 7-day
time window. This result empirically shows that the design of
SYZ ID
d1baeb1 [27]
8eceaff [29]
bb7fa48 [31]
d767177 [33]
460cc94 [34]
0df4c1a [35]
229e0b7 [25]
163388d [38]
bdeea91 [23]
b9b37a7 [41]
0d93140 [43]
b0e30ab [45]
d5222b3 [47]
3a6c997 [49]
cbb2898 [51]
e4be308 [53]
3b7409f [54]
Exploitability Change
LL → L (2) (cid:63)
LL → L (2) (cid:63)
LL → L (1)
LL → L (2)
LL → L (1)
LL → L (3)
LL → L (3)
LL → L (1)
LL → L (1)
LL → L (4)
LL → L (1)
LL → L (1)
LL → L (1)
L → L (10)
L → L (1)
L → L (11)
L → L (1)
SYZ ID
de28cb0 [28]
f56bbe6 [30]
f0ec9a3 [32]
5d3cce3 [8]
692a8c2 [12]
4cf5ee7 [36]
502c872 [37]
b36d7e4 [39]
1fd1d44 [40]
695527b [42]
85fd017 [44]
6a03985 [46]
575a090 [48]
27ae1ae [50]
4bf11aa [52]
7022420 [11]
ddaf58b [55]
Exploitability Change
LL → L (5)
LL → L (1)
LL → L (1)
LL → L (2) (cid:63)
LL → L (12) (cid:63)
LL → L (2)
LL → L (1)
LL → L (1)
LL → L (1)
LL → L (1)
LL → L (4) (cid:63)
LL → L (3) (cid:63)
LL → L (1)
L → L (1)
L → L (1)
L → L (1)
L → L (2)
TABLE III: The summary of exploitation potential improve-
ment. In the column of ”Exploitability Change”, LL means
the original error behavior is less likely to be exploitable.
The letter L means the newly discovered error behaviors
are likely to be exploitable. The number in the parenthesis
represents the amount of newly identiﬁed error behaviors tied
to probably exploitable. The star (cid:63) denotes the bugs for which
we have developed exploits based on the newly discovered
error behaviors and their provided primitives.
object-driven fuzzing and mutation optimization in GREBE,
to a large extent, can save the time and resources for the
discovery of new error behaviors.
4Since the new error behaviors discovered by Syzkaller and its variant is too
few compared with the other fuzzers, we conservatively use 7 days (7×24=168
hours) to represent the non-discovered error behaviors when computing the
time.
C. Security Implication
Exploitation Potential Exploration. Recall that we design
GREBE to explore a kernel bug’s multiple error behaviors.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2088
Exploitation Potential
Kernel Bug Errors
Likely to exploit
Less likely to exploit
KASAN (e.g., use-after-free,
out-of-bound access, double-free)
BUG, GPF, NULL ptr dereference,
panic, WARN, wrappers (e.g., pr err)
TABLE IV: The summary of the types of error behaviors in
bug reports and their corresponding exploitation potential.
With the multiple manifested behaviors in hand, we expect
some newly exposed error behaviors to indicate a higher
exploitation potential for a kernel bug (e.g., ﬁnding an out-
of-bound write error behavior for a kernel bug that orig-
inally manifests less-likely-to-exploit error behavior – null
pointer dereference). As a result, we further evaluate GREBE’s
capability in exploitation potential exploration. To do this,
we ﬁrst recruited 20+ security researchers and conducted a
user study (detailed in Appendix A) under the approved IRB
(STUDY00008566). From the user-study results, we obtain
the relationship between a manifested error behavior and the
exploitation potential. As is depicted in Table IV, each error
behavior is categorized into either “likely to exploit” or “less
likely to exploit”. Using this error-behavior-to-exploitability
mapping obtained from security researchers, we then compare
our newly identiﬁed error behaviors with those speciﬁed in
their original bug reports.
In our dataset, we have 60 Linux kernel bugs. For 44 bugs,
their reports gathered from Syzbot demonstrate error behaviors
associated with less-likely-to-exploit. For the other 16 kernel
bugs, their reports expose errors tied to likely-to-exploit. As we
can observe from Table III, for 26 bugs (about 60% of 44 less-
likely-to-exploit bugs), GREBE could ﬁnd at least one likely-
to-exploit error behavior. From that newly identiﬁed error
behavior, one could imply a higher exploitation potential. This
observation indicates that GREBE can help security researchers
better infer kernel bugs’ exploitation potential.
Among the rest 16 kernel bugs originally tied to likely-
to-exploit, there are 8 bugs (50%). By using GREBE, one
can identify their other likely-to-exploit error behaviors. We
argue, this does not mean that GREBE has no utility for these
kernel bugs. Taking a closer look at the three cases #e4be308
(cid:44)→ , #3b7409f, and #ddaf58b. Their original reports all indicate
that the bug provides an ability to perform a write to an
unauthorized memory region. However, the newly discovered
error behaviors enable the adversaries to perform unauthorized
read/write at different memory regions. Take the case #3619dec5
(cid:44)→ for example. Its new error behavior can write data to the
kmalloc-64 from 56th to 60th bytes, whereas its error behavior
shown in the report corrupts the ﬁrst eight bytes of kmalloc-64.
This enlarged memory access potentially diversiﬁes the way
to perform exploitation and bypass mitigation.
For the kernel bugs of our selection that do not show
exploitation potential improvement (i.e., 26 bugs = 60-26-8),
we argue that this does not dilute the contribution of GREBE.
First, based on the aforementioned small-scale evaluation on
the false negatives of GREBE, it is very likely that all the
possible error behaviors of these bugs are exposed. In this
situation, there are fewer chances for a security researcher to
ﬁnd unknown error behaviors indicating a higher exploitation
potential. Second, although the exploitation potential remains
unchanged, GREBE manages to ﬁnd many other error behav-
iors (e.g., #1fd1d44 in the table at [26]). These additional error
behaviors and the corresponding fuzzing programs can poten-
tially facilitate the root cause diagnosis, as is demonstrated
in [7].
Real-world impact. For all the 44 kernel bugs (the original
reports of which implies less-likely-to-exploit), we performed
an exhaustive search and found no work demonstrating their
exploitability in the past. As described above, using GREBE,
we can turn 26 of them from less-likely-to-exploit to likely-
to-exploit. For these 26 kernel bugs, we further explore their
exploitability manually. We surprisingly discovered that 6 out
of the 26 bugs (illustrated by a star sign in Table III) could
be turned into fully exploitable kernel vulnerabilities. Take
the case #6a03985 as an example. Its error behavior initially
reported by Syzkaller is a WARNING implying less-likely-to-
exploit. Using GREBE, we identiﬁed a use-after-free error
behavior for this bug. Starting from this newly discovered error
behavior and the primitive the error behavior provides, we
successfully demonstrated the bug’s exploitability, including
leaking sensitive data (e.g., encryption key and hashed pass-
word), bypassing KASLR, and redirecting the kernel execution
for privilege escalation. Recently, we have shared our working
exploits with the corresponding vendors. Because the bug’s
original report
implies less-likely-to-exploit, many vendors
defer or completely ignore the adoption of the patch. Upon
receiving our exploitation demonstration, they conﬁrmed our
ﬁndings, took immediate action to apply patches, and assigned
us with CVE IDs. In [56], we release one of our exploits
temporarily only for the paper review. We will publicly release
all 6 exploits (tied to the cases #d1baeb1, #6a03985, #5d3cce3,
#8eceaf, #85fd017 and #692a8c2) after the paper is accepted.
VII. RELATED WORK
This section summarizes the works most relevant to ours.
Kernel fuzzing. Syzkaller [4] and Trinity [6] are two popular
code-coverage-based kernel fuzzers. While doing fuzzing, they
use templates to specify the dependency between system calls
and the expected value range of system calls’ arguments. How-
ever, with only explicit dependencies between system calls,
it is not enough to produce a high-quality fuzzing program
because the OS kernel is a massive system with a complicated
internal state transition. IMF [57] optimizes kernel fuzzing by
tracking the system calls and analyzing them coordinately with
type information to infer the kernel system’s internal states.
This approach, unfortunately, has the limitation of extracting
internal dependencies inside the kernel. As such, taking a step
ahead, Moonshine [17] leverages light-weight static analysis
to detect internal dependencies across different system calls
from system call
traces of real-world programs. Recently,
HFL [18] introduces hybrid fuzzing to the kernel, performing
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2089
point-to analysis, and symbolic checking to ﬁgure out precise
constraints between system state variables. To support closed-
source kernel, instead of relying on the kernel interface to
collect code coverage, kAFL [5] proposes a fuzzing framework
that employs a hardware-assisted code coverage measurement.