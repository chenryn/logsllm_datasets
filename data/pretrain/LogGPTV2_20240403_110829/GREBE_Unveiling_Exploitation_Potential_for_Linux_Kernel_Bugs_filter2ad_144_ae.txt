### 优化后的文本

#### 警告：crypto destroy tfm 中的引用计数错误
- KASAN: use-after-free 读取在 crypto alg extsize
- KASAN: use-after-free 读取在 free netdev
- KASAN: use-after-free 读取在 netif napi add
- KASAN: use-after-free 读取在 release sock
- KASAN: use-after-free 读取在 nr release
- KASAN: use-after-free 读取在 nr insert socket
- KASAN: use-after-free 写入在 nr insert socket
- KASAN: use-after-free 读取在 lock sock nested
- KASAN: use-after-free 读取在 delayed uprobe remove
- KASAN: use-after-free 读取在 uprobe mmap
- general protection fault 在 uprobe mmap
- KASAN: use-after-free 读取在 update ref ctr

#### 表 II：Syzkaller、Syzkaller 变体、GREBE 和无变异优化的 GREBE 在一些采样的内核错误下的性能
- “SYZ ID” 列是案例 ID。
- “识别的关键结构” 列表示通过静态分析工具识别并由 GREBE 使用的结构。
- “初始错误行为” 列表示在相应的错误报告中表现的错误行为。
- “发现的新错误行为” 列是新发现的错误行为。注意，对于每个案例，我们仅采样部分新识别的错误行为以供说明。

#### 性能
表 II 和 [26] 中的表格显示了每个 fuzzer 用于发现新的内核错误行为的时间。
1. 我们观察到 Syzkaller 及其变体具有相当的效率（21546 小时 vs 21528 小时）。
2. 然而，无变异优化的 GREBE 在识别新的错误行为上花费的时间少于 Syzkaller（15011 小时 vs 21546 小时）。应用变异优化后，GREBE 进一步减少了发现新错误行为所需的时间（5445 小时 vs 15011 小时）。这表明，单独使用变异优化对模糊测试效率的提升有限，而对象驱动组件或两者的结合可以显著提高模糊测试效率。

#### 效率
1. GREBE 在 24 小时内成功披露了 32 个测试用例中的 79 种新错误行为。例如，在表 II 的案例 #5d3cce3 中，GREBE 在 9 小时内发现了 netif_napi_add 中的 use-after-free 读取错误。相比之下，无变异优化的 GREBE 花费了超过 3 天时间。原始的 Syzkaller 及其变体在 7 天的时间窗口内未能找到此错误行为。
2. 这一结果实证地表明，GREBE 的设计在节省时间和资源方面具有显著优势。

#### 安全影响
**利用潜力探索**
- 我们设计 GREBE 以探索内核错误的多种错误行为。
- 通过用户研究（详细见附录 A），我们获得了错误行为与利用潜力之间的关系。如表 IV 所示，每种错误行为被归类为“可能被利用”或“不太可能被利用”。
- 在我们的数据集中，有 60 个 Linux 内核错误。其中 44 个错误的行为与不太可能被利用相关，另外 16 个错误的行为与可能被利用相关。
- 对于 26 个错误（约占 44 个不太可能被利用的错误的 60%），GREBE 至少找到了一个可能被利用的错误行为，从而提高了这些错误的利用潜力。

**实际影响**
- 对于所有 44 个最初被认为不太可能被利用的内核错误，我们进行了详尽搜索，未发现过去有任何工作证明它们的可利用性。
- 使用 GREBE，我们将其中 26 个错误从不太可能被利用转变为可能被利用。进一步手动探索这些错误的可利用性，我们惊讶地发现其中 6 个错误可以转化为完全可利用的内核漏洞。
- 例如，在案例 #6a03985 中，Syzkaller 最初报告的错误行为是一个 WARNING，暗示不太可能被利用。使用 GREBE，我们发现了该错误的 use-after-free 错误行为，并成功展示了该错误的可利用性，包括泄露敏感数据（如加密密钥和哈希密码）、绕过 KASLR 以及重定向内核执行以进行权限提升。

#### 相关工作
**内核模糊测试**
- Syzkaller [4] 和 Trinity [6] 是两个流行的基于代码覆盖率的内核模糊测试工具。
- IMF [57] 通过跟踪系统调用并结合类型信息推断内核系统的内部状态来优化内核模糊测试。
- Moonshine [17] 利用轻量级静态分析从真实程序的系统调用跟踪中检测不同系统调用之间的内部依赖关系。
- HFL [18] 引入混合模糊测试到内核中，执行指针分析和符号检查以确定系统状态变量之间的精确约束。
- kAFL [5] 提出了一种模糊测试框架，利用硬件辅助的代码覆盖率测量支持闭源内核。

---

希望这个优化后的文本更加清晰、连贯和专业。如果有任何进一步的修改需求，请告诉我！