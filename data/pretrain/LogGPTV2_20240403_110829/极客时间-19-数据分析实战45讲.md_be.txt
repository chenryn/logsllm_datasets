## 总结Apriori算法的核心就是理解频繁项集和关联规则。在算法运算的过程中，还要重点掌握对支持度、置信度和提升度的理解。在工具使用上，你可以使用efficient-apriori这个工具包，它会把每一条数据中的项（item）放到一个集合（篮子）里来处理，不考虑项（item）之间的先后顺序。在实际运用中你还需要灵活处理，比如导演如何选择演员这个案例，虽然工具的使用会很方便，但重要的还是数据挖掘前的准备过程，也就是获取某个导演的电影数据集。![](Images/7181fcd7122281e39ecc60b3247400be.png){savepage-src="https://static001.geekbang.org/resource/image/28/9d/282c25e8651b3e0b675be7267d13629d.png"}\最后给你留两道思考题吧。请你编写代码挖掘下张艺谋导演使用演员的频繁项集和关联规则，最小支持度可以设置为0.1 或 0.05。另外你认为 Apriori算法中的最小支持度和最小置信度，一般设置为多少比较合理？欢迎你在评论区与我分享你的答案，也欢迎点击"请朋友读"，把这篇文章分享给你的朋友或者同事。![](Images/8b75105190797b2e4f7be2536b6543db.png){savepage-src="https://static001.geekbang.org/resource/image/48/96/48cb89aa8c4858bbc18df3b3ac414496.jpg"}
# 32丨PageRank（上）：搞懂Google的PageRank算法互联网发展到现在，搜索引擎已经非常好用，基本上输入关键词，都能找到匹配的内容，质量还不错。但在1998年之前，搜索引擎的体验并不好。早期的搜索引擎，会遇到下面的两类问题：1.  返回结果质量不高：搜索结果不考虑网页的质量，而是通过时间顺序进行检索；2.  容易被人钻空子：搜索引擎是基于检索词进行检索的，页面中检索词出现的频次越高，匹配度越高，这样就会出现网页作弊的情况。有些网页为了增加搜索引擎的排名，故意增加某个检索词的频率。基于这些缺陷，当时 Google 的创始人拉里·佩奇提出了 PageRank算法，目的就是要找到优质的网页，这样 Google的排序结果不仅能找到用户想要的内容，而且还会从众多网页中筛选出权重高的呈现给用户。Google 的两位创始人都是斯坦福大学的博士生，他们提出的 PageRank算法受到了论文影响力因子的评价启发。当一篇论文被引用的次数越多，证明这篇论文的影响力越大。正是这个想法解决了当时网页检索质量不高的问题。
## PageRank 的简化模型我们先来看下 PageRank 是如何计算的。我假设一共有 4 个网页 A、B、C、D。它们之间的链接信息如图所示：![](Images/bc0f7e7caafd918d9389f61366a622a8.png){savepage-src="https://static001.geekbang.org/resource/image/81/36/814d53ff8d73113631482e71b7c53636.png"}\这里有两个概念你需要了解一下。出链指的是链接出去的链接。入链指的是链接进来的链接。比如图中 A 有 2个入链，3 个出链。``{=html}简单来说，一个网页的影响力 =所有入链集合的页面的加权影响力之和，用公式表示为：![](Images/9bc23545c4252f5a0c3000fe89f9616e.png){savepage-src="https://static001.geekbang.org/resource/image/70/0c/70104ab44fa1d9d690f99dc328d8af0c.png"}\u 为待评估的页面，[]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[B]{#33.html#MathJax-Span-4.mistyle="font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.155em, 1000.75em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[u]{#33.html#MathJax-Span-7.mistyle="font-size: 70.7%; font-family: MathJax_Math-italic;"}]{#33.html#MathJax-Span-6.mrow}]{#33.html#MathJax-Span-5.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -3.856em; left: 0.755em;"}]{style="display: inline-block; position: relative; width: 1.226em; height: 0px;"}]{#33.html#MathJax-Span-3.msubsup}]{#33.html#MathJax-Span-2.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.461em, 1001.23em, 2.591em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 1.226em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.232em; border-left: 0px solid; width: 0px; height: 1.179em;"}]{#33.html#MathJax-Span-1.mathstyle="width: 1.555em; display: inline-block;"}``{=html}[$B_{u}$]{.MJX_Assistive_MathMLrole="presentation"}]{#33.html#MathJax-Element-1-Frame .MathJaxtabindex="0" style="position: relative;"mathml="Bu"role="presentation"}$$ 为页面 u 的入链集合。针对入链集合中的任意页面v，它能给 u 带来的影响力是其自身的影响力 PR(v) 除以 v页面的出链数量，即页面 v 把影响力 PR(v)平均分配给了它的出链，这样统计所有能给 u 带来链接的页面v，得到的总和就是网页 u 的影响力，即为 PR(u)。所以你能看到，出链会给被链接的页面赋予影响力，当我们统计了一个网页链出去的数量，也就是统计了这个网页的跳转概率。在这个例子中，你能看到 A 有三个出链分别链接到了 B、C、D上。那么当用户访问 A 的时候，就有跳转到 B、C 或者 D的可能性，跳转概率均为 1/3。B 有两个出链，链接到了 A 和 D 上，跳转概率为 1/2。这样，我们可以得到 A、B、C、D 这四个网页的转移矩阵 M：![](Images/676e14392432f72881f4c2a1e3210e8d.png){savepage-src="https://static001.geekbang.org/resource/image/20/d4/204b0934f166d6945a90185aa2c95dd4.png"}\我们假设 A、B、C、D 四个页面的初始影响力都是相同的，即：![](Images/c85f135d247ccc733514b7bc91f48086.png){savepage-src="https://static001.geekbang.org/resource/image/a8/b8/a8eb12b5242e082b5d2281300c326bb8.png"}\当进行第一次转移之后，各页面的影响力 []{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[w]{#33.html#MathJax-Span-11.mistyle="font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.438em, 1000.71em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[1]{#33.html#MathJax-Span-14.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#33.html#MathJax-Span-13.mrow}]{#33.html#MathJax-Span-12.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -3.856em; left: 0.708em;"}]{style="display: inline-block; position: relative; width: 1.132em; height: 0px;"}]{#33.html#MathJax-Span-10.msubsup}]{#33.html#MathJax-Span-9.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.744em, 1001.13em, 2.591em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 1.132em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.232em; border-left: 0px solid; width: 0px; height: 0.885em;"}]{#33.html#MathJax-Span-8.mathstyle="width: 1.414em; display: inline-block;"}``{=html}[$w_{1}$]{.MJX_Assistive_MathMLrole="presentation"}]{#33.html#MathJax-Element-2-Frame .MathJaxtabindex="0" style="position: relative;"mathml="w1"role="presentation"}$$ 变为：![](Images/84718278667a5f6cabb54b9985d6904f.png){savepage-src="https://static001.geekbang.org/resource/image/fc/8c/fcbcdd8e96384f855b4f7c842627ff8c.png"}\然后我们再用转移矩阵乘以 []{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[w]{#33.html#MathJax-Span-18.mistyle="font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.438em, 1000.71em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[1]{#33.html#MathJax-Span-21.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#33.html#MathJax-Span-20.mrow}]{#33.html#MathJax-Span-19.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -3.856em; left: 0.708em;"}]{style="display: inline-block; position: relative; width: 1.132em; height: 0px;"}]{#33.html#MathJax-Span-17.msubsup}]{#33.html#MathJax-Span-16.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.744em, 1001.13em, 2.591em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 1.132em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.232em; border-left: 0px solid; width: 0px; height: 0.885em;"}]{#33.html#MathJax-Span-15.mathstyle="width: 1.414em; display: inline-block;"}``{=html}[$w_{1}$]{.MJX_Assistive_MathMLrole="presentation"}]{#33.html#MathJax-Element-3-Frame .MathJaxtabindex="0" style="position: relative;"mathml="w1"role="presentation"}$$ 得到 []{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[w]{#33.html#MathJax-Span-25.mistyle="font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.438em, 1000.71em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[2]{#33.html#MathJax-Span-28.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#33.html#MathJax-Span-27.mrow}]{#33.html#MathJax-Span-26.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -3.856em; left: 0.708em;"}]{style="display: inline-block; position: relative; width: 1.132em; height: 0px;"}]{#33.html#MathJax-Span-24.msubsup}]{#33.html#MathJax-Span-23.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.744em, 1001.13em, 2.591em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 1.132em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.232em; border-left: 0px solid; width: 0px; height: 0.885em;"}]{#33.html#MathJax-Span-22.mathstyle="width: 1.414em; display: inline-block;"}``{=html}[$w_{2}$]{.MJX_Assistive_MathMLrole="presentation"}]{#33.html#MathJax-Element-4-Frame .MathJaxtabindex="0" style="position: relative;"mathml="w2"role="presentation"}$$ 结果，直到第 n 次迭代后 []{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[w]{#33.html#MathJax-Span-32.mistyle="font-family: MathJax_Math-italic;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.438em, 1000.71em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[n]{#33.html#MathJax-Span-35.mistyle="font-size: 70.7%; font-family: MathJax_Math-italic;"}]{#33.html#MathJax-Span-34.mrow}]{#33.html#MathJax-Span-33.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -3.856em; left: 0.708em;"}]{style="display: inline-block; position: relative; width: 1.226em; height: 0px;"}]{#33.html#MathJax-Span-31.msubsup}]{#33.html#MathJax-Span-30.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.744em, 1001.23em, 2.591em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 1.226em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.232em; border-left: 0px solid; width: 0px; height: 0.885em;"}]{#33.html#MathJax-Span-29.mathstyle="width: 1.555em; display: inline-block;"}``{=html}[$w_{n}$]{.MJX_Assistive_MathMLrole="presentation"}]{#33.html#MathJax-Element-5-Frame .MathJaxtabindex="0" style="position: relative;"mathml="wn"role="presentation"}$$ 影响力不再发生变化，可以收敛到(0.3333，0.2222，0.2222，0.2222），也就是对应着 A、B、C、D四个页面最终平衡状态下的影响力。你能看出 A 页面相比于其他页面来说权重更大，也就是 PR 值更高。而 B、C、D页面的 PR 值相等。至此，我们模拟了一个简化的 PageRank的计算过程，实际情况会比这个复杂，可能会面临两个问题：1\. 等级泄露（RankLeak）：如果一个网页没有出链，就像是一个黑洞一样，吸收了其他网页的影响力而不释放，最终会导致其他网页的PR 值为 0。![](Images/2498eeb792ca2356b90baa52992ea198.png){savepage-src="https://static001.geekbang.org/resource/image/77/62/77336108b0233638a35bfd7450438162.png"}\2. 等级沉没（RankSink）：如果一个网页只有出链，没有入链（如下图所示），计算的过程迭代下来，会导致这个网页的PR 值为 0（也就是不存在公式中的 V）。![](Images/84da0100e2c4bb405f23f57324a18b91.png){savepage-src="https://static001.geekbang.org/resource/image/0d/e6/0d113854fb56116d79efe7f0e0374fe6.png"}\针对等级泄露和等级沉没的情况，我们需要灵活处理。比如针对等级泄露的情况，我们可以把没有出链的节点，先从图中去掉，等计算完所有节点的PR值之后，再加上该节点进行计算。不过这种方法会导致新的等级泄露的节点的产生，所以工作量还是很大的。有没有一种方法，可以同时解决等级泄露和等级沉没这两个问题呢？
## PageRank 的随机浏览模型为了解决简化模型中存在的等级泄露和等级沉没的问题，拉里·佩奇提出了PageRank的随机浏览模型。他假设了这样一个场景：用户并不都是按照跳转链接的方式来上网，还有一种可能是不论当前处于哪个页面，都有概率访问到其他任意的页面，比如说用户就是要直接输入网址访问其他页面，虽然这个概率比较小。所以他定义了阻尼因子d，这个因子代表了用户按照跳转链接来上网的概率，通常可以取一个固定值0.85，而 1-d=0.15则代表了用户不是通过跳转链接的方式来访问网页的，比如直接输入网址。![](Images/110d47ee66210d3a4b2a703d1af7144a.png){savepage-src="https://static001.geekbang.org/resource/image/5f/8f/5f40c980c2f728f12159058ea19a4d8f.png"}\其中 N为网页总数，这样我们又可以重新迭代网页的权重计算了，因为加入了阻尼因子d，一定程度上解决了等级泄露和等级沉没的问题。通过数学定理（这里不进行讲解）也可以证明，最终 PageRank随机浏览模型是可以收敛的，也就是可以得到一个稳定正常的 PR 值。
## PageRank 在社交影响力评估中的应用网页之间会形成一个网络，是我们的互联网，论文之间也存在着相互引用的关系，可以说我们所处的环境就是各种网络的集合。只要是有网络的地方，就存在出链和入链，就会有 PR权重的计算，也就可以运用我们今天讲的 PageRank 算法。我们可以把 PageRank算法延展到社交网络领域中。比如在微博上，如果我们想要计算某个人的影响力，该怎么做呢？一个人的微博粉丝数并不一定等于他的实际影响力。如果按照 PageRank算法，还需要看这些粉丝的质量如何。如果有很多明星或者大 V关注，那么这个人的影响力一定很高。如果粉丝是通过购买僵尸粉得来的，那么即使粉丝数再多，影响力也不高。同样，在工作场景中，比如说脉脉这个社交软件，它计算的就是个人在职场的影响力。如果你的工作关系是李开复、江南春这样的名人，那么你的职场影响力一定会很高。反之，如果你是个学生，在职场上被链入的关系比较少的话，职场影响力就会比较低。同样，如果你想要看一个公司的经营能力，也可以看这家公司都和哪些公司有合作。如果它合作的都是世界500强企业，那么这个公司在行业内一定是领导者，如果这个公司的客户都是小客户，即使数量比较多，业内影响力也不一定大。除非像淘宝一样，有海量的中小客户，最后大客户也会找上门来寻求合作。所以权重高的节点，往往会有一些权重同样很高的节点在进行合作。
## PageRank 给我们带来的启发PageRank 可以说是 Google 搜索引擎重要的技术之一，在 1998 年帮助 Google获得了搜索引擎的领先优势，现在 PageRank已经比原来复杂很多，但它的思想依然能带给我们很多启发。比如，如果你想要自己的媒体影响力有所提高，就尽量要混在大 V圈中；如果想找到高职位的工作，就尽量结识公司高层，或者认识更多的猎头，因为猎头和很多高职位的人员都有链接关系。同样，PageRank也可以帮我们识别链接农场。链接农场指的是网页为了链接而链接，填充了一些没有用的内容。这些页面相互链接或者指向了某一个网页，从而想要得到更高的权重。
## 总结今天我给你讲了 PageRank 的算法原理，对简化的 PageRank模型进行了模拟。针对简化模型中存在的等级泄露和等级沉没这两个问题，PageRank的随机浏览模型引入了阻尼因子 d 来解决。同样，PageRank有很广的应用领域，在许多网络结构中都有应用，比如计算一个人的微博影响力等。它也告诉我们，在社交网络中，链接的质量非常重要。![](Images/ed9a19d760c53b816c361b7ab8325321.png){savepage-src="https://static001.geekbang.org/resource/image/f9/7d/f936296fed70f27ba23064ec14a7e37d.png"}\学完今天的内容，你不妨说说 PageRank的算法原理？另外在现实生活中，除了我在文中举到的几个例子，你还能说一些PageRank 都有哪些应用场景吗？欢迎在评论区与我分享你的答案，也欢迎点击"请朋友读"，把这篇文章分享给你的朋友或者同事。![](Images/8b75105190797b2e4f7be2536b6543db.png){savepage-src="https://static001.geekbang.org/resource/image/48/96/48cb89aa8c4858bbc18df3b3ac414496.jpg"}
# 33丨PageRank（下）：分析希拉里邮件中的人物关系上节课我们讲到 PageRank算法经常被用到网络关系的分析中，比如在社交网络中计算个人的影响力，计算论文的影响力或者网站的影响力等。今天我们就来做一个关于 PageRank算法的实战，在这之前，你需要思考三个问题：1.  如何使用工具完成 PageRank    算法，包括使用工具创建网络图，设置节点、边、权重等，并通过创建好的网络图计算节点的    PR 值；2.  对于一个实际的项目，比如希拉里的 9306    封邮件（工具包中邮件的数量），如何使用 PageRank    算法挖掘出有影响力的节点，并且绘制网络图；3.  如何对创建好的网络图进行可视化，如果网络中的节点数较多，如何筛选重要的节点进行可视化，从而得到精简的网络关系图。
## 如何使用工具实现 PageRank 算法PageRank 算法工具在 sklearn中并不存在，我们需要找到新的工具包。实际上有一个关于图论和网络建模的工具叫NetworkX，它是用 Python语言开发的工具，内置了常用的图与网络分析算法，可以方便我们进行网络数据分析。上节课，我举了一个网页权重的例子，假设一共有 4 个网页A、B、C、D，它们之间的链接信息如图所示：![](Images/1bf474630776bd0b37ee7785d591c727.png){savepage-src="https://static001.geekbang.org/resource/image/47/ea/47e5f21d16b15a98d4a32a73ebd477ea.png"}\针对这个例子，我们看下用 NetworkX 如何计算 A、B、C、D 四个网页的 PR值，具体代码如下：``{=html}    import networkx as nx
# 创建有向图G = nx.DiGraph() 