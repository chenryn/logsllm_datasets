Lastly, we’ll demonstrate how to multiplex command-and-
control (C2) connections by building a reverse HTTP proxy.
Chapter 5: Exploiting DNS
This chapter introduces you to basic DNS concepts using Go.
First, we’ll perform client operations, including how to look
for particular domain records. Then we’ll show you how to
write a custom DNS server and DNS proxy, both of which are
useful for C2 operations.
Chapter 6: Interacting with SMB and NTLM
We’ll explore the SMB and NTLM protocols, using them as a
basis for a discussion of protocol implementations in Go.
Using a partial implementation of the SMB protocol, we’ll
discuss the marshaling and unmarshaling of data, the usage of
custom field tags, and more. We’ll discuss and demonstrate
how to use this implementation to retrieve the SMB-signing
policy, as well as perform password-guessing attacks.
Chapter 7: Abusing Databases and Filesystems
Pillaging data is a critical aspect of adversarial testing. Data
lives in numerous resources, including databases and
filesystems. This chapter introduces basic ways to connect to
and interact with databases across a variety of common SQL
and NoSQL platforms. You’ll learn the basics of connecting to
SQL databases and running queries. We’ll show you how to
search databases and tables for sensitive information, a
common technique used during post-exploitation. We’ll also
show how to walk filesystems and inspect files for sensitive
information.
Chapter 8: Raw Packet Processing
We’ll show you how to sniff and process network packets by
using the gopacket library, which uses libpcap. You’ll learn how to
identify available network devices, use packet filters, and
process those packets. We will then develop a port scanner
that can scan reliably through various protection mechanisms,
including syn-flood and syn-cookies, which cause normal port
scans to show excessive false positives.
Chapter 9: Writing and Porting Exploit Code
This chapter focuses almost solely on creating exploits. It
begins with creating a fuzzer to discover different types of
vulnerabilities. The second half of the chapter discusses how
to port existing exploits to Go from other languages. This
discussion includes a port of a Java deserialization exploit and
the Dirty COW privilege escalation exploit. We conclude the
chapter with a discussion on creating and transforming
shellcode for use within your Go programs.
Chapter 10: Go Plugins and Extendable Tools
We’ll introduce two separate methods for creating extendable
tools. The first method, introduced in Go version 1.8, uses
Go’s native plug-in mechanism. We’ll discuss the use cases
for this approach and discuss a second approach that leverages
Lua to create extensible tools. We’ll demonstrate practical
examples showing how to adopt either approach to perform a
common security task.
Chapter 11: Implementing and Attacking
Cryptography
This chapter covers the fundamental concepts of symmetric
and asymmetric cryptography using Go. This information
focuses on using and understanding cryptography through the
standard Go package. Go is one of the few languages that,
instead of using a third-party library for encryption, uses a
native implementation within the language. This makes the
code easy to navigate, modify, and understand.
We’ll explore the standard library by examining common
use cases and creating tools. The chapter will show you how to
perform hashing, message authentication, and encryption.
Lastly, we’ll demonstrate how to brute-force decrypt an RC2-
encrypted ciphertext.
Chapter 12: Windows System Interaction and
Analysis
In our discussion on attacking Windows, we’ll demonstrate
methods of interacting with the Windows native API, explore
the syscall package in order to perform process injection, and
learn how to build a Portable Executable (PE) binary parser.
The chapter will conclude with a discussion of calling native C
libraries through Go’s C interoperability mechanisms.
Chapter 13: Hiding Data with Steganography
Steganography is the concealment of a message or file within
another file. This chapter introduces one variation of
steganography: hiding arbitrary data within a PNG image
file’s contents. These techniques can be useful for exfiltrating
information, creating obfuscated C2 messages, and bypassing
detective or preventative controls.
Chapter 14: Building a Command-and-Control RAT
The final chapter discusses practical implementations of
command-and-control (C2) implants and servers in Go. We’ll
leverage the wisdom and knowledge gained in previous
chapters to build a C2 channel. The C2 client/server
implementation will, by nature of being custom-made, avoid
signature-based security controls and attempt to circumvent
heuristics and network-based egress controls.
1
GO FUNDAMENTALS
This chapter will guide you through the process of setting up
your Go development environment and introduce you to the
language’s syntax. People have written entire books on the
fundamental mechanics of the language; this chapter covers
the most basic concepts you’ll need in order to work through
the code examples in the following chapters. We’ll cover
everything from primitive data types to implementing
concurrency. For readers who are already well versed in the
language, you’ll find much of this chapter to be a review.
SETTING UP A DEVELOPMENT
ENVIRONMENT
To get started with Go, you’ll need a functional development
environment. In this section, we’ll walk you through the steps
to download Go and set up your workspace and environment
variables. We’ll discuss various options for your integrated
development environment and some of the standard tooling
that comes with Go.
Downloading and Installing Go
Start by downloading the Go binary release most appropriate
to your operating system and architecture from
https://golang.org/dl/. Binaries exist for Windows, Linux, and
macOS. If you’re using a system that doesn’t have an available
precompiled binary, you can download the Go source code
from that link.
Execute the binary and follow the prompts, which will be
minimal, in order to install the entire set of Go core packages.
Packages, called libraries in most other languages, contain
useful code you can use in your Go programs.
Setting GOROOT to Define the Go Binary Location
Next, the operating system needs to know how to find the Go
installation. In most instances, if you’ve installed Go in the
default path, such as /usr/local/go on a *Nix/BSD-based
system, you don’t have to take any action here. However, in
the event that you’ve chosen to install Go in a nonstandard
path or are installing Go on Windows, you’ll need to tell the
operating system where to find the Go binary.
You can do this from your command line by setting the
reserved GOROOT environment variable to the location of your
binary. Setting environment variables is operating-system
specific. On Linux or macOS, you can add this to your
~/.profile:
set GOROOT=/path/to/go
On Windows, you can add this environment variable
through the System (Control Panel), by clicking the
Environment Variables button.
Setting GOPATH to Determine the Location of Your
Go Workspace
Unlike setting your GOROOT, which is necessary in only certain
installation scenarios, you must always define an environment
variable named GOPATH to instruct the Go toolset where your
source code, third-party libraries, and compiled programs will
exist. This can be any location of your choosing. Once you’ve
chosen or created this base workspace directory, create the
following three subdirectories within: bin, pkg, and src (more
on these directories shortly). Then, set an environment
variable named GOPATH that points to your base workspace
directory. For example, if you want to place your projects in a
directory called gocode located within your home directory on
Linux, you set GOPATH to the following:
GOPATH=$HOME/gocode
The bin directory will contain your compiled and installed
Go executable binaries. Binaries that are built and installed
will be automatically placed into this location. The pkg
directory stores various package objects, including third-party
Go dependencies that your code might rely on. For example,
perhaps you want to use another developer’s code that more
elegantly handles HTTP routing. The pkg directory will
contain the binary artifacts necessary to consume their
implementation in your code. Finally, the src directory will
contain all the evil source code you’ll write.
The location of your workspace is arbitrary, but the
directories within must match this naming convention and
structure. The compilation, build, and package management
commands you’ll learn about later in this chapter all rely on
this common directory structure. Without this important setup,
Go projects won’t compile or be able to locate any of their
necessary dependencies!
After configuring the necessary GOROOT and GOPATH
environment variables, confirm that they’re properly set. You
can do this on Linux and Windows via the set command. Also,
check that your system can locate the binary and that you’ve
installed the expected Go version with the go version command:
$ go version
go version go1.11.5 linux/amd64
This command should return the version of the binary you
installed.
Choosing an Integrated Development Environment
Next, you’ll probably want to select an integrated development
environment (IDE) in which to write your code. Although an
IDE isn’t required, many have features that help reduce errors
in your code, add version-control shortcuts, aid in package
management, and more. As Go is still a fairly young language,
there may not be as many mature IDEs as for other languages.
Fortunately, advancements over the last few years leave
you with several, full-featured options. We’ll review some of
them in this chapter. For a more complete list of IDE or editor
options, check out the Go wiki page at
https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins/
. This book is IDE/editor agnostic, meaning we won’t force
you into any one solution.
Vim Editor
The Vim text editor, available in many operating-system
distributions, provides a versatile, extensible, and completely
open source development environment. One appealing feature
of Vim is that it lets users run everything from their terminal
without fancy GUIs getting in the way.
Vim contains a vast ecosystem of plug-ins through which
you can customize themes, add version control, define
snippets, add layout and code-navigation features, include
autocomplete, perform syntax highlighting and linting, and
much, much more. Vim’s most common plug-in management
systems include Vundle and Pathogen.
To use Vim for Go, install the vim-go plug-in
(https://github.com/fatih/vim-go/) shown in Figure 1-1.
Figure 1-1: The vim-go plug-in
Of course, to use Vim for Go development, you’ll have to
become comfortable with Vim. Further, customizing your
development environment with all the features you desire
might be a frustrating process. If you use Vim, which is free,
you’ll likely need to sacrifice some of the conveniences of
commercial IDEs.
GitHub Atom
GitHub’s IDE, called Atom (https://atom.io/), is a hackable
text editor with a large offering of community-driven
packages. Unlike Vim, Atom provides a dedicated IDE
application rather than an in-terminal solution, as shown in
Figure 1-2.
Figure 1-2: Atom with Go support
Like Vim, Atom is free. It provides tiling, package
management, version control, debugging, autocomplete, and a
myriad of additional features out of the box or through the use
of the go-plus plug-in, which provides dedicated Go support
(https://atom.io/packages/go-plus/).
Microsoft Visual Studio Code
Microsoft’s Visual Studio Code, or VS Code
(https://code.visualstudio.com), is arguably one of the most
feature-rich and easiest IDE applications to configure. VS
Code, shown in Figure 1-3, is completely open source and
distributed under an MIT license.
Figure 1-3: The VS Code IDE with Go support
VS Code supports a diverse set of extensions for themes,
versioning, code completion, debugging, linting, and
formatting. You can get Go integration with the vscode-go
extension (https://github.com/Microsoft/vscode-go/).
JetBrains GoLand
The JetBrains collection of development tools are efficient and
feature-rich, making both professional development and
hobbyist projects easy to accomplish. Figure 1-4 shows what
the JetBrains GoLand IDE looks like.
GoLand is the JetBrains commercial IDE dedicated to the
Go language. Pricing for GoLand ranges from free for
students, to $89 annually for individuals, to $199 annually for
organizations. GoLand offers all the expected features of a
rich IDE, including debugging, code completion, version
control, linting, formatting, and more. Although paying for a
product may not sound appealing, commercial products such
as GoLand typically have official support, documentation,
timely bug fixes, and some of the other assurances that come
with enterprise software.
Figure 1-4: The GoLand commercial IDE
Using Common Go Tool Commands
Go ships with several useful commands that simplify the
development process. The commands themselves are
commonly included in IDEs, making the tooling consistent
across development environments. Let’s take a look at some of
these commands.
The go run Command
One of the more common commands you’ll execute during
development, go run will compile and execute the main package
—your program’s entry point.
As an example, save the following code under a project
directory within $GOPATH/src (remember, you created this
workspace during installation) as main.go:
package main
import (
"fmt"
)
func main() {
fmt.Println("Hello, Black Hat Gophers!")
}
From the command line, within the directory containing
this file, execute go run main.go. You should see Hello, Black Hat
Gophers! printed to your screen.
The go build Command
Note that go run executed your file, but it didn’t produce a
standalone binary file. That’s where go build comes in. The go
build command compiles your application, including any
packages and their dependencies, without installing the results.
It creates a binary file on disk but doesn’t execute your
program. The files it creates follow reasonable naming
conventions, but it’s not uncommon to change the name of the
created binary file by using the -o output command line option.
Rename main.go from the previous example to hello.go. In
a terminal window, execute go build hello.go. If everything goes
as intended, this command should create an executable file
with the name hello. Now enter this command:
$ ./hello
Hello, Black Hat Gophers!
This should run the standalone binary file.
By default, the produced binary file contains debugging
information and the symbol table. This can bloat the size of
the file. To reduce the file size, you can include additional
flags during the build process to strip this information from the
binary. For example, the following command will reduce the
binary size by approximately 30 percent:
$ go build -ldflags "-w -s"
Having a smaller binary will make it more efficient to
transfer or embed while pursuing your nefarious endeavors.
Cross-Compiling
Using go build works great for running a binary on your current
system or one of identical architecture, but what if you want to
create a binary that can run on a different architecture? That’s
where cross-compiling comes in. Cross-compiling is one of
the coolest aspects of Go, as no other language can do it as
easily. The build command allows you to cross-compile your
program for multiple operating systems and architectures.
Reference the official Go documentation at
https://golang.org/doc/install/source#environment/ for further
details regarding allowable combinations of compatible
operating system and architecture compilation types.
To cross-compile, you need to set a constraint. This is just
a means to pass information to the build command about the
operating system and architecture for which you’d like to
compile your code. These constraints include GOOS (for the
operating system) and GOARCH (for the architecture).
You can introduce build constraints in three ways: via the
command line, code comments, or a file suffix naming
convention. We’ll discuss the command line method here and
leave the other two methods for you to research if you wish.
Let’s suppose that you want to cross-compile your previous
hello.go program residing on a macOS system so that it runs
on a Linux 64-bit architecture. You can accomplish this via the
command line by setting the GOOS and GOARCH constraints
when running the build command:
$ GOOS="linux" GOARCH="amd64" go build hello.go
$ ls
hello hello.go
$ file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not
stripped
The output confirms that the resulting binary is a 64-bit
ELF (Linux) file.
The cross-compilation process is much simpler in Go than
in just about any other modern programming language. The
only real “gotcha” happens when you try to cross-compile
applications that use native C bindings. We’ll stay out of the
weeds and let you dig into those challenges independently.
Depending on the packages you import and the projects you
develop, you may not have to worry about that very often.
The go doc Command
The go doc Command
The go doc command lets you interrogate documentation about
a package, function, method, or variable. This documentation
is embedded as comments through your code. Let’s take a look
at how to obtain details about the fmt.Println() function:
$ go doc fmt.Println
func Println(a ...interface{}) (n int, err error)
Println formats using the default formats for its operands and writes to
standard output. Spaces are always added between operands and a newline
is appended. It returns the number of bytes written and any write error
encountered.
The output that go doc produces is taken directly out of the
source code comments. As long as you adequately comment
your packages, functions, methods, and variables, you’ll be
able to automatically inspect the documentation via the go doc
command.
The go get Command
Many of the Go programs that you’ll develop in this book will
require third-party packages. To obtain package source code,
use the go get command. For instance, let’s assume you’ve
written the following code that imports the stacktitan/ldapauth
package:
package main
import (
"fmt"
"net/http"
❶ "github.com/stacktitan/ldapauth"
)
Even though you’ve imported the stacktitan/ldapauth package
❶, you can’t access the package quite yet. You first have to
run the go get command. Using go get github.com/stacktitan/ldapauth
downloads the actual package and places it within the
$GOPATH/src directory.
The following directory tree illustrates the placement of the
ldapauth package within your GOPATH workspace:
$ tree src/github.com/stacktitan/
❶ src/github.com/stacktitan/
└── ldapauth
├── LICENSE
├── README.md
└── ldap_auth.go
Notice that the path ❶ and the imported package name are
constructed in a way that avoids assigning the same name to