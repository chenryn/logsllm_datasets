possible, e.g., due to performance constraints. In the speciﬁc
case of Java, had our evaluation been performed earlier, one
would probably have had the chance to design a more ﬁne
grained policy system in the ﬁrst place, which then in turn
would have allowed all current use cases without having to
opt for implicit privilege elevation.
Properly document
mance.
tradeoffs between security and perfor-
Design and implementation of software is shaped by func-
tional and non-functional requirements. Tradeoffs are often
necessary due to conﬂicting requirements, and security-related
functionality not always has the highest priority. While in
many cases at least functional requirements are documented,
it seems less common to properly document how tradeoffs
shaped the design and implementation of a complex software.
In the speciﬁc case of shortcuts in Java’s access control
mechanisms, we were required to perform manual reviews,
functional tests, and also doublecheck with representatives
from Oracle to verify our assumption that one reason for
which shortcuts were introduced was for performance reasons.
In result, performance-related tradeoffs in long-living systems
should be thoroughly documented, as performance constraints
deﬁnitely change over time and many optimizations become
obsolete eventually.
Revaluate performance tradeoffs in regular intervals.
The very nature of a tradeoff is to balance out a negative
impact with a positive impact of similar or higher value. If
the hoped-for positive impact is improved performance and
ease of use, and the negative impacts are, e.g., an increased
attack surface and decreased maintainability, then this tradeoff
changes as performance gains decrease with optimizations of
1038
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:24:58 UTC from IEEE Xplore.  Restrictions apply. 
the runtime. We thus argue that a revaluation of performance-
related tradeoffs in regular intervals should be part of the
maintenance process of any long-living system.
VIII. RELATED WORK
Aside from Li Gong’s extensive work [2], [15], [27] for the
Java security model, several researchers took up the challenge
to analyze, extend or break the model. We present work that is
concerned with optimizing the access-control process as well
as work that goes beyond this and seeks out for alternatives
to stack-based access control.
Fournet and Gordon [28] provide a complete theoretic
model for stack-based access control. Using this model they
are also able to point out the limitations of stack inspection.
Shortcuts, on the other hand, are not part of the model and
may invalidate the guarantees achieved with it.
Herzog et al.
[29] analyzed the performance of
the
SecurityManager in Java and provide guidance on how
to use it efﬁciently. However, they do not provide any details
on shortcuts.
Several approaches have been developed to optimize Java
stack inspection in order to reduce performance overheads.
Bartoletti et al. [7] present two control-ﬂow analyses that
safely approximate the set of permissions granted or denied
to methods and therefore speed up runtime checks. Koved et
al. [26] extend the precision and applicability of the analysis.
Chang [30] built on their work to make the analyses more
precise using a backward static analysis to compute more
precise information on the performed checks. Likewise, Pistoia
et al. [8] analyze Java bytecode to ﬁnd unnecessary (and
therefore excessive) and redundant (and therefore inefﬁcient)
privileges while ensuring that there are no tainted variables in
the privileged code. This is not only interesting for optimiza-
tion but also helpful in the detection of vulnerabilities.
Other work is more concerned with the maintainance issue
of access control
in Java. Cifuentes et al. [9] provide a
deﬁnition for caller sensitivity and describe means to detect
unguarded caller sensitive method calls. Toledo et al. [31]
observed that access-control checks are scattered throughout
the JCL making them non-modular and therefore hard to
maintain. They propose two solutions based on aspect-oriented
programming to fully modularize access control in Java. In
their work they not only cover permission checking, but also
privileged execution and permission contexts.
Moreover, there are alternatives to stack-based access con-
trol. Abadi et al. [32] suggest
to base access control on
execution history rather than on the current call stack. This
will not only capture the nesting of methods, but also any
method that has completed prior to the method that is checked.
Methods that already completed are not on the call stack
anymore and would thus be ignored by regular stack-based
access control. Nevertheless, such methods may change the
global state of the application to a state in which subsequently
called sensitive methods should not be allowed to execute.
Martinelli et al. [33] integrated history-based access control
into Java using IBM’s Jikes VM. However, this approach
causes a signiﬁcant slowdown as its checks are more costly.
Wallach et al. [34] discuss an alternative they call security-
passing style. They represent security contexts as pushdown
automata, where calling a method is represented by a push
operation and returning is represented by a pop operation.
To weave these automata with the program they rewrite a
program’s bytecode so that it no longer needs any security
functionality from the JVM.
Building on the work on stack-based and history-based
access control, Pistoia et al. [35] introduce information-based
access control. They argue that history-based access control
may prevent authorized code from executing because of less
authorized code executed previously, although it may not have
inﬂuenced the security of the operation that is about to be
executed. In information-based access control every access-
control policy implies an information-ﬂow policy. It augments
stack inspections with the tracking of information ﬂow to
sensitive operations. An extensive review on the relation
of access control and secure information ﬂow is given by
Banerjee and Naumann [36].
IX. CONCLUSION
A key contribution of this paper is the thorough analysis
of the security threat imposed by current shortcuts in the Java
Class Library (JCL), which omit stack-based access-control
in certain situations and cause implicit privilege elevation.
The presence of shortcuts is responsible for the single largest
group of vulnerabilities known to have been exploited for the
Java runtime. We showed that shortcuts directly enable attack
vectors and complicate the security-preserving maintenance
and evolution of the code base; as they elevate privileges
to certain callers implicitly, their callers are in many cases
either unaware of the elevations or unable to reason about
their effects and scope.
Through a tool-assisted adaptation we have created a new
variant of the JCL that works almost without shortcuts,
allowing privileges to be elevated only explicitly through
the use of privileged wrappers. The adapted code allows
maintainers, security experts and tools to easily identify points
of privilege escalation. Moreover, some previous exploits that
abuse insecure use of reﬂection are effectively mitigated by
our approach.
One reason for which shortcuts were originally introduced
was to lower the execution overhead of access control. Surpris-
ingly at ﬁrst, however, a set of large-scale experiments with
the DaCapo benchmark suite shows virtually no measurable
runtime overhead caused by our removal of shortcuts. Micro-
benchmarks explain this result by showing that, in the worst
case, the absolute overheads introduced are all in the order
of microseconds. As we discussed, the reason for this pos-
itive performance is due to early stack-walk terminations at
doPriviliged-calls.
A second reason for the presence of shortcuts is that the
implicit assignment of privilege is convenient, as it reduces
1039
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:24:58 UTC from IEEE Xplore.  Restrictions apply. 
the need to elevate priviliges explicitly, e.g. through an appro-
priate access-control policy. We thus assessed in detail the
usability implications that a move from implicit to purely
explicit privilege elevation entails. The tradeoffs discussed
will ultimately determine whether the proposed hardening is
worthwhile adopting at this point in time.
Another major point of consideration for adopting the
proposed hardening is the large one-time cost involved in im-
plementing it: ideally, security-trained JCL developers should
review every single doPrivileged-call our adaptation in-
troduces, to see that it is not unduly leaking privilege. We
have reported our ﬁndings to the security team at Oracle Inc.
and are discussing those tradeoffs with them. In future work,
we plan to work towards tool support for proving privilege
containment at least for some recurring situations.
REFERENCES
[1] “About Java,” https://www.java.com/en/about/.
[2] L. Gong and G. Ellison, Inside Java(TM) 2 Platform Security: Archi-
tecture, API Design, and Implementation, 2nd ed. Pearson Education,
2003.
[3] “2013 cisco annual security report,” http://www.cisco.com/web/offer/
gist ty2 asset/Cisco 2013 ASR.pdf, 2013.
[4] “2014 cisco annual security report,” http://www.cisco.com/web/offers/
lp/2014-annual-security-report/index.html, Jan. 2014.
[5] P. Holzinger, S. Triller, A. Bartel, and E. Bodden, “An in-depth study
of more than ten years of java exploitation,” in Proceedings of the 2016
ACM SIGSAC Conference on Computer and Communications Security.
ACM, 2016, pp. 779–790.
[6] N. Hardy, “The confused deputy:(or why capabilities might have been
invented),” ACM SIGOPS Operating Systems Review, vol. 22, no. 4, pp.
36–38, 1988.
[7] M. Bartoletti, P. Degano, and G. Ferrari, “Static analysis for stack
inspection,” Electronic Notes in Theoretical Computer Science, vol. 54,
no. 0, pp. 69 – 80, 2001, conCoord: International Workshop on
Concurrency and Coordination (Workshop associated to the 13th
Lipari School).
[Online]. Available: http://www.sciencedirect.com/
science/article/pii/S1571066104002361
[8] M. Pistoia, R. Flynn, L. Koved, and V. Sreedhar, “Interprocedural
analysis for privileged code placement and tainted variable detection,”
in ECOOP 2005 - Object-Oriented Programming,
ser. Lecture
Springer Berlin
Notes
Heidelberg, 2005, vol. 3586, pp. 362–386.
[Online]. Available:
http://dx.doi.org/10.1007/11531142 16
in Computer Science, A. Black, Ed.
[9] C. Cifuentes, A. Gross, and N. Keynes, “Understanding caller-sensitive
method vulnerabilities: A class of access control vulnerabilities in the
java platform,” in Proceedings of the 4th ACM SIGPLAN International
Workshop on State Of the Art in Program Analysis, ser. SOAP 2015.
New York, NY, USA: ACM, 2015, pp. 7–12. [Online]. Available:
http://doi.acm.org/10.1145/2771284.2771286
[10] S. M. Blackburn, R. Garner, C. Hoffmann, A. M. Khang, K. S.
McKinley, R. Bentzur, A. Diwan, D. Feinberg, D. Frampton, S. Z. Guyer,
M. Hirzel, A. Hosking, M. Jump, H. Lee, J. E. B. Moss, A. Phansalkar,
D. Stefanovi´c, T. VanDrunen, D. von Dincklage, and B. Wiedermann,
“The dacapo benchmarks:
Java benchmarking development and
analysis,” in Proceedings of the 21st Annual ACM SIGPLAN Conference
on Object-oriented Programming Systems, Languages, and Applications,
ser. OOPSLA ’06. New York, NY, USA: ACM, 2006, pp. 169–190.
[Online]. Available: http://doi.acm.org/10.1145/1167473.1167488
[11] “Secure coding guidelines
for
Java SE,” http://www.oracle.com/
technetwork/java/seccodeguide-139067.html.
[12] “Security
Explorations
-
SE-2012-01 Details,”
http://www.
security-explorations.com/en/SE-2012-01-details.html.
[13] K.-P. Yee, “User interaction design for secure systems,” Computer
Science Division (EECS), University of California, Tech. Rep., 2002.
[14] S. T¨urpe, “Idea: Usable platforms
secure programming –
mining unix for
insight and guidelines,” in Engineering Secure
Software and Systems (Proc. ESSoS’16), ser. LNCS, vol. 9639, Apr.
2016, forthcoming. [Online]. Available: http://testlab.sit.fraunhofer.de/
downloads/Publications/tuerpe2016idea.pdf
for
[15] L. Gong, “Java security: A ten year retrospective,” in Computer Security
Applications Conference, 2009. ACSAC ’09. Annual, Dec 2009, pp. 395–
405.
[16] “National vulnerability database,” https://nvd.nist.gov/.
[17] P. Lam, E. Bodden, O. Lhot´ak, and L. Hendren, “The Soot
framework for Java program analysis: a retrospective,” in Cetus Users
and Compiler Infrastructure Workshop, 2011.
[Online]. Available:
http://www.bodden.de/pubs/lblh11soot.pdf
[18] S. Chiba, “Javassist-a reﬂection-based programming wizard for java,”
in Proceedings of OOPSLA98 Workshop on Reﬂective Programming in
C++ and Java, 1998, p. 174.
[19] J. R. Rose,
“Bytecodes meet
in Proceedings of
jvm,”
the
Machines and Intermediate Languages,
York, NY, USA: ACM, 2009, pp. 2:1–2:11.
http://doi.acm.org/10.1145/1711506.1711508
combinators:
Invokedynamic on
the Third Workshop on Virtual
New
[Online]. Available:
ser. VMIL ’09.
[20] “Security Explorations - Security vulnerability notice,” http://www.
security-explorations.com/materials/SE-2012-01-IBM-2.pdf.
[21] “OpenJDK source releases - build b132,” http://download.java.net/
openjdk/jdk8/.
[22] “The dacapo benchmark suite - #80 jython generates npe with eager
compilation,” https://sourceforge.net/p/dacapobench/bugs/80/.
[23] “JUnit Benchmarks,”
html.
http://labs.carrotsearch.com/junit-benchmarks.
[24] J. Y. Gil, K. Lenz, and Y. Shimron, “A microbenchmark case study and
lessons learned,” in Proceedings of the compilation of the co-located
workshops on DSM’11, TMC’11, AGERE! 2011, AOOPES’11, NEAT’11,
& VMIL’11. ACM, 2011, pp. 297–308.
[25] D. Gu, C. Verbrugge, and E. M. Gagnon, “Relative factors in perfor-
mance analysis of java virtual machines,” in Proceedings of the 2nd
international conference on Virtual execution environments.
ACM,
2006, pp. 111–121.
[26] L. Koved, M. Pistoia, and A. Kershenbaum, “Access rights analysis
for java,” in Proceedings of the 17th ACM SIGPLAN Conference on
Object-oriented Programming, Systems, Languages, and Applications,
ser. OOPSLA ’02. New York, NY, USA: ACM, 2002, pp. 359–372.
[Online]. Available: http://doi.acm.org/10.1145/582419.582452
[27] L. Gong, “Secure java class loading,” Internet Computing, IEEE, vol. 2,
no. 6, pp. 56–61, Nov 1998.
[28] C. Fournet and A. D. Gordon, “Stack inspection: Theory and variants,”
ACM Trans. Program. Lang. Syst., vol. 25, no. 3, pp. 360–399, May
2003. [Online]. Available: http://doi.acm.org/10.1145/641909.641912
[29] A. Herzog and N. Shahmehri, “Performance of the java security
manager,” Computers & Security, vol. 24, no. 3, pp. 192–207, 2005.
[Online]. Available: http://dx.doi.org/10.1016/j.cose.2004.08.006
[30] B.-M. Chang, “Static check analysis for
SIGPLAN Not., vol. 41, no. 3, pp. 40–48, Mar. 2006.
Available: http://doi.acm.org/10.1145/1140543.1140550
java stack inspection,”
[Online].
[31] R. Toledo, A. Nunez, E. Tanter, and S. Katz, “Aspectizing java access
control,” Software Engineering, IEEE Transactions on, vol. 38, no. 1,
pp. 101–117, Jan 2012.
[32] M. Abadi and C. Fournet, “Access control based on execution
history,” in Proceedings of
the Network and Distributed System
Security Symposium, NDSS 2003, San Diego, California, USA. The
Internet Society, 2003. [Online]. Available: http://www.isoc.org/isoc/
conferences/ndss/03/proceedings/papers/7.pdf
[33] F. Martinelli and P. Mori, “Enhancing java security with history based
access control,” in Foundations of Security Analysis and Design IV, ser.
Lecture Notes in Computer Science, A. Aldini and R. Gorrieri, Eds.
Springer Berlin Heidelberg, 2007, vol. 4677, pp. 135–159. [Online].
Available: http://dx.doi.org/10.1007/978-3-540-74810-6 5
[34] D. S. Wallach, A. W. Appel, and E. W. Felten, “Safkasi: A security
mechanism for language-based systems,” ACM Trans. Softw. Eng.
Methodol., vol. 9, no. 4, pp. 341–378, Oct. 2000. [Online]. Available:
http://doi.acm.org/10.1145/363516.363520
[35] M. Pistoia, A. Banerjee, and D. Naumann, “Beyond stack inspection: A
uniﬁed access-control and information-ﬂow security model,” in Security
and Privacy, 2007. SP ’07. IEEE Symposium on, May 2007, pp. 149–
163.
[36] A. Banerjee and D. A. Naumann, “Stack-based access control and secure
information ﬂow,” J. Funct. Program., vol. 15, no. 2, pp. 131–177, 2005.
[Online]. Available: http://dx.doi.org/10.1017/S0956796804005453
1040
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:24:58 UTC from IEEE Xplore.  Restrictions apply.