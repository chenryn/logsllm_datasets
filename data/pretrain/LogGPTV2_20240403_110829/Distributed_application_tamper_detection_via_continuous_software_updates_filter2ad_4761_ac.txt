p
0
main
i
0,0
foo
p
0
p
rnd_args(foo
0)
main
p
0
main
i
0,0
main
i
0,1
foo
p
0
foo
p
1
foo
i
0,0
foo
i
0,1
foo
i
0,0
foo
i
0,1
foo
i
0,2
foo
i
0,0
foo
i
0,1
foo
i
0,2
foo
i
1,0
p
g
0
(b)
p
g
0
p
g
1
p
g
0
p
g
1
(c)
(d)
Figure 3: Diversity graphs. Protocol nodes are ellipses and implementation nodes rectangles.
wi
main
p
0
A
wi
main
i
0,0
wi
main
p
0
A
wi
main
i
0,0
protocol
change
wi
main
p
0
A
wi
main
i
0,0
wi
p
foo
0
wi
p
foo
0
wj, j < i
wj, j < i
wj, j < i
wi
i
foo
0,0
wi
i
foo
0,0
wi
p
foo
0
wi
i
foo
0,0
Figure 4: Computing forbidden sets for forward operations.
Active blocks are marked with an A, wi marks the generation
a block belongs to, and forbidden blocks are crossed out.
p
i
0,1. Next, we obfuscate g
node foo
p
itive, which generates a protocol-incompatible variant g
forced to furthermore generate a new variant foo
p
patible with g
p
ing rnd_args to foo
0 using the encode_var prim-
1. We are
i
0,1 com-
i
1,0 is created by apply-
0, resulting in a new protocol node foo
1. In Figure 3 (d), ﬁnally, foo
i
0,2 of foo
p
1.
Rollback update cycles. For performance reasons it is not al-
ways possible to transform a block working set wi into a new gener-
ation wi+1 by simply applying obfuscating primitives. Every such
transformation incurs overhead and compounding transformations
would eventually lead to unacceptable client performance. The di-
versity scheduler supports a rollback operation, in which working
set wi+1 is the result of replacing some of the blocks in wi with
variants from previous generations. Since our primitives are param-
eterized, this will allow the system to ﬁrst roll back a few blocks
to previous variants, then roll forward by applying new transforma-
tions, and to do so without incurring any extra performance penalty.
3.4 Diversity Strategies
It is well known that software protection techniques (such as the
obfuscating primitives in Section 3.2) deployed in the ﬁeld have a
limited survival time. Any static target will fall to a motivated ad-
versary equipped with standard reverse engineering tools such as
debuggers, tracers, disassemblers, and decompilers. We therefore
make use of strategies, means of combining primitive transforma-
tions that gives the adversary not a static, but a constantly changing,
attack target. We identify three strategies, based on the notion of
diversity, essential to making effective use of software protection:
DEFINITION 3
(DIVERSITY). A program p is temporally di-
verse if it is delivered to the user, over time, as an inﬁnite and non-
repeating sequence of variants (cid:2)v0, v1, . . .(cid:3) where vi (cid:4)= vj if i (cid:4)= j.
A program p is spatially diverse if a variant v is constructed by
compounding multiple layers of interchangeable primitive trans-
324
formations. A program p is semantically diverse if two variants vi
and vj of p cannot be used interchangeably.
2
Temporal diversity is sometimes known as renewability or software
aging [19], and spatial diversity as defense-in-depth.
The diversity scheduler (see Figure 1) decides on an appropri-
ate sequence of strategies to employ in order to best protect the
client program from tampering. It employs temporal diversity by
producing generations of block variant working sets, spatial di-
versity by compounding protocol-preserving primitives from Sec-
tion 3.2.3, and semantic diversity by applying the non-protocol-
preserving primitives from Section 3.2.4.
The input to the scheduler is the current working set wi, the cur-
rent diversity graph Gi, the performance proﬁle of the client code,
the security requirements of different parts of the code (the level
attributes provided as program annotations), the set of primitives
and their effect on diversity and performance, and the active set
(functions currently on the client’s call stack). The output of the
scheduling operation is a new working set wi+i, the kill set of
blocks that need to be invalidated on the client side, and an updated
diversity graph Gi+1.
3.4.1 The Diversity Scheduler
The scheduler can choose between forward and rollback updates.
In a forward update it applies primitive transformations to the blocks
in the current working set, resulting in a new working set with more
confusion but also more performance overhead. In a rollback up-
date, one or more of the blocks in the current working set are made
to revert back to previous variants.
Depending on the state that the client is currently in, not all
blocks can be transformed by all primitives, nor can all blocks be
reverted to previous variants. Fundamentally, the reason is that our
system is designed not to replace running code, i.e. functions cur-
rently on the activation stack. We will next examine the restrictions
necessary in the case of forward cycles.
3.4.2 Restrictions on Forward Update Cycles
To see the restrictions on which transformations can be applied
to which blocks in case of a forward update cycle, consider the
i
example in Figure 4 (a), where main
0,0 is on the stack. Since it
would provide no further diversity to transform blocks not in the
current generation, any block in wj , j < i is forbidden. Active
i
blocks (here, only main
0,0) are also forbidden since in our system
we cannot replace running code. Furthermore, a block called di-
rectly by an active block is forbidden for non-protocol-preserving
i
transformations. To see why, consider foo
0,0, above. If we were to
i
0,0 would have to be
change foo
updated, and this is not possible since this block is currently active.
i
0,0’s protocol, the call site in main
Thus, to perform a forward transformation, the scheduler com-
putes forbidden nodes in the diversity graph, selects a permissible
block B and a transformation T , performs the transformation, up-
dates the diversity graph, and sends the kill set to the client.
If
there is more than one possible candidate block and transforma-
tion, we choose heuristically to maximize diversity and confusion
while minimizing additional overhead.
3.5 Linking
During execution blocks will continuously come and go in the
client’s block bag. Therefore, it is not possible to refer to code
blocks directly, and we are forced to add a level of indirection. We
thus keep an array of function pointers funPtrArr indexed by
block numbers. A function call bar(42), where bar is block
number 22, turns into the following code, where the function named
_loadBlock(blockNo) loads a missing block over the net-
work and ﬁlls in funPtrArr[blockNo] with the new address:
float (*tmp)(int) = funPtrArr[22];
if (tmp == NULL) {tmp = _loadBlock(22);}
(*(float(*)(int))tmp(42);
4. SECURITY ANALYSIS
In this section we evaluate the security generated by our system.
In Section 4.1 we ﬁrst discuss the server’s ability to detect tam-
pering during interaction-events with the client. In Section 4.2 we
enumerate the methods of attack available to the client and how
each of these attacks can be blocked. In Section 4.3 we describe
the results of attacks we implemented and executed ourselves. In
Section 4.4, ﬁnally, as a measure of the difﬁculty of reusing analy-
ses (the most serious attack described in Section 4.2) we measure
the diversity created by our various transformations.
4.1 Attack Detection
There are several ways in which the server can check that the
client is playing by the rules and ways in which it can punish him if
he does not. Referring back to Figure 1, we see that there are three
client-server interaction events which give the server the opportu-
nity to detect foul play.
In Figure 1 ②, the block scheduler receives a block request from
the client, at which time it will verify that the block belongs to
the client’s current working set. If it does not, this means that the
client has refused a previous block update and, as a result, is now
requesting obsolete blocks belonging to a previous working set. If
fake function calls have been added into the program, a request for
a fake function (which has been inserted by means of the opaque
primitive) will also alert the server that tampering has occurred.
In Figure 1 ③, the server initiates an update cycle and the client
responds with its active set, a list of the functions on its current call
stack (or call stacks, in case of a multi-threaded program). Clearly,
it is in the client’s best interest to lie about the active set:
if he
can convince us that the entire working set is active, i.e. that ev-
ery function in the program is currently on the call stack, he will
prevent us from transforming any blocks! The block scheduler can
detect such degenerate cases by using the call graph portion of the
diversity graph to verify that the active sets represent realizable call
sequences.
In Figure 1 ①, server.c veriﬁes that a remote procedure call
from the client uses a current protocol. This includes checking that
the RPC number and the type and order of arguments is current,
as well as checking that all arguments to the call are within their
speciﬁed ranges. Since the RPC_enc primitive will occasionally be
invoked to randomize the protocol, this is our main way of verifying
325
that the client is executing blocks from an untampered and current
working set.
We can also add application speciﬁc checks to server.c. For
example, we may know that certain sequences of remote procedure
calls are illegal, or we may be able to keep track of enough of the
client’s current local state to be able to detect calls that could never
happen at the current point in the execution.
4.2 Enumeration of the Attack Space
The attack tree in Figure 5 shows the attack space available to a
malicious user. The root of the tree represents the attacker’s goal,
namely to tamper with a particular asset in the program without
being detected. An asset could be a security check, code that up-
dates a particular global variable, the integrity of a control-ﬂow
path, global data, etc. An effective attack proceeds in three steps:
successfully ﬁnd the asset blocks A = {A1, . . . , An}, the set of
blocks that need to be modiﬁed among the blocks in the block bag
(node 1); successfully tamper with these blocks (node 2), and, ﬁ-
nally, avoid detection by the server (node 3). Once the asset blocks
have been located, the adversary is free to modify them to reach his
attack goals.
Figure 5 shows four ways for the attacker to avoid the server
detecting the modiﬁcation to A, ordered from easiest to hardest to
carry out. First (node 3.1), if the attacker is lucky the asset blocks
are badly protected, i.e. not connected to the rest of the program
through use of global variables, calls to other functions, or calls to
RPCs, in any meaningful way. Then he can modify A without the
risk of detection.
Node 3.2 shows that if, during every update cycle, the client can
convince the server that the blocks in A are on the active set, then
the server will never be able to update A. The active set must still
be plausible, requiring the client to analyze the blocks, build the
call graph, and report an active set that does not arouse suspicion.
Node 3.3 shows that the client can trick the server into only mak-
ing trivial changes to A, allowing him to simply ignore updates.
For this attack to work the client reports an active set that contains
blocks that reference the RPCs and variables that A also references.
As a result, those RPCs and variables cannot be modiﬁed, which
prevents the server from performing major changes to A.
Finally, node 3.4 shows an attack where the adversary ﬁnds an-
cestor blocks N0, . . . Nk−1 of a new block variant Nk, extracts any
new variable or RPC encodings, and patches A to use these new
encodings. Thus, A remains tampered but conforms to any new
protocols.
4.2.1 Countermeasures
The primitives in Section 3.2 have been designed to counter the
attacks above.
Nodes 1.2.1, 3.1, 3.2.1.1, 3.3.1.1, and 3.4.1 in Figure 5 show that
block analysis is an integral part of every attack. Depending on the
information needed to carry out the attack, this will involve various
forms of static and/or dynamic analyses, such as disassembly, de-
compilation, control-ﬂow analysis, data-ﬂow analysis, slicing, etc.
We use the primitives, especially the protocol-preserving ones in
Section 3.2.3, to make block analysis more difﬁcult. Any reverse
engineering effort will eventually succeed, but because blocks are
constantly updated it is sufﬁcient for the transformations to slow
down the attacks between updates.
If the asset is contained in one or more orphan blocks (node 3.1),
such as the unlikely situation where the asset is a function contain-
ing a single printf("hello world") statement, the adver-
sary can modify it at will. In such situations the opaque primitive
will allow us to connect the orphan block to the rest of the program
Tamper asset without being
detected
1
Find asset
blocks A
2
Tamper
with A
3
Avoid
detection
1.1
Find blocks
1.2
Detect
asset
blocks
1.1.1
Wait for
blocks to
appear in
block bag
1.1.2
Probe
server for