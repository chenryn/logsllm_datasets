vulnerabilities is trivial and can be easily implemented.
For each backend interface, a number of parameters
(p) are associated with each request.
SkyWalker tests
each interface p times to check every parameter for SQLi
and XSS. The XXE check is performed on all interfaces
because some AS can accept JSON or XML requests. As
mentioned earlier, the scan is slow and randomly done to
avoid congestion and degradation of service on production
backends. SkyWalker creates two queues, a job queue and
a processing queue. SkyWalker generates p requests for a
given backend interface and stores them in the job queue.
The job queue contains all backend requests, which are
shufﬂed and loaded into the processing queue in batches
(128 requests per batch). Batches that contain requests with
the same domain or IP address are removed and replaced by
non-overlapping domains and IP address requests. There are
32 workers that ingest from the processing queue and store
the results for vulnerability analysis.
4.4 Vulnerability Analysis
The vulnerability analysis is two parts, N-day analysis, and
0-day analysis. For the N-day analysis, SkyWalker correlates
CVE entries with results from the ﬁngerprinting to identify
possible issues. The conﬁdence level of the ﬁngerprint re-
sults is also used to verify each vulnerability. SkyWalker
uses NASL scripts that take the output of the service dis-
covery, OS identiﬁcation, SS identiﬁcation, and CS identiﬁ-
cation as input and match them against known vulnerabili-
ties (CVEs). The NASL results are considered if they have
90% conﬁdence level or higher for OS detection, which pro-
vides high accuracy for vulnerability matching. Note, that
the conﬁdence level is calculated based on pre-proﬁled OSes
by matching the ﬁngerprint signals (collected from all lay-
ers) to the proﬁle signals.
We manually veriﬁed all 983 N-days and found them to
be all true positives. The zero false positive results are due
to the Nessus conﬁguration, which allows us to tune how
the scans are done and how they should be reported. For
example, we conﬁgure Nessus to perform the scan types
described above, consider OS type and version detection of
90% or higher and consider SS that have banner information
with version numbers. On the other hand, when we used
UDP scanning techniques and consider generic service
banner information we ﬁnd over 6,500 candidate N-day
instances with a large false positive rate. In theory, the back-
end can be conﬁgured to lie about the banner information,
which would make it hard for us to verify.
For the 0-day analysis, SkyWalker carefully triggers the
candidate vulnerability to verify the ﬁndings. For each vul-
nerable parameter, SkyWalker generates a pair of request
messages, the original message and the vulnerable message.
556    28th USENIX Security Symposium
USENIX Association
For SQLi, SkyWalker baselines the original request message
several times throughout the week and at different times of
the day. Then SkyWalker performs the same measurement
on the vulnerable message in the same week but in non-
overlapping time intervals by triggering the vulnerable pa-
rameter through an SQLi sleep injection. SkyWalker calcu-
lates the response time deviation based on the sleep param-
eter passed in the SQL statement and the average response
time of the message pairs. If the deviation is equal to the
time delay parameter in the SQL statement, SkyWalker con-
cludes that the interface and parameter pair is vulnerable.
Similarly for XSS, SkyWalker triggers the vulnerable pa-
rameter and includes JavaScript code to creates a new div
element with a unique name attribute. SkyWalker checks
the returned content by parsing the document object model
(DOM) to ﬁnd the div element containing the unique name
attribute. If the div element with the set name attribute ex-
ists SkyWalker concludes that the interface and parameter
are vulnerable. Note that SkyWalker matches the returned
content with parameters sent to ensure that the XSS candi-
date vulnerability is of type 2 (reﬂected). For XXE, Sky-
Walker generates a request message that contains an HTTP
callback request to a server we operate. The request mes-
sage is passed to the backend, which will parse the specially
crafted XML document. If the parser is vulnerable to XXE,
SkyWalker will log an HTTP request from the backend un-
der analysis, which indicates the interface is vulnerable. In
addition, we manually reviewed the request/return pairs for
all 655 0-day instances and found no false positives.
4.5 Open Access for Developers
One of our primary goals for this work is to empower app
developers with open access to SkyWalker via a free-to-use
web-service. The service currently supports Android mobile
apps but can be extended to support other mobile platforms,
e.g., Apple iOS. The web-interface takes as input a link to an
Android app in the Google Play store or a direct APK upload.
SkyWalker then performs binary analysis to extract the back-
ends, label them based on our curated dataset, ﬁngerprint
them, and identify vulnerabilities that affect them. In addi-
tion to the analysis, the output report provides guidelines on
how to mitigate the identiﬁed issues using the strategies dis-
cussed earlier (upgrade, patch, block, report, and migrate).
SkyWalker summarizes vulnerability ﬁndings across all
observed SDK and Java library backends, which developers
can turn to proactively to make an informed decision when
choosing third-party libraries to include in their future
It is important to note that attackers can abuse this
apps.
system to attack mobile app backends.
Therefore we
require the developers to disclose their afﬁliation with the
target app before the analysis results are provided. Once
a user is manually vetted, they can only submit apps that
they develop. We do not consider third-party SDKs in
this process. The SkyWalker service can be found at:
https://MobileBackend.vet.
5 Assessment Findings
5.1 Experiment Setup
Environmnet. We use a local workstation running Ubuntu
14.04 with 24GB memory and 16 x 2.393GHz Intel Xeon
CPUs and four Nexus phones to run and instrument the mo-
bile apps. We use an Amazon Web Service (AWS) Elastic
Compute (EC2) instance with a reserved IP address to con-
duct the ﬁngerprinting and run a web server with informa-
tion about our study along with an email address for backend
hosts to contact us if they want to opt-out.
Tools and Data Sets.
For the binary analysis tool im-
plementation, we relied on Soot [25], FlowDroid [26],
Z3-str [27], and Xposed [28] with custom code written in
Java (7,000 lines of code) and Python (900 lines of code).
For our backend labeling implementation, we relied on Team
Cymru IP-to-ASN [29], MaxMind Geolocation [23], Alexa
ranking [30], ipcat list [20], and Domaintools WHOIS [31]
with custom code written in Python (480 lines of code).
For ﬁngerprinting, we relied on the Nessus scanner and
commercial plugins [32], sqlmap [33], and Acunetix [34].
We used Nessus plugins and custom Python code (1010 lines
of code) to perform the vulnerability analysis. For internet
measurements, we utilized honeypot scanning activity from
Greynoise [35].
5.2 Software Vulnerability Details
Table 4 shows the distribution of 0-day and N-day instances
across the software layers. We categorize the apps using the
Google Play store groups and present the number of vulnera-
bilities and backend labels. Overall, we analyzed 4,980 apps
with cloud-based backends and successfully extracted back-
ends for 4,740 mobile apps. The remaining 240 mobile apps
crashed and did not complete the full binary analysis.
Interestingly, the OS component reports the least vulner-
abilities, while the AS component reports the most vulnera-
bilities, across all mobile app categories. Recall from Sec-
tion 3.2, vulnerabilities affecting AS components are all con-
sidered 0-day. The OS, SS, and SC components account for
N-day vulnerabilities. Although the number of apps is not
uniform across the categories, we use the raw vulnerability
count for ranking. For 0-day vulnerabilities, the top three
mobile app categories are tools, entertainment, and games.
For N-day vulnerabilities, the top three mobile app categories
are entertainment, tools, and games.
Ownership. Table 4 presents the labels for the backends
used by mobile apps. The most common label is hybrid,
where 3,336 backends use hybrid infrastructure. The second
USENIX Association
28th USENIX Security Symposium    557
Category
# Mob. Apps
Books & Reference
Business
Entertainment
Games
Lifestyle
Misc
Tools
Video & Audio
Total
332
145
1,177
1,283
363
199
792
689
4,980
# OS
15
5
36
34
20
6
19
24
121
# SS
49
22
108
81
50
21
84
46
356
# AS
55
10
158
147
79
45
184
89
655
Vulnerabilties
Total
190
74
472
368
221
118
402
257
1,638
# B1st
365
93
746
290
262
76
729
267
2,492
# B3rd
653
258
913
804
665
422
796
648
1,089
Labels
# Bhyb
501
150
942
651
311
163
812
434
3,336
# Bukn
354
113
783
444
237
105
464
357
2,506
Total
1,873
614
3,384
2,189
1,475
766
2,801
1,706
9,423
# CS
71
37
170
106
72
46
115
98
506
Table 4: An overview of the vulnerable mobile apps per genre along with the raw counts of vulnerabilities and labels.
Party
B1st
B3rd
Bhyb
Bukn
Vulnerable Component
CS
OS
211
37
42
6
184
47
55
173
SS
87
21
150
135
AS
155
200
154
146
Total
490
269
535
509
Table 5: Count of apps affected by vulnerabilities per cloud
layer and their corresponding labels.
Comp.
OS
SS
AS
CS
Vulnerability (Top 3)
Expired Lifecycle for Linux OS (various)
Windows Server RCE (MS15-034)
Expired Lifecycle for Windows Server
Vulnerable PHP Version
Expired Lifecycle for Web Server (various)
Vulnerable Apache Version
XSS (various)
SQLi (various)