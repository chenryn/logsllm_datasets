事情是这样的，最近有个渗透的小伙伴找我，它通过shiro反序列化植入内存马获取了一个shell，但这台主机上有负载均衡，所以通过冰蝎、蚁剑等连接工具上传大文件会上传失败，需要我这边提供解决方案。
## 问题分析
### 问题一：为什么shell管理工具文件上传需要分包？
我使用蚁剑做了测试，蚁剑配置shell可以在`其他设置`中设置分片的大小，默认是`500kb`，那有小伙伴可能要说了，那我将这个值改成一个比较大的值不就可以一次性上传大文件也就相当于解决了负载均衡的问题。  
理论上是没错的，我们改分包的大小为`5000kb`试试，提示 **上传失败！**  
抓包可以看到确实发起了上传请求但是并 **没有获取到返回结果** ，并且我们可以看到上传的内容都是在`z2`参数中，那么  
**会不会是请求参数有大小限制导致的？**  
经过查阅资料， **Tomcat默认参数大小为2M** ，所以才需要对上传操作分包上传。  
### 问题二：是否有其他方式上传大文件？
虽然webshell管理工具没有提供一次上传大文件的方式，但实际上我们也 **可以自己构造一个上传点通过解析上传表单的内容实现一次性上传大文件的需求**  
。虽然这种方案也算比较可行，可以解决目前的需求，但是并没有从本质上解决负载均衡下的webshell连接问题。
### 问题三：有什么方法可以解决负载均衡下的webshell连接问题？
其实在很早以前`Medicean`表哥就分析过这个问题，可以参考[负载均衡下的 WebShell  
连接](https://mp.weixin.qq.com/s/4Bmz_fuu0yrLMK1oBKKtRA)。  
在这片文章中他提出了一个比较稳妥的解决方案，即  
**实现HTTP代理，将所有对webshell的连接请求都代理到指定的一台节点上处理，我们只需要和代理交互即可** 。  
虽然`Medicean`表哥提出了解决方案，不过并没有给出具体的实现代码，所以我们只能自己去写，不过这个逻辑本身也比较简单，  
**请求代理url时构建一个新的url请求并发送到指定节点，最后获取返回结果并返回给客户端** 。
## 环境搭建
这里我开了两台web进行模拟。  
tomcat **模拟负载均衡** 的主机，这台主机上有一个webshell（）。
springboot启动的web **模拟代理**
的功能（主要是为了方便调试），需要将所有对webshell的请求转发到tomcat中处理并获取返回结果(
## 问题处理
首先是URL请求的问题，由于我们并不知道对方主机上是否有其他的第三方库处理HTTP请求，所以选择使用JDK自带的`HttpsURLConnection`来处理URL请求。可以分为下面几个步骤实现代理功能。
### 步骤一：接收请求内容并发给目标
在获取请求内容时，我们的代理并不关注目标发送了什么数据，所以我这里决定使用`request.getInputStream`获取请求内容。但是这里有个小坑点，由于我是使用springboot来模拟`proxy`的，但  
**springboot在到达我们的proxy Controller之前会读取InputStream中的内容，所以在proxy  
Controller中去读**`request.getInputStream` 是获取不到内容的 。  
由于渗透小伙伴给的目标本身不解析JSP，我最终一定是要打一个内存马给他的，所以我这干脆找了个[Filter的内存马](https://github.com/bitterzzZZ/MemoryShellLearn/blob/main/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B3%A8%E5%85%A5%E5%86%85%E5%AD%98%E9%A9%AC/tomcat-
servlet-filter-listener/AddFilter.java)，在`doFilter`中添加我们代理的逻辑。  
### 步骤二：获取目标返回结果并返回给客户端
在获取返回包时，还有一个小坑，蚁剑的返回包是字符，所以我们直接用字符流获取返回内容并输出是没问题的，但是冰蝎的返回包却是字节码，用字符流处理会有问题，因此最终还是用`OutputStream`获取响应。  
### 效果演示
下面是 **蚁剑** 的测试，`proxy2`是我注入的内存马的URL：  
**冰蝎演示**  
### 内存马种植问题
在本地调试通过后因为要把代理打到内存中，所以我在本地搭建了shiro测试。但是当我通过shiro植入内存马却爆了请求头过长的问题。  
但我用[GITHUB](https://github.com/j1anFen/shiro_attack)上这款工具注入内存马却没有问题，抓包分析下它的内存马种植除了有remeberMe字段，还POST一个dy参数。  
那我们分析下这款工具是如何注入内存马的。  
当我们执行内存马植入操作，主要会交给`attack.core.AttackService#injectMem`处理请求。`GadgetPayload`生成加密后的Remeberme的值，将这个值设置到Cookie中，并且植入内存马的密码和路径都会被设置到请求头中。接下来通过`MemBytes.getBytes`获取要注入的内存马的类的Base64后的字节码并设置到dy字段中。所以在`dy`参数中保存的才是真正的内存马。`Cookie`中保存的只是加载内存马的Loader。  
分析过CC的同学一定知道，`TemplatesImpl`中最终会将`_bytecodes`中的类实例化，所以到服务端会执行`InjectMemTool`的构造方法。  
`InjectMemTool`构造方法中通过反射获取`request`对象的`dy`参数，Base64解码后通过defineClass加载类，最终实例化后调用`equal`方法。这里作者还是下了一些功夫的，为了压缩这个类的体积，将反射获取字段内容抽出来构造了`getFV`方法。  
在作者提供的内存马中，`equals`方法会去通过`addFilter`或者`addServlet`添加内存马。  
虽然了解了原理，但是自己手改这样的代码其实还是比较复杂的，所以我决定将作者提供的内存马的实现类的`doFilter`方法改成我们的代理类的内容，所以要分析`MemBytes.getBytes`的逻辑。`getBytes`根据传入的类型找到`classname`，再根据`classname`从`MEM_TOOLS`中找到实现类的字节码。  
这个字节码在初始化时就会被放入Map中，所以理论上来讲，只要我们在Map里添加代理和实现类的Base64编码就可以扩展这个功能了。  
理论上是这样没错，可是我将Proxy添加到map中，编译后覆盖掉原有的类后发现我的`ProxyFilter`并没有在界面上显示。  
分析源码后发现这些值是写死的，所以不能通过这种方式扩展，只能通过将原有的`Filter`覆盖为我们的Proxy的方式来实现。可惜作者没有在GITHUB开源，二开不太方便。  
### SSL问题
本以为到这里就结束了，但目标是开启了SSL的tomcat,而这个SSL可能是使用的自签名，所以直接去请求会报错，我本地也给tomcat开启了SSL进行访问测试，发现会爆一个SSL的异常，所以这里我们还要加上一个判断，忽略SSL的验证。  
### 完整实现
最后给出完整实现的JSP版本。
## 参考文章
  * [负载均衡下的 WebShell 连接](https://mp.weixin.qq.com/s/4Bmz_fuu0yrLMK1oBKKtRA)