Michael Ligh, Malicious Code Engineer
Greg Sinclair, Rapid-Response Engineer
iDefense Security Intelligence Services
Malware RCE: 
Debuggers and Decryptor Development
Topics
• How to script a debugger for malware RCE
• Almost all malicious code uses some form of obfuscation to 
protect
» Strings
» Configurations
» Command-and-Control (C&C) protocols/hosts
» Stolen Data
• Save time, leverage the code’s own functions
» All you have to do is find it
• We'll show you some examples
» Kraken, Laqma, Silent Banker, DHTMLSpy, Torpig/MBR
The Hiding Game
Why do malicious code authors obfuscate things?
» To make RCE significantly more difficult
» To prevent others from reading the stolen data
» To prevent others from deciphering the C&C protocol
» To make building IDS/IPS and anti-virus signatures more 
difficult
The Hiding Game
Why do we de-obfuscate things?
» To make RCE easier
» To recover stolen data and credentials
» To decipher the C&C protocol
» To build IDS/IPS and anti-virus signatures
Decryptor Development Methods
1. Manual RCE: Decryptor developement based on ASM
» Requires the most intimacy with ASM
» More code + more complexity = more time consuming
2. Assisted RCE: Pressing F5 (Hex-rays)
» Requires type fix-up often
3. Scripting the debugger: Let the malware do the work 
» More code + more complexity = more time consuming 
The best method depends on the project 
» For example, Wireshark plugins require manual or assisted
Scripting the Debugger
•
Generally speaking, there are three classes of scriptable 
analysis
» Active 
» You control which functions execute and in which order
» Redirect EIP (“New origin here”) and “crawl” through code
» Example: Silent Banker encoded strings (max code coverage)
» Passive
» Monitor Trojan with function hooks, API or internal
» Let it run through (may need !hidedebug) 
» Example: Kraken network traffic
» Recon and utility scripting
» Kind of a catch-all, hybrid class
» Examples include
» Scanning an arbitrary file for shell code
» Checking shared DLLs for hooks
» Unpacking malware or other “protected” binaries
June 27, 2008
Requirements
•
Required
» Copy of the Trojan 
» Debugger 
» Immunity Debugger + Python
» Olly + OllyScript
» IDA + IDC/IDAPython 
» Basic RCE knowledge 
» Unpacking, breakpoints, stepping, running, registers
•
Optional
» Disassembler 
» Virtual environment 
Demo Summary
Demo Line-up
» Silent Banker
» Decode binary strings
» Resolve hash-based API imports
» Kraken
» Print decrypted network traffic 
» Generate C&C hostnames
» Laqma 
» Snoop on shared memory and window messages (IPC)
» Torpig/MBR
» Extract decrypted data from the kernel driver
[Active] Example: SilentBanker Strings Decoder
•
Decoding strings requires some basic RCE work
» Locate obfuscated strings
» Locate function xrefs to the obfuscated string
» Does the function look like a decoder?
» Yes - analyze parameters/output (registers and stack)
» No - keep looking
» The following looks like a decoder
June 27, 2008
[Active] Example: SilentBanker Strings Decoder
10
DEMO
[Active] Example: SilentBanker Strings Decoder
[Active] Example: Silent Banker API Resolution
•
The effect of run-time dynamic linking
» LoadLibrary/GetProcAddress instead of IAT
» API calls look like “call dword ptr [eax+20h]”
» Makes static analysis a PITA
•
SilentBanker uses hash-based RTDL
» Frequently used in shell code
» Binary contains 32-bit hash instead of function name
» It walks a loaded library's exports 
» if hash(getNextExportName()) == 0x19272710
» Makes static analysis an even bigger PITA
[Active] Example: Silent Banker API Resolution
Quick solution to the problem
» Find the base address of call table
» Run the Trojan until it fills in the call table 
» Loop through the call table with reverse lookups 
» Add a structure to the IDB and rename if desired
»  call dword ptr [eax+20h]
»  call dword ptr [eax+ExitProcess] 
[Active] Example: Silent Banker API Resolution
DEMO
[Active] Example: Kraken C&C Hostname Generation
Spam bot uses UDP 447 and HTTP POST for C&C
» Locates C&C servers based on hostname algorithm
» It is easy to find the algorithm-containing function 
» Analyze the function parameters
» for(i=0; i Immdbg)
» Scanning arbitrary files for shellcode
» Scanning memory for API function hooks
28
[Utility] Importing and Exporting Data
• Transfer data into IDA for static analysis
» Save the debugger script's output to text file
» Use IDAPython to import the data to the .idb
» Patch decoded strings, rename call tables with API 
• Transfer data into Immdbg for dynamic analysis
» Reverse the process above
» Save named functions, comments, structure members
[Utility] Importing and Exporting Data
DEMO
30
[Utility] Detect Shellcode in Arbitrary Files
• Is that .pdf, .doc or .jpeg malicious?
» Applies to any file type
» Could still be malicious without shellcode
» JavaScript bytecode
» PDF FlateDecode
• Based on common characteristics of shellcode
» Load the file into memory and scan each byte 
» Is it a jump or a call instruction? 
» Is the destination address valid?
» Are the instructions at the destination address valid?
31
[Utility] Detect Shellcode in Arbitrary Files
32
[Utility] Detect Shellcode in Arbitrary Files
• Result set is proportional to file size
• Other methods/resources for detecting shellcode
» Open suspect file in IDA and press “c”
» Use a stream disassembler 
» diStorm64 (http://www.ragestorm.net/distorm) 
» Polymorphic Shellcode (Detection) by Christoph Gratl
» Hybrid Engine for Polymorphic Shellcode Detection by 
Payer, Teufl and Lamberger
» Libemu (http://libemu.mwcollect.org) 
33
[Utility] Detect Hooked API Functions
•
Multiple methods for user mode API hooking
» Trampoline hooks
» IAT hooks (watch out for LoadLibrary/GetProcAddress 
hooks)
» Modify DLL on disk
•
It is easy to check for trampoline hooks
» For each loaded DLL
» For each exported function
» Is the prologue overwritten?
» CALL
» JMP
» PUSH/RET
» Yes – is the destination inside the loaded DLL?
34
[Utility] Detect Hooked API Functions
•
Determine the purpose of an API hook
» Set breakpoints on the hooked functions
» Use the target process as desired (i.e., browse to Web 
page)
» Debug 
35
[Utility] Detect Hooked API Functions
DEMO
36
Potential Caveats
• The project may require “manual” or “assisted” RCE
» Wireshark, Glamour/Gpcoder tool
• Scripting ring-zero malicious code is possible, but 
challenging
» Patch API calls (ntoskrnl.exe:RtlTimeToTimeFields -> 
ntdll.dll:RtlTimeToFileFields)
• Interpreted scripts can take a while to execute 
• Subject to anti-debugger detection 
» But try http://www.PEiD.info/BobSoft 
Additional Resources
• Immunity Debugger and Forums
» http://www.immunitysec.com/products-immdbg.shtml 
» http://forum.immunityinc.com 
• OpenRCE has a few scripts, too
» http://www.openrce.org 
• We're hosting ours with Google Code
» http://code.google.com/p/mhl-malware-scripts 
June 27, 2008
Q and A
Michael Ligh
Greg Sinclair
iDefense Security Intelligence Services