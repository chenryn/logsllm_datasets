resulting in sending each RESET packet being an expensive opera-
tion. If exploited, this behavior can be used in a Denial-of-Service
attack against the server. This critical bug has been acknowledged
by the developers and will be fixed soon.
Issue 3: Inconsistent Port on RETRY in QUIC-Tracker.
6.2.5
Analysis technique and outcome: After learning the model
of one of the implementations we detected a discrepancy (in terms
of traces) in how two different implementations handle the Retry
Mechanism: if the server sent a RETRY packet the model would
transition to a state where connection establishment was impossible.
This greatly contrasted with behavior learned in another model.
One of the properties of a confirmed erroneous trace is that ei-
ther the Implementation or the Adapter are behaving unexpectedly.
In this case, it was the reference implementation, QUIC-Tracker,
that had a bug in its retry mechanism, and only one of the target im-
plementations considered it critical enough to not allow connection
establishment to take place.
Underlying Issue: QUIC’s Retry Mechanism, as introduced in
Section 6.2.3, is a way for the server to validate that a packet is
indeed being sent from a specific IP address and port, and not just
an attacker replaying packets from a spoofed source. The client
starts by sending a ClientHello as usual, but this time the server
replies to it with a RETRY packet. This packet has a unique token
which the client must take and send in a new ClientHello from
the same IP address and port. The server then checks if the Retry
Token matches the one previously sent to confirm these packets are
being sent from the claimed source. Our reference implementation
was correctly returning the token; however it was doing so with a
new UDP socket using a random free port instead of the one we
were using before. As such, the token would be sent from a different
port, and address validation would fail, interrupting the handshake.
Issue 4: Stream Data Blocked Bug in Google QUIC.
6.2.6
Analysis technique and outcome: Using the extended models
of Section 4.3, we synthesized an extended Mealy Machine (shown
in Appendix ??) that describes how the Maximum Stream Data field
in the STREAM_DATA_BLOCKED frame changes over the states. By
inspecting this model we were able to detect that this field always
has the value 0, and is never updated, even when the stream gets
blocked.
Underlying Issue: One of the key features of QUIC is flow
control. For this, QUIC makes use of a series of frames dedicated
to coordinating flow limits between the two endpoints. One such
frame, the STREAM_DATA_BLOCKED frame, is responsible for alerting
the other endpoint when we would like to send data on a stream,
but the flow control limits imposed on us by the endpoint itself
do not allow us to do so. This frame has two fields, a Stream ID
field indicating which stream is blocked, and a Maximum Stream
Data field, indicating at what offset of the data the block happened.
We found that although one of the implementations used these
frames and did not transmit data over the agreed limits, it did
not set the Maximum Stream Data correctly, and instead used the
constant 0. The developers have confirmed that this section of the
specification was incorrectly implemented. They explained that 0
772
was a placeholder set during initial development, which they had
forgotten to update.
7 RELATED WORK
Model learning has been applied to a range of communication and
security protocols [9, 10], including network protocols [12, 17, 18,
22]. Prognosis improves on previous work in several directions:
first, the architecture of Prognosis is parametric with respect to
reference implementation, an aspect that greatly decreases the
amount of work and expertise needed to analyze one protocol
implementation; second, Prognosis allows a user to swap different
implementations of the same protocol seamlessly by requiring only
a socket change; third, Prognosis uses synthesis to enrich the
models with data and enables a more fine-grained control in the
type of properties and details one can analyze. Prognosis is the first
model-learning tool used to analyze several QUIC implementations.
Other approaches to analyze QUIC include recent work by McMil-
lan and Zuck [27] who manually build a formal specification of the
wire protocol in the Ivy language, and then use it for test generation
and find a range of bugs in different implementations. In contrast,
the approach used in Prognosis automates the building of a finite
state model guided by an abstract alphabet. The models learned
by Prognosis can also be used for test generation, and crucially
one does not need to manually encode the protocol logic, including
complex cryptographic components, to use Prognosis. McMillan
and Zuck [27] specify the full protocol state including the security
handshake, with unbounded data. The models we learned with
Prognosis abstract away details not covered by the alphabet or the
registers we chose to synthesize. Closely related to [27], but only
for TCP, is the work of [15] using symbolic model checking.
Other approaches to analyze protocol implementations include
building a correct-by-construction reference implementation [14, 19]
and then use it when testing a new implementation. This approach
has the advantage of having every component of the protocol in the
reference implementation formally verified. However, the amount
of manual work to build such implementation is out of reach of
most development teams and, moreover, it will be making specific
choices in terms of the RFC specification.
Prognosis is closed-box—it does not assume access to the code
of the implementation being analyzed. Open-box approaches to ana-
lyze QUIC also appeared in the literature [23, 30]. These works focus
on testing protocol compliance using symbolic execution. How-
ever, subtle bugs related to ambiguities in the RFC or differences
between implementations (like the ones detected by Prognosis
and described in Section 6) would not be detected easily.
Finally, Prognosis complements differential testing [26]: the
learned models as well as the Adapter can be used to create high-
quality test cases that trigger complex behaviors of the protocols,
something that is typically hard in a closed-box setting. Further-
more, Prognosis produces models that can be inspected by protocol
designers, something that differential testing cannot help with.
In summary, our work focuses on developing a modular, reusable,
and flexible framework, where different formal analysis techniques
can easily be made accessible for different protocols and implemen-
tations thereof.
SIGCOMM ’21, August 23–27, 2021, Virtual Event, USA
Ferreira et al.
8 CONCLUSION
Prognosis is a modular framework to automatically learn models
of network protocol implementations and analyze them. Prognosis
has been successfully used to analyze TCP and QUIC implemen-
tations and has found several bugs in different mainstream QUIC
implementations. One of the key contributions of Prognosis is
the use of a reference implementation to remove the burden of
having to implement a protocol logic from the user. This step was
required in previous approaches based on model learning. Though
this contribution means that less experienced users have easier
access to our framework, Prognosis still requires some knowledge
on how to instrument the reference implementation.
One direction for further work is investigating whether there are
semi-automated ways of aiding the user of Prognosis in finding
the key places where the code needs instrumentation. The use
of active model learning is core to Prognosis as the precision of
the learned model can be adjusted on demand. However, in cases
where access to logs is possible, and to avoid resorting to so many
expensive queries, the learning process could be speeded up using
a combination of passive and active learning.
The models Prognosis can currently synthesize do not encom-
pass any form of environment quantities, which are interesting in
a networking context to capture e.g., congestion, latency, or mem-
ory usage properties. Extending Prognosis to richer quantitative
models is perhaps the most challenging yet impactful direction for
future work, as it will require significant advances on the design
of learning algorithms. Recent developments in active learning
of weighted automata [13, 33] provide a good starting point for
this direction. Learning quantitative properties will also require an
enriched Adapter that can answer quantitative queries.
9 ACKNOWLEDGMENTS
Ferreira and Silva were partially funded by ERC grant AutoProbe
(101002697). D’Antoni was partially funded by Facebook research
awards, a Microsoft Faculty Fellowship, and an Amazon Research
Award. The authors would like to thank Hongqiang Liu for his help
in preparing the final version of the paper.
REFERENCES
[1] 2021. cloudflare/quiche. (Jan. 2021). https://github.com/cloudflare/quiche original-
date: 2018-09-29T18:22:05Z.
[2] 2021.
facebookincubator/mvfst.
(Jan. 2021).
https://github.com/
facebookincubator/mvfst original-date: 2018-04-09T22:49:15Z.
[3] 2021. Google QUIC - The Chromium Projects. (Jan. 2021). https://www.chromium.
[4] 2021. Heartbleed - CVE-2014-0160. (Jan. 2021). https://nvd.nist.gov/vuln/detail/
org/quic
CVE-2014-0160
[5] 2021. Let server abort on post-Retry packet number reset by dtikhonov · Pull
(Jan. 2021). https://github.com/quicwg/
Request #3990 · quicwg/base-drafts.
base-drafts/pull/3990 Library Catalog: github.com.
[6] 2021. NVD - CVE-2017-1000253. (Jan. 2021). https://nvd.nist.gov/vuln/detail/
[7] 2021. NVD - CVE-2018-5390.
(Jan. 2021). https://nvd.nist.gov/vuln/detail/
CVE-2017-1000253
CVE-2018-5390
[8] 2021. Scapy. (Jan. 2021). https://scapy.net/
[9] F. Aarts, J. De Ruiter, and E. Poll. 2013. Formal Models of Bank Cards for Free.
In 2013 IEEE Sixth International Conference on Software Testing, Verification and
Validation Workshops. 461–468. https://doi.org/10.1109/ICSTW.2013.60
[10] Fides Aarts, Julien Schmaltz, and Frits Vaandrager. 2010.
Inference and Ab-
straction of the Biometric Passport. In Leveraging Applications of Formal Meth-
ods, Verification, and Validation (Lecture Notes in Computer Science), Tiziana
Margaria and Bernhard Steffen (Eds.). Springer, Berlin, Heidelberg, 673–686.
https://doi.org/10.1007/978-3-642-16558-0-54
[11] Dana Angluin. 1987. Learning regular sets from queries and counterexamples.
Information and Computation 75, 2 (Nov. 1987), 87–106. https://doi.org/10.1016/
0890-5401(87)90052-6
[12] George Argyros, Ioannis Stais, Suman Jana, Angelos D. Keromytis, and Aggelos
Kiayias. 2016. SFADiff: Automated Evasion Attacks and Fingerprinting Using
Black-Box Differential Automata Learning. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security (CCS ’16). Association for
Computing Machinery, New York, NY, USA, 1690?1701. https://doi.org/10.1145/
2976749.2978383
[13] Borja Balle and Mehryar Mohri. 2015. Learning Weighted Automata. In Algebraic
Informatics - 6th International Conference, CAI 2015, Stuttgart, Germany, September
1-4, 2015. Proceedings (Lecture Notes in Computer Science), Andreas Maletti (Ed.),
Vol. 9270. Springer, 1–21. https://doi.org/10.1007/978-3-319-23021-4_1
[14] Karthikeyan Bhargavan et al. 2016. Everest: Towards a Verified, Drop-in Replace-
ment of HTTPS. (2016), 11.
[15] Steve Bishop, Matthew Fairbairn, Hannes Mehnert, Michael Norrish, Tom Ridge,
Peter Sewell, Michael Smith, and Keith Wansbrough. 2019. Engineering with
Logic: Rigorous Test-Oracle Specification and Validation for TCP/IP and the
Sockets API. J. ACM 66, 1 (2019), 1:1–1:77. https://doi.org/10.1145/3243650
[16] Leonardo de Moura and Nikolaj Bjørner. 2008. Z3: An Efficient SMT Solver. In
Tools and Algorithms for the Construction and Analysis of Systems (Lecture Notes in
Computer Science), C. R. Ramakrishnan and Jakob Rehof (Eds.). Springer, Berlin,
Heidelberg, 337–340. https://doi.org/10.1007/978-3-540-78800-3_24
[17] Joeri de Ruiter. 2016. A Tale of the OpenSSL State Machine: A Large-Scale Black-
Box Analysis. In Secure IT Systems - 21st Nordic Conference, NordSec 2016, Oulu,
Finland, November 2-4, 2016, Proceedings (Lecture Notes in Computer Science),
Billy Bob Brumley and Juha Röning (Eds.), Vol. 10014. 169–184. https://doi.org/
10.1007/978-3-319-47560-8_11
[18] Joeri de Ruiter and Erik Poll. 2015. Protocol State Fuzzing of TLS Implementations.
In 24th USENIX Security Symposium, USENIX Security 15, Washington, D.C., USA,
August 12-14, 2015, Jaeyeon Jung and Thorsten Holz (Eds.). USENIX Association,
193–206.
[19] Antoine Delignat-Lavaud, Cédric Fournet, Bryan Parno, Jonathan Protzenko,
Tahina Ramananandro, Jay Bosamiya, Joseph Lallemand, Itsaka Rakotonirina,
and Yi Zhou. [n. d.]. A Security Model and Fully Verified Implementation for the
IETF QUIC Record Layer. ([n. d.]), 17.
[20] Antoine Delignat-Lavaud, Cédric Fournet, Bryan Parno, Jonathan Protzenko,
Tahina Ramananandro, Jay Bosamiya, Joseph Lallemand, Itsaka Rakotonirina,
and Yi Zhou. 2020. A Security Model and Fully Verified Implementation for the
IETF QUIC Record Layer.
IACR Cryptol. ePrint Arch. 2020 (2020), 114. https:
//eprint.iacr.org/2020/114
[21] Paul Fiterau-Brostean, Bengt Jonsson, Robert Merget, Joeri de Ruiter, Konstanti-
nos Sagonas, and Juraj Somorovsky. 2020. Analysis of {DTLS} Implementations
Using Protocol State Fuzzing. 2523–2540. https://www.usenix.org/conference/
usenixsecurity20/presentation/fiterau-brostean
[22] Paul Fiterău-Broştean, Ramon Janssen, and Frits Vaandrager. 2016. Combining
Model Learning and Model Checking to Analyze TCP Implementations. In Com-
puter Aided Verification (Lecture Notes in Computer Science), Swarat Chaudhuri
and Azadeh Farzan (Eds.). Springer International Publishing, Cham, 454–471.
https://doi.org/10.1007/978-3-319-41540-6-25
[23] Vidhi Goel, Rui Paulo, and Christoph Paasch. 2020. Testing QUIC with packetdrill.
In Proceedings of the Workshop on the Evolution, Performance, and Interoperability
of QUIC. ACM, Virtual Event USA, 1–7. https://doi.org/10.1145/3405796.3405825
[24] Harry B. Hunt and Daniel J. Rosenkrantz. 1977. On Equivalence and Containment
Problems for Formal Languages. J. ACM 24, 3 (July 1977), 387–396. https:
//doi.org/10.1145/322017.322020
[25] Malte Isberner, Falk Howar, and Bernhard Steffen. 2015. The Open-Source
LearnLib - A Framework for Active Automata Learning. In Computer Aided
Verification - 27th International Conference, CAV 2015, San Francisco, CA, USA,
July 18-24, 2015, Proceedings, Part I (Lecture Notes in Computer Science), Daniel
Kroening and Corina S. Pasareanu (Eds.), Vol. 9206. Springer, 487–495. https:
//doi.org/10.1007/978-3-319-21690-4_32
[26] William M McKeeman. 1998. Differential Testing for Software. 10, 1 (1998), 8.
[27] Kenneth L. McMillan and Lenore D. Zuck. 2019. Formal specification and testing
of QUIC. In Proceedings of the ACM Special Interest Group on Data Communication
(SIGCOMM ’19). Association for Computing Machinery, Beijing, China, 227–240.
https://doi.org/10.1145/3341302.3342087
[28] Maxime Piraux, Quentin De Coninck, and Olivier Bonaventure. 2018. Observing
the Evolution of QUIC Implementations. Proceedings of the Workshop on the
Evolution, Performance, and Interoperability of QUIC (Dec. 2018), 8–14. https:
//doi.org/10.1145/3284850.3284852 arXiv: 1810.09134.
[29] J. Postel. 1980. DoD standard Transmission Control Protocol.
(1980). https:
//www.rfc-editor.org/info/rfc0761 Number: RFC 761.
[30] Felix Rath, Daniel Schemmel, and Klaus Wehrle. 2018. Interoperability-Guided
Testing of QUIC Implementations Using Symbolic Execution. In Proceedings of the
Workshop on the Evolution, Performance, and Interoperability of QUIC (EPIQ’18).
Association for Computing Machinery, New York, NY, USA, 15?21. https://doi.
773
Prognosis: Closed-Box Analysis of Network Protocol Implementations
SIGCOMM ’21, August 23–27, 2021, Virtual Event, USA
Contents
The artifact bundles the learner, adapter, synthesizer, and target
implementations required to run Prognosis, as well as custom
scripting and documentation.
Hosting
The artifact’s code, scripts, and documentation are fully accessible
at: https://doi.org/10.5281/zenodo.5040974
Requirements
A device capable of running Docker and Docker Compose, as well
as x86 based images, either natively or through virtualisation.
A minimum of 8 GB of memory, recommended 16 GB for running
all experiments.
org/10.1145/3284850.3284853
[31] Martin Thomson and Jana Iyengar. [n. d.]. QUIC: A UDP-Based Multiplexed and
Secure Transport. ([n. d.]). https://tools.ietf.org/html/draft-ietf-quic-transport-29
Library Catalog: tools.ietf.org.
[32] Frits Vaandrager. 2017. Model learning. Commun. ACM 60, 2 (Jan. 2017), 86–95.
https://doi.org/10.1145/2967606
[33] Gerco van Heerdt, Clemens Kupke, Jurriaan Rot, and Alexandra Silva. 2020. Learn-
ing Weighted Automata over Principal Ideal Domains. In Foundations of Software
Science and Computation Structures - 23rd International Conference, FOSSACS 2020
(Lecture Notes in Computer Science), Jean Goubault-Larrecq and Barbara König
(Eds.), Vol. 12077. Springer, 602–621. https://doi.org/10.1007/978-3-030-45231-5_
31
Appendices are supporting material that has not been peer-reviewed.
A ARTIFACT APPENDIX
Abstract
We provide the source code and scripting to run Prognosis, as well
as re-run and verify claimed properties and results.
Scope
The artifact covers the full code and tooling used in both the devel-
opment and execution of Prognosis, as well as the source code of
its targets.
774