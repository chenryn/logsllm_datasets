protocol/protocol.pdf.
[73] G. Jaeschke. On strong pseudoprimes to several bases. Mathematics
of Computation, 61(204):915–926, 1993.
[74] M. Joye and P. Paillier. Fast generation of prime numbers on portable
devices: An update. In CHES, Oct. 2006.
[75] M. Joye, P. Paillier, and S. Vaudenay. Efﬁcient generation of prime
numbers. In CHES, Aug. 2000.
[76] B. Kaliski. RSA factoring challenge. In H. C. A. van Tilborg, editor,
Encyclopedia of Cryptography. Springer, 2005.
2090    29th USENIX Security Symposium
USENIX Association
[77] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size
commitments to polynomials and their applications. In ASIACRYPT,
Dec. 2010.
[78] A. E. Kosba, D. Papadopoulos, C. Papamanthou, M. F. Sayed, E. Shi,
and N. Triandopoulos. TRUESET: Faster veriﬁable set computations.
In USENIX Security, Aug. 2014.
[79] A. E. Kosba, C. Papamanthou, and E. Shi. xJsnark: A framework for
efﬁcient veriﬁable computation. In IEEE S&P, May 2018.
[80] J. Lee, K. Nikitin, and S. Setty. Replicated state machines without
replicated execution. In IEEE S&P, May 2020.
[81] J. Li, N. Li, and R. Xue. Universal accumulators with efﬁcient
nonmembership proofs. In ACNS, June 2007.
[82] B. Libert, S. C. Ramanna, and M. Yung. Functional commitment
schemes: From polynomial commitments to pairing-based
accumulators from simple assumptions. In ICALP, July 2016.
[83] B. Libert and M. Yung. Concise mercurial vector commitments and
independent zero-knowledge sets with short proofs. In TCC, Feb.
2010.
[84] H. Lipmaa. Secure accumulators from euclidean rings without
trusted setup. In ACNS, June 2012.
[85] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. Sonic:
Zero-knowledge SNARKs from linear-size universal and updatable
structured reference strings. In ACM CCS, Nov. 2019.
[86] Matter network. https://demo.matter-labs.io/explorer/.
[87] U. M. Maurer. Fast generation of secure RSA-moduli with almost
maximal diversity. In EUROCRYPT, Apr. 1990.
[88] U. M. Maurer. Fast generation of prime numbers and secure
public-key cryptographic parameters. Journal of Cryptology,
8(3):123–155, Sept. 1995.
[89] I. Meckler and E. Shapiro. Coda: Decentralized cryptocurrency at
scale. https://cdn.codaprotocol.com/v2/static/coda-
whitepaper-05-10-2018-0.pdf, May 2018.
[90] R. C. Merkle. A digital signature based on a conventional encryption
function. In CRYPTO, Aug. 1988.
[91] B. Möller. Algorithms for multi-exponentiation. In SAC, Aug. 2001.
[92] N. Nethercote and J. Seward. How to shadow every byte of memory
used by a program. In VEE, June 2007.
[93] L. Nguyen. Accumulators from bilinear pairings and applications. In
CT-RSA 2005, Feb. 2005.
[94] On-chain scaling to potentially ~500 tx/sec through mass tx
validation. https://ethresear.ch/t/on-chain-scaling-to-
potentially-500-tx-sec-through-mass-tx-
validation/3477.
[95] C. Papamanthou, E. Shi, and R. Tamassia. Signatures of correct
computation. In TCC, Mar. 2013.
[96] B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: Nearly
practical veriﬁable computation. In IEEE S&P, May 2013.
[97] T. P. Pedersen. Non-interactive and information-theoretic secure
veriﬁable secret sharing. In CRYPTO, Aug. 1992.
[98] M. O. Rabin. Probabilistic algorithm for testing primality. J. Number
Theory, 12(1):128–138, Feb. 1980.
[99] L. Reyzin, D. Meshkov, A. Chepurnoy, and S. Ivanov. Improving
authenticated dynamic dictionaries, with applications to
cryptocurrencies. In FC, Apr. 2017.
[100] L. Reyzin and S. Yakoubov. Efﬁcient asynchronous accumulators for
distributed PKI. In SCN, Aug. / Sept. 2016.
[101] R. L. Rivest, A. Shamir, and D. A. Wagner. Time-lock puzzles and
timed-release crypto. Technical report, MIT LCS, Mar. 1996.
[102] The RSA challenge numbers.
https://web.archive.org/web/20130921041734/http:
//www.emc.com/emc-plus/rsa-labs/historical/the-rsa-
challenge-numbers.htm.
[103] Rust programming language. https://www.rust-lang.org/.
[104] Sapling cryptography library, community edition.
https://github.com/matter-labs/sapling-crypto.
[105] S. Setty, S. Angel, T. Gupta, and J. Lee. Proving the correct execution
of concurrent services in zero-knowledge. In OSDI, Oct. 2018.
[106] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walﬁsh.
Resolving the conﬂict between generality and plausibility in veriﬁed
computation. In EuroSys, Apr. 2013.
[107] S. T. V. Setty, R. McPherson, A. J. Blumberg, and M. Walﬁsh.
Making argument systems for outsourced computation practical
(sometimes). In NDSS, Feb. 2012.
[108] S. T. V. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and
M. Walﬁsh. Taking proof-based veriﬁed computation a few steps
closer to practicality. In USENIX Security, Aug. 2012.
[109] J. Shawe-Taylor. Generating strong primes. Electronics Letters,
22(16):875–877, 1986.
[110] E. G. Straus. Addition chains of vectors (problem 5125). Amer. Math.
Monthly, 70:806–808, 1964.
[111] J. Thaler. Time-optimal interactive proofs for circuit evaluation. In
CRYPTO, Aug. 2013.
[112] J. Thaler, M. Roberts, M. Mitzenmacher, and H. Pﬁster. Veriﬁable
computation with massively parallel interactive proofs. In HotCloud,
June 2012.
[113] V. Vu, S. T. V. Setty, A. J. Blumberg, and M. Walﬁsh. A hybrid
architecture for interactive veriﬁable computation. In IEEE S&P,
May 2013.
[114] R. S. Wahby, M. Howald, S. J. Garg, a. shelat, and M. Walﬁsh.
Veriﬁable ASICs. In IEEE S&P, May 2016.
[115] R. S. Wahby, Y. Ji, A. J. Blumberg, a. shelat, J. Thaler, M. Walﬁsh,
and T. Wies. Full accounting for veriﬁable outsourcing. In ACM
CCS, Oct. / Nov. 2017.
[116] R. S. Wahby, S. T. V. Setty, Z. Ren, A. J. Blumberg, and M. Walﬁsh.
Efﬁcient RAM and control ﬂow in veriﬁable outsourced computation.
In NDSS, Feb. 2015.
[117] R. S. Wahby, I. Tzialla, a. shelat, J. Thaler, and M. Walﬁsh.
Doubly-efﬁcient zkSNARKs without trusted setup. In IEEE S&P,
May 2018.
[118] A. Waksman. A permutation network. Journal of the ACM,
15(1):159–163, Jan. 1968.
[119] M. Walﬁsh and A. J. Blumberg. Verifying computations without
reexecuting them: from theoretical possibility to near practicality.
Communications of the Association for Computing Machinery, Feb.
2015.
[120] B. Wesolowski. Efﬁcient veriﬁable delay functions. In EUROCRYPT,
May 2019.
[121] H. Wu, W. Zheng, A. Chiesa, R. A. Popa, and I. Stoica. DIZK: A
distributed zero knowledge proof system. In USENIX Security, Aug.
2018.
[122] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song. Libra:
Succinct zero-knowledge proofs with optimal prover computation. In
CRYPTO, Aug. 2019.
[123] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou.
vSQL: Verifying arbitrary SQL queries over dynamic outsourced
databases. In IEEE S&P, May 2017.
[124] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou.
vRAM: Faster veriﬁable RAM with program-independent
preprocessing. In IEEE S&P, May 2018.
USENIX Association
29th USENIX Security Symposium    2091
A Proof of MultiSwap Consistency
Let σ denote a multiset of swaps. Let inσ denote {y : (x,y) ∈
σ} and let rmσ denote {x : (x,y) ∈ σ}.
Claim 1. Let σ be a multiset of swaps and σc be
a cycle. MultiSwap(S,σ (cid:93) σc,S(cid:48)) holds if and only if
MultiSwap(S,σ,S(cid:48)) does.
Proof: We prove both directions simultaneously, by illus-
trating a bidirectional chain of mutually implicating equalities.
We start with the deﬁnition of MultiSwap(S,σ(cid:93) σc,S(cid:48)):
S(cid:48) = S(cid:93) inσ(cid:93)σc (cid:12) rmσ(cid:93)σc
S(cid:48) = S(cid:93) inσc (cid:93) inσ (cid:12) rmσc (cid:12) rmσ
properties of (cid:93), (cid:12)
Since σc is a cycle, we have that inσc = rmσc, so rmσc ⊆
S(cid:93) inσc, and the removal of rmσc can be moved earlier
S(cid:48) = S(cid:93) inσc (cid:12) rmσc (cid:93) inσ (cid:12) rmσ
S(cid:48) = S(cid:93) inσ (cid:12) rmσ
the statement
line is exactly our goal:
This last
MultiSwap(S,σ,S(cid:48)) holds.
Claim 2. If σ contains no cycles and MultiSwap(S,σ,S(cid:48))
holds, then σ is sequentially consistent with respect to S, pro-
ducing S(cid:48).
that
Proof: Let n be the number of swaps in σ. For a set S and
multiset of swaps τ, deﬁne the directed multigraph GS,τ as
a multigraph where the vertices are the universe of multiset
elements, the edges point from each removal to its corre-
sponding insertion, and each vertex is labeled with a multi-
plicity equal to to the multiplicity of that vertex’s element in
S, minus the out-degree, plus the in-degree. Observe that in
G = GS,σ, the multiplicity of each vertex is equal to the mul-
tiplicity of that element in S(cid:48). Furthermore, by the predicate
MultiSwap(S,σ,S(cid:48)) and the soundness of the proofs of inser-
tions and removal, all multiplicities in G are non-negative.
We now construct the sequentially valid ordering of σ.
Since σ has no swap cycles, G has no edge cycles. Thus,
the edges of G can be topologically sorted such that all edges
to a vertex occur before any edge from that vertex. We lift
this edge order to a swap order, observing that in this swap
order, all swaps inserting an element occur before all swaps
removing it.
It sufﬁces to show that when σ is applied to S in this order,
each swap is valid. Let σi denote the ﬁrst i elements of σ in
the aforementioned order. Thus, GS,σn is equal to G. Further-
more, the order ensures for all i > j and for all vertices v, the
multiplicity of v in GS,σi is at most the multiplicity of v in
GS,σ j. Suppose that the ith element of this order, (xi,yi) were
invalid, where i ≤ n. This implies that the multiplicity of xi
in GS,σi is negative. This would imply that the multiplicity of
xi in GS,σn = G were negative, a contradiction. Thus no swap
(xi,yi) is invalid in this order.
Proof of Lemma 1. The reverse direction follows immedi-
ately from the deﬁnition of MultiSwap.
We prove the forward direction by (strong) induction on
the size of σ. Say that σ has no cycles. Then the lemma fol-
lows from Claim 2. Otherwise, let τ be a multiset of swaps
and let σc be a cycle such that σ = τ (cid:93) σc. By Claim 1,
MultiSwap(S,τ,S(cid:48)) holds. Then, by the inductive hypothe-
sis, τ can be decomposed into cycle-free τ(cid:48) and cycles τc
i such
i and τ(cid:48) is sequentially consistent with re-
i τc
i )(cid:93) σc
i τc
is a decomposition of σ into a cycle-free swap multiset and
cycles, we conclude this direction of the proof.
that τ = τ(cid:48) (cid:93)(cid:85)
spect to S, producing S(cid:48). By observing that τ(cid:48) (cid:93) ((cid:85)
B Parameter Values
Our RSA accumulators work in G = Z×
N /{±1}, where N is
the RSA-2048 challenge number [102], N=0xc7970ceedcc3
b0754490201a7aa613cd73911081c790f5f1a8726f46355
0bb5b7ff0db8e1ea1189ec72f93d1650011bd721aeeacc2
acde32a04107f0648c2813a31f5b0b7765ff8b44b4b6ffc
93384b646eb09c7cf5e8592d40ea33c80039f35b4f14a04
b51f7bfd781be4d1673164ba8eb991c2c4d730bbbe35f59
2bdef524af7e8daefd26c66fc02c479af89d64d373f4427
09439de66ceb955f3ea37d5159f6135809f85334b5cb181
3addc80cd05609f10ac6a95ad65872c909525bdad32bc72
9592642920f24c61dc5b3c3b7923e56b16a4d9d373d8721
f24a3fc0f1b3131f55615172866bccc30f95054c824e733
a5eb6817f7bc16399d48c6361cc7e5.
We randomly selected a 2048-bit offset ∆ for our division-
intractable hash H∆ (§4.2); we use the value ∆=0xf3709c40
772816d668926cae548ffea31f49034ab1b30fb84b595ca
6c126a6646a4341abea2f8b07bf8d366801ac293e5a286a
bb43accdec39ac8f0bc599519cf1e532f9c70b5406c4b65
2ca7da4e1cb102b69953841ae20d4bcab055c5338487ba0
0fe95e821abd381b191dfb77bae3e022ccd818d4064882d
28481ffa2db45093a4deab05f6ebfbadcf11afe7369caea
aaf1f02572348a17f0510b333b8a2d56e67d892f1e1182b
26301d9347ae0a900cff2a0979caddb1a86e04a6cbc9704
d6549e5b3aef0d5c3dc4aba648ed421b0ba37c3f8e8edc1
2ef42b86d8e5fbc0dbd903238ca2e9ed6873ccb68e8103b
5d01b4249bfbe8e70cb4f4983f41df8c8f.
Our evaluation (§7) builds on the BLS12-381 elliptic
curve [27], which is the Barreto-Lynn-Scott curve [6] with pa-
rameter z = -0xd201000000010000 whose subgroup order
is p = 0x73eda753299d7d483339d80809a1d80553bda40
2fffe5bfeffffffff00000001. This is the characteristic of
the ﬁeld Fp for which we synthesize constraints.
2092    29th USENIX Security Symposium
USENIX Association