title:Towards Automatic Generation of Vulnerability-Based Signatures
author:David Brumley and
James Newsome and
Dawn Xiaodong Song and
Hao Wang and
Somesh Jha
Towards Automatic Generation of Vulnerability-Based Signatures
David Brumley, James Newsome, and Dawn Song
Hao Wang and Somesh Jha
Carnegie Mellon University
University of Wisconsin-Madison
Pittsburgh, PA, USA
{dbrumley,jnewsome,dawnsong}@cmu.edu
Madison, WI, USA
{hbwang, jha}@cs.wisc.edu
Abstract
1 Introduction
In this paper we explore the problem of creating vulner-
ability signatures. A vulnerability signature matches all ex-
ploits of a given vulnerability, even polymorphic or meta-
morphic variants. Our work departs from previous ap-
proaches by focusing on the semantics of the program and
vulnerability exercised by a sample exploit instead of the
semantics or syntax of the exploit itself. We show the se-
mantics of a vulnerability deﬁne a language which contains
all and only those inputs that exploit the vulnerability. A
vulnerability signature is a representation (e.g., a regular
expression) of the vulnerability language. Unlike exploit-
based signatures whose error rate can only be empirically
measured for known test cases, the quality of a vulnerability
signature can be formally quantiﬁed for all possible inputs.
We provide a formal deﬁnition of a vulnerability signa-
ture and investigate the computational complexity of creat-
ing and matching vulnerability signatures. We also system-
atically explore the design space of vulnerability signatures.
We identify three central issues in vulnerability-signature
creation: how a vulnerability signature represents the set
of inputs that may exercise a vulnerability, the vulnerability
coverage (i.e., number of vulnerable program paths) that is
subject to our analysis during signature creation, and how
a vulnerability signature is then created for a given repre-
sentation and coverage.
We propose new data-ﬂow analysis and novel adoption
of existing techniques such as constraint solving for au-
tomatically generating vulnerability signatures. We have
built a prototype system to test our techniques. Our experi-
ments show that we can automatically generate a vulner-
ability signature using a single exploit which is of much
higher quality than previous exploit-based signatures.
In
addition, our techniques have several other security appli-
cations, and thus may be of independent interest.
A vulnerability is a type of bug that can be used by an
attacker to alter the intended operation of the software in a
malicious way. An exploit is an actual input that triggers a
software vulnerability, typically with malicious intent and
devastating consequences. One of the most popular and ef-
fective exploit defense mechanisms is signature-based input
ﬁltering (also called content-based ﬁltering) [7, 40] . Thus,
any improvements in signature generation will likely have
widespread impact.
We need automatic signature generation techniques
because manual signature generation is slow and error
prone.
Fast generation is important because previously
unknown (“zero-day”) or unpatched vulnerabilities can be
exploited orders of magnitude faster than a human can re-
spond, such as during a worm outbreak [7, 51]. Automatic
techniques have the potential to be more accurate than man-
ual efforts because vulnerabilities tend to be complex and
require intricate knowledge of details such as realizable pro-
gram paths and corner conditions. Understanding the com-
plexities of a vulnerability has consistently proven very dif-
ﬁcult for humans at even the source code level [11], let alone
COTS software at the assembly level.
Challenges for automatically creating signatures. The
task of automatically constructing signatures is complicated
by the fact that there are usually several different polymor-
phic exploit variants that can trigger a software vulnerabil-
ity [21, 33, 43]. For example, a buffer-overrun vulnerability
in a network service may be triggered by many different
protocol messages. Another example, sometimes referred
to as metamorphism, is that exploit variants may differ syn-
tactically but be semantically equivalent [28, 52], e.g., an
exploit could use different assembly instructions that have
the same effect. Our approach does not need to distinguish
between polymorphism and metamorphism: both are re-
ferred to as polymorphism throughout this paper. Many
morphing tools are publicly available to automatically gen-
erate polymorphic exploit variants [2, 3, 21]. Thus, to be
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
effective, the signature should be constructed based on the
property of the vulnerability, instead of an exploit (this ob-
servation has been made by others as well [56]).
Limitations of previous approaches. The importance of
the signature generation problem has recently prompted
researchers to investigate automatic signature generation
techniques. Previous approaches fall into at least one of
the following categories: (a) require manual steps, (b) em-
ploy heuristics which may fail in many settings, (c) tech-
niques rely on speciﬁc properties of an exploit, e.g., return
addresses, and are thus not vulnerability signatures, (d) are
limited by the underlying signature representation they can
generate, or (e) only work for speciﬁc vulnerabilities in spe-
ciﬁc circumstances.
For example, one approach is pattern-extraction based
methods which syntactically identify bit patterns that ap-
pear in attack samples but not in innocuous samples [30,
32, 43, 50]. However, these techniques are either incapable
of handling polymorphic worms [30, 32, 50], or vulnera-
ble in an adversarial environment in which an attacker can
inject false or superﬂuous tokens, such as an over-learning
or “red-herring” attack [43]. Another approach is based on
application and exploit semantic information [35, 44, 58].
However, these techniques are heuristics-based and rely on
speciﬁc properties of the exploits such as the value used
to overwrite the return address to be invariant. It has been
shown previously these heuristics may not work in many
real-world vulnerabilities [19, 43].
In addition, previous
work along either line has not systematically explored the
design space of signature creation, instead focusing on a
single design point such as creating regular expressions
for control-hijacking attacks. Regular-expressions can only
recognize simple syntactic properties, thus may not be pre-
cise enough in many settings, e.g., regular expressions can-
not recognize a vulnerability where valid and invalid check-
sums need to be distinguished.
Our approach, roadmap, and the central issues. Our
approach departs from previous work by analyzing the vul-
nerability uncovered by a new exploit attack instead of an-
alyzing the exploit. At a high level, our main contribution
is a new class of signature, which we call a vulnerability
signature, that is not speciﬁc to details such as whether an
exploit successfully hijacks control of the program, but in-
stead whether executing an input will (potentially) result in
an unsafe execution state.
In this paper we present a formal approach for reasoning
about vulnerability signatures.
Intuitively, a vulnerability
signature matches a set of inputs (strings) which satisfy a
vulnerability condition in the program. A vulnerability con-
dition is a speciﬁcation of a particular type of program bug,
e.g., memory writes should be within the allocated buffer
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
space. We then systematically explore the design space of
vulnerability signatures, and identify two important dimen-
sions: how the signature is represented, in which there is
an expressiveness trade-off between matching accuracy and
efﬁciency, and how much of the vulnerability is covered
by the signature, in which there is a trade-off between the
amount of analysis performed and the signature false neg-
ative rate. We then develop new techniques for creating
vulnerability signatures for different representations. We
focus on three representations which highlight the inherent
accuracy, efﬁciency, and creation time trade-offs in the de-
sign space: Turing machine signatures, symbolic constraint
signatures, and regular expression signatures.
Contributions. This paper presents a systematic ap-
proach using a formal model and methods to create vul-
nerability signatures using static program analysis. We re-
quire only a single sample exploit which is used to initially
identify the vulnerability. Our automatic signature gener-
ation approach is applicable to all vulnerabilities in which
the vulnerability condition can be formally speciﬁed. Our
approach uncovers a rich new domain for representing sig-
natures and new techniques for creating them. In particular:
• We provide a formal deﬁnition for vulnerability signa-
tures. Our approach leads to a new perspective where a
vulnerability signature can be represented by different
language classes with different expressive powers.
• We explore the design space of vulnerability signa-
ture and show that there is an inherent trade-off be-
tween signature matching and accuracy for different
representations. In particular, a perfect signature can
be created (Turing machine signatures in Section 2.3),
but matching may take an unbounded amount of time.
On the other hand, signatures that allow fast match-
ing are less accurate (regular-expression signatures in
Section 2.3).
• We introduce the notion of vulnerability signature cov-
erage. As we will see, one challenge is that a vulnera-
bility may be reachable by an inﬁnite number of paths
in the program (in the presence of looping). We show
how to iteratively consider each path separately so that
signature generation can scale.
• Our methods allow us to identify where a created vul-
nerability signature approximates a perfect vulnerabil-
ity signature. Speciﬁcally, in our setting, one can iden-
tify and control when and how imprecision is intro-
duced. This property makes it easy to quantify the
quality of the generated vulnerability signature.
• We develop new static analysis techniques (such as
the regular expression data-ﬂow framework in Sec-
tion 3.4.2), and make novel adoptions of existing tech-
niques such as program chopping and constraint satis-
faction to our problem domain.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
• We provide a prototype implementation of our tech-
niques and automatically create signatures for several
real-world vulnerabilities. Our prototype addresses au-
tomatic signatures creation in one of the hardest sce-
narios: only the program binary is used. We do not
require source code or type information, and therefore
our prototype is applicable to COTS software.
• Our results show that our techniques automatically
generate signatures that are of a much higher quality
than previous techniques.
2 Vulnerability Signature
In this section we ﬁrst give a formal deﬁnition of a vul-
nerability signature. Intuitively, a vulnerability signature is
a representation for the set of inputs that satisfy a speciﬁed
vulnerability condition (vulnerability conditions are for-
mally deﬁned in Section 2.2). We then explore two dimen-
sions of the design space for vulnerability signatures: signa-
ture representation and coverage. Roughly speaking, design
points in the signature representation dimension trade-off
matching accuracy and matching efﬁciency. Design points
in the vulnerability signature creation dimension trade-off
creation time for signature coverage, i.e., how many pro-
gram paths are analyzed.
Problem setting. We motivate our work and approach to
vulnerability signatures in the following setting: a new ex-
ploit is just released for an unknown vulnerability. A site
has detected the exploit through some means such as dy-
namic taint analysis or stack protection, and wishes to cre-
ate a signature that recognizes any further exploits. The site
can furnish our analysis with the tuple {P, T, x, c} where
P is the program, x is the exploit string, c is a vulnerability
condition, and T is the execution trace of P on x. Since
our experiments are at the assembly level, we assume P is
a binary program and T is an instruction trace, though our
techniques also work at the source-code level. Our goal is
to create a vulnerability signature which will match future
malicious inputs x(cid:2) by examining them without running P.
In addition, we want to create signatures quickly since
in many scenarios signatures must be deployed almost im-
mediately after detection to be of any value. Therefore, we
take an iterative approach that generates successively bet-
ter signatures. Each successive signature will match more
exploit variants without requiring further exploit samples.
c h a r ∗ g e t u r l ( c h a r
i n p [ 1 0 ] ) {
c h a r ∗ u r l = m a l l o c ( 4 ) ;
i n t c = 0 ;
i f ( i n p [ c ]
! = ’ g ’ && i n p [ c ]
! = ’G ’ )
r e t u r n NULL ;
i n p [ c ] = ’G ’ ;
c + + ;
w h i l e ( i n p [ c ] == ’
’ )
w h i l e ( i n p [ c ]
! = ’
’ ) {
∗ u r l = i n p [ c ] ; c + + ; u r l + + ;
c + + ;
}
p r i n t f ( ‘ ‘% s ’ ’ , u r l ) ;
r e t u r n u r l ;
}
Figure 1. Our running example, which re-
turns the URL of a request of the form [g|G]
, else NULL.
assume x = g /AAAA. The corresponding trace is T =
{1, 2, 3, 4, 6, 7, 8, 9, 8, 10, 11, 10, 11, 10, 11, 10, 11, 10, 11}
where each number is the corresponding line number in
Figure 1.
The vulnerability condition is a heap over-
ﬂow, which the input x satisﬁes (i.e.,
the program is
exploited) on the 5th
iteration of line 11 since the URL is 5
characters long while only 4 characters were allocated.
2.1 Vulnerability Signature Deﬁnition
A vulnerability is 2-tuple (P, c), where P is a program
(which is a sequence of instructions (cid:3)i1, · · · , ik(cid:4)), and c is
a vulnerability condition (deﬁned formally below). The ex-
ecution trace obtained by executing a program P on input
x is denoted by T (P, x). An execution trace is simply a
sequence of actual instructions that are executed. A vul-
nerability condition c is evaluated on an execution trace T .
If T satisﬁes the vulnerability condition c, we denote it by
T |= c. The language of a vulnerability LP,c consists of
the set of all inputs x to a program P such that the resulting
execution trace satisﬁes c. Let Σ∗ be the domain of inputs
to P. Formally, LP,c is the language deﬁned by:
LP,c = {x ∈ Σ∗ | T (P, x) |= c}
Running example. Throughout
this paper, we use
the running example given in Figure 1. Our example
is in a C-like language for clarity; our implementation
operates on program binaries. The example returns the
URL when the request begins with the ’G’ or ’g’ key-
word, else NULL is returned.
In our example, we will
An exploit for a vulnerability (P, c) is simply an input
x ∈ LP,c, i.e., executing P on input x results in a trace
that satisﬁes the vulnerability condition c. A vulnerability
signature is a matching function MATCH which for an input
x returns either EXPLOIT or BENIGN without running
P. A perfect vulnerability signature satisﬁes the following
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
property:
(cid:2)
MATCH(x) =
EXPLOIT when x ∈ LP,c
BENIGN when x /∈ LP,c
As we show in Section 2.3, the language LP,c can be
represented in many different ways ranging from Turing
machines which are precise, i.e., accept exactly LP,c, to
regular expressions which may not be precise, i.e., have an
error rate.
Soundness and completeness for signatures. We deﬁne
completeness for a vulnerability signature MATCH to be
∀x : x ∈ LP,c ⇒MATCH(x) = EXPLOIT, i.e., MATCH ac-