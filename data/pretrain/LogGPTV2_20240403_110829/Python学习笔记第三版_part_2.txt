学习笔记 . 第三版
最直接的关联操作就是赋值，⽽后对名字的任何引⽤都被解释为对⽬标对象的操作。
>>> x = 100
>>> x
100
>>> x += 2
>>> x
102
赋值操作步骤：
1. 准备好右值⽬标对象（⽐如上例中的整数对象 100）。
2. 准备好名字（通常是常量，保存在特定列表⾥。⽐如 x）。
3. 在名字空间（namespace）⾥为两者建⽴关联。
即便如此，名字和⽬标对象之间也仅只是引⽤关联。名字只负责找到正确的⼈，但对于该
⼈的能⼒⼀⽆所知。鉴于在运⾏期才能知道名字引⽤的⽬标类型，所以 Python 是⼀种动
态类型语⾔。
Names have no type, but objects do.
名字空间
名字空间是上下⽂环境⾥专门⽤来存储名字和⽬标引⽤关联的容器。
x x.ref : 100.ref 100
name namespace object
对 Python ⽽⾔，每个模块（源码⽂件）都有⼀个全局名字空间（globals）。⽽根据代码
作⽤域，又有当前或本地名字空间（locals）⼀说。如果直接在模块级别执⾏，那么当前
!14
学习笔记 . 第三版
名字空间和全局名字空间相同。但在某个函数内，当前名字空间就专指函数执⾏栈帧
（stack frame）作⽤域。
名字空间默认使⽤ dict 数据结构，由多个键值对（key/value）组成。每个 key 总是唯⼀。
>>> x = 100
>>> id(globals()) # 在模块作⽤用域调⽤用。
4344493328
>>> id(locals()) # ⽐比对 ID 值，可以看到在模块级别，两者相同。
4344493328
>>> globals() # 包含模块作⽤用域名字和对象的映射关系。
{'x': 100}
>>> def test():
x = "hello, test!"
print(locals()) # 指向函数本地名字空间。
print("locals:", id(locals()))
print("globals:", id(globals())) # 指向全局名字空间。
>>> test() # 在函数作⽤用域调⽤用。
{'x': 'hello, test!'} # 此时，locals 输出函数栈帧名字空间。
locals : 4347899696 # locals <> globals。
globals: 4344493328
globals 总是指向所在模块名字空间，⽽ locals 则指向当前作⽤域环境。
全局名字空间
函数名字空间
globals()
globals() locals()
function
locals()
module
!15
学习笔记 . 第三版
在了解名字空间后，我们甚⾄可以直接通过操控名字空间来建⽴名字和对象的引⽤。这与
传统的变量定义⽅式有所不同。
并⾮所有时候都能直接操作名字空间。函数执⾏时会使⽤ FAST 缓存优化，直接修改其本地名字
空间未必有效。正常编码时，应尽可能避免有修改操作。
>>> globals()["hello"] = "hello, world!"
>>> globals()["number"] = 12345
>>> hello
'hello, world!'
>>> number
12345
在名字空间⾥，名字只是简单的字符串主键。也就是说名字⾃⾝数据结构⾥没有任何⽬标
对象信息，因为引⽤关系是名字空间字典维护的。透过名字访问⽬标对象，⽆⾮是⽤名字
作 key 去字典⾥读取 value，从⽽获得最终引⽤。也正因为如此，名字可随时重新关联另
⼀个对象，⽽不在乎其类型是否相同。
>>> x = 100
>>> x
100
>>> id(x)
4319528720
>>> globals()
{'x': 100}
>>> x = "abc" # 重新关联其他对象，没有类型限制。
>>> x
'abc'
>>> id(x) # 通过输出 id，可以看到关联新对象，⽽而⾮非修改原对象内容。
4321344792
>>> globals() # 名字空间引⽤用关系变更更。
{'x': 'abc'}
!16
学习笔记 . 第三版
赋值操作仅仅是让名字在名字空间⾥重新关联，⽽⾮修改原对象。
x 100 100
x abc
修改前 修改后
和⼀个名字只能引⽤⼀个对象不同，每个对象可以有多个名字，⽆论是在相同或不同的名
字空间⾥。
⼀个⼈在办公室⾥（名字空间）可以叫⽼王、王⼤虎，或其他什么，这是单⼀空间⾥有多个名字。
出办公室，在全公司（另⼀名字空间）范围内，还可有王处长等其他名字。
>>> x = 1234
>>> y = x # 总是按引⽤用传递。
>>> x is y # 判断是否引⽤用同⼀一对象。
True
>>> id(x) # 输出 id 值来确认上述结论。
4350620272
>>> id(y)
4350620272
>>> globals() # 1234 有两个名字。
{'x': 1234, 'y': 1234}
应使⽤ is 语句判断两个名字是否引⽤同⼀对象。相等操作符并不能确定两个名字指向同⼀
对象，这涉及到操作符重载，或许它被设定为⽐较值是否相等。
>>> a = 1234 # 请使⽤用⼤大数字。因为⼩小数字常量量会被缓存复⽤用。
>>> b = 1234
!17
学习笔记 . 第三版
>>> a is b # 指向不不同对象。
False
>>> a == b # 值相等。
True
命名规则
名字应选⽤有实际含义，易于阅读和理解的字母或单词组合。
• 必须⽤以字母或下划线开头。
• 区分⼤⼩写。
• 不能使⽤保留关键字（reserved words）。
>>> x = 1
>>> X = "abc"
>>> x is X # 区分⼤大⼩小写。
False
为统⼀命名风格，建议：
• 类型名称使⽤ CapWords 格式。
• 模块⽂件名，函数、⽅法成员等使⽤ lower_case_with_underscores 格式。
• 全局常量使⽤ UPPER_CASE_WITH_UNDERSCORES 格式。
• 避免与内置函数或标准库常⽤类型同名，易导致误解。
>>> OK = 200
>>> KEY_MIN = 10
>>> set_name = None
尽管 Python 3 ⽀持⽤中⽂字符作为名字，但从习惯上讲，这并不是好选择。
保留关键字：
False class finally is return
!18
学习笔记 . 第三版
True continue for lambda try
None def from nonlocal while
and del global not with
as elif if or yield
assert else import pass
break except in raise
提⽰：2.x ⾥的 exec、print，在 3.x ⾥已变成函数，不再是保留字。
>>> class = 100
SyntaxError: invalid syntax
如要检查动态⽣成代码是否违反保留字规则，可⽤ keyword 模块。
>>> import keyword
>>> keyword.kwlist
['False', 'None', ..., 'with', 'yield']
>>> keyword.iskeyword("is")
True
>>> keyword.iskeyword("print")
False
以下划线开头的名字，有特殊含义。
• 模块成员以单下划线开头（_x），属私有成员，不会被 “import *” 语句导⼊。
• 类型成员以双下划线开头，但⽆结尾（__x），属私有成员，会被⾃动重命名。
• 以双下划线开头和结尾（__x__），通常是系统成员，避免使⽤。
• 交互模式（shell）下，单下划线（_）返回最后⼀个表达式结果。
>>> 1 + 2 + 3
6
>>> _
6
!19
学习笔记 . 第三版
1.3 内存
没有值类型、引⽤类型之分。事实上，每个对象都很 “重”。即便是简单的整数类型，都有
⼀个标准对象头，保存类型指针和引⽤计数等信息。如果是变长类型（⽐如 str、list 等），
还会记录数据项长度，然后才是对象状态数据。
x
cnt : 2 type ptr ... 1234
y
name object
>>> x = 1234
>>> import sys
>>> sys.getsizeof(x) # Python 3 ⾥里里 int 也是变⻓长结构。
28
总是通过名字来完成 “引⽤传递”（pass-by-reference）。名字关联会增加计数，反之减少。
如删除全部名字关联，那么该对象引⽤计数归零，会被系统⾃动回收。这就是默认的引⽤
计数垃圾回收机制（Reference Counting Garbage Collector）。
关于 Python 是 pass-by-reference，还是 pass-by-value，会有⼀些不同的说法。归其原因，是因为
名字不是内存位置符号造成的。如果变量（variable）不包括名字所关联的⽬标对象，那么就是
值传递。因为传递是通过 “复制” 名字来实现的，这类似于复制指针，或许正确说法是 pass-by-
object-reference。不过在编码时，我们通常关注的是⽬标对象，⽽⾮名字⾃⾝。从这点上来说，
⽤ “引⽤传递” 更能清晰解释代码的实际意图。
基于⽴场不同，对某些问题会有不同的理论解释。有时候，反过来⽤实现来推导理论，或许更能
加深理解，更好地掌握相关知识。
>>> a = 1234
>>> b = a
>>> sys.getrefcount(a) # getrefcount ⾃自身也会通过参数引⽤用⽬目标对象，导致计数 +1 。
3
!20
学习笔记 . 第三版
>>> del a # 删除其中⼀一个名字，减少计数。
>>> sys.getrefcount(b)
2
所有对象都由内存管理系统在特定区域统⼀分配。赋值、传参，亦或是返回局部变量都⽆
需关⼼内存位置，并没有什么逃逸或者隐式复制（⽬标对象）⾏为发⽣。
基于性能考虑，像 Java、Go 这类语⾔，编译器会优先在栈（stack）上分配对象内存。但考虑到
闭包、接⼜、外部引⽤等因素，原本在栈上分配的对象可能会 “逃逸” 到堆（heap）。这势必会
延长对象⽣命周期，加⼤垃圾回收负担。所以，会有专门的逃逸分析（escape analysis），便于
优化代码和算法。
Python 虚拟机虽然也有执⾏栈的概念，但并不会在栈上为对象分配内存。从这点上来说，可以
认为所有原⽣对象（⾮ C、Cython 等扩展）都在 “堆” 上分配。
>>> a = 1234
>>> def test(b):
print(a is b) # 参数 b 和 a 都指向同⼀一对象。
>>> test(a)
True
>>> def test():
x = "hello, test"
print(id(x))
return x # 返回局部变量量。
>>> a = test() # 对⽐比 id 结果，确认局部变量量被导出。
4371868400
>>> id(a)
4371868400
将对象多个名字中的某个重新赋值，并不会影响其他名字。
>>> a = 1234
>>> b = a
!21
学习笔记 . 第三版
>>> a is b
True
>>> a = "hello" # 将 a 重新关联到字符串串对象。
>>> a is b # 此时，a、b 分别指向不不同对象。
False
>>> a
'hello'
>>> b
1234
a a hello
1234
b b 1234
修改前 修改后
>>> a = 1234
>>> def test(b):
print(b is a) # True; 此时 b 和 a 指向同⼀一对象。
b = "hello" # 在 locals 中，b 重新关联到字符串串。
print(b is a) # False; 这时 b 和 a 分道扬镳。
>>> test(a)
True
False
>>> a # 显然对 a 没有影响。
1234
注意，只有对名字赋值才会变更引⽤关系。如下⾯⽰例，函数仅仅是透过名字引⽤修改列
表对象⾃⾝，⽽并未重新关联到其他对象。
>>> a = [1, 2]
>>> def test(b):
b.append(3) # 通过名字 b 向列列表追加数据。
print(b) # 查看修改结果。
!22
学习笔记 . 第三版
>>> test(a)
[1, 2, 3]
>>> a # a 和 b 指向同⼀一对象，⾃自然也能获得 “同步” 结果。
[1, 2, 3]
弱引用
如果说，名字与⽬标对象关联构成强引⽤关系，会增加引⽤计数，会影响其⽣命周期。那
么，弱引⽤（weak reference）就是减配版，在保留引⽤的前提下，不增加计数，也不阻⽌
⽬标被回收。不过，并不是所有类型都⽀持弱引⽤。
class X:
def __del__(self): # 析构⽅方法，观察实例例被回收。
print(id(self), "dead.")
>>> a = X() # 创建实例例。