title:Enter the Hydra: Towards Principled Bug Bounties and Exploit-Resistant
Smart Contracts
author:Lorenz Breidenbach and
Philip Daian and
Florian Tramèr and
Ari Juels
Enter the Hydra: Towards Principled Bug Bounties 
and Exploit-Resistant Smart Contracts
Lorenz Breidenbach, Cornell Tech, IC3, ETH Zurich; Philip Daian, Cornell Tech, IC3;  
Florian Tramer, Stanford; Ari Juels, Cornell Tech, IC3, Jacobs Institute
https://www.usenix.org/conference/usenixsecurity18/presentation/breindenbach
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.Enter the Hydra: Towards Principled Bug Bounties and Exploit-Resistant
Smart Contracts∗
Lorenz Breidenbach
PI:EMAIL
Cornell Tech, IC3†,
ETH Z¨urich
Philip Daian
PI:EMAIL
Cornell Tech, IC3†
Florian Tram`er
PI:EMAIL
Stanford
Ari Juels
PI:EMAIL
Cornell Tech, IC3†,
Jacobs Institute
Abstract
Bug bounties are a popular tool to help prevent soft-
ware exploits. Yet, they lack rigorous principles for set-
ting bounty amounts and require high payments to attract
economically rational hackers. Rather than claim boun-
ties for serious bugs, hackers often sell or exploit them.
We present the Hydra Framework, the ﬁrst general,
principled approach to modeling and administering bug
bounties that incentivize bug disclosure. Our key idea
is an exploit gap, a program transformation that enables
runtime detection, and rewarding, of critical bugs. Our
framework transforms programs via N-of-N-version pro-
gramming, a variant of classical N-version programming
that runs multiple independent program instances.
We apply the Hydra Framework to smart contracts,
small programs that execute on blockchains. We show
how Hydra contracts greatly amplify the power of boun-
ties to incentivize bug disclosure by economically ra-
tional adversaries, establishing the ﬁrst framework for
rigorous economic evaluation of smart contract secu-
rity. We also model powerful adversaries capable of bug
withholding, exploiting race conditions in blockchains to
claim bounties before honest users can. We present Sub-
marine Commitments, a countermeasure of independent
interest that conceals transactions on blockchains.
We design a simple, automated version of the Hydra
Framework for Ethereum (ethereum.org) and imple-
ment two Hydra contracts, an ERC20 standard token and
a Monty-Hall game. We evaluate our implementation for
completeness and soundness with the ofﬁcial Ethereum
Virtual Machine test suite and live blockchain data.
1
Introduction
Despite theoretical and practical advances in code de-
velopment, software vulnerabilities remain an ineradica-
∗The ﬁrst three authors contributed equally to this work.
†Initiative for Cryptocurrencies and Contracts, initc3.org
ble security problem. Vulnerability reward programs—
a.k.a. bug bounties—have become instrumental in orga-
nizations’ security assurance strategies. These programs
offer rewards as incentives for hackers to disclose soft-
ware bugs. Unfortunately, hackers often prefer to exploit
critical vulnerabilities or sell them in gray markets.
The chief reason for this choice is that the bugs eli-
gible for large bounties are generally weaponizable vul-
nerabilities. The ﬁnancial value of critical bugs (0-days)
in gray markets may exceed bounty amounts by a fac-
tor of as much as ten to one hundred [2]. For example,
while Apple offers a maximum 200k USD bounty, a bro-
ker intermediary such as Zerodium purportedly offers 1.5
million USD for certain iPhone jailbreaks. In some cases
hackers can monetize vulnerabilities themselves for large
payouts [15, 11]. Modest bounties may thus fail to suc-
cessfully incentivize disclosure by rational actors [43].
Pricing bounties appropriately can also be hard be-
cause of a lack of research giving principled guidance.
Payments are often scheduled arbitrarily based on bug
categories and may not reﬂect bugs’ market value or im-
pact. For example, Apple offers up to 100k USD for
generic bugs deﬁned as “Extraction of conﬁdential mate-
rial protected by the Secure Enclave Processor” [43].
Finally, bounties present a problem of fair exchange.
A bounty payer does not wish to pay before reviewing
an exploit, while hackers are wary of revealing exploits
and risking non-payment (e.g., [26, 4, 54]). This uncer-
tainty creates a market inefﬁciency that limits incentives
for rational hackers to uncover vulnerabilities.
We introduce the Hydra Framework, the ﬁrst prin-
cipled approach to bug bounty administration that ad-
dresses these challenges. Our framework deters econom-
ically rational actors, including black-hat hackers, from
exploiting bugs or selling them in underground markets.
We focus on smart contracts as a use case to demonstrate
our framework’s power analytically and empirically.
USENIX Association
27th USENIX Security Symposium    1335
adversarial study and attack, smart contracts urgently
require new bug-mitigation techniques.
• Unique economic properties: A smart contract’s cryp-
tocurrency balance is often a direct measure of an ex-
ploit value. This facilitates principled bounty price set-
ting in our framework. Moreover, blockchain proto-
cols are often secured through both cryptography and
economic guarantees. For the ﬁrst time, we lift similar
economic safety guarantees to the smart-contract level,
creating programs with measurable economic security.
• Bounty automation: Application of our framework to
and by smart contracts can award bounties automati-
cally. The result is a fair exchange of bugs for boun-
ties and guaranteed payment for the ﬁrst valid submit-
ted bug. Bounties are transparent to bounty hunters
and can be adjusted dynamically to reﬂect contracts’
changing value, creating a stable bounty marketplace.
• Graceful termination: Smart contracts are not (yet)
mission critical software and can often be aborted with
minimal adverse effects, as required for NNVP. Reme-
diation of the DAO and Parity multisig attacks involved
refunding users, a mechanism considered in this paper.
We design a Hydra Framework for Ethereum and
evaluate it on two applications, an ERC20 token [55]
and a Monty Hall game [56].
In both cases, we pro-
duce three independent implementations of a common
contract speciﬁcation, using three different program-
ming languages in the Ethereum ecosystem. The Hy-
dra Framework automatically instruments these contract
“heads” so that they interact with a common Hydra meta-
contract. The meta-contract acts as a generic proxy that
delegates incoming transactions to each head in turn and
pays out a bounty in the event of a disagreement between
the heads. Our Hydra ERC20 token is deployed on the
Ethereum main network (with a 3000 USD bounty), the
ﬁrst principled, automated and trust-free bug bounty. Our
framework is applicable to over 76% of Ethereum con-
tracts in use. Our full framework code, tests, and experi-
ments are available at thehydra.io.
Major challenges. Several papers [33, 21] criticize
traditional N-version programming, observing that mul-
tiple versions of a program often exhibit correlated
faults—an ostensible hitch in our framework.
We revisit these papers and show that NNVP achieves
an appealing cost-beneﬁt trade-off, by abandoning fault-
tolerance in favor of error detection. Compared to the
majority voting scheme used in N-version programming,
partial
independence is greatly ampliﬁed by NNVP,
which requires agreement by all heads. Previous exper-
imental results in fact show that NNVP can achieve a
large exploit gap in Hydra programs. In particular, we
review high-proﬁle smart contract failures, showing that
Figure 1: Hydra program with heads f1, f2, and f3. Exam-
ple on right shows effect of bug induced by input X in f3.
The Hydra Framework. Our key idea is to build sup-
port for bug detection and bounties into software at de-
velopment time using a concept that we call an exploit
gap. This is a program transformation that makes critical
bugs detectable at runtime, but hard to exploit.
We propose an exploit gap technique that we refer to as
N-of-N-version programming (NNVP). A variant of clas-
sical N-version programming, NNVP leverages multiple
versions of a program that are independently developed,
or otherwise made heterogeneous. In the Hydra Frame-
work, these program versions, or heads, are executed in
parallel within a meta-program called a Hydra program.
In stark contrast to N-version programming’s goal of
fault tolerance (i.e., where the program attempts to pro-
duce a correct output even in the face of partial failures),
NNVP focuses on error detection and safe termination.
If heads’ outputs are identical, a Hydra program runs nor-
mally. If the outputs diverge for some input, a dangerous
state is indicated and the program aborts and pays out a
bounty. The basic idea is depicted in Figure 1.
A bug is only exploitable if it affects all Hydra heads
identically. If failures are somewhat uncorrelated across
heads, a bug in one head is thus unlikely to affect the
Hydra program as a whole. Moreover, an adversary
that breaks one head and, instead of claiming a bounty,
tries to generalize the exploit, risks preemption by hon-
est bounty hunters. We show that even when an ex-
ploit’s market value exceeds the bounty by multiple or-
ders of magnitude, economically rational hackers are in-
centivized to disclose bugs rather than attempt an exploit.
A Hydra Framework for smart contracts. We focus
on smart contracts, programs that execute on blockchains
such as Ethereum [14]. They are especially well suited
as a use case given several distinctive properties:
• Heightened vulnerability: Smart contracts are often ﬁ-
nancial instruments. Bugs usually directly affect funds,
enabling hackers to extract (pseudonymous) cryptocur-
rency, as shown by tens of millions of dollars worth of
Ethereum stolen from [15] and [11]. Smart contract
binaries are publicly visible and executable, and often
open-source. Given their high value and exposure to
1336    27th USENIX Security Symposium
USENIX Association
NNVP would have addressed many of them.
A second challenge arises in automating bug bounties
for smart contracts. Decentralized blockchain protocols
allow adversaries to perform front-running—ordering
their transactions ahead of those of honest users [51]. As
a result, a na¨ıvely implemented bounty contract is vul-
nerable to bug-withholding attacks: upon ﬁnding a bug
in one head, a hacker can withhold it and try to compro-
mise all heads to exploit the full contract. If an honest
user discovers a bug, the hacker front-runs her and claims
the bounty ﬁrst. Thus, withholding carries no cost for the
hacker, removing incentives for early disclosure.
We propose Submarine Commitments, a countermea-
sure of independent interest that temporarily conceals a
bounty claim among ordinary transactions, preventing a
hacker from observing and front-running a claim. We
formally deﬁne security for Submarine Commitments
and prove that they effectively prevent bug withholding.
Contributions. Our main contributions are:
• The Hydra Framework: We propose, analyze, and
demonstrate the ﬁrst general approach to principled
bug bounties. We introduce the idea of an exploit gap
and explore N-of-N-version programming (NNVP) as
a speciﬁc instantiation. We demonstrate the power of
NNVP Hydra programs in revisiting the N-version pro-
gramming literature and provide the ﬁrst quantiﬁable
notion of economic security for smart contracts.
• Bug withholding and Submarine Commitments: We
identify the subtle bug-withholding attack. To ana-
lyze its security, we present a strong, formal adversar-
ial model that encompasses front-running and other at-
tacks. We introduce a countermeasure of independent
interest called Submarine Commitments and prove that
it effectively prevents bug withholding. Frontrunning
is a widespread, costly ﬂaw in blockchain applications
more general than bug withholding [8] [10] [12] [51],
and Submarine Commitments provide a mitigation us-
able for exchanges, auctions, and other systems.
• Implementation: We implement a Hydra Framework
for Ethereum and instantiate it for an ERC20 token
and a Monty Hall game. We measure costs of run-
ning multi-headed contracts on-chain and showcase
Hydra’s soundness and applicability, concluding that
our framework can automatically transform the major-
ity (76%) of contracts used in Ethereum while passing
all ofﬁcial virtual machine tests. Our bounty-backed,
three-headed Hydra ERC20 token is live on Ethereum.
2 Preliminaries and Notation
Programs. Let f denote a stateful program. From a
state s, running f on input x produces output y and up-
dates s. For an input sequence X = [x1,x2, . . . ], we denote
by run( f ,X) := [y1,y2, . . . ] a serial execution trace of f
starting at the initial state and outputting yi on input xi.
Exploits. For a program f , let I be an abstract ideal
program that deﬁnes f ’s intended behavior. I.e., for any
input X, run(I,X) is the correct output. The input space
is assumed to be bounded and input sequences are ﬁnite.
We assume that a program may produce a fallback out-
put ⊥ if it detects that the execution is diverging from in-
tended behavior (e.g., throwing an exception on a stack
overﬂow). The ideal program I never outputs ⊥. If a pro-
gram f outputs ⊥ on some input xi, then all subsequent
outputs in that execution trace will also be fallbacks. A
program’s execution trace is a fallback trace if it agrees
with the ideal program up to some input xi, and then out-
puts ⊥. Let A (cid:64) B denote that sequence A is a strict preﬁx
of sequence B. The set of fallback traces is then
Y⊥ :=(cid:8)Y | ∃i.[y1, . . . ,yi] (cid:64) run(I,X)∧(cid:86)n
j=i+1(y j = ⊥)(cid:9) ,
We deﬁne an exploit against f as any input sequence X
for which f ’s output is neither that of the ideal program
If E( f ,I) denotes the exploit set
nor a fallback trace.
of f with respect to I, then X ∈ E( f ,I) if and only if
run( f ,X) (cid:54)∈ Y⊥ ∪ {run(I,X)}. Note that the notions of
ideal program, fallback output, and exploit are oblivious
to the representation of the program’s internal state.
Exploit gaps and bug bounties. A program transfor-
mation T combines N ≥ 1 programs into a program
f ∗ := T( f1, f2, . . . , fN). Our notion of exploit gap aims
to capture the idea that f ∗ has fewer exploits than the
original fi. However, directly relating the sizes |E( f ∗,I)|
and |E( fi,I)| is problematic as these quantities are hard
to measure. Instead, we deﬁne a probabilistic notion of
exploit gap, for input sequences sampled from a distribu-
tion D (e.g., the distribution of user inputs to a program).
Deﬁnition 1 (Exploit Gap). A program transformation
T( f1, f2, . . . , fN) := f ∗ introduces an afﬁrmative exploit