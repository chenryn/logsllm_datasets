## Page 345
Substitution运算符
319
运算元replacement
The Replacement Operand
在普通s/…..…./中，replacement紧跟在regex之后；m/…./使用两个分隔符，而这里要使用
3个。如果正则表达式使用对称的分隔符（例如），则replacement有自己的一对分隔符
（这样总共就有4个分隔符）。举例来说，s（….)）（.)和s[…].…./和s.…·都是合法的。
这种情况下，两对分隔符可以用空白字符分隔，如果使用了空白字符，还可以添加注释。
对称的分隔符通常在/x或/e中使用。
$text =~ 8{
...复杂的表达式，大量的注释，以及...
...对一段Perl代码求值，把结果作为replacement..
}ex;
请注意区分regex和replacement。regex会按照正则表达式的方式来解析，有自己的分隔符
(291）。replacement则会当作普通的双引号字符串来解析和求值（evaluate)。求值会在
匹配之后进行（如果使用了/g，每次匹配之后都会求值），所以$1之类的变量能够指向对应
的匹配内容。
在下面两种情况下，replacement不会按照双引号字符串来解析：
replacement的分隔符是单引号，此时作为单引号字符串，不会进行变量插值。
使用了/e修饰符（下一节讨论），replacement会作为一小段Perl代码而不是双引号字
符串。这一小段Perl代码会在每次匹配之后执行，结果作为replacement。
/e修饰符
The /e Modifier
/e修饰符会把replacement作为一段Perl代码来进行求值，这就类似eval（·}。代码装载
时，首先会检查这段代码的语法，确保没有错误，但是每次匹配之后都会对代码重新求值。
每次匹配之后，replacement都会在scalarcontext中重新求值，结果作为replacement。下面
有个简单的例子：
Stext=~B/-time-/localtime/ge;
在scalarcontext中，它会用Perl的1ocaltime函数的结果（也就是返回表示当前时间的文
本，例如“MonSep2518:36:512006"）替换'-time-l。
因为求值是每次匹配之后进行的，我们可以通过S1等变量引用匹配的内容。例如，URL中
---
## Page 346
320
第7章：Perl
测验答案
318页测验的答案
318页代码的结果：
WHILE stooge is Larry.
WHILE stooge is Curly.
WHILE stooge is Moe.
IF stooge is Larry.
FOREACH stooge is Moe.
FOREACH stooge is Moe.
FOREACH stooge is Moe.
请注意，如果foreach循环中的print引用了S_而不是S&，结果就会与while的一
样。在这个foreach中，m/…/g返回的（'Larry'，‘Curly'，‘Moe'）并没有使用。
相反倒是使用了伴随效应中的S&，这表示程序有错误，因为listcontext的伴随效应，
m/.../g并不常用。
不容许出现的特殊字符，可以编码为百分号“%”加两位十六进制数的形式。为了编码所有
这种字符，可以这样：
$ur1 =~s/([~a-zA-20-9）)/sprintf(*%%%02x',ord($1))/ge;
下面的程序可以用来解码：
Surl =~ s/（[0-9a-f][0-9a-f])/pack("C",hex($1))/ige;
简单地说，Bprintf（%%%02x'，ord（character））把字符转换为对应的URL编码，而
pack（"c"，value）的作用相反，请参考你常用的Perl文档获取更多信息。
多次使用/e
通常情况下，对单个运算符多次使用同一修饰符没有特殊意义（只有让读者更困惑），但是
重复/e修饰符却会改变replacement的替换过程。正常情况下，replacement会进行一次求值，
但是如果“e’的数目多于1个，则Perl又会对求值的结果进行求值，如此一直进行下去，
求值的次数与‘e’的数目一样多。或许它的主要价值是用作比较Perl代码复杂性的测试。
不过此功能并非完全无用。如果需要手动进行变量插值（例如从配置文件读入字符事）。也
就是说，有一个字符串‘…·Svar.…'，我们希望把‘Svar’替换为svar的值。
---
## Page 347
Split运算符
321
简单的办法是：
$data s~ s/(\S[a-zA-Z_]\w*)/$1/eeg;
如果不使用/e，则会替换匹配的‘Svar’自身，这没什么用。使用一个/e，会对s1重新求
值，得到‘Svar’，这样也没什么意义，同样是用匹配的文本替换自身。但是如果使用两个
/e，则‘Svar’会重新求值，得到内容，这样就模拟了变量插值。
应用场合与返回值
ContextandReturnValue
根据context和/g的不同组合，match运算符会返回不同的值。不过，substitution运算符
没有这么复杂一它返回的要么是替换发生的次数，要么是空字符串，表示没有发生任何
替换。
为使用方便，返回值为Boolean时（例如在if条件语句中），只要发生了替换，返回值就为
true，false表示没发生替换。
Split运算符
TlieSplit Operator
功能多样的split运算符（在不那么严格的时候，人们通常称其为函数）常被视为listcontext
中m/./g（311）的对立物。后者返回表达式匹配的文本，而sp1it返回由表达式匹配
的文本分隔的文本。把$text=~m/：/g应用到·I0.sYS：225558：95-10-03：-a-Bh:optiona1
中，返回四个元素的list：
（.：..：.·：，·：.）
这似平没什么用，但是Bplit（/：/，$text）返回5个元素的list：
两个例子都告诉我们，：匹配了4次。使用split，这4次匹配把目标字符串的副本分隔为
5段，返回包含5个字符串的list。
这个例子只用单个字符分隔目标字符串，其实我们可以使用任何正则表达式：
@Paragraphs=split(m/\s*\s*/i,Shtml);
它会按照或者（两边可能有空白字符）把shtm1中的HTML代码分隔开来。你甚至
可以按位置分隔：
@Lines = split(m/~/m, $lines);
把字符串按行切分。
对最简单形式的数据来说，Split非常有用也很容易理解。不过，因为存在许多参数、特
---
## Page 348
322
第7章：Perl
殊情况和特殊情形，事情会变得复杂。在深入这些细节之前，先给出两个特别有用的例子：
·特殊的match运算符//，会把目标字符串切分为单个字符，也就是说，Bplit（//，
"ghorttegt"）得到10个元素的list：（"s"，“h"，“o"，·..，"B"，"t"）。
）
切分，等于使用m/\s+/，只是会忽略开头和结尾的空白字符。这样，Bplit（""，
，，，申（...o...
稍后讨论各种特殊情况，我们先来看基础的部分。
Split基础知识
Basic Split
split运算符看起来像函数，它接收3个参数：
split(match operand，target string. chunk-limit operand)
括号是可选的，未提供的运算元会设置为默认值（本节稍后讨论)。
split总是在listcontext中使用，常用的模式包括：
@array=split(...);
for my $item(split(…-)）{
）
match运算元
运算元match有几种特殊情况，不过它通常等价于match操作中的regex运算元。也就是
说，你可以使用/…/和m{)之类的形式，它可以是regex对象，或者任何能够求值为字符
串的表达式。它只支持第292页介绍的核心修饰符。
如果继续要用括号来分组，请务必使用非捕获型括号（？：")。我们稍后将会看到，在split
中使用捕获型括号会触发极特殊的功能。
targetstring运算元
targetstring只用于检测，绝不会被修改。如果没有设定，默认使用s_。
---
## Page 349
Split运算符
323
chunk-limit运算元
chunk-limit运算元的主要功能是设定split切分字符事的数目上限。对上面的例子中同样
的目标字符串调用split（/:/，$text，3）得到：
('I0.SYS','225558','95-10-03:-a-sh:optiona1')
这告诉我们，/：/匹配两次之后sp1it会终止，产生所需的3段。它可能可以匹配更多的次
数，但这里不需要，因为存在段的数目限制。设定的数目将作为上限，所以最多只能返回
规定数目的元素（除非正则表达式包含捕获型括号，后文会论及）。得到的元素数目可能少
于上限，如果得到的分段少于规定的数目，也不会有多余的内容来“填充”。对于示例所用
的数据，aplit（/:/，$text，29)返回的list只有5个元素。不过，split（/:/，$text)
和ap1it（/：/，$text，99）有重要的区别，这里暂时还看不出来一-请记住这一点，稍后
我们会仔细讲解。
记住，chunk-limit运算元指向的是各匹配之间的分段，而不是匹配的数目本身。否则，前面
那个上限为3的例子就应该得到这个：
这不是程序运行的结果。
这里谈谈效率：假设只希望取开头的几个元素，例如：
（Sfilename,$size,$date）=split(/:/,$text);
为了提高效率，在需要的元素赋值之后，Perl会停止split操作。它会自动把chunk-limit
设置为list的元素个数+1。
深入split
从我们接触过的例子来看，Sp1it很容易使用，但有三个特殊的问题增加了它实践起来的
复杂程度：
·返回空元素。
·
特殊的regex运算符。
·
包含捕获型括号的regex。
下面分别讨论。
制
---
## Page 350
324
第7章：Perl
返回空元素
Rehurning Empty Elements
sp1it的基本功能是返回由各个匹配分隔的分本，但有的时候，返回的文本是空字符串（长
度为0的字符串，例如""），比如：
@nums = sp1it(m/:/,"12:3478*)
它返回：
("12°, "34*,**, "78")
正则表达式：匹配了3次，所以应当返回4个元素。第3个元素为空，表示正则表达式在
一行中匹配了两次，它们之间没有文本。
结尾的空元素
通常情况下，结尾的空元素不会返回，例如：
²/）s=su
同样会返回4个元素：
("12"，“34"，*"，*78*)
即使这个正则表达式在字符串的末尾能匹配更多的次数，结果也没有变化。在默认情况下，
split不会返回list末尾的空元素。不过，我们可以通过设定chunk-limit运算元，让split
返回所有的末尾元素。
chunk-limit运算元的次要职能
chunk-limit的主要用途是设定分段数目的上限，任何不等于0的chunk-limit都会保留末尾
的空元素（chunk-limit设置为零等价于不设置chunk-limit）。如果你不希望限制返回的chunk
的数目，但是希望保留末尾的空元素，只需要设置一个非常大的限制即可。或者更好的办
法是，设置为-1，因为chunk-limit为负数表示一个足够大的上限：8plit（/：/，$text，-1）
会返回所有的元素，包括末尾的空元素。
另一个极端是，如果你不希望保留任何空元素，可以在split之前使用grep(length)。使
用grep之后，只会返回长度不为0的元素（也就是说，非空元素）。
my @NonEmpty=grep（length）split(/:/.$text）;
字符串末尾的特殊匹配
在字符串开头的匹配会产生一个空元素：
@nums = split(m/:/,“123478)
---
## Page 351
Split运算符
325
@num的值为：
(""，“12*，“34"，"",*78*)
开始的空元素表明，正则表达式在字符串的开头能够匹配。不过也有例外，如果一个正则
表达式没有匹配任何文本，如果它在字符串的开头或者结尾匹配，那么开头和/或结尾的空
元素将不会生成。来看个简单的例子：Bplit（/\b/，"aBimpleteet"），它能够匹配其
中的6个位置‘asimpletest”。即使它能匹配6次，也不会返回7个元素，而是5
个元素：（"a"，""，"Bimple"，""，“test"）。其实，这种特殊情况我们已经见过，即
第321页的@Lines=split（m/^/m，$1ines）。
Split中的特殊Regex运算元
Split‘sSpecialRegexOperands
split的match运算元通常就是正则文字或者regex对象，这与match运算符的情况一样，
不过也有例外：
regex为空的意思不是“使用当前的默认正则表达式”，而是把目标字符串分割为字符。
在刚开始讨论split的时候我们见过这个例子，8plit（//，“Bhorttest")返回10
个元素的list：（"s"，"h"，"o"，，"s"，"t"）。
如果match运算元是由单个空格构成的字符串（而不是正则表达式），则是另一种特殊
情况。它基本等同与/s+/，只是会忽略开头的空白字符。这主要是为了模拟awk对
输人进行的默认的输入-记录-分隔（input-record-separator）操作，尽管对普通情况来说
它也很有用。
如果希望保留开头的空白字符，可以直接使用m/\S+/。如果希望保留末尾的空白字符，
只需要把chunk-limit设置为-1。
如果没有设置regex运算元，则默认使用一个空格符（上面提到的特殊情况）。这样，
不带任何运算元的split就等价于aplit（"'，$_，0）。
如果regex为，会自动使用修饰符/m（增强型行锚点匹配模式）。（因为某些原因，Si
则不行）。因为明确使用m/~/m非常容易，我推荐这种更清晰的写法。m/~/m是把包含
多行文本的字符串按行切分的简便方法。
Split不产生伴随效应
请注意，split的match运算元看起来很像普通的match运算符，但是它没有任何伴随效应。
split中的正则表达式不会影响到之后的match或是substitution操作所用的默认正则表达
---
## Page 352
326
第7章：Perl
式，也不会设置s&、$'、$1之类的变量。Split在伴随效应上完全独立于程序的其他部分
（注8）。
Split中带捕获型括号的match运算元
SplitsMatclOperand witli CapturingParentheses
捕获型括号会从整体上改变split。一旦使用了捕获型括号，返回的list中会多出些独立的