attacker-controlled memory.
Having successfully placed the required string into an
accessible portion of memory, the ﬁnal step is to craft the
call that utilizes this string to spawn a root shell. To do this,
a execlp@plt call is used, as in §III-B2. Listing 4 shows
the execlp portion of the exploit.
The execlp@plt is the .text memory location of
execlp@plt, the random bytes on line 2 is utilized as a
spacer, since x86 architecture skips 4 bytes when looking
for arguments on the stack, followed by the memory location
of the string we copied into .bss and a memory equivalent
NULL argument. The full ROP exploit code is successful in
spawning a root shell on the target machine.
2) ARMv7: As with x86, we utilize ROP for our ASLR
bypass on the Raspberry Pi. The general structure of the
exploit is the same as in §III-C1 (we locate the required
gadgets, copy the needed string into the .bss portion of
Connman’s memory using memcpy, and call execlp@plt).
However, there are three major differences.
First, ARMv7 arguments must be loaded into registers.
This is addressed in the same manner as in §III-C1. As
previously stated, memcpy takes three arguments: dest, src,
and length. Therefore, the same gadget as §III-C1 is utilized
to load the proper arguments into registers r0, r1, and r2,
respectively. The source of these arguments is the same as the
x86 exploit, although on ARMv7 .bss+4 is used.
Second, the length of the gadget required makes copying
the full /bin/sh string impossible. The length of the gadget
prevents more than three calls from executing, as after the
third call in the ROP chain the exploit is overwritten by data
from a subsequent legitimate function reference. If attempting
to copy the full /bin/sh string, the exploit terminates after
copying /bi and a SIGSEV occurs. However, as mentioned
previously, execlp@plt has the ability to use relative ﬁle
addresses. This allows us to copy only sh into the .bss
portion of memory,
leaving one function call available to
reference execlp@plt.
The ﬁnal and most challenging difference is the lack of
a ret; function in ARMv7 assembly. In §III-B2, we use
a pop pc command to invoke execlp@plt. A pop pc
command will not by itself return to the previous location.
Instead, ARMv7 utilizes branch-link calls, such as bl (branch-
link) or blx (branch-link-exchange) [55]. Branch-link stores
the address of the next instruction from the call in r14,
also known as the lr or link register, and changes program
execution to the passed memory location. The called function
can then return to the previous location using a branch
command (b or bx), or if necessary push the value of r14 to
the stack, and return using a pop pc command. A suitable
gadget has to be found to facilitate this behavior in our exploit.
We ﬁnd a blx r3 gadget in Connman that branch-links to
the value stored in r3. We load r3 with the memory location
of execlp@plt and the pc register with the blx r3 gad
get.
. . .
+ ’\xb1\x12\x01\x00 ’ #Pop r0−r7 , pc
+ ’\ xc4\x9d\x0b\x00 ’ #1 r0 , b s s +4
+ ’\x68\x01\x01\x00 ’ #2 r1 ,
’ s ’
+ ’\x01\x00\x00\x00 ’ #3 r2 i n t =1
+ ’\x98\xb7\x01\x00 ’ #4 r3 = memcpy@plt
+ ’\ xc4\xd2\ x f f \ x7e ’ #5 r4
+ ’\x59\x58\ xf0\x76 ’ #6 r5
+ ’\x00\x00\x00\x00 ’ #7 r6 − a l l p l a c e h o l d e r s
+ ’\x1d\ xc3\x01\x00 ’ #8 pc t o b l x r3
+ ’\x00\x00\x00\x00 ’ # o f f s e t
i n p a r s e r r
t o p r e v e n t
s i g s e v
c h a r a c t e r s
f o r
b l x
Listing 5. memcpy chain ROP exploit
1
2
3
4
5
6
7
8
9
10
251
The code to copy the string into .bss is a repeated
occurrence of the contents of Listing 5, as described below.
On Line 1, the same gadget for loading the registers is
used as in §III-B2. The gadget loads register r0 (Line 2) with
the destination argument for memcpy, in our case .bss+4.
We then load r1 (Line 3) with the source argument for
memcpy, in this snippet the location of an ’s’ character in the
.text portion of Connman’s memory. Next, the gadget loads
Register r2 (Line 4) with the length argument for memcpy,
an integer of value 1. Lastly, we load r3 (Line 5) with the
memory address of memcpy@plt. We again load r5, r6,
and r7 with placeholders to prevent SIGSEV in parse_rr.
loads the pc with the memory
location of the gadget blx {r3} which itself branches to the
location stored in r3, memcpy@plt. The ﬁnal NULL bytes
on line 10 are an offset for blx, which attempts to return to
4 bytes after its calling in our scenario.
On Line 9,
the gadget
Following a string of these calls to put "sh" into the .bss,
we make a call to execlp@plt in the same manner as in
Listing 2, with the exception of placing the address of bss+4
in Line 2.
This exploit is successful in spawning a root shell under
multiple circumstances, with or without the aid of gdb. We are
able to exploit Connman with ASLR enabled as per system
default settings after boot, and with the developer default
CFLAGS enabled. This exploit is successful with no changes
to the compilation of Connman, the system ASLR or other
settings, or the Connman code.
D. Wi-Fi Pineapple
Having successfully bypassed the targeted protection mech-
anisms, our next experiments focus on conducting the attack
remotely with a man-in-the-middle DNS server. To accomplish
this, we use a Wi-Fi Pineapple [32] to mimic a malicious
access point. The Wi-Fi Pineapple is a mobile access point
designed for network reconnaissance and penetration testing.
With the Pineapple, we simulate a speciﬁc class of attacks that
can trigger this vulnerability, namely using a rogue access
point or hijacking device trafﬁc. However, this vulnerability
can be triggered by other classes of attacks. For instance, an
attacker can use a malicious domain and lure a target user
to their site, then use the domain’s DNS server to respond to
queries with the exploit code. A cache poisoning attack could
be used to force trafﬁc to a domain, at which point exploit code
designed to create a botnet could be sent to visitors, allowing
a recreation of the Mirai attack from 2016 [10].
With the Wi-Fi Pineapple, we ﬁrst
remotely exploit
Connman on the x86 architecture. The goal of this experi-
ment is to perform the exploit in conditions similar to those
a malicious adversary might use. We set the Pineapple to
broadcast a trusted network SSID, and conﬁgure it to utilize
DHCP to assign our malicious DNS server to clients. The
Wi-Fi Pineapple is able to broadcast a stronger signal than the
legitimate access point, causing our targeted machine to switch
its connection. Once this had been achieved, the malicious
DNS server is able to intercept all DNS requests being sent
from the target machine, and provides responses containing
the exploit code. On the x86 architecture, the only attack we
attempt is the basic stack smash, as a proof of feasibility for
the man-in-the-middle setup.
Once we show the Pineapple is able to be used as a man-in-
the-middle DNS server, we perform all three ARMv7 exploits
against the Raspberry Pi with no conﬁguration changes
except connecting to the SSID broadcast by the Pineapple.
The only network conﬁguration set in the Raspberry Pi
under Ubuntu Mate is to utilize DHCP and automatic DNS
server via DHCP. All three ARMv7 exploits are successful
under these conditions.
The most
IV. SUGGESTED MITIGATIONS
immediate mitigation for memory corruption
vulnerabilities is patching. However, this puts the onus on the
code-producer to remedy the issue and ensure a critical mass
of devices are updated by users, an obligation developers and
users have struggled with in the past.
Hardware-supported control ﬂow integrity (CFI) techniques
(e.g., [56]) show promise towards securing IoT ﬁrmware
against code-reuse attacks, such as the ones we demonstrate.
Hardware-supported security has now been widely introduced
in many embedded architectures. For example, TrustZone [57],
ARM’s hardware-based security technology (ARM spans 60%
of the current embedded device market [58]), is being adapted
into most ARM processor families, and TrustZone-enabled
devices are expected to reach 1 Trillion by 2035 [59]. Intel
and AMD have also introduced similar technologies [60],
[61]. As the next step in our research, we plan to adapt the
CFICaRE [56] technique to our IoT devices running Connman
to gauge the efﬁcacy of protection against code-reuse attacks
we created, and extend the approach if necessary.
(cf.,
Artiﬁcial software diversity (ASD)
[62]) protects
against code-reuse attacks through adding probabilistic pro-
tection to a binary by randomizing program implementa-
tions (i.e., randomizing program data space or control-ﬂow
sequences) [62]. This probabilistic protection implies that
a successful attack is not guaranteed to work on multiple
systems, preventing mass attacks from occurring.
Amongst artiﬁcial software diversity techniques, compile-
time software diversity (cf., [63]) might be best suited for IoT
devices. Compile-time software diversity moves the additional
performance overhead away from the IoT device and into the
developer’s space, limiting the impact on device performance.
In particular, code-sequence randomization [63], which makes
use of standard code-rewriting compilation time techniques
such as call-inlining and instruction scheduling, and modiﬁes
them so that
the output binary is randomized from one
compilation to the next, requires minimal code-producer and
code-user cooperation to implement, making it ideal for the
“it just works” mindset of IoT.
Equivalent-instruction randomization [62] is another ASD
technique that takes advantage of semantically-equivalent in-
struction sets to randomize binaries. An equivalent-instruction
randomization framework for IoT ﬁrmware is currently under
252
development at UNC Charlotte. Speciﬁcally, we are using a
combination of equivalent-instruction randomization and other
randomization techniques to randomize compiled programs
into dynamically equivalent binaries.
V. ADAPTING FOR OTHER VULNERABILITIES
Our code can work out-of-the-box (with minimal mod-
iﬁcation) against DNS-based overﬂow vulnerabilities such
as CVE-2017-14493, CVE-2018-9445 and CVE-2018-19278.
CVE-2017-14493 and CVE-2018-9445 are stack-based buffer-
overﬂows in dnsmasq and systemd, respectively. CVE-
2018-19278 is a buffer-overﬂow vulnerability in DNS handling
in the Digium Asterisk service. Minimal modiﬁcation includes
basic changes such as changing variables to memory addresses
suitable for the targeted vulnerability.
With moderate modiﬁcation, our code can be adapted to
work against a range of protocol-based vulnerabilities. Our
code is designed to deliver a payload from a DNS server. How-
ever, by modifying the packet creation algorithm, along with
previously discussed modiﬁcations, overﬂows in other proto-
cols can be targeted. For example, CVE-2019-8985, CVE-
2019-9125, CVE-2018-6692 (buffer-overﬂow vulnerabilities
exploitable with HTTP packets) and CVE-2018-20410 (buffer-
overﬂow vulnerability triggered by a crafted TCP packet) can
be exploited by a modiﬁed version of our code. In theory, any
protocol-based overﬂow vulnerability is susceptible, as long
as the code is modiﬁed to craft the appropriate packet, rather
than a DNS packet, and the memory values are changed to
the appropriate context for the targeted vulnerability.
Our general exploit generation and delivery approach can
be used for a wide variety of exploits. Our exploit generation
approach includes methods for examining program memory
to determine the standard behavior of the targeted function,
ascertaining the behavior of the targeted function after passing
it corrupted code, and discovering potential exploit path-
ways within the program (e.g., discovering gadgets within
the program that can be called for a code-reuse attack), as
described in §III. Our novel delivery approach of using the
Wi-Fi Pineapple (which facilitates the often formidable task of
allowing control of a devices communication pathway without
compromising the targeted LAN) can be used effectively
in other exploits widely. In theory, any memory-corruption
vulnerability exploitable from a remote posture would be able
to use our approach.
VI. RELATED WORK
Numerous related works address security issues in embed-
ded systems, and many academic papers attempt to enhance
the security of these systems (e.g., [64–72]). However, most
of these concern cryptographic properties (e.g. conﬁdentiality,
integrity, authentication) and hence do not address the problem
of buffer overﬂow attacks speciﬁcally.
Several works in the literature address defenses for memory-
corruption vulnerabilities (including in traditional software),
such as CFI; we discuss these in detail in §IV.
Other works attempt to make C a safer language (e.g.,
AddressSanitizer [73] and SAFECode [?]). These approaches
utilize array-bound checks (tests performed at run-time to
ensure array accesses are safe) and usually involve two steps.
First, they scan the instruction set of the program for vul-
nerabilities, then insert array-bounds checks at the vulnerable
regions. While these approaches are effective at deterring out-
of-bound memory access, they impose signiﬁcant overhead on
compiled programs, which is incompatible as-is for IoT. For
instance, AddressSanitizer slows programs by more than 70%,