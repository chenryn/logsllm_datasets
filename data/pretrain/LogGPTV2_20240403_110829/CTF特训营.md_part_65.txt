k[17]=ri_sbox（k[13]);
15.
k{18]^=rj_sbox（k[14]);
16.
k[19]=ri_sbox(k[15]);
17.
18.
for (i = 12;i > 0; i-=4){
19.
k[i+0]^=k{i-4]；
20.
k[i+1]=k{i-3]；
21.
ki+2]=k{i-2]；
22.
k[i+3]=k[i-1];
23.
24.
25.
*rc=（uint8_t)（*rc>1）^（（*rc&1）?0x8d:0））;
26.
k[0]^=rj_sbox(k[29])^（*rc);
27.
k[1]^=rj_sbox(k[30]);
28.
k[2]^=ri_sbox(k[31]）);
29.
k[3]^=ri_sbox(k[28]);
30.}
5.KnownHighBitsMessageAttack
选项3-6中还隐藏着一种攻击方法，因为flag只有256bit，前面
padding了256bit的1，那么实际可以看为512个0和256个1是已知的，
也就是说，如果将明文视为1024bit，那么其实前768bit是已知的，由
512个0和256个1组成。再爆破1个bit即可完成密文高bit位泄露攻击。
6.检查与修补
---
## Page 793
CTF特训营：技术详解、解题方法与
22.3 Revolver
793/1144
因为题目中出现的公钥对于checker来说均有私钥与之对应，所
以使用私钥进行检查可以保证密码学考点的完整性和不可破坏性。因
此该题主要是使用私钥去解密key，然后验证flag。下面主要对4个功
能进行check，代码如下：
1.def checker_main(target,flag_ssh):
2.
if exp_1(target)==False:
345
returnFalse,hb_len_modify ERROR
if exp_2（target,flag_ssh)==False
returnFalse,e3rsa_or_rule_modify ERROR"
6.
ifexp_3（target,flag_ssh)==False
7.
returnFalse,backdoor_rsa_aeskey_flag ERROR"
8.
if exp_4(target)==False:
9.
returnFalse,"roundkey_leakERROR
10.
return True,"OK
检查的内容具体如下。
1）首先，flag是读进来的，为了保证flag的open不会被篡改，并
且在checker拥有私钥的前提下，进行如下操作：获取flag的密文（被
AES256加密），获取AES256的key的密文（被RSA加密），使用私钥
解密key，使用key解密flag，使用paramikossh登录gamebox并cat
flag，验证两个flag是否相等。通过以上步骤，可以保证flag在内存中
是确实存在的。
2）保证所有攻击流程不会被篡改：在拥有私钥的前提下，所有
---
## Page 794
CTF特训营：技术详解、解题方法与
22.3 Revolver
794/1144
攻击流程的每一个步骤都可以进行完整的验证，思路非常简单，以正
常数据（比如不会越界的数据）走完攻击流程，并用私钥解密，观察
flag与ssh获取的flag是否相同。
3）读取了不连续的aes轮密钥进行检查。
综上所述，patch方法必须非常精确，否则会checkdown。修补
方法具体如下：
1）修改程序中造成OOBWrite的size，将48改为16即可；
2）需要保证不能拿到连续的两个轮密钥，对输入进行限制或者
返回错误的轮密钥；
3）修改padding，使高bit不可知。
---
## Page 795
CTF特训营：技术详解、解题方法与
22.4 Railgun
795/1144
22.4  Railgun
这是XCTF2018Final的AD题目，题目的类型为PWN+Crypto，提
供了note式交互页面，具有如下关键数据。
玩家描述description，开始的时候输入，是个指针malloc存储。
玩家姓名playerbss，开始的时候输入。
剩余硬币数量coinbss，初始为o，uint型，可以被整型溢出。
boss的个数。
10个boss的结构体数组，初始化直接生成，10个malloc，结构
体所有数据初始化。结构体中包含怪物所用AES的key，怪物等级
怪物存活。
一套RSA，初始化直接生成，p、q、e、d和n。
一套用于检查的RSA，固定n和e，checker知道p和q。
评论地址。
关键note操作如下所示。
---
## Page 796
CTF特训营：技术详解、解题方法与
22.4Railgun
796/1144
1）程序加载：最开始要过一个pow（否则生成RSA的素数消耗
的资源过大），过完之后开始各种初始化，并输入玩家姓名，
2）操作1，modify。修改玩家姓名（存在nullbyteoffbyone）。
3）操作2，mining。挖掘coin（coin+=1可以直接撞）。
4）操作3，status。根据bossnumber打印怪物状态，打印公钥。
5）操作4，Index。获取flag选项，读取flag，在后面填充足够数
量的随机字符串，然后使用RSA一套对flag进行加密，然后打印密
文。
6）操作5，railgun。攻击怪物，选择一个怪物，接受一个密文
使用d解密，对解密结果的后6位使用该怪物的AES的key进行AES
ECB加密，询问是否消耗1个硬币，若消耗，则给出密文，询问是否
消耗1个硬币（这里不进行硬币余额的判断），若消耗1个硬币，则将
怪物存活状态改为击杀。
7）操作6，accelerator。技能，花费200个硬币，可以释放掉第
十个boss，boss个数=9（boss个数=9的时候不能使用该操作）。
8）操作7，comment。评论，malloc一块内存，然后填入评论
---
## Page 797
CTF特训营：技术详解、解题方法与
22.4Railgun
797/1144
自己输入长度，长度不能超过256，评论的时候判断是否已经存在评
论，若存在评论则无法进行再次评论，而是直接打印评论。
9）操作8，check。checker使用的选项，用checker使用的RSA
可以获得RSA一套中的d以及第1个怪物和第10个怪物的
key（checkercheckflag的正确性+RSA的正确性+aeskey的正确
性）。
10）操作9，exit。退出（free）。
本题从理论上不可获取shell，选手通过二进制漏洞修改或者泄露
密码学部分的信息实现攻击。本题的攻击利用、修补、稳定性维持都
真有较高的难度。所有的flag获取都必须通过RSAparityoracle进行
通过off-by-one漏洞、UAF漏洞实现信息的泄露或修改。本题除了解
题难度较高之外，还具有一定的性能优化难度，因为需要fastmining
和RSAparityoracle，因此如何减少交互数量，提升运行速度也是非
常关键的，否则极有可能一次攻击都无法完成。
题目的第一种攻击方式为nullbyteoff-by-one(fake
knownaccelarate)。
---
## Page 798
CTF特训营：技术详解、解题方法与.
22.4Railgun
798/1144
选手在添加自我描述部分的时候存在off-by-one，通过off-by-one
修改数组头指针，使其上移到description，使得堆结构体可控。堆结
构体中存储的是AES的密钥，通过修改AES的密钥可以解密RSA的密
文解密的后16字节，然后判断明文的奇偶性，从而进行RSAparity
oracle。
本题除了上述漏洞的利用之外，还考察了如下考点
迷惑点：leak的明文长度较多，所以会造成可以LLLAtack的假
象。
整型溢出攻击方式：为了避免挖矿，可以通过整型溢出获得硬
币，这里考察了一个奇偶性质的问题，因为每次攻击都需要花费两个
硬币，所以如果将硬币mining到奇数的话，硬币的数量永远不会为
0。
RSAparityoracle优化问题：完整的RSAparityoracle要交互
1024次流程才能leak完毕，但是因为明文数量约为模数的一半，且明
文后面有padding，所以可以在攻击过程的初始状态和结束状态进行
优化，减少一半的攻击次数。
本题可以通过查表方式来进行，不用整型溢出，手动挖矿，但是
---
## Page 799
CTF特训营：技术详解、解题方法与
22.4Railgun
799/1144
因为时间和交互次数问题，会降低exp的稳定性。
题目的第二种攻击方式为：UseAfterFree+integer-overflow（or
fastmining)+rsaparityoracle(feathigh-bitsknownaccelarate)。
后续攻击方式与第一种相同，达成RSAparityoracle攻击条件可
以使用另外一个漏洞。使用大量硬币释放掉最后一个boss后，使用多
次评论UAF操控最后一个boss的内容，然后通过攻击怪物选项使用
RSAparityoracle。
---
## Page 800
CTF特训营：技术详解、解题方法与
本筒小结8
800/1144
本篇小结
学习CTF中Crypto类型的题目需要一定数学功底和逻辑思维，对
于初学者来说并不是一个发好的CTF分类，但是一旦掌握了Crypto的
做题技巧，会是你在CTF竞赛中非常重要的得分点。
古典密码是CTF竞赛中常见的较为简单的考点，选手只需要能够
识别加密方式以及了解相关攻击技巧，即可快速解题。具有挑战性的
古典密码类型题目是较为罕见的。
分组密码和序列密码是CTF中的核心考点，在了解了本书介绍的
基本攻击方法后，可以针对分组密码、序列密码的各类结构及分析技
巧进行深入研究，例如差分攻击、积分攻击、快速相关攻击等，这些
内容是国内大型比赛以及国际比赛的重点考核区域。
公钥密码是CTF线上赛的必考内容，近年来基于格的问题越来越
流行，在学习完基本的公钥密码知识体系和攻击方式后，深入研究格
相关知识和基于格的攻击技巧是在公钥密码领域提升做题能力的关
键。
哈希函数相关的考点较少，了解基本的哈希碰撞、彩虹表、长度
---
## Page 801
CTF特训营：技术详解、解题方法与
本筒小结
801/1144
扩展攻击等相关知识即可应付大多数竞赛情况。
当前区块链已成为CTF竞赛的热门领域，作为密码学选手，了解
这块链相关领域的基本知识和做题技巧也是帮助队伍获得好成绩的关
键。
---
## Page 802
CTF特训营：技术详解、解题方法与
第五篇CTF之APK
802/1144
第五篇CTF之APK
本篇主要讲解CTF中APK的知识点，主要包括三个方面：首先，
介绍APK类型题目的基础知识点，包括题目的概述、Android系统的
基本特性以及ARM架构的基础知识；其次，介绍Dalvik层的逆向分析
技术，主要包括静态分析和动态调试两个方面；最后，介绍Native层
的逆向分析技术，主要包括调用特征分析、静态分析、动态调试三个
方面。
---
## Page 803
CTF特训营：技术详解、解题方法与
第23章APK基础
803/1144
第23章
APK基础
本章将简要介绍CTF比赛中Android题目的类型，以及作为
Android逆向人员必须具备的基础知识
---
## Page 804
CTF特训营：技术详解、解题方法与
23.1Android题目类型804/1144
23.1Android题目类型
CTF比赛中的Android题自主要以APK逆向为主，一般的出题方式
是：提供一个APK安装程序，让选手进行逆向和调试分析，从而得出
隐藏在其中的flag；也有可能不直接提供APK安装程序，而是需要通
过流量、解密或者拼装等方式获得，但是最终都会获取一个APK文件
（或者dex文件）来进行逆向操作。
目前，市面上大部分的Android系统都部署在ARM处理器平台上
CTF比赛中所出的大部分题自也是基于ARM平台的，因此推荐在做此
类题目的时候准备一部Android手机，这样调试起来会比较方便；当
然，模拟器也可以，但是模拟器在性能上会稍微差点且操作烦琐，同
时不排除有的APK可能会对模拟器进行验证，徒增烦恼。如果想深入
研究Android，推荐使用容歌的Nexus系列手机，刷机和调试都非常方
便。
解答Android题自对于工具的依赖非常强，熟练掌握几款工具能
够让你在解题时得心应手。因此，本章将以介绍各类知名的逆向工具
为主，辅以原理解析，并讲解几个例题作为巩固，以达到较好的效果。
---
## Page 805
CTF特训营：技术详解、解题方法与
23.1Android题目类型
805/1144
司时，本章也会简要介绍Android操作系统的结构以及ARM处理
器架构的相关基础知识，已经掌握这些基础知识的读者可以直接跳
过。
---
## Page 806
CTF特训营：技术详解、解题方法与
23.2Android基本架构806/1144
23.2Android基本架构
Android操作系统可分为4层，分别是Linux内核层、系统运行
层、应用框架层和应用层，而CTF中的Android题目主要集中在应用
层，不会涉及过多系统方面的知识
从开发人员的角度来看，一个Android应用可以分为两个部分：
一部分使用Java实现，也称Dalvik虚拟机层；一部分使用C/C++实现
也称Native层。从出题的角度来看，题目的主要逻辑既可以出在
Dalvik层，也可以出在Native层。对Dalvik层的代码进行逆向操作比较
方便，属于较简单的题型，而对Native层的代码进行逆向操作可能会
比较复杂，属于较难的题型
---
## Page 807
CTF特训营：技术详解、解题方法与
23.2.1Android的Dalvik虚拟机807/1144
23.2.1Android的Dalvik虚拟机
Android应用虽然可以使用Java开发，但是Android应用却不是运
行在标准的Java虚拟机上，而是运行在谷歌专门为Android开发的
Dalvik虚拟机上。虽然Android从5.0开始默认使用ART虚拟机，抛弃
了Dalvik虚拟机，但是Dalvik虚拟机的基础知识仍然是逆向必不可少
的，尤其是DEX文件的反编译。
Dalvik虚拟机中运行的是Dalvik字节码，并不是Java字节码，所
有的Dalvik字节码均由Java字节码转换而来，并打包成一个
DEX（DalvikExecutable）可执行文件。Dalvik虚拟机有一套自己的
指令集，以及一套专门的Dalvik汇编代码。
---
## Page 808
CTF特训营：技术详解、解题方法与
23.2.2Native层808/1144
23.2.2Native层
Android既可以使用Java开发，也可以与C/C++结合开发，甚至
可以使用纯C/C++开发。使用C/C++开发的代码经过编译后会形成一
个so文件，会在Android应用运行时加载到内存中。这与x86平台中
Linux加载so库的方式非常相似，唯一不同的是如何将Native层的函数
与Dalvik层的函数进行关联，使得Native层的函数在Dalvik层中可以很
方便地调用。
Native层中的函数与Dalvik层的函数有多种关联方式，具体的细
节将在Native层（第25章）进行详细阐述，这里先简单了解其整体概
念。
---
## Page 809
CTF特训营：技术详解、解题方法与
23.3ARM架构基础知识
809/1144
23.3ARM架构基础知识
自前绝大多数Android应用都运行在ARM处理器架构上，这里简
单介绍一下ARM处理器架构的几个重要特性。
主流的32位ARM处理器架构的版本为ARMV7，64位的ARM处理
器的原理与之类似，鉴于自前的题自很少涉及64位的ARM处理器
这里主要介绍32位的ARM处理器中适用于ARMV7的特性
ARM处理器共有37个32位寄存器，其中31个为通用寄存器，6个
为状态寄存器。
ARM处理器共有7种运行模式，除用户模式之外，其余6种模式
称为特权模式，Android应用主要运行在用户模式下。
在用户模式下，处理器可以访向的寄存器为不分组寄存器
R0-R7、分组寄存器R8-R14、程序计数器R15（PC）以及当前的程
序状态寄存器CPSR。
ARM处理器有两种工作状态：ARM状态和Thumb状态，处理器
可以在这两种状态下随意切换。这两种状态的主要区别是，ARM状
---
## Page 810
CTF特训营：技术详解、解题方法与
23.3ARM架构基础知识
810/1144
态下会执行32位对齐的ARM指令，而在Thumb状态时主要执行16位
对齐的Thumb指令。处理器判断当前状态的主要标志是程序状态寄存
器CPSR中的T标志，当T位为1时，处理器处于Thumb状态，反之则
处于ARM状态。两种状态下寄存器的命名有所不同，具体如下。
两种状态下R0-R7与CPSR相同。
ARM状态下的R11对应Thumb状态下的FP
ARM状态下的R12对应Thumb状态下的IP。
ARM状态下的R13对应Thumb状态下的SP
ARM状态下的R14对应Thumb状态下的LR
ARM状态下的R15对应Thumb状态下的PC