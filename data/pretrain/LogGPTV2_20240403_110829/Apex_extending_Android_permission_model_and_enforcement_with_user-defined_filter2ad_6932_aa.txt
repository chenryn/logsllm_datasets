title:Apex: extending Android permission model and enforcement with user-defined
runtime constraints
author:Mohammad Nauman and
Sohail Khan and
Xinwen Zhang
Apex: Extending Android Permission Model and
Enforcement with User-deﬁned Runtime Constraints
Mohammad Nauman
Institute of Management
Sciences, Pakistan
PI:EMAIL
Sohail Khan
School of Electrical
Engineering and Computer
Science, NUST Pakistan
PI:EMAIL
Xinwen Zhang
Samsung Information Systems
America, USA
PI:EMAIL
ABSTRACT
Android is the ﬁrst mass-produced consumer-market open
source mobile platform that allows developers to easily cre-
ate applications and users to readily install them. However,
giving users the ability to install third-party applications
poses serious security concerns. While the existing security
mechanism in Android allows a mobile phone user to see
which resources an application requires, she has no choice
but to allow access to all the requested permissions if she
wishes to use the applications. There is no way of granting
some permissions and denying others. Moreover, there is no
way of restricting the usage of resources based on runtime
constraints such as the location of the device or the number
of times a resource has been previously used. In this paper,
we present Apex – a policy enforcement framework for An-
droid that allows a user to selectively grant permissions to
applications as well as impose constraints on the usage of re-
sources. We also describe an extended package installer that
allows the user to set these constraints through an easy-to-
use interface. Our enforcement framework is implemented
through a minimal change to the existing Android code base
and is backward compatible with the current security mech-
anism.
Categories and Subject Descriptors
D.4.6 [OPERATING SYSTEMS]: Security and Protec-
tion—Access controls
General Terms
Security
Keywords
Mobile platforms, Android, Policy Framework, Constraints
1.
INTRODUCTION
In the current scenario of mobile platforms, Android [3] is
among the most popular open source and fully customizable
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS’10 April 13–16, 2010, Beijing, China.
Copyright 2010 ACM 978-1-60558-936-7/10/04 ...$10.00.
software stacks for mobile devices. Introduced by Google, it
includes an operating system, system utilities, middleware in
the form of a virtual machine, and a set of core applications
including a web browser, dialer, calculator and a few others.
Third party developers creating applications for Android
can submit their applications to Android Market from where
users can download and install them. While this provides a
high level of availability of unique, specialized or general pur-
pose applications, it also gives rise to serious security con-
cerns. When a user installs an application, she has to trust
that the application will not misuse her phone’s resources.
At install-time, Android presents the list of permissions re-
quested by the application, which have to be granted if the
user wishes to continue with the installation. This is an
all-or-nothing decision in which the user can either allow all
permissions or give up the ability to install the application.
Moreover, once the user grants the permissions, there is no
way of revoking these permissions from an installed applica-
tion, or imposing constraints on how, when and under what
conditions these permissions can be used.
Consider a weather update application that reads a user’s
location from her phone and provides timely weather up-
dates. It can receive location information in two ways. It
may read it automatically from gps or prompt the user to
manually enter her location if gps is unavailable.
In An-
droid, the application must request permission to read loca-
tion information at install-time and if the user permits it, the
application has access to her exact location even though such
precision is not necessary for providing weather updates. If
however, she denies the permission, the application cannot
be installed. The user therefore does not have a choice to
protect the privacy of her location if she wishes to use the
application for which the exact location isn’t even necessary
and the application itself provides an alternative.
To address these problems, we have developed Android
Permission Extension (Apex) framework, a comprehensive
policy enforcement mechanism for the Android platform.
Apex gives a user several options for restricting the usage
of phone resources by diﬀerent applications. The user may
grant some permissions and deny others. This allows the
user to use part of the functionality provided by the appli-
cation while still restricting access to critical and/or costly
resources. Apex also allows the user to impose runtime con-
straints on the usage of resources. Finally, the user may wish
to restrict the usage of the resources depending on an appli-
cation’s use e.g., limiting the number of sms messages sent
each day. We deﬁne the semantics of Apex as well as the
policy model used to describe these constraints. We also de-
scribe an extended package installer which allows end-users
to specify their constraints without having to learn a policy
language. Apex and the extended installer are both imple-
mented with a minimal and backward compatible change in
the existing architecture and code base of Android for better
acceptability in the community.
2. BACKGROUND
2.1 Android Architecture
Android architecture is composed in layers. These are
the application layer, application framework layer, Android
runtime and system libraries. Applications are composed of
one or more diﬀerent components. There are four types of
components namely activities, services, broadcast receivers
and content providers. Activities include a visible interface
of the application. Service components are used for back-
ground processing which does not require a visible interface.
The broadcast receiver component receives and responds to
messages broadcast by application code. Finally, content
providers enable the creation of a custom interface for stor-
ing and retrieving data in diﬀerent types of data stores such
as ﬁlesystems or sqlite databases. The application frame-
work layer enables the use or reuse of diﬀerent low-level
components. Android also includes a set of system libraries,
which are used by diﬀerent components of Android.
Components of an application can interact with other
components – both within the application and outside it
– using a specialized inter-component communication mech-
anism based on Intents. An intent is “an abstract represen-
tation of an action to be performed” [4]. Intents can either
be sent to a speciﬁc component – called explicit intents – or
broadcast to the Android framework, which passes it on to
the appropriate components. These intents are called im-
plicit intents and are much more commonly used. Both of
these types share the same permission mechanism and for
the sake of clarity, we only consider implicit intents in this
paper.
2.2 Motivating Example
In order to demonstrate the existing Android security
framework and its limitations, we have created a set of four
example applications as a case study, which is representative
of a large class of applications available in the Android Mar-
ket. Ringlet is a sample application that performs several
tasks using diﬀerent low-level components like gprs, mms,
gps etc. It accesses three other applications, each gather-
ing data from a diﬀerent social network – facebook, twitter
and ﬂickr. On receiving user name/password pairs, Ringlet
passes on the username and passwords of the social networks
to their respective back-end services. The back-end services
connect the user to the three networks at the same time
and extract updates from the social network sites to their
respective content provider datastores on the phone. The
front-end gui receives messages from the content providers,
displays these messages to the user in one streamlined in-
terface and allows her to reply back to the messages or
forward these messages to a contact via sms or mms.
It
should be noted that several applications similar to Ringlet
are available on the Android Market that use several per-
missions such as sending sms and accessing the location of
the user.
If a user downloads several applications for dif-
ferent purposes and grants all requested permissions to all
applications, there is no way of ensuring that none of the
applications will misuse these permissions.
In essence, there are four issues: (1) The user has to grant
all permissions in order to be able to install the applica-
tion; (2) there is no way of restricting the extent to which
an application may use the granted permissions; (3) since
all permissions are based on singular, install-time checks,
access to resources cannot be restricted based on dynamic
constraints such as the location of the user or the time of the
day; and (4) the only way of revoking permissions once they
are granted to an application is to uninstall the application.
We address these issues by enhancing the existing secu-
rity architecture of Android for enabling the user to restrict
the usage limit of both newly installed applications as well
as applications installed in the past. In the following sec-
tion, we formally describe a policy model for this purpose
and then detail how it has been incorporated in the existing
security mechanism of the Android framework.
3. ANDROID USAGE POLICIES
In this section, we ﬁrst present a logical model of the
existing Android security mechanism that focuses on the
semantics of Inter-Component Communication ( icc). The
model covers the semantics of intents, intent ﬁlters and the
permission logic for granting or denying access to resources.
Afterwards, we describe the policy model used for extending
the permission mechanism of Android to incorporate user-
deﬁned dynamic constraints.
In traditional access control models, policies revolve
around the abstractions of subjects, objects and rights. In
system-level permission models, policies are based on pro-
cesses, users, resources and rights. Android’s security frame-
work diﬀers slightly from both of these approaches in that 1)
the security model diﬀerentiates between the diﬀerent mod-
ules of a single application and 2) there is usually only one
user per device.
Each application consists of diﬀerent modular portions
termed as components. An application a1 might be allowed
access to one component of application a2 but not another.
This allows an application to make parts of its functional-
ity publicly available to other applications while keeping the
rest of the components protected. In this way, the smallest
unit of an application, with respect to the Android security
framework, is the component. We therefore deﬁne our secu-
rity framework on the basis of components of applications.
Definition 1
(Applications and Components).
The set of applications and components in Android are
denoted by A and C respectively and a component associa-
tion function ς : C → A associates each component with a
unique application.
Inter-Component Communication (icc) in Android is ac-
complished through the concept of Intents. Intents encap-
sulate the information associated with the icc call. The
action string describes the action to be performed, data
acts an argument for the action, category speciﬁes the
type of the component that should handle the intent and
the extras ﬁeld includes other arbitrary information associ-
ated with the raised intent. For example, in our motivat-
ing example (cf. Section 2.2), an intent of action string
edu.apex.android.ringlet.fkringlet.post, data "New Image
Caption", category "edu.apex.android.category.category_-
photo" and an image in the extras ﬁeld can be used to post
an image to the user’s ﬂickr proﬁle. Formally,
Definition 2
(Intent). An
intent
4-tuple
(α, σ, γ, ), where α is an action string describing the action
to be performed, σ is a string representing the data, γ is
the string representing the category and  : name → val is
a function that maps names of extra information to their
values. The set of intents is denoted as I.
is
a
Definition 5
(Uses-Permissions).
declares
permissions
A uses-permission construct
the
install-time.
granted to the application by the user at
Permissions are associated with applications rather than
their individual components. The basic permission function
µ : A → 2P is a function that maps an application to the
permissions it is granted where A is the set of applications
and P is the set of permissions.
Any application willing to ‘serve’ an intent describes its
willingness using the  tag in the manifest ﬁle.
An intent ﬁlter can be used to describe the ﬁne grained de-
tails of the intent an application is willing to serve including
the action string, data and the category of the intent. We
formalize intent ﬁlters using action strings that they serve.
This allows for a cleaner formalization without lack of gen-
erality. We deﬁne an intent ﬁlter as:
Definition 3
(Intent Filter). An intent ﬁlter is an
application’s willingness to serve an intent. Intent ﬁlters are
associated with individual components of applications. An
intent-ﬁlter association function Af : C → 2F maps each
component of an application to a set of intent ﬁlters where
F is the set of intent ﬁlters and I ⊆ F .
If a component
c ∈ C has an intent ﬁlter f , we write f ∈ Af (c).
Example 1. The ﬂickr service exposes the action
string edu.apex.android.intents.fks_intent in its intent ﬁl-
ter. This intent ﬁlter catches all intents matching this action
string, which can then be used to start the ﬂickr service.
Components associated with intent ﬁlters may impose re-
strictions on which applications may call them. These re-
strictions are deﬁned using the concept of permissions.
When an application provider writes an application, she
provides a list of intent ﬁlters that are supported by dif-
ferent components of the application. Moreover, she can
associate permissions with the individual components of the
application. This would ensure that only an application that
possesses the required permissions can call the component
through the given intent. Permissions are ﬁrst declared (as a
unique string in  tag) and then associated with