# 06 \| 分布式事务：All or nothing你好，我是聂鹏程。今天，我来继续带你打卡分布式核心技术。对于网上购物的每一笔订单来说，电商平台一般都会有两个核心步骤：一是订单业务采取下订单操作，二是库存业务采取减库存操作。通常，这两个业务会运行在不同的机器上，甚至是运行在不同区域的机器上。针对同一笔订单，当且仅当订单操作和减库存操作一致时，才能保证交易的正确性。也就是说一笔订单，只有这两个操作都完成，才能算做处理成功，否则处理失败，充分体现了"Allor nothing"的思想。在分布式领域中，这个问题就是分布式事务问题。那么今天，我们就一起打卡分布式事务吧。
## 什么是分布式事务？要想理解分布式事务，我们首先来看一下什么是事务。事务，其实是包含一系列操作的、一个有边界的工作序列，有明确的开始和结束标志，且要么被完全执行，要么完全失败，即all ornothing。通常情况下，我们所说的事务指的都是本地事务，也就是在单机上的事务。而**分布式事务，就是在分布式系统中运行的事务，由多个本地事务组合而成。**在分布式场景下，对事务的处理操作可能来自不同的机器，甚至是来自不同的操作系统。文章开头提到的电商处理订单问题，就是典型的分布式事务。要深入理解分布式事务，我们首先需要了解它的特征。分布式事务是多个事务的组合，那么事务的特征ACID，也是分布式事务的基本特征，其中 ACID 具体含义如下：``{=html}-   **原子性（Atomicity**），即事务最终的状态只有两种，全部执行成功和全部不执行。若处理事务的任何一项操作不成功，就会导致整个事务失败。一旦操作失败，所有操作都会被取消（即回滚），使得事务仿佛没有被执行过一样。-   **一致性（Consistency）**，是指事务操作前和操作后，数据的完整性保持一致或满足完整性约束。比如，用户    A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户    B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加    200 元 ; 一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600    元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200    元，但用户 B 未增加的情况 (该情况，用户 A 和 B 均为 600 元，总共    1200 元)。-   **隔离性（Isolation）**，是指当系统内有多个事务并发执行时，多个事务不会相互干扰，即一个事务内部的操作及使用的数据，对其他并发事务是隔离的。-   **持久性（Durability）**，也被称为永久性，是指一个事务完成了，那么它对数据库所做的更新就被永久保存下来了。即使发生系统崩溃或宕机等故障，只要数据库能够重新被访问，那么一定能够将其恢复到事务完成时的状态。分布式事务基本能够满足 ACID，其中的 C是强一致性，也就是所有操作均执行成功，才提交最终结果，以保证数据一致性或完整性。但随着分布式系统规模不断扩大，复杂度急剧上升，达成强一致性所需时间周期较长，限定了复杂业务的处理。为了适应复杂业务，出现了BASE理论，该理论的一个关键点就是采用最终一致性代替强一致性。我会在"知识扩展"模块与你详细展开BASE 理论这部分内容。介绍完什么是分布式事务，以及事务的基本特征后，就进入"怎么做"的阶段啦。所以接下来，我们就看看如何实现分布式事务吧。
## 如何实现分布式事务？实际上，分布式事务主要是解决在分布式环境下，组合事务的一致性问题。实现分布式事务有以下3 种基本方法：-   基于 XA 协议的二阶段提交协议方法；-   三阶段提交协议方法；-   基于消息的最终一致性方法。其中，基于 XA协议的二阶段提交协议方法和三阶段提交协议方法，采用了强一致性，遵从ACID，基于消息的最终一致性方法，采用了最终一致性，遵从 BASE 理论。
### 基于 XA 协议的二阶段提交方法XA 是一个分布式事务协议，规定了事务管理器和资源管理器接口。因此，XA协议可以分为两部分，即事务管理器和本地资源管理器。**XA 实现分布式事务的原理，就类似于我在****第 3篇文章**](https://time.geekbang.org/column/article/141772)**中与你介绍的集中式算法**：事务管理器作为协调者，负责各个本地资源的提交和回滚；而资源管理器就是分布式事务的参与者，通常由数据库实现，比如Oracle、DB2 等商业数据库都实现了 XA 接口。基于 XA 协议的二阶段提交方法中，二阶段提交协议（The two-phase commitprotocol，2PC），用于保证分布式系统中事务提交时的数据一致性，是 XA在全局事务中用于协调多个资源的机制。那么，**两阶段提交协议如何保证分布在不同节点上的分布式事务的一致性呢**？为了保证它们的一致性，我们需要引入一个协调者来管理所有的节点，并确保这些节点正确提交操作结果，若提交失败则放弃事务。接下来，我们看看两阶段提交协议的具体过程。两阶段提交协议的执行过程，分为投票（voting）和提交（commit）两个阶段。**投票为第一阶段**，协调者（Coordinator，即事务管理器）会向事务的参与者（Cohort，即本地资源管理器）发起执行操作的CanCommit请求，并等待参与者的响应。参与者接收到请求后，会执行请求中的事务操作，记录日志信息但不提交，待参与者执行成功，则向协调者发送"Yes"消息，表示同意操作；若不成功，则发送"No"消息，表示终止操作。当所有的参与者都返回了操作结果（Yes 或 No消息）后，**系统进入了提交阶段**。在提交阶段，协调者会根据所有参与者返回的信息向参与者发送DoCommit 或 DoAbort 指令：-   若协调者收到的都是"Yes"消息，则向参与者发送"DoCommit"消息，参与者会完成剩余的操作并释放资源，然后向协调者返回"HaveCommitted"消息；-   如果协调者收到的消息中包含"No"消息，则向所有参与者发送"DoAbort"消息，此时发送"Yes"的参与者则会根据之前执行操作时的回滚日志对操作进行回滚，然后所有参与者会向协调者发送"HaveCommitted"消息；-   协调者接收到"HaveCommitted"消息，就意味着整个事务结束了。接下来，**我以用户 A 要在网上下单购买 100 件 T恤为例，重点与你介绍下单操作和减库存操作这两个操作**，帮助你加深对二阶段提交协议的理解。第一阶段：订单系统中将与用户 A有关的订单数据库锁住，准备好增加一条关于用户 A 购买 100 件 T恤的信息，并将同意消息"Yes"回复给协调者。而库存系统由于 T恤库存不足，出货失败，因此向协调者回复了一个终止消息"No"。![](Images/a4a71c9eeb96e93a1ea941683747ccba.png){savepage-src="https://static001.geekbang.org/resource/image/8a/6a/8a880c358c5f1a1fe9c8cc8179d6b56a.png"}第二阶段：由于库存系统操作不成功，因此，协调者就会向订单系统和库存系统发送"DoAbort"消息。订单系统接收到"DoAbort"消息后，将系统内的数据退回到没有用户A 购买 100 件 T恤的版本，并释放锁住的数据库资源。订单系统和库存系统完成操作后，向协调者发送"HaveCommitted"消息，表示完成了事务的撤销操作。至此，用户 A 购买 100 件 T 恤这一事务已经结束，用户 A 购买失败。![](Images/bdda0ffd69d008f9f5af9222ce0773ec.png){savepage-src="https://static001.geekbang.org/resource/image/bd/5c/bd73d10eb000ee554a448d169344f95c.png"}由上述流程可以看出，**二阶段提交的算法思路可以概括为**：协调者下发请求事务操作，参与者将操作结果通知协调者，协调者根据所有参与者的反馈结果决定各参与者是要提交操作还是撤销操作。虽然基于 XA 的二阶段提交算法基本满足了事务的 ACID 特性，但依然有些不足。-   **同步阻塞问题**：二阶段提交算法在执行过程中，所有参与节点都是事务阻塞型的。也就是说，当本地资源管理器占有临界资源时，其他资源管理器如果要访问同一临界资源，会处于阻塞状态。-   **单点故障问题：**基于 XA    的二阶段提交算法类似于集中式算法，一旦事务管理器发生故障，整个系统都处于停滞状态。尤其是在提交阶段，一旦事务管理器发生故障，资源管理器会由于等待管理器的消息，而一直锁定事务资源，导致整个系统被阻塞。-   **数据不一致问题：**在提交阶段，当协调者向参与者发送 DoCommit    请求之后，如果发生了局部网络异常，或者在发送提交请求的过程中协调者发生了故障，就会导致只有一部分参与者接收到了提交请求并执行提交操作，但其他未接到提交请求的那部分参与者则无法执行事务提交。于是整个分布式系统便出现了数据不一致的问题。
### 三阶段提交方法三阶段提交协议（Three-phase commitprotocol，3PC），是对二阶段提交（2PC）的改进。为了解决两阶段提交的同步阻塞和数据不一致问题，**三阶段提交引入了超时机制和准备阶段**。-   同时在协调者和参与者中引入超时机制。如果协调者或参与者在规定的时间内没有接收到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务。-   在第一阶段和第二阶段中间引入了一个准备阶段，也就是在提交阶段之前，加入了一个预提交阶段。在预提交阶段排除一些不一致的情况，保证在最后提交之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，3PC 把 2PC的提交阶段一分为二，这样三阶段提交协议就有CanCommit、PreCommit、DoCommit 三个阶段。**第一，CanCommit 阶段。**CanCommit 阶段与 2PC的投票阶段类似：协调者向参与者发送请求操作（CanCommit请求），询问参与者是否可以执行事务提交操作，然后等待参与者的响应；参与者收到CanCommit 请求之后，回复 Yes，表示可以顺利执行事务；否则回复 No。CanCommit 阶段不同节点之间的事务请求成功和失败的流程，如下所示。![](Images/1fe99b2ace06081e71351115f5b42517.png){savepage-src="https://static001.geekbang.org/resource/image/56/7c/56fe63b378ed63d24e318af22419bb7c.png"}**第二，PreCommit 阶段。**协调者根据参与者的回复情况，来决定是否可以进行 PreCommit 操作。-   如果所有参与者回复的都是"Yes"，那么协调者就会执行事务的预执行：    -   **发送预提交请求。**协调者向参与者发送 PreCommit        请求，进入预提交阶段。    -   **事务预提交**。参与者接收到 PreCommit 请求后执行事务操作，并将        Undo 和 Redo 信息记录到事务日志中。    -   **响应反馈**。如果参与者成功执行了事务操作，则返回 ACK        响应，同时开始等待最终指令。-   假如任何一个参与者向协调者发送了"No"消息，或者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作：    -   **发送中断请求**。协调者向所有参与者发送"Abort"消息。    -   **终断事务**。参与者收到"Abort"消息之后，或超时后仍未收到协调者的消息，执行事务的终断操作。预执行阶段，不同节点上事务执行成功和失败的流程，如下所示。![](Images/7086f193d194cb594898759214df2592.png){savepage-src="https://static001.geekbang.org/resource/image/4e/45/4edc9b1a1248825d62db5b9107b09045.png"}**第三，DoCommit 阶段。**DoCmmit 阶段进行真正的事务提交，根据 PreCommit阶段协调者发送的消息，进入执行提交阶段或事务中断阶段。-   **执行提交阶段：**    -   发送提交请求。协调者接收到所有参与者发送的 Ack        响应，从预提交状态进入到提交状态，并向所有参与者发送 DoCommit        消息。    -   事务提交。参与者接收到 DoCommit        消息之后，正式提交事务。完成事务提交之后，释放所有锁住的资源。    -   响应反馈。参与者提交完事务之后，向协调者发送 Ack 响应。    -   完成事务。协调者接收到所有参与者的 Ack 响应之后，完成事务。-   **事务中断阶段：**    -   发送中断请求。协调者向所有参与者发送 Abort 请求。    -   事务回滚。参与者接收到 Abort 消息之后，利用其在 PreCommit        阶段记录的 Undo 信息执行事务的回滚操作，并释放所有锁住的资源。    -   反馈结果。参与者完成事务回滚之后，向协调者发送 Ack 消息。    -   终断事务。协调者接收到参与者反馈的 Ack        消息之后，执行事务的终断，并结束事务。执行阶段不同节点上事务执行成功和失败 (事务终断) 的流程，如下所示。![](Images/5a2400f8147bef4930cf32ea6a89efb7.png){savepage-src="https://static001.geekbang.org/resource/image/7e/0f/7e332feee4fb6b6fd67689b66cc2610f.png"}在 DoCommit 阶段，当参与者向协调者发送 Ack消息后，如果长时间没有得到协调者的响应，在默认情况下，参与者会自动将超时的事务进行提交，不会像两阶段提交那样被阻塞住。