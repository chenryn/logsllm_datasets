moves a pointer to the secret into register rax. Finally, the last
gadget is a leakage gadget (using the SMoTher side-channel)
which dereferences a byte of the secret, and encodes the LSB
into the channel.
3.1.1 Classiﬁcation of gadgets
Gadgets in a SpecROP chain can be classiﬁed based on the
functionality they provide. The main gadget categories are:
• Arithmetic gadgets perform simple arithmetic such as ad-
ditions or subtractions. These might be useful for pointer
manipulation, for example, allowing an attacker to craft
pointers to secrets.
• Shift gadgets shift and rotate values in registers. Gadgets
used in the SMoTherSpectre attack leak speciﬁc bits in
registers (for example, the LSB). These gadgets allow
an attacker to move secrets in other bits of the register
into those bits which are leakable.
• Data movement gadgets move secrets or other data
between registers, and between registers and memory.
These can be used for moving secrets into a register
targeted by the leakage gadget, for example.
• Leakage gadgets encode register/memory state into mi-
croarchitectural channels, enabling the attacker to later
infer and leak information.
• Multi-use gadgets perform more than one of the above
functions. An example is a lea gadget that performs an
addition and multiplication.
This classiﬁcation allows us to locate generic gadgets in
existing code bases, rather than speciﬁc sequences for partic-
ular attack scenarios. In Section 5, we describe SpecFication,
a tool for ﬁnding useful SpecROP gadgets, under constraints
on their length, and starting and ending conditions.
4 Evaluation
We now evaluate the practical aspects of a SpecROP attack.
First, we explore the contexts in which gadgets can be chained,
and the limits on the number of control-ﬂow instructions
which can reliably be poisoned. Towards this goal, we ex-
plore both avenues of chaining SpecROP gadgets: indirect
jumps and returns. Second, we create a prototype attack in a
laboratory setting to explore how chained gadgets enhance
a SMoTherSpectre attack, and whether there is any loss in
accuracy of leaked information as a result of chaining gadgets.
Finally, we describe a SpecROP attack on a real-world target,
libcrypto from OpenSSL, demonstrating that such attacks
are indeed feasible.
6700K 8700
Context
Y
Cross thread
N
Cross process
Y
Aliased
1 even with factory microcode.
Y
N
Y
9700
10510U
N
N
Y
N1
N
Y
Table 1: Contexts in which branch poisoning is feasible
/ / Load u n i q u e a d d r e s s Ai
( rdx ) , rcx
0x100 , rdx
1
2 mov
add
3
/ / Load a d d r e s s
4
5 mov
( r di ) , r8
add
0x8 , r di
6
/ /
7
jmpq
8
r8
Jump t o n e x t g a d g e t
t o n e x t g a d g e t
Listing 2: Gadgets used to determine maximum chaining
length using indirect jumps. The loads to Ai mark the execu-
tion of this gadget. The ﬁnal jump chains to the next gadget.
4.1 Gadget chaining
The practicality of a SpecROP attack is strongly linked to the
number of gadgets that can be reliably chained: the express-
ibility of the chain increases with the number of gadgets it
contains. Most practical SEA attacks will require at least two
(for the Spectre example) to three gadgets (for the OpenSSL
example). We describe our experiments for chaining gadgets
using indirect jumps and return instructions and evaluate the
contexts under which we were able to inﬂuence the branch
predictor.
Indirect jump poisoning in different contexts We evalu-
ated the ability to poison the branch predictor
• across threads sharing an SMT physical core,
• across processes sharing an SMT physical core, and
• across instructions at different addresses, leveraging
aliasing within the Branch Target Buffer (BTB).
We experimented with four generations of Intel’s processors
with updated microcode: i) Skylake i7-6700K, ii) Coffee Lake
i7-8700, iii) Coffee Lake Refresh i7-9700, and iv) Comet Lake
i7-10510U. From Table 1, we can see that branch poisoning is
only possible between an attacker and victim who share code
execution within a process, for example, a browser sandbox
running JavaScript from multiple websites.
4.1.1 Chaining gadgets through indirect jumps
Let us investigate the chaining of gadgets ending in indirect
jumps and calls. Assuming that the targets for the jump are
unavailable, the processor will use target predictions from
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    5
the BTB to speculatively fetch and execute instructions from
multiple gadgets.
In our experiment, we execute two threads from the same
process running on logical cores sharing a physical core. One
of the threads takes the role of an attacker, using a sequence
of indirect jumps through gadgets J0-J15 to train the branch
predictor. Listing 2 shows the code for the gadgets. The other
thread takes the role of the victim, speculatively following the
same path through the gadgets. The goal of this experiment is
to determine how many gadgets are actually executed by the
victim.
The target for the terminal jump of each gadget is loaded
from an array in memory (line 5), allowing us to “program”
different paths for the attacker and victim. On the attacker, the
gadgets are chained in an order designed to appear random to
the processor (J0 → J2 → J13 → J4 → J10 . . .J15). Architec-
turally, the victim is programmed to jump directly from J0 to
the end of J15. However, we ﬂush the targets for the victim
from the cache, causing it to speculatively execute the same
chain as trained by the attacker until the targets are fetched
from memory. At this point, the victim state is rolled back.
To determine whether a gadget Ji is executed by the victim,
we instrument them with memory accesses (line 2) to unique
addresses Ai. Using per-address Flush+Reload channels (see
Section 2.2), we can determine which gadgets are executed:
if gadget Ji is executed speculatively, the access to Ai is faster
in the Reload phase. Knowing which gadgets were actually
executed by the victim allows us to infer how many indirect
jumps were successfully poisoned.
Figure 3a shows results from running this experiment on
two generations of Intel processors, the i7-8700 and the i7-
6700K, both with and without the latest microcode updates.
On each machine, we use 10 sets of 1,000 runs, plotting the
median of the fraction of times the nth gadget was executed
by the victim. The limits show the minimum and maximum
fractions across the sets. On both processors, up to four gad-
gets can be chained with more than 50% success. However,
the probabilities of chaining ﬁve or more gadgets drops dras-
tically, with less than 10% success for reaching six gadgets.
A preliminary investigation suggests that TLB misses are not
responsible for this trend, as moving the gadgets or the cache-
lines for the Flush+Reload channels to 2MB hugepages do
not improve it. We also see that microcode updates do not
signiﬁcantly affect the median success rate.
4.1.2 Chaining gadgets through return instructions
We now study the chaining of gadgets terminated by return
instructions (ret). Modern processors use the Return Stack
Buffer (RSB) to predict the target of a ret instruction when
the return address on the stack is not immediately available.
Return addresses are pushed onto the RSB by call instruc-
tions, and are popped by ret instructions. Using unmatched
function calls, attackers can push excess values onto the RSB
and cause misprediction on later returns.
To show the possibility of chaining gadgets using RSB we
consider two experiments. In the ﬁrst, the attacker and victim
execute on the same thread. In the second, the attacker and
victim run on different threads within the same process, using
a futex to interleave their execution on a single core.
Same-thread chaining
In this experiment, the attacker uses
function calls to push a sequence of addresses onto the RSB.
The victim executes subsequently, its return instructions using
predictions from the RSB. The addresses on the RSB lead
to a sequence of gadgets, each of which accesses memory at
an unique address before executing a (poisoned) ret instruc-
tion. The memory accesses form a Flush+Reload channel to
determine which of the gadgets were executed by the victim.
Figure 3b shows results of our experiments on an i7-6700K,
an i7-8700 (16 RSB entries each), and a Xeon(R) E5-1620 (24
RSB entries). These experiments demonstrate the chaining
of up to ﬁve gadgets with a reasonable success rate on the
i7-6700K processor and up to two gadgets on the Xeon(R)
E5-1620. The success rate drops precipitously to practically
zero for more gadgets on all processors.
Cross-thread chaining
In this experiment, the attacker poi-
sons the RSB (as in the previous experiment) before using a
futex to switch to the victim thread. Due to the limited size
of the RSB, and its pollution during the context switch (there
are multiple function calls within the kernel code) only a few
RSB entries remain untouched for the victim. The victim’s
execution is again similar to the previous experiment. On a
i7-6700, the attacker can consistently chain up to two gadgets
on the victim. On a Xeon(R) E5-1620, up to three gadgets
can be chained using the RSB.
4.2 Proof-of-Concept
We now demonstrate the power of the SpecROP exploit tech-
nique. The proof-of-concept (PoC) attack is based on the
SMoTherSpectre attack, which leaks speciﬁc bits using a side-
channel based on port contention. Speciﬁcally, the SMoTher
leakage gadget targets the least-signiﬁcant bit (LSB) of the
register rdx. In our PoC, we use this leakage gadget in differ-
ent chains, augmenting the leakage capabilities of SMoTh-
erSpectre. While this PoC uses the SpecROP approach to
ameliorate one limitation of the SMoTherSpectre attack, we
believe that it is indicative of the improvement possible for
other attacks.
Our concept attack improves the SMoTherSpectre attack by
leaking eight bits of the register, not just the LSB. The attacker
achieves this by using shift gadgets for performing right-shift
operations on register rdx before being redirected to the leak-
age gadget. Note that the attack can trivially be extended to
leak the rest of the register. Figure 4 shows the ﬂow of control
on the victim. The attack starts at the basic block ending in
6    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
(a) Using indirect jumps
(b) Using ret instructions
Figure 3: The median success rate of chaining gadgets of different lengths on various processors. The limits represent the
maximum and minimum rate across runs. Entries marked "factory" represents runs without microcode updates.
an indirect jump (labeled jmp in the ﬁgure). The actual jump
target is the end block. By ensuring that the branch target is
unavailable, the attacker causes the victim to start speculative
execution, following the gadget chain trained by the attacker.
The attacker repeats this process several times, leading the
victim across the different paths to the leakage gadget. Along
each path, the register holding the secret is shifted by different
offsets, so that the leakage gadget ultimately leaks different
bits of the key.
Let us illustrate the process of leaking different bits. At
the jump gadget, suppose register dl holds a 8-bit secret
s = {si|i ∈ [0,7]} which the attacker wishes to leak. When
the attacker directly chains the jmp to the leakage gadget,
the value leaked is s0, the LSB of rdx. Instead, when the at-
tacker chains jmp→shift 1→leak, the register rdx holds s1
in the LSB at the leakage gadget. The leakage gadget now
encodes s1 into the side-channel. Similarly, on repetitions
where the attacker chains jmp→shift j→leak, the bit s j is
leaked. Therefore, by progressively redirecting the victim’s
speculative control ﬂow through different SpecROP chains,
the attacker extends the leakage scope of SMoTherSpectre.
The SpecROP attack is not constrained to leaking individ-
ual bits. It is the characteristic of the leakage channel used
in this POC that a bit is leaked at a time. With a cache-based
side-channel which leaks a byte at a time, and addition gad-
gets which manipulate the pointer used to access secrets, a
SpecROP attacker can leak an entire byte per iteration.
This proof-of-concept attack models a behavior which is
typical of many programs, for example OpenSSL. C++ virtual
function calls use indirect jumps, and hold a pointer to the
object as the ﬁrst parameter. For a virtual function call within
a loop, the attacker may run different chains on different iter-
ations. If the attacker can access different secrets by chaining
different sequences of gadgets, the attacker may progressively
Figure 4: The ﬂow of control during non-speculative execu-
tion (solid line), SMoTherSpectre attack (dashed line) and in
SpecROP attack (dotted lines).
leak multiple secrets as the victim executes.
In our laboratory proof-of-concept, the attacker and vic-
tim run in separate processes. We run the experiment on an
i7-6700K processor with microcode updates disabled. This
allows cross-process branch poisoning on a shared physical
core. With updated microcode, the attacker model changes to
that described in Section 4.1.
Our laboratory proof-of-concept was used to leak 1,024
randomly generated bytes. As discussed previously, different
chains leak each of the 8 bits per byte, and we treat samples
for each bit as a separate channel in the evaluation. For each
channel, we collect 1,024 attacker SMoTher timing samples
(a measure of port contention with the victim), corresponding
to 1,024 randomly generated "secret" bits on the victim. We
then separate the attacker timings into two sets, depending
on the value of corresponding secret bit on the victim, and
plot the probability distribution function (pdf) for each set.
When the distributions are clearly distinguishable, it means
that the attacker’s timing is strongly correlated to the victim’s
secret and can be classiﬁed with a high accuracy. Figure 5
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    7
12345678Number of gadgets chained (with indirect jumps)0.00.20.40.60.81.0Fraction of runs nthgadget reachedi7-6700Ki7-8700i7-6700K (factory)i7-8700 (factory)123456780.00.20.40.60.81.0Fraction of runs nthgadget reachedi7-6700Ki7-8700E5-1620Number of gadgets chained (with returns) jmpjmpshift 1shift 2...shift 7leakan indirect call in the EVP_EncryptUpdate function directly to
a leakage gadget. The register rdx holds a pointer to the secret
plaintext and this gadget leaks a bit of it from memory. In
contrast, the SpecROP attacker ﬁrst redirects the indirect call
to an arithmetic gadget which increments rdx by a constant
(for eg. 0x40), and subsequently to a leakage gadget. As a re-
sult, the attacker leaks a different bit from the plaintext. With
different arithmetic gadgets, this approach can vastly increase
the leakage scope of SMoTherSpectre. Figure 6 illustrates
this: the leftmost path shows the speculative control-ﬂow in
the base attack, and the other paths illustrate the leakage pos-
sible through different chains of gadgets. All the processing
and leakage gadgets are taken from glibc, which is likely
to be linked for most C programs, and are listed in full in
Appendix B.
In particular, we implemented an attack using the chain
which increments rdx by 0x40. The basic procedure of the
attack is very similar to SMoTherSpectre: the attacker and
victim are threads in the same process running on logical cores
on an SMT (hyperthreaded) physical core. Over 100,000
runs, the victim sets/resets the targeted bit in the plaintext
and initiates an AES encryption. Concurrently, the attacker
thread passes through a sequence of indirect jumps to poison
the BTB. In contrast to basic SMoTherSpectre, this chain
poisons more than one indirect branch on the victim. During
the consequent period of speculative execution on the victim,
the attacker times a sequence of instructions using rdtsc
timestamps. Due to port contention, the attacker’s readings
should be correlated to the victim’s secret. After the run, we
separate the attacker’s timings into sets based on the actual
value of the victim’s secret, and use the Student’s t-test to
validate that the distributions are actually distinguishable with
high conﬁdence (95%).
We ran our attack on an i7-8700 processor. Compared
to SMoTherSpectre, the victim in our attack executed the
leakage gadget in 33% of the runs instead of 80%. This is
explained by our observations in Section 4.1.1: the success
rate of reaching the ﬁnal gadget drops with the length of the
chain. Despite the added noise which results from runs where
the leakage gadget was not reached, the Student’s t-test reports
that the distributions are distinguishable with 95% conﬁdence.
The test reports a timing difference of 4.41%± 0.06%.
5 SpecFication: Gadget Search
To automate and improve the search for complex gadget
chains, we develop a tool. The goal of our gadget search
tool is two-fold:
1. To characterize the presence of processing gadgets which
will enable an attacker to perform useful transformations
on program state. Section 3.1.1 lists the target gadget
classes.
2. To automate the process of ﬁnding gadget chains as per
a set of constraints (described below).
Figure 5: SMoTher timing for multiple gadget chain, sepa-
rated according to the actual "secret" bit values. We have
plotted the ranges of the individual probability distribution
functions, separated by the secrets they represent, zero and
one.
shows the results of the experiment. Our plot aggregates the
results, showing the range of probabilities across the channels.
The plot reveals that the attacker timings are similar across
all channels, and that there is a clear separation within the
distributions based on the actual secret. This means that the
attacker can choose a threshold (around 140 cycles in this
case), and classify each timing sample as a zero or one with a
high accuracy. In fact, we can accurately guess victim secrets
across all channels with an accuracy ranging between 99%
and 100%.
In this experiment, the channel for bit 0 uses the shortest
chain, directly connecting the jmp gadget to the leakage gad-
get. In fact, this chain is identical to the base SMoTherSpectre
attack. This chain requires a single poisoned branch, whereas
the chains for leaking other bits require two. We have seen
(in Section 4.1.1) that longer chains lead to a diminishing
probability of reaching the ﬁnal (leakage) gadget. Therefore,
the leakage accuracy for channel 0 is the target for the other
channels. In fact, channel 0 leaks with 100% accuracy, and
even the worst channel has an accuracy of greater than 99%.
This shows that for a gadget chain of length two, SpecROP
allows us to augment the leakage scope of SMoTherSpectre
without suffering any loss of accuracy.
4.3 OpenSSL attack
In this section, we describe a realistic attack on a target pro-
gram using OpenSSL’s generic EnVeloP (EVP) interface to
encrypt/decrypt data. This attack improves upon the base
SMoTherSpectre attack on the same target, enabling the at-
tacker to leak an additional bit of the secret by modifying a
pointer held in register rdx using an arithmetic gadget. By
poisoning the BTB, the base SMoTherSpectre attack redirects
8    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
120130140150160170180190200Attacker (SMoTher) timing0.000.050.100.150.200.25Probabilitysecret = 0secret = 1Figure 6: SpecROP allows an attacker to extend the leakage scope of the SMoTherSpectre attack on OpenSSL, targeting plaintext
during encryption. The base attacker can leak a bit from byte 1 of the plaintext, whereas SpecROP chains enable leakage from
bytes 8, 16, 65 and 80 using different processing gadgets. The relevant register state is shown below the dotted lines for each
gadget.
The ﬁrst goal allows us to support our claim that gadgets
enhance the capability of an attacker to access and leak se-
crets. The second goal will enable attackers to construct useful