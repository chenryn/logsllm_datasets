inlined functions and if the target programs do not show such
inlining. But even then, using the multiple initial basic block
matches in our BHB algorithm, our approach can likely ﬁnd
the multiple counterparts in the non-inlined target program.
3) Instruction Reordering: Compilers may reorder inde-
pendent computations to enhance data locality. Reordered
instructions in a basic block change the syntactic assignment
formulas in the IR. However, ultimately the I/O pairs are the
same, as otherwise the semantics of the basic block would
have changed. By comparing the code semantics, our system
thus tackles reordering for free.
semantics instead of syntax.
6) Calling Conventions: Our approach is largely indepen-
dent of calling conventions. As we abstract from concrete
register names, to us it is not important which registers (or
stack/memory addresses) are used to pass registers or to return
results. It would be problematic when comparing the syntax
of the IR representations, but when hashing the sampled I/O
pairs, our approach completely ignores register names.
This list of compiler idiosyncrasies is incomplete, but
covering all of them would go beyond the scope of this
discussion. We have to acknowledge that some optimizations
modify the CFG (e.g., loop unrolling, dead code elimination)
and may become problematic if they affect the code parts
of the bug signature. However, our evaluation has shown
that our system performed well
in a realistic setting and
implicitly covered many of the optimization cases. Recall
that most of the experiments conducted in Section IV were
based on real-world binaries that were compiled by various
vendors. That is, we did not self-compile these binaries in
a homogeneous setting. Instead, our algorithm worked well
for heterogeneous build environments (different compilers,
optimization strategies, etc.), underlining the usability of our
approach in a practical setting.
C. Scalability
We performed all experiments in a single process/thread
and did not use any parallel computing to speed up the
experiments. The algorithm with the best results, k-MinHash,
degrades performance quite signiﬁcantly. This may become
problematic when searching multiple signatures in a large
database of binaries. A solution could be to run the compu-
tationally cheaper algorithms (e.g., Single-MinHash) ﬁrst and
then re-process the high ranks with k-MinHash. Moreover,
most computations can be scaled up with straightforward
parallelization. The uniﬁcation/sampling/hashing phases can
run in parallel on a basic block level, which would reduce
the runtime by orders of magnitude with commodity servers.
In addition, note that the most compute-intensive parts of
our approach are one-time operations. That is, translating the
binaries, sampling and hashing has to be performed only once
per binary under analysis. Only the matching phase needs to
be run once per search for a bug signature—a process that can
also easily run in parallel.
VI. RELATED WORK
To the best of our knowledge, we are the ﬁrst to propose a
strategy for comparing binary code across different architec-
tures. Our work thus differs from other works that have a sim-
ilar use case (bug ﬁnding) and it is therefore hard to directly
compare our cross-architecture bug search with other works
that operated under less challenging conditions (e.g., with
available source code or only for a single architecture). This
is also the reason why we did not compare our evaluation to
existing approaches, simply because there is no other approach
that operates on multiple architectures. In the following, we
review works that also aim to ﬁnd code similarity or bugs,
albeit using quite different preconditions.
722722
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:05:33 UTC from IEEE Xplore.  Restrictions apply. 
A. Code Similarity
A ﬁrst line of research has proposed methods to ﬁnd code
clones on a source code level. CCFINDER [22] can ﬁnd
equal sufﬁx chains of source code tokens. DECKARD [18]
leverages abstract syntax trees and local sensitive hashes to
ﬁnd similar subtrees of source code. Yamaguchi et al. [42]
broaden this concept with methods from text mining to not
only re-ﬁnd the same bug, but in the best case extrapolate
vulnerabilities by ﬁnding close neighbors, or even to ﬁnd
missing checks through anomaly detection. The latter was
also studied independently by Gauthier et al. [14]. Lastly,
REDEBUG [17] is a highly scalable system to ﬁnd unpatched
code clones in many popular programming languages. As
opposed to our system, these approaches require source code
and thus cannot aid code search in binary software, especially
not for closed-source software.
Lacking symbolic information complicates the process of
comparing code at the binary level. Early approaches to ﬁnd
binary code similarity rely on sequences of occurring calls [1]
or assembly K-grams [30]. Other approaches follow strategies
to compare the semantics of code. BINHUNT [13] uses sym-
bolic execution and a theorem prover to show that basic blocks
are semantically equivalent, but suffers from performance
bottlenecks. A follow-up project, IBINHUNT [29], augments
BinHunt with taint analysis to reduce the number of possible
matches. Not only are both works tailored towards equivalence
instead of gradual similarity, which is problematic for bug
extrapolation, they are both speciﬁc to x86, which makes them
incomparable to our work. BINJUICE [24] translates basic
blocks into syntactic equations (similar to our formulas) and
uses the concatenated and hashed equations as one input to
measure similarity between two basic blocks. However, this
approach is assumed to fail across CPU architectures, as we
have shown that formulas are syntactically different for each
architecture. BINHASH [20] relies on the input/output behavior
of equations, but also does not
include steps to support
multiple architectures. Furthermore, they cannot use the CFG,
but instead have to aggregate the hashes on a function level.
This precludes sub-function granularity, which is problematic
for our use-case. EXPOS ´E [32], a search engine for binary
code, uses a theorem prover to match binary functions, but
operates on a function level and simply assumes a single
calling convention (cdecl), which is impractical even on a
single CPU architecture.
Concurrent to our work, Egele et al. proposed Blanket Ex-
ecution (BLEX) [11], a system to match functions in binaries.
They execute each function of a binary for a low number of
execution contexts (according to the authors, three is sufﬁcient)
and save the function-level output. They also make sure to ex-
ecute each of the functions’ basic blocks at least once, simply
by re-executing the function from the ﬁrst basic block that
was not yet covered. Note that the changes to the execution
contexts propagate through the basic blocks and thereby only
function-level output is considered. While BLEX can compare
binaries compiled with different optimization levels, it can
only perform function-level matching. Due to this fact, the
number of entities which have to be compared is quite low in
comparison to our work, which is why they did not have to
use techniques like MinHashing. BLEX currently supports only
x64 binaries, and extending its scope to other architectures
would be tedious—both because BLEX is based on Intel’s Pin
and because it does not address many of the challenges of
cross-platform binary comparisons (cf. Section II-C).
Our work has similar goals as TEDEM [33], which uses a
notion of signatures to ﬁnd bugs in binaries. We also perform a
greedy search when broadening the signature, as our proposed
Best-Hit-Broadening algorithm shows. However, the authors
use tree-edit distance metrics, which severely slow down the
matching process and do not capture all syntactical changes.
Thus, TEDEM is not suitable for cross-platform comparisons.
Our approach overlaps with some ideas of these works,
but has many novel aspects. We developed a cheap, semantic
metric, which utilizes the CFG and is able to operate on
sub-function granularity. Most importantly, we are the ﬁrst to
compare binaries across architectures by unifying binary code
from multiple architectures to a common representation.
B. Identifying Previously-Unknown Bugs
We aim to identify bugs that are similar to well-known bugs.
Orthogonal related work searches for previously-unknown
bugs. To this end, some works rely on source code to
ﬁnd vulnerabilities. For example, in AEG [2], Avgerinos et
al. suggest using preconditioned symbolic execution in order
to explore exploitable program paths. Similarly, COVERITY [4]
uses static analysis to reveal potential memory corruption
vulnerabilities or data races; however, it fails to verify whether
all preconditions for exploitation are actually met, and also
does not cover all bug classes. In fact, the authors described
why Coverity did not detect the Heartbleed bug [7].
Shankar et al. proposed using a type-inference engine to
detect format string vulnerabilities [35]; a similar principle
was followed by Johnson and Wagner [21]. Other approaches
can identify new bugs even without access to source code.
Arguably the ﬁrst work in this area was Miller et al.’s proposal
to use blackbox fuzzing to provoke program crashes [28].
Livshits and Lam use tainting to ﬁnd vulnerabilities in Java
bytecode [25]. Recently, Cha et al. introduced an efﬁcient
symbolic execution engine to ﬁnd previously-unseen bugs
at the binary level with MAYHEM [6]. In general, dynamic
analysis approaches like fuzzing or Mayhem require an op-
erable environment where the software is actually running.
As illustrated by Zaddach et al. [43], this is far from easy
on highly-specialized hardware such as embedded devices. In
contrast, a purely static analysis like ours does not have to deal
with the peculiarities of the actual hardware platform other
than its CPU architecture. Moreover, many existing solutions
are tailored to ﬁnd only one class of bugs, such as control
ﬂow hijack vulnerabilities. As such, they are not generally
suitable to ﬁnd any class of bugs, as our system is. On the
other hand, these tools can ﬁnd previously-unseen bugs, while
723723
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:05:33 UTC from IEEE Xplore.  Restrictions apply. 
our approach is focused on re-ﬁnding bugs in other binary
software. We thus consider these works as complementary.
VII. CONCLUSIONS
In this paper, we showed that semantic binary code match-
ing is possible across CPU architectures under reasonable
assumptions that hold in practice. This advances prior research
results that are restricted to comparing binary code of a single
architecture. Our novel metric allows for ﬁne-grained code
comparison, which we successfully applied to identify real-
world vulnerabilities in closed-source software.
The pervasiveness of the Heartbleed bug exempliﬁes the
importance of identifying code parts in closed-source binary
programs that contain a speciﬁc vulnerability. With the rise of
closed-source software on other architectures (e.g., Windows
RT and iOS on ARM, or numerous ﬁrmware binaries for
MIPS), and re-use of potentially vulnerable code in such
software, our approach can greatly assist in ﬁnding future
vulnerabilities in binaries compiled for any architecture.
ACKNOWLEDGMENT
This work was supported by ERC Starting Grant No.
640110 (BASTION) and by the German Research Foundation
(DFG) research training group UbiCrypt (GRK 1817).
REFERENCES
[1] F. Ahmed, H. Hameed, M. Z. Shaﬁq, and M. Farooq. Using Spatio-
temporal Information in API Calls with Machine Learning Algorithms
for Malware Detection. In ACM AISec, 2009.
[2] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley. AEG: Automatic
Exploit Generation. In Symposium on Network and Distributed System
Security (NDSS), 2011.
[3] T. Bao, J. Burket, M. Woo, R. Turner, and D. Brumley. Byteweight:
In USENIX Security
Learning to recognize functions in binary code.
Symposium, 2014.
[4] A. Bessey, K. Block, B. Chelf, A. Chou, B. Fulton, S. Hallem, C. Henri-
Gros, A. Kamsky, S. McPeak, and D. Engler. A Few Billion Lines of
Code Later: Using Static Analysis to Find Bugs in the Real World.
Communications of ACM, 2010.
[5] A. Z. Broder. On the Resemblance and Containment of Documents. In
IEEE SEQUENCES, 1997.
[6] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley. Unleashing
Mayhem on Binary Code. In IEEE Symposium on Security and Privacy,
2012.
[7] A. Choue. On Detecting Heartbleed with Static Analysis, Apr. 2014.
http://tinyurl.com/hb-coverity.
[8] A. Costini, J. Zaddach, A. Francillon, and D. Balzarotti. A Large-Scale
Analysis of the Security of Embedded Firmwares. In USENIX Security
Symposium, 2014.
[9] DD-WRT. r21676, May 2013. http://tinyurl.com/ddwrt-21676.
[10] T. Dullien and R. Rolles. Graph-based comparison of executable objects.
SSTIC, 5, 2005.
[11] M. Egele, M. Woo, P. Chapman, and D. Brumley. Blanket execution:
In
Dynamic similarity testing for program binaries and components.
USENIX Security Symposium, 2014.
[12] A. Frank. On Kuhn’s Hungarian Method – A Tribute From Hungary.
Technical report, Oct. 2004.
[13] D. Gao, M. Reiter, and D. Song. BinHunt: Automatically Finding
Semantic Differences in Binary Programs. In Information and Comm.
Sec., 2008.
[14] F. Gauthier, T. Lavoie, and E. Merlo. Uncovering Access Control
In
Weaknesses and Flaws with Security-discordant Software Clones.
Annual Computer Security Applications Conference (ACSAC), 2013.
[15] S. Haeﬂiger, G. von Krogh, and S. Spaeth. Code Reuse in Open Source
Software. Journal of Management Science, Jan. 2008.
[16] IDA Pro - Interactive Disassembler. http://www.hex-rays.com/idapro/.
[17] J. Jang, A. Agrawal, and D. Brumley. ReDeBug: Finding Unpatched
Code Clones in Entire OS Distributions. In IEEE Symposium on Security
and Privacy, 2012.
[18] L. Jiang, G. Misherghi, Z. Su, and S. Glondu. DECKARD: Scalable
In International
and Accurate Tree-Based Detection of Code Clones.
Conference on Software Engineering (ICSE), 2007.
[19] W. Jin, S. Chaki, C. Cohen, A. Gurﬁnkel, J. Havrilla, C. Hines, and
P. Narasimhan. Binary Function Clustering Using Semantic Hashes. In
ICMLA, 2012.
[20] W. Jin, S. Chaki, C. Cohen, A. Gurﬁnkel, J. Havrilla, C. Hines, and
In
P. Narasimhan. Binary function clustering using semantic hashes.
ICMLA, 2012.
[21] R. Johnson and D. Wagner. Finding User/Kernel Pointer Bugs with Type
Inference. In USENIX Security Symposium, 2004.
[22] T. Kamiya, S. Kusumoto, and K. Inoue. CCFinder: A Multilinguistic
Token-based Code Clone Detection System for Large Scale Source
Code. IEEE Trans. Softw. Eng., 2002.
[23] kingcope. Mikrotik RouterOS 5.* and 6.* sshd remote preauth heap
corruption, September 2013. http://tinyurl.com/mikrotik-vuln.
[24] A. Lakhotia, M. D. Preda, and R. Giacobazzi. Fast Location of Similar
Code Fragments Using Semantic ’Juice’. In ACM SIGPLAN Workshop
on Programming Languages and Analysis for Security (PLAS), 2013.
[25] V. B. Livshits and M. S. Lam. Finding Security Vulnerabilities in Java
In USENIX Security Symposium,
Applications with Static Analysis.
2005.
[26] I. McCabe Software.
More Complex Equals Less Secure:
a Test Path and You Could Get Hacked, Feb 2012.
Miss
http://www.mccabe.com/pdf/More%20Complex%20Equals%20Less
%20Secure-McCabe.pdf.
[27] Microsoft-Research.
Z3: Theorem Prover, February
2014.
http://z3.codeplex.com/.
[28] B. P. Miller, L. Fredriksen, and B. So. An Empirical Study of the
Reliability of UNIX Utilities. Commununications of ACM, 1990.
[29] J. Ming, M. Pan, and D. Gao.
iBinHunt: Binary Hunting with Inter-
procedural Control Flow. In International Conference on Information
Security and Cryptology, 2013.
[30] G. Myles and C. Collberg. K-gram Based Software Birthmarks. In ACM
Symposium On Applied Computing (SAC), 2005.
[31] NETGEAR.
ReadyNAS OS Version
6.1.6,
June
2014.
[32] B. H. Ng and A. Prakash. Expose: Discovering Potential Binary Code
http://tinyurl.com/ng-readynas-616.
Re-use. In IEEE COMPSAC, 2013.
[33] J. Pewny, F. Schuster, C. Rossow, and T. Holz. Leveraging Semantic
In Annual Computer
Signatures for Bug Search in Binary Programs.
Security Applications Conference (ACSAC), 2014.
[34] R. Seggelmann, M. Tuexen, and M. Williams. RFC 6520: Transport
Layer Security (TLS) and Datagram Transport Layer Security (DTLS)
Heartbeat Extension, Feb. 2012.
[35] U. Shankar, K. Talwar, J. Foster, and D. Wagner. Detecting Format-
String Vulnerabilities with Type Qualiﬁers. In USENIX Security Sym-
posium, 2001.
[36] Y. Shoshitaishvili. Python bindings for Valgrind’s VEX IR, February
2014. https://github.com/zardus/pyvex.
[37] UBM Tech.
Embedded Market
Study, Mar.
2013.
http://tinyurl.com/embmarketstudy13.
[38] US-CERT/NIST. Vulnerability Summary for CVE-2013-1813, Novem-
ber 2013. http://tinyurl.com/cve20131813.
[39] Valgrind. Documentation, 2014. http://www.valgrind.org/docs/.
[40] V. van der Veen, N. dutt Sharma, L. Cavallaro, and H. Bos. Memory
Errors: The Past, the Present, and the Future. In Symposium on Recent
Advances in Intrusion Detection (RAID), 2012.
[41] E. Vanderbeken.
How Sercomm saved my Easter!, April 2014.
http://tinyurl.com/sercomm-backdoor.
[42] F. Yamaguchi, M. Lottmann, and K. Rieck. Generalized vulnerability
extrapolation using abstract syntax trees. In Annual Computer Security
Applications Conference (ACSAC), 2012.
[43] J. Zaddach, L. Bruno, A. Francillon, and D. Balzarotti. Avatar:
A Framework to Support Dynamic Security Analysis of Embedded
Systems’ Firmwares. In Symposium on Network and Distributed System
Security (NDSS), 2014.
[44] R. B. Zadeh and A. Goel. Dimension Independent Similarity Compu-
tation. CoRR, abs/1206.2082, 2012.
724724
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:05:33 UTC from IEEE Xplore.  Restrictions apply.