---
tags: ['架构', '分布式']
level: 1
---
# 可用性
![可用性金字塔](/assets/屏幕截图%202021-10-27%20221303.png)
## 可靠性
- 给定时间间隔与条件 系统无故障持续运行的概率
可用性看重的是宕机时长、可靠性看重的宕机次数
## 稳定性
某个时间段内出错的概率，越高稳定性越差
性能是否逐渐劣化、软件每次的同样行为是否表现一致
## 本地可用
- 解决的是硬件、网络故障
[CAP](/软件工程/架构/系统设计/分布式/分布式理论.md#CAP)：
- CA：集群架构
- CP：
- AP：分布式架构
## 数据逻辑保护
大部分影响可用性的原因是人为操作的失误
- 预防：备份、变更审核
- 监控：系统异常行为监控
### 修复
- 版本回滚 数据恢复
### 数据变更流程
数据变更都需要被审核
- DBA -> 产品拥有者 -> 开发者
### 备份
- 冷备：成本低 实时性低不一致
- 热备
  - 同步热备
  - 主从热备 canal
、快照、CDP、事件溯源
## 容灾多活
### 技术路线
- 数据库（应用层）容灾：同构数据库下的数据同步 需要关注网络、主机资源问题
- SAN网络层容灾
- 存储层容灾：存储环境必须一致 依赖于特定厂商
### DRP规划
- 灾难恢复计划
![202192721112](/assets/202192721112.png)
业务影响分析：确定最核心业务
RTO RPO
### 容灾演练
根据文档内容进行测试与排练
在非生产环境进行模拟测试 在生产环境进行并行测试
中断测试
### BCP业务连续性计划
### 多活方案
- 双活
  - 成本 = 1/(N-1) * N
- 两地三中心
## 冗余
保证高可用的主要手段是使用冗余
- 对于计算服务器来说，保证是无状态的，就可以实现冗余
- 而对于存储服务器，需要通过主从复制来实现冗余
  - 存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响
使用了冗余之后，如果出现了异常就要采取行动来保证高可用，就需要使用**状态决策**来保证系统高可用，但是通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确，不管是一主多备，主备切换，还是多主选举都会出现不同程度的状态不一致，这是由于网络分区的存在导致的
### 高可用存储
#### 双机架构
##### 主备复制
```mermaid
stateDiagram-v2
  客户端 --> 主机: 读&写
  主机 --> 备机: 数据复制
  客户端 --> 备机: 主机不可用时读&写
```
备机主要还是起到一个备份作用，并不承担实际的业务读写操作，如果要把备机改为主机，需要人工操作
这种方式浪费了备机资源，同时主机故障后人工介入操作，人工也是一种故障点
##### 主从复制
```mermaid
stateDiagram-v2
  客户端 --> 主机: 读&写
  主机 --> 备机: 数据复制
  客户端 --> 备机: 读
```
客户端需要感知主从关系，做[读写分离](/软件工程/架构/系统设计/高并发.md#总结：读写分离)将不同的操作发给不同的机器进行处理
##### 主主复制
```mermaid
stateDiagram-v2
  direction LR
  客户端 --> 主机1: 读&写
  主机1 --> 主机2: 数据复制
  主机2 --> 主机1: 数据复制
  客户端 --> 主机2: 读&写
```
主主复制架构对数据的设计有严格的要求，一般适合于那些临时性、可丢失、可覆盖的数据场景
##### 双机切换
- 即出现故障时系统自动决定主机角色，并完成角色切换
需要考虑的点：
- 状态传递的渠道
- 状态检测的内容
- 切换时机
- 切换策略
- 自动程度
- 数据冲突解决
互连式：状态传递通道本身也是不可靠的
```mermaid
stateDiagram-v2
  客户端 --> 主机: 读&写
  主机 --> 备机: 数据复制
  主机 --> 备机: 状态传递
  客户端 --> 备机: 主机不可用时读&写
```
中介式：需要中介本身是高可用
```mermaid
stateDiagram-v2
  客户端 --> 主机: 读&写
  主机 --> 备机: 数据复制
  主机 --> 中介: 状态上报
  备机 --> 中介: 状态上报
  客户端 --> 备机: 主机不可用时读&写
```
备机探测式：
```mermaid
stateDiagram-v2
  客户端 --> 主机: 读&写
  主机 --> 备机: 数据复制
  备机 --> 主机: 探测主机是否挂了
  客户端 --> 备机: 主机不可用时读&写
```
#### 数据集群
数据集中集群
```mermaid
stateDiagram-v2
  state 数据集中式集群 {
    主机 --> 备机1: 数据复制
    主机 --> 备机2: 数据复制
    主机 --> 备机3: 数据复制
  }
  客户端 --> 数据集中式集群
```
数据分散集群：每台服务器都会负责存储一部分数据，又会备份一部分数据
![数据分散集群](/assets/批注%202020-03-19%20081559.png)
#### 数据分区
- 将数据按照一定的规则进行分区，不同分区分布在不同的物理位置上，物理区域之间可以通过复制来备份
集中式复制:
```mermaid
stateDiagram-v2
  北京分区 --> 贵州备份中心: 数据复制
  上海分区 --> 贵州备份中心: 数据复制
  广州分区 --> 贵州备份中心: 数据复制
```
互备式复制：
```mermaid
stateDiagram-v2
  北京分区 --> 上海分区: 数据复制
  上海分区 --> 广州分区: 数据复制
  广州分区 --> 北京分区: 数据复制
```
独立式复制：
```mermaid
stateDiagram-v2
  北京分区 --> 北京备份中心: 数据复制
  上海分区 --> 上海备份中心: 数据复制
  广州分区 --> 广州备份中心: 数据复制
```
### 计算高可用
- 设计复杂度主要体现在任务管理方面，即当任务在某台服务器上执行失败后，如何将任务重新分配到新的服务器进行执行
#### 主备
```mermaid
stateDiagram-v2
  任务分配器 --> 主机: 计算任务
  任务分配器 --> 备机: 计算任务(人工切换)
```
#### 主从
```mermaid
stateDiagram-v2
  任务分配器 --> 主机: 计算任务1
  任务分配器 --> 备机: 计算任务2
```
#### 集群式
- 调度集群：一个任务可能会在不同的机器上执行
```mermaid
stateDiagram-v2
  任务分配器 --> 集群
  state 集群 {
    [*] --> 服务器1: 计算任务
    [*] --> 服务器2: 计算任务
    [*] --> 服务器3: 计算任务