 stable和immutable函数, 函数内不允许修改数据.(如PGver>=8.0 函数内不可执行非SELECT|PERFORM语句.)
 使用同样的参数调用返回同样的结果, 在事务中有这个特性的也归属stable.
 优化器可根据实际场景优化stable函数的调用次数, 同样的参数多次调用可减少成单次调用.
 stable和immutable函数可用于优化器选择合适的索引扫描, 因为索引扫描仅评估被比较的表达式一次, 后多次与索
引值进行比较.
 stable和volatile函数都不能用于创建函数索引, 只有immutable函数可以用于创建函数索引.
 stable和immutable函数, snapshot为外部调用函数的QUERY的snapshot, 函数内部始终保持这个snapshot, 外部会
话带来的的数据变更不被反映到函数执行过程中.
函数的三态小结
 IMMUTABLE
 不允许修改数据, 使用同样的参数调用返回同样的结果.
 优化器在处理immutable函数时, 先评估函数结果, 将结果替换为常量.
 因此使用约束优化查询的场景中也只识别immutable函数.
 STABLE和IMMUTABLE的区别
 stable函数在select和where子句中不被优化, 仅仅当使用索引扫描时where子句对应的stable函数才会被优化为1次调
用.
 在prepared statement中的使用区别:
 immutable函数在plan时以常量替代, stable函数在execute阶段被执行.
 因此immutable函数参数为常量时, 在prepared statement场景只执行一次, 而stable函数被多次执行.
 函数稳定性通过查看pg_proc.provolatile得到
PostgreSQL MVCC
 事务隔离级别,
 并发控制,
 锁的介绍,
 死锁的发现和处理, 实际应用中如何避免死锁
PostgreSQL MVCC
 PostgreSQL的多版本并发控制
 版本识别演示.(INSERT, UPDATE, DELETE, 使用ctid定位, 并查看该TUPLE xmin, xmax的变化)
 关键词
 XID -- 数据库的事务ID
 Tuple head: xmin, xmax, 行头部的XID信息, xmin表示插入这条记录的事务XID, xmax表示删除(或锁)这条记录的事务XID
 Xid_snapshot : 当前集群中的未结束事务.
 Clog : 事务提交状态日志
 事务隔离级别.
 数据可见性条件 :
 1. 记录的头部XID信息比当前事务更早. （repeatable read或ssi有这个要求, read committed没有这个要求）
 2. 记录的头部XID信息不在当前的XID_snapshot中. (即记录上的事务状态不是未提交的状态.)
 3. 记录头部的XID信息在CLOG中应该显示为已提交.
PostgreSQL MVCC
 更新和删除数据时, 并不是直接删除行的数据, 而是更新行的头部信息中的xmax和infomask掩码.
 事务提交后更新当前数据库集群的事务状态和pg_clog中的事务提交状态.
 Infomask和infomask2参看
 src/include/access/htup_details.h
 例子 :
 会话1 :
 digoal=# truncate iso_test ;
 TRUNCATE TABLE
 digoal=# insert into iso_test values (1,'test');
 INSERT 0 1
 digoal=# begin;
 BEGIN
 digoal=# update iso_test set info='new' where id=1;
 UPDATE 1
PostgreSQL MVCC
 会话2 :
 digoal=# select ctid,xmin,xmax,* from iso_test where id=1;
 ctid | xmin | xmax | id | info
 -------+-----------+-----------+----+------
 (0,1) | 316732572 | 316732573 | 1 | test
 (1 row)
 PostgreSQL多版本并发控制不需要UNDO表空间.
PostgreSQL MVCC
 RepeatableRead1 tuple-v1 IDLE IN TRANSACTION;
 ReadCommitted1 tuple-v1 IDLE IN TRANSACTION;
 RC2 tuple-v1 UPDATE -> tuple-v2 COMMIT;
 RR1 tuple-v1 IDLE IN TRANSACTION;
 RC1 tuple-v2 IDLE IN TRANSACTION;
 RR2 tuple-v2 IDLE IN TRANSACTION;
 RC3 tuple-v2 UPDATE -> tuple-v3 COMMIT;
 RR1 tuple-v1 IDLE IN TRANSACTION;
 RR2 tuple-v2 IDLE IN TRANSACTION;
 RC1 tuple-v3 IDLE IN TRANSACTION;
PostgreSQL 事务隔离级别
 脏读
 在一个事务中可以读到其他未提交的事务产生或变更的数据.
 PostgreSQL不支持read uncommitted事务隔离级别, 无法测试.
 不可重复读
 在一个事务中, 再次读取前面SQL读过的数据时, 可能出现读取到的数据和前面读取到的不一致的现象. (例如其他事务在此期间已提
交的数据)
 使用read committed事务隔离级别测试
 幻像读
 在一个事务中, 再次执行同样的SQL, 得到的结果可能不一致.
 标准SQL事务隔离级别, (PostgreSQL的repeatable read隔离级别不会产生幻像读)
 PostgreSQL不支持read uncommitted隔离级别.
PostgreSQL 事务隔离级别测试1
 不可重复读测试
 digoal=# create table iso_test(id int, info text);
 digoal=# insert into iso_test values (1, 'test');
 digoal=# begin isolation level read committed;
 BEGIN
 digoal=# select * from iso_test where id=1;
 id | info
 ----+------
 1 | test
 (1 row)
 -- 其他会话更新这份数据, 并提交.
 digoal=# update iso_test set info='new' where id=1;
 -- 不可重复读出现.
 digoal=# select * from iso_test where id=1;
 id | info
 ----+------
 1 | new
 (1 row)
PostgreSQL 事务隔离级别测试2
 幻象读测试
 digoal=# begin isolation level read committed;
 digoal=# select * from iso_test;
 id | info
 ----+------
 1 | new
 (1 row)
 -- 其他会话新增数据
 digoal=# insert into iso_test values (2, 'test');
 -- 幻象读出现
 digoal=# select * from iso_test;
 id | info
 ----+------
 1 | new
 2 | test
 (2 rows)
PostgreSQL 事务隔离级别测试3
 使用repeatable read可避免不可重复读和幻象读.
 digoal=# delete from iso_test;
 digoal=# insert into iso_test values (1, 'test');
 digoal=# begin isolation level repeatable read;
 digoal=# select * from iso_test where id=1;
 id | info
 ----+------
 1 | test
 (1 row)
 -- 其他会话修改数据, 并提交
 digoal=# update iso_test set info='new' where id=1;
 -- 未出现不可重复读现象.
 digoal=# select * from iso_test where id=1;
 id | info
 ----+------
 1 | test
 (1 row)
PostgreSQL 事务隔离级别测试3
 -- 其他会话新增数据.
 digoal=# insert into iso_test values (2, 'test');
 INSERT 0 1
 -- 未出现幻象读
 digoal=# select * from iso_test ;
 id | info
 ----+------
 1 | test
 (1 row)
PostgreSQL 事务隔离级别测试4
 PostgreSQL repeatable read情景案例
 当repeatable read的事务去更新或删除在事务过程中被其他事务已经变更过的数据时, 将报错等待回滚.
 digoal=# truncate iso_test ;
 digoal=# insert into iso_test values (1,'test');
 digoal=# begin isolation level repeatable read;
 digoal=# select * from iso_test ;
 id | info
 ----+------
 1 | test
 (1 row)
 -- 其他事务更新或者删除这条记录, 并提交.
 digoal=# update iso_test set info='new' where id=1;
 UPDATE 1
 -- 在repeatable read的事务中更新或者删除这条记录. 会报错回滚
 digoal=# update iso_test set info='tt' where id=1;
 ERROR: could not serialize access due to concurrent update
 digoal=# rollback;
 ROLLBACK
PostgreSQL 事务隔离级别测试4
 先获取锁, 再处理行上的数据(例如做条件判断.)
 所以会有这种现象.
 -- 会话1
 digoal=# truncate iso_test ;
 TRUNCATE TABLE
 digoal=# insert into iso_test values (1,'test');
 INSERT 0 1
 digoal=# begin;
 BEGIN
 digoal=# update iso_test set id=id+1 returning id;
 id
 ----
 2
 (1 row)
 UPDATE 1
PostgreSQL 事务隔离级别测试4
 -- 会话2
 digoal=# select * from iso_test ;
 id | info
 ----+------
 1 | test
 (1 row)
 digoal=# delete from iso_test where id=1; -- 等待ctid=(0,1)的行exclusive锁
 -- 会话1, 提交事务
 digoal=# end;
 COMMIT
 -- 会话2, 此时会话2等待的这条ctid(0,1)已经被会话1删除了(如果会话2是repeatable read模式的话这里会报错).
 DELETE 0
 digoal=# select * from iso_test;
 id | info
 ----+------
 2 | test
 (1 row)
PostgreSQL 事务隔离级别测试5
 Serializable 隔离级别
 目标是模拟serializable的隔离级别事务的提交顺序转换为串行的执行顺序.
 例如 :
 Start transaction a serializable
 Start transaction b serializable
 Session a -> SQL …
 Session b -> SQL …
 Session a|b -> SQL …
 …. Session a|b -> SQL …
 Commit b
 Commit a
 这个场景模拟成 :
 Start transaction b ssi
 Sql …
 Commit b
 Start transaction a ssi
 Sql … 如果会话a扫描过的数据在B中被加ssi锁, 那么a会话将提交失败.
 Commit a
PostgreSQL 事务隔离级别测试5
 PostgreSQL 串行事务隔离级别的实现, 通过对扫描过的数据加载预锁来实现(内存中的一种弱冲突锁, 只在事务结束时判断是否有数据依赖
性的冲突)
执行计划
 因为涉及到扫描的数据, 所以这种锁和 有关.
 例如
 Select * from tbl where a=1;
 如果没有索引, 那么是全表扫描, 需要扫描所有的数据块.
 加载的预锁是表级别的预锁. (那么期间如果其他串行事务对这个表有任何变更, 包括插入,删除,更新等. 并且先提交的话.)
 这个会话结束的时候会发现预加锁的数据被其他串行事务变更了, 所以会提交失败.