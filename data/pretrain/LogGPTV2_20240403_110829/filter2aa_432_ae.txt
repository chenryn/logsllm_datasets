把外围设备作为文件看待
文件系统被组织成树状，称为目录树。目录树有一个成为根（root）的节点（记做“ /”）。
文件系统结构中的每个非树节点都是文件的一个目录（directory），树的叶节点上的文件既
可以是目录，也可以是正规文件（regular files），还可以是特殊设备文件（special device files）。
文件名由路径名（path name）给出，路径名描述了怎样在一个文件系统树中确定一个文件
的位置。路径名是一个分量名序列，各分量名之间用“ /” 隔开。分量是一个字符序列，它
致命一个北唯一的包含在前级（目录）分量中的文件名。一个完整的路径名由一个斜杠字
符开始，并且指明一个文件，这个文件可以从文件系统的根开始，沿着该路径名的后继分
 20 -
Linux 网络编程
量名所在的那个分支游历文件树而找到。
在 UNIX/Linux 系统中，程序不了解内核按怎样的内部格式存贮文件，而把数据作为
无格式的字节流看待。程序可以按他们自己的意愿去解释字节流，但这种解释与操作系统
如何存储数据无关。因此，对文件中数据进行存取的语法是由系统定义的，并且对所有的
程序都是同样的。但是，数据的语义是由程序自己定义的。比如，正文格式化程序 troff 希
望在正文的每一行尾部着到换行符，而系统记帐程序则希望找到定长记录。两个程序都使
用相同的系统服务，以存取文件中作为字节流存在的数据，而在程序内部，它们通过分析
把字节流解释成适当的格式。如果哪一个程序发现格式是错误的，则由它自己负责采取适
当的行动。
从这方面说，目录也像正规文件。系统把目录中的数据作为字节流看待。但是由于该
数据中包含许多以预定格式记录的目录中的文件名，所以操作系统以及诸如 ls 这样的程序
就能够在目录中发现文件。
对一个文件的存取权限由与文件相联系的 access permissions 所控制。存取权限能够分
别对文件所有者，同组用户及其它人这三类用户独立的建立许可权，以控制读写及执行的
许可权。如果目录存取权限允许的话，则用户可以创建文件。新创建的文件是文件系统目
录结构的树叶节点。
对于用户来说，UNIX 系统把设备看成文件。以特殊设备文件标名的设备，占据着文
件系统目录结构中的节点位置。程序存取正规文件时使用什么语法，他们在存取设备时也
使用什么语法。读写设备的语义在很大程度上与读写正规文件时相同。设备保护方式与正
规文件的保护方式相同：都是通过适当建立它们的（文件）存取许可权实现的。由于设备
名看起来象正规文件名，并且对于设备和正规文件能执行相同的操作，所以大多数程序在
其内部不必知道它们所操纵的文件的类型。
2.2.2  流和标准 I/O 库
UNIX/Linux 内核为我们提供了一系列用于访问文件系统（包括其它 I/O 设备）的系统
调用，如 open,close 等，通过这些系统调用我们可以实现全部的 I/O 功能。但由这些系统调
用组成的 I/O 系统也存在使用不便，缺乏灵活性等的缺点。
为了提高 I/O 系统的模块性和灵活性，Ritchie 提出了流的概念。“ 流” 是在内核空间中
的流驱动程序与用户空间中的进程之间的一种全双工处理和数据传输通路。在内核中，流
通过流首、驱动程序以及它们之间的零个或多个模块组成。流首是流最靠近用户进程的那
一端。由流上用户进程发出的所有系统调用都由流首处理。
流驱动程序可以是提供外部 I/O 设备服务的一种设备驱动程序；也可以是一种软件驱
动程序，通常这种驱动程序称为伪设备驱动程序。流驱动程序主要处理内核与设备间的数
据传输。除了进行流机制使用的数据结构与该设备理解的数据结构间的转换之外，它很少
或根本不处理别的数据。
在流首和驱动程序之间可以插入一个或多个模块，以便在流首和驱动程序间传递消息
时对其进行中间处理。流模块由用户进程在流中动态的互联。创建这种连接不需要内核编
程、汇编或连接编辑。
流使用队列结构，以保持与压入的模块或打开的流设备有关的信息。队列总是成对分
i 节点(inode)：
Linux 缺省使用一种叫 EXT 2 的文件系统，在这种文件系
统中，每个文件在它所在的目录中都有一个对应的 inode，其中
保存了文件的文件名，长度，存取权限等信息。可以这样认为：
目录就是由 inode 所组成的特殊文件。
UNIX/Linux 模型
- 21 -
配，一个用于读另一个用于写。每一个驱动程序、模块和流首都各有一个队列对。只要打
开流或者把模块压入到流中，就分配队列对。
数据以消息的形式在驱动程序和流首之间以及在模块间传递。消息是一组数据结构，
它们用于在用户进程、模块和驱动程序间传递数据、状态和控制信息。从流首向驱动程序，
或者从继承向设备传递的消息称之为“ 顺流” 传播（也称之为“ 写侧”）。类似的，消息以
另一方向传递，即从设备向进程或从驱动程序向流首方向传递，称之为“ 逆流” 传播（也
称之为“ 读侧”）。
一个流消息由一个或多个消息块构成。每一个“ 块” 是由首部、数据块和数据缓冲区
组成的三元组，流首在用户进程的数据空间和流内核数据空间之间传输数据。用户进程发
送给驱动程序的数据被打包成流消息，然后顺流传递。当包含数据的消息经由逆流到达流
首时，此消息由流首处理，它把数据复制到用户缓冲区中。
在流内部，消息由类型指示符区分。逆流发送的某些消息类型可能导致流首执行特定
的动作，如，送一个信号给用户进程。其它消息类型主要在流内部传递信息，用户进程不
会直接见到这些消息。
流的概念已经被 UNIX/Linux 系统所广泛使用。如进程通信中的管道就是用流来实现
的。
Ritchie 还为 C 开发了一个基于流的 I/O 库，称为标准 I/O 库。这个库具有有效的、功
能强大的和可移植的文件访问性能。组成库的例行程序提供了一个用户不可见的自动缓冲
机构，从而使得访问文件的次数和调用系统调用的次数最小化，取得了较高的效率。这个
库的使用范围较广，因为它提供了许多比系统调用 read 和 write 更强的性能，如格式输出
和数据转换等。标准 I/O 例行库还是可移植的，它们不受任何 UNIX 的特殊性的限制，并
且已经成为与 UNIX 无关的 C 语言 ANSI 标准部分。任何 C 编译程序都提供对标准 I/O 库
全部例行程序的访问，而不管其操作系统是什么。
输入输出（文件系统及其操作）是 UNIX/Linux 程序设计中的基础和重要组成，但是
由于在大部分 C 语言教材中对此都有比较详细的介绍，故请对这个问题有兴趣的读者自行
参阅其它资料，这里不再赘述。
2.3  进程
在多道程序工作的环境下，操作系统必须能够实现资源的共享和程序的并发执行，从
而使程序的执行出现了并行、动态和相互制约的新特征。为了能反映程序活动的这些新特
点，UNIX 引入了进程（process）这个概念。UNIX 的进程是一个正在执行的程序的映象。
这里需要注意的是程序和进程的区别。一个程序是一个可执行的文件，而一个进程则是一
个执行中的程序实例。在 UNIX/Linux 系统中可以同时执行多个进程（这一特征有时称为
多任务设计），对进程数目无逻辑上的限制，并且系统中可以同时存在一个程序的多个实例。
各种系统调用允许进程创建新进程、终止进程、对进程执行的阶段进行同步及控制对各种
事件的反映。在进程使用系统调用的条件下，进程便相互独立的执行了。
进程是 UNIX/Linux 程序设计中最重要的部分，在后面的章节中我们将对进程作详细
的介绍。
- 22 -
Linux网络编程
第三章  进程控制
3.1  进程的建立与运行
3.1.1  进程的概念
在 UNIX 中，进程是正在执行的程序。它相当于 Windows 环境内的任务这一概念。每
个进程包括程序代码和数据。其中数据包含程序变量数据、外部数据和程序堆栈等。
系统的命令解释程序 shell 为了执行一条命令，就要建立一个新的进程并运行它，例如：
$cat file1
该命令就会使 shell 专门建立一个进程来运行 cat 命令。
再看一个复杂一些的命令：
$ls | wc –ll
这个命令就会使 shell 建立两个进程，以并发运行命令 ls 和 wc,把目录列表命令 ls 的输
出通过管道送至字计数命令 wc。
因为一个进程对应于一个程序的执行，所以绝对不要把进程与程序这两个概念相混淆。
进程是动态的概念，而程序为静态的概念。实际上，多个进程可以并发执行同一个程序，
对于公用的实用程序就常常是这样。例如，几个用户可以同时运行一个编辑程序，每个用
户对此程序的执行均作为一个单独的进程。
在 UNIX 中，一个进程又可以启动另一个进程，这就给 UNIX 的进程环境提供了一个
象文件系统目录树那样的层次结构。进程树的顶端是一个控制进程，它是一个名为 init 的
程序的执行，该进程是所有用户进程的祖先。
Linux 同样向程序员提供一些进程控制方面的系统调用，其中最重要的有以下几个：
1．fork()。它通过复制调用进程来建立新的进程，它是最基本的进程建立操作。
2．exec。它包括一系列的系统调用，其中每个系统调用都完成相同的功能，即通过用
一个新的程序覆盖原内存空间，来实现进程的转变。各种 exec 系统调用之间的区别仅在于
它们的参数构造不同。
3．wait()。它提供了初级的进程同步措施，它能使一个进程等待，直到另一个进程结
束为止。
4．exit()。这个系统调用常用来终止一个进程的运行。
在下面，我们将对 Linux 的进程进行详细的讨论，并要对以上系统调用作出详细的介
绍。
3.1.2  进程的建立
系统调用 fork()是建立进程的最基本操作，它是把 Linux 变换为多任务系统的基础。fork()
在 Linux 系统库 unistd.h 中的函数声明如下：
       pid_t fork(void);
如果 fork()调用成功，就会使内核建立一个新的进程，所建的新进程是调用 fork()的进
程的副本。也就是说，新的进程运行与其创建者一样的程序，其中的变量具有与创建进程
那变量相同的值。但是这两个进程间还是有差距的，我们在下面将详细的讨论。
第三章 进程控制
- 23 -
新建立的进程被成为子进程（child process），那个调用 fork()建立此新进程的进程被称
为父进程（parent process）。以后，父进程与子进程就并发执行，它们都从 fork()调用后的
那句语句开始执行。
有些读者可能习惯于纯串行的程序设计环境，一开始对 fork()调用的理解可能会有一
些困难。图 3-1 给出了 fork()调用的情况，有助于对 fork()调用的理解。图中给出了三个语
句，先是调用 printf()，随后调用 fork()，然后又调用 printf()。
图 3- 1  fork()调用执行示意图
如图 3-1，它分为 fork()调用前和调用后两部分。调用前的那一部分给出了进程 A 调用
fork()的情况。PC（程序计数器）指向当前执行的语句。这时它指向第一个 printf 语句。调
用后那一部分给出了调用 fork()以后的情况。这时进程 A 和 B 一起运行，进程 A 是父进程，
进程 B 是子进程，它是进程 A 的副本，执行与 A 一样的程序。两个 PC 都指向第二个 printf
语句，即 fork()调用之后的语句。也就是说，A 和 B 都从程序的相同点开始执行。
系统调用 fork()没有参数，它返回一个 pid_t 类型的值 pid。pid 被用来区分父进程和子
进程。在父进程中，pid 被置为一个非 0 的正整数；在子进程中，pid 被置为 0。根据 fork()
在父进程和子进程中的返回值不同，程序员可以据此为两个进程指定不同的工作。
在父进程中，pid 中返回的数是子进程的进程标识符。这个数用于在系统中表示一个进
程，就像用户标识符标识一个用户那样。因为所有的进程都是通过 fork()调用形成的，所以
每个 UNIX 进程都有自己的进程标识符，而且它是唯一的。
下面请大家看一个程序，从中可以看到系统调用 fork()的作用，以及进程标识符的使
用情况：
- 24 -
Linux网络编程
#include 
#include 
main()
{
pid_t pid;
printf(“Now only one process\n”);
printf(“Calling fork…\n”);
pid=fork();
if (!pid)
printf(“I’m the child\n”);
else if (pid>0)
printf(“I’m the parent, child has pid %d\n”,pid);
else
print (“Fork fail!\n”);
}
fork 调用后面的条件语句有三个分支：第一个分支对应于 pid 的值为零，它给出了子
进程的工作；第二个分支对应于 pid 之值为正数，它给出了父进程的工作。第三个分支对
应于 pid 之值为负数（实际为-1），它给出了 fork 建立子进程失败时所作的工作。当系统那
进程总数已达到系统规定的最大数，或者是用户可建立的进程数已达到系统规定的最大数
时，这时再调用 fork，则会导致失败，并在 errno 中含有出错代码 EAGAIN。我们还应该
注意到。上述两个进程间没有同步措施，所以父进程和子进程的输出内容有可能会叠加在
一起。
从上面的讨论可以直到，fork()调用是一个非常有用的系统调用。如果把它隔离起来单
独看的话，其似乎是空洞无意义的。但是，当它与其它的 Linux 功能结合起来时，就显现
出了它的价值。例如，可以用 Linux 提供的进程间通信机构（如信号和管道等），使父进程
与子进程协作完成彼此有关的不同任务。经常与 fork()配合使用的另一个系统调用是 exec，
我们即将在下面讨论它。
3.1.3  进程的运行
1．系统调用 exec 系列
如果 fork()是程序员唯一可使用的建立进程的手段，那么 Linux 的性能会受很大影响。
因为 fork()只能建立相同程序的副本。幸运的是，Linux 还提供了系统调用 exec 系列，它可
以用于新程序的运行。exec 系列中的系统调用都完成相同的功能，它们把一个新程序装入
调用进程的内存空间，来改变调用进程的执行代码，从而形成新进程。如果 exec 调用成功，
调用进程将被覆盖，然后从新程序的入口开始执行。这样就产生了一个新的进程，但是它
的进程标识符与调用进程相同。这就是说，exec 没有建立一个与调用进程并发的新进程，
而是用新进程取代了原来的进程。所以，对 exec 调用成功后，没有任何数据返回，这与 fork()
不同。下面给出了 exec 系列调用在 Linux 系统库中 unistd.h 中的函数声明：
       int execl( const char *path, const char *arg, ...);
       int execlp( const char *file, const char *arg, ...);
       int  execle( const char *path, const char *arg , ..., char* const envp[]);
       int execv( const char *path, char *const argv[]);
       int execvp( const char *file, char *const argv[]);
第三章 进程控制
- 25 -
为了使事情简单明了，我们将着重讨论 exec 系列中的一个系统调用，即 execl()。execl()
调用的参数均为字符型指针，第一个参数 path 给出了被执行的程序所在的文件名，它必须
是一个有效的路径名，文件本身也必须含有一个真正的可执行程序。但是不能用 exec()l 来
运行一个 shell 命令组成的文件。系统只要检查文件的开头两个字节，就可以知到该文件是
否为程序文件（程序文件的开头两个字节是系统规定的专用值）。第二个以及用省略号表示
的其它参数一起组成了该程序执行时的参数表。按照 Linux 的惯例，参数表的第一项是不
带路径的程序文件名。被调用的程序可以访问这个参数表，它们相当于 shell 下的命令行参
数。实际上，shell 本身对命令的调用也是用 exec 调用来实现的。由于参数的个数是任意的，
所以必须用一个 null 指针来标记参数表的结尾。下面给出一个使用 execl 调用来运行目录
列表程序 ls 的例子：
#include 
#include 
main()
{
printf(“Executing ls\n”);
execl(“/bin/ls”,”ls”,”-l”,NULL);
/* 如果 execl返回，说明调用失败 */
perror(“execl failed to run ls”);
exit(1);
}
我们用图 3-2 来表示该程序的工作情况。调用前那一部分给出了 execl()即将执行之前
时的进程情况，调用后那一部分给出了被改变进程的情况，它现在运行 ls 程序。程序计数
器 PC 指向 ls 的第一行，表明 execl()导致从新程序的入口开始执行。
请注意，程序在 execl()调用后紧跟着一个对库例行程序 perror()的无条件调用。这是因
为，如果调用程序还存在，并且 execl()调用返回，那么肯定是 execl()调用出错了。这时，execl()
和其它 exec 调用总是返回-1。这也就是说，只要 execl()和其它 exec 调用成功，就肯定清除
了调用程序而代之以新的程序。
exec 系列的其它系统调用给程序员提供使用 exec 功能的灵活性，它们能适用于多种形
式的参数表。execv()只有两个参数：第一个参数指向被执行的程序文件的路径名，第二个
参数 argv 是一个字符型指针的数组，如下所示：
char *argv []
这个数组中的第一个元素指向被执行程序的文件名（不含路径），剩下的元素指向程序
所用的参数。因为该参数表的长度是不确定的，所以要用 null 指针作结尾。
下面给出一个用 execv()运行 ls 命令的例子：
#include 
#include 
main()
{
char* av[]={"ls","-l",NULL};
execv("/bin/ls",av);
perror("execv failed");
- 26 -
Linux网络编程
exit(1);
}
图 3-2  exec()调用执行示意图
系统调用 execlp()和 execvp()分别类似于系统调用 execl()和 execv()，它们的主要区别
是：execlp()和 execvp()的第一个参数指向的是一个简单的文件名，而不是一个路径名。它
们通过检索 shell 环境变量 PATH指出的目录，来得到该文件名的路径前缀部分。例如，可