S t r i n g fileName = " l o c S i n k " ;
Fil eOu tpu tStr eam sink
= openFileOutput ( fileName , 0 ) ;
long time = System . c u r r e n t T i m e M i l l i s ( ) ;
S t r i n g s t r = gpsLong + gpsLat + time ;
sink . w r i t e ( s t r . g e t B y t e s ( ) ) ;
sink . c l o s e ( ) ;
1
2
3
4
5
6
7
8
9
}
Listing 1: An example of soft-coded file access.
Figure 1: Illustration of the /data/ and /sdcard/ directories
in Android’s file system.
several sub-directories under an app’s directory. Example sub-
directories include /files/, /databases/, /share_prefs/, and /cache/. The
sub-directory /files/ can include any files, /databases/ stores SQLite
database files, /share_prefs/ stores SharedPreferences files, and
/cache/ stores cache files. A SharedPreferences file can be viewed
as a simple database, in which data are stored in key-value pairs.
When an app wants to use external storage and has the per-
mission to do so, Android will create a directory /sdcard/Android/-
data// for the app. Moreover, this directory contains
sub-directories /files/ and /cache/. Unlike the internal storage, data
stored in the external storage can be read by all other apps on
the device. Moreover, the external storage also has other public
directories such as Pictures and Download. We note that if a device
does not have a real SD card, Android will use a part of the internal
storage to emulate one and link /sdcard/ to it.
File access: An app can access a file using either a hard-coded
approach or a soft-coded approach. Specifically, in the hard-coded
approach, an app specifies an absolute file path (e.g., /data/data/-
com.facebook.katana/files/a.txt) and reads/writes to the file. In the
soft-coded approach, the app uses an Android API to locate a file
and then operates on the file. Table 1 shows some example Android
APIs that can be used to find file paths. These APIs were found
via reading through the latest version Android documentation and
source code. Listing 1 shows an example of soft-coded file access.
The app uses an API openFileOutput(fileName, 0) at line 4 to open
the file /data/data//files/locSink, and then the app
writes GPS location and time to the file.
/data/data///sdcard/files/databases/share_prefs/cache/Download/… …Android/data//Pictures/… …CCS ’18, October 15–19, 2018, Toronto, ON, Canada
Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan
2.2 Problem Definition
Suppose a forensic investigator is investigating a crime and has col-
lected a suspect’s mobile device. Moreover, the forensic investigator
has obtained a file system image from the device, e.g., through phys-
ical image extraction [29]. We note that it is a common practice in
forensics that the forensic investigator can retrieve the file system
image, e.g., using SRSRoot [6]. There could be thousands of files on
the device. For example, we extracted the physical image of a Nexus
7 tablet that was used for around 5 years. The device has installed
90 apps (including both system and user apps), which generated
around 19K files. The forensic investigator aims to identify the
files on the device that could contain certain types of evidentiary
data, e.g., GPS locations, visited URLs. We call the problem evidence
identification problem, and we formally describe it as follows:
Definition 2.1 (Evidence Identification Problem). Given an image
of a device’s file system and a type of evidentiary data, the evidence
identification problem is to identify the files (if any) that contain
the type of evidentiary data.
In this work, we focus on solving the evidence identification
problem for Android smartphones. Moreover, we focus on the evi-
dentiary data including location, time, visited URL, and text input as
they were shown to be useful digital evidence in real-world crime
investigations [14, 27, 32, 42]. For instance, GPS locations and texts
retrieved from suspects’ smartphones were used to corroborate
charges in one of the biggest poaching cases in Washington [14];
visited URLs retrieved from a suspect’s smartphone are used as
important digital evidence for investigating a kidnapping case that
happened at University of Illinois Urbana-Champaign in 2017. Al-
though we focus on these types of evidentiary data, our techniques
can be easily extended to other types of data such as contacts, device
ID, and sensors, if a forensic investigator is interested in analyzing
such data for potential evidence.
3 EVIHUNTER
3.1 Overview
Figure 2 overviews our EviHunter, which consists of two compo-
nents, App Evidence Database and Matcher.
App Evidence Database (AED): AED contains the evidentiary
data for a large number of apps. Specifically, each row of AED
represents a file that could be generated by an app and the types
of evidentiary data that the file contains. Files are identified by
their file paths. AED has three columns: the first column includes
apps’ package names; the second column includes file paths; and
the third column indicates the types of evidentiary data that the
corresponding file could contain. A file path could be either static or
dynamic. Specifically, if a file path does not depend on the execution
environment of the app that generates the file, then the file path is
static, otherwise it is dynamic. Therefore, if an app uses a static file
path for a file, then this file has the same path on different devices;
if an app uses a dynamic file path for a file, then the file path could
be different on different devices and at different times. For instance,
an app could use timestamp as a part of a file’s name, which results
in a dynamic file path. In our AED, a dynamic file path includes
the pattern for the dynamic part. For instance, /data/data//files/evidence-.txt represents that the app could
Figure 2: Overview of our EviHunter.
generate a file whose file name includes the timestamp when the
file was generated.
Matcher: Given a file system image from a suspect’s device, the
Matcher matches the file paths on the device against those in the
AED, to identify the files on the device that could contain the
evidentiary data of interest to forensic investigators. If the device
has an app that is not included in AED, we will analyze the app
using EviHunter and add the results into AED. A file path on the
device is matched against a file path in the AED if they are the
same.
Moreover, when matching a file path against a dynamic file
path in the AED, a forensic investigator can use partial match via
ignoring the dynamic part or consider the pattern (e.g., date format)
of the dynamic part via regular expression.
Next, we discuss how EviHunter builds the AED.
3.2 Building the AED via Static Analysis
AED should have a high coverage to avoid missing potential eviden-
tiary data. Specifically, for an app, AED should include as many file
paths that contain evidentiary data as possible. we leverage static
analysis instead of dynamic analysis to build the AED. In particular,
we develop a static data-flow analysis method to build an AED for
a large number of apps. Specifically, in our static data-flow analysis,
we define a customized tag structure for variables and propagate
the tags in an app via forward analysis. We leverage existing sink
methods for file system found by existing tools [12, 21, 35]. How-
ever, we uncover new sources as the sources in existing tools are
not complete.
3.2.1 Pre-processing. Given an app, we first use Soot [43] to trans-
form the app to Jimple code, a three address intermediate repre-
sentation. Second, we use IC3 [16] to build the inter-connected
component communication (ICC) models. Finally, we use Flow-
Droid [12] to construct call graphs and entry points. The latest
version of FlowDroid has integrated IccTA [28] to incorporate the
ICC models when building call graphs. FlowDroid also extracts the
app’s package name, which we will use as the app’s identifier. We
note that FlowDroid alone is insufficient to build our AED. Specifi-
cally, FlowDroid aims to identify data flows from sources to sinks.
However, FlowDroid does not identify the file paths where data are
written to.
3.2.2 Tag for a Variable. We define a tag structure for each variable,
e.g., primitive, object, and class field. Then, we propagate variables’
App Evidence DatabaseFile System Image of Suspect’s DeviceMatcherForensic Analysis ReportApp Package NameEvidence File PathEvidence Typecom.app1com.app1com.app2com.app2 /data/data/com.app1/files/a.txtlocation, time /data/data/com.app1/databases/m.sqlitevisited URL /data/data/com.app2/shared_prefs/b.xmltext input /data/data/com.app2/cache/crash.bintimeEviHunter
CCS ’18, October 15–19, 2018, Toronto, ON, Canada
Table 2: Propagation rules of non-method-invoking statements. Ca is a constant string, while Cb
is a constant that is not string. fA and fB are static fields, while fa and fb are instance fields.
Statement
EvSet
t(va).EvSet ← ∅
t(va).EvSet ← ∅
t(va).EvSet ← t(vb).EvSet
t(va).EvSet ← t(fB).EvSet
t(fA).EvSet ← t(vb).EvSet
t(va).EvSet ← t(vb .f ).EvSet
t(va .f ).EvSet ← t(vb).EvSet
t(va).EvSet ← t(vb).EvSet
t(va).EvSet ← t(va).EvSet ∪ t(vc).EvSet
t(va).EvSet ← t(vb).EvSet ∪ t(vc).EvSet
2 t(va).EvSet ← t(vb).EvSet ∪ t(vc).EvSet
va = Ca
va = Cb
va = vb
va = fB
fA = vb
va = vb .fb
va .fa = vb
va = vb[vc]
va[vb] = vc
1
va = vb + vc
va = vb binop vc
1 When vb and vc are string values.
2 When the binary operator binop is not “+”.
Propagation Rule
Path
t(va).Path ← C
t(va).Path ← ∅
t(va).Path ← t(vb).Path
t(va).Path ← t(fB).Path
t(fA).Path ← t(vb).Path
t(va).Path ← t(vb .f ).Path
t(va .f ).Path ← t(vb).Path
t(va).Path ← t(vb).Path
t(va).Path ← t(vc).Path
t(va).Path ← t(vb).Path + t(vc).Path
t(va).Path ← ∅
tags via performing forward data-flow analysis starting from the
entry point in the call graph. We denote by t(v) the tag for a variable
v. The tag should carry sufficient information to identify both
the types of evidentiary data and the file paths. To achieve these
goals, we propose a tag structure which includes the following
information:
• Evidence type set (EvSet): Types of evidentiary data that a
variable could contain.
• File path (Path): File path associated with a variable. For
instance, when an app writes data to file system via a file
descriptor, the Path associated with the file descriptor is the
file where data are written to.
We note that in conventional static analysis tools that were
designed to detect sensitive data flows in Android apps, a tag often
only includes the data types (i.e., EvSet in our case).
3.2.3 Propagation Rules. Propagation rules define how tags are
updated when analyzing the statements in an app. Our rules are
applied to the three-address Jimple code of an app. We classify
statements into two groups, i.e., non-method-invoking statements
and method-invoking statements. We discuss the propagation rules
for them separately.
Non-method-invoking statements: Table 2 shows the propa-
gation rules for the possible non-method-invoking statements in
the Jimple intermediate representation. When a statement assigns
a constant string to a variable, we set the EvSet and Path of the
variable’s tag to be empty and the constant, respectively; if the
constant is not a string, we will set both EvSet and Path to be empty.
Moreover, when a statement assigns one variable’s value to another
variable, i.e., va = vb, we assign vb’s tag to va. Next, we discuss
the statements with more complex assignment relationships.
• Class field access: A class field can be a static field or an
instance field. A static field is shared by all instances of a
class, while an instance field is unique to an instance of a
class. Each field has a tag. We maintain static fields of a class
in a globally available map, where static fields are keys and
their tags are values in the map. For an instance, we use
a map to maintain its instance fields and their tags, where
fields are keys and their tags are values in the map. This map
structure can help track the fields of an object.
• Array access: For an array variable va, we store its tag t(va)
as the union of the tags of its elements. Moreover, for each
array, we maintain a map that stores the tags of its elements.
For instance, t(va .i) is the tag of the ith element of the ar-
ray variable va. For each array access, we resolve the index
whenever we can. Suppose we have an assignment statement
va[vb] = vc. If the index variable vb can be resolved, we
propagate tags as t(va .vb) ← t(vc), otherwise we merge the
evidence set t(vc).EvSet of the variable vc into that of va. In
the case of the statement va = vb[vc], if vc is resolvable, we
assign the tag of the element vc to va, otherwise we assign
the tag of the array variable vb to that of the variable va.
The propagation rules for array access shown in Table 2 are
for the scenarios where index cannot be resolved.
• Binary operator: We propagate the union of the EvSet of the
two operands for all binary operators. If the operator is +
and both operands are string, then we update the Path as the
concatenation of the Path of the two operands, otherwise
we set the Path to be empty.
v1.method(v2, v3, · · · );
v0 = v1.method(v2, v3, · · · );
(1)
(2)
Method-invoking statements: A method-invoking statement could
be a method call without leveraging the return value or a method
call with assigning the return value to a variable. We abstract the
two cases in Equation 1 and 2, respectively. In the first case, we
CCS ’18, October 15–19, 2018, Toronto, ON, Canada
Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan
Table 3: Data-flow summary of example Android APIs for file access.
Method
getDataDirectory()
getCacheDir()
getFilesDir()
getFileStreamPath(String v2)
openFileOutput(String v2, int v3)
getDataDir()
openOrCreateDatabase(String v2, ... )
openDatabase(String v2, ... )
getSharedPreferences(String v2,int v3)
getDefaultSharedPreferences(Context v2)
getPreferences(int v2)
getDir(String v2, int v3)
openOrCreateDatabase(File v2, ... )
getExternalStorageDirectory()
getExternalStoragePublicDirectory(String v2)
getObbDir()
getExternalCacheDir()
getExternalFilesDir(String v2)
Data-flow Summary
t(v0).Path ← "/data/"
t(v0).Path ← "/data/data//cache/"
t(v0).Path ← "/data/data//files/"
t(v0).Path ← "/data/data//files/" + v2
t(v0).Path ← "/data/data//files/" + v2
t(v0).Path ← "/data/data//databases/"
t(v0).Path ← "/data/data//databases/" + v2
t(v0).Path ← "/data/data//databases/" + v2
t(v0).Path ← "/data/data//shared_prefs/" + t(v1).Path + ".xml"
t(v0).Path ← "/data/data//shared_prefs/_preferences.xml"
t(v0).Path ← "/data/data//shared_prefs/.xml"
t(v0).Path ← "/data/data//app_" + v2
t(v0).Path ← t(v2).Path
t(v0).Path ← "/sdcard/"
t(v0).Path ← "/sdcard/", if v2 is empty.