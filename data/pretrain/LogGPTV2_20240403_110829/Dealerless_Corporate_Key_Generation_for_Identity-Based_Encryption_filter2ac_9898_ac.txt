For any monotonic access structure A and an autho-
rized set A ∈ A, let (M, ρ) ← GenLsssM atrix(A)
be the LSSS matrix realizing A, and I = {i|ρ(i) ∈
A} be the index set of the rows labeled by the par-
ties in A, F indLsssConst(A, (M, ρ), A)1 outputs con-
i∈I wiMi = (1, 0,
. . . , 0). Note that wi (cid:54)= 0 ∀i ∈ I, since we assume A is
a minimum authorized set as above. Note that there
are eﬃcient (i.e. polynomial time) algorithm to im-
plement the F indLsssConst() algorithm, for example
the Gaussian Elimination.
Thus, for any monotonic access structure A, let (M, ρ) ←
GenLsssM atrix(A), and for any authorized set A ∈ A,
let {wi|i ∈ I} ← F indLsssConst(A, (M, ρ), A) where I =
{i|ρ(i) ∈ A}. For any secret s ∈ Zp, we can generate
the secret share vector by (s1, . . . , sm) = M(cid:126)v, where (cid:126)v =
(s, v2, . . . , vd) is column vector with v2, . . . , vd randomly cho-
sen from Zp, and we can recover the secret from the shares
provided by the parties in A by s =(cid:80)
i∈I wisi.
4.
IBE WITH DEALERLESS DISTRIBUTED
PKG
Now following the Key-Homomorphic IBE template, we
propose a Dealerless Distributed PKG protocol for IBE,
where the master secret key is setup in a completely dis-
tributed manner among multiple PKGs, according to a pol-
icy that reﬂects the practical requirements on security and
1Note that we may remove the input A, as the LSSS (M, ρ)
is enough to express the access policy.
availability. The policy could be any monotonic access struc-
tures. Also, we present the user private key generation pro-
cess, as well as the (unaﬀected) encryption and decryption
algorithms, for this IBE with Distributed PKG.
4.1 IBE with Dealerless Distributed PKG sup-
porting Any Monotonic Access Structures
First we make some presettings as follows:
1. The protocol is designed and analyzed in the asyn-
chronous communication model, i.e. we do not require
that messages of a given round in the protocol are sent
by all parties, and delivered to their intended recipi-
ents, simultaneously.
2. All PKGs in the protocol intend to run the protocol
successfully, although some of them are dishonest and
try to gain some advantage on the ﬁnal result. When
dishonest behaviours are detected, the protocol will
abort and investigation will be started. The goal of
dishonest PKG(s) is to gain some advantage without
causing the protocol to abort or to avoid being inves-
tigated when the protocol aborts due to the detection
of dishonest behaviours. In other words, the PKGs are
covert adversaries [1], i.e. they may deviate arbitrarily
from the protocol speciﬁcation in an attempt to cheat,
but do not wish to be “caught” doing so.
3. There is a bulletin board that could be accessed by the
public.
4. The LSSS matrix (M, ρ) is generated by running the
GenLsssM atrix() algorithm with the access policy A,
and PKGs are assigned index. Let n × d be the size
of the matrix M . If some PKG will be assigned to k
shares, then it will be given k index and act as k dif-
ferent PKGs. At last, we assume there are n diﬀerent
PKGs P1, . . . , Pn, although some of them actually are
the same entity. Without loss of generality, and for
simplicity, we assume ρ(i) = Pi.
5. There exist a secure cryptographic hash function H, a
secure public key encryption scheme Π = (EnKeyGen,
Encrypt, Decrypt), and a secure signature scheme Σ =
(SnKeyGen, Sign, V erif y).
The Setup Protocol of Distributed PKG:
1. Initialize.
Each Pi publishes its certiﬁed signature veriﬁcation
key V Ki to the public bulletin board.
In addition,
it generates a temporary encryption key pair (T P Ki,
T DKi) ← EnKeyGen(λ), signs T P Ki using its se-
cret signing key SKi, and publishes T P Ki and the
corresponding signature to the public bulletin board.
A unique protocol identiﬁer pid is created. All PKGs
agree on the same underlying group G and CMPK.
2. Generate shares and commit to a ﬁngerprint.
Each Pi (i = 1, . . . , n) executes the following actions:
(a) Pi chooses uniformly random αi ∈ Z∗
p, and com-
putes Ei ← Fp(αi, CMPK), si ← fs(αi, CMPK).
215(b) Pi computes the shares of Ei and si using the
LSSS matrix (M, ρ): Pi chooses ui,2, . . . , ui,d ∈
Zp randomly and sets (cid:126)ui = (αi, ui,2, . . . , ui,d),
then for j = 1,··· , n, Pi computes
αi,j ← Mj · (cid:126)ui,
si,j ← fs(αi,j, CMPK), Ei,j ← Fp(αi,j, CMPK).
It is worth noticing that the values of si,j and
Ei,j can also be computed even when Pi does
In particular, for
not know the value of αi
j = 1,··· , n, let Mj = (Mj,1, . . . , Mj,d) be the
j-th row of M , Pi computes si,j ← s
⊕
k=2 Mj,kui,k, CMPK) and Ei,j ← E
⊗
k=2 Mj,kui,k, CMPK), where ui,2, . . . , ui,d ∈
fs((cid:80)d
Fp((cid:80)d
(c) Pi computes a ﬁngerprint f pi ← H(cid:0)(i, 1, Ei,1)
||(i, 2, Ei,2)|| . . .||(i, n, Ei,n)||(i, Ei)(cid:1).
Zp are randomly chosen. 3
⊕Mj,1
i
⊗Mj,1
i
2.
(d) Pi signs the ﬁngerprint by σ(1)
(i, f pi, pid||1)), 4 and publishes (σ(1)
to the public bulletin board.
i
i ← Sign(SKi,
, (i, f pi, pid||1))
aborts, since this implies that the corresponding
Pj did not execute Step (3a) honestly.
Note that Step 2 and Step 3 can be executed in a
parallel manner.
4. Distribute secret shares and publish the corre-
sponding public shares.
Now all the values {(σ(1)
i=1 on the
public bulletin board have been acknowledged/endorsed
by all PKGs.6 Each Pi(i = 1, . . . , n) then takes the fol-
lowing actions:
, (i, f pi, pid||1))}n
i
i ← Sign(SKi, (i, 1, Ei,1)||(i, 2,
(a) Pi computes σ(3)
Ei,2)|| . . .||(i, n, Ei,n)||(i, Ei)||pid||3), and publishes
, ({(i, j, Ei,j)}n
j=1, (i, Ei), pid||3)) to the pub-
(σ(3)
lic bulletin board.
i
(b) For j = 1, . . . , n, Pi computes δi,j ← Encrypt(T P Kj ,
i,j ← Sign(SKi, (i, j, δi,j, pid||4)),
j=1 to the
i,j , (i, j, δi,j, pid||4))}n
(i, j, si,j )) and σ(4)
and publishes {(σ(4)
public bulletin board.
3. Verify signatures on the ﬁngerprints. 5
5. Verify the public shares.
(a) Each Pj(j = 1, . . . , n) veriﬁes other PKGs’ (ﬁn-
gerprint, signature) pairs, and signs and publishes
their veriﬁcation results to the public bulletin board.
To do this, Pj does the followings for each i ∈
{1, . . . , n} \ {j}.
i. Pj computes resulti,j ← V erif y(V Ki, (i, f pi,
). Note that resulti,j ∈ {TRUE,
pid||1), σ(1)
FALSE}.
i
ii. If resulti,j = FALSE, Pj publishes a com-
is dishonestly executing the
plaint that Pi
protocol, and the protocol aborts.
i
(b) Finally, for each (σ(1)
putes σ(2)
and publishes (σ(2)
the public bulletin board.
iii. Otherwise (i.e. resulti,j = TRUE), Pj com-
i,j ← Sign(SKj, (i, j, resulti,j, pid||2)),
i,j , (i, j, resulti,j, pid||2)) to
, (i, f pi, pid||1)) (i = 1, . . . , n),
if any of the corresponding veriﬁcation results {(σ(2)
i,j ,
(i, j, resulti,j, pid||2))}j∈{1,...,n}\{i} has invalid sig-
nature σ(2)
i,j or has resulti,j = FALSE, the protocol
2Such a case may happen after the later protocol for dy-
namic PKGs’ change is run.
⊕Mj,1
3Note that si,j = s
i
⊕ fs((cid:80)d
fs(αi, CMPK)⊕Mj,1 ⊕ fs((cid:80)d
fs(Mj,1αi +(cid:80)d
⊗ Fp((cid:80)d
Fp(αi, CMPK)⊗Mj,1 ⊗ Fp((cid:80)d
Fp(Mj,1αi +(cid:80)d
k=2 Mj,kui,k, CMPK) =
=
k=2 Mj,kui,k, CMPK) = fs(Mj · (cid:126)ui, CMPK),
⊗Mj,1
E
=
i
=
k=2 Mj,kui,k, CMPK) = Fp(Mj · (cid:126)ui, CMPK).
4pid||1 is used as part of the message to be signed. This is
to defend against the possible replay attacks.
5Verifying the ﬁngerprints before moving to the next step
is to detect any dishonest behaviours as early as possible,
and more importantly, is to guarantee that when complaints
happen in next steps, no PKG can deny the ﬁngerprints
that he had sent in this step. Besides, Pi’s (ﬁngerprint,
signature) pairs need to be checked by all the other PKGs in
{P1, . . . , Pn}\{Pi}, in order to prevent any collusion attacks.
k=2 Mj,kui,k, CMPK)
k=2 Mj,kui,k, CMPK)
k=2 Mj,kui,k, CMPK)
Ei,j
=
(a) Each Pj (j = 1, . . . , n) veriﬁes other PKGs’ public
shares, and signs and publishes their veriﬁcation
results to the public bulletin board. To do this,
Pj does the followings for each i ∈ {1, . . . , n}\{j}.
V erif y(V Ki, (i, 1,
Ei,1)||(i, 2, Ei,2)|| . . .||(i, n, Ei,n)||(i, Ei)||pid||3,
σ(3)
i
i. Pj computes resulti,j ←(cid:16)
Ei,2)|| . . .||(i, n, Ei,n)||(i, Ei)(cid:1)(cid:17)
f pi = H(cid:0)(i, 1, Ei,1)||(i, 2,
(cid:17) ∧(cid:16)
) = TRUE
.
Ei =(cid:78)
ii. If resulti,j = TRUE, Pj checks if {Ei,k, Ei}n
k=1
satisfy the access policy A:
for each (mini-
mum) authorized set T ∈ A, let I = {k|ρ(k) ∈
T}, Pj computes the constants {wk}k∈I ←
F indLsssConst(A, (M, ρ), T ), and checks if
⊗wk
i,k
k∈I E
holds.
resulti,j ← FALSE;
• If any of the checks fails, Pj sets
• otherwise, Pj sets resulti,j ← TRUE.
iii. If resulti,j = FALSE, Pj throws a complaint
that Pi did not execute the protocol hon-
estly, and the protocol aborts. Otherwise (i.e.
i,j ← Sign(
resulti,j = TRUE), Pj computes σ(5)
SKj, (i, j, resulti,j, pid||5)), and publishes
i,j , (i, j, resulti,j, pid||5)) to the public bul-
(σ(5)
letin board.
, ({(i, k, Ei,k)}n
i
k=1, (i, Ei),
pid||3)) (i = 1, . . . , n), if any of the corresponding
veriﬁcation results
i,j , (i, j, resulti,j, pid||5))}j∈{1,...,n}\{i} has in-
{(σ(5)
valid signature σ(5)
i,j or has resulti,j = FALSE, the
protocol aborts, since this implies that the corre-
sponding Pj did not execute Step (5a) honestly.
(b) Finally, for each (σ(3)
6From the view of implementation, all PKGs may copy these
values to its local storage as the evidence in case of any com-
plaint appears. Besides, Step 4 can start only after Step 3
is completed.
2166. Verify the secret shares.
(a) Each Pj(j = 1, . . . , n) checks if all the secret shares
it received from the other PKGs are consistent
with the corresponding public shares. To do this,
Pj does the followings for each i ∈ {1, . . . , n}\{j}.
i. Pj computes resulti,j ← V erif y(V Ki, (i, j,
δi,j, pid||4), σ(4)
i,j ).
ii. If resulti,j = FALSE, Pj throws a complaint
that Pi did not follow the protocol honestly,
and the protocol aborts.
iii. Otherwise (i.e. resulti,j = TRUE), Pj com-
putes (i, j, si,j) ← Decrypt(T DKj, δi,j).
If
MKVerify(CMPK, Ei,j, si,j) (cid:54)= 1, Pj throws a
complaint that Pi did not follow the proto-
col honestly and justiﬁes the complaint by re-
7,
vealing its temporary decryption key T DKj
and the protocol aborts. Otherwise, Pj sets
resulti,j ← TRUE, computes σ(6)
i,j ← Sign(SKj,
(i, j, resulti,j, pid||6)), and publishes (σ(6)
i,j , (i, j,
resulti,j, pid||6)) to the public bulletin board,
i,j , (i, j, δi,j, pid||4)).
as its endorsement for (σ(4)
i,j , (i, j, δi,j, pid||4))}1≤i(cid:54)=j≤n,
if the corresponding veriﬁcation result (σ(6)
i,j , (i, j,
resulti,j, pid||6)) has invalid signature σ(6)
i,j or has
resulti,j = FALSE, the protocol aborts, since this
implies that the corresponding Pj did not execute
Step (6a) honestly.
(b) Finally, for each {(σ(4)
Note that Step (4), Step (5), and Step (6) can be
executed in a parallel manner.
7. Form the Final Shares.
For i = 1, . . . , n, the values ({Ei,j}1≤j≤n, Ei) on the
public bulletin board have been acknowledged/endorsed
by PKGs {P1, . . . , Pn}\{Pi}, and each Pj (j = 1, . . . , n)
has endorsed that all Pis with i ∈ {1, . . . , n} \ {j}
have distributed correct secret shares si,j to it. Each
Pj (j = 1, . . . , n) takes the following actions:
(a) Pj computes E(j) ←(cid:78)n
ter public key to be mpk(j) :=(cid:0)E(j), CMPK(cid:1). In
addition, it computes E ← (cid:78)n
i=1 Ei,j and sets its mas-
i=1 Ei and pub-
lishes E as a part of its master public key.
Note that anyone can check the correctness of
E(j) and E, using the values of {Ei,j, Ei}n
i=1 on
the public bulletin board. This will deter Pj from
dishonestly publishing the values of E(j) and E.
(b) Pj computes s(j) ←(cid:76)n
secret key to be msk(j) :=(cid:0)s(j)(cid:1).
i=1 si,j and sets its master
Note that whether Pj honestly executes this step
to generate its msk(j) cannot be veriﬁed now, but
it will be veriﬁed once Pj uses its msk(j), as dis-
cussed later.
7Note that the validity of T DKj can be checked using the
corresponding T P Kj, and Pi cannot deny the content of δi,j
(due to the signature σ(4)
i,j ).
Suppose that Pj honestly executes Step (7a) and Step
(7b), we have that