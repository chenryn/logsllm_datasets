key difference being that they use structural typing, whereas objects use nominative typing.
This will fail. You can’t modify a non-ref parameter 
because it might have been copied before being passed to 
the procedure. The parameter is said to be immutable.
This will work because 
PersonRef is defined as a ref.
Nominative vs. structural typing
The key difference between nominative typing and structural typing is the way in which
equivalence of types is determined.
Consider the following example:
type
Dog = object
name: string
Cat = object
name: string
let dog: Dog = Dog(name: "Fluffy")
let cat: Cat = Cat(name: "Fluffy")
echo(dog == cat)
The compiler gives an error because the Dog and Cat types aren’t equivalent. That’s
because they were defined separately with two different names.
Now let’s replace the object with tuple:
type
Dog = tuple
name: string
Cat = tuple
name: string
let dog: Dog = (name: "Fluffy")
let cat: Cat = (name: "Fluffy")
echo(dog == cat)
Error: type mismatch: 
got (Dog, Cat)
true
Licensed to   
51
User-defined types
There are many different ways that tuples can be defined. The two most compact ways
are shown here:
type
Point = tuple[x, y: int]
Point2 = (int, int)
You’ll note that a tuple doesn’t need to define the names of its fields. As long as the
order and type of the values in two tuple types match, their types are considered to be
the same.
let pos: Point = (x: 100, y: 50)
doAssert pos == (100, 50)
When a tuple’s fields have no names, you can still access them by using the indexing
operator: []. When a name is defined, the fields can be accessed in the same way that
object fields can be accessed.
 Nim also supports tuple unpacking. A tuple’s fields can be assigned directly to multi-
ple identifiers. Here’s an example:
let pos: Point = (x: 100, y: 50)
let (x, y) = pos
let (left, _) = pos
doAssert x == pos[0]
doAssert y == pos[1]
doAssert left == x
Tuples are useful for lightweight types with few fields. They’re most commonly used as
a way to return multiple values from procedures. 
2.6.3
Enums
An enum or enumerated type is the third and final type that I’ll introduce in this sec-
tion. Nim enums are very similar to ANSI C’s enums. An enum defines a collection of
identifiers that have some meaning attached to them.
 In Nim, enums have an order attached to them, which means they’re ordinal types
and can be used in case statements and as the base type of sets.
In this case, the compiler is happy to compile this code. The resulting executable dis-
plays the message “true,” because the dog and cat variables contain the same data.
The compiler doesn’t look at the names of the type; instead, it looks at their structure
to determine whether they’re equivalent.
That’s the fundamental difference between tuples and objects.
You can specify any name, as long as 
the number of fields on the left of the 
equals sign is the same as the 
number of fields in the tuple.
You can use a single 
underscore (_) in order 
to discard fields.
Licensed to   
52
CHAPTER 2
Getting started
type
Color = enum
colRed,
colGreen,
colBlue
let color: Color = colRed
Listing 2.14 defines a new Color enum. You’ll note that when specifying the values,
you don’t need to prefix them with the name of the enum—I added a prefix to each
value to make them a little bit more distinguishable. There’s a pragma called pure
that makes it mandatory to prefix each of the enum’s values with the name of that
enum, followed by a dot.
type
Color {.pure.} = enum
red, green, blue
let color = Color.red
Depending on your use case, you may wish to prefix the enum values manually with
something that’s shorter than the enum’s name, or you can let Nim enforce the prefix
automatically with the pure pragma.
Enums can be used to create a collection of meaningful identifiers; they’re most com-
monly used to denote flags.
 This section gave you a small taste of the different ways types can be defined in
Nim. Nim’s type system is very powerful, and this was by no means an extensive
description of it all. You’ll find out more about Nim’s type system throughout this
book. Chapter 9, in particular, will introduce you to generics, which are a very power-
ful feature of Nim’s type system. 
Listing 2.14
Enumerator type
Pragmas
Pragmas are language constructs that specify how a compiler should process its
input. They’re used in Nim fairly often, and depending on their type, they can be
applied to the whole file or to a single definition.
You can also define your own pragmas using macros, which you’ll learn more about
in chapter 9.
For a list of pragmas, take a look at the Nim manual: http://nim-lang.org/docs/
manual.html#pragmas.
Licensed to   
53
Summary
2.7
Summary
 Nim uses indentation to delimit scope and uses # for comments.
 The basic types include int, float, char, string, and bool.
 Mutable and immutable variables can be defined using the var and let key-
words, respectively.
 A value assigned to a constant must be computable at compile time.
 Procedures are defined using the proc keyword.
 The result variable is implicitly defined in every procedure with a return type.
 An array stores a constant number of items.
 A sequence can grow dynamically at runtime.
 The flow of your application can be controlled via the if and case statements.
 One or more statements can be executed multiple times with the while
statement.
 Collection types can be iterated through using the for statement.
 A try statement can be used to handle exceptions at runtime.
 Multiple different data types can be defined under a single type section.
 Non-reference types can’t be modified from inside a procedure.
 Tuples can be used to return multiple values from a single procedure.
Licensed to   
Licensed to   
Part 2
Nim in practice
Now that you know the basics of Nim, you’re ready to move on to writing
some software.
 In chapter 3, you’ll be developing a simple but functional chat application.
This chapter will mainly teach you about asynchronous sockets, but you’ll also
learn something about parsing and generating JSON, reading text from the stan-
dard input stream, and using Nim’s module system.
 Chapter 4 focuses on the standard library, showing you usage examples of
various algorithms and data structures defined there. It also offers a more in-
depth look at the module system.
 Chapter 5 looks at package management, which is extremely common nowa-
days. Package managers are useful because they offer an easy way to install third-
party libraries for use in your applications.
 Chapter 6 is about parallelism. This is an important topic as it allows for some
powerful optimizations, especially in today’s multicore world. In this chapter
we’ll look at a parsing problem that’s easy to parallelize. Different parsing meth-
ods are also demonstrated.
 Chapter 7 leads you through the development of a significantly simplified
Twitter clone. You’ll learn how a web application is created using the Jester web
framework, how HTML can be generated using Nim’s filters, and how to store
data in an SQLite database.
Licensed to   
Licensed to   
57
Writing a
chat application
In the previous chapter, you learned the basics of the Nim programming language,
including the syntax, some of the built-in types, how to define variables and proce-
dures, how to use control-flow statements, and much more.
 In this chapter, you’ll build on and solidify that knowledge by developing a fully
functional chat application. You’ll also learn many new concepts that are essential
to the development of certain applications. In particular, you’ll do the following:
 Build a command-line interface, which can be used to ask the user for input.
 Learn how to use sockets to transfer data over networks, such as the internet.
This chapter covers
 Asking the user for input
 Creating a command-line interface
 Parsing and generating JSON
 Transferring data over the network
 Using and creating modules
Licensed to   
58
CHAPTER 3
Writing a chat application
 Use a JSON parser to build a simple chat protocol. The application will use this
protocol to exchange messages in a standard and consistent manner.
 Learn how to use modules to separate your code into standalone units, which
will make your code more reusable.
With the popularity of the internet, computer networks have become increasingly
important. The most basic feature of the internet is the transfer of data, but imple-
menting this feature isn’t always easy at the programming language level. In creating
this chapter’s chat application, you’ll learn the basics of transferring data between
multiple computers.
 By the end of this chapter, you’ll have successfully written an application consisting
of two different components: a server and a client. You’ll be able to send the client to
your friends and use it to chat with each other in real time over the internet.
 The source code for all the examples in this book is available on GitHub at
https://github.com/dom96/nim-in-action-code.
 Let’s begin by exploring how the application will work and what it will look like.
3.1
The architecture of a chat application
The main purpose of a chat application is to allow multiple people to communicate
using their personal computers. One way to accomplish this is by using a network that
these computers are connected to, like the internet, and sending data over it.
 Unlike applications such as Facebook Messenger or WhatsApp, which are primar-
ily used for one-to-one communication, the chat application developed in this chapter
will primarily support group communication (many-to-many) similar to Internet Relay
Chat (IRC) or Slack. This means that a single message will be sent to multiple users.
3.1.1
What will the finished application look like?
Let’s say I just watched the latest Game of Thrones episode and am now excited to talk
with my friends about it. I’ll call them John and Grace, in case they don’t appreciate
me using their real names in this book. The conversation might go something like this
(no Game of Thrones spoilers, I promise).
Dominik said: What did you guys think about the latest Game of Thrones
episode?
Grace said: I thought Tyrion was really great in it!
John said: I agree with Grace. Tyrion deserves an Emmy for his performance.
At the end of this chapter, you’ll have built an application that will allow this discus-
sion to take place. Let’s see what the finished application will look like in the context
of the preceding conversation.
Listing 3.1
Conversation between me, John, and Grace about Game of Thrones
Licensed to   
59
The architecture of a chat application
I first asked John and Grace what they thought of the latest Game of Thrones episode. I
did this by entering my message into the chat application and pressing the Enter key
to send it (figure 3.1).
 Both John and Grace will receive this message on their computers, and the client
application will show it to both of them in the same way (figure 3.2). Note how my mes-
sage is prefixed by “Dominik said,” letting John and Grace know who sent the message.
Grace can now answer my question by typing in her response and pressing Enter; John
and I will receive her reply. This way, we can have a discussion over the internet rela-
tively easily.
 This should give you an idea of what you’re aiming to achieve by the end of this
chapter. Sure, it might not be as impressive as a full-blown application with a graphical
user interface, but it’s a start.
 Now let’s move on to discussing some of the basic aspects of this application, in
particular, its network architecture.
NETWORK ARCHITECTURES AND MODELS
There are two primary network architectures that can be used for this application: peer-
to-peer networking and the client-server model. With peer-to-peer networking, there’s
no server; instead, each client is connected to multiple other clients that then exchange
information between each other. With the client-server model, there’s a single server to
which all the clients connect. The messages are all sent to the server, and the server
redistributes them to the correct clients. Figure 3.3 shows how these models compare.
 The client-server model is the simpler of the two, and because it works well for the
kind of application that you’ll be writing, we’ll use it.
Figure 3.1
My screen after I send the message
Figure 3.2
John’s and Grace’s screens
Licensed to   
60
CHAPTER 3
Writing a chat application
Another thing to consider is the transport protocol, which you’ll use to transfer mes-
sages in your application. The two major protocols in use today are TCP and UDP.
They’re used widely for many different types of applications, but they differ in two
important ways.
 The most important feature of TCP is that it ensures that messages are delivered to
their destination. Extra information is sent along with the messages to verify that they
have been delivered correctly, but this comes at the cost of some performance.
 UDP doesn’t do this. With UDP, data is sent rapidly, and the protocol doesn’t check
whether the data arrives at its destination. This makes UDP perform better than TCP,
but data transmission is less reliable.
 Chat applications should be efficient, but reliable delivery of messages is more
important. Based on this aspect alone, TCP wins.
NETWORKING
There’s a vast amount of information about networking that’s
outside the scope of this book. I encourage you to research this topic further
if it’s of interest to you. 
THE CLIENT AND SERVER COMPONENTS
Now that you know a bit about the networking side of things, let’s look at how the soft-
ware will actually work. The plan is to create two separate applications, or components: a
server component and a client component.
 When the server first starts, it will begin listening for connections from a client on a
specific port. The port will be hardcoded into the server and chosen ahead of time so it
won’t conflict with any other application. I wouldn’t want it to prevent you from enjoying
a good game of Counter-Strike, would I? Once a connection on that port is detected, the
server will accept it and wait for messages from it. A newly received message will be sent
to any other client whose connection was previously accepted by the server.
 When the client first starts, it will connect to the server address that the user speci-
fied on the command line. Once it successfully connects, the user of the client will be
able to send messages to the server by inputting them through the command line.
The client will also actively listen for messages from the server, and once a message is
received, it will be displayed to the user.
 Figure 3.4 shows how the chat application operates in a simple use case involving
three clients. Dom, John, and Grace are all running clients connected to the server. In
the figure, Dom sends a “Hello” message using their client. The server will accept this
message and pass it on to other clients currently connected to it.
Server
Client
Client
Client
Client
Client
Client
Client
Client
Indicates ﬂow of messages
Client-server 
Peer-to-peer 
Figure 3.3
Client-server 
vs. peer-to-peer
Licensed to   
61
Starting the project
You should now have a good idea of how the chat application will work. The next sec-
tion will show you how to implement it. 
3.2
Starting the project
The previous section outlined how the chat application will work. This section
describes the first steps needed to begin the project. This chapter is an exercise, and I
encourage you to follow along, developing the application as you read it.
 You might find this surprising, but starting a project in Nim is very quick and easy.
You can simply open your favorite text editor, create a new file, and start coding.
 But before you do that, you should decide on a directory layout for your project.
This is entirely optional—the compiler won’t mind if you save all your code in
C:\code, but doing so is bad practice. You should ideally create a new directory just for
this project, such as C:\code\ChatApp (or ~/code/ChatApp). Inside the project direc-
tory, create a src directory to store all your source code. In the future you can, when
necessary, create other directories such as tests, images, docs, and more. Most Nim
projects are laid out this way, as illustrated in the following listing. This project is
small, so it will only use the src directory for now.
MyAwesomeApp
├── bin
│
└── MyAwesomeApp
├── images
│
└── logo.png
├── src
│
└── MyAwesomeApp.nim
└── tests
└── generictest.nim
PROJECT DIRECTORY LAYOUT
A good project directory layout is very beneficial,
especially for large applications. It’s better to set it up sooner rather than
later. Separating your application source code from your tests means that you
can easily write test code that doesn’t conflict or otherwise affect your applica-
tion. In general, this separation also makes code navigation easier.
Now create a client.nim file in the src directory. This file will compile into a client
executable and act as the client component of the chat application. You’re now ready
to start writing code.
Listing 3.2
Typical directory layout for a Nim project
Server
John
Grace
Hello
Dom said Hello
Dom said Hello
Dom
Figure 3.4
The operation 
of the chat application
The root directory of the MyAwesomeApp project
Holds all the executables for this project
Holds all the images for this project
Holds all the Nim source code files 
related to this project
Holds all the Nim source code files 
that contain tests for the files in src
Licensed to   
62
CHAPTER 3
Writing a chat application
 As a small test, begin by writing the following into your new client.nim file, and
then save it:
echo("Chat application started")
To compile your new client.nim file, follow these steps.
1
Open a new terminal window.
2
cd into your project directory by executing cd ~/code/ChatApp, replacing
~/code/ChatApp with the path to your project directory.
3
Compile the client.nim file by executing nim c src/client.nim.
APORIA
If you’re using Aporia, you can just press F4 or select Tools > Com-
pile Current File in the menu bar to compile the currently selected tab. You
can also press F5 to compile and run.
If you’ve done everything correctly, you should see the results shown in figure 3.5 in
your terminal window.
OUTPUT DIRECTORY
By default, the Nim compiler will produce the execut-
able beside the Nim source code file that was compiled. You can use the -o
flag to change this. For example, nim c -o:chat src/client.nim will place a
chat executable in the current directory.
Assuming that the compilation was successful, the executable that was created by the
compiler can now be started. To execute it, use the ./src/client command, or
.\src\client.exe if you’re on Windows. This should display “Chat application
started” on the screen and then exit.
 You now have a good starting point for further development. We started out slowly,
and so far your application isn’t doing much. But it gives you an idea of how applica-
tion development in Nim should be initiated, and it ensures that the Nim compiler
works correctly on your computer.
 Now that you’ve made a start on this project, let’s move on to the first task: the
command-line interface. 
Figure 3.5
Successful compilation of client.nim
Licensed to   
63
Retrieving input in the client component
3.3
Retrieving input in the client component
Applications typically expect to receive some sort of guidance from the user, such as
the URL of a website to navigate to or the filename of a video to play. Applications
need this guidance because, sadly, they can’t (yet) read our intentions directly from
our brains. They need explicit instructions in the form of commands or mouse clicks.
The simplest way to guide a piece of software is to give it an explicit command.
 The client component of the chat application will need the following input: the
address of the server to send messages to and one or more messages to send to the
server. These are the minimum inputs the user will need to provide to the chat appli-
cation. You need both a way to ask the user for specific input and a way to then get the
data that the user enters using their keyboard.
 Let’s focus on the minimum data that we need from the user. The address of the
server to connect to is somewhat critical, because it’s needed before the client can do
anything. We should ask the user for it as soon as the client starts. Until the client con-
nects to the server, the user won’t be able to send any messages, so asking the user for
a message will come after.
3.3.1
Retrieving command-line parameters supplied by the user
On the command line, there are two ways you can get data from the user:
 Through command-line parameters, which are passed to your application when
it’s started
 Through the standard input stream, which can be read from at any time