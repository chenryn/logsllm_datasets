local ﬁle system and can be used to implement a purely lo-
cal MLS conﬁguration. In most cases, however, caching
and common networked ﬁle systems will require coordina-
tion of policy across node boundaries.
3. File System I/O Structure in Microsoft Win-
dows NT
The Microsoft Windows NT family of operating systems
[14, 15] exposes several APIs via environmental subsys-
tems. While these APIs are largely procedural in nature, the
internal processing is asynchronous and packet-based in na-
ture. In this regard, it shares more with OpenVMS [3] than
with Unix [4], although one major difference to OpenVMS
is that, like Unix System V Release 4 and later derivatives,
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:05:43 UTC from IEEE Xplore.  Restrictions apply. 
User
Application
Environmental Subsystem
System Support Library
Executive
Cache
Manager
VM
Manager
Remote File
System Driver
I/O Manager
Filter Driver
Local File
System Driver
Class Driver
Port Driver
Miniport Driver
HAL
Storage
Figure 2. Components involved in ﬁle system
I/O
it has a uniﬁed ﬁle system cache and virtual memory archi-
tecture.
Regardless of which environmental subsystem is used,
the I/O operation eventually results in a call to the system
service dispatcher in kernel mode. This dispatcher handles
the distribution of the operations into the various kernel
components1. For the discussion here, only some compo-
nents are of interest. Besides the I/O Manager, the Win-
dows Management Instrumentation (WMI), Plug and Play
(PnP) Manager, and the Power Manager components (these
appear only with Microsoft Windows 2000 and later revi-
sions) are also relevant for device level operations.
The central component, however, is the I/O manager. It
creates I/O request packets (IRP) from incoming requests 2
and ensures that all drivers for which an IRP is relevant
are called with the IRP in the proper sequence. Each IRP
sent to a kernel-mode driver represents a pending I/O re-
quest to that driver. An IRP will continue to be outstand-
1Since Microsoft Windows NT 4.0, graphics interfaces are part of the
kernel mode and bypass this mechanism. The DirectX family of APIs
even allows bypassing of normal operating system protection (memory and
devices) by user mode appliations.
2With the exception of Fast I/O which bypasses this step, loosely pat-
terned after the OpenVMS concept by the same name
ing until the recipient of the IRP invokes the IoCom-
pleteRequest() service routine for that particular IRP.
Invoking IoCompleteRequest() on an IRP results in
that I/O operation being marked as completed, and the I/O
Manager then triggers any post-completion processing that
was awaiting completion of the I/O request. Each request
must be completed exactly once.
This mechanism lends itself to a layered processing ap-
proach in which IRPs are cascaded across several driver lay-
ers (possibly with additional IRPs created along the way at
lower levels). As a side effect of this architecture, one can
alter the functionality of the operating system by interpos-
ing additional layers in the driver stack. One example of
such an interposition is shown in ﬁgure 2.
The placement of the ﬁltering layer in ﬁgure 2 has the
advantage of such a module being able to intercept and op-
erate on generic (ﬁle-system independent) operations from
upper operating system layers; this type of ﬁlter is called
a ﬁle system ﬁlter driver. Most importantly, the depicted
interposition layer allows operations on the ﬁle level. Com-
mon disk encryption mechanisms typically work by adding
special disk drivers or lower level ﬁlter drivers; as a result
they are dependent on speciﬁc hardware or are not able to
work on individual ﬁles; in addition, they do not support re-
mote ﬁle systems. While handling ﬁles individually entails
a signiﬁcantly higher complexity, it is necessary to support
the semantics found in the system described here. Interpo-
sition at this level is also largely3 oblivious to the type of
ﬁle system.
Microsoft Windows NT does not fully adhere to the
packet-based I/O model for all types of drivers, though. A
special case exists in case of ﬁle systems, therefore also
for ﬁle system ﬁlter drivers. This exception is the Fast
I/O mechanism; here the I/O Manager, Cache Manager,
and the various ﬁle system implementations (if they support
this mechanism) interact by means of explicit cross-module
calls instead of creating IRPs. This performance enhance-
ment adds considerable complexity to the design of any ﬁle
system ﬁlter drivers since additional communication paths
must be handled. While it is possible for a driver (partic-
ularly a ﬁlter driver – this has the result that lower-level
drivers are also not confronted with Fast I/O for a given
call) to signal that Fast I/O is not supported with the result
that an equivalent request is created in the form of an IRP
and sent again by the system service dispatcher, the double
performance penalty thus incurred is not justiﬁable.
Microsoft Windows NT uses the ﬁlter driver mechanism
— not only for ﬁle systems — itself to support additional
functionality that is optional or can be made available for
different ﬁle system types with a single driver; one exam-
ple in Microsoft Windows 2000 is the Single Instance Store
3There are some differences in behavior for remote ﬁle system redirec-
tors
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:05:43 UTC from IEEE Xplore.  Restrictions apply. 
File Read/Write
Page Faults
I/O Manager
Page Fault Handler
Filter Driver
Fast I/O
Read/Write
File System Driver
Page Read/Write
Mapped Page Writer
Modified Page Writer
 V
M
M
Copy Read/Write
Lazy Writer
Read Ahead Thread
Memory Mapping
Cache
Manager
Page Faults
Figure 3.
components
Interactions between ﬁle system
(SIS) ﬁle system ﬁlter driver that conserves disk space by
removing multiple copies of a ﬁle and replacing them with
links to a single shared copy in a common directory. An-
other application example of a ﬁle system ﬁlter drivers is a
virus scanner; again, this type of application requires access
to ﬁle system semantics.
Some care needs to be taken in case a ﬁle system ﬁl-
ter driver modiﬁes data on underlying ﬁle systems since the
uniﬁed cache and VM architecture results in Fast I/O re-
quests bypassing the regular ﬁle system (ﬁlter) and access-
ing the cache directly as shown in ﬁgure 3. Failing to update
all relevant access paths could thus lead to inconsistencies.
Some additional details can be found in [8, 9], although
regrettably most of the internal interfaces that need to be
supported are largely undocumented. It should, however,
be noted that apart from issues arising from defects removed
and occasionally introduced and some minor additions, the
internal ﬁle system APIs of this platform have remained rel-
atively stable despite major changes in the portions of the
system visible to most users and developers.
4. Implementation
This section discusses several aspects of implementing
the transparent ﬁle system security mechanism by means of
inserting a ﬁle system ﬁlter driver into the operating systems
of the Microsoft Windows NT platform.
4.1. Structure and Bootstrapping
Each kernel mode driver must provide a DriverEn-
try() function that is called by the I/O manager on
driver load. This function performs initialization opera-
tions of the driver such as reading parameters from reg-
istry settings, allocating data structures, DeviceObject,
and SymbolicLink objects, and initializing the call table
(MajorFunction table).
The MajorFunction table is a list of dispatch points
supported by the driver. Each I/O request is packed into
an IRP by the I/O manager and contains all information
describing the request including the desired operation (the
MajorFunction). The driver may set an entry in this ta-
ble for each MajorFunction it wishes to process with its
own dispatch functions.
The enforcement driver architecture consists of two
parts, namely a ﬁlter driver dealing with ﬁle-system speciﬁc
parts and another kernel module or driver (i.e the ECRM –
which is realized as a pseudo device driver, but is in fact
accessed by direct kernel mode calls instead of using an
IRP-based mechanism) which contols the actual policy op-
erations such as deciding on access rights or encryption and
decryption. This latter driver is called on by the ﬁle system
ﬁlter driver for all intercepted calls on the ﬁle system and
encapsulates all necessary operations such as communica-
tion with a cryptographic coprocessor which may house the
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:05:43 UTC from IEEE Xplore.  Restrictions apply. 
actual ECRM mechanism.
As a result, no cryptographic operations or other opera-
tions related to policy are visible outside of the ECRM. If
such operations are delegated to a tamper-resistant crypto-
graphic coprocessor, this ensures that the policy decisions
and key material used for enforcing such decisions cannot
be modiﬁed unless considerable effort is expended.
The ﬁlter driver mechanism must be logically located
on top of the driver modules whose behavior it wishes to
change, augment, or replace. It is also possible for such a
ﬁlter driver to create new calls to (among others) such lower
layer drivers as may be the case if some more elaborate in-
formation or modiﬁcation to the ﬁle system are required.
The ﬁlter driver described here is located above the ﬁle sys-
tem and is therefore able to work on and identify individual
ﬁles and does not deal with individual device types. File
system ﬁlter drivers operating below the ﬁle system driver
level (but above storage class drivers) are somewhat mis-
named as they are only capable of working on amorphous
data blocks without ﬁle system semantics in the calls reach-
ing such layers as ﬁle operations are broken up into block--
based operations by the respective ﬁle system drivers.
The ability to operate on ﬁles allows the implementa-
tion to gather information on the entities wishing to perform
the respective operation and forward this information to the
ECRM for further processing. If necessary, each individual
ﬁle can therefore be treated differently if possesses an iden-
tifying feature and the security policy or security policies to
be applied in such a case dictate this behavior.
To ensure that the security policy is enforced uniformly,
all ﬁle systems on a node must be intercepted and brought
under the control of the security system. This is achieved by
registering a callback function with the I/O manager which
is called whenever a ﬁle system is loaded. This ensures
that the ﬁlter driver can attach itself to all ﬁle systems, even
those that are loaded dynamically after booting. Dynamic
loading of ﬁle systems can, for example, occur when re-
movable media are loaded. An implication of this is that the
ﬁlter driver must be loaded prior to all ﬁle systems. This
can be achieved by assigning it either to the “Filter” driver
group or associating the necessary tag value with it in the
registry settings for the driver load sequence.
The only ﬁle system for which such a ﬁlter driver is not
notiﬁed of a load event is the Raw ﬁle system (permitting
access to the raw device without any ﬁle system interpre-
tation). In this case the ﬁlter driver must attach itself ex-
plicitly to this ﬁle system. Another exception from the noti-
ﬁcation mechanism that must be dealt with explicitly is the
LAN Manager redirector used for accessing network shares.
This, however, appears to have been an oversight by the de-
velopers of Windows NT since this behavior is no longer
observed under Microsoft Windows 2000.
Once the notiﬁcation callback is called, the ﬁlter driver
can attach to the ﬁle system or ﬁle system recognizer, re-
spectively, and is then able to intercept the ﬁle system
control requests (with the minor functions LoadFS and
MountVolume) and attach itself to mounted volumes.
Once it is attached to a mounted volume, the ﬁlter driver
can intercept all necessary I/O requests.
4.2. Considerations for modiﬁed read and write be-
havior
As a consequence of the uniﬁed virtual memory and ﬁle
system architecture in the Microsoft Windows NT operating
system family, it is not sufﬁcient to modify only the behav-
ior of read (IRP MJ READ) and write (IRP MJ WRITE)
operations. Doing so would lead to a partially encrypted
(or otherwise modiﬁed by the ﬁlter driver) cache since in
addition to simple read and write requests, memory map-
ping operations (e.g. used for mapping executable ﬁles into