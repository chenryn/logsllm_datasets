myArray[1]、myArray[2]，等等（但不匹配myArray[10])。
?
提示正如大家看到的那样，在与正则表达式打交道的时候
同样的问题几乎总是有好几种不同的解决办法。这些办法并无
优劣之分，你尽可以选择最熟悉的部种语法。
警告正则表达式的语法是区分字母大小写的。\d匹配数字，
D与\d的含义刚好相反，接下来将看到的其他类元字符也是
如此
4.3.2匹配字母和数字（与非字母和数字）
字母和数字，A到z（不分大小写）、数字0到9，再加上下划线字符（_），
是另一种比较常用的字符集合。这些字符常见于各种名字里，如（文件
---
## Page 40
30
第4章使用元字符
名、子目录名、变量名、数据库对象名等）、表4-3列出了用来匹配字母数
字和非字母数字的类元字符。
表4-3字母数字元字符
元字符
说明
\w
任何一个字母数字字符（大小写均可）或下划线字符（等价于
[a-zA-20-9_])
\W
任何一个非字母数字或非下划线字符（等价于[~a-zA-28-9_]）
下面这个例子里的原始文本是一些来自某个数据库的记录，那些记
录的内容是美国和加拿大某些城市的邮政编码”。
文本
11213
A1C2E3
48075
M184F2
48237
H1H2H2
98046
正则表达式
1w/\d/=|d)=/d
结果
11213
A1C2E3
48075
M1B4F2
48237
H1H2H2
99006
分析
在这个模式里，交替出现的\w和\d元字符将使得匹配结果里只包含
加拿大城市的邮政编码。
①美国和加拿大城市的邮政编码规则参见附录B的B.2和B.3节。—编者注
---
## Page 41
4.3匹配特定的字符类别
注意在上面这个例子里，正则表达式解决了我们的问题。
但它正确吗？请大家思考一下，为什么美国的邮政编码没有
被医配出来？是因为它们只由数字构成、还是因为什么其他
原国？
我们将不给出这个问题的答案，理由很简单，例子里的模式解
决了问题。这里的关键是正则表达式很少有对错之分（当然，前
提是它们能解决问题），我们更关心的是它们的复杂程度，而这
要由模式匹配操作的精确程度来决定：如果你需要更精确的匹
配，就需要构造更复杂的正则表达式。
4.3.3匹配空白字符（与非空白字符）
另一种常见的字符类别是空白字符。在本章前面的内容里，我们向
大家介绍了一些用来匹配某个特定的空白字符的元字符。表4-4列出了用
来匹配所有空白字符的类元字符。
表4-4空白字符元字符
元字符
1s
（[
任何一个非空白字符（等价于[\f\n\\t\v]）
元宇符\s的覆盖范围内，当然也就没有被排除在类元字符\S
的覆盖范围外。
4.3.4匹配十六进制或八进制数值
你或许不会遇到需要通过某个特定字符的十六进制值或八进制值来
匹配它的情况，但我们希望大家明白这是可以做到的。
1.使用十六进制值
在正则表达式里，十六进制（逢16进1）数值要用前缀\x来给出。比
如说，\xBA对应于ASCII字符10（换行符），其效果等价于\n。
---
## Page 42
第4章使用元字符
2.使用八进制值
在正则表达式里，八进制（逢8进1）数值要用前缓\0来给出，数值
本身可以是两位或三位数字。比如说，\011对应于ASCII字符9（制表符），
其效果等价于\t。
注意
有不少正则表达式实现还充许使用\c前组来指定各种
控制字符。比如说，\cZ将匹配Cturl-Z。不过，在实际工作中，
必须使用这种语法的情况相当少见
4.4
使用POSIX字符类
对元字符以及各种字符集合进行的讨论，必须要提到POSIX字符
类。POSIX字符类是许多（但不是所有）正则表达式实现都支持的一种
简写形式。
注意
JavaSeript不支持在正则表达式里使用POSIX字符类。
麦4-5POSIX字符类
字符类
说明
[:a1num: ]
任何个字母或数字（等价于[a-2A-28-9])
[:a1pha: ]
任何个字母（等价于[a-zA-Z])
[:blank:]
空格或制表符（等价于[\t]）
[:]
ASC1I控制字符 (ASCII 到31,再加上ASCII127)
[:digit:]
任何—个数字（等价于[0-9]）
[:ude8: ]
和[:print：]—样，但不包括空格
[:1ower:]
任何个小写字母（等价于[a-z])
[:print:]
任何一个可打印字符
[:punct:]
既不属于[：alnu=：]也不属于[：cntr1：]的任一个字符
[:space:]
任何个空白字符，包括空格（等价于[^\f\n\r\t\]²°)
[:upper: ]
任何一个大写字母（等价于[A-Z])
[:xdigit: ]
任何个十六进制数字（等价于[a-fA-Fθ-9]）
①注意，字母t后有一个空格。
译者注
②注意，字母v后有一个空格。
译者注
---
## Page 43
4.4使用POSIX字符类
POSIX语法与我们此前见过的元字符不太一样。为了演示POSIX字符
类的用法，我们来看一个前一章里的例子—利用正则表达式从一段
HTML代码里把RGB值查找出来：
文本
正则表达式
#[ [:xdigit:11[:xdigit: 111[:xdigit:111[:xdigit:11[:xdigit:11[[
→ :xdigit : 11
结果
<B00Y BGC0L0R-*#336633’TEXT-*#FFFFFE*
<,0,=NI0VWL33T 0, =NIOUVd01
分析
在前一章里使用的模式是重复写出的6个[0-9A-Fz-f]字符集合，把
那6个[0-9A-Fz-f]全部替换为[[：xdigit：]]就得到这里的模式。它们的
匹配结果完全一样。
注意这里使用的模式以[[开头、以]]结束（两对方括号）。
这是使用POSIX字符类所必须的。POSIX字符类必须括在
[：和：]之间，我们使用的POSIX字符类是[：xdigit：]（不
是：xdigit：）。外层的[和]字将用来定义一个字符集合，内层
的[和】字符是POSIX字符类本身的组成部分。
警告
一般来说，支持POSIX标准的正则表达式实现都支持表
4-5所列出的部12个POSIX字将类，但在一些细节方面可能会与
这里的描述有细微的差异。
---
## Page 44
34第4章使用元字符
4.5小结
我们在第2章和第3章对字符匹配操作和字符集合匹配操进行了讨
论。在此基础上，这一章对用来匹配特定字符（制表符、换行符等）和
用来匹配一个字符集合或字符类（数字、字母数字字符等）的元字符进
行了讲解。这些简短的元字符和POSIX字符类可以用来简化正则表达式
模式。
---
## Page 45
第5章
重复匹配
在前几章里，你们学习了如何使用各种元字符、字符集合和字符类
去匹配单个字符。在这一章里，你将学习如何匹配多个连续重复出现的
字符或字符集合。
5.1有多少个匹配
通过前面的学习，我们已经把正则表达式模式匹配操作的基础知识
全都介绍给了大家，但我们给出的每个例子都有一个非常严格的限制。
现在，请大家思考一下，如何构造一个匹配电子邮件地址的正则表达式。
电子邮件地址的基本格式应该是如下所示的样子：
textetext.text
利用前一章讨论的元字符，你可能会写出一个如下所示的正则表
达式：
m\ *\,8188)
w可以匹配所有的字母和数字字符（以及下划线字符_，这个字符在
电子邮件地址里是合法的）：@字符不需要被转义，但，字符需要。
这个正则表达式本身没有任何错误，可它几乎没有任何实际的用处
它只能匹配ab.c形式的电子邮件地址（虽然在语法方面没有任何间题，
但这显然不是一个合法的地址）。导致这一结来的关键是\w只能匹配单个
字符，而我们无法预知电子邮件地址的各个字段会有多少个字符。举个
最简单的例子，下面这些都是合法的电子邮件地址，但它们在@前面的字
符个数都不一样。
---
## Page 46
36
第5章重复匹配
beforta.com
beneforta.con
bfortaeforta.con
要想解决这类问题，我们需要一种能够匹配多个字符的办法，这可
以通过使用几种特殊的元字符来做到。
5.1.1匹配一个或多个字符
要想匹配同一个字符（或字符集合）的多次重复，只要简单地给这
个字符（或字符集合）加上一个+字符作为后缀就行了。+匹配一个或多
个字符（至少一个；不匹配零个字符的情况）。比如，a匹配a本身，a+将
匹配一个或多个连续出现的a。类似地，[0-9]匹配任意单个数字，[0-9]+
将匹配一个或多个连续的数字。
?
提示在给一个字持集合加上+后级的时候，必须把+放在这个
字符集合的外面。比如说，[0-9]+是正确的，[0-9+]则不是。
[0-9+]其实也是一个合法的正则表达式，但它匹配的不是一
个或多个数字：它定义了一个由数字0到9和+构成的字符集合，
因而只能匹配一个单个的数字字符或加号。虽然合法，可它并
不是我们需要的东西。
重新回到电子邮件地址的例子，我们这次将使用+来匹配一个或多个
字符：
文本
Send personal enail to benBforta.com. For questions
about a book use supporteforta.con. Feel free to send
nice if it were that sinple, huh7) .
unsolicited email to spaneforta.com (wouldn't it be
正则表达式
w+β]m*1 . =*
结果
Send personal email to benpforta.com. For questions
about a book use supporteforta.con. Feel free to send
---
## Page 47
5.1有多少个匹配
37
nice if it were that simple, huh7).
unsolicited email to spameforta.con (wouldn’t it be
分析
这个模式把原始文本里的3个电子邮件地址全都正确地匹配出来了。
这个正则表达式先用第一个\w+匹配一个或多个字母数字字符，再用第二
个w+匹配后面的一个或多个字符，然后匹配一个.字符（使用转义序列
\.），最后用第三个\w+匹配电子邮件地址的剩余部分。
提示+是一个元字符。如果需要匹配+本身，就必须使用它的
特义序列\+
+还可以用来匹配一个或多个字符集合。为了演示这种用法，我们在
下面这个例子里使用了和刚才一样的正则表达式，但原始文本和上一个
例子稍有不同：
文本
Send personal enail to beneforta.com or
book use supporteforta.com. If your message
ben.fortaeforta.com. For questions about a
is urgent try beneurgent forta.con. Fee1
free to send unsolicited enail to
spameforta.com (wouldn’t it be nice if
it were that sisple, huh?) .
正则表达式
[w+e)+\ . \+
结果
Send personal enail to beneforta.com or
book use supporteforta.com.If your message
ben.fortaeforta.com. For questions about a