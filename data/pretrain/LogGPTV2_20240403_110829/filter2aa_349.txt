王大宝, PK
虚拟机 - 恶意程式攻防的新战场
 讲师简介
王大宝, 小时候大家叫他王小宝,长大后就称王大宝,目前隶
属一神秘单位. 虽然佯称兴趣在看书与听音乐, 但是其实晚
上都在打Game. 长期于系统最底层打滚,熟悉ASM,C/C++,
对于资安毫无任何兴趣,也无经验,纯粹是被某坏人骗上台, 
可以说是不可多得的素人讲师!! 
 议程大纲：
现今的 CPU 都支援虚拟化专用指令集, 让 VM 获得硬体的
支援. 在这个场次中,我们将详细地介绍 Intel 的 VT指令集
与其 Hypervisor 运作的机制. 此外我们将并介绍在恶意软
体研究领域中在 Hypervisor 模式下能有哪些应用,包含恶意
程式技术与侦防分析的应用. 最后我们将介绍自行开发能在
Hypervisor 模式下运作的 Malware POC, 而且是无法被目
前防毒与防护系统侦测到! 
Agenda
 VMM on x86
 Hardware assisted architecture
 VMM software implementing
 Security & VMM
What is VMM
 Has full control over the platform
 A thin layer between the physical 
hardware and virtualized environment
 Be able to retain selective control from 
guest software
 The real world
现实是残酷的, 从VM中醒过来不一定是好事 … :P
What is VMM (conti.)
Guest OS 1
Guest OS 2
VMM
Physical Processor
Types of Hypervisors
Intel® VT-x
 Introduced by Intel®
 Includes a new set of instructions
 Totally isolated environments for each guest
 Solved many problems which were caused by guest 
OS executing at the same level of host OS
 Provides better performance than byte code 
emulation
Keywords
 VMM runs at VMX root operation
 Guest software runs at VMX non-root 
operation
 Transition from VMM to guest software is 
called VM entry
 Transition from guest software to VMM is 
called VM exit
VMX root operation
 Check CPU capabilities
mov
eax, 1
cpuid
test
ecx, 20h
VMX – Virtual Machine Extensions
5
VMX root operation (conti.)
 Prepare a non-pageable memory 
(VMXON Region)
 storage of host context
 aligned to 4KB
 in MTRR range – Write Back (type 6)
 size = MSR#480 [43:32]
 rev_id = MSR#480 [31:0]
31
0
rev_id
43
VMXON Region Size
32
VMX root operation (conti.)
 Enable VMXE bit (bit13) in CR4
mov
eax, cr4
or
eax, Bit13
mov
cr4, eax
13
VMXE – Virtual Machine Extensions Enabled
VMX root 
operation (conti.)
 VMXON instruction
vmxon phymem_vmxon_region
 Hello, real world…
VMX non-root operation
 Prepare a non-pageable memory (VMCS)
 storage of guest software states
 aligned to 4KB
 in MTRR range – Write Back (type 6)
 size = MSR#480 [43:32]
 rev_id = MSR#480 [31:0]
VMX non-root operation 
(conti.)
 Instructions to initialize VMCS
 VMCLEAR, VMPTRLD
 VMCLEAR
 Initialize the new VMCS region in memory
 Set the launch state to “clear”
 Invalidates the working VMCS pointer register
 VMPTRLD
 Initializes the working VMCS pointer with the new 
VMCS region's physical address.
 Validates the working VMCS pointer register
VMX non-root operation 
(conti.)
 Instructions to access specific field of 
VMCS
 VMWRITE, VMREAD
 Each field has its encoding
 Example:
○ GUEST_RIP = 681eh
○ To set GUEST_RIP into VMCS:
mov
eax, 681eh
vmwrite
eax, dword ptr NEW_GUEST_RIP
○ To get GUEST_RIP from VMCS:
mov
eax, 681eh
vmread
ebx, eax
VMX non-root operation 
(conti.)
 Now it is time to run guest software
 VMLAUNCH, VMRESUME
 Launch state of VMCS will be set to 
“launched”
VMM, VMCS, Guest OS
CPU#A
CPU#B
VMXON Region #A
VMCS #1A
VMCS #2A
VMXON Region #B
VMCS #1B
VMCS #2B
Guest OS 1
Guest OS 2
VM exit handling
 VMM gets VM exit reason from VMCS, 
determines handle it or not
Bit Position(s)
Contents
15:0
Basic exit reason
27:16
Reserved (cleared to 0)
28
Pending MTF VM exit
29
VM exit from VMX root operation
30
Reserved (cleared to 0)
31
VM-entry failure (0 = true VM exit; 1 = VM-entry failure)
VM exit handling (conti.)
 VM exit basic reasons
 > 50
 Sensitive instructions
 Privilege registers change
 Exceptions
 …
 Exit qualification contains additional 
information
 Execute VMRESUME after handled VM exit
Lifecycle of a VMM software
VMXON
VMM
Guest
VMXOFF
VMM Lives
VM Entry
VM Exit
System VMs
IA-32
Operation
VT-x Operations 
Ring 0
Ring 3
VMX Root
Operation
VMX 
Non-root
Operation
. . .
Ring 0
Ring 3
VM 1
Ring 0
Ring 3
VM 2
Ring 0
Ring 3
VM n
VMXON
VMLAUNCH
VMRESUME
VM Exit
VMCS
2
VMCS
n
VMCS
1
Security & VMM
 VMM is transparent to its guests
 A well-implemented VMM is very hard to be 
detected
 Almost all VMM-detection technologies in 
present are based on flaws of VMM itself
 A positive usage of VMM could be a very 
powerful weapon against various attacks of 
malwares
 So could be in either way…
 But…
Security & VMM (conti.)
 Difficulties in implementing VMM
 No OS API
 No existed input/output
 No existed drivers
 Developers implement everything in VMM
○ Disk read/write
○ Keyboard input/output
○ Control video RAM for output
○ Direct manipulation on NIC, USB stack
VMX vs. SMM
 In a software developer’s aspect, VMX 
operation is very similar to SMM
 Transparent to client
 Has processor context storage
 Full control over system
 Isolated environment, DIY everything
 Differences
 SMM is triggered by hardware
 SMM has higher priority than VMX
 SMM is not accessible at runtime
Malware and VMM
 How to detect or analysis Kernel Malware ??
User mode 
Malware
Kernel mode 
Malware
Kernel Behavior 
Monitor
???
Demo 1: Invisible VMM Keylogger
 A handcrafted key logger in VMM
 Capture KB input from I/O port
 Hidden File in Guest OS File system !
 Definitely invisible…Ya 
○ Cant be detected by any Anti-Virus or HIPS in 
the world
File System Implemented in VMM
hitkey2010 has been saved to disk
VMM Keylogger
Demo2: Rootkit Detection
 Physical Memory Forensics with VMM !!
 EPROCESS parsing
 SSDT parsing
 Etc.
 Demo our new toy
VMM on Forensic Approach
Found a process that hidden by Fu rootkit
Q&A
Reference
 Intel ®64 and IA-32 Architectures Software 
Developer's Manual Vol.2, Vol.3
 http://code.google.com/p/hyperdbg/
 http://virtualizationtechnologyvt.blogspot.com/
 http://www.ibm.com/developerworks/cn/linux/l-
cn-vt/index.html
 http://www.invisiblethingslab.com/