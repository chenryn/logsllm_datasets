V
V
/=
，下面是在REPL中输入一个含有内嵌引号的字符串时所看到的
www.TopSage.com
表10-1字符比较函数
foo\bar
表10-2字面字符串
foobar
"foobar"
foo”bar
foobar
大小写相关
CHAR>=
CHAR
CHAR=
STRING
STRING=
?
10.9字符串比较
 STRING-NOT-LESSP
STRING-NOT-GREATERP
STRING-GREATERP
STRING-LESSP
STRING-NOT-EQUAL
STRING-EQUAL
大小写无关
109
---
## Page 127
串的访问函数CHAR。这些以及其他一些函数都是下一章的主题，让我们继续吧。
使用通用序列元素访问函数ELT或者使用通用数组元素访问函数AREF。你还可以使用特定于字符
于字符串。例如，你可以用LENGTH函数来检查字符串的长度并获取和设定字符串中的个别字符,
且如同我前面提到的，由于字符串实际上是一种序列，我将在下一章讨论的所有序列函数都可用
110
 其他字符串函数允许你转化字符串的大小写以及从一个字符串的一端或两端修剪字符。而
第 10章数字、字符和字符串
www.TopSage.com
---
## Page 128
个新分配的含有那些参数的定长向量。
量随着元素的增加和移除而增大和减小。
Perl或Ruby中的数组、Python中的列表以及Java中的ArrayList类：它们抽象了实际存储，允许向
组非常相似：一-块数据头以及一段保存向量元素的连续内存区域。?另一方面，变长向量更像是
11.1向量
的子类型(即序列)。因此，你可以将本章我所讨论的许多函数同时用在向量和列表上。
哈希表。?尽管如此，向量和列表共享了许多特征，因此Common Lisp将它们都视为更一般抽象
许多场合其他数据结构更合适。
于集中在列表上是错误的。尽管它是一种将Lisp代码作为Lisp数据来表达的关键数据结构，但在
列表是如此灵活的数据结构，它可用于许多其他语言使用数组和哈希表的场合。但是将注意力过
此，这一观点通常导致读者错误地推论出列表是Lisp的唯一集合类型。更糟糕的是，因为Lisp的
(ontogeny-recapitulates-phylogeny）原则的Lisp教材也都从讨论基于列表的Lisp集合开始。尽管如
array）、映射表（map）和字典（dictionary)。
为数组（array)、列表（list）或元组（tuple)，后者命名为哈希表（hash table）、关联数组（associative
为了避免让列表过于出风头，在本章里我将集中在Common Lisp的其他集合类型上：向量和
② 向量被称为向量，而不是像其他语言里那样被称为数组，是因为Common Lisp支持真正的多维数组。将它称为一
①一旦你熟悉了CommonLisp提供的所有数据类型，会发现列表可以作为原型数据结构来使用，并且以后可以替换
你可以用函数VECTOR来生成含有特定值的定长向量，该函数接受任意数量的参数并返回一
向量是Common Lisp基本的整数索引集合，它们分为两大类。定长向量与Java等语言里的数
当然，Lisp以其列表数据结构闻名于世，而多数遵循了语言用法的进化重演
维数组应该更加确切，但过于冗繁。
成其他更高效的东西，只要你清楚了使用数据的确切方式。
集
www.TopSage.com
合
---
## Page 129
VECTOR-POP返回最近推入的项，并在该过程中递减填充指针。
前值上添加一个元素并将填充指针递增一次，并返回新元素被添加位置的索引。函数
下面的MAKE-ARRAY调用生成了一个带有五元素空间的向量，它看起来是空的，因为填充指针是
填充位置的索引。
量。这个数字存放在向量的填充指针里，这样称呼是因为它是当为向量添加一个元素时下一个被
跟踪其用来保存元素的内存和可访问的槽位数量,变长向量还要跟踪实际存储在向量中的元素数
你可以写成下面这样：
可以传递一个:initial-element参数。因此，为了生成一个元素初始化到NIL的五元素向量，
向量，它们必须在被访问之前设置其值。
来代替只含有一项的列表。如果没有其他参数，MAKE-ARRAY就将创建一个带有未初始化元素的
表将含有一个数字，也就是向量的大小。出于方便的考量，MAKE-ARRAY也会用一个简单的数字
量。MAKE-ARRAY的一个必要参数是一个含有数组维数的列表。由于向量是一维数组，所以该列
修改的向量。
字面对象的后果并不明确，因此应当总是使用VECTOR或更为通用的函数MARE-ARRAY来创建打算
并用READ读取，以此来保存并恢复向量。可以使用#（.．.)语法在代码中添加字面向量，但修改
为了创建带有填充指针的向量,你可以向MAKE-ARRAY传递一个:fill-pointer实参。例如,
112
① 数组元素在其被访问前“必须”被赋值，如果不这样做，其行为将是未定义的。Lisp不一定会报错。
MAKE-ARRAY也是用来创建变长向量的函数。变长向量是比定长向量稍微复杂的向量。除了
MAKE-ARRAY比VECTOR更加通用，因为它可以用来创建任何维度的数组以及定长和变长向
(defparameter *x* (make-array 5 :fill-pointer 0))
(make-array 5 :initial-element nil) → #(NIL NIL NIL NIL NIL)
语法#（．..)是Lisp打印器和读取器使用的向量的字面表示形式，该语法可使你用PRINT打印
(vector-pop *x*)
(vector-push 'c
(vector-push 'b *x*) 
0←(*x ，usnd-oDa)
(make-array 5 :fill-pointer 0) → #{)
x*
￥X
(vector 1 2) → #(1 2)
vector 1)
(vector)
第11章集合
→#()
*x*）
↑
个
#(A)
#(A B)
C
#(A B C)
2
#(AB)
#(A)
www.TopSage.com
。“为了创建所有元素都设置到一个特定值上的向量，你
---
## Page 130
描述符是符号BIT。
如将两个位数组“与”在一起（不会介绍）。用来创建一个位向量传递给：element-type的类型
语法，看起来像#*00001111，另外还有一个相对巨大的函数库。这些函数可用于按位操作，例
字符串，如下所示：，
串。注意，你需要引用该符号以避免它被视为一个变量名。例如，创建一个初始为空但却变长的
来创建变长字符串。该参数接受一个类型描述符。我将不会介绍你可以在这里使用的所有可能的
并且根本不能修改它们。但你可以用MAKE-ARRAY通过添加另一个关键字参数：element-type
次数，等等。
为字符串函数库带来新的功能，例如用一个子串来搜索字符串，查找一个字符在字符串中出现的
们也是向量，所有接下来几节里所讨论的接受向量实参的函数也可以用在字符串上。这些函数将
至于它们有自己的读写语法（双引号）和一组特定于字符串的函数，前一章已讨论过。但因为它
本身就是重要的数据类型。
并且可以比通用向量提供对其元素更快速的访问。不过目前我们将集中介绍几类特化向量，它们
向量使其仅限于保存特定类型的元素。使用特化向量的理由之一是，它们可以更加紧凑地存储，
11.2
向一个已满的向量（其填充指针等于底层存储的大小）中推入元素时，它能自动扩展该数组。
添加元素，你可以使用VECTOR-PUSH-EXTEND，它就像VECTOR-PUSH那样工作，只是在你试图
数：adjustable。
素。为了创建一个可任意变长的向量，你需要向MAKE-ARRAY传递另外一个关键字参
其中一类你已经见过了，就是字符串，它是特定用来保存字符的向量。字符串特别重要，以
①尽管经常一起使用，但：file-pointer和：adjustable是无关的—
诸如“foo”这样的字面字符串，和那些用#（）语法写成的字面向量一样，其大小都是固定的，
位向量是元素全部由0或1所组成的向量，它也得到一些特殊对待。它们有一个特别的读/写
目前为止，你处理的所有向量都是可以保存任意类型对象的通用向量。你也可以创建特化的
(make-array5:fill-pointer 0:adjustablet:element-type'character)→""
这个调用生成了一个可调整的向量，其底层内存可以按需调整大小。为了向一个可调整向量
(make-array5:fill-pointer0:adjustablet)→#()
尽管如此，甚至一个带有填充指针的向量也不是完全变长的。向量*x*只能保存最多五个元
数组。不过，你只能在带有填充指针的向量上使用VECTOR-PUSH和VECTOR-POP，并只能在带有填充指针且可
*x*
(vector-pop *x*)
来修改可调整数组。
调整的向量上使用VECTOR-PUSH-EXTEND。你还可以使用函数ADJUST-ARRAY以超出扩展向量长度的多种方式
向量的子类型
→#（）
→
www.TopSage.com
一你可以生成一个不带有填充指针的可调整
---