**例 12-1 资金从一个账户到另一个账户的非幂等转移**
```sql
BEGIN TRANSACTION;
    UPDATE accounts SET balance = balance + 11.00 WHERE account_id = 1234;
    UPDATE accounts SET balance = balance - 11.00 WHERE account_id = 4321;
COMMIT;
```
客户端可以重连到资料库并重试事务，但现在已经处于 TCP 重复抑制的范围之外了。因为 [例 12-1]() 中的事务不是幂等的，可能会发生转了 \$22 而不是期望的 \$11。因此，尽管 [例 12-1]() 是一个事务原子性的标准样例，但它实际上并不正确，而真正的银行并不会这样办事【3】。
两阶段提交（请参阅 “[原子提交与两阶段提交](ch9.md#原子提交与两阶段提交)”）协议会破坏 TCP 连线与事务之间的 1:1 对映，因为它们必须在故障后允许事务协调器重连到资料库，告诉资料库将存疑事务提交还是中止。这足以确保事务只被恰好执行一次吗？不幸的是，并不能。
即使我们可以抑制资料库客户端与伺服器之间的重复事务，我们仍然需要担心终端使用者装置与应用伺服器之间的网路。例如，如果终端使用者的客户端是 Web 浏览器，则它可能会使用 HTTP POST 请求向伺服器提交指令。也许使用者正处于一个讯号微弱的蜂窝资料网路连线中，它们成功地传送了 POST，但却在能够从伺服器接收响应之前没了讯号。
在这种情况下，可能会向用户显示错误讯息，而他们可能会手动重试。Web 浏览器警告说，“你确定要再次提交这个表单吗？”  —— 使用者选 “是”，因为他们希望操作发生（Post/Redirect/Get 模式【54】可以避免在正常操作中出现此警告讯息，但 POST 请求超时就没办法了）。从 Web 伺服器的角度来看，重试是一个独立的请求；从资料库的角度来看，这是一个独立的事务。通常的除重机制无济于事。
#### 操作识别符号
要在通过几跳的网路通讯上使操作具有幂等性，仅仅依赖资料库提供的事务机制是不够的 —— 你需要考虑 **端到端（end-to-end）** 的请求流。
例如，你可以为操作生成一个唯一的识别符号（例如 UUID），并将其作为隐藏表单栏位包含在客户端应用中，或透过计算所有表单相关栏位的杂凑来生成操作 ID 【3】。如果 Web 浏览器提交了两次 POST 请求，这两个请求将具有相同的操作 ID。然后，你可以将该操作 ID 一路传递到资料库，并检查你是否曾经使用给定的 ID 执行过一个操作，如 [例 12-2]() 中所示。
**例 12-2 使用唯一 ID 来抑制重复请求**
```sql
ALTER TABLE requests ADD UNIQUE (request_id);
BEGIN TRANSACTION;
    INSERT INTO requests
        (request_id, from_account, to_account, amount)
        VALUES('0286FDB8-D7E1-423F-B40B-792B3608036C', 4321, 1234, 11.00);
    UPDATE accounts SET balance = balance + 11.00 WHERE account_id = 1234;
    UPDATE accounts SET balance = balance - 11.00 WHERE account_id = 4321;
COMMIT;
```
[例 12-2]() 依赖于 `request_id` 列上的唯一约束。如果一个事务尝试插入一个已经存在的 ID，那么 `INSERT` 失败，事务被中止，使其无法生效两次。即使在较弱的隔离级别下，关系资料库也能正确地维护唯一性约束（而在 “[写入偏差与幻读](ch7.md#写入偏差与幻读)” 中讨论过，应用级别的 **检查 - 然后 - 插入** 可能会在不可序列化的隔离下失败）。
除了抑制重复的请求之外，[例 12-2]() 中的请求表表现得就像一种事件日志，暗示著事件溯源的想法（请参阅 “[事件溯源](ch11.md#事件溯源)”）。更新账户余额事实上不必与插入事件发生在同一个事务中，因为它们是冗余的，而能由下游消费者从请求事件中衍生出来 —— 只要该事件被恰好处理一次，这又一次可以使用请求 ID 来强制执行。
#### 端到端原则
抑制重复事务的这种情况只是一个更普遍的原则的一个例子，这个原则被称为 **端到端原则（end-to-end argument）**，它在 1984 年由 Saltzer、Reed 和 Clark 阐述【55】：
> 只有在通讯系统两端应用的知识与帮助下，所讨论的功能才能完全地正确地实现。因而将这种被质疑的功能作为通讯系统本身的功能是不可能的（有时，通讯系统可以提供这种功能的不完备版本，可能有助于提高效能）。
>
在我们的例子中 **所讨论的功能** 是重复抑制。我们看到 TCP 在 TCP 连线层次抑制了重复的资料包，一些流处理器在讯息处理层次提供了所谓的恰好一次语义，但这些都无法阻止当一个请求超时时，使用者亲自提交重复的请求。TCP，资料库事务，以及流处理器本身并不能完全排除这些重复。解决这个问题需要一个端到端的解决方案：从终端使用者的客户端一路传递到资料库的事务识别符号。
端到端原则也适用于检查资料的完整性：乙太网，TCP 和 TLS 中内建的校验和可以检测网路中资料包的损坏情况，但是它们无法检测到由连线两端传送 / 接收软体中 Bug 导致的损坏。或资料储存所在磁碟上的损坏。如果你想捕获资料所有可能的损坏来源，你也需要端到端的校验和。
类似的原则也适用于加密【55】：家庭 WiFi 网路上的密码可以防止人们窃听你的 WiFi 流量，但无法阻止网际网路上其他地方攻击者的窥探；客户端与伺服器之间的 TLS/SSL 可以阻挡网路攻击者，但无法阻止恶意伺服器。只有端到端的加密和认证可以防止所有这些事情。
尽管低层级的功能（TCP 重复抑制、乙太网校验和、WiFi 加密）无法单独提供所需的端到端功能，但它们仍然很有用，因为它们能降低较高层级出现问题的可能性。例如，如果我们没有 TCP 来将资料包排成正确的顺序，那么 HTTP 请求通常就会被搅烂。我们只需要记住，低级别的可靠性功能本身并不足以确保端到端的正确性。
#### 在资料系统中应用端到端思考