how dynamic traces are collected.
Function Hooking. Function hooking is a family of techniques that allows one
to intercept function calls to inspect the parameters or alter the behavior of the
program. In this section, we present two features of JavaScript that we use to
hook functions: function redeﬁnition and set functions.
Function redeﬁnition is a technique for overwriting JavaScript functions and
object methods. Consider the example in Listing 1.2, which shows the use of
function redeﬁnition that logs any call to the function alert. This is achieved
ﬁrst by associating a new name to the function alert (Line 2), and then by
redeﬁning the alert function (Line 3). The redeﬁnition still behaves as the
original alert, however, it adds (i.e., hooks) a call to log its use.
While function redeﬁnition can be used to hook arbitrary functions to func-
tion calls, it cannot be used when functions are set as an object property, i.e.,
obj.prop=function(){[...]}. To hook functions in these cases, we use so-
called set functions, which are bound to object properties that are called when-
ever the property is changed. For example, one can hook the function myHook to
the property propr of the object obj as follows:
j¨Ak: Using Dynamic Analysis to Crawl and Test Modern Web Applications
301
Listing 1.2. Function hooking via function redeﬁnition
1
2
3
4
5
6
7
alert ( " Hello world ! " ) ; // show a popup window
var o r i g _ a l e r t = alert;
f u n c t i o n alert ( s ) {
c o n s o l e . l o g ( " call to alert " + s ) ; // hook
return o r i g _ a l e r t ( s ) ;
}
alert ( " Hello world ! " ) ; // message is also shown in the console
Object.defineProperty(obj,"prop",{set:myHook}).
Event Handlers Registration. We now show the use of function hooking
to capture the registration of event handlers in three of the four registration
models: addEventListener function, event handler property, and timing events.
For the fourth registration model, i.e., event handler attribute, we do not use
function hooking. As in this model handlers are registered as HTML attribute,
we captured them by visiting the HTML DOM tree.
Hooking addEventListener — To capture the registration of a new handler,
j¨Ak injects its own function whenever the addEventListener function is called.
Listing 1.3 shows an example for the hooking code. The function installHook
installs a hook function hook before the execution of a function f of object obj.
installHook ﬁrst preserves a reference to the original function (Line 2). Then,
j¨Ak replaces the original function with its own anonymous function (Line 3
to Line 6). The anonymous function ﬁrst calls the hook (Line 4) and then the
original function (Line 5). Here, the parameters of hook are this and arguments.
Both parameters are JavaScript keywords. The ﬁrst one is a reference to the
object instance whereas the latter is a list containing the parameters that will
be passed to the function f. Finally, j¨Ak can use the installHook function to
install its hook handler myHook for every call to the function addEventListener
of any HTML tag element, as shown below:
1
i n s t a l l H o o k ( E l e m e n t . p r o t o t y p e , " a d d E v e n t L i s t e n e r " , myHook )
Here Element.prototype is a special object that deﬁnes the basic behaviors of
all DOM nodes.
Hooking Event Handler Properties — To capture the registration of event han-
dlers via event properties, one can install a hook function as a set function in the
Listing 1.3. Function Hooking for the addEventListener function
1
2
3
4
5
6
7
f u n c t i o n i n s t a l l H o o k ( obj , f , hook ) {
var orig = obj [ f ];
obj [ f ] = f u n c t i o n () {
hook ( this , a r g u m e n t s ) ;
return o r i g . a p p l y ( this , a r g u m e n t s ) ;
}
}
302
G. Pellegrino et al.
DOM elements. However, this approach requires further care. First, the registra-
tion of a set function may be overwritten by other set functions installed by the
JavaScript program. As opposed to function redeﬁnition, set functions do not
guarantee that the hook will remain for the entire duration of the analysis. This
can be solved by ﬁrst redeﬁning the defineProperty function and then moni-
toring its use. Then, if the hook detects a set-function registration, it will create
a new set function which chains j¨Ak’s set function with the one provided by the
program. Second, we observed that the registration of set functions for event
properties may prevent the JavaScript engine from ﬁring events. This can inter-
fere with the operations of a JavaScript program, e.g., it can break the execution
of self-submitting forms1. While j¨Ak’s set function will still detect event handler
registrations, after the discovery, the JavaScript engine needs to be reinitialized.
Finally, as opposed to function redeﬁnitions, this technique may not work in
every JavaScript engine. To install set functions, the JavaScript engine needs to
mark the property as conﬁgurable. Unfortunately, this is an engine-dependent
feature. For example, the JavaScript engines of Google and Mozilla, i.e., V8 and
SpiderMonkey, support this feature whereas the JavaScript engine of Apple does
not allow it. When function hooking on event properties is not allowed, one can
instead inspect the DOM tree to detect changes in the event properties.
Hooking Timing Event Handlers — To capture the registration of timing event
handlers, it is possible to reuse the installHook function of Listing 1.3 as follows:
1
2
i n s t a l l H o o k ( window , " s e t T i m e o u t " , myHook )
i n s t a l l H o o k ( window , " s e t I n t e r v a l " , myHook )
where myHook is the hook function.
Network Communication APIs. Next, we describe the use of function hook-
ing to dynamically inspect the use of networking communication APIs. We will
illustrate an example hooking the XMLHttpRequest API, but the general app-
roach can easily be extended to further communication APIs.
As shown in Sect. 2.2, the XHR API is used in three steps. First, an XHR
object is instantiated. Then, the HTTP request method and the URL of the
server side is passed to the XHR object via the open function. Finally, the HTTP
request is sent with the function send. j¨Ak can use installHook to inject its
hook handler myHook for both open and send as follows:
1
2
i n s t a l l H o o k ( X M L H t t p R e q u e s t , " open " , myHook ) ;
i n s t a l l H o o k ( X M L H t t p R e q u e s t , " send " , myHook ) ;
Other network communication APIs may require the URL of the endpoint
as a parameter to the constructor. For example, WebSocket accepts the URL
only in the constructor function as follows: var ws = new WebSocket(server).
In general, when one would like to hook a function in the constructor, Line 5
of installHook in Listing 1.3 needs to be modiﬁed to return an instance of the
object, i.e., return new orig(arguments[0], ...).
1 A self-submitting form is an HTML form that is submitted by ﬁring submit or mouse
click events within the JavaScript program.
j¨Ak: Using Dynamic Analysis to Crawl and Test Modern Web Applications
303
Run-Time DOM Analysis. The DOM tree is a collection of objects each
representing an element of the HTML document. The DOM tree can be visited
to inspect its current state. Each visit can be scheduled via JavaScript events or
it can be executed on-demand. In this paper, we consider three uses of run-time
DOM analysis. First, it is used to extract the registration of handlers as HTML
attributes. Second, it is used to identify changes in the tree while ﬁring events.
Third, it can be used to discover the registration of event handlers when the
JavaScript engine does not allow to hook code as set functions.
Collection of Dynamic Traces. After describing how to install j¨Ak’s hook
functions, we now turn to the actual behavior of the these functions. In general,
j¨Ak uses hook functions to collect information from the run-time environment
at the point of their invocation. This information is then sent to the crawler,
which collects them in an execution trace.
For the event handler registration, the hook function depends on the type of
event (see, e.g., Listing 1.4). For example, for DOM events, the hook function
collects the name of the event, the position in the DOM tree of the source and
sends it to the crawler. Instead, for timing events, the hook can collect the
timeout set by the caller. In either case, hook functions send trace entries to the
crawler via a JavaScript object trace, which is mapped to a queue object in the
crawler’s memory. This object acts as a bridge between the JavaScript execution
environment and the crawler’s execution environment.
Listing 1.4. Hook Function for the addEventListener and setTimeout
f u n c t i o n a d d E v e n t L i s t e n e r H o o k ( elem , args ) {
path = getPath ( elem ) ;
entry = {
" e v t _ t y p e "
" e v t _ s o u r c e " : path
: args [0] , // 1 st par of a d d E v e n t L i s t e n e r
};
t r a c e . p u s h ( entry ) ;
}
f u n c t i o n t i m e o u t H o o k ( elem , args ) {
entry = {
" e v t _ t y p e "
" time "
: " t i m e o u t " ,
: args [1] // 1 st par of s e t T i m e o u t
};
t r a c e . p u s h ( entry ) ;
}
1
2
3
4
5
6
7
8
1
2
3
4
5
6
7
When collecting trace entries for network communication APIs, one has to
address two issues. First, the APIs typically require multiple steps to set up a
communication channel and to deliver messages to the server side. For example,
the XHR API requires at least three steps (Lines 3–8 in Listing 1.1). These
steps are not necessarily atomic. In fact, a program may open a pool of XHR
connections, and ﬁnally call the send function of each object. In this case, a
single hook will result in a trace which contains uncorrelated trace events: at
the beginning a sequence of “open” events with the URL endpoints, and then a
sequence of only “send” events with the body being sent.
304
G. Pellegrino et al.
For these reasons, j¨Ak deﬁnes a hook for each of the API functions and then
uses the API object to store the current state of the API calls. For example,
Listing 1.5 shows the hook function for the API functions open and send. The
hook function xhrOpenHook creates two new object properties in the object xhr
for the HTTP request method and the URL, respectively. Then, the function
xhrSendHook collects the content of the two object properties and the body of
the HTTP requests, and the sends them to the crawler. Such hooks are thread-
safe, and thus even work correctly when JavaScript programs access the network
communication API concurrently (e.g., within Web Workers [4]).
3.2 Crawling
In the previous section, we presented the dynamic analysis technique in isolation.
In this section, we will integrate the dynamic analysis into our web crawler j¨Ak.
The crawler is model-based, i.e., it creates and maintains a model of the web
application which is used at each step to decide the next part to explore. First,
we describe how we create the model. Then, we discuss the selection criteria for
the next action, and ﬁnally the termination conditions.
Navigation Graph. j¨Ak creates and maintains a navigation graph of the web
application which models both the transitions within a client-side program and
the transitions between web pages. The model is a directed graph similar to
the one shown in Fig. 1, in which nodes are clusters of pages and edges can be
events and URLs. Each page p is modeled as a tuple of three elements p =
(cid:2)u, E, L, F(cid:3) where u the web page URL, E is the JavaScript events, L a set of
URLs (e.g., linked URLs, server-side endpoints), and F a set of HTML forms.
j¨Ak normalizes all URLs by striping out query string values and sorting the query
string parameter lexicographically. Two pages p(cid:3) and p(cid:3)(cid:3) are in the same cluster
if (i) u(cid:3) and u(cid:3)(cid:3) are identical and (ii) the two pages are suﬃciently similar. The
similarity is calculated as a proportion between the number of common events,
URLs and forms over the total number of events, URLs and forms. Precisely,
the similarity is deﬁned as follow:
Listing 1.5. Hook Functions for XHR API
f u n c t i o n x h r O p e n H o o k ( xhr , args ) {
x h r . m e t h o d = args [0]; // 1 st par of H T M L H t t p R e q u e s t . o p e n , i.e. , HTTP
method
x h r . u r l = args [1];
// 2 nd par , i.e. , the URL
}
f u n c t i o n x h r S e n d H o o k ( xhr , args ) {
entry = {
" e v t _ t y p e "
: " xhr " ,
" url "
" method "
" body "
: xhr.url ,
: xhr.method ,
: args [0] // 1 st par of X M L H t t p R e q u e s t . s e n d
};
t r a c e . p u s h ( entry ) ;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
j¨Ak: Using Dynamic Analysis to Crawl and Test Modern Web Applications
305
s(p(cid:3), p(cid:3)(cid:3)
) =
|E(cid:3) ∩ E(cid:3)(cid:3)| + |L(cid:3) ∩ L(cid:3)(cid:3)| + |F (cid:3) ∩ F (cid:3)(cid:3)|
|E(cid:3) ∪ E(cid:3)(cid:3)| + |L(cid:3) ∪ L(cid:3)(cid:3)| + |F (cid:3) ∪ F (cid:3)(cid:3)|
Through experimental analysis we determined that a similarity threshold of
0.8 generates the best results for our setting.
Navigating. The dynamic analysis of the JavaScript program generates a run-
time trace containing event handler registrations and dynamically-generated
URLs. It also includes the result of the DOM-tree analysis such as linked URLs
and forms. This information is then sorted into two lists, a list of events and a