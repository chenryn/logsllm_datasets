else
end for
end if
Xi = M askedSubBytesO(i)+r(Xi)
if r = 0 then
for i ∈ Sf 0[0, 15] do
end for
for i ∈ [0, 15] do
1: On-the-ﬂy key expansion RoundKeyr, r ∈ [0, 10],
2: RoundKey0 ← RoundKey0 ⊕ M ask0
3: X = X ⊕ RoundKey0
4: for each r ∈ [0, 8] do
5:
6:
7:
8:
9:
10:
11:
12:
13:
14: X = SR(X)
15: X = M C(X)
16: X = X ⊕ RoundKeyr+1
17: M CPr = M C(SR(M askr+1)) ⊕ M askr+1
18: X = X ⊕ M CPr;
19: end for
20: for i ∈ Sf 10[0, 15] do
21: Xi = M askedSubBytesO(i)+9(Xi)
22: end for
23: X = SR(X)
24: X = X ⊕ RoundKey10
25: M CP9 = SR(M ask10)
26: X = X ⊕ M CP9;
/* AddRoundKey of the next round */
/* Last round */
of pattern or sequence which is composed by a series of
relevant leakages in one power trace and can be exploited
to conduct sensitive information identiﬁcation. A major
feature of this ﬁngerprint is that the leakage in each time
instant is inadequate for the secret recovery, but when the
information accumulates in a number of instants in time,
the identiﬁcation of the source of the leakage gets clear and
accurate.
In order to generalize the process of utilizing leakage ﬁn-
gerprint, we deﬁne in one single power trace the exploitable
intermediate values which lead to the corresponding leakages
as fj(Xj, Sj), j ∈ [0, n − 1], where j represents the jth
leakage position and Xj ∈ {x1, ..., xp}, Sj ∈ {s1, ..., sq} de-
note the jth known variable and secret variable respectively.
Consequently, we get a leakage sequence of length n with the
form of:
Tf p = L◦Seq{fj(Xj, Sj)|j ∈ [0, n−1]}+Seq{εj|j ∈ [0, n−1]}
where L : Z → R describes the real leakage function of the
targeted cryptographic device and maps each intermediate
value in the set of Seq separately, and εj is modelled as n
independent random noises. For an exploitable sequence, Sj
should follow the form of Sj = gj−1(Sj−1), j ∈ [1, n − 1],
where gj−1 refers to a public relation between the usage
of successive secret variables. And we call such sequence
the ﬁngerprint of S0, denoted as Tf p(S0), since S0 uniquely
determines all the values in Tf p except the noise interference,
and conversely the identiﬁcation of the variable S0 strongly
depends on this leakage sequence.
Now, we consider the exploitation of the ﬁngerprint from
an attacker’s perspective. When obtaining one power trace
with the public value Xj known, the attacker is capable
of guessing q possible sequences of W ◦ Seq{fj(Xj, Sj)|j ∈
[0, n − 1]} by selecting all the possible alternatives from the
value domain of S0, where W is a prediction leakage model
guessed by the attacker as an approximation of L. More
precisely, choosing si as a candidate for S0, the guessing
sequence can be denoted as:
Gf p(si) = W◦Seq{f0(X0, si), f1(X1, g0(si)), ..., fn(Xn, gn(si))}
where gn refers to n compound operations of the mapping
gj. Thus, the identiﬁcation of S0 can be formalized as
shown below, where DIST is a distinguisher to judge
the similarities between T and G, and should be chosen
according to diﬀerent attack scenarios:
S0 = argmin
si
{DIST (Tf p(S0), Gf p(si))}
(1)
Note that, a special scenario happens when fi is identical
to fj for all i, j ∈ [0, n − 1], and gj denoted above is an
identical transformation, making Sj, j ∈ [0, n − 1] equal
to each other. Under these conditions, the process of
ﬁngerprint identiﬁcation can be regarded as an approxima-
tion of correlation power analysis as described in [4] but
in a horizontal direction, with the famous DIST Pearson
correlation coeﬃcient.
Following the expressions above, we mainly discuss in
the subsections below three kinds of leakage ﬁngerprints
detected in RSM2.0, namely the ﬁngerprints of mask, oﬀset
and shuﬄe. By utilizing them, both oﬀset and shuﬄe array
are easily recovered with high probabilities in only one trace,
leading to the collapse of the security foundation of RSM2.0.
3.2 Mask Fingerprints
As a software implementation in ATmega163, RSM2.0
provides many opportunities for attackers to spy the inner
state of the running smart card since assembly instructions
are executed item by item in logical order and continuously
leak power consumptions according to the data they are pro-
cessing. Moreover, Hamming weight (HW) model has long
been considered as a good prediction model to approximate
the real leakage function L for smart card, which is also the
basic assumption for leakage prediction W in this article.
The essence of the mask ﬁngerprint in RSM2.0 mainly lies
in two aspects, the scheme of mask use between successive
rounds and the selection of the mask values.
In details,
as a ﬁxed and publicly known set, mask array is used
randomly according to the oﬀset array updated in each
power trace. However, the relationship of mask usage among
rounds is deﬁnite and can be expressed as M askr (deﬁned
in section 2). Taking the ith byte as an example, the leakage
ﬁngerprint with a maximum length of 11 can be extracted
horizontally with the form of
L ◦ Seq{M [O(i) + r] + εr|r ∈ [0, 10]}
where M [O(i) + 0] is loaded in the register to mask the
corresponding byte of the ﬁrst round key while M [O(i) +
810r], r ∈ [1, 10] is applied to construct the MaskCompensation
matrix of the current round. What makes this ﬁngerprint
further exploitable is that the Hamming Weight of diﬀerent
element in mask array varies irregularly, making the guess-
ing ﬁngerprint candidates distinguishable from each other.
Below, we list 16 possible values of M [O(i) + 0] and their
corresponding HW values.
M[]
HW◦M[]
M[]
HW◦M[]
M[]
HW◦M[]
0x03
0x0c
0x35
0x3a
0x50
0x5f
2
2
4
4
2
6
0x66
0x69
0x96
0x99
0xa0
0xaf
4
4
4
4
2
6
0xc5
0xca
0xf3
0xfc
4
4
6
6
Table 1: Hamming Weight of Mask array.
Based on the list above, 16 guessing ﬁngerprints can be
extracted with the starting point of M [O(i) + 0] and in
the form of Seq{HW ◦ M [O(i) + r]|r ∈ [0, 10]}, where
M [O(i) + r], r ∈ [0, 10] goes along the M [] in a circle. We
list all of these possible ﬁngerprints in the Appendix A in the
order of longest sequence match, and obviously two longest
undistinguishable sequences start at M [2] and M [8] and last
6 elements in both sequences.
In order to identify each M [O(i) + 0], i ∈ [0, 15] with
high probability, we combine the identiﬁcation framework in
Equation (1) with classic template attack (TA [6]) which is
capable of mapping a real leakage ﬁngerprint Tf p into a HW
sequence which is deﬁned as Mf p. Thus the identiﬁcation
process can be redeﬁned as:
M [O(i)] = argmin
M [j]
{DIST (Mf p(M [O(i)]), Gf p(M [j]))}
(2)
Thus, on the basis of 100 percent accuracy for the HW
recovery in each leakage position, the ﬁngerprint with a
length larger than 6 is suﬃcient for guessing the source of the
mask ﬁngerprint, namely M [O(i)+0], i ∈ [0, 15] and with the
total length of 11, the mask ﬁngerprints constructed by us
meet the identiﬁcation condition. Note also that the DIST
to distinguish the correct value of M [O(i)+0] from the other
candidates can be a simple string matching function here.
In addition to the length of ﬁngerprints, two other factors
that have inﬂuences on the ﬁngerprint identiﬁcation are
Minimum Interval of Leakage which we name MIL, and
Signal to Noise Rate (SNR). MIL completely depends
on the value range of the leakage source. For example,
in mask’s case, only three HW leakages from {2, 4, 6}
are possible and thus the MIL equals to 2. Since MIL
keeps constant corresponding to a speciﬁc leakage source,
we don’t perform an in-depth assessment of its inﬂuence.
Intuitively, the larger MIL would result in a better recovery
in each single leakage position with TA and a better
ﬁngerprint identiﬁcation on the whole. On the other hand,
SNR is determined by a variety of causes such as target
devices, measurement instruments, environmental noise,
temperature, humidity etc. But what really matters is the
accuracy SNR aﬀects to map the Tf p into Mf p by TA.
Taking Gf p(M [2]) and Gf p(M [8]) as an example, the in-
correct recovery of HW in three positions of Mf p(M [2])
would possibly mislead the judgment, regarding M [8] as
the correct leakage source by mistake. What’s worse, with
only one mistake induced at a certain position, any real
ﬁngerprint would be mapped into an intermediate state,
diﬀerent from any forms of the 16 guessing ﬁngerprints in
Appendix A. In such a scenario, distinguisher in the form
of string matching function becomes invalid and should be
replaced by a new one with the capability of error tolerance
and error correction.
Before introducing a new distinguisher, we ﬁrst make a
brief observation and statistical analysis of the HW recovery
at one single position under the noise condition. Without
loss of generality, we choose randomly 5000 publicly avail-
able power traces oﬀered by DPA contest v4.2 committee to
perform the recovery process on single leakage position with
the help of TA. Two ﬁgures followed show respectively the
mean power traces of M [O(3) + 5] for 3 kinds of HW levels
and the accuracy for HW (M [O(3) + 5]) recovery with the
assumption of known O(3) in each trace.
Figure 1: Mean traces of diﬀerent Hamming
Weights
Figure 2: Single position deviation
Two conclusions can be drawn from both ﬁgures:
1. The variation in power leakage basically keeps pace
with the HW of the intermediate values processed,
which in turn validates our assumption of leakage type
for the ATmaga163 platform.
2. The HW recovery of the changing M [O(3) + 5] shows
a remarkable feature in the Fig. 2. The success rate of
HW recovery with no deviation is the highest among
ﬁve possible classiﬁcations, reaching approximately
95.3%. Meanwhile, the deviation recovery within one
unit of the MIL has a success rate as high as 99.8%.
811Based on these statistical results, a conclusion can be
drawn that the error of HW recovery at each leakage position
happens occasionally and gathers around the correct HW
within a small scale. Therefore, we propose using Euclidean
Distance model as a replacement for string matching func-
tion to distinguish the correct leakage source under noise
circumstance. Thus the identiﬁcation process can be further
rewritten as:
{Euclid(Mf p(M [O(i)]), Gf p(M [j]))}
(3)
M [O(i)] = argmin
M [j]
Intuitively, the Euclidean distinguisher is capable of mit-
igating the error of source identiﬁcation caused by the
recovery deviation at a few positions, which meets our
requirements for error tolerance and error correction. To
further evaluate the accuracy of ﬁngerprint identiﬁcation
under diﬀerent ﬁngerprint lengths and recovery deviation,
we ﬁrst make a rough construction of the probabilistic model
fp for deviation. More precisely, we deﬁne X ∈ {2, 4, 6} as
the correct HW corresponding to a certain leakage position
and deﬁne Y ∈ {2, 4, 6} as the guessing result on the basis
of that leakage, thus fp is deﬁned in Equation (4), where δ
is the Dirac distribution.
An example of the deviation model for p = 0.65 is depicted
in Fig.3. It should be specially mentioned that with X being
the HW at both ends of the value range, namely 2 and 6
in mark’s case, the possibility of no deviation guesses is
designed to be the accumulation of both p and (1 − p)/2.
It’s reasonable since leakage in ATmega163 complies with a
linear form (as stated in the two conclusions above) and thus
the bias outside the range would most probably be identiﬁed
as the closest value within the range.
With the help of this probabilistic model, we conduct
a series of three experiments by identifying 1000 random
M [O(3) + 0] provided in DPA Contest with the deviated
Mf p(M [O(3)+0]).
In details, we evaluate the inﬂuence of
length ranging from 6 to 11 in each experiment and the
non-deviation possibility p changes from 0.65 to 0.35. The
results of identiﬁcation accuracy are recorded in Table 2:
l
p
0.65
0.50
0.35
6
7
8
9
10
11
72.7% 83.5% 86.3% 88% 94.3% 95.9%
50.3% 59.3% 65.2% 68.7% 75.5% 82.1%
34% 43.2% 47.8% 55.7% 59.6% 68.4%
Table 2:
Identiﬁcation accuracy under diﬀerent
length of ﬁngerprint and deviation model fp(Y |X).
The table clearly shows the eﬀectiveness of our attack by
using the mask ﬁngerprint. What’s more, the Euclidean
Distance model we propose helps to further improve the ac-
curacy and eﬃciency of the identiﬁcation process even under
low SNR condition, making it an easy to use vulnerability
of high risk.
In order to counteract such attack scheme, a straight-
forward and eﬃcient method is to select an array of 16
masks with the same Hamming Weight, resulting in com-
pletely identical ﬁngerprints for all possible leakage sources.
However, it should be noted that the selection of masks is
also constrained, as stated in [5], in order to minimize the
mutual information leakage of mono-variable and provide
security assurance under degree 4, and this would set up
some barriers to the HW-constant countermeasures.
3.3 Offset Fingerprints3
Compared with mask ﬁngerprint which can be mitigated
or completely eliminated by balancing ﬁngerprint candi-
dates, oﬀset ﬁngerprint is much more likely to be overlooked
and also more diﬃcult to remove.
The generation of oﬀset ﬁngerprint also results from the
regularity of mask usage. As stated in 3.2, the masks used
in ten encryption rounds constitute the mask ﬁngerprint.
But before that happens, each [O(i) + r]%16, i ∈ [0, 15],
is individually calculated and
as the index of the mask,
loaded into the register, where r ∈ [0, 10]. Actually,
in
the implementation code, three instructions are operated
successively to get the ﬁnal index of each mask:
Instructions in the assembly code Corresponding results
stored in the register
(Line 1071-1073)
ld H1,X+
add YL,H1
andi YL, 0x0F
O(i)
O(i)+r
[O(i)+r]%16
Table 3: Exploitable leakage sources in assembly
code.
These instructions leak power consumption in the form
of L ◦ O(i) + ε, L ◦ (O(i) + r) + ε, L ◦ ([O(i) + r]%16) + ε
respectively. And we mainly concentrate on the latter two
kinds of leakages as ten rounds of them make up the two
oﬀset ﬁngerprints as follows:
Tf p(O(i)+0) = L ◦ Seq{[O(i) + r] + εr |r ∈ [0, 10]}
Tf p([O(i)+0]%16) = L ◦ Seq{[O(i) + r]%16 + εr |r ∈ [0, 10]}
The same as what is mentioned in 3.2, what makes these
ﬁngerprints exploitable is the distinguishability between
distinct leakage sequences under Hamming Weight assump-
tions. As the index for mask usage, O(i) ranges from 0 to
15 and this range is deﬁned as θ[], where θ[i] = i, i ∈ [0, 15].
We list each number in θ[] and its corresponding Hamming