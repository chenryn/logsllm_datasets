R.5 This would have been the only check performed
by the SBAC test.
2. Verify that the frame of the boolean value pointed
to by append contains R.
is caused
by the fact
the value of append is read
in the security-sensitive operation guarded by the
checkPermission call. This test also succeeds
since that frame is All.
This test
that
5We are abusing the notation here by considering the permission in R1
as a set of atomic permissions, one of which is the permission to write ﬁle
password.txt, as explained in Section 2.
3. Similarly, verify that the frame of the String object
pointed to by name contains R. This test fails because
that frame is ∅.
Therefore, IBAC causes the security-sensitive operation
to fail since it has detected an integrity violation at the
point in which the IBAC test has been executed. As
observed, SBAC would not have recognized the integrity
violation, thereby allowing b.m1 to cause the contents
of passwords.txt to be overwritten. Coincidentally,
HBAC would have caused this program to fail, but only be-
cause the execution of b.m1 was in the history.
2 ∩ R(cid:2)
Another interesting example is the program of Figure 3,
which uses the grant primitive doPrivileged. Assume
that an untrusted client invokes m2 on an object c of type C
after setting c.logFileName to "passwords.txt".
The frame for this value will be All ∩ R(cid:2)
3 = ∅. Fol-
lowing the same reasoning as in the example of Figure 1,
we would conclude that the following must hold:
• The String object pointed to by name in con-
structor
FileOutputStream.(File,
boolean) is framed with ∅ since it is the return
value of file.getPath, and this method returns
exactly the object assigned to logFileName by
the untrusted client. Moreover, the value of name is
control dependent on the File object pointed to by
file, which is framed with ∅, sos (pc) = ∅.
• The value of
the boolean parameter append
the FileOutputStream.(File,
3 = All
from constructor
in
boolean) constructor is framed with All∩R(cid:2)
since
FileOutputStream.(String).
The IBAC test performs the following operations:
originated
value
that
1. Verify that
the set D of
the dynamic permis-
sions associated with the current stack of execu-
tion contains singleton R = {FilePermission
"passwords.txt", "write"}. This test suc-
1 ⊃ R. The presence
ceeds because D = R(cid:2)
of doPrivileged on the stack prevents R(cid:2)
2 from be-
ing part of the computation of D. This would have
been the only test performed by SBAC.
1 = R(cid:2)
3∩R(cid:2)
2. Verify that the frame of the boolean value pointed to
by append contains R. This test also succeeds since
that frame is All, like in the previous example.
3. Verify that the frame of the String object pointed to
by name contains R. This test fails because that frame
is ∅.
Therefore,
IBAC dynamically detects the presence of
tainted variables in privilege-asserting code, solving a seri-
ous problem previously identiﬁed in the literature [33], and
forces interferent programs permitted by SBAC to fail.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:51 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007The program of Figure 4 is useful to illustrate the dif-
ference between IBAC and HBAC. Here, when the IBAC
test is performed, the values used in the security-sensitive
operation dominated by the test are framed as follows:
in
and
F.main
• The String object pointed to by name in
the
FileOutputStream.(File,
boolean) constructor is framed with R(cid:2)(cid:2)
1 since it is
the return value of file.getPath, which returns
exactly the String object "passwords.txt"
allocated
to
passed
FileOutputStream.(String).
Moreover, the value of name is control dependent on
the File object pointed to by file, which also is
framed with R(cid:2)(cid:2)
1 .
• The value of
the boolean parameter append
the FileOutputStream.(File,
with
from the
con-
in
boolean)
All
since
FileOutputStream.(String)
structor.
constructor
value
originated
that
is
framed
The IBAC test performs the following operations:
1. Verify that
the set D of
the dynamic permis-
sions associated with the current stack of execu-
tion contains singleton R = {FilePermission
"passwords.txt", "write"}. This test suc-
ceeds because D = R(cid:2)(cid:2)
1 ⊃ R.
3 ∩ R(cid:2)(cid:2)
1 = R(cid:2)(cid:2)
2. Verify that the frame of the boolean value pointed to
by append contains R. This test also succeeds since
that frame is All.
3. Verify that the frame of the String object pointed to
by name contains R. This test succeeds because that
frame is R(cid:2)(cid:2)
1 ⊃ R.
The HBAC test would have unjustly caused this program
to fail because g.m3 is in the history, and class G has been
granted no permissions.
4.2 Production-level Code
The programs of Sections 1.1 and 1.2 that we have
just revisited are not contrived examples, but have been
inspired by production-level code. Currently,
the core
of the Eclipse platform, called the Rich Client Platform
(RCP), is undergoing extensive code rewriting to permit
it to run with security enabled [15]. This work is being
performed by using a static analyzer to model the stack
inspection mechanism [39] and detect the permission set
required by each RCP component [27] and the security-
sensitive operations that should be wrapped into privilege-
asserting blocks of code to shield other Eclipse compo-
nents from unnecessary permission requirements [33]. The
is that an un-
problem with SBAC, as we have noted,
trusted component may inﬂuence the security-sensitive op-
erations performed in a more trusted component, with-
out being on the stack of execution when the security
check is performed. A concrete example is the following:
Method evaluate in SystemTestExpression, in
the org.eclipse.core.expressions RCP compo-
nent, accesses a security-sensitive system property through
the following code:
String str = (String)
AccessController.doPrivileged(
new PrivilegedAction() {
public Object run() {
return System.getProperty(fProperty);
}
});
Unfortunately,
the String object pointed to by
fProperty is inﬂuenced,
through a series of direct
and indirect ﬂows, by the String object pointed to
by the ELEMENT ACTIVE WHEN constant
in class
HandlerPersistence.
This class is located in
the org.eclipse.ui.workbench RCP compo-
nent, which in the current version of
the RCP has
not been granted the PropertyPermission re-
quired to execute the code above.
In an SBAC sys-
tem such as the current version of Java on top of
which Eclipse runs, a malicious attacker could modify
the value of ELEMENT ACTIVE WHEN and condi-
tion the property being accessed.
Since no method
of HandlerPersistence is on the stack when
System.getProperty calls checkPermission,
this integrity exposure would not disappear by simply
removing the privilege-asserting block around the call
to System.getProperty. Conversely, by tracking
information ﬂows to each security-sensitive operation and
testing not only the callers on the current stack of execution
up to the doPrivileged caller, but also the labels
on all the values read in the security-sensitive operation
guarded by the checkPermission call, IBAC detects
the integrity exposure. It is now up to the developers and
system administrators to decide whether the code needs
to be corrected to eliminate this exposure or whether it is
safe to grant HandlerPersistence the appropriate
PropertyPermission.
5 Proposed Implementation
We propose two different implementations for IBAC en-
forcement: a completely static enforcement, and one that
combines static analysis with dynamic enforcement.
A completely static IBAC enforcement can be achieved
by considering the set of all the statements guarded by the
test. For each statement s guarded by a testR command,
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:51 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007it must be the case that no statement s(cid:2) ∈ backslice(s) orig-
inates from code with static permission set P such that P (cid:8)⊇
R. Here, backslice is the function that maps each statement
s to its static backwards slice, consisting of all the (transi-
tive) predecessors of s along control- and data-dependence
edges in the Program Dependence Graph (PDG). The set of
statements guarded by a test can be assumed to be the set
of statements immediately following the test call.6 For ex-
ample, in the FileOutputStream code of Figure 2, the
statements guarded by the checkPermission call are
the assignment to append and the calls to openAppend
and open.
The stack inspection mechanism necessary to prevent
untrusted code from causing the execution of a security-
sensitive event can also be modeled statically. A call graph
and a points-to graph [21] representing the execution of
the program under analysis are built. For each node in
the call graph corresponding to a checkPermission
method call, the set P of abstract Permission objects
that, according to the model, could have ﬂowed to the
Permission parameter of checkPermission is com-
puted. The level of abstraction could be by allocation
site, as in Andersen’s analysis [3]. Next, each of these
Permission sets is propagated backwards in the call
graph, performing set unions at merge points, until a ﬁx
point is reached [26]. The only nodes in this ﬁx-point iter-
ation that kill the reverse propagation of the Permission
sets are the doPrivileged nodes, to model the require-
ment that a call to doPrivileged on a stack of execu-
tion causes the stack inspection to stop regardless of the
Permission being checked.7 Once a ﬁx point has been
reached, each node in the call graph is mapped to a set of
abstract Permission objects, overapproximating the per-
missions required at run time by the method represented by
that node. The IBAC enforcement will require each class in
the program under analysis to be granted at least the permis-
sions required by each of its declared methods according to
the model.
This approach has the advantage that it is sound; it iden-
tiﬁes all the integrity violations. From a security perspec-
tive, this is important because all such violations will be
6In fact, this should be a security coding guideline, which, if enforced,
helps preventing violations of the Principle of Complete Mediation [35] as
well as Time-Of-Check-To-Time-Of-Use (TOCTTOU) attacks [11].
7We are assuming that the program is a Java program. For other
languages, the algorithm is almost the same, with only slight changes.
For example, in CLR, checkPermission would have to be replaced
by Demand, doPrivileged by Assert, and Permission by
IPermission. Additionally, it should be noted that a doPrivileged
node kills the universe of all the Permission objects associated with the
program under analysis, whereas Assert only kills the IPermission
objects that have been passed to its IPermission parameter. The reason
behind this difference is that doPrivileged stops the stack inspection
indiscriminately, while Assert only stops it for those IPermission
objects that have been passed as parameters to it [32].
Its disadvantage is that it is potentially conser-
detected.
vative, with the result that some of the reported violations
may in reality be false alarms. The precision of the analy-
sis can signiﬁcantly affect its scalability. Alternatively, the
stack-inspection mechanism can still be enforced dynami-
cally, while static analysis is used only to track direct and
indirect ﬂows causing integrity violations.
Dynamic IBAC enforcement can be carried out by as-
sociating a label with every value, based on the static per-
missions granted by the current access-control policy. At
each existing testR command (corresponding to calls to
checkPermission in Java and Demand in CLR), an or-
dinary stack inspection is performed. However, it is neces-
sary for the frame P of each expression E guarded by the
test to satisfy P ⊆ R. This requires inserting additional
test R for E calls for each such expression E . This ap-
proach must be coupled with a static analysis implementing
the write oracle, which is responsible for overapproximat-
ing the set of values that would be modiﬁed at every branch
not taken, as explained in Section 2.2.
6 Related Work
Early work by Denning and Denning [13] focuses on
static analysis for information ﬂow. Subsequently, Goguen
and Meseguer [19] introduce a more general notion of infor-
mation ﬂow based on noninterference. Volpano, et al. [41]
show a type-based algorithm that certiﬁes implicit and ex-
plicit ﬂows and also guarantees noninterference.
Noninterference is traditionally the technical criterion
used for proving correctness of security analysis algorithms
or type systems. However, it is also hard to check non-
interference directly. Snelting et al. [37] connect PDGs
with noninterference. Hammer et al. [23] present a PDG-
based algorithm for verifying noninterference: for any out-
put statement s, it must be the case that any statement in
backslice(s) must have a security labels lower than the se-
curity label of s. It should be noted, however, that type-
system-based algorithms have the advantage of supporting
compositional analysis, which means that parts of programs
can be analyzed in isolation. This is generally hard to do in
PDG-based analysis.
Taint analysis is an integrity problem, in which the fo-
cus is whether untrusted data obtained from the user might
inﬂuence other data that the system trusts. The notion of
tainted variables became known with the Perl language.
In Perl, using the -T option allows detecting tainted vari-
ables [42]. Shankar et al. present a tainted-variable analy-
sis for CQual using constraint graphs [36]. To ﬁnd format-
string bugs, CQual uses a type-qualiﬁer system [17] with
two qualiﬁers: tainted and untainted. A constraint graph is
constructed for a CQual program. If there is a path from
a tainted node to an untainted node in the graph, an error
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:51 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007is ﬂagged. Newsome and Song [31] propose a dynamic
taint analysis that catches errors by monitoring tainted vari-
ables at run time. Data originating or arithmetically derived
from untrusted sources, such as the network, are marked
as tainted. Tainted variables are tracked at run time, and
when they are used in a dangerous way an attack is de-
tected. Volpano et al. [41] relate taint analysis to enforcing
information-ﬂow policies through typing. Ashcraft and En-
gler [4] also use taint analysis to detect software attacks due
to tainted variables. Their approach provides user-deﬁned
sanity checks to untaint potentially tainted variables. To