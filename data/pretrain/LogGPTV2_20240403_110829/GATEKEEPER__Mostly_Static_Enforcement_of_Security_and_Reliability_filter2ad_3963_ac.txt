there is an unfortunate coding pattern encouraged by Live
widgets that makes static analysis difﬁcult, as shown in
Figure 11. The url value, which is the result concatenat-
ing of a constant URL and widgetURL is being used on
the right-hand side and could be used for code injection.
An assignment v1.innerHTML = v2 is rewritten as
if (__IsUnsafe(v2)) {
alert("Disguised eval attempt at :");
} else {
v1.innerHTML = v2;
}
where IsUnsafe disallows all but very simple HTML.
Currently, IsUnsafe is implemented as follows:
function __IsUnsafe(data)) {
return (toStaticHTML(data)===data);
}
toStaticHTML, a built-in function supported in newer
versions of Internet Explorer, removes attempts to intro-
duce script from a piece of HTML. An alternative is to
provide a parser that allows a subset of HTML, an ap-
proach that is used in WebSandbox [25]. The call to
alert is optional — it is only needed if we want to warn
the user. Otherwise, we may just omit the statement in
question.
3.2.2 Rewriting Unresolved Heap Loads and Stores
That syntax for JavaScriptGK supported by GATEKEEPER
has an extra variant of LOAD and STORE rules for associa-
tive arrays, which introduce Datalog facts shown below:
v1 = v2[∗]
v1[∗] = v2
LOAD(v1, v2, _)
STORE(v1, _, v2)
[ARRAYLOAD]
[ARRAYSTORE]
When the indices of an associative array operation cannot
be determined statically, we have to be conservative. This
means that any ﬁeld that may be reached can be accessed.
This also means that to be conservative, we must consider
the possibility that any ﬁeld may be affected as well: the
ﬁeld parameter is unconstrained, as indicated by an _ in
the Datalog rules above.
Example 2. Consider the following motivating example:
’f’ : function(){...},
’g’ : function(){...}, ...};
1. var a = {
2.
3.
5. a[x + y] = function(){...};
6. a.f();
If we cannot statically decide which ﬁeld of object a is be-
ing written to on line 5, we have to conservatively assume
1. function T(){ this.foo = function(){ return 0}};
2. var t = new T();
3. T.prototype.bar = function(){ return 1; };
4. t.bar(); // return 1
dT , pT
a1
dbar, pbar
Figure 9: Prototype manipulation example.
1.
2.
3.
PTSTO(T, dT ). HEAPPTSTO(dT , "prototype", pT ). PROTOTYPE(pT , hFP).
PTSTO(t, a1). PROTOTYPE(a1, pT ).
HEAPPTSTO(pT , "bar", dbar). HEAPPTSTO(dbar, "prototype", pbar). PROTOTYPE(pbar, hFP).
Figure 10: Rules created for the prototype manipulation example in Figure 9.
that the assignment could be to ﬁeld f. This can affect
which function is called on line 6. (cid:3)
Moreover, any statically unresolved store may intro-
duce additional code through writing to the innerHTML
ﬁeld that will be never seen by static analysis. We rewrite
statically unsafe stores v1[i] = v2 by blacklisting ﬁelds
that may lead to code introduction:
While we currently use a blacklist and do our best to
keep it as complete as we can, ideally blacklist design and
browser runtime design would go hand-in-hand. We re-
ally could beneﬁt from a browser-speciﬁed form of run-
time safety, as illustrated by the use strict pragma [14].
A conceptually safer, albeit more restrictive, approach is
to resort to a whitelist of allowed ﬁelds.
if (i==="onclick" ||
i==="onkeypress" || ...) {
alert("Disguised eval attempt at :");
} else
if(i==="innerHTML" && __IsUnsafe(v2)){
alert("Unsafe innerHTML at :");
} else {
v1[i] = v2;
}
Note that we use === instead of == because the lat-
ter form will try to coarse i to a string, which is not our
intention. Also note that it’s impossible to introduce a
TOCTOU vulnerability of having v2 change “underneath
us” after the safety check because of the single-threaded
nature of JavaScript.
Similarly, statically unsafe loads of the form v1 = v2[i]
can be restricted as follows:
if (i==="eval" || i==="setInterval" ||
i==="setTimeout" || i==="Function" ||...)
{
alert("Disguised eval attempt at :");
} else {
v1 = v2[i];
}
Note that we have to check for unsafe functions such as
eval, setInterval, etc. While we reject them as tokens
for JavaScriptSAFE, they may still creep in through stati-
cally unresolved array accesses. Note that to preserve the
soundness of our analysis, care must be taken to keep the
blacklist comprehensive.
3.3 Normalization Details
In this section we discuss several aspects of normalizing
the JavaScript AST. Note that certain tricky control ﬂow
and reﬂective constructs like for...in are omitted here be-
cause our analysis is ﬂow-insensitive.
Handling the global object. We treat the global object
explicitly by introducing a variable global and then as-
signing to its ﬁelds. One interesting detail is that global
variable reads and writes become loads and stores to ﬁelds
of the global object, respectively.
Handling of this argument in function calls. One
curious feature of JavaScript
is its treatment of the
this keyword, which is described in section 10.2 of
the EcmaScript-262 standard.
For calls of the form
f(x, y, ...), the this value is set by the runtime to the
global object. This is a pretty surprising design choice, so
we translate syntactic forms f(x, y, ...) and o.f(x, y, ...)
differently, passing the global object in place of this in
the former case.
3.4 Native Environment
The browser embedding of the JavaScript engine has
a large number of pre-deﬁned objects.
In addition to
Array, Date, String, and other objects deﬁned by the
EcmaScript-262 standard,
the browser deﬁnes objects
such as Window and Document.
Native environment construction. Because we are do-
ing whole-program analysis, we need to create stubs for
this.writeWidget = function(widgetURL) {
var url = "http://widgets.clearspring.com/csproduct/web/show/flash?
opt=-MAX/1/-PUR/http%253A%252F%252Fwww.microsoft.com&url="+widgetURL;
var myFrame = document.createElement("div");
myFrame.innerHTML = ’’;
...
}
Figure 11: innerHTML assignment example
the native environment so that calls to built-in methods re-
solve to actual functions. We recursively traverse the na-
tive embedding. For every function we encounter, we pro-
vide a default stub function(){return undefined;}.
The resulting set of declarations looks as follows:
var global = new Object();
// this references in the global namespace refer to global
var this = global;
global.Array = new Object();
global.Array.constructor = new function(){return undefined;}
global.Array.join = new function(){return undefined;}
...
Note that we use an explicit global object to host a
namespace for our declarations instead of the implicit
this object that JavaScript uses.
In most browser im-
plementations,
the global this object is aliased with
the window object, leading to the following declaration:
global.window = global;.
Soundness. However, as it turns out, creation of a sound
native environment is more difﬁcult than that. Indeed, the
approach above assumes that the built-in functions return
objects that are never aliased. This fallacy is most obvi-
ously demonstrated by the following code:
var parent_div = document.getElementById(’header’);
var child_div = document.createElement(’div’);
parent_div.appendChild(child_div);
var child_div2 = parent_div.childNodes[0];
In this case, child div and child div2 are aliases for
the same DIV element.
if we pretend they are not, we
will miss an existing alias. We therefore model operations
such as appendChild, etc. in JavaScript code, effectively
creating mock-ups instead of native browser-provided im-
plementations.
In our implementation, we have done our best to ensure
the soundness of the environment we produce by starting
with an automatically generated collection of stubs and
augmenting them by hand to match what we believe the
proper browser semantics to be. This is similar to mod-
eling memcpy in a static analysis of C code or native
methods in a static analysis for Java. However, as with
two instance of foreign function interface (FFI) model-
ing above, this form of manual involvement is often error-
prone. It many also unfortunately compromise the sound-
ness of the overall approach, both because of implemen-
tation mistakes and because of browser incompatibilities.
A potential alternative to our current approach and part
of our future work is to consider a standards-compliant
browser that that implements some of its library code in
JavaScript, such as Chrome. With such an approach, be-
cause libraries become amenable to analysis, the need for
manually constructed stubs would be diminished.
When modeling the native environment, when in doubt,
we tried to err on the side of caution. For instance, we do
not attempt to model the DOM very precisely, assuming
initially that any DOM-manipulating method may return
any DOM node (effectively all DOM nodes are statically
modeled as a single allocation site). Since our policies in
Section 4 do not focus on the DOM, this imprecise, but
sound modeling does not result in false positives.
4 Security and Reliability Policies
This section is organized as follows. Sections 4.1–4.4 talk
about six policies that apply to widgets from all widgets
hosts we use in this paper (Live, Sidebar, and Google).
Section 4.5 talks about host-speciﬁc policies, where we
present two policies speciﬁc to Live and one speciﬁc to
Sidebar widgets. Along with each policy, we present the
Datalog query that is designed to ﬁnd policy violations.
We have run these queries on our set of 8,379 benchmark
widgets. A detailed discussion of our experimental ﬁnd-
ings can be found in Section 5.
4.1 Restricting Widget Capabilities
Perhaps the most common requirement for a system that
reasons about widgets is the ability to restrict code capa-
bilities, such as disallowing calling a particular function,
using a particular object or namespace, etc. The Live
Widget Developer Checklist provides many such exam-
ples [34]. This is also what systems like Caja and Web-
Sandbox aim to accomplish [25, 29]. We can achieve the
same goal statically.
Pop-up boxes represent a major annoyance when using
web sites. Widgets that bring up popup boxes, achieved
by calling function alert in JavaScript, can be used for
denial-of-service against the user. In fact, the alert box
prevention example below comes from a widget sample
that asynchronously spawns new alert boxes; this wid-
get is distributed with WebSandbox [26]. The following
query ensures that the alert routine is never called:
Array.prototype.feed = function(o, s){
if(!s){s=o;o={};}
var k,p=s.split(":");
while(typeof(k=p.shift())!="undefined")
o[k]=this.shift();
return o;
}
Query output: AlertCalls(i : I )
GlobalSym(m, h)
: –
PTSTO("global", g),
HEAPPTSTO(g, m, h).
AlertCalls(i)
: – GlobalSym("alert", h),
CALLS(i, h).
To deﬁne AlertCalls, we ﬁrst deﬁne an auxiliary query
GlobalSym : F × H used for looking up global functions
such as alert. On the right-hand side, g ∈ H is the
explicitly represented global object pointed to by vari-
able global. Following ﬁeld m takes us to the heap ob-
ject h of interest. AlertCalls instantiates this query for
ﬁeld alert. Note that there are several references to it in
the default browser environment such as window.alert
and document.alert. Since they all are aliases for the
same function, the query above will spot all calls, inde-
pendently of the the reference being used.
4.2 Detecting Writes to Frozen Objects
We disallow changing properties of built-in objects such
as Boolean, Array, Date, Function, Math, Document,
Window, etc.
to prevent environment pollution at-
tacks such as prototype hijacking [9]. This is simi-
lar to frozen objects proposed in EcmaScript 4. The
query in Figure 12 looks for attempts to add or up-
date properties of JavaScript built-in objects speciﬁed by
the auxiliary query BuiltInObject, including attempts to
change their prototypes: The rules above handle the case
of assigning to properties of these built-in objects di-
rectly. Often, however, a widget might attempt to as-
sign properties of the prototype of an object as in
Function.prototype.apply = function(){...}. We
can prevent this by ﬁrst deﬁning a recursive heap reacha-
bility relation Reaches:
Reaches(h1, h2)
Reaches(h1, h2)
: – HEAPPTSTO(h1, _, h2).
: – HEAPPTSTO(h1, _, h0),
Reaches(h0, h2).
and then adding to the FrozenViolation deﬁnition:
FrozenViolation(v)
: –
STORE(v, _, _),
PTSTO(v, h0),
BuiltInObject(h),
Reaches(h, h0).
An example of a typical policy violation from our exper-
iments is shown below:
4.3 Detecting Code Injection
As discussed above, document.write is a routine that
allows the developer to output arbitrary HTML, thus al-
lowing code injection through the use of  tags.
While verbatim calls to document.write can be found
using grep, it is easy to disguise them through the use of
aliasing:
var x = document;
var y = x.write;
y("");
The query below showcases the power of points-to analy-
sis. In addition to ﬁnding the direct calls, the query be-
low will correctly determine that the call to y invokes
document.write.
Query output: DocumentWrite(i : I )
DocumentWrite(i)
: – GlobalSym("document", d ),
HEAPPTSTO(d, "write", m),
CALLS(i, h).
DocumentWrite(i)
: – GlobalSym("document", d ),
HEAPPTSTO(d, "writeln", m),
CALLS(i, h).
4.4 Redirecting the Browser
JavaScript in the browser has write access to the current
page’s location, which may be used to redirect the user
to a malicious site. Google widget Google Calculator
performing such redirection is shown below:
window.location =
"http://e-r.se/google-calculator/index.htm"
Allowing such redirect not only opens the door to phish-
ing widgets luring users to malicious sites, redirects
within an iframe also open the possibility of running
code that has not been adequately checked by the host-
ing site, potentially circumventing policy checking en-
tirely. Another concern is cross-site scripting attacks
that involve stealing cookies: a cross-site scripting at-
tack may be mounted by assigning a location of the form
"http : //www.evil.com/" + document.cookie. Of
Query output: FrozenViolation(v : V )
BuiltInObject(h) : – GlobalSym("Boolean", h). BuiltInObject(h) : – GlobalSym("Array", h).
BuiltInObject(h) : – GlobalSym("Date", h).
BuiltInObject(h) : – GlobalSym("Math", h).
BuiltInObject(h) : – GlobalSym("Window", h).
BuiltInObject(h) : – GlobalSym("Function", h).
BuiltInObject(h) : – GlobalSym("Document", h).
FrozenViolation(v) : – STORE(v, _, _), PTSTO(v, h), BuiltInObject(h).
Figure 12: FrozenViolations query
course, grep is not an adequate tool for spotting redi-
rects, both because of the aliasing issue described above
and because read access to window.location is in fact
allowed. Moreover, redirects can take many forms, which
we capture through the queries below. Direct location
assignment are found by the following query:
var SearchTag = new String ("Home");
var SearchTagStr = new String(
"meta%3ASearch.tag%28%22beginTag+" +
SearchTag +"endTag%22%29");
var QnaURL = new String(
SearchHostPath /*+ SearchQstateStr */+
SearchTagStr +"&format=rss") ;
// define the constructor for your Gadget
Microsoft.LiveQnA.RssGadget =
function(p_elSource, p_args, p_namespace) { ... }
Query output: LocationAssign(v : V )
LocationAssign(v)
: – GlobalSym("window", h),
PTSTO(v, h),
STORE(_, "location", v).
LocationAssign(v)
: – GlobalSym("document", h),
LocationAssign(v)
: –
PTSTO(v, h),
STORE(_, "location", v).
PTSTO("global", h),
PTSTO(v, h),
STORE(_, "location", v).
Storing to location object’s properties are found by the
following query:
LocationAssign(v)
: – GlobalSym(h, "location"),
PTSTO(v, h),
STORE(v, _, _).
Calling methods on the location object are found by the
following query:
Query output: LocationChange(i : I )
LocationChange(i)
LocationChange(i)
LocationChange(i)
: – LocationObject(h),
HEAPPTSTO(h, "assign", h0),
CALLS(i, h0).