。
1 35
CISSP 官方学习指南(第 7 版)
在 下面的示例 中 ， 可 以看到当 X和Y进行 XOR 运算时的情况:
X: 01101100
Y: 1 0 1 0 0 1 1 1
X EB Y: 1 1 0 0 1 0 1 1
3. 模函数
在密码学领域， 模函数极为重要。 回想一下我们最初学习除法时的情形。 在那时， 你并不熟悉
小数， 每次在进行除法操作时都会得出余数。 计算机本来也不理解小数系统， 并且这些余数在计算
机执行很多数学运算时起到了 至关重要的作用。 模函数十分简单， 也就是在完成除法运算后得到
余数。
提示 :
对于密码学来说， 模函数就如同逻辑运算一样重要。 应 该确保对其功能非常熟悉， 并且可以执
行一些 简单的棋运算 。
1 36
在等式中 ， 模函数通常由缩写词 mod 来表示， 不过有时也会用%运算符来表示。 下面给出 了几
个模运算的输入和输出示例 :
8 mod 6 = 2
6 mod 8 = 6
10 mod 3 = 1
10 mod 2 = 0
32 mod 8 = 0
我们将在第 7 章探讨 RSA 公钥算法(以其发明 者 Rivest、 Shamir、 Adleman 命名)时再次介绍这
种运算。
4. 单向函数
单向函数是一种数学运算， 它可以通过所有可能的输入值组合得出结果， 但是反向得出输入值
却是不可能的 。 公钥密码系统都建立在单向 函数的基础上。 但实际上， 人们从未证明过任何指定的
己知函数确实是单向的。 密码员依赖于他们认定的单向函数， 但是理论上它们可能会被将来的密码
分析人员破解。
这里举一个例子。 试想你有一个三个数相乘的 函数。 如果限制输入值是一位数字 ， 那么通过
查看数值结果反向设计这个函数并确定可能的输入值是相当简单的 。 例如， 通过 1 、 3和5这三个
输入值可以得到结果 15。 然而， 假设限制输入值为 5 位的素数。 通过计算机或计算器获得结果还
是很简单的， 但是反向推算就不是那么简单了 。 你能算出 10718 488 075 259 是哪三个素数得出 的
结果吗? 不是那么简单 ， 对吗? (这三个数是 1 7 093、 22 441 和 27 943)。 实际上 5 位的素数共有 8 363
个 ， 因此利用计算机或穷举攻击算法可能会破解这个问题， 但 口算是无法得出结果的， 这一点是肯
定 的 !
第6章 密码学与对称加密算法
5. 随机数
密码学往往通过在加密过程中添加随机性来获得强度。 实现这个 目 标的一种方法是使用随机数。
随机数是随机数字发生器 ， 起到了 数学函数中 占位符变量的作用。 执行数学函数时， 占位符会被替
换为在处理时刻生成的随机数。 每次使用数学函数时 ， 随机数都会产生一个独特的数字。 随机数的
一个更为人接受的示例是初始向量(Initialization Vector， IV)， 这是一个与分组长度相 同的随机比特
串 ， 并且与原始消息相异或。 在每次使用相 同密钥加密相同的消息时， N 都被用于创建独特的密文。
6. 零知识证明
密码学的一个优点是建立了 这样的机制: 在不向第三方揭示事实本身的情况下向第三方证明对
事实的 了解。 这种机制通常涉及密码和其他秘密的身份认证。
零知识证明的经典示例涉及两个人: Peggy 和 Victor0 Peggy 知道环形洞穴内部暗门 的密码， 如
图 6.2 所示。 Victor 愿意从 Peggy 那里购买密码， 但是在付款之前希望 P巳ggy 证明她确实知道密码。
因 为担心得不到酬金， 所以 Peggy 也不愿意先将密码告诉 Victor。 零知识证明就能够解决这个左右
为难的问题。
. .
图 6.2 魔法门
Victor 可 以站在洞穴的入口， 并且 目 送 Peggy 进入洞穴。 Peggy 随后到达暗门 ， 并且使用密码打
开暗门 。 她穿过暗门 ， 最后通过路径 2 返回洞穴入口。 Victor 看到 Peggy 从路径 1 进入洞穴， 然后
通过路径 2 返回 ， 这就证明她肯定知道打开暗 门 的密码。
7 分割知识
如果执行某个操作所需的信息或权限在多个用户之间分配时， 任何一个人都没有足够的权限来
危害环境的安全性。 单个解决方案中 包含的这种职责分离和两人控制被称为分割知识。 分割知识
的最佳示例就是密钥托管的概念。 通过使用密钥托管， 密码密钥、 数字签名甚至数字证书 ， 可 以
被存储在或备份在一种被称为密钥托管数据库的特殊数据库中 。 如果用户 的密钥丢失或损坏， 那
么 可以从备份中抽取出相应的密钥 。 然而， 如果只存在一个密钥托管恢复代理 ， 那么就有机会伪
1 37
CISSP 官方学习指南(第 7 版)
造和滥用这种权限。 "M ofN 控制 " 要求: 在总数为 N 的代理中 ， 最少需要 M 个代理一起工作才能
完成安全性很高的任务。 因此， "3 of 8 控制 " 要求 8 个人(被分配了密钥托管恢复代理的工作任
务)中 的 3 个人一起完成工作， 才能从密钥托管数据库中取出单个密钥(本例说明 了 M 始终小于等
于 N) 。
8. 工作函数
通过使用工作函数或工作因数， 从成本和/或时间方面来度量所有努力， 就可 以度量密码学系统
的强度 。 通常， 针对加密系统执行完全穷举攻击所需的时间和努力， 就是工作函数所表示的 内容。
密码系统提供的安全性和保护与工作函辈U因数的值成正比。 工作函数的大小应当与受保护资产的相
对值匹配。 工作函数只需稍大于受保护资产 的时间值。 换句话说， 所有安全性(包括密码学)都应当
是有效益的和有效率的 。 保护某个资产所花费的成本不能超过这个资产 自 身的价值， 但是一定要保
证提供足够的保护。 因此， 如果信息由于时间的推移而失去价值， 那么工作函数的大小只 需确保在
数据失去价值前提供保护 即可。
6.2.4 密码
许多关心保持通信机密性的政府和个人已经使用密码系统很长时间 了 。 在接下来的内容中， 我
们将对密码的概念和几种常见的、 形成现代密码基础的密码类型进行介绍。 这些概念看起来只 是基
础知识， 但是在组合使用时可能是令人畏惧的对手， 并且会令密码分析人员长时间无法破解。
1 . 编码与密码
1 38
人们常常将词汇 "编码" 和 "密码" 互换使用 ， 但是从技术上讲 ， 它们是不能互换的。 在这两
个概念之间 ， 存在很重要的差异。 编码是密码学系统中表示词汇或短语的符号， 有时 是秘密的， 但
是不一定提供机密性。 编码的常见示例是执法机构使用 的通信 " 10 系统"。 在这个系统中 ， 1;吾句 " 我
收到你的信息， 并且理解其含义" 被表示成编码短语 " 1 0-4飞 这个编码是众人皆知的， 但是它确实
提供了 通信 的简 易性。 一些编码是秘密的 。 为了传输机密的消息， 这些编码可能使用数学函数或密
码字典来表示词汇、 短语或句子。 例如 ， 间谍可能通过传送语句 "鹰着陆了 " 来报告敌人飞机的来袭。
另 一方面， 密码总是意味着隐藏消息的真实含义。 密码使用各种技术修改和/或重新排列消息中
的字符或比特， 从而实现机密'性。 在 比特(也就是二进制编码的单个位)、 字符(也就是 ASCII 码消息
的单个字符)或分组(也就是一条消息的固定长度分段， 通常用 比特数表示)的基础上， 密码将消息从
明 文转换为密文 。 接下来将介绍几种 目 前常用 的密码。
提示 :
记住编码和密码之间差异的一种简单方法是: 编码针对词汇和短语， 而 密码则针对单独的字符
和比特。
2. 换位密码
换位密码使用某种加密算法重新排列明 文消息中 的字母， 从而形成密文消息。 解密算法只需反
演加密转换过程就可 以得到原始消息。
第6章 密码学与对称加密算法
在本章前面的图 6. 1 所示的挑战/响应协议示例中 ， 一个简单的换位密码被用于简单地调换消息
中 的字母， 从而使 apple 变成 elppa。 换位密码可能会比这个示例复杂得多。 例如， 可 以使用一个密
钥来执行柱状换位(∞iωnnar transpositioo)。 在该例中， 我们试图利用密钥 attacker 对信息"The fighters
will strike the eoemy bases at 0000" 进行加密。 首先， 我们要取出密钥的宇母， 并且依照宇母顺序进
行编号。 第一个字母A的值为 1 ， 第二个字母 A 的值为 2， 下一个字母按顺序是 C， 编号为 3 ， 依
此类推。 结果就是下面这个顺序:
A T TACKER
1 7 8 2 3 5 4 6
接下来， 消息中 的字母按顺序写 在密钥字母的下面:
A T T A C K E R
1 7 8 2 354 6
T H E F 1 G H T
E R S W 1 L L S
T R IKE T H E
E N E M Y B A S
ESATNO ON
最后， 发送者通过向 下读取每一列对消息进行加密， 这些列的顺序依据第一步中分配的数字读
取 。 这个过程便产生 了 如下所示的密文:
T E T E E F W K M T 1 1 E Y N H L H A 0 G L T B 0 T S E S N H R R N S E S 1 E A
在另一端 ， 接收者利用密文和相同 的密钥重建这个 8 列矩阵， 随后按行读取得到明文消息 。
3. 替代密码
替代密码使用加密算法将明文消息中 的每一个字符或比特都替换为不同的宇符。 在本章开始时
讨论的凯撒密码就是替代密码的一个很好的例子。 现在我们 已经学习 了 密码学的一些数学知识， 所
以将从另外的方面研究凯撒密码。 前面曾经介绍过， 我们简单地将消息 中 的每个字母都替换为其右
侧第三个字母， 从而生成密文。 然而， 在到达字母表的末端并且用光了字母时 ， 我们碰到了 问题。
通过绕回到字母表的开头就可以解决这个问题， 这样明 文字符 Z 变成 了 密文字符 C。
通过将每个字母转换成与之对等的十进制值(即 A 等于 0， z 等于 25)， 就可以采用数学关系来
表示 ROT3 密码。 随后， 通过将每个明文字母加 3 就能够确定密文。 利用 " 密码学的数学原理 " 一
节 中 的模函数可以将回绕过程考虑在 内 。 凯撒密码最终的加密函数如下所示: