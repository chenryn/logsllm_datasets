---
author: Alex Chadwick
category: 树莓派
comments_data:
- date: '2019-09-29 14:35:01'
  message: 有多想不开,使用汇编语言? 二十年前我毕业的时候,学校里主要教汇编,我到企业一看根本不会有人使用了汇编,这都9102年了,,
  postip: 27.17.71.210
  username: fefjlsdfdfsx [Firefox 67.0|GNU/Linux]
count:
  commentnum: 1
  favtimes: 0
  likes: 0
  sharetimes: 0
  viewnum: 7298
date: '2019-02-16 14:52:00'
editorchoice: false
excerpt: 在本系列中，你将学习在树莓派中如何使用汇编代码控制屏幕，从显示随机数据开始，接着学习显示一个固定的图像和显示文本，然后格式化数字为文本。
fromurl: https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen01.html
id: 10540
islctt: true
largepic: /data/attachment/album/201902/16/145001egq5zxwgy7o3qrj7.jpg
permalink: /article-10540-1.html
pic: /data/attachment/album/201902/16/145001egq5zxwgy7o3qrj7.jpg.thumb.jpg
related:
- displayorder: 0
  raid: 10530
- displayorder: 0
  raid: 10551
reviewer: wxy
selector: lujun9972
summary: 在本系列中，你将学习在树莓派中如何使用汇编代码控制屏幕，从显示随机数据开始，接着学习显示一个固定的图像和显示文本，然后格式化数字为文本。
tags:
- 树莓派
- 屏幕
thumb: false
title: 计算机实验室之树莓派：课程 6 屏幕01
titlepic: true
translator: qhwdw
updated: '2019-02-16 14:52:00'
---
![](/data/attachment/album/201902/16/145001egq5zxwgy7o3qrj7.jpg)
欢迎来到屏幕系列课程。在本系列中，你将学习在树莓派中如何使用汇编代码控制屏幕，从显示随机数据开始，接着学习显示一个固定的图像和显示文本，然后格式化数字为文本。假设你已经完成了 OK 系列课程的学习，所以在本系列中出现的有些知识将不再重复。
第一节的屏幕课程教你一些关于图形的基础理论，然后用这些理论在屏幕或电视上显示一个图案。
### 1、入门
预期你已经完成了 OK 系列的课程，以及那个系列课程中在 `gpio.s` 和 `systemTimer.s` 文件中调用的函数。如果你没有完成这些，或你喜欢完美的实现，可以去下载 `OK05.s` 解决方案。在这里也要使用 `main.s` 文件中从开始到包含 `mov sp,#0x8000` 的这一行之前的代码。请删除这一行以后的部分。
### 2、计算机图形
正如你所认识到的，从根本上来说，计算机是非常愚蠢的。它们只能执行有限数量的指令，仅仅能做一些数学，但是它们也能以某种方式来做很多很多的事情。而在这些事情中，我们目前想知道的是，计算机是如何将一个图像显示到屏幕上的。我们如何将这个问题转换成二进制？答案相当简单；我们为每个颜色设计一些编码方法，然后我们为在屏幕上的每个像素保存一个编码。一个像素就是你的屏幕上的一个非常小的点。如果你离屏幕足够近，你或许能够辨别出你的屏幕上的单个像素，能够看到每个图像都是由这些像素组成的。
> 
> 将颜色表示为数字有几种方法。在这里我们专注于 RGB 方法，但 HSL 也是很常用的另一种方法。
> 
> 
> 
随着计算机时代的进步，人们希望显示越来越复杂的图形，于是发明了图形卡的概念。图形卡是你的计算机上用来在屏幕上专门绘制图像的第二个处理器。它的任务就是将像素值信息转换成显示在屏幕上的亮度级别。在现代计算机中，图形卡已经能够做更多更复杂的事情了，比如绘制三维图形。但是在本系列教程中，我们只专注于图形卡的基本使用；从内存中取得像素然后把它显示到屏幕上。
不管使用哪种方法，现在马上出现的一个问题就是我们使用的颜色编码。这里有几种选择，每个产生不同的输出质量。为了完整起见，我在这里只是简单概述它们。
| 名字 | 唯一颜色数量 | 描述 | 示例 |
| --- | --- | --- | --- |
| 单色 | 2 | 每个像素使用 1 位去保存，其中 1 表示白色，0 表示黑色。 | Monochrome image of a bird |
| 灰度 | 256 | 每个像素使用 1 个字节去保存，使用 255 表示白色，0 表示黑色，介于这两个值之间的所有值表示这两个颜色的一个线性组合。 | Geryscale image of a bird |
| 8 色 | 8 | 每个像素使用 3 位去保存，第一位表示红色通道，第二位表示绿色通道，第三位表示蓝色通道。 | 8 colour image of a bird |
| 低色值 | 256 | 每个像素使用 8 位去保存，前三位表示红色通道的强度，接下来的三位表示绿色通道的强度，最后两位表示蓝色通道的强度。 | Low colour image of a bird |
| 高色值 | 65,536 | 每个像素使用 16 位去保存，前五位表示红色通道的强度，接下来的六位表示绿色通道的强度，最后的五位表示蓝色通道的强度。 | High colour image of a bird |
| 真彩色 | 16,777,216 | 每个像素使用 24 位去保存，前八位表示红色通道，第二个八位表示绿色通道，最后八位表示蓝色通道。 | True colour image of a bird |
| RGBA32 | 16,777,216 带 256 级透明度 | 每个像素使用 32 位去保存，前八位表示红色通道，第二个八位表示绿色通道，第三个八位表示蓝色通道。只有一个图像绘制在另一个图像的上方时才考虑使用透明通道，值为 0 时表示下面图像的颜色，值为 255 时表示上面这个图像的颜色，介于这两个值之间的所有值表示这两个图像颜色的混合。 |
> 
> 不过这里的一些图像只用了很少的颜色，因为它们使用了一个叫空间抖动的技术。这允许它们以很少的颜色仍然能表示出非常好的图像。许多早期的操作系统就使用了这种技术。
> 
> 
> 
在本教程中，我们将从使用高色值开始。这样你就可以看到图像的构成，它的形成过程清楚，图像质量好，又不像真彩色那样占用太多的空间。也就是说，显示一个比较小的 800x600 像素的图像，它只需要小于 1 MiB 的空间。它另外的好处是它的大小是 2 次幂的倍数，相比真彩色这将极大地降低了获取信息的复杂度。
树莓派和它的图形处理器有一种特殊而奇怪的关系。在树莓派上，首先运行的事实上是图形处理器，它负责启动主处理器。这是很不常见的。最终它不会有太大的差别，但在许多交互中，它经常给人感觉主处理器是次要的，而图形处理器才是主要的。在树莓派上这两者之间依靠一个叫 “邮箱” 的东西来通讯。它们中的每一个都可以为对方投放邮件，这个邮件将在未来的某个时刻被对方收集并处理。我们将使用这个邮箱去向图形处理器请求一个地址。这个地址将是一个我们在屏幕上写入像素颜色信息的位置，我们称为帧缓冲，图形卡将定期检查这个位置，然后更新屏幕上相应的像素。
> 
> 保存 帧缓冲   frame buffer 给计算机带来了很大的内存负担。基于这种原因，早期计算机经常作弊，比如，保存一屏幕文本，在每次单独刷新时，它只绘制刷新了的字母。
> 
> 
> 
### 3、编写邮差程序
接下来我们做的第一件事情就是编写一个“邮差”程序。它有两个方法：`MailboxRead`，从寄存器 `r0` 中的邮箱通道读取一个消息。而 `MailboxWrite`，将寄存器 `r0` 中的头 28 位的值写到寄存器 `r1` 中的邮箱通道。树莓派有 7 个与图形处理器进行通讯的邮箱通道。但仅第一个对我们有用，因为它用于协调帧缓冲。
> 
> 消息传递是组件间通讯时使用的常见方法。一些操作系统在程序之间使用虚拟消息进行通讯。
> 
> 
> 
下列的表和示意图描述了邮箱的操作。
表 3.1 邮箱地址
| 地址 | 大小 / 字节 | 名字 | 描述 | 读 / 写 |
| --- | --- | --- | --- | --- |
| 2000B880 | 4 | Read | 接收邮件 | R |
| 2000B890 | 4 | Poll | 不检索接收 | R |
| 2000B894 | 4 | Sender | 发送者信息 | R |
| 2000B898 | 4 | Status | 信息 | R |
| 2000B89C | 4 | Configuration | 设置 | RW |
| 2000B8A0 | 4 | Write | 发送邮件 | W |
为了给指定的邮箱发送一个消息：
1. 发送者等待，直到 `Status` 字段的头一位为 0。
2. 发送者写入到 `Write`，低 4 位是要发送到的邮箱，高 28 位是要写入的消息。
为了读取一个消息：
1. 接收者等待，直到 `Status` 字段的第 30 位为 0。
2. 接收者读取消息。
3. 接收者确认消息来自正确的邮箱，否则再次重试。
如果你觉得有信心，你现在已经有足够的信息去写出我们所需的两个方法。如果没有信心，请继续往下看。
与以前一样，我建议你实现的第一个方法是获取邮箱区域的地址。
```
.globl GetMailboxBase
GetMailboxBase:
ldr r0,=0x2000B880
mov pc,lr
```
发送程序相对简单一些，因此我们将首先去实现它。随着你的方法越来越复杂，你需要提前去规划它们。规划它们的一个好的方式是写出一个简单步骤列表，详细地列出你需要做的事情，像下面一样。
1. 我们的输入将要写什么（`r0`），以及写到什么邮箱（`r1`）。我们必须验证邮箱的真实性，以及它的低 4 位的值是否为 0。不要忘了验证输入。
2. 使用 `GetMailboxBase` 去检索地址。
3. 读取 `Status` 字段。
4. 检查头一位是否为 0。如果不是，回到第 3 步。
5. 将写入的值和邮箱通道组合到一起。
6. 写入到 `Write`。
我们来按顺序写出它们中的每一步。
1、这将实现我们验证 `r0` 和 `r1` 的目的。`tst` 是通过计算两个操作数的逻辑与来比较两个操作数的函数，然后将结果与 0 进行比较。在本案例中，它将检查在寄存器 `r0` 中的输入的低 4 位是否为全 0。
```
.globl MailboxWrite
MailboxWrite:
tst r0,#0b1111
movne pc,lr
cmp r1,#15
movhi pc,lr
```
> 
> `tst reg,#val` 计算寄存器 `reg` 和 `#val` 的逻辑与，然后将计算结果与 0 进行比较。
> 
> 
> 