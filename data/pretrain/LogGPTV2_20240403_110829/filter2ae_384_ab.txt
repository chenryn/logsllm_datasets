  * 5.REPLY：
主节点和副本节点收到COMMIT消息，需要进行以下交验：
a. 副本节点COMMIT消息签名是否正确。
b. 当前副本节点是否已经收到了同一视图v下的n。
c. d与m的摘要是否一致。
d. n是否在区间[h, H]内。
非法请求丢弃。如果副本节点i收到了2f+1个验证通过的COMMIT消息，说明当前网络中的大部分节点已经达成共识，运行客户端的请求操作o，并返回``给客户端，r是请求操作结果，客户端如果收到f+1个相同的REPLY消息，说明客户端发起的请求已经达成全网共识，否则客户端需要判断是否重新发送请求给主节点。记录其他副本节点发送的COMMIT消息到log中。
垃圾回收：
在上述算法流程中，为了确保在View
Change的过程中，能够恢复先前的请求，每一个副本节点都记录一些消息到本地的log中，当执行请求后副本节点需要把之前该请求的记录消息清除掉。最简单的做法是在Reply消息后，再执行一次当前状态的共识同步，这样做的成本比较高，因此可以在执行完多条请求K（例如：100条）后执行一次状态同步。这个状态同步消息就是CheckPoint消息。
副本节点i发送``给其他节点，n是当前节点所保留的最后一个视图请求编号，d是对当前状态的一个摘要，该CheckPoint消息记录到log中。如果副本节点i收到了2f+1个验证过的CheckPoint消息，则清除先前日志中的消息，并以n作为当前一个stable
checkpoint。
这是理想情况，实际上当副本节点i向其他节点发出CheckPoint消息后，其他节点还没有完成K条请求，所以不会立即对i的请求作出响应，它还会按照自己的节奏，向前行进，但此时发出的CheckPoint并未形成stable，为了防止i的处理请求过快，设置一个上文提到的高低水位区间[h,
H]来解决这个问题。低水位h等于上一个stable checkpoint的编号，高水位H = h +
L，其中L是我们指定的数值，等于checkpoint周期处理请求数K的整数倍，可以设置为L =
2K。当副本节点i处理请求超过高水位H时，此时就会停止脚步，等待stable checkpoint发生变化，再继续前进。
View Change：
如果主节点作恶，它可能会给不同的请求编上相同的序号，或者不去分配序号，或者让相邻的序号不连续。备份节点应当有职责来主动检查这些序号的合法性。如果主节点掉线或者作恶不广播客户端的请求，客户端设置超时机制，超时的话，向所有副本节点广播请求消息。副本节点检测出主节点作恶或者下线，发起View
Change协议。
副本节点向其他节点广播``消息。n是最新的stable
checkpoint的编号，C是2f+1验证过的CheckPoint消息集合，P是当前副本节点未完成的请求的PRE-PREPARE和PREPARE消息集合。
当主节点p = v + 1 mod |R|收到2f个有效的VIEW-CHANGE消息后，向其他节点广播``消息。V是有效的VIEW-CHANGE消息集合。O是主节点重新发起的未经完成的PRE-PREPARE消息集合。PRE-PREPARE消息集合的选取规则：
1.选取V中最小的stable checkpoint编号min-s，选取V中prepare消息的最大编号max-s。
2.在min-s和max-s之间，如果存在P消息集合，则创建`, m>`消息。否则创建一个空的PRE-PREPARE消息，即：`, m(null)>,
m(null)`空消息，d(null)空消息摘要。
副本节点收到主节点的NEW-VIEW消息，验证有效性，有效的话，进入v+1状态，并且开始O中的PRE-PREPARE消息处理流程。
在 PBFT 中，通过如下设计，使其在正常情况下的性能有显著优化：
●使用快速的消息认证码和 hash 计算代替计算量大的数字签名计算；
●采用缓存机制，批量的处理客户端请求；
●仅由某一台服务器向客户端发送完整的响应消息，其余服务器只发送 hash 值验证已响应消息的正确性。
但是 PBFT 也存在一些不足之处：
1.客户端请求的处理延时较大，在 5 步通信后才会返回执行结果（使用暂态优化执行仍需要 4 步通信延时）。这是因为正确服务器需要确定至少 f
台其他正确服务器就执行顺序达成一致后才会处理请求消息。
2.服务器间的广播通信量巨大 ,导致容错扩展性方面表现不佳 。对于 n 台服务器，通信复杂度是
O(N²)。随着容忍的拜占庭错误服务器数目增加，通信量急剧上升，正常情况下的性能也会明显下降 。
## 2.2 DPOS - aBFT -- EOS2.0 共识协议
要理解 EOS 平台的 DPoS+aBFT 就要先介绍 DPos 机制。在最早的 EOS 技术白皮书中，EOS主要采用的是 DPoS
机制，而在新版的白皮书中，做了一些改进，采用了 aBFT+DPoS共识机制。
### 2.1.1 什么是DPoS呢？
DPoS：Deligated Proof of Stake，也称委托股权证明，在 EOS 的白皮书中对 EOS 为何使用 DPoS
进行了详尽的解释，简单摘录如下：
EOS.IO软件架构中采用目前为止唯一能够复合上述性能要求的区块链共识算（DPOS）。根据这种算法，全网持有代币的人可以通过投票系统来选择区块生产者，一旦当选任何人都可以参与区块的生产。
EOS.IO里预计每3秒生产一个区块。任何时刻，只有一个生产者被授权产生区块。如果在某个时间内没有成功出块，则跳过该块。
EOS.IO架构中区块产生是以21个区块为一个周期。在每个出块周期开始时，21个区块生产者会被投票选出。前20名出块者首选自动选出，第21个出块者按所得投票数目对应概率选出。所选择的生产者会根据从块时间导出的伪随机数进行混合。以便保证出块者之间的连接尽量平衡。
如果出块者错过了一个块，并且在最近24小时内没有产生任何块，则这个出块者将被删除。这确保了网络的顺利运行。
在正常情况下，DPOS块链不会经历任何分叉，因为块生产者合作生产区块而不是竞争。如果有区块分叉，共识将自动切换到最长的链条。具有更多生产者的区块链长度将比具有较少生产者的区块链增长速度更快。此外，没有块生产者应该同时在两个区块链分叉上生产块。如果一个块生产者发现这么做了，就可能被投票出局。
### 2.1.2 那么什么又是 aBFT+DPoS？
aBFT+DPoS: asynchronous Byzantine Fault Tolerance- Deligated Proof of
Stake，又称具有异步拜占庭容错机制的DPoS。典型的 DPoS
区块链有100％的区块生产者参与。从广播时间开始平均0.25秒后，可以认为交易具有99.9％的确定性。除 DPoS 外，EOS.IO
还添加了异步拜占庭容错（aBFT），以更快地实现不可逆性。aBFT 算法可在1秒内提供 100％ 的不可逆性确认。
拜占庭容错的“异步”属性克服了对容错的挑战，即时序问题。很多 BFT
协议都假定在达成共识时存在最大消息延迟阈值。异步拜占庭容错（aBFT）网络消除了这种假设，并允许某些消息丢失或无限期地延迟。
DPOS 共识加上 aBFT 算法后，验证时不再按照出块顺序由超级节点一个个验证区块内容，而是让出块节点成为主节点，出块后同时向剩下 20
个节点进行广播，并获得节点的验证反馈，如果有超过 2/3 的节点验证通过，则该区块成为不可逆区块。aBFT可以使得EOS的区块确认速度显著增加。
该机制的具体过程是：EOS 的持有者通过投票系统对各个超级节点竞选者进行投票，选出 21 个节点为超级节点。然后这
21个超级节点以自身的网络资源状况商议出一个出块权拥有顺序，在每个超级节点拥有出块权时，以间隔为500毫秒(500毫秒是EOS团队通过大量实验测试得出的当前网络状态下可达到的最小的稳定状态下的出块间隔)连续产生
6 个新区块，然后切换到下一个超级节点连续产生之后的 6 个区块。
该方式可以保证一个超级节点可以连续以500毫秒的间隔产生区块，因为在同一超级节点产生新区块时不受当前网络状况的影响，但由于网络的延迟很难使得其他节点对已经产生的区块进行确认，使其成为不可逆区块。使用上aBFT+DPoS
协议就可以使得 EOS 的出块间隔从原来的3秒降低到500毫秒，这也使得跨链通信的时延大大缩短，单位时间内可确认的交易数量大大提升。
如果网络状况完美，一笔交易被打包后，在0.5秒内就可完全确认。当然，网络不可能一直这么完美，很有可能上一个超级节点出块后，下一个超级节点还没来得及确认这个块，自己就要产生新块了。为避免因出块速度过快而漏块，EOS中21个超级节点的出块顺序是精心确定的。EOS的超级节点按照其他的地理位置依次轮流成为主节点，尽可能减少超级节点的网络延迟。比如超级节点有中国、美国、加拿大、日本，那么成为主节点的顺序是中国>日本>美国>加拿大或者反过来，总之保证相邻最近的超级节点要依次交接主节点角色。
除此之外，还有另外一个机制来避免这一点。在EOS中，虽然出块时间降为0.5秒，但每个超级节点在一轮中连续出 6 个块，也就是说，仍然负责 3
秒时间的出块，只不过是由 1 个块变成了 6
个块。这样，前面几个块肯定有足够时间经过确认，不存在整个超级节点被跳过的现象。可以看出每轮记账节点的出块总时间还是 3 秒钟，在这 3
秒里，因为他对他自己出的块是信任的，所以可以持续出块。一边出块一边广播，3 秒之内率先广播的区块肯定能够得到确认，在网络通畅的情况下，6
个区块都会可能得到确认。