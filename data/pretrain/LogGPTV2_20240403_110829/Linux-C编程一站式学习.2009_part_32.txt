盘
和
片
器
并不
总
备
连
数
都是希望这些数据以后会被程序访问到。大多数程序的行为都具有局部性
相对的，
访
线
总
过据
有些是操作系统配合硬件完成的。
几TB。
2
鼎
典型的
储
典
百GB到
容
百MB至
容
硬盘是
量是
的
存
存是
到
是
一种非
度
难提高到电子的速
机械运动的
磁性介质要旋转，
动
盘时存在机械
磁
硬盘由磁性介质和
说
见
由DRAM组
后
硬
很
后不会丢失。
盘上的
艮受限制。
头组成
明
H
草电丢失的，
所以访问
磁头要稚
D
面关
易失性存储
访问其它
数据掉目
川。保存不
访问硬
问速
速度很
移动
Cache的
成
这
电
在
度
详
存储器都不是由指令直接控制的，有些
称为
（(Non-volatile Memory）。
的106倍。
访问时
是寄存器
几毫秒,
问时间是
典型的访
，操作系统从硬盘读数据时会预读
典问几
易失性存储器
时
型的
纳
间
防提
序的多次访问了。
硬盘的时间就可以
来都被程序访问
如果这几个页面
内存中缓存起来，
盘上读几个页面到
系统通
问速度较慢，操
备总线控制器去议
由驱动程序操作设
作系统维护。
是VA,
程序指令中的地址
用MMU的情况下，
访问的，
内存是通过地址来
决定先做什么后
寄存器一样由指
完成的，
别。Cache所做
的，
级缓存是用PA寻址
是用VA寻址的，
（Amortize）给程
分摊
中查找。
先用PA去二级缓存
间
用
，那么这一次
]的映射关系由
的是PA，
这是它们的
(Volatile
常一次从
而访问内存
而不是
一级缓存
它们之
，或者反复
读
到
硬
作
操
动像冷做
区的
20
访
---
## Page 271
4. MMU
T
一页
能显著提升计算机的性能，这就是Memory Hierarchy的意义所在。
在和Cache打交道,
是512MB的，
设想有两台计算机,
到；CPU访问一
 硬盘都是100GB的，
一个数据，
有Cache的计算机明显会快很多。
一台有256KB的Cache，
我把和它相邻的数据也都缓存起来，
全国嵌入式人才培训基地
 硬盘快几个数量级，
 虽然多出来256KB的Cache与内存、硬盘的容量相比微不
起始页
一级
一台没有Cache,
高速存储器的容量只能做得很小，却
由于局部性原理,
 CPU很可能马上就会访问到。
，两台计算机的内存都 
第 18 章 x86汇编程序基础
，CPU大部分时间是
下一页
---
## Page 272
读者能看懂基本的汇编程序而不要求会写汇编程序，
样的指令，
要彻底搞清楚C语言的原理，
5.ELF文件
4.寻址方式
3.第二个汇编程序
5. Memory Hierarchy
2.x86的寄存器
第18 章x86汇编程序基础 请点评
1.最简单的汇编程序
目
上一页
5.2.可执行文件
H
目标文件
 要做到心中有数。本章介绍汇编程序的-
 就必须深入到指令一层去理解。你写一行C代码，编译器会生成什么
第18章x86汇编程序基础
全国嵌入式人才培训基地
全国嵌入式人才培训基地
部分ⅡI. C语言本质
起始页
上一级
一些基础知识。汇编不是本书的重点，
H-
一章将在汇编的基础上讨论C语言的原理。
1.最简单的汇编程序
，本书要求
2
下一页
---
## Page 273
然后用链接器（Linker，或Link Editor）1a把目标文件hello.o链接成可执行文件hello：
把这个程序保存成文件hello.s（汇编程序通常以.s作为文件名后缀）
（Assembler）as把汇编程序中的助记符翻译成机器指令，生成目标文件hello.o:
1.最简单的汇编程序 请点评
二
例18.1.最简单的汇编程序
$ ld hello.o -o hello
S
 as hello.s -o hello.o
###
###
movl $4, %ebx 
##
#OUTPUT:
#INPUT:
##
int $0x80
movl
·globl 
.section .text
.section
VARIABLES:
L'$l,
_start
%eax
.data
%eax holds
after running the program
%ebx 
echo $?
none
status
typing
 holds
 # this is the status number we will
##
a program
#
code back to the Linux
echo $?
return.
return
第18章x86汇编程序基础
the
 the system call number
1.最简单的汇编程序
全国嵌入式人才培训基地
 different
 return status 
to
the
 around 
 things to
 and it
for
 kernel
用汇编器
273
---
## Page 274
中第一条被执行的指令。
又比较特殊，
这样一个符号定义时,
这里定义了_start符号，
用.globi声明，就表示这个符号不会被链接器用到。
的入口地址,
个程序的入口，
·globi指示告诉汇编器,
数第一
个变量，
汇编器的处理之后，
.text段保存代码，是只读和可执行的，后面那些指令都属于.text段。
是空的。
保存程序的数据，是可读可写的，
时，
指令所以加个“伪"字。
汇编程序中以.开头的名称并不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊
下面逐行分析这个汇编程序。首先，#号表示单行注释，类似于C语言的//注释。
"main函数和启动例程"详细解释。
所以这段汇编代码相当于在C程序的main函数中return 4;。为什么会相当呢？我们在第2节
可以用特殊变量s?得到上一条命令的退出状态:
现在执行这个程序，
目标文件，
件合并成一个可执行文件，
修改目标文件中的信息，
为什么用汇编器翻译成机器指令了还不行，
，每个段被加载到不同的地址，
一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的。
 其实就是读写某个地址的内存单元，
start:
·globl
.section .text
.section .data 
，但也需要经过链接才能成为可执行文件。
echo 
 所以每个汇编程序都要提供-
_start
所有的符号都被替换成它所代表的地址值。在C语言中我们通过变量名访问一
，它只做了一件事就是退出，
，汇编器在翻译汇编程序时会计算每个数据对象和每条指令的地址，
 对地址做重定位，
_start这个符号要被链接器用到，所以要在目标文件的符号表中标记它是
，在第2节“main函数和启动例程"详细解释。我们这个例子虽然只有一
 符号在汇编程序中代表一个地址，
，相当于C程序的全局变量。本程序中没有定义数据，所以.data段
，操作系统对不同的页面设置不同的读、
在第5.2节“可执行文件"详细解释，
还要有一个链接的步骤呢？链接主要有两个作用，
个
，我们通过函数名调用一个函数，
_start符号并且用.globi声明。如果一个符号没有
退出状态是4，第2节“自定义函数"讲过在Shell中
，可以用在指令中，汇编程序经过
写、执行权限。.data段
 程序被操作系统加载执行
，把它设置为整个程)
 其实就是跳转到该函
由于它不是真正的
二是把多个目标文
当看
274
适
是
---
## Page 275
前两条指令都是为这条指令做准备的，执行这条指令时发生以下动作:
和上一条指令类似，生成一个立即数4并保存到ebx寄存器中。
操作数总是源操作数，第二个操作数总是目标操作数。
符号名区分开。以后我们会看到mov指令还有另外几种形式，但数据传送方向都是一样的，第一个
的，
这是一条数据传送指令，
3.
，称为立即数（lmmediate）。在汇编程序中,
．int指令称为软中断指令,
空间继续执行后面的指令，而_exit系统调用比较特殊，它会终止掉当前进程，而不是返回用
eax和ebx的值是传递给系统调用的两个参数。eax的值是系统调用号，
$0x80的下一条指令，在用户程序看来就像函数调用和返回一样。
断类似，CPU从用户模式切换到特权模式，然后跳转到内核代码中执行异常处理程序。
都是由int$0x80指令引发的，内核需要通过eax判断用户要调哪个系统调用，
以保证系统服务被安全地调用。在调用结束之后，
经
供用户程序使用，
在Linux内核中int$0x8o这种异常称为系统调用（SystemCall）
空间继续执行。
代码路线走，
由异常处理程序进入内核，
序时CPU处于用户模式，不能直接调用内核函数，
movl $4， %ebx 
movl $1, %eax
int $0x80
x86汇编的两种语法：intel语法和AT&T语法 请点评
如[GroudUp]，其它书一般采用intel语法，例如[x86Assembly]
介绍x86汇编的书很多，
考[AssemblyHOWTO].
的方式表示。本书不详细讨论这两种语法之间的区别，读者可以参
和目标操作数的位置互换，
果用intel语法来写，就是mov eax,edx,
法，Windows也使用intel语法，而UNIX平台的汇编器一直使
x86汇编一直存在两种不同的语法，
，而不能由用户程序随心所欲，
，这条指令要求CPU内部产生一个数字1并保存到eax寄存器中。mov的后
，可以用这条指令故意产生一个异常，
 用户程序只能通过寄存器传几个参数，
，UNIX平台的书都采用AT&T语法，例
字长也不是用指令的后缀|表示而是用另外
，表示退出状态。大多数系统调用完成之后会返回用户
，立即数前面要加$，
在intel的官方文档中使用intel语
，想调哪个内核函数就调哪个内核函数，这样可
寄存器名不加%号，
，CPU再切换回用户模式，继续执行int 
，所以需要通过系统调用切换CPU模式
上一章讲过，异常的处理和中
内核提供了很多系统服多
，之后就要按内核设计好
源操作数
，Linux的各种系统调用
因为在执行用户
275
户
调
务
---
## Page 276
解释其原因吗？
习题 请点评
第18章x86汇编程序基础
页
全国嵌入式人才培训基地
起始页
上一级
2.x86的寄存器
下一页
---
## Page 277
在intel的手册中这几个标志位分别称为CF、OF、ZF、SF。ebp和esp用于维护函数调用的栈帧,
标志位，其中包括第3节“整数的加减运算"讲过的进位标志、溢出标志、零标志和负数标志，
2. x86的寄存器 请点评
1.最简单的汇编程序
在第1节“函数调用"详细讨论。
存在edx寄存器中。也就是说，
而除数可以在任意寄存器中,
其中某个寄存器做某种用途，
的，
二页
比如movi指令可以把一个立即数传送到eax中，
页
 通用寄存器对于某些特殊指令来说也不是通用的。
计算结果的商数保存在eax寄存器中（覆盖原来的被除数），余数保
edx、edi、ési。这些寄存器在大多数指令中是可以任意选用
第18章x86汇编程序基础
全国嵌入式人才培训基地
全国嵌入式人才培训基地
2.x86的寄存器
 eip是程序计数器,
起始页
上一级
也可传送到ebx中。但也有一些指令规定只能用
eflags保存着计算过程中产生的
 edx寄存器必须是0,