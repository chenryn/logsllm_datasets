 # ChildEBP RetAddr   
00 00d0e35c 022a7782 dbgeng!KdComConnection::Read 
//从 COM 口读取数据 
01 00d0e37c 022a93f8 dbgeng!KdConnection::ReadAll+0x22 
02 00d0e3a0 022a87ba dbgeng!KdComConnection::ReadPacketLeader+0x38//读导引字节 
03 00d0e3c8 020dd6a8 dbgeng!KdComConnection::ReadPacketContents+0x6a 
04 00d0e400 020ddff3 dbgeng!DbgKdTransport::ReadPacketContents+0x108 
05 00d0e474 020deb29 dbgeng!DbgKdTransport::WaitForPacket+0x133 
06 00d0e4a8 020debf2 dbgeng!DbgKdTransport::SendReceivePacket+0x59 
07 00d0e4d4 020d72df dbgeng!DbgKdTransport::SendReceiveManip+0x42 
08 00d0e548 020f058e dbgeng!ConnLiveKernelTargetInfo::ReadControl+0x7f 
09 00d0e574 0214e3d7 dbgeng!TargetInfo::GetTargetSpecialRegisters+0x3e 
因为与 KD 通信需要花费较多时间，所以 WinDBG 会将某些命令的执行结果保存起
来，如果下次再执行同样的命令时，就不必再从 KD 那里读取。举例来说，当我们连续多
次执行 kv 命令或者 r 命令时，会感觉到后面几次的速度明显加快，因为它们使用了缓存
的数据。为了保证数据的一致性。每次退出命令状态时，WinDBG 会清除缓存的数据。 
《软件调试》补编 
- 66 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
29.8.4  将调试目标中断到调试器 
如果目标系统处于运行状态，那么可以通过中断（Break）命令将其中断到调试器。
其工作过程如下： 
在通过 WinDBG 的界面发出中断命令（菜单或者 Ctrl+Break）后，UI 线程会调用
DebugClient类的SetInterrupt方法，并将第一个参数设置为DEBUG_INTERRUPT_ ACTIVE
（ 0 ）。 这 会 导 致 SetInterrupt 方 法 通 过 全 局 变 量 g_Target 调 用 调 试 目 标 对 象 的
RequestBreakIn 方法。对于内核调试，g_Target 指向的是 ConnLiveKernelTargetInfo 类的实
例，因此这个类的 RequestBreakIn 方法会被调用，这个方法的实现非常简单，只是将对象
的一个成员变量（偏移为 0x1F7）设置为 1。这些操作发生在 UI 线程中。此时调试会话线
程 通 常 是 在 等 待 目 标 系 统 的 调 试 事 件 ， 也 就 是 在 执 行 DbgKdTransport 类 的
ReadPacketContents 方法。这个方法在反复等待目标系统的通信包期间，每次循环时都会
检查目标对象的 0x1F7 成员变量，如果发现其值等于 1，那么就调用 WriteBreakInPacket
方法向目标系统发送中断命令，其过程如清单 29-14 所示。 
清单 29-14  内核调试会话线程向目标系统发送中断命令 
0:001> kn 
 # ChildEBP RetAddr   
//调试会话线程 
00 00d0fd78 020e04c3 dbgeng!KdComConnection::Write 
//写 COM 口 
01 00d0fd98 020de3c2 dbgeng!DbgKdTransport::Write+0x33 //写 Break 命令 
02 00d0fdbc 020dd5ed dbgeng!DbgKdTransport::WriteBreakInPacket+0x32 
03 00d0fddc 020ddff3 dbgeng!DbgKdTransport::ReadPacketContents+0x4d 
04 00d0fe50 02133f5b dbgeng!DbgKdTransport::WaitForPacket+0x133 
05 00d0feec 02133e38 dbgeng!ConnLiveKernelTargetInfo::WaitStateChange+0x8b 
06 00d0ff10 020ceacf dbgeng!ConnLiveKernelTargetInfo::WaitForEvent+0x68 
07 00d0ff34 020cee9e dbgeng!WaitForAnyTarget+0x5f 
08 00d0ff80 020cf110 dbgeng!RawWaitForEvent+0x2ae 
//等待调试事件 
09 00d0ff98 0102aadf dbgeng!DebugClient::WaitForEvent+0xb0 
0a 00d0ffb4 7c80b6a3 WinDBG!EngineLoop+0x13f 
//调试会话循环 
0b 00d0ffec 00000000 kernel32!BaseThreadStart+0x37 
如 18 章所介绍的，目标系统在每次更新系统时间（KeUpdateSystemTime）时会调用
内核调试引擎的 KdPollBreakIn 函数，检查是否有中断命令，如果有，则准备中断到内核
调试器。 
29.8.5  本地内核调试 
WinDBG 将 本 地 内 核 调 试 看 作 是 双 机 内 核 调 试 的 特 例 ， 调 试 引 擎 中 的
LocalLiveKernelTargetInfo 类用来描述本地内核目标。因此当建立本地内核调试会话时，
LiveKernelInitialize 方法创建的是 LocalLiveKernelTargetInfo 类的实例。 
因为调试器与调试目标在同一个系统中，所以本地内核调试的通信过程比双机调试简
单得多。事实上，调试器就是通过 NtSystemDebugControl 内核服务来与调试目标进行通信
的。清单 29-15 显示了 WinDBG 的调试会话线程执行显示内存命令的过程。 
清单 29-15  本地内核调试时执行内存显示命令的过程 
0:002> kn 
 # ChildEBP RetAddr   
00 00e0e128 0222395f ntdll!ZwSystemDebugControl+0xa 
//调用内核服务 
01 00e0e168 020d821f dbgeng!LocalLiveKernelTargetInfo::DebugControl+0xaf 
02 00e0e1a8 0217a9b2 dbgeng!LocalLiveKernelTargetInfo::ReadVirtual+0xbf 
03 00e0e470 0217ae72 dbgeng!DumpValues::Dump+0x552 
04 00e0e48c 0217d26d dbgeng!DumpValues::ParseAndDump+0x72 //解析命令 
05 00e0e900 02187883 dbgeng!ParseDumpCommand+0xa0d 
//内存显示命令的入口 
06 00e0e9d8 021889a9 dbgeng!ProcessCommands+0x7b3 
//分发命令 
07 00e0ea1c 020cbec9 dbgeng!ProcessCommandsAndCatch+0x49  
《软件调试》补编 
- 67 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
08 00e0eeb4 020cc12a dbgeng!Execute+0x2b9 
09 00e0eee4 01028553 dbgeng!DebugClient::ExecuteWide+0x6a //执行命令的接口函数 
0a 00e0ef8c 01028a43 WinDBG!ProcessCommand+0x143 
0b 00e0ffa0 0102ad06 WinDBG!ProcessEngineCommands+0xa3 
0c 00e0ffb4 7c80b6a3 WinDBG!EngineLoop+0x366 
//调试会话循环 
0d 00e0ffec 00000000 kernel32!BaseThreadStart+0x37  
可以看到，03 号到 0d 号栈帧与双机内核调试是一样的。栈帧 02 是 Dump 方法调用
的 LocalLiveKernelTargetInfo 类的 ReadVirtual 方法，后者再调用 DebugControl 方法，这里
仍然使用了 C++的多态性。DebugControl 方法只是对系统服务 ZwSystemDebug- Control
的封装。ZwSystemDebugControl 通过系统调用机制调用内核中的 NtSystemDebugControl
方法。 
29.9  远程用户态调试 
WinDBG 工具包提供了多种方式进行远程调试，本节将讨论通过进程服务器（Process 
Server）来进行远程用户态调试的基本原理和实现方法。 
29.9.1  基本模型 
图 29-20 显示了通过进程服务器调试位于另一个系统中的用户态程序时的基本模型。
左侧的系统是被调试程序所运行的系统，称为目标系统。因为它是调试服务的提供者，所
以目标系统有时也被称为服务器系统。相对而言，右侧运行调试器的系统称为客户系统
（Client）。 
图 29-20  通过进程服务器（DbgSrv）进行远程用户态调试 
目标系统需要运行进程服务器程序 DbgSrv.exe，它位于 WinDBG 的程序目录中。可
以在目标系统中安装完整的 WinDBG 工具包，也可以直接将 WinDBG 的程序目录复制到
目标系统。 
目标系统与客户系统之间的通信方式可以有以下几种：命名管道（NPIPE）、TCP、
COM 口、安全的管道（Secure Pipe，简称 SPIPE）和 SSL（Secure Sockets Layer）。其中
SPIPE 和 SSL 需要两个系统中的操作系统都至少是 Windows 2000。 
29.9.2  进程服务器 
在目标系统中，启动一个命令行窗口，切换到 DbgSrv.exe 文件所在的目录，然后键入
如下命令： 
C:\WinDBG>dbgsrv -t tcp:port=1022 -c notepad.exe 
这条命令的含义是启动进程服务器，让其使用 TCP 协议监听 1025 号端口，同时创建
《软件调试》补编 
- 68 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
notepad.exe 进程（要调试的程序）。 
此时在目标系统中运行一个用于分析 DbgSrv 的调试器，将其附加到 DbgSrv 进程，
然后将 DbgSrv 中断到调试器。可以发现除了用于中断到调试器的 2 号线程外，DbgSrv 还
有两个线程。0 号线程是 UI 线程，也是这个进程的初始线程，1 号线程是监听调试器连接
请求的监听线程。 
事实上，DbgSrv 启动后，它的主函数（main）在分析命令行参数后便调用 DebugClient
类的 StartProcessServerWide 方法启动进程服务器，这个方法的原型如下： 
HRESULT IDebugClient5::StartProcessServerWide( 
    IN ULONG  Flags, IN PCWSTR  Options, IN PVOID  Reserved); 
其中 Flags 参 数用 于指 定调 试目 标的 类型 ， 必 须为 DEBUG_CLASS_USER_ 
WINDOWS(2)，Options 用来指定与调试器的连接字符串，它的值就是命令行中-t 开关后
的参数，观察其值为： 
0:000> du 007a1118  
007a1118  "tcp:port=1025" 
StartProcessServerWide
函 数 会 调 用
DbgRpcCreateServer ， 后 者 调 用
DbgRpcInitializeTransport 创建传输层对象实例，因为我们指定的是 TCP 连接，所以
创建的是 DbgRpcTcpTransport 类的实例。而后 DbgRpcCreateServer 函数调用新创建
的传输层对象的 CreateServer 方法。CreateServer 再调用 CreateServer- Socket 方
法，后者调用操作系统的 Socket API WSASocket 创建通信套接字。在创建好通信套接字
之后，DbgRpcCreateServer 方法调用 CreateThread API 来创建一个新的线程，线程的函
数为 dbgeng!DbgRpcServerThread。这个线程用来监听来自客户机器的连接请求。 
StartProcessServerWide 方法返回后，DbgSrv 的主函数根据-c 参数指定的命令行
来创建新的进程，但是并没有与其建立调试关系。在以上任务完成后，0 号线程的任务基
本完成，调用 WaitForProcessServerEnd 方法等待结束命令。 
29.9.3  连接进程服务器 
在客户系统中，使用如下命令行启动 WinDBG： 
c:\WinDBG>WinDBG -premote tcp:server=,port=1022 
然后选择 File 菜单的 Attach to a process…命令，这时目标系统的 DbgSrv 会命中我们预先
设置的 CreateThread 断点。这是因为，WinDBG 从命令行参数中知道是远程调试，所以需
要从远程获得供调试的进程列表，于是开始与目标系统的进程服务器建立连接。在目标机
器上，DbgSrv 的监听线程接收到连接请求后，会调用 CreateThread API 创建一个新的工作
线程来与客户机上的 WinDBG 通信，我们称其为服务线程。这个新线程的入口函数为
DBGENG 模块中的 DbgRpcClientThread 函数。处理完一个连接后，监听线程再次调用
AcceptConnection 方法等待新的连接请求。当再有新的连接请求（客户）时，DbgSrv
的监听线程会再创建一个新的服务线程。也就是说，DbgSrv 会为每个客户创建一个不同
的服务线程。因此，一个 DbgSrv 进程可以为多个 WinDBG 服务。 
29.9.4  服务循环 
WinDBG 使用 RPC（Remote Procedure Call）机制来调用服务器进程中的调试器引擎
函数。下面我们简要讨论其过程。服务线程启动后，便进入一个工作循环等待来自客户端
的数据，如清单 29-16 所示。 
《软件调试》补编 
- 69 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
清单 29-16  DbgSrv 的服务线程在等待客户数据 
0:002> kn 
 # ChildEBP RetAddr   
00 00a7fdd8 7c90e9c0 ntdll!KiFastSystemCallRet 
//调用系统服务 
01 00a7fddc 7c8025cb ntdll!ZwWaitForSingleObject+0xc 
//残根函数 
02 00a7fe40 7c802532 kernel32!WaitForSingleObjectEx+0xa8  
03 00a7fe54 7c831568 kernel32!WaitForSingleObject+0x12 
//等待同步对象 
04 00a7fe68 71a6b083 kernel32!GetOverlappedResult+0x30 
05 00a7feac 71ac0d59 mswsock!WSPGetOverlappedResult+0x62  
06 00a7fed8 0228ac57 WS2_32!WSAGetOverlappedResult+0x56 
07 00a7ff0c 02286a65 dbgeng!DbgRpcTcpTransport::Read+0xa7//传输层的读数据方法 
08 00a7ff60 022882d8 dbgeng!DbgRpcReceiveCalls+0x55 
//接收远程调用 
09 00a7ffb4 7c80b6a3 dbgeng!DbgRpcClientThread+0xa8 
0a 00a7ffec 00000000 kernel32!BaseThreadStart+0x37 
//线程的启动函数 
当服务线程收到一个完整的 RPC 数据包后，它先调用 DbgRpcGetStub 函数读取要调
用的函数指针，这个函数指针通常是调试器引擎中的 SFN_IXXX 函数。在确认读取到的函
数指针不为空后，服务线程便就调用这个函数，然后再把函数的执行结果发送给客户端的
WinDBG。完成一次服务后，服务线程再调用 DbgRpcReceiveCalls 来等待新的调用，如
此循环直到结束。 
29.9.5  建立调试会话 
当我们在 WinDBG 中选择 Notepad 进程并按确定后，和调试本地的应用程序一样，
WinDBG 会创建一个新的调试会话线程并调用 StartSession 函数，其详细过程如清单 29-17
所示。 
清单 29-17  附加到远程的应用程序 
0:001> kn 
 # ChildEBP RetAddr   
00 00f0fad8 7c90e9c0 ntdll!KiFastSystemCallRet 
//系统调用 
01 00f0fadc 7c8025cb ntdll!ZwWaitForSingleObject+0xc 
02 00f0fb40 7c802532 kernel32!WaitForSingleObjectEx+0xa8 
03 00f0fb54 7c831568 kernel32!WaitForSingleObject+0x12 
//等待同步对象 
04 00f0fb68 71a6b083 kernel32!GetOverlappedResult+0x30 
05 00f0fbac 71ac0d59 mswsock!WSPGetOverlappedResult+0x62 
06 00f0fbd8 0228ac57 WS2_32!WSAGetOverlappedResult+0x56 
07 00f0fc0c 02286a65 dbgeng!DbgRpcTcpTransport::Read+0xa7 //传输层的读数据方法 
08 00f0fc60 02286f8e dbgeng!DbgRpcReceiveCalls+0x55 
09 00f0fc80 0229e83d dbgeng!DbgRpcConnection::SendReceive+0x10e //发送并接收应答 
0a 00f0fccc 020f3a31 dbgeng!ProxyIUserDebugServicesN::AttachProcess+0x11d 
0b 00f0fcfc 020c1344 dbgeng!LiveUserTargetInfo::StartAttachProcess+0xd1 
0c 00f0fd40 0102a385 dbgeng!DebugClient::CreateProcessAndAttach2Wide+0x104 
0d 00f0ffa4 0102a9bb WinDBG!StartSession+0x445 
//开始调试会话 
0e 00f0ffb4 7c80b6a3 WinDBG!EngineLoop+0x1b 
//调试会话循环 
0f 00f0ffec 00000000 kernel32!BaseThreadStart+0x37 
在上面的清单中，从栈帧#0b 到#0f 与调试本地对的应用程序是完全一样的。差异是
从 栈 帧 #0a 开 始 的 ， 在 调 试 本 地 的 应 用 程 序 时 ， LiveUserTargetInfo 用 的 是
LiveUserDebugServices 类，而这里 LiveUserTargetInfo 用的是 ProxyIUserDebugServicesN
类。ProxyIUserDebugServicesN 类与 LiveUserDebugServices 具有相同的接口，所以
LiveUserTargetInfo 类可以不关心二者的差异。 
ProxyIUserDebugServicesN 类将 AttachProcess 调用通过 DbgRpcConnection 发送给远
程的进程服务器，然后等待它的回复（栈帧 0～8）。 
清单 29-18 显示的是目标机器上的服务线程收到调用 AttachProcess 函数的请求后，在
DbgSrv 进程中执行这个请求的过程。 
清单 29-18  服务线程执行附加动作时的函数调用过程 
《软件调试》补编 
- 70 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
0:002> kn 
 # ChildEBP RetAddr   
00 00a7fe9c 0229a146 ntdll!NtDebugActiveProcess 
//系统调用 
01 00a7feb8 0229a2b0 dbgeng!LiveUserDebugServices::CreateDebugActiveProcess… 
02 00a7fed4 022a47ee dbgeng!LiveUserDebugServices::AttachProcess+0xb0 
03 00a7ff04 02286c27 dbgeng!SFN_IUserDebugServicesN_AttachProcess+0xbe 
04 00a7ff60 022882d8 dbgeng!DbgRpcReceiveCalls+0x217 
//接收调用 
05 00a7ffb4 7c80b6a3 dbgeng!DbgRpcClientThread+0xa8 
//服务线程 
06 00a7ffec 00000000 kernel32!BaseThreadStart+0x37 