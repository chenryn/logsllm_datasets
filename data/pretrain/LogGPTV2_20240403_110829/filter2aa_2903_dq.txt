Windows是一个庞大而且复杂的操作系统，Vista的源代码行数约为
5000万行，NT 3.1的也有560万行。Vista安装后在磁盘上所占的空间约
为6GB，其中内核态核心模块NTOSKRNL.EXE的大小为3.4MB，
NTDLL.DLL为1.1MB。表15-1列出了Windows几个主要版本的
NTOSKRNL.EXE和NTDLL.DLL文件的典型大小。
表15-1 Windows的内核和NTDLL文件的大小（单位：字节）
文 件 名
NT 3.51
Win2K
XP SP1
XP SP2
Vista RTM
NTOSKRNL.EXE
804 864
1 640 976
2 042 240
2 180 096
3 467 880
NTDLL.DLL
307 088
481 040
668 672
708 096
1 162 656
从运行态来看，在一个典型的Windows系统中，大多数时候都有几
十个进程（数百个线程）在运行。以作者写作此内容时所使用的
Windows XP SP2系统为例，系统中共有82个进程，783个线程在工作。
对于Windows这样复杂的系统，可调试性对其是极其重要的。事实上，
好的可调试性是Windows系统成功的一个关键技术因素。如果没有这个
因素，这个系统也许就会因为太多的Showstopper而永远不能发布。本
节将从Windows操作系统中选取一些体现可调试性的特征进行分析，以
学习其中所蕴含的设计思想，并加深读者对软件可调试性的理解。
15.5.1 健康性检查和BSOD
在很多Windows内核函数中，存在类似如下的代码。
if(…)
    BugCheckEx(…);
这样的代码通常称为健康性检查，即为了保证系统健全性而作的额
外检查。如果检查失败，则以蓝屏的形式报告出来。
健康性检查与断言（assert）不同，断言只存在于Checked版本中，
而健康性检查既存在于Checked版本中，又存在于Free版本中。事实
上，Checked和Free这两种称呼就是在开发Windows NT时，为了将包含
健康性检查的版本与不包含健康性检查的Release版本区分开来而引入
的。在此之前，通常只使用Debug和Release两种定义方式。表15-2列出
了这4种版本定义方式的主要差异。
表15-2 4种版本定义方式的比较
版  本
Debug
Checked
Free
Release
编译器优化（compiler optimization）
OFF
ON
ON
ON
调试追踪（debug trace）
ON
ON
OFF
OFF
断言（assertion）
ON
ON
OFF
OFF
健康性检查
ON
ON
ON
OFF
因为开发NT 3.1时，测试团队主要测试的是Checked版本和Free版
本，并没有对Debug和Release版本做很多测试，所以NT 3.1发布时没有
使用Release版本[3]。也就是说，健康性检查在正式发布的产品版本中依
然存在。这种做法一直延续到今天，而且这种定义方式也应用到驱动程
序开发中。从可调试性的角度来看，健康性检查和蓝屏机制有利于及时
发现错误和异常情况，并让错误“跳出来”。
15.5.2 可控制性
Windows操作系统中几乎随处都可以看到高灵活性和可控性的设
计。比如，Windows的启动配置文件（BOOT.INI）支持40多个选项来定
义系统的工作参数。另外，Windows的很多行为都可以通过修改注册表
中的键值来控制。可配置能力不但提高了Windows系统的灵活性，而且
有利于调试和维护。以下是使用配置选项来帮助调试的几个例子。
/BREAK，这个选项会告诉HAL在初始化时等待内核调试会话建
立，以便可以使更多的初始化代码可以被调试，详见本书后续分
册。
/KERNEL和/HAL，可以利用这两个选项来指定要使用的内核文件
和HAL文件。比如可以使用这种方法来将内核和HAL文件切换为
Checked版本。
/MAXMEM，指定Windows要使用的内存，利用这个选项可以模拟
只有在小内存系统才出现的问题。
/DEBU和/DEBUGPORT，分别用于启动和配置内核调试引擎。
/CRASHDEBUG，与/DEBUG在启动期间就启动内核调试不同，这
个选项告诉Windows，当系统出现蓝屏时再启动内核调试引擎，这
与应用程序中的JIT调试很类似。
/NOPAE，强制加载不包含PAE（Physical Address Extension）支持
的内核文件。这对于在支持PAE的硬件上调试非PAE情况下发生的
问题是很有帮助的。
/NUMPROC，指定要使用的CPU数目，使用这个选项可以在多CPU
系统上调试单CPU情况下的问题。
/YEAR，强制系统使用指定的年份，忽略计算机系统的实际年份，
该选项是为了帮助调试“2000年问题”而设计的。
使用注册表来帮助调试的例子也有很多，比如可以在Image File
Execution Options下为一个程序设置执行选项，让系统加载这个程序时
先启动调试器。
15.5.3 公开的符号文件
调试符号对于软件调试具有极其重要意义，有了调试符号可以大大
降低跟踪执行的难度，加快发现问题根源的速度。微软的调试符号服务
器为Windows操作系统的几乎所有程序文件提供了符号文件，并且包含
了公开发布的大多数版本。从微软的网站也可以根据操作系统版本下载
其对应的符号文件包。
公开的符号文件不但为调试和学习Windows操作系统提供了帮助，
而且为开发和调试Windows驱动程序和应用程序提供了支持。
15.5.4 WER
Windows错误报告（Windows Error Reporting，WER）机制可以自
动收集应用程序或系统崩溃的信息，生成报告，并在征求用户同意后发
送到用于错误分析的服务器（详见本书后续分卷）。自动报告是一种有
效的辅助调试手段，有利于降低调试成本，尤其对于产品期调试有着极
高的价值。
15.5.5 ETW和日志
ETW（Event Trace for Windows）机制可以高效地记录操作系统、
驱动程序，或者应用程序的事件（详见本书后续分卷）。使用ETW可以
有效地提高软件的可追溯性。
Windows操作系统主要有两种日志机制。一种是基于日志服务的，
调用ReportEvent API来写日志记录。另一种是Windows Vista引入的公用
日志文件系统（Common Log File System，CLFS）。CLFS的核心功能
是由一个名为CLFS.SYS的内核模块所提供的。CLFS.SYS输出了一系列
以Clfs开头的函数和结构，如ClfsCreateLogFile等，内核模式的驱动程序
可以直接调用这些函数。用户态的程序可以调用Clfsw32.dll所输出的用
户态API。
15.5.6 性能计数器
Windows操作系统内置了性能监视（performance monitor）机制，
通过性能计数器（performance counter）来记录软件的内部状态。
Windows预定义了大量反映操作系统内核和系统对象状态的计数器，软
件开发商也可以定义并登记其他计数器。
使用perfmon工具可以以图形化的方式观察性能计数器的值。
Windows XP引入了一个名为typeperf的命令行工具来观察性能计数器。
例如，以下是使用typeperf命令显示可用内存数量时的执行结果。
C:\> typeperf "Memory\Available Bytes" -si 00:05    //每5s更新一次
"(PDH-CSV 4.0)","\\AdvDbg002\Memory\Available Bytes"
"05/07/2007 17:08:36.375","1213886464.000000"
"05/07/2007 17:08:41.375","1211101184.000000"
…
性能计数器为系统管理员和计算机用户了解系统运行情况提供了一
种简单而有效的方式，对于调试系统中与性能有关的软硬件问题有着重
要作用。
15.5.7 内置的内核调试引擎
Windows内核调试引擎内置在每个Windows系统的内核之中， 主要
功能包含在NTOSKRNL.EXE中（详见本书后续分卷）。这意味着，内
核调试支持始终存在于Windows系统中，如果要对一个发生故障的系统
进行内核调试，不需要重新安装特别的版本或其他文件，这为调试
Windows内核和内核态的其他程序提供了很大的便利。
15.5.8 手动触发崩溃
Windows还有一个不太被注意的调试支持，即在注册表中设置了
CrashOnCtrlScroll = 1并重启后（详见本书后续分卷），按住标准键盘右
侧的Ctrl键后再按ScrollLock键，系统会产生一个特别的蓝屏崩溃，其停
止码为MANUALLY_INITIATED_CRASH（0xE2）。因为蓝屏可以触发
崩溃时才激活的内核调试（/CRASHDEBUG）和内核转储，所以这个支
持对调试某些随机的系统僵死很有用，比如突然没有响应或在开机关机
过程中发生的无限等待。
本节介绍了Windows操作系统内置的一些调试支持，类似的例子还
有很多。通过这些例子，读者可以认识到支持可调试性的意义，以及带
来的好处，同时也应该思考如何在自己的软件产品中加入类似的机制。
15.6 与安全、商业秘密和性能的关系
任何事物都有两面性，我们不得不承认实现可调试性本身也是有代
价的。特别应该注意以下几个方面的影响：安全、性能和商业秘密。
15.6.1 可调试性与安全性
高可调试性追求对软件的全方位掌控，可以了解其状态的任何细
节，并控制它的行为。这对调试来说是有利的，但是如果这些功能或机
制被恶意软件或入侵的黑客所使用，那么导致的后果可能很严重。这就
好比武器被别人盗用了，武器越强大，导致的危害可能越大。
考虑到这一点，当设计可调试性机制时，应该配以必要的安全防范
措施。例如，可以设计登录和验证机制，根据用户的角色决定他可以使
用的功能。这就好像网站的管理和维护功能只对网站的管理员开放。
15.6.2 可调试性与商业秘密
实现可调试性时也要注意防止泄漏商业和技术秘密。如果日志或调
试信息中包含重要的算法和资料，那么在存储和输出信息前，应该先将
信息加密，或者借助ETW技术使用二进制格式来输出日志信息，并控制
好格式文件（TMF文件）。但是这种保密只会增加阅读的难度，攻击者
还有可能分析出有效的数据。
因为符号文件包含了软件的很多细节，所以应该注意合理保护PDB
文件，尤其是包含全部调试信息的私有符号文件。对于合作伙伴或客户
通常只提供剥离私有符号后的公开符号文件。使用/PDBSTRIPPED链接
选项可以产生公开符号文件。
15.6.3 可调试性与性能
可调试性对性能的影响主要体现在两个方面，从空间角度来看，在
程序中支持可调试性必然会增加可执行文件的大小，生成日志等信息会
占用一定的磁盘空间。从时间角度来看，用于提高可调试性的代码可能
会占用少量的CPU时间。因此当设计可调试性机制时，应该注意以下两
点。
第一，将调试机制设计成可开关的，最好是可以动态开关的。于
是，当不需要调试时，调试机制的影响非常小；当需要调试时，又可以
立刻开启。
第二，防止调试机制被错用和滥用，调试机制的目的是辅助调试，
不应该用于其他目的。应该避免过量使用调试机制，否则不但会影响性
能，而且对调试本身也可能产生副作用。举例来说，如果频繁输出大量
的重复信息，会使调试者眼花缭乱，难以找到真正有用的信息。
相对于提高可调试性所带来的好处，它的副作用还是可以接受的，
而且只要处理得当，可以把这种影响降得很低。
15.7 本章小结