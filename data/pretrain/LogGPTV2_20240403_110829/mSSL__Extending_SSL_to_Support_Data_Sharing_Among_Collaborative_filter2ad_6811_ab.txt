client can then request the retransmission of block b.
With this solution, a client does not have to download
all the hash values beforehand as in the superblock-based
solution, nor does it need to perform expensive encryption
or decryption operations. However, this solution can lead to
a high trafﬁc overhead. For a data object with 2m blocks,
every block’s authentication path will have m hash values.
Assuming each hash value is 16 bytes, the total amount of
overhead trafﬁc will then be 16m ∗ 2m bytes, 16m
|b| of the
data trafﬁc (|b| is the number of bytes of a block).
3.4 mSSL’s On-demand Data Integrity Solution
via Integrity Path
(cid:1)) where b
mSSL’s integrity solution optimizes both the on-demand
requests of integrity veriﬁcation information, and the ver-
iﬁcation procedure. In fact, when a client needs to obtain
an authentication path A(b) of a newly downloaded block
b, it may not need to download every hash value h∈A(b).
(cid:1) is an-
For a given hash value h∈A(b), if h∈A(b
other block and has been veriﬁed earlier, h must be already
available locally. For example, in Figure 2, the authentica-
tion path of block b1 and b2 are A1 = (cid:2)H2, H34, H58(cid:3) and
A2 = (cid:2)H1, H34, H58(cid:3), respectively. If a client received b1
ﬁrst and then veriﬁed its integrity by obtaining A1, it does
not need to download H34 and H58 again when verifying
b2. Moreover, certain hash values will have to be calculated
during the local block integrity veriﬁcation process, and can
become available for veriﬁcation along other authentication
paths. Using the same example, when verifying b1’s in-
tegrity, H1 (as well as H12 and H14) will be calculated.
Therefore, when verifying b2 along A2, there is no need to
download H1 either.
In contrast to the authentication path concept, we now in-
troduce a concept called mSSL integrity path for optimized
block integrity veriﬁcation. A block’s mSSL integrity path
consists of all those hash values from this block’s authenti-
cation path that are not locally available. To determine what
are these hash values, we introduce Theorem 1 below:
Theorem 1 If h is locally available at a recipient client r,
then h’s uncle uncle(h) is also locally available.
m
, H
We omit the proof of Theorem 1 to save space. Now,
suppose a block b’s authentication path A(b) is A(b) =
m−1, ..., H 1(cid:3), and denote b’s mSSL integrity path
(cid:2)H
mip(b). If H
l is not, then
, · · · , H 1 are
l
according to Theorem 1, we know H
l are.
m
all locally available, and none of H
l−1 is locally available, but H
l−1, H
, H
m−1, · · · , H
m
Thus, mip(b) = (cid:2)H
l(cid:3), with a total of
|mip(b)| = m − l + 1 hash values.
|mip(b)| is also the
number of levels needed to be downloaded in order to have
a complete authentication path.
m−1, · · · , H
, H
The integrity path concept greatly simpliﬁes the on-
demand request process. When a client receives block b
from a server or a provider, it can determine mip(b) ﬁrst and
then send a request for mip(b) to the server or the provider.
Notice that it is sufﬁcient for the request to just contain the
value of |mip(b)| since the provider or the server can easily
determine what mip(b) is. Figure 3 describes this proce-
dure, where a client maintains an object O’s Merkle hash
tree, tc(O), that only keeps locally available hash values.
l−1) to calculate all of H
Once the client receives mip(b), it could further derive
A(b) and apply the procedure from Section 3.3 to verify the
integrity of block b. However, mSSL also optimizes this
l−1 was locally available, an
veriﬁcation process. Since H
l−1 must have
earlier integrity veriﬁcation that involves H
l−1’s ancestors (in-
used sibling(H
l−1) is
cluding the root), therefore an authentic sibling(H
also locally available (sibling(H
l’s parent).
As a result, the veriﬁcation of block b actually only needs to
l−1) with the current
compare a newly calculated sibling(H
l−1) to decide if block b is integral; the additional
sibling(H
calculations from level l − 1 up would be repeated calcula-
tions.
l−1) is also H
S
, p
3
Obtain    (  )
M O
2
4
5
Request
O
Signed root of     (   )
M  O
b     , mip(b    )
first
first
. . . . . .
8 Request block    ,
ib
using |             |
mip(b )
i
9
b , mip(b )
i
i
c
1
Initialize
t O   (   )
c
integrity
6 Verify block
ct O(   (  ) updated)
7
Determine
mip(b )
|            |
i
Verify block
integrity
10
ct O(   (  ) updated)
Figure 3. mSSL’s integrity solution. Except for
the very ﬁrst block bf irst, the client c requests
on-demand the integrity path of every block.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:14:11 UTC from IEEE Xplore.  Restrictions apply. 
4 Proof of Service
4.1 Overview
An obstacle to realizing the beneﬁts of data sharing
among peer clients is whether clients have incentives to
share data. To address this, we assume a simple but generic
economy model: (1) A provider will receive credits for as-
sisting its server. (2) A recipient will pay less for the data
it receives from providers since it does not directly utilize
as much of its server’s resources. (3) By ofﬂoading some
tasks to its providers, a server will serve more clients over-
all and thus make more proﬁt, even though it charges each
individual client less.
However, in order to harden such an economy model,
it is critical that a trustworthy, effective proof-of-service
mechanism must be designed. With proof of service, a
client can present to its server a proof of its service to others,
a server can verify whether or not a client has indeed served
other clients as it claims, and a recipient cannot cheat or be
cheated about its reception of data from others.
We describe our approach to providing proofs of ser-
vice below. This approach must ensure trustworthiness of
proofs. Furthermore, given that a large number of clients of
a single server may be involved, the approach must be scal-
able; in particular, the server should not be overloaded and
the trafﬁc and storage overhead should not be high.
Our basic solution is to assume that every data object
is divided into multiple blocks and enforce an interlocking
block-by-block veriﬁcation mechanism between every pair
of provider and recipient. For every block that a provider
has sent to a recipient, the recipient will verify the integrity
of the block and sends back a non-repudiable acknowledg-
ment to the provider. The provider will verify the acknowl-
edgment before providing the next block. Those veriﬁed
acknowledgments can then be used as the proof of the ser-
vice that the provider has offered to other clients.
However, problems may arise in this basic solution.
Clearly, if a provider has to present a separate acknowl-
edgment as the proof for every block it served, there will
be a proof explosion with large ﬁles. Also, after receiving a
block from a provider, a recipient may run away without ac-
knowledging the receipt of this block, leaving the provider
unable to have a proof for serving the block. Finally, the
server can be overloaded if clients require the server to com-
pose or verify acknowledgments frequently.
We address these problems. Figure 4 shows the proof-of-
service operations between a provider p and a recipient r.
Basically, in steps 1 and 2, p and r will go through a hand-
shake, including exchanging public key certiﬁcates. Then
after r requests block bi (step 3), p will send block bi en-
crypted using a secret block key to r in step 4. In step 5, r
acknowledges its receipts of the encrypted bi and, if needed,
requests another block. p will verify the acknowledgment in
step 6; if veriﬁed, in step 7 it sends the block key in its pro-
tected form to r, which can then obtain the block key, use
it to decrypt the encrypted block, and verify the integrity of
the block.
p
6 verify
}ib{(ack
)
k r
i
1
2
3
4
5
ticket, cert(PUB  )
  r
cert(PUB
      )
      p
...
... , req(    )
 i b
k r
}
i {
b
i
(ack k r
}ib{
),
i
r
req
i+1b(
)
7
send(    )
 r
 k
  ,
 i
k
r
i+1
{
b
i+1}
...
}i
8
k r
i b{
decrypt
ib
to obtain     ,
ib
verify     ’s
integrity
Figure 4. mSSL’s proof-of-service solution
4.2 Step-wise Explanations and Justiﬁcations
In the following, we explain and justify our steps above.
Steps 1 and 2 show the exchange of public key certiﬁ-
cates between p and r. We ﬁrst make sure that every client
has a certiﬁed public key. This is important because clients
in the hybrid peer-to-peer paradigm are often ordinary users
and do not have certiﬁed public keys. Noticing that while
running the SSL protocol, the server itself has a certiﬁcate
for its own public key, we use the server as a public key CA
(certiﬁcate authority) to certify the public keys of its own
clients. A client needs to generate beforehand a key pair by
itself using a public key generation algorithm, then send a
certiﬁcate request to the server. The server in turn will gen-
erate a certiﬁcate that is signed with the server’s private key
and send it back to the client. As a result, every client can
have its own public key certiﬁed by the server, and every
client is also able to verify the certiﬁcate of its peers.
As shown in step 4, a secret block key is also used for
encrypting a block. When the provider sends the ith block
bi from a data object oid to a recipient rid, it will generate
a block key k
r
i as:
r
i = f (pid, rid, oid, i, kp)
k
(1)
where f is a one-way hash function and kp is the secret key
shared between the provider and the server. Note the server
can also apply this formula to calculate the block key.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:14:11 UTC from IEEE Xplore.  Restrictions apply. 
For acknowledging an encrypted block k
i {bi}, in step 5
r
the recipient forms the acknowledgment ack(k
i {bi}):
r
P RVr{pid, rid, oid, sack, timestamp, d(k
r
i {bi})}
(2)
where P RVr is the private key of r for signing the acknowl-
edgment (so that r cannot deny it later), timestamp records
i {bi}) is the di-
when the acknowledgment is issued, d(k
r
gest of the encrypted block using a one-way hash function.
Furthermore, the sack ﬁeld in acknowledgments solves the
proof explosion problem.
It is in a format similar to the
SACK options for the TCP protocol [14], and can express
all the blocks that r has received from p, instead of just the
most recent one. For example, it can be [0 − 56, 58 − 99] to
conﬁrm the reception of the ﬁrst 100 blocks of a data object
except for block 57.
In step 6, p will verify the acknowledgment to decide
whether or not to provide the block key to the recipient in
i {bi}) so
step 7. This includes verifying the digest ﬁeld d(k
r
that when p presents S this acknowledgment as the proof
of its service, S can verify whether r received the correctly
encrypted last block, i.e., correct block bi encrypted using
r
i . Note that the server can use Equation
correct block key k
r
i .
(1) to calculate k
In step 7, send(k
i ) is the delivery of the block key in a
r
protected form:
P RVp{pid, rid, oid, i, P U Br{k
r
i }}
(3)
where P RVp is p’s private key, P U Br is r’s public key,
and obviously r—and only r—can use P U Bp (p’s public
r
i . Also, if r cannot
key) and its own private key to obtain k
i {bi} , it can forward the protected block key to S
r
decrypt k
so that S can verify if p sent a bad block key.
In case p did not or could not provide a block key at all
(i.e. no step 7 happening), r can retrieve it by asking S to
apply Equation (1) to calculate the block key. When doing
so, r must send S an acknowledgment as in Equation (2)
so that S knows r has indeed received a correctly encrypted
block from p. Also, the server expects that there is only
one such query for each recipient-provider pair, since the
occurrence of this query means that after this query r would
decide that p should not be relied upon any more.
Finally, in step 8, after the recipient receives the block
i {bi} (received in step 4) to obtain bi.
r
key, it can decrypt k
Moreover, it can verify the integrity of bi. Only if bi is
integral will the recipient continue with the provider for the
next block. In case bi appears to be corrupted, r knows that
i {bi}) to S as a correct proof of its
p cannot present ack(k
r
service—S knows the correct bi and k
r
i .
4.3 Performance and Scalability Considerations