explicitly do not protect against client-side XSS vulnerabil-
ities, also called DOM-based XSS. Client-side XSS vulner-
abilities occur when untrusted input is interpreted as Java-
Script by the client-side JavaScript code using methods such
as eval, document.write, or innerHTML. The root cause of
these vulnerabilities is in the JavaScript code.
In this paper, we focus solely on separating inline Java-
Script code (that is, JavaScript in between ). While there are other vectors where JavaScript
can be executed, such as JavaScript code in HTML at-
tributes (event handlers such as onclick) and inline Cascad-
ing Style Sheet (CSS) styles [16], the techniques described
here can be extended to approximate and rewrite the HTML
attributes and inline CSS.
Unfortunately, code and data separation in an HTML
page is not a panacea for XSS vulnerabilities.
In modern
web applications, the inline JavaScript code is sometimes
dynamically generated by the server-side code. A common
scenario is to use the dynamic JavaScript code to pass data
from the server-side code to the client-side code. There may
be XSS vulnerabilities, even if code and data are properly
separated, if the data embedded in the JavaScript code is not
properly sanitized. deDacota provides a partial solution to
the problem of dynamic JavaScript (see Section 4.5).
4. DESIGN
Our goal is to statically transform a given web application
so that the new version preserves the application semantics
but outputs web pages where all the inline JavaScript code
is moved to external JavaScript ﬁles. These external ﬁles
will be the only JavaScript that the browser will execute,
based on a Content Security Policy.
There are three high-level steps to our approach. For each
web page in the web application: (1) we statically determine
a conservative approximation of the page’s HTML output,
(2) we extract all inline JavaScript from the approximated
HTML output, and (3) we rewrite the application so that
all inline JavaScript is moved to external ﬁles.
Hereinafter, we deﬁne a running example that we use to
describe how deDacota automatically transforms a web ap-
plication, according to the three steps outlined previously.
4.1 Example
Listing 1 shows a simpliﬁed ASP.NET Web Form page.
Note that everything not in between the  is output
directly to the browser. Everything between matching  is C# code. A subtle but important point is that
var username = " ";
1 
2
3
4
5
6
7
8
9
10 
(cid:104), Line 2(cid:105)
(cid:104), Line 5(cid:105)
(cid:104)Example, Line 6(cid:105)
Listing 1: Example of a simple ASP.NET Web Form
page.
(cid:104)var username = ", Line 7(cid:105)
1 void Render ( T e x t W r i t e r w ) {
2
3
4
5
6
7
w . Write ( " \ n
this . Title = " Example " ;
this . Username = Request . Params [ " name " ];
w . Write ( " \ n
w . Write ( this . Title ) ;
w . Write ( "  \ n
  " ) ;
\ n
" ) ;
\ n
var username = \" " ) ;
w . Write ( this . Username ) ;
w . Write ( " \";\ n
 " ) ;
\ n
\ n
8
9
10 }
Listing 2: The compiled C# output of Listing 1.
(cid:104)*, Line 8(cid:105)
(cid:104)";, Line 9(cid:105)
Figure 1: Approximation graph for the code in List-
ing 1 and Listing 2. The dotted node’s content is
not statically determinable.
equivalent C# program. The ASP.NET compiler creates a
class (not shown) that represents the ASP.NET Web Form.
A method of the class is given a TextWriter object as a pa-
rameter. Anything written to this object will be sent in the
HTTP response. TextWriter.Write is a method call equiv-
alent of writing to the console in a traditional command-line
application.
From comparing Listing 1 to Listing 2, one can see that
output not between  tags is written to the Text-
Writer object. The code between the  tags is
inlined into the function (Lines 3 and 4), and the code that
is between the  tags is written to the TextWriter
object (Lines 6 and 8). We also note that TextWriter.Write
is one of a set of methods used to write content to the HTTP
response. However, for simplicity, in the remainder of this
paper, we will use TextWriter.Write to represent all possi-
ble ways of writing content to the HTTP response.
4.2 Approximating HTML Output
In the ﬁrst phase of our approach, we approximate the
HTML output of a web page. This is a two-step process.
First, we need to determine, at every TextWriter.Write lo-
cation, what is being written. Second, we need to determine
the order of the TextWriter.Write function invocations.
We use a diﬀerent static analysis technique to answer each
of the two questions. To determine what is being written
at a TextWriter.Write, we use the points-to analysis algo-
rithm presented in [10] modiﬁed to work on .NET byte-code,
instead of C. This points-to analysis algorithm is inclusion-
based, demand-driven, context-sensitive, ﬁeld-sensitive, and
partially ﬂow-sensitive. The points-to analysis algorithm
computes the set of strings that alias with the parameter of
TextWriter.Write. If all strings in the alias set are constant
strings, the output at the TextWriter.Write will be deﬁned
as the conjunction of all possible constant strings. Other-
wise, we say the output is statically undecidable. To deter-
mine the ordering of all TextWriter.Write method calls, we
build a control-ﬂow graph, using standard techniques, that
only contains the TextWriter.Write method calls.
We encode the information produced by the two static
analyses—the ordering of TextWriter.Write method calls
and their possible output—into a graph that we call an ap-
proximation graph. Figure 1 shows the approximation graph
for the code in Listing 1 and Listing 2. Each node in the
graph contains the location of the TextWriter.Write that
this node represents as well as the possible constant strings
that could be output at this TextWriter.Write location.
Content that cannot be determined statically is represented
by a wild card * (the dotted node in Figure 1). The strings
that may be output at the TextWriter.Write will be used
to identify inline JavaScript, and the location of the Text-
Writer.Write will be used for rewriting the application.
In Figure 2 we show the approximation graph of a more
complex page. The graph in Figure 2 contains a branch,
where each node in the branch maps to the same Text-
Writer.Write method. This happens when the points-to
analysis says that the TextWriter.Write method can out-
put one of multiple strings. The other way there can be a
branch in the approximation graph is when there is a branch
in the control ﬂow of the web application. The graph in Fig-
ure 2 also contains a loop that includes the nodes shown in
bold. However, because we cannot statically determine the
number of times a loop may execute, and we want our anal-
ysis to be conservative, we collapse all nodes of a loop (in
the approximation graph) into a single node. This new node
now has undecidable content (represented by a *). The new
node also keeps track of all the TextWriter.Write methods
that were part of the original loop.
1208(cid:104), Line 70(cid:105)
Figure 2: Approximation graph with branches and
a loop. The loop will be collapsed into one node to
create the ﬁnal approximation graph.
After collapsing all loops in the graph, we derive a conser-
vative approximation of the HTML output of a web page.
The approximation graph is a directed acyclic graph (DAG),
and any path from the root node to a leaf node will represent
one possible output of the web page.
4.3 Extracting Inline JavaScript
In the second phase, our approach uses the approxima-
tion graph described previously to extract all possible inline
JavaScript. The output of this phase is a set containing all
possible inline JavaScript that may appear in the web page.
In an approximation graph, each unique path from the
root node to a leaf node represents a potential output of the
page. A na¨ıve algorithm would enumerate all paths and,
thus, all outputs, and parse each output string to identify
inline JavaScript. However, even without loops, the number
of unique paths even in a simple web page may quickly ex-
plode and become unmanageable (this is the path-explosion
problem faced in static analysis).
To reduce the impact of the path explosion problem, we
extract the inline JavaScript directly from the approxima-
tion graph. We ﬁrst search for the opening and closing tags
of HTML elements in the graph. We ignore tags that appear
in comments. Then, for each pair of JavaScript tags (i.e.,
), we process all the unique paths
between the opening and closing tags. For each path, we
obtain an inline JavaScript that the program might output.
While our current prototype is relatively simplistic in pars-
ing the starting and ending JavaScript ﬁles, it could be pos-
sible to use the parsing engine from a real browser. However,
this is not as straight-forward as it seems, as our input is a
graph of all potential HTML output, not a single document.
We leave this approach to future work.
All identiﬁed inline JavaScript pieces are then passed to
the last phase of our approach, which decides how to rewrite
the application.
4.4 Application Rewriting
The goal of the third phase is to rewrite the application
so that all identiﬁed inline JavaScript will be removed from
the HTML content and saved in external JavaScript ﬁles.
In the HTML code, an inline JavaScript is replaced with a
reference to the external JavaScript ﬁle as follows:
It is not uncommon that multiple possible inline Java-
Script snippets exist between an opening and closing Java-
Script tag because there may be branches between the tags
in the approximation graph. To know which exact inline
JavaScript is created, we need to track the execution of the
server-side code.
The inline JavaScript identiﬁed in the previous phase falls
into two categories: static and dynamic (i.e., contains un-
decidable content). Because we cannot statically decide the
content of a dynamic inline JavaScript, we must track the
execution of the server-side code to create its external Java-
Script ﬁle(s) at runtime. Therefore, we can avoid tracking
the execution of the server-side code only for the case in
which there is a single, static inline JavaScript code.
For a pair of opening and closing script tags that require
tracking the execution of the server-side code, we rewrite
the application as follows. At the TextWriter.Write that
may output the opening script tag, we ﬁrst check if the out-
put string contains the tag. We need to perform this check
because a TextWriter.Write site may be used to output ei-
ther inline JavaScript code or other HTML. If we ﬁnd the
opening script tag in the output, we use a session ﬂag to
indicate that an inline JavaScript rewriting has started. We
write out everything before the start of the opening script
tag. We remove the opening script tag itself. The remaining
content is stored into a session buﬀer. Note that both session
ﬂag and buﬀer are unique to each opening script tag. Then,
for all subsequent TextWriter.Write method calls that are
part of the inline JavaScript we are rewriting, except for the
last (that writes the closing tag), we append their output
to the session buﬀer if the session ﬂag is on. For the last
TextWriter.Write method call (i.e., the one that writes the
closing script tag), any string content that occurs before the
closing script tag is appended to the session buﬀer. Any
content after the closing script tag is just written to the
output. At this point, the session buﬀer contains the entire
inline JavaScript code. We save this code to an external ﬁle
and add a TextWriter.Write method call that outputs the
reference to this JavaScript ﬁle.
To support JavaScript caching on the client side, the name
of the JavaScript ﬁle is derived from its content, using a
cryptographic hash of the JavaScript content. An unin-
tended beneﬁt of this approach is that inline JavaScript that
is included on multiple pages will be cached by the browser,
improving application performance by reducing the size of
the page and saving server requests.
Listing 3 shows the result of applying this rewriting pro-
cess to the inline JavaScript code in Listing 2. The changes
shown are only those made to Lines 7–9 in Listing 2.
4.5 Dynamic Inline JavaScript
At this point in our analysis, we have successfully sepa-
rated the JavaScript code from the HTML data in the web
application.
If the web application’s JavaScript is static,
and by static we mean statically decidable, then the appli-
cation is now immune to XSS vulnerabilities. However, if
1209\ n
" ) ;
1 w . Write ( "  \ n
2
3 Session [ " 7 " ] = " \ n
4 Session [ " 7 " ] += this . Username ;
5 Session [ " 7 " ] += " \";\ n