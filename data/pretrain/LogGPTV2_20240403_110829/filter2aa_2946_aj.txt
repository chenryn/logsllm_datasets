在这里我们可以使用LordPE来查看我们这个DLL文件的导出表（涉及中级班课程暂时可以略过），我们只要知
道在这个导出表中有这个DLL声明的函数：
可以很清楚的看见我们的函数名称变成了_add@8。
滴水逆向课程笔记  –  Win32
动态链接库  –  131
25.1.2 使用.DEF文件
我们可以在项目中创建一个文件扩展名为.def的文件，在该文件中使用如下格式来声明：
按照这种方式修改如下：
头文件：
CPP文件：
DEF文件：
然后编译，用LordPE打开查看一下函数名称就会发现其没有了@xxx这样的格式而是我们定义什么样就是什么
样：
EXPORTS 
1
函数名 @编号 // 有编号，也有名称
2
函数名 @编号     NONAME // 有编号，没有名称
3
滴水逆向课程笔记  –  Win32
动态链接库  –  132
这样做的好处就是：可以很直观的看见函数名，并且在应用层面可以达到隐藏的目的。
25.2 使用动态链接库
使用动态链接库的步骤比较繁琐，一共有如下几个步骤：
滴水逆向课程笔记  –  Win32
动态链接库  –  133
执行结果如下图：
// 将DLL文件复制到项目目录下
1
2
// 步骤1：定义函数指针,如：
3
typedef int (*lpAdd)(int,int);
4
5
// 步骤2：声明函数指针变量,如：
6
lpAdd myAdd;
7
8
// 步骤3：动态加载dll到内存中,如：
9
// LoadLibrary函数会先从当前目录寻找，然后在系统目录寻找
10
HINSTANCE hModule = LoadLibrary("B.dll"); 
11
12
// 步骤4：获取函数地址,如：
13
myAdd = (lpAdd)GetProcAddress(hModule, "add");
14
15
// 步骤5：调用函数,如：
16
int a = myAdd(10,2);
17
18
// 步骤6：释放动态链接库,如：
19
FreeLibrary(hModule);
20
滴水逆向课程笔记  –  Win32
隐式链接  –  134
1.
2.
3.
26 隐式链接
之前我们调用动态链接库（DLL文件）使用的方式实际上是显式链接，它的优点是非常灵活，缺点就是使用起
来非常麻烦，步骤很繁琐。
本章节我们来学习隐式链接，通过隐式链接我们只需要一次配置，之后就会非常的方便。
26.1 隐式链接
隐式链接有这几个步骤：
将.dll和.lib放到项目目录下
将 #pragma comment(lib, "DLL名.lib") 添加到调用文件
加入函数声明
函数声明格式如下：
注意：在课程中给出的_declspec是有两个下划线的，经过查询之后实际上一个下划线和两个下划线是等价的。
注意，如果你创建动态链接库的方式是extern的方式，那么在第三步加入函数声明时就应该按照extern的格式
来：
_declspec(dllimport) _调用约定 返回值 函数名称 (函数参数列表);
1
extern "C" _declspec(dllexport) 调用约定 返回类型 函数名 (参数列表);
1
extern "C" _declspec(dllimport) 调用约定 返回类型 函数名 (参数列表);
2
滴水逆向课程笔记  –  Win32
隐式链接  –  135
26.2 隐式链接的实现
使用隐式链接，编译器会将链接的DLL文件存放到导入表中：
我们可以使用LordPE来查看一下：
并且它可以详细的记录使用了DLL中的哪些函数：
滴水逆向课程笔记  –  Win32
隐式链接  –  136
26.3 DLL的优点
DLL的优点如下图所示，DLL只在内存中加载一份，修改的时候就是写拷贝原理，不会影响别的进程使用DLL以
及不会影响DLL本身：
26.4 DllMain函数
我们的控制台程序入口是Main函数，而DLL文件的入口函数是DllMain函数（DllMain函数可能会执行很多次，
不像我们的Main函数只执行一次），其语法格式如下：
BOOL WINAPI DllMain(
1
  HINSTANCE hinstDLL,   // handle to the DLL module DLL模块的句柄，当前DLL被加载到什么位置
2
  DWORD fdwReason,      // reason for calling function DLL被调用的原因，有4种情况：DLL_PROCESS_ATTACH
（当某个进程第一次执行LoadLibrary）、DLL_PROCESS_DETACH（当某个进程释放了DLL）、DLL_THREAD_ATTACH（当某个进
程的其他线程再次执行LoadLibrary）、DLL_THREAD_DETACH（当某个进程的其他线程释放了DLL）
3
  LPVOID lpvReserved    // reserved
4
);
5
滴水逆向课程笔记  –  Win32
远程线程  –  137
27 远程线程
27.1 线程的概念
线程是附属在进程上的执行实体，是代码的执行流程；代码必须通过线程才能执行。
27.2 创建远程线程
创建远程线程的函数是CreateRemoteThread，其语法格式如下：
CreateThread函数是在当前进程中创建线程，而CreateRemoteThread函数是允许在其他进程中创建线程，所
以远程线程就可以理解为是非本进程中的线程。
首先创建A进程，代码如下：
进程B写了一个远程线程创建的代码：
HANDLE CreateRemoteThread(
1
  HANDLE hProcess,                          // handle to process 输入类型，进程句柄
2
  LPSECURITY_ATTRIBUTES lpThreadAttributes, // SD 输入类型，安全属性，包含安全描述符
3
  SIZE_T dwStackSize,                       // initial stack size 输入类型，堆大小
4
  LPTHREAD_START_ROUTINE lpStartAddress,    // thread function 输入类型，线程函数，线程函数地址应该是在别
的进程中存在的
5
  LPVOID lpParameter,                       // thread argument 输入类型，线程参数
6
  DWORD dwCreationFlags,                    // creation option 输入类型，创建设置
7
  LPDWORD lpThreadId                        // thread identifier 输出类型，线程id
8
);
9
void Fun() {
1
    for(int i = 0; i <= 5; i++) {
2
        printf("Fun running... \n");
3
        Sleep(1000);
4
    }
5
}
6
7
DWORD WINAPI ThreadProc(LPVOID lpParameter) {
8
    Fun();
9
    return 0;
10
}
11
12
int main(int argc, char* argv[]) {
13
14
    HANDLE hThread = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
15
16
    CloseHandle(hThread);
17
18
    getchar();
19
    return 0;
20
}
21
滴水逆向课程笔记  –  Win32
远程线程  –  138
函数MyCreateRemoteThread传入2个参数，一个是进程ID，一个是线程函数地址。
进程ID通过任务管理器查看：
BOOL MyCreateRemoteThread(DWORD dwProcessId, DWORD dwProcessAddr) {
1
    DWORD dwThreadId;
2
    HANDLE hProcess;
3
    HANDLE hThread;
4
    // 1. 获取进程句柄
5
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
6
    // 判断OpenProcess是否执行成功
7
    if(hProcess == NULL) {
8
        OutputDebugString("OpenProcess failed! \n");
9
        return FALSE;
10
    }
11
    // 2. 创建远程线程
12
    hThread = CreateRemoteThread(
13
        hProcess,                          // handle to process
14
        NULL, // SD
15
        0,                       // initial stack size
16
        (LPTHREAD_START_ROUTINE)dwProcessAddr,    // thread function
17
        NULL,                       // thread argument
18
        0,                    // creation option
19
        &dwThreadId                        // thread identifier
20
    );
21
    // 判断CreateRemoteThread是否执行成功
22
    if(hThread == NULL) {
23
        OutputDebugString("CreateRemoteThread failed! \n");
24
        CloseHandle(hProcess);
25
        return FALSE;
26
    }
27
28
    // 3. 关闭
29
    CloseHandle(hThread);
30
    CloseHandle(hProcess);
31
32
    // 返回
33
    return TRUE;
34
}
35
滴水逆向课程笔记  –  Win32
远程线程  –  139
我们在进程A的代码下断点找到线程函数地址：
然后将对应值填入即可远程创建线程：
滴水逆向课程笔记  –  Win32
远程线程  –  140
滴水逆向课程笔记  –  Win32
远程线程注入  –  141
28 远程线程注入
之前我们是远程创建线程，调用的也是人家自己的线程函数，而如果我们想要创建远程线程调用自己定义的线
程函数就需要使用远程线程注入技术。
28.1 什么是注入
所谓注入就是在第三方进程不知道或者不允许的情况下将模块或者代码写入对方进程空间，并设法执行的技
术。
在安全领域，“注入”是非常重要的一种技术手段，注入与反注入也一直处于不断变化的，而且也愈来愈激烈的
对抗当中。
已知的注入方式：
远程线程注入、APC注入、消息钩子注入、注册表注入、导入表注入、输入法注入等等。
28.2 远程线程注入的流程
远程线程注入的思路就是在进程A中创建线程，将线程函数指向LoadLibrary函数。
那么为什么可以这样呢？这是因为我们执行远程线程函数满足返回值是4字节，一个参数是4字节即可
（ThreadProc就是这样的条件）：
我们再来看一下LoadLibrary函数的语法格式：
我们可以跟进（F12）一下HMODULE和LPCTSTR这两个宏的定义，就会发现其实都是4字节宽度。
具体实现步骤如下图所示：
HMODULE LoadLibrary(
1
  LPCTSTR lpFileName   // file name of module
2
);
3
滴水逆向课程笔记  –  Win32
远程线程注入  –  142
28.3 如何执行代码
DLL文件，在DLL文件入口函数判断并创建线程：
文件我们用之前写的Test1.exe即可，将编译好的DLL和Test1.exe放在同一个目录并打开Test1.exe。
注入实现：
// B.cpp : Defines the entry point for the DLL application.
1
//
2
3
#include "stdafx.h"
4
5
DWORD WINAPI ThreadProc(LPVOID lpParaneter) {
6
    for (;;) {
7
        Sleep(1000);
8
        printf("DLL RUNNING...");
9
    }
10
}
11
12
BOOL APIENTRY DllMain( HANDLE hModule, 
13
                       DWORD  ul_reason_for_call, 
14
                       LPVOID lpReserved
15
                     )
16
{   // 当进程执行LoadLibrary时创建一个线程，执行ThreadProc线程
17
    switch (ul_reason_for_call) {
18
    case DLL_PROCESS_ATTACH:
19
        CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
20
        break;
21
    }
22
    return TRUE;
23
}
24
滴水逆向课程笔记  –  Win32
远程线程注入  –  143
// Test.cpp : Defines the entry point for the console application.
1
//
2
3
#include "StdAfx.h"
4
5
// LoadDll需要两个参数一个参数是进程ID，一个是DLL文件的路径
6
BOOL LoadDll(DWORD dwProcessID, char* szDllPathName) {
7
8
    BOOL bRet;
9
    HANDLE hProcess;
10
    HANDLE hThread;
11
    DWORD dwLength;
12
    DWORD dwLoadAddr;
13
    LPVOID lpAllocAddr;
14
    DWORD dwThreadID;
15
    HMODULE hModule;
16
17
    bRet = 0;
18
    dwLoadAddr = 0;
19
    hProcess = 0;
20
21
    // 1. 获取进程句柄
22
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);
23
    if (hProcess == NULL) {
24
        OutputDebugString("OpenProcess failed! \n");
25
        return FALSE;
26
    }
27
28
    // 2. 获取DLL文件路径的长度，并在最后+1，因为要加上0结尾的长度
29
    dwLength = strlen(szDllPathName) + 1;
30
31
    // 3. 在目标进程分配内存
32
    lpAllocAddr = VirtualAllocEx(hProcess, NULL, dwLength, MEM_COMMIT, PAGE_READWRITE);
33
    if (lpAllocAddr == NULL) {
34
        OutputDebugString("VirtualAllocEx failed! \n");
35