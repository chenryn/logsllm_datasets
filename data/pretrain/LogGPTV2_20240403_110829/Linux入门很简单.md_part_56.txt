进入这个界面，就可以进行调试了。当然，要想调试，需要了解一下GDB的一些基本的指令。我们简单介绍几个常用的。
![alt](images/00002.jpeg){.tpzz} run命令（或者简写为r）------这个命令很好理解，就是从头开始运行程序。像刚才懒蜗牛运行"gdb
./rubbish19_debug"后，进入了GDB调试环境，但是并没有自动运行起19号这个程序，需要run一下才行。
![alt](images/00002.jpeg){.tpzz} break命令（或者简写为b）------这个命令用来设置断点。例如"break
12"的意思就是在程序源码的12行设置断点。这样程序运行到这一行就会停下来。
![alt](images/00002.jpeg){.tpzz} list命令（或者简写为l）------列出当前程序源代码。遇到问题了总得看看源码吧，或者设置个断点什么的也得看着源码才知道应该断在哪行。那就用这个命令查看源码就可以了。
![alt](images/00002.jpeg){.tpzz} continue命令（或者简写为c）------这是继续执行的意思。程序遇到断点停下来以后，可以用这个命令继续执行下去，直到碰到下一个断点，或者结束。
![alt](images/00002.jpeg){.tpzz} print命令（或者简写为p）------这个命令用来打印变量的值。比如print
i，意思就是打印出变量i当前的值。
![alt](images/00002.jpeg){.tpzz} examine命令（或者简写为x）------这个命令用于查看指定内存地址中的数据。例如examine
0x12345678的意思是查看内存中，地址为0x12345678位置所存放的数据。
![alt](images/00011.jpeg){.tpzz}**提示：**[examine命令只能查看当前被调试程序能够合法访问的地址。]{.kai1}
![alt](images/00002.jpeg){.tpzz} next命令（或者简写为n）------这是单步执行的命令。程序遇到断点停下来之后，执行这个命令可向下执行一句代码。
懒蜗牛同学好像是之前看书学习过了，虽然据我所知这是他第一次使用GDB，但是似乎还挺熟练。
进入GDB调试环境后，懒蜗牛输入了r并且回车。于是，GDB按下一个电钮，19号的身体跟着腾地一下站了起来，启动了。插着电缆的19号像他上次启动后一样，还是要去骚扰狐狸妹妹，访问人家的内存空间，于是我也只好再次举起屠龙刀，再次将其一刀两断。
GDB赶快向懒蜗牛报告：19号同学在按照您的图纸进行某某动作的时候，由于侵占他人内存空间，触犯了内存管理条例第287条，因此被处以"断刑"。然后还指出了19号的这种行为在懒蜗牛的图纸中所在的位置，也就是代码行数，类似下面这样：
![alt](images/00459.jpeg){.calibre3}
懒蜗牛一看，rubbish.c文件的第9行就出问题了，太伤自尊了，可是这第9行也看不出什么不对的来。应该是这个指针有什么问题，还是从头看看程序吧。
于是懒蜗牛输入了list命令，GDB赶紧把19号的整个图纸------也就是全部程序的源代码，打印了出来。程序一打印出来，懒蜗牛才看明白：这个buffer指针压根就没有初始化嘛，只是做了声明而已，也没给申请内存空间，就这么用，那不出问题才怪。
8.2.4 扩展阅读：内存管理机制
前面向您介绍了懒蜗牛创造的rubbish
19号程序，这家伙由于不遵守《Linux系统内存管理条例》被我干掉了。那么我们Linux的内存管理原则是什么呢？都有什么规矩呢？下面就来说说。
咱们说过，一个程序工作的时候需要用到的内存分为几个部分：代码段、数据段、BSS段和堆栈段。其他的段，基本上程序一启动就确定好了，没什么可说的，也没太多要管理的。唯独这个堆栈里面的堆空间，是程序运行起来之后动态申请的，需要我来管理。
【空间的申请和释放】
堆空间是指程序在起床运行后向我申请来的空间，也是一个程序占用得最多的空间。一个程序如果要想使用工作间里的空间，要向我提出要求，说需要多大多大的一块内存空间------这个过程叫做申请。然后我根据工作间里的情况来分配，告诉他，哪块哪块归你，然后这个程序就去用了。
这时候那块地方就单独给这个程序使用，不许别的程序访问了。如果别的程序胆敢来访问这块空间，就像你去人家偷东西一样，必须依法剁成两段（偷东西没这么大罪过吧......）。
那么这块内存空间分给这个程序使用之后就永远给他了么？想得美！你买房还只有70年产权呢，这么珍贵的内存空间怎么可能永久分给一个程序。申请到内存空间的这个程序在做完了相关的事情，不再需要这块空间的时候，他应该跟我报道，说空间我用完了，这块地方可以再给别的程序用了------这个过程叫做释放。
【内存泄漏】
一个有知识有道德有理想的程序，在他回硬盘睡觉以前应该释放掉所有他申请过的空间。如果遇到哪个不良程序，无德青年申请了很多空间不释放，我也没有办法。因为这不像越界访问那样，访问了别人的地址就是访问了，人赃俱获，无法抵赖。而人家不释放空间，也许是因为他一会儿还需要用这块空间呢，我没法证明他申请的空间用不着了。我唯一可以做的就是在他回硬盘睡觉的时候，检查所有他申请过的空间，如果有没释放的，就强制释放掉------你都睡觉去了，你申请的空间肯定用不着了嘛。
![alt](images/00011.jpeg){.tpzz}**提示：**[Linux在程序退出之后将回收程序申请的所有资源，包括内存空间、Socket连接、设备访问等。]{.kai1}
但是如果这个程序是个长时间运行的后台服务程序，并且还不断地申请新的空间而不释放，那就麻烦了。内存空间会被他一点一点地消耗光，这就是最烦人的内存泄漏。在我们软件界，内存泄漏是和瓦斯泄漏同样严重的事故。《Linux系统内存管理条例》第3条明确写着------禁止申请不释放！就在第4条禁止抽烟的上面（当然不能抽烟，内存都冒烟了机器还能用么）。
【Windows与Linux对内存使用的不同理念】
其实不光是Linux，Windows里的程序一样需要遵守类似的原则，估计他们那里大概也有个什么《Windows系统内存管理办法》之类的文件吧，反正大家的原理是一样的。不过对于工作间的使用，Windows和我还是有点不同的。
Windows总是喜欢尽量留出空间来，好给新起床的程序用。可是我总觉得，作为一个系统，我怎么能知道用户还有什么程序要运行呢？要是没有程序要来了，工作间里还空那么大地方，不让正在工作的程序用，那不是浪费么？所以我还是习惯尽可能地把东西都搬进工作间里。除了程序们申请多少内存就尽可能给多少之外，剩下的部分，我就把一些可能会用到的库、命令等统统都搬进来，能占多少占多少。
有人问：要是你把这里边都占满了，待会儿有程序要进来咋办？很简单啊，我再搬出去呗！
程序要用空间，也不是一下子都占满吧，他也得把他的东西一点点搬进来。他往内存里搬的时候，我就往外搬，不耽误。所以，当某个程序启动，跟我说："我要10平米的地方放东西。"的时候，我就先答应他说："好，你就往那边那10平米放吧。"然后在他往内存里搬数据的时候，我再去给他清理那10平米的地方。也可能他要10平米，但是暂时只用了2平米，那我就先腾出2平米来，等他再要我再腾。他们管我这个方法叫Copy-onwrite。
但是Windows就不同了。可能是因为他们普遍比较胖的缘故吧，都比较懒，不愿意搬来搬去这么折腾。基本上Windows只是在必须用啥东西的时候才把那东西搬到内存里，让内存留出尽可能多的空闲空间。这样，当有程序向他申请内存的时候，就可以用手一指：那块地，归你。然后就不用管了。内存实在不够用的时候就找个比较闲的程序，命令他：你，去硬盘里先忍会儿。
![alt](images/00011.jpeg){.tpzz}**提示：**[图形界面中，可以通过"系统"\|"系统管理"\|"系统监视器"来查看内存使用情况，如图8.4所示。]{.kai1}
![alt](images/00460.jpeg){.calibre3}
图8.4 系统监视器
[在字符界面中可以通过"free"命令查看内存使用情况。但需注意"free"命令显示的结果中，第1行为计算了内核缓冲后的使用率。这个使用率一般很高，多数空闲内存都被用于缓冲。"buffer/cache"一行显示的，才是真正的应用软件所占用的内存，如图8.5红线处所示（free命令显示结果默认单位为KB）。]{.kai1}
![alt](images/00461.jpeg){.calibre3}
图8.5 free命令
[8.3 包工头]{.kai}
简单的程序直接用GCC编译就可以了。但是如果程序越来越大，源码文件越来越多，再手动调用GCC来编译就显得费事了。有什么好办法呢？
8.3.1 懒蜗牛的日记C
"2010年10月10日 起风
今天好孤独，节后的只有一天的周末还要独自来加班。领导总是不顾员工的死活，就像剥削劳动人民的包工头一样。
不过今天加班的时候倒是抽空完善了我的rubbish程序。现在这个程序已经有16个.c文件了。每次编译的时候敲命令还真麻烦。还好Linux可以记住最近运行的几条命令，不用每次都输入。不过就算这样也挺累的，有没有更好的办法呢？"
8.3.2 越来越多的源码文件
最近硬盘里的rubbish越来越多，已经排到31号了。虽然这些程序都不大，31个加在一起也就几兆的大小，可关键是这帮程序大都不着调，不是段错误就是内存泄漏，要不就是乱访问设备。这么多不着调的程序在内存里折腾，指不定什么时候就出事了。
【文件太多，一起编译费时费力】
这些rubbish程序，除了不着调以外，个头越来越大，源码也越来越复杂。从rubbish
1号只有一个.c文件，发展到现在，rubbish
31号一共有10多个源码文件。每次懒蜗牛同学编译rubbish
31号的时候，都要这样：
![alt](images/00462.jpeg){.calibre3}
每次看着他输入这么长一串的命令，我真替他累得慌。并且每次懒蜗牛这么一编译，施工队那哥儿几个就都得跑过来，把这一大堆.c挨个打开，开始从头施工，一个一个编译。有时候懒蜗牛只是在ai.c里面修改了很少的一点，编译的时候施工队的同志们也要从头到尾地重新编译每一个文件。
这就好像盖个楼，完工之后开发商说：一楼这个大门的门把手图纸上画错了，应该用圆的，怎么画成方的了？改了吧。施工方一听，赶紧下令："图纸画错啦！把楼炸了重新盖！"虽然这样对于拉动GDP发展有很好的作用，但毕竟属于精神不正常的范畴。
【分别编译，一起链接】
那么我们的GCC施工队为什么做这种很抽风的事呢？这不怪施工队，这是因为懒蜗牛输入的命令就是让他们拆了重盖的意思（也就是让他们从头开始编译），他们只是严格执行命令而已。实际上完全不必这样，那些.c文件中，改了哪个只编译哪个就可以。那应该怎么操作呢？
（1）首先，源码写完了之后先各自编译成模块，运行：
![alt](images/00463.jpeg){.calibre3}
这个命令的意思就是把这些.c文件各自编译成.o文件，如rubbish.o、input.o等。
（2）要获得最终的二进制文件，只要再运行：
![alt](images/00464.jpeg){.calibre3}
就生成了最终的rubbish 31号。
（3）那么之后如果修改了某个源文件------比如修改了ai.c文件，只需要重新编译这一个文件就行了，就运行：
![alt](images/00465.jpeg){.calibre3}
这样就编译出了新的ai.o。
（4）得到新的ai.o之后再运行：
![alt](images/00466.jpeg){.calibre3}