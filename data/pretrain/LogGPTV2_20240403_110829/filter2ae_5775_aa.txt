Author：薇拉vera@[勾陈安全实验室](http://www.polaris-lab.com/ "勾陈安全实验室")
> “The world is not made of strings , but is made of things.”  
>  ——辛格博士，from Google.
写在前面，对知识图谱的了解源于我在刘峤老师实验室里所做的【知识图谱中的关系推理】这方面的研究，在来到公司上班之后，意外发现在工业界这一块也有着非常巨大的需求。当然工业界面临的数据量和问题也是学术界远远不可启及的……  
总之，最近决定把这个技能捡起来打磨打磨重新上膛，遂准备通过这一系列文章来对知识图谱进行一次梳理。
欢迎对这个方向感兴趣的童鞋们来交流~也欢迎同行指出这系列文章的不足！先行鞠躬笔芯感谢！
# 0x01 定义
俗话说：“看人先看脸。”在我们深入了解知识图谱之前，让我们先来看一下它长什么样子!  
emmm这是百度知识图谱给出的小时代关系图谱的样子，你可以看到，如果两个角色之间有关系，他们就会被一条无向边连接在一起，那么这个角色，我们就称为实体（Entity）/节点（Point），他们之间的这条边，我们就称为关系（Relationship）/边（Edge）。  
当然，实际的知识图谱当然不会像这种人为处理过的看起来这么舒服……给大家看几张更真实一点的知识图谱的样子——  
还有这样……  
总而言之，知识图谱本质上就是上图展示出来的这种语义网络，是一种基于图的数据结构，由 **节点(Point)和边(Edge)**
组成。在知识图谱里，每个节点表示现实世界中存在的“实体”，每条边为实体与实体之间的“关系”。
# 0x02 存储方式
知识图谱的存储方式通常分为以下两种——
  * **RDF存储格式**  
主要常用Jena
  * **图数据库(Graph Database)**  
主要常用neo4j
**采用图数据库而不是关系数据库的原因？**
  1. 简单的知识图谱可以用关系数据库，但是一旦知识图谱变复杂，在关联查询的效率上会比传统的存储方式有显著的提高。当我们涉及到2,3度的关联查询，基于知识图谱的查询效率会高出几千倍甚至几百万倍。
  2. 基于图的存储在设计上会非常灵活，一般只需要局部的改动即可。
  3. 把实体和关系存储在图数据结构是一种符合整个故事逻辑的最好的方式。
# 0x03 知识图谱的架构
知识图谱的架构主要可以被分为
  * 逻辑架构
  * 技术架构
## 3-1逻辑架构
在逻辑上，我们通常将知识图谱划分为两个层次： **数据层和模式层** 。
  * **模式层：** 在数据层之上，是知识图谱的核心，存储经过提炼的知识，通常通过 **本体库** 来管理这一层这一层（本体库可以理解为面向对象里的“类”这样一个概念，本体库就储存着知识图谱的类）。
  * **数据层：** 存储真实的数据。
如果还是有点模糊，可以看看这个例子——
> 模式层：实体-关系-实体，实体-属性-性值  
>  数据层：比尔盖茨-妻子-梅琳达·盖茨，比尔盖茨-总裁-微软
## 3-2 技术架构
知识图谱的整体架构如图所示，其中虚线框内的部分为知识图谱的构建过程，同时也是知识图谱更新的过程。  
别紧张，让我们顺着这张图来理一下思路。首先我们有一大堆的数据，这些数据可能是结构化的、非结构化的以及半结构化的，然后我们基于这些数据来构建知识图谱，这一步主要是通过一系列自动化或半自动化的技术手段，来从原始数据中提取出知识要素，即一堆实体关系，并将其存入我们的知识库的模式层和数据层。  
构建知识图谱是一个迭代更新的过程，根据知识获取的逻辑，每一轮迭代包含三个阶段——
  * **信息抽取：** 从各种类型的数据源中提取出实体、属性以及实体间的相互关系，在此基础上形成本体化的知识表达；
  * **知识融合：** 在获得新知识之后，需要对其进行整合，以消除矛盾和歧义，比如某些实体可能有多种表达，某个特定称谓也许对应于多个不同的实体等；
  * **知识加工：** 对于经过融合的新知识，需要经过质量评估之后（部分需要人工参与甄别），才能将合格的部分加入到知识库中，以确保知识库的质量。
## 3-3构建方式
知识图谱有自顶向下和自底向上2种构建方式。
  * **自顶向下：**  
借助百科类网站等结构化数据源，从高质量数据中提取本体和模式信息，加入到知识库中；
  * **自底向上**  
借助一定的技术手段，从公开采集的数据中提取出资源模式，选择其中置信度较高的新模式，经人工审核之后，加入到知识库中。
# 0x04 构建技术
【这里提到的构建技术主要是自底向上的构建方式里会涉及到的构建技术】  
如前所述，构建知识图谱是一个迭代更新的过程，根据知识获取的逻辑，每一轮迭代包含三个阶段——
  * **信息抽取：** 从各种类型的数据源中提取出实体、属性以及实体间的相互关系，在此基础上形成本体化的知识表达；
  * **知识融合：** 在获得新知识之后，需要对其进行整合，以消除矛盾和歧义，比如某些实体可能有多种表达，某个特定称谓也许对应于多个不同的实体等；
  * **知识加工：** 对于经过融合的新知识，需要经过质量评估之后（部分需要人工参与甄别），才能将合格的部分加入到知识库中，以确保知识库的质量。
见下图——  
## 4-1 信息抽取
信息抽取（infromation extraction）是知识图谱构建的第1步，其中的关键问题是——
> 如何从异构数据源中自动抽取信息得到候选指示单元。  
>  信息抽取是一种自动化地从半结构化和无结构数据中抽取实体、关系以及实体属性等结构化信息的技术。  
>  涉及的关键技术包括： **实体抽取、关系抽取和属性抽取。**
### 4-1-1 实体抽取
**实体抽取** ，也称为 **命名实体识别（named entity recognition，NER）** ，是指从文本数据集中自动识别出命名实体。
**研究历史：**
  1. 面向单一领域，关注如何识别出文本中的人名、地名等专有名词和有意义的时间等实体信息
    1. 启发式算法+人工规则，实现自动抽取实体的原型系统
    2. 统计机器学习方法辅助解决命名实体抽取问题
    3. 有监督学习+先验知识
  2. 开始关注 **开放域（open domain）** 的信息抽取问题，不再限定于特定的知识领域，而是面向开放的互联网，研究和解决全网信息抽取问题。
    1. 人工建立科学完整的命名实体分类体系
    2. 基于归纳总结的实体类别，基于条件随机场模型进行实体边界识别，最后采用自适应感知机实现对实体的自动分类
    3. 采用统计机器学习的方法，从目标数据集中抽取出与之具有相似上下文特征的实体，从而实现实体的分类和聚类。
    4. 迭代扩展实体语料库
    5. 通过搜索引擎的服务器日志，聚类获取新出现的命名实体。——已应用于自动补全技术
### 4-1-2 关系抽取
文本语料经过实体抽取，得到的是一系列离散的命名实体，为了得到语义信息，还需要从相关语料中提取出实体之间的关联关系，通过关系将实体联系起来，才能够形成网状的知识结构。这就是
**关系抽取** 需要做的事。  
**研究历史：**
  1. 人工构造语法和语义规则（模式匹配）
  2. 统计机器学习方法
  3. 基于特征向量或核函数的有监督学习方法
  4. 研究重点转向半监督和无监督
  5. 开始研究面向开放域的信息抽取方法
  6. 将面向开放域的信息抽取方法和面向封闭领域的传统方法结合
### 4-1-3 属性抽取
**属性抽取** 的目标是从不同信息源中采集特定实体的属性信息，如针对某个公众人物，可以从网络公开信息中得到其昵称、生日、国籍、教育背景等信息。
**研究历史：**
  1. 将实体的属性视作实体与属性值之间的一种名词性关系，将属性抽取任务转化为关系抽取任务。
  2. 基于规则和启发式算法，抽取结构化数据
  3. 基于百科类网站的半结构化数据，通过自动抽取生成训练语料，用于训练实体属性标注模型，然后将其应用于对非结构化数据的实体属性抽取。
  4. 采用数据挖掘的方法直接从文本中挖掘实体属性和属性值之间的关系模式，据此实现对属性名和属性值在文本中的定位。
## 4-2 知识融合
通过信息抽取，我们就从原始的非结构化和半结构化数据中获取到了实体、关系以及实体的属性信息。  
如果我们将接下来的过程比喻成拼图的话，那么这些信息就是拼图碎片，散乱无章，甚至还有从其他拼图里跑来的碎片、本身就是用来干扰我们拼图的错误碎片。  
**也就是说——**
  * 拼图碎片（信息）之间的关系是扁平化的，缺乏层次性和逻辑性；
  * 拼图（知识）中还存在大量冗杂和错误的拼图碎片（信息）
那么如何解决这一问题，就是在知识融合这一步里我们需要做的了。  
知识融合包括2部分内容：
  * 实体链接
  * 知识合并
### 4-2-1 实体链接
**实体链接（entity linking）** 是指对于从文本中抽取得到的实体对象，将其链接到知识库中对应的正确实体对象的操作。  
其基本思想是首先根据给定的 **实体指称项** ，从知识库中选出一组候选实体对象，然后通过 **相似度计算** 将指称项链接到正确的实体对象。
**研究历史：**
  1. 仅关注如何将从文本中抽取到的实体链接到知识库中，忽视了位于同一文档的实体间存在的语义联系。
  2. 开始关注利用实体的共现关系，同时将多个实体链接到知识库中。 **即集成实体链接（collective entity linking）**
**实体链接的流程：**
  1. 从文本中通过实体抽取得到实体指称项；
  2. 进行 **实体消歧** 和 **共指消解** ，判断知识库中的同名实体与之是否代表不同的含义以及知识库中是否存在其他命名实体与之表示相同的含义；