真正的“消除循环”解法
The Real“Llnrolling-thte-Loop”Patftern
这和原来的表达式能够匹配的结果是完全一致的。但是循环消除之后，表达式能够在有限
的时间内结束匹配。不但效率高得多，并且避免了无休止匹配。
消除循环常用的解法是：
openingnormal*(specialnormal*)*closing)
避免无休止匹配
避免”（\\]*（[\\"]*）*"中的无休止匹配，有三点很重要：
1）special部分和normal部分匹配的开头不能量合。
special和normal部分的子表达式不能从同一位置开始匹配。在上例中，normal部分是
[^\\"]，special部分是\.，显然它们不能匹配同样的字符，因为后者要求以反斜线开
头，而前者不容许出现开头的反斜线。
另一方面，\.和[^"]都能够从‘"He1lo\n"’开始匹配，所以它们不符合这种解法。
如果二者能够从字符串中的同一位置开始匹配，就无法确定该使用哪一个，这种不确定就
会造成无休止匹配。“abudoBarude’的例子说明了这一点（227）。如果无法匹配（或是
POSIXNFA引擎在任何情况下的匹配），就必须尝试所有的可能性。这非常糟糕，因为改进
这个表达式的首要原因就是为了避免这种情况。
如果我们确信，special和normal部分不能匹配同样的字符，就可以将special部分用作检查
点，消除normal部分在（）*的各轮选代时匹配同样文本造成的不确定性。如果我们确信
special部分和normal部分永远不会匹配同样的文本，则特定目标字符事的匹配中存在唯一
多，于是避免了无休止匹配。
---
## Page 291
消除循环
265
2）normal部分必须匹配至少一个字符
第二点是，如果normal部分需要匹配字符才能成功，则它必须匹配至少一个字符。如果我
们能够匹配成功，而不占用任何字符，那么下面的字符仍然必须由“（specialnormal*)*的
不同选代来匹配，这样我们就回到了原来的（*）*的问题。
选择（\\.）*作为special部分就违背了这条规定。"[^\\"]*（（\1.）*[^\\."]*）*"注定是
个糟糕的表达式，如果用它来匹配“"Tubby”（会失败），在得到匹配失败的结论之前，引
擎必须尝试若干个"[^\\"]*匹配“Tubby”的每一种可能。因为special部分可以不匹配任
何字符，所以它无法作为检查点。
3）special部分必须是固化的
special部分匹配的文本不能由该部分的多次选代完成。如果需要匹配Pascal中可能出现的
注释（）和空白。能够匹配注释部分的正则表达式是\（[^）*），所以整个正则表达式就
是（\（[^）]*\）1+）*（它永远不会终止）。或许，你会这样划分normal和special部分：
Special
]+（.[~-]+）*
我们知道，匹配每次进行到标记的位置时，应该出现一个反斜线或者闭双引号。如果反斜
线能匹配，就匹配它，然后是被转义的字符，然后是更多的字符，直到下一一次到达“闭引
号或者反斜线”的位置。
和之前一样，最并始的非引用内容或是引号内的文本可能为空。我们可以把两个加号改成
星号，这样就得到与264页相同的表达式。
方法3：匹配主机名
Methtod3: An InternetHostname
上面介绍了两种消除循环的办法，不过我还愿意介绍另一种办法。在用正则表达式匹配如
www.yahoo.com这样的主机名时，它令我震惊。主机名主要是用点号分隔的子域名的序列，
准确地划定子域名的匹配规范很麻烦（203），为了保证清晰，我们使用[a-2]+来匹配
子域名。
如果子域名是a-2]+，我们希望得到点号分隔的子域名序列，首先要匹配第一个子域名。
之后其他的子域名以点号开头。用正则表达式来表示，就是[a-z]+（\.[a-z]+)*。现在，
如果我希望添加上前面出现的各种标记，就得到“a-z]+（\.[a-z]+)*，显然它看起来非常
熟悉，对吗？
为了说明这种相似性，我们尝试把它对应到双引号字符串的例子。如果我们认为字符串是
"."’之内的文本，包括normal部分[^\\"]，由special部分\\.i分隔，就能套用消
除循环的解法，得到[^\\"]+（\\.[^\\"]+)*"中，也就是在讨论方法1中的某个地步。
也就是说，从概念上讲，我们能够把由点号分隔的主机名的问题看成双引号字符事的问题，
用前面用过的套路。
二者既存在相似性，也存在区别。在方法1中，我们改变正则表达式是为了容许normal部
分和special部分之后出现空白，但是这里不容许出现空白。所以虽然这个例子与之前的并
非完全相同，但也属于同一类，同样可以用来证明消除循环的技巧的强大和便捷。
---
## Page 294
268
第6章：打造高效正则表达式
子域名的例子与之前的例子有两大区别：
·域名的开始和结束没有分界符。
子域名的normal部分不可能为空（也就是说两个点号不能紧挨在一起，点号也不能出
现在整个域名的开头或结尾）。对双引号字符串来说，normal部分可以为空，即使按照
我们的假设它们不太应该为空。所以我们需要把[\\"]改为[\\"]。而子域名
的例子不能进行这种修改，因为special部分是分隔符，必须出现。
观察
Obseroations
回过头来看双引号字符串的例子，表达式"[^\\"]*（\\.[^\\"]*)*"有许多优点，也存在
一些陷阱。
陷阱：
可读性这是最大的问题，原来的-（[^\\"]！\\.）*"可能更容易一眼看懂，我们放弃
了可读性来追求效率。
可维护性可维护性可能更复杂，因为任何改动都必须保持对两个[^\\"相同。我们
牺牲了可维护性来追求效率。
好处：
·速度如果不能匹配，或是采用POSIXNFA，这个正则表达式不会进人无休止匹配。
因为进行了精心地调校，特定的文本只能以唯一的方式匹配，如果文本不能匹配，引
擎会迅速发现它。
还是速度正则表达式“操作连续性（flow）”很好，这也是“流畅运转的正则表达式”
（?277）的主题。我对传统型NFA进行了检测，消除循环之后的表达式总是比之前
使用多选结构的表达式要快得多。即使匹配能够成功，不会进人无休止匹配状态时，
也是如此。
使用固化分组和占有优先量词
UlsingAtomicGroupingandPossessioeQuantifiers
表达式"（\\.1[^\\"]+）*"之所以会进入无休止匹配的状态，问题在于，如果无法匹配，
它会陷人徒劳的尝试。不过，如果存在匹配，就能很快结束，因为~\"]+能够匹配目标
字符串中的大多数字符（也就是之前讨论过的normal部分）。因为!]+通常会为速度优
化（247），而且能够匹配大多数字符，外面的（)*量词的开销因此大为减少。
---
## Page 295
消除循环
269
所以，（\\.！[~\\"]+)*"的问题就在于，不会在匹配时会陷人徒劳的尝试，在我们知道
毫无用处的备用状态之中不断回溯。我们知道这些状态基无价值，因为他们只是检查同样
对象的不同排列（如果'abci不能匹配foo”，那么‘abci或者abc)（以及'abc，abci或者
无论什么形式的abci）都不能匹配。如果我们能抛弃这些状态，正则表达式就能迅速报告
匹配失败）。
抛弃（或者是忽略）这些状态的方法有两种：固化分组（139）或者占有优先量词（142）。
在我们着手消除回溯以前，我希望交换多选分支的顺序，把“"（\\.1[^\\"]+)*"变为
“"（“^\\"]+1\\.)*"，这样匹配“普通”文本的元素就出现在第一位。前几章中我们已经
数次提到过，如果两个或两个以上的多选分支能够在同一位置匹配，排列顺序的时候就要
小心，因为顺序可能影响到匹配的结果。但对于本例来说，不同多选分支匹配的是不同的
文本（某个多选分支在一处能够匹配，则其他多选分支在此处就不能匹配），从正确匹配的
角度来看，顺序就是无关紧要的，所以我们可以根据清晰或效率的要求来选择顺序。
使用占有优先量词避免无休止匹配
会造成无休止匹配的表达式“（{^\\"]+1\\.)*"有两个量词。我们可以把其中一个改为占
有优先量词，或者两个都改。这两者有区别吗？因为大多数回溯的麻烦源自“]+留下的
状态，所以把它改成占有优先是我的第一想法。这样得到的表达式，即使找不到匹配，速
度也很快。不过，把外面的（）*改成占有优先会抛弃括号内的所有备选状态，其中包括
[+和多选结构本身的备选状态，所以如果我要从中选取一个的话，我会选取后者。
但我们并非只能选择一个，因为我们可以把两个都改为占有优先量词。具体哪种办法最快，
可能取决于占有优先量词的优化情况。现在，只有Sun的Javaregexpackage支持这种表示
法，所以我的测试只能在Java中进行，并且发现某些情形下其中一种组合更快。我原本期
望，使用两个占有优先量词是最快的，所以这些结果让我相信，Sun的优化还不够彻底。
使用固化分组避免无休止匹配
如果要对（（^\\"]+1\\.）*"使用固化分组，最容易想到的办法就是把普通括号改成固化
分组括号："（?>[^\\"]+1\\.）*"。不过我们必须知道，在抛弃状态的问题上，（？>）*
与占有优先的（)*+是迥然不同的。
---
## Page 296
270
第6章：打造高效正则表达式
(…）*+在完成时不会留下任何状态，相反，（?>…！)*只是消除多选结构每次选代时
保留的状态。星号是独立于固化分组的，所以不受影响，这个表达式仍然会保留“跳过本
轮迭代”的备用状态。也就是说，回溯中的状态仍然不是确定的最终状态。我们希望同时
消除外面量词的备用状态，所以要把外面的括号也改成固化分组。也就是说模拟占有优先
（….·…….）*+必须用到（？>（…1….)*）：。
解决无休止匹配的问题时，（·）*+和（？>）*都很有用，但是它们在抛弃状态的选
择和时间上却是不同的（更多的差异，请参阅173页）。
简单的消除循环的例子
Short Ulnrolling Examples
现在我们大概了解了消除循环的思想，来看看书中曾经出现过的几个例子，想想该如何消
除循环。
消除“多字符”引文中的循环
在第4章第167页，我们看到这个例子：
#匹配开头的
#现在匹配尽可能多的..
（？！）#如果不是也不是
#任何字符都没问题
) *
#（匹配优先量词）
#直到结束边界
normal部分是[^）
#匹配开头的
(?>[~
#任意数量的.
（？！）#如果不是也不是
>
#匹配special“
[^
#最后匹配结尾的
这里固化分组并不是必须的，但如果只能部分匹配，使用固化分组能够提高速度。
消除连续行匹配例子中的循环
连续行的例子出现在前一章的开头（186），当时使用的表达式是\w+=（[\n\\]I\\.）*
看起来这很适合应用这种技巧：
\W+=
#开头的文字和'=
#现在读取（并且捕获）值..，
（
(?>[^\n\\]*）
#*normal"*
（？>\\.[^\n\\]*）*
.o）#
---