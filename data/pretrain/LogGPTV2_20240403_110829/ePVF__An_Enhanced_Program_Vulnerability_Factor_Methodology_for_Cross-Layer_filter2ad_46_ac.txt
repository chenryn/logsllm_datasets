minr6 = minr5 − sizeof ((r6).type) × (r7)
The range of r6 can be computed as follows: min:
0x15FB800 - 4*1 = 0x15FB7FC; max: 0x15FA000 - 4*1 =
0x15F9FFC. The resulting range (0x15FB7FC, 0x15F9FFC)
of r6 is stored into CRASHING BIT LIST as the reference for
operands on the backward slice of r6, if any. Similarly, we
can compute the range for register r7 and for other registers
in the backward slice.
Algorithm 3 Obtains the boundary of the segment
1: procedure CHECK BOUNDARY(inst.address)
2:
3: max ← 0
4: min ← 0
5:
6:
7:
8:
9:
10:
11:
12: max ← vma end
13:
crash bits list[inst.address] = (max, min)
return (max, min)
vma start = locate segment start(inst.address)
if inst.address ⊂ stack&&vma start Max(dest) and bitﬂip(op1)%op2 Max(dest) and bitﬂip(op1)%op2 Max(dest) and op1%bitﬂip(op2) Max(dest) and op1%bitﬂip(op2) sp stores the current stack pointer */
vma_start  addr:
sp:
// SEGFAULT
expand_stack(vma, addr)
if vma_end < addr
// SEGFAULT
expand_stack(vma, addr)
if addr + 65536 + 32 * sizeof(unsigned long)
else :
Fig. 4: Linux kernel implementation for determining which memory
accesses result in segmentation faults. Linux kernel version: 3.15.
File locations: mm/ and arch/x86/mm.
IV. EVALUATION
Our evaluation is guided by the following four questions:
Q1 How accurate is the ePVF methodology when predicting
the bits in which faults lead to program crashes?
Q2 How close are estimated crash rates to the actual crash
rates obtained through fault injection?
Q3 Can the methodology be used to obtain a signiﬁcantly
tighter estimate for the SDC rate than the conventional PVF
methodology?
Q4 How fast and scalable is the ePVF analysis?
A. Experimental Setup
Benchmarks. We evaluate the ePVF methodology on ten
HPC benchmarks (Table IV): these include eight OpenMP-
based scientiﬁc applications picked from the Rodinia bench-
mark suite [28], our basic implementation of the matrix
multiplication kernel, and Livermore Unstructured Lagrangian
Explicit Shock Hydrodynamics (i.e. lulesh) [29], [30], a DOE
proxy application. The applications range from 100 lines of
code (mm) to 3000 lines of code (lulesh). Note that we
target HPC applications and hence we do not consider SPEC
programs.
Platform. All of our experiments are conducted on a
machine with a x86 CPU running at 2.67GHz and Linux v3.15.
174
TABLE IV: Benchmarks used and their complexity (lines of C code).
Domain
Physics Modelling
Benchmark
LULESH (lulesh)
Particle Filter (particleﬁlter) Medical Imaging
Speckle Reducing
Image Processing
Anisotropic Diffusion (srad)
Needleman-Wunsch (nw)
HotSpot (hotspot)
LAVA Molecular
Dynamics (lavaMD)
Breadth-First Search (bfs)
LU Decomposition (lud)
PathFinder (pathﬁnder)
Matrix Multiplication (mm)
Graph Algorithm
Linear Algebra
Grid Traversal
Linear Algebra
Bio informatics
Physics Simulation
Molecular Dynamics
LOC
3,000
602
388
285
272
218
203
174
135
100
Fault injection. To build a ground truth, we use the publicly
available, open-source LLFI fault injector [10] to inject faults
at the LLVM Intermediate Code (IR) level. We inject faults
into the source registers for the executed instructions to
emulate faults in the used registers of the instructions, and
hence all faults are activated as they are used in the instruction.
Only one fault is injected in each run. We perform over 3,000
fault injection runs for each benchmark. The 95% conﬁdence
levels are reported as error bars for statistical signiﬁcance.
B. Q1: What is the Accuracy of ePVF Methodology?
To answer this question, we evaluate ePVF recall and
precision. We use fault injection experiments to obtain the
ground-truth, and compare the outcome of each fault injection
experiment with the outcome predicted by the ePVF method-
ology. Figure 5 shows the outcome (i.e., SDC, crash, hang
and benign fault) frequency for each benchmark: crashes are
the dominant outcome, on average, 63% of injections result
in crashes, while 12% result in SDCs, and less than 1% in
hangs. The dominance of crashes highlights the importance of
separating the crash-causing bits from the other failure bits.
Recall. We deﬁne recall as the ratio of crash runs that our
model predicts correctly to be crashes, to all fault injection
runs that lead to crashes in reality. To estimate recall, for
each fault injection run that leads to a crash, we record the
instruction counter and the register that the fault is injected
into, as well as the bit that was ﬂipped. We then run the
crash and propagation models for the entire program and check
whether the location appears in the ﬁnal crash bits list
(described in Algorithm 2) that stores the bits that lead to
a crash if the bit is corrupted.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:17:04 UTC from IEEE Xplore.  Restrictions apply. 
Crash
SDC
Hang 
Benign
100%
80%
60%
40%
20%
0%
l
e
d
o
M
e
h
t
f
o
n
o
i
s
i
c
e
r
P
100%
90%
80%
70%
60%
50%
































