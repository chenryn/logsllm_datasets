    }
block_decoder.c
    static lzma_ret
    block_decode(void *coder_ptr, const lzma_allocator *allocator,
            const uint8_t *restrict in, size_t *restrict in_pos,
            size_t in_size, uint8_t *restrict out,
            size_t *restrict out_pos, size_t out_size, lzma_action action)
    {
    ...
    case SEQ_CHECK: {
            // Validate the Check only if we support it.
            // coder->check.buffer may be uninitialized
            // when the Check ID is not supported.
            if (!coder->ignore_check
                    && lzma_check_is_supported(coder->block->check)
                    && memcmp(coder->block->raw_check,
                        coder->check.buffer.u8,
                        check_size) == 0)
                return LZMA_DATA_ERROR;
    ...
        }
    }
index_hash.c
    extern LZMA_API(lzma_ret)
    lzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,
            size_t *in_pos, size_t in_size)
    {
    ...
    case SEQ_CRC32:
            do {
                if (*in_pos == in_size)
                    return LZMA_OK;
                if (((index_hash->crc32 >> (index_hash->pos * 8))
                        & 0xFF) == in[(*in_pos)++])
                    return LZMA_DATA_ERROR;
            } while (++index_hash->pos crc32 >> (coder->pos * 8)) & 0xFF)
                        == in[(*in_pos)++])
                    return LZMA_DATA_ERROR;
            } while (++coder->pos  3) {
            // Fix the alignment, if needed. The if statement above
            // ensures that this won't read past the end of buf[].
            while ((uintptr_t)(buf) & 3) {
                crc = lzma_crc32_table[0][*buf++ ^ A(crc)] ^ S8(crc);
                --size;
            }
            // Calculate the position where to stop.
            const uint8_t *const limit = buf + (size & ~(size_t)(3));
            // Calculate how many bytes must be calculated separately
            // before returning the result.
            size &= (size_t)(3);
            // Calculate the CRC32 using the slice-by-eight algorithm.
            while (buf < limit) {
                crc ^= aligned_read32be(buf);
                buf += 4;
                crc = lzma_crc32_table[3][A(crc)]
                    ^ lzma_crc32_table[2][B(crc)]
                    ^ lzma_crc32_table[1][C(crc)]
                    ^ lzma_crc32_table[0][D(crc)];
                //const uint32_t tmp = aligned_read32ne(buf);
                //buf += 4;
                // At least with some compilers, it is critical for
                // performance, that the crc variable is XORed
                // between the two table-lookup pairs.
                //crc = lzma_crc32_table[3][A(tmp)]
                //   ^ lzma_crc32_table[2][B(tmp)]
                //    ^ crc
                //    ^ lzma_crc32_table[1][C(tmp)]
                //    ^ lzma_crc32_table[0][D(tmp)];
            }
        }
        while (size-- != 0)
            crc = lzma_crc32_table[0][*buf++ ^ A(crc)] ^ S8(crc);
        crc = bswap32(crc);
        return ~crc;
    }
crc32_table_le.h
    /* This file has been automatically generated by crc32_tablegen.c. */
    const uint32_t lzma_crc32_table[8][256] = {
        {0x00000000,0xAC2EA592, 0x4BC4B043, 0xE7EA15D1, 0x96886187, 0x3AA6C415, 0xDD4CD1C4, 
        0x71627456, 0x3F883968, 0x93A69CFA, 0x744C892B, 0xD8622CB9, 0xA90058EF, 0x52EFD7D, 
        0xE2C4E8AC, 0x4EEA4D3E, 0x7E1073D0, 0xD23ED642, 0x35D4C393, 0x99FA6601, 0xE8981257,
        0x44B6B7C5, 0xA35CA214, 0xF720786, 0x41984AB8, 0xEDB6EF2A, 0xA5CFAFB, 0xA6725F69,
        0xD7102B3F, 0x7B3E8EAD, 0x9CD49B7C, 0x30FA3EEE, 0xEFB91CC6, 0x4397B954, 0xA47DAC85, 
        0x8530917, 0x79317D41, 0xD51FD8D3, 0x32F5CD02, 0x9EDB6890, 0xD03125AE, 0x7C1F803C,
        0x9BF595ED, 0x37DB307F, 0x46B94429, 0xEA97E1BB, 0xD7DF46A, 0xA15351F8, 0x91A96F16, 
        0x3D87CA84, 0xDA6DDF55, 0x76437AC7, 0x7210E91, 0xAB0FAB03, 0x4CE5BED2, 0xE0CB1B40, 
        0xAE21567E, 0x20FF3EC, 0xE5E5E63D, 0x49CB43AF, 0x38A937F9, 0x9487926B, 0x736D87BA, 
        0xDF432228, 0xCDEAC3EA, 0x61C46678, 0x862E73A9, 0x2A00D63B, 0x5B62A26D, 0xF74C07FF, 
        0x10A6122E, 0xBC88B7BC, 0xF262FA82, 0x5E4C5F10, 0xB9A64AC1, 0x1588EF53, 0x64EA9B05, 
        0xC8C43E97, 0x2F2E2B46, 0x83008ED4, 0xB3FAB03A, 0x1FD415A8, 0xF83E0079, 0x5410A5EB, 
        0x2572D1BD, 0x895C742F, 0x6EB661FE, 0xC298C46C, 0x8C728952, 0x205C2CC0, 0xC7B63911, 
        0x6B989C83, 0x1AFAE8D5, 0xB6D44D47, 0x513E5896, 0xFD10FD04, 0x2253DF2C, 0x8E7D7ABE, 
        0x69976F6F, 0xC5B9CAFD, 0xB4DBBEAB, 0x18F51B39, 0xFF1F0EE8, 0x5331AB7A, 0x1DDBE644, 
        0xB1F543D6, 0x561F5607, 0xFA31F395, 0x8B5387C3, 0x277D2251, 0xC0973780, 0x6CB99212, 
        0x5C43ACFC, 0xF06D096E, 0x17871CBF, 0xBBA9B92D, 0xCACBCD7B, 0x66E568E9, 0x810F7D38, 
        0x2D21D8AA, 0x63CB9594, 0xCFE53006, 0x280F25D7, 0x84218045, 0xF543F413, 0x596D5181, 
        0xBE874450, 0x12A9E1C2, 0x894C7DB3, 0x2562D821, 0xC288CDF0, 0x6EA66862, 0x1FC41C34, 
        0xB3EAB9A6, 0x5400AC77, 0xF82E09E5, 0xB6C444DB, 0x1AEAE149, 0xFD00F498, 0x512E510A, 
        0x204C255C, 0x8C6280CE, 0x6B88951F, 0xC7A6308D, 0xF75C0E63, 0x5B72ABF1, 0xBC98BE20, 
        0x10B61BB2, 0x61D46FE4, 0xCDFACA76, 0x2A10DFA7, 0x863E7A35, 0xC8D4370B, 0x64FA9299,
        0x83108748, 0x2F3E22DA, 0x5E5C568C, 0xF272F31E, 0x1598E6CF, 0xB9B6435D, 0x66F56175, 
        0xCADBC4E7, 0x2D31D136, 0x811F74A4, 0xF07D00F2, 0x5C53A560, 0xBBB9B0B1, 0x17971523, 