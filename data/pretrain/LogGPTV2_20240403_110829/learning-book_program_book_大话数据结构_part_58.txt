HeapAdjust（L，1,i-1）;/*将L->r[1..i-1]重新调整为大项堆*/
10
11)
从代码中也可以看出，整个排序过程分为两个for循环。第一个循环要完成的就
是将现在的待排序序列构建成一个大顶堆。第二个循环要完成的就是逐步将每个最大
值的根结点与末尾元素交换，并且再调整其成为大顶堆。
假设我们要排序的序列是{50,10,90,30.70,40,80,60,20}27，那么Length=9，第一
个for循环，代码第4行，1是从L9/2]=4开始，4→3→2→1的变量变化。为什么不
注”：这里把每个数字乘以10，是为了与下标的个位教字进行区分，因为我们在讲解中，会大量的提到数组下标的数
字。
399
---
## Page 424
大据数据结构
是从1到9或者从9到1，而是从4到1呢？其实我们看了图9-7-5就明白了，它们
都有什么规律？它们都是有孩子的结点。注意灰色结点的下标编号就是1、2、3、4。
60
图9-7-5
我们所谓的将待排序的序列构建成为一个大顶堆，其实就是从下往上、从右到
左，将每个非终端结点（非叶结点）当作根结点，将其和其子树调整成大顶堆。i的4
→3一2→1的变量变化，其实也就是30，90，10、50的结点调整过程。
既然已经弄清楚1的变化是在调整哪些元素了，现在我们来看关键的HeapAdjust
（堆调整）函数是如何实现的。
/已知L->r[8.,m]中记录的关键字除L->r[s]之外均满足堆的定义*/
/本函数调整L->r[s]的关键字，使L->r[s..m]成为一个大顶堆*/
1void HeapAdjust（SqList*L,int s,intm)
2
int temp,j;
4
temp=L->r[s];
for（j=2*s;jr[j]r[j+1])
8
++j:
1为关键字中较大的记录的下标·/
9
if（temp>=L->r[51)
10
break;
/rC应插入在位置s上·/
11
[5]m，因此跳出循环。
8.第14行，将temp=30赋值给Lr[s]=Lr[8]，完成30与60的交换工作。如图
9-7-7所示。本次函数调用完成。
401
---
## Page 426
大语数据结构
下标
下标
501090607040803020
图9-7-7
9.再次调用HeapAdjust，此时s=3，m=9。第4行，temp=Lr[3]=90，第7~8
行，由于4080，因此退出循
环，最终本次调用，整个序列未发什么改变。
10.再次调用HeapAdjust，此时s=2，m=9。第4行，temp=Lr[2]=10，第7~8
行，60length;i>l;1--)
8
swap（L，1，1）：/·将堆顶记录和当前未经排序子序列的最后一个记录交换/
9
HeapAdjust（L,1,i-1）：/*将L->r[1..i-1]重新调整为大项堆·/
10}
1.当i=9时，第8行，交换20与90，第9行，将当前的根结点20进行大顶堆
的调整，调整过程和刚才流程一样，找到它左右子结点的较大值，互换，再找
到其子结点的较大值互换。此时序列变为（80,70,50,60,10,40,20,30,90}，如图
9-7-10所示。
90
图9-7-10
2.当i=8时，交换30与80，并将30与70交换，再与60交换，此时序列变为
{70,60,50,30,10,40,20,80,90}，如图9-7-11所示。
80
70
50
80
图9-7-11
404
---
## Page 429
第9章排序
3.后面的变化完全类似，不解释，只看图（图9-7-12）。
70
80
90
10
50
60
70
80
90
10
20
30
50
60
70
90
图9-7-12
最终就得到一个完全有序的序列了。
9.7.2堆排序复杂度分析
堆排序的效率到底有多高呢？我们来分析一下。
它的运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上。
在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端结点开始构
405
---
## Page 430
大适数据结构
建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点来说，其实最多
进行两次比较和互换操作，因此整个构建堆的时间复杂度为0[n）。
个结点到根结点的距离为[ogzi]+1），并且需要取n-1次堆顶记录，因此，重建堆
的时间复杂度为O（nlgn）。
所以总体来说，堆排序的时间复杂度为0（nlgn）。由于堆排序对原始记录的排序
状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为O（nlogr）。这在性能
上显然要远远好过于冒泡、简单选择、直接插入的0（n2）的时间复杂度了。
空间复杂度上，它只有一个用来交换的暂存单元，也非常的不错。不过由于记录
的比较与交换是跳跃式进行，因此堆排序也是一种不稳定的排序方法。
另外，由于初始构建堆所需的比较次数较多，因此，它并不适合待排序序列个数
较少的情况。
9.8归并排序
前面我们讲了堆排序，因为它用到了完全二叉树，充分利用了完全二叉树的深度
是[bgzn”+1的特性，所以效率比较高。不过堆结构的设计本身是比较复杂的，老实
说，能想出这样的结构就挺不容易，有没有更直接简单的办法利用完全二叉树来排序
呢？当然有。
先来举一个例子。你们知道高考一本、二本、专科分数线是如何划分出来的吗？
简单地说，如果各高校本科专业在某省高三理科学生中计划招收1万名，那么将
全省参加高考的理科学生分数倒排序，第1万名的总分数就是当年本科生的分数线
（现实可能会比这复杂，这里简化之）。也就是说，即使你是你们班级第一、甚至年级
第一名，如果你没有上分数线，则说明你的成绩排不到全省前1万名，你也就基本失
去了当年上本科的机会了。
换句话说，所谓的全省排名，其实也就是每个市、每个县、每个学校、每个班级
的排名合并后再排名得到的。注意我这里用到了合并一词。
我们要比较两个学生的成绩高低是很容易的，比如甲比乙分数低，丙比丁分数
注”：关于堆排序算法更详细讲解，请参考《翼泌导论》第二部分第六章“堆排序”的内客。
406
---
## Page 431
第9章排序
低。那么我们也就可以很容易得到甲乙丙丁合并后的成绩排名，同样的，戊已庚辛
的排名也容易得到，由于他们两组分别有序了，把他们八个学生成绩合并有序也是
很容易做到的了，继续下去最终完成全省学生的成绩排名，此时高考状元也就诞
生了。
为了更清晰地说清楚这里的思想，大家来看图9-8-1所示，我们将本是无序的数
组序列{16,7,13,10,9,15,3,2,5,8,12,1,11,4,6,14}，通过两两合并排序后再合并，最终获
得了一个有序的数组。注意仔细观察它的形状，你会发现，它像极了一棵倒置的完全
二叉树，通常涉及到完全二叉树结构的排序算法，效率一般都不低的—这就是我们
要讲的归并排序法。
16
13
10
12
1
11
4
5
11
7101316
23915
15812
461114
237910131516
14 568111214
12345678910111213141516
图9-8-1
9.8.1归并排序算法
归并”一词的中文含义就是合并、并入的意思，而在数据结构中的定义是将两个
或两个以上的有序表组合成一个新的有序表。
归并排序（MergingSort）就是利用归并的思想实现的排序方法。它的原理是假
设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为
1，然后两两归并，得到[n/21（[x1表示不小于x的最小整数）个长度为2或1的有
序子序列；再两两归并，，如此重复，直至得到一个长度为n的有序序列为止，
这种排序方法称为2路归并排序。29
好了，有了对归并排序的初步认识后，我们来看代码。
/对顺序表L作归并换序*/
注”：本书只会绍2路归并排序。
407
---
## Page 432
大语数保结构
MSort（L->r,L->r,1,L->length）;
一句代码，别奇怪，它只是调用了另一个函数面已。为了与前面的排序算法统
一，我们用了同样的参数定义SqList*L，由于我们要讲解的归并排序实现需要用到递
归调用3，因此我们外封装了一个函数。假设现在要对数组
{50,10,90,30,70,40,80,60,20}进行排序，Llength=9，我现来看看MSort的实现。
/将SR[5..t]归并排序为TR1[s..t]*/
1void MSort（int SR[],int TR1[],int s,int t）