has been recovered (see Algorithm 1).
Experimentally, we determined that this attack succeeds with
881 AES invocations on average (over 1000 runs with random keys,
minimum: 306, maximum: 3346), given a deterministic, noise-free
strlen() oracle. Note that this attack could also be adapted to work
with noisy measurements, using the so-called zero-value model
known from hardware side-channel attacks [12]. Besides, the attack
would also be applicable when targeting the first round of the AES
in a known-plaintext scenario.
Properly closing this side-channel requires profound changes in
the way edger8r works. Notably, the bridge code includes an lfence
instruction at line 11 to rule out advanced Spectre-v1 misspecula-
tion attacks that might still speculatively compute on unchecked
pointers before they are architecturally rejected. However, our
attack is immune to such countermeasures because we directly
observe side effects of normal, non-speculative execution. Further,
early rejecting the ecall when detecting that the start pointer falls
inside the enclave does not suffice in general. In such a case, adver-
saries might still pass pointers below the enclave base address, and
observe secret-dependent behavior based on the first bytes of the
enclave. Intel implemented our recommended mitigation strategy
by dropping support for the superfluous [sizefunc] EDL attribute
entirely, and further abstaining from computing untrusted buffer
sizes inside the enclave. Instead, alleged buffer sizes are computed
outside the enclave, and passed as an untrusted argument, such that
the CHECK_UNIQUE_POINTER test can take place immediately. For the
strlen() case, the untrusted memory can simply be copied inside,
and an extra null byte inserted at the alleged end. This solution con-
veniently moves all secret-dependent control flow from the enclave
into the untrusted application context.
Microsoft Open Enclave SDK. After Intel had properly patched
the strlen() side-channel vulnerability in the SGX-SDK, OE ap-
pears to have tried to adopt our proposed mitigation strategy of
passing an untrusted alleged string length into the enclave. How-
ever, after reviewing the generated code, we found that oeedger8r
fails to include a 0x00 terminator byte after copying the untrusted
string inside enclave memory (cf. Appendix A.6). This critical over-
sight can be exploited to trick the shielded enclave application into
operating on non-null-terminated strings. The trusted user function
will incorrectly assume that the string is properly terminated and
may perform out-of-bounds memory read/writes, hence turning a
mitigation for a subtle and functionally correct side-channel issue
into a more dangerous source of enclave memory corruption. This
OE vulnerability is tracked via CVE-2019-0876 and specific to en-
claves that expect EDL string arguments, and output or manipulate
them in-place (e.g., strcpy()).
We experimentally demonstrated this vulnerability by means
of a minimal PoC application enclave which overwrites all non-
alphanumeric chars in a string with 0x20, until the null terminator
is encountered. If this enclave operates on an unterminated string,
the length field of the subsequent heap frame is corrupted, which
subsequently can be further leveraged in more complex exploits.
5.3 Validating variable-sized buffers
Multi-byte input buffers are commonly specified by passing a pointer
to the start of the buffer and an associated size. In order to properly
validate such buffers, the trusted runtime should first compute the
end pointer by adding the alleged size argument, and thereafter
assert that the complete input buffer address range falls outside the
enclave. However, since the buffer size is an adversary-controlled
EnclaveIRQ1encryptString(){		aesenc	k[8],	%xmm0		aesenc	k[9],	%xmm0		//Interruption		aesenclast	k[10],%xmm0}SSAThread ATHREAD ATHREAD B4Ecall (SSA_frame+ XMM0_OFFSET)2AEX Thread AHost ApplicationEdger8rEcall(msg){		...		strlen(msg)}Ecall (message)SSAThread B5AEX Thread B3Conﬁgtimer6Check accessed bitHardwareparameter, care should be taken to prevent the pointer addition
from overflowing and silently wrapping around the address space.
Attack vector #6 (integer overflow): Runtimes should use safe arith-
metics when computing addresses in a buffer with untrusted size. ▷ Rela-
tively well-understood in production SDKs, not in research code.
TEE design. We found that the address-related vulnerabilities
in this section are significantly more exploitable in TEE designs
that provide increased attacker control over the shared memory
and enclave memory layouts. For instance, some integer overflow
vulnerabilities require the adversary to control the enclave base
address in a shared address space, as is the case for the Intel SGX [8]
and Sancus [32] designs, but not for ARM TrustZone [34] or Key-
stone [21]. Further, we found that logical errors may arise when
checking variable sized buffers in a shared address space. As de-
tailed below, the exploitability of such logic bugs depends heavily
on the ability of the adversary to trigger certain edge cases (e.g.,
passing a pointer that lies just before the enclave base address),
which might also be considerably easier in single-address space
TEE designs like Intel SGX or Sancus.
Fortanix Rust-EDP. In contrast to the other runtimes described
in this paper, Fortanix’s EDP [11] leverages the type system of
the safe Rust language to disallow inadvertent untrusted pointer
dereferences apart from the dedicated UserSafe type, which trans-
parently sanitizes any pointers passed into the enclave. Rust-EDP’s
shielding system has been explicitly designed to avoid known en-
clave boundary attacks and implements libOS-like functionality
through a deliberately very narrow ocall interface that is kept
invisible to the application programmer. However, our analysis
shows that the promising approach of enforcing pointer sanitiza-
tion through the use of a type system may evidently still suffer from
security issues if the implementation in the type itself is incorrect.
We manually scrutinized the implementation of the confined
UserSafe type (part of the Rust compiler’s SGX-EDP target [11])
and found a potentially exploitable integer overflow vulnerability
in the pointer validation logic. Listing 4 shows the relevant is_use
r_range() function, which checks whether an untrusted memory
range specified by a pointer and length falls completely outside the
enclave. Concretely, we observed that the 64-bit integer addition to
compute the end pointer at line 4 may overflow. Note that Rust can
automatically detect integer overflows, but these runtime checks
are only enabled in debug mode, meaning that in production builds
(e.g., rustc -C debug-assertions=off), integer overflows do not
cause an error by default [25].
We confirmed (after isolating the validation function in a dummy
Rust test program) that said function can be made to early-out
and return true at line 5 even when passing an illegal in-enclave
pointer if the enclave base is near the top of the address space.
Note that Intel SGX leaves the enclave base address under explicit
attacker control [8], so this requirement may be satisfied by real-
world attackers. For example, the untrusted runtime can return
a specially-crafted pointer from the alloc() usercall, potentially
leading to in-enclave memory disclosure or corruption, depending
on how the pointer is further used within the enclave. After our
disclosure, the EDP trusted runtime now explicitly asserts that
untrusted sizes returned by alloc() do not overflow.
1 // / `true ` if the specified memory range is in userspace .
2 pub fn is_user_range (p: * const u8 , len : usize ) -> bool {
3
4 ⭑ let end = start + ( len as u64 );
5
end = image_base () + ( unsafe {
let start = p as u64 ;
ENCLAVE_SIZE } as u64 ) // unsafe ok : link - time constant
6 }
Listing 4: Pointer validation in the Rust-EDP UserSafe type.
Google Asylo. Apart from the aforementioned [user_check] is-
sues, the entry points in Asylo’s trusted runtime take care to vali-
date all second-level input buffers. However, our code review also
revealed a subtle logic mistake in the input validation logic itself.
That is, we observed that many of the trusted runtime functions (cf.
Appendix A.3 for a relevant sample) rely on the TrustedPrimitive
s::IsTrustedExtent(input,input_size) library function returning
true to reject the ecall attempt when detecting that an untrusted
input buffer is completely contained within enclave memory.
While this function itself translates to the corresponding sgx_is
_within_enclave() primitive from the SGX-SDK, which is indeed
correct and free from integer overflow vulnerabilities, the logic
mistake occurs when considering malicious input buffers that only
partly overlap with untrusted and enclave memory. For instance,
IsTrustedExtent() will properly return false and the ecall will
still be allowed when passing a lengthy adversarial input buffer
that starts one byte before the enclave base address but continues
into the enclave memory range. Evidently, this may subsequently
lead to trusted enclave memory corruption or disclosure. Hence,
the trusted runtime should instead make use of the proper sgx_is_
outside_enclave() SGX-SDK primitive.
Attack vector #7 (outside ≠ ¬inside): In a shared address space, input
buffers should not fall partially inside the trusted memory region. ▷ Gen-
erally understood in production SDKs, not always in research code.
Graphene-SGX. We discovered a critical integer overflow vul-
nerability in the widely used pointer range validation function
that often computes on untrusted attacker-provided sizes (simi-
lar to the Rust-EDP issue described above). We further found that
Graphene-SGX suffers from the same subtle logic mistake that we
spotted in the Asylo code base: at the time of our review, there
was no sgx_is_outside_enclave() primitive, and all instances of
the intended “abort if not completely outside” were erroneously
checked for “abort if completely inside enclave” (cf. Listing 5 for a
relevant sample). A related type of pointer validation vulnerabili-
ties arises when the libOS allocates variable-sized output buffers in
untrusted memory outside the enclave to be able to exchange data
for ocall arguments and return values. For performance reasons,
Graphene-SGX allocates such shared memory buffers directly on
the untrusted host stack. While the untrusted host stack pointer
is indeed validated to lie outside of enclave memory upon enclave
entry, we observed that the trusted libOS does not properly check
whether the untrusted stack does not overflow into enclave memory
after allocating a new shared memory buffer in the widely used OC
ALLOC macro. Depending on the specific ocall implementation, the
enclave will subsequently copy data to/from the inappropriately
allocated buffer, leading to information disclosure and/or memory
corruption.
Keystone. While Keystone [21] is still a research prototype and
lacked essential functionality when we reviewed its code, we dis-
covered and reported a potential integer overflow vulnerability (cf.
Appendix A.7) in the trusted security monitor’s detect_region_ove
rlap() function, which is used during the creation of an enclave.
However, this overflow was not directly exploitable due to certain
restrictions on region sizes in the Keystone codebase.
Sancus. We found both logical errors and integer overflow vul-
nerabilities in the sancus_is_outside_sm() function provided by the
trusted runtime. Particularly, the current implementation does not
properly detect an untrusted buffer that spans the entire enclave
address range, or a carefully crafted length specifier that triggers
an integer overflow to wrap around the 16-bit address space.
5.4 Pointer-to-pointer validation pitfalls
While the previous sections have focussed on the spatial aspect of
untrusted pointer dereferencing, we also found more subtle vulner-
abilities related to the temporal aspect. That is, whenever a pointer
points to an untrusted address or size (as it is often the case, for
instance, in marshalling structs), the runtime should take care to
first copy the second-level pointer value to a trusted location in
enclave memory before applying the sanitization logic. If this is
not the case, adversaries may overwrite the second-level pointer
in untrusted memory after the validation has succeeded but before
the pointer is dereferenced in the enclave code. This class of vul-
nerabilities is also referred to as “double fetch” bugs in operating
system kernels [37, 53].
Attack vector #8 (double fetch): Untrusted pointer values should be
copied inside the enclave before validation to avoid time-of-check time-of-
use. ▷ Relatively well-understood (once pointer sanitization is applied).
TEE design. Double fetch bugs typically rely on a very nar-
row vulnerability time window and hence can be notoriously hard
to exploit in traditional user-to-kernel contexts. However, recent
research demonstrated how some TEE design decisions may con-
siderably simplify exploitation of synchronization bugs in enclaves.
AsyncShock [50] exploits that Intel SGX adversaries may provoke
page faults in the enclaved execution, and SGX-Step [45] similarly
abuses that privileged SGX adversaries may abuse system timers to
very precisely interrupt a victim enclave after every single instruc-
tion. Finally, Schwarz et al. [37] use a cache side-channel to expose
double fetch bugs in both Intel SGX and ARM TrustZone TEEs.
Graphene-SGX. Scrutinizing Graphene-SGX’s ocall interface,
we found several instances of exploitable double fetch vulnerabili-
ties. Listing 5 provides a relevant code snippet that attempts to sani-
tize the result of the sock_accept system call. First, at line 1, a buffer
ms is allocated in untrusted memory outside the enclave. The struct
buffer pointed to by ms contains another pointer ms->ms_addr that
will be initialized by the untrusted runtime to point to the socket
address returned by the system call. As ms->ms_addr is an untrusted
pointer, the libOS shielding system attempts to properly validate
that it lies outside the enclave at line 5 (modulo the logic bug de-
scribed in Section 5.3) before dereferencing ms->ms_addr a second
time when copying the socket address buffer inside at line 11. How-
ever, since the parent ms struct was allocated in untrusted memory
and has never been copied inside, SGX adversaries can interrupt
1
2
3
4
5 ⭑
6
7
8
9
10
11 ⭑
OCALLOC (ms , ms_ocall_sock_accept_t *, sizeof (* ms ));
...
retval = SGX_OCALL ( OCALL_SOCK_ACCEPT , ms );
if ( retval >= 0) {
if ( len && ( sgx_is_within_enclave (ms -> ms_addr , len )
|| ms -> ms_addrlen > len )) {
OCALL_EXIT () ;
return - PAL_ERROR_DENIED ;
}
...
COPY_FROM_USER ( addr , ms -> ms_addr , ms -> ms_addrlen );
Listing 5: Double fetch vulnerability in Graphene-SGX.
the enclave in between lines 5 and 11 and trivially overwrite the ms
_addr field with an arbitrary in-enclave address, potentially leading
to trusted memory disclosure.
5.5 Validating ocall return values
Apart from validating ecall arguments, the enclave trusted runtime
should also take care to properly scrutinize ocall return values
when passing pointers or sizes back into the enclave.
Attack vector #9 (Iago): Pointers or sizes returned through ocalls
should be scrutinized [4]. ▷ Understood, but still prevalent in research
libOSs that shield system calls; one instance in a production SDK.
TEE design. We found that the complexity of the shielding sys-
tem may largely affect this attack surface. That is, SDK-based ap-
proaches typically do not feature a large built-in ocall interface,
whereas libOSs should safeguard against Iago attacks [4] by scruti-
nizing return values from the complex system call interface before
passing them on to the shielded application.
Microsoft Open Enclave SDK. OE’s trusted runtime includes
a oe_get_report() function which is used to provide attestation
functionality to the enclaved binary. Internally, this function per-
forms the same ocall twice; the first time specifying the output
buffer as a null pointer in order to obtain the required quote size.
Based on this size, a buffer is allocated on the enclave heap, and
subsequently filled through a second ocall invocation. We found,
however, that the untrusted runtime can return different sizes for
the two ocall invocations (tracked via CVE-2019-1369). Particularly,
the in-enclave buffer is allocated based on the size obtained from
the first ocall, whereas the size returned by the second ocall is
passed on to the caller of oe_get_report(). Hence, returning an un-
expectedly large size in the second ocall invocation may cause the
enclave application to read or write out of bounds. We experimen-
tally confirmed that OE’s remote attestation example enclave can
leak up to 10 kB of trusted heap memory (this upper bound is due
to an internal limit), possibly at multiple heap locations depending
on other memory allocations.
LibOS-based runtimes. We discovered several exploitable in-
stances of Iago attacks [4] in Graphene-SGX’s ocall interface. For
example, an untrusted system call return value len is later used
to copy len bytes from untrusted memory into a fixed-size buffer
inside the enclave, leading to arbitrary write-past the in-enclave
buffer. To demonstrate this vulnerability, we developed a PoC where
the readdir() system call in the untrusted runtime returns an un-
expected length, causing an out-of-bounds write in the enclave.
Similarly, in SGX-LKL’s ocall interface, we found several in-
stances of Iago vulnerabilities where for example the untrusted
pointers returned by mmap() are not checked to lie outside of en-
clave memory, or the untrusted length returned by write() is passed
unsanitized back to the shielded application. To demonstrate how
this can be successfully exploited, we developed an elementary
victim application featuring a common programming idiom where
write() is used to output a buffer piecewise, each time advancing
a pointer with the number of bytes successfully written (i.e., the
system call’s return value). We modified the untrusted runtime to
unexpectedly increment the return value of the write() system call,
causing the shielded application binary to output secret enclave
memory beyond the buffer bounds. Finally, we also confirmed and
reported the existence of similar issues in Google Asylo.
Keystone. Similar to the above SGX runtimes, Keystone pro-
vides system call wrappers to simplify porting of existing code to
an enclave. While Keystone documentation indicates that the de-
velopers are aware of potential issues, the codebase currently lacks
mitigations against Iago attacks. Hence, we developed an exploit
using the write() system call, similar to the SGX-LKL PoC.
5.6 Scrubbing uninitialized structure padding
Apart from pointers and size arguments, enclaves may also pass
composite struct types to the untrusted world. While, as with all
output buffers, we assume that enclave applications do not inten-