and events can be called from Windows PowerShell through the ScheduledTasks cmdlet (documented 
at https://docs.microsoft.com/en-us/powershell/module/scheduledtasks/). Note that the Task Scheduler 
includes a Compatibility plug-in, which allows legacy applications, like the AT command, to work with 
the Task Scheduler. In the May 2019 Update edition of Windows 10 (19H1), the AT tool has been de-
clared deprecated, and you should instead use schtasks.exe.
Initialization
When started by the Service Control Manager, the Task Scheduler service begins its initialization pro-
cedure. It starts by registering its manifest-based ETW event provider (that has the DE7B24EA-73C8-
4A09-985D-5BDADCFA9017 global unique ID). All the events generated by the Task Scheduler are con-
sumed by UBPM. It then initializes the Credential store, which is a component used to securely access 
the user credentials stored by the Credential Manager and the Task store. The latter checks that all the 
XML task descriptors located in the Task store’s secondary shadow copy (maintained for compatibility 
reasons and usually located in %SystemRoot%\System32\Tasks path) are in sync with the task descrip-
tors located in the Task store cache. The Task store cache is represented by multiple registry keys, with 
the root being HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache. 
The next step in the Task Scheduler initialization is to initialize UBPM. The Task Scheduler service uses 
the UbpmInitialize API exported from UBPM.dll for starting the core components of UBPM. The func-
tion registers an ETW consumer of the Task Scheduler’s event provider and connects to the Resource 
Manager. The Resource Manager is a component loaded by the Process State Manager (Psmsrv.dll, in the 
context of the Broker Infrastructure service), which drives resource-wise policies based on the machine 
state and global resource usage. Resource Manager helps UBPM to manage maintenance tasks. Those 
types of tasks run only in particular system states, like when the workstation CPU usage is low, when 
game mode is off, the user is not physically present, and so on. UBPM initialization code then retrieves 
the WNF state names representing the task’s conditions from the System Event Broker: AC power, Idle 
Workstation, IP address or network available, Workstation switching to Battery power. (Those conditions 
are visible in the Conditions sheet of the Create Task dialog box of the Task Scheduler MMC plug-in.)
UBPM initializes its internal thread pool worker threads, obtains system power capabilities, reads a 
list of the maintenance and critical task actions (from the HKLM\System\CurrentControlSet\Control\
Ubpm registry key and group policy settings) and subscribes to system power settings notifications 
(in that way UBPM knows when the system changes its power state). 
The execution control returns to the Task Scheduler, which finally registers the global RPC interfaces 
of both itself and UBPM. Those interfaces are used by the Task Scheduler API client-side DLL (Taskschd.dll) 
to provide a way for client processes to interact via the Task Scheduler via the Task Scheduler COM 
interfaces, which are documented at https://docs.microsoft.com/en-us/windows/win32/api/taskschd/.
478 
CHAPTER 10 Management, diagnostics, and tracing
After the initialization is complete, the Task store enumerates all the tasks that are installed in the 
system and starts each of them. Tasks are stored in the cache in four groups: Boot, logon, plain, and 
Maintenance task. Each group has an associated subkey, called Index Group Tasks key, located in the 
Task store’s root registry key (HKLM\ SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\
TaskCache, as introduced previously). Inside each Index Tasks group key is one subkey per each task, 
identified through a global unique identifier (GUID). The Task Scheduler enumerates the names of all 
the group’s subkeys, and, for each of them, opens the relative Task’s master key, which is located in the 
Tasks subkey of the Task store’s root registry key. Figure 10-26 shows a sample boot task, which has the 
{0C7D8A27-9B28-49F1-979C-AD37C4D290B1} GUID. The task GUID is listed in the figure as one of the 
first entries in the Boot index group key. The figure also shows the master Task key, which stores binary 
data in the registry to entirely describe the task.
FIGURE 10-26 A boot task master key.
The task’s master key contains all the information that describes the task. Two properties of the task 
are the most important: Triggers, which describe the conditions that will trigger the task, and Actions, 
which describe what happen when the task is executed. Both properties are stored in binary registry 
values (named “Triggers” and “Actions,”, as shown in Figure 10-26). The Task Scheduler first reads the 
hash of the entire task descriptor (stored in the Hash registry value); then it reads all the task’s configu-
ration data and the binary data for triggers and actions. After parsing this data, it adds each identified 
trigger and action descriptor to an internal list. 
CHAPTER 10 Management, diagnostics, and tracing
479
The Task Scheduler then recalculates the SHA256 hash of the new task descriptor (which includes 
all the data read from the registry) and compares it with the expected value. If the two hashes do not 
match, the Task Scheduler opens the XML file associated with the task contained in the store’s shadow 
copy (the %SystemRoot%\System32\Tasks folder), parses its data and recalculates a new hash, and 
finally replaces the task descriptor in the registry. Indeed, tasks can be described by binary data in-
cluded in the registry and also by an XML file, which adhere to a well-defined schema, documented at 
https://docs.microsoft.com/en-us/windows/win32/taskschd/task-scheduler-schema.
EXPERIMENT: Explore a task’s XML descriptor
Task descriptors, as introduced in this section, are stored by the Task store in two formats: XML 
file and in the registry. In this experiment, you will peek at both formats. First, open the Task 
Scheduler applet by typing taskschd.msc in the Cortana search box. Expand the Task Scheduler 
Library node and all the subnodes until you reach the Microsoft\Windows folder. Explore each 
subnode and search for a task that has the Actions tab set to Custom Handler. The action type 
is used for describing COM-hosted tasks, which are not supported by the Task Scheduler applet. 
In this example, we consider the ProcessMemoryDiagnosticEvents, which can be found under the 
MemoryDiagnostics folder, but any task with the Actions set to Custom Handler works well:
Open an administrative command prompt window (by typing CMD in the Cortana search 
box and selecting Run As Administrator); then type the following command (replacing the task 
path with the one of your choice): 
schtasks /query /tn "Microsoft\Windows\MemoryDiagnostic\ProcessMemoryDiagnosticEvents" /xml 
EXPERIMENT: Explore a task’s XML descriptor
Task descriptors, as introduced in this section, are stored by the Task store in two formats: XML
file and in the registry. In this experiment, you will peek at both formats. First, open the Task
Scheduler applet by typing taskschd.msc in the Cortana search box. Expand the Task Scheduler
Library node and all the subnodes until you reach the Microsoft\Windows folder. Explore each
subnode and search for a task that has the Actions tab set to Custom Handler. The action type
is used for describing COM-hosted tasks, which are not supported by the Task Scheduler applet.
In this example, we consider the ProcessMemoryDiagnosticEvents, which can be found under the
MemoryDiagnostics folder, but any task with the Actions set to Custom Handler works well:
Custom Handler works well:
Custom Handler
Open an administrative command prompt window (by typing CMD in the Cortana search 
box and selecting Run As Administrator); then type the following command (replacing the task 
path with the one of your choice): 
schtasks /query /tn "Microsoft\Windows\MemoryDiagnostic\ProcessMemoryDiagnosticEvents" /xml 
480 
CHAPTER 10 Management, diagnostics, and tracing
The output shows the task’s XML descriptor, which includes the Task’s security descriptor 
(used to protect the task for being opened by unauthorized identities), the task’s author and de-
scription, the security principal that should run it, the task settings, and task triggers and actions:
    1.0 
    D:P(A;;FA;;;BA)(A;;FA;;;SY)(A;;FR;;;AU) 
    $(@%SystemRoot%\system32\MemoryDiagnostic.dll,-600) 
    $(@%SystemRoot%\system32\MemoryDiagnostic.dll,-603) 
    \Microsoft\Windows\MemoryDiagnostic\ProcessMemoryDiagnosticEvents 
S-1-5-32-544 
HighestAvailable 
    false 
    true 
    true 
    false 
    PT2H 
    true 
    IgnoreNew 
    true 
    true 
true 
true 
    true 
&lt;QueryList&gt;&lt;Query Id="0" Path="System"&gt;&lt;Select Pa
th="System"&gt;*[System[Provider[@Name='Microsoft-Windows-WER-SystemErrorReporting'] 
and (EventID=1000 or EventID=1001 or EventID=1006)]]&lt;/Select&gt;&lt;/Query&gt;&lt;/
QueryList&gt; 
    . . . [cut for space reasons] . . .  
{8168E74A-B39F-46D8-ADCD-7BED477B80A3} 
The output shows the task’s XML descriptor, which includes the Task’s security descriptor 
(used to protect the task for being opened by unauthorized identities), the task’s author and de-
scription, the security principal that should run it, the task settings, and task triggers and actions:
    1.0
    D:P(A;;FA;;;BA)(A;;FA;;;SY)(A;;FR;;;AU)
    $(@%SystemRoot%\system32\MemoryDiagnostic.dll,-600)
    $(@%SystemRoot%\system32\MemoryDiagnostic.dll,-603)
    \Microsoft\Windows\MemoryDiagnostic\ProcessMemoryDiagnosticEvents
S-1-5-32-544
HighestAvailable
    false
    true
    true
    false
    PT2H
    true
    IgnoreNew
    true
    true
true
true
    true
&lt;QueryList&gt;&lt;Query Id="0" Path="System"&gt;&lt;Select Pa
th="System"&gt;*[System[Provider[@Name='Microsoft-Windows-WER-SystemErrorReporting'] 
and (EventID=1000 or EventID=1001 or EventID=1006)]]&lt;/Select&gt;&lt;/Query&gt;&lt;/
QueryList&gt;
    . . . [cut for space reasons] . . . 
{8168E74A-B39F-46D8-ADCD-7BED477B80A3}
CHAPTER 10 Management, diagnostics, and tracing
481
In the case of the ProcessMemoryDiagnosticEvents task, there are multiple ETW triggers (which 
allow the task to be executed only when certain diagnostics events are generated. Indeed, the 
trigger descriptors include the ETW query specified in XPath format). The only registered action 
is a ComHandler, which includes just the CLSID (class ID) of the COM object representing the task. 
Open the Registry Editor and navigate to the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID 
key. Select Find... from the Edit menu and copy and paste the CLSID located after the ClassID XML 
tag of the task descriptor (with or without the curly brackets). You should be able to find the DLL 
that implements the ITaskHandler interface representing the task, which will be hosted by the Task 
Host client application (Taskhostw.exe, described later in the “Task host client” section):
If you navigate in the HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\
TaskCache\Tasks registry key, you should also be able to find the GUID of the task descriptor 
stored in the Task store cache. To find it, you should search using the task’s URI. Indeed, the 
task’s GUID is not stored in the XML configuration file. The data belonging to the task descrip-
tor in the registry is identical to the one stored in the XML configuration file located in the 
store’s shadow copy (%systemroot%\System32\Tasks\Microsoft\ Windows\MemoryDiagnostic\
ProcessMemoryDiagnosticEvents). Only the binary format in which it is stored changes.
Enabled tasks should be registered with UBPM. The Task Scheduler calls the RegisterTask function 
of the Ubpm Proxy, which first connects to the Credential store, for retrieving the credential used to 
start the task, and then processes the list of all actions and triggers (stored in an internal list), convert-
ing them in a format that UBPM can understand. Finally, it calls the UbpmTriggerConsumerRegister API 
exported from UBPM.dll. The task is ready to be executed when the right conditions are verified.
Unified Background Process Manager (UBPM)
Traditionally, UBPM was mainly responsible in managing tasks’ life cycles and states (start, stop, enable/
disable, and so on) and to provide notification and triggers support. Windows 8.1 introduced the Broker 
Infrastructure and moved all the triggers and notifications management to different brokers that can 
In the case of the ProcessMemoryDiagnosticEvents task, there are multiple ETW triggers (which
allow the task to be executed only when certain diagnostics events are generated. Indeed, the
trigger descriptors include the ETW query specified in XPath format). The only registered action
is a ComHandler, which includes just the CLSID (class ID) of the COM object representing the task.
Open the Registry Editor and navigate to the HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID
key. Select Find... from the Edit menu and copy and paste the CLSID located after the ClassID XML
tag of the task descriptor (with or without the curly brackets). You should be able to find the DLL
that implements the ITaskHandler interface representing the task, which will be hosted by the Task
Host client application (Taskhostw.exe, described later in the “Task host client” section):
If you navigate in the HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\
TaskCache\Tasks registry key, you should also be able to find the GUID of the task descriptor 
stored in the Task store cache. To find it, you should search using the task’s URI. Indeed, the 
task’s GUID is not stored in the XML configuration file. The data belonging to the task descrip-
tor in the registry is identical to the one stored in the XML configuration file located in the 
store’s shadow copy (%systemroot%\System32\Tasks\Microsoft\ Windows\MemoryDiagnostic\
ProcessMemoryDiagnosticEvents). Only the binary format in which it is stored changes.
482 
CHAPTER 10 Management, diagnostics, and tracing
be used by both Modern and standard Win32 applications. Thus, in Windows 10, UBPM acts as a proxy 
for standard Win32 Tasks’ triggers and translates the trigger consumers request to the correct broker. 
UBPM is still responsible for providing COM APIs available to applications for the following:
I 
Registering and unregistering a trigger consumer, as well as opening and closing a handle to one
I 
Generating a notification or a trigger
I 
Sending a command to a trigger provider
Similar to the Task Scheduler’s architecture, UBPM is composed of various internal components: Task 
Host server and client, COM-based Task Host library, and Event Manager.
Task host server
When one of the System brokers raises an event registered by a UBPM trigger consumer (by publishing 
a WNF state change), the UbpmTriggerArrived callback function is executed. UBPM searches the inter-
nal list of a registered task’s triggers (based on the WNF state name) and, when it finds the correct one, 
processes the task’s actions. At the time of this writing, only the Launch Executable action is supported. 
This action supports both hosted and nonhosted executables. Nonhosted executables are regular 
Win32 executables that do not directly interact with UBPM; hosted executables are COM classes that 
directly interact with UBPM and need to be hosted by a task host client process. After a host-based 
executable (taskhostw.exe) is launched, it can host different tasks, depending on its associated token. 
(Host-based executables are very similar to shared Svchost services.)
Like SCM, UBPM supports different types of logon security tokens for task’s host processes. The 
UbpmTokenGetTokenForTask function is able to create a new token based on the account information 
stored in the task descriptor. The security token generated by UBPM for a task can have one of the fol-
lowing owners: a registered user account, Virtual Service account, Network Service account, or Local 
Service account. Unlike SCM, UBPM fully supports Interactive tokens. UBPM uses services exposed by 
the User Manager (Usermgr.dll) to enumerate the currently active interactive sessions. For each session, 
it compares the User SID specified in the task’s descriptor with the owner of the interactive session. If 
the two match, UBPM duplicates the token attached to the interactive session and uses it to log on the 
new executable. As a result, interactive tasks can run only with a standard user account. (Noninteractive 
tasks can run with all the account types listed previously.)
After the token has been generated, UBPM starts the task’s host process. In case the task is a hosted 
COM task, the UbpmFindHost function searches inside an internal list of Taskhostw.exe (task host cli-
ent) process instances. If it finds a process that runs with the same security context of the new task, it 
simply sends a Start Task command (which includes the COM task’s name and CLSID) through the task 
host local RPC connection and waits for the first response. The task host client process and UBPM are 
connected through a static RPC channel (named ubpmtaskhostchannel) and use a connection protocol 
similar to the one implemented in the SCM. 
CHAPTER 10 Management, diagnostics, and tracing
483
If a compatible client process instance has not been found, or if the task’s host process is a regular 
non-COM executable, UBPM builds a new environment block, parses the command line, and creates a 
new process in a suspended state using the CreateProcessAsUser API. UBPM runs each task’s host pro-
cess in a Job object, which allows it to quickly set the state of multiple tasks and fine-tune the resources 
allocated for background tasks. UBPM searches inside an internal list for Job objects containing host 
processes belonging to the same session ID and the same type of tasks (regular, critical, COM-based, 
or non-hosted). If it finds a compatible Job, it simply assigns the new process to the Job (by using the 
AssignProcessToJobObject API). Otherwise, it creates a new one and adds it to its internal list.
After the Job object has been created, the task is finally ready to be started: the initial process’s 
thread is resumed. For COM-hosted tasks, UBPM waits for the initial contact from the task host client 
(performed when the client wants to open a RPC communication channel with UBPM, similar to the 
way in which Service control applications open a channel to the SCM) and sends the Start Task com-
mand. UBPM finally registers a wait callback on the task’s host process, which allow it to detect when 
a task host’s process terminates unexpectedly.
Task Host client 
The Task Host client process receives commands from UBPM (Task Host Server) living in the Task 
Scheduler service. At initialization time, it opens the local RPC interface that was created by UBPM during 
its initialization and loops forever, waiting for commands to come through the channel. Four commands 