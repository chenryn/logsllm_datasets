# 三、使用微服务
阅读前两章后，您现在应该对 Docker 体系结构及其概念有所了解。在我们继续我们的 Java、Docker 和 Kubernetes 之旅之前，让我们了解一下微服务的概念。
通过阅读这一章，您将发现为什么过渡到微服务和云开发是必要的，以及为什么单片架构不再是一种选择。微服务架构也是 Docker 和 Kubernetes 特别有用的地方。
本章将涵盖以下主题:
*   微服务介绍和单片体系结构比较
*   Docker 和 Kubernetes 如何融入微服务世界
*   何时使用微服务架构
在我们实际创建 Java 微服务并使用 Docker 和 Kubernetes 部署它之前，让我们先解释一下微服务的思想，并将其与单体架构进行比较。
# 微服务介绍
根据定义，微服务，也称为**微服务架构** ( **MSA** )，是一种架构风格和设计模式，它表示应用应该由松散耦合的服务集合组成。这个架构将业务领域模型分解成由服务实现的更小的、一致的部分。换句话说，每个服务都有自己的职责，独立于其他服务，每个服务都提供特定的功能。
这些服务应该是孤立的和自治的。然而，他们当然需要沟通来提供一些业务功能。他们通常使用`REST`曝光或以发布/订阅的方式发布和订阅事件来进行交流。
解释微服务概念背后的原因的最好方法是将它们与构建大型应用的传统方法——整体设计——进行比较。
请看下图，它展示了由微服务组成的整体应用和分布式应用:
![](img/ea77b619-8dc0-4242-a213-870885b41bbc.jpg)
正如您在前面的图表中所看到的，单体应用与使用微服务架构创建的应用完全不同。让我们比较一下这两种方法，并指出它们的优缺点。
# 单片与微服务
我们从描述单片架构开始进行比较，以呈现其特性。
# 整体架构
过去，我们将应用创建为完整的、大量的、统一的代码片段。让我们以一个 web MVC 应用为例。下图显示了此类应用的简化架构:
![](img/19569c5a-adff-4d67-9480-e68197d182a6.jpg)
如您所见，该图展示了典型的 web 应用，在本例中是银行系统的一个片段。这是**模型** **视图控制器** ( **MVC** )应用，由模型、视图和控制器组成，将 HTML 内容提供回客户端的浏览器。它也可能通过 REST 端点接受和发送 JSON 内容。这种应用是作为单个单元构建的。如你所见，我们这里有几层。企业应用通常由三部分组成:客户端用户界面(由运行在浏览器中的 HTML 页面和 JavaScript 组成)，处理`HTTP`请求的服务器端部分(可能使用一些类似 spring 的控制器构建)，然后我们有一个服务层，它可能使用 EJB 或 Spring 服务来实现。服务层执行特定于域的业务逻辑，并最终检索/更新数据库中的数据。这是一个非常典型的 web 应用，我们每个人都可能偶尔创建一次。整个应用是一个整体，一个单一的逻辑可执行文件。要对系统进行任何更改，我们必须构建和部署整个服务器端应用的更新版本；这种应用被打包成单个 WAR 或 EAR 档案，以及所有静态内容，如 HTML 和 JavaScript 文件。部署后，所有应用代码都在同一台机器上运行。扩展这种类型的应用通常需要将完全相同的应用代码的多个副本部署到集群中的多台机器上，可能在某个负载平衡器的后面。
这个设计还不错，毕竟我们已经启动并运行了我们的应用。但是这个世界，尤其是当使用敏捷方法时，变化很快。企业开始要求比以往更快地发布软件。ASAP 已经成为 IT 开发语言词典中非常常见的一个词。规范是波动的，所以代码经常变化，并随着时间的推移而增长。如果开发应用的团队很大(在复杂、庞大的应用中可能会如此)，每个人都必须非常小心，不要破坏彼此的工作。每增加一个功能，我们的应用就会变得越来越复杂。编译和构建时间变得更长，使用单元或集成测试来测试整个事情迟早会变得棘手。此外，新成员加入团队的切入点可能令人望而生畏，他们需要从源代码库中签出整个项目。然后他们需要在集成开发环境中构建它(在大型应用的情况下，这并不总是那么容易)，并分析和理解组件结构来完成他们的工作。此外，从事用户界面部分工作的人员需要与从事中间层工作的开发人员、数据库建模人员、数据库管理员等进行交流。随着时间的推移，团队结构通常会开始模仿应用架构。有一种风险是，从事特定层工作的开发人员会倾向于在他所控制的层中尽可能多地放入逻辑。因此，随着时间的推移，代码可能变得不可维护。我们都去过那里，做过那件事，不是吗？
此外，单片系统的扩展并不像将 WAR 或 EAR 放入另一个应用服务器然后启动它那么容易。因为所有的应用代码都在服务器上的同一个进程中运行，所以通常几乎不可能扩展应用的单个部分。举个例子:我们有一个与 VOIP 外部服务集成的应用。我们的应用用户不多，但我们需要处理来自 VOIP 服务的大量事件。为了处理不断增加的负载，我们需要扩展我们的应用，在单块系统的情况下，我们需要扩展整个系统。这是因为应用是一个单一的大的工作单元。如果只有一个应用的服务需要 CPU 或资源，则必须为整个服务器提供足够的内存和 CPU 来处理负载。这可能很贵。每台服务器都需要一个快速的中央处理器和足够的内存来运行我们应用中要求最高的组件。
所有单片应用都具有这些特性:
*   它们相当大，经常有很多人在上面工作。当将您的项目加载到集成开发环境中时，这可能是一个问题，尽管有强大的机器和出色的开发环境，例如 IntelliJ IDEA。但这不仅仅是数百、数千或数百万行代码的问题。这是关于解决方案的复杂性，比如团队成员之间的沟通问题。通信问题可能导致在应用的不同部分出现同一问题的多个解决方案。这将使它变得更大，它很容易演变成一个大泥球，再也没有人能理解整个系统。此外，人们可能害怕对系统进行实质性的改变，因为在另一端的某些东西可能会突然停止工作。如果这是用户在生产系统上报告的，那就太糟糕了。
*   它们有很长的发布周期，我们都知道发布管理、权限、回归测试等过程。几乎不可能创造出一个具有巨大的整体应用的连续输送流。
*   它们很难扩展；运营团队在集群中放置一个新的应用实例通常需要大量的工作。扩展特定功能是不可能的，您唯一的选择是在集群中增加整个系统的实例。这使得向上和向下扩展成为一大挑战。
*   如果部署失败，整个系统将不可用。
*   您被锁定在特定的编程语言或技术栈中。当然，有了 Java，系统的部分可以用一种或多种运行在 JVM 上的语言来开发，比如 Scala、Kotlin 或 Groovy，但是如果需要集成一个`.net`库，麻烦就从这里开始了。这也意味着你不能总是使用合适的工具来完成工作。想象一个场景，其中您希望在数据库中存储大量复杂的文档。它们通常有不同的结构。MongoDB 作为文档数据库应该是合适的吧？是的，但是我们的系统运行在甲骨文上。