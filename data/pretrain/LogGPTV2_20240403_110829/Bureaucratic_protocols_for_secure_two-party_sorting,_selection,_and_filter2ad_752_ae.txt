The error rates are plotted in Figure 14.
Our selection algorithm is quite accurate. Most of the
errors are just oﬀ by one (i.e., instead of ﬁnding the k-th
largest number, the algorithm returns the (k − 1)-th or (k +
1)-th largest number). The rate of this type of errors is quite
small (less than 0.014%). Errors that are oﬀ by more than
one position are much less.
Error distance=1
Error distance=2
Error distance=3
1.4x 10−4
e
t
a
r
r
o
r
r
E
1.2
1
0.8
0.6
0.4
0.2
0
128
256
512
1024
2048
The input size
4096
8192
16384
Figure 14: Error rate of the Fast Selection algorithm
7. RELATED WORK
Bureaucratic computing reveals the inherent relationship
between secure two-party computation and oblivious algo-
rithms. We brieﬂy review these two ﬁelds in this section.
10
Applications of S2P can be categorized into two directions.
One focuses on developing generic solution using Yao’s gar-
bled circuit [13, 14, 30]. Thanks to Fairplay [25], we can
easily build Yao’s circuit for a speciﬁc problem. However,
this general approach is not scalable [1,24]. For example, di-
rectly compiling the bubblesort algorithm into Yao’s circuit
generates a circuit that contains O(n2) compare-swap gates,
each of which requires an expensive oblivious-transfer pro-
tocol. The cost of such a generic circuit is quite large with a
big n. Another direction aims at designing S2P schemes for
a given function or a speciﬁc algorithm [1,3,6,8,11,24]. They
take the approach of reducing the generic circuit construc-
tion into many invocations of simpler secure functions of less
inputs, or sacriﬁcing partial secret information to gain eﬃ-
ciency. The concept of “data obliviousness of an algorithm”
has never been studied in those papers.
Our goal is diﬀerent. We would like to answer which algo-
rithm is the fastest for a speciﬁc S2P computation problem,
such as sorting. Bureaucratic framework ensures that the
costly eﬀort of applying the generic garbled circuit is spent
only on the atomic two-input functions.
This framework roots in the data obliviousness of algo-
rithms. Knuth’s book [21] is one of the ﬁrst places to men-
tion “oblivious algorithm” in details. In [12, 27], the authors
propose “cache-oblivious” algorithms, which are appealing
in hardware applications. The motivation is to design algo-
rithms that are independent to hardware parameters, such
as cache size and cache-line length. This line of work has
little relationship to ours; we study data obliviousness.
Sorting network is an important research topic in hard-
ware and parallelization research [4]. We exam most popular
two of them, odd-even merge and bitonic sort. Several stud-
ies based on [4] have improved eﬃciency and simplicity for
selection and sorting [7, 22]. Sorting networks are suitable
for bureaucratic computing since they are data-oblivious.
Shellsort and its variants is another widely-studied tech-
nique
[19, 28]. These variants are mainly for improving
performance. The best known time complexity for Shell-
sort variant is beyond O(n log n) [28]. To the best of our
knowledge, our Randomized Shellsort is the ﬁrst variant that
achieves O(n log n), with a provable very high probability.
Moreover, it is, by design, data-oblivious and appropriate
for bureaucratic computing.
This paper is also (arguably) the ﬁrst one to propose ef-
ﬁcient S2P sorting, selection, and permutation algorithms.
Although there is a secure kth-ranked computation method
in [1], their setting is diﬀerent from ours, in the sense that
it allows partial information (i.e., intermediate results) dis-
closure. Our solution ensures zero knowledge disclosure.
We have already summarized the work related to random
[13] O. Goldreich. The Foundations of Cryptography,
permuting in Section 5. We will not repeat it here.
volume 2. 2004.
8. CONCLUSION
We propose a bureaucratic computing framework for algo-
rithm design for S2P computation, and justify its eﬃciency
on S2P sorting, selection and permutation problems. Our
system is reasonably fast and will be open source. With
the increasing privacy concerns, we believe that the direc-
tion to ﬁnd eﬃcient algorithms for bureaucratic computing
is important. This paper makes an important initial step to-
wards this direction. More eﬃcient algorithms will emerge
to solve other interesting S2P problems.
9. REFERENCES
[1] G. Aggarwal, N. Mishra, and B. Pinkas. Secure
computation of the kth-ranked element. In In
Advances in Cryptology-Proc. of Eurocrypt’04, pages
40–55, 2004.
[2] M. Ajtai, J. Komlos, and E. Szemeredi. Sorting in
c log n parallel steps. Combinatorica, 3:1–19, 1983.
[3] M. J. Atallah and W. Du. Secure multi-party
computational geometry. In WADS2001: 7th
International Workshop on Algorithms and Data
Structures, pages 165–179, Providence, Rhode Island,
USA, August 8-10 2001.
[4] K. E. Batcher. Sorting networks and their
applications. In Proceedings of the AFIPS Spring Joint
Computer Conference 32, pages 307–314, 1968.
[5] M. Blum, R. W. Floyd, V. Pratt, R. Rivest, and
R. Tarjan. Time bounds for selection, 1973.
[6] R. Canetti, Y. Ishai, R. Kumar, M. K. Reiter,
R. Rubinfeld, and R. N. Wright. Selective private
function evaluation with applications to private
statistics (extended abstract). In Proceedings of
Twentieth ACM Symposium on Principles of
Distributed Computing (PODC), 2001.
[7] G. Chen and H. Shen. A bitonic selection algorithm
on multiprocessor system. J. of Comput. Sci. Technol.,
4:315–322, 1989.
[8] B. Chor, O. Goldreich, E. Kushilevitz, and M. Sudan.
Private information retrieval. In Proceedings of IEEE
Symposium on Foundations of Computer Science,
Milwaukee, WI USA, October 23-25 1995.
[9] M. Ciura. Best increments for the average case of
shellsort. In International Symposium on
Fundamentals of Computation Theory, Riga, Latvia,
2001.
[10] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and
C. Stein. Introduction to Algorithms, Second Edition.
The MIT Press, 2001.
[11] J. Feigenbaum, Y. Ishai, T. Malkin, K. Nissim,
M. Strauss, and R. Wright. Secure multiparty
computation of approximations. In Twenty Eighth
International Colloquium on Automata, Language and
Programming, 2001.
[12] M. Frigo, C. E. Leiserson, H. Prokop, and
S. Ramachandran. Cache-oblivious algorithms
(extended abstract). In In Proc. 40th Annual
Symposium on Foundations of Computer Science,
pages 285–397. IEEE Computer Society Press, 1999.
[14] O. Goldreich, S. Micali, and A. Wigderson. How to
play any mental game. In Proceedings of the 19th
Annual ACM Symposium on Theory of Computing,
pages 218–229, 1987.
[15] L. J. Goldstein and S. W. Leibholz. On the synthesis
of signal switching networks with transient blocking,
1967.
[16] M. T. Goodrich and R. Tamassia. Algorithm Design:
Foundations, Analysis, and Internet Examples. Wiley,
2001.
[17] Michael T. Goodrich. Randomized Shellsort: A simple
oblivious sorting algorithm. In Proceedings of the
ACM-SIAM Symposium on Discrete Algorithms
(SODA), pages 1–16. SIAM, 2010.
[18] J. Incerpi. A study of the worst case of shellsort.
Ph.D. thesis, Brown University, Dept. of Computer
Science, 1994.
[19] J. Incerpi and R. Sedgewick. Practical variations of
shellsort. Information Processing Letters, 79:223–227,
2001.
[20] D. E. Knuth. Seminumerical algorithms. The Art of
Computer Programming, 2.
[21] D. E. Knuth. Sorting and searching. The Art of
Computer Programming, 3.
[22] T. Leighton, Y. Ma, and T. Suel. On probabilistic
networks for selection, merging, and sorting. In
SPAA’95, pages 106–118, Santa Barbara, CA, USA,
1995.
[23] P. Lemke. The performance of randomized
shellsort-like network sorting algorithms. In SCAMP
working paper, Institute for Defense Analysis,
Princeton, NJ, USA, 1994.
[24] Y. Lindell and B. Pinkas. Privacy preserving data
mining. In Advances in Cryptology - Crypto2000,
Lecture Notes in Computer Science, volume 1880,
2000.
[25] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay
– a secure two-party computation system. In In
USENIX Security Symposium, pages 287–302, 2004.
[26] M. S. Paterson. Improved sorting networks with o(log
n) depth. Algorithmica, 5:75–92, 2005.
[27] H. Prokop. Cache-oblivious algorithms. Technical
report, M.I.T, 1999.
[28] R. Sedgewick. Analysis of shellsort and related
algorithms. In ESA 96: Fourth Annual European
Symposium on Algorithms, pages 25–27, 1996.
[29] D. L. Shell. A high-speed sorting procedure. Commun.
ACM, 2(7):30–32, 1959.
[30] A. C. Yao. How to generate and exchange secrets. In
Proceedings 27th IEEE Symposium on Foundations of
Computer Science, pages 162–167, 1986.
APPENDIX
A. PROOF OF THEOREM 2
Here is the proof for Theorem 2, the time complexity of
Randomized Shellsort.
Proof. In every round, we have six passes. When oﬀset
equals to f , the number of compare-swap operations that
11
2f ∗ f , and ( n
f − 1) ∗ f , ( n
each pass takes is ( n
f − 3) ∗ f ,
( n
f − 2) ∗ f , ( n
2f − 1) ∗ f , respectively. Note that
the third, fourth, and sixth inner loop are not running at the
ﬁrst round. We have the total number of compare-swaps as
the following:
f − 1) ∗ f , ( n
T (n) =
+
log n
X
i=1
log n
X
i=2
((
((
n
fi
n
fi
− 1)f + (
n
fi
− 1)f + (
n
2fi
)fi)
− 3)fi + (
n
fi
− 2)fi + (
n
2fi
− 1)fi).
Since we are using geometry sequence for our oﬀset, fi is
n/2i, we have
T (n) = 5n log n −
15
2
n + 8.
This concludes our proof.
B. PROOF OF THEOREM 3
We have the time complexity of the Fast selection algo-
rithm. The proof of Theorem 3 is the following:
Proof. Similar to the proof above, we list the number
of compare-swaps each inner loop takes. When oﬀset is f ,
they are ⌊ k
⌋f , and f , respectively. The
summation of them gives the expression of Tn,k:
f ⌉f , ⌊ n−k−f
f ⌋f , ⌈ n−k
f
Tn,k =
⌊log k⌋
X
i=0
(⌊
k
fi
⌋fi + ⌈
n − k
fi
⌉fi + ⌊
n − k − fi
fi
⌋fi + fi) + n
(2)
Since fi is k/2i, we have
Tn,k ≤
⌊log k⌋
X
i=0
(
k
fi
fi + (
n − k
fi
+ 1)fi +
n − k − fi
fi
fi + fi) + n
=
⌊log k⌋
X
i=0
(2n − k + fi) + n
≤ (2n − k) log k + 3n + k − 2
We can have the lower bound in the same way.
C. RELATED ALGORITHMS
Odd-Even Mergesort
Input: The n-element array A that to be sorted
Output: The sorted array A
if n > 1 then
Odd-Even Mergesort A0, A1, . . . , A n
Odd-Even Mergesort A n
Odd-Even Merge(A)
2 , A n
2 +1, . . . , An
−1
2
end
procedure Odd-Even Merge(a)
1: if n > 2
2: Odd-Even Merge(a0, a2, . . . , an−2)
3: Odd-Even Merge(a1, a3, . . . , an−1)
4: CompareSwap(a, i, i + 1) for all i ∈ {1, 3, 5, 7, . . . , n − 3}
5: else
6: CompareSwap(a, 0, 1)
Figure 15: Odd-Even Mergesort Algorithm
Bitonic sort
Input: The n-element array A that to be sorted, start, end, direction
Output: The sorted array Astart . . . Aend
n ← end − start if n > 1 then
2
m ← n
Bitonic sort(Astart, . . . , Am, ASCENDING)
Bitonic sort(Am+start, . . . , Am, DESCENDING)
Bitonic Merge(Astart, . . . , Aend, direction)
Figure 15 is the algorithm of Odd-Even Mergesort; while
end
Figure 16 is Bitonic sort algorithm.
procedure Bitonic Merge(a, low, a.length, direction)
1: n ← a.length
2: if n > 1
3: m ← n/2
4: for(i ← low; i < low + m; i ← i + 1
5: CompareSwap(a, i, i + m, direction)
6: Bitonic Merge(a, low, m, direction)
7: Bitonic Merge(a, low + m, m, direction)
Figure 16: Bitonic sort Algorithm
12