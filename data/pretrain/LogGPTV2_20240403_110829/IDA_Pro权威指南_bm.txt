   SDK 自带的命令行构建脚本要求一个名为 IDA 的环境变量指向 。你可以通过编辑/allmake.mak和/allmake.unx文件设置这个变量，或在你的全局环境中添加一个 IDA 环境变量，为所有脚本设置这个变量。
Steve Micallef 的指南还提供了有关配置构建环境的详细说明，以使用各种编译器构建插件。在为Windows 版本的IDA 构建SDK 模块时，我们偏好于使用 MinGW工具 gcc 和make。第17章～第19 章所举的例子中包括一些并不依赖SDK 自带的任何构建脚本的生成文件和Visual Studio 项目文件，你可以轻松对它们进行修改，以满足自己的项目要求。特定于模块的构建配置将分别在这 3 章中讨论。
16.2 IDA 应用编程接口
IDA 的API 由/include目录中的头文件定义。关于可用的 API 函数，并没有一个完整的目录（不过 Steve Micallef 在他的插件编写指南中已经收集了一部分 API 函数）。最初，许多潜在的 SDK 程序员很难接受这一事实。实际上，对于“我如何使用SDK 做……？”这个问题，从来没有简单的答案。要想获得这类问题的答案，可以采取两种途径：将这些问题粘贴到IDA的用户论坛，或者搜索 API 文档尝试自己找到答案。你可能会问，该搜索哪些文档呢？当然是头文件文档！虽然这些文档并不是最便于搜索的文档，但是，其中确实包含API 的所有功能。这时，你可以使用 grep
 工具（或者一个适当的替代工具，最好是内置在编程编辑器中）。不过，关键是你要知道搜索什么内容，因为这并不总是非常明显。
有一些方法可以帮助你缩小搜索范围。首先，利用你所掌握的IDC 脚本语言知识，使用关键字及从 IDC 中获得的函数名称，设法在 SDK 中找到类似的功能。但是，令人非常沮丧的是，虽然许多 SDK 函数的用途与 IDC 函数的用途完全相同，但这些函数的名称却很少相同。这使得程序员需要学习两组 API 调用，一组用于 IDC ，一组用于 SDK 。为了解决这个问题，我们在附录 B中提供了一个完整的列表，其中列出了 IDC 函数及用于执行这些函数的对应的 SDK 6.1 操作。
缩小SDK 相关搜索范围的第二种方法是熟悉各种 SDK 头文件的内容和作用（更为重要）。通常，头文件会根据函数类型为相关的函数和数据结构分组。例如，处理用户交互的 SDK 函数归入kernwin.hpp文件。如果通过 grep
 之类的搜索无法确定你需要的功能，那么，了解与该功能有关的头文件信息，将可以帮助你缩小搜索范围，减少需要深入分析的文件的数量。
16.2.1 头文件概述
虽然SDK 的readme.txt 文件概括介绍了大多数常用的头文件，但是，在这一节中，我们重点说明其他一些与这些文件有关的信息。首先，绝大多数头文件使用.hpp 作为后缀，但也有一些文件使用.h 作为后缀。在命名将要包含在文件中的头文件时，这很可能会导致细小的错误。其次，ida.hpp 是SDK 的主要头文件，该文件应包括在所有与 SDK 有关的项目中。最后，SDK 利用预处理指令阻止用户访问那些 Hex-Rays 认为危险的函数（如 strcpy
 和sprint
 ）。有关所有这些函数的完整内容，请参考 pro.h头文件。要恢复对这些函数的访问，在将 ida.hpp 包含在你自己的文件中之前，必须定义 USE_DANGEROUS_FUNCTIONS
 宏，如下所示：
#define USE_DANGEROUS_FUNCTIONS  
#include 
如果没有定义USE_DANGEROUS_FUNCTIONS
 宏，将导致一个构建错误，其大致意思是：dont_ use_snprintf
 是一个未定义的符号（如果尝试使用 snprintf
 函数）。为了“补偿”对这些所谓的危险函数的限制，SDK 为每个函数定义了更加安全的替代函数，这些函数通常采用qstr XXXX
 的形式，如qstrncpy
 和qsnprintf
 。这些更加安全的函数也是在 pro.h文件中声明的。
同样，SDK 还限制用户访问许多标准文件输入/输出变量和函数，如 stdin
 、stdout
 、fopen
 、fwrite
 和fprintf
 。这种限制部分是由于 Borland编译器的局限性所致。对于这些函数，SDK 同样为它们定义了替代函数，它们一般为 qXXX
 的形式，如 qfopen
 和qfprintf
 。如果你需要访问标准文件函数，那么，在包含fpro.h 文件之前，你必须定义USE_STANDARD_FILE_FUNCIONS宏
 。（fpro.h文件由kernwin.hpp包含，后者又由其他几个文件包含。）
多数情况下，每个 SDK 头文件都包含一段简要描述，说明这个文件的作用，并用相当详细的注释介绍在这个文件中声明的数据结构和函数。这些注释构成了 IDA 的API 文档。下面简要说明一些常用的 SDK 头文件。
area.hpp
 。这个文件定义area_t
 结构体，它是数据库中的一个相邻地址块。这个结构体作为其他几个类（根据一个地址范围构建）的基类。你很少需要直接包含这个文件，因为它通常包含在定义area_t
 的文件中。
auto.hpp
 。这个文件声明用于处理IDA 的自动分析器的函数。如果IDA 并不忙于处理用户输入事件，自动分析器将执行排队分析任务。
bytes.hpp
 。这个文件声明处理各个数据库字节的函数。在这个文件中声明的函数用于读取和写入各个数据库字节及修改这些字节的属性。有各种函数还可用于访问与指令操作数有关的标志，另外一些函数则用于修改常规注释和可重复注释。
dbg.hpp
 。这个文件声明的函数通过编程控制IDA 调试器。
entry.hpp
 。这个头文件声明的函数用于处理文件的进入点。对于共享库，每个导出的函数或数据值都被视为是一个进入点。
expr.hpp
 。这个文件声明处理IDC 结构的函数和数据结构。你可以在模块中修改现有的IDC函数，添加新的IDC 函数或执行IDC 语句。
fpro.h
 。这个文件包含前面讨论的文件输入/输出替代函数，如qfopen
 。
frame.hpp
 。这个头文件包含用于操纵栈帧的函数。
funcs.hpp
 。这个头文件包含用于处理经过反汇编的函数的函数和数据结构，以及用于处理FLIRT 签名的函数。
gdl.hpp
 。这个文件为使用DOT或GDL生成图形声明支持例程。
ida.hpp
 。这个文件是处理SDK 所需的主要头文件，其中包含idainfo
 结构的定义和全局变量inf的声明，还包含许多字段，一些字段提供与当前数据库有关的信息，另一些字段则由配置文件设置初始化。
idp.hpp
 。这个文件包含一些结构体的声明，这些结构体构成处理器模块的基础。描述当前处理器模块的全局变量ph
 和描述当前汇编器的全局变量ash
 也在这个文件中定义。
kernwin.hpp
 。这个文件声明用于处理用户交互和用户界面的函数。这个文件还声明了 SDK中替代IDC 的AskXXX
 函数的函数，以及用于设置显示位置和配置热键关联的函数。
lines.hpp
 。这个文件声明用于生成格式化的彩色反汇编行的函数。
loader.hpp
 。这个文件包含分别用于创建加载器模块和插件模块的loader_t
 和plugin_t
 结构体的声明，以及用于加载文件和激活插件的函数的声明。
name.hpp
 。这个文件声明用于操纵已命名位置（相对于结构或栈帧中的名称，它们分别在stuct.hpp 和funcs.hpp 中声明）的函数。
netnode.hpp
 。网络节点是通过API访问的最低级的存储结构。通常，IDA 的用户界面完全隐藏了网络节点细节。这个文件包含notnode
 类的定义及用于网络节点低级操纵的函数。
pro.h
 。这个文件包含任何SDK 模块所需的顶级类型定义和宏。不需要明确将这个文件包含在你的项目中，因为ida.hpp 已经包含它了。另外，IDA_SDK_VERSION
 宏也在这个文件中定义。IDA_SDK_VERSION
 宏可用于确定一个模块正使用哪个版本的SDK 构建。在使用不同的SDK 版本时，你还可以对它进行测试，以提供条件编译。需要注意的是，IDA_SDK_VERSION
 由SDK 5.2引入。在SDK 5.2之前，并没有正式的方法确定模块使用的是什么版本的SDK 。本书的网站上提供有一个非正式的头文件（sdk_versions.h ），它为较低版本的SDK 定义了IDA_SDK_VERSION
 宏。
search.hpp
 。这个文件声明对数据库进行各种搜索的函数。
segment.hpp
 。这个文件包含segment_t
 类（area_t
 的一个子类）的声明，segment_t
 类用于描述二进制文件的各节（如.text
 、.data
 等）。这个文件还声明了用于处理段的函数。
struct.hpp
 。这个文件声明struc_t
 类以及操纵数据库中的结构的函数。
typeinf.hpp
 。这个文件声明用于处理IDA 类型库的函数。另外，在这个文件中声明的函数还可用于访问函数签名，包括函数返回类型和参数序列。
ua.hpp
 。这个文件声明在处理器模块中大量使用的op_t
 和insn_t
 类。这个文件还声明了用于反汇编各条指令，以及为每个反汇编行的各个部分生成文本的函数。
xerf.hpp
 。这个文件声明添加、删除和遍历代码和数据交叉引用所需的数据类型和函数。
上面介绍了 SDK 自带的大约一半的头文件。但是，在你深入学习 SDK 时，建议你不但要了解这个列表中的文件，还要熟悉其他所有的头文件。已发布的 API 函数带有 ida_export
 标记。SDK自带的链接库仅导出带有 ida_export
 标记的函数。请不要因为使用 idaapi
 而产生误解，因为它仅仅表示一个函数只有在 Windows 平台上才使用 stdcall
 调用约定。有时候，你可能会遇到一些不带 ida_export
 标记的函数，你不能在模块中使用这些函数。
16.2.2 网络节点
IDA 的许多 API 以C++ 类为基础创建，它模拟一个经过反汇编的二进制文件的各节。另一方面，netnode
 类则有些神秘，因为它似乎与二进制文件的结构（如节、函数、指令等）没有任何直接关系。
网络节点是 IDA 数据库中最低级和最通用的数据存储机制。作为一名模块程序员，你很少需要直接操作网络节点。许多较为高级的数据结构均隐藏了一个事实，即它们最终都需要依靠网络节点永久存储在数据库中。nalt.hpp 文件详细说明了在数据库中使用网络节点的一些方法。例如，通过这个文件，我们知道，与二进制文件导入的共享库和函数有关的信息存储在一个名为import_node
 的网络节点中（是的，网络节点也有名称）。网络节点还是 IDC 全局数组的永久存储机制。
网络节点由 netnode.hpp 文件全面描述。但是，从宏观角度看，网络节点是 IDA 的内部存储结构，其用途非常广泛。尽管如此，即使是 SDK 程序员也不知道它们的具体结构。为了提供一个访问这些存储结构的接口，SDK 定义了netnode
 类，它就像是这个内部存储结构的“不透明包装”。netnode
 类包含唯一一个数据成员，即 netnodenumber
 ，它是一个用于访问网络节点的内部表示形式的整数标识符。每个网络节点由它的 netnodenumber
 唯一标识。在32 位系统上，netnodenumber
 是一个32 位整数，可以表示232
 个唯一的网络节点。在64 位系统上，netnodenumber
 是一个 64 位整数，可以表示 264
 个唯一的网络节点。多数情况下，netnodenumber
 代表数据库中的一个虚拟地址，它在数据库中的每个地址与存储和某地址有关的信息所需的网络节点之间建立一个自然的对应关系。任何与一个地址有关的信息（如注释）都存储在与这个地址有关的网络节点中。
要操纵网络节点，建议你使用一个实例化的 netnode
 对象调用netnode
 类的成员函数。浏览netnode.hpp 文件，你会发现，有许多非成员函数似乎也可用于操纵网络节点。相对于成员函数，我们不鼓励使用这些函数。但是，你会注意到，netnode
 类中的大多数成员函数都是某个非成员函数的“瘦包装器”（thin wrapper）。
在SDK 内部，网络节点可用于存储几种不同类型的信息。每个网络节点都有一个最长达512个字符的名称和一个最长达 1024 个字节的主值。netnode
 类的成员函数用于检索（name
 ）或修改（rename
 ）网络节点的名称。其他成员函数可按整数（ set_long 、long_value
 ）、字符串（ set、valstr
 ）或任意二进制大对象（set、valobj
 ）1
 处理网络节点的主值。处理主值的方式由你所使用的函数决定。
1. 二进制大对象，即BLOB ，通常指任何大小可变的二进制数据。
使情况更加复杂的是：除了名称和主值外，每个 netnode
 还能够存储256 个稀疏数组，其中的数组元素可以为任意大小，最大为 1024 个字节。这些数组分为 3 种相互重叠的类型。第一类数组使用 32 位索引值，最多可以保存 40 亿个数组元素。第二类数组使用 8 位索引值，最多可以保存256 个数组元素。最后一类数组实际上是使用字符串作为密钥的散列表。无论使用哪一类数组，数组中的每个元素能接受的值最大为 1024 个字节。简言之，一个网络节点可以存储数量极其庞大的数据，现在我们只需要了解这一点是如何做到的。