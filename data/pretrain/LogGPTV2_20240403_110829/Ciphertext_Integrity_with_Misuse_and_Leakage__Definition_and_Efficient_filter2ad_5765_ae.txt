DTE which encrypts â„“-block messages provides (ğ‘, ğ‘¡, ğœ€)-CIML
security in the unbounded leakage model as long as ğ‘¡ â‰¤ ğ‘¡â€² âˆ’
(ğ‘ + 1)(ğ‘¡H + (2â„“ + 1)ğ‘¡F) where ğ‘¡H and ğ‘¡F are the time needed
to evaluate H and F, and we have
ğœ€ â‰¤ ğœ€Fâ‹† + ğœ€ğ‘ğ‘Ÿ + 2ğ‘ Â· ğœ€ğ‘ğ‘Ÿ + (ğ‘ + 1) Â· 2
âˆ’ğ‘›.
An interesting observation about this statement is that it
shows that the pseudorandomness of F has no impact on the
success probability of the CIML adversary.
The proof of Theorem 5.3 is given in Appendix A.
6 DIGEST, COMMIT AND ENCRYPT
The previous construction reaches different types of guaran-
tees with and without leakages (namely, MR and CIML). As
a (more balanced) alternative, we now present a construction
that drops the requirement of MR (without leakage), and
only focuses on CIML security. This construction has the
advantage of only requiring one execution of the leak-free
function, but at the expense of relying on the random oracle
model in its proof of CIML security (yet not for its LR CPA
security, as will be shown in Section 7).
We acknowledge that the use of a random oracle when
analyzing implementation weaknesses is questionable, since
the random oracle is an abstraction, and therefore does not
offer a simple model for physical leakages.
In order to overcome this difficulty, we assume that the
random oracle has unbounded leakages: it leaks all of its
inputs and outputs. Of course, such a leakage model would
be too strong for proving any confidentiality property of a
construction that would hash a secret value. But we show
that, even in a such a strong leakage model, CIML can be
achieved.
Besides, and as discussed in [47], the random oracle model
sometimes comes in handy in order to argue about the security
of natural constructions of which the LR seems hard to reach
in the standard model. In view of the practical interest of the
DCE construction, we therefore include a proof in this model
in our treatment and suggest the further investigation of DCE
instances as an interesting scope for further research. We note
that our proof does not make use of the programmability of
the random oracle, which is a common source of gaps in the
Conferenceâ€™17, July 2017, Washington, DC, USA
Figure 5: DCE leakage-resilient AE (part I). Part II
is identical to Fig. 3.
DCE
Encğ‘˜(ğ‘Ÿ, ğ‘š), where ğ‘š = (ğ‘š1, ğ‘š2, . . . , ğ‘šâ„“):
(âˆ€ğ‘– =
âˆ™ h â† H(ğ‘Ÿâ€–ğ‘š)
âˆ™ ğ‘˜0 â† F*
ğ‘˜(h)
âˆ™ ğ‘0 â† Fğ‘˜0 (ğ‘ğµ) âŠ• ğ‘Ÿ
âˆ™ ğ‘˜ğ‘– â† Fğ‘˜ğ‘–âˆ’1 (ğ‘ğ´), ğ‘ğ‘– â† Fğ‘˜ğ‘– (ğ‘ğµ) âŠ• ğ‘šğ‘–
1, . . . , â„“)
âˆ™ return ğ¶ = (h, ğ‘0, ğ‘1, ğ‘2, . . . , ğ‘â„“)
âˆ™ ğ‘˜0 â† F*
âˆ™ ğ‘Ÿ â† Fğ‘˜0 (ğ‘ğµ) âŠ• ğ‘0
âˆ™ ğ‘˜ğ‘– â† Fğ‘˜ğ‘–âˆ’1 (ğ‘ğ´), ğ‘šğ‘– â† Fğ‘˜ğ‘– (ğ‘ğµ) âŠ• ğ‘ğ‘–
(âˆ€ğ‘– =
1, . . . , â„“)
âˆ™ if h = H(ğ‘Ÿâ€–ğ‘š) return ğ‘š = (ğ‘š1, ..., ğ‘šâ„“), else return
âŠ¥.
ğ‘˜(h)
Decğ‘˜(ğ¶), where ğ¶ = (h, ğ‘0, ğ‘1, ğ‘2, . . . , ğ‘â„“):
Figure 6: The DCE scheme.
soundness of schemes that are proven to be secure in this
model but are insecure for any instantiation of the random
oracle.
6.1 Specifications
The authentication part of the DCE scheme is outlined in
Figure 5 which is then plugged to the encrypting part of
Figure 3. The full specification is available in Figure 6. There,
H is a hash function and ğ‘ğ´ and ğ‘ğµ are two public distinct
constants in â„¬ = {0, 1}ğ‘›. The key ğ‘˜ is picked randomly from
ğ’¦, as usual.
6.2 Security analysis
Theorem 6.1. Let H : {0, 1}ğ‘› Ã— {0, 1}â‹† â†¦âˆ’â†’ {0, 1}ğ‘› be
modeled as a random oracle. Let F* : {0, 1}ğ‘› Ã— {0, 1}ğ‘› â†¦âˆ’â†’
{0, 1}ğ‘› be (ğ‘ + 1, ğ‘¡â€², ğœ€F* )-pseudorandom. Then, DCE provides
(ğ‘, ğ‘¡, ğœ€)-CIML security in the unbounded leakage model, where
ğ‘¡ â‰¤ ğ‘¡â€² âˆ’ (ğ‘ + 1)(ğ‘¡H + (2â„“ + 1)ğ‘¡F), â„“ is the number of blocks
of the encrypted messages, ğ‘¡H and ğ‘¡F are the time needed to
evaluate H and F, and we have
ğœ€ â‰¤ ğœ€F* + 4(ğ‘ + 1)2/2ğ‘› + (ğ‘ + 1)/2ğ‘›.
Francesco Berti, FranÂ¸cois Koeune, Olivier Pereira,
Thomas Peters, FranÂ¸cois-Xavier Standaert.
The proof of Theorem 6.1 is given in Appendix B. The CPA
security of DCE without leakage (or misuse) in the random
oracle model is immediate.
7 LEAKAGE-RESILIENT CPA
SECURITY
The ciphertext integrity properties discussed in the previous
sections do not imply anything about the confidentiality of
the messages that are encrypted with DTE and DCE.
This section shows the leakage-resilient CPA security of
these schemes, which is measured by the probability that
an adversary distinguishes between playing the PrivKlmcpa,0
ğ’œL,AE
and PrivKlmcpa,1
ğ’œL,AE games, defined in Figure 7 and borrowed
from PSV [37]. This is essentially the traditional CPA game,
with the addition that the challenger provides leakages for
any computation it performs, including the test query at
Step 3), and that the adversary can access a leakage oracle L
that gives him leakages from the attacked circuit on chosen
inputs (which makes it possible to run matching attacks, as
described in Section 4). This oracle was formally omitted in
the previous sections, as it was meaningless in the unbounded
leakage model.
We recall that the lmcpa superscript in the notation PrivKlmcpa,0
ğ’œL,AE
stands for multiple messages and blocks leakage-resilient CPA
security, which relates to the remark in introduction that
our following proofs only guarantee that the security of our
constructions for multiple messages and blocks reduces to
their security for one block, and then depends on what can
be guaranteed for this single block. As discussed in [37], this
is the best that can be achieved given the impossibility of
leakage-resilient CPA security with negligible advantage (due
the the fact that even a single bit of plaintext leakage trivially
breaks the semantic security game).
ğ’œL,AE , with AE = (ğ’¦, Enc, Dec), is the output of the
PrivKlmcpa,b
following experiment:
(1) Select ğ‘˜ $â† ğ’¦
(2) ğ’œL gets access to a leaking encryption oracle that,
when queried on a message ğ‘š of arbitrary block
length, returns Encğ‘˜(ğ‘š) together with the leakage
resulting from the encryption process.
(3) ğ’œL submits two messages ğ‘š0 and ğ‘š1 of identical
block length, to which he is replied with Encğ‘˜(ğ‘šğ‘)
and the corresponding leakage.
(4) ğ’œL can keep accessing the leaking encryption oracle.
(5) ğ’œL outputs a bit ğ‘â€².
Figure 7: The PrivKlmcpa,b
ğ’œL,AE game
The PrivKleav,b
ğ’œL,AE game [37], modeling leakage-resilient eaves-
dropper security, is defined just in the same way, except that
the encryption oracles from steps 2 and 4 disappear.
Ciphertext Integrity with Misuse and Leakage
Conferenceâ€™17, July 2017, Washington, DC, USA
Definition 7.1. An AE scheme AE = (ğ’¦, Enc, Dec) with
leakage function L is (ğ‘, ğ‘¡, ğœ–) lmcpa-secure (resp. leav-secure)
if, for every (ğ‘, ğ‘¡)-bounded adversary ğ’œL, the lmcpa (resp.
leav) advantage |PrivKlmcpa,0
ğ’œL,AEâˆ’
ğ’œL,AE|) is bounded by ğœ–.
PrivKleav,1
ğ’œL,AE | (resp. |PrivKleav,0
ğ’œL,AE âˆ’PrivKlmcpa,1
7.1 Background: LMCPA security of
PSV-ENC
Observing that the encryption part of all our schemes essen-
tially follows the PSV-ENC scheme, we can hope to import
the results of the previous analyzes of that scheme.
The security of an implementation of the PSV-ENC scheme
relies on the assumption that the block cipher implementation
that it uses has 2-simulatable leakages.
The notion of simulatable leakages is based on the ğ‘-sim-
game below, from which ğ‘-simulatable leakages are defined.
This game essentially measures the capability of a simulator
to produce leakages that look consistent with given inputs
and outputs of a block cipher, without knowing the key used
in the computation.
Game ğ‘-sim(ğ’œ, F, L,ğ’®, ğ‘) [43, Section 2.1].
The challenger selects two random keys ğ‘˜, ğ‘˜* $â† ğ’¦. The
output of the game is a bit ğ‘â€² computed by ğ’œL based on the
challenger responses to a total of at most ğ‘ adversarial
queries of the following type:
Query
Enc(ğ‘¥)
and one query of the following type:
Query
Gen(ğ‘§, ğ‘¥)
Response if ğ‘ = 0 Response if ğ‘ = 1
Fğ‘˜(ğ‘¥), L(ğ‘˜, ğ‘¥)
Response if ğ‘ = 0 Response if ğ‘ = 1
ğ’® L(ğ‘§, ğ‘¥, ğ‘˜)
Fğ‘˜(ğ‘¥), ğ’® L(ğ‘˜*, ğ‘¥, Fğ‘˜(ğ‘¥))
ğ’® L(ğ‘§, ğ‘¥, ğ‘˜*)
Definition 7.2. [ğ‘-simulatable leakages [43, Def. 1]] Let F be
a PRF having leakage function L. Then F has (ğ‘ğ’® , ğ‘¡ğ’® , ğ‘ğ’œ, ğ‘¡ğ’œ, ğœ–ğ‘-ğ‘ ğ‘–ğ‘š)
ğ‘-simulatable leakages if there is a (ğ‘ğ’® , ğ‘¡ğ’® )-bounded simulator
ğ’® L such that, for every (ğ‘ğ’œ, ğ‘¡ğ’œ)-bounded adversary ğ’œL, we
have
| Pr[ğ‘-sim(ğ’œ, F, L,ğ’® L, 1) = 1]âˆ’
Pr[ğ‘-sim(ğ’œ, F, L,ğ’® L, 0) = 1]| â‰¤ ğœ–ğ‘-ğ‘ ğ‘–ğ‘š.
Based on this definition, the eavesdropper security of PSV-
ENC can be summarized as follows.
Theorem 7.3 ([37], Thm 3.). Let F be a (ğ‘, ğ‘¡, ğœ–F)-PRF
whose implementation has running time ğ‘¡F and a leakage
function LF with (ğ‘ğ’® , ğ‘¡ğ’® , ğ‘, ğ‘¡, ğœ–2-ğ‘ ğ‘–ğ‘š) 2-simulatable leakages.
The advantage of every (ğ‘âˆ’ ğ‘ğ‘Ÿ, ğ‘¡âˆ’ ğ‘¡ğ‘Ÿ)-bounded ğ’œLF playing
the PrivKleav,b
PSVâˆ’ENC = â„“(Advğ‘  +
4(ğœ–F + ğœ–2-ğ‘ ğ‘–ğ‘š)) where Advğ‘  is a bound on the eavesdropper
advantage of a (ğ‘ âˆ’ ğ‘ğ‘Ÿâ€² , ğ‘¡ âˆ’ ğ‘¡ğ‘Ÿâ€² )-bounded adversary trying
to distinguish the encryptions of two single-block messages
encrypted with the PSV-ENC scheme, ğ‘ğ‘Ÿ, ğ‘ğ‘Ÿâ€² are ğ’ª(â„“ğ‘ğ’® ) and
ğ‘¡ğ‘Ÿ, ğ‘¡ğ‘Ÿâ€² are ğ’ª(â„“(ğ‘¡ğ’® + ğ‘¡F)).
PSVâˆ’ENC game is bounded by ğœ–eav
This result relates the eavesdropper security of the PSV-
ENC scheme to the security that is offered in front of an
adversary who can only get a single encryption of a single
block messages, which is expected to be simpler to evaluate
(see discussion in [37]). Note that, in our analysis below, we
will not need to use any result about the CPA security of
PSV-ENC.
7.2 Bounding hash function leakages
The security of the PSV-ENC scheme is going to be helpful
for the encryption part of the DTE and DCE modes, but the
first parts of our modes also include the evaluation of a hash
function running on the message to be encrypted, which may
in turn leak information about the message and help win the
PrivKlmcpa,b
ğ’œL,AE game: if the implementation of the hash function
just leaks its input in full, we can obviously not hope for
any confidentiality. We therefore turn to the definition of our
security assumption about the hash function implementation,
before analyzing DCE and DTE.
Concretely, we need a bound on the distinguishing proba-
bility of an adversary who would see the leakages resulting
from hashing something containing a message ğ‘š0 and those
resulting from hashing something containing ğ‘š1. Simply as-
suming the indistinguishability of leakages on adversarially
chosen ğ‘š0 and ğ‘š1 would be way too strong from a physical
point-of-view: if an adversary knows ğ‘š0 and ğ‘š1, he can ob-
tain leakages computed on these two values directly from the
hash function implementation, and compare those leakages
with the leakage returned by the challenger, in a leakage
matching attack.
However, our adversary faces a more difficult problem,
since he is not able to predict what message is hashed when
he gets leakages to distinguish. More precisely, the adversary
may be able to choose 2 messages ğ‘š0 and ğ‘š1, but must
then decide the value of ğ‘ when he gets H(ğ‘Ÿâ€–ğ‘šğ‘), LH(ğ‘Ÿâ€–ğ‘šğ‘)
in return, where ğ‘Ÿ is a fresh random value and LH(ğ‘¥) is the
leakage resulting from evaluating the hash function on ğ‘¥.
Since DTE and DCE encrypt (ğ‘Ÿâ€–ğ‘šğ‘) with PSV-ENC, ğ‘Ÿ is
unknown to the adversary, and he cannot feed his device
with (ğ‘Ÿâ€–ğ‘š0) or (ğ‘Ÿâ€–ğ‘š1) in order to match the leakages, and
is bound to run a more sophisticated SPA attack due to the
partially unknown state.
The DCE and DTE schemes also hash (ğ‘Ÿâ€–ğ‘šğ‘) and not
(ğ‘šğ‘â€–ğ‘Ÿ). While equivalent in theory, this makes sure that,
when using an iterating hash function, the block containing
the randomness ğ‘Ÿ is processed before the blocks containing the