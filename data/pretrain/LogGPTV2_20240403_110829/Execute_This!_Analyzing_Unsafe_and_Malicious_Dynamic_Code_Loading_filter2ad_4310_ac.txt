still were unable to identify the application as malicious.
Our proposed protection system (see Section VI) mitigates
all of these threats by enforcing signature checks on any code
– including any external code – so that attackers cannot escape
analysis and detection by downloading code at runtime.
2) Code loading as source of vulnerabilities: Improper use
of the code-loading techniques presented in Section III-A can
introduce severe vulnerabilities in benign applications. There
are many subtle aspects to consider, and our analysis of ap-
plications from Google Play shows that application developers
often fail in their attempt to implement the mechanism securely
(as we will describe in more detail in Section V).
The essential problem is that Android directs responsibility
for checking the integrity and authenticity of external code to
the application or framework developers. Those developers’
main concern is the application or framework’s functionality,
and they are often unaware of the security implications of their
applications’ behavior. This leads to opportunities for attackers
to replace the expected legitimate code with malicious one.
Without proper checks, applications will not detect the attack
and execute the malicious code.
The most common problems we found are the following:
a) Insecure downloads: Some applications download
external code via HTTP. Since HTTP connections are vulnera-
ble to man-in-the-middle attacks, it is possible for attackers to
modify or replace the downloaded code. Fahl et al. showed that
the use of HTTP and improper use of HTTPS are a widespread
problem in Android applications in general [15].
b) Unprotected storage: We observed applications that
download additional code (often in the form of APKs) and
store it in the device’s ﬁle system. In many cases, the storage
location was improperly chosen in such a way that other
2https://www.virustotal.com/
3http://andrototal.org/
6
applications had write access to it (e.g., directories on the
external storage of the device, often an SD card). This allows
other applications on the device to tamper with the code. By
modifying an APK before it is installed, for instance, attackers
can gain full access to the new application’s data.
methods, basic blocks, and the individual Dalvik bytecode
instructions. Based on this data, it transforms the code into
static single assignment (SSA) form [10]. It then performs
Class Hierarchy Analysis (CHA) and it builds the control ﬂow
graph (CFG) for each individual method.
c) Improper use of package names: Every application
that is installed on an Android system is identiﬁed via its
package name. The developer can freely specify the package
name, but it must be unique on the device. Applications can
use the package names of other applications to locate and load
their code (see Section III-A for details). However, application
developers often do not consider the possibility that a particular
package name can be used by several applications, as long as
they are not installed on the same device. In particular, the
application that uses a given package name ﬁrst, “reserves”
it on that device. The package name is not displayed to the
user during application installation, so that an attacker can
choose a package name for her application that is normally
used by a well-known application (such as a framework that
many applications load code from). If a user installs such a
malicious application, then any application that uses the well-
known package name will load the malicious code instead.
Note that the malicious application must be installed before the
benign one, because the system does not allow the installation
of applications with a package name that is already used on
the device.
In Section V-B, we will present exploits against real-world
applications using the above attack techniques.
IV. AUTOMATIC DETECTION
In order to assess how widespread the previously described
problems are among popular Android applications, we devel-
oped a tool that extracts information about the (mis)use of
code loading techniques by means of static analysis.
At a high level, our detection tool receives an APK as
input and looks for indications of problematic code loading.
The analysis is performed directly on top of Dalvik bytecode,
and does not require the source code of the application to
be analyzed. The output of the tool consists of an informative
report that shows whether the given application could possibly
load additional code at runtime. If this is the case, the report
also indicates the category of every detected code-loading
attempt (as described in Section III-A).
In this section, we describe the design and implementation
of our tool, while we will present the results of our analysis
in Section V-A.
A. Basis for the tool
We developed a static-analysis tool for the detection of
code-loading behavior.
We would like to note that parts of this work were
developed for other, already published research [14]. We do not
claim those parts of the tool as contributions, but in this section
we will describe all the relevant details for completeness. In
the following, we will clearly state which parts of the tool are
novel.
The tool ﬁrst uses Androguard [13] to disassemble the
Dalvik byte code and to obtain information about classes,
B. Construction of the sCFG
On top of this, the tool constructs the super control ﬂow
graph (sCFG), which represents possible method invocations
between the different methods. In particular, an edge in the
sCFG means that a given invoke instruction could possibly
direct control ﬂow to the given method’s entry point.
Even though the construction of the sCFG is a well-studied
task in the program analysis literature, it is not straightforward
to build a precise call graph. The key difﬁculty is that Dalvik
bytecode (like most object oriented languages, such as C++
and C#) heavily relies on the dynamic dispatch mechanism
to determine which method a given invoke instruction will
jump to. For the purpose of this work, we chose to apply
a class-hierarchy-based algorithm that scales well while being
reasonably precise at the same time. From a high-level point of
view, the tool determines the possible targets for each invoke
bytecode instruction by combining the information about the
targets’ types from the invoke instructions and the results
provided by the class-hierarchy analysis.
More speciﬁcally, we implemented the algorithm as fol-
lows. Given an invocation i of a method m of class c, we ﬁrst
use the class hierarchy to ﬁnd all non-abstract subclasses of c.
If c is an interface, then we locate all classes that implement
the interface, and their subclasses. We place c and all classes
found so far in the set X. Then we check for each class x
in X whether the class implements a method with the same
signature as m (i.e., the class overrides m). If this is the case,
we accept the candidate as a possible target and connect it to
the invocation i in the sCFG. Otherwise, we traverse the class
hierarchy upward starting from class x, to check whether a
compatible method is implemented in classes extended by x:
the ﬁrst method we encounter will be considered as the target
of the invocation i.
Note that this algorithm produces an over-approximation
of the sCFG: In other words, we introduce edges between
invoke instructions and method entry points that might never
be used at runtime. However, as we will discuss below, this
does not pose a problem for the heuristics we developed for
our analysis.
C. Backward slicing
The type of analysis we aim to perform requires the
capability of program slicing. Based on the control ﬂow
information, the tool is able to compute slices of the analyzed
application. We implemented a backward slicing algorithm that
works on top of the sCFG, based on work by Weiser [35].
Given an instruction i and a register r used by the instruc-
tion, a slice s(i, r) is a set of instructions that can possibly
inﬂuence the value that register r contains when executing the
instruction i. We compute the slice by starting at instruction i
and walking back in the method’s CFG, tracing the ﬂow of data
toward r in the SSA representation of the code. Whenever the
7
slicing algorithm reaches the beginning of a method, it uses the
sCFG to locate all possible callers and recursively continues
the analysis. Our implementation also keeps track of class and
instance variables, so whenever such variables are used, the
analysis recursively continues at all points in the code that
assign values to the respective variables.
D. Heuristics to detect code loading
The following heuristics were implemented on top of the
existing tool speciﬁcally for the work presented in this paper.
The goal of our analysis is to ﬁnd uses of the loading
techniques detailed in Section III-A. Therefore, the detection
tool
looks for invocations of methods that are associated
with the respective techniques (e.g., createPackageContext to
load code via a package context). If it detects a suspicious
invocation, it uses the slicing mechanism described above to
further analyze the call. In the previous example, a mere call
to createPackageContext is not enough to conclude that the
application loads external code. Instead, we have to make
sure that the ﬂags CONTEXT INCLUDE CODE and CON-
TEXT IGNORE SECURITY are passed as parameters (see
Section III-A). We do so by computing a slice from the call
instruction and the register that contains the ﬂags parameter.
We implement several heuristics to detect issues with code-
loading:
1) General detection: In order to identify candidate ap-
plications for further analysis, we detect the use of all code-
loading techniques presented in Section III-A by identifying
the associated method invocations. If a technique requires a
method invocation with speciﬁc parameters, we check their
presence by computing slices for the respective argument
registers.
2) Storage location: For APK installations, class loaders
and native code, we analyze the storage location of the code
to be loaded. If the code is stored in a world-writable location
such as the device’s external storage, we consider the load
operation to be vulnerable, because other applications can
maliciously modify the code.
3) Code provenance: For the same set of techniques, we
search for indications that the code is downloaded via HTTP.
We ﬂag such cases as problematic, because HTTP is vulnerable
against man-in-the-middle attacks.
4) Package names: We consider code-loading based on
package names a security risk at all times, because a given
package name is not guaranteed to belong to the desired
application (see Section III-D2). In particular, creating package
contexts and using them to load code is a vulnerable operation,
since the target application is always identiﬁed by its package
name.
With the help of our tool, we identiﬁed a large number of
vulnerable applications on Google Play, among them even very
popular applications with millions of users (see Section V-A).
V. LARGE-SCALE ANALYSIS OF BENIGN APPLICATIONS
In the previous section, we described a tool for automatic
detection of code-loading behavior. We applied the tool to
various sets of real-world applications in order to assess
TABLE I.
USE OF DIFFERENT CODE-LOADING TECHNIQUES IN 1,632
POPULAR APPLICATIONS FROM GOOGLE PLAY.
Category
Applications in the category
(relative to the whole set)
Flagged vulnerable
(relative to the whole set)
Class loaders
Package context
Native code
APK installation
Runtime.exec
Total
83 (5.01%)
13 (0.80%)
70 (4.29%)
155 (9.50%)
379 (23.22%)
530 (32.48%)
31 (1.90%)
13 (0.80%)
0
117 (7.17%)
n/a
151 (9.25%)
the prevalence of code-loading techniques and the associated
security issues. We found that the techniques are very popular
and lead to vulnerabilities in a number of applications. In this
section, we ﬁrst present the results of our study and afterward
detail
two severe vulnerabilities that we found during the
analysis.
A. Use of code-loading techniques
We applied the detection tool to the following sets of
applications from Google Play:
1)
2)
3)
A set of 1,632 applications chosen randomly in May
2012 from among those applications on Google Play
with more than one million installations.
The 50 most popular free applications from Google
Play in November 2012.
The 50 most popular free applications from Google
Play in August 2013.
We ran our detection tool on the applications in those three
test sets with a timeout value of one hour. In 10% of the cases,
the runtime exceeded the timeout value. In the remaining cases,
the mean runtime was 74.9 seconds per application with a
standard deviation of 55.3 seconds. Taking all executions into
account, including those that timed out, the median runtime
was 69.8 seconds. The mean size of the analyzed code ﬁles
was 3,303 KB, the standard deviation 2,152 KB.
Tables I, II and III show the use of code-loading techniques
by applications and the number of vulnerabilities detected
by our tool in the different test sets, respectively. Note that
a single application can use multiple techniques. Also, note
that code-loading using Runtime.exec does not usually lead to
vulnerabilities, because it is commonly only used to execute
system binaries. The surprisingly high numbers of applications
containing code for this technique is partially due to multi-
platform frameworks: Runtime.exec, as opposed to the other
code-loading mechanisms presented in this paper, is not spe-
ciﬁc to Android. We found Java frameworks in the analyzed
applications that exclusively use Runtime.exec when executed
on non-Android systems.
Our results show that loading code at runtime is indeed
a widespread phenomenon among benign applications. We
found a surprisingly high number of potentially vulnerable
applications. The analysis of the large test set indicates that
9.25% of the applications on Google Play are vulnerable to
code-injection attacks (see Table I). The situation in the top 50
free applications at the time of writing is even more alarming:
16% of the applications contain vulnerable code (see Table III).
8
TABLE II.
CODE-LOADING IN THE TOP 50 FREE APPLICATIONS AS OF
NOVEMBER 2012. VULNERABILITIES MANUALLY CONFIRMED.
Category
Applications in the category
(relative to the whole set)
Flagged vulnerable
(relative to the whole set)
Class loaders
Package context
Native code
APK installation
Runtime.exec
Total
8 (16%)
1 (2%)
4 (8%)
4 (8%)
12 (24%)
20 (40%)
1 (2%)
1 (2%)
0
2 (4%)
n/a
3 (6%)
TABLE III.
CODE-LOADING IN THE TOP 50 FREE APPLICATIONS AS OF
AUGUST 2013. VULNERABILITIES MANUALLY CONFIRMED.
Category
Applications in the category
(relative to the whole set)
Flagged vulnerable
(relative to the whole set)
Class loaders
Package context
Native code
APK installation
Runtime.exec
Total
17 (34%)
0