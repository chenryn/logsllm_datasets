WHam(Hash,Hash’) =
CPri(Hashi ⊕ Hash’i)
(5)
k∑
i=1
where Hash is the original hash, Hash’ is the recovered
hash, i is the index of the bit, and CPri is the classiﬁer pre-
diction probability of the ith bit. PAtt will trigger an alarm
when the computed weighted Hamming distance passes the
detection threshold (τ).
4.2 Testbed Design and Setup
In this section, we describe our industrial robot arm testbed
and our implementation of PAtt’s Prover on the PLC control-
ling the robot arm.
The PLC and Process. The industrial control system used in
this paper is a modern robotic arm controlled by a Siemens
170          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Associationscripts to allow for automated control and link them to the
PLC through the Snap7 communication library.
Function Blocks for Prover Functionality. To simplify the
usage of the proposed method, in practical industrial con-
trol systems we programmed the whole path strategy and
attestation functions inside the function blocks that could be
easily used by non-experts. The core idea of the PAtt is to
enable the remote attestation of a PLC’s control logic (or
the conﬁguration data) without requiring changes to the PLC
hardware or the manufacturer provided ﬁrmware. In other
words, PAtt should be applicable to legacy systems by re-
compiling/extending only the operator provided control logic
programs of a PLC. We wrote 315 lines of code inside the
designed function blocks to compute the hash and perform
the actuation strategies. We used TIA 15 together with the
Python-Snap7 libraries at the veriﬁer side to communicate
with the function blocks inside the PLC.
The attestation result, as soon as it is computed, will be
encoded into the commands the PLC sends to the connected
physical system as well as the veriﬁer. The resulting sensor
readings that depend on the attestation report are forwarded
to the veriﬁer. The veriﬁer has a model of the physical system
and can calculate which series of sensor readings to expect
based on the actual functional commands, including the en-
coded attestation report.
Random Actuation Strategy. To implement the required
random actuation strategy, we designed a set of function
blocks to perform PAtt’s micro-commands inside the func-
tion block within the bounded timing of the needed abstract
macro-command by the process. As discussed before, the
completion of the micro-commands will lead to a physical
state as required by the macro-command. The random actua-
tion strategy was written directly inside the function blocks,
and it includes three function blocks and in total, 214 lines
of codes inside the ladder logic. As only a limited number of
micro-commands can be executed in each scan cycle, we are
not able to run the complete actuation strategy based (with a
number of steps determined by the length of our hash) within
a single scan cycle. In particular, in our implementation, we
generate eight micro-commands in one scan cycle. We now
discuss how we addressed this implementation issue.
Splitting the Attestation over Multiple Protocol Rounds.
Overall, we want to execute 256 micro-commands (to match
the 256-bit output of our hash, SHA256). As we can only
execute eight micro-commands in each scan cycle, we need to
execute micro-commands over multiple scan cycles. Unfortu-
nately, this increases the time required for the attestation, and
potentially allows the attacker more time to compute precise
simulations of executions (or communicate with a remote
Oracle). To ensure that this is not possible for the attacker, we
run the overall protocols in 32 rounds, with fresh nonces in
each round. In each round, we execute eight micro-commands
based on the most recent hash. Each round contributes 8 bits
Figure 4: Implemented setup.
S7-1200 PLC with a remote attestation server with at least one
GB storage, 16 GB memory, and an Intel Core i7 processor.
The PLC is programmed with the controller code for the
robotic arm. The veriﬁer communicates with the PLC over an
industrial network and uses the SNAP7 library. The veriﬁer
is written in Python, and has more than 3000 lines of code.
Our setup consists of a PLC-controlled Dobot robotic arm.
The arm includes a rotating base with two arm segments,
which we refer to as the rear and front arm segments respec-
tively. At the end of the front arm, the segment is an end-
effector, which can hold several different attachments, like a
gripper or 3D-printing extruder head. The arm is actuated by
three stepper motors, which we control via a Siemens S7-1200
PLC. Actuation is achieved through (i) a Pulse Width Mod-
ulation (PWM) Input/Output (IO) module for the PLC, and
(ii) one A4988 stepper driver per stepper motor to correctly
control the motor coils. Due to limitations in the amount of IO
pins available in our setup, we utilize only two stepper motors
in our implementation (see Figure 4). The PLC controls the
stepper drivers with PWM signals generated by our designed
function blocks of the PLC control logic that translate the
macro-commands to micro-commands, including the analog
conversion of the hash.
For sensing, the robotic arm uses an inertial measurement
unit (IMU) on both of its segments, with accelerometer and
gyroscope measurements collected during operation being
routed to the PLC via a combination of an Arduino MEGA
and MAX232 adapter, converting the accelerometers’ I2C
protocol to an RS232 module on the PLC.
On the PLC, we program the sensing-actuation control
loop. We implement the low-level arm kinematics, and point-
to-point movement functions adapted from the open-dobot
project [1] translated to the Siemens SCL language. To sim-
ulate an application-focused environment, we use python
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 171of difﬁculty for the attacker to correctly guess the hash (or
spoof sensor reading traces that are decoded to the expected
hash). The Prover is attested by the Veriﬁer only if all 32
rounds conclude successfully. We designed the encoding pro-
cess to keep the PLC busy by the generation of hashes over
the physical process and providing a new nonce in each scan
cycle that convince the PLC to perform the random physical
actuation over each scan cycle while the PLC computation
power is devoted for the new hash generation.
5 Evaluation
In this section, we evaluate our proposal of the physics-based
attestation of the control systems.
5.1 Dataset
Normal Operation. Our training dataset consists of 10
hashes and corresponding sensor reading traces, repeated six
times for each hash (in total 60 runs). The traces are generated
during normal operation (which captures the natural noise of
the physical process) with a sampling rate of ten sensor read-
ings for each micro-command. For our test evaluation dataset,
we performed a number of attacks: a one-bit approximation
attack, two-bit approximation attack, and simulation attacks
(each attack was run 20 times). The overall size of sensor read-
ings and the generated dataset was roughly 100 megabytes.
We now describe the details of our attack implementation.
Hash Approximation Attacks. In this attack, an attacker
modiﬁed the control logic of the PLC which resulted in
a different hash (and thus a changed sequence of micro-
commands). To show that PAtt can detect even minor changes
in the hash/actuation sequence, we evaluated the performance
of PAtt against an attacker that ﬂips one or two random bits of
the hash to modify the robot arm’s trajectory. The attacker has
full access to the stored hash and the actuation commands.
In particular, we performed ten one-bit approximation at-
tacks and ten two-bit approximation attacks, and we evaluated
the detection performance based on this attack. As the classi-
ﬁers of our implementation PAtt are only trained on normal
process behavior, we did not need to include the attack traces
in the classiﬁer training process. The implemented hash ap-
proximation attack was used as a test data-set, which consists
of twenty hashes of sensor traces, and each hash repeated two
times, and the normal operation was used as train data-set.
Replay Attacks. In addition to the effects of incorrect hashes
or manipulated micro-command sequences, we also investi-
gated whether the attacker would be able to produce sensor
reading sequences by simulation (e.g., based on prior obser-
vations). For example, the attacker could try to record and
replay earlier sensor reading traces, or try to re-assemble a
new sensor reading trace from multiple earlier observations.
We now argue why the former is infeasible and then describe
how we evaluated the latter. The attacker could generate a ta-
ble of short sequences of micro-commands and corresponding
sensor readings to simulate sensor reading traces of arbitrary
hashes. Our intuition is that this is not feasible as the sensor
readings are inﬂuenced by the trajectory position of the arm
and the average move over a window of time. Considering
the memory and computational resources available on the
PLC, the attacker needs to regenerate the corresponding sen-
sor reading that is inﬂuenced by the trajectory position of the
arm and the average move over a window of time. Our results
(presented next) conﬁrm this. The implemented replay attack
was used as a test data-set which consists of ten hashes with
replayed sensor traces from the attack table, and each hash
repeated two times, and the normal operation was used as
train data-set.
5.2 Evaluation Results
To evaluate the performance of PAtt, we use the following
metrics (see Section 10.2 in the Appendix): Sensitivity, Speci-
ﬁcity, Precision, False Positive Rate (FPR), False Negative
Rate (FNR), Accuracy, F1-score, and Matthews Correlation
Coefﬁcient (MCC).
Decoding. We now present our evaluation of different classi-
ﬁers for decoding the sensor reading traces to the actuation
strategy. The results in Table 2 summarizes the performance
of our classiﬁers. The most promising classiﬁers for our data
set were the Random Forest and Multi-Layer Perceptron (with
accuracy 0.9923 and 0.9915, respectively). The tradeoff be-
tween false acceptance and false rejection can be seen in
the ROC, provided in Appendix 10.3. Overall, it can be ob-
served that our decoding is reliably able to translate the sensor
reading traces back into the micro-commands.
Hash Authentication. For remaining analysis, we used the
RF classiﬁer for the decoding. The next step (the hash authen-
tication) required an appropriate value for τ (the threshold for
the weighted Hamming distance between the expected and
decoded hash). We now show how we selected τ, based on
analysis of the distributions of the hashes’ weighted Ham-
ming distances in normal and attack cases. We start with
(more intuitively understandable) ﬁgures on the distributions
of weighted Hamming distances in normal operations and
during attacks. Figure 5 shows the weighted Hamming dis-
tance with the occurrence probability distribution of one-bit
approximation attack, two-bit approximation attack, and re-
play attack, respectively. As shown in Figure 5a, the curve
of the occurrence probability distribution of the normal op-
eration overlap with the curve of the occurrence probability
distribution of the one-bit approximation attack. That implies
no value for τ will allow us to decide between the two cases
without error correctly, and it means that there will be a non-
negligible probability that the attacker can perform her attack
while remaining undetected. In contrast, Figure 5b shows the
curve of the occurrence probability distribution of the normal
172          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Association1
0.8
0.6
0.4
0.2
0
0
1
y
t
i
l
i
b
a
b
o
r
P
e
c
n
e
r
u
c
c
O
Normal Operation
1-bit Flipping Attack
y
t
i
l
i
b
a
b
o
r
P
e
c
n
e
r
u
c
c
O
2
3
4
5
6
Weighted Hamming Distance
1
0.8
0.6
0.4
0.2
0
0
1
Normal Operation
2-bit Flipping Attack
y
t
i
l
i
b
a
b
o
r
P
e
c
n
e
r
u
c
c
O
2
3
4
5
6
7
Weighted Hamming Distance
1
0.8
0.6
0.4
0.2
0
0
10