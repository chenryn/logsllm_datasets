title:A layered naming architecture for the internet
author:Hari Balakrishnan and
Karthik Lakshminarayanan and
Sylvia Ratnasamy and
Scott Shenker and
Ion Stoica and
Michael Walfish
A Layered Naming Architecture for the Internet
∗
Hari Balakrishnan
PI:EMAIL
Scott Shenker
†§
†
Karthik Lakshminarayanan
PI:EMAIL
†
Ion Stoica
‡
Sylvia Ratnasamy
PI:EMAIL
∗
Michael Walﬁsh
PI:EMAIL
PI:EMAIL
PI:EMAIL
ABSTRACT
Currently the Internet has only one level of name resolution, DNS,
which converts user-level domain names into IP addresses. In this
paper we borrow liberally from the literature to argue that there
should be three levels of name resolution: from user-level descrip-
tors to service identiﬁers; from service identiﬁers to endpoint iden-
tiﬁers; and from endpoint identiﬁers to IP addresses. These addi-
tional levels of naming and resolution (1) allow services and data
to be ﬁrst class Internet objects (in that they can be directly and per-
sistently named), (2) seamlessly accommodate mobility and multi-
homing and (3) integrate middleboxes (such as NATs and ﬁrewalls)
into the Internet architecture. We further argue that ﬂat names are a
natural choice for the service and endpoint identiﬁers. Hence, this
architecture requires scalable resolution of ﬂat names, a capability
that distributed hash tables (DHTs) can provide.
Categories and Subject Descriptors
C.2.5 [Computer-Communication Networks]: Local and Wide-
Area Networks—Internet; C.2.1 [Computer-Communication
Networks]: Network Architecture and Design; C.2.4 [Computer-
Communication Networks]: Distributed Systems—Distributed
databases
General Terms
Design
Keywords
Naming, Internet architecture, name resolution, distributed hash ta-
bles, middleboxes, global identiﬁers
∗
MIT Computer Science and Artiﬁcial Intelligence Lab
†
UC Berkeley, Computer Science Division
‡
Intel Research, Berkeley
§
International Computer Science Institute (ICSI)
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
SIGCOMM’04, Aug. 30–Sept. 3, 2004, Portland, Oregon, USA.
Copyright 2004 ACM 1-58113-862-8/04/0008 ...$5.00.
1.
INTRODUCTION
Despite its tremendous success,
the Internet architecture is
widely acknowledged to be far from ideal, and the Internet’s in-
creasing ubiquity and importance have made its ﬂaws all the more
evident and urgent. The case for architectural change has never
been stronger, as witnessed by the burgeoning set of architectural
critiques and counter-proposals emerging from the research com-
munity (e.g., [2,5–8,41,45,55,56]). Ironically, the growth that mo-
tivated these proposals now makes their success unlikely: the sheer
size of the Internet’s installed router infrastructure renders signiﬁ-
cant changes to IP almost impossible. The decade-long struggle to
deploy IPv6 should give any aspiring network architect pause.
Rather than attempt the Sisyphean task of modifying routers,
we focus on improving a more malleable facet of the architecture:
naming.1 Although this restriction in focus prevents us from ad-
dressing issues that inherently involve routers (such as complete
denial-of-service protection, ﬁne-grained host-control over routing,
and quality-of-service) there are many issues for which changes to
IP would be irrelevant—and for which changes to the naming ar-
chitecture would be crucial.
The current Internet has only two global namespaces, DNS
names and IP addresses, both of which are tied to pre-existing struc-
tures (administrative domains and network topology, respectively).
The rigidity and paucity of these namespaces are responsible for
a variety of architectural ills. For instance, the Internet is now
widely used by applications to gain access to services (processes
that are remotely invoked by clients, such as Web servers) and data
(ﬁles, streams, etc.), yet the Internet does not have a mechanism
for directly and persistently naming data and services.
Instead,
both are named relative to the hosts on which they reside. Us-
ing DNS to name data overloads the names and rigidly associates
them with speciﬁc domains or network locations, making it incon-
venient to move service instances and data, as well as to replicate
them [23, 36, 50, 51, 59]. In this sense, the Internet’s current host-
centric naming treats data and services as second-class network cit-
izens.
In addition, users and system administrators often resort to ar-
chitecturally suspect middleboxes—such as NATs/NAPTs [52],
ﬁrewalls and transparent caches—because they cannot get sim-
ilar functionality within the architecture. The well-known ar-
chitectural problems posed by today’s middleboxes include vio-
lating IP semantics and making the Internet application-speciﬁc;
1Of course, our naming proposal requires alterations to host soft-
ware and, as we discuss later, a new name resolution infrastructure.
These alterations are a signiﬁcant deployment barrier but not one
as unyielding as changing the router infrastructure. We will return
to this issue in Section 6.
343see [15, 31, 60] for details.
To remedy these and other architectural problems, in this paper
we revisit the issue of naming. We begin by describing four general
design principles about the nature and use of names. While these
principles are seemingly innocuous, they are routinely violated in
today’s Internet. We claim that adherence to these principles re-
quires a naming framework with four layers: user-level descriptors
such as search keywords, e-mail addresses, etc.; service identiﬁers
(SIDs); endpoint identiﬁers (EIDs); and IP addresses or other for-
warding directives.2 We then propose an architecture that makes
essential use of these namespaces. This architecture has the fol-
lowing beneﬁts: (1) services and data become “ﬁrst-class” Internet
objects, in that they are named independent of network location or
DNS domain and thus can freely migrate or be replicated across
host and administrative boundaries, (2) mobility and multi-homing
of hosts can be gracefully accommodated, and (3) network-layer
and application-layer middleboxes (which we rechristen “interme-
diaries”) can be interposed on the data path between two commu-
nicating endpoints.
Our principles, naming framework, and architecture rely heav-
ily on existing proposals. From Nimrod [7] and the Host Identi-
ﬁcation Protocol (HIP) proposal [32, 33, 35], we borrow the idea
of decoupling the transport and networking layers to address mo-
bility and multi-homing. From the Unmanaged Internet Protocol
(UIP) proposal [14], we borrow the idea of using this same de-
coupling to address problems that result from private addressing
realms, such as those created by NATs. From the Internet Indirec-
tion Infrastructure (i3) [53], we borrow the idea of source-directed
indirection. From Semantic-Free Referencing (SFR) [59], we bor-
row the idea that the service identiﬁer namespace be ﬂat (meaning
that the identiﬁers are unstructured and not overloaded with any se-
mantics about the object being named, e.g., a ﬂat identiﬁer might be
a number chosen uniformly at random from [0, 2128−1]), and from
HIP and UIP again, we borrow the idea that the endpoint identiﬁers
be ﬂat. Our proposal thus requires a name resolution infrastruc-
ture that can scalably resolve ﬂat names. Distributed hash tables
(DHTs) represent one possible solution to this resolution problem
(see [3,40,42,54,61] for background on DHTs), and so we borrow
from that literature as well.
Thus, this work is a pastiche of borrowed elements; our con-
tribution is both the distillation of some basic principles and their
synthesis into a coherent architecture. We present our four basic
design principles in Section 2, followed by a description of the ar-
chitecture and its beneﬁts in Section 3. A key aspect of the proposal
is ﬂat names, and we discuss the issues associated with them in Sec-
tion 4. We survey related work in Section 5, and in Section 6 we
conclude with a brief discussion.
2. DESIGN PRINCIPLES
Those are my principles, and if you don’t like them...
well, I have others.
Groucho Marx
We now present four basic design principles that we feel are es-
sential to the nature and use of Internet names.
2This naming hierarchy is nothing more than a particular realiza-
tion of Saltzer’s taxonomy of network elements [44], in which he
identiﬁed users/services (our SIDs), hosts (our EIDs), network at-
tachment points (IP addresses), and paths. Since we don’t consider
aspects of the architecture that require router involvement, we don’t
address the issue of naming paths.
2.1 Names and Protocols
Our ﬁrst design principle addresses the role of names in proto-
cols.
Principle #1: Names should bind protocols only to the
relevant aspects of the underlying structure; binding
protocols to irrelevant details unnecessarily limits ﬂex-
ibility and functionality.
This seemingly innocuous principle is routinely violated in to-
day’s architecture. When applications request a service or data,
they care only about the identity (for service) or content (for data)
of the object they requested; the particular end-host servicing a re-
quest is immaterial. However, today’s DNS-based names for ser-
vices and data (e.g., URLs like http ://abc.org/dog.jpg) force
applications to resolve service and data names down to an IP ad-
dress (e.g., to fetch the data named by the URL above, the Web
browser itself, rather than a lower level software module, has to
learn the IP address represented by abc.org), thereby binding the
application request to a particular network location, as expressed
by an IP address. This resolution violates Principle #1 twice over:
it binds data and services to particular end-hosts—and, even worse,
to the network locations of those end-hosts. (In the rest of this pa-
per, for brevity, we mostly use the term “service” to mean “service
and data.”)
Rectifying this double violation requires the introduction of two
(and only two) new naming layers. First, Principle #1 implies that
applications be able to refer to services with persistent names that
aren’t tied to the endpoint hosting the service. We therefore claim
that a class of names called service identiﬁers (SIDs) should exist
that give applications exactly this ability. We think that humans and
the software they use should get these SIDs as the output of various
mapping services that take as input user-level descriptors. By user-
level descriptors, we mean handles in various formats that humans
can exchange (e.g., search queries, e-mail addresses). See [37, 58,
59] for discussion about such mapping services.
Second, transport protocols exchange data between two end-
points, and the network locations of the endpoints are irrelevant
to the basic semantics of transport. Only at the IP layer is the
IP address naturally part of the protocol semantics of best-effort
packet delivery between network-layer addresses. Today, however,
the semantics of IP are wound into the transport layers. For ex-
ample, hosts name TCP connections by a quadruple that includes
two IP addresses. As a result, a TCP connection fails when the IP
address of an endpoint changes,3 and a TCP connection on a multi-
homed endpoint cannot use more than one of the IP addresses at
a time. Principle #1 suggests that transport protocols should be
able to refer to endpoints in a manner independent of their IP ad-
dress or network topology. We thus adopt—from previous work,
as mentioned in Section 1—the idea of a topologically independent
endpoint identiﬁer (EID) that uniquely identiﬁes a host.
These two new naming layers that have been motivated by Prin-
ciple #1 require two additional layers of name resolution: from
SIDs to EIDs and from EIDs to IP addresses. To interact with a
3One solution to this problem, Mobile IP [34], treats the mobile
host’s “home” IP address as a permanent identiﬁer and relies on
IP-layer packet interception and redirection. Another solution is
migrating TCP connections “in-band” [48]. A third is allowing
connections to break but using a session layer to re-initiate broken
connections [47, 49], giving applications the abstraction of an un-
interrupted connection. These three solutions work around the fun-
damental issue: endpoints are named by topological identiﬁers (IP
addresses). None directly addresses the architectural shortcoming.
service (e.g., a Web server), the application initiates a communi-
cation session whose destination is named by the service’s SID.
When an application resolves that SID, it gets one or more EIDs
that identify the end-hosts that run the service. The session will
typically involve one or more transport-layer (e.g., TCP) connec-