uN
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
v5
1
...
1
...
0
...
0
. . .
. . .
. . .
. . .
(cid:1)
. . .
. . .
. . .
. . .
v23
1
...
1
...
0
...
1
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
vN
1
...
0
...
1
...
0
Iu8
ˆIu35
Iv5
ˆIv23
Client
I want to search wi
located at u8 ∈ S0
request row u8, column v5
fetch row Iu8, column Iv5
(1)
request row u10, column v40
(1)
fetch row Iu10, column Iv40
decrypt
(2)
I′u8, I′v5
I′u10, I′v40
re-encrypt
(3)
ˆIu8, ˆIv5
ˆIu10, ˆIv40
(4)
ˆIu35, ˆIv23
assign new address
ˆIu20, ˆIv12
swap
write to row u35, column v23
write to row u20, column v12
(5)
repeat for each search/update operation∗ opi, i = 1, . . . , q
Server S1
Encrypted data structure I(1)
v1
. . .
v12
. . .
v40
. . .
vN
Iu(cid:18)0
ˆIu(cid:19)0
0
...
1
...
1
...
1
. . .
. . .
. . .
. . .
. . .
. . .
. . .
1
...
0
...
0
...
1
. . .
. . .
. . .
. . .
. . .
. . .
. . .
0
...
1
...
1
...
0
. . .
. . .
. . .
. . .
. . .
. . .
. . .
ˆIv12
Iv40
1
...
0
...
0
...
0
u1
...
u10
...
u20
...
uN
data fetched from S0, S1
data uploaded to S0, S1
download
upload
uk: row index
vj: column index
Iuk : encrypted data in row uk
Ivj : encrypted data in column vj
I′uk : decrypted data in row uk
I′vj : decrypted data in column vj
ˆIuk : re-encrypted data in row uk
ˆIvj : re-encrypted data in column vj
*This strategy provides the unlinkability between queries as the same
operation cannot be observed if S0 and S1 are non-colluding. Hence, it prevents leakage from search & update patterns and invalidates statistical attacks.
keyword/ﬁle generates diﬀerent queries to each server. Multiple repetitions of the same
Figure 2: Illustration of a search/update operation on the DSSE encrypted data structure in DOD-DSSE scheme.
indicate that DOD-DSSE is much faster than using ODS
with Path ORAM protocol on dictionary1 and incidence ma-
trix2 data structures, respectively, in terms of end-to-end
delay (Table 1). DOD-DSSE only takes around one second
to perform an access operation on a very large data structure
(see Section 5 for a detailed comparison).
• Formal security analysis and full-ﬂedged implementation:
We fully analyze the security and information leakages of
DOD-DSSE (Section 4.3). We provide a detailed implemen-
tation of DOD-DSSE on two virtual Amazon EC2 servers
and strictly evaluated the performance of DOD-DSSE on
real network settings (Section 5). We also released the im-
plementation of DOD-DSSE for public use3.
These properties make DOD-DSSE an ideal alternative
for privacy-critical cloud applications. We brieﬂy describe
the main idea of DOD-DSSE as follows:
Main idea. Existing DSSE schemes rely on a deterministic
association between the (address) token of a query and its
corresponding encrypted result in the DSSE data structure.
In other words, each query x is represented by a determin-
istic address token-data tuple (ux, Iux ) in the encrypted
data structure I. Despite permitting consistent and fast
search/update operations, these deterministic relations leak
data structure-access pattern as discussed in Section 1.1.
1Dictionary is a ⟨key, value⟩ structure such that given a keyword
key, its corresponding value is a list of ﬁle IDs in which key appears.
This data structure oﬀers sublinear search time, but leaks information
due to its size depending on the ﬁle IDs associated with key.
2Incidence matrix is a data structure which represents the relation-
ship between keywords (indexing rows) and ﬁles (indexing columns)
via its cell value. For example, if matrix entry I[i, j] is set to 1, it
means the keyword indexing the ith row appears in the ﬁle indexing
the jth column. Similarly, the I[i, j] entry is set to 0 if the keyword
indexing the ith row does not appear in the ﬁle indexing column j.
3Available at https://github.com/thanghoang/DOD-DSSE/
The research challenge is to devise cryptographic methods
that can create a random uniform address token-data tuple
(ux, Iux ) for each query x in an oblivious way with just a
small number of communication rounds and processing time.
DOD-DSSE achieves this by using a “fetch–reencrypt–swap”
strategy between two servers as follows:
First, the client creates two encrypted data structures,
each including address-data tuples (ux, Iux ) of all possible
search and update queries, and then sends them to two non-
colluding servers (S0, S1), respectively. To perform a search
or update operation, the client sends a search query and
an update query to each server. One query is for the real
operation while the other three are randomly selected (fake)
queries (Figure 2, step (1)). Each server sends back to the
client the corresponding address-data tuples that have been
queried. After that, the client decrypts the received data
to obtain the result (step (2)), and then re-encrypts them
(step (3)). The client creates new address-data tuple for
each performed query by assigning re-encrypted data to a
random address (step (4)). Finally, the client swaps such
address-data tuples and writes them back to the other server
(step (5)). That means the new address-data tuple of the
query being read from server S0 will be written to server S1
and vice versa. This strategy makes each server observe a
randomized data structure-access pattern with only one-time
repetition of a unlinkable query that has been performed on
the other server, provided that the two servers do not collude.
Section 4 presents detailed constructions of DOD-DSSE .
Limitations. (i) We assume that the two servers storing the
encrypted data structures are non-colluding; (ii) DOD-DSSE
leaks to each server Sb (b = 0, 1) a one-time repetition of
a query that was previously performed on the other server.
This query cannot be linked to any other queries performed
on Sb and it never repeats on Sb again.
We note that the performance and security beneﬁts of
304
DOD-DSSE well-justiﬁes these limitations. Furthermore,
(i) two practical non-colluding servers can be found in real
world as competitive cloud providers such as Amazon, Mi-
crosoft and Google are very unlikely to collude against their
client. (ii) Indeed, we show that with minimal information
leakage (i.e., one-time repetition of an unknown and un-
linkable query on the other server), DOD-DSSE seals all
search/update patterns, prevents statistical attacks which
are main objectives of a secure DSSE. At the same time, it
achieves extremely eﬃcient performance compared to using
ORAM-based techniques. Therefore, DOD-DSSE oﬀers an
ideal security-performance trade-oﬀ for DSSE.
2. PRELIMINARIES
Notation. Given a bit b, ¬b means the complement of
|| denotes a concatenation operation. x $← S means
b.
variable x is randomly and uniformly selected from set S.
S \ {x} denotes x ∈S is removed from S, and |S| denotes
cardinality of set S. {xi}l
i=1 denotes (x1, . . . , xl). κ is a se-
curity parameter. E = (Enc, Dec, Gen) is an IND-CPA secure
symmetric encryption scheme [14], which is comprised of
three algorithms: key generation k ←E .Gen(1κ); encryption
with secret key k on message M as c ←E .Enck(M ); decryp-
tion as M ←E .Deck(c). We denote c ←E .Enck(M, a) and
M ←E .Deck(c, a) as IND-CPA encryption and decryption
with a counter a, respectively. H : {0, 1}∗ → {0, 1}|H| is an
ideal cryptographic hash function, where |H| is the length
of hash output. τ ← KDF(x) is a key derivation function
which takes as input an arbitrary string x ∈{ 0, 1}∗ and
outputs a key τ . f and w denote a ﬁle and a keyword, respec-
tively. m and n denote the maximum number of ﬁles and
keywords in the dataset, respectively. f = (fid1 , . . . , fidm )
denotes the collection of ﬁles. If I is a matrix then Iu denotes
the row indexed by u (i.e., Iu = I[u,∗]). We abuse this
notation to also indicate a whole column indexed by u (i.e.,
Iu = I[∗, u]). This abuse of notation simpliﬁes somewhat the
presentation of our algorithms as well as our security analysis.
Iu[j] means accessing the jth element of Iu. read(u, data) (or
data ← Read(u)) and write(u, data) are read and write oper-
ations on data at address u, respectively and u ← pos(data)
returns the address u where data is located.
Security Deﬁnition. The security notion for DSSE is
Dynamic adaptive security against Chosen-Keyword Attacks
(CKA2) security [13, 12, 21, 26]), which captures information
leakage via leakage functions characterizing the information
leakage due to search and update operations (see [12, 21,
26] for the details). All existing DSSE schemes (e.g. [10,
5, 4, 21, 17, 26] with Dynamic CKA2 security leak data
structure-access pattern which can be deﬁned [23] as follows:
i
, u(b)
D e f i n i t i o n 1. Data structure-access pattern is a data
request sequence −→σb = {op(b)
i=1 of length q over
the encrypted data structure I on server Sb during search
and update operations, where op(b)
i ),
write(u(b)
i )}, u(b)
is the address identiﬁer on Sb to be
read or written and data(b)
to be
read or written on Sb.
is the data located at u(b)
i ∈{ read(u(b)
, data(b)
i }q
, data(b)
, data(b)
i
i
i
i
i
i
Data structure-access pattern leaks search patterns and
update patterns which can be deﬁned as follows:
305
• Search pattern indicates if the same keyword has been
previously searched. Given a query on w at time t, the
search pattern is a binary vector of length t with 1 at
location i if the search i ≤ t was for w, 0 otherwise.
• Update pattern indicates information being leaked dur-
ing an update operation with diﬀerent levels, in that
level 1 (as deﬁned in [26]) leaks least information which
is similar to search pattern. We refer readers to [26]
for a detailed description.
The ORAM security deﬁnition [23] on server Sb is as follows:
D e f i n i t i o n 2. Let APb(−→σb) denote an (possibly ran-
domized) access pattern to Sb given the sequence of data
requests −→σb as deﬁned in Deﬁnition 1. The ORAM scheme
is secure if for any two −→σb and −→σb′ of the same length, their
access patterns APb(−→σb) and APb(−→σb′) are computationally
indistinguishable by anyone but the client.
3. OUR MODELS
System Model. Our system model comprises a client and
two servers S = (S0, S1), each storing an instance of an
encrypted data structure created from the same ﬁle collection.
A s s u m p t i o n 1. Servers communicate with the client
via private channels. (i) (S0, S1) are honest-but-curious,
meaning that they show interest in learning information but
follow the protocol faithfully; they do not inject malicious
inputs to the system. (ii) S0 and S1 do not collude.
Security Model. In DOD-DSSE , data request sequences
(−→σ0, −→σ1) of length q in Deﬁnition 1 are independently ob-
served by servers (S0, S1), respectively. We assume that
the encrypted data structure can store up to N distinct
data items, each corresponding with either a search or an
update query. Each item is represented by a unique address-
data tuple (u, data) in the data structure. The security of
DOD-DSSE scheme relies on the fact that any access opera-
tions op(b)
guaranteed to be unlinkable. This achievement enables us to
protect the data structure-access pattern in each server as
deﬁned in Deﬁnition 1. We deﬁne the unlinkability property
of access operations on the encrypted data structure in DSSE
as follows:
i ∈ −→σb observed by server Sb, for all 1 ≤ i ≤ q are
D e f i n i t i o n 3. Let (u(b)
i
, data(b)
i ), (u(b)
j
, data(b)