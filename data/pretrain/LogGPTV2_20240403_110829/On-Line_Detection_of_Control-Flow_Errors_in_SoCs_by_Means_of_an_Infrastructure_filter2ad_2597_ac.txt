SoC  (including  the  MIPS  core  processor,  the  I-IP  and
independent  code  memories),  both  running  the  same
application, have been used. Faults have been  injected
in  one  of  the  two  architectures,  while  the  other
remained  free  of  faults.  Then,  at  every  core  processor
cycle,  the  simulation  tool  compared  the  value  of  the
program counters from both copies, to check if an error
occurred. At the same time, all errors detected by the I-
IP  were  recorded  in  a  log  file,  indicating  the  type  of
error  that  was  detected  and  other  information  used  in
the  analysis  of 
the  simulation  results.  Figure  3
illustrates the error detection scheme described here.
Memory
Memory
I-IP
I-IP
I-IP
I-IP
Random
Fault Injection
Fault
Fault
Sensitive
Sensitive
Processor
Processor
Golden
Processor
comparator
comparator
Error
Error
Figure 3. Error detection scheme
4.2. Fault coverage analysis
The proposed I-IP detected all SEU errors affecting
the  program  counter  bits  during  the  fault  injection
experiments using the Viterbi application. Some special
detection  cases  deserve  a  closer  analysis,  and  are
described in the following paragraphs.
First, one  must  recall  that  the  MIPS  core processor
uses  byte  addressing  to  read  from  the  code  memory.
Therefore, all instruction addresses must be a multiple
of  4  and,  in  some  MIPS  implementations,  a  value
different from zero in the two low order bits of the PC
generate  a  processor  exception.  In  the  implementation
used in our experiments, this was not true, and the I-IP
itself was responsible to detect those errors by checking
if the two bits are equal to zero for every fetch.
the  program  counter.  Due 
Second,  approximately  3%  of  the  detected  errors
were caused by faults that hit the 3rd least significant bit
of 
instruction
addressing scheme described in the previous paragraph,
when a bit flip from ‘1’ to ‘0’ of the 3rd bit occurs, it is
equivalent  to  keep  in  the  program  counter  the  same
value that was used in the previous cycle, what would
make the processor execute the same instruction again,
sometimes  affecting 
the
program  execution.  In  order  to  cope  with  these  cases,
the I-IP checks if two consecutive fetch operations ask
for the same  memory  address  and,  if  so,  sends back  a
nop instruction to the core processor. On the other hand,
when a SEU in the 3rd bit causes a bit flip from ‘0’ to
‘1’, one instruction is skipped and not executed; in this
case, the I-IP detects the error because the fetch address
the  results  produced  by 
the 
to 
is  not  the  expected  one  (address  A  +  size  of  the
instruction).
Finally,  although  in  this  experiment  all  errors  have
been  detected,  it  is  important  to highlight  that  there  is
one case in which the proposed I-IP fails in detecting an
incorrect  branch.  This  very  unlikely  situation  can
happen  only  with  conditional  branch  instructions,  for
which  there  are  two  alternative  valid  destination
addresses,  one  to  be  used  when  the  branch  is  taken
(Ataken), and the other when the program has to proceed
with  the  instruction  immediately  following  the  branch
(Anext).  It  happens  when  a  fault  occurs  exactly  during
the execution cycle of a conditional branch instruction,
and that fault changes the value of the program counter
in  such  a  way  that  the  corrupted  value  is,  by  extreme
coincidence,  equal  to  the  other  valid  value  for  that
branch instruction, i.e., Ataken is transformed in Anext, or
vice versa.
In  order  to  detect  such  situation,  it  would  be
necessary to add new capabilities to the I-IP, allowing it
to  duplicate  all  instructions  that  affect  the  condition
flags  of  the  core  processor  and  keep,  inside  the  I-IP,
replicas  of  the  condition  codes,  in  order  to  use  their
values to check the evaluation of conditions during the
execution  of  conditional  branch 
instructions.  The
additional  area  that  would  be  required  to  implement
these  features,  as  well  as  the  performance  and  area
penalties that  would be  incurred,  make  this  alternative
not feasible.
4.2. Performance and area analysis
As commented in Section 2, most of the control flow
error detection techniques proposed so far imply heavy
performance and/or area overheads.
The  technique  proposed  in  this  paper,  besides  its
good  error  detection  capability,  requires  very  small
performance and area overheads, as shown in Table 1.
Table 1. Performance and area overheads
Without I-IP With I-IP Overhead
13.59%
8,779
9,972
38,340
41,982
9.5%
Performance
(# of cycles)
Area
(# of gates)
The performance information in Table 1 relates only
to the execution of the specific Viterbi algorithm used
in the experiments, which is normally executed by the
core processor in 8,779 cycles. As described in Section
4,  when  the  I-IP  is  present  in  the  SoC,  it  replaces
branches and jump and link instructions by sequences of
instructions,  thereby  introducing  some  overhead.  For
the  Viterbi  algorithm,  1,193  additional  cycles  were
necessary, a 13.59% increase in the computation time.
However,  depending  on  the  use  of  those  specific
instructions, other applications may behave differently.
Concerning  the  area  overhead,  the  circular  register
file  used  by  the  I-IP  to  keep  the  addresses  to  be  later
compared with the PC contents is responsible for most
of  it.  Because  our  technique  has  been  designed  to  be
non-intrusive, the I-IP must store locally all information
needed to check the control flow from outside the target
processor.
As  opposed  to  the  performance  overhead,  the  area
overhead is application independent, which means that
the  area  overhead  figures  in  Table  1  will  remain  the
same for any other application.
5. Conclusions and future work
and 
This paper proposes the use of an infrastructure IP as
a means to detect control flow errors caused by transient
faults  affecting  the  program  counter  of  the  core
processor in a SoC.
hardware 
application 
The  technique  is  non-intrusive,  both  from  the  core
processor 
software
standpoints,  and  in  our  experiments  has  been  able  to
detect all errors caused by SEUs affecting the program
counter bits of a pipelined MIPS processor executing a
benchmark  application,  with  small  performance  and
area  overheads,  when  compared  with  most  of  the
alternative techniques discussed in Section 2.
As  to  the  fault  detection  capability,  the  proposed
technique  has  shown  to  perform  better  than  related
ones, with an error detection coverage of 100% for the
benchmark application used in the tests, and with only
one  non  detectable  situation,  which  has  an  almost
negligible probability of occurrence.
The next steps in this project will be the repetition of
the  experiments  with  a  broader  set  of  benchmark
applications, and the development of tools to automate
the  generation  of  new  I-IP  versions  for  other  core
processors.
6. References
[1]  Mahmood,  A.,  and  McCluskey,  E.  J.,  “Concurrent  Error
Detection  Using  Watchdog  Processors  –  a  Survey”,  IEEE
Transactions  on  Computers,  vol.  37,  no.  2,  IEEE  Computer
Society, New-York-London, February 1988, pp 160-174.
[2]  Lisbôa,  C.  A.  L.,  Carro,  L.,  Sonza  Reorda,  M.,  and
Violante,  M.  “Online  Hardening  of  Programs  against  SEUs
and  SETs”,  in  Proceedings  of  the  21st  IEEE  International
Symposium on Defect and Fault Tolerance in VLSI Systems -
DFT  2006,  IEEE  Computer  Society,  Los  Alamitos,  CA,
October 2006, pp. 280-288.
[3] Torellas, S., Nicolescu, B., Velazco, R., Valderas, M. G.,
and Savaria, Y., “Validation by fault injection of a Software
Error Detection Technique dealing with critical Single Event
Upsets”, in Proceedings of the 7th IEEE Latin-American Test
Workshop  (LATW  2006),  Evangraph,  Porto  Alegre,  RS,
Brasil, March 2006, pp. 111-116.
[4]  B.  W.  Johnson,  Design  and  Analysis  of  Fault  Tolerant
Digital  Systems:  Solutions  Manual,  Addison-Wesley
Publishing Company, Reading, MA, October 1994.
[5]  Austin,  T.,  “DIVA:  A  Reliable  Substrate  for  Deep
-
Submicron  Microarchitecture  Design”. 
Proceedings of the 32nd ACM/IEEE International Symposium
on  Microarchitecture,  pages  196-207,  Los  Alamitos,  CA,
November, 1999.
In  MICRO32 
[6]  Breveglieri,  L,  Koren,  I,  and  Maistri,  P.,  “Incorporating
Error  Detection  and  Online  Reconfiguration  into  a  Regular
Architecture  for  the  Advanced  Encryption  Standard”.  In
Proceedings  of  the  20th  IEEE  International  Symposium  on
Defect  and  Fault  Tolerance  in  VLSI  Systems  -  DFT  2005,
IEEE  Computer  Society,  Los  Alamitos,  CA,  October  2005,
pp. 72-80.
[7]  K.  H.  Huang,  J.  A.  Abraham,  “Algorithm-Based  Fault
Tolerance  for  Matrix  Operations”,  IEEE  Transactions  on
Computers, vol. 33, December 1984, pp. 518-528.
[8] N. Oh, P.P. Shirvani, and E.J. McCluskey. “Control flow
Checking  by  Software  Signatures”,  IEEE  Transactions  on
Reliability, Vol. 51, No. 2, March 2002, pp. 111-112.
[9] Goloubeva, O., Rebaundengo, M., Sonza Reorda, M., and
Violante,  M.,  “Soft  Error  Detection  Using  Control  Flow
Assertions”,  in  Proceedings  of  the  18th  IEEE  International
Symposium on Defect and Fault Tolerance (DFT 2003), IEEE
Computer  Society,  Los  Alamitos,  CA,  November  2003,  pp.
581-588.
[10] P. Bernardi, L. M. V. Bolzani, M. Rebaudengo, M. Sonza
Reorda,  F.  L.  Vargas,  M.  Violante.  “A  New  Hybrid  Fault
IEEE
Detection  Technique 
Transactions  on  Computers,  Vol.  55,  No.  2,  February  2006,
pp. 185-198.
for  Systems-on-a-Chip”, 
[11]  M.  Namjoo,  “CERBERUS-16:  An  architecture  for  a
general  purpose  watchdog  processor”,  in  Proceedings  of  the
13th  International  Symposium  on  Fault-Tolerant  Computing
(FTCS-13), 1983, pp. 216-219.
[12] K. Wilken, J.P. Shen, “Continuous signature monitoring:
low-cost  concurrent  detection  of  processor  control  errors”,
IEEE Transactions on Computer-Aided Design of Integrated
Circuits and Systems, Vol. 9, No. 6, June 1990, pp. 629-641.
[13] J. Ohlsson, M. Rimen, “Implicit signature checking”, in
Digest  of  Papers  of  the  25th  International  Symposium  on
Fault-Tolerant Computing (FTCS-25), 1995, pp. 218-227.
[14]  Miremadi,  G.,  and  Torin,  J.,  “Evaluating  Processor
Behavior  and  Three  Error-Detection  Mechanisms  Using
Physical  Fault-Injection”,  IEEE  Transactions  on  Reliability,
vol.  44,  no.  3,  IEEE  Computer  Society,  New-York-London,
September 1995, pp 441-454.
[15]  Alkhalifa,  Z.,  Nair,  V.  S.  S.,  Krishnamurthy,  N.,  and
Abraham,  J.  A.,  “Design  and  Evaluation  of  System-Level
Checks  for  On-line  Control  Flow  Error  Detection”,  IEEE
Transactions on Parallel and Distributed Systems, vol. 10, no.
6,  IEEE  Computer  Society,  New-York-London,  May-June
1999, pp 627-641.
[16] A. C. S. Beck Fo, J. C. B. Mattos, F. R. Wagner, and L.
Carro,  “CACO-PS:  A  General  Purpose  Cycle-Accurate
Configurable  Power-Simulator”,  in  Proceedings  of  the  16th
Brazilian  Symposium  on  Integrated  Circuits  and  Systems
Design (SBCCI 2003), Sep. 2003.
[17]  Nicolescu,  B.,  Savaria,  B.,  and  Velazco,  R.,  “Software
detection  mechanisms  providing  full  coverage  against  single
bit-flip  faults”.  IEEE  Transactions  on  Nuclear  Science,  vol.
51, no. 6, part 2, IEEE Computer Society, New-York-London,
May-December 2004, pp 3510-3518.