of the entire supply chain.
We do not consider physical attacks to legitimate readers, tags, or
tag-item attachment. Existing technical or management solutions
to thwart such attacks [21] are essentially complementary to our so-
lution. While we do not exclude the possibility that RFID readers
and/or tagged items can be in the possession of some attackers, we
assume that the attackers cannot access the stored secrets by break-
ing into RFID readers or tags, though they can probe, monitor, re-
play, or analyze the wireless communications between readers and
tags. We also assume that attackers cannot detach RFID tags from
their attached items without physically destroying the functionality
of tags and items.
We do not address possible denial of service to legitimate readers
(as in most RFID security and privacy papers3). Such attacks can
be easily detected by legitimate readers. Since the sources of such
attacks must be situated in an area physically close to the victim
readers, detected attacks can be thwarted by inspecting the area
and removing the attack sources.
3.2 System Setup
For every partner Pi, let Sigi(m) denote a public key signa-
ture generated by Pi on message m, and Enci(m) denote a public
key encryption under Pi’s public key on message m. (Note that
Pi may have different public key pairs for signatures and encryp-
tion.) Let l be the maximum length of RFID tags’ serial numbers.
For ∀ i > 1, Pi selects a secret key ki ∈R {0, 1}l and sends
Enci−1(ki, Sigi(ki)) to its upstream partner Pi−1.
In this way,
Pi securely sends his secret key ki to Pi−1 with non-repudiation.
Pi−1 accepts the key if the signature is veriﬁed true under Pi’s sig-
nature public key. Moreover, a strong collision resistant hash func-
tion H(·) : {0, 1}∗ → {0, 1}l is selected for all partners. H(·)
digests an any-bit long binary string into an l-bit long binary string.
RFID Tag Initialization P1 is responsible for RFID tag initializa-
tion. The data pertaining to an RFID tag includes a serial number
and an access key:
• Tag Serial Number (C): A globally unique number that serves
as the identity of the tag.
• Access Key (K): A l-bit secret key shared with the assigned
RFID readers.
3Some RFID solutions such as blocker tags [11] actually utilize the
denial of service to protect consumer’s privacy, preventing RFID
tags from being read by any (rogue) readers beyond the point-of-
sale.
236
in Section 4. Our Read protocol described below only shows the
interaction between one tag and a reader.
Step 1: Reader → Tag: The reader selects a non-zero nonce
r ∈R {0, 1}l and sends it to the tag.
Step 2: Tag → Reader:
If r = 0, Abort. Otherwise, the tag
computes t = H(r ⊕ α) and sends t back to the reader as the
response.
Step 3:
rithm 1 to identify the engaged tag.
Identiﬁcation by Reader: The reader executes Algo-
if sj = 0 then
rj ← r
tj ← H(cj ⊕ rj ⊕ ki)
Algorithm 1 RFID Identiﬁcation
Input:database Di = {d1, d2, · · · , dn}, tag’s reply t, nonce r, key ki
Procedure:
1: for every entry dj = (cj , rj , tj , pj , sj ) in Di, 1 ≤ j ≤ n do
2:
3:
4:
5:
end if
6: end for
7: Search an entry dz ∈ {di|si = 0}, such that tz = t.
8: if dz is found then
9:
10: else
11:
12: end if
sz ← 1 and the tag in read is accepted.
Abort, the identiﬁcation of the tag fails.
Note that if the tag is a legitimate one, its access key k is the same
as Pi’s key ki, i.e. k = ki. The basic idea of Algorithm 1 in Step 3
is similar to a dictionary attack on a password ﬁle with salts. Using
the nonce r, the reader computes all possible responses for all un-
marked tags in the database Di. Then, the reader searches t from
her computation results. If no match is found, the reader aborts the
transaction since it is unable to identify this tag. Otherwise, the
reader retrieves from the database Di the entry (c, m, t, p, s) and
sets s = 1. From the pointer in this record, Pi is able to locate
relevant information with respect to this RFID tag.
Write Protocol
The write process is to update a tag’s access key so that it can be ac-
cessed securely by the authorized readers of the next partner Pi+1.
Moreover, it helps to resist tracing attacks. In essence, the reader
of Pi writes ki+1 to an RFID tag. The protocol is as follows:
Step 1: Reader → Tag The reader computes a = ki ⊕ ki+1 and
b = H(a ⊕ c ⊕ ki). It sends (a, b) to the tag.
Step 2: Veriﬁcation by Tag On receiving (a, b) from the reader,
the tag authenticates the reader by checking whether b = H(a⊕α).
If so, it updates α by computing α = a ⊕ α; Otherwise, the tag
rejects the write command.
In the write command, b is essentially an authenticator for a. It
passes the tag’s veriﬁcation provided that the reader has the knowl-
edge of both the tag’s serial number c and it access key k. Note
that a tag’s content α is never released to any reader. Therefore, to
update a tag, the reader must successfully identify the tag.
4. ANALYSIS
In this section, we analyze our scheme with respect to the secu-
rity requirements posed by supply chain management as discussed
in Section 2.
4.1 Authoritative Access to RFID tags
Ideally, RFID applications would allow an RFID tag to authen-
ticate a reader which attempts to read or write it. Since RFID
read protocol is time-critical especially in batch process mode, the
standard shared-key based authentication protocols cost undesir-
able delay. In our solution shown in Section 3, the tag responses
Instead of storing both C and K, a pseudonym α, which is an XOR
result of C and K, i.e., α = C⊕K, is stored in the tag. The format
of the content of RFID tag is the following:
Tag Pseudonym (α)
Table 1: The Format of RFID Tags
P1 initializes an RFID tag as follows. She ﬁrst determines the tag
serial number, c, according to the item which this tag is supposed to
attach to. She then assigns k2 as the access key, Finally, she writes
c ⊕ k2 into the tag.
Database Initialization Each Pi maintains a database Di in her
local storage. Each tuple in the database corresponds to a tag. Di
contains all RFID information with respect to the said shipment.
Speciﬁcally, Di has the following structure, where n is the number
of tags for the current shipment:
• Tag Serial Number (C) : the same as deﬁned in last para-
graph.
• Tag Secret Mask (R): a secret random number used for tag
authentication.
• Tag Response (T ): the response (to be) received from the
corresponding RFID tag.
• Pointer: An octet string containing an address where the
business information relevant to the tag is stored. An alter-
native approach is to store information in this ﬁeld directly.
Obviously, it trades the storage cost for communication efﬁ-
ciency.
• Status (S): a binary bit. ’s=1’ means that the corresponding
RFID tag has been processed; otherwise, ’s=0’. Throughout
the paper, we call an entry is unmarked if its status is not set
as 1.
For convenience, the j-th entry in the database, (cj, rj, tj, pj, sj),
is denoted by dj. Di is represented by {d1, d2,··· , dn}.
Ini-
tially, Di is empty. To process the incoming material ﬂow, Pi,
1 < i ≤ N, either receives or downloads all serial numbers and
pointers of Di−1 from Pi−1 through a secure communication chan-
nel. Pi sets all sj = 0, 1 ≤ j ≤ n. All other ﬁelds are initially
empty. Note that Pi and Pi−1 share a secret key ki. Therefore, a
secure communication channel is easily established in a standard
fashion. Since P1 is the originator of the supply chain, she initial-
izes her D1 after setting up RFID tags described previously.
3.3 RFID Read/Write Protocol
RFID tags are read and written by RFID readers under each part-
ner’s management. The read and write operations of RFID read-
ers need the support from the back-end servant computers. Since
the communications between readers and servant computers can
be easily protected by standard encryption and authentication tech-
niques, we do not discuss its relevant security issues in this paper.
We show below how an RFID reader of partner Pi interacts with
an RFID tag using Read/Write protocols (see illustrations in Figure
2). Without loss of generality, let the tag’s serial number be c,
access key be k and its stored value be α.
Read Protocol
The ultimate goal of Read protocol for Pi’s reader is to extract a
tag’s serial number and retrieve its corresponding record from the
database. In practice, an RFID reader usually interacts with multi-
ple RFID tags in a batch. We leave the discussion of batch process
237
Tag Serial Number (C)
c1
...
cn
Tag Secret Mask (R)
r1
...
rn
Table 2: The structural deﬁnition of database Di
Tag Response (T )
t1
...
tn
Pointer
p1
...
pn
Status
s1
...
sn
Figure 2: Protocol for RFID communications in supply chains
to any query without explicit authentication. Nonetheless, only au-
thorized readers are able to interpret the responses and extract their
identities whereas a malicious reader obtains no meaningful infor-
mation from its interrogation. With such an implicit authentication
approach, we minimize RFID tags’ response time without compro-
mising security. In Write protocol, our solution is similar to HMAC
[3] which authenticates the source of the write command.
We summarize the security with respect to authoritative access
in the following statement.
STATEMENT 4.1. Consider an RFID tag delivered by partner
Pi−1 to partner Pi. Only Pi’s reader is able to read the tag’s serial
number. Furthermore, only Pi’s reader is able to write to this tag.
(Proof Sketch) On any read challenge r, the tag responses with
t = H(r ⊕ α). Since α = k ⊕ c, therefore t = H(r ⊕ k ⊕ c). It is
straightforward to observe that only with knowledge k can a reader
compute tag serial number c such that it satisﬁes t = H(r⊕ k⊕ c).
Before delivering an RFID tag to Pi, Pi−1 has updated the tag’s
access key with k = ki, where ki is Pi’s secret key. Thus, Pi
is able to locate c. Moreover, a secure hash function is one-way.
Namely, no polynomial-time bounded entity is able to derive its
pre-image r ⊕ α from t. Thus, an unauthorized reader is unable to
acquire any signiﬁcant information of the tag’s identity c.
In the write command (a, b), b is in fact an authenticator of a, in
the same manner as using HMAC, where c ⊕ k is the shared key
between Pi’s reader and the tag. Due to the weak collision resis-
tance of hash function H, only with the knowledge of c and k, can
the reader compute b = H(a⊕ c⊕ k). It implies that the originator
of (a, b) is in possession of the matching key ki. Therefore, only
commands from the authorized reader can be accepted by the tag.
2
Note that Pi−1 can read/write a tag shipped to Pi as well, since
ki is shared between Pi−1 and Pi. This imposes no risk since Pi−1
has processed all tags. Before the material ﬂow arrives at Pi, Pi−1
is still involved. However, immediately after Pi updates RFID tags,
Pi−1’s privilege to read/write becomes invalid.
4.2 Authenticity of Tags
The use of nonce in Read protocol is to thwart tag cloning at-
tacks [7]. If no nonce is used in the protocol, it is vulnerable to
cloning and replay attacks. A rogue reader can easily probe a valid
tag, and then clones this tag by copying its received response to
tags at her disposal. Note that a supply chain’s reader is unable to
distinguish the original tag and a cloned malicious tag. Such fail-
ures cause ﬁnancial losses. The authenticity of tags in our protocol
is summarized in the following statement.
STATEMENT 4.2. Given a nonce r, it is computationally infea-
sible for an adversary, without the knowledge of ki, to ﬁnd a pair of
serial number c and valid response t, such that t = H(r ⊕ c⊕ ki).
238
Find c from DiSearch Dkfor a single record (c, r, t,p,s) such that t=H(r c ki)If not found, the tag is unidentifiedOtherwise update the tag in step 3)3) update: a=ki ki+1, b=H(a c ki)t=H(r)readertagdatabasememoryH(), H(), Di:  C,R,T,Pointer, Status1) query: r2) reply: tCheck if b = H(a)If no, the reader is unidentifiedOtherwise update withaAccess Key ki, ki+1(Proof Sketch) This is obvious, as providing (c, t) satisfying the
hash equation without knowledge of ki is equivalent to the reverse
of the hash function. In fact, the adversary is even unable to ﬁnd
(α, t) satisfying t = H(r⊕α). Thus, for a randomly chosen nonce,
no faked tag will be accepted by the reader.
2
n
However, the use of nonce for tag authentication is at the cost of
higher computation complexity on the reader’s side. In the worst
case, the reader needs to conduct n hashing computations, O(n log n)
sorting operations, and log n!
comparisons for reaching a tag. This
complexity is naturally high even though all the necessary compu-
tations are executed by the reader (including the Savant computer).
To reduce the complexity of authentication to a practical level
without sacriﬁcing much anti-cloning capability, a fresh nonce can
be used for authenticating a batch of multiple tags, instead of a sin-
gle tag. The total n tags are partitioned into m batches such that
all the tagged items in the same batch share the same nonce and are
processed concurrently. Different batches have their own unique
fresh nonce. Such an approach conforms with supply chain prac-
tice where tagged items often arrived together and are processed in
batches. For simplicity, we assume that each batch consists of n/m
tags.
Before the arrival of a batch of tagged items, the RFID reader
will (i) update the unmarked records in its database with a fresh
nonce r, i.e. to set tj = H(r ⊕ ki ⊕ cj) for each unmarked tag cj,
and (ii) sort the unmarked records according to the updated hash
values. This process is called batch pre-processing, which happens
before reader interacting with each tag in a batch. The batch pre-
processing takes maximum n (minimum n/m) hashing computa-
tions and O(n log n) (minimum O(n/m log n/m)) sorting opera-
tions for processing the ﬁrst batch (last batch) of tags. In section
4.5, we will illustrate that the time cost for batch pre-processing is
sufﬁciently low even for an unrealistically large number n.
Upon the arrival of a batch of tagged items, the RFID reader will
(i) initiate Read protocol with the same nonce r for interrogating
all tags in the batch in parallel, and (ii) verify each tag’s response
against the unmarked records in its updated and sorted database.
This process is called real-time searching. For simplicity, we as-
sume that the binary search is used in the searching process4. The
complexity of authenticating each tag in this process is given below.
STATEMENT 4.3. To authenticate and read n tags processed
in m batches, a legitimate reader on average needs to conduct
log n!
n = O(log n) comparisons per tag.
(Proof Sketch) With the updated and sorted database, the reader
will authenticates all n/m tags in the ﬁrst batch by verifying each
tag’s reply against the unmarked database records and marking the
matched record. This requires log n + log(n− 1) + . . . + log(n−
n/m + 1) comparisons in binary search.
Similar to the ﬁrst batch, it requires log(n − n/m) + log(n −
n/m − 1) + . . . + log(n − 2n/m + 1) comparisons for the sec-
ond batch (if any). In the end, the last batch demands log n/m +
log(n/m − 1) + . . . + log 1 comparisons.
Overall, the reader needs to conduct log n + log(n − 1) + . . . +
n =
2n − 1) = O(log n) com-
2
We observe that in some supply chain applications, partner Pi