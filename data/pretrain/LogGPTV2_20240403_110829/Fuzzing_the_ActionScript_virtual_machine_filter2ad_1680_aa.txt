title:Fuzzing the ActionScript virtual machine
author:Guanxing Wen and
Yuqing Zhang and
Qixu Liu and
Dingning Yang
Fuzzing the ActionScript Virtual Machine
Guanxing Wen, Yuqing Zhang, Qixu Liu, Dingning Yang
National Computer Network Intrusion Protection Center
School of Computer and Control, UCAS, Beijing 100049 PR China
PI:EMAIL, {zhangyq, liuqixu}@ucas.ac.cn, PI:EMAIL
ABSTRACT
Fuzz testing is an automated testing technique where ran-
dom data is used as an input to software systems in order to
reveal security bugs/vulnerabilities. Fuzzed inputs must be
binaries embedded with compiled bytecodes when testing
against ActionScript virtual machines (AVMs). The cur-
rent fuzzing method for JavaScript-like virtual machines is
very limited when applied to compiler-involved AVMs. The
complete source code should be both grammatically and se-
mantically valid to allow execution by ﬁrst passing through
the compiler. In this paper, we present ScriptGene, an algo-
rithmic approach to overcome the additional complexity of
generating valid ActionScript programs. First, nearly-valid
code snippets are randomly generated, with some controls
on instruction ﬂow. Second, we present a novel mutation
method where the former code snippets are lexically ana-
lyzed and mutated with runtime information of the AVM,
which helps us to build context for undeﬁned behaviours a-
gainst compiler-check and produce a high code coverage. Ac-
cordingly, we have implemented and evaluated ScriptGene
on three diﬀerent versions of Adobe AVMs. Results demon-
strate that ScriptGene not only covers almost all the blocks
of the oﬃcial test suite (Tamarin), but also is capable of
nearly twice the code coverage. The discovery of six bugs
missed by the oﬃcial test suite demonstrates the eﬀective-
ness, validity and novelty of ScriptGene.
Categories and Subject Descriptors
D.2.5 [Testing and Debugging]: Testing tools
Keywords
Fuzz testing, Vulnerability discovery, ActionScript
1.
INTRODUCTION
The theory of application virtual machines is well devel-
oped. An application virtual machine (VM) isolates the host
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIA CCS’13, May 8–10, 2013, Hangzhou, China.
Copyright 2013 ACM 978-1-4503-1767-2/13/05 ...$15.00.
OS from a single process. The VM is created when the asso-
ciated process is started and destroyed when the associated
process exits [27]. VM Implementations can be divided in-
to two categories based on the code execution. JavaScript-
like VMs accept source code directly, interpreting and ex-
ecuting code lines sequentially. ActionScript-like VMs ac-
cept only bytecodes generated by a compiler from source
code. This additional compilation stage adds complexity
to ActionScript-like VMs when compared to JavaScript-like
VMs. Since many VMs are programmed using C/C++, it is
not surprising that they contain bugs similar to other com-
plex software systems.
Fuzz testing or fuzzing is a form of testing heavily used for
ﬁnding security vulnerabilities in software. Since complete-
ly random strings generated by traditional fuzzing methods
do not usually execute in VMs, grammar-based fuzzing is
employed instead. Grammar-based whitebox approach of
[17] has been used on a JavaScript VM. They presented
a dynamic test-case generation algorithm, where symbol-
ic execution directly generates grammar-based constraints,
whose satisﬁability is veriﬁed using a custom grammar-based
constraint solver. The solver solves the altered constraints
and directs code snippet generation to cover more execution
paths of the VM. Unfortunately this approach is limited to
JavaScript-like VMs, since feedback operates on the input
directly. In comparison, ActionScript-like VMs only accept
binaries embedded with bytecodes, which are the outputs
of the compiler. Therefore, a hypothetical solver is unable
to analyze and generate new pieces of code as inputs, ren-
dering this approach ineﬀective. Grammar-based blackbox
approach of [19] is yet another eﬀective fuzzing method on
VMs. Previously, this approach has also been restricted to
testing JavaScript-like VMs. Both grammar-based whitebox
and blackbox fuzzing methods focus only on the grammar,
ignoring the substantial contributions of runtime class, prop-
erty and API functions to the discovery of bugs in VMs.
To overcome the diﬃculties associated with fuzzing of
ActionScript-like VMs, we have created ScriptGene. Script-
Gene generates ActionScript (AS) source code, compiles and
executes them on Adobe Flash ActionScript Virtual Ma-
chines (AVMs). As seen in ﬁgure 1, the left-hand side se-
quence of block diagrams, connected by downward arrows
illustrates the ScriptGene code generation process. Pri-
or to the code generation, a knowledge base is built by
interpreting the grammar ﬁle of AS and the oﬃcial test
cases. Then, grammar-based blackbox methods generate
nearly-valid code. The right-hand side sequence of the ﬁg-
ure with upward arrows illustrates the mutation phase. A
457lexier marks all the identiﬁers in source code, pointing to
functions, classes and variables with markers, followed by
mutations and substitutions of markers with actual runtime
class information. Lastly, the test case programs are created
and sent to the target AVM.
Figure 1: ScriptGene workﬂow.
In comparison with earlier approaches, ScriptGene’s test-
generation techniques substantially advance the state of the
art in fuzzing VMs by generating compilable and expressive
random source code of high complexity, employing many
AS language features. Compiler-validity is ensured by gen-
erating AS code that does not contain undeﬁned classes,
variables or functions; nor depend on random arrangements
of the code structure. Currently, ScriptGene generates AS
programs suitable for testing AVMs. Flexibility of our ideas
underpinning ScriptGene, as well as our speciﬁc implemen-
tation should easily port to test other VMs. This paper
summarizes the construction of ScriptGene and some of its
current testing results.
Adobe Flash is a multimedia platform used to add ani-
mations to web pages and hybrid document formats such as
PDFs and Oﬃce documents. Usually, Adobe Flash ﬁles with
the “.SWF” (SWF) extension are treated as harmless ﬁles or
as videos by the host OS. AS code inside SWFs are typically
used to control animations and merely contain functions to
operate natively on local resources (e.g., disk, process. . . ).
Thus, AVMs are running in trusted environments. If a SWF
ﬁle triggers a vulnerability of the AVM and executes na-
tive code out of the trusted environment, the local resources
could be compromised. Furthermore, Just-In-Time compil-
ers (JIT) of AVMs can be used to breakthrough memory
protection methods such as ASLR and DEP [16]. APT at-
tack to RSA [15] in 2011 demonstrated the ramiﬁcations of
AVM security vulnerabilities.
AVMs were chosen as the testing targets for two reasons.
First and foremost, vulnerabilities in trusted environments
are intrinsically harmful, more so than an equivalent lan-
guage that operates on the local resources natively. Sec-
ond, there appears to be a lack of existing grammar-based
approaches focusing on ActionScript-like languages, where
compilers are involved.
(cid:15) Our ﬁrst contribution is the implementation of a grammar-
based blackbox method to fuzz test complier-involved
AVMs. Our implementation has covered almost all the
code blocks (>96%) of the oﬃcial test cases.
(cid:15) Our second contribution is the advancement of the s-
tate of the art in grammar-based blackbox test code
generation, coupled with runtime class mutations. Our
approach not only has allowed us to gain addition-
al code coverage to nearly double that of the oﬃcial
test cases in our experiments, but also has discovered
six previously undocumented bugs in three versions of
AVMs [11] that were missed by the oﬃcial test cases.
The remainder of this paper is organized as follows. Sec-
tion 2 presents the technical details on ScriptGene, from the
code generation phase to the runtime class mutation phase.
Section 3 details the actual implementation and discusses
our evaluations. Section 4 discusses related works and the
state of the art in fuzz testing. Section 5 details the sim-
pliﬁed strategy for ScriptGene and some of its limitations.
Section 6 concludes the paper.
2. SCRIPTGENE
The basic concepts behind ScriptGene are in Section 2.1.
The additional grammar controls are in Section 2.2. Our AS
code generation algorithm is presented in Section 2.3. Ex-
traction of runtime information for runtime class mutations
is detailed in Section 2.4. Mutation of extracted informa-
tion into code to create compilable source code is presented
in Section 2.5.
2.1 Basic concepts and terminology
ActionScript and AVMs There are currently two ver-
sions of AS: AS2 and AS3, executed by AVM1 and AVM2.
AS2 lacks many new features, such as 3D presentations and
is less eﬀective in code execution as compared to AS3. AS3
is chosen, since it is the version most frequently employed
by current SWFs. AS3 based on ECMAScript4 standard [6]
is an object-oriented programming language used to build
SWFs. Unless otherwise noted, AS refers to AS3 and AVM
refers to AVM2 hereafter.
Grammar ﬁles In order to generate and parse source
code, the grammar ﬁle [7] written in ANTLR, containing
the grammar standards of AS is utilized. ANTLR is a pars-
er generator framework written by Parr and Quong [23].
Once the grammar ﬁle is established, the task of building a
parser is similar to compiling source code. In addition to the
AS parser, an ANTLR language parser parses the ANTLR
format AS grammar ﬁle, since we wish to generate AS code
snippets beyond merely parsing them. Since some features
of ANTLR are only enabled under Java, Java is used to parse
source code. Other parts of ScriptGene are programmed in
Python, to leverage its string manipulation capabilities.
ANTLR ParserActoinScript ParserActoinScript LexerCode generationTest SuiteAlmost valid ActionScriptActionScript grammar fileActionScript grammaritSample codeRuntime Class InfoMarked ActionScriptRuntime Class MutationValid ActionScriptCompile and Run458In total, there are three grammar ﬁles for ScriptGene: a
grammar ﬁle used to build a parser for AS (G1), a grammar
ﬁle used to guide the AS code generation process (G2) and
a grammar ﬁle used to build a parser for ANTLR (G3).
G2 is a modiﬁed version of G1, which will be explained in
Section 2.2. G3 is the oﬃcial ANTLR grammar ﬁle inside
the example directory of its Java distributions.
Grammar rules in ANTLR format In ANTLR, AS
grammar elements can be divided into three categories: rules,
blocks and atoms. Rules comprise the main structures list-
ed in an ANTLR format grammar ﬁle. Rules also con-
tain sub-rules. Sub-rules are mixtures of blocks and atom-
s. Blocks consist of atoms. Atoms represent terminal and
non-terminal nodes. Non-terminal nodes are other rules and
terminal nodes are tokens or real characters inside a range.
For the code generation phase, only the knowledge of node
extensibility is required. If the node stands for a rule, it is
extensible and ready to be extended with sub-rules, other-
wise, no action is performed to this node until the end.
2.2 Adding control to grammar rules
The generated code should contain a diversity of gram-
mar structures and runtime class interactions, while being
easy to mutate and free of non-interesting code structure.
Simultaneously, the generated code must be compilable. To
satisfy these requirements, two controls are added to the
production of AS code during opportune stages of Script-
Gene before compilation. First control consists of modiﬁ-
cations to the grammar ﬁle and the second control consists
of adjustments to the context during the mutation phase
(Section 2.5). Although adjustments of the grammar ﬁle
are less ﬂexible than that of the runtime class mutations
Python code, the foremost occurrence of the grammar ﬁle
in the ScriptGene generation process necessitates that it be
given a higher adjustment priority. This allows the removal
of root causes of potentially troublesome structures from
the compiler. G2 is therefore created from G1 under a few
controls (e.g., simpliﬁcation, ignorance, modiﬁcation...) of
select rules. G2 is then transformed into a Python source
ﬁle by the ANTLR parser.
Simpliﬁcation rules ANTLR allows Java code to be in-
serted into grammar rules to analyze the complex context of
the source code. However, this kind of Java code behaves as
comments to the ANTLR language parser, and is ill-suited
for generating code snippets. A clean-up simpliﬁcation of
this Java code is required to facilitate the process of parsing
G2 into Python format.
Ignorance rules A rule such as xmlPrimaryExpression is
used to parse XML expressions, which are uninteresting to
us, since we focus on the grammar structures of the context
and not on particular API functions. Code generation cycles
will be wasted if these rules are left unmodiﬁed. Thus, these
rules’ sub-rules are replaced with short XML expression in-
stances.
Modiﬁcation rules A rule such as functionBody is rewrit-
ten with a one-time loop structure. All the functions gen-
erated will start from one-time for-loops. This allows most
breaks and continues inside those functions compiler-legal
statuses.
Expansion and replacement rules Consider the rule
tryStatement as an example. The main part of this rule
is embedded inside a block, whose expansion according to
our algorithm can simply be a random pick from its sub-
atoms (see Section 2.3.2). Initialization of tryStatement sub-
rule selection will not work. Therefore, depth-ﬁrst sub-rule
selection is disabled in this situation. The rule is rewriten
and the block inside the tryStatement is replaced with a
newly deﬁned rule tryStatementBlock. Initialization of sub-
rule selection on tryStatementBlock will work and give the
code generation phase a greater diversity.
1: tryStatement
: TRY blockStatement
( catchClause+ finallyClause
| catchClause+
| finallyClause
)
;
2: tryStatement
: TRY blockStatement tryStatementBlock
;
tryStatementBlock
: catchClause+ finallyClause
| catchClause+
| finallyClause
;
Marking of rules related to functions and variable
declarations This is done for the runtime class mutation
phase, to reduce the complexity of lexical analysis subse-
quently. For example, if we attempt to expand the vari-
ableDeclaration rule during the code generation phase, the
sophisticated variable expression will be very diﬃcult for the
mutation algorithm to control both the type and the value
of the variable. Therefore, its sub-rules are replaced with
markers such that we can directly alter the type and the
value of the variable.
2.3 Grammar-based blackbox fuzzing
According to vulnerability reports of AVMs in the past
2 years [20], many vulnerabilities were caused by AS code
containing interactions with runtime classes. Therefore, a
main aspect of ScriptGene is to create opportunities for in-
teractions between diﬀerent runtime classes.
2.3.1 Key points of the design
There are three key points that should be taken into con-
sideration while creating compiler-pass AS code to test a
backend AVM.
Stricter environment For a JavaScript-like VM, even
if the backend VM receives no executable code due to the
inappropriate grammar context of the input code, it is stil-
l possible to test the frontend parser and trigger bugs in
trusted environments. Unlike JavaScript code and its VM,
AS code interfaces with the AVM via a compiler. Bugs of
the parser (in the compiler) would not be a direct threat
to the trusted environment. Accordingly, AS requires much
stricter context than JavaScript, since any preceding line of
invalid AS code will block the execution of the remaining
code due to the compiler.
I.e., AS should be global-valid
while JavaScript needs to be only line-valid. Adding con-
trols to the code generation phase and marking rules inside
G2 (see Section 2.2) overcomes this diﬃculty.
Additional grammar structures in AVMs In order
to compile and execute code on the AVM, some addition-
al structures are needed in our AS code. Such structures