微软签名缺陷利用 - 老但有用的技术
0x00 前言
这项技术原理很简单，一般正规公司开发的PE文件都有数字签名，但是微软提供的签名技术，并没有签
名所有数据，还有部分结构体，没有纳入签名计算，因此我们可以修改这些结构体，放入我们的
shellcode，而不影响签名校验。
这项技术到底有多大用呢？我的结论是作用只能算锦上添花，不是雪中送碳的技术。这2天有个老哥把这
项技术写成了适合CS使用的.net和BOF程序。我们看看他的程序结构。
0x00 SigFile红队工具分析
 首先我们通过作者提供的SigFile程序把shellcode通过加密保存在正规的PE文件中，然后上传到目标服
务器。在这一步会面临AV/EDR的静态扫描，大部分杀软发现是正规签名（比如微软签名）就直接放过
了，因此这一步落地被杀的几率不高，但是因为这项技术至少可以追溯到2013年以前，也就是说10年老
技术了，因此被杀软针对性查杀的可能性还是较高的，这就是攻防对抗，随着时间推移，没有一招鲜吃
遍天的可能。这一步我们按照1-10分的查杀可能，我打7分。
接下来就是使用SigLoad读取被嵌入正常PE的shellcode，这一步中sigLoad是用.net和bof开发的可以在
内存中使用不落地。因为正常的PE内存中展开是没有包含我们写shellcode的哪些字段。因此我们读取方
法和读取一个文本类似，就是打开文件，找到物理偏移，然后读取，再解密加载执行。唯一的优势是，
我们的这个“文本”是被正规签名的PE，这样可以更OPSEC一点。
读取完shellcode，就是执行shellcode了，这一步就和本文提到的技术没有任何关系了。sigLoad使用的
是常规的远程进程注入OpenProcess+VirtualAllocEx+WriteProcessMemory+CreateRemoteThread。
这样的一连串的API调用，被杀的几率很大。
因此我们从功能上拆解下sigFile这个工具，shellcode插入高信誉签名PE、SigLoad加载合成的PE并执行
shellcode，这就是这个工具的2大功能，涉及到本文提到的签名漏洞问题的核心就前2个功能，因此根据
我个人判断这项技术杀软对抗的作用其实没想想的那么大。
0x00 使用测试
 我们先利用SigFile制作一个包含shellcode的正规签名PE：
Produced by AttackTeamFamily - Author: L.N. - Date: 2021-08-10 
No. 1 / 5 - Welcome to www.red-team.cn
成功不改变数字签名的情况下加入了shellcode，注意签名没变，但是文件hash变了。我们使用cs试试
看能不能正常使用。
我们先看系统有没有打补丁，这个补丁13年就出了https://docs.microsoft.com/en-us/security-update
s/SecurityAdvisories/2014/2915720?redirectedfrom=MSDN，很关键的一点就是，不默认开启。
通过查看，非管理员权限也是可以的。
reg query x86 HKLM\Software\Microsoft\Cryptography\Wintrust\Config
reg query x64 HKLM\Software\Wow6432Node\Microsoft\Cryptography\Wintrust\Config
如果上面注册表路径存在，则检测EnableCertPaddingCheck值是否为1，1为开启。
Produced by AttackTeamFamily - Author: L.N. - Date: 2021-08-10 
No. 2 / 5 - Welcome to www.red-team.cn
默认没有相关配置。我们使用CS试试作者的SigLoader加载shellcode试试。一来就给我报了个这个错：
然后我把里面冗余的代码删了删，例如：代码中当前线程执行shellcode的代码删除了，因为没有用，作
者使用的是Loader.cs中的远程进程注入。然后把原来使用的.net4.6.1调低到4.5，再编译，就可以了。
Produced by AttackTeamFamily - Author: L.N. - Date: 2021-08-10 
No. 3 / 5 - Welcome to www.red-team.cn
显示成功了，但是一注入就进程崩溃，建议大家谨慎使用，于是我把它注入的那段代码改了，但是尼玛
还是失败，最后我对比解密的shellcode发现少了一截。垃圾代码。于是我读了下加解密代码。发现作者
偏移搞错了。于是没把加密的shellcode读完，解密出来的也就不全了。于是改了改代码。ok，再测试。
最后成功了。
0x00 总结
由于浪费我1个多小时去找代码bug，我只能评价垃圾！垃圾！垃圾！看朋友圈有其他同学测试成功，我
不知道他们怎么成功的，可能用的bof的代码，我这儿bof就不测试了。回归正题，微软签名缺陷这个漏
洞APT10很早就用过了，不是新东西，但是微软虽然有修复方案，但是不是默认配置，因此可用度应该
很高。这个技术具体杀软对抗能力有多强，我持保留意见，因为杀软对抗已经过了单点对抗的年代，而
这个技术也只是对抗中一个点而已，后面的进程操作不免杀，也是等于零。
            Stream stream = new MemoryStream(_peBlob);
            long pos = stream.Seek(_dataOffset + _tag.Length, SeekOrigin.Begin);
            Console.WriteLine("[+]: Shellcode located at {0:x2}", pos);
            //垃圾原始代码
            //byte[] shellcode = new byte[_peBlob.Length - (pos + _tag.Length)];
            //stream.Read(shellcode, 0, (_peBlob.Length)- ((int)pos + 
_tag.Length));
            byte[] shellcode = new byte[_peBlob.Length - (int)pos ];
            stream.Read(shellcode, 0, (_peBlob.Length)- (int)pos);
            byte[] b_shellcode = Utils.Decrypt(shellcode, _encKey);
            stream.Close();
Produced by AttackTeamFamily - Author: L.N. - Date: 2021-08-10 
No. 4 / 5 - Welcome to www.red-team.cn
Produced by AttackTeamFamily - Author: L.N. - Date: 2021-08-10 
No. 5 / 5 - Welcome to www.red-team.cn