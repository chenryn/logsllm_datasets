### 顶点处理图形渲染的第一步是顶点处理。构成多边形建模的每一个多边形呢，都有多个顶点（Vertex）。这些顶点都有一个在三维空间里的坐标。但是我们的屏幕是二维的，所以在确定当前视角的时候，我们需要把这些顶点在三维空间里面的位置，转化到屏幕这个二维空间里面。这个转换的操作，就被叫作顶点处理。如果你稍微学过一点图形学的话，应该知道，这样的转化都是通过线性代数的计算来进行的。可以想见，我们的建模越精细，需要转换的顶点数量就越多，计算量就越大。**而且，这里面每一个顶点位置的转换，互相之间没有依赖，是可以并行独立计算的。**![](Images/273f591bd7c7c044c6e8d67f11050392.png){savepage-src="https://static001.geekbang.org/resource/image/04/de/04c3da62c382e45b8f891cfa046169de.jpeg"}```{=html}```顶点处理就是在进行线性变换]{.reference}```{=html}```
### 图元处理在顶点处理完成之后呢，我们需要开始进行第二步，也就是图元处理。图元处理，其实就是要把顶点处理完成之后的各个顶点连起来，变成多边形。其实转化后的顶点，仍然是在一个三维空间里，只是第三维的Z轴，是正对屏幕的"深度"。所以我们针对这些多边形，需要做一个操作，叫剔除和裁剪（CullandClip），也就是把不在屏幕里面，或者一部分不在屏幕里面的内容给去掉，减少接下来流程的工作量。![](Images/c8d14346ab4307ed927d479acfdb4b69.png){savepage-src="https://static001.geekbang.org/resource/image/4a/1d/4a20559c43f93177d7a99081a0cd0e1d.jpeg"}
### 栅格化在图元处理完成之后呢，渲染还远远没有完成。我们的屏幕分辨率是有限的。它一般是通过一个个"像素（Pixel）"来显示出内容的。所以，对于做完图元处理的多边形，我们要开始进行第三步操作。这个操作就是把它们转换成屏幕里面的一个个像素点。这个操作呢，就叫作栅格化。**这个栅格化操作，有一个特点和上面的顶点处理是一样的，就是每一个图元都可以并行独立地栅格化。**![](Images/d2e083a94e4f9a64f8f97d4c891a89b7.png){savepage-src="https://static001.geekbang.org/resource/image/e6/a6/e60a58e632fc05dbf96eaa5cbb7fb2a6.jpeg"}
### 片段处理在栅格化变成了像素点之后，我们的图还是"黑白"的。我们还需要计算每一个像素的颜色、透明度等信息，给像素点上色。这步操作，就是片段处理。**这步操作，同样也可以每个片段并行、独立进行，和上面的顶点处理和栅格化一样。**![](Images/5e4b19fc11b8e79e88479ab1bb915343.png){savepage-src="https://static001.geekbang.org/resource/image/49/08/490f298719e81beb1871c10566d56308.jpeg"}
### 像素操作最后一步呢，我们就要把不同的多边形的像素点"混合（Blending）"到一起。可能前面的多边形可能是半透明的，那么前后的颜色就要混合在一起变成一个新的颜色；或者前面的多边形遮挡住了后面的多边形，那么我们只要显示前面多边形的颜色就好了。最终，输出到显示设备。![](Images/c4e19bd4ebd158b9adbe4b62e5f465e0.png){savepage-src="https://static001.geekbang.org/resource/image/31/1f/312b8e4730ac04d36c99ee7c56bbba1f.jpg"}经过这完整的 5个步骤之后，我们就完成了从三维空间里的数据的渲染，变成屏幕上你可以看到的3D 动画了。这样 5个步骤的渲染流程呢，一般也被称之为**图形流水线**（GraphicPipeline）。这个名字和我们讲解 CPU里面的流水线非常相似，都叫**Pipeline**。![](Images/ef59de56512478c1c64564883b83bcf3.png){savepage-src="https://static001.geekbang.org/resource/image/bf/8f/bf6554dffdf501182ac45bc59d30648f.jpeg"}
## 解放图形渲染的 GPU我们可以想一想，如果用 CPU来进行这个渲染过程，需要花上多少资源呢？我们可以通过一些数据来做个粗略的估算。在上世纪 90 年代的时候，屏幕的分辨率还没有现在那么高。一般的 CRT显示器也就是 640×480 的分辨率。这意味着屏幕上有 30万个像素需要渲染。为了让我们的眼睛看到画面不晕眩，我们希望画面能有 60帧。于是，每秒我们就要重新渲染 60 次这个画面。也就是说，每秒我们需要完成1800 万次单个像素的渲染。从栅格化开始，每个像素有 3个流水线步骤，即使每次步骤只有 1 个指令，那我们也需要 5400万条指令，也就是 54M 条指令。90 年代的 CPU 的性能是多少呢？93 年出货的第一代 Pentium 处理器，主频是60MHz，后续逐步推出了 66MHz、75MHz、100MHz 的处理器。以这个性能来看，用CPU 来渲染 3D 图形，基本上就要把 CPU的性能用完了。因为实际的每一个渲染步骤可能不止一个指令，我们的 CPU可能根本就跑不动这样的三维图形渲染。也就是在这个时候，Voodoo FX这样的图形加速卡登上了历史舞台。既然图形渲染的流程是固定的，那我们直接用硬件来处理这部分过程，不用CPU 来计算是不是就好了？很显然，这样的硬件会比制造有同样计算性能的 CPU要便宜得多。因为整个计算流程是完全固定的，不需要流水线停顿、乱序执行等等的各类导致CPU计算变得复杂的问题。我们也不需要有什么可编程能力，只要让硬件按照写好的逻辑进行运算就好了。那个时候，整个顶点处理的过程还是都由 CPU进行的，不过后续所有到图元和像素级别的处理都是通过 Voodoo FX 或者 TNT这样的显卡去处理的。也就是从这个时代开始，我们能玩上"真 3D"的游戏了。![](Images/af7cc7961cfc50102d55761708190bcc.png){savepage-src="https://static001.geekbang.org/resource/image/85/db/852288ae6b69b7e649c81f90c9fd7cdb.jpeg"}不过，无论是 Voodoo FX 还是 NVidiaTNT。整个显卡的架构还不同于我们现代的显卡，也没有现代显卡去进行各种加速深度学习的能力。这个能力，要到NVidia 提出 Unified Shader Archicture才开始具备。这也是我们下一讲要讲的内容。
## 总结延伸这一讲里，我带你了解了一个基于多边形建模的三维图形的渲染过程。这个渲染过程需要经过顶点处理、图元处理、栅格化、片段处理以及像素操作这5 个步骤。这 5个步骤把存储在内存里面的多边形数据变成了渲染在屏幕上的画面。因为里面的很多步骤，都需要渲染整个画面里面的每一个像素，所以其实计算量是很大的。我们的CPU 这个时候，就有点跑不动了。于是，像 3dfx 和 NVidia 这样的厂商就推出了 3D加速卡，用硬件来完成图元处理开始的渲染流程。这些加速卡和现代的显卡还不太一样，它们是用固定的处理流程来完成整个3D 图形渲染的过程。不过，因为不用像 CPU那样考虑计算和处理能力的通用性。我们就可以用比起 CPU芯片更低的成本，更好地完成 3D 图形的渲染工作。而 3D游戏的时代也是从这个时候开始的。