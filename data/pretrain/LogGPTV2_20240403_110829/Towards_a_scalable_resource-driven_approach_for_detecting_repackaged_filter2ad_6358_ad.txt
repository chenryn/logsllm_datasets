The ﬁrst one is “Android Debug” used for signing debugging
version of apps. The second one is the company’s domain
(i.e., lvping.com). We are not sure whether the ones signed
by the debugging certiﬁcate are repackaged apps created by
attackers or it is just because the developer forgot to export
release version and sign them using oﬃcial certiﬁcates.
5.7.3 Misusing Certiﬁcates
We found a pair of repackaged apps that have the same
package name (i.e., a5game.leidian2) but diﬀerent certiﬁ-
cate ﬁngerprints. One was signed by ’EE1C7585428F65BAC
2D156B0792D2358’, and the other app was signed by ’86544D
775DCBA00275CD304C5C37BCC7’. We investigated the t-
wo certiﬁcates and found the former is owned by “5agame.
com”, but the latter’s owner is in Chinese characters, which
is the name of the website http://www.5agame.com. After
careful examination of their codes, we did not ﬁnd anything
abnormal. It is likely that both the two apps were actual-
ly published by the same developer “5agame.com”, but they
chose diﬀerent certiﬁcates for the same app for some un-
known reasons. This may result in failures of updates, be-
cause the Android system does not allow the newer app and
the older one have diﬀerent certiﬁcates. Therefore, it is an
example of misusing app certiﬁcates.
6. DISCUSSION
6.1 Attack Analysis
Zhang et al. described the behaviors of three kinds of
repackaging attacks [45], including (1) lazy attacks that use
automatic code obfuscation tools to repackage apps without
modifying the functionality of original apps; (2) malware
that embeds malicious payload into original apps without
changing them; (3) amateur attacks that may make some
changes to original apps besides employing the automatic
code obfuscation tools. Since none of them will modify the
resources and the related codes, ResDroid can detect them.
Advanced attackers who know ResDroid may change fea-
tures to evade detection. For example, they can insert many
junk resources into the repackaged app for aﬀecting the sta-
tistical features. However, we consider the relations between
resources and codes (e.g., references from XML ﬁles, loading
from code) and identify core resources, from which statisti-
cal features are extracted. Therefore, junk resources that are
not carefully crafted will be ﬁltered out. Dedicated attacker-
s may change statistical features by inserting resources and
altering the dex ﬁle simultaneously at a cost of increased ap-
p size and degraded performance. We may apply dead-code
detection techniques [12] to identify such junk functions and
remove them along with the corresponding resources when
computing the features.
As explained in Section 3.5, it is diﬃcult for attackers to
re-implement a new layout while keeping the same looks and
feels. Moreover, to retain the normal functionality and QoE
of the repackaged app, attackers will not remove event han-
dlers. Although attackers can add new event handlers, they
cannot modiﬁed the result of normalized LCS as explained in
Section 3.5.3. Therefore, the structural features are robust
and can raise the bar for attackers to evade detection.
6.2 Limitations and Future Work
We notice that apps created by automatic building tools
will cause false positives, because these tools provide devel-
opers a set of templates to create apps. Apps using the
same template will shared similar appearance and the event
handlers, therefore, their statistical features and structural
feature are alike. ResDroid cannot diﬀerentiate them.
In
future work, we will use components’ attributes to diﬀeren-
tiate them. Another possible approach is to use code-level
detection systems such as DNADroid [19] to handle them.
If code obfuscation/app hardening systems employ vari-
ous dynamic loading techniques and encryption methods to
prevent static analysis, ResDroid may not be able to handle
such apps through static analysis. However, since these tech-
niques will eventually load codes and resources into memo-
ry, we will design a kernel-based dynamic approach like [42],
which keeps monitoring the behavior of a hardened app and
dumps selected codes and resources after they are loaded.
Moreover, we will examine how to ﬁngerprint apps protect-
ed by diﬀerent code obfuscation/app hardening systems.
7. RELATED WORK
Code clone detection. Considerable research has been
conducted on code clone detection [11, 39, 41]. Existing
approaches can be roughly classiﬁed into four groups [41]:
(1) textual analysis that extracts ﬁngerprints from code di-
rectly; (2) lexical analysis that converts codes into lexical
tokens and then detects duplicated token sequences (e.g.,
CP-Miner [32], etc.); (3) syntactic analysis that ﬁrst turn-
s codes into abstract syntax trees (AST) and then applies
tree matching or structural metrics to detect clones (e.g.,
Deckard [30], etc.); (4) semantic analysis that employs static
program analysis to extract more precise information about
the code, such as program dependency graph, for detection
(e.g., GPLAG [33], etc.). Some of these methods have been
used to detect repackaged apps by analyzing dex ﬁles, or the
converted Java class ﬁles, or the disassembled smali codes.
Repackaged apps detection. Assuming apps from the
oﬃcial market are original, DroidMOSS applies fuzzy hash-
ing to each app’s opcodes and then compares it to original
apps’ ﬁngerprint for detecting repackaged apps [47]. Similar-
ly, Androguard [1] uses several standard similarity metrics
to hash methods and basic blocks for comparison. Juxtapp
characterizes apps through k-grams of opcodes and feature
hashing and then clusters the corresponding bitvectors to
identify app clones [27]. PiggyApp was designed to detect
piggybacked apps, a special kind of repackaged apps, which
contain injected code [46].
It ﬁrst decouples modules ac-
cording to their dependency relationship and then construc-
t ﬁngerprint for the primary module by collecting various
features, such as requested permissions, Android API call-
s used, etc. [46]. These methods are vulnerable to simple
obfuscation techniques because they consider few semantic
information about codes [29, 43, 44].
Dresnos used normalized compression distance (NCD) [15]
to compare the similarity of apps according to their method
signatures,
including external API used, exceptions, and
control ﬂow graph (CFG) [22]. Potharaju et al. proposed
an approach to detect plagiarized apps according to symbol
tables and method-level AST ﬁngerprints. This approach
can handle two kinds of obfuscation techniques that mangles
symbol table or inserts random methods with no function-
ality [37]. DroidSim utilizes component-based control ﬂow
graph (CB-CFG) to quantify the similarity between app-
s [43]. DNADroid constructs a program dependency graph
(PDG) for each method and then performs subgraph isomor-
phism comparison on PDGs after ﬁltering out unnecessary
methods [19]. To speed up DNADroid, AnDarwin splits
PDGs into connected components (i.e., semantic blocks),
each of which will be represented by a semantic vector con-
taining the number of speciﬁc types. After that, it employs
locality sensitive hashing (LSH) to identify code clones that
have similar semantic vectors [20]. Chen et al. proposed a
novel approach that uses the centroid of control dependency
graph to measure the similarity between methods for detect-
ing cross-market app clones [13]. Although these methods
are better than the previous ones, they could still be easi-
ly evaded by obfuscation techniques (e.g., inserting dummy
codes or adding data related variables) [43, 45].
Recently, Hao et al. showed that it is possible to detect
app clones using UI state transition graphs [28]. In a simul-
taneous research, Zhang et al. proposed ViewDroid that ﬁrst
constructs feature view graph and then applies subgraph iso-
morphism algorithm to measure the similarity between two
apps [45]. Although both ViewDroid and ResDroid exploit
UI for detecting repackaged apps, there are three major dif-
ference between them. First, ViewDroid only uses the rela-
tionship among activities while ResDroid employs both the
layout of activities and the relationship among activities.
Moreover, we take into account Android’s fragment compo-
nent that provides similar functionality as an activity. How-
ever, ViewDroid does not handle such component. Second,
by only examining core resources, ResDroid would be more
eﬃcient and more robust to third-party libraries than View-
Droid that considers all views. Third, whereas ViewDroid
targets on comparison between a pair of apps, ResDroid is
built on top of a two-stage methodology and equipped with
two kinds of algorithms.
8. CONCLUSION
t of mobile security strategies. http://betanews.com/2013/12/03/
app-hardening-emerges-as-a-key-component-of-mobile-security-strategies/,
2014.
We propose a novel approach that leverages new features
extracted from core resources and codes to detect repack-
aged apps. These features do not require processing all op-
codes and are resilient to code obfuscation/app hardening
techniques. To speed up the detection, we adopt the divide-
and-conquer strategy to reduce the comparison and support
parallel processing. Our solution have been realized in Res-
Droid and the extensive evaluation using real repackaged
apps has demonstrated its eﬀectiveness and eﬃciency.
9. ACKNOWLEDGMENT
We thank reviewers for their comments, and thank Wen-
jun Hu and Kai Chen for providing us samples. This work
is supported in part by the Hong Kong GRF (No. PolyU
5389/13E), the National Natural Science Foundation of Chi-
na (No. 61202396), the PolyU Research Grant(G-UA3X),
and the Open Fund of Key Lab of Digital Signal and Image
Processing of Guangdong Province(2013GDDSIPL-04).
10. REFERENCES
[1] Androguard. https://code.google.com/p/androguard/, 2011.
[2] 1.2% of apps on google play are repackaged to deliver ads,
collect info.
http://www.net-security.org/secworld.php?id=15976, 11 2013.
[3] App hardening emerges as a key componen-
[4] Gator: Program analysis toolkit for android.
http://dacongy.github.io/gator/, 2014.
[5] Managing the activity lifecycle. http://developer.android.com/
training/basics/activity-lifecycle/index.html, 2014.
[6] Resources overview. http://developer.android.com/guide/
topics/resources/overview.html, 2014.
[7] C. Aggarwal and C. Reddy. Data Clustering: Algorithms and
Applications. Chapman and Hall/CRC, 2013.
[8] A. Andoni and P. Indyk. Near-optimal hashing algorithms for
approximate nearest neighbor in high dimensions. Commun.
ACM, 51(1), 2008.
[9] Arxan Technologies Inc. State of security in the app economy.
http://www.arxan.com/resources/state-of-security-in-the-app-
economy/.
[10] T. Azim and I. Neamtiu. Targeted and depth-ﬁrst exploration
for systematic testing of android apps. In Proc. ACM
SIGPLAN, 2013.
[11] S. Bellon, R. Koschke, G. Antoniol, J. Krinke, and E. Merlo.
Comparison and evaluation of clone detection tools. IEEE
Trans. Software Eng., 33(9), 2007.
[12] D. Beyer, A. Noack, and C. Lewerentz. Eﬃcient relational
calculation for software analysis. IEEE Trans. Software Eng.,
31(2), 2005.
[13] K. Chen, P. Liu, and Y. Zhang. Achieving accuracy and
scalability simultaneously in detecting application clones on
android markets. In Proc. ACM ICSE, 2014.
[14] W.-Y. Chen, Y. Song, H. Bai, C.-J. Lin, and E. Y. Chang.
Parallel spectral clustering in distributed systems. IEEE
Trans. Pattern Anal. Mach. Intell., 33(3), 2011.
[15] R. Cilibrasi and P. Vitanyi. Clustering by compression. IEEE
Transactions on Information Theory, 51(4), 2005.
[16] Cisco Systems Inc. Annual security report, 2014.
[17] C. Collberg and J. Nagra. Surreptitious Software:
Obfuscation, Watermarking, and Tamperprooﬁng for
Software Protection. Addison-Wesley, 2009.
[18] S. Corporation. Internet security threat report, 2014.
[19] J. Crussell, C. Gibler, and H. Chen. Attack of the clones:
Detecting cloned applications on android markets. In Proc.
ESORICS, 2012.
[20] J. Crussell, C. Gibler, and H. Chen. Scalable semantics-based
detection of similar android applications. In Proc. ESORICS,
2013.
[21] J. Davies, D. M. German, M. W. Godfrey, and A. Hindle.
Software bertillonage. Empirical Software Engineering, 18(6),
2013.
[22] A. Dresnos. Android: Static analysis using similarity distance.
In Proc. HICSS, 2012.
[23] W. Enck, P. Gilbert, B. gon Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. Sheth. Taintdroid: An information-ﬂow
tracking system for realtime privacy monitoring on
smartphones. In Proc. OSDI, 2010.
[24] C. Gibler, R. Stevens, J. Crussell, H. Chen, H. Zang, and
H. Choi. Adrob: examining the landscape and impact of
android application plagiarism. In Proc. ACM MobiSys, 2013.
[25] M. Grace, Y. Zhou, Q. Zhang, S. Zou, and X. Jiang.
Riskranker: scalable and accurate zero-day android malware
detection. In Proc. ACM MobiSys, 2012.
[26] M. Halkidi, Y. Batistakis, and M. Vazirgiannis. On clustering
validation techniques. Journal of Intelligent Information
Systems, 17(2-3), 2001.
[27] S. Hanna, L. Huang, E. Wu, S. Li, C. Chen, and D. Song.
Juxtapp: a scalable system for detecting code reuse among
android applications. In Proc. DIMVA, 2012.
[28] S. Hao, B. Liu, S. Nath, W. Halfond, and R. Govindan.
PUMA: Programmable ui-automation for large scale dynamic
analysis of mobile apps. In Proc. ACM MobiSys, 2014.
[29] H. Huang, S. Zhu, P. Liu, and D. Wu. A framework for
evaluating mobile app repackaging detection algorithms. In
Proc. TRUST, 2013.
[30] L. Jiang, G. Misherghi, Z. Su, and S. Glondu. Deckard:
Scalable and accurate tree-based detection of code clones. In
Proc. IEEE ICSE, 2007.
[31] J.-H. Jung, J. Y. Kim, H.-C. Lee, and J. H. Yi. Repackaging
attack on android banking applications and its
countermeasures. Wireless Personal Comm., 73(4), 2013.
[32] Z. Li, S. Lu, S. Myagmar, and Y. Zhou. Cp-miner: Finding
copy-paste and related bugs in large-scale software code. IEEE
Transactions on Software Engineering, 32(3), 2006.
[33] C. Liu, C. Chen, J. Han, and P. Yu. Gplag: Detection of
software plagiarism by program dependence graph analysis. In
Proc. ACM KDD, 2006.
[34] M. Newman. Networks: An Introduction. Oxford University
Press, 2010.
[35] A. Papadopoulos. Nearest Neighbor Search: A Database
Perspective. Springer, 2004.
[36] D. Pelleg, A. W. Moore, et al. X-means: Extending k-means
with eﬃcient estimation of the number of clusters. In Proc.
ICML, 2000.
[37] R. Potharaju, A. Newell, C. Nita-Rotaru, and X. Zhang.
Plagiarizing smartphone applications: Attack strategies and
defense techniques. In Proc. ESSoS, 2012.
[38] C. Qian, X. Luo, Y. Shao, and A. Chan. On tracking
information ﬂows through JNI in android apps. In Proc.
IEEE/IFIP DSN, 2014.
[39] D. Rattan, R. Bhatia, and M. Singh. Software clone detection:
A systematic review. Information and Software Technology,
55(7), 2013.
[40] A. Rountev and D. Yan. Static reference analysis for gui
objects in android software. In Proc. IEEE/ACM CGO, 2014.
[41] C. Roy, J. Cordy, and R. Koschke. Comparison and evaluation
of code clone detection techniques and tools: A qualitative
approach. Sci. Comput. Program., 74(7), 2009.
[42] Y. Shao, X. Luo, and C. Qian. Rootguard: Protecting rooted
android phones. IEEE Computer, June 2014.
[43] X. Sun, Y. Zhongyang, Z. Xin, B. Mao, and L. Xie. Detecting
code reuse in android applications using component-based
control ﬂow graph. In Proc. IFIP SEC, 2014.
[44] M. Vasquez, A. Holtzhauer, C. Bernal-Cardenas, and
D. Poshyvanyk. Revisiting android reuse studies in the context
of code obfuscation and library usages. In Proc. IEEE MSR,
2014.
[45] F. Zhang, H. Huang, S. Zhu, D. Wu, and P. Liu. Viewdroid:
Towards obfuscation-resilient mobile application repackaging
detection. In Proc. ACM WiSec, 2014.
[46] W. Zhou, Y. Zhou, M. Grace, X. Jiang, and S. Zou. Fast,
scalable detection of piggybacked mobile applications. In Proc.
ACM CODASPY, 2013.
[47] W. Zhou, Y. Zhou, X. Jiang, and P. Ning. Detecting
repackaged smartphone applications in third-party android
marketplaces. In Proc. ACM CODASPY, 2012.
[48] Y. Zhou and X. Jiang. Dissecting android malware:
Characterization and evolution. In Proc. IEEE Symp. Security
and Privacy, 2012.