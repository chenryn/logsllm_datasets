# ip link set A up
(8) 将B设备放到刚创建的独立的网络空间中去：
17
# ip link set B netns $pid
18
(9) 在虚拟网络空间中将设备B重命名为更通用的名称eth0：
138 第12章 容器网络
# ip netns exec $pid ip link set dev B name eth0
(10) 为eth0设置MAC地址：
# ip netns exec $pid ip link set eth0 address 12:34:56:78:9a:bc
(11) 启动eth0：
# ip netns exec $pid ip link set eth0 up
(12) 为eth0配置网络IP地址及子网掩码：
# ip netns exec $pid ip addr add 172.17.42.99/16 dev eth0
(13) 为主机设置路由地址：
# ip netns exec $pid ip route add default via 172.17.42.1
至此，容器的网络环境已经配置完毕。可以看到，它与Docker默认为我们配置的网络环境
一样。
出于安全性考虑，容器的进程是不允许更改它自己的网络配置的，所以ip netns exec所执
行的网络命令放到Docker容器中执行可能并不会生效。我们可以使用--privileged=true赋予容器
更改网络配置的权限，但这样会增加容器网络在内部被破坏的风险。相比而已，我们更加推荐使
用ip nets exec这种更加安全的方式去配置网络环境。
另外需要注意的是，Docker引擎并不会保存我们对容器所做的网络环境配置。当容器退出时，
我们创建的虚拟网络空间也会被销毁，包括放置在网络空间的eth0和主机端的设备A。
12.2 配置及原理
在这一节中，我们会讲到Docker网络的基本配置。结合上一节的网络原理，我们会深入配置
后的原理。
12.2.1 基本配置
Linux主机名保存在/etc/hostname文件中，域名解析服务器IP保存在/etc/resolv.conf文件中，host
配置保存在/etc/hosts文件中。Docker容器也是一样的，我们看一下使用默认参数启动一个容器的
这3个文件：
# docker run -t -i ubuntu
root@c85588436954:/# cat /etc/hostname
c85588436954
root@c85588436954:/# cat /etc/hosts
172.17.0.2 c85588436954
127.0.0.1 localhost
::1 localhost ip6-localhost ip6-loopback
12.2 配置及原理 139
fe00::0 ip6-localnet
1
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
2
root@c85588436954:/# cat /etc/resolv.conf
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
3
nameserver 8.8.8.8
4
nameserver 8.8.4.4
接下来，我们将介绍如何修改这些默认值以及这些修改背后的原理。
5
1. 主机名配置
默认情况下，会以容器ID的前12个字符作为主机名。当然，我们也可以使用-h HOSTNAME或 6
--hostname=HOSTNAME选项来修改主机名：
7
# docker run -h myhostname -t -i ubuntu
root@myhostname:/# cat /etc/hostname
myhostname 9
root@myhostname:/# cat /etc/hosts
172.17.0.2 myhostname
127.0.0.1 localhost 8
...(略)
-h选项将直接修改/etc/hostname文件，同时也会修改/etc/hosts主机的IP对应的主机名。容器的
10
主机名会显示在容器内/bin/bash终端的计算机名区域（终端@符号后的区域），而它对主机和其他
容器是不可见的。在主机上使用docker ps命令，也无法看到容器的主机名。
10
2. DNS配置
12
使用参数--dns=IP_ADDRRESS可以为新启动的容器配置一个或者多个域名服务器，这个参数会
修改/etc/resolv.conf文件。容器中的进程需要通过主机名或域名来访问时，如果该域名在/etc/hosts
13
文件中不能被解析，就会从文件/etc/resolv.conf中读取DNS服务器的IP地址，然后在端口53上向
DNS服务器请求解析域名到IP地址。
14
--dns-search=DOMAIN用来配置DNS查询的后置域。举个例子，如果你设置DNS搜索域为
baidu.com，那么当你访问主机名为music的主机时，容器将不仅仅去DNS服务器查询music的IP地
15
址，还会同时查询music.baidu.com域名的IP地址。如果不想使用这个设置，将DOMAIN置为空即
可。这个配置同样会修改/etc/resolv.conf文件。
16
Docker从版本1.2.0开始，支持在容器中直接修改/etc/hostname、/etc/hosts和/etc/resolve.conf
这3个文件。不过对文件的修改也仅在本次容器运行期间有效，容器退出后修改也随之丢失。通
17
过docker commit命令将容器运行环境保存成镜像时，这3个文件的修改也会丢失而不会写入到容
器镜像中去。
18
140 第12章 容器网络
Docker容器的主机名和DNS等网络配置并不是在镜像中修改的，而是在启动的那一刻通过覆
写下面这3个文件来达到：
/etc/hostname
/etc/hosts
/etc/resolv.conf
在容器中使用mount命令可以发现，hostname、hosts和resolv.conf这3个文件其实是挂载在主机
上的文件，每一个容器对应着一份副本，通过uuid进行隔离：
root@myhostname:/# mount
...(略)
/dev/disk/by-uuid/ff907709-9cd2-4189-ae46-67e2df64753e on /etc/resolv.conf type ext4
(rw,relatime,errors=remount-ro,data=ordered)
/dev/disk/by-uuid/ff907709-9cd2-4189-ae46-67e2df64753e on /etc/hostname type ext4
(rw,relatime,errors=remount-ro,data=ordered)
/dev/disk/by-uuid/ff907709-9cd2-4189-ae46-67e2df64753e on /etc/hosts type ext4
(rw,relatime,errors=remount-ro,data=ordered)
...(略)
我们不应该直接修改这些文件来达到目标，Docker会为我们自动配置好这些文件，以满足当
前网络的需求。如果需要修改，需要在首次运行容器时通过命令进行配置。
12.2.2 容器互联配置及原理
上一章中，我们已经讲过容器间的互联。容器与容器之间能否进行通信，主要由下面两个因
素所决定。
 需要通信的容器的网络接口是否处于同一网络拓扑结构中。默认情况下，Docker会将容
器接入到名为docker0的网桥上。网桥会处理容器之间的数据包交换。
 iptables配置是否允许两个容器之间创建连接。
当我们启动容器时，Docker引擎会在主机iptables中创建一条转发链。如果我们配置了
--icc=true，这条转发链就使用ACCEPT策略进行配置。如果--icc设置成了false，就使用DROP
策略进行配置。将--icc参数设置成true还是false取决于我们是否要依赖iptables来保护容器免受
端口刺探或被其他无关容器访问的危险。
分别在--icc设成true和false的情况下，使用下面的命令创建一个容器：
# docker run -t -i -p 80 ubuntu
 --icc=false时，过滤表的规则如下：
# iptables -L -n
...(略)
Chain FORWARD (policy ACCEPT)
target prot opt source destination
ACCEPT tcp -- 0.0.0.0/0 172.17.0.2 tcp dpt:80
12.2 配置及原理 141
DROP all -- 0.0.0.0/0 0.0.0.0/0
1
ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 ctstate RELATED,ESTABLISHED
ACCEPT all -- 0.0.0.0/0 0.0.0.0/0
...( 略)
2
上面的规则表明，目标地址为容器的IP地址172.17.0.2，tcp端口号为80的数据都将被丢弃。
 --icc=true时，过滤表的规则如下: 3
# iptables -L -n
...(略) 4
Chain FORWARD (policy ACCEPT)
target prot opt source destination
ACCEPT tcp -- 0.0.0.0/0 172.17.0.2 tcp dpt:80 5
ACCEPT all -- 0.0.0.0/0 0.0.0.0/0
ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 ctstate RELATED,ESTABLISHED
ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 6
...( 略)
上面的规则表明，目标地址为容器的IP地址172.17.0.2，tcp端口号为80的数据都将被转发。 7
--icc参数通过全局配置文件/etc/default/docker中的DOCKER_OPTS选项进行配置，如：
9
DOCKER_OPTS="--icc=false"
或者 8
DOCKER_OPTS="--icc=true"
10
通过设置全局配置中DOCKER_OPTS选项中的--iptables为false，启动容器将不会修改主机的
iptables。一般情况下，我们不需要这么做，否则容器网络将不能正常工作。
10
为了保证最大的网络安全，一般选择将--icc设置成false，那么这种情况下我们如何能让容
器之间进行通信呢？这就要依赖第4章所讲的--link参数。在将--icc置为false，iptables置为true，
12
而又指定了--link参数的情况下，Docker会在iptables里插入一条ACCEPT规则，以允许容器能访
问另外一个容器所打开的端口，这个端口可由镜像在Dockerfile文件通过EXPOSE命令指定，也可以
13
是使用-p参数打开的端口。下面我们将演示这种情况。
(1) 配置--icc=false并重启docker服务： 14
# echo 'DOCKER_OPTS="--icc=false"' > /etc/default/docker
# service docker restart 15
(2) 在一个终端启动一个开放80端口的容器：
16
# docker run -t -i -p 80 --name=gloomy_fermi ubuntu
(3) 在另一个终端启动另一容器：
17
sudo docker run -t -i --link=gloomy_fermi:sv Ubuntu
18
其中gloomy_fermi是第一个容器的名称。
142 第12章 容器网络
(4) 在第3个终端查看iptables规则：
# iptables -L -n
...(略)
Chain FORWARD (policy ACCEPT)
target prot opt source destination
ACCEPT tcp -- 172.17.0.3 172.17.0.4 tcp spt:80
ACCEPT tcp -- 172.17.0.4 172.17.0.3 tcp dpt:80
DROP all -- 0.0.0.0/0 0.0.0.0/0
...(略)
上面的规则表明，允许172.17.0.4容器1与172.17.0.3容器2在容器2的tcp端口80上进行通信。
--link=gloomy_fermi:sv选项会在/etc/hosts文件中添加一项名为sv的域名解析。这个sv对应的
IP即gloomy_fermi容器对应的IP地址。这样容器内的进程在不知道gloomy_fermi容器的IP地址的情
况下，也可以使用sv别名与之通信。当容器重启的时候，可能会获得与上一次不一样的IP地址，
Docker会自动修改接收者容器/etc/hosts文件中的sv项目，以保证通信正常。查看上例接收者容器
中/etc/hosts的内容：
# cat /etc/hosts
172.17.0.4 7c1944a258c3
127.0.0.1 localhost
::1 localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.17.0.3 sv
其中172.17.0.3 sv项是通过--link=gloomy_fermi:sv选项添加进来的。
12.2.3 容器内访配置及原理
默认情况下，容器能与外部创建连接，但外部网络不能主动连接容器。如果希望容器能够接
收来自外部的连接，可以在使用docker run命令运行容器时指定一个特殊参数，即-p或-P。-p和
-P都是用来向外部开放内访的端口的。
 使用-P或者--publish-all=true|false。有了这个参数，创建容器镜像的Dockerfile文件中
EXPOSE命令所指定的端口都将变成可访问的。这个命令会将EXPOSE的端口列表随机映射到
主机49153~65535的端口范围。如果想知道具体是哪个端口，还需要额外的命令操作。
 使用-p SPEC或--publish=SPEC（这个方法更方便）。这个参数不仅允许我们添加可内访的
端口，还可以指定该端口的类型（TCP、UDP）及其在主机上映射的具体端口。
无论使用哪种方法，最终都需要通过修改主机上iptables的nat表来完成。
假如使用docker run -t -i -p 80 ubuntu启动一个容器，则nat表的形式如下：
12.2 配置及原理 143
# iptables -t nat -L -n
1
...(略)
Chain DOCKER (2 references)
target prot opt source destination
2
DNAT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:49155 to:172.17.0.5:80
...(略)
3
上面的动态地址转换（DNAT）规则将匹配任何流经本机且目的端口为49155的tcp&ip包，并
将该包的目标地址及端口转换成容器网络的IP地址172.17.0.5及容器开放的端口80。经过这样的转
4
换，外部网络的包就能顺利抵达容器内部的网络。
下面我们使用docker run -t -i -p 127.0.0.1:80:8080/udp ubuntu命令来启动一个容器，这
5
是一个稍微复杂一点的端口映射例子，指明的是将容器的udp端口80映射到主机的localhost
（127.0.0.1）网络接口上的udp端口8080上。这种情况下，nat表的形式如下：
6
# iptables -t nat -L -n
...(略)
7
Chain DOCKER (2 references)
target prot opt source destination
DNAT udp -- 0.0.0.0/0 127.0.0.1 udp dpt:80 to:172.17.0.6:8080
...(略) 9
我们可以看到DNAT规则的协议类型（prot）匹配变成了udp，目标地址（destination）匹
8
配变成了127.0.0.1，转换的目标端口变成了我们指定的8080端口。
另外，我们可以修改Docker全局配置文件/etc/default/docker的DOCKER_OPTS选项，通过配置参
10
数--ip=IP_ADDRESS，达到指定一个或多个目标IP地址的作用。记住，修改全局配置时，需要重启
Docker服务方可生效。
10
12.2.4 容器外访配置及原理
12
是否允许容器访问外部网络，主要受主机的ip_forward系统参数影响。默认情况下，
13
ip_forward设置成1，如果它被设置成0，则可以通过以下方法打开它：
# cat /proc/sys/net/ipv4/ip_forward
14
0