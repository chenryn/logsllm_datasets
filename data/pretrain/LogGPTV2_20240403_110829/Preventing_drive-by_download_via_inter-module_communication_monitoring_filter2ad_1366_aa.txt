title:Preventing drive-by download via inter-module communication monitoring
author:Chengyu Song and
Jianwei Zhuge and
Xinhui Han and
Zhiyuan Ye
Preventing Drive-by Download via Inter-Module
Communication Monitoring
∗
Chengyu Song Jianwei Zhuge
Xinhui Han Zhiyuan Ye
Key Laboratory of Network and Software Security Assurance (Peking University)
Institute of Computer Science and Technology, Peking University, China
{songchengyu,zhugejianwei,hanxinhui,yezhiyuan}@icst.pku.edu.cn
Ministry of Education, China
ABSTRACT
Drive-by download attack is one of the most severe threats to
Internet users. Typically, only visiting a malicious page will
result in compromise of the client and infection of malware.
By the end of 2008, drive-by download had already become
the number one infection vector of malware [5]. The down-
loaded malware may steal the users’ personal identiﬁcation
and password. They may also join botnet to send spams,
host phishing site or launch distributed denial of service at-
tacks.
Generally, these attacks rely on successful exploits of the
vulnerabilities in web browsers or their plug-ins. There-
fore, we proposed an inter-module communication monitor-
ing based technique to detect malicious exploitation of vul-
nerable components thus preventing the vulnerability being
exploited. We have implemented a prototype system that
was integrated into the most popular web browser Microsoft
Internet Explorer. Experimental results demonstrate that,
on our test set, by using vulnerability-based signature, our
system could accurately detect all attacks targeting at vul-
nerabilities in our deﬁnitions and produced no false positive.
The evaluation also shows the performance penalty is kept
low.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—In-
vasive software
General Terms
Security
Keywords
Drive-by download, malicious script, inter-module commu-
nication, intrusion detection, ActiveX
∗Corresponding author.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS’10 April 13–16, 2010, Beijing, China.
Copyright 2010 ACM 978-1-60558-936-7/10/04 ...$10.00.
1.
INTRODUCTION
A drive-by download (also mentioned as web-based mal-
ware in [32]) is a download which user indirectly authorized
but without understanding the consequences or any down-
load that happens without knowledge of the user. As more
and more computers are connected to the Internet, this kind
of attack has become the most widely use attack vector to
deliver malicious code [5, 2, 31]. These malicious codes could
be Trojans which steal identiﬁcation, password of your on-
line game or any other information that can be sold on black
market [49]. They may also be bot that used to build bot-
nets [7] to send spams [19], host phishing sites [22], or launch
distributed denial of service (DDoS) attacks [21].
A typical drive-by download attack scene has been clearly
explained in [30], The general steps may include:
1. Attackers prepare the exploit payloads and malwares.
The payloads could be malicious JavaScript, VBScript,
browser plug-ins, Adobe Flash or a combination of
them. These payloads are then put onto exploit servers
and malwares are put onto malware servers.
2. Attackers then embed links pointing to these payloads
into legitimate pages 1 by cracking the web sites or
buying web visit traﬃcs from the evil or unwitting
webmasters.
3. When victims visit these polluted pages, they are redi-
rected to the exploit servers.
4. The browser downloads the exploit payloads and tries
to handle them. During the handling procedure, these
malicious payloads launch attacks.
5. Once the victims are compromised, the prepared mal-
wares are downloaded and executed.
This new, web-based attack has several advantages over
traditional attacks. One advantage is the ability to launch
heap-spray attack [27, 8, 38], to increase the success rates of
exploitation. But a more deadly one is that, by using this
form of attack, it is much easier to bypass most detection
mechanisms used by existing protection systems.
Generally, detection mechanisms can be classiﬁed into
content-based and behavior-based. And protection systems
1In this paper, we deﬁne a page as all the content (html ﬁles,
scripts, images, et al.) that will be download automatically
by browser during a browsing session.
can be divided into network-based and host-based. Fire-
wall and network-based intrusion detection system (NIDS)
are two typical network-based protection systems. Antivirus
(AV) software and host-based intrusion detection system
(HIDS) are two typical host-based protection systems.
To detect malicious content eﬀectively, the content must
have special characteristics distinguishing itself from benign
ones. Before drive-by download attack emerged, researchers
[41, 29, 28] had found some viable methods to identify ma-
licious network ﬂows by detecting the plain text or light-
encoded shellcode within these ﬂows. However, in drive-by
download attacks, by utilizing the powerful capacities pro-
vided by the script engine of browsers or their plug-ins, at-
tackers can encode their shellcode in much more variable
ways during transfer, and then decode them just before the
exploitation. Currently, the most widely used encode mech-
anism is JavaScript obfuscation [14, 32]. And attackers have
begun using some more complex mechanisms, such as em-
bedding the malicious script into encrypted Adobe Flash
ﬁles [47]. Moreover, as the scripting engine getting more
and more powerful, attackers may even write a new inter-
preted language [37] to implement the exploitation.
AV softwares have been ﬁghting against diﬀerent encoding
and morphing mechanisms for many years, and have many
mature countermeasures. But most of them still use static
scanning strategy to detect malicious content on the web.
Although some of them have included script execution en-
gines, comparing with the complex browsers, these engines
are so primitive that sometimes they cannot handle the ma-
licious scripts correctly.
In short, current ‘unpack’ or anti-morphing technologies
used by content-based detection mechanisms are not power-
ful enough to handle these web-based malicious codes. Be-
sides, the scanning strategy is also problematic. Most exist-
ing scanners use ﬁle or network ﬂow as scanning granularity.
However, to help web application developers, most browsers
have the ability to let scripts include other scripts. By lever-
aging this feature, attackers can split one exploit script into
several ﬁles without aﬀecting the correct functionality. As
a result, scanners without a mature reassemble mechanism
will be bypassed.
By using behavior-based detection mechanism, the un-
packing and reassembling problem stated above could be
avoided. But the situation for existing behavior-based pro-
tection systems is no better. Firewalls can block illegal traf-
ﬁcs, yet from the perspective of ﬁrewall, since drive-by down-
load attack is almost the same as legitimate visiting web
pages, it has no reason to block this kind of traﬃc. Even
though black lists (e.g. Google Safe Browsing API [18]) can
be used to prevent visiting malicious servers, these lists trend
to be incomplete and sometimes outdated.
Most HIDSs use system behaviors (e.g. system call in-
vocations) to detect malicious programs. However, as the
malicious activities involved in drive-by download attacks
(e.g.
installing plug-ins, downloading and executing pro-
grams) are indistinguishable from legitimate activities at
this level, either the false negatives or the false positives
will be too high to be acceptable.
The limitation of behavior-based detection mechanism can
be attributed to the absence of decisive semantic information
from the exploitation scene. That is, the information they
gathered are so general that the characteristics of these in-
formation are not typical enough for attack detection. This
is similar to detecting malicious behaviors happening in the
guest operating system at the virtual machine monitor level.
To overcome this limitation, we propose monitoring inter-
module communication (IMC) to detect and prevent drive-
by download attacks. The motivation is: if we cannot get the
decisive semantic information outside the browser, maybe we
could get them from the inside. Luckily, after we analyzed
the attack scene more carefully, we found the following facts:
(1) modern web browsers are modularized, from the basic
HTML parsing and rendering engine to the diverse plug-ins,
are all implemented as modules; (2) no matter how the ma-
licious content reach the victim and how attackers prepare
the exploits, the essence of most exploitations is malicious
invocations of functions provided by the vulnerable module;
(3) these invocations are from the modules which handle
the malicious content; and (4) when the vulnerable func-
tion is invoked, the content has usually been deobfuscated.
Therefore, we could treat the invocations as communications
between modules and by checking these communications, at-
tacks are much easier to detect.
Generally, the proposed detection mechanism works as:
(1) monitoring the communications to the vulnerable mod-
ules during a browsing session; and (2) checking the commu-
nication content to identify known attacks, for improving the
detect precision, here we use vulnerability-based signatures
[46, 4] instead of traditional attack-based signatures. To
verify this idea, we implemented a proof-of-concept system
that is integrated into Microsoft Internet Explorer (MSIE)
browser. And we tested this prototype system on over one
hundred cached drive-by download attack samples.
In summary, the contributions of this paper are:
• We proposed an IMC monitoring based detection
mechanism to detect and prevent the drive-by down-
load attacks;
• We described a proof-of-concept implementation of our
approach, which can be integrated into the most widely
used browser, MSIE;
• We analyzed 19 popular vulnerability reports and gen-
erated 37 signatures for those vulnerabilities;
• We evaluated our prototype using 119 cached drive-
by download attack samples and the Alexa top ranked
sites. The experimental results demonstrate that our
system has a high detection eﬀectiveness and low false
positive rate, while the performance overhead is kept
low.
The rest of this paper is structured as: In Section 2, we in-
troduce the related work and compared our work with them.
In Section 3 we present the design of our approach and in
Section 4 we describe the implementation of our prototype
system.
In Section 5 we evaluate the prototype and dis-
cuss its limitation and future work in Section 6. At last, we
conclude our work in Section 7.
2. RELATED WORK
As drive-by download attack is becoming more and more
popular, besides the protection and detection systems men-
tioned in the introduction section, many other approaches
have been proposed to detect, analyze and mitigate this se-
vere threat.
General studies. To get a better understanding of this
threat, Provos et al. investigated web-based malware in [32],
in which they studied the ways adversaries used to place
exploits and the diﬀerent exploit techniques. In [49] Zhuge
et al. gave an empirical study of the black market behind
drive-by download attack and reported about 1.49% of the
web site returned by search engine is malicious. [31, 9] also
studied the malicious web site ratio on Internet.
Server-side detection. To detect injection attacks
against benign web pages, Halfond and Orso [16] proposed a
static technique to detect SQL injection. In [1] Bandhakavi
et al. describes a similar mechanism. Later they extended
this mechanism to detect cross site script (XSS) attack [3].
Based on dynamic taint analysis, researchers proposed sev-
eral methods to detect script injection attack [26, 25, 40]
and SQL injection attack [17, 36]. While our work aimed at
detecting and preventing drive-by download attacks at the
client-side, these works tended to stop the drive-by down-
load attack from the source. However, as some malicious
web sites are set up on purpose [49], only detecting server-
side exploitations cannot solve the problem once and for all.
Client-side detection. To detect drive-by download at-
tack, by adopting the honeypot idea, Microsoft proposed
HoneyMonkey system [45]. On contrary to server-side hon-
eypots that passively wait for attacks, honeypots of this kind
(i.e. client honeypot) will actively visit the Internet to trig-
ger web-based attacks. Since legitimate activities are re-
ducing to zero in honeypots, HIDS could be used without
producing false positives. However, as most existing high-
interaction client honeypot systems [45, 32, 39] still rely on
events at system API level, the abnormal behaviors they
detected are more likely to be from the malicious activi-
ties of downloaded malware, rather than activities directly
from the malicious web pages. Hence, if the malware is not
downloaded successfully, or the malware does not perform
any suspicious activities during the detection time window
(e.g. keep silent in virtual machines), a false negative would
rise. Since our approach detect the essential exploit behav-
ior, it can detect the attack more precisely than traditional
high-interaction client honeypots.
Since high-interaction honeypots are sometimes too heavy,
Jose introduced PHoneyC, a low-interaction client honey-
pot to detect malicious web pages in [24]. Unlike high-
interaction client honeypot, PHoneyC uses ActiveX emu-
lation to detect web-based exploits and uses AV scanner to
detect known malicious content. Wepawet [20] provides an
online service where people can submit suspicious URL for
analysis. It uses similar ideas like PHoneyC but is imple-
mented in Java. The disadvantage of these systems is similar
to antivirus software, i.e. though they can provide certain
level of interaction, today’s browsers are too complex to be
emulated perfectly. As a result, attackers can use features
not easily imitable to detect and bypass these emulators (e.g.
innerHTML). Since our approach can be integrated into real
browser, we could avoid such problems.
Since most exploits are implemented in script languages,
more precisely, in JavaScript [23], detecting and analyzing
malicious JavaScript is also gaining more and more atten-
tions. Egele et al. [13] and Ratanaworabhan et al. [33] pro-
posed techniques to identify drive-by download attacks by
detecting shellcode in JavaScript variables or heap memory.
While our approach is able to detect shellcode-based attacks
as well, it also can detect attacks without using shellcode.
Improving reliability of plug-in and browser. As
most drive-by download attacks rely on exploiting client-
side vulnerabilities, a lot of research has been done on miti-
gating vulnerabilities or limiting the damages. In Secunia’s
report [35], it is indicated that many of the vulnerabilities
being exploited are from browser plug-ins, especially Ac-
tiveX controls. To reduce this kind of vulnerabilities, in [10]
Dormann and Plakosh introduced an automated ActiveX
control fuzzing system to detect security ﬂaws. To solve
this problem from source, Yee et al.
[48] and Douceur et
al. [11] proposed two new plug-in frameworks named Native
Client and Xax. In these frameworks, plug-ins are restricted
inside sandboxes like what is done to Java applets but the
performance penalty is kept acceptable.
To push these restrictions further, Grier et al.
[15] pre-
sented OP browser, in which not only diﬀerent principles are
handled in diﬀerent sandboxed processes, but the scripts and
plug-ins used in one principle are also handled in diﬀerent
processes. This browser architecture also emphasizes the
important to use centralized, explicit IMC for auditing and
security checking. Based on the same idea, Microsoft also
developed the Gazelle browser [43]. Although these solutions
can provide better security, they are still prototype and most
Internet users are tending to use old browsers with which
they are familiar. For example, IE6 and IE7 still occupy
the biggest portion of the browser market [42]. Comparing
with them, our work could provide a more secure browsing
experience before the revolution of browser architecture.
Vulnerability-based signature. Vulnerability-based
signatures have been use in the Shield system [44] intro-
duced by Wang et al. Later, this work was extended to pre-
vent web-based exploits in [34]. Our work, while also aims
at preventing web-based exploits, diﬀers from BrowserShield
in the interception level. BrowserShield instruments HTML
and JavaScript content of a web page but our system inter-
cepts the communications made between browser modules.