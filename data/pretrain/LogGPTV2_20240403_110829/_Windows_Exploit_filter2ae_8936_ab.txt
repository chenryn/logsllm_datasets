好，让我们看看调试器，看看当我们触发漏洞时会发生什么。 你会注意到我已经添加（但注释掉）CollectGarbage（）函数。
在我的测试期间，我注意到poc不可靠（只有大约80％），所以我正在试验CollectGarbage（），看看是否会提高可靠性。
CollectGarbage（）是javascript公开的一个函数，它清空了四个bin，这些bin通过oleaut32.dll中的自定义堆管理引擎实现。当我们尝试在堆上分配我们自己的假对象，将与之相关。
从我的测试，我不能确定它有什么区别，但如果任何人有任何想法，在下面留下评论。
从下面的执行流程我们可以看到一个对象试图调用vtable中与EAX偏移量为0x70十六进制的函数。
stacktrace向我们展示了导致崩溃的执行流程。 如果我们在返回地址（在那里调用应该返回）如果没有崩溃，我们可以看到我们的函数是如何调用的。
看起来像EBX中的一些对象通过它的vtable指针ECX，然后后来被mshtml！CElement :: Doc引用调用一个函数在0x70十六进制偏移量。
通过使用一些巧妙的断点，我们可以跟踪由mshtml！CTreeNode做出的分配，以查看是否有任何熟悉的值弹出。
下面的结果表明EBX指向CparaElement，并且应该被调用的函数是Celement :: SecurityContext。
这似乎与MS13-009的漏洞描述相一致：“Microsoft Internet Explorer中的Use-After-Free漏洞，其中释放了一个CParaElement节点，但仍在CDoc中保留引用。当CDoc重新布局时，此内存被重用 执行“。
**  
**
**MS13-009 EIP**
正如我前面提到的，这里的主要重点是如何克服我们在exploit过程中遇到的障碍，所以我不会花时间来解释如何在堆上分配我们自己的对象。
相反，我将使用来自公开可用的漏洞的代码段。 我们的新POC可以在下面看到。
再次注意CollectGarbage（）函数，随意使用它，看看它是否有任何重大差异，当尝试分配对象。 让我们看看调试器，看看当我们执行这个POC会发生什么。
如果0x0c0c0c7c是存储器中的有效位置，则此指令序列将最终调用0x0c0c0c7c（= EIP）的DWORD值，此时不是这种情况。
记住我们的堆喷射设置为将shellcode变量对齐到0x0c0c0c0c，我们将看到为什么这是必要的。
只要记住我们可以设置EIP为任何我们想要的值，例如0xaaaaaaaa的DWORD值。 这可以通过用0xaaaaaaaa-0x70 =
0xaaaaaa3a重写EAX来实现。 你可以看到下面的例子。
让我们来看看调试器，以验证我们现在将最终覆盖EIP与0xaaaaaaaa。
**  
**
**MS13-009 Code Execution**
我们已经走了很远！ 综合我们迄今为止所做的工作，我们可以开始我们的代码执行之旅。 第一个任务是创建我们的新POC，其中包含我们的喷射并触发漏洞。
从下面的截图我们可以看到，我们覆盖了EIP与0x90909090，这是因为EIP从位于0x0c0c0c0c + 0x70 =
0x0c0c0c7c的DWORD的值，它指向我们的nopslide。
**  
**
**1.3 EIP in NopSlide**
这可能看起来有点混乱，希望下面的视图将帮助弄清过程！
让我们尝试填充我们的shellcode变量，以便我们可以精确地覆盖EIP。 我们可以通过在缓冲区长度为0x70十六进制（112字节=
28-DWORD）的前面添加我们的unescape ASCII字符串来实现。
如预期，我们现在可以完全控制EIP。 作为提醒，EIP中的值为小端。
**1.4 EIP Override**
我们的0x1000十六进制块的新布局如下。
好完美！现在我们要面对我们的下一个障碍。我们的ROP链和shellcode将位于堆上，但我们的堆栈指针（=
ESP）指向mshtml内部。我们执行的任何ROP小部件都将返回堆栈中的下一个地址，因此我们需要将堆栈从mshtml转移到堆上控制的区域（我们的0x1000字节块）。因为你会记得EAX正好指向我们的shellcode变量的开头，所以如果我们找到一个ROP小部件将EAX移动到ESP或交换它们，我们将能够枢转堆栈并开始执行我们的ROP链在0x0c0c0c0c。
我将使用来自与java6一起打包的MSVCR71.dll的ROP小工具，并由Internet
Explorer自动加载。我在下面包含了由mona生成的两个文本文件：
（1）MSVCR71_rop_suggestions.txt，其中包含一个主题化的ROP小工具列表；
（2）MSVCR71_rop.txt，它包含一个ROP小工具的原始列表；
如果你想使用他们，我建议你下载文件并使用正则表达式解析它们。
MSVCR71_rop_suggestions.txt –
[here](http://www.fuzzysecurity.com/tutorials/expDev/tools/MSVCR71_rop_suggestions.txt)
MSVCR71_rop.txt –
[here](http://www.fuzzysecurity.com/tutorials/expDev/tools/MSVCR71_rop.txt)
解析文本文件，我们可以轻松地找到我们需要的小工具，让我们修改我们的POC，并验证一切正常工作。
从下面的屏幕截图我们可以看到，我们在XCHG
EAX，ESP上下了断点，如果我们继续执行流程，我们成功地跳转到堆栈并尝试在0x0c0c0c0c执行第一个DWORD。
**  
**
**1.5 Breakpoint – Stack Pivot**
**  
**
**1.6 EIP = 0x42424242**
我们几乎解决所有的困难。 我们现在必须执行一个ROP链，用它禁用内存区域的DEP，因此我们可以执行第二阶段的有效负载。
幸运的是，MSVCR71.dll被攻击者反复滥用，并且已经存在一个由corelanc0d3r在这里创建的优化的ROP链。
让我们在我们的POC中插入这个ROP链并重新运行漏洞。
从屏幕截图中我们可以看到，我们在跳转堆栈后打开我们的第一个gadget，并且在我们调用VirtualProtect后，我们到达了剩下的垃圾。
**1.7 ROP gadget at 0x0c0c0c0c**
****
**1.8 Leftover junk 0x41414141**
现在剩下的就是在我们的垃圾缓冲区结束时插入一个跳转，跳过我们的初始EIP覆盖（XCHG EAX，ESP＃RETN）。
在我们的短跳跃之后放置的任何shellcode将被执行
在执行我们的短跳后，我们可以自由执行我们选择的任何shellcode！
**1.9 0xeb04 short jump** **Shellcode + Game Over**
现在到了容易的部分，让我们生成一些shellcode！
好，现在让我们整理我们的POC，添加注释和运行最终的漏洞。
我想再次提及，这个漏洞有一些可靠性问题（只有正常触发的几率是80％），如果任何人有问题，请在下面留下评论。
**2.0 Game Over**
****
传送门：[【技术分享】Windows
Exploit开发系列教程——堆喷射（一）](http://bobao.360.cn/learning/detail/3548.html)