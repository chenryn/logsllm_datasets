opportunity for library fuzzing because such API functions can
affect exploration of library code or discovering bugs potentially
by changing internal state.
4.3 Discovered vulnerabilities
We added two projects from GitHub, cJSON [5] and mpc [7], to
discover unknown bugs using AFL and FuzzBuilder. As projects
in OSS-Fuzz have been fuzzed significantly, other projects need
to be fuzzed to discover unknown bugs under limited resource.
Moreover, this can be an example to show that testers can easily
634s
e
n
i
l
d
e
t
i
s
i
v
f
o
#
500
400
300
200
100
0
s
e
n
i
l
d
e
t
i
s
i
v
f
o
#
20,000
15,000
10,000
5,000
0
1,260
1,050
840
630
420
210
0
5
6
0
1
3
2
4
time(h)
(b) T2
14,700
12,250
9,800
7,350
4,900
2,450
0
0
1
5
6
3
2
4
time(h)
(c) T6
7,200
6,000
4,800
3,600
2,400
1,200
0
0
1
5
6
3
2
4
time(h)
(a) T1
5
6
0
1
3
2
4
time(h)
(d) T8
FuzzBuilder
OSS-Fuzz
Figure 7: Line coverage comparison between FuzzBuilder and OSS-Fuzz for 6 hours fuzzing
FuzzBuilder
OSS-Fuzz
Input Generation
Target Program Execution
Update Seeds
Execution Analysis
Figure 9: General process of greybox fuzzing
T3
T4
T5
T7
test set
Especially, heap buffer overflow found in expat is an impressive
result because it is a bug that OSS-Fuzz could not find even though
it has used a large resource. The bug was found because FuzzBuilder
could generate an executable that includes a function sequence to
reach a state where the bug could be disclosed. Other bugs are
significant because they have not found owing to a difficulty in
applying greybox fuzzing.
Figure 8: Line coverage comparison between FuzzBuilder
and OSS-Fuzz for different time ranges fuzzing
Table 11: Tested projects from GitHub
project
cJSON
mpc
commit
08103f048e5f54c8f60aaefda16761faf37114f2
b31e02e427f55d4ce69c33ed9936a1b396628440
Table 12: Found bugs via automatically generated executa-
bles
project
expat
cJSON
mpc
bug type
heap buffer overflow
NULL dereference
stack buffer overflow
heap buffer overflow
apply fuzzing to library projects by using FuzzBuilder without in-
depth knowledge of libraries. Project names and commits are shown
in Table 11.
Consequently, we found four bugs from three projects, and all
the bugs we found are summarized in Table 12.
5 RELATED WORKS
5.1 Greybox fuzzing
We will address a simple background of greybox fuzzing in this
section. Although there are various types of greybox fuzzing, we
will focus on evolutionary mutation-based greybox fuzzing such as
AFL.
Fuzzing is a dynamic test that finds bugs in programs with ar-
bitrary input values. Greybox fuzzing uses lightweight program
analysis to generate arbitrary input values efficiently for exploring
various program paths. Generally, greybox fuzzing works, as shown
in Fig 9.
Greybox fuzzing generates arbitrary input values based on pro-
vided seeds. When a program terminates, greybox fuzzing analyzes
execution information such as basic block coverage and then up-
dates seeds if a generated input value covered new coverage. These
steps continue to repeat.
It is difficult for greybox fuzzing to achieve high code coverage
if a program requires a complex structure for its input value. There-
fore, seeds that can explore various program paths are used to solve
this problem.
Seeds that are used for fuzzing have been researched actively:
which seeds should get more energy [29, 32], how to generate seeds
efficiently [31, 33], and seed optimization [25].
635Some researches suggested new input generation mechanisms
to solve this problem: Angora[14], VUzzer[24], lafintel [9], steelix
[22], eclipser [15], TIFF [19], memfuzz [16]. Additionally, there are
hybrid approaches that use both fuzzing and symbolic execution
[30, 34]. However, it is still useful to provide seeds because they help
to achieve sufficient code coverage without any runtime resources,
in contrast to the above mechanisms.
Fuzzers should find bugs as many and as fast as possible to
increase the efficiency of greybox fuzzing. One of the ways to
achieve this is increasing the number executed instructions during
fuzzing. If more instructions are executed, then a larger part of
code is visited, thereby increasing opportunities to discover bugs.
Thus, the number of visited code lines is measured to evaluate
the performance of greybox fuzzing along with the number of
discovered bugs.
Most of the greybox fuzzers require an executable and the ex-
ecutable should be guaranteed to terminate within a short time.
Greybox fuzzers should execute a program with as many input
values as possible to explore various program paths. Thus, execu-
tion time is significant as it determines how many input values
can be tested within a specific time. These make it challenging to
apply greybox fuzzing to some programs, such as a library or a
server program which is waiting a request. Hence, an additional
executable should be prepared to apply greybox fuzzing and addi-
tional executables should include calling functions that are defined
in a target program and terminate within a short time.
5.2 OSS-Fuzz
OSS-Fuzz is a fuzzing service framework that was managed by
Google. This framework was released to share open source projects
with a successful fuzzing experience of chrome component. Until
today, OSS-Fuzz has tested more than 100 open source projects and
has found more than 10000 bugs.
To register an open source project to OSS-Fuzz, developers in
charge of a project should write code for fuzzing. The written source
code is stored in OSS-Fuzz, and then it is distributed to Clusterfuzz
[11] environment. Clusterfuzz is a distributed environment where
fuzzing is performed. OSS-Fuzz uses Libfuzzer as a fuzzer.
Libfuzzer is a greybox fuzzer for a library, that allows developers
to write code for fuzzing by using a simple interface. The written
source code is built to an executable with Libfuzzer code. Fuzzing
starts by executing this executable.
Although Libfuzzer provides a way for library fuzzing, source
code for fuzzing should be written manually by one who has in-
depth knowledge of a target project. These make it challenging to
use Libfuzzer in practice because it requires an understanding of a
library to write code correctly, understanding of fuzzing to write
code that is fuzzing-friendly, and maintenance of source code.
6 DISCUSSION
The followings are discussion topics for generating an executable
more precisely.
Automated specification of FA. FA is chosen manually in this
study. User intervention is required to provide information about FA
to FuzzBuilder. Fortunately, it is not difficult to select them because
various information is available in the form of manual or example
code. However, as future work, we will automate this functionality
for a fully automated process.
Optimization of generated executable. FuzzBuilder eliminates
unnecessary test functions when generating executables from unit
tests. However, there are many instructions that are not related to
fuzzing in generated executables. It is because most of the instruc-
tions were copied from unit tests directly. Further, even necessary
test functions may include calls to library API functions that are
not directly related to FA. These unnecessary parts slow down exe-
cution speed, which affects fuzzing performance. As future work,
we will consider a transformation of unit tests to generate a more
efficient executable for library fuzzing.
Errors in unit test. Unit test functions that implement test
cases may use an instruction to terminate program forcefully, such
as assert and abort for handling unexpected results. Some test func-
tions do not consider an unexpected value; hence, many bugs may
arise if an unexpected value is given. Unfortunately, most of the
values from fuzzers are an unexpected value. Thus, these cases
frequently occur during fuzzing and can cause two problems. First,
because of forced termination, most of the instructions in unit tests
may not be executed sufficiently. Second, fuzzers will recognize
such termination as a bug. As bugs in test code may not be a bug
of a target library, this can be considered as a false alarm. One of
the advantages of greybox fuzzing is low false alarms. Therefore,
this topic should be considered to get benefits of greybox fuzzing.
Expansion of input value types. FuzzBuilder considers an in-
put parameter type as char pointer. This data type is sufficient to
show the performance of the proposed method. This is because
many functions for parsing, a primary test target of greybox fuzzing,
receive input values in the form of char pointer data type. Further,
most of the fuzzing in OSS-Fuzz use this data type for passing
random input to a library. However, input value can be a string
data type in C++, or any user-defined type. Fuzzers have a higher
chance to explore various paths of libraries if more data types are
supported.
7 CONCLUSION
In this study, we proposed a method for applying greybox fuzzing
to a library. We implemented this method as a tool, FuzzBuilder,
which is based on LLVM framework. Executables generated by
FuzzBuilder can be used in any other fuzzers such as AFL. This
method helps developers by eliminating writing and maintenance
of source code for fuzzing. Additionally, this method helps testers
to perform greybox fuzzing without in-depth knowledge of a target
program. Further, seeds can be generated by this method for effi-
cient greybox fuzzing. Thus, FuzzBuilder helps to enhance software
security by applying greybox fuzzing to various types of a program
easily.
ACKNOWLEDGMENTS
This work was supported under the framework of international
cooperation program managed by National Research Foundation
of Korea(No.2017K1A3A1A17092614).
636[32] Maverick Woo, Sang Kil Cha, Samantha Gottlieb, and David Brumley. 2013.
Scheduling black-box mutational fuzzing. In Proceedings of the 2013 ACM SIGSAC
conference on Computer & communications security. ACM, 511â€“522.
[33] Wei You, Xuwei Liu, Shiqing Ma, David Perry, Xiangyu Zhang, and Bin Liang.
2019. SLF: Fuzzing without Valid Seed Inputs. In Proceedings of the 41st Interna-
tional Conference on Software Engineering, ICSE, Vol. 2019.
[34] Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and Taesoo Kim. 2018. {QSYM}:
A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing. In 27th
{USENIX} Security Symposium ({USENIX} Security 18). 745â€“761.
[35] Michal Zalewski. 2014. American Fuzzy Lob. http://lcamtuf.coredump.cx/afl/
[36] Michal Zalewski. 2015.
american fuzzy lop technical whitepaper.
http://lcamtuf.coredump.cx/afl/technical_details.txt (2015).
REFERENCES
[1] 1997. expat. https://github.com/libexpat/libexpat
[2] 2003. c-ares. https://github.com/c-ares/c-ares
[3] 2008. Google Test. https://github.com/google/googletest
[4] 2008. yara. https://github.com/VirusTotal/yara
[5] 2009. cJSON. https://github.com/DaveGamble/cJSON
[6] 2012. JUnit Best Practices Guide. https://howtodoinjava.com/best-practices/
unit-testing-best-practices-junit-reference-guide/
[7] 2013. mpc. https://github.com/orangeduck/mpc
[8] 2014. boringssl. https://github.com/google/boringssl
[9] 2016. lafintel. https://lafintel.wordpress.com/
[10] 2017. notes for asan. https://github.com/mirrorer/afl/blob/master/docs/notes_
for_asan.txt
[11] 2019. clusterfuzz. https://github.com/google/clusterfuzz
[12] Marcel BÃ¶hme, Van-Thuan Pham, Manh-Dung Nguyen, and Abhik Roychoudhury.
2017. Directed greybox fuzzing. In Proceedings of the 2017 ACM SIGSAC Conference
on Computer and Communications Security. ACM, 2329â€“2344.
[13] Marcel BÃ¶hme, Van-Thuan Pham, and Abhik Roychoudhury. 2017. Coverage-
based greybox fuzzing as markov chain. IEEE Transactions on Software Engineering
(2017).
[14] Peng Chen and Hao Chen. 2018. Angora: Efficient fuzzing by principled search.
In 2018 IEEE Symposium on Security and Privacy (SP). IEEE, 711â€“725.
[15] Jaeseung Choi, Joonun Jang, Choongwoo Han, and Sang Kil Cha. 2019. Grey-
box Concolic Testing on Binary Code. In International Conference on Software
Engineering (ICSE).
[16] Nicolas Coppik, Oliver Schwahn, and Neeraj Suri. 2019. MemFuzz: Using Memory
Accesses to Guide Fuzzing. In 2019 12th IEEE Conference on Software Testing,
Validation and Verification (ICST). IEEE, 48â€“58.
[17] Shuitao Gan, Chao Zhang, Xiaojun Qin, Xuwen Tu, Kang Li, Zhongyu Pei, and
Zuoning Chen. 2018. CollAFL: Path sensitive fuzzing. In 2018 IEEE Symposium
on Security and Privacy (SP). IEEE, 679â€“696.
[18] HyungSeok Han and Sang Kil Cha. 2017. Imf: Inferred model-based fuzzer. In
Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
Security. ACM, 2345â€“2358.
[19] Vivek Jain, Sanjay Rawat, Cristiano Giuffrida, and Herbert Bos. 2018. TIFF: Using
Input Type Inference To Improve Fuzzing. In Proceedings of the 34th Annual
Computer Security Applications Conference. ACM, 505â€“517.
[20] George Klees, Andrew Ruef, Benji Cooper, Shiyi Wei, and Michael Hicks. 2018.
Evaluating fuzz testing. In Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security. ACM, 2123â€“2138.
[21] Chris Lattner and Vikram Adve. 2004. LLVM: A compilation framework for
lifelong program analysis & transformation. In Proceedings of the international
symposium on Code generation and optimization: feedback-directed and runtime
optimization. IEEE Computer Society, 75.
[22] Yuekang Li, Bihuan Chen, Mahinthan Chandramohan, Shang-Wei Lin, Yang Liu,
and Alwen Tiu. 2017. Steelix: program-state based binary fuzzing. In Proceedings
of the 2017 11th Joint Meeting on Foundations of Software Engineering. ACM,
627â€“637.
[23] Hui Peng, Yan Shoshitaishvili, and Mathias Payer. 2018. T-Fuzz: fuzzing by
program transformation. In 2018 IEEE Symposium on Security and Privacy (SP).
IEEE, 697â€“710.
[24] Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,
and Herbert Bos. 2017. VUzzer: Application-aware Evolutionary Fuzzing.. In
NDSS, Vol. 17. 1â€“14.
[25] Alexandre Rebert, Sang Kil Cha, Thanassis Avgerinos, Jonathan Foote, David
Warren, Gustavo Grieco, and David Brumley. 2014. Optimizing seed selection for
fuzzing. In 23rd {USENIX} Security Symposium ({USENIX} Security 14). 861â€“875.
[26] Kosta Serebryany. 2016. Continuous fuzzing with libfuzzer and addresssanitizer.
In 2016 IEEE Cybersecurity Development (SecDev). IEEE, 157â€“157.
source software. (2017).
[27] Kostya Serebryany. 2017. OSS-Fuzz-Googleâ€™s continuous fuzzing service for open
[28] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitriy
Vyukov. 2012. AddressSanitizer: A fast address sanity checker. In Presented as
part of the 2012 {USENIX} Annual Technical Conference ({USENIX}{ATC} 12).
309â€“318.
[29] Lingyun Situ, Linzhang Wang, Xuandong Li, Le Guan, Wenhui Zhang, and Peng
Liu. 2019. Energy distribution matters in greybox fuzzing. In Proceedings of the
41st International Conference on Software Engineering: Companion Proceedings.
IEEE Press, 270â€“271.
[30] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution.. In
NDSS, Vol. 16. 1â€“16.
[31] Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2017. Skyfire: Data-driven
seed generation for fuzzing. In 2017 IEEE Symposium on Security and Privacy (SP).
IEEE, 579â€“594.
637