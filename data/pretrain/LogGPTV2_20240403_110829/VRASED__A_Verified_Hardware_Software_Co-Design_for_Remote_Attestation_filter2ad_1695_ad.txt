fact, such support is necessary for all approaches without a
separate secure stack.
6 Evaluation
We now discuss
implementation details and evaluate
VRASED’s overhead and performance. Section 6.2 reports on
veriﬁcation complexity. Section 6.3 discusses performance in
terms of time and space complexity as well as its hardware
overhead. We also provide a comparison between VRASED
and other RA architectures targeting low-end devices, namely
SANCUS [38] and SMART [21], in Section 6.4.
5.2 Compiler-Based Clean-Up
While stack erasure in HACL* would integrate nicely with
the overall proof of SW-Att, the assurance would be at the
language abstraction level, and not necessarily at the machine
level. The latter would require additional assumptions about
the compilation tool chain. We could also consider performing
stack erasure directly in the compiler. In fact, a recent proposal
to do exactly that was made in zerostack [45], an extension
to Clang/LLVM. In case of VRASED, this feature could be
used on unmodiﬁed HACL* (at compilation time), to add in-
structions to erase the stack before the return of each function
enabling P2, assuming the existence of a veriﬁed RAM erasure
routine upon boot. We emphasize that this approach may in-
crease the compiler’s trusted code base. Ideally, it should be
implemented and formally veriﬁed as part of a veriﬁed com-
piler suite, such as CompCert [33].
5.3 Double-HMAC Call
Finally, complete stack erasure could also be achieved directly
using currently veriﬁed HACL* properties, without any fur-
ther modiﬁcations. This approach involves invoking HACL*
HMAC function a second time, after the computation of the
actual HMAC. The second "dummy" call would use the same
input data, however, instead of using K , an independent con-
stant, such as {0}512, would be used as the HMAC key.
Recall that HACL* is veriﬁed to only allocate memory on
the stack in a deterministic manner. Also, due to HACL*’s
veriﬁed properties that mitigate side-channels, software ﬂow
does not change based on the secret key. Therefore, this de-
terministic allocation implies that, for inputs of the same size,
any variable allocated by the ﬁrst "real" HMAC call (tainted by
K ), would be overwritten by the corresponding variable in the
second "dummy" call. Note that the same guarantee discussed
in Section 5.1 is provided here and secure RAM erasure at boot
would still be needed for the same reasons. Admittedly, this
double-HMAC approach would consume twice as many CPU
cycles. Still, it might be a worthwhile trade-off, especially, if
there is memory shortage and lack of previously discussed
HACL* or compiler extension.
6.1
Implementation
As mentioned earlier, we use OpenMSP430 [22] as an open
core implementation of the MSP430 architecture. Open-
MSP430 is written in the Verilog hardware description lan-
guage (HDL) and can execute software generated by any
MSP430 toolchain with near cycle accuracy. We modiﬁed
the standard OpenMSP430 to implement the hardware archi-
tecture presented in Section 3.3, as shown in Figure 3. This
includes adding ROM to store K and SW-Att, adding HW-Mod,
and adapting the memory backbone accordingly. We use Xilinx
Vivado [50] – a popular logic synthesis tool – to synthesize
an RTL description of HW-Mod into hardware in FPGA. FPGA
synthesized hardware consists of a number of logic cells. Each
consists of Look-Up Tables (LUTs) and registers; LUTs are
used to implement combinatorial boolean logic while registers
are used for sequential logic elements, i.e., FSM states and
data storage. We compiled SW-Att using the native msp430-
gcc [46] and used Linker scripts to generate software images
compatible with the memory layout of Figure 3. Finally, we
evaluated VRASED on the FPGA platform targeting Artix-
7 [51] class of devices.
6.2 Veriﬁcation Results
As discussed in Section 3.2, VRASED’s veriﬁcation consists
of properties P1–P7. P5 is achieved directly by executing
SW-Att from ROM. Meanwhile, HACL* HMAC veriﬁcation
implies P4. All other properties are automatically veriﬁed us-
ing NuSMV model checker. Table 2 shows the veriﬁcation
results of VRASED’s HW-Mod composition as well as results
for individual sub-modules. It shows that VRASED success-
fully achieves all the required security properties. These results
also demonstrate feasibility of our veriﬁcation approach, since
the veriﬁcation process – running on a commodity desktop
computer – consumes only small amount of memory and time:
< 14MB and 0.3sec, respectively, for all properties.
1440    28th USENIX Security Symposium
USENIX Association
Table 3: Evaluation of cost, overhead, and performance of RA
Method
RAM Erasure
Required Upon Boot?
FPGA Hardware
Cell
LUT Reg
Core (Baseline)
Secure Stack (Section 4)
Erasure on SW-Att (Section 5.1)
Compiler-based Clean-up (Section 5.2) 6
Double-HMAC Call (Section 5.3)
N/A
No
Yes
Yes
Yes
1842
1964
1954
1954
1954
684
721
717
717
717
3044
3237
3220
3220
3220
Verilog
Memory (byte)
Time to attest 4KB
LoC
4034
4621
4516
4516
4516
ROM Sec. RAM CPU cycles ms (at 8MHz)
0
4500
4522
4522
4570
0
2332
0
0
0
N/A
3601216
3613283
3613283
7201605
N/A
450.15
451.66
451.66
900.20
Table 2: Veriﬁcation results running on a desktop @ 3.40 GHz.
HW Submod.
LTL Spec. Mem. (MB)
Time (s) Veriﬁed
Key AC
Atomicity
Exclusive Stack
DMA Support
HW-Mod
2,11
3,4,5,11
6,7,11
8-11
2-11
7.5
8.5
8.1
8.2
13.6
.02
.05
.03
.04
.28
✓
✓
✓
✓
✓
Table 4: Qualitative comparison between RA architectures
targeting low-end devices
Design Type
RA function
ROM for RA code
DMA Support
Formally Veriﬁed
VRASED
SMART
Hybrid (HW/SW) Hybrid (HW/SW)
HMAC-SHA256
HMAC-SHA1
SANCUS
Pure HW
SPONGENT-128/128/8
Yes
Yes
Yes
Yes
No
No
No
No
No
6.3 Performance and Hardware Cost
We now report on VRASED’s performance considering the stan-
dard design (described in Section 4) and alternatives discussed
in Section 5. We evaluate the hardware footprint, memory
(ROM and secure RAM), and run-time. Table 3 summarizes the
results.
Hardware Footprint. The secure stack approach adds around
587 lines of code in Verilog HDL. This corresponds to around
15% of the code in the original OpenMSP430 core. In terms of
synthesized hardware, it requires 122 (6.6%) and 37 (5.4%) ad-
ditional LUTs and registers respectively. Overall, VRASED con-
tains 193 logic cells more than the unmodiﬁed OpenMSP430
core, corresponding to a 6.3% increase.
Memory. VRASED requires ∼4.5KB of ROM; most of which
(96%) is for storing HACL* HMAC-SHA256 code. The se-
cure stack approach has the smallest ROM size, as it does not
need to perform a memory clean-up in software. However, this
advantage is attained at the price of requiring 2.3KBytes of
reserved RAM. This overhead corresponds to 3.5% of MSP430
16-bit address space.
Attestation Run-time. Attestation run-time is dominated by
the time it takes to compute the HMAC of P rv’s memory. The
secure stack, erasure on SW-Att and compiler-based clean-
up approaches take roughly .45s to attest 4KB of RAM on an
MSP430 device with a clock frequency at 8MHz. Whereas, the
6As mentioned in Section 5.2, there is no formally veriﬁed msp430 com-
piler capable of performing stack erasure. Thus, we estimate overhead of
this approach by manually inserting code required for erasing the stack in
SW-Att.
double MAC approach requires invoking the HMAC function
twice, leading its run-time to be roughly two times slower.
Discussion. We consider VRASED’s overhead to be affordable.
The additional hardware, including registers, logic gates and ex-
clusive memory, resulted in only a 3-6% increase. The number
of cycles required by SW-Att exhibits a linear increase with
the size of attested memory. As MSP430 typically runs at 8-
25MHz, attestation of the entire RAM on a typical MSP430 can
be computed in less than a second. VRASED’s RA is relatively
cheap to the P rv. As a point of comparison we can consider
a common cryptographic primitive such as the Curve25519
Elliptic-Curve Difﬁe-Hellman (ECDH) key exchange. A single
execution of an optimized version of such protocol on MSP430
has been reported to take ≈ 9 million cycles [24]. As Table 3
shows, attestation of 4KBytes (typical size of RAM in some
MSP430 models) can be computed three times faster.
6.4 Comparison with Other Low-End RA Ar-
chitectures
We here compare VRASED’s overhead with two widely
known RA architectures targeting low-end embedded systems:
SMART [21] and SANCUS [38]. We emphasize, however,
that both SMART and SANCUS were designed in an ad hoc
manner. Thus, they can not be formally veriﬁed and do not pro-
vide any guarantees offered by VRASED’s veriﬁed architecture.
Nevertheless, it is considered important to contrast VRASED’s
cost with such architectures to demonstrate its affordability.
Table 4 presents a comparison between features offered and
required by aforementioned architectures. SANCUS is, to the
best of our knowledge, the cheapest pure HW-based architec-
ture, while SMART is a minimal HW/SW RA co-design. Since
SANCUS’s RA routine is implemented entirely in HW, it does
not require ROM to store the SW implementation of the in-
tegrity ensuring function. VRASED implements a MAC with
digest sizes of 256-bits. SMART and SANCUS, on the other
hand, use SHA1-based MAC and SPONGENT-128/128/8 [7],
respectively. Such MACs do not offer strong collision resis-
tance due to the small digest sizes (and known collisions). Of
the three architectures, VRASED is the only one secure in the
presence of DMA and the only one to be rigorously speciﬁed
and formally veriﬁed.
Figure 13 presents a quantitative comparison between the
RA architectures. It considers additional overhead in relation to
the latest version of the unmodiﬁed OpenMSP430 (Available
USENIX Association
28th USENIX Security Symposium    1441
0
0
1
0
8
0
6
0
4
0
2
0
0
4
1
0
2
1