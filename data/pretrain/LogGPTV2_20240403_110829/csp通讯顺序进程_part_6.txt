它们是相同的，则是很不容易的事。
15
要画出CT，整个示意图，实在
图示法的另-一个弱点是不能描绘
1
choc
coin
toffes
广
---
## Page 38
证明
L1C
证明
L1B
证明
L1A
一点以后不再说明。
不论在哪儿，我们都假设方程式两边的进程的字母表都相同，这
11 (x:A→P(x)) =(y:B-→Q(y))
程显然是一样的。
如果两个进程的初始选择相同，其后续行为也相同，则这两个进
一步是相同的，但以后的行为不同，则这两个进程就不同，但是
由选择算子定义的进程，如果它们第一步的选择就不同，或者第
与算术中的法则很类似。
法则证明或否证字母表相同的两个进程的等同性，这些代数法则
都应知道（x+y）和（y－x)代表同一个数。我们可以运用一些代数
识别哪些表达式孰画了同一客体，哪些没有。这就象懂算术的人
要正确理解记法的含意，且能准确无误地使用它们，就必须学会
而另一方面，能动作的进程和什么都不能做的进程不会等同。
法则L1有凡个推论：
第一条法则(L1)是处理选择算子的(1.1.3节)。它说明两个
STOP≠(4-→P)
定义 R(x)=P
(c→P|d→Q)=(d-Q1e→P)
{}≠{]
LHS=(x:{o,d}-→R(x))
(c→P)≠(4→Q)
LHS=(x:{ }→P)
=(x:{d,c}→R(x))
≠(x:{d}→P)
=RHS
=RHS
=Q
=(A=BAx∈A.P(x)=Q(x))
4(+)
p=x
当x=C时
如果c≠
由定义(1.1:3节结尾)
(}≠{④}
由定义（1.1.3节结尾）
由定义
{c,d}={d,c}
由定义
G
---
## Page 39
证明这类事实。当我们证明某些显而易见的事实，而使用的法则
更为可信。该证明的唯一目的是要通过举例，说明这些法则足以
VM1和VMS只是该唯一解的两个不同名字而已。
递归方程相同。由于方程是卫式的，因此它只有一个解。于是，
证明
VM1 =VmS.
X3 设 VM1 =(coin→VM2)， 且 VM2 =(choc-→VM1),要证明
解：
下面紧接着---个重要推论，说明μX.F(X)确实是有关方程的
L2如果F(X)是卫式表达式，则有
条法则，即每个卫式递归方程有唯一解。
证明由L1C即可得证。
X2 μX.(coin-→(choc-→X|toffee→X))
证明由L1D，再由L1A即可得证。
X1 (coin→chao-→coin-→choc-STOP)≠(coin-STOP)
证明[c}={c}
L2AμX.F(X)=F(μX.F(X))
L1D
这个命题的成立是很显然的，进行证明也不能使人觉得它
要证明有关递归定义进程的更普逼的命题，我们还需引人一
用以上法则可证些简单的命题。
所以，VM1是递归方程的一个解，这个递归方程与VMS的
举例
举例
(c→P) =(c→Q)=P=Q
VM1 = (coin-→VM2)
=μX.(coin-=(toffee-→X|choc→X))
=(coin-→(choc→VM1))
(Y = F(Y))=(Y = μX ,F(X))
根据VM2定义
根据VM1定义
口
---
## Page 40
的每个事件可表逃为·个原子，臀如"COIN，"TOFFEE。一个
每个x，F(x)定义了进程执行第一个事件x后的未来行为。
而且，应用L2A，这个表达式可按要求的形式展开
这样，递归定义的进程可记为
形）。对递归定义的进程，我们--直强调所用递归式应该是卫式。
STOP)，或只有一个元素（如前缀情形），或多个元素（如选择情
这里F是符号到进程的对应函数，且集合B可以是空集（如
L3
件下，法则L3说明只有一个这样的数组X，其元素满足所有方
数组，其下标变化范围为S，F(i,X)是卫式表达式。在这些条
这里S是下标集合，每个方程的下标是S的--个元案；X是进程
般形式为
却没有那么明显时，要详细检查每一步证明，防止出现循环论
在LISP语言中，每个进程就可表述为--个函数。进程字母表中
证。
根据上述观点，在某种适当的函数式程序设计语言中，譬如
在上越条件下，如果有
法则L2可推广到联立递归。使用下标联立递归方程组的一
到目前为止，可表述的进程都记为以下形式
(Vi:S.(X=F(i,X)AY=F(i,Y)))
(x:B→F(x,μX.(x:B→F(x,X))))
X;= F(i,X)
μX,(x:B-→F(x,X))
1.4进程的实施
(x:B→F(x))
对所有iS
则X=Y
7
---
## Page 41
虑这一点。这样，CT就定义为
由自然数到进程的…个函数，当然进程本身也是函数，但先不考
例如，简单自动售货机（μX.coin→choc→X)就表示为
要四个参数：
表示一般的前缀操作（c→P）
许将一·函数做为一个自变量传递给另一个函数，我们利用这一点
数（如STOP)作为函数结果。LISP的另一个便利条件是，它允
表示。
数作为结果，代表进程的后续行为。于是，（coin→STOP)可
如果自变量的值是该进程的可能事件，这个函数则给出另一个函
于此。例如，既然STOP 从不执行任何事件，"BLEEP 就是它.
给出一个特殊符号"BLEEP作为结果。符号"BLEBP的用途仅在
变量。如果这个符号不是该进程的第一个可能事件，这个函数则
还可以用它表示联立递归式。
用函数
所能给出的唯一结果，因此它被定义为
进程是一个函数，
18
这个例子利用了LISP的一个便利条件，即可以返回·个函
我们可以利川 LISP的LABEL 特性表示递归定义的进程。
一个函数要表示一个一般的二元选择算子（o→P|d→Q)，需
LABEL X.prefix("COIN,prefix("CHOC,X))
choice2(c,P,d,Q) = Ax,if x = c then P
prefix(c,P) =Ax.if x= c then P
，它可以作用于这类事件符号上，把它们看作自
Ax.if x = "COIN then STOP
STOP=Ax."BLEEP
如CT(1.1.4节X2)就可被看作是.
 else if x = d then Q
else"BLEEP
else"BLEEP
else"BLEEP
---
## Page 42
之后，进程的后续行为。这条规律为我们探讨进程的行为提示了
menu = (A, P) = if A = NIL then NIL
程。重复时，P作用于该符号产生的结果将用来取代P。当结束
输入的符号不在表menu（A，P)中，则就发出清晰的哎哎的响声，
到货光屏上，然后再由键盘输入一个符号，观察结果。如果这个
果y在menu（A,P（x))中，则P(x）（y)定义的是在x和y都发生
给出可做为P的生存期内的第一个事件的全部符号
interaot(A,P,k) =cons(menu(A,P),
符号的表，则LISP函数
CT(0)是以地面为起点的进程。
序列，则以下函数给出其输出序列
这--过程时键入符号"END。于是，如果K是由键盘输入的符号
但不接受它。如果它在这个表中，就会被接受，然后重复这一过
一个很有用的方法。编写一段程序，先将menu（A，P)的值输出
CT=LABELx.An.
如果P是表示一个进程的函数，且.A为包含该进程字母表中
个函数，它定义了P执行完×后的未来行为。由此推出，如
以上定义LISP函数时所用的记号法很不正规，
假设x在menu（A,P)中，且P(x)不是"BLEEP，那么P(x)
if n=0 then choice2(" AROUND, X(O),"UP, X(1))
else choice2("UP,X(n +1),"DOWN, X(n- 1))
else if P(car(k)) = "BLEEP then
else if P(car(A)) ="BLEEP
else interact(A,P(car(k)),cdr(k)))
if car() = "END then NIL
else cons(car(A),menu(cdr(A),P))
then menu(cdr(A), P)
cons("BLEEP,interact(A,P,cdr(k)))
menu(A,P)
还需要把它
9
---
## Page 43
录该进程到某一时刻为止执行的各个事件。设想有位观察员带着
程算子的一种实施了。
函数，它们作用于表示进程的函数上，就可以被看作是相应的进
看做是其相应进程的实施。更进一步地说，象prefix这样的LISP
示的任-一进程了。
总之，这样--来，我们就有可能观察计算机执行以LISP函数表
数imteract应该改写，使用显式输大和输出来达到同样的效果。
可以交互式地研究进程P的行为。在其它儿种LISP 版本中，函
第一个输出。使用者通过在不断输出荣单中选择并输入符号，就
interact时以键盘作为它的第三个参数；进程P的荣单则是它的
如果输入和输出是由情式求值的LISP实施的，则在调用函数
用LABEL特性，因此有
还要更方便些，因为这种LISP允许对递归方程直接编码，不需
约束的那种LISP，使用它时会方便些。而使用情式求随的LISP
有什么困难。
在各种类型机器上用各种LISP 变种翻译并运行进程时，都不会
我们使用的只是纯函数式LISP语言的一个很小的子集合，因此，
中，前缓函数可定义为
们翻译成具体规范的LISP的S-—表达式的形式。例如在LISPkit
2
如果有好几种LISP版本都能用，我们就选择带有变量静态
一个进程行为的迹是符号的一个有限序列，这个符号序列记
VMS= prefix("COIN, prefix("CHOC, VMS))
(prefix
tambda
(lambda(x)(if(eg x a)p(quote BLEEP))))
(α p)
。从这个意义上来说，这种LISP函数就可以被
1.5
迹
---
## Page 44
对一台给定的机器来说，那四个长度为2的迹中只有一个能真正
过2的迹
X4复杂自动售货机VMC(1.1.3节中X4)有以下七个长度不超
空迹是每个逃程可能的最短迹。
X3在选程开始执行任何事件之前，观察员的笔记本是空白
些进程的宇母表内，所以也就不能被观察到或记录下来。
样。因为顾客的饥不可耐和机器满足顾客要求的责任威都不在这
的。这种情况表示为空迹
不论是进程还是观察员此时都无法了解这笔完整的交易会是怎
X2同是那台售货机在第二位顾客的巧克力被送出之前的迹为
位顾客服务，这时它的迹为
X1简单自动售货机VMS(1.1.2节中X2)，若刚好完成了为两
在一对角括号内
他记录的先后次序也不是重要的。
有两个事件同时发生了，观察员做记录时也总要有先有后，而且
来。我们完全可以忽略两个事件同时发生的可能性；因为即使箕
笔记本，观察这个进程，每一个事件发生时他就将该事件名记下
《》不包含任何事件的空序列。
归两个事件组成，y跟在x后发生。
一个迹将表示为符号的一个序列，中间山逗号断开，并且括
举例
21
门
口
口
---
## Page 45
溯如
和按照"，的次序简单地拼到-一起，构成一个迹，结果记
1.6.1连接
质以及迹的运算。我们要别到以下约定
着一个很关键的角色。在这一节里，我们要探讨迹的某些一般性
不在我们选择的字母表内。
了。至于顾客和售货机的结局如何，我们就不得而知了，因为这
是一筹莫展，不会再有事件发生了，不会再有符号能记在小本上
成为VMC可能的迹。这时，顾客可能干着急没办法，观察员也