Stagefright: Scary Code
in the Heart of Android
Researching Android Multimedia
Framework Security
Joshua "jduck" Drake
August 7th 2015
DEF CON 23
Agenda
Introduction
System Architecture
Attack Surface
Attack Vectors
Vulnerability Discovery / Issues Found
Exploitability / Mitigations
Disclosure
Conclusions
Introduction
About the presenter and this research
About Joshua J. Drake aka jduck
Focused on vulnerability research and exploit development
for the past 16 years
Current Affiliations:
Zimperium's VP of Platform Research and Exploitation
Lead Author of Android Hacker's Handbook
Founder of the #droidsec research group
Previous Affiliations:
Accuvant Labs (now Optiv), Rapid7's Metasploit,
VeriSign's iDefense Labs
Motivations
1. Improve the overall state of mobile security
1. Discover and eliminate critical vulnerabilities
2. Spur mobile software update improvements
2. Increase visibility of risky code in Android
3. Put the Droid Army to good use!
Special thanks go to Amir Etemadieh of Optiv / Exploiteers
for his help with this research.
Sponsors
This work was sponsored by Accuvant Labs (now Optiv) with
continuing support from Zimperium. 
 & 
Additional thanks to Collin Mulliner and Mathew Solnik!
What is Stagefright?
Android's Multimedia Framework library
written primarily in C++
Handles all video and audio files
Provides playback facilities - e.g. {Nu,Awesome}Player
Extracts metadata for the Gallery, etc.
Brief History
Android launched with an engine called OpenCORE
Added to AOSP during Android Eclair (2.0) dev
Optionally used in Android Froyo (2.2)
Both devices I have on 2.2 have it enabled
Set as the default engine in Gingerbread (2.3) and later 
It's also used in Firefox, Firefox OS, etc.
first shipped in Firefox version 17
Used on Mac OS X, Windows, and Android
NOT used on Linux (uses gstreamer)
Why Stagefright?
1. Exposed via multiple attack vectors
some of which require no user interaction
2. Binary file format parsers are often vulnerable
Especially those written in native code
3. Various public mentions of instability (crashes)
/r/Android, AOSP bug tracker, googling for
"mediaserver crash", etc.
4. Related publications about fuzzing the code
Related Work I
 (
)
Fuzzing the Media Framework in Android Slides
by Alexandru Blanda and his team from Intel
They released their tools! See: 
Interesting results!
tons of things reported
7 accepted as security issues
3 fixed in AOSP
CVE-2014-7915, CVE-2014-7916, CVE-2014-7917
MFFA
MORE ON THESE LATER ;-)
Related Work II
On Designing an Efficient Distributed Black-Box Fuzzing
System for Mobile Devices
by Wang Hao Lee, Murali Srirangam Ramanujam, and S.P.T.
Krishnan of Singapore's Institute for Infocomm Research
Focused on tooling more than bugs
Not focused on Android only
Found several bugs, but analysis seems lacking/incorrect
Unclear if any issues were fixed as a result
Related work
Pulling a John Connor: Defeating Android
by Charlie Miller at Shmoocon 2009
Discusses fuzzing a media player
got crashes in mediaserver
Focused on opencore, not Stagefright
Focused on pre-release G1
Really old, research done in 2008
However, due to apparent lack of proactive Android security
research it seems relevant still.
About this research
Stagefright is big and supports a wide variety of multimedia
file formats.
Rather than dividing my focus among multiple formats, I
focused on MPEG4.
This allowed me to be more thorough in eliminating issues. 
As such, the rest of this presentation will be somewhat
specific to Stagefright's MPEG4 processing.
System Architecture
Processes, privileges, etc.
Android Architecture
Picture from 
 in the Android Developer documentation
Android Interfaces
Android is very modular
Things run in separate
processes
Lots of inter-process
communications
"Sandbox" relies on modified
scheme based on Linux users
and groups
libstagefright executes inside
"MEDIA SERVER"
Process Architecture
The mediaserver process runs in the background:
media     181   1     120180 10676 [...] S /system/bin/mediaserver
It's a native service that's started at boot from /init.rc:
service media /system/bin/mediaserver
    class main
    [...]
As such, the process automatically restarts when it crashes.
Process Privileges (Nexus 5)
The last part of the service definition in /init.rc shows the
privileges that the service runs with:
service media /system/bin/mediaserver
    class main
    user media
    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm
WHOA! This service is very PRIVILEGED!
Android apps CANNOT request/receive permissions like
audio, camera, drmrpc, and mediadrm
But there's more...
mediaserver Privilege Survey
A Droid Army provides quick and valuable survey results!!
I surveyed 51 devices. The breakdown by OEM was:
Count  $(BRAND)
====== ====================
17     Nexus/Google
13     Motorola
9      Samsung
6      HTC
3      LG
1      Sony
1      Amazon
1      ASUS
1      Facebook
1      OnePlus/Cyanogen
1      SilentCircle/SGP
Let's look at accessible groups, sorted by # of devices...
Privilege Survey Results I
CNT GROUP              PURPOSE
51  3003(inet)         /* can create AF_INET and AF_INET6 sockets */
51  3002(net_bt)       /* bluetooth: create sco, rfcomm or l2cap sockets */
51  3001(net_bt_admin) /* bluetooth: create any socket */
51  1006(camera)       /* camera devices */
51  1005(audio)        /* audio devices */
[...]
All devices had this level of access, with which you can:
Monitor, record, and playback audio
Access camera devices
Connect to hosts on the Internet
Access and configure bluetooth
Ouch! This allows an attacker to spy on you already.
Privilege Survey Results II
Continuing down the line, things get interesting...
CNT GROUP              PURPOSE
33  3007(net_bw_acct)  /* change bandwidth statistics accounting */
33  1026(drmrpc)       /* group for drm rpc */
27  1000(system)       /* system server */
20  1003(graphics)     /* graphics devices */
19  1031(mediadrm)     /* MediaDrm plugins */
18  3004(net_raw)      /* can create raw INET sockets */
11  3009(qcom_diag)    /*  baseband debugging? */
9   1028(sdcard_r)     /* external storage read access */
8   1023(media_rw)     /* internal media storage write access */
8   1004(input)        /* input devices */
7   1015(sdcard_rw)    /* external storage write access */
4   2000(shell)        /* adb and debug shell user */
4   1001(radio)        /* telephony subsystem, RIL */
and more!
Architecture Recap
To recap the important bits...
1. libstagefright processes media inside mediaserver
2. The service runs privileged, potentially even as "system"
3. mediaserver automatically restarts
The additional attack surface exposed to a compromised
mediaserver is large â€” even compared to ADB. Beware.
Attack Surface
Where is the code under attack?
Locating the Attack Surface
NOTE: Released tools include some helper scripts.
Once you have your environment set up, finding the MPEG4
attack surface is relative straight-forward.
1. Attach debugger to mediaserver process
2. Place breakpoint on open
3. Open an MPEG4 video file
4. Sift through breakpoint hits until r0 points at your file
5. Look at the backtrace
6. Dig in and read the surrounding code
What do you find?
[*] open("/sdcard/Music/playing.mp4",...) called from:
#0  open (pathname=, flags=0) at bionic/libc/unistd/open.c:
#1  0x40b345e8 in FileSource (this=0x479038, filename=0x478d08 "/sdcard/Music/pl
#2  0x40b332fe in android::DataSource::CreateFromURI (uri=0x478d08 "/sdcard/Musi
#3  0x40b2ef50 in android::AwesomePlayer::finishSetDataSource_l (this=0x478058)
 at frameworks/base/media/libstagefright/AwesomePlayer.cpp:2085
#4  0x40b2efb2 in android::AwesomePlayer::onPrepareAsyncEvent (this=, queue
#6  0x40b50c28 in android::TimedEventQueue::threadEntry (this=0x47806c) at frame
#7  0x40b50c6c in android::TimedEventQueue::ThreadWrapper (me=0x47806c) at frame
#8  0x400e8c50 in __thread_entry (func=0x40b50c59 , attr=0xbe81e
frame #3 - frameworks/base /
media/libstagefright/AwesomePlayer.cpp:2085
(note: moved to frameworks/av in Android >= 4.1)
AwesomePlayer.cpp:2085
2085         dataSource = DataSource::CreateFromURI(mUri.string(), &mUriHeaders)
2086     }
....
2092     sp extractor;
2093
2094     if (isWidevineStreaming) {
....
2109     } else {
2110         extractor = MediaExtractor::Create(
2111                 dataSource, sniffedMIME.empty() ? NULL : sniffedMIME.c_str(
....
2127     status_t err = setDataSource_l(extractor);
Okay, so it calls setDataSource_l(sp)...
Let's look at that.
AwesomePlayer::setDataSource_l
 349 status_t AwesomePlayer::setDataSource_l(const sp &extractor) {
 ...
 356     for (size_t i = 0; i countTracks(); ++i) {
... calls MPEG4Extractor::countTracks:
 305 size_t MPEG4Extractor::countTracks() {
 ...
 307     if ((err = readMetaData()) != OK) {
In turn, that calls readMetaData. Let's check that out...
 365 status_t MPEG4Extractor::readMetaData() {
 ...
 372     while ((err = parseChunk(&offset, 0)) == OK) {
 373     }
readMetaData calls parseChunk. Let's look at that!
MPEG4Extractor::parseChunk
This function is the primary attack surface for MPEG4
parsing!
primary dispatch for handling MP4 atoms / FourCC values
between 80 and 140 depend on Android version
it's implemented using recurison
 671     switch(chunk_type) {
 672         case FOURCC('m', 'o', 'o', 'v'):
 673         case FOURCC('t', 'r', 'a', 'k'):
 ...
 724             while (*offset  tag is new in HTML5! Let's try it... 
...Yep, it works!
Vector II: Browser Auto-download
Also, servers can force you to download instead!
Vector II: Browser Auto-download II
See also: http://developer.android.com/reference/android/app/DownloadManager.html
Downloads happen in the background.
No prompting to the user.
No option to prompt either :-/
FEATURE REQUEST!
This behavior has been abused in the past...
Thomas Cannon's "Data Stealing"
Not just on Android! "Carpet Bombing" attack 
Testing shows it processes media when it's finished
downloading!
Enter the Media Scanner
NOTE: For more details, see the bonus slides or whitepaper (in progress).
After a long journey looking into browser download
processing, I discovered the MediaScanner, which:
Extracts metadata for the Gallery and so on.
Is invoked in various ways, including:
Directly, via MediaScannerConnection
MEDIA_{MOUNTED,SCANNER_SCAN_FILE} Intents
Classes implementing MediaScannerConnectionClient
With our new understanding, we continue our methodology
and track backwards to untrusted data sources. We find...
Tons of Attack Vectors!
We find a multitude of attack vectors that use Stagefright!
In summary, any way your device touches media:
Mobile Network - Mms
Client Side - Browser, Downloads, Email
Physically Adjacent - Nfc, Bluetooth, VCards
Physical - SD Cards, USB OTG Drives, USB MTP/PTP
Misc - Gallery
Total attack vectors: 11+
Do you use any of these to talk to untrusted people?
The Scariest Part - MMS
Media is AUTOMATICALLY processed ON MMS RECEIPT.
BEFORE creating a notification!
Actually, while creating the notification 
Exploiting a vulnerability in Stagefright via MMS could allow
SILENT, REMOTE, PRIVILEGED code execution.
The attacker's payload simply needs to prevent the
notification. 
Who has your phone number?
Where does this work?
Doesn't seem to work in com.android.mms (AOSP:packages/apps/Mms)
Works in latest version of Hangouts
The default MMS application in 5.0+
Google removed com.android.mms 
Works in latest version of Messenger
Popular alternative to Hangouts
Now com.google.android.apps.messaging 
TURN AUTO-RETRIEVE OFF!
Not a silver bullet, 10+ vectors left... 
Triggers Virally
The vulnerable code is invoked many times in Android.
Basically any time a thumbnail is rendered or metadata is
needed (e.g. dimensions)
Rotating the screen
Starting the Messaging app (conversation list)
Viewing the Gallery
Sharing malicious media
and so on...
Any Other Vectors?
There could be additional vectors! Consider:
Downstream (OEM/Carrier) modifications
Third-party apps
Untested ideas:
Instant messaging?
Social networks?
QR Codes?
Please reach out if you have ideas or discover additional
vectors!
Vulnerability Discovery
Are there security bugs in Stagefright?
Discovery Methodology
This is the basic methodology I used for the first pass:
1. Write fuzzer (basic dumb fuzzer in this case)
2. Run the fuzzer
3. While fuzzer runs, read code
4. When fuzzer finds crashes, read surrounding code
5. Repeat until brain melted
First Round Specifics
Again, the decision was to focus on MP4 video.
Seemed complicated enough...
Had the most lines of code
Same code handles other formats (3GP, M4A)
Corpus
What code your inputs exercise matters
Didn't even bother with building an optimized set
Started with the smallest file possible
@Zenofex created meow.3gp - 25KB
First Round Results
The fuzzer ran on live Android devices for ~1 week.
Results: ~6200 crashes
Most crashes not interesting
Post-analysis results: ~20 unique bugs
None of these were very interesting
However, code review during analysis was fruitful!
Found ~5 memory corruptions nearby during code review
These became CVE-2015-1538 and CVE-2015-1539