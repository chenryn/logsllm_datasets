ﬂows can be subject to different types of vulnerabilities, as
discussed in Section 3, we focus on XSS. Thus, the heuristics
implemented by the exploit checker consists of recognizing
a vulnerable ﬂow when an alert window is spawned by the
corresponding, tainted ﬂow. Finally, the exploit checker stores
the vulnerable ﬂows in the conﬁrmed vulnerabilities database.
The deﬁnition of injection payload is non-trivial. Since our
1https://github.com/AvalZ/RevOK
20    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
Section 5.3.
5.1 RevOK
Our prototype consists of two modules: the test driver and the
test stub. We detail them below.
Test driver A dedicated test driver is used for each scanning
system. The test driver (i) triggers a scan against the test stub,
(ii) saves the report in HTML format and (iii) processes the
report to detect tainted and vulnerable ﬂows (in Phase 1 and
2, respectively). While (iii) is the same for all the scanning
systems, (i) and (ii) may vary.
In general, the implementation of (i) and (ii) belongs to
two categories depending on whether the scanning system
has a programmable interface or only a GUI. When a pro-
grammable interface is available, we implement a Python 3
client application. For instance, we use the native os Python
module to launch Nmap so that its report is saved in a spe-
ciﬁc location (as describe in Section 2). Similarly, we use the
requests Python library2 to invoke the REST APIs provided
by a scanning system and save the returned HTML report.
Instead, when the scanning system only supports GUI-based
interactions, we resort to GUI automation. In particular, we
use the Selenium Python library3 for browser-based GUIs and
PyAutoGUI4 for desktop GUIs. In the case of GUI automa-
tion, the test driver repeats a sequence of operations recorded
during a manual test.
Finally, for the report processing step (iii) we distinguish
between two operations. The tainted ﬂow detection trivially
searches the report for the injected tokens provided by the
response generator (see below). Instead, vulnerable ﬂows are
conﬁrmed by checking the presence of alert windows through
the Selenium function switch_to_alert().
Test stub For the response generator, we implemented
the PCFG grammar fuzzer detailed in Section 4.2 in
Python. Tokens are represented by randomly-generated Uni-
versally Unique Identiﬁers [22] (UUID). A UUID con-
sists of 32 hexadecimal characters organized in 5 groups
that are separated by the - symbol. An example UUID is
018d54ae-b0d3-4e89-aa32-6f5106e00683. As required
in Section 4.2, UUIDs are both recognizable (as collisions
are extremely unlikely to happen) and uninterpreted (as they
contain no HTML special characters).
On the other hand, starting from a response, the exploit
builder replaces a given UUID with an injection payload.
Payloads are taken for a predeﬁned list of selected polyglots,
as discussed in Section 4.3.
Figure 5: Phase 2 – ﬁnd vulnerable ﬂows.
TEE applies to both on-premise and as-a-service scanning
systems, some issues must be considered. The ﬁrst issue is
testing performances. As a matter of fact, scanning systems
can take a considerable amount of time to perform a single
scan. Moreover, as-a-service scanning systems should not
be ﬂooded by requests to avoid degradation of the quality
of service. For these reasons, we aim to limit the number of
payloads to check.
As discussed in Section 2.3, polyglots allow us to test mul-
tiple contexts with a single payload. In this way, we increase
the success probability of each payload and, thus, we reduce
the overall number of tests.
In principle, we might resort to the polyglot of [11], which
escapes 26 contexts. However, its length (144 characters)
is not adequate since many scanning systems shorten long
strings when compiling their reports, so preventing the ex-
ploit from taking place. To avoid this issue, we opted for poly-
glots such as "’/>.
This is rendered by the browser when appearing inside both
an HTML tag and an HTML attribute. The reason is that
the initial " and ’ allow the payload to escape from quoted
attributes.
Furthermore, delivering the JavaScript payload in onerror
has two advantages. First, it circumvents basic input ﬁltering
methods, e.g., blacklisting of the script string. Secondly,
our payload applies to both static and dynamic reports. More
precisely, a static report consists of HTML pages that are
created by the scanning system and subsequently loaded by
the analyst’s browser. Instead, a dynamic report is loaded
by the browser and updated by the scanning system during
the scan process. The HTML5 standard speciﬁcation [16,
§ 8.4.3] clearly states that browsers can skip the execution of
dynamically loaded scripts. For this reason, our payload binds
the script execution to an error event that we trigger using
a broken image link (i.e., src=’x’). A concrete example of
this scenario is discussed in Section 6.2.
5 Implementation and results
In this section, we present our prototype RevOK. We used it
to carry out an experimental assessment that we discuss in
2https://requests.readthedocs.io
3https://selenium-python.readthedocs.io/
4https://pyautogui.readthedocs.io
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    21
60
30
0
5.2 Selection criteria
We applied our prototype implementation to 78 scanning
systems. The full list of scanning systems, together with our
experimental results (see Section 5.3), is given in Table 1.
There, we use (cid:140) and H to distinguish between as-a-service
and on-premise scanning systems, respectively.
For our experiments, we searched for scanning systems
included in several categories. In particular, we considered
security scanners, server ﬁngerprinting tools, search engine
optimization (SEO) tools, redirect checkers, and more. From
these, we removed scanning systems belonging to the follow-
ing categories.
• Abandonware, i.e., on-premise scanning systems that
were not maintained in the last 5 years.
• Paywalled, i.e., scanning systems that are not free and
have no trial version.
• Scheduled, i.e., as-a-service scanning systems that only
perform periodic scans, not controlled by the analyst.
Vulnerable
Tainted
r
e
v
r
e
S
n
o
i
t
a
c
o
L
t
e
N
p
s
A
X
-
d
e
r
e
w
o
P
-
X
c
v
M
t
e
N
p
s
A
X
-
S
T
S
s
u
t
a
t
S
S
S
X
X
-
P
S
C
h
s
i
n
r
a
V
X
-
y
d
o
B
e
i
k
o
o
C
-
t
e
S
e
m
a
r
F
-
X
t
n
e
t
n
o
C
X
-
Figure 6: Frequency of tainted and vulnerable ﬂows.
5.3 Results
We applied RevOK to the scanning systems of Table 1. For
each scanning system, we used RevOK to execute 10 scan
rounds (see Section 4) and we listed all the detected tainted
and vulnerable ﬂows. As a result, we discovered that 67 scan-
ning systems have tainted ﬂows and, among them, 36 are
vulnerable to XSS.
In Table 1, for each scanning system we report the number
of tainted and vulnerable ﬂows (T and V, respectively) de-
tected by RevOK. After running RevOK, we also conducted
a manual vulnerability assessment of each scanning system.
The assessment consisted of a review of each tainted ﬂow,
followed by a manual payload generation (see below).
Under column M, (cid:88) indicates that an XSS vulnerability
was found by a human analyst starting from the outcome
of RevOK. It is worth noticing that only in one case, i.e.,
DupliChecker, RevOK resulted in a false negative w.r.t. the
manual analysis. By investigating the causes, we discovered
that DupliChecker performs URL encoding on the tainted
locations. This encoding, among other operations, replaces
white spaces with %20, thus invalidating our payloads. To
effectively bypass URL encoding, we replaced white spaces
(U+0020) with non-breaking spaces (U+00A0) that are not
modiﬁed. Thus, we deﬁned a new polyglot payload that uses
non-breaking spaces and we added it to the injection list
included in RevOK. Using this new payload, RevOK could
also detect the vulnerability in DupliChecker.
At the time of writing, all the vulnerabilities detected by
RevOK have been reported to the tool vendors and are under-
going a responsible disclosure process (see Appendix A).
In Figure 6 we show the frequency of the tainted and vulner-
able ﬂows over the 14 ﬁelds considered by RevOK. Location
Figure 7: Correlation between tainted ﬁelds.
has 59 tainted ﬂows, the highest number, and 21 vulnerable
ﬂows. Server only has 51 tainted ﬂows, but it has 26 vul-
nerable ﬂows, the highest number. On the other hand, Body
has only 14 tainted ﬂows and only 1 vulnerable ﬂow. This
highlights that most scanning systems sanitize the Body ﬁeld
in their reports. The reason is that HTTP responses most
likely contain HTML code in their Body. Thus, sanitization is
mandatory to preserve the report layout. Also, the Body ﬁeld
is often omitted by the considered scanning systems.
In Figure 7 and Figure 8 we show the correlation matrices
for tainted and vulnerable ﬁelds, respectively. From these
matrices we observe a few, relevant facts. We brieﬂy discuss
them below.
The ﬁrst observation is that the Body ﬁeld is almost unre-
lated to the other ﬁelds, both in terms of tainted and vulnerable
ﬂows. This is somehow expected since the Body ﬁeld is often
neglected as discussed above.
22    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
Table 1: Experimental results for the considered scanning systems. († requested to stay anonymous.)
T is the number of tainted ﬂows, V is the number of vulnerable ﬂows, M indicates if a human analyst found a vulnerability.
Name
(cid:140) AddMe
(cid:140) AdResults
H Arachni
(cid:140) AUKSEO
(cid:140) BeautifyTools
(cid:140) BrowserSPY
(cid:140) CheckHost
(cid:140) CheckMyHeaders.com
(cid:140) CheckSERP
(cid:140) CheckShortURL
(cid:140) Cloxy Tools
(cid:140) CookieLaw
(cid:140) CookieMetrix
(cid:140) DNS Checker
(cid:140) DNSTools
(cid:140) Dupli Checker
(cid:140) evilacid.com
(cid:140) expandUrl
(cid:140) FreeDirectoryWebsites
(cid:140) GDPR Cookie Scan
(cid:140) GeekFlare
(cid:140) Hacker Target
(cid:140) HTTP Tools
(cid:140) httpstatus.io
H InsightVM
(cid:140) InternetMarketingNinjas
T
11
14
14
-
13
9
1
1
11
1
11
1
2
1
-
1
12
1
13
-
12
13
12
14
3
1
Name
V M
11 (cid:88) (cid:140) InternetOfﬁcer
(cid:140) [Anonymous]†
-
(cid:140) iplocation.net
-
(cid:140) IPv6 Scanner
-
(cid:140) itEXPERsT
-
-
H IVRE
(cid:140) JoydeepDeb
-
-
(cid:140) JSON Formatter
-
(cid:140) LucasZ ZeleznY
1 (cid:88) H Metasploit Pro
-
(cid:140) Monitor Backlinks
-
H Nessus
1 (cid:88) (cid:140) Nikto Online