7.4 Stream Cipher
Stream Cipher is a symmetric key cipher, whose basic feature is that the encrypting
and decrypting parties use a stream of keys of the same length as the plaintext, which
are combined with the plaintext stream to perform the encryption and decryption.
The key stream is usually a stream of bits generated by a pseudo-random number
generator of some deterministic state, and both parties use the seed of the pseudo-
random number generator as the key, while the combinatorial function is usually a
bit-wise XOR operation. The basic structure of a stream cipher is shown in Fig. 7.25.
Since the initialization of the pseudo-random number generator is a one-time
process and the generation of the key stream is a minor overhead, there is a speed
advantage of stream ciphers for processing longer plaintexts. Accordingly, the
security of the stream cipher depends almost entirely on the randomness of the
data generated by the pseudo-random number generator.
For a safe generator, the following characteristics are generally required.
• The period of the resulting random key stream is large enough.
The seeds are long enough to resist brute force attacks.
· A change of 1 position in the seed causes a dramatic change in sequence
(avalanche effect).
• The resulting key stream is resistant to statistical analysis, such as frequency
When obtaining a small number of key streams, it is not possible to restore the
analysis.
state of the entire generator.
In this section, we will introduce the common linear congruential generators in
CTFs, linear feedback shift registers, and RC4, a stream cipher algorithm based on
nonlinear array transformations.
Key
PRNG
Key Stream
Plaintext Stream
Ciphertext Stream
Fig, 7.25 Stream Cipher
---
## Page 596
584
7 Crypto
7.4.1Linear Congruential Generator(LCG)
Linear Congruential Generator (LCG) is a simple and easy to implement algorithm
LCG generates sequences that satisfy the following formula.
for generating sequences of random numbers from linear functions. The standard
Xe+1 = (Ax, + B)modM
where A, B, and M are constants, and an initial value xo is required as the seed.
From the above equation, it is obvious that the maximum period of the LCG is M.
7.4.1.1 Break LCGs with Known Sequences
In the case where M is known, since the equation of the LCG is a simple linear
relation, an equation for A and B can be created if two consecutive x, are obtained.
wpow(g + xv) = t+x
X j-1 = (Ax; + B)modM
So if we get two pairs of consecutive x, we can solve this equation set to solve for
parameters A and B.
If M is unknown, then we need at least 5 consecutive x
d, = Xe+1  Xa
dx+1 = Xn+2  Xx+1 = A(xx+1  xn) = Ad,modM
dn+2 = Xxe+3  Xxn+2 = A(x+2  xe+1) = Adn1 = A²d,modM
.'d,dn+2  d+1 = OmodM
So, if we have five or more consecutive x, we can find M by calculating greatest
common factors of the 4 formula above.
Example 7.3 VolgaCTF Quals 2015, this challenge provides an encryption script
and an encrypted PNG file. The encryption script is as follows.
dmport struct
import os
N = 65521
class LCG (1 :
def __init_
self.m =M
_ (self, s) :
(self.a, self.b, self.state) = struct .unpack [′= 6)
gamma = 1cg - generate_gamma (len (data) )
‘p.xo) deu * (eep *p.xo) dew) dfz u 6 *p xog (6 、 p) xuo] )uto[ , txmqax
gamma) )1)
def decrypt (ciphertext, key) :
return enczypt (ciphertext, key)
def sanity_check (1 :
# -..
if __nane__ "'_main_':
vith open (flag.png', * rb*) as f:
key = os.urandon [6)
data = f.read ()
enc_data = encrypt (data, key)
vith open ('flag.enc.bin', 'wb+') as f :
f.write (enc_data)
This script encrypts the flag-png file using a stream cipher.
stzuct ,pack (state;
goto fa11;
if (buf ->rand_type == TYPE_0) {
###x0  (52 + (15+251501 + [0] 95) ) - (9 2521
state[0] = val;
+result = val;
else 
As you can see, when using rand_type_0, a standard LCG algorithm is used:
s; = (1103515245 × 3;1 + 12345) mod  2147483648
---
## Page 600
588
7Crypto
Obviously, when one of the random numbers it produces is captured, it is possible to
predict all the random numbers. Since 1103515245 and 2147483648 are co-prime,
the inverse 1857678181 can be obtained, with
S1 = (x,  12345) × 1857678181mod  2147483648
This enables forward recovery of the random number sequence.
Because the security of this method is too weak, the srand() initialization function
provided in Glibc has abandoned TYPE_0 and uses TYPE_3 by default.
7.4.2LinearFeedback Shift Register(LFSR)
A Shift Register is a component commonly used in digital circuits to shift data from
randomness of the generated sequence signal is sufficiently strong, it can satisfy the
one location to the next, and is often used to generate serial signals. When the
need of keystream in stream cipher. The Linear Feedback Shift Register (LFSR),
which is commonly used in cryptography, consists of a shift register and a feedback
function, where the feedback function is a linear function. When performing
keystream generation, one bit at a time is shifted out of the shift register as the
current result, and the shifted-in bits are determined by the feedback function that
depends on certain bits in the register. The basic structure of the LFSR is shown in
Fig. 7.27.
In order to obtain the maximum period of the LFSR, i.e., 2n-1 for the n-bit LFSR,
ouod jeuguo -u ue :em umoo o u uasoo s!  uooung xorqpog 
on GF(2) is chosen. For example, when n=32,
x² + x” + x + x² + x² + x + 1
Then the F function can be obtained as
F=
Fig, 7.27 Linear feedback
shift register
---
## Page 601
7.4  Stream Cipher
589
That is, the feedback bits are generated by the XOR result of the 32nd, 7th, 5th, 3rd,
2nd, and 1st bits of the register. These bits are called taps and the sequence with the
Iargest period is called an m-sequence.
7.4.2.1 Break the LFSR with Known Sequences
Suppose the length of LFSR is n bits, when its output of length 2n is known, if the
equation group has a solution, the feedback function of LFSR can be completely
obtained by solving the linear equation group, so as to break LFSR. For example,
consider an unknown 4-bit LFSR, and we have an output sequence of 10001010, and
since XOR is equivalent to modulo-2 addition, the following linear equation group
can be listed.
 po 1 = f∞0 + 0 + 1 + 1
Og + 0; + 0 + 1a = 0 mod 2
Og + 0α + 1a + 0 = 1 mod 2
(o + 1α + 0α + 1a = 0 mod 2
Solving the equation group, we have
a = 1
Ω = 0
Ω; = 1
( a = 0
Then, the feedback function can be obtained as.
F =so
Thus, the sequence of the LFSR can be predicted.
7.4.2.2 Breaking Linux Glibc's RandO Function-2
The other part of the rando function is implemented as follows.
int randon_r (stzuct random_data *buf, int32_t *result) {
int32_t *state;
if (buf == NULL II result == NULL)
 goto fai1;
state = buf->state;
/ * TYPE_O */
---
## Page 602
590
7 Crypto
else 
int32_t *fptr = buf ->fptr;
int32_t *rptr = buf ->rptr ;
int32_t *end_ptr = buf ->end_ptr;
xdx (zeun) =+ xdg+ = teA
uint32_t val;
/+ Chucking least random bit +/
+result = val >> 1;
if (fptr >= end_ptr) {
++fptr;
fptr = state;
++rptr;
else {
if (rptr >= end_ptr)
++xptr;
rptr = state;
buf->fptr = fptr;
buf ->#ptr = rpt;
return 0 ;
fail :
_set_errno (EINVAL) ;
return -1;
This method of generating the next random number is achieved by adding the
numbers in the state array according to fptr and rptr and dividing them by two, much
like the linear feedback method. In the case of TYPE_3, the length of the state array
is 344, and fptr and rptr are the current index minus 31 and the current index minus
3, respectively, so the function for generating the next random number is actually a
linear feedback cquation as follows.
2
Note that the number shifted into the state array is not the generated random number,
but the number before right shifting 1 bit, so the last bit can be either 0 or 1. There-
fore, after we get 32 random numbers, the next number we predict will have an error
of 1 with a 25% probability, and the error will increase as the number of predictions
increases. However, in most cases it is not necessary to predict too much, so an error
of 1 is sufficient, and if we can continue to get random numbers, we can make
corrections as we predict to reduce the error.
The folowing is a simple demo for correcting random numbers while making
predictions.
---
## Page 603
7.4  Stream Cipher
591
#include 
#include 
#include 
int main (1 {
int s[256] = {0}, 1 = 0;
srand (time (o)) ;
for (1 = 0; 1 > 1;
int yy = rand (1;
printf (*predicted td, actual $d’,n", xx, yy) ;
f (yy - xx == 1) (
[1 -3] ++ ;
s [1 -31] ++ ;
s[1] += 2;
return 0 ;
7.4.3RC4
RC4 is a special stream cipher, proposed by Ronald Rivest in 1987, and is used in
Wired Equivalent Privacy (WEP), which was once one of the algorithms in TLS.
RC4 uses a 0-255 bit key to generate a stream key, which is then XORed with the
plaintext to generate a ciphertext. The RC4 algorithm is very widely used because of
its strength and high computational efficiency.
The pseudo-code (from Wikipedia) of the RC4 algorithm is as follows. The first
step is KSA (Key-Scheduling Algorithm), where the state array S is initialized
according to the input key.
for i from 0 to 255
endfor
s[i] := 1
J := 0
for ( i=0 ; 1<256 ; 1++)
 : = (j + S[1] + key [1 mod keylength] ) $ 256
svap values of s [1] and s[j]
endfor
The second step is PRGA (Pseudo-Random Generation Algorithm), where the
state array is modified and generate one byte of the keystream. Finally, we the
keystream is XORed with the plaintext to generate ciphertext.
---
## Page 604
592
7 Crypto
J := 0
1 : = 0
while GeneratingOutput:
j := (j + s[1]) mod 256
1 := (1 + 1) mod 256
/ / a
svap values of s[1] and s [j]
/ / b
k := S[{s [1] + s[j1] $ 256]
/ / c
output K
endwhile
Since RC4 is a stream cipher algorithm, it'’s also vulnerable to known plaintext
attacks. If a certain key is used to encrypt n bytes of data and the plaintext is known,
the n-byte stream key can be recovered; if this key is reused, we can then decrypt
other ciphertext. During the actual atack, known plaintext attacks are often used in
case some part of the ciphertext is predictable, such as the header of an HTTP
message.
In particular, when the input key is [0, 0, 255, 254, 253, ., 2], KSA modifies S
into [0, 1, 2, ., 255], then the output stream key is S[(2*i) % 256] with a very short
repetition period. Besides, there are also other weak keys for RC4, which can also
generate short period stream keys. So when using the RC4 algorithm in practice, it is
necessary to check the keys in advance.
7.5 Public Key Cryptography
7.5.1Introduction toPublicKey Cryptography
Since the introduction of the Kirchhoff principle and symmetric cryptosystems,
cryptography has entered the modern cryptographic phase. While mature block
ciphers and stream ciphers have excellent encryption strength and efficiency, sym-
metric cryptosystems have a problem that cannot be ignored  the transmission of a
key requires a secure channel, otherwise symmetric cryptosystems are not secure if
jo qod o os you op sssodo os uoe u p si oy o
authentication and non-repudiation of information. Based on these facts, in 1976
Whitfield Diffie and Martin Hellman published their landmark article New directions
in crypfography, which laid the foundation for public-key cryptosystems, and in
1977 Ron Rivest, Adi Shamir and Leonard Adleman invented a public-key crypto-
graphic algorithm, RSA, that is still widely used today.
Public Key Cryptography, also known as asymmetric cryptography, is character-
ized by the fact that encryption and decryption no longer use the same key. The user
will make one key public and keep the other private, and these two keys are called
public and private keys. When the sender of a message chooses to encrypt it with the
receiver’s public key, the receiver receives the message and decrypts it with his
private key, thus maintaining the confidentiality of the message; if the sender sign
the message with his private key and the receiver verifies the digest with the sender’s
---
## Page 605
7.5 Public Key Cryptography
593
public key, this serves as a signature and ensures the authentication and
non-repudiation of the message.
The common public-key cryptographic algorithm used in CTF is the RSA
algorithm, which is the basic knowledge that CTF participants must have, and
CTF also involves some cryptosystems related to discrete logarithms and ellitic
curves.