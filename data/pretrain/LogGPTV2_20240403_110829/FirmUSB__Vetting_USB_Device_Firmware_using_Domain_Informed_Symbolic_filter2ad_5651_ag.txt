以下是优化后的文本，使其更加清晰、连贯和专业：

---

### 参考文献

[13] Matthew Brocker 和 Stephen Checkoway. 2014. iSeeYou: 禁用 MacBook 摄像头指示灯. 在第 23 届 USENIX 安全研讨会 (USENIX Security 14) 上发表, 页码 337-352.

[14] Jacob Burnim 和 Koushik Sen. 2008. 可扩展动态测试生成的启发式方法. 在第 23 届 IEEE/ACM 自动化软件工程国际会议 (ASE 2008) 上发表, 日期为 2008 年 9 月 15 日至 19 日, 地点为意大利拉奎拉, 页码 443-446.

[15] Kevin Butler, Stephen McLaughlin 和 Patrick McDaniel. 2010. Kells: 便携数据保护框架. 在第 26 届年度计算机安全应用大会 (ACSAC) 上发表, 地点为美国德克萨斯州奥斯汀.

[16] Cristian Cadar, Daniel Dunbar 和 Dawson Engler. 2008. KLEE: 复杂系统程序的无辅助自动高覆盖率测试生成. 在第 8 届 USENIX 操作系统设计与实现会议上发表 (OSDI'08), 页码 209-224.

[17] Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, David L. Dill 和 Dawson R. Engler. 2006. EXE: 自动生成致命输入. 在第 13 届 ACM 计算机和通信安全会议上发表 (CCS '06), 页码 322-335.

[18] Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert 和 David Brumley. 2012. 在二进制代码上释放 Mayhem. 在 2012 年 IEEE 安全与隐私研讨会上发表 (SP '12), 页码 380-394.

[19] Marek Chalupa. 2017. LLVM DependenceGraph. https://github.com/mchalupa/dg.

[20] Geoff Chappell. 2007. America Online 利用自己的软件漏洞. http://geoffchappell.com/notes/security/aim/index.htm. (2007).

[21] Geoff Chappell. 2013. (s)elf-exploitation. http://www.gamasutra.com/view/feature/194772/dirty_game_development_tricks.php. (2013).

[22] Avik Chaudhuri 和 Jeffrey S. Foster. 2010. Ruby-on-Rails Web 应用程序的符号安全分析. 在第 17 届 ACM 计算机和通信安全会议上发表 (CCS '10), 页码 585-594.

[23] D. D. Chen, M. Egele, M. Woo 和 D. Brumley. 2016. 面向 Linux 基于嵌入式固件的自动化动态分析. 在 ISOC 网络与分布式系统研讨会 (NDSS) 上发表 (2016).

[24] Vitaly Chipounov, Volodymyr Kuznetsov 和 George Candea. 2011. S2E: 软件系统的多路径在体分析平台. SIGPLAN Not. 47, 4 (2011 年 3 月), 页码 265-278.

[25] Liviu Ciortea, Cristian Zamfir, Stefan Bucur, Vitaly Chipounov 和 George Candea. 2010. Cloud9: 一个软件测试服务. SIGOPS Oper. Syst. Rev. 43, 4 (2010 年 1 月), 页码 5-10.

[26] Ricardo Corin 和 Felipe Andrés Manzano. 2012. KLEE 符号执行引擎中的安全代码污点分析. 在第 14 届国际信息和通信安全会议上发表 (ICICS'12), 页码 264-275.

[27] Andrei Costin, Jonas Zaddach, Aurélien Francillon 和 Davide Balzarotti. 2014. 嵌入式固件的大规模安全性分析. 在第 23 届 USENIX 安全研讨会 (SEC'14) 上发表.

[28] Drew Davidson, Benjamin Moench, Thomas Ristenpart 和 Somesh Jha. 2013. 使用符号执行查找嵌入式系统中的漏洞. 在第 22 届 USENIX 安全研讨会 (USENIX Security 13) 上发表, USENIX, 华盛顿特区, 页码 463-478. https://www.usenix.org/conference/usenixsecurity13/technical-sessions/paper/davidson

[29] Alessandro Di Federico, Mathias Payer 和 Giovanni Agosta. 2017. Rev.Ng: 用于恢复 CFG 和函数边界的统一二进制分析框架. 在第 26 届编译器构造国际会议 (CC 2017) 上发表. ACM, 纽约, 美国, 页码 131-141. https://doi.org/10.1145/3033019.3033028

[30] Sinan Adnan Diwan, Sundresan Perumal 和 Ammar J Fatah. 2014. USB 拇指驱动器的完整安全包. 计算机工程与智能系统 5, 8 (2014), 页码 30-37.

[31] Nicolas Falliere, Liam O Murchu 和 Eric Chien. 2011. W32. Stuxnet 报告.

[32] Patrice Godefroid, Michael Y. Levin 和 David A. Molnar. 2008. 自动化白盒模糊测试. 在网络与分布式系统安全研讨会 (NDSS 2008) 上发表, 地点为美国加利福尼亚州圣迭戈, 日期为 2008 年 2 月 10 日至 13 日.

[33] Arie Gurfinkel, Temesghen Kahsai, Anvesh Komuravelli 和 Jorge A. Navas. 2015. SeaHorn 验证框架. 在计算机辅助验证 - 第 27 届国际会议 (CAV 2015) 上发表, 地点为美国旧金山, 日期为 2015 年 7 月 18 日至 24 日, 页码 343-361.

[34] Julien Henry, David Monniaux 和 Matthieu Moy. 2012. PAGAI: 路径敏感静态分析器. 电子笔记理论计算机科学 289 (2012 年 12 月).

[35] James C. King. 1976. 符号执行与程序测试. Commun. ACM 19, 7 (1976 年 7 月).

(2011).

Lang. Syst. 35, 1 (2013 年 4 月).

[38] Joseph P. Near 和 Daniel Jackson. 2014. Derailer: Web 应用程序的交互式安全分析. 在第 29 届 ACM/IEEE 自动化软件工程国际会议上发表 (ASE '14), 页码 587-598.

[39] Joseph P. Near 和 Daniel Jackson. 2016. 使用访问控制模式目录查找 Web 应用程序中的安全漏洞. 在第 38 届国际软件工程会议上发表 (ICSE '16), 页码 947-958.

[40] Nicholas Nethercote 和 Julian Seward. 2007. Valgrind: 一个重量级的动态二进制插桩框架. 在 ACM Sigplan 通知, 卷 42. ACM, 页码 89-100.

[41] Karsten Nohl 和 Jakob Lell. 2014. BadUSB–邪恶的配件. Black Hat USA (2014).

turnipschool. (2015).

[42] NSA. 2015. TURNIPSCHOOL - NSA Playset. http://www.nsaplayset.org/

[43] V. A. Padaryan, V. V. Kaushan 和 A. N. Fedotov. 2015. 栈缓冲区溢出漏洞的自动化利用生成. Program. Comput. Softw. 41, 6 (2015 年 11 月), 页码 373-380.

[44] Pancake. 2017. Radare 2. https://github.com/radare/radare2. (2017).

[45] Dung Vu Pham, Malka N Halgamuge, Ali Syed 和 Priyan Mendis. 2010. 优化 Windows 安全特性以阻止 USB 存储设备上的恶意软件和黑客工具. 在电磁研究进展研讨会上发表.

[46] Sergej Schumilo, Ralf Spenneberg 和 Hendrik Schwartke. 2014. 不要信任你的 USB! 如何在 USB 设备驱动程序中找到漏洞. 在 Blackhat Europe 上发表.

[47] Seungwon Shin 和 Guofei Gu. 2010. Conficker 及其后: 大规模实证研究. 在第 26 届年度计算机安全应用大会 (ACSAC '10) 上发表. ACM, 纽约, 美国, 页码 151-160. https://doi.org/10.1145/1920261.1920285

[48] Yan Shoshitaishvili, Ruoyu Wang, Christophe Hauser, Christopher Kruegel 和 Giovanni Vigna. 2015. Firmalice - 二进制固件中的自动检测认证绕过漏洞. 在 NDSS 上发表.

[49] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino, Andrew Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel 和 Giovanni Vigna. 2016. SoK: (状态) 攻击的艺术: 二进制分析中的进攻技术. 在 IEEE 安全与隐私研讨会上发表.

[50] Dawn Song, David Brumley, Heng Yin, Juan Caballero, Ivan Jager, Min Gyung Kang, Zhenkai Liang, James Newsome, Pongsin Poosankam 和 Prateek Saxena. 2008. BitBlaze: 通过二进制分析的新计算机安全方法. 在第 4 届国际信息系统安全会议上发表 (ICISS '08), 页码 1-25.

[51] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang, Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel 和 Giovanni Vigna. 2016. Driller: 通过选择性符号执行增强模糊测试. 在 NDSS 上发表.

[52] Yulei Sui 和 Jingling Xue. 2016. SVF: LLVM 中的过程间静态值流分析. 在第 25 届编译器构造国际会议上发表, CC 2016, 西班牙巴塞罗那, 日期为 2016 年 3 月 12 日至 18 日, 页码 265-266.

[53] A. Tetmeyer 和 H. Saiedian. 2010. USB 设备的安全威胁及风险缓解. 技术与社会杂志, IEEE 29, 4 (2010 年冬季), 页码 44-49. https://doi.org/10.1109/MTS.2010.939228

[54] Aditya V. Thakur, Junghee Lim, Akash Lal, Amanda Burton, Evan Driscoll, Matt Elder, Tycho Andersen 和 Thomas W. Reps. 2010. 机器代码的定向证明生成. 在计算机辅助验证, 第 22 届国际会议 (CAV 2010) 上发表, 地点为英国爱丁堡, 日期为 2010 年 7 月 15 日至 19 日, 页码 288-305.

[55] Dave Jing Tian, Adam Bates 和 Kevin Butler. 2015. 通过 GoodUSB 防御恶意 USB 固件. 在第 31 届年度计算机安全应用大会上发表 (ACSAC).

[56] Dave Jing Tian, Adam Bates, Kevin Butler 和 Raju Rangaswami. 2016. ProvUSB: 基于块级来源的 USB 存储设备数据保护. 在第 23 届 ACM 计算机和通信安全会议上发表 (CCS'16). 奥地利维也纳.

[57] Dave Jing Tian, Nolen Scaife, Adam Bates, Kevin R.B. Butler 和 P. Traynor. 2016. 通过 USBFILTER 使 USB 再次伟大. 在 2016 年 USENIX 安全研讨会上发表. 美国德克萨斯州奥斯汀.

[58] Matthew Tischer, Zakir Durumeric, Sam Foster, Sunny Duan, Alec Mori, Elie Bursztein 和 Michael Bailey. 2016. 用户确实会插入他们找到的 USB 驱动器. 在 2016 年 IEEE 安全与隐私研讨会上发表. IEEE, 页码 306-319.

[59] Anjo Vahldiek-Oberwagner, Eslam Elnikety, Aastha Mehta, Deepak Garg, Peter Druschel, Rodrigo Rodrigues, Johannes Gehrke 和 Ansley Post. 2015. Guardat: 在存储层强制执行数据策略. 在第十届欧洲计算机系统会议上发表. ACM, 页码 13.

[60] Vector35. 2015. Binary Ninja. https://binary.ninja/. (2015).

[61] Jim Walter. 2012. "Flame Attacks": 简报和妥协指标. McAfee Labs 报告 (2012 年 5 月).

[36] Volodymyr Kuznetsov, Vitaly Chipounov 和 George Candea. 2010. 使用 DDT 测试封闭源二进制设备驱动程序. 在 2010 年 USENIX 年度技术会议上发表 (USENIXATC'10), 页码 12-12.

[37] Junghee Lim 和 Thomas Reps. 2013. TSL: 生成抽象解释器的系统及其在机器代码分析中的应用. ACM Trans. Program. Lang. Syst. 35, 1 (2013 年 4 月).

[62] Zhaohui Wang 和 Angelos Stavrou. 2010. 利用智能手机 USB 连接的乐趣与利润. 在第 26 届年度计算机安全应用大会 (ACSAC '10) 上发表.

[63] John Wharton. 1980. Intel-MCS-51 单芯片微控制器家族简介. 英特尔公司 (1980).

16
[64] Babak Yadegari 和 Saumya Debray. [n.d.]. 混淆代码的符号执行. 在第 22 届 ACM SIGSAC 计算机和通信安全会议上发表 (2015) (CCS '15). ACM, 页码 732-744. https://doi.org/10.1145/2810103.2813663

[65] Babak Yadegari 和 Saumya Debray. 2015. 混淆代码的符号执行. 在第 22 届 ACM SIGSAC 计算机和通信安全会议上发表 (CCS '15), 页码 732-744.

[66] Bo Yang, Dengguo Feng, Yu Qin, Yingjun Zhang 和 Weijin Wang. 2015. TMSUI: 工业控制系统中 USB 存储设备的信任管理方案. 密码学 ePrint 档案, 报告 2015/022. (2015). http://eprint.iacr.org/

[67] Jonas Zaddach, Luca Bruno, Aurélien Francillon 和 Davide Balzarotti. 2014. AVATAR: 一个支持嵌入式系统固件动态安全分析的框架. 在第 21 届年度网络与分布式系统安全研讨会 (NDSS 2014) 上发表, 地点为美国加利福尼亚州圣迭戈, 日期为 2014 年 2 月 23 日至 26 日.

17
附录

}
}
inject_start = TRUE ;
if (! inject_start ) {
inject_counter ++;
if ( inject_counter > ATTACK_THRESHOLD ) {
清单 1 类似于添加到 EzHID 的最小注入代码片段。in1_buffer 是在查询 2 完成后将被标记为不一致的内容。省略了其他处理器细节。
1 static void timer2_isr ()
2 {
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }
memcpy (in1_buffer, key_script , sizeof ( firmusb_script ));
in1_busy = TRUE ;
inject_start = FALSE ;
// 来自 I/O 端口的正常键盘数据
memcpy (in1_buffer, key_buffer , kbd_num_bytes );
in1_busy = TRUE ;
// 来自数据段的静态按键
if ( inject_start ) {
if (! in1_busy ) {
if (! in1_busy ) {
if ( kbd_data ) {
}
}
}
}
. idVendor = ( vend ), \
. idProduct = ( prod )
. idVendor = ( vend ), \
. idProduct = ( prod ), \
. bInterfaceClass = ( cl )
. idVendor = ( vend ), \
. idProduct = ( prod ), \
. bcdDevice_lo = ( lo ), \
. bcdDevice_hi = ( hi )
清单 2 USBDB 实现了总共 10 个匹配规则。所有这些规则都是直接从 Linux 内核 4.9 源文件中提取的, 反映了现实世界的 USB 设备匹配。
1 /* https :// lxr . missinglinkelectronics . com / linux + v4 .9/ include / linux / usb .h# L853 */
2 # define USB_DEVICE_ID_MATCH_DEVICE ( USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT )
3 # define USB_DEVICE_ID_MATCH_DEV_RANGE ( USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI )
4 # define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION ( USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE )
5 # define USB_DEVICE_ID_MATCH_DEV_INFO ( USB_DEVICE_ID_MATCH_DEV_CLASS | USB_DEVICE_ID_MATCH_DEV_SUBCLASS | USB_DEVICE_ID_MATCH_DEV_PROTOCOL )
6 # define USB_DEVICE_ID_MATCH_INT_INFO ( USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS | USB_DEVICE_ID_MATCH_INT_PROTOCOL )
7
8 # define USB_DEVICE ( vend , prod ) . match_flags = USB_DEVICE_ID_MATCH_DEVICE , \
9
10
11
12 # define USB_DEVICE_VER ( vend , prod , lo , hi ) . match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION , \
13
14
15
16
17
18 # define USB_DEVICE_INTERFACE_CLASS ( vend , prod , cl ) . match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_CLASS , \
19
20
21
22
23 # define USB_DEVICE_INTERFACE_PROTOCOL ( vend , prod , pr ) . match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_PROTOCOL , \
24
25
26
27
28 # define USB_DEVICE_INTERFACE_NUMBER ( vend , prod , num ) . match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_NUMBER , \
29
30
31
32
33 # define USB_DEVICE_INFO (cl , sc , pr ) . match_flags = USB_DEVICE_ID_MATCH_DEV_INFO , \
34
35
36
37
38 # define USB_INTERFACE_INFO (cl , sc , pr ) . match_flags = USB_DEVICE_ID_MATCH_INT_INFO , \
39
40
41
42
43 # define USB_DEVICE_AND_INTERFACE_INFO ( vend , prod , cl , sc , pr ) . match_flags = USB_DEVICE_ID_MATCH_INT_INFO | USB_DEVICE_ID_MATCH_DEVICE , \
44
45
46
47
48
49
50 # define USB_VENDOR_AND_INTERFACE_INFO ( vend , cl , sc , pr ) . match_flags = USB_DEVICE_ID_MATCH_INT_INFO | USB_DEVICE_ID_MATCH_VENDOR , \
51
52
53
54
55
56 # define USUAL_DEV ( useProto , useTrans ) { USB_INTERFACE_INFO ( USB_CLASS_MASS_STORAGE , useProto , useTrans ) }
. idVendor = ( vend ), \
. idProduct = ( prod ), \
. bInterfaceClass = ( cl ), \
. bInterfaceSubClass = ( sc ), \
. bInterfaceProtocol = ( pr )
. idVendor = ( vend ), \
. bInterfaceClass = ( cl ), \
. bInterfaceSubClass = ( sc ), \
. bInterfaceProtocol = ( pr )
. bInterfaceClass = ( cl ), \
. bInterfaceSubClass = ( sc ), \
. bInterfaceProtocol = ( pr )
. idVendor = ( vend ), \
. idProduct = ( prod ), \
. bInterfaceProtocol = ( pr )
. bDeviceClass = ( cl ), \
. bDeviceSubClass = ( sc ), \
. bDeviceProtocol = ( pr )
. idVendor = ( vend ), \
. idProduct = ( prod ), \
. bInterfaceNumber = ( num )

18

---

希望这些修改能够帮助你更好地理解和使用这些参考文献。