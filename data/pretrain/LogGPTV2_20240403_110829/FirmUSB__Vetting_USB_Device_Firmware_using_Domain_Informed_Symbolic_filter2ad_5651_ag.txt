and theory of computation. USENIX; login 36, 6 (2011).
[13] Matthew Brocker and Stephen Checkoway. 2014. iSeeYou: Disabling the MacBook
webcam indicator LED. In 23rd USENIX Security Symposium (USENIX Security
14). 337–352.
[14] Jacob Burnim and Koushik Sen. 2008. Heuristics for Scalable Dynamic Test
Generation. In 23rd IEEE/ACM International Conference on Automated Software
Engineering (ASE 2008), 15-19 September 2008, L’Aquila, Italy. 443–446.
[15] Kevin Butler, Stephen McLaughlin, and Patrick McDaniel. 2010. Kells: A Protec-
tion Framework for Portable Data. In Proceedings of the 26th Annual Computer
Security Applications Conference (ACSAC). Austin, TX, USA.
[16] Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted and
Automatic Generation of High-coverage Tests for Complex Systems Programs.
In Proceedings of the 8th USENIX Conference on Operating Systems Design and
Implementation (OSDI’08). 209–224.
[17] Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, David L. Dill, and Dawson R.
Engler. 2006. EXE: Automatically Generating Inputs of Death. In Proceedings of
the 13th ACM Conference on Computer and Communications Security (CCS ’06).
322–335.
[18] Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David Brumley. 2012.
Unleashing Mayhem on Binary Code. In Proceedings of the 2012 IEEE Symposium
on Security and Privacy (SP ’12). 380–394.
[19] Marek Chalupa. 2017. LLVM DependenceGraph. https://github.com/mchalupa/dg.
[20] Geoff Chappell. 2007. America Online Exploits Bug In Own Software. http:
//geoffchappell.com/notes/security/aim/index.htm. (2007).
[21] Geoff Chappell. 2013.
(s)elf-exploitation. http://www.gamasutra.com/view/
feature/194772/dirty_game_development_tricks.php. (2013).
[22] Avik Chaudhuri and Jeffrey S. Foster. 2010. Symbolic Security Analysis of Ruby-
on-rails Web Applications. In Proceedings of the 17th ACM Conference on Computer
and Communications Security (CCS ’10). 585–594.
[23] D D Chen, M Egele, M Woo, and D Brumley. 2016. Towards Automated Dynamic
Analysis for Linux-based Embedded Firmware. Proceedings of the ISOC Network
and Distributed Systems Symposium (NDSS) (2016).
[24] Vitaly Chipounov, Volodymyr Kuznetsov, and George Candea. 2011. S2E: A
Platform for In-vivo Multi-path Analysis of Software Systems. SIGPLAN Not. 47,
4 (March 2011), 265–278.
[25] Liviu Ciortea, Cristian Zamfir, Stefan Bucur, Vitaly Chipounov, and George
Candea. 2010. Cloud9: A Software Testing Service. SIGOPS Oper. Syst. Rev. 43, 4
(Jan. 2010), 5–10.
[26] Ricardo Corin and Felipe Andrés Manzano. 2012. Taint Analysis of Security Code
in the KLEE Symbolic Execution Engine. In Proceedings of the 14th International
Conference on Information and Communications Security (ICICS’12). 264–275.
[27] Andrei Costin, Jonas Zaddach, Aurélien Francillon, and Davide Balzarotti. 2014.
A Large-scale Analysis of the Security of Embedded Firmwares. In Proceedings of
the 23rd USENIX Conference on Security Symposium (SEC’14).
[28] Drew Davidson, Benjamin Moench, Thomas Ristenpart, and Somesh Jha. 2013.
FIE on Firmware: Finding Vulnerabilities in Embedded Systems Using Sym-
bolic Execution. In Presented as part of the 22nd USENIX Security Symposium
(USENIX Security 13). USENIX, Washington, D.C., 463–478. https://www.usenix.
org/conference/usenixsecurity13/technical-sessions/paper/davidson
[29] Alessandro Di Federico, Mathias Payer, and Giovanni Agosta. 2017. Rev.Ng: A
Unified Binary Analysis Framework to Recover CFGs and Function Boundaries. In
Proceedings of the 26th International Conference on Compiler Construction (CC 2017).
ACM, New York, NY, USA, 131–141. https://doi.org/10.1145/3033019.3033028
[30] Sinan Adnan Diwan, Sundresan Perumal, and Ammar J Fatah. 2014. Complete
security package for USB thumb drive. Computer Engineering and Intelligent
Systems 5, 8 (2014), 30–37.
[31] Nicolas Falliere, Liam O Murchu, and Eric Chien. 2011. W32. Stuxnet Dossier.
[32] Patrice Godefroid, Michael Y. Levin, and David A. Molnar. 2008. Automated
Whitebox Fuzz Testing. In Proceedings of the Network and Distributed System
Security Symposium, NDSS 2008, San Diego, California, USA, 10th February - 13th
February 2008.
[33] Arie Gurfinkel, Temesghen Kahsai, Anvesh Komuravelli, and Jorge A. Navas.
2015. The SeaHorn Verification Framework. In Computer Aided Verification -
27th International Conference, CAV 2015, San Francisco, CA, USA, July 18-24, 2015,
Proceedings, Part I. 343–361.
[34] Julien Henry, David Monniaux, and Matthieu Moy. 2012. PAGAI: A Path Sensitive
Static Analyser. Electron. Notes Theor. Comput. Sci. 289 (Dec. 2012).
[35] James C. King. 1976. Symbolic Execution and Program Testing. Commun. ACM
19, 7 (July 1976).
(2011).
Lang. Syst. 35, 1 (April 2013).
[38] Joseph P. Near and Daniel Jackson. 2014. Derailer: Interactive Security Anal-
ysis for Web Applications. In Proceedings of the 29th ACM/IEEE International
Conference on Automated Software Engineering (ASE ’14). 587–598.
[39] Joseph P. Near and Daniel Jackson. 2016. Finding Security Bugs in Web Appli-
cations Using a Catalog of Access Control Patterns. In Proceedings of the 38th
International Conference on Software Engineering (ICSE ’16). 947–958.
[40] Nicholas Nethercote and Julian Seward. 2007. Valgrind: a framework for heavy-
weight dynamic binary instrumentation. In ACM Sigplan notices, Vol. 42. ACM,
89–100.
[41] Karsten Nohl and Jakob Lell. 2014. BadUSB–On accessories that turn evil. Black
Hat USA (2014).
turnipschool. (2015).
[42] NSA. 2015. TURNIPSCHOOL - NSA Playset. http://www.nsaplayset.org/
[43] V. A. Padaryan, V. V. Kaushan, and A. N. Fedotov. 2015. Automated Exploit
Generation for Stack Buffer Overflow Vulnerabilities. Program. Comput. Softw.
41, 6 (Nov. 2015), 373–380.
[44] Pancake. 2017. Radare 2. https://github.com/radare/radare2. (2017).
[45] Dung Vu Pham, Malka N Halgamuge, Ali Syed, and Priyan Mendis. 2010. Opti-
mizing Windows Security Features to Block Malware and Hack Tools on USB
Storage Devices. In Progress in Electromagnetics Research Symposium.
[46] Sergej Schumilo, Ralf Spenneberg, and Hendrik Schwartke. 2014. Don’t trust
your USB! How to find bugs in USB device drivers. In Blackhat Europe.
[47] Seungwon Shin and Guofei Gu. 2010. Conficker and Beyond: A Large-scale
Empirical Study. In Proceedings of the 26th Annual Computer Security Applications
Conference (ACSAC ’10). ACM, New York, NY, USA, 151–160. https://doi.org/10.
1145/1920261.1920285
[48] Yan Shoshitaishvili, Ruoyu Wang, Christophe Hauser, Christopher Kruegel, and
Giovanni Vigna. 2015. Firmalice - Automatic Detection of Authentication Bypass
Vulnerabilities in Binary Firmware. In NDSS.
[49] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino,
Andrew Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel,
and Giovanni Vigna. 2016. SoK: (State of) The Art of War: Offensive Techniques
in Binary Analysis. In IEEE Symposium on Security and Privacy.
[50] Dawn Song, David Brumley, Heng Yin, Juan Caballero, Ivan Jager, Min Gyung
Kang, Zhenkai Liang, James Newsome, Pongsin Poosankam, and Prateek Saxena.
2008. BitBlaze: A New Approach to Computer Security via Binary Analysis. In
Proceedings of the 4th International Conference on Information Systems Security
(ICISS ’08). 1–25.
[51] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In
NDSS.
[52] Yulei Sui and Jingling Xue. 2016. SVF: interprocedural static value-flow anal-
ysis in LLVM. In Proceedings of the 25th International Conference on Compiler
Construction, CC 2016, Barcelona, Spain, March 12-18, 2016. 265–266.
[53] A. Tetmeyer and H. Saiedian. 2010. Security Threats and Mitigating Risk for
USB Devices. Technology and Society Magazine, IEEE 29, 4 (winter 2010), 44–49.
https://doi.org/10.1109/MTS.2010.939228
[54] Aditya V. Thakur, Junghee Lim, Akash Lal, Amanda Burton, Evan Driscoll, Matt
Elder, Tycho Andersen, and Thomas W. Reps. 2010. Directed Proof Generation
for Machine Code. In Computer Aided Verification, 22nd International Conference,
CAV 2010, Edinburgh, UK, July 15-19, 2010. Proceedings. 288–305.
[55] Dave Jing Tian, Adam Bates, and Kevin Butler. 2015. Defending Against Malicious
USB Firmware with GoodUSB. In Proceedings of the 31st Annual Computer Security
Applications Conference (ACSAC).
[56] Dave Jing Tian, Adam Bates, Kevin Butler, and Raju Rangaswami. 2016. ProvUSB:
Block-level Provenance-Based Data Protection for USB Storage Devices. In Pro-
ceedings of the 23rd ACM Conference on Computer and Communications Security
(CCS’16). Vienna, Austria.
[57] Dave Jing Tian, Nolen Scaife, Adam Bates, Kevin R.B. Butler, and P. Traynor. 2016.
Making USB great again with USBFILTER. In Proceedings of the 2016 USENIX
Security Symposium. Austin, TX, USA.
[58] Matthew Tischer, Zakir Durumeric, Sam Foster, Sunny Duan, Alec Mori, Elie
Bursztein, and Michael Bailey. 2016. Users really do plug in USB drives they find.
In Security and Privacy (SP), 2016 IEEE Symposium on. IEEE, 306–319.
[59] Anjo Vahldiek-Oberwagner, Eslam Elnikety, Aastha Mehta, Deepak Garg, Peter
Druschel, Rodrigo Rodrigues, Johannes Gehrke, and Ansley Post. 2015. Guardat:
Enforcing data policies at the storage layer. In Proceedings of the Tenth European
Conference on Computer Systems. ACM, 13.
[60] Vector35. 2015. Binary Ninja. https://binary.ninja/. (2015).
[61] Jim Walter. 2012. "Flame Attacks": Briefing and Indicators of Compromise. McAfee
Labs Report (May 2012).
[36] Volodymyr Kuznetsov, Vitaly Chipounov, and George Candea. 2010. Testing
Closed-source Binary Device Drivers with DDT. In Proceedings of the 2010 USENIX
Conference on USENIX Annual Technical Conference (USENIXATC’10). 12–12.
[37] Junghee Lim and Thomas Reps. 2013. TSL: A System for Generating Abstract
Interpreters and Its Application to Machine-Code Analysis. ACM Trans. Program.
[62] Zhaohui Wang and Angelos Stavrou. 2010. Exploiting Smart-phone USB Con-
nectivity for Fun and Profit. In Proceedings of the 26th Annual Computer Security
Applications Conference (ACSAC ’10).
[63] John Wharton. 1980. An Introduction to the Intel-MCS-51 Single-Chip Micro-
computer Family. Intel Corporation (1980).
16
[64] Babak Yadegari and Saumya Debray. [n. d.]. Symbolic Execution of Obfuscated
Code. In Proceedings of the 22Nd ACM SIGSAC Conference on Computer and
Communications Security (2015) (CCS ’15). ACM, 732–744. https://doi.org/10.
1145/2810103.2813663
[65] Babak Yadegari and Saumya Debray. 2015. Symbolic Execution of Obfuscated
Code. In Proceedings of the 22Nd ACM SIGSAC Conference on Computer and
Communications Security (CCS ’15). 732–744.
[66] Bo Yang, Dengguo Feng, Yu Qin, Yingjun Zhang, and Weijin Wang. 2015. TMSUI:
A Trust Management Scheme of USB Storage Devices for Industrial Control
Systems. Cryptology ePrint Archive, Report 2015/022. (2015). http://eprint.iacr.
org/.
[67] Jonas Zaddach, Luca Bruno, Aurélien Francillon, and Davide Balzarotti. 2014.
AVATAR: A Framework to Support Dynamic Security Analysis of Embedded
Systems’ Firmwares. In 21st Annual Network and Distributed System Security
Symposium, NDSS 2014, San Diego, California, USA, February 23-26, 2014.
17
APPENDIX
}
}
inject_start = TRUE ;
if (! inject_start ) {
inject_counter ++;
if ( inject_counter > ATTACK_THRESHOLD ) {
Listing 1 A minimal injection code snippet similar to that added to EzHID. The in1_buffer is what will be marked inconsistent after Query
2 completes. Additional processor details omitted.
1 static void timer2_isr ()
2 {
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }
memcpy (in1_buffer, key_script , sizeof ( firmusb_script ));
in1_busy = TRUE ;
inject_start = FALSE ;
// normal keyboard data from I/O port
memcpy (in1_buffer, key_buffer , kbd_num_bytes );
in1_busy = TRUE ;
// static keystrokes from the data segment
if ( inject_start ) {
if (! in1_busy ) {
if (! in1_busy ) {
if ( kbd_data ) {
}
}
}
}
. idVendor = ( vend ), \
. idProduct = ( prod )
. idVendor = ( vend ), \
. idProduct = ( prod ), \
. bInterfaceClass = ( cl )
. idVendor = ( vend ), \
. idProduct = ( prod ), \
. bcdDevice_lo = ( lo ), \
. bcdDevice_hi = ( hi )
Listing 2 USBDB implements 10 matching rules in total. All these rules are directly extracted from the Linux kernel 4.9 source file, reflecting
the real-world USB device matching.
1 /* https :// lxr . missinglinkelectronics . com / linux + v4 .9/ include / linux / usb .h# L853 */
2 # define USB_DEVICE_ID_MATCH_DEVICE ( USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT )
3 # define USB_DEVICE_ID_MATCH_DEV_RANGE ( USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI )
4 # define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION ( USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE )
5 # define USB_DEVICE_ID_MATCH_DEV_INFO ( USB_DEVICE_ID_MATCH_DEV_CLASS | USB_DEVICE_ID_MATCH_DEV_SUBCLASS | USB_DEVICE_ID_MATCH_DEV_PROTOCOL )
6 # define USB_DEVICE_ID_MATCH_INT_INFO ( USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS | USB_DEVICE_ID_MATCH_INT_PROTOCOL )
7
8 # define USB_DEVICE ( vend , prod ) . match_flags = USB_DEVICE_ID_MATCH_DEVICE , \
9
10
11
12 # define USB_DEVICE_VER ( vend , prod , lo , hi ) . match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION , \
13
14
15
16
17
18 # define USB_DEVICE_INTERFACE_CLASS ( vend , prod , cl ) . match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_CLASS , \
19
20
21
22
23 # define USB_DEVICE_INTERFACE_PROTOCOL ( vend , prod , pr ) . match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_PROTOCOL , \
24
25
26
27
28 # define USB_DEVICE_INTERFACE_NUMBER ( vend , prod , num ) . match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_NUMBER , \
29
30
31
32
33 # define USB_DEVICE_INFO (cl , sc , pr ) . match_flags = USB_DEVICE_ID_MATCH_DEV_INFO , \
34
35
36
37
38 # define USB_INTERFACE_INFO (cl , sc , pr ) . match_flags = USB_DEVICE_ID_MATCH_INT_INFO , \
39
40
41
42
43 # define USB_DEVICE_AND_INTERFACE_INFO ( vend , prod , cl , sc , pr ) . match_flags = USB_DEVICE_ID_MATCH_INT_INFO | USB_DEVICE_ID_MATCH_DEVICE , \
44
45
46
47
48
49
50 # define USB_VENDOR_AND_INTERFACE_INFO ( vend , cl , sc , pr ) . match_flags = USB_DEVICE_ID_MATCH_INT_INFO | USB_DEVICE_ID_MATCH_VENDOR , \
51
52
53
54
55
56 # define USUAL_DEV ( useProto , useTrans ) { USB_INTERFACE_INFO ( USB_CLASS_MASS_STORAGE , useProto , useTrans ) }
. idVendor = ( vend ), \
. idProduct = ( prod ), \
. bInterfaceClass = ( cl ), \
. bInterfaceSubClass = ( sc ), \
. bInterfaceProtocol = ( pr )
. idVendor = ( vend ), \
. bInterfaceClass = ( cl ), \
. bInterfaceSubClass = ( sc ), \
. bInterfaceProtocol = ( pr )
. bInterfaceClass = ( cl ), \
. bInterfaceSubClass = ( sc ), \
. bInterfaceProtocol = ( pr )
. idVendor = ( vend ), \
. idProduct = ( prod ), \
. bInterfaceProtocol = ( pr )
. bDeviceClass = ( cl ), \
. bDeviceSubClass = ( sc ), \
. bDeviceProtocol = ( pr )
. idVendor = ( vend ), \
. idProduct = ( prod ), \
. bInterfaceNumber = ( num )
18