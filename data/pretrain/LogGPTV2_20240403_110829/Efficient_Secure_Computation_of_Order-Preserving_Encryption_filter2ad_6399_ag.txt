DO. It is illustrated in Figure 18a.
are random bits.
â€²(i)
(i)
(i)
, b
, b
, b
1
2
b
(i)
possible cases:
SCSP is given the server state S and a valid ciphertextâˆï¸€âœxâ¨†ï¸, yÌƒï¸€.
Then it chooses two elementsâˆï¸âœxjâ¨†ï¸, yjÌƒï¸,âˆï¸âœxj+1â¨†ï¸, yj+1Ìƒï¸ from the
OPE-table, such that yj â‰¤ y  depth(âœxj+1â¨†ï¸) then insertâœxâ¨†ï¸ right to
âœxjâ¨†ï¸
â— else depth(âœxj+1â¨†ï¸)> depth(âœxjâ¨†ï¸), insertâœxâ¨†ï¸ left toâœxj+1â¨†ï¸
For all ancestors ofâœxâ¨†ï¸, b
âœxâ¨†ï¸ (the equality test from Equation 9 returns 1 if the inputs are
different and 0 otherwise). For the nodeâœxâ¨†ï¸ itself, there are two
â— âœxâ¨†ï¸ is not a leaf: this occurs if one is trying to insert a value,
(i)
e = 0 because
â— âœxâ¨†ï¸ is a leaf: this occurs either because yj= y holds as above
(i)
orâœxâ¨†ï¸ is inserted at a leaf node. If yj= y holds, then b
e = 0
(i)
Ğ´ = 0. Ifâœxâ¨†ï¸ is inserted at a leaf node,
(i)
which also implies b
then b
done. Hence the simulator chooses b
between 0 and undefined.
are undefined because no comparison was
randomly
is 0 (resp. 1) if the path P goes to the
is 1 for all ancestors of
that was already in the tree. It holds b
yj is equal to y.
left (resp. to the right). The value of b
(i)
Ğ´ = b
possible cases:
= b
(i)
(i)
(i)
(i)
and b
Ğ´
Ğ´
Ğ´
e
e
e
â€²(i)
To simulate the CSPâ€™s view, SCSP chooses a random integer r
and random bits b
Î±
illustrated in Figure 18b.
and generates the output
and b
Ï‰ , b
Î± , b
Ï‰
(i)
â€²(i)
(i)
â€²(i)
Efficient Secure Computation of Order-Preserving Encryption
ASIA CCS â€™20, October 5â€“9, 2020, Taipei, Taiwan
o
o
a
b
, b
, b
o ,
a , b
a , b
o , b
â€²(i)
(i)
(i)
(i)
(i)â¨†ï¸,âˆï¸€b
(i)+ r
(i)â¨†ï¸, r
(i)
âœx
,âœx
e âŠ• b
(i)
(i)
â€²(i)
â€²(i)
(i)
â€²(i)
(i)
(i)
e âŠ• b
Ìƒï¸€,âˆï¸€b
Ìƒï¸€
Ğ´ âŠ• b
Ğ´ âŠ• b
(a) CSP View: for i= 1â‹¯l
(i)
(i)
(i)
â€²(i)
(i)+ r
â€²(i)
(i)â¨†ï¸, r
â€²(i)â¨†ï¸,âˆï¸€b
e âŠ• b
âœx
,âœx
â€²(i)
(i)
â€²(i)
(i)
(i)
(i)
â€²(i)
(i)
Ï‰ Ìƒï¸€,âˆï¸€b
Ìƒï¸€
Ğ´ âŠ• b
e âŠ• b
Ğ´ âŠ• b
(b) CSP Simulator: for i= 1â‹¯l
Ï‰ , b
Ï‰ , b
Î± , b
Î± , b
, b
Î±
Î±
a
b
Ï‰ ,
Figure 18: CSP Simulation
Since valuesâœx
(i)
(i)â¨†ï¸, b
â€²(i)
e
(i)
(i)
Ğ´
, b
same in Figures 18a and 18b, and r
distinguishable from r
Î± , b
Î±
, b
(i)
â€²(i)
depend on the path, they are the
are in-
(cid:3)
, b
a , b
Ï‰ , b
â€²(i)
â€²(i)
a
Ï‰ .
(i)
(i)
â€²(i)
(i)
o , b
, b
, b
o
C USING OTHER COMPARISON PROTOCOLS
Our scheme works with any 2-PC for comparison. We describe in
this section how oblivious comparison can be implemented using
DGK comparison protocol [13]. This can done using other schemes
such as Lin-Tzeng [46]. We start by describing DGK protocol itself.
(12)
C.1 The DGK protocol
Let Pi and Pj be two parties with private input xi and xj respectively.
Let xb
j = xjl . . . xj1 denote the bit representation
i = xil . . . xi1 and xb
of xi and xj. To determine whether xiâ‰¤ xj or xi> xj, one computes
for each 1â‰¤ uâ‰¤ l the following numbers zu:
allows to secret-share the result of the comparison between two
v=u+1(xivâŠ• xjv).
zu= s+ xiuâˆ’ xju+ 3
lâˆ‘
v=u+1(xivâŠ•xjv) will be zero exactly
The sum of exclusive-orsâˆ‘l
when xiv = xjv for u xj) and
parties. Assume Pi holds a pair(pki , ski) of public/private key for
an additively HE and letâœâ‹…â¨†ï¸i denote ciphertexts under pki. To check
whether xiâ‰¤ xj holds the protocol works as follows:
â— Pi sendsâœxb
iâ¨†ï¸i=(âœxilâ¨†ï¸i , . . . ,âœxi1â¨†ï¸i) to Pj
â— Pj computes DgkEval() which consists of:
â€“ Choose a random Î´ji and compute s= 1âˆ’ Î´ji
â€“ Computeâœzuâ¨†ï¸ using Equation 12 for 1â‰¤ uâ‰¤ l
â€²
â€“ Computeâœz
uâ¨†ï¸â†âœzuâ¨†ï¸ru for all u and random ru
â€“ Choose a random permutation Ï€ of{1, . . . , l}
â€²
â€²
â€“ Send back Ï€(âœz
1â¨†ï¸i) to Pi and output Î´ji
lâ¨†ï¸i , . . . ,âœz
â€²
â€²
j) denote
Let(Î´ji ,(âœz
1â¨†ï¸i))â† DgkEval(âœxb
iâ¨†ï¸i , xb
lâ¨†ï¸i , . . . ,âœz
â€²
â€²
1â¨†ï¸i) which
â— Pi computes Î´ij â† DgkDecrypt(âœz
lâ¨†ï¸i , . . . ,âœz
â€²
consists of setting Î´ij â† 1 if oneâœz
uâ¨†ï¸i decrypts to 0 and
Î´ijâ† 0 otherwise. Finally, Pi outputs Î´ij.
this computation.
After the computation the parties Pi and Pj hold random bits Î´ij and
Î´ji and it holds Î´ijâŠ• Î´ji=(xâ‰¤ y). In this protocol parties Pi and
Pj perform respectivelyğ’ª(l) andğ’ª(6l) asymmetric operations.
C.2 Oblivious Comparison Using DGK protocol
The DGK comparison protocol can be used for the oblivious compar-
ison as follows. For each node x in the OPE-tree, the DO stores both
âœxâ¨†ï¸,âœxbâ¨†ï¸ during the initialization. During the oblivious comparison
step, the CSP sendsâœxâ¨†ï¸,âœxbâ¨†ï¸ to DA and nothing to the DO. For
the equality testing, the DA usesâœxâ¨†ï¸ to evaluate a zero testing by
computingâœ(xâˆ’x)â‹…r1+r2â¨†ï¸ where r1, r2 are two numbers chosen ran-
â€²
â€²
1â¨†ï¸))â† DgkEval(âœxbâ¨†ï¸, xb). Then
DA evaluates(ba,(âœz
lâ¨†ï¸, . . . ,âœz
â€²
the DA sendsâœ(xâˆ’ x)â‹… r1+ r2â¨†ï¸ and(âœz
1â¨†ï¸) to the DO.
The DA also sends r2 and ba to the CSP. The DO evaluates boâ†
â€²
â€²
lâ¨†ï¸i , . . . ,âœz
DgkDecrypt(âœz
1â¨†ï¸i) and sends(xâˆ’ x)â‹… r1+ r2 and bo
to the CSP. Finally the CSP sets beâ† 1 if(xâˆ’ x)â‹… r1+ r2â‰  r2 and
beâ† 0 otherwise, and bĞ´= baâŠ• bo.
domly in the plaintext space. For the greater than comparison, the
â€²
lâ¨†ï¸, . . . ,âœz
D OOPE WITH ESEDS-OPE
We now briefly describe how OOPE can be realized with ESEDS-
OPE [27] that is IND-CPA-DS-secure, and therefore, secure against
recent plaintext guessing attacks [20, 21, 35] on OPE. As explained
before, ESEDS-OPE combines the benefits of three previous order-
preserving encryption schemes: mOPE1 [38], mOPE3 [25] and
MOPE [8]. ESEDS-OPE consists of four algorithms: key generation,
encryption, decryption and search. The key generation algorithm
takes a security parameter and outputs a secret key. The decryption
algorithm takes the secret key and a ciphertext and outputs the
corresponding plaintext. Key generation and decryption algorithms
are run as before by the data owner alone.
The encryption algorithm takes the secret key, a plaintext and
the state of the encryption stored on the server. Then it requires the
data owner and the server to interactively perform a binary search
using Kerschbaumâ€™s random tree traversal as in mOPE3. Finally,
the server inserts the new plaintext and rotates the resulting data
structure around a new random modulus. The extension to OOPE
will however concern only the tree traversal. In the OOPE protocol,
the three parties just have to traverse the tree with the extension
discussed in Section 7.1 by implementing the comparison and the
random coin in a garbled circuit.
The search algorithm takes the secret key, the state of the encryp-
tion and a range(ï¸€a, bâŒ‹ï¸€. Let cÎ± (resp. cÎ² ) be the ciphertext with the
Î± (resp. Î²) it holds Î±â‰¥ a (resp. Î²â‰¤ b). Then the search algorithm
smallest (resp. largest) order such that for the associated plaintext
requires the data owner and the server to interactively perform
two binary searches (using a non random tree traversal) to get cÎ±
and cÎ² and then returns all ciphertexts between cÎ± and cÎ² . Here as
well, the extension to OOPE only concerns the tree traversal. The
parties will just have to traverse the tree as in the original OOPE
protocol as described in Section 5.3 with the only difference that
they will not have to check for equality as the traversal here is no
longer random.