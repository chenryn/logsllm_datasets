=⇒ s ◦ [u(cid:48)
1, u(cid:48)
2] (cid:38) (cid:126)C;(cid:126)i
1, u(cid:48)
2] (cid:38) (cid:126)C2; (cid:126)i2
∨E
⊥E
M :: Σ, v1:time, v2:time; Ψ, u1 ≤ v1, v2 ≤ u2; E; Γ, x : s1 ◦ [v1, v2]
α
=⇒ s2 ◦ [v1, v2] (cid:38) (cid:126)C;(cid:126)i
(pf impI ([x][v1][v2]M )) :: Σ; Ψ; E; Γ
α
=⇒ s1 ⊃ s2 ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
⊃I
M :: Σ, v:σ; Ψ; E; Γ
α
=⇒ s ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
(pf forallI ([v]M )) :: Σ; Ψ; E; Γ
α
=⇒ ∀v:σ.s ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
∀I
M1 :: Σ; Ψ; E; Γ
α⇐= ∃v:σ.s ◦ [u1, u2] (cid:38) (cid:126)C1; (cid:126)i1
M :: Σ; Ψ; E; Γ
(pf existsI t M ) :: Σ; Ψ; E; Γ
α
=⇒ s[t/v] ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
Σ (cid:96) t : σ
=⇒ ∃v:σ.s ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
M2 :: Σ, v:σ; Ψ; E; Γ, x : s ◦ [u1, u2]
α
∃I
(pf existsE M1 ([v][x]M2)) :: Σ; Ψ; E; Γ
α
=⇒ s(cid:48) ◦ [u(cid:48)
1, u(cid:48)
2] (cid:38) (cid:126)C1, (cid:126)C2; (cid:126)i1, (cid:126)i2
α
=⇒ s(cid:48) ◦ [u(cid:48)
1, u(cid:48)
2] (cid:38) (cid:126)C2; (cid:126)i2
∃E
Figure 6: BL: Proof veriﬁcation checking rules, Part 1
to be veriﬁed is matched with the conclusion of a rule, and the premises established
recursively. Observe that, with the exception of the rule (CS) in Figure 7, only one
other rule will apply to any given proof term and hypotheses.
Since bidirectional proof checking is standard, we describe only some of the rules
brieﬂy. Checking rules for proof terms that introduce connectives follow a similar tem-
plate. We explain only one representative case here: (∧I) from Figure 6. This rule states
that in order check that pf conjI M1 M2 establishes the judgment s1 ∧ s2 ◦ [u1, u2]
(conclusion of the rule), we must check that M1 establishes s1 ◦ [u1, u2] (ﬁrst premise)
and that M2 establishes s2 ◦ [u1, u2] (second premise). The outputs of the premises
(cid:126)C1; (cid:126)i1 and (cid:126)C2; (cid:126)i2 are combined to form the output of the whole veriﬁcation: (cid:126)C1, (cid:126)C2; (cid:126)i1, (cid:126)i2.
Checking rules for proof terms that eliminate a connective are more interesting. In these
cases the principal judgment is synthesized, not checked. For example, in the rule (∨E)
from Figure 6, the ﬁrst premise synthesizes the judgment s1 ∨ s2 ◦ [u1, u2] from the
proof term M. The obtained formulas s1 and s2 are then used to check the two proof
terms M1 and M2.
The rule (interI) from Figure 5 corresponds to two checking rules in the veriﬁer,
named (interI1) and (interI2) in Figure 7. If the interpreted predicate i checks in E,
38
M :: Σ; Ψ; E; Γ
(pf atI M ) :: Σ; Ψ; E; Γ
α
α
@I
2] (cid:38) (cid:126)C;(cid:126)i
=⇒ s ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
1, u(cid:48)
=⇒ (s @ [u1, u2]) ◦ [u(cid:48)
1, u(cid:48)
2] (cid:38) (cid:126)C1; (cid:126)i1
1 , u(cid:48)(cid:48)
=⇒ s(cid:48) ◦ [u(cid:48)(cid:48)
2 ] (cid:38) (cid:126)C2; (cid:126)i2
1 , u(cid:48)(cid:48)
2 ] (cid:38) (cid:126)C1, (cid:126)C2; (cid:126)i1, (cid:126)i2
=⇒ s(cid:48) ◦ [u(cid:48)(cid:48)
α
α
α⇐= (s @ [u1, u2]) ◦ [u(cid:48)
M1 :: Σ; Ψ; E; Γ
M2 :: Σ; Ψ; E; Γ, x : s ◦ [u1, u2]
(pf atE M1 ([x]M2)) :: Σ; Ψ; E; Γ
M :: Σ; Ψ; E; Γ| k,u1,u2=⇒ s ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
(pf saysI M ) :: Σ; Ψ; E; Γ
α
=⇒ (k says s) ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
saysI
M1 :: Σ; Ψ; E; Γ
M2 :: Σ; Ψ; E; Γ, x : k claims s ◦ [u1, u2]
(pf saysE M1 ([x]M2)) :: Σ; Ψ; E; Γ
E |= i
α⇐= (k says s) ◦ [u1, u2] (cid:38) (cid:126)C1; (cid:126)i1
α
=⇒ s(cid:48) ◦ [u(cid:48)
1, u(cid:48)
1, u(cid:48)
2] (cid:38) (cid:126)C2; (cid:126)i2
2] (cid:38) (cid:126)C1, (cid:126)C2; (cid:126)i1, (cid:126)i2
α
=⇒ s(cid:48) ◦ [u(cid:48)
@E
saysE
1, u(cid:48)
|= (cid:126)C1
(pf sinjI) :: Σ; Ψ; E; Γ
M1 :: Σ; Ψ; E; Γ
α
=⇒ i ◦ [u1, u2] (cid:38) ·; · interI1
α⇐= i ◦ [u1, u2] (cid:38) (cid:126)C1; (cid:126)i1
(pf sinjE M1 M2) :: Σ; Ψ; E; Γ
=⇒ i ◦ [u1, u2] (cid:38) ·; i
(pf sinjI) :: Σ; Ψ; E; Γ
1, u(cid:48)
=⇒ s(cid:48) ◦ [u(cid:48)
2] (cid:38) (cid:126)C1, (cid:126)C2; (cid:126)i1, (cid:126)i2
2] (cid:38) (cid:126)C2; (cid:126)i2
M2 :: Σ; Ψ; E, i; Γ
=⇒ s(cid:48) ◦ [u(cid:48)
α
interE
α
α
interI2
(cid:126)C1 (cid:46)(cid:47) (cid:126)C2 = (Ψ |= c)
(pf cinjI) :: Σ; Ψ; E; Γ
M1 :: Σ; Ψ; E; Γ
α⇐= c ◦ [u1, u2] (cid:38) (cid:126)C1; (cid:126)i1
M :: Σ; Ψ; E; Γ
(pf cinjE M1 M2) :: Σ; Ψ; E; Γ
α⇐= s ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
M :: Σ; Ψ; E; Γ
α
=⇒ c ◦ [u1, u2] (cid:38) (cid:126)C2; · consI
=⇒ s(cid:48) ◦ [u(cid:48)
2] (cid:38) (cid:126)C1, (cid:126)C2; (cid:126)i1, (cid:126)i2
1), (Ψ |= u(cid:48)
M2 :: Σ; Ψ, c; E; Γ
=⇒ s(cid:48) ◦ [u(cid:48)
α
1, u(cid:48)
α
C1 (cid:46)(cid:47) C2 = (Ψ |= u1 ≤ u(cid:48)
=⇒ s ◦ [u(cid:48)
2] (cid:38) (cid:126)C, (cid:126)C2;(cid:126)i
1, u(cid:48)
α
1, u(cid:48)
2] (cid:38) (cid:126)C2; (cid:126)i2
consE
2 ≤ u2)
|= (cid:126)C1
CS
Figure 7: BL: Proof veriﬁcation checking rules, Part 2
(interI1) is used and the output is empty. Otherwise, i is written to the output (rule
(interI2)). When the veriﬁer is used in PCFS, E is generally empty, so in practice, i
always gets written to the output (and then to the procap).
Synthesis rules (Figure 8) apply to some proof terms that eliminate connectives and
to hypotheses (rules (hyp) and (claims)). The only non-trivial rule here is (⊃E). It states
that in order to synthesize the judgment proved by a proof term pf impE M1 M2 u(cid:48)
1 u(cid:48)
2,
we should ﬁrst synthesize the judgment s1 ⊃ s2 ◦ [u1, u2] proved by M1 (ﬁrst premise).
Next, we should check that M2 proves s1 ◦ [u(cid:48)
1, u(cid:48)
1, u(cid:48)
2] is
1) and (Ψ |= u(cid:48)
a subset of [u1, u2] (constraints (Ψ |= u1 ≤ u(cid:48)
2 ≤ u2)). If all these hold,
then pf impE M1 M2 u(cid:48)
1, u(cid:48)
2].
2] (second premise) and that [u(cid:48)
2 proves the judgment s2 ◦ [u(cid:48)
In both the checking and synthesis rules, if a set of constraint judgments needs to be
checked in a rule, then this set is split non-deterministically into two sets, one of which
is checked immediately, and the other of which is written to the output. This happens in
rules (consI), (CS), (claims) and (⊃E). It is expected that the output judgments will be
checked later (e.g., in PCFS, the output judgments are written in a procap and checked
whenever the procap is checked).
1 u(cid:48)
The rule (CS) in Figure 7 allows the veriﬁer to move from a checking judgment to
a synthesis judgment without changing the proof term. This shift can be, and must
39
α⇐= s ◦ [u1, u2] (cid:38) ·; · hyp
x :: Σ; Ψ; E; Γ, x : s ◦ [u1, u2]
(cid:126)C1 (cid:46)(cid:47) (cid:126)C2 = (Ψ |= u1 ≤ ub), (Ψ |= ue ≤ u2), (Ψ |= k(cid:48) (cid:23) k)
α⇐= s ◦ [u1, u2] (cid:38) (cid:126)C2; ·
x :: Σ; Ψ; E; Γ, x : k(cid:48) claims s ◦ [u1, u2]
α = k, ub, ue
|= (cid:126)C1
claims
M :: Σ; Ψ; E; Γ
α⇐= s1 ∧ s2 ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
(pf conjE1 M ) :: Σ; Ψ; E; Γ
α⇐= s1 ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
M :: Σ; Ψ; E; Γ
(pf conjE2 M ) :: Σ; Ψ; E; Γ
α⇐= s1 ∧ s2 ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
α⇐= s2 ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
α⇐= s1 ⊃ s2 ◦ [u1, u2] (cid:38) (cid:126)C1; (cid:126)i1
(cid:126)C3 (cid:46)(cid:47) (cid:126)C4 = (Ψ |= u1 ≤ u(cid:48)
∧E1
∧E2
M2 :: Σ; Ψ; E; Γ
α
=⇒ s1 ◦ [u(cid:48)
M1 :: Σ; Ψ; E; Γ
1, u(cid:48)
2] (cid:38) (cid:126)C2; (cid:126)i2
1 u(cid:48)
(pf impE M1 M2 u(cid:48)
1), (Ψ |= u(cid:48)
2 ≤ u2)
2] (cid:38) (cid:126)C1, (cid:126)C2, (cid:126)C4; (cid:126)i1, (cid:126)i2
|= (cid:126)C3
⊃E
2) :: Σ; Ψ; E; Γ
α⇐= s2 ◦ [u(cid:48)
1, u(cid:48)
α⇐= ∀v:σ.s ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
M :: Σ; Ψ; E; Γ
(pf forallE M t) :: Σ; Ψ; E; Γ
Σ (cid:96) t : σ
α⇐= s[t/v] ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i
∀E
Figure 8: BL: Proof veriﬁcation synthesis rules
be, applied when the proof term M matches the proof term in the conclusion of some
rule in Figure 8. Generally, bidirectional proof veriﬁers also allow a shift in the other
direction – from synthesis to checking – via an explicit proof term constructor. In our
implementation we do not allow this coercion. The consequence of this restriction is that
our veriﬁer can only check normal proof terms (a proof term is normal if it does not
contain any elimination constructor immediately outside an introduction constructor).
While it is easy to avoid this restriction by allowing the explicit coercion, we do not
do so here since our proof search tool constructs normal proofs only. Further, normal
proofs are complete: any hypothetical judgment that has a proof also has a normal
proof. Proof of the latter result is based on a sequent calculus presentation of BL, which
is beyond the scope of this paper.
Another important point concerns the scope of parameters in the checking rules (∀I)
and (∃E) of Figure 6. In each case, the premise introduces a new parameter v:σ, which
may appear free in the output – (cid:126)C;(cid:126)i for (∀I) and (cid:126)C1, (cid:126)C2; (cid:126)i1, (cid:126)i2 for (∃E). As mentioned
in Appendix A, decision procedures for solving constraints and interpreted predicates
treat such parameters universally, e.g., in the case of (∀I), if (cid:126)C is found to hold then
(cid:126)C[t/v] would also hold for every ground term t. To ensure that parameters introduced
in diﬀerent branches of the veriﬁcation do not conﬂict in the outputs, we also assume
implicitly that all parameters introduced during veriﬁcation are unique.
The following lemma establishes that this veriﬁcation procedure is sound, i.e., any
proof it veriﬁes is valid in BL’s natural deduction system subject to some conditions.
Lemma B.1 (Veriﬁcation Soundness). Suppose that |= (cid:126)C and E(cid:48) |= (cid:126)i. Then
1. M :: Σ; Ψ; E; Γ α=⇒ s ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i implies M :: Σ; Ψ; E, E(cid:48); Γ α−→ s ◦ [u1, u2] (cid:38)