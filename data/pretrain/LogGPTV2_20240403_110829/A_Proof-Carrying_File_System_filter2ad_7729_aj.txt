### 优化后的文本

在以下的证明验证规则中，待验证的判断与规则的结论相匹配，并且前提条件被递归地建立。请注意，除了图7中的(CS)规则外，只有一个其他规则适用于任何给定的证明项和假设。

由于双向证明检查是标准的，我们仅简要描述一些规则。引入连接词的证明项的检查规则遵循类似的模板。这里我们仅解释一个代表性的例子：图6中的(∧I)规则。该规则表明，为了验证pf conjI M1 M2确立了判断s1 ∧ s2 ◦ [u1, u2]（规则的结论），我们需要验证M1确立了s1 ◦ [u1, u2]（第一个前提）并且M2确立了s2 ◦ [u1, u2]（第二个前提）。前提输出(cid:126)C1; (cid:126)i1 和 (cid:126)C2; (cid:126)i2 结合形成整个验证的输出：(cid:126)C1, (cid:126)C2; (cid:126)i1, (cid:126)i2。

消除连接词的证明项的检查规则更为有趣。在这些情况下，主要判断是合成的，而不是检查的。例如，在图6中的(∨E)规则中，第一个前提从证明项M中合成了判断s1 ∨ s2 ◦ [u1, u2]。然后使用获得的公式s1和s2来检查两个证明项M1和M2。

图5中的(interI)规则对应于验证器中的两个检查规则，分别命名为图7中的(interI1)和(interI2)。如果解释的谓词i在E中检查通过，则使用(interI1)规则，输出为空。否则，i将写入输出（规则(interI2)）。当验证器在PCFS中使用时，E通常为空，因此实际上i总是写入输出（然后写入procap）。

合成规则（图8）适用于某些消除连接词的证明项和假设（规则(hyp)和(claims)）。这里唯一的非平凡规则是(⊃E)。它表明，为了合成由pf impE M1 M2 u'(1) u'(2) 证明的判断，我们首先应合成由M1证明的判断s1 ⊃ s2 ◦ [u1, u2]（第一个前提）。接下来，我们应验证M2证明s1 ◦ [u'(1), u'(2)] 并且[u'(1), u'(2)] 是[u1, u2]的子集（约束(Ψ |= u1 ≤ u'(1)) 和 (Ψ |= u'(2) ≤ u2)）。如果所有这些都成立，则pf impE M1 M2 u'(1) u'(2) 证明判断s2 ◦ [u'(1), u'(2)]。

在检查和合成规则中，如果需要检查一组约束判断，则该集合会被非确定性地分成两组，其中一组立即检查，另一组写入输出。这发生在(consI)、(CS)、(claims)和(⊃E)规则中。预期输出判断将在稍后进行检查（例如，在PCFS中，输出判断被写入procap并在procap被检查时进行检查）。

图7中的(CS)规则允许验证器从检查判断转移到合成判断，而无需更改证明项。这种转换可以并且必须应用于图8中某个规则的结论中的证明项。通常，双向证明验证器也允许通过显式的证明项构造函数从合成到检查的方向转换。在我们的实现中，我们不允许这种强制转换。这一限制的结果是我们的验证器只能检查正常的证明项（如果证明项不包含直接位于引入构造函数之外的消除构造函数，则它是正常的）。虽然可以通过允许显式强制转换来避免此限制，但我们在这里没有这样做，因为我们的证明搜索工具只构建正常的证明。此外，正常证明是完整的：任何具有证明的假设判断也具有正常的证明。后者的证明基于BL的顺序演算表示，这超出了本文的范围。

另一个重要点涉及图6中的检查规则(∀I)和(∃E)中的参数范围。在这两种情况下，前提引入了一个新的参数v:σ，该参数可能在输出中自由出现——(∀I)中的(cid:126)C;(cid:126)i 和 (∃E)中的(cid:126)C1, (cid:126)C2; (cid:126)i1, (cid:126)i2。如附录A所述，用于解决约束和解释谓词的决策过程将此类参数视为普遍的，例如，在(∀I)的情况下，如果发现(cid:126)C成立，则对于每个基础项t，(cid:126)C[t/v]也会成立。为确保在验证的不同分支中引入的参数不会在输出中冲突，我们还隐含地假设在验证过程中引入的所有参数都是唯一的。

以下引理建立了该验证程序的声音性，即它验证的任何证明在满足某些条件的情况下在BL的自然演绎系统中是有效的。

**引理B.1（验证声音性）** 假设|= (cid:126)C 和 E' |= (cid:126)i。那么：

1. 如果 M :: Σ; Ψ; E; Γ α=⇒ s ◦ [u1, u2] (cid:38) (cid:126)C;(cid:126)i 成立，则 M :: Σ; Ψ; E, E'; Γ α−→ s ◦ [u1, u2] (cid:38) 成立。