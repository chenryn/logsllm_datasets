#("foo"
"bar"
（eoo)#（((o x )(x) pqu):# x:（zea
ambda
(c) (eql char c)） string)
#*CHAR-EQUAL)
'(456))
www.TopSage.com
→(1２34.56)
→#(123456)
一它返回满足谓词的那些元素。
11.6整个序列上的操作
→2
117
---
## Page 135
从一个特定索引开始并延续到一个特定终止索引或结尾处的子序列。例如：
11.8子序列操作
出于同样原因，MERGE的第一个参数必须是用来指定所生成序列类型的类型描述符。
的序列也将是有序的。和排序函数一样，MERGE也接受一个：keY参数。和CONCATENATE一样，
和两个排序函数之间的关系在于，如果每个序列已经被同样的谓词排序过了，那么由MERGE返回
回的序列将含有参数序列的实际元素。
用来从序列元素中抽取出传给排序谓词的值的函数。被抽取出的关键字仅用于确定元素顺序，返
而不只是这样：
和STABLE-SORT破坏序列是合理的。但这意味着需要记得要这样来写：?
个对象，否则应该传递一个副本。下一章里将会讨论更多有关破坏性函数的内容。
（比如给它赋值一个变量或将它传递给另一个函数），第二，除非你不再需要传给破坏性函数的那
或多或少地修改它们的参数。这有两层含义：第一，你应该总是对这些函数的返回值做一些事情
只保证结果是已排序的并可能重排等价元素。
参组成的谓词，返回该序列排序后的版本。
11.7
函数MERGE接受两个序列和一个谓词，并返回按照该谓词合并这两个序列所产生的序列。它
这两个函数都是所谓的破坏性（destructive）函数。通常出于效率的原因，破坏性函数都会
118
①当传递给排序函数的序列是一个向量时，其破坏性实际上可以确保进行元素的就地交换，因此你可以无需保存返
在排序以后，你通常不会再关心那个序列的未排序版本，因此在排序的过程中，允许SORT
SUBSEQ也支持SETF，但不会扩大或缩小一个序列。如果新的值和将被替换的子序列具有不
另一类函数允许你对已有序列的子序列进行操作，其中最基本的是SUBSEQ，它解出序列中
这两个函数也接受关键字参数：key，它和其他序列函数的：key参数一样，应当是一个将被
(setf my-sequence (sort my-sequence #'string#(1234)#(5432))
(every #'> #(1 2 3 4) #(5 4 3 2)) 
下面的调用比较成对的两个序列中的元素：
notany
(notevery #'evenp #(1 2 3 4 5)) →T
(notany #'evenp #(1 2 3 4 5))
哈希表
序列映射函数
第11章集合
#(1
2
www.TopSage.com
2)}
IN←
→
→
"→NIL
T
NIL
---
## Page 138
LET所做的变量绑定，并用一个形式返回的多个值来填充它们。
MULTIPLE-VALUE-BIND宏来利用GETHASH额外返回值。MULTIPLE-VALUE-BIND创建类似于
是一个布尔值，用来指示该键在哈希表中是否存在。由于多重返回值的工作方式，除非调用者用
题，即通过多重返回值。GETHASH实际上返回两个值：主值是保存在给定键下的值或NIL；从值
中不存在还是键在表中存在却带有值NIL。GETHASH用一个我尚未讨论到的特性解决了这一问
哈希表中相应键下的值（如果有的话）或是NIL。
了一些自定义哈希表的方法。
希码的哈希函数。不过，尽管语言标准仅提供了使用标准等价函数的哈希表，但多数实现都提供
函数；一个以一种和等价函数最终比较两个键时相兼容的方式，用来从键中计算出一个数值的哈
数—只能是值EQ、EQL、EQUAL和EQUALP。这是因为哈希表实际上需要两个函数：一个等价性
传递给序列函数的：teSt参数不同的是，MAKE-HASH-TABLE的：teSt不能用来指定一个任意函
个可能的值是符号EQ和EQUALP。这些都是第4章里讨论过的标准对象比较函数的名字。不过，和
通过将符号EQUAL作为：teSt关键字参数传递给MAKE-HASH-TABLE来获得。：teSt参数的另外两
同内容的字符串不一定是EQL等价的。在这种情况下，你需要一个所谓的EQUAL哈希表，它可以
的意义上是相同的对象。这是一个好的默认值，除非你想要使用字符串作为健，因为两个带有相
一个可以看见多值的形式显式地处理它，否则额外的返回值将被偷偷地丢掉。
新值上一
保存在一个特定的键下。以后就可以使用相同的键来获取该值，或者可以将同一个键关联到一个
我将在第20章里讨论更多关于多重返回值的细节，但目前我将概要地介绍一下如何使用
① 由于历史上的意外，GETHASH的参数顺序与ELT相反。ELT将集合作为第一个参数，然后是索引I，而GETHASH将
函数GETHASH提供了对哈希表元素的访问。它接受两个参数，即键和哈希表，并返回保存在
(setf (gethash 'bar *h*) nil) ; provide an explicit value of NIL
(defun show-value (key hash-table)
下面的函数显示了怎样使用MULTIPLE-VALUE-BIND，它绑定的变量是value和present：
由于当键在表中不存在时GETHASH返回NIL，所以无法从返回值中看出，究竟是键在哈希表
(gethash ‘foo *h*） → QUUx 
(xnnb. (xUx ooJ: useunab) Jnas)
(gethash'foo *h*） → NIL
(defparameter *h* (make-hash-table))
键作为第一个参数，然后是集合。
(multiple-value-bind (value present) (gethash key hash-table)
每个键映射到单一值上。
{if present
www.TopSage.com
例如：
value)
value))))
11.11哈希表
121
---
## Page 139
个让Lisp因此得名的数据结构了。
数组的函数库。但本章中涉及的内容已能满足多数通用编程场合的需要。现在，可以介绍列表这
MAPHASH表达式的等价LOOP形式如下所示：
移除当前项。例如，为了移除所有其值小于10的项，可以写成下面这样：
但有两个例外：可以将SETF与GETHASH一起使用来改变当前项的值，并且可以使用REMHASH来
用一次该函数。例如，为了打印哈希表中所有的键值对，可以像这样来使用MAPHASH：
11.12
清除哈希表中的所有键值对。
一个键值对。REMHASH接受和GETHASH相同的参数并移除指定的项。也可以使用CLRHASH来完全
122
①LOOP的哈希表迭代通常是用更基本的形式WITH-HASH-TABLE-ITERATOR来实现的，你不需要担心这点。它被
关于Common Lisp所支持的非列表集合，我还可以讲更多的内容，例如多维数组以及处理位
另一种在哈希表上选代的方式是使用扩展的LOOP宏，我将在第22章里讨论它。°第一个
(maphash #'(lambda (k v) (format t "~a => ~a~&" k v)) *h*)
Common Lisp提供了几种在哈希表项上选代的方式，其中最简单的方式是通过函数MAPHASH。
(4 antea-useu) butsn *u* ut sKay-useu au2 butaq x xos doot)
(maphash #(1ambda (k v) (when (< v 10) (remhash k *h*))) *h*)
在迭代一个哈希表的过程中，向其中添加或移除元素的后果没有被指定 (并且可能会很坏).
由于将一个键下面的值设置成NIL会造成把键留在表中，因而你需要另一个函数来完全移除
添加到语言里特定用来支持实现诸如LOOP这样的东西，并且除非你需要编写迭代在哈希表之上的全新控制构造，
(show-value 'baz *h*) → "Value NIL because key not found."
(show-value
'auasid o xn a  (*u+ oo. ae-mou)
否则几乎不会用到它。
哈希表迭代
第11章集合
'bar *h*)
www.TopSage.com
---
## Page 140
两个值的形式，即所谓的“点对”。
引用。除非第二个值是NIL或是另一个点对单元，否则点对都将打印成在括号中并用一个点分隔