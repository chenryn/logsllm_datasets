logg y = logB(A/(c2j
4.2 Security Analysis
u,0) mod n).
In this subsection we show that Scheme I is a secure group
signature scheme and satisﬁes weak forward security. We
state our theorems here and would like to refer the reader
to the appendix A for detailed proofs.
Lemma 1. PK{(α, β, δ, ) : B2 = (g2) ∧
)α(1/(a2))β(1/(y2))δ∧1 = (B2T−j+1
d2 = (A2T−j+1
)α(1/(g2))δ
∧ β ∈ Γ ∧ α ∈ Λ}(m) is a statistical zero-knowledge proof of
knowledge of the group membership key.
5
Lemma 2. In Scheme I, under the strong RSA assump-
tion, a group signing key for some time period t, (xu, eu, cu)
where xu ∈ Γ, eu ∈ Λ, and c2T −t
= daxu mod n, can only
be generated by the group manager given that the number of
group signing keys the group manager issues is polynomially
bounded.
eu
u
Lemma 3. Scheme I satisﬁes weak forward security under
the strong RSA assumption and given that the number of
group signing keys the group manager issues is polynomially
bounded.
Corollary 1. In the random oracle model, Scheme I
is secure and satisﬁes the weak forward security under the
strong RSA assumption and the decisional Diﬃe-Hellman
assumption.
4.3 Time-Limited Group Membership
When a group member U joins at time period i, if he
only obtains the group signing key for that time period
(cu,i, eu, xu), then he can only generate group signatures
valid for time periods following time period i and not for
the time periods prior to time period i. Thus his group
membership is only valid for the time after he joined.
We can easily extend Scheme I to support a more general
form of time-limited group membership, i.e. a group mem-
ber is only allowed to sign on behalf of the group during a
limited time. The basic idea is to have two chains of the
group signing key. One chain evolves forward over time (as
in Scheme I) and the other chain backwards. Note that the
two chains share the same xu. A signer needs to know both
the signing key in the forward chain and the backward chain
for time period i to generate a signature valid for time period
i. Knowing the signing key for time period i in the forward
chain enables the signer to compute all the keys in the for-
ward chain after time period i, and knowing the signing key
for time period i in the backward chain enables the signer
to compute all the keys in the backward chain prior to time
period i. Therefore knowing the signing key for time period
i in the forward chain and the signing key for time period j
in the backward chain allow the member to sign documents
between time period i and j, given i < j. And the expence
of two chains is not much, i.e. the signature size is less than
double of the basic one-chain signature size.
4.4 Revocation
2
We can extend Scheme I to support retroactive revocation
with backward unlinkability. Let h be a generator in a cyclic
group of order n where the decisional Diﬃe Hellman prob-
lem is hard [9, 7]. When a group member U signs a message
in time period j with his group signing key (cu,j, eu, xu),
besides the basic SIGN procedure, U also does the follow-
ing. He randomly selects r ∈ Zn and compute g2 = hr,
C = gcu,j
, and reveals (g2, C) which we call a revocation
token. U proves through signature of knowledge that g2 and
C are of the right form. When a user V is expelled from
the group starting from time period i, cv,i and i will be
published in the CRL. Assume a veriﬁer has a signature for
time period j where j ≥ i and the revocation token in the
signature is (g
). To see whether the signing key has
been expelled, the veriﬁer simply compute cv,j and check
(cid:4)
2)cv,j . If they equal, it means that the sig-
whether C
nature is revoked. In more detail, for U to sign a message
m in time period j, the protocol is as the following:
(cid:4)
2, C
= (g
(cid:4)
(cid:4)
229U chooses r1 ∈R {0, 1}2(cid:20)n , r2 ∈R Zn, computes A =
cu,jyr1 , B = gr1 , g2 = hr2 , C = gcu,j
PK{(α, β, δ, , γ) : g2 = hγ ∧ B2 = (g2) ∧
d2 = (A2T−j+1
∧ β ∈ Γ ∧ α ∈ Λ}(m),
and PK2{(η, θ) : A = ηyθ ∧ B = gθ ∧ C = gη
, and generates
)α(1/(a2))β(1/(y2))δ∧1 = (B2T−j+1
2}(m).
2
)α(1/(g2))δ
The ﬁrst protocol PK is the same as in our original forward-
secure group signature scheme. The second protocol PK2 is
a new zero-knowledge proof protocol that we construct and
we explain the details in the appendix B.
It is clear that this scheme supports publicly-revokable
group membership. However, the backward unlinkability
property relies on a new cryptographic assumption which
we call log-square assumption: Let n be a product of two
safe primes as in Scheme I. Let G be a cyclic group of order
n where the decisional Diﬃe Hellman problem is hard, and
let g2 be a generator of G. Given a random v ∈R QRn, and
2 ∈R G, it is computationally hard for an attacker
w = gu
to decide whether v = u2 mod n without knowing the fac-
tor of n. Under this assumption, it is easy to see that our
scheme supports backward unlinkability. The cryptographic
assumption reduces to either factoring or discrete logarithm
problem. We conjecture this problem is hard although more
research still needs to be done to study this problem.
5. FORWARD SECURE GROUP
SIGNATURE II
5.1 The Scheme
SETUP Procedure. The SETUP procedure is almost the
same as in Scheme I. In addition to the SETUP procedure
in Scheme I, let Λi denote integer interval (2(cid:20)Λ (1+i2(cid:20)Λ /(T +
1)), 2(cid:20)Λ (1 + (i + 1)2(cid:20)Λ /(T + 1))), for 0 ≤ i ≤ T. The group
manager also speciﬁes a deterministic one-way method such
that given a randomly chosen prime eu,i ∈ Λi, one can
generate a sequence of prime numbers eu,i, . . . , eu,T where
eu,j ∈ Λj, for i ≤ j ≤ T. Given only eu,j for some i ≤ j ≤ T ,
it is hard to compute backwards, i.e. eu,k for k < j.
(cid:1)
Intuition. This forward secure group signature scheme is
similar to Scheme I in section 4 except that it uses a dif-
ferent one-way function to evolve the group signing keys.
When a user U joins the group, similarly to Scheme I, he
and GM randomly select xu ∈R Γ together such that U
knows xu and GM only knows yu := axu . The group man-
ager then randomly selects a prime eu,0 ∈ Λ0 which then
generates a sequence of prime numbers eu,i ∈ Λi, 0 ≤ i ≤ T .
0≤i≤T eu,i. The group manager then computes
Let bu =
fu := (yud)1/(bu) mod n, and sends U (fu, eu,0). Thus from
(xu, fu, eu,0), U can derive his group signing key for each
time period. In particular, let v0 = fu, vi+1 = veu,i
, w0 =
(cid:1)
1≤i≤T eu,i, wi+1 = wi/eu,i+1. U ’s group signing key for
time period i is (xu, cu,i, eu,i) where cu,i = vwi
i mod n.
To sign a message m for time period i, U produces non-
interactive proofs of knowledge that he knows (xu, cu,i, eu,i)
such that ceu,i
able the OPEN procedure, the signer also encrypts cu,i with
the public key of the group manager and produces the non-
interactive proof that the encryption is of the correct form.
In case of a dispute, the group manager can simply decrypt
the value of cu,i to identify the actual signer.
u,i = daxu , xu ∈ Γ, and eu,i ∈ Λi. To en-
i
JOIN Procedure. The JOIN procedure is the same as in
Scheme I except for the third step. In the third step, the
group manager randomly selects a prime eu,0 ∈ Λ0 which
then generates a sequence of prime numbers eu,i ∈ Λi, 0 ≤
i ≤ T . Let bu =
0≤i≤T eu,i. The group manager then
computes fu := (yud)1/(bu) mod n, and sends U (fu, eu,0).
U computes bu from the given eu,0 and veriﬁes that axu d =
f bu
u mod n.
(cid:1)
(cid:1)
EVOLVE Procedure. Let v0 = fu, w0 =
1≤i≤T eu,i. In
each time period i, U stores (vi, eu,i). To evolve in time pe-
riod i + 1, U computes eu,i+1, . . . , eu,T from eu,i and com-
, wi+1 = eu,i+2 ··· eu,T . Thus U ’s group
putes vi+1 = veu,i
signing key for time period i + 1 is (xu, cu,i+1, eu,i+1) where
cu,i+1 = vwi+1
i+1 mod n. And U update the storage (vi, eu,i)
to (vi+1, eu,i+1).
i
SIGN and VERIFY Procedures. Assume U has group
signing key (cu,j, eu,j, xu) at time period j. To sign a mes-
sage m in time period j, he ﬁrst chooses r1 ∈R {0, 1}2(cid:20)n ,
computes A = cu,jyr1 , B = gr1 , and generates
PK{(α, β, δ, ) : d2 = (A2)α(1/(a2))β(1/(y2))δ ∧
B2 = (g2) ∧ 1 = (B2)α(1/(g2))δ ∧ β ∈ Γ ∧ α ∈ Λj}(m).
A veriﬁer simply checks the validity of the above signature
of knowledge.
OPEN Procedure. In the event that the actual signer
must be subsequently identiﬁed (e.g., in case of a dispute),
GM ﬁrst checks the validity of the signature via the VER-
IFY procedure, and then recover cu,j (and thus the iden-
tity of U ) as cu,j = (A/Bx) mod n. GM also proves that
logg y = logB(A/(cu,j) mod n).
5.2 Security Analysis
We show that Scheme II is a secure group signature scheme
and satisﬁes strong forward security. We state our theorems
here and would like to refer the reader to the appendix A
for detailed proofs.
Lemma 4. PK{(α, β, δ, ) : d2 = (A2)α(1/(a2))β(1/(y2))δ
∧ B2 = (g2) ∧ 1 = (B2)α(1/(g2))δ ∧ β ∈ Γ ∧ α ∈ Λi}(m) is
a statistical zero-knowledge proof of knowledge of the group
membership key.
Lemma 5. In Scheme II, under the strong RSA assump-
u,t = daxu mod n, xu ∈ Γ, and eu ∈ Λt, can only
tion, a group signing key for some time period t, (xu, eu,t, cu,t),
where ceu,t
be generated by the group manager given that the number of
group signing keys the group manager issues is polynomially
bounded.
Lemma 6. Under the strong RSA assumption, Scheme II
satisﬁes strong forward security given that the number of
group signing keys the group manager issues is polynomially
bounded.
Corollary 2. In the random oracle model, Scheme II
is secure and satisﬁes the strong forward security under the
strong RSA assumption and the decisional Diﬃe-Hellman
assumption.
5.3 Time-limited Group Membership
Using Scheme II, we can in fact support group member-
ship valid for any subset of the time periods with almost
6
230(cid:1)
no overhead. For example, when user U joins the group, if
GM only wants to issue U group membership valid for time
periods t1, . . . , tm, then in step 3 instead of computing bu as
the product of the whole sequence eu,0, . . . , eu,T , GM com-
1≤i≤m eu,ti and then compute fu = (yud)1/bu
putes bu =
mod n. Thus U can only sign on behalf the group in time
periods t1, . . . , tm with no extra overhead in secret storage
and computation time comparing to the basic Scheme II.
5.4 Revocation
Revocation in Scheme II is easy. When U signs with his
group membership (xu, eu,i, cu,i) in time period i, besides
the basic SIGN procedure in Scheme II, he also does the
following: he randomly generates an element g3 ∈ QRn and
reveals g3 and D = geu,i
and proves in zero-knowledge that
D is formed correctly. We call (g3, D) the revocation token
of the signature. More precisely, the new SIGN procedure
is as the following: U chooses r1 ∈R {0, 1}2(cid:20)n , g3 ∈R QRn,
computes A = cu,iyr1 , B = gr1 , D = geu,i
PK{(α, β, δ, ) : B2 = (g2) ∧ 1 = (B2)α(1/(g2))δ ∧
3)α ∧ d2 = (A2)α(1/(a2))β(1/(y2))δ ∧ β ∈ Γ
D2 = (g2
∧ α ∈ Λi}(m).
, and generates
3
3
A veriﬁer simply checks the validity of the above signature
of knowledge.
Now if the group manager wants to revoke U ’s signature
starting from time period i, he simply reveals eu,i and i. If
a user V obtained a signature for time period j ≥ i and
the revocation token of the signature is (g
), to check
whether the signature is revoked, (i.e. it was signed by U ),
V computes eu,j from eu,i and simply checks whether D
=
(g
If they equal, it means the signature is revoked
because it is signed by U after time period i.
)eu,j .
, D
(cid:4)
(cid:4)
(cid:4)
(cid:4)
This revocation scheme supports retroactive public revo-
cation. It is easy to see that all signatures signed by other