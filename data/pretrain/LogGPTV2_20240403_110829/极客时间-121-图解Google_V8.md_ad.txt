# 03｜快属性和慢属性：V8采用了哪些策略提升了对象属性的访问速度？你好，我是李兵。 在前面的课程中，我们介绍了 JavaScript中的对象是由一组组属性和值的集合，从 JavaScript语言的角度来看，JavaScript对象像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。 然而在 V8实现对象存储时，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线性的数据结构，查询效率会低于线性的数据结构，V8为了提升存储和查找效率，采用了一套复杂的存储策略。 ![](Images/43656e4b9dc75f79c6f3d0beccd714b6.png)savepage-src="https://static001.geekbang.org/resource/image/c9/ef/c970cdc7b89bfe0a12e560fe94fcdfef.jpg"}线性结构和非线性结构今天这节课我们就来分析下 V8采用了哪些策略提升了对象属性的访问速度。 常规属性 (properties) 和排序属性 (element)在开始之前，我们先来了解什么是对象中的**常规属性**和**排序属性**，你可以先参考下面这样一段代码：     function Foo() {        this[100] = 'test-100'        this[1] = 'test-1'        this["B"] = 'bar-B'        this[50] = 'test-50'        this[9] =  'test-9'        this[8] = 'test-8'        this[3] = 'test-3'        this[5] = 'test-5'        this["A"] = 'bar-A'        this["C"] = 'bar-C'    }    var bar = new Foo()    for(key in bar){        console.log(`index:${key}  value:${bar[key]}`)    }在上面这段代码中，我们利用构造函数 Foo 创建了一个 bar对象，在构造函数中，我们给 bar对象设置了很多属性，包括了数字属性和字符串属性，然后我们枚举出来了 bar对象中所有的属性，并将其一一打印出来，下面就是执行这段代码所打印出来的结果：     index:1  value:test-1    index:3  value:test-3    index:5  value:test-5    index:8  value:test-8    index:9  value:test-9    index:50  value:test-50    index:100  value:test-100    index:B  value:bar-B    index:A  value:bar-A    index:C  value:bar-C观察这段打印出来的数据，我们发现打印出来的属性顺序并不是我们设置的顺序，我们设置属性的时候是乱序设置的，比如开始先设置100，然后有设置了1，但是输出的内容却非常规律，总的来说体现在以下两点： 1.  设置的数字属性被最先打印出来了，并且按照数字大小的顺序打印的；        2.  设置的字符串属性依然是按照之前的设置顺序打印的，比如我们是按照    B、A、C    的顺序设置的，打印出来依然是这个顺序。        之所以出现这样的结果，是因为在 ECMAScript规范中定义了**数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。** 在这里我们把对象中的数字属性称为**排序属性**，在 V8 中被称为 **elements**，字符串属性就被称为**常规属性**，在 V8 中被称为 **properties**。 在 V8内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个**线性数据结构**来分别保存排序属性和常规属性，具体结构如下图所示： ![](Images/df204a5bb7e81ee1ea6ca623bbfd0ccc.png)savepage-src="https://static001.geekbang.org/resource/image/af/75/af2654db3d3a2e0b9a9eaa25e862cc75.jpg"}V8内部的对象构造通过上图我们可以发现，bar 对象包含了两个隐藏属性：elements 属性和properties 属性，elements 属性指向了 elements 对象，在 elements对象中，会按照顺序存放排序属性，properties 属性则指向了 properties对象，在 properties对象中，会按照创建时的顺序保存了常规属性。 分解成这两种线性数据结构之后，如果执行索引操作，那么 V8 会先从elements 属性中按照顺序读取所有的元素，然后再在 properties属性中读取所有的元素，这样就完成一次索引操作。 快属性和慢属性将不同的属性分别保存到 elements 属性和 properties属性中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步操作，比如执行`bar.B`这个语句来查找 B 的属性值，那么在 V8 会先查找出properties 属性所指向的对象 properties，然后再在 properties 对象中查找 B属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率。 基于这个原因，V8采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，我们把这称为**对象内属性 (in-objectproperties)。**对象在内存中的展现形式你可以参看下图： ![](Images/af57adf6ad91932c341fc9c38f594584.png)savepage-src="https://static001.geekbang.org/resource/image/f1/3e/f12b4c6f6e631ce51d5b4f288dbfb13e.jpg"}对象内属性采用对象内属性之后，常规属性就被保存到 bar对象本身了，这样当再次使用`bar.B`来查找 B 的属性值时，V8 就可以直接从 bar对象本身去获取该值就可以了，这种方式减少查找属性值的步骤，增加了查找效率。 不过对象内属性的数量是固定的，默认是 10个，如果添加的属性超出了对象分配的空间，则它们将被保存在常规属性存储中。虽然属性存储多了一层间接层，但可以自由地扩容。 通常，我们将保存在线性数据结构中的属性称之为"快属性"，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。 因此，如果一个对象的属性过多时，V8为就会采取另外一种存储策略，那就是"慢属性"策略，但慢属性的对象内部会有独立的非线性数据结构(词典)作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。 ![](Images/f45de4d5fe66fb9ba19503c862a69a2e.png)savepage-src="https://static001.geekbang.org/resource/image/e8/17/e8ce990dce53295a414ce79e38149917.jpg"}慢属性是如何存储的实践：在 Chrome 中查看对象布局现在我们知道了 V8 是怎么存储对象的了，接下来我们来结合 Chrome中的内存快照，来看看对象在内存中是如何布局的？ 你可以打开 Chrome开发者工具，先选择控制台标签，然后在控制台中执行以下代码查看内存快照：     function Foo(property_num,element_num) {        //添加可索引属性        for (let i = 0; i :1:1这是告诉我们，变量 foo并不是一个函数，所以无法被调用。同样是在定义的函数之前调用函数，第一段代码就可以正确执行，而第二段代码却报错，这是为什么呢？其主要原因是这两种定义函数的方式具有不同语义，不同的语义触发了不同的行为。![](Images/2c30387202ecc1f8d5db08677e691322.png)savepage-src="https://static001.geekbang.org/resource/image/a7/10/a74668eb5bf183538ce9b47a20eb0610.jpg"}不同的语义，触发不同的行为因为语义不同，所以我们给这两种定义函数的方式使用了不同的名称，第一种称之为**函数声明**，第二种称之为**函数表达式。**下面我们就来分别分析下，函数声明和函数表达式的语义，以及 V8是怎么处理函数声明和函数表达式的。V8 是怎么处理函数声明的？我们先来看函数声明，**函数声明**定义了一个具有指定参数的函数，其声明语法如下所示：    function name([param,[, param,[..., param]]]) {       [statements    }接下来我们来看看 V8是怎么处理函数声明的。我们知道，V8 在执行 JavaScript的过程中，会先对其进行编译，然后再执行，比如下面这段代码：    var x = 5    function foo(){        console.log('Foo')    }V8执行这段代码的流程大致如下图所示：![](Images/cd1331e387d2db8962ffe2599131e38a.png)savepage-src="https://static001.geekbang.org/resource/image/49/32/49eb14dd3c00438988595896c348c732.jpg"}在编译阶段，如果解析到函数声明，那么 V8会将这个函数声明转换为内存中的函数对象，并将其放到作用域中。同样，如果解析到了某个变量声明，也会将其放到作用域中，但是会将其值设置为undefined，表示该变量还未被使用。然后在 V8 执行阶段，如果使用了某个变量，或者调用了某个函数，那么 V8便会去作用域查找相关内容。关于作用域的数据，你也可以使用 D8来查看，具体操作方式如下：1.  将这段代码保存到 test.js    中；    2.  使用"d8 \--print-scopes    test.js"命令即可查看作用域的状态。        执行这段指令之后，打印出如下信息：    Global scope:    global { // (0x7fb62281ca48) (0, 50)      // will be compiled      // 1 stack slots      // temporary vars:      TEMPORARY .result;  // (0x7fb62281cfe8) local[0      // local vars:      VAR x;  // (0x7fb62281cc98)      VAR foo;  // (0x7fb62281cf40)      function foo () { // (0x7fb62281cd50) (22, 50)        // lazily parsed        // 2 heap slots      }    }上面这段就是 V8 生成的作用域，我们可以看到，作用域中包含了变量 x 和foo，变量 x 的默认值是 undefined，变量 foo 指向了 foo 函数对象，foo函数对象被 V8存放在内存中的堆空间了，这些变量都是在编译阶段被装进作用域中的。因为在执行之前，这些变量都被提升到作用域中了，所以在执行阶段，V8当然就能获取到所有的定义变量了。我们把这种在编译阶段，将所有的变量提升到作用域的过程称为**变量提升**。了解了变量提升，我们就能解释，为什么可以在函数声明之前调用该函数了，这是因为声明的函数在编译阶段就被提升到作用域中，在执行阶段，只要是在作用域中存在的变量或者对象，都是可以使用的。对于变量提升，函数和普通的对象还是存在一些差异的，通过上面的分析我们知道，如果是一个普通变量，变量提升之后的值都是undefined，如果是声明的函数，那么变量提升之后的值则是函数对象，我们可以通过下面的代码来实践下：    console.log(x)    console.log(foo)    var x = 5    function foo(){    }执行上面这段代码，我们可以看到，普通变量 x 的值就是undefined，而函数对象 foo的值则是完整的对象，那这又是为什么呢？这就是涉及到表达式和语句的区别了。简单地理解，表达式就是表示值的式子，而语句是操作值的式子。比如：     x = 5就是表达式，因为执行这段代码，它会返回一个值。同样，`6 === 5` 也是一个表达式，因为它会返回False。 而语句则不同了，比如你定义了一个变量：    var x这就是一个语句，执行该语句时，V8并不会返回任何值给你。同样，当我声明了一个函数时，这个函数声明也是一个语句，比如下面这段函数声明：    function foo(){      return 1    }当执行到这段代码时，V8 并没有返回任何的值，它只是解析 foo函数，并将函数对象存储到内存中。![](Images/75f146e757d3bbd34c1f942c99e1a83e.png)savepage-src="https://static001.geekbang.org/resource/image/24/43/244971073e6e41d10cefbb1de13bb343.jpg"}表达式和语句了解了表达式和语句的区别，接下来我们继续分析上面的问题。我们知道，在V8 执行`var x = 5`这段代码时，会认为它是两段代码，一段是定义变量的语句，一段是赋值的表达式，如下所示：    var x = undefined    x = 5首先，在变量提升阶段，V8并不会执行赋值的表达式，该阶段只会分析基础的语句，比如变量的定义，函数的声明。而这两行代码是在不同的阶段完成的，`var x`是在编译阶段完成的，也可以说是在变量提升阶段完成的，而`x = 5`是表达式，所有的表达式都是在执行阶段完成的。在变量提升阶段，V8 将这些变量存放在作用域时，还会给它们赋一个默认的undefined值，所以在定义一个普通的变量之前，使用该变量，那么该变量的值就是undefined。 现在我们知道，**表达式是不会在编译阶段执行的**，那么函数声明是表达式还是语句呢？你可以看下面这段函数声明：    function foo(){        console.log('Foo')    }执行上面这段代码，它并没有输出任何内容，所以可以肯定，函数声明并不是一个表达式，而是一个语句。V8在变量提升阶段，如果遇到函数声明，那么 V8同样会对该函数声明执行变量提升操作。函数也是一个对象，所以在编译阶段，V8就会将整个函数对象提升到作用域中，并不是给该函数名称赋一个undefined，理解这一点尤为重要。总的来说，在 V8 解析 JavaScript源码的过程中，如果遇到普通的变量声明，那么便会将其提升到作用域中，并给该变量赋值为undefined，如果遇到的是函数声明，那么 V8会在内存中为声明生成函数对象，并将该对象提升到作用域中。![](Images/a0467652540865284b401ad6537cb23d.png)savepage-src="https://static001.geekbang.org/resource/image/ec/e6/ec7dc43a09baf57985b1cefda1caf4e6.jpg"}V8 是怎么处理函数表达式？了解了函数声明，在来看看函数表达式。**我们在一个表达式中使用 function来定一个函数，那么就把该函数称为函数表达式。**比如：      foo = 1是一个表达式，这时候我们把右边的数字 1替换成函数定义，那么这就变成了函数表达式，如下所示：    foo = function (){        console.log('foo')    }函数表达式与函数声明的最主要区别有以下三点：1.  函数表达式是在表达式语句中使用 function    的，最典型的表达式是"a=b"这种形式，因为函数也是一个对象，我们把"a =    function    (){}"这种方式称为函数表达式；        2.  在函数表达式中，可以省略函数名称，从而创建匿名函数（anonymous    functions）；        3.  一个函数表达式可以被用作一个即时调用的函数表达式------IIFE（Immediately    Invoked Function    Expression）。        了解了函数表达式，我们就来分析这段代码：    foo()    var foo = function (){        console.log('foo')    }当执行这段代码的时候，V8在编译阶段会先查找声明语句，你可以把这段代码拆分为下面两行代码：    var foo = undefined    foo = function (){        console.log('foo')    }第一行是声明语句，所以 V8在解析阶段，就会在作用域中创建该对象，并将该对象设置为undefined，第二行是函数表达式，在编译阶段，V8并不会处理函数表达式，所以也就不会将该函数表达式提升到作用域中了。那么在函数表达式之前调用该函数 foo，此时的 foo 只是指向了undefined，所以就相当于调用一个 undefined，而 undefined只是一个原生对象，并不是函数，所以当然会报错了。立即调用的函数表达式（IIFE）现在我们知道了，在编译阶段，V8 并不会处理函数表达式，而 JavaScript中的**立即函数调用表达式**正是使用了这个特性来实现了非常广泛的应用，下面我们就来一起看看立即函数调用表达式。JavaScript中有一个圆括号运算符，圆括号里面可以放一个表达式，比如下面的代码：    (a=3)括号里面是一个表达式，整个语句也是一个表达式，最终输出3。 如果在小括号里面放上一段函数的定义，如下所示：    (function () {        //statements    })因为小括号之间存放的必须是表达式，所以如果在小阔号里面定义一个函数，那么V8就会把这个函数看成是函数表达式，执行时它会返回一个函数对象。存放在括号里面的函数便是一个函数表达式，它会返回一个函数对象，如果我直接在表达式后面加上调用的括号，这就称**立即调用函数表达式**（IIFE），比如下面代码：    (function () {        //statements    })()因为函数立即表达式也是一个表达式，所以 V8在编译阶段，并不会为该表达式创建函数对象。**这样的一个好处就是不会污染环境，函数和函数内部的变量都不会被其他部分的代码访问到。**在 ES6 之前，JavaScript中没有私有作用域的概念，如果在多人开发的项目中，你模块中的变量可能覆盖掉别人的变量，所以使用函数立即表达式就可以将我们内部变量封装起来，避免了相互之间的变量污染。另外，因为函数立即表达式是立即执行的，所以将一个函数立即表达式赋给一个变量时，不是存储IIFE 本身，而是存储 IIFE执行后返回的结果。如下所示：    var a = (function () {        return 1    })()总结今天我们是要学习 V8 是如何处理函数表达式的。函数表达式在实际的项目应用中非常广，不过由于函数声明和函数表达式之间非常类似，非常容易引起人们的误解，所以我们先从通过两段容易让人误解的代码，分析了函数声明和函数表达式之间的区别。函数声明的本质是语句，而函数表达式的本质则是表达式。函数声明和变量声明类似，V8在编译阶段，都会对其执行变量提升的操作，将它们提升到作用域中，在执行阶段，如果使用了某个变量，就可以直接去作用域中去查找。不过 V8对于提升函数和提升变量的策略是不同的，如果提升了一个变量，那么 V8在将变量提升到作用域中时，还会为其设置默认值undefined，如果是函数声明，那么 V8会在内存中创建该函数对象，并提升整个函数对象。函数表达式也是表达式的一种，在编译阶段，V8并不会将表达式中的函数对象提升到全局作用域中，所以无法在函数表达式之前使用该函数。函数立即表达式是一种特别的表达式，主要用来封装一些变量、函数，可以起到变量隔离和代码隐藏的作用，因此在一些大的开源项目中有广泛的应用。思考题留给你一道经典面试题，看看下面这两段代码打印出来的结果是什么？欢迎你在留言区与我分享讨论。    var n = 1;    (function foo(){        n = 100;        console.log(n);    }())    console.log(n);    var n = 1;    function foo(){        n = 100;        console.log(n);    }    console.log(n);    foo()感谢你的阅读，如果你觉得这篇文章对你有所启发，也欢迎把它分享给你的朋友。