title:Semantics-Aware Android Malware Classification Using Weighted Contextual
API Dependency Graphs
author:Mu Zhang and
Yue Duan and
Heng Yin and
Zhiruo Zhao
Semantics-Aware Android Malware Classiﬁcation Using
Weighted Contextual API Dependency Graphs
Mu Zhang
Yue Duan
Heng Yin
Zhiruo Zhao
Department of EECS, Syracuse University, Syracuse, NY, USA
{muzhang,yuduan,heyin,zzhao11}@syr.edu
ABSTRACT
The drastic increase of Android malware has led to a strong interest
in developing methods to automate the malware analysis process.
Existing automated Android malware detection and classiﬁcation
methods fall into two general categories: 1) signature-based and 2)
machine learning-based. Signature-based approaches can be easily
evaded by bytecode-level transformation attacks. Prior learning-
based works extract features from application syntax, rather than
program semantics, and are also subject to evasion. In this paper,
we propose a novel semantic-based approach that classiﬁes An-
droid malware via dependency graphs. To battle transformation
attacks, we extract a weighted contextual API dependency graph as
program semantics to construct feature sets. To ﬁght against mal-
ware variants and zero-day malware, we introduce graph similarity
metrics to uncover homogeneous application behaviors while toler-
ating minor implementation differences. We implement a prototype
system, DroidSIFT, in 23 thousand lines of Java code. We evaluate
our system using 2200 malware samples and 13500 benign sam-
ples. Experiments show that our signature detection can correctly
label 93% of malware instances; our anomaly detector is capable
of detecting zero-day malware with a low false negative rate (2%)
and an acceptable false positive rate (5.15%) for a vetting purpose.
Categories and Subject Descriptors
D.2.4 [Software Engineering]: Software/Program Veriﬁcation—
Validation; D.4.6 [Operating Systems]: Security and Protection—
Invasive software
General Terms
Security
Keywords
Android; Malware classiﬁcation; Semantics-aware; Graph similar-
ity; Signature detection; Anomaly detection
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright 2014 ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660359.
1.
INTRODUCTION
The number of new Android malware instances has grown ex-
ponentially in recent years. McAfee reports [3] that 2.47 million
new mobile malware samples were collected in 2013, which repre-
sents a 197% increase over 2012. Greater and greater amounts of
manual effort are required to analyze the increasing number of new
malware instances. This has led to a strong interest in developing
methods to automate the malware analysis process.
Existing automated Android malware detection and classiﬁca-
tion methods fall into two general categories: 1) signature-based
and 2) machine learning-based. Signature-based approaches [18,
37] look for speciﬁc patterns in the bytecode and API calls, but they
are easily evaded by bytecode-level transformation attacks [28].
Machine learning-based approaches [5, 6, 27] extract features from
an application’s behavior (such as permission requests and criti-
cal API calls) and apply standard machine learning algorithms to
perform binary classiﬁcation. Because the extracted features are
associated with application syntax, rather than program semantics,
these detectors are also susceptible to evasion.
To directly address malware that evades automated detection,
prior works distill program semantics into graph representations,
such as control-ﬂow graphs [11], data dependency graphs [16, 21]
and permission event graphs [10]. These graphs are checked against
manually-crafted speciﬁcations to detect malware. However, these
detectors tend to seek an exact match for a given speciﬁcation and
therefore can potentially be evaded by polymorphic variants. Fur-
thermore, the speciﬁcations used for detection are produced from
known malware families and cannot be used to battle zero-day mal-
ware.
In this paper, we propose a novel semantic-based approach that
classiﬁes Android malware via dependency graphs. To battle trans-
formation attacks [28], we extract a weighted contextual API de-
pendency graph as program semantics to construct feature sets. The
subsequent classiﬁcation then depends on more robust semantic-
level behavior rather than program syntax. It is much harder for
an adversary to use an elaborate bytecode-level transformation to
evade such a training system. To ﬁght against malware variants
and zero-day malware, we introduce graph similarity metrics to un-
cover homogeneous essential application behaviors while tolerat-
ing minor implementation differences. Consequently, new or poly-
morphic malware that has a unique implementation, but performs
common malicious behaviors, cannot evade detection.
To our knowledge, when compared to traditional semantics-aware
approaches for desktop malware detection, we are the ﬁrst to ex-
amine program semantics within the context of Android malware
classiﬁcation. We also take a step further to defeat malware vari-
ants and zero-day malware by comparing the similarity of these
programs to that of known malware at the behavioral level.
We build a database of behavior graphs for a collection of An-
droid apps. Each graph models the API usage scenario and pro-
gram semantics of the app that it represents. Given a new app, a
query is made for the app’s behavior graphs to search for the most
similar counterpart in the database. The query result is a similarity
score which sets the corresponding element in the feature vector of
the app. Every element of this feature vector is associated with an
individual graph in the database.
We build graph databases for two sets of behaviors: benign and
malicious. Feature vectors extracted from these two sets are then
used to train two separate classiﬁers for anomaly detection and sig-
nature detection. The former is capable of discovering zero-day
malware, and the latter is used to identify malware variants.
We implement a prototype system, DroidSIFT, in 23 thousand
lines of Java code. Our dependency graph generation is built on
top of Soot [2], while our graph similarity query leverages a graph
matching toolkit [29] to compute graph edit distance. We evaluate
our system using 2200 malware samples and 13500 benign sam-
ples. Experiments show that our signature detection can correctly
label 93% malware instances; our anomaly detector is capable of
detecting zero-day malware with a low false negative rate (2%) and
an acceptable false positive rate (5.15%) for vetting purpose.
In summary, this paper makes the following contributions:
• We propose a semantic-based malware classiﬁcation to ac-
curately detect both zero-day malware and unknown variants
of known malware families. We model program semantics
with weighted contextual API dependency graphs, introduce
graph similarity metrics to capture homogeneous semantics
in malware variants or zero-day malware samples, and en-
code similarity scores into graph-based feature vectors to en-
able classiﬁers for anomaly and signature detections.
• We implement a prototype system, DroidSIFT, that performs
static program analysis to generate dependency graphs. Droid-
SIFT builds graph databases and produces graph-based fea-
ture vectors by performing graph similarity queries. It then
uses the feature vectors of benign and malware apps to con-
struct two separate classiﬁers that enable anomaly and signa-
ture detections, respectively.
• We evaluate the effectiveness of DroidSIFT using 2200 mal-
ware samples and 13500 benign samples. Experiments show
that our signature detection can correctly label 93% malware
instances; our anomaly detector is capable of detecting zero-
day malware with a low false negative rate (2%) and an ac-
ceptable false positive rate (5.15%) for vetting purpose.
Paper Organization. The rest of the paper is organized as follows.
Section 2 describes the deployment of our learning-based detection
mechanism and gives an overview of our malware classiﬁcation
technique. Section 3 deﬁnes our graph representation of Android
program semantics and explains our graph generation methodol-
ogy. Section 4 elaborates graph similarity query, the extraction of
graph-based feature vectors and learning-based anomaly & signa-
ture detection. Section 5 shows the experimental results of our ap-
proach. Discussion and related work are presented in Section 6
and 7, respectively. Finally, the paper concludes with Section 8.
2. OVERVIEW
In this section, we present an overview of the problem and the
deployment and architecture of our proposed solution.
2.1 Problem Statement
An effective vetting process for discovering malicious software
is essential for maintaining a healthy ecosystem in the Android app
markets. Unfortunately, existing vetting processes are still fairly
Figure 1: Deployment of DroidSIFT
rudimentary. As an example, consider the Bouncer [22] vetting
system that is used by the ofﬁcial Google Play Android market.
Though the technical details of Bouncer are not publicly avail-
able, experiments by Oberheide and Miller [24] show that Bouncer
performs dynamic analysis to examine apps within an emulated
Android environment for a limited period of time. This method
of analysis can be easily evaded by apps that perform emulator
detection, contain hidden behaviors that are timer-based, or oth-
erwise avoid triggering malicious behavior during the short time
period when the app is being vetted. Signature detection tech-
niques adopted by the current anti-malware products have also been
shown to be trivially evaded by simple bytecode-level transforma-
tions [28].
We propose a new technique, DroidSIFT, illustrated in Figure 1,
that addresses these shortcomings and can be deployed as a re-
placement for existing vetting techniques currently in use by the
Android app markets. This technique is based on static analysis,
which is immune to emulation detection and is capable of analyz-
ing the entirety of an app’s code. Further, to defeat bytecode-level
transformations, our static analysis is semantics-aware and extracts
program behaviors at the semantic level. More speciﬁcally, we
achieve the following design goals:
• Semantic-based Detection. Our approach detects malware
instances based on their program semantics. It does not rely
on malicious code patterns, external symptoms, or heuristics.
Our approach is able to perform program analysis for both
the interpretation and demonstration of inherent program de-
pendencies and execution contexts.
• High Scalability. Our approach is scalable to cope with
millions of unique benign and malicious Android app sam-
ples. It addresses the complexity of static program analysis,
which can be considerably expensive in terms of both time
and memory resources, to perform precisely.
• Variant Resiliency. Our approach is resilient to polymor-
phic variants. It is common for attackers to implement ma-
licious functionalities in slightly different manners and still
be able to perform the expected malicious behaviors. This
malware polymorphism can defeat detection methods that
are based on exact behavior matching, which is the method
prevalently adopted by existing signature-based detection and
graph-based model checking. To address this, our technique
is able to measure the similarity of app behaviors and tolerate
such implementation variants by using similarity scores.
Consequently, we are able to conduct two kinds of classiﬁca-
tions: anomaly detection and signature detection. Upon receiving a
new app submission, our vetting process will conduct anomaly de-
tection to determine whether it contains behaviors that signiﬁcantly
deviate from the benign apps within our database. If such a devia-
tion is discovered, a potential malware instance is identiﬁed. Then,
we conduct further signature detection on it to determine if this app
falls into any malware family within our signature database. If so,
the app is ﬂagged as malicious and bounced back to the developer
immediately.
Android App MarketOnline DetectionOffline Graph Database Construction & Training PhaseUpdate Database & ClassifiersDeveloperSubmitVetReportFigure 2: Overview of DroidSIFT
If the app passes this hurdle, it is still possible that a new malware
species has been found. We bounce the app back to the developer
with a detailed report when suspicious behaviors that deviate from
benign behaviors are discovered, and we request justiﬁcation for
the deviation. The app is approved only after the developer makes
a convincing justiﬁcation for the deviation. Otherwise, after fur-
ther investigation, we may conﬁrm it to indeed be a new malware
species. By placing this information into our malware database, we
further improve our signature detection to detect this new malware
species in the future.
It is also possible to deploy our technique via a more ad-hoc
scheme. For example, our detection mechanism can be deployed as
a public service that allows a cautious app user to examine an app
prior to its installation. An enterprise that maintains its own private
app repository could utilize such a security service. The enterprise
service conducts vetting prior to adding an app to the internal app
pool, thereby protecting employees from apps that contain malware
behaviors.
2.2 Architecture Overview
Figure 2 depicts the workﬂow of our graph-based Android mal-
ware classiﬁcation. This takes the following steps:
(1) Behavior Graph Generation. Our malware classiﬁcation con-
siders graph similarity as the feature vector. To this end, we
ﬁrst perform static program analysis to transform Android byte-
code programs into their corresponding graph representations.
Our program analysis includes entry point discovery and call
graph analysis to better understand the API calling contexts,
and it leverages both forward and backward dataﬂow analysis
to explore API dependencies and uncover any constant parame-
ters. The result of this analysis is expressed via Weighted Con-
textual API Dependency Graphs that expose security-related
behaviors of Android apps.
(2) Scalable Graph Similarity Query. Having generated graphs
for both benign and malicious apps, we then query the graph
database for the one graph most similar to a given graph. To
address the scalability challenge, we utilize a bucket-based in-
dexing scheme to improve search efﬁciency. Each bucket con-
tains graphs bearing APIs from the same Android packages,
and it is indexed with a bitvector that indicates the presence of
such packages. Given a graph query, we can quickly seek to the
corresponding bucket index by matching the package’s vector
to the bucket’s bitvector. Once a matching bucket is located,
we further iterate this bucket to ﬁnd the best-matching graph.
Finding the best-matching graph, instead of an exact match, is
necessary to identify polymorphic malware.
(3) Graph-based Feature Vector Extraction. Given an app, we
attempt to ﬁnd the best match for each of its graphs from the
database. This produces a similarity feature vector. Each ele-
ment of the vector is associated with an existing graph in the
database. This vector bears a non-zero similarity score in one
element only if the corresponding graph is the best match to
one of the graphs for the given app.
(4) Anomaly & Signature Detection. We have implemented a
signature classiﬁer and an anomaly detector. We have produced
feature vectors for malicious apps, and these vectors are used
to train the classiﬁer for signature detection. The anomaly de-
tection discovers zero-day Android malware, and the signature
detector uncovers the type (family) of the malware.
3. WEIGHTED CONTEXTUAL API DEPEN-
DENCY GRAPH
In this section, we describe how we capture the semantic-level
behaviors of Android malware in the form of graphs. We start