——————————
31
① 日语中有严格的敬语体系。当对方为长辈、上级、合作伙伴时须使用敬语。——译者注
图灵社区会员 metorm 专享 尊重版权
700 …… 第31天：写在开发完成之后
可以想象一下屏幕后面不是你的分身，而就是你自己，在不停地升级。这么说感觉好像在跟大家
推销似的（笑）。那就再说说相反的情况，一本不便宜的书，买了之后觉得后悔的话那真是太伤
心了，因此请大家听听读过这本书的人的感想，或者先试读一部分，仔细考虑之后再购买。也可
以跟同样的价钱能买到的别的东西（比如可以买几根巧克力棒之类的）对比一下，考虑考虑买了
对你是不是有价值。不过这种话写在最后好像没什么意义了嘛，如果看到这里的应该是已经买了
吧……
作为笔者来说，已经在内容的充实方面做了很多努力。既然定价的调整是有限度的，那么如
果能让内容的质量提高到原来的两倍，就相当于价格降到了一半。虽说这本书还远远没达到两倍
的标准，但笔者确实已经尽了自己最大的努力。
■■■■■
讲解的长短以及整体的节奏也是经过仔细调整的，如果加快节奏，以笔者的能力恐怕会讲不
清楚。如果把本书这些内容两天并作一天来写的话，用15章的篇幅就可以搞定了，但各位读者当
中一定会有人消化不良的。
光看本书的书名“30天自制操作系统”，对于毫无操作系统相关知识的人来说，可能会觉得
“什么嘛，居然要30天那么长啊”，笔者也知道30天有点长，但以现在的节奏，到第20天就结束的
话，感觉实在是很可惜（不信的话可以看看第20天时的样子……我们刚刚开始编写API呢），想想
看仅仅多了10天的内容，我们的系统就变得好玩多了。如果在第10天或者第15天收尾就更无法接
受了，完全体现不出编写操作系统的乐趣。
反过来说，如果我们将开发周期延长到40天或者50天，那一定能做出更有意思的系统。不过
笔者的体力实在是支撑不了，好想休息一下呀。况且如果书名变成《50天自制操作系统》，估计
各位读者更要敬而远之了吧。
对于操作系统，笔者有很多自己的观点，其中之一就是操作系统应自带文件压缩功能。但这
个观点并未成为操作系统界的常识，因此笔者也就没有过多地讨论，而是在29.2节中，仅以缩小
字库文件大小为目的加入了压缩功能，关于压缩对操作系统的重要性也只字未提。
若操作系统自带压缩功能是常识，笔者就会在29.2节中，从构思基本算法开始，对tek压缩进
行详细的介绍，或者说是十分想向大家介绍。很遗憾，我们的篇幅有限，无论如何也无法在这本
书中展开这个话题。
笔者对于操作系统的这些观点，大部分都在OSASK中有所体现，但在本书的撰写过程中，
却尽量避免将这些观点流露出来，也没有将OSASK搬出来，跟大家吹嘘“怎么样，这个功能也
有哦，很厉害吧”之类的，因为这样做一点意思都没有。笔者不想给大家强加先入为主的观念，
而将大家好不容易冒出来的好点子给扼杀掉。
因此，笔者只向大家介绍编写操作系统的技术，并希望各位读者能自由发挥想象力，开发出
图灵社区会员 metorm 专享 尊重版权
7 后记 …… 701
各种各样不同的操作系统。如果大家开发出来的操作系统都像OSASK的克隆一样，那自制操作
1
系统的世界也就没有进步，变得相当无聊了。
18
■■■■■
临近收尾，预定的截稿日一拖再拖，实在是给编辑添了不少麻烦，笔者能力有限，实在抱歉。
3
另外，对于出版社能够听取笔者的建议，也表示衷心的感谢。
在这里，还要向临近考试还参与本书校对的初中生读者代表DAsoran同学、高中生代表uchan
20
同学，以及对本书做出很多客观诚恳指摘的成人读者代表若生启表示感谢。
还有为本书绘制插图以及制作各种示意图的hideyosi，真是帮了大忙，在此表示感谢。
21
还要感谢OSASK社区的各位成员。在这一年多的时间里，为了撰写这本书，而中断了OSASK
的开发，在此期间，虽然有些抱怨，但大家还是坚持了下来。归根结底，也是承蒙社区各位成员
22
的厚爱，便OSASK一举成名，笔者才能有机会出版本书。
当然，最要感谢的是现在正在读这本书的你，谢谢。
7
■■■■■
8
哎呀，再多说几句。如果各位想给笔者发邮件，请发送到下面的邮箱①：
Hidemi KAWAI 
9
不过，笔者不能保证对收到的来信一一回复。如果是提问或者感想的话，请尽量到支持网页
的论坛中发帖，这样的话，笔者之外的人也可以看到以及回帖，应该可以更快地得到有用的回答。
26
如果想给笔者发私人邮件，回复慢了或者收不到回复也无所谓的话，那么请发到上面的邮箱吧。
这也能叫自制操作系统？太坑爹了！（以下内容不是面向初学 27
COLUMN-12
者的）
28
说到编写操作系统，难道不该先从应该编写一个怎样的操作系统开始讨论吗？要编写多
任务操作系统，如何解决访问冲突难道不是最重要的吗？连文件系统都没有设计怎么能算是
自制操作系统啊！根本没有考虑设备驱动程序的问题嘛！内存不足时的处理实在是不够完善 29
啊！窗口系统也太粗糙了点吧？中断处理的少许优化、窗口移动的加速、加入压缩功能之类
的，都不算是操作系统中本质的部分，难道不该减少这部分内容的篇幅，将重点更多地放在
30
操作系统的本质上吗？如果操作系统都照这样来做，那世上的操作系统得有多不靠谱啊！
且先不论自制操作系统这个主题，想要找点这本书的好处难啊。作为汇编语言的入门吧，
16
——————————
① 请发送到下面的邮箱：在某些文档中，笔者的邮箱可能写的是这个：PI:EMAIL，这个地址现在已经不用了， 31
因此请不要发到这里。
图灵社区会员 metorm 专享 尊重版权
702 …… 第31天：写在开发完成之后
对于指令的讲解也太少了；作为C语言的入门吧，对语法的讲解又不充分；作为算法的入门
吧，还需要介绍很多其他的东西才行。无论哪个都是只有半瓶醋，没什么用处。这种对操作
系统大小的过度追求，对编程初学者来说难道不是有害的吗？
像上面这种质疑的声音是肯定会有的，没错没错，你说得对，这本书的确有上面这些不
足之处。不过，笔者在写这本书的时候，可并不是对这些不足一无所知的哦（关于操作系统
大小的那一点，笔者认为是有益而不是有害的）。
■■■■■
“从失败中学习”是贯穿本书的一个理念。当然，一开始在什么都不知道的情况下，也
谈不上失败，因此笔者就先单方面地进行一些讲解，而随着内容的进行，我们一般是先随便
做一个版本，然后发现这个版本的缺陷之后再进行改良。因此，可能你看到“纸娃娃系统”
在访问冲突方面考虑不周，其实笔者是故意这样做的。有更多篇幅的话，就可以利用访问冲
突让“纸娃娃系统”崩溃一次，然后再引出改良的话题。
或者说，笔者正是因为清楚这些不足才希望各位指教。如果你能指出其中的不足，而且
可以提出对策的话，那笔者就可以直接将这些对策告诉各位读者了。也就是说，你可以为这
本书来撰写续篇了。所以别客气，请多多指教吧。
■■■■■
当然，这个“从失败中学习”的理念恐怕也会遭到一些质疑吧。如果不经过这些失败的
例子，从一开始就条理清楚地讲解各个功能的必要性，整个篇幅就可以缩短，最终的操作系
统完成度也会提高，大概有15天左右就可以达到现在的完成度了吧。可是那样的讲解到底效
果如何呢？是不是能通俗易懂呢？用算术来举例，我们不要一上来就介绍乘法运算，而是先
用反复的加法运算先凑合一段时间，等实在觉得太麻烦受不了的时候，再介绍乘法运算，这
样一下子就可以感受到乘法运算的便利，也就更有动力去背九九乘法表了。
对这本书的标题感兴趣的读者，一定都曾经萌发过编写操作系统的念头吧。因此凡是可
能会对读者的兴趣产生不利影响的东西，笔者都尽量避免。在使用汇编语言时，尽量减少所
使用指令的种类；对C语言的语法并非完全讲解，而是仅限于其中容易理解的部分（或者说
是不用的话反而会变得更难懂的部分）。
对于笔者来说，这的确是颇具挑战性的。“纸娃娃系统”到底能用多简单的语法实现丰
富的功能，这是个挑战；到底能用多简单的知识就能完成一个操作系统，也是一个挑战。大
家可能也不止一次会想，在某些地方使用更高级的命令会更好。笔者也想过在某些地方使用
一些高级的算法，也想过为了本书的读者将来能读懂其他程序而对C语言一些其他的语法进
行讲解，但是这些笔者都没有做，因为一旦开始这样的话题，可能就没完没了了。
图灵社区会员 metorm 专享 尊重版权
8 毕业典礼 …… 703
■■■■■ 1
本书的主旨就是要让本来很难的东西看上去变得很容易。只要看上去很容易，读者就会
18
在基本理解的基础上有动力继续读下去（有些无法实际感受到的东西也不是很重要，只要基
本上理解了就没有问题），读到后面发现前面的东西其实并没有完全理解，这时只要再翻回
3
前面看看就可以了。如果本来就很难的东西，还要用很难的方式去讲解，那读者马上就会厌
倦的，因此笔者尽量避免出现这种情况。
当然，把本来简单的东西搞得很复杂，那就更不应该了。 20
在内容的先后上笔者也花了心思。从操作系统的重要功能开始做，这种观点对于本书来
说是不成立的。本书是从简单的、好看的、效果容易理解的、有成就感的、而且是对操作系
21
统有必要的部分开始，逐步进行开发的。因此，可能会出现一些不太寻常的东西。例如为了
介绍操作系统的核心，从一开始就引入了bim2hrb.exe，其实这个工具是应用程序用的连接器。
22
也就是说，本来应该在编写应用程序的时候才引入bim2hrb.exe的，但我们却在一开始几乎不
加说明地引入了bim2hrb.exe。另外，在本书中根本没有操作系统用的连接器，这也是在内容
上花了心思的结果。 7
在编写“纸娃娃系统”的过程中，有很多涉及对速度进行优化的内容，现在想想看，其
中有一些内容感觉不是非常有必要。不过，在撰写那些章节的时候，考虑到这个算法在以后
8
还可以派上别的用场，因此附带提一提。另一方面，其实优化速度本身在某些情况下还是相
当重要的。如果因为没有优化而造成速度很慢，读者可能会误以为“果然初学者做出的系统，
9
速度没办法达到像Windows和Linux那样实用的程度”，从而影响了开发的斗志。
26
■■■■■
嗯，就说这么多吧，如果无法接受这些观点也没关系，但希望大家在批判前能理解笔者 27
的想法。
28
88 毕业典礼
29
/* 《友谊天长地久》苏格兰民谣①*/
$E"SJIS"; T100L4O4 30
$K"ほたるのひかり まどのゆき"; CF.F8FAG.F8GAFFA>CD2&D8R8
16
——————————
① 这里和30.3节的情况相同，如果大家没有将日文显示改造成中文显示，则还是要使用日文歌词才能在应用程序中
正常显示出来。这首歌是苏格兰民谣，在日本的中小学毕业典礼上经常会演唱，中文版就是大家所熟悉的《友谊 31
地久天长》。——译者注
图灵社区会员 metorm 专享 尊重版权
704 …… 第31天：写在开发完成之后
$K"书(ふみ)よむつき日 かさねつつ"; DC.
$K"いつしか年も すぎのとを"; DC.DC.CD2&D8R8
$K"あけてぞ けさは わかれゆく"; DC.<A8AFG.F8GAF.D8DCF2&F8R8
$K""; R
99 附录
这本书如果按顺序读下来的话应该还是一本不错的书，不过在读过一遍之后，忽然想知道关
于某个知识点是在哪里讲解的，找起来可就麻烦了。此外，如果对于某个函数的写法不太理解，
想找到这个写法是在哪个章节提到的，就更加麻烦了。
因此，我们在这里提供了一个简单的函数索引。它是在bootpack.h和apilib.h的代码中加上注
释所构成的，通过这个索引，就可以追溯到某个函数是在哪个章节进行过修改了。
bootpack.h
/* asmhead.nas */
struct BOOTINFO { /* 0x0ff0.0x0fff */ /* 5.2, 6.3, 18.7 */
char cyls; /* 引导扇区读取到磁盘的哪个位置 */
char leds; /* 引导时键盘的LED状态 */
char vmode; /* 显卡的颜色位数 */
char reserve;
short scrnx, scrny; /* 画面分辨率 */
char *vram;
};
#define ADR_BOOTINFO 0x00000ff0
#define ADR_DISKIMG 0x00100000
/* naskfunc.nas */
void io_hlt(void); /* 3.9, 4.6 */
void io_cli(void); /* 4.6 */
void io_sti(void); /* 4.6 */
void io_stihlt(void); /* 4.6 */
int io_in8(int port); /* 4.6 */
void io_out8(int port, int data); /* 4.6 */
int io_load_eflags(void); /* 4.6 */
void io_store_eflags(int eflags); /* 4.6 */
void load_gdtr(int limit, int addr); /* 6.4 */
void load_idtr(int limit, int addr);
int load_cr0(void); /* 9.2 */
void store_cr0(int cr0); /* 9.2 */
void load_tr(int tr); /* 15.1 */
void asm_inthandler0c(void); /* 22.2 */
void asm_inthandler0d(void); /* 21.5, 21.6 */
void asm_inthandler20(void); /* 12.1, 21.4, 21.6 */
void asm_inthandler21(void); /* 6.6 */
void asm_inthandler2c(void);
unsigned int memtest_sub(unsigned int start, unsigned int end); /* 9.2, 9.3 */
void farjmp(int eip, int cs); /* 15.3 */
void farcall(int eip, int cs); /* 20.4 */
图灵社区会员 metorm 专享 尊重版权
9 附录 …… 705
void asm_hrb_api(void); /* 20.8, 21.4, 21.6 */
1
void start_app(int eip, int cs, int esp, int ds, int *tss_esp0); /* 21.4, 21.6 */
void asm_end_app(void); /* 22.3 */
/* fifo.c */ 18
struct FIFO32 { /* 13.4, 16.2 */
int *buf;
int p, q, size, free, flags; 3
struct TASK *task;
};
void fifo32_init(struct FIFO32 *fifo, int size, int *buf, struct TASK *task); /* 13.4, 16.2 */
20
int fifo32_put(struct FIFO32 *fifo, int data); /* 13.4, 16.2, 16.4, 16.5 */
int fifo32_get(struct FIFO32 *fifo); /* 13.4 */
int fifo32_status(struct FIFO32 *fifo); /* 13.4 */
21
/* graphic.c */
void init_palette(void); /* 4.6, 25.2 */
void set_palette(int start, int end, unsigned char *rgb); /* 4.6 */
22
void boxfill8(unsigned char *vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1);
/* 4.7 */
void init_screen8(char *vram, int x, int y);
void putfont8(char *vram, int xsize, int x, int y, char c, char *font); /* 5.4 */ 7
void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s); /* 5.6, 28.5,
28.6, 28.7 */
void init_mouse_cursor8(char *mouse, char bc); /* 5.8 */
8
void putblock8_8(char *vram, int vxsize, int pxsize, /* 5.8 */
int pysize, int px0, int py0, char *buf, int bxsize);
#define COL8_000000 0
#define COL8_FF0000 1 9
#define COL8_00FF00 2
#define COL8_FFFF00 3
#define COL8_0000FF 4 26
#define COL8_FF00FF 5
#define COL8_00FFFF 6
#define COL8_FFFFFF 7
#define COL8_C6C6C6 8 27
#define COL8_840000 9
#define COL8_008400 10
#define COL8_848400 11 28
#define COL8_000084 12