## 通过 D 触发器实现存储功能有了时钟信号，我们的系统里就有了一个像"自动门"一样的开关。利用这个开关和相同的反馈电路，我们就可以构造出一个有"记忆"功能的电路。这个有记忆功能的电路，可以实现在CPU中用来存储计算结果的寄存器，也可以用来实现计算机五大组成部分之一的存储器。![](Images/7492b366515d0753f60b378a2563961f.png){savepage-src="https://static001.geekbang.org/resource/image/dc/de/dc6dcce612b2fd51939d7ec44b3fe1de.jpeg"}我们先来看下面这个 RS触发器电路。这个电路由两个或非门电路组成。我在图里面，把它标成了 A 和B。![](Images/810010b3585eac4a6315bf3247016a84.png){savepage-src="https://static001.geekbang.org/resource/image/7d/a9/7dd38282b8862cb6541ee82e76e1e0a9.jpg"}```{=html}```或非门的真值表]{.reference}```{=html}```1.  在这个电路一开始，输入开关都是关闭的，所以或非门（NOR）A 的输入是 0    和 0。对应到我列的这个真值表，输出就是 1。而或非门 B 的输入是 0 和 A    的输出 1，对应输出就是 0。B 的输出 0 反馈到    A，和之前的输入没有变化，A 的输出仍然是 1。而整个电路的**输出    Q**，也就是 0。2.  当我们把 A 前面的开关 R 合上的时候，A 的输入变成了 1 和    0，输出就变成了 0，对应 B 的输入变成 0 和 0，输出就变成了 1。B    的输出 1 反馈给到了 A，A 的输入变成了 1 和 1，输出仍然是 0。所以把 A    的开关合上之后，电路仍然是稳定的，不会像晶振那样振荡，但是整个电路的**输出    Q**变成了 1。3.  这个时候，如果我们再把 A 前面的开关 R 打开，A 的输入变成和 1 和    0，输出还是 0，对应的 B 的输入没有变化，输出也还是 1。B 的输出 1    反馈给到了 A，A 的输入变成了 1 和 0，输出仍然是    0。这个时候，电路仍然稳定。**开关 R 和 S    的状态和上面的第一步是一样的，但是最终的输出 Q 仍然是 1，**和第 1    步里 Q    状态是相反的。我们的输入和刚才第二步的开关状态不一样，但是输出结果仍然保留在了第    2 步时的输出没有发生变化。4.  这个时候，只有我们再去关闭下面的开关 S，才可以看到，这个时候，B    有一个输入必然是 1，所以 B 的输出必然是 0，也就是电路的最终**输出    Q**必然是 0。这样一个电路，我们称之为触发器（Flip-Flop）。接通开关 R，输出变为1，即使断开开关，输出还是 1 不变。接通开关 S，输出变为0，即使断开开关，输出也还是0。也就是，**当两个开关都断开的时候，最终的输出结果，取决于之前动作的输出结果，这个也就是我们说的记忆功能**。这里的这个电路是最简单的 RS触发器，也就是所谓的复位置位触发器（Reset-Set Flip Flop)。对应的输出结果的真值表，你可以看下面这个表格。可以看到，当两个开关都是0 的时候，对应的输出不是 1 或者 0，而是和 Q 的上一个状态一致。![](Images/40cb21ab573acbcdccbafeedde1fb332.png){savepage-src="https://static001.geekbang.org/resource/image/ac/cb/acc43093e8f0da21b660b4cb5d3d05cb.jpg"}再往这个电路里加两个与门和一个小小的时钟信号，我们就可以实现一个利用时钟信号来操作一个电路了。这个电路可以帮我们实现什么时候可以往Q 里写入数据。我们看看下面这个电路，这个在我们的上面的 R-S 触发器基础之上，在 R 和 S开关之后，加入了两个与门，同时给这两个与门加入了一个**时钟信号CLK**作为电路输入。这样，当时钟信号 CLK 在低电平的时候，与门的输入里有一个 0，两个实际的 R和 S 后的与门的输出必然是 0。也就是说，无论我们怎么按 R 和 S的开关，根据 R-S 触发器的真值表，对应的 Q 的输出都不会发生变化。只有当时钟信号 CLK 在高电平的时候，与门的一个输入是1，输出结果完全取决于 R 和 S 的开关。我们可以在这个时候，通过开关 R 和S，来决定对应 Q 的输出。![](Images/b205a1697621037cfcf0486e9f7051c5.png){savepage-src="https://static001.geekbang.org/resource/image/9e/d8/9e9bc411aa8c7bf2f080f306a0fb8bd8.jpeg"}```{=html}```通过一个时钟信号，我们可以在特定的时间对输出的 Q进行写入操作]{.reference}```{=html}```如果这个时候，我们让 R 和 S的开关，也用一个反相器连起来，也就是通过同一个开关控制 R 和 S。只要 CLK信号是 1，R 和 S 就可以设置输出 Q。而当 CLK 信号是 0 的时候，无论 R 和 S怎么设置，输出信号 Q 是不变的。这样，这个电路就成了我们最常用的 D型触发器。用来控制 R 和 S 这两个开关的信号呢，我们视作一个输入的数据信号D，也就是 Data，这就是 D 型触发器的由来。![](Images/2e469540ca359c9e85aa423c08cacaab.png){savepage-src="https://static001.geekbang.org/resource/image/d7/bb/d749acce21756d89c35ee19545cfebbb.jpeg"}```{=html}```把 R 和 S 两个信号通过一个反相器合并，我们可以通过一个数据信号 D 进行 Q的写入操作]{.reference}```{=html}```一个 D 型触发器，只能控制 1 个比特的读写，但是如果我们同时拿出多个 D型触发器并列在一起，并且把用同一个 CLK 信号控制作为所有 D型触发器的开关，这就变成了一个 N 位的 D 型触发器，也就可以同时控制 N位的读写。CPU 里面的寄存器可以直接通过 D 型触发器来构造。我们可以在 D型触发器的基础上，加上更多的开关，来实现清 0 或者全部置为 1这样的快捷操作。
## 总结延伸好了，到了这里，我们可以顺一顺思路了。通过引入了时序电路，我们终于可以把数据"存储"下来了。我们通过反馈电路，创建了时钟信号，然后再利用这个时钟信号和门电路组合，实现了"状态记忆"的功能。电路的输出信号不单单取决于当前的输入信号，还要取决于输出信号之前的状态。最常见的这个电路就是我们的D 触发器，它也是我们实际在 CPU 内实现存储功能的寄存器的实现方式。这也是现代计算机体系结构中的"冯·诺伊曼"机的一个关键，就是程序需要可以"存储"，而不是靠固定的线路连接或者手工拨动开关，来实现计算机的可存储和可编程的功能。有了时钟信号和触发器之后，我们还差一个"自动"需求没有实现。我们的计算机还不能做到自动地不停地从内存里面读取指令去执行。这一部分，我们留在下一讲。下一讲里，我们看看怎么让程序自动运转起来。
## 推荐阅读想要深入了解计算机里面的各种功能组件，是怎么通过电路来实现的，推荐你去阅读《编码：隐匿在计算机软硬件背后的语言》这本书的第14 章和 16 章。如果对于数字电路和数字逻辑特别感兴趣，想要彻底弄清楚数字电路、时序逻辑电路，也可以看一看计算机学科的一本专业的教科书《数字逻辑应用与设计》。
## 课后思考现在我们的 CPU 主频非常高了，通常在几 GHz了，但是实际上我们的晶振并不能提供这么高的频率，而是通过"外频 +倍频"的方式来实现高频率的时钟信号。请你研究一下，倍频和分频的信号是通过什么样的电路实现的？欢迎留言和我分享你的疑惑和见解，也欢迎你把今天的内容分享给你的朋友，和他一起学习和进步。![](Images/79d06107d349635530fbf82aa8dfb625.png){savepage-src="https://static001.geekbang.org/resource/image/28/29/281ca28b90c8aa0aecbb5adc08394f29.jpg"}
# 19 \| 建立数据通路（下）：指令+运算=CPU上一讲，我们讲解了时钟信号是怎么实现的，以及怎么利用这个时钟信号，来控制数据的读写，可以使得我们能把需要的数据"存储"下来。那么，这一讲，我们要让计算机"自动"跑起来。通过一个时钟信号，我们可以实现计数器，这个会成为我们的 PC寄存器。然后，我们还需要一个能够帮我们在内存里面寻找指定数据地址的译码器，以及解析读取到的机器指令的译码器。这样，我们就能把所有学习到的硬件组件串联起来，变成一个CPU，实现我们在计算机指令的执行部分的运行步骤。
## PC 寄存器所需要的计数器我们常说的 PC寄存器，还有个名字叫程序计数器。下面我们就来看看，它为什么叫作程序计数器。有了时钟信号，我们可以提供定时的输入；有了 D型触发器，我们可以在时钟信号控制的时间点写入数据。我们把这两个功能组合起来，就可以实现一个自动的计数器了。加法器的两个输入，一个始终设置成 1，另外一个来自于一个 D 型触发器A。我们把加法器的输出结果，写到这个 D 型触发器 A 里面。于是，D型触发器里面的数据就会在固定的时钟信号为 1 的时候更新一次。![](Images/173156b160fbdb303b8163392b09c77b.png){savepage-src="https://static001.geekbang.org/resource/image/1e/4c/1ed21092022057ed192a7d9aff76144c.jpg"}这样，我们就有了一个每过一个时钟周期，就能固定自增 1的自动计数器了。这个自动计数器，可以拿来当我们的 PC 寄存器。事实上，PC寄存器的这个 PC，英文就是 Program Counter，也就是**程序计数器**的意思。``{=html}每次自增之后，我们可以去对应的 D型触发器里面取值，这也是我们下一条需要运行指令的地址。前面第 5讲我们讲过，同一个程序的指令应该要顺序地存放在内存里面。这里就和前面对应上了，顺序地存放指令，就是为了让我们通过程序计数器就能定时地不断执行新指令。加法计数、内存取值，乃至后面的命令执行，最终其实都是由我们一开始讲的时钟信号，来控制执行时间点和先后顺序的，这也是我们需要时序电路最核心的原因。在最简单的情况下，我们需要让每一条指令，从程序计数，到获取指令、执行指令，都在一个时钟周期内完成。如果PC寄存器自增地太快，程序就会出错。因为前一次的运算结果还没有写回到对应的寄存器里面的时候，后面一条指令已经开始读取里面的数据来做下一次计算了。这个时候，如果我们的指令使用同样的寄存器，前一条指令的计算就会没有效果，计算结果就错了。在这种设计下，我们需要在一个时钟周期里，确保执行完一条最复杂的 CPU指令，也就是耗时最长的一条 CPU 指令。这样的 CPU设计，我们称之为**单指令周期处理器**（Single Cycle Processor）。很显然，这样的设计有点儿浪费。因为即便只调用一条非常简单的指令，我们也需要等待整个时钟周期的时间走完，才能执行下一条指令。在后面章节里我们会讲到，通过流水线技术进行性能优化，可以减少需要等待的时间，这里我们暂且说到这里。