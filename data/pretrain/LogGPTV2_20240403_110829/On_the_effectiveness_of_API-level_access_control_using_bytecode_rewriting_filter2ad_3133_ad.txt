tion.
Other researches have modiﬁed the Android OS
to monitor the data ﬂow, detect data leakage and permis-
sion exploits [15, 18, 20, 28]. TISSA modiﬁed the Android
OS to provide ﬁne-grained protection on personal informa-
tion [28]. TaintDroid performs taint analysis on applications
and checks for privacy leakage [15]. Hornyack et al. mod-
iﬁed the Android OS to replace private data with dummy
data when the data are oﬀered to applications [18]. It also
blocks network transmissions if they contain data that are
not supposed to be sent out. The main drawbacks of the
OS-modiﬁcation approach is the lack of ﬂexibility and the
need to update the phones.
Several
Bytecode rewriting for other purposes.
works use bytecode rewriting to instrument Android appli-
cations [23, 25], although not for enforcing API-level access
control. Adsplit used bytecode rewriting to remove adver-
tisement components to another advertisement service [25].
The work in [23] used bytecode rewriting to bind applica-
tions to fake Market app instead of the genuine one, so at-
tacks can be launched in Google In-App Billing.
8. CONCLUSION AND FUTURE WORK
API-level access control using bytecode rewriting is a com-
mon technique used by existing work to provide ﬁne-grained
access control in Android. To fully understand how secure
this technique is, we have conducted a systematic study on
the eﬀectiveness of the implementation of this technique.
We have identiﬁed several new attacks. Although all the
problems are ﬁxable, our work manifests the need to per-
form more static analysis and dynamic checking should be
Figure 10: Successful Attack on Geolocation App
Note that android.os.ServiceManager is hidden in
Android framework, which means the compiler would throw
an error when an application tries to invoke any methods of
it. At runtime android.os.ServiceManager is already
loaded by DVM when application is started. However, one
can cheat the compiler by writing a dummy android.os.
ServiceManager to overcome compile time error.
my.location.LocMgr.getLastKnownLocation has
diﬀerent method signature compared to that of android.
location.LocationManager.getLastKnownLocation.
Malicious application can escape access control check of cur-
rent bytecode rewritier. Figure 10 demonstrates last known
location is successfully retrieved by the application despite
the location is at New York City.
6.3 Recommendations
The above problem is not diﬃcult to ﬁx; the easiest ﬁx
is to apply the API-level access control on android.os.
ServiceManager’s getService API, so application’s Java
code cannot use this API to get system services. It is very
rare that generic application would need to create custom
client for system services, since rich android APIs are already
provided to handle communications with system services. If
we do not want to block this API, we can apply the bytecode
rewriting technique to android.os.Binder.
7. RELATED WORK
Fine-grained access control using bytecode rewrit-
ing.
Several researchers have proposed to implement ﬁne-
grained access control using bytecode rewriting on Android
platform [11,14,19,22]. I-ARM embedded In-App Reference
Monitors into Android application [14]. Via instrumenting
the bytecode, security policies are interposed on all secure-
sensitive API calls. Several other work [11,19,22] placed Ref-
erence Monitors in other Android services and substituted
the calls to API methods with calls to other services. The
work in [19, 22] removes all the assigned permissions from
the applications, and reassigns the applications with ﬁne-
grained permissions. The executions of all secure-sensitive
APIs will be delegated to the services. In-vivo uses another
approach, it only uses the services to checks whether the
application can invoke sensitive API calls or not [11], if it is
approved, executions of APIs still take place inside the ap-
plications. Some researchers have proposed similar work on
ﬁne-grained access control using bytecode rewriting for Java
platform [12, 16, 24]. Ajay et. al insert runtime checks into
10
performed to fulﬁll an eﬀective API-level access control us-
ing bytecode rewriting. Our work can be beneﬁcial to those
who make use of bytecode rewriting or those who develop
bytecode rewriting tools.
9. REFERENCES
[1] Android developer.
http://www.developer.android.com/about/
versions/android-4.0.3.html.
[2] Android reverse engineering honeynet project.
http://www.honeynet.org/node/783.
[3] Binder. http://www.developer.android.com/
reference/andrdoid/os/Binder.html.
[4] Bytecode for the dalvik vm. http://www.source.
android.com/tech/dalvik-bytecode.html.
[5] Commonsware camera application.
http://github.com/commonsguy/cw-omnibus.
[6] Jni tips. http://www.developers.android.com.
guide/practices/jni.html.
[7] Naming a package.
http://www.docs.oracle.com/javase/
tutorial/package/namingpkgs.html.
[8] smali: An assembler/disassembler for android’s dex
format. http://www.code.google.com/p/smali.
[9] Swi handlers. http://www.infocenter.arm.com/
help/index.jsp?topic=/com.arm.doc.
dui0040d/Cacdfeci.html.
[10] Android binder: Android interprocess communication.
2011.
ACM conference on Computer and communication
security, 2011.
[19] J. Jeon, K. K. Micinski, and J. A. Vaughan. Dr.
android and mr. hide: Fine-grained security policies
on unmodiﬁed android. Technical Report, Department
of Computer Science, University of Maryland, 2011.
[20] M. Nauman, S. Khan, and X. Zhang. Apex:
Extending android permission model and enforcement
with user-deﬁned runtime constraints. in Proceedings
of the 5th ACM Symposium on Information,
Computer and Communications Security, 2010.
[21] D. Poo, D. Kiong, and S. Ashok. Object-oriented
programming and java, 2nd edition. 2007.
[22] N. Reddy, J. Jeon, J. Vaughan, T. Millstein, and
J. Foster. Application-centric security policies on
unmodiﬁed android. UCLA Computer Science
Department, Technical Report, 2011.
[23] D. Reynaud, E. C. R. Shin, T. R. Magrino, E. X. Wu,
and D. Song. Freemarket: Shopping for free in android
applications. In Proceedings of the 19th Annual
Symposium on Network and Distributed System
Security, 2012.
[24] A. Rudys and D. S. Wallach. Enforceing java run-time
properties using bytecode rewriting. 2002.
[25] S. Shekhar, M. Dietz, and D. S. Wallach. Adsplit:
Separating smartphone advertising from applications.
CoRR,abs/102.4030, 2012.
[26] R. Xu, H. Saidi, and R. Anderson. Aurasium:
Practical policy enforcement for android applications.
In Proceedings of the 21st USENIX Security
Symposium, 2012.
[11] A. Bartel, J. Klein, K. Allix, Y. Traon, and
[27] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. Hey, you,
M. Monperrus. Improving privacy on android
smartphones through in-vivo bytecode
instrumentation. CoRR, abs/1208.4536, 2012.
[12] A. Chander, J. C. Mitchell, and I. Shin. Mobile code
security by java bytecode instrumentation. pages
1027–1040, 2001.
[13] E. Chin, A. P. Felt, K. Greenwood, and D. Wanger.
Analyzing inter-application communication in android.
In Proceedings of the 9th International Conference on
Mobile system, application and serivecs, 2011.
[14] B. Davis, B. Sanders, A. Khodaverdian, and H. Chen.
I-arm-droid: A rewriting framework for in-app
reference monitors for android applications. In IEEE
Mobile Security Technologies, 2012.
[15] W. Enck, P. Gilbert, B. Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. N. Sheth. Taintdroid: an
information-ﬂow tracking system for realtime privacy
monitoring on smartphones. In Proceedings of the 9th
USENIX Conference on Operating Systems Design
and Implementation, pp.1-6, 2010.
[16] U. Erlingsson. The inlined reference monitor approach
to security policy enforcement. 2004.
[17] A. P. Felt, E. Chin, S. Hanna, D. Song, and
D. Wagner. Android permissions demystiﬁed. In
Proceedings of the 18th ACM Conference on Computer
and Communication Security, 2011.
[18] P. Hornyack, S. Han, J. Jung, S. Schechter, and
D. Wetherall. ”these aren’t the droids you’re looking
for”: Retroﬁtting android to protect data from
imperious applications. In Proceedings of the 18th
11
get oﬀ of my market: Detection malicious apps in
oﬃcial and alternative android markets. In
Proceedings of the 19th Annual Symposium on
Network and Distributed System Security, 2012.
[28] Y. Zhou, X.Zhang, X. Jiang, and V. Freeh. Taming
information-stealing smartphone applications(on
android). Trust and Trustworthy Computing,
pp.93-107, 2011.
APPENDIX
A. LIBRARIES NOT PRELOADED
The following are shared native libraries provided by the
Android platform. These libraries are stored under the di-
rectory /system/lib, and default class loader is not aware
of their existence. Applications can reload them during run-
time. If bytecode rewriting puts any access control on Java
native APIs in order to restrict applications’ access to the
native library functions in these libraries, the access control
can be bypassed using our attacks.
libETC1.so,
libFFTEm.so
libOpenglSystemCommon.so
libGLESv1_enc.so
libSR_AudioIn.so
libGLESv2_dbg.so
libEGL.so,
libGLESv1_CM.so,
libGLESv2.so,
libOpenSLES.so,
libRS.so,
libWnnEngDic.so, libWnnJpnDic.so
lib_renderControl_enc.so,
libandroid_runtime.so,
libaudioeffect_jni.so,
libbcc.so,
libbcinfo.so,
libbcc.so.sha1
libbinder.so
libandroid.so
libandroid_servers.so
libaudioflinger.so
libc_malloc_debug_leak.so
libcamera_client.so
libclcore.bc
libctest.so
libdefcontainer_jni.so
libgui.so
libhardware_legacy.so
libhwui.so
libicuuc.so
libjnigraphics.so
libnfc_ndef.so
libpixelflinger.so
libpowermanager.so
libfilterfw.so
libdvm.so
libnativehelper.so
libemoji.so
libexpat.so
libjni_latinime.so
liblog.so
libmedia.so
libdl.so
libdrm1_jni.so
libc.so,
libc_malloc_debug_qemu.so,
libcameraservice.so,
libcrypto.so,
libcutils.so,
libdiskconfig.so,
libdrm1.so,
libdrmframework.so,
libeffects.so,
libexif.so,
libext4_utils.so,
libfilterpack_imageproc.so
libgabi++.so,
libhardware.so,
libharfbuzz.so,
libicui18n.so,
libinput.so,
libjni_mosaic.so,
libjpeg.so,
libm.so,
libmediaplayerservice.so
libmtp.so,
libnetutils.so,
libpagemap.so,
libpower.so,
libreference-ril.so,
libsensorservice.so,
libsonivox.so,
libsqlite.so,
libsrec_jni.so,
libstagefright.so
libstagefright_amrnb_common.so
libstagefright_foundation.so
libstagefright_omx.so
libstagefright_soft_aacdec.so
libstagefright_soft_amrdec.so
libstagefright_soft_g711dec.so
libstagefright_yuv.so
libstdc++.so,
libsurfaceflinger.so
libsurfaceflinger_client.so
libsystem_server.so
libsysutils.so,
libttscompat.so, libttspico.so
libui.so,
libutils.so,
libvorbisidec.so
libwebrtc_audio_preprocessing.so
libwilhelm.so,
libwpa_client.so,
libril.so
libskia.so
libwnndict.so
libz.so
libthread_db.so
libstlport.so
libusbhost.so
libvariablespeed.so
libspeexresampler.so
libsqlite_jni.so
libssl.so
B. CLASSES LINKED TO ANDROID_RUNTIME
The following are Android framework Java classes that
link to the native library functions in the android_runtime
library.
If an API-level access control is put upon these
classes to restrict the applications’ access of their linked na-
tive library functions, our attacks can bypass this access
control by directly invoking those native library functions.
/android/debug/JNITest
/com/android/internal/os/RuntimeInit
/android/os/SystemClock
/android/util/EventLog
/android/util/Log
/android/util/FloatMath
/android/text/format/Time
/android/pim/EventRecurrence
/android/content/AssetManager
/android/security/Md5MessageDigest
/android/text/AndroidCharacter
/android/text/AndroidBidi
/android/text/KeyCharacterMap
12
/android/os/Process
/android/os/Binder
/android/view/Display
/android/nio/utils
/android/graphics/PixelFormat
/android/graphics/Graphics
/android/view/Surface
/android/view/ViewRoot
/com/google/android/gles/jni/EGLImpl
/com/google/android/gles/jni/GLImpl
/android/opengl/jni/GLES10
/android/opengl/jni/GLES20
/android/graphics/Bitmap
/android/graphics/BitmapFactory
/android/graphics/BitmapRegionDecoder
/android/graphics/Camera
/android/graphics/Canvas
/android/graphics/ColorFilter
/android/graphics/DrawFilter
/android/graphics/Interpolator
/android/graphics/LayerRasterizer
/android/graphics/MaskFilter
/android/graphics/Matrix
/android/graphics/Movie
/android/graphics/NinePatch
/android/graphics/Paint
/android/graphics/PorterDuff
/android/graphics/Rasterizer
/android/graphics/Region
/android/graphics/Shader
/android/graphics/Typeface
/android/graphics/Xfermode
/android/graphics/YuvImage
/com/android/internal/graphics/NativeUtils
/android/database/CursorWindow
/android/database/SQLiteCompiledSql
/android/database/SQLiteDatabase
/android/database/SQLiteDebug
/android/database/SQLiteProgram
/android/database/SQLiteQuery
/android/database/SQLiteStatement
/android/os/Debug
/android/os/FileObserver
/android/os/FileUtils
/android/os/MessageQueue
/android/os/ParcelFileDescriptor
/android/os/Power
/android/os/StatFs
/android/os/SystemProperties
/android/os/UEventObserver
/android/net/LocalSocketImpl
/android/net/NetworkUtils
/android/net/TrafficStats
/android/net/wifi/WifiManager
/android/nfc/NdefMessage
/android/nfc/NdefRecord
/android/os/MemoryFile
/com/android/internal/os/ZygoteInit
/android/hardware/Camera
/android/hardware/SensorManager
/android/media/AudioRecord
/android/media/AudioSystem
/android/media/AudioTrack
/android/media/ToneGenerator
/android/opengl/classes
/android/bluetooth/HeadsetBase
/android/bluetooth/BluetoothAudioGateway
/android/bluetooth/BluetoothSocket
/android/bluetooth/ScoSocket
/android/server/BluetoothService
/android/server/BluetoothEventLoop
/android/server/BluetoothA2dpService
/android/server/Watchdog
/android/message/digest/sha1
/android/ddm/DdmHandleNativeHeap
/android/backup/BackupDataOutput
/android/backup/FileBackupHelperBase
/android/backup/BackupHelperDispatcher
/android/content/res/ObbScanner
/android/content/res/Configuration
13