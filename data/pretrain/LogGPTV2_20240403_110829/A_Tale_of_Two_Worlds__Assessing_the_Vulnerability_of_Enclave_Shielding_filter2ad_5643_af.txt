tionally disclose secrets through the program-visible state (i.e., the
struct’s individual members), prior research on operating system
kernel [7] and SGX enclave [23] interfaces has shown that padding
bytes silently added by the compiler may still unintentionally leak
uninitialized secret memory.
Attack vector #10 (uninitialized padding): Scrubbing program-visible
state may not suffice for struct outputs [23]. ▷ Especially relevant for
production SDKs that expose the enclave interface to the programmer.
TEE design. This subtle attack vector cannot be easily mitigated
by sanitizing program-visible API state. Possible mitigations include
securely initializing the entire output struct using memset() and/or
doing a member-wise deep-copy, or declaring the output struct as
“packed” so the compiler does not unknowingly introduce padding.
However, both solutions require application-specific knowledge
about the exact struct types being passed. As an important insight,
we therefore found that this attack vector can only be transparently
shielded when the enclave interface is predefined and fixed. That
is, the fixed ocall interface in libOS-based runtimes can indeed be
manually scrutinized for this type of vulnerabilities. However, this
is not the case for SDK-based runtimes that offer a generic enclave
interface defined by the programmer, and hence (opposed to their
shielding responsibility) ultimately outsource the responsibility of
scrubbing uninitialized struct padding to the application developer.
SDK-based runtimes. Lee et al. [23] first demonstrated how
uninitialized struct padding may pose a subtle information leak-
age source in the edger8r-generated code of the Intel SGX-SDK.
Building on their findings, we generalized this attack vector to also
demonstrate its applicability to oeedger8r-generated code in Mi-
crosoft’s Open Enclave SDK, as well as in the Sancus TEE. Similarly,
we confirmed that padding leakage can also occur in Keystone, e.g.,
through the padding of calc_message_t in the demo enclave.
LibOS-based runtimes. We reviewed the ocall interfaces in
the libOS-based runtimes we studied (Graphene-SGX, LKL, Rust-
EDP). Rust-EDP appears to be free of such issues, and Graphene-
SGX explicitly enforces struct packing through a compiler #pragma.
However, SGX-LKL contains at least two instances of an ocall using
a struct with potentially vulnerable padding bytes (sigaction and
siginfo_t). In Google Asylo, most structs passed through an ocall
are explicitly declared as packed, however, we found one instance of
a padded struct BridgeSignalHandler used in the syscall interface.
6 DISCUSSION AND GENERAL MITIGATIONS
The most intuitive solution to defend against our attacks is to in-
corporate additional checks in the enclave code to properly sanitize
ABI state and API arguments/return values. When properly imple-
mented, such checks suffice to block all of the attacks described
in this work, and they have indeed been adopted by the various
projects we analyzed. However, leaving the decision of whether
(and how) to correctly implement numerous interface validation
checks to enclave developers, who are likely unaware of this class
of vulnerabilities, may be problematic. Moreover, even when de-
velopers think about inserting the necessary checks, our analysis
has revealed several recurring pitfalls, including subtle logical bugs,
side-channels, double fetches, and integer overflows. This high-
lights the need for more principled approaches to rule out this class
of vulnerabilities at large, as well as defense-in-depth code harden-
ing measures that may raise the bar for successful exploitation.
Code hardening. Interface sanitization vulnerabilities are closely
related to a wider class of memory safety issues [3, 22], and their
exploitation may hence be partially hindered by established tech-
niques such as heap obfuscation (cf. Section 4.1). Furthermore, SGX-
Shield [40] aims to obstruct memory corruption attacks by random-
izing the memory layout of enclaved binaries shielded by the Intel
SGX-SDK. However, prior research [3] has shown that SGX-Shield
does not randomize the trusted runtime, meaning that the code
we studied would still feature a deterministic and static memory
layout, and may offer numerous gadgets for mounting code reuse
attacks. Further, as the trusted runtime also forms an integral part
of SGX-Shield’s loader [40], any memory safety or side-channel
vulnerabilities in the trusted runtime itself may also be used to dis-
rupt the preliminary randomization stage. While randomizing the
memory layout of the trusted runtime would indeed be desirable,
this constitutes a non-trivial task [3, 40] given its low-level nature,
including hand-written assembly code and static memory addresses
expected by SGX’s eenter and eresume instructions. In this respect,
we want to emphasize that some of the attacks we presented are
free from non-static address dependencies, and hence remain inher-
ently immune to software randomization schemes. For example, the
SGX-SDK strlen() oracle in Fig. 4 depends solely on the fixed ad-
dress of the victim’s SSA frame, which is deterministically dictated
by the SGX hardware and immutable from software.
As a perpendicular code hardening avenue, we recommend to
implement more aggressive responses when detecting pointer vi-
olations in the trusted runtime. That is, most of the runtimes we
studied merely reject the ecall attempt when detecting pointer
poisoning. In the SGX-SDK strlen() oracle attack of Section 5.2,
we for example abused this to repeatedly call a victim enclave,
each time passing an illegal pointer and making side-channel ob-
servations before the ecall is eventually rejected. To rule out such
repeated attacks, and reflecting that in-enclave pointers represent
clear adversarial or buggy behavior, we recommend to immediately
destroy secrets and/or initiate an infinite loop upon detecting the
first pointer poisoning attempt in the trusted runtime.
Hardware-assisted solutions. As a more principled approach
to rule out the confused deputy attacks described in this paper,
solutions could leverage finer-grained memory protection features
in the processor. In particular, tagged memory [51] or capability
architectures [52] appear to be a promising approach to inherently
separate the memory domains of untrusted and trusted code. On
a capability machine [52], pointers are represented at run-time as
unforgeable objects carrying associated permissions and length
fields. The machine ensures that untrusted code can never create
a valid capability that points inside enclave-private memory and
pass it as an argument to an ecall, thereby eradicating an entire
class of pointer dereference vulnerabilities architecturally.
As an example of an alternative tagged memory design, the re-
cently proposed Timber-V [51] architecture provides lightweight
and strong enclaved execution on embedded RISC-V platforms.
Timber-V processors offer enhanced MPU isolation by keeping
track of a 2-bit tag for every memory word, allowing individual
memory locations to be associated with one out of 4 possible se-
curity domains. The CPU further restricts tag updates, and offers
checked memory load/store operations, which take an expected tag
as an argument and trap whenever the actual memory location
being dereferenced does not match the expected tag. Hence, any
pointer poisoning attempts by untrusted code outside the enclave
would be immediately caught by the hardware.
The untrusted pointer dereference issues we identified in this
work bear some similarities with how privileged OS kernel code
needs to properly sanitize user space pointers in e.g., system call
arguments. As a defense-in-depth mechanism, recent x86 proces-
sors support Supervisor Mode Access Protection (SMAP) features
to explicitly disallow unintended user space pointer dereferences
in kernel mode [17]. We encourage further research to investigate
porting such CPU features to enclave mode.
Safe programming languages. The combination of TEEs and
safe programming languages, such as Rust, has been proposed as a
promising research direction to safeguard enclave program seman-
tics, but still requires additional interface sanitizations [48]. The
approach of Fortanix’s Rust-EDP [11] shows how the compiler’s
type system can be automatically leveraged to limit the burden of
pointer sanitization concerns from a cross-cutting concern through-
out the enclave code base to the correct implementation of a single
untrusted pointer type. However, it is important to note that safe
languages by themselves are not a silver bullet solution to our
attacks. That is, the trusted runtime code remains responsible to
bootstrap memory safety guarantees by (i) establishing expected
ABI calling conventions in the low-level entry assembly code, and
(ii) providing a correct implementation of sanitization in the un-
trusted pointer type. In this respect, the subtle integer overflow
vulnerability in Fortantix’s EDP, presented in Section 5.3, demon-
strates that developing both the trusted runtime libraries and the
enclave in safe Rust may still not suffice to fully eradicate pointer
sanitization vulnerabilities.
Finally, as an alternative to Intel’s edger8r tool, the use of sep-
aration logic has been proposed to automatically generate secure
wrappers for SGX enclaves [49]. This approach aims to provide the
advantages of safe languages, and even formal verification guaran-
tees, but still relies on explicit developer annotations.
7 CONCLUSIONS AND FUTURE WORK
Our work highlights that the shielding responsibilities in today’s
TEE runtimes are not sufficiently understood, and that various
security issues exist in the respective trusted computing bases. We
showed that this attack surface is large and often overlooked: we
have identified 35 interface sanitization vulnerabilities in 8 open-
source TEE runtimes, including production-quality SDKs written
by security-savvy developer teams. Our analysis further reveals
that the entry points into this attack surface are more pervasive
than merely argument pointers: we contributed a classification of
10 recurring vulnerability classes spanning the ABI and API tiers.
In the defensive landscape, our work emphasizes the need to
research more principled interface sanitization strategies to safe-
guard the unique TEE shielding responsibilities. We particularly
encourage the development of static analysis tools, and fuzzing-
based vulnerability discovery and exploitation techniques to further
explore this attack surface.
ACKNOWLEDGMENTS
We thank Jethro Beekman (Fortanix), Job Noorman (KU Leuven),
and Johannes Götzfried for insightful discussions, and the anony-
mous reviewers for constructive feedback that helped improving
the paper. We further would like to thank the maintainers of the
open-source projects we studied for their contributions to the com-
munity and for promptly responding and working on mitigations.
This research is partially funded by the Research Fund KU Leu-
ven, and by the Agency for Innovation and Entrepreneurship (Flan-
ders). Jo Van Bulck is supported by a grant of the Research Foun-
dation – Flanders (FWO). This research is partially funded by the
Engineering and Physical Sciences Research Council (EPSRC) under
grants EP/R012598/1, EP/R008000/1 and by the European Union’s
Horizon 2020 research and innovation programme under grant
agreement No. 779391 (FutureTPM). Abdulla Aldoseri is supported
by a stipend from the University of Bahrain.
REFERENCES
[1] Sergei Arnautov, Bohdan Trach, Franz Gregor, Thomas Knauth, Andre Martin,
Christian Priebe, Joshua Lind, Divya Muthukumaran, Dan O’Keeffe, Mark L Still-
well, et al. 2016. SCONE: Secure Linux Containers with Intel SGX. In Proceedings
of the 12th USENIX Symposium on Operating Systems Design and Implementation.
USENIX Association, 689–703.
[2] Andrew Baumann, Marcus Peinado, and Galen Hunt. 2014. Shielding applications
from an untrusted cloud with Haven. In Proceedings of the 11th USENIX conference
on Operating Systems Design and Implementation. USENIX Association, 267–283.
[3] Andrea Biondo, Mauro Conti, Lucas Davi, Tommaso Frassetto, and Ahmad-Reza
Sadeghi. 2018. The Guard’s Dilemma: Efficient Code-Reuse Attacks Against Intel
SGX. In Proceedings of the 27th USENIX Security Symposium. 1213–1227.
[4] S. Checkoway and H. Shacham. 2013. Iago Attacks: Why the System Call API
is a Bad Untrusted RPC Interface. In International Conference on Architectural
Support for Programming Languages and Operating Systems (ASPLOS). 253–264.
[5] Guoxing Chen, Sanchuan Chen, Yuan Xiao, Yinqian Zhang, Zhiqiang Lin, and
Ten H Lai. 2019. SgxPectre: Stealing Intel Secrets from SGX Enclaves Via Spec-
ulative Execution. In 2019 IEEE European Symposium on Security and Privacy
(EuroS&P). IEEE, 142–157.
[6] Haogang Chen, Yandong Mao, Xi Wang, Dong Zhou, Nickolai Zeldovich, and
M Frans Kaashoek. 2011. Linux kernel vulnerabilities: State-of-the-art defenses
and open problems. In Proceedings of the Second Asia-Pacific Workshop on Systems.
ACM, 5:1–5:5.
[7] J. Corbet. 2010. Structure holes and information leaks. online, accessed 2019-08-06:
https://lwn.net/Articles/417989/. (December 2010).
[8] V. Costan and S. Devadas. 2016. Intel SGX Explained. IACR Cryptology ePrint
Archive 2016, 086 (2016), 1–118.
[30] A. Moghimi, J. Wichelmann, T. Eisenbarth, and B. Sunar. 2019. Memjam: A false
dependency attack against constant-time crypto implementations. International
Journal of Parallel Programming 47, 4 (2019), 538–570.
[31] J. Noorman, J. Tobias Mühlberg, and F. Piessens. 2017. Authentic execution of
distributed event-driven applications with a small TCB. In STM. 55–71.
[32] J. Noorman, J. Van Bulck, J. Tobias Mühlberg, F. Piessens, P. Maene, B. Preneel, I.
Verbauwhede, J. Götzfried, T. Müller, and F. Freiling. 2017. Sancus 2.0: A low-cost
security architecture for IoT devices. ACM Transactions on Privacy and Security
(TOPS) 20, 3 (2017), 7:1–7:33.
[33] OP-TEE. 2019. Security Advisories. online, accessed 2019-08-29: https://www.op-
tee.org/security-advisories. (2019).
[9] J. Edge. 2008. CVE-2008-1367 Kernel doesn’t clear DF for signal handlers.
https://bugzilla.redhat.com/show_bug.cgi?id=437312. (March 2008).
[10] A. Fog. 2018. Calling conventions for different C++ compilers and operating
systems. http://www.agner.org/optimize/calling_conventions.pdf. (April 2018).
[11] Fortanix. 2019. Fortanix Enclave Development Platform – Rust EDP. online,
accessed 2019-08-30: https://edp.fortanix.com/. (2019).
[12] J. D. Golić and C. Tymen. 2003. Multiplicative Masking and Power Analysis of
AES. In Cryptographic Hardware and Embedded Systems (CHES). 198–212.
[13] Google. 2019. Asylo: An open and flexible framework for enclave applications.
online, accessed 2019-08-06: https://asylo.dev/. (2019).
[14] J. Götzfried, T. Müller, R. De Clercq, P. Maene, F. Freiling, and I. Verbauwhede.
2015. Soteria: Offline software protection within low-cost embedded devices. In
Annual Computer Security Applications Conference (ACSAC). 241–250.
[15] Jago Gyselinck, Jo Van Bulck, Frank Piessens, and Raoul Strackx. 2018. Off-limits:
Abusing legacy x86 memory segmentation to spy on enclaved execution. In
International Symposium on Engineering Secure Software and Systems (ESSoS ’18).
Springer, 44–60.
[16] N. Hardy. 1988. The Confused Deputy (or why capabilities might have been
invented). ACM SIGOPS Operating Systems Review 22, 4 (1988), 36–38.
[17] Intel. 2016.
Intel 64 and IA-32 Architectures Software Developer’s Manual,
Volume 3 (3A, 3B & 3C): System Programming Guide. 325384 (2016).
[18] Intel. 2018. Intel Software Guard Extensions (SGX) SW Development Guidance for
Potential Edger8r Generated Code Side Channel Exploits. Revision 1.0.
[19] Intel. 2019. Intel Software Guard Extensions – Get Started with the SDK. online,
accessed 2019-05-10: https://software.intel.com/en-us/sgx/sdk. (2019).
[20] E. Mohammadian Koruyeh, K. N Khasawneh, C. Song, and N. Abu-Ghazaleh. 2018.
Spectre returns! speculation attacks using the return stack buffer. In USENIX
Workshop on Offensive Technologies (WOOT).
[21] D. Lee, D. Kohlbrenner, S. Shinde, D. Song, and K. Asanović. 2019. Keystone: A
Framework for Architecting TEEs. arXiv preprint arXiv:1907.10119 (2019).
[22] J. Lee, J. Jang, Y. Jang, N. Kwak, Y. Choi, C. Choi, T. Kim, M. Peinado, and
B. Byunghoon Kang. 2017. Hacking in Darkness: Return-oriented Programming
against Secure Enclaves. In Proceedings of the 26th USENIX Security Symposium.
523–539.
[23] S. Lee and T. Kim. 2017. Leaking Uninitialized Secure Enclave Memory via
Structure Padding. arXiv preprint arXiv:1710.09061 (2017).
[24] Sangho Lee, Ming-Wei Shih, Prasun Gera, Taesoo Kim, Hyesoon Kim, and Marcus
Peinado. 2017. Inferring Fine-grained Control Flow Inside SGX Enclaves with
Branch Shadowing. In Proceedings of the 26th USENIX Security Symposium. 557–
574.
[25] G. Lehel and N. Matsakis. 2017. rust-lang RFC: Integer overflows in Rust. online,
accessed 2019-05-10: https://github.com/rust-lang/rfcs/blob/9ef0c35/text/0560-
integer-overflow.md. (2017).
[26] M. Lipp, D. Gruss, R. Spreitzer, C. Maurice, and S. Mangard. 2016. Armageddon:
Cache attacks on mobile devices. In Proceedings of the 25th USENIX Security
Symposium. 549–564.
[27] A. Machiry, E. Gustafson, C. Spensky, C. Salls, N. Stephens, R. Wang, A. Bianchi,
Y. Ryn Choe, C. Kruegel, and G. Vigna. 2017. BOOMERANG: Exploiting the
Semantic Gap in Trusted Execution Environments. In NDSS 2017.
[28] Pieter Maene, Johannes Götzfried, Ruan De Clercq, Tilo Müller, Felix Freiling, and
Ingrid Verbauwhede. 2017. Hardware-Based Trusted Computing Architectures
for Isolation and Attestation. IEEE Trans. Comput. PP, 99 (2017).
[29] Microsoft. 2019. Open Enclave SDK.
online, accessed 2019-05-10: https:
//openenclave.io/sdk/. (2019).
[34] S. Pinto and N. Santos. 2019. Demystifying Arm TrustZone: A Comprehensive
Survey. ACM Computing Surveys (CSUR) 51, 6 (2019), 130.
[35] Christian Priebe, Divya Muthukumaran, Joshua Lind, Huanzhou Zhu, Shujie Cui,
Vasily A Sartakov, and Peter Pietzuch. 2019. SGX-LKL: Securing the Host OS
Interface for Trusted Execution. arXiv preprint arXiv:1908.11143 (2019).
[36] Graphene Project. 2019. Graphene: a Library OS for Unmodified Applications.
online, accessed 2019-08-30: https://grapheneproject.io/. (2019).
[37] M. Schwarz, D. Gruss, M. Lipp, C. Maurice, T. Schuster, A. Fogh, and S. Mangard.
2018. Automated detection, exploitation, and elimination of double-fetch bugs
using modern CPU features. In Asia CCS 2018. 587–600.
[38] M. Schwarz, Samuel Weiser, and Daniel Gruss. 2019. Practical enclave malware
with Intel SGX. In DIMVA. 177–196.
[39] M. Schwarz, S. Weiser, D. Gruss, C. Maurice, and S. Mangard. 2017. Malware
guard extension: using SGX to conceal cache attacks. In DIMVA. 3–24.
[40] J. Seo, B. Lee, S. Min Kim, M.W Shih, I. Shin, D. Han, and T. Kim. 2017. SGX-Shield:
Enabling Address Space Layout Randomization for SGX Programs.. In NDSS 2017.
[41] H. Shacham et al. 2007. The geometry of innocent flesh on the bone: return-into-
libc without function calls (on the x86).. In ACM CCS 2007. 552–561.
[42] S. Shinde, D. Le Tien, S. Tople, and P. Saxena. 2017. Panoply: Low-TCB Linux
Applications With SGX Enclaves. In NDSS 2017.
[43] C.C Tsai, D. E Porter, and M. Vij. 2017. Graphene-SGX: A practical library OS for
unmodified applications on SGX. In USENIX ATC.
[44] J. Van Bulck, M. Minkin, O. Weisse, D. Genkin, B. Kasikci, F. Piessens, M. Sil-
berstein, T. F. Wenisch, Y. Yarom, and R. Strackx. 2018. Foreshadow: Extracting
the keys to the Intel SGX kingdom with transient out-of-order execution. In
Proceedings of the 27th USENIX Security Symposium.
[45] J. Van Bulck, F. Piessens, and R. Strackx. 2017. SGX-Step: A practical attack
framework for precise enclave execution control. In SysTEX. 4:1–4:6.
[46] J. Van Bulck, F. Piessens, and R. Strackx. 2018. Nemesis: Studying microarchitec-
tural timing Leaks in rudimentary CPU interrupt logic. In ACM CCS 2018.
[47] J. Van Bulck, N. Weichbrodt, R. Kapitza, F. Piessens, and R. Strackx. 2017. Telling
your secrets without page faults: Stealthy page table-based attacks on enclaved
execution. In Proceedings of the 26th USENIX Security Symposium. 1041–1056.
[48] N. van Ginkel, R. Strackx, T. Mühlberg, and F. Piessens. 2016. Towards safe
enclaves. In Hot Issues in Security Principles and Trust (HotSpot). 1–16.
[49] N. van Ginkel, R. Strackx, and F. Piessens. 2017. Automatically generating
secure wrappers for SGX enclaves from separation logic specifications. In Asian
Symposium on Programming Languages and Systems. 105–123.
[50] N. Weichbrodt, A. Kurmus, P. Pietzuch, and R. Kapitza. 2016. AsyncShock: