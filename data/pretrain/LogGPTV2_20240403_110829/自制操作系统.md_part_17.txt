 段的大小是多少
 段的起始地址在哪里
 段的管理属性（禁止写入，禁止执行，系统专用等）
CPU用8个字节（=64位）的数据来表示这些信息。但是，用于指定段的寄存器只有16位。或
许有人会猜想在32位模式下，段寄存器会扩展到64位，但事实上段寄存器仍然是16位。
那该怎么办才好呢？可以模仿图像调色板的做法。也就是说，先有一个段号③，存放在段寄
存器里。然后预先设定好段号与段的对应关系。
调色板中，色号可以使用0~255的数。段号可以用0~8191的数。因为段寄存器是16位，所以
本来应该能够处理0~65535范围的数，但由于CPU设计上的原因，段寄存器的低3位不能使用。因
此能够使用的段号只有13位，能够处理的就只有位于0~8191的区域了。
——————————
① GB（Giga Byte，吉字节），指1024MB，可不是Game Boy的省略哟（笑）。
② 英文是paging。“分段”的基本思想是将4GB的内存分割；而分页的思想是有多少个任务就要分多少页， 还要对
内存进行排序。不过解说到这个程度，大家估计都不懂。以后有机会再详细说明。
③ 英文是segment selector，也有译作“段选择符”的。
图灵社区会员 metorm 专享 尊重版权
9 GDT与IDT的初始化（harib02i） …… 103
段号怎么设定呢？这是对于CPU的设定，不需要像调色板那样使用io_out（由于不是外部设
1
备，当然没必要）。但因为能够使用0~8191的范围，即可以定义8192个段，所以设定这么多段就
需要8192×8=65 536字节（64KB）。大家可能会想，CPU没那么大存储能力，不可能存储那么多
2
数据，是不是要写入到内存中去呀。不错，正是这样。这64KB（实际上也可以比这少）的数据
就称为GDT。
3
GDT是“global（segment）descriptor table”的缩写，意思是全局段号记录表。将这些数据整
齐地排列在内存的某个地方，然后将内存的起始地址和有效设定个数放在CPU内被称作GDTR①的
4
特殊寄存器中，设定就完成了。
■■■■■
5
另外，IDT是“interrupt descriptor table”的缩写，直译过来就是“中断记录表”。当CPU遇到
外部状况变化，或者是内部偶然发生某些错误时，会临时切换过去处理这种突发事件。这就是中
5
断功能。
我们拿电脑的键盘来举个例子。以CPU的速度来看，键盘特别慢，只是偶尔动一动。就算是
7
重复按同一个键，一秒钟也很难输入50个字符。而CPU在1/50秒的时间内，能执行200万条指令
（CPU主频100MHz时）。CPU每执行200万条指令，查询一次键盘的状况就已经足够了。如果查询
8
得太慢，用户输入一个字符时电脑就会半天没反应。
要是设备只有键盘，用“查询”这种处理方法还好。但事实上还有鼠标、软驱、硬盘、光驱、
9
网卡，声卡等很多需要定期查看状态的设备。其中，网卡还需要CPU快速响应。响应不及时的话，
数据就可能接受失败，而不得不再传送一次。如果因为害怕处理不及时而靠查询的方法轮流查看
各个设备状态的话，CPU就会穷于应付，不能完成正常的处理。 10
正是为解决以上问题，才有了中断机制。各个设备有变化时就产生中断，中断发生后，CPU
暂时停止正在处理的任务，并做好接下来能够继续处理的准备，转而执行中断程序。中断程序执 11
行完以后，再调用事先设定好的函数，返回处理中的任务。正是得益于中断机制，CPU可以不用
一直查询键盘，鼠标，网卡等设备的状态，将精力集中在处理任务上。 12
讲了这么长，其实总结来说就是：要使用鼠标，就必须要使用中断。所以，我们必须设定IDT。
IDT记录了0～255的中断号码与调用函数的对应关系，比如说发生了123号中断，就调用○×函数，
13
其设定方法与GDT很相似（或许是因为使用同样的方法能简化CPU的电路）。
如果段的设定还没顺利完成就设定IDT的话，会比较麻烦，所以必须先进行GDT的设定。
14
15
——————————
16
① global (segment) descriptor table register的缩写。
图灵社区会员 metorm 专享 尊重版权
104 …… 第5天：结构体、文字显示与GDT/IDT初始化
■■■■■
虽然说明很长，但程序并没那么长。
本次的*bootpack.c节选
struct SEGMENT_DESCRIPTOR{
short limit_low, base_low;
char base_mid, access_right;
char limit_high, base_high;
};
struct GATE_DESCRIPTOR {
short offset_low, selector;
char dw_count, access_right;
short offset_high;
};
void init_gdtidt(void)
图灵社区会员 metorm 专享 尊重版权
9 GDT与IDT的初始化（harib02i） …… 105
{
1
struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) 0x00270000;
struct GATE_DESCRIPTOR *idt = (struct GATE_DESCRIPTOR *) 0x0026f800;
int i;
2
/* GDT的初始化 */
for (i = 0; i  0xfffff) {
ar |= 0x8000; /* G_bit = 1 */
limit /= 0x1000; 8
}
sd->limit_low = limit & 0xffff;
sd->base_low = base & 0xffff;
9
sd->base_mid = (base >> 16) & 0xff;
sd->access_right = ar & 0xff;
sd->limit_high = ((limit >> 16) & 0x0f) | ((ar >> 8) & 0xf0);
sd->base_high = (base >> 24) & 0xff; 10
return;
}
void set_gatedesc(struct GATE_DESCRIPTOR *gd, int offset, int selector, int ar) 11
{
gd->offset_low = offset & 0xffff;
gd->selector = selector;
12
gd->dw_count = (ar >> 8) & 0xff;
gd->access_right = ar & 0xff;
gd->offset_high = (offset >> 16) & 0xffff;
return; 13
}
SEGMENT_DESCRIPTOR中存放GDT的8字节的内容，它无非是以CPU的资料为基础，写成
14
了结构体的形式。同样，GATE_DESCRIPTOR中存放IDT的8字节的内容，也是以CPU的资料为
基础的。
15
变量gdt被赋值0x00270000，就是说要将0x270000～0x27ffff设为GDT。至于为什么用这个地
址，其实那只是笔者随便作出的决定，并没有特殊的意义。从内存分布图可以看出这一块地方并
16
没有被使用。
图灵社区会员 metorm 专享 尊重版权
106 …… 第5天：结构体、文字显示与GDT/IDT初始化
变量idt也是一样，IDT被设为了0x26f800～0x26ffff。顺便说一下，0x280000～0x2fffff已经有
了bootpack.h。“哎？什么时候？我可没听说过这事哦！”大家可能会有这样的疑问，其实是后面
要讲到的“asmhead.nas”帮我们做了这样的处理。
■■■■■
现在继续往下说明。
for (i = 0; i >”是右移位运算符。比如计算00101100>>3，就得到00000101。移位时，舍弃右边溢出
1
的位，而左边不足的3位，要补3个0。
2
3
4
5
5
7
8
9
■■■■■
今天到这里就差不多了，访问权属性及IDT的详细说明就留到明天吧。总之，使用本程序的
10
操作系统是做成了。能不能正常运行啊？赶紧试一试吧。“make run ”……还好，能运行。这次
只是简单地做了初期设定，所以即使运行成功了，画面上也什么都不显示。
11
现在haribote.sys变成多少字节了呢？哦，光字体就有4KB，增加了不少，到7632字节了。今
天就先到这里吧，大家明天见。
12
13
14
15
16
图灵社区会员 metorm 专享 尊重版权
第 6 天
分割编译与中断处理
 分割源文件（harib03a）
 整理Makefile（harib03b）
 整理头文件（harib03c）
 意犹未尽
 初始化PIC（harib03d）
 中断处理程序的制作（harib03e）
11 分割源文件（harib03a）
本来想接着详细讲解一下昨天剩下的程序，但一上来就说这些，有点乏味，所以还是先做点
准备活动吧。不经意地看一下bootpack.c，发现它竟然已长达近300行，是太长了点。所以我们决
定把它分割为几部分。
将源文件分割为几部分的利弊，大致如下。
优点
(1) 按照处理内容进行分类，如果分得好的话，将来进行修改时，容易找到地方。
(2) 如果Makefile写得好，只需要编译修改过的文件，就可以提高make的速度。
(3) 单个源文件都不长。多个小文件比一个大文件好处理。
(4) 看起来很酷（笑）。
缺点
(5) 源文件数量增加。
(6) 分类分得不好的话，修改时不容易找到地方。
图灵社区会员 metorm 专享 尊重版权
2 整理Makefile（harib03b） …… 109
■■■■■ 1
我们先将源文件按下图分割一下看看。
2
3
4
分割并不是很难，但有一点很关键。比如如果graphic.c也想使用naskfunc.nas的函数，就必须
5
要写上“void io_out8（int port,int data）;”这种函数声明。虽然这都已经写在bootpack.c里了，但
编译器在编译graphic.c时，根本不知道有bootpack.c存在。
6
这样整理一下看起来就清爽多了。对应源文件的分割，我们还要修改Makefile，流程如下：
6
8
9
10
理解了这个流程，Makefile也就很容易看懂了。
现在再来“make run”。运行起来一点问题也没有，分割成功了。 11
22 整理 Makefile（harib03b）
12
分割虽然成功了，但现在Makefile又有点长了，足足有113行。虽说出现这种情况是情有可原，
13
但是，像这样：
bootpack.gas : bootpack.c Makefile 14
$(CC1) -o bootpack.gas bootpack.c
graphic.gas : graphic.c Makefile
15
$(CC1) -o graphic.gas graphic.c
dsctbl.gas : dsctbl.c Makefile
$(CC1) -o dsctbl.gas dsctbl.c 16
图灵社区会员 metorm 专享 尊重版权
110 …… 第6天：分割编译与中断处理
或者像这样：