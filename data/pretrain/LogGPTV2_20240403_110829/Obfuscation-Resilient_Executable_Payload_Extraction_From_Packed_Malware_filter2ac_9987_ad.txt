equivalent instructions (e.g., “pop x; jmp * x”) [14].
NX-bit Switch. For the above two cases that do not point
to the target API ( 6 in Figure 4), we will notify the kernel
USENIX Association
30th USENIX Security Symposium    3459
BTSBranch to Target API?ProcessorOur Page Fault HandlerReconstruct Import Tables (IAT & INT)NXNoYesCopy & Reset Tracer Buffer TracerBufferNotify Kernel NX-bit Switch Module  Enabling BTSLast Branch & Trampoline Base Address Data FlowControl FlowNX SupportedAPI Micro ExecutionPE HeaderExecutable Malware API Callsites & ContextMemory DumpOEP MemoryOEP MemoryMemory Static Analysiscall [f1]call CreateFilecall WriteFileResolve API NamesProces Filtering12call [f2]NX-bit Switch for DLL Pages & Non-DLL Pages...45768TracerBuffer3Current Stack FrameUser LevelKernel Top StackArgument n……Argument 1   Anti-debuggingAPI Return AddressOriginalFrame(prepared by API callsite)   TargetAPI Return Address Argument 1 TargetAPI  Arguments…… Argument n NewFrame(prepared by trampoline )Anti-debuggingAPI Arguments High Address Low Address NX-bit switch module to disable NX bit for DLL pages and
enable NX bit for the trampoline code. As a result, the exe-
cution of the above two cases can resume. When the control
ﬂow goes back to the trampoline, it will also trigger a non-
executable page fault. At this time, our page fault handler will
switch the NX bit again; that is, it switches on NX bit for
DLL pages and switches off NX bit for the trampoline code.
In this way, we can enable NX bit for DLL pages whenever
the control ﬂow reenters them.
1-Branch Interrupt. We have to consider the case that
the control ﬂow does not go back to the trampoline code. A
skilled attacker can create ROP-chain inside the DLL to jump
to the target API directly. Since we have disabled NX bit for
DLL pages to resume the “ROP Redirection” execution, this
attack will not trigger the page fault when the control ﬂow
reaches the target API. Our solution is to reset the size of BTS
buffer as one when we detect “ret-like” instructions. This
enables our BTS-mechanism to capture each branch in the
ROP-chain inside the DLL, but at the cost of higher overhead.
In this way, we ensure one of our hardware-mechanism (NX
or BTS) can capture the branch to the target API in any case.
4.8 Import Table Reconstruction
If the destination address resides within the target API’s code
( 7 in Figure 4), the next step is to resolve the API name
from this address. Note that if the packer applies the stolen
code technique (Figure 2(e)), the destination address will not
be the entry point of the target API, but in the middle of the
API code. Therefore, we identify API name not by its entry
point, but by a memory range of this API. More concretely,
we ﬁrst scan the OEP memory to obtain each loaded DLL’s
memory range. For each DLL, we scan its export address
table from the DLL header to get all API names and calculate
their memory ranges. After that, we relate the destination
address with a particular API name by checking whether the
destination address is located within the memory range of an
API. After we complete all possible API Micro Executions
and resolve the API name for each API callsite, we will rebuild
a new IAT as well as the associated INT. Furthermore, we
will recover the reference to the new IAT & INT from the
PE header, so that they are reachable for static analysis and
Windows PE loader. For the cases of “Rewrite Original API
Call ” (Figure 2(f)), we also need to rewrite direct calls back
to indirect calls through the new IAT reference. At last, our
recovered PE header is stitched together with the unpacked
code to assemble an executable program ( 8 in Figure 4).
5 Evaluation
API-Xray automates the import table reconstruction for unpac-
ked Windows programs on the x86/x64 platform. We conduct
a set of experiments to evaluate API-Xray’s effectiveness
from four aspects. 1) API-Xray outperforms existing work in
Table 4: The API coverage evaluation results with the ground
truth dataset. API obfuscation type numbers (Column 2) re-
present: 1) IAT Redirection; 2) Rewrite API Callsite; 3) Sto-
len Code; 4) ROP Redirection; 5) Anti-debugging Routine.
We test four representative methods: BinUnpack (BU) [15],
Ugarte-Pedrero et al.’s work in S&P’15 (SP) [73], RePEcon-
struct (RP) [44], and API-Xray (AX)).
API Obfuscation
#APIs
Packers
Types
BU SP
RP AX
Non-obfuscation Packers
UPX
API Obfuscation Packers
Yoda’s Crypter
Yoda’s Protector
TELock
ZProtect
Enigma
ASProtect
PESpin
Armadillo
PEP
Obsidium
PELock
Themida
Packing model
Partial code revealing
348
102
102
213
0
23
178
119
220
41
0
0
0
0
56
56
56
56
56
56
32
18
19
17
15
19
0
0
348
348
124
124
235
56
59
202
126
231
53
15
20
0
0
348
348
348
348
348
348
348
348
348
348
348
348
348
1
1
1
1
1
2
1,3
1,5
1,2,5
1,4,5
1,3,4
2,3
2,3
terms of better API coverage and API-obfuscation resistance.
2) Compared with LBR and IPT, we demonstrate that our
choice of BTS is the only viable option for import table recon-
struction. 3) We report our experience of testing large-scale
packed malware in the wild. Especially, API-Xray advances
unknown/new malware detection and analysis.
5.1 Comparative Evaluation
Our study in §3 has found that 12 prevalent packers apply
different API obfuscation schemes. To set up a controlled ex-
periment, we apply these 12 packers to a sample of notorious
Zeus Trojan. Zeus Trojan, also known as Zbot, is often used to
steal ﬁnancial data from the victim machines and install ran-
somware [28]. Zeus has been on Check Point’s Top10 wanted
malware list for many years [71]. Our motivation for testing
Zeus is based on the two following arguments. First, Zeus is
the most sophisticated botnet that the FBI has ever attempted
to disrupt [30]. It has 348 APIs, which is signiﬁcantly more
than other typical malware samples (e.g., about 114 APIs
for WannaCry and about 168 APIs for Conﬁcker). Second,
Zeus is controlled by different commands from the Network,
which means it has many execution paths. These execution
paths cause the dynamic-based import table reconstruction
approaches to recover limited APIs (see Section 2.2). In our
evaluation, we compile Zeus binary code§ with its source
code in Windows 10.
We compare API-Xray with three representative import ta-
ble reconstruction methods: BinUnpack [15], Ugarte-Pedrero
§MD5: 9e722f9c2e344f683b5e9c37b1035b95
3460    30th USENIX Security Symposium
USENIX Association
et al.’s work [73], and RePEconstruct [44]. As we summari-
zed in Table 1, these three methods represent memory static
analysis, dynamic, and hybrid analysis, respectively. Besides,
we also need a generic unpacking tool to provide the OEP
memory as the input to these import table reconstruction met-
hods. Due to the high performance of BinUnpack [15], we
use BinUnpack’s OEP identiﬁcation heuristics to halt the pro-
cess when the OEP is reached. Our testbed is a laptop with
an Intel Core i7-8550 processor (quad-core, 1.80GHz) and
16GB memory, running Windows 10.
5.1.1 API Coverage
The 12 packers that apply API obfuscation are shown in the
ﬁrst column of Table 4. In addition, we use UPX packer
to represent the packer that does not apply any obfuscation.
Themida [57] is a sophisticated commercial code obfuscator.
We use Themida to evaluate two complicated packer cases.
First, we enable Themida’s packing model to pack Zeus’s
binary code. The distinct feature of Themida packer is that
the unpacking routine code is further obfuscated by code
virtualization. Second, as the source code of Zeus is available,
we apply Themida’s optional functionality: “Encode Macro”.
“Encode Macro” allows users to mark a region of source code
that needs to be encrypted. At run time, Themida will ﬁrst
decrypt the code inside the macro, execute it, and then encrypt
it again. We treat this “Encode Macro” model as the partial
code revealing packer, which is a well-known challenge for all
generic unpackers [7], because only a portion of the original
code is revealed during any given unpacking time window.
We enable Themida’s “Encode Macro” option to protect
the major functions of Zeus. This means every time only one
function’s OEP memory is available for us to analyze. We
handle this tough case using the following steps: 1) when the
unpacking tool returns the OEP memory for each function, we
resolve API names for this function and dump this function’s
process memory; 2) we collect all resolved API names to
reconstruct import tables; 3) we reassemble all function pro-
cess memory dumps as a single consistent code image, which
is further stitched together with reconstructed import tables
from step 2 to generate an executable Zeus.
Table 4’s second column shows the API obfuscation types
adopted by these packers. We can see that the “IAT Redi-
rection” is the most common API obfuscation type. Columns
3∼6 show the number of APIs that are restored by the four tes-
ted methods. We treat this number as the metrics to measure
the completeness of import table reconstruction tools.
The original Zeus has 348 APIs in its import table. As a
static-only method, BinUnpack [15] is brittle when handing
API obfuscation schemes, so BinUnpack fails to resolve API
names for ZProtect, Obsidium, PELock, Themida. For the
rest of packers, we notice that BinUnpack can resolve part
of API names. We look into these packers and ﬁnd that these
packers only obfuscate APIs exported from particular DLLs.
means this tool can defeat an API obfuscation type.
Table 5: The comparison of API-obfuscation resistance. “(cid:32)”
API-Xray
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
Obfuscation Type
IAT Redirection
Rewrite API Callsite
Stolen Code
ROP Redirection
Anti-debugging Routine
BinUpack
RePEconstruct
(cid:32)
(cid:32)
S&P’15
(cid:32)
(cid:32)
For example, Yoda’s Crypter packer only obfuscates the APIs
exported by kernel32.dll, user32.dll, and advapi32.dll, but not
other APIs. As a result, BinUnpack can restore 102 APIs that
are not obfuscated by Yoda’s Crypter packer.
For Ugarte-Pedrero et al.’s work [73], as a dynamic-only
method, it can resolve at most 56 API names for nine packers,
because only these 56 APIs are called during a single execu-
tion path. Of course, we can expect Ugarte-Pedrero et al.’s
work to cover more APIs after it explores more paths with
new inputs, but its design does not deal with all API obfusca-
tion types. For the left four complex packers, Ugarte-Pedrero
et al.’s work performed even worse because it is evaded by
“Stolen Code,” “ROP Redirection,” and “Anti-debugging Rou-
tine.” For RePEconstruct [44], although it can cover more