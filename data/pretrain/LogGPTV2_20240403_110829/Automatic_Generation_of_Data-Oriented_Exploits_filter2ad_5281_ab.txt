We deﬁne the core problem of data-ﬂow stitching as
follows. For a program with a memory error, we take
the following parameters as the input: a 2D-DFG G from
a benign execution of the program, a memory error in-
ﬂuence I, and two vertices vS (source) and vT (target).
In our example, vS is the private key buffer, shown as
(privKey12, 6) in Figure 1 and vT is the public output
1We treat the register name as a special memory address.
2privKey1 here means the key buffer address, a concrete value.
buffer, shown as (output, 16) in Figure 1. Our goal is
to generate an exploit input that exhibits a new 2D-DFG
G(cid:29) = {V(cid:29),E(cid:29)}, where V(cid:29) and E(cid:29) result from the memory
error exploit, and that G(cid:29) contains data-ﬂow paths from
vS to vT . Let E = E(cid:29)−E be the edge-set difference and
V = V(cid:29) − V be the vertex-set difference. Then, E is the
set of new edges we need to generate to get E(cid:29) from E.
The memory error inﬂuence I is the set of memory
locations which can be written to by the memory error,
represented as a set of vertices. Therefore, we must se-
lect V to be a subset of vertices in I. To achieve G1
we consider variables carrying program secrets as source
vertices and variables written to public outputs as target
vertices. In the development of attacks for G2, source
vertices are attacker-controlled variables and target ver-
tices are security-critical variables such as system call
parameters. A successful data-oriented attack should ad-
ditionally satisfy the following critical requirements:
• R1. The exploit input satisﬁes the program path
constraints to reach the memory error, create new
edges and continue the execution to reach the in-
struction creating vT .
• R2. The instructions executed in the exploit must
conform to the program’s static control ﬂow graph.
2.4 Key Technique & Challenges
The key idea in data-ﬂow stitching is to efﬁciently search
for the new data-ﬂow edge set E to add in G(cid:29) such that
it creates new data-ﬂow paths from vS to vT . For each
edge (x,y) ∈ E, x is data-dependent on vS and vT is data-
dependent on y. We denote the sub-graph of G contain-
ing all the vertices that are data-dependent on vS as the
source ﬂow. We also denote the sub-graph of G contain-
ing all the vertices that vT is data-dependent on as the
target ﬂow. For each vertex pair (x, y), where x is in the
source ﬂow and y is in the target ﬂow, we check whether
(x, y) is a feasible edge of E resulting from the inclusion
of vertices from I. The vertices x and y may either be
contained in I directly, or be connected via a sequence of
edges by corruption of their pointers which are in I. If we
change the address to which x is written, or change the
address from which y is read, the value of x will ﬂow to y.
If so, we call (x, y) the stitch edge, x the stitch source, and
y the stitch target. For example, in Figure 2, we change
the pointer (which is in I) of the ﬁle name from reqFile1
to privKey1. Then the ﬂow of the private key and the
ﬂow of the ﬁle name are stitched, as we discuss in Sec-
tion 2.1. In ﬁnding data-ﬂow stitching in the 2D-DFG,
we face the following challenges:
• C1. Large search space for stitching. A 2D-DFG
from a real-world program has many data ﬂows and
a large number of vertices. For example, there are
180  24th USENIX Security Symposium 
USENIX Association
4
address 
&privKey 
privKey1 
privKey1 
output 
&userInput 
&reqFile 
userInput1 
reqFile1 
userInput1 
reqFile1 
privKey1 
Attack 
0 
6 
9 
12 
14 
16 
time 
Figure 2: A data-oriented attack of Code 1. This attack connects
ﬂow of the private key and ﬂow of the ﬁle name, with the new edges
(dashed lines).
776 source vertices and 56 target vertices in one of
SSHD attacks. Therefore, the search space to ﬁnd a
feasible path is large, for we often need heavy anal-
ysis to connect each pair of vertices.
• C2. Limited knowledge of memory layout. Most
of the modern operating systems have enabled
ASLR by default. The base addresses of data mem-
ory regions, like the stack and the heap, are random-
ized and thus are difﬁcult to predict.
The 2D-DFG captures only the data dependencies
in the execution, abstracting away control dependence
and any conditional constraints the the program imposes
along the execution path. To satisfy the requirements R1
and R2 completely, the following challenge must be ad-
dressed:
• C3. Complex program path constraints. A suc-
cessful data-oriented attack causes the victim pro-
gram execute to the memory error, create a stitch
edge, and continue without crashing. This requires
the input to satisfy all path constraints, respect the
program’s control ﬂow integrity constraints, and
avoid invalid memory accesses.
3 Data-ﬂow Stitching
Data-oriented exploits can manipulate data-ﬂow paths in
a number of different ways to stitch the source and target
vertices. The solution space can be categorized based on
the number of new edges added by the exploit. The sim-
plest case of data-oriented exploits is when the exploit
adds a single new edge. More complex exploits that use
a sequence of corrupted values can be crafted when a
single-edge stitch is infeasible. We discuss these cases to
solve challenge C1 in Section 3.1 and 3.2. To overcome
the challenge C2, we develop two methods to make data-
oriented attacks work even when ASLR is deployed, dis-
cussed in Section 3.3. For each stitch candidate, we con-
sider the path constraints and CFI requirement (C3) to
generate input that trigger the stitch edge in Section 4.4.
1 struct passwd { uid_t pw_uid; ... } *pw;
2 ...
3 int uid = getuid();
4 pw->pw_uid = uid;
5 ...
6 void passive(void) { ...
7
8
9
10
Code 2: Code snippet of wu-ftpd, setting uid back to process user
id.
seteuid(0);
...
seteuid(pw->pw_uid);
... }
//format string error
//set root uid
//set normal uid
address 
I 
100 
100 
0 
3 
4 
pw1 
&uid 
&arg 
100 
address 
 Attack  
100 
0 
100 
0 
100 
9 
(a) 
time 
0 
3 
4 
5 
(b) 
0 
9 
time 
Figure 3: Target ﬂow in the single-edge stitch of wu-ftpd. &arg
is the stack address of setuid’s argument. (a) is the original target
ﬂow, where the pw->pwd uid has vale 100 and address pw1. Grey
area stands for the memory inﬂuence I. With the stitching attack, the
value at address pw1 is changed to 0 in (b).
3.1 Basic Stitching Technique
A basic data-oriented exploit adds one edge in the new
edge set E to connect vS with vT . We call this case
a single-edge stitch. For instance, attackers can cre-
ate a single new vertex at the memory corruption point
by overwriting a security-critical data value, causing es-
calation of privileges. Most of the previously known
data-oriented attacks are cases of single-edge stitches,
including attacks studied by Chen et al. [19] and the
IE Safemode attack [6]. We use the example of a vul-
nerable web server wu-ftpd, shown in Code 2, which
was used by Chen et al. to explain non-control data at-
tacks [19]. In this exploit, the attackers utilizes a format
string vulnerability (skipped on line 5) to overwrite the
security-critical pw->pw uid with root user’s id. The
subsequent setuid call on line 9, which is intended to
drop the process privileges, instead makes the program
retain its root user privileges. Figure 3 (a) and Figure 3
(b) show the 2D-DFG for the execution of the vulnerable
code fragment under a benign and the exploit payload re-
spectively. Numbers on time-axis are the line numbers in
Code 2. The exploit aims to introduce a single edge to
write a zero value from the network input to the memory
allocated to the pw->pw id. Note that the exploit is a
valid path in the static control-ﬂow graph.
Search for Single-Edge Stitch. Instead of brute-forcing
all vertices in the target ﬂow for a stitch edge, we propose
a method that utilizes the inﬂuence set I of the mem-
USENIX Association  
24th USENIX Security Symposium  181
5
StitchAlgo-1: Single-edge Stitch
Input: G: benign 2D-DFG,
I: memory inﬂuence,
vT : target vertex,
cp: memory error vertex,
X: value to be in VT .value (requirement for stitch edge)
Output: E: stitch edge candidate set
1 E = /0
2 T DFlow = dataSubgraph(G, vT )
3 foreach v ∈ V(TDFlow) do
if isRegister(v) then
4
5
continue
/* only data edges */
/* Skip registers */
0 
2 
6
7
if ∃ (v, v(cid:29)) ∈ E(TDFlow): ∃ t : v.time pw uid’s ﬂow, and the source ﬂow is the ﬂow of a constant 0.
With the attack, the variable pw at &pw is changed to b2. A later opera-
tion reads 0 from b2 and writes it to stack for setuid. Two edges are
changed: one for pointer dereference and another for data movement.
ways. Attackers can use several single-edge stitches to
create a multi-edge stitch. Another way is to perform
pointer stitch, which corrupts a variable that is later used
as a pointer to vertices in the source or target ﬂow. Since
the pointer determines the address of the stitch source
or the stitch target, corrupting the pointer introduces two
different edges: one edge for the new “points to” rela-
tionship and one edge for the changed data ﬂow. We re-
visit the example of wu-ftpd shown earlier in Code 2,
illustrating a multi-edge stitch exploit in it. Instead of
directly modifying the ﬁeld pw uid, we change its base
pointer pw to an address of a structure with a constant
0 at the offset corresponding to the pw uid. The vul-
nerable code then reads 0 and uses it as the argument
of setuid, creating a privilege escalation attack. Fig-
ure 4 shows the 2D-DFGs for the benign and attack exe-
cutions. Changing the value of pw creates two new edges
(dashed lines): the grey edge that connects the corrupted
pointer to a new variable it points to, and the black edge
that writes the new variable into setuid argument. As
a result, we create a two-edge stitch.
Identifying Pointer Stitches. Our algorithm for ﬁnding
multi-edge exploits using pointer stitching is shown in
the StitchAlgo-2. The basic idea is to check each mem-
ory vertex in the source ﬂow and the target ﬂow. If it is
pointed to by another vertex in the 2D-DFG, we select
the pointer vertex to corrupt. The search for stitchable
pointers on the target ﬂow is different from that on the
source ﬂow. Speciﬁcally, for a vertex v in the target ﬂow,
we need to ﬁnd an data edge (v(cid:29),v) and a pointer vertex
vp of v(cid:29), and then change vp to point to a vertex vs in the
source ﬂow, so that a new edge (vs,v) will be created to
stitch the data ﬂows. For a vertex v in the source ﬂow, we
need to ﬁnd an data edge (v,v(cid:29)) and a pointer vertex vp of
v(cid:29), and change vp to point to a vertex vt in the target ﬂow,
so that a new edge (v,vt) will be created to stitch the data
ﬂows. At the same time, we need to consider the liveness
of the stitching vertices. For example, the source vertex
182  24th USENIX Security Symposium 
USENIX Association
6
StitchAlgo-2: Pointer Stitch
Input: G: benign 2D-DFG,
vS: source vertex,
cp: memory error vertex
Output: E: stitch edge candidate set
1 E = /0
2 SrcFlow = subgraph(G, vS)
3 T gtFlow = subgraph(G, vT )
4 SDFlow = dataSubgraph(G, vS)
5 T DFlow = dataSubgraph(G, vT )
6 foreach v ∈ V(TDFlow) do
I: memory inﬂuence,
vT : target vertex,
/* both data and address edges. */
/* only data edges */
if isRegister(v) then continue
if (cid:31) (vi ∈ E(I)∧ (v, v(cid:29)) ∈ TDFlow) : vi.time < v(cid:29).time then
continue
foreach (vp, v) ∈ E(TgtFlow) – E(TDFlow) do
/* Only consider address edges.
if vp is used to write v then continue
/* Expect data ﬂow from v
foreach vs ∈ V(SDFlow) do
if ¬isRegister(vs) ∧ vs.isAliveAt(vp.time) then
StitchAlgo-1(G, I, vp, cp, vs.address)