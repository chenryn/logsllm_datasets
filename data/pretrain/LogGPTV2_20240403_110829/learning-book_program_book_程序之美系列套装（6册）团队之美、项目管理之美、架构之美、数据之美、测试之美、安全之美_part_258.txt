地球和卫星的防火墙带来的漏洞都多。因此，这就是HTTP协议。
如果有什么事不能通过HTTP协议来完成，那这件事就需要重新考
虑一下了。为了说明这一点，我们具体看一下消费电子设备的情
况。这些产品很多都很酷，但是只有那些很棒的设备才包含HTTP
客户端（如iPhone或者一些基于Android的设备）。真正令人惊叹的
设备甚至包含了HTTP服务器（Nkia的S60上可以运行HTTP服务
器）。正如任何完善的规则都有例外，HTTP协议也不例外。它是
无状态、重量级的，当你需要以快速、有状态形式完成一些任务
时，这两个特征可能会成为障碍。以下协议是这些例外的例子。
可扩展消息处理现场协议（XPP）
AOL的即时通信产品是该领域在实时社会通信产品上的首次亮相，
并且发展异常迅猛。人们想“聊关”。不久，人们就想通过P2P进行
聊天，或者通过其他服务，XMIPP就这样诞生了。开始的时候，作
为一个标准的传输框架和用于描述社会交互、展现数据的标准格
式，XMPP被拼凑成了一种通用的消息框架，使用范围广泛，包括
从IM到通用消息工具PubSub。在2008年中期，Cisco收购了
Jabber.com(XMPP安装商业化的领袖），网络路由器也将很快装配
很小的、烧制了专用的XMIPP处理程序的硅芯片，供全世界使用。
BitTorrent
当你的用例是高度定制时，最好能够把数据处理流程调成“最优”。
砍掉这些琐碎的东西和多余的载荷，使得任意的客户端和服务器之
间的数据传输通信只适用于客户端和服务器紧密耦合并且协作良好
的情况。BitTorrent在分布式的一组节点上来回移动大量的二进制数
据块的速度是异常惊人的，这是对高度定制的用例进行优化的一个
很好的例子。
私有权/P2P
HTTP协议的一大不足是每个有效的请求/响应对包含了与之前相同
的数据头集合，即使这对操作可能是某个特定的客户端和服务器的
第n对的交互操作。如果能够在初始阶段管理好这些交互，使得数
据通道除了位操作之外其他什么都不做，那岂不是更智能？确实如
此。这个原因以及很多其他原因，驱动着“点到点"(Pint-2-Point或
Peer-2-Peer协议的很多实现，这些实现每天传输着大量的数据。
1457
---
## Page 1459
选择HTTP协议作为传输方式，这将带来一个问题：它对应的格式
是什么？当然，如果一个传输协议在过去几年中已经变得无处不
在，这个过程中基于其传输的数据也必然已经被“净化”了。
格式
XMIL为进一步实现数据格式化打下了基础。数据应该基于哪一个层
次格式来通信的问题基本上已经解决了。现在对由XML衍生出的数
据格式的讨论是所有一切讨论的起始。虽然现在有很多开发人员觉
得采用XML格式是理所当然的，但是值得注意的是这种数据格式非
常臃肿。XML基于文本的格式，在定义上非常有描述性，因而它通
常不是用于通信的最佳格式。每当我参与现代协议和格式的讨论
时，我就想起AOL专有的FDO模型。FDO是二进制的、紧凑的以比
特存储的协议/格式结合，为300波特的现代连接进行了优化。幸运
的是，网络连接已经发展到今天，宽带速度已经成为规范。
如上所述，正如HTTP协议一样，XML的劣势也是它的优势。如果
我们在过去15年学到了些东西，那便是无处不在的可读的协议和格
式一—我真的是这么认为。一种格式越是被人们所理解，它就越可
以进一步走向创新之路。当调试程序的唯一方式是通过解密工具把
数据转换成用大脑可以理解的东西时，人类创造性和通信之间就开
数据”只能通过计算机来处理。注意：有效载荷格式和元数据格式
（通常是XML)之间存在区别。高清晰的视频数据（如最近的高清
晰的轰动电影）占用了大量的物理空间，而且人们无法阅读它；我
把这种数据称为有效载荷格式。描述性的信息，比如视频的元数
据，是相对比较紧凑的。在网络中，通过有效载荷格式传输胜过元
数据传输（只要问问你最喜欢的网络服务提供商它占多少比例就知
道了），但是这种格式的数据在被计算机解码之前，相对显得呆板
无趣。
接口
接口（AI使事情变得开始有趣。一旦每个人都认识到大量的HTTP事
务像传统的API调用一样在网络上无处不在，REST协议为我们把
Web作为大分布式应用奠定了基础。RoyFielding是HTTP1.1协议的
贡献者之一，他教会我们如何像表示状态转换(Rpresentational State
Transfer,REST那样描述事物的思想框架。
1458
---
## Page 1460
开发者终于可以停止挣扎于使用CORBA和DCOM模式来把他们的逻
辑和数据分布到联网的计算机上，转而借助于标准的HTTP和基于
文本的工具来实现应用程序间在传统的Web应用层以下进行交互。
这导致你能够想到的几乎所有Web应用的API呈爆炸式发展，如图
8-1所示。API成为每个产品经理必有的东西。这既是件好事，也是
件坏事。从好的方面来看，成千上万的产品公开它们的数据，全世
界都能够访问。Programmable
Web（http：//www.programmableweb.com/）记录了好几百个这样的产
品，而且随时可以使用。从坏的方面来看，很多API很仓促地并发
出来，没有考虑到它们可能会如何被使用。其结果是由于API调用
程序根据性能或者功能特征，带来从WAN到各种可能满足或可能不
满足你的期望的不同终端范围的API调用高潮。很少有WebAPI提供
服务层协议(Srvice-LevelAgreement,SLA)，如果真的有这样的API，
其状况通常是很悲惨的。
1000
600
200
2007
2008
2009
年份
图8-1：在过去几年公用的API数量增长情况，数据来源于
ProgrammableWeb网站
为了使某个应用的数据和功能能够通过AP获取，不论是真正的还
是假想的需求，都可以在网络上创造一些有趣的挑战。
如果查看今天的API在网络上是如何使用的，那么你会发现它们看
起来是随意传输数据，且没有严格的SLA。在规模上，我们第一次
1459
---
## Page 1461
有软件可以非常有规律地和其他软件进行集成。这种集成方式称为
“混搭服务”(mshups)，因为它们把数据从各个服务中“混搭"在一
起。越来越多的终端用户期望数据在他们的社交应用能够具有实时
性，但是支持实时数据传输的基础设施还远远不够丰富。在实现实
时应用时，软件工程师无限复杂的创新性已经为应用提供实时通知
产生了很多不同的模型（如"Comet”、“WebHooks”，以及各种
“PubSub"消息通知系统）。这些模型其中有些行之有效，有些则没
有。不管你的方法是什么，解决方案在根本上没有真正的“魔术”；
相反，饱受考验的框架通常都是在“幕后”一直发挥着作用。
在应用软件中有两个基本的时间流处理(tme-flow-processing)原语
(Pimitives)：轮询(Plling)和事件(Eents)。应用程序根据时间来执行，
而用户交互的应用程序需要用户或者另一个服务的输入。该输入通
过轮询或者事件方式在应用中执行。值得注意的是你可以通过以上
任意一种模式来实现，在计算机课堂上应该讲解到使用它们的一些
绝妙技巧，我不在这里赘述。这里重要的是定义关于应用程序如何
收集它的相关输入的更高层的概念。使用例子来说明表达这两种模
型最简单。
轮询
轮询是通过应用程序不断询问中断是否有变化来实现的：如果检测
到变化，程序会执行定义好的动作。一个常用的类比是酒吧服务
员。想象一家酒吧，有1个服务员和10个顾客。如果这个服务员是
轮询模式的服务员，他会不断地询问每个顾客他们是否要喝酒。在
一杯吗？”等。不时地，其中一个被询问的顾客会回答“来一杯”，则
该服务员就先不询问了，给顾客倒一杯酒。轮询的方式实现起来美
丽简单，但是通常这对于客户端和服务器都是非常低效（正如类比
所示）。
速率控制[]
提供AP为开发者进行访问的方式来展示你的在线服务，通常可以
很容易实现：而基于应用程序构建一些框架并把数据连接起来就不
是那么容易了。但是，一旦把API开放出来，你就无法控制这些API
将会如何被其他应用程序使用。对程序的完全控制已经保护代码运
行了几千年的时间。因此，构建一个大规模的"WebAPr”（即"Web
服务”）需要付出慎重的考虑、熟练的管理和业务操作。
1460
---
## Page 1462
如果有人幸运地构建出一个令开发者很感兴趣的API，因此其轮询
负载将变得很大，在应用上处理负荷增长的最简单的方式是通过IP
或包头、通信层的访问，从而限制API的使用。虽然这种处理方式
解决了伸缩性问题，但是它中断了为取悦用户而集成这个API的程
序的处理流程。并发者不希望在他们的应用中构建“节流层”
(TrottlingLayer)，他们只是希望执行习惯性的调用，使得系统能够
“工作即可”。实际上，在系统中解决数据访问问题需要花费的精力
比基于IP的速率限制还要多（即“节流”），但是我们通常无法投入
足够的时间来调研真正的解决方案。一些社交数据的应用已经投入
精力来解决这个问题，他们的API能够承载高负荷访问（如Digg)。
但是绝大多数应用还不具备这一特点。
做止确的事
然而，包含大量社交数据的流行的社交应用程序在基础设施上不应
该要求有庞大的资金投入，也不必是具有很强横向扩展性的应用。
这些方面都会抑制产品的创新，耗费大量的资金。相反地，利用饱
经时间考验的“事件”原语，简单地说是通过有序方式。大量规则说
明了访问社交数据的90%以上的调用是不必要的。绝大多数时候，
这些数据甚至是无法访问的。仍然以之前的酒吧服务员为例，当顾
客回答“不喝酒"时，会由于被服务员不断地询问相同的问题而并始
变得不耐烦。
为了更新某个用户拍的照片，不断地询问Flickr是一种资源浪费。
相反地，如果当用户更新了他的照片，Flickr系统通知你的应用程
序来调用，这种处理方式就会更高效，对用户更重要以及更及时。
每加仑0英里的效率
我将使用众所周知的“Flickr，Friendfeed的例子"来强调在获取社交数
据时，使用轮询方式的低效性。总体来说，社交数据是由用户生成
的。这意味着依赖于利用社交数据的社交应用是基于人们的行为，
而不是更容易预测和管理的计算机的行为。当我们开发的软件的价
值完全是人类活动的某个功能时，事情开始变得有趣。这个例子很
有趣，因为发布者（Fickr)和消费者（Fiendfeed）都对用户的笔记留言
进行比较，这能够对通过轮询方式异步传输的“外部调用"ofbox的
本质问题产生有价值的洞察。
1461
---
## Page 1463
在2008年7月，EvenHenshaw-Plath和KellanElliot-McCrea在俄勒冈
州波特兰(Prtland)市组织的OSCON(OpenSourceConvention,O'Reilly
的开源集会）会议上发表了演讲“BeyondREST？”
(htp：//www.slideshare.net/kellan/beyond-rest)。在该演讲中，他们透
露为了确定Friendfeed的4.6万的用户账号在最近24小时内是否上传
相片，Friendfeed每天会请求Flickr的API290万次。而它的4.6万的用
户，其中仅仅7000个用户在这期间内会访问Flickr，可能会上传照
片。
一条著名的社交应用规则，称为"1-9-90"规则，在过去几年中开始
兴起。其要旨是，如果你考虑社交应用100%的用户基础，其中1%
的用户对核心数据有贡献（如"上传一张照片”），9%的用户参与贡
献数据（如"把一张照片标记为最喜欢的”），而90%的用户仅仅浏
览这些数据（如“视图照片”）。如果保守地把该规则应用于
Flickr/Friendfeed范例中，则可以说明在某一天有7000个用户访问了
Flickr，有700个用户会上传照片。这意味着Friendfeed请求Flickr接
口290万次，只是为了知道他们的700个用户确实做了某些更新。这
种方式“命中"的最高比率是0.02%，即4000次请求发现1条更新。