# Pwnhub-Crypto-韩国欧巴
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
近日有机会做了一次pwnhub的crypto，闲下来后做了一下记录
## 题目分析
题目很简短，如下
    #!/usr/bin/env python
    import gmpy
    from Crypto.Util.number import *
    from secret import x, y, flag
    assert gmpy.is_prime(y) ** 2016 + gmpy.is_prime(x+1) ** 2017 + ((x**2 - 1)**2 % (2*x*y - 1) + 2) ** 2018 == 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146
    p = gmpy.next_prime(x**3 + y**3)
    q = gmpy.next_prime(x**2*y + y**2*x)
    n = p * q
    phi = (p-1)*(q-1)
    d = gmpy.invert(0x10001, phi)
    enc = pow(bytes_to_long(flag), 0x10001, n)
    print 'n =', n
    print 'enc =', enc
这里我们摆出已知的几个式子  
那么现在的想法很清楚：
    1.利用已知的等式求出p和q
    2.利用已知的等式进行代换，不需求出p和q，直接整体带入解密
这里我们选择走一步看一步，因为这样比较复杂的公式，我也没办法直接看出正解，只能步步为营
## 解题step1
首先从题目给的等式入手，这里的
    is_prime(y)
    is_prime(x+1)
均为bool值  
式子中带有取余肯定是我们不希望看到的，于是我们从  
我们可以发现这是式子中的最高次，那么我们能否利用2018方对其进行范围缩小？  
尝试分析  
为了方便后续描述，我们将等式右边的大数命名为num  
通过简单运算发现
    num>pow(2,2018)
    num = PolynomialRing(Zmod(n), implementation='NTL')
        f = x - p_fake
        res = f.small_roots(X=2**i, beta=0.5)
        if res:
            for j in res:
                p_true = p_fake-j
                if n%p_true == 0:
                    print p_true
                    flag = True
                    break
        if flag:
            break
即可得到p
    19758773482416975773513594727554854838261383456469757248975289414355380735280879485422339870304527397062948550174303008020919366147474933112054539960497455035338201515203147106735705140472387837291772737954077643308046956678940164319688649687874053450947563446714782140815873215100887989866701486767419287547227200825869331893787470348194603234016874968352188422840451629535806709831811012761153410419196032233502030396198424770210265894560281233572716876438572799
## 解题step3
对于p的近似值恢复，也可以使用爆破方法，毕竟爆破量不是很大  
爆破脚本如下
    from Crypto.Util import number
    import gmpy2
    import gmpy
    import libnum
    import primefac
    e = 0x10001
    enc = 73933313646416156737449236838459526871566017180178176765840447023088664788672323530940171469589918772272559607026808711216932468486201094786991159096267208480969757088208089800600731106685561375522764783335332964711981392251568543122418192877756299395774738176188452197889668610818741062203831272066261677731889616150485770623945568369493256759711422067551058418926344060504112146971937651406886327429318390247733970549845424064244469193626197360072341969574784310397213033860597822010667926563087858301337091484951760613299203587677078666096526093414014637559237148644939541419075479462431789925219269815364529507771308181435591670281081465439913711912925412078002618729159141400730636976744132429329651487292506365655834202469178066850282850374067239317928012461993443785247524500680257923687511378073703423047348824611101206633407452837948194591695712958510124436821151767823443033286425729473563002691262316964646014201612
    n = 260272753019642842691231717156206014402348296256668058656902033827190888150939144319270903947159599144884859205368557385941127216969379550487700198771513118894125094678559478972591331182960004648132846372455712958337042783083099376871113795475285658106058675217077803768944674144803250791799957440111855021945690877200606577646234107957498370758707097662736662439460472126493593605957225541979181422479704018055731221681621886820626215670393536343427267329350730257979042198593215747542270975288047196483958369426727778580292311145109908665004662296440533724591193527886702374790526322791818523938910660223971454070731594803459613066617828657725704376475527288174777197739360634209448477565044519733575375490101670974499385760735451471034271880800081246883157088501597655371430353965493264345172541221268942926210055390568364981514774743693528424196241142665685211916330254113610598390909248626686397970038848966187547231199741
    p = 9*(gmpy.root(n/54,6)[0])**3
    for i in xrange(10000):
        if n%(p+i) == 0:
            p = p+i
            q = n/p
            phi = int((p-1)*(q-1))
            d = gmpy2.invert(e,phi)
            print libnum.n2s(pow(enc,d,n))
            break
也可以轻松得到flag
    flag{e01c9eb8078ea9bbac035ea68021c070}