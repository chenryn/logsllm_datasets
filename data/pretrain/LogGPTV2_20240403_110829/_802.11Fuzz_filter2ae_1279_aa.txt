# 【技术分享】基于802.11Fuzz技术的研究
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
作者：[](http://bobao.360.cn/member/contribute?uid=2665001095)[icecolor](http://bobao.360.cn/member/contribute?uid=775238387)
稿费：500RMB（不服你也来投稿啊！）
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
关于无线的Fuzz最开始接触了解时，国内基本毛线都搜不到。经过几个月的资料搜集和学习，将大约全网的fuzz资料整理翻译分析并读懂写下，就为填补国内空白，也希望无线爱好者能多多交流。
在各个安全领域的漏洞挖掘方法中，Fuzz都挺流行的.
Fuzz是一种黑盒软件测试技术，这基本上是使用畸形或半自动化的方式在一个畸形的数据注入发现执行错误，运用在协议也比较多。当源代码是不可用的时候，还是不错的，在802.11协议方面，Fuzzing的层面也比较多，特别是针对驱动和接入点的。
802.11的 State machine ，802.11标准规定的State machine
这里有‘State1 ，State2，State3’这三个状态。它这写的比较模糊，不太容易懂，翻译过来有点懵逼。其实这三个State的本意该是：
State1：是用于访问点的客户端设备的初始状态。
State2：是通过对访问点进行身份验证的身份验证状态。
State3：是一个授权发送接受数据通信帧并通过无线接入点和有线网络的关联的状态转换过程，然后反馈802.11Frames.
上面都提到了，802.11标准规定状态机必须在固件或者驱动中实现，许多的驱动管理的状态为了保证它的运行，都采用例如一个AP接受了Assoc请求后，只包括一个网络配置名称，这三个状态是很重要的，Fuzz的思路就是从这三个State机制中来。
802.11还定义了三种帧类型（就是上面那Class）：
Class1 Frames：允许从State1、2和3探测请求/响应,beacon,身份验证请求/响应/解除认证
Class2 Frames：只有经过身份验证,可以从State2和3(重新)Assoc请求/响应/解除关联
Class3 Frames：只有在Assoc请求下，可以能在State3内解除认证
每个State都可以进行fuzzing，但是第一个肯定是比后两个容易，因为后面两个都提到了需要成功认证的协议。
（两个图，第一个详细点，那个能看懂就看那个就行了）
**一、Access Points Fuzzing 802.11 的介绍：**
1、Fuzzing原理
无线协议里面，Beacon是802.11里面的一个重要组成部分，它涵盖了几乎所有AP的重要配置信息。
下面举个ApFuzzing框架的例子，就是通过构建畸形数据包，并将针对Wi-Fi 设备，然后发现已知和未知的漏洞。
Fuzzing802.11接入点，类似于802.11 client的fuzzing。无线客户端功能由接入点解析
802.11个访问点栈将解析大量的802.11的数据包：
*Probe request
*Authentication requests 
*Association requests 
*Crypted and unencrypted data frames 
*Control frames 
还有一些其他协议接入点可以fuzzing：
WPA/WPA2 handshakes
基于EAP的认证
基于State的Fuzzing
State1进行成功的身份验证请求
State2 进行成功的关联请求
State3是基于认证成功的密钥交换
****
****
2.Fuzzing 举例
Scapy是一个开放源代码的网络编程语言，它是基于Python，可以重放数据，捕获分析，产生随机数据包。可以根据自己的测试需求去改变，好像好多东西都需要它的支持，用处挺大的。有人基于Scapy写了一个叫做wifuzz的工具，写的接入点挺全的，能够fuzz出一些堆栈错误或者Crash，支持的接入点：
我选了个auth 模式的FUZZ，它会将FUZZ出来的的数据保存到一个路径下供我们查看。
    $ sudo python wifuzz.py -s fuzztest auth
    Thur Sep 26 21:41:36 2016 {MAIN} Target SSID: fuzztest; Interface: wlan0; Ping timeout:
    60;PCAP directory: /dev/shm; Test mode? False; Fuzzer(s): auth;
    Thur Sep 26 21:41:36 2016 {WIFI} Waiting for a beacon from SSID=[fuzztest] Thur Sep 26 21:41:36 2016 {WIFI} Beacon from SSID=[fuzztest] found (MAC=[11:22:33:44:55:66])
    Thur Sep 26 21:41:36 2016 {WIFI} Starting fuzz 'auth'
    Thur Sep 26 21:41:36 2016 {WIFI} [R00001] Sending packets 1-100
    Thur Sep 26 21:41:50 2016 {WIFI} [R00001] Checking if the AP is still up...
    Thur Sep 26 21:41:50 2016 {WIFI} Waiting for a beacon from SSID=[fuzztest] Thur Sep 26 21:41:50 2016 {WIFI} Beacon from SSID=[fuzztest] found (MAC=[11:22:33:44:55:66])
    Thur Sep 26 21:41:50 2016 {WIFI} [R00002] Sending packets 101-200 Thur Sep 26 21:42:04 2016 {WIFI} [R00002] Checking if the AP is still up...
    Thur Sep 26 21:42:04 2016 {WIFI} Waiting for a beacon from SSID=[fuzztest]
    Thur Sep 26 21:42:04 2016 {WIFI} Beacon from SSID=[fuzztest] found (MAC=[11:22:33:44:55:66])
    Thur Sep 26 21:42:04 2016 {WIFI} [R00003] Sending packets 201-300 Thur Sep 26 21:42:18 2016 {WIFI} [R00003] Checking if the AP is still up...
    Thur Sep 26 21:42:18 2016 {WIFI} Waiting for a beacon from SSID=[fuzztest] Thur Sep 26 21:42:19 2016 {WIFI} Beacon from SSID=[fuzztest] found (MAC=[11:22:33:44:55:66])
    Thur Sep 26 21:42:19 2016 {WIFI} [R00004] Sending packets 301-400
    Thur Sep 26 21:42:42 2016 {WIFI} [R00004] recv() timeout exceeded! (packet #325) Thur Sep 26 21:42:42 2016 {WIFI} [R00004] Checking if the AP is still up...
    Thur Sep 26 21:42:42 2016 {WIFI} Waiting for a beacon from SSID=[fuzztest]
    Thur Sep 26 10:40:42 2016 {WIFI} [!] The AP does not respond anymore. Latest test-case has been written to '/dev/shm/wifuzz-69erb.pcap'
再来个Beacon的内容配置：
在Metasploit中呢，有一个专门用于fuzz
Beacon的模块，不过要自己安装Lorcon2这个无线注入模块。[https://github.com/gitpan/Net-Lorcon2](https://github.com/gitpan/Net-Lorcon2) 安装后要配置好环境变量，这时候容易出错，细心点就行了。
因为是 Beacon这个接入点的FUZZ，那么它会产生无规则信息。
****
这就是个简单的举例，大家读懂了协议，Fuzzer都可以自己来。
****
**二、基于802.11 Driver 的Fuzzing**
关于802.11协议标准的深入解析
（1）802.11扩展有点复杂的…
几种帧类型（管理，数据，控制）大量的信令
速率，信道，网络名称，密码
所有这些东西都必须由固件/驱动程序解析
单独的针对驱动进行闭源驱动、逆向，开源驱动，黑白审计什么的，会很难….也很费劲，所以，Fuzz是一种很不错的选择
（2）Madwifi：是个Linux下的无线驱动，例如Atheros芯片驱动（没搞过无线的应该不知道不同芯片之间有啥区别，google一下就行了）
（3）802.11芯片提供了几种模式的操作用处：
监听802.11层
作为AP接入点
作为一个Ad-Hoc网络
作为一个Station
（4）802.11一共有两个扫描技术（主动与被动）
主动扫描：发送探测请求，并监听探测响应
被动扫描：监听Beacon和信道跳跃
（驱动可以监听Beacon和探测的响应数据。）
（5）802.11的扫描技术（主动与被动）
主动扫描：发送探测请求，并监听探测响应
被动扫描：监听Beacon和信道跳跃
驱动可以监听Beacon和探测的响应数据
1、Fuzzing原理及Fuzzer
关于information elements
信息元素是management frames.中的必要字段，信息元素是由类型、长度和值组成的。
信息元素由一个8位的类型字段，一个8位的长度字段，和多达255个字节的数据。 这种类型的结构是非常类似于在许多不同的协议中使用的普通类型-长度-值（TLV）形式。 信标和探测响应分组必须包含一个SSID 信息元素，对于大多数无线客户端处理数据包。一个支持信息元素值和信道信息元素。
拿这个老外的例子来说吧：
类型的元素为（1byte）
长度是Payload总长度的值（1byte）
Payload的信息元素值为（0-255byte）
有一些信息值是有固定长度的，如果不正确可能缓冲区溢出，如果在802.11内长度高于buffer的大小，则可能出现溢出。
例如。SSID属性，0为它的最小值，最大为32byte
用个循环来表示：