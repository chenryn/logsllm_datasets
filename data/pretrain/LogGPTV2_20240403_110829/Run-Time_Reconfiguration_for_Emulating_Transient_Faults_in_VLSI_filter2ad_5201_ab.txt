programmable device. It means that writing the proper 
bits  into  the  configuration  memory  will  allow  us  to 
modify the corresponding bits of the memory blocks. 
Hence,  the  following  steps  must  be  followed  to 
reverse  the  state  of  one  of  these  bits  (see  Figure  4): 
first, the logical value of that bit is extracted from the 
current  state  of  the  device  and,  after  that,  a  new 
reconfiguration  file  that  flips  that  logic  value  is 
downloaded into the FPGA configuration memory. 
MEMORY BLOCK (2 x n)
m
m
n
Address
DataIn
Clock
WriteEnable
ChipEnable
11001010
00101000
00001 00
00000011
1
/0
n
DataOut
(’1’)
>
.
.
.
.
.
.
Bit-flip
Reverse (’0’)
00000000
(’0’)
Figure 4. Reversing the state of a bit from an internal 
memory block 
the 
fault 
Since 
remains  until 
the 
reconfiguration  phase 
the  original 
configuration  (cf.  Figure  1)  after  fault  elapses  is 
skipped. 
rewritten, 
restores 
that 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:11:40 UTC from IEEE Xplore.  Restrictions apply. 
4.2. Pulse faults 
They  model 
the  occurrence  of  Single  Event 
Transients  (SET)  faults  in  combinational  logic.  The 
logic  state  of  a  combinational  element  is  reversed 
during a short period  of time,  behaving properly after 
that  time.  Target  elements  are  usually  synthesised  as 
function  generators, which are implemented by means 
of LUTs and their linking lines. Therefore, pulse fault 
emulation must target these FPGA components. 
With  respect  to  function  generators,  pulses  can 
target any LUT input line, the LUT output line and also 
the  combinational  circuit  the  LUT  implements.  The 
proposed approach is derived from the one presented in 
[15]  to  emulate  the  occurrence  of  stuck-at  faults  for 
BIST  effectiveness  evaluation.  Since  the  contents  of 
the  LUT  represent  the  truth  table  of  a  circuit,  it  is 
possible 
to  extract  this  information  to  obtain  a 
structural representation of the circuit. This truth table 
is  recomputed  (inverting  the  output,  input  or  internal 
line  of  the  circuit)  and  downloaded  into  the  FPGA 
configuration  memory  to  emulate  the  occurrence  of  a 
pulse in the targeted element (cf. Figure 5). 
Truth table: {’0’, ‘1’, ‘0’, ‘1’, ‘1’, ‘1’, ‘0’, ‘1’, ‘0’, ‘0’, ‘1’, ‘1’, ‘1’, ‘0’, ‘1’, ‘1’}
Circuit extraction
LUT4
LUT3
LUT2
LUT1
LUT
LUTout
LUT1
LUT4
LUT3
LUT2
LUTout
Pulse
Truth table: {’ ’, ‘1’, ‘ ’, ‘1’, ‘ ’, ‘1’, ‘ ’, ‘1’, ‘ ’, ‘ ’, ‘1’, ‘1’, ‘ ’, ‘ ’, ‘1’, ‘1’}
1
1
1
Fault injection
0
1
1
0
1
Figure 5. Injecting a pulse fault into a combinational 
circuit implemented as a LUT 
As  dealing  with  transient  faults,  disabling  the 
previously 
require 
reconfiguring again the FPGA to program the affected 
LUT with the original truth table. 
fault  will 
injected 
pulse 
A  different  approach  must  be  followed  when  the 
target  of  a  pulse  fault  is  not  a  LUT,  but  a  path  that 
connects to a CB input. Since all CB inputs, but LUT 
inputs (already covered), have a multiplexer in charge 
of inverting their incoming logical levels (cf. Figure 6), 
the  emulation  of  pulse  faults  in  these  lines  is  quite 
straightforward.  It  is  only  necessary  to  invert  the 
control  bit  of  the  multiplexer  for  the  targeted  line. 
Disabling  the  pulse  fault  is  only  a  matter  of  inverting 
again the control bit of the related multiplexer. 
Pulse
FFin
‘1’
‘0’
InvertFFinMux
Figure 6. Injecting a pulse fault (dashed lines) into a 
combinational path implemented as a CB input 
4.3. Delay faults 
the 
This  model  assumes  a  modification  of 
propagation  delay  of  a  circuit.  Although 
the 
propagation  delays  of  the  model  implemented  in  the 
FPGA will not match those of the final implementation, 
the  application  of  this  fault can provide an estimation 
of  the  behaviour  of  the  system  in  presence  of  delays. 
The FPGA elements that are susceptible to be used to 
emulate  delay  faults  are  the  interconnecting  lines  that 
implement  signals,  variables  and  ports  of  the  HDL 
model.  This  paper  proposes  two  different  approaches 
depending  on  whether  it  is  necessary  to  reroute  the 
target line. 
One  of  the  first  solutions  in  coming  to  mind  to 
increase the propagation delay of a path is to extend its 
length or increase the number of elements it traverses. 
The path is broken up to introduce a number of unused 
combinational  or  sequential  elements  such  as  FFs, 
LUTs and/or multiplexers. Thus, the injection of such a 
fault  involves  rerouting  the  target  path  to  include  all 
this  elements  or  to  extend  the  routing  through  some 
more  segment  lines  not  routed  yet.  For  example, 
implementing a shift register composed by the required 
number of unused FFs (cf. Figure 7) is a good manner 
to emulate a large delay in a line. Disabling the injected 
fault  involves  the  reconfiguration  of  the  FPGA  to 
restore its original configuration. 
A
Delay
A
LOOK-UP TABLE
(LUT)
LUTorFFMux
‘1’
LUTout
FFout
PR
D
Q
FLIP-FLOP
>
(FF)
FFin
InvertFFinMux
‘1’
CLR
Figure 7. Injecting a delay by means of routing a line 
through more logic (dashed lines substitute thick lines) 
A
A
Delay
Figure 8. Injecting a delay by increasing the fan-out of 
the line (dashed lines) 
The  second  approach  takes  into  account  that,  in 
programmable devices, the propagation delay of a line 
depends on its load capacitance, which is proportional 
to  the  fan-out  of  the  line.  Therefore,  increasing  the 
line’s  fan-out  increases  its  delay.  This  fan-out  can  be 
easily  increased  by  reconfiguring  the  control  bit  of 
unused pass transistors from the PMs the line is routed 
through (cf. Figure 8). Since each increment of the fan-
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:11:40 UTC from IEEE Xplore.  Restrictions apply. 
out  slowly  increases  the  propagation  delay  of the  line 
this  approach  is  adequate  to  emulate  faults  that 
introduce small propagation delays. Disabling the fault 
is performed just by restoring the original configuration 
of  the  control  bit  of  the  used  pass  transistors.  Of 
course, the resulting propagation delay depends on the 
selected  FPGA.  For  instance,  a  LUT  from  a  Virtex 
FPGA  [16]  has  a  delay  ranging  from  0.29  to  0.8 
nanoseconds while increasing the fan-out of a line can 
add between 0.001 and 0.018 nanoseconds. 
4.4. Indetermination faults 
This fault model assumes that the target will present 
an  undetermined  voltage level (between the high- and 
low-level  thresholds).  The  targets  of  this  fault  are  the 
combinational and sequential elements that  implement 
the logic of the HDL model, i.e. LUTs and FFs. 
One  can  possibly  think  that  the  best  way  of 
emulating an indetermination fault will be causing the 
occurrence  of  an  undetermined  logic  level  in  the 
targeted  element.  This  could  possibly  be  achieved  by 
causing  a  short-circuit  between  lines  holding  opposite 
logic  levels  or  by  leaving  the  target  line  opened. 
However, since we are dealing with digital circuits, the 
analogue  value  resulting  from  the  short-circuit  or  the 
open line will lead to a well defined although uncertain 
value  (logic  ‘0’  or  logic  ‘1’)  when  it  goes  through  a 
buffer  along  the  routing  or  at  the  input  of  a  CB. 
Therefore,  why  taking  the  effort  of  causing  the 
occurrence  of  short-circuits/open 
lines  instead  of 
generating the final logic levels? 
indetermination.  Under 
We propose the  use of a randomiser that generates 
the  final  logic  levels  the  internal  buffer  of  the  FPGA 
interprets as the undetermined voltage value caused by 
the 
this  assumption,  any 
procedure capable of modifying the logical value of the 
sequential  and  combinational  elements  is  eligible  to 
inject 
these  elements. 
Hence,  the  indetermination  injection  in  LUTs  follows 
the same scheme shown in Section 4.2 and the injection 
in  sequential  logic  is  very  similar  to  the  bit-flip 
injection (Section 4.1). 
indetermination  faults 
into 
4.5. Summary 
This  section  has  dealt  with  the  use  of  FPGAs  for 
emulating  a  wide  set  of  transient  faults  typically 
injected  in  HDL  models  of  VLSI  systems.  It  has 
presented, for each fault model, which FPGA resources 
can be targeted and how can the fault be emulated by 
means  of  FPGA  run-time  reconfiguration.  Table  1 
synthesizes the performed study. 
Table 1. Emulation of transient fault models with 
Fault model 
Bit-flip 
Pulse 
Delay 
FPGAs 
FPGA target  Description 
FFs 
Observations 
Slower than LSR 
Pulse GSR line 
Faster than GSR 
Pulse LSR line 
Modify memory bit 
Not applicable 
Use the input 
to LUT inputs 
inverter mux 
Modify LUT contents 
Increase fan-out 
Good for small delays 
Increase routing path  Good for large delays 
See Bit-flip 
See Pulse 
Randomly generate 
the final value 
Memory 
blocks 
CB inputs 
LUTs 
PMs 
FFs 
LUTs 
Indetermination 
5. Experimental tool 
the 
feasibility  of 
An experimental tool has been developed in order to 
show 
the  previously  defined 
methodology. That tool, named FADES (FPGA-based 
framework  for  the  Analysis  of  the  Dependability  of 
Embedded Systems), is based on the Virtex [16] FPGA 
series  from  Xilinx,  which  was  selected  due  to  the 
facilities  provided  to  work  with  its  configuration  file. 
This  first  prototype  has  been  implemented  on  an 
RC1000-PP board [17] from Celoxica. 
FADES consists of three different modules: 
–  Experiments  setup  module:  A  graphical  user 
interface  allows  the  user  to  specify  all  the  parameters 
required  to  perform  the  experiments.  Some  of  these 
parameters  are the  length of the experiments, the type 
of fault to be emulated, the fault location and duration, 
the observation points, etc. A view of this tool is shown 
in Figure 9. 
Figure 9. Experiments set-up tool 
– Fault emulation module: It is in charge of taking 
the  previously  defined  parameters  to  perform  the 
emulation  of  the  selected  faults.  It  makes  use  of  the 
JBits  package  [18]  that  provides  some  functions  to 