3.2复查源代码中的SQL注入
分析源代码漏洞主要有两种方法：静态代码分析和动态代码分析。静态代码分析是指在分
析源代码的过程中并不真正执行代码。动态代码分析是指在代码运行过程中对其进行分析。手
动静态代码分析是指对源代码逐行进行复查以发现潜在的漏洞。但对于包含很多行代码的大型
程序来说，要仔细检查每一行代码，通常是不可行的，因为那样会非常耗时耗力。为克服该问
题，安全顾间和开发人员通常会编写工具和脚本，或者使用各种开发工具和操作系统工具来辅
助完成大量基础代码的复查任务。
复查源代码时应采用系统的方法，这一点很重要。代码复查的目标是定位并分析可能隐含
程序安全问题的代码段。本章介绍的方法以检测受感染型漏润为目标。受感染数据是指从不可
信来源收到的数据（如果将受感染的数据复制给内部变量，内部变量同样会受感染）。使用经过
验证的没有受到感染的程序或输入验证函数可对受感染的数据进行净化。在程序易受攻击的位
置，受感染的数据会引发潜在的安全问题。这些易受攻击的位置被称为渗入点（sink）。
在复查SQL注入漏洞的语境中，我们将渗入点称为安全敏感（security-sensitive)函数，该函
数用于执行涉及数据库的SQL语句。为缩小复查关注的范围，我们应首先识别潜在的渗入点。
---
## Page 86
SQL注入攻击与防御（第2版）
这项任务并不简单，因为每种编程语言均提供了很多不同的方法来构造和执行SQL语句（3.2.2
节“危险的函数”会详细列举这些方法)。如果找到了一个渗入点，就说明很可能存在SQL注
入漏洞，大多数情况下必须进一步分析其他的代码以确定是否存在注入漏洞。如果Web开发人
员无法确保在将从渗入源（某种产生受感染数据的途径，比如Web表单、cookie、输入参数等）
收到的值传递给SQL查询（该查询在数据库服务器上执行）之前已对其进行验证，那么通常会引
发SQL注入漏洞。下面的PHP代码行说明了这个间题：
′$_GET["para=*]**) )
上述代码很容易引发SQL注入，因为它直接将用户输入传递给了动态构造的SQL语句，
并且该语句未经过验证就被执行
多数情况下，识别创建并执行SQL语句的函数并不是整个过程的最后一步，因为不可能
很容易地从代码行中发现存在的漏润。例如，下面的 PHP 代码行存在潜在的漏洞，但无法准
确地确定，因为我们并不知道Sparam变量是否受到感染或者它在传递给函数之前是否已经过
验证：
要准确确定是否存在漏洞，您需要跟踪该变量到其产生源并密切关注在应用中访间它的过
程。要实现该目的，您需要识别应用的入口点（渗入源）并搜索源代码以找到为Sparam变量赋值
的位置。应尽力找到与下列PHP代码行类似的代码：
$param = $_GET[“param*] 
上述代码行为Sparam变量分配了由用户控制的数据。
找到入口点之后，一定要跟踪输入以发现使用数据的位置和方式。可通过跟踪执行流程来
实现该目的。如果通过跟踪发现存在下面两行PHP代码，就可以断定程序在用户可操控的
Sparam参数中存在SQL注入漏洞：
param = $_GET["param"] ;
上述代码存在SQL注入漏洞，因为它直接将易受感染的变量（Sparam)传递给了动态构造的
SQL语句（渗入点)并被执行。如果通过跟踪发现存在下面三行PHP代码，那么同样可以断定程
序存在SQL注入漏洞，只不过对输入长度进行了限制。这意味着无法确定是否能有效地利用
该漏洞。接下来需要开始跟踪Slimit变量以准确判断到底存在多大的注入空间：
§param = $_GET[“param*] 
if (strlen (Sparam) 
在HTML中，可以为表单指定两种不同的提交方法：GET和POST。可以在FORM元素
内部使用METHOD属性来指定要使用的提交方法。GET和POST方法的主要差别在于对表单
数据的编码方法上。上述表单使用的是GET方法，即Web 浏览器将表单的数据编码在URL
中。如果表单使用的是POST方法，表单数据将显示在一个消息体中。如果使用POST方法提
交上述表单，将会在地址栏中看到“http://www.victim.com/process_input.pbp"：而如果使用 GET
方法提交上述表单，那么在地址栏中看到的内容将变为“http:/www.victim.com/process_
*ndu=reqgndu=oogdqd-ndu
问号（?）后面的内容称为查询字符串。查询字符串保存了通过表单提交的用户输入（也可以
在URL中手动提交）。在查询字符串中，使用和号（&）或分号（)分隔参数，使用等号（-）分隔参
数的名称和值。由于GET方法是在URL中对数据进行编码，面URL的最大长度是2048个字
符，因此该方法能传递的参数存在大小限制。POST方法则没有大小限制。ACTION属性用于
指定负责处理表单舞本的URL
Web应用还可以使用Webcookie。cookie是一种通用机制，服务端连接可使用它来存储、
75
---
## Page 90
SQL注入攻击与防御（第2版）
检索客户端连接的信息。Web开发人员可使用cookie在客户机上保存信息，并在以后的阶段中
检索要处理的数据。应用开发人员还可以使用HTTP头。HTTP头构成了HTTP请求的核心，
它们在HTTP响应中非常重要，它们定义了所请求数据或已提供数据的多种特性。
当Web服务器使用PHP处理HTTP请求时，PHP将HTTP请求中提交的信息转换成预定
义的变量。PHP开发人员可使用下列函数处理用户输入：
·S_GET：一个关联数组，存放通过HTTPGET方法传递的变量。
·SHTTP_GET_VARS：与S_GET相同，在PHP4.1.0中已弃用。
·S_POST：一个关联数组，存放通过HTTPPOST方法传递的变量。
·SHTTP_POST_VARS：与S_POST相同，在PHP4.1.0中已弃用。
·S_REQUEST：一个关联数组，包含S_GET、S_POST和S_COOKIE的内容。
·$_COOKIE：一个关联数组，存放通过HTTPcookie传递给当前脚本的变量。
·$HTTP_COOKIE_VARS：与S_COOKIE相同，在PHP4.1.0中已弃用。
·S_SERVER：服务器及执行环境的信息。
·$HTTP_SERVER_VARS：与S_SERVER相同，在PHP4.1.0中已弃用。
下列代码行说明了如何在PHP应用中使用这些函数：
//$_GET—一个存放通过GET方法传递变量的关联数组
Svariable = S_GET['name′]:
//SHTTP_GET_VARS——个通过HTTPGET方法传递变量的关联数组，在PHP4.1.0中已弃用
$variable = SGET_GET_VARS['name′];
//$_POST一个存放通过POST方法传递变量的关联数组
Svariable = S_POST['name′];
//$HTTP_POST_CARS—一个通过POST方法传递变量的关联数组，在PHP4.1.0中已弃用
$variable = SHTTP_POST_VARS [*name*1 ;
//S_REQUEST——个关联数组，包含S_GET、S_POST和S_COOKIE的内容
Svariable = S_REQUEST['name′];
//$_COOKIE——个关联数组，存放通过HTTPCookie传递的变量
//S_SERVER——服务器和执行环境的信息
[,eweu,1aIxooo s = etqeTxeAs
//$HTTP_DERVER_VARS—服务器和执行环境的信息，在PHP4.1.0中已弃用
$variable = SHTTP_SERVER_VARS[*name′]
PHP包含一个很有名的设置项—register_globals，可以在 PHP 的配置文件(php.ini)中对