k−1
i=1 ri +
(cid:2)k−1
k−1
i=1 si + c
By expanding the above, we get s
(cid:6)
) for some message m
=
4.2.1 Reduction to the k-Sum Problem
The attack uses a 2-node tree T where the challenger
controls the leaf node with some secret key sk∗
, and the
adversary controls the root node with a secret key sk. The
adversary chooses an arbitrary message m and initiates k − 1
concurrent calls to the signing oracle, using m,T as inputs to
each of the oracle queries. At the beginning of the challenge
phase of each concurrent oracle call i ∈ {1, . . . , k − 1} the
adversary chooses a malicious ¯ti (we show how to choose it
below). Note that there are no restrictions on the choice of ¯ti,
because it fully depends on adversary’s commitment in the root
node at the end of the commitment phase. During the response
phase the adversary obtains from T ’s leaf node si = ri+ci·sk∗
for all i ∈ {1, . . . , k − 1}, one for each concurrent call to the
signing oracle. Here ri is uniformly random (and unknown
to the adversary) and ci = H0(¯ti, m). The adversary then
∗ (cid:9)= m
∗
constructs a signature σ = (c
∗ · sk. We now
k−1
such that c
i=1 ci and s
show how to choose the ¯ti’s such that σ is a valid signature
(cid:6)
∗
for m
i=1 ci ·
k−1
(sk∗
i=1 ri, which
is computable from the challenger’s commitment values. Note
that σ is a valid signature if c
) =
(cid:6)
∗
∗
H0(h, m
=
k−1
i=1 H0(¯ti, m). So in order to produce a forgery,
(cid:6)
∗
and ¯ti for all
the adversary needs to ﬁnd values m, m
i ∈ {1, . . . , k − 1} such that H0(h, m
k−1
∗
i=1 H0(¯ti, m)
) =
modulo the group order.
We reduce this to the k-sum problem where list Li for each
i ∈ {1, . . . , k − 1} will contain sL outputs of H0(¯ti, m), ﬁlled
by evaluating the hash function on distinct values of ¯ti. List Lk
∗
will contain sL outputs of H0(h, m
), each for some distinct
. This requires that the message space is large
value of m
enough to produce a sufﬁcient number of list elements for list
Lk. In Section 4.2.3 we show how to extend this attack in case
if the message space is limited.
the unforgeability of CoSi can be broken in
any tree T where the challenger controls a non-root node
(recall
that our security notion allows only a single non-
adversarial tree node). Even though the values of PK j, tj and
sj propagate and accumulate throughout the tree, the adversary
can cancel out the contributed shares from all adversarial nodes
regardless of the tree structure, obtaining the shares that belong
speciﬁcally to the challenger’s node.
Furthermore, our attack can be extended to forge signatures
in any tree T where the attacker controls only the root node
∗
i=1 ri , m
(cid:6)
). But from the above we only know that c
k−1
i=1 ci =
Note that
∗
= H0(g
(cid:2)k−1
.
(cid:6)
∗
(cid:18)(cid:17)(cid:26)(cid:20)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:45:54 UTC from IEEE Xplore.  Restrictions apply. 
(cid:3)
(cid:3)
=
, sk∗
, sk∗
, qS, qC, qH, )-forger for CoSi in group G, where τ
,·,·). Here par are parameters and (pk∗
(note that our security notion does not model this case). In
order to do this, the attacker should treat all non-root nodes as
a single challenger node, meaning it should multiply together
all commitments and add together all responses acquired from
its children. Running the above attack would then produce a
forgery with respect to the sum of all secret keys that belong
to the non-root nodes in the tree. The extended attack requires
the same amount of resources as the basic attack against a
single challenger node.
Theorem 2. Let G = (cid:2)g(cid:3) be a cyclic group of prime order q.
Let A be an adversary that (τ, sL, )-breaks the k-sum problem
in group (Zq, +). Then there exists an adversary B that is
a (τ
τ + O(k · sL · lg q), qS = qC = k − 1 and qH = k · sL.
Proof of Theorem 2. We build a CoSi forger B. Recall that
adversary B playing against the unforgeability of CoSi takes
par , pk∗
as input, and is provided with an access to the random
oracle H0 : G × {0, 1}∗ → Zq and to the signing oracle
OSign(par ,sk∗
) is
a challenge key-pair generated by the security game. Upon
halting, the adversary has to return σ, m,PK, where σ is a
forgery for message m with respect to set of public keys PK.
Let B perform the following steps:
. Set T equal to
• Choose an arbitrary message m ∈ {0, 1}∗
a 2-node tree of depth 1 where the leaf node corresponds
to the challenge key pair pk∗
, and the root node is
controlled by the adversary. Sample an adversarial key
pair (pk , sk ) ←$ Kg(par ) that will be used for the root
node. Parse pk∗
) and pk as (y, π), then set
∗ · y. According to the key generation algorithm,
PK = y
we have PK = gsk∗
• Simultaneously initiate k−1 queries to the signing oracle
,·,·) with m and T as input. For each i ∈
OSign(par ,sk∗
{1, . . . , k− 1}, pause the i-th concurrent interaction with
the signing oracle after the commitment phase, having
acquired the commitment value pair (ti, pk∗
) where ti =
gri for ri ∈ Zq that was chosen uniformly at random and
is not known to B. Set h =
• Create empty tables T : {1, . . . , k − 1} × Zq → G and
Tk : Zq → Zq. For each i ∈ {1, . . . , k − 1} create an
empty list Li and ﬁll it with xi,j = H0(¯tj, m) for all
j ∈ {1, . . . , sL}, such that {¯t1, . . . , ¯tsL} are distinct ele-
ments from G. Set T [i, xi,j] = ¯tj accordingly. Create an
empty list Lk and ﬁll it with xk,j = q−H0(h, m
∗
j ) mod q
} are distinct
for j ∈ {1, . . . , sL}, such that {m
∗
1, . . . , m
elements from {0, 1}∗ \{m}. Set Tk[xk,j] = m
∗
j accord-
ingly.
• Run adversary A on lists L1, . . . , Lk to get a solution
to the k-list problem, meaning A returns to B a list of
elements c1, . . . ck ∈ Zq such that c1 + . . . + ck ≡ 0
mod q, and ci ∈ Li for all i ∈ {1, . . . , k}. Set m
∗
=
). Note that c1+. . .+ck−1 ≡ c
∗
Tk[ck] and c
mod q if adversary A returned a correct solution to the
k-sum problem.
• For each i ∈ {1, . . . , k − 1} set ¯ti = T [i, ci] and
pass (¯ti, PK ) as the challenge value pair to the i-th
∗
= H0(h, m
k−1
i=1 ti.
as (y
(cid:5)
+sk .
∗
sL
, π
∗
∗
∗
.
∗
∗
=
concurrent interaction with the signing oracle to get back
(cid:6)
the response si = ri + ci · sk∗
∗·sk mod q. Let σ = (c
k−1
• Compute s
i=1 si +c
and let PK = {pk∗
, pk}. Return σ, m
∗
(cid:6)
k−1
∗
j=1 ri. Then we have s
=
∗·sk = r
∗
∗
, m
),
Assume that adversary A returned a valid solution to the k-
(cid:6)
sum problem. Denote r
=
j=1 cj·sk∗
k−1
+sk ). It follows
∗ · PK −c
),
that c
∗
with respect
meaning σ is a valid signature for message m
to the aggregated public key PK .
∗·(sk∗
+c
) = H0(gs
∗
= H0(h, m
k−1
j=1 ri+
∗
) = H0(gr
,PK.
∗
, m
(cid:6)
+c
, s
∗
∗
∗
∗
4.2.2 Parameter Choices
√
When using the k-tree algorithm in the attack against CoSi,
we have n = lg q. If the number of parallel signing queries
is 3 then the adversary solves the 4-sum problem using 4 ·
q1/3 random oracle queries in time O(q1/3). Furthermore, if
lg q and the adversary uses (k − 1) parallel signing
k = 2
oracle queries, then it solves the k-sum problem using 22
lg q
random oracle queries in time O(22
lg q). More generally, if
the adversary uses (k − 1) parallel signing queries for any
k, then it has to solve the k-sum problem using qH = k ·
2lg q/(1+lg k) random oracle queries (to generate k lists of size
sL = 2lg q/(1+lg k)) and runtime τ ∈ O(k · 2lg q/(1+lg k)).
4.2.3 Producing a forgery for a ﬁxed message
√
√
∗
∗
∗
∗
k−1
i=1 si + c
= a · (cid:6)
= a · (cid:6)
∗
) for some message m
∗
, s
k−1
∗
i=1 ci and s
In the attack on CoSi described above, the list Lk is ﬁlled
. This requires that the message
using distinct values of m
space is large enough to produce a sufﬁcient number of list
elements for Lk. It also prohibits from producing a forgery for
. We now extend the attack
some a priori ﬁxed message m
to remove these restrictions. We will show how to produce a
∗
forgery for an arbitrary message m
Compared to the initial attack,
.
the adversary will now
construct a signature σ = (c
such
∗ · sk for
that c
an arbitrary group exponent a. The purpose of value a is to
, allowing to add a new
re-randomize possible values of c
element to list Lk for each distinct a. We now again show
∗
how to choose the ¯ti’s such that σ is a valid signature for m
.
+ sk ).
Let h = g
=
= a·(cid:6)
H0(ga·(cid:2)k−1
∗
). But we only know that
i=1 ri , m
k−1
k−1
∗
i=1 H0(¯ti, m). So in order to produce
c
∗
and
a forgery, the adversary needs to ﬁnd values a, m, m
(cid:6)
¯ti for all i ∈ {1, . . . , k − 1} such that H0(ha, m
) · a
−1 =
∗
k−1
i=1 H0(¯ti, m) modulo the group order.
We reduce this to the k-sum problem where list Li for each
i ∈ {1, . . . , k − 1} will contain sL outputs of H0(¯ti, m), ﬁlled
by evaluating the hash function on distinct values of ¯ti. List
−1, each for some
∗
Lk will contain sL outputs of H0(ha, m
distinct value a.
i=1 ri. Note that σ is a valid signature if c
i=1 ci = a·(cid:6)
From the above, we get s
∗
) = H0(ha, m
= a ·(cid:6)
k−1
i=1 ri + c
∗ · (sk∗
)·a
(cid:2)k−1
∗
∗
∗
problem:
The following steps change in the reduction to the k-sum
• In the ﬁrst step of the attack, adversary B now chooses
two arbitrary distinct messages m, m
• In the third step of the attack,
populated with xk,j = q − H0(haj , m
∗
∗ ∈ {0, 1}∗
.
the list Lk is now
) · a
−1
j mod q
(cid:18)(cid:17)(cid:26)(cid:21)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:45:54 UTC from IEEE Xplore.  Restrictions apply. 
∗
∗
∗
∗
= H0(ha, m
for j ∈ {1, . . . , sL}, such that {a1, . . . , asL
} are distinct
elements from Zq. Set Tk[xk,j] = aj accordingly.
• In the fourth step of the attack, B runs A to acquire a list
of elements c1, . . . ck ∈ Zq as before. It sets a = Tk[ck]
). Note that a(c1 + . . . + ck−1) ≡ c
∗
and c
mod q if adversary A returned a correct solution to the
k-sum problem.
• In the ﬁnal step of the attack, compute s
∗· sk mod q. Let σ = (c
c
Return σ, m
j=1 ri + a·(cid:6)
= a·(cid:6)
k−1
i=1 si +
), and let PK = {pk∗
, pk}.