title:Fixing Races for Fun and Profit: How to Use access(2)
author:Drew Dean and
Alan J. Hu
USENIX Association
Proceedings of the
13th USENIX Security Symposium
San Diego, CA, USA
August 9–13, 2004
© 2004 by The USENIX Association
Phone: 1 510 528 8649
All Rights Reserved
FAX: 1 510 548 5738
Rights to individual papers remain with the author or the author's employer.
Email: PI:EMAIL
For more information about the USENIX Association:
WWW: http://www.usenix.org
 Permission is granted for noncommercial reproduction of the work for educational or research purposes.
This copyright notice must be included in the reproduced paper. USENIX acknowledges all trademarks herein.
Fixing Races for Fun and Proﬁt: How to use access(2)
Drew Dean∗
Computer Science Laboratory, SRI International
PI:EMAIL
Alan J. Hu†
Dept. of Computer Science, University of British Columbia
PI:EMAIL
Abstract
It is well known that it is insecure to use the access(2)
system call in a setuid program to test for the ability of
the program’s executor to access a ﬁle before opening
said ﬁle. Although the access(2) call appears to have
been designed exactly for this use, such use is vulnera-
ble to a race condition. This race condition is a classic
example of a time-of-check-to-time-of-use (TOCTTOU)
problem. We prove the “folk theorem” that no portable,
deterministic solution exists without changes to the sys-
tem call interface, we present a probabilistic solution,
and we examine the effect of increasing CPU speeds on
the exploitability of the attack.
1
Introduction
Since the 1988 Morris worm, and particularly the 1996
tutorial on stack smashing in Phrack [1], the buffer over-
ﬂow has been the attacker’s weapon of choice for sub-
verting system security. Many techniques for preventing
or mitigating the effects of the lack of memory safety
have appeared in the literature [9, 14, 12, 13, 3]. Prior to
the popularization of stack smashing, various race con-
ditions were commonly utilized as the key step in privi-
lege escalation attacks, i.e., gaining superuser privileges
on a machine to which one has access via an ordinary
account. While not quite as catastrophic as a buffer over-
ﬂow in a network server that hands out superuser priv-
∗Work supported by the Ofﬁce of Naval Research under contract
N00014-02-1-0109. Any opinions, ﬁndings, and conclusions or rec-
ommendations expressed in this material are those of the author(s) and
do not necessarily reﬂect the views of the Ofﬁce of Naval Research.
†Work done mostly while a Visiting Fellow at SRI. Supported in
part by a grant from the Natural Science and Engineering Research
Council of Canada.
ileges to anyone who knows the magic packet to send,
local privilege escalation attacks remain a serious threat.
This is particularly true as another security vulnerability
may give the attacker the ability to execute code of their
choice as an unprivileged user. Given the wide range
of privilege escalation attacks on many common oper-
ating systems, it is very difﬁcult to prevent an attacker
from “owning” a machine once they can get the ﬁrst ma-
chine instruction of their choice executed. Hence, one
is wise to expend great effort to make sure that the at-
tacker cannot execute the ﬁrst instruction of an attack.
If we could prevent privilege escalation, we would have
more conﬁdence in the ability of lower-level operating
system primitives to contain the damage of security vul-
nerabilities exposed to the network. We make one of
many required steps towards that goal in this paper.
One particular race condition is especially infamous
among developers of security-critical software, particu-
larly setuid programs, on Unix and Unix-like systems:
the one between an appearance of the access(2) sys-
tem call, and a subsequent open(2) call. Although this
paradigm appears to have been the intended use of ac-
cess(2), which ﬁrst appeared in V7 Unix in 1979, it has
always been subject to this race condition. Recall that in-
dividual Unix system calls are atomic, but sequences of
system calls offer no guarantees as to atomicity. This is a
long standing problem: a 1993 CERT advisory [7] docu-
ments this exact race condition in xterm, and earlier ex-
ploits based on this problem are believed to exist. How-
ever, there is no generally available, highly portable, cor-
rect solution for providing the functionality of access(2).
This paper remedies this unfortunate situation. It is com-
monly accepted that ﬁxing this problem requires a ker-
nel change. While this is true for a deterministic solu-
tion, we present a highly portable probabilistic solution
that works under the existing system call interface. The
technique used is reminiscent of hardness ampliﬁcation
as found in the cryptology literature [16], but applied to
system calls, rather than cryptologic primitives.
We ﬁrst survey the problem, its history, partial solutions,
and related work. We then prove the “folk theorem”
that there is no (deterministic) solution to the problem
short of a kernel modiﬁcation. We present our proba-
bilistic solution, and experimental data showing the ex-
ploitability of the problem across several generations of
machines. Final thoughts are presented in the conclu-
sion.
2 Background
We ﬁrst describe the problem that we are solving, ex-
plain why some known partial solutions are not optimal,
and describe related work on this problem.
2.1 The Problem
One of Unix’s patented innovations was the introduc-
tion of the setuid bit on program ﬁles, to indicate that a
program should execute with the privileges of its owner,
rather than the user that invoked the program, as is the
normal case. As more sophisticated programs were de-
veloped using the setuid facility, there was desire to have
the ability to do access control checks based on the in-
voker of the program (i.e., the real user id of the pro-
gram, as opposed to the effective user id of the pro-
gram). The kernel is clearly the proper place to perform
these checks, as pathname parsing and traversal is tricky,
particularly since the introduction of symbolic links in
4.2 BSD [2]. This need was addressed with the addi-
tion of the access(2) system call to V7 Unix in 1979.
It appears that the intention was for the following code
fragment:
the ﬁle system in between the two system calls, to trick
a setuid program into opening a ﬁle that it should not.
Apple (MacOS X 10.3) and FreeBSD (4.7) are very suc-
cinct in their manual pages for access(2): “Access() is a
potential security hole and should never be used.” For
na¨ıve uses of access(2), this is true; however, we shall
see that the real situation is more complicated.
2.2 Partial Solutions
We will show that the Unix system call interface, as de-
ﬁned, offers no completely portable, deterministic solu-
tion to the problem. The deﬁnitive solution to this prob-
lem is a kernel change, of which there are many possi-
bilities, all of which can be made to work correctly. The
simplest change would appear to be the addition of an
O RUID option to be passed to open(2), specifying that
open(2) should use the real user id of the process, rather
than its effective user id, for access control decisions.
Without a kernel modiﬁcation, two other solutions par-
tially ﬁx the problem.
User id juggling Since the advent of saved user ids
in 4.2BSD, through one mechanism or another, modern
Unixes have had a way to temporarily drop privileges
gained from a program being setuid and then later re-
gain those privileges. Unfortunately, the setuid family
of system calls is its own rats nest. On different Unix
and Unix-like systems, system calls of the same name
and arguments can have different semantics, including
the possibility of silent failure [8]. Hence, a solution de-
pending on user id juggling can be made to work, but is
generally not portable.
if(access(pathname, R_OK) == 0)
if((fd = open(pathname, O_RDONLY))
== 0) ...
to work in the obvious way – that is, to check whether
pathname is readable, and if so, open the ﬁle for reading
on ﬁle descriptor fd.
Unfortunately, there is a classic time-of-check-to-time-
of-use (TOCTTOU) [11] problem lurking here: the pair
of access(2) and open(2) system calls is not a single,
atomic operation. Hence, a clever attacker can change
Passing an open ﬁle descriptor A somewhat im-
proved approach is to fork off a child process, have that
process permanently drop all extra privileges, and then
attempt to open the ﬁle. If successful, the child process
can pass the open ﬁle descriptor across a Unix-domain
socket and exit.1 The user id handling is greatly simpli-
ﬁed, although some of the caveats above still apply. The
major drawback is that fork(2) is a relatively expensive
system call, even with copy-on-write optimizations.
1This idea was communicated to the ﬁrst author by Michael Plass
of PARC.
2.3 Related Work
The standard paper on this subject is the 1996 work of
Bishop and Dilger [6]. They provide a very comprehen-
sive description of the problem, dissecting a 1993 CERT
advisory of a real life instance of this problem. Bishop
and Dilger then go on to discuss static analysis tech-
niques for ﬁnding the problem in C programs. Rather
surprisingly, Bishop’s well known 1987 paper, “How to
Write a Setuid Program” [4] does not mention this pit-
fall. Bishop’s book [5] also discusses the problem and its
workarounds. We have tried to ﬁnd the ﬁrst description
of this problem in the literature, but so far have come up
empty.2 The ﬁrst author recalls this problem being part
of the folklore in the late 1980s.3
Cowan, et al., [10] cover a very similar problem, a race
condition between the use of stat(2) and open(2), with
their RaceGuard technology. They changed the ker-
nel to maintain a small per-process cache of ﬁles that
have been stat’d and found not to exist. If a subsequent
open(2) ﬁnds an existing ﬁle, the open fails. This race
condition is primarily found in the creation of tempo-
rary ﬁles. While it is essentially equivalent to the ac-
cess(2)/open(2) race we consider in this paper, the solu-
tion is entirely different: they modify the kernel, we do
not. Tsyrklevich and Yee [15] take a similar approach
to RaceGuard, in that their solution involves a kernel
modiﬁcation. However, they have a richer policy lan-
guage to express what race conditions they will inter-
cept, and they suspend the putative attacker process (a
process that interfered with another process’ race prone
call sequence) rather than causing an open(2) call to fail.
Again, Tsyrklevich and Yee modify the kernel, to ﬁx ex-
isting vulnerable applications, whereas we are proposing
a user level technique to solve the problem.
3 No Deterministic Solution
Given the difﬁculties and overheads of existing solu-
tions to the access(2)/open(2) race, it’s tempting to try to
imagine a solution that doesn’t require kernel changes,
juggling user ids, forking processes, or dropping privi-
leges. Fundamentally, the problem arises because per-
missions to a ﬁle are a property of a path (being depen-
dent on the relevant execute permission along all direc-
2We would greatly appreciate any citation between 1979 and 1992
being brought to our attention.
3Messrs. Bellovin, Kernighan, Ritchie, Shapiro and Ms. Mintz
concur with this recollection in private communication, January 2004.
tories on the path and the relevant permissions for the
ﬁlename), and the mapping of paths to ﬁles is mutable.
However, the inode (and device number, and generation
number if available) for a ﬁle is not a mutable mapping;
it’s the ground truth. Perhaps a clever combination of
system calls and redundant checks, verifying that the
path-to-inode mapping did not change, could be made
to work, analogous to mutual exclusion protocols that
don’t need atomic test-and-set instructions.
A widely held belief is that such a solution isn’t possi-
ble, but to our knowledge this has never been precisely
stated nor proven. Here, we state and prove this theo-
rem. Furthermore, the assumptions needed to prove the
theorem will suggest an alternative solution.
Theorem 1 Under the following assumptions:
• the only way for a setuid program to determine
whether the real user id should have access to a ﬁle
is via the access(2) system call or other mechanisms
based on the pathname (e.g., parsing the pathname
and traversing the directory structures) rather than
the ﬁle descriptor,
• none of the system calls for checking access per-
mission also atomically provide a ﬁle descriptor or
other unchangeable identiﬁer of the ﬁle,
• an attacker can win all races against the setuid pro-
gram,
then there is no way to write a setuid program that is
secure against the access(2)/open(2) race.
The ﬁrst assumption means that the theorem ignores so-
lutions based on juggling user ids and giving up privi-
lege, which we rule out because of portability and ef-
ﬁciency concerns. The ﬁrst two assumptions also im-
ply ignoring various solutions based on kernel changes:
for example, an faccess(2) call that determines access
permissions given a ﬁle descriptor violates the ﬁrst as-
sumption, whereas an O RUID option to open(2), as dis-
cussed in Section 2.2, violates the second assumption.
Note that although fstat(2) at ﬁrst glance appears to vio-
late the ﬁrst assumption, it actually doesn’t, since the stat
buffer contains permission information for the ﬁle only,
but doesn’t consider the permissions through all directo-
ries on the ﬁle’s path. In general, the theorem applies to
any combination of the typical accessors of the ﬁle sys-
tem state: access(2), open(2), stat(2), fstat(2), lstat(2),
read(2), getdents(2), etc. The third assumption is stan-
dard when analyzing security against race conditions.
Proof: Any attempted solution will perform a sequence
of system calls. We can model this sequence as a string
σ over the alphabet {a, o}, where a represents a call to
an access-checking function, and o represents any other
call, e.g., open(2). (If the attempted solution has mul-
tiple control ﬂow paths making different sequences of
calls, we can model this as a ﬁnite set of strings, one
for each path through the program, and the attacker can
attack each of these strings separately.) Similarly, we
can model the attacker’s execution as a string τ over the
alphabet {g, b}, where g represents swapping in a good
ﬁle (one for which the real user id has permission) for
the ﬁle whose access is being checked, and b represents
swapping in a bad ﬁle (one for which the real user id
doesn’t have permission). An attempted attack is an in-
terleaving ρ of the strings σ and τ .
The assumption that the attacker can win races against
the setuid program means that the attacker can control
what interleaving occurs (at least some fraction of the
time — we only need one success for a successful at-
tack). Suppose the attempted solution σ contains n in-
stances of a. The attack can then consist of the string
(gb)n, and the attacker can make the interleaving ρ such
that each call a is immediately bracketed before by g and
after by b. Therefore, every access-checking call checks
the good ﬁle and grants permission, whereas all other
operations will see the same bad ﬁle, and hence there
will be no inconsistencies that can be detected. There-
fore, under the assumptions, there is no secure solution.
The above theorem actually generalizes to other TOCT-
TOU problem instances that satisfy similar assumptions.
If there is no way to check something and acquire it in
a single atomic operation, and if we assume the attacker
can win races, then the attacker can always swap in the
good thing before each check and swap in the bad thing
before any other operations.
Notice how strongly the proof of the theorem relies on
the assumption that the attacker can win races when-
ever needed. This assumption is reasonable and pru-
dent when considering the security of ad hoc races that
occurred by oversight, since a determined attacker can
employ various means to increase the likelihood of win-
ning races and can repeat the attack millions of times.
However, is this assumption still reasonable if we care-
fully design an obstacle course of races that the attacker
needs to win? By analogy to cryptology, an attacker that
can guess bits of a key can break any cryptosystem, but
with enough key bits, the probability of guessing them
all correctly is acceptably small. This insight leads to
our probabilistic solution.
4 A Probabilistic Solution
Our probabilistic solution relies on weakening the as-
sumption that the attacker can win all races whenever
needed. Instead, we will assume the more realistic as-
sumption that, for each race, the attacker has some prob-
ability of winning. This probability will vary depending
on the details of the code, the OS, the CPU speed, the
disks, etc., which we will discuss in Section 5, but the
fundamental idea is to treat races as probabilistic events.
The other major assumption needed for our solution is
that the calls to access(2) and open(2) must be idempo-
tent and have no undesirable side effects. For typical
usages of opening ﬁles for reading or writing, this as-
sumption is reasonable. However, one must be careful
with certain usages of open(2). In particular, some com-
mon ﬂag combinations, like (O_CREAT | O_EXCL),
are not idempotent and will not work with our solution.
Similarly, calling open(2) on some devices may cause
undesirable side effects (like rewinding a tape), which
our solution will not prevent.
The probabilistic solution starts with the standard calls
to access(2) followed by open(2). However, these two
calls are then followed by k strengthening rounds, where
k is a conﬁgurable strengthening parameter. Each
strengthening round consists of an additional call to ac-
cess(2) followed by open(2), and then a check to verify
that the ﬁle that was opened was the same as had been
opened previously (by comparing inodes, etc.). When
k = 0, our solution degenerates into the standard, race-
vulnerable access(2)/open(2) sequence. Figure 1 shows
the code for our solution.
The probabilistic solution adds some overhead over the