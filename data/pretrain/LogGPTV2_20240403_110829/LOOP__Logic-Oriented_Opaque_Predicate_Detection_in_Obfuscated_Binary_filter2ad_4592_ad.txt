b
e
d
-
i
t
n
A
n
e
t
t
a
ﬂ
G
F
C
M
V
-
i
t
n
A
(cid:88) (cid:88)
(cid:88) (cid:88)
(cid:88)
(cid:88) (cid:88)
(cid:88)
P
O
#
(0,0,0)
(2,0,0)
(0,0,0)
(5,3,1)
(3,0,0)
(8,1,1)
(cid:88) (cid:88) (12,0,0)
(2,0,0)
(0,0,0)
(cid:88) (cid:88) (cid:88) (cid:88) (10,0,0)
(cid:88) (cid:88)
(90,3,1)
(6,0,0)
(4,0,0)
(6,0,0)
(8,1,0)
(cid:88)
(cid:88) (cid:88)
(cid:88)
(cid:88)
(cid:88)
)
N
F
#
,
P
F
#
(
(0, 0)
(0, 0)
(0, 0)
(2, 0)
(1, 0)
(0, 0)
(4, 0)
(0, 0)
(1, 0)
(0, 0)
(0, 0)
(2, 0)
(0, 0)
(1, 0)
(3, 0)
)
s
(
i
e
m
T
3.4
4.2
3.0
7.8
15.4
22.3
244.5
8.2
5.3
8.5
36.2
24.6
18.2
132.3
192.3
(cid:88) (cid:88)
(cid:88)
(cid:88) (cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88) (cid:88)
r
e
k
c
a
p
r
e
k
c
a
p
.
t
p
y
r
c
n
E
.
s
e
r
p
m
o
C
(cid:88)
(cid:88)
(cid:88)
.
e
p
m
a
t
t
n
a
t
s
n
o
c
r
e
d
r
o
e
r
e
d
o
c
k
n
u
J
e
d
o
C
e
u
q
a
p
O
k
c
a
t
s
-
l
l
a
C
(cid:88) (cid:88) (cid:88) (cid:88)
(cid:88) (cid:88)
(cid:88)
(cid:88) (cid:88)
(cid:88) (cid:88) (cid:88)
ASPack
Packer
FSG
UPX
PECompact
VMProtect
e
z
i
S
12
29
13
30
32 Yoda’s Protector (cid:88) (cid:88)
(cid:88) (cid:88)
33
(cid:88)
276
(cid:88) (cid:88)
30
(cid:88) (cid:88)
20
(cid:88)
17
(cid:88) (cid:88)
61
47
60
41
85 Yoda’s Protector (cid:88) (cid:88)
ASPack
ASPack
Themida
PolyEnE
UPack
UPack
PECompact
ASProtect
(cid:88) (cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) (cid:88) (cid:88) (cid:88)
Table 5: Speed up metamorphic malware variants
matching
Family
Metaphor
Lexotan32
Win32.Evol
Basic blocks
reduction (%)
Isomorphism
speedup (X)
26
20
16
2.0
1.6
1.2
last branch is always true.
In summary, our experiments
show that LOOP is eﬀective in detecting opaque predicates
in obfuscated binary code with a zero false negative rate.
Considering that LOOP aims to provide a general and au-
tomatic de-obfuscation solution, which usually involves te-
dious manual work, the false positive rate is tolerable.
6.3 Metamorphic Malware Matching
To conﬁrm the value of our approach in malware defenses,
we also test LOOP in the task of code normalization for
metamorphic malware [9, 10]. Metamorphic malware mu-
tates its code during infection so that each variant bears
little resemblance to another one in syntax. It is well known
that metamorphism can undermine the signature-based anti-
malware solutions [44]. Bruschi et al. [9, 10] propose code
normalization to reverse the mutation process. To test whether
an instance of metamorphic malware is present inside an in-
fected host program, they compare malicious code and nor-
malized program by inter-procedural control ﬂow subgraph
isomorphism. The drawback is that they do not handle
opaque predicates, although opaque predicates are one of
the commonly used mutation methods. Opaque predicates
can seriously thwart normalized control ﬂow graph compari-
son [9]. We re-implement their code normalization based on
BAP and test the speedup of normalized control ﬂow graph
isomorphism under the preprocess of LOOP on three famous
metamorphic malware families.
Since the three metamorphic malware samples are all ﬁle-
infecting, we ﬁrst force each malware to infect 20 Cygwin
utilities.4 For each family, we follow similar steps as in Br-
uschi et al.
to normalize infected programs and compare
their control ﬂow graphs (CFG) with malicious code’s CFG,
leveraging VFLIB library [20]. In addition, we apply LOOP
to preprocess infected programs to remove the corresponding
superﬂuous branches and infeasible paths. Table 5 shows the
improvements introduced by our approach on average. Com-
pared with the results without applying LOOP, we remove
redundant basic blocks as much as 26% and speed up sub-
graph isomorphism by a factor of up to 2.0 (e.g., Metaphor).
7. DISCUSSIONS AND FUTURE WORK
We further discuss about our design choices, limitations
and future work in this section.
Dynamic Approach.
Our approach bears the similar limitations as dynamic
analysis in general. For example, LOOP can only detect
opaque predicates executed at run time. Static analysis
might explore all the possible paths in the program. How-
ever, even static disassembly of stripped binaries is still a
challenge [30, 47]. Moreover, the various obfuscation tech-
niques listed in Table 4 will undoubtedly deter extracting
accurate control ﬂow graph from binary code. We believe
our approach, based on the test cases that execute opaque
predicates, is practical in analyzing a malicious program. A
possible way to increase path coverage is to leverage test-
generation techniques [13, 25] to automatically explore new
paths. Another concern we want to discuss is scalability is-
sue. The size of a slice may become signiﬁcant for a program
with high workload, and our detection approach is linearly
dependent on the size of a slice. In that case, LOOP has
to analyze a large number of predicates, resulting in a sub-
stantial performance slowdown. One way to alleviate the
high overhead is to detect opaque predicates in parallel. We
plan to explore this direction in our future work. Detect-
4www.cygwin.com
765Figure 10: Example of two-way opaque predicates.
Figure 11: Example of 3x+1 conjecture.
ing repetitive opaque predicates due to loop unrolling leads
to performance penalty. We will extend our tool with loop
identiﬁcation in the next version.
Floating Point.
The eﬀect of LOOP is restricted by the capability of the
constraint solver and symbolic execution tools. One example
is ﬂoating point. Since precisely deﬁning the rounding se-
mantics of ﬂoating point is challenging, current binary sym-
bolic execution does not support ﬂoating point instructions
(e.g., fdiv and fmul) [7]. As a result, currently LOOP is
unable to detect opaque predicates involving ﬂoating point
operations. One might argue that attackers can easily get
around LOOP by using ﬂoating point equations. However,
using ﬂoating point equations in malware increases the pos-
sibility of detection as well, because both ﬂoating point in-