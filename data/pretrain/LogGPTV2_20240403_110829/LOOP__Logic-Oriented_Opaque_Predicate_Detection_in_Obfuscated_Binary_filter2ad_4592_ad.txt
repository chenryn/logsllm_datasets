### 优化后的文本

#### 表5：加速变形恶意软件变种匹配
| 家族 | 变形 | 基本块减少 (%) | 同构速度提升 (X) |
|------|------|-----------------|------------------|
| Metaphor | Lexotan32 | 26 | 2.0 |
| Win32.Evol | - | 20 | 1.6 |
| - | - | 16 | 1.2 |

在总结中，我们的实验表明，LOOP 在检测混淆二进制代码中的不透明谓词方面非常有效，并且没有假阴性。考虑到 LOOP 的目标是提供一种通用且自动的去混淆解决方案，这通常涉及繁琐的手动工作，因此假阳性率是可以接受的。

### 6.3 变形恶意软件匹配
为了验证我们方法在恶意软件防御中的价值，我们还测试了 LOOP 在变形恶意软件 [9, 10] 代码规范化任务中的表现。变形恶意软件在其感染过程中会改变其代码，使得每个变种在语法上几乎没有相似之处。众所周知，变形可以削弱基于签名的反恶意软件解决方案 [44]。Bruschi 等人 [9, 10] 提出了代码规范化来逆转变异过程。为了测试一个变形恶意软件实例是否存在于被感染的主机程序中，他们通过过程间控制流子图同构比较恶意代码和规范化程序。缺点是他们没有处理不透明谓词，尽管不透明谓词是常用的变异方法之一。不透明谓词会严重阻碍规范化控制流图的比较 [9]。我们基于 BAP 重新实现了他们的代码规范化，并测试了在三个著名的变形恶意软件家族中应用 LOOP 预处理后对规范化控制流图同构的速度提升。

由于这三个变形恶意软件样本都是文件感染型，我们首先强制每个恶意软件感染 20 个 Cygwin 工具。对于每个家族，我们遵循与 Bruschi 等人类似的方法来规范化受感染的程序，并使用 VFLIB 库 [20] 比较它们的控制流图 (CFG) 与恶意代码的 CFG。此外，我们应用 LOOP 对受感染的程序进行预处理，以移除相应的冗余分支和不可行路径。表 5 显示了我们方法带来的平均改进。与未应用 LOOP 的结果相比，我们最多减少了 26% 的冗余基本块，并将子图同构的速度提高了最多 2.0 倍（例如，Metaphor）。

### 7. 讨论和未来工作
在本节中，我们将进一步讨论我们的设计选择、局限性和未来的工作。

**动态方法**
我们的方法具有与动态分析类似的局限性。例如，LOOP 只能检测运行时执行的不透明谓词。静态分析可能会探索程序中的所有可能路径。然而，即使是对剥离二进制文件的静态反汇编仍然是一个挑战 [30, 47]。此外，表 4 中列出的各种混淆技术无疑会阻碍从二进制代码中提取准确的控制流图。我们认为，基于执行不透明谓词的测试用例，我们的方法在分析恶意程序时是实用的。一种增加路径覆盖率的可能方法是利用测试生成技术 [13, 25] 自动探索新的路径。另一个需要讨论的问题是可扩展性问题。对于高负载的程序，切片的大小可能会变得很大，而我们的检测方法线性依赖于切片的大小。在这种情况下，LOOP 必须分析大量的谓词，从而导致显著的性能下降。减轻高开销的一种方法是并行检测不透明谓词。我们计划在未来的工作中探索这一方向。由于循环展开导致的重复不透明谓词检测会导致性能损失。我们将在下一版本中扩展我们的工具以识别循环。

**浮点运算**
LOOP 的效果受到约束求解器和符号执行工具能力的限制。一个例子是浮点运算。由于精确定义浮点运算的舍入语义很困难，当前的二进制符号执行不支持浮点指令（如 fdiv 和 fmul）[7]。因此，目前 LOOP 无法检测涉及浮点运算的不透明谓词。有人可能会认为，攻击者可以通过使用浮点方程轻松绕过 LOOP。然而，使用浮点方程也会增加被检测的可能性，因为浮点运算增加了恶意软件的复杂性和检测难度。

希望这些改进能使您的文本更加清晰、连贯和专业。如果有任何进一步的需求，请随时告知。