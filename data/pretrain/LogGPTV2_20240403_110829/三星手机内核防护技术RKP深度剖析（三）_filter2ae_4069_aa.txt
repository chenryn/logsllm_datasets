# 三星手机内核防护技术RKP深度剖析（三）
|
##### 译文声明
本文是翻译文章，文章原作者 longterm，文章来源：longterm.io
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
在本系列文章中，我们将为读者深入讲解三星手机的内核防护技术。在上一篇文章中，我们为读者介绍了本研究所使用的平台，如何在两种平台上面提取二进制文件，如何获取相关的符号/日志字符串，简要介绍了管理程序的框架，最后，详细说明了三种公用的结构体。在本文中，将继续为读者呈现更多精彩内容！
**（接上文）**
## 系统初始化
实际上，uH/RKP是由S-Boot（Samsung
Bootloader）加载到内存中的。S-Boot通过命令安全监视程序（运行在EL3）在其指定的地址开始执行管理程序的代码，来跳转到EL2入口点。
    uint64_t cmd_load_hypervisor() {
        // ...
        part = FindPartitionByName("UH");
        if (part) {
            dprintf("%s: loading uH image from %d..\n", "f_load_hypervisor", part - >block_offset);
            ReadPartition( & hdr, part - >file_offset, part - >block_offset, 0x4C);
            dprintf("[uH] uh page size = 0x%x\n", (((hdr.size - 1) >> 12) + 1)  0x200000 || hdr.size > 0x1FEDF0) {
                dprintf("Could not do normal boot.(invalid uH length)\n");
                // ...
            }
            ret = memcmp_s( & hdr, "GREENTEA", 8);
            if (ret) {
                ret = -1;
                dprintf("Could not do uh load. (invalid magic)\n");
                // ...
            } else {
                ReadPartition(0x86FFF000, part - >file_offset, part - >block_offset, total_size);
                ret = pit_check_signature(part - >partition_name, 0x86FFF000, total_size);
                if (ret) {
                    dprintf("Could not do uh load. (invalid signing) %x\n", ret);
                    // ...
                }
                load_hypervisor(0xC2000400, 0x87001000, 0x2000, 1, 0x87000000, 0x100000);
                dprintf("[uH] load hypervisor\n");
            }
        } else {
            ret = -1;
            dprintf("Could not load uH. (invalid ppi)\n");
            // ...
        }
        return ret;
    }
    void load_hypervisor(...) {
        dsb();
        asm("smc #0");
        isb();
    }
注意：在最新的三星设备上，监视程序代码（基于ATF-ARM可信固件）已经不再以纯文本的形式出现在S-Boot二进制文件中，取而代之的是一个加密的blob。现在，我们需要利用三星的可信操作系统实现（TEEGRIS）的漏洞，才能转储到纯文本形式的监视程序代码。
    void
    default(...) {
            // ...
            if (get_current_el() == 8) {
                // Save registers x0 to x30, sp_el1, elr_el2, spsr_el2
                // ...
                memset( & rkp_bss_start, 0, 0x1000);
                main(saved_regs.x0, saved_regs.x1, &saved_regs);
            }
            asm("smc #0");
        }
在这里，代码是从default函数开始执行的。在调用main之前，这个函数将先检查是否在EL2中运行。一旦main返回，它就会进行SMC，大概是为了把控制权还给S-Boot。
    int32_t main(int64_t x0, int64_t x1, saved_regs_t * regs) {
        // ...
        // Setting A=0 (Alignment fault checking disabled)
        //SA=0 (SP Alignment check disabled)
        set_sctlr_el2(get_sctlr_el2() & 0xFFFFFFF5);
        if (!initialized) {
            initialized = 1;
            // Check if loading address is as expected
            if ( & hyp_base != 0x87000000) {
                uh_log('L', "slsi_main.c", 326, "[-] static s1 mmu mismatch");
                return - 1;
            }
            set_ttbr0_el2( & static_s1_page_tables_start__);
            s1_enable();
            uh_init(0x87000000, 0x200000);
            if (vmm_init())
            return - 1;
            uh_log('L', "slsi_main.c", 338, "[+] vmm initialized");
            set_vttbr_el2( & static_s2_page_tables_start__);
            uh_log('L', "slsi_main.c", 348, "[+] static s2 mmu initialized");
            s2_enable();
            uh_log('L', "slsi_main.c", 351, "[+] static s2 mmu enabled");
        }
        uh_log('L', "slsi_main.c", 355, "[*] initialization completed");
        return 0;
    }
在禁用对齐检查并确保将该二进制文件加载到预期地址（0x87000000)后，main函数会把TTBR0_EL2设置为其初始页表，并调用s1_enable函数。
    void s1_enable() {
        // ...
        cs_init( & s1_lock);
        // Setting Attr0=0xff (Normal memory, Outer & Inner Write-Back Non-transient,
        //Outer & Inner Read-Allocate Write-Allocate)
        //Attr1=0x00 (Device-nGnRnE memory)
        //Attr2=0x44 (Normal memory, Outer & Inner Write-Back Transient,
        //Outer & Inner No Read-Allocate No Write-Allocate)
        set_mair_el2(get_mair_el2() & 0xFFFFFFFFFF000000 | 0x4400FF);
        // Setting T0SZ=24 (TTBR0_EL2 region size is 2^40)
        //IRGN0=0b11 && ORGN0=0b11
        //(Normal memory, Outer & Inner Write-Back
        //Read-Allocate No Write-Allocate Cacheable)
        //SH0=0b11 (Inner Shareable)
        //PAS=0b010 (PA size is 40 bits, 1TB)
        set_tcr_el2(get_tcr_el2(); & 0xFFF8C0C0 | 0x23F18);
        flush_entire_cache();
        sctlr_el2 = get_sctlr_el2();
        // Setting C=1 (data is cacheable for EL2)
        //I=1 (instruction access is cacheable for EL2)
        //WXN=1 (writeable implies non-executable for EL2)
        set_sctlr_el2(sctlr_el2 & 0xFFF7EFFB | 0x81004);
        invalidate_entire_s1_el2_tlb();
        // Setting M=1 (EL2 stage 1 address translation enabled)
        set_sctlr_el2(sctlr_el2 & 0xFFF7EFFA | 0x81005);
    }
函数s1_enable的主要任务是设置MAIR_EL2、TCR_EL2和SCTLR_EL2等与缓存相关的字段；但它最重要的任务，却是启用EL2的MMU。然后，main函数将调用uh_init函数，并将uH的内存范围传给它。
我们可以看到，Gal Beniamini提出的第二项设计改进，也就是将WXN位设置为1，也已经被三星的KNOX团队实现了。
    int64_t uh_init(int64_t uh_base, int64_t uh_size) {
        // ...
        memset( & uh_state.base, 0, sizeof(uh_state));
        uh_state.base = uh_base;
        uh_state.size = uh_size;
        static_heap_initialize(uh_base, uh_size);
        if (!static_heap_remove_range(0x87100000, 0x40000) || !static_heap_remove_range( & hyp_base, 0x87046000 - &hyp_base) ||
        !static_heap_remove_range(0x870FF000, 0x1000)) {
            uh_panic();
        }
        memory_init();
        uh_log('L', "main.c", 131, "================================= LOG FORMAT =================================");
        uh_log('L', "main.c", 132, "[LOG:L, WARN: W, ERR: E, DIE:D][Core Num: Log Line Num][File Name:Code Line]");
        uh_log('L', "main.c", 133, "==============================================================================");
        uh_log('L', "main.c", 134, "[+] uH base: 0x%p, size: 0x%lx", uh_state.base, uh_state.size);
        uh_log('L', "main.c", 135, "[+] log base: 0x%p, size: 0x%x", 0x87100000, 0x40000);
        uh_log('L', "main.c", 137, "[+] code base: 0x%p, size: 0x%p", &hyp_base, 0x46000);
        uh_log('L', "main.c", 139, "[+] stack base: 0x%p, size: 0x%p", stacks, 0x10000);
        uh_log('L', "main.c", 143, "[+] bigdata base: 0x%p, size: 0x%p", 0x870FFC40, 0x3C0);
        uh_log('L', "main.c", 152, "[+] date: %s, time: %s", "Feb 27 2020", "17:28:58");
        uh_log('L', "main.c", 153, "[+] version: %s", "UH64_3b7c7d4f exynos9610");
        uh_register_commands(0, init_cmds, 0, 5, 1);
        j_rkp_register_commands();
        uh_log('L', "main.c", 370, "%d app started", 1);
        system_init();
        apps_init();
        uh_init_bigdata();
        uh_init_context();
        memlist_init( & uh_state.dynamic_regions);
        pa_restrict_init();
        uh_state.inited = 1;
        uh_log('L', "main.c", 427, "[+] uH initialized");
        return 0;
在将参数保存到一个我们命名为uh_state的全局控制结构体中后，uh_init函数将调用static_heap_initialize函数。这个函数首先将其参数保存到全局变量中，然后，将双向堆块链表初始化为一个横跨整个uH静态内存范围的空闲块。
接下来，uh_init函数将调用heap_remove_range函数，从内存中删除静态堆分配器可以返回的3个重要地址范围（从而有效地将原来的内存块分割成多个块）：
  1. 日志区域。
  2. uH（代码/数据/bss/栈）区域。
  3. “bigdata”（分析）区域。
之后，uh_init将调用memory_init函数。
    int64_t memory_init() {
        memory_buffer = 0x87100000;
        memset(0x87100000, 0, 0x40000);
        cs_init( & memory_cs);
        clean_invalidate_data_cache_region(0x87100000, 0x40000);
        memory_buffer_index = 0;
        memory_active = 1;
        return s1_map(0x87100000, 0x40000, UNKN3 | WRITE | READ);
    }
这个函数将日志区域清零，并将其映射到EL2页表中。这个区域将会用于*printf字符串打印函数，后者会在uh_log函数内部调用。
之后，uh_init函数将使用uh_log来记录各种信息
(这些信息可以从设备上的/proc/uh_log中获取)。然后，uh_init函数会调用uh_register_commands和
rkp_register_commands函数（它也调用uh_register_commands，但参数不同）。
    int64_t uh_register_commands(uint32_t app_id,
    int64_t cmd_array,
    int64_t cmd_checker,
    uint32_t cmd_count,
    uint32_t flag) {
        // ...