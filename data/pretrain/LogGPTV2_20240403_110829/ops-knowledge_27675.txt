User: I'm using Tornado options to define command-line arguments. However, I would like to be able to throw arbitrary configuration options, not defined in code, to my program. These will differ, depending on what the program is supposed to do. For instance, connect to a bluetooth device using a MAC address or connect to a serial device using a TTY.
If I define a set of "mandatory" options in code and then add an additional when calling the program, I get an exception thrown by parse_command_line().
It would be very handy to get e.g. a dictionary with the remaining (undefined) options. That is, much in the same way as **kwargs works in functions.
Can this be done?
(A work-around is to define a string option named e.g. configuration and throw everything in there, possibly encoded in some clever way. As the program is being called by another program I can e.g. base64-encode a serialized dict.)

Update: I've noticed that if you add command-line args without leading dashes, Tornado will ignore them and return a list with remaining (undefined) options.
Assistant: The tornado.options philosophy is that any module may define options, not just the main entry point.  So if you might need a bluetooth mac address, you'd define that option in the module that interacts with bluetooth.  (and if you might need more than one you can set multiple=True).  The only tricky part is that you must import all modules that define options before calling parse_command_line.  Truly arbitrary options are not supported by tornado.options.
It's also possible to use argparse or another command-line library instead of tornado.options.parse_command_line - the rest of tornado doesn't care whether you're using tornado.options or not.