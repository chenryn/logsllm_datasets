UEFI 
Bootkit 
Modified FW Doesn’t Enforce Secure Boot 
Hardware 
I/O 
Memory 
Network 
Graphics 
UEFI DXE Core / Dispatcher 
UEFI OS Loaders 
System Firmware (SEC/PEI) 
DXE 
Driver 
UEFI 
Bootkit 
Signed 
BIOS 
Update 
DXE 
Driver 
OS Kernel 
OS Driver 
OS Exploit 
Demo 
(Bypassing Secure Boot by Corrupting Platform Key in SPI) 
Turn On/Off Secure Boot in BIOS Setup 
How to Disable Secure Boot? 
SecureBootEnable UEFI Variable 
 When turning ON/OFF Secure Boot, it should change 
Hmm.. but there is no SecureBootEnable variable 
 Where does the BIOS store Secure Boot Enable flag? 
Should be NV  somewhere in SPI Flash.. 
 Just dump SPI flash with Secure Boot ON and OFF 
 Then compare two SPI flash images 
Yeah.. Good Luck With That ;( 
There’s A Better Way.. 
Secure Boot On  
Secure Boot Off 
Secure Boot On  
Secure Boot Off 
Secure Boot Disable is Really in Setup! 
chipsec_util.py spi dump spi.bin 
chipsec_util.py uefi nvram spi.bin 
chipsec_util.py decode spi.bin 
Demo 
(Attack Disabling Secure Boot) 
Secure Boot: Image Verification Policies 
DxeImageVerificationLib defines policies applied to different types of 
images and on security violation 
IMAGE_FROM_FV (ALWAYS_EXECUTE), IMAGE_FROM_FIXED_MEDIA, 
IMAGE_FROM_REMOVABLE_MEDIA, IMAGE_FROM_OPTION_ROM 
ALWAYS_EXECUTE, NEVER_EXECUTE, 
ALLOW_EXECUTE_ON_SECURITY_VIOLATION 
DEFER_EXECUTE_ON_SECURITY_VIOLATION 
DENY_EXECUTE_ON_SECURITY_VIOLATION 
QUERY_USER_ON_SECURITY_VIOLATION 
SecurityPkg\Library\DxeImageVerificationLib 
http://sourceforge.net/apps/mediawiki/tianocore/index.php?title=SecurityPkg 
Secure Boot: Image Verification Policies 
Image Verification Policy? 
(IMAGE_FROM_FV) 
ALWAYS_EXECUTE? 
EFI_SUCCESS 
NEVER_EXECUTE? 
EFI_ACCESS_DENIED 
Storing Image Verification Policies in Setup 
•
Read „Setup‟ UEFI variable and look for sequences 
•
04 04 04, 00 04 04, 05 05 05, 00 05 05 
•
We looked near Secure Boot On/Off Byte! 
•
Modify bytes corresponding to policies to 00 (ALWAYS_EXECUTE) 
then write modified „Setup‟ variable 
Modifying Image Verification Policies 
[CHIPSEC] Reading EFI variable Name='Setup' GUID={EC87D643-EBA4-4BB5-A1E5-
3F3E36B20DA9} from 'Setup_orig.bin' via Variable API.. 
EFI variable: 
Name      : Setup 
GUID      : EC87D643-EBA4-4BB5-A1E5-3F3E36B20DA9 
Data      : 
.. 
01 01 01 00 00 00 00 01 01 01 00 00 00 00 00 00 |                  
00 00 00 00 00 00 01 01 00 00 00 04 04          |               
[CHIPSEC] (uefi) time elapsed 0.000 
[CHIPSEC] Writing EFI variable Name='Setup' GUID={EC87D643-EBA4-4BB5-A1E5-
3F3E36B20DA9} from 'Setup_policy_exploit.bin' via Variable API.. 
Writing EFI variable: 
Name      : Setup 
GUID      : EC87D643-EBA4-4BB5-A1E5-3F3E36B20DA9 
Data      : 
.. 
01 01 01 00 00 00 00 01 01 01 00 00 00 00 00 00 |                  
00 00 00 00 00 00 01 01 00 00 04 00 00          |               
[CHIPSEC] (uefi) time elapsed 0.203 
OptionRomPolicy 
FixedMediaPolicy 
RemovableMediaPolicy 
Allows Bypassing Secure Boot 
Issue was co-discovered with Corey Kallenberg, Xeno Kovah, John Butterworth and Sam Cornwell from MITRE 
All Your Boot Are Belong To Us, Setup for Failure: Defeating SecureBoot 
Demo 
(Bypassing Secure Boot via Image Verification Policies) 
How To Avoid These? 
1.
Do not store critical Secure Boot configuration in UEFI variables 
accessible to potentially compromised OS kernel or boot loader 
Remove RUNTIME_ACCESS attribute (reduce access permissions) 
Use authenticated variable where required by UEFI Spec 
Disabling Secure Boot requires physically present user 
2.
Set Image Verification Policies to secure values 
Use Platform Configuration Database (PCD) for the policies 
Using ALWAYS_EXECUTE,ALLOW_EXECUTE_* is a bad idea 
Especially check PcdOptionRomImageVerificationPolicy 
Default should be NEVER_EXECUTE or DENY_EXECUTE 
Recap on Image Verification Handler 
SecureBoot EFI variable doesn‟t exist or equals to 
SECURE_BOOT_MODE_DISABLE? EFI_SUCCESS 
File is not valid PE/COFF image? EFI_ACCESS_DENIED 
SecureBootEnable NV EFI variable doesn‟t exist or equals to 
SECURE_BOOT_DISABLE? EFI_SUCCESS 
SetupMode NV EFI variable doesn‟t exist or equals to SETUP_MODE? 
EFI_SUCCESS 
EFI Executables 
 Any EFI executables other then PE/COFF? 
 YES! – EFI Byte Code (EBC), Terse Executable (TE) 
 But EBC image is a 32 bits PE/COFF image wrapping byte 
code. No luck  
 Terse Executable format: 
   In an effort to reduce image size, a new executable image header (TE) 
was created that includes only those fields from the PE/COFF headers 
required for execution under the PI Architecture. Since this header 
contains the information required for execution of the image, it can 
replace the PE/COFF headers from the original image.  
 http://wiki.phoenix.com/wiki/index.php/Terse_Executable_Format  
TE is not PE/COFF 
 TE differs from PE/COFF only with header: 
PE/TE Header Handling by the BIOS 
 Decoded UEFI BIOS image from SPI Flash 
PE/TE Header Handling by the BIOS 
CORE_DXE.efi: 
PE/TE Header Confusion 
 ExecuteSecurityHandler calls GetFileBuffer to 
read an executable file.  
 GetFileBuffer reads the file and checks it to have a valid 
PE header. It returns EFI_LOAD_ERROR if executable is not 
PE/COFF. 
 ExecuteSecurityHandler returns EFI_SUCCESS (0) 
in case GetFileBuffer returns an error 
 Signature Checks are Skipped! 
PE/TE Header Confusion 
BIOS allows running TE images w/o signature check 
 Malicious PE/COFF EFI executable (bootkit.efi) 
 Convert executable to TE format by replacing PE/COFF 
header with TE header 
 Replace OS boot loaders with resulting TE EFI executable 
 Signature check is skipped for TE EFI executable 
 Executable will load and patch original OS boot loader 
Demo 
(Secure Boot Bypass via PE/TE Header Confusion) 
Other Secure Boot Problems 
• CSM Module Allows Legacy On UEFI Based Firmware 
• Allows Legacy OS Boot Through [Unsigned] MBR 
• Allows Loading Legacy [Unsigned] Option ROMs 
• Once CSM is ON, UEFI BIOS dispatches legacy OROMs then boots MBR 
• CSM Cannot Be Turned On When Secure Boot is Enabled 
• CSM can be turned On/Off in BIOS Setup Options 
• But cannot select “CSM Enabled” when Secure Boot is On 
CSM Enabled with Secure Boot 
• Force CSM to Disabled if Secure Boot is Enabled 
• But don‟t do that only in Setup HII 
• Implement isCSMEnabled() function always returning FALSE in Secure Boot 
• Never fall back to legacy boot through MBR if Secure Boot verification of UEFI 
executable fails 
Mitigations 
Clearing Platform Key… from Software 
“Clear Secure Boot keys” takes effect after reboot 
 The switch that triggers clearing of Secure Boot keys is in UEFI 
Variable (happens to be in „Setup‟ variable) 
But recall that Secure Boot is OFF without Platform Key 
PK is cleared  Secure Boot is Disabled 
Install Default Keys… From Where? 
Default Secure Boot keys can be restored [When there‟s no PK] 
Switch that triggers restore of Secure Boot keys to their default 
values is in UEFI Variable (happens to be in „Setup‟) 
Nah.. Default keys are protected. They are in FV 
But we just added 9 hashes to the DBX blacklist  
Did You Notice Secure Boot Was Disabled? 
The system protects Secure Boot configuration from modification but has 
an implementation bug 
Firmware stores integrity of Secure Boot settings & checks on reboot 
Upon integrity mismatch, beeps 3 times, waits timeout then… 
Keeps booting with modified Secure Boot settings 
BIOS Attack Surface: BIOS Settings 
System 
FW/BIOS 
SPI Flash 
Protection 
BIOS 
Update 
SMRAM 
Protection 
Hardware 
Config. 
SMI 
Handlers 
Secure 
Boot 
BIOS 
Settings 
(NVRAM, 
Variables) 
… 
Handling Sensitive Data 
• BIOS and Pre-OS applications store keystrokes in legacy 
BIOS keyboard buffer in BIOS data area (at PA = 0x41E) 
• BIOS, HDD passwords, Full-Disk Encryption PINs etc. 
• Some BIOS‟es didn‟t clear keyboard buffer 
• Bypassing Pre-Boot Authentication Passwords 
• chipsec_main -m common.bios_kbrd_buffer 
Pre-Boot Passwords Exposure 
Secrets in the Keyboard Buffer? 
[*] running module: chipsec.modules.common.bios_kbrd_buffer 
[x][ ======================================================================= 
[x][ Module: Pre-boot Passwords in the BIOS Keyboard Buffer 
[x][ ======================================================================= 
[*] Keyboard buffer head pointer = 0x3A (at 0x41A), tail pointer = 0x3A (at 0x41C) 
[*] Keyboard buffer contents (at 0x41E): 
20 00 20 00 20 00 20 00 20 00 20 00 20 00 20 00 | 
20 00 20 00 20 00 20 00 20 00 20 00 20 00 20 00 | 
[-] Keyboard buffer tail points inside the buffer (= 0x3A) 
    It may potentially expose lengths of pre-boot passwords. Was your password 15 
characters long? 
[*] Checking contents of the keyboard buffer.. 
[+] PASSED: Keyboard buffer looks empty. Pre-boot passwords don't seem to be 
exposed 
* Better check from EFI shell as OS/pre-boot app might have cleared the keyboard buffer 
BIOS Attack Surface: SMI Handlers 
System 
FW/BIOS 
SPI Flash 
Protection 
BIOS 
Update 
SMRAM 
Protection 
Hardware 
Config. 
SMI 
Handlers 
Secure 
Boot 
BIOS 
Settings 
(NVRAM, 
Variables) 
… 
What? More Issues With SMI Handlers ? 
• Coordination is ongoing with independent BIOS vendors 
and platform manufacturers 
Multiple UEFI BIOS SMI Handler Vulnerabilities 
Do BIOS Attacks Require Kernel Privileges? 
Hardware 
I/O 
Memory 
Network 
Graphics 
UEFI DXE Core / Dispatcher 
UEFI OS Loaders 
System Firmware (SEC/PEI) 
OS Kernel 
OS Exploit 
To attack BIOS, exploit 
needs access to HW: 
•PCIe config, 
•I/O ports, 
•physical memory, 
•etc. 
So, generally, yes. 
Kernel privileges are 
required.. 
Signed OS Driver 
Unless Suitable Kernel Driver Already Signed 
Hardware 
I/O 
Memory 
Network 
Graphics 
UEFI DXE Core / Dispatcher 
UEFI OS Loaders 
System Firmware (SEC/PEI) 
OS Kernel 
Legitimate signed OS 
kernel driver which can 
do all this on behalf of a 
user mode app (as a 
confused deputy). 
We found suitable driver 
signed for Windows 
64bit versions (co-
discovered with 
researchers from MITRE) 
User-mode Exploit 
Ref: BIOS Security Guidelines / Best Practices 
•
CHIPSEC framework: https://github.com/chipsec/chipsec 
•
MITRE Copernicus tool 
•
NIST BIOS Protection Guidelines (SP 800-147 and SP 800-147B) 
•
IAD BIOS Update Protection Profile 
•
Windows Hardware Certification Requirements 
•
UEFI Forum sub-teams: USST (UEFI Security) and PSST (PI Security) 
•
UEFI Firmware Security Best Practices 
•
BIOS Flash Regions 
•
UEFI Variables in Flash (UEFI Variable Usage Technical Advisory) 
•
Capsule Updates 
•
SMRAM 
•
Secure Boot 
Ref: BIOS Security Research 
•
Security Issues Related to Pentium System Management Mode (CSW 2006) 
•
Implementing and Detecting an ACPI BIOS Rootkit (BlackHat EU 2006) 
•
Implementing and Detecting a PCI Rootkit (BlackHat DC 2007) 
•
Programmed I/O accesses: a threat to Virtual Machine Monitors? (PacSec 2007) 
•
Hacking the Extensible Firmware Interface (BlackHat USA 2007) 
•
BIOS Boot Hijacking And VMWare Vulnerabilities Digging (PoC 2007) 
•
Bypassing pre-boot authentication passwords (DEF CON 16) 
•
Using SMM for "Other Purposes“ (Phrack65) 
•
Persistent BIOS Infection (Phrack66) 
•
A New Breed of Malware: The SMM Rootkit (BlackHat USA 2008) 
•
Preventing & Detecting Xen Hypervisor Subversions (BlackHat USA 2008) 
•
A Real SMM Rootkit: Reversing and Hooking BIOS SMI Handlers (Phrack66) 
•
Attacking Intel BIOS (BlackHat USA 2009) 
•
Getting Into the SMRAM: SMM Reloaded (CSW 2009, CSW 2009) 
•
Attacking SMM Memory via Intel Cache Poisoning (ITL 2009) 
•
BIOS SMM Privilege Escalation Vulnerabilities (bugtraq 2009) 
•
System Management Mode Design and Security Issues (IT Defense 2010) 
•
Analysis of building blocks and attack vectors associated with UEFI (SANS Institute) 
•
(U)EFI Bootkits (BlackHat USA 2012 @snare, SaferBytes 2012 Andrea Allievi, HITB 2013) 
•
Evil Maid Just Got Angrier (CSW 2013) 
•
A Tale of One Software Bypass of Windows 8 Secure Boot (BlackHat USA 2013) 
•
BIOS Chronomancy (NoSuchCon 2013, BlackHat USA 2013, Hack.lu 2013) 
•
Defeating Signed BIOS Enforcement (PacSec 2013, Ekoparty 2013) 
•
UEFI and PCI BootKit (PacSec 2013) 
•
Meet „badBIOS‟ the mysterious Mac and PC malware that jumps airgaps (#badBios) 
•
All Your Boot Are Belong To Us (CanSecWest 2014 Intel and MITRE) 
•
Setup for Failure: Defeating Secure Boot (Syscan 2014) 
•
Setup for Failure: More Ways to Defeat Secure Boot (HITB 2014 AMS) 
•
Analytics, and Scalability, and UEFI Exploitation (INFILTRATE 2014) 
•
PC Firmware Attacks, Copernicus and You (AusCERT 2014) 
•
Extreme Privilege Escalation (BlackHat USA 2014) 
THANK YOU!