[31] T. H. Dang, P. Maniatis, and D. Wagner, “The performance cost of shadow
stacks and stack canaries,” in Proceedings of the 10th ACM Symposium on
Information, Computer and Communications Security, pp. 555–566, 2015.
[32] “Add Test to Verify NX is Enabled.” https://android-review.googlesource.co
m/c/platform/cts/+/21776. Accessed December 22, 2020.
[33] “Tcpdump Public CVE List.” https://www.tcpdump.org/public-cve-list.txt.
Accessed December 22, 2020.
[34] “Tcpdump Common Vulnerabilities.” https://cve.mitre.org/cgi-bin/cvekey.c
gi?keyword=tcpdump. Accessed December 22, 2020.
[35] H. Meng, V. Thing, Y. Cheng, Z. Dai, and L. Zhang, “A survey of Android
exploits in the wild,” Computers & Security, vol. 76, pp. 71–91, 07 2018.
[36] “Android Vulnerabilities: vold asec.” https://androidvulnerabilities.org/vulne
rabilities/vold asec. Accessed December 22, 2020.
[37] “Root 4.4.X - Pie for Motorola devices.” https://forum.xda-developers.c
om/moto-x/orig-development/root-4-4-x-pie-motorola-devices-t2771623.
Accessed December 22, 2020.
[38] “OATmeal on the Universal Cereal Bus: Exploiting Android phones over
USB.” https://googleprojectzero.blogspot.com/2018/09/oatmeal-on-universa
l-cereal-bus.html. Accessed December 22, 2020.
[39] “Android
6.0 Changes
- Access
to Hardware
Identifier.”
https://developer.android.com/about/versions/marshmallow/android-6.0
-changes.html#behavior-hardware-id. Accessed December 22, 2020.
[40] “BScout: Direct Whole Patch Presence Test for Java Executables,” in 29th
USENIX Security Symposium (USENIX Security 20), (Boston, MA), USENIX
Association, Aug. 2020.
[41] D. Thomas, A. Beresford, and A. Rice, “Security metrics for the android
ecosystem,” pp. 87–98, 10 2015.
[42] D. Tian, G. Hernandez, J. Choi, V. Frost, C. Ruales, K. Butler, P. Traynor,
H. Vijayakumar, L. Harrison, A. Rahmati, and M. Grace, “ATtention Spanned:
Comprehensive Vulnerability Analysis of AT Commands Within the Android
Ecosystem,” in 27th USENIX Security Symposium (USENIX Security 18),
(Baltimore, MD), pp. 351–366, USENIX Association, 2018.
[43] L. Wu, M. Grace, Y. Zhou, C. Wu, and X. Jiang, “The impact of vendor
customizations on android security,” pp. 623–634, 11 2013.
[44] J. Gamba, M. Rashed, A. Razaghpanah, J. Tapiador, and N. Vallina-Rodriguez,
“An analysis of pre-installed android software,” in 2020 IEEE Symposium on
Security and Privacy (SP), pp. 1039–1055, 2020.
[45] E. Reshetova, F. Bonazzi, and N. Asokan, “Selint: An seandroid policy analysis
tool,” pp. 47–58, 01 2017.
[46] E. Reshetova, F. Bonazzi, T. Nyman, R. Borgaonkar, and N. Asokan,
“Characterizing seandroid policies in the wild,” pp. 482–489, 01 2016.
[47] R. Wang, W. Enck, D. Reeves, X. Zhang, P. Ning, D. Xu, W. Zhou, and A. M.
Azab, “Easeandroid: Automatic policy analysis and refinement for security
enhanced android via large-scale semi-supervised learning,” in 24th USENIX
Security Symposium (USENIX Security 15), (Washington, D.C.), pp. 351–366,
USENIX Association, Aug. 2015.
[48] B. Im, A. Chen, and D. S. Wallach, “An historical analysis of the seandroid
policy evolution,” Proceedings of the 34th Annual Computer Security
Applications Conference, 2018.
[49] D. J. T. Grant Hernandez, A. S. Yadav, B. J. Williams, and K. R. Butler,
“Bigmac: Fine-grained policy analysis of android firmware,” in 29th USENIX
Security Symposium (USENIX Security 20), 2020.
ACKNOWLEDGEMENTS
We would like to thank the anonymous reviewers for their
constructive feedback. We would also like to thank Slasti Mormanti
and Betty Sebright for their support and insights.
This work was partially supported by the European Research
Council (ERC) under the European Unions Horizon 2020
research and innovation programme (grant agreement No 771844
BitCrumbs).
REFERENCES
[1] S. Cuthbertson,
“Sharing what’s
new in Android Q.”
https:
//www.blog.google/products/android/android-q-io/, 2019.
[2] “Issue 2002: Samsung Android multiple interactionless RCEs and other remote
access issues in Qmage image codec built into Skia.” https://bugs.chromium.
org/p/project-zero/issues/detail?id=2002. Accessed December 22, 2020.
[3] “Android compatibility definition document.” https://source.android.com/com
patibility/cdd. Accessed December 22, 2020.
[4] “Vendor Test Suite (VTS) & Infrastructure.” https://source.android.com/com
patibility/vts. Accessed December 22, 2020.
[5] “Android ONE.” https://www.android.com/one/. Accessed December 22, 2020.
[6] X. Zhou, Y. Lee, N. Zhang, M. Naveed, and X. Wang, “The peril of
fragmentation: Security hazards in android device driver customizations,” in
2014 IEEE Symposium on Security and Privacy, pp. 409–423, 2014.
[7] Y. Aafer, X. Zhang, and W. Du, “Harvesting inconsistent security configurations
in custom android roms via differential analysis,” in 25th USENIX Security
Symposium (USENIX Security 16), pp. 1153–1168, 2016.
[8] N. Kralevich, “Honey, i shrunk the attack surface,” Black Hat, 2017.
[9] “Android Codenames, Tags, and Build Numbers.” https://source.android.com
/setup/start/build-numbers#source-code-tags-and-builds. Accessed December
22, 2020.
[10] “Android Security: Taming the Complex Ecosystem.” https://wisec19.fiu.ed
u/wp-content/uploads/wisec2019-keynote.pdf. Accessed December 22, 2020.
[11] “Trade Federation Overview.” https://source.android.com/devices/tech/test
infra/tradefed. Accessed December 22, 2020.
[12] “Verifying Boot - Rollback protection.” https://source.android.com/security/
verifiedboot/verified-boot. Accessed December 22, 2020.
[13] “Android 4.4.3 Patch Finally Closes Up An Ancient Vulnerability, Shuts Down
Several Serious Security Exploits.” https://www.androidpolice.com/2014/0
6/04/android-4-4-3-patch-finally-closes-ancient-vulnerability-shuts-severa
l-serious-security-exploits/. Accessed December 22, 2020.
[14] “CVE-2018-9488.” https://nvd.nist.gov/vuln/detail/CVE-2018-9488. Accessed
[17] “Linux Kernel Banner.” https://git.kernel.org/pub/scm/linux/kernel/git/torval
ds/linux.git/tree/init/version.c. Accessed December 22, 2020.
[18] “vmlinux-to-elf.” https://github.com/marin-m/vmlinux-to-elf.
Accessed
December 22, 2020.
[19] “Factory images for nexus and pixel devices.” https://developers.google.co
m/android/images. Accessed December 22, 2020.
[20] “Firmware file.” https://firmwarefile.com/. Accessed December 22, 2020.
[21] “Stock rom.” https://www.stockrom.net/. Accessed December 22, 2020.
[22] “Mobile vendor market share worldwide.” https://gs.statcounter.com/ven
dor-market-share/mobile/worldwide/#monthly-201003-202007. Accessed
December 22, 2020.
[23] “Loadable Kernel Modules.” https://source.android.com/devices/architectur
e/kernel/loadable-kernel-modules. Accessed December 22, 2020.
[24] “Core Kernel Requirements.” https://source.android.com/devices/architectur
e/kernel/core-kernel-reqs. Accessed December 22, 2020.
[25] “SELinux for Android 8.0.” https://source.android.com/security/selinux/im
ages/SELinux Treble.pdf. Accessed December 22, 2020.
[26] “SELinuxNeverallowTestFrame.py.” https://android.googlesource.com/platf
orm/cts/+/refs/heads/master/tools/selinux/SELinuxNeverallowTestFrame.py.
Accessed December 22, 2020.
[27] “Hardening the media stack.” https://android-developers.googleblog.com/20
16/05/hardening-media-stack.html. Accessed December 22, 2020.
[28] “Control Flow Integrity.” https://source.android.com/devices/tech/debug/cfi.
Accessed December 22, 2020.
[15] “Android Init Language.” https://android.googlesource.com/platform/system
/core/+/master/init/README.md. Accessed December 22, 2020.
[16] “Practical Android Exploitation.” http://theroot.ninja/PAE.pdf. Accessed
December 22, 2020.
December 22, 2020.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:28:06 UTC from IEEE Xplore.  Restrictions apply. 
100
A. Compile-time Hardening
APPENDIX
This section of the appendix is dedicated to a more detailed
description of mitigation techniques considered in Section VI-B.
For each technique we provide a short description and we explain
which artifacts we considered to detect if and ELF file implements
it or not. We report a final summary in Table V.
I) Stack Canaries. Stack canaries, introduced in Android 1.5, work
by placing a random integer (canary) in memory just before the
stack return pointer. In order to overwrite the return pointer (and thus
take control of the execution flow), stack-based buffer overflows
attacks must also overwrite the canary value. Before a function
returns, the stack canary integrity is checked using the function
__stack_chk_fail (or __intel_security_cookie
in an alternative implementation), and if it appears to be modified
due to an overwrite, the program exits immediately. Thus, we
checked for the presence of the aforementioned function among the
binary’s symbols. We highlight how the stack protector works in two
configurations. The first one protects the buffer only if it is greater
than a certain size (depending on the architecture), while the second
one (named “strong”) protects buffers even if they are one byte size.
We assumed, as safe assumption, that real world binaries have at least
one buffer that can be protected by this compiler defense mechanism.
Even though this assumption might sometimes fail, we believe that
the numbers of binaries without a buffer to protect is negligible and
it is not going to affect the overall results of our measurement.
II) No eXecute (NX). NX marks certain areas of the program
as not executable. NX can be implemented both via software or
hardware (almost all modern processors uses it). In our analysis,
we checked if the GNU_STACK segment of the binaries, which
tells the system whether the stack should be executable or not.
III) Position Independent Executables (PIE). The code of a PIE
binary can be placed into random locations in memory, and it
executes properly regardless of its absolute address. PIE works in
tandem with Address Space Layout Randomization (ASLR). ASLR
randomly arranges the address space positions of key data areas of a
process (e.g., the base of the executable, stack, heap, and libraries). If
the executable is position independent, the location of the executable
code within the process is also randomized, making it more difficult
for an attacker to predict target addresses. As of Android 4.0 (SDK
15), the kernel gained support for ASLR, but Android still lacked
userspace support. The Android 4.1 (SDK 16) release introduced
support for full ASLR by enabling heap randomization and adding
linker support for PIE. Android 5 (SDK 21) is the latest step
forwards, as non-PIE executable support was dropped, and all
processes now have full ASLR. The third graph of Figure 3 reflects
the history flow: the growth since its introduction (SDK 16), and a
second increase when the non-PIE executable support was dropped
in (SDK 21). PIE is the security enhancement with the greater
adoption because, after Android 5, the linker does not load non-
PIE executables. A PIE ELF file is of the type ET_DYN, and its
.dynamic section contains the DT_DEBUG tag.
IV) Full Relocation Read-Only (RELRO). A dynamically linked
ELF binary uses a look-up table called Global Offset Table (GOT)
to dynamically resolve functions located in shared libraries. The
dynamic linker defers function-call resolution to the point when the
function is called rather than at load time. This technique is known
as lazy binding, and it needs that the GOT lives in a predefined place
and is writable. Hence, if an attacker finds a bug allowing them to
write a few bytes (as many as the length of a valid address), they can
overwrite a GOT entry. If a GOT entry is properly overwritten, the
attacker can hijack a library call to their malicious code. However,
the immediate binding is a valid countermeasure: the linker can
resolve all the dynamically linked functions at the beginning of
execution and make the GOT read-only. This mitigation is known
as Full RELRO, and it appears in the SE of Android 4.1. If an ELF
implements the Full RELRO, it has the GNU_RELRO segment and
its .dynamic section contains the DT_BIND_NOW tag. The
GNU_RELRO segment indicates the memory region which should
be made read-only after relocation is done, while the .dynamic
section contains an array of tags. The DT_BIND_NOW tag in-
dicates the linker that all relocations must be processed before
returning control to the program, i.e., using immediate binding.
V) FORTIFY_SOURCE. This is a macro (available in both GCC
and Clang) that provides lightweight checks for detecting buffer
overflows in various dangerous functions, like memcpy. Some of
the checks can be performed at compile time while other checks
take place at run-time and result in a run-time error if the check
fails. FORTIFY_SOURCE works in two phases: first, it tries
to computes the number of bytes of the destination buffer used
in a dangerous function. If it succeed, it replaces the dangerous
functions with their secure _chk counterpart (e.g., memcpy →
__memcpy_chk) adding as new argument the size of the buffer.
If an attacker tries to copy more bytes, the _chk function detects
the overflow and the program’s execution is stopped. If the first
step fails, the compiler cannot harden a function (e.g., it might
fail with dynamic memory allocated buffers). For dynamically
linked executables, the libc contains the implementation of the
_chk functions. Therefore, we first checked whether the libc
supports FORTIFY_SOURCE, that is, the libc contains at
least one _chk function among its exported symbols. If yes, for
each binary, we check if it contains at least one _chk function
among its imported symbols.
VI) setuid/setgid. These are a special type of file permissions
that permit users to run specific executables with temporarily
elevated privileges, to perform a specific task.
B. Kernel Configuration Mappings
Table VI contains, for each of the configurations defined in
the CDD, the correspondent Kernel Symbol introduced while
enabling the specific configuration. We noticed how, some kernel
configurations might map to the same symbol, while other kernel
configurations, depending on the version of the kernel, might
change the symbol used. For these configurations, we rely on
regular expressions to identify valid symbols. For 3 configurations,
we were not able to identify any symbol for the mapping.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:28:06 UTC from IEEE Xplore.  Restrictions apply. 
101
TABLE V
MITIGATION TECHNIQUES
SDK Version
3
9
16
17
18
1.5
2.3
4.1
4.2
4.3
Enhancement
Stack Canaries
No eXecute (NX)
Position Independent Executables (PIE)
Full Read-only Relocations (RELRO)
FORTIFY SOURCE
No setuid/setgid programs
Artifact
__stack_chk_fail function symbol, or
__intel_security_cookie function symbol
GNU_STACK segment RW-
ELF type ET_DYN, and
.dynamic section with DT_DEBUG tag
GNU_RELRO segment, and
.dynamic section with DT_BIND_NOW tag
*_chk function symbols, and
*_chk exported function in libc
setuid/setguid bit in file’s permission
MAPPINGS KERNEL CONFIGURATION TO ELF SYMBOLS
TABLE VI
Kernel Configuration
CONFIG SECURITY SELINUX
CONFIG SECCOMP
CONFIG CC STACKPROTECTOR REGULAR
CONFIG CC STACKPROTECTOR STRONG
CONFIG DEBUG RODATA
CONFIG STRICT KERNEL RWX
CONFIG HARDENED USERCOPY
CONFIG ARM64 SW TTBR0 PAN
CONFIG RANDOMIZE BASE
CONFIG PAGE TABLE ISOLATION
CONFIG UNMAP KERNEL AT EL0
CONFIG HARDEN BRANCH PREDICTOR
CONFIG SHADOW CALL STACK
CONFIG SECURITY DMESG RESTRICT
CONFIG SECURITY KPTR RESTRICT
CONFIG ARM64 PAN
CONFIG CFI CLANG
CONFIG DEFAULT MMAP MIN ADDR
CONFIG CPU SW DOMAIN PAN
CONFIG LTO CLANG
Kernel Symbol
Symbol contains selinux
Symbol contains seccomp
__stack_chk_fail
__stack_chk_guard
rodata_enabled, set_debug_rodata, __setup_set_debug_rodata
mark_readonly
__check_heap_object, __check_object_size
reserved_ttbr0
Symbol contains kaslr
tlb_flush_mmu_tlbonly
__initcall_map_entry_trampoline1
__nospectre_v2
init_shadow_call_stack
dmesg_restrict
kptr_restrict
cpu_enable_pan
Symbol contains __cfi_*
No symbol mapping found, variable
No symbol mapping, inline assembly
No symbol mapping found
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:28:06 UTC from IEEE Xplore.  Restrictions apply. 
102