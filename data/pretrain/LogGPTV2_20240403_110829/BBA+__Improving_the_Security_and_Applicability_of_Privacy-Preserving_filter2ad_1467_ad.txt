Advob-issue
is negligible in n.
Definition 3.5 demands that an adversary may not be able to
successfully call the accumulation or verification protocol for a
forged token, i. e. a token that has not been issued by a legitimate
issuer.
Definition 3.5. A trapdoor-linkable BBA+ scheme BBAP is called
owner-binding with respect to Accum and Vfy if for any PPT adver-
sary A in the experiment Expob-acc-ver
BBAP,A (n) from Fig. 2 the advantage
of A defined by
Advob-acc-ver
BBAP,A (n) := Pr[Expob-acc-ver
BBAP,A (n) = 1]
is negligible in n.
(2)
With Definition 3.6 we ensure that, unless some token is used
twice (which induces the usage of the same token serial number),
Experiment Expbb
BBAP,A (n)
(CRS, td) ← Setup(1n )
(pkI, skI ) ← IGen(CRS)
b ← AMalIssue,MalAcc,MalVer (pkI )
The experiment returns 1 iff A did a successful call to MalVer resulting in a view view =
(pkI, skI, w, v, msgs, dstag, hid, 1) ∈ VVfy
and extracted user public-key pkU ←
ExtractUID(td, hid) such that the following conditions are satisfied:
– all successful MalIssue/MalAcc calls produced unique token version numbers
– the claimed balance w ∈ Zp does not equal the sum of previously collected accumula-
n,CRS
tion values v for pkU , i. e.,
w (cid:44) (cid:88)
v∈VpkU
v,
where VpkU is the list of all accumulation values v ∈ Zp that appeared in previous suc-
cessfull calls to MalAcc or MalVer for which pkU could be extracted using ExtractUID.
Figure 3: Balance binding experiment.
Experiment Expdsd
BBAP,A (n)
(CRS, td) ← Setup(1n )
(pkI, skI ) ← IGen(CRS)
b ← AMalIssue,MalAcc,MalVer (pkI )
The experiment returns 1 iff A did two successful MalAcc/MalVer calls resulting in
two views view1 and view2 including two double-spending tags dstag1 = (s, z1 ) and
dstag2 = (s, z2 ) and extracted user public-keys pk(1)U and pk(2)U (using ExtractUID) such
that at least one of the following conditions is satisfied:
– pk(1)U (cid:44) pk(2)U or
– IdentDS(pkI, dstag1, dstag2 ) (cid:44) (pk(1)U , Π) or
– IdentDS(pkI, dstag1, dstag2 ) = (pk(1)U , Π) but VerifyGuilt(pkI, pk(1)U , Π) = 0
Figure 4: Double-spending detection experiment.
the claimed balance for a token in the scope of the verification
protocol always coincides with sum of points allegedly collected
with this token. Note that if this property is violated, then this
could mean that (1) the claimed balance is not equal to the “real”
balance of the presented token or that (2) the “real” balance does not
coincide with the sum of legitimately collected points associated
with this token in the records.
Definition 3.6. A trapdoor-linkable BBA+ scheme BBAP is called
balance-binding if for any PPT adversary A in the experiment
BBAP,A (n) from Fig. 3 the advantage of A defined by
Expbb
Advbb
is negligible in n.
BBAP,A (n) := Pr[Expbb
BBAP,A (n) = 1]
(3)
Definition 3.7 enforces that two transactions leading to the same
token version number have always been initiated by the same user
and this user can be identified.
Definition 3.7. A trapdoor-linkable BBA+ scheme BBAP ensures
double-spending detection if for any PPT adversary A in the ex-
BBAP,A (n) from Fig. 4 the advantage of A defined
periment Expdsd
by
(4)
Advdsd
BBAP,A (n) := Pr[Expdsd
BBAP,A (n) = 1]
is negligible in n.
3.4 Definition of User Security and Privacy
This section presents the key security properties for users, pro-
tecting them from dishonest operators: Firstly, a user should have
Session I3:  Personal PrivacyCCS’17, October 30-November 3, 2017, Dallas, TX, USA1932BBAP,A (1n )
Experiment Exppriv-real
(CRS, td) ← Setup(1n )
(pkI, state0 ) ← A0 (CRS)
b ← AHonUser,RealHonIssue,RealHonAcc,RealHonVer,RealCorrupt
1
return b
(pkI, state0 )
BBAP,A (1n )
Experiment Exppriv-ideal
(CRS, tdsim ) ← SimSetup(1n )
(pkI, state0 ) ← A0 (CRS)
b ← AHonUser,SimHonIssue,SimHonAcc,SimHonVer,SimCorrupt
1
return b
(pkI, state0 )
Figure 5: Real world privacy experiment.
Figure 6: Ideal world privacy experiment.
the privacy guarantee that its individual interactions cannot be
exploited for tracking and secondly no operator should be able to
forge a proof that a user has allegedly committed a double-spending.
Our privacy definition essentially demands that an adversary,
which could be a collusion of I, AC, and V, may not be able
to link the Accum and Vfy transactions of an honest user. More
precisely, the definition demands that Accum and Vfy do not reveal
any information (except for the balance in case of Vfy) that may help
in linking transactions. This even needs to hold for transactions
preceding and succeeding (except the very next) the corruption of
the user. Hence, we define a form of forward and backward privacy.
To this end, our definition follows the real/ideal world paradigm.
In the real world, depicted in Fig. 5, first the CRS is generated
honestly and the adversary chooses a public system key pkI of his
choice. Then the adversary is allowed to interact with a couple of
oracles, that allow the adversary to create a number of honest users
and instruct these users to interact with him in the scope of Issue,
Accum, or Vfy. Within these interactions, the oracles play the role
of the honest user, while the adversary plays the issuer, accumulator,
or verifier. Whenever an interaction does not successfully terminate
from the user’s perspective, then this particular user refuses to
participate in any future interaction, i. e. the oracles are blocked for
the respective pkU.8 If the adversary calls an oracle for a blocked
user, the oracle simply sends ⊥-messages. Moreover, for each user
no oracle can be called concurrently, i. e. for any arbitrary but fixed
pkU another oracle can only be invoked if no previous oracle call
for the same pkU is still pending. The oracles the adversary can
access are:
• HonUser() creates a new user entity by running (pkU , skU )
← UGen(CRS). The oracle returns pkU to the adversary.
• RealHonIssue(pkU ) lets the user with public key pkU run
the Issue protocol with the adversary impersonating the
issuer I, provided that pkU has not been used before in a
call to RealHonIssue which was successful from the user’s
perspective.
• RealHonAcc(pkU , v) lets the user with public key pkU run
the Accum protocol with the adversary impersonating the
accumulator AC on input v ∈ Zp, provided that the oracle
RealHonIssue(pkU ) has successfully been called at some
point before.
• RealHonVer(pkU , v) lets the user with public key pkU run
the Vfy protocol with the adversary impersonating the veri-
fier V on input v ∈ Zp provided that RealHonIssue(pkU )
has successfully been called at some point before.
8We need to demand that any previous call for pkU was successful as otherwise an
adversary may simply abort an Accum or Vfy transaction or start two such interactions
in parallel and then trigger the user to double-spend its token in a subsequent call
which would reveal the user’s identity. If the adversary has tried to cheat and has been
successfully detected by the user doing so, then this user “leaves” the system.
• RealCorrupt(pkU ) can be called by the adversary to cor-
rupt the user with public and secret key (pkU , skU ) ←
HonUser(). The oracle outputs the secret key skU of the
user as well as the user’s most recent token τ along with the
balance w.
In the ideal world, depicted in Fig. 6, first a CRS along with a
simulation trapdoor tdsim is generated honestly. The adversary only
receives the CRS as input like in the real game. Then, the adversary
may act exactly like in the real game, by accessing a number of
oracles. However, compared to the real world, some oracles are
implemented differently in order not to leak information that allows
to link transactions.
The basic idea is that all messages that are sent from a user to
the adversary in the scope of the protocols Vfy and AC are simu-
lated, i.e., are generated without any user-related data and thus are
information-theoretic independent. Nonetheless, if the adversary
corrupts a specific user by means of the SimCorrupt oracle, the
adversary expects to see a correct secret key skU, a plausible token
τ, and a correct balance w. As the adversary commands all users,
he can keep track of all balances and the simulation must do the
same. Hence, the oracles are implemented in a very specific way.
The adversary interacts with one global user simulator Usim
that keeps track of all interactions and the oracles are interfaces
of this simulator. Internally, the simulator stores and updates for
each pkU the corresponding skU, the current balance w and the
latest state object. This state object enables the simulator to come
up with a correct token upon corruption of a specific user. When
the adversary invokes an oracle (aka interface) the user simulator
Usim internally invokes a corresponding simulation algorithm that
does not receive any user-related input and returns an updated state
object to the simulator. Messages between the internal simulation
algorithm and the adversary are forwarded by the simulator.
If the adversary calls SimHonAcc or SimHonVer for a user with
ID pkU that has been successfully corrupted in the previous call
for this pkU, then the user simulator does not run the simulation
algorithm but executes the real protocol using the information that
has been returned by SimCorrupt.9
In the ideal game, the user simulator Usim behaves as follows
upon an adversarial invocation of the oracles (aka interfaces):
• HonUser() creates a new user entity by running (pkU , skU )
← UGen(CRS). The simulator returns pkU to the adversary
and stores skU in the internal database.
• SimHonIssue(pkU ) simulates a user with public key pkU
who runs the Issue protocol with the adversary imperson-
ating the issuer I, provided that pkU has not been used
9This is required as the adversary, given all user secrets, may now perform the next
interaction of this user on his own and learn a double-spending tag. Running the
simulator now needs to result in a second double-spending tag that can be used with
the first one to reveal pkU .
Session I3:  Personal PrivacyCCS’17, October 30-November 3, 2017, Dallas, TX, USA1933Experiment Expfacp
BBAP,A (n)
(CRS, td) ← Setup(1n )
(pkI, skI ) ← IGen(CRS)
(pkU , skU ) ← UGen(CRS)
Π ← ARealHonIssue,RealHonAcc,RealHonVer (pkI, pkU )
The experiment returns 1 iff VerifyGuilt(pkI, pkU , Π) = 1.
Figure 7: False accusation protection experiment.
before in a call to SimHonIssue which was successful from
the user’s perspective. The internal simulation algorithm
gets pkU but not skU.
• SimHonAcc(pkU , v) simulates a user with public key pkU
that runs the Accum protocol with the adversary imper-
sonating AC on common input v ∈ Zp, provided that
SimHonIssue(pkU ) has successfully been called at some
point before. The internal simulation algorithm only gets v
but not τ, w, pkU nor skU.
• SimHonVer(pkU , v) simulates a user with public key pkU
that runs the Vfy protocol with the adversary impersonat-
ing the verifier V on common input v ∈ Zp provided that
SimHonIssue(pkU ) has successfully been called at some
point before. The user simulator looks up the recent balance
w associated with pkU in the database and calls the simu-
lation algorithm. The internal simulation algorithm gets v
and w but not τ, pkU nor skU.
• SimCorrupt(pkU ) can be called by the adversary to corrupt
the user with public key pkU. The simulator looks up skU
associated with pkU, the current balance w, and the state
object from the database. It then calls the internal simulation
algorithm on this input. The output of the algorithm is a
tuple (skU , w, τ ) and is returned to the adversary.
Please note that
the internal simulation algorithms of
SimHonIssue, SimHonAcc, SimHonVer don’t get a token, skU nor
the state object as input. However, upon corruption the internal
algorithm of SimCorrupt(pkU ) must come up with a valid token
as part of its output (skU , w, τ ). Essentially, this means that this
algorithm must create a plausible token out of the latest state ob-
ject. But this object has been created by algorithms that have never
received any user-specific input.
As already mentioned, for privacy we demand that the real and
the ideal world are computationally indistinguishable.
Definition 3.8. We say that a BBA+ scheme BBAP is privacy-
preserving, if there exist PPT algorithms SimSetup and SimCorrupt
as well as interactive PPT algorithms as described in SimHonIssue,
SimHonAcc and SimHonVer, respectively, such that for all PPT
adversaries A = (A0, A1) in the experiments from Figs. 5 and 6,
the advantage Advpriv
(cid:12)(cid:12)(cid:12)(cid:12)Pr[Exppriv-real
BBAP,A (n) of A defined by
BBAP,A (n) = 1] − Pr[Exppriv-ideal
BBAP,A (n) = 1]
(5)
(cid:12)(cid:12)(cid:12)(cid:12)
is negligible in n.
Finally, Definition 3.9 demands that honest users cannot be
falsely accused of having committed a double-spending by an ad-
versary who generates pkI and may coincide with I, AC, and V.
Definition 3.9. A trapdoor-linkable BBA+ scheme BBAP ensures
false-accusation protection if for any PPT adversary A in the ex-
BBAP,A (n) from Fig. 7 the advantage of A defined
periment Expfacp
by
(6)
Advfacp
BBAP,A (n) := Pr[Expfacp
BBAP,A (n) = 1]
is negligible in n.
4 BBA+ INSTANTIATION
In this section, we present our basic scheme BBAP which is secure
with respect to the “reduced model” presented in Section 3.3 and
privacy-preserving with respect to the model in Section 3.4. As
already mentioned, this basic protocol can easily be made secure
in a full-fledged model in which eavesdropping on and corrupting
of honest users is allowed, by encrypting all messages transmitted
during the protocols Issue, Accum and Vfy. Please refer to the full
version of the paper [22] for details.
4.1 Building Blocks
Let SetupGrp be a bilinear group generator (cf. Definition 2.1) which
outputs the description of a bilinear group gp := (G1, G2, GT , e, p,