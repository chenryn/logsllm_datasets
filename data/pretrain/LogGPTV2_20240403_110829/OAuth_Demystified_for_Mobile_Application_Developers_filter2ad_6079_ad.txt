cannot guarantee that an access token is sent to its intended
relying party application, there is currently no secure way of
performing authentication using Facebook on iOS (even the
security-enhanced implicit grant described in Section 5.2 is
vulnerable).
Fortunately, the Android platform is slightly diﬀerent.
Our study revealed that both of the two major Android
service providers (i.e., Facebook and Google) were using the
Intent mechanism securely. Unlike for service providers in
iOS, Android service providers can actually verify the recip-
ient’s identity when Android Intent is used for message pass-
ing, using the Android key hash. By default, every Android
application in the Google Play store is signed using its de-
veloper’s secret key (this secret is diﬀerent from the OAuth
relying party secret). When an Android relying party reg-
(a) Correct usage.
(b) Incorrect usage by Keek.
Figure 4: Usages of the Facebook appsecret proof ﬂow. Parameters inside square brackets are cryptographically hashed using
the relying party secret.
isters itself with the service provider, the service provider
would ask the relying party to provide a hash of its Android
developer key. Then, when the service provider wishes to
send sensitive messages (e.g., access token) to the same re-
lying party, it can use the following code to fetch for the
developer’s key hash:
relying_party = Activity.getCallingPackage();
dev_key_hash = getPackageManager().
getPackageInfo(relying_party,
PackageManager.GET_SIGNATURES);
Once the relying party’s key hash is obtained, the service
provider can check if this key hash matches with the key hash
provided by the developer during its application registration
stage (this is akin to checking for the redirection URI). If the
two key hashes match, then the service provider can trust
that the message is returned to the correct relying party.
We have veriﬁed that both Google and Facebook use this
mechanism to deliver access tokens to Android applications.
Out of all the access token delivery methods, this is the only
method in Android that was found to be secure.
5.3.2 Mobile browser and WebView
Since the OAuth speciﬁcation does not specify how to
perform user-agent redirection for mobile applications,
it
may seem natural to use a mobile browser or an embedded
browser (i.e., WebView [3, 19]) to perform web-based OAuth
redirections on mobile devices. Previous work showed some
instances of insecure WebView usages jeopardizing security
[31, 42].
It is valuable to understand how pervasive and
fundamental the problem is in our set of applications.
The WebView usage is very common for service providers
that utilize a single protocol ﬂow for both web and mobile
relying parties. In our study, we observed several notable
service providers that fall into this category, including Twit-
ter, Microsoft LiveID, Flikr, and Renren. Unlike Facebook
and Google, these service providers do not facilitate OAuth
ﬂows for mobile relying party using their own mobile applica-
tions. Instead, they choose to use their websites to conduct
all mobile OAuth transactions.
Many mobile developers na¨ıvely believe that since the
OAuth speciﬁcation is speciﬁcally designed for web usages,
one can securely apply it to mobile platforms by using the
web-based ﬂow inside a mobile web browser (or a WebView
instance). This is a common misconception, as we have not
found a single case in our study where a mobile browser or
WebView is used securely for OAuth.
The fundamental reason why one cannot securely perform
OAuth transactions between a mobile relying party and a
web-based service provider is that it is diﬃcult, if not im-
possible, for the service provider website to determine the
identity of the mobile relying party. To the best of our
knowledge, there currently exists no secure method in ei-
ther iOS or Android to allow a service provider website to
deliver sensitive OAuth tokens (e.g., request token or access
token) to the honest relying party application. In our study,
we observed two ﬂawed methods used by web-based service
providers to deliver OAuth tokens to mobile relying party
applications. These two methods are described below.
• Using custom schemes and custom Intent ﬁlters
– One way for a web-based service provider (inside a
mobile browser or WebView) to deliver OAuth tokens
to a mobile relying party is by redirecting the user to
a URI with the relying party’s custom scheme. Recall
in Section 5.3.1, we concluded that: (1) the custom
scheme mechanism in iOS is insecure, and (2) the cus-
tom Intent ﬁlter mechanism in Android can be used
securely by verifying the relying party’s developer key
hash. Unfortunately, an Android relying party’s de-
veloper key hash can only be veriﬁed using a native
mobile application. A web-based service provider in-
side a browser cannot verify the relying party’s key
hash without using the relying party as an oracle.
• Using URI parameters – Another technique for
sending access token to a mobile relying party is by di-
rectly attaching the access token to the service provider’s
URI (e.g., provider.com/?token=TOKEN).
If the ser-
vice provider is contained inside a WebView, the rely-
ing party that hosts the WebView instance can recover
this URI using WebView API calls (e.g., getURL()
in Android). For instance, the Renren Android SDK
was using this method to perform its access token
exchange. Unfortunately, when using this technique,
there is currently no way for the embedded service
provider to determine the identity of the host appli-
cation.
Interestingly, the problem with message passing between
a WebView instance and its host application is similar to the
UserService ProviderRelying party1. App ID, redirect URI3. Access Token2. User grants permission5. User’s FB ID4. [Access Token]Verifies redirect URIVerifies appsecret_proofUserService ProviderRelying party1. App ID, redirect URI3. Access Token2. User grants permission4. [Access Token]Verifies appsecret_proof5. Proof succeeded6. proof succeededVerifies redirect URI8. User’s FB ID7.Access TokenFor most service providers, this step involves the user to
ﬁrst sign onto the service provider using her log-in creden-
tials, then manually click through a permission dialogue box
with the relying party’s name and the permission scope (i.e.,
the type of protected resource the relying party wishes to
access). Only then can the protocol transaction proceed.
However, Tencent interpreted this step diﬀerently: it issued
the user’s ID hash to the relying party immediately after au-
thenticating the user (without prompting the user with an
additional permission dialogue box). This step seemed in-
nocuous at ﬁrst – since if the user voluntarily decided to log
into the relying party application by entering her Tencent
credentials, an additional permission dialogue might seem
unnecessary. Unfortunately, when the protocol transaction
is performed inside a WebView (which is the default method
used by Tencent’s oﬃcial SDK), the following attack is fea-
sible:
1. A user signs onto a malicious application using Ten-
cent in a WebView. However, the adversary supplies
Tencent with the application ID and redirection URI
of a benign relying party.
2. The user authenticates with Tencent, thinking that she
is signing onto the malicious application. Unfortu-
nately, unbeknownst to the user, Tencent treats this
authentication request as one that comes from the be-
nign relying party. Before proceeding, Tencent veriﬁes
that the redirection URI supplied in Step 1 matches
with the registered URI for the application speciﬁed
by the app ID in Step 1 (both of which are the correct
information of the benign relying party provided by
the attacker).
3. Tencent redirects the user to the redirection URI that
belongs to the benign relying party. This redirection
request includes the user’s ID hash for the benign re-
lying party.
4. At this point, the malicious application can obtain the
user’s ID hash associated with the benign relying party
from its WebView using getURL() in Android and cur-
rentWebView.request.URL in iOS.
After the attacker retrieves the user’s ID hash for the benign
relying party, she can use this to sign onto the benign relying
party’s application as the user.
It is important to note that this attack was enabled by
two implementation details that were not well-deﬁned in the
OAuth speciﬁcations. First, Tencent used the same service
provider website for both web and mobile OAuth ﬂows. This
forced its mobile relying party applications into using We-
bView for authentication. Second, because Tencent’s user
authentication step did not include a permission dialogue
box, users could not determine the identity of the relying
party application they were signing onto.
After we reported our ﬁndings, Tencent immediately ac-
knowledged this issue and patched their user authentication
mechanism by adding an additional permission dialogue box.
5.5 Lessons learned
As we have shown in this section, OAuth usages on mo-
bile applications require detailed understandings and con-
siderations about the protocol speciﬁcations and the mobile
platform capabilities. We hope that this study can provoke
Figure 5: Tencent’s enhanced implicit grant for authenti-
cation. The variables inside the square brackets are crypto-
graphically hashed using a secret key known to only Tencent.
problem described by Barth et al. several years ago regard-
ing inter-frame communications in web browsers [6]. In this
work, the authors proposed a method called PostMessage
that allows embedded principals to specify the origin of the
message recipient. A similar technique for mobile applica-
tions has been proposed by Wang et al. [42]. However, this
proposal is yet to be adopted in practice by mobile operating
systems.
5.4
Inventing home-brewed protocol ﬂows
Since the OAuth speciﬁcation does not specify the use-
case of authentication, instead of leveraging existing autho-
rization ﬂows, several service providers have decided to come
up with their own “OAuth-based” protocol ﬂows. In this sec-
tion, we study one of these home-brewed OAuth protocols
and demonstrate the diﬃculties in designing a completely
secure authentication ﬂow.
Tencent is a popular Chinese OAuth service provider that
owns Tencent Weibo (a micro-blogging platform with 825
million users [40]) and QQ (an instant messaging application
with 798 million active accounts [39]). Tencent claimed to
provide authentication using the OAuth 2.0 implicit grant.
Upon investigation, we discovered that the implicit grant
used by Tencent is actually a modiﬁed version of the OAuth
2.0 implicit grant. We illustrate Tencent’s implicit grant in
Figure 5 and analyze it below.
Tencent’s developers seemed to understand that because
access tokens in OAuth 2.0 are not bound to their relying
parties, the standard implicit grant is inherently insecure
for authentication. In order to make the implicit grant safe
for authentication, Tencent added a new ID hash parameter
into the protocol ﬂow. This ID hash is a concatenated string
of the relying party’s application ID and the user’s Tencent
ID, cryptographically hashed using a secret key that is only
known to Tencent. For authentication purposes, instead of
using the access token to exchange for the user’s Tencent
ID, relying parties can simply use this ID hash directly as
the user ID. Since the value of the ID hash is diﬀerent for
each application, an adversary cannot utilize a user’s ID
hash generated for one application to sign onto the user’s
account for another application.
Another unique attribute of Tencent’s OAuth ﬂow is how
Tencent authenticates the user in Step 2 of the protocol. In
the canonical OAuth 2.0 implicit grant, this step is deﬁned
as follows [27]:
The authorization server authenticates the re-
source owner (via the user-agent) and establishes
whether the resource owner grants or denies the
client’s access request.
UserService ProviderRelying party2. User logs into Tencent3. Access token,[App ID, User ID]1. App ID, redirect URIVerifies redirect URI4. Access token, [App ID, User ID]the OAuth Working Group to come up with clear guidelines
for mobile application developers. Some lessons we learned
from this study are summarized here.
General lessons. The security of OAuth partially lies in
its access token delivery methodology. We showed that it is
diﬃcult for a mobile service provider to ensure that an access
token is sent to its intended recipient. For this, we come
up with an informal rule-of-thumb for mobile developers to
decide on whether a certain mechanism can be safely used
for access token delivery:
• A mechanism can be safely used to distribute access
tokens if the service provider can always identify the
recipient using a globally unique identiﬁer.
For example, on the Web, browser redirection can be con-
sidered as a secure access token delivery method because the
relying party can always be uniquely identiﬁed through its
host name. In Android, an Intent can be used to securely
send an access token to its intended mobile relying party
application because the relying party can be uniquely iden-
tiﬁed through its developer key hash. On the other hand,
a custom scheme cannot be used to transfer an access to-
ken because iOS allows multiple applications to register for
the same scheme without oﬀering an accessible method to
identify these applications.
Lessons for authorization. In addition to using a se-
cure method to deliver access tokens, another important se-
curity criterion for authorization is to ensure that the user’s
permission is willfully granted to the relying party. For this,
the service provider should always obtain permission from
a user by presenting a dialogue box including the relying
party’s information and the scopes of its permissions.
Lessons for authentication. When OAuth is used for
authentication, the user’s device must not be trusted. This
rule has two implications. First, the relying party must re-
frain from bundling any security related protocol logic (e.g.,
security checks) or any sensitive information (e.g., the appli-
cation secret) into its own mobile application. Second, the
relying party must assume that the attacker could tamper
with any data sent from the user’s device.
For this reason, an integral step of the protocol is to ensure
that the relying party receiving the user’s ID in the last step
of the protocol is the same relying party that the user intends
to authenticate to. For instance, the OAuth 1.0 ﬂow is secure
for authentication because a given access token can only be
used to exchange for the user’s ID by the same relying party
that the access token was granted to.
6. RELATED WORK