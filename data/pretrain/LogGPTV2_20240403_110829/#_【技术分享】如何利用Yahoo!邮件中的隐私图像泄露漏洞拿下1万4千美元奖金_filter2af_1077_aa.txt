# 【技术分享】如何利用Yahoo!邮件中的隐私图像泄露漏洞赢得14,000美元奖金

## 译文声明
本文为翻译文章，原文来源于scarybeastsecurity.blogspot.hk。译文仅供参考，具体内容及含义以原文为准。
- 翻译：兴趣使然的小胃（http://bobao.360.cn/member/contribute?uid=2819002922）
- 预估稿费：200RMB
- 投稿方式：发送邮件至linwei#360.cn 或登录网页版在线投稿

## 一、前言
“滴血”攻击是目前非常热门的话题，其中最著名的包括[心脏滴血（Heartbleed）](https://en.wikipedia.org/wiki/Heartbleed)和[云滴血（Cloudbleed）](https://en.wikipedia.org/wiki/Cloudbleed)漏洞。这些漏洞都是由于服务端代码中的越界读取漏洞导致服务器私密内存数据被返回给客户端。这类漏洞会泄露服务端进程内存空间中的敏感信息，如密钥、令牌、cookies等。此外，最近在微软图像库的客户端实现中也发现了类似的漏洞，该漏洞可以通过Internet Explorer泄露敏感信息。

本文将介绍一个名为Yahoobleed #1（YB1）的漏洞，通过此漏洞可以从Yahoo!服务器窃取其他用户的Yahoo!邮件中的隐私图像附件。YB1利用的是我在[ImageMagick](https://www.imagemagick.org/script/index.php)图像处理软件中发现的一个零日漏洞。现在这个漏洞已经修复，并且编号为CESA-2017-0002。与传统的越界读取漏洞不同，这个漏洞是由于未初始化内存的使用引起的。程序使用某个未初始化的图像解码缓冲区来渲染图片并返回给用户，从而导致服务端内存泄露。这种类型的漏洞更为隐蔽，因为服务器不会崩溃，但泄露的数据受限于已被释放的堆块中的数据。

## 二、Yahoo!的回应
Yahoo!对这个漏洞的响应堪称完美，具体如下：
1. Yahoo!有一个漏洞奖励项目，鼓励并回馈安全研究者，并与黑客保持积极联系。
2. 收到漏洞报告后，他们有90天的回复期限，这是一个非常进步的做法。相比之下，微软有时会将合理的披露期限变成无意义的争论。
3. 该漏洞确实在90天内得到了修复。
4. 沟通过程非常顺畅，即使我频繁发送询问请求，他们也不厌其烦。
5. 漏洞修复非常彻底：直接弃用了ImageMagick。
6. 他们给予了我14,000美元的奖励（结合另一个漏洞获得），平均每字节价值778美元，非常棒。
7. 我将所有奖金捐赠给了慈善机构。确认这一信息后，Yahoo!将奖金提高到了28,000美元。
8. 最终，事了拂衣去，深藏功与名。

## 三、漏洞示例
在漏洞示例中，我们使用的攻击方法是将一个18字节的漏洞利用文件作为Yahoo!邮件附件发送给自己，然后在收到的邮件中点击这张图像，运行图片预览面板。最终浏览器收到的图像是未初始化或之前已释放的内存数据。

请注意，以下三张图片经过各种变换抹去了存在的信息熵，原始图片已被销毁。

**图片1**：你可以看到被黑圈围绕的字母A。想象一下，在调试一个自认为非常无趣的漏洞时，突然在返回的图像中出现这样的信息会有什么感觉？如果假设内存中的图像不包含重复信息，那么复原图像中出现重复信息可能是因为内存中的图像大小与未初始化的画布尺寸不匹配。根据内存中图像的不同存储方式，尺寸不匹配会导致图像重复或偏移。

**图片2**：你仍然可以看到图片中残存的人脸痕迹，也许是额头、鼻子、前额甚至颚骨。当你从这张图片中发现一张随机的脸时，你会感受到问题的严重性。当我遇到这种情况时，我删除了导致未初始化内存漏洞的所有文件，并报告了该漏洞。

**图片3**：图像中的颜色得以保留，因为图片中有某些垂直的彩色线条，这些颜色包括品红色、青色以及黄色。究竟是内存中的哪个结构导致了这种现象，我不清楚。最初我认为这是某些CMYK颜色空间的表现，但随后否定了这种想法。JPEG文件通常在YCbCr颜色空间中进行编码，因此这种现象可能与某个编码或解码的JPEG图片有关。

## 四、漏洞分析
这个漏洞隐藏于RLE（Utah Raster Toolkit Run Length Encoded）图片格式中，我之前在某篇分析box.com内存损坏漏洞的文章中也提到过这个漏洞。相关代码片段可以在coders/rle.c源码中找到：

```c
pixel_info_length = image->columns * image->rows * MagickMax(number_planes_filled, 4);
pixels = (unsigned char *) GetVirtualMemoryBlob(pixel_info);

if ((flags & 0x01) && !(flags & 0x02)) {
  // 设置背景色
  p = pixels;
  for (i = 0; i < (ssize_t) number_pixels; i++) {
    // ...
    for (j = 0; j < (ssize_t) (number_planes - 1); j++) {
      // ...
    }
  }
}
```

这段代码中的`GetVirtualMemoryBlob`函数分配了一个未初始化的内存块，而后续的循环操作并未正确初始化这些内存，导致了内存泄露。