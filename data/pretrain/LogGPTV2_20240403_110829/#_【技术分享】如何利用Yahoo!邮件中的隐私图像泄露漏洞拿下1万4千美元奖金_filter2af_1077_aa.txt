# 【技术分享】如何利用Yahoo!邮件中的隐私图像泄露漏洞拿下1万4千美元奖金
|
##### 译文声明
本文是翻译文章，文章来源：scarybeastsecurity.blogspot.hk
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
翻译：[兴趣使然的小胃](http://bobao.360.cn/member/contribute?uid=2819002922)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**一、前言**
滴血攻击现在是个非常热门的话题，这类漏洞中最引人注目的就是[心脏滴血（Heartbleed）漏洞](https://en.wikipedia.org/wiki/Heartbleed)以及[云滴血（Cloudbleed）漏洞](https://en.wikipedia.org/wiki/Cloudbleed)。在这两个漏洞中，服务端代码中存在的越界读取漏洞都会导致服务器的私密内存数据被返回给客户端。这些漏洞会泄露服务端进程内存空间中的敏感信息，比如密钥、令牌、cookies等。此外，最近微软图像库的客户端实现中还存在滴血[漏洞](https://bugs.chromium.org/p/project-zero/issues/detail?id=992)，该漏洞会通过Internet
Explorer泄露敏感信息。滴血攻击之所以引人关注，原因在于它们不受大多数沙盒的影响，并且利用方式也相对容易。
本文介绍的是一个Yahoobleed #1（YB1）漏洞，我们可以利用这个漏洞，从Yahoo!服务器中窃取其他用户的Yahoo!邮件中的隐私图像附件。
YB1利用的是我之前在[ImageMagick](https://www.imagemagick.org/script/index.php)图像处理软件中发现的一个0-day漏洞。现在这个漏洞已经是一个1-day漏洞了，因为我已经将其上报给ImageMagick，同时提交了一行修复[代码](http://git.imagemagick.org/repos/ImageMagick/commit/1c358ffe0049f768dd49a8a889c1cbf99ac9849b)来解决这个问题。目前这个漏洞的编号为CESA-2017-0002。
之前滴血类漏洞通常都是越界读取漏洞，但本文分析的这个漏洞是由于未初始化内存的使用所引起的。在这个案例中，程序以某个未初始化的图像解码缓冲区为基础，来渲染某张图片并返回给用户，这将导致服务端内存泄露。这类漏洞与越界读取漏洞相比更为隐蔽，因为服务器永远不会发生崩溃。然而，所泄露的隐私数据会受限于已被释放的堆块中的数据。
**二、Yahoo!的回复**
Yahoo!对这个漏洞的回复是我见过的最为完美的回复，具体如下：
1、Yahoo!有个漏洞奖金项目，用来鼓励并回馈漏洞安全研究，同时也与黑客保持积极的联系等等。
2、一旦收到漏洞报告时，他们自己会有一个90天的回复期限，这是非常进步的一点，另一个反例就是微软，微软偶尔会将合理的披露期限变成毫无意义的缠斗过程。
3、该漏洞的确在90天内就被修补了。
4、沟通过程非常顺畅，即使我发送了太多的ping请求他们也不厌其烦。
5、漏洞的修复非常彻底：他们直接弃用了ImageMagick。
6、他们给我发放了1万4千美金的奖励（我结合另外一个[漏洞](https://scarybeastsecurity.blogspot.hk/2017/05/bleed-more-powerful-dumping-yahoo.html)获得了这些奖金），平均每个字节价值778美金，非常棒。
7、我将所有奖金捐献给了慈善机构。确认这一信息后，Yahoo!接受了相关建议，将奖金提高到了28,000美金。
8、事了拂衣去，深藏功与名。
**三、漏洞示例**
在漏洞示例中，我们所使用的攻击方法就是将某个18字节的漏洞利用文件（或者变量）作为Yahoo!邮件附件发送给我自己，然后在收到的邮件中点击这张图像，运行图片预览面板。最终浏览器收到的图像对应的是一段未初始化、或者之前已经被释放的内存数据。
请注意：对于下文所使用的三张图片，我通过各种变换抹去了图片中存在的信息熵，且原始图片已经被销毁。
在图片#1中，你可以看到被黑圈围绕的字母A。想象一下，当你正在调试一个自认为非常无趣的漏洞时，在返回的图像中突然出现这类信息会有什么感觉？如果假设内存中原始的图像不包含重复信息，那么在复原的图像中重复出现这类信息有多种可能的原因。
最为明显的一个原因就是，内存中的图像大小可能与我们未初始化的画布（canvas）尺寸不匹配，对这个例子来说，我们使用的画布尺寸为1024×1024。根据内存中图像的不同存储方式，尺寸不匹配将导致图像重复以及（或者）偏移，这两种现象都可以在这个示例中找到。
此外，内存中图像的表示方式可能与颜色空间（colorspace）、颜色空间通道顺序或者Alpha通道状态（为“是”或者“否”状态）不一致。这种情况下，缩略图解码及重新编码管道将在执行过程中在内存中留下各种不同的衍生品。
请不要怀疑我们能否正确恢复原始的图像，但这并非是我们的目标。
在图片#2中，你仍然有可能找出图片中残存的人脸痕迹，也许是额头、鼻子、前额甚至颚骨？有可能什么都找不到，因为我已经去掉了图片中的信息熵。但当你从这张图片中发现一张随机的脸时，你就会感觉到问题的严重性。当我遇到这种情况时，我删除了导致未初始化内存漏洞的所有文件，并报告了该漏洞。
在图片3#中，图像中的颜色得以保留，因为这张图片中有某些垂直的彩色线条，这些颜色包括品红色、青色以及黄色。究竟内存中的哪个结构会导致这种现象发生呢？我并不了解。最开始我认为这是某些CMYK颜色空间的外在表现，但随后我否定了这种想法。JPEG文件通常会在YCbCr颜色空间中进行编码，因此这种现象可能与某个编码或解码的JPEG图片有关。
**四、漏洞分析**
这个漏洞隐藏于RLE（Utah Raster Toolkit Run Length
Encoded）图片格式中，我之前在某篇分析box.com内存损坏漏洞的[文章](https://scarybeastsecurity.blogspot.com/2017/03/black-box-discovery-of-memory.html)中也提到过这个漏洞。我们可以在coders/rle.c源码中，找到与新的ImageMagick
0-day漏洞有关的代码片段：
        pixel_info_length=image->columns*image->rows*
          MagickMax(number_planes_filled,4);
        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
        if ((flags & 0x01) && !(flags & 0x02))
          {
    [...]
            /*
              Set background color.
            */
            p=pixels;
            for (i=0; i < (ssize_t) number_pixels; i++)
            {
    [...]
                {
                  for (j=0; j < (ssize_t) (number_planes-1); j++)