# 25 \| 答疑课堂：模块四热点问题解答你好，我是刘超。本周我们结束了"JVM 性能监测及调优"的学习，这一期答疑课堂我精选了模块四中11位同学的留言，进行集中解答，希望也能对你有所帮助。另外，我想为坚持跟到现在的同学点个赞，期待我们能有更多的技术交流，共同成长。第 20 讲](https://time.geekbang.org/column/article/106203)![](Images/ee3ba6edec0548c6107f85c90554042d.png){savepage-src="https://static001.geekbang.org/resource/image/31/3a/31a205290c3b2391f115ee77f511a43a.jpeg"}很多同学都问到了类似"黑夜里的猫\"问到的问题，所以我来集中回复一下。JVM的内存模型只是一个规范，方法区也是一个规范，一个逻辑分区，并不是一个物理空间，我们这里说的字符串常量放在堆内存空间中，是指实际的物理空间。![](Images/b2cb0f7fa5146562654bc8a20e5ccef5.png){savepage-src="https://static001.geekbang.org/resource/image/2a/01/2ac5ee0c9a6fe67ce8f896be75d05f01.jpeg"}文灏的问题和上一个类似，一同回复一下。元空间是属于方法区的，方法区只是一个逻辑分区，而元空间是具体实现。所以类的元数据是存放在元空间，逻辑上属于方法区。第 21 讲](https://time.geekbang.org/column/article/106953)![](Images/d9d21167bed50310df6e05a4a10c6c14.png){savepage-src="https://static001.geekbang.org/resource/image/f2/76/f2fa07e388f5a3dbe84bb12bfea5ee76.jpeg"}Liam 同学，目前 Hotspot 虚拟机暂时不支持栈上分配对象。W.LI同学的留言值得参考，所以这里一同贴出来了。![](Images/ec90e21ca7fbcd36490fe846e30a8deb.png){savepage-src="https://static001.geekbang.org/resource/image/20/f2/20e59cb2df51bd171d41c81e074821f2.jpeg"}第 22 讲](https://time.geekbang.org/column/article/107396)![](Images/05f61e60e112bcc640acdeb1de18a176.png){savepage-src="https://static001.geekbang.org/resource/image/09/25/09ada15236e8ceeef2558d6ab7505425.jpeg"}非常赞，Region 这块，Jxin 同学讲解得很到位。这里我再总结下 CMS 和 G1的一些知识点。CMS 垃圾收集器是基于标记清除算法实现的，目前主要用于老年代垃圾回收。CMS收集器的 GC 周期主要由 7 个阶段组成，其中有两个阶段会发生stop-the-world，其它阶段都是并发执行的。``{=html}![](Images/6fdfcc7c5ebcb95ed1b6ccccb17e7e7b.png){savepage-src="https://static001.geekbang.org/resource/image/50/aa/500c2f0e112ced378fd49a09c61c5caa.jpg"}G1垃圾收集器是基于标记整理算法实现的，是一个分代垃圾收集器，既负责年轻代，也负责老年代的垃圾回收。跟之前各个分代使用连续的虚拟内存地址不一样，G1 使用了一种 Region方式对堆内存进行了划分，同样也分年轻代、老年代，但每一代使用的是 N个不连续的 Region 内存块，每个 Region 占用一块连续的虚拟内存地址。在 G1 中，还有一种叫 Humongous 区域，用于存储特别大的对象。G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代的YoungGC 中被回收掉。![](Images/c35c5d038831de35f7463d192057278e.png){savepage-src="https://static001.geekbang.org/resource/image/f8/be/f832278afd5cdb94decd1f6826056dbe.jpg"}G1 分为 Young GC、Mix GC 以及 Full GC。G1 Young GC 主要是在 Eden 区进行，当 Eden 区空间不足时，则会触发一次Young GC。将 Eden 区数据移到 Survivor 空间时，如果 Survivor空间不足，则会直接晋升到老年代。此时 Survivor的数据也会晋升到老年代。Young GC 的执行是并行的，期间会发生 STW。当堆空间的占用率达到一定阈值后会触发 G1 Mix GC（阈值由命令参数-XX:InitiatingHeapOccupancyPercent 设定，默认值 45），Mix GC主要包括了四个阶段，其中只有并发标记阶段不会发生 STW，其它阶段均会发生STW。![](Images/9d85c40c143e52af7d6524da65a718c6.png){savepage-src="https://static001.geekbang.org/resource/image/b8/2f/b8090ff2c7ddf54fb5f6e3c19a36d32f.jpg"}G1 和 CMS 主要的区别在于：-   CMS 主要集中在老年代的回收，而 G1 集中在分代回收，包括了年轻代的    Young GC 以及老年代的 Mix GC；-   G1 使用了 Region    方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生；-   在初始化标记阶段，搜索可达对象使用到的 Card    Table，其实现方式不一样。这里我简单解释下 Card Table，在垃圾回收的时候都是从 Root开始搜索，这会先经过年轻代再到老年代，也有可能老年代引用到年轻代对象，如果发生YoungGC，除了从年轻代扫描根对象之外，还需要再从老年代扫描根对象，确认引用年轻代对象的情况。**这种属于跨代处理，非常消耗性能。**为了避免在回收年轻代时跨代扫描整个老年代，CMS和 G1 都用到了 Card Table 来记录这些引用关系。只是 G1 在 Card Table的基础上引入了 RSet，每个 Region 初始化时，都会初始化一个 RSet，RSet记录了其它 Region 中的对象引用本 Region 对象的关系。除此之外，CMS 和 G1 在解决并发标记时漏标的方式也不一样，CMS 使用的是Incremental Update 算法，而 G1 使用的是 SATB 算法。首先，我们要了解在并发标记中，G1 和 CMS 都是基于三色标记算法来实现的：-   黑色：根对象，或者对象和对象中的子对象都被扫描；-   灰色：对象本身被扫描，但还没扫描对象中的子对象；-   白色：不可达对象。基于这种标记有一个漏标的问题，也就是说，当一个白色标记对象，在垃圾回收被清理掉时，正好有一个对象引用了该白色标记对象，此时由于被回收掉了，就会出现对象丢失的问题。为了避免上述问题，CMS 采用了 Incremental Update算法，只要在写屏障（writebarrier）里发现一个白对象的引用被赋值到一个黑对象的字段里，那就把这个白对象变成灰色的。而在G1 中，采用的是 SATB算法，该算法认为开始时所有能遍历到的对象都是需要标记的，即认为都是活的。G1 具备 Pause Prediction Model ，即停顿预测模型。用户可以设定整个 GC过程中期望的停顿时间，用参数 -XX:MaxGCPauseMillis 可以指定一个 G1收集过程的目标停顿时间，默认值 200ms。G1 会根据这个模型统计出来的历史数据，来预测一次垃圾回收所需要的 Region数量，通过控制 Region 数来控制目标停顿时间的实现。![](Images/198e6240e5e8c2c7a651f411f7a40580.png){savepage-src="https://static001.geekbang.org/resource/image/91/b4/915e9793981a278112087f0c880b96b4.jpeg"}Liam 提出的这两个问题都非常好。不管什么 GC，都会发送stop-the-world，区别是发生的时间长短。而这个时间跟垃圾收集器又有关系，Serial、PartNew、ParallelScavenge 收集器无论是串行还是并行，都会挂起用户线程，而 CMS 和 G1在并发标记时，是不会挂起用户线程的，但其它时候一样会挂起用户线程，stopthe world 的时间相对来说就小很多了。Major Gc 在很多参考资料中是等价于 Full GC的，我们也可以发现很多性能监测工具中只有 Minor GC 和 FullGC。一般情况下，一次 Full GC将会对年轻代、老年代、元空间以及堆外内存进行垃圾回收。触发 Full GC的原因有很多：-   当年轻代晋升到老年代的对象大小，并比目前老年代剩余的空间大小还要大时，会触发    Full GC；-   当老年代的空间使用率超过某阈值时，会触发 Full GC；-   当元空间不足时（JDK1.7 永久代不足），也会触发 Full GC；-   当调用 System.gc() 也会安排一次 Full GC。![](Images/ace7cef932c635bba9fa13178cc273c8.png){savepage-src="https://static001.geekbang.org/resource/image/a8/24/a8a506a512922609669b4073d0dbc224.jpeg"}接下来解答 ninghtmare 的提问。我们可以通过 jstat -gc pid interval查看每次 GC 之后，具体每一个分区的内存使用率变化情况。我们可以通过 JVM的设置参数，来查看垃圾收集器的具体设置参数，使用的方式有很多，例如 jcmdpid VM.flags 就可以查看到相关的设置参数。![](Images/7d229d03250de4a66e27eb1d007f9d2b.png){savepage-src="https://static001.geekbang.org/resource/image/26/2e/26d688a3af534fb00fe3b89d261e5c2e.jpg"}这里附上第 22 讲中，我总结的各个设置参数对应的垃圾收集器图表。![](Images/809c9aa5bd5069f29596a4679f620b85.png){savepage-src="https://static001.geekbang.org/resource/image/e2/56/e29c9ac3e53ffbc8a5648644a87d6256.jpeg"}第 23 讲](https://time.geekbang.org/column/article/108139)![](Images/6dc43ae789a50b48282c6f358225bc65.png){savepage-src="https://static001.geekbang.org/resource/image/bb/76/bb92ec845c715f9d36a6ce48a0c7d276.jpeg"}我又不乱来同学的留言真是没有乱来，细节掌握得很好！前提是老年代有足够接受这些对象的空间，才会进行分配担保。如果老年代剩余空间小于每次Minor GC 晋升到老年代的平均值，则会发起一次 Full GC。![](Images/bd365accac92e8f06916e89cff75115b.png){savepage-src="https://static001.geekbang.org/resource/image/28/20/2838514b87e62d69bf51d7a7f12a0c20.jpeg"}看到这里，我发现爱提问的同学始终爱提问，非常鼓励啊，技术是需要交流的，也欢迎你有任何疑问，随时留言给我，我会知无不尽。现在回答 W.LI同学的问题。这个会根据我们创建对象占用的内存使用率，合理分配内存，并不仅仅考虑对象晋升的问题，还会综合考虑回收停顿时间等因素。针对某些特殊场景，我们可以手动来调优配置。第 24 讲](https://time.geekbang.org/column/article/108582)![](Images/847a7686dd4f952841db99086d0ca65c.png){savepage-src="https://static001.geekbang.org/resource/image/10/24/1080a8574a1a1ded35b736ccbec40524.jpeg"}下面解答 Geek_75b4cd 同学的问题。我们知道，ThreadLocal 是基于 ThreadLocalMap 实现的，这个 Map 的 Entry继承了 WeakReference，而 Entry 对象中的 key 使用了 WeakReference封装，也就是说 Entry 中的 key是一个弱引用类型，而弱引用类型只能存活在下次 GC 之前。如果一个线程调用 ThreadLocal 的 set 设置变量，当前 ThreadLocalMap则会新增一条记录，但由于发生了一次垃圾回收，此时的 key 值就会被回收，而value 值依然存在内存中，由于当前线程一直存在，所以 value值将一直被引用。.这些被垃圾回收掉的 key 就会一直存在一条引用链的关系：Thread \--\>ThreadLocalMap--\>Entry--\>Value。这条引用链会导致 Entry不会被回收，Value 也不会被回收，但 Entry 中的 key却已经被回收的情况发生，从而造成内存泄漏。我们只需要在使用完该 key 值之后，将 value 值通过 remove 方法 remove掉，就可以防止内存泄漏了。![](Images/de5a74dd3d831da0ffb147e1b16280b0.png){savepage-src="https://static001.geekbang.org/resource/image/8d/9a/8da35d95d5b31e3f0a582dbd4d47fd9a.jpeg"}最后一个问题来自于 WL 同学。内存泄漏是指不再使用的对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。例如，我在[第03 讲](https://time.geekbang.org/column/article/97215)中说到的，Java6 中substring 方法就可能会导致内存泄漏。当调用 substring 方法时会调用 new string构造函数，此时会复用原来字符串的 char 数组，而如果我们仅仅是用 substring获取一小段字符，而在原本 string 字符串非常大的情况下，substring的对象如果一直被引用，由于 substring 里的 char数组仍然指向原字符串，此时 string 字符串也无法回收，从而导致内存泄露。内存溢出则是发生了OutOfMemoryException，内存溢出的情况有很多，例如堆内存空间不足，栈空间不足，还有方法区空间不足等都会导致内存溢出。内存泄漏与内存溢出的关系：内存泄漏很容易导致内存溢出，但内存溢出不一定是内存泄漏导致的。今天的答疑就到这里，[如果你还有其它问题，请在留言区中提出，]{.orange}我会一一解答。最后欢迎你点击"请朋友读"，把今天的内容分享给身边的朋友，邀请他加入讨论。![unpreview](Images/b7c462671ae86891c7f8ac1941814e21.png){savepage-src="https://static001.geekbang.org/resource/image/bb/67/bbe343640d6b708832c4133ec53ed967.jpg"}
# 26 \| 单例模式：如何创建单一对象优化系统性能？你好，我是刘超。从这一讲开始，我们将一起探讨设计模式的性能调优。在《Design Patterns:Elements of Reusable Object-Oriented Software》一书中，有 23种设计模式的描述，其中，单例设计模式是最常用的设计模式之一。无论是在开源框架，还是在我们的日常开发中，单例模式几乎无处不在。
## 什么是单例模式？它的核心在于，单例模式可以保证一个类仅创建一个实例，并提供一个访问它的全局访问点。该模式有三个基本要点：一是这个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。结合这三点，我们来实现一个简单的单例：    // 饿汉模式public final class Singleton {    private static Singleton instance=new Singleton();// 自行创建实例    private Singleton(){}// 构造函数    public static Singleton getInstance(){// 通过该函数向整个系统提供实例        return instance;    }}由于在一个系统中，一个类经常会被使用在不同的地方，[通过单例模式，我们可以避免多次创建多个实例，从而节约系统资源。]{.orange}
## 饿汉模式我们可以发现，以上第一种实现单例的代码中，使用了 static 修饰了成员变量instance，所以该变量会在类初始化的过程中被收集进类构造器即 \方法中。在多线程场景下，JVM 会保证只有一个线程能执行该类的 \方法，其它线程将会被阻塞等待。等到唯一的一次 \ 方法执行完成，其它线程将不会再执行 \方法，转而执行自己的代码。也就是说，static 修饰了成员变量instance，在多线程的情况下能保证只实例化一次。``{=html}这种方式实现的单例模式，在类加载阶段就已经在堆内存中开辟了一块内存，用于存放实例化对象，所以也称为饿汉模式。饿汉模式实现的单例的优点是，可以保证多线程情况下实例的唯一性，而且getInstance 直接返回唯一实例，性能非常高。然而，在类成员变量比较多，或变量比较大的情况下，这种模式可能会在没有使用类对象的情况下，一直占用堆内存。试想下，如果一个第三方开源框架中的类都是基于饿汉模式实现的单例，这将会初始化所有单例类，无疑是灾难性的。
## 懒汉模式懒汉模式就是为了避免直接加载类对象时提前创建对象的一种单例设计模式。该模式使用懒加载方式，只有当系统使用到类对象时，才会将实例加载到堆内存中。通过以下代码，我们可以简单地了解下懒加载的实现方式：    // 懒汉模式public final class Singleton {    private static Singleton instance= null;// 不实例化    private Singleton(){}// 构造函数    public static Singleton getInstance(){// 通过该函数向整个系统提供实例        if(null == instance){// 当 instance 为 null 时，则实例化对象，否则直接返回对象            instance = new Singleton();// 实例化对象        }        return instance;// 返回已存在的对象    }}以上代码在单线程下运行是没有问题的，但要运行在多线程下，就会出现实例化多个类对象的情况。这是怎么回事呢？当线程 A 进入到 if 判断条件后，开始实例化对象，此时 instance 依然为null；又有线程 B 进入到 if判断条件中，之后也会通过条件判断，进入到方法里面创建一个实例对象。所以我们需要对该方法进行加锁，保证多线程情况下仅创建一个实例。这里我们使用Synchronized 同步锁来修饰 getInstance 方法：    // 懒汉模式 + synchronized 同步锁public final class Singleton {    private static Singleton instance= null;// 不实例化    private Singleton(){}// 构造函数    public static synchronized Singleton getInstance(){// 加同步锁，通过该函数向整个系统提供实例        if(null == instance){// 当 instance 为 null 时，则实例化对象，否则直接返回对象            instance = new Singleton();// 实例化对象        }        return instance;// 返回已存在的对象    }}但我们前面讲过，同步锁会增加锁竞争，带来系统性能开销，从而导致系统性能下降，因此这种方式也会降低单例模式的性能。还有，每次请求获取类对象时，都会通过 getInstance()方法获取，除了第一次为 null，其它每次请求基本都是不为 null的。在没有加同步锁之前，是因为 if 判断条件为 null时，才导致创建了多个实例。基于以上两点，我们可以考虑将同步锁放在 if条件里面，这样就可以减少同步锁资源竞争。    // 懒汉模式 + synchronized 同步锁public final class Singleton {    private static Singleton instance= null;// 不实例化    private Singleton(){}// 构造函数    public static Singleton getInstance(){// 加同步锁，通过该函数向整个系统提供实例        if(null == instance){// 当 instance 为 null 时，则实例化对象，否则直接返回对象          synchronized (Singleton.class){              instance = new Singleton();// 实例化对象          }         }        return instance;// 返回已存在的对象    }}看到这里，你是不是觉得这样就可以了呢？答案是依然会创建多个实例。这是因为当多个线程进入到if判断条件里，虽然有同步锁，但是进入到判断条件里面的线程依然会依次获取到锁创建对象，然后再释放同步锁。所以我们还需要在同步锁里面再加一个判断条件：    // 懒汉模式 + synchronized 同步锁 + double-checkpublic final class Singleton {    private static Singleton instance= null;// 不实例化    private Singleton(){}// 构造函数    public static Singleton getInstance(){// 加同步锁，通过该函数向整个系统提供实例        if(null == instance){// 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象          synchronized (Singleton.class){// 同步锁             if(null == instance){// 第二次判断                instance = new Singleton();// 实例化对象             }          }         }        return instance;// 返回已存在的对象    }}以上这种方式，通常被称为Double-Check，它可以大大提高支持多线程的懒汉模式的运行性能。那这样做是不是就能保证万无一失了呢？还会有什么问题吗？其实这里又跟 Happens-Before规则和重排序扯上关系了，这里我们先来简单了解下 Happens-Before规则和重排序。我们在第二期[加餐](https://time.geekbang.org/column/article/105756)中分享过，编译器为了尽可能地减少寄存器的读取、存储次数，会充分复用寄存器的存储值，比如以下代码，如果没有进行重排序优化，正常的执行顺序是步骤1\\2\\3，而在编译期间进行了重排序优化之后，执行的步骤有可能就变成了步骤1/3/2，这样就能减少一次寄存器的存取次数。    int a = 1;// 步骤 1：加载 a 变量的内存地址到寄存器中，加载 1 到寄存器中，CPU 通过 mov 指令把 1 写入到寄存器指定的内存中int b = 2;// 步骤 2 加载 b 变量的内存地址到寄存器中，加载 2 到寄存器中，CPU 通过 mov 指令把 2 写入到寄存器指定的内存中a = a + 1;// 步骤 3 重新加载 a 变量的内存地址到寄存器中，加载 1 到寄存器中，CPU 通过 mov 指令把 1 写入到寄存器指定的内存中在 JMM 中，重排序是十分重要的一环，特别是在并发编程中。如果 JVM可以对它们进行任意排序以提高程序性能，也可能会给并发编程带来一系列的问题。例如，我上面讲到的Double-Check的单例问题，假设类中有其它的属性也需要实例化，这个时候，除了要实例化单例类本身，还需要对其它属性也进行实例化：    // 懒汉模式 + synchronized 同步锁 + double-checkpublic final class Singleton {    private static Singleton instance= null;// 不实例化    public List list = null;//list 属性    private Singleton(){      list = new ArrayList();    }// 构造函数    public static Singleton getInstance(){// 加同步锁，通过该函数向整个系统提供实例        if(null == instance){// 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象          synchronized (Singleton.class){// 同步锁             if(null == instance){// 第二次判断                instance = new Singleton();// 实例化对象             }          }         }        return instance;// 返回已存在的对象    }}在执行 instance = new Singleton(); 代码时，正常情况下，实例过程这样的：-   给 Singleton 分配内存；-   调用 Singleton 的构造函数来初始化成员变量；-   将 Singleton 对象指向分配的内存空间（执行完这步 singleton 就为非    null 了）。如果虚拟机发生了重排序优化，这个时候步骤 3 可能发生在步骤 2之前。如果初始化线程刚好完成步骤 3，而步骤 2没有进行时，则刚好有另一个线程到了第一次判断，这个时候判断为非null，并返回对象使用，这个时候实际没有完成其它属性的构造，因此使用这个属性就很可能会导致异常。在这里，Synchronized只能保证可见性、原子性，无法保证执行的顺序。这个时候，就体现出 Happens-Before规则的重要性了。通过字面意思，你可能会误以为是前一个操作发生在后一个操作之前。然而真正的意思是，前一个操作的结果可以被后续的操作获取。这条规则规范了编译器对程序的重排序优化。我们知道 volatile 关键字可以保证线程间变量的可见性，简单地说就是当线程 A对变量 X 进行修改后，在线程 A 后面执行的其它线程就能看到变量 X的变动。除此之外，volatile 在 JDK1.5之后还有一个作用就是阻止局部重排序的发生，也就是说，volatile变量的操作指令都不会被重排序。所以使用 volatile 修饰 instance之后，Double-Check 懒汉单例模式就万无一失了。    // 懒汉模式 + synchronized 同步锁 + double-checkpublic final class Singleton {    private volatile static Singleton instance= null;// 不实例化    public List list = null;//list 属性    private Singleton(){      list = new ArrayList();    }// 构造函数    public static Singleton getInstance(){// 加同步锁，通过该函数向整个系统提供实例        if(null == instance){// 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象          synchronized (Singleton.class){// 同步锁             if(null == instance){// 第二次判断                instance = new Singleton();// 实例化对象             }          }         }        return instance;// 返回已存在的对象    }}
## 通过内部类实现以上这种同步锁 +Double-Check的实现方式相对来说，复杂且加了同步锁，那有没有稍微简单一点儿的可以实现线程安全的懒加载方式呢？我们知道，在饿汉模式中，我们使用了 static 修饰了成员变量instance，所以该变量会在类初始化的过程中被收集进类构造器即 \方法中。在多线程场景下，JVM 会保证只有一个线程能执行该类的 \方法，其它线程将会被阻塞等待。这种方式可以保证内存的可见性、顺序性以及原子性。如果我们在 Singleton类中创建一个内部类来实现成员变量的初始化，则可以避免多线程下重复创建对象的情况发生。这种方式，只有在第一次调用getInstance() 方法时，才会加载 InnerSingleton 类，而只有在加载InnerSingleton 类之后，才会实例化创建对象。具体实现如下：    // 懒汉模式 内部类实现public final class Singleton {public List list = null;// list 属性 private Singleton() {// 构造函数list = new ArrayList();} // 内部类实现public static class InnerSingleton {private static Singleton instance=new Singleton();// 自行创建实例} public static Singleton getInstance() {return InnerSingleton.instance;// 返回内部类中的静态变量}}
## 总结单例的实现方式其实有很多，但总结起来就两种：饿汉模式和懒汉模式，我们可以根据自己的需求来做选择。如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；如果我们是写一些工具类，则优先考虑使用懒汉模式，因为很多项目可能会引用到jar包，但未必会使用到这个工具类，懒汉模式实现的单例可以避免提前被加载到内存中，占用系统资源。
## 思考题除了以上那些实现单例的方式，你还知道其它实现方式吗？]{.orange}期待在留言区看到你的答案。也欢迎你点击"请朋友读"，把今天的内容分享给身边的朋友，邀请他一起讨论。![unpreview](Images/b7c462671ae86891c7f8ac1941814e21.png){savepage-src="https://static001.geekbang.org/resource/image/bb/67/bbe343640d6b708832c4133ec53ed967.jpg"}