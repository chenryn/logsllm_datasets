(vs. P
â€“ Before a corruption, S outputs a randomly sampled session
key ğ‘˜0 (vs. ğ‘˜1).
â€“ After a corruption, but ğ‘1 (vs. ğ‘0) has been generated before
corruption. Particularly, S selects the message ğ‘ 1 (vs. ğ‘ 0) ran-
domly, and simulates the ciphertext by sampling Â¯ğ‘0 (vs. Â¯ğ‘1)
randomly. After that, S cannot decrypt Â¯ğ‘0 (vs. Â¯ğ‘1) to a correct
value under the re-generated secret key ğ‘ ğ‘˜ (cid:4)
1), and S
samples a randomly chosen plaintext. Finally, S asks for the
session key ğ‘˜0 (vs. ğ‘˜1) from H on the pair (ğ‘ 0, ğ‘  (cid:4)
, ğ‘ 1)).
1
â€“ After a corruption, S selects a message ğ‘ 1 (vs. ğ‘ 0) randomly and
0 (vs. ğ‘ ğ‘˜ (cid:4)
) (vs. (ğ‘  (cid:4)
0
0 (vs. ğ‘ ğ‘˜ (cid:4)
invokes ğ‘0 â† AFEM.Enc(ğ‘ğ‘˜1, ğ‘ 0) (vs. ğ‘1 â† AFEM.Enc(ğ‘ğ‘˜0, ğ‘ 1)).
After that, S decapsulates Â¯ğ‘0 (vs. Â¯ğ‘1) to a correct value under
the re-generated secret key ğ‘ ğ‘˜ (cid:4)
1). Finally, S asks for the
session key ğ‘˜0 (vs. ğ‘˜1) from H on the pair (ğ‘ 0, ğ‘  (cid:4)
, ğ‘ 1)).
1
ğ‘—
) (vs. ğ¶ğ‘œğ‘Ÿğ‘Ÿğ‘¢ğ‘ğ‘¡ (P
)) implies that if this is the first
1
ğ‘—
corruption query involving Pğ‘–
0 (vs. P
1 ), one could first obtain a
secret key ğ‘ ğ‘˜0 (vs. ğ‘ ğ‘˜1), then define the public key ğ‘ğ‘˜0 (vs. ğ‘ğ‘˜1)
via the algorithm AFEM.PubGen(ğ‘ ğ‘˜0) (vs. AFEM.PubGen(ğ‘ ğ‘˜1)).
â€¢ ğ‘‡ ğ‘’ğ‘ ğ‘¡ (ğ‘) is answered using the defined session key according to
â€¢ ğ¶ğ‘œğ‘Ÿğ‘Ÿğ‘¢ğ‘ğ‘¡ (Pğ‘–
0
) (vs. (ğ‘  (cid:4)
0
the choice bit ğ‘.
At the very end, or at the time of corruption, the biometric charac-
teristics are selected at random, and corresponding public keys are
calculated via the secret keys. As a consequence, we have
Claim 7.
|Adv
Hy6
A
(ğœ†) âˆ’ Adv
Hy7
A
(ğœ†)| is negligible.
Proof. This claim is guaranteed by the security of AFEM.
(cid:2)
ğ‘—
) or ğ‘‡ ğ‘’ğ‘ ğ‘¡ (P
1
In the final hybrid, Aâ€™s view is independent of the real biometric
secret keys chosen by S until the following cases happen. 1). A
ğ‘—
) or ğ‘‡ ğ‘’ğ‘ ğ‘¡ (Pğ‘–
queries ğ‘…ğ‘’ğ‘£ğ‘’ğ‘ğ‘™ (Pğ‘–
) (vs. ğ‘…ğ‘’ğ‘£ğ‘’ğ‘ğ‘™ (P
)) after
0
0
1
ğ‘—
ğ‘†ğ‘’ğ‘›ğ‘‘1 (Pğ‘–
, ğ‘ğ‘˜0)) for a malicious and valid ğ‘ğ‘˜1
, ğ‘ğ‘˜1) (vs. ğ‘†ğ‘’ğ‘›ğ‘‘1 (P
0
1
ğ‘—
(vs. ğ‘ğ‘˜0); 2) A queries ğ‘…ğ‘’ğ‘£ğ‘’ğ‘ğ‘™ (Pğ‘–
) or ğ‘‡ ğ‘’ğ‘ ğ‘¡ (Pğ‘–
) (vs. ğ‘…ğ‘’ğ‘£ğ‘’ğ‘ğ‘™ (P
) or
0
0
1
ğ‘—
ğ‘—
, ğ‘0)) for a malicious
ğ‘‡ ğ‘’ğ‘ ğ‘¡ (P
, ğ‘1) (vs. ğ‘†ğ‘’ğ‘›ğ‘‘2 (P
1
1
Hy7
and valid ğ‘1 (vs. ğ‘0). Thus, it holds that Adv
(ğœ†) â‰¤ ğ‘„ğ‘  /(cid:12)ğ· (cid:12),
A
the way the session keys are defined is exactly the same as in the
random or the real cases (chosen at random before corruption). The
probability ğ‘ = ğ‘ (cid:4) is exactly Adv
(ğœ†) â‰¤ ğ‘„ğ‘  /(cid:12)ğ· (cid:12) + ğ‘›ğ‘’ğ‘”ğ‘™ (ğœ†). This
concludes the proof of Theorem 5.2 with Claim 1 to 7.
)) after ğ‘†ğ‘’ğ‘›ğ‘‘2 (Pğ‘–
0
Hy0
A
Session 10B: Crypto and Protocol Security CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2627Table 1: Asymptotic Comparison, where(cid:6)ğ‘› denotes the bit-length of a biometric string, ğ‘› denotes the size of a biometric vector
set, and ğœ is a constant. A round means an interaction between two participants, i.e., one participant sends a message to the
other, who then sends another message back. For the researches [19] and [21], the number of rounds is evaluated based on the
building blocks (e.g., aPAKE is regarded as one round), i.e., the actual number of rounds depends on the instantiations, which
may be bigger than the number presented in this table.
Scheme
Technique
Round Multiplication Exponentiation Hash
fPAKE-1 [19]
fPAKE-2 [19]
fuzzy
aPAKE-1 [21]
fuzzy
aPAKE-2 [21]
BAKE-1
BAKE-2
PAKE +
Garbled Circult
Secret Sharing
Secret Sharing +
Oblivious Transfer
sender
receiver
sender
receiver
sender
receiver
sender
receiver
sender
receiver
sender
receiver Polynomial Interpolation
Secret Sharing +
Random
Linear Codes
aPAKE
5
2
2
2
1
1
âˆ’
âˆ’
âˆ’
âˆ’
2(cid:6)ğ‘› + ğœ
(cid:6)ğ‘› + ğœ
4(cid:6)ğ‘› + ğœ
2(cid:6)ğ‘› + ğœ
ğœ(cid:6)ğ‘›2
âˆ’
ğ‘›2
ğœ ğ‘›3
3(cid:6)ğ‘› + ğœ
3(cid:6)ğ‘› + ğœ
2(cid:6)ğ‘› + ğœ
2(cid:6)ğ‘› + ğœ
4(cid:6)ğ‘› + ğœ
4(cid:6)ğ‘› + ğœ
5(cid:6)ğ‘› + ğœ
5(cid:6)ğ‘› + ğœ
4(cid:6)ğ‘› + ğœ
4(cid:6)ğ‘› + ğœ
(cid:6)ğ‘›
(cid:6)ğ‘›
3(cid:6)ğ‘› + ğœ
2(cid:6)ğ‘› + ğœ
4(cid:6)ğ‘› + ğœ
2(cid:6)ğ‘› + ğœ
Secret
Symmetric
Sharing Encryption
âˆ’
âˆ’
ğœ
ğœ
1
âˆ’
âˆ’
âˆ’
âˆ’
âˆ’
ğœ
ğœ
âˆ’
âˆ’
âˆ’
âˆ’
2(cid:6)ğ‘› + ğœ
2(cid:6)ğ‘› + ğœ
2(cid:6)ğ‘›
(cid:6)ğ‘›
âˆ’
âˆ’
âˆ’
âˆ’
ğœ
ğœ
2ğ‘› + ğœ
2ğ‘› + ğœ
âˆ’
ğœ
ğœ
ğœ
Table 2: Running Time (ms) on IrisCode and FVC2004.
Table 3: Communication Cost
FVC2004.
(KB) on IrisCode and
IrisCode
FVC2004
Case 1 Case 2 Case 3 Case 4 DB1 DB2 DB3 DB4
IrisCode
FVC2004
ğ‘š/ğ‘›
PubGen
Enc
Dec
16
54
101
71
32
55
110
79
64
56
111
85
128
58
110
116
95
29
151
315
91
28
148
293
138
43
221
598
150
45
232
631
Case 1 Case 2 Case 3 Case 4 DB1 DB2 DB3 DB4
ğ‘š/ğ‘›
ğ‘ğ‘˜
ğ‘
16
0.813
0.844
32
3.094
3.125
64
12.156
12.188
128
48.281
48.313
95
2.969
2.672
91
2.844
2.566
138
4.313
3.867
150
4.688
4.219
For asynchronous BAKE, the security proof is identical to syn-
chronous BAKE except for the Session sid0, which is reduced to
the security of AFEM.
6 EVALUATION
We show the asymptotic comparison with the state-of-the-art solu-
tions and the experimental results on our implementation.
6.1 Asymptotic Comparison
The asymptotic comparison with the state-of-the-art solutions is
shown in Table 1, where our BAKE protocol for biometric vector is
denoted as BAKE-1 and the one for biometric vector set is denoted as
BAKE-2. Note that fPAKE [19] is a symmetric primitive, which gives
biometric characteristics away to the receiver and thus dissatisfies
the design goal of biometric privacy, while fuzzy aPAKE [21] is an
asymmetric primitive that has similar goals to BAKE.
BAKE-1, fPAKE (instantiated as in [19]), and fuzzy aPAKE (in-
stantiated as suggested in [21]) are designed for an (cid:6)ğ‘›-bit string,
while BAKE-2 is designed for a set of cardinal ğ‘›. The computation
complexities of fPAKE-2 and fuzzy aPAKE-2 heavily rely on the un-
derlying PAKE and aPAKE solutions. Therefore, in all the solutions
for an(cid:6)ğ‘›-bit string, BAKE-1 is the most efficient one in terms of the
computation complexity. Moreover, among these solutions, only
BAKE-1 and BAKE-2 are one-round protocols that are suitable for
the asynchronous secure messaging setting.
6.2 Experiments
Implementation. To measure the performance of our BAKE
6.2.1
protocols, we implemented a prototype in Python using a laptop
computer, with the Intel Core i5-8300H CPU @ 2.30 GHz and 8 GB
RAM. The group in both solutions is implemented with the elliptic
curve Curve25519. BAKE-1 is implemented with the random linear
code provided in Fuller et al. [24] and BAKE-2 is instantiated with
Feldmanâ€™s secret sharing [23]. To ensure the biometric keys from
the same user are considered close, and the ones from different