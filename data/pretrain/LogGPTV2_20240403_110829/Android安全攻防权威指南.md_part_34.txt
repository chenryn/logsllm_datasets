bcdDev1ce
2.32
iManufacturer
2 HTC
iProduct
3 Android Phone
[-..]
bNunConfigurations
Configuration Descriptor:
1
[...1
bleumInterfaces
[-..】
3
Interface Descriptor:
[- .. ]
bNumBndpointe
bInterfaceClass
255 Vendor Specific Clas8
2
bInterfaceSubClass
66
bInterfaceProtocol
1
iInterface
Endpoint Descriptor 1
bLength
7
bDescriptorType
0x83
5
bEndpointAddress
NI C d8
bmAttributes
2
Transfer Type
Bu1k
Synch Type
None
Usage Type
Data
[- . . ]
Endpoint Descriptor:
bLength
bDescriptorType
bEndpointAddress
0x0
5
EP 3 0UT
bnAttributes
Transfer Type
2
Bulk
Synch Type
None
Usage Type
Data
[. ..]
---
## Page 152
136
第5章理解Android的攻击面
可以使用libusb与单一端点进行通信，而 libusb为许多高级编程语言（如 Python和 Ruby）
都提供了支持。
Android设备在一个USB接口上同时支持多种功能。这一支持机制被称为“Multifunction
Composite Gadget”，而背后的软件被称为“Gadget框架”。在一台设备上，你经常可以从init配
置文件中找到关于支持USB模式的更多信息，例如Nexus4有一个/init.mako.usb.rc文件，该文件
详细列出了所有可能的模式组合以及相关的生产厂商和产品ID。以下是默认模式的条目。
on property:sys .usb. config=mtp
stop adbd
vrite /sys/class/android_usb/androido/idVendor 18D1
vrite /sya/class/android_usb/androido/enable 0
vrite /ays/class/android_usb/androld0/LdProduct 4EE1
write /8y8/c1as8/android_u8b/android0/bDeviceClas8 0
write /sys/class/android_usb/android0/bDeviceSubClass 0
write /sys/class/android_usb/androido/functions ntp
write /ays/class/android_usb/androido/bDeviceProtoco1 0
write /sys/class/android_usb/androLd0/enable 1
setprop sys,usb.state $(sys.usb.config)
上述片段告知 init进程在某个进程将sys.usb.config属性设置为mtp时如何响应。除了
停止ADB守护进程外，init进程还需要通过/sys/class/android_usb重新配置Gadget框架。
另外，可以在AOSP代码仓库中找到Android框架如何管理USB设备的信息。以下片段显
示了在frameworks/base项目中Android支持的不同模式。
dev:~/android/source/frameworke/bases git grep UsB_FuNcTIoN_
core/Java/android/hardvare/usb/UsbManager- {ava:57:
▪(91ink
#USB_FUNCTION_MASS_STORAG&) boolean extra indicating whether the
core/Java/android/hardrare/usb/UsbManager- Java:59 :
•  {01ink
USB_FUNcTIoN_ADB) boolean extra indicating whether the
core/java/android/hardvare/usb/UsbManager -Java:61:
▪ (91ink
#USB_FUNCTION_RNDIs) boolean extra indicating whether the
core/ java/android/hardware/usb/UsbKanager . Java:63 :
*  (e1ink
USB_PUNCTIoN_MrP) boolean extra indicating whether the
core/ java/android/hardvare/usb/UsbManager - Java:65 1
▪  (91ink
#USB_FUNCTIoN_PTP) boolean extra indicating whether the
core/ java/android/hardware/usb/UsbManager - Java:67 :
*  (01ink
IUSB_FUNCTIoN_PTP) boolean extra indicating whether the
core/java/android/hardvare/usb/UsbManager - Java:69 :
▪(91ink
#USB_FUNCrIoN_AUDIo_soURCE) boolean extra indicating whether the
对在USB上暴露的攻击面进行深人挖掘，取决于不同接口所支持的具体功能与协议。这超
出了本章的范围，第6章中将深人介绍其中的一个接口：媒体传输协议（MTP）。
2. ADB
用于开发的Android设备通常启用了USB调试。这会启动ADB守护进程，后者允许在Android
设备上以特殊权限运行命令。在许多设备上，特别是运行Android4.2.2之前版本的设备，访间ADB
shell并不需要任何认证。甚至，软件版本号为1.27.531.11的T-MobileHTCOne手机默认暴露了无
需认证的ADB，而且并不允许关闭它。可以想象，获取设备的这种访问可以轻易达成一些有趣的
---
## Page 153
5.8小结137
攻击。
安全研究人员Kyle Osbom、Robert Rowley和Michael Muller演示了许多种利用设备ADB访
问的攻击方法。RobertRowley在几个会议上展示过JuiceJacking攻击，在这些攻击中，攻击者可
以创建出手机充电站，在目标手机连接USB进行充电时，可以隐蔽地下载目标手机上的数据。
或者在目标手机中安装恶意软件。Rowley的公共充电站只是为了引起公众对这些威胁的重视，
面一个恶意攻击者就不会这么仁慈了。KyleOsborm，以及后来的MichaelMuller，都开发了使用
ADB来下载目标数据的工具。KyleOsbom的工具特别设计来在攻击者的Android设备上运行，
实施“物理隐蔽强迫”攻击。在这种攻击场景中，攻击者在目标不注意的时候，将攻击者设备连
接到目标设备上，从中窃取最为敏感的数据。整个过程通常只需要很短的时间，这让这种攻击异
常高效。值得庆幸的是，Android的后期版本中默认对ADB增加了认证。这显著地缓解了这种类
型的攻击，但并没有完全消除ADB攻击面。
5.6.3其他物理攻击面
5
尽管USB是Android设备上最普遍存在的物理攻击面，但它并不是唯一的一个。其他物理
攻击面包括手机SIM卡、SD卡、HDMI、暴露的测试点和对接连接器等。Android系统中通过各
种不同类型的软件（从内核驱动到Android框架层API）来提供对所有这些接口的支持。探索这
些接口之下的攻击面超出了本章的范围，留给感兴趣的读者去练习。
5.7第三方修改
第1章介绍过，许多参与生产Android设备的实体会修改操作系统的不同组成部分。比如，
OEM倾向于在他们的整合过程中对系统进行大量的修改。OEM进行的修改已经不限于某个区域，
而是倾向于深度定制整个系统。例如，许多OEM会在他们的版本中捆绑一些特别的应用，如提
高效率的工具。一些OEM甚至将他们的特性实现在Android框架层中，并在系统中的各个位置
使用。所有这些第三方修改都可能会扩大设备的攻击面，而这种情况确实经常发生。
确定这些修改的范围和本质是一个非常困难的过程，而且绝大部分都需要手工分析。一般需
要将待分析的设备与Nexus设备进行对比。正如在第2章所提到的，大多数设备有着许多原生
Android设备中没有的运行进程，通过比较两个设备的ps命令输出和文件系统内容，可以展示
出许多差异。init进程的配置文件在这里很有帮助。审查对Android框架层的修改则需要处理
Dalvik代码的专业工具。定位到这些差异后，发现由这些软件引入的额外攻击面是相当频琐的工
作，通常需要花许多个小时来进行逆向工程与分析。
5.8小结
本章探索了Android设备可能被攻击的所有不同途径，讨论了如何根据可应用的攻击向量和
攻击面的不同属性对研究工作进行优先级排序。
---
## Page 154
138第5章理解Android的攻击面
通过根据访问复杂性将Android的攻击面分成4个高层分类，本章分别深人到每种攻击面的
底层细节中，涉及了不同类型的相邻条件对可用攻击方法的影响。
本章也讨论了一些已知的攻击方法，并介绍了一些可用来进一步探索Android攻击面的工具
和技术。特别是，你学到了如何识别Android设备上暴露的端点，如网络服务、本地IPC功能和
USB接口等。
由于Android代码规模庞大，本章不可能详尽地分析Android的整个攻击面，因此我们鼓励
你应用并扩展本章展示的技术方法进一步探索。
下一章将对本章中提及的一些概念进行扩展，并进一步探索几个特定的攻击面，还将介绍如
何利用模棚测试（fuzzing）方法来发现安全漏洞。
---
## Page 155
第6章
使用模糊测试来挖掘漏洞
浦派
模糊测试（fuzztesting），或称fuzzing，是一种通过构造畸形输人，来测试软件输入验证的
方法。本章将就模糊测试展开详细讨论。本章会介绍模期测试的起源，并解释各种相关任务的细
微差别。模棚测试包含目标识别、输人构造、系统自动化和结果监控等步骤。最后，本章会围绕
本书写作时测试的三个模测试工具，来分别阐述它们各自不同的方法、挑战和考虑因素。这些
例子会向你展示使用fuzzing技术来挖掘漏洞是多么容易。读完本章后，相信你一定会很好地理
解模棚测试，并使用这一技术来找到隐藏在Android系统中的漏洞。
6.1模糊测试的背景
模糊测试拥有很长的历史，并且被证明能够有效地找到漏润。这一技术最初是由威斯康星大
学麦迪逊分校的BartonMiller教授在1988年提出，当时仅仅是作为一个课程项目来测试各种
UNIX系统工具的错误。而在现代信息安全领域中，模测试已经成为安全专家和开发者审计软
件输入验证的方法。事实上，已经有一些杰出的安全研究人员就这一主题写过专著。这一简单的
技术已经帮助人们发现了许许多多的bug，其中相当一部分是安全漏洞。
模糊测试的基本前提是使用自动化的方法测试尽可能多的可达程序路径。处理大量不同的输
入会触发分支条件的计算，每次分支决策可能会导致软件执行包含错误或无效假设的代码。因此
在模测试中，到达更多的执行路径意味着更有可能找到bug。
模棚测试能够在安全研究社区流行有很多原因。模病测试最吸引人的一点包许是其所其有的
自动化这个本质特点。研究人员只要开发出一个模期测试工具就能使其长期运行，而自已可以去
做其他工作，如审计或逆向工程等。此外，开发一个简单的模棚测试工具只需要很少的时间，尤
其是相比人工审计二进制或源代码而言。一些模糊测试框架进一步减少了研究人员所需的的精力
投人。而且，使用模糊测试找到的bug数量远超人工审计。所有这些优势都预示着模棚测试将会
长期存在。
尽管有如此多的优势，模糊测试也并非完美。首先、它只能找到缺陷，而找到的缺陷是否属
于安全问题还需要研究人员进一步分析，关于这个问题将在第7章详细介绍。其次，模糊测试也
有局限。考虑使用模翻测试来测试16字节的输人，相比其他文件格式来说，这算是很小的输人
了。因为每个字节有255种可能值，所以整个输人集合包含319626579315078487616775634
---
## Page 156