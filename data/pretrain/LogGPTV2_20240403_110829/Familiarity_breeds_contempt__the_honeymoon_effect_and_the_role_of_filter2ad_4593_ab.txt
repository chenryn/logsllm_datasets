and so on.
To ”normalize” the length of the honeymoon for these
factors to enable meaningful comparisons between diﬀerent
software packages, the honeymoon ratio – the ratio of the
time between release and the discovery of the ﬁrst exploit
and the time between the discovery of the ﬁrst and the sec-
ond – may be more revealing, since time to the second vul-
nerability discovery occurs in exactly the same software.
The median number of days in the honeymoon period
across all 700 releases in our dataset was 110. The median
honeymoon ratio across all releases is 1.54.
The honeymoon ratio remained positive in virtually all
software packages and types. The eﬀect is weaker, but also
occurred, between the primal and second and second and
third reported vulnerabilities, depending on the particular
software package.
Figure 4 shows the median honeymoon ratio (and the
median ratios for the intervals between the second, third
and fourth vulnerabilities) for each operating system in the
dataset. Figure 5 shows the median honeymoon ratio of
servers, and Figure 6 shows end-user applications.
3.3 Open vs. Closed Source
The honeymoon eﬀect is strong in both open- and closed-
source software, but it manifests itself somewhat diﬀerently.
Of the 38 software systems we analyzed, 13 are open-
source and 25 are closed-source. But of the 700 software
releases in our dataset 171 were for closed-source systems
and 508 were for open source. Open-source packages in our
dataset issued new release versions at a much more rapid
rate than their closed source counterparts.
Table 2: Median Honeymoon Ratio for Open and
Closed Source Code
Honeymoon Days Ratios
Type
Open Source
Closed Source
115
98
1.23
1.48
Yet in spite of its more rapid pace of new releases, open
source software releases enjoyed a signiﬁcantly longer me-
dian honeymoon before the ﬁrst publicly exploitable vulner-
ability was discovered: 115 days, vs. 98 days for closed-
source releases.(see Table 2)
The median honeymoon ratio, however, is shorter in open-
source than in closed. The median ratio for all open-source
releases was 1.23, but for closed source it was 1.48. Figure 7
shows the median honeymoon ratios for various open-source
systems, and Figure 8 shows the median ratios for closed-
source systems.
254
Medians of Ratios of Primal to Subsequent for Operating Systems
Days to Zero:Days to Second
Days to Second:Days to Third
Days to Third:Days to Fourth
 100
 10
 1
 0.1
0.01
 100
 10
 1
 0.1
 0.01
F
r
e
e
O
S
X
B
S
D
r
e
d
s
ola
h
at
ris
N
T
w
in
9
8
W
W
in
2
in
2
X
P
0
0
0
0
0
0
P
r
o
S
e
r
v
e
s
2
0
0
3
Figure 4: Honeymoon ratios of p0/p0+1, p0+1/p0+2 and
p0+2/p0+3 for major operating systems. (Log scale.
Note that a ﬁgure over 1.0 indicates a positive hon-
eymoon).
Medians of Ratios of Primal to Subsequent for Server Applications
Days to Zero:Days to Second
Days to Second:Days to Third
Days to Third:Days to Fourth
 100
 10
 1
 0.1
 0.01
A
A
A
R
O
P
P
W
ste
Bin
d
Fir
p
a
p
a
c
h
e
c
h
http
eto
m
ris
k
efo
x
s
y
n
c
p
e
h
p
nld
a
p
s
e
r
v
c
at
e
r
in
W
o
stg
r
e
s
ql
e
b
S
e
r
v
e
r
2
0
0
Figure 5: Honeymoon ratio of p0/p0+1, p0+1/p0+2 and
p0+2/p0+3 for common server applications
255
Medians of Ratios of Primal to Subsequent for User Applications
Days to Zero:Days to Second
Days to Second:Days to Third
Days to Third:Days to Fourth
Fir
R
s
y
n
c
efo
x
S
a
m
b
a
ie i
m
r
e
a
d
v
m
w
e
r
a
r
e
s
afa
ri
a
g
e
m
q
uic
kti
m
e
W
in
d
o
w
a
gic
k
w
o
r
k
statio
n
Figure 6: Honeymoon ratios of p0/p0+1, p0+1/p0+2 and
p0+2/p0+3 for common user applications
The longer honeymoon period with a shorter honeymoon
ratio for open-source software suggests that it not only takes
longer for attackers to ﬁnd the initial bugs in open-source
software, but that the rate at which they ”climb the learn-
ing curve” does not accelerate as much over time as it does
in closed-source systems. This may be a surprising result,
given that attackers do not have the opportunity to study
the source code in closed-source systems, and suggests that
familiarity with the system is related to properties extrinsic
to the system and not simply access to source code.
4. THE HONEYMOON EFFECT AND PRI-
MAL VULNERABILITIES
To more fully understand the factors responsible for the
honeymoon eﬀect, we examined the attributes of a particular
set of primal vulnerabilities.
In this section we compare
the honeymoon periods of this set and show that primal
vulnerabilities are not a result of “low-hanging fruit”, and
that other extrinsic properties must apply.
It is well known that as complex software evolves from one
version to the next, new features are added, old ones dep-
recated and changes are made, but throughout its evolution
much of the standard code base of a piece of software remains
the same. One reason for this is to maintain backward com-
patibility, but an even more prevalent reason is that code
re-use is a primary principle of software engineering [18, 5].
In Milk or Wine [25] Ozment et al measured the portion
of legacy code in several versions of OpenBSD and found
that 61% of legacy (their term is ’foundational’) code was
still present 15 releases (and 7.5 years) later. This legacy
code accounted for 62% of the total vulnerabilities found.
While it is not possible to measure the amounts of legacy
code from version to version in closed source products as
it is for open source, it is well known that the major ven-
Medians of Ratios of Primal to Subsequent for Open Source Code
Days to Zero:Days to Second
Days to Second:Days to Third
Days to Third:Days to Fourth
 100
 10
 1
 0.1
 0.01
dors strongly encourage code re-use among their collaborat-
ing developers [19], and more importantly, it is possible to
measure the numbers of legacy vulnerabilities. By compar-
ing the disclosure date of a vulnerability with the release
dates and product version aﬀected, it is possible to deter-
mine which vulnerabilities discovered in the current release
result from earlier versions. For example, if a vulnerability
V aﬀects versions (k,...N) (0<k<N) of a product, but not
versions (1,...,k-1) and was disclosed after the release date
of version N, we know that the vulnerability was introduced
into the product with version k, and that it stayed hidden
until its discovery after the release of version N. We call
these regressive vulnerabilities as they are those vulnerabil-
ities which are not found through normal regression testing
and may lie dormant through more than one version re-
lease(sometimes for years).1 For the purposes of this paper,
we deﬁne a regressive vulnerability as a primal vulnerability
that was discovered to aﬀect not only version N in which
it was found, but also aﬀect one or more earlier versions (
versions N-1, N-2,...,1.0)
R
A
A
A
R
O
P
P
S
F
r
e
e
e
d
B
S
h
at
D
ste
Bin
Fir
d
p
p
a
c
h
e
a
c
h
eto
http
ris
k