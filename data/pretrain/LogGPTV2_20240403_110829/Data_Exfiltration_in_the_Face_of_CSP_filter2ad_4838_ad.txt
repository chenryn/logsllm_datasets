R
U
(cid:3) (cid:4) (cid:4)
• — (cid:4) (cid:4)
— (cid:4) (cid:3)
(cid:3) (cid:4) (cid:3)
— (cid:4) (cid:4)
(cid:3) (cid:4) (cid:4)
(cid:3) (cid:4) (cid:4)
— (cid:4) (cid:4)
• — (cid:4) (cid:4)
— (cid:4) (cid:4)
(cid:3) (cid:3) (cid:3)
• — (cid:4) (cid:4)
Table 1: Overview of tested browsers, indicating detected information leaks through DNS or HTTP requests while subject to
a strict CSP. OS abbreviations: Apple Mac OSX 10.10.3 Yosemite (OSX), iPhone 6 emulator (IP6), Microsoft Windows 8.1
(W81), Windows 10 tech preview (W10), Windows Phone 8.1 emulator (WP8), Android 5.0.2 on Motorola Moto 2 (MG2),
Android 5.0.2 emulator (AL5). “•”: leak detected. “◦”: leak detected in some cases. “(cid:4)”: vulnerable. “(cid:3)”: vulnerable in some
cases. “—”: not vulnerable.
complementary conditions under which they will leak in-
formation. For parent web pages served over HTTPS, an
attacker can use rel=prefetch to leak information through
DNS prefetching and resource prefetching via Edge. For
parent web pages served over HTTP, an attacker can use
rel=dns-prefetch to leak information through DNS prefetch-
ing, but only if the  element can be injected in the
original HTML code, instead of being added through JavaScript,
which is in accordance with this scenario.
Safari Mobile can only be used to leak information through
automatic DNS prefetching, which requires that DNS prefetch-
ing is not explicitly disabled for parent web pages served over
HTTP, and explicitly enabled for parent web pages served
over HTTPS.
JavaScript injection The results of the JavaScript injec-
tion scenario are similar to the HTML injection scenario,
except for two cases. Since an attacker cannot inject HTML
code in this scenario, but can only execute JavaScript, Edge
and Firefox are only vulnerable under certain conditions.
Edge will not leak information through rel=dns-prefetch
if it is added by JavaScript. Because of this, an attacker in
this scenario can only leak information through rel=prefetch,
which in turn will only work when the parent web page is
served over HTTPS.
Firefox leaks information through several  elements
injected as static HTML and also when written into the page
by JavaScript using document.write(). However, Firefox
will not leak information through these elements when they
are added through addChild(). This is a limitation that
may hinder an attacker, if the injected JavaScript is limited
to using only addChild().
6. LARGE-SCALE STUDY OF THE WEB
Automatic and forced DNS prefetching implementations
are about seven years old now, available since the ﬁrst re-
lease of Chrome and Firefox since version 3.5. Resource
prefetching and CSP are younger than DNS prefetching.
In this study, we set out to measure how widespread these
technologies are used on the Web and in what context they
are applied. We determine whether their usage is related to a
website’s popularity or function. In addition, we investigate
whether web developers are using strong CSP policies and
how they deal with automatic DNS prefetching in that case.
6.1 Experiment setup
For this experiment, we performed a study of the top
10,000 most popular domains according to Alexa. For each
of these Alexa domains, the Bing search engine was con-
sulted to retrieve the top 100 web pages in that domain. In
total, Bing returned us a data set with 897,777 URLs.
We modiﬁed PhantomJS [6] in such a way so that any
interaction with automatic DNS prefetching,  ele-
ments and CSP is recorded.
In particular, we are inter-
ested in knowing whether a web page will explicitly enable
or disable DNS prefetching through the X-DNS-Prefetch-
Control header and whether it will do this through a header
in the HTTP response, or add a  ele-
ment to achieve the same eﬀect. Similarly, we are interested
in knowing whether a web page will make use of CSP using
the Content-Security-Policy header or one of its precur-
sors. Finally, we are also interested in a web page’s usage of
 elements and the relationship types they employ.
We visited the URLs in our data set using the modi-
ﬁed PhantomJS, resulting in the successful visit of 879,407
URLs.
6.2 Results
Automatic DNS prefetching statistics Of the 879,407
successfully visited web pages, 804,202 or 91.4% were served
over HTTP and the remaining 75,205 or 8.6% over HTTPS.
860HTTP
header
0
672
0
672
792,537
meta
8,883
2,021
89
10,993
HTTPS
header meta
725
13
0
738
1
17
0
18
74,449
Total
9,609
2,723
89
12,421
866,986
On
Oﬀ
Both
Changed
Unchanged
Table 2: Statistics on the usage of the X-DNS-Prefetch-
Control HTTP header for automatic DNS prefetching.
By default, web pages on HTTP have automatic DNS
prefetching enabled and we observed that 792,537 or 98.5%
of HTTP web pages do not change this default behavior.
Of the remaining 11,665 HTTP web pages, 8,883 (76.2%)
enable DNS prefetching explicitly, 2,693 (23.1%) explicitly
disable it and 89 (0.8%) both enable and disable it. The
majority of the enabling or disabling happens through  elements (10,993 web pages or 94.2%), instead
of HTTP headers (672 web pages or 5.8%). Those web
pages that use HTTP headers, only use it to switch oﬀ DNS
prefetching and not re-enable the default by switching it on.
On web pages served over HTTPS, DNS prefetching is
disabled by default. Of the 75,205 web pages served over
HTTPS, 74,449 or 99.0% do not change this default behav-
ior. Of the 756 web pages that change the default, 18 or
2.4% use HTTP header and 738 or 97.6% use  elements.
Resource prefetching statistics The “dns-prefetch” re-
lationship is the sixth most occurring relationship type en-
countered in our data set after “stylesheet”, “shortcut”, “canon-
ical”, “alternate” and “icon”.
relationship
dns-prefetch
next
prev
prefetch
prerender
subresource
preconnect
preload
URLs
domains
164,636
57,866
32,546
2,445
1,535
1,036
94
2
(18.7%)
(6.6%)
(3.7%)
(0.3%)
(0.2%)
(0.1%)
(0.0%)
(0.0%)
4,230
2,587
1,495
92
63
24
4
1
(42.3%)
(25.9%)
(14.9%)
(0.9%)
(0.6%)
(0.2%)
(0.0%)
(0.0%)
Table 3: Statistics on the usage of selected  element
relationship types. Percentages are relative to the entire
set of successfully retrieved URLs and the total amount of
domains respectively.
As shown in Table 3, “dns-prefetch” accounts for 164,636
or 18.7% of the URLs in the data set, encompassing 42.3%
of the domains of the Alexa top 10,000.
Content-Security-Policy statistics Of the 879,407 URLs
that our browser visited successfully, 31,364 activated the
Content-Security-Policy processing code of which 27,966 on
HTTP web pages and 3,398 on HTTPS web pages. Table 4
indicates these results in more detail, where “leaky” indi-
cates a CSP that allows a request to an attacker-controlled
domain and “good” indicates one that does not allow such
leak.
Among the HTTP web pages that used CSP, 894 or 3.2%
had a “good” policy that should eﬀectively stop an attacker
from fetching resources from an attacker-controlled domain.
CSP
leaky
good
none
leaky
DNS
pref.
yes
no
yes
no
yes
no
yes
no
yes
no
yes
no
URLs
Domains
P
T
T
H
754
18
54
0
9,563
137
2
127
0
34
35
3,065
26,697
375
894
0
773,714
2,318
99
2,871
0
428
627
71,152
(3.0%)
(0.0%)
(0.1%)
(0.0%)
(88.0%)
(0.3%)
(0.0%)
(0.3%)
(0.0%)
(0.0%)
(0.1%)
(8.1%)
(7.5%)
(0.2%)
(0.5%)
(0.0%)
(95.6%)
(1.4%)
(0.0%)
(1.3%)
(0.0%)
(0.3%)
(0.4%)
(30.6%)
Table 4: Statistics on the usage of CSP policies in com-
bination with how DNS prefetching is conﬁgured. A good
CSP disallows any request to an attacker-controlled domain,
while a leaky CSP does not. Percentages are relative to
the entire set of successfully retrieved URLs and the total
amount of domains respectively.
good
none
S
P
T
T
H
None of these web pages explicitly disabled automatic DNS
prefetching, so that it was enabled by default.
Of the web pages with CSP served over HTTPS, 428
or 12.6% had an eﬀective policy in place to stop informa-
tion leaks to an attacker-controlled domain. Similar to the
HTTP web pages, none of these HTTPS web pages explicitly
enabled the automatic DNS prefetching, but instead relied
on the default behavior, implicitly disabling automatic DNS
prefetching.
6.3 Discussion
We could not ﬁnd any meaningful correlation between the
usage of DNS prefetching, resource prefetching and CSP on
a certain domain with either the domain’s Alexa ranking
or Trend Micro’s Site Safety categorization of the domain.
This indicates that performance and security improvements
do not only beneﬁt the most popular web domains, but that
all web developers use them equally.
The results of our study show that 42.3% of the top 10,000
Alexa domains use forced DNS prefetching through 
elements with the “dns-prefetch” relationship. However, the
default behavior for automatic DNS prefetching is mostly
left untouched by the web developers.
In our study of CSP, most pages using CSP do not have
a strict policy in place that would prevent conventional (i.e.
through regular HTTP requests) information leaking through
other elements. Only 428 web pages have a strict policy in
place, and also have DNS prefetching disabled.
To conclude, web developers seem to be aware of the ben-
eﬁts that DNS and resource prefetching can oﬀer for perfor-
mance, although not of the risks it can pose to privacy and
security.
7. MEASURES DISCUSSION
Data exﬁltration prevention in web browsers is an non-
trivial but important security goal. CSP prevents several
data exﬁltration attacks such as the attack in Listing 1,
but is known to not prevent in variety of other cases. Za-
lewski [51], for instance, gives examples of sophisticated at-
tacks to leak data. Many of those, such as through dangling
861markup injection, rerouting of existing forms or abusing plu-
gins, can be prevented through a sane CSP. However, Za-
lewski mentions further attack vectors, namely through page
navigation, the window.name DOM property, and timing.
In the following, we shortly explain some of these attack
vectors to not only raise awareness but also to stimulate de-
velopment of practical protection mechanisms to limit their
eﬀects in future. Additionally, we also make suggestions for
tackling the concrete problem of data exﬁltration through
DNS prefetching based on our case study.
7.1 Measures on data exﬁltration
Page navigation Instead of trying to silently leak data
from within a web page, an attacker can also simply navigate
the browser to an attacker-controlled page. If the navigation
URL contains sensitive information it is then leaked through
the page request itself. In the following JavaScript code, the
cookie of the current web page is sent as part of the page
request to evil.com.