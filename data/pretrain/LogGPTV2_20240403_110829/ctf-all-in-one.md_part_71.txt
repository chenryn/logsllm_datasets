大规模
类型的安全漏洞
运行系
统
检测
该类技术
运行
733
5.0 软件漏洞分析
授 系统 了解运行
权 认证测试通过了解运行 中授 系统的授
分析结
认 系统的授权、认证工作 权、 权认证工 Nessus,
果较为
证 流程来尝试规避运行系 认证 作，需要 WebScarab
准确
测 统的授权、认证机制 机制 较多的人
试 中潜 工参与分
在的 析工作
漏洞
检测
数据验证测试目的在于
运行
发现由于运行系统没有 技术比
数 系统
正确验证来自客户端或 较成
据 中授
外界的数据而产生的安 熟，可 分析结果
验 权、 MVS,
全漏洞。该类技术主要 用工具 误报率比
证 认证 AppScan
通过构造特定的输入以 较多， 较高
测 机制
检测是否可以触发运行 操作简
试 中潜
系统的某些特定类型安 单
在的
全漏洞
漏洞
检测
运行
数 系统 技术比
据 中在 较成
安 数据安全性验证旨在发 存储 熟，可 分析结果
全 现威胁运行系统内部数 和传 用工具 误报率比 WireShark
性 据自身安全性的漏洞 输数 较多， 较高
验 据时 操作简
证 潜在 单
的漏
洞
参考资料
《软件漏洞分析技术》
734
5.1 模糊测试
5.1 模糊测试
基本原理
方法实现
参考资料
基本原理
模糊测试（fuzzing）是一种通过向程序提供非预期的输入并监控输出中的异常来发
现软件中的故障的方法。
用于模糊测试的模糊测试器（fuzzer）分为两类：
一类是基于变异的模糊测试器，它通过对已有的数据样本进行变异来创建测试
用例
另一类是基于生成的模糊测试器，它为被测试系统使用的协议或文件格式建
模，基于模型生成输入并据此创建测试用例。
模糊测试流程
模糊测试通常包含下面几个基本阶段：
1. 确定测试目标：确定目标程序的性质、功能、运行条件和环境、编写程序的语
言、软件过去所发现的漏洞信息以及与外部进行交互的接口等
2. 确定输入向量：例如文件数据、网络数据和环境变量等。
3. 生成模糊测试数据：在确定输入向量之后设计要模糊测试的方法和测试数据生
成算法等
4. 执行模糊测试数据：自动完成向测试目标发送大量测试数据的过程，包括启动
目标进程、发送测试数据和打开文件等
5. 监视异常：监视目标程序是否产生异常，记录使程序产生异常的测试数据和异
常相关信息
6. 判定发现的漏洞是否可被利用：通过将产生异常的数据重新发送给目标程序，
跟踪异常产生前后程序相关的处理流程，分析异常产生的原因，从而判断是否
可利用
735
5.1 模糊测试
基本要求
要实现高效的模糊测试，通常需要满足下面几个方面的要求：
1. 可重现性：测试者必须能够知道使目标程序状态变化所对应的测试数据是什
么，如果不具备重现测试结果的能力，那么整个过程就失去了意义。实现可重
现性的一个方法是在发送测试数据的同时记录下测试数据和目标程序的状态
2. 可重用性：进行模块化开发，这样就不需要为一个新的目标程序重新开发一个
模糊测试器
3. 代码覆盖：指模糊测试器能够使目标程序达到或执行的所有代码及过程状态的
数量
4. 异常监视：能够精确地判定目标程序是否发生异常非常的关键
存在的问题
模糊测试中存在的问题：
1. 具有较强的盲目性：即使熟悉协议格式，依然没有解决测试用例路径重复的问
题，导致效率较低
2. 测试用例冗余度大：由于很多测试用例通过随机策略产生，导致会产生重复或
相似的测试用例
3. 对关联字段的针对性不强：大多数时候只是对多个元素进行数据的随机生成或
变异，缺乏对协议关联字段的针对性
方法实现
输入数据的关联分析
通常情况下，应用程序都会对输入的数据对象进行格式检查。通过分析输入到程序
的数据对象的结构以及其组成元素之间的依赖关系，构造符合格式要求的测试用例
从而绕过程序格式检查，是提高模糊测试成功率的重要步骤。
应用程序的输入数据通常都遵循一定的规范，并具有固定的结构。例如：网络数据
包通常遵守某种特定的网络协议规范，文件数据通常遵守特定的文件格式规范。输
入数据结构化分析就是对这些网络数据包或文件格式的结构进行分析，识别出特定
736
5.1 模糊测试
的可能引起应用程序解析错误的字段，有针对性地通过变异或生成的方式构建测试
用例。通常关注下面几种字段：表示长度的字段、表示偏移的字段、可能引起应用
程序执行不同逻辑的字段、可变长度的数据等。
应用程序所能处理的数据对象是非常复杂的。例如 MS Office 文件是一种基于对象
嵌入和链接方式存储的复合文件，不仅可以在文件中嵌入其他格式的文件，还可以
包含多种不同类型的元数据。这种复杂性导致在对其进行模糊测试的过程中产生的
绝大多数测试数据都不能被应用程序所接受。数据块关联模型是解决这一问题的有
效途径。该模型以数据块为基本元素，以数据块之间的关联性为纽带生成畸形测试
数据。其中，数据块是数据块关联模型的基础。通常一个数据对象可以分为几个数
据块，数据块之间的依赖关系称为数据关联。
数据块的划分通常遵循三个基本原则：
使数据块之间的关联性尽可能的小
将具有特定意义的数据划分为一个数据块
将一段连续且固定不变的数据划分为同一个数据块
数据块关联模型的划分：
关联方式
内关联：指同一数据对象内不同数据块之间的关联性。
长度关联：数据对象内某一个或几个数据块表示另一数据块的长度。
是文件格式、网络协议和ActiveX控件模糊测试中最常见的一种数据关
联方式。
外关联：指属于多个不同数据对象的多个不同数据块之间存在的关联性。
内容关联：某个数据对象的某个数据块表示另一个（或同一个）数据
对象的另一个数据块的值。在需要用户验证的网络协议应用中经常出
现。
关联强度
强关联：关联数据块的数量大于等于非关联数据块的数量。
弱关联：关联数据块的数量小于非关联数据块的数量。
评价标准
有效数据对象效率：构造的畸形数据对象个数与能够被应用程序所接受处
理的数据对象个数的比率。
测试用例集的构建方法
737
5.1 模糊测试
常见的构建方法有以下几种：
随机方法：简单地产生大量伪随机数据给目标程序。
强制性测试：模糊测试器从一个有效的协议或数据格式样本开始，持续不断地
打乱数据包或文件中的每一个字节、字、双字或字符串。
预先生成测试用例：对一个专门规约的研究，以理解所有被支持的数据格式和
每种数据格式可接受的取值范围，然后生成用于测试边界条件或迫使规约发生
违例的硬编码的数据包或文件。
遗传算法：将测试用例的生成过程转化为一个利用遗传算法进行数值优化的问
题，算法的搜索空间即为待测软件的输入域，其中最优解即为满足测试目标的
测试用例。首先，使用初始数据和种子生成数据，然后对数据进行测试和评
估，并监控测试过程，如果满足测试终止的条件，就输出测试结果，否则通过
选择、杂交、变异生成新的数据。
错误注入与模糊启发式
错误注入：指按照特定的故障模型，用人为的、有意识的方式产生故障，
并施加特定故障于待测软件系统中，以加速该系统错误和失效的发生。
通常可注入的错误类型：内存错误、处理器错误、通信错误、进程错
误、消息错误、网络错误、程序代码错误等
模糊启发式：将模糊字串或模糊数值列表中包含的特定潜在危险值称作模
糊启发式。
边界整型值：整型值上溢、下溢、符号溢出等。
字符串重复：堆栈溢出等。
字段分隔符：将非字母数字字符如空格、制表符等随机地包含到模糊
测试字符串中。
格式化字符串：最好选择 "%s"、"%n" 等包含到字符串中。
字符转换和翻译：特别关注对扩展字符的处理。
目录遍历：在URL中附加 "../" 之类的符号将导致攻击者访问未授权的
目录。
命令注入：向 "exec()"、"system()" 之类的 API 调用传递未经过滤的
用户数据。
测试异常分析
在程序动态分析过程中，相关信息的获取途径有下面几种：
通过程序的正常输出获取信息
通过静态代码插桩获取信息
738
5.1 模糊测试
通过动态二进制插桩获取信息
通过虚拟机获取信息
通过调试接口或者调试器获取信息
模糊测试框架
模糊测试框架是一个通用的模糊器，可以对不同类型的目标进行模糊测试，它将一
些单调的工作抽象化，并且将这些工作减少到最低程度。通常模糊测试框架都包含
以下几个部分：
模糊测试数据生成模块
原始数据生成模块：可以直接读取一些手工构造的正常数据，也可以根据
结构定义来自动生成正常的测试数据
畸形数据生成模块：在原始数据的基础上做一些修改和变形，从而生成最
终的畸形数据
动态调试模块：利用操作系统提供的调试接口来实现动态调试功能，以捕获被
调试程序产生的异常信息
执行监控模块：在动态调试模块的基础上，在被调试程序运行过程中，实现对
被调试程序执行状态的监控，从而决定什么时候终止被调试程序的运行
自动脚本模块：在执行监控模块的基础上，提供更复杂的监控功能
异常过滤模块：在动态调试模块的基础上，对异常产生的结果实时过滤
测试结果管理模块：测试结果数据库中除了异常信息之外，产生异常的畸形数
据也会被保存。利用测试结果数据库，可以实现回归测试。
参考资料
Fuzzing
Awesome-Fuzzing
739
5.1.1 AFL fuzzer
5.1.1 AFL fuzzer
AFL 简介
安装
简单示例
AFL 简介
AFL 是一个强大的 Fuzzing 测试工具，由 lcamtuf 所开发。利用 AFL 在源码编译时
进行插桩（简称编译时插桩），可以自动产生测试用例来探索二进制程序内部新的
执行路径。与其他基于插桩技术的 fuzzer 相比，AFL 具有较低的性能消耗，各种高
效的模糊测试策略和最小化技巧，它无需很多复杂的配置即可处理现实中的复杂程
序。另外 AFL 也支持直接对没有源码的二进制程序进行黑盒测试，但需要 QEMU
的支持。
安装
$ wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz
$ tar zxvf afl-latest.tgz
$ cd afl-2.52b
$ make
$ sudo make install
简单示例
参考资料
740
5.1.2 libFuzzer
5.1.2 libFuzzer
参考资料
参考资料
libFuzzer – a library for coverage-guided fuzz testing.
741
5.2 动态二进制插桩
5.2 动态二进制插桩
742
5.2.1 Pin
5.2.1 Pin 动态二进制插桩
插桩技术
Pin 简介
Pin 的基本用法
Pintool 示例分析
Pintool 编写
Pin 在 CTF 中的应用
扩展：Triton
插桩技术
插桩技术是将额外的代码注入程序中以收集运行时的信息，可分为两种：
源代码插桩（Source Code Instrumentation(SCI)）：额外代码注入到程序源代码
中。
示例：
// 原始程序
void sci() {
int num = 0;
for (int i=0; i<100; ++i) {
num += 1;
if (i == 50) {
break;
}
}
printf("%d", num);
}
743
5.2.1 Pin
// 插桩后的程序
char inst[5];
void sci() {
int num = 0;
inst[0] = 1;
for (int i=0; i<100; ++i) {
num += 1;
inst[1] = 1;
if (i == 50) {
inst[2] = 1;
break;
}
inst[3] = 1;
}
printf("%d", num);
inst[4] = 1;
}
二进制插桩（Binary Instrumentation(BI)）：额外代码注入到二进制可执行文件
中。
静态二进制插桩：在程序执行前插入额外的代码和数据，生成一个永久改变的
可执行文件。
动态二进制插桩：在程序运行时实时地插入额外代码和数据，对可执行文件没
有任何永久改变。
以上面的函数 sci 生成的汇编为例：
原始汇编代码
744
5.2.1 Pin
sci:
pushl %ebp
movl %esp, %ebp