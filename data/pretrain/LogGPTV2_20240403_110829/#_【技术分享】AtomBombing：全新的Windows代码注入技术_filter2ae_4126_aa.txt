# 【技术分享】AtomBombing：全新的Windows代码注入技术
|
##### 译文声明
本文是翻译文章，文章来源：breakingmalware
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
**翻译：**[ **Ox9A82**
****](http://bobao.360.cn/member/contribute?uid=2676915949)
**稿费：250RMB（不服你也来投稿啊！）**
**投稿方式：发送邮件至linwei#360.cn，或登陆[
**网页版**](http://bobao.360.cn/contribute/index)在线投稿**
最近，我们发现了一种称为AtomBombin的新的代码注入技术，它利用了Windows的异步过程调用（简称APC）机制。目前，这种技术还不能够被防入侵的安全工具检测到。
代码注入作为一种强大的武器已经存在于黑客武器库中很多年了。有关代码注入的背景及其在APT攻击中的各种用法，请查看：
[http://blog.ensilo.com/atombombing-a-code-injection-that-bypasses-current-security-solutions](http://blog.ensilo.com/atombombing-a-code-injection-that-bypasses-current-security-solutions)
**概述**
我们开始窥探一下，看看攻击者如何努力找到一种安全厂商不知道的新方法，以实现绕过大多数的安全产品。
它还需要能够在不同的进程上工作，而不是只是能适应特定的进程。
在这里，我想向你介绍的就是AtomBombing – 一种全新的Windows代码注入技术。
AtomBombing需要以下三步来实现：
1.任意地址写任意值（Write-What-Where） – 能够将任意数据写入目标进程的地址空间中的任意位置。
2.执行 – 劫持目标进程的线程以执行在步骤1中写入的代码。
3.恢复 – 清理并且恢复执行在步骤2中被劫持的线程。
**AtomBombing 步骤1: 任意地址写任意值（Write-What-Where）**
我是在偶然之间发现这几个非常有趣的API函数的：
GlobalAddAtom – 向全局原子表中添加一个字符串，并返回一个唯一的值（一个原子）来标识字符串。
GlobalGetAtomName – 通过指定一个全局原子来检索它对应的字符串副本。
通过调用GlobalAddAtom，可以在全局原子表中存储一个空终止的缓冲区。并且此表可以被系统上的每个进程访问。然后可以通过调用GlobalGetAtomName来检索缓冲区。
GlobalGetAtomName函数接收一个指向输出缓冲区的指针，因此调用者可以选择将空终止缓冲区存储在哪里。
理论上，我可以通过调用GlobalAddAtom向全局原子表添加一个包含shellcode的缓冲区，然后以某种方式使目标进程调用GlobalGetAtomName，那么就可以将代码从我的进程复制到目标进程，而不需要调用WriteProcessMemory。
从我的当前进程中调用GlobalAddAtom是非常简单的，但是如何使目标进程调用GlobalGetAtomName呢？
可以使用线程异步过程调用（APC）来解决：
QueueUserApc()函数： 向指定线程的APC队列添加用户模式APC对象。
函数原型如下：
    DWORD WINAPI QueueUserAPC(
    _In_ PAPCFUNC  pfnAPC, 
    _In_ HANDLE    hThread, 
    _In_ ULONG_PTR dwData
    );
QueueUserApc函数的第一个参数是指向APC功能函数(APCProc)的指针，这个函数的函数原型如下：
    VOID CALLBACK APCProc(
      _In_ ULONG_PTR dwParam
    );
GlobalGetAtomName的原型是：
    UINT WINAPI GlobalGetAtomName(  
    _In_  ATOM   nAtom,  
    _Out_ LPTSTR lpBuffer,  
    _In_  int    nSize
    );
由于GlobalGetAtomName需要3个参数（而APCProc的定义只有1个参数），因此我们不能使用QueueUserApc来直接调用目标进程中的GlobalGetAtomName。
让我们来看看QueueUserApc的内部：
正如图示的一样，QueueUserApc内部使用未公开的NtQueueApcThread系统调用，来将APC添加到目标线程的APC队列。
有趣的是，NtQueueApcThread接受的APC函数的指针并不是调用者传递给QueueUserApc的原始APCProc函数指针。
相反，实际传递的函数指针是ntdll!RtlDispatchAPC，并且传递给QueueUserApc的原始APCProc函数是作为参数传递给ntdll！RtlDispatchAPC的。
再让我们来看看ntdll!RtlDispatchAPC：
它首先检查第三个参数是否有效，这意味着在分派APC之前需要激活ActivationContext。
如果需要激活ActivationContext：
函数ntdll!RtlDispatchAPC函数的执行流程如下：
1.传递的ActivationContext（当前在ESI中）将通过调用RtlActivateActivationContextUnsafeFast函数来激活。
2.将原来APCProc函数的参数（即传递给QueueUserApc的第三个参数）压到栈中。因为我们要调用原来的APCProc函数。
3.在分发APC之前，调用CFG（__guard_check_icall_fptr）以确保APC的目标是CFG有效的函数。（译注：CFG指的是控制流保护）
4.调用原始的APCProc，APC被成功调度。
一旦APCProc返回，ActivationContext会被激活：
另一方面，如果不需要激活ActivationContext：
那么代码会跳过所有ActivationContext相关的东西，并在调用CFG后立即调度APC。
这意味着什么？当调用QueueUserApc时，我们被迫传递一个只有一个参数的APCProc。但是，在内部QueueUserApc使用NtQueueApcThread来调用ntdll!RtlDispatchAPC，而它使用3个参数。
我们之前的目标是什么？是为了调用GlobalGetAtomName。
那它需要多少个参数呢？3个！
我们能够满足要求吗？ 能！
怎么样实现呢？ 通过NtQueueApcThread！
请参阅AtomBombing的GitHub中的main_ApcWriteProcessMemory。
**AtomBombing 步骤2：执行**
显然，我从来没指望能在我的目标进程中找到RWX(译注:指可读可写可执行，因为目前的保护机制使得一般可读写的内存不可执行。而可执行的内存不可写。)的代码段。我需要一种能在目标进程中持续分配RWX内存的方法，而且不需要在被注入进程的环境中调用VirtualAllocEx函数。遗憾的是，我找不到任何这样的函数，可以使我通过APC调用来分配可执行内存或者更改现有内存的保护标志。
我们到目前为止拥有了什么？一个任意地址写+想得到可执行内存的强烈欲望。我想了很久，发现很难克服这个障碍，但是马上我突然想到了。当DEP被发明时，它的创造者认为，“就像这样，数据不再是可执行的了，因此再也没有人能够利用漏洞了”。然而不幸的是，情况并非如此;
一种新的技术被开发出来，来专门实现绕过DEP：这就是ROP – 返回导向编程。
那么我们该如何使用ROP来巩固我们的优势，从而在目标进程中执行我们的shellcode呢？
我们可以将我们的代码复制到目标进程中的RW代码段（使用步骤1中的方法）。然后通过精心制作的ROP链来分配RWX内存，再把代码从RW代码区复制到新分配的RWX内存块中，最后跳转到RWX内存中执行它。
找到RW代码段并不难，对于这个概念证明，我决定使用在kernelbase的数据部分之后的未使用的空间。
请参阅AtomBombing的GitHub中的main_GetCodeCaveAddress。