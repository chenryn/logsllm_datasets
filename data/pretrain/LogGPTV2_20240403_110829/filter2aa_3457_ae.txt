7.4 Running Commands 
Beacon’s shell command will task a Beacon to execute a command via cmd.exe on the 
compromised host. When the command completes, Beacon will present the output to you.  
Use the run command to execute a command without cmd.exe. The run command will post 
output to you. The execute command runs a program in the background and does not capture 
output. 
www.cobaltstrike.com/
/
45/
Use the powershell command to execute a command with PowerShell on the compromised host. 
Use the powerpick command to execute PowerShell cmdlets without powershell.exe. This 
command relies on the Unmanaged PowerShell technique developed by Lee Christensen. The 
powershell and powerpick commands will use your current token.  
The psinject command will inject Unmanaged PowerShell into a specific process and run your 
cmdlet from that location.  
The powershell-import command will import a PowerShell script into Beacon. Future uses of 
the powershell, powerpick, and psinject commands will have cmdlets from the imported script 
available to them. Beacon will only hold one PowerShell script at a time. Import an empty file to 
clear the imported script from Beacon. 
The execute-assembly command will run a local .NET executable as a Beacon post-exploitation 
job. You may pass arguments to this assembly as if it were run from a Windows command-line 
interface. This command will also inherit your current token. 
If you want Beacon to execute commands from a specific directory, use the cd command in the 
Beacon console to switch the working directory of the Beacon’s process. The pwd command 
will tell you which directory you’re currently working from.  
The setenv command will set an environment variable. 
Beacon can execute Beacon Object Files without creating a new process. Beacon Object Files 
are compiled C programs, written to a specific convention, that run within a Beacon session. Use 
inline-execute [args] to execute a Beacon Object File with the specified arguments. More 
information Beacon Object Files is at:  
https://www.cobaltstrike.com/help-beacon-object-files 
7.5 Session Passing 
Cobalt Strike’s Beacon started out as a stable lifeline to keep access to a compromised host. 
From day one, Beacon’s primary purpose was to pass accesses to other Cobalt Strike listeners. 
Use the spawn command to spawn a session for a listener. The spawn command accepts an 
architecture (e.g., x86, x64) and a listener as its arguments. 
By default, the spawn command will spawn a session in rundll32.exe. An alert administrator 
may find it strange that rundll32.exe is periodically making connections to the internet. Find a 
better program (e.g., Internet Explorer) and use the spawnto command to state which program 
Beacon should spawn for its sessions.  
The spawnto command requires you to specify an architecture (x86 or x64) and a full path to a 
program to spawn, as needed. Type spawnto by itself and press enter to instruct Beacon to go 
back to its default behavior. 
www.cobaltstrike.com/
/
46/
Type inject followed by a process id and a listener name to inject a session into a specific 
process. Use ps to get a list of processes on the current system. Use inject [pid] x64 to inject a 
64-bit Beacon into an x64 process. 
The spawn and inject commands both inject a payload stage into memory. If the payload stage is 
an HTTP, HTTPS, or DNS Beacon and it can’t reach you—you will not see a session. If the 
payload stage is a bind TCP or SMB Beacon, these commands will automatically try to link to 
and assume control of these payloads. 
Use dllinject [pid] to inject a Reflective DLL into a process.  
Use the shinject [pid] [architecture] [/path/to/file.bin] command to inject shellcode, from a 
local file, into a process on target. Use shspawn [architecture] [/path/to/file.bin] to spawn the 
“spawn to” process and inject the specified shellcode file into that process. 
Use dllload [pid] [c:\path\to\file.dll] to load an on-disk DLL in another process. 
7.6 Alternate Parent Processes 
Use ppid [pid] to assign an alternate parent process for programs run by your Beacon session. 
This is a means to make your activity blend in with normal actions on the target. The current 
Beacon session must have rights to the alternate parent and it’s best if the alternate parent 
process exists in the same desktop session as your Beacon. Type ppid, with no arguments, to 
have Beacon launch processes with no spoofed parent.  
The runu command will execute a command with another process as the parent. This command 
will run with the rights and desktop session of its alternate parent process. The current Beacon 
session must have full rights to the alternate parent. The spawnu command will spawn a 
temporary process, as a child of a specified process, and inject a Beacon payload stage into it. 
The spawnto value controls which program is used as a temporary process. 
7.7 Spoof Process Arguments 
Each Beacon has an internal list of commands it should spoof arguments for. When Beacon runs 
a command that matches a list, Beacon: 
1. Starts the matched process in a suspended state (with the fake arguments) 
2. Updates the process memory with the real arguments 
3. Resumes the process 
The effect is that host instrumentation recording a process launch will see the fake arguments. 
This helps mask your real activity. 
Use argue [command] [fake arguments] to add a command to this internal list. The [command] 
portion may contain an environment variable. Use argue [command] to remove a command 
from this internal list. argue, by itself, lists the commands in this internal list. 
The process match logic is exact. If Beacon tries to launch “net.exe”, it will not match net, 
NET.EXE, or c:\windows\system32\net.exe from its internal list. It will only match net.exe. 
www.cobaltstrike.com/
/
47/
x86 Beacon can only spoof arguments in x86 child processes. Likewise, x64 Beacon can only 
spoof arguments in x64 child processes. 
The real arguments are written to the memory space that holds the fake arguments. If the real 
arguments are longer than the fake arguments, the command launch will fail. 
7.8 Blocking DLLs in Child Processes 
Use blockdlls start to ask Beacon to launch child processes with a binary signature policy that 
blocks non-Microsoft DLLs from the process space. Use blockdlls stop to disable this behavior. 
This feature requires Windows 10. 
7.9 Upload and Download Files 
The download command will download the requested file. You do not need to provide quotes 
around a filename with spaces in it. Beacon is built for low and slow exfiltration of data. During 
each check-in, Beacon will download a fixed chunk of each file its tasked to get. The size of this 
chunk depends on Beacon’s current data channel. The HTTP and HTTPS channels pull data in 
512KB chunks. 
Type downloads to see a list of file downloads in progress for the current Beacon. Use the 
cancel command, followed by a filename, to cancel a download that’s in progress. You may use 
wildcards with your cancel command to cancel multiple file downloads at once. 
Go to View -> Downloads in Cobalt Strike to see the files that your team has downloaded so far. 
Only completed downloads will show up in this tab. Downloaded files are stored on the team 
server. To bring files back to your system, highlight them here, and press Sync Files. Cobalt 
Strike will then download the selected files to a folder of your choosing on your system. 
The upload command will upload a file to the host.  
When you upload a file, you will sometimes want to update its timestamps to make it blend in 
with other files in the same folder. Use the timestomp command to do this. The timestomp 
command will match the Modified, Accessed, and Created times of one file to another file. 
7.10 File Browser 
Beacon’s File Browser is an opportunity to explore the files on a compromised system. Go to 
[Beacon] -> Explore -> File Browser to open it. 
The file browser will request a listing for the current working directory of Beacon. When this 
result arrives, the file browser will populate. 
The left-hand side of the file browser is a tree which organizes the known drives and folders into 
one view. The right-hand side of the file browser shows the contents of the current folder.  
www.cobaltstrike.com/
/
48/
Figure 35. File Browser 
Each file browser caches the folder listings it receives. A colored folder indicates the folder’s 
contents are in this file browser’s cache. You may navigate to cached folders without generating 
a new file listing request. Press Refresh to ask Beacon to update the contents of the current 
folder. 
A dark-grey folder means the folder’s contents are not in this file browser’s cache. Click on a 
folder in the tree to have Beacon generate a task to list the contents of this folder (and update its 
cache). Double-click on a dark-grey folder in the right-hand side current folder view to do the 
same. 
To go up a folder, press the folder button next to the file path above the right-hand side folder 
details view. If the parent folder is in this file browser’s cache, you will see the results 
immediately. If the parent folder is not in the file browser’s cache, the browser will generate a 
task to list the contents of the parent folder. 
Right-click a file to download or delete it.  
To see which drives are available, press List Drives.  
7.11 File System Commands 
You may prefer to browse and manipulate the file system from the Beacon console. You can do 
this too. Use the ls command to list files in the current directory. Use mkdir to make a directory. 
rm will remove a file or folder. cp copies a file to a destination. mv moves a file. 
7.12 The Windows Registry 
Use reg_query [x86|x64] [HIVE\path\to\key] to query a specific key in the registry. This 
command will print the values within that key and a list of any subkeys. The x86/x64 option is 
required and forces Beacon to use the WOW64 (x86) or native view of the registry. reg_query 
[x86|x64] [HIVE\path\to\key] [value] will query a specific value within a registry key. 
www.cobaltstrike.com/
/
49/
7.13 Keystrokes and Screenshots 
Beacon’s tools to log keystrokes and take screenshots are designed to inject into another process 
and report their results to your Beacon.  
To start the keystroke logger, use keylogger pid x86 to inject into an x86 process. Use keylogger 
pid x64 to inject into an x64 process. Use keylogger by itself to inject the keystroke logger into a 
temporary process. The keystroke logger will monitor keystrokes from the injected process and 
report them to Beacon until the process terminates or you kill the keystroke logger post-
exploitation job.  
Be aware that multiple keystroke loggers may conflict with each other. Use only one keystroke 
logger per desktop session.  
To take a screenshot, use screenshot pid x86 to inject the screenshot tool into an x86 process. 
Use screenshot pid x64 to inject into an x64 process. This variant of the screenshot command 
will take one screenshot and exit. screenshot, by itself, will inject the screenshot tool into a 
temporary process.  
The screenwatch command (with options to use a temporary process or inject into an explicit 
process) will continuously take screenshots until you stop the screenwatch post-exploitation job. 
Use the printscreen command (also with temporary process and inject options) to take a 
screenshot by a different method. This command uses a PrintScr keypress to place the screenshot 
onto the user's clipboard. This feature recovers the screenshot from the clipboard and reports it 
back to you. 
When Beacon receives new screenshots or keystrokes, it will post a message to the Beacon 
console. The screenshot and keystroke information is not available through the Beacon console 
though. Go to View -> Keystrokes to see logged keystrokes across all of your Beacon sessions. 
Go to View -> Screenshots to browse through screenshots from all of your Beacon sessions. 
Both of these dialogs update as new information comes in. These dialogs make it easy for one 
operator to monitor keystrokes and screenshots on all of your Beacon sessions. 
7.14 Post-Exploitation Jobs 
Several Beacon features run as jobs in another process (e.g., the keystroke logger and screenshot 
tool). These jobs run in the background and report their output when it’s available. Use the jobs 
command to see which jobs are running in your Beacon. Use jobkill [job number] to kill a job. 
7.15 The Process Browser 
The Process Browser does the obvious; it tasks a Beacon to show a list of processes and shows 
this information to you. The left-hand side shows the processes organized into a tree. The current 
process for your Beacon is highlighted yellow. 
The right-hand side shows the process details. The Process Browser is also a convenient place to 
impersonate a token from another process, deploy the screenshot tool, or deploy the keystroke 
logger. Highlight one or more processes and press the appropriate button at the bottom of the tab. 
www.cobaltstrike.com/
/
50/
Figure 36. Process Browser 
If you highlight multiple Beacons and task them to show processes, Cobalt Strike will show a 
Process Browser that also states which host the process comes from. This variant of the Process 
Browser is a convenient way to deploy Beacon’s post-exploitation tools to multiple systems at 
once. Simply sort by process name, highlight the interesting processes on your target systems, 
and press the Screenshot or Log Keystrokes button to deploy these tools to all highlighted 
systems. 
7.16 Desktop Control 
To interact with a desktop on a target host, go to [beacon] -> Explore -> Desktop (VNC). This 
will stage a VNC server into the memory of the current process and tunnel the connection 
through Beacon.  
When the VNC server is ready, Cobalt Strike will open a tab labeled Desktop HOST@PID.  
You may also use Beacon’s desktop command to inject a VNC server into a specific process. 
Use desktop pid architecture low|high. The last parameter let’s you specify a quality for the 
VNC session. 
www.cobaltstrike.com/
/
51/
Figure 37. Cobalt Strike Desktop Viewer 
The bottom of the desktop tab has several buttons. These are: 
Refresh the screen 
View only 
Decrease Zoom 
Increase Zoom 
Zoom to 100% 
Adjust Zoom to Fit Tab 
Send Ctrl+Escape 
Lock the Ctrl key 
Lock the Alt key 
If you can’t type in a Desktop tab, check the state of the Ctrl and Alt buttons. When either 
button is pressed, all of your keystrokes are sent with the Ctrl or Alt modifier. Press the Ctrl or 
Alt button to turn off this behavior. Make sure View only isn’t pressed either. To prevent you 
from accidentally moving the mouse, View only is pressed by default. 
www.cobaltstrike.com/
/
52/
7.17 Privilege Escalation 
Some post-exploitation commands require system administrator-level rights. Beacon includes 
several options to help you elevate your access.  
Elevate with an Exploit 
Type elevate to list privilege escalation exploits registered with Cobalt Strike. Run elevate 
[exploit] [listener] to attempt to elevate with a specific exploit. You may also launch one of these 
exploits through [beacon] -> Access -> Elevate. 
Use runasadmin, by itself, to list command elevator exploits registered with Cobalt Strike. Run 
runasadmin [exploit] [command + args] to attempt to run the specified command in an elevated 
context.  
Cobalt Strike separates command elevator exploits and session-yielding exploits because some 
attacks are a natural opportunity to spawn a session. Other attacks yield a “run this command” 
primitive. Spawning a session from a “run this command” primitive puts a lot of weaponization 
decisions (not always favorable) in the hands of your tool developer. With runasadmin, it’s your 
choice to drop an executable to disk and run it, to run a PowerShell one-liner, or to weaken the 
target in some way. 
If you’d like to use a PowerShell one-liner to spawn a session, go to [session] -> Access -> One-
liner. This dialog will setup a localhost-only webserver within your Beacon session to host a 
payload stage and return a PowerShell command to download and run this payload stage. This 
webserver is one-use only. Once it’s connected to once, it will clean itself up and stop serving 
your payload. If you run a TCP or SMB Beacon with this tool, you will need to use connect or 
link to assume control of the payload manually. Also, be aware that if you try to use an x64 
payload—this will fail if the x86 PowerShell is in your $PATH. 
Figure 38. PowerShell One-liner 
Cobalt Strike does not have many built-in elevate options. Exploit development is not a focus of 
the work at Strategic Cyber LLC. It is easy to integrate privilege escalation exploits via Cobalt 
Strike’s Aggressor Script programming language though. To see what this looks like, download 
the Elevate Kit. The Elevate Kit is an Aggressor Script that integrates several open source 
privilege escalation exploits into Cobalt Strike. https://github.com/rsmudge/ElevateKit 
www.cobaltstrike.com/
/
53/
Elevate with Known Credentials 
Use runas [DOMAIN\user] [password] [command] to run a command as another user using 
their credentials. The runas command will not return any output. You may use runas from a non-
privileged context though. 
Use spawnas [DOMAIN\user] [password] [listener] to spawn a session as another user using 
their credentials. This command spawns a temporary process and injects your payload stage into 
it. You may also go to [beacon] -> Access -> Spawn As to run this command as well. 
With both of these commands, be aware that credentials for a non-SID 500 account will spawn a 
payload in a medium integrity context. You will need to use Bypass UAC to elevate to a high 
integrity context. Also, be aware, that you should run these commands from a working folder 
that the specified account can read.  
Get SYSTEM 
Use getsystem to impersonate a token for the SYSTEM account. This level of access may allow 
you to perform privileged actions that are not possible as an Administrator user. 
Another way to get SYSTEM is to create a service that runs a payload. The elevate svc-exe 
[listener] command does this. It will drop an executable that runs a payload, create a service to 
run it, assume control of the payload, and cleanup the service and executable. 
UAC Bypass 
Microsoft introduced User Account Control (UAC) in Windows Vista and refined it in Windows 
7. UAC works a lot like sudo in UNIX. Day-to-day a user works with normal privileges. When 
the user needs to perform a privileged action—the system asks if they would like to elevate their 
rights.  
Cobalt Strike ships with a few UAC bypass attacks. These attacks will not work if the current 
user is not an Administrator. To check if the current user is in the Administrators group, use run 
whoami /groups. 
elevate uac-token-duplication [listener] will spawn a temporary process with elevated rights 
and inject a payload stage into it. This attack uses a UAC-loophole that allows a non-elevated 
process to launch an arbitrary process with a token stolen from an elevated process. This 
loophole requires the attack to remove several rights assigned to the elevated token. The abilities 
of your new session will reflect these restricted rights. If Always Notify is at its highest setting, 
this attack requires that an elevated process is already running in the current desktop session (as 
the same user). This attack works on Windows 7 and Windows 10 prior to the November 2018 
update. 
runasadmin uac-token-duplication [command] is the same attack described above, but this 
variant runs a command of your choosing in an elevated context. 
runasadmin uac-cmstplua [command] will attempt to bypass UAC and run a command in an 
elevated context. This attack relies on a COM object that automatically elevates from certain 
process contexts (Microsoft signed, lives in c:\windows\*). 
www.cobaltstrike.com/
/
54/
Privileges 
Type getprivs to enable the privileges assigned to your current access token. 
7.18 Mimikatz 