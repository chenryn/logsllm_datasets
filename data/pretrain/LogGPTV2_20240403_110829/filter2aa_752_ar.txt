命令删除它。 
  % ipcrm shm 1627649 
5.1.8 优点和缺点 
共享内存块提供了在任意数量的进程之间进行高效双向通信的机制。每个使用者都可以
读取写入数据，但是所有程序之间必须达成并遵守一定的协议，以防止诸如在读取信息之前
覆写内存空间等竞争状态的出现。不幸的是，Linux 无法严格保证提供对共享内存块的独占
访问，甚至是在你通过使用 IPC_PRIVATE 创建新的共享内存块的时候也不能保证访问的独
占性。 
同时，多个使用共享内存块的进程之间必须协调使用同一个键值。 
5.2 进程信号量 
前一节中我们提到过，当访问共享内存的时候，进程之间必须相互协调以避免竞争状态
的出现。正如我们在第四章“线程”中 4.4.5 节“线程信号量”里说过的，信号量是一个可
用于同步多线程环境的计数器。Linux 还提供了一个另外一个用于进程间同步的信号量实现
（通常它被称为进程信号量，有时也被称为 System V 信号量）。进程信号量的分配、使用和
释放方法都与共享内存块相似。尽管单个信号量足以解决大多数问题，进程信号量是按组
（set）分配的。本节中，我们将展示如何利用各种 Linux 提供的各种系统调用来实现一个具
有两种状态的信号量。 
www.AdvancedLinuxProgramming.com 
84
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
5.2.1 分配和释放 
与用于分配、释放共享内存的 shmget 和 shmctl 类似，系统调用 semget 和 semctl
负责分配、释放信号量。调用 semget 函数并传递如下参数：一个用于标识信号量组的键值，
该组中包含的信号量数量和与 shmget 所需的相同的权限位标识。该函数返回的是信号量组
的标识符。你可以通过指定正确的键值来获取一个已经存在的信号量的标识符；这种情况下，
传递的信号量组的容量可以为 0。 
信号量会一直保存在系统中，甚至所有使用它们的进程都退出后也不会自动被销毁。最
后一个使用信号量的进程必须明确地删除所使用的信号量组，来确保系统中不会有太多闲置
的信号量组，从而导致无法创建新的信号量组。可以通过调用 semctl 来删除信号量组。调
用时的四个参数分别为信号量组的标识符，组中包含的信号量数量、常量 IPC_RMID 和一
个 union semun 类型的任意值（被忽略）。调用进程的有效用户 id 必须与分配这个信号量
组的用户 id 相同（或者调用进程为 root 权限亦可）。与共享内存不同，删除一个信号量组
会导致 Linux 立即释放资源。 
列表 5.2 展示了用于分配和释放一个二元信号量的函数。 
代码列表 5.2 （sem_all_deall.c）分配和释放二元信号量 
#include  
#include  
#include  
/* 我们必须自己定义 semun 联合类型。 */ 
union semun { 
  int val; 
  struct semid_ds *buf; 
  unsigned short int *array; 
  struct seminfo *__buf; 
}; 
/* 获取一个二元信号量的标识符。如果需要则创建这个信号量 */ 
int binary_semaphore_allocation (key_t key, int sem_flags) 
{ 
  return semget (key, 1, sem_flags); 
} 
/* 释放二元信号量。所有用户必须已经结束使用这个信号量。如果失败，返回 -1 */ 
int binary_semaphore_deallocate (int semid) 
{ 
  union semun ignored_argument; 
  return semctl (semid, 1, IPC_RMID, ignored_argument); 
} 
www.AdvancedLinuxProgramming.com 
85
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
5.2.2 初始化信号量 
分配与初始化信号量是两个相互独立的操作。以 0 为第二参数，以 SETALL 为第三个
参数调用 semctl 可以对一个信号量组进行初始化。第四个参数是一个 semun 对象，且它
的 array 字段指向一个 unsigned short 数组。数组中的每个值均用于初始化该组中的一
个信号量。 
列表 5.3 展示了初始化一个二元信号量的函数 
代码列表 5.3 （sem_init.c） 初始化一个二元信号量 
#include  
#include  
#include  
/* 我们必须自己定义 union semun。*/ 
union semun { 
  int val; 
  struct semid_ds *buf; 
  unsigned short int *array; 
  struct seminfo *__buf; 
}; 
/* 将一个二元信号量初始化为 1。*/ 
int binary_semaphore_initialize (int semid) 
{ 
  union semun argument; 
  unsigned short values[1]; 
  values[0] = 1; 
  argument.array = values; 
  return semctl (semid, 0, SETALL, argument); 
} 
5.2.3 等待和投递操作 
每个信号量都具有一个非负的值，且信号量支持等待和投递操作。系统调用 semop 实
现了这两个操作。它的第一个参数是信号量的标识符，第二个参数是一个包含 struct 
sembuf 类型元素的数组；这些元素指明了你希望执行的操作。第三个参数是这个数组的长
度。 
结构体 sembuf 中包含如下字段： 
· sem_num 将要执行操作的信号量组中包含的信号量数量 
www.AdvancedLinuxProgramming.com 
86
· sem_op 是一个指定了操作类型的整数 
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
· 如果 sem_op 是一个正整数，则这个值会立刻被加到信号量的值上 
如果 sem_op 为负，则将从信号量值中减去它的绝对值。如果这将使信号量的值小
于零，则这个操作会导致进程阻塞，直到信号量的值至少等于操作值的绝对值（由
其它进程增加它的值）。 
· 如果 sem_op 为 0，这个操作会导致进程阻塞，直到信号量的值为零才恢复。 
· sem_flg 是一个符号位。指定 IPC_NOWAIT 以防止操作阻塞；如果该操作本应
阻塞，则 semop 调用会失败。如果为 sem_flg 指定 SEM_UNDO，Linux 会在进
程退出的时候自动撤销该次操作。 
列表 5.4 展示了二元信号量的等待和投递操作。 
代码列表 5.4 （sem_pv.c）二元信号量的等待和投递操作 
#include  
#include  
#include  
/* 等待一个二元信号量。阻塞直到信号量的值为正，然后将其减 1 */ 
int binary_semaphore_wait (int semid) 
{ 
  struct sembuf operations[1]; 
  /* 使用（且仅使用）第一个信号量 */ 
  operations[0].sem_num = 0; 
  /* 减一 */ 
  operations[0].sem_op = -1; 
  /* 允许撤销操作 */ 
  operations[0].sem_flg = SEM_UNDO; 
  return semop (semid, operations, 1); 
} 
/* 对一个二元信号量执行投递操作：将其值加一。 
   这个操作会立即返回。*/ 
int binary_semaphore_post (int semid) 
{ 
  struct sembuf operations[1]; 
  /* 使用（且仅使用）第一个信号量 */ 
  operations[0].sem_num = 0; 
  /* 加一 */ 
  operations[0].sem_op = 1; 
  /* 允许撤销操作 */ 
  operations[0].sem_flg = SEM_UNDO; 
www.AdvancedLinuxProgramming.com 
87
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
  return semop (semid, operations, 1); 
} 
指定 SEM_UNDO 标志解决当出现一个进程仍然持有信号量资源时被终止这种特殊情
况时可能出现的资源泄漏问题。当一个进程被有意识或者无意识地结束的时候，信号量的值
会被调整到“撤销”了所有该进程执行过的操作后的状态。例如，如果一个进程在被杀死之
前减小了一个信号量的值，则该信号量的值会增长。 
5.2.4 调试信号量 
命令 ipcs -s 可以显示系统中现有的信号量组的相关信息。而 ipcrm sem 命令可以
从命令行删除一个信号量组。例如，要删除标识符为 5790517 的信号量组则应运行以下命令： 
  % ipcrm sem 5790517 
5.3 映射内存 
映射内存提供了一种使多个进程通过一个共享文件进行通信的机制。尽管可以将映射内
存想象为一个有名字的共享内存，你始终应当记住两者之间有技术层面的区别。映射内存既
可以用于进程间通信，也可以作为一种访问文件内容的简单方法。 
映射内存在一个文件和一块进程地址空间之间建立了联系。Linux 将文件分割成内存分
页大小的块并复制到虚拟内存中，因此进程可以在自己的地址空间中直接访问文件内容。这
样，进程就可以以读取普通内存空间的方法来访问文件的内容，也可以通过写入内存地址来
修改文件的内容。这是一种方便的访问文件的方法。 
你可以将映射内存想象成这样的操作：分配一个足够容纳整个文件内容的缓存，将全部
文件内容读入缓存，并且（当缓存内容被修改过后）最后将缓存写回文件。Linux 替你完成
文件读写的操作。 
除了用于进程间通信，还有其它一些情况会使用映射内存。其中一些用途在 5.3.5 节
“mmap 的其它用途”中进行了讨论。 
5.3.1 映射一个普通文件 
要将一个普通文件映射到内存空间，应使用 mmap（映射内存，“Memory MAPped”，读
作“em-map”）。函数 mmap 的第一个参数指明了你希望 Linux 将文件映射在进程地址空间中
的位置；传递 NULL 指针允许 Linux 系统自动选择起始地址。第二个参数是映射内存块的长
度，以字节为单位。第三个参数指定了对被映射内存区域的保护，由 PROT_READ、
PROT_WRITE 和 PROT_EXEC 三个标志位按位与操作得到。三个值分别标识读、写和执
行权限。第四个参数是一个用于指明额外选项的标志值。第五个参数应传递一个已经打开的、
指向被映射文件的句柄。最后一个参数指明了文件中被映射区域相对于文件开始位置的偏移
量。通过选择适当的开始位置和偏移量，你可以选择将文件的全部内容或某个特定部分映射
到内存中。 
标志值可以由以下常量进行按位或操作进行组合得到： 
· MAP_FIXED——如果你指定这个标志，Linux 会强制使用你提供的地址进行映射，
而不只是将该地址作为一个对映射地址的参考进行选择。该地址必须按内存分页边
界对齐。 
· MAP_PRIVATE——对映射区域内存的写操作不会直接导致对被绑定文件的修改，
www.AdvancedLinuxProgramming.com 
88
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
而是修改该进程持有的一份该文件的私有副本。其它进程不会发现这些写操作。这
个模式不能与 MAP_SHARED 同时使用。 
· MAP_SHARED——对内存的写入操作会立刻反应在被映射的文件中，而不会被系
统缓冲。将映射内存作为一种 IPC 手段时应使用这个标志。这个模式不能与
MAP_PRIVATE 同时使用。 
如果调用成功，mmap 会返回一个指向被映射内存区域的起点的指针。如果调用失败则
返回常量 MAP_FAILED。 
当你不再使用一块映射内存的时候应调用 munmap 进行释放。将被映射内存区域的开始
地址和内存块的长度作为参数调用这个函数。Linux 会在进程结束的时候自动释放进程中映
射的内存区域。 
5.3.2 示例程序 
让我们看两个利用映射内存对文件进行读写的程序。列表 5.5 中的第一个程序会产生一
个随机数并写入一个映射到内存的文件中。列表 5.6 中的第二个程序则会从文件中读取并输
出这个值，然后将该值的两倍写回到文件中。两个程序均接受一个指明被映射文件的参数。 
代码列表 5.5 （mmap-write.c）将一个随即数写入内存映射文件 