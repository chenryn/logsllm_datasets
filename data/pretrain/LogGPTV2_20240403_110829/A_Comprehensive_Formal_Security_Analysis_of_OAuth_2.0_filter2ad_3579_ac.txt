the user selects that she wants to log in using HIdP (Step 1 in Fig-
ure 3). Now, the attacker intercepts the request intended for the
RP and modiﬁes the content of this request by replacing HIdP by
AIdP.8 The response of the RP 3 (containing a redirect to AIdP)
is then again intercepted and modiﬁed by the attacker such that it
redirects the user to HIdP 4 . The attacker also replaces the OAuth
client id of the RP at AIdP with the client id of the RP at HIdP
(which is public information). (Note that we assume that from this
point on, in accordance with the OAuth security recommendations,
the communication between the user’s browser and HIdP and the
RP is encrypted by using HTTPS, and thus, cannot be inspected or
altered by the attacker.) The user then authenticates to HIdP and is
redirected back to the RP 8 . The RP thinks, due to Step 2 of the
attack, that the nonce code contained in this redirect was issued by
AIdP, rather than HIdP. The RP therefore now tries to redeem this
nonce for an access token at AIdP 10 , rather than HIdP. This leaks
code to the attacker.
Breaking Authorization. If HIdP has not issued an OAuth client
secret to RP during registration, the attacker can now redeem code
for an access token at HIdP (in 11 and 12 ).9 This access token
allows the attacker to access protected resources of the user at HIdP.
This breaks the authorization property (see Section 5.2). We note
that at this point, the attacker might even provide false information
8At this point, the attacker could also read the session id for
the user’s session at RP. Our attack, however, is not based on this
possibility and works even if the RP changes this session id as soon
as the user is logged in and the connection is protected by HTTPS
(a best practice for session management).
9In the case that RP has to provide a client secret, this would
not work in this mode (see also Figure 2). Recall that in this mode,
client secrets are optional.
1208about the user or her protected resources to the RP: he could issue
a self-created access token which RP would then use to access such
information at the attacker.
Breaking Authentication. To break the authentication property (see
Section 5.2) and impersonate the honest user, the attacker, after
obtaining code in Step 10 , starts a new login process (using his own
browser) at the RP. He selects HIdP as the IdP for this login process
and receives a redirect to HIdP, which he ignores. This redirect
contains a cookie for a new login session and a fresh state parameter.
The attacker now sends code to the RP imitating a real login (using
the cookie and fresh state value from the previous response). The
RP then retrieves an access token at HIdP using code and uses this
access token to fetch the (honest) user’s id. Being convinced that
the attacker owns the honest user’s account, the RP issues a session
cookie for this account to the attacker. As a result, the attacker
is logged in at the RP under the honest user’s id. (Note that the
attacker does not learn an access token in this case.)
Variant. There is also a variant of the IdP mix-up attack that only
requires a web attacker (which does not intercept and manipulate
network messages). In this variant, the user wants to log in with
AIdP, but is redirected by AIdP to log in at HIdP; a fact a vigilant
user might detect.
In detail, the ﬁrst four steps in Figure 3 are replaced by the fol-
lowing steps: First, the user starts a new OAuth ﬂow with RP using
AIdP. She is then redirected by RP to AIdP’s authorization end-
point. Now, instead of prompting the user for her password, AIdP
redirects the user to HIdP’s authorization endpoint. (Note that, as
above, in this step, the attacker uses the state value he received from
the browser plus the client id of RP at HIdP.) From here on, the
attack proceeds exactly as in Step 5 in Figure 3.
Related Attacks. An attack in the same class, cross social-network
request forgery, was outlined by Bansal, Bhargavan, Delignat-La-
vaud, and Maffeis in [6]. It applies to RPs with naïve user intention
tracking (rather than explicit user intention tracking assumed in our
IdP mix-up attack above) in combination with IdPs, such as Face-
book, that only loosely check the redirect URI.10 Our IdP mix-up
attack works even if an IdP strictly checks redirect URIs. While the
attack in [6] is described in the context of concrete social network
implementations, our ﬁndings show that this class of attacks is not
merely an implementation error, but a more general problem in the
OAuth standard. This was conﬁrmed by the IETF OAuth Work-
ing Group, who, as mentioned, are in the process of amending the
OAuth standard according to our ﬁxes (see Section 3.6).
Another attack with a similar outcome, called Malicious End-
points Attack, leveraging the OpenID Connect Discovery mech-
anism and therefore limited to OpenID Connect, was described
in [27]. This attack assumes a CSRF vulnerability on the RP’s side.
Fix. A fundamental problem in the authorization code and implicit
modes of the OAuth standard is a lack of reliable information in
the redirect in Steps 6 and 7 in Figure 1 (even if HTTPS is used).
The RP does not receive information from where the redirect was
initiated (when explicit user intention tracking is used) or receives
information that can easily be spoofed (when naïve user intention
tracking is used with IdPs such as Facebook). Hence, the RP cannot
check whether the information contained in the redirect stems from
the IdP that was indicated in Step 1 .
Our ﬁx therefore is to include the identity of the IdP in the redi-
rect URI in some form that cannot be inﬂuenced by the attacker, e.g.,
using a new URI parameter. Each IdP should add such a parameter
10Facebook, by default, only checks the origin of redirect URIs.
to the redirect URI.11 The RP can then check that the parameter
contains the identity of the IdP it expects to receive the response
from. (This could be used with either naïve or explicit user inten-
tion tracking, but to mitigate the naïve RP session integrity attack
described below, we advise to use explicit user intention tracking
only, see below.)
We show in Section 5 that this ﬁx is indeed sufﬁcient to mitigate
the IdP mix-up attack (as well as the attacks pointed out in [6, 27]).
3.3 State Leak Attack
Using the state leak attack, an attacker can force a browser to
be logged in under the attacker’s name at an RP or force an RP to
use a resource of the attacker instead of a resource of the user. This
attack, which breaks our session integrity property (see Section 5.2),
enables what is often called session swapping or login CSRF [7].
Attack. After the user has authenticated to the IdP in the authoriza-
tion code mode, the user is redirected to RP (Step 7 in Figure 1).
This request contains state and code as parameters. The response
to this request (Step 14 ) can be a page containing a link to the at-
tacker’s website or some resource located at the attacker’s website.
When the user clicks the link or the resource is loaded, the user’s
browser sends a request to the attacker. This request contains a Ref-
erer header with the full URI of the page the user was redirected to,
which in this case contains state and code.
As the state value is supposed to protect the browser’s session
against CSRF attacks, the attacker can now use the leaked state
value to perform a CSRF attack against the victim. For example, he
can redirect the victim’s browser to the RP’s redirection endpoint
(again) and by this, overwrite the previously performed authoriza-
tion. The user will then be logged in as the attacker.
Given the history of OAuth, leaks of sensitive data through the
referrer header are not surprising. For example, the fact that the au-
thorization code can leak through the Referer header was described
as an attack (in a similar setting) in [21]. Since the authorization
code is single-use only [20], it might already be redeemed by the
time it is received by the attacker. State, however, is not limited to
single use, making this attack easier to exploit in practice. Stealing
the state value through the Referer header to break session integrity
has not been reported as an attack before, as was conﬁrmed by the
IETF OAuth Working Group.
State Leak at IdPs. A variant of this attack exists if the login page
at an IdP contains links to external resources.
If the user visits
this page to authenticate at the IdP and the browser follows links
to external resources, the state is transferred in the Referer header.
This variant is applicable to the authorization code mode and the
implicit mode.
Fix. We suggest to limit state to a single use and to use the recently
introduced referrer policies [13] to avoid leakage of the state (or
code) to the attacker. Using referrer policies, a web server can
instruct a web browser to (partially or completely) suppress the
Referer header when the browser follows links in or loads resources
for some web page. The Referer header can be blocked entirely, or
it can, for example, be stripped down to the origin of the URI of the
web page. Referrer policies are supported by all modern browsers.
Our OAuth model includes this ﬁx (such that only the origin is
permitted in the Referer header for links on web pages of RPs/IdPs)
and our security proof shows its effectiveness (see Section 5). The
11The OAuth Working Group indeed created a draft for an
RFC [22] that includes this ﬁx, where this parameter is called iss
(issuer).
1209ﬁx also protects the authorization code from leaking as in the attack
described in [21].
3.4 Naïve RP Session Integrity Attack
This attack again breaks the session integrity property for RPs,
where here we assume an RP that uses naïve user intention track-
ing.12 (Note that we may still assume that the OAuth state parameter
is used, i.e., RP is not necessarily stateless.)
Attack. First, an attacker starts a session with HIdP (an honest
IdP) to obtain an authorization code or access token for his own
account. Next, when a user wants to log in at some RP using AIdP
(an IdP controlled by the attacker), AIdP redirects the user back to
the redirection URI of HIdP at RP. AIdP attaches to this redirection
URI the state issued by RP, and the code or token obtained from
HIdP. Now, since RP performs naïve user intention tracking only,
the RP then believes that the user logged in at HIdP. Hence, the
user is logged in at RP using the attacker’s identity at HIdP or the
RP accesses the attacker’s resources at HIdP believing that these
resources are owned by the user.
Fix. The ﬁx against the IdP mix-up attack (described above) does
not work in this case: Since RP does not track where the user wanted
to log in, it has to rely on parameters in the redirection URI which
the attacker can easily spoof. Instead, we propose to always use
explicit user intention tracking.
3.5 Implications to OpenID Connect
OpenID Connect [31] is a standard for authentication built on top
of the OAuth protocol. Among others, OpenID Connect is used by
PayPal, Google, and Microsoft.
All four attacks can be applied to OpenID Connect as well. We
here outline OpenID Connect and how the attacks apply to this
protocol. A detailed description can be found in [17].
OpenID Connect extends OAuth in several ways, e.g., by addi-
tional security measures. OpenID Connect deﬁnes an authorization
code mode, an implicit mode, and a hybrid mode. The former two
are based on the corresponding OAuth modes and the latter is a
combination of the two modes.
307 Redirect, State Leak, Naïve RP Session Integrity Attacks. All
three attacks apply to OpenID Connect in exactly the same way as
described above. The vulnerable steps are identical.
IdP Mix-Up Attack. In OpenID Connect, the mix-up attack applies
to the authorization code mode and the hybrid mode. In the au-
thorization code mode, the attack is very similar to the one on the
OAuth authorization code mode. In the hybrid mode, the attack is
more complicated as additional security measures have to be cir-
cumvented by the attacker. In particular, it must be ensured that the
RP does not detect that the issuer of the id token, a signed crypto-
graphic document used in OpenID Connect, is not the honest IdP.
Interestingly, in the hybrid mode, depending on an implementation
detail of the RP, either authorization or authentication is broken (or
both if no client secret is used).
3.6 Veriﬁcation and Disclosure
We veriﬁed the IdP mix-up and 307 redirect attacks on the Apache
web server module mod_auth_openidc, an implementation of an
OpenID Connect (and therefore also OAuth) RP. We also veriﬁed
the IdP mix-up attack on the python implementation pyoidc. We ver-
12Recall the meaning of “naïve user intention tracking” from
Section 2.
iﬁed the state leak attack on the current version of the Facebook PHP
SDK and the naïve RP session integrity attack on nytimes.com.13
We reported all attacks to the OAuth and OpenID Connect work-
ing groups who conﬁrmed the attacks. The OAuth working group
invited us to present our ﬁndings to them and prepared a draft for an
RFC that mitigates the IdP mix-up attack (using the ﬁx described
in Section 3.2) [22]. Fixes regarding the other attacks are currently
under discussion. We also notiﬁed nytimes.com, Facebook, and the
developers of mod_auth_openidc and pyoidc.
4. FKS MODEL
Our formal security analysis of OAuth is based on a slightly ex-
tended version (see Section 5.1) of the FKS model, a general Dolev-
Yao (DY) style web model proposed by Fett et al. in [14, 16]. This
model is designed independently of a speciﬁc web application and
closely mimics published (de-facto) standards and speciﬁcations
for the web, for example, the HTTP/1.1 and HTML5 standards and
associated (proposed) standards. The FKS model deﬁnes a general
communication model, and, based on it, web systems consisting
of web browsers, DNS servers, and web servers as well as web
and network attackers. Here, we only brieﬂy recall the FKS model
(see [14, 16] for a full description, comparison with other models,
and a discussion of its limitations); see also [17].
Communication Model. The main entities in the model are (atomic)
processes, which are used to model browsers, servers, and attack-
ers. Each process listens to one or more (IP) addresses. Processes
communicate via events, which consist of a message as well as a
receiver and a sender address. In every step of a run, one event is
chosen non-deterministically from a “pool” of waiting events and is
delivered to one of the processes that listens to the event’s receiver
address. The process can then handle the event and output new
events, which are added to the pool of events, and so on.
As usual in DY models (see, e.g., [1]), messages are expressed
as formal terms over a signature Σ. The signature contains con-
stants (for (IP) addresses, strings, nonces) as well as sequence, pro-
jection, and function symbols (e.g., for encryption/decryption and
signatures). For example, in the web model, an HTTP request is
represented as a term r containing a nonce, an HTTP method, a do-
main name, a path, URI parameters, headers, and a message body.
For example, a request for the URI http://example.com/s?p=1 is
represented as
r :=(cid:104)HTTPReq,n1, GET, example.com, /s,(cid:104)(cid:104)p,1(cid:105)(cid:105),(cid:104)(cid:105),(cid:104)(cid:105)(cid:105)
where the body and the headers are empty. An HTTPS request for
r is of the form enca((cid:104)r,k(cid:48)(cid:105), pub(kexample.com)), where k(cid:48) is a fresh
symmetric key (a nonce) generated by the sender of the request
(typically a browser); the responder is supposed to use this key to
encrypt the response.
The equational theory associated with Σ is deﬁned as usual in
DY models. The theory induces a congruence relation ≡ on terms,
capturing the meaning of the function symbols in Σ. For instance,
the equation in the equational theory which captures asymmetric
decryption is deca(enca(x, pub(y)),y) = x. With this, we have that,
for example,
deca(enca((cid:104)r,k(cid:48)(cid:105), pub(kexample.com)),kexample.com) ≡ (cid:104)r,k(cid:48)(cid:105)
i.e., these two terms are equivalent w.r.t. the equational theory.
A (DY) process consists of a set of addresses the process listens
to, a set of states (terms), an initial state, and a relation that takes an
13mod_auth_openidc and nytimes.com are not susceptible to the
state leak attack since after the login/authorization, the user is im-
mediately redirected to another web page at the same RP.
1210A script models JavaScript running in a browser. Scripts are de-
ﬁned similarly to DY processes. When triggered by a browser, a
script is provided with state information. The script then outputs a
term representing a new internal state and a command to be inter-
preted by the browser (see also the speciﬁcation of browsers below).
Similarly to an attacker process, the so-called attacker script may
output everything that is derivable from the input.
A system is a set of processes. A conﬁguration of this system
consists of the states of all processes in the system, the pool of
waiting events, and a sequence of unused nonces. Systems induce
runs, i.e., sequences of conﬁgurations, where each conﬁguration is
obtained by delivering one of the waiting events of the preceding
conﬁguration to a process, which then performs a computation step.
A web system formalizes the web infrastructure and web appli-
cations. It contains a system consisting of honest and attacker pro-
cesses. Honest processes can be web browsers, web servers, or
DNS servers. Attackers can be either web attackers (who can listen
to and send messages from their own addresses only) or network
attackers (who may listen to and spoof all addresses and therefore
are the most powerful attackers). A web system further contains a
set of scripts (comprising honest scripts and the attacker script).
In our analysis of OAuth, we consider either one network attacker
or a set of web attackers (see Section 5). In our OAuth model, we
need to specify only the behavior of servers and scripts. These
are not deﬁned by the FKS model since they depend on the spe-