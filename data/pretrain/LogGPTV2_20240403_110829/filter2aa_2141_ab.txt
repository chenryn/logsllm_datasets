# [y = 0, x = 7]
33
Angr
●
一整个集成符号执行
●
path, path_group, factory, ...
CLE, archinfo
PyVEX, SimuVEX
Claripy
Angr
analysis
surveyors
34
Script – Hello Angr
●
脚本初体验
35
Script - Demo
36
Script – Hello Angr
●
Surveyors
import angr
p = angr.Project("test")
ex = p.surveyors.Explorer(find=(0x400844, ), avoid=(0x400855,))
ex.run()
print ex.found[0].state.posix.dumps(0)
37
Script – Hello Angr
●
path_group
import angr
p = angr.Project("test")
initial_state = p.factory.entry_state()
pg = p.factory.path_group(initial_state)
pg.explore(find=(0x4005d1,))
print pg
# 
print pg.found[0]
# 
print pg.found[0].state.posix.dumps(0)
# input_string
38
Script – Hello Angr
●
SimState
–
entry_state: a SimState initialized to the program state at the 
binary's entry point
–
blank_state: a SimState object with little initialization
SimState
- symbolic memory
- symbolic registers
- constraints
>>> import angr
>>> b = angr.Project('/bin/true')
>>> s = b.factory.blank_state(addr=0x08048591)
>>> s = b.factory.entry_state()
# The first 5 bytes of the binary
>>> print s.memory.load(b.loader.min_addr(), 5)
39
Script - ARGS
●
如何设 args ？
40
Script - ARGS
●
如何设 args ？
import angr
import claripy
p = angr.Project("test")
args = claripy.BVS('args', 8*16)
initial_state = prog.factory.entry_state(args=["./vul", args])
pg = p.factory.path_group(initial_state)
pg.explore(find=(0x4005d1,))
print pg
# 
print pg.found[0]
# 
print pg.found[0].state.posix.dumps(0)
# input_string
41
Script - ARGS
●
Claripy frontends
# Create a 32-bit symbolic bitvector "x"
>>> claripy.BVS('x', 32)
# Create a 32-bit bitvectory with the value 0x12345678
>>> claripy.BVV(0x12345678, 32)
42
Script – Memory Access
●
如何在记忆体位址上放符号变数？
–
方便我们追踪并求解记忆体位址上的值
43
Script – Memory Access
●
如何在记忆体位址上放符号变数？
import angr
p = angr.Project('./vul')
s = p.factory.blank_state(addr=0x80485c8)
bvs = s.se.BVS('to_memory', 8*4)
s.se.add(bvs > 1000)
s.memory.store(0x08049b80, bvs, endness='Iend_LE')
pg = p.factory.path_group(s, immutable=False)
...
44
Script – Memory Access
45
Script – Memory Access
●
Accessing Data
●
s.se is the solver engine of the state
# get the integer
>>> print s.se.any_int(s.regs.rax)
# get the string
>>> print s.se.any_str(s.memory.load(0x1000, 10, endness='Iend_LE'))
# storing data
>>> s.regs.rax = aaaa
>>> s.memory.store(0x1000, aaaa, endness='Iend_LE')
>>> s.memory.store(s.regs.rax, aaaa, endness='Iend_LE')
46
Script – Posix
●
如何对 stdin 的内容加上限制式？
47
Script – Posix
●
如何对 stdin 的内容加上限制式？
p = angr.Project('./vul')
st = p.factory.full_init_state(args=['./vul'])
# Constrain the first 28 bytes to be non-null and non-newline
for _ in xrange(28):
    k = st.posix.files[0].read_from(1)
    st.se.add(k != 0)
    st.se.add(k != 10)
# Constrain the last byte to be a newline
k = st.posix.files[0].read_from(1)
st.se.add(k == 10)
# Reset the symbolic stdin's properties and set its length
st.posix.files[0].seek(0)
st.posix.files[0].length = 29
...
48
Optimization
49
Optimization
●
实际用 angr 跑，会发现
–
跑了几个小时都还没找到目标路径
–
跑著跑著就坏了
●
自动分析似乎很美好，但却隐藏很多问题 ...
50
Optimization
●
Environment
–
shared library
●
Exploration Strategy
–
BFS
–
DFS
●
Explosion
–
path explosion
–
path pruning
51
Environment
●
情境
–
对符号执行来说， libc 里复杂无比，一旦进入 libc function 分析可能
就挂在里面了
–
Crypto function
–
看不懂的 syscall
52
Environment
●
SimProcedure
●
Hook symbol
●
Go into library
p = angr.Project('./vul',
                          load_options={'auto_load_libs': True},
                          use_sim_procedures=True,
                          exclude_sim_procedures_func='strcmp')
class my_strcmp(simuvex.SimProcedure):                                         
    def run(self):
        ...
        return ...
p.hook_symbol('strcmp', my_strcmp)
53
Environment
●
Hook
●
Unknown syscall
'''
$ objdump -M intel -d ./vul | grep -A2 85d7                               
 80485d7:       e8 9f 00 00 00          call   804867b
 80485dc:       89 44 24 10             mov    DWORD PTR [esp+0x10],eax             
 80485e0:       83 7c 24 10 ff          cmp    DWORD PTR [esp+0x10],0xffffffff   
'''
def check1(state):                                                                  
    state.regs.eax = 20
p.hook(0x080485d7, check1, length=5)                                                
initial_state = project.factory.entry_state(
    args=[project.filename, arg1],
    add_options={'BYPASS_UNSUPPORTED_SYSCALL'}) 
54
Exploration Strategy
●
Exploration techniques
pg = p.factory.path_group(initial_state, immutable=False)
pg.use_technique(angr.exploration_techniques.DFS())
# pg.explore(find=(0x08041234, ))
pg.run(step_func=my_find_func)
55
Explosion
●
情境
int counter = 0, values = 0;
for(i=0; i<100; i++){
    if(input[i] == 'B'){
        counter++;
        values += 2;
    }   
}   
if(counter == 75) 
    bug();
56
Explosion
●
情境
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   
57
Explosion
●
Veritesting
–
结合静态符号执行以及动态符号执行
–
把限制式全部合并在一条路径上
–
减少 path explosion 的影响
pg = p.factory.path_group(initial_state, immutable=False, veritesting=True)
58
Explosion
●
情境
–
Unsatisfiable path 代表这条路不可能发生，即无法产生任何一组 
input 使得 binary 可以照这条路执行
 . . . . . . . . . . . . . . . . . . . . . . . .
59
Explosion
●
LAZY_SOLVES
–
懒得检查，意思是当路径探索完的时候才进行检查
–
预设是开启的
initial_state = project.factory.entry_state(args=[project.filename, arg1])
initial_state.options.discard('LAZY_SOLVES')
60
Explosion
●
Without LAZY_SOLVES
–
Checked 5 paths
–
Pruned 2 paths
●
LAZY_SOLVES
–
Checked 35 paths
–
Pruned 34 paths
 . . . . . . . . . . . . . . . . . . . . . . . .
               (32 paths)
61
Explosion
●
Without LAZY_SOLVES
–
Checked 67 paths
–
Pruned 1 path
●
LAZY_SOLVES
–
Checked 35 paths
–
Pruned 2 paths
 . . . . . . . . . . . . . . . . . . . . . . . .
               (32 paths)
62
Explosion
●
Dynamic path pruning
–
根据已经检查的路径们，推估现在 unsatisfiable path 的比例
–
依照 unsatisfiable path 的比例调整之后路径要不要进行检查的机率
63
Other Debug Options
●
REVERSE_MEMORY_NAME_MAP
–
保留对记忆体位址的资讯，让我们可以拿 BVS 的名字
（ 'file_/dev/stdin' ）来得到模拟的记忆体位址（ 0xffff1234 ）
●
TRACK_ACTION_HISTORY
–
方便查看之前所模拟执行过的状态的 ACTION 纪录
64
Demo
65
结论
●
现在流行自动打 CTF
●
Angr 各种脚本写法以及优化小技巧
●
单用 symbolic execution 做自动分析其实还不够
66
Reference
●
Symbolic Execution
–
Angr: http://angr.io/
–
KLEE: https://klee.github.io/
–
Triton: http://triton.quarkslab.com/
●
My blog: http://ysc21.github.io/
67
Q & A