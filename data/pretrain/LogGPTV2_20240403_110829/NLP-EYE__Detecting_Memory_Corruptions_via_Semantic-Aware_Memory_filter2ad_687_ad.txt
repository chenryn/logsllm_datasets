sMagick
4.7 Case Study
We discuss two representative vulnerabilities found in the
GraphicsMagick library and the CPython interpreter, respec-
tively.
GraphicsMagick is a library that was derived from the Im-
ageMagick image processing utility in November 2002. Graph-
icsMagick is securely designed and implemented after be-
ing tested by Memcheck and Helgrind3. Also, AddressSanitizer
(ASAN) [40], the most mature redzone-based memory error
detector, proves it to be secure against memory errors. Never-
theless, NLP-EYE detects six null pointer de-reference vul-
nerabilities from its latest version. An example is presented in
Figure 5. The function MagickAllocateMemory is declared
to allocate memories. If the dynamic memory is insufﬁcient
and a null pointer is returned by this function (Line 4 of File2),
a segmentation fault will be triggered (Line 6 of File2).
To detect
the
this vulnerability, a detector should rec-
ognize
customized memory allocation function
MagickAllocateMemory, which is a macro deﬁnition
of the MagickMalloc function. For MagickMalloc, its
implementation is deﬁned in File1, and a customized
memory allocation function MallocFunc is declared in this
function. Besides analyzing the standard memory operation
functions, NLP-EYE ﬁrst identiﬁes the macro deﬁnition,
MagickAllocateMemory in Line4 of File2, and uses its
original function MagicMalloc in File1 to replace it. By
proceeding the preprocessing and semantics extraction
phases, NLP-EYE labels those functions as memory
operation functions, and ﬁnally locates function misuses. In
comparison, other detection tools (e.g., MallocChecker) cannot
distinguish those customized functions (i.e, MallocFunc,
MagicMalloc, and MagickAllocateMemory), and thus fail
to detect the ﬂaw.
3Memcheck is a memory error detector for C and C++ programs. Hel-
grind is a tool for detecting synchronisation errors in C, C++ and Fortran
programs that use the POSIX pthreads threading primitives. They are all
based on Valgrind [35]
Figure 6: A double-free vulnerability in CPython
Another sample code snippet with double-free vulnerability
is shown in Figure 6, which is detected from CPython inter-
preter. Apparently, function PyMem_Free in File1 is a memory
de-allocation function. If the variable res is -1, the variable
key will be freed twice (Line 10 and 15 of File2, respectively) .
To our surprise, this simple vulnerability was found neither by
manual audit nor automated source code analysis. According
to the feedback of CPython developers, the corresponding host
function has been tested for many times, but the vulnerability
still exists. Based on this feedback, we would say that identi-
fying customized memory operation functions is suitable to
memory corruption detection. NLP-EYE is very helpful in
this scenario.
5 Related Work
There are prior efforts of vulnerability detection, in this sec-
tion, we introduce these works based on their analysis ap-
proaches, i.e., source code-based analysis and binary code-
based analysis.
5.1 Source Code-based Analysis
Previous studies detect vulnerabilities by applying pro-
gram analysis on source code to extract pointer informa-
tion [41] [44] and data dependencies [33], [24], [29], [28].
To analyze C programming source code, CRED [44] detects
use-after-free vulnerabilities in C programs. It extracts points-
to information by applying a path-sensitive demand-driven
approach. To decrease false alarms, it uses spatio-temporal
context reduction technique to construct use-after-free pairs
File1: GraphicsMagick/magick/memory.cFile2: GraphicsMagick/coders/pdb.c12345678static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception){ ... comment=MagickAllocateMemory(char *,length+1); p=comment; p[0]='\0'; ...}123456MagickExport void * MagickMalloc(const size_t size){ if (size == 0) return ((void *) NULL);  MEMORY_LIMIT_CHECK(GetCurrentFunction(),size); return (MallocFunc)(size);}File1: CPython/Objects/obmalloc.cFile2: CPython/Modules/_randommodule.c1234567891011121314151617static PyObject *random_seed(RandomObject *self, PyObject *args){ ... res = _PyLong_AsByteArray((PyLongObject *)n, (unsigned char *)key,   keyused * 4, PY_LITTLE_ENDIAN, 0); /* unsigned */ if (res == -1) { PyMem_Free(key); goto Done; } ... Done: PyMem_Free(key); return result;}123void PyMem_Free(void *ptr){ _PyMem.free(_PyMem.ctx, ptr);}318          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Associationprecisely. However, the pairing part is time consuming that
every path in the source code is required to be analyzed and
memorized. Instead of analyzing the entire source code, Pin-
point [41] applies sparse value-ﬂow analysis to identify vul-
nerabilities in C programs, such as use-after-free, double-free.
To reduces the cost of data dependency analysis, Pinpoint ana-
lyzes local data dependence ﬁrst and then performs symbolic
execution to memorize the non-local data dependency and
path conditions.
Similar to the above, some other tools detect vulnerabilities
by compare data-ﬂows with some pre-deﬁned rules/violations.
CBMC [28] is a C bounded model checker, which examines
safety of the assertions under a given bound. It translates
assertions and loops into a formula. If this formula satisﬁes
any pre-deﬁned violations, then a violated assertion will be
identiﬁed. Coccinelle [29] ﬁnds speciﬁc bug by comparing the
code with a given pattern written in Semantic Patch Language
(SmPL).
Source code-based analysis has also been applied to Linux
kernel. Due to the large amount of kernel code in Linux,
DR. CHECKER [33] and K-Miner [24] are designed to be more
effective and efﬁciency. DR. CHECKER employs a soundy ap-
proach based on program analysis. It is capable of conducting
large-scale analysis and detecting numerous classes of bugs
in Linux kernel drivers. K-Miner ﬁnds vulnerabilities by set-
ting up a virtual kernel environment and processing syscalls
separately.
Those proposed tools perform well to detect vulnerabilities
implemented under standard programming styles, such as call-
ing standard library APIs, designing standard implementation
steps. They cannot proceed those customized functions just
like how NLP-EYE does.
Instead of applying program analysis, both VulPecker [30]
and VUDDY [27] detects vulnerabilities based on the code sim-
ilarity. VulPecker builds a vulnerability database by using diff
hunk features collected from each vulnerable code and its
corresponding patch code. VUDDY proceeds each vulnerable
function as an unit, and then abstracts and normalizes vulnera-
ble functions to ensure that they are able to detect clones with
modiﬁcations. However, similarity-based techniques require
a massive database that can be learnt from.
5.2 Binary Code-based Analysis
Instead of analyzing source code, binary code can also
be adopted to identify memory corruption vulnerabili-
ties on stacks and allocated memories [22], [35], [40],
[26], [43], [25], [23].
Memory shadowing helps to track the memory status
at runtime.
It also causes large memory consumption.
Dr.Memory [22] conducts memory checking on Windows and
Linux. It uses memory shadowing to track the memory status
and identiﬁes stack usage within heap memory. Dr.Memory is
ﬂexible and lightweight by using an encoding for callstacks to
reduce memory consumption. AddressSanitizer [40] minimizes
the memory consumption by creating a compact shadow mem-
ory, which achieves a a 128-to-1 mapping. By implementing
a specialized memory allocator and code instrumentation in
the compiler, AddressSanitizer analyzes the vulnerabilities on
stack, head, global variables. HOTracer [26] discovers heap
overﬂow vulnerabilities by examining whether a heap access
operation can be controlled by an attacker. HOTracer ﬁnds
vulnerabilities by giving an accurate deﬁnition to buffer over-
ﬂow and it uses a heuristic method to ﬁnd memory allocation
functions. HOTracer is able to identify memory allocation func-
tions with a higher accuracy, and several unknown overﬂow
vulnerabilities are detected.
Unfortunately, detecting memory corruptions through bi-
nary code-based analysis requires proper inputs, that can pre-
cisely trigger the corresponding memory operation. It might
cause some false negatives because of the incomplete code
coverage.
6 Conclusion
We propose an NLP-based automated approach to detect mem-
ory corruption vulnerabilities. A detection tool, NLP-EYE,
is developed to identify vulnerabilities of null pointer de-
reference, use-after-free, double free. The novelty of our ap-
proach is that we retrieve the function semantics accurately
based on a little function information, i.e., function prototypes
and comments, instead of using the entire function implemen-
tations. With the help of NLP-based and type-based analyses,
NLP-EYE identiﬁes memory operation functions accurately.
Our approach is also adaptable since NLP-EYE generates
an adaptive corpus for different dataset by extracting their
comments from source code and various programming styles.
In this work, we only focused on memory corruption vul-
nerabilities. We plan to extend NLP-EYE in future with
additional reference functions to identify the other vulnera-
bilities. We also open source NLP-EYE to help analysts and
developers to improve software security.
7 Acknowledgments
The authors would like to thank the anonymous reviewers
for their feedback and our shepherd, Dongpeng Xu, for his
valuable comments to help improving this paper.
This work was supported by the General Program of
National Natural Science Foundation of China (Grant
No.61872237), the Key Program of National Natural Science
Foundation of China (Grant No.U1636217) and the National
Key Research and Development Program of China (Grant
No.2016YFB0801200).
We especially thank Huawei Technologies, Inc. for the
research grant that supported this work, Ant Financial Ser-
vices Group for the support of this research within the SJTU-
AntFinancial joint Institute of FinTech Security, and Nanjing
Turing Artiﬁcial Intelligence Institute with the internship pro-
gram.
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 319References
[1] Clang Static Analyzer. http://clang-analyzer.llvm.org.
[2] Cppcheck. http://cppcheck.sourceforge.net.
[3] CPython. https://www.python.org.
[4] Git. https://git-scm.com.
[5] GNU
Manuals
Online.
https://www.gnu.org/manual/manual.en.html .
[6] GnuTLS. https://www.gnutls.org.
[7] Google
Web
Trillion
Word
Corpus.
http://googleresearch.blogspot.com/2006/08/all-
our-n-gram-are-belong-to-you.html.
[8] GraphicsMagick. http://www.graphicsmagick.org.
[9] ImageMagick. https://www.imagemagick.org.
[10] Infer. https://fbinfer.com.
[11] LibTIFF. http://www.libtiff.org.
[12] Linux man pages online. http://man7.org/linux/man-
pages/index.html.
[13] MallocChecker. https://clang-analyzer.llvm.org/.
[14] Microsoft: 70 percent of all security bugs are memory
safety issues. https://www.zdnet.com/article/microsoft-
70-percent-of-all-security-bugs-are-memory-safety-
issues/.
[15] Python
https://pypi.org/project/wordsegment/.
Wordsegment.
[16] Stackoverﬂow. https://stackoverﬂow.com.
[17] Vim. https://www.vim.org.
[18] VisualCodeGrepper. https://github.com/nccgroup/VCG.
[19] Wikipedia. https://www.wikipedia.org.
[20] Windows
8
APIs
References.
https://docs.microsoft.com/en-
us/windows/desktop/apiindex/windows-8-api-sets.
[21] Windows
Driver
API
https://docs.microsoft.com/en-us/windows-
hardware/drivers/ddi/content/.
references.
[22] Bruening, Derek and Zhao, Qin. Practical Memory
Checking with Dr. Memory. In Proceedings of the 9th
Annual IEEE/ACM International Symposium on Code
Generation and Optimization (CGO), 2011.
[23] Dinakar Dhurjati and Vikram Adve. Efﬁciently Detect-
ing All Dangling Pointer Uses in Production Servers. In
Proceedings of International Conference on Dependable
Systems and Networks (DSN), 2006.
[24] David Gens, Simon Schmitt, Lucas Davi, and Ahmad-
Reza Sadeghi. K-miner: Uncovering Memory Corrup-
In Proceedings of 2018 Network and
tion in Linux.
Distributed System Security Symposium (NDSS), 2018.
[25] Niranjan Hasabnis, Ashish Misra, and R Sekar. Light-
weight Bounds Checking. In Proceedings of the Tenth
International Symposium on Code Generation and Opti-
mization (CGO), 2012.
[26] Xiangkun Jia, Chao Zhang, Purui Su, Yi Yang, Huafeng
Huang, and Dengguo Feng. Towards Efﬁcient Heap
Overﬂow Discovery. In Proceedings of 26th USENIX
Security Symposium USENIX Security (USENIX Secu-
rity), 2017.
[27] Seulbae Kim, Seunghoon Woo, Heejo Lee, and Hakjoo
Oh. VUDDY: A Scalable Approach for Vulnerable
Code Clone Discovery. In Proceedings of 2017 IEEE
Symposium on Security and Privacy (SP), 2017.
[28] Daniel Kroening and Michael Tautschnig. CBMC–C
Bounded Model Checker. In Proceedings of Interna-
tional Conference on Tools and Algorithms for the Con-
struction and Analysis of Systems (TACAS), 2014.
[29] Julia Lawall, Ben Laurie, Ren’e Rydhof Hansen, Nicolas
Palix, and Gilles Muller. Finding Error Handling Bugs
in Openssl Using Coccinelle. In Proceedings of 2010
European Dependable Computing Conference (EDCC),
2010.
[30] Zhen Li, Deqing Zou, Shouhuai Xu, Hai Jin, Hanchao
Qi, and Jie Hu. VulPecker: an Automated Vulnerability
Detection System Based on Code Similarity Analysis.
In Proceedings of the 32nd Annual Conference on Com-
puter Security Applications (ACSAC), 2016.
[31] Stanley B. Lippman. C++ Primer. 2012.
[32] Edward Loper and Steven Bird. NLTK: the Natural
Language Toolkit. arXiv preprint cs/0205028, 2002.
[33] Aravind Machiry, Chad Spensky, Jake Corina, Nick
Stephens, Christopher Kruegel, and Giovanni Vigna.
DR.CHECKER: A Soundy Analysis for Linux Kernel
Drivers. In Proceedings of 26th USENIX Security Sym-
posium USENIX Security (USENIX Security), 2017.
[34] Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey
Dean. Efﬁcient Estimation of word representations in
Vector Space. arXiv preprint arXiv:1301.3781, 2013.
[35] Nicholas Nethercote and Julian Seward. Valgrind: a
Framework for Heavyweight Dynamic binary instru-
In Proceedings of ACM Sigplan notices,
mentation.
2007.
[36] Stephen Prata. C Primer Plus. 2014.
320          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Association[37] Radim Rehurek and Petr Sojka. Software Framework for
Topic Modelling with Large Corpora. In Proceedings of
the LREC 2010 Workshop on New Challenges for NLP
Frameworks (LREC), 2010.
[38] Edward J Schwartz, Cory F Cohen, Michael Duggan,
Jeffrey Gennari, Jeffrey S Havrilla, and Charles Hines.
Using Logic Programming to Recover C++ Classes and
Methods from Compiled Executables. In Proceedings
of the 2018 ACM SIGSAC Conference on Computer and
Communications Security (CCS), 2018.
[39] Toby Segaran and Jeff Hammerbacher. Beautiful Data:
the Stories Behind Elegant Data Solutions. 2009.
[40] Konstantin Serebryany, Derek Bruening, Alexander
Potapenko, and Dmitriy Vyukov. AddressSanitizer: A
In Proceedings of the
Fast Address Sanity Checker.
2012 USENIX Annual Technical Conference (USENIX
ATC), 2012.
Code. In Proceedings of the 39th ACM SIGPLAN Con-
ference on Programming Language Design and Imple-
mentation (PLDI), 2018.
[42] Yulei Sui and Jingling Xue. SVF: Interprocedural Static
Value-ﬂow Analysis in LLVM. In Proceedings of the
25th international conference on compiler construction
(CC), 2016.
[43] Erik Van Der Kouwe, Vinod Nigade, and Cristiano Giuf-
frida. Dangsan: Scalable use-after-free Detection. In
Proceedings of the Twelfth European Conference on
Computer Systems (EuroSys), 2017.
[44] Hua Yan, Yulei Sui, Shiping Chen, and Jingling Xue.
Spatio-Temporal Context Reduction: a Pointer-Analysis-
Based Static Approach for Detecting Use-After-Free
In Proceedings of 2018 IEEE/ACM
Vulnerabilities.
40th International Conference on Software Engineering
(ICSE), 2018.
[41] Qingkai Shi, Xiao Xiao, Rongxin Wu, Jinguo Zhou,
Gang Fan, and Charles Zhang. Pinpoint: Fast and Pre-
cise Sparse Value Flow Analysis for Million Lines of
[45] Li Yujian and Liu Bo. A Normalized Levenshtein Dis-
tance Metric. IEEE transactions on pattern analysis
and machine intelligence (TPAMI), 2007.
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 321