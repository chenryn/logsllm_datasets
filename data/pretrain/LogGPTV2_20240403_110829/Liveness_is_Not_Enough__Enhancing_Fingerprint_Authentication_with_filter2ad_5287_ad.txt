### 优化后的文本

#### 表 6: 使用非重叠受试者训练基础 CNN 和测试时的平均 BAC (%)、FAR (%)、FRR (%) 和 AUC
| 特征集 + 分类器 | CNF + LOF | UnF + LOF |
|-----------------|------------|------------|
| BAC             | 95.34      | 95.59      |
| FAR             | 4.20       | 3.35       |
| FRR             | 5.10       | 5.47       |
| AUC             | 0.9805     | 0.9867     |

#### 7.2.2 非重叠受试者的性能评估
我们还评估了在使用非重叠受试者训练基础 CNN 并评估认证模型时 FINAUTH 的性能。我们将这 90 名受试者随机且均匀地分成两组。一组用于训练基础 CNN 作为特征提取器，另一组用于评估认证模型的性能。在测试阶段，我们使用了 5 折交叉验证。我们在数据集-1 的坐姿数据点上使用了 CNF + LOF 和 UnF + LOF。

表 6 显示了在使用非重叠受试者训练基础 CNN 和测试时的 BAC、FAR、FRR 和 AUC。CNF + LOF 和 UnF + LOF 的平均 BAC 分别为 95.34%（相比表 5 中的 97.99%）和 95.59%（相比表 5 中的 98.02%）。

#### 7.2.3 不同姿势的影响
为了研究姿势和移动对 FINAUTH 性能的影响，我们使用了数据集-1 中的所有 63,000 个数据点。对于每个用户和每个姿势，我们使用训练数据集中的 30 个数据点来训练一个分类器。具体来说，对于每个参与者，认证模型分别针对五种不同的姿势进行训练。然后，利用该模型评估不同姿势的性能。

图 7 显示了使用不同姿势的数据点训练认证模型（x 轴）和评估性能（y 轴）时的 BAC。结果表明，FINAUTH 在静止姿势（如坐姿、站姿和躺姿）下的性能优于移动姿势（如步行和跑步）。在静止姿势下训练的认证模型可以转移到其他静止姿势而不会显著降级。如果忽略现实生活中的罕见姿势“跑步”，FINAUTH 在使用 30 个坐姿数据点对用户进行建模时可达到超过 94% 的 BAC。

#### 7.2.4 训练数据集大小的影响
为了研究训练数据集大小的影响，我们将训练数据集的大小从 5 增加到 100，步长为 5 或 10，以对合法用户进行建模。图 6 显示了不同分类器在不同训练数据集大小下的 BAC。正如预期的那样，更多的训练数据可以获得更高的 BAC。使用基于 CNN 的特征或两种特征集的联合，LOF 的表现优于其他三种分类器。仅用 5 个训练数据点和基于 CNN 的特征，LOF 可以实现 96.04% 的 BAC，其 FAR 为 1.12%，FRR 为 6.80%。使用 100 个训练数据点时，LOF 可以实现 99.28% 的 BAC，其 FAR 和 FRR 分别为 0.045% 和 1.39%。

#### 7.2.5 时间一致性
为了研究用户的指纹行为在长时间内的一致性，我们使用了数据集-2 和数据集-1 中的 45,000 个坐姿数据点。训练数据点选自数据集-1（第一周的数据收集），测试数据点来自数据集-2。

图 8 显示了数据集-2A 和数据集-2B 在不同周数下的平均 BAC、FAR 和 FRR。结果显示，行为变异性对 FINAUTH 的可用性有一定影响，但对安全性的影响较小。特别是，在图 8(a) 中，BAC 从 96.34% 下降到 90.13%，其 FRR 从 6.20% 增加到 15.46%（7 周内）。而在图 8(b) 中，BAC 从 96.19% 下降到 93.96%，其 FRR 从 6.50% 增加到 9.69%（5 周内）。FAR 在数据集-2A 和数据集-2B 中几乎保持稳定。这表明 FINAUTH 对短期行为变异具有一定的鲁棒性。特别是在实际应用中，可以通过重新训练认证模型来解决行为变异性问题，即更新模型机制，类似于 Face ID [3] 所采用的方法。

#### 7.2.6 不同设备的影响
为了研究不同设备上的指尖触控数据如何影响 FINAUTH 的鲁棒性，我们评估了数据集-1 和数据集-3 中的 45,000 个坐姿数据点。如表 7 所示，Oneplus3、Oneplus5、Xperia XZ1 和 Vivo X21 的 BAC 分别为 97.99%、98.41%、96.83% 和 98.64%。不同设备之间的 BAC 存在差异。最佳性能出现在 Vivo X21 上，BAC 达到 98.64%，其 FAR 和 FRR 分别为 0.58% 和 2.13%。最差的结果出现在 Xperia XZ1 上，BAC 为 96.83%，其 FAR 和 FRR 分别为 1.69% 和 4.65%。

#### 7.3 演示攻击的评估
为了研究对抗演示攻击的能力，我们使用了数据集-4，并报告了在不同训练数据集大小下 CNF + LOF 的 FAR。

图 9(a) 显示了在不同训练数据集大小下使用数据集-4A 进行人工复制品攻击时的 FAR。总体 BAC 小于 3%。具体来说，当模型用 10 个数据点训练时，FAR 为 2.01%，而用 100 个数据点训练时，FAR 改善到 0.08%。

图 9(b) 显示了在不同训练数据集大小下使用数据集-4B 进行傀儡攻击时的 FAR。结果显示，FINAUTH 对抗傀儡攻击的平均 FAR 低于 2%。具体来说，当模型仅用 5 个数据点训练时，平均 FAR 为 1.93%，而用 100 个数据点训练时，FAR 改善到 0.12%。

图 9(c) 显示了在不同训练数据集大小下使用数据集-4C 进行模仿攻击时的 FAR。结果显示，攻击者很难模仿用户的指尖触控行为。在用 5 个数据点训练的模型下，攻击成功率为 3.10%，而在用 100 个数据点训练的模型下，攻击成功率改善到 0.25%。

结果表明，FINAUTH 在对抗三种类型的演示攻击方面是有效的。使用更多的合法数据点来训练认证模型可以增强对各种攻击的防御能力。表 8 显示了使用 100 个数据点训练的认证模型下的 FAR 和预测分数。特别是，所有攻击数据点的预测分数分布及其在高斯核下的核密度估计如图 10 所示。

#### 7.4 系统性能
我们分析了 FINAUTH 在 OnePlus 3、Redmi Note 4X、Xperia XZ1 和 Vivo X21 上的系统性能。在每台设备上，我们进行了 50 次认证原型测试，以评估认证延迟、内存使用和功耗。

**认证延迟**：延迟定义为认证系统检测到指纹认证事件到系统生成结果之间的时间间隔。它包括数据收集、数据处理和分类所需的时间。表 9 显示了四款智能手机的延迟。我们的方法在这四款智能手机上的平均延迟分别为 713.34 ms、722.93 ms、630.72 ms 和 692.15 ms。图 11 显示了不同智能手机上启用和不启用 FINAUTH 时的延迟累积分布函数 (CDF)。对于 90% 的尝试，FINAUTH 的延迟分别小于 742.39 ms、749.83 ms、643.26 ms 和 714.54 ms（OnePlus 3、Redmi Note 4X、Xperia XZ1 和 Vivo X21）。总体而言，FINAUTH 仅需 689.79 ms 的平均延迟。此外，我们的方法在智能手机上的延迟低于现有的 PIN、图案锁和面部认证等方法。这意味着 FINAUTH 可以及时认证用户。

**内存使用**：我们使用 Trepn Profiler 和 Android Studio Profiler 监测了 FINAUTH 的内存使用情况。表 9 显示了在四款智能手机上不考虑图形的内存使用情况。具体来说，四款不同智能手机的内存使用量分别为 62.99 MB、57.82 MB、48.77 MB 和 81.19 MB。平均内存使用量为 62.69 MB，比原始指纹认证增加了 14.92 MB。

**功耗**：使用 Trepn Profiler 提供 mW 级别的功耗估算。通过减去屏幕开启时的屏幕功耗来测量功耗。平均功耗开销为 23.13 mW，比原始指纹认证增加了 6.90 mW（见表 9）。

综上所述，FINAUTH 在商用智能手机上实现了 689.79 ms 的低认证延迟，内存使用量为 62.69 MB，功耗为 23.13 mW。与原始指纹认证相比，它引入的额外开销和延迟非常小。

#### 7.5 其他设计考虑
为了验证我们的特征提取是否有效，我们还尝试构建另一个基于 CNN 的特征提取器，直接从去噪传感器数据中提取特征，而不对指尖触控行为进行特征化。我们采用了类似的模型结构（见表 2），并使用去噪传感器数据的功率谱矩阵作为输入来预训练模型以区分不同用户。然后，我们通过将去噪传感器数据的功率谱矩阵输入模型来进行端到端特征学习以提取特征。

图 12(a) 显示了使用 CNN 实现端到端特征学习时的 ROC 曲线。在训练数据集大小为 500 时，其最佳 BAC 为 61.10%。而在我们设计的指尖触控行为特征化方法（第 3.2 节）下，仅用 50 个训练数据点即可达到 93.11% 的 BAC。结果表明，指尖触控行为特征化的步骤显著减少了对更深模型和更多训练数据点的依赖。

我们还评估了一种利用深度学习分类模型的方法 [23]。我们使用了 ALOCC 模型 [60]，该模型结合了生成对抗网络和自编码器以实现单类分类。该模型在训练阶段结合这两个网络来学习输入的自分布。它通过比较输入和输出之间的距离与阈值来确定数据点是否为异常值。在我们的实验中，该模型的输入是加速度和旋转角度的功率谱矩阵。

---

希望这些修改能使你的文本更加清晰、连贯和专业。如果有任何进一步的调整需求，请告诉我！