Custom Processing Unit:
Tracing and Patching Intel Atom Microcode
Black Hat USA 2022
Pietro Borrello
Sapienza University of Rome
Martin Schwarzl
Graz University of Technology
Michael Schwarz
CISPA Helmholtz Center for Information Security
Daniel Gruss
Graz University of Technology
Outline
1. Deep dive on CPU µcode
1
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Outline
1. Deep dive on CPU µcode
2. µcode Software Framework
1
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Outline
1. Deep dive on CPU µcode
2. µcode Software Framework
3. Reverse Engineering of the secret µcode update algorithm
1
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Outline
1. Deep dive on CPU µcode
2. µcode Software Framework
3. Reverse Engineering of the secret µcode update algorithm
4. Some bonus content ;)
1
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Disclaimer
• This is based on our understanding of CPU Microarchitecture.
• In theory, it may be all wrong.
• In practice, a lot seems right.
2
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
How do CPUs work?
3
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Positive Technologies Results
• Red Unlock of Atom Goldmont (GLM) CPUs
4
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Positive Technologies Results
• Red Unlock of Atom Goldmont (GLM) CPUs
• Extraction and reverse engineering of GLM µcode format
4
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Positive Technologies Results
• Red Unlock of Atom Goldmont (GLM) CPUs
• Extraction and reverse engineering of GLM µcode format
• Discovery of undocumented control instructions to access
internal buffers
4
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Microcoded Instuctions 101
. . .
cpuid
. . .
. . .
. . .
. . .
XLAT
5
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Microcoded Instuctions 101
. . .
cpuid
. . .
. . .
. . .
. . .
XLAT
µcode ROM
seqw
ROM
5
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Microcoded Instuctions 101
. . .
cpuid
. . .
. . .
. . .
. . .
XLAT
µcode ROM
seqw
ROM
µcode RAM
seqw
RAM
5
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Microcoded Instuctions 101
. . .
cpuid
. . .
. . .
. . .
. . .
XLAT
µcode ROM
seqw
ROM
µcode RAM
seqw
RAM
match & patch
5
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode instruction
OP1
09282eb80236
OP2
0008890f8009
OP3
092830f80236
SEQW
0903e480
6
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Deep Dive into the µcode
U1a54: 09282eb80236
CMPUJZ_DIRECT_NOTTAKEN(tmp6, 0x2, U0e2e)
U1a55: 0008890f8009
tmp8:= ZEROEXT_DSZ32(0x2389)
U1a56: 092830f80236
SYNC-> CMPUJZ_DIRECT_NOTTAKEN(tmp6, 0x3, U0e30)
U1a57: 000000000000
NOP
SEQW:
0903e480
SEQW GOTO U03e4
7
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Building a Ghidra µcode Decompiler
8
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Building a Ghidra µcode Decompiler
8
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Control Registers Bus
• CPU interacts with its internal components through the CRBUS
9
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Control Registers Bus
• CPU interacts with its internal components through the CRBUS
• MRSs → CRBUS addr
9
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Control Registers Bus
• CPU interacts with its internal components through the CRBUS
• MRSs → CRBUS addr
• Control and Status registers
9
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Control Registers Bus
• CPU interacts with its internal components through the CRBUS
• MRSs → CRBUS addr
• Control and Status registers
• SMM configuration
9
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Control Registers Bus
• CPU interacts with its internal components through the CRBUS
• MRSs → CRBUS addr
• Control and Status registers
• SMM configuration
• Local Direct Access Test (LDAT) access
9
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Accessing the µcode Sequencer
• The µcode Sequencer manages the access to µcode ROM and
RAM
10
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Accessing the µcode Sequencer
• The µcode Sequencer manages the access to µcode ROM and
RAM
→ The LDAT has access to the µcode Sequencer
10
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Accessing the µcode Sequencer
• The µcode Sequencer manages the access to µcode ROM and
RAM
→ The LDAT has access to the µcode Sequencer
→ We can access the LDAT through the CRBUS
10
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Accessing the µcode Sequencer
• The µcode Sequencer manages the access to µcode ROM and
RAM
→ The LDAT has access to the µcode Sequencer
→ We can access the LDAT through the CRBUS
→ If we can access the CRBUS we can control µcode!
10
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
udbgrd and udbgwr
Positive Technologies discovered the existance of two secret
instructions that can access (RW):
• System agent
• URAM
• Staging buffer
• I/O ports
• Power supply unit
11
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
udbgrd and udbgwr
Positive Technologies discovered the existance of two secret
instructions that can access (RW):
• System agent
• URAM
• Staging buffer
• I/O ports
• Power supply unit
• CRBUS
11
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
e.g., Writing to the CRBUS
def CRBUS _WRITE(ADDR , VAL):
udbgwr(
rax: ADDR ,
rbx|rdx: VAL ,
rcx: 0,
)
12
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Program LDAT from the CRBUS
// Decompile
of: U2782
- part
of
ucode
update
routine
w r i t e 8 ( crbus 06a0 , ( ucode address − 0 x7c00 ) ) ;
MSLOOPCTR = (∗( ushort
∗) (( long ) u cod e u p d a t e p t r + 3) − 1) ;
syncmark ( ) ;
i f
( ( i n u c o d e u s t a t e & 8) != 0)
{
s y n c f u l l ( ) ;
w r i t e 8 ( crbus 06a1 ,0 x30400 ) ;
u cod e p tr = ( ulong
∗) (( long ) u cod e u p d a t e p t r + 5) ;
do {
ucode qword = ∗ ucode ptr ;
u cod e p tr = ucode ptr + 1;
w r i t e 8 ( crbus 06a4 , ucode qword ) ;
w r i t e 8 ( crbus 06a5 , ucode qword >> 0x20 ) ;
syncwait ( ) ;
MSLOOPCTR −= 1;
}
while
(−1 > 32
CRBUS [0 x6a1] = 0
with
SELECTOR:
2 -> SEQW
PATCH RAM
3 -> MATCH & PATCH
4 -> UCODE
PATCH RAM
14
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Match & Patch 101
Redirects execution from µcode ROM to µcode RAM to execute patches.
patch_off = (patch_addr - 0x7c00) / 2;
entry:
+--+-----------+------------------------+----+
|3e| patch_off |
match_addr
|enbl|
+--+-----------+------------------------+----+
24
16
1
0
15
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
The first µcode Framework
Leveraging udbgrd/wr we can patch µcode via software
16
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
The first µcode Framework
Leveraging udbgrd/wr we can patch µcode via software
• Completely observe CPU behavior
16
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
The first µcode Framework
Leveraging udbgrd/wr we can patch µcode via software
• Completely observe CPU behavior
• Completely control CPU behavior
16
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
The first µcode Framework
Leveraging udbgrd/wr we can patch µcode via software
• Completely observe CPU behavior
• Completely control CPU behavior
• All within a BIOS or kernel module
16
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode Framework
Patch µcode
17
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode Framework
Patch µcode
Hook µcode
17
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode Framework
Patch µcode
Hook µcode
Trace µcode
17
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode patches
We can change the CPU’s behavior.
18
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode patches
We can change the CPU’s behavior.
• Change microcoded instructions
18
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode patches
We can change the CPU’s behavior.
• Change microcoded instructions
• Add functionalities to the CPU
18
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode patch Hello World!
.patch 0x0428 # RDRAND ENTRY POINT
.org 0x7c00
rax:= ZEROEXT_DSZ64(0x6f57206f6c6c6548) # ‘Hello Wo’
rbx:= ZEROEXT_DSZ64(0x21646c72) # ‘rld!\x00’
UEND
19
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode patch Hello World!
.patch 0x0428 # RDRAND ENTRY POINT
.org 0x7c00
rax:= ZEROEXT_DSZ64(0x6f57206f6c6c6548) # ‘Hello Wo’
rbx:= ZEROEXT_DSZ64(0x21646c72) # ‘rld!\x00’
UEND
1. Assemble µcode
2. Write µcode at 0x7c00
3. Setup Match & Patch: 0x0428 → 0x7c00
4. rdrand → “Hello World!”
19
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Make rdrand less boring
rdrand returns random data, what if we make it return SMM memory?
.patch 0x0428 # RDRAND ENTRY POINT
.org 0x7c00
tmp1:= MOVEFROMCREG_DSZ64(CR_SMRR_MASK)
tmp2:= ZEROEXT_DSZ64(0x0)
MOVETOCREG_DSZ64(tmp2, CR_SMRR_MASK) # DISABLE SMM MEMORY RANGE
rax:= LDPPHYS_DSZ64(0x7b000000) # SMROM ADDR
MOVETOCREG_DSZ64(tmp1, CR_SMRR_MASK)
UEND
20
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Make rdrand less boring
rdrand returns random data, what if we make it return SMM memory?
.patch 0x0428 # RDRAND ENTRY POINT
.org 0x7c00
tmp1:= MOVEFROMCREG_DSZ64(CR_SMRR_MASK)
tmp2:= ZEROEXT_DSZ64(0x0)
MOVETOCREG_DSZ64(tmp2, CR_SMRR_MASK) # DISABLE SMM MEMORY RANGE
rax:= LDPPHYS_DSZ64(0x7b000000) # SMROM ADDR
MOVETOCREG_DSZ64(tmp1, CR_SMRR_MASK)
UEND
20
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Make rdrand less boring
rdrand returns random data, what if we make it return SMM memory?
.patch 0x0428 # RDRAND ENTRY POINT
.org 0x7c00
tmp1:= MOVEFROMCREG_DSZ64(CR_SMRR_MASK)
tmp2:= ZEROEXT_DSZ64(0x0)
MOVETOCREG_DSZ64(tmp2, CR_SMRR_MASK) # DISABLE SMM MEMORY RANGE
rax:= LDPPHYS_DSZ64(0x7b000000) # SMROM ADDR
MOVETOCREG_DSZ64(tmp1, CR_SMRR_MASK)
UEND
20
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Make rdrand less boring
rdrand returns random data, what if we make it return SMM memory?
.patch 0x0428 # RDRAND ENTRY POINT
.org 0x7c00
tmp1:= MOVEFROMCREG_DSZ64(CR_SMRR_MASK)
tmp2:= ZEROEXT_DSZ64(0x0)
MOVETOCREG_DSZ64(tmp2, CR_SMRR_MASK) # DISABLE SMM MEMORY RANGE
rax:= LDPPHYS_DSZ64(0x7b000000) # SMROM ADDR
MOVETOCREG_DSZ64(tmp1, CR_SMRR_MASK)
UEND
20
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
DEMO
µcode hooks
Install µcode hooks to observe events.
• Setup Match & Patch to execute custom µcode at certain
events
• Resume execution
21
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Make your own performance counter
We can make the CPU to react to certain µcode events, e.g., verw executed
.patch 0xXXXX # INSTRUCTION ENTRY POINT
.org 0x7da0
tmp0:= ZEROEXT_DSZ64()
tmp1:= LDPPHYSTICKLE_DSZ64_ASZ64_SC1(tmp0)
tmp1:= ADD_DSZ64(tmp1, 0x1) # INCREMENT COUNTER
STADPPHYSTICKLE_DSZ64_ASZ64_SC1(tmp0, tmp1)
UJMP(0xXXXX + 1) # JUMP TO NEXT UOP
22
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
Make your own performance counter
We can make the CPU to react to certain µcode events, e.g., verw executed
.patch 0xXXXX # INSTRUCTION ENTRY POINT
.org 0x7da0
tmp0:= ZEROEXT_DSZ64()
tmp1:= LDPPHYSTICKLE_DSZ64_ASZ64_SC1(tmp0)
tmp1:= ADD_DSZ64(tmp1, 0x1) # INCREMENT COUNTER
STADPPHYSTICKLE_DSZ64_ASZ64_SC1(tmp0, tmp1)
UJMP(0xXXXX + 1) # JUMP TO NEXT UOP
22
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode traces
Trace µcode execution leveraging hooks.
cpuid
?
µcode
hook:
1.
dump timestamp
2.
disable hook
3.
continue
23
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode traces
Trace µcode execution leveraging hooks.
cpuid
?
µcode
hook:
1.
dump timestamp
2.
disable hook
3.
continue
23
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode traces
Trace µcode execution leveraging hooks.
cpuid
?
µcode
hook:
1.
dump timestamp
2.
disable hook
3.
continue
23
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode traces
Trace µcode execution leveraging hooks.
cpuid
?
µcode
hook:
1.
dump timestamp
2.
disable hook
3.
continue
23
Pietro Borrello (@borrello pietro)
Martin Schwarzl (@marv0x90)
µcode traces