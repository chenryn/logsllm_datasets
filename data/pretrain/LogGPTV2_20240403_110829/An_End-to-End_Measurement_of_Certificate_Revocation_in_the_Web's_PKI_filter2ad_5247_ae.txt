certiﬁcates have CRLs or OCSP responders listed.
If the
revocation information is not available for the ﬁrst interme-
diate certiﬁcate (or the leaf certiﬁcate if no intermediates
exist), Opera rejects the certiﬁcate on all platforms (if using
CRLs) and only on Linux and Windows (if using OCSP);
in all other cases, Opera accepts the certiﬁcate. Opera in-
correctly treats OCSP responses with the unknown status
as trusted. Opera requests OCSP staples on all platforms;
however, on OS X (similar to Chrome) Opera does not re-
spect revoked staples and attempts to contact the OCSP
responder directly.
Safari. We examined the three most recent major versions
of Safari (6.0–8.0) and found them all to have the same be-
havior.22 Safari checks all certiﬁcates in the chain using
CRLs or OCSP. Safari incorrectly treats OCSP responses
with the unknown status as trusted. Safari does attempt
to fetch the CRL if the OCSP responder is unavailable. If
the revocation information is not available for the ﬁrst in-
termediate certiﬁcate (or the leaf certiﬁcate, if there are no
intermediates) and the certiﬁcate has a CRL, Safari rejects
the certiﬁcate; in all other cases, it accepts the certiﬁcate.
Safari does not request OCSP staples.
OS X oﬀers system-wide settings via Keychain Access that
allow users to change certiﬁcate revocation checking behav-
ior. The default behavior, which we used in our above analy-
sis, is referred to as “Best attempt”. If a user selects “Require
if certiﬁcate indicates”, Safari does indeed reject all chains
where any of the revocation information is unavailable.
Internet Explorer. We tested every major version of In-
ternet Explorer (IE) between 7.0 (on Vista) to 11.0 (on Win-
dows 10, 8.1, and 7). We found that the behavior of IE
changed between version 9.0 and 10.0, and again with IE
11.0; we therefore consider them separately.
20We must create separate VMs for each browser/OS, as some
browsers use system-wide libraries and daemons for checking revo-
cation information, which can lead to caching eﬀects at the OS level.
21Firefox contains a hardcoded list of root certiﬁcates that are
allowed to issue EV certiﬁcates. We recompiled Firefox 40.0 after
adding our root certiﬁcate to Firefox’s list.
22We observed strange behavior with the most recent Safari/OS
X update (8.0.5/10.0.3). With this update, Safari does not check
any CRLs and only checks OCSP responders for EV certiﬁcates. The
release notes do not mention any SSL policy changes, so we believe
this behavior to be a bug; we have ﬁled a bug report with Apple.
On IE 7.0–9.0, IE checks all certiﬁcates in the chain for
both CRLs and OCSP responders. If the OCSP responder
is unavailable, IE does download the CRL. If the revoca-
tion information is not available for the ﬁrst certiﬁcate in
the chain, IE rejects the certiﬁcate; in all other cases, IE ac-
cepts the certiﬁcate. IE incorrectly treats OCSP responses
with the unknown status as trusted. IE does request OCSP
staples.
On IE 10.0, IE has the same behavior except that when
revocation information is not available for the leaf certiﬁcate,
IE pops up a warning to the user and asks them if they wish
to proceed.
On IE 11.0, IE has the same behavior except that when
revocation information is not available for the leaf certiﬁ-
cate, IE correctly rejects the certiﬁcate without popping up
a warning.
In summary, we observe that no browser in its default con-
ﬁguration correctly checks all revocations and rejects certiﬁ-
cates if revocation information is unavailable (as described
in §2.2). In fact, many browsers do not bother to check re-
vocation information at all. Overall, Internet Explorer per-
forms the most checks, followed closely by Safari and newer
versions of Opera.
We also found that many browsers do not correctly in-
terpret unknown OCSP responses, not all browsers support
OCSP Stapling, and many do not understand revoked sta-
ples. This is surprising, as OCSP Stapling is the most ef-
ﬁcient way of obtaining certiﬁcate revocation information,
and it imposes almost no extra latency on clients.
6.4 Mobile Browsers
Next, we study the certiﬁcate revocation checking behav-
ior of browsers on mobile devices. To make the tests easier
to conduct, we use the device simulators provided by the OS
vendors where possible, rather than physical devices. These
simulators run a full version of the mobile OS, allowing us
to easily test multiple versions.
iOS. We begin by checking the behavior of Mobile Safari on
iOS. We used the Xcode-based iOS simulator to test iOS 7
and 8, and use a physical iPhone 3GS device for iOS 6.23
We observe that Mobile Safari does not check any certiﬁcate
revocation information, nor does it request OCSP staples.
Android. We test the certiﬁcate revocation checking be-
havior of Android by using the Android Emulator. We test
the “stock” Browser app and Chrome on the three most re-
cent versions of Android: Lollipop (5.1), KitKat (4.4), and
Jelly Bean (4.3). Similar to iOS, we ﬁnd that neither appli-
cation checks any certiﬁcate revocation information. How-
ever, by examining the network traﬃc, we found that both
applications do request OCSP staples, but do not use them
in certiﬁcate validation. Even when served an OCSP staple
with status revoked, both applications validate the certiﬁ-
cate and continue with the connection.
We also attempted to test the Android port of the Firefox
browser, but were unable to successfully import our root
certiﬁcate into the application.
Windows Phone. Finally, we tested the mobile version
of IE running on Windows Phone 8.0 using the Windows
23The iPhone simulator for iOS 6 does not provide an option for
Phone Emulator. Mobile IE performs identically to all other
tested browsers, not checking revocation information and
not requesting OCSP staples.
Overall, our results on mobile devices are disheartening. De-
spite the increasing fraction of web traﬃc that is generated
by these devices, none of the major web browsers bother to
check whether any certiﬁcates they are presented with are
revoked. This design decision is likely driven by the higher
cost (in terms of latency and power) of obtaining revocation
information on a mobile device [20]. However, this decision
does not excuse the universal lack of proper OCSP Stapling
support, as requesting OCSP staples for the leaf certiﬁcate
requires the client to create no additional connections.
6.5 Summary
If clients do not fetch and respect revocation information,
the revocation eﬀorts of website administrators and CAs are
wasted. To analyze client behavior, this section presented
our test suite, and the results from all major desktop and
mobile browsers. While we see widely disparate behavior—
often even among the same browser on diﬀerent platforms—
we ﬁnd that no browser meets all necessary criteria for re-
vocation checking. Moreover, we empirically demonstrate
the extent to which EV certiﬁcates are validated diﬀerently.
Perhaps most concerning is the fact that no mobile browsers
check for revocations at all.
For desktop browsers, it is diﬃcult to determine whether
the absence of revocation checking is an explicit design de-
cision or a set of common bugs. For mobile browsers, on
the other hand, we believe the complete lack of revocation
checking is an explicit decision to conserve users’ bandwidth.
7. CRLSETS
In response to the cost of obtaining revocation informa-
tion, Google adopted an additional approach in 2013 called
CRLSets [26]. Chrome checks a small, pre-populated list of
revoked certiﬁcates. This list is updated and sent to clients
out-of-band, thus eliminating the cost of checking revocation
information at page load time.
In this section, we characterize CRLSets and investigate
their impact on security in the face of revocations. While
CRLSets currently aﬀect only users of the Chrome browser,
this approach has recently been adopted by Firefox in the
OneCRL [41] project24, so understanding the implications
of this approach can have a signiﬁcant impact on a large
number of web users.
7.1 Overview and Methodology
The high-level CRLSet approach is documented [2], but
the process used for generating them is not public. Impor-
tantly, the developers state that: (1) the size of the CRLSet
ﬁle is capped at 250 KB; (2) they populate it using an “in-
ternal list of crawled CRLs” (some of which are not public)
fetched on the order of hours; (3) if a CRL has too many
entries it will be dropped from the CRLSet; and (4) revoca-
tions are included only if they use one of a small number of
reason codes25 (we refer to these as CRLSet reason codes).
CRLSet ﬁles are published to a public URL and fetched
periodically by Chrome. We fetched these ﬁles once per
24In contrast to CRLSets, OneCRL is for intermediate certiﬁcates.
As of this writing, there are only 8 revoked certiﬁcates on the list.
25No reason code, Unspeciﬁed, KeyCompromise, CACompromise,
installing root certiﬁcates.
or AACompromise
Figure 7: Cumulative distribution of the fraction of a CRL’s
entries that appear in CRLSets. Also shown are just those entries
that have CRLSet reason codes. Most certiﬁcates with “valid”
reasons are included the CRLSet, but most CRL entries overall
are missing.
Figure 8: Number of entries in the CRLSet over time (note that
the y-axis does not start at 0). The peak of nearly 25,000 entries
is due to the Heartbleed vulnerability; since then the size of the
CRLSet has decreased over time by more than a third.
day between September 23, 2014 and March 31, 2015, and
crawled 110 historical CRLSets originally published between
July 18th, 2013 and September 23, 2014; in total our dataset
contains 300 unique CRLSets. CRLSets are internally or-
ganized as a list of key/value pairs, where the key is the
SHA256 of the certiﬁcate issuer’s public key (which we call
the parent), and the values for that key are all the serial
numbers of revoked certiﬁcates signed by that parent.26
Mapping a revoked certiﬁcate in a CRLSet to a CRL is
nontrivial because CAs can have multiple signing certiﬁ-
cates, public keys, and CRLs. When comparing CRLSet
entries with CRLs (using the data described in §3.2), we
compare the entries in the CRLSet for each parent with the
entries in all CRLs for certiﬁcates signed by that parent.
7.2 CRLSet Coverage
We ﬁrst determine the fraction of CAs covered by
CRLSets. In our CRL dataset, we see 2,168 CA certiﬁcates
(both intermediate and root) with 1,584 distinct public keys.
In CRLSets, we observe 62 unique parents. Thus, CRLSets
cover revocations for only 3.9% of CA certiﬁcates.27 Of those
62, we can only map 52 to a CA certiﬁcate that we know of;
the remainder are likely from non-public CA certiﬁcates.
Next, we investigate how entries in CRLSets compare with
those in CRLs. Across all CRLs we crawled, we observe
11,461,935 revoked certiﬁcates; only 41,105 of these appear
in CRLSets. Thus, only 0.35% of all revoked certiﬁcates
ever appear in the CRLSet. Additionally, of the 2,800 total
CRLs we observed, only 295 (10.5%) have ever had any entry
appear in a CRLSet (this number is larger than the number
of parents, as a given parent can sign multiple CRLs). We
refer to these CRLs as covered CRLs.
Covered CRLs. For the covered CRLs, we examine the
fraction of their entries that appear in the CRLSet. Fig-
ure 7 presents the cumulative distribution of CRLSet cov-
erage across covered CRLs. Since the Chromium project
states that only revocations with a certain reason codes will
26CRLSets also include a small set of leaf certiﬁcates that are ex-
plicitly blocked based on their public key; this list is called BlockedSP-
KIs. The list current contains 11 such certiﬁcates. Curiously, Chrome
44.0 declares these certiﬁcates as revoked in the URL Status Bar, but
still completes the connection and renders the page. For an example,
please see https://revoked.grc.com/ and the corresponding discus-
sion [8]. We have ﬁled a bug with the Chrome developers regarding
this behavior.
27We cannot say precisely what fraction of CAs are represented in
CRLSets, as CAs often have many keys.
appear in the CRLSet, we also plot the cumulative distribu-
tion of coverage only for entries with CRLSet reason codes
as well.
We ﬁnd that for 75.6% of covered CRLs, all entries with
CRLSet reason codes appear in the CRLSet. For the re-
maining CRLs, we ﬁnd that the number of entries with
CRLSet reason codes missing ranges from 1 to 5,826 (the
latter comes from Verisign’s “International EV” CRL, mak-
ing it especially strange). Overall, we observe that for most
covered CRLs, CRLSets provide perfect coverage; however,
there are many CRLs for which CRLSets provide only par-
tial coverage.
Un-covered Revocations. We now address the question
of what certiﬁcates are not included in CRLSets. While
there are millions of revoked certiﬁcates that do not ap-
pear in CRLSets, we focus on those that belong to popular
websites, since they will impact the largest fraction of In-
ternet traﬃc. Across all Alexa top one million domains,
we see 42,225 revocations in CRLs, but only 1,644 (3.9%) in
CRLSets. If we focus on the Alexa top 1,000 domains, we see
392 revoked certiﬁcates, but only 41 (10.4%) ever appear in
CRLSets. Thus, unless these sites use EV certiﬁcates (which
cause Chrome to perform the revocation checks described
above), certiﬁcates presented by the many of the most pop-
ular domains are left unchecked by Chrome’s CRLSets.
7.3 CRLSet Dynamics
We now examine CRLSet dynamics, and begin by inves-
tigating how the CRLSet size changes over time. Figure 8
shows that the number of entries in CRLSets ranges from
15,922 to 24,904, with the peak corresponding to the Heart-
bleed vulnerability, followed by a decrease over the following
year. The signiﬁcant decrease in May–June 2014 is largely
explained by the removal of the “VeriSign Class 3 Extended
Validation” parent (and its 5,774 entries) from the CRLSet,
and general downward trend corresponds with the behavior
of the underlying CRLs.
To better understand the dynamics of CRLSet entries, we
zoom in on the number of entries added and removed from
the CRLSet each day, and limit ourselves to the time period
of October 1, 2014 to March 31, 2015 where we have daily
scans of both CRLSet ﬁles and CRL entries. Figure 9 shows
this, using a log scale on the y-axis. We observe that CRLs
exhibit weekly patterns, with increased activity during the
week and lulls during the weekend. We also observe that
CRLSets are updated frequently, but there is a noticeable
 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.2 0.4 0.6 0.8 1CDFFraction of CRLs’ Entries in CRLSetCRLSet Reason CodesAll Revocations 15000 16000 17000 18000 19000 20000 21000 22000 23000 24000 25000SepNovJanMarMayJulSepNovJanMarNumber of Entries in CRLSetDate (2013-2015)Figure 9: Number of daily new revocations appearing in CRLs
(upper line) and CRLSets (lower line). CRL additions show
weekly patterns and are much larger than CRLSet additions. For
two weeks in late 2014, we observed no additions to CRLSets.
gap with no additions in November–December 2014. Other-
wise we observe no direct correlation between peaks/troughs
in CRL and CRLSet updates, consistent with the fact that
CRLSets track only a small subset of the CRLs.
Lastly, we focus on the security impact of CRLSet dynam-
ics, speciﬁcally for the set of revocations that appear in both
CRLs and CRLSets. We focus on periods of time when a cer-
tiﬁcate appears in a CRL but not in the CRLSet (687 cases
in our dataset), or was removed from a CRLSet before the
revoked certiﬁcate expired (629 cases in our dataset). We
refer to these as periods of vulnerability. Figure 10 shows
this using the cumulative distribution of days of vulnerabil-
ity over all certiﬁcates that appeared in CRLSets. We ﬁnd
that most revoked certiﬁcates appear in the CRLSets within
one day (60%), and more than 90% appear within two days.
This suggests that an automated process pulls CRL data
into CRLSets, and thus there is a relatively small window
of vulnerability after a revocation occurs.28
However, we observe that revoked certiﬁcates are some-
times removed from the CRLSet hundreds of days before
they expire. This result is due to the signiﬁcant decrease
in CRLSet size seen in Figure 8.
In one case, a revoked
CA cert was removed from the CRLSet that is valid until
the year 2020. In the median case, revocations are removed
from CRLSets 187 days before the certiﬁcate expires.
7.4 Improving CRLSets: Bloom Filters
As we have shown, Google’s CRLSet implementation has
very low coverage. An alternative data structure that could
hold more revocations while also obeying Google’s strict size
constraints is a Bloom Filter [4]. A Bloom Filter has the ad-
vantage of no false negatives (if a certiﬁcate is revoked, it will
be ﬂagged as revoked by the ﬁlter); however, it will produce
a tunable false positive rate (a non-revoked certiﬁcate may
be ﬂagged as revoked). Thus, when a certiﬁcate “hits” the
ﬁlter, the client would need to check a CRL before ﬂagging
the connection as insecure. Although checking CRLs intro-
duces lag, this lag would only impact performance for false
positives (since true positives should be blocked anyway).
Also note that the size of the Bloom Filter would depend on