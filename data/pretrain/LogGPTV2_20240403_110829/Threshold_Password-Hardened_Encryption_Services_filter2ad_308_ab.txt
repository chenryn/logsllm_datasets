0, ğœ), skâ€²
1, . . . , skâ€²
ğ‘š) â† Rotate
(cid:42) S(â€œrotâ€, sk0),
R1(â€œrotâ€, sk1),
Rğ‘š(â€œrotâ€, skğ‘š)
. . . ,
(cid:43)
:
The rotation protocol is run between the server and all ğ‘š rate-
limiters. Each party inputs its secret key and outputs a rotated key.
The server additionally outputs an update token ğœ.
ğ¶â€² â† Udt(ğœ, ğ‘›, ğ¶):
The update algorithm inputs an update token ğœ, a nonce ğ‘›, and a
ciphertext ğ¶. It outputs a new ciphertext ğ¶â€².
Correctness. Correctness is defined in the obvious way and the
formal definition is omitted. Roughly speaking, a (ğ‘¡, ğ‘š)-PHE is
correct whenever all honestly generated ciphertexts can be success-
fully decrypted to recover the encrypted message with the correct
password, at long as at least ğ‘¡ rate-limiters participate in the de-
cryption protocol. Moreover, if a ciphertext passes decryption with
respect to some secret keys, then the updated ciphertext also passes
decryption with respect to the rotated keys.
Remarks. Our model requires a trusted party to run the setup
algorithm. In a typical application of (ğ‘¡, ğ‘š)-PHE it is acceptable to
let the server run the setup algorithm, send the rate-limiter keys
to the respective rate-limiters, and securely delete those keys. This
is because it is for the serverâ€™s own benefit to employ a (ğ‘¡, ğ‘š)-
PHE scheme in the first place. Moreover, the rate-limiters do not
contribute any private inputs other than their secret keys in any
protocols. If we insist that the server cannot be trusted to run the
setup, a standard solution is to emulate the setup using a secure
multi-party computation (MPC) protocol.
In our syntax, we handle the nonces differently compared to the
approach in previous work [12]. We believe that the new approach
models the reality more closely and is more intuitive. Previously, the
encryption and decryption protocols take a â€œlabelâ€ as common input
for both the server and the rate-limiter, where the label consists of a
server-side nonce and a rate-limiter-side nonce. This model deviates
from the reality where the nonce is generated during (instead of
before) the encryption protocol, stored by the server, and sent to the
rate-limiter during decryption. More confusingly, the label input to
the encryption protocol is by default an empty string, unless it is
called in the forward security experiment.
2.1 Security of (ğ‘¡, ğ‘š)-PHE
We define the hiding and soundness properties of (ğ‘¡, ğ‘š)-PHE. We
assume that each rate-limiter has an authenticated channel to the
server and that the rate limiters are not aware of each other, i.e., for
ğ‘– â‰  ğ‘—, there may not exist any communication channel between Rğ‘–
and R ğ‘—. We focus on a semi-adaptive corruption model, where the
adversary must declare the set of corrupt parties for the next time
period, where a time period is the time between two honest key-
rotations. The possibility to corrupt parties during a time period
is modeled in the oracle RotateO, where the adversary can set
HonestRot to 1 and define a set ğ¼ for which he wishes to learn the
private-keys.
This corruption model is already stronger than that in previous
work [12, 13], where the adversary must declare the corrupt party at
the very beginning of the experiment, and cannot change its choice
throughout the experiment. For completeness, we also define a fully
adaptive variant, where the adversary can request to corrupt any
party at any time.
2.1.1 Hiding. Intuitively, hiding models the property that no party
should be able to do better than online brute force attacks against
the password space. As passwords have limited entropy, we limit
the adversaryâ€™s decryption queries using the counter DecCount
3
UdtO, ChOğ‘, DecChO}
(sk0, . . . , skğ‘š) â† Setup(1ğœ†, 1ğ‘š, 1ğ‘¡)
Î ,A,ğ‘„Dec,PW(1ğœ†, 1ğ‘š, 1ğ‘¡ , ğ¼)
ensure |ğ¼ âˆ© [ğ‘š]| < ğ‘¡ âˆ¨ 0 âˆ‰ ğ¼
IsChallenged := 0, ğœ := ğœ–, DecCount := 0
Hidğ‘
1 :
2 :
3 : CorruptParties := ğ¼
4 :
5 : O := {EncO, DecO, CorrO , RotateO,
6 :
7 : ğ‘â€² â† AO(1ğœ†, {skğ‘– }ğ‘–âˆˆğ¼)
8 :
9 :
EncO(pw, ğ‘€, ğ¼, {Pğ‘–}ğ‘–âˆˆğ¼)
1 :
2 : Sâˆ— := if 0 âˆˆ ğ¼ then PO
0 else := S(â€œencâ€, sk0, pw, ğ‘€)
3 : Râˆ—
ğ‘– else Rğ‘– (â€œencâ€, skğ‘–) âˆ€ğ‘– âˆˆ [ğ‘š]
ğ‘– := if ğ‘– âˆˆ ğ¼ then PO
((ğ‘›, ğ¶; view0), (âˆ—; view1), . . . , (âˆ—; viewğ‘š)) â† âŸ¨Sâˆ—, Râˆ—
4 :
return (ğ‘›, ğ¶, viewğ¼)
5 :
if DecCount â‰¥ ğ‘„Dec then ğ‘â€² â†$ {0, 1}
return ğ‘â€²
ensure ğ¼ âŠ† CorruptParties
1, . . . , Râˆ—
ğ‘šâŸ©
1, . . . , Râˆ—
ğ‘šâŸ©
0 else := S(â€œdecâ€, sk0, pw, ğ‘›0, ğ¶)
ğ‘– else Rğ‘– (â€œdecâ€, skğ‘–, ğ‘›) âˆ€ğ‘– âˆˆ [ğ‘š]
DecO(pw, ğ‘›0, ğ¶, ğ¼, {Pğ‘–}ğ‘–âˆˆğ¼)
ensure ğ¼ âŠ† CorruptParties
1 :
2 : Sâˆ— := if 0 âˆˆ ğ¼ then PO
3 : Râˆ—
ğ‘– := if ğ‘– âˆˆ ğ¼ then PO
((ğ‘€; view0), (ğ‘›1; view1), . . . , (ğ‘›ğ‘š; viewğ‘š)) â† âŸ¨Sâˆ—, Râˆ—
4 :
5 : ğ‘0 := (0 âˆˆ ğ¼ âˆ¨ ğ‘›0 = ğ‘›âˆ—)
6 : ğ‘1 := (|ğ¼ âˆ© [ğ‘š]| + |{ğ‘– : ğ‘›ğ‘– = ğ‘›âˆ—}| â‰¥ ğ‘¡)
7 :
8 :
if ğ‘0 âˆ§ ğ‘1 then DecCount := DecCount + 1
return (ğ‘€, viewğ¼)
DecChO(ğ¶, ğ¼, {Pğ‘–}ğ‘–âˆˆğ¼)
1 :
2 : Sâˆ— := S(â€œdecâ€, sk0, pwâˆ—, ğ‘›âˆ—, ğ¶)
3 : Râˆ—
4 :
5 :
ğ‘– := if ğ‘– âˆˆ ğ¼ then PO
((âˆ—; view0), . . . , (âˆ—; viewğ‘š)) â† âŸ¨Sâˆ—, Râˆ—
return viewğ¼
ensure IsChallenged = 1 âˆ§ ğ¼ âŠ† CorruptParties \ {0}
ğ‘– else Rğ‘– (â€œdecâ€, skğ‘–, ğ‘›) âˆ€ğ‘– âˆˆ [ğ‘š]
1, . . . , Râˆ—
ğ‘šâŸ©
1, . . . , Râˆ—
ğ‘šâŸ©
if HonestRot = 1 then // Honest rotation then corruption
ensure |ğ¼ âˆ© [ğ‘š]| < ğ‘¡ âˆ¨ 0 âˆ‰ ğ¼
Sâˆ— := S(â€œrotâ€, sk0)
Râˆ—
ğ‘– := Rğ‘– (â€œrotâ€, skğ‘–) âˆ€ğ‘– âˆˆ [ğ‘š]
((sk0, ğœ), sk1, . . . , skğ‘š) â† âŸ¨Sâˆ—, Râˆ—
CorruptParties := ğ¼
return {skğ‘– }ğ‘–âˆˆğ¼
else // Malicious rotation
RotateO(HonestRot, ğ¼, {Pğ‘–}ğ‘–âˆˆğ¼)
1 :
2 :
3 :
4 :
5 :
6 :
7 :
8 :
9 :
10 :
11 :
12 :
13 :
14 :
15 :
âŸ¨Sâˆ—, Râˆ—
return viewğ¼
1, . . . , Râˆ—
ğ‘šâŸ©
endif
ensure ğ¼ âŠ† CorruptParties
Sâˆ— := if 0 âˆˆ ğ¼ then PO
Râˆ—
ğ‘– := if ğ‘– âˆˆ ğ¼ then PO
((sk0, ğœ; view0), (sk1; view1), . . . , (skğ‘š; viewğ‘š)) â†
0 else S(â€œrotâ€, sk0)
ğ‘– else Rğ‘– (â€œrotâ€, skğ‘–) âˆ€ğ‘– âˆˆ [ğ‘š]
CorrO(ğ‘–) Only available in fully adaptive variant
1 : CorruptPartiesâ€² := CorruptParties âˆª {ğ‘– }
2 :
3 : CorruptParties := CorruptPartiesâ€²
4 :
ensure |CorruptPartiesâ€² âˆ© [ğ‘š]| < ğ‘¡ âˆ¨ 0 âˆ‰ CorruptPartiesâ€²
return skğ‘–
ensure ğœ â‰  ğœ–
return ğ¶â€²
0 , ğ‘€âˆ—
UdtO(ğ‘›, ğ¶)
1 :
2 : ğ¶â€² â† Udt(ğœ, ğ‘›, ğ¶)
3 :
ChOğ‘(ğ‘€âˆ—
ensure IsChallenged = 0 âˆ§ ğ¼ âŠ† CorruptParties \ {0}
1 :
IsChallenged := 1, pwâˆ— â†$ PW
2 :
3 : Sâˆ— := S(â€œencâ€, sk0, pwâˆ—, ğ‘€âˆ—
ğ‘)
4 : Râˆ—
5 :
6 :
ğ‘– := if ğ‘– âˆˆ ğ¼ then PO
((ğ‘›âˆ—, ğ¶âˆ—), (âˆ—; view1), . . . , (âˆ—; viewğ‘š)) â† âŸ¨Sâˆ—, Râˆ—
return (ğ‘›âˆ—, ğ¶âˆ—, viewğ¼)
1 , ğ¼, {Pğ‘–}ğ‘–âˆˆğ¼)
ğ‘– else Rğ‘– (â€œencâ€, skğ‘–) âˆ€ğ‘– âˆˆ [ğ‘š]
1, . . . , Râˆ—
ğ‘šâŸ©
Figure 1: Hiding Experiment (Procedures in dashed boxes are provided for variant with fully adaptive corruption.)
which is bounded by ğ‘„Dec. At any given time, the adversary may
either corrupt the server and up to ğ‘¡ âˆ’1 rate limiters, or an arbitrary
subset of rate-limiters but not the server. It can also instruct the
parties to execute an honest key-rotation, after which all parties
are considered honest, and the adversary can corrupt a possibly
different subset of parties again.
The Oracles. The (encryption, decryption, key rotation, and cipher-
text update) oracles are formally defined in Figure 1. The oracles
interface protocol executions by inputting a set of adversarial proce-
dures and running the respective protocols with the codes of some
honest parties replaced. The encrypt and decrypt oracles EncO and
4
DecO model normal interactions with adversarially choosen mes-
sages resp. ciphertexts. The decrypt challenge oracle DecChO, in
contrast, allows the adversary to observe interactions between an
honest server and potentially malicious rate-limiters with the cor-
rect challenge password. The oracle RotateO allows the adversary
to request key-rotation. The adversary can request for an honest
key-rotation, where the update token remains secret, while the set
of corrupted parties is reset depending on the choice of the adver-
sary. The adversary can also request for a malicious key-rotation,
where the code of some parties are possibly replaced by malicious
ones. The oracle UdtO allows updating any ciphertext with the
most recent update token ğœ. In the fully adaptive variant, the ad-
versary gains access to an additional corrupt oracle CorrO from
which it can learn the current secret keys of parties of its choice.
Finally, the adversary can generate a challenge ciphertext using
ChO. Notice that the challenge may only be generated once3 and
the server code used to generate the challenge ciphertext is honest
(although the server key might be revealed via CorrO and RotateO).
Intuitively this is reasonable as a malicious server can store the mes-
sage and the password outside the protocol, and therefore security
for maliciously generated ciphertexts is unrealistic.
0
Hid
(cid:12)(cid:12)(cid:12) Pr(cid:104)
Pr(cid:104)
Definition 1 (Hiding). A (ğ‘¡, ğ‘š)-PHE Î  is semi-adaptively
hiding if, for any PPT adversary A, any integer ğ‘„Dec â‰¥ 0, and any
password space PW4 with support size of at least ğ‘„Dec,
1
2
Î ,A,ğ‘„Dec,PW(1ğœ†, 1ğ‘š, 1ğ‘¡) = 1(cid:105) âˆ’
Î ,A,ğ‘„Dec,PW(1ğœ†, 1ğ‘š, 1ğ‘¡) = 1(cid:105)(cid:12)(cid:12)(cid:12) â‰¤ ğ‘„Dec
|PW| + negl(ğœ†) .
The (ğ‘¡, ğ‘š)-PHE Î  is fully adaptively hiding if in Hid the adversary
A is given access to the CorrO oracle.
1
Hid
Soundness. Our definition of soundness is inspired by the
2.1.2
complete robustness definition [8] for encryption schemes, which
intuitively captures the property that a ciphertext cannot be encrypt-
ing two distinct messages. In [12], the soundness of PHE requires
that there is no inconsistency between an encryption session and a
decryption session, whereas the strong soundness notion further
requires that there is no inconsistency between two decryption
sessions. To unify both deception strategies, we define a sound-
ness experiment where the adversary is given an encryption and a
decryption oracle. The former takes as input all the inputs of the
server, including the randomness, during an encryption session,
and possibly malicious programs for all the rate-limiters. The oracle
then runs the encryption protocol between an honest execution
of the server code on the given input, and the possibly malicious
rate-limiters. The decryption oracle is defined in a similar way, ex-
cept that the decryption protocol is run. The adversary is successful
if an inconsistency occur between the communication transcripts
produced by any two oracle queries.
Definition 2 (Soundness). A (ğ‘¡, ğ‘š)-PHE Î  is sound if,
for any PPT adversary A,
0
Soundness
Pr(cid:104)
Î ,A(1ğœ†, 1ğ‘š, 1ğ‘¡) = 1(cid:105) â‰¤ negl(ğœ†) .
3 CONSTRUCTION
Our construction of a (ğ‘¡, ğ‘š)-PHE scheme can be seen as a gen-
eralization of the PHE scheme of [12], where a secret key of one
rate-limiter is shared to multiple rate-limiters. In contrast to [12] it