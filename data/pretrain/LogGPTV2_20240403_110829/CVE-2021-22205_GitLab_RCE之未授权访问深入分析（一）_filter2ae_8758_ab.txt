        "encoding/json"
    )
    //返回信息
    type Company struct {
        ID int
        Name string
        Country string
    }
    //权限认证中间件
    func AuthHandler(next http.Handler) http.Handler {
        //这里使用HandlerFunc将函数包装成了httpHandler并返回给LogHandler的next
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){
        //如果没有嵌套中间件则使用默认的DefaultServeMux
        if next == nil {
            next = http.DefaultServeMux
        }
        //判断Authorization头是否不为空
        auth := r.Header.Get("Authorization")
        if auth != "" {
            next.ServeHTTP(w, r)
        }else{
            //返回401
            w.WriteHeader(http.StatusUnauthorized)
        }
        })
    }
    //日志请求中间件
    func LogHandler(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){
        if next == nil {
            next = http.DefaultServeMux
        }
        start := time.Now()
        //打印请求路径
        log.Printf("Started %s %s", r.Method, r.URL.Path)
        //调用嵌套的中间件，这里为AuthMiddleware
        next.ServeHTTP(w, r)
        //打印请求耗时
        log.Printf("Comleted %s in %v", r.URL.Path, time.Since(start))
        })
    }
    func main() {
        //注册路由
        http.HandleFunc("/user", func(w http.ResponseWriter, r *http.Request) {
            //实例化结构体返回json格式数据
            c := &Company{
                ID:123,
                Name:"TopSec",
                Country: "CN",
            }
            enc := json.NewEncoder(w)
            enc.Encode(c)
        })
        //监听端口绑定自定义中间件
        http.ListenAndServe(":8000",LogHandler(AuthHandler(nil)))
    }
写法二和写法一的区别在于写法一手动实现了`ServeHTTP`方法，而写法二使用函数的形式在其内部通过`HandlerFunc`的转换返回了一个handler处理器，这个handler实现了`ServeHTTP`方法，调用`ServeHTTP`方法则会调用其本身，所以同样也能当做中间件做请求处理。
提供两种方式的原因是当存在一个现有的类型需要转换为handler时只需要添加一个`ServeHTTP`方法即可。关于http和中间件更详细的分析就不在这里一一展开了，感兴趣的读者可以参考这两篇文章：[net/http库源码笔记](https://www.jianshu.com/p/be3d9cdc680b
"net/http库源码笔记")、[Go的http包详解](https://www.jianshu.com/p/c90ebdd5d1a1
"Go的http包详解")
## ruby前置知识
在ruby中当要调用方法时，可以不加括号只使用方法名。实例变量使用@开头表示。
> 元编程
通过元编程是可以在运行时动态地操作语言结构（如类、模块、实例变量等）
`instance_variable_get(var)`方法可以取得并返回对象的实例变量var的值。
`instance_variable_set(var, val)`方法可以将val的值赋值给对象实例变量var并返回该值。
`instance_variable_defined(var)`方法可以判断对象实例变量var是否定义。
> yield 关键字
函数调用时可以传入语句块替换其中的yield关键字并执行。如下示例：
    def a
      return 4
    end
    def b
      puts yield
    end
    b{a+1}
调用b时会将yield关键字替换为语句块a+1，所以会调用a返回4然后加上1打印5。
> Web框架rails
>
>   * 路由
>
在rails中的路由文件一般位于`config/routes.rb`下，在路由里面可以将请求和处理方法关联起来，交给指定controller里面的action，如下形式：
      post 'account/setting/:id',
        to: 'account#setting',
        constraints: { id: /[A-Z]\d{5}/ }
`account/setting/`是请求的固定url，`:id`表示带参数的路由。to表示交给`account`controller下的action`setting`处理。constraints定义了路由约束，使用正则表达式来对参数`:id`进行约束。
  * 过滤器
rails中可以插入定义好的类方法实现[过滤器](https://guides.rubyonrails.org/action_controller_overview.html#filters
"rails
过滤器")，一般分为`before_action`，`after_action`，`around_action`分别表示调用action”之前”、”之后”、”围绕”需要执行的操作。如：
    before_action :find_product, only: [:show]
上方表示在执行特定 Action `show`之前，先去执行 find_product 方法。
还可以使用`skip_before_action`跳过之前`before_action`指定的方法。
    class ApplicationController  DjVu是由AT&T实验室自1996年起开发的一种图像压缩技术，已发展成为标准的图像文档格式之一
>
>
> ExifTool是一个独立于平台的Perl库，一款能用作多功能图片信息查看工具。可以解析出照片的exif信息，可以编辑修改exif信息，用户能够轻松地进行查看图像文件的EXIF信息，完美支持exif信息的导出。
关键在于ExifTool在解析DjVu注释的`ParseAnt`函数中存在漏洞，所以我们就可以通过构造DjVu文件并插入恶意注释内容将其改为jpg后缀上传，因为gitlab并未在这个过程中验证文件内容是否是允许的格式，最后让ExifTool以DjVu形式来解析文件，造成了ExifTool代码执行漏洞。
该漏洞存在于ExifTool的7.44版本以上，在12.4版本中修复。Gitlab
v13.10.2使用的ExifTool版本为11.70。并且接口`/uploads/user`可通过获取的X-CSRF-Token和未登录Session后来进行未授权访问。最终造成了GitLab未授权的远程代码执行漏洞。
###  漏洞补丁分析
根据官方通告得知安全版本之一有13.10.3，那么我们直接切换到分支13.10.3查看[补丁提交记录](https://gitlab.com/gitlab-org/gitlab/-/commits/v13.10.3-ee/
"13.10.3提交记录")即可，打开页面发现在4月9日和11日有两个关于本次漏洞的commits，在其后的4月13日进行了合并。
在commit`Check content type before running
exiftool`中添加了`isTIFF`和`isJPEG`两个方法到`workhorse/internal/upload/rewrite.go`分别对TIFF文件解码或读取JPEG前512个字节来进行文件类型检测。
    func isTIFF(r io.Reader) bool 
      //对TIFF文件解码
        _, err := tiff.Decode(r)
        if err == nil {
            return true
        }
        if _, unsupported := err.(tiff.UnsupportedError); unsupported {
            return true
        }
        return false
    }
    func isJPEG(r io.Reader) bool {
      //读取JPEG前512个字节
        // Only the first 512 bytes are used to sniff the content type.
        buf, err := ioutil.ReadAll(io.LimitReader(r, 512))
        if err != nil {
            return false
        }
        return http.DetectContentType(buf) == "image/jpeg"
    }
在commit`Detect file MIME type before checking exif
headers`中添加了方法`check_for_allowed_types`到`lib/gitlab/sanitizers/exif.rb`检测mime_type是否为JPG或TIFF。
          def check_for_allowed_types(contents)
            mime_type = Gitlab::Utils::MimeType.from_string(contents)
            unless ALLOWED_MIME_TYPES.include?(mime_type)
              raise "File type #{mime_type} not supported. Only supports #{ALLOWED_MIME_TYPES.join(", ")}."
            end
          end
不过在rails中的exiftool调用是以[Rake任务](https://docs.gitlab.com/ee/administration/raketasks/uploads/sanitize.html
"Uploads sanitize Rake
tasks")存在的。以下是rails中的rake文件，位于`lib/tasks/gitlab/uploads/sanitize.rake`
    namespace :gitlab do
      namespace :uploads do
        namespace :sanitize do
          desc 'GitLab | Uploads | Remove EXIF from images.'
          task :remove_exif, [:start_id, :stop_id, :dry_run, :sleep_time, :uploader, :since] => :environment do |task, args|
            args.with_defaults(dry_run: 'true')
            args.with_defaults(sleep_time: 0.3)
            logger = Logger.new(STDOUT)
            sanitizer = Gitlab::Sanitizers::Exif.new(logger: logger)
            sanitizer.batch_clean(start_id: args.start_id, stop_id: args.stop_id,
                                  dry_run: args.dry_run != 'false',
                                  sleep_time: args.sleep_time.to_f,
                                  uploader: args.uploader,
                                  since: args.since)
          end
        end
      end
    end
> Rake是一门构建语言，和make和ant很像。Rake是用Ruby写的，它支持它自己的DSL用来处理和维护  
>  Ruby应用程序。Rails用rake的扩展来完成多种不同的任务。
## 漏洞复现分析
> 网上最开始流传的方式为通过[后台上传](https://www.cnblogs.com/ybit/p/14918949.html
> "后台上传")恶意JPG格式文件触发代码执行。从之后流出的在野利用分析来看，上传接口`/uploads/user`其实并不需要认证，也就是未授权的RCE，只需要获取到CSRF-> Token和未登录session即可。该漏洞的触发流程可大概分为两种，下面将一一介绍。