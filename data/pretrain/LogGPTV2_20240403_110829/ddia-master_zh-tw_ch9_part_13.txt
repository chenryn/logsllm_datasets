* 完整性（Integrity）
  没有节点决定两次。
* 有效性（Validity）
  如果一个节点决定了值 `v` ，则 `v` 由某个节点所提议。
* 终止（Termination）
  由所有未崩溃的节点来最终决定值。
**一致同意** 和 **完整性** 属性定义了共识的核心思想：所有人都决定了相同的结果，一旦决定了，你就不能改变主意。**有效性** 属性主要是为了排除平凡的解决方案：例如，无论提议了什么值，你都可以有一个始终决定值为 `null` 的演算法，该演算法满足 **一致同意** 和 **完整性** 属性，但不满足 **有效性** 属性。
如果你不关心容错，那么满足前三个属性很容易：你可以将一个节点硬编码为 “独裁者”，并让该节点做出所有的决定。但如果该节点失效，那么系统就无法再做出任何决定。事实上，这就是我们在两阶段提交的情况中所看到的：如果协调者失效，那么存疑的参与者就无法决定提交还是中止。
**终止** 属性形式化了容错的思想。它实质上说的是，一个共识演算法不能简单地永远闲坐著等死 —— 换句话说，它必须取得进展。即使部分节点出现故障，其他节点也必须达成一项决定（**终止** 是一种 **活性属性**，而另外三种是 **安全属性** —— 请参阅 “[安全性和活性](ch8.md#安全性和活性)”）。
共识的系统模型假设，当一个节点 “崩溃” 时，它会突然消失而且永远不会回来。（不像软体崩溃，想象一下地震，包含你的节点的资料中心被山体滑坡所摧毁，你必须假设节点被埋在 30 英尺以下的泥土中，并且永远不会重新上线）在这个系统模型中，任何需要等待节点恢复的演算法都不能满足 **终止** 属性。特别是，2PC 不符合终止属性的要求。
当然如果 **所有** 的节点都崩溃了，没有一个在执行，那么所有演算法都不可能决定任何事情。演算法可以容忍的失效数量是有限的：事实上可以证明，任何共识演算法都需要至少占总体 **多数（majority）** 的节点正确工作，以确保终止属性【67】。多数可以安全地组成法定人数（请参阅 “[读写的法定人数](ch5.md#读写的法定人数)”）。
因此 **终止** 属性取决于一个假设，**不超过一半的节点崩溃或不可达**。然而即使多数节点出现故障或存在严重的网路问题，绝大多数共识的实现都能始终确保安全属性得到满足 —— 一致同意，完整性和有效性【92】。因此，大规模的中断可能会阻止系统处理请求，但是它不能透过使系统做出无效的决定来破坏共识系统。
大多数共识演算法假设不存在 **拜占庭式错误**，正如在 “[拜占庭故障](ch8.md#拜占庭故障)” 一节中所讨论的那样。也就是说，如果一个节点没有正确地遵循协议（例如，如果它向不同节点发送矛盾的讯息），它就可能会破坏协议的安全属性。克服拜占庭故障，稳健地达成共识是可能的，只要少于三分之一的节点存在拜占庭故障【25,93】。但我们没有地方在本书中详细讨论这些演算法了。
#### 共识演算法和全序广播
最著名的容错共识演算法是 **检视戳复制（VSR, Viewstamped Replication）**【94,95】，Paxos 【96,97,98,99】，Raft 【22,100,101】以及 Zab 【15,21,102】 。这些演算法之间有不少相似之处，但它们并不相同【103】。在本书中我们不会介绍各种演算法的详细细节：了解一些它们共通的高阶思想通常已经足够了，除非你准备自己实现一个共识系统。（可能并不明智，相当难【98,104】）
大多数这些演算法实际上并不直接使用这里描述的形式化模型（提议与决定单个值，并满足一致同意、完整性、有效性和终止属性）。取而代之的是，它们决定了值的 **顺序（sequence）**，这使它们成为全序广播演算法，正如本章前面所讨论的那样（请参阅 “[全序广播](#全序广播)”）。
请记住，全序广播要求将讯息按照相同的顺序，恰好传递一次，准确传送到所有节点。如果仔细思考，这相当于进行了几轮共识：在每一轮中，节点提议下一条要传送的讯息，然后决定在全序中下一条要传送的讯息【67】。
所以，全序广播相当于重复进行多轮共识（每次共识决定与一次讯息传递相对应）：
* 由于 **一致同意** 属性，所有节点决定以相同的顺序传递相同的讯息。
* 由于 **完整性** 属性，讯息不会重复。
* 由于 **有效性** 属性，讯息不会被损坏，也不能凭空编造。
* 由于 **终止** 属性，讯息不会丢失。
检视戳复制，Raft 和 Zab 直接实现了全序广播，因为这样做比重复 **一次一值（one value a time）** 的共识更高效。在 Paxos 的情况下，这种最佳化被称为 Multi-Paxos。
#### 单主复制与共识
在 [第五章](ch5.md) 中，我们讨论了单主复制（请参阅 “[领导者与追随者](ch5.md#领导者与追随者)”），它将所有的写入操作都交给主库，并以相同的顺序将它们应用到从库，从而使副本保持在最新状态。这实际上不就是一个全序广播吗？为什么我们在 [第五章](ch5.md) 里一点都没担心过共识问题呢？
答案取决于如何选择领导者。如果主库是由运维人员手动选择和配置的，那么你实际上拥有一种 **独裁型别** 的 “共识演算法”：只有一个节点被允许接受写入（即决定写入复制日志的顺序），如果该节点发生故障，则系统将无法写入，直到运维手动配置其他节点作为主库。这样的系统在实践中可以表现良好，但它无法满足共识的 **终止** 属性，因为它需要人为干预才能取得 **进展**。
一些资料库会自动执行领导者选举和故障切换，如果旧主库失效，会提拔一个从库为新主库（请参阅 “[处理节点宕机](ch5.md#处理节点宕机)”）。这使我们向容错的全序广播更进一步，从而达成共识。
但是还有一个问题。我们之前曾经讨论过脑裂的问题，并且说过所有的节点都需要同意是谁领导，否则两个不同的节点都会认为自己是领导者，从而导致资料库进入不一致的状态。因此，选出一位领导者需要共识。但如果这里描述的共识演算法实际上是全序广播演算法，并且全序广播就像单主复制，而单主复制需要一个领导者，那么...
这样看来，要选出一个领导者，我们首先需要一个领导者。要解决共识问题，我们首先需要解决共识问题。我们如何跳出这个先有鸡还是先有蛋的问题？
#### 纪元编号和法定人数
迄今为止所讨论的所有共识协议，在内部都以某种形式使用一个领导者，但它们并不能保证领导者是独一无二的。相反，它们可以做出更弱的保证：协议定义了一个 **纪元编号**（epoch number，在 Paxos 中被称为 **投票编号**，即 ballot number，在检视戳复制中被称为 **检视编号**，即 view number，以及在 Raft 中被为 **任期号码**，即 term number），并确保在每个时代中，领导者都是唯一的。
每次当现任领导被认为挂掉的时候，节点间就会开始一场投票，以选出一个新领导。这次选举被赋予一个递增的纪元编号，因此纪元编号是全序且单调递增的。如果两个不同的时代的领导者之间出现冲突（也许是因为前任领导者实际上并未死亡），那么带有更高纪元编号的领导说了算。