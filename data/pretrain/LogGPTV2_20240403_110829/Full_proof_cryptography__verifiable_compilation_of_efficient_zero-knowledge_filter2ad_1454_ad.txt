goals produced by the front end of the compiler:
(i) Atomic goals consisting of pre-image proofs under a homo-
morphism with a ﬁnite domain using the Σφ-protocol, includ-
ing product homomorphisms where the co-domain is a tuple
of images in the range of the group operation.
(ii) Atomic goals consisting of pre-image proofs under an expo-
nentiation homomorphism in a hidden-order group using the
ΣGSP-protocol, including product homomorphisms where the
co-domain is a tuple of images in the range of the group op-
eration. In particular, these include goals resulting from the
resolution of interval proofs as described in §4.
(iii) Arbitrary, possibly nested, AND- and OR-compositions of
proof goals as in point (i).
We stress that, although the code generation component of
ZKCrypt addresses an even broader set of proof goals, this class
was selected to cover essentially all practical applications. Indeed,
although we do not support compositions of ΣGSP-protocol, this
is only a restriction for OR-compositions, which are rarely used
494P1hGresi(x, w):
$← stTypehGresi
stP
r ← Prover1hGresi(x, w, stP )
return (r, stP )
VchGresi():
c $← cTypehGresi
return c
P2hGresi(x, w, c, stP ):
VhGresi(x, r, c, s):
s ← Prover2hGresi(x, w, c, stP )
return s
a ← VeriﬁerhGresi(x, r, c, s)
return a
Figure 5: Descriptions of reference implementations.
in practice. Flat AND-compositions can be achieved with product
homomorphisms.
Given a resolved proof goal Gres, the veriﬁed compiler is able
to generate a description of a reference implementation for a suit-
able Σ-protocol, consisting of CertiCrypt programs corresponding
to algorithms P1, P2, V and Vc. The generated descriptions of
these algorithms follow a carefully designed structure, tailored to
facilitate the formal proof that, for any goal, the (therefore) veriﬁed
compiler produces correct and secure reference implementations.
The challenge here was to ﬁnd the best balance between the
level of abstraction at which the formalization is performed in Cer-
tiCrypt, and our goal to give formal veriﬁcation guarantees over
the optimized implementations generated by ZKCrypt. On the
one hand, proving that the reference implementations meet the pre-
scribed correctness and security requirements is much easier if one
can reason abstractly about homomorphisms, group operations, etc.
On the other hand, we wish to prove observational equivalence to
programs produced by ZKCrypt in what is essentially pseudo-code
of an imperative language very close to common programming
languages. We achieve a compromise between these two aspects,
which enables us to reach both objectives simultaneously.
Concretely, we construct each algorithm as shown in Figure 5,
where we introduce annotations between angle brackets as in
XhGresi to make explicit the goal G an object X corresponds to.
Note that all algorithms have at most two statements: a random
assignment that samples all necessary random values up-front, and
a deterministic assignment that computes the output in terms of the
input of the algorithm and the sampled random values. For exam-
ple, in algorithm P1hGresi, the ﬁrst operation corresponds to sam-
pling a tuple uniformly at random from the set stTypehGresi, which
corresponds to a Cartesian product of sets derived from the proof
goal Gres. The second statement consists of a single assignment
that evaluates a function of the inputs of the algorithm and the ran-
domly sampled tuple; this is typically a huge expression performing
all the necessary parsing and algebraic computations. More pre-
cisely, functions Prover1hGresi, Prover2hGresi and VeriﬁerhGresi
may map to arbitrarily complex CertiCrypt expressions.
We observe that by restricting the reference implementation of
protocols to the form shown in Figure 5 we do not lose general-
ity. Indeed, this form is achievable for all goals, including those
comprising arbitrary (possibly nested) Boolean compositions of
atomic goals, which is a non-trivial aspect of the formalization ap-
proach adopted in ZKCrypt. Intuitively, for atomic goals, the com-
putations performed by the reference implementation correspond
to those described in §3 for the Σφ- and ΣGSP- protocols. For
Boolean combinations of Σφ-protocols, the reference implemen-
tation is generated recursively by unfolding the inductively deﬁned
proof goal according to the standard procedures for Boolean com-
position described in §3. This is made possible by our approach
to isolating random sampling operations from other computations.
For illustrative purposes we present a short excerpt of the deﬁni-
tion of the prover function Prover1 in Listing 1. The excerpt corre-
sponds to the case of Boolean compositions of proof goals that can
be handled using the Σφ-protocol, and takes as input a pair (x, w)
and the value stP comprising all values randomly sampled by the
P1hGresi algorithm. The base case maps to a concrete homomor-
phism, whereas recursive calls construct homomorphisms for And
and Or combinations.
Listing 1: Deﬁnition of algorithm Prover1 in Coq.
F i x p o i n t p r o v e r _ p h i g :
( DomType g ) → e x p r
( TGtype ( RandTG g ) ) → e x p r
e x p r
e x p r
match g w i t h
| Hom ( PhiHom A B h ) ⇒ f u n w x ⇒ phiHom h
| And g1 g2 ⇒ f u n w x ps ⇒
( CodomType g ) →
( CodomType g )
: =
( p r o v e r _ p h i
p r o v e r _ p h i
( F s t w)
( Snd w)
( F s t x )
( Snd x )
( F s t ps )
( Snd ps )
|
)
| Or g1 g2 ⇒ f u n w x ps ⇒
IF I s L (w) THEN
( p r o v e r _ p h i
( P r o j L w)
( F s t x )
( F s t
( Snd ps ) )
|
s i m _ p h i
( Snd x )
( F s t ps )
( Snd ( Snd ps ) )
ELSE
(
s i m _ p h i
p r o v e r _ p h i
( F s t x )
( F s t ps )
( P r o j r w)
( F s t
( Snd x )
( Snd ps ) )
( Snd ( Snd ps ) )
)
)
|
end
In addition to the descriptions of reference implementations for
the algorithms of Σ-protocols, the compiler also generates the aux-
iliary algorithms that are required to establish security. In particu-
lar, for each goal, the compiler generates deﬁnitions of a suitable
simulator and special extractor that can be used in the theorem
statements that capture the zero-knowledge and proof of knowl-
edge properties. The ability to generate suitable simulators is also
an essential part of generating ZK-PoK protocols for Or compo-
sitions of Σφ-protocols. Indeed, the deﬁnitions of algorithms P1
and P2 explicitly rely on the simulator descriptions as part of their
code, as can be seen in the snippet in Listing 1: in Or-compositions,
the prover uses as a sub-procedure the simulator of the protocol for
which it does not know a witness.
We discuss next how we prove the correctness and security prop-
erties of reference implementations for all supported proof goals.
Completeness. Completeness of reference implementations is
given by the CertiCrypt theorem below.
THEOREM 2
(COMPLETENESS). For all supported goals
Gres, and all pairs (x, w) satisfying the associated relation, we
prove
c $← VchGresi();
(r, stP ) $← P1hGresi(x, w);
s ← P2hGresi(x, w, c, stP );
a ← VhGresi(x, r, c, s)
≈{a}
0
a ← true
Intuitively, this formalization states that in an honest execution, the
veriﬁer always will accept. Observe that, also in the protocol def-
inition, the challenge generation is hoisted to the beginning of the
protocol, as this facilitates proving equivalence claims. This is a
valid transformation because we only have to prove that properties
hold for an honest veriﬁer that does not deviate from the protocol.
The proof of this theorem requires combined reasoning about the
algebraic manipulations performed by the protocol parties. This is
particularly challenging in the case of goals based on Σφ, for which
the proof is by induction on the structure of the goal, dealing with
the recursive deﬁnitions of the algorithms themselves. For exam-
ple, in Or-compositions one needs to deal with the rearrangement
of recursive calls, by establishing intermediate results of the form:
(r, c, s, a) $← ProtocolhG1 ∨ G2i(x, ι1(w1)) ≈{r,c,s,a}
(r1, c1, s1, a1) $← ProtocolhG1i(π1(x), w1);
c $← cTypehGresi; c2 ← c − c1;
(r2, c2, s2, a2) $← ShG2i(π2(x), c2);
r ← (r1, r2); a ← a1 ∧ a2
0
495This result states that the behavior of the protocol, when run on the
prover side with the witnesses corresponding to goal G1 is identical
to that of another procedure which explicitly relies on a protocol for
goal G1 and a simulator for goal G2. The proof of this equivalence
must then make use of the recursive deﬁnition of the protocol (itself
based on the prover and veriﬁer algorithms presented in Figure 5)
and of the simulator, and requires proving that the needed code
rearrangements do not modify the semantics of the experiments.
HVZK. Honest veriﬁer ZK of reference implementations is given
by the CertiCrypt theorem below.
THEOREM 3
(HVZK). For all supported goals Gres, and for
all pairs (x, w) satisfying the relation associated with Gres, we
prove the following statistical equivalence:
c $← VchGresi();
(r, stP ) $← P1hGresi(x, w);
s ← P2hGresi(x, w, c, stP );
a ← VhGresi(x, r, c, s)
≈{r,c,s}
ǫhGresi
(r, c, s) $← ShGresi(x)
Here, ShGresi is the simulator algorithm generated by ZKCrypt
for goal Gres. The concrete value of the statistical distance between
the distributions depends on the goal. For the particular case of
Σφ-protocols and Boolean combinations thereof, this is actually
0, and so proving this property corresponds to showing that the
distributions are identical, implying perfect HVZK. In this case,
the type of reasoning required to construct the proof is very similar
to that described for completeness.
On the contrary, proving the zero knowledge property of ΣGSP-
protocols constitutes a signiﬁcant challenge because it requires rea-
soning about statistical distance. Given any ΣGSP goal Gres deﬁned
over a homomorphism where the co-domain is a tuple of arbitrary
size m, we bound the statistical distance in the statement above by
ǫhGresi = m/2ℓ, where ℓ is a concrete security parameter given
as input to the compiler along with the goal speciﬁcation (see §3).
Establishing this result for arbitrary homomorphisms required rea-
soning about the number of points contained in hypercubes in Zm,
and proving the upper bound using Bernoulli’s inequality.
Proof of Knowledge. The following CertiCrypt theorem ensures
that all generated reference implementations satisfy the General-
ized Special Soundness introduced in §3.
THEOREM 4
every
(PROOF OF KNOWLEDGE). For
sup-
ported valid goals Gres,
for all (x, w) satisfying the relation
associated with Gres, and for any two accepting conversations
(r, c, s) and (r, c′, s′) satisfying relation R′hGresi,
RhGresi(x, EhGresi(r, c, c′, s, s′)) = true .
The theorem statement nicely matches Deﬁnition 2, where re-
lation R′hGresi expresses the restriction on traces described in §3
for either Σφ- or ΣGSP- protocols, and EhGresi denotes the knowl-
edge extractor generated by the compiler. However, the theorem
includes an additional validity restriction on proof goals that we
now explain. Referring to §3, recall that for c+ > 2 both the
Σφ-protocol and the ΣGSP-protocol can only be proven to satisfy
Deﬁnition 2 if the underlying homomorphisms satisfy an addi-
tional property. Our notion of proof goal validity captures these ex-
tra restrictions. Concretely, the validity requirement for Σφ goals
implies that all prime factors of special exponents for homomor-
phisms are greater than c+. For the ΣGSP-protocol, the validity re-
quirement is as follows. Recall, from §3 that R typically samples
an RSA modulus n and deﬁnes a relation R as
R(x, (µ, w))
.
= x = µφ(w) ∧ µd = 1
(mod n)
Here, d is the product of the primes dividing the order of the mul-
tiplicative group modulo n, which are less than or equal to c+. We
require for validity that d satisﬁes this property.
Proving this theorem in CertiCrypt posed a different sort of chal-
lenge when compared to the previous ones, as it is not formulated in
the form of a program equivalence statement. Essentially, it trans-
lates into a proof goal formulated over the semantics of the un-
derlying algebraic constructions. Here we make critical use of the
extensive Coq library that is included in ZKCrypt and that was de-
veloped to support the semantics of the data types included in the
necessary CertiCrypt extensions. In turn, this library makes inten-
sive use of SSReﬂect [35] and its comprehensive Coq library on
algebraic and number theoretic results.
6.
IMPLEMENTATION
To establish our ultimate veriﬁcation goal, we translate the opti-
mized implementations of protocols generated by ZKCrypt to the
language of CertiCrypt. By taking advantage of the convenient
notation that ZKCrypt automatically sets up in CertiCrypt, this
translation step is straightforward and essentially corresponds to
pretty-printing the output implementation ﬁles. Our strategy to for-
mally verify these optimized implementations is to ﬁrst establish
an intermediate result stating that these are correct with respect to
a reference implementation. More precisely, we establish that each
of the algorithms in the implementation ﬁle, namely P1, P2, V, and
Vc, are observationally equivalent to the corresponding algorithms
in the reference implementation. These results are formalized in
CertiCrypt by lemmas that typically look as the one below.
LEMMA 1
(CORRECTNESS OF P1). For all (x, w) in the do-
main of relation R, associated with resolved goal Gres, the following
equivalence holds:
(r, stP ) $← P1(x, w) ≈{r,stP }
0
(r, stP ) $← Pref
1 hGresi(x, w)
Here Pref
1
refers to the reference implementation for algorithm
P1. Equivalence is formalized by imposing that, for any possi-
ble ﬁxed input, the outputs of both algorithms are identically dis-
tributed. Several differences between the reference and optimized
implementations make proving these lemmas non trivial:
1. The reference implementation is expressed at a slightly
higher level of abstraction than the optimized implementa-
tion. In particular, the reference implementation expresses
homomorphism computations as native operations in the
CertiCrypt language, whereas these are expanded as lower-
level operations over the underlying algebraic groups in the
optimized protocol implementation.
2. The reference implementation typically uses different lan-
guage constructions than the optimized protocol.