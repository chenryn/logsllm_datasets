User: 请选择Go领域相关问题的正确答案及解释题目：以下哪个选项正确地实现了复利计算的递归和非递归方法？

A: / 递归实现/nfunc compoundInterestRecursive(P, i float64, n int) float64 {/n    if n == 0 {/n        return P/n    }/n    return compoundInterestRecursive(P*(1+i), i, n-1)/n}/n/n// 非递归实现/nfunc compoundInterestIterative(P, i float64, n int) float64 {/n    for j := 0; j &lt; n; j++ {/n        P = P * (1 + i)/n    }/n    return P/n}/n
B: // 递归实现/nfunc compoundInterestRecursive(P, i float64, n int) float64 {/n    if n == 0 {/n        return P/n    }/n    return P * (1+compoundInterestRecursive(P, i, n-1))/n}/n/n// 非递归实现/nfunc compoundInterestIterative(P, i float64, n int) float64 {/n    for j := 0; j &lt; n; j++ {/n        P = P + P * i/n    }/n    return P/n}/n
C: // 递归实现/nfunc compoundInterestRecursive(P, i float64, n int) float64 {/n    if n == 1 {/n        return P * (P + i)/n    }/n    return P * compoundInterestRecursive(P, i, n-1)/n}/n/n// 非递归实现/nfunc compoundInterestIterative(P, i float64, n int) float64 {/n    for j := 0; j &lt; n; j++ {/n        P = P * i/n    }/n    return P/n}/n
D: // 递归实现/nfunc compoundInterestRecursive(P, i float64, n int) float64 {/n    if n == 0 {/n        return P/n    }/n    return P * (1 + i) * compoundInterestRecursive(P, i, n-1)/n}/n/n// 非递归实现/nfunc compoundInterestIterative(P, i float64, n int) float64 {/n    for j := 0; j &lt; n; j++ {/n        P = P * (1 + i)/n    }/n    return P/n}

Assistant: Answer: A