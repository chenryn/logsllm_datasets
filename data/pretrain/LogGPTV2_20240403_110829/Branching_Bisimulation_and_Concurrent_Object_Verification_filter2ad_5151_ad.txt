(cid:2)
(cid:2)
Non-Ô¨Åxed LPs
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
div.branch.bisim./
trace reÔ¨Åne.
(cid:2)
(cid:2)
√ó√ó√ó
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
√ó√ó√ó
(cid:2)
√ó√ó√ó
(cid:2)
Fine-grained concurrent lists
Case study
12. Heller et al. lazy list [16]
13. Optimistic list [17]
14. Fine-grained syn. list [17]
Linearizability
(cid:2)
(cid:2)
(cid:2)
Non-Ô¨Åxed LPs
(cid:2)
branch.bisim./
trace reÔ¨Åne.
(cid:2)
(cid:2)
(cid:2)
2http://cadp.inria.fr/
273
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:24:37 UTC from IEEE Xplore.  Restrictions apply. 
B. Experimental Setup
To start off, we modeled all concurrent data structures using
the LNT modeling language3, which allows for modeling the
object behavior as a set of threads governed by interleaving
semantics. CADP provides automated support for generating
transition systems of LNT models, obtaining their branching
bisimulation quotients, and the veriÔ¨Åcation of temporal logic
formulas. When CADP reveals that two transition systems
are incomparable (w.r.t. trace reÔ¨Ånement or bisimulation), it
provides a counterexample. These counterexamples turned out
to be very helpful in diagnosing the reason of violation. As
the analysis is restricted to Ô¨Ånite transition systems, we can
bound the state space by either: (1) bounding the size of the
object (e.g., the size of the stack), or by (2) restricting the
number of operations a thread can perform. In the former case,
threads can perform operations such as pop and push inÔ¨Ånitely
many times. We take the latter approach since the original
algorithms typically do not handle the case of bounded stacks
or queues, and imposing such bounds would require amend-
ments of original algorithms for treating overÔ¨Çow situations.
Based on these veriÔ¨Åed models, we conducted the performance
analysis of concurrent data structures [40], where a description
of the CADP toolsets and the LNT language is given.
C. VeriÔ¨Åcation Results
The experimental results of 14 concurrent objects are sum-
marized in Table II. We discuss the results as follows.
‚Ä¢ To verify linearizability, we apply our Ô¨Årst approach in
Figure 1 (a) (cf. Theorem 5.3) and successfully verify
14 concurrent data structures. In contrast to [3], [20],
[36], which rely on linearization points and give different
mechanism treating different types of linearization points,
our method does not need linearization points, and can
support automatic veriÔ¨Åcation.
‚Ä¢ To verify progress, our second approach in Figure 1 (b)
(cf. Theorems 5.8, 5.9) is applied, and successfully verify
11 algorithms to be lock-free. There are two ways. One
way is to manually construct abstract programs and verify
their lock-freedom by Theorem 5.8. We construct the
abstract programs for MS queue, DGLM queue, CCAS
and RDCSS. For static linearization points, the abstract
program coincides with the speciÔ¨Åcation. The second way
is using the quotient as the abstract system, and auto-
matically verify lock-free property of Ô¨Ånite-state systems
by Theorem 5.9. Compared to [21], their method proves
the lock-free property for 3 non-blocking algorithms, i.e.,
Treiber stack, MS queue and DGLM queue. They do not
discuss more complex algorithms like CCAS, RDCSS
and the stacks with Hazard Pointers (HP) [10], [24] as
our work.
‚Ä¢ Our method is fully-automated for Ô¨Ånite systems. Auto-
matic veriÔ¨Åcation allows to Ô¨Ånd bugs easily if an error
diagnostic path reported successfully.
3An extension of the ISO standard language LOTOS (ISO:8807:1989)
274
‚Ä¢ VeriÔ¨Åcation based on branching bisimulation equivalence
checking for Ô¨Ånite state systems (or quotients) is more
efÔ¨Åcient
than trace reÔ¨Ånement checking on the origi-
nal systems, due to the polynomial-time algorithm for
checking branching bisimulation. The reduction factor
(cf. Figure 10) ranges from at least 5 up to more than
1000 and has an increasing trend if the number of threads
and operations per thread is increasing. The veriÔ¨Åcation
time for objects can be found in Tables VI, III, IV.
D. A concrete example: the MS lock-free queue
We present the MS lock-free queue as a representative, and
show the abstract object and detailed experimental results. The
implementation of MS queue can be found in Fig.5.
1) Analyzing algorithms by branching bisimilar: Since the
branching bisimulation equivalence captures state equivalence,
by computing the quotient, we can easily obtain the essential
transitions of concurrent programs. For the MS queue example
in Fig. 6, all internal steps in the quotient are labeled with
Lines 8,20,21,28 (Fig. 5). These key statements acquired
from the quotient coincide with the manual analysis [20]. Fur-
ther, we check whether the speciÔ¨Åcation and concrete object
are branching bisimilar. If they are not, a path is generated.
Fig. 7 is the diagnostic paths involving Lines 20,28, which
are generated by checking the branching bisimilarity between
the quotients of the queue speciÔ¨Åcation and MS queue. This
path shows a complicated interleaving of non-Ô¨Åxed LPs, which
the speciÔ¨Åcation does not have. From the path, we can reÔ¨Åne
the speciÔ¨Åcation into Ô¨Åner atomic blocks.
deq2
√ú2
√ú1
ret2,a ret1,b
(t2:line 28)
(t1:line 28)
(t1:line 20) is not an LP 
deq1
√ú1
(t1:line 20)
(t1:line 20) is an LP 
Fig. 7. The non-Ô¨Åxed linearization point in method Deq.
2) The speciÔ¨Åcation and abstract object of MS queue:
The speciÔ¨Åcation and abstract queue are shown in Fig. 8. The
enqueue method Enq abs(v) is the same as the speciÔ¨Åcation
Enq spec(v), which has one atomic block. But for dequeue
method Deq abs, we need two atomic blocks. The Ô¨Årst atomic
block Line 42 matches Line 20 and the second atomic
block Line 44 matches Line 28. In details, atomic block
Line 42 is the linearization point for empty queue such that
dequeue returns EMPTY, and atomic block Line 44 is the
linearization point for successfully removing the Ô¨Årst node
from the list. Further, between Line 42 and Line 44, ab-
stract method Deq abs allows interleavings with other threads
that may change the value of Head. When atomic block Line
42 reads Head again, of which the value is changed, it will
restart the while-loop such that atomic block Line 42 may
not be the linearization point (due to the non-empty queue).
Thus, the interleavings of atomic blocks are consistent with
the interleavings of Lines 8,20,21,28 of MS queue.
The DGLM queue [7] that improves the MS queue can be
analyzed similarly. By rewriting the concrete program to an
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:24:37 UTC from IEEE Xplore.  Restrictions apply. 
equivalent abstract queue, we can verify the much simpler
abstract queue instead of the original object program.
32 Enq_spec(v){
33 atomic {
38 Enq_abs(v){
39
atomic {
x:=new_node(v);
t:=Tail;
t.next:=x;Tail:=x;
x:=new_node(v);
t:=Tail;
t.next:=x;Tail:=x;
34
}
}
40
}
}
35 Deq_spec() {
36 atomic {
h:=Head;t:=Tail;
if(h=t) b:=0
else
b:=1;
s:=h.next;
Head:=s;
v:=s.val;
37 }
if (b==1) return v
else return EMPTY;
}
41 Deq_abs() {
42 atomic {
while(true) {
h:=Head;t:=Tail;
};
43
44 atomic {
if(h=Head)
if(h=t)
return EMPTY;
else {
s:=h.next;
Head:=s;
v:=s.val;
return v;}
else skip;
45
} } }
Fig. 8. SpeciÔ¨Åcation Enq/Deq spec(v) and abstract queue Enq/Deq abs(v).
3) Experimental results: The veriÔ¨Åcation results for the MS
queue as well as the DGLM queue are given in Table VI,
where the veriÔ¨Åcation time (in seconds) together with the
state spaces of these objects and their quotients are recorded
respectively. The MS lock-free and DGLM queues have the
same speciÔ¨Åcation (ŒòSP) and abstract object (ŒîAbs). The
DGLM queue has a smaller state-space since it is an optimized
version of MS lock-free queue. From Table VI, we can see
that the abstract queue and MS/DGLM queues are branching
bisimilar, which correspond to the same quotient (Œî‚àó/‚âà).
These results show that our veriÔ¨Åcation methods are rather
efÔ¨Åcient to check linearizability and lock-freedom. Although
the trace reÔ¨Ånement checking in Theorem 5.3 is PSPACE-
complete, the quotient system reduces the state space by a
factor of 100 times or more, such that verifying linearizablity,
which is impossible directly on the original system, becomes
possible. For example, for 3 threads with 3 operations, the
veriÔ¨Åcation time of about 76 million states takes around only
50 seconds.
E. Automatically verifying lock-freedom
We also provide a full automatic veriÔ¨Åcation method using
Theorem 5.9 to check the lock-free property (for Ô¨Ånite sys-
tems), without constructing abstract objects. The experimental
results on checking the lock-free property of the MS queue are
presented in Table III, where ŒîMS and ŒîMS/‚âà are the state
spaces of the original system and the quotient, respectively.
From Table III, all the instances of the queue satisfy the lock-
free property. Because the quotient is usually much smaller
than the abstract object program (c.f. Table VI), the veriÔ¨Åcation
method using Theorem 5.9 is more efÔ¨Åcient than Theorem 5.8.
Let us see the HM lock-free list that involves the operations
add and remove. The experimental results in Table IV indicate
that these Ô¨Ånite instances of the HM list satisfy the lock-free
property. Other algorithms in Table II can be veriÔ¨Åed similarly.
AUTOMATICALLY CHECKING LOCK-FREEDOM OF THE MS QUEUE [25].
TABLE III
#Th.-#Op.
2-3
2-4
2-5
2-6
3-1
3-2
3-3
ŒîMS
49038
304049
1554292
7092627
10845
1496486
76157266
ŒîMS/‚âà lock-free (Thm.5.9)
863
2648
6765
15820
220
7337
74551
Yes
Yes
Yes
Yes
Yes
Yes
Yes
time (s)
0.68
1.90
8.44
40.21
0.52
9.41
516.79
TABLE IV
AUTOMATICALLY CHECKING LOCK-FREEDOM OF THE HM LIST [17].
#Th.-#Op. ŒîHM ŒîHM/‚âà lock-free (Thm.5.9)
time (s)
2-2
2-3
2-4
2-5
3-1
8602
55732
227989
670482
16216
414
1949
5314
10368
445
Yes
Yes
Yes
Yes
Yes
0.44
1.01
1.96
4.29
0.88
The method dequeue of the HW queue [18] is not lock-free.
By comparing the divergence-sensitive branching bisimilarity
between the system and its quotient in Table V, we obtain
ŒîHW (cid:9)‚âàdiv (ŒîHW/‚âà). The equivalence checking using Theo-
rem 5.9 automatically generates a divergence, shown in Fig. 9.
The divergence is found in the Deq method.
CHECKING LOCK-FREEDOM OF THE HW QUEUE [18].
TABLE V
#Th.-#Op. ŒîHW ŒîHW/‚âà lock-free (Thm.5.9)
3-1
1324
156
No
time (s)
0.37
!"&'&$(!"(!'#'
 