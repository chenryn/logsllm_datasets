## 实现方法 {#16.html#-}和数据库读写分离类似，分库分表具体的实现方式也是"程序代码封装"和"中间件封装"，但实现会更复杂。读写分离实现时只要识别SQL 操作是读操作还是写操作，通过简单的判断SELECT、UPDATE、INSERT、DELETE几个关键字就可以做到，而分库分表的实现除了要判断操作类型外，还要判断 SQL中具体需要操作的表、操作函数（例如 count 函数)、order by、group by操作等，然后再根据不同的操作进行不同的处理。例如 order by操作，需要先从多个库查询到各个库的数据，然后再重新 order by才能得到最终的结果。
## 小结 {#16.html#-}今天我为你讲了高性能数据库集群的分库分表架构，包括业务分库产生的问题和分表的两种方式及其带来的复杂度，希望对你有所帮助。这就是今天的全部内容，留一道思考题给你吧，你认为什么时候引入分库分表是合适的？是数据库性能不够的时候就开始分库分表么？欢迎你把答案写到留言区，和我一起讨论。相信经过深度思考的回答，也会让你对知识的理解更加深刻。（编辑乱入：精彩的留言有机会获得丰厚福利哦！）![](Images/f2eae62fce5bba3ca5ee38d11da01862.png){savepage-src="https://static001.geekbang.org/resource/image/ba/37/ba6fcd186893b8cc9977d18e1fa5ab37.jpg"}
# 16 \| 高性能NoSQL关系数据库经过几十年的发展后已经非常成熟，强大的 SQL 功能和 ACID的属性，使得关系数据库广泛应用于各式各样的系统中，但这并不意味着关系数据库是完美的，关系数据库存在如下缺点。-   关系数据库存储的是行记录，无法存储数据结构以微博的关注关系为例，"我关注的人"是一个用户 ID列表，使用关系数据库存储只能将列表拆成多行，然后再查询出来组装，无法直接存储一个列表。-   关系数据库的 schema 扩展很不方便关系数据库的表结构 schema是强约束，操作不存在的列会报错，业务变化时扩充列也比较麻烦，需要执行DDL（data definition language，如 CREATE、ALTER、DROP等）语句修改，而且修改时可能会长时间锁表（例如，MySQL 可能将表锁住 1个小时）。-   关系数据库在大数据场景下 I/O 较高如果对一些大量数据的表进行统计之类的运算，关系数据库的 I/O会很高，因为即使只针对其中某一列进行运算，关系数据库也会将整行数据从存储设备读入内存。-   关系数据库的全文搜索功能比较弱关系数据库的全文搜索只能使用 like进行整表扫描匹配，性能非常低，在互联网这种搜索复杂的场景下无法满足业务要求。针对上述问题，分别诞生了不同的 NoSQL解决方案，这些方案与关系数据库相比，在某些应用场景下表现更好。但世上没有免费的午餐，NoSQL方案带来的优势，本质上是牺牲 ACID中的某个或者某几个特性，**因此我们不能盲目地迷信 NoSQL 是银弹，而应该将NoSQL 作为 SQL 的一个有力补充**，NoSQL != No SQL，而是 NoSQL = Not OnlySQL。常见的 NoSQL 方案分为 4 类。-   K-V 存储：解决关系数据库无法存储数据结构的问题，以 Redis 为代表。-   文档数据库：解决关系数据库强 schema 约束的问题，以 MongoDB 为代表。-   列式数据库：解决关系数据库大数据场景下的 I/O 问题，以 HBase 为代表。-   全文搜索引擎：解决关系数据库的全文搜索性能问题，以 Elasticsearch    为代表。今天，我来介绍一下各种[高性能 NoSQL 方案的典型特征和应用场景。]{.orange}``{=html}
## K-V 存储K-V 存储的全称是 Key-Value 存储，其中 Key是数据的标识，和关系数据库中的主键含义一样，Value 就是具体的数据。Redis 是 K-V 存储的典型代表，它是一款开源（基于 BSD 许可）的高性能 K-V缓存和存储系统。Redis 的 Value 是具体的数据结构，包括string、hash、list、set、sorted set、bitmap 和hyperloglog，所以常常被称为数据结构服务器。以 List 数据结构为例，Redis提供了下面这些典型的操作（更多请参考链接：）：-   LPOP key 从队列的左边出队一个元素。-   LINDEX key index 获取一个元素，通过其索引列表。-   LLEN key 获得队列（List）的长度。-   RPOP key 从队列的右边出队一个元素。以上这些功能，如果用关系数据库来实现，就会变得很复杂。例如，LPOP操作是移除并返回 key 对应的 list的第一个元素。如果用关系数据库来存储，为了达到同样目的，需要进行下面的操作：-   每条数据除了数据编号（例如，行    ID），还要有位置编号，否则没有办法判断哪条数据是第一条。注意这里不能用行    ID 作为位置编号，因为我们会往列表头部插入数据。-   查询出第一条数据。-   删除第一条数据。-   更新从第二条开始的所有数据的位置编号。可以看出关系数据库的实现很麻烦，而且需要进行多次 SQL 操作，性能很低。Redis 的缺点主要体现在并不支持完整的 ACID 事务，Redis虽然提供事务功能，但 Redis 的事务和关系数据库的事务不可同日而语，Redis的事务只能保证隔离性和一致性（I 和 C），无法保证原子性和持久性（A 和D）。虽然 Redis 并没有严格遵循 ACID 原则，但实际上大部分业务也不需要严格遵循ACID 原则。以上面的微博关注操作为例，即使系统没有将 A 加入 B的粉丝列表，其实业务影响也非常小，因此我们在设计方案时，需要根据业务特性和要求来确定是否可以用Redis，而不能因为 Redis 不遵循 ACID 原则就直接放弃。
## 文档数据库为了解决关系数据库 schema带来的问题，文档数据库应运而生。文档数据库最大的特点就是no-schema，可以存储和读取任意的数据。目前绝大部分文档数据库存储的数据格式是JSON（或者 BSON），因为 JSON数据是自描述的，无须在使用前定义字段，读取一个 JSON中不存在的字段也不会导致 SQL 那样的语法错误。文档数据库的 no-schema 特性，给业务开发带来了几个明显的优势。1\. 新增字段简单业务上增加新的字段，无须再像关系数据库一样要先执行 DDL语句修改表结构，程序代码直接读写即可。2\. 历史数据不会出错对于历史数据，即使没有新增的字段，也不会导致错误，只会返回空值，此时代码进行兼容处理即可。3\. 可以很容易存储复杂数据JSON是一种强大的描述语言，能够描述复杂的数据结构。例如，我们设计一个用户管理系统，用户的信息有ID、姓名、性别、爱好、邮箱、地址、学历信息。其中爱好是列表（因为可以有多个爱好）；地址是一个结构，包括省市区楼盘地址；学历包括学校、专业、入学毕业年份信息等。如果我们用关系数据库来存储，需要设计多张表，包括基本信息（列：ID、姓名、性别、邮箱）、爱好（列：ID、爱好）、地址（列：省、市、区、详细地址）、学历（列：入学时间、毕业时间、学校名称、专业），而使用文档数据库，一个JSON 就可以全部描述。     {                        "id": 10000,     "name": "James",     "sex": "male",     "hobbies": [          "football",         "playing",         "singing"    ],     "email": "PI:EMAIL",     "address": {          "province": "GuangDong",         "city": "GuangZhou",         "district": "Tianhe",         "detail": "PingYun Road 163"    },     "education": [          {              "begin": "2000-09-01",             "end": "2004-07-01",             "school": "UESTC",             "major": "Computer Science & Technology"        },         {              "begin": "2004-09-01",             "end": "2007-07-01",             "school": "SCUT",             "major": "Computer Science & Technology"        }    ] } 通过这个样例我们看到，使用 JSON来描述数据，比使用关系型数据库表来描述数据方便和容易得多，而且更加容易理解。文档数据库的这个特点，特别适合电商和游戏这类的业务场景。以电商为例，不同商品的属性差异很大。例如，冰箱的属性和笔记本电脑的属性差异非常大，如下图所示。![](Images/f0402ef21cf79bd45716baad9951733a.png){savepage-src="https://static001.geekbang.org/resource/image/6f/e6/6f443acc979763e793b6808763a542e6.png"}\![](Images/494b390d7c01e4b5f8f845077a0b80ba.png){savepage-src="https://static001.geekbang.org/resource/image/dd/ef/dde7fd574490c38ecda77b52bab1abef.png"}即使是同类商品也有不同的属性。例如，LCD 和 LED显示器，两者有不同的参数指标。这种业务场景如果使用关系数据库来存储数据，就会很麻烦，而使用文档数据库，会简单、方便许多，扩展新的属性也更加容易。文档数据库 no-schema的特性带来的这些优势也是有代价的，最主要的代价就是不支持事务。例如，使用MongoDB来存储商品库存，系统创建订单的时候首先需要减扣库存，然后再创建订单。这是一个事务操作，用关系数据库来实现就很简单，但如果用MongoDB来实现，就无法做到事务性。异常情况下可能出现库存被扣减了，但订单没有创建的情况。因此某些对事务要求严格的业务场景是不能使用文档数据库的。文档数据库另外一个缺点就是无法实现关系数据库的 join操作。例如，我们有一个用户信息表和一个订单表，订单表中有买家用户id。如果要查询"购买了苹果笔记本用户中的女性用户"，用关系数据库来实现，一个简单的join 操作就搞定了；而用文档数据库是无法进行 join查询的，需要查两次：一次查询订单表中购买了苹果笔记本的用户，然后再查询这些用户哪些是女性用户。