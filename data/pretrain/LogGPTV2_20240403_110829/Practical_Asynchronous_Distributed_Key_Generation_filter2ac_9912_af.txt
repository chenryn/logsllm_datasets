i
w
d
n
a
B
100
80
60
40
20
0
t + 1, curve25519
t + 1, bls12-381
2t + 1, curve25519
2t + 1, bls12-381
drand, bn256
)
s
d
n
o
c
e
s
n
i
(
e
m
i
t
n
u
R
150
100
50
0
16
32
64
128
16
32
64
128
Number of nodes
Number of nodes
Figure 4: Bandwidth usage, amount of data sent by a node during
ADKG protocol.
Figure 5: Average runtime as measured the average time difference
between the start of the ADKG and the time a node output keys.
around each) for primitive elliptic curve operations. Note
that bls12-381 supports pairing, so our implementation
can be used for pairing-based threshold cryptosystems such
as [9]. However, a downside of pairing friendly curves is
that they are less efﬁcient for applications that do not need
them, in terms of both communication and computation
costs. For example, a group element in curve25519 is 32
bytes, whereas group elements in bls12-381 are 48 and 96
bytes. Furthermore, our micro-benchmark illustrates that a
group exponentiation in bls12-381 is 6× slower than that
of curve25519.
We improve the bandwidth usage and runtime per node
of our ADKG protocol under the common case, i.e., when
all nodes are honest and the network has a small delay. We
implement the following optimizations: (1) The data dissem-
ination step of the RBC protocol [19, Algorithm 3], which
involves error correction and two rounds of communication,
can be omitted unless some nodes trigger it. This reduces
the bandwidth usage by approximately 50% in the common
case; (2) Most of the ABA instances terminate without a coin
in the common case; hence, we never explicitly compute the
threshold keys for those ABA instances. We observe that
this optimization reduces the runtime by about 65% for our
ADKG implementation with (cid:96) = t + 1 in the common case.
B. Evaluation Setup
We evaluate our ADKG implementation with a varying
number of nodes: 16, 32, 64, 128. For a given n ≥ 3t + 1,
we evaluate with two reconstruction thresholds: t + 1 and
2t + 1. We run all nodes on Amazon Web Services (AWS)
t3a.medium virtual machines (VM) with one node per VM.
Each VM has two vCPUs and 4GB RAM and runs Ubuntu
20.04.
We place nodes evenly across eight different AWS re-
gions: Canada, Ireland, N. California, N. Virginia, Oregon,
Ohio, Singapore, and Tokyo. We create an overlay network
among nodes where all nodes are pair-wise connected, i.e.,
they form a complete graph.
Baselines. Since no implementation of any ADKG exists,
we only compare with the synchronous DKG of Gennaro
et al. [31] as implemented in Drand [1]. To our knowledge,
Drand is the only DKG protocol in use today. Other imple-
mentations of synchronous DKG focus on the cryptography
part and do not implement the networking part. We evaluate
Drand with its default reconstruction threshold of n/2 + 1.
We could only run Drand with up to 64 nodes; Drand with
128 nodes keeps aborting in our experiments.
C. Evaluation Results
With our evaluation we aim to demonstrate that our
ADKG protocol scales well with the number of nodes and
has reasonable runtime and bandwidth usage.
Runtime. We measure the time difference between the start
of the ADKG protocol and when a node outputs the shared
public key and its secret share. We then average this time
across all nodes to compute the runtime of our ADKG
protocol. We report the results in Figure 5.
For (cid:96) = t+1, our ADKG protocol takes approximately 10
seconds for 64 nodes, which is only 19% of Drand. When
(cid:96) = 2t+1, however, our ADKG protocol takes much longer:
160 seconds for 64 nodes, about 3× of Drand.
Upon close inspection, we found that when (cid:96) = t + 1,
various miscellaneous steps account for most of the runtime,
whereas when (cid:96) = 2t + 1, Paillier operations dominate
the runtime. This is conﬁrmed in Table III. Speciﬁcally,
one instance of high threshold ACSS requires O(n) Paillier
operations per node, resulting in O(n2) Paillier operations
per node in the sharing phase of our high-threshold ADKG.
Running time of sharing phase. We measure the per node
running time of the sharing phase of our ADKG protocol.
More speciﬁcally, we ﬁrst measure the running time of the
dealer and non-dealer nodes separately. We then calculate
the running time of sharing phase as the sum of one dealer
node’s running time and the running time of n non-dealer
node. We report the results in Table III. Observe that when
(cid:96) = t + 1, even with 128 nodes, the running time of the
sharing phase is less than 7% of the total running time of
our ADKG protocol. However, with (cid:96) = 2t+1, for 64 nodes,
the computation time of ACSS step is more than 80% of the
total running time.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:29 UTC from IEEE Xplore.  Restrictions apply. 
12
2529
Table III: Computation cost of ACSS phase measured in time taken
(in seconds) with varying number of nodes.
Time taken (in seconds)
Elliptic Curve
(cid:96)
n = 16 n = 32 n = 64 n = 128
curve25519
bls12-381
curve25519
bls12-381
t + 1
t + 1
2t + 1
2t + 1
0.01
0.07
8.50
8.96
0.02
0.21
32.53
34.43
0.07
0.71
127.54
134.66
0.19
2.52
504.47
531.22
Bandwidth usage. We measure bandwidth usage as the
amount of bytes sent by a node in the entire ADKG protocol.
We report bandwidth usage per node in Figure 4. Consistent
with the analysis from §V, the bandwidth usage of our
protocol increases quadratically with the number of nodes.
Our bandwidth usage is signiﬁcantly lower than Drand.
Using the 64 nodes experiment, for example, each node in
Drand sends 93.8 Megabytes of data; In our ADKG, when
(cid:96) = t + 1, each node only sends 2.96 Megabytes, which is
only 1/30th of Drand; when (cid:96) = 2t + 1, each node sends
19.2 Megabytes, still only 1/5th of Drand. We note that
the higher bandwidth usage for high-threshold again comes
from the high-threshold ACSS scheme.
We also note that, although in bls12-381 group elements
are 16 bytes longer than in curve25519, this does not
noticeably affect the total protocol bandwidth usage due
to the comparable costs of other data, such as DCR group
elements, ﬁeld integers, and hashes.
IX. RELATED WORK
Starting from the seminal work of Pedersen [50], nu-
merous works have studied the problem of Distributed Key
Generation with various cryptographic assumptions, network
conditions and with other properties [13], [14], [26], [31],
[47], [37], [35], [53], [39], [40], [43], [4], [28], [19]. We will
roughly categorize prior works into two categories based on
the network assumption: Synchrony and Asynchrony.
Synchronous DKG. DKG in the synchronous network
has been studied for decades [50], [26], [13], [14], [31],
[47], [37], [35], [53]. Pedersen proposed the ﬁrst DKG
protocol [50] using a veriﬁable secret sharing. Gennaro et
al. [31] showed that the Pedersen protocol allows an attacker
to bias the public-key distribution and proposed a scheme
without this issue but at a higher cost. Neji et al. [47]
proposed a simple mechanism to mitigate the bias-attack
illustrated by [31]. We adopted their idea, but we found the
proof presented in their original paper [47] skipped some
details of the simulator. In this paper, we present a new
proof of secrecy.
Canetti et al. [13] presented extended Gennaro et al. [31]
to be secure against an adaptive adversary. Fouque and
Stern [26] used publicly veriﬁable secret sharing (PVSS) in-
stead of VSS to make the protocol non-interactive. Gurkan et
al. [37] designed a PVSS-based DKG protocol with a linear
size public-veriﬁcation transcript. However, their protocol
can only tolerate O(log n) faulty nodes. Moreover, in their
protocol, the secret key is a group element instead of a ﬁeld
element. As a result, their protocol is incompatible with off-
the-shelf threshold signature or encryption schemes. Very
recently, Groth [35] designed a new DKG protocol based
on a new PVSS scheme; the protocol is non-interactive,
assuming the existence of a broadcast channel. Moreover,
the secret key in his protocol is a ﬁeld element.
Asynchronous DKG. Only a handful of works studied the
DKG problem in partially synchronous or asynchronous
networks [40], [43], [4], [28], [19]. Kate et al. [40] extended
Pedersen’s DKG to a partially synchronous network. The
protocol has O(κn4) total communication cost, tolerates up
to one-third malicious nodes, and relies on synchrony for
termination. Tomescu et al. [56] lowered the computational
cost of Kate et al. [40] by a factor of O(n/log n) at a
logarithmic increase in communication cost.
Kokoris et al. [43] designed the ﬁrst asynchronous DKG
scheme with a total communication cost of O(κn4) and an
expected round complexity of O(n). Abraham et al. [4]
proposed an ADKG protocol with a communication cost
of O(κn3 log n). Gao et al. [28] and Das et al. [19] gave
two methods to lower the communication cost of [4] to
O(κn3). Since Abraham et al. uses the PVSS scheme of
Gurkan et al. [37], all three constructions [4], [28], [19]
inherit the limitation that the secret key is a group element
and the ADKG is not compatible with off-the-shelf threshold
encryption or signature schemes.
The setup phase of Aleph’s randomness beacon [27] used
different sources of coins for different ABA instances. Their
work inspired the key set proposal phase of our design. But
note that Aleph’s setup phase is not a ADKG protocol and
our ADKG protocol differs signiﬁcantly from it.
DKG implementations. The increasing popularity of
threshold signatures has led to many DKG implementa-
tions [53], [52], [48], [38], [1], [33], [55]. All these im-
plementations assume synchronous networks.
X. CONCLUSION
In this paper, we presented a simple and concretely
efﬁcient asynchronous distributed key generation protocol
for discrete logarithm based threshold cryptosystem. In a
network of n nodes, our ADKG protocol incurs a commu-
nication cost of O(κn3) and terminates in expected O(log n)
rounds. Our protocol uses many fundamental asynchronous
primitives such as ACSS, RBC, threshold common coin, and
ABA in a modular way. As a result, an improved protocol
for these primitives, especially high-threshold ACSS, would
immediately improve our ADKG protocol. We formally
prove the security and correctness of our ADKG protocol.
We provide a prototype implementation and evaluate our
prototype atop up to 128 geographically distributed nodes
to illustrate the practicality of our ADKG protocol.
13
2530
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:29 UTC from IEEE Xplore.  Restrictions apply. 
ACKNOWLEDGMENTS
The authors would like to thank Amit Agarwal, Adithya
Bhat, Kobi Gurkan, Dakshita Khurana, Nibesh Shrestha, and
Gilad Stern for the helpful discussions related to the paper.
Also, the authors would like to thank Sylvain Bellemare for
helping with the hbACSS codebase and Nicolas Gailly for
helping with running the Drand experiments.
REFERENCES
[1] “Drand - a distributed randomness beacon daemon,” 2020,
https://github.com/drand/drand.
[2] “curve25519-dalek: A pure-rust
implementation of group
operations on ristretto and curve25519,” 2021, https://github.
com/dalek-cryptography/curve25519-dalek.
[3] “hbacss,” 2021, https://github.com/tyurek/hbACSS.
[4] I. Abraham, P. Jovanovic, M. Maller, S. Meiklejohn, G. Stern,
and A. Tomescu, “Reaching consensus for asynchronous
distributed key generation,” in Proceedings of the 2021 ACM
Symposium on Principles of Distributed Computing, 2021, pp.
363–373.
[5] I. Abraham, D. Malkhi, and A. Spiegelman, “Asymptotically
optimal validated asynchronous byzantine agreement,” in
Proceedings of the 2019 ACM Symposium on Principles of
Distributed Computing, 2019, pp. 337–346.
[6] N. Alhaddad, M. Varia, and H. Zhang, “High-threshold avss
with optimal communication complexity,” in International
Conference on Financial Cryptography and Data Security.
Springer, 2021, pp. 479–498.
[7] M. Ben-Or and R. El-Yaniv, “Resilient-optimal interactive
consistency in constant time,” Distributed Computing, vol. 16,
no. 4, pp. 249–262, 2003.
[8] M. Ben-Or, B. Kelmer, and T. Rabin, “Asynchronous se-
cure computations with optimal resilience,” in Proceedings
of the thirteenth annual ACM symposium on Principles of
distributed computing, 1994, pp. 183–192.
[9] A. Boldyreva, “Threshold signatures, multisignatures and
blind signatures based on the gap-difﬁe-hellman-group sig-
nature scheme,” in International Workshop on Public Key
Cryptography. Springer, 2003, pp. 31–46.
[13] R. Canetti, R. Gennaro, S. Jarecki, H. Krawczyk, and T. Ra-
bin, “Adaptive security for threshold cryptosystems,” in An-
nual International Cryptology Conference. Springer, 1999,
pp. 98–116.
[14] J. Canny and S. Sorkin, “Practical large-scale distributed key
generation,” in International Conference on the Theory and
Applications of Cryptographic Techniques. Springer, 2004,
pp. 138–152.
[15] I. Cascudo and B. David, “Scrape: Scalable randomness
attested by public entities,” in International Conference on
Applied Cryptography and Network Security. Springer, 2017,
pp. 537–556.
[16] D. Chaum and T. P. Pedersen, “Wallet databases with ob-
servers,” in Annual International Cryptology Conference.
Springer, 1992, pp. 89–105.
[17] T. Crain, “Two more algorithms for randomized signature-
free asynchronous binary byzantine consensus with t < n/3
and o(n2) messages and o(1) round expected termination,”
arXiv preprint arXiv:2002.08765, 2020.
[18] G. Danezis, L. Kokoris-Kogias, A. Sonnino, and A. Spiegel-
man, “Narwhal and tusk: a dag-based mempool and efﬁcient
bft consensus,” in Proceedings of the Seventeenth European
Conference on Computer Systems, 2022, pp. 34–50.
[19] S. Das, Z. Xiang, and L. Ren, “Asynchronous data dissem-
ination and its applications,” in Proceedings of
the 2021
ACM SIGSAC Conference on Computer and Communications
Security, 2021.
[20] C. Data61, “Python paillier
data61/python-paillier, 2013.
library,” https://github.com/
[21] Y. G. Desmedt, “Threshold cryptography,” European Trans-