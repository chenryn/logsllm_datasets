[13] T.-H. H. Chan, K.-M. Chung, B. Maggs, and E. Shi. Foundations
of differentially oblivious algorithms. ePrint 2017/1033, 2017. https:
//eprint.iacr.org/2017/1033.
[14] S. Chen, X. Zhang, M. K. Reiter, and Y. Zhang. Detecting Privileged Side-
Channel Attacks in Shielded Execution with Déjà Vu. In AsiaCCS ’17.
[15] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. Introduction
to Algorithms, 3rd Edition. MIT Press, 2009.
[16] V. Costan, I. A. Lebedev, and S. Devadas. Sanctum: Minimal hardware
extensions for strong software isolation. In USENIX Security ’16.
[17] R. Curtmola, J. Garay, S. Kamara, and R. Ostrovsky. Searchable
symmetric encryption: improved deﬁnitions and efﬁcient constructions.
In CCS ’06.
[18] J. Doerner and A. Shelat. Scaling ORAM for secure computation. In
CCS ’17.
[19] Enron email dataset. https://www.cs.cmu.edu/~./enron/.
[20] S. Eskandarian and M. Zaharia. An oblivious general-purpose SQL
database for the cloud. ArXiv, Report 1710.00458, 2017. http://arxiv.
org/abs/1710.00458.
[21] S. Faber, S. Jarecki, S. Kentros, and B. Wei. Three-Party ORAM for
secure computation. In ASIACRYPT ’15.
[22] C. W. Fletcher, L. Ren, A. Kwon, M. van Dijk, E. Stefanov, D. Serpanos,
and S. Devadas. A low-latency, low-area hardware oblivious RAM
controller. In FCCM ’15.
[23] B. Fuhry, R. Bahmani, F. Brasser, F. Hahn, F. Kerschbaum, and
In
A. Sadeghi. HardIDX: Practical and secure index with SGX.
DBSec ‘17.
[24] S. Garg, P. Mohassel, and C. Papamanthou. TWORAM: Efﬁcient
oblivious RAM in two rounds with applications to searchable encryption.
In CRYPTO ’16.
[25] C. Gentry, K. A. Goldman, S. Halevi, C. S. Jutla, M. Raykova, and
D. Wichs. Optimizing ORAM and using it efﬁciently for secure
computation. In PETS ’13.
[26] M. Giaruad, A. Anzala-Yamajako, O. Bernard, and P. Lafourcase.
Practical passive leakage-abuse attacks against symmetric searchable
encryption. In ICETE ’17.
[27] O. Goldreich and R. Ostrovsky. Software protection and simulation on
oblivious RAMs. J. ACM, 1996.
[28] M. T. Goorish, M. Michael, O. Ohrimenko, and T. Roberto. Privacy-
preserving group data access via stateless oblivious RAM simulation. In
SODA ’12.
[29] J. Götzfried, M. Eckert, S. Schinzel, and T. Müller. Cache Attacks on
Intel SGX. In EUROSEC ’17.
[30] P. Grubbs, R. McPherson, M. Naveed, T. Ristenpart, and V. Shmatikov.
Breaking web applications built on top of encrypted data. In CCS ’16.
[31] D. Gruss, J. Lettner, F. Schuster, O. Ohrimenko, I. Haller, and M. Costa.
Strong and efﬁcient cache side-channel protection using hardware
transactional memory. In USENIX Security ’17.
[32] M. Hähnel, W. Cui, and M. Peinado. High-resolution side channels for
untrusted operating systems. In ATC ’2017.
[33] W. He, D. Akhawe, S. Jain, E. Shi, and D. X. Song. ShadowCrypt:
Encrypted web applications for everyone. In CCS ’14.
[34] M. S. Islam, M. Kuzu, and M. Kantarcioglu. Access pattern disclosure on
searchable encryption: Ramiﬁcation, attack and mitigation. In NDSS ’12.
[35] S. Johnson, V. Scarlata, C. Rozas, E. Brickell, and F. McKeen. Intel
software guard extensions: EPID provisioning and attestation services.
[36] S. Kamara, C. Papamanthou, and T. Roeder. Dynamic searchable
symmetric encryption. In CCS ’12.
[37] G. Kellaris, G. Kollios, K. Nissim, and A. O’Neill. Generic attacks on
secure outsourced databases. In CCS ’16.
[38] M. Keller and P. Scholl. Efﬁcient, oblivious data structures for MPC. In
ASIACRYPT ’14.
[39] K. Kurosawa. Garbled searchable symmetric encryption. In FC ’14.
[40] B. Lau, S. P. Chung, C. Song, Y. Jang, W. Lee, and A. Boldyreva.
Mimesis Aegis: A mimicry privacy shield - a system’s approach to data
privacy on public cloud. In USENIX Security ’14.
[41] C. Liu, A. Harris, M. Maas, M. W. Hicks, M. Tiwari, and E. Shi.
Ghostrider: A hardware-software system for memory trace oblivious
computation. In ASPLOS ’15.
[42] C. Liu, L. Zhu, M. Wang, and Y.-A. Tan. Search pattern leakage
in searchable encryption: Attacks and new construction. Information
Sciences, 2014.
[43] J. R. Lorch, B. Parno, J. W. Mickens, M. Raykova, and J. Schiffman.
Shroud: ensuring private access to large-scale data in the data center. In
FAST ’13.
[44] Marlinspike, Moxie. Technology preview: Private contact discovery for
Signal. https://signal.org/blog/private-contact-discovery/, 2017.
[45] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shaﬁ,
Innovative instructions and
V. Shanbhogue, and U. R. Savagaonkar.
software model for isolated execution. In HASP ’13.
[46] M. S. Melara, A. Blankstein, J. Bonneau, E. W. Felten, and M. J.
Freedman. CONIKS: bringing key transparency to end users. In USENIX
Security ’15.
[47] R. C. Merkle. A certiﬁed digital signature. In CRYPTO ’89.
[48] T. Moataz and E.-O. Blass. Oblivious substring search with updates.
ePrint 2015/722, 2015. http://eprint.iacr.org/2015/722.
[49] A. Moghimi, G. Irazoqui, and T. Eisenbarth. Cachezoom: How SGX
ampliﬁes the power of cache attacks. In CHES ’17.
[50] M. Naveed. The fallacy of composition of oblivious RAM and searchable
encryption. ePrint 2015/668, 2015.
[51] M. Naveed, M. Prabhakaran, and C. A. Gunter. Dynamic searchable
encryption via blind storage. In SP ’14.
[52] W. Ogata, K. Koiwa, A. Kanaoka, and S. Matsuo. Toward practical
searchable symmetric encryption. In IWSEC ’13.
[53] D. Pouliot and C. V. Wright. The shadow nemesis: Inference attacks on
efﬁciently deployable, efﬁciently searchable encryption. In CCS ’16.
[54] Relevance scores: Understanding and customizing. https://docs.marklogic.
com/guide/search-dev/relevance.
[55] D. S. Roche, A. J. A. Aviv, and S. G. Choi. A practical oblivious map
data structure with secure deletion and history independence. In SP ’16.
[56] C. Sahin, V. Zakhary, A. El Abbadi, H. Lin, and S. Tessaro. TaoStore:
Overcoming asynchronicity in oblivious data storage. In SP ’16.
[57] S. Sasy, S. Gorbunov, and C. W. Fletcher. Zerotrace : Oblivious memory
primitives from Intel SGX. ePrint 2017/549, 2017. http://eprint.iacr.org/
2017/549.
[58] M. Schwarz, S. Weiser, D. Gruss, C. Maurice, and S. Mangard. Malware
Guard Extension: Using SGX to conceal cache attacks. In DIMVA ’17.
[59] M.-W. Shih, S. Lee, T. Kim, and M. Peinado. T-SGX: Eradicating
controlled-channel attacks against enclave programs. In NDSS ’17.
[60] S. Shinde, Z. L. Chua, V. Narayanan, and P. Saxena. Preventing page
faults from telling your secrets. In AsiaCCS ’16.
[61] R. Sinha, S. K. Rajamani, and S. A. Seshia. A compiler and veriﬁer for
page access oblivious computation. In ESEC/FSE ’17.
[62] D. X. Song, D. Wagner, and A. Perrig. Practical techniques for searches
on encrypted data. In SP ’00.
[63] E. Stefanov, C. Papamanthou, and E. Shi. Practical dynamic searchable
encryption with small leakage. In NDSS ’14.
[64] E. Stefanov, M. van Dijk, E. Shi, C. W. Fletcher, L. Ren, X. Yu, and
S. Devadas. Path ORAM: an extremely simple oblivious RAM protocol.
In CCS ’13.
[65] R. Strackx and F. Piessens. Ariadne: a minimal approach to state
continuity. In USENIX Security ’16.
[66] S. Tamrakar, J. Liu, A. Paverd, J. Ekberg, B. Pinkas, and N. Asokan. The
circle game: Scalable private membership test using trusted hardware.
In AsiaCCS ’17.
[67] T. Toft. Secure data structures based on multi-party computation. In
[69] J. Van Bulck, N. Weichbrodt, R. Kapitza, F. Piessens, and R. Strackx.
Telling your secrets without page faults: Stealthy page table-based attacks
on enclaved execution. In USENIX Security ’17.
[70] P. Wang, H. Wang, and J. Pieprzyk. Secure coprocessor-based private
information retrieval without periodical preprocessing. In AISC ’10.
[71] W. Wang, G. Chen, X. Pan, Y. Zhang, X. Wang, V. Bindschaedler, H. Tang,
and C. A. Gunter. Leaky Cauldron on the Dark Land: Understanding
memory side-channel hazards in SGX. In CCS ’17.
[72] X. S. Wang, T. Chan, and E. Shi. Circuit ORAM: On tightness of the
goldreich-ostrovsky lower bound. In CCS ’15.
[68] S. Tople and P. Saxena. On the trade-offs in oblivious execution
PODC ’11.
techniques. In DIMVA ’17.
293
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. 
[73] X. S. Wang, Y. Huang, T. Chan, A. Shelat, and E. Shi. SCORAM:
oblivious RAM for secure computation. In CCS ’14.
[74] X. S. Wang, K. Nayak, C. Liu, T. H. Chan, E. Shi, E. Stefanov, and
Y. Huang. Oblivious data structures. In CCS ’14.
[75] Y. Xu, W. Cui, and M. Peinado. Controlled-channel attacks: Deterministic
side channels for untrusted operating systems. In SP ’15.
[76] Y. Yang, X. Ding, R. H. Deng, and F. Bao. An efﬁcient PIR construction
using trusted hardware. In ISW ’08.
[77] X. Yu, C. Fletcher, L. Ren, M. van Dijk, and S. Devadas. Efﬁcient private
information retrieval using secure hardware. MIT Tech Report 509, 2013.
http://csg.csail.mit.edu/pubs/memos/Memo-509/memo509.pdf.
[78] S. Zahur, X. S. Wang, M. Raykova, A. Gascón, J. Doerner, D. Evans,
and J. Katz. Revisiting Square-Root ORAM: efﬁcient random access in
multi-party computation. In SP ’16.
[79] Y. Zhang, J. Katz, and C. Papamanthou. All your queries are belong
to us: The power of ﬁle-injection attacks on searchable encryption. In
USENIX Security ’16.
APPENDIX A
CONSTRUCTION OF AN OSM SCHEME
We now provide details for our construction of an OSM sch-
eme from Section IV-C. We ﬁrst provide detailed pseudocode
(Fig. 11) for our construction, and then provide correctness
and security proofs for the same.
Theorem 1. The OSM scheme from Section IV-C is correct
as per the security deﬁnition in Section IV-B.
Proof. The oblivious sorted multimap scheme is correct assum-
ing the correctness of the plaintext sorted multimap and the
oblivious data structures framework of [74] are correct. It is
easy to verify the correctness of the plaintext sorted multimap,
since it is a small modiﬁcation to order statistic trees and
AVL trees. The sorted multimap also satisﬁes Deﬁnition 1, and
hence can be used with the ODS framework.
Theorem 2. The OSM scheme from Section IV-C is secure as
per the security deﬁnition in Section IV-B.
Proof. We construct a simulator Sim (Fig. 15) that uses the
ODS simulator SimODS as a black box. The view of an ad-
versary interacting with the simulator oracle SIdeal instantiated
OSM.InitS(m, Map):
1) Let Tree = Map.New();
2) For (k, v) ∈ Map: Tree.Insert(k, v).
3) Let rt = Tree.root().
4) Let i = 1.
5) If rt (cid:7)= ⊥, for each node in Tree:
a) If node = rt: irt = i.
b) i := i + 1.
6) Let (ptrrt
7) Output st = (ptrrt
, rt, stODS).
, stODS) := ODS.Init(m, Tree, irt).
OSM.InsertS(mut st, k, v):
1) Let ptrrt := st.ptrrt.
2) Let stODS := st.stODS.
3) Let (rt
4) Let pad := 1.44 · log(osmClient.treeSize) + 1.
(cid:2), pad).
5) st.ptrrt := ODS.FinalizeS(mut stODS, rt
(cid:2), . . . ) ← OSM.InsHelperS(mut st, k, v, ptrrt) (Fig. 13).
with Sim is indistinguishable from an adversary interacting with
SReal because the simulator pads the number of access to the
appropriate amount, and so the adversary sees the same number
of read and write memory accesses to the server regardless of
the query input.
Sim.InitS(m, (cid:4)k, (cid:4)v):
1) l := calc_node_size((cid:4)k, (cid:4)v).
2) stODS ← SimODS.InitS(m, l).
3) Store st := ((cid:4)k, (cid:4)v, stODS).
Sim.SizeS():
1) Let b := 1.44 log(m).
2) SimODS.AccessS(mut stODS, b).
Sim.InsertS():
1) Let b := 1.44 log(m) + 1.
2) SimODS.AccessS(mut stODS, b).
Sim.FindS(r):
1) Let b := 2 × 1.44 log(m) + r.
2) SimODS.AccessS(mut stODS, b).
Figure 15: Simulator for our OSM construction.
APPENDIX B
SECURITY OF PATH ORAM
Security for Path ORAM is deﬁned via two experiments:
one in which an adversary interacts with an oracle SReal acting
as a proxy to the scheme, and another in which the adversary
interacts with an oracle SIdeal that acts as a proxy to a simulator
Sim that only gets some of the inputs. Both oracles expose to
the adversary the same interface (see Fig. 16): the adversary
can make an Init query that speciﬁes the initial blocks (and a
maximum number of blocks), and then can make any number
of Read or Evict queries, with the restriction that the input
to any Evict query is the list of all leaves fetched since the
previous such call. The adversary may observe accesses to the
server made by the oracles as a result of these invocations. Path
ORAM is secure if the adversary cannot distinguish between
the two experiments.
APPENDIX C
SECURITY OF AN ODS SCHEME
Security of an ODS scheme deﬁned via two experiments:
one in which an adversary interacts with an oracle SReal
OSM.SizeS(mut st, k):
1) Let rootKey := st.rt.key.
2) Let ptr := st.ptrrt.
3) ODS.StartS(mut st.stODS, st.ptrrt)
4) Let size := 0.
5) While rootKey (cid:7)= ⊥:
a) Let curNode ← ODS.AccessS(mut st.stODS, read(ptr)).
b) If rootKey = k: set size := curNode.size(); break.
c) Else if rootKey < k:
i) rootKey := curNode.leftKey().
ii) ptr := curNode.lChild().
d) Else:
i) rootKey := curNode.rightKey().
ii) ptr := curNode.rChild().
6) Let bound := 1.44 · log(osmClient.treeSize).
7) st.ptrrt := ODS.FinalizeS(mut st.stODS, st.rt, bound).
8) Output size.
OSM.FindS(st, k, i, j):
1) Let ptrrt := st.ptrrt.
2) Let stODS := st.stODS.
3) Let (rt
4) Let pad := 1.44 · log(osmClient.treeSize) + 1.
(cid:2), pad).
5) st.ptrrt := ODS.FinalizeS(mut stODS, rt
6) Output #—v .
(cid:2), #—v ) ← OSM.FindHelperS(mut st, k, v, ptrrt) (Fig. 12).
Figure 11: Construction of a sorted multimap.
294
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. 
OSM.FindHelperS(mut st, k, i, j)
1) Let stODS := st.stODS.
2) if rootKey (cid:7)= ⊥:
a) Find path to i-th k-node:
b) Find path to j-th k-node:
lower ← OSM.GetAtIndexS(mut st, k, i).
upper ← OSM.GetAtIndexS(mut st, k, j).
c) Find node with index i: ﬁrst := last(lower).
d) Find node with index j: last := last(upper).
e) Let intersection := ⊥.
f) For i ∈ {0, . . . , min(lower.len, upper.len)}:
Compute the node at the intersection of the two paths:
if lower[i] = upper[i]: set intersection := lower[i].
Find nodes that lie between the two paths:
g) If intersection (cid:7)= ⊥:
i) Initialize empty queue workQueue.
ii) Initialize empty list of matching nodes results.