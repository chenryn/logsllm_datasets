title:GREBE: Unveiling Exploitation Potential for Linux Kernel Bugs
author:Zhenpeng Lin and
Yueqi Chen and
Yuhang Wu and
Dongliang Mu and
Chensheng Yu and
Xinyu Xing and
Kang Li
3
8
6
3
3
8
9
.
2
2
0
2
.
4
1
2
6
4
P
S
/
9
0
1
1
.
0
1
:
I
O
D
|
E
E
E
I
2
2
0
2
©
0
0
.
1
3
$
/
2
2
/
9
-
6
1
3
1
-
4
5
6
6
-
1
-
8
7
9
|
)
P
S
(
y
c
a
v
i
r
P
d
n
a
y
t
i
r
u
c
e
S
n
o
m
u
i
s
o
p
m
y
S
E
E
E
I
2
2
0
2
2022 IEEE Symposium on Security and Privacy (SP)
GREBE: Unveiling Exploitation Potential for Linux
Kernel Bugs
Zhenpeng Lin††∗, Yueqi Chen††, Yuhang Wu††, Dongliang Mu†(cid:107), Chensheng Yu‡, Xinyu Xing§(cid:107), Kang li¶
††The Pennsylvania State University †School of Cyber Science and Engineering, HUST
‡George Washington University
§Northwestern University
¶Baidu USA
{zplin, ycx431, yuhang}@psu.edu, PI:EMAIL,
PI:EMAIL, PI:EMAIL, PI:EMAIL
Abstract—Nowadays, dynamic testing tools have signiﬁcantly
expedited the discovery of bugs in the Linux kernel. When unveil-
ing kernel bugs, they automatically generate reports, specifying
the errors the Linux encounters. The error in the report implies
the possible exploitability of the corresponding kernel bug. As a
result, many security analysts use the manifested error to infer a
bug’s exploitability and thus prioritize their exploit development
effort. However, using the error in the report, security researchers
might underestimate a bug’s exploitability. The error exhibited in
the report may depend upon how the bug is triggered. Through
different paths or under different contexts, a bug may manifest
various error behaviors implying very different exploitation
potentials. This work proposes a new kernel fuzzing technique
to explore all the possible error behaviors that a kernel bug
might bring about. Unlike conventional kernel fuzzing techniques
concentrating on kernel code coverage, our fuzzing technique is
more directed towards the buggy code fragment. It introduces
an object-driven kernel fuzzing technique to explore various
contexts and paths to trigger the reported bug, making the bug
manifest various error behaviors. With the newly demonstrated
errors, security researchers could better infer a bug’s possible
exploitability. To evaluate our proposed technique’s effectiveness,
efﬁciency, and impact, we implement our fuzzing technique as a
tool GREBE and apply it to 60 real-world Linux kernel bugs. On
average, GREBE could manifest 2+ additional error behaviors for
each of the kernel bugs. For 26 kernel bugs, GREBE discovers
higher exploitation potential. We report to kernel vendors some
of the bugs – the exploitability of which was wrongly assessed
and the corresponding patch has not yet been carefully applied
– resulting in their rapid patch adoption.
I. INTRODUCTION
Today, Linux powers a wide variety of computing systems.
To improve its security, researchers and analysts introduced au-
tomated kernel fuzzing techniques and various debugging/san-
itization features. With their facilitation, it becomes easier
for security researchers and kernel developers to pinpoint a
bug in the Linux kernel. However, it is still challenging to
determine whether bug conditions are sufﬁcient to represent
a security vulnerability. For example, a bug that demonstrates
out-of-bound error behaviors usually implies a higher chance
to exploit than those that exhibit null pointer dereference error
behaviors. As such, both our survey result (shown in A) and
previous research [1], [2], [3] indicate that the manifested error
behaviors of bugs play a critical role in prioritizing exploit
development efforts.
∗Part of the work was done during the summer internship at Baidu USA
(cid:107)Corresponding author
In practice, when existing fuzzing tools identify a kernel
bug, the manifested error behavior of the bug may be one
of its many possible error behaviors. Its other possible error
behaviors could be far away from the one that has been already
exposed. For example, as we will elaborate in Section II, by
following different paths or execution contexts to trigger a
kernel bug, we can make a kernel bug exhibit not only a less-
likely-to-exploit GPF (General Protection Fault) error behavior
but also a highly-likely-to-exploit UAF (Use-After-Free) error
behavior. As such, it could be misleading if security analysts
only use singly manifested error behavior to infer the bug’s
possible exploitability.
In order to address this problem, one instinctive reaction is
to take as input a kernel bug report, analyze the root cause
of that kernel bug, and infer all possible consequences that
the root cause of the bug could potentially bring about (e.g.,
out-of-bound memory violation, null pointer dereference, and
memory leak, etc.). However, root cause diagnosis is typically
considered a time-consuming and labor-intensive task. As a
result, we argue that a more realistic strategy for tackling
this problem is to expose many possible post-triggered error
behaviors of a given kernel bug without performing root cause
analysis. Then, from the error behaviors unveiled, security
analysts could better infer its possible exploitability in a more
accurate fashion.
To realize the idea above, we can borrow the concept
of kernel fuzzing. However, existing kernel fuzzing methods
are mainly designed to maximize the code coverage (e.g.,
Syzkaller [4], KAFL [5] and Trinity [6], etc.). Using them in
our task inevitably suffers from inefﬁciency and ineffective-
ness issues, it is simply because code-coverage-driven kernel
fuzzing is not customized nor optimized for ﬁnding various
paths or contexts relevant to the same buggy code fragment. To
this end, we propose a customized kernel fuzzing mechanism
that concentrates its fuzzing energy on the buggy code areas
and, meanwhile, diversiﬁes the kernel execution paths and
contexts towards the target buggy code fragment.
Technically speaking, our proposed kernel fuzzing mech-
anism could be viewed as a directed fuzzing approach. It
ﬁrst takes one kernel bug report as input and extracts the
kernel structures/objects relevant to the reported kernel error.
Then, the fuzzing method performs fuzzing testing and utilizes
the hits to the identiﬁed kernel structures/objects as feedback
© 2022, Zhenpeng Lin. Under license to IEEE.
DOI 10.1109/SP46214.2022.00071
2078
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
to the fuzzer. Since the identiﬁed kernel structures/objects
are essential to the success in triggering the reported bug,
using them to guide fuzzing could narrow the scope of the
kernel fuzzer, making the fuzzer focus mostly on the paths
and contexts pertaining to the reported bug. In this work, we
implement this approach as a kernel-object-driven fuzzing tool
and name it after GREBE, standing for “fuzzinG foR multiplE
Behavior Exploration”.
Using our tool to explore error behaviors for 60 kernel bug
reports, we show that GREBE could demonstrate more than
2 different error behaviors on average for each given bug
report. For many kernel bugs in our experiment (26 out of
60), we also observe that their newly identiﬁed error behaviors
usually demonstrate a higher exploitation potential than those
listed in the original bug report. More surprisingly, through the
paths and contexts that we newly identiﬁed, we also discover
6 kernel bugs with seemly unexploitable memory corruption
ability (e.g. GPF, kernel warning, etc.) could be turned into
ones with powerful memory corruption ability that can be
utilized to perform an arbitrary execution. All these bugs have
not demonstrated any exploitability before. We report this
ﬁnding to some kernel vendors – that have not yet applied
the ready-to-use patches in their products – resulting in their
immediate patch adoption.
To the best of our knowledge, this is the ﬁrst work that
exposes a bug’s multiple error behaviors for exploitability
exploration. The exhibition of multiple error behaviors could
potentially expedite the remedy and elimination of highly ex-
ploitable bugs from the kernel. Besides, it could also augment
security analysts to turn an unexploitable primitive into an
exploitable one. Last but not least, demonstrating a bug with
multiple error behaviors could also potentially beneﬁt the bug’s
root cause diagnosis [7].
In summary, this paper makes the following contributions.
• We design a new technical approach that utilizes carefully
selected kernel objects to guide kernel fuzzing and thus
explores a bug’s multiple error behaviors.
• Following our design, we extend Syzkaller,
implement
GREBE, and demonstrate its utility in ﬁnding multiple error
behaviors for 60 distinct real-world Linux kernel bugs.
• We show that given a kernel bug demonstrating only a low
possibility to exploit, our proposed method could ﬁnd its
other error behaviors indicating much stronger exploitability.
II. MOTIVATING EXAMPLE
A reported kernel error implies the potential exploitability
of the corresponding bug. As we mentioned above, the mani-
fested error depends upon how the bug is triggered. As such,
using a single bug report (exhibiting one error behavior) could
possibly bring about the underestimation of that bug’s potential
exploitability. In Listing 1, we show a concrete example to
illustrate this issue.
As is depicted in the list, the function tun_attach is respon-
sible for conﬁguring the network interface. Its argument tun
(cid:44)→ refers to a global variable shared by all the tun ﬁles in
the opened state. As is shown in line 3, if IFF_NAPI is set
if (tun->flags & IFF_NAPI) {
1 static void tun_attach(struct tun_struct *tun, ...)
2 {
3
4
5
6
7
8
9
// initialize a timer
hrtimer_init(&napi->timer, CLOCK_MONOTONIC,
// link current napi to the device’s napi list
list_add(&napi->dev_list, &dev->napi_list);
HRTIMER_MODE_REL_PINNED);
}
struct tun_struct *tun = rtnl_dereference(tfile->tun);
if (tun->flags & IFF_NAPI) {
// GPF happens if timer is uninitialized
hrtimer_cancel(&tfile->napi->timer);
// remove the current napi from the list
netif_napi_del(&tfile->napi);
10 }
11
12 static void tun_detach(struct tun_file *tfile, ...)
13 {
14
15
16
17
18
19
20
21
22 }
23
24 void free_netdev(struct net_device *dev) {
25
26
27
28 }