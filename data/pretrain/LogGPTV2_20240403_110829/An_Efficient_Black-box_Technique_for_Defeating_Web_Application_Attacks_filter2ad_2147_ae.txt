ence algorithm was compared, without considering the time
for I/O, parsing, policy enforcement, etc. We observed that
• taint inference was speeded up by a factor of 10 to 20,
with the average of about 14,
• taint inference memory requirements were reduced by
a factor of 50 to 1000, and
• the time spent in the coarse-ﬁltering algorithm far ex-
ceeded the time spent in the edit-distance algorithm.
Next, we investigated the relative contribution of differ-
ent components of our implementation (excluding the time
spent within event interceptors) to the overall performance.
We found that
• about 60% of the time was spent in taint inference al-
gorithms,
• about 20% of the time was spent in the parser, and an-
other 20% in policy checking.
These numbers were obtained using proﬁling tools. These
results validate the efforts put into improving the perfor-
mance of taint inference.
Overall Performance overhead. Finally, we measured
the total performance overhead introduced by our approach,
after all optimizations (including pruning policies) were
factored in. Our focus in this context was on benign re-
quests, the assumption being that the vast majority of re-
quests received by a protected server would likely be be-
nign, and hence the overhead due to benign requests will
dominate over those of attacks. For this measurement, we
used the AMNESIA dataset because the requests can be
launched from a script. (In contrast, user interaction is re-
quired for other applications, thus making it hard to make
meaningful performance measurements.) All of the policies
shown in Figure 6 were enforced.
Figure 9 shows the results. The “response time” column
shows the total time taken (in seconds) to carry out all of
the requests in the absence of our defenses. (Not even the
event interceptors are in place.) It measures the wall-clock
time for sending all the requests and receiving responses.
The “overhead” column shows the increase in response time
when our defenses are enabled.
These performance numbers reﬂect the effect of the opti-
mization described in Section 6. This optimization is excep-
tionally effective: when an input parameter does not match
our attack ﬁltering criteria, then it is not processed by taint
inference algorithm. Moreover, output parsing and policy
enforcement are skipped if none of the parameters in a ses-
sion match attack-ﬁltering criteria. As a result, this opti-
mization improves performance by an average factor of 5
for these applications.
8 Related Work
Model-carrying code [24] and Dataﬂow anomaly detec-
tion [1] developed techniques for discovering information
ﬂows by using runtime comparison of parameter values to
different function calls. The focus of these works was to dis-
cover equality relationships among relatively short strings
(mainly, ﬁle names), which is much easier than the taint in-
ference problem described in this paper. Moreover, those
works were concerned with building an automata model of
program behavior, which is quite different from our goals
in this paper of deﬁning policies and detecting injection at-
tacks.
A number of techniques have been developed that rely
on taint-tracking for detecting memory corruption attacks
[27, 5, 16] and script injection attacks [21, 17, 10]. This
prompted much research into efﬁcient techniques for auto-
mated taint-tracking [28, 13, 22, 23]. Nevertheless, taint-
tracking remains quite expensive, at least in the context of C
and binary code, incurring high overheads of 50% or more.
More importantly, it requires extensive instrumentation of
protected application, which may impact its stability, and/or
may need source code access. We have therefore developed
a complementary approach that avoids such instrumenta-
tion.
Several researchers have made the observation that in-
jection attacks are characterized by changes to the struc-
ture of commands. AMNESIA [9] relied on a static anal-
ysis to detect the intended structure of SQL queries. Static
analysis, since it must operate without knowing runtime in-
puts, must make some approximations that decrease its ac-
curacy. Candid [25] therefore uses a dynamic analysis to
discover intended query structure. Recently, this technique
was extended to address XSS attacks [2]. These dynamic
approaches, although different from taint-tracking, never-
theless rely on deep instrumentation of protected applica-
tions, and hence have drawbacks similar to those of taint-
tracking approaches.
Our approach, in many ways, is similar to traditional
intrusion detection techniques. These techniques can op-
erate non-intrusively, based on observations that could be
made without deep instrumentation, or otherwise adversely
affecting the application operation. At the same time, our
approach is able to offer greatly improved accuracy over
intrusion detection techniques, which have historically suf-
fered from high false positive (or in false negative) rates.
Indeed, our approach is able to offer about the same level of
accuracy as taint-tracking and related techniques, but with-
out the need for deep instrumentation.
It may appear that taint-tracking techniques have an ad-
vantage in terms of being able to reason about information
ﬂows in the presence of complex transformations, but this
is arguable. Most practical taint-tracking techniques track
only data dependence, and ignore control-dependence and
implicit ﬂows. This results in missing ﬂows when complex
transformations take place. Moreover, when tainted and un-
tainted data are stored and retrieved from the same aggre-
gate data structure, taint-tracking techniques can introduce a
number of false positives. In contrast, none of these aspects
lead to problems with our approach, but it faces a different
set of problems, such as the application of simple functions
on input data. Thus, in terms of their ability to handle com-
plex transformations, the strengths and weaknesses of the
two approaches complement each other. Moreover, since
web applications do not seem to use many complex trans-
formations (except the standard encodings that are already
handled by our approach), our taint inference approach is
robust enough to reliably detect attacks on them.
The focus of Su et al [26] was on developing a for-
mal characterization SQL injection and related attacks. Our
work improves on theirs by providing a policy framework
that is language-neutral, and moreover, is decoupled from
parser implementations.
The implementation of Su et al [26] does not require ap-
plication instrumentation. However, it relies on modifying
inputs to add “bracketing” characters around each input. It
assumes that these characters would propagate unchanged
to the output, where they can be stripped away. This tech-
nique is fragile and can break many real applications. For
instance, in the case of SquirrelMail and phpBB, a num-
ber of input parameters are not used in SQL queries, so the
technique may have no opportunity to remove the brackets
before the parameter value is used. In other cases, the pa-
rameter may be used in SQL queries as well as for other pur-
poses, e.g., generating a URL, setting a cookie value, gen-
erating a ﬁle name, etc. Moreover, applications may make
assumptions about the length of their inputs, or may per-
form computations that depend on their value. Finally, even
if the bracketing approach could be used, it requires man-
ual assistance to identify the set of characters that could be
used for bracketing. In contrast, our approach does not re-
quire any modiﬁcation of inputs or outputs, and is truly a
black-box technique.
Microsoft has recently incorporated a defense for com-
mon forms of reﬂected XSS attacks in IE 8 [15]. It shares
some similarities with our approach:
it is also based on
comparing inputs and outputs, and it detects attacks when
the HTTP request data matches some of the characteris-
tics of an XSS attack. But there are several differences as
well. Whereas our defense is implemented on the server
side, their defense is more accessible to an end-user since
it resides on the client side. More importantly, the techni-
cal approach for recognizing reﬂection is quite different in
the two approaches. Whereas we rely on rough parsing and
approximate substring matching, their approach is based on
regular expression matching. Speciﬁcally, they match out-
going HTTP requests against regular expressions crafted to
identify those requests that may be involved in XSS attacks.
If there is a match, their approach generates another regular
expression that captures the characteristics of a response (to
this request) that contains an attack. If the response matches
this regular expression, an XSS attack is detected. The reg-
ular expression used to match against requests differs from
that for responses in order to allow for small changes (such
as character removal, insertion or translation) that may oc-
cur on the server. Whereas we rely on approximate string
matching to handle this problem, their approach seems to
rely on the developers to encode possible differences ex-
plicitly in terms of the differences between the regular ex-
pressions for matching requests and responses.
Privacy Oracle [12] is a recently developed black box
approach for discovering information leaks by applications.
Although information leaks are often modeled in terms of
information ﬂows, this is not the approach taken in Privacy
Oracle. Instead, they infer possible ﬂows based on differen-
tial testing, i.e., by observing differences in the application
output when the input is changed. Their approach has some
superﬁcial similarities to our approach in that they make use
of sequence alignment algorithms, which are closely related
to approximate matching. However, in contrast with our ap-
proach where we match inputs with outputs, their approach
applies sequence alignment algorithms to compare different
outputs so as to discover what portions of the output remain
constant and what portions change.
9 Conclusions
In this paper, we presented a new approach for accu-
rate detection of common types of attacks launched on web
applications. Our approach relies on a new technique for
inferring taint propagation by passively observing inputs
and outputs of a protected application. We then presented
a new policy framework that enables policies to be speci-
ﬁed in a language-neutral manner. As compared to previ-
ous works, our approach does not require extensive instru-
mentation of the applications to be protected. It is robust,
and can easily support applications written in many differ-
ent languages (Java/C/C++/PHP), and on many platforms
(Apache/IIS/Tomcat).
It is able to detect many types of
command injection attacks, as well as cross-site scripting
within a single framework, and using very few policies. It
introduces signiﬁcantly lower overheads (typically less than
5%) as compared to previous approaches.
Acknowledgements
We would like to thank Mark Cornwell, James Just and
Nathan Li from Global Infotek for numerous discussions
on this project, and for helping with experiments involv-
ing Microsoft IIS and WebGoat. We would also like to
thank Lorenzo Cavallaro for compiling the CVE vulnera-
bility chart shown in Figure 1, and Wei Xu for providing a
working version of many of the exploits used in this paper.
References
[1] Sandeep Bhatkar, Abhishek Chaturvedi, and R. Sekar.
Dataﬂow anomaly detection. In IEEE Symposium on Secu-
rity and Privacy, May 2006.
[2] Prithvi Bisht and V.N. Venkatakrishnan. Xss-guard: Precise
In Inter-
dynamic detection of cross-site scripting attacks.
national Conference on Detection of Intrusions & Malware,
and Vulnerability Assessment, 2008.
[3] BreachSecurity. Modsecurity: Open source web application
ﬁrewall. On the web at http://www.modsecurity.org/.
[4] Gregory Buehrer, Bruce W. Weide, and Paolo A. G. Sivilotti.
Using parse tree validation to prevent sql injection attacks. In
SEM ’05: Proceedings of the 5th international workshop on
Software engineering and middleware, pages 106–113, New
York, NY, USA, 2005. ACM.
[5] S. Chen, J. Xu, N. Nakka, Z. Kalbarczyk, and R. K. Iyer.
Defeating memory corruption attacks via pointer taintedness
detection. In IEEE International Conference on Dependable
Systems and Networks (DSN), 2005.
[6] National Center for Biotechnology Information (NCBI). Ba-
sic Local Alignment Search Tool (BLAST). On the web at
http://www.ncbi.nlm.nih.gov/blast/Blast.cgi.
[7] Dan Gusﬁeld. Algorithms on strings, trees, and sequences:
computer science and computational biology. Cambridge
University Press, 1997.
[8] William Halfond. SQL injection application testbed. On the
web at http://www.cc.gatech.edu/ whalfond/testbed.html.
[9] William Halfond and Alessandro Orso. AMNESIA: Anal-
ysis and monitoring for neutralizing sql-injection.
In
IEEE/ACM International Conference on Automated Soft-
ware Engineering (ASE), 2005.
[10] William G. J. Halfond, Alessandro Orso, and Panagiotis
Manolios. Using positive tainting and syntax-aware evalua-
tion to counter sql injection attacks. In SIGSOFT FSE, 2006.
[11] Trevor Jim, Nikhil Swamy, and Michael Hicks. Beep:
Browser-enforced embedded policies. In WWW, 2007.
[12] Jaeyeon Jung, Anmol Sheth, Ben Greenstein, David Wether-
all, Gabriel Maganis, and Tadayoshi Kohno. Privacy oracle:
a system for ﬁnding application leaks with black box differ-
ential testing. In CCS, 2008.
[13] Lap Chung Lam and Tzi cker Chiueh. A general dynamic in-
formation ﬂow tracking framework for security applications.
In Annual Computer Security Applications Conference (AC-
SAC), 2006.
[14] V. I. Levenshtein. Binary codes capable of correcting dele-
Soviet Physics Doklady,
tions, insertions, and reversals.
10(707), 1966.
[24] R. Sekar, V. Venkatakrishnan, S. Basu, S. Bhatkar, and D. C.
DuVarney. Model-carrying code: A practical approach for
safe execution of untrusted applications. In ACM Symposium
on Operating System Principles, Bolton Landing, New York,
October 2003.
[25] P. Madhusudan Sruthi Bandhakavi, Prithvi Bisht and V.N.
Venkatakrishnan. Candid: Preventing sql injection attacks
using dynamic candidate evaluations. In CCS, 2007.
[26] Zhendong Su and Gary Wassermann. The essence of com-
In POPL ’06:
mand injection attacks in web applications.
Conference record of the 33rd ACM SIGPLAN-SIGACT sym-
posium on Principles of programming languages, pages
372–382, New York, NY, USA, 2006. ACM.
[27] G. Edward Suh, Jae W. Lee, David Zhang, and Srinivas De-
vadas. Secure program execution via dynamic information
ﬂow tracking. In International Conference on Architectural
Support for Programming Languages and Operating Sys-
tems, pages 85–96, Boston, MA, USA, 2004.
[28] Wei Xu, Sandeep Bhatkar, and R. Sekar. Taint-enhanced pol-
icy enforcement: A practical approach to defeat a wide range
of attacks. In USENIX Security Symposium, August 2006.
[15] Microsoft.
Implementation,
http://blogs.technet.com/swi/archive/2008/08/19/
ie-8-xss-ﬁlter-architecture-implementation.aspx.
the
8 XSS
IE
2008.
Filter Architecture/
at
On
web
[16] James Newsome and Dawn Song. Dynamic taint analysis
for automatic detection, analysis, and signature generation of
exploits on commodity software. In Network and Distributed
System Security Symposium (NDSS), 2005.
[17] Anh Nguyen-Tuong, Salvatore Guarnieri, Doug Greene, Jeff
Shirley, and David Evans. Automatically hardening web ap-
plications using precise tainting. In 20th IFIP International
Information Security Conference, 2005.
[18] University of Virginia.
Fasta.
On the web at
http://fasta.bioch.virginia.edu/.
[19] OWASP.
Http response splitting.
On the web at
www.owasp.org/index.php/HTTP Response Splitting.
[20] OWASP.
the
Owasp webgoat
http://www.owasp.org/index.php/Category:
project.
On
web
OWASP WebGoat Project.
at
[21] Tadeusa Pietraszek and Chris Vanden Berghe. Defend-
ing against injection attacks through context-sensitive string
In Recent Advances in Intrusion Detection
evaluation.
(RAID), 2005.
[22] Feng Qin, Cheng Wang, Zhenmin Li, Ho seop Kim,
Yuanyuan Zhou, and Youfeng Wu. LIFT: A low-overhead
practical information ﬂow tracking system for detecting gen-
eral security attacks. In IEEE/ACM International Symposium
on Microarchitecture, December 2006.
[23] Prateek Saxena, R. Sekar, and Varun Puranik. Efﬁcient ﬁne-
grained binary instrumentation with applications to taint-
tracking. In IEEE/ACM Conference on Code Generation and
Optimization (CGO), April 2008.