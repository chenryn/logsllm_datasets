users can exercise control over content they provide by delet-
ing it. Users may explicitly delete individual pieces of content
or their account. Data types such as ephemeral or draft posts
are automatically deleted after a ﬁxed time period.
Deletions should be fully effected within 90 days, after
which the data can no longer be used in products or services
in the ordinary course of business. Most deletions involve
a relatively small amount of data and should ﬁnish quickly,
i.e., within one day. 90 days provides sufﬁcient time to delete
an account despite transient errors. Deleted data may subse-
USENIX Association
29th USENIX Security Symposium    1059
quently persist in backups for up to 90 days for recovery from
inadvertent deletions or other infrastructure failures.
A few deletions may take more than 90 days to complete.
Typical reasons entail deleting an unusually high number of
pieces of content, e.g., an account which has been creating
content consistently over many years, and persistent infras-
tructure failures. In such cases deletions may run for more
than 90 days but are required to make continuous progress
towards completion. Any failures must be resolved.
2.5 Threat Model
DELF safeguards the deletion process against developer mis-
takes. In our threat model developers are employed by their
organization and aim to uphold its deletion policy, but may
erroneously—not maliciously—fail to do so in practice. We
consider the following types of mistakes.
Developers may altogether omit to specify what to delete
when a user triggers a deletion. For example, developers may
add a new edge type from the photo data type to a user data
type and store which users are tagged in the photo, but omit
to implement deletion of the edge when the photo is deleted.
Developers may specify to retain data that should be
deleted according to the deletion policy. For example, de-
velopers may opt to retain who voted in a poll after a voter
deletes their account to ensure that poll results cannot change
retroactively, overlooking that users should be able to delete
any data they provide including how they voted in polls.
Developers may inadvertently delete the wrong data. For
example, developers may specify that deleting a comment
should entail deleting all its attachments, such as photos. Yet
they may overlook that users can attach third-party photos
to their comments and these will get deleted too. Mistakes
can introduce security vulnerabilities. We consider users to
be potentially malicious. For example, an adversarial user
may try to delete arbitrary photos by attaching a photo to a
comment they create and then deleting the comment.
Developers may fail to execute the speciﬁcation they have
provided. For example, developers may attempt to delete all
comments when a post is deleted, but they may not anticipate
that the list can include millions of items, that the process
may take days, and that any data store may temporarily or
permanently fail to delete individual comments.
Malicious developers are outside the scope of this work.
In our experience the vast majority of developers faithfully
try to implement their employer’s policy and are subject to
disciplinary action if they systematically fail to do so. As we
demonstrate next, without ongoing detection benign devel-
oper mistakes account for frequent bugs in deletion.
3 Case Study: Unassisted Deletion
We motivate the need for DELF by conducting a case study
within FACEBOOK. We measure (a) how likely developers
are to remember their obligation to delete data (§3.1), (b),
whether they do so correctly (§3.2), and (c), the operational
overhead of recovering from inadvertent deletions without
framework support (§3.3). To our knowledge, this is the ﬁrst
study to measure such developer actions.
3.1 Developer omissions
We measure developer proactiveness specifying how collected
data should be deleted, i.e., without enforcement from a frame-
work. We look at the deployment phase of DELF in Instagram
starting on April 2019. To facilitate backwards compatibility,
developers were able, for a limited period of time, to deﬁne a
certain category of new TAO edge types without specifying
how any collected data should be deleted in advance (§5.4).
When developers omitted to provide deletion speciﬁcations
they were reminded to do so retroactively (§4.3).
Between April and July 2019 40 distinct Instagram develop-
ers introduced 70 new edge types without enforcement from
DELF. We inspect each of them, ﬁnding that 32 distict de-
velopers created 56 new edge types and did not remember to
update the corresponding code to handle their deletion when
either of the objects they reference is deleted. In effect with-
out any enforcement developers handled deletion proactively
for only 20% of the edge types they created.
We attribute limited developer proactiveness to the lack of
feedback triggered by development tools while prototyping
new features. The situation has parallels with common types
of security concerns; in particular managing memory without
help from a framework [53,54]. Developers can store data per-
sistently (resp. allocate memory) and—assuming sufﬁcient
storage capacity (resp. memory)—they observe no failures
if they forgo to specify how their application should behave
when deletes occur (resp. when in-memory objects are no
longer referenced). For memory management, common tech-
niques forgo developer education and automate the process
fully [55], or expect developers to specify application behav-
ior ahead of time before memory is allocated [56]. For data
deletion, no similar tools exist (§2.2). Another contributing
factor is deletion seldom being a driving requirement while
prototyping new features. It is common for deletion to only
be introduced as a requirement retroactively and only after
core pieces of functionality have already been implemented.
3.2 Developer mistakes
To prevent dangling data when a new edge type between a
source and a target object type is introduced, developers need
to specify what should happen if the source object is deleted.
Developers may opt to delete or retain the target object and
their choice is subject to peer review. In the next section
we discuss in detail how developers achieve this via DELF
edge type annotations (§4). Here we measure the precision
developers achieve in the task when unassisted.
1060    29th USENIX Security Symposium
USENIX Association
ANNOTATION
TRUE POS.
FALSE POS.
PRECISION
shallow
deep
refcount
OVERALL
239
87
0
326
5
3
0
8
98.0%
96.7%
N/A
97.6%
Table 1: Precision achieved by FACEBOOK developers when
asked to provide DELF annotations for edge types (see Ta-
ble 2). Specifying shallow designates that referenced data
should not get deleted while deep designates that it should.
We collect all changesets introducing at least one new edge
type annotation submitted between June 24 and June 27 2019,
totaling 327 changesets created by 129 developers, and for
each changeset we request retroactive expert review. The ex-
pert is a tenured privacy engineer with extensive experience
in deletion, FACEBOOK’s deletion policy, products and infras-
tructure. For each annotation the expert considered incorrect
we surfaced the issue with the original changeset authors or
peer reviewers and established ground truth.
Table 1 summarizes our results. Developers misclassiﬁed
edge types demonstrating an overall precision of 97.6%, with
mistakes leading to inadvertent retention and mistakes leading
to inadvertent deletion occurring at similar rates. Reasons for
mistakes included (a) a developer confusing the direction of
deletion for a pair of edge types, (b) two developers copying
annotations without conﬁrming correctness, (c) a developer
prototyping a new feature who intended to revisit annotations
at a later stage, and (d), a developer who had not thought
through all scenarios that should trigger deletion. While we
were not able to construct exploits for the 5 edges incorrectly
annotated deep in our sample (Table 1, shallow false posi-
tives), we anticipate that a proportion of such mistakes will
be exploitable externally, i.e., they can be exploited to delete
data without validating necessary permissions.
Using the rate at which edge types are being introduced
in FACEBOOK infrastructure at the time of our case study,
we interpolate that developers incorrectly annotate approxi-
mately 2 edge types every day. In absolute numbers, mistakes
that result in inadvertent deletion are approximately twice as
common than those that result in inadvertent data retention.
3.3 Recovery
We highlight the operational overhead and risk introduced by
inadvertent deletions based on an incident in July 2018 [9],
when Facebook developers discovered a bug causing inadver-
tent deletion of hundreds of millions of videos and performed
restorations from backups without framework support.
The issue involved two object types, one ephemeral and
one permanent, with references to the same video object
type. Deletion logic designated erroneously that shared video
objects should be deleted when either of these object types
is deleted, meaning that the video would always be deleted
when the ephemeral object expired. The bug was triggered by
normal user actions, and was detected by investigating user
reports 100 days after the bug was introduced.
The data recovery process spanned 70 days involving over
10 engineering teams. To recover videos engineers employed
data store backups. A signiﬁcant difﬁculty in restoration
was that each application-level video was backed by many
database-level objects: several blobs in Everstore and tens
of objects in TAO without any accessible information to tie
multiple underlying deleted objects together. Moreover, Ev-
erstore and TAO each have their own independent backups.
The ﬁnal implementation of restoration involved scanning
through TAO backups to identify deleted objects, logging all
references therein to deleted blobs in Everstore, a separate
restoration process in Everstore, and ﬁnally, writing new data
in TAO to combine restored items into a viable product experi-
ence. The process resulted in data loss since the bug lingered
for a period longer than backup retention.
We conclude that expecting developers to implement dele-
tion unassisted is not sustainable in complex applications such
as modern OSNs. To achieve correctness, developers need
to be reminded to specify deletion behavior and revisit data
which they failed to delete, while service providers need a
dependable way to mitigate the risk of data loss and reduce
the operational complexity when inadvertent deletions occur.
4 Design
DELF forces developers to specify how data is deleted when
data types are deﬁned. It achieves this by introducing annota-
tions related to deletion to a domain-speciﬁc language used
to deﬁne data types. DELF then intercepts application-level
deletions and transparently executes them to completion in-
dependently of the underlying data store. DELF offers two
safety mechanisms: the ability to verify correctness of devel-
oper annotations and undo deletions for a short time period.
4.1 Deletion Speciﬁcation
DELF forces developers to specify deletion annotations for
all new object and edge types they create. The data type
deﬁnition step is instrumental to DELF’s design. The edge
type deﬁnitions in particular provide a statically-known list
of all potential references between objects. When an object
is deleted, DELF enumerates all potential data stores where
dangling data may reside based on edge types and deletes it all
according to developer annotations. Edge types enable DELF
to perform subgraph deletions and delete dangling data.
Table 2 summarizes DELF annotations, categorized based
on their applicability and purpose. Edge annotations apply
on edge types while object annotations apply on object types.
The goal of an annotation is to increase deletion coverage, i.e.,
USENIX Association
29th USENIX Security Symposium    1061
GOAL
VALIDATION
ANNOTATION
APPLIES ON
Edge Types
shallow
Edge Types
deep
Edge Types
refcount
Object Types
by_any
Object Types
short_ttl
Object Types
directly
Object Types
by_x_only
directly_only Object Types
Object Types
not_deleted
Object Types
custom
Coverage
Coverage
Coverage
Coverage
Coverage
Coverage
Prevention
Prevention
Prevention
Coverage
Dynamic
Dynamic
Dynamic
Static
Static
DESCRIPTION
When deleting the source object delete only the edge.
When deleting the source object cascade and delete the target.
Cascade only when the last source object gets deleted.
One or more inbound edge types should be deep.
The object type should specify limited retention.
Static & Dynamic Objects are deleted via direct user action in product.
Static
Static & Dynamic
Static
N/A
Stricter form of by_any; provides a list of edge types.
Stricter form of directly; rejects deep edge types.
Prevents objects of this type from being deleted.
Developers specify arbitrary procedural deletion logic in code.
Table 2: DELF annotations allow developers to control deletion. They apply on either object or edge type deﬁnitions and can be
validated via different methods to prevent dangling data and inadvertent deletions (§4.3)
.
not leave dangling data, or to prevent inadvertent deletions,
i.e., to preclude deleting the wrong data. Figure 1 provides
example annotations for the Photo object type from §2.4.
Edge type annotations. These specify what happens to ref-
erenced objects upon deletion. Each edge is unidirectional,
pointing from a source object to a target object. An edge type
annotation prescribes the expected deletion behavior once
the source object gets deleted. Developers choose between
deleting only the source object (shallow), cascading and
deleting the associated object by following the edge (deep)
and cascading only when the last edge to the target object is
deleted (refcount). All edge type annotations result in the
deletion of the edges themselves. Edge annotations improve
deletion coverage because they force developers to declare
how referenced data should be deleted.
Object type annotations. These specify how objects of a
particular type should be deleted. By default DELF assumes
that all object types contain data users create therefore ob-
jects of every type should be deletable in some form. There
are three main object annotations. The default annotation
is by_any. It requires that each object type declares at least
one deep-annotated inbound edge type from another object
type; thus individual objects of this object type are deleted
via traversal of that edge type. Developers may pick instead
short_ttl or directly. The former ensures that all objects
of this type get deleted by virtue of limited retention—the
precise maximum retention allowed should be consistent with
the service provider’s deletion policy. The latter is appropri-
ate for object types that users can delete via direct action in
product, e.g., object types designating user accounts.
DELF exposes three object annotations that help protect ob-
jects against inadvertent deletions trigged by deleting objects
of other types. The by_x_only annotation is a restricted form
of by_any. It is parameterized by a whitelist of edge types that
may trigger deletions of objects of this type. DELF prevents
developers from accidentally declaring deep edges of any
other type not found in the whitelist. The directly_only
annotation is a more restrictive form of directly; DELF
prevents any inbound edge types to be marked deep. The
not_deleted annotation prevents all deletions altogether by
both rejecting all inbound deep edge types and by not gener-
ating code to perform object deletes. To prevent overuse of
not_deleted, DELF requires developers to reference a doc-
umented privacy or legal decision which mandates retaining
the data, e.g., a task in the service provider’s tracking system.
The custom annotation allows developers to provide ar-
bitrary procedural code to execute when objects of a given
type are deleted. Unlike declarative annotations, code in a
custom section can express complicated deletion logic de-
pendent on arbitrary state. For example, code in a custom
section may inspect the object being deleted and delete one
of its edges with either shallow or deep semantics based on
the value of a particular object ﬁeld. Executing procedural