### User Control Over Content
Users can exercise control over the content they provide by deleting it. This deletion can be performed on individual pieces of content or on their entire account. Data types such as ephemeral or draft posts are automatically deleted after a fixed time period.

Deletions should be fully completed within 90 days, after which the data can no longer be used in products or services in the ordinary course of business. Most deletions involve a relatively small amount of data and should be completed quickly, typically within one day. The 90-day window provides sufficient time to handle transient errors and ensure that an account is fully deleted. Deleted data may persist in backups for up to 90 days to facilitate recovery from inadvertent deletions or other infrastructure failures.

In some cases, deletions may take more than 90 days to complete, particularly when an unusually high number of content pieces need to be deleted, such as an account that has been consistently creating content over many years, or due to persistent infrastructure failures. In these cases, deletions must make continuous progress toward completion, and any failures must be resolved.

### Threat Model
DELF safeguards the deletion process against developer mistakes. In our threat model, developers are employed by their organization and aim to uphold its deletion policy but may inadvertently fail to do so. We consider the following types of mistakes:

1. **Omission**: Developers may omit to specify what to delete when a user triggers a deletion. For example, if a new edge type is added from a photo data type to a user data type, developers might store which users are tagged in the photo but forget to implement the deletion of this edge when the photo is deleted.
2. **Retention Errors**: Developers may specify to retain data that should be deleted according to the deletion policy. For instance, developers might retain who voted in a poll after a voter deletes their account, overlooking that users should be able to delete any data they provide, including their votes.
3. **Incorrect Deletion**: Developers may inadvertently delete the wrong data. For example, deleting a comment might entail deleting all its attachments, such as photos. However, if users can attach third-party photos to their comments, these will also get deleted, leading to potential security vulnerabilities.
4. **Execution Failures**: Developers may fail to execute the specified deletion. For example, deleting a post might require deleting all associated comments, but developers might not anticipate that the list can include millions of items, leading to a lengthy process that may fail due to data store issues.

Malicious developers are outside the scope of this work. In our experience, the vast majority of developers faithfully try to implement their employer’s policy and are subject to disciplinary action if they systematically fail to do so. Without ongoing detection, benign developer mistakes account for frequent bugs in deletion.

### Case Study: Unassisted Deletion
We conducted a case study within Facebook to motivate the need for DELF. We measured (a) how likely developers are to remember their obligation to delete data (§3.1), (b) whether they do so correctly (§3.2), and (c) the operational overhead of recovering from inadvertent deletions without framework support (§3.3). To our knowledge, this is the first study to measure such developer actions.

#### 3.1 Developer Omissions
We measured developer proactiveness in specifying how collected data should be deleted, i.e., without enforcement from a framework. During the deployment phase of DELF in Instagram starting in April 2019, developers were allowed, for a limited period, to define certain new TAO edge types without specifying how the collected data should be deleted in advance (§5.4). If developers omitted to provide deletion specifications, they were reminded to do so retroactively (§4.3).

Between April and July 2019, 40 distinct Instagram developers introduced 70 new edge types without enforcement from DELF. We found that 32 distinct developers created 56 new edge types and did not remember to update the corresponding code to handle their deletion when either of the objects they reference is deleted. Effectively, without any enforcement, developers handled deletion proactively for only 20% of the edge types they created.

We attribute limited developer proactiveness to the lack of feedback triggered by development tools while prototyping new features. This situation is similar to common types of security concerns, such as managing memory without help from a framework [53,54]. Developers can store data persistently (or allocate memory) and, assuming sufficient storage capacity (or memory), they observe no failures if they forgo specifying how their application should behave when deletes occur (or when in-memory objects are no longer referenced). For memory management, common techniques either automate the process fully [55] or expect developers to specify application behavior ahead of time before memory is allocated [56]. For data deletion, no similar tools exist (§2.2). Another contributing factor is that deletion is seldom a driving requirement while prototyping new features. It is common for deletion to be introduced as a requirement only retroactively and after core functionality has already been implemented.

#### 3.2 Developer Mistakes
To prevent dangling data when a new edge type between a source and a target object type is introduced, developers need to specify what should happen if the source object is deleted. They may opt to delete or retain the target object, and their choice is subject to peer review. In the next section, we discuss in detail how developers achieve this via DELF edge type annotations (§4). Here, we measure the precision developers achieve in the task when unassisted.

| Annotation | True Pos. | False Pos. | Precision |
|------------|-----------|------------|-----------|
| shallow    | 239       | 5          | 98.0%     |
| deep       | 87        | 3          | 96.7%     |
| refcount   | 0         | 0          | N/A       |
| Overall    | 326       | 8          | 97.6%     |

Table 1: Precision achieved by Facebook developers when asked to provide DELF annotations for edge types (see Table 2). Specifying "shallow" designates that referenced data should not be deleted, while "deep" designates that it should. We collected all changesets introducing at least one new edge type annotation submitted between June 24 and June 27, 2019, totaling 327 changesets created by 129 developers. For each changeset, we requested retroactive expert review. The expert is a tenured privacy engineer with extensive experience in deletion, Facebook's deletion policy, products, and infrastructure. For each annotation the expert considered incorrect, we surfaced the issue with the original changeset authors or peer reviewers and established ground truth.

Developers misclassified edge types, demonstrating an overall precision of 97.6%. Mistakes leading to inadvertent retention and mistakes leading to inadvertent deletion occurred at similar rates. Reasons for mistakes included (a) a developer confusing the direction of deletion for a pair of edge types, (b) two developers copying annotations without confirming correctness, (c) a developer prototyping a new feature who intended to revisit annotations at a later stage, and (d) a developer who had not thought through all scenarios that should trigger deletion. While we were not able to construct exploits for the 5 edges incorrectly annotated as "deep" in our sample (Table 1, shallow false positives), we anticipate that a proportion of such mistakes will be exploitable externally, i.e., they can be exploited to delete data without validating necessary permissions.

Using the rate at which edge types are being introduced in Facebook infrastructure at the time of our case study, we interpolate that developers incorrectly annotate approximately 2 edge types every day. In absolute numbers, mistakes that result in inadvertent deletion are approximately twice as common as those that result in inadvertent data retention.

#### 3.3 Recovery
We highlight the operational overhead and risk introduced by inadvertent deletions based on an incident in July 2018 [9], when Facebook developers discovered a bug causing inadvertent deletion of hundreds of millions of videos and performed restorations from backups without framework support.

The issue involved two object types, one ephemeral and one permanent, with references to the same video object type. Deletion logic erroneously designated that shared video objects should be deleted when either of these object types is deleted, meaning that the video would always be deleted when the ephemeral object expired. The bug was triggered by normal user actions and was detected by investigating user reports 100 days after the bug was introduced.

The data recovery process spanned 70 days, involving over 10 engineering teams. To recover videos, engineers employed data store backups. A significant difficulty in restoration was that each application-level video was backed by many database-level objects: several blobs in Everstore and tens of objects in TAO without any accessible information to tie multiple underlying deleted objects together. Moreover, Everstore and TAO each have their own independent backups.

The final implementation of restoration involved scanning through TAO backups to identify deleted objects, logging all references therein to deleted blobs in Everstore, a separate restoration process in Everstore, and finally, writing new data in TAO to combine restored items into a viable product experience. The process resulted in data loss since the bug lingered for a period longer than backup retention.

We conclude that expecting developers to implement deletion unassisted is not sustainable in complex applications such as modern OSNs. To achieve correctness, developers need to be reminded to specify deletion behavior and revisit data they failed to delete, while service providers need a dependable way to mitigate the risk of data loss and reduce the operational complexity when inadvertent deletions occur.

### Design
DELF forces developers to specify how data is deleted when data types are defined. It achieves this by introducing annotations related to deletion to a domain-specific language used to define data types. DELF then intercepts application-level deletions and transparently executes them to completion independently of the underlying data store. DELF offers two safety mechanisms: the ability to verify the correctness of developer annotations and undo deletions for a short time period.

#### 4.1 Deletion Specification
DELF forces developers to specify deletion annotations for all new object and edge types they create. The data type definition step is instrumental to DELF’s design. Edge type definitions, in particular, provide a statically-known list of all potential references between objects. When an object is deleted, DELF enumerates all potential data stores where dangling data may reside based on edge types and deletes it all according to developer annotations. Edge types enable DELF to perform subgraph deletions and delete dangling data.

Table 2 summarizes DELF annotations, categorized based on their applicability and purpose. Edge annotations apply to edge types, while object annotations apply to object types. The goal of an annotation is to increase deletion coverage, i.e., not leave dangling data, or to prevent inadvertent deletions, i.e., to preclude deleting the wrong data. Figure 1 provides example annotations for the Photo object type from §2.4.

| Goal           | Validation | Annotation  | Applies On  | Description                                                                                       |
|----------------|------------|-------------|-------------|---------------------------------------------------------------------------------------------------|
| Coverage       | Static     | shallow     | Edge Types  | When deleting the source object, delete only the edge.                                             |
| Coverage       | Static     | deep        | Edge Types  | When deleting the source object, cascade and delete the target.                                    |
| Coverage       | Static     | refcount    | Edge Types  | Cascade only when the last source object gets deleted.                                             |
| Coverage       | Static     | by_any      | Object Types| One or more inbound edge types should be deep.                                                     |
| Prevention     | Static     | short_ttl   | Object Types| The object type should specify limited retention.                                                  |
| Coverage       | Static     | directly    | Object Types| Static & Dynamic Objects are deleted via direct user action in the product.                        |
| Prevention     | Static     | by_x_only   | Object Types| Stricter form of by_any; provides a list of edge types.                                            |
| Prevention     | Static     | directly_only | Object Types| Stricter form of directly; rejects deep edge types.                                                |
| Prevention     | Static     | not_deleted | Object Types| Prevents objects of this type from being deleted.                                                   |
| Dynamic        | Dynamic    | custom      | Object Types| Developers specify arbitrary procedural deletion logic in code.                                    |

**Edge Type Annotations**: These specify what happens to referenced objects upon deletion. Each edge is unidirectional, pointing from a source object to a target object. An edge type annotation prescribes the expected deletion behavior once the source object gets deleted. Developers choose between deleting only the source object (shallow), cascading and deleting the associated object by following the edge (deep), and cascading only when the last edge to the target object is deleted (refcount). All edge type annotations result in the deletion of the edges themselves. Edge annotations improve deletion coverage because they force developers to declare how referenced data should be deleted.

**Object Type Annotations**: These specify how objects of a particular type should be deleted. By default, DELF assumes that all object types contain data users create, therefore, objects of every type should be deletable in some form. There are three main object annotations. The default annotation is `by_any`, which requires that each object type declares at least one deep-annotated inbound edge type from another object type; thus, individual objects of this object type are deleted via traversal of that edge type. Developers may pick instead `short_ttl` or `directly`. The former ensures that all objects of this type get deleted by virtue of limited retention—the precise maximum retention allowed should be consistent with the service provider’s deletion policy. The latter is appropriate for object types that users can delete via direct action in the product, e.g., object types designating user accounts.

DELF exposes three object annotations that help protect objects against inadvertent deletions triggered by deleting objects of other types. The `by_x_only` annotation is a restricted form of `by_any`. It is parameterized by a whitelist of edge types that may trigger deletions of objects of this type. DELF prevents developers from accidentally declaring deep edges of any other type not found in the whitelist. The `directly_only` annotation is a more restrictive form of `directly`; DELF prevents any inbound edge types from being marked deep. The `not_deleted` annotation prevents all deletions altogether by both rejecting all inbound deep edge types and by not generating code to perform object deletes. To prevent overuse of `not_deleted`, DELF requires developers to reference a documented privacy or legal decision which mandates retaining the data, e.g., a task in the service provider’s tracking system.

The `custom` annotation allows developers to provide arbitrary procedural code to execute when objects of a given type are deleted. Unlike declarative annotations, code in a `custom` section can express complicated deletion logic dependent on arbitrary state. For example, code in a `custom` section may inspect the object being deleted and delete one of its edges with either shallow or deep semantics based on the value of a particular object field. Executing procedural code in a `custom` section allows for flexible and context-dependent deletion logic.