![](../img/fig7-9.png)
**图 7-9 互动式事务和储存过程之间的区别（使用图 7-8 的示例事务）**
#### 储存过程的优点和缺点
储存过程在关系型资料库中已经存在了一段时间了，自 1999 年以来它们一直是 SQL 标准（SQL/PSM）的一部分。出于各种原因，它们的名声有点不太好：
- 每个资料库厂商都有自己的储存过程语言（Oracle 有 PL/SQL，SQL Server 有 T-SQL，PostgreSQL 有 PL/pgSQL，等等）。这些语言并没有跟上通用程式语言的发展，所以从今天的角度来看，它们看起来相当丑陋和陈旧，而且缺乏大多数程式语言中能找到的库的生态系统。
- 在资料库中执行的程式码难以管理：与应用伺服器相比，它更难除错，更难以保持版本控制和部署，更难测试，并且难以整合到指标收集系统来进行监控。
- 资料库通常比应用伺服器对效能敏感的多，因为单个数据库例项通常由许多应用伺服器共享。资料库中一个写得不好的储存过程（例如，占用大量记忆体或 CPU 时间）会比在应用伺服器中相同的程式码造成更多的麻烦。
但是这些问题都是可以克服的。现代的储存过程实现放弃了 PL/SQL，而是使用现有的通用程式语言：VoltDB 使用 Java 或 Groovy，Datomic 使用 Java 或 Clojure，而 Redis 使用 Lua。
**储存过程与记忆体储存**，使得在单个执行绪上执行所有事务变得可行。由于不需要等待 I/O，且避免了并发控制机制的开销，它们可以在单个执行绪上实现相当好的吞吐量。
VoltDB 还使用储存过程进行复制：但不是将事务的写入结果从一个节点复制到另一个节点，而是在每个节点上执行相同的储存过程。因此 VoltDB 要求储存过程是 **确定性的**（在不同的节点上执行时，它们必须产生相同的结果）。举个例子，如果事务需要使用当前的日期和时间，则必须透过特殊的确定性 API 来实现。
#### 分割槽
顺序执行所有事务使并发控制简单多了，但资料库的事务吞吐量被限制为单机单核的速度。只读事务可以使用快照隔离在其它地方执行，但对于写入吞吐量较高的应用，单执行绪事务处理器可能成为一个严重的瓶颈。
为了伸缩至多个 CPU 核心和多个节点，可以对资料进行分割槽（请参阅 [第六章](ch6.md)），在 VoltDB 中支援这样做。如果你可以找到一种对资料集进行分割槽的方法，以便每个事务只需要在单个分割槽中读写资料，那么每个分割槽就可以拥有自己独立执行的事务处理执行绪。在这种情况下可以为每个分割槽指派一个独立的 CPU 核，事务吞吐量就可以与 CPU 核数保持线性伸缩【47】。
但是，对于需要访问多个分割槽的任何事务，资料库必须在触及的所有分割槽之间协调事务。储存过程需要跨越所有分割槽锁定执行，以确保整个系统的可序列性。
由于跨分割槽事务具有额外的协调开销，所以它们比单分割槽事务慢得多。VoltDB 报告的吞吐量大约是每秒 1000 个跨分割槽写入，比单分割槽吞吐量低几个数量级，并且不能透过增加更多的机器来增加吞吐量【49】。
事务是否可以是划分至单个分割槽很大程度上取决于应用资料的结构。简单的键值资料通常可以非常容易地进行分割槽，但是具有多个次级索引的资料可能需要大量的跨分割槽协调（请参阅 “[分割槽与次级索引](ch6.md#分割槽与次级索引)”）。
#### 序列执行小结
在特定约束条件下，真的序列执行事务，已经成为一种实现可序列化隔离等级的可行办法。
- 每个事务都必须小而快，只要有一个缓慢的事务，就会拖慢所有事务处理。
- 仅限于活跃资料集可以放入记忆体的情况。很少访问的资料可能会被移动到磁碟，但如果需要在单执行绪执行的事务中访问这些磁碟中的资料，系统就会变得非常慢 [^x]。
- 写入吞吐量必须低到能在单个 CPU 核上处理，如若不然，事务需要能划分至单个分割槽，且不需要跨分割槽协调。
- 跨分割槽事务是可能的，但是它们能被使用的程度有很大的限制。
[^x]: 如果事务需要访问不在记忆体中的资料，最好的解决方案可能是中止事务，非同步地将资料提取到记忆体中，同时继续处理其他事务，然后在资料载入完毕时重新启动事务。这种方法被称为 **反快取（anti-caching）**，正如前面在 “[在记忆体中储存一切](ch3.md#在记忆体中储存一切)” 中所述。
### 两阶段锁定
大约 30 年来，在资料库中只有一种广泛使用的序列化演算法：**两阶段锁定（2PL，two-phase locking）** [^xi]
[^xi]: 有时也称为 **严格两阶段锁定（SS2PL, strong strict two-phase locking）**，以便和其他 2PL 变体区分。
> #### 2PL不是2PC
>
> 请注意，虽然两阶段锁定（2PL）听起来非常类似于两阶段提交（2PC），但它们是完全不同的东西。我们将在 [第九章](ch9.md) 讨论 2PC。
之前我们看到锁通常用于防止脏写（请参阅 “[没有脏写](#没有脏写)” 一节）：如果两个事务同时尝试写入同一个物件，则锁可确保第二个写入必须等到第一个写入完成事务（中止或提交），然后才能继续。
两阶段锁定类似，但是锁的要求更强得多。只要没有写入，就允许多个事务同时读取同一个物件。但物件只要有写入（修改或删除），就需要 **独占访问（exclusive access）** 许可权：
- 如果事务 A 读取了一个物件，并且事务 B 想要写入该物件，那么 B 必须等到 A 提交或中止才能继续（这确保 B 不能在 A 底下意外地改变物件）。
- 如果事务 A 写入了一个物件，并且事务 B 想要读取该物件，则 B 必须等到 A 提交或中止才能继续（像 [图 7-1](../img/fig7-1.png) 那样读取旧版本的物件在 2PL 下是不可接受的）。
在 2PL 中，写入不仅会阻塞其他写入，也会阻塞读，反之亦然。快照隔离使得 **读不阻塞写，写也不阻塞读**（请参阅 “[实现快照隔离](#实现快照隔离)”），这是 2PL 和快照隔离之间的关键区别。另一方面，因为 2PL 提供了可序列化的性质，它可以防止早先讨论的所有竞争条件，包括丢失更新和写入偏差。
#### 实现两阶段锁
2PL 用于 MySQL（InnoDB）和 SQL Server 中的可序列化隔离级别，以及 DB2 中的可重复读隔离级别【23,36】。
读与写的阻塞是透过为资料库中每个物件新增锁来实现的。锁可以处于 **共享模式（shared mode）** 或 **独占模式（exclusive mode）**。锁使用如下：
- 若事务要读取物件，则须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务已经在物件上持有排它锁，则这些事务必须等待。
- 若事务要写入一个物件，它必须首先以独占模式获取该锁。没有其他事务可以同时持有锁（无论是共享模式还是独占模式），所以如果物件上存在任何锁，该事务必须等待。
- 如果事务先读取再写入物件，则它可能会将其共享锁升级为独占锁。升级锁的工作与直接获得独占锁相同。
- 事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）。这就是 “两阶段” 这个名字的来源：第一阶段（当事务正在执行时）获取锁，第二阶段（在事务结束时）释放所有的锁。
由于使用了这么多的锁，因此很可能会发生：事务 A 等待事务 B 释放它的锁，反之亦然。这种情况叫做 **死锁（Deadlock）**。资料库会自动检测事务之间的死锁，并中止其中一个，以便另一个继续执行。被中止的事务需要由应用程式重试。
#### 两阶段锁定的效能
两阶段锁定的巨大缺点，以及 70 年代以来没有被所有人使用的原因，是其效能问题。两阶段锁定下的事务吞吐量与查询响应时间要比弱隔离级别下要差得多。
这一部分是由于获取和释放所有这些锁的开销，但更重要的是由于并发性的降低。按照设计，如果两个并发事务试图做任何可能导致竞争条件的事情，那么必须等待另一个完成。