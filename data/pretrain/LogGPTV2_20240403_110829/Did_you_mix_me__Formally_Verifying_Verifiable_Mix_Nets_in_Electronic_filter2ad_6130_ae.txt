(cid:3)
1, ..., u
q , and w1, w2, w3,∈ Zq and
1 V chooses u = (u1, ..., uN ) ∈ ZN
2 P deﬁnes u(cid:3) = (u
N ) ∈ ZN
(cid:3)
(cid:3)N
(cid:3)
i,0ui,
u to P.
ˆr = (ˆr1, ..., ˆrN ), ˆw = ( ˆw1, ..., ˆwN ), w(cid:3) =
(w
w4 ∈ R. P deﬁnes ¯r = (cid:2)¯1, r(cid:3), ˜r = (cid:2)r, u(cid:3),
(cid:3)
ˆr =
j and
j=i+1 u
(cid:3)N
i,2 ). P hands the
(cid:3)ui
(cid:3)ui
(cid:3) = (
r
i=1 r
i,1 ,
following values (ˆc, t1, t2, t3, t4, ˆti) to V, where we
set ˆc0 = h and i ∈ [1, N ],
(cid:3)N
u(cid:2)
t1 = gw1
ˆci = g ˆri ˆc
i−1
(cid:3)
1, ..., w
(cid:2)N
i=1 ˆri
(cid:2)N
i=1 r
t3 = gw3
t2 = gw2
(cid:3)N
i=1 r
i
(cid:3)N
t4 = Σ.EncP K(0, w4)
w(cid:2)
i−1
3 V chooses a challenge ξ ∈ Zq at random and sends it
4 P then responds with:
ˆti = g ˆwi ˆc
to P.
i=1 e
(cid:3)w(cid:2)
i
i
i
s1 = w1 + ξ · ¯r
ˆsi = ˆwi + ξ · ˆri
s2 = w2 + ξ · ˆr
i + ξ · u
(cid:3)
(cid:3)
(cid:3)
i = w
s
i
5 V accepts if and only if, for i ∈ [1, N ],
s3 = w3 + ξ · ˜r
s4 = w4 − ξ · r
(cid:3)
w(cid:2)
i
i
i=1 h
t1 = (
t3 = (
(cid:3)N
i=1 hi)−ξgs1
s(cid:2)
i
(cid:3)N
i=1 h
i
i )−ξgs3
(cid:3)N
(cid:3)N
i=1 ci/
i=1 cui
N(cid:4)
(cid:2)N
i=1 ui )−ξgs2
t2 = (ˆcN /h
s(cid:2)
−ξ
i gˆsi ˆc
i−1
i
ˆti = ˆc
N(cid:4)
t4 = (
(ei)ui )−ξΣ.EncP K(0, s4)
(cid:3)
i)s(cid:2)
i
(e
i=1
i=1
The Terelius-Wikstr¨om mix net is the combination of Wik-
str¨om’s work [13] and Terelius-Wikstr¨om’s work [16]. In
the earlier work, Wikstr¨om shows how to split
the effort
of constructing a proof of shufﬂe into an ofﬂine and online
phase—for simplicity of presentation, we have chosen in this
work to fold the two phases back together. In the ofﬂine phase,
the prover ﬁrst commits to a permutation matrix and then
proves that it did so; in the online phase, the prover then
shufﬂes the ciphertexts and proves that it did so consistently
with the matrix committed to in the ofﬂine phase. In the latter
work, the authors showed that a square matrix M = (mi,j)
over Zq is a permutation matrix if and only if for a vector
¯x = (x1, ..., xN ) of independent variables:
N(cid:4)
i=1
(cid:2) ¯mi, ¯x(cid:3) =
N(cid:4)
i=1
xi and M ¯1 = ¯1.
j=1 c
i=1 h
mi,1
i
)—it
(cid:3)N
(cid:3)N
mi,N
i
i=1 as
, ..., grN
(cid:3)N
This result is important because if the matrix is commit-
ted to column-wise in extended Pedersen commitments—
(c1, ..., cN ) = (gr1
is
i=1 h
easy to publicly compute the commitment to the vector of
inner products {(cid:2) ¯mi, ¯x(cid:3)}N
xj
j . The ﬁrst equality
of the necessary and sufﬁcient condition given above can be
tested efﬁciently by subtracting the lhs from the rhs and using
Schwarz-Zippel’s lemma, stating that if f (x1, ..., xN ) is a non-
zero polynomial of degree d and we pick a point ¯e from ZN
q
randomly, then the probability that f (¯e) = 0 is at most d/q.
The result of these insights is that is sufﬁces to check certain
discrete log relationships to establish a proof of correctness.
It is then fairly straight-forward to construct a sigma protocol
which proves these discrete log problems relationships hold.
B. Formally
proved, starting by deﬁning the subrelationships.
(cid:3) s.t. c = Π.ComCK(m, r) = Π.ComCK(m(cid:3)
We will now formally deﬁne the relationship which is
We deﬁne Rcom to be the relation consisting of pairs of
tuples; the ﬁrst tuple is of the form commitment key CK,
commitment c. The second tuple is of the form, two distinct
message vectors m, m(cid:3) and two associated randomness values
(cid:3)). If
r and r
an adversary can ﬁnd a witness to this relationship they have
broken the binding property of the commitment scheme which
in this case also means they have broken the discrete log
problem.
We deﬁne Rπ to be the relation consisting of pairs of tuples
of the form commitment key CK, vector of commitments c,
message M and associated randomness vector r s.t. M is a
permutation matrix and ci = Π.ComCK(Mi, ri).
, r
ΣP K to be the relation consisting of pairs of
tuples of the form public key P K, two vectors of ciphertexts
1,··· , ct
CT = (ct1,··· , ctn) and CT(cid:3) = (ct
(cid:3)
(cid:3)
n) and a permu-
tation π and randomness vector r = (r1,··· , rn) such that
i = ctπ(i)Σ.EncP K(1, rπ(i)) for all i ∈ [1, N ]. We deﬁne
(cid:3)
ct
this in Coq by ﬁrst calculating ctπ(i) and rπ(i) as e’’ and
r’’, respectively, and then requiring that the re-encryption
relationship holds for all ciphertexts in the vectors.
We deﬁne Rshuf
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:48 UTC from IEEE Xplore.  Restrictions apply. 
1757
We are now able to deﬁne the relationship proved by the
mix net. The relationship is Rcom∨(Rπ∧Rshuf
), stating that
either the ciphertexts were correctly mixed or the adversary
has broken the commitment scheme, as shown below.
Definition WikRel (pk: enc.PK) (e e’: vector G1.G (1+N))
(h: G) (hs: VG (1+N)) (c: VG (1+N)) :=
ΣP K
(exists (r: MoC_M.VF (1+N)) (r’: VF (1+N)) (m: MF (1+N)),
(relReEnc pk e e’ m r /\ relPi h hs c m r’))
\/
((exists (c: G) (m1 m2: VF (1+N)) (r1 r2: F),
relComEPC h hs c m1 m2 r1 r2).
The protocol that the prover and veriﬁer follow for the proof
of shufﬂe is shown in Algorithm 1; normally, the proof is
made non-interactive using the Fiat-Shamir transform. So
in practice, we assume that the Fiat-Shamir transform was
correctly implemented. For convenience of presentation, we
present Algorithm 1 for the case of basic ElGamal where
the randomness and challenge space is Zq. The algorithm
describes a 4 round zero-knowledge proof between a prover
and veriﬁer which asserts that the prover knows private inputs
which satisfy the public inputs. In the ﬁrst round the veriﬁer
challenges the prover to which the prover responds with
several commitments in round two. In the third round the
veriﬁer challenges the prover again and prover responds in
round four. In step ﬁve of the algorithm the veriﬁer checks
if the responses provided by the prover in round four satisfy
certain relationships with the statement and commitments.
The standard paper proof adopts a form of special soundness
to prove soundness. See Wikstr¨om’s recent work [63] for
information on the knowledge error achieved by this proof.
s
:
( e e ’ :
a l l
a l l keys and c i p h e r t e x t s * )
( pk : enc . PK)
Our Coq theorem for the security (special soundness) of the
mix net is given below. Essentially it universally quantiﬁes
over all possible statements and proof transcripts (lines 1 to
21) and then says if enough of the proof transcripts accept
(lines 23 to 28) with distinct challenges (lines 30 and 31)
then we can extract a witness to the relationship (line 49).
The requirement that the matrix of challenges has an inverse
(line 40 and 41) could be removed by slightly modifying the
proof but this would render the result incompatible with the
deployed implementations.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
Theorem T h e M i x n e t I s S e c u r e
( * For
s t a t e m e n t s * )
( * For
f o r a l l
( * Commitment p a r a m e t e r s and m a t r i x commitments * )
f o r a l l
( hs : VG (1+N) )
( * For p r i m a r y c h a l l e n g e s * )
f o r a l l (U: MF (1+N) ) ,
f o r a l l
( cHat : v e c t o r
l e t Sig := WikstromSigma i n
l e t
V f o r a l l
( fun t => Sigma . V1 F Sig ( t . 1 . 1 . 1 , t . 1 . 1 . 2 , t . 1 . 2 . 1 ,
t . 2 . 1 ) = t r u e
/\ Sigma . V1 F Sig ( t . 1 . 1 . 1 , t . 1 . 1 . 2 , t . 1 . 2 . 2 , t . 2 . 2 )
cHat U i n
( * Sigma p r o t o c o l s
( com : v e c t o r
f o r a l l
( c h a l : v e c t o r
( t : v e c t o r ( ( Sigma . T F Sig ) * ( Sigma . T F Sig ) ) (1+N) ) ,
a c c e p t * )
( Sigma . C F Sig )
( F*F )
( Vmap2 ( fun x y => ( x , y ) )
fun x y => ( x , y ) )
( Vmap2 (
WikstromStatment pk h hs c cHat c o l e e ’ )
:= Vmap2 ( fun cHat c o l =>
( v e c t o r G1 .G (1+N) ) ) ,
(VG (1+N) )
(1+N) ) ,
fun x y => ( x , y ) )
s com ) c h a l )