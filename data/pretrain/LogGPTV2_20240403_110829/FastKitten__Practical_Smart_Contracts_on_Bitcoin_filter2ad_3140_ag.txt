article / 3251171 / components - processors / intels - plan - to -
fix - meltdown - in - silicon - raises - more - questions - than -
answers.html, 2018.
[28] M. Hachman.
[29] M. Hoekstra, R. Lal, P. Pappachan, V. Phegade, and J. Del Cuvillo.
Using Innovative Instructions to Create Trustworthy Software Solutions.
In Workshop on Hardware and Architectural Support for Security and
Privacy (HASP). ACM, 2013.
[30] A. Homescu, S. Brunthaler, P. Larsen, and M. Franz. Librando: trans-
parent code randomization for just-in-time compilers. In ACM SIGSAC
Conference on Computer and Communications Security, CCS, 2013.
[31] Intel.
Intel Software Guard Extensions developer guide, 2016.
https://download.01.org/intel-sgx/linux-1.7/docs/Intel_
SGX_Developer_Guide.pdf.
[32] Intel. Resources and Response to Side Channel L1 Terminal Fault.
https://www.intel.com/content/www/us/en/architecture-
and-technology/l1tf.html, 2018.
[33] A. Juels, A. E. Kosba, and E. Shi. The ring of gyges: Investigating
In Proceedings of the 2016
the future of criminal smart contracts.
ACM SIGSAC Conference on Computer and Communications Security,
Vienna, Austria, October 24-28, 2016, 2016.
[34] H. A. Kalodner, S. Goldfeder, X. Chen, S. M. Weinberg, and E. W.
Felten. Arbitrum: Scalable, private smart contracts. In USENIX Security
Symposium, 2018.
[35] A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk:
The blockchain model of cryptography and privacy-preserving smart
contracts. In Security and Privacy (SP), 2016 IEEE Symposium on.
IEEE, 2016.
[36] A. E. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk:
The blockchain model of cryptography and privacy-preserving smart
contracts. In IEEE Symposium on Security and Privacy, 2016.
816    28th USENIX Security Symposium
USENIX Association
[37] R. Kumaresan and I. Bentov. How to use bitcoin to incentivize correct
computations. In Proceedings of the ACM SIGSAC Conference on
Computer and Communications Security. ACM, 2014.
[57] M.-W. Shih, S. Lee, T. Kim, and M. Peinado. T-SGX: Eradicating
controlled-channel attacks against enclave programs. In Annual Net-
work and Distributed System Security Symposium, 2017.
[38] R. Kumaresan and I. Bentov. Amortizing secure computation with
penalties. In Proceedings of the ACM SIGSAC Conference on Computer
and Communications Security, 2016.
[39] R. Kumaresan, T. Moran, and I. Bentov. How to use bitcoin to play
decentralized poker. In Proceedings of the 22nd ACM SIGSAC Confer-
ence on Computer and Communications Security. ACM, 2015.
[40] R. Kumaresan, V. Vaikuntanathan, and P. N. Vasudevan. Improvements
In Proceedings of the ACM
to secure computation with penalties.
SIGSAC Conference on Computer and Communications Security, 2016.
[41] L. Lamport, R. Shostak, and M. Pease. The byzantine generals prob-
lem. ACM Transactions on Programming Languages and Systems
(TOPLAS), 1982.
[42] P. Larsen, A. Homescu, S. Brunthaler, and M. Franz. SoK: Automated
software diversity. In 35th IEEE Symposium on Security and Privacy,
S&P, 2014.
[43] J. Lind, O. Naor, I. Eyal, F. Kelbert, P. R. Pietzuch, and E. G. Sirer.
Teechain: Reducing storage costs on the blockchain with ofﬂine pay-
ment channels. In 11th ACM International Systems and Storage Con-
ference, 2018.
[44] R. Matzutt, J. Hiller, M. Henze, J. H. Ziegeldorf, D. Müllmann,
O. Hohlfeld, and K. Wehrle. A quantitative analysis of the impact
of arbitrary blockchain content on bitcoin. In Proceedings of the 22nd
International Conference on Financial Cryptography and Data Security
(FC). Springer, 2018.
[45] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shaﬁ,
V. Shanbhogue, and U. R. Savagaonkar. Innovative Instructions and
Software Model for Isolated Execution. In Workshop on Hardware and
Architectural Support for Security and Privacy (HASP). ACM, 2013.
[46] Microsoft. The coco framework, 2018. GIT repository available at
https://github.com/Azure/coco-framework.
[47] I. Miers, C. Garman, M. Green, and A. D. Rubin. Zerocoin: Anonymous
distributed e-cash from bitcoin. In Security and Privacy (SP), 2013
IEEE Symposium on. IEEE, 2013.
[48] A. Miller and I. Bentov. Zero-collateral lotteries in bitcoin and
In Security and Privacy Workshops (EuroS&PW), 2017
ethereum.
IEEE European Symposium on. IEEE, 2017.
[49] A. Miller, I. Bentov, R. Kumaresan, and P. McCorry. Sprites: Payment
channels that go faster than lightning. CoRR, abs/1702.05812, 2017.
[50] V. Mohan, P. Larsen, S. Brunthaler, K. W. Hamlen, and M. Franz.
Opaque control-ﬂow integrity. In NDSS, 2015.
[51] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system,”
http://bitcoin.org/bitcoin.pdf, 2008.
[52] J. Noorman, P. Agten, W. Daniels, R. Strackx, A. Van Herrewege,
C. Huygens, B. Preneel, I. Verbauwhede, and F. Piessens.
San-
cus: Low-cost trustworthy extensible networked devices with a zero-
software trusted computing base. In 22nd USENIX Security symposium,
USENIX Sec, 2013.
[53] V. Pappas, M. Polychronakis, and A. D. Keromytis. Smashing the
gadgets: Hindering return-oriented programming using in-place code
randomization. In 33rd IEEE Symposium on Security and Privacy,
S&P, 2012.
[54] R. Pass, E. Shi, and F. Tramèr. Formal abstractions for attested execu-
tion secure processors. IACR Cryptology ePrint Archive, 2016.
[55] J. Poon and V. Buterin. Plasma: Scalable autonomous smart contracts,
Aug 2017. Plasma, https://plasma.io/plasma.pdf/.
[56] J. Seo, B. Lee, S. Kim, M.-W. Shih, I. Shin, D. Han, and T. Kim. SGX-
Shield: Enabling address space layout randomization for SGX pro-
grams. In Annual Network and Distributed System Security Symposium,
2017.
[58] J. Teutsch and C. Reitwießner. A scalable veriﬁcation solution for
https://people.cs.uchicago.edu/
blockchains, Nov 2017.
~teutsch/papers/truebit.pdf.
[59] F. Tramèr, F. Zhang, H. Lin, J. Hubaux, A. Juels, and E. Shi. Sealed-
glass proofs: Using transparent enclaves to prove and sell knowledge.
In 2017 IEEE European Symposium on Security and Privacy, EuroS&P,
2017.
[60] J. Van Bulck, F. Piessens, and R. Strackx. Foreshadow: Extracting the
keys to the intel sgx kingdom with transient out-of-order execution. In
27th USENIX Security Symposium (USENIX Security 18). USENIX
Association, 2018.
[61] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin. Binary stirring:
self-randomizing instruction addresses of legacy x86 binary code. In
ACM SIGSAC Conference on Computer and Communications Security,
CCS, 2012.
[62] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
D. Song, and W. Zou. Practical control ﬂow integrity and random-
ization for binary executables. In 34th IEEE Symposium on Security
and Privacy, S&P, 2013.
[63] F. Zhang, E. Cecchetti, K. Croman, A. Juels, and E. Shi. Town crier: An
authenticated data feed for smart contracts. In Proceedings of the 2016
ACM SIGSAC conference on computer and communications security.
ACM, 2016.
[64] F. Zhang, P. Daian, I. Bentov, and A. Juels. Paralysis proofs: Safe access-
structure updates for cryptocurrencies and more. IACR Cryptology
ePrint Archive, 2018.
[65] M. Zhang and R. Sekar. Control ﬂow integrity for COTS binaries. In
22nd USENIX Security Symposium, USENIX Sec, 2013.
A Further Related Work
There is a large body of work trying to improve the scalabil-
ity of blockchains by moving a major part of smart contract
executions off the blockchain (for example, via second layer
solutions [24, 34, 49, 55] or outsourcing of computation [58]).
As discussed in the main body of this paper, all of these so-
lutions run on top of blockchains with sufﬁciently complex
scripting language, e.g., on Ethereum. However, they cannot
be integrated into popular legacy cryptocurrencies such as
Bitcoin, which is their main difference compared to our work.
Recall that one of the main goals of FASTKITTEN is make
minimal assumption on the underlying blockchain technology
and in particular, to run over the Bitcoin blockchain.
Another motivation for off-chain contract execution might be
the goal of protecting privacy. Hawk [36] and the “Ring of
Gyges” [33] are examples of works that do keep the state,
all inputs and outputs private. It is also true for the scaling
solutions mentioned above; These techniques work only over
cryptocurrencies with support for complex smart contracts,
e.g. over Ethereum.
Below we discuss the differences between these solutions and
FASTKITTEN when run on top of Ethereum.
A.1 Second-layer Scaling Solutions
State Channels State channels [20, 24, 49] are a prominent
second layer scaling solution. They allow a set of parties
USENIX Association
28th USENIX Security Symposium    817
to execute complex smart contracts off-chain. As long as
all parties are honest and agree on the state transitions, the
blockchain is contacted only during the channel creation,
when parties lock funds in the channel, and during channel
closure, when the locked funds are distributed back to the
parties according to the result of contract execution. However,
once parties run into disagreement off-chain, they have to
resolve their dispute on-chain and perform the state transition
via the blockchain.
While in the optimistic case when all parties are honest, state
channels are very efﬁcient, a potentially heavy computation
might need to be done on-chain in case of disagreement. This
is in contrast to the FASTKITTEN protocol which does not
require any computation to be performed on the blockchain
even in case of disputes.
Plasma Another promising second-layer scaling solution is
Plasma, ﬁrst introduced by Poon and Buterin [55]. The main
idea of Plasma is to build new chains (Plasma chains) on
top of the Ethereum blockchain. Each Plasma chain has its
own operator that is responsible for validating transactions
and regularly posting a short commitment about the current
state of the Plasma chain to a smart contract on the Ethereum
blockchain. The regular commitments guarantee to the partic-
ipants of the Plasma chain that in case the operator cheats, his
misbehavior can be proven to the Ethereum smart contract
and parties can exit the Plasma chain with all their funds.
While the original goal of Plasma [55] was to support arbi-
trary complex smart contracts, to the best of our knowledge,
there is no concrete protocol that would achieve this goal
(the existing Plasma designs support only payment transac-
tions). Moreover, the plasma research community currently
conjectures that Plasma with general smart contracts might
be impossible to construct [8].
A.2
Arbitrum The disadvantage of state channels, i.e., the po-
tentially heavy on-chain execution in case of dispute, is being
addressed by the work Arbitrum [34]. Every smart contract,
which Arbitrum models as a virtual machine (VM), to be
executed off-chain has a set of “manager” parties responsi-
ble for correct VM execution. As long as managers reach
consensus on the VM state transitions, execution progresses
off-chain similarly as in state channels. In case of dispute,
managers do not perform the VM state transition on-chain as
in state channel. Instead, one manager can propose the next
VM state which other managers can challenge. If the newly
posted state is challenged, the proposer and the challenger
run an interactive protocol via the blockchain, so-called “bi-
section” protocol, in which one disputable computation step
is eventually identiﬁed and whose correct execution is ver-
iﬁed on-chain. Hence, instead of executing the entire state
transition on-chain (which might potentially require a lot of
time/space), only one computation step of the state transition
Incentive-driven Veriﬁcation
has to be performed on-chain in addition to the bisection pro-
tocol (which might require O(log(s)) blockchain transactions,
where s is the number of computations steps in the state tran-
sition). The Arbitrum protocol works under the assumption
that at least one manager of the VM is honest and challenges
false states if they are posted by other managers. Since the
blockchain interaction during the bisection protocol is rather
expensive, Arbitrum uses monetary incentives to motivate
managers to behave honestly and follow the protocol.
TrueBit Another solution that supports off-chain execution
of smart contracts using incentive veriﬁcation is TrueBit [58].
For each off-chain execution, the TrueBit system selects (us-
ing a lottery) one party, called the “Solver”, that is responsible
for performing the state transition and inform all other parties
about the new contract state. The TrueBit system incentives
parties to become so called “veriﬁers” and check the correct-
ness of the computation performed by the Solver. In case they
detect misbehavior, they are supposed to challenge the Solver
on the blockchain and run the “veriﬁcation game” which
works similarly as the “bisection protocol” of Arbitrum. Sim-
ilar to Arbitrum, TrueBit relies on the assumption that there
is at least one honest veriﬁer which correctly performs all
the validations and challenges malicious Solvers. In contrast
to Arbitrum, all inputs and the contract state are inherently
public even in the optimistic case when everyone is honest.
Apart from the different trust model and lower requirement
on the underlying blockchain technology, FASTKITTEN dif-
fers from Arbitrum and TrueBit by providing stronger privacy
guarantees, meaning that in both the optimistic and the pes-
simistic case, inputs of honest parties as well as the state of
the smart contract remains private.
A.3 TEEs for privacy
None of the solutions discussed above achieves privacy pre-
serving off-chain contract execution. This is tackled by the
work Hawk [36] which keeps the state, all inputs and all out-
puts private. Hawk contracts [35] achieve these properties
using Ethereum smart contracts that judge computations done
by a third party (a manager), who executes the contract on
private inputs and is trusted not to reveal any secrets. First all
parties submit their encrypted inputs to the contract, then the
manager computes the result and proves its correctness with a
zero knowledge proof. If the proof is correct, the contract pays
out money accordingly. While the authors of Hawk discuss
the possibility to use SGX for instantiating the manager and
reducing the trust assumptions in this party, it still leverages
the blockchain for every user input, and it only supports single
round protocols which is their main difference to FASTKIT-
TEN. A possible extension to multi-round protocols would be
difﬁcult to achieve without letting the smart contract verify
the correctness of every round individually, and thus create a
large blockchain communication overhead.
818    28th USENIX Security Symposium
USENIX Association