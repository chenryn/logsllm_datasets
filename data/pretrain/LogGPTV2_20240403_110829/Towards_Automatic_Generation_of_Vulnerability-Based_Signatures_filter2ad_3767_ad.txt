where y = (a + i0) ∗ z as before and jz is “jump if zero”
results in the constraint (a + i0) ∗ z = 0. Constraints eval-
uate to a constant because machine instructions only allow
comparison of an expression to a constant. The total sym-
bolic formula is then just the conjunction of each branch
predicate.
The constraint system consisting of the conditions on
each branch predicate in π is returned as the desired sig-
nature. Optionally, constraint systems can be simpliﬁed,
which consists of deducing how multiple constraints can be
collapsed into a single constraint.
PEP symbolic execution. PEP symbolic execution is
similar to the MEP case, except we must deal with loops.
Loops are handled by computing ﬁxed points. However,
in data-ﬂow analysis a widening operator is used to guar-
antee that the iteration to compute the ﬁxed-point termi-
nates [6, 18]. Currently, we use the following algorithm
to handle loops:
• First, we identify induction variables [41, Chapter 14]
in each loop. For example, the induction variable for
the ﬁrst while loop in Figure 1 is c. We also compute
the bounds on the induction variable, e.g., the bound
on the induction variable c is c ≥ 1.
• Assume that an induction variable is used to index the
input array in the condition used in the while loop.
The condition used in the while loop along with the
bounds on the induction variable gives us the desired
result. For the ﬁrst while loop in Figure 1 the condition
that is generated is
( i n p u t [ c ]
= ’
’ ) w h e r e ( c >= 1 )
3.4 Regular Expression Signature Generation
3.4.1 Computing MEP Regular Expression Signatures
One method for generating a regular expression is to solve
the constraint system S to a set x : x ∈ S and or-ing (|) to-
gether all members, e.g., if S = {00, 01, 21}, then the regu-
lar expression is 00|01|21 4
. This method is explored heav-
ily in test-case generation literature [10, 22, 23, 24, 25]. We
adopt this approach to our problem setting.
Divide-and-conquer. The number of variables to con-
sider within a single path may be very large, e.g., mil-
lions of variables at the assembly level. We address this
4
A reader may notice this expression is precise, and wonder when the
solution will not be precise. The answer is as precise as the symbolic
representation, e.g., if the symbolic representation only unrolls a loop once,
then the regular expression signature will not reﬂect inputs that may cause
the loop to be executed more than one time.
problem by decomposing an MEP single-path solution into
smaller sub-paths we can consider independently. Let π =
ventry v1...vexit be an MEP path. A sub-path is a sequence
of instructions πi = vivi+1...v(cid:2) ∈ π in the CFG. A sub-
path πi can be independently evaluated with respect to an-
other sub-path πj if no computation in πi could ever affect
a computation in πj, and vice-versa. Formally, we partition
π = π1π2π3...πj , where each πi is a partition with no data
dependencies with another sub-path πj . A data dependency
exists between πi and πj if πi computes a value that πj uses.
Since no computation in one sub-path πi could affect a
computation in another sub-path πj , each sub-path can be
independently solved, then the ﬁnal solution can be com-
bined. The solution to each sub-path πi is computed as
above by solving the corresponding constraint system for
the sub-path. The full path π is then the conjunction (∧) of
all sub-paths.
MEP solution. Our approach allows us to divide a sin-
gle MEP into possibly several smaller sub-problems. Let
the MEP path π = π1π2...πn correspond to evaluating the
symbolic input in order i1, ...in. Since sub-paths are inde-
pendent, we can always reorder the sub-paths so this is the
case. Then the signature for an MEP is the concatenation
of the solution for each sub-path. If πi has solution Si, then
the resulting signature is S = S1S2...Sn.
3.4.2 Computing PEP Regular Expression Signatures
We consider two approaches for computing a PEP solu-
tion. The ﬁrst method considers each MEP path within
a PEP independently, and solves the symbolic constraints
exactly. The second method is an optimization based on
data-ﬂow analysis which can be applied to portions of the
PEP control-ﬂow graph when certain conditions stated be-
low are met. The data-ﬂow analysis optimization works on
basic blocks instead of paths and does not require access to
a constraint solver.
Exact PEP solution. The PEP solution iteratively ex-
plores paths, and then solves them as an MEP solution. We
note that in practice one would likely create an initial MEP
signature for the sample exploit, then process other paths in
the background. This approach generates an initial narrow
signature quickly, then continues to reﬁne it as we perform
more analysis.
In many cases we may be
PEP data-ﬂow optimization.
able to determine: (a) the data dependencies partition a vul-
nerability into two or more components (w.r.t.
the CFG),
and (b) some of these components do direct comparisons
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
with input values. For example, many protocols have key-
words or have constant values for speciﬁc ﬁelds which the
input is simply compared against.
We use data-ﬂow analysis to efﬁciently compute the lan-
guage accepted by such components. Since each compo-
nent has no data dependencies with other components, the
solution to each component can be inlined into the complete
PEP or MEP solution. At a high level, data-ﬂow analysis it-
eratively processes a CFG until a ﬁxed point of data-ﬂow
facts is reached. Data-ﬂow analysis is widely used in com-
pilers and is highly efﬁcient.
The data-ﬂow analysis combines regular expressions ac-
cepted for each basic block (i.e., a block of contiguous in-
structions with a single entry and exit point) into a regular
expression accepted by the entire component. Due to space
constraints, we give here a very rough overview of data-
ﬂow analysis and leave further discussion to the extended
version of this paper [8]. At a high level, each CFG edge
is labeled with a set of data-ﬂow facts, which in our case is
the regular expression accepted by the basic block for true
edges, and the negated regular expression for false edges.
One key component for a data-ﬂow analysis is specifying
a (cid:16) (meet) operator, which summarizes how multiple in-
coming edges to a node are combined, i.e., combining the
regular expression for a point of conﬂuence of incoming
edges. Our (cid:16) operator states how to combine regular ex-
pressions α and β at a conﬂuence point, e.g., if β =!α, then
the conﬂuence point corresponds to the regular expression
Σ. In our running example, the instructions on line 4 can be
analyzed independently using data-ﬂow analysis, resulting
in the regular expression g|G for the ﬁrst byte of the input.
Note realistic programs usually have much larger compo-
nents than in our example which are amenable to data-ﬂow
analysis.
4 Evaluation and Implementation
We have implemented a prototype system to evaluate
our techniques for automatically generating signatures. In
this section we brieﬂy discuss implementation details of our
prototype, and then present our evaluation results. Our eval-
uation results show that even an MEP vulnerability signa-
ture is of far higher quality than signatures generated with
previous approaches. We focus on creating regular expres-
sion signatures since they require generation of the Turing
machine and symbolic signature.
4.1 Implementation
Our total prototype for implementing our techniques
is about 9000 lines of C++ code. We currently use
CBMC [16], a bounded model checker, to help build and
solve symbolic constraints to produce regular expression
signatures.
5
Disassembling the program, converting to IR, and ob-
taining instruction traces. Our binary program disas-
sembler is based upon Kruegel et. al. [34]. We then trans-
late each instruction into the appropriate IR statement via
our own translation language.
Instruction traces can be efﬁciently generated for most
modern architectures including x86 via hardware [5, 49] or
via software [1, 37, 42]. An instruction trace contains the
instruction address and optionally the value of the operands
for each instruction executed. Although the number of in-
structions executed may be large, the corresponding trace
can be efﬁciently represented [38, 53]. We currently use
Pin [37] to create our traces.
Solving the constraint system. We use model checking
to solve the system of constraints. We translate the con-
straints into constraints on C variables and use CBMC [16]).
We then assert to the model checker that the vulnerability
condition is unsatisﬁable. The model checker will either
verify the vulnerability condition is unsatisﬁable, or solve
the constraint system and present a counter-example which,
by construction, is a satisfying input. This process can be
iterated to exhaustively enumerate all possible satisfying in-
puts (i.e., exploits). The regular expression signature is the
“or” of all satisfying inputs. However, this process may be
slow when an input byte may be any of the 2256 values.
Therefore, we currently apply a widening operator such that
any byte that appears to be unconstrained after 3 iterations
becomes a wild-card byte. The widening step may intro-
duce false positives, and can be eliminated when desired.
We show that precise regular expression signature gener-
ation can be reduced to the model checking problem in the
extended version of this paper [8]. Exploring less precise
generation techniques, as well as techniques that work on
practical examples but may be theoretically limited, is an
area of future work.
Implementation limitations. Our current implementa-
tion is a prototype used for researching automatic signature
generation. Although our prototype works in our research
setting, there are a number of limitations. As mentioned
previously, alias analysis is currently not supported. Specif-
ically, we assume that no two memory locations are aliases.
In addition to the possible imprecision this may introduce
during symbolic execution, this limitation prevents us from
computing a true chop [27, 48]. Our current callgraph-
based chopping algorithm is less precise than a true chop,
5
We do not use source code despite the fact this is primarily a C model
checker.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
which primarily results in larger MEP and PEP coverages
than necessary. Second, we currently create sub-paths based
upon control-ﬂow based analysis, which may not accurately
identify when two sub-paths are independent (Section 3.4).
Finally, our IR transformations do not handle ﬂoating point
operations, and we currently do not support the entire x86
instruction set (we add operations as needed for our experi-
ments). All these limitations are orthogonal to our problem
and can be resolved by implementing known techniques.
We currently manually verify none of these problems intro-
duce errors into our results.
4.2 MEP Evaluation
4.2.1 ATPhttpd
ATPhttpd is a webserver written in C [47]. ATPhttpd ver-
sion 0.4b is vulnerable to a common sprintf-style buffer-
overﬂow when an HTTP request is too long. Speciﬁcally,
an exploit of the ATPhttpd vulnerability must meet the fol-
lowing conditions: (a) the HTTP request method is case-
insensitive, and must be either “get” or “head”; (b) the ﬁrst
byte of the requested ﬁle name must be ’/’, and cannot be
followed by ’/’; (c) the requested ﬁlename cannot contain
the substring “/../” or end with “/..”; and (d) the requested
ﬁlename must be over 677 characters long.
We use the exploit sample from [46], which consists of
the request GET /, followed by the shell code, followed
by the HTTP protocol string HTTP/1.1. In this experi-
ment, the vulnerability condition given for ATPhttpd is that
no pointer should be able to write to a return address.
Signature result and quality. We generated the symbolic
constraints, which were partitioned into 10 distinct sub-
paths that were analyzed independently. We solved the con-
straints and create a regular expression in a little over a sec-
ond, with the average time per partition taking 0.1216s.
We
the
regular
generated
expression
signature
[g|G][e|E][t|T][ ]/.{423}//.{3}/.{386}. This
regular expression is almost perfect w.r.t.
the necessary
conditions to reach the vulnerability as stated previously.
In particular, it recognizes that the get keyword is case
insensitive, and that most bytes can be anything. The
bytes that are constraints (“/” and “//” in the signature)
are both contained in the exploit and explicitly tested
along the MEP vulnerability path that the exploit took.
We contrast our signature with previous exploit-speciﬁc
signature generation approaches [44, 43, 36], which at best
only identify small parts of our signature and do not match
different exploit variants such as those that crashes the
server instead of injecting code. Our signatures will catch
all exploit variants given only a single exploit sample.
4.2.2 BIND
BIND is one of the most popular DNS servers. BIND
supports a secret key transaction authentication mechanism
where messages are signed with a transaction signature
(TSIG) [55]. BIND 8.2.x is susceptible to a stack overﬂow
vulnerability in the TSIG processing code.
The attacker must send a valid DNS transaction signature
request in order to exploit this vulnerability [12]. DNS is a
binary-based protocol in which all messages are struct-like.
DNS (and the exploit) can be TCP or UDP-based, though
here we only consider the UDP protocol messages. DNS
messages begin with a header, followed by a number of re-
source records (RR). An exploit of this vulnerability must
satisfy the following conditions: (a) the request must be a
query, which is represented by byte 2 of the message be-
ing 0; (b) there must be questions present, meaning that the
ﬁeld specifying the number of questions (byte offsets 4 and
5) must be greater than zero, and that there must be properly
encoded questions starting at offset 12; (c) the ﬁeld specify-
ing the number of additional resource records (byte offsets
10 and 11) must be greater than zero; (d) The DNS must
contain a resource record with the type ﬁeld set to TSIG,
which is 0x00af. Since DNS may have many different re-
source records in a single request, the speciﬁc byte offset
for this ﬁeld is a function of several other ﬁelds in the re-
quest. We use the TSIG vulnerability exploit from the LION
worm [54] as our sample exploit.
Signature result and quality. We generated the symbolic
constraints, which again could be partitioned into 10 dis-
tinct graphs, which we independently analyzed. The gener-
ated regular-expression signature speciﬁed that bytes 6-10
must be zero, that bytes 268 and 500, which indicate the end
of each query in the exploit, must be 0, that byte 12 must
not be 0, which is the ﬁrst byte of the ﬁrst query, and ﬁnally,
that bytes 505 through 507 must be 0x0000fa, which is the
0 byte at the beginning of the additional resource records
section, followed by the ﬁeld type TSIG. We verify that the
constructed signature identiﬁed all constraints that must be
met to exploit the vulnerability. We also veriﬁed the false-
positive rate of our signature by matching it again 1,000,000
DNS requests (trace taken from a high-trafﬁc DNS server
that serves several top level domains). There were no false
positives.
4.3 PEP Evaluation
The chop of ATPHttpd took 30μs and found 88% of all
functions were reachable between accepting a connection
and the vulnerability point (including all libraries). As men-
tioned previously, one technique for generating a PEP sig-
nature is to consider each MEP path independently. An-
other technique is to estimate the effects of multiple paths
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
simultaneously. Our current prototype implementation for
the latter technique is limited to moderate-sized functions.
Unfortunately, the ATPHttpd and BIND vulnerabilities use
extremely large library function which consists of several
thousand basic blocks. Addressing scalability issues is an
important part of our future work. We expect existing state
reduction techniques from model checking will help solve
this problem.
Here, we evaluate our PEP techniques on synthetic ex-
amples. We compile down our running example to a binary,
and then calculate the full PEP solution. The regular expres-
sion generated is [g|G][ ]*[ˆ ]{5,}. The total time to
compute the answer is about 1.5 seconds. Alternatively, our
tool can also produce the regular expression for each inde-
pendent component of the PEP, and then use data-ﬂow facts
to produce the ﬁnal signature. In this setting, our tool runs
slightly faster as it does not have to perform symbolic eval-
uation along all possible paths.
5 Discussion
We provide more extensive analysis, including proofs
of the hardness of signature creation and of our data-ﬂow
framework in the extended version of this paper [8].
Other application scenarios. At a high level, our tech-
niques generate an input string that reaches a given instruc-
tion in the binary. Several other applications of our tech-
niques that we plan on investigating include:
• Improve existing pattern-extraction signature genera-