having such a formal model has other beneﬁts; for example,
security researchers can use it to verify other properties of
their interest on the runtime permission model. We based our
model on the Alloy implementation of [20] as Alloy is a high-
level speciﬁcation language that is easy to interpret. However,
we spend a signiﬁcant amount of effort to extend this model
to conform to the ofﬁcial speciﬁcation for the new runtime
permissions [4]. We analyze the security of the model through
an automated analysis and show that when it is augmented with
the design of Cusper, the fundamental security properties that
were originally violated are satisﬁed. Our main contributions
to the existing formal analysis on Android permissions can be
summarized as follows:
• We updated the deﬁnitions of permission-related data
abstractions in the model to comply with the new
deﬁnitions of the runtime permission model.
• We signiﬁcantly updated the permission granting
scheme to comply with the complex granting scheme
of the runtime model speciﬁcation (e.g., permissions
can be granted as either install or runtime).
• We implemented permission groups and permission
granting on a group basis for dangerous permissions
according to the runtime permission model.
• We enabled apps to dynamically change their manifest
declarations and introduced an app update mechanism
(apps could not be updated in the previous model).
• We identiﬁed and ﬁxed the bugs in the existing model
• We demonstrated the existence of the aforementioned
• We implemented our defense, Cusper, in the model to
thwart these vulnerabilities and showed that Cusper
satisﬁes the fundamental security properties.
(e.g., missing signature checks for permissions).
custom permission vulnerabilities in the model.
We only model the parts of Android that concern permissions
(e.g., permission-related data abstractions and operations) as it
would be infeasible to model all of Android due to its large
scope and complexity. Additionally, due to space limitations,
we will be only be presenting the parts of our model that are
key to understanding the general operation of the model or that
signiﬁcantly differ from the previous model. As for the actual
Alloy implementation, we will present only a small part of
it in this section. but the full implementation can be found
in [17]. Our model can be dissected into three main parts:
1) abstractions related to permissions, device architecture, and
applications on Android, 2) system operations that concern
permissions, and 3) fundamental security properties to verify
the correct behavior of the model.
A. Abstractions
In this section, we present the abstractions in our model that
correspond to the representations of permissions, applications
and devices on Android.
Permissions. Our Permission abstraction is on a par with
what we described in Section II: each permission is associated
with a name, a source package to indicate the deﬁning package
name, a protection level, and at most one permission group.
Listing 2 presents the Alloy implementation for permissions,
protection levels and permission group abstractions.
Applications and Components. Each Application on
Android has a unique package name, a signature used by the
developer to sign the app, and a target SDK level. Additionally,
each app can comprise of several components, deﬁned by the
set Component, where a component can be one of the four
Android components. Each component can be protected with
a permission that we call guard. Furthermore, an application
itself can have a guard to protect all of its components.
Component guard takes precedence over the application guard
in case they both exist. Each application can deﬁne a set of
custom permissions and request a set of permissions.
In order to keep track of the permissions that are granted
to apps, each app is associated with a permissionsState
ﬁeld that consists of a set of PermissionData objects
which carry system ﬂags and state information (e.g., whether
a permission is granted as runtime or install time) regarding
9
each permission granted to the app at any time. This concept
of “stateful” permissions is one of the major representation
differences between the runtime and the install time models.
In order to implement an app update mechanism, we need
to allow apps to dynamically change the declarations in their
manifest ﬁle. To achieve this, we associate the ﬁelds that
require to be mutable with an object from the totally-ordered
set of Time in order to allow pairing of the ﬁelds with different
values at different time steps. Obviously, package name and
the signature should be immutable since these are the unique
identiﬁers for apps and developers. The ability to dynamically
change declarations is another important feature we introduce
in our model, as this gives us the ability to update Android
apps that are already installed on a given device. Listing 3
demonstrates the application-related abstractions in Alloy.
Device. Each Device comes with a set of built-in system
permissions and a set of custom permissions deﬁned by third-
party apps. We also include a platform signature in our device
representation to correctly perform signature checks when
granting signature permissions deﬁned by the system. Listing 4
illustrates the device abstraction in Alloy.
B. System Behavior
In this section, we describe the main system operations
(i.e., Alloy predicates) that deal with Android permissions.
By carefully investigating the Android source code, we have
observed that most of these critical operations have either
undergone a signiﬁcant amount of change or been recently
introduced with the runtime permission model. Speciﬁcally,
apart from the signiﬁcant change in abstractions, main oper-
ations such as install, uninstall and update now all require
a scan over all the other existing applications to properly
adjust their permissions whenever there is a change in the set
of permissions (e.g., removal of a permission). Additionally,
Android’s permission granting scheme changed drastically
with the introduction of runtime permissions. We aim to reﬂect
all of these changes in our formal model. It is important to note
that the order of statements in the presented predicates do not
affect their correct operation since Alloy is a declarative (rather
than imperative) language.
Grant Permissions. In contrast with the install permission
Listing 2: Permissions and permission groups in the model
sig Permission {
name : PermName,
protectionLevel : ProtectionLevel,
sourcePackage : PackageName,
permGroup : lone PermGroupName// if perm belongs to
group
}
abstract sig ProtectionLevel {}
one sig Normal, Dangerous, Signature extends
ProtectionLevel {}
sig PermissionGroup {
name : PermGroupName,
perms : Permission -> Time // set of changing perms
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
Listing 3: Applications and components in the model
sig Application {
packageName : PackageName,
signature : AppSignature,
declaredPerms : Permission -> Time, // custom
permissions
usesPerms : PermName -> Time, // requested permissions
guard : lone PermName, // protects all components
components : set Component,
targetSDK : Int -> Time,
// carries info regarding granted perms
permissionsState : PermissionData -> Time
}
abstract sig Component { // def. shortened for brevity
app : Application,
guard : lone PermName, // protects only this component
}
sig PermissionData {
perm : Permission,
flags : Flags,
isRuntime : Bool // runtime or install permission
}
Listing 4: An Android Device in the model
one sig Device {
apps : Application -> Time,
builtinPerms : set Permission, // system permissions
customPerms : Permission -> Time, // custom permissions
platformPackageName : one PackageName,
platformSignature : AppSignature,
builtinPermGroups : set PermissionGroup // system
groups
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
1
2
3
4
5
6
7
8
model where permissions can be granted only at installation,
in the runtime permission model, depending on the protection
level and the app’s target SDK level, permissions can be
granted as either install or runtime permissions. Permissions
with protection level normal and signature are always granted
as install permissions, whereas for dangerous permissions, the
behavior changes based on the target SDK level of the app
being installed.
Table III shows the cases that can happen for when
granting permissions. Each case will add/remove “stateful”
permission objects for this app. As explained in IV, we
observed implementation ﬂaws in this part of the Android
source code which make the aforementioned attacks possible
and we mirrored the same erroneous behavior in our Alloy
predicate for granting permissions (grantPermissions).
For example, when denying “dangling” permissions to apps,
we skip to revoke runtime permissions and only revoke install
permissions as it is currently implemented in Android. Also,
when a custom permission is updated from normal to danger-
TABLE III: Cases of grantPermissions. (∗ Precondition: Permission
should exist as an install permission. † Deny if no other case matches.)
Grant Permission Cases
Grant install
Grant install
Grant legacy install
Grant upgrade∗
Grant runtime
Deny †
Protection Level
Normal
Signature
Dangerous
Dangerous
Dangerous
-
SDK Level
Any
Any
=23
>=23
-
Grant As
Install
Install
Install
Runtime
Runtime
-
10
Listing 5: Granting permissions in the Alloy model
pred grantPermissions[app : Application, t, t’ : Time] {
all pname : app.usesPerms.t’ |
pname in (Device.builtinPerms +
Device.customPerms.t’).name =⇒
(let p = findPermissionByName[pname, t’] {
p.protectionLevel = Normal // Case GRANT_INSTALL
(normal)
=⇒ grantInstallCase[p, app, t, t’]
else // Case GRANT_INSTALL (signature)
p.protectionLevel = Signature and
(verifySignatureForCustomPermission[p, app, t’]
or
verifySignatureForBuiltinPermission[p, app])
=⇒ grantInstallCase[p, app, t, t’]
// . . . other cases (grant runtime etc.)
else // Case GRANT_DENY (deny permission)
no pd : PermissionData | pd.perm.name = pname
and pd in app.permissionsState.t’
})
else //permission doesnt exist, evoke (wrongfully
only install perms)
let pd = getPermissionData[pname, app, t]{
hasPermissionData[pname, app, t]
and pd.isRuntime = True
and pd.perm.protectionLevel = Dangerous
=⇒ pd in app.permissionsState.t’
else
no pd : PermissionData | pd.perm.name = pname
and pd in app.permissionsState.t’
}
// make sure app cannot be granted unrequested
permission
no pd : app.permissionsState.t’ |
pd.perm.name not in app.usesPerms.t’
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
ous protection level, we treat this as an app SDK update—
just as Android mistakenly does—and automatically grant
the dangerous permission without user’s consent. Note that
our ﬁnal formal model corrects these and other problematic
issues according to Cusper’s design. Listing 5 illustrates this
operation; an example to how an individual case are handled
can be found in Listing 10 in Appendix.
Installation. As a precondition to the install operation,
the app being installed should not exist on the device and the
list of apps after the operation is completed should consist
strictly of all the apps before installation augmented by the
new app. As a result of installation, custom permissions of
this app will be added to the device. Just as it is currently
handled in Android, our Alloy predicate for installation does
not allow an app to declare a custom permission which has the
same name as an existing permission on the device. Custom
permissions that are declared to be part of system permission
groups also get added to the respective groups. Finally, the