Research 
Demystifying Kernel Exploitation by 
Abusing GDI Objects 
Saif El-Sherei 
PI:EMAIL 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!2!
!
Introduction 
In this paper, we will discuss integer overflows that lead to Kernel Pool memory corruption. We will 
go through discovery, triggering, and exploiting the identified issues, by abusing two GDI objects, the 
bitmap and palette objects. The concepts presented in this paper represent how I understood and 
tackled them, they might not be very scientific in that sense. 
Standing on the Shoulders of Giants 
• 
Nicolas Economou Economonu and Diego Juarez Juarez Abusing GDI for ring 0: 
https://www.coresecurity.com/blog/abusing-gdi-for-ring0-exploit-primitives  
• 
360 Vulcan:  https://cansecwest.com/slides/2017/CSW2017_PengQiu-
ShefangZhong_win32k_dark_composition.pdf  
• 
K33n team: https://www.slideshare.net/PeterHlavaty/windows-kernel-exploitation-this-time-
font-hunt-you-down-in-4-bytes  
• 
J00ru, Halvar Flake, Tarjei Mandt, Halsten, Alex Ionescu, Nikita Terankov and many others. 
The Setup 
• 
IDA Pro. 
• 
Zynamics BinDiff. 
• 
VirtualKD (much love). 
• 
WinDbg 
• 
GDIObjDump WinDbg Extension 
• 
VmWare Worksation: 
- 
Windows 8.1 x64. 
- 
Windows 7 SP1 x86. 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!3!
!
WinDbg Pool Analysis Tips 
!poolused 
This command can be used to view the pool usage of a certain Pool tag or for a certain Pool type. 
!poolfind 
This command is used to find all locations of allocated objects of the specified Pool tag. 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!4!
!
!pool 
This command is used to view the Pool page where the specified address is located in. 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!5!
!
Kernel Pool 
Kernel Pool Types 
The kernel Pool is a sort of Heap memory that is used by the kernel, and it has many types [1], the 
most used are: 
• 
Desktop Heap: primarily used for Desktop objects like Windows, Classes, Menus, and so on. 
- 
Allocation Functions: RtlAllocateHeap(), DesktopAlloc(). 
- 
Free Function: RtlFreeHeap(). 
• 
Non-Paged Pool: Objects allocated to this pool, have their virtual addresses mapped to 
physical pages on the system, some of the objects allocated in the Non-Paged Session Pool 
are related to system objects, like semaphores, Event objects, etc. 
• 
Paged Session Pool: This Pool type is the one we will be focused on in this paper; Objects 
allocated to this pool might not have their virtual addresses mapped to physical memory, and 
objects that are stored there don’t always have to be available in memory for normal Kernel 
operations, and can be only valid for the current execution session, like GDI and some User 
objects.  
- 
For Both the Non-Paged and Paged Pool allocations the ExAllocatePoolWithTag() 
Function is used for allocations, with the 1st argument set to the Pool type if 0x21 
then allocate the object to Paged Session Pool, if 0x29; then the object is Allocated to 
the Non-Paged Pool.  
- 
The function ExFreePoolWithTag() and ExFreePool() are used to Free Pool memory. 
Kernel Pool Allocations Dynamics 
Looking at Win32AllocPool function we can see how the kernel allocates objects to the Pages Session 
Pool type 0x21. 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!6!
!
The next thing to know about Kernel Pool is that its memory is separated into 0x1000 byte Pages. 
The first allocation to that page would result in the chunk being allocated at the beginning of the page, 
subsequent allocations would be allocated from the end of the page, in most pool allocation behaviour. 
In x64 bits systems, the kernel Pool Header is of size 0x10, and size 0x8 for x86 ones [2].  
During tests, it was noticed that requested kernel objects allocation below a certain size gets allocated 
to the Look aside list using a fixed size structure, however the focus will be on normal kernel Pool 
allocations. 
Pool spraying / Feng shui 
The idea behind Pool spraying / feng shui, is to get the Pool memory in a deterministic state. This, is 
done using a series of allocations and deallocations, to create memory holes the same size as the 
vulnerable object where it will be allocated in a memory location adjacent to objects under our control 
that can be later abused.  
If the vulnerable object is not freed within the vulnerable function execution, the memory holes can 
be anywhere in the Pool page, however, if the object gets freed at the end of execution, like the two 
case-studies presented in this paper, then the approach would be to allocate the vulnerable object at 
the end of the Pool page, so the next chunk header won’t be available, and the free call at the end of 
the vulnerable function won’t trigger a BSOD with a BAD POOL HEADER.  
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!7!
!
Forcing Object Allocation at End of Pool Page 
Let’s assume that the vulnerable object is of size 0x40 including the Pool header, the first allocated 
chunk to the page will have to be of the size 0x1000 – 0x40 = 0xFC0 including the Pool Header. 
Next Allocate the 0x40 bytes left in the Pool pages. 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!8!
!
If the overflow requires the object that will be abused, to be at a certain offset from the overflowed 
object.  
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!9!
!
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!10!
!
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!11!
!
Pool Corruption 
Pool corruption can happen for many reasons, use-after-free, linear Pool overflows, Pool Out-of-
bounds writes, and so on. 
Unsigned Integer Overflows 
Unsigned Integer Overflows is the result of unchecked calculations using a controlled integer that will 
wrap the result around MAX_UINT (0xFFFFFFFF) to a small value depending on the calculation, 
resulting in a smaller number than intended, which can have diverse effects depending on how the 
overflowed value is used.  
To have a better understanding of what actually happens in an unsigned integer overflow: 
Assume the system is x86 so UINT sizes are 4 bytes (32 bits), the value 0x80 is added to the supplied 
integer: 
0xFFFFFF80 + 0x81 = 00000001 ?? 
The above calculations will result in 0x1 on x86 bit systems, and in some cases on x64 bit systems, 
the actual result of the calculation is 0x100000001, which is larger than the 4 bytes which represents 
the size of UINT on x86 operating systems, so it gets truncated to 4 bytes omitting the most significant 
byte resulting in 0x1. 
During testing on x64 based systems, it would be very hard to find a clean x64-bit integer overflow 
since it requires very large numbers, although the concept still applies. However, many of the 
vulnerable functions like the one presented later, would actually cast this value to a 32-bit register 
before use, which results in integer truncation to 32-bit as explained above. 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!12!
!
Consider what would happen in a function that: 
1. Accepts an integer as an argument and does some calculations on it; 
2. Those calculations, result in an integer overflow 
3. Later, the function supplies the resulted small integer value to a memory allocation function; 
4. It then uses the original large integer to: 
a. copy data to the newly allocated buffer (linear overflow), or 
b.  tries to write to an offset that it expects to be within the allocation bounds (OOB 
write).  
These will be the two types of integer overflows covered in this paper. 
Linear Overflow 
Linear overflow happens when data is copied to an object without bounds checking, using memory 
copying loops or functions. This can be due to several reasons. For example, an overflowed small size 
is passed to the allocation function, and the memory copying function uses the original large size to 
copy data to the allocated memory location, or when an object gets allocated using a fixed size, and 
the memory copying loop or function uses a user supplied size without verification. 
Out-Of-Bounds(OOB) Write 
In case of OOB write, the application will first allocate an object that is expected to have a fixed size 
or a size larger than a certain value; however, if the size passed to the allocation function suffers from 
an integer overflow, the size can be wrapped to a very small value. 
Later, the application tries to write/read to and index that is expected to be part of the allocated 
object, but since the allocation size was overflowed, the resultant object is much smaller than 
expected, which leads to OOB write/read.  
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!13!
!
Abusing GDI Objects for ring0 Exploit Primitives 
Usually in exploit development, objects corrupted by the 1st stage memory corruption can be used to 
gain a 2nd stage memory corruption primitive. These objects usually have certain members that allow 
such abuse, such as a member that specifies or influences the object or the object’s data size. Thus, 
allowing relative memory read/write, and can be enough in some cases to completely exploit a bug. 
However, if the object has another member, a pointer that points to the object data, it will transform 
the memory corruption primitive into arbitrary memory read/write and will greatly ease the 
exploitation journey. That is why this technique is usually exploited using two objects, one (manager) 
will be used to set the data pointer for the second (usually adjacent) object (worker) to gain arbitrary 
read/write (Game Over). 
In case of the Windows kernel, GDI objects can be used to achieve such primitive, specifically Bitmap 
objects, which was disclosed to my knowledge by k33n team [3], and detailed heavily by Nicolas 
Economou and Diego Juarez in the Abusing GDI objects for ring0 primitives articles and talk [4]. 
I was lucky enough to discover another GDI object that can be abused in the same way, the Palette 
object. To my knowledge relative kernel memory read/write was referred to in two slides of the 360 
Vulcan team talk Win32k Dark Composition [10], but further investigation while trying to exploit 
MS17-017 on x64 bit systems resulted in the finding; this being that the Palette object can also be used 
to gain arbitrary kernel memory read/write as well, which makes it as powerful as the Bitmap abuse 
technique.  
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!14!
!
Relative Memory Read/Write 
Relative memory read/write, is when an exploit primitive allows us to read/write relative to the 
location of a certain memory address, and in this case, object pointers. This is achieved by corrupting 
the GDI object to increase its size, which is usually the first step after the bug is triggered into gaining 
full arbitrary kernel memory read/write. 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!15!
!
Arbitrary Memory Read/Write 
Arbitrary memory read/write in general, is when an object has a member that is a pointer to the 
objects data (data pointer). If this pointer was to be corrupted or altered, whenever a function that is 
used for reading/writing of the objects data is called, it will try to read/write from the altered pointer, 
giving a powerful exploitation primitive to read/write to/from anywhere in memory.  
To explain further consider the manager/worker approach. Object A (Manager) whose size was 
extended, is now able to read/write past the data limit. Reaching Object B (Worker) data pointer 
*Data, by reading the contiguous memory from Object A data until Object B *Data and replacing the 
offset of Object B data pointer, with a leaked or calculated address. Then when the exploit 
reads/writes to Object B data, it will do so, to a pointer under the attacker control. 
!
Demystifying Kernel Exploitation by 
Abusing GDI Objects 2017-07-18!
!
! !
!
pg.!16!
!
SURFOBJ - Bitmaps Objects 
Bitmap objects are represented in kernel memory by Pool tag Gh?5, Gla5 and type _SURFOBJ. The 
structure is documented at msdn [5], ReactOS 32-bit version [6], Diego Juarez’s blog post for x64 bit 
version[7]. This is the technique that will be used to exploit MS16-098, later in the paper, and to my 
knowledge first disclosed by k33n Team [3] and later heavily analysed and detailed by Diego Juarez in 
his blog post[7], and talk[4] with Nicolas Economou both back in 2015. 
SURFOBJ structures 
The most interesting members of the SURFOBJ object are the sizlBitmap, which represent a SIZEL 
structure specifying the width and height of the bitmap. pvScan0 and pvBits are pointers to the bitmap 