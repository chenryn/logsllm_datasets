satisfy all the requirements, which we describe below.
To present our scheme, we ﬁrst recall the general construc-
tion of IBE and deﬁne its terminology. An IBE scheme is
comprised of four parts: setup, key generation, encryption,
and decryption.
• SetupIBE(1n): Takes as input the security parameter.
We split the setup into two parts: Part 1 outputs the
public parameters PPIBE, and Part 2 outputs the mas-
ter public key mpkIBE and the master secret key mskIBE.
The public parameters are common to all key pairs,
and are implicitly given to all algorithms below.
• KeyGenIBE(mskIBE, ID): Takes as input the master se-
cret key and the identity ID of the client, and outputs
the client’s secret key skIBE.
• EncIBE(mpkIBE, m, ID): Takes as input the master pub-
lic key, the plaintext message m, and the identity of a
client, and outputs the ciphertext c.
• DecIBE(c, skIBE): Takes as input the ciphertext and the
client’s secret key and outputs the message.
Due to lack of space, we assume familiarity with the deﬁ-
nition of IBE. Here we informally state that encrypting with
IBE is a secure encryption.
We are now ready to present our construction. Our IBE-
ASE scheme is deﬁned as follows.
• Setup(1n, m):
1. Run Part 1 of SetupIBE, receiving PPIBE.
2. Choose 2m random strings, gj,0, gj,1, for j ∈ [m],
where gj,0 corresponds to not having attribute j,
and gj,1 corresponds to having the attribute. These
will be the “identities” of the system.
3. Run a key generation protocol for an ELH sig-
nature scheme, receiving and setting mVK to the
public veriﬁcation key and mSK to the secret sign-
ing key.
4. Output PP := (PPIBE,{gj,0, gj,1}j∈[m]), mVK, and
mSK.
• GenCert(mSK, χ):
14591. Run Part 2 of SetupIBE, creating mskIBE and mpkIBE.
Set pkχ := (mpkIBE, σ = Sign(mpkIBE)). In what
follows we sometimes abuse notation and refer to
pkχ only as the public key and sometimes as both
the public key and its signature.
2. For each attribute j ∈ [m], call KeyGenIBE on in-
put mskIBE and identity gj,χ[j]. This returns a
secret key skj.
3. Set the client’s secret key to skχ := (sk1, . . . , skm).
Note that now we can discard the master secret key
mskIBE. We use the signature to compensate for the
fact that mpkIBE is not one of the public parameters of
the system.
• Vrfy(mVK, pkχ): Output a bit attesting to the validity
• Enc(pkχ,{xj,0, xj,1}j∈[m]):
of the public key pkχ by checking the signature σ.
1. Verify that Vrfy(mVK, pkχ) = 1. If not then abort.
2. For j ∈ [m], compute cj,0 ← EncIBE(pkχ, xj,0, gj0)
and cj,1 ← EncIBE(pkχ, xj,1, gj1).
3. Output c := c1,0, c1,1, . . . , cm,0, cm,1.
• Dec(skχ, c): Output xj := DecIBE(cj,χ[j], skχ[j]) for all
• Unlink(pkχ, skχ): In our implementation using the Boneh-
j ∈ [m].
Franklin IBE scheme, the public key pkχ has the form
gz for some value z. We implement the unlink opera-
tion by raising pkχ to a random exponent s. All other
values are also raised to s, including the ELH signature
and every component of the secret key.
• Project(pkχ, skχ, S): The project function in the IBE
case is trivial; all that needs to be done is to remove
from the secret key the elements whose index is not in
the set S. The public key remains the same.
(mSK): Exactly as in GenCert, except now the
secret key sk contains secret keys skj,b for all j ∈ [m]
and b ∈ {0, 1}.
This can be trivially achieved in two manners: ﬁrst,
by giving additional secret keys exactly in the format
as given in GenCert or even simpler by just giving x to
the client.
• GenCert∗
(sk, c): Same as Dec, except here the full set of 2m
plaintexts are returned. This is completely straightfor-
ward, as the secret key now includes decryption keys
for all messages.
• Dec∗
The proof of the following theorem is presented in the full
version [35].
Theorem 8.1. The above scheme is a secure ASE scheme
when instantiated with the Boneh-Franklin IBE and an ELH
signature scheme. The ELH signature scheme needs to work
over the same group G, as deﬁned in Boneh-Franklin.
9. ASE USING ELH SIGNATURES
We present an instantiation of an attribute-selective en-
cryption (ASE) scheme (cf. §5) based on extractable linearly
homomorphic (ELH) signatures (cf. §7). The key generation
and certiﬁcation mechanism uses the homomorphic prop-
erty of the signatures while their extractability properties
are used to prove security.
The ELH-ASE scheme is deﬁned as follows.
• Setup(1n, m): Let Sig = (Sign, Vrfy) be an ELH sig-
nature scheme over a group G of order q. Setup uses
Sig to sign several elements in each client’s public key
(deﬁned below). Each element type (g, h, u) has a ded-
icated signature key and there is also a per-attribute
signature key to sign elements of the form uej. For
readability, we denote the above four types of signa-
tures by Signg, Signh, Signu and Signj for j ∈ [m].
The set of public veriﬁcation keys for the above sig-
natures form the master veriﬁcation key mVK and the
corresponding secret signing keys form the master se-
cret key mSK.
We refer to the party running the Setup function as
the CA.
• GenCert(mSK, χ): A public key pkχ associated with
an attribute vector χ = (χ1, . . . χm) is generated as
follows:
compute signatures Signg(g), Signh(h), and Signu(u).
1. Choose random elements g, h, u ∈ G \ {1} and
2. Choose r1, . . . , rm ∈R Z∗
if
χ[j] = 0 and ej = hrj if χ[j] = 1; compute signa-
tures Signj(uej) for j ∈ [m].
q and set ej = grj
Set the public key pkχ to (g, h, u,{ej}j∈[m], Signg(g),
Signh(h), Signu(u),{Signj(uej)}j∈[m]) and the secret key
skχ to {rj}j∈[m].
• Vrfy(mVK, pkχ): Check that g, h, u ∈ G \ {1} and use
• Enc(pkχ,{xj,0, xj,1}j∈[m]): For j ∈ [m], choose sj, tj ∈R
mVK to check all signatures.
Zq and set cj,0 :=(cid:0)gsj , esj
(cid:1) and cj,1 :=
htj , etj
· xj,0
(cid:16)
j · xj,1
j
The ciphertext is the sequence {(cj,0, cj,1)}j∈[m].
(Note: We assume for simplicity that the random val-
ues xj,b, that correspond to input wire labels X b
j in
protocol Πabke of Fig. 6.1 are random elements in G
(these values are later hashed into strings hb
j as part
of the garbling scheme GABKE).)
• Dec(skχ,{(cj,0, cj,1)}j∈[m]): For j ∈ [m], set (C1, C2)
• Unlink(pkχ, skχ): Choose a random value r ∈ Zq and
to the pair cj,χj and compute xj,χj := C2/C1
rj .
raise every element of pk to the power of r; output:
j}j∈[m], (Signg(g))r, (Signh(h))r,
χ := (gr, hr, ur,{er
(cid:48)
pk
(Signu(u))r,{(Signj(uej))r}j∈[m])
(cid:17)
.
• GenCert∗
χ := {r · rj}j∈[m].
and sk(cid:48)
• Project(pkχ, skχ, S): Output a new public key by omit-
ting any component ej for j /∈ S, and set the corre-
sponding secret key to {rj}j∈S.
(mSK): Generation of the pair (pkχ, skχ) is
the same as for GenCert except that h is set to gτ for
known τ ∈R Zq and ej is set to grj for all j ∈ [m] (as
in the case χ = 0m). The secret key sk is comprised of
the set {rj}j∈[m] and the value τ . This enables Dec∗
as follows.
(sk,{cj,0, cj,1}j∈[m]): For j ∈ [m], set (C1, C2)
rj . Then,
to the pair cj,0 and compute xj,0 := C2/C1
for j ∈ [m], set (C1, C2) to the pair cj,1 and compute
xj,1 := C2/C1
τ·rj .
• Dec∗
The proof of the following theorem is presented in the full
version [35].
Theorem 9.1. If Sig is an extractable linearly homomor-
phic signature scheme over a DDH group G then under the
DDH and KEA assumptions over G, the ELH-ASE scheme
1460has the properties of collusion resistance, attribute privacy,
unlinkability, projectability and committing encryption.
10. PERFORMANCE
As the bottleneck in terms of computation is the pairings
and exponentiations (versus garbling and evaluating the pol-
icy), we now give a concrete count of the number of pair-
ings and exponentiations required for each of the two ASE
schemes presented in §8 and §9.
• IBE-based scheme (§8). For concreteness we calculate
the cost using the Boneh-Franklin IBE scheme [13].
– The client computes two exponentiations to ran-
domize both its “master public key” and its asso-
ciated signature.
– The server computes two pairings to verify the
signature of the client’s “master public key”. To
encrypt 2m messages, the server computes 2m
pairings and 2m exponentiations.
– The client computes m pairings and exponentia-
tions to decrypt m messages.
• ELH signature-based scheme (§9).
– The client computes a total of 6 + 2m exponenti-
ations to randomize both the basis and its associ-
ated signature (6) and the public keys and their
associated signatures (2m). These operations can
all be done oﬄine.
– The server computes 3+m signature veriﬁcations,
which requires 6 + 2m pairings (this can be sped
up by batch veriﬁcation of signatures; see below).
To encrypt the 2m messages it computes 4m ex-
ponentiations.
– The client computes m exponentiations to de-
crypt m messages.
We note several important points regarding the perfor-
mance of the ELH signature-based scheme. First, the scheme
requires the client to only compute exponentiations as op-
posed to pairings. This could be meaningful in a setting
where the client is a small computing device. Second, the
server can batch multiple signature veriﬁcations from dif-
ferent clients. The CA’s signature keys for g, h, u and the
attributes are the same for all clients. Using techniques of
Ferrara et al. [24] for batching pairing-based signatures can
help us achieve better amortized run-times.
Implementation and results. We implemented the scheme
described in Figure 6.1 using the ELH signature-based ASE
scheme (cf. §9) utilizing all the optimizations mentioned
above. We instantiate the coin-tossing and commitment
functionalities using SHA-1, and use the privacy-free gar-
bling technique of Zahur et al. [39]. The code as well as
all the scripts for generating our experimental results are
available at https://github.com/amaloz/abke.
All experiments were conducted on an Intel Core i5-4210H
CPU running at 2.90 GHz, and we use the RELIC library [6]
for pairings, using the optimal ate pairing on the BN-P256
curve. On our benchmark machine, pairings take roughly
1.88 ms and exponentiations in G1 take roughly 160 µs
(76 µs when using preprocessing). All experiments were
run over localhost; however, to emulate a WAN environ-
ment we used the tc command in Linux to set the latency
Figure 10.1: Computation time of the server and client for
various numbers of attributes and sizes of the policy. The bottom
x-axis gives the number of gates in the policy, the top x-axis gives
the number of attributes, and the y-axis gives the computation
time in seconds.
Figure 10.2: Communication time of the server and client for
various numbers of attributes and sizes of the policy circuit. The
bottom x-axis gives the number of gates in the policy, the top
x-axis gives the number of attributes, the left y-axis gives the
computation time (in seconds), and the right y-axis gives the
number of bits sent (in Mb).
Figure 10.3: Optimized computation time (i.e., pushing the
cost of randomizing the public key and garbling the policy to an
oﬄine stage, along with batching of the key veriﬁcation) of the
server and client for various numbers of attributes and sizes of the
policy. The bottom x-axis gives the number of gates in the policy,
the top x-axis gives the number of attributes, and the y-axis gives
the computation time in seconds.
to 33 ms (the average latency in the United States [2]) and
the bandwidth to 200 Mbps. For each measurement, we ran
10 iterations of 10 runs, taking the mean of the medians
from each run.
Figures 10.1 and 10.2 show the results of our experiments.
We varied the number of attributes m between 10, 50, and
200, and varied the size of the policy (comprised of only AND
gates) between 1,000, 10,000, and 100,000. Figure 10.1 de-
picts the computation time of the server and client, whereas
Figure 10.2 depicts the communication time. We also list the
number of bits sent by the server and client in Figure 10.2.
103104105103104105103104105NumberofANDGates0.00.20.40.60.81.0ComputationTime(s)ServerTimeClientTime1050200NumberofAttributes103104105103104105103104105NumberofANDGates0.00.51.01.52.02.5CommunicationTime(s)ServerTimeClientTime1050200NumberofAttributes0102030405060DataSent(Mb)DataSent103104105103104105103104105NumberofANDGates0.000.050.100.150.200.25ComputationTime(s)ServerTimeClientTime1050200NumberofAttributes1461Step
S
S [opt]
P P [opt]
159 ms
82 ms
2 (Gb)