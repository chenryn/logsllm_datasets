**作者：天融信阿尔法实验室  
公众号：**
### 前言
在学习PHP的过程中发现有些PHP特性的东西不好理解，如PHP中的00截断，MD5缺陷，反序列化绕过`__wakeup`等等。本人不想拘泥于表面现象的理解，想探究PHP内核到底是怎样做到的。
下面是将用CTF中常用的一个反序列化漏洞CVE-2016-7124(绕过魔法函数`__wakeup`)为例，将此次调试PHP内核的过程分享出来。包括从内核源码调试环境的搭建，序列化与反序列化内核源码分析到最后的漏洞分析整个部分。
### 一、 一个例子引发的思考
我们可以首先看本人写的小例子。
根据上图我们先介绍下PHP中的魔法函数：
我们先看下官方文档对几个常用魔法函数的介绍：
这里稍作总结，当一个类被初始化为实例时会调用`__construct`，当被销毁时会调用`__destruct`。
当一个类调用serialize进行序列化时会自动调用`__sleep`函数，当字符串要利用unserialize反序列化成一个类时会调用`__wakeup`函数。上述魔法函数如果存在都将会自动进行调用。不用自己手动进行显示调用。
现在我们来看最开始的代码部分，在`__destruct`函数中有写入文件的敏感操作。我们这里利用反序列化构造危险的字符串有可能会造成代码执行漏洞。
当我们构造好相应的字符串准备进行利用时，我们却发现它的`__wakeup`函数中有过滤操作，这就给我们的构造造成了阻碍。因为我们知道反序列化无论如何都是要先调用`__wakeup`函数的。
这里我们不禁想到了利用这个PHP反序列化漏洞CVE-2016-7124(绕过魔法函数`__wakeup`)，轻松绕过反序列化会自动调用的魔法函数`___wakeup`，把敏感操作写入进了文件。
当然，上面的代码只是我个人举得一个简单例子，真实情况中不乏有上述情况的出现。但是这种绕过方法却使我非常感兴趣。PHP的内部到底是如何操作和处理才会影响到上层代码逻辑出现如此神奇的情况（BUG）。接下来本人将对PHP内核进行动态调试分析。探究此问题。
此漏洞(CVE-2016-7124)受影响版本PHP5系列为5.6.25之前，7.x系列为7.0.10之前。所以我们后面会编译两个版本：一为不受此漏洞影响的版本7.3.0，另一个版本为漏洞存在的版本5.6.10。通过两个版本的对比来更详细的了解其差异。
### 二、PHP源码调试环境搭建
我们都知道PHP是由C语言开发，因本人所使用环境为WIN 10,所以主要介绍Windows下的环境搭建。我们需要如下材料：
  * PHP源码。
  * PHP SDK工具包，用于构建PHP
  * 调试所需要IDE。
源码可在GITHUB上下载，链接：，可以选择所需要的版本进行下载。
PHP SDK的工具包下载地址：[https://github.com/Microsoft/php-sdk-binary-tools
](https://github.com/Microsoft/php-sdk-binary-tools%20%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%E6%89%80%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85%E5%8F%AA%E6%94%AF%E6%8C%81VC14)
这个地址所下载的工具包只支持VC14，VC15。当然你也可以从
找到支持PHP低版本的VC11,VC12等，在使用PHP SDK之前必须保证你有安装对应版本Windows SDK组件的VS。
后文中会使用PHP7.3.0和5.6.10，下面会介绍这两个版本的源码编译，其他版本手法类似。
#### 2.1 编译Windows PHP 7.3.0
本机环境WIN10 X64，PHP SDK是在上述github链接上下载。进入SDK目录，发现4个批处理文件，这里双击phpsdk-vc15-x64。
接着在此shell中输入 phpsdk_buildtree php7，会发现同目录下出现了php7文件夹，并且shell目录也发生了变化。
接着我们把解压后的源码放在\php7\vc15\x64下，shell进入此文件夹内，利用phpsdk_deps –update –branch master
命令更新下载相关依赖组件。等待完成后，进入源码目录下双击buildconf.bat批处理文件，它会释放configure.bat和configure.js两个文件，在shell中运行configure
–disable-all –enable-cli –enable-debug –enable-phar 配置相应的编译选项，如还有别的需求，可执行
configure –help 查看
根据提示，直接使用nmake进行编译。
编译完成，可执行文件目录在`php7\vc15\x64\php-src\x64\Debug_TS`文件夹下。我们可输入php -v查看相关信息。
#### 2.2 编译Windows PHP 5.6.10
方法跟7.3.0 相同，只需注意的是PHP5.6使用Windows SDK组件版本为VC11，需要下载VS2012，并且不能使用github上下载的PHP
SDK进行编译，需要在 上选择VC11 的PHP
SDK和相关依赖组件进行编译，其余和上述完全相同，这里不再重复。
#### 2.3 调试配置
因为我们上述已经编译好了PHP解释器，我们这里直接使用VSCODE来进行调试。
下载完成后安装C/C++调试扩展。
接着打开源码目录，点击调试—>打开配置，会打开launch.json文件。
根据上图，配置好这三个参数后，可在当前目录下1.php中写PHP代码，在PHP源码中下断点直接进行调试。
调试环境搭建完成。
### 三、PHP反序列化源码解析
一般提及PHP反序列化，往往就是serialize和unserialize两个成对出现的函数，当然必不可少的还有`__sleep()`和`__wakeup()`这两个魔术方法。众所周知，序列化简单点来说就是对象存文件，反序列化刚好相反，从文件中把对象读取出来并实例化。
下面，我们根据上面搭好的调试环境，通过动态调试的手法来直观的反应PHP（7.3.0版本）中序列化与反序列化到底干了哪些事情。
#### 3.1 serialize源码分析
我们先写个不含有`__sleep`魔法函数的简单Demo：
接着我们在源码中全局搜索serialize函数，定位此函数是在var.c文件中。我们直接在函数头下断点，并启动调试。
我们可见在做了一些准备工作后，开始进入序列化处理函数，我们跟进`php_var_serialize`函数。
我们这里继续跟进`php_var_serialize_intern`函数，下面就是主要处理函数了，因为函数代码比较多，我们这里只截出关键部分，此函数还在var.c文件中。