an external trigger signal from the DUT. The EM pulse injector
is a customized hand-made EM probe designed as a simple loop
antenna. Refer Figure 3 for the EM probe used for our experiments.
6.2 Implementation of EMFI attack
Given that our fault attack requires to inject targeted faults, it
becomes necessary to precisely identify the exact instructions to
be faulted within the implementation. We attempt to analyze the
fault vulnerabilities of three different variants of the zgen operation.
Figure 2: Experimental setup for the fault injection
(a)
(b)
Figure 3: (a) Hand-made probe used for our EMFI setup (b)
Probe placed over the DUT
We will give the following terminology to the three considered
variants:
• Variant-1: Adding y to s1c
• Variant-2: Adding s1c to y
• Variant-3: Prevent Overwriting the result onto the operands
The first two variants are based on the order of the operands
within the addition operation while the result of addition in both
the variants is overwritten into the same variable as one of the
operands. But, the third variant is based on storing the result into a
new variable different from the operands. While we demonstrate
our attack against all the three variants, it is important to note that
Variant-2 and 3 were proposed as concrete countermeasures against
the skip-addition attack in a number of works [8, 9].
1
LDR .W r3 , [ r4 , # 4 ] !
2
LDR .W r1 , [ r2 , # 4 ] !
3
CMP
4 ADD
5
6
r4 , r5
r1
r3 ,
s t o r e o p e r a t i o n ∗ /
/ ∗ Target
STR .W r3 ,
[ r0 ,
# 4 ] !
Figure 4: Assembly code snippet from implementation of
Dilithium containing the target store operation
6.2.1 Variant-1: Adding y to s1c. This variant corresponds to Case-
1 of zgen where random information (y) is added to secret informa-
tion (s1c) stored in z. Refer Figure 5 for the C code snippet of the
PCEM pulse generatorDUT (ARM Cortex-M4F)Injection ProbeX-Y TableSession 5B: Fault Attacks and Side Channel AnalysisAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand4341
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
Figure 5: Code snippet: C-Code of Variant-1, Adding y to s1c
with the result of addition stored in the same variable that
contains s1c
poly_unif_gamma1m1 ( z . vec+i , key , nonce + + ) ;
/ ∗ Sampling y in z
f o r ( i = 0 ;
∗ /
i < L ; ++ i )
∗ /
/ ∗ Computing NTT( y )
yhat = z ;
p o l y v e c l _ n t t (& yhat ) ;
/ ∗ Computing NTT( c )
chat = c ;
p o l y _ n t t (& chat ) ;
/ ∗ Computing product
f o r ( i = 0 ;
{
sc
i < L ; ++ i )
∗ /
∗ /
poly_ptwise_imont ( sc . vec+i ,& chat , s1 . vec+ i ) ;
poly_intt_mont ( sc . vec+ i ) ;
}
/ ∗ L a s t a d d i t i o n to g e n e r a t e z
/ ∗
p o l y v e c l _ a d d (&z ,& sc ,& z ) ;
( sc added to y )
∗ /
∗ /
Figure 6: Code snippet: C-Code of Variant-2, Adding s1c to y
with the result for addition stored in the same variable that
contains y
operations corresponding to zgen. It is important to note that all
C-code snippets in this paper only include those operations (lines of
code) relevant to our attack. Referring to the assembly code snippet
in Figure 4 corresponding to the target addition operation, we can
see that the result (Line 4 of Figure 4) in register r3 is stored back
to the memory location pointed to by register r0 offset by 4 (Line 6
of Figure 4).
Utilizing the on-chip hardware debugging feature, we found that
the pointers to both the source and destination memory locations
of the addition operation contain the same value (i.e) r4 = r0 in
line 1 and 6 of Figure 4 respectively. This confirms our claims that
the result of addition is stored back into the memory location of s1c
through the STR instruction (Line 6 in Figure 4). Skipping this STR
(store) instruction once effectively has the same effect as skipping
the addition operation for that coefficient. The addition operation
corresponding to other coefficients could also be similarly faulted
to yield multiple faulted signatures using which the attacker can
poly_unif_gamma1m1 ( y . vec+i , key , nonce + + ) ;
poly_unif_gamma1m1 ( y . vec+i , key , nonce + + ) ;
/ ∗ Sampling y ∗ /
f o r ( i = 0 ;
i < L ; ++ i )
∗ /
/ ∗ Computing NTT( y )
yhat = y ;
p o l y v e c l _ n t t (& yhat ) ;
/ ∗ Computing NTT( c )
chat = c ;
p o l y _ n t t (& chat ) ;
/ ∗ Computing product
f o r ( i = 0 ;
{
sc
i < L ; ++ i )
∗ /
∗ /
poly_ptwise_imont ( z . vec+i ,& chat , s1 . vec+ i ) ;
poly_intt_mont ( z . vec+ i ) ;
}
/ ∗ L a s t a d d i t i o n to g e n e r a t e z
/ ∗
p o l y v e c l _ a d d (&z ,&y ,& z ) ;
( y added to sc )
∗ /
∗ /
/ ∗ Sampling y ∗ /
f o r ( i = 0 ;
i < L ; ++ i )
∗ /
∗ /
/ ∗ Computing NTT( y )
yhat = y ;
p o l y v e c l _ n t t (& yhat ) ;
/ ∗ Computing NTT( c )
chat = c ;
p o l y _ n t t (& chat ) ;
/ ∗ Computing product
/ ∗ R e s u l t
f o r ( i = 0 ;
{
sc
∗ /
s t o r e d in ztemp ∗ /
i < L ; ++ i )
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
poly_ptwise_imont ( ztemp . vec+i ,& chat , s1 . vec+ i ) ;
poly_intt_mont ( ztemp . vec+ i ) ;
}
/ ∗ L a s t a d d i t i o n to g e n e r a t e z
/ ∗ R e s u l t
p o l y v e c l _ a d d (&z ,&y ,& ztemp ) ;
s t o r e d in new v a r i a b l e z
∗ /
∗ /
Figure 7: Code snippet: C-Code of Variant-3, Result is stored
in a new variable compared to that of the operands
recover the primary secret s1 using our analysis presented for Case-
1.
6.2.2 Variant-2: Adding s1c to y. Here, we consider the case when
secret information (s1c) is added to random information (y) stored
in z illustrating Case-2 of zgen. The C code snippet of the corre-
spondingly modified implementation can be seen in Figure 6. The
compiled assembly code generated for this case was similar to that
of Variant-1 (barring changes in the register values and register
locations). Thus, we use the same assembly code in Figure 4 for
our analysis on Variant-2. Similar to our attack on Variant-1, the
same STR (store) instruction (Line 6 of Figure 4) can be skipped
to effectively skip the addition operation for the given coefficient,
thus ensuring that the faulted coefficient retains the value of cor-
responding coefficient of y. The attacker simply repeats the faults
across different coefficients until he generates enough faulted sig-
natures using which our analysis presented for Case-2 can be used
to recover the primary secret s1 of Dilithium.
6.2.3 Variant-3: Prevent Overwriting the result onto the operands.
We consider a third variant wherein the result of the addition op-
eration is stored in a new variable (new memory location), which
was the other technique that was proposed as a possible counter-
measure against skip-addition fault attacks [8, 9]. Refer Figure 7 for
the C Code of the correspondingly modified implementation of the
zgen step, wherein the result of the addition operation is stored in a
new variable (Line 18) compared to that of the operands. We again
observe a very similar compiled assembly implementation (barring
changes in the register values and register location) and hence use
the same assembly code snippet in Figure 4 for analysis.
But for this case, we found that the pointers to the destination
and source operands now point to different memory locations (i.e)
r0 (cid:44) r4. Thus, skipping the STR (store) instruction will not result in
a meaningful fault since the faulted coefficient will retain a random
value. But, we see that the ADD instruction (Line 4 in Figure 4)
is implemented as ADD r3,r1 wherein the source and destination
registers are the same (r3). Thus, skipping this ADD instruction will
ensure that register r3 which contains the first operand (coefficient
Session 5B: Fault Attacks and Side Channel AnalysisAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand435of s1c of y depending on the order of operands), will be stored as
the result of the addition operation. We attribute this nature of the
ADD instruction (source register and destination register are the
same) to the choice of maximum level of compiler optimization
(O3). Upon successful fault injection, the attacker can use either of
our attacks proposed for Case-1 or Case-2, depending on the order
of operands used in the addition operation, to recover the primary
secret s1.
6.3 Systematic Approach towards targeted
fault injection in Dilithium
The success of our attack depends on the attacker’s ability to pre-
cisely target the addition operation of zgen in the last iteration of
the signing procedure. For a given message, the attacker has to
identify the time instance corresponding to the last iteration and
subsequently, the target addition operation within the last itera-
tion. While none of the previous works requiring to inject precisely
targeted faults [8, 13] address this point, we leverage on the deter-
ministic nature of the Dilithium scheme and use the information
from the EM/power side channel for precise identification of our
target operation.
EM Measurements are observed from the same DUT using a near-
field probe and are processed using a Lecroy 610Zi oscilloscope
at a sampling rate of 50MSam/sec. Refer Figure 8(a) for the EM
trace of a single signing procedure wherein the repeating patterns
corresponding to different iterations can be clearly distinguished
through simple visual inspection5. Refer Figure 8(b) for a zoomed-
in-view of the same trace. Thus, mere visual inspection of the trace
allows us to approximately if not accurately locate the different it-
erations and also identify the last iteration which is of most interest
to us for our attack. Given the deterministic nature of the signature
scheme, the position of the last iteration for a given message is the
same (i.e) loclast_iter(m), unless targeted faults lead to rejection of
the faulted signature.
The second and trickier task is to locate the position of addi-
tion operation within the last iteration. The offset of the addition
operation (denoted as locadd(m)
) varies with respect to different