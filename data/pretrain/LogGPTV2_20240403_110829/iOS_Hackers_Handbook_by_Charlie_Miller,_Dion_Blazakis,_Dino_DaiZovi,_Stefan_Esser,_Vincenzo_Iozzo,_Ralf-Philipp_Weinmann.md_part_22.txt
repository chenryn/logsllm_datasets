#include 
#include 
cc0066..iinndddd 115588 44//1166//22001122 55::4455::2222 PPMM
Chapter 6 n Fuzzing iOS Applications 159
#define SBSApplicationLaunchUnlockDevice 4
#define SBSApplicationDebugOnNextLaunch_plus_SBSApplicationLaunch
WaitForDebugger 0x402
bool SBSOpenSensitiveURLAndUnlock(CFURLRef url, char flags);
int main(int argc, char **argv) {
if(argc != 2) {
fprintf(stderr, “Usage: sbopenurl url\n”);
}
CFURLRef cu = CFURLCreateWithBytes(NULL, argv[1],
strlen(argv[1]), kCFStringEncodingUTF8, NULL);
if(!cu) {
fprintf(stderr, “invalid URL\n”);
return 1;
}
int fd = dup(2);
close(2);
bool ret = SBSOpenSensitiveURLAndUnlock(cu, 1);
if(!ret) {
dup2(fd, 2);
fprintf(stderr, “SBSOpenSensitiveURLAndUnlock failed\n”);
return 1;
}
return 0;
}
This program simply calls the SBSOpenSensitiveURLAndUnlock API from the
private SpringBoardServices framework on the URL passed in as a command-
line argument. You can build it with the following commands:
/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/gcc -x
objective-c -arch armv6 -isysroot
/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0
.sdk/ -F /Developer/Platforms/iPhoneOS.platform/Developer/
SDKs/iPhoneOS5.0.sdk/System/Library/PrivateFrameworks -g –
-framework Foundation -framework SpringBoardServices -o
sbopenurl sbopenurl.c
Then you need to give it the proper entitlement to work:
codesign -fs “iPhone Developer” --entitlements ent.plist
sbopenurl
Here you’ll need to have previously downloaded a developer certifi cate from
Apple. The fi le ent.plist contains the necessary entitlements and looks like this:
com.apple.springboard.debugapplications
com.apple.springboard.opensensitiveurl
cc0066..iinndddd 115599 44//1166//22001122 55::4455::2222 PPMM
160 Chapter 6 n Fuzzing iOS Applications
Transfer the program to your iOS device and you have a replacement for open.
The slightly modifi ed version of crash now runs in iOS:
#!/bin/bash
url=$1
sleeptime=$2
filename=/private/var/mobile/Library/Logs/CrashReporter/
LatestCrash-MobileSafari.plist
rm $filename 2> /dev/null
echo Going to do $url
/var/root/sbopenurl $url
sleep $sleeptime
cat $filename 2>/dev/null
/usr/bin/killall -9 MobileSafari 2>/dev/null
and is run the same way as previously:
iPhone:~ root# ./crash http://192.168.1.2/a/62.pdf 6
Going to do http://192.168.1.2/a/62.pdf
iPhone:~ root# ./crash http://192.168.1.2/a/63.pdf 6
Going to do http://192.168.1.2/a/63.pdf
AutoSubmitted
SysInfoCrashReporterKey
411e2ce88eec340ad40d98f220a2238d3696254c
bug_type
109
...
You now have a way to generate inputs, launch MobileSafari against a URL,
and detect crashes. All that remains is to tie it all together. We leave that to the
interested reader.
PPT Fuzzing Fun
When you run the fuzzer from the previous section, you will quickly begin to
fi nd bugs. Following is one such example that is not patched at the time of this
writing. It is from the same crash outlined in the “Quick Look Fuzzing” section.
Notice that no symbols are available for MobileSafari crashes on the iOS device.
# ./crash http://192.168.1.2/bad.ppt 10
Going to do http://192.168.1.2/bad.ppt
cc0066..iinndddd 116600 44//1166//22001122 55::4455::2222 PPMM
Chapter 6 n Fuzzing iOS Applications 161
AutoSubmitted
SysInfoCrashReporterKey
411e2ce88eec340ad40d98f220a2238d3696254c
bug_type
109
description
Incident Identifi er: 7A75E653-019B-44AC-BE54-
271959167450
CrashReporter Key: 411e2ce88eec340ad40d98f220a2238d3696254c
Hardware Model: iPhone3,1
Process: MobileSafari [1103]
Path: /Applications/MobileSafari.app/MobileSafari
Identifi er: MobileSafari
Version: ??? (???)
Code Type: ARM (Native)
Parent Process: launchd [1]
Date/Time: 2011-12-18 21:56:57.053 -0600
OS Version: iPhone OS 5.0.1 (9A405)
Report Version: 104
Exception Type: EXC_BAD_ACCESS (SIGSEGV)
Exception Codes: KERN_INVALID_ADDRESS at 0x0000002c
Crashed Thread: 10
...
Thread 10 Crashed:
0 Offi ceImport 0x383594a0 0x3813e000 + 2208928
1 Offi ceImport 0x381bdc82 0x3813e000 + 523394
2 Offi ceImport 0x381bcbbe 0x3813e000 + 519102
3 Offi ceImport 0x381bb990 0x3813e000 + 514448
4 Offi ceImport 0x38148010 0x3813e000 + 40976
5 Offi ceImport 0x38147b94 0x3813e000 + 39828
...
Thread 10 crashed with ARM Thread State:
r0: 0x00000024 r1: 0x00000000 r2: 0x00000000 r3: 0x00000000
r4: 0x00000000 r5: 0x0ecbece8 r6: 0x00000000 r7: 0x04fa8620
r8: 0x002d3c90 r9: 0x00000003 r10: 0x00000003 r11: 0x0ecc43b0
ip: 0x04fa8620 sp: 0x04fa8620 lr: 0x381bdc89 pc: 0x383594a0
cpsr: 0x00000030
If you sync your device and look at the logs in the Organizer window in
Xcode, you get symbols. (Or you can use the standalone symbolicatecrash util-
ity, which comes as part of the iOS SDK). See Figure 6-6.
cc0066..iinndddd 116611 44//1166//22001122 55::4455::2222 PPMM
162 Chapter 6 n Fuzzing iOS Applications
Figure 6.6: Symbolicated crash report seen in Xcode
SMS Fuzzing
So far, you’ve fuzzed the web browser that comes with iOS. This is by far one of
the largest attack surfaces in iOS. However, iOS is obviously more than a mobile
web browser. In this section, you fuzz something that you don’t see on many
desktops. It demonstrates how to fuzz the way iPhones receive Short Message
Service (SMS) messages.
SMS, the technology behind text messages, consists of small amounts of data
sent over the wireless carrier radio network to devices. These messages repre-
sent a great vector for attacks for a few reasons. The main reason is, unlike the
TCP/IP stack, there is no way to “fi rewall” inbound connections. All new SMS
communications arrive unannounced and must be handled by the device. From
a targeting perspective, it is also very interesting. Though it might be hard to
fi nd someone’s IP address, especially for a laptop that is carried from place to
place, it is often quite easy to fi nd someone’s phone number. Another reason
SMS is an attractive attack vector is that it doesn’t require any user interaction
to get data to the application. This differs from attacking web browsers, which
requires getting the user to visit a malicious site. As an added bonus, on iOS, the
process that handles SMS messages does not run in a sandbox and is respon-
sible for communication with the baseband processor (more on this in a bit). So,
armed with a phone number and an SMS exploit, an attacker could conceivably
get code running that can monitor phone calls and text messages, with no user
interaction, and there isn’t anything the victims can do about it if they want to
receive phone calls or SMS messages. An SMS exploit would be very powerful
indeed. Let’s see how you could fi nd an SMS vulnerability in iOS.
cc0066..iinndddd 116622 44//1166//22001122 55::4455::2222 PPMM
Chapter 6 n Fuzzing iOS Applications 163
SMS Basics
SMS is really a communications protocol designed to be used in Global System
of Mobile Communications (GSM) mobile communication systems. This protocol
was originally documented in the GSM standards more than twenty years ago.
SMS uses the bandwidth normally reserved for telephony traffi c control when
not in use. This control channel is used for the phone to communicate to nearby
towers, and provides a way for both towers and the phone to know everything
is okay on the network. This channel is also needed for call setup, such as the
message the tower sends to the phone when there is an incoming call. SMS was
designed to also use these control channels so that it could be implemented
without adding any expense or hardware for the carrier. The drawback is that
messages are necessarily short, as the name suggests. Currently, SMS data is
restricted to 140 bytes, or 160 7-bit characters (70 16-bit characters). SMS is now
available on a wide range of networks, including 3G and 4G networks.
When a device sends an SMS message, it is sent to a Short Message Service
Center (SMSC). The SMSC then forwards the message toward the intended
recipient. This may mean passing it to another SMSC or directly to the recipi-
ent, depending on whether the sending and receiving device are on the same
carrier network. SMSCs play the role of routers in IP networks, with one big
exception. If a recipient is not reachable — for example, if their phone is turned
off or they are somewhere out of the range of service — the SMSC queues the
message for later delivery. SMS delivery is best effort, meaning there is no
guarantee that a given message will reach its destination and no guarantee
that no delays will occur.
SMS can deliver more than just text. Some providers allow over-the-air pro-
gramming of devices using SMS messages. It is possible to send binary data
such as ringtones and pictures or use SMS to alert when voicemails are received.
iOS, in particular, uses SMS messages to provide information concerning visual
voicemails and MMS.
The iPhone is actually composed of two processors: the main CPU, called
the application processor, and a second CPU, called the baseband processor.
The main CPU is the one that runs the iOS operating system kernel and all
applications mentioned so far. The baseband processor runs a specialized real-
time operating system that controls the mobile phone interface and handles all
communication with the cellular phone network. (The baseband processor is
covered in detail in Chapter 11.) For now, you need to know only that the base-
band processor provides a way for the application processor to communicate
with it. This communication takes place over multiple logical serial lines. On
older iPhones, the actual software running on the application CPU communicates
to the modem over these serial lines using the text-based GSM AT command
set. These AT commands are used to control every aspect of the cellular phone
network interface, including call control and SMS delivery.
cc0066..iinndddd 116633 44//1166//22001122 55::4455::2222 PPMM
164 Chapter 6 n Fuzzing iOS Applications
When an SMSC delivers an SMS message to the modem of the iPhone, the
modem communicates with the application processor via an unsolicited AT
command result code. The result code consists of two lines of text. The fi rst
contains the result code and the number of bytes that follow on the next line.
The second line contains the SMS message in hexadecimal representation.
These AT command result codes are read by some version of the CommCenter
process on the iPhone.
Exactly which process handles the communication is dependent on the
hardware present on the iPhone. Inside the /System/Library/LaunchDaemons
directory are two associated plist fi les called com.apple.CommCenter.plist and
com.apple.CommCenterClassic.plist. Examining these (after converting to
XML format using plutil) show they both have the label com.apple.CommCenter,
however, they are limited to different hardware. CommCenterClassic lists:
...
LimitLoadToHardware
machine
iPhone1,2
iPhone2,1
iPhone3,1
iPod2,1
iPod2,2
iPod3,1
iPod4,1
iPad0,1
iPad1,1
iPad2,1
iPad2,2
AppleTV2,1
...
By way of comparison, CommCenter lists a different set of hardware:
...
LimitLoadToHardware
machine
iPhone3,3
iPhone4,1
iPhone4,2
iPad2,3
iPad3,1
iPad3,2
iPad3,3
cc0066..iinndddd 116644 44//1166//22001122 55::4455::2233 PPMM
Chapter 6 n Fuzzing iOS Applications 165
...
For simplicity this chapter examines CommCenterClassic.
Focusing on the Protocol Data Unit Mode
The SMS specifi cation has two modes in which a modem may operate, called
SMS text mode and SMS Protocol Data Unit (PDU) mode. When acting in dif-
ferent modes, the syntax of SMS AT commands and the responses returned
will differ. The biggest difference is that SMS text mode supports only text. For
example, to send an SMS message, you would use something like this:
AT+CMGS=”+85291234567”
Lame SMS text mode message
Because of this limitation, far fewer features are available in SMS text mode.
Another problem with SMS text mode is that it is not as widely supported by
modems.
For these reasons, this section focuses on SMS PDU mode. This provides you
with a much larger (although compared to a browser, quite small) attack surface
in which to look for bugs.
SMS messages exist in two formats. The SMS-SUBMIT format is used for
messages sent from mobile devices to the SMSC, and the SMS-DELIVER format
is used for messages sent from the SMSC to the mobile device. Because this
section focuses on how iOS handles incoming messages, it concentrates on
SMS-DELIVER messages.
Following is an example of an unsolicited AT result code for an SMS-DELIVER
format in SMS PDU mode:
+CMT: ,30
0791947106004034040D91947196466656F8000090108211421540
0BE8329BFD4697D9EC377D
The CMT result code is used for delivery of SMS messages in iOS. Now that