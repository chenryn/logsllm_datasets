• 
aud (audience): The token issuer issues the JWT to an intended 
recipient or a list of recipients, which is represented by the aud 
parameter. The recipient or the recipient list should know how to 
parse the JWT and validate it. Prior to any validation check, it must 
first see whether the particular JWT is issued for its use and if not 
should reject immediately. The value of the aud parameter can 
be a case-sensitive string value or an array of strings. The token 
issuer should know, prior to issuing the token, who the intended 
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
162
recipient (or the recipients) of the token is, and the value of the aud 
parameter must be a pre-agreed value between the token issuer 
and the recipient. In practice, one can also use a regular expression 
to validate the audience of the token. For example, the value of the 
aud in the token can be *.apress.com, while each recipient under 
the apress.com domain can have its own aud values: foo.apress.
com, bar.apress.com likewise. Instead of finding an exact match for 
the aud value, each recipient can just check whether the aud value 
matches the regular expression: (?:[a-zA-Z0-9]*|\*).apress.com. 
This will make sure that any recipient can use a JWT, which is having 
any subdomain of apress.com.
• 
exp (expiration time): Each JWT carries an expiration time. The 
recipient of the JWT token must reject it, if that token has expired. 
The issuer can decide the value of the expiration time. The JWT 
specification does not recommend or provide any guidelines on 
how to decide the best token expiration time. It’s a responsibility of 
the other specifications, which use JWT internally to provide such 
recommendations. The value of the exp parameter is calculated by 
adding the expiration time (from the token issued time) in seconds 
to the time elapsed from 1970-01-01T00:00:00Z UTC to the current 
time. If the token issuer’s clock is out of sync with the recipient’s clock 
(irrespective of their time zone), then the expiration time validation 
could fail. To fix that, each recipient can add a couple of minutes as 
the clock skew during the validation process.
• 
nbf (not before): The recipient of the token should reject it, if the 
value of the nbf parameter is greater than the current time. The JWT 
is not good enough to use prior to the value indicated in the nbf 
parameter. The value of the nbf parameter is the number of seconds 
elapsed from 1970-01-01T00:00:00Z UTC to the not before time.
• 
iat (issued at): The iat parameter in the JWT indicates the issued 
time of the JWT as calculated by the token issuer. The value 
of the iat parameter is the number of seconds elapsed from 
1970-01-01T00:00:00Z UTC to the current time, when the token is 
issued.
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
163
• 
jti (JWT ID): The jti parameter in the JWT is a unique token 
identifier generated by the token issuer. If the token recipient accepts 
JWTs from multiple token issuers, then this value may not be unique 
across all the issuers. In that case, the token recipient can maintain 
the token uniqueness by maintaining the tokens under the token 
issuer. The combination of the token issuer identifier + the jti 
should produce a unique token identifier.
The public claims are defined by the other specifications, which are built on top 
of JWT. To avoid any collisions in such cases, names should either be registered in the 
IANA JSON Web Token Claims registry or defined in a collision-resistant manner with a 
proper namespace. For example, the OpenID Connect specification defines its own set 
of claims, which are included inside the ID token (the ID token itself is a JWT), and those 
claims are registered in the IANA JSON Web Token Claims registry.
The private claims should indeed be private and shared only between a given 
token issuer and a selected set of recipients. These claims should be used with caution, 
because there is a chance for collision. If a given recipient accepts tokens from multiple 
token issuers, then the semantics of the same claim may be different from one issuer to 
another, if it is a private claim.
 JWT Signature
The third part of the JWT is the signature, which is also base64url-encoded. The 
cryptographic parameters related to the signature are defined in the JOSE header. In 
this particular example, Google uses RSASSA-PKCS1-V1_53 with the SHA256 hashing 
algorithm, which is expressed by value of the alg parameter in the JOSE header: RS256. 
The following shows the signature element of the JWT returned back from Google. The 
signature itself is not human readable—so there is no point of trying to base64url-decode 
the following:
TVKv-pdyvk2gW8sGsCbsnkqsrS0TH00xnY6ETkIfgIxfotvFn5IwKm3xyBMpy0
FFe0Rb5Ht8AEJV6PdWyxz8rMgX2HROWqSo_RfEfUpBb4iOsq4W28KftW5
H0IA44VmNZ6zU4YTqPSt4TPhyFC-9fP2D_Hg7JQozpQRUfbWTJI
3 RSASSA-PKCS1-V1_5 is defined in RFC 3447: www.ietf.org/rfc/rfc3447.txt. It uses the 
signer’s RSA private key to sign the message in the way defined by PKCS#1.
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
164
GENERATING A PLAINTEXT JWT
The plaintext JWT doesn’t have a signature. It has only two parts. The value of the alg 
parameter in the JOSE header must be set to none. The following Java code generates 
a plaintext JWT. you can download the complete Java sample as a Maven project from 
https://github.com/apisecurity/samples/tree/master/ch07/sample01.
public static String buildPlainJWT() {
// build audience restriction list.
List aud = new ArrayList();
aud.add("https://app1.foo.com");
aud.add("https://app2.foo.com");
Date currentTime = new Date();
// create a claims set.
JWTClaimsSet jwtClaims = new JWTClaimsSet.Builder().
                                // set the value of the issuer.
                                issuer("https://apress.com").
                                 // set the subject value - JWT belongs to  
// this subject.
                                subject("john").
                                // set values for audience restriction.
                                audience(aud).
                                // expiration time set to 10 minutes.
                                 expirationTime(new Date(new Date().getTime() 
+ 1000 * 60 * 10)).
                                 // set the valid from time to current time.
                                notBeforeTime(currentTime).
                                // set issued time to current time.
                                issueTime(currentTime).
                                 // set a generated UUID as the JWT  
// identifier.
                                jwtID(UUID.randomUUID().toString()).
                                build();
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
165
// create plaintext JWT with the JWT claims.
PlainJWT plainJwt = new PlainJWT(jwtClaims);
// serialize into string.
String jwtInText = plainJwt.serialize();
// print the value of the JWT.
System.out.println(jwtInText);
return jwtInText;
}
To build and run the program, execute the following Maven command from the ch07/
sample01 directory.
\> mvn test -Psample01
The preceding code produces the following output, which is a JWT. If you run the code again 
and again, you may not get the same output as the value of the currentTime variable 
changes every time you run the program:
eyJhbGciOiJub25lIn0.eyJleHAiOjE0MDIwMzcxNDEsInN1YiI6ImpvaG4iLCJuYm
YiOjE0MDIwMzY1NDEsImF1ZCI6WyJodHRwczpcL1wvYXBwMS5mb28uY29tIi
wiaHR0cHM6XC9cL2FwcDIuZm9vLmNvbSJdLCJpc3MiOiJodHRwczpcL1wvYX
ByZXNzLmNvbSIsImp0aSI6IjVmMmQzM2RmLTEyNDktNGIwMS04MmYxLWJl
MjliM2NhOTY4OSIsImlhdCI6MTQwMjAzNjU0MX0.
The following Java code shows how to parse a base64url-encoded JWT. This code would 
ideally run at the JWT recipient end:
public static PlainJWT parsePlainJWT() throws ParseException {
        // get JWT in base64url-encoded text.
        String jwtInText = buildPlainJWT();
        // build a plain JWT from the bade64url-encoded text.
        PlainJWT plainJwt  = PlainJWT.parse(jwtInText);
        // print the JOSE header in JSON.
        System.out.println(plainJwt.getHeader().toString());
        // print JWT body in JSON.
        System.out.println(plainJwt.getPayload().toString());
        return plainJwt;
}
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
166
This code produces the following output, which includes the parsed JOSE header and the 
payload:
{"alg":"none"}
{
   "exp":1402038339,
   "sub":"john",
   "nbf":1402037739,
   "aud":["https:\/\/app1.foo.com","https:\/\/app2.foo.com"],
   "iss":"https:\/\/apress.com",
   "jti":"1e41881f-7472-4030-8132-856ccf4cbb25",
   "iat":1402037739
}
JOSE WORKING GROUP
Many working groups within the IETF work directly with JSON, including the OAuth working 
group and the System for Cross-domain Identity Management (SCIM) working group. The SCIM 
working group is building a provisioning standard based on JSON. Outside the IETF, the OASIS 
XACML working group is working on building a JSON profile for XACML 3.0.
The OpenID Connect specification, which is developed under the OpenID Foundation, is also 
heavily based on JSON. Due to the rise of standards built around JSON and the heavy usage of 
JSON for data exchange in APIs, it has become absolutely necessary to define how to secure 
JSON messages at the message level. The use of Transport Layer Security (TLS) only provides 
confidentiality and integrity at the transport layer. The JOSE working group, formed under the 
IETF, has the goal of standardizing integrity protection and confidentiality as well as the format 
for keys and algorithm identifiers to support interoperability of security services for protocols 
that use JSON. JSON Web Signature (RFC 7515), JSON Web Encryption (RFC 7516), JSON 
Web Key (RFC 7517), and JSON Web Algorithms (RFC 7518) are four IETF proposed standards, 
which were developed under the JOSE working group.
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
167
 JSON Web Signature (JWS)
The JSON Web Signature (JWS) specification, developed under the IETF JOSE working 
group, represents a message or a payload, which is digitally signed or MACed (when 
a hashing algorithm is used with HMAC). A signed message can be serialized in two 
ways by following the JWS specification: the JWS compact serialization and the JWS 
JSON serialization. The Google OpenID Connect example discussed at the beginning of 
this chapter uses JWS compact serialization. In fact, the OpenID Connect specification 
mandates to use JWS compact serialization and JWE compact serialization whenever 
necessary (we discuss JWE in Chapter 8). The term JWS token is used to refer to the 
serialized form of a payload, following any of the serialization techniques defined in the 
JWS specification.
Note JSON Web Tokens (JWTs) are always serialized with the JWS compact 
serialization or the JWE compact serialization. We discuss JWE (JSON Web 
Encryption) in Chapter 8.
 JWS Compact Serialization
JWS compact serialization represents a signed JSON payload as a compact URL-safe 
string. This compact string has three main elements separated by periods (.): the JOSE 
header, the JWS payload, and the JWS signature (see Figure 7-1). If you use compact 
serialization against a JSON payload, then you can have only a single signature, which is 
computed over the complete JOSE header and JWS payload.
 JOSE Header
The JWS specification introduces 11 parameters to the JOSE header. The following 
lists out the parameters carried in a JOSE header, which are related to the message 
Figure 7-1. A JWS token with compact serialization
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
168
signature. Out of all those parameters, the JWT specification only defines the typ and 
cty parameters (as we discussed before); the rest is defined by the JWS specification. 
The JOSE header in a JWS token carries all the parameters required by the JWS token 
recipient to properly validate its signature:
• 
alg (algorithm): The name of the algorithm, which is used to sign 
the JSON payload. This is a required attribute in the JOSE header. 
Failure to include this in the header will result in a token parsing 
error. The value of the alg parameter is a string, which is picked from 
the JSON Web Signature and Encryption Algorithms registry defined 
by the JSON Web Algorithms (JWA) specification. If the value of 
the alg parameter is not picked from the preceding registry, then it 
should be defined in a collision-resistant manner, but that won’t give 
any guarantee that the particular algorithm is identified by all JWS 
implementations. It’s always better to stick to the algorithms defined 
in the JWA specification.
• 
jku: The jku parameter in the JOSE header carries a URL, which 
points to a JSON Web Key (JWK) set. This JWK set represents a 
collection of JSON-encoded public keys, where one of the keys 
is used to sign the JSON payload. Whatever the protocol used to 
retrieve the key set should provide the integrity protection. If keys are 
retrieved over HTTP, then instead of plain HTTP, HTTPS (or HTTP 
over TLS) should be used. We discuss Transport Layer Security (TLS) 
in detail in Appendix C. The jku is an optional parameter.
• 
jwk: The jwk parameter in JOSE header represents the public key 
corresponding to the key that is used to sign the JSON payload. The 
key is encoded as per the JSON Web Key (JWK) specification. The jku 
parameter, which we discussed before, points to a link that holds a 
set of JWKs, while the jwk parameter embeds the key into the JOSE 
header itself. The jwk is an optional parameter.
• 
kid: The kid parameter of the JOSE header represents an identifier 
for the key that is used to sign the JSON payload. Using this identifier, 
the recipient of the JWS should be able locate the key. If the token 
issuer uses the kid parameter in the JOSE header to let the recipient 
know about the signing key, then the corresponding key should be 
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
169
exchanged “somehow” between the token issuer and the recipient 
beforehand. How this key exchange happens is out of the scope of 
the JWS specification. If the value of the kid parameter refers to a 
JWK, then the value of this parameter should match the value of the 
kid parameter in the JWK. The kid is an optional parameter in the 
JOSE header.
• 
x5u: The x5u parameter in the JOSE header is very much similar to 
the jku parameter, which we discussed before. Instead of pointing 
to a JWK set, the URL here points to an X.509 certificate or a chain 
of X.509 certificates. The resource pointed by the URL must hold 
the certificate or the chain of certificates in the PEM- encoded form. 
Each certificate in the chain must appear between the delimiters4: 
-----BEGIN CERTIFICATE----- and -----END CERTIFICATE-----. The 
public key corresponding to the key used to sign the JSON payload 
should be the very first entry in the certificate chain, and the rest is 
the certificates of intermediate CAs (certificate authority) and the 
root CA. The x5u is an optional parameter in the JOSE header.
• 
x5c: The x5c parameter in the JOSE header represents the X.509 
certificate (or the certificate chain), which corresponds to the private 
key, which is used to sign the JSON payload. This is similar to the jwk 
parameter we discussed before, but in this case, instead of a JWK, it’s 
an X.509 certificate (or a chain of certificates). The certificate or the 
certificate chain is represented in a JSON array of certificate value 
strings. Each element in the array should be a base64-encoded DER 
PKIX certificate value. The public key corresponding to the key used 
to sign the JSON payload should be the very first entry in the JSON 
array, and the rest is the certificates of intermediate CAs (certificate 
authority) and the root CA. The x5c is an optional parameter in the 
JOSE header.
4 The Internet IP Security PKI Profile of IKEv1/ISAKMP, IKEv2, and PKIX (RFC 4945) defines the 
delimiters for X.509 certificates under Section 6.1, https://tools.ietf.org/html/rfc4945
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
170
• 
x5t: The x5t parameter in the JOSE header represents the base64url-
encoded SHA-1 thumbprint of the X.509 certificate corresponding 
to the key used to sign the JSON payload. This is similar to the kid 
parameter we discussed before. Both these parameters are used 
to locate the key. If the token issuer uses the x5t parameter in the 
JOSE header to let the recipient know about the signing key, then the 
corresponding key should be exchanged “somehow” between the 
token issuer and the recipient beforehand. How this key exchange 
happens is out of the scope of the JWS specification. The x5t is an 
optional parameter in the JOSE header.
• 
x5t#s256: The x5t#s256 parameter in the JOSE header represents 
the base64url-encoded SHA256 thumbprint of the X.509 certificate 
corresponding to the key used to sign the JSON payload. The only 
difference between x5t#s256 and the x5t is the hashing algorithm. 
The x5t#s256 is an optional parameter in the JOSE header.
• 
typ: The typ parameter in the JOSE header is used to define the 
media type of the complete JWS. There are two types of components 
that process a JWS: JWS implementations and JWS applications. 