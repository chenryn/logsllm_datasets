SystemTap 提供深入准确的系统活动和程序行为分析，以便您可以准确包我系统和程序瓶颈。
Eclipse 的功能函数图插件使用 SystemTap 作为后端，可让其完整监控程序状态，其中包括功能调用、返
回、次数以及用户空间变量，并以直观形式显示以便优化。
有关 SystemTap 的详情请参考《SystemTap 初学者指南》，地址为
http://access.redhat.com/site/documentation/Red_Hat_Enterprise_Linux/。
3.5.2. OProfile
OProfile（oprofile）是一个系统范围的性能监控工具。它使用处理器专用性能监控硬件搜索有关内核和系
统可执行程序的信息，比如何时参考内存，L2 缓存要求数，以及收到的硬件中断数。它还可以用来决定处理
器用量，以及使用最多的应用程序和服务。
Oprofile 还可以通过 Eclipse Oprofile 插件与 Eclipse 一同使用。这个插件可以让用户轻松确定其代码中最耗
时的部分，并在执行 OProfile 的所有命令行功能时获得最丰富的直观结果。
但用户应该注意到 OProfile 的几个限制：
性能监控示例可能不准确因为该处理器可能没有按顺序执行指令，可能是根据最接近的指令执行，而不
是触发中断的指令。
因为 OProfile 是系统范围内的程序，且会多次启动和停止，多次运行的示例允许有累积。就是说您需要
清除以前程序运行产生的示例数据。
它主要是识别有 CPU 限制的问题进程，因此无法识别等待为其他事件锁定而处于睡眠状态的进程。
有关使用 OProfile 的详情请参考 《部署指南》，地址为
http://access.redhat.com/site/documentation/Red_Hat_Enterprise_Linux/；或者
/usr/share/doc/oprofile- 中的 oprofile 文档。
21
红帽企业版 Linux 6 性能调节指南
3.5.3. Valgrind
Valgrind 提供大量探测和分析工具以便帮助您改进性能并修正您的程序。这些工具可以探测与内存和线程有
关的错误，以及堆、栈和阵列过度运行，以便您在程序代码中轻松定位并修改错误。他们还可以分析缓存，
堆，以及分支预测以便识别增加程序速度，减少程序内存使用的因素。
Valgrind 通过在综合 CPU 运行分析您的程序，并检测其执行的程序代码。然后它会输出“说明”明确为用户指
定的文件描述符、文件或者网络插槽鉴别出执行程序所涉及的每个进程。检测等级根据 Valgrind 工具的使用
及设置而有所不同，但重要的是注意执行检测的代码的时间比一般执行代码要长 4-50 倍。
Valgrind 可以在您的程序中原封不动地使用，不需要重新编译。但因为 Valgrind 使用调试信息锁定代码中的
问题，如果您的程序以及支持库无法使用启用的调试信息编译，则强烈建议您将重新编译包含在这个信息
中。
从红帽企业版 Linux 6.4 开始 Valgrind 整合了 gdb (GNU Project Debugger) 以改进调试效率。
有关 Valgrind 的详情请参考《开发者指南》，地址为
http://access.redhat.com/site/documentation/Red_Hat_Enterprise_Linux/。或者在安装 valgrind 软件包后
查看 man valgrind 命令。附带的文档也可在此找到：
/usr/share/doc/valgrind-/valgrind_manual.pdf
/usr/share/doc/valgrind-/html/index.html
有关如何使用 Valgrind 分析系统内存的详情请参考 第 5.3 节 “使用 Valgrind 简要描述内存使用”。
3.5.4. Perf
perf 工具提供大量有用的性能计数器，可让用户评估其系统中其他程序的影响：
perf stat
这个命令常见性能事件的总体统计，其中包括执行的质量以及消耗的时钟周期。您可以使用选项标
签收集事件中默认测量事件以外的统计数据。从红帽企业版 Linux 6.4 开始，还可以使用 perf
stat 过滤根据一个或者多个指定的控制组（cgroup）指定的监控。有关详情请查看 man
page：man perf-stat。
perf record
这个命令将性能数据记录到文件中，以后可以使用 perf report 进行分析。有关详情请查看
man page：man perf-record。
perf report
这个命令从文件中读取性能数据并分析记录的数据。有关详情请查看 man page：man perf-
report。
perf list
这个命令列出具体机器中的可用事件。这些时间随性能监控硬件以及系统软件配置而有所不同。有
关详情请查看 man page：man perf-list
perf top
这个命令与 top 工具的功能类似。它可以实时生成并显示性能计数器分析。有关详情请查看 man
page：man perf-top。
22
第 3 章 监控和分析系统性能
有关 perf 的详情请查看红帽企业版 Linux 《开发者指南》，地址为
http://access.redhat.com/site/documentation/Red_Hat_Enterprise_Linux/。
3.6. Red Hat Enterprise MRG
Red Hat Enterprise MRG 的实时组件包括 Tuna，它是可让用户调整其系统的可调节参数值，并查看那些
更改结果。虽然这个工具是为使用实时组件而开发，但它也可以用于调整标准红帽企业版 Linux 系统。
使用 Tuna，您可以调整或者禁用不必要的系统活动，其中包括：
与电源管理有关的 BIOS 参数、错误探测以及系统管理中断；
网络设置，比如中断结合以及 TCP 使用；
日志文件系统中的日志活动；
系统活动记录；
中断和用户进程是由具体 CPU 还是一组 CPU 处理；
是否使用 swap 空间；以及
如何处理内存不足的意外情况。
有关使用 Tuna 界面调整 Red Hat Enterprise MRG 的概念性信息请参考《实时调节指南》中“常规系统调
节”一章。有关使用 Tuna 界面的步骤请参考《Tuna 用户指南》。这两本指南的网址为
http://access.redhat.com/site/documentation/Red_Hat_Enterprise_MRG/。
23
红帽企业版 Linux 6 性能调节指南
第第 4 章章 CPU
CPU 意为中央处理单元，对大多数系统来说这个名字并不恰当，因为中央暗指一个，而大多数现代系统有一
个以上的处理单元或者核。通常 CPUs 是一个放在一个包装中附着在主板插槽。主板的每个插槽可连接到其
他 CPU 插槽、内存控制器、中断控制器以及其他外部设备。连接到操作系统的插槽是一个 CPU 及相关资源
的逻辑分组。这个概念是我们要讨论的 CPU 调节中大多数问题的关键。
红帽企业版 Linux 有大量关于系统 CPU 事件的统计。这些统计数据在计划调节策略以改进 CPU 性能时很有
帮助。第 4.1.2 节 “调节 CPU 性能” 中讨论了一些游泳的统计，在哪里可以找到它们以及如何就性能调节对
其进行分析。
拓拓扑扑
在旧的计算机系统中，每个系统只有几个 CPU，因此将其构架称为对称多处理器（SMP）。就是说系统中的
每个 CPU 对可用内存有类似（或者对称）的访问。近年来，CPU 按插槽计数已完善到可以尝试对系统中的
所有内存进行对称访问，但这项技术非常昂贵。大多数高 CPU 计数系统现在才有名为非均匀内存访
问（NUMA）技术而不是 SMP。
AMD 处理器很久以前就已经在其超级传输（HT）互联中采用此架构，同时 Intel 也已最其快速通道互
联（QPI）设计中使用此架构。NUMA 和 SMP 调节方法各异，因为最为程序分配资源时要考虑此系统的拓
扑。
线线程程
Linux 操作系统内部到执行单元被称为线程。线程有注册上下文、栈以及在 CPU 中运行到可执行代码片段。
操作系统（OS）的任务时在可用 CPU 中调度这些线程。
操作系统根据跨各个核到线程间到负载平衡最大化 CPU 使用。因为 OS 主要考虑的是要让 CPU 处于忙碌状
态，它可能没有就程序性能作出最佳选择。将一个程序线程从一个 CPU 移动到其他插槽要比等待 CPU 对性
能的影响更大，因为访问内存的操作在跨插槽时会变得非常缓慢。对于高性能程序，设计者最好可以决定要
将其放在哪个线程中。第 4.2 节 “CPU 调度” 中讨论了如何以最佳方式分配 CPU 和内存以便最好地执行程序
线程。
中中断断
中断（在 Linux 中被称为 IRQ）是一个不易觉察（但仍很重要）的系统事件，它可以影响程序性能。这些事
件由操作系统处理，并用于外部设备以通知数据到达或者操作完成，比如系统写入或者计时器事件。
OS 或者 CPU 执行程序代码处理中断的方法不影响程序功能。但它可能影响程序的性能。本章还讨论了防止
中断对程序性能产生负面影响。
4.1. CPU 拓拓扑扑
4.1.1. CPU 和和 NUMA 拓拓扑扑
第一台计算机处理器是单处理机，就是说系统只有一个 CPU。让这个操作系统可以平行运行进程的幻想是希
望它能够将一个 CPU 迅速从一个执行线程切换到另一个。为提高系统性能，设计者注意到采用提高时钟率
提高指令执行速度的方法是有限的（通常受采用当前技术生成稳定时钟波形的限制）。在努力获得更好总体
系统性能时，设计者在系统中添加了另一个 CPU，就可以让两个平行流同时运行。这个添加处理器的趋势一
直延续至今。
大多数早期的单处理机系统的设计为让每个 CPU 到每个内存位置都使用同一逻辑路径（一般是平行总
线）。这样每次 CPU 访问任意位置的内存时与其他系统中的 CPU 对内存的访问消耗的时间是相同的。此类
24
第 4 章 CPU
架构就是我们所说的同步多处理器（SMP）系统。SMP 适合 CPU 数较少的系统，但一旦 CPU 计数超过某
一点（8 或者 16），要满足对内存的平等访问所需的平行 trace 数就会使用过多的板载资源，留给外设的空
间就太少。
有两个新概念整合在一起可以允许系统中有较多的 CPU：
1. 串行总线
2. NUMA 拓扑
串行总线是一个有很高时钟频率的单线通讯路径，以分组突发传送的方式传送数据。硬件设计者开始使用串
行总线作为 CPU 之间、CPU 和内存控制器以及其他外设之间的高速互联。就是说不是要求在每个 CPU 中
都有 32 和 64 个板载 trace 连接到内存子系统，现在只要一个 trace 即可，明显减少了板载空间要求。
同时，硬件设计者通过减小芯片尺寸在同样的空间中放置了更多晶体管。他们不是将独立 CPU 直接放到主
板上，而是开始将其打包到处理器包中作为多核处理器。然后设计者不是为每个处理器包提供对等的内存访
问，而是借助非均衡存储器访问（NUMA）策略，让每个包/插槽组合有一个或者多个专用内存区以便提供高
速访问。每个插槽还有到另一个插槽的互联以便提供对其他插槽内存的低速访问。
作为简单的 NUMA 示例，假设我们有一个双插槽主板，其中每个插槽都有四核。就是说该系统中的 CPU 总
数为 8，每个插槽有 4 个。每个插槽还附带 4GB 内存条，内存总数为 8GB。在这个示例中 CPU 0-3 在插
槽 0 中，CPU 4-7 在插槽 1 中。这个示例中的每个插槽都对应一个 NUMA 代码。
CPU 0 访问内存条 0 大约需要三个时钟周期：一个周期是将地址发给内存控制器，一个周期是设置对该内
存位置的访问，一个周期是读取或者写入到该位置。但 CPU 4 可能需要 6 个时钟周期方可访问内存的同一
位置，因为它位于不同的插槽，必须经过两个内存控制器：插槽 1 中的本地内存控制器和插槽 0 中的远程内
存控制器。如果在那个位置出现竞争（即如果有一个以上 CPU 同时尝试访问同一位置），内存控制器需要
对该内存进行随机且连续的访问，所以内存访问所需时间会较长。添加缓存一致性（保证本地 CPU 缓存包
含同一内存位置的相同数据）会让此过程更为复杂。
最新高端处理器，比如 Intel 的 Xeon 和 AMD 的 Opteron 都有 NUMA 拓扑。AMD 处理器使用我们所说的超