title:A Realistic Look At Failure Detectors
author:Carole Delporte-Gallet and
Hugues Fauconnier and
Rachid Guerraoui
A Realistic 
Look At Failure Detectors 
tLaboratoire 
C. Delporte-Ga.llet 
d'Informatique 
Universite 
tDistributed 
t, H. Fauconnier t, R. Guerraoui t 
Algorithrnique: 
Paris VII - Denis Diderot 
Programming Laboratory, 
Fondements et Applications, 
Swiss Federal Institute 
of Technology 
in Lausanne 
Abstract 
This paper shows that, in an environment where we 
do not bound the number of faulty processes, 
P of Perfect failure detectors 
realistic 
ment problems like uniform consensus, 
cast, and terminating reliable broadcast (also called 
Byzantine Generals). 
the class 
is the weakest (among 
failure detectors) 
atomic broad­
to solve fundamental  agree­
hierarchy, by showing 
detector 
we collapse 
the 
Roughly speaking, in this environment, 
Chandra-Toueg  failure 
that P ends up being the only class to solve those agree­
ment problems. This contributes in explaining 
why 
systems  we know of do rely 
most reliable distributed 
on some group membership service that precisely aims 
at emulating P. 
side effect of our work, we show 
As an interesting 
that, in our general environment, uniform consensus 
is strictly hamer than consensus, 
view that uniform consensus 
strictly weaker than terminating 
and atomic broadcast are 
reliable broadcast. 
and we revisit the 
agreement 
determining 
about failures 
Roughly speaking, 
and sufficient to reach agree­
and terminating reliable broad­
need to de­
problem, processes 
formation about failures, and this information 
is the 
key to reaching agreement in the presence of failures. 
The motivation 
of our work is to determine the exact 
information 
needed to achieve agree­
ment in an environment 
where we do not bound the 
number of failures (we focus here on process crash­
failures). 
that infor­
an abstract metric' 
mation comes down to providing 
that helps measure whether  a set of synchrony as­
sumptions are necessary 
ment [3J. 
We consider in this paper two fundamental 
problems: consensu.s 
cast. In the consensu.s 
cide on a common value among one of the proposed 
values. 
lent to solving the atomic broadcast problem [IJ, in any 
system where only a finite number of messages can be 
lost, e.g., with reliable 
in delivering 
tally ordered manner. Solving this problem is a key to 
building highly available and consistent  replicated 
ser­
vices. Terminating reliable broadcast is a strong and 
convenient 
should deliver 
should deliver 
with reliable 
a specific nil value for every message that was broad­
by any COf­
cast by a faulty process and not delivered 
rect process [11]. This problem is a rephrasing, 
in the 
crash-stop model, of the famous Byzantine Generals 
problem [13]. 
1 Solving this problem is known to be equiva­
the same sequence of messages, 
broadcast but, in addition, 
This problem consists 
messages to processes 
form of reliable 
the processes 
and to­
in a reliable 
broadcast: 
channels. 
just like 
1 By default, we consider the uniform variant of the con­
sensus problem, which precludes any disagreement among two 
processes, even if one of them ends up being faulty [10). In 
Section 6, we discuss the impact of going back to the COTTect­
restricted variant of consensus, 
interest. 
which is solely of theoretical 
1 Introduction 
1.1 Motivation 
environment. 
but is rather difficult to 
It is well known that agreement is at the heart of re­
computing, 
liable distributed 
achieve in a failure-prone 
lar, without any synchrony assumptions 
tions on process relative 
delays), 
distributed  processes 
through reli­
able channels and at most one of them might fail (and 
it can do so only by crashing) [5]. In fact, synchrony 
assumptions are needed to provide processes 
agreement is impossible  even 
that communicate 
among a set of 
speeds and communication 
In particu­
(i.e., 
assump­
with in-
0-7695-1597-5/02 
$17.00 © 2002 IEEE 
345 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:21:30 UTC from IEEE Xplore.  Restrictions apply. 
1.2 Background: the failure detector 
hierarchy 
and this 
hiding lower 
with hints about process failures, 
A failure detector 
oracle that provides 
of a failure detector. 
a distributed 
In a seminal paper [1], Chandra and Toueg proposed 
about fail­
a precise way to measure the information 
ures needed to solve agreement problems within the 
abstraction 
is represented  by 
processes 
oracle can be viewed as an abstraction 
level synchrony assumptions such as message commu­
speeds, Le., as­
nication delays and process relative 
sumptions that underly any useful form of information 
about process failures. 
Chandra and Toueg established 
detector  classes. 
failure detectors 
about failures. 
a class B in the hierarchy 
failures 
captured by B. In other words, the 
about failures 
synchrony assumptions under lying A are stronger 
than 
those underlying 
classes were identified: 
Strong failure detectors, 
detectors, 
Among these classes, P is the strongest 
is the weakest. The  following 
Basically, a class gathers a set of 
that capture the same information 
than 
In short, a clas s A is stronger 
three interesting 
the class 08, of Eventually 
the class 8 of Strong failure 
and the class P of Perfect 
captured by A encompasses 
results were proved [1]: 
B. In particular, 
failure detectors. 
the information 
a hierarchy 
of failure 
whereas OS 
if the information  about 
• Any failure 
detector 
of class OS solves consensus 
(and hence atomic broadcast) if a majority of 
processes 
are correct. 
• Any failure detector of class 8 solves consensus 
(and hence atomic broadcast) even ifthe number 
of faulty processes 
is not bounded. 2 
• Any failure 
detector of class P solves terminating 
reliable 
processes 
is not bounded. 
broadcast even if the number of faulty 
the fact 
each of these results  conveys 
is sufficient to 
under a spe­
Interestingly, 
about failures 
that a. certain information 
solve some agreement problem (possibly 
cific assumption on the maximum number of faulty 
processes [1]). A natural  question 
also necessary? 
information 
and Toueg addressed the 
with  Hadzilacos,  Chandra 
question for the case of consensus with a majority of 
They proved that 08 is actually 
correct processes. 
the weakest for consensus if a majority of processes 
about failures 
follows: is tbat 
Together 
2In fact, the  actual definition of S assumes that at least one 
process  does  not  crash 
to the more general case where any number of processes  can 
crash. 
but the definition can easily be adapted 
are correct [2J. In a precise sense, this goes through 
proving that there is an algorithm A that transforms 
any failure detector 'D that solves consensus into a 
failure detector of class OS. In short, the very exis­
tence of A means that V provides at least as much 
is 
information 
hence minimal. Chandra and Toueg also pointed out 
of 
the very fact  that 
08 is neither sufficient for consensus nor for 
failures, 
terminating 
if we do not bound  the  number 
as OS: this information 
about failures 
broadcast. 
reliable 
1.3 Contributions 
the num­
reliable 
reliable 
broadcast 
failures, 
detectors 
determining 
that can guess the fu­
the weakest failure 
where we do not restrict 
that indeed encapsulate 
if any number of processes 
(as in [2)) and following 
even in a perfectly 
system), and we focus only on realistic 
In an environment 
ber of possible 
detector classes for problems like consensus (thus for 
atomic broadcast) and terminating 
have been open for almost a decade now. We show 
here that there is one answer to these questions: P. 
can fail, P 
More precisely, 
is the weakest failure detector class to solve consen­
sus (hence atomic hroadcast) and terminating 
broadcast. 
We state and prove our result using simple algorithm 
fail­
the original 
reductions 
ure detector formalism of [11, with one exception 
how­
ever. We exclude from the original 
space of (1], failure detectors 
ture (these cannot be implemented 
synchronous 
failures 
assumptions. 
At first glance, our result seems to introduce 
diction. 
S solves consensus even if we do not restrict 
weaker than 
ber of faulty processes, 
P. How can P be the weakest? Interestingly, 
we show in the paper, within the space of realistic 
fail­
ure detectors, 
power. As observed in [12], 
ference between these classes is rather artificial 
general environment. 
To summarise, our paper shows that, in an environ­
ment where we do not bound the number Of faulty pro­
about failures 
cesses, the exact information 
solve consensus (hence atomic broadcast) 
nating reliable 
we collapse 
being the only useful class in the hierarchy 
agreement problems. A posteriori, 
prising and our results might explain why developers 
of reliable 
as  a basic bUilding block [14], a group membership 
needed to 
and  termi­
broadcast is captured by P. In short, 
a contra­
above, it was shown in !l] that 
this means that the dif­
in our 
the failure detector hierarchy: P ends up 
8 and P have the same computational 
and 8 is strictly 
this is not that sur­
As we recalled 
distributed 
synchrony 
systems have been considering, 
to solve 
the num­
and as 
failure  detector 
346 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:21:30 UTC from IEEE Xplore.  Restrictions apply. 
which precisely 
aims at emulating a Perfect 
Le., when a process is suspected, 
Le., 
it is excluded from the group: every suspi­
service, 
failure detector, 
timed-out, 
cion hence turns out to be accurate [4, 6, 16]. 
As a side effect of our work, we point out two inter­
First, if 
esting results in our general environment. 
of consen­
we consider the correct-restricted  variant 
P is clearly not the 
sus (Le., nQn-uniform 
weakest. A simple corollary 
is that 
(uniform) 
restricted  variant 
visit the view that consensus and atomic broadcast 
are strictly weaker problems than terminating 
broadcast. 
harder than the correct­
Second, we also· re­
of this observation 
of consensus. 
consensus), 
is strictly 
consensus 
reliable 
2 System  model 
with failure 
computation 
is the FLP model [51 augmented with the 
Our model of asynchronous 
detection 
failure detector abstraction [1, 21. A discrete 
global 
clock is assumed, and 4:>, the range of the clock's ticks, 
is the set of natural numbers. The global clock is used 
and is not accessible 
for presentation  simplicity 
to the 
processes. 
We sketch here the fundamentals 
of the 
in specific details about 
model. The reader interested 
the model should consult [2]. 
2.1 Failure patterns and environments 
system composed of a finite 
. . .  ,Pn} ( Inl =  n > 3). 
We consider a distributed 
set of n processes n =  {Pl,P2, 
A process Pi is said to crash at time t if Pi does not 
perform any action after time t (the notion of action 
below). Failures are permanent, i.e., no 
is recalled 
process recovers after a crash. A correct process is 
a process that does not crash. A failure pattern is a 
function F from 4:> to 2°, where F(t) denotes the set 
that have crashed through time t. The 
of processes 
set of correct processes 
correct(F). 
An environment E is a set of failure patterns. En­
describe the crashes that can occur in a 
vironments 
system. In this paper, we consider the environment 
that contains all possible 
do not bound the number of processes 
pattern F is noted 
that can crash. 
in a failure 
patterns. 
failure 
That is, we 
with each failure detec­
A failure detector history H with range R 
denoted by Vi. Associated 
tor V is a range Rv3 of values output by the failure 
detector. 
is a function H from n x 4:> to R. For every process 
Pi E n, for every time t E 4:>, H(p" t) denotes the value 
detector module of process Pi at time t, 
of the failure 
i.e., H(Pi' t) denotes  the 
value output by Vi at time 
t. A failure detector 
V is a function that maps each 
failure pattern F to a set of failure detector 
with range Rv. V(F) denotes the set of possible 
fail­
for the failure 
pattern 
ure detector  histories 
F, i.e., each  history 
a possible behaviour 
of V for the failure pattern F. The failure detectors 
introduced 
any such failure 
any history H in V(F), H(Pi, 
suspected 
in !l] do all have a range R =  2°. For 
pattern F and 
t) is the set of processes 
permitted 
represents 
detector V, any failure 
by process Pi at time t. 
histories 
2.3 Algorithms 
a 
detector 
three actions: 
(1) Pi receives 
of the step, (c) the mes­
D is a collection 
Ai (one per process 