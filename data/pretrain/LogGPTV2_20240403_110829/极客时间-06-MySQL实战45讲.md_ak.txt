# "快照"在 MVCC 里是怎么工作的？在可重复读隔离级别下，事务在启动的时候就"拍了个快照"。注意，这个快照是基于整库的。这时，你会说这看上去不太现实啊。如果一个库有100G，那么我启动一个事务，MySQL 就要拷贝 100G的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。实际上，我们并不需要拷贝出这 100G的数据。我们先来看看这个快照是怎么实现的。InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transactionid。它是在事务开始的时候向 InnoDB的事务系统申请的，是按申请顺序严格递增的。而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id 赋值给这个数据版本的事务 ID，记为 rowtrx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的row trx_id。如图 2 所示，就是一个记录被多个事务连续更新后的状态。![](Images/3a99c08a7c1412087b8f2243bbc0e7c2.png){savepage-src="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png"}```{=html}```图 2 行状态变更图```{=html}```图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是25。你可能会问，前面的文章不是说，语句更新会生成 undolog（回滚日志）吗？那么，**undo log 在哪呢？**实际上，图 2 中的三个虚线箭头，就是 undo log；而 V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。明白了多版本和 row trx_id 的概念后，我们再来想一下，InnoDB是怎么定义那个"100G"的快照的。按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。因此，一个事务只需要在启动的时候声明说，"以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本"。当然，如果"上一个版本"也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在"活跃"的所有事务ID。"活跃"指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id和这个一致性视图的对比结果得到的。这个视图数组把所有的 row trx_id 分成了几种不同的情况。![](Images/5bc5669c5b2c0965822e0fcfcdcaad31.png){savepage-src="https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png"}```{=html}```图 3 数据版本可见性规则```{=html}```这样，对于当前事务的启动瞬间来说，一个数据版本的 rowtrx_id，有以下几种可能：1.  如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；2.  如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；3.  如果落在黄色部分，那就包括两种情况\    a. 若 row trx_id    在数组中，表示这个版本是由还没提交的事务生成的，不可见；\    b. 若 row trx_id    不在数组中，表示这个版本是已经提交了的事务生成的，可见。比如，对于图 2 中的数据来说，如果有一个事务，它的低水位是18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出V3，所以在它看来，这一行的值是 11。你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的2 或者 3(a)的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是"静态"的了。所以你现在知道了，**InnoDB利用了"所有数据都有多个版本"的这个特性，实现了"秒级创建快照"的能力。**接下来，我们继续看一下图 1 中的三个事务，分析下事务 A的语句返回的结果，为什么是 k=1。这里，我们不妨做如下假设：1.  事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；2.  事务 A、B、C 的版本号分别是    100、101、102，且当前系统里只有这四个事务；3.  三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。这样，事务 A 的视图数组就是 \[99,100\], 事务 B 的视图数组是\[99,100,101\], 事务 C 的视图数组是 \[99,100,101,102\]。为了简化分析，我先把其他干扰语句去掉，只画出跟事务 A查询逻辑有关的操作：![](Images/77bcde8a183c9fb41913ccb76f8845dc.png){savepage-src="https://static001.geekbang.org/resource/image/94/49/9416c310e406519b7460437cb0c5c149.png"}```{=html}```图 4 事务 A 查询数据逻辑图```{=html}```从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了(1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90这个版本已经成为了历史版本。第二个有效更新是事务 B，把数据从 (1,2) 改成了(1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102又成为了历史版本。你可能注意到了，在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的(1,3) 这个版本已经变成当前版本了。但这个版本对事务 A必须是不可见的，否则就变成脏读了。好，现在事务 A 要来读数据了，它的视图数组是\[99,100\]。当然了，读数据都是从当前版本读起的。所以，事务 A查询语句的读数据流程是这样的：-   找到 (1,3) 的时候，判断出 row    trx_id=101，比高水位大，处于红色区域，不可见；-   接着，找到上一个历史版本，一看 row    trx_id=102，比高水位大，处于红色区域，不可见；-   再往前找，终于找到了（1,1)，它的 row    trx_id=90，比低水位小，处于绿色区域，可见。这样执行下来，虽然期间这一行数据被修改过，但是事务 A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：1.  版本未提交，不可见；2.  版本已提交，但是是在视图创建后提交的，不可见；3.  版本已提交，而且是在视图创建前提交的，可见。现在，我们用这个规则来判断图 4 中的查询结果，事务 A的查询语句的视图数组是在事务 A 启动的时候生成的，这时候：-   (1,3) 还没提交，属于情况 1，不可见；-   (1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况    2，不可见；-   (1,1) 是在视图数组创建之前提交的，可见。你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。
# 更新逻辑细心的同学可能有疑问了：**事务 B 的 update语句，如果按照一致性读，好像结果不对哦？**你看图 5 中，事务 B 的视图数组是先生成的，之后事务 C才提交，不是应该看不见 (1,2) 吗，怎么能算出 (1,3) 来？![](Images/1e43438f80289e65443d42b4c57603e2.png){savepage-src="https://static001.geekbang.org/resource/image/86/9f/86ad7e8abe7bf16505b97718d8ac149f.png"}```{=html}```图 5 事务 B 更新逻辑图```{=html}```是的，如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C的更新就丢失了。因此，事务 B 此时的 set k=k+1是在（1,2）的基础上进行的操作。所以，这里就用到了这样一条规则：**更新数据都是先读后写的，而这个读，只能读当前的值，称为"当前读"（currentread）。**因此，在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据(1,3)，这个新版本的 row trx_id 是 101。所以，在执行事务 B 查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。这里我们提到了一个概念，叫作当前读。其实，除了 update 语句外，select语句如果加锁，也是当前读。所以，如果把事务 A 的查询语句 select \* from t where id=1 修改一下，加上lock in share mode 或 for update，也都可以读到版本号是 101的数据，返回的 k 的值是 3。下面这两个 select 语句，就是分别加了读锁（S锁，共享锁）和写锁（X 锁，排他锁）。    mysql> select k from t where id=1 lock in share mode;mysql> select k from t where id=1 for update;再往前一步，假设事务 C 不是马上提交的，而是变成了下面的事务C'，会怎么样呢？![](Images/b393e95fdd13ea20d18983b0edb68815.png){savepage-src="https://static001.geekbang.org/resource/image/cd/6e/cda2a0d7decb61e59dddc83ac51efb6e.png"}```{=html}```图 6 事务 A、B、C\'的执行流程```{=html}```事务 C'的不同是，更新后并没有马上提交，在它提交前，事务 B的更新语句先发起了。前面说过了，虽然事务 C'还没提交，但是 (1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务 B的更新语句会怎么处理呢？这时候，我们在上一篇文章中提到的"两阶段锁协议"就要上场了。事务C'没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C'释放这个锁，才能继续它的当前读。![](Images/b85b5f0139a968d4097fb9988838bbbe.png){savepage-src="https://static001.geekbang.org/resource/image/54/92/540967ea905e8b63630e496786d84c92.png"}```{=html}```图 7 事务 B 更新逻辑图（配合事务 C\'）```{=html}```到这里，我们把一致性读、当前读和行锁就串起来了。现在，我们再回到文章开头的问题：**事务的可重复读的能力是怎么实现的？**可重复读的核心就是一致性读（consistentread）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：-   在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；-   在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。那么，我们再看一下，在读提交隔离级别下，事务 A 和事务 B 的查询语句查到的k，分别应该是多少呢？这里需要说明一下，"start transaction with consistent snapshot;"的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的start transaction。下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的read view 框。（注意：这里，我们用的还是事务 C的逻辑直接提交，而不是事务 C'）![](Images/4992b1d7aa628333f26b76d8a89187a8.png){savepage-src="https://static001.geekbang.org/resource/image/18/be/18fd5179b38c8c3804b313c3582cd1be.jpg"}```{=html}```图 8 读提交隔离级别下的事务状态图```{=html}```这时，事务 A 的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：-   (1,3) 还没提交，属于情况 1，不可见；-   (1,2) 提交了，属于情况 3，可见。所以，这时候事务 A 查询语句返回的是 k=2。显然地，事务 B 查询结果 k=3。
# 小结InnoDB 的行数据有多个版本，每个数据版本有自己的 rowtrx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据row trx_id 和一致性视图确定数据版本的可见性。-   对于可重复读，查询只承认在事务启动前就已经提交完成的数据；-   对于读提交，查询只承认在语句启动前就已经提交完成的数据；而当前读，总是读取已经提交完成的最新版本。你也可以想一下，为什么表结构不支持"可重复读"？这是因为表结构没有对应的行数据，也没有row trx_id，因此只能遵循当前读的逻辑。当然，MySQL 8.0 已经可以把表结构放在 InnoDB字典里了，也许以后会支持表结构的可重复读。又到思考题时间了。我用下面的表结构和初始化语句作为试验环境，事务隔离级别是可重复读。现在，我要把所有"字段c 和 id 值相等的行"的 c值清零，但是却发现了一个"诡异"的、改不掉的情况。请你构造出这种情况，并说明其原理。    mysql> CREATE TABLE `t` (  `id` int(11) NOT NULL,  `c` int(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB;insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);![](Images/ddb40bcba104a62daed4ce1fc0756090.png){savepage-src="https://static001.geekbang.org/resource/image/9b/0b/9b8fe7cf88c9ba40dc12e93e36c3060b.png"}\复现出来以后，请你再思考一下，在实际的业务开发中有没有可能碰到这种情况？你的应用代码会不会掉进这个"坑"里，你又是怎么解决的呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。
# 上期问题时间我在上一篇文章最后，留给你的问题是：怎么删除表的前 10000行。比较多的留言都选择了第二种方式，即：在一个连接中循环执行 20 次delete from T limit 500。确实是这样的，第二种方式是相对较好的。第一种方式（即：直接执行 delete from T limit10000）里面，单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。第三种方式（即：在 20 个连接中同时执行 delete from T limit500），会人为造成锁冲突。评论区留言点赞板：> \@Tony Du 的评论，详细而且准确。\> \@Knight²º¹⁸ 提到了如果可以加上特定条件，将这 10000> 行天然分开，可以考虑第三种。是的，实际上在操作的时候我也建议你尽量拿到> ID 再删除。\> \@荒漠甘泉 提了一个不错的问题，大家需要区分行锁、MDL> 锁和表锁的区别。对 InnoDB 表更新一行，可能过了 MDL> 关，却被挡在行锁阶段。![](Images/d7767a95fa59b270d692441e706a6dce.png){savepage-src="https://static001.geekbang.org/resource/image/ce/d9/ce7f4e35916ed1aa49206a53a0547bd9.jpg"}
# 09 \| 普通索引和唯一索引，应该怎么选择？今天的正文开始前，我要特意感谢一下评论区几位留下高质量留言的同学。]{.reference}用户名是 \@某、人的同学，对文章的知识点做了梳理，然后提了关于事务可见性的问题，就是先启动但是后提交的事务，对数据可见性的影响。@夏日雨同学也提到了这个问题，我在置顶评论中回复了，今天的文章末尾也会再展开说明。@Justin和 \@倪大人两位同学提了两个好问题。]{.reference}对于能够引发更深一步思考的问题，我会在回复的内容中写上"好问题"三个字，方便你搜索，你也可以去看看他们的留言。]{.reference}非常感谢大家很细致地看文章，并且留下了那么多和很高质量的留言。知道文章有给大家带来一些新理解，对我来说是一个很好的鼓励。同时，也让其他认真看评论区的同学，有机会发现一些自己还没有意识到的、但可能还不清晰的知识点，这也在总体上提高了整个专栏的质量。再次谢谢你们。]{.reference}好了，现在就回到我们今天的正文内容。]{.reference}在前面的基础篇文章中，我给你介绍过索引的基本概念，相信你已经了解了唯一索引和普通索引的区别。今天我们就继续来谈谈，在不同的业务场景下，应该选择普通索引，还是唯一索引？假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL 语句：``{=html}    select name from CUser where id_card = 'xxxxxxxyyyyyyzzzzz';所以，你一定会考虑在 id_card 字段上建索引。由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择，要么给id_card字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？简单起见，我们还是用第 4篇文章[《深入浅出索引（上）》](https://time.geekbang.org/column/article/69236)中的例子来说明，假设字段k 上的值都不重复。![](Images/82754ea191fdd44b8a5f8f97d6cec69d.png){savepage-src="https://static001.geekbang.org/resource/image/1e/46/1ed9536031d6698570ea175a7b7f9a46.png"}```{=html}```图 1 InnoDB 的索引组织结构```{=html}```接下来，我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。