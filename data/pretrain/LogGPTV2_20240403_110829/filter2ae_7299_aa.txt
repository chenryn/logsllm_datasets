# 深耕保护模式（四）
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 页
X86模式下存在10-10-12分页和2-9-9-12分页。
## 10-10-12分页
在x86系统下，总说一个进程有4GB空间，那么按照这个说法来说，在windows上起一个进程就要占用4GB空间，两个进程就要占用8GB空间，但是实际上是我们电脑的物理内存往往只有8GB，16GB多一点的可能有32GB，我们却启动了几十个进程，这显然是矛盾的。
实际上，我们所说的进程有4GB内存空间，这个概念是虚拟的。cpu会经过一定算法从虚拟内存地址找到物理内存地址。
这里还有几个概念：线性地址、有效地址、物理地址
如下指令：
MOV eax,dword ptr ds:[0x12345678]
其中,0x12345678 是有效地址
ds.Base + 0x12345678 是线性地址
物理地址就是真正在内存条上的地址，不是虚拟出来的。
每个进程都有一个CR3,(准确的说是都一个CR3的值，CR3本身是个寄存器，一个核，只有一套寄存器)
CR3指向一个物理页，一共4096字节,从CR3到物理页的过程如图：
下面在10-10-12分页模式下从线性地址找到物理地址。要想当前xp系统是10-10-12分页，需要修改boot.ini文件。
将noexecute 改成 execute。
写入一句话到记事本，并通过CE找到他的线性地址。
采用10-10-12分页方式拆解这个线性地址。(十位，十位和十二位)
拆完以后CPU首先去找CR3寄存器，CR3寄存器是一个唯一存储物理地址的寄存器，CR3中存了一个值，这个值指向一个物理页，这个也有4096个字节，也就是他的第一级，第一部分分的高十位就是确定这个地址在第一级的哪个位置，第二个十位就是确定在第二级的哪个位置，最后12位就是确定在4096个字节的物理页的v哪个地址，4096
= 2 ^ 12;第一级中每个成员是4个字节，4096个字节可以存放1024 = 2 ^ 10个地址，同样第二级也是一样。
通过windbg获取notepad的cr3。
这里还得计算几个偏移。前面两个都是目录，由于一个是4个字节所以需要乘以4。
在!dd表示查看物理地址。这里第一层是0
    kd> !dd 15d45000+0
第一级找到了，要去掉最后三位，这三位是属性。
    kd> !dd 15bad000+2A8
第三级一样的。使用!db一个字节一个字节的查看。
    kd> !dd 15ba8000+A40
    kd> !db 15ba8a40
物理地址就已经找到了。
在白皮书描述中整个过程如下（线性地址到物理地址）：
## PDE和PTE
Cr3寄存器起到了不可或缺的作用。那Cr3寄存器中存储的究竟是什么呢？
Cr3寄存器不同于其他寄存器，在所有的寄存器中，只有Cr3寄存器存储的地址是 **物理地址** ，其他寄存器存储的都是 **线性地址** 。
Cr3寄存器所存储的物理地址指向了一个 **页目录表（Page-Directory Table，PDT）**
，也就是我们前面所说的查找时的第一级。在Windows中，一个页的大小通常为4KB(有4MB的)，即一个页（页目录表）可以存储1024个页目录表项（PDE）。
而第二级为页表(PTT)， 每个页表的大小为4KB，即一个页表可以存储1024个页表项（PTE）。
这种设计方式正是10-10-12分页的由来，由于前面两级是四个字节一组，那么索引为2的10次方就可以获取到每一项(整个是4096字节)，也就是10位；而最后一级物理页，一个字节一组，所以需要4096组，索引也要指到4096，也就是2的12次方，正好12位。
上面说到10-10-12分页还有一个大页（4MB）,实际上是没有页表(PTT)这一级，也就是PDE直接去索引物理页，那么就是2^10*2^12，正好是4MB。
页表项（PTE）具有以下特征：
  1. PTE可以指向一个物理页，也可以不指向物理页
  2. 多个PTE可以指向同一个物理页
  3. 一个PTE只能指向一个物理页
## 实验
我们都知道地址0是绝对不能写入的，如果写入回报0xC0000005错误，那么是什么原因不能写入呢？他的本质实际上就是0地址没有对应的物理页，也就是上面所说的“PTE可以指向一个物理页，也可以不指向物理页”，0地址实际上就没有对应的物理页。
那么我们可以自己将线性地址0的PTE挂载到物理页上，这样就可以读写了。运行这样一段代码：
    #include "stdafx.h"
    int main(int argc, char* argv[])
    {
        int x = 1;
        printf("x的地址:%x\n",&x);
        *(int*)0 = 123;
        printf("0地址数据:%d\n",*(int*)0);
        return 0;
    }
我们要做的就是将线性地址0的物理页挂载到局部变量x的物理页，让两个PTE指向的是同一个物理页。
还是先找到当前进程的cr3。
获取x的线性地址：0x0012ff7c，并对其经行分解。
然后找到其对应的物理地址
    kd> !dd 1a9e9000 + 0
    kd> !dd 1a9b4000 + 4BC
    kd> !db 1a790000 + f7c
让线性地址0的PTE指向同一块物理地址。
如果线性地址为0，那么他就没有PTE，所以这里要写一个PTE。
    kd> !dd 1a9b4000
由于二级偏移也是0，那么这里就把二级偏移直接写成物理页的首地址。也就是1a790067。
    kd> !ed 1a9b4000 1a790067
回到程序重新执行，在线性地址0的位置已经写入了123。
此时用图形化表示为：
## PDE&PTE属性
PDE和PTE的低12位实际上是表明属性，这个在之前的练习中已经了解过了。
###  物理页的属性
物理页的属性 = PDE属性 & PTE属性
P位和段的P位是一样的，表示当前PDE或者PTE是否有效，所以PDE与PTE的P位 P=1 才是有效的物理页。
####  R/W属性
R/W位表示是否是可读可写的。R/W = 0 只读，R/W = 1 可读可写，只有当PDE和PTE的R/W位都为1的时候，该物理页才是可读可写的。
观察下面一段代码：
    #include "stdafx.h"
    #include 
    int main(int argc, char* argv[])
    {
        char* str = "Hello World";
        printf("线性地址:%x\n",str);
        getchar();
        DWORD dwVal = (DWORD)str;
        *(char*)dwVal = 'M';
        printf("%s",str);
        return 0;
    }
直接执行是会报错的，因为str指向的是常量区中的一个字符串，这是不可以写的，但是如果我们更改物理页对应的PDE和PTE的R/W属性，则可以成功改写。
直接执行Access Violation。
拆分线性地址：
通过Cr3找到PTE，发现最后12位属性中R/W位为0。(属性为025)
那么这里就需要让R/W位为1，属性变为027。
    !ed 30b4088 19c48027
代码能够顺利执行，字符串成功被修改。
####  U/S属性
  * U/S = 0 特权用户
  * U/S = 1 普通用户
特权用户也就意味着只有高权限才能访问，普通用户普通权限即可访问。
观察这样一段代码，直接访问肯定是失败。
    int main(int argc, char* argv[])
    {
        PDWORD p = (PDWORD)0x8003F00C;
        getchar();
        printf("高2G地址：%x\n",*p);
        return 0;
    }
我们三环程序是无法直接访问高两G内存空间的，这里可以用之前的调用门提权访问，也可以通过修改页属性来访问。
这里具体细节和上面修改R/W差不多。
可以发现这个地址的PDE和PTE的U/S位都是0。
    kd> !ed 1d50a800 0003b167
    kd> !ed 3b0fc 0003f167
> 这里一不小心把程序放过去了，直接结束了没截图，并没有报错，也就不重新做这个实验了。
####  P/S位