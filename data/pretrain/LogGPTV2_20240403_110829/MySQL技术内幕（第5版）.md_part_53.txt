符或字节来创建索引。）
这样的集合即为“最左前缀”。（这与对列的前缀进行索引有所不同，它会使用列值的前n个字
的索引。复合索引相当于多个索引，因为索引中最左边的任意数据列集合都可用于匹配各个行。
体语法请参考2.6.4.2节。
列的第一个字符恐怕不行，因为这样做会导致索引无法获得大量的唯一值。
个列进行索引。而只为前面的10或20个字符进行索引，这样可以节省大量的索引空间，而且
有一个CHAR（200）列，如果大多数值的前10个或20个字符都是唯一的，那么就可以不用为整
如果主键值较长，则会导致每一个二级索引需要占用更多的存储空间。
级
带来更多好处。聚簇索引会把数据行和主键值存储在一起（即聚集在一起)。其他的索引都是二
CHAR（100）。较短小的值可以在以下几个方面提高索引的处理性能。
需要存储的数据时，就不要选用BIGINT；如果值的长度都不会超过25个字符，那么就不要用
询优化程序确定出某个值在表的行里出现频率很大时，它会跳过索引，转去执行全表扫描操作。
搜索哪个值，你得到的都是近乎一半的行。在这种情况下，索引可能根本无法使用。因为当查
例如，某个列包含值1、3、7、4、7、3，那么它的基数为4。相对于表里行的总数来说，列的
使用多个连接列来优化查询，那么它不会使用全表扫描，从而大大减少潜在的“表-行”组合。
都是特别好的索引候选列。在上面的查询里，col_b 和 col_c 都是这种例子。如果 MySQL 能
可
表里出现的列自已并不足以说明它应该被索引。
204
盘IO操作，加快索引速度。）当然，你可能会想继续沿用某些惯用做法。不过，只索引数据
能使查询变得更快。（对较短小的值进行索引，可以获得上一条指导中描述过的好处，即较少
假设有一个表，它拥有一个多个列的复合索引l，这些列的名字分别为country、state 和
后再通过它定位到相应的行。这意味着，主键值在每一个二级索引里都会重复出现。因此，
索引，即它们把主键值和二级索引值存储在一起。在二级索引里进行查找，会先得到主键值，
两个值一
年龄值的列，索引可以很容易地将各个行区分开来。但是对于记录性别的列，其中只会
数越高（也就是说
（5）利用最左前缀。当创建包含n个列的复合索引时，实际上会创建n个专供MySQL使用
（4）索引字符串值的前缀。想要对字符串列进行索引，应当尽可能指定前缀长度。例如，你
（2）认真考虑数据列基数。
出现在连接子句中的列，或者出现在 WHERE 子句中形如col1=Co12的表达式里的列，
对InnoDB存储引擎，因为它使用的是聚簇索引（clusteredindex），所以让主键尽量短小会
口短小值可以让比较操作更快，从而加快索引查找速度。
（3）索引短小值。应尽量选用较小的数据类型。例如，当使用MEDIUMINT列便足以容纳你
当然，输出显示的列与WHERE子句里使用的列可能是相同的。重点在于，那个输出列的列
口短小值可以让索引短小，从而减少对磁盘IO请求。
几率。
同时容纳更多的键，那么就可以在不从磁盘读取更多索引块的前提下，提高找到键值的
对于更短小的键值，键缓存里的索引块可以容纳更多的键值。如果MySQL 能在内存里
第5章查询优化
102
一'M'和·F'，索引操作毫无用处。如果这两个值出现的频率大致一样，那么不管
+
说，它包含的唯一值多，重复值少），索引的使用效果越好。对于包含许多不
。列的基数（cardinality）是指它所容纳的所有非重复值的个数。
整
包
---
## Page 225
索引定义里加上USINGBTREE。例如：
MEMORY表来进行范围比较，那么请改用B 树索引。如果想要指定这种类型的索引，可以在
这也是MEMORY表的默认索引类型，因此不需要做什么特别的事情。如果通常是使用
比较操作。
许你在这两者之间进行选择。在选择索引类型时，请考虑计划在索引列上执行的是什么类型的
型则会改用R树索引。MEMORY存储引擎默认会使用散列索引，但它也支持B树索引，并允
的索引实现。例如，InnoDB总会使用B树索引。MyISAM也会使用B树索引，但对于空间类
它们必须拥有单独的索引。
索引，就没有意
有索引的最力
免造成这样的错误，请维护好那些真正需要的索引。
成执行计划时，MySQL会对索引进行仔细推敲。创建多余的索引，会为查询优化程序增加更多
占用的时间就越长。很少使用或从不使用索引，会大大降低表的修改速度。此外，在为检索！
作的性能。在
都建立索引。前面提到过，每增加一个索引都需要占据额外的磁盘空间，而且都会影响写入操
的组合。
用索引找到那些与州匹配的行可以缩小MySQL搜索的范围，但是该索引还是不能用于这些值
引。如果要搜索某个给定的州和某个特定的市（该索引的第1个列和第3个列)，那么，尽管使
的
面几种列组合：
者只指定了country 值和 state 值，MySQL也可以充分利用索引。因此，索引可用于搜索下
顺序排序，然后再按 country 进行排序。这意味着，即使在查询里只指定了 country 值，或
（7）让参与比较的索引类型保持匹配。在创建索引时，大部分存储引擎都会选择它们要使用
如果你正在孝
工作。当表有太多的索引时，MySQL还有可能（只是存在可能）无法使用最好的索引。为避
如果只是为了精确查找才使用MEMORY表，那么使用散列索引则会是一个不错的选择。
（6）不要建立过多的索引。不要以为索引“越多越好”，
CREATE TABLE lookup
口对于散列索引，会有一个散列函数应用于每一个列值。最终的散列值都会被存入索
对于没有包含最左边前缀的那些搜索，如按照 state或city来搜索，MySQL无法使用索
Country
Country,
Country, State,city
开头的，那么B树索引还可用在使用运算符LIKE进行模式匹配的操作里。
使用B 树索引会带来高效。如果匹配模式是以一个纯字符串，而不是一个通配符作为
weightBETWEEN 100 AND150
id完成精确匹配的比较操作里，散列索引的速度非常快。但在那些用于查找一个范围
值。使用散列值的好处是它们之间的比较比其原始值更有效率。）在使用运算符=或
引，用于执行查找。
name
id
左前缀。如果是这样，那么就不用再费心思去添加它，因为，事实上，你已有了这
在对表做了修改之后，索引就会更新，并且可能还会重组，索引越多，整个过程
意义了。但FULLTEXT索引是一个例外，对于想要搜索的每一个不同的列集合，
State
考虑要为某个有索引的表添加索引，那么请考虑这个需要添加的索引是否是已
CHAR(20),
INT NOT NULL,
有一个对country、state 和city 的索引，那么再添加一个对country 的
（散列函数实现的算法，会尽量为不同的输入值生成不同的散列
<>、
！=和BETWEEN运算符，
”，然后就为你所能看到的所有数据列
，进行精确比较或范围比较时，
5.1使用索引
205
所
---
## Page 226
们返回的具体内容。
查询的一部分：在对主 SELECT 语句进行分析之前，EXPLAIN必须先执行子查询，才能知道它
与DELETE、
如何执行的（并非实际执行）相关信息显示出来。（自MySQL5.6.3开始，也可以将EXPLAIN
不会去搜索表。通过执行EXPLAIN语句，可以看到这一点。该语句会告知MySQL，把SELECT
果调用下面这条查询语句，那么不管表有多大，MySQL都能执行得很快：
S
的查询在这个日志里频繁出现，那么这个查询可能就不是最优的，需要改写，以让它运行得更
的查询。（更多与MySQL日志有关的讨论请参考12.8节。）慢查询日志是一个文本文件，它可
度
务
了在该列使用索引的可能性。
行比较，那么对列进行索引就毫无价值。服务器必须为每一个行计算一次函数值，这样就排除
树索引，甚至可以对同一列进行索引。
206
 NULL 值。具体来讲，这些信息会包括将用于扫描各个表的索引、将要用到的连接类型，以
度。本节将讨论查询优化程序是如何工作的。更多与MySQL所采用的优化度量方法有关的资
决
在某些情形下，如果某个查询的 FROM子句里包含了子查询，那么 EXPLAIN会先执行这个
2
器处于高负载时，会往慢查询日志里写入更多的查询。
用任何文件显示程序打开查看，也可以用mysqldumpslow工具来汇总其内容。如果某个给定
当然，MySQL的查询优化程序会充分利用索引，但它同时也会利用其他的信息。例如，如
（8）利用慢查询日志找出那些性能低劣的查询。这个日志可以帮助我们找出从索引当中获益
通常情况下，EXPLAIN语句返回的信息比上面的多，包含信息更为丰富的值，而非只是一
possible_keys:
有些类型的比较操作不能使用索引。如果只是通过把列值传递给STRCMP（)那样的函数来进
mysql> EXPLAIN SELECT * FROM tbl_name WHERE FALSE\G
要使用EXPLAIN，
在这个示例里，MySQL会检查WHERE子句，并发现没有符合查询条件的行，
SELECT * FROM tbl_name WHERE FALSE;
当你调用语句时，MySQL会先对它进行分析，判断出可以使用哪些优化操作来加快处理速
如果所用的搜索类型允许，那么可以让一个MEMORY表同时拥有一个散列索引和一个 B
MySQL查询优化程序
)ENGINE=MEMORY;
第5章查询优化
PRIMARY KEY （id)USING BTREE
key_len:
、INSERT、REPLACE和UPDATE语句一起使用。）
Extra:
￥***
type:
ref:
key:
id:
。（自MySQL5.6.3开始，不会再出现这种行为。）
Impossible
NULL
NULL
NULL
NULL
NULL
NULL
NULL
SIMPLE
，只需将单词EXPLAIN放在SELECT语句的前面即可。
****
WHERE
￥
***
，因此根本就
---
## Page 227
句里。下面两条语句完全等效：
与查询列的列表之间，对语句里的所有连接都起作用，具有全局效果。第二个地方在FROM
你就能越早地缩小可能的候选行范围。
也就是说，对表进行排序，让那个能使查询出的行数最小的表，排在最前面。查询性能越好，
列顺序进行连接。
化程序的选择。带有STRAIGHT_JOIN的连接操作，会强制各个表按照它们在FROM子句里的排
优化
MySQL优化程序会自行确定各个表的扫描顺序，以求用最快的速度把各个行检索出来。有时，
息请参考附录E。
FORCE INDEX、USE INDEX 或 IGNORE INDEX，以告知服务器期望使用哪些索引。更多相关信
令的执行效率是否会有所改善时，这类信息可以派上用场。
用到。当你尝试使用各种不同的办法来编写某一条语句时，或者很想知道增加索引对于查询命
经常会
TABLE
引里的键值都是均匀分布的。当在判断索引是否应该与常量进行比较时，优化程序还会对索引
估索引效率。默认情况下，当把索引列里的值与某个常量进行比较时，优化程序会假设相关索
求。量
个行进行检查
果首先测试co12列，得到300个行，那么为找到与col1列相匹配的那30个行，只需对这300
列相匹配的那30个行，也必须对这900个行进行检查。也就是说，会有870个行测试失败。
时测试这两个列，会匹配到30个行。如果首先测试co11列，得到900个行，那么为找到与col2
询需要对两个列进行测试，那么它们当中的每一个都会有一个索引：
越快。如果首先执行最严格的条件测试，那么查询处理的速度也会更快一些。假设，有一个查
除行，是因为从搜索范围中排除行的速度越快，那么找到那些与搜索条件匹配的行的速度也会
SELECT语句的目标是要找到行，而不是要排除它们。相比之下，查询优化程序之所以要尽力排
来消除对行数量随时可能快速增加的顾虑。其中最后那个观点，听起来有悖常理。毕竟，调用
5.2.1
在 SELECT 语句里，有两个地方可以指定 STRAIGHT_JOIN。第一个地方在 SELECT关键字
如果真想这么做，那么可以尝试把各个表排列好，从而达到优先执行最严格查询的目的。
也可以通过
（3）在必要时给予优化程序提示或改写它。在连接操作的表列表里，可以在表名的后面加上
（2）使用EXPLAIN验证优化程序的操作。使用EXPLAIN 语句可以了解到各个索引是否会被
如果表在填充好数据之后一直未被改动，那么只需在加载后对它做一次分析即可。如果表
一定要对比试试有和没有 STRAIGHT_JOIN 的情况。MySQL可能有更好的理由，不按你认
SELECT...FROM t1 STRAIGHT_JOIN t2 STRAIGHT_JOIN t3...
再假设，对col1列的测试会匹配到900个行，对co12 列的测试会匹配到300个行；而
查询优化程序有几个目标，但是其主要目标是：尽可能使用索引，并且使用最严格的索
SELECT STRAIGHT_JOIN
程序做出的选择不是最优的。如果遇到此种情况，可以用STRAIGHT_JOIN关键字来改写优
会被更新，则应该间歇性地（与数据的更新频率保持一致）对它进行分析。
（1）分析表。这将生成关于键值分布情况的统计数据，它们可以帮助优化程序更准确地评
下面描述的这些指导意见，有助于优化程序对索引的充分利用。
最终，查询优化程序会首
WHERE col1 ='some value' AND col2 =some other value';
SELECT col3 FROM mytable
查询优化程序的工作原理
句告知服务器执行键值分析。
查。也就是说，只有270个行会测试失败，从而减少了对计算和磁盘I/O操作的需
STRAIGHT_JOIN强制要求优化程序按特定的顺序使用各个表。
首先检验col2，因为这样做的工作量更少。
FROM t1 INNER JOIN t2 INNER JOIN t3..;
5.2MySQL查询优化程序
一般情况下
207
同
---
## Page 228
如果想要把无论是否出现在该列里的所有字符串都找出来，那么用这个子句是正确的。但不要
date_col列的值进行比较，而无需再转换成具体的天数。在此情况下，索引即可派上用场。
以在执行查询之前，被一次性地计算成一个常量，但是该值现在是一个日期。它可以直接上
列仍然会出现在函数调用里，阻止索引的使用。第三行是最好的。同样地，表达式右边的值
式右边的值可以在处理查询之前由优化程序一次性计算出来，而不用逐行计算。但是date_col
的值。第
中的3种：
以内的行找出来。有多种方式可以表达这种类型的比较操作，
这个表达式不会把1990与索引列进行比较；它会把1990与根据该列计算出来的那个值进行比
的查询，那么索引将不会被用到：
了那些小于2的值。因
此情况下，不会使用索引。因为必须检索列中的每一个值，才能计算出比较操作中左侧表达式
过
较
对于第一行，MySQL必须检索每一个行的mycol值，然后乘以2，再将结果与4进行比较。在
值。虽然有时这是无法避免的，但是在许多情况下，你都可以改写查询，让这个索引列单独出现。
杂算术表达式中的一部分，那么MySQL将不会使用该索引，因为它必须计算每一个行的表达式