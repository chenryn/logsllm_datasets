# Linux 内核安全机制总结
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
之前面试被问到了内核安全机制的相关问题，但是没有很好的回答出来，所以在此以学习的目的总结这方面的知识。欢迎各位师傅一起交流讨论。
## 防御框架
说到Linux内核防御就不得不提起那张广泛流传的`Linux Kernel Defence
Map`。这里放出两个不同版本的对比图，可以看到新版本中又对老版本的地图做了一些修改和添加。新图在老图的基础上修改了一些语言描述，并且调整了排列顺序，增加了ARM，Intel的硬件防护，clang的CFI，PAX_RAP。所以这里我会按照新图的顺序来讲解。
这个地图把Linux内核的防御相关内容划分成了八种不同的类别，这里简单介绍一下：
  * 绿色标记：Linux内核的主线防御
  * 白色标记：通用防御技术
  * 深蓝色标记：主线不支持的防御
  * 紫色标记：bug检测
  * 灰色标记：商用防御
  * 粉色标记：漏洞
  * 浅蓝色标记：硬件防御
  * 黄色标记：利用技术
防御方面会总结Linux的主线防御，商用防御和硬件防御，主线不支持的防御将不会出现。
## 防御技术
###  RANDSTRUCT
它是作为一个GCC的插件，能够随机化C写的结构体布局，这个选项开启的时候会把内核中的结构体字段重新排列。这个重新排列的过程发生在编译期间，插件会获得一个随机种子，根据这个来重新排列结构体字段，使得攻击者无法精确知道结构体对应位置的字段。因此，提高了漏洞利用的难度。
参考：
###  LATENT_ENTROPY
GCC的插件之一，这个插件为了缓解内核在启动和启动之后生成加密密钥的熵太少的问题。这个插件会把随机值混入到有`__latent_entropy`属性标记的函数中的`latent_entropy`全局变量中。这个全局变量的值会被加入到内核熵池中用来增加熵。
参考：
###  PAX_RANDKSTACK
由PaX
Team实现的`PAX_RANDKSTACK`是针对进程内核栈的随机化。由于内核栈本身的实现，内核中是可以任意访问没有任何防护的。随机化对栈布局的打乱，配合内核栈信息的擦除，能够有效防止内核信息泄漏，不容易猜透内存的布局。
实现总结：
  1. pax_randomize_kstack的实现。这个函数读取时钟（随机数）对进程内核栈基址进行掩码异或，获取有随机化偏移的栈基址，赋值给相应的内核结构，栈增长时就会基于这个随机化地址。
  2. 在相应的系统调用入口处插入随机化的函数。因为进程内核栈的使用是通过进程触发系统调用（当然还有异常和中断），陷进内核，来切换到进程内核栈，随机化应该在这些地方插入执行。而它放置的位置是在系统调用返回之前。
  3. 配合性地，PaX 实现了 pax_erase_kstack 函数，在内核/用户空间切换的时候进行内核信息抹除，填充。
参考：
###  __ro_after_init
为了减少内核中的攻击面，会标记内核的一部分为只读内容。内核在初始化过程中会写入一些内容，但在初始化之后这部分内容确定为只读作用，这种情况下我们不能使用const，因为实际上它是有写入修改的，所以就诞生了`__ro_after_init`。它会在内核初始化完成之后把这些内存区域标记为只读。
参考：
###  PAX_CONSTIFY_PLUGIN
为了缓解修改函数指针劫持控制流的攻击方式而推出的GCC插件。它会使得所有的函数指针的结构体都变为只读。
参考：
###  PAX_SIZE_OVERFLOW
用于检测溢出用的GCC插件，它会用double类型大小的数据结构来保存size表达式的计算结果，然后拿这个结果和实际的输出大小作比较，以此来检查溢出的情况。但是，这个检测不会针对整个源码，只会对一些特定的地方做检查，比如内存分配的时候错误的大小导致的缓冲区溢出。也可以对一些地方做标记，跳过对它们的溢出检查。
参考：
###  REFCOUNT_FULL
这个是一个针对引用计数的溢出保护，在对引用计数操作的函数中添加指令检测refcount是否为负。如果没有这个保护，内核对象引用计数不断增加，当发生溢出时，引用计数为负数，内存即可被释放，而此时程序还有对该指针所值内存的引用，就有可能发生`use
after free`，可以用做攻击利用。
参考：
类似的保护`PAX_REFCOUNT`
参考：
###  TIF_FSCHECK flag
一些执行路径会临时升高`addr_limit`，为了内核代码能够像读写用户内存一样读写内核内存，但如果就这样返回到用户态，那么在用户态就可以读写到内核内存，所以这个标志位会在返回用户态时检查`addr_limit`的值。对任何调用了`set_fs()`都会设置线程标记`TIF_FSCHECK`。
参考：
###  SCHED_STACK_END_CHECK
这个选项是为了检查在调用`schedule()`时的栈溢出情况。如果栈结束的位置发现被覆盖，那么这些被覆盖区域的内容是不可信的。这是为了确保不会发生错误行为，被覆盖区域如果执行可能会在后续阶段出现数据损坏或崩溃。这个检查的运行时开销很小。
参考：
###  GRKERNSEC_KSTACKOVERFLOW
Grsecurity 的 KSTACKOVERFLOW 特性是针对进程内核栈溢出的一些加固措施，主要包括：
  * 进程内核栈初始化时的`vmap`与 `thread_info`的分离
  * `double_fault` 中 `Guard page` 的检测
  * 一些指针的检查
  * 一些配合性的初始化
参考：
以下是另外两个相关的防御机制
####  VMAP_STACK
这个机制是采用vmalloc申请的内存作为内核栈，这样可以利用vmalloc自带的`guard
page`增强栈溢出检测能力，同时这些申请的内存空间在物理上可能是不连续的，能够减少内存的碎片化。
参考：
####  THREAD_INFO_IN_TASK
这个选项开启的时候会把`thread_info`放入到`task_struct`中，在原来的结构中`task_struct`和`thread_info`是分开的，这个`thread_info`位于线程栈的最低地址处，但又比`task_struct`地址高，所以如果发生溢出会使得`thread_info`的数据结构被破坏，不会被判断为栈溢出。
    union thread_union {
    #ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK
        struct task_struct task;
    #endif
    #ifndef CONFIG_THREAD_INFO_IN_TASK
        struct thread_info thread_info;
    #endif
        unsigned long stack[THREAD_SIZE/sizeof(long)];
    };
参考：
###  HARDENED_USERCOPY
这个安全机制是从`PAX_USERCOPY`中借鉴学习的。Linux内核的设计中，内核地址空间和用户地址空间是隔离的，不能直接透过地址去访问内存。因此，当需要发生用户空间和内核空间进行数据交换时，需要将数据拷贝一份到另一个的内存空间中。在内核中
copy_from_user 和 copy_to_user
这组函数承担了数据在内核空间和用户空间之间拷贝的任务。这就带来一个问题，如果从用户空间拷贝到内核空间的数据长度超过内核的缓冲区长度，就会产生溢出破坏内核的空间数据导致有漏洞利用的可能。`HARDENED_USERCOPY`在这组函数中实现了对缓冲区长度的检查，当长度检查发现有溢出的可能时，就不会执行数据的复制，防止非法拷贝覆盖内存，破坏栈帧或堆。
参考：
###  STACKLEAK
这个机制的出现时为了缓解内核栈的溢出和泄露类型的漏洞。主要作用：
  * 减少内核栈信息泄露漏洞能泄露的信息
  * 阻止一些未初始化栈变量攻击
  * 检测进程内核栈的溢出
整体的实现方法借鉴了`PAX_MEMORY_STACKLEAK`，一个是实现了再进出内核空间时对进程内核栈的数据进行擦除，这样就算有泄露信息的漏洞也只能得到无效数据；另外一个用于检测栈溢出的功能可以与`VMAP_STACK`和`THREAD_INFO_IN_TASK`搭配。
参考：  
###  slub_debug
####  Z（Red Zone）
Red zone出现在内存分配对象的后面，以及后一个对象的前面，用于检测越界访问的问题，在这里面会填充`magic num`，之后检测Red
zone区域数据就能够判断是否发生溢出。
####  F（free）
激活完整性检查功能，在特定的环节比如free的时候增加各种条件判断，验证数据是否完好。可以用来检测多次free的情况。
####  P（Posion）
当对象被新分配的时候回被填充特殊的`magic num
0x5a`，这时出现对象使用就会触发未初始化使用的错误，而在对象释放之后会被填充`0x6b`，这时如果对象被使用就会触发`use after
free`的漏洞检测。
    #define POISON_INUSE         0x5a    /* for use-uninitialised poisoning */
    #define POISON_FREE          0x6b    /* for use-after-free poisoning */