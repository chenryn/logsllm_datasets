very small time difference and thus the conditional en-
tropy of the target user’s password reset token given
the attacker’s token will be small. Thus, the attacker
can generate a token for an account he owns and in
fast succession a token for the target account. Then
the microtime() used for generating the token of his
account can be used to approximate the microtime()
output that was used for the token of the target account.
Experiments. We conducted a series of experiments
for both our algorithms using the following setup. We
created a PHP “time” script that prints out the current
seconds and microseconds of the server. To evaluate
the ATS algorithm we ﬁrst performed synchronization
between a client and the server and afterwards we sent
a request to the time script and tried to predict the value
it would return. To evaluate the Request Twins algo-
rithm we submitted two requests to the time script in
fast succession and measured the difference between
the output of the two responses.
In Figure 3 we show the time difference between
the server’s time and our client’s calculation for four
servers with different CPU’s and RTT parameters. Our
experiments suggest that both algorithms signiﬁcantly
reduce the entropy of microseconds (up to an average
of 11 bits with ATS and 14 bits with Request Twins)
having different advantages each. Speciﬁcally, the
ATS algorithm seems to be affected by large RTT val-
ues while it is less affected by differences in the CPU
speed. The situation is reversed for Request Twins
where the algorithm is immune to changes in the RTT
however, it is less effective in old systems with low
processing speed.
4
Seed Attacks
In this section we describe attacks that allow either the
recovery or the reconstruction of the seeds used for the
PHP system’s PRNGs. This allows the attacker to pre-
dict all future iterations of these functions and hence
reduces the entropy of functions rand(),mt rand(),
lcg value() as well as the extra entropy argument
of uniqid() to zero bits. We exploit two properties
of the seeds used in these functions. The ﬁrst one is
the reusage of entropy sources between different seeds.
This enables us to reconstruct a seed without any ac-
cess to outputs of the respective PRNG. The second is
the small entropy of certain seeds that allows one to
recover its value by bruteforce.
We present three distinct attacks. The ﬁrst attack al-
lows one to recover the seed of the internal LCG seed
used by the PHP system using a session identiﬁer. Us-
ing that seed our second attack reconstructs the seed of
rand() and mt rand() functions from the elements
of the LCG seed without any access to outputs of these
4
Conﬁguration
CPU(GHz) RTT(ms) min
1× 3.2
0
4× 2.3
5
1× 0.3
53
2× 2.6
73
1.1
8.2
9
135
ATS
max
4300
76693
39266
140886
avg
410
4135
2724
83573
Req. Twins
min
0
565
1420
2
max
1485
1669
23022
1890
avg
47
1153
4849
299
Figure 2: ATS.
Figure 3: Effectiveness of our time entropy lowering techniques against four servers
of different computational power and RTT. Time measurements are in microseconds.
functions. Finally, we exploit the fact that the seed
used in these functions is small enough for someone
with access to the output of these functions to recover
its value by bruteforce.
Generating fresh processes. Our attacks on this sec-
tion rely on the ability of the attacker to connect to a
process with a newly initialized state. We describe a
generic technique against mod php in order to achieve
a connection to a fresh process. Recall that in mod php
when the number of occupied processes passes a cer-
tain threshold new processes are created to handle the
new connections. This gives the attacker a way to force
the creation of fresh processes: The attacker creates a
large number of connections to the target server with
the keep-alive HTTP header set. Having occupied a
large number of processes the web server will create
a number of new processes to handle subsequent re-
quests. The attacker, keeping the previous connections
open, makes a new one which, given that the attacker
created enough connections, will be handled by a fresh
process.
4.1 Recovering the LCG seed from Ses-
sion ID’s
In this section we present a technique to recover the
php combined lcg() seed using a PHP session iden-
tiﬁer. In PHP, when a new session is created using the
respective PHP function (session start()), a pseu-
dorandom string is returned to the user in a cookie, in
order to identify that particular session. That string is
generated using a conjuction of user speciﬁc and pro-
cess speciﬁc information, and then is hashed using a
hash function which is by default MD5, however there
is an option to use other hash functions such as SHA-1.
The values contained in the hash are:
Client IP address (32 bits).
A time measurement: Unix epoch and microsec-
onds (32 + 20 bits).
A value generated by php combined lcg() (64
bits).
Notice now that in the context of our attack model
the attacker controls each request thus he knows ex-
actly most of the values. Speciﬁcally, the client IP ad-
dress is the attacker’s IP address and the Unix Epoch
can be determined through the date HTTP header. In
addition, if php combined lcg() is not initialized at
the time the session is created, as it happens when a
fresh process is spawned, then it is seeded. The state
of the php combined lcg() is two registers s1, s2 of
size 32 bits each, which are initialized as follows. Let
T1 and T2 be two subsequent time measurements. Then
we have that
s1 = T1.sec⊕ (T1.usec (cid:28) 11) and s2 = pid⊕ (T2.usec (cid:28) 11)
where pid denotes the current process id, or if threads
are used the current thread id 2.
Process id’s have a range of 215 values in Linux
systems In Windows systems the process id’s (resp.
threads) are also at most 215 unless there are more
than 215 active processes (resp. threads) in the system
which is a very unlikely occurence.
Observe now that the session calculation involves
three time measurements T0, T1 and T2. Given that
these three measurements are conducted succesivelly
it is advantageous to estimate their entropy by examin-
ing the random variables T0,∆1 = T1−T0,∆2 = T2−T1.
We conducted experiments in different systems to es-
timate the range of values for ∆1 and ∆2. Our exper-
iments suggest that ∆1 ∈ [1,4] while ∆2 ∈ [0,3]. We
also found a positive linear correlation in the values of
the two pairs. This enables a cutdown of the possible
valid pairs. These results suggest that the additionally
entropy introduced by the two ∆ variables is at most 5
bits.
To summarize, the total remaining entropy of the
session identiﬁer hash is the sum of the microseconds
entropy from T0 (≈ 20 bits) the two ∆ variables (≈
5 bits) and the process identiﬁer(15 bits). These give
a total of 40 bits which is tractable cf. section 1.1.
Furthermore the following improvements can be made:
(1) Using the ATS algorithm the microseconds entropy
can be reduced as much as 11 bits on average. (2) The
attacker can make several connections to fresh pro-
cesses instead of one, in rapid succession, obtaining
2In PHP versions before 5.3.2 the seed used only one time mea-
surement which made it even weaker.
5
session identiﬁers from each of the processes. Because
the requests were made in a small time interval the
preimages of the hashes obtained belong into the same
search space, thus improving the probability of invert-
ing one of the preimages proportionally to the number
of session identiﬁers identiﬁers obtained. Our experi-
ments with the request twins technique suggest that at
least 4 session identiﬁers can be obtained from within
the same search space thus offering a reduction of at
least two bits. Adding these improvements reduces the
search time up to 227 MD5 computations.
4.2 Reconstructing the PRNG Seed from
Session ID’s
In this section we exploit the fact that the PHP system
reuses entropy sources between different generators, in
order to reconstruct the PRNG seed used by rand()
and mt rand() functions from a PHP session identi-
ﬁer. In order to predict the seed we only need to ﬁnd
a preimage for the session id, using the methods de-
scribed in the previous section. One advantage of this
attack is that it requires no outputs from the affected
functions.
When a new process is created the internal state of
the functions rand() and mt rand() is uninitialized.
Thus, when these functions are called for the ﬁrst time
within the script a seed is constructed as follows:
seed = (epoch× pid)⊕ (106× php combined lcg())
where epoch denotes the seconds since epoch and pid
denotes the process id of the process handling the re-
quest. It it easy to notice, that an attacker with access to
a session id preimage has all the information needed in
order to calculate the seed used to initialize the PRNGs
since:
is
known
seed
from the
epoch is obtained through the HTTP Date header.
pid
of
the
php combined lcg() obtained
the
through
preimage of the session id from section 4.1.
php combined lcg() is also known, since the at-
tacker has access to its seed, he can easily predict
the next iteration after the initial value.
In summary the technique of this section allows the re-
construction of the seed of the mt rand() and rand()
functions given access to a PHP session id of a fresh
process. The time complexity of the attack is the
same as the one described in section 4.1 while the
query complexity is one request, given that the attacker
spawned a fresh process (which itself requires only a
handful of requests).
4.3 Recovering the Seed from Applica-
tion leaks
In contrast to the technique presented in the previous
section, the attack presented here recovers the seed of
6
the PRNG functions rand() and mt rand() when the
attacker has access to the output of these functions. We
exploit the fact that the seed used by the PHP system is
only 32 bits. Thus, an attacker who connects to a fresh
process and obtains a number of outputs from these
functions can bruteforce the 32 bit seed that produces
the same output.
We emphasize that this attack works even if the out-
puts are truncated or passed through transformations
like hash functions. The requirements of the attack is
that the attacker can deﬁne a function from the set of
all seeds to a sufﬁciently large range and can obtain a
sample of this function evaluated on the seed that the
attacker tries to recover. Additionally for the attack to
work this function should behave as a random map.
Consider the following example. The attacker has
access to a user account of an application which gen-
erates a password reset token as 6 symbols where each
symbol is deﬁned as g(mt rand()) where g is a ta-
ble lookup function for a table with 60 entries contain-
ing alphanumeric characters. The attacker deﬁnes the
function f to be the concatenation of two password re-
set tokens generated just after the PRNG is initialized.
The attacker samples the function by connecting to a
fresh process and resetting his password two times.
Since the table of function g contains 60 entries, the
attacker obtains 6 bits per token symbol, giving a total
range to the function f of 72 bits.
The time complexity of the attack is 232 calculations
of f however, we can reduce the online complexity
of the attack using a time-space tradeoff. In this case
the online complexity of the attack can be as little as
216. The query complexity of the attack depends on
the number of requests needed to obtain a sample of
f . In the example given above the query complexity is
two requests.
5
State recovery attacks
One can argue that randomness attacks can be easily
thwarted by increasing the entropy of the seeding for
the PRNG functions used by the PHP system. For ex-
ample, the suhosin PHP hardening extension replaces
the rand() function with a Mersene Twister generator
with separate state from mt rand() and offers a larger
seed for both generators getting entropy from the oper-
ating system3.
We show that this is not the case. We exploit the
algebraic structure of the PRNGs used in order to re-
cover their internal state after a sufﬁcient number of
past outputs (leaks) have been observed by the attacker.
Any such attack has to overcome two challenges. First,
web applications usually need only a small range of
3The suhosin patch installed in some Unix operating systems
by default does not include the randomness patches, rather than it
mainly offers protection from memory corruption attacks. The full
extension is usually installed separately from the PHP packages.
lowing range for possible values for n:
(cid:98) (l − a)· M
b− a + 1
(cid:99) ≤ n ≤ (cid:98) (l − a + 1)· M
b− a + 1
(cid:99)− 1
Therefore, given a bucket number l we are able to
ﬁnd an upper and lower bound for the original number
denoted respectively by Ll and Ul. In order to recover
a part of the original number n one can simply ﬁnd the
number of most signiﬁcant bits of Ll and Ul that are
equal and observe that these bits would be the same
also in the number n. Therefore, given a bucket l we
can compare the MSBs of both numbers and set the
MSBs of n to the largest sequence of common most
signiﬁcant bits of Ll,Ul.
Notice that in some cases even the most signiﬁ-
cant bit of the two numbers are different, thus we
are be unable to infer any bit of the original number
n with absolute certainty. For example, in Figure 4
given that a number falls in bucket 3 we have that
920350134≤ n≤ 1227133512. Because 920350134  230 we are unable to infer any
bit of the original number n.
Another important observation is that this speciﬁc
truncation algorithm allows the recovery of a fragment
of the MSBs of the original number. Therefore, in the
following sections we will assume that the truncation
occurs in the MSBs and we will describe our algo-
rithms based on MSB truncated numbers. However, all
algorithms described work for any kind of truncation.
5.2 Process distinguisher
As we mentioned in section 2.1, if one wants to receive
a number of leaks from the same PHP process one can
use keep-alive requests. However, there is an upper
bound that limits the number of such requests (by de-
fault 100). Therefore, if the attacker needs to observe
more outputs beyond the keep-alive limit the connec-
tion will drop and when the attacker connects back to
the server he may be served from a different process
with a different internal state. Therefore, in order to
apply state recovery attacks (which typically require
more than 100 requests), we must be able to submit
all the necessary requests to the same process. In this
section, we will describe a generic technique that ﬁnds
the same process over and over using the PHP session
leaks described in section 4.1.
While we cannot avoid disconnecting from a pro-
cess after we have submitted the maximum number of
keep-alive requests, we can start reconnecting back to
the server until we hit the process we were connected
before and continue to submit requests. The problem
in applying this approach is that it is not apparent to
distinguish whether the process we are currently con-
nected to is the one that was serving us in the previ-
ous connection. To distinguish between different pro-
cesses, we can use the preimage from a session iden-
tiﬁer. Recall that the session id contains a value from
Figure 4: Mapping a random number n ∈ [M] to 7
buckets and the respective bits of n that are revealed
given each bucket.