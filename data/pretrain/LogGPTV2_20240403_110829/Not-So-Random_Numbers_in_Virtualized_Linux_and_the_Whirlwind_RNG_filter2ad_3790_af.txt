### Compression Function Calls and Hashing
One can utilize SHA-256 or adjust the seed values to trigger hashing more or less frequently. In our design, we select the full SHA-512 for output generation. This choice can be substituted with any suitable hash function, such as AES in Davies-Meyer mode [31].

### B. Security Evaluation
We evaluate the boot-time and reset security of Whirlwind. We conducted 50 reboots in Xen using an instrumented version of the Linux kernel with Whirlwind. Additionally, we performed 50 resets from a single Xen snapshot captured while idling (5 minutes after boot). A user-level process requests 512-bit outputs from the RNG every 500 μs after resumption. The instrumentation records all inputs and outputs to the Whirlwind RNG. We then perform a complexity analysis, similar to that for the legacy /dev/(u)random (see Section IV), which ignores all input sources except the cycle counter. This provides a conservative estimate of unpredictability from the attacker’s perspective. As intended, the adversarial uncertainty regarding the Whirlwind internal state reaches 1024 bits (the maximum amount) before the first use of the RNG during boot or after a reset. Consequently, reset vulnerabilities are mitigated: the probability of repeated output arising from the reuse of the same snapshot is negligible.

We have not yet evaluated Whirlwind's entropy accumulation on low-end systems, such as embedded systems [12, 23]. In these environments, the cycle timing loop may provide less uncertainty due to the reduced non-determinism in embedded system CPUs. However, in these settings, VM snapshots are typically not used, and we can employ the techniques described in [23] for generating entropy at boot.

### C. Performance Evaluation
We now evaluate the performance of Whirlwind, particularly in comparison to the existing /dev/(u)random and GRI RNGs. Our Whirlwind implementation uses SHA-512, which is stronger than the SHA-1 (and MD5 for GRI) used in the legacy RNGs. We expect this to result in a performance penalty due to the use of more robust cryptography.

To compare, we measured the throughput of reading from /dev/urandom and GRI for both Whirlwind and the legacy RNGs. While the system was idle, we executed reads of 10,000 blocks on the /dev/urandom interface for various block sizes using `dd`. We repeated this 100 times for each block size and reported the average throughput in Figure 9. As expected, the legacy RNG performs slightly better at smaller block sizes (≤ 16 bytes), but Whirlwind outperforms it at 64 and 256-byte block sizes.

We also compared the performance of adding inputs to the new and legacy RNGs. We added minimal instrumentation to time these operations and measured performance during VM boots, resets, and idle times. We also used these runs to measure the performance of reading from GRI. The results indicate that the various functions were timed over 100,000 times for each RNG. Input processing for /dev/(u)random is equally fast in Whirlwind as in the legacy RNG. However, the GRI output interface requires 10.3 μs (with a standard deviation of ±1.8) for Whirlwind, whereas the legacy RNG requires only 1.0 μs (±0.5).

To the best of our knowledge, GRI is primarily used during process creation. To understand whether the GRI slowdown will cause issues in applications, we ran the fork benchmark from LMbench [22] 100 times. The average latency of `fork` is 414 μs (±5 μs) for the legacy RNG and 418 μs (±5 μs) for the kernel with Whirlwind. Thus, Whirlwind incurs only a 1% overhead in this (worst-case) benchmark, indicating that this is not a significant problem for practical use.

Lastly, we evaluated the overhead of the `ww_bootstrap()` function (Algorithm 2) used at boot and snapshot resumption. The time to execute the timing loops has a mean of 0.7 ms over 50 runs. Since boot and snapshot resumption are infrequent operations, this level of overhead is unlikely to impact deployments.

Overall, we conclude that Whirlwind's performance closely matches that of existing RNGs and, in some cases, even surpasses them despite using more expensive (and more secure) cryptographic primitives. This results in a significantly simplified design and improved security.

### VIII. Conclusions
In this work, we conducted the first comprehensive analysis of the security of the Linux system random number generators (RNGs) in virtualized environments, including Xen, VMware, and Amazon EC2. Our empirical measurements suggest that cycle counters in these settings provide a reliable source of uncertainty from an attacker's perspective. However, deficiencies in the design of the /dev/(u)random RNG make it vulnerable to VM reset vulnerabilities, leading to catastrophic reuse of internal state values when generating supposedly "random" outputs. Both the /dev/(u)random and kernel-only GRI RNGs also suffer from a small boot-time entropy hole, making the very first output more predictable than it should be.

Our second main contribution is a new design for system RNGs called Whirlwind. It addresses the problems of the existing Linux RNGs while being simpler, faster, and using a sound cryptographic extraction process. We have implemented and tested Whirlwind in virtualized environments, and our results show that Whirlwind offers performance equal to, and sometimes better than, the previous RNGs, while providing enhanced security.

### VII. Related Work
Over the years, many high-profile RNG failures have been reported, including attacks against SSL implementations, online poker, insecure random values in Windows, predictable host keys in Debian OpenSSL, jailbreaks on PlayStation 3, factorizable RSA private keys on embedded systems, and predictable outputs in the OpenSSL RNG on Android. Several papers have analyzed the /dev/(u)random RNG, highlighting its complexity and potential issues in constrained environments. Dodis et al. [6] suggested that the cryptographic extraction component of RNGs should be robust, meaning an RNG should guarantee entropy collection regardless of the input stream rate. None of the above studies considered RNG performance in modern virtualized environments.

In virtualized settings, Garfinkel and Rosenblum [8] hypothesized that VM reset vulnerabilities might exist when reusing VM snapshots. Ristenpart and Yilek [26] uncovered actual vulnerabilities in user-level processes that cache randomness in memory. We answer the open question of whether system RNGs suffer from reset vulnerabilities, unfortunately, in the affirmative.