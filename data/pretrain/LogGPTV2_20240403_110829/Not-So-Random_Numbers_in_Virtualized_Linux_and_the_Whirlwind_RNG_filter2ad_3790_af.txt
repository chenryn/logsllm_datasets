compression function calls. One might also use SHA-256,
smaller or larger seed values (to trigger hashing more or less
frequently), and the like. Additionally, we choose the output
generation hash H as the full SHA-512. Again, this can be
replaced with any suitable hash function or even AES in a
one-way mode such as Davies-Meyer mode [31].
B. Security evaluation
We evaluate the boot-time and reset security of Whirl-
wind. We perform 50 reboots in Xen from a particular
using an instrumented version of the Linux kernel using
Whirlwind. We also perform 50 resets from a single Xen
snapshot captured while idling (5 minutes after boot); a user
level process requests 512-bit outputs from the RNG every
500 μs after resumption. As before,
the instrumentation
records all inputs and outputs to the Whirlwind RNG. We
then perform complexity analysis as done for the legacy
/dev/(u)random (see Section IV), which again ignores all
input sources except
the cycle counter. This provides a
conservative estimate of unpredictability from the attacker’s
perspective. As intended, the adversarial uncertainty regard-
ing the Whirlwind internal state hits 1024 (the maximal
amount) before the ﬁrst use of the RNG either during boot
or after a reset. An immediate implication is that reset
vulnerabilities are avoided: the probability of repeated output
arising from reuse of the same snapshot is negligible.
We have not yet evaluated Whirlwind’s entropy accumula-
tion on low-end systems, such as embedded systems [12,23].
In particular, here the cycle timing loop may provide less
uncertainty because embedded system CPUs themselves
have less non-determinism. In these settings, however, we
do not expect to be using VM snapshots (making this use
moot) and for generating entropy at boot we can use the
techniques of [23].
Throughput (/dev/urandom)
Block size Whirlwind (MB/s)
Legacy (MB/s)
4 bytes
16 bytes
64 bytes
256 bytes
0.6
2.3
9.3
21.8
1.6
4.9
9.0
12.0
Figure 9. Comparing performance of the Whirlwind and legacy /dev/u-
random implementations using dd to read 10,000 blocks of various sizes.
C. Performance evaluation
We turn to evaluating the performance of Whirlwind,
particularly in comparison to the existing /dev/(u)random
and GRI RNGs. Our Whirlwind implementation uses SHA-
512 as opposed to SHA-1 (resp. MD5 for GRI), so we
expect to see a performance penalty from the use of stronger
cryptography. To compare, we evaluated the throughput of
reading from /dev/urandom and GRI for both Whirlwind
and the legacy RNGs. While the system is otherwise idle,
we execute reads of 10,000 blocks on the /dev/urandom
interface for various block sizes using dd. We repeat this 100
times for each block size and report the average throughput
in Figure 9. As expected, the legacy RNG performs slightly
better at smaller block sizes (≤ 16 byte), but is outperformed
by Whirlwind at 64 and 256 byte block sizes.
We also compare measured performance of adding inputs
to the new and legacy RNGs. We add minimal instrumen-
tation to time these operations and measure performance
during VM boots, resets, and during idle time. We also use
these runs to measure performance of reading from GRI. The
resulting performance data indicate the various functions
were timed more than 100,000 times for each RNG. The
results are that while input processing for /dev/(u)random is
as fast in Whirlwind as in the legacy RNG, the GRI output
interface requires 10.3 μs (one standard deviation is ±1.8)
for Whirlwind but the legacy RNG requires only 1.0 μs
(±0.5).
To the best of our knowledge GRI is only used during
process creation. In order to understand whether the GRI
slowdown will cause problems in applications, we run the
fork benchmark from LMbench [22] 100 times. The average
latency of fork is 414 μs (with standard deviation ±5 μs)
for the legacy RNG, and 418 μs (±5 μs) for kernel with
Whirlwind. Thus Whirlwind incurs only 1% overhead in
this (worst-case) benchmark, and so we believe this is not a
problem for practical use.
Lastly, we evaluate the overhead of ww bootstrap()
(Algorithm 2) used at boot and snapshot resumption. The
time to execute the timing loops has a mean of 0.7 ms over
50 runs. Boot and snapshot resumption are rare operations,
suggesting this level of overhead will not impact deploy-
ments.
Overall we conclude that Whirlwind has performance
closely matching the existing RNGs, and in some cases
even better despite using more expensive (and more secure!)
572
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:43 UTC from IEEE Xplore.  Restrictions apply. 
suggesting that using /dev/urandom right before randomness
use is not a valid countermeasure with the existing design,
though it will be with Whirlwind.
In [28], the authors hypothesize that booting multiple
times from the same VM image in an infrastructure-as-a-
service (IaaS) setting such as Amazon’s EC2 may enable
attackers to predict /dev/(u)random RNG outputs that can
lead to SSH host key compromises. Our analyses suggest
that such an attack is infeasible for all uses of the Linux
RNGs beyond the ﬁrst during boot.
Thompson et al. [30] point out the potential for a mali-
cious hypervisor to snoop on the entropy pools of a guest
VM. Kerrigan et al. [15] investigate entropy pool poisoning
attacks, where one guest VM in a cloud setting attempts
to interfere with another’s entropy pool by (say) sending
interrupts at a known frequency to the guest. Theirs is
a negative result, with their experiments showing that the
attack fails. Our measurements corroborate this: even just
a few bits of uncertainty about cycle counters leads to an
unpredictable RNG state even in the current /dev/(u)random
implementation. We also investigate using such interrupt
injection as a defense.
Finally, we use CPU timing jitter as an entropy source as
used in other systems, such as the haveged entropy daemon
and the CPU jitter RNG [1,24].
VIII. CONCLUSIONS
In this work, we performed the ﬁrst analysis of the secu-
rity of the Linux system random number generators (RNGs)
when operating in virtualized environments including Xen,
VMware, and Amazon EC2. While our empirical measure-
ments estimate that cycle counters in these settings (whether
virtualized or not) provide a ready source of uncertainty from
an attacker’s point of view, deﬁciencies in the design of
the /dev/(u)random RNG make it vulnerable to VM reset
vulnerabilities which cause catastrophic reuse of internal
state values when generating supposedly “random” outputs.
Both the /dev/(u)random and kernel-only GRI RNGs also
suffer from a small boot-time entropy hole in which the very
ﬁrst output from either is more predictable than it should be.
Our second main contribution is a new design for system
RNGs called Whirlwind. It rectiﬁes the problems of the
existing Linux RNGs, while being simpler, faster, and using
a sound cryptographic extraction process. We have imple-
mented and tested Whirlwind in virtualized environments.
Our results showed that Whirlwind enjoys performance
equal (and sometimes even better) than the previous RNG.
cryptographic primitives. For this, we get a signiﬁcantly
simpliﬁed design and improved security.
VII. RELATED WORK
Many high proﬁle RNG failures have been reported over
the years, including ones leading to: attacks against the
Secure Socket Layer (SSL) implementation of an early
Netscape web browser [10]; the ability to cheat cheat at
online poker [2]; insecure random values in Microsoft Win-
dows [7]; predictable host keys in Debian OpenSSL [32];
jailbreaks against the Sony’s PlayStation 3 [4]; factorizable
RSA private keys generated on embedded systems [12];
predictable outputs in the OpenSSL RNG on Android [17];
and factoring RSA private keys that protect digital IDs on
government-issued smart cards in Taiwan [5].
Several
papers
the
previous
Linux
analyzed
/dev/(u)random RNG. Gutterman et al.
[11] provided
the ﬁrst: they reverse-engineer the design of the RNG from
the source code (attesting to its complexity!); highlight
problems in the hashing steps (that were subsequently
ﬁxed and the version we analyze includes these ﬁxes);
and point out that in some constrained environments such
as embedded systems or network routers there might be
insufﬁcient entropy provided to the RNG. Heninger et
al. [12] show that embedded Linux systems suffer from
a boot-time entropy hole which leads to exposure of
cryptographic secret keys generated on affected devices.
Mowery et al. [23] look to ﬁll
this boot-time entropy
hole by way of timing functions in kernel initialization.
Vuillemin et al. [9] perform an in-depth, empirical analysis
of entropy transfers in Linux /dev/(u)random, and show
that most consumers are in the kernel.
Dodis et al. [6], building off earlier work by Barak
and Halevi [3], suggest that the cryptographic extraction
component of RNGs should be robust, meaning an RNG
should guarantee entropy is collected no matter the rate of
entropy in the input stream. They show that /dev/(u)random
is not robust, but do not show attacks that would affect
practice. Part of the Whirlwind design is inspired by their
online hashing based extractor, though they use universal
hash functions and we use cryptographic ones.
None of the above consider RNG performance in modern
virtualized environments. We also do not know of any
analyses of the GRI RNG before our work.
Turning to virtualized settings, Garﬁnkel and Rosen-
blum [8] hypothesized that VM reset vulnerabilities may ex-
ist when reusing VM snapshots, and analyses by Ristenpart
and Yilek [26], uncovered actual vulnerabilities in user-level
processes such as Apache mod ssl that cache randomness in
memory before use. In these settings, the user-level process
never invoked /dev/urandom (or /dev/random) after VM
resumption, and in particular they left as an open question
whether system RNGs suffer from reset vulnerabilities as
well. We answer this question, unfortunately, in the positive,
573
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:43 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] Haveged entropy gatherer.
haveged/.
http://www.issihosts.com/
[2] B. Arkin, F. Hill, S. Marks, M. Schmid, T. J. Walls, and
G. Mc-Graw. How we learned to cheat at online poker: A
study in software security. The developer.com Journal, 1999.
[3] B. Barak and S. Halevi. A model and architecture for pseudo-
random generation with applications to /dev/random.
In
Computer and Communications Security – CCS, pages 203–
212. ACM, 2005.
[4] M. Bendel. Hackers Describe PS3 Security As Epic Fail,
Gain Unrestricted Access, 2010.
[5] D. J. Bernstein, Y.-A. Chang, C.-M. Cheng, L.-P. Chou,
N. Heninger, T. Lange, and N. van Someren. Factoring rsa
keys from certiﬁed smart cards: Coppersmith in the wild. In
Advances in Cryptology – ASIACRYPT 2013, pages 341–360.
Springer, 2013.
[6] Y. Dodis, D. Pointcheval, S. Ruhault, D. Vergnaud, and
D. Wichs.
Security analysis of pseudo-random number
generators with input: /dev/random is not robust. In Computer
and Communications Security – CCS. ACM, 2013.
[7] L. Dorrendorf, Z. Gutterman, and B. Pinkas. Cryptanalysis
of the random number generator of the Windows operating
system.
ACM Transactions on Information and System
Security (TISSEC), 13(1):10, 2009.
[16] M. Kerrisk. LCE: Don’t play dice with random numbers,
2012. https://lwn.net/Articles/525459/.
[17] S. H. Kim, D. Han, and D. H. Lee. Predictability of Android
OpenSSL’s Pseudo Random Number Generator. In Computer
and Communications Security – CCS, pages 659–668. ACM,
2013.
[18] P. Lacharme, A. Rck, V. Strubel, and M. Videau. The linux
pseudorandom number generator revisited. Cryptology ePrint
Archive, Report 2012/251, 2012. http://eprint.iacr.org/.
[19] E. Leitl. Intel In Bed with NSA. cryptome mailing list, 2013.
http://cryptome.org/2013/07/intel-bed-nsa.htm.
[20] N. Mc Guire, P. O. Okech, and Q. Zhou. Analysis of
inherent randomness of the Linux kernel. In Real Time Linux
Workshop, 2009.
[21] R. McEvoy, J. Curran, P. Cotter, and C. Murphy. Fortuna:
cryptographically secure pseudo-random number generation
in software and hardware. 2006.
[22] L. W. McVoy, C. Staelin, et al.
for performance analysis.
Conference, pages 279–294. San Diego, CA, USA, 1996.
lmbench: Portable tools
In USENIX Annual Technical
[23] K. Mowery, M. Wei, D. Kohlbrenner, H. Shacham, and
S. Swanson. Welcome to the Entropics: Boot-Time Entropy
in Embedded Devices. pages 589–603. IEEE, 2013.
[24] S. M¨uller. CPU Time Jitter Based Non-Physical True Random
Number Generator, 2013.
[8] T. Garﬁnkel and M. Rosenblum. When virtual is harder than
real: Security challenges in virtual machine based computing
environments.
In Workshop on Hot Topics in Operating
Systems – HotOS-X, May 2005.
[25] National Institute of Standards and Technology.
Federal
Information Processing Standards Publication 180-2: Secure
Hash Standard, 2002.
http://csrc.nist.gov/publications/ﬁps/
ﬁps180-2/ﬁps180-2withchangenotice.pdf.
[9] F. Goichon, C. Lauradoux, G. Salagnac, and T. Vuillemin.
Entropy transfers in the Linux Random Number Generator.
Research Report RR-8060, INRIA, Sept. 2012.
[10] I. Goldberg and D. Wagner. Randomness and the Netscape
browser. Dr Dobb’s Journal-Software Tools for the Profes-
sional Programmer, 21(1):66–71, 1996.
[11] Z. Gutterman, B. Pinkas, and T. Reinman. Analysis of the
In IEEE Symposium on
Linux random number generator.
Security and Privacy, pages 371–385. IEEE, 2006.
[12] N. Heninger, Z. Durumeric, E. Wustrow, and J. A. Halderman.
Mining Your Ps and Qs: Detection of Widespread Weak Keys
in Network Devices. 2012.
[13] J. Kelsey, B. Schneier, and N. Ferguson. Yarrow-160: Notes
on the design and analysis of the yarrow cryptographic
pseudorandom number generator. In Selected Areas in Cryp-
tography, pages 13–33. Springer, 2000.
[14] B. Kerrigan and Y. Chen. A study of entropy sources in cloud
computers: random number generation on cloud hosts.
In
Computer Network Security, pages 286–298. Springer, 2012.
[15] B. Kerrigan and Y. Chen. A study of entropy sources in cloud
computers: random number generation on cloud hosts.
In
Computer Network Security, pages 286–298. Springer, 2012.
[26] T. Ristenpart and S. Yilek. When good randomness goes bad:
Virtual machine reset vulnerabilities and hedging deployed
cryptography. In NDSS. ISOC, 2010.
[27] A.
About
2013.
Shah.
machines,
about-random-numbers-and-virtual-machines/.
virtual
http://log.amitshah.net/2013/01/
random numbers
and
[28] A. Stamos, A. Becherer, and N. Wilcox. Cloud computing
models and vulnerabilities: Raining on the trendy new parade.
BlackHat USA, 2009.
[29] M. A. Stephens. Use of the Kolmogorov-Smirnov, Cram´er-
Von Mises and related statistics without extensive tables.
Journal of the Royal Statistical Society. Series B (Method-
ological), pages 115–122, 1970.
[30] C. J. Thompson, I. J. De Silva, M. D. Manner, M. T. Foley,
and P. E. Baxter. Randomness exposed–an attack on hosted
virtual machines, 2011.
[31] R. S. Winternitz. A secure one-way hash function built from
des. In IEEE Symposium on Security and Privacy, pages 88–
90, 1984.
[32] S. Yilek, E. Rescorla, H. Shacham, B. Enright, and S. Savage.
When private keys are public: results from the 2008 Debian
OpenSSL vulnerability. In SIGCOMM Conference on Internet
Measurement, pages 15–27. ACM, 2009.
574
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:43 UTC from IEEE Xplore.  Restrictions apply.