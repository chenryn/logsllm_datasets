另外，在 /etc/mysql/my.cnf（MySQL 的配置文件）中添加如下设置。
``` 代码无行号
[client]
default-character-set=utf8
```
#### **参考：Java+MySQL 的安全连接方法**
Java 连接 MySQL 时使用 JDBC 驱动的 MySQL
Connector/J。由于这一组合默认使用的是动态占位符，因此，建议修改如下设置（阴影部分）以改为使用静态占位符。
    Connection con = DriverManager.getConnection(
    "jdbc:mysql://localhost/dbname?user=xxx&password=xxxx&
    useServerPrepStmts=true
    &useUnicode=true&characterEncoding=utf8")
> **参考文献**
>
> \[1\] Justin Clarke.（2009）. *SQL Injection Attacks and Defence* .
> Syngress.
>
> \[2\] 金床 .（2007）.《ウェブアプリケーションセキュリティ》（《Web
> 应用安全》）. データ·ハウス .
>
> \[3\] 佐名木智贵 .（2008）.《セキュア Web プログラミング Tips
> 集》（《Web 编程安全性技巧》）. ソフト·リサーチ·センター .
>
> \[4\] 德丸浩（2008 年 12 月 22 日）. Java と MySQL の组み合わせで
> Unicode の U+00A5 を用いた SQL インジェクションの可能性（通过 Java 和
> MySQL 的组合对利用 Uninode 的 U+00A5 进行 SQL 注入的可能性）.
> 参考日期：2010 年 12 月 23 日，参考网址：德丸浩の日记 :
> 
>
> \[5\] 独立行政法人信息处理推进机构（IPA）.（2010 年 3 月 18 日）.
> 安全な SQL の呼び出し方（安全调用 SQL 的方法）. 参考日期：2010 年 12
> 月 7 日，参考网址：情报処理推进机构 :
> 
## **4.5 关键处理中引入的安全隐患** {#text00000.html#nav_point_27}
Web
应用中，用户登录后执行的操作中有些处理一旦完成就无法撤销，本书将此类处理称为"关键处理"[27]{.注释编号}
。像用户使用信用卡支付、从用户的银行账号转账、发送邮件、更改密码或邮箱地址等都是关键处理的典型案例。
[27]{.注释编号下} 有些文献也把关键处理用于表示特定的副作用。
关键处理中如果存在安全隐患，就会产生名为跨站请求伪造（Cross-Site Request
Forgeries，简称 CSRF）的漏洞。接下来，本节就将对 CSRF
漏洞进行详细的说明。
### **4.5.1 跨站请求伪造（CSRF）** {#text00000.html#nav_point_28}
#### **概要**
在执行关键处理前，需要确认该请求是否确实由用户自愿发起。如果忽略了这个确认步骤，就可能出现很大问题，比如用户只是浏览了恶意网站，浏览器就擅自执行关键处理等。
引发上述问题的安全隐患被称为跨站请求伪造（CSRF）漏洞，而针对 CSRF
漏洞进行的攻击就是 CSRF 攻击。
Web 应用存在 CSRF 漏洞时就可能会遭受如下攻击。
-   使用用户的账号购物
-   删除用户账号
-   使用用户的账号发布帖子
-   更改用户的密码或邮箱地址等
CSRF
漏洞造成的影响仅限于应用的关键处理被恶意使用，而像用户的个人信息等就无法通过
CSRF 攻击窃取 [28]{.注释编号} 。
[28]{.注释编号下}
但是，一旦攻击者修改了用户的密码，就有可能窃取该用户的个人信息。
因此，为了预防 CSRF
漏洞，就需要在执行关键处理前确认请求确实是由用户自愿发起的。详情请参考本节的"对策"。
**CSRF 漏洞总览**
![{%}](Image00082.jpg)
#### **攻击手段与影响**
首先让我们来看一下针对 CSRF
漏洞实施的两种典型的攻击模式。即"输入－执行"这种简单模式下的攻击手段以及中途包含确认页面时的攻击方法。
-   **"输入－执行"模式的 CSRF 攻击**
    此处用更改密码页面作为"输入－执行"模式下关键处理的例子。以下 PHP
    脚本展示了更改密码处理的概要。
    > **代码清单 /45/45-001.php（登录脚本）**
    ``` 代码无行号
    已登录 (id:)
     更改密码 
    ```
    > **代码清单 /45/45-002.php（密码输入页面）**
    ``` 代码无行号
    新密码 
    ```
    > **代码清单 /45/45-003.php（执行更改密码）**
    ``` 代码无行号
     ○○的密码已更改为△△
    ```
    这些脚本的运行示例如图 4-41 所示。
    ![{%}](Image00083.jpg)
    **图 4-41 脚本运行示例**
    可见，密码在最后的 45-003.php
    中被更改。然而，通过此脚本更改密码，还需要满足以下 3 个条件。
    -   使用 POST 方法请求 45-003.php
    -   保持登录状态
    -   使用 POST 参数中的 `pwd` 指定新密码
    而使浏览器发送满足以上条件的请求的攻击即为 CSRF
    攻击。下面就是用来实施 CSRF 攻击的 HTML 文件。
    > **代码清单 /45/45-900.html**
    ``` 代码无行号
    ```
    这段代码为实施 CSRF 攻击的恶意网页的 HTML
    源代码。攻击者将其置于互联网上，并在其中添加攻击对象网站用户可能感兴趣的内容，以引诱网站的用户前来浏览。
    用户浏览此 HTML 时的情形如图 4-42 所示。
    ![{%}](Image00084.jpg)
    **图 4-42 通过 CSRF 攻击变更密码**
    这种情况下，因为先前列举的变更密码所需条件都已满足，所以正规用户的密码就被成功更改为了
    cracked。
    ![{%}](Image00085.jpg)
    **图 4-43 CSRF 攻击成功**
    攻击者在实际发动攻击时，为了使攻击显得隐蔽，通常会采用不可见的
    iframe 来布置恶意网页（45-901.html）。
    ![{%}](Image00086.jpg)
    **图 4-44 隐藏 iframe 以进行暗中攻击**
    此时，根据同源策略，从 iframe
    的外层（恶意网页）无法读取到内层（攻击对象）的内容，因此，CSRF
    攻击虽然能够以正规用户的权限恶意使用攻击对象网站中的关键处理，却无法获取网页中显示的内容。
    -   **密码被更改也会导致信息泄漏**
        由于 CSRF
        攻击者不能获取攻击对象页面，因此便无法窃取信息。但是，在使用
        CSRF
        攻击成功更改用户密码后，攻击者就知道了更改后的密码，从而也就能够登录应用来窃取被害人的信息了。
-   **CSRF 攻击与 XSS 攻击**
    CSRF 与（反射型）XSS
    不仅名称相似，攻击流程也如出一辙，甚至连攻击的影响也有相同之处，因此将两者混淆的人不在少数。而为了区分两者，我们可以看一下图
    4-45 所展示的 CSRF 和反射型 XSS 的攻击流程。根据此图可以看出，CSRF
    和 XSS 在步骤①到③时大体相似，之后便产生了分歧。
    ![{%}](Image00087.jpg)
    **图 4-45 CSRF 与反射型 XSS 的比较**
    CSRF
    是指恶意使用服务器对步骤③中请求的处理，恶意使用的内容仅限于服务器端提供的处理。
    而 XSS
    的情况下，③的请求中包含的脚本则被原封不动地以响应④的形式返回，随后该恶意脚本在用户的浏览器中被执行。由于攻击者能够在用户的浏览器上执行自己准备的
    HTML 或
    JavaScript，因此只要是浏览器能做到的事都可以被用作攻击手段。攻击者甚至还能够通过
    JavaScript
    恶意使用服务器端的功能（显示在图中的话就是步骤⑤------向服务器发出恶意请求）。
    由此可见，就攻击范围来说，XSS 的威胁更大，但针对 CSRF
    漏洞则特别需要注意如下两点。
    -   CSRF 需要在设计阶段就考虑防范策略
    -   开发者对 CSRF 的认知度要低于 XSS，CSRF 对策方面也没有太大进展
-   **存在确认页面时的 CSRF 攻击**
    接下来就让我们来看一下第二种攻击模式，即输入页面与执行页面之间包含确认页面时的情况。有人觉得有了确认页面后
    CSRF 攻击就行不通了，但遗憾的是这是个普遍的误解。
    下面以更改邮箱地址的操作为例进行说明。一旦能够随意更改他人的邮箱地址，就可以使用重置密码等功能窃取用户密码。
    确认页面将数据传递给执行页面的方法大体上有两种。一种是使用 hidden
    参数（type 属性为 hidden 的 input
    元素），另一种是使用会话变量。首先来看使用 hidden 参数的情况。
    -   **使用 hidden 参数传递参数**
        下图展示了更改邮箱地址操作时的页面跳转情况。输入页面中输入的邮箱地址被以
        hidden 参数的形式嵌入在确认页面中，然后又被传递给了执行页面。
        ![{%}](Image00088.jpg)
        **图 4-46 使用 hidden 参数传递参数**
        此模式下的 CSRF
        攻击手段与没有确认页面时的情况相同。这是因为执行页面从输入（HTTP
        请求）中取得邮箱地址信息这一点与之前的例子一样。所以，上面介绍的恶意
        HTML 几乎是被直接用来攻击的。
    -   **使用会话变量传递参数**
        针对在确认页面和执行页面之间利用会话变量传递参数的网站，CSRF
        将如何展开攻击呢？如图 4-47
        所示，确认页面将接收到的邮箱地址保存至会话变量，然后再转递给执行页面。
        ![{%}](Image00089.jpg)