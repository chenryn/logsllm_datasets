就本例来说，有5个不错的代码洞可以使用。起始地址给出了代码洞的虚拟内存地址（VMA），即当PE文件加载到内存中后，代码洞的地址，文件偏移量是代码洞在PE文件内的相对位置，这里以字节为单位。
大部分洞穴大都位于数据节内，但是，由于数据节没有execute权限，所以需要修改相应的节标志。我们的后门代码大小在400-500字节左右，所以这里的代码洞应该够用了。所选择的代码洞的起始地址应该保存好，在将节权限改为R/W/E之后，植入后门的第一步工作就算完成了。接下来，我们开始处理执行流程的重定向问题。
**劫持执行流程**
在这一步中，目标是将执行流重定向到后门代码，为此需要修改目标可执行文件的相关指令。在选择修改哪一个指令方面，有一些细节需要引起我们的高度注意。所有二进制指令具有一定的大小（以字节为单位），为了跳转到后门代码的地址上面，必须使用5或6字节的长跳转指令。因此，在给二进制代码打补丁时，被修改的指令的长度需要跟长跳转指令的长度保持一致，否则它的上一条或下一条指令就会被破坏。
在进行重定向的时候，选择适当的内存空间对于绕过AV产品的动态和沙箱分析机制是非常重要的。如果直接进行重定向，则可能在AV软件的动态分析阶段被检测到。
**隐藏在用户交互下：**
为了绕过沙箱/动态分析阶段的检测，首先想到的自然是延迟shellcode的执行或设计能够检测沙箱的shellcode和触发机制。但是在制作后门时，通常没有这么多的空间，供我们在PE文件中添加这些额外的代码。此外，还可以利用汇编语言设计防检测机制，但是这需要大量的时间和丰富的知识。
该方法使用的函数，需要用户的介入才能得到执行，具体来说，这个函数对应于程序的特定功能，只有当实际的用户运行该程序并且执行了特定的操作时，才会执行这个函数，引发执行流程的重定向，从而激活后门代码。如果此方法可以正确实施，它将具有％100成功率，并且不会增加后门代码的大小。
当用户点击putty用户界面上的“Open”按钮时，将会启动一个相应的函数，来检查给定IP地址的有效性，
如果ip地址字段中的值不为空并且有效，就会执行一个函数来连接给定ip地址。
如果客户端成功创建了一个ssh会话，就会弹出一个新的窗口，并要求输入登陆凭证，
这就是发生重定向的地方，因为没有那款AV产品高级到检测这么复杂的用法，所以，以这种方式植入的后门，自然就不必担心受到自动沙箱和动态分析的检测了。  
使用基本的逆向工程方法，如跟踪字符串及其引用，很容易就能找到连接函数的地址。客户端与给定的ip建立连接后，会将字符串“login
as：”打印到窗口中。这个字符串将帮助我们找到连接函数的地址，因为IDA Pro在跟踪字符串引用方面非常优秀。
在IDA中依次选择Views->Open Subviews->Strings菜单项，来寻找字符串“login as:”
找到该字符串后双击，就会来到它在代码中的位置，由于IDA能够找出数据节内该字符串的所有交叉引用，我们只需按“Ctrl +
X”就能显示所有交叉引用，这个引用位于打印“login as：”字符串的函数中，
这就是我们要修改的那个指令，在进行任何更改之前，先保存下来。因为在执行后门代码之后，我们还会用到它。
将PUSH 467C7C指令更改为JMP
0x47A478之后，后门制作的重新定向阶段便告一段落了。需要注意的是，要记住下一个指令的地址。在执行后门代码后，它将用作返回地址。接下来，我们要做的是注入后门代码。
**注入后门代码**
在注入后门代码时，首先需要想到的是在执行后门代码之前保存寄存器。所有寄存器中的每个值对于程序的执行而言都是非常重要的。所以，需要在代码洞的开头部分放入相应的PUSHAD和PUSHFD指令，将所有寄存器和寄存器标志都保存到堆栈中。这些值将在执行后门代码之后弹出，以便程序可以继续执行而不会出现任何问题。
如前所述，我们这里使用的后门代码来自metasploit项目的meterpreter reverse tcp
shellcode。但是，这里需要对这个shellcode稍作修改。通常，反向tcp
shellcode连接处理程序的尝试次数是有限制的，如果连接失败，则通过调用ExitProcess API来关闭该进程。
这里的问题是，如果连接处理程序失败，putty客户端将会停止，现在，我们只要修改几行shellcode的汇编代码，就可以让它每次连接失败后，重新尝试连接处理程序，同时，还让shellcode的尺寸也变小了。
对汇编代码进行必要的更改后，使用nasm -f bin stager_reverse_tcp_nx.asm命令进行编译。现在反向tcp
shellcode已经可以使用了，但不会直接植入。我们的目标是在新线程上执行shellcode。为了创建一个新的线程实例，需要让另一个shellcode调用指向反向tcp
shellcode的CreateThread API。在Metasploit项目中，也有一个用于创建线程得shellcode，它是由Stephen
Fever编写的。
在将十六进制的shellcode字节码放入createthread.asm文件之后，就可以使用nasm -f bin
createthread.asm命令进行汇编。这样，该shellcode就可以插入到代码洞了，但在插入该shellcode之前，应该对其进行加壳，以便绕过AV产品的静态/特征分析检测。因为metasploit项目中的所有加壳软件对大多数AV产品来说都熟悉不过了，所以强烈建议使用自定义的加壳软件。本文不会介绍如何制作shellcode的自定义加壳软件，因为将来会单独写一篇文章进行详细的介绍，但是如果组合使用多个metasploit加壳软件的话，也是可行的。在每次加壳之后，以原始格式将编码的shellcode上传到相应的在线查毒网站，看看免杀效果如何。尝试每种组合，直到它无法被检测到为止；如果您有耐心，那么等待下一篇文章也行。
对shellcode成功加壳之后，就可以把它插入代码洞了。请选中PUSHFD下面的指令，然后在immunity debugger中按Ctrl +
E组合键，这样shellcode将以十六进制格式粘贴到这里。
使用xxd -ps
createthread命令，以十六进制格式打印输出创建线程的shellcode，或使用十六进制编辑器打开shellcode并复制相应的十六进制值。在将十六进制值粘贴到调试器时，请注意字节限制，因为这些修改都是在immunity
debugger中进行的，而对于immunity
debugger来说，向编辑代码窗口中粘贴代码时，是有字节限制的。所以，我们可以每次粘贴一部分，按下OK按钮后，继续粘贴后续字节，当所有shellcode全部粘贴到代码洞之后，插入后门代码的流程便大功告成了。
**恢复执行流程**
在创建后门代码线程之后，需要恢复程序的正常执行，这意味着EIP应该跳回到将执行权限重定向至代码洞的那个函数。但是在跳回到该函数之前，应该首先将寄存器的值恢复到之前的状态。
通过在shellcode的末尾放入相应的POPFD和POPAD指令，就可以将此前保存的寄存器的值以相同的顺序从堆栈中弹出。在恢复寄存器之后，先别忙着跳回，因为还有一件重要的事情需要处理，即我们要执行的是被劫持的指令，但是为了将程序的执行重定向到代码洞，PUSH
467C7C指令已经被替换为JMP 0x47A478了。现在，可以把这个PUSH
467C7C指令放到最后面，就能恢复被劫持的指令了。接下来，我们就可以跳回到通过插入JMP
0x41CB73指令将执行重定向到代码洞的那个函数了，代码如下所示。
最后，选中相应的指令，单击右键，通过相应的选项将它们复制到可执行文件。对于这个操作，我们应该对所有被修改的指令都执行一遍。当所有指令被复制并保存到文件后，关闭调试器，然后测试可执行文件，如果可执行文件运行正常的话，那就说明后门可以使用了。
最后，建议处理好最终文件的校验和，以免引起怀疑，这也能够降低被检测出来的风险。
**  
**
**小结**
最后，在按照上述方法正确处理之后，我们的后门就可以完全隐身了。
**演示视频**
现在，您可以通过下列视频来观看我们安装后门后的putty的表现了：
**参考资料**
****
**传送门**
* * *
[**【技术分享】反侦测的艺术part1：介绍AV和检测的技术**
****](http://bobao.360.cn/learning/detail/3420.html)
[**【技术分享】反侦测的艺术part3：shellcode炼金术**
****](http://bobao.360.cn/learning/detail/3589.html)
[********](http://bobao.360.cn/learning/detail/3420.html)