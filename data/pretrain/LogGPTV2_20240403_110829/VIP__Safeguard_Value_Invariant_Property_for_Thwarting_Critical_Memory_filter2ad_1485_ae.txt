15
10
5
0
)
%
(
d
a
e
h
r
e
v
O
e
c
n
a
m
r
o
f
r
e
P
VIP-heap protection
VIP-CFI+VTPtr
VIP-CPI
400.perlbench
401.bzip2
403.gcc
429.mcf
433.milc
444.namd
445.gobmk
447.dealII
450.soplex
453.povray
462.libquantum
456.hmmer
458.sjeng
464.h264ref
471.omnetpp
470.lbm
483.xalancbmk
482.sphinx3
473.astar
Geomean-SPEC
Geomean-ALL
PostgreSQL
NGINX
Figure 7: The performance overhead of SPEC CPU2006, NGINX web server, and PostgreSQL database server relative to an unprotected baseline
build. Our three VIP protections are: (1) heap metadata protection, (2) CFI and C++ VTPtr protection, and (3) CPI protecting all sensitive pointers.
HyperSpace imposes negligible average performance overhead of 1.33%, 0.86% and 5.53% for VIP heap metadata protection, VIP-CFI+VTPtr
and VIP-CPI, respectively.
(1) CVE-2016-10190. This is a heap-based buffer overflow in
ffmpeg, a popular multimedia framework. This exploit allows re-
mote web servers to execute arbitrary code by overwriting function
pointers in an AVIOContext object. VIP-CFI/CPI successfully detects
this exploit [52] and halts its execution by asserting the corruption
of a function pointer in a victim AVIOContext object.
(2) CVE-2015-8668. This is a heap-based buffer overflow in libtiff,
an image file format library. This exploit allows remote attackers
to execute arbitrary code. A malicious BMP file causes an integer
overflow followed by a heap overflow that overwrites a function
pointer in a TIFF structure. VIP-CFI/CPI successfully detects this
exploit [19] by asserting the corrupted function pointer before use.
(3) CVE-2014-1912. This is a buffer overflow in python2.7 caused
by a missing buffer size check. An attacker can overwrite a func-
tion pointer in PyTypeObject via a crafted string and can execute
arbitrary code. VIP-CFI/CPI blocks this exploit [66] by detecting
the corruption of the function pointer before use.
9.1.2 Synthesized Exploits We used synthesized exploits to
demonstrate how HyperSpace can defend VTPtr hijacking in C++
objects, COOP attacks [64] ‚Äì a Turing complete attack via creating
fake C++ objects ‚Äì and heap exploits.
(1) CFIXX C++ Test Suite. We used a C++ test suite [53] released
by Burow et al. [7]. It provides four VTPtr hijacking exploits (FakeVT,
FakeVT-sig, VTxchg, VTxchg-hier), and one COOP exploit. Essen-
tially, the VTPtr hijacking exploits overwrite a VTPtr in a C++ object.
In order to make the test suite more similar to real-world memory
corruption-based attacks, we modified the test suite to corrupt a
VTPtr using a heap-based overflow instead of directly overwriting
the VTPtr using memcpy. This modification is required for the attack
to be accurately replicated and does not affect the success or failure
of the attack. Without this modification, HyperSpace would deter-
mine this memcpy to be legitimate since it would be interpreted as
the programmer‚Äôs intention. Our modification is inspired by a syn-
thesized exploit in OS-CFI [42]. VIP-VTPtr detects all four exploits
by checking if a VTPtr is corrupted before allowing a call to a virtual
function of a given object. The COOP attack creates a fake object
without calling the class‚Äô constructor and calls a virtual function of
the fake object. VIP-VTPtr prevents this exploit by detecting that
the VTPtr of the fake object is not initialized as sensitive data and
raises an exception before the virtual function call.
(2) Heap Exploit. To evaluate heap metadata protection, we used
an exploit from [17], which overwrites the inline metadata of an al-
located heap memory. HyperSpace thwarts this attack by detecting
the metadata corruption upon free of a victim memory chunk.
9.2 Performance Evaluation
We evaluate the performance overhead of HyperSpace security
mechanisms described in ¬ß6 using SPEC CPU2006 and two real-
world applications: NGINX (v1.14.2) and PostgreSQL (REL_12_0).
SPEC CPU2006 has realistic compute-intensive applications that
are ideal to see the worst-case overhead of HyperSpace. We choose
SPEC CPU2006 over SPEC CPU2017 to easily compare HyperSpace
with prior work. Figure 7 shows performance overhead compared
to an unprotected original baseline build running on the original
kernel. The average numbers reported here are geometric means.
9.2.1 Performance Overhead of SPEC CPU2006
(1) Heap Metadata Protection. The performance overhead for
heap metadata protection with HyperSpace is 1.33% overall as Fig-
ure 7 shows. Three benchmarks have more than a 5% overhead.
These three benchmarks heavily call malloc and free. For example,
471.omnetpp calls malloc and free over 534 million times com-
bined. In addition to omnetpp, perlbench, dealII, and xalancbmk
call malloc and free millions of times as well, which explains this
overhead. This is consistent with results in previous work [15].
(2) VIP-CFI+VTPtr. We then evaluate CFI and C++ VTPtr pro-
tection, which together protect all code pointers of a program by
enforcing VIP. The performance overhead is negligible, 0.88%. A
few benchmarks show small performance improvement (1-2%) be-
cause SafeStack improves the locality of safe objects by moving
large arrays to the regular stack. In the worst case, only two C++
benchmarks, 471.omnetpp and 483.xalancbmk, exceed 3% overhead.
In these two benchmarks, the use of virtual function calls was more
frequent compared to other C++ benchmarks, resulting in higher
overhead from protecting the integrity of the VTPtr.
(3) VIP-CPI. HyperSpace‚Äôs CPI protection performs well, with
an average overhead of 6.18%. Two benchmarks, 400.perlbench
and 453.povray, show the highest overhead. 400.perlbench accu-
mulates overhead from frequently utilizing sensitive global vari-
ables that contain function pointers. For example, a perlbench func-
tion, Perl_runops_standard, contains a while loop, where the loop
condition contains sensitive indirect call, followed by the return
variable being assigned to a sensitive global variable. This causes
repetitive permission changes of the safe memory region and col-
lects undesirable, but unavoidable overhead. As for 453.povray,
most overheads are from assertions of function pointers in the
struct Method_Struct. This struct mimics C++‚Äôs virtual function
table by containing a series of function pointers. Other 453.povray
objects use this struct to call function pointers abundantly through-
out its runtime. HyperSpace protection recursively extends to
Session 5D: Misc: Android and Vulnerabilities CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea1621pointers of objects that contain the struct Method_Struct. These
chains of pointers require VIP instrumentation throughout the
benchmark resulting in unusual overhead. Recent works, ERIM [78]
and IMIX [27], also attempted to utilize MPK for protecting the
metadata store of CPI. However, they incur much more runtime
overhead than VIP-CPI: the maximum overhead is 3.2√ó higher for
ERIM and 28.5√ó for IMIX than VIP-CPI. Moreover, they do not reveal
their runtime overhead for 400.perlbench and 453.povray, which
are most likely their two highest overheads similar to VIP-CPI. This
shows that our optimization techniques (especially, to reduce the
MPK permission change overhead) described in ¬ß7 are effective.
(4) Summary. The performance overhead of HyperSpace for SPEC
CPU2006 is negligible: 0.88% for VIP-CFI protection and 6.18% for
VIP-CPI protection. In comparison, current state-of-the-art defense
techniques like Code-Pointer Integrity [45] and ùúáCFI [36], have an
average overhead of 8.4% and 7.88% with the worst-case overhead
of 44% and 49%, respectively.
9.2.2 Performance Overhead of Real-World Applications
NGINX and PostgreSQL are two widely used web and database
servers, respectively. We used the default NGINX configuration,
accommodating a max of 1024 connections per processor. Bench-
marking is done over a network using a server on the same network
switch. Similarly, the default configuration for PostgreSQL was also
used with a max of 100 connections. The numbers reported here
are latency at 24-cores. We configured benchmark clients ‚Äì wrk and
pgbench ‚Äì to fully stress the server.
(1) NGINX. We evaluate the performance of NGINX using an
HTTP benchmarking tool wrk [30]. wrk spawns threads that send
requests for a 6,745-byte static HTML page and measures the la-
tency and request throughput (req/sec). We ran wrk with 24 threads
with each thread handling 50 HTTP connections to fully stress
the server. We ran the host and server on two separate machines
with a 100Gbps Ethernet connection. The performance overhead is
negligible: heap metadata, CFI and CPI protections impose 1.38%,
0.44% and 1.05% of overhead, respectively. The request throughput
was 2.32K, 2.33K and 2.32K req/sec, respectively, compared to a
2.35K req/sec baseline. In addition, we evaluated NGINX with SSL
enabled. The results confirm that the performance overhead with
SSL is still negligible: 1.42%, 0.47% and 1.09% for heap metadata, CFI
and CPI, respectively. That is because while SSL is CPU-intensive,
it does not have many sensitive pointers. The request throughput
was 2.06K, 2.08K and 2.07K req/sec, respectively, compared to a
2.09K req/sec baseline.
(2) PostgreSQL. To evaluate the performance of PostgreSQL, we
used pgbench [76], which repetitively runs concurrent database
sessions that handle a sequence of SQL commands to measure the
average transaction rate and latency. We ran the host and server on
the same machine. We tested PostgreSQL with 24 concurrent data-
base clients. PostgreSQL shows negligible performance impact of
1.30%, 1.96% and 2.04% for heap metadata, CFI, and CPI protections,
respectively. Concretely, PostgreSQL showed 1696, 1685, and 1683
transactions-per-second, respectively, compared to a 1719 baseline.
9.3 Performance Analysis
We first analyze the impact of our optimization techniques and then
provide a detailed analysis of the memory consumption.
SLNT
CBB
CFN
INLN
SS
HGP
120
100
80
60
40
20
0
)
%
(
t
n
e
m
e
v
o
r
p
m
i
e
c
n
a
m
r
o
f
r
e
P
400.perlbench
401.bzip2
403.gcc
Average-SPEC
462.libquantum
483.xalancbmk
456.hmmer
482.sphinx3
471.omnetpp
458.sjeng
450.soplex
473.astar
453.povray
470.lbm
433.milc
445.gobmk
429.mcf
464.h264ref
447.dealII
444.namd
Figure 8: Impact of the performance optimization techniques de-
scribed in ¬ß7. (SLNT: runtime silent store elimination; CBB: basic
block-level coalescing; CFN: function-level coalescing; INLN: inlin-
ing VIP APIs; SS: safe stack; HGP: huge page).
9.3.1 Impact of Performance Optimization In order to mea-
sure the impact of each optimization technique, we turned off one
optimization at a time in a fully optimized VIP-CPI. Figure 8 shows
the impact of each technique for SPEC CPU2006.
(1) Runtime Silent Store Elimination (SLNT). HyperSpace
reduces costly wrpkru instructions by eliminating unnecessary,
repetitive modifications of the safe memory region. If an object
has already been registered and its value is the same (i.e., silent
store), HyperSpace skips unnecessary, repetitive vip_register and
vip_write calls to reduce the costly MPK permission changes. This
optimization improves performance by 6.6% on average. In particu-
lar, it improves the performance of 453.povray by 75%.
(2) Coalescing Permission Changes within a Basic Block (CBB).
Coalescing permission changes within a basic block improves per-
formance 2.17% on average by minimizing the number of permis-
sion changes. 453.povray is improved 9.8% for having an abundant
number of sensitive object pointers that are often updated.
(3) Coalescing Permission Changes within a Function (CFN).
Extending coalescing to function scope improves performance
1.4% on average. 464.h264ref, 458.sjeng, and 400.perlbench have
higher performance gain of 7.2%, 6.8%, and 3.5%, respectively, due
to having commonly used functions such as Perl_linklist recog-
nized as a safe function.