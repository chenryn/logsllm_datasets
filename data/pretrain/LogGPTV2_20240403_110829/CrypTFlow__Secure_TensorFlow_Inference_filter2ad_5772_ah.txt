L .
Output: Z ∈ Z
f 2×1
1. for i = {0, ..., f − 1} do
L
2.
3.
4.
5. end for
end for
for j = {0, ..., f − 1} do
Z[i · f + j] = X[i][j]
L
where n = m − f + 1.
for j = {0, ..., m − f} do
Algorithm 3 ReshapeInput
Input: X ∈ Zm×m
.
Output: Z ∈ Z
n2×f 2
L
Global Information: Filter dimension f.
1. for i = {0, ..., m − f} do
2.
3.
4.
5.
X[k + i][l + j]
6.
7.
8.
9. end for
for k = {0, ..., f − 1} do
end for
end for
end for
for l = {0, ..., f − 1} do
Z[i·(m−f +1)+j][k·f +j] =
.
L
Algorithm 4 ReshapeOutput
Input: X ∈ Zn2×1
.
Output: Z ∈ Zn×n
1. for i = {0, ..., n − 1} do
2.
3.
4.
5. end for
end for
L
for j = {0, ..., n − 1} do
Z[i][j] = X[i · n + j]
B. Batch Normalization
Batch Normalization [46] is used to normalize the inputs
to intermediate layers across a mini-batch of images. For
a batch B of inputs, let μB and σ2
B be the mean and the
variance respectively. For an input x, the output of the batch
normalization layer is deﬁned as
(cid:14)
(x − μB)
σ2
B + 
BN (x) = γ
+ β
where γ and β are the model parameters learned during
training phase. In the inference phase, μB and σ2
B represent
the mean and variance of the entire training dataset.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:36:59 UTC from IEEE Xplore.  Restrictions apply. 
351
Top1 Accuracy Vs Scaling Factor
Top5 Accuracy Vs Scaling Factor
9
11
13
15
19
17
Scaling Factor
21
23
25
27
Fixed Point Accuracy
Floating Point Accuracy
y
c
a
r
u
c
c
A
5
p
o
T
91.9
91.8
91.7
91.6
91.5
91.4
91.3
8
10
12
14
16
20
18
Scaling Factor
22
24
26
28
30
Fixed Point Accuracy
Floating Point Accuracy
Fig. 11: RESNET50: Top 1 accuracy vs Scale
Fig. 14: DENSENET121: Top 5 accuracy vs Scale
y
c
a
r
u
c
c
A
1
p
o
T
76.5
76.45
76.4
76.35
76.3
76.25
76.2
y
c
a
r
u
c
c
A
5
p
o
T
93.24
93.22
93.2
93.18
93.16
93.14
93.12
93.1
93.08
Top5 Accuracy Vs Scaling Factor
9
11
13
15
17
19
Scaling Factor
21
23
25
27
Fixed Point Accuracy
Floating Point Accuracy
Fig. 12: RESNET50: Top 5 accuracy vs Scale
C. Accuracy of Athos
In this section, we present the Top 1 and Top 5 accuracies
of Athos on the ImageNet dataset.
D. Comparison with 2PC/FHE
See Table X which validates the well-known fact that 3PC
protocols like Porthos are much faster than 2PC/FHE-based
approaches. We omit other 2PC/FHE works ([62], [19], [15],
[14], [58], etc.) as the performance comparisons are similar
and do not provide additional insights.
E. Proof of malicious security
For simplicity, consider the case of single malicious party
Pi. Informally, we argue that our technique constrains Pi
to follow the instructions of the semi-honest protocol π(·)
faithfully. Or, deviating from faithful execution would result
in some honest party to abort. The ﬁrst Compute invocation
Top1 Accuracy Vs Scaling Factor
y
c
a
r
u
c
c
A
1
p
o
T
74.5
74.3
74.1
73.9
73.7
73.5
73.3
8
10
12
14
16
20
18
Scaling Factor
22
24
26
28
30
Fixed Point Accuracy
Floating Point Accuracy
Fig. 13: DENSENET121: Top 1 accuracy vs Scale
Benchmark
∗
SQUEEZENET
(CIFAR)
MiniONN (CIFAR)
MiniONN (MNIST)
CHET MiniONN
1342
-
-
-
544
9.4
Gazelle
-
12.9
0.81
Porthos
0.05
0.36
0.03
TABLE X: Comparison with 2PC – All times in seconds.
CHET replaces ReLUs in a small SQUEEZENET with square
activations.
attest
attest
attest
of F (vki,ski)
ﬁxes the input of Pi used in the protocol. Since
every other F (vkj ,skj )
reliably knows the veriﬁcation key vki
used by F (vki,ski)
, it checks the signatures on the function
description (i.e., T (i)
π∗ ) as well as the messages of the protocol.
The unforgeability of the signature scheme guarantees that
Pi cannot forge signatures on incorrectly generated protocol
messages. Note that we use this property to ensure that both of
the following signatures cannot be forged: (a) signatures under
vki on messages generated by F (vki,ski)
and sent to honest Pj
(b) signatures under vkj on messages sent by Pj being fed
into F (vki,ski)
provides correct randomness to
generate messages of Pi in the semi-honest secure protocol.
to any honest party Pj are
Hence, all messages from Pi
generated correctly as directed by π. This argument can be
easily extended to multiple colluding corrupt parties.
. Also, F (vki,ski)
attest
attest
attest
Formally, we give a security proof using the standard
simulation paradigm (we refer the reader to [35], [18] for
details on the paradigm). That is, the protocol in Figure 8
securely realizes the ideal MPC functionality described in
Figure 9 against malicious adversaries.
Theorem 2 (Restated). Let π(·) be a semi-honest se-
cure MPC protocol securely realizing F f
mpc. Then, protocol
Protmalicious(P1,··· , Pn) described in Figure 8 securely real-
−hybrid model (with i ∈ [n]) against
mpc in the F (vki,ski)
izes F f
malicious adversaries.
Proof Sketch. Let A be the real world adversary. Ideal world
adversary S that simulates the view of A is as follows: Let
S(cid:2) be the ideal world adversary or the semi-honest simulator
for π (this exists because π is semi-honest secure). S picks
{(vkk, skk)}k∈[n] and gives {vkk}k∈[n] to A. We denote a
corrupt party by Pi and honest party by Pj. Next, when A
invokes an instance of F (vki,ski)
on command Commit for
a corrupted party Pi, S simulates the correct behavior of
attest
attest
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:36:59 UTC from IEEE Xplore.  Restrictions apply. 
352
attest
F (vki,ski)
. Also, S sends correctly generated tokens {T (j)
π∗ }
for all honest parties to A. When S receives token from A
corresponding to a corrupted party Pi, it checks it against
∗ and vki. It aborts if veriﬁcation fails. When A invokes
π
with xi, S stores it as input of Pi. When A commits
F (vki,ski)
to inputs of all corrupt parties, S sends these to F f
mpc to learn
output y. It sends inputs of corrupt parties and outputs y to
attest
S(cid:2) that generates the view of the adversary in the semi-honest
protocol, that contains the randomness for all corrupt parties
as well as the transcript of the protocol. Using this, it is easy
for S to simulate the view of A in the rest of the protocol. The
indistinguishability of the adversary’s view in real and ideal
executions follows from the semi-honest security of π.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:36:59 UTC from IEEE Xplore.  Restrictions apply. 
353