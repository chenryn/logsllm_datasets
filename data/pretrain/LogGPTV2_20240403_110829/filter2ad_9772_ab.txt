*tcache`这个是个全局变量，直接指向了这个tcache数据结构，应该是每个线程都会维护以这个这个全局变量。
tcache_perthread_struct中包含了一个tcache_entry数组，元素有64个，代表着64个链表，也就是说以供会有64个单向链表组成一个tcache，每个链表上也是与fast
bin一样都是记录的相同大小的某个size的chunk。但是与fastbin不一样的是，单向链表的长度是有限制的，不能超过7，当超过7个的时候就会往对应的bin上进行分流，同样可以通过GEF的heap
bins tcache去查看。64个链表维护的chunk大小范围为0x20-0x410,间隔是0x10.
###  Unsorted， Large 和 Small bins
Unosrted, Large 和 Small bins联系的比较紧密，他们都是在一个数组中的，而fastbin 和tcache都是有自己单独的数组的。
    /* Normal bins packed as described above */
    mchunkptr bins[NBINS * 2 - 2];
bins这个数组中的第0个元素空置，第一个元素就是指向unsorted bin list的指针，紧接着的62个元素都是指向samll bin
链表的指针，后面63个指向的是Large bin链表的指针。  
如下图所示的结构图
Unsorted bin链表，这个主要是用来存放刚被释放的chunk，被free释放掉的chunk并不会直接回到对应的fast bin或者small bin
large bin中，而是先回到unsorted bin，以供后面malloc的时候更加快速的使用。
  * 这是一个双向链表，与fast bin链表不同是它多了一个bk指针
  * 这个链表上的大小并不是固定的，任何大小的chunk都可以到这个链表上来
  * 当出现malloc_consolidate，就是一次对heap的整理，就会把unsorted bin重新放到各自对应chunk size的链表上
Small bin的每个链表存放的元素的大小的都是相同的，对于大小不大于0x400(64bit)的chunk会被放置在这个链表上
Large
Bin使用来存放超过0x400大小的chunk的，但是这些链表上的chunk的大小并不一定是相同的，而是有一个范围的，比如对于0x400到0x420(仅举例)的chunk都放在第一个large
bin的链表上。
###  Top chunk
是在当前在用的堆区的最顶部，它不是属于任何一个bin，是一个之前调用mmap或者sbrk从内核中分配的内存还剩下未用的区域。如果用户请求的size在所有的bin和tcache中都没有满足，就会从top
chunk开始分配，剩下的未用的chunk则是新的top chunk。  
如果当前用户请求的size连top chunk都满足不了，则会继续调用系统调用mmap或者sbrk扩展堆区，就是扩展top
chunk。然后再把chunk返回给用户。  
top chunk是所有分配的源头，第一个malloc肯定是从top chunk中分配的，因为此时所有的bin和tcache都是空的
###  各种bin和chunk在内存中的示意图
malloc_chunk就是chunk header，是一个chunk的开头，无论malloced或者空闲的都有这个header.
###  Main Arena
Main Arena实际上就是一个对heap的抽象的数据结构，它包含了对各种bin的定义，tcache的定义，top
chunk的定义，都是在这个数据结构中的，它在初始化的时候是作为一个全局变量保留在全局区域的。  
当我们在GEF中调用heap相关的各种命令实际上都是通过对这个变量的读取来解析的。
    gef➤  heap bins
    [+] No Tcache in this version of libc
    ────────────────────── Fastbins for arena 0x7ffff7dd1b20 ──────────────────────
    Fastbins[idx=0, size=0x10]  ←  Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE)
    Fastbins[idx=1, size=0x20] 0x00
    Fastbins[idx=2, size=0x30] 0x00
    Fastbins[idx=3, size=0x40] 0x00
    Fastbins[idx=4, size=0x50] 0x00
    Fastbins[idx=5, size=0x60] 0x00
    Fastbins[idx=6, size=0x70] 0x00
    ───────────────────── Unsorted Bin for arena 'main_arena' ─────────────────────
    [+] Found 0 chunks in unsorted bin.
    ────────────────────── Small Bins for arena 'main_arena' ──────────────────────
    [+] Found 0 chunks in 0 small non-empty bins.
    ────────────────────── Large Bins for arena 'main_arena' ──────────────────────
    [+] Found 0 chunks in 0 large non-empty bins.
    gef➤  x/20g 0x7ffff7dd1b20
    0x7ffff7dd1b20 :  0x0 0x602000
    0x7ffff7dd1b30 : 0x0 0x0
    0x7ffff7dd1b40 : 0x0 0x0
    0x7ffff7dd1b50 : 0x0 0x0
    0x7ffff7dd1b60 : 0x0 0x0
    0x7ffff7dd1b70 : 0x0 0x602120
    0x7ffff7dd1b80 : 0x0 0x7ffff7dd1b78
    0x7ffff7dd1b90 :  0x7ffff7dd1b78  0x7ffff7dd1b88
    0x7ffff7dd1ba0 :  0x7ffff7dd1b88  0x7ffff7dd1b98
    0x7ffff7dd1bb0 :  0x7ffff7dd1b98  0x7ffff7dd1ba8
###  Consolidation
由于多次的释放和malloc会不可避免的出现很多小的chunk，这就有可能有两个连续的chunk虽然都是空闲的，但是由于是两个独立的chunk，在malloc使用的时候并不能将他们作为一个chunk返回，因此就会降低内存的使用效率，为了减少碎片，就需要在合适的时候将这些相邻的空闲块给合并成一个大的chunk。
合并的函数就是malloc_consolidate, 调用它的时候就会对空闲块进行合并，那么这个函数的调用条件有什么呢:
    malloc large bin的时候，当需要很大的chunk的时候，就会调用这个函数先进行一次合并，看看会不会多出来一些可以用的chunk。
    当top chunk中的空间不够用的时候
    free函数之后，会对chunk进行前后合并，如果这个合并后的chunk size大于FASTBIN_CONSOLIDATION_THRESHOLD，也会调用一次
###  与堆利用相关的
我们前面先简单介绍了一下与堆相关的一些基本概念，虽然没有覆盖完全，但是与堆利用相关的已经基本列出，更加详细的认知需要在漏洞利用的过程中再去学习。
下面列出对漏洞利用的知识体系的基本框架
我们要想进行堆利用，就需要首先发现一个与堆相关的漏洞，UAF，堆溢出，double
free这些，然后我们通过这个漏洞去修改一些chunk，这些chunk肯定是属于某个bin
链表或者tcache中，然后我们再借用house的各种方法去实现更复杂的利用方法。虽然还有很多方法没有列出，但是我们可以先掌握这些最基本的，这也是我在这个系列文章中要覆盖到的一些方法。
## 参考
1.  
2.