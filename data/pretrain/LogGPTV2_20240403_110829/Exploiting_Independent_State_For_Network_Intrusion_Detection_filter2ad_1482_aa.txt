title:Exploiting Independent State For Network Intrusion Detection
author:Robin Sommer and
Vern Paxson
Exploiting Independent State For Network Intrusion Detection
Robin Sommer
TU M¨unchen
PI:EMAIL
Vern Paxson
ICSI/LBNL
PI:EMAIL
Abstract
Network intrusion detection systems (NIDSs) critically
rely on processing a great deal of state. Often much of this
state resides solely in the volatile processor memory acces-
sible to a single user-level process on a single machine. In
this work we highlight the power of independent state, i.e.,
internal ﬁne-grained state that can be propagated from one
instance of a NIDS to others running either concurrently or
subsequently. Independent state provides us with a wealth
of possible applications that hold promise for enhancing the
capabilities of NIDSs. We discuss an implementation of in-
dependent state for the Bro NIDS and examine how we can
then leverage independent state for distributed processing,
load parallelization, selective preservation of state across
restarts and crashes, dynamic reconﬁguration, high-level
policy maintenance, and support for proﬁling and debug-
ging. We have experimented with each of these applications
in several large environments and are now working to inte-
grate them into the sites’ operational monitoring. A perfor-
mance evaluation shows that our implementation is suitable
for use even in large-scale environments.
1 Introduction
Network intrusion detection systems (NIDSs) of any so-
phistication rely on managing a signiﬁcant amount of state.
The state reﬂects the NIDS’s model of the communications
currently active in the network and also the NIDS’s analy-
sis over time, both in the past (previous activity by hosts or
users, suspicion levels, relationships between connections)
and in the future (timers used to model protocol interac-
tions and to drive detection algorithms). Managing this
state raises signiﬁcant issues, among which are its sheer
volume [7]. Another issue that to date has received less
attention, concerns the degree to which the state is often
tied to a single executing process. That is, often much of a
NIDS’s state resides solely in the volatile processor mem-
ory accessible to a single user-level process on a single ma-
chine. Generally, any state that exists more broadly than
in the context of a single process is a minor subset of the
NIDS process’s full state: either higher-level results (often
just alerts) sent between processes to facilitate correlation or
aggregation, or log ﬁles written to disk for processing in the
future. The much richer (and bulkier) internal state of the
NIDS remains exactly that, internal. It cannot be accessed
by other processes unless a special means is provided for
doing so, and it is permanently lost upon termination of the
NIDS (which, due to a crash, may happen unexpectedly).
In this work we argue for the great utility of incorpo-
rating independent state into intrusion detection systems.
The goal is to enable much of the semantically rich, de-
tailed state that hitherto could exist only within a single ex-
ecuting process to become independent of that process. We
consider two basic types of independent state. Spatially in-
dependent state can be propagated from one instance of a
NIDS to other, concurrently executing, instances. Tempo-
rally independent state continues to exist after an instance
(or all instances) of a NIDS has exited. For both types of
independence, the state essentially exists “outside” of any
particular process.
Our contribution is not the fundamental notion of state
that can be shared between processes or accessed over
time—that already appears in numerous existing systems—
but rather the beneﬁts of doing so within a framework that
(i) is uniﬁed, i.e., it covers all of the systems’ state in the
same way, and (ii) encompasses ﬁne-grained state. This
second is particularly important: by keeping ﬁne-grained
state, rather than only aggregated state such as alerts or ac-
tivity summaries, we can continue to process the indepen-
dent state using the full set of mechanisms provided by the
system. We explore such a framework by implementing in-
dependent state for the Bro intrusion detection system [16].
Bro is a highly stateful NIDS. Its basic model has two
main layers: event generation and policy script execu-
tion. Events are generated by an event engine which per-
forms policy-neutral analysis of network trafﬁc at differ-
ent semantic levels. For example, there are events for
attempted/established/terminated/rejected connections, the
requests and replies for a number of applications, and suc-
cessful and unsuccessful user authentication. The user
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:11:05 UTC from IEEE Xplore.  Restrictions apply. 
writes policy scripts using a specialized, richly-typed high-
level language. These scripts execute on the events gener-
ated by the event engine and codify the actions the NIDS
should take: updating data structures describing the activity
seen on the network, sending out real-time alerts, record-
ing activity transcripts to ﬁles, and executing programs as
a means of reactive response. Thus, both the event engine
layer and the policy script layer generate and manage a great
deal of state. In this work, we strive to convert all of this
state into independent state.
Independent, ﬁne-grained state provides us with a wealth
of possible applications that hold great promise for en-
hancing the power of a NIDS. These include coordinating
distributed monitoring; increasing NIDS performance by
splitting the analysis load across multiple CPUs in a vari-
ety of ways; selectively preserving key state across restarts
and crashes; dynamically reconﬁguring the operation of the
NIDS on-the-ﬂy; tracking the usage over time of the ele-
ments of a NIDS’s scripts to support high-level policy main-
tenance; and enabling detailed proﬁling and debugging. We
have implemented all of these and will discuss them in
depth.
As a ﬁrst example, consider a set of NIDSs at different
locations of a network, each able to identify suspicious ac-
tivity in its segment. Traditionally, either each NIDS works
independently of its peers, or there is an explicit mechanism
to send, receive and incorporate alerts. With independent
state, it is possible to transparently leverage the others’ re-
sults. We simply tell the systems what state should be syn-
chronized among them. This state can span the range of
individual analysis variables, low-level (e.g., packet signa-
ture match) or high-level (e.g., successful SSL negotiation)
events, large tables storing accumulated context, or oper-
ator alerts. We further emphasize that this is only one of
many applications for independent state, as we will develop
subsequently.
In the next section, we give an overview of previous work
related to our efforts. In §3 we then discuss the design and
implementation of independent state within our architec-
ture. We examine in §4 the powerful features and applica-
tions mentioned above that ﬁne-grained independent state
enables. In §5 we evaluate the communication performance
of the architecture, and we summarize in §6.
2 Related Work
While the unifying concept of independent state has not
been previously formulated in network intrusion detection
research, some of its aspects can be found in earlier NIDSs.
A number of NIDSs facilitate distributing the detection pro-
cessing across multiple locations in a network. They em-
ploy different approaches to do so, but distribution implic-
itly requires the exchange of state.
NetSTAT [26] describes attack scenarios using state tran-
sition diagrams.
If, due to the characteristics of an at-
tack scenario, a single NetSTAT probe is unable to de-
tect an attack solely by itself, it is conﬁgured with a par-
tial scenario and communicates its analysis to other probes,
thereby transferring state. MetaSTAT [27] adds dynamic
reconﬁguration capabilities to the STAT framework.
Emerald [17] hierarchically organizes monitors which
exchange messages to propagate results and subscribe to
services. GrIDS [23] models large-scale attacks by activ-
ity graphs. Its components monitor trafﬁc at multiple loca-
tions and communicate by sending or requesting informa-
tion. AAFID [22] builds on autonomous agents which com-
municate their results to hierarchically organized monitors.
AAFID’s design speciﬁcally addresses dynamic reconﬁgu-
ration and acknowledges the utility of persistent state, al-
though the prototype does not implement it.
The “Intrusion Detection Message Exchange Format”
(IDMEF [9]) aims at deﬁning a standard format to exchange
alerts between different NIDSs.
It differs from our work
by its focus on interoperability and its restriction to the ex-
change of high-level state.
By setting up a network of communicating NIDSs, we
are building a distributed system. The mechanisms that we
employ (e.g., serialization, persistence, and synchroniza-
tion) are well-established in other areas (see, e.g., [24, 21]).
Applying them to network intrusion detection provides us
with a wide variety of new applications.
3 Design and Implementation
for
We ﬁrst discuss our main tool
implementing
independent-state: a serialization framework. We next turn
to how the user interacts with the framework by discussing
its script-level interface, and ﬁnish with a discussion of ad-
dressing the need for secure and robust communication be-
tween concurrent NIDS processes.
3.1 Serialization Framework
For Bro, there are two main layers of operation, each of
which stores a signiﬁcant amount of state. The C++ event
engine layer analyzes network trafﬁc in a policy-neutral
fashion, producing a stream of events reﬂecting the activ-
ity present in the trafﬁc stream. The activity encompasses
different semantic levels:
individual packets, byte-stream
signatures, connections, applications, and interrelationships
between connections (e.g., stepping stones [28]). While
the event engine’s operation is tunable by redeﬁning user-
visible parameters, its algorithms—and therefore the types
of state it stores—are ﬁxed. On the other hand, the pol-
icy script layer, which executes scripts written in a custom
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:11:05 UTC from IEEE Xplore.  Restrictions apply. 
language over the stream of events, allows the user to ar-
bitrarily change and extend the standard set of scripts (and
in fact the user is expected to do so, to express site-speciﬁc
policy). Since this layer equips the user with a full script-
ing language providing a rich set of control constructs and
compound data types, the corresponding types of state are
only determined when the scripts are loaded at run-time.
There are four main types of internal, event-engine state
in Bro: connection state, analyzer state, timers, and control
state. The policy script layer includes six types of state:
the scripts themselves, data stored by the scripts, operations
on this data (see below for why we term these a form of
“state”), event generation, function calls, and byte-level sig-
natures.1
The main mechanism for making the state independent
is a serialization framework that enables us to convert all
of Bro’s main data structures into a self-contained binary
representation and back. Once we have this, we can, for
example, make state temporally independent by serializing
it into a ﬁle at the termination of a Bro instance. A new
instance can then read it back upon start-up. Similarly, to
make state spatially independent, we can send it over the
network to some remote instance.
Making object-oriented data structures serializable is,
by itself, fairly straightforward and well-established prac-
tice [21]. However, adding full serializability to a com-
plex system like Bro, which was not designed with this in
mind, raises numerous subtle issues we must address. One
of the basic problems that arise is the time needed to serial-
ize state. Bro is a realtime system that must keep up with a
high-volume stream of packets. If it spends too much time
on other things than processing packets, it risks dropping
packets. Therefore, we implemented incremental serializa-
tion: serialization proceeds in steps intermixed with packet
processing. In this way, it takes more time to ﬁnish the seri-
alization, but our ability to keep pace with the packet stream
improves.
Due to limited space we must omit further discussion
of a number of other issues (e.g., incremental serializa-
tion, restoring references to shallow-copied objects, using
process-independent object names to synchronize multiple
processes, locally rescheduling timers instantiated by other
instances of the NIDS). See [19] for more details.
3.2 Using Independent State
The framework presented in the previous section is in-
ternal to Bro’s event engine and hidden from the user, while
the interface to the framework is deﬁned via new seman-
tics expressed at the policy script level. The development
of the elements of the interface has been mainly driven by
the needs of particular applications, and thus will continue
1We do not discuss signatures further due to limited space.
to be extended as we gain more experience with using it.
We note that having the general serialization framework in
place, the semantic interface was quite easy to add, and we
expect this to hold for future extensions, too.
First, we illustrate how the user can create temporally-
independent state, which essentially means writing differ-
ent elements of the NIDS’s state into ﬁles and reading them
back again later, possibly after having ﬁrst modiﬁed them
using other instances of the NIDS. We then discuss control-
ling spatially-independent state, which is done in the con-
text of communication between multiple instances of the
NIDS. All the language constructs and functions are acces-
sible at the script-level. To ease their use, we have also
developed standard scripts to accomplish a number of com-
mon tasks.
3.2.1 Temporally Independent State
To make state temporally independent, we store it in ﬁles.
These ﬁles can then be read by another instance at a later
point of time.
The most obvious use of temporally independent state
is to make data persistent. The data is stored into a set of
ﬁles just before a Bro process terminates, and re-read when
a new instance starts up. Instead of storing all global data
per default, we let the user selectively deﬁne which script-
level data to save by adding an attribute &persistent to
its type declaration. For example,
global saw_Blaster: set[addr] &persistent;
declares a set of addresses for which any changes to the
set will be propagated to future invocations of Bro. Such a
set is useful, for example, in tracking which addresses have
already generated alerts in the past in order to reduce the
volume of future alerts. Furthermore, because temporally-
independent state includes its associated timestamps and
timers, we could also use:
global saw_Blaster: set[addr]
&persistent &create_expire=30days;
and Bro will delete each set element 30 days after it was
added, so we will be reminded of all still-active Blasters
once a month.
The reason we structure the interface so that the user ex-
plicitly marks which state to keep persistent, with all other
state by default remaining non-persistent, is both that the
volume of the entire set of state can be very large, and also
that we ﬁnd that policy scripts are often written in a style
that presumes that state exists only during the execution of
a single instance of Bro. We return to this point when dis-
cussing checkpointing in §4.1.
Along with &persistent, we also added a function
make connection persistent, which tells Bro to
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:11:05 UTC from IEEE Xplore.  Restrictions apply. 
store the associated state of a particular connection. In ad-
dition to automatically writing all persistent state at termi-
nation, the new script function checkpoint can be called
anytime during operation. It uses incremental serialization
to avoid packet drops and can be called by another stan-
dard policy script to save Bro’s state at regular time inter-
vals. Similarly, the new function rescan state reads
state back from disk. One application here is to transfer
data between two Bro instances. Another is more powerful:
By copying a state ﬁle into that of a running instance, we
can change its conﬁguration on-the-ﬂy—both the values of
its global variables and also the values of its functions and
event handlers, i.e., we can dynamically change the code it
executes.
Along with script variables and function deﬁnitions, we
also developed a way to make event generation temporally-
independent. By calling the function capture events,
our policy script can tell Bro to write all events raised during
run-time into a ﬁle. One use is to later replay these events
in another instance of Bro for debugging and exploring al-