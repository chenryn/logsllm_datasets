# Title: Exploiting Independent State for Network Intrusion Detection

## Authors
- Robin Sommer, TU München, PI:EMAIL
- Vern Paxson, ICSI/LBNL, PI:EMAIL

## Abstract
Network intrusion detection systems (NIDSs) rely heavily on processing a significant amount of state. Often, this state is confined to the volatile processor memory accessible to a single user-level process on a single machine. In this work, we highlight the power of independent state, which is internal, fine-grained state that can be propagated from one NIDS instance to others running concurrently or subsequently. Independent state offers numerous applications that can enhance NIDS capabilities. We discuss an implementation of independent state for the Bro NIDS and explore its use in distributed processing, load parallelization, selective state preservation across restarts and crashes, dynamic reconfiguration, high-level policy maintenance, and support for profiling and debugging. Our experiments in large environments demonstrate the feasibility of integrating these features into operational monitoring. Performance evaluations show that our implementation is suitable even for large-scale environments.

## 1. Introduction
Sophisticated network intrusion detection systems (NIDSs) manage a significant amount of state, reflecting the current network communications and the NIDS's analysis over time. This state includes past and future activities, suspicion levels, and relationships between connections. Managing this state raises significant issues, particularly its volume and the fact that it is often tied to a single executing process. The rich, detailed internal state of the NIDS is typically confined to the volatile memory of a single process and is lost upon termination.

In this work, we advocate for the incorporation of independent state into NIDSs. Independent state allows the semantically rich, detailed state that previously existed only within a single process to become independent of that process. We consider two types of independent state: spatially independent state, which can be propagated between concurrently executing NIDS instances, and temporally independent state, which persists after an instance has exited.

Our contribution is not the fundamental notion of shared state but rather the benefits of a unified framework that covers all system state and encompasses fine-grained state. By maintaining fine-grained state, we can continue to process independent state using the full set of mechanisms provided by the system. We implement independent state for the Bro NIDS, a highly stateful system with event generation and policy script execution layers.

Independent, fine-grained state provides numerous applications, including coordinating distributed monitoring, increasing NIDS performance through load parallelization, preserving key state across restarts and crashes, dynamically reconfiguring NIDS operations, supporting high-level policy maintenance, and enabling detailed profiling and debugging. We have implemented these features and will discuss them in detail.

For example, consider multiple NIDSs at different network locations, each capable of identifying suspicious activity in its segment. Traditionally, either each NIDS operates independently, or there is an explicit mechanism to exchange alerts. With independent state, NIDSs can transparently leverage each other's results by synchronizing specific state elements, such as individual analysis variables, low-level events, high-level events, large context tables, or operator alerts.

In the following sections, we review related work, discuss the design and implementation of independent state within our architecture, examine the powerful features and applications enabled by fine-grained independent state, evaluate the communication performance of the architecture, and summarize our findings.

## 2. Related Work
While the concept of independent state is novel in network intrusion detection research, some aspects can be found in earlier NIDSs. Several NIDSs facilitate distributing detection processing across multiple network locations, implicitly requiring state exchange.

- **NetSTAT** [26] uses state transition diagrams to describe attack scenarios. If a single NetSTAT probe cannot detect an attack, it communicates its partial analysis to other probes.
- **MetaSTAT** [27] adds dynamic reconfiguration capabilities to the STAT framework.
- **Emerald** [17] organizes monitors hierarchically, exchanging messages to propagate results and subscribe to services.
- **GrIDS** [23] models large-scale attacks using activity graphs, with components communicating by sending or requesting information.
- **AAFID** [22] uses autonomous agents to communicate results to hierarchically organized monitors, addressing dynamic reconfiguration and persistent state, though the prototype does not implement it.
- **IDMEF** [9] aims to standardize alert exchange between NIDSs, focusing on interoperability and high-level state exchange.

By setting up a network of communicating NIDSs, we build a distributed system. The mechanisms we employ, such as serialization, persistence, and synchronization, are well-established in other areas [24, 21]. Applying them to NIDSs provides a wide variety of new applications.

## 3. Design and Implementation

### 3.1 Serialization Framework
Bro has two main layers: the C++ event engine and the policy script layer. The event engine analyzes network traffic in a policy-neutral manner, generating events reflecting various semantic levels. The policy script layer executes custom scripts over the event stream, allowing users to change and extend the standard set of scripts.

There are four main types of internal, event-engine state in Bro: connection state, analyzer state, timers, and control state. The policy script layer includes six types of state: scripts, data stored by scripts, operations on this data, event generation, function calls, and byte-level signatures.

The main mechanism for making state independent is a serialization framework that converts Bro's data structures into a self-contained binary representation. This allows us to make state temporally independent by serializing it into a file at termination and reading it back upon startup. Similarly, to make state spatially independent, we can send it over the network to remote instances.

Adding full serializability to a complex system like Bro, which was not designed for this, raises subtle issues. One challenge is the time required for serialization. Bro is a real-time system that must keep up with a high-volume packet stream. To address this, we implemented incremental serialization, intermixing serialization steps with packet processing.

### 3.2 Using Independent State
The serialization framework is internal to Bro’s event engine and hidden from the user, while the interface is defined via new semantics at the policy script level. The interface development is driven by application needs and will be extended as we gain more experience.

#### 3.2.1 Temporally Independent State
To make state temporally independent, we store it in files. These files can be read by another instance at a later time. The most obvious use is to make data persistent. Data is stored in files before a Bro process terminates and re-read when a new instance starts. Users can selectively define which script-level data to save by adding a `&persistent` attribute to type declarations. For example:

```bro
global saw_Blaster: set[addr] &persistent;
```

This declares a set of addresses whose changes will be propagated to future Bro invocations. Additionally, we can specify expiration times:

```bro
global saw_Blaster: set[addr] &persistent &create_expire=30days;
```

This deletes each set element 30 days after it was added. We structure the interface so that users explicitly mark which state to keep persistent, as the entire state volume can be very large and scripts often assume state exists only during a single instance.

We also added a `make_connection_persistent` function to store the state of a particular connection. The `checkpoint` function can be called anytime during operation to save Bro’s state incrementally, avoiding packet drops. The `rescan_state` function reads state back from disk, allowing data transfer between Bro instances or on-the-fly configuration changes.

Along with script variables and function definitions, we developed a way to make event generation temporally independent. The `capture_events` function writes all events raised during run-time into a file, which can be replayed for debugging and exploration.