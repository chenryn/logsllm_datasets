说明这里存在ssti漏洞，然后就可以用类似的语法删除指定文件了
然后在评论区刷新以后就会执行payload了
**了解安全文档**
有时候官方文档除了会提供模板引擎的基础语法外，还会设置很多警示项以帮助开发者提高系统安全性，但是往往这些警示项也会为攻击者提供思路。例如ERB引擎的安全文档指出可以列出所有目录，然后按如下方式读取任意文件
**配套靶场：利用文档发动SSTI攻击**
首先因为题目中没有告诉我们这是哪一款模板引擎，所以我们要让它们使用的模板语句故意报错，从报错信息中我们一般可以知道使用的是哪种模板引擎，在编辑模板的${}模板表达式中随便输入些什么，就会触发报错
然后我们就可以对症下药了，我们需要去查阅一下相关的文档，看看有没有相关警示项，我们直接去搜freemarker
ssti，找到一个利用内置函数执行os命令，payload模板如下  
` ${ex("[payload]")}`  
于是我们在编辑模板的地方将payload写入模板表达式
这样当模板引擎执行表达式的时候就会执行删除命令了
**查找已知利用文章**
顾名思义，就是当知道使用的是哪种模板引擎后可以利用搜索引擎查找是否有前人总结的漏洞利用方法，这样可以节约很多查阅文档的时间
**配套靶场：利用已知利用文章发动未知语言的SSTI攻击**
因为不知道使用的是哪一款模板引擎，所以我们需要输入各种版本的错误模板表达式以触发报错
然后我们就利用搜索引擎查找一下有没有相关的现成的利用方式，搜到了一个知名的payload模板
    wrtz{{#with "s" as |string|}}
      {{#with "e"}}
        {{#with split as |conslist|}}
          {{this.pop}}
          {{this.push (lookup string.sub "constructor")}}
          {{this.pop}}
          {{#with string.split as |codelist|}}
            {{this.pop}}
            {{this.push "return require('child_process').exec('[payload]');"}}
            {{this.pop}}
            {{#each conslist}}
              {{#with (string.sub.apply 0 codelist)}}
                {{this}}
              {{/with}}
            {{/each}}
          {{/with}}
        {{/with}}
      {{/with}}
    {{/with}}
因为是通过传入GET参数传入payload，所以我们需要将整个payload做一个URL编码
**探索**
如果我们通过查找资料已经找不到有效的攻击手段了怎么办，下一步就是探索环境并尝试发现有权访问的所有对象。很多模板引擎存在如”self”和”environment”之类的对象，该类对象包含该类模板引擎支持的所有对象、方法和属性，利用这些因素可以生成很多意想不到的对象。例如基于Java的模板语言可以使用以下注入列出环境中的所有变量  
`${T(java.lang.System).getenv()}`  
Burp Pro中的Intruder已经内置了用于暴力破解变量名的词表。
**开发者提供的对象**
有时候网站会包含一些内置的和开发人员定制的对象，这些对象往往可能会暴露一些敏感的方法，还是要借助文档或文章的帮助。并且SSTI也不是总能远程执行命令的，有时候可以进行目录遍历等同样高风险的攻击获取敏感数据的访问权限。
**配套靶场：通过开发者提供的对象利用SSTI触发信息泄漏**
先用fuzz字符串(${{<%[%’”}}%)触发报错判断模板引擎的类型
经过查阅文档得知，有一个内置的模板标签{% debug %}，可以显示调试信息
然后又查阅文档得知，{{settings.SECRET_KEY}}表达式可以查看指定的环境变量
我们就顺利地知道了指定的环境变量值
**构造自定义利用**
有时候通过现有的公开的利用方式无法触发ssti漏洞，比如模板引擎防止在沙箱环境中，此时需要审计每个功能点的可利用性来发现隐藏的漏洞点
**使用对象链构造自定义利用**
通过查阅文档，观察不同对象返回的对象和可用的方法可以构造一条对象引用链，从而发现不易发现的ssti漏洞点，就像反序列化的工具链一样。例如，在基于Java的模板引擎Velocity中，可以访问名为class的ClassTool对象。研究文档表明可以链接class.inspect()方法和class.type属性来获取对任意对象的引用。如下所示  
`$class.inspect("java.lang.Runtime").type.getRuntime().exec("bad-stuff-here")`
**配套靶场：在沙箱环境中发动SSTI攻击**
首先我们通过查阅资料知道对象类下面有一个getClass()方法，该方法会返回当前对象的内存管理(runtime)类，然后一路查找下去，可以构造如下利用链
然后我们转一下ASCII就能得到要提交的文件内容了
**使用开发者提供的对象构造对象链**
有时候即使有很多文档，但是没有有效的对象可以用来构造对象链，如果开发者针对当前目标创建了特定的对象，则可以通过不断观察它们并尝试构造漏洞。下面我们通过一道靶场来深入理解。
**配套靶场：自定义利用发动SSTI攻击**
我们看到用户页面有一个功能点使用模板引擎，发现开发者提供的是user对象，现在需要基于user对象来构造漏洞，先看一下上传头像功能点，上传一个无效的图片文件触发报错
从报错信息来看，我们知道有两个文件，一个是/home/carlos/User.php，一个是/home/carlos/avatar_upload.php，前者先不管，后面可能有用，后者中包含User对象的setAvatar方法，这个方法需要两个参数，一个是文件路径，一个是类型，我们知道修改显示名称功能点处有对User对象的控制权，所以我们选择利用这个控制权执行setAvatar方法，将我们想读取的文件读取出来，于是进行如下操作
执行完setAvatar方法后需要刷新一下页面才能在第二个包的响应中看到我们要读取的文件，下面我们用类似的方法读取一下/home/carlos/User.php文件，看看里面有没有可利用的东西
我们找到了这个函数，这个函数可以删除当前设置的头像文件，那么如果我们把头像文件设置为目标文件，则可以利用这个函数删除它。
## 如何缓解SSTI攻击？
避免引入SSTI漏洞的最简单方法之一是始终使用“无逻辑”模板引擎，如Mustache，除非绝对必要。尽可能将逻辑层与渲染层分离，可以大大减少面临最危险的基于模板的攻击的风险。另一种措施是仅在沙盒环境中执行用户的代码，在该环境中，潜在危险的模块和功能已被完全删除。但是沙箱也会存在被绕过的风险。最后，另一种补充方法是通过在封闭的Docker容器中部署模板环境来部署沙箱。
## 总结
以上就是梨子带你刷burpsuite官方网络安全学院靶场(练兵场)系列之高级漏洞篇 –
服务器端模板注入(SSTI)专题的全部内容啦，本专题主要讲了SSTI的形成原理，以及包括探测、识别、利用(阅读、探索、构建自定义攻击)多个步骤讲解如何发现并利用SSTI漏洞，最后介绍了如何缓解这类攻击等，感兴趣的同学可以在评论区进行讨论，嘻嘻嘻。