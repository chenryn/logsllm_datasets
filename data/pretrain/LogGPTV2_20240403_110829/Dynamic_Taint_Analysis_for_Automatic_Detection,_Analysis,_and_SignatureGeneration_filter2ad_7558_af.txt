from disk, and checks each control transfer to ensure that
the destination is to a basic block that has not been modi-
ﬁed. Thus, Program Shepherding can prevent code injec-
tion attacks. It also prevents some existing code attacks by
ensuring that control transfers to a library can only go to
exported entry points, and that return addresses point
to just after a call instruction. However, these tech-
niques do not prevent many existing-code attacks (e.g.,
overwrite a function pointer to the exec library call). In
contrast, TaintCheck can prevent these existing-code at-
tacks. Moreover, TaintCheck, via dynamic taint analysis,
provides detailed information how the vulnerability is ex-
ploited. Program Shepherding does not.
Other runtime detection mechanisms Many ap-
proaches have been proposed to detect when certain vul-
nerabilities are exploited by attacks. Most of these pre-
vious mechanisms require source code or special recom-
pilation of the program, such as StackGuard [14], Point-
Guard [13], full-bounds check [19, 37], LibsafePlus [5],
FormatGuard [12], and CCured [27]. Many of them re-
quire recompiling the libraries [19, 37], modifying the
original source code, or are not compatible with some pro-
grams [27, 13]. These issues hinder the deployment and
the applicability of these methods in attack defense for
commodity software, since source code is often unavail-
able.
Several other approaches for runtime attack detection
have been proposed that do not require source code
or specially compiled binary programs, such as Lib-
Safe [6], LibFormat [36], Program Shepherding [22], and
the Nethercote-Fitzhardinge bounds check [28]. However,
they fail to detect many types of attacks. For example,
LibSafe only catches buffer overﬂows related to certain
string-handling functions, LibFormat only detects certain
format modiﬁers in format strings and thus can have high
false positives and false negatives, and the Nethercote-
Fitzhardinge bounds check has signiﬁcant false positives
and false negatives.
In contrast, TaintCheck detects a
wider range of attacks and incurs fewer false positives.
Other approaches have been proposed for more coarse-
grained attack detection, including system call interpo-
sition (e.g.
Systrace [33], GSWTK [17], Tron [7],
Janus [18], and MAPbox [3]). These approaches detect
attacks by detecting anomalous system call sequences in a
program. They do not give detailed information about the
vulnerability and how it is exploited, and require building
models for each protected program.
Other taint-based approaches Static taint analysis has
been used to ﬁnd bugs in C programs [16, 39, 46] or to
identify potentially sensitive data in Scrash [9]. Perl [2]
does runtime taint checking to see whether data from un-
trusted sources are used in security-sensitive ways such as
as an argument to a system call.
Chow et. al.
independently and concurrently proposed
to use whole-system simulation with tainting analysis to
analyze how sensitive data are handled in large programs
such as Apache and Emacs [11]. The tainting propagation
in TaintCheck is similar to the one in [11]. However,
their work focuses on analyzing the lifetime of sensitive
data such as passwords, where our work concerns attack
detection and defense.
Minos independently and concurrently proposed hard-
ware extension to perform Biba-like data integrity check
of control ﬂow to detect attacks at runtime [15]. Their
work uses hardware and OS modiﬁcations to perform
Biba integrity checks at the whole-system level. In con-
trast, TaintCheck requires no hardware or OS modiﬁca-
tions, and can be very ﬂexible and ﬁne-grained to detect
attacks that were not addressed in Minos such as format
string vulnerabilities3 and attacks that overwrite security-
sensitive variables such as system call arguments. Taint-
Check is also able to perform more detailed analysis of
3Minos can detect some forms of format string vulnerabilities if they
alter the control ﬂow, however, our work can detect format string vulner-
abilities even when they do not alter control ﬂow.
detected attacks, which can be used for automatic signa-
ture generation.
Other signature generation approaches and defense
systems Several automatic signature generation meth-
ods have recently been proposed,
including Early-
bird [41], Honeycomb [24], and Autograph [21]. Early-
bird [41] monitors trafﬁc and generates signatures which
consist of the Rabin ﬁngerprints of the most commonly
occurring 39 byte substrings in the monitored trafﬁc. Hon-
eycomb [24] classiﬁes trafﬁc that is sent to a honeypot as
malicious, and generates signatures based on the longest
common substrings found in trafﬁc sent to the honeypot.
Autograph [21] uses distributed monitoring points to de-
termine what hosts are performing port scans. All trafﬁc
from hosts that have been seen performing port scans is
classiﬁed as malicious. Autograph then uses a ﬁle chunk-
ing technique to split requests into blocks, and generates
a signature consisting of the most common blocks seen in
malicious trafﬁc.
As we showed in Section 6, TaintCheck can be used as
a classiﬁer to reduce the false positive and/or false nega-
tive rates of the classiﬁers used in these systems. Taint-
Check can also provide semantic analysis of attack pay-
loads, which can be used to generate signatures with fewer
samples than by using content-analysis alone. Finally,
TaintCheck can also be used to verify the signatures and
alarms produced by such systems.
Shield [45] presents an alternative approach to content-
based ﬁltering. Shield uses the characteristics of a vul-
nerability to manually generate a signature for any exploit
of that vulnerability before an exploit is seen in the wild.
This is a promising approach, but it does not help in the
case that the worm utilizes a vulnerability that was previ-
ously unknown, or only recently became known.
Sidiroglou and Keromytis propose a worm vaccine ar-
chitecture to automatically generate patches for vulnera-
bilities [40].
8. Conclusion
In order to combat the rapid spread of a new worm be-
fore it can compromise a large number of machines, it is
necessary to have automatic attack detection and defense
mechanisms.
In this paper we have proposed dynamic
taint analysis and shown how it can be used to detect and
analyze most types of software exploits, without requir-
ing source code or special compilation of a program, thus
allowing it to easily be used on commodity software. It
reliably detects many attacks, and we have found no false
positives in our tests. In addition, because it monitors the
execution of a program at a ﬁne-grained level, TaintCheck
can be used to provide additional information about the
attack. It is currently able to identify the input that caused
the exploit, show how the malicious input led to the ex-
ploit at a processor-instruction level, and identify the value
used to overwrite the protected data (e.g.
the return ad-
dress).
Furthermore, we have shown that TaintCheck is particu-
larly useful in an automatic signature generation system—
it can be used to enable semantic analysis based signature
generation, enhance content pattern extraction based sig-
nature generation, and verify the quality of generated sig-
natures.
9. Acknowledgments
We would like to thank David Brumley, Mike Bur-
rows, Jedediah Crandall, Debin Gao, Brad Karp, Angelos
Keromytis, Nicholas Nethercote, Jonathon Shapiro, Peter
Szor, Helen Wang, Felix Wu, Avi Yaar, and Lidong Zhou
for providing feedback and assistance on this project. We
also thank the anonymous reviewers for their insightful
feedback.
References
[1] ISC innd 2.x remote buffer overﬂow vulnerability. http:
//securityfocus.com/bid/1316.
[2] Perl security manual page. http://www.perldoc.
com.
[3] A. Acharya and M. Raje. MAPbox: Using parameterized
behavior classes to conﬁne applications. In the Proceedings
9th USENIX Security Symposium, 2000.
[4] H. Agrawal and J. Horgan. Dynamic program slicing. In
Proc. SIGPLAN, 1990.
[5] K. Avijit, P. Gupta, and D. Gupta. Tied, libsafeplus: Tools
for runtime buffer overﬂow protection. In USENIX Security
Symposium, August 2004.
[6] A. Baratloo, N. Singh, and T. Tsai. Transparent run-time
defense against stack smashing attacks. In USENIX Annual
Technical Conference 2000, 2000.
[7] A. Berman, V. Bourassa, and E. Selberg. Tron: Process-
speciﬁc ﬁle protection for the unix operating system. In the
Proceedings of the USENIX Technical Conference on UNIX
and Advanced Computing Systems, 1995.
[8] S. Bhatkar, D. C. DuVarney, and R. Sekar. Address obfus-
cation: An efﬁcient approach to combat a broad range of
memory error exploits.
In USENIX Security Symposium,
2003.
[9] P. Broadwell, M. Harren, and N. Sastry. Scrash: A system
for generating security crash information. In the Proceed-
ings of the 12th USENIX Security Symposium, 2003.
[10] M. Chew and D. Song. Mitigating buffer overﬂows by op-
erating system randomization. Technical Report CMU-CS-
02-197, Carnegie Mellon University, December 2002.
[11] J. Chow, B. Pfaff, T. Garﬁnk el, K. Christopher, and
M. Rosenblum. Understanding data lifetime via whole sys-
tem simulation. In USENIX Security Symposium, August
2004.
[12] C. Cowan, M. Barringer, S. Beattie, and G. Kroah-
Hartman. FormatGuard: automatic protection from printf
format string vulnerabilities.
USENIX Security Symposium, August 2001.
In Proceedings of the 10th
[13] C. Cowan, S. Beattie, J. Johansen, and P. Wagle. Point-
Guard: Protecting pointers from buffer overﬂow vulnera-
bilities. In 12th USENIX Security Symposium, 2003.
[14] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beat-
tie, A. Grier, P. Wagle, Q. Zhang, and H. Hinton. Stack-
Guard: automatic adaptive detection and prevention of
buffer-overﬂow attacks. In Proceedings of the 7th USENIX
Security Symposium, January 1998.
[15] J. R. Crandall and F. T. Chong. Minos: Architectural sup-
port for software security through control data integrity. In
To appear in International Symposium on Microarchitec-
ture, December 2004.
[16] J. Foster, M. Fahndrich, and A. Aiken. A theory of type
qualiﬁers.
In Proceedings of the ACM SIGPLAN Confer-
ence on Programming Language Design and Implementa-
tion (PLDI), 1999.
[17] T. Fraser, L. Badger, and M. Feldman. Hardening COTS
software with generic software wrappers. In the Proceed-
ings of the IEEE Symposium on Security and Privacy, pages
2–16, 1999.
[18] I. Goldberg, D. Wagner, R. Thomas, and E. A. Brewer. A
secure environment for untrusted helper applications.
In
the Proceedings of the 6th USENIX Security Symposium,
San Jose, CA, USA, 1996.
[19] R. Jones and P. Kelly. Backwards-compatible bounds
checking for arrays and pointers in C programs.
In Pro-
ceedings of the Third International Workshop on Automated
Debugging, 1995.
[20] G. S. Kc, A. D. Keromytis, and V. Prevelakis. Countering
code-injection attacks with instruction-set randomization.
In Proceedings of the 10th ACM conference on Computer
and Communication Security, 2003.
[21] H.-A. Kim and B. Karp. Autograph: toward automated,
distributed worm signature detection. In Proceedings of the
13th USENIX Security Symposium, August 2004.
[22] V. Kiriansky, D. Bruening, and S. Amarasinghe. Secure
execution via program shepherding. In Proceedings of the
11th USENIX Security Symposium, August 2002.
[23] B. Korel and J. Laski. Dynamic slicing of computer pro-
grams. In J. Systems and Software, volume 13, 1990.
[24] C. Kreibich and J. Crowcroft. Honeycomb - creating in-
trusion detection signatures using honeypots. In Proceed-
ings of the Second Workshop on Hot Topics in Networks
(HotNets-II), November 2003.
[25] D. Moore, V. Paxson, S. Savage, C. Shannon, S. Staniford,
and N. Weaver. Inside the slammer worm. In IEEE Security
and Privacy, volume 1, 2003.
[26] D. Moore, C. Shannon, G. Voelker, and S. Savage. Internet
quarantine: Requirements for containing self-propagating
code. In 2003 IEEE Infocom Conference, 2003.
[27] G. C. Necula, S. McPeak, and W. Weimer. CCured: type-
safe retroﬁtting of legacy code. In Proceedings of the Sym-
posium on Principles of Programming Languages, 2002.
[28] N. Nethercote and J. Fitzhardinge. Bounds-checking entire
programs without recompiling. In Proceedings of the Sec-
ond Workshop on Semantics, Program Analysis, and Com-
puting Environments for Memory Management (SPACE
2004), Venice, Italy, Jan. 2004. (Proceedings not formally
published.).
[29] N. Nethercote and J. Seward. Valgrind: A program super-
vision framework. In Proceedings of the Third Workshop
on Runtime Veriﬁcation (RV’03), Boulder, Colorado, USA,
July 2003.
[30] A. Pasupulati, J. Coit, K. Levitt, and F. Wu. Buttercup:
On network-based detection of polymorphic buffer over-
ﬂow vulnerabilities. In IEEE/IFIP Network Operation and
Management Symposium, May 2004.
[31] V. Paxson. Bro: a system for detecting network intruders in
real-time. Computer Networks, 31(23-24), December 1999.
[32] T. S. Project. Snort, the open-source network intrusion de-
tection system. http://www.snort.org/.
[33] N. Provos. Improving host security with system call poli-
cies. In the Proceedings of the 12th USENIX Security Sym-
posium, 2003.
[34] r code. ATPhttpd exploit.
http://www.cotse.
com/mailing-lists/todays/att-0003/
01-atphttp0x06.c.
[35] Y. Ramin. ATPhttpd. http://www.redshift.com/
˜yramin/atp/atphttpd/.
[36] T.
J. Robbins.
libformat.
http://www.
securityfocus.com/tools/1818, 2001.
[37] O. Ruwase and M. Lam. A practical dynamic buffer over-
ﬂow detector.
In Proceedings of the 11th Annual Net-
work and Distributed System Security Symposium, Febru-
ary 2004.
[38] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu,
and D. Boneh. On the effectiveness of address space ran-
domization. In ACM Computer and Communication Secu-
rity Symposium, 2004.
[39] U. Shankar, K. Talwar, J. Foster, and D. Wagner. Detecting
In Pro-
format-string vulnerabilities with type qualiﬁers.
ceedings of the 10th USENIX Security Symposium, 2001.
[40] S. Sidiroglou and A. D. Keromytis. A network worm vac-
cine architecture. In Proceedings of the IEEE International
Workshops on Enabling Technologies: Infrastructure for
Collaborative Enterprises (WETICE), Workshop on Enter-
prise Security, pages 220–225, June 2003.
[41] S. Singh, C. Estan, G. Varghese, and S. Savage. The Early-
Bird system for real-time detection of unknown worms.
Technical Report CS2003-0761, University of California,
San Diego, August 2003.
[42] S. Staniford, V. Paxson, and N. Weaver. How to 0wn the
Internet in your spare time. In 11th USENIX Security Sym-
posium, 2002.
[43] C. Systems.
Network-based application recognition.
http://www.cisco.com/univercd/cc/td/
doc/product/software/ios122/122newf%t/
122t/122t8/dtnbarad.htm.
[44] P. Szor. Hunting for metamorphic. In Virus Bulletin Con-
ference, 2001.
[45] H. J. Wang, C. Guo, D. R. Simon, and A. Zugenmaier.
Shield: Vulnerability-driven network ﬁlters for preventing
known vulnerability exploits. In ACM SIGCOMM, August
2004.
[46] X. Zhang, A. Edwards, and T. Jaeger. Using CQual for
static analysis of authorization hook placement. In the Pro-
ceedings of the 11th USENIX Security Symposium, 2002.