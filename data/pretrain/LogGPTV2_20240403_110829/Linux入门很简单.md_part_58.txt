我趁懒蜗牛不注意的时候叫来ldd，运行了一下ldd
./rubbish1115，看看这个软件都依赖什么。ldd向我汇报如下：
![alt](images/00474.jpeg){.calibre3}
看来依赖的还不是很多，算是最基本的了，可照样不能随便放到别的系统上运行啊。比如这个"ld-linux-x86-64.so.2"，明显只有64位系统才可以。"libc.so.6"虽然是个系统就有，但是版本也得合适，不合适也不行。这也是为什么Linux上发布的软件好多都是源码包的原因，因为系统环境实在是各式各样，还是把源码放到目标系统上编译一遍更方便。然而我这些话也就跟您说说，懒蜗牛听不见我说话的，所以他还是把那个rubbish金刚直接贴到网上了。
8.4.3 一个标准的源码包安装过程
几天之后，懒蜗牛就收到了应有的回应。
"这个程序在我这运行不了啊？"
"楼主我用SUSE啊，你编译出个SUSE版本的来吧。"
"楼主再好好看看吧，我这里运行不了。"
"我是32位机啊，运行不了这64位的。楼主提供个32位的版本吧。"
......
懒蜗牛同学终于意识到二进制文件不是放到哪都能执行的，可要让懒蜗牛去给每个人编译一个针对他们系统的版本也是不大可能的。好吧，那就发布源码！
可是问题又来了，源码发布的软件包应该是什么样子呢？为了避免再次体现自己的无知，懒蜗牛从网上下载了一个lynx2.8.7.tar.gz软件包。这个Lynx是一个字符界面的浏览器，懒蜗牛倒不是想用它，主要是这个软件体积不大，依赖也不多，正好拿来体验一下源码包的安装。
【要装源码包，先打开看看】
像".tar.gz"这样的源码包是下载软件时最经常遇到的了。另外还有".tar.bz2"格式，跟".tar.gz"的没什么区别，只是压缩格式不同而已。就类似于一个是RAR，一个是ZIP。那么这样的软件包怎么装呢？当然是先把包解开再看了，得先解开压缩包看看里面是什么内容才能知道怎么装啊，就像我问你RAR包怎么装，你能知道么？
".tar.gz"格式的文件，就像是一个邮局寄来的包裹。你收到一个包裹后怎么办？当然是先打开啦！先找剪子、小刀之类的工具把包裹拆开，然后看看里面有什么东西，根据里面东西的不同来决定怎么处理。里面要是家里寄来的松子核桃之类的特产，就赶快吃了；要是比较难吃的松子核桃什么的，就跟同事分着吃了；要是部手机，就赶快拿出来试试；要是下面还有把手枪，就赶紧拿刚才那手机报警。
【解压TAR包的工具】
这些大概不用我说，智力正常的人都应该知道怎么做。其实TAR包也是如此。拿到一个TAR包之后，先用你的工具把TAR包拆开。工具是啥？有道是解铃还须系铃人，TAR打的包，当然还用TAR来解了。一般解压一个TAR包的命令是：
![alt](images/00475.jpeg){.calibre3}
这里，xzvf是tar命令的参数，我们分别解释一下。
![alt](images/00002.jpeg){.tpzz} x------参数x意味着要做解包的动作，与之相反的是c，也就是打包的意思。
![alt](images/00002.jpeg){.tpzz} z------意思是这个包是用gzip压缩过的，需要先调用gzip解压。
![alt](images/00002.jpeg){.tpzz} v------显示解压的过程，也就是打印出解压出来的文件。如果没有这个参数，则在解压过程中没有任何输出。
![alt](images/00002.jpeg){.tpzz} f------指明要解压的文件。
另外还有一些常用的参数，也顺道介绍一下。
![alt](images/00002.jpeg){.tpzz} j------意思是这个包是用bzip压缩过的（也就是.tar.bz2格式），需要先调用bzip2解压。
![alt](images/00002.jpeg){.tpzz} c------这个参数的意思是要做打包的动作，和x参数相反。
![alt](images/00002.jpeg){.tpzz} C------注意这个参数是大写的C，用于将解压缩后的文件存放到指定目录。如果没有这个参数，则默认解压到当前目录。
当然，也可以用那个叫做文档管理器的家伙，他的中文名字叫归档管理器，他的英文名字叫file-roller。不过其实他只是个负责用图形界面和用户交流的家伙，真正干活的还得是tar。
![alt](images/00011.jpeg){.tpzz}**提示：**[tar命令后面的参数顺序并没有特定要求，但要确保文件名紧跟在f参数后。如"tar--vzxf
xxx.tar.gz"，"tar --xvzf xxx.tar.gz"都是正确写法。]{.kai1}
TAR包解开后，一般会得到一个目录，里面有很多的文件。然后干什么呢？有的同学记起来了，看看里面的东西啊。
一般包里面应该有个README文件。文件里写着这个软件是干什么用的、怎么安装、怎么用、作者是谁、何方人士、爱吃什么、身高多少、腰围裤长等信息。也可能安装的方法写在一个叫做INSALL的文件里。总之，应该有相应的文档文件来告诉你这个软件怎么装。不过也有时候软件的作者不厚道，或者忘性大，没有写README或者INSTALL文件。或者文件是有，但是没说清楚到底怎么装，那怎么办呢？只好去给作者写个E-mail鄙视他了。
8.4.4 configure的作用
懒蜗牛把下载来的软件包移动到了他的家目录下，然后运行：
![alt](images/00476.jpeg){.calibre3}
把这个压缩包解压了出来。解压之后是一个目录，叫做lynx2-8-7。懒蜗牛继续运行：
![alt](images/00477.jpeg){.calibre3}
这样就进入了刚刚解压出来的目录里面，用ls看了一下，发现有很多文件：
![alt](images/00478.jpeg){.calibre3}
其中有个叫做INSTALLATION的文件，里面很显然应该写着安装方法。于是懒蜗牛同学打开这个文件看了看，内容很多。不过关于安装，他看到这么几行：
![alt](images/00479.jpeg){.calibre3}
看来是运行这样两个命令就可以了。于是，懒蜗牛同学按照说明，运行了：
![alt](images/00480.jpeg){.calibre3}
这个configure是干什么的呢？
【施工之前，先勘察好环境】
我们知道GCC施工队听make包工头的指挥，make包工头根据Makefile安排工作。这样，如果想把一堆源码编译成二进制的程序，只要执行一下make。执行之后make会在当前目录下寻找Makefile，然后按照上面写的方案，指挥施工队：在这盖个大裤衩，在那盖个水煮蛋，再在中间垒个鸟窝。然后施工队按照命令一点点施工，直到最终完成任务。
然而事情有时候并不是那么简单。没准包工头make下达建设大裤衩命令之后，施工队回来报告：这地方挨着鞭炮厂啊，盖大裤衩还不烧着了？包工头说：那先盖水煮蛋吧。施工队又报告：这地方常年干旱，地下水位也低，这点水连泡面都不够，别说煮蛋了。包工头只好说：那就先盖那鸟窝，总行了吧？施工队再说：鸟窝倒是能盖，就是这地方不通天然气，点不着窝里那火炬啊。
【分析师出马】
遇到这些问题，都是由于开工之前没有对施工的环境、现有的材料进行合理分析导致的。那么我们的这个configure，就是能够解决这种问题的一名分析师。
configure跟make不一样，他并不是常驻在我这里的软件，而是每个源码发行的软件自带的一个脚本。简单点说，铁打的make只有一个，流水的configure每个软件一个。
有了configure之后，编译软件的步骤就多了一步------./configure。让这个分析师首先开始工作，他会检查当地的情况，有什么材料、什么库、什么编译器之类的，都检查一遍，然后因地制宜地设计一份Makefile。如果有足够的水，才允许煮蛋；有远离火种的安全空间才能晾裤衩等。如果条件不满足，configure就会报告错误，告诉用户这里缺少什么，等用户想办法弄齐了再来编译。如果条件满足可以施工，configure就会出一份Makefile。注意，一般configure调查前，目录下是没有Makefile文件的（当然，没有configure的情况另说）。
懒蜗牛运行./configure之后，得到了如下输出结果：
![alt](images/00481.jpeg){.calibre3}
这中间省去了几百行，无非就是"checking for xxxxxx\...
yes/no"这样的格式。这些输出的意思，就是说configure在对我们系统进行检查，报告有什么材料，没有什么材料。如果不是必需的材料，没有也就没有了。如果是必需的东西没有，那么confiugre就会报错并停止。
最终，我们这个系统里的东西还比较全，configure发现可以施工，于是就生成了Makefile文件。
![alt](images/00011.jpeg){.tpzz}**提示：**[Makefile文件中可以引用另一个Makefile文件，因此一个软件工程中，经常可以看到不同源码目录下都有一个Makefile文件。]{.kai1}
生成了Makefile文件，于是懒蜗牛同学就运行make命令：
![alt](images/00482.jpeg){.calibre3}
make开始工作，指挥着GCC施工队进行编译。由于软件很小，马上就编译完了。编译完成之后，就在当前目录下生成了一个叫做lynx的二进制文件。不过如果就这么放在这，运行起来很不方便，所以懒蜗牛同学继续运行了：
![alt](images/00483.jpeg){.calibre3}
这才把这个软件安装在了我们系统里。
![alt](images/00011.jpeg){.tpzz}**提示：**[如果要删除源码安装的软件，可以在源码目录下运行"make
uninstall"。作为一个标准的GNU软件，生成的makefile中应该都包含有uninstall的定义，但实际有一些不规范的软件，没有提供uninstall的方法，就只能手动删除了。]{.kai1}
【照猫画虎】
有了这么一番感受之后，懒蜗牛知道了一个源码发布的软件包的大概样子。于是照着人家这个软件包，对比一下自己的这个软件。一看，Makefile是现成的，只要再增加一个configure脚本，检查一下系统中有没有gcc之类的编译工具及库文件等就可以了。
要写这么个脚本，需要用到Shell脚本编程的知识。懒蜗牛之前虽然学过一点，但那都只是些皮毛。现在要真去写configure脚本，还真有点力不从心。怎么办呢？对，照猫画虎！看看那个Lynx的configure怎么写的，跟着学就好了。懒蜗牛想得挺好，叫来gedit打开configure一看就傻了------洋洋洒洒连注释带语句一共36379行！这得看到哪年啊！
8.4.5 扩展阅读：黄金搭档------tar和gzip
前面介绍到tar命令，基本上每个Linux系统都会带着这个软件，我这里也是。这个软件是干什么的呢？