        os.system("C:\python27\python.exe C:\BugId\BugId.py C:\Users\IEUser\Desktop\xml_validate_results\xmlvalidate.exe -- %s" % testcase)
运行上面的脚本得到了下面的输出：  
一旦我为所有得到的崩溃运行了它，可以很清楚的看到，我们命中的是相同的 bug。为了确认这一点，让我们打开 windbg：
    0:000> g
    (a6c.5c0): Access violation - code c0000005 (!!! second chance !!!)
    eax=03727aa0 ebx=0012fc3c ecx=00000000 edx=00000000 esi=030f4f1c edi=00000002
    eip=6f95025a esp=0012fbcc ebp=0012fbcc iopl=0         nv up ei pl zr na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
    msxml6!DTD::findEntityGeneral+0x5:
    6f95025a 8b4918          mov     ecx,dword ptr [ecx+18h] ds:0023:00000018=????????
    0:000> kv
    ChildEBP RetAddr  Args to Child              
    0012fbcc 6f9de300 03727aa0 00000002 030f4f1c msxml6!DTD::findEntityGeneral+0x5 (FPO: [Non-Fpo]) (CONV: thiscall) [d:w7rtmsqlxmlmsxml6xmldtddtd.hxx @ 236]
    0012fbe8 6f999db3 03727aa0 00000003 030c5fb0 msxml6!DTD::checkAttrEntityRef+0x14 (FPO: [Non-Fpo]) (CONV: thiscall) [d:w7rtmsqlxmlmsxml6xmldtddtd.cxx @ 1470]
    0012fc10 6f90508f 030f4f18 0012fc3c 00000000 msxml6!GetAttributeValueCollapsing+0x43 (FPO: [Non-Fpo]) (CONV: stdcall) [d:w7rtmsqlxmlmsxml6xmlparsenodefactory.cxx @ 771]
    0012fc28 6f902d87 00000003 030f4f14 6f9051f4 msxml6!NodeFactory::FindAttributeValue+0x3c (FPO: [Non-Fpo]) (CONV: thiscall) [d:w7rtmsqlxmlmsxml6xmlparsenodefactory.cxx @ 743]
    0012fc8c 6f8f7f0d 030c5fb0 030c3f20 01570040 msxml6!NodeFactory::CreateNode+0x124 (FPO: [Non-Fpo]) (CONV: stdcall) [d:w7rtmsqlxmlmsxml6xmlparsenodefactory.cxx @ 444]
    0012fd1c 6f8f5042 010c3f20 ffffffff c4fd70d3 msxml6!XMLParser::Run+0x740 (FPO: [Non-Fpo]) (CONV: stdcall) [d:w7rtmsqlxmlmsxml6xmltokenizerparserxmlparser.cxx @ 1165]
    0012fd58 6f8f4f93 030c3f20 c4fd7017 00000000 msxml6!Document::run+0x89 (FPO: [Non-Fpo]) (CONV: thiscall) [d:w7rtmsqlxmlmsxml6xmlomdocument.cxx @ 1494]
    0012fd9c 6f90a95b 030ddf58 00000000 00000000 msxml6!Document::_load+0x1f1 (FPO: [Non-Fpo]) (CONV: thiscall) [d:w7rtmsqlxmlmsxml6xmlomdocument.cxx @ 1012]
    0012fdc8 6f8f6c75 037278f0 00000000 c4fd73b3 msxml6!Document::load+0xa5 (FPO: [Non-Fpo]) (CONV: thiscall) [d:w7rtmsqlxmlmsxml6xmlomdocument.cxx @ 754]
    0012fe38 00401d36 00000000 00000008 00000000 msxml6!DOMDocumentWrapper::load+0x1ff (FPO: [Non-Fpo]) (CONV: stdcall) [d:w7rtmsqlxmlmsxml6xmlomxmldom.cxx @ 1111]
    -- cut --
让我们来看一个造成崩溃的 xml：
    C:UsersIEUserDesktopxml_validate_resultsfuzzer01crashes>type id_000000_00
       Gambardella, Matthew
       XML Developer's Guide
       Computer
       44.95
       2000-10-01
       An in-depth look at creating applications with
       XML.
正如你看到的，如果我们在 xml 或者其编码后提供了一些 garbage，就会得到上面的崩溃。Mitja 还将测试用例减到最小，如下所示：
对该库进行模糊测试的整个思想，是基于在 IE 上下文中找到一个漏洞并以某种方法触发它。经过一番搜索，让我们使用下面的
Poc（crashme.html），看看它是否会使 IE11 崩溃：
在 Python 的 SimpleHTTPServer 中运行它，提供下面的东西：
Bingo！正如预期的那样，至少在启用了 PageHeap 的情况下，我们能够触发与我们在测试框架中相同的崩溃。小心不要在 Microsoft
Outlook 中包含该 xml，因为它也会崩溃！此外，由于它基于库本身，如果产生一个更 sexy 的崩溃，则会增加攻击面！
**  
**
**打补丁**
在与 Mitja 通过电子邮件交流后，他向我提供了可以在完全更新的 x64 系统上使用的补丁：
    ;target platform: Windows 7 x64
    ;
    RUN_CMD C:UserssymeonDesktopxmlvalidate_64bitxmlvalidate.exe C:UserssymeonDesktopxmlvalidate_64bitpoc2.xml
    MODULE_PATH "C:WindowsSystem32msxml6.dll"
    PATCH_ID 200000
    PATCH_FORMAT_VER 2
    VULN_ID 9999999
    PLATFORM win64
    patchlet_start
     PATCHLET_ID 1
     PATCHLET_TYPE 2
     PATCHLET_OFFSET 0xD093D 
     PIT msxml6.dll!0xD097D
     code_start
      test rbp, rbp ;is rbp (this) NULL?
      jnz continue
      jmp PIT_0xD097D
      continue:
     code_end
    patchlet_end
我们来调试和测试下这个补丁程序，我已经创建了一个账户，并未开发者安装了 0patch 代理，右击上述的 .0pp 文件：
一旦在测试框架中使用了可以导致崩溃的 xml，我立即设置断点：
从上面的代码中看到，rbp 寄存器确实是 null，这将导致 null pointer dereference 的问题。由于我们已经部署了 0patch
代理，实际上它会跳转到 msxml6.dll!0xD097D，从而避免崩溃：
太棒了！接下来我在修复后的版本上再次启动 winafl，但是不幸失败了。由于 0patch（钩子函数？）的性质，它与 WinAFL 不兼容，于是崩溃了。
然而，这是一种“DoS 0day”，正如我之前提到的，我在2017年6月向微软提出报告，二十天后收到一下邮件：
我完全同意这一决定，但我最感兴趣的还是修补掉这个烦人的
bug，以便我可以继续前进。在调试器上花了几个小时之后，我发现唯一可控制的用户输入是编码字符串的长度：
    eax=03052660 ebx=0012fc3c ecx=00000011 edx=00000020 esi=03054f24 edi=00000002
    eip=6f80e616 esp=0012fbd4 ebp=0012fbe4 iopl=0         nv up ei pl zr na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
    msxml6!Name::create+0xf:
    6f80e616 e8e7e6f9ff      call    msxml6!Name::create (6f7acd02)
    0:000> dds esp L3
    0012fbd4  00000000
    0012fbd8  03064ff8
    0012fbdc  00000003
    0:000> dc 03064ff8 L4
    03064ff8  00610061 00000061 ???????? ????????  a.a.a...????????
上面的 unicode 字符串其实是来自我们测试用例的开头，其中数字 3 很明显是长度（函数的签名：Name *__stdcall
Name::create(String *pS, const wchar_t *pch, int iLen, Atom *pAtomURN)）
**  
**
**结论**
如你所见，花一些时间在微软的 API 和文档上是非常值得的！另外，重构一些基本函数并精确定位影响性能的问题也可能对我们的工作有很大的改进！
我必须感谢 lvan 将 afl 移植到 Windows 并创建了这个令人吃惊的项目。也感谢 Axel 和其他一直积极做贡献的人。
我的同事 Javier 激励我写了这篇博客，Richard 一直在回答我愚蠢的问题，并给我所有的帮助，来自 0patch 的 Mitja
建立了这个补丁，最后 Patroklo 几年前教了我一些模糊测试的技巧！
**  
**
**参考**
[Evolutionary Kernel Fuzzing-BH2017-rjohnson-FINAL.pdf](https://github.com/richinseattle/EvolutionaryKernelFuzzing/blob/master/slides/Evolutionary%20Kernel%20Fuzzing-BH2017-rjohnson-FINAL.pdf)
[Super Awesome Fuzzing, Part
One](https://labsblog.f-secure.com/2017/06/22/super-awesome-fuzzing-part-one/)