# CVE-2017-6736 思科IOS系统远程代码执行漏洞分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
##
## 0x00漏洞背景
2017年6月29日，思科在安全更新中修复了在IOS和IOS
XE软件中SNMP子系统的9个严重远程代码执行漏洞(CVE-2017-6736—–CVE-2017-6744)。这些漏洞影响了多个Cisco
IOS和Cisco IOS
XE的主流版本。其中，CVE-2017-6736漏洞允许攻击者通过发送特定的SNMP数据包，使目标系统重新加载或执行代码。2018年1月，研究人员Artem
Kondratenko公开了CVE-2017-6736的PoC脚本代码，由于思科网络设备有极高的市场占有率，所以很多没有及时更新补丁或按照思科官方处置建议进行配置的网络设备，增大了被攻击者利用漏洞进行攻击的风险。
从官方给出的信息来看，这个漏洞与2016年影子经纪人披露的NSA武器库中Cisco
ASA设备SNMP远程代码执行漏洞（CVE-2016-6366）在受影响系统版本，利用条件限制等很多信息上颇为相似。出于探究两个漏洞原理和细节关系，并通过分析过程深入了解基于RISC指令集的IOT设备漏洞分析和调试方法的想法，本文从思科IOS处理SNMP请求数据包的过程入手，分析了漏洞产生的原因，并将分析过程和技术细节予以呈现。
## 0x01 漏洞简要介绍
####  1. 漏洞原理
CVE-2017-6736从本质上来说，是一个缓冲区溢出漏洞。从漏洞利用的角度来讲，攻击者可以向系统发送精心构造的SNMP数据包来造成溢出，当漏洞利用成功时，攻击者即可在设备上执行shellcode。
####  2. 漏洞影响范围
该漏洞可以影响此前所有Cisco IOS 和IOS XE软件的发行版，且影响所有的SNMP版本(1, 2c 和3)。具体发行版包括Cisco IOS
12.0版本至12.4版本、15.0版本至15.6版本和IOS XE 2.2版本至3.17版本。其中，运行SNMP
2c或更低版本的系统只有在攻击者知道系统SNMP只读社区（Readonly Community）字符串时才能成功利用，对于运行SNMP
v3的系统，攻击者必须拥有系统的用户访问凭据才能进行攻击。
另外，Cisco官方给出了脆弱MIB的配置列表，如下所示：
l ADSL-LINE-MIB
l ALPS-MIB
l CISCO-ADSL-DMT-LINE-MIB
l CISCO-BSTUN-MIB
l CISCO-MAC-AUTH-BYPASS-MIB
l CISCO-SLB-EXT-MIB
l CISCO-VOICE-DNIS-MIB
l CISCO-VOICE-NUMBER-EXPANSION-MIB
l TN3270E-RT-MIB
上述MIB在个别SNMP系统上会有缺失，但是当列表中的MIB存在于SNMP系统时，会默认启用。
####  3. 利用条件限制
攻击者主机必须在设备的信任列表中才能向IOS发送SNMP数据包，可以通过IPv4或者IPv6发送SNMP数据包实现漏洞利用，但只有指向系统的流量才能利用漏洞。在运行SNMP
2c或更低版本的系统只有在攻击者知道系统SNMP只读社区（Readonly Community）字符串时才能成功利用，对于运行SNMP
v3的系统，攻击者必须拥有系统的用户访问凭据才能进行攻击。
## 0x02 漏洞分析
####  1. 前期准备
由于没有真机作为调试环境，所以采用 IDA Pro + Qemu + Dynamips + GDB
stub作为调试环境。而目前Dynamips最新版本支持的Cisco
IOS镜像中，并没有c2800系列。经过模拟环境测试，PoC脚本用于c2600系列固件时可以触发漏洞造成溢出，所以我们选择c2600-bino3s3-mz.123-22.bin固件镜像作为调试和分析对象。
####  2. PoC代码分析
该漏洞PoC代码由python编写。主要功能是构造特定格式的数据包，造成SNMP处理流程溢出。从PoC代码公开的信息来看，漏洞可在Cisco
Integrated Service Router 2811型号的设备上利用。固件和ROM支持型号如下：
最新固件型号
|
Cisco IOS Software, 2800 Software (C2800NM-ADVENTERPRISEK9-M), Version
15.1(4)M12a, RELEASE SOFTWARE (fc1)  
---|---  
ROM型号
|
System Bootstrap, Version 12.4(13r)T, RELEASE SOFTWARE (fc1)  
核心代码如下：
alps_oid=’1.3.6.1.4.1.9.9.95.1.3.1.1.7.108.39.84.85.195.249.106.59.210.37.23.42.103.182.75.232.81{0}{1}{2}{3}{4}{5}{6}{7}.14.167.142.47.118.77.96.179.109.211.170.27.243.88.157.50{8}{9}.35.27.203.165.44.25.83.68.39.22.219.77.32.38.6.115{10}{11}.11.187.147.166.116.171.114.126.109.248.144.111.30′
for k, sh_dword in enumerate([sh_buf[i:i+4] for i in range(0, len(sh_buf),
4)]):
s0 = bin2oid(sh_dword) # shellcode dword
s1 = bin2oid(‘x00x00x00x00’)
s2 = bin2oid(‘xBFxC5xB7xDC’)
s3 = bin2oid(‘x00x00x00x00’)
s4 = bin2oid(‘x00x00x00x00’)
s5 = bin2oid(‘x00x00x00x00’)
s6 = bin2oid(‘x00x00x00x00’)