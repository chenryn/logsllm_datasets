.NET 文件上传多个场景绕过预编译限制获取 Shell 
Ivan1ee@dotNet 安全矩阵 
[ dotNet 安全矩阵] —— 聚焦于微软.NET 安全技术，关注基于.NET
衍生出的各种红蓝攻防对抗技术、分享内容不限于 .NET 代码审计、 
最新的.NET 漏洞分析、反序列化漏洞研究、有趣的.NET 安全
Trick、.NET 开源软件分享、. NET 生态等热点话题，愿你能在这里学
到实在的干货，共同推动.NET 安全氛围卷起来。 
配套的[ dotNet 安全矩阵]知识星球优惠活动持续进行，价格直接给
到星球最低起步价[￥50] ，每天只需要 1 块钱不到，就可以让自己
从.NET 小白成为高手，因为星球里的资料和教程很少在市面上广泛
传播，价值完全划算，还可以获得阿里、蚂蚁、字节等大厂内推实习
或社招岗位的机会，欢迎对.NET 感兴趣的小伙伴们加入我们，一起
做一件有情有意义的事。 
0X01 背景 
在攻防演练的这个大背景下，红蓝对抗也逐渐真正的提升到对抗这个层次，这
不今天由 dotNet 安全矩阵星球圈友们组成的微信群里有位群友问起如何突破
预编译拿 webshell 有什么方法，预编译已经够麻烦了，这位师傅还非常有挑战
的加上了不考虑跨目录的情况下怎么获取 webshell，借师傅这么有挑战的命题
笔者系统性的介绍预编译几种不同场景下获取 shell 的手段，希望本文探讨的这
些可行性路径以及达成目标使用的不同方法能在实战中有所帮助 
0X02 困局 
.NET 站点发布时提供一项预编译的能力，可以提升站点运行处理的速度以及保
护知识版权，采用了这种预编译模式后站点下的每个.NET 文件的内容被标记为 
"这是预编译工具生成的标记文件，不应删除!"，如果此时上传一个普通的 aspx
木马，访问后提示 "未预编译文件，因此不能请求该文件"，如下图所示，那么
这种场景下如何通过文件上传漏洞获取 WebShell 呢？笔者想到了以下不同场
景下的几种变通的方法，在正式介绍方法前首先回顾下预编译的原理。 
0X03 用法 
.NET 下的编译方式大致可以分成两种方式，分别为动态编译和预编译。动态编译因为文件
以源代码的形式放置于 Web 容器中，所以对于首次访问编译时需要消耗大量的资源，这
样会严重降低 Web 应用的响应速度，另外代码内容是开放的，容易被篡改导致系统不安
全或崩溃，从知识产权来看也不利于保护商业秘密。以上这两点动态编译的劣势也是开发
者选择预编译的两种原因，预编译模式下将编译所有的.NET 文件，当然 HTML、图片、
css 等静态资源文件不包含在内，在预编译过程中编译器将创建的程序集存储于项目根目
录下的 Bin 文件夹，另外也会同步到一个.NET 特殊的目
录 %SystemRoot%\Microsoft.NET\Framework\version\Temporary ASP.NET Files 文件夹
下，Bin 目录下会编译生成两类为文件，一类是扩展名为.compiled，该文件包含指向与该
页相应的程序集名称；另一类文件是编译后的扩展名为.dll 的程序集文件。下面笔者分几
个小节分别介绍预编译发布过程和生成的结果文件 
3.1 编译选项 
创建.NET MVC 项目后右击选择 发布，系统提供了文件夹、FTP、IIS、云发布等多种途
径，笔者选择了传统的 IIS 发布，发布就绪后配置 Release 选项，打开预编译详细配置页
面，默认情况下系统勾选了 "允许更新预编译站点"，这样的好处在于可以很轻松的修改代
码，方便应急维护，但不好的方面就是不安全，未能达到保护软件知识版权的目的。如果
不勾选“允许更新预编译站点”，项目下的所有 aspx 文件的内容都将被重写为 “这是预编译
工具生成的标记文件，不应删除!”，而文件本身也只是个占位符。 
除了图形化界面操作预编译之外，Visual Studio 还提供了命令行下的可执行程序
aspnet_compiler 预编译.NET 项目，具体的命令释义如下 
名称 
释义 
aspnet_compiler -v /Lib -p D:\Project\VisualStudio\Pre\WebForm\test D:\test -
fixednames 
-v 
表示指向的虚拟地址路径 /Lib 
-p 
要编译的源 Web 项目所在文件夹、以及输出的目的文件夹 
-fixednames 
表示每个.aspx 都编译生成单独的 dll 文件，并使用固定文件名 
经过编译后项目文件夹中的所有.aspx, .ashx 及 App_Code 中的.cs 文件都会被编译成 DLL
文件，静态资源文件将原封不动的复制到目的文件夹里。 
3.2 complied 保留文件 
.NET 每一次编译都会生成很多具有.compiled 扩展名的保留文件，这个文件本质上是一个
XML 文件，命名格式如下，其中[page]是页面的名称，[folder-hash]是对页面所在路径的
Hash Value，这样做可保证处于同一级目录的所有保留文件具有不同的文件名。 
例如笔者本地 MVC 项目里用到的 about.aspx 被预编译名为 
about.aspx.cdcab7d2.compiled，那么打开再看看里面的 XML 内容各代表什么意思，打开
后如下 
[page].aspx.[folder-hash].compiled 
通过 hash 和 filehash 的缓存，.NET 可以判断自上一次使用以来保留文件和它所依赖的文
件是否被改动，如果真的被改动了将会重新编译。 
3.3 PrecompliedApp.config 
假设按照第 3.1.1 小节的默认配置，.NET 预编译项目后会多出一个 Precompiled.config 文
件，此文件用来控制当前站点预编译状态，内容如下最关键的是 updatable 选项，当配置
为 false 时，整个项目为预编译不允许更新，意思就是传入.cs 文件将不能运行；只有为
true 的情况下才能正常运行.cs 这样未编译的文件，另外此文件内容的更改或文件删除，均
需要重启 IIS 才能生效，权限要求较高！ 
0X04 预编译绕过的几种场景 
攻防对抗实战中想绕过预编译挺困难的，因为预编译本身也是微软设计出来的一套提高性
能和安全保护的机制，笔者总结几种常见的绕过方法和一种未公开的绕过方式，但这些方
法都不具备通用性需要结合特定的场景下去使用。 
4.1 上传 ASP 脚本 
IIS 作为优秀的 Web 容器，不光对.NET 支持非常好，对早前的 ASP 脚本一直也支持，但在
笔者当前的环境 IIS10 里默认是不启用的，需要在应用程序功能配置上勾选上 ASP，这样
在.NET 预编译模式下通过上传 ASP 木马可以 GetShell，因为 ASP 脚本
由 %windir%\system32\inetsrv\asp.dll 负责处理请求，而.NET 项目是
由 %windir%\Microsoft.NET\Framework64\v4.0.30319\aspnet_isapi.dll 负责处理，所以
和.NET 无关。 
4.2 上传至 Bin 目录 
bin 这个目录包含了项目所有使用到的.Net 程序集，并且 在 Web 应用程序任意处的其他
代码会自动引用该文件夹。典型的示例是您为自定义类编译好的代码。您可以将编译后的
程序集复制到 Web 应用程序的 Bin 文件夹中，这样所有页都可以使用这个类。Bin 文件夹
中的程序集无需注册。只要.dll 文件存在于 Bin 文件夹中，.NET 就可以识别它。如果您
更改了 .dll 文件，并将它的新版本写入到了 Bin 文件夹中，则 .NET 会检测到更新，并
对随后的新页请求使用新版本的 .dll ，笔者假定如果上传漏洞可以任意跨目录的话就可以
将编译好的 compiled 文件和关联的 App_Web_xxxxx.dll 上传到 Bin 目录，举个栗子比如需
要编译“D:\Project\test”目录下的 aspx.aspx 文件，文件内容是启动 calc， 执行下面命令生
成 aspx.aspx.cdcab7d2.compiled 和 App_Web_4z2nrvyu.dll 两个文件，将它们上传到
bin 目录，然后还需要把 aspx.aspx 这个占位符文件上传到站点根目录下，再访问
/aspx.aspx 即可在进程中拉起计算器，整个过程需要分三次上传，并且涉及到跨 bin 目录
和根目录 
aspnet_compiler -v /Lib -p D:\Project\test D:\test -fixednames 
如果遇到根目录不可写的场景话，就需要改变打法，用.NET 提供的全局文件 Global.asax
去实现 GetShell，Global.asax 这个文件是 IIS 请求和响应必进过的文件，是包含了 HTTP
会话生命周期各个阶段状态处置的文件。 它继承自 System.Web.HttpApplication，它的作
用是定义 .NET 应用程序中的所有应用程序对象共有的方法、属性和事件。笔者在 
Application_Start 和 Application_BeginRequest 两个方法内分别实现启动 winver 进程和
mstsc 进程，如下图 