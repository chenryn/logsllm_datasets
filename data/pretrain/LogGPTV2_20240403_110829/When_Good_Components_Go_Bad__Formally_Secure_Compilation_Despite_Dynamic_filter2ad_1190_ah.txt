with undefined behavior in P [58]. If a property π is in Closed≺P
and it allows a trace t that ends with an undefined behavior in P—
i.e., ∃m. t = m · Undef(P)—then π should also allow any extension
of the trace m—i.e., any trace t′ that has m as a prefix. The intuition
is simple: the compilation chain is free to implement a trace with
undefined behavior in P as an arbitrary trace extension, so if the
property accepts traces with undefined behavior it should also
accept their extensions. Conversely, if a property π in Closed≺P
rejects a trace t′, then for any prefix m of t′ the property π should
also reject the trace m · Undef(P).
16
When Good Components Go Bad
Abate et al.
REFERENCES
[1] M. Abadi and C. Fournet. Access control based on execution history. NDSS. The
[2] M. Abadi. Protection in programming-language translations. Secure Internet
Internet Society, 2003.
Programming. 1999.
[3] M. Abadi, C. Fournet, and G. Gonthier. Secure implementation of channel abstrac-
tions. Information and Computation, 174(1):37–83, 2002.
[4] M. Abadi and J. Planul. On layout randomization for arrays and functions. POST.
[5] M. Abadi and G. D. Plotkin. On protection by layout randomization. ACM TISSEC,
2013.
15(2):8, 2012.
For a negative example that is not in Closed≺P , consider the
following formalization of the property S1 from §2, requiring all
writes in the trace to be preceded by a corresponding read:
S1={t | ∀m d x. m · E.write() ≤ t
⇒ ∃m′. m′ · E.read · Ret(x) ≤ m}
While property S1 is Safety it is not Closed≺P . Consider the trace
t′ = [C0.main(); E.write()] (cid:60) S1 that does a write without
a read and thus violates S1. For S1 to be Closed≺P it would have
to reject not only t′, but also [C0.main(); Undef(P)] and Undef(P),
which it does not. One can, however, define a stronger variant of
S1 that is in ZP :
S
Z +
P
1 ={t|∀m d x.(m · E.write()≤t ∨ m · Undef(P)≤t)
⇒ ∃m′. m′ · E.read · Ret(x) ≤ m}
Z +
P
1
The property S
requires any write or undefined behavior in P to
be preceded by a corresponding read. While this property is quite
restrictive, it does hold (vacuously) for the strengthened system in
Figure 2 when taking P = {C0} and C = {C1, C2}, since we assumed
that C0 has no undefined behavior.
Using ZP , we proved an equivalent RSCDC characterization:
(cid:18) ∀P π∈ZP . (∀CS t . CS[P]⇝t ⇒ t∈π)
⇒ (∀CT t . CT [P↓]⇝t ⇒ t∈π)
(cid:19)
Theorem A.2.
RSCDC ⇐⇒
This theorem shows that RSCDC is equivalent to the preservation
of all properties in ZP for all P. One might still wonder how one
obtains such robust safety properties in the source language, given
that the execution traces can be influenced not only by the partial
program but also by the adversarial context. In cases in which the
trace records enough information so that one can determine the
originator of each event, robust safety properties can explicitly talk
only about the events of the program, not the ones of the context.
Moreover, once we add interfaces in RSCDC
MD (§3.3) we are able
to effectively restrict the context from directly performing certain
events (e.g., certain system calls), and the robust safety property can
then be about these privileged events that the sandboxed context
cannot directly perform.
One might also wonder what stronger property does one have
to prove in the source in order to obtain a certain safety property π
in the target using an RSCDC compiler in the case in which π is not
itself in ZP . Especially when all undefined behavior is already gone
in the target language, it seems natural to look at safety properties
such as S1(cid:60)ZP above that do not talk at all about undefined behavior.
1 ∈ZP
For S1 above, we manually defined the stronger property S
that is preserved by an RSCDC compiler. In fact, given any safety
property π we can easily define π Z +
P that is in ZP , is stronger than
π, and is otherwise as permissive as possible:
′ ⇒ t
P ≜ π ∩ {t | ∀t
′∈π}
π Z +
Z +
P
′
. t≺P t
We can also easily answer the dual question asking what is left of
an arbitrary safety property established in the source when looking
at the target of an RSCDC compiler:
π Z −
P ≜ π ∪ {t
′ | ∃t∈π . t≺P t
′ ∨ t
′ ≤ t}
17
[6] C. Abate, A. Azevedo de Amorim, R. Blanco, A. N. Evans, G. Fachini, C. Hriţcu,
T. Laurent, B. C. Pierce, M. Stronati, and A. Tolmach. When good components go
bad: Formally secure compilation despite dynamic compromise. CCS. 2018.
[7] C. Abate, R. Blanco, D. Garg, C. Hriţcu, M. Patrignani, and J. Thibault.
Jour-
ney beyond full abstraction: Exploring robust property preservation for secure
compilation. CSF, 2019.
[8] P. Agten, B. Jacobs, and F. Piessens. Sound modular verification of C code executing
in an unverified context. POPL. 2015.
[9] P. Agten, R. Strackx, B. Jacobs, and F. Piessens. Secure compilation to modern
processors. CSF. 2012.
[10] A. Ahmed. Verified compilers for a multi-language world. SNAPL. 2015.
[11] A. Ahmed and M. Blume. Typed closure conversion preserves observational
[12] A. Ahmed and M. Blume. An equivalence-preserving CPS translation via multi-
[13] A. Azevedo de Amorim. A methodology for micro-policies. PhD thesis, University
equivalence. ICFP. 2008.
language semantics. ICFP. 2011.
of Pennsylvania, 2017.
[14] A. Azevedo de Amorim, N. Collins, A. DeHon, D. Demange, C. Hriţcu, D. Pichardie,
B. C. Pierce, R. Pollack, and A. Tolmach. A verified information-flow architecture.
POPL. 2014.
[15] A. Azevedo de Amorim, M. Dénès, N. Giannarakis, C. Hriţcu, B. C. Pierce,
A. Spector-Zabusky, and A. Tolmach. Micro-policies: Formally verified, tag-based
security monitors. Oakland S&P. 2015.
[16] A. Azevedo de Amorim, C. Hriţcu, and B. C. Pierce. The meaning of memory
safety. POST. 2018.
[17] M. Backes, M. P. Grochulla, C. Hriţcu, and M. Maffei. Achieving security despite
compromise using zero-knowledge. CSF. 2009.
[18] D. A. Basin and C. Cremers. Know your enemy: Compromising adversaries in
protocol analysis. TISSEC, 17(2):7:1–7:31, 2014.
[19] A. Bittau, P. Marchenko, M. Handley, and B. Karp. Wedge: Splitting applications
into reduced-privilege compartments. USENIX NSDI, 2008.
[20] M. Castro and B. Liskov. Practical byzantine fault tolerance and proactive recov-
ery. TOCS, 20(4):398–461, 2002.
[21] D. Chisnall, C. Rothwell, R. N. M. Watson, J. Woodruff, M. Vadera, S. W. Moore,
M. Roe, B. Davis, and P. G. Neumann. Beyond the PDP-11: Architectural support
for a memory-safe C abstract machine. ASPLOS. 2015.
[22] M. R. Clarkson and F. B. Schneider. Hyperproperties. JCS, 18(6):1157–1210, 2010.
[23] D. Devriese, M. Patrignani, and F. Piessens. Fully-abstract compilation by ap-
[24] D. Devriese, M. Patrignani, and F. Piessens. Parametricity versus the universal
proximate back-translation. POPL, 2016.
type. PACMPL, 2(POPL):38:1–38:23, 2018.
[25] D. Devriese, M. Patrignani, F. Piessens, and S. Keuchel. Modular, fully-abstract
compilation by approximate back-translation. LMCS, 13(4), 2017.
[26] D. Devriese, F. Piessens, and L. Birkedal. Reasoning about object capabilities with
logical relations and effect parametricity. EuroS&P. 2016.
[27] U. Dhawan, C. Hriţcu, R. Rubin, N. Vasilakis, S. Chiricescu, J. M. Smith, T. F.
Knight, Jr., B. C. Pierce, and A. DeHon. Architectural support for software-defined
metadata processing. ASPLOS. 2015.
[28] G. J. Duck and R. H. C. Yap. EffectiveSan: Type and memory error detection
using dynamically typed C/C++. PLDI, 2018.
[29] A. Filinski. Linear continuations. POPL. 1992.
[30] C. Fournet, A. D. Gordon, and S. Maffeis. A type discipline for authorization
policies. ACM Trans. Program. Lang. Syst., 29(5):25, 2007.
[31] C. Fournet, N. Swamy, J. Chen, P.-É. Dagand, P.-Y. Strub, and B. Livshits. Fully
abstract compilation to JavaScript. POPL. 2013.
[32] A. Gollamudi and C. Fournet. Building secure SGX enclaves using F*, C/C++ and
X64. 2nd Workshop on Principles of Secure Compilation (PriSC), 2018.
[33] A. D. Gordon and A. Jeffrey. Types and effects for asymmetric cryptographic
[34] A. D. Gordon and A. Jeffrey. Secrecy despite compromise: Types, cryptography,
protocols. JCS, 12(3-4):435–483, 2004.
and the pi-calculus. CONCUR. 2005.
[35] K. Gudka, R. N. M. Watson, J. Anderson, D. Chisnall, B. Davis, B. Laurie, I. Marinos,
P. G. Neumann, and A. Richardson. Clean application compartmentalization with
SOAAP. CCS. 2015.
[36] A. Haas, A. Rossberg, D. L. Schuff, B. L. Titzer, M. Holman, D. Gohman, L. Wagner,
A. Zakai, and J. F. Bastien. Bringing the web up to speed with WebAssembly. PLDI,
When Good Components Go Bad
Abate et al.
[37] I. Haller, Y. Jeon, H. Peng, M. Payer, C. Giuffrida, H. Bos, and E. van der Kouwe.
S&P. 2013.
TypeSan: Practical type confusion detection. CCS, 2016.
[77] G. Tan. Principles and implementation techniques of software-based fault isola-
[38] C. Hathhorn, C. Ellison, and G. Rosu. Defining the undefinedness of C. PLDI.
tion. FTSEC, 1(3):137–198, 2017.
[76] L. Szekeres, M. Payer, T. Wei, and D. Song. SoK: Eternal war in memory. IEEE
2017.
2015.
HotSpot, 2016.
[78] S. Tsampas, A. El-Korashy, M. Patrignani, D. Devriese, D. Garg, and F. Piessens.
Towards automatic compartmentalization of C programs on capability machines.
FCS, 2017.
[79] N. van Ginkel, R. Strackx, J. T. Muehlberg, and F. Piessens. Towards safe enclaves.
[80] T. Van Strydonck, D. Devriese, and F. Piessens. Linear capabilities for modular
fully-abstract compilation of verified code. 2nd Workshop on Principles of Secure
Compilation (PriSC), 2018.
[81] N. Vasilakis, B. Karel, N. Roessler, N. Dautenhahn, A. DeHon, and J. M. Smith.
BreakApp: Automated, flexible application compartmentalization. NDSS. 2018.
[82] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham. Efficient software-based
fault isolation. SOSP, 1993.
[83] X. Wang, N. Zeldovich, M. F. Kaashoek, and A. Solar-Lezama. Towards
optimization-safe systems: Analyzing the impact of undefined behavior. SOSP.
2013.
[84] R. N. M. Watson, J. Woodruff, P. G. Neumann, S. W. Moore, J. Anderson, D. Chis-
nall, N. H. Dave, B. Davis, K. Gudka, B. Laurie, S. J. Murdoch, R. Norton, M. Roe,
S. Son, and M. Vadera. CHERI: A hybrid capability-system architecture for scalable
software compartmentalization. S&P. 2015.
[85] P. Wilke, F. Besson, S. Blazy, and A. Dang. CompCert for software fault isolation.
[86] T. Y. C. Woo and S. S. Lam. A semantic model for authentication protocols. IEEE
[87] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy, S. Okasaka, N. Narula,
and N. Fullagar. Native Client: A sandbox for portable, untrusted x86 native code.
CACM, 53(1):91–99, 2010.
[88] S. Zdancewic and A. C. Myers. Secure information flow via linear continuations.
Higher Order and Symbolic Computation, 15:2002, 2002.
[89] L. Zhao, G. Li, B. D. Sutter, and J. Regehr. ARMor: Fully verified software fault
isolation. EMSOFT. 2011.
[39] The Heartbleed bug. http://heartbleed.com/, 2014.
[40] Software guard extensions (SGX) programming reference, 2014.
[41] ISO/IEC. ISO/IEC 9899:2011 - programming languages – C, 2011.
[42] R. Jagadeesan, C. Pitcher, J. Rathke, and J. Riely. Local memory via layout
[43] A. Jeffrey and J. Rathke. Java Jr: Fully abstract trace semantics for a core Java
[44] L. Jia, S. Sen, D. Garg, and A. Datta. A logic of programs with interface-confined
randomization. CSF. 2011.
language. ESOP. 2005.
code. CSF. 2015.
[45] Y. Juglaret, C. Hriţcu, A. Azevedo de Amorim, B. Eng, and B. C. Pierce. Be-
yond good and evil: Formalizing the security guarantees of compartmentalizing
compilation. CSF, 2016.
[46] Y. Juglaret, C. Hriţcu, A. Azevedo de Amorim, B. C. Pierce, A. Spector-Zabusky,
and A. Tolmach. Towards a fully abstract compiler using micro-policies: Secure
compilation for mutually distrustful components. CoRR, abs/1510.00697, 2015.
[47] J. Kang, Y. Kim, C.-K. Hur, D. Dreyer, and V. Vafeiadis. Lightweight verification
[48] A. Kennedy. Securing the .NET programming model. Theoretical Computer
of separate compilation. POPL, 2016.
Science, 364(3):311–317, 2006.
[49] D. Kilpatrick. Privman: A library for partitioning applications. USENIX FREENIX.
Secure Compilation Meeting (SCM), 2017.
[50] T. F. Knight, Jr., A. DeHon, A. Sutherland, U. Dhawan, A. Kwon, and S. Ray. SAFE
S&P. 1993.
ISA (version 3.0 with interrupts per thread), 2012.
[51] R. Krebbers. The C Standard Formalized in Coq. PhD thesis, Radboud University
2003.
Nijmegen, 2015.
[52] J. Kroll, G. Stewart, and A. Appel. Portable software fault isolation. CSF. 2014.
[53] O. Kupferman and M. Y. Vardi. Robust satisfaction. CONCUR, 1999.
[54] L. Lamport and F. B. Schneider. Formal foundation for specification and verifi-
cation. In Distributed Systems: Methods and Tools for Specification, An Advanced
Course, 1984.
[55] L. Lamport, R. E. Shostak, and M. C. Pease. The byzantine generals problem.
ACM Transactions on Programming Languages and Systems, 4(3):382–401, 1982.
[56] C. Lattner. What every C programmer should know about undefined behavior
#1/3. LLVM Project Blog, 2011.
[57] J. Lee, Y. Kim, Y. Song, C. Hur, S. Das, D. Majnemer, J. Regehr, and N. P. Lopes.
Taming undefined behavior in LLVM. PLDI, 2017.
[58] X. Leroy. Formal verification of a realistic compiler. CACM, 52(7):107–115, 2009.
[59] X. Leroy and S. Blazy. Formal verification of a C-like memory model and its uses
for verifying program transformations. JAR, 41(1):1–31, 2008.
[60] G. Morrisett, G. Tan, J. Tassarotti, J.-B. Tristan, and E. Gan. RockSalt: Better,
faster, stronger SFI for the x86. PLDI. 2012.
[61] E. Mullen, D. Zuniga, Z. Tatlock, and D. Grossman. Verified peephole optimiza-
tions for CompCert. PLDI, 2016.
[62] T. C. Murray, D. Matichuk, M. Brassil, P. Gammie, T. Bourke, S. Seefried, C. Lewis,
X. Gao, and G. Klein. seL4: From general purpose to a proof of information flow
enforcement. IEEE S&P. 2013.
[63] M. S. New, W. J. Bowman, and A. Ahmed. Fully abstract compilation via universal
embedding. ICFP, 2016.
[64] Z. Paraskevopoulou, C. Hriţcu, M. Dénès, L. Lampropoulos, and B. C. Pierce.
Foundational property-based testing. ITP. 2015.
[65] M. Patrignani, P. Agten, R. Strackx, B. Jacobs, D. Clarke, and F. Piessens. Secure
compilation to protected module architectures. TOPLAS, 2015.
[66] M. Patrignani and D. Clarke. Fully abstract trace semantics for protected module
[67] M. Patrignani, D. Devriese, and F. Piessens. On modular and fully-abstract
architectures. CL, 42:22–45, 2015.
compilation. CSF. 2016.
[68] M. Patrignani and D. Garg. Robustly safe compilation. ESOP, 2019.
[69] N. Provos, M. Friedl, and P. Honeyman. Preventing privilege escalation. In 12th
USENIX Security Symposium. 2003.
[70] J. Regehr. A guide to undefined behavior in C and C++, part 3. Embedded in
[71] C. Reis and S. D. Gribble. Isolating web programs in modern browser architectures.
[72] T. Sewell, S. Winwood, P. Gammie, T. C. Murray, J. Andronick, and G. Klein. seL4
[73] L. Skorstengaard, D. Devriese, and L. Birkedal. Enforcing well-bracketed control
flow and stack encapsulation using linear capabilities. 2nd Workshop on Principles
of Secure Compilation (PriSC), 2018.
[74] L. Skorstengaard, D. Devriese, and L. Birkedal. Reasoning about a machine with
local capabilities - provably safe stack and return pointer management. ESOP,
2018.
[75] D. Swasey, D. Garg, and D. Dreyer. Robust and compositional verification of
object capability patterns. PACMPL, 1(OOPSLA):89:1–89:26, 2017.
Academia blog, 2010.
EuroSys. 2009.
enforces integrity. ITP. 2011.
18