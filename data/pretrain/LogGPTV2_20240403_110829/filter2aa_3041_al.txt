代码清单 4-38 使用 for range 迭代切片
// 创建一个整型切片 
// 其长度和容量都是 4 个元素 
slice := []int{10, 20, 30, 40} 
// 迭代每一个元素，并显示其值 
for index, value := range slice { 
 fmt.Printf("Index: %d  Value: %d\n", index, value) 
} 
Output: 
Index: 0  Value: 10 
Index: 1  Value: 20 
Index: 2  Value: 30 
Index: 3  Value: 40 
当迭代切片时，关键字 range 会返回两个值。第一个值是当前迭代到的索引位置，第二个
值是该位置对应元素值的一份副本（见图 4-19）。 
图 4-19  使用 range 迭代切片会创建每个元素的副本
需要强调的是，range 创建了每个元素的副本，而不是直接返回对该元素的引用，如代码
清单 4-39 所示。如果使用该值变量的地址作为指向每个元素的指针，就会造成错误。让我们看看
是为什么。 
代码清单 4-39 range 提供了每个元素的副本
// 创建一个整型切片 
// 其长度和容量都是 4 个元素 
slice := []int{10, 20, 30, 40} 
// 迭代每个元素，并显示值和地址 
for index, value := range slice { 
 fmt.Printf("Value: %d  Value-Addr: %X  ElemAddr: %X\n", 
 value, &value, &slice[index]) 
} 
Output: 
Value: 10  Value-Addr: 10500168  ElemAddr: 1052E100 
Value: 20  Value-Addr: 10500168  ElemAddr: 1052E104 
Value: 30  Value-Addr: 10500168  ElemAddr: 1052E108 
Value: 40  Value-Addr: 10500168  ElemAddr: 1052E10C 
因为迭代返回的变量是一个迭代过程中根据切片依次赋值的新变量，所以 value 的地址总
是相同的。要想获取每个元素的地址，可以使用切片变量和索引值。 
如果不需要索引值，可以使用占位字符来忽略这个值，如代码清单 4-40 所示。 
代码清单 4-40 使用空白标识符（下划线）来忽略索引值 
// 创建一个整型切片 
// 其长度和容量都是 4 个元素 
slice := []int{10, 20, 30, 40} 
// 迭代每个元素，并显示其值 
for _, value := range slice { 
 fmt.Printf("Value: %d\n", value) 
} 
Output: 
Value: 10 
Value: 20 
Value: 30 
Value: 40 
关键字 range 总是会从切片头部开始迭代。如果想对迭代做更多的控制，依旧可以使用传
统的 for 循环，如代码清单 4-41 所示。
代码清单 4-41 使用传统的 for 循环对切片进行迭代
// 创建一个整型切片 
// 其长度和容量都是 4 个元素 
slice := []int{10, 20, 30, 40} 
// 从第三个元素开始迭代每个元素 
for index := 2; index < len(slice); index++ { 
 fmt.Printf("Index: %d  Value: %d\n", index, slice[index]) 
} 
Output: 
Index: 2  Value: 30 
Index: 3  Value: 40 
有两个特殊的内置函数 len 和 cap，可以用于处理数组、切片和通道。对于切片，函数 len
返回切片的长度，函数 cap 返回切片的容量。在代码清单 4-41 里，我们使用函数 len 来决定什
么时候停止对切片的迭代。 
现在知道了如何创建和使用切片。可以组合多个切片成为多维切片，并对其进行迭代。 
4.2.4  多维切片 
和数组一样，切片是一维的。不过，和之前对数组的讨论一样，可以组合多个切片形成多维
切片，如代码清单 4-42 所示。 
代码清单 4-42 声明多维切片 
// 创建一个整型切片的切片 
slice := [][]int{{10}, {100, 200}} 
我们有了一个包含两个元素的外层切片，每个元素包含一个内层的整型切片。切片 slice
的值看起来像图 4-20 展示的样子。 
图 4-20  整型切片的切片的值 
在图 4-20 里，可以看到组合切片的操作是如何将一个切片嵌入到另一个切片中的。外层的
切片包括两个元素，每个元素都是一个切片。第一个元素中的切片使用单个整数 10 来初始化，
第二个元素中的切片包括两个整数，即 100 和 200。 
这种组合可以让用户创建非常复杂且强大的数据结构。已经学过的关于内置函数 append
的规则也可以应用到组合后的切片上，如代码清单 4-43 所示。 
代码清单 4-43 组合切片的切片 
// 创建一个整型切片的切片 
slice := [][]int{{10}, {100, 200}} 
// 为第一个切片追加值为 20 的元素 
slice[0] = append(slice[0], 20) 
Go 语言里使用 append 函数处理追加的方式很简明：先增长切片，再将新的整型切片赋值
给外层切片的第一个元素。当代码清单 4-43 中的操作完成后，会为新的整型切片分配新的底层数
组，然后将切片复制到外层切片的索引为 0 的元素，如图 4-21 所示。 
图 4-21  append 操作之后外层切片索引为 0 的元素的布局
即便是这么简单的多维切片，操作时也会涉及众多布局和值。看起来在函数间像这样传递数
据结构也会很复杂。不过切片本身结构很简单，可以以很小的成本在函数间传递。 
4.2.5  在函数间传递切片 
在函数间传递切片就是要在函数间以值的方式传递切片。由于切片的尺寸很小，在函数间复
制和传递切片成本也很低。让我们创建一个大切片，并将这个切片以值的方式传递给函数 foo，
如代码清单 4-44 所示。 
代码清单 4-44 在函数间传递切片 
// 分配包含 100 万个整型值的切片 
slice := make([]int, 1e6) 
// 将 slice 传递到函数 foo 
slice = foo(slice) 
// 函数 foo 接收一个整型切片，并返回这个切片 
func foo(slice []int) []int { 
 ... 
 return slice 
} 
在 64 位架构的机器上，一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量
字段分别需要 8 字节。由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片
复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底
层数组（见图 4-22）。 
图 4-22  函数调用之后两个切片指向同一个底层数组 
在函数间传递 24 字节的数据会非常快速、简单。这也是切片效率高的地方。不需要传递指
针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本。 
4.3  映射的内部实现和基础功能 
映射是一种数据结构，用于存储一系列无序的键值对。 
映射里基于键来存储值。图 4-23 通过一个例子展示了映射里键值对是如何存储的。映射功
能强大的地方是，能够基于键快速检索数据。键就像索引一样，指向与该键关联的值。 
图 4-23  键值对的关系 
4.3.1  内部实现 
映射是一个集合，可以使用类似处理数组和切片的方式迭代映射中的元素。但映射是无序的
集合，意味着没有办法预测键值对被返回的顺序。即便使用同样的顺序保存键值对，每次迭代映
射的时候顺序也可能不一样。无序的原因是映射的实现使用了散列表，见图 4-24。 
图 4-24  映射的内部结构的简单表示 
映射的散列表包含一组桶。在存储、删除或者查找键值对的时候，所有操作都要先选择一个
桶。把操作映射时指定的键传给映射的散列函数，就能选中对应的桶。这个散列函数的目的是生
成一个索引，这个索引最终将键值对分布到所有可用的桶里。 
随着映射存储的增加，索引分布越均匀，访问键值对的速度就越快。如果你在映射里存储了
10 000 个元素，你不希望每次查找都要访问 10 000 个键值对才能找到需要的元素，你希望查找
键值对的次数越少越好。对于有 10 000 个元素的映射，每次查找只需要查找 8 个键值对才是一
个分布得比较好的映射。映射通过合理数量的桶来平衡键值对的分布。 
Go 语言的映射生成散列键的过程比图 4-25 展示的过程要稍微长一些，不过大体过程是类似
的。在我们的例子里，键是字符串，代表颜色。这些字符串会转换为一个数值（散列值）。这个
数值落在映射已有桶的序号范围内表示一个可以用于存储的桶的序号。之后，这个数值就被用于
选择桶，用于存储或者查找指定的键值对。对 Go 语言的映射来说，生成的散列键的一部分，具
体来说是低位（LOB），被用来选择桶。 
如果再仔细看看图 4-24，就能看出桶的内部实现。映射使用两个数据结构来存储数据。第一
个数据结构是一个数组，内部存储的是用于选择桶的散列键的高八位值。这个数组用于区分每个
键值对要存在哪个桶里。第二个数据结构是一个字节数组，用于存储键值对。该字节数组先依次
存储了这个桶里所有的键，之后依次存储了这个桶里所有的值。实现这种键值对的存储方式目的
在于减少每个桶所需的内存。 
图 4-25  简单描述散列函数是如何工作的 
映射底层的实现还有很多细节，不过这些细节超出了本书的范畴。创建并使用映射并不需要
了解所有的细节，只要记住一件事：映射是一个存储键值对的无序集合。 
4.3.2  创建和初始化 
Go 语言中有很多种方法可以创建并初始化映射，可以使用内置的 make 函数（如代码清单 4-45
所示），也可以使用映射字面量。 
代码清单 4-45 使用 make 声明映射
// 创建一个映射，键的类型是 string，值的类型是 int 
dict := make(map[string]int) 
// 创建一个映射，键和值的类型都是 string 
// 使用两个键值对初始化映射 
dict := map[string]string{"Red": "#da1337", "Orange": "#e95a22"} 
创建映射时，更常用的方法是使用映射字面量。映射的初始长度会根据初始化时指定的键值
对的数量来确定。 
映射的键可以是任何值。这个值的类型可以是内置的类型，也可以是结构类型，只要这个值
可以使用==运算符做比较。切片、函数以及包含切片的结构类型这些类型由于具有引用语义，
不能作为映射的键，使用这些类型会造成编译错误，如代码清单 4-46 所示。 
代码清单 4-46 使用映射字面量声明空映射 
// 创建一个映射，使用字符串切片作为映射的键 
dict := map[[]string]int{} 
Compiler Exception: 
invalid map key type []string 
没有任何理由阻止用户使用切片作为映射的值，如代码清单 4-47 所示。这个在使用一个映射
键对应一组数据时，会非常有用。 
代码清单 4-47 声明一个存储字符串切片的映射 
// 创建一个映射，使用字符串切片作为值 
dict := map[int][]string{} 
4.3.3  使用映射 
键值对赋值给映射，是通过指定适当类型的键并给这个键赋一个值来完成的，如代码清
单 4-48 所示。 
代码清单 4-48 为映射赋值 
// 创建一个空映射，用来存储颜色以及颜色对应的十六进制代码 
colors := map[string]string{} 
// 将 Red 的代码加入到映射 
colors["Red"] = "#da1337" 
可以通过声明一个未初始化的映射来创建一个值为 nil 的映射（称为 nil 映射 ）。nil 映射
不能用于存储键值对，否则，会产生一个语言运行时错误，如代码清单 4-49 所示。 
代码清单 4-49 对 nil 映射赋值时的语言运行时错误
// 通过声明映射创建一个 nil 映射 
var colors map[string]string 
// 将 Red 的代码加入到映射 
colors["Red"] = "#da1337" 
Runtime Error: 
panic: runtime error: assignment to entry in nil map 
测试映射里是否存在某个键是映射的一个重要操作。这个操作允许用户写一些逻辑来确定是
否完成了某个操作或者是否在映射里缓存了特定数据。这个操作也可以用来比较两个映射，来确
定哪些键值对互相匹配，哪些键值对不匹配。 
从映射取值时有两个选择。第一个选择是，可以同时获得值，以及一个表示这个键是否存在
的标志，如代码清单 4-50 所示。 
代码清单 4-50 从映射获取值并判断键是否存在 
// 获取键 Blue 对应的值 
value, exists := colors["Blue"] 
// 这个键存在吗？ 
if exists { 
 fmt.Println(value) 
} 
另一个选择是，只返回键对应的值，然后通过判断这个值是不是零值来确定键是否存在，如
代码清单 4-51 所示。
①
① 这种方法只能用在映射存储的值都是非零值的情况。——译者注
代码清单 4-51 从映射获取值，并通过该值判断键是否存在 
// 获取键 Blue 对应的值 
value := colors["Blue"] 
// 这个键存在吗？ 
if value != "" { 
 fmt.Println(value) 
} 
在 Go 语言里，通过键来索引映射时，即便这个键不存在也总会返回一个值。在这种情况下，
返回的是该值对应的类型的零值。 
迭代映射里的所有值和迭代数组或切片一样，使用关键字 range，如代码清单 4-52 所示。
但对映射来说，range 返回的不是索引和值，而是键值对。
代码清单 4-52 使用 range 迭代映射
// 创建一个映射，存储颜色以及颜色对应的十六进制代码 
colors := map[string]string{ 
 "AliceBlue":   "#f0f8ff", 
 "Coral":       "#ff7F50", 
 "DarkGray":    "#a9a9a9", 
 "ForestGreen": "#228b22", 
} 
// 显示映射里的所有颜色 
for key, value := range colors { 
 fmt.Printf("Key: %s  Value: %s\n", key, value) 
} 
如果想把一个键值对从映射里删除，就使用内置的 delete 函数，如代码清单 4-53 所示。
代码清单 4-53 从映射中删除一项 
// 删除键为 Coral 的键值对 
delete(colors, "Coral") 
// 显示映射里的所有颜色 
for key, value := range colors { 
 fmt.Printf("Key: %s  Value: %s\n", key, value) 
} 
这次在迭代映射时，颜色 Coral 不会显示在屏幕上。 
4.3.4  在函数间传递映射 
在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对
这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改，如代码清单 4-54 所示。 
代码清单 4-54 在函数间传递映射 
func main() { 
 // 创建一个映射，存储颜色以及颜色对应的十六进制代码 
 colors := map[string]string{ 
 "AliceBlue":   "#f0f8ff", 
 "Coral":       "#ff7F50", 
 "DarkGray":    "#a9a9a9", 
 "ForestGreen": "#228b22", 
 } 
 // 显示映射里的所有颜色 
 for key, value := range colors { 
 fmt.Printf("Key: %s  Value: %s\n", key, value) 
 } 
 // 调用函数来移除指定的键 
 removeColor(colors, "Coral") 
 // 显示映射里的所有颜色 
 for key, value := range colors { 
 fmt.Printf("Key: %s  Value: %s\n", key, value) 
 } 
} 
// removeColor 将指定映射里的键删除 
func removeColor(colors map[string]string, key string) { 
 delete(colors, key) 
} 
如果运行这个程序，会得到代码清单 4-55 所示的输出。 
代码清单 4-55 代码清单 4-54 的输出 
Key: AliceBlue Value: #F0F8FF 
Key: Coral Value: #FF7F50 
Key: DarkGray Value: #A9A9A9 
Key: ForestGreen Value: #228B22 
Key: AliceBlue Value: #F0F8FF 
Key: DarkGray Value: #A9A9A9 
Key: ForestGreen Value: #228B22 
可以看到，在调用了 removeColor 之后，main 函数里引用的映射中不再有 Coral 颜色
了。这个特性和切片类似，保证可以用很小的成本来复制映射。 
4.4  小结 
数组是构造切片和映射的基石。
Go 语言里切片经常用来处理数据的集合，映射用来处理具有键值对结构的数据。
内置函数 make 可以创建切片和映射，并指定原始的长度和容量。也可以直接使用切片
和映射字面量，或者使用字面量作为变量的初始值。 
切片有容量限制，不过可以使用内置的 append 函数扩展容量。
映射的增长没有容量或者任何限制。
内置函数 len 可以用来获取切片或者映射的长度。
内置函数 cap 只能用于切片。
通过组合，可以创建多维数组和多维切片。也可以使用切片或者其他映射作为映射的值。
但是切片不能用作映射的键。 
将切片或者映射传递给函数成本很小，并且不会复制底层的数据结构。
第 5 章 Go 语言的类型系统 
本章主要内容 