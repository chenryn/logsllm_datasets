        CloseHandle(hProcess);
36
        return FALSE;
37
    }
38
39
    // 4. 拷贝DLL路径名字到目标进程的内存
40
    bRet = WriteProcessMemory(hProcess, lpAllocAddr, szDllPathName, dwLength, NULL);
41
    if (!bRet) {
42
        OutputDebugString("WriteProcessMemory failed! \n");
43
        CloseHandle(hProcess);
44
        return FALSE;
45
    }
46
47
    // 5. 获取模块句柄
48
    // LoadLibrary这个函数是在kernel32.dll这个模块中的，所以需要现货区kernel32.dll这个模块的句柄
49
    hModule = GetModuleHandle("kernel32.dll");
50
    if (!hModule) {
51
        OutputDebugString("GetModuleHandle failed! \n");
52
        CloseHandle(hProcess);
53
        return FALSE;
54
    }
55
滴水逆向课程笔记  –  Win32
远程线程注入  –  144
注入成功：
56
    // 6. 获取LoadLibraryA函数地址
57
    dwLoadAddr = (DWORD)GetProcAddress(hModule, "LoadLibraryA");
58
    if (!dwLoadAddr){
59
        OutputDebugString("GetProcAddress failed! \n");
60
        CloseHandle(hModule);
61
        CloseHandle(hProcess);
62
        return FALSE;
63
    }
64
65
    // 7. 创建远程线程，加载DLL
66
    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)dwLoadAddr, 
lpAllocAddr, 0, &dwThreadID);
67
    if (!hThread){
68
        OutputDebugString("CreateRemoteThread failed! \n");
69
        CloseHandle(hModule);
70
        CloseHandle(hProcess);
71
        return FALSE;
72
    }
73
74
    // 8. 关闭进程句柄
75
    CloseHandle(hThread);
76
    CloseHandle(hProcess);
77
78
    return TRUE;
79
}
80
81
int main(int argc, char* argv[]) {
82
83
    LoadDll(384, "C:\\Documents and Settings\\Administrator\\桌面\\test\\B.dll");
84
    getchar();
85
    return 0;
86
}
87
滴水逆向课程笔记  –  Win32
远程线程注入  –  145
滴水逆向课程笔记  –  Win32
进程间通信  –  146
29 进程间通信
同一台机器上进程之间的通信虽然有很多种方法，但其本质就是共享内存。
29.1 举例说明
假设现在我们进程A的代码是这样的：
滴水逆向课程笔记  –  Win32
进程间通信  –  147
这就是获取输入的字符来攻击、打坐、加血的小程序，我们想要自动化的控制这个程序而不是自己输入该怎么
办？这时候就需要使用平时中大家常提的外挂技术，在这里实际上就是远程线程注入，通过进程B控制进程A的
执行流程。
如下是DLL文件的代码：
void Attack()
1
{
2
    printf("**********攻击********** \n");
3
    return;
4
}
5
6
void Rest()
7
{
8
    printf("**********打坐********** \n");
9
    return;
10
}
11
12
void Blood()
13
{
14
    printf("**********加血********** \n");
15
    return;
16
}
17
18
int main(int argc, char* argv[]) {
19
    char cGetchar;
20
    printf("**********GAME BEGIN********** \n");
21
    while(1) {
22
        cGetchar = getchar();
23
        switch(cGetchar) {
24
        case 'A':
25
            {
26
                Attack();
27
                break;
28
            }
29
        case 'R':
30
            {
31
                Rest();
32
                break;
33
            }
34
        case 'B':
35
            {
36
                Blood();
37
                break;
38
            }
39
        }
40
    }
41
    return 0;
42
}
43
滴水逆向课程笔记  –  Win32
进程间通信  –  148
// B.cpp : Defines the entry point for the DLL application.
1
//
2
3
#include "stdafx.h"
4
5
#define _MAP_ "共享内存"
6
7
// 首先需要获取函数的地址
8
#define ATTACK 0x00401030
9
#define REST 0x00401080
10
#define BLOOD 0x004010D0
11
12
HANDLE g_hModule;
13
HANDLE g_hMapFile;
14
LPTSTR lpBuffer;
15
DWORD dwType;
16
17
DWORD WINAPI ThreadProc(LPVOID lpParameter)
18
{
19
    dwType = 0;
20
    g_hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, _MAP_);
21
22
    if (g_hMapFile == NULL)
23
    {
24
        printf("OpenFileMapping failed: %d", GetLastError());
25
        return 0;
26
    }
27
28
    //映射内存
29
    lpBuffer = (LPTSTR)MapViewOfFile(g_hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, BUFSIZ);
30
31
    for (;;)
32
    {
33
        if (lpBuffer != NULL)
34
        {
35
            // 读取数据
36
            CopyMemory(&dwType, lpBuffer, 4);
37
        }
38
39
        if (dwType == 1)
40
        {
41
            // 攻击
42
            __asm {
43
                mov eax, ATTACK
44
                    call eax
45
            }
46
            dwType == 0;
47
            CopyMemory(&dwType, lpBuffer, 4);
48
        }
49
50
        if (dwType == 2)
51
        {
52
            // 打坐
53
            __asm {
54
                mov eax, REST
55
滴水逆向课程笔记  –  Win32
进程间通信  –  149
需要注意的是我们首先需要获取函数的地址，这个我们可以通过VC6反汇编来寻找：
                    call eax
56
            }
57
            dwType == 0;
58
            CopyMemory(&dwType, lpBuffer, 4);
59
        }
60
61
        if (dwType == 3)
62
        {
63
            // 加血
64
            __asm {
65
                mov eax, BLOOD
66
                    call eax
67
            }
68
            dwType == 0;
69
            CopyMemory(&dwType, lpBuffer, 4);
70
        }
71
72
        if (dwType == 4)
73
        {
74
            //卸载自身并退出
75
            FreeLibraryAndExitThread((HMODULE)g_hModule, 0);
76
        }
77
78
        Sleep(500);
79
    }
80
81
    return 0;
82
}
83
84
BOOL APIENTRY DllMain( HMODULE hModule,
85
                      DWORD  ul_reason_for_call,
86
                      LPVOID lpReserved
87
                      )
88
{
89
    switch (ul_reason_for_call) {
90
    case DLL_PROCESS_ATTACH:
91
        {
92
            CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThreadProc, NULL, 0, NULL);
93
            break;
94
        }
95
    }
96
    return TRUE;
97
}
98
滴水逆向课程笔记  –  Win32
进程间通信  –  150
编译好DLL之后，我们需要一个进程B来控制进程A，代码如下：
滴水逆向课程笔记  –  Win32
进程间通信  –  151
#include 
1
#include 
2
#include 
3
4
#define _MAP_ "共享内存"
5