title:From Collision To Exploitation: Unleashing Use-After-Free Vulnerabilities
in Linux Kernel
author:Wen Xu and
Juanru Li and
Junliang Shu and
Wenbo Yang and
Tianyi Xie and
Yuanyuan Zhang and
Dawu Gu
From Collision To Exploitation:
Unleashing Use-After-Free Vulnerabilities in Linux Kernel
Wen Xu, Juanru Li, Junliang Shu, Wenbo Yang
∗
Tianyi Xie, Yuanyuan Zhang
Shanghai Jiao Tong University
800 Dongchuan Road, Shanghai, China
, Dawu Gu
ABSTRACT
Since vulnerabilities in Linux kernel are on the increase, at-
tackers have turned their interests into related exploitation
techniques. However, compared with numerous researches
on exploiting use-after-free vulnerabilities in the user ap-
plications, few eﬀorts studied how to exploit use-after-free
vulnerabilities in Linux kernel due to the diﬃculties that
mainly come from the uncertainty of the kernel memory lay-
out. Without speciﬁc information leakage, attackers could
only conduct a blind memory overwriting strategy trying to
corrupt the critical part of the kernel, for which the success
rate is negligible.
In this work, we present a novel memory collision strat-
egy to exploit the use-after-free vulnerabilities in Linux ker-
nel reliably. The insight of our exploit strategy is that a
probabilistic memory collision can be constructed according
to the widely deployed kernel memory reuse mechanisms,
which signiﬁcantly increases the success rate of the attack.
Based on this insight, we present two practical memory
collision attacks: An object-based attack that leverages
the memory recycling mechanism of the kernel allocator to
achieve freed vulnerable object covering, and a physmap-
based attack that takes advantage of the overlap between
the physmap and the SLAB caches to achieve a more ﬂex-
ible memory manipulation. Our proposed attacks are uni-
versal for various Linux kernels of diﬀerent architectures
and could successfully exploit systems with use-after-free
vulnerabilities in kernel. Particularly, we achieve privilege
escalation on various popular Android devices (kernel ver-
sion>=4.3) including those with 64-bit processors by ex-
ploiting the CVE-2015-3636 use-after-free vulnerability in
Linux kernel. To our knowledge, this is the ﬁrst generic
kernel exploit for the latest version of Android. Finally,
to defend this kind of memory collision, we propose two
corresponding mitigation schemes.
Categories and Subject Descriptors: D.4.6 [Operating
Systems]: Security and Protection
∗Corresponding author: PI:EMAIL
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12-16, 2015, Denver, CO, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813637.
General Terms: Security.
Keywords: Memory Collision; User-after-free Vulnerabil-
ity; Linux Kernel Exploit
1.
INTRODUCTION
Recent mitigation eﬀorts such as DEP, ASLR, stack ca-
naries, and sandbox isolation signiﬁcantly increase the cost
to compromise user level applications and thus attackers
turn their interests into OS kernels. Compared with user
applications, current OS kernels are of high interest to at-
tackers for two main reasons. First, attacking the core is
always more eﬀective. If the sandbox of a user application
cannot be bypassed, attackers are not able to do anything
that causes real damage to the system or other applications,
especially on Android and iOS devices. However, if an at-
tacker was able to compromise the kernel and achieve code
execution in the kernel context, he could take the complete
control of the system and there would be no need to by-
pass the sandbox. Second, less protection and mitigation
schemes are applied to the OS kernel compared with that
for the applications.
With the improvement of security in Linux kernel, vulner-
abilities such as logical errors and checks missing on argu-
ments and privileges become rare. It is also hard for attack-
ers to exploit vulnerabilities like NULL pointer dereferences
as well as stack overﬂows due to the stack canary applied
in Linux kernel [7]. Thus the kernel heap related vulner-
abilities such as heap overﬂows and use-after-free become
signiﬁcant targets for attackers to exploit nowadays. How-
ever, exploiting a heap vulnerability (e.g. use-after-free) in
the kernel is still non-trivial although there are fewer related
mitigation and protection schemes in action than with user
applications. A particular heap layout is hard to be con-
structed in Linux kernel since various tasks are running in
the kernel and have an impact on the kernel heap simulta-
neously. To eﬀectively and eﬃciently exploit use-after-free
vulnerabilities in Linux kernel, the following challenges need
to be addressed:
Stability: As a modern operating system, Linux supports
multi-thread scheduling, which means that large amounts
of tasks may run on the system simultaneously. Every task
has the possibility to inﬂuence the kernel, which may lead
to the allocation or de-allocation of kernel objects at any
time. The behavior of the kernel allocator is unstable and
unpredictable under such circumstance, and this is the most
troublesome part for the kernel exploit. A successful at-
tack should overwrite the target kernel object without un-
expected corruption.
Separation: Due to the inner workings of Linux kernel’s
allocators (SLAB and SLUB allocator, described in Sec-
tion 3), diﬀerent types of kernel objects cannot be stored in
the same memory region. The memory overwriting based
attack work needs to circumvent such restriction to fulﬁl
the target.
Data Control : When memory gets overwritten, the new
object appears at the location once occupied by the freed
object and ﬁll the freed object with its data. The covering
data is crucial when exploiting a memory corruption bug
like use-after-free. Thus it is important for the collision
attack to not only occupy the space but also fully control
the ﬁlling data.
To address these challenges, we propose a novel memory
collision attack strategy to be universally applied to exploit
use-after-free vulnerabilities in Linux kernel. The basic in-
sight of our attack is that the memory allocation and reuse
mechanisms of the kernel expose certain patterns, which
can be leveraged to construct a memory collision (a prob-
abilistic memory overwriting) with high success rate. For
instance, due to physical memory limitation, the system al-
ways ﬁrst recycles the recently freed memory for a future
allocation, in order to improve performance and save en-
ergy. Such behavior reduces the entropy of the memory
layout and leads to a high probability of a memory colli-
sion. Using this behavior in our attack allows us to exploit
these memory collision style vulnerabilities with a high rate
of appearance. That justiﬁes why nowadays collision style
vulnerabilities are likely to be occur and attackers always
manage to exploit them.
As a proof of concept, two practical attacks are con-
structed based on our memory collision attack strategy:
Object-based attack : The ﬁrst attack mainly uses the ker-
nel buﬀers created by calling kmalloc to create a collision
with the freed vulnerable object and ﬁll it with the spe-
ciﬁc data. It is based on the observation that a successful
memory collision in kernel can be achieved with the size
separation provided by the SLUB allocator. Since objects
of diﬀerent types might share the same size, they can be
arranged into one cache by the SLUB allocator with a well-
designed attack. We present two types of object-based at-
tacks. One is a collision attack between objects of the same
size, which is stable but comes with many restrictions. The
other is a collision attack between objects of diﬀerent sizes,
which circumvents the object isolation provided by the ker-
nel allocator.
Physmap-based attack : The second attack mainly uses
the physmap in the kernel to achieve memory collision and
is more powerful. The physmap is a large virtual memory
region inside the kernel address space that contains a direct
mapping of all or a part of the physical memory. The usage
of the physmap to bypass application level protections is
ﬁrst mentioned in [17]. And based on the previous work, we
discover an unexpected and powerful use of the physmap,
which is to re-ﬁll the freed vulnerable objects. This leads to
a generic, stable and reliable exploitation of use-after-free
Linux kernel.
In short, our attack can completely bypass the separa-
tion provided by the SLAB/SLUB allocator. We ﬁnd that
almost all the use-after-free vulnerabilities in Linux kernel
can be exploited by adopting our attack model. In fact, the
proposed physmap-based attack overcomes most diﬃculties
encountered while exploiting use-after-free bugs mentioned
above, and is universally applied for both 32-bit and 64-bit
versions of Linux on various architectures including the An-
droid kernel. To validate the eﬀectiveness and wide appli-
cability of our attacks, a number of experiments are carried
out. Particularly, We demonstrate a generic Android ker-
nel exploit using CVE-2015-3636, a vulnerability cred-
ited to the author, to root most Android devices on the
market nowadays including the 64-bit ones. Furthermore,
two eﬀective mitigation against the related attacks are also
presented in this paper.
2. A BIRD’S-EYE VIEW
2.1 Use-after-free Vulnerabilities in Linux Ker-
nel
When a use-after-free vulnerability is associated with a
kernel object, the memory it once occupied can be accessed
by attackers again after the de-allocation by kernel alloca-
tors. Considering the following code in Listing 1 as a typical
example. It is a vulnerable kernel module that introduces a
new syscall and one can allocate kernel objects of 512-byte
in a cache by option 1 and free the objects previously allo-
cated by option 2. When using option 3, a function pointer
stored in a speciﬁed kernel object is to be invoked. If the
object has been freed and then ﬁlled with data controlled by
attacker, the EIP/RIP register for x86/x64 architecture or
the PC register for ARM architecture is to be hijacked to
injected shellcode and an arbitrary code execution in kernel
context will be achieved.
Listing 1: Vulnerable Kernel Module
1 ...
2 asmlinkage int sys_vuln (int opt, int index) {
3
...
switch (opt) {
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
case 1: // Allocate
...
obj[total++] = kmem_cache_alloc(cachep,
GFP_KERNEL);
break;
case 2: // Free
...
free(obj[index]);
...
break;
case 3: // Use
...
/* no status checking */
void (*fp)(void) = (void (*)(void))(*(
unsigned long *)obj[index]);
fp();
break;
}
...
/* Return index of the allocated object */
return total - 1;
}
25
26 static int __init initmodule (void) {
27
...
cachep = kmem_create_cache("vuln_cache", 512, 0,
SLAB_HWCACHE_ALIGN, NULL);
sct = (unsigned long **)SYS_CALL_TABLE;
sct[NR_SYS_UNUSED] = sys_vuln;
...
28
29
30
31
}
32
33 ...
In fact, it is non-trivial to precisely re-occupy the mem-
ory once belonged to the vulnerable object when exploiting
such a kernel use-after-free vulnerability. The complexity
and diversity of memory layout of Linux kernel makes it
very diﬃcult to arrange an exploit precisely. In contrast to
user programs, to achieve memory overwriting in OS ker-
nel is much harder. The hardness comes from the fact that
many tasks are scheduled concurrently on one core and all
of them may have impacts on the kernel heap. Thus attack-
ers can no longer predict the precise memory layout of the
kernel space. The working mechanisms of the kernel alloca-
tors may also sharply decrease the probability of a memory
overwriting in the kernel, including the randomness of allo-
cations, the separation of kernel objects of diﬀerent types
and the support of per-CPU caches. Without speciﬁc infor-
mation leakage, attackers can only perform a blind memory
ﬁlling trying to overwrite the critical memory region with
slim probability of success.
2.2 Memory Collision Strategy
Our proposed attack introduces a novel memory collision
strategy, which guarantees that the memory region con-
trolled by attackers could overlap the critical memory region
with signiﬁcant stability. We illustrate in Figure 1 the prin-
ciple of our proposed memory collision strategy. Basically,