pdf
html
jpg
doc
txt
xls
ppt
xml
gif
ps
csv
gz
log
unk
eps
png
others
Total
Number
Num %
2378
2117
1073
797
788
584
501
353
349
208
188
128
99
59
40
39
141
9876
24.08
21.43
10.86
8.07
7.98
5.91
5.07
3.57
3.53
2.11
1.90
1.30
1.00
0.60
0.41
0.39
1.77
100
Size
Avg (KB) Total (MB) %
565.27
59.15
335.08
361.92
553.89
587.68
2110.94
132.59
81.64
764.85
202.77
628.64
170.80
358.53
516.59
312.85
343.62
449.44
1312.70
122.29
351.12
281.69
426.23
335.16
1032.80
45.71
27.83
155.36
37.23
78.58
16.51
20.66
20.18
11.92
58.72
4334.67
30.28
2.82
8.10
6.50
9.83
7.73
23.82
1.10
0.64
3.58
0.86
1.81
3.81
4.77
4.66
2.75
1.35
100
been completed). The notification procedure takes little time and
most of the execution time of encryption ransomware is spent on
the encryption part.
We observed that ten families complete the file encryption in
less than an hour. For ransomware CTB-Locker, JigSaw, Mobef and
Petya, their encryption takes even less than 20 minutes. Moreover,
we discovered that some ransomware encrypt only small files or
files with certain extensions. For example, JigSaw encrypts only
files smaller than 10 MB, CTB-Locker only locks up files with cer-
tain extensions and Petya only encrypts a system’s Master File
Table (MFT) [27].
Observation 1: Ransomware typically locks up data rapidly
and the size of the data encrypted is relatively small.
Implication: Ransomware would like to minimize the
chances of being terminated and caught, or ransomware au-
thors may want to collect ransom quickly.
Table 1 also shows that eight ransomware families attempt to
delete backup files. Recall that we assigned ransomware samples
the administrator privilege, which grants the ransomware the per-
mission to destroy backups. We observed that some ransomware
families attempt to bypass User Access Control if the privilege
of deleting the backup files is not given. For instance, cerber [4]
firstly escalates its privilege and then deletes Shadow Copies using
the WMIC utility [56].
Observation 2: Ransomware variants proactively try to re-
move any means that victims could have to recover from the
attack without paying the ransom.
Implication: Ransomware can obtain kernel privilege to ter-
minate or destroy software-based defense systems such as
explicit data backups.
Figure 1: The system architecture of using an SSD. The main
idea of FlashGuard is proposed and implemented in the
Flash Translation Layer (FTL) in SSD firmware.
3 THREAT MODEL
As this work focuses on defending against encryption ransomware,
we exclude the damage caused by non-encryption ransomware
because they typically lock a computer system in a way which
is not difficult for a knowledgeable person to reverse. For exam-
ple, the ransomware Trojan WinLock trivially restricts access to
the computer system and asks users to pay ransom to receive a
code for unlocking their machines. In addition, we assume that
encryption ransomware must be capable of restoring user data be-
cause inaccessibility and non-recoverability after paying ransom
can significantly influence the rewards of ransomware attacks.
In this work, we only consider the situation where data on persis-
tent storage are overwritten or deleted by ransomware. The targets
not only include the files created by user-level applications (e.g.,
.docx and .zip) but also the metadata files that are required for
file systems (e.g., Master File Table).
As discussed in § 2, some ransomware (e.g., cerber) will try to
elevate its privileges to run as administrator. Once the privilege is
given, the ransomware can disable or terminate any kernel-level
defense mechanisms. As such, we do not assume the OS is trustwor-
thy. Rather, we trust the SSD firmware. We believe this is a realistic
assumption because (1) firmware is located within a storage con-
troller, making it hardware-isolated to ransomware processes; (2)
in comparison with the OS kernel, firmware has a small Trusted
Computing Base (TCB) typically less vulnerable to malware attacks.
Overall, we believe this is a realistic threat model. First, it con-
siders all types of ransomware attacks that aim to encrypt user
data. Second, this threat model covers the cases in which the OS
kernel is compromised such as WannaCry [53]. With the advance
in ransomware defense, we believe ransomware authors will also
actively exploit the vulnerabilities in the OS kernel. To the best of
knowledge, this is the first work that explores malware defense
solutions at the firmware level.
4 APPROACH OVERVIEW
In this section, we briefly describe the technical background on
SSDs and then discuss how the intrinsic properties of SSDs can
be leveraged for building a lightweight data recovery system to
protect against encryption ransomware.
Figure 2: The fundamental difference between HDD and SSD
for an overwrite operation. When a logical block x is over-
written, HDD will update the mapped physical block y with
the new data B, while SSD will place the new data B on a free
block z and garbage collect the block y later.
4.1 Technical Background in SSDs
Same as conventional HDDs, a commodity SSD employs a block
interface to encapsulate the idiosyncrasies of flash devices (see
Figure 1). As such, it gives upper-level software systems (such as
file systems) an impression that both SSD and HDD perform storage
operations in the same manner. At the hardware level, however,
an SSD is fundamentally different from HDD which physically
overwrites data on disks when a logical overwrite occurs (as shown
in Figure 2-a).
Given an SSD, each physical page can be written only after it is
erased. Unfortunately, erase operation can be performed only at
block (which has multiple pages) granularity and such operations
are time-consuming. Therefore, SSDs issue the writes to free pages
which have been erased in advance (i.e., out-of-place write) rather
than waiting for the expensive erase operation for every write, and
GC will be executed later to clean the stale data on SSDs. Moreover,
each flash block has limited endurance: it is rated only for a few
thousands erase operations, therefore it is important for the blocks
to age uniformly. SSDs employ both out-of-place write and GC
to overcome the shortcomings of SSDs and maintain indirections
in the Flash Translation Layer (FTL) for indexing the virtual-to-
physical address mapping.
For a logical overwrite on SSD, the data is written to a free block
which has already been erased, the old copies become invalid and
are garbage collected later (see Figure 2-b). Details about the FTL
logic will be discussed in § 5.
4.2 Rationale
To demand ransom, ransomware typically overwrites user files
with encrypted contents. As described in § 4.1, SSDs naturally hold
the old copies of the data overwritten by upper-level programs. As
such, SSDs can be devised as a recovery system that holds data
potentially manipulated by ransomware. Moreover, SSDs have an
indirection layer at the firmware level to manage data. Building a
recovery system on top of it, we can naturally isolate our recovery
system from the OS, making it resistant to the attacks typically
launched by malware to evade anti-virus. Taking advantage of the
intrinsic characteristics of SSDs, we can also minimize the code
space of our recovery system. As a result, SSDs naturally reduce
the attack surface of our recovery system.
Block DriverHostApplicationkerneluserspaceread/writeBlock I/O InterfaceFlash Translation LayerNAND FlashHardwareDeviceABwrite B to logical block xABA(a) Overwrite on HDD(b) Overwrite on SSDlogical blockphysical blockxyxywrite B to logical block xxyxyzFigure 3: Overview of RFTL in FlashGuard. RFTL slightly modifies the existing FTLs by adding a read tracker table (RTT) to
track whether a page has been read. Cooperating with other tables, RTT helps RFTL track the pages that could be encrypted
by ransomware. LPA: logical page address, PPA: physical page address, VPA: virtual page address, PBA: physical block address.
5 DESIGN AND IMPLEMENTATION
FlashGuard consists of two major components: a Ransomware-
aware Flash Translation Layer (RFTL) and a tool for data recovery.
The RFTL is designed for holding data potentially overwritten
by encryption ransomware. The recovery tool is for victims to
offset the damage to their files when they are aware of ransomware
infection. In this section, we present the design and implementation
of FlashGuard in details.
5.1 Ransomware-Aware FTL
The FTL in modern SSDs maintains four data structures (see 1 2
3 4 in Figure 3) to support out-of-place write and GC functional-
ities in practice. For each I/O access, the address mapping table 1
is checked to translate the logical page address (LPA) to physical
page address (PPA)2. For performance reason, the recently accessed
mapping table entries 1 are stored in a cache (using LRU policy in
RFTL) located in a small and fast SRAM. If a mapping entry is not
cached, FTL will check the Global Mapping Directory (GMD) 2 to
locate the corresponding translation page, and place the mapping
entry in the address-mapping cache.
After certain storage operations, some pages in flash blocks may
become invalid. To assist the GC operation, FTL usually uses the
Block Validity Table (BVT) 3 to track the number of the valid
pages in each block and to determine whether the block should
be garbage collected or not. Since BVT is indexed in block-level
granularity, it is small and can be fully stored in SRAM. Once a
block is selected as the GC candidate, the Page Validity Table (PVT)
4 will be accessed to check which pages are valid and should
be moved to a new flash block. The PVT could be a conventional
page validity bitmap (PVB) or a recent optimized version which
uses a log-structured merge-tree to reduce the space requirement
2The mapping table can be managed in page-level, block-level or hybrid block/page
granularity. FlashGuard uses fine-granular and fully-associative page-level mapping.
We believe it also works for other two mapping schemes.
of indexing the bitmap for each physical block [8]. In this work, we
adopt the latter design for obtaining better performance. We will use
examples (see § 5.2 and § 5.3) to illustrate how these data structures
work collaboratively with other components in FlashGuard.
To augment an SSD with the capability of counteracting ran-
somware attacks, a straightforward solution is to keep all the invalid
pages in the physical device until ransomware is detected. This is
infeasible for two major reasons. First, an SSD would quickly fill up
with stale data, making the SSD unusable and causing unacceptable
resource inefficiency. Second, the GC operations will be executed
much more frequently to compact and collect free blocks, which
affects the storage performance significantly.
Therefore, it is desirable that SSDs only hold the invalid pages
having the old versions of the data manipulated by encrypted ran-
somware. According to our study (§ 2) and CryptoDrop [44], the
size of the data encrypted by ransomware is typically less than a
gigabyte. Holding such a small dataset will have negligible impact
on a commodity SSD which usually has TBs of storage capacity.
However, it is challenging to track the pages manipulated by
encryption ransomware since the underlying FTL does not have
any semantic information of the received storage commands. To
overcome this, we propose the Ransomware-aware FTL to track the
invalid pages that could result from ransomware. RFTL augments
the conventional FTLs with only one additional data structure: the
Read Tracker Table (RTT) 5 , which requires minimal modifi-
cation to the existing firmware implementation.
We propose RTT based on the insights that ransomware typically
read user data from disk, encrypt it and then overwrite or delete
the original copy [19, 44]. Therefore, if a page has been read and
then become invalid later, it could be a victim page encrypted by
ransomware. We use the RTT 5 to track the page that has been
read and leverage the PVT 4 to check whether it is valid or not.
RTT and PVT provide us the hints to decide whether the page
should be reained or not.
RAM in FirmwareAddress Mapping (LRU Cache) Y … … … … … … X Y FlashLPA PPA Data Blocks … … PBA Counter Blocks Validity Table (BVT) W … … … … … … Z W VPA PPA Translation Blocks Global Mapping Directory (GMD) Cached Page Validity Table (PVT) V … … … … … … V PBA Validity Bitmap  Validity Blocks B Cached Read Tracker Table (RTT) R … … … … … … R PBA Read Bitmap  Read Tracker Blocks B 12345Tables for existing FTLsTable for RFTLidentify all the old pages mapped to the same LPA), (3) the times-
tamp when the page is written, and (4) a Retained Invalid Page
(RIP) bit to indicate whether this page is invalid and also poten-
tially manipulated by encryption ransomware. The OOB metadata
is hardware-isolated and its content is filled within flash controller,
therefore, it is naturally protected against the adversary that has
the administrator privilege. We will discuss how these metadata
can be leveraged for data recovery in § 5.4.
5.3 Garbage Collection in RFTL
Garbage collection is an essential component in SSDs to provide
free blocks for future use by compacting the used flash blocks and
also guarantee all the flash blocks age uniformly to extend SSD
lifetime. It also plays a critical role in preserving the old copies
(invalid pages) of the data manipulated by ransomware. When GC
executes, it first selects the candidate blocks, move the valid pages
in those blocks to new free blocks, and then erases these candidate
blocks for future use.
Key idea: To make an SSD capable of holding data for recovery, we
propose a new GC scheme in RFTL. In particular, RFTL examines
whether an invalid page in a GC candidate block has been read.
The GC will retain those pages. The invalid pages that have never
been read will be discarded/erased. The intuition behind this is that
ransomware needs to read data from an SSD before performing
encryption, therefore the pages that have never been read could
not be a piece of damaged data caused by ransomware.
We describe the new GC scheme in Algorithm 1 and discuss its
procedure as follows.
GC procedure: When the number of free blocks in an SSD is
below a threshold (10% - 40% of all the flash blocks in commodity
SSDs), GC will be triggered to free space. The existing GC typically
employs a greedy algorithm for selecting the GC candidate blocks.
More specifically, it chooses the block with the least number of
valid pages. This selection procedure can be quickly completed by
looking up the BVT 3 that tracks the number of valid pages for
each block.
Different from the current block selection scheme for GC can-
didate, RFTL takes those retained invalid pages (RIP has set to be
Reserved in Algorithm 1) as valid pages. Therefore, the GC in RFTL
selects the block with the least number of both valid pages and
retained invalid pages. Such a GC scheme implies that a block with
multiple invalid pages retained for recovery may delay its collec-
tion (see Figure 5), which could reduce the additional GC overhead
caused by copying retained invalid pages to new free blocks.
Once a candidate flash block is selected, RFTL checks the PVT
4 and searches the valid pages in that block. Since lazy policies are
usually adopted to update the PVT, the information in PVT might
be outdated. To address this issue, RFTL double checks each valid
page indicated by PVT by looking at its OOB metadata. It retrieves
the LPA from the OOB metadata and looks up the corresponding
PPA through the address mapping table 1 . If the PPA retrieved is
the same as the PPA of the page, RFTL deems it valid.
Given a candidate flash block, RFTL migrates its valid pages and