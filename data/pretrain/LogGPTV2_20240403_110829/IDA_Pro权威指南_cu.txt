 ）和写入（stosb
 ）数据，让较高的 24位保持不变。在IDC 中，我们没有办法将一个变量划分成很小的部分，除非使用各种按位运算屏蔽并重新组合这个变量的各个部分。具体来说，就 odsb
 指令而言，有一个更加可信的模拟，如下所示：
1. EAX 寄存器的低8 位也叫做AL寄存器。
eax = (eax & 0xFFFFFF00) | (Byte(esi++) & 0xFF);
这个例子先清除 EAX变量的低8 位，然后使用一个OR
 运算合并低8 位中的新值。在Burneye解码示例中，我们注意到一个事实：在每个外层循环开始时，整个 EAX寄存器被设置为 8，这样做会将 EAX的高24位清零。因此，我们选择忽略它对EAX高24位的赋值效果，以简化lodsb
 的实现（➌）。同时，我们不需要考虑 stosb
 的实现（➍），因为 PatchByte
 函数仅读取它的输入值（这里为 EAX）的低 8 位。
执行Burneye解码IDC 脚本后，我们的数据库将反映出所有变化。正常情况下，除非模糊程序在Linux系统上运行，否则这些变化将不可见。如果去模糊过程得以正确执行，我们很可能会在IDA 的“字符串”窗口中看到许多更具可读性的字符串。为了观察这一事实，需要关闭并重新打开“字符串”窗口，或者在窗口中右击光标，选择 Setup，然后单击OK，刷新这个窗口的内容。这两个操作都会使 IDA 重新扫描数据库，从中搜索字符串内容。
剩下的任务包括：如果返回函数在它的第一条指令中就弹出返回地址，确定它将在什么地方返回；使 IDA 根据情况将解码后的字节值正确显示为指令或数据。Burneye解码函数的最后 3 条指令如下所示：
LOAD:0537107F                 popa  
LOAD:05371080                 popf  
LOAD:05371081                 retn  
如前所述，这个函数首先弹出它的返回地址，这意味着剩余的栈值由调用方设置。这里使用的popa
 和popf
 指令与Burneye的启动例程开始部分使用的 pusha
 和pushf
 指令对应，如下所示：
  LOAD:05371035 start           proc near  
  LOAD:05371035  
➊  LOAD:05371035                 push    off_5371008  
  LOAD:0537103B                 pushf  
  LOAD:0537103C                 pusha
结果栈上剩下的唯一一个值是在 start
 的第一行代码（➊）中压入的地址。Burneye解码例程会返回到这个地址，深入分析 Burneye保护的二进制文件也需要从这个地址继续。
从前面的例子来看，编写一段脚本解码或解压模糊二进制文件，似乎是一个相对容易的事情。就Burneye而言，情况确实如此，因为Burneye并没有使用特别复杂的模糊算法。但是，使用IDC执行更加复杂的实用工具（如 ASPack和tElock ）的去模糊存根，你可能需要付出更大的努力。
基于脚本的去模糊的优点包括：你根本不需要执行你所分析的二进制文件；不需要完全了解用于去模糊二进制文件的具体算法，你就可以创建一个有效的脚本。后一个说法似乎有些矛盾，因为你只有完全理解去模糊算法，才能使用一个脚本模拟这个算法。但是，利用这里和第 15 章描述的脚本开发流程，你只需要完全理解去模糊过程使用的每一条 CPU 指令。通过使用 IDC 忠实地执行每一项 CPU 操作，并且根据反汇编代码清单排定每项操作的正确顺序，你将有一段能够模拟程序操作的脚本，即使你并不完全理解这些操作作为整体执行的高级算法。
使用基于脚本的方法的缺点在于，你编写的脚本往往相当死板。如果由于去模糊工具升级，或者由于去模糊工具使用了其他的命令行设置，那么，之前对这个工具有效的脚本可能需要进行相应的修改。例如，你可以开发出一个通用解压脚本，供使用UPX 打包的二进制文件使用2
 ，但是，随着 UPX 不断升级，你需要对这段脚本持续调整。
2. 相关示例参见http://www.idabook.com/examples/chapter21
 。
最后，使用基于脚本的去模糊方法无法构建“万能药”式的去模糊解决方案。没有任何一个脚本能够对所有的二进制文件去模糊。从某个角度说，基于脚本的去模糊方法与基于签名的入侵检测和反病毒系统有许多相同的缺点。你必须为每一个新型包装器开发一个新的脚本，现有包装器的任何细微变化都可能会使现有的脚本失效。
21.3.2 面向模拟的去模糊
在创建脚本执行去模糊任务时，我们总是需要模拟一个 CPU 的指令集，以与被去模糊的程序在行为上保持完全一致。如果我们有一个指令模拟器，那么我们可以将这些脚本执行的一些或全部工作转交给模拟器完成，从而大大缩短对一个 IDA 数据库去模糊所需的时间。模拟器能够填补脚本与调试器之间的空白，它不但比脚本更加高效，而且比调试器更加灵活。例如，使用模拟器，我们可以模拟一个在 x86 平台上运行的 MIPS二进制文件，或者模拟一个在 Windows 平台上运行的 Linux ELF二进制文件的指令。
模拟器的复杂程度各不相同。不过，模拟器至少需要一些指令字节和足够的内存，专门供栈操作和CPU 寄存器使用。更加复杂的模拟器则可以利用模拟化的硬件设备和操作系统服务。
IDA 并不提供本地模拟工具3
 ，但是，它的插件体系结构功能相当强大，能够创建模拟器类型的插件。实现这类模拟器的一种方法是将 IDA 数据库作为碰巧包含我们希望模拟的二进制文件（通过加载器模块的帮助）的虚拟内存处理。模拟器插件所需要做的是提供少量内存，跟踪所有CPU 寄存器的状态，同时提供较大数量的内存，同时提供某种用于实施栈的方法。实施栈的一种方法是在映射到适合栈的位置的数据库中创建一个新段。模拟器通过从模拟器指令指针的当前值指定的数据库位置读取字节，并根据被模拟 CPU 的指令集规范解码读取到的值，同时更新任何受已解码的指令影响的内存值，从而执行它的操作。可能的更新包括修改模拟的注册表值，将这些值存储到模拟的栈内存空间中，或者根据已解码的指令生成的内存地址，将经过修改的值补缀到IDA 数据库的数据或代码段。控制模拟器的方式与控制调试器类似，因为你同样可以逐步执行每条指令，检查内存，修改寄存器以及设置断点。程序内存空间中的内容将在 IDA 的反汇编代码清单和十六进制窗口中显示，而模拟器需要为 CPU 寄存器生成自己的显示。
3. IDA自带有能够通过 IDA 的调试界面与开源 Bochs模拟器交互的插件。有关详细信息，参见第 24 章至第 26 章。
使用这样的模拟器，我们可以在程序的入口点开始模拟，并逐步模拟去模糊阶段的所有指令，从而对一个模糊程序进行去模糊处理。因为这种模拟器将数据库作为它的备用存储器，因此，所有自修改将立即在数据库中反映出来。到去模糊过程完成时，数据库将被正确转换成程序的去模糊版本，就好像程序一直在调试器的控制下运行一样。与调试相比，模拟的一个明显优点在于模拟器绝不会执行潜在恶意的代码，而调试器辅助的去模糊必须至少执行恶意程序的某个部分，才能获得该程序的去模糊版本。
ida-x86emu （x86emu）插件（见表 21-1 ）就是一个这样的模拟器插件，可用于模拟大部分的x86 指令集。这个插件为开源插件，并使用自 4.9版以来的所有 IDA SDK 版本构建。这个插件适用于IDA 所有版本的二进制版本包含在 x86emu发行版中。这个插件供Windows GUI 版本的 IDA或Qt版本的IDA 使用，同时提供构建脚本，允许用户使用 MinGw（g++/make）或微软（Visual Studio 2008 ）工具构建相应的插件。该插件的 Qt 版本与Linux版本的IDA 和OS X版本的 IDA 兼容。除了与你的 IDA 版本对应的 SDK 外，使用这个插件没有其他别的要求。要安装这个插件，可以将已编译的插件二进制文件（x86emu.plw/x86emu-qt.plw）复制到/plugins 目录中。
表21-1 ida-x86emu 插件
名称
ida-x86emu
作者
Chirs Eagle
发布
用于SDK v6.1的源代码及用于自5.0以来的所有IDA 版本（包括IDA 免费版本）的二进制文件。源代码向后兼容到SDK 4.9 版
价格
免费
说明
IDA嵌入式x86 指令模拟器
信息
http://www.idabook.com/ida-x86emu
你不需要进行插件配置，x86emu插件默认使用ALT+F8热键组合激活。你只能对使用x86处理器的二进制文件激活这个插件。这个插件可用于任何类型的二进制文件，如 PE、ELF 和Mach-O。使用第17章讨论的工具（Visual Studio 或MinGW的gcc 和make），我们可以由源代码构建这个插件。
1. x86emu 初始化
激活x86emu插件后，该插件的控制对话框将显示出来，如图 21-4 所示。对话框的基本显示包括寄存器内容，还有控制按钮，用于执行简单的模拟任务，如控制模拟器或修改数据值。
图21-4 x86emu模拟器控制对话框
一旦激活后，插件将执行许多其他操作。模拟器将为所有文件类型创建名为.stack
 和.heap
 的新数据库段，为模拟程序的操作提供运行时内存支持。在某个二进制文件中第一次激活插件时，当前的光标位置用于初始化指令指针（EIP
 ）。对于 Windows PE二进制文件，该插件执行以下任务。
创建另外一个名为.headers
 的程序段，重新读取输入的二进制文件，然后将 MS-DOS 和PE头部字节加载到数据库中。
分配内存，模拟一个线程环境块（TEB ）和一个进程环境块（PEB ）。用合理的值填充这些结构，让被模拟的程序确信，它在真正的 Windows 环境中运行。
为x86 段寄存器分配合理的值，配置一个虚假的中断描述符表，提供最小的异常处理功能。
尝试在PE文件的导入目录中定位所有被引用的 DLL 。对于每一个被发现的 DLL ，模拟器将在数据库中为它们创建额外的段，并加载该DLL 的头部和导出目录。然后，用从已加载 DLL的信息中获得的函数地址填充二进制文件的导入表。注意，已导入的 DLL 中没有任何代码被加载到数据库中。
每次保存或关闭数据库时，插件的当前状态（寄存器值）被保存在一个网络节点中。其他内存状态（如栈值和堆值）也被保存下来，因为这些值存储在数据库的专用段内。随后激活插件时，将从现有的网络节点数据恢复模拟器状态。
2. 基本的x86emu 操作
模拟器控制对话框专门提供与基本调试器非常类似的功能。在你想要修改的寄存器的编辑框中输入一个新值，即可修改 CPU 寄存器的内容。
Step 按钮用于模拟单独一条指令。从 EIP 寄存器指定的数据库位置读取一个或数个字节，并执行这些指令字节指定的操作，即可模拟一条指令。在必要时，寄存器显示的值会更新，以反映因为模拟当前指令而导致的变化。每次单击 Step 按钮，模拟器一定会以代码（而非数据）显示EIP 指定的地址处的字节。这一特性有助于阻止指令流中的任何去同步操作。此外，模拟器会使反汇编显示窗口跳转到 EIP 指定的位置，以跟踪每一条被模拟的指令。
Run to cursor按钮用于模拟连续的几条指令。模拟从当前EIP 位置开始，直到到达一个断点或EIP 等于当前光标位置时结束。模拟器用于识别通过IDA 的调试器界面（右击指定的地址并选择Add breakpoint）或模拟器自己的断点界面（Emulate ▶Set Breakpoint）设置的断点集。
x86emu 断点
模拟器并不使用 int 3
 指令之类的硬件调试寄存器或软件中断。模拟器维护一个内部断点列表，在模拟每一条指令之前，模拟器会将被模拟的指令的指针与列表中的断点比较。虽然这种方法似乎较为低效，但它比一般的模拟高效，而且它具有一个优点，即被模拟的程序无法检测到也无法修改模拟器断点。
选择Run to cursor按钮后，模拟器并不会暂停以为每一条获取的指令重新格式化反汇编代码清单。它只格式化第一条和最后一条被执行的指令。对于较长的指令序列，重新格式化每条指令的反汇编代码清单所导致的开销将使模拟器的性能低得令人难以忍受。因此，在使用 Run To Cursor 命令时，你应当十分小心，因为在 EIP 到达光标位置之前，你将无法重新控制模拟器（和IDA ）。如果由于某种原因，执行从未触发断点或到达光标位置，你可能需要强制终止 IDA ，这可能会导致你之前所做的重要工作被白白浪费。
Skip 按钮用于使模拟器略过一条指令，而不模拟这条指令。例如，你可以使用 Skip 命令忽略一个条件跳转而到达一个特定的代码块，不顾任何条件标志的状态。Skip 还可用于略过函数调用，如导入的库函数，因为你无法模拟它的代码。如果你选择略过某个函数调用，请确保对数据库进行更新，以反映该函数可能做出的任何更改。此类更改的示例包括：修改 EAX的值以反映所需的函数返回值，或者填充其地址已传递给函数的缓冲区。此外，如果被略过的函数使用stdcall
 调用约定，你还应当根据被略过的函数在返回时从栈中清除的字节数，小心对 ESP 进行手动调整。
Jump to cursor 按钮将使 EIP 更新为当前光标所在位置的地址。这个特性可用于忽略整个代码块。如果 CPU 标志的状态不会对跳转造成影响，该特性还可用于跟踪一个条件跳转。记住，在一个函数内跳转可能会影响栈布局（例如，如果你忽略压入操作或栈指针调整），导致无法预料的后果。注意，模拟器并没有必要从一个程序的入口点开始模拟。你完全可以使用模拟器模拟二进制文件中的一个函数，以研究该函数的行为。这也是我们提供Jump to cursor 按钮的目的之一。使用这个按钮，你可以轻松确定二进制文件中的模拟目标。
Run 按钮的功能与 Run to cursor按钮的功能类似。但是，它更加危险，因为在到达一个断点之前，执行不会停止。因此，如果你选择使用这个命令，你应当完全确定执行会到达某个断点。
Segments 按钮用于访问x86 段寄存器和段基址的配置。段配置对话框如图 21-5 所示，你可以通过它修改与段有关的值。
图21-5 x86emu段寄存器配置
虽然模拟器的地址计算取决于你提供的基址值，但是，模拟器当前并不能完全模拟x86 全局描述符表（GDT）。
单击Set Memory 按钮，将显示如图 21-6 所示的基本内存修改对话框。
图21-6 x86emu内存修改对话框
基本上，这个对话框是一些 SDK PatchXXX
 函数的包装器。插入到数据库中的数据的类型通过对话框提供的单选按钮进行选择，而具体的数据则输入到对话框提供的编辑框中。如果选择Load from file 按钮，用户将看到一个标准的打开文件对话框，选择一个文件后，这个文件将从指定地址开始把内容传送到数据库中。
Push data按钮用于将数据值放入被模拟的程序栈的顶部。生成的对话框如图 21-7 所示，你可以通过它指定将要压入栈的一个或几个数据项。
图21-7 x86emu栈数据对话框
模拟器当前仅接受数值数据。提供的值以一次 4 字节的方式，按从右至左的顺序压入栈中，就好像它们是一个函数调用的参数。栈指针的值将根据被压入栈中的值的数量进行调整。这个对话框的主要用途是在直接跳转到将要模拟的函数之前，对函数的参数进行配置。这样，用户不需要找到函数的具体执行路径，即可模拟这个函数。
3. 模拟器辅助的去模糊
接下来，我们将讨论将 x86emu插件作为一个去模糊工具。首先回到开发了一个完整的 IDC脚本的Burneye示例。假设我们之前并不知道 Burneye解码算法，去模糊过程如下所示。
打开Burneye保护的二进制文件。光标应自动位于start
 入口点处。激活模拟器（ALT+F8），图21-4 所示的对话框将显示模拟器的结果状态。
开始单步执行模拟器，请特别注意将要模拟的指令。6 步以后，模拟器将到达函数 sub_5371048
 处（参见代码清单 21-3 ）。
这个函数的结构似乎相当完整。我们可以选择继续单步执行模拟器，以便更完整地了解该函数的执行流。我们也可以选择对这个函数进行一段时间的研究，确定将光标放置在该函数的return
 语句上并单击Run to cursor按钮是否安全。我们选择后一种情况，将光标放在地址 0537108h
 处，并单击 Run to cursor按钮。
至此去模糊已经完成。单步执行模拟器，再执行 return
 语句两次，返回新的去模糊后的代码，使 IDA 将去模糊后的字节重新格式化为指令。
得到的去模糊代码如下所示：
    LOAD:05371082 loc_5371082:                        ; CODE XREF: start+E↑ j
    LOAD:05371082                 call    sub_5371048
    LOAD:05371082 ; --------------------------------------------------------------
    LOAD:05371087                 db    0
    LOAD:05371088                 db    0
    LOAD:05371089                 db    0
    LOAD:0537108A                 db    0
    LOAD:0537108B                 db    0
    LOAD:0537108C                 db    0
    LOAD:0537108D                 db    0
    LOAD:0537108E                 db    0
    LOAD:0537108F                 db    0
    LOAD:05371090 ; --------------------------------------------------------------
    LOAD:05371090
    LOAD:05371090 loc_5371090:                       ; DATA XREF: LOAD:off_5371008↑ o
➊  LOAD:05371090                 pushf
    LOAD:05371091                 pop     ebx
    LOAD:05371092                 mov     esi, esp
    LOAD:05371094                 call    sub_5371117
    LOAD:05371099                 mov     ebp, edx
    LOAD:0537109B                 cmp     ecx, 20h
    LOAD:0537109E                 jl      loc_53710AB
    LOAD:053710A4                 xor     eax, eax
    LOAD:053710A6                 jmp     loc_53710B5
将这个代码段与代码清单 21-2 比较，很明显可以看到，指令在去模糊过程中发生了变化。完成初步的去模糊后，程序从 loc_5371090
 地址处的pushf
 指令（➊）继续执行。
很明显，模拟器辅助的去模糊要比前面讨论的面向脚本的去模糊过程更加简单。花时间开发模拟器，你得到一个高度灵活的去模糊方法，而花时间编写一个特定于 Burneye的脚本，你得到一个非常专一化的脚本，在其他去模糊情形中，这个脚本没有多大用处。
注意，虽然在前一个例子中，Burneye保护的二进制文件是一个 Linux ELF 二进制文件，但是，x86emu仍然能够模拟这个文件中的指令，因为它们全都是 x86 指令，而不论它们来自什么操作系统，属于何种文件类型。x86emu可直接用于 Windows PE二进制文件，如本章前面讨论的UPX示例。目前绝大多数的模糊恶意软件都以 Windows 平台为攻击对象，因此，x86emu提供了许多特定于 Windows PE二进制文件的功能（如前所述）。
使用模拟器解压 UPX 二进制文件非常简单。首先，在启动模拟器时，光标应放置在程序的入口点（start
 ）。然后，再将光标移到UPX 导入表的第一条指令上，并重建循环（代码清单21-1的地址0040886Ch
 处），使模拟器能够运行Run to Cursor 命令。这时，二进制文件已经被解压，“字符串”窗口可用于查看所有解压后的库和函数的名称，UPX 将用它们构建程序的导入表。如果模拟器逐步模拟代码清单 21-1 中的代码，最终它将遇到下面的函数调用：
UPX1:00408882                 call    dword ptr [esi+808Ch]
模拟这类指令可能非常危险，因为一开始，你并不清楚这个指令指向什么地方（表示call
 指令的目标地址并不明显）。一般而言，函数调用可能指向两个地方：程序代码（.text
 ）段内的一个函数，或者程序所使用的共享库中的一个函数。任何时候遇到 call