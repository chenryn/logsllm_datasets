### Improved Text

**Specifically, as this system call will completely change the memory layout of the out-grafted process, our current prototype simply chooses to first restore the process back to the production VM and then re-out-graft it immediately after the system call is completed by the production VM. Though this approach leverages the functionalities we have already implemented for grafting and restoring processes, an integrated solution is still desired.**

**Moreover, our current prototype proactively maps all (user-mode) memory pages at the very beginning when a process is out-grafted. A more efficient solution would be to map only the currently executing code page to the security VM. The remaining pages could be lazily mapped when they are actually accessed. This would further enhance our system's performance.**

**One caveat we encountered in our prototype development is related to shared pages. Specifically, most commodity operating systems map the same physical pages for common shared library code across different processes. In our system, this means that a single host-physical page can contain code used by multiple processes in the production VM. Recall that our system directly maps this host-physical page to the out-grafted process in the security VM. If the monitoring tool modifies such a code page (e.g., to install certain code hooks), this could alter the behavior of other processes in the production VM. Fortunately, this issue can be resolved by cooperating with the helper module and KVM to mark all executable code pages for the out-grafted process as read-only in the Extended Page Tables (EPT). By applying the classic copy-on-write technique, if the monitor process (not the out-grafted process) attempts to write to this page, a separate copy of the page can be created.**

**Finally, with the widespread adoption of virtualization in data centers, we envision that different security VMs can be dispatched to each physical machine to inspect running guest VMs and their internal processes (for fine-grained execution monitoring). This is largely feasible as the semantic gap has been effectively bridged to support existing monitoring tools. On the other hand, with our current focus on examining individual suspect processes for malicious behavior, we believe there are other interesting applications and opportunities (e.g., performance monitoring and intelligent parallel job scheduling) that remain to be explored, which we plan to investigate in the future.**

### 6. RELATED WORK

**Virtualization has been widely proposed to address various computer system problems, including enhancing the effectiveness and robustness of host-based monitoring tools. Specifically, it has been applied in offline malware analysis [9, 11], honeypot-based malware capture [20], intrusion analysis [23, 24], and malware detection [15, 21]. Among the most notable, Livewire [15] pioneered the concept of placing a monitor "out-of-VM" and applying VM introspection techniques to understand in-VM activities. Several recent systems address the inherent semantic gap challenge to improve VM introspection for various purposes [8, 10, 21, 30, 31, 37]. For instance, Virtuoso [12] aims to effectively automate the process of building introspection-based security tools. Another system [10] proposes injecting stealthy agents into a monitored VM to solve the semantic gap problem and enhance out-of-VM tools. Similar to most of these efforts, our approach places security tools out-of-VM. However, our approach differs from them in the way it addresses the semantic gap challenge. Specifically, while prior approaches are sensitive to particular guest kernel versions or patches, our approach brings the suspect process to the security tool and allows for native support of existing tools.**

**In other words, by effectively removing the semantic gap, our approach enables the reuse of existing user-mode process monitoring tools. Furthermore, our approach localizes the impact on the out-grafted process and avoids perturbing the monitored VM as a whole.**

**From another perspective, one recent system, SIM [34], utilizes hardware features to place an "in-VM" monitor in a hypervisor-protected address space. While it is not physically running out-of-VM, SIM still suffers from the semantic gap and cannot natively support existing monitoring tools. In other words, though the in-VM presence leads to unique performance benefits, there is a need to adapt existing tools to take advantage of SIM support. Additionally, the main goal of SIM is to protect "kernel hook"-based monitors. Another recent system, Gateway [38], leverages virtualization to detect kernel malware by monitoring kernel APIs invoked by device drivers. In contrast, our focus is on fine-grained process-level execution monitoring (e.g., ltrace) that typically requires user-mode interception. Process implanting [22] is another "in-VM" approach, where an "undercover agent" process is dynamically implanted in a target VM for surveillance and repair operations. Contrary to process out-grafting, process implanting relies on the integrity of the target VM’s kernel and requires special modifications to the program executed by the implanted process.**

**Process out-grafting requires redirecting the process execution across two different VMs, which bears certain similarities to well-known process migration mechanisms [28, 29, 35, 36]. However, a key difference is that process migration techniques typically move the entire execution state, including kernel-maintained resources, while our approach only temporarily redirects the user-level execution of a process for secure monitoring. Moreover, most process migration techniques are typically applied for generic purposes such as fault-tolerance and load-balancing [28, 35] and do not consider the isolation challenge for secure monitoring. We also note that the idea of system call forwarding has been previously applied in systems to protect a critical application from an untrusted kernel [39]. In this case, a programmer can divide system calls into two sets so that each set will be serviced by either a trusted or untrusted kernel, respectively.**

**In contrast, throughout the out-grafting duration, our system uses a single kernel to serve all system calls for the out-grafted process. Moreover, due to the relocated user-level execution, we need to perform mode-sensitive split execution, which leads to an extra but unique need for forwarding page faults. System call forwarding between VMs has also been used [27] to improve the fidelity of the runtime environment for better malware behavior monitoring, albeit without isolation guarantees. In contrast, we aim to address the compatibility of existing process monitoring tools while ensuring their strong isolation in the context of VM introspection. Further, we dynamically create the memory mapping for the out-grafted process between the production VM and security VM. Also, our on-demand grafting allows for dynamically grafting the execution first and then restoring the execution back.**

**More generally, sandboxing and isolation techniques [14, 16, 32] have been widely researched and applied as effective mechanisms to confine an untrusted process’ access to sensitive resources in the host system. Our work is related to them by essentially leveraging the VM isolation provided by the underlying virtualization layer. However, with an out-of-VM approach, process out-grafting can be applied on-demand, providing flexibility in monitoring the runtime behavior of suspect processes. Additionally, our approach is unorthodox compared to traditional sandboxing and isolation techniques due to its split execution, i.e., the user-mode and kernel-mode execution of an out-grafted process run in two different VMs.**

### 7. CONCLUSION

**We have presented the design, implementation, and evaluation of process out-grafting, an architectural approach to address isolation and compatibility challenges in out-of-VM approaches for fine-grained process-level execution monitoring. By effectively relocating a suspect process from a production VM to the security VM for close inspection, process out-grafting removes the semantic gap for native support of existing process monitoring tools. Moreover, by forwarding the system calls from the out-grafted process back to the production VM, it can smoothly continue its execution while being strictly isolated from the monitoring tool. Evaluation results with several performance benchmarks demonstrate its effectiveness and practicality.**

### Acknowledgements

**The authors would like to thank the anonymous reviewers for their insightful comments that helped improve the presentation of this paper. This work was supported in part by the US Air Force Office of Scientific Research (AFOSR) under Contract FA9550-10-1-0099 and the US National Science Foundation (NSF) under Grants 0852131, 0855297, 0855036, 0910767, and 0952640. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the AFOSR and the NSF.**

### 8. REFERENCES

[References remain unchanged]

---

This version of the text is more structured, clear, and professional, with improved flow and coherence.