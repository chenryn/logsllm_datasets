理程序的复杂性，所以在处理Unicode时不应忘记这些问题。用户可能会期望，处理这样的
数据时，必须能够处理正常空格（U+002o）和非换行空格（no-breakspaces）（U+00A0），或
许还需要包括Unicode中其他的成打的空白字符之中的任意一个。
Unicode3.1+和U+FFFF之后的代码点
UnicodeVersion3.1诞生于2001年中期，增加了U+FFFF之后的代码点（之前版本的Unicode
也支持这些代码点，但是在Version3.1以前，它们都是没有定义的）。例如，代表音乐谱号
C（Clef）的字符对应代码点U+1D121。之前那些仅支持低于U+FFFF字符的程序无法处理
这种情况。大多数程序的\unum只能支持最多4位十六进制数值。
能够处理这类新字符的程序通常提供了\x（num）序列，num可以为任意多位数字（这是为了
增强只支持4位数字的\unum表示法）。你可以使用\x（1D121）来匹配这类“谱号C”之类
的字符。
Unicode中的行终止符
Unicode定义了多个用于表示行终止符的字符（以及一个双字符序列），详见表3-5。
表3-5：Unicode行终止符
字符
描述
LF
U+000A
ASCII换行符
VT
U+00OB
ASCII垂直制表符
FF
U+O0OC
ASCII进纸符
CR
U+00OD
ASCII回车
CR/LF
U+000DU+000A
ASCII回车/换行
NEL
U+0085
Unicode换行
LS
U+2028
Unicode行分隔符
PS
U+2029
Unicode段分隔符
---
## Page 136
110
第3章：正则表达式的特性和流派概览
如果行终止符获得了完全的支持，它会影响文本行从文件（在脚本语言中，还包括程序读
取的文件）读入的方式。在使用正则表达式时，它们影响点号（111)，以及、'$和Z
的匹配（112）。
正则模式和匹配模式
Regex Modes and Matcl Modes
许多正则引擎都支持多种不同的模式，它们规定了正则表达式应该如何解释和应用。我们
已经看过Perl的/x修饰符（容许自由空格和注释的正则模式72）和/i修饰符（进行不区
分大小写匹配的模式?47）。
在许多流派中，模式可以完全作用于整个表达式，也可以单独应用于某个子表达式。整体
应用是通过修饰符或者选项（options）来决定的，例如Perl的/i，PHP的模式修饰符
(446)，和java.uti1.regex的Pattern.CASE_INSENSITIVE标志（99)。如果支持，
应用到目标字符事中部分文本的模式是通过一个正则结构来实现的，例如用（？i）来开启
不区分大小写的匹配，（？-i）来停用该匹配。有的流派也支持（？i：）和（？-i：）来启
用或者停用对括号内的子表达式进行不区分大小写匹配的功能。
本章后面部分会介绍（135）如何在正则表达式中设置这些模式。在本节，我们只看看大
多数系统提供的常见模式。
不区分大小写的匹配模式
此模式很常见，它在匹配过程中会忽略字母的大小写，所以'b可以匹配“b’和“B。此
功能也必须依赖于正确的字符编码支持，所以之前我们提到的注意事项对它都适用。
在历史上，不区分大小写的匹配支持一直不太令人满意，被bug困扰，好在如今大部分已
经修正了。不过，Ruby不区分大小写的匹配仍然不能处理八进制和十六进制的转义字符。
matching)”）。简单地说，就是并非所有的ASCII字母和数字字符都存在大小写形式，而某
些字符在作为单词首字母时会有单独的标题格式（titlecase）。有时候在大写和小写之间并
没有明显的一对一映射。常见的例子是希腊字母西格马，它有两个小写形式和o，在
不区分大小写的模式中，这三者应该是等价的。根据我的测试，只有Perl和Java的java。
util.regex能够正确处理它们。
---
## Page 137
宇符串，字符编码和匹配模式
111
另一个问题是，有时候单个字符会对应到一组字符。常见的例子是大写的8是两个字符的
组合“ss”。这种情况只有Perl能够正确处理。
Unicode还带来了一些问题。例如单字符J（U+01Fo）没有对应的大写形式的单字符。相反，
J需要使用组合字符（107），U+004A和U+030C。而J和J应该在不区分大小写的模式中
是等价的。类似的还有一对三的例子。幸好，这些都不是常用字符。
宽松排列和注释模式
此模式会忽略字符组外部的所有空白字符。字符组内部的空白字符仍然有效（java.util，
regex是例外），#符号和换行符之间的内容视为注释。我们已经见过Perl（72）、Java（98）
和VB.NET（99）中相应的例子。
不过，在java.util.regex中，字符组之外的所有空白字符并非都会被忽略，而是作为一
个“无意义元字符（do-notingmetacharacter)”。在理解12·3时，这种区分很重要，因为
它表示3接在12之后，而不是有些人以为的123。
当然，“空白字符”的定义取决于所采用的字符编码的定义，以及此编码对空白字符的支持
程度。大多数程序只能识别ASCII的空白字符。
点号通配模式（dot-match-allmatchmode，也叫“单行模式"）
通常，点号是不能匹配换行符的。最初的Unix正则表达式工具是逐行处理的，直到sed和
lex出现之后，才提出匹配换行符的要求。那时候，人们常用".*来匹配“本行中的其他内
容（therestoftheline)”，为了保证一致，新的语法不能修改".*的定义（注9)。所以，能
够处理多行文本的工具（例如文本编辑器）通常不容许点号匹配换行符。
对现代编程语言来说，点号能够匹配换行符的模式和不能匹配的模式同样有用。这两种模
式哪个更方便，取决于具体的情况。许多程序提供了两种方法供正则表达式选择。
这种常规标准也有少数例外的情况。支持Unicode的系统，例如在Sun的正则表达式包，
点号能够匹配未使用此模式时点号不能匹配的所有单字符Unicode行终止符（109）。在
注9：KenThompson（ed的作者）向我解释说，这样.*1变得“非常古怪”。
---
## Page 138
112
第3章：正则表达式的特性和流派概览
Tcl的普通模式中，点号能够匹配任何字符，但是在其特殊的“区分换行（newline-sensitive）”
和“部分区分换行（partialnewline-sensitive）”的匹配模式下，点号和排除型字符组都不能
匹配换行符。
不幸的命名
/s修饰符对应的匹配模式第一次出现在Perl时，被称为“单行文本模式（single-linemode）”。
这个不幸的命名一直是混乱的起源，因为与下一节讨论的“多行文本模式（multilinemode）”
比较起来，它似乎与和'$i没有关系。其实“单行文本模式”指的是，点号不受限制，可
以匹配任荷字符。
增强的行锚点模式（Enhancedline-anchormatchmode，也叫“多行文本模式"）
增强的行锚点模式会影响到行锚点和'$的匹配。通常情况下，锚点不能匹配字符申
内部的换行符，而只能匹配目标字符串的起始位置。但是在此增强模式下，它能够匹配字
符串中内嵌的文本行的开头位置。前一章出现了这样的例子（69），当时我们用Perl开发
把文本内容转换为超文本内容程序。其中，所有的文本保存在一个字符串中，所以我们可
‘s..，转s.‘s…，*bm///-基
it's”。该替换把空“行”替换为段落tag。
$i也是这样，尽管$在正常情况下的匹配的基本规则比较难理解（129）。不过，就本节
来说，我们只需要记住，$：可以匹配字符串内部的换行符，就足够了。
支持此模式的程序通常还提供了A和Z，它们的作用与普通的和S)一样，只是在此
模式下它们的意义不会发生变化。也就是说A和Z永远不会匹配字符串内部的换行符。
有些实现方式中，$i和z能够匹配字符串内部的换行符，不过它们通常会提供z，唯一
匹配整个字符串的结尾位置。详见129页。
对点号来说，常用标准有一些例外。在GNUEmacs之类的文本编辑器中，行锚点通常能够
匹配字符串中的换行符，因为在编辑器中这样非常有意义。另一方面，lex的'$：只能匹配换
行符之前的位置（其中的意义与常见的一样）。
此模式下，在Sun的java.util.regex之类支持Unicode的系统中，行锚点能够匹配任何
一种行终止符（109）。Ruby的行锚点在正常情况下能够匹配字符串中的换行符，Python
的Z类似z)，而不是普通的$l。
---
## Page 139
常用的元字符和特性
113
长期以来，这种模式被称为“多行模式（multilinemode）”。尽管它与“单行模式”没有什
么关系，但看名字总容易觉得二者有关联。后者修改的是点号的匹配规则，前者修改的是
和'S的匹配规则。另一方面，它们从不同的思路处理换行符。第一个修改了点号处理换行
）
文字文本模式
“文字文本（literaltext)”模式几乎不能识别任何正则表达式元字符。例如，文字文本模式
索（“搜索这个字符事”，而不是“搜索这个正则表达式”），支持正则表达式的程序通常也
提供了普通的字符事搜索功能。正则表达式的文字文本模式之所以更有趣，是因为它可以
只作用于正则表达式的一部分，举例来说，PCRE（因此也包括PHP）的正则表达式和Perl
的正则表达式文本提供了特殊的序列\Q\E，其中内容的元字符全部被忽略（当然，不包
括\E)。
常用的元字符和特性
Conmon Metacharacters andFeatures
本章的其他部分-一剩下大约30页的内容简要介绍下一页列出的常见正则表达式元字符和
概念。这里的介绍并不是全面彻底的，不过也没有任何一种正则工具涉及其中的所有内容。
从某种意义上说，这一节只是前两章内容的总结，但同时也是为本章介绍更全面更深刻的
知识做准备。读者第一次接触时，只需略读本章就可以继续阅读下面各章，以后在需要的
时候可以随时回过头来查阅细节。
有的工具添加了大量的新功能，也可能毫无根据地改变某些通用表示法，以满足它们的特
殊要求。尽管我有时会提到这些特殊的工具，但不会花太多的笔墨在工具的细节问题上。
相反，在这一节我只希望介绍常见的元字符及其作用，以及与此相关的一些问题。我希望
读者能够参考自己擅长的工具提供的使用手册。
注10：正常情况下，Tcl的点号能够匹配所有字符，所以从这个意义上说它比其他任何语言都要
直接易懂。在Tcl的正则表达式中，换行持并不需要特殊处理（对点号和行锚点来说都是
如此）、但是如果明确指定了匹配模式，情况就不一样了。不过，因为其他系统通常以其
他方式来做到这一点，那些习情其他方式的用户可能会感到递惑。
---
## Page 140
114
第3章：正则表达式的特性和流派概览
本节介绍的结构
字符表示法
115字符缩略表示法：\n、\t、\a、\b、\e、\f、\r、\v、
116八进制转义：\num
117十六进制/Unicode转义：\xnum、\x（num）、\unum、\unum，
117控制字符：\cchar
字符组及相关结构
118
普通字符组：[a-z]和[^a-z]
119
几乎能匹配任何字符的元字符：点号
120
单个字节：\C
120
Unicode组合字符序列：\x
120
字符组缩略表示法：\w、\d、\B、\W、\D、\S
121
Unicode属性、区块和分类：\p（Prop)、\P(Prop)
125
字符组运算符：【[a-z]&&[^aeiou]]
127
POSIX“字符组”方括号表示法：[[：alpha：]]
128
POSIX“collating序列”方括号表示法：[[.epan-11.1]
128
POSIX“字符等价类”方括号表示法：（[=n=]]
128
Emacs语法类
锚点及其他“零长度断言”
129
行/字符串起点：^、\A
129
行/字符串终点：$、\z、\z
130
本次匹配的开始位置（或者上次匹配的结束位置）：\G
133
单词分界符：\b、\B、\，"
133
顺序环视（?=.）、（?1.）；逆序环视（7…)
139
固化分组：（?>)
139
多选结构：·….·….
140
条件判断：（?ifthenlelse）
141
匹配优先量词：*、+、？、（num，num）
141
忽略优先量词：*？、+?、??、（num，num}？
142
占有优先量词：*+、++、?+、（num，num}+
11
---
## Page 141
常用的元字符和特性