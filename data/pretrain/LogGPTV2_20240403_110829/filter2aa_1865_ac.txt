2708
// ”1−”
2709
s i d
s t r
l e n += 2 ;
2710
// t s k
f p r i n t f ( stderr ,
” Revision : %i \n” ,
sid −>r e v i s i o n ) ;
2711
2712
//
This
check
helps
not
p r o c e s s
i n v a l i d
data ,
which
was
noticed
while
t e s t i n g
2713
//
a
f a i l i n g
harddrive
2714
i f
( sid −>r e v i s i o n == 1)
{
This variable is computed with an arbitrary 32-bit oﬀset (line 2704) from an existing buﬀer (line 2706)
without any bounds checking.
5.6.1
Reproduction
$
patch . py
NtfsPart . dsk Bad . dsk
10667177
\x9b
$
f s t a t
Bad . dsk
5.7
NTFS Image Causes fsstat to Crash
fstat crashes while processing a corrupted ﬁlesystem image. The crash happens while copying data from
the sds variable (line 2831) in ntfs.c. Care is taken to ensure that no out of bounds reads occur with checks
at line 2817. However, these checks are based on the oﬀset computed in terms of 32-bit values (line 2809)
not in terms of bytes. The check assumes that the current offset is actually a byte count, which would be
four times larger.
2808
while
( t o t a l b y t e s p r o c e s s e d s i z e )
{
2809
c u r r e n t o f f s e t =
2810
( u i n t p t r t
∗)
sds − ( u i n t p t r t
∗)
s d s b u f f e r −>b u f f e r ;
2811
2812
o f f s e t = getu32 ( fs −>endian ,
sds−>e n t s i z e ) ;
2813
i f
( o f f s e t % 16)
{
2814
o f f s e t = ( ( o f f s e t
/
16) + 1)
∗
16;
2815
}
2816
2817
i f
( ( o f f s e t
!=
0) && ( o f f s e t s i z e
c u r r e n t o f f s e t ) )
2818
&& ( getu64 ( fs −>endian ,
sds−>f i l e
o f f ) s i z e ) )
{
2819
2820
NTFS SDS ENTRY ∗ s d s e n t r y ;
2821
2822
i f
( ( s d s e n t r y =
2823
(NTFS SDS ENTRY ∗)
mymalloc ( s i z e o f (NTFS SDS ENTRY) ) ) ==
2824
NULL)
{
2825
return
1 ;
http://www.isecpartners.com
8/12
2826
}
2827
i f
( ( sds entry −>data = ( u i n t 8 t
∗)
mymalloc ( o f f s e t ) ) == NULL)
{
2828
f r e e ( s d s e n t r y ) ;
2829
return
1 ;
2830
}
2831
memcpy( sds entry −>data ,
sds ,
o f f s e t ) ;
5.7.1
Reproduction
$
patch . py
NtfsPart . dsk Bad . dsk
10666450
\x01
$
f s s t a t
Bad . dsk
6
Defects Found in Guidance EnCase
EnCase from Guidance Software is a very diﬀerent beast from TSK. It is Windows-only (with a Linux
remote device acquisition component), features a complex GUI, and incorporates features for browsing,
searching and displaying devices, ﬁlesystems, and data ﬁles. For programmability, it incorporates its own
programming language, Enscript, that resembles C++ and Java.
As with TSK, EnCase showed numerous defects with relatively simple fuzzing techniques, although we
also created targeted, domain-speciﬁc faults in test data, such as carefully crafted partition tables and NTFS
directory structures.4
We tested EnCase versions 6.2 and 6.5.
6.1
Note
Due to the deadline for submitting presentation materials to Black Hat and the ongoing nature of our
conversation with Guidance Software, we are unable to present in this revision of the paper all the details
of the defects in EnCase that we found. By the time you read this, this version of the paper may be out of
date and the canonical version may have the defect details. Please see https://www.isecpartners.com/
blackhat/ to ﬁnd the most recent version of this paper. We apologize for the inconvenience.
6.2
Disk Image With Corrupted MBR Partition Table Cannot Be Acquired
EnCase cannot properly acquire disks with certain corrupted MBR partition tables. When running linen
on a system with a disk with a carefully crafted partition table (including many partition table entries), linen
won’t start up properly. If linen is started prior to corrupting the image, it will start up, but EnCase will
hang indeﬁnitely while acquiring the image. (It is possible to cancel out of the linen import.)
If a disk image is made and transferred to the EnCase workstation and acquired as a raw disk image,
EnCase will hang indeﬁnitely while attempting to acquire the image. There is no way to cancel out of this
process — the GUI becomes unresponsive. We have not identiﬁed the root cause of this issue, but it appears
4We noticed instances where EnCase’s remote acquisition tool for Linux, linen, could not process a corrupted disk image
if linen was started up after the ﬁlesystem was corrupted. Since our primary goal was to test EnCase, not linen, we worked
around these issues by running linen prior to corrupting a disk image without further analyzing the issues in linen.
http://www.isecpartners.com
9/12
to be due to the overly large values in the 29th partition table entry. We were unable to reproduce this issue
in similar situations with a small number of partitions.
6.3
Corrupted NTFS Filesystem Crashes EnCase During Acquisition
EnCase crashes while acquiring certain corrupted NTFS partitions. The crash occurs when EnCase
processes FILE records that contain a larger-than-expected oﬀset to update sequence value, causing it to
read past the end of a buﬀer, resulting in a read access violation. Here is an example FILE record that
causes the crash.
6.4
Corrupted Microsoft Exchange Database Crashes EnCase During Search
and Analysis
EnCase crashes while searching/analyzing a ﬁlesystem containing a corrupted Microsoft Exchange database,
as seen in Figure ??. The crash occurs during the searching phase of an acquisition in which all Search,
Hash and Signature Analysis options were enabled. The crash appears to be a read access violation with a
bad value in eax that is dereferenced, but the exact value in eax appears to change every time (or at least
very often). We have not determined the cause of or full implications of this problem.
6.5
Corrupted NTFS Filesystem Causes Memory Allocation Error
EnCase reports memory allocation errors when acquiring corrupted NTFS images. The size of memory
being allocated is under the control of the attacker. iSEC has not found any ill eﬀects caused by this error
condition other than an error being displayed and corrupted records not being displayed.
6.6
EnCase and Linux Interpret NTFS Filesystems Diﬀerently
EnCase and Linux appear to use diﬀerent NTFS metadata when parsing directory structures. We created
an NTFS image with a directory loop in it by modifying an NTFS ﬁlesystem and replacing a directory entry
for a ﬁle with a reference to the directory’s parent directory. When mounting this directory in Linux5, the
modiﬁcation was as expected and a directory loop was present. When importing this image into EnCase,
the loop was not present and the original ﬁle was still present in the directory — but EnCase did not make
other ﬁles in the directory visible.
This diﬀerence in behavior can be used by an attacker to hide data on a disk. An NTFS image can be
constructed that has one interpretation on Linux and another in EnCase.
We manually edited an NTFS image to create a directory loop. This directory loop was visible in Linux
(when using the NTFS-3g driver) but to our surprise, EnCase did not see the edits we made. Instead it
displayed the unedited ﬁle. This indicates that EnCase and Linux give diﬀerent interpretation to NTFS
images, probably by using diﬀerent parts of the redundant information stored in the ﬁlesystem. An attacker
could abuse this inconsistency to hide data that could only be viewed in Linux and not in EnCase.
5iSEC used the NTFS-3g Linux driver: http://www.ntfs-3g.org/.
http://www.isecpartners.com
10/12
6.7
EnCase Crashes When Viewing Certain Deeply Nested Directories
We created NTFS images with very deeply nested directories and observed that EnCase would crash
in diﬀerent ways after the image was acquired when performing the Expand All action, or when manually
expanding the subdirectory views in the ﬁle browsing GUI. Some of these crashes were caused when the
program used a return address on the stack that had been overwritten. The values being written to the
stack were small integers. While were able to manipulate the value of these integers to some degree, we were
unable to exploit this ﬂaw for arbitrary code execution.
7
Conclusion
We performed focused, shallow, and narrow testing of EnCase and The Sleuth Kit, yet immediately found
security ﬂaws with simple attack tenchniques. We believe these vulnerabilities exist for several reasons:
1. Forensic software vendors are not paranoid enough. Vendors must operate under the assumption that
their software is under concerted attack. After all, the software is often used to examine evidenced
seized from suspected computer criminals and from computers suspected to have been compromised
by an attacker — that is, the evidence has been under the control of someone capable and motivated
to frustrate an investgation against them, or to attack again.
2. Vendors do not take advantage of the protections for native code that platforms provide, such as
stack overﬂow protection, memory page protection (e.g. ensuring that the write bit is unset whenever
the execute bit is set on a page), safe exception handling (speciﬁc to Microsoft C), et c. EnCase in
particular is not designed to be run by a low-privilege user, ensuring that any successful code-execution
attack runs with maximum privilege on the forensic workstation.
The use of managed code eliminates many types of attack altogether.
3. Forensic software customers use insuﬃcient acceptance criteria when evaluating software packages.
Criteria typically address only functional correctness during evidence acquisition (not analysis) when
no attacker is present,6 yet forensic investigations are adversarial. Therefore, customers should pressure
vendors to observe the practices in (2) and to perform negative testing against the product (discussed
further below).
4. The software and methods for testing the quality of forensic software should be public. Carrier notes7
that suﬃcient public testing tools, results, and methodologies either don’t exist or are not public.
Making these public will help customers know what they are getting and where they may be vulnerable,
and may even raise the standard of testing and improve the quality of the software.
6see http://www.cftt.nist.gov/ and [1], speciﬁcally lines 43 – 46 (“The two critical measurable attributes of the digital
source acquisition process are accuracy and completeness. Accuracy is a qualitative measure to determine if each bit of the
acquisition is equal to the corresponding bit of the source. Completeness is a quantitative measure to determine if each accessible
bit of the source is acquired.”) and 86 – 172. Although the NIST document focuses strictly on the acquisition of evidence, it
is not enough to standardize only acquisition. Most forensic toolkits also include functionality for evidence analysis, and it is
at the analysis stage where security, not just accuracy and completeness, is crucial.
7http://dftt.sourceforge.net/: “To ﬁll the gap between extensive tests from NIST and no public tests, I have been developing
small test cases.”
http://www.isecpartners.com
11/12
7.1
Future Work
We have only scratched the broad attack surface of the products we investigated.
We fuzzed and
manipulated only some of the most common data types and only in simple ways — other data formats and
more sophisticated attacks are likely to bring more defects to the surface.
7.2
Acknowledgements
We thank the vendors, Guidance Software and Brian Carrier, for their fast and helpful responses to our
issue reports. Thanks also go to Jesse Burns for his help in debugging software on Windows, and for original
authorship of the mutation functions we used in fuzzing.
References
[1] http://www.cftt.nist.gov/DA-ATP-pc-01.pdf. 11
[2] http://dftt.sourceforge.net/.
[3] http://www.seccuris.com/documents/papers/Seccuris-Antiforensics.pdf.
[4] http://www.blackhat.com/presentations/bh-usa-05/bh-us-05-foster-liu-update.pdf.
[5] http://metasploit.com/projects/antiforensics/.
[6] http://www.simson.net/clips/academic/2007.ICIW.AntiForensics.pdf.
[7] B. Carrier. File system forensic analysis. Addison Wesley, 2005.
http://www.isecpartners.com
12/12