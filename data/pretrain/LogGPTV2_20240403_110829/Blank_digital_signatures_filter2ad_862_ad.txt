1l
), runs Inst(T (cid:48)
) and returns σM(cid:48)
0l
l (cid:22) T (cid:48)
0 and M(cid:48)
0 and T (cid:48)
1 .
and σM(cid:48)
1l
b ,M(cid:48)
1
bl , σT (cid:48)
b
, pp, sk
b
l, σM(cid:48)
0l
, σM(cid:48)
1l
) and
0
b
retrieves (sk
returns σM(cid:48)
0l
b
and σM(cid:48)
1l
in a randomly permuted order.
All of these queries can be made adaptively.
Output: The adversary A outputs (Tb, σTb(cid:48) ) and wins if b = b(cid:48).
Game 3: Privacy Game
6.3 Comparison to the Naive Approaches
Recall that the ﬁrst naive approach given in Section 2.1 would require the originator to produce one
signature for every possible template instantiation. Let us look at the above example, where we have
20 ﬁxed elements and 25 exchangeable elements with 5 choices each. Note that this is an absolutely
reasonable example, which is far from being overstated. Then, the originator would have to compute
525 ≈ 298 · 1015 signatures, which is obviously impractical.
The second naive approach we have mentioned is the use of Merkle hash trees to reduce the
number of signatures that need to be computed by the originator at the expense of higher computa-
tional costs and an increased size of the signature. This means that the originator needs to build a
complete binary tree, where the number of leaves equals the number of possible template instantia-
tions. Furthermore, each leaf would need to include a random string as additional input to the hash
function in order to hide the instantiations from a veriﬁer as it is done in redactable signatures [11].
In our above example, the number of leaves would then be 525 ≈ 298 · 1015. In order to build the
hash tree, the originator would need to perform one hash evaluation per node in the tree. Note that
for a complete binary tree with n leaves there would be at most 2n − 1 nodes in the tree. For our
above example, this would yield at most 2 · 525 − 1 hash evaluations and the same number of PRF
evaluations to randomize the tree (see [11] for more details on how to compute the random strings
using a PRF). Although the veriﬁcation of a signature for an instantiation in this construction would
be quite eﬃcient, as it can be carried in logarithmic time in the number of possible instantiations,
KeyGen: On input (κ, t), choose an elliptic curve E(Fq) with a subgroup of large prime order p generated by
P ∈ E(Fq)[p], such that the bitlength of p is κ. Choose a pairing e : E(Fq)[p] × E(Fq)[p] → F∗
qk [p] and
a full-domain cryptographic hash function H : {0, 1}∗ → Zp for use with the encoding functions. Pick
α ∈R Z∗
Sign: Given T , pp, dskO and dpkP, where T is a template of size |T | = (cid:96) and length n with (cid:96) > n, this
algorithm picks a unique idT ∈R {0, 1}κ, computes tT = t(T ) ∈ Zp[X], picks a secret ρ ∈R Z∗
p and
computes
p, compute (αP, . . . , αtP ) and output pp = (H, E(Fq), e, p, P, αP, . . . , αtP ).
C = e(ρ · tT (α)P, P )
and τ = DSign(idT (cid:107)C(cid:107)n(cid:107)dpkP, dskO)
VerifyT : Given T , σT , pp, dpkO, skT
and returns the template signature σT = (idT ,C, n, τ ) as well as skT
P and dpkP, where T is a template of size |T | = (cid:96) and length n with (cid:96) > n,
this algorithm checks whether |T | ≤ t. If not, it returns false. Otherwise, it computes tT = t(T ) and
checks whether
P = ρ.
DVerify(τ, idT (cid:107)C(cid:107)n(cid:107)dpkP, dpkO) = true ∧ e(ρ · tT (α)P, P ) = C.
Inst: Given T ,M, σT , pp, skT
If so, return true and false otherwise.
algorithm computes mM = mT (M) ∈ Zp[X]. Then, it computes
P and dskP, where T is a template of size |T | = (cid:96) and length n with (cid:96) > n, this
CM = ρ · mM(α)P and µ = DSign(τ(cid:107)CM(cid:107)I, dskP).
It returns σM = (µ,CM,I, σT ).
VerifyM: Given M, σM = (µ,CM,I = (|Mi|)n
i=1, σT ), pp, dpkP and dpkO this algorithm veriﬁes whether
DVerify(τ, idT (cid:107)C(cid:107)n(cid:107)dpkP, dpkO) = true ∧ DVerify(µ, τ(cid:107)CM(cid:107)I, dpkP) = true ∧
n(cid:88)
|I| = n ∧
|Mi| = |M|
On failure return false, otherwise evaluate mM = mT (M) and check whether
i=1
e(mM(α)P,CM) = C
On success return true and false otherwise.
Scheme 1: Blank Digital Signature Scheme
the Sign, VerifyT and Inst algorithms all require the computation of the full hash tree rendering this
approach impractical.
We emphasize that in our approach the signature size stays constant, regardless of the number of
possible template instantiations. This is due to the fact that the template polynomial, whose degree
grows only linearly in the template size, is mapped to a point on the curve, which is further mapped
to a ﬁeld element and then hashed. Notice that in our construction, the computational eﬀort is
independent of the number of potential template instantiation. Instead, it grows only linearly with
the template size, i.e., with the number and the cardinality of exchangeable elements and the number
of ﬁxed elements.
6.4 Security
Subsequently, we investigate the security of our construction in the proposed security model by
considering all the required security properties.
Theorem 1. Assuming the existence of secure hash functions and that the t-SDH assumption holds
in E(Fq), Scheme 1 is correct with respect to Deﬁnition 10.
Proof. See Appendix A.1.
Theorem 2. Assuming the existence of secure hash functions and secure digital signature schemes
and that the t-SDH assumption holds in E(Fq), Scheme 1 is unforgeable with respect to Deﬁnition 11.
We assume that the originator as well as the proxy both own an authentic key pair for a secure digital
signature scheme (dskO, dpkO) and (dskP, dpkP), respectively.
SetupT: The trusted third party T chooses a suitable security parameter κ and a value t ∈ N representing
the maximum template length, runs KeyGen(κ, t) and publishes pp in an authentic fashion.
IssueO: O deﬁnes a message template T , runs Sign(T , pp, dskO, dpkP) and gives σT = (idT ,C, n, τ ) as well as
skT
P , dpkP) to check whether σT is a valid signature for T is-
IssueP: P runs VerifyT (T , σT , pp, dpkO, skT
sued by O. On success, P, on behalf of O, deﬁnes a template instantiation M (cid:22) T and runs
Inst(T ,M, σT , pp, skT
run
VerifyM(M, σM, pp, dpkP, dpkO) to check whether σM is a valid signature for M issued by O
and P.
P , dskP) and publishes (M, σM).
possession
Verify: Anybody
(M, σM)
public
keys
P to P.
can
now take
and
in
of
the
Protocol 1: Blank Digital Signature Protocol
Proof. See Appendix A.2.
Theorem 3. Assuming the existence of secure hash functions and secure digital signature schemes
and that the t-SDH assumption holds in E(Fq), Scheme 1 is immutable with respect to Deﬁnition 12.
Proof. See Appendix A.3.
Theorem 4. Scheme 1 is unconditionally private with respect to Deﬁnition 13.
Proof. See Appendix A.4.
Taking Theorem 1-Theorem 4 together, we obtain the following corollary.
Corollary 1. Scheme 1 is a secure BDSS.
7 Conclusions
In this paper we have introduced a new notion of digital signatures, namely so-called blank digital
signatures. We have provided the abstract scheme, a security model and a concrete construction of
such a scheme from any secure digital signature scheme, pairing-friendly elliptic curves and poly-
nomial commitments. Moreover, we have proven the security of our construction and have given
several use cases, such as delegated contract signing.
7.1 Future Work
Since blank digital signatures are a novel concept, there are several open issues for future work, which
we outline subsequently. One issue for future work is to get rid of the trusted third party for key
generation. Furthermore, it would be desirable to generalize the blank digital signature scheme and
its security model to multiple designated proxies, which seems to be straight-forward by inclusion
of multiple proxy signature veriﬁcation keys into the template signature. However, in this naive
construction every proxy and every veriﬁer can determine the set of designated proxies. This may
not be desirable in practice, whereas to achieve this goal does not seem to be that straight-forward.
Another issue is to ﬁnd alternative designated constructions for blank signatures potentially without
relying on standard digital signature schemes. Additionally, it would be desirable to prove the security
of our construction under weaker assumptions and to impose further restrictions on allowed template
instantiations, i.e., to further limit the allowed combinations of choices over all exchangeable elements
of templates. Also, allowing blank ﬁelds, which can be substituted with arbitrary strings, would be
desirable. Finally, it may be interesting to investigate concepts applied in the construction of blank
digital signatures in the proxy signature setting.
8 Acknowledgements
We would like to thank Jiangtao Li for his many valuable suggestions for improving the presentation
of this paper. The work of both authors has been supported by the European Commission through
project FP7-FutureID, grant agreement number 318424.
References
1. Ateniese, G., Chou, D.H., de Medeiros, B., Tsudik, G.: Sanitizable Signatures. In: ESORICS. LNCS,
vol. 3679, pp. 159–177. Springer (2005)
2. Benaloh, J.C., de Mare, M.: One-way accumulators: A decentralized alternative to digital sinatures (ex-
tended abstract). In: Advances in Cryptology - EUROCRYPT ’93. Lecture Notes in Computer Science,
vol. 765, pp. 274–285 (1993)
3. Bloom, B.H.: Space/time trade-oﬀs in hash coding with allowable errors. Commun. ACM 13(7), 422–426
(1970)
4. Boldyreva, A., Palacio, A., Warinschi, B.: Secure proxy signature schemes for delegation of signing rights.
IACR Cryptology ePrint Archive 2003, 96 (2003)
5. Boldyreva, A., Palacio, A., Warinschi, B.: Secure Proxy Signature Schemes for Delegation of Signing
Rights. J. Cryptology 25(1), 57–115 (2012)
6. Brzuska, C., P¨ohls, H.C., Samelin, K.: Non-interactive public accountability for sanitizable signatures.
In: Proc. of the 9th European PKI Workshop: Research and Applications (EuroPKI 2012). LNCS,
Springer-Verlag (2012)
7. Canard, S., Jambert, A.: On Extended Sanitizable Signature Schemes. In: Topics in Cryptology - CT-
RSA 2010. LNCS, vol. 5985, pp. 179–194 (2010)
8. Chatterjee, S., Menezes, A.: On cryptographic protocols employing asymmetric pairings - the role of ψ
revisited. Discrete Applied Mathematics 159(13), 1311–1322 (2011)
9. Gallagher, P., Furlani, C.: FIPS PUB 186-3 federal information processing standards publication digital
signature standard (dss) (2009)
10. Goldwasser, S., Micali, S., Rivest, R.L.: A Digital Signature Scheme Secure Against Adaptive Chosen-
Message Attacks. SIAM J. Comput. 17(2), 281–308 (1988)
11. Johnson, R., Molnar, D., Song, D.X., Wagner, D.: Homomorphic Signature Schemes. In: Topics in
Cryptology - CT-RSA 2002. LNCS, vol. 2271, pp. 244–262 (2002)
12. Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size commitments to polynomials and their applica-
tions. In: Advances in Cryptology - ASIACRYPT 2010. pp. 177–194 (2010)
13. Klonowski, M., Lauks, A.: Extended sanitizable signatures. In: ICISC. pp. 343–355 (2006)
14. Mambo, M., Usuda, K., Okamoto, E.: Proxy Signatures for Delegating Signing Operation. In: ACM
Conference on Computer and Communications Security (CCS 1996). pp. 48–57 (1996)
15. Merkle, R.C.: A digital signature based on a conventional encryption function. In: CRYPTO. pp. 369–378
(1987)
16. Samelin, K., Poehls, H.C., Posegga, J., de Meer, H.: Redactable vs. Sanitizable Signatures. Tech. Rep.
Number MIP-1208, Department of Informatics and Mathematics, University of Passau (2012)
17. Schuldt, J.C.N., Matsuura, K., Paterson, K.G.: Proxy Signatures Secure Against Proxy Key Exposure.
In: 11th International Workshop on Practice and Theory in Public-Key (PKC 2008). LNCS, vol. 4939,
pp. 141–161 (2008)
18. Silverman, J.: The Arithmetic of Elliptic Curves, Graduate Texts in Mathematics, vol. 106. Springer
(1986)
19. Steinfeld, R., Bull, L., Zheng, Y.: Content Extraction Signatures. In: ICISC 2001. LNCS, vol. 2288, pp.
285–304. Springer (2001)
A Proofs
This section contains the proofs of Theorem 1-Theorem 4.
A.1 Proof of Theorem 1
We show the signature correctness and soundness as well as the instantiation correctness, where we
omit showing that the DSS veriﬁcation as well as the signature veriﬁcation and message signature
veriﬁcation work, since they are clear from the construction.
What remains to show is the signature soundness. Note that for a given template signature σT for
template T the commitment C of the template encoding polynomial is ﬁxed. Consequently, breaking
the signature soundness requires ﬁnding (skT
P ,T ∗) such that C∗ = C.
P ,T ) (cid:54)= (skT ∗
This requires either collisions in the hash function H used in the encoding functions, ﬁnding
second preimages in H or breaking the polynomial binding of the construction. If an adversary A
is able to attack the latter case, then we can construct an eﬃcient adversary B, which uses A to
solve the t-SDH problem in E(Fq). B gets input an instance (P, αP, . . . , αtP ) of the t-SDH problem.
Then B runs DKeyGen twice to produce DSS key pairs for the originator and the proxy, sets up the
public parameters pp = (H, E(Fq), e, p, P, αP, . . . , αtP ) and gives pp and the DSS key pairs to A. If
A is able to win the game by outputting a template signature σT to T as well as (skT
P = ρ,T ) and