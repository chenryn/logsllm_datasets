491
98.7
100.0
99.9
98.9
–
100.0
99.5
99.3
99.1
99.8
96.5
91.5
98.8
97.8
–
100.0
96.9
97.9
97.1
96.4
the virtual callsite which does not follow a typical C++ callsite
pattern. This could be addressed by considering additional vcall
patterns, at the risk of adding false positives. Given our already
high recall rates, we believe this would not be a favorable trade-off.
We also verified 86 cases which VTV did not recognize as vir-
tual callsite instructions. A manual verification of all cases show
that these are indeed vcall instructions and hence missed virtual
callsites by VTV. An example is given in Figure 4 for 510.parest_r.
Here, a vector is created and the function reinit() is invoked on
line 2547. However, since the class dealii::Vector is
provided by the application and reinit() is a virtual function of
this class, this function call is translated into a virtual callsite. We
contacted the VTV authors about this issue and they confirmed
that this happens because the compiler accesses the memory of the
objects directly when calling the virtual function in the internal
intermediate representation. Usually, the compiler accesses them
while going through an internal vtblptr field. Unfortunately, to fix
this issue in VTV would require a lot of non-trivial work since the
analysis has to be enhanced.
CFIXX. Since CFIXX performs the enforcement in a similar way,
we also evaluated our binary-only approach against this source code
based method. Hence, we compiled the applications with CFIXX
which is based on LLVM and extracted the protected virtual callsites
as ground truth for our comparison. Table 3 shows the results of this
evaluation. Unfortunately, we were not able to compile 447.dealII
and 526.blender_r with CFIXX. As the table shows, vps can identify
on average 99.6% of all SPEC CPU2006 and 99.5% of SPEC CPU2017
virtual callsites that are also protected by CFIXX. Furthermore,
vps also yields a high precision with 97.0% for SPEC CPU2006
107Table 4: Results of Marx’s vcall accuracy evaluation. For
each application this table shows (i) the ground truth gen-
erated by VTV; (ii) static vcall identification, depicting the
number of indirect call instructions identified as vcall that
are true positives and false positives as well as recall and
precision.
#TP
1,307
–
98
701
1
–
Static Identification
#FP
122
–
10
3
0
–
Recall (%)
83.9
–
96.1
87.4
100.0
–
91.8
Precision (%)
91.5
–
90.7
99.6
100.0
–
95.4
3,673
115
5,465
23,541
171
0
295
11
22
33
1,347
0
78.5
94.3
85.0
69.4
98.3
0.0
70.9
69.7
81.3
84.2
92.6
91.3
99.6
99.9
11.3
0.0
65.8
90.9
88.8
90.7
Program
447.dealII
450.soplex
453.povray
471.omnetpp
473.astar
483.xalancbmk
Average [SPEC CPU2006]
#GT
1,558
–
102
802
1
–
510.parest_r
511.povray_r
520.omnetpp_r
523.xalancbmk_r
526.blender_r
541.leela_r
Average [SPEC CPU2017]
4,678
122
6,430
33,880
174
1
MongoDB
MySQL
Node.js
17,836
11,876
12,643
12,437
10,867
10,648
1,249
1,214
1,095
and 96.9% for SPEC CPU2017 on average. For large real-world
applications, the recall and precision rates are similar with a recall
of 99.1% for MySQL and 99.8% for Node.js and a precision of 97.1%
and 96.4% respectively. A manual analysis of the missed virtual
callsites (false negatives) showed the same two reasons for a miss
that also occurred for VTV.
Marx. A direct comparison of the accuracy with other binary-
only approaches is difficult since different test sets are used to
evaluate it. For example, vfGuard evaluates the accuracy of their ap-
proach against only two applications, while T-VIP is only evaluated
against one. VTint states absolute numbers without any compari-
son with a ground truth. VCI evaluates their approach against SPEC
CPU2006, but the numbers given for the ground truth created with
VTV differ completely from ours (e.g., 9,201 vs. 13,440 vcalls for
483.xalancbmk) which makes a comparison difficult. Additionally,
the paper reports no false positives during their analysis which
we encounter in the same application set with a similar identifi-
cation technique. Unfortunately, as discussed in Section 4.3.1, we
were not able to determine the reason for this. Furthermore, most
approaches target different platforms than vps (Windows x86 and
Linux x86) and are not open source. Since Marx is the only open
source approach that targets the same platform, we analyzed our
evaluation set with it. In order to create as few false positives as pos-
sible, we used its conservative mode. Unfortunately, Marx crashed
during the analysis of 483.xalancbmk. The results of the analysis
can be seen in Table 4. Compared to Marx, we have considerably
higher recall with better precision. Averaged over the CPU2006
benchmarks supported by Marx, vps achieves 98.2% recall (91.8%
for Marx) and on CPU2017 97.4% versus 70.9%, respectively. This
Table 5: Object creation and destruction accuracy results,
showing the number of vtable references in the code as
found in the ground truth and as identified or missed by our
analysis.
Program
447.dealII
450.soplex
453.povray
471.omnetpp
473.astar
483.xalancbmk
510.parest_r
511.povray_r
520.omnetpp_r
523.xalancbmk_r
526.blender_r
541.leela_r
MongoDB
MySQL
Node.js
#GT
–
102
103
372
0
2,918
12,482
103
1,381
2,790
–
87
8,054
8,532
7,816
#identified
–
228
226
871
8
6,530
25,804
224
3,280
6,323
–
180
11,401
11,524
19,204
#missed
–
0
0
0
0
0
0
0
0
0
–
0
0
0
0
does not come at the cost of more false positives, as our precision is
similar on CPU2006 (94.5% vs. 95.4%) and much better on CPU2017
(91.1% vs. 65.8%). For large real-world applications like MySQL and
MongoDB, vps identifies 16.3% and 28.1% more virtual callsites with
better precision (98.5% vs. 88.8% for MySQL and 99.7% vs. 90.9% for
MongoDB).
Overall, our analysis shows that vps is precise enough to pro-
vide an application with protection against control-flow hijacking
attacks at virtual callsites. The evaluation showed that on aver-
age only 2.5% when comparing against VTV and 0.5% comparing
against CFIXX of the vcalls were missed. Since binary analysis is
a hard problem, the results are very promising in showing that a
sophisticated analysis can almost reach the same degree of protec-
tion as a source based approach. In addition, it shows that even
source code approaches such as VTV do not find all virtual callsite
instructions and can benefit from binary-only approaches such as
vps. Furthermore, the number of false positives show the sensibility
of our approach to handle them during instrumentation rather than
assume their absence.
7.2 Object Initialization/Destruction Accuracy
To avoid breaking applications, vps must instrument all valid ob-
ject initialization and destruction sites. To ensure that this is the
case, we compare the number of vtable-referencing instructions
found by vps to a ground truth. We generate the ground truth
with an LLVM 4.0.0 pass that instruments Clang’s internal func-
tion CodeGenFunction::InitializeVTablePointer(), which
Clang uses for all vtable pointer initialization.
Table 5 shows the results for the same set of applications we used
in Section 7.1. We omit results for 447.dealII from SPEC CPU 2006
and 526.blender_r from SPEC CPU 2017 because these benchmarks
fail to compile with LLVM 4.0.0. The results for the remaining appli-
cations show that our analysis finds all vtable-referencing instruc-
tions. It conservatively overestimates the set of vtable-referencing
instructions, ensuring the security and correctness of vps at the
108vtblptr writes
+Virtual calls
+Secure mprotect
+Dynamic analysis
5
0
8.n
a
m
d
5
1
0.p
arest
5
1
1.p
o
vra
y
5
2
0.o
5
2
3.x
m
n
etp
p
ala
n
cb
m
k
5
2
6.ble
5
3
1.d
n
d
er
ee
psje
n
g
5
4