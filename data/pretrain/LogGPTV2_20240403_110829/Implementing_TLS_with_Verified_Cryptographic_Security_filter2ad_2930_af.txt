These assumptions are similar to the tagged key-encapsulation
security of [34] and the PRF-ODH assumption of [33] respec-
tively (see the full paper for details). Thus we deﬁne
= StrongSig(si) ∧ StrongCRE(si) ∧ StrongPRF(si) ∧
StrongHS(si)
(StrongRSAPMS(si) ∨ StrongDHPMS(si))
(cid:3)
For example, if the ciphersuite of si matches TLS_DHE_
DSS_WITH_*, StrongHS(si) holds if the signature scheme
DSS is INT-CMA secure [31], CRE and DH are jointly DH-
PMS secure, CRE is a computationally strong randomness
extractor [26], and PRF is a pseudo-random function, and
similarly for RSA-based ciphersuites.
PRF
;Ii
CRE-secure, PRF is Ii
Theorem 4 (Handshake): If Nonce is Ii
Nonce-secure, Sig is
Ii
Sig-secure, CRE is Ii
PRF-
secure, and we have
RSAKey · CRE · RSA ≈ RSAKey · CRE · RSAi,
(RSA-PMS)
(DH-PMS) DHGroup · CRE · DH ≈ DHGroup · CRE · DHi,
= Nonce· Sig· RSAKey· Cert· PRF· DHGroup· CRE·
then HS
RSA · DH · TLSExt · Handshake is Ii
;Ii
StAE
;Ii
HS secure.
StAE
(cid:3)
Intuitively, the theorem states that HS is secure provided
its cryptographic building blocks are INT-CMA, CRE, PRF,
RSA-PMS, and DH-PMS secure for all strong handshake
ciphersuites.
Proof outline To be able to complete the proof of Theorem 4
by typing, we replace each concrete implementations of the
underlying cryptographic modules by their typed, ideal coun-
terparts. The order of idealizations in our proof corresponds
to the sequence of games in ordinary security proofs which
for the ciphersuites TLS_DHE_DSS_WITH_* is very close
to Jager et al. [33]. Their proof only considers a particular
ciphersuite in isolation and only for the initial handshake; the
proof for our implementation requires more work to handle full
and abbreviated handshakes and re-handshakes with different
key exchange methods, and thus heavily relies on automation,
e.g., because of the potential for cross-protocol attacks [46].
After idealization, we apply typing Lemmas to verify by
typing that the idealized handshake meets Ii
HS. The Handshake
module itself, the largest and most complex in our codebase,
455
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:52:05 UTC from IEEE Xplore.  Restrictions apply. 
type (;id:epoch) stream
type (;id:epoch, h:(;id)stream, r:range) data
val data:
id:epoch{not(Auth(id))} → s:(;id) stream → r:range →
b:(;r) rbytes → c: (;id,s,r) data
val repr:
id:epoch{not(Safe(id))} → s:(;id) stream → r:range →
c: (;id,s,r) data → (;r) rbytes
val split: id:epoch → s:(;id) stream →
r0:range → r1:range → d:(;id,s,Sum(r0,r1)) data →
d0:(;id,s,r0) data ∗ d1:(;id,ExtendStream(id,s,r0,d0),r1) data
Figure 3. DataStream interface towards TLS (excerpt).
implements the handshake internal state machine, but does not
implement cryptography. It is veriﬁed by typing using the ideal
interfaces of the cryptographic modules (Lemma Handshake
.tc7). For this task, we carefully specify the content of the
message log eventually veriﬁed in the Finished messages,
and we rely on the safe renegotiation extension to provide
authentication of the whole chain of epochs extended by each
successive handshake on the connection.
VI. MAIN API & THEOREMS FOR TLS
We are now ready to explain our ideal interface for TLS
and give our main theorems.
A. TLS API
cally derived from those deﬁned in §IV and §V:
The main API depends on two predicates on epochs, logi-
• Auth(id), deﬁned as SafeHS(SI(id))∧ StrongAuth(id), indi-
cates that data exchanged over a connection with epoch
id is expected to be authentic in an ideal TLS implemen-
tation. Our types prevent the forgery of such data.
• Safe(id), deﬁned as SafeHS(SI(id))∧ Strong(id), indicates
that data exchanged over id is expected to be both
authentic and secret in an ideal implementation. Our types
prevent all access to such data outside the application.
Both these predicates rely on the honesty of the pre master
secret, and hence of the long-term keys used in id. For
simplicity, our API does not enable the compromise of StAE
keys once they have been safely generated by the handshake.
However, since these keys are also typed using interfaces
with LEAK functions (see §IV), it would be straightforward
to formally supplement our APIs with explicit functions that
let the adversary generate corrupt keys. Similarly, we do not
currently model forward secrecy, which can in any case only
be achieved for ephemeral Difﬁe-Hellman ciphersuites.
DataStream The API is parameterized by an application-
level plaintext module DataStream. Fig. 3 provides its main
interface towards TLS. (It may export a richer interface to
other application-level modules.) The indexed abstract type
data represents messages exchanged over TLS connections;
stream is the type of speciﬁcation-level sequences of data
fragments, used to index the messages sent (or received) at a
particular position in the data stream. DataStream may deﬁne
data concretely e.g. as bytes, and stream as a list of bytes.
To send the next message over an established connection
indexed by id, after sending the stream s, the application may
provide any value of type (;id,s,rg)data. As explained in §IV,
data is also indexed by a range rg, so that the application may
shape the trafﬁc by hiding secret data lengths within a given
public range. Both data and stream are abstract types indexed
precisely by positions and epochs, thus only the application
may access raw data or move data between positions and
epochs. The DataStream interface exports three functions to
TLS. The functions data and repr let TLS read the concrete
binary representation of application data at un-Safe indexes,
and forge application data at un-Auth indexes. In addition, the
split function enables TLS to fragment data without looking at
its contents, by providing two sub-ranges r0 and r1 that add
up to the index range r; the function returns two data values
that logically come one after the other in their data stream.
Main TLS Interface Fig. 4 outlines our main F7 interface,
omitting most reﬁnements for simplicity. The API provides
abstract TLS connections using two main types:
indexes
(ConnectionInfo, written CI for brevity) and states (Cn). An
index is an immutable data structure detailing connection
parameters (see §V). A state is an abstract type, representing a
handle c to a running client or server TLS connection; its index
is written CI(c). Initial states (Cn0) are returned by connect
or accept; they must then be used linearly; next states that
leave the index unchanged are written nextCn. The interface
provides two main functions to operate on TLS connections,
read and write, plus a series of functions to initiate them and
control their successive handshakes (explained in §V).
• read takes the current state and returns an ioresult i, with
different cases: Read(c,d) returns an updated connection
state c and some received data d; the index of d states
that it extends the input stream of the current epoch,
and a postcondition states that if Auth holds for this
epoch, then the peer has sent that data; similarly Fatal
and Close, report genuine alerts from the peer if Auth
holds; CertQuery notiﬁes the application that the current
handshake requests some certiﬁcate authorization (either
by resuming the handshake with authorize or aborting it
with refuse); Handshaken signals the completion of the
current handshake; the application can then inspect the
new epoch before proceeding.
• write takes the current state and some data, and sim-
ilarly returns an ioresult o with different cases, e.g.,
WritePartial returns an updated state and the rest of the
message, after sending its ﬁrst fragment; and MustRead
notiﬁes the application that
the
it should read until
ongoing handshake completes before writing again.
For instance, a client application that implements data as
strings may interact with TLS with a (call −→ result) sequence
as follows (with an implicit state threaded through the calls):
connect t g; read −→ CertQuery(q); authorize q −→ Handshaken;
write 6..30 "Hello world\n" −→ WriteComplete;
read −→ Read(0..24,"404\n"); read −→ Close(t).
TLS does not guarantee synchronization between input
and output streams; for instance, the client may write three
(cid:2)
0, then initiate rekeying, while
messages d0, d1, d2 then read d
456
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:52:05 UTC from IEEE Xplore.  Restrictions apply. 
type Cn
type (;g:conﬁg) Cn0 = c0:Cn{InitCn(g,c0)}
type (;c:Cn) nextCn = c’:Cn{NextCn(c,c’)}
type (;c:Cn) msg i = r:range ∗ (;CI(c).id in, Stream i(c), r) data
type (;c:Cn) msg o = r:range ∗ (;CI(c).id out, Stream o(c), r) data
type (;c:Cn) ioresult i =
| Read of c’:(;c) nextCn ∗ d:(;c) msg i
{Extend i(c,c’,d) ∧ (Auth(CI(c).id in) ⇒ Write(CI(c).id in, Bytes i(c’))) }
| Close of TCP.Stream{Auth(CI(c).id in) ⇒ Close(CI(c).id in, Bytes i(c))}
| Fatal of a:alertDescription
{Auth(CI(c).id in) ⇒ Fatal(CI(c).id in,a,Bytes i(c))}
| CertQuery of c’:(;c) nextCn ∗ (;c’) query {Extend(c, c’)}
| Handshaken of c’:Cn {Complete(CI(c’),Cfg(c’)) ∧ ...}
| ...
val read : c:Cn → (;c) ioresult i
type (;c:Cn,d:(;c) msg o) ioresult o =
| WriteComplete of c’:(;c) nextCn {Extend o(c,c’,d)}
| WritePartial of c’:(;c) nextCn ∗ d’:(;c’) msg o
{ ∃d0. Extend o(c,c’,d0) ∧ Split o(c, d, d0, c’, d’) }
| WriteError of alertDescription option
| MustRead of c’:Cn {...}
val write: c:Cn → d:(;c) msg o → (;c,d) ioresult o
val connect: TCP.Stream → g:conﬁg → c0:(;g)Cn0{CI(c0).role = Client}
val accept: TCP.Stream → g:conﬁg → c0:(;g)Cn0{CI(c0).role = Server}
val shutdown: c:Cn → c’:Cn{...}
val rekey: c:Cn {CI(c).role=Client} → c’:(;c)nextCn{Extend(c,c’)}
val resume: TCP.Stream → g:conﬁg → sessionID → c0:(;g)Cn0{...}
val rehandshake: c:Cn {CI(c).role=Client} → c’:(;c)nextCn{...}
val request: c:Cn {CI(c).role=Server} → c’:(;c)nextCn{...}
val authorize: c:Cn → (;c) query → (;c) ioresult i
val refuse: c:Cn → (;c) query → unit
Figure 4. Main TLS interface (excerpt).
(cid:2)
0 and d
(cid:2)
the server reads d0, write d
1, then reads d1. On the
other hand, when notiﬁed of a Close or that a new handshake is
complete, our interface guarantees that all previous fragments
have been received; so, the client knows that d2 was received,
and the server knows that d
(cid:2)
1 was received.
B. TLS Security
As usual with communications protocols, the adversary is
in full control of the network. This is modelled by a trivial
TCP implementation, written TCP below, that reads and writes
into buffers shared with the adversary. The application and its
adversary may repeatedly set the input buffer, call the TLS
interface, and read the output buffer, thereby scheduling any
number of parallel connections.
Our main theorem is stated for a class of adversaries
that range over restricted programs well-typed against
the
TLS API. As illustrated below, such programs include TLS
applications composed with their own adversaries, and our
theorem enables the automated security veriﬁcation of these
applications by typechecking. In addition, §VI-C gives a corol-
lary, stated more cryptographically as security for a class of
adversaries with oracle access to functions over plain datatypes
(bytes, pairs, and integers) rather than those of our API. Let
Ii
DS be the dataStream interface (Fig. 3) and Ii
T LS be our
main TLS interface (Fig. 4), including auxiliary interfaces
such as ICert to give the adversary control over long-term key
management.
Deﬁnition 6: A module C is TLS-secure when it
DS, ITCP) ;Ii
TLS-secure for restricted users.
(Ii
is
457
Intuitively, the deﬁnition means that TLS treats data sent
over connections with Safe indexes as if it were abstract—only
the application is able to create and read them. Moreover, the
whole streams are authenticated, interleaved with occurrences
of TLS events about the handshake and alerts.
; Ii
StAE
StAE-secure and Ii
Theorem 5 (TLS Security): For any StAE and HS that are
StPlain ; I i
Ii
HS-secure for restricted
users, the module StAEPlain · StAE · HS · TLS is TLS-secure.
Proof outline Recall the deﬁnition of Safe(id) as SafeHS(SI(
id))∧ Strong(id); thus indexes safe for HS and StAE are also
safe with regards to our TLS implementation. The main step
of the proof is by typechecking our implementation code,
(cid:2) StPlain ; Ii
that is, Ii
StPlain (Lemma StPlain.tc7) and
(cid:2) TLS ; Ii
DS
ITCP, Ii
DS, Ii
StAE, Ii
TLS (Lemmas Dispatch.tc7 and
HS
TLS.tc7, where Dispatch.fs is an auxiliary module of TLS that
multiplexes between content types.).
We combine Theorems 3, 4, and 5 and summarize them in
cryptographic terms as follows: If the cryptographic building
blocks of TLS are IND-CPA, INT-CMA, SPRP, and PRF
secure for strong record cipher-suites and INT-CMA, CRE,
PRF, RSA-PMS, and DH-PMS secure for strong handshake
cipher-suites, then TLS is secure when used safely through our
API. As illustrated by our sample applications, the safe use of
our API can easily be controlled by typing.
C. Security for ‘untyped’ adversaries
Theorem 5 holds for any composition of applications and
their adversaries well-typed against our TLS API. To show