### Assumptions and Definitions

The assumptions in our work are similar to the tagged key-encapsulation security of [34] and the PRF-ODH assumption of [33]. For a detailed comparison, refer to the full paper. We define the following:

\[
\text{StrongSig}(s_i) \land \text{StrongCRE}(s_i) \land \text{StrongPRF}(s_i) \land \text{StrongHS}(s_i) \land (\text{StrongRSAPMS}(s_i) \lor \text{StrongDHPMS}(s_i))
\]

For example, if the ciphersuite of \( s_i \) matches `TLS_DHE_DSS_WITH_*`, then \(\text{StrongHS}(s_i)\) holds if:
- The signature scheme DSS is INT-CMA secure [31].
- CRE and DH are jointly DHPMS secure.
- CRE is a computationally strong randomness extractor [26].
- PRF is a pseudo-random function.

Similarly, for RSA-based ciphersuites, the same conditions apply.

### Theorem 4: Handshake Security

**Theorem 4 (Handshake):** If Nonce is \( I_i \)-Nonce-secure, Sig is \( I_i \)-Sig-secure, CRE is \( I_i \)-CRE-secure, PRF is \( I_i \)-PRF-secure, and we have:

\[
\text{RSAKey} \cdot \text{CRE} \cdot \text{RSA} \approx \text{RSAKey} \cdot \text{CRE} \cdot \text{RSA}_i
\]

\[
\text{(DH-PMS)} \quad \text{DHGroup} \cdot \text{CRE} \cdot \text{DH} \approx \text{DHGroup} \cdot \text{CRE} \cdot \text{DH}_i
\]

Then, \( \text{HS} = \text{Nonce} \cdot \text{Sig} \cdot \text{RSAKey} \cdot \text{Cert} \cdot \text{PRF} \cdot \text{DHGroup} \cdot \text{CRE} \cdot \text{RSA} \cdot \text{DH} \cdot \text{TLSExt} \cdot \text{Handshake} \) is \( I_i \)-HS-secure.

**Intuition:** This theorem states that the handshake is secure provided its cryptographic building blocks (INT-CMA, CRE, PRF, RSA-PMS, and DH-PMS) are secure for all strong handshake ciphersuites.

### Proof Outline

To prove Theorem 4, we replace each concrete implementation of the underlying cryptographic modules with their typed, ideal counterparts. The order of idealizations corresponds to the sequence of games in ordinary security proofs, which for the ciphersuites `TLS_DHE_DSS_WITH_*` is very close to Jager et al. [33]. Their proof only considers a particular ciphersuite in isolation and only for the initial handshake. Our proof requires more work to handle full and abbreviated handshakes and re-handshakes with different key exchange methods, thus heavily relying on automation to address potential cross-protocol attacks [46].

After idealization, we apply typing lemmas to verify by typing that the idealized handshake meets \( I_i \)-HS. The Handshake module, the largest and most complex in our codebase, implements the handshake internal state machine but does not implement cryptography. It is verified by typing using the ideal interfaces of the cryptographic modules (Lemma Handshake.tc7). We carefully specify the content of the message log eventually verified in the Finished messages and rely on the safe renegotiation extension to provide authentication of the whole chain of epochs extended by each successive handshake on the connection.

### Main API and Theorems for TLS

#### A. TLS API

The main API depends on two predicates on epochs, logically derived from those defined in Sections IV and V:

- **Auth(id):** Defined as \(\text{SafeHS}(\text{SI}(id)) \land \text{StrongAuth}(id)\), indicates that data exchanged over a connection with epoch \( id \) is expected to be authentic in an ideal TLS implementation. Our types prevent the forgery of such data.
- **Safe(id):** Defined as \(\text{SafeHS}(\text{SI}(id)) \land \text{Strong}(id)\), indicates that data exchanged over \( id \) is expected to be both authentic and secret in an ideal implementation. Our types prevent all access to such data outside the application.

Both these predicates rely on the honesty of the pre-master secret and the long-term keys used in \( id \). For simplicity, our API does not enable the compromise of StAE keys once they have been safely generated by the handshake. However, since these keys are also typed using interfaces with LEAK functions (see Section IV), it would be straightforward to formally supplement our APIs with explicit functions that let the adversary generate corrupt keys. Similarly, we do not currently model forward secrecy, which can only be achieved for ephemeral Diffie-Hellman ciphersuites.

**DataStream Interface:**
The API is parameterized by an application-level plaintext module DataStream. Figure 3 provides its main interface towards TLS. (It may export a richer interface to other application-level modules.) The indexed abstract type `data` represents messages exchanged over TLS connections; `stream` is the type of specification-level sequences of data fragments, used to index the messages sent (or received) at a particular position in the data stream. DataStream may define `data` concretely, e.g., as bytes, and `stream` as a list of bytes.

To send the next message over an established connection indexed by \( id \), after sending the stream \( s \), the application may provide any value of type `(;id,s,rg)data`. As explained in Section IV, `data` is also indexed by a range \( rg \), so the application may shape the traffic by hiding secret data lengths within a given public range. Both `data` and `stream` are abstract types indexed precisely by positions and epochs, thus only the application may access raw data or move data between positions and epochs. The DataStream interface exports three functions to TLS: `data`, `repr`, and `split`.

- **data:** Allows TLS to read the concrete binary representation of application data at un-Safe indexes.
- **repr:** Allows TLS to forge application data at un-Auth indexes.
- **split:** Enables TLS to fragment data without looking at its contents, by providing two sub-ranges \( r0 \) and \( r1 \) that add up to the index range \( r \); the function returns two data values that logically come one after the other in their data stream.

**Main TLS Interface:**
Figure 4 outlines our main F7 interface, omitting most refinements for simplicity. The API provides abstract TLS connections using two main types: indexes (`ConnectionInfo`, written CI for brevity) and states (`Cn`). An index is an immutable data structure detailing connection parameters (see Section V). A state is an abstract type, representing a handle \( c \) to a running client or server TLS connection; its index is written `CI(c)`. Initial states (`Cn0`) are returned by `connect` or `accept`; they must then be used linearly; next states that leave the index unchanged are written `nextCn`.

The interface provides two main functions to operate on TLS connections, `read` and `write`, plus a series of functions to initiate them and control their successive handshakes (explained in Section V).

- **read:** Takes the current state and returns an `ioresult i`, with different cases:
  - `Read(c,d)`: Returns an updated connection state \( c \) and some received data \( d \); the index of \( d \) states that it extends the input stream of the current epoch, and a postcondition states that if Auth holds for this epoch, then the peer has sent that data.
  - `Fatal` and `Close`: Report genuine alerts from the peer if Auth holds.
  - `CertQuery`: Notifies the application that the current handshake requests some certificate authorization (either by resuming the handshake with `authorize` or aborting it with `refuse`).
  - `Handshaken`: Signals the completion of the current handshake; the application can then inspect the new epoch before proceeding.

- **write:** Takes the current state and some data, and similarly returns an `ioresult o` with different cases, e.g., `WritePartial` returns an updated state and the rest of the message, after sending its first fragment; and `MustRead` notifies the application that it should read until the ongoing handshake completes before writing again.

For instance, a client application that implements `data` as strings may interact with TLS with a (call → result) sequence as follows (with an implicit state threaded through the calls):

```plaintext
connect t g; read −→ CertQuery(q); authorize q −→ Handshaken;
write 6..30 "Hello world\n" −→ WriteComplete;
read −→ Read(0..24,"404\n"); read −→ Close(t).
```

TLS does not guarantee synchronization between input and output streams. For instance, the client may write three messages \( d0, d1, d2 \) then read \( d0 \), while the server reads \( d0 \), writes \( d1 \), then reads \( d1 \). On the other hand, when notified of a `Close` or that a new handshake is complete, our interface guarantees that all previous fragments have been received; so, the client knows that \( d2 \) was received, and the server knows that \( d1 \) was received.

#### B. TLS Security

As usual with communications protocols, the adversary is in full control of the network. This is modeled by a trivial TCP implementation, written `TCP` below, that reads and writes into buffers shared with the adversary. The application and its adversary may repeatedly set the input buffer, call the TLS interface, and read the output buffer, thereby scheduling any number of parallel connections.

Our main theorem is stated for a class of adversaries that range over restricted programs well-typed against the TLS API. Such programs include TLS applications composed with their own adversaries, and our theorem enables the automated security verification of these applications by typechecking. In addition, Section VI-C gives a corollary, stated more cryptographically as security for a class of adversaries with oracle access to functions over plain datatypes (bytes, pairs, and integers) rather than those of our API. Let \( I_i \)-DS be the dataStream interface (Fig. 3) and \( I_i \)-TLS be our main TLS interface (Fig. 4), including auxiliary interfaces such as ICert to give the adversary control over long-term key management.

**Definition 6:** A module \( C \) is TLS-secure when it is \( (I_i \)-DS, ITCP) ; I_i \)-TLS-secure for restricted users.

**Intuition:** The definition means that TLS treats data sent over connections with Safe indexes as if it were abstract—only the application is able to create and read them. Moreover, the whole streams are authenticated, interleaved with occurrences of TLS events about the handshake and alerts.

**Theorem 5 (TLS Security):** For any StAE and HS that are \( I_i \)-StAE-secure and \( I_i \)-HS-secure for restricted users, the module \( \text{StAEPlain} \cdot \text{StAE} \cdot \text{HS} \cdot \text{TLS} \) is TLS-secure.

**Proof Outline:** Recall the definition of Safe(id) as \(\text{SafeHS}(\text{SI}(id)) \land \text{Strong}(id)\); thus, indexes safe for HS and StAE are also safe with regards to our TLS implementation. The main step of the proof is by typechecking our implementation code, that is, \( I_i \)-StPlain (Lemma StPlain.tc7) and \( I_i \)-TLS (Lemmas Dispatch.tc7 and TLS.tc7, where Dispatch.fs is an auxiliary module of TLS that multiplexes between content types).

We combine Theorems 3, 4, and 5 and summarize them in cryptographic terms as follows: If the cryptographic building blocks of TLS are IND-CPA, INT-CMA, SPRP, and PRF secure for strong record cipher-suites and INT-CMA, CRE, PRF, RSA-PMS, and DH-PMS secure for strong handshake cipher-suites, then TLS is secure when used safely through our API. As illustrated by our sample applications, the safe use of our API can easily be controlled by typing.

#### C. Security for 'untyped' adversaries

Theorem 5 holds for any composition of applications and their adversaries well-typed against our TLS API. To show...