A Journey Into Fuzzing 
WebAssembly Virtual Machines 
Patrick Ventuzelo
#BHUSA  @BlackHatEvents 
#BHUSA @BlackHatEvents
Patrick Ventuzelo (@Pat_Ventuzelo)
●
Founder & CEO of FuzzingLabs | Senior Security Researcher
○
Fuzzing and vulnerability research
○
Development of security tools
●
Training/Online courses
○
Rust Security Audit & Fuzzing
○
Go Security Audit & Fuzzing
○
WebAssembly Reversing & Analysis
○
Practical Web Browser Fuzzing 
●
Main focus
○
Fuzzing, Vulnerability research
○
Rust, Golang, WebAssembly, Browsers
○
Blockchain Security, Smart contracts
●
Previously speaker at:
○
OﬀensiveCon, REcon, RingZer0, ToorCon, hack.lu, NorthSec, FIRST, etc.
2
#BHUSA @BlackHatEvents
Introduction to WebAssembly
3
#BHUSA @BlackHatEvents
What is WebAssembly?
●
Binary instruction format for a stack-based virtual machine
○
Low-level bytecode
○
Compilation target for C/C++/Rust/Go/etc.
●
Generic evolution of NaCl & Asm.js
●
W3C standard
●
MVP 1.0 (March 2017), MVP 2.0 (2022/2023)
●
Natively supported in all major browsers
●
WebAssembly goals:
○
Be fast, eﬀicient, and portable
○
Easily readable and debuggable
○
Safe (using sandboxed execution environment)
○
Open and modulable
4
#BHUSA @BlackHatEvents
How WebAssembly works?
5
Compilers
.wasm
WebAssembly
Virtual
Machine
#BHUSA @BlackHatEvents
Step 1: Compilation into WebAssembly module
6
Compilers
.wasm
WebAssembly
Virtual
Machine
Source code & Compiler toolchains
LLVM,
Emscripten,
Binaryen
#BHUSA @BlackHatEvents
WebAssembly Binary Format
7
Compilation
binary file (.wasm)
Rust
C/C++
#BHUSA @BlackHatEvents
Step 2: Execution by the WebAssembly VM
8
Compilers
.wasm
WebAssembly
Virtual
Machine
Source code & Compiler toolchains
LLVM,
Emscripten,
Binaryen
Runtime & Host environments
V8,
wasmer,
wasmtime
#BHUSA @BlackHatEvents
.wasm
WebAssembly VM - Execution stages
9
WebAssembly VM
#BHUSA @BlackHatEvents
1.
Decoding/Parsing: The binary format is parsed and converted into a module
.wasm
WebAssembly VM - Decoding/Parsing
10
WebAssembly VM
1
#BHUSA @BlackHatEvents
1.
Decoding/Parsing: The binary format is parsed and converted into a module
2.
Validation: The decoded module undergoes validation checks (such as type checking)
.wasm
WebAssembly VM - Validation
11
WebAssembly VM
1
2
#BHUSA @BlackHatEvents
1.
Decoding/Parsing: The binary format is parsed and converted into a module
2.
Validation: The decoded module undergoes validation checks (such as type checking)
3.
Instantiation: Creation of a module instance with all the context instantiated
.wasm
WebAssembly VM - Instantiation
12
WebAssembly VM
1
2
3
#BHUSA @BlackHatEvents
WebAssembly VM - Instantiation
13
Host (OS, Browser) - Shared
wasm instance (VM) - immutable
Functions
0
1
2
3
Execution 
stack
3
0
1
1
2
Indirect function table 
memories
globals
Tables
#BHUSA @BlackHatEvents
1.
Decoding/Parsing: The binary format is parsed and converted into a module
2.
Validation: The decoded module undergoes validation checks (such as type checking)
3.
Instantiation: Creation of a module instance with all the context instantiated
4.
Execution/Invocation: Exported functions are called by the host over the module instance
.wasm
WebAssembly VM - Execution/Invocation
14
WebAssembly VM
1
2
3
4
#BHUSA @BlackHatEvents
Step 2: Execution by the WebAssembly VM
15
Compilers
.wasm
WebAssembly
Virtual
Machine
Source code & Compiler toolchains
LLVM,
Emscripten,
Binaryen
Runtime & Host environments
V8,
wasmer,
wasmtime
#BHUSA @BlackHatEvents
WebAssembly VM - Use-cases
●
Standalone VM (server)
○
Edge computing
○
Back-end apps
■
Nodejs
○
Mobile & Desktop apps
○
IoT & Embedded OS
○
Blockchain
■
Polkadot, Substrate, Cosmos, NEAR
■
Spacemesh, Golem, EOS, DFINITY
●
Browser (client)
○
Video, Audio & Image processing
○
Videos Games
○
Complexe web apps
■
Autocad, Google Earth
■
Photoshop, Shopify, Figma
○
OS Emulation
16
#BHUSA @BlackHatEvents
Focus of this talk: WebAssembly VM
17
Compilers
.wasm
WebAssembly
Virtual
Machine
Runtime & Host environments
Source code & Compiler toolchains
#BHUSA @BlackHatEvents
1.
Decoding/Parsing: The binary format is parsed and converted into a module
2.
Validation: The decoded module undergoes validation checks (such as type checking)
3.
Instantiation: Creation of a module instance with all the context instantiated
4.
Execution/Invocation: Exported functions are called by the host over the module instance
.wasm
Goal: Find bugs on every stage on diﬀerent VMs!
18
WebAssembly VM
1
2
3
4
#BHUSA @BlackHatEvents
1. Coverage-guided fuzzing
19
#BHUSA @BlackHatEvents
●
Coverage-guided fuzzing
○
Observe how inputs are processed to learn which mutations are interesting.
○
Save inputs to be re-used and mutated in future iterations.
Fuzzing strategy: Coverage-guided fuzzing
20
Crashes
Mutation
Corpus
.wasm
Fuzzer
Monitoring
.wasm
.wasm
.wasm
Coverage
Target
WebAssembly
Virtual
Machine
#BHUSA @BlackHatEvents
Input: WebAssembly Binary Format
●
Module structure
○
Header: magic number + version
○
11 Sections: may appear at most once
○
1 custom section: unlimited
21
#BHUSA @BlackHatEvents
Targets: Standalone VMs & parsing libraries
22
●
Targets (C/C++)
○
Binaryen: Compiler and toolchain libraries
○
WABT: The WebAssembly Binary Toolkit
○
Wasm3: WebAssembly interpreter
○
WAMR: WebAssembly Micro Runtime
○
WAC: WebAssembly interpreter in C
○
Radare2: Reverse engineering framework
○
Etc. 
#BHUSA @BlackHatEvents
C/C++ Coverage-guided Fuzzing
●
C/C++ Fuzzers
○
AFL: american fuzzy lop
○
Honggfuzz: Feedback-driven/evolutionary fuzzer
○
AFL++: AFL with community patches
●
Complexity: None
○
Instrumentation using custom gcc/clang
○
Overwrite CC or CXX flags
○
Prefered AFL++ instead of vanilla AFL
23
#BHUSA @BlackHatEvents
Results: ~46 bugs/vulnerabilities
●
Binaryen
○
Out-of-bound read  - issue
●
WABT
○
Assertion errors - issue#1, issue#2, issue#3, issue#4
○
Uncontrolled memory allocation - issue
●
WAMR
○
Null pointer dereference - issues (5)
○
Heap out of bounds read - issues (29)
○
Assertion errors - issue#1, issue#2
○
Heap out of bounds write - issue
○
Segmentation fault - issue
●
Radare2
○
Heap out of bounds read - issue
○
Heap out of bounds read - issue
24
#BHUSA @BlackHatEvents
●
Reusing corpora between all targets
Fuzzing strategy: Improvements #1
25
Mutation
.wasm
Fuzzers
Monitoring
.wasm
.wasm
.wasm
Coverage
Targets
WABT
Binaryen
wasm3
…
Crashes
Corpus
#BHUSA @BlackHatEvents
●
Reusing corpora between all targets
●
Add crashing files inside the existing corpus
○
It might make crash some other targets
Fuzzing strategy: Improvements #1
26
Mutation
.wasm
Fuzzers
Monitoring
.wasm
.wasm
.wasm
Coverage
Targets
WABT
Binaryen
wasm3
…
Crashes
Corpus
#BHUSA @BlackHatEvents
2. In-process fuzzing
27
#BHUSA @BlackHatEvents
●
In-Process fuzzing
○
Fuzz a specific entry point of the program in only one dedicated process
○
For every test case, the process isn't restarted but the values are changed in memory.
Fuzzers
Fuzzing strategy: In-process fuzzing
28
Mutation
.wasm
Monitoring
.wasm
.wasm
.wasm
pywasm
Coverage
…
Crashes
Corpus
wasmtime
wasmer
#BHUSA @BlackHatEvents
Targets: Standalone VMs & parsing libraries
29
●
Targets (Rust)
○
Wasmer: WebAssembly Runtime supporting WASI and Emscripten
○
Wasmtime: A standalone runtime for WebAssembly
○
wain: WebAssembly interpreter written in Rust from scratch
○
Wasmparser: Decoding/parsing library of wasm binary files
○
wasmi: WebAssembly (Wasm) interpreter.
○
Cranelift: JIT compiler for wasm
○
Lucet: Sandboxing WebAssembly Compiler
○
Etc. 
●
Targets
○
pywasm: A WebAssembly interpreter written in pure Python
○
webassemblyjs: JavaScript Toolchain for WebAssembly
#BHUSA @BlackHatEvents
Rust In-process fuzzing
●
Rust Fuzzers
○
cargofuzz: A cargo subcommand for fuzzing with libFuzzer
○
honggfuzz-rs: Fuzz your Rust code with Honggfuzz!
○
afl.rs: Fuzzing Rust code with AFLplusplus
●
Complexity: Low
○
You need to write some fuzzing harnesses
○
honggfuzz-rs is my favorite (faster and better interface)
○
New fuzzer cargo-libafl is promising
30
#BHUSA @BlackHatEvents
Python/JS In-process fuzzing
●
Fuzzers
○
Atheris: Coverage-guided Python fuzzing engine based on Libfuzzer
○
jsfuzz: Coverage-guided fuzzer for javascript/nodejs packages
●
Complexity: Low
○
You need to write some fuzzing harnesses
○
Learn how to use diﬀerent fuzzing frameworks
31
#BHUSA @BlackHatEvents
Results: ~62 bugs/vulnerabilities
●
Results
○
Wasmer - issues (22)
○
Cranelift - issues (2)
○
Wasmparser - issues (3)
○
Wasmtime - issues (17)
○
wain - issues (4)
○
lucet - issues (2)
○
Pywasm - not reported (10)
○
webassemblyjs - issue
●
Type of bugs found
○
Panicking macros
○
Index out of bound panic