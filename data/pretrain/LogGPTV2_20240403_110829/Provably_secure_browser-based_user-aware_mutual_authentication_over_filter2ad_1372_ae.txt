### Protocol Specification and Adversary Success Conditions

According to the protocol specification, U (the user) accepts after recognizing the authenticator \( w \). The adversary succeeds only if B (the browser) has received a `Send` query containing a message of the form \( E|F \), which has not been previously returned by S (the server). The decryption of \( F \) yields \( (w'|\mu_S) \), and the rendering of \( w' \) results in acceptance by U. After excluding forgeries of \( \mu_S \) in Game G17, we conclude that the success probability of A (the adversary) is conditioned by the occurrence of `InjCert` (by which A learns \( k_1 \) and \( k_2 \)) and is given by the probability of A finding some authenticator \( w \in W \), excluding the subset of human-indistinguishable authenticators \( W^* \) that will be visualized to U. The success probability of A in finding such a Human-Perceptible Authenticator (HPA) depends on the size of \( W^* \). This is a critical point in our security analysis of BBMA, where human skills in distinguishing authenticators become important. We derive:

\[
| \Pr[\text{Win21}] - \Pr[\text{Win20}] | \leq q \frac{|W|}{|W^*|}
\]

This excludes attacks resulting in the impersonation of the server towards the user. Therefore, A wins in this game if there is a server instance that accepts but no partnered client instance, i.e., if the second condition from Definition 3 is satisfied. Note that S accepts only after verifying the authenticity of \( \mu_C \) and ensuring that the decrypted password \( pw' \) matches the one shared with U. Having excluded replays and forgeries of \( \mu_C \) in Games G19 and G20, it follows that there must be a client instance that sends this message. This also implies that the mentioned client instance should use the same session ID as the server instance; otherwise, the server instance would have aborted upon verifying the client's signature \( \sigma_C \). Hence, \( \Pr[\text{Win21}] = 0 \).

### Realization of BBMA

In our realization of BBMA, the TLS protocol is first executed in bilateral authentication mode to establish a secure channel. Then, `HumanAuth` and `HumanResponse` messages are exchanged. `HumanAuth` contains the authenticated and encrypted human authenticator, while `HumanResponse` contains the authenticated and encrypted user password. Thus, the authenticator and password are protected by message authentication and encryption mechanisms using the keys provided by the TLS record layer. The flexibility in choosing the higher-order protocol makes this realization particularly interesting. Processing and displaying the authenticator are modular and outsourced to the web application, allowing the use of personally tailored authenticators. By "personal," we mean the way in which the authenticators are presented to the user. Since technically sophisticated users might opt for classical web authentication, our realization allows downgrading to TLS in server authentication mode only.

We used HTTP over TLS in client authentication mode, executing a standalone web application (to avoid cross-site scripting attacks) written in PHP. To avoid performance penalties for servers with large-scale penetration, a TLS accelerator may be used. The protocol consists of two stages: the registration stage and the login stage. In the registration stage, the user selects an image and generates a client certificate as defined in PKCS#10. In the login stage, the image is displayed while the user is prompted to enter a password into a web form. A demonstration is available at [32].

As with any password-based key exchange protocol, we assume there is no (active) adversary intercepting the setup of credentials. During the setup phase, the protocol is vulnerable to man-in-the-middle attacks. When the user requests the website (Fig. 2), they can opt for registration. The server may test if a client certificate is present in the browser by sending a `CertificateRequest` message. The user then enters an email address, username, and password, and uploads an image.

If no client certificate is stored in the browser, the server triggers the generation of a public key pair and a PKCS#10 certificate signing request. Upon receiving the PKCS#10 request, the server issues a certificate. Since the server is the issuer, no third party is required. The certificate is provided with attributes chosen by the server to relieve the user from filling out security parameters. Finally, the server displays a link where the user can download the client certificate. The client certificate’s fingerprint, along with the credentials, is stored in the server’s database and used to identify the user in the login stage. The overhead to install the client certificate is minimal, with modern browsers providing an easy-to-use interface. For example, in the current release of Firefox, the user simply clicks a link to store the certificate, requiring no further interaction.

Upon requesting the login page (Fig. 2), the server checks that the browser possesses a valid client certificate as specified by TLS (`CertificateRequest`). It then displays the corresponding image above the login form (`HumanAuth`); otherwise, the protocol halts, and the user is prevented from seeing the login page (and the authenticator). To access the site, the user must enter their username and password (`HumanResponse`). The `HumanAuth` and `HumanResponse` messages are authenticated and encrypted by the TLS record layer. However, TLS-protected messages are secured only while in transit on the network. After reception, the message plaintext, as recovered by the record layer, is forwarded to the browser, where it can persist in the cache. To prevent the adversary from revealing cache information and disclosing the HPA, we set up the server using the HTTP `cache-response-directive` [20, Sect. 14.9.2] so that the browser avoids caching the `HumanAuth` message.

### Conclusion

User authentication on the web is essential and subject to various attacks. We have introduced and analyzed a browser-based authentication protocol that makes the weakest assumptions about users’ skills, requiring them to detect a human-perceptible authenticator. The protocol is specifically designed for users who are security-unaware and accustomed to evaluating websites through easily recognizable indicators. It remains an open question whether all users can detect the human-perceptible authenticator, which requires usability experiments to specify the choice of "good" authenticators and keep human fuzziness low. The presented protocol takes initial steps toward bridging the gap between protocols that are provably secure, interfaced to error-prone users, and implementable within the design constraints of standard browsers.

Interesting approaches to make BBMA more lightweight include the automatic generation of self-signed X.509 certificates in the browser or modifications to the mature browser security model that allow for securely handling cookies. Another challenge is developing a cryptographic compiler that composes browser-based protocols in a general and provably secure manner. A final issue is modeling alternative human skills, such as the ability to solve human-hard puzzles (e.g., CAPTCHAs). Recent work by Canetti, Halevi, and Steiner [14] has made initial progress in formally treating the solving of such puzzles.

### Acknowledgment

This work was partially supported by the European Commission under contract IST-2002-507932 through the ECRYPT Network of Excellence.

### References

[References listed as provided, with proper formatting and citation.]

---

This optimized version aims to improve clarity, coherence, and professionalism while maintaining the technical details and structure of the original text.