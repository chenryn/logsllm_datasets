title:Key Confirmation in Key Exchange: A Formal Treatment and Implications
for TLS 1.3
author:Marc Fischlin and
Felix G&quot;unther and
Benedikt Schmidt and
Bogdan Warinschi
2016 IEEE Symposium on Security and Privacy
2016 IEEE Symposium on Security and Privacy
Key Conﬁrmation in Key Exchange:
A Formal Treatment and Implications for TLS 1.3
Marc Fischlin
Felix Günther
Cryptoplexity, Technische Universität Darmstadt
Darmstadt, Germany
Benedikt Schmidt
IMDEA Software Institute
Madrid, Spain
Bogdan Warinschi
University of Bristol
Bristol, UK
marc.ﬁPI:EMAIL, PI:EMAIL
PI:EMAIL
PI:EMAIL
Abstract—Key exchange protocols allow two parties at remote
locations to compute a shared secret key. The common security
notions for such protocols are secrecy and authenticity, but
many widely deployed protocols and standards name another
property, called key conﬁrmation, as a major design goal. This
property should guarantee that a party in the key exchange
protocol is assured that another party also holds the shared
key. Remarkably, while secrecy and authenticity deﬁnitions have
been studied extensively, key conﬁrmation has been treated rather
informally so far.
In this work, we provide the ﬁrst rigorous formalization of
key conﬁrmation, leveraging the game-based security framework
well-established for secrecy and authentication notions for key
exchange. We deﬁne two ﬂavors of key conﬁrmation, full and
almost-full key conﬁrmation, taking into account the inevitable
asymmetry of
to the
transmission of the ﬁnal protocol message. These notions capture
the strongest level of key conﬁrmation reasonably expectable for
the two communication partners of the key exchange.
the parties with respect
the roles of
We demonstrate the beneﬁts of having precise security deﬁni-
tions for key-conﬁrmation by applying them to the next version
of the Transport Layer Security (TLS) protocol, version 1.3,
currently developed by the Internet Engineering Task Force
(IETF). Our analysis shows that the full handshake as speciﬁed
in the TLS 1.3 draft draft-ietf-tls-tls13-10 achieves
desirable notions of key conﬁrmation for both clients and servers.
While key conﬁrmation is generally understood and in the
TLS 1.3 draft described as being obtained from the Finished
messages exchanged,
interestingly we can show that the full
TLS 1.3 handshake provides key conﬁrmation even without those
messages, shedding a formal
light on the security properties
different handshake messages entail.
We further demonstrate the usefulness of rigorous deﬁnition
by revisiting a folklore approach to establish key conﬁrmation
(as discussed for example in SP 800-56A of NIST). We provide a
formalization as a generic protocol transformation and show that
the resulting protocols enjoy strong key conﬁrmation guarantees,
thus conﬁrming its beneﬁcial use in both theoretical and practical
protocol designs.
I. INTRODUCTION
Key exchange is one of most widely deployed cryptographic
protocols to date, bootstrapping conﬁdential and authenticated
data exchange in virtually any secure communication protocol.
The most basic security properties are key secrecy and entity
authentication: the former property guarantees that no other
party learns information about
the key whereas the later
ensures that the key is shared with the intended partner. The
seminal work of Bellare and Rogaway [4] provided rigorous
2375-1207/16 $31.00 © 2016 IEEE
© 2016, Marc Fischlin. Under license to IEEE.
DOI 10.1109/SP.2016.34
DOI 10.1109/SP.2016.34
452
452
security deﬁnitions for these two notions and thus grounded
the design and analysis of such protocols on solid foundations.
The huge body of follow-up work reﬁned, extended, and ap-
plied their results. These include extensions to the asymmetric
setting [8], more reﬁned attacker models [14], dealing with
different variants of entity authentication [28], etc. There is
also a large body of work, e.g., [22], [24], [7], [5], [18],
applying and extending these results to real-world security
protocols such as TLS [17] or SSH [32].
A. Key Conﬁrmation
An intuitively desirable security property that has so far
escaped a rigorous treatment is key conﬁrmation: the idea that
when a party accepts locally a key, it has the guarantee that
some other party has precisely the same key. The property
is often mentioned in scientiﬁc papers on the subject of
key exchange [3], [23], [25] but the typical reference for a
deﬁnition is the “Handbook of Applied Cryptography” [27,
Deﬁnition 12.7] which describes key conﬁrmation as the
property
“whereby one party is assured that a second
(possibly unidentiﬁed) party actually has possession
of a particular secret key.”
Other references include the reﬁnement proposed by Blake-
Wilson and Menezes [9], [10] who further distinguish between
explicit key conﬁrmation, where one party is assured that the
other party holds the key, and implicit key conﬁrmation, where
the other party can compute the key.
One may speculate that the reason for a lack of rigorous
deﬁnitions is that absence of key conﬁrmation does not seem to
open parties to attacks: a party may send messages encrypted
with an (unconﬁrmed) key which no-one can decrypt. This
may be a waste of resources but not an obvious security
risk. Another possibility is that it might seem “clear” when a
protocol has key conﬁrmation, so a formal deﬁnition appears
to be an overkill. For example, protocols like TLS 1.2 [17]
and EMV [20] utilize the derived key during the execution
of the protocol, so receiving a a message encrypted with the
shared key provides key-conﬁrmation assurances.
This level of informal understanding is also reﬂected by
other folklore protocol transformations that can boost a se-
cure key exchange protocol to also provide key conﬁrmation
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:58 UTC from IEEE Xplore.  Restrictions apply. 
guarantees. A popular proposal (which we refer to as “refresh-
then-MAC”) is to extend a key exchange protocol as follows:
use the established key ﬁrst to derive two additional keys; the
ﬁrst will be set as the session key whereas the latter will be
used to compute a message authentication code (MAC) value
over the transcript of the protocol so far. Exchanging valid
MACs should then guarantee that parties have also locally
computed the associated session key.
The status of key conﬁrmation as an important security
property is still unclear. On the one hand, some practition-
ers seem to be convinced that key conﬁrmation messages
(messages that use the key derived to ensure that the parties
have agreed on the same key) do improve authentication1, yet
others struggle to understand the beneﬁts that key conﬁrmation
messages bring to protocols2. Nevertheless, many security
protocol speciﬁcations name key conﬁrmation as an explicit
goal to achieve, including, e.g., the recommendations for key
establishment schemes by NIST [2], [1], [21], or the draft
speciﬁcations for the next TLS version 1.3 [29].
This paper is motivated by the observation that any serious
discussion of this issue is moot in the absence of clear security
deﬁnitions and that such deﬁnitions should also ground design
decisions and security analysis which nowadays simply rely on
the type of lore outlined above. To support the argument, note
that the recommendation of NIST concerning key conﬁrmation
in [2], [1] basically follows the informal deﬁnition above,
ignoring that one of the protocol participants must accept ﬁrst
and thus gets a different strength of conﬁrmation guarantee
than the one accepting last.
B. Our Results
SECURITY DEFINITIONS. We propose security deﬁnitions (in
Section III) that aim to capture the established intuition behind
key conﬁrmation. First, we note that we do not attempt to
distinguish between explicit and implicit key conﬁrmation:
distinct computational interpretation to “has the key” and “can
compute the key” seem difﬁcult to provide. This follows the
line of reasoning by Blake-Wilson and Menezes [9] who argue
that “for all practical purposes, the assurances [of implicit and
explicit key conﬁrmation] are in fact the same,” especially
since one cannot guarantee that a party forgets a key between
its derivation and its ﬁrst time usage.
Second, it is clear that key conﬁrmation guarantees are
asymmetric: the party that receives the last message obtains the
stronger guarantees; such guarantees do not hold for the party
that sends the last message since the message can be dropped
by an adversary. Accordingly, we distinguish between full
key conﬁrmation and almost-full key conﬁrmation. The former
property guarantees that when a party accepts a key, there
exists some other party that has already accepted precisely
that key. The latter property ensures that when a party accepts
1Adam Langley publicly proclaimed at
the Real World Cryptography
Workshop (RWC) 2014: “Key-conﬁrmation messages are here to stay.” [26]
2See the discussion on the TLS mailing list [31] on removing the conﬁr-
mation message from the design of TLS.
a key, there is some session which, if it accepts, then it accepts
the same key. Formalizing sound key conﬁrmation notions
turns out to be more challenging than one might expect given
the common informal understanding: As we explain later in the
paper, although we rely on compelling intuition, the deﬁnitions
need to be carefully crafted to avoid some potential pitfalls
which we outline.
A prime feature of our deﬁnitions is modularity. Following
Blake-Wilson and Menezes [9] as well as NIST [2], [1], we
chose to disentangle key conﬁrmation from the other security
concerns speciﬁc to key exchange. In particular, our notion
only ensures that there exists some party that accepted the
same key: the notion does not guarantee that it is the expected
communication partner. However, the desired property follows
by combining key conﬁrmation and implicit key authentication
(i.e., classical key secrecy with mutually authenticating par-
ties [4]): a protocol with both these properties has explicit key
authentication. Informally, key conﬁrmation can be interpreted
as guaranteeing the lower bound that “at
least one other
(unspeciﬁed) party holds the key” whereas implicit key au-
thentication ensures the upper bound that “at most one (namely
the expected) party holds the key.” Together, the notions entail
explicit key authentication: “exactly the expected party holds
the key.” Note that the deﬁnitional modularity also allows us
to “swap” the key conﬁrmation steps and property in and out,
depending on the protocol’s security requirements (as in the
recommendations of NIST), and to independently argue about
this additional security feature.
the
security
APPLICATION TO TLS. We use the rigorous
that we develop to shed light on the key-
models
recent TLS 1.3 draft
conﬁrmation properties of
draft-ietf-tls-tls13-10 [29] (short: draft-10) in
Section IV. As in previous TLS versions, TLS 1.3 draft-10
leverages Finished messages essentially consisting of a mes-
sage authentication code (MAC) computed over the transcript
of the key exchange and sent both by the client and the server.
It is hence not surprising that our analysis conﬁrms that (the
full, (EC)DHE handshake of) TLS 1.3 indeed achieves the
strongest expectable key conﬁrmation guarantees, i.e., full key
conﬁrmation for the server (which accepts after the client)
and almost-full key conﬁrmation for the client (which accepts
ﬁrst).
Perhaps surprisingly, we show that key conﬁrmation does
not (necessarily) rely on the Finished messages exchanged,
but can actually be shown to hold even in a shortened variant
of the full draft-10 handshake which omits these mes-
sages. This becomes possible due to the CertificateVerify
messages sent in the full draft-10 handshake, which are
essentially an online signature under the parties’ long-term
secret signing keys over (the hash of) all messages exchanged
(i.e., the transcript or “session hash”, as denoted in TLS 1.3).
This result deepens the understanding of the far-reaching
security guarantees achievable with the session hash con-
cept (originally introduced to counter the triple handshake
attack [6]
in TLS 1.2) and online signatures. While it
453453
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:58 UTC from IEEE Xplore.  Restrictions apply. 
might at ﬁrst glance seem to open up a discussion of
whether Finished messages become obsolete in presence
of CertificateVerify messages already establishing key
conﬁrmation, we remark that TLS 1.3 draft-10 provi-
sions further, abbreviated handshake variants which omit the
CertificateVerify messages for performance reasons and
fully rely on the Finished messages for key conﬁrmation as
well as authentication.
GENERIC CONSTRUCTION. As explained above, one idea used
to obtain key conﬁrmation deployed in existing protocols is to
somehow explicitly involve the key in the operations of the
key-exchange protocol. This message plays a double role: on
the one hand the MAC “ties” together the messages that belong
to one session. On the other hand, the message is sent over
the channel that is being established, or in other words, it is
encrypted with the session key: receiving this message would
therefore show that the other party already holds the key.
It is by now well-known that unmitigated use of the session
key (for either encrypting or MAC-ing) immediately destroys
key secrecy, and better transformations have been proposed
and used in protocol design. For example, Chen and Kudla
study the impact that such a transformation has on a particular
protocol, but still need to rely on intuition to conclude that the
resulting protocol satisﬁes key conﬁrmation [15]. With precise
deﬁnitions in place, we are in a position where these proposals
can be accurately analyzed.
We deploy our rigorous notions to analyze the popular
“refresh-then-MAC” transformation (also recommended by
NIST [2], [21]) and conﬁrm that the intuition behind the
construction is indeed correct: when applied to a key-exchange
protocol that ensures key secrecy the transformation yields
a protocol which, in addition, also satisﬁes key conﬁrmation
(and preserves (implicit) authentication). Interestingly, as a by-
product of our formalism, we can now also show that the
simpler version where one sends some additionally derived
key material in clear, without computing a MAC, would serve
the same purpose and already provide key conﬁrmation.
II. KEY EXCHANGE PROTOCOLS AND THEIR SECURITY
In this section we deﬁne key exchange protocols and
their security, following essentially the approach of Bellare
and Rogaway [4]. We recall the basic security properties of
key secrecy, i.e., that session keys look random, and Match
security as deﬁned in [13], [12], which guarantees soundness
of session partnering (e.g., that a successful session has a
unique partner session).
In the model we will
introduce the notion of a key-
conﬁrmation identiﬁer kcid, pivotal for our formalization
of almost-full key conﬁrmation. Essentially, once set,
the
identiﬁer kcid ensures that the party will eventually derive
the same key as any other party with that identiﬁer, even
though the party has not accepted and the session identiﬁer
sid has not been set yet. In other words, one may interpret
the setting of the key-conﬁrmation identiﬁer as stating that,
upon receiving the partner’s conﬁrmation message, a session
will have enough information to compute the (same) key. We
elaborate on the choices for setting key-conﬁrmation identiﬁers
in a protocol further when introducing the notion of almost-
full key conﬁrmation that relies on them.
A. Protocol Syntax
We consider two-party protocols where participating parties
belong to either a set of clients C or a set of servers S. Each set
has associated a long-term key generation algorithm KGclient
resp. KGserver (one of these algorithms can be trivial, for the
case when a set of parties does not have long term keys). We
let I = C ∪ S denote the set of all identities in the system.
Our focus is on key exchange protocols which are deﬁned
by an (interactive) program Π that parties execute locally.
the program maintains a state st =
Between invocations,
(crypt, status, role, id, pid, sid, kcid, key), where the different
components are as follows:
• crypt ∈ {0, 1}∗ is some protocol-speciﬁc state, e.g.,
secret Difﬁe-Hellman values. It will be set to the par-
ticipants cryptographic keys upon initialization.
• status ∈ {accept, reject,⊥} is a variable that indicates
the status of the key-exchange phase. Initially, status =⊥
and may change to accept in accepted executions, or
reject in runs in which the party rejects. We assume
that once the status has been set to accept or reject,
the value does not change anymore and the adversary
immediately learns the value of status.
• role ∈ {client, server} is the role of the participant.