title:MUST, SHOULD, DON'T CARE: TCP Conformance in the Wild
author:Mike Kosek and
Leo Bl&quot;ocher and
Jan R&quot;uth and
Torsten Zimmermann and
Oliver Hohlfeld
MUST, SHOULD, DON’T CARE: TCP
Conformance in the Wild
Mike Kosek1(B)
, Leo Bl¨ocher1, Jan R¨uth1
and Oliver Hohlfeld2
, Torsten Zimmermann1,
1 Communication and Distributed Systems, RWTH Aachen University,
{kosek,bloecher,rueth,zimmermann}@comsys.rwth-aachen.de
Aachen, Germany
2 Chair of Computer Networks, Brandenburg University of Technology,
Cottbus, Germany
PI:EMAIL
Abstract. Standards govern the SHOULD and MUST requirements for
protocol implementers for interoperability. In case of TCP that carries
the bulk of the Internets’ traﬃc, these requirements are deﬁned in RFCs.
While it is known that not all optional features are implemented and
non-conformance exists, one would assume that TCP implementations
at least conform to the minimum set of MUST requirements. In this
paper, we use Internet-wide scans to show how Internet hosts and paths
conform to these basic requirements. We uncover a non-negligible set
of hosts and paths that do not adhere to even basic requirements. For
example, we observe hosts that do not correctly handle checksums and
cases of middlebox interference for TCP options. We identify hosts that
drop packets when the urgent pointer is set or simply crash. Our publicly
available results highlight that conformance to even fundamental proto-
col requirements should not be taken for granted but instead checked
regularly.
1 Introduction
Reliable, interoperable, and secure Internet communication largely depends on
the adherence to standards deﬁned in RFCs. These RFCs are simple text doc-
uments, and any speciﬁcations published within them are inherently informal,
ﬂexible, and up for interpretation, despite the usage of keywords indicating the
requirement levels [20], e.g., SHOULD or MUST. It is therefore expected and
known that violations—and thus non-conformance—do arise unwillingly. Never-
theless, it can be assumed that Internet hosts widely respect at least a minimal
set of mandatory requirements. To which degree this is the case is, however,
unknown.
In this paper, we shed light on this question by performing Internet-wide
active scans to probe if Internet hosts and paths are conformant to a set of
minimum TCP requirements that any TCP speaker MUST implement. This
adherence to the fundamental protocol principles is especially important since
c(cid:2) Springer Nature Switzerland AG 2020
A. Sperotto et al. (Eds.): PAM 2020, LNCS 12048, pp. 122–138, 2020.
https://doi.org/10.1007/978-3-030-44081-7_8
MUST, SHOULD, DON’T CARE: TCP Conformance in the Wild
123
TCP carries the bulk of the data transmission in the Internet. The basic require-
ments of a TCP host are deﬁned in RFC 793 [47]—the core TCP speciﬁcation.
Since its over 40 years of existence, it has accumulated over 25 accepted errata
described in RFC 793bis-Draft14 [27], which is a draft of a planned future update
of the TCP speciﬁcation, incorporating all minor changes and errata to RFC 793.
We base our selection of probed requirements on formalized MUST requirements
deﬁned in this drafted update to RFC 793.
The relevance of TCP in the Internet is reﬂected in the number of studies
assessing its properties and conformance. Well studied are the interoperability of
TCP extensions [21], or within special purpose scenarios [40,41], and especially
non-conformance introduced by middleboxes on the path [24,35]. However, the
conformance to basic mandatory TCP features has not been studied in the wild.
We close this gap by studying to which degree TCP implementations in the wild
conform to MUST requirements. Non-conformance to these requirements limits
interoperability, extensibility, performance, or security properties, leading to the
essential necessity to understand who does not adhere to which level of non-
conformance. Uncovering occurrences of non-conformities hence reveal areas of
improvement for future standards. A recent example is QUIC, where eﬀort is
put into the avoidance of such misconceptions during standardization [46].
With our large scale measurement campaign presented in this paper, we show
that while the majority of end-to-end connections are indeed conforming to the
tested requirements, a non-trivial number of end-hosts as well as end-to-end
paths show non-conformities, breaking current and future TCP extensions, and
even voiding interoperability thus reducing connectivity. We show that
(cid:2) In a controlled lab study, non-conformance already exists at the OS-level:
only two tested stacks (Linux and lwIP) pass all tests, where, surprisingly,
others (including macOS and Windows) fail in at least one category each.
Observing non-conformance in the wild can therefore be expected.
(cid:2) In the wild, we indeed found a non-negligible amount of non-conformant hosts.
For example, checksums are not veriﬁed in ∼3.5% cases, and middleboxes
inject non-conformant MSS values. Worrisome, using reserved ﬂags or setting
the urgent pointer can render the target host unreachable.
(cid:2) At a infrastructure level, 4.8% of the Alexa domains with and without www.
preﬁx show diﬀerent conformance levels (e.g., because of diﬀerent infrastruc-
tures: CDN vs. origin server), mostly due to ﬂags that limit reachability. The
reachability of websites can thus depend on the www. preﬁx.
Structure. In Sect. 2 we present related work followed by our methodology and
its validation in Sect. 3. The design and evaluation of our Internet-wide TCP
conformance scans are discussed in Sect. 4 before we conclude the paper.
2 Related Work
Multiple measurement approaches have focused on the conformance of TCP
implementations on servers, the presence of middleboxes and their interference
124
M. Kosek et al.
on TCP connections, and non-standard conform behavior. In the following, we
discuss similarities and diﬀerences of selected approaches to our work.
TCP Stack Behavior. One line of research aims at characterizing remote
TCP stacks by their behavior (e.g., realized in the TCP Behavior Inference Tool
(TBIT) [45] in 2001). One aspect is to study the deployment of TCP tunings (e.g.,
the initial window conﬁguration [48–50]) or TCP extensions (e.g., Fast Retrans-
mit [45], Fast Open [39,44], Selective Acknowledgment (SACK) [36,43,45], or
Explicit Congestion Notiﬁcation (ECN) [18,36,37,42,43,45] and ECN++ [38] to
name a few). While these works aim to generally characterize stacks by behav-
ior and to study the availability and deployability of TCP extensions, our work
speciﬁcally focuses on the conformance of current TCP stacks to mandatory
behavior every stack must implement. A second aspect concerns the usage of
behavioral characterizations to ﬁngerprint TCP stacks (e.g., via active [30] or
passive [19] measurements) and mechanisms to defeat ﬁngerprinting (e.g., [53]).
Middlebox Interference. The end-to-end behavior of TCP not only depends
on the stack implementations, but also on on-path middleboxes [22], which can
tune TCP performance and security but also (negatively) impact protocol mech-
anisms and extensions (see e.g., [18,42,43]). Given their relevance, a large body
of work studies the impact within the last two decades and opens the question
if TCP is still extensible in today’s Internet. Answering this question resulted in
a methodology for middlebox inference which is extended by multiple works
to provide middlebox detection tools to assess their inﬂuence; By observing
the diﬀerences between sent and received TCP options at controlled endpoints
(TCPExposure [32]), it is observed that 25% of the studied paths tamper with
TCP options, e.g., with TCP’s SACK mechanism. Similarly, tracebox [24] also
identiﬁes middleboxes based on modiﬁcations of TCP options, but as client-
side only approach without requiring server control. Besides also identifying the
issues with TCP’s SACK option, they highlight the interference with TCP’s
MSS option and the incorrect behavior of TCP implementations when prob-
ing for MPTCP support. PATHSpider [35] extends tracebox to test more TCP
options, e.g., ECN or diﬀerentiated services code point (DSCP). They evaluate
their tool in an ECN support study, highlighting that some intermediaries tam-
per with the respective options, making a global ECN deployment a challenging
task. Further investigating how middleboxes harm TCP traﬃc, a tracebox-based
study [28] shows that more than a third of all studied paths cross at least one
middlebox, and that on over 6% of these paths TCP traﬃc is harmed. Given
the negative inﬂuence of transparent middleboxes, proposals enable endpoints
to identify and negotiate with middleboxes using a new TCP option [34] and to
generally cooperate with middleboxes [23]. While we focus on assessing TCP con-
formance to mandatory behavior, we follow tracebox’s approach to diﬀerentiate
non-conforming stacks from middlebox interference causing non-conformity.
Takeaway: While a large body of work already investigates TCP behavior and
middlebox inference, a focus on conformance to mandatory functionality required
to implement is missing—a gap that we address in this study.
MUST, SHOULD, DON’T CARE: TCP Conformance in the Wild
125
3 Methodology
We test TCP conformance by performing active measurements that probe for
mandatory TCP features and check adherence to the RFC. We begin by explain-
ing how we detect middleboxes before we deﬁne the test cases and then validate
our methodology in controlled testbed experiments.
3.1 Middlebox Detection
Middleboxes can alter TCP header information and thereby cause non-
conformance, which we would wrongly attribute to the probed host without
performing a middlebox detection. Therefore, we use the tracebox approach [24]
to detect interfering middleboxes by sending and repeating our probes with
increasing IP TTLs. That is, in every test case (see Sect. 3.2), the ﬁrst segment
is sent multiple times with increasing TTL values from 1 to 30 in parallel while
capturing ICMP time exceeded messages. We limit the TTL to 30 since we did
not observe higher hop counts in our prior work for Internet-wide scans [51].
To distinguish the replied messages and determine the hop count, we encode
the TTL in the IPv4 ID and in the TCP acknowledgment number, window
size, and urgent pointer ﬁelds. We chose to encode the TTL in multiple header
ﬁelds since middleboxes could alter every single one. These repetitions enable us
to pinpoint and detect (non-)conformance within the end-to-end path if ICMP
messages are issued by the intermediaries quoting the expired segment. Please
note that alteration or removal of some of our encodings does not render the
path or the speciﬁc hop non-conformant. A non-conformance is only attested,
if the actual tested behavior was modiﬁed as visible through the expired seg-
ment. Further, since only parts of the ﬁelds—all 16 or 32 bits in size—may be
altered by middleboxes (e.g., slight changes to the window size), we repeat each
value as often as possible within every ﬁeld. Our TTL value of at most 30 can
be encoded in 5 bits, and thus be repeated 3 to 6 times in the selected ﬁelds.
Additionally, the TCP header option No-Operation (NOOP) allows an opaque
encoding of the TTL. Speciﬁcally, we append as many NOOPs as there are hops
in the TTL to the ﬁxed-size header. Other header ﬁelds are either utilized for
routing decisions (e.g., port numbers in load balancers) or are not opaque (e.g.,
sequence numbers), rendering them unsuitable. Depending on the speciﬁc test
case, some of the ﬁelds are not used for the TTL encoding. For example, when
testing for urgent pointer adherence, we do not encode the TTL in the urgent
pointer ﬁeld.
3.2 TCP Conformance Test Cases
Our test cases check for observable TCP conformance of end-to-end connections
by actively probing for a set of minimum requirements that any TCP must imple-
ment. We base our selection on 119 explicitly numbered requirements speciﬁed
in RFC 793bis-Draft14 [27], of which 69 are absolute requirements (i.e., MUSTs
[20]). These MUSTs resemble minimum requirements for any TCP connection
126
M. Kosek et al.
participating in the Internet—not only for hosts, but also for intermediate ele-
ments within the traversed path. The majority of these 69 MUSTs address inter-
nal state-handling details, and can therefore not be observed or veriﬁed via active
probing. To enable an Internet-wide assessment of TCP conformance, we thus
focus on MUST requirements whose adherence is observable by communicating
with the remote host. We synthesize eight tests from these requirements, which
we summarize in Table 1, and discuss them in the following paragraphs. Each test
is in some way critical to interoperability, security, performance, or extensibility
of TCP. The complexity involved in verifying conformance to other advanced
requirements often leads to the exclusion of these seemingly fundamental prop-
erties in favor of more specialized research.
Table 1. Requirements based on the MUSTs (number from RFC shown in brackets)
as deﬁned in RFC 793bis, Draft 14 [27]. Further, we show the precise test sequence and
the condition leading to a PASS for the test.
Checksum
PASS Condition
ChecksumIncorrect (2,3)
ChecksumZero (2,3)
Options