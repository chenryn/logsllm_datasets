### 6.1 Experiment Design

In this experiment, we ensure that all conditions are identical for both twins, including the Pi-3 hardware, software image, HAT (Hardware Attached on Top) and its satellite visibility, experiment duration, and temperature environment. The only difference is the source of the PPS (Pulse Per Second) signal: in one twin, it comes from the HAT itself, while in the other, it is replaced by a reference PPS generated by our signal generator.

For the first time, we will examine timestamps from the system clock, which is disciplined by the `ntpd` daemon synchronizing to the input PPS in a standard configuration for each twin. Timestamps are recorded within the IRQ (Interrupt Request) routine responding to the PPS pulses, just after the raw timestamping location. We compare the system clock timestamps \( S_r(i) \) and \( S_h(i) \) for the twin with the reference and HAT PPS, respectively.

### 6.2 Results

We analyze the Inter-Pulse Time (IPT) sequence, defined as:
\[ IPT_x(i) = S_x(i + 1) - S_x(i) \]
for each Pi, where \( x \) is either \( h \) (HAT) or \( r \) (reference).

Figure 6 shows a representative subset of 3000 pulses from each IPT timeseries, along with histograms of all values between the 0.1st and 99.9th percentiles. The two series are very similar, but the outliers in the HAT case are larger than those of the underlying pulses, which have a range under 1 µs (as shown in Figure 2). This indicates that the system clock based on HAT pulses can achieve similar accuracy to one built on a high-end reference system, provided satellite reception is maintained. However, it also highlights the importance of algorithm stability, as small instabilities at the pulse level are being amplified rather than suppressed by `ntpd`, albeit slightly, even under ideal conditions.

While \( IPT_x(i) \) examines errors in measuring 1-second intervals, the error of the system clock over the entire trace is given by:
\[ S_x(i) - (S_x(1) + i - 1) \]
For each twin, we observe a fluctuating periodic wander in a 30 µs band, indicating that the software clock (in)stability is dominating the small differences in pulse quality. For reference, the best-case wander on a PC platform is closer to 10 µs.

### 5.1 Experiment Design

Linux provides a standard way to access a PPS signal via the Kernel PPS interface. We developed a user-space data logging application that uses this call to block on each pulse. Upon each callback, we immediately read the STC (System Time Counter) using memory mapping and retrieve and log our IRQ-based STC timestamp. For each generation of Pi, we collected several hours of data, including periods of minimal load and high load induced by file transfers.

### 5.2 Results

We first examined the Inter-Pulse values \( C(i) \) taken at each timestamping location separately. For example, results for the Pi-2 showed identical median values but markedly different variabilities, with [kernel, user] standard deviations of [3.1, 418] µs and ranges of [0.11, 32.5] ms. This is despite the benefit of low-latency memory-mapped STC reads.

A more direct approach is to examine the latency \( L(i) \) between the raw timestamps read in the kernel and user space:
\[ L(i) = STC(t_u^i) - STC(t_k^i) \]
The histogram of \( L(i) \) is given in Figure 5 for each Pi generation, showing values from the minimum to the 99.9th percentile. Although a clear generational improvement is seen, the gap between the arrival of the pulse and its receipt in user space can be significant, with outliers extending into the millisecond range.

The experiment also collected instances where the pulse was detected by the kernel but the callback failed.

### 7. Conclusion

To address the question of whether we can trust the Pi for timing, we synthesize our findings as follows:

- **Timing Hardware Fundamentals**: Results from Goal 1 showed that the STC's stability is an adequate basis for a software clock, not very different from that of a larger PC platform. However, the 1 µs resolution is a current limitation.
- **GPS Source Quality**: Results from Goal 2 showed that a well-chosen, inexpensive GPS source can be almost indistinguishable from an expensive reference for timing needs below 1 µs, provided there is reliable PPS and consistent satellite coverage.
- **Latency Management**: Goals 3 and 4 highlight the need to manage access latencies properly to fully benefit from a PPS. Operating system and other latencies are more significant on a Pi than on a larger platform.
- **Synchronization Algorithms**: With PPS available, Goal 4 shows that a Pi+HAT using `ntpd` on Raspbian can perform to within a small factor of a Stratum-1 server on a larger platform. However, erratic behavior if the PPS stability degrades cannot be ruled out, especially under high system load.

For a Pi without PPS, the timestamps used for system clock definition/synchronization would be of packets exchanged with remote timeservers, which is problematic due to the high latency network interface. For example, the Pi-3 has a USB-based interface, which is polled from the operating system rather than interrupt-driven. Under ideal conditions, latencies lie in the 10s of µs range but can easily reach 100s of µs or even the ms level under heavy load.

It is well documented that `ntpd` has significant stability issues. When network and system latency variability reach certain 'tipping points', stability is lost, and errors can jump from a best-case value of the order of 1 ms to a wandering error with an amplitude of 10s or 100s of ms, or even beyond. Because latencies are higher on a Pi, it is more vulnerable to this occurring.

To demonstrate the best possible performance of the Pi without a PPS, we performed an additional 30-hour experiment where a Pi-3 was a Stratum-2 client, synchronizing over the LAN to a Stratum-1 reference NTP server (the SRS) with no other network traffic or system load. The IPTh(i) timeseries now exhibited spikes in the ±20 µs range and periodicity with an amplitude of 5 µs. More importantly, the accumulated error \( S_x(i) - (S_x(1) + i - 1) \) exhibited a wander in a 370 µs band, compared to 30 µs previously. This is approaching the ms level, even under these very unrealistic ideal conditions.

Feedforward synchronization algorithms such as RADclock do not suffer from the feedback instabilities and can deliver high accuracy (wander under 1 ms under reasonable assumptions). Moreover, because RADclock treats time difference measurement differently from absolute time at a fundamental level, it can provide PPS-like accuracy for quantities such as round-trip and inter-packet times, and delay variation, without the need for PPS. This is ideal for measurement efforts, such as CAIDA’s Internet topology mapping, which are based on RTTs. Of course, individual packet timestamps will still suffer from the latencies of the network hardware, even with a perfect system clock.

In conclusion, timing sufficient for most network measurement purposes is fundamentally possible on a Pi, but achieving it may require replacing `ntpd` to ensure accuracy, reliability, and meaningful error bounds. With the right clock synchronization approach, the limitation to timestamp accuracy on the platform is likely to be the latency of the network interface.

### Acknowledgment

This work was partially supported by the Australian Research Council’s Linkage Projects funding scheme #LP120100073, in partnership with Symmetricom (now Microsemi), an ITSP Tier-2 project grant (ref. no. GHP/027/11) from the Innovation Technology Fund in Hong Kong, and a research grant from the Joint Universities Computer Center of Hong Kong (ref. no. H-ZL17). Thanks also to Lewis Masters, Nick Gustafson, Brendan Horan, and Michael Wouters for their insights, and the reviewers and our shepherd for helpful comments.

### References

[References listed as in the original text]

This revised version aims to improve clarity, coherence, and professionalism, making the content more accessible and easier to understand.