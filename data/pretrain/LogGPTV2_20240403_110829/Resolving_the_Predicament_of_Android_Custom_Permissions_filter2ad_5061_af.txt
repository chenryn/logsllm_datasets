APPENDIX
In our formal model, we update the representation of
permissions in order to reﬂect our design decisions. First, we
add a boolean ﬁeld to our Permission Alloy signature to
indicate whether a permission is custom or system. Then, we
also add a source id ﬁeld, which will be used during permission
enforcement to uniquely identify permissions. Here, we use
app signature and not the hash of it for our formal model
for simplicity. Updated permission abstraction can be seen in
Listing 8.
For app and component guards, Cusper performs name
translation at runtime during enforcement. Listing 9 represents
the component invocation operation and the predicate in line 8
illustrates how permission enforcement is done according to
Cusper. Whenever a component is being invoked, we retrieve
the name of corresponding app or component permission,
perform a lookup operation to ﬁnd the corresponding Cusper
name (see line 11). In addition, we update how we perform
enforcement, so that when the system checks whether a calling
app has the permission required to invoke a component, it will
use both the permission name and the source id (see line 14).
custom
permission
correctly
the
as
FLAG PERMISSION REVOKE ON UPGRADE
shown in line 25 of Listing 10, which illustrates how
grantInstall case is handled.
we
indicator
Furthermore,
the
boolean
utilize
ﬁeld
to
set
ﬂag
B. Other discovered attacks
In addition to the attacks we discussed in Section IV, we
also discovered another attack on Android custom permissions
that utilizes the lack of naming conventions for permissions to
launch attacks on benign apps [14].
As described in Section II, custom permissions can also be
created dynamically via the Android APIs. In this attack, the
adversary spoofs the dynamic custom permissions of the vic-
tim. This attack is currently reproducible only on older versions
14
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
pred invoke[t, t’ : Time, caller, callee : Component]{
caller.app + callee.app in Device.apps.t
canCall[caller, callee, t]
noChanges[t, t’]
}
// Permission enforcement in the model according to
Cusper
pred canCall[caller, callee : Component, t : Time] {
let pname = guardedBy[callee],
// name translation during enforcement for
components
source = getSourceId[callee, t],
pd = getPermissionData[pname, caller.app, t] {
pname in pd.perm.name
source in pd.perm.sourceId
}
}
// Return name of the permission protecting component
fun guardedBy : Component -> PermName {
{c : Component, p : Name |
// component-specific permission takes priority
over the app-wide permission
(p = c.guard.name) or (no c.guard and p =
c.app.guard.name)
}
}
// Guard names are translated during enforcement
fun getSourceId[c : Component, t : Time] : one
AppSignature {
{p : AppSignature |
(p = findPermissionByName[c.guard.name,
t].sourceId) or
(no c.guard and p =
findPermissionByName[c.app.guard.name,
t].sourceId)
}
}
// No changes in device and granted permissions
pred noChanges[t, t’ : Time] {
Device.customPerms.t’ = Device.customPerms.t
Device.apps.t’ = Device.apps.t
all a : Application | a.permissionsState.t’ =
a.permissionsState.t
}
of (<6) due to some other issues in the new versions. Since
we focused on modeling the new versions of Android and did
not ﬁnd strong evidence for the use of dynamic permissions by
third-party developers as of now, we did not address this attack
in our work. However, we believe it is worth presenting here as
it demonstrates the extent of custom permission vulnerabilities
and provides further proof that Android custom permissions
are problematic at their current stage.
• Steps to Produce the Attack. In order to carry out the dynamic
custom permission attack, the adversary builds an app that
statically declares a custom permission that the victim app is
planning to dynamically create via the addPermission()
API method, which requires the static declaration of a permis-
sion tree with a speciﬁc domain name by the victim. The attack
can work only if the installation of the attack app is performed
before the victim app has an opportunity to dynamically create
the permission of interest. After this, the attack app can gain
unfettered access to signature protected components of the
Listing 10: Grant install case for grantPermissions predicate
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
pred grantInstallCase[p : Permission, app : Application,
hasRuntimePermission[p, app, t]
t, t’ : Time] {
=⇒ revokeRuntimePermission[p, app, t, t’]
grantInstallPermission[p, app, t, t’]
// no runtime permission should exist for this
permission
no pd : app.permissionsState.t’ |
pd.perm = p and pd.isRuntime = True
}
pred hasRuntimePermission[p : Permission, app :
Application, t :
Time] {
one pd : app.permissionsState.t |
pd.perm.name = p.name and pd.isRuntime = True
}
pred revokeRuntimePermission[p : Permission, app :
Application, t, t’ : Time] {
no pd : app.permissionsState.t’ |
pd.perm.name = p.name and pd.isRuntime = True
}
pred grantInstallPermission[p : Permission, app :
Application, t, t’ : Time] {
one pd : app.permissionsState.t’ |
pd.perm = p and pd.isRuntime = False
// Cusper fix : clear the flag to disallow
automatic upgrade to runtime for custom
permissions
p.isCustomPermission = False =⇒
clearPermFlags[pd, t’]
else setPermFlags[pd, t’]
}
pred clearPermFlags[pd : PermissionData, t : Time] {
pd.flags.FLAG_PERMISSION_REVOKE_ON_UPGRADE = False
// clear other flags. . .
}
pred setPermFlags[pd : PermissionData, t : Time] {
pd.flags.FLAG_PERMISSION_REVOKE_ON_UPGRADE = True
// set other flags. . .
}
victim app, while the victim will not be able to dynamically
create its own custom permission anymore since it is already
deﬁned in the system.
• Internals of the Attack. Android does not seem to perform
any checks on the availability of the permission names for
statically deﬁned custom permissions against the permission
tree names on the device. In other words, an app can still
statically declare a custom permission with the domain name
of a permission tree declared by another app, even though the
operation would fail if the app tried to declare this permission
dynamically (i.e., throws SecurityException stating the
tree belongs to another app). Same kind of name translation
approach we presented in Cusper can be used for the names
of permission trees to resolve this problem.
As we mentioned,
this attack works only on older
Android versions (<6.0) since the new versions require
MANAGE USERS or CREATE USERS permissions for the
addPermission() API to properly work even though this
behavior is not documented in the Android developer guides.
We believe this itself might be an undesired behavior that
was introduced by the system developers while implementing
possibly the multi-user framework in Android; hence, if this
implementation is changed, the dynamic custom permission
spooﬁng vulnerability should emerge on Android 6.0 and
onward.
REFERENCES
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]
[10]
[11]
[12]
[13]
[14]
[15]
[16]
[17]
“Alloy: A language and tool for relational models.” http://alloy.mit.edu.
“Android : Requesting permissions,” https://tinyurl.com/y8gp4dn6.
“Android dashboard,” https://tinyurl.com/qfquw3s.
“Android permissions.” https://tinyurl.com/y863owbb.
“Android plugin application,” https://tinyurl.com/ycfd9pot.
“Android users have an average of 95 apps installed on their phones,
according to yahoo aviate data,” https://tinyurl.com/ybc7dqbn.
“Apktool decompiler,” http://ibotpeaches.github.io/Apktool/.
“Creating apps with plugin architecture,” https://tinyurl.com/ydfdk9z7.
“Custom permission vulnerabilities.” https://tinyurl.com/y7yoae52.
“Dex2jar.” https://github.com/pxb1988/dex2jar.
“Google cloud messaging,” https://tinyurl.com/ybocrrqw.
“Jd-gui.” http://jd.benow.ca/.
“Privilege escalation by exploiting fcfs property of custom permissions,”
https://issuetracker.google.com/issues/37131935.
“Privilege escalation by exploiting permission trees and dynamic custom
permissions,” https://issuetracker.google.com/issues/37324008.
“Privilege escalation through custom permission update,” https://
issuetracker.google.com/issues/37130844.
“Program correctness, the speciﬁcation,” https://tinyurl.com/y8r8cze8.
“Resolving the predicament of android custom permissions,” https://
sites.google.com/view/cusper-custom-permissions/home.
“Upload applications to appaloosa,” https://tinyurl.com/y94pb3cv.
“Yoga guru,” https://tinyurl.com/yb3dqopp.
[18]
[19]
[20] H. Bagheri, E. Kang, S. Malek, and D. Jackson, “Detection of design
ﬂaws in the android permission protocol through bounded veriﬁcation,”
in International Symposium on Formal Methods, 2015.
[21] G. Betarte, J. Campo, C. Luna, and A. Romano, “Verifying android’s
permission model,” in Theoretical Aspects of Computing, 2015.
[22] D. Bogdanas, N. Nelson, and D. Dig, “Analysis and transformations in
support of android privacy,” Tech. Rep., 2016.
[23] E. Chin, A. Felt, K. Greenwood, and D. Wagner, “Analyzing inter-
application communication in android,” in MobiSys, 2011.
[24] Z. Fang, W. Han, D. Li, Z. Guo, D. Guo, X. Wang, Z. Qian, and
H. Chen, “revdroid: code analysis of the side effects after dynamic
permission revocation of android apps,” in Asia CCS, 2016.
[25] A. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner, “Android
permissions demystiﬁed,” in CCS, 2011.
[26] A. Felt, H. J. Wang, A. Moshchuk, S. Hanna, and E. Chin, “Permission
re-delegation: and defenses.” in USENIX Security, 2011.
[27] K. Leino, “Dafny: An automatic program veriﬁer for functional cor-
rectness,” in Logic for Programming AI and Reasoning, 2010.
J. Sellwood and J. Crampton, “Sleeping android: The danger of dormant
permissions,” in SPSM, 2013.
[28]
[29] W. Shin, S. Kiyomoto, K. Fukushima, and T. Tanaka, “A formal model
to analyze the permission authorization and enforcement in the android
framework,” in SocialCom, 2010.
[30] W. Shin, S. Kwak, S. Kiyomoto, K. Fukushima, and T. Tanaka, “A small
but non-negligible ﬂaw in the android permission scheme,” in POLICY,
2010.
[31] X. Wei, L. Gomez, I. Neamtiu, and M. Faloutsos, “Permission evolution
in the android ecosystem,” in ACSAC, 2012.
[32] L. Xing, X. Pan, R. Wang, K. Yuan, and X. Wang, “Upgrading your
android, elevating my malware: Privilege escalation through mobile os
updating,” in IEEE Security and Privacy, 2014.
[33] Y. Zhauniarovich and O. Gadyatskaya, “Small changes, big changes:
an updated view on the android permission system,” in RAID, 2016.
15