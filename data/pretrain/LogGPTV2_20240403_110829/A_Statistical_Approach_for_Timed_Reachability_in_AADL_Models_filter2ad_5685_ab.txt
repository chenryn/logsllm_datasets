ok
transient
: initial state;
: error state urgent in
300 msec;
: error state;
: error state;
-[ e_trans
-[ repair within 200 msec
]-> transient;
to 300 msec ]-> ok;
ok
hot
ok
end gpsError.i;
-[ e_hot
-[ @activation ]-> ok;
-[ e_permanent ]-> permanent;
]-> hot;
A speciﬁcation is deﬁned by one or more processes P =
(cid:3)L, l0, I, Tr, Var , A, T(cid:4), where L is the ﬁnite set of locations,
l0 ∈ L the initial location, Var the set of variables, A the set
of actions including internal action τ, and
•
•
•
•
ν : Var → V the valuation function with ν(v) being
a value from the domain of variable v ∈ Var;
I : L → Expr the function that assigns to each location
an invariant expression in Expr, which is a Boolean
expression over the continuous variables in Var. They
restrict the residence time in that location.
Tr : L × V ar → R the function that assigns the
(constant) derivative of all continuous variables in all
locations.
T ⊆ L × A × Expr ∪ R × E×L the set of discrete
transitions, with Expr being the set of Boolean guard
expressions over the variables Var; R being a real-
valued parameter which if set indicates an exponential
delay – this value may only be set for transitions with
the internal action τ; and E : (Var → V ) → (Var →
V ) being the function that updates the valuation upon
taking the transition.
In order to prevent ill-deﬁned semantics for probabilistic
transitions, a single location may contain only transitions with a
Boolean guard or exit rate, it cannot combine both. Furthermore,
for locations with transitions that have an associated exit rate,
the invariant must be true.
The state of a process is deﬁned as a tuple L× (Var → V ),
assigning a valuation of the variables to the current location.
A discrete transition (cid:3)ls, α, g, e, lt(cid:4) ∈ T allows the system to
move from location ls to lt, executing action α. The transition
is enabled if g is an expression that evaluates to true in the
current state, or describes an exponential delay. Upon execution
of the transition, the effect e is applied upon the valuation ν
of the variables.
A timed transition updates the valuation of the continuous
variables, based on the invariants of the current location. For
a continuous variable v ∈ Var and a delay d ∈ R, ν
(cid:2)(v) =
ν(v) + I(v)∗ d. For a discrete variable v, ν
(cid:2)(v) = ν(v) remains
the same.
A complete speciﬁcation is deﬁned by a network of com-
municating processes. The state space of such a speciﬁcation is
the cross-product of the state spaces of each process. Discrete
transitions can occur individually or in parallel, synchronizing
on the shared part of the combined alphabet of actions. Note,
a transition with an exponential delay cannot synchronize with
any other transition as the internal action τ does not synchronize
with other processes.
Various sources of non-determinism exist. Multiple transi-
tions T may be enabled at the same time, between different
processes or within a single process. Second, multiple delays
may be possible depending on the invariant of the current loca-
tion. Before discrete event simulation is possible, these forms
of non-determinism have to be resolved, see Section III-B.
Path generation of such processes is then possible by evalu-
ating for a given state the possible discrete and timed transitions.
By employing a given strategy to resolve non-determinism for
both the discrete and continuous dynamics, the next state can
be generated by means of a probability distribution over either
the discrete or timed transitions. Generally, a path is then
generated by alternating between timed and discrete transitions,
see also [18].
Figure 2 shows a simpliﬁcation of the model speciﬁed in
Listing 2. Here, three locations are represented as nodes, with
the label shown above the invariant of that location. Edges
represent the discrete transitions, with the action shown above
the guard or exit rate. The clock representing the delays in the
model is an implicit variable, reset to zero at every discrete
transition.
F. COMPASS Toolset Architecture
The COMPASS toolset makes use of various tool compo-
nents to provide the supported functionality. A frontend parses
input models and properties, which can then be translated
by backends into formats usable by the various tools. As
mentioned before, the properties can be represented by various
logics such as LTL, CTL and CSL, converted into the format
8383
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:48:59 UTC from IEEE Xplore.  Restrictions apply. 
to analyze the behavior of the model, by allowing the state
to change by progressing time or selecting discrete transitions
between modes. The event connections and data ﬂows are used
by the network to determine which transitions can synchronize,
and the global effect of data assignments.
The simulation logic consists of three sub-parts: The
strategy determines how non-determinism is resolved, and
is explained in Section III-B. The generator part deals with
statistical analysis of the current results and determines whether
or not further simulation is required to attain the desired
accuracy and precision. Currently the generator implements the
Chernoff-Hoeffding bound, but future extensions may allow
other approaches such as Chow-Robbins or Gauss [20] (this may
require further considerations, see also Section III-C). Finally,
there is a part responsible for path generation, integrating the
other two parts into the actual simulation engine.
The complete simulator has been implemented in the C++
language, consisting of approximately 14,000 lines of code.
Additionally about 200 lines of Python code were necessary to
integrate it into the COMPASS toolset.
Fig. 1. Example of slimsim. After opening a model ﬁle, the user can enter
the required conﬁdence and error bound, and specify the strategy to use. Then,
the run button will start the simulation.
repair
[200,300] msec
ok
transient
≤ 300 msec
e_trans λ = 0.1 per hour
e_hot
λ = 0.1 per day
hot
@activation
Fig. 2. Simpliﬁed STA of GPS error model.
B. Strategies
supported by the various tools. Two backends are available for
the translation of the model. The primary, preexisting backend
translates the model into SMV [19] for use with the NuSMV
model checker [11]. NuSMV can then be used for analysis, or
its outputs can be chained to other tools (such as MRMC, see
Section IV).
As part of the work presented in this paper the simulator
format has been added as a secondary backend. This allows
for a single, consistent interface for validating the input model
before performing the analysis (such as checking for recursively
deﬁned components).
The toolset provides the translated input model to the
tool(s) corresponding to a particular analysis. After analysis, it
processes the results and presents it to the user. Two interfaces
are available for this: A GUI (see Figure 1) provides user
friendly access, and a CLI (Command Line Interface) provides
more direct control and automation.
III.
IMPLEMENTATION
A. Simulator Architecture
The architecture of the simulator can roughly be divided
in three parts: One part represents the static structure of the
input model; One part implements the behavior of the model
and ﬁnally a third part deals with the actual simulation.
The speciﬁcation is loaded from a ﬁle that is generated by
the toolset, which in turn is translated into the corresponding
data structures. From this data, the actual model instance is con-
structed which contains the concrete connections between the
various components that may have been deﬁned. Furthermore,
the various data of the model are allocated and initialized.
The model is then used to construct the event-data network,
which builds the connection topology of event and data ports
and keep tracks of the current state of the model [15]. This
network, the Network of Event Data Automata can then be used
8484
The simulator supports the deﬁnition of strategies. This
mechanism allows the user to control the behavior of the
simulator where the input speciﬁcation does not precisely dictate
what the next step should be (due to non-determinism). Since
such behaviors can alter the outcome of the simulation, it is
left to the user to decide what approach suits the analysis best.
In [18], it is shown that various approaches are possible, each
possibly leading to different outcomes of the statistical analysis.
Before the analysis is started, the user has to specify what
strategy to use (along with the conﬁdence and error bound).
The simulator implements four automated strategies, and
one manual input strategy:
•
•
•
ASAP – The ASAP strategy implements the resolution
of time delays by determining the ﬁrst possible time
point at which a discrete step becomes enabled. This
deﬁnes an ‘urgent’ semantics, where the model moves
as fast as possible. This strategy is similar to the one
employed by the MODES tool [4].
Progressive – The progressive strategy determines
the exact intervals in which a discrete transition is
active, and randomly selects a time point from these
intervals by a uniform distribution, similar to UPPAAL-
SMC [3].
Local – The local strategy only considers the invariant
of the current location, selecting the widest possible
range of delays.
• MaxTime – The MaxTime strategy will delay as
much as is allowed by the invariant of the current
location. This strategy can in particular helpful to ﬁnd
actionlocks [18].
Input – The input strategy asks the user what the
next step should be for each step in the simulation.
It presents the possible alternatives, both as discrete
transitions and time delays, as well as the current state
of the model.
•
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:48:59 UTC from IEEE Xplore.  Restrictions apply. 
As explain before, Figure 2 shows a simpliﬁed automaton
of the GPS example from Listing 2. The effects of the various
strategies can be exempliﬁed by the transition from location
ok to transient. It is guarded by a non-deterministic time
interval between 200 and 300 msec. Here, the ASAP strategy
will schedule a delay of 200 msec, whereas MaxTime will
schedule 300 msec. The Progressive strategy uniformly selects
from the interval [200, 300] msec, determined by the guard.
The Local strategy ignores the guard, and selects from the
interval [0, 300] msec, based on the invariant.
For all strategies, underspeciﬁcation of choice is always
resolved using a uniform distribution using the notion of
equiprobability, where the Progressive, Local, and MaxTime
strategies select the delay before the transition, and the ASAP
strategy select the (ﬁrst executable) transition ﬁrst, with only
one possible delay. Underspeciﬁcation of time is, in so far
a strategy considers, an interval resolved by a (continuous)
uniform distribution as well.
C. Parallelization
The algorithm for Monte Carlo simulations lets itself be
parallelized rather trivially, as the outcome of each simulation
does not depend on any other. Thus, it makes sense to distribute
the workload in order to improve performance. However, care
should be taken that the use of multiple parallel processes does
not introduce any bias. The work in [21] shows that taking a
sample from a process into account as soon as it arrives alters
the outcome based on the number of processes. A solution
is to balance the workload between processors, ensuring each
processor performs the same amount of simulations. In the case
of the CH-bound, the number of samples required is known
a-priori and so a trivial solution is to have each processor
calculate N/k samples, for k processors. However, a more
general procedure is described in [22] where N does not have
to be known in advance. Here, the results of the processors
are buffered, until at least one sample is available from all
processors. Then, these samples are taken from the buffer. This
approach has been implemented in our simulator, to support the
use of other generators such as Chow-Robbins or Gauss [20]
in the future.
D. Deadlocks
One particular problem Monte Carlo simulators face is
dealing with deadlocks. In such cases, it is not possible to
produce further events, and the path generation has to stop.
Depending on the semantics of the underlying model, this may
be valid or invalid behavior. SLIM admits the speciﬁcation of
models containing deadlocks and depending on the intention of
the user, this may not be desirable. In such cases, slimsim
can be conﬁgured to generate an error upon the detection of a
deadlock. In other cases, a path leading to a time- or deadlock
is considered to falsify the property being checked, as reaching
a goal state from such a state is not possible.
IV. BENCHMARKS
A comparison was made between the simulator and the
original analysis ﬂow using CTMCs. In order to generate the
CTMCs from the input model, the toolset takes several steps.