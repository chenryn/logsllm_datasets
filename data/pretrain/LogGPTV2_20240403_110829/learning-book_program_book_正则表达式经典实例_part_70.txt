362第7章
www.TopSage.com
---
## Page 379
7.16匹配1Pv4地址
问题描述
你要检查某个特定字符串是否包含了一个以255.255.255.255标记法来表示的IPv4地
址。另外，你还想把这个地址转化为一个32位整数。
解决方案
正则表达式
检查一个IP地址的简单正则式：
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
检查一个IP地址的精确正则式：
(?:(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?)\.){3}
（[6-0]6-0]0]16-0][-0]1-0]:)
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
从一大段文本中抽取IP地址的简单正则式：
\b（？:[0-9]{1,3}\.){3}[0-9]{1,3}\b
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
从一大段文本中抽取IP地址的精确正则式：
\b(?:(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?)\.){3}
(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?) \b
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
捕获IP地址中的4个部分的简单正则式：
（[0-9]{1,3})\.（[0-9]{1,3}）\.（[0-9]{1,3})\.（[0-9]1,3}）$
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
捕获IP地址中的4个部分的精确正则式：
([6-0]6-0][0]1[6-0][-0]1[-01）
(25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?)\.
(25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?)\.
（[6-0]6-0]0]16-0]-0]1-0])
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
URL、路径和Internet地址
363
www.TopSage.com
---
## Page 380
Perl
if($subject =~m/([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/)
1
$ip=$1来逐个匹配IP地址中的4段数字。它们实际上
允许出现0～999之间的数字，而不只是0～255。当你已知输人文本中只包含合法IP
地址的时候，这些简单的正则式会更高效，你需要做的只是把IP地址和其他内容分
开即可。
精确的正则式则使用（25[0-5]2[0-4][0-9][01]?[0-9][0-9]?>逐个分别匹配IP地址中的4
个数字。这个正则式会精确地匹配0～255范围内的数字，对于10～99之间的数字，
前面可以包含一个可选的0；而对于0～9之间的数字，前面可以包含两个可选的
0。（25[0-5]>会匹配250~255，（2[0-4][0-9]>匹配200～249，而会匹
配0～199，其中也包括了可选的前缀0。实例6.5中详细讲解了如何使用-一个正则表达
式来匹配数字区间。
如果你要检查整个字符串是否是一个合法的IP地址，就需要使用一个以脱字符开始、
以美元符结束的正则式。它们分别是字符串开始和字符串结束的定位符，相关的详细
信息，请参考实例2.5。如果你要在一大段文本中查找一个IP地址，那么就需要使用一
个以单词边界（b）（实例2.6）作为开始和结束的正则式。
前面4个正则表达式中使用了<(?:numberL.){3}number）的形式。在IP地址中的前3个
数字会用一个非捕获分组来匹配（实例2.9），它可以重复3次（实例2.12）。该分组会
匹配字符和一个字面上的点号，而在一个IP地址中总是会包含3个点号。正则式的最
后一部分匹配了IP地址中的最后一个数字。使用非捕获分组并把它重复3次可以使我
们的正则表达式更简短、更高效。
要把IP地址中的文本表示转换为一个整数，我们需要分别捕获4个数字。解决方案中
最后两个正则式完成的是这个任务。原来我们对一个分组重复3次，而现在则需要使
用4个捕获分组，分别处理一个数字。只有用这种罗列的办法才能在IP地址中分别捕
获所有4个数字。
364第7章
www.TopSage.com
---
## Page 381
一旦捕获到了这些数字，把它们组合为32位的整数就是很容易的。在Perl中，特殊变
量$1、$2、$3和$4含有正则表达式中4个分组所匹配到的文本。实例3.9讲解了在其
他编程语言中如何提取捕获分组的方法。在Perl中，对字符串应用逐位操作的左移位
操作符(<<)，就可以把捕获分组中的字符串变量自动强制转换为数字。在其他语言中，
在用一个逐位操作or对数字进行移位和组合之前，你可能必须先调用String.tolntegerO
或者其他类似的手段。
参见
实例2.3、实例2.8、实例2.9和实例2.12。
7.17匹配IPv6地址
问题描述
你要检查一个字符串代表的是否是一个使用标准、紧凑和/或混合标记法来表示的IPv6
地址。
解决方案
标准标记法
匹配一个使用标准标记法的IPv6地址，标准的IPv6地址由8个使用十六进制表示的
16位数组成，各数之间用冒号分隔（例如1762：0：0:0：0:B03:1：AF18）。前导的0是可
选的。
检查整个目标文本是否是一个使用标准标记法的IPv6地址：
(?:[A-F0-9]{1,4}:){7}[A-F0-9}{1, 4}$
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
A(?:[A-F0-9]{1, 4} :)(7}[AF0-9]{1, 4)\Z
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
在一大段文本集合中查找一个使用标准标记法的IPv6地址：
(?<![: .\w]) (?: [AF0-9]{1, 4) :) {7} [A-F0-9] {1, 4} (?![: . \w])
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby 1.9
JavaScript和Ruby1.8并不支持逆序环视。我们必须去掉在正则式开头，用来保证不会
找到位于一长串十六进制数和冒号序列中的IPv6地址的检查。现在我们使用单词边界
来部分执行这个检查：
URL、路径和Internet地址
365
www.TopSage.com
---
## Page 382
\b(?:[A-F0-9]{1, 4}:){7}[A-F0-9]{1, 4}\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
混合标记
16位数和后面跟随的4个十进制字节数组成。各个字数之间用冒号分隔，而字节之间
则用点号分隔。在字数和字节数之间用一个冒号作为分隔。在每个十六进制数和十进
制字节中的前导0都是可选的。这种标记法会用于IPv4和IPv6地址混用的情况下。IPv6
地址是IPv4地址的扩展。762：0：0：0：0：B03：127.32.67.15就是一个使用混合标记法的IPv6
地址。
检查整个目标文本是否是一个使用混合标记法的IPv6地址：
(?:[A-F0-9]{1, 4}:) {6}(?:(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?)\.){3}
(?: 25[0-5]12 [0-4][0-9]1[01]?[0-9][0-9]?) $
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
在一大段文本中查找-一个使用混合标记法的IPv6地址：
(?<![:. \w])(?:[A-F0-9]{1,4}:) {6}
(?:(?: 25[0-5]12[04][0-9]1[01] ?[0-9][0-9]?)\.) {3}
(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?) (?![: . \w])
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
JavaScript和Ruby1.8并不支持逆序环视。我们必须去掉在正则式开头，用来保证不会
找到位于一长串十六进制数和冒号序列中的IPv6地址的检查。现在使用单词边界来部
分执行这个检查：
\b（?:[A-F0-9]{1,4}:){6}(?:(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?)\.){3}
(?:25[0-5]12[0-4][0-9]1[01] ?[0-9][0-9] ?)\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
标准或混合标记法
匹配一个使用标准或混合标记法的IPv6地址。
检查整个目标文本是否是一个使用标准或混合标记法的IPv6地址：
\A
#字符串开始
(？:[A-F0-9]{1, 4}:) {6}
#6个字数
(?:[A-F0-9}(1, 4}:[A-F0-9](1, 4}
#2个字数
1（？:（?:25[0-5]12[0-4][0-9]1[01]？[0-9][0-9]？)\.）{3}#或4个字节数
(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?)
\z
#字符串结束
366第7章
www.TopSage.com
---
## Page 383
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
(?:[A-F0-9]{1, 4} :) (6}(?: [A-F0-9]{1, 4} : [A-F0-9]{1, 4} 1
(（6-0]6-0]0]16-0]-0]1-0):)
(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?))$
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python
在一大段文本中找到一个使用标准或混合标记法的IPv6地址：
(?<![:.\w])
#地址定位
(?:[A-F0-9](1, 4}:) {6}
6个字数
(?:[A-F0-9]{1,4}:[A-F0-9}{1,4}
#2个字数
1(?:(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?)\.){3}
#或4个字节数
(?:25[0-5]12[0-4][0-9]1[01] ?[0-9][0-9]?)
)(?![: .\w])
#地址定位
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby1.9
JavaScript和Ruby1.8并不支持逆序环视。我们必须去掉在正则式开头，用来保证不会
找到位于一长串十六进制数和冒号序列中的IPv6地址的检查。现在使用单词边界来部
分执行这个检查：
\b
#单词边界
(?:[A-F0-9]{1, 4) :) (6}
#6个字数
(?: [A-F0-9]{1, 4} : [A-F0-9] {1, 4}
#2个字数
1(?:(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?)\.){3}
#或4个字节数
(2[6-0][6-0]0]1[6-0][-0]1-0]:)
)b
单词边界
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
\b(?: [A-F0-9] (1, 4} :) {6}(?: [A-F0-9] (1, 4} : [A-F0-9] (1, 4) 1
(?:(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?)\.){3}
(?:25[0-5]12[0-4][0-9]1[01]?[0-9][0-9]?))\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
压缩标记法
匹配一个使用压缩标记法的IPv6地址。压缩标记法和标准标记法大体相同，只是可以
省略一个或者多个值为0的数字序列，而在略去0的数字序列的前后就会只剩下冒号。
使用压缩标记法的地址中会出现两个连续的冒号，因此可以通过这个特征来进行识别。
一个地址中只能省略一个值为0的数字序列，否则，我们就无法确定在每个序列中有
多少个数字被省略掉了。如果省略的为0的数字出现在IP地址的开端或结尾，那么该
地址就会以两个冒号作为开始或结束。如果所有的数都是0，那么IPv6地址就会以两
个冒号组成，其中不包含任何数字。
URL、路径和Internet地址
367
www.TopSage.com
---
## Page 384