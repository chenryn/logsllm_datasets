tion for branch target prediction attacks, indirect branch promo-
tion aims to ‚Äúrewrite‚Äù indirect transfers as direct: at runtime, each
dynamically-resolved indirect branch target is compared to sev-
eral statically-encoded candidates, with a conditional jump to each
ab with #     ¬ª
ab0ùëé and #        ¬ª
i1b and #   ¬ª
should the comparison match (e.g., if(%eax == foo): jump foo).
While promotion is applicable to nearly all indirect branches (and
hence indirect critical edges), branch target prediction accuracy is
never guaranteed. Existing approaches attempt to maximize pre-
cision by profiling indirect branches in advance for their ‚Äúmost
probable‚Äù targets, however, fuzzing may expose (and prioritize)
new targets previously considered unlikely by profiling.
Hybrid Instrumentation: A third possibility for indirect criti-
cal edges is to default back to AFL-style hashing-based edge cover-
age (¬ß 2.3). While it is impossible to identify each indirect edge‚Äôs
targets accurately, a conservative approach is to instead instrument
the set of all potential indirect branch targets, as their heuristics
are generally well-known (e.g., function entrypoints for indirect
calls, and post-call blocks for returns). We can thus imagine future
target-tailored CGT approaches balancing fast speed for common-
case critical edges with more precise handling (e.g., header splitting,
promotion, and hybrid instrumentation) of infrequent ones.
6.2 Trade-offs of Hit Count Coverage
Hit counts measure fuzzing exploration progress in loops and cycles,
but as with any coverage metric, their implementation must care-
fully balance precision and speed to support effective bug-finding.
Two considerations central to hit count coverage implementations
are (1) the size and number of bucket ranges; and (2) the frequency
at which hit counts are tracked. We discuss both of these below.
Bucket Granularity: Our current implementation of bucketed
unrolling (¬ß 4.3) mimics the hit count tracking of conventional
fuzzers by injecting conditional checks against eight bucket ranges
(0‚Äì1, 2, 3, 4‚Äì7, 8‚Äì15, 16‚Äì31, 32‚Äì127, 128+). However, these eight
bucket ranges are merely an artifact of AFL‚Äôs original implementa-
tion (each hashed edge is mapped to an 8-bit index in its coverage
bitmap). Adding more buckets makes it possible to track more subtle
changes in loop iteration counts, while using fewer buckets trades-
off this level of introspection for higher fuzzing throughput. While
it is unclear which bucket ranges achieve the best balance of speed
and coverage with respect to bug-finding, we expect that future
research will address these unanswered questions and more.
Frequency of Tracking: How often hit counts are tracked fur-
ther influences fuzzing exploration and bug-finding. Conventional
exhaustive (per-edge) hit counts shed light on frequencies of cycle
subpaths (e.g., how many times a loop break is taken), but risk
Session 2A: Fuzzing and Bug Finding CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea362saturating a fuzzer‚Äôs search space with redundant or noisy paths.
Bucketed unrolling instead trades-off coverage exhaustiveness for
speed by restricting hit count tracking to only a subset of the pro-
gram state (e.g., loop iteration counters). While our analysis of
the bugs exclusively found by exhaustive hit counts (Figure 11b)
reveals that none are outside the reach of HeXcite, we expect
that future work will explore adapting selective and synergistic hit
count schemes to better cover complex loops, cycles, and compiler
optimizations at high speed.
6.3 Improving Performance
The fuzzing-oriented binary transformation platform currently
utilized in HeXcite, ZAFL [38], adopts a code layout algorithm
that rewrites all direct jumps to have 32-bit PC-relative signed
displacements. While this is well-suited to our implementation of
zero-address jump mistargeting (¬ß 4.2)‚Äîenabling virtually every
conditional jump in the program‚Äôs address space to be mistargeted
to 0x00‚Äî32-bit displacements accumulate more runtime overhead
over 8‚Äì16-bit displacements. As ZAFL has experimental code lay-
outs that instead prioritize smaller displacements, we thus envision
potential for faster ‚Äúhybrid‚Äù mistargeting schemes that coalesce
both zero-address and embedded interrupt styles.
6.4 Supporting Other Software & Platforms
Our current coverage-preserving CGT prototype, HeXcite, sup-
ports 64-bit Linux C and C++ binaries. Extending support to other
software characteristics (e.g., 32-bit) or platforms (e.g., Windows)
requires retooling of its underlying static binary rewriting engine.
However, as this component is orthogonal to the fundamental prin-
ciples of coverage-preserving CGT, we expect that HeXcite will
capitalize on future engineering improvements in static rewriting
to bring accelerated fuzzing to the broader software ecosystem.
7 RELATED WORK
We discuss recent efforts to improve binary-only fuzzing perfor-
mance that are orthogonal to coverage-preserving CGT: (1) faster
instrumentation, (2) less instrumentation, and (3) faster execution.
7.1 Faster Instrumentation
As binary fuzzing effectiveness depends heavily on maintaining
fast coverage tracking, a growing body of research is targeting
instrumentation-side optimizations. Efforts to improve dynamic
translation-based instrumentation (e.g., AFL-QEMU [59], DrAFL [47],
UnicornAFL [52]) generally focus on simplifying or expanding the
caching of translated code [4]; while those using static rewriting
(e.g., ZAFL [38], Dyninst [40], RetroWrite [15]) tackle various chal-
lenges related to generated code performance. Though our coverage-
preserving CGT prototype, HeXcite, currently leverages the ZAFL
rewriter, we believe that future advances in binary instrumentation
will enable it to achieve performance even closer to native speed.
7.2 Less Instrumentation
Another way to reduce the footprint of coverage tracking is to
eliminate needless instrumentation from the program under test.
While most other control-flow-centric approaches only exist in
compiler instrumentation-based implementation (e.g., dominator
trees [2], INSTRIM [28], CollAFL [19]), their principles are well-
suited to binary-only fuzzing. A recent fork of AFL-Dyninst [26]
omits instrumentation from blocks preceded by unconditional di-
rect transfer, as their coverage is directly implied by their ancestor‚Äôs.
In addition to accelerating execution of HeXcite‚Äôs tracer binary,
we see the potential for such control-flow-centric analyses to help
determine how HeXcite‚Äôs control-flow-altering transformations
(e.g., bucketed unrolling) should optimally be applied.
7.3 Faster Execution
Besides instrumentation, execution is itself a bottleneck to fuzzing,
as faster execution enables more test cases to be run on the tar-
get program in less time. Most modern binary-only fuzzing efforts
have abandoned slow process creation-based execution for faster
snapshotting, leveraging cheap copy-on-write cloning to rapidly
initiate target execution from a pre-initialized state (e.g., AFL‚Äôs fork-
server [59]). Xu et al. [55] achieve even faster snapshotting through
fuzzing-optimized Linux kernel extensions. The recent technique
of persistent/in-memory execution offers higher speed by restrict-
ing execution to only a pre-specified target program code region
(essentially interposing a loop), and is gaining support among pop-
ular binary-only fuzzing toolchains (e.g., WinAFL [22], AFL-QEMU,
UnicornAFL). Many efforts are also exploring the benefits of amor-
tizing fuzzing execution speed through parallelization; off-the-shelf
binary-only fuzzers like AFL [59] and honggFuzz [49] support par-
allelization out-of-the-box, and recent work by Falk [16] achieves
even faster speed by leveraging vectorized instruction sets. As exe-
cution and coverage tracking work hand-in-hand during fuzzing,
we view such accelerated execution mechanisms as complementary
to HeXcite‚Äôs accelerated coverage tracking.
8 CONCLUSION
Coverage-preserving Coverage-guided Tracing extends the prin-
ciples behind CGT‚Äôs performance-maximizing, waste-eliminating
tracing strategy to the finer-gained coverage metrics it is not nat-
urally supportive of: edge coverage and hit counts. We introduce
program transformations that enhance CGT‚Äôs introspection capa-
bilities while upholding its minimally-invasive nature; and show
how these techniques improve binary-only fuzzing effectiveness
over conventional CGT, while keeping an orders-of-magnitude per-
formance advantage over the leading binary-only coverage tracers.
Our results reveal it is finally possible for today‚Äôs state-of-the-
art coverage-guided fuzzers to embrace the acceleration of CGT‚Äî
without sacrificing coverage. We envision a new era in software
fuzzing, where synergistic and target-tailored approaches will max-
imize common-case performance with infrequent-case precision.
ACKNOWLEDGEMENT
We thank our shepherd Jun Xu and our reviewers for helping us
improve the paper. We also thank Peter Goodman and Trail of Bits
for assisting us with binary-to-LLVM lifting. This material is based
upon work supported by the Defense Advanced Research Projects
Agency under Contract No. W911NF-18-C-0019 and the National
Science Foundation under Grant No. 1650540.
Session 2A: Fuzzing and Bug Finding CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea363REFERENCES
[1] laf-intel: Circumventing Fuzzing Roadblocks with Compiler Transformations,
2016. URL: https://lafintel.wordpress.com/.
[2] Hiralal Agrawal. Dominators, Super Blocks, and Program Coverage. In ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL,
1994.
[3] Cornelius Aschermann, Sergej Schumilo, Tim Blazytko, Robert Gawlik, and
Thorsten Holz. REDQUEEN: Fuzzing with Input-to-State Correspondence. In
Network and Distributed System Security Symposium, NDSS, 2018.
[4] Andrea Biondo. Improving AFL‚Äôs QEMU mode performance, 2018. URL: https:
//abiondo.me/2018/09/21/improving-afl-qemu-mode/.
[5] Tim Blazytko, Cornelius Aschermann, Moritz Schl√∂gel, Ali Abbasi, Sergej Schu-
milo, Simon W√∂rner, and Thorsten Holz. GRIMOIRE: Synthesizing Structure
while Fuzzing. In USENIX Security Symposium, USENIX, 2019.
[6] Marcel B√∂hme, Van-Thuan Pham, Manh-Dung Nguyen, and Abhik Roychoud-
hury. Directed Greybox Fuzzing. In ACM SIGSAC Conference on Computer and
Communications Security, CCS, 2017.
[7] Marcel B√∂hme, Van-Thuan Pham, and Abhik Roychoudhury. Coverage-based
Greybox Fuzzing As Markov Chain. In ACM SIGSAC Conference on Computer
and Communications Security, CCS, 2016.
[8] Ella Bounimova, Patrice Godefroid, and David Molnar.
Billions and Bil-
lions of Constraints: Whitebox Fuzz Testing in Production. Technical report,
2012. URL: https://www.microsoft.com/en-us/research/publication/billions-and-
billions-of-constraints-whitebox-fuzz-testing-in-production/.
[9] Peng Chen and Hao Chen. Angora: efficient fuzzing by principled search. In
IEEE Symposium on Security and Privacy, Oakland, 2018.
[10] Peng Chen, Jianzhong Liu, and Hao Chen. Matryoshka: Fuzzing Deeply Nested
Branches. In ACM SIGSAC Conference on Computer and Communications Security,
CCS, 2019.
[11] Yaohui Chen, Peng Li, Jun Xu, Shengjian Guo, Rundong Zhou, Yulong Zhang,
Taowei, and Long Lu. SAVIOR: Towards Bug-Driven Hybrid Testing. In IEEE
Symposium on Security and Privacy, Oakland, 2020. arXiv: 1906.07327.
[12] Yuanliang Chen, Yu Jiang, Fuchen Ma, Jie Liang, Mingzhe Wang, Chijin Zhou,
Xun Jiao, and Zhuo Su. EnFuzz: Ensemble Fuzzing with Seed Synchronization
among Diverse Fuzzers. In USENIX Security Symposium, USENIX, 2019.
[13] Jaeseung Choi, Joonun Jang, Choongwoo Han, and Sang Kil Cha. Grey-box Con-
colic Testing on Binary Code. In International Conference on Software Engineering,
ICSE, 2019.
[14] Artem Dinaburg and Andrew Ruef. McSema: Static Translation of X86 Instruc-
tions to LLVM, 2014. URL: https://github.com/trailofbits/mcsema.
[15] Sushant Dinesh, Nathan Burow, Dongyan Xu, and Mathias Payer. RetroWrite:
Statically Instrumenting COTS Binaries for Fuzzing and Sanitization. In IEEE
Symposium on Security and Privacy, Oakland, 2020.
[16] Brandon Falk. Vectorized Emulation: Hardware accelerated taint tracking at 2
trillion instructions per second, 2018. URL: https://gamozolabs.github.io/fuzzing/
2018/10/14/vectorized_emulation.html.
[17] Andrea Fioraldi, Daniele Cono D‚ÄôElia, and Leonardo Querzoni. Fuzzing Binaries
for Memory Safety Errors with QASan. In IEEE Secure Development Conference,
SecDev, 2020.
[18] Andrea Fioraldi, Dominik Maier, Heiko Ei√üfeldt, and Marc Heuse. AFL++: Com-
bining Incremental Steps of Fuzzing Research. In USENIX Workshop on Offensive
Technologies, WOOT, 2020.
[19] S. Gan, C. Zhang, X. Qin, X. Tu, K. Li, Z. Pei, and Z. Chen. CollAFL: Path Sensitive
Fuzzing. In IEEE Symposium on Security and Privacy, Oakland, 2018.
[20] GNU Project. GNU gprof, 2018. URL: https://sourceware.org/binutils/docs/gprof/.
[21] Patrice Godefroid, Adam Kiezun, and Michael Y Levin. Grammar-based whitebox
fuzzing. In ACM SIGPLAN Conference on Programming Language Design and
Implementation, PLDI, 2008.
[22] Google Project Zero. WinAFL, 2016. URL: https://github.com/googleprojectzero/
winafl.
products/ida/.
dyninst.
[25] William H. Hawkins, Jason D. Hiser, Michele Co, Anh Nguyen-Tuong, and Jack W.
In IEEE/IFIP
Davidson. Zipr: Efficient Static Binary Rewriting for Security.
International Conference on Dependable Systems and Networks, DSN, 2017.
[26] Marc Heuse. AFL-Dyninst, 2018. URL: https://github.com/vanhauser-thc/afl-
[27] Jason Hiser, Anh Nguyen-Tuong, William Hawkins, Matthew McGill, Michele
Co, and Jack Davidson. Zipr++: Exceptional Binary Rewriting. In Workshop on
Forming an Ecosystem Around Software Transformation, FEAST, 2017.
[28] Chin-Chia Hsu, Che-Yu Wu, Hsu-Chun Hsiao, and Shih-Kun Huang. INSTRIM:
Lightweight Instrumentation for Coverage-guided Fuzzing. In NDSS Workshop
on Binary Analysis Research, BAR, 2018.
[29] Vivek Jain, Sanjay Rawat, Cristiano Giuffrida, and Herbert Bos. TIFF: Using Input
Type Inference To Improve Fuzzing. In Annual Computer Security Applications
Conference, ACSAC, 2018.
[30] Jinho Jung, Stephen Tong, Hong Hu, Jungwon Lim, Yonghwi Jin, and Taesoo
Kim. WINNIE: Fuzzing Windows Applications with Harness Synthesis and Fast
Cloning. In Network and Distributed System Security Symposium, NDSS, 2021.
[31] Sun Hyoung Kim, Cong Sun, Dongrui Zeng, and Gang Tan. Refining Indirect
Call Targets at the Binary Level. In Network and Distributed System Security
Symposium, NDSS, 2021.
[32] George Klees, Andrew Ruef, Benji Cooper, Shiyi Wei, and Michael Hicks. Evalu-
ating Fuzz Testing. In ACM SIGSAC Conference on Computer and Communications
Security, CCS, 2018.
[33] C. Lattner and V. Adve. LLVM: A compilation framework for lifelong program
analysis & transformation. In International Symposium on Code Generation and
Optimization, CGO, 2004.
[34] Caroline Lemieux and Koushik Sen. FairFuzz: A Targeted Mutation Strategy for
Increasing Greybox Fuzz Testing Coverage. In ACM/IEEE International Conference
on Automated Software Engineering, ASE, 2018.
[35] Yuekang Li, Bihuan Chen, Mahinthan Chandramohan, Shang-Wei Lin, Yang Liu,
and Alwen Tiu. Steelix: Program-state Based Binary Fuzzing. In ACM Joint
Meeting on Foundations of Software Engineering, ESEC/FSE, 2017.
[36] Chenyang Lv, Shouling Ji, Chao Zhang, Yuwei Li, Wei-Han Lee, Yu Song, and
Raheem Beyah. MOPT: Optimize Mutation Scheduling for Fuzzers. In USENIX
Security Symposium, USENIX, 2019.
[37] Stefan Nagy and Matthew Hicks. Full-speed Fuzzing: Reducing Fuzzing Overhead
through Coverage-guided Tracing. In IEEE Symposium on Security and Privacy,
Oakland, 2019.
[38] Stefan Nagy, Anh Nguyen-Tuong, Jason D Hiser, Jack W Davidson, and Matthew
Hicks. Breaking Through Binaries: Compiler-quality Instrumentation for Better
Binary-only Fuzzing. In USENIX Security Symposium, USENIX, 2021.
[39] Chengbin Pang, Ruotong Yu, Yaohui Chen, Eric Koskinen, Georgios Portokalidis,
Bing Mao, and Jun Xu. SoK: All You Ever Wanted to Know About x86/x64 Binary
Disassembly But Were Afraid to Ask. In IEEE Symposium on Security and Privacy,
Oakland, 2021.
[40] Paradyn Tools Project. Dyninst API, 2018. URL: https://dyninst.org/dyninst.
[41] Van-Thuan Pham, Marcel B√∂hme, Andrew E. Santosa, Alexandru RƒÉzvan CƒÉci-
ulescu, and Abhik Roychoudhury. Smart Greybox Fuzzing. IEEE Transactions on
Software Engineering, 2019.
[42] Ganesan Ramalingam. On Loops, Dominators, and Dominance Frontiers. ACM
transactions on Programming Languages and Systems, page 22, 2002.
[43] Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,
and Herbert Bos. VUzzer: Application-aware Evolutionary Fuzzing. In Network
and Distributed System Security Symposium, NDSS, 2017.
[44] Sanjay Rawat and Laurent Mounier. Finding Buffer Overflow Inducing Loops in
Binary Executables. In IEEE International Conference on Software Security and
Reliability, SERE, 2012.
[45] Kosta Serebryany. Continuous fuzzing with libfuzzer and addresssanitizer. In
IEEE Cybersecurity Development Conference, SecDev, 2016.
[46] Dongdong She, Kexin Pei, Dave Epstein, Junfeng Yang, Baishakhi Ray, and Suman
In IEEE
Jana. NEUZZ: Efficient Fuzzing with Neural Program Smoothing.
Symposium on Security and Privacy, Oakland, 2019.
[47] Maksim Shudrak and Battelle. drAFL, 2019. URL: https://github.com/mxmssh/
[48] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In Network
and Distributed System Security Symposium, NDSS, 2016.
[49] Robert Swiecki. honggfuzz, 2018. URL: http://honggfuzz.com/.
[50] The Clang Team. SanitizerCoverage, 2019. URL: https://clang.llvm.org/docs/
SanitizerCoverage.html.
[51] Fabian Toepfer and Dominik Maier. BSOD: Binary-only Scalable fuzzing Of
device Drivers. In International Symposium on Research in Attacks, Intrusions and
Defenses, RAID, 2021.
[52] Nathan Voss and Battelle. AFL-Unicorn, 2019. URL: https://github.com/Battelle/
[53] Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. Superion: Grammar-Aware
Greybox Fuzzing. In International Conference on Software Engineering, ICSE, 2019.
arXiv: 1812.01197.
[54] Matthias Wenzl, Georg Merzdovnik, Johanna Ullrich, and Edgar Weippl. From
Hack to Elaborate Technique‚ÄîA Survey on Binary Rewriting. ACM Computing
Surveys, 52(3), 2019.
[55] Wen Xu, Sanidhya Kashyap, Changwoo Min, and Taesoo Kim. Designing New Op-
erating Primitives to Improve Fuzzing Performance. In ACM SIGSAC Conference
on Computer and Communications Security, CCS, 2017.
[56] Wei You, Xuwei Liu, Shiqing Ma, David Perry, Xiangyu Zhang, and Bin Liang.
SLF: Fuzzing without Valid Seed Inputs. In International Conference on Software
Engineering, ICSE, 2019.
[57] Wei You, Xueqiang Wang, Shiqing Ma, Jianjun Huang, Xiangyu Zhang, XiaoFeng
Wang, and Bin Liang. ProFuzzer: On-the-fly Input Type Probing for Better Zero-
day Vulnerability Discovery. In IEEE Symposium on Security and Privacy, Oakland,
drAFL.
[23] Samuel Gro√ü and Google Project Zero. Fuzzing ImageIO, 2020. URL: https:
//googleprojectzero.blogspot.com/2020/04/fuzzing-imageio.html.
[24] Ilfak Guilfanov and Hex-Rays.
IDA, 2019. URL: https://www.hex-rays.com/
afl-unicorn.
Session 2A: Fuzzing and Bug Finding CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea3642019.
[58] Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and Taesoo Kim. QSYM: A
Practical Concolic Execution Engine Tailored for Hybrid Fuzzing. In USENIX
Security Symposium, USENIX, 2018.
[59] Michal Zalewski. American fuzzy lop, 2017. URL: http://lcamtuf.coredump.cx/afl/.
[60] Lei Zhao, Yue Duan, Heng Yin, and Jifeng Xuan. Send Hardest Problems My Way:
Probabilistic Path Prioritization for Hybrid Fuzzing. In Network and Distributed
System Security Symposium, NDSS, 2019.
Session 2A: Fuzzing and Bug Finding CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea365