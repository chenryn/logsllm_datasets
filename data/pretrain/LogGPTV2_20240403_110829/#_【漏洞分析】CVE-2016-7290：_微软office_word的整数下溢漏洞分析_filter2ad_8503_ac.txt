    eip=744fb40c esp=0024c694 ebp=0024c69c iopl=0         nv up ei pl nz ac po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210212
    MSVCR90!memmove+0xfc:
    744fb40c f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
    0:000> dds poi(@edi-4) L1
    4141415d  ????????
我们能看到我们覆写数据的指针，指向了来自esi中值对应的函数。因为esi中的数据是标记过的，我们能知道用来覆写指针的偏移。
    0:000> ?0x5d-0x41
    Evaluate expression: 28 = 0000001c
    0:000> !py mona do -a 002513c4 -s 0x78
    Hold on...
    [+] Command used:
    !py mona.py do -a 002513c4 -s 0x78
    ----------------------------------------------------    [+] Dumping object at 0x002513c4, 0x78 bytes
    [+] Preparing output file 'dumpobj.txt'
        - (Re)setting logfile dumpobj.txt
    [+] Generating module info table, hang on...
        - Processing modules
        - Done. Let's rock 'n roll.
    >> Object at 0x002513c4 (0x78 bytes):
    Offset  Address      Contents    Info
    ------  -------      --------    -----    +00     0x002513c4 | 0x41414141  = ASCII 'AAAA' 
    +04     0x002513c8 | 0x41414142  = ASCII 'AAAB' 
    +08     0x002513cc | 0x41414143  = ASCII 'AAAC' 
    +0c     0x002513d0 | 0x41414144  = ASCII 'AAAD' 
    +10     0x002513d4 | 0x41414145  = ASCII 'AAAE' 
    +14     0x002513d8 | 0x41414146  = ASCII 'AAAF' 
    +18     0x002513dc | 0x41414147  = ASCII 'AAAG' 
    +1c     0x002513e0 | 0x41414148  = ASCII 'AAAH' 
    +20     0x002513e4 | 0x41414149  = ASCII 'AAAI' 
    +24     0x002513e8 | 0x4141414a  = ASCII 'AAAJ' 
    +28     0x002513ec | 0x4141414b  = ASCII 'AAAK' 
    +2c     0x002513f0 | 0x4141414c  = ASCII 'AAAL' 
    +30     0x002513f4 | 0x4141414d  = ASCII 'AAAM' 
    +34     0x002513f8 | 0x4141414e  = ASCII 'AAAN' 
    +38     0x002513fc | 0x4141414f  = ASCII 'AAAO' 
    +3c     0x00251400 | 0x41414150  = ASCII 'AAAP' 
    +40     0x00251404 | 0x41414151  = ASCII 'AAAQ' 
    +44     0x00251408 | 0x41414152  = ASCII 'AAAR' 
    +48     0x0025140c | 0x41414153  = ASCII 'AAAS' 
    +4c     0x00251410 | 0x41414154  = ASCII 'AAAT' 
    +50     0x00251414 | 0x41414155  = ASCII 'AAAU' 
    +54     0x00251418 | 0x41414156  = ASCII 'AAAV' 
    +58     0x0025141c | 0x41414157  = ASCII 'AAAW' 
    +5c     0x00251420 | 0x41414158  = ASCII 'AAAX' 
    +60     0x00251424 | 0x41414159  = ASCII 'AAAY' 
    +64     0x00251428 | 0x4141415a  = ASCII 'AAAZ' 
    +68     0x0025142c | 0x4141415b  = ASCII 'AAA[' 
    +6c     0x00251430 | 0x4141415c  = ASCII 'AAA' 
    +70     0x00251434 | 0x4141415d  = ASCII 'AAA]' 
    +74     0x00251438 | 0xff000000
**0x03 曝光**
再次观察调用栈，注意到memmove()的调用。
    0:000> kvn L2
     # ChildEBP RetAddr  Args to Child              
    00 0024c69c 5e3f9b36 002513bf 22870ff8 000000d3 MSVCR90!memmove+0xfc
    WARNING: Stack unwind information not available. Following frames may be wrong.
    01 0024c6b0 5e413843 22870ff8 002513bf 000000d3 wwlib!DllGetClassObject+0x455a
用Hex-Rays反编译器，可以看到这个函数只是memmove()的一个封装，并在wwlib库中调用。可以重命名sub_316d9b16函数为memmove_wrapper_1。
    int __stdcall memmove_wrapper_1(void *Src, void *Dst, size_t Size)
    {
      int result; // eax@2
      if ( Size > 0x7FFFFFFF )
        result = MSO_1511(1647603307, 0);
      else
        result = (int)memmove(Dst, Src, Size);
      return result;
    }
如果大小大于MAX_INT，一个整形溢出异常被触发。另外也没有合理的校验小雨目的缓冲区的情况。
为了利用，我们得知道memmove()如何访问和被调用。
所以设置一个断点bp wwlib!DllGetClassObject+0x4554 ".printf "calling memmove(%x, %x,
%x);\n", poi(@esp), poi(@esp+4), poi(@esp+8); gc"并重新运行PoC。
    calling memmove(271164, 26fb3c, e);
    calling memmove(271172, 26fb4a, f);
    calling memmove(271148, 2266efe0, 3);
    calling memmove(27114b, 2266efe3, 3);
    calling memmove(27114e, 2266efe6, 3);
    calling memmove(271151, 2266efe9, 3);
    calling memmove(271154, 2266efec, 3);
    calling memmove(271157, 2266efef, 4);
    calling memmove(27115b, 2266eff3, 5);
    calling memmove(27122e, 27115b, 5);
    calling memmove(27115b, 2266eff8, d3);
    (5f0.59c): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=00000000 ebx=00000000 ecx=00000033 edx=00000002 esi=2266effd edi=00271160
    eip=744fb40c esp=0026c430 ebp=0026c438 iopl=0         nv up ei pl nz ac po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210212
    MSVCR90!memmove+0xfc:
    744fb40c f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
有一系列的源缓冲区是0x2266efXX开头的，并且目的缓冲区是0x002711YY。怀疑这是在一个错误的循环中多次调用memmove()。
我决定分析每个调用来判断是否是独特的。在windbg中执行‘k’命令不能继续分割它，我们已经准备在上述断点减缓执行。我决定用一个轻量的windbg插件来收集返回地址：
    from pykd import *
    mashed = 0
    for frame in getStack():
        mashed += frame.returnOffset
    print "stack hash: 0x%x" % mashed
    0:000> !py sh
    stack hash: 0x199a6804c9
现在将它添加到我们的断点，换一行并在末尾增加空格，最后重新运行：
    0:010> bu wwlib!DllGetClassObject+0x4554 ".printf "calling memmove(%x, %x, %x); ", poi(@esp), poi(@esp+4), poi(@esp+8); !py sh; gc"
    0:010> g
    ...
    calling memmove(190fa4, 18f97c, e); stack hash: 0x18a96a3a98
    calling memmove(190fb2, 18f98a, f); stack hash: 0x18a96a3a98
    calling memmove(190f88, 49d7fe0, 3); stack hash: 0x1847ab6993
    calling memmove(190f8b, 49d7fe3, 3); stack hash: 0x1847ab6993
    calling memmove(190f8e, 49d7fe6, 3); stack hash: 0x1847ab6993
    calling memmove(190f91, 49d7fe9, 3); stack hash: 0x1847ab6993
    calling memmove(190f94, 49d7fec, 3); stack hash: 0x1847ab6993
    calling memmove(190f97, 49d7fef, 4); stack hash: 0x1847ab6993
    calling memmove(190f9b, 49d7ff3, 5); stack hash: 0x1847ab6993
    calling memmove(19106e, 190f9b, 5); stack hash: 0x1847ad8b4c
    calling memmove(190f9b, 49d7ff8, d3); stack hash: 0x1847ab6993
    (7dc.71c): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=00000000 ebx=00000000 ecx=00000033 edx=00000002 esi=049d7ffd edi=00190fa0
    eip=744fb40c esp=0018c270 ebp=0018c278 iopl=0         nv up ei pl nz ac po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210212
    MSVCR90!memmove+0xfc:
    744fb40c f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
现在可以判断memmove() 在一个循环中被调用，因为在同一个栈哈希值0x1847ab6993。
**  
**
**0x05 影响**
因为不能溢出返回地址和之后在写或复制操作中会访问和用到的一些值，这个漏洞的影响非常小。
Microsoft将此漏洞修补为“Microsoft
Office信息泄露漏洞”，这在本文中介绍的上下文中说的通。然而，如果我们能够在溢出覆盖栈中.text中的一个指针，这个漏洞将影响更大。
在sub_316f3232函数中，有525处调用memmove_wrapper_1()，意味着有有多种途径可以触发这个漏洞。
另外在栈中没有一个函数使用了/GS保护，意味着如果返回地址被覆盖，没有系统级别的缓解措施能够缓解它。
**0x06 总结**
许多复杂的漏洞在office代码中一直存在，只是难以被发现。甚至更难去调查根因并开发利用，如果微软开放了符号表，将能更好的发现漏洞。