# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                  NAMES3dc0601189dd        testnginx:1         "/bin/sh -c 'nginx -…"   About a minute ago   Up About a minute   0.0.0.0:8081->80/tcp   boring_cohen在 Linux 上，为了操作 Cgroup，有一个专门的 Cgroup 文件系统，我们运行mount 命令可以查看。    
# mount -t cgroupcgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)cgroup 文件系统多挂载到 /sys/fs/cgroup下，通过上面的命令行，我们可以看到我们可以用 cgroup 控制哪些资源。对于 CPU 的控制，我在这一章的第一节讲过，Docker 可以控制cpu-shares、cpus 和 cpuset。我们在 /sys/fs/cgroup/ 下面能看到下面的目录结构。    drwxr-xr-x 5 root root  0 May 30 17:00 blkiolrwxrwxrwx 1 root root 11 May 30 17:00 cpu -> cpu,cpuacctlrwxrwxrwx 1 root root 11 May 30 17:00 cpuacct -> cpu,cpuacctdrwxr-xr-x 5 root root  0 May 30 17:00 cpu,cpuacctdrwxr-xr-x 3 root root  0 May 30 17:00 cpusetdrwxr-xr-x 5 root root  0 May 30 17:00 devicesdrwxr-xr-x 3 root root  0 May 30 17:00 freezerdrwxr-xr-x 3 root root  0 May 30 17:00 hugetlbdrwxr-xr-x 5 root root  0 May 30 17:00 memorylrwxrwxrwx 1 root root 16 May 30 17:00 net_cls -> net_cls,net_priodrwxr-xr-x 3 root root  0 May 30 17:00 net_cls,net_priolrwxrwxrwx 1 root root 16 May 30 17:00 net_prio -> net_cls,net_priodrwxr-xr-x 3 root root  0 May 30 17:00 perf_eventdrwxr-xr-x 5 root root  0 May 30 17:00 pidsdrwxr-xr-x 5 root root  0 May 30 17:00 systemd我们可以想象，CPU 的资源控制的配置文件，应该在 cpu,cpuacct这个文件夹下面。    
# lscgroup.clone_children  cpu.cfs_period_us  notify_on_releasecgroup.event_control   cpu.cfs_quota_us   release_agentcgroup.procs           cpu.rt_period_us   system.slicecgroup.sane_behavior   cpu.rt_runtime_us  taskscpuacct.stat           cpu.shares         user.slicecpuacct.usage          cpu.statcpuacct.usage_percpu   docker果真，这下面是对 cpu 的相关控制，里面还有一个路径叫docker。我们进入这个路径。    ]
# lscgroup.clone_childrencgroup.event_controlcgroup.procscpuacct.statcpuacct.usagecpuacct.usage_percpucpu.cfs_period_uscpu.cfs_quota_uscpu.rt_period_uscpu.rt_runtime_uscpu.sharescpu.stat3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfdnotify_on_releasetasks这里面有个很长的 id，是我们创建的 docker 的 id。    [3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd]
# lscgroup.clone_children  cpuacct.usage_percpu  cpu.sharescgroup.event_control   cpu.cfs_period_us     cpu.statcgroup.procs           cpu.cfs_quota_us      notify_on_releasecpuacct.stat           cpu.rt_period_us      taskscpuacct.usage          cpu.rt_runtime_us在这里，我们能看到 cpu.shares，还有一个重要的文件tasks。这里面是这个容器里所有进程的进程号，也即所有这些进程都被这些 cpu策略控制。    [3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd]
# cat tasks 394873952039526395273952839529如果我们查看 cpu.shares，里面就是我们设置的 513。    [3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd]