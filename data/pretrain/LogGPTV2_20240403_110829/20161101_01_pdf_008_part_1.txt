WAL Internals Of
PostgreSQL
Contents
REDO Definition
Redo Implementation in PostgreSQL
Key Structures Used in PostgreSQL
Advantages & Disadvantages of PostgreSQL Implementation
Redo Implementation in Oracle
Advantages & Disadvantages of Oracle Implementation
Improvements in PostgreSQL
Detailed method for one of the improvements
REDO Definition
• Redo logs contain a history of all changes made to the database.
• Redo log files are used by
– Recovery
– Incremental Backup and Point In Time Recovery
– Replication
• Every change made to the database is written to the redo log file
before it is written to the data file.
• The redo log buffer is flushed to the redo log file when a COMMIT
is issued.
• A background log writer process to flush Redo in case if the
database setting is such that Redo should be flushed in a batch.
• Redo is not required for temporary tables.
REDO Definition
Redo Implementation in PostgreSQL
Key Structures Used in PostgreSQL
Advantages & Disadvantages of PostgreSQL Implementation
Redo Implementation in Oracle
Advantages & Disadvantages of Oracle Implementation
Improvements in PostgreSQL
Detailed method for one of the improvements
Jargons
• WAL – Write Ahead Log. It is used in context of transaction log files.
• Xlog - Transaction log. It is used in context of transaction log
buffers.
• LSN – Log sequence number. It is used to mark position of log in
pages.
• Bgwriter – Background writer.This is used to flush shared buffers
and perform checkpoint.
• Clog - Commit log. It is used in context of transaction status buffers.
• Partial Page Write – This happens when OS is able to write partial
page in disk files which can cause corruption.
Redo Implementation in PostgreSQL
• In PostgreSQL, Redo logs are known by Write Ahead Logs (WAL)
and it is ensured that log entries must reach stable storage before
the data-page changes they describe.
• To guarantee above,
- Each data page (either heap or index) is marked with the
LSN (log sequence number --- in practice, a WAL file location) of
the latest XLOG record affecting the page.
- Before the bufmgr can write out a dirty page, it must ensure
that xlog has been flushed to disk at least up to the page's LSN.
• This low-level interaction improves performance by not waiting for
WAL I/O until necessary.
• Temporary table operations doesn’t get logged.
Redo Record Data
INSERT UPDATE DELETE
INSERT INTO score UPDATE score DELETE FROM score
(team, runs, wickets) SET WHERE team = 'AUS';
VALUES runs = 104,
('AUS',100,4); wickets = 5
WHERE team = 'AUS';
Header Info : crc, Header Info : crc,
Header Info : crc,
RM_HEAP_ID, Xid,len, RM_HEAP_ID, Xid,len,
RM_HEAP_ID, Xid,len,
XLOG_HEAP_INSERT XLOG_HEAP_UPDATE
XLOG_HEAP_DELETE
Data : tupleid, infobits,
Data : tupleid
Data : oldtupid, newtupid,
c0: 'AUS'
infobits,
c1: 100
c0: 'AUS'
c2: 4
c1: 104
c2: 4
Algorithm For WAL Action
• Pin and take Exclusive-lock on buffer containing the data page to be
modified
• Start the critical section which ensures that any error occur till End of
critical section should be a PANIC as buffers might contain
unlogged changes.
• Apply changes to buffer.
• Mark the buffer as dirty which ensures bgwriter (checkpoint) will
flush this page and marking buffer dirty before writing log record
ensures less contention for content latch of buffer.
• Build a record to be inserted in transaction log buffer.
• Update the Page with LSN which will be used by bgwriter or flush
operation of page to ensure that corresponding log is flushed from
buffer.
• End Critical section.
• Unlock and unpin the buffer.
Important Locks Used In WAL
• WALInsertLock
• This lock is used to insert transaction log record contents into
transaction log memory buffer. First this lock is taken then whole
contents including full buffers (if full_page_writes is on) are copied
into log buffers.
• Other places where this lock is used
- During flush of log buffers to check if there are any more
additions to log buffer since last it is decided till log buffer flush
point.
- To determine the Checkpoint redo location
- During Online backup to enforce Full page writes till the
backup is finished.
- to get the current WAL insert location from built in function.
Important Locks Used In WAL
• WALWriteLock
• This lock is used to write transaction log buffer data to WAL file.
After taking this lock all the transaction log buffer data upto pre-
decided point will get flushed.
• Places where it get used are
- Flush of transaction log which can be due to Commit, Flush
of data buffers, truncate of commit log etc.
- During Switch of Xlog.
- During get of new Xlog buffer, if all buffers are already
occupied and not flushed.
- Get the time of the last xlog segment switch
Write Ahead Log Files
• The transaction log files are stored in $PGDATA/pg_xlog
directory. They are named as 000000020000070A0000008E.
- The first 8 digits identifies the timeline,
- The following 8 digits identifies the (logical) xlog file and
- The last ones represents the (physical) xlog file (Segement)
• The physical files in pg_xlog directory are not actually the xlog
files;
PostgreSQL calls it segments.
• Each Segment contains Bocks of 8K and Segment size is 16M.
Block 0 Block 1 Block 2 … Block 255
1. Seg Hdr 1. Block Header 1. Block Header
2. Block Header 2. WAL Records 2. WAL Records 1. Block Header
3. WAL Records 3. Each WAL record 3. Each WAL record 2. WAL Records
Each WAL record has header. has header. 3. Each WAL record
has header. WAL 4,5 WAL 5,6,7,8 has header.
WAL 1, 2 ,3 WAL m,n,…
Switch Transaction Log Segment
• What is XLOG SWITCH?
It means to change the current xlog segment file to next
segment file.
• What all needs XLOG SWITCH?
• At Archive timeout, so that current files can be archived.
• At Shutdown, so that current files can be archived.
• At start of online backup
• By built-in function pg_switch_xlog
Async Commit
• In this mode, the WAL data gets flushed to disk after predefined
time by a background WAL writer process.
• Commit only updates the WAL record pointer upto which
background process needs to flush.
• In worst-case three walwriter cycles will be required to flush the
WAL buffered data.
• We must not set a transaction-committed hint bit on a relation page
and have that record make it to disk prior to the WAL record of the
commit. This can maintain transaction status consistency across
crash recovery.
Protection against partial writes in disk
• Data Page Partial Write Protection
• To protect the data page partial write, the first WAL record
affecting a given page after a checkpoint is made to contain a copy
of the entire page, and we implement replay by restoring that page
copy instead of redoing the update.
• WAL Page Partial Write Protection
• Each WAL record contains CRC and checking the validity of the
WAL record's CRC will detect partial write.
• Each WAL page contains a magic number, the validity of which is
checked after reading each page.
REDO Definition
Redo Implementation in PostgreSQL
Key Structures Used in PostgreSQL
Advantages & Disadvantages of PostgreSQL Implementation
Redo Implementation in Oracle
Advantages & Disadvantages of Oracle Implementation
Improvements in PostgreSQL
Detailed method for one of the improvements
XLogRecord
• Fixed size log record header which sits in the beginning of each log
record.
• Stores the information of current transaction id.
• Stores CRC to validate the log record.
• Stores total length of record
• Info bits to indicate whether backup block information is present.
• Resource manager id to indicate type of resource of log record
XLogRecData
• The resource manager data is defined by a chain of one or more
XLogRecData structs.
• - Multiple structs are used when backup pages needs to be
written
• when the buffer is backed up, it does not insert the data pointed to
by this XLogRecData struct into the XLOG record
• Flag to indicate whether free space of backup page can be omitted.
• Actual data of record
• Buffer associated with data
BkpBlock
• Header information for backup block. This is appended to Xlog
Record.
• Stores information about hole inside backup page
• Stores information for relation containing block
• Follows it is the actual backup page data
REDO Definition
Redo Implementation in PostgreSQL
Key Structures Used in PostgreSQL
Advantages & Disadvantages of PostgreSQL Implementation
Redo Implementation in Oracle
Advantages & Disadvantages of Oracle Implementation
Improvements in PostgreSQL
Detailed method for one of the improvements
Advantages/Disadvantages Of PG Implementation
• Advantages
1. One of the Advanced features of PostgreSQL is it its ability to perform
transactional DDL’s via its Write Ahead Log design.
2. Removing holes of data page and then write to WAL will have less I/O if
pages are not full.
3. WAL data written for Insert and Delete operation is lesser than systems
having UNDO (Oracle).
4. During ASync Commit, writing data only in blocks ensures less usage of
I/O bandwidth.
5. Keeping Log Sequence Number on each page ensures that during dirty
page flush Buffer Manager doesnot need to wait for Flush of WAL until
necessary.
Advantages/Disadvantages Of PG Implementation
• Disadvantages
1. Flushing data pages during Commit can be heavier.
2. Update operation writes whole row in WAL even if 1 or 2
columns are modified. This can lead to increase in overall
WAL traffic.
3. During Async Commit, each time to check tuple visibility it
needs to refer CLOG Buffer/File which is costly.
4. Calculating CRC for each WAL can be costly especially in
case during full data page writes.
REDO Definition
Redo Implementation in PostgreSQL
Key Structures Used in PostgreSQL
Advantages & Disadvantages of PostgreSQL Implementation
Redo Implementation in Oracle
Advantages & Disadvantages of Oracle Implementation
Improvements in PostgreSQL
Detailed method for one of the improvements
Redo Log Files
• Redo log uses operating system block size
– usually 512 bytes
– format dependent on
• operating system
• Oracle version
• Each redo log consists of
– header
– redo records
• Redo log is written sequentially
...
Block 0 Block 1 Block 2 Block 3 Block 4 Block M
File Redo Redo Redo Redo Redo
Header Header Record Records Records Record
1 2 & 3 3 & 4 N
Redo Records
• A redo record consists of
– redo record header
– one or more change vectors
• Each redo record contains undo and redo for an atomic change
• Some changes do not require undo
.....
Redo
Change Change Change Change
Record
#1 #2 #3 #N
Header
Redo Record Header
• Every redo record has a header
REDO RECORD - Thread:1 RBA: 0x003666.000000cf.0010 LEN: 0x019c VLD: 0x01
SCN: 0x0000.00eb1279 SUBSCN: 1 05/08/2003 15:44:12
• Fields include
Thread Thread Number
RBA Redo Byte Address
LEN Length of record in
bytes
SCN System Change
Number
Date and Time of
Change
Redo Byte Address (RBA)
• Every redo record has a Redo Byte Address (RBA) e.g.
RBA: 0x003666.000000cf.0010
• RBA is 10 bytes in length