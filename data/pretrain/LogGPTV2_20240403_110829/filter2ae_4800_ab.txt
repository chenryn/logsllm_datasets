>> 主要用于在目标机器上做跳板，进而可以对内网进行攻击
  * 四种基本的网络情况
  *     * 攻击者有独立外网IP，拿到shell的服务器也有独立的外网IP
  *     * 攻击者有独立外网IP，拿到shell的服务器在内网，只有几个映射端口
  *     * 攻击者在内网，服务器也在内网只有几个映射端口
  *     * 攻击者在内网，服务器有独立外网IP
四种情况有不同拿下服务器的方式
## 端口转发
  * 原理  
端口转发是转发一个 **网络端口** 从 **一个网络节点到另一个网络节点**
的行为。使一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址(局域网内部）上的一个端口。  
简单地说︰端口转发就是将一个端口（这个端口可以本机的端口，也可以是本机可以访问到的任意主机的端口）转发到 **任意一台可以访问到的IP**
上，通常这个IP是公网ip
  * 端口转发场景∶  
外网主机A已经可以任意连接内网主机B上的端口，但是无法访问内网主机C上的端口  
此时可以将C主机的端口转发到B主机的端口，那么外网主机A访问B主机的某某端口就相当于访问了C主机的某某端口  
### 端口转发工具
#### lcx
> lcx是一个居于socket套接字实现的端口转发工具，有windows和linux两个版本，windows叫lcx.exe,linux叫portmap  
>  一个正常的socket隧道必须具备两端：服务器端和客户端
##### windows下：
>   * 转发端口：`lcx.exe -slave 公网IP 端口 内网IP 端口`
>   * 监听端口：`lcx.exe -listen 转发端口，本机任意没有没有被占用的端口`
>   * 映射端口：`lcx.exe -tran 映射端口号 ip 目标端口`
>
  * 本地端口映射:如果目标服务器由于防火墙的限制，部分端口的数据无法通过防火墙，可以将目标服务器相应端口的数据传到 **防火墙允许的其他端口**  
`lcx.exe -tran 映射端口号 目标ip 目标端口`
  * 内网端口转发：如下规则时，主机不能直接访问内网，这时就需要web服务器当 **跳板** ，也就是 **代理** 来使攻击机访问到内网主机  
基本命令：  
·转发端口`lcx.exe -slave 公网ip 端口 内网ip 端口`  
·监听端口`lcx.exe -listen 转发端口 本机任意没有被占用端口`
> windows端口转发实例  
>  环境︰内网主机不能访问外网，但是可以访问同网段的内网机器，同时80端口只能本地访问，但是8080端口对外开放。
>
>> 步骤一:被控服务器的80端口转发到本地的8080端口 `lcx -tran 8080 127.0.0.1 80`  
>  步骤二∶在内网被控服务器上连接内网能够对外访问的服务器 `lcx -slave 192.168.56.1 4444 192.168.56.101
> 8080`  
>  步骤三∶在能够对外访问的内网机器上监听端口 `lcx -listen 4444 12345`  
>  步骤四∶外网机器访问192.168.56.1的12345端口也就是从 **服务器12345- >服务器4444->外网8080->内网80**  
>  在外网192.168.64.230访问192.168.64.103:12345
##### linux下：
用法: `./portmap -m method [-h1 host1] -p1 port1 [-h2 host2] -p2 port2 [-v]
[-log filename]`  
v:version
> -m:指定method action参数  
>  method=1:监听port1连接至主机2的port2(端口映射)  
>  method=2:监听Port1转发至port2  
>  method=3:连接主机1对应的端口和主机2对应的端口(端口转发)
如:`./portmap -m 2 -p1 6666 -h2 公网ip -p2 7777`//监听来自6666端口的请求并转发至7777
#### frp
  * FRP(fast reverse proxy)是用go语言开发的 **反向代理应用** ，可以进行 **内网穿透**
  * frp支持tcp\udp\http\https
frp用处
>   1. 利用处于 **内网** 或 **防火墙** 的机器，对外网提供http\https\tcp\udp服务
>   2. 对于http,https服务支持基于域名的虚拟主机，支持自定义域名，是多个域名共用一个80端口
>
下载后frp文件内frps,frps.ini为服务端程序和配置文件，frpc,frpc.ini是客户端程序及配置文件
>   * 服务端设置
>
>
>> 修改frp.ini  
>  文件格式：
>>  
>>  
>>     [common]
>>     bind_port = 7000 #frp服务器监听㐰
>>     dashboard_port = 7500 #web后台监听端口
>>     dashboard_user =admin #web后台用户名及密码
>>     dashboard_pwd = admin
>>     token = 123456 #客户端和服务器的连接口令
>>
>> 运行frps服务器端 `./frps -c frps.ini` #-c意思是加载配置文件  
>  访问x.x.x.x:7500，使用自己设置的用户名和密码登录
>
>   * 客户端设置
>
>
>> 修改frpc.ini文件
>>  
>>  
>>     [common]
>>     server_addr = 192.168.152.217
>>     #服务端IP地址
>>     server_port = 7000
>>     #服务器端口
>>     token = 123456
>>     #服务器上设置的连接口令
>>     [http]
>>     #自定义规则，[xxx]表示规则名
>>     type = tcp
>>     #type:转发的协议类型
>>     local_ip = 127.0.0.1
>>     local_port = 3389
>>     #本地应用的端口号
>>     remote_port = 7001
>>     #这条规则在服务端开放的端口号
>>
>> 配置完成frp.ini后，cmd运行frpc(和服务端一样-c指定配置文件)  
>  在局域网外客户端连接服务端的remote_port端口
该工具可跨平台，也就是windows exe程序连接linux  
上述操作也就 **相当于listen 7000转到7001** 然后连接
#### metasploit portfwd
  * 简介  
一款内置于meterpreter
shell中的工具，直接访问攻击系统无法访问的机器。在可以访问攻击机和靶机的受损主机上运行此命令，可以通过本机转发TCP连接，成为一个支点。
> 选项  
>  -L∶要监听的本地主机(可选).  
>  -l : 要监听的本地端口，与此端口的连接将被转发到远程系统·  
>  -p∶要连接的远程端口，TCP连接将转发到的端口  
>  -r∶要连接的远程主机的IP地址  
>  参数  
>  Add :该参数用于 **创建** 转发  
>  `portfwd add -I 本地监听端口号 -p 目标端口号 -r 目标机IP地址`  
>  Delete :这将从转发端口列表中删除 **先前的** 条目.  
>  `portfwd delete -I 本地监听端口号 -p 目标端口号 -r 目标机IP地址`  
>  List : **列出** 当前转发的所有端口  
>  `portfwd list`  
>  Flush :这将删除转发列表中的 **所有** 端口
这个不太稳定，不如frp，lcx不怎么用了。
# 边界代理
代理类别：HTTP代理、socks代理、telnet代理、ssl代理  
代理工具：EarthWorm、reGeorg(http代理)、proxifier(win)、sockscap64(win)、proxychains(linux)
内网通过代理连接外部网络为正向代理，外网通过代理连接内网为反向代理。  
负载均衡服务器：将用户的请求分发到空闲服务器上。
  * socks代理  
当通过代理服务器访问一个网站时，socks服务器起到了一个中间人的身份，分别与两方通信然后将结果告知另一方。只要配置好socks代理后无需指定
**被访问目标** 。  
socks和http代理走的是tcp流量，意思是udp的协议不能用这两种代理
  * 代理和端口转发的异同：
代理 | 端口转发  
---|---  
需要socks协议支持 | 无需协议支持  
一对多，访问网络 | 一对一，帮助他人访问某端口  
socks代理可以理解为lcx端口转发，他在服务端监听一个服务端口，有连接请求时会从socks协议中解析出访问目标url的目标端口
**意思就是，有代理就不需要他娘的端口转发了，还指定端口转来转去脑子都转晕了，代理不需要那么多花里胡哨的。**
## **proxychains**
  * proxychains是一个开源代理工具，可以在linux下全局代理。proxychains通过一个用户定义的代理列表强制连接指定的应用程序，支持http\socks4\socks5类型。
  * 使用
>   1. 在使用工具前要对工具进行配置，配置文件:/etc/proxychains.conf  
>  删除dynamic_chain的注释  
>  底部添加代理服务器  
>  `proxychains 软件名`以代理启动任意软件
>
## regeorg工具
  * regeorg主要是把内网服务器端口通过http/https隧道转发至本机，形成回路
  * 用于目标服务器在 **内网或做了端口策略** 的情况下连接目标服务器内部开放端口
  * 利用webshell建立一个socks代理进行内网穿透，则服务器必须支持aspx\php\jsp中的一种
  * regeorg分为服务端和客户端。 **服务端有php\aspx\jsp\node.js等多种，客户端为python** ，所以用的时候文件里面找对应脚本
### regeorg使用
和proxychains结合使用
  1. pip install安装
  2. 假设服务器是php版本，将regeorg里的php上传到服务器，直接访问显示"georg says,'all seems fine'"，为正常运行  
  1. 终端下运行:`python reGeorgSocksProxy.py -u 靶机reGeorg脚本地址 -p 本地监听端口`
  2. 再起一个终端修改proxychains.conf配置文件，删除dynamic_chain的注释，在ProxyList最后加一行`socks5 127.0.0.1 本地监听端口`，并把其他的注释  
代理就配置好了
  1. 使用`proxychains 命令`，流量会自动从配置文件端口经过(python跑的脚本终端别关)
但是在msf外配置的代理,msf内部流量是不会走代理过的
## msf route
msf框架中自带路由转发功能，在已经获取meterpreter shell的基础上添加一条去往内网的路由  
路由添加： `run autoroute -s 内网网端`  
`run autoroute -p` 查看路由添加情况
## proxifiler
proxifiler为windows客户端代理工具， **socks5客户端**
，可以让不支持通过代理服务器工作的程序通过https或socks5代理或代理链
  * 支持socks4\socks5\http\tcp\udp。有gui  
使用:profil配置代理ip和端口。proxification rules设置代理规则，不需要代理的设为direct模式