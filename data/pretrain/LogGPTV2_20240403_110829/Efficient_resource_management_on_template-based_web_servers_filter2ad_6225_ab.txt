### 授权与下载信息
授权使用仅限于：清华大学。下载时间：2021年3月20日 09:57:38 UTC，来源：IEEE Xplore。适用限制。

### 摘要
本文提出了一种新的请求调度方法，旨在显著提高多线程Web服务器的性能。该方法考虑了当前的趋势，即通过分离不同的任务到多个线程池中来优化请求处理流程。具体来说，Web服务器将解析请求头、生成数据和渲染模板的任务分配给不同的线程池。此外，数据库连接仅分配给负责数据生成的线程，以避免在渲染模板或提供静态内容时数据库连接闲置。这种方法有效地减少了数据库作为瓶颈的可能性，并提高了整体响应速度和吞吐量。我们还实现了类似于最短作业优先（Shortest Job First, SJF）调度的效果，但不会导致长时间运行的任务被饿死。进一步地，我们将CherryPy Web服务器与Django模板语言结合，验证了所提方法的有效性，结果显示，对于大多数网页，平均响应时间降低了两个数量级，而在高负载下，总体吞吐量提升了31.3%。

### 目录
- 第2节：现代Web应用程序技术背景
- 第3节：提议的请求调度方法详解
- 第4节：评估结果展示
- 第5节：相关工作的讨论
- 第6节：结论

### 2. 背景
尽管单进程事件驱动架构可以为缓存工作负载和静态Web内容提供出色的性能，但对于磁盘绑定的工作负载和动态生成的内容，多线程架构通常表现更佳。目前，大多数流行的商业网站都采用多线程服务器提供Web服务。本节将详细说明激励我们工作的两个关键问题：(1) Web模板模型相对于传统动态内容生成模型的优势；(2) 多线程Web服务器中传统请求处理模型的不足之处。

#### 2.1 使用Web模板
以下示例展示了使用Web模板与传统Web编程方式之间的差异。图1展示了传统方式下动态Web内容的生成过程，代码作为一个Python Server Page编写，允许在HTML中嵌入Python代码。这种方式混合了数据生成和表示代码，使得大型项目难以维护。相比之下，使用现代Web服务器如CherryPy及模板语言如Django，则可将内容与表示代码分离，从而简化开发流程并提高可读性和可维护性。

#### 2.2 线程每请求模型
多线程Web服务器中最常用的请求处理模型是线程每请求模型。在此模型中，每个传入请求由一个单独的监听线程接收后，会被分派给线程池中的一个独立线程进行处理，直到返回结果给客户端为止。为了防止资源过度消耗，线程池大小通常受到限制，同时，有限数量的数据库连接也被共享。然而，这种模型不支持最近流行的Web模板趋势，即分离内容代码和表示代码。因此，在执行呈现操作的同时仍持有数据库连接，会导致宝贵的数据库连接资源被浪费。

### 3. 设计
本节首先介绍了对Web模板必要的修改以支持新的请求调度方法，然后详细阐述了线程池的设计及请求调度策略。我们以CherryPy为例说明现代模板支持的多线程Web服务器设计，并使用Django作为现代Web模板的例子。

#### 3.1 对Web模板的修改
为了支持提出的请求调度方法，需要对Web应用的模板进行轻微调整。这些调整不影响CherryPy代码的基本编写方式。主要区别在于函数不再直接返回渲染后的模板，而是返回未渲染的模板及其渲染所需的数据。例如，在Django实现中，传统的返回语句为`return get_template("tmpl.html").render(Context(data))`，而我们的修改版本则为`return ("tmpl.html", data)`。这样做的好处是保持了模板代码的一致性，便于广泛采用。

#### 3.2 线程池
我们的新模型包含一个监听线程以及五个不同类型的线程池：请求头解析、静态请求处理、一般动态请求处理、长时间动态请求处理和模板渲染。每个线程池都有自己的同步队列。当接收到新请求时，监听线程会将其传递给适当的线程池进行处理。通过这种方式，我们可以更高效地管理和利用系统资源，同时保证不同类型请求得到最优处理。

以上是对原始文本的专业化和清晰度提升后的版本。希望这能帮助您更好地理解原文内容。