SET "name" "john"
客户端B
第19章
务·311
---
## Page 316
312·第四部分独立功能的实现
该客户端的事务安全性已经被破坏。
touchWatchKey函数会将监视被修改键的客户端的 REDIS_DIRTY_CAS 标识打开，表示
进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么
等等，在执行之后都会调用multi.c/touchWatchKey函数对 watched_keys 字典
19.2.2
touchWatchKey函数的定义可以用以下伪代码来描述
所有对数据库进行修改的命令，比如 SET、LPUSH、SADD、ZREM、DEL、FLUSHDB
如果键"address" 被修改，那么 c2 和 c4 两个客户端的 REDIS_DIRTY_CAS 标
watched_keys
 如果键"age"被修改，那么 c3 和c10086 两个客户端的 REDIS_DIRTY_CAS 标
如果键"name"被修改，那么c1、c2、cl0086三个客户端的 REDIS_DIRTY
举个例子，
def touchwatchKey (db, key) :
"address"
识将被打开。
CAS 标识将被打开。
"age""
"name"
识将被打开。
if key in db.watched_keys:
#如果键key存在于数据库的 watched keys字典中
监视机制的触发
那么说明
，对于图19-5所示的 watched_keys 字典来说：
for client in db.watched_keys [key]:
#遍历所有监视键 key 的客户端
client.flags |= REDIS_DIRTY_CAS
#打开标识
至小
c1
2
watched_keys
"address"
"age"
"name"
个客户端在监视这个key
c
2
图19-4 执行 WATCH 命令之后的 watched_keys 字典
c2
c3
cl
watched_keys
"address"
"age"
"name"
c10086
C4
c2
c10086
2
3
c1
C4
 c2
010086
---
## Page 317
那么当c10086执行以下WATCH命令之后：
到失败的整个过程。
19.2.4
务器会拒绝执行它们提交的事务，以此来保证事务的安全性。
REDIS_DIRTY_CAS 标识将被打开。当这三个客户端向服务器发送 EXEC命令的时候，服
行事务：
REDIS_DIRTY_CAS 标识来决定是否执
19.2.3
假设当前客户端为 cl0086，而数据库watched_keys字典的当前状态如图19-7所示,
为了进一步熟悉 WATCH命令的运作方式，让我们来看一个带有WATCH的事务从开始
如果客户端的 REDIS_DIRTY
当服务器接收到一个客户端发来的EXEC 命令时，服务器会根据这个客户端是否打开了
图 19-7执行WATCH命令之前的
watched_keys 字典将更新至图 19-8 所示的状态。
c10086> WATCH "name"
这个判断是否执行事务的过程可以用流程图19-6来描述。
口 如果客户端的 REDIS_DIRTY_CAS 标识没有被打开，那么说明客户端监视的所有键
吴
watched_keys
客户端提交的这个事务。
都没有被修改过（或者客户端没有监视任何键），事务仍然是安全的，服务器将执行
行客户端提交的事务。
不再安全，所以服务器会拒绝执
客户端所监视的键当中，至少有
CAS 标识已经被打开，那么说明
情况下，客户端提交的事务已经
一个键已经被修改过了，在这种
"address"
一个完整的WATCH事务执行过程
"name"
判断事务是否安全
watched_keys 字典
"age"
c1
H
拒绝执行客户端提交的事务
watched_keys
图19-6服务器判断是否执行事务的过程
"address"
图19-8执行WATCH 命令之后的
"age"
"name"
watched_keys 字典
客户端向服务器发送EXEC命令
标识是否已经打开？
REDIS_DIRTY
，如果某个客户端对"name
是
客户端的
21086
”执行客户端提交的事务
否
CAS
第19章
事 
务313
---
## Page 318
314·第四部分独立功能的实现
行，因此，Redis 的事务是具有原子性的。
就执行事务中的所有操作，要么就一个操作也不执行。
（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有耐久性（Durability）。
19.3.1 原子性 
19.3 事务的 ACID 性质
CAS 标志已经被打开，所以服务器将拒绝执行它提交的事务：
DIRTY_CAS 标识被打开，其中包括客户端c10086。
置成了"john"：
队列：
对于 Redis 的事务功能来说，事务队列中的命令要么就全部都执行，要么就一个都不执
事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么
之后，当c10086 向服务器发送EXEC命令时候，因为 c10086的 REDIS_DIRTY_
举个例子，以下展示的是一个成功执行的事务，事务中的所有命令都会被执行
以下四个小节将分别对这四个性质进行讨论。
在Redis中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性
在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。
就在这时，另一个客户端c999向服务器发送了一条SET命令，将"name”键的值设
接下来，客户端c10086 继续向服务器发送 MULTI命令，并将一-个 SET命令放人事务
redis> SET msg "hello"
c10086> EXEC
uuuo5n uaueu, Las  SET "name" "peter"
C10086> MULTI
QUEUED
(nil)
QUEUED
---
## Page 319
无论事务是否执行成功，数据库也应该仍然是一致的。
19.3.2
所以他认为没有必要为 Redis 开发事务回滚功能。
程错误产生的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，
Redis 追求简单高效的设计主旨不相符，并且他认为，Redis 事务的执行时错误通常都是编
继续执行下去，并且之前执行的命令也不会有任何影响：
去，直到将事务队列中的所有命令都执行完毕为止。
（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下
绝执行，事务中的所有命令都不会被执行：
事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，
在下面的这个例子中，即使 RPUSH命令在执行期间出现了错误，事务的后续命令也会
Redis 的作者在事务功能的文档中解释说，不支持事务回滚是因为这种复杂的功能和
Redis 的事务和传统的关系型数据库事务的最大区别在于，Redis 不支持事务回滚机制
QUEUED
redis> RPUSH msg "good bye" "bye bye” # 错误地对字符串键 msg 执行列表键的命令
redis> GET msg
redis> MULTI
与此相反，以下展示了一个执行失败的事务，这个事务因为命令人队出错而被服务器拒
QUEUED
redis>ExEC
QUEUED
redis> GET
OK
2) "hello"
(error)
一致性
SADD fruit "apple" "banana" "cherry"
ERR wrong number of arguments for 'get' command
 WRONGTYPE Operation against a key holding the wrong kind of value
第19章
事
务+315
---
## Page 320
316·第四部分独立功能的实现
有人队错误的事务影响。
客户端提交的事务会被服务器拒绝执行：
况，那么 Redis 将拒绝执行这个事务。
务的一致性的。
绍三个 Redis 事务可能出错的地方，并说明 Redis 是如何妥善地处理这些错误，从而确保事
和 GET命令被执行了，而错误的YAHOOOO则被忽略了：
Redis 2.6.4 版本上测试的，可以看到，事务可以正常执行，但只有成功入队的 SET命令
事务一样可以执行，不过被执行的命令只包括那些正确入队的命令。以下这段代码是在
在以下展示的示例中，因为客户端尝试向事务人队一个不存在的命令YAHOOOO，所以
因为服务器会拒绝执行人队过程中出现错误的事务，所以 Redis事务的一致性不会被带
redis> MULTI
如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情
1.入队错误
Redis 通过谨慎的错误检测和简单的设计来保证事务的一致性，以下三个小节将分别介
(error) EXECABoRT Transaction discarded because of previous errors.
redis> EXEC
redis> GET msg
redis> SET msg "hello"
“一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。
根据文档记录，在Redis 2.6.5 以前的版本，即使有命令在入队过程中发生了错误，
QUEUED
redis>YAHOOOO
QUEUED
2
1)OK
QUEUED
redis> GET msg
redis> YAHOO0O
QUEUED
redis> SET msg "heilo"
OK
redis> MULTI
(error)
"hello"
 ERR unknown command 'YAHOOO0'
Redis 2.6.5 以前的入队错误处理 
---
## Page 321
能有以下情况出现：
所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响。
并且这种错误只能在事务执行（也即是命令执行）期间被发现：
然后在事务里面尝试对"msg”键执行只能用于列表键的 RPUSH命令，这将引发一个错误
在 2.6.5 以前的版本中，Redis 事务的一致性也不会被入队错误影响。
口如果服务器运行在RDB 模式下，那么在事务中途停机不会导致不一致性，因为服务
口如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因
如果 Redis 服务器在执行事务的过程中停机，那么根据服务器所使用的持久化模式，可
3.服务器停机
因为在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理,
" "α" ", naqeudre aavs  EXEC
QUEUED
QUEUED
QUEUED
redis>
对数据库键执行了错误类型的操作是事务执行期间最常见的错误之一。
口即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执
?
口执行过程中发生的错误都是一些不能在人队时被服务器发现的错误，这些错误只会
关于这种错误有两个需要说明的地方：
除了人队时可能发生错误以外，事务还可能在执行的过程中发生错误。
2.执行错误
此数据总是一致的。
在命令实际执行时被触发。
因为错误的命令不会被入队，所以 Redis 不会尝试去执行错误的命令，因此，即使
被出错的命令影响。
(integer) 3
行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会
(error) WRONGTYPE Operation against a key holding the wrong kind of value
"Azau?" "eueuea" uatdde, arntg Cavs 
第19章
务
·317
---
## Page 322
318·第四部分独立功能的实现
提供任何额外的持久化功能，所以 Redis 事务的耐久性由 Redis 所使用的持久化模式决定：
的结果也不会丢失。
永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得
19.3.4耐久性
事务也总是具有隔离性的。
在执行事务期间不会对事务进行中断，因此，Redis 的事务总是以串行的方式运行的，并且
影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。
19.3.3隔离性
会影响数据库的一致性。
因为 Redis 的事务不过是简单地用队列包裹起了一组 Redis 命令，Redis 并没有为事务
因为 Redis 使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，
事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到
口当服务器运行在 AOF 持久化模式下，并且 appendfsync 选项的值为 everysec
口当服务器在无持久化的内存模式下运作时，事务不具有耐久性：一旦服务器停机，
事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相
口当服务器运行在 AOF 持久化模式下，并且 appendfsync 选项的值为 always 时,
综上所述，无论Redis 服务器运行在哪种持久化模式下，事务执行中途发生的停机都不
口女
那一秒钟之内，这可能会造成事务数据丢失，所以这种配置下的事务不具有耐久性。
时，程序会每秒同步一次命令数据到硬盘。因为停机可能会恰好发生在等待同步的
程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘里
证事务数据被第一时间保存到硬盘里面，因此 RDB 持久化模式下的事务也不具有耐
当服务器在RDB 持久化模式下运作时，服务器只会在特定的保存条件被满足时，才
包括事务数据在内的所有服务器数据都将丢失。
面，因此这种配置下的事务是具有耐久性的。
久性。
会执行BGSAVE命令，对数据库进行保存操作，并且异步执行的BGSAVE不能保
总是一致的。
果找不到可供使用的AOF 文件，那么重启之后的数据库将是空白的，而空白数据库
器可以根据现有的AOF 文件来恢复数据，从而将数据库还原到一个一致的状态。如
如果服务器运行在AOF模式下，那么在事务中途停机不会导致不一致性，因为服务
总是一致的。
果找不到可供使用的 RDB 文件，那么重启之后的数据库将是空白的，而空白数据库
器可以根据现有的 RDB 文件来恢复数据，从而将数据库还原到一个一致的状态。如
---
## Page 323
19.4重点回顾
久性：
appendfsync-on-rewrite 处于关闭状态。