# CVE-2021-3490 eBPF 32位边界计算错误漏洞利用分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
**影响版本** ：Linux 5.7-rc1以后，Linux 5.13-rc4 以前； v5.13-rc4已修补，v5.13-rc3未修补。
评分7.8分。
**测试版本** ：Linux-5.11 和 Linux-5.11.16
[exploit及测试环境下载地址](https://github.com/bsauce/kernel-exploit-factory)—
**编译选项** ：`CONFIG_BPF_SYSCALL`，config所有带BPF字样的。 **CONFIG_SLAB=y**
`General setup` —-> `Choose SLAB allocator (SLUB (Unqueued Allocator))` —->
`SLAB`
在编译时将`.config`中的`CONFIG_E1000`和`CONFIG_E1000E`，变更为=y。[参考](https://blog.csdn.net/qq_16097611/article/details/104965045)
    $ wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v4.x/linux-5.11.16.tar.xz
    $ tar -xvf linux-5.11.16.tar.xz
    # KASAN: 设置 make menuconfig 设置"Kernel hacking" ->"Memory Debugging" -> "KASan: runtime memory debugger"。
    $ make -j32
    $ make all
    $ make modules
    # 编译出的bzImage目录：/arch/x86/boot/bzImage。
**漏洞描述** ：Linux内核中按位操作（AND、OR 和 XOR）的 eBPF ALU32 边界跟踪没有正确更新 32 位边界，造成 Linux
内核中的越界读取和写入，从而导致任意代码执行。三个漏洞函数分别是
[scalar32_min_max_and()](https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7078)
、[scalar32_min_max_or()](https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7149)、[scalar32_min_max_xor()](https://elixir.bootlin.com/linux/v5.13-rc3/source/kernel/bpf/verifier.c#L7219)。`AND/OR`
是在 Linux 5.7-rc1 中引入，`XOR` 是在 Linux 5.10-rc1中引入。
**补丁**
：[patch](https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=049c4e13714ecbca567b4d5f6d563f05d431c80e)
若低32位都为 known，则调用
[__mark_reg32_known()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1053)，将32位边界设置为reg的低32位（常数），保证最后更新边界时，有正确的边界。
    diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
    index 757476c91c984..9352a1b7de2dd 100644
    --- a/kernel/bpf/verifier.c
    +++ b/kernel/bpf/verifier.c
    @@ -7084,11 +7084,10 @@ static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,
         s32 smin_val = src_reg->s32_min_value;
         u32 umax_val = src_reg->u32_max_value;
    -    /* Assuming scalar64_min_max_and will be called so its safe
    -     * to skip updating register for known 32-bit case.
    -     */
    -    if (src_known && dst_known)
    +    if (src_known && dst_known) {
    +        __mark_reg32_known(dst_reg, var32_off.value);
             return;
    +    }
         /* We get our minimum from the var_off, since that's inherently
          * bitwise.  Our maximum is the minimum of the operands' maxima.
    @@ -7108,7 +7107,6 @@ static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,
             dst_reg->s32_min_value = dst_reg->u32_min_value;
             dst_reg->s32_max_value = dst_reg->u32_max_value;
         }
    -     }*/
    static void __mark_reg32_known(struct bpf_reg_state *reg, u64 imm)
    {
        reg->var_off = tnum_const_subreg(reg->var_off, imm);
        reg->s32_min_value = (s32)imm;
        reg->s32_max_value = (s32)imm;
        reg->u32_min_value = (u32)imm;
        reg->u32_max_value = (u32)imm;
    }
**保护机制** ：开启KASLR/SMEP/SMAP。
**利用总结** ：利用verifier阶段与runtime执行阶段的不一致性，进行越界读写。泄露内核基址、伪造函数表、实现任意读写后篡改本线程的cred。
* * *
## 1\. 漏洞分析
**参考**
：BPF介绍和相似漏洞分析，可参考[CVE-2020-8835利用](https://blog.csdn.net/panhewu9919/article/details/117736484)，里面也有`var_off`
也即`tnum`结构的含义。总之，其成员 `value` 表示确定的值，`mask` 对应的位是1则表示该位不确定。
**漏洞根源**
：eBPF指令集可以对64位寄存器或低32位进行操作，`verifier`也会对低32位进行范围追踪：`{u,s}32_{min,max}_value`。每次进行指令操作，有两个函数会分别更新64位和32位的边界，在
[adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031)
中调用这两个函数。很多BPF漏洞都出现在对32位边界的处理上。CVE-2021-3490也出现在32位运算
`BPF_AND`、`BPF_OR`、`BPF_XOR` 中。
####  1-1 代码跟踪
**漏洞调用链**
：[adjust_scalar_min_max_vals()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L7031)
->
[scalar32_min_max_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L6534)
    *
    /* WARNING: This function does calculations on 64-bit values, but  * the actual execution may occur on 32-bit values. Therefore,      * things like bitshifts need extra checks in the 32-bit case.
    */
    static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
                                          struct bpf_insn *insn,
                                          struct bpf_reg_state 
                                                      *dst_reg,
                                          struct bpf_reg_state src_reg)
    {
    ...
            case BPF_AND:
                    dst_reg->var_off = tnum_and(dst_reg->var_off,       
                    src_reg.var_off);
                    scalar32_min_max_and(dst_reg, &src_reg);    // [1] var_off = tnum_or(dst_reg->var_off,  
                    src_reg.var_off);
                    scalar32_min_max_or(dst_reg, &src_reg);        // var_off = tnum_xor(dst_reg->var_off,   
                    src_reg.var_off);
                    scalar32_min_max_xor(dst_reg, &src_reg);    // 
[__mark_reg_known()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1045)
来标记寄存器的，所以暂时不用处理），直接返回。64位 `BPF_AND` 中，若 `src_reg` 和 `dst_reg` 都为 known，则调用
[__mark_reg_known()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1045)
将寄存器标记为 known。
**问题**
：[scalar32_min_max_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L6534)
32位中，`*_known` 变量是调用
[tnum_subreg_is_const()](https://elixir.bootlin.com/linux/v5.12.3/source/include/linux/tnum.h#L96)
来计算的，而
[scalar_min_max_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L6570)
64位中是调用
[tnum_is_const()](https://elixir.bootlin.com/linux/v5.12.3/source/include/linux/tnum.h#L54)
来计算的。区别是，前者只判断低32位的 `tnum->mask` 来判断是否为 known，后者则判断整个64位是否为
known。如果某个寄存器的高32位不确定，而低32位是确定的，则
[scalar_min_max_and()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L6570)
也不会调用
[__mark_reg_known()](https://elixir.bootlin.com/linux/v5.12.3/source/kernel/bpf/verifier.c#L1045)
来标记寄存器。
    static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,
                                     struct bpf_reg_state *src_reg)
    {
        bool src_known = tnum_subreg_is_const(src_reg->var_off);
        bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
        struct tnum var32_off = tnum_subreg(dst_reg->var_off);
        s32 smin_val = src_reg->s32_min_value;
        u32 umax_val = src_reg->u32_max_value;
        /* Assuming scalar64_min_max_and will be called so its safe
        * to skip updating register for known 32-bit case.   开发者假设，反正之后还是会调用scalar_min_max_and() -> __mark_reg_known() 来标记寄存器的，所以暂时不用处理，直接返回。但是如果某个寄存器的高32位不确定，而低32位是确定的，则 scalar_min_max_and() 不会调用 __mark_reg_known()。
        */
        if (src_known && dst_known)
            return;
    ...
    }
    static void scalar_min_max_and(struct bpf_reg_state *dst_reg,
                                  struct bpf_reg_state *src_reg)
    {
        bool src_known = tnum_is_const(src_reg->var_off);
        bool dst_known = tnum_is_const(dst_reg->var_off);
        s64 smin_val = src_reg->smin_value;
        u64 umin_val = src_reg->umin_value;