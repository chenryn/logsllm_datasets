它在文件中搜索一个模式，然而，
真正的匹配都作用于“Z”而且只有“Z”
我们将看几个演示匹配范围的示列。然后我们将使用类似grep的一
QQ群：
 including Zippy, our dog
including 00ippy,
 including O0ippy, our dog
50192241
生成单个替换的程序 
，但它是非常好的工具。它可以使用简单的shell脚
，至于如何匹配很少会有问题。然而，当想要
 our dog
- 63 -
它允许要匹配的字符串指定一个
第三章 
。我们可以使用gres命令
了解正则表达式语法
。它产生的结果与
---
## Page 64
出。我们在所匹配的内容下面添加一行脱字符（）来标记所匹配的内容。
有任意多的字符或没有字符。在有以上两行的文件上运行grep会产生一行的输
的字符；
配。如果我们稍微改动正则表达式，结果就会很明显：
意次的字符”
我们期望第一行上的匹配范围扩展为从“A”到“Z”，而不仅是“Z”真正被匹
注10：
$ gres "A.*Z" "00" sample
何操作都可以应用于sed。这里我们用两个零（00）来替换被正则表达式
本章的其余部分将使用gres来演示替换元字符的用法。记住，
“.*”可以被解释为出现零次或多次的任意字符，
00elda
00iggy
00ippy, our dog
“A.*Z”匹配的字符串。
sed -e "s$A$pattern$A$replacement$A" $file 
exit 1 
echo $3 is not a file. >&2
else
file=$3
if［-f $3］
replacement=$2 
pattern=$1
exit 1
echo Usage: gres pattern replacement file >&2
then
if ［$#-lt 3］
$ cat gres
#!/bin/sh 
fi
then 
A. *Z
“A”是模式中的开始字符，
Control-A很方便。这样做大大地减少了分隔符出现在模式中或替
echoltr...行虽然较复杂，但是生成用作sed替换命令的分隔符
QQ群：
换文本中的机会。
，包括什么也没有的情况。整个表达式表示A和Z之间有任意数目
50192241
- 64 -
“Z”是最后一个字符；在它们之间可以
（注10)
第三章
这意味着可以找到“出现任
了解正则表达式语法
应用于gres的任
---
## Page 65
然而，
要匹配第一个参数，
让我们来看有两个用引号包围的参数的troff宏，
到的问题。
前面我们说过，
正则表达式“A.*Z”在每种情况下都匹配可能为最长的范围。
现在，让我们看看类似的一组包含“A”和“Z”的多次出现的示列行。
字符串“A.*”匹配A后面跟有任意个字符（包括零个字符）再跟有Z的模式。
限制范目
这样，
匹配的范围从“A”到“”。相同的正则表达式还匹配下面的行：
All of us,.
All of us, including Zippy, our dog
AII
AII
All of us,
因为模式中的第二个引号与该行上的最后一个引号匹配，所以它结束匹
u*
\. Se ". *" ". *""
.Se "Appendix" "Full Program Listings"
当我们想要匹配最短的范围时会出问题。
All of us, including Zippy, our dog 
1. Se
ofL
 heard it on radio station WVAZ 1060.
of
。例如，
国
QQ群：
Ⅱ*"
us,
'sn
正则表达式尝试匹配最长的字符串，
 including Zippy and Ziggy and Zelda
eplaz pue ]*>
\.[A-Z12].”.*”
、\.[a-z]\{2\}
\f[(BIRP]C*[BW]*
\$[0-9]*\. [0-9] [0-9]
[0-9]\[3\}-[0-9]\{4\}
[0-9]{3\}-[0-9]\[2\}-[0-9]\{4\]
[A-Z] [a-z]{3, 9\}[0-9]\{1,2\},[0-9]\{4\]
[Z-][Z-v]‘*
[z-][z-]
\.[A-Z12].
正则表达式
.*， [A-Z] [A-Z] [0-9] [5] (-[0-9] [4])?
- 67 -
第三章 
了解正则表达式语法
---
## Page 68
C
因此，
稍微实践一下，
3
下这些步骤：
这就要求采用可控制的，有秩序的方式来使用 sed。在编写脚本时，应遵循以
.7
理解编辑的脚本与得到的输出之间的因果关系。
些改动更冒险。这种担心的原因是自动化任务会发生一些不可逆转的事情。学
大多数不熟习 sed 的人都觉得，
并可控制的方式，来体验一次一步进行改变的感觉。
查因果关系。
手动进行编辑工作时，
并转换成一个非手动的过程，即通过执行一个脚本来实现。
务
点
重
这
件
文件上运行它。使用 sed 可以将类似于vi 编辑器中手动的操作过程提取出来,
为了使用 sed，首先要编写一个含有一系列编辑操作的脚本，
个基本的原理：
委托给别人，
类似于个人的时间管理，
述。
些步骤只是第三章“了解正则表达式语法”中介绍编写正则表达式的过程的
返回到它的前一个状态。
在提交最终的改变之前反复测试这个过程。
在着手做之前要弄清楚想做什么。
本章内容
脚本中的所有编辑命令都将依次应用与每个输入行。
明确地描述处理的过程。
在脚本中应用命令
 本章可以使你自由地编写处理编辑工作的脚本。这就要了解 sed 工作的
它们描述了编写任意种类的程序的方法论。检测脚本是否工作的最好的
开始 PromiSed Land
sed 脚本的 4种类型
测式并保存输出
寻址上的全局透视
如果成功了，再将大的任务委托给它们），
，你就会信赖你的 sed 脚本，
QQ群：
，可以通过输入一个编辑命令并观察立即出现的结果来检
，学会将某些任务委托给别人去做。你可以将小的任
50192241
一旦学会了交互式文本编辑器，就可以采用安全的
 编写执行一系列编辑动作的脚本，
它将会做你想让它做的工作（这有
第四章
编写 sed脚本
0
然后在某个输入
编写 sed 脚本
，比手动做一
第四章
---
## Page 69
脚本。它将“The Unix system”改变为“The UNIX Operating System”
那里存储单个输入行（注1）。图4-1展示了进行模式空间转换的一个两行的
sed 维护一种模式空间，即一个工作区或临时缓冲区，当应用编辑命令时将在
模式空间 
后，我们将讨论所发生的事情。
你认为会发生什么呢？用一个样本文件试一下。在了解了 sed 是如何工作的之
“pig”换成“cow”并将“cow”换成“horse”。
我们将看到使用替换命令的示列。假设有人快速编写了下面的脚本，来将
味着与原始输入行匹配的模式可能不再与经过编辑操作之后的行匹配。
实正好相反。Sed首先将整个编辑脚本应用于第一个输入行，
下一个编辑命令之前，
将一系列编辑组合进一个脚本中会出现意想不到的结果。
在脚本中应用命令
在探讨脚本中可使用的所有命令之前，
对用这么少的命令能处理这么多事情而感到惊奇（第五章“基本 sed 命令”
令变量，但本章中的脚本将有针对性地使用几个命令。虽然如此，你仍可能
成
这
介绍了这些基本原理之后，
编
的任何编辑工作都会改变后续命令应用的行。Sed 不会保留最初的行。这
输入行并对其应用整个脚本。引文 sed 总是处理原是行的最新形式，所以
辑操作会对另一个编辑操作产生什么影响。新用户一般会认为，sed 在应用
些脚本提供了你将要编写的脚本的基本模型。虽然在 sed 中可以使用许多。
s/cow/horse/g
s/pig/cow/g
送到标准输出。
原始的输入文件未被改变，编辑命令修改了原始行的备份并且此备份被发
命令应用于所有的行（全局的)，除非寻址限制了受编辑命令影响的行。
QQ 群:
先将一个单独的编辑命令应用与输入的所有的行。但事
，我们将看一下不同的 sed 应用的 4种类型的脚本。
50192241
- 69
，首先了解脚本如何工作以及如何使用脚
第四章
，你可能考虑不到一个
然后再读取第
编写 sed 脚本
意
生
是
命
公
---
## Page 70
这
包
列
间
结
后
宗
的
意
第
尾
初始时，
而
注
图
”
”
‘cow”之前将“cow”
个错误只是脚本中命令的顺序的问题，
脚本中的问题。正如所希望的那样，
脚本中的所有的命令应用与新读入的行。
应用了所有的指令后，
当前行。
第二个替换命令的模式不匹配最初的输入行，它匹配模式空间中发生了变化
。脚本中的第一个命令应用于这一行，
8888
380808
含horse!
，
的内名
果是，
二>
1:
4-1:
88888
888
个命令，
8888
888
88880
容
，任何 sed 命令都可以为应用下一个命令改变模式空间的内容。漠视
是动态的，
模式空间包含有单个输入行的备份。
读慢
一次一行的设计的一个优点是 sed 在读取非常庞大的文件时不会出
808888
888808