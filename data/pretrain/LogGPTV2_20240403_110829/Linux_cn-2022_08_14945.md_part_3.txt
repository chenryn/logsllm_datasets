首次阐述上述三维场景分割的是美国空军的研究员，他们曾尝试向美国空军证明计算机图形已经非常先进，可以应用到飞行模拟器领域。1969 年，他们将研究发现发表在一份题为《计算机生成图像在图形仿真中的应用研究》的报告中。该报告的总结部分指出，计算机图形可用于训练飞行员，但也警告说，其实际应用可能会受制于 VSD 问题：
> 
> 实时图像处理需要解决的一个关键问题就是优先级问题，或称隐藏线问题。在我们平时用眼睛观察外界时，大自然替我们轻易地解决了这一问题：不透明物体上的一个点，掩盖了同一视觉方向上、且距离较远的所有其它物体。但在计算机中，这项任务却非常困难。图像处理需要解决的优先级问题，随着环境复杂程度的增加，计算量会呈指数级增长，随即就会超过绘制物体透视图所需的计算负载。   [2] 
> 
> 
> 
他们在报告中提出了一项基于构造“遮挡矩阵”的方案，这一方案据说早些时候曾被应用于 NASA 的项目当中。研究员指出，平面将场景一分为二，可用来解决平面两侧物体之间存在的“任何优先级问题”。通常情况下，可能需要明确将这些平面添加到场景中，但对某些几何体，只需借助你已经拥有的几何体的表面即可。他们举了一个例子，如下图：p 1、p 2 以及 p 3 是三个不同的平面，如果摄像机视角位于其中一个平面的前方，即“正”面，p i 的值就等于 1。这种矩阵展示出基于三个不同平面和摄像机视角位置的三个物体之间的关系 —— 如果物体 a i 遮挡了物体 a j，那么 a ij 在此矩阵中的数值等于 1。
![](/data/attachment/album/202208/19/161549m90qqfjeopk7hr6q.png)
研究人员指出，这种矩阵可以应用到硬件中，对每一帧进行重新评估。该矩阵基本上可以用作大型的开关，或者一种预置的 Z 缓冲区。在绘制给定的物体时，如果在物体所在列上得出数值 1，并且所在行已经在绘制中，那么物体被遮挡的部分就不会绘制出来。
不过，该矩阵方法的主要缺点在于，为了在场景中表示出 n 个物体，你需要一个尺寸为 n 2 的矩阵。于是，研究人员们继续深入，探究将遮挡矩阵表示为“优先级列表”的可行性，该列表的尺寸是 n，可确定物体绘制的顺序。他们随即发现，诸如上图此类场景根本无法确定顺序（因为它存在循环阻塞的现象）。因此，他们花了很多时间来阐明“合适”与“不合适”场景之间的数学区别。最后，他们得出了一个结论：至少对于“合适的”场景下，优先级列表是可以制作出来的；而对场景设计师来说，避免设计出“不合适”的场景也不是一件难事。但是，他们并没有说明如何生成该列表。可以说，这份 1969 年的研究的首要贡献在于提出了：至少，在 *理论上*，可以采用平面分割的方法，对场景中的物体进行渲染排序。
直到 1980 年，一份题为《基于优先级树结构的可见表面生成》的论文提出了解决该问题的具体算法。在这份论文中，作者  亨利·福克斯   Henry Fuchs 、 泽维·凯德姆   Zvi Kedem  以及  布鲁斯·内勒   Bruce Naylor  介绍了 BSP 树。他们指出，这种新的数据结构“可以替代十年前首次使用，但由于一些问题未得到广泛发展的方案”（即前文 1969 年美国空军相关研究中的方案）。   [3]  BSP 树一经生成，即可用于确定场景中物体的优先级顺序。
三人在论文中对 BSP 树的工作原理给出了相当可读的解释。但在本文，我将尝试使用更加通俗的语言，介绍给大家。
首先，在场景中选定一个多边形，将该多边形所在的平面作为分割平面。同时，该多边形充当树的根节点。场景中剩下的多边形会分散在分割平面的两侧。位于分割表面“前方”或者与分割平面相交后位于“前”半部分的多边形落在了根节点左侧的左子树上；位于分割表面“后方”或者与分割平面相交后位于“后”半部分的多边形落在了右子树上。接着，递归重复这一过程：在左子树和右子树上各选定一个多边形，作为各自空间新的分割平面，继而二分出来更多的子空间和子树。等到全部的多边形均选定之后，二叉空间分割也就结束了。
假设你想由后向前将场景中的几何图形进行渲染。（这就是所谓的“ 画家算法   painter's algorithm ”。因为在绘制时，距离摄像机较远的多边形会被距离摄像机较近的多边形所覆盖，借此正确进行渲染任务。）如果想要实现这一算法，必须按顺序遍历 BSP 树，左右子树的渲染顺序由摄像机视角与节点所在分割平面的位置关系决定的。因此，针对树上的每个节点，首先渲染距离分割平面较“远”一侧的所有多边形，接着是位于平面上的多边形，最后是距离平面较“近”一侧的所有多边形 —— “远”与“近”相对于摄像机视角而言。根据前文，距离分割平面较远一侧的多边形无法遮挡近侧的物体，所以这种方法可以解决 VSD 问题。
下图表示一个简单的二维场景的 BSP 树的构造与遍历过程。在二维中，分割平面变成了分割线，但就基本原理而言，与复杂的三维场景并无二致。
![](/data/attachment/album/202208/19/161550fqlmf9mpovvoojvp.svg)
第一步：根分割线落在 D 墙上，将剩下的几何图形分为两组。
![](/data/attachment/album/202208/19/161550f6hbof3xr88r46ss.svg)
第二步：继续分割位于 D 墙两侧的空间。C 墙是其中一侧的唯一一堵墙壁，因此无需再分。另一侧，B 墙形成新的分割平面。因为 A 墙与新的分割平面相交，所以必须将其分割为两堵墙。
![](/data/attachment/album/202208/19/161550zeomy7q77jhonoom.svg)
第三步：参照右上方视角，由后向前对墙壁进行排序，对执行画家算法很有帮助。这就是树的顺序遍历过程。
福克斯、凯德姆以及内勒多次强调了 BSP 树的优势：它只需构建一次。可能有些难以置信，但实际上无论摄像机视角位于何处，同一棵 BSP 树都可以用来渲染一个场景。只要场景中的多边形没有移动，BSP 树就不会失效。因此，BSP 树在实时渲染任务中非常实用 —— 构建树时的所有艰巨任务都可以在渲染工作开展之前完成。
同时，三人也提到了一项需要进一步深入研究的问题：究竟怎样才能构建出一棵 “高质量的” BSP 树？BSP 树的质量取决于用作分割平面的多边形的选择。我在前文跳过了这一问题，不过如果用作分割平面的多边形与其他多边形相交，那么为了让 BSP 算法发挥作用，必须将相交的多边形一分为二，这样两部分就可以分在不同的空间。但是如果这种现象反复出现，BSP 树的构建势必会大幅增加场景中多边形的数量。
内勒后来在其 1993 年的论文《构建高质量的分割树》中提及这一问题。卡马克的同事，id Software 的共同创始人  约翰·罗梅洛   John Romero  指出，这篇论文是卡马克在《毁灭战士》中引入 BSP 树时读到的论文之一。   [4] 