  even	
  use	
  SQL	
  injection	
  to	
  retrieve	
  the	
database	
  file	
  from	
  the	
  live	
  system.	
  This	
  will	
  make	
  it	
  more	
  convenient	
  to	
  analyze	
  the	
  results	
  of	
  our	
various	
  SQL	
  injections.	
Appendix	
  A	
  contains	
  a	
  program	
  that	
  automates	
  this	
  exploit.	
Vulnerability 3: Remote Code Execution 
Arbitrary	
  file	
  extraction	
  yields	
  greater	
  access	
  than	
  before,	
  but	
  ideally	
  we	
  will	
  find	
  a	
  way	
  to	
  execute	
arbitrary	
  code,	
  hopefully	
  enabling	
  fully	
  privileged	
  system	
  access.	
  The	
  most	
  likely	
  attack	
  vector	
  is	
  a	
  buffer	
overflow.	
  With	
  luck	
  we	
  can	
  find	
  an	
  unbounded	
  write	
  to	
  a	
  buffer	
  declared	
  on	
  the	
  stack.	
We	
  start	
  our	
  quest	
  for	
  overflow	
  candidates	
  by	
  searching	
  for	
  low	
  hanging	
  fruit.	
  A	
  grep	
  through	
  the	
source	
  code	
  for	
  dangerous	
  string-­‐handling	
  functions	
  is	
  a	
  good	
  place	
  to	
  begin.	
Figure 14 A search through MiniDLNA’s source code for dangerous string functions yields many candidates. 
Searching	
  for	
  strcat(),	
  sprintf(),	
  and	
  strcpy()	
  function	
  calls	
  returns	
  265	
  lines.	
  It	
  looks	
  like	
  there	
are	
  plenty	
  of	
  opportunities	
  to	
  overflow	
  a	
  buffer.	
Let’s	
  have	
  a	
  look	
  at	
  upnpsoap.c,	
  line	
  846	
SQL	
  Injection	
  to	
  MIPS	
  Overflows:	
  Rooting	
  SOHO	
  Routers	
Zachary	
  Cutlip	
12 
Figure 15 A buffer overflow candidate in MiniDLNA’s SQLite callback() function. 
This	
  is	
  an	
  intriguing	
  bug	
  for	
  a	
  couple	
  of	
  reasons.	
  First,	
  this	
  sprintf()	
  is	
  near	
  the	
  end	
  of	
  an	
exceptionally	
  long	
  function.	
  That	
  is	
  important	
  because	
  there	
  are	
  many	
  function	
  arguments	
  and	
  local	
variables	
  on	
  the	
  stack.	
  If	
  an	
  overflow	
  overwrites	
  the	
  stack	
  too	
  early	
  in	
  the	
  function,	
  there	
  are	
  many	
hazards	
  that	
  would	
  likely	
  crash	
  the	
  program	
  before	
  we	
  successfully	
  intercept	
  the	
  function’s	
  return.	
This	
  bug	
  is	
  also	
  interesting	
  because	
  callback()	
  is	
  the	
  function	
  passed	
  to	
  sqlite3_exec()	
  to	
  process	
the	
  query	
  results.	
  As	
  seen	
  at	
  line	
  956	
  of	
  upnpsoap.c,	
  the	
  query	
  whose	
  results	
  are	
  sent	
  to	
  callback()	
is:	
Figure 16 The SQL query whose results are processed by MiniDLNA’s callback() function. 
Let’s	
  look	
  at	
  the	
  schema	
  for	
  the	
  DETAILS	
  table.	
SQL	
  Injection	
  to	
  MIPS	
  Overflows:	
  Rooting	
  SOHO	
  Routers	
Zachary	
  Cutlip	
13 
Figure 17 The schema of the DETAILS table.  ALBUM_ART is an integer. 
The	
  schema	
  shows	
  that	
  ALBUM_ART	
  is	
  an	
  integer,	
  but	
  the	
  sprintf()	
  in	
  question	
  is	
  writing	
  the	
returned	
  album	
  art	
  ID	
  into	
  the	
  512-­‐byte	
  str_buf	
  as	
  a	
  string.	
A	
  couple	
  things	
  are	
  worth	
  noting.	
  First,	
  SQLite	
  uses	
  “type	
  affinity4”	
  to	
  convert	
  a	
  string	
  to	
  a	
  field’s	
numeric	
  type.	
  It	
  does	
  this	
  only	
  if	
  the	
  string	
  has	
  a	
  numeric	
  representation.	
  For	
  example,	
  the	
  string	
“1234”	
  will	
  be	
  stored	
  as	
  the	
  integer	
  1,234	
  in	
  an	
  integer	
  field,	
  but	
  “1234WXYZ”	
  will	
  be	
  stored	
  as	
  a	
  string.	
Further,	
  SQLite	
  returns	
  results	
  from	
  queries	
  on	
  integer	
  fields	
  as	
  strings.	
Second,	
  the	
  program	
  attempts	
  to	
  “validate”	
  the	
  string	
  returned	
  by	
  SQLite	
  using	
  the	
  atoi()	
  function.	
However,	
  this	
  test	
  only	
  verifies	
  that	
  at	
  least	
  the	
  first	
  character	
  of	
  the	
  string	
  is	
  a	
  number	
  and	
  more	
specifically,	
  a	
  number	
  other	
  than	
  zero.	
  The	
  rest	
  of	
  the	
  string,	
  starting	
  with	
  the	
  first	
  non-­‐number,	
  is	
ignored.5	
The	
  implication	
  is	
  that	
  arbitrary	
  data	
  may	
  be	
  returned	
  from	
  the	
  SQL	
  query	
  and	
  subsequently	
  written	
  into	
str_buf,	
  even	
  though	
  ALBUM_ART	
  is	
  specified	
  as	
  an	
  integer	
  in	
  the	
  database’s	
  schema.	
  Perhaps	
  the	
developer	
  assumes	
  album_art	
  will	
  be	
  a	
  string	
  representation	
  of	
  an	
  integer,	
  and	
  therefore	
  of	
  limited	
length.	
  Next,	
  by	
  violating	
  this	
  assumption,	
  we	
  will	
  have	
  an	
  exploitable	
  buffer	
  overflow.	
Ordinarily	
  this	
  particular	
  bug	
  is	
  difficult	
  or	
  impossible	
  to	
  exploit,	
  as	
  its	
  input	
  comes	
  from	
  a	
  database,	
  not	
from	
  user	
  input	
  or	
  a	
  network	
  connection.	
  There	
  is	
  no	
  reason	
  that	
  the	
  database,	
  which	
  is	
  not	
  user	
  facing,	
should	
  contain	
  anything	
  that	
  the	
  application	
  didn’t	
  put	
  there	
  itself.	
  Fortunately	
  for	
  us,	
  we	
  have	
previously	
  discovered	
  a	
  trivially	
  exploitable	
  SQL	
  injection	
  that	
  gives	
  us	
  unfettered	
  access	
  to	
  the	
database.	
  Thus,	
  we	
  can	
  put	
  anything	
  there	
  we	
  want.	
To	
  be	
  sure	
  this	
  bug	
  is	
  present	
  in	
  the	
  shipping	
  executable,	
  we	
  can	
  go	
  back	
  to	
  IDA	
  Pro	
  for	
  a	
  quick	
  look	
inside	
  the	
  callback()	
  function.	
4	
  http://www.sqlite.org/faq.html#q3	
5	
  http://kernel.org/doc/man-­‐pages/online/pages/man3/atoi.3.html	
SQL	
  Injection	
  to	
  MIPS	
  Overflows:	
  Rooting	
  SOHO	
  Routers	
Zachary	
  Cutlip	
14 
Figure 18 Verifying the presence of the buffer overflow candidate in the shipping minidlna.exe executable. 
Disassembly	
  in	
  IDA	
  suggests	
  that	
  the	
  target’s	
  copy	
  of	
  MiniDLNA	
  is	
  vulnerable	
  to	
  an	
  ALBUM_ART	
  buffer	
overflow.	
In	
  order	
  to	
  verify	
  exploitability	
  we	
  need	
  to	
  have	
  data	
  that	
  we	
  control	
  loaded	
  into	
  the	
  CPU’s	
  program	
counter.	
  We	
  can	
  test	
  this	
  by	
  first	
  staging	
  records	
  in	
  the	
  OBJECTS	
  and	
  DETAILS	
  tables	
  that	
  will	
  satisfy	
  the	
left	
  join	
  query	
  described	
  earlier.	
  Then	
  we	
  will	
  stage	
  a	
  sufficiently	
  long	
  string	
  in	
  the	
  database	
  to	
  overflow	
the	
  buffer	
  and	
  overwrite	
  the	
  function’s	
  saved	
  return	
  address.	
We	
  can	
  set	
  up	
  the	
  appropriate	
  records	
  with	
  the	
  following	
  SQL	
  commands:	
INSERT/**/into/**/DETAILS(ID,SIZE,TITLE,ARTIST,ALBUM,TRACK,DLNA_PN,MIME, 
ALBUM_ART,DISC) 
/**/VALUES("31337”,”PWNED”,"PWNED","PWNED","PWNED","PWNED","PWNED", 
"PWNED",”1","PWNED"); 
INSERT/**/into/**/OBJECTS(OBJECT_ID,PARENT_ID,CLASS,DETAIL_ID)/**/ 
VALUES("PWNED","PWNED","container","31337"); 
This	
  will	
  create	
  two	
  records	
  that	
  are	
  related	
  via	
  a	
  DETAILS.ID	
  and	
  OBJECTS.DETAIL_ID	
  of	
  ‘31337’.	
  It	
is	
  also	
  important	
  to	
  note	
  that	
  the	
  OBJECTS.ID	
  value	
  is	
  ‘PWNED’	
  and	
  that	
  the	
  ALBUM_ART	