i (⃗x )⟩i∈[I]. Suppose д(⃗x ) − д′(⃗x ) ∈ I. Then there
ideal I = ⟨ei (⃗x ) − e′
are ui (⃗x ) ∈ Z[⃗x] (called coefficients) such that
′
ui (⃗x )[ei (⃗x ) − e
д(⃗x ) − д
(cid:88)
(⃗x ) =
(3)
′
i (⃗x )].
i∈[I]
Hence д(⃗x ) − д′(⃗x ) = 0 follows from the polynomial equations
ei (⃗x ) = e′
i (⃗x ) for i ∈ [I]. Similarly, it suffices to check if h(⃗x ) −
fj (⃗x ) = f
′
j (⃗x ) + dj · nj (⃗x )
Session I4:  Verifying CryptoCCS’17, October 30-November 3, 2017, Dallas, TX, USA1983h′(⃗x ) ∈ ⟨m(⃗x ), ei (⃗x ) − e′
Z[⃗x] such that
′
h(⃗x ) − h
(cid:88)
i∈[I]
i (⃗x )⟩i∈[I] for (2). If so, there are u, ui (⃗x ) ∈
(⃗x ) = u (⃗x ) · m(⃗x ) +
ui (⃗x )[ei (⃗x ) − e
′
i (⃗x )].
(4)
Thus h(⃗x ) ≡ h′(⃗x ) mod m(⃗x ) as required. The reduction to the
ideal membership problem however is incomplete. Consider Z |=
∀x .x2 + x ≡ 0 mod 2 but x2 + x (cid:60) ⟨2⟩ [22].
Two Coq tactics are available to find formal proofs for the poly-
nomial equation entailment problems [28, 29]. The tactic nsatz
proves the entailment problem of the form in (1); the tactic gbarith
proves the form in (2). The ideal membership problem can be solved
by finding a Gröbner basis for the ideal [15]. Both tactics solve the
polynomial equation entailment problem by computing Gröbner
bases for induced ideals. Finding Gröbner bases for ideals however
is NP-hard because it allows us to solve a system of equations over
the Boolean field [20]. Low-level mathematical constructs can have
hundreds of polynomial equations in (1) or (2). Both Coq tactics
fail to solve such problems in a reasonable amount of time.
We develop two heuristics to solve the polynomial equation
entailment problem more effectively. Note that the polynomial
equations generated by Algorithm 6 are of the forms: x = e (from
assignment statements) or x +2cy = e (from Split statements). Such
polynomial equations can safely be removed after every occurrences
of x are replaced with e or e − 2cy respectively. The number of
generators of the induced ideal is hence reduced. We define a Coq
tactic to simplify polynomial equation entailment problems by
rewriting variables and then removing polynomial equations.
To further improve scalability, we use the computer algebra
system Singular to solve the ideal membership problem [21]. Our
tactic submits the membership problem to Singular and obtains
coefficients from the computer algebra system. Since algorithms
used in Singular might be implemented incorrectly, our Coq tactic
then certifies the coefficients by checking the equation (3) or (4)
to ensure the polynomial equation entailment problem is correctly
solved. Soundness of our technique therefore does not rely on the
external solver Singular.
6 EVALUATION
We evaluate our techniques in real-world low-level mathematical
constructs in X25519. In elliptic curve cryptography, arithmetic com-
putation over large finite fields is required. For instance, Curve25519
defined by y2 = x3 +486662x2 +x is over the Galois field K = GF(ϱ)
with ϱ = 2255 − 19. To make the field explicit, we rewrite its defini-
tion as:
y ·K y =K x ·K x ·K x +K 486662 ·K x ·K x +K x .
(5)
Since arithmetic computation is over K whose elements can
be represented by 255-bit numbers, any pair (x, y) satisfying (5)
(called a point on the curve) can be represented by a pair of 255-
bit numbers. It can be shown that points on Curve25519 with the
point at infinity as the unit (denoted 0G) form a commutative group
G = (G, +G, 0G) with G = {(x, y) : x, y satisfying (5)}. Let P0 =
(x0, y0), P1 = (x1, y1) ∈ G. We have −P0 = (x0,−y0) and P0 +G P1 =
(6)
(x, y) where
m = (y1 −K y0) ÷K (x1 −K x0)
x = m ·K m −K 486662 −K x0 −K x1
y = (2 ·K x0 +K x1 +K 486662) ·K m −K m ·K m ·K m −K y0
when P0 (cid:44) ±P1. Other cases (P0 = ±P1) are defined similarly [15].
G and similar elliptic curve groups are the main objects in elliptic
curve cryptography. It is essential to implement the commutative
binary operation +G very efficiently in practice.
6.1 Arithmetic Computation over GF(2255 − 19)
The operation +G is defined by arithmetic computation over K.
Mathematical constructs for arithmetic over K are hence necessary.
Recall that an element in K is represented by a 256-bit number.
Arithmetic computation for 255-bit integers however is not yet
available in commodity computing devices as of the year 2017; it
has to be carried out by limbs where a limb is a 32- or 64-bit number
depending on the underlying computer architectures. Figure 3 is
such an implementation of subtraction for the AMD64 architecture.
Multiplication is another interesting but much more complicated
computation. The naïve implementation for 255-bit multiplication
would compute a 510-bit product and then find the corresponding
255-bit representation by division. An efficient implementation
for 255-bit multiplication avoids division by performing modulo
operations aggressively. For instance, an intermediate result of the
form c ·K 2255 is immediately replaced by c ·K 19 since 2255 =K 19
in GF(ϱ). This is indeed how the most efficient multiplication for
the AMD64 architecture is implemented (Appendix A.1) [9, 10].
In our experiment, we took real-world efficient and secure low-
level implementations of arithmetic computation over GF(ϱ) from [9,
10], manually translated source codes to our domain specific lan-
guage, specified their algebraic and range properties, and performed
certified verification with our technique. Table 1 summarizes the
results without and with applying the two heuristics in Section 5.2.
The column “safe” shows the time used by the SMT solver Boolec-
tor to verify if the input program is safe. The column “range” shows
the time used by Boolector to verify the range specification of
the input program. The columns “algebraic” show the time used by
Singular to verify the algebraic specification of the input program.
The columns “total” show the total verification time including safety
check, verification of range and algebraic specifications, rewriting,
proof certification, etc. The columns “without heuristics” and “with
heuristics” respectively show the time information without and
with the two heuristics. The results show that without the two
heuristics, multiplication and square cannot be verified because
the computation of Gröbner bases was killed by the OS after run-
ning for days. With the heuristics, all the implementations can be
verified in seconds.
We also tried to verify buggy implementations such as the buggy
implementation of multiplication mentioned in [14]. In such cases,
our verification tactic in Coq just failed without giving any coun-
terexample. Note that when our tactic fails to verify a program, we
cannot conclude that the program is buggy because our approach
is sound but not complete.
Session I4:  Verifying CryptoCCS’17, October 30-November 3, 2017, Dallas, TX, USA1984Table 1: Certified Verification of Arithmetic Operations over GF(ϱ)
addition
subtraction
multiplication
multiplication by 121666
square
number of lines
10
15
144
26
109
safe
0.162
0.140
3.904
0.266
3.722
algebraic
30.545
35.646
time (seconds)
range without heuristics
total
41.55
0.249
0.389
48.47
41.070
0.852
19.905
1112.311
1125.41
-
-
-
-
with heuristics
algebraic
total
4.14
4.93
81.93
7.70
47.44
0.401
0.208
2.312
0.315
1.087
remark
a +K b
a −K b
a ·K b
121666 ·K a
a ·K a
6.2 The Montgomery Ladderstep
Recall that X25519 is based on the Abelian group G = (G, +G, 0G)
induced by the curve Curve25519. As aforementioned, the binary
operation +G requires another sequence of arithmetic computation
over GF(ϱ). Errors could still be introduced or even implanted in
any sequence of computation proclaimed to implement +G. Our
next experiment verifies a critical low-level program implementing
the group operation [9, 10].
Let P ∈ G be a point on Curve25519. We write [n]P for the n-
fold addition P +G · · · +G P ∈ G for n ∈ N. In X25519, we want
to compute a point multiplication, that is, the point [n]P for given
n and P. The standard iterative squaring method computes [n]P
by examining each bit of n iteratively. For each iteration, [2m]P is
computed from [m]P and added with another P when the current bit
is 1. Although the method is reasonably efficient, it is not constant-
time and hence insecure.
Algorithm 9 Montgomery Ladderstep
1: function Ladderstep(x1, xm, zm, xm+1, zm+1)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
t1 ← xm +K zm
t2 ← xm −K zm
t7 ← t2 ·K t2
t6 ← t1 ·K t1
t5 ← t6 −K t7
t3 ← xm+1 +K zm+1
t4 ← xm+1 −K zm+1
t9 ← t3 ·K t2
t8 ← t4 ·K t1
xm+1 ← t8 +K t9
zm+1 ← t8 −K t9
xm+1 ← xm+1 ·K xm+1
zm+1 ← zm+1 ·K zm+1
zm+1 ← zm+1 ·K x1
xm ← t6 ·K t7
zm ← 121666 ·K t5
zm ← zm +K t7
zm ← zm ·K t5
return (xm, zm, xm+1, zm+1)
12:
13:
14:
15:
16:
17:
18:
19:
20:
21: end function
To have constant execution time, the key idea is to compute both
[2m]P and [2m +1]P at each iteration. The Montgomery Ladderstep
is an efficient algorithm computing [2m]P and [2m + 1]P from P,
[m]P, and [m + 1]P on Montgomery curves (including Curve25519).
The algorithm uses only x coordinates of the points. Furthermore,
expensive divisions are avoided in the Ladderstep by projective
representations. That is, the algorithm represents x ÷K z by the
pair x : z and works with fractions (Algorithm 9).
Let unprimed and primed variables denote their values before
and after computation respectively. Write xy to denote x ·K y for
short. The Montgomery Ladderstep has the following algebraic
specification [25]:2
(xmxm −K zmzm )(xmxm −K zmzm )
x′
m =K 4(xmxm+1 −K zmzm+1)(xmxm+1 −K zmzm+1)
z′
m =K 4x1 (xmzm+1 −K zmxm+1)(xmzm+1 −K zmxm+1)
x′
m+1 =K
z′
m+1 =K 4xmzm (xmxm +K 121666xmzm +K zmzm )
For the range specification, the unsigned value of each limb used
to represent an output xm, zm, xm+1, or zm+1 must be in the range
from 0 to 251 + 215. In our experiment, we replace all arithmetic
computation over K with corresponding mathematical constructs
(4 additions, 4 subtractions, 4 squares, 5 multiplications, and 1 mul-
tiplication by 121666) written in bvCryptoLine, translate the above
specification into an algebraic specification, a range specification,
and a safety check, and then apply our technique to verify the
Ladderstep (containing 1282 statements). The verification takes 131
hours, including 77 hours in safety check 3, 33 hours in checking
range specification, 16 hours in checking algebraic specification,
and the remaining hours in term rewriting, proof validation, etc.
For production releases of low-level mathematical constructs, we
believe 5.5 days in verification time are well invested.
7 CONCLUSION
We have developed techniques to verify algebraic and range spec-
ifications of low-level mathematical constructs in cryptographic
programs. Our case studies on real low-level implementations of
X25519 suggest the applicability and scalability of our techniques.
Currently, we are working on automatic translation from assem-
bly languages to our domain specific language. Such translation
will make our verification techniques more accessible to assembly
programmers. We are also applying our techniques to more low-
level mathematical constructs in industrial cryptographic programs.
Communication with assembly programmers will further improve
the proposed techniques in practice.
REFERENCES
[1] Reynald Affeldt. 2013. On construction of a library of formally verified low-level
arithmetic functions. Innovations in Systems and Software Engineering 9, 2 (2013),
59–77.
[2] Reynald Affeldt and Nicolas Marti. 2007. An Approach to Formal Verification
of Arithmetic Functions in Assembly. In Advances in Computer Science (LNCS),
Mitsu Okada and Ichiro Satoh (Eds.), Vol. 4435. Springer, 346–360.
2Amusingly, we find for ourselves the factor of 4 in both the numerator and denomi-
nator of the addition formulas during verification, noted on [25, p. 261].
3We verified the four equations in the algebraic specification separately and our Coq
tactic checked the safety of the same program four times. The time needed to check
program safety once is roughly 19 hours.
Session I4:  Verifying CryptoCCS’17, October 30-November 3, 2017, Dallas, TX, USA1985[3] Reynald Affeldt, David Nowak, and Kiyoshi Yamada. 2012. Certifying assembly
with formal security proofs: The case of BBS. Science of Computer Programming
77, 10–11 (2012), 1058–1074.
[4] B. Alpern, M. N. Wegman, and F. K. Zadeck. 1988. Detecting Equality of Variables
in Programs. In POPL. ACM, New York, NY, USA, 1–11.
[5] Andrew W. Appel. 2015. Verification of a Cryptographic Primitive: SHA-256.
ACM Transactions on Programming Languages and Systems 37, 2 (2015), 7:1–7:31.
https://doi.org/10.1145/2701415
[6] Lennart Beringer, Adam Petcher, Katherine Q. Ye, and Andrew W. Appel. 2015.
Verified Correctness and Security of OpenSSL HMAC. In USENIX Security Sym-
posium 2015. USENIX Association, 207–221.
[7] Daniel J. Bernstein. 2005. Cache Timing Attacks on AES. (2005). https://cr.yp.to/
antiforgery/cachetiming-20050414.pdf.
[8] Daniel J. Bernstein. 2006. Curve25519: new Diffie-Hellman speed records. In
Public Key Cryptography (LNCS), Moti Yung, Yevgeniy Dodis, Aggelos Kiayias,
and Tal Malkin (Eds.), Vol. 3958. Springer, 207–228.
[9] Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang.
2011. High-Speed High-Security Signatures. In CHES (LNCS), Bart Preneel and
Tsuyoshi Takagi (Eds.), Vol. 6917. Springer, 124–142.
[10] Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang.
2012. High-Speed High-Security Signatures. Journal of Cryptographic Engineering
2, 2 (2012), 77–89.
[11] Daniel J. Bernstein and Peter Schwabe. 2016. gfverif: Fast and Easy Verification
of Finite-Field Arithmetic. (2016). http://gfverif.cryptojedi.org.
[12] Yves Bertot and Pierre Castéran. 2004. Interactive Theorem Proving and Program
Development – Coq’Art: The Calculus of Inductive Constructions. Springer.
[13] B. Bond, C. Hawblitzel, M. Kapritsos, K. R. M. Leino, J. R. Lorch, B. Parno, A.
Rane, S. Setty, and L. Thompson. 2017. Vale: Verifying High-Performance Cryp-
tographic Assembly Code. In USENIX Security Symposium 2017. USENIX Associ-
ation, 917–934.
[14] Yu-Fang Chen, Chang-Hong Hsu, Hsin-Hung Lin, Peter Schwabe, Ming-Hsien
Tsai, Bow-Yaw Wang, Bo-Yin Yang, and Shang-Yi Yang. 2014. Verifying
Curve25519 Software. In CCS. ACM, 299–309. https://doi.org/10.1145/2660267.
2660370
[15] Henri Cohen. 1996. A Course in Computational Algebraic Number Theory (3rd
[16] The Sage Developers. 2017. SageMath, the Sage Mathematics Software System.
ed.). GTM, Vol. 138. Springer.
(2017). http://www.sagemath.org.
[17] Burak Ekici, Alain Mebsout, Cesare Tinelli, Chantal Keller, Guy Katz, Andrew
Reynolds, and Clark Barrett. 2017. SMTCoq: A plug-in for integrating SMT
solvers into Coq. In CAV (LNCS), Viktor Kuncak and Rupak Majumdar (Eds.).
Springer.
[18] everest 2016. Project Everest. https://project-everest.github.io. (2016). Accessed: