Thenyoucreatedbytedataandwroteittoanimagefile.
Finally,youusedXORencodingtoobfuscateyourpayload.
Thischapterfocusedonimagefilesandonlyscratchedthe
surfaceofwhatyoucanaccomplishbyusingsteganography
techniques.Butyoushouldbeabletoapplywhatyoulearned
heretoexploreotherbinaryfiletypes.
ADDITIONALEXERCISES
Likemanyoftheotherchaptersinthisbook,thischapterwill
providethemostvalueifyouactuallycodeandexperiment
alongtheway.Therefore,wewanttoconcludewithafew
challengestoexpandontheideasalreadycovered:
1. WhilereadingtheXORsection,youmayhavenoticedthattheXorDecode()
functionproducesadecodedchunksegment,butneverupdatestheCRC
checksum.Seeifyoucancorrectthisissue.
2. TheWriteData()functionfacilitatestheabilitytoinjectarbitrarychunk
segments.Whatcodechangeswouldyouhavetomakeifyouwantedto
overwriteexistingancillarychunksegments?Ifyouneedhelp,ourexplanation
aboutbyteshiftingandtheSeek()functionmaybeusefulinsolvingthis
problem.
3. Here’samorechallengingproblem:trytoinjectapayload—thePNGDATA
bytechunk—bydistributingitthroughoutvariousancillarychunksegments.
Youcoulddothisonebyteatatime,orwithmultiplegroupingsofbytes,soget
creative.Asanaddedbonus,createadecoderthatreadsexactpayloadbyte
offsetlocations,makingiteasiertoextractthepayload.
4. ThechapterexplainedhowtouseXORasaconfidentialitytechnique—a
methodtoobfuscatetheimplantedpayload.Trytoimplementadifferent
technique,suchasAESencryption.Gocorepackagesprovideanumberof
possibilities(seeChapter11ifyouneedarefresher).Observehowthesolution
affectsthenewimage.Doesitcausetheoverallsizetoincrease,andifso,by
howmuch?
5. Usethecodeideaswithinthischaptertoexpandsupportforotherimagefile
formats.OtherimagespecificationsmaynotbeasorganizedasPNG.Want
proof?GivethePDFspecificationaread,asitcanberatherintimidating.How
wouldyousolvethechallengesofreadingandwritingdatatothisnewimage
format?
14
BUILDINGACOMMAND-AND-
CONTROLRAT
Inthischapter,we’lltietogetherseverallessonsfromthe
previouschapterstobuildabasiccommandandcontrol(C2)
remoteaccessTrojan(RAT).ARATisatoolusedby
attackerstoremotelyperformactionsonacompromised
victim’smachine,suchasaccessingthefilesystem,executing
code,andsniffingnetworktraffic.
BuildingthisRATrequiresbuildingthreeseparatetools:a
clientimplant,aserver,andanadmincomponent.Theclient
implantistheportionoftheRATthatrunsonacompromised
workstation.Theserveriswhatwillinteractwiththeclient
implant,muchlikethewayCobaltStrike’steamserver—the
servercomponentofthewidelyusedC2tool—sends
commandstocompromisedsystems.Unliketheteamserver,
whichusesasingleservicetofacilitateserverand
administrativefunctions,we’llcreateaseparate,stand-alone
admincomponentusedtoactuallyissuethecommands.This
serverwillactasthemiddleman,choreographing
communicationsbetweencompromisedsystemsandthe
attackerinteractingwiththeadmincomponent.
ThereareaninfinitenumberofwaystodesignaRAT.In
thischapter,weaimtohighlighthowtohandleclientand
servercommunicationsforremoteaccess.Forthisreason,
we’llshowyouhowtobuildsomethingsimpleand
unpolished,andthenpromptyoutocreatesignificant
improvementsthatshouldmakeyourspecificversionmore
robust.Theseimprovements,inmanycases,willrequireyou
toreusecontentandcodeexamplesfrompreviouschapters.
You’llapplyyourknowledge,creativity,andproblem-solving
abilitytoenhanceyourimplementation.
GETTINGSTARTED
Togetstarted,let’sreviewwhatwe’regoingtodo:we’ll
createaserverthatreceivesworkintheformofoperating
systemcommandsfromanadmincomponent(whichwe’ll
alsocreate).We’llcreateanimplantthatpollstheserver
periodicallytolookfornewcommandsandthenpublishesthe
commandoutputbackontotheserver.Theserverwillthen
handthatresultbacktotheadministrativeclientsothatthe
operator(you)canseetheoutput.
Let’sstartbyinstallingatoolthatwillhelpushandleall
thesenetworkinteractionsandreviewingthedirectory
structureforthisproject.
InstallingProtocolBuffersforDefiningagRPCAPI
We’llbuildallthenetworkinteractionsbyusinggRPC,a
high-performanceremoteprocedurecall(RPC)framework
createdbyGoogle.RPCframeworksallowclientsto
communicatewithserversoverstandardanddefinedprotocols
withouthavingtounderstandanyoftheunderlyingdetails.
ThegRPCframeworkoperatesoverHTTP/2,communicating
messagesinahighlyefficient,binarystructure.
MuchlikeotherRPCmechanisms,suchasRESTor
SOAP,ourdatastructuresneedtobedefinedinordertomake
themeasytoserializeanddeserialize.Luckilyforus,there’sa
mechanismfordefiningourdataandAPIfunctionssowecan
usethemwithgRPC.Thismechanism,ProtocolBuffers(or
Protobuf,forshort),includesastandardsyntaxforAPIand
complexdatadefinitionsintheformofa.protofile.Tooling
existstocompilethatdefinitionfileintoGo-friendlyinterface
stubsanddatatypes.Infact,thistoolingcanproduceoutputin
avarietyoflanguages,meaningyoucanusethe.protofileto
generateC#stubsandtypes.
YourfirstorderofbusinessistoinstalltheProtobuf
compileronyoursystem.Walkingthroughtheinstallationis
outsidethescopeofthisbook,butyou’llfindfulldetailsunder
the“Installation”sectionoftheofficialGoProtobufrepository
athttps://github.com/golang/protobuf/.Also,whileyou’reat
it,installthegRPCpackagewiththefollowingcommand:
>goget-ugoogle.golang.org/grpc
CreatingtheProjectWorkspace
Next,let’screateourprojectworkspace.We’llcreatefour
subdirectoriestoaccountforthethreecomponents(the
implant,server,andadmincomponent)andthegRPCAPI
definitionfiles.Ineachofthecomponentdirectories,we’ll
createasingleGofile(ofthesamenameastheencompassing
directory)that’llbelongtoitsownmainpackage.Thisletsus
independentlycompileandruneachasastand-alone
componentandwillcreateadescriptivebinarynameinthe
eventwerungobuildonthecomponent.We’llalsocreateafile
namedimplant.protoinourgrpcapidirectory.Thatfilewill
holdourProtobufschemaandgRPCAPIdefinitions.Here’s
thedirectorystructureyoushouldhave:
$tree
.
|--client
||--client.go
|--grpcapi
||--implant.proto
|--implant
||--implant.go
|--server
|--server.go
Withthestructurecreated,wecanbeginbuildingour
implementation.Throughoutthenextseveralsections,we’ll
walkyouthroughthecontentsofeachfile.
DEFININGANDBUILDINGTHE
GRPCAPI
Thenextorderofbusinessistodefinethefunctionalityand
dataourgRPCAPIwilluse.Unlikebuildingandconsuming
RESTendpoints,whichhaveafairlywell-definedsetof
expectations(forexample,theyuseHTTPverbsandURL
pathstodefinewhichactiontotakeonwhichdata),gRPCis
morearbitrary.YoueffectivelydefineanAPIserviceandtie
toitthefunctionprototypesanddatatypesforthatservice.
We’lluseProtobufstodefineourAPI.Youcanfindafull
explanationoftheProtobufsyntaxwithaquickGoogle
search,butwe’llbrieflyexplainithere.
Ataminimum,we’llneedtodefineanadministrative
serviceusedbyoperatorstosendoperatingsystemcommands
(work)totheserver.We’llalsoneedanimplantserviceused
byourimplanttofetchworkfromtheserverandsendthe
commandoutputbacktotheserver.Listing14-1showsthe
contentsoftheimplant.protofile.(Allthecodelistingsatthe
rootlocationof/existundertheprovidedgithubrepo
https://github.com/blackhat-go/bhg/.)
//implant.proto
syntax="proto3";
❶packagegrpcapi;
//ImplantdefinesourC2APIfunctions
❷serviceImplant{
rpcFetchCommand(Empty)returns(Command);
rpcSendOutput(Command)returns(Empty);
}
//AdmindefinesourAdminAPIfunctions
❸serviceAdmin{
rpcRunCommand(Command)returns(Command);
}
//Commanddefinesawithbothinputandoutputfields
❹messageCommand{
stringIn=1;
stringOut=2;
}
//Emptydefinesanemptymessageusedinplaceofnull
❺messageEmpty{
}
Listing14-1:DefiningthegRPCAPIbyusingProtobuf(/ch-
14/grpcapi/implant.proto)
Recallhowweintendtocompilethisdefinitionfileinto
Go-specificartifacts?Well,weexplicitlyincludepackagegrpcapi
❶toinstructthecompilerthatwewanttheseartifactscreated
underthegrpcapipackage.Thenameofthispackageis
arbitrary.WepickedittoensurethattheAPIcoderemains
separatefromtheothercomponents.
OurschemathendefinesaservicenamedImplantanda
servicenamedAdmin.We’reseparatingthesebecausewe
expectourImplantcomponenttointeractwithourAPIina
differentmannerthanourAdminclient.Forexample,we
wouldn’twantourImplantsendingoperatingsystemcommand
worktoourserver,justaswedon’twanttorequireourAdmin
componenttosendcommandoutputtotheserver.
WedefinetwomethodsontheImplantservice:FetchCommand
andSendOutput❷.Definingthesemethodsislikedefiningan
interfaceinGo.We’resayingthatanyimplementationofthe
Implantservicewillneedtoimplementthosetwomethods.
FetchCommand,whichtakesanEmptymessageasaparameterand
returnsaCommandmessage,willretrieveanyoutstanding
operatingsystemcommandsfromtheserver.SendOutputwill
sendaCommandmessage(whichcontainscommandoutput)
backtotheserver.Thesemessages,whichwe’llcover
momentarily,arearbitrary,complexdatastructuresthat
containfieldsnecessaryforustopassdatabackandforth
betweenourendpoints.
OurAdminservicedefinesasinglemethod:RunCommand,
whichtakesaCommandmessageasaparameterandexpectsto
readaCommandmessageback❸.Itsintentionistoallowyou,
theRAToperator,torunanoperatingsystemcommandona
remotesystemthathasarunningimplant.
Lastly,wedefinethetwomessageswe’llbepassing
around:CommandandEmpty.TheCommandmessagecontainstwo
fields,oneusedformaintainingtheoperatingsystem
commanditself(astringnamedIn)andoneusedfor
maintainingthecommandoutput(astringnamedOut)❹.Note
thatthemessageandfieldnamesarearbitrary,butthatwe
assigneachfieldanumericalvalue.Youmightbewondering
howwecanassignInandOutnumericalvaluesifwedefined
themtobestrings.Theansweristhatthisisaschema
definition,notanimplementation.Thosenumericalvalues
representtheoffsetwithinthemessageitselfwherethose
fieldswillappear.We’resayingInwillappearfirst,andOut
willappearsecond.TheEmptymessagecontainsnofields❺.
ThisisahacktoworkaroundthefactthatProtobufdoesn’t
explicitlyallownullvaluestobepassedintoorreturnedfrom
anRPCmethod.
Nowwehaveourschema.TowrapupthegRPCdefinition,
weneedtocompiletheschema.Runthefollowingcommand
fromthegrpcapidirectory:
>protoc-I.implant.proto--go_out=plugins=grpc:./
Thiscommand,whichisavailableafteryoucompletethe
initialinstallationwementionedearlier,searchesthecurrent
directoryfortheProtobuffilenamedimplant.protoand
producesGo-specificoutputinthecurrentdirectory.Onceyou
executeitsuccessfully,youshouldhaveanewfilenamed
implant.pb.goinyourgrpcapidirectory.Thisnewfilecontains
theinterfaceandstructdefinitionsfortheservicesandmessages
createdintheProtobufschema.We’llleveragethisfor
buildingourserver,implant,andadmincomponent.Let’s
buildtheseonebyone.
CREATINGTHESERVER
Let’sstartwiththeserver,whichwillacceptcommandsfrom
theadminclientandpollingfromtheimplant.Theserverwill
bethemostcomplicatedofthecomponents,sinceit’llneedto
implementboththeImplantandAdminservices.Plus,sinceit’s
actingasamiddlemanbetweentheadmincomponentand
implant,it’llneedtoproxyandmanagemessagescomingto
andfromeachside.
ImplementingtheProtocolInterface
Let’sfirstlookatthegutsofourserverinserver/server.go
(Listing14-2).Here,we’reimplementingtheinterface
methodsnecessaryfortheservertoreadandwritecommands
fromandtosharedchannels.
❶typeimplantServerstruct{
work,outputchan*grpcapi.Command
}
typeadminServerstruct{
work,outputchan*grpcapi.Command
}
❷funcNewImplantServer(work,outputchan*grpcapi.Command)*implantServer
{
s:=new(implantServer)
s.work=work
s.output=output
returns
}
funcNewAdminServer(work,outputchan*grpcapi.Command)*adminServer{
s:=new(adminServer)
s.work=work
s.output=output
returns
}
❸func(s*implantServer)FetchCommand(ctxcontext.Context,\
empty*grpcapi.Empty)(*grpcapi.Command,error){
varcmd=new(grpcapi.Command)
❹select{
casecmd,ok:=<-s.work:
ifok{
returncmd,nil
}
returncmd,errors.New("channelclosed")
default:
//Nowork
returncmd,nil
}
}
❺func(s*implantServer)SendOutput(ctxcontext.Context,\
result*grpcapi.Command)
(*grpcapi.Empty,error){
s.output<-result
return&grpcapi.Empty{},nil
}
❻func(s*adminServer)RunCommand(ctxcontext.Context,cmd
*grpcapi.Command)\
(*grpcapi.Command,error){
varres*grpcapi.Command
gofunc(){
s.work<-cmd
}()
res=<-s.output
returnres,nil
}
Listing14-2:Definingtheservertypes(/ch-14/server/server.go)
ToserveouradminandimplantAPIs,weneedtodefine
servertypesthatimplementallthenecessaryinterface
methods.ThisistheonlywaywecanstartanImplantorAdmin
service.Thatis,we’llneedtohavetheFetchCommand(ctx
context.Context,empty*grpcapi.Empty),SendOutput(ctxcontext.Context,result
*grpcapi.Command),andRunCommand(ctxcontext.Context,cmd
*grpcapi.Command)methodsproperlydefined.Tokeepour
implantandadminAPIsmutuallyexclusive,we’llimplement
themasseparatetypes.
First,wecreateourstructs,namedimplantServerandadminServer,
that’llimplementthenecessarymethods❶.Eachtype
containsidenticalfields:twochannels,usedforsendingand
receivingworkandcommandoutput.Thisisaprettysimple
wayforourserverstoproxythecommandsandtheir
responsesbetweentheadminandimplantcomponents.
Next,wedefineacoupleofhelperfunctions,
NewImplantServer(work,outputchan*grpcapi.Command)and
NewAdminServer(work,outputchan*grpcapi.Command),thatcreatenew
implantServerandadminServerinstances❷.Theseexistsolelyto
makesurethechannelsareproperlyinitialized.
Nowcomestheinterestingpart:theimplementationofour
gRPCmethods.Youmightnoticethatthemethodsdon’t
exactlymatchtheProtobufschema.Forexample,we’re
receivingacontext.Contextparameterineachmethodand
returninganerror.Theprotoccommandyouranearlierto
compileyourschemaaddedthesetoeachinterfacemethod
definitioninthegeneratedfile.Thisletsusmanagerequest
contextandreturnerrors.Thisisprettystandardstuffformost
networkcommunications.Thecompilersparedusfromhaving
toexplicitlyrequirethatinourschemafile.
ThefirstmethodweimplementonourimplantServer,
FetchCommand(ctxcontext.Context,empty*grpcapi.Empty),receivesa
*grpcapi.Emptyandreturnsa*grpcapi.Command❸.Recallthatwe
definedthisEmptytypebecausegRPCdoesn’tallownullvalues
explicitly.Wedon’tneedtoreceiveanyinputsincetheclient
implantwillcalltheFetchCommand(ctxcontext.Context,empty*grpcapi
.Empty)methodassortofapollingmechanismthatasks,“Hey,
doyouhaveworkforme?”Themethod’slogicisabitmore
complicated,sincewecansendworktotheimplantonlyifwe
actuallyhaveworktosend.So,weuseaselectstatement❹on
theworkchanneltodeterminewhetherwedohavework.
Readingfromachannelinthismannerisnonblocking,
meaningthatexecutionwillrunourdefaultcaseifthere’s
nothingtoreadfromthechannel.Thisisideal,sincewe’ll
haveourimplantcallingFetchCommand(ctxcontext.Context,empty
*grpcapi.Empty)onaperiodicbasisasawaytogetworkona
near-real-timeschedule.Intheeventthatwedohaveworkin
thechannel,wereturnthecommand.Behindthescenes,the
commandwillbeserializedandsentoverthenetworkbackto
theimplant.
ThesecondimplantServermethod,SendOutput(ctxcontext.Context,
result*grpcapi.Command),pushesthereceived*grpcapi.Commandonto
theoutputchannel❺.RecallthatwedefinedourCommandto
havenotonlyastringfieldforthecommandtorun,butalsoa
fieldtoholdthecommand’soutput.SincetheCommandwe’re
receivinghastheoutputfieldpopulatedwiththeresultofa
command(asrunbytheimplant)theSendOutput(ctxcontext.Context,
result*grpcapi.Command)methodsimplytakesthatresultfromthe
implantandputsitontoachannelthatouradmincomponent
willreadfromlater.
ThelastimplantServermethod,RunCommand(ctxcontext.Context,cmd
*grpcapi.Command),isdefinedontheadminServertype.Itreceivesa
Commandthathasnotyetbeensenttotheimplant❻.It
representsaunitofworkouradmincomponentwantsour
implanttoexecute.Weuseagoroutinetoplaceourworkon
theworkchannel.Aswe’reusinganunbufferedchannel,this
actionblocksexecution.Weneedtobeabletoreadfromthe
outputchannel,though,soweuseagoroutinetoputworkon
thechannelandcontinueexecution.Executionblocks,waiting
foraresponseonouroutputchannel.We’veessentiallymade
thisflowasynchronoussetofsteps:sendacommandtoan
implantandwaitforaresponse.Whenwereceivethe
response,wereturntheresult.Again,weexpectthisresult,a
Command,tohaveitsoutputfieldpopulatedwiththeresultof
theoperatingsystemcommandexecutedbytheimplant.
Writingthemain()Function
Listing14-3showstheserver/server.gofile’smain()function,
whichrunstwoseparateservers—onetoreceivecommands