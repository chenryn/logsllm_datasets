Currently, using app.test_client() together with multi-threaded environment
will fail:
    from concurrent.futures import ThreadPoolExecutor
    from flask import Flask, jsonify
    app = Flask(__name__)
    @app.route("/info")
    def info():
        return jsonify({"status": "success"})
    app.testing = True
    with app.test_client() as client:
        def check(*args):
            return client.get("/info")
        with ThreadPoolExecutor(5) as tpe:
            print(tpe.map(check, range(5)))
with
    Traceback (most recent call last):
      File "/Users/X/.pyenv/versions/flow-venv-3.9/lib/python3.9/site-packages/flask/ctx.py", line 399, in pop
        self.app.do_teardown_request(exc)
      File "/Users/X/.pyenv/versions/flow-venv-3.9/lib/python3.9/site-packages/flask/app.py", line 2370, in do_teardown_request
        for name in chain(request.blueprints, (None,)):
      File "/Users/X/.pyenv/versions/flow-venv-3.9/lib/python3.9/site-packages/werkzeug/local.py", line 316, in __get__
        obj = instance._get_current_object()  # type: ignore[misc]
      File "/Users/X/.pyenv/versions/flow-venv-3.9/lib/python3.9/site-packages/werkzeug/local.py", line 513, in _get_current_object
        raise RuntimeError(unbound_message) from None
    RuntimeError: Working outside of request context.
Obviously, this can be solved by running the app as standalone (see
http://www.prschmid.com/2013/01/multi-threaded-unit-test-for-flask-rest.html),
but then I have to add manual error control and re-rise and do not get proper
tracebacks while testing, and code coverage is also not given.