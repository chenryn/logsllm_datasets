If ğ‘sent â‰  ğ‘recv + 1 then
Return âŠ¥
Return ğ‘šsent
Figure 23: Support function SUPP for strict in-order delivery.
ğ‘op â† ğ‘op + 1
If label(cid:48) = label then
Return (ğ‘op, ğ‘š)
(op = sent âˆ§ label(cid:48) â‰ âŠ¥) then
If (op = recv âˆ§ ğ‘š â‰ âŠ¥)âˆ¨
Return (ğ‘op,âŠ¥)
MTP-ME(F) = 0 for any F making
sent by user u, so we have Advupref
at most 296 queries, and otherwise there exists an adversary
F such that Advupref
MTP-ME(F) = 1. Note that MTP-ME always has
payloads larger than 256 bits. The MTProto implementation
of message encoding we analysed was not UPREF-secure as
it allowed repeated msg_id (cf. Section IV-B2).
Game Gupref
ME,F
win â† false
(stME,I , stME,R)
â†$ ME.Init()
ğ‘‹I â† ğ‘‹R â† âˆ…
F Send; Return win
Figure 24: Preï¬x uniqueness of message encoding scheme ME.
Send(u, ğ‘š, aux, ğ‘Ÿ)
(stME,u, ğ‘) â† ME.Encode(stME,u, ğ‘š, aux; ğ‘Ÿ)
If | ğ‘| < 256 then return âŠ¥
ğ‘0 â† ğ‘[0 : 256]
If ğ‘0 âˆˆ ğ‘‹u then win â† true
ğ‘‹u â† ğ‘‹u âˆª {ğ‘0} ; Return ğ‘
3) Encoding robustness of MTP-ME: We require that decoding
in MTP-ME should not affect its state in such a way that
would be visible in future encoded payloads, as deï¬ned by
the security game in Fig. 25. The advantage of an adversary
D in breaking the ENCROB-security of a message encoding
ME,D ] âˆ’
scheme ME is deï¬ned as Advencrob
1. This advantage is trivially zero both for MTP-ME and the
original MTProto message encoding scheme (modelled in the
full version). Note, however, that this property is incompatible
with stronger notions of resistance against reordering attacks
such as causality preservation.
(D) = 2 Â· Pr[Gencrob
ME
Game Gencrob
ME,D
ğ‘ â†$ {0, 1} ; (stME,I , stME,R) â†$ ME.Init()
ğ‘(cid:48) â†$ DSend,Recv ; Return ğ‘(cid:48) = ğ‘
Send(u, ğ‘š, aux, ğ‘Ÿ)
(stME,u, ğ‘) â† ME.Encode(stME,u, ğ‘š, aux; ğ‘Ÿ) ; Return ğ‘
Recv(u, ğ‘, aux)
If ğ‘ = 1 then (stME,u, ğ‘š) â† ME.Decode(stME,u, ğ‘, aux)
Return âŠ¥
Figure 25: Encoding robustness of message encoding scheme
ME.
4) Combined security of MTP-SE and MTP-ME: We require
that decryption in MTP-SE with uniformly random keys has
unpredictable outputs with respect to MTP-ME, as deï¬ned in
Fig. 26. The security game Gunpred
SE,ME,F in Fig. 26 gives adversary
F access to two oracles. For any user u âˆˆ {I, R} and
message key msg_key, oracle Ch decrypts a given ciphertext
ğ‘se of deterministic symmetric encryption scheme SE under
a uniformly random key ğ‘˜ âˆˆ {0, 1}SE.kl, and then decodes
it using the given message encoding state stME of message
encoding scheme ME, returning no output. The adversary is
allowed to choose arbitrary values of ğ‘se and stME; it is allowed
to repeatedly query oracle Ch on inputs that contain the same
values for u, msg_key in order to reuse a ï¬xed, secret SE key ğ‘˜
with different choices of ğ‘se. Oracle Expose lets F learn the
SE key corresponding to the given u and msg_key; the table S
is then used to disallow the adversary from querying Ch with
this pair of u and msg_key values again. F wins if it can cause
ME.Decode to output a valid ğ‘š â‰  âŠ¥. Note that msg_key in
this game merely serves as a label for the tables, so we allow it
to be an arbitrary string msg_key âˆˆ {0, 1}âˆ—. The advantage of
F in breaking the UNPRED-security of SE with respect to ME
SE,ME,F]. In the full version
is deï¬ned as Advunpred
MTP-SE,MTP-ME(F) â‰¤ ğ‘Ch/264 for
of this work we show that Advunpred
any F making ğ‘Ch queries.
SE,ME (F) = Pr[Gunpred
Game Gunpred
SE,ME,F
win â† false ; F Expose,Ch ; Return win
Expose(u, msg_key)
S[u, msg_key] â† true ; Return T[u, msg_key]
Ch(u, msg_key, ğ‘se, stME, aux)
If Â¬S[u, msg_key] then
// msg_key âˆˆ {0, 1}âˆ—
// msg_key âˆˆ {0, 1}âˆ—
If T[u, msg_key] =âŠ¥ then T[u, msg_key] â†$ {0, 1}SE.kl
ğ‘˜ â† T[u, msg_key] ; ğ‘ â† SE.Dec(ğ‘˜, ğ‘se)
(stME, ğ‘š) â† ME.Decode(stME, ğ‘, aux)
If ğ‘š â‰  âŠ¥ then win â† true
Return âŠ¥
Figure 26: Unpredictability of deterministic symmetric encryp-
tion scheme SE with respect to message encoding scheme ME.
D. Correctness of MTP-CH
We claim that our MTProto-based channel satisï¬es our
correctness deï¬nition. Consider any adversary F playing
in the correctness game Gcorr
CH,supp,F (Fig. 6) for channel
CH = MTP-CH (Fig. 12) and support function supp = SUPP
(Fig. 23). Due to the deï¬nition of SUPP, the Recv oracle in
game Gcorr
MTP-CH,SUPP,F rejects all CH ciphertexts that were not
previously returned by Send. The encryption and decryption
algorithms of channel MTP-CH rely in a modular way on
the message encoding scheme MTP-ME, deterministic function
families MTP-KDF, MTP-MAC, and deterministic symmetric
encryption scheme MTP-SE; the latter provides decryption
correctness, so any valid ciphertext processed by oracle
Recv correctly recovers the originally encrypted payload
ğ‘. Thus we need to show that MTP-ME always recovers the
expected plaintext ğ‘š from payload ğ‘, meaning ğ‘š matches the
corresponding output of SUPP. This is implied by the EINT-
security of MTP-ME with respect to SUPP; we prove the latter
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:42 UTC from IEEE Xplore.  Restrictions apply. 
101
in the full version of this work for adversaries that make at
most 296 queries.22
E. IND-security of MTP-CH
Due to lack of space, here we provide only a very high-level
overview of how we prove IND-security of MTP-CH and a
theorem statement. We begin our IND-security reduction by
considering an arbitrary adversary DIND playing in the IND-
security game against channel CH = MTP-CH (i.e. Gind
CH,DIND
in Fig. 6), and we gradually change this game until we can
show that DIND can no longer win. To this end, we make three
key observations. (1) Recall that oracle Recv always returns
âŠ¥, and the only functionality of this oracle is to update the
state of receiverâ€™s channel by calling CH.Recv. We assume
that calls to CH.Recv never affect the ciphertexts that are
returned by future calls to CH.Send (more precisely, we use the
ENCROB property of ME that reasons about payloads rather
than ciphertexts). This allows us to completely disregard the
Recv oracle, making it immediately return âŠ¥ without calling
CH.Recv. (2) We use the UPRKPRF-security of MAC to show
that the ciphertexts returned by oracle Ch contain msg_key
values that look uniformly random and are independent of
each other. Roughly, this security notion requires that MAC
can only be evaluated on a set of inputs with unique preï¬xes.
To ensure this, we assume that the payloads produced by ME
meet this requirement (as formalised by the UPREF property
of ME). (3) In order to prove that oracle Ch does not leak
the challenge bit, it remains to show that ciphertexts returned
by Ch contain ğ‘se values that look uniformly random and
independent of each other. This follows from the OTIND$-
security of SE. We invoke the OTWIND-security of HASH to
show that auth_key_id does not leak any information about
the KDF keys; we then use the RKPRF-security of KDF to show
that the keys used for SE are uniformly random. Finally, we
use the birthday bound to argue that the uniformly random
values of msg_key are unlikely to collide, and hence the keys
used for SE are also one-time. Formally, we have:
Theorem 1. Let ME, HASH, MAC, KDF, ğœ™MAC, ğœ™KDF, SE be any
primitives that meet the requirements stated in Deï¬nition 5
of channel MTP-CH. Let CH = MTP-CH[ME, HASH, MAC, KDF,
ğœ™MAC, ğœ™KDF, SE]. Let DIND be any adversary against the IND-
security of CH, making ğ‘Ch queries to its Ch oracle. Then
there exist adversaries DOTWIND, DRKPRF, DENCROB, FUPREF,
DUPRKPRF, DOTIND$ such that
Advotwind
Advind
+ Advencrob
+ Advuprkprf
MAC, ğœ™MAC
+ Advotind$
HASH (DOTWIND) + Advrkprf
(FUPREF)
(DENCROB) + Advupref
ME
ME
(DOTIND$)(cid:17)
(DUPRKPRF) + ğ‘Ch Â· (ğ‘Ch âˆ’ 1)
2 Â· 2MAC.ol
CH (DIND) â‰¤ 2 Â·(cid:16)
(DRKPRF)
KDF, ğœ™KDF
.
SE
The proof can be found in the full version of this work.
22There are other ways to handle counters which could imply correctness
for unbounded adversaries â€“ MTP-ME wraps its counters to stay close to the
actual MTProto implementations.
F. INT-security of MTP-CH
Due to lack of space, here we provide only a very high-level
overview of how we prove integrity of MTP-CH and a theorem
statement. Details are in the full version. The ï¬rst half of
our integrity proof shows that it is hard to forge ciphertexts;
in order to justify this, we rely on security properties of the
cryptographic primitives that are used to build the channel
MTP-CH (i.e. HASH, KDF, SE, and MAC). Once ciphertext
forgery is ruled out, we are guaranteed that MTP-CH broadly
matches an intuition of an authenticated channel: it prevents
an attacker from modifying or creating its own ciphertexts but
still allows it to intercept and subsequently drop, reorder or
replay honestly produced ciphertexts. So it remains to show
that the message encoding scheme ME appropriately resolves
all of the possible adversarial interaction with an authenticated
channel; formally, we require that it behaves according to the
requirements that are speciï¬ed by some support function supp.
Our main result is then:
Theorem 2. Let session_id âˆˆ {0, 1}64, pb âˆˆ N, and bl = 128.
Let ME = MTP-ME[session_id, pb, bl] be the message encoding
scheme as deï¬ned in Deï¬nition 6. Let SE = MTP-SE be the
deterministic symmetric encryption scheme as deï¬ned in Deï¬n-
ition 10. Let HASH, MAC, KDF, ğœ™MAC, ğœ™KDF be any primitives
that, together with ME and SE, meet the requirements stated in
Deï¬nition 5 of channel MTP-CH. Let CH = MTP-CH[ME, HASH,
MAC, KDF, ğœ™MAC, ğœ™KDF, SE]. Let supp = SUPP be the support
function as deï¬ned in Fig. 23. Let FINT be any adversary
against the INT-security of CH with respect to supp. Then
there exist adversaries DOTWIND, DRKPRF, FUNPRED, FRKCR,
FEINT such that
Advint
CH,supp(FINT) â‰¤ Advotwind
+ Advunpred
+ Adveint
HASH (DOTWIND) + Advrkprf
SE,ME (FUNPRED) + Advrkcr
ME,supp(FEINT).
(DRKPRF)
(FRKCR)
MAC, ğœ™MAC
KDF, ğœ™KDF
The proof can be found in the full version of this work.
G. Instantiation and Interpretation
We are now ready to combine the theorems from the previous
two sections with the notions deï¬ned in Section V-A and
Section V-C and the proofs in the full version of this work. This
is meant to allow interpretation of our main results: qualitatively
(what security assumptions are made) and quantitatively (what
security level is achieved). Note that in both of the following
corollaries, the adversary is limited to making 296 queries.
This is due to the wrapping of counters in MTP-ME, since
beyond this limit the advantage in breaking UPREF-security
and EINT-security of MTP-ME becomes 1.
Corollary 1. Let session_id âˆˆ {0, 1}64, pb âˆˆ N and bl = 128.
Let ME = MTP-ME[session_id, pb, bl], MTP-HASH, MTP-MAC,
MTP-KDF, ğœ™MAC, ğœ™KDF, MTP-SE be the primitives of MTProto
deï¬ned in Section IV-D. Let CH = MTP-CH[ME, MTP-HASH,
MTP-MAC, MTP-KDF, ğœ™MAC, ğœ™KDF, MTP-SE]. Let ğœ™SHACAL-2 be
the related-key-deriving function deï¬ned in Fig. 20. Let â„256
be the SHA-256 compression function, and let H be the corres-
ponding function family with H.Ev = â„256, H.kl = H.ol = 256
and H.In = {0, 1}512. Let â„“ âˆˆ N. Let DIND be any adversary
against the IND-security of CH, making ğ‘Ch â‰¤ 296 queries
to its Ch oracle, each query made for a message of length
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:42 UTC from IEEE Xplore.  Restrictions apply. 
102
at most â„“ â‰¤ 227 bits.23 Then there exist adversaries Dshacal
OTPRF,
DLRKPRF, DHRKPRF, Dcompr
Advind
OTPRF, DOTIND$ such that