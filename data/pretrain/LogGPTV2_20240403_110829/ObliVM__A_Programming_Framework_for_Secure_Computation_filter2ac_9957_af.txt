designed an oblivious AVL tree algorithm, but were unable to
implement it due to high programming complexity. Now, with
ObliVM, we implement an AVL tree with 311 lines of code
in ObliVM-lang, consuming under 10 student·hours (including
the implementation as well as debugging).
We stress that it is not possible to implement oblivious AVL
tree in previous languages for secure computation, including
the state-of-the-art Wysteria [17].
D. End-to-End Application Performance
Currently in ObliVM-GC, we implemented a standard
garbling scheme with Garbled Row Reduction [36] and Fre-
eXOR [5]. We also implemented an OT extension protocol
proposed by Ishai et al. [3] and a basic OT protocol by Naor
and Pinkas [55].
Setup. For evaluation, here we consider a scenario where a
client secret shares its data between two non-colluding cloud
providers a priori. For cases where inputs are a large dataset
(e.g., Heap, Map/Set, etc), depending on the application, the
client may sometimes need to place the inputs in an ORAM,
and secret-share the resulting ORAM among the two cloud
providers. We do not measure this setup cost in our evaluation
– this cost can depend highly on the available bandwidth
372
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:08:02 UTC from IEEE Xplore.  Restrictions apply. 
Program
Input size
CMBC-GC
(estimate)
#AND
gates
ObliVM Framework
ObliVM + JustGarble
(estimate)
Total
time
Online
time
0.12ms
69.4ms
1.96ms
0.36ms
0.52ms
0.39ms
4.58min
20.4min
19.6min
1.7min
1.5s
2.9s
189ms
0.98s
1.21s
0.05ms
28.9ms
0.82ms
0.15ms
0.22ms
0.16ms
1.9min
8.5min
8.2min
42.5s
625ms
1.2s
78.8ms
0.41s
504ms
Integer addition
Integer mult.
Integer Comparison
Floating point addition
Floating point mult.
Hamming distance
1024 bits
1024 bits
16384 bits
64 bits
64 bits
1600 bits
2977
6.4M
32K
10K
10K
30K
Total
#AND
time
gates
Basic instructions
1024
572K
16384
3035
4312
3200
335.7ms
104ms
104ms
310ms
31ms
66.4s
Total
time
Online
time
1.7ms
833ms
26ms
4.32ms
6.29ms
5.07ms
0.6ms
274ms
8.58ms
1.45ms
2.02ms
1.71ms
K-Means
Dijkstra’s Algorithm
MST
Histogram
Heap
Map/Set
Binary Search
Count Min Sketch
AMS Sketch
Linear or super-linear algorithms
0.5MB
48KB
48KB
0.25MB
1GB
1GB
1GB
0.31GB
1.25GB
550B
755B
755B
137B
32B
32B
32B
9.9B
40B
66d
91d
91d
16.5d
2269M 62.1min
10B
12.6h
9.6B
12.4h
866M 21.5min
Sublinear-time algorithms
23.6min
3.09h
3h
8.56min
3.9d
3.9d
3.9d
30.8h
5.18d
12.5M
59.3s
23.9M 117.2s
7.36s
1562K
20.77s
8088K
9949K
36.76s
10.42s
20.67s
1.34s
6.4s
9.95s
TABLE IV: Application performance. Actual measured numbers are in bold. The remainder are estimated numbers and should
be interpreted with care. ObliVM numbers for basic instructions and sublinear-time algorithms are the mean of 20 runs. Since
for all these applications, our measurements have small spread (all runs are within 6% from the mean), we use a single run for
linear-time and super-linear algorithms (the same for Table V).
between the client and the two cloud providers. Therefore, our
evaluation begins assuming this one-time setup has completed.
End-to-end application performance. In Table IV, we con-
sider three types of applications, basic instructions (e.g., ad-
dition, multiplication, and ﬂoating point operations);
linear
or super-linear algorithms (e.g., Dijkstra, K-Means, Minimum
Spanning Tree, and Histogram); and sublinear-time algorithms
(e.g., Heap, Map/Set, Binary Search, Count Min Sketch, AMS
Sketch). We report the circuit size, online and total costs for
a variety of applications at typical data sizes.
In Table IV, we also compare ObliVM with a state-of-
the-art automated secure computation system CMBC-GC [16].
We note that the authors of CMBC-GC did not run all of
these application benchmarks, so we project the performance
of CMBC-GC using the following estimate: we ﬁrst change
our compiler to adopt a linear scan of memory upon dynamic
memory accesses – this allows us to obtain an estimate of
the circuit size CMBC-GC would have obtained for the same
applications. For the set of application benchmarks (e.g., K-
Means, MST, etc) CMBC-GC did report in their paper, we
conﬁrmed that our circuit size estimates are always a lower
bound of what CMBC-GC reported. We then estimate the
runtime of CMBC-GC based on their reported 96K AND
gates per sec – assuming that a network bandwidth of at least
2.8MBps is provisioned.
As mentioned earlier, the focus of this paper is our lan-
guage and compiler, not the back end cryptographic implemen-
tation. It should be relatively easy to integrate our language
and compiler with a JustGarble-like back end that employs
hardware AES-NI. In Table IV, we also give an estimate
of the performance we anticipate if we ran our ObliVM-
generated circuits over a JustGarble-like back end. This is
calculated using our circuit sizes and the 11M AND gates/sec
performance number reported by JustGarble [4].
• Online cost. To measure online cost, we assume that
all work that is independent of input data is performed
ofﬂine, including garbling and input-independent OT pre-
processing. Our present ObliVM implementation achieves
an online speed of 1.8M gates/sec consuming roughly
54MBps network bandwidth.
• Ofﬂine cost. When no work is deferred to an ofﬂine phase,
ObliVM achieves a garbling speed of 670K gates/sec
consuming 19MBps network bandwidth.
Slowdown relative to a non-secure baseline. For complete-
ness, we now describe ObliVM’s slowdown in comparison
with a non-secure baseline where computation is performed
in cleartext. As shown in Table V, our slowdown relative to a
non-secure baseline is application dependent, and ranges from
45× to 9.3 × 106×. We also present the estimated slowdown
if a JustGarble-like back end is used for ObliVM-generated
circuits. These numbers are estimated based on our circuit
sizes as well as the reported 11M AND gates/sec performance
metric reported by JustGarble [4].
In particular, we elaborate on the following interest-
ing cases. First,
the distributed genome-wide association
study(GWAS) application is Task 1 in the iDash secure ge-
nomic analysis competition [56], with total data size 380KB.
This task achieves a small slowdown, because part of the
computation is done locally – speciﬁcally, Alice and Bob each
performs some local preprocessing to obtain the alle frequen-
373
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:08:02 UTC from IEEE Xplore.  Restrictions apply. 
Task
Cleartext Time
K-Means
0.4ms
Distributed GWAS
40ms
Binary Search
10μs
AMS Sketch
80μs
Hamming dist.
0.3μs
Online
Total
Online
Total
Online
Total
Online
Total
Online
Total
ObliVM
Runtime
Slowdown
ObliVM+JustGB
(estimate)
Slowdown
24min
3.6 × 106
62min
9.3 × 106
1.9min
2.9 × 105
4.58min
6.9 × 105
1.8s
45
0.14s
3.5
5.2s
130
0.28s
7
1.3s
1.3 × 105
7.4s
7.4 × 105
9.5s
1.2 × 105
36.8s
4.6 × 105
1.71ms
6 × 103
5.07ms
1.7 × 104
78.8ms
7.9 × 103
189ms
1.9 × 104
0.5s
6.3 × 103
1.2s
1.5 × 104
0.16ms
5.3 × 102
0.39ms
1.3 × 103
TABLE V: Slowdown of secure computation compared with non-secure, cleartext computation. Parameter choices are the
same as Table IV. Online cost only includes operations that are input-dependent. All time measurements assume data are pre-
loaded to the memory. ObliVM requires a bandwidth of 19MBps. Numbers for JustGarble are estimated using ObliVM-generated
circuit sizes assuming 315MBps bandwidth.
cies of their own data, before engaging in a secure computation
protocol to compute χ2-statistics. For details, we refer the
reader to our online short note on how we implemented the
competition tasks. On the other hand, benchmarks with ﬂoating
point operations such as K-Means incur a relatively larger
slowdown because modern processors have special ﬂoating
point instructions which makes it favorable to the insecure
baseline.
VIII. CONCLUSION, SUBSEQUENT AND FUTURE WORK
We design ObliVM, a programming framework for auto-
mated secure computation. Additional examples can be found
at our project website http://www.oblivm.com, including pop-
ular streaming algorithms, graph algorithms, data structures,
machine learning algorithms, secure genome analysis [56], etc.
A. Subsequent Works and Adoption of ObliVM
To the best of our knowledge, our framework is al-
ready being adopted in other projects. First, the GraphSC
work [24] extends our ObliVM-GC framework to support
parallel execution of gadgets on modern architectures with
inherent parallelism, such as multi-core processor architec-
tures, and compute clusters. Because of ObliVM-GC’s clean
architecture, it was not too much work for GraphSC’s par-
allel extension, which required about 1200 more lines of
code on top of ObliVM-GC. Second, our collaborators (and
a subset of the authors of this paper) are implementing a
MIPS processor over our ObliVM framework. Such a MIPS
processor will allow maximum backward compatibility: code
written in any language can be compiled to a MIPS processor
using a stock compiler, and then evaluated securely. Third,
a group of networking researchers have used our ObliVM-
GC framework to develop privacy-preserving software-deﬁned
networking applications [57]. Fourth, we used our ObliVM
framework to participate in the iDash Secure Genome Analysis
Competition [56], [58]. Finally, Wagner et al. also use our
ObliVM framework to develop privacy-preserving applications