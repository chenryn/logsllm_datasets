Swapping the two operands of ⊛ with rule (1), we get
⟨x1 = x2 ∧ τ1 = x1⟩ τ2 = 0; τ2 = τ2 + x2; skip; ⊛ skip; ⟨τ1 = τ2⟩
After applying rule (4), we get
{x1 = x2 ∧ τ1 = x1} τ2 = 0; τ2 = τ2 + x2; skip; {τ1 = τ2}
Applying Hoare-style strongest postcondition computation, the
above Hoare triple can be reduced to
{x1 = x2 ∧ τ1 = x1 ∧ τ2 = x2} skip; {τ1 = τ2}
Since this Hoare triple is clearly valid, we have proven non-interference
using the QCHL proof rules.
□
Rule (5) specifies the general verification logic for branch state-
ments. This rule is an analog of the conditional rule in standard
Hoare logic: we can verify an if statement by embedding the branch
condition e into the true branch and its negation ¬e into the false
branch and carry out the proof for both branches accordingly.
Rule (6) specifies the general verification logic for loops. Without
loss of generality, this rule requires both sides of the ⊛ operator
to be loops: If one side is a not a loop, we can always apply one
of the other rules, using rule (1) to swap the loop to the other side
if necessary. The idea here is to apply self-composition [14]: we
run the loop on the left-hand side first, followed by the loop on the
right-hand side, and try to derive the proof as if the two loops are
sequentially composed.
While rule (6) is sound, it is typically difficult to prove 2-safety
using rule (6) alone. In particular, rule (6) does not allow us to syn-
chronize executions between the two loops, so the resulting Hoare
triples are often hard to verify. The following example illustrates
this issue:
Example. Consider the following code snippet:
e1 = α(e)
e2 = α(e)
e1 ≡α e2
S1 = α(S)
S2 = α(S)
S1 ≡α S2
e1 ≡α e2
S1 ≡α S2
Σ ⊢ e1 : low
Σ ⊢ e2 : low
Σ ⊢ CanSynchronize(e1, e2, S1, S2, I)
|= I → (e1 ↔ e2)
Σ ⊢ CanSynchronize(e1, e2, S1, S2, I)
Figure 6: Helper rules for figure 5
λ ( low n , low k).
i = 0;
while (i  0) consume(1); else consume(100);
}
bar() {
int y = readSecret();
if(y <= 0) consume(1); else consume(100);
}
While this program does not have any secret-dependent imbal-
ance in resource usage, foo and bar individually do not obey non-
interference, causing our analysis to report false positives. However,
in practice, we have not observed any such false positives, and this
strategy greatly increases the scalability of the tool.
Resource usage instrumentation. The language we considered
for our formalization in Section 4 is equipped with a consume(x)
statement that models consumption of x units of resource. Unfortu-
nately, since Java programs do not come with such statements, our
implementation uses a cost model to instrument the program with
such consume statements. In principle, our framework can detect
different classes of side channels, provided that the tool is given a
suitable cost model for the corresponding resource type.
Our current implementation provides cost models for two kinds
of resource usage, namely, timing and response size. For timing,
we use a coarse cost model where every byte code instruction is
assumed to have unit cost. For response size, each string s that is
appended to the response consumes s.lenдth() units of resource.
Counterexample generation. If Themis fails to verify the bounded
non-interference property for a given ϵ, it can also generate coun-
terexamples by using the models provided by the underlying SMT
solver. In particular, when the verification condition (VC) generated
by Themis is invalid, the tool asks the SMT solver for a falsifying
assignment and pretty-prints the model returned from Z3 by replac-
ing Z3 symbols with their corresponding variable names. Since the
VCs depend on automatically inferred loop invariants, the coun-
terexamples generated by Themis may be spurious if the inference
engine does not infer sufficiently strong loop invariants.
5.2 System Implementation
The Themis system is implemented in a combination of Java and
OCaml and leverages multiple existing tools, such as Soot [67],
Z3 [24], and Apron [44]. Specifically, our pointer analysis builds
on top of Soot [67], and we extend the taint analysis provided by
FlowDroid [9], which is a state-of-the-art context-, field-, flow-,
and object-sensitive taint analyzer, to also track implicit flows. Our
QCHL verifier is implemented in OCaml and uses the Z3 SMT
solver [24] to discharge the generated verification conditions. To
prove the Hoare triples that arise as premises in the QCHL proof
rules, we perform standard weakest precondition computation,
leveraging the Apron numerical abstract domain library [44] to
infer standard loop invariants. Recall that we infer relational loop
invariants using the monomial predicate abstraction technique
described in Section 4.3.
Our formal description of QCHL in section 4 uses a simplified
programming language that does not have many of the complexities
of Java. Themis handles these complexities by first leveraging the
Soot framework to parse the Java bytecode to Soot IR, and then
using an in-house “front-end” that further lowers Soot IR into a
form closer to what is presented in section 4. In particular, the
transformation from Soot to our IR recovers program structures
(loops, conditionals etc.) and encodes heap accesses in terms of
arrays. The verifier performs strongest postcondition calculation
over our internal IR and encodes verification conditions with SMT
formulae. In the remainder of this section, we explain how we
handle various challenges that we encountered while building the
Themis frontend.
Object encoding. Since objects are pervasive in Java applications,
their encoding has a significant impact on the precision and scala-
bility of the approach. In Themis, we adopt a heap encoding that
is similar to ESC-Java [28]. Specifically, instance fields of objects
are represented as maps from object references (modeled as inte-
ger variables) to the value of the corresponding field. Reads and
writes to the map are modeled using select and update functions
defined by the theory of arrays in SMT solvers. If two object refer-
ences are known not to be the same (according to the results of the
Session D3:  Logical Side ChannelsCCS’17, October 30-November 3, 2017, Dallas, TX, USA882pointer analysis), we then add a disequality constraint between the