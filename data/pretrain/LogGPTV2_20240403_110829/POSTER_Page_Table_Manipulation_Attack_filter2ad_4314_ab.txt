Figure 1. First-level descriptor formats of short 
descriptor in AArch32 
The  pseudo  code  for  the  XN  bit  clear  operation  for  the  memory 
located at virtual address 0xED800000 would be as follows: 
. 
/* AArch32 Pseudo code */ 
{ 
unsigned int* a = 0xC0007B60;  
*a = *a & ~(0x10);          /* XN clear */ 
} 
2.1.4  Confirmation of the work 
After  changing  PTE  attribute  of  Master  Kernel  Page  Table, 
invalidating  TLB  and  accessing  modified  region  are  required  to 
make  current  address  space  refer  to  the  modified  Master  Kernel 
Page Table. New process creation can substitute for the procedure 
since  the  newly  created  process  always  refers  to  Master  Kernel 
Page  Table.  To  confirm  the  result  of  the  Kernel  address  space 
modification,  page  table  dump  (PT_DUMP)  feature  providing 
information of kernel space can be used. 
this  reason, 
2.2  PTMA Attack in x86-64 
In x86-64 Linux Kernel, multi-level mapping is applied for kernel 
space.  For 
tables  are 
dynamically allocated except Page Global Directory. So, it is hard 
to  know  the  address  of  the  targeted  PTE  with  address  of  Master 
Kernel Page Table. In this chapter, we introduce an effective way 
to  find  the  targeted  PTE  through  simple  categorization  and 
calculation with information from the booting log of Linux Kernel. 
the  memory  for  page 
2.2.1  Discovering Master Kernel Page Table 
In  various  Linux  distributions,  the  booting  log  is  accessible 
without root permission. The booting log includes the information 
on memory mapping, page size, and physical memory address for 
Master  Kernel  Page  Table.  We  can  obtain  that  information 
through dmesg command. 
In x86-64, size of a page table is 4KB and a page table consists of 
512  64-bit  entries.  Depending  on  page  size,  the  size  of  mapping 
region is different. For example, if the page size is 4KB, the page 
table can map 2MB memory region (4KB x 512 entry). Similarly, 
if  page  size  is  2MB,  a  page  table  can  map  1GB  memory  region. 
We  can  categorize  mapping  info  with  physical  address  and 
mapping size as Figure 2. 
2.2.2  Finding the targeted PTE 
Next  step  is  to  make  a  pair  from  two  types  of  mapping 
information:  Mapping  info  and  Page  Table  allocation.  The 
allocation information of page table includes the physical address 
of  the  page  table.  So,  if  we  can  make  a  pair,  we  can  find  the 
address  of  page  table  for  targeted  region.  For  kernel  memory 
mapping, there are two rules. 
One rule is that the mapping for lower address comes first. Second 
rule is that for the mapping of lower level, the mapping of higher 
level including the lower level should be done first. 
In  Figure  2,  a  region  from  0x00000000  to  0x000fffff  should  be 
mapped  at  first  (Rule  1).  However,  higher  level  mapping 
including the region is not done yet. So, a mapping (①) with 1GB 
page size and the other mapping (②) with 2MB page size will be 
done  in  that  order  (Rule  2).  After  the  higher  level  mapping,  the 
mapping  (③)  for  the  region  from  0x00000000  to  0x001fffff  can 
be  done.  In  this  way,  we  can  make  pairs  from  two  types  of 
mapping information. 
Virtual  addresses  are  linearly  mapped  to  the  physical  memory 
from  the  virtual  address  of  _PAGE_OFFSET  in  x86-64  Linux 
Kernel.  So, physical address  of   the memory  located  at  virtual  
1645 
Figure 2. Mapping info with physical address and mapping size 
address 0xffff880075200000 is 0x75200000. The memory located 
at  physical  address  0x75200000  belongs  in  a  region  from 
0x40000000 to 0x7fffdfff. From the Figure 2, the base address of 
page  table  for  the  region  from  0x40000000  to  0x7fffdfff  is 
0x228c000.  Through  the  calculation,  we  can  know  that  the  PTE 
address of memory located at virtual address 0xffff880075200000 
is 0x0228cd48. 
2.2.3  Modifying attribute of corresponding memory 
The  Figure  3  shows  the  format  of  IA32-e  Page-Directory  Entry 
that  map  to  2-Mbyte  page.  The  highest  bit  63  in  this  format  is 
execute-disable. 
3.  SUMMARY 
PTMA  is  an  effective  technique  for  the  kernel  exploit  since  it 
attacks the principle of the memory  management  mechanism  that 
is  used  for  the  kernel  exploit  defense  in  almost  all  systems. 
According  to  our  test  in  widely  used  architectures  such  as 
AArch32 and x86-64, it is confirmed that any designated memory 
can be accessed without any restriction. This  results  in  unlimited 
possibility  of  kernel  exploit.  For  example,  the  Android  kernel 
rootkit [7] can be realized easily with the help of PTMA even in 
the  hardened  kernel.  With  the  presentation  of  this  critical  attack, 
we hope to inspire and contribute to the development of the more 
secure architecture. 
Figure 3. IA32-e Page-Directory Entry format, which 
divided into 2MB page frames 
We  can  know  the  PTE  address.  So,  it  is  possible  to  rewrite 
memory  attribute  to  alleviate  the  restriction  of  execution.  The 
pseudo code for the XD bit clear operation for the virtual address 
0xffff880075200000 would be as follows: 
. 
/* x86-64 Pseudo code */ 
{ 
unsigned long* a = 0xFFFF880000000000 + 0x228cd48; 
*a = *a & ~(0x8000000000000000);           /* XD clear */ 
} 
After  this  one  bit  clear  operation,  the  memory  located  at  virtual 
address  from  0xffff880075200000 
is 
changed to executable. 
to  0xffff8800753fffff 
2.2.4  Confirmation of the work 
For  making  new  address  space  that  reflects  the  modified  Master 
Kernel  Page  Table,  create  new  process.  We  can  check  kernel 
space  to  confirm  the  result  of  the  kernel  space  modification 
through  page  table  dump  (PT_DUMP).  PT_DUMP  shows  the 
attribute  of  the  kernel  address  space  and  we  can  compare  the 
attributes after clearing bit 63 of PTE. 
After modifying PTE at 0xffff88000228cd48, we have confirmed 
that  the  attribute  of  the  corresponding  memory  at  virtual  address 
0x0xffff880075200000  ~  0x0xffff8800753fffff  is  changed  to 
executable. 
4.  REFERENCES 
[1]  V. P. Kemerlis, M. Polychronakis, and A. D. Keromytis. 
ret2dir: Rethinking kernel isolation. In 23rd USENIX 
Security Symposium (USENIX Security 14), pages 957{972, 
San Diego, CA, Aug. 2014. USENIX Association. 
[2]  P. Sundareson. ARM Linux embedded memory protection 
techniques. http://www.slideshare.net/prabindh/arm-
memory-protection-techniques, 2013. Accessed: 2015-08-09. 
[3]  J. Edge. Extending the use of RO and NX. 
http://lwn.net/Articles/422487/, 2011. Accessed: 2015-08-09. 
[4]  C. Matthieu. x86: Add NX protection for kernel data. 
https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/c
ommit/?id=5bd5a452662bc37c54fb6828db1a3faf87e6511c, 
2010. Accessed: 2015-08-09. 
[5]  R. King. ARM: implement basic NX support for kernel 
lowmem mappings.  http://marc.info/?l=git-commits-
head&m=139053447618651&w=2, 2013. Accessed: 2015-
08-09. 
[6]  C. Team. Exploit writing tutorial part 10: Chaining DEP with 
ROP the Rubik's[tm] cube. 
https://www.corelan.be/index.php/2010/06/16/exploit-
writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-
cube, 2010. Accessed: 2015-08-09. 
[7]  D. You. Android platform based linux kernel rootkit. 
http://www.phrack.com/issues/68/6.html#article, 2011. 
Accessed: 2015-08-09.
1646