那是我们的第一个命令。它告诉处理器将数字 `0x20200000` 保存到寄存器 `r0` 中。在这里我需要去回答两个问题， 寄存器   register 是什么？`0x20200000` 是一个什么样的数字？
寄存器在处理器中就是一个极小的内存块，它是处理器保存正在处理的数字的地方。处理器中有很多寄存器，很多都有专门的用途，我们在后面会一一接触到它们。最重要的有十三个（命名为 `r0`、`r1`、`r2`、…、`r9`、`r10`、`r11`、`r12`），它们被称为通用寄存器，你可以使用它们做任何计算。由于是写我们的第一行代码，我们在示例中使用了 `r0`，当然你可以使用它们中的任何一个。只要后面始终如一就没有问题。
> 
> 树莓派上的一个单独的寄存器能够保存任何介于 `0` 到 `4,294,967,295`（含）之间的任意整数，它可能看起来像一个很大的内存，实际上它仅有 32 个二进制比特。
> 
> 
> 
`0x20200000` 确实是一个数字。只不过它是以十六进制表示的。下面的内容详细解释了十六进制的相关信息：
> 
> 延伸阅读：十六进制解释
> 
> 
> 十六进制是另一种表示数字的方式。你或许只知道十进制的数字表示方法，十进制共有十个数字：`0`、`1`、`2`、`3`、`4`、`5`、`6`、`7`、`8` 和 `9`。十六进制共有十六个数字：`0`、`1`、`2`、`3`、`4`、`5`、`6`、`7`、`8`、`9`、`a`、`b`、`c`、`d`、`e` 和 `f`。
> 
> 
> 你可能还记得十进制是如何用位制来表示的。即最右侧的数字是个位，紧接着的左边一位是十位，再接着的左边一位是百位，依此类推。也就是说，它的值是 100 × 百位的数字，再加上 10 × 十位的数字，再加上 1 × 个位的数字。
> 
> 
> ![567 is 5 hundreds, 6 tens and 7 units.](/data/attachment/album/201901/19/163701yuhkdt0y0h40i1bd.png)
> 
> 
> 从数学的角度来看，我们可以发现规律，最右侧的数字是 10 0 = 1s，紧接着的左边一位是 10 1 = 10s，再接着是 10 2 = 100s，依此类推。我们设定在系统中，0 是最低位，紧接着是 1，依此类推。但如果我们使用一个不同于 10 的数字为幂底会是什么样呢？我们在系统中使用的十六进制就是这样的一个数字。
> 
> 
> ![567 is 5x10^2+6x10^1+7x10^0](/data/attachment/album/201901/19/163630sth1cq0cth0hhhcw.png)
> 
> 
> ![567 = 5x10^2+6x10^1+7x10^0 = 2x16^2+3x16^1+7x16^0](/data/attachment/album/201901/19/163631rmloo5ekbkxm6sez.png)
> 
> 
> 上面的数学等式表明，十进制的数字 567 等于十六进制的数字 237。通常我们需要在系统中明确它们，我们使用下标  10 表示它是十进制数字，用下标  16 表示它是十六进制数字。由于在汇编代码中写上下标的小数字很困难，因此我们使用 0x 来表示它是一个十六进制的数字，因此 0x237 的意思就是 237 16 。
> 
> 
> 那么，后面的 `a`、`b`、`c`、`d`、`e` 和 `f` 又是什么呢？好问题！在十六进制中为了能够写每个数字，我们就需要额外的东西。例如 9 16 = 9×16 0 = 9 10 ，但是 10 16 = 1×16 1 + 1×16 0 = 16 10 。因此，如果我们只使用 0、1、2、3、4、5、6、7、8 和 9，我们就无法写出 10 10 、11 10 、12 10 、13 10 、14 10 、15 10 。因此我们引入了 6 个新的数字，这样 a 16 = 10 10 、b 16 = 11 10 、c 16 = 12 10 、d 16 = 13 10 、e 16 = 14 10 、f 16 = 15 10 。
> 
> 
> 所以，我们就有了另一种写数字的方式。但是我们为什么要这么麻烦呢？好问题！由于计算机总是工作在二进制中，事实证明，十六进制是非常有用的，因为每个十六进制数字正好是四个二进制数字的长度。这种方法还有另外一个好处，那就是许多计算机的数字都是十六进制的整数倍，而不是十进制的整数倍。比如，我在上面的汇编代码中使用的一个数字 20200000 16 。如果我们用十进制来写，它就是一个不太好记住的数字 538968064 10 。
> 
> 
> 我们可以用下面的简单方法将十进制转换成十六进制：
> 
> 
> ![Conversion example](/data/attachment/album/201901/19/163631n31kkbo1owkkzk0g.png)
> 
> 
> 1. 我们以十进制数字 567 为例来说明。
> 2. 将十进制数字 567 除以 16 并计算其余数。例如 567 ÷ 16 = 35 余数为 7。
> 3. 在十六进制中余数就是答案中的最后一位数字，在我们的例子中它是 7。
> 4. 重复第 2 步和第 3 步，直到除法结果的整数部分为 0。例如 35 ÷ 16 = 2 余数为 3，因此 3 就是答案中的下一位。2 ÷ 16 = 0 余数为 2，因此 2 就是答案的接下来一位。
> 5. 一旦除法结果的整数部分为 0 就结束了。答案就是反序的余数，因此 567 10 = 237 16。
> 
> 
> 转换十六进制数字为十进制，也很容易，将数字展开即可，因此 237 16 = 2×16 2 + 3×16 1 +7 ×16 0 = 2×256 + 3×16 + 7×1 = 512 + 48 + 7 = 567。
> 
> 
> 
因此，我们所写的第一个汇编命令是将数字 20200000 16 加载到寄存器 `r0` 中。那个命令看起来似乎没有什么用，但事实并非如此。在计算机中，有大量的内存块和设备。为了能够访问它们，我们给每个内存块和设备指定了一个地址。就像邮政地址或网站地址一样，它用于标识我们想去访问的内存块或设备的位置。计算机中的地址就是一串数字，因此上面的数字 20200000 16 就是 GPIO 控制器的地址。这个地址是由制造商的设计所决定的，他们也可以使用其它地址（只要不与其它的冲突即可）。我之所以知道这个地址是 GPIO 控制器的地址是因为我看了它的手册，   3  地址的使用没有专门的规范（除了它们都是以十六进制表示的大数以外）。
### 4、启用输出
![A diagram showing key parts of the GPIO controller.](/data/attachment/album/201901/19/163631hqe44v4flov45c34.png)
阅读了手册可以得知，我们需要给 GPIO 控制器发送两个消息。我们必须用它的语言告诉它，如果我们这样做了，它将非常乐意实现我们的意图，去打开 OK 的 LED 指示灯。幸运的是，它是一个非常简单的芯片，为了让它能够理解我们要做什么，只需要给它设定几个数字即可。
```
mov r1,#1
lsl r1,#18
str r1,[r0,#4]
```
> 
> `mov reg,#val` 将数字 `val` 放到名为 `reg` 的寄存器中。
> 
> 
> `lsl reg,#val` 将寄存器 `reg` 中的二进制操作数左移 `val` 位。
> 
> 
> `str reg,[dest,#val]` 将寄存器 `reg` 中的数字保存到地址 `dest + val` 上。
> 
> 
> 
这些命令的作用是在 GPIO 的第 16 号插针上启用输出。首先我们在寄存器 `r1` 中获取一个必需的值，接着将这个值发送到 GPIO 控制器。因此，前两个命令是尝试取值到寄存器 `r1` 中，我们可以像前面一样使用另一个命令 `ldr` 来实现，但 `lsl` 命令对我们后面能够设置任何给定的 GPIO 针比较有用，因此从一个公式中推导出值要比直接写入来好一些。表示 OK 的 LED 灯是直接连线到 GPIO 的第 16 号针脚上的，因此我们需要发送一个命令去启用第 16 号针脚。
寄存器 `r1` 中的值是启用 LED 针所需要的。第一行命令将数字 1 10 放到 `r1` 中。在这个操作中 `mov` 命令要比 `ldr` 命令快很多，因为它不需要与内存交互，而 `ldr` 命令是将需要的值从内存中加载到寄存器中。尽管如此，`mov` 命令仅能用于加载某些值。   4  在 ARM 汇编代码中，基本上每个指令都使用一个三字母代码表示。它们被称为助记词，用于表示操作的用途。`mov` 是 “move” 的简写，而 `ldr` 是 “load register” 的简写。`mov` 是将第二个参数 `#1` 移动到前面的 `r1` 寄存器中。一般情况下，`#` 肯定是表示一个数字，但我们已经看到了不符合这种情况的一个反例。
第二个指令是 `lsl`（逻辑左移）。它的意思是将第一个参数的二进制操作数向左移第二个参数所表示的位数。在这个案例中，将 1 10 （即 1 2 ）向左移 18 位（将它变成 1000000000000000000 2=262144 10 ）。
如果你不熟悉二进制表示法，可以看下面的内容：
> 
> 延伸阅读： 二进制解释
> 
> 
> 与十六进制一样，二进制是写数字的另一种方法。在二进制中只有两个数字，即 `0` 和 `1`。它在计算机中非常有用，因为我们可以用电路来实现它，即电流能够通过电路表示为 `1`，而电流不能通过电路表示为 `0`。这就是计算机能够完成真实工作和做数学运算的原理。尽管二进制只有两个数字，但它却能够表示任何一个数字，只是写起来有点长而已。
> 
> 
> ![567 in decimal = 1000110111 in binary](/data/attachment/album/201901/19/163631ax2zee3z3rye31yo.png)
> 
> 