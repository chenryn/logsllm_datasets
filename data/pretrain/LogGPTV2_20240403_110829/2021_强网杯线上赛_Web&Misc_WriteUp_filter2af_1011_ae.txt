              0 LOAD_FAST                0 (x)
              2 LOAD_DEREF               0 (stream)
              4 LOAD_METHOD              0 (__next__)
              6 CALL_METHOD              0
              8 BINARY_XOR
             10 RETURN_VALUE
    Disassembly of  at 0x7f1199dd4c90, file "main.py", line 44>:
              0 BUILD_MAP                0
              2 LOAD_FAST                0 (.0)
        >>    4 FOR_ITER                 9 (to 24)
              6 STORE_FAST               1 (x)
              8 LOAD_FAST                1 (x)
             10 LOAD_FAST                1 (x)
             12 LOAD_GLOBAL              0 (n)
             14 LOAD_FAST                1 (x)
             16 BINARY_SUBSCR
             18 BINARY_XOR
             20 MAP_ADD                  2
             22 JUMP_ABSOLUTE            2 (to 4)
        >>   24 RETURN_VALUE
    Disassembly of  at 0x7f1199dd5b00, file "main.py", line 45>:
              0 GEN_START                0
              2 LOAD_FAST                0 (.0)
        >>    4 FOR_ITER                 9 (to 24)
              6 STORE_FAST               1 (i)
              8 LOAD_FAST                1 (i)
             10 LOAD_METHOD              0 (bit_count)
             12 CALL_METHOD              0
             14 LOAD_FAST                1 (i)
             16 BUILD_TUPLE              2
             18 YIELD_VALUE
             20 POP_TOP
             22 JUMP_ABSOLUTE            2 (to 4)
        >>   24 LOAD_CONST               0 (None)
             26 RETURN_VALUE
    Disassembly of  at 0x7f1199a42d90, file "main.py", line 47>:
              0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (1)
              4 BINARY_SUBSCR
              6 RETURN_VALUE
人工手动逆向得到对应 python 代码大概如下
（有些地方没有完全按照字节码来写
    import sys
    from hashlib import sha256
    w = b'\xf6\xef\x10H\xa9\x0f\x9f\xb5\x80\xc1xd\xae\xd3\x03\xb2\x84\xc2\xb4\x0e\xc8\xf3  
    m |= {x: x^n[x] for x in n}
    m |= ((i.bit_count(), i) for i in b)
    stream = RC4(list(map(lambda m:m[1], sorted(m.items()))))
    # print welcome banner...
    # print(stream)
    print(xor(w, stream).decode())
    p = sys.stdin.buffer.readline()
    e = xor(e, stream)
    # print(e)
    c = xor(p, stream)
    if sha256(c).digest() != s:  # error
        print(e.decode())
        exit()
    print(xor(t, stream))  # true?
大约可以直到，这个地方通过爆破输入字符的长度，得到`t`的真实数据
可以发现，输入长度为 26 的时候，会提示说 `Congratulations! Now you should now what the flag
is`，这个就是 `t` 的解密结果。而其他情况都不能正确解码。
于是就去找哪里还有这个输入。
然后发现用 pyc 隐写了一部分内容，使用脚本 stegosaurus 导出 pyc 隐写。
> [一文让你完全弄懂Stegosaurus](https://zhuanlan.zhihu.com/p/51226097)
>
> 
需要魔改一下 header，python 3.10 长度是16.
另外输出的话不用转 str，直接 bytes 就好了。
得到长度为 26 的 bytes
    b'\xe5\n2\xd6"\xf0}I\xb0\xcd\xa2\x11\xf0\xb4U\x166\xc5o\xdb\xc9\xead\x04\x15b'
最后将这个作为输入，然后让上述代码的 `c` 打印出来，即为 flag
`flag{P0w5rFu1_0pEn_50urcE}`
###  ISO1995
> We follow ISO1995. ISO1995 has many problems though. One known problem is a
> time.
>
> [附件下载](https://pan.baidu.com/s/1vNY8AzzLVkxbq90h2cW6NQ)
> 提取码（GAME）[备用下载](https://share.weiyun.com/lkcBIbbi)
>
> 压缩包解压密码：fantasicqwb2021
下载下来以 `iso9660` 挂载
    mount -t iso9660 iso1995 /mnt/随便一个目录
发现有一堆名为 `flag_fxxxxx` （xxxx为数字）的文件。
用 ultraISO 把文件导出来，发现每个文件只有一个字符。
另外根据题目提示，查看 hex 发现他每个文件名之前的 `FFFFFFFF` 之后跟着的 2bytes 都不同，怀疑是个序号或者时间之类的。
于是写个脚本提取，转成十进制作为文件名并按照这个顺序把文件内容读取出来。
    import re
    with open('iso1995_trunk_hex', 'r', encoding='utf-8') as fin:
        s = fin.read()
    s = s.strip().replace(' ', '').replace('\n', '')
    print(s)
    # FFFFFFFF027D08020000010000011A0066006C00610067005F006600300031003000310031003B0031003C0041040000000004410100000000000001
    # FFFFFFFF001E08020000010000011A0066006C00610067005F006600300031003000300038003B0031003C003E0400000000043E0100000000000001
    # FFFFFFFF011208020000010000011A0066006C00610067005F006600300030003900340032003B0031003C00FC030000000003FC0100000000000001
    re_num = re.compile(
        r'FFFFFFFF(\w{4})08020000010000011A0066006C00610067005F006600(\w{18})')
    l = re_num.findall(s)
    len(l)
    # 1024
    filename_list = []
    for i in l:
        name = int(i[0], 16)
        # print(name)
        filename_list.append(name)
    decode_str2 = ''
    for i in filename_list:
        filename = f'./iso1995file/flag_f{str(i).rjust(5, "0")}'
        with open(filename, 'r', encoding='utf-8') as f:
            x = f.read()
            print(x)
            decode_str2 += x
    print(decode_str2)
    # !Sdk*t eiW!BJ9$QpR. pIk{V#t:NE;J8M{Qi>W%|1vw5rGyMWX_mY,htG1KLE`pNNMYd?U\SF'Vxo {1)xT_'3FoRIP~O`&!K'ZAKM8G%UT{oN41|4P42S~6*g2KJ}o,8j/]&FimP0V2c::+{#;Bj@Cd\w9ioA&is#g#6!_9SI4Xx6rKoN ZhzD##,4!/bbB(v/Q(6ez{bKoH'-B'*hg5xq$n0xz 0v9wfbGs|[K-ana]D!+*\+`abDa7w16BySRx-#D/-a1O55Q`Fbgn`n;YI9[M't@v%}Iz0fmVl#ls+aI\: 6?|VvGHD~Q0O4{-.siztGve HL7,*oJ&wL*}.7pRx"t1vzM):FL3r@:-C1
    # FLAG{Dir3ct0ry_jYa_n41}
`FLAG{Dir3ct0ry_jYa_n41}`
> 赛后发现这个又是原题。。
>
> [2020 BingoCTF – ISO
> Solution.md](https://webcache.googleusercontent.com/search?q=cache:sleibHV0ffkJ:https://gist.github.com/iidx/70bc719bf5410080801e84406189cd49+&cd=1&hl=zh-> CN&ct=clnk)
###  EzTime
> Forensic.Find a file that a time attribute has been modified by a program.
> （本题flag为非正式形式）
>
> [附件下载](https://pan.baidu.com/s/1tr-n3qcYOomsSeM8fEUYVg)
> 提取码（GAME）[备用下载](https://share.weiyun.com/UhRqdXaX)
>
> 压缩包解压密码：fantasicqwb2021
解压得到 `$LogFile`、`$MFT` (Master File Table)
> [File – $LogFile (2)](https://flatcap.org/linux-> ntfs/ntfs/files/logfile.html)
>
> [NTFS Timestamp changes on Windows
> 10](https://www.forensixchange.com/posts/19_04_22_win10_ntfs_time_rules/)
>
> [Do you MFT? Here’s an MFT Overview.](https://community.rsa.com/t5/rsa-> netwitness-platform-blog/do-you-mft-here-s-an-mft-overview/ba-p/519885)
>
> 
>
> 
最后又找到了个 [NTFS Log Tracker 工具](https://sites.google.com/site/forensicnote/ntfs-log-tracker)
导入之后可以看到相关信息
找了老半天时间参数被修改的文件，最后发现是这个（
可以把时间导出来发现秒以下都是 000000…
提交的 flag 就是
`{45EF6FFC-F0B6-4000-A7C0-8D1549355A8C}.png`
###  问卷题
`flag{Welc0me_tO_qwbS5_Hope_you_play_h4ppily}`
## 小结
好几次比赛都出了内存取证的题目了，这里正好就整理一下吧。
    volatility -f winxp.raw imageinfo                      # 查询镜像基本信息
    volatility -f winxp.raw --profile=WinXPSP3x86 pstree   # 查运行进程进程树
    volatility -f winxp.raw --profile=WinXPSP3x86 pslist   # 查正在运行的进程
    volatility -f winxp.raw --profile=WinXPSP3x86 memdump -p 324 --dump-dir .    # 将PID=324的进程dump出来
    volatility -f winxp.raw --profile=WinXPSP3x86 procdump -p 324 --dump-dir .   # 将PID=324进程导出为exe
    volatility -f winxp.raw --profile=WinXPSP3x86 dlldump -p 324 --dump-dir .    # 将PID=324进程的所有DLL导出
    volatility -f winxp.raw --profile=WinXPSP3x86 getsids -p 324  # 查询指定进程的SID
    volatility -f winxp.raw --profile=WinXPSP3x86 dlllist -p 324  # 查询指定进程加载过的DLL
    volatility -f winxp.raw --profile=WinXPSP3x86 threads -p 324  # 列出当前进程中活跃的线程
    volatility -f winxp.raw --profile=WinXPSP3x86 drivermodule    # 列出目标中驱动加载情况
    volatility -f winxp.raw --profile=WinXPSP3x86 malfind -p 324 -D .   # 检索内存读写执行页
    volatility -f winxp.raw --profile=WinXPSP3x86 iehistory # 检索IE浏览器历史记录
    volatility -f winxp.raw --profile=WinXPSP3x86 joblinks  # 检索计划任务
    volatility -f winxp.raw --profile=WinXPSP3x86 cmdscan   # 只能检索命令行历史
    volatility -f winxp.raw --profile=WinXPSP3x86 consoles  # 抓取控制台下执行的命令以及回显数据
    volatility -f winxp.raw --profile=WinXPSP3x86 cmdline   # 列出所有命令行下运行的程序
    volatility -f winxp.raw --profile=WinXPSP3x86 connscan    # 检索已经建立的网络链接
    volatility -f winxp.raw --profile=WinXPSP3x86 connections # 检索已经建立的网络链接
    volatility -f winxp.raw --profile=WinXPSP3x86 netscan     # 检索所有网络连接情况
    volatility -f winxp.raw --profile=WinXPSP3x86 sockscan    # TrueCrypt摘要TrueCrypt摘要
    volatility -f winxp.raw --profile=WinXPSP3x86 timeliner # 尽可能多的发现目标主机痕迹
    volatility -f winxp.raw --profile=WinXPSP3x86 hivelist                                       # 检索所有注册表蜂巢
    volatility -f winxp.raw --profile=WinXPSP3x86 hivedump -o 0xe144f758                         # 检索SAM注册表键值对
    volatility -f winxp.raw --profile=WinXPSP3x86 dumpregistry -D .                         # 导出注册表
    volatility -f winxp.raw --profile=WinXPSP3x86 printkey -K "SAM\Domains\Account\Users\Names"  # 检索注册表中账号密码
    volatility -f winxp.raw --profile=WinXPSP3x86 hashdump -y system地址 -s SAM地址               # dump目标账号Hash值
    volatility -f winxp.raw --profile=WinXPSP3x86 printkey -K "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"  # 查最后登录的用户
    volatility -f winxp.raw --profile=WinXPSP3x86 userassist                                     # 查询程序运行次数
（参考了 [Volatility 内存数字取证方法](https://www.cnblogs.com/LyShark/p/12484763.html),
thx
* * *
最后，感谢队友带喵喵一起玩 qwq！
顺便，欢迎大师傅们来 [咱博客](https://miaotony.xyz/?from=anquanke) 逛逛喵~
_（溜了溜了喵~_