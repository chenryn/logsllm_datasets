✗
Safe
Minimum
guard
CATT
guard
row
256 KiB 128 MiB ✗
256 KiB 128 MiB ✗
2 MiB ✗
128 KiB
256 KiB 256 KiB ✓
module in two conﬁgurations: default, and aggressive, with sample periods and
thresholds reduced by a factor of 10, and ran profile on the protected system.
We used the source code freely provided by the authors [1], with a modiﬁcation
to disable its use of the precise store event, as this was unavailable on the Haswell
CPUs of our test systems. We consider this change inconsequential to the results
of this evaluation as profile only uses loads to trigger bit ﬂips.
Table 4 shows the results of an 8 MiB run for two memory setups. We see
a roughly 50% dropoﬀ in bit ﬂip counts when ANVIL is in use, while minimal
diﬀerences between the default and aggressive runs. This suggests that bit ﬂips
got through not due to poor detection sensitivity, but rather due to fundamen-
tal issues in identifying which rows are in danger and, consequently, failure in
refreshing them. Indeed, the ratio between prevented/unprevented bit ﬂips is
consistent with the increases in Rowhammer eﬀectiveness due to new insights
into memory addressing, as previously shown in Fig. 3. We propose enhancing
ANVIL with detailed models of memory addressing in order to better identify
potential Rowhammer targets and be able to accurately refresh them.
Second, we examine CATT [8], which attempts to mitigate the damage of
Rowhammer attacks crossing the kernel-userspace boundary by partitioning
the physical address space in two contiguous regions, one for kernel, one for
userspace, with a “buﬀer” or “guard” row in between. CATT computes the size
of this guard row by accounting for the number of banks, ranks, DIMMs, and
channels of memory in use, multiplying the standard DRAM row size (8 KiB)
by each of these in turn. This is a ﬁne approach, assuming a linear and mono-
tonic mapping between physical and DRAM address spaces. However, as we have
shown before in Fig. 1 this assumption can be false.
Table 5 presents the results for four representative memory conﬁgurations,
showcasing all combinations of the rank mirroring and on-DIMM remapping
features. For every setup we mark as unsafe we have repeatedly and consistently
found bit ﬂips that are far enough away in physical address space from both of
their aggressor rows to “jump over” the guard area and thus defeat the linear
protection guarantees of CATT. In the “Minimum guard” column, we provide
the minimum size a CATT-like contiguous guard zone separating two physical
address areas needs to be in order to fully protect them against hammering each
other. In cases where this minimum contiguous guard distance is inconveniently
Defeating Software Mitigations Against Rowhammer
63
large, a non-wasteful isolation-based defense must support accurate memory
addressing and non-contiguous guard buﬀers.
Attack Simulator
To demonstrate Hammertime’s simulator, we implemented several published
Rowhammer attacks as exploit models: Page Table Entry Exploits rely on
ﬂipping bits in memory used to hold page tables. Previous work [20] has sug-
gested exploiting ﬂips in the page frame pointer bits of a PTE. Other potentially
useful attacks are setting the U/S bit of a PTE, allowing userspace access to a
kernel page, and clearing of the NX bit, marking memory as executable. Dedup
Est Machina [7] which exploits 1 → 0 ﬂips in bits 0 − 10 and 52 − 63 of
64-bit words in a page. The entire code is presented in Listing 1.1. Flip Feng
Shui [19] relies on triggering bit ﬂips at speciﬁc page oﬀsets in order to corrupt
the contents of sensitive ﬁles in the page cache.
We evaluated each model with
all double-sided ﬂip tables pre-
sented in Sect. 5.1. The results are
presented in Table 6. The “Min
Mem” column represents the mini-
mum amount of physically contigu-
ous memory required (on average)
to ﬁnd one single useful bit ﬂip.
The “Time” column is an estimate
of the mean time to the ﬁrst bit
ﬂip, assuming precise targeting and
200ms spent on each Rowhammer
test.
Pagetable
PFN
Pagetable
U/S bit
Pagetable
NX bit
Dedup Est
Machina
Table 6. Results of attack simulation
Attack
Run
ID Success
Rate
Min
Mem
[KiB]
Time
[s]
F1
Best
Median G1
Worst B1
A2
Best
Median J1
Worst B1
F1
Best
Median E2
Worst A2
A4
Best
Median E2
Worst A2
F1
Median C1
Worst B1
F1
Best
Median C1
Worst B1
23.0%
40
0.7% 1152
16
68.8%
5.3%
152
0.3% 2456
3.5%
232
0.3% 2376
0.3
3.8
61.3
5.6
59.3
0% N/A N/A
0.9
28.6
0% N/A N/A
0.2
1.5
1625
8.8
233.1
0% N/A N/A
0.9
21.9
406.4
16
98.4%
13.1%
64
<0.1% 65024
2.3%
360
0.1% 9328
FFS GPG Best
FFS
sources.list
We see that an attack’s suc-
cess rate depends not only on how
vulnerable memory is, but also on
the speciﬁc bit ﬂips pursued. Data
dependency is one issue: as evi-
denced in Table 2, memory can have
a preference for ﬂipping in one direction more than the other. An exploit such
as the Page Table U/S bit attack, which relies on 0 → 1 bit ﬂips can achieve
relatively poor success rates on otherwise very vulnerable (albeit in the oppo-
site direction) RAM. The second issue is the “rarity” of the required bit ﬂips
for each attack in terms of bit oﬀsets in a given memory page. Attacks such as
Page Table PFN or Dedup Est Machina, which make use of ﬂips located at one
of potentially many page oﬀsets show signiﬁcantly better results than attacks
which require ﬂips in very precise positions, such as Flip Feng Shui.
40
880
<0.1% 16256
23.0%
0.9%
64
A. Tatar et al.
6 Related Work
To our knowledge, there are no studies systematically applying accurate memory
addressing models to implement either Rowhammer attacks or defenses. Like-
wise, there are no studies looking into address manipulation beyond the memory
controller in the context of exploiting Rowhammer.
The ﬁrst to describe the Rowhammer bug in widespread commodity hardware
were Kim et al. [13] in their study on the prevalence of bit ﬂips on DDR3. Coming
from the hardware community, the researchers probed the DIMMs directly with
an FPGA. Besides identifying the phenomenon, the authors discovered that the
root cause of the problem was the repeated toggling of the DRAM row buﬀer.
They also found that many bits are susceptible to ﬂips and that ﬂipping bits
requires modest amounts of memory accesses (in their experiments fewer than
150K).
While the authors identiﬁed the hardware bug as a potential security prob-
lem, it was unclear whether it could be exploited in practice. One year later,
Seaborn presented the ﬁrst two concrete Rowhammer exploits, in the form of
escaping the Google Native Client (NaCl) sandbox and escalating local privileges
on Linux [20]. In addition, Seaborn discovered that the bit ﬂip rate increased
signiﬁcantly with double-sided Rowhammer. The exploits relied on Intel x86’s
CLFLUSH instruction to evict a cache line from the CPU caches in order to read
directly from DRAM. CLFLUSH was quickly disabled in NaCl, while Linux mit-
igated the local privilege exploit by disabling unprivileged access to virtual-
to-physical memory mapping information (i.e., /proc/self/pagemap) used in
the exploit to perform double-sided Rowhammer. Soon after, however, Gruss
et al. [9] showed that it is possible to perform double-sided Rowhammer from
the browser, without CLFLUSH, and without pagemap—using cache eviction sets
and transparent huge pages (THP) [4]. They also found that hammering a pair
of neighboring rows, increases the number of ﬂips in the rows adjacent to the
pair. In addition, Qiao et al. [18] showed how Rowhammer can be triggered
using non-temporal memory instructions in lieu of cache ﬂushing. Bosman et
al. showed that it is possible to ﬂip bits from JavaScript in a controlled fashion
using probabilistic double-sided Rowhammer without the need for huge pages [6].
Meanwhile, Xiao et al. [22] presented a second cross-VM attack that built on the
original Seaborn attack while improving on our knowledge of DRAM geometry.
Research so far predominantly targeted DDR3 RAM and x86 processors.
Aichinger [3] then analyzed the prevalence of the Rowhammer bug on server
systems with ECC memory and Lanteigne performed an analysis on DDR4 mem-
ory [14]. Despite initial doubt among researchers whether the memory controller
would be suﬃciently fast to trigger the Rowhammer eﬀect, Van der Veen et
al. [21] demonstrated that ARM-based mobile devices are equally susceptible
to the Rowhammer problem. New attack techniques focus on the DRAM itself.
For instance, Lanteigne [14,15] examined how data and access patterns inﬂu-
enced on bit ﬂip probabilities on DDR3 and DDR4 memory on Intel and AMD
CPUs. Meanwhile, Pessl et al [17] demonstrated that reverse engineering the
Defeating Software Mitigations Against Rowhammer
65
bank DRAM addressing can reduce the search time for Rowhammer bit ﬂips.
These techniques are complementary to our work.
7 Conclusion
Rowhammer is constantly on the news and increasingly sophisticated Rowham-
mer attacks surface both in industry and academia. In response, defenses have
quickly been developed, aiming to either prevent Rowhammer from occurring or
mitigating the security impact of bit ﬂips. Both attacks and defenses however
make simplifying assumptions about memory layout and addressing which limits
their generality, reproducibility and eﬀectiveness.
To ﬁll this gap, we took a closer look at precisely how an accurate memory
addressing model impacts Rowhammer. Our analysis shows that software’s abil-
ity to trigger, as well as protect against, Rowhammer is greatly inﬂuenced by the
addressing schemes used by the memory subsystem. We introduce an end-to-end
model of DRAM addressing, including the previously unexplored techniques of
rank mirroring and on-DIMM remapping. We show that by using such an address
model to select Rowhammer targets, attackers can trigger signiﬁcantly more bit
ﬂips than previously assumed and even trigger bit ﬂips on DIMMs where the
state of the art fails, amplifying the relevance of existing attacks. We also show
that existing defenses do not properly account for memory addressing can be
bypassed by suﬃciently informed attackers.
To support our work, we introduced Hammertime, a software suite for
Rowhammer studies. Hammertime allows researchers to proﬁle a large set of
DIMMs for bit ﬂips and later use the resulting data to simulate the Rowhammer
defect in software. More importantly, Hammertime makes Rowhammer research
much faster, more comparable, and more reproducible. For example, Hammer-
time’s simulator allows researchers to quickly prototype a new Rowhammer vec-
tor and evaluate its eﬀectiveness on a given set of existing ﬂip tables. To foster
further Rowhammer research and in support of reproducible and comparable
studies, we are releasing Hammertime as open source.
References
1. ANVIL source code (2016). https://github.com/zaweke/rowhammer/tree/master/
anvil. Accessed 03 Apr 2018
2. Advanced Micro Devices: BIOS and Kernel Developers Guide (BKDG) for AMD
Family 15h Models 60h–6Fh Processors, May 2016
3. Aichinger, B.: DDR memory errors caused by row hammer. In: HPEC 2015 (2015)
4. Arcangeli, A.: Transparent hugepage support. In: KVM Forum (2010)
5. Aweke, Z.B., et al.: ANVIL: software-based protection against next-generation
rowhammer attacks. In: ASPLOS 2016 (2016)
6. Bosman, E., Razavi, K., Bos, H., Giuﬀrida, C.: Over the edge: silently owning
Windows 10’s secure browser. In: BHEU 2016 (2016)
7. Bosman, E., Razavi, K., Bos, H., Giuﬀrida, C.: Dedup Est machina: memory dedu-
plication as an advanced exploitation vector. In: SP 2016 (2016)
66
A. Tatar et al.
8. Brasser, F., Davi, L., Gens, D., Liebchen, C., Sadeghi, A.R.: Can’t touch this:
software-only mitigation against rowhammer attacks targeting kernel memory. In:
26th USENIX Security Symposium (USENIX Security 2017), Vancouver, BC,
pp. 117–130. USENIX Association (2017). https://www.usenix.org/conference/
usenixsecurity17/technical-sessions/presentation/brasser
9. Gruss, D., Maurice, C., Mangard, S.: Rowhammer.js: a remote software-induced
fault attack in JavaScript. In: Caballero, J., Zurutuza, U., Rodr´ıguez, R.J. (eds.)
DIMVA 2016. LNCS, vol. 9721, pp. 300–321. Springer, Cham (2016). https://doi.
org/10.1007/978-3-319-40667-1 15
10. JEDEC: DDR3 SDRAM STANDARD. JESD79-3C, November 2008
11. Kasamsetty, K.: DRAM scaling challenges and solutions in LPDDR4 context. In:
MemCon 2014 (2014)
12. Khan, S., Wilkerson, C., Wang, Z., Alameldeen, A.R., Lee, D., Mutlu, O.: Detect-
ing and mitigating data-dependent DRAM failures by exploiting current memory
content. In: MICRO 2017 (2017)
13. Kim, Y., et al.: Flipping bits in memory without accessing them: an experimental
study of DRAM disturbance errors. In: ISCA 2014 (2014)
14. Lanteigne, M.: A Tale of Two Hammers: A Brief Rowhammer Analysis of AMD
vs. Intel, May 2016. http://www.thirdio.com/rowhammera1.pdf
15. Lanteigne, M.: How Rowhammer Could Be Used to Exploit Weaknesses in Com-
puter Hardware. SEMICON China (2016)
16. Meza, J., Wu, Q., Kumar, S., Mutlu, O.: Revisiting memory errors in large-scale
production data centers: analysis and modeling of new trends from the ﬁeld. In:
DSN 2015 (2015)
17. Pessl, P., Gruss, D., Maurice, C., Schwarz, M., Mangard, S.: DRAMA: exploiting
DRAM addressing for cross-CPU attacks. In: SEC 2016 (2016)
18. Qiao, R., Seaborn, M.: A new approach for rowhammer attacks. In: 2016 IEEE
International Symposium on Hardware Oriented Security and Trust (HOST), pp.
161–166, May 2016. https://doi.org/10.1109/HST.2016.7495576
19. Razavi, K., Gras, B., Bosman, E., Preneel, B., Giuﬀrida, C., Bos, H.: Flip Feng
Shui: hammering a needle in the software stack. In: SEC 2016 (2016)
20. Seaborn, M.: Exploiting the DRAM rowhammer bug to gain kernel privileges. In:
BH 2015 (2015)
21. van der Veen, V., et al.: Drammer: deterministic rowhammer attacks on mobile
platforms. In: CCS 2016 (2016)
22. Xiao, Y., Zhang, X., Zhang, Y., Teodorescu, M.R.: One bit ﬂips, one cloud ﬂops:
cross-VM row hammer attacks and privilege escalation. In: SEC 2016 (2016)