> **练习 6**、实现 `fs/serv.c` 中的 `serve_write` 和 `lib/file.c` 中的 `devfile_write`。
> 
> 
> 使用 `make grade` 去测试你的代码。你的代码通过 file\_write、fileread after filewrite、open、和 large file 的测试后，得分应该是 90（总分为150）。
> 
> 
> 
### 进程增殖
我们给你提供了 `spawn` 的代码（查看 `lib/spawn.c` 文件），它用于创建一个新环境、从文件系统中加载一个程序镜像并启动子环境来运行这个程序。然后这个父进程独立于子环境持续运行。`spawn` 函数的行为，在效果上类似于UNIX 中的 `fork`，然后同时紧跟着 `fork` 之后在子进程中立即启动执行一个 `exec`。
我们实现的是 `spawn`，而不是一个类 UNIX 的 `exec`，因为 `spawn` 是很容易从用户空间中、以”外内核式“ 实现的，它无需来自内核的特别帮助。为了在用户空间中实现 `exec`，想一想你应该做什么？确保你理解了它为什么很难。
> 
> **练习 7**、`spawn` 依赖新的系统调用 `sys_env_set_trapframe` 去初始化新创建的环境的状态。实现 `kern/syscall.c` 中的 `sys_env_set_trapframe`。（不要忘记在 `syscall()` 中派发新系统调用）
> 
> 
> 运行来自 `kern/init.c` 中的 `user/spawnhello` 程序来测试你的代码`kern/init.c` ，它将尝试从文件系统中增殖 `/hello`。
> 
> 
> 使用 `make grade` 去测试你的代码。
> 
> 
> 
.
> 
> **小挑战！**实现 Unix 式的 `exec`。
> 
> 
> 
.
> 
> **小挑战！**实现 `mmap` 式的文件内存映射，并如果可能的话，修改 `spawn` 从 ELF 中直接映射页。
> 
> 
> 
### 跨 fork 和 spawn 共享库状态
UNIX 文件描述符是一个通称的概念，它还包括管道、控制台 I/O 等等。在 JOS 中，每个这类设备都有一个相应的 `struct Dev`，使用指针去指向到实现读取/写入/等等的函数上。对于那个设备类型，`lib/fd.c` 在其上实现了类 UNIX 的文件描述符接口。每个 `struct Fd` 表示它的设备类型，并且大多数 `lib/fd.c` 中的函数只是简单地派发操作到 `struct Dev` 中相应函数上。
`lib/fd.c` 也在每个应用程序环境的地址空间中维护一个文件描述符表区域，开始位置在 `FDTABLE` 处。这个区域为应该程序能够一次最多打开 `MAXFD`（当前为 32）个文件描述符而保留页的地址空间值（4KB）。在任意给定的时刻，当且仅当相应的文件描述符处于使用中时，一个特定的文件描述符表才会被映射。在区域的 `FILEDATA` 处开始的位置，每个文件描述符表也有一个可选的”数据页“，如果它们被选定，相应的设备就能使用它。
我们想跨 `fork` 和 `spawn` 共享文件描述符状态，但是文件描述符状态是保存在用户空间的内存中。而现在，在 `fork` 中，内存是标记为写时复制的，因此状态将被复制而不是共享。（这意味着环境不能在它们自己无法打开的文件中去搜索，并且管道不能跨一个 `fork` 去工作）在 `spawn` 上，内存将被保留，压根不会去复制。（事实上，增殖的环境从使用一个不打开的文件描述符去开始。）
我们将要修改 `fork`，以让它知道某些被”库管理的系统“所使用的、和总是被共享的内存区域。而不是去”硬编码“一个某些区域的列表，我们将在页表条目中设置一个”这些不使用“的位（就像我们在 `fork` 中使用的 `PTE_COW` 位一样）。
我们在 `inc/lib.h` 中定义了一个新的 `PTE_SHARE` 位，在 Intel 和 AMD 的手册中，这个位是被标记为”软件可使用的“的三个 PTE 位之一。我们将创建一个约定，如果一个页表条目中这个位被设置，那么在 `fork` 和 `spawn` 中应该直接从父环境中复制 PTE 到子环境中。注意它与标记为写时复制的差别：正如在第一段中所描述的，我们希望确保能共享页更新。
> 
> **练习 8**、修改 `lib/fork.c` 中的 `duppage`，以遵循最新约定。如果页表条目设置了 `PTE_SHARE` 位，仅直接复制映射。（你应该去使用 `PTE_SYSCALL`，而不是 `0xfff`，去从页表条目中掩掉有关的位。`0xfff` 仅选出可访问的位和脏位。）
> 
> 
> 同样的，在 `lib/spawn.c` 中实现 `copy_shared_pages`。它应该循环遍历当前进程中所有的页表条目（就像 `fork` 那样），复制任何设置了 `PTE_SHARE` 位的页映射到子进程中。
> 
> 
> 
使用 `make run-testpteshare` 去检查你的代码行为是否正确。正确的情况下，你应该会看到像 `fork handles PTE_SHARE right` 和 ”`spawn handles PTE_SHARE right`” 这样的输出行。
使用 `make run-testfdsharing` 去检查文件描述符是否正确共享。正确的情况下，你应该会看到 `read in child succeeded` 和 “`read in parent succeeded`” 这样的输出行。
### 键盘接口
为了能让 shell 工作，我们需要一些方式去输入。QEMU 可以显示输出，我们将它的输出写入到 CGA 显示器上和串行端口上，但到目前为止，我们仅能够在内核监视器中接收输入。在 QEMU 中，我们从图形化窗口中的输入作为从键盘到 JOS 的输入，虽然键入到控制台的输入作为出现在串行端口上的字符的方式显现。在 `kern/console.c` 中已经包含了由我们自实验 1 以来的内核监视器所使用的键盘和串行端口的驱动程序，但现在你需要去把这些增加到系统中。
> 
> **练习 9**、在你的 `kern/trap.c` 中，调用 `kbd_intr` 去处理捕获 `IRQ_OFFSET+IRQ_KBD` 和 `serial_intr`，用它们去处理捕获 `IRQ_OFFSET+IRQ_SERIAL`。
> 
> 
> 
在 `lib/console.c` 中，我们为你实现了文件的控制台输入/输出。`kbd_intr` 和 `serial_intr` 将使用从最新读取到的输入来填充缓冲区，而控制台文件类型去排空缓冲区（默认情况下，控制台文件类型为 stdin/stdout，除非用户重定向它们）。
运行 `make run-testkbd` 并输入几行来测试你的代码。在你输入完成之后，系统将回显你输入的行。如果控制台和窗口都可以使用的话，尝试在它们上面都做一下测试。
### Shell
运行 `make run-icode` 或 `make run-icode-nox` 将运行你的内核并启动 `user/icode`。`icode` 又运行 `init`，它将设置控制台作为文件描述符 0 和 1（即：标准输入 stdin 和标准输出 stdout），然后增殖出环境 `sh`，就是 shell。之后你应该能够运行如下的命令了：
```
echo hello world | cat
cat lorem |cat
cat lorem |num
cat lorem |num |num |num |num |num
lsfd
```
注意用户库常规程序 `cprintf` 将直接输出到控制台，而不会使用文件描述符代码。这对调试非常有用，但是对管道连接其它程序却很不利。为将输出打印到特定的文件描述符（比如 1，它是标准输出 stdout），需要使用 `fprintf(1, "...", ...)`。`printf("...", ...)` 是将输出打印到文件描述符 1（标准输出 stdout） 的快捷方式。查看 `user/lsfd.c` 了解更多示例。
> 
> **练习 10**、这个 shell 不支持 I/O 重定向。如果能够运行 `run sh  
> 
> 通过在你的 shell 中输入 `sh  
> 
> 运行 `make run-testshell` 去测试你的 shell。`testshell` 只是简单地给 shell ”喂“上面的命令（也可以在 `fs/testshell.sh` 中找到），然后检查它的输出是否与 `fs/testshell.key` 一样。
> 
> 
> 
.
> 
> **小挑战！**给你的 shell 添加更多的特性。最好包括以下的特性（其中一些可能会要求修改文件系统）：
> 
> 
> * 后台命令 (`ls &`)
> * 一行中运行多个命令 (`ls; echo hi`)
> * 命令组 (`(ls; echo hi) | cat > out`)
> * 扩展环境变量 (`echo $hello`)
> * 引号 (`echo "a | b"`)
> * 命令行历史和/或编辑功能
> * tab 命令补全
> * 为命令行查找目录、cd 和路径
> * 文件创建
> * 用快捷键 `ctl-c` 去杀死一个运行中的环境
> 
> 
> 可做的事情还有很多，并不仅限于以上列表。
> 
> 
> 
到目前为止，你的代码应该要通过所有的测试。和以前一样，你可以使用 `make grade` 去评级你的提交，并且使用 `make handin` 上交你的实验。
**本实验到此结束。** 和以前一样，不要忘了运行 `make grade` 去做评级测试，并将你的练习答案和挑战问题的解决方案写下来。在动手实验之前，使用 `git status` 和 `git diff` 去检查你的变更，并不要忘记使用 `git add answers-lab5.txt` 去提交你的答案。完成之后，使用 `git commit -am 'my solutions to lab 5’` 去提交你的变更，然后使用 `make handin` 去提交你的解决方案。
---
via: 
作者：[csail.mit](https://pdos.csail.mit.edu) 选题：[lujun9972](https://github.com/lujun9972) 译者：[qhwdw](https://github.com/qhwdw) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出