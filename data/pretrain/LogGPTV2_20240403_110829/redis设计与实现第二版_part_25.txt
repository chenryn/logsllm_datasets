所以多个文件事
，因为一个服务器
队列
套接字s3
图 12-1 
接字
套接字s2
文件事件处理器的四个组成部分
，并根据套接字产生的事件的类
1O多路复用程序
传送
文件事件分派器
连接应答处理器
命令回复处理器
命令请求处理器
事件处理器
---
## Page 157
事件类型：
间的关联。
数，让 I/0 多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之
并对事件和事件处理器进行关联。
READABLE 事件，等到 AE_READABLE 事件处理完之后，才处理 AE_WRITABLE 事件。
12.1.4 API
事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_
WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：
12.1.3
底层实现：
编译时自动选择系统中性能最高的 I/O 多路复用函数库来作为 Redis 的 I/O 多路复用程序的
ae.c/aeGetFileEvents 函数接受一个套接字描述符，返回该套接字正在被监听的
ae.c/aeDeleteFileEvent函数接受一个套接字描述符和一个监听事件类型作为参
ae.c/aeCreateFileEvent 函数接受一个套接字描述符、一个事件类型，以及一个
这也就是说，如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。
当套接字变得可写时（客户端对套接字执行 read操作），套接字产生AE_
 当套接字变得可读时（客户端对套接字执行 write 操作，或者执行 close 操作),
I/O 多路复用程序可以监听多个套接字的 ae.h/AE_READABLE 事件和 ae.h/AE_
# endif
/* Include the best multiplexing layer supported by this system.
WRITABLE 事件。
include "ae_evport.c"
ifdef HAVE_EVPORT
兼
connect 操作），套接字产生 AE_READABLE 事件。
或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行
else
事件的类型
#endif
#ifdef HAVE_EPOLL
#endif
# ifdef HAVE_KQUEUE
include "ae_select.c"
else
include "ae_kqueue.c"
图12-3Redis的IVO多路复用程序有多个IVO
= t= = = = = = = =  t == = 
select
多路复用库实现可选
epoll
I/O多路复用程序
底层实现
第 12章事 
= = == = = = == == = = = 
kqueue
件+153
---
## Page 158
154·第二部分单机数据库的实现
务器监听套接字的时候，套接字就会产生 AE_READABLE 事件，引发连接应答处理器执行，
的 AE_READABLE事件关联起来，当有客户端用 sys/socket.h/connect 函数连接服
数的包装。
用于对连接服务器监听套接字的客户端进行应答，具体实现为 sys/socket.h/accept 函
令请求处理器和命令回复处理器。
求，比如说：
12.1.5
函数库，
的名称：返回"epoll”表示底层为epoll函数库，返回“select"表示底层为 select
待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。
产生文件事件，当有至少一个事件产生，或者等待超时后，函数返回。
在指定的时间内，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字
函数返回。
定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，
当 Redis 服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字
ae.c/aeGetApiName 函数返回 I/O 多路复用程序底层所使用的 I/O 多路复用函数库
ae.c/aeApiPoll函数接受一个 sys/time.h/structtimeval 结构为参数，并
 networking.c/acceptTcpHandler 函数是Redis 的连接应答处理器，这个处理器
1. 连接应答处理器 
在这些事件处理器里面，服务器最常用的要数与客户端进行通信的连接应答处理器、命
Redis 为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需
ae．.c/aeProcessEvents 函数是文件事件分派器，它先调用 aeApiPoll 函数来等
口当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编
口为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。
口为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。
口为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处
ae．c/aeWait 函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，在给
写的复制处理器。
口如果套接字的写事件正在被监听，那么函数返回 AEWRITABLE。
口如果套接字的读事件正在被监听，那么函数返回 AE_READABLE。
口如果套接字没有任何事件被监听，那么函数返回AE_NONE。
理器。
WRITABLE。
，诸如此类。
文件事件的处理器
---
## Page 159
READABLE 事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然
应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。
中会产生什么事件，而这些事件又是如何被处理的。
WRITABLE 事件之间的关联。
解除命令回复处理器与客户端套接字的AE_
人操作，如图 12-6 所示。
令回复处理器执行，并执行相应的套接字写
时，就会产生AE_WRITABLE 事件，引发命
WRITABLE事件和命令回复处理器关联起来，
write 函数的包装。
负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h/
事件关联命令请求处理器。
行，并执行相应的套接字读人操作，如图12-5 所示。
READABLE 事件，引发命令请求处理器执
送命令请求的时候，套接字就会产生AE
求处理器关联起来，当客户端向服务器发
套接字的AE_READABLE事件和命令请
功连接到服务器之后，服务器会将客户端
h/read 函数的包装。
送的命令请求内容，具体实现为unistd.
这个处理器负责从套接字中读人客户端发
Client 函数是 Redis 的命令请求处理器，
并执行相应的套接字应答操作，如图12-4 所示。
假设一个 Redis 服务器正在运作，那么这个服务器的监听套接字的 AE_READABLE 事件
如果这时有一个Redis 客户端向服务器发起连接，那么监听套接字将产生 AE_
当命令回复发送完毕之后，服务器就会
让我们来追踪一次 Redis 客户端与服务器进行连接并发送命令的整个过程，看看在过程
当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE
在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的 AE_READABLE
4.一次完整的客户端与服务器连接事件示例
networking.c/sendReplyToClient 函数是 Redis 的命令回复处理器，这个处理器
当一个客户端通过连接应答处理器成
3.命令回复处理器
 networking.c/readQueryFrom
2.命令请求处理器
当客户端准备好接收服务器传回的命令回复
客户端
图12-4
客户端
图12-5
客户端
图12-6
连接监听套接字
发送命令请求
服务器接收客户端发来的命令请求
服务器对客户端的连接请求进行应答
服务器向客户端发送命令回复
发送命令回复
AE_READABLE 事件，
执行连接应答处理器
服务器监听套接字产生
执行命令请求处理器
客户端套接字产生
执行命令回复处理器
客户端套接字产生
第12 章
服务器
服务器
服务器
事
件
155
---
## Page 160
156·第二部分单机数据库的实现
12.2 时间事件
及通信时用到的事件处理器。
理器之间的关联。
户端套接字的 AE_WRITABLE 事件与命令回复处
回复全部写人到套接字之后，服务器就会解除客
命令回复处理器执行，当命令回复处理器将命令
客户端套接字将产生AE_WRITABLE事件，触发
器进行关联。当客户端尝试读取命令回复的时候，
端套接字的AE_WRITABLE事件与命令回复处理
关程序去执行。
READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相
请求处理器进行关联，使得客户端可以向主服务器发送命令请求。
后创建客户端套接字，
之后，假设客户端向主服务器发送一个命令请求，那么客户端套接字将产生AE_
图12-7总结了上面描述的整个通信过程，以
执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户
口如果事件处理器返回 ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达
口timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相
 when：毫秒精度的 UNIX 时间戳，记录了时间事件的到达（arrive）时间。
口id：服务器为时间事件创建的全局唯一ID（标识号）。ID 号按从小到大的顺序递增，
一个时间事件主要由以下三个属性组成：
口 周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔 30 毫秒
口定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间
Redis 的时间事件分为以下两类：
新事件的 ID 号比I旧事件的 ID 号要大。
就执行一次。
的 30 毫秒之后执行一次。
个时间事件进行更新，让这个事件在30毫秒之后再次到达。
行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这
属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运
当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when
如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：
到一次之后就会被删除，之后不再到达。
个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：
应的处理器来处理事件。
客户端
图12-7客户端和服务器的通信过程
、服务器执行命令回复处理器
服务器向客户端发送命令回复
客户端向服务器发送命令请求
服务器执行命令请求处理器
客户端向服务器发送连接请求
服务器执行连接应答处理器
服务器
---
## Page 161
年 12月1日零时前 20毫秒）时调用 aeCreateTimeEvent 函数，服务器将创建ID 为3
间的milliseconds 毫秒之后到达，而事件的处理器为 proc。
处理器 proc 作为参数，将一个新的时间事件添加到服务器，这个新的时间事件将在当前时
12.2.2
达的时间事件都会被处理。
件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到
该链表不按 when 属性的大小排序。正因为链表没有按 when 属性进行排序，所以当时间事
件的ID 为3，中间事件的 ID 为 2，表尾事件的 ID 为 1。
因为新的时间事件总是插人到链表的表头，所以三个时间事件分别按ID 逆序排序，表头事
整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。
12.2.1
执行的性能。
将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件
在 benchmark 模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是
那么当程序以 50毫秒和 handler_3 处理器为参数，在时间1385877599980（2013
例如，如果服务器当前所保存的时间事件如图12-9所示。
ae.c/aeCreateTimeEvent 函数接受一个毫秒数milliseconds 和一个时间事件
图12-8展示了一个保存时间事件的链表的例子，链表中包含了三个不同的时间事件：
服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历
注意，我们说保存时间事件的链表为无序链表，指的不是链表不按ID 排序，而是说，
目前版本的 Redis只使用周期性事件，而没有使用定时事件。
在目前版本中，正常模式下的 Redis 服务器只使用 serverCron 一个时间事件，而
time_events-
API
实现
无序链表并不影响时间事件处理器的性能 
时之后30毫秒）
图12-8用链表连接起来的三个时间事件
time_event
handler_3
timeProc
when
时)
handler_2
timeProc
time_event
when
2
时之后10毫秒）
time_event
handler_1
timeProc
when
第 12 章事 
id
件
·157
---
## Page 162
158·第二部分单机数据库的实现
2和1的时间事件，因为这两个事件的到达时间都大于等于1385877600010。
（2013 年12月1日零时之后10毫秒），那么 processTimeEvents 函数将处理图中ID 为
指的是，时间事件的 when属性记录的UNIX 时间等于或小于当前时间的 UNIX时间戳。
并调用这些事件的处理器。已到达
数会遍历所有已到达的时间事件，
函数是时间事件的执行器，这个函
函数将返回 ID 为 2 的事件。
么调用 aeSearchNearestTimer
保存的时间事件如图12-8所示，那
日零时前 20毫秒)，而服务器当前
1385877599980（2013年12月1
aeDeleteFileEvent（3）之后，服务器保存的时间事件将变成图 12-9 所示的样子。
删除该 ID 所对应的时间事件。
的时间事件，这时服务器所保存的时间事件将如图12-8所示。
举个例子，如果服务器当前保存的时间事件如图12-8所示，那么当程序调用
举个例子，如果服务器保存的时间事件如图12-8所示，并且当前时间为1385877600010
ae.c/processTimeEvents
举个例子，如果当前时间为
ae.c/aeSearchNearestTimer 函数返回到达时间距离当前时间最接近的那个时间事件。
ae.c/aeDeleteFileEvent 函数接受一个时间事件ID 作为参数，然后从服务器中
def processTimeEvents() :
#遍历服务器中的所有时间事件
else:
如果这是一个周期性事件
检查事件是否已经到达 
那么按限事件处理器的返回信更新时间事件的 when 属性
让这个事件在指定的时间之后再次到达
if retval == AE_NOMORE:
如果这是一个定时事件
retval = time_event.timeProc()
delete_time_event_from_server(time_event)
春 那么将该事件从服务器中剔除
time_events-
图12-9用链表连接起来的两个时间事件
零时）
handler_2
time_event
timeProc
when
2
id
时之后10毫秒)
(2013年12月1日零
handler_1