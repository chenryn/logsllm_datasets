•
•
◦
◦
•
•
◦
◦
Key Pinning (Client History)
Key Pinning (Server)
Key Pinning (Preloaded)
Key Pinning (DNS)
Multipath Probing
Channel-bound Credentials
Credential-bound Channels
Key Agility/Manifest
HTTPS-only Pinning (Server)
HTTPS-only Pinning (Preloaded)
HTTPS-only Pinning (DNS)
Visual Cues for Secure POST
Browser-stored CRL
Certiﬁcate Status Stapling
Short-lived Certiﬁcates
List of Active Certiﬁcates
•
•
•
•
•
•
◦
•
•
◦
•
•
•
extension. Instead of focusing on speciﬁc tools, we distill
the main concepts behind each tool into a set of primitives
that can be combined in different ways to address security
issues within the CA/B model.
A summary is provided in Table I. The columns provide a
framework for evaluation. The ﬁrst set of columns, Security
Properties Offered, show a set of properties not met by
the current HTTPS and CA/B model but which selected
primitives (as designated in the rows) provide. Primitives
that offer a certain enhancement typically trade off aspects
of security, privacy, deployability and usability. The next set
of columns are used to evaluate the enhancement according
to Security & Privacy, Deployability, and Usability (cf. [28]).
Combination Logic: It is interesting to consider how
the primitives (rows) of Table I can be combined, to achieve
broader sets of enhanced properties. In general, if the prim-
itives of two rows are combined, the combined primitive
inherits the strongest level of individual fulﬁllment from
the Security Properties Offered columns (a logical-OR) but
the weakest level from the Evaluation of Impact on HTTPS
columns (a logical-AND).
A. Security Properties Offered by Primitives
Detecting Certiﬁcate Substitution (Table I–column A):
Section IV-B provided several examples of how adversaries
have illegitimately obtained browser-accepted certiﬁcates for
subject domains (targets) they do not control. An adversary
capable of modifying a TLS handshake intended for this
target (through e.g., wide-impact DNS hijacking or on-
path interception near the server) could actively replace the
target’s certiﬁcate with his own—a substitution allowing
read/write access to the encrypted content without triggering
browser warnings or errors. Primitives that detect such a
MITM attack involving a substituted certiﬁcate are listed
under Detects MITM (ﬁrst column, Table I). If a primitive
requires risk or “blind” trust on ﬁrst use (TOFU) to detect
these attacks, we use ◦ to denote partial fulﬁllment.
Some primitives detect only speciﬁc subclasses of such
MITM attacks. We say a MITM attack is local
if the
adversary is able to insert himself into connections to the
server from only a subset of clients (through e.g., poisoned
local DNS cache or on-path interception near the client);
if detectable,
the primitive fulﬁls Detects Local MITM.
An HTTPS connection is often used to transmit a client
authentication credential (e.g., a password or secure cookie)
to the host. Some primitives focus on protecting against
credential theft during an HTTPS MITM attack; these fulﬁll
Protects Client Credential. Again, blind TOFU primitives
partially fulﬁll (◦). Some primitives that use pinning (see
518
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:35 UTC from IEEE Xplore.  Restrictions apply. 
below) make false-reject errors if a server updates its public
key, switches issuing CAs, or uses multiple certiﬁcates for
the same host. Primitives that resolve such false-reject errors
fulﬁl Updatable Pins.
Detecting TLS Stripping (Table I–column B): Sec-
tion IV-E outlined TLS stripping attacks where HTTPS
POSTs [79] or GETs [72] are simply downgraded to HTTP
by a man-in-the-middle adversary. Since many enhance-
ments to HTTPS do not take into account security-relevant
details of a connection until there is an HTTPS request
from the client, TLS stripping bypasses them. Primitives that
can detect stripping attacks fulﬁl Detects TLS Stripping and
partially fulﬁl it if they rely on blind TOFU. Primitives that
deter (through enforcement or a security indicator) POST
requests from being submitted over HTTP fulﬁl Afﬁrms
POST-to-HTTPS.
PKI Improvements (Table I–column C): Sections IV-D
and IV-C respectively described two general problems with
the PKI infrastructure: the lack of reliable revocation and the
hidden nature of intermediate CA certiﬁcates. We assume in
evaluating the primitives that CRLs or OCSP responses are
not available and examine their ability to otherwise detect a
revoked certiﬁcate; primitives which do fulﬁll Responsive
Revocation. Primitives fulﬁl Intermediate CAs Visible if
every intermediate CA is visible to the user at any time.
B. Evaluation Criteria for Impact on HTTPS
Security & Privacy: Some primitives introduce new in-
frastructure elements, which include entities that contribute
to the trust decision or are queried when establishing an
HTTPS connection. A primitive not introducing any new
trusted parties fulﬁlls No New Trusted Entity, with partial
fulﬁllment if the responsibilities of an already trusted party
are expanded. If it does not introduce any new parties that
will become aware of all (or a fraction of) sites a user visits
over HTTPS, it fulﬁlls No New Traceability. If it eliminates
such a class of entities (such as OCSP responders) it fulﬁlls
Reduces Traceability.
In the current HTTPS model, servers authenticate them-
selves through certiﬁcates. Many primitives effectively intro-
duce new server authentication tokens, like (see below) pins
or signed OCSP responses, that are transmitted to the client.
Generally procedures for issuing, updating, and revoking
these new tokens must be established, as well as integrity
protection. Primitives that do not introduce such tokens fulﬁl
No New Auth’n Tokens.
Deployability: Primitives that do not change how web
servers implement TLS and HTTPS have the greatest poten-
tial for deployment. Primitives that do not require any server
involvement or code changes fulﬁll No Server-side Changes,
while primitives that only require servers to participate in
a way that does not
involve changing any server code
partially fulﬁlls it. Some primitives rely on DNSSEC which
has not been fully deployed;
the others are Deployable
without DNSSEC. If primitives do not introduce an extra
communication round that blocks completion of the connec-
tion, they fulﬁll No Extra Communications. Finally, Internet
Scalable systems could foreseeably support enrolment from
all current HTTPS servers and potentially beyond.
Usability: Evaluating usability properties is difﬁcult with-
out conducting user studies. However, some objective us-
ability properties can be determined from the design and
knowledge of the operating environment. A primitive fulﬁlls
No False-Rejects if it does not reject legitimate server certiﬁ-
cates. A primitive not fulﬁlling No False-Rejects requires the
user (e.g., through a warning dialogue) to distinguish false-
rejects from an actual attack. Primitives fulﬁll No New User
Decisions if they are automated and do not require users to
respond correctly to new security cues or dialogues.
In the current model, an HTTPS connection succeeds,
with a security indicator (closed lock), when a site certiﬁcate
is browser-acceptable. For some primitives, connections may
succeed for other reasons. For example, if a primitive is
blind TOFU, an indication of trust could be attributed to it
being the ﬁrst use or because the behaviour matches what
is expected. Depending on how these primitives are imple-
mented, users either (i) cannot readily determine the reason
for trust, (ii) are frequently warned, or (iii) a new security
cue is introduced. The latter two would respectively impact
No False-Rejects and No New User Decision. Instead of
assuming how these primitives should be implemented, we
identify them as not fulﬁlling Status Signalled Completely.
We award a partial fulﬁllment if the basis of trust is not clear
because server enrolment is optional, and thus a fallback
trust mechanism may be also necessary.
C. Summary and Evaluation of Proposed Primitives
Here we describe the proposals summarized in Table I.
Due to space constraints, detailed justiﬁcation of the ratings
is provided in the extended version of this paper [32].
Key Pinning (Client History): Other than the browser
trust anchors, validating an HTTPS server certiﬁcate is
a stateless process, independent of any previous browser
acceptable certiﬁcates seen for a particular site. A pinning
primitive based on client history (also called inductive
pinning) remembers the last browser-acceptable public key
encountered for a particular site and warns the user if this
information changes. This allows detection of certiﬁcate
substitution attacks, even if the adversary has somehow
obtained a browser-acceptable certiﬁcate—but only if the
user has visited the site previously. Note that the term ‘key
pinning” (used here and below) is a slight misnomer, as the
pin could specify anything from the entire certiﬁcate chain to
a predicate applied over various certiﬁcate attributes to only
the SubjectPublicKeyInfo ﬁeld of the server certiﬁcate.
Client-based key pinning is proposed in CertLock [93]
(which pins the issuing CA country) and implemented in
519
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:35 UTC from IEEE Xplore.  Restrictions apply. 
Firefox extension Certiﬁcate Patrol (which pins the entire
chain and shows differences through a dialogue).
Key Pinning (Server): With client-side key pinning, a
trade-off results from the level of granularity of certiﬁcate
information being pinned. Servers are better positioned to
themselves know which certiﬁcate attributes are likely to
remain stable over time, and certiﬁcate rollovers are typ-
ically planned in advance. Server-asserted pinning allows
the server to specify in an HTTPS header or TLS extension
which certiﬁcate attributes to pin and for how long. One
proposal, HPKP [10], suggests that servers specify a set of
public keys (the SubjectPublicKeyInfo ﬁeld of an X.509
certiﬁcate) of which one must be present in each interaction.
A second proposal, TACK [12], is similar but organizes
server keys under a new TACK signing key, to which the
hostname is pinned by the client. The TACK key is used
to sign server certiﬁcates and can allow revocation (see Key
Agility/Manifest below).
Key Pinning (Preloaded): To avoid the blind TOFU
approach of server-asserted key pinning, browser vendors
could include a list of pins within the browser itself. Google
Chrome currently pins a number of certiﬁcates for its own
domains, as well as others by request.24 Among other issues,
this pinning allowed Chrome users to detect the earlier-
mentioned MITM attack involving DigitNotar. The list could
be populated by entities other than the browser vendor.
Key Pinning (DNS): Recall that some CAs offer DV
certiﬁcates to sites that can demonstrate control over the
DNS record for their hostname. If a CA does no more than
look at a DNS record to validate ownership then couldn’t
clients do it instead, cutting out the CA? In practice, it is
easier for an adversary to manipulate the client’s view of
DNS, which could rely on a cache or local resolver [94].
However with DNSSEC, records digitally signed by the
name servers give clients the ability to validate records.
The DNS-based Authentication of Named Entities (DANE)
protocol [3] proposes that servers pin their public key in
their DNSSEC record for clients to validate against.
We note one beneﬁt of DNS-based pinning proposed [7]
not captured in our framework. Even without DNSSEC,
sites could pin certiﬁcate attributes such as acceptable CAs,
for other CAs to reference if they are ever asked, perhaps
illegitimately, to generate a certiﬁcate for the site. This offers
protection against social engineering attacks that imperson-
ate a domain owner to a CA.
Multipath Probing: Crowdsourcing is an approach with
many technological applications. Applied to making trust de-
cisions in HTTPS, crowdsourcing might take one of several
forms. First, participants could contribute objective (e.g., “I
have seen this certiﬁcate before”) or subjective (e.g., “I do
not trust the CA that issued this certiﬁcate”) information. We
cannot deﬁnitively evaluate subjective crowdsourcing as the
24A. Langley, “Public key pinning,” Imperial Violet (blog), 04 May 2011.
properties it achieves depend on the quality of information
provided by a client’s peers. Tools that enable subjective
trust assertions (whether crowd-sourced or from a delegated
authority) include Omnibroker [9], Monkeysphere (web of
trust PKI for HTTPS), YURLs (URLs with a built-in public
key ﬁngerprint obtained from a trusted peer), and S-Links
(links to HTTPS sites where the links specify certiﬁcate
information or extra validation steps).
Objective measurements generally fall along the dimen-
sions of time (e.g., “I see the same certiﬁcate as last
time”) and space (“I see the same certiﬁcate as my peer”).
Time-based measurements are captured by inductive client
pinning, however we note that the usefulness of blind TOFU
can be extended by ﬁnding the peer with the earliest “ﬁrst
use.” Multipath probing is a space-based measurement; the
idea is to establish if the client receives a certiﬁcate that
is consistent with the certiﬁcate received by independent
observers (notaries) distributed across the internet. Multipath
probing can detect local certiﬁcate substitution attacks, but
not attacks where all trafﬁc to the host is modiﬁed.
As a primitive, multipath probing was proposed in Per-
spectives [107], available as a Firefox extension. Conver-
gence [73], also a Firefox extension, is a reﬁnement that
provides a more general architecture for crowdsourcing that
could include subjective information as well as objective
measures. Another reﬁnement, DoubleCheck [17], probes
from multiple servers in the existing Tor anonymity network
(which cleanly eliminates the privacy threat notaries pose
in terms of tracking). In addition to network devices, any
collection of certiﬁcate data can additionally be consulted for
an independent perspective (e.g., the SSL Observatory [39]
or ICSI Notary [18]). Certiﬁcate Transparency (CT) [6]
is a proposal for creating a central audit log of HTTPS
certiﬁcates, which is veriﬁably append-only and maintained
by independent monitors.
Channel-bound Credentials: Some primitives forgo de-
tecting MITM attacks in favour of protecting some of
the information otherwise subject
to theft by a MITM
adversary. HTTPS is commonly used to provide secure
transport of client authentication credentials, e.g., passwords
and cookies. Channel-bound credentials make such creden-
tials functionally dependent on the speciﬁcs of the HTTPS
connection—speciﬁcs an adversary cannot replicate even
with a browser-acceptable certiﬁcate for the site. Rather than
modifying user-chosen passwords, these primitives modify
the authentication value in cookies. With channel-bound
cookies [36], this value is cryptographically bound to a
semi-persistent, site-speciﬁc public key certiﬁcate generated
on-the-ﬂy by the client, called an origin bound certiﬁcate
(OBC). To login with such a cookie, the client ﬁrst es-
tablishes a mutually authenticated TLS connection using
its OBC and then transmits the OBC-dependent cookie. A
MITM adversary cannot successfully use a stolen OBC-
bound cookie unless it can establish an OBC-authenticated
520
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:35 UTC from IEEE Xplore.  Restrictions apply. 