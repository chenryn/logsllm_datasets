ProxyLogon
is Just the Tip of the Iceberg
A New Attack Surface on Microsoft Exchange Server!
Orange Tsai
Orange Tsai
â€¢ Orange Tsai, focusing on Web and Application 0-day research
â€¢ Principal Security Researcher of DEVCORE
â€¢ Captain of HITCON CTF Team
â€¢ Speaker of Security Conferences
â€¢ Black Hat USA & ASIA / DEFCON / HITB / HITCON â€¦
â€¢ Selected Awards and Honors:
â€¢ 2017 - 1st place of Top 10 Web Hacking Techniques
â€¢ 2018 - 1st place of Top 10 Web Hacking Techniques
â€¢ 2019 - Winner of Pwnie Awards "Best Server-Side Bug"
â€¢ 2021 - Champion and "Master of Pwn" of Pwn2Own
Disclaimer
All vulnerabilities disclosed today are reported responsibly and
patched by Microsoft
Why Target Exchange Server?
1.
Mail servers always keep confidential secrets and Exchange Server is 
the most well-known mail solution for enterprises and governments 
worldwide
2. Has been the target for Nation-sponsored hackers for a long time 
(Equation GroupðŸ˜‰)
3. More than 400,000 Exchange servers exposed on the Internet 
according to our survey
Exchange Security in the Past Years
â€¢ Most bugs are based on known attack vectors but there are still 
several notable bugs:
1.
EnglishmansDentist from Equation Group: 
â€¢ Recap: A only practical and public pre-auth RCE in the Exchange history. Unfortunately, the 
arsenal only works on an ancient Exchange Server 2003
2.
CVE-2020-0688 Hardcoded MachineKey from anonymous working with ZDI:
â€¢ Recap: A classic .NET deserialization bug due to a hardcoded cryptography key. This is also a 
hint shows Microsoft Exchange is lacking of security reviews
Our Works
â€¢ We focus on the Exchange architecture and discover a new attack surface 
that no one proposed before. That's why we can pop 0days easily!
â€¢ We discovered 8 vulnerabilities that covered server-side, client-side, and 
crypto bugs through this new attack surface, and chained into 3 attacks:
1.
ProxyLogon: The most well-known pre-auth RCE chain
2.
ProxyOracle: A plaintext-password recovery attacking chain
3.
ProxyShell: The pre-auth RCE chain we demonstrated at Pwn2Own 2021
Vulnerabilities We Discovered
â–  Vulnerability related to this new attack surface
Report Time
Name
CVE
Patch Time
Reported by
Jan 05, 2021
ProxyLogon
CVE-2021-26855
Mar 02, 2021
Orange Tsai, Volexity
and MSTIC
Jan 05, 2021
ProxyLogon
CVE-2021-27065
Mar 02, 2021
Orange Tsai, Volexity
and MSTIC
Jan 17, 2021
ProxyOracle
CVE-2021-31196
Jul 13, 2021
Orange Tsai
Jan 17, 2021
ProxyOracle
CVE-2021-31195
May 11, 2021
Orange Tsai
Apr 02, 2021
ProxyShell
(Pwn2Own Bug)
CVE-2021-34473
Apr 13, 2021
Orange Tsai
(Working with ZDI)
Apr 02, 2021
ProxyShell
(Pwn2Own Bug)
CVE-2021-34523
Apr 13, 2021
Orange Tsai
(Working with ZDI)
Apr 02, 2021
ProxyShell
(Pwn2Own Bug)
CVE-2021-31207
May 11, 2021
Orange Tsai
(Working with ZDI)
Jun 02, 2021
-
-
-
Orange Tsai
Vulnerabilities Related to This 
Attack Surface
Dubbed to
CVE
Patch Time
Reported by
HAFNIUM
CVE-2021-26855
Mar 02, 2021
Orange Tsai, Volexity and MSTIC
HAFNIUM
CVE-2021-27065
Mar 02, 2021
Orange Tsai, Volexity and MSTIC
HAFNIUM
CVE-2021-26857
Mar 02, 2021
Dubex and MSTIC
HAFNIUM
CVE-2021-26858
Mar 02, 2021
MSTIC
-
CVE-2021-28480
Apr 13, 2021
NSA
-
CVE-2021-28481
Apr 13, 2021
NSA
-
CVE-2021-28482
Apr 13, 2021
NSA
-
CVE-2021-28483
Apr 13, 2021
NSA
â–  Vulnerability related to this new attack surface
Exchange Architecture
Backend Server
Frontend Server
2000/2003
Mailbox Role
Client Access Role
Hub Transport 
Role
Unified Messaging 
Role
Edge Transport 
Role
2007/2010
Mailbox Role
Client Access Role
Edge Transport 
Role
2013
Edge Transport 
Role
2016/2019
Mailbox Role
Mailbox Service
Client Access 
Service
Where to Focus?
â€¢ We focus on the Client Access Service (CAS)
â€¢ CAS is a fundamental protocol handler in Microsoft Exchange Server. 
The Microsoft official documentation also indicates:
"Mailbox servers contain the Client Access Services that accept client 
connections for all protocols. These frontend services are responsible for 
routing or proxying connections to the corresponding backend services"
where we focus on
Client Access Service in IIS
Two websites?
Client Access Service in IIS
Exchange Architecture
â€¢ Applications in Frontend include the ProxyModule
â€¢ Parse incoming HTTP requests, apply protocol specified settings, and 
forward to the Backend
â€¢ Applications in Backend include the BackendRehydrationModule
â€¢ Receive and populate HTTP requests from the Frontend
â€¢ Applications synchronizes the internal information between the 
Frontend and Backend by HTTP headers
IIS
IIS
Remote
PowerShell
RPC 
Proxy
EWS, OWA
ECP, OABâ€¦
Mailbox Database
FrontEnd Service
BackEnd Service
HTTP/HTTPS
IIS Modules
Validation
Module
Logging
Module
IIS Modules
Filter
Module
FBA
Module
Oauth
Module
â€¦
Rehydration
Module
RoutingUpdate
Module
RBAC
Module
HTTP Proxy Module
Our Ideas
Could we access the Backend intentionally?
\ProxyRequestHandler.cs
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
Copy Client Headers
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
HTTP Header Blacklists
protected virtual bool ShouldCopyHeaderToServerRequest(string headerName) {
return !string.Equals(headerName, "X-CommonAccessToken", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "X-IsFromCafe", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "X-SourceCafeServer", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "msExchProxyUri", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "X-MSExchangeActivityCtx", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "return-client-request-id", OrdinalIgnoreCase) 
&& !string.Equals(headerName, "X-Forwarded-For", OrdinalIgnoreCase) 
&& (!headerName.StartsWith("X-Backend-Diag-", OrdinalIgnoreCase) 
|| this.ClientRequest.GetHttpRequestBase().IsProbeRequest());
}
HttpProxy\ProxyRequestHandler.cs
Copy Client Cookies
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Add Special Headers
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Clone User Identity
if (this.ClientRequest.IsAuthenticated) {
CommonAccessToken commonAccessToken = AspNetHelper.FixupCommonAccessToken(
this.HttpContext, this.AnchoredRoutingTarget.BackEndServer.Version);
if (commonAccessToken != null) {
headers["X-CommonAccessToken"] = commonAccessToken.Serialize(
new int?(HttpProxySettings.CompressTokenMinimumSize.Value));
}
} else if (this.ShouldBackendRequestBeAnonymous()) {
headers["X-CommonAccessToken"] = new CommonAccessToken(9).Serialize();
}
HttpProxy\ProxyRequestHandler.cs
Calculate Backend URL
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Create New HTTP Client
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Attach Authorization Header
if (this.ProxyKerberosAuthentication) {
// use origin Kerberos Authentication
} else if (this.AuthBehavior.AuthState == AuthState.BackEndFullAuth || this.
ShouldBackendRequestBeAnonymous() || (HttpProxySettings.TestBackEndSupportEnabled.Value
&& !string.IsNullOrEmpty(this.ClientRequest.Headers["TestBackEndUrl"]))) {
// unauthenticated
} else {
serverRequest.Headers["Authorization"] = KerberosUtilities.GenerateKerberosAuthHeader(
serverRequest.Address.Host, this.TraceContext, 
ref this.authenticationContext, ref this.kerberosChallenge);
}
HttpProxy\ProxyRequestHandler.cs
Generate Kerberos Ticket
internal static string GenerateKerberosAuthHeader(string host, int traceContext, ref
AuthenticationContext authenticationContext, ref string kerberosChallenge) {
// â€¦
authenticationContext = new AuthenticationContext();
authenticationContext.InitializeForOutboundNegotiate(AuthenticationMechanism.Kerberos,
"HTTP/" + host, null, null);
SecurityStatus securityStatus = authenticationContext.NegotiateSecurityContext(inputBuffer, 
out bytes);
return "Negotiate " + Encoding.ASCII.GetString(bytes);
}
HttpProxy\KerberosUtilities.cs
The Actual Request Sent to 
Backend
Get Backend Response
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section
> GetTargetBackEndServerUrl
> CreateServerRequest
> GetServerResponse
3.
Response Section
> CopyHeadersToClientResponse
> CopyCookiesToClientResponse
BeginRequest
AuthenticateRequest
AuthorizeRequest
MapRequestHandler
EndRequest
IHttpHandler
LogRequest
Copy Response to Client
1.
Request Section
> CopyHeadersToServerRequest
> CopyCookiesToServerRequest
> AddProtocolSpecificHeadersToServerRequest
2.
Proxy Section