# Title: Attribute-Based Key Exchange with General Policies

## Authors:
- Vladimir Kolesnikov, Bell Labs
- Hugo Krawczyk, IBM Research
- Yehuda Lindell, Bar-Ilan University
- Alex J. Malozemoff, Galois
- Tal Rabin, IBM Research

## Abstract
Attribute-based methods provide authorization to parties based on whether their set of attributes (e.g., age, organization, etc.) fulfills a policy. In attribute-based encryption (ABE), authorized parties can decrypt, and in attribute-based credentials (ABCs), authorized parties can authenticate themselves.

In this paper, we combine elements of ABE and ABCs with garbled circuits to construct attribute-based key exchange (ABKE). Our focus is on an interactive solution involving a client that holds a certificate (issued by an authority) vouching for the client’s attributes and a server that holds a policy computable on such a set of attributes. The goal is for the server to establish a shared key with the client if and only if the client’s certified attributes satisfy the policy. Our solution ensures strong privacy guarantees for both the client and the server, including attribute privacy and unlinkability of client sessions.

Our main contribution is a construction of ABKE for arbitrary circuits with high (concrete) efficiency. Specifically, we support general policies expressible as boolean circuits computed on a set of attributes. Even for policies containing hundreds of thousands of gates, the performance cost is dominated by two pairing computations per policy input. This means that, for a similar cost to prior ABE/ABC solutions, which can only support small formulas efficiently, we can support vastly richer policies.

We implemented our solution and report on its performance. For policies with 100,000 gates and 200 inputs over a realistic network, the server and client spend 957 ms and 176 ms on computation, respectively. When using offline preprocessing and batch signature verification, this drops to only 243 ms and 97 ms.

## 1. Introduction
The increasing need and complexity of authentication in the digital world, alongside growing privacy concerns, has led to the development of encryption and authentication mechanisms that combine privacy aspects (anonymity, unlinkability, etc.) with credentials that go beyond asserting an identity but rather vouch for a full set of attributes (age, rank, role, etc.). These mechanisms allow for authentication and encryption based on authorization policies computed on the provided set of attributes. For example, in a hospital setting, access to a patient’s records can be provided to the patient, her doctor, nurses while on duty, or the director of the hospital ward, formalized as a policy.

Prime examples of these mechanisms are attribute-based credentials (ABCs) [23, 17, 19, 20, 7, 3, 4] and attribute-based encryption (ABE) [36, 30, 9, 38]. ABCs are mainly directed towards identification and access control based on a set of attributes, emphasizing privacy aspects such as anonymity, unlinkability, and attribute privacy. While ABCs generally assume an interactive setting between a client and a server, ABE focuses on (non-interactive) encryption where authorization is enforced through an encryption scheme that ties a ciphertext to a policy and a decryption key, ensuring that only clients with attributes satisfying the policy can decrypt (note that we focus on the "ciphertext policy" setting of ABE [9]). Since ABE schemes are non-interactive, they have certain implicit privacy properties of ABC solutions, such as unlinkability and attribute privacy. An essential requirement of these primitives is collusion resistance, meaning different clients cannot combine their attributes to pass policy verification that neither could individually pass.

In many practical settings, simply communicating a message to a party or establishing rights (such as validating a function of attributes) is not enough. For example, authentication to an online service is usually followed by further communications that also need to be protected. The goal in these systems is to use credentials to bootstrap a key exchange protocol that provides the parties with keys to protect a session.

In this paper, we combine elements of ABE and ABCs to build attribute-based key exchange (ABKE). Our focus is on an interactive solution involving a client that holds a certificate (issued by an authority CA) vouching for the client’s attributes and a server that holds a policy computable on such a set of attributes. The goal is for the server to establish a shared key with the client if and only if the client’s certified attributes satisfy the policy. Our solution enjoys strong privacy guarantees for both the client and the server, including attribute privacy and unlinkability of client sessions.

### 1.1 Overview of Our Solutions
Our main contributions are a definition (cf. §4) and realization (cf. §6) of attribute-based key exchange (ABKE) for public (circuit-based) policies.

**ABKE using garbled circuits.** Our construction uses garbled circuits to achieve ABKE. The use of garbled circuits enables us to obtain a solution that supports arbitrarily-complex policies without requiring heavy machinery like multilinear maps or fully homomorphic encryption and is concretely efficient. In our approach, the server generates a garbled circuit and sends it to the client. The client then obtains the garbled values on the input wires of the circuit, depending on its attributes. This is achieved by encrypting the garbled values on the input wires using a type of encryption that enables the client to decrypt only those values associated with its attributes. We call this notion attribute selective encryption (ASE) (cf. §5). The main technical difficulty comes with ensuring that the client obtains input labels corresponding to its credentials in a private, unlinkable, and collusion-free manner. At a high level, we construct such an encryption scheme using a rerandomizable set of public keys and a rerandomizable signature binding the public keys together. The client then presents a set of rerandomized keys (along with a signature on them), and the server encrypts the garbled labels knowing that the client can only decrypt the appropriate set. We introduce and utilize the notion of extractable linearly homomorphic (ELH) signatures (cf. §7) to construct two instantiations of ASE: one based on identity-based encryption (cf. §8) and the other built directly from ELH signatures (cf. §9). The extractability requirement ensures that a simulator can extract the original message that was signed, even though the adversary presents a randomized message. We prove this extractability property using the knowledge-of-exponent (KEA) assumption.

Our use of garbled circuits is a careful adaptation of the zero-knowledge-using-garbled-circuits approach of Jawurek et al. [34]. As shown in their work, we can use a single garbled circuit while still achieving malicious security; this is discussed in more detail in §6.

**Concrete performance.** At a cost similar to that of prior ABE/ABC solutions, which only run efficiently on (small) formulas, we can support vastly richer policies represented by large circuits. Specifically, we instantiate our construction over bilinear groups requiring a number of pairings proportional to the number of input attributes to the policy circuit. Then, a garbled circuit computation of the policy circuit is performed with a cost that is not noticeable for policies of even relatively large circuit size.

To directly measure the performance of our scheme, we implemented it and ran various experiments; see §10. For example, in our implementation, the server and client computation time for a 1,000-gate policy and 10 attributes is 67 ms and 11 ms, respectively; for a 100,000-gate policy and 200 attributes, the times are only 957 ms and 176 ms. We also note that much of the computation can be moved offline, and we can use batch signature verification on the server side. With a 100,000-gate policy and 200 attributes, this optimized time is only around 243 ms for the server, when assuming the server is batching ten messages in its signature verification, and 97 ms for the client.

**Additional features.** Our construction can be easily extended to provide additional useful features, as detailed below:
- **Credential expiration:** By having attributes encode the expiration date.
- **Delegation of attributes:** This follows directly from the projectability property of our ASE definition (cf. §5).
- **Multi-authority:** This can be achieved generically by having credentials from different CAs encode, as a sequence of attributes, a unique certified serial number which is verified to be the same during ABKE. A more efficient alternative is offered by our ELH-based ASE construction (cf. §9) by using a common value \( u \) in the clients’ public keys in lieu of a unique serial number.
- **Unlinkability with respect to CA:** Our IBE-based construction for ASE (cf. §8) provides information-theoretic unlinkability, which implies unlinkability even against a colluding server and CA. Such unlinkability is also achieved by our ELH-based solution provided that the public key components \( g \) and \( h \) are generated jointly between the client and CA.

**Future work.** In this work, we consider public policies only. However, our techniques can be used to provide some notion of private policies, and we leave this for future work. Likewise, our focus here has been on achieving practical efficiency, and we achieve this using the KEA assumption and the random-oracle model. The goal of achieving comparable efficiency under standard assumptions only and without a random oracle is important, and we leave it for future work.

## 2. Related Work
Our ABKE notion relates to ciphertext-policy attribute-based encryption (CP-ABE) and attribute-based credentials (ABCs). CP-ABE gives rise to a single-message key exchange (KE) solution in which a session key is encrypted under ABE and hence is implicitly authenticated by clients that can decrypt. Since the same key is distributed to any client with a set of attributes satisfying the policy, multiple clients may share the same key. This is the solution proposed by Gorantla et al. [28], who provide a game-based definition of attribute-based authenticated key exchange (under the abbreviation AB-AKE) and note that such a scheme is more in line with group key exchange than standard AKE.

ABE-based AKE requires several public-key operations per gate of the policy formula. Recent solutions to ABE for general circuits [26, 29], while sufficient to show feasibility, are mainly of theoretical interest due to the use of heavy underlying primitives. By using garbled circuits, our protocol costs are dramatically lower than either of the above ABE-based solutions.

Since most key exchange settings allow for interaction (the session that they protect is in itself typically interactive), our work leverages interaction to improve policy expressiveness and performance. In this sense, we are closer to the ABC setting, where clients own the credentials they use in the protocol.