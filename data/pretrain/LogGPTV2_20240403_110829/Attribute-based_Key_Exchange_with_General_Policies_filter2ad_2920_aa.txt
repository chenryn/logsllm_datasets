title:Attribute-based Key Exchange with General Policies
author:Vladimir Kolesnikov and
Hugo Krawczyk and
Yehuda Lindell and
Alex J. Malozemoff and
Tal Rabin
Attribute-based Key Exchange with General Policies∗
Vladimir Kolesnikov
Hugo Krawczyk
IBM Research
PI:EMAIL
Yehuda Lindell
Bar-Ilan University
PI:EMAIL
Tal Rabin
IBM Research
PI:EMAIL
1.
INTRODUCTION
The increasing need and complexity of authentication in
the digital world, alongside ever growing privacy concerns,
has given rise to encryption and authentication mechanisms
that combine privacy aspects (anonymity, unlinkability, etc.)
with credentials that go well beyond asserting an identity
of a client but rather vouch for a full set of attributes (age,
rank, role, etc.). These mechanisms allow for authentication
and encryption that build on authorization policies com-
puted on the provided set of attributes. For example, in a
hospital setting, access to a patient’s records can be pro-
vided to the patient, her doctor, nurses while on duty, or to
the director of the hospital ward, and this can be formalized
as a policy.
The prime examples of these mechanisms are attribute-
based credentials (ABCs) [23, 17, 19, 20, 7, 3, 4] and attribute-
based encryption (ABE) [36, 30, 9, 38]. The former is mainly
directed towards identiﬁcation and access control based on
a set of attributes, and emphasizes privacy aspects such
as anonymity, unlinkability, and attribute privacy. While
ABCs generally assume an interactive setting between a
client and a server, ABE focuses on (non-interactive) encryp-
tion where authorization is enforced through an encryption
scheme that ties a ciphertext to a policy and a decryption
key that ensures that only clients that have attributes that
satisfy the policy can decrypt (note that we focus on the “ci-
phertext policy” setting of ABE [9]). Since ABE schemes are
non-interactive (and the party decrypting is completely pas-
sive), they have certain implicit privacy properties of ABC
solutions such as unlinkability and attribute privacy. An
essential requirement of the above primitives is that of col-
lusion resistance. This means that diﬀerent clients of the
system cannot combine their attributes in order to pass pol-
icy veriﬁcation that neither could have individually passed.
In many practical settings simply communicating a mes-
sage to a party or just establishing rights (such as validating
a function of attributes) is not enough. For example, authen-
tication to an online service is usually followed with further
communications that also need to be protected.
In other
words, the goal in these systems is the use of credentials to
bootstrap a key exchange protocol that provides the parties
with keys to protect a session.
In this paper we combine elements of ABE and ABCs to
build attribute-based key exchange (ABKE) where our focus
is on an interactive solution involving a client that holds
a certiﬁcate (issued by an authority CA) vouching for the
client’s attributes and a server that holds a policy com-
kolesnikov@research.bell-
Bell Labs
labs.com
†
Alex J. Malozemoff
PI:EMAIL
Galois
ABSTRACT
Attribute-based methods provide authorization to parties
based on whether their set of attributes (e.g., age, organi-
zation, etc.) fulﬁlls a policy. In attribute-based encryption
(ABE), authorized parties can decrypt, and in attribute-
based credentials (ABCs), authorized parties can authen-
ticate themselves.
In this paper, we combine elements of
ABE and ABCs together with garbled circuits to construct
attribute-based key exchange (ABKE). Our focus is on an in-
teractive solution involving a client that holds a certiﬁcate
(issued by an authority) vouching for that client’s attributes
and a server that holds a policy computable on such a set of
attributes. The goal is for the server to establish a shared
key with the client but only if the client’s certiﬁed attributes
satisfy the policy. Our solution enjoys strong privacy guar-
antees for both the client and the server, including attribute
privacy and unlinkability of client sessions.
Our main contribution is a construction of ABKE for ar-
bitrary circuits with high (concrete) eﬃciency. Speciﬁcally,
we support general policies expressible as boolean circuits
computed on a set of attributes. Even for policies contain-
ing hundreds of thousands of gates the performance cost is
dominated by two pairing computations per policy input.
Put another way, for a similar cost to prior ABE/ABC solu-
tions, which can only support small formulas eﬃciently, we
can support vastly richer policies.
We implemented our solution and report on its perfor-
mance. For policies with 100,000 gates and 200 inputs over
a realistic network, the server and client spend 957 ms and
176 ms on computation, respectively. When using oﬄine
preprocessing and batch signature veriﬁcation, this drops to
only 243 ms and 97 ms.
∗
iacr.org/2016/518
†
Portion of work done while at University of Maryland and
Bell Labs.
The full version of this paper is available at https://eprint.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978359
1451putable on the set of attributes. The goal is for the server
to establish a shared key with the client if and only if the
client’s certiﬁed attributes satisfy the policy.1
Of course, the above goal is easy to achieve if the client
is willing to reveal its attributes to the server. The objec-
tive of our work is to enable the ABKE functionality while
keeping the attributes of the client private alongside ensur-
ing additional important properties. The main features of
our ABKE solution are summarized next.
General policies. We support any policy expressible as a
polynomial-size boolean circuit computed on a set of
attributes.
Attribute privacy. Client attributes are never disclosed. Of
course, the server learns whether the key exchange suc-
ceeded and thus learns that the client’s attributes ful-
ﬁll the policy used in the exchange. However, nothing
beyond this fact is revealed.
Unlinkability. Multiple communications with the same client
(with one or more servers) cannot be linked together.
Collusion resistance. It is not possible for an adversary given
keys associated with multiple clients with diﬀerent at-
tributes (certiﬁed by the CA) to succeed in an exchange
in which no single client with its associated attributes
fulﬁlls the policy. In particular, attributes from diﬀer-
ent clients cannot be mixed-and-matched.
1.1 Overview of Our Solutions
Our main contributions are a deﬁnition (cf. §4) and real-
ization (cf. §6) of attribute-based key exchange (ABKE) for
public (circuit-based) policies.
ABKE using garbled circuits. Our construction uses
garbled circuits in order to achieve ABKE. The use of gar-
bled circuits enables us to obtain a solution that both sup-
ports arbitrarily-complex policies (without requiring heavy
machinery like multilinear maps or fully homomorphic en-
cryption) and is concretely eﬃcient. In our approach, the
server generates a garbled circuit and sends it to the client.
The client then obtains the garbled values on the input wires
of the circuit, depending on its attributes. This is achieved
by encrypting the garbled values on the input wires using
a type of encryption that enables the client to decrypt only
those values associated with its attributes. We call this no-
tion attribute selective encryption (ASE) (cf. §5). The main
technical diﬃculty comes with ensuring that the client ob-
tains input labels corresponding to its credentials in a pri-
vate, unlinkable, and collusion-free manner. At a high level,
we construct such an encryption scheme using a rerandomiz-
able set of public keys and a rerandomizable signature bind-
ing the public keys together. The client then presents a set
of rerandomized keys (along with a signature on them), and
the server encrypts the garbled labels knowing that the client
can only decrypt the appropriate set. We introduce and uti-
lize the notion of extractable linearly homomorphic (ELH) sig-
natures (cf. §7) to construct two instantiations of ASE: one
based on identity-based encryption (cf. §8) and the other
1Note that we focus on the client-server setting where the
client authenticates to the server. Server authentication usu-
ally happens with regular public key certiﬁcates that identify
the server and can use standard tools such as TLS. Exten-
sions of our system to the mutual authentication setting are
possible but not treated here.
built directly from ELH signatures (cf. §9). The extractabil-
ity requirement ensures that a simulator can extract the
original message that was signed, even though the adversary
presents a randomized message. We prove this extractability
property using the knowledge-of-exponent (KEA) assump-
tion.
Our use of garbled circuits is a careful adaptation of the
zero-knowledge-using-garbled-circuits approach of Jawurek
et al. [34]. As shown in their work, we can use a single
garbled circuit while still achieving malicious security; this
is discussed in more detail in §6.
Concrete performance. At a cost similar to that of prior
ABE/ABC solutions, which only run eﬃciently on (small)
formulas, we can support vastly richer policies represented
by large circuits. Speciﬁcally, we instantiate our construc-
tion over bilinear groups requiring a number of pairings pro-
portional to the number of input attributes to the policy
circuit. Then a garbled circuit computation of the policy
circuit is performed with cost that is not noticeable for poli-
cies of even relatively large circuit size2.
To directly measure the performance of our scheme, we
implemented it and ran various experiments; see §10. For
example, in our implementation, the server and client com-
putation time for a 1,000-gate policy and 10 attributes is
67 ms and 11 ms, respectively; for a 100,000-gate policy
and 200 attributes the times are only 957 ms and 176 ms.
We also note that much of the computation can be moved
oﬄine and we can use batch signature veriﬁcation on the
server side. Again with a 100,000-gate policy and 200 at-
tributes, this optimized time is only around 243 ms for the
server, when assuming the server is batching ten messages
in its signature veriﬁcation, and 97 ms for the client.
Additional features. Our construction can be easily ex-
tended to provide additional useful features, as detailed be-
low.
• Credential expiration, by having attributes encode the
expiration date.
• Delegation of attributes. This follows directly from the
projectability property of our ASE deﬁnition (cf. §5).
• Multi-authority. This can be achieved generically by
having credentials from diﬀerent CAs encode, as a se-
quence of attributes, a unique certiﬁed serial number
which is veriﬁed to be the same during ABKE. A more
eﬃcient alternative is oﬀered by our ELH-based ASE
construction (cf. §9) by using a common value u in the
clients’ public keys in lieu of a unique serial number.
• Unlinkability with respect to CA. Our IBE-based con-
struction for ASE (cf. §8) provides information the-
oretic unlinkability, which implies unlinkability even
against a colluding server and CA. Such unlinkability
is also achieved by our ELH-based solution provided
that the public key components g and h are generated
jointly between the client and CA.
Future work. In this work we consider public policies only.
However, our techniques can be used to provide some no-
tion of private policies and we leave this for future work.
Likewise, our focus here has been on achieving practical eﬃ-
ciency, and we achieve this using the KEA assumption and
2For example, we can garble (resp., evaluate) an AND gate
in roughly 46 (resp., 28) cycles per gate using privacy-free
garbled circuits [25, 39].
1452the random-oracle model. The goal of achieving compara-
ble eﬃciency under standard assumptions only and without
a random oracle is important and we leave it for future work.
2. RELATED WORK
Our ABKE notion relates to ciphertext-policy attribute-
based encryption (CP-ABE) and attribute-based credentials
(ABCs). CP-ABE gives rise to a single-message key ex-
change (KE) solution in which a session key is encrypted
under ABE and hence is implicitly authenticated by clients
that can decrypt. Since the same key is distributed to any
client with a set of attributes satisfying the policy, multiple
clients may share the same key. This is the solution proposed
by Gorantla et al. [28], who provide a game-based deﬁni-
tion of attribute-based authenticated key exchange (under
the abbreviation AB-AKE) and note that such a scheme is
more in line with group key exchange than standard AKE.
ABE-based AKE requires several public-key operations
per gate of the policy formula. Recent solutions to ABE for
general circuits [26, 29], while suﬃcient to show feasibility,
are mainly of theoretical interest due to the use of heavy
underlying primitives. By using garbled circuits, our pro-
tocol costs are dramatically lower than either of the above
ABE-based solutions.
Since most key exchange settings allow for interaction (the
session that they protect is in itself typically interactive), our
work leverages interaction to improve policy expressiveness
as well as performance. In this sense we are closer to the
ABC setting, where clients own the credentials they use in