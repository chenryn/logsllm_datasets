detection-relevant properties occur during regular operation of the IDS mon-
itoring landscape (i.e., during IDS training); this is the statistic ‘number of
occurrences of each variation of the detection-relevant property’.
Attack injection time is the point(s) in time when a hypercall attack con-
sisting of one or more hypercalls is injected. This allows for the speciﬁcation of
arbitrary temporal distributions of attack injection actions. It also allows for the
speciﬁcation of the following relevant temporal properties of malicious activities:
– Base rate: Base rate is the prior probability of an intrusion (attack). The error
occurring when the attack detection accuracy of an IDS is assessed without
taking the base rate into account is known as the base rate fallacy [13]. The
speciﬁcation of attack injection times provides a close estimation of the actual
base rate in the testing phase. As we demonstrate in Sect. 5, base rate can
be estimated by considering the number of injected attacks and the number
of variations of the detection-relevant property that have occurred during
attack injection. The latter is estimated based on the statistic ‘average rate
of occurrence of the detection-relevant property’.
– IDS evasive properties: Speciﬁcation of the attack injection time enables the
injection of “smoke screen” evasive attacks. In the context of this work, the
“smoke screen” technique consists of delaying the invocation of the hypercalls
comprising an attack such that a given amount of benign hypercall activity
occurs between each hypercall invocation. This is an important test since some
IDSes have been shown to be vulnerable to such attacks (e.g., Xenini; see [14]).
3.2 Testing
IDS Training. IDS training is the ﬁrst activity of the testing phase. We require
reinitialization of the IDS monitoring landscape between the planning and test-
ing phases (see Fig. 1a). The rationale behind this is practical: many parame-
ters of the existing IDSes designed to detect hypercall attacks (e.g., length of
IDS training period, attack detection threshold) require a priori conﬁguration.
These parameters are tuned based on observations made in the planning phase
(see Sect. 3.1). This raises concerns related to the non-determinism of hypercall
activities, a topic that we discuss in paragraph ‘on repeatability concerns’.
Attack Injection. For this critical step, we developed a new tool called hInjec-
tor. Section 4 introduces this tool and describes how it is used.
Calculation of Metric Values. After attack injection is performed, values of
relevant metrics can be calculated (e.g., true and false positive rate). This also
raises concerns related to the non-determinism of hypercall activities, which we
discuss next.
On Repeatability Concerns. Observations and decisions made in the plan-
ning phase might be irrelevant if hypercall activities are highly non-deterministic
478
A. Milenkoski et al.
and therefore not repeatable. For example, the benign hypercall activities occur-
ring in the testing phase may not reach steady-state at a point in time close to
the estimated one in the planning phase.
In addition, metric values reported as end-results of an evaluation study,
where workloads that are not fully deterministic are used, have to be statistically
accurate. This is crucial for credible evaluation. Principles of statistical theory
impose metric values to be repeatedly calculated and their means to be reported
as end-results. Therefore, we require repeated execution of the testing phase
(see Fig. 1a). However, this may be time-consuming if the number of needed
repetitions is high due to high non-determinism of hypercall activities.
Specifying an IDS monitoring landscape as we deﬁne it (see Sect. 3.1) alle-
viates the above concerns; that is, it helps to reduce the non-determinism of
hypercall activities by removing major sources of non-determinism, such as non-
repeatable workloads. This is in line with Burtsev [15], who observes that, given
repeatability of execution of VMs’ user tasks is preserved, VMs always invoke
the same hypercalls. We acknowledge that achieving complete repeatability of
hypercall activities by specifying VM characteristics is infeasible. This is mainly
due to the complexity of the architectures and operating principles of kernels.
In Sect. 5, we empirically show that, provided an IDS monitoring landscape is
speciﬁed, a VM’s hypercall activities exhibit repeatability to an extent suﬃcient
to conclude that: (i) the decisions and observations made in the planning phase
are of practical relevance when it comes to IDS testing, and (ii) the number of
measurement repetitions needed to calculate statistically accurate metric values
is small. This is in favor of the practical feasibility of our approach, which involves
repeated initialization of an IDS monitoring landscape.
4 hInjector
hInjector is a tool for injecting hypercall attacks. It realizes the attack injection
scenarios speciﬁed in the planning phase (see Sect. 3.1). The current implementa-
tion of hInjector is for the Xen hypervisor, but the techniques are not Xen-speciﬁc
and can be ported to other hypervisors.
hInjector supports the injection of attacks crafted with respect to the attack
models that we developed (see Sect. 2). We extend these attack models with a
model involving diﬀerent hypercall call sites. Hypercall call sites are one of the
detection-relevant properties that existing IDSes designed to detect hypercall
attacks analyze. We consider that hypercalls can be executed from regular or
irregular call sites. The latter is typically a hacker’s loadable kernel module
(LKM) used to mount hypercall attacks.
Our design criteria for hInjector are injection of realistic attacks, injection
during regular system operation, and non-disruptive attack injection. These cri-
teria are crucial for the representative, rigorous, and practically feasible IDS
evaluation. We discuss more in Sect. 4.2.
Availability. hInjector is publicly available at https://github.com/hinj/hInj.
Evaluation of Intrusion Detection Systems in Virtualized Environments
479
User
Kernel
Hardware
 5
vCPU
monitors
IDS 
(in SVM)
MVM
 1
LKM
Injector
 3
Logs
6
 2
Hypervisor
Filter
 4
Hypercall
handler
Memory
shared_info
 3
 5
Fig. 2. The architecture of hInjector
4.1 hInjector Architecture
Figure 2 depicts the architecture of hInjector. It shows the primary components:
Injector, LKM, Filter, Conﬁguration, and Logs. We refer to the VM from where
hypercall attacks are injected as the malicious VM (MVM). We also depict a
typical IDS designed to detect hypercall attacks, with components in the hyper-
visor and a secured VM (SVM), co-located with MVM (see Sect. 2). The IDS
monitors the MVM’s hypercall activity by monitoring virtual CPU registers and
the virtual memory of MVM using its hypervisor component.
The Injector component, deployed in the MVM’s kernel, intercepts at a given
rate hypercalls invoked by the kernel and modiﬁes hypercall parameter values
on-the-ﬂy (i) making them speciﬁcally crafted for triggering a vulnerability, or
(ii) replacing them with random, irregular values that an IDS may label as
anomalous. The Injector injects hypercalls invoked from a regular call site (i.e.,
from the kernel address space). We discuss more on Injector in Sect. 4.3.
The LKM component, a module in MVM’s kernel, invokes hypercalls with
regular or speciﬁcally crafted parameter value(s), including a series of hypercalls
in a given order. The LKM injects hypercalls invoked from an irregular call site
(i.e., from a loadable kernel module).
The Filter component, deployed in the hypervisor’s hypercall handlers, iden-
tiﬁes hypercalls injected by the Injector or the LKM, blocks the execution of the
respective hypercall handlers, and returns valid error codes. The Filter identi-
ﬁes injected hypercalls based on information stored by the Injector/LKM in the
shared info structure, a memory region shared between a VM and the hypervi-
sor. To this end, we extended shared info with a string ﬁeld named hid (hypercall
identiﬁcation), which contains identiﬁcation information on injected hypercalls.
We discuss more about the Filter when we discuss the design criterion ‘non-
disruptive attack injection’ in Sect. 4.2.
The Conﬁguration component is a set of user ﬁles in XML containing conﬁg-
uration parameters for managing the operation of the Injector and the LKM. It
allows specifying, for example, parameter values for a given hypercall (relevant
to the Injector and the LKM), ordering of a series of hypercalls (relevant to the
LKM), and temporal distribution of injection actions.
480
A. Milenkoski et al.
The Logs are user ﬁles containing records about invoked hypercalls that
are part of attacks; that is, hypercall IDs and parameter values, as well as
timestamps. The logged data serves as reference data (i.e., as “ground truth”)
used for distinguishing false positives from injected attacks and calculating IDS
attack detection accuracy metrics, such as true and false positive rate.
We now present an example of the implemented hypercall attack injection pro-
cedure. Figure 2 depicts the steps to inject a hypercall attack by the LKM: (1)
the LKM crafts a parameter value of a given hypercall as speciﬁed in the conﬁg-
uration; (2) the LKM stores the ID of the hypercall, the number of the crafted
parameter, and the parameter value in hid; (3) the LKM passes the hypercall to
MVM’s vCPU, which then passes control to hypervisor; (4) the Filter, using the
data stored in hid, identiﬁes the injected hypercall when the respective hypercall
handler is executed; (5) the Filter updates hid indicating that it has intercepted
the injected hypercall, then returns a valid error code to block execution of the
handler; (6) after the error code arrives at MVM’s kernel, the LKM ﬁrst veriﬁes
whether hid has been updated by the Filter and then logs the ID and parameter
values of the injected hypercall.
4.2 hInjector Design Criteria
Injection of Realistic Attacks. The injection of realistic attacks is crucial for
the representative IDS evaluation. In order to inject realistic hypercall attacks,
hInjector requires representative hypercall attack models. hInjector supports the
injection of attacks crafted with respect to arbitrary attack models, for example,
the models that we developed [5] (see Sect. 2).
We developed proof-of-concept code for triggering the hypercall vulnerabili-
ties that we analyzed [5].4 The proof-of-concept code enables granularization of
the attack models. For example, we can specify speciﬁc parameter values or the
order of a series of hypercalls that trigger a hypercall vulnerability. This enables
the injection of realistic hypercall attacks, crafted to trigger publicly disclosed
hypercall vulnerabilities. In Fig. 3a, we show how we triggered the vulnerabil-
ity CVE-2012-3495 of the Xen hypervisor in a testbed environment. In Fig. 3b,
we present the conﬁguration of hInjector for injecting an attack triggering CVE-
2012-3495. Conﬁguration ﬁles for injecting attacks that trigger publicly disclosed
hypercall vulnerabilities are distributed with hInjector.
Injection During Regular System Operation. Benign activities, mixed with
attacks, are needed to subject an IDS under test to realistic attack scenarios.
hInjector is designed to inject hypercall attacks during regular operation of guest
VMs. Thus, provided that during an IDS evaluation experiment representative
user tasks run in the VMs in the IDS monitoring landscape, the presence of
representative benign hypercall activities is guaranteed.
4 We developed proof-of-concept code based on reverse-engineering the released
patches ﬁxing the considered vulnerabilities.
Evaluation of Intrusion Detection Systems in Virtualized Environments
481
Fig. 3. (a) Triggering CVE-2012-3495 [the hypercall physdev op is executed 18 times:
the value of its ﬁrst parameter is 23 (PHYSDEVOP get free pirq); the value of the ﬁeld
type of its second parameter (struct physdev get free pirq) is 1]; (b) Conﬁguration of
hInjector for injecting an attack triggering CVE-2012-3495
Non-disruptive Attack Injection. The state of the hypervisor or the VM(s)
from where attacks are injected may be altered by the attacks injected by hIn-
jector. This may cause crashes obstructing the execution of the IDS evaluation
process. Filter prevents crashes by blocking the execution of the hypervisor’s
handlers that handle the injected hypercalls. This preserves the states of the
hypervisor and of the VM(s) from where attacks are injected, and, in addition,
it ensures that injected attacks do not impact the operation of the IDS under
test, which normally has components in the hypervisor and in a VM (see Sect. 2).
After blocking the execution of hypervisor’s handlers, Filter returns valid error
codes. This allows the control ﬂow of the kernel of the VM from where hypercall
attacks are injected to properly handle failed hypercalls that have been executed
by it and have been modiﬁed by the Injector on-the-ﬂy.
4.3 Injector: Performance Overhead
The rate at which the kernel invokes hypercalls is high (i.e., in some cases more
than 30000 hypercalls per second, see Sect. 5). Therefore, Injector, which manip-
ulates hypercalls on-the-ﬂy, can easily incur intolerable system performance over-
head. We made the following observation when developing Injector: manipulating
orders of series of hypercalls is very performance-expensive; therefore, Injector
can manipulate only hypercall parameter values. Further, we measured the over-
head incurred by Injector on the execution rate of hypercalls, relative to this rate
when Injector is inactive, when replacing regular hypercall parameter values with
random, irregular values. In Fig. 4, we depict this overhead, which we measured
as follows. We deployed Injector in the kernel of a Debian 8.0 operating system
running on top of Xen 4.4.5. We invoked the mmuext op hypercall 40000 times
using a loadable kernel module. We measured the time, in microseconds (μs),
needed for the invoked hypercalls to complete their operation (‘Execution time’
in Fig. 4) in scenarios where: (i) Injector is inactive (‘Base’ in Fig. 4), and (ii)
Injector manipulates the value of the second parameter of mmuext op at the
482
A. Milenkoski et al.
rate of 1:50 (i.e., Injector manipulates parameter value once in 50 invocations of
mmuext op), 1:100, 1:500, 1:1000, and 1:10000. We repeated the measurements
30 times and averaged the results.
Based on the results from the above experiment, we conclude that a user
should constrain the rate at which Injector manipulates hypercall parameter
values to a value such that the incurred overhead is not higher than 2 %. This is
important since we observed that overheads higher than 2 % often cause notice-
able system slowdowns or crashes. We showed that Injector normally incurs
overheads higher than 2 % when it manipulates hypercall parameter values
approximately once in less than 500 hypercall invocations (see Fig. 4). Note
that overheads incurred by Injector for hypercalls other than mmuext op do
not signiﬁcantly diﬀer from those depicted in Fig. 4 since the implementation of
Injector is the same for all hypercalls.
)
s
µ
(
e
m
i
t
n
o
i
t
u
c
e
x
E
2400
1600
800
[10 %]
[4.953 %]
[1.606 %]
[0.395 %]
[0.257 %]
Base
1:50
1:100
1:500
1:1000
1:10000
Fig. 4. Overhead incurred by Injector [measurements of the incurred overhead are
depicted in square brackets]
5 Case Study
We now demonstrate the application of our approach by evaluating Xenini [3]
following the steps presented in Sect. 3. Xenini is a representative anomaly-based
IDS. It uses the popular Stide [16] method. Xenini slides a window of size k over
a sequence of n hypercalls and identiﬁes mismatches (anomalies) by comparing
each k-length sequence with regular patterns learned during IDS training. Xenini
records the number of mismatches as a percentage of the total possible number
of pairwise mismatches for a sequence of n hypercalls (i.e., (k − 1)(n − k/2)).
We call this percentage anomaly score. When the anomaly score exceeds a given
threshold th ∈ [0; 1], Xenini ﬁres an alert. For the purpose of this study, we con-
ﬁgured Xenini such that its detection-relevant property is sequences of hypercall
IDs of length 4 (i.e., k = 4; n = 10).
It is important to emphasize that we focus on demonstrating the feasibility
of attack injection in virtualized environments for IDS testing purposes and not
on discussing the behavior of Xenini in detail or comparing it with other IDSes.
We specify arbitrary attack injection scenarios and evaluate Xenini with the sole
purpose of demonstrating all steps and functionalities of the proposed approach.
We refer the reader to Sect. 5.3 for an overview of further application scenarios.
Evaluation of Intrusion Detection Systems in Virtualized Environments
483
5.1 Case Study: Planning
Speciﬁcation of an IDS Monitoring Landscape. We use the SPECvirt
sc2013 benchmark to specify an IDS monitoring landscape.5 SPECvirt sc2013 is
an industry-standard virtualization benchmark developed by SPEC (Standard
Performance Evaluation Corporation). Its complex architecture matches a typ-
ical server consolidation scenario in a datacenter — it consists of 6 co-located
front- and back-end server VMs (i.e., web, network ﬁle, mail, batch, application,
and database server VM) and 4 workload drivers that act as clients generating
workloads for the front-end servers. The workload drivers are heavily modiﬁed
versions of the drivers of the SPECweb 2005, SPECimap, SPECjAppServer2004,
and SPECbatch (i.e., SPEC CPU 2006) benchmarks. They generate workloads
representative of workloads seen in production virtualized environments.
In Fig. 5, we depict the deployment of SPECvirt sc2013 as an IDS monitoring
landscape. The workload drivers generate workloads that map to hypercalls. We
used Xen 4.4.1 as hypervisor and we virtualized the VMs using full paravirtu-
alization.6 To each server VM, we allocated 8 virtual CPUs pinned to separate
physical CPU cores of 2 GHz, 3 GB of main memory, and 100 GB of hard disk
memory. In Fig. 5, we depict the operating systems and architectures of the
server VMs, and the server software we deployed in the VMs.7
SPECweb 2005 
workload driver
SPECimap 
workload driver
SPECjAppServer2004