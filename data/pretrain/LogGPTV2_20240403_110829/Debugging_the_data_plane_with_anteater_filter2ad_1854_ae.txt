runtime leaves room for improvement. However, using con-
trol plane analysis in place of Anteater does not address this
problem, as the invariants of interest are computationally
diﬃcult (see Appendix) regardless of whether the informa-
tion is represented at the control or data plane. It’s unclear
whether one approach can be fundamentally faster; diﬀer-
ences may come down to the choice of which invariants to
test, and implementation details. However, we note that
the data plane analysis approach may be easier because un-
like control plane analysis, it need not predict future system
inputs or dynamic protocol convergence.
Extending Anteater to handle more general properties. The
generality of boolean satisﬁability enables Anteater to han-
dle other types of network properties beyond those presented
in this paper. For example, Anteater could model network
latency by introducing a new ﬁeld in the symbolic packet to
record the packet’s total latency, and increasing it at each
hop according to the link’s latency using our packet trans-
formation algorithms. (The SAT solver we used supports
arithmetic operations such as +,−,≤ that would be useful
for representing network behavior and constraints involving
latency.)
Of course, some bugs are beyond Anteater’s reach, such as
those that have no eﬀect on the contents of forwarding state.
That includes some hardware failures (e.g., corrupting the
contents of the packet during forwarding), and conﬁguration
issues that do not aﬀect the FIB.
7. RELATED WORK
Static analysis of the data plane. The research most closely
related to Anteater performs static analysis of data plane
protocols. Xie et al. [39] introduced algorithms to check
reachability in IP networks with support for ACL policies.
Their design was a theoretical proposal without an imple-
mentation or evaluation. Anteater uses this algorithm, but
we show how to make it practical by designing and imple-
menting our own algorithms to use reachability to check
meaningful network invariants, developing a system to make
these algorithmically complex operations (see the Appendix)
tractable, and using Anteater on a real network to ﬁnd 23
real bugs. Xie et al. also propose an algorithm for handling
packet transformations. However, their proposal did not
handle fully general transformations, requiring knowledge of
an inverse transform function and only handling non-loopy
paths. Our novel algorithm handles arbitrary packet trans-
formations (without needing the inverse transform). This
299
distinction becomes important for practical protocols that
can cause packets to revisit the same node more than once
(e.g., MPLS Fast Reroute).
Roscoe et al. [33] proposed predicate routing to unify the
notions of both routing and ﬁrewalling into boolean ex-
pressions, Bush and Griﬃn [9] gave a formal model of in-
tegrity (including connectivity and isolation) of virtual pri-
vate routed networks, and Hamed et al. [19] designed algo-
rithms and a system to identify policy conﬂicts in IPSec,
demonstrating bug-ﬁnding eﬃcacy in a user study. In con-
trast, Anteater is a general framework that can be used to
check many protocols, and we have demonstrated that it can
ﬁnd bugs in real deployed networks.
Static analysis of control plane conﬁguration. Analyzing
conﬁgurations of the control plane, including routers [6, 14]
and ﬁrewalls [2, 5, 43], can serve as a sanity check prior
to deployment. As discussed in the introduction, conﬁgura-
tion analysis has two disadvantages. First, it must simulate
the behavior of the control plane for the given conﬁgura-
tion, making these tools protocol-speciﬁc; indeed, the task of
parsing conﬁgurations is non-trivial and error-prone [26, 41].
Second, conﬁguration analysis will miss non-conﬁguration
errors (e.g., errors in router software and inconsistencies be-
tween the control plane and data plane [18, 27, 41]; see our
study of such errors in §5.2).
However, conﬁguration analysis has the potential to de-
tect bugs before a new conﬁguration is deployed. Anteater
can detect bugs only once they have aﬀected the data plane
— though, as we have shown, there are subtle bugs that fall
into this category (e.g., router implementation bugs, copy-
ing wrong conﬁgurations to routers) that only a data plane
analysis approach like Anteater can detect. Control plane
analysis and Anteater are thus complementary.
Intercepting control plane dynamics. Monitoring the dy-
namics of the control plane can detect a broad class of fail-
ures [16, 20] with little overhead, but may miss bugs that
only aﬀect the data plane. As above, the approach is com-
plementary to ours.
Traﬃc monitoring. Traﬃc monitoring is widely used to de-
tect network anomalies as they occur [4, 29, 35, 37]. Anteater’s
approach is complementary:
it can provably detect or rule
out certain classes of bugs, and it can detect problems that
are not being triggered by currently active ﬂows or that do
not cause a statistical anomaly in aggregate traﬃc ﬂow.
SAT solving in other settings. Work on model checking,
hardware veriﬁcation and program analysis [7, 40, 42] of-
ten encounter problems that are NP-Complete. They are
often reduced into SAT problems so that SAT solvers can
solve them eﬀectively in practice. This work inspired our
approach of using SAT solving to model and analyze data-
plane behavior.
8. CONCLUSION
We presented Anteater, a practical system for ﬁnding bugs
in networks via data plane analysis. Anteater collects data
plane information from network devices, models data plane
behavior as instances of satisﬁability problems, and uses for-
mal analysis techniques to systematically analyze the net-
work. To the best of our knowledge, Anteater is the ﬁrst
design and implementation of a data plane analysis system
used to ﬁnd real bugs in real networks.
We ran Anteater on our campus network and uncovered
23 bugs. Anteater helped our network operators improve
the reliability of the campus network. Our study suggests
that analyzing data plane information could be a feasible
approach to assist debugging today’s networks.
Acknowledgements
We would like to thank our shepherd, Emin G¨un Sirer, and
the anonymous reviewers for their valuable comments. We
also thank our network operator Debbie Fligor for collecting
data and sharing her operational experience. This research
was funded by NSF grants CNS 0834738, CNS 0831212, CNS
1040396, and CNS 1053781, grant N0014-09-1-0743 from the
Oﬃce of Naval Research, AFOSR MURI grant FA9550-09-
01-0539, a grant from the Internet Services Research Center
(ISRC) of Microsoft Research, and a Fulbright S&T Fellow-
ship.
9. REFERENCES
[1] JUNOS: MPLS fast reroute solutions, network operations
guide. 2007.
[2] E. S. Al-Shaer and H. H. Hamed. Discovery of policy
anomalies in distributed ﬁrewalls. In Proc. IEEE
INFOCOM, 2004.
[3] Apple. What is lights out management?, September 2010.
http://support.apple.com/kb/TA2456.
[4] F. Baccelli, S. Machiraju, D. Veitch, and J. Bolot. The role
of PASTA in network measurement. In Proc. ACM
SIGCOMM, 2006.
[5] Y. Bartal, A. Mayer, K. Nissim, and A. Wool. Firmato: A
novel ﬁrewall management toolkit. In Proc. IEEE S&P,
1999.
[6] T. Benson, A. Akella, and D. Maltz. Unraveling the
complexity of network management. In Proc. USENIX
NSDI, 2009.
[7] A. Biere, A. Cimatti, E. M. Clarke, and Y. Zhu. Symbolic
model checking without BDDs. In Proc. TACAS, 1999.
[8] R. Brummayer and A. Biere. Boolector: An eﬃcient smt
solver for bit-vectors and arrays. In Proc. TACAS, 2009.
[9] R. Bush and T. G. Griﬃn. Integrity for virtual private
routed networks. In Proc. IEEE INFOCOM, 2003.
[10] Cisco Systems Inc. Spanning tree protocol problems and
related design considerations.
http://www.cisco.com/en/US/tech/tk389/tk621/
technologies_tech_note9186a8951ac.shtml, August
2005. Document ID 10556.
[11] J. Duﬀy. BGP bug bites Juniper software. Network World,
December 2007.
[12] J. Evers. Trio of Cisco ﬂaws may threaten networks. CNET
News, January 2007.
[13] D. Farinacci, T. Li, S. Hanks, D. Meyer, and P. Traina.
Generic Routing Encapsulation (GRE). RFC 2784, March
2000.
[14] N. Feamster and H. Balakrishnan. Detecting BGP
conﬁguration faults with static analysis. In Proc. USENIX
NSDI, 2005.
[15] N. Feamster and J. Rexford. Network-wide prediction of
BGP routes. IEEE/ACM Transactions on Networking,
15:253–266, 2007.
[16] A. Feldmann, O. Maennel, Z. Mao, A. Berger, and
B. Maggs. Locating Internet routing instabilities. In Proc.
ACM SIGCOMM, 2004.
[17] D. Geels, G. Altekar, P. Maniatis, T. Roscoe, and I. Stoica.
Friday: Global comprehension for distributed replay. In
Proc. USENIX NSDI, 2007.
[18] G. Goodell, W. Aiello, T. Griﬃn, J. Ioannidis,
P. McDaniel, and A. Rubin. Working around BGP: An
300
incremental approach to improving security and accuracy of
interdomain routing. In Proc. NDSS, 2003.
[19] H. Hamed, E. Al-Shaer, and W. Marrero. Modeling and
veriﬁcation of IPSec and VPN security policies. In Proc.
ICNP, 2005.
[20] X. Hu and Z. M. Mao. Accurate real-time identiﬁcation of
IP preﬁx hijacking. In Proc. IEEE S&P, 2007.
[21] Intel. The all new 2010 Intel Core vPro processor family:
Intelligence that adapts to your needs, 2010.
http://www.intel.com/Assets/PDF/whitepaper/31171.pdf.
[22] M. Lasserre and V. Kompella. Virtual private LAN service
(VPLS) using label distribution protocol (LDP) signaling.
RFC 4762, January 2007.
[23] C. Lattner and V. Adve. LLVM: A compilation framework
for lifelong program analysis & transformation. In Proc.
CGO, 2004.
[24] X. Liu, Z. Guo, X. Wang, F. Chen, X. Lian, J. Tang,
M. Wu, M. F. Kaashoek, and Z. Zhang. D3S: Debugging
deployed distributed systems. In Proc. USENIX NSDI,
2008.
[25] R. Mahajan, D. Wetherall, and T. Anderson.
Understanding BGP misconﬁguration. In Proc. ACM
SIGCOMM, 2002.
[26] Y. Mandelbaum, S. Lee, and D. Caldwell. Adaptive parsing
of router conﬁguration languages. In Workshop INM, 2008.
[27] Z. M. Mao, D. Johnson, J. Rexford, J. Wang, and R. Katz.
Scalable and accurate identiﬁcation of AS-level forwarding
paths. In Proc. IEEE INFOCOM, 2004.
[28] N. McKeown, T. Anderson, H. Balakrishnan, G. Parulkar,
L. Peterson, J. Rexford, and S. Shenker. OpenFlow:
Enabling innovation in campus networks. ACM CCR, April
2008.
[29] Nagios. http://www.nagios.org.
[30] Quagga Routing Suite. http://www.quagga.net.
[31] Quagga Routing Suite. Commercial Resources.
http://www.quagga.net/commercial.php.
[32] Renesys. Longer is not always better. http://www.renesys.
com/blog/29/2/longer-is-not-better.shtml.
[33] T. Roscoe, S. Hand, R. Isaacs, R. Mortier, and
P. Jardetzky. Predicate routing: Enabling controlled
networking. ACM CCR, January 2003.
[34] Ruby-Prolog.
https://rubyforge.org/projects/ruby-prolog.
[35] F. Silveira, C. Diot, N. Taft, and R. Govindan. ASTUTE:
Detecting a diﬀerent class of traﬃc anomalies. In Proc.
ACM SIGCOMM, 2010.
[36] N. Spring, R. Mahajan, and D. Wetherall. Measuring ISP
topologies with rocketfuel. In Proc. ACM SIGCOMM, 2002.
[37] P. Tune and D. Veitch. Towards optimal sampling for ﬂow
size estimation. In Proc. IMC, 2008.
[38] J. Wu, Z. M. Mao, J. Rexford, and J. Wang. Finding a
needle in a haystack: Pinpointing signiﬁcant BGP routing
changes in an IP network. In Proc. USENIX NSDI, 2005.
[39] G. G. Xie, J. Zhan, D. A. Maltz, H. Zhang, A. Greenberg,
G. Hjalmtysson, and J. Rexford. On static reachability
analysis of IP networks. In Proc. IEEE INFOCOM, 2005.
[40] Y. Xie and A. Aiken. Saturn: A scalable framework for
error detection using boolean satisﬁability. Proc. ACM
TOPLAS, 29(3), 2007.
[41] Z. Yin, M. Caesar, and Y. Zhou. Towards understanding
bugs in open source router software. ACM CCR, June 2010.
[42] D. Yuan, H. Mai, W. Xiong, L. Tan, Y. Zhou, and
S. Pasupathy. SherLog: Error diagnosis by connecting clues
from run-time logs. In ASPLOS, 2010.
[43] L. Yuan, J. Mai, Z. Su, H. Chen, C.-N. Chuah, and
P. Mohapatra. FIREMAN: A toolkit for FIREwall
Modeling and ANalysis. In Proc. IEEE S&P, 2006.
[44] E. Zmijewski. Reckless driving on the Internet.
http://www.renesys.com/blog/29/2/
the-flap-heard-around-the-worl.shtml, February 2009.
Appendix
In this appendix, we discuss the complexity of the basic problem
of determining reachability in a network given its data plane state.
The diﬃculty of determining reachability depends strongly on
what functions we allow the data plane to perform. If network
devices implement only IP-style longest preﬁx match forwarding
on a destination address, it is fairly easy to show that reachability
can be decided in polynomial time. However, if we augment the
data plane with richer functions, the problem quickly becomes
diﬃcult. As we show below, packet ﬁlters make reachability NP-
Complete; and of course, reachability is undecidable in the case
of allowing arbitrary programs in the data plane.
It is useful to mention how this complexity relates to the ap-
proach of Xie et al. [39], whose reachability algorithm is essen-
tially the same as ours, but written in terms of set union/inter-
section operations rather than SAT. As pointed out in [39], even
with packet ﬁlters, the reachability algorithm terminates within
O(V 3) operations. However, this algorithm only calculates a for-
mula representing reachability, and does not evaluate whether
that formula is satisﬁable.
In [39], it was assumed that evalu-
ating the formula (via set operations in the formulation of [39])
would be fast. This may be true in many instances, but in the
general case deciding whether one vertex can reach another in the
presence of packet ﬁlters is not in O(V 3), unless P = NP. Thus,
to handle the general case, the use of SAT or similar techniques
is required since the problem is NP-complete. We choose to use
an existing SAT solver to leverage optimizations for determining
satisﬁability.
We now describe in more detail how packet ﬁlters make reach-
ability NP-Complete. The input to the reachability problem con-
sists of a directed graph G = (V, E), the boolean policy function
Q(e, p) which returns true when packet p can pass along edge e,
and two vertices s, t ∈ V . The problem is to decide whether there
exists a packet p and an s ❀ t path in G, such that Q(e, p) = true
for all edges e along the path. (Note this problem deﬁnition does
not allow packet transformations.) To complete the deﬁnition of
the problem, we must specify what sort of packet ﬁlters the pol-
icy function Q can represent. We could allow the ﬁlter to be any
boolean expression whose variables are the packet’s ﬁelds. In this
case, the problem can trivially encode arbitrary SAT instances
by using a given SAT formula as the policy function along a sin-
gle edge s → t, with no other nodes or edges in the graph, with
the SAT formula’s variables being the packet’s ﬁelds. Thus, that
formulation of the reachability problem is NP-Complete.
One might wonder whether a simpler, more restricted deﬁnition
of packet ﬁlters makes the problem easy. We now show that even
when Q for each edge is a function of a single bit in the packet
header, the problem is still NP-complete because the complexity
can be encoded into the network topology.
Proposition 1. Deciding reachability in a network with single-
bit packet ﬁlters is NP-Complete.
Proof. Given a packet and a path through the network, since
the length of the path must be < |V |, we can easily verify in
polynomial time whether the packet will be delivered. Therefore
the problem is in NP.
To show NP-hardness, suppose we are given an instance of a
3-SAT problem with n binary variables x1, . . . , xn and k clauses
C1, . . . , Ck. Construct an instance of the reachability problem as
follows. The packet will have n one-bit ﬁelds corresponding to the
n variables xi. We create k + 1 nodes v0, v1, . . . , vk, and we let
s = v0 and t = vk. For each clause Ci, we add three parallel edges
ei1, ei2, ei3 all spanning vi−1 → vi. If the ﬁrst literal in clause Ci
is some variable xi, then the policy function Q(ei1, p) = true if
and only if the ith bit of p is 1; otherwise the ﬁrst literal in Ci is
the negated variable xi, and we let Q(ei1, p) = true if and only
if the ith bit of p is 0. The policy functions for ei2 and ei3 are
constructed similarly based on the second and third literals in Ci.
With the above construction a packet p can ﬂow from vi−1
to vi if and only if Ci evaluates to true under the assignment
corresponding to p. Therefore, p can ﬂow from s to t if and only if
all 3-SAT clauses are satisﬁed. Thus, since 3-SAT is NP-complete,
reachability with single-bit packet ﬁlters is NP-complete.
301