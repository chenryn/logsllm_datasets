angr.exploration_techniques 下：
Explorer ：该技术实现了 .explore() 功能，允许在探索时查找或避免某
些地址。
DFS ：深度优先搜索，每次只探索一条路径，其它路径会放到 deferred
stash 中。直到当前路径探索结束，再从 deferred 中取出最长的一条继续
探索。
LoopLimiter ：限制路径的循环次数，超出限制的路径将被放到 discard
stash 中。
LengthLimiter ：限制路径的最大长度
ManualMergepoint ：将程序中的某个地址标记为合并点，将在一定时间范
围内到达的所有 state 合并在一起。
Veritesting ：是这篇论文的实现，试图识别出有用的合并点来解决路径爆
炸问题。在创建 SimulationManager 时通过 veritesting=True 来开启。
Tracer ：记录在某个具体输入下的执行路径，结果是执行完最后一个 basic
block 的 state，存放在 traced stash 中。
Oppologist ：当遇到某个不支持的指令时，它将具体化该指令的所有输入
并使用 unicorn engine 继续执行。
Threading ：将线程级并行添加到探索过程中。
796
5.3.1 angr
Spiller ：当处于 active 的 state 过多时，将其中一些转存到磁盘上以保持
较低的内存消耗。
VEX IR 翻译器
angr 使用了 VEX 作为二进制分析的中间表示。VEX IR 是由 Valgrind 项目开发和
使用的中间表示，后来这一部分被分离出去作为 libVEX，libVEX 用于将机器码转
换成 VEX IR（更多内容参考章节5.2.3）。在 angr 项目中，开发了模块 PyVEX 作
为 libVEX 的 Python 包装。当然也对 libVEX 做了一些修改，使其更加适用于程序
分析。
一些用法如下：
>>> import pyvex, archinfo
>>> bb = pyvex.IRSB('\xc3', 0x400400, archinfo.ArchAMD64()) # 将
一个位于 0x400400 的 AMD64 基本块（\xc3，即ret）转成 VEX
>>> bb.pp() # 打印 IRSB（Intermediate Representation Super Bl
ock）
IRSB {
t0:Ity_I64 t1:Ity_I64 t2:Ity_I64 t3:Ity_I64
00 | ------ IMark(0x400400, 1, 0) ------
01 | t0 = GET:I64(rsp)
02 | t1 = LDle:I64(t0)
03 | t2 = Add64(t0,0x0000000000000008)
04 | PUT(rsp) = t2
05 | t3 = Sub64(t2,0x0000000000000080)
06 | ====== AbiHint(0xt3, 128, t1) ======
NEXT: PUT(rip) = t1; Ijk_Ret
}
>>> bb.statements[3] # 表达式
>>> bb.statements[3].pp()
t2 = Add64(t0,0x0000000000000008)
>>> bb.statements[3].data # 数据
>>> bb.statements[3].data.pp()
797
5.3.1 angr
Add64(t0,0x0000000000000008)
>>> bb.statements[3].data.op # 操作符
'Iop_Add64'
>>> bb.statements[3].data.args # 参数
[, ]
>>> bb.statements[3].data.args[0]
>>> bb.statements[3].data.args[0].pp()
t0
>>> bb.next # 基本块末尾无条件跳转的目标
>>> bb.next.pp()
t1
>>> bb.jumpkind # 无条件跳转的类型
'Ijk_Ret'
到这里 angr 的核心概念就介绍得差不多了，更多更详细的内容还是推荐查看官方
教程和 API 文档。另外在我的博客里有 angr 源码分析的笔记。
扩展工具
由于 angr 强大的静态分析和符号执行能力，我们可以在 angr 之上开发其他的一些
工：
angrop：rop 链自动化生成器
Patcherex：二进制文件自动化 patch 引擎
Driller：用符号执行增强 AFL 的下一代 fuzzer
Rex：自动化漏洞利用引擎
CTF 实例
查看章节 6.2.3、6.2.8。
798
5.3.1 angr
参考资料
angr.io
docs.angr.io
angr API documentation
The Art of War:Offensive Techniques in Binary Analysis
799
5.3.2 Triton
5.3.2 Triton
参考资料
参考资料
Triton - A DBA Framework
800
5.3.3 KLEE
5.3.3 KLEE
参考资料
参考资料
KLEE LLVM Execution Engine
801
5.3.4 S²E
5.3.4 S²E
参考资料
参考资料
S²E: A Platform for In-Vivo Analysis of Software Systems
802
5.4 数据流分析
5.4 数据流分析
基本原理
方法实现
实例分析
基本原理
数据流分析是一种用来获取相关数据沿着程序执行路径流动的信息分析技术。分析
对象是程序执行路径上的数据流动或可能的取值。
数据流分析的分类
根据对程序路径的分析精度分类：
流不敏感分析（flow insensitive）：不考虑语句的先后顺序，按照程序语句的
物理位置从上往下顺序分析每一语句，忽略程序中存在的分支
流敏感分析（flow sensitive）：考虑程序语句可能的执行顺序，通常需要利用
程序的控制流图（CFG）
路径敏感分析（path sensitive）：不仅考虑语句的先后顺序，还对程序执行路
径条件加以判断，以确定分析使用的语句序列是否对应着一条可实际运行的程
序执行路径
根据分析程序路径的深度分类：
过程内分析（intraprocedure analysis）：只针对程序中函数内的代码
过程间分析（inter-procedure analysis）：考虑函数之间的数据流，即需要跟
踪分析目标数据在函数之间的传递过程
上下文不敏感分析（context-insensitive）：将每个调用或返回看做一个
“goto” 操作，忽略调用位置和函数参数取值等函数调用的相关信息
上下文敏感分析（context-sensitive）：对不同调用位置调用的同一函数
加以区分
检测程序漏洞
803
5.4 数据流分析
由于一些程序漏洞的特征恰好可以表现为特定程序变量在特定的程序点上的性质、
状态或取值不满足程序安全的规定，因此数据流分析可以直接用于检测这些漏洞。
例如指针变量二次释放的问题：
free(p);
[...]
free(p);
使用数据流分析跟踪指针变量的状态，当指针 p 被释放时，记录指针变量 p 的状态
为已释放，当再次遇到对 p 的释放操作时，对 p 的状态进行检查。
有时还要考虑变量的别名问题，例如下面这样：
p = q;
free(q);
[...]
*p = 1;
这时就需要建立别名关系信息来辅助分析。
再看一个数组越界的问题：
a[i] = 1;
使用数据流分析方法一方面记录数组 a 的长度，另一方面分析变量 i 的取值，并进
行比较，以判断数据的访问是否越界。
strcpy(x, y);
记录下变量 x 被分配空间的大小和变量 y 的长度，如果前者小于后者，则判断存在
缓冲区溢出。
总的来说，基于数据流的源代码漏洞分析的原理如下图所示：
804
5.4 数据流分析
代码建模
该过程通过一系列的程序分析技术获得程序代码模型。首先通过词法分析
生成词素的序列，然后通过语法分析将词素组合成抽象语法树。如果需要
三地址码，则利用中间代码生成过程解析抽象语法树生成三地址码。如果
采用流敏感或路径敏感的方式，则可以通过分析抽象语法树得到程序的控
制流图。构造控制流图的过程是过程内的控制流分析过程。控制流还包含
分析各个过程之间的调用关系的部分。通过分析过程之间的调用关系，还
可以构造程序的调用图。另外，该过程还需要一些辅助支持技术，例如变
量的别名分析，Java 反射机制分析，C/C++ 的函数指针或虚函数调用分
析等。
程序代码模型
漏洞分析系统通常使用树型结构的抽象语法树或者线性的三地址码来描述
程序代码的语义。控制流图描述了过程内程序的控制流路径，较为精确的
数据流分析通常利用控制流图分析程序执行路径上的某些行为。调用图描
述了过程之间的调用关系，是过程间分析需要用到的程序结构。
漏洞分析规则
漏洞分析规则是检测程序漏洞的依据。对于分析变量状态的规则，可以使
用状态自动机来描述。对于需要分析变量取值的情况，则需要指出应该怎
样记录变量的取值，以及在怎样的情况下对变量的取值进行何种的检测。
静态漏洞分析
数据流分析可以看做一个根据检测规则在程序的可执行路径上跟踪变量的
状态或者变量取值的过程。在该过程中，如果待分析的程序语句是函数调
用语句，则需要利用调用图进行过程间的分析，以分析被调用函数的内部
805
5.4 数据流分析
代码。另外，数据流分析还可以作为辅助技术，用于完善程序调用图和分
析变量别名等。
处理分析结果
对检测出的漏洞进行危害程度分类等。
方法实现
程序代码模型
数据流分析使用的程序代码模型主要包括程序代码的中间表示以及一些关键的数据
结构，利用程序代码的中间表示可以对程序语句的指令语义进行分析。
抽象语法树（AST）是程序抽象语法结构的树状表现形式，其每个内部节点代表一
个运算符，该节点的子节点代表这个运算符的运算分量。通过描述控制转移语句的
语法结构，抽象语法树在一定程度上也描述了程序的过程内代码的控制流结构。
举个例子，辗转相除法的算法描述和抽象语法树如下：
while b ≠ 0
if a > b
a := a − b
else
b := b − a
return a
806
5.4 数据流分析
三地址码（TAC）由一组类似于汇编语言的指令组成，每个指令具有不多于三个的
运算分量。每个运算分量都像是一个寄存器。
通常的三地址码指令包括下面几种：
x = y op z ：表示 y 和 z 经过 op 指示的计算将结果存入 x
x = op y ：表示运算分量 y 经过操作 op 的计算将结果存入 x
x = y ：表示赋值操作
goto L ：表示无条件跳转
if x goto L ：表示条件跳转
x = y[i] ：表示数组赋值操作
x = &y 、 x = *y ：表示对地址的操作
807
5.4 数据流分析
param x1
param x2
call p
表示过程调用 p(x1, x2)
举个例子：
for (i = 0; i = 10 goto L2 ; conditional jump
t2 := t1 * t1 ; square of i
t3 := t1 * 4 ; word-align address
t4 := b + t3 ; address to store i*i
*t4 := t2 ; store through pointer
t1 := t1 + 1 ; increase i
goto L1 ; repeat loop
L2:
静态单赋值形式（SSA）是一种程序语句或者指令的表示形式，在这种表示形式
中，所有的赋值都是针对具有不同名字的变量，也就是说，如果某个变量在不同的
程序点被赋值，那么在这些程序点上，该变量在静态单赋值形式的表示中应该使用
不同的名字。在使用下标的赋值表示中，变量的名字用于区分程序中的不同的变
量，下标用于区分不同程序点上变量的赋值情况。另外，如果在一个程序中，同一
个变量可能在两个不同的控制流路径中被赋值，并且在路径交汇后，该变量被使
用，那么就需要一种被称为 Φ 函数的的表示规则将变量的赋值合并起来。
看下面这个例子：
808
5.4 数据流分析
通过 Φ 函数在最后一个区块的起始产生一个新的定义 y3，这样程序就会根据具体
的运行路径来选择是 y1 还是 y2，而在最后一个区块中，仅需要使用 y3，即可得到
正确的数值。
静态单赋值形式对于数据流分析的意义在于，可以简单而直接地发现变量的赋值和
使用情况，以此分析数据的流向并发现程序不安全的行为。
控制流图（CFG）通常是指用于描述程序过程内的控制流的有向图。控制流由节点
和有向边组成。典型的节点是基本块（BB），即程序语句的线性序列。有向边表示
节点之间存在潜在的控制流路径，通常都带有属性（如if语句的true分支和false分
支）。
看几个例子：
809
5.4 数据流分析
(a)：一个 if-then-else 语句
(b)：一个 while 循环
(c)：有两个出口的自然环路（natural loop），例如一个有 if 语句的 while 循
环，非结构化但可以简化
(d)：有两个入口的循环，例如 goto 到一个 while 或者 for 循环里，不可简化
调用图（CG）是描述程序中过程之间的调用和被调用关系的有向图。控制图是一
个节点和边的集合，并满足如下原则：
对程序中的每个过程都有一个节点
对每个调用点都有一个节点
如果调用点 c 调用了过程 p，就存在一条从 c 的节点到 p 的节点的边
程序建模
程序建模包括代码解析和辅助分析两个部分。其中代码解析过程是指词法分析、语
法分析、中间代码生成以及过程内的控制流分析等基础的分析过程。辅助分析主要
包括控制流分析等为数据流分析提供支持的分析过程。
810
5.4 数据流分析
在代码解析过程中，词法分析读入源程序输出词素序列，每个词素对应一个词法单
元，语法分析使用词法单元的第一个分量来创建抽象语法树，中间代码生成过程将
抽象语法树转化为三地址码，而三地址码常表示为静态单赋值形式。编译器在源代
码编译过程中得到的中间表示及其他的数据结构可以很好地为检测程序漏洞的数据
流分析所用。因此，一些分析系统将相应的代码编译器实现的某些过程或者代码解
析组件作为分析系统的前端，利用这些过程或者组件获得所需的数据结构，完成堆
程序源代码的解析。然而，对于解释型语言或者脚本语言编写的程序，程序代码直
接被解释器解释执行，没有相应的编译器实现对程序代码的基本解析。这时，我们
需要在分析系统中设计完成代码解析的各个部分。而对于某些语言如 Java，其编译
后得到的中间程序被相应的虚拟机执行。这时，分析系统可以分析这个中间程序，
即 .class 文件。
在辅助分析过程中，通过过程内的程序流分析可以构建过程的控制流图。如果分析
系统选择使用抽象语法树作为中间表示，可以尝试在抽象语法树中增加控制流的
边。如果选择三地址码作为中间表示，则需要分析其中的控制转移语句构建控制流
图，具体过程如下：首先逐句分析程序指令或者指令，识别其中的控制转移语句，