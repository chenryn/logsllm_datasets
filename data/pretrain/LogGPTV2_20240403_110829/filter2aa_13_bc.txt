第四步：使用jdb命令启动连接attach调试器：
但是这里可能会出现这样的错误：
这是因为8700端口没有指定，这时候可以通过Eclipse的DDMS进行端口查看，如图23-8所示。
图23-8 查看进程调试端口
这里是8600端口，但是基本端口8700不在。有两种处理方式，一种方式是把上面的命令的端口改成8600，还有一种方式是选中这个应用，使其具有8700端口，如图23-9所示。
图23-9 设置8700端口
点击这个条目即可，这时候再运行上面的jdb命令：
处于等待状态。
第五步：给dvmDexFileOpenPartial函数下断点。
使用一个IDA静态分析得到这个函数的相对地址43308，如下所示：
在动态调试的IDA中进行解密，使用Ctrl+S键找到libdvm.so在内存中的基地址41579000，如图23-10所示。
图23-10 函数的基地址
然后将两者相加得到绝对地址43308+41579000=415BC308，使用G键，跳转，如图23-11所示。
图23-11 跳转到绝对地址
跳转到dvmDexFileOpenPartial函数处，下断点，如下所示：
第六步：点击运行按钮或者F9键运行程序。
之前的jdb命令就连接上了：
IDA出现一些提示界面，不要理会，一路点击Cancel按钮即可，如图23-12所示。
图23-12 加载so文件对话框
运行到了dvmDexFileOpenPartial函数处，如下所示：
使用F8键进行单步调试。这里需要注意的是，只要运行过了PUSH命令就可以了，记得不要越过下面的BL命令，因为没必要走到那里。当执行了PUSH命令之后，就是使用脚本来dump出内存中的dex数据了。这里有一个知识点：R0～R4寄存器一般是用来存放一个函数的参数值的，而dvmDexFileOpenPartial函数的第一个参数就是dex内存起始地址，第二个参数就是dex大小，如下所示：
这里就可以使用这样的脚本进行dump操作：
脚本不解释了，非常简单，而且这是固定的格式，以后dump内存中的dex都是用这段代码，将dump出来的dex保存到F盘中。
然后使用Shirt+F2键调出IDA的脚本，如图23-13所示。
图23-13 dump出dex文件
点击Run，这里可能需要等一会。运行成功之后，去F盘得到dump.dex文件。到这里，IDA使命就完成了，因为得到了内存的dex文件了，下面只要分析dex文件即可。
23.3 分析解密之后的dex文件内容
拿到dump.dex文件之后，使用dex2jar工具进行反编译，如下所示：
可惜的是，报错了，反编译失败，主要是因为有一个类导致的。开始我以为是dump出来的dex文件有问题，最后用baksmali工具得到smali文件是可以的，所以不是dump出来的问题，最后用baksmali工具将dex转化成smali源码：
得到的smali源码目录classout在C盘中，如图23-14所示。
图23-14 反编译之后的smali源码
得到了指定的smali源码了。
那么下面就可以使用静态方式分析smali。首先找到入口的MainActivity源码：
这里不解释了，肯定是找按钮的点击事件代码处，这里是一个btn_listener变量，看这个变量的定义：
是MainActivity$1内部类定义，查看这个类的smali源码，直接查看它的onClick方法：
这里可以看到，把EditText中的内容用Intent传递给WebViewActivity中，但是这里的intent数据的key是加密的。下面继续看WebViewActivity这个类：
直接查找onCreate方法即可，这里是初始化WebView，然后进行一些设置。这里看到一个@JavascriptInterface。
这个注解在使用WebView的时候都知道，它是用于JavaScript中能够访问而设置的，没有这个注解的方法JavaScript是访问不了的。
注意：这个注解是在SDK 17加上的，也就是Android 4.2版本中，那么在之前的版本中没有这个注解，任何public的方法都可以在JavaScript代码中访问，而Java对象继承关系会导致很多public的方法都可以在JavaScript中访问，其中一个重要的方法就是getClass（）。然后JavaScript可以通过反射来访问其他一些内容。那么这里就有这个问题了，比如下面的一段JavaScript代码：
这段JavaScript代码很危险，使用getClass方法得到这个对象（Java中的每个对象都有这个方法的），用这个方法可以得到一个Java对象，然后就可以调用这个对象中的方法了。这个也算是WebView的一个漏洞。所以通过引入@JavascriptInterface注解，则在JavaScript中只能访问@JavascriptInterface注解的函数。这样就可以增强安全性。
回归到正题，上面分析了smali源码，看到了WebView的一些设置信息，可以继续往下面看：
这里看到了一些重要的方法，一个是addJavascriptInterface，一个是loadUrl方法。知道addjavaascriptInterface方法一般的用法：
第一个参数是本地的Java对象，第二个参数是给JavaScript中使用的对象的名称。然后JavaScript得到这个对象的名称就可以调用本地的Java对象中的方法了。这里用如下代码：
将JavaScript中的名称进行混淆加密了，这也是为了防止恶意的网站来拦截后，然后调用本地的Java中的方法。
注意：这里又存在一个关于WebView的安全问题，就是JavaScript访问的对象的名称问题，比如现在程序中有一个JavaScript交互的类，类中有一个获取设备重要信息的方法，获取设备的imei，如果程序没有做这样名称的混淆的话，破解者得到这个JavaScript名称和方法名，然后就伪造一个恶意URL，来调用程序中的这个方法，比如这样一个例子：
然后再设置JavaScript名称：
就可以伪造一个恶意的URL页面来访问这个方法，比如这个恶意的页面代码如下：
运行程序如图23-15所示。
图23-15 调用JavaScript方法
恶意页面就成功地调用了程序中的一个重要方法。可以看到，对JavaScript交互中的对象名称做混淆是必要的，特别是本地一些重要的方法。
分析完了WebView的一些初始化和设置代码，而且知道如果要被JavaScript访问的方法，必须要有@JavascriptInterface注解，因为在Java中注解也是一个类，所以去注解类的源码看看那个被JavaScript调用的方法：
这里看到有一个showToast方法，展示的内容为\u7965\u9f99\uff01，在线转化一下，如图23-16所示。
图23-16 在线转化字符串
这里就是题目要求展示的内容。
到这里就分析完了apk的逻辑了，下面来整理一下：
1）在MainActivity中输入一个页面的URL，跳转到WebViewActivity进行展示。
2）WebViewActivity有Java Script交互，需要调用本地Java对象中的showToast方法展示消息。
问题：因为这里的Java Script对象名称进行了加密，所以这里自己编写一个网页，但是不知道这个Java Script对象名称，无法完成showToast方法的调用。
23.4 逆向方法
下面就来分析一下如何解决上面的问题。其实解决这个问题现有的方法太多了。
第一种方法：修改smali源码。
把上面的那个Java Script对象名称改成自己想要的，比如jiangwei，然后在自己编写的页面中直接调用jiangwei.showToast方法即可。不过这里需要修改smali源码，使用smali工具回编译成dex文件，再返回到apk中运行。方法是可行的，但是感觉太复杂，这里不采用。
第二种方法：利用WebView的漏洞。
直接使用如下Java Script代码即可。
这里根本不需要任何JavaScript对象的名称，只需要方法名就可以完成调用。可以看到这个漏洞还是很危险的。
第三种方法：调用加密方法。
看到了那个加密方法，自己写一个程序，来调用这个方法，既然上面已经得到正确的JavaScript对象名称，这里就采用这种方式。因为这个方式有一个新的技能，所以这里就讲解一下了。
如果用第三种方法的话，就需要再去分析那个加密方法逻辑了：
android.support.v4.widget.ListViewAutoScrollHelpern在这个类中，再去查找这个smali源码：
这个类加载了libtranslate.so库，而且加密方法是native层的，那么用IDA查看libtranslate.so库，如图23-17所示。
图23-17 native函数
搜一下Java开头的函数，发现并没有和decrypt_native方法对应的native函数，说明这里做了native方法的注册混淆，直接看JNI_OnLoad函数，如下所示：
这里果然是自己注册了native函数，但是分析到这里，就不往下分析了，为什么呢？因为其实没必要搞清楚native层的函数功能，知道了Java层的native方法定义，那么可以自己定义一个native方法来调用libtranslate.so中的加密函数功能，如图23-18所示。
图23-18 Demo工程
新建一个Demo工程，仿造一个ListViewAutoScrollHelpern类，内部再定义一个native方法。
然后在MainActivity中加载libtranslate.so：
然后调用那个native方法，打印结果如下：
这里的方法参数可以查看smali源码中的那个方法参数：
点击运行，发现有崩溃的，查看log信息，如下所示：
是由于libtranslate.so中有一个PagerTitleStripIcsn类找不到，这个类应该也有一个native方法，再构造这个类：
再次运行，还是报错，原因差不多，还需要再构造一个类TaskStackBuilderJellybeann：
好了，再次点击运行：
成功了，从这个log信息可以看出来，解密之后的Java Script对象名称是：SmokeyBear，那么下面就简单了，再构造一个URL页面，直接调用SmokeyBear.showToast即可。
注意：这里如果知道了Java层的native方法的定义，那么就可以调用这个native方法来获取native层的函数功能，这还是很不安全的。如何防止自己的so被别人调用呢？在前面章节中已经讲解了安全防护的知识，可以在so中的native函数做一个应用的签名校验，只有属于自己的签名应用才能调用，否则直接退出。
23.5 逆向测试
上面已经知道了Java Script的对象名称，下面就来构造这个页面了：
这里又有一个问题了，这个页面构造好了？放哪里呢？有的人可能有服务器，放到服务器上，然后输入URL地址就可以了，的确这个方法是可以的，但是有的人没有服务器怎么办呢？也有方法，知道WebView的loadUrl方法是可以加载本地页面的，所以可以把这个页面保存到本地，但是需要注意的是，这里不能存到SD卡中，因为这个应用没有读取SD的权限，可以查看它的AndroidManifest.xml文件：
在不重新打包的情况下，是没办法做到的，那么放哪里呢？其实很简单，可以放在这个应用的/data/data/com.ali.tg.testapp/目录下，因为除了SD卡位置，这个位置是最好的了，那么知道WebView的loadUrl方法在加载本地的页面的格式是：file：///data/data/com.ali.tg.testapp/crack.html；那么直接输入即可。
这里再介绍一个小技巧：在一个文本框中输入这么多内容，手动输入很烦琐，可以借助命令来实现输入，就是使用如下命令：
具体用法是，打开需要输入内容的EditText，点击调出系统的输入法界面，然后执行上面的命令即可：
不过这里有一个小问题，就是它不识别分号，如图23-19所示。
图23-19 文本框输入内容
直接修改成分号点击“进入”，运行成功。可看到toast的展示。
提示：项目下载地址为http://download.csdn.net/detail/jiangwei0910410003/9543445。
23.6 逆向加固应用的方法总结
破解的步骤比较多，下面来整理一下破解步骤。
1.破解的常规套路
按照破解惯例，首先解压出classses.dex文件，使用dex2jar工具查看Java代码，发现只有一个Application类，所以猜测apk被加壳（加固）了，然后用apktool来反编译apk，得到它的资源文件和AndroidManifest.xml内容，找到了包名和入口的Activity类。
2.加固apk的源程序一般存放的位置
知道加固apk后，那么就分析这个加固的apk放在哪里，肯定是存放在本地的一个地方，一般是三个地方：
·应用的asset目录中。
·应用的libs中的so文件中。
·应用的dex文件的末尾。
分析了之后，发现asset目录中的确有两个jar文件，但是打不开，猜测是经过处理了，所以得分析处理逻辑，但是这时候也没有代码，怎么分析呢？这时候就需要借助于dump内存dex技术了：不管最后的源apk放在哪里，最后都是需要经历解密动态加载到内存中的，所以分析底层加载dex源码，知道有一个函数dvmDexFileOpenPartial，这个函数有两个重要参数，一个是dex的地址，一个是dex的大小，而且知道这个函数是在libdvm.so中的。所以可以使用IDA进行动态调试获取信息。
3.双开IDA开始获取内存中的dex内容