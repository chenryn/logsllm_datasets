original, which helps debugging the monitor, monitored pro-
gram, and policy.
These design goals are in support of two main project
goals. First, we are assessing the applicability and eﬀective-
ness NSU for web applications. Second, we are interested in
practical performance of monitoring; our hypothesis is that
it could be achieved by leveraging oﬀ-the-shelf JIT compil-
ers, and we investigate whether it is true.
Contributions and outline. The main contribution is an
IFC monitor inliner for almost full ECMAScript 5, with
support for web APIs. We report on experiments with per-
formance benchmarks and also small but realistic mashups,
for which we have built enough API and library infrastruc-
ture. Our system is named JEST, for JS with Embedded
Security Tracking.
Sec. 2 highlights IF issues in JS, only brieﬂy since most
have been described in prior work.
Sec. 3 describes the design and rationale for monitored
programs and the inliner. The inliner handles actual scripts
as found in web pages, handling all the complications of
scripts embedded in HTML and providing support for track-
ing of IF across DOM operations. Although prior work has
identiﬁed the main challenges of tracking information ﬂows
in JS, we have to address them in full, in all their guises.
We argue why the design meets our goals.
Sec. 4 presents some experimental results, using an en-
tirely unmodiﬁed JS engine. The inliner itself is written
in Haskell and it’s performance is not problemmatic; what
we evaluate is performance of monitored programs. Exper-
iments on benchmarks designed to evaluate JIT compila-
tion exhibit on the order of 200× slowdowns depending on
whether the inliner is conﬁgured to prioritize transparency.
The results give some evidence that straightforward inlined
monitoring with NSU can be competitive with the approach
of modifying the JS interpreter, but do not show that our
goal of JIT-friendliness has been achieved completely. We
observe that the monitor core beneﬁts nicely from JIT com-
pilation but the instrumention we add to the monitored pro-
gram prevented JIT compilation in our experiments using
one JS engine.
The experiments also include case studies with mashups
inspired by apps in the wild and which have interesting IF
policies.
Sec. 5 provides further discussion of related work on IFC
for JS. Sec. 6 wraps up with discussion of future prospects.
The JEST software distribution provides infrastructure
for further experimentation and other investigations of IF
in JS: wrappers for DOM API and ECMAScript standard
libraries, and auxiliary open-source libraries and programs
developed to support the inliner and the experiments. The
source code of the inliner, supporting libraries, mashup case
studies are released under an open-source license [15]. De-
tailed technical documentation is available in [14].
In the near term it is unlikely that any IFC monitor will
have acceptable cost/beneﬁt ratio for general client-side use.
Even for taint tracking, prior works report quite signiﬁcant
slowdowns. Substantial slowdowns also result from code
transformations to support “safe subsets” of JS. See Sec. 5
for some numbers. However, performance numbers includ-
ing our own suggest that inlined monitoring can be prac-
tical for purposes of testing and security auditing (includ-
ing forensics). In testing scenarios, signiﬁcant performance
In addition, reproducible
degradation can be acceptable.
tests can facilitate inference of upgrade annotations.
IFC
may also be practical for production use in situations where
a security-sensitive mashup does not require a lot of client-
side computation.
631JEST supports all of ECMAScript 5.1 non-strict mode,
except the with statement. This version is by far the most
widely used for reasons of browser portability and perfor-
mance. Support for with is possible if targeting a platform
with an implementation of ECMAScript 6 Proxies.
Although this paper focuses on web apps, JS is used ex-
tensively outside of the browser context: many desktop and
most mobile environments allow applications written in JS,
which could beneﬁt from IFC.
2.
INFORMATION FLOWS IN JAVASCRIPT
Policies and example. In this paper we conﬁne attention
to policies in a simple, standard form. Policy has two parts.
First, a ﬁxed lattice of levels, where l (cid:118) l(cid:48) means information
at level l is allowed to ﬂow to l(cid:48), which may be interpreted to
mean “more secret” or “less integrity” or both. Second, ﬁxed
labels are assigned to input and output channels such as
input forms on a page and network connections. The policy
is interpreted to mean inputs at level l may inﬂuence outputs
at level l(cid:48) only if l (cid:118) l(cid:48). This noninterference property can
be formalized in terms of two runs, where variation of inputs
above l is allowed to cause variation only for outputs above
l, for all l.
As an example, consider this third-party payment proces-
sor scenario. A web store employs a third party to process
credit card payments. To avoid the need to deal directly with
PCI compliance, it integrates payment processing at client
side. At checkout an external IFrame from the payment
processing provider is loaded which includes a form for the
credit card information; the cost is provided via a postMes-
sage from the main page to the frame. Upon completion of
the credit card transaction, the payment processor returns
a crypto-signed transaction summary (to prevent forgery by
the user) which is sent to the merchant site via XMLHttpRe-
quest to conﬁrm payment. The merchant site should have
no access to the credit card details and the payment pro-
cessor should have no access to the order contents. The
merchant site is allowed to disclose the total, the name and
the zip-code part of the address (for credit card veriﬁcation).
The merchant has incentives to impose a conﬁdential-
ity policy given using three security levels: M (merchant-
private), P (processor-private) and ⊥ (public), such that
⊥ /pay as ⊥ so that the payment
conﬁrmation received from that URL or the error message
can be sent to the merchant page. In the merchant checkout
page we label all the ﬁelds and page elements as M, except
for the name and zip code form ﬁelds which are labeled ⊥.
The other channels in the merchant page are the payment
conﬁrmation /payment and order change
submission <merchant.domain/order_change URL’s, both
labeled M.
In our system policies are speciﬁed in a declarative lan-
guage (though an investigation of usability of policy speci-
ﬁcation is not our goal). The system is modular enough to
allow adding other ways of specifying policies with minimal
changes: a policy is compiled to a JavaScript object with
methods that give labels for locations and create new pub-
lic labels. The policy writer can specify labeling of URI’s,
DOM elements and cookies.
Downgrading is needed for most practical requirements.
In the example above, the individual purchase amounts are
part of the order contents and considered secret, but their to-
tal must be revealed to the payment processor. Prior works
suggest such policies can be speciﬁed by means of code an-
notations that designate some expression and program point
where the value of that expression may be downgraded [53].
(Such annotations may be derived from higher level policies
independent from the code; this important issue is beyond
the scope of this paper.) The semantics of downgrading is
subtle [53] but for our purposes adequate semantics is pro-
vided by prior work [7, 3, 58]. A monitor can implement
downgrading by re-labeling, together with appropriate check
for implicit ﬂow. In our system downgrading policies can be
speciﬁed in the application code using a call to a declassiﬁ-
cation function.
IFC challenges. In addition to heap locations and dynamic
evaluation, there are other JS features that pose a challenge
to precise tracking of information ﬂows. Most of them have
been studied in detail in [29, 28, 11]. We will remind the
reader of the most interesting ones.
Variables and object ﬁelds are not the only storage chan-
nel: the structure of objects, arrays, DOM tree nodes and
lexical environments [29, 52, 2] can store information too.
We discuss a few examples to illustrate the point.
Arrays in JS are objects, with elements being ﬁelds with
numeric names. Every array has a length ﬁeld with inter-
esting semantics: reading it will always give the index of the
highest-numbered array element plus one, writing to it will
cause all the elements that have indices higher or equal than
the new value to be removed. Field names that are not valid
indices do not interact with length. Consider this example:
var a = [1 ,2];
if ( secret ==1) a . length = 1;
output ( low , " 1 " in a ) ;
An array a is initialized with two elements. Depending
on a secret its length is set to 1, which causes the second
element to be deleted. By checking whether the element is
present afterwards the attacker can leak one bit of informa-
tion, which can be magniﬁed.
A taint tracker could propagate labels in order to catch
the indirect ﬂow from secret to a.length. But, in order
to account for the ﬂow from setting length to the outcome
of the "1" in a test, our monitor employs structure and
existence labels on the objects and ﬁelds respectively [29].
This applies to arrays, objects and the DOM.
Local variables can be created and deleted too. Condi-
tional creation cannot be done with static var declarations,
because of hoisting. However, conditional creation of vari-
ables can be achieved using eval. For example, if (secret)
eval("var x;"); will create a new variable x if it didn’t ex-
ist before. For this to be a ﬂow channel it needs to be possi-
ble to detect existence as well. Unlike for ﬁelds, there are no
built-in operators for enumerating or querying existence of
local variables. However, one can use ReferenceError ex-
ceptions thrown when reading non-existent variables. Here
is an example.
632public = 1;
if ( secret ) eval ( " var x ; " ) ;
try { x ;} catch ( e ) { public = 0;}
output ( low , public ) ;
To prevent these attacks we currently disallow dynamic
evaluation of code that introduces new variables in a high
implicit context.
Another complication is the presence of unstructured con-
trol ﬂow due to break and continue statements and excep-
tions. The presence of such ﬂows means that syntax-driven
analysis, monitoring and transformation rules found in the
literature [38, 5, 29, 54] would miss or over-approximate
implicit ﬂows when applied to JS. There is also branching
control-ﬂow at the expression level. The fact whether a sub-
expression is evaluated might depend on the result of evalu-
ation another sub-expression. In addition to exceptions and
the conditional expression (-?-:-), this occurs due to lazy
evaluation of the logical operators && (and) and || (or).
The ECMAScript standard does not deﬁne any input and
output operations.
Instead, it has to rely on the hosting
environment —the browser in our case— to expose an API
necessary for performing IO. Additionally, the browser ex-
poses an interface for manipulating the web-page content,
which serves as both IO channel and storage channel (struc-
ture of the document and values of document elements).
Finally, there is the ECMAScript standard library. Some
of these APIs can cause information ﬂows across diﬀerent
parts of the API (e.g., assigning to the length property of
an array can cause a toString method of another object
be called), or even be invoked implicitly by the semantics.
Implicit ﬂows via exceptions, storage channels via structure
and internal state, and side-eﬀects (e.g., utility methods in
the Array prototype object) are also an issue with the stan-
dard library.
In order to maintain soundness information
ﬂows through the use of these API’s need to be accounted
for.
3. MONITOR DESIGN
We focus on the core components and design principles
and discuss how they support our goals, as articulated in
Sec. 1. Due to space limitations we cannot present an in-
depth discussion of the design and implementation of the
monitor and the inliner. More details could be found in [14,
15].
Soundness and transparency rely primarily on that of the
information-ﬂow semantics, which is similar to prior work
[29, 52, 11], so we don’t elaborate it. However, the semantics
relies on the ability to mediate the operations of the under-
lying language semantics and the APIs, which is trivial to
achieve in interpreter-based monitors and hard for inlined.
Performance depends on the scope of program instrumen-
tation and whether JIT compilers generate eﬃcient code for
the monitor.
3.1 Additional challenges due to inlining
Inlined monitors live side-by-side with the monitored pro-
gram. This makes them vulnerable to attacks from the
program that may try to tamper with the monitor state
or implementation. Protection is not easy since the moni-
tored program needs access to the monitor. Another issue
we need to consider is discrepancies between browser imple-
mentations that might expose diﬀering APIs. Fortunately,
addressing these challenges is possible with semantic medi-
ation and API emulation.
As noted in [28, 24, 13], the semantics of ECMAScript and
DOM is full of edge-cases and implicit mutual dependencies:
for example, applying the + operator may cause a call to a
toString function deﬁned in the standard library — or even
to a user-deﬁned one! The monitor must track all these
interactions.
Finally, being implemented in JS itself, the monitor should
play by its rules and neither has access nor can modify the
inner workings of the interpreter and the libraries, such as
the internal algorithms and state, as deﬁned in the speciﬁca-
tion. This complicates achieving mediation while preserving
transparency.
3.2 Principal design choices
The goals and challenges have guided us to make the fol-
lowing design decisions.
Boxes. Association of security labels with values plays an
important role in the monitor design. Previous work has
used shadow variables and ﬁelds [54, 17], sparse labeling [11,
4], and boxing [29, 11].2 We argue that boxing is more
appropriate for inlined monitors in JS. Our boxes are objects
with four ﬁelds: v for the value, l for the security label, t
for the type tag and m for meta-data.
The primary purpose of boxes is to store values together
with labels. This simpliﬁes storage, eliminating the need
to distinguish between ﬁelds and variables as with shadow
locations.
It also simpliﬁes reasoning about access to the
It also allows us to adopt an important invariant:
labels.
all the transformed (sub-)expressions evaluate to boxes. Fi-
nally, it allows us to store extra meta-data used in precise
modeling of the internal algorithms of both the HTML and
ECMAScript speciﬁcations in an eﬃcient way.
On the face of it boxes are a terrible idea because they
require an extra level of indirection to all data accesses and
more storage. Yet, we have observed that they simplify both
the monitor core and the inlining algorithm and, at the same
time, allow for more eﬃcient execution in the JIT.
JavaScript’s dynamism has led modern JIT compilers to
adopt dynamic —instead of static— analysis for optimiz-
ing code generation. The most common approach,3 which
applies to V8 and SpiderMonkey, is dubbed tracing method
JIT compilation. Compilers have two tiers. The ﬁrst gen-
erates native code for function bodies on their ﬁrst invoca-
tion and supports all JS features at the price of suboptimal