有了这个矩阵，我们就可以很容易地知道图中的信息。
1.我们要判定任意两顶点是否有边无边就非常容易了。
2.我们要知道某个顶点的度，其实就是这个顶点v在邻接矩阵中第1行（或第1
列）的元素之和。比如顶点v的度就是1+0+1+0=2。
3.求顶点v的所有邻接点就是将矩阵中第1行元素扫描一遍，arc[][]为1就是
邻接点。
225
---
## Page 250
大语数据结构
我们再来看一个有向图样例，如图7-4-3所示的左图。
顶点数组：
VoV1V2V
Vo
V2
0
01
边数组：
01
v的出度为2
2
0
0
U
0
0
v的入度为1
图 7-4-3
顶点数组为vertex[4]=[voV,V2,vs}，弧数组arc[4][4]为图7-4-3右图这样的一个
矩阵。主对角线上数值依然为0。但因为是有向图，所以此矩阵并不对称，比如由V1
到vo有弧，得到arc[1][0]=1，面vo到v没有弧，因此arc[0][1]=0。
有向图讲究入度与出度，顶点V的入度为1，正好是第v列各数之和。顶点v1
的出度为2，即第v行的各数之和。
与无向图同样的办法，判断顶点v到v是否存在弧，只需要查找矩阵中arc[]
是否为1即可。要求v的所有邻接点就是将矩阵第i行元素扫描一遍，查找arc[][]
为1的顶点。
在图的术语中，我们提到了网的概念，也就是每条边上带有权的图叫做网。那么
这些权值就需要存下来，如何处理这个矩阵来适应这个需求呢？我们有办法。
设图G是网图，有n个顶点，则邻接矩阵是一个nXn的方阵，定义为：
W，若（vv,)∈E或∈E
arc[il]=
0，若i=j
反之
这里w表示（vv）或上的权值。oo表示一个计算机允许的、大于所有边
上权值的值，也就是一个不可能的极限值。有同学会问，为什么不是0呢？原因在于
权值W大多数情况下是正值，但个别时候可能就是0，甚至有可能是负值。因此必须
要用一个不可能的值来代表不存在。如图7-4-4左图就是一个有向网图，右图就是它
的邻接矩阵。
226
---
## Page 251
第7章图
顶点数组：
Vo
V
0
0
6
9
0
3
边数组：
00
2
00
0
5
00
0
8
00
0
图 7-4-4
那么邻接矩阵是如何实现图的创建的呢？我们先来看看图的邻接矩阵存储的结
构，代码如下。
typedef char VertexType;
1项点类型应由用户定义*/
typedef int EdgeType:
/边上的权值类型应由用户定义*/
define MAXVEx 100
/·最大顶点数，应由用户定义*/
define INFINITY 65535
/*用65535来代表*/
typedef struct
VertexType vexs[MAXVEX];
顶点表*/
EdgeType arc[MAXVEX] [MAXVEX];
/邻接矩阵，可看作边表·/
int numVertexes, numEdges;
1.图中当前的顶点数和边数*/
MGraph;
有了这个结构定义，我们构造一个图，其实就是给顶点表和边表输入数据的过
程。我们来看看无向网图的创建代码。
/*建立无向网图的邻接矩阵表示*/
void CreateMGraph (MGraph *G)
int i,j.k,;
printf（“输入顶点数和边数：\n"）；
scanf（"ed，ed"，6G->numVertexes，4G->numEdges）：/·输入顶点数和边数*/
for（i=0：inumVertexes;i++）/读入顶点信息，建立项点表*/
scanf（sG->vexs[i]）;
for（i=0inumVertexes;i++)
for（j-0;jnumVertexes;j++）
227
---
## Page 252
大话数据结构
G->arC[1][j]-INFINITY;/邻接矩阵初始化*/
for（k=O：knumEdges;k++）/·读入numEdges条边，建立邻接矩阵*/
printf（“输入边（vi，vj）上的下标i.下标j和权w：\n"）;
scanf（"ed，d，ed"，6i，6j，6w）:/*输入边（vi，vj）上的权w*/
G->arc[i][j]=w
G->arc[j][i]-G->arc[1][]/因为是无向图，矩降对称*/
从代码中也可以得到，n个顶点和e条边的无向网图的创建，时间复杂度为
O（n+n²+e)，其中对邻接矩阵Garc的初始化耗费了O（n2]的时间。
7.4.2邻接表
邻接矩阵是不错的一种图存储结构，但是我们也发现，对于边数相对顶点较少的
图，这种结构是存在对存储空间的极大浪费的。比如说，如果我们要处理图7-4-5这
样的稀疏有向图，邻接矩阵中除了arc[1][0]有权值外，没有其他弧，其实这些存储空
间都浪费掉了。
顶点数组：
VovV2VV4
V1
V2
Vy
8
8
8
V
V4
IA
9
0
8
00
边数组：
V2
8
0
00
00
?
Vs
8
0
00
V400
8880
图7-4-5
因此我们考虑另外一种存储结构方式。回忆我们在线性表时谈到，顺序存储结构
就存在预先分配内存可能造成存储空间浪费的问题，于是引出了链式存储的结构。同
样的，我们也可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。
再回忆我们在树中谈存储结构时，讲到了一种孩子表示法，将结点存入数组，并
对结点的孩子进行链式存储，不管有多少孩子，也不会存在空间浪费问题。这个思路
228
---
## Page 253
第7章图
同样适用于图的存储。我们把这种数组与链表相结合的存储方法称为邻接表
(Adjacency List)。
邻接表的处理办法是这样。
1.图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组
可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元
素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。
2.图中每个顶点v的所有邻接点构成一个线性表，由于邻接点的个数不定，所以
用单链表存储，无向图称为顶点v的边表，有向图则称为顶点v作为弧尾的
出边表。
例如图7-4-6所示的就是一个无向图的邻接表结构。
下标 data firstedge adjvex next
Vo
VE
0
2
V
2
V2
3V
0
图 7-4-6
从图中我们知道，顶点表的各个结点由data和firstedge两个域表示，data是数据
域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一
个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点
的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。比如v顶点
与vo、v2互为邻接点，则在v的边表中，adjvex分别为vo的0和v2的2。
这样的结构，对于我们要获得图的相关信息也是很方便的。比如我们要想知道某
个顶点的度，就去查找这个顶点的边表中结点的个数。若要判断顶点v到V是否存在
边，只需要测试顶点v的边表中advex是否存在结点v的下标j就行了。若求顶点的
所有邻接点，其实就是对此顶点的边表进行遍历，得到的adjvex域对应的顶点就是邻
接点。
若是有向图，邻接表结构是类似的，比如图7-4-7中第一幅图的邻接表就是第二
幅图。但要注意的是有向图由于有方向，我们是以顶点为弧尾来存储边表的，这样很
容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头
229
---
## Page 254
大语数据结构
的弧，我们可以建立一个有向图的逆邻接表，即对每个顶点v都建立一个链接为v为
弧头的表。如图7-4-7的第三幅图所示。
下标 data firstedge
adjvex next
V
V
V2
V3
邻接表
下标data firstedge
adjvex next
2
2
逆邻接表
图7-4-7
此时我们很容易就可以算出某个顶点的入度或出度是多少，判断两顶点是否存在
弧也很容易实现。
对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权
值信息即可，如图7-4-8所示。
下标 data firstedge
23
0
35
图 7-4-8
230
---
## Page 255
第7章图
有了这些结构的图，下面关于结点定义的代码就很好理解了。
typedef char VertexType;
1.项点类型应由用户定义/
typedef int EdgeType;
1.边上的权值类型应由用户定义·/
1边表结点*/
int adjvex;
1·邻接点城，存储该顶点对应的下标/
EdgeType weight;
用于存储权值，对于非网图可以不需要*/
structEdgeNode*next;/·链域，指向下一个邻接点*/
typedef struct VertexNode
1顶点表结点/
VertexType data;
/顶点城，存储顶点信息/
/边表头指针/
JVertexNode,AdjList[MAxVEx];
typedef struct
AdjList adjList;
int numVertexes,numEdges;
图中告前顶点数和边数*/
}GraphAdjList;
对于邻接表的创建，也就是顺理成章之事。无问图的邻接表创建代码如下
/*建立图的邻接表结构·/
int 1,J.k;
EdgeNode *e;
printf（“输入顶点数和边数：\n"）;
scanf（“d，ed”，6G->numVertexes，6G->numEdges）;/输入顶点数和边数*/
for（i-0;1numVertexes;i++）
/读入顶点信息，建立顶点表*/
scanf（6G->adjList[1].data）;
/*输入项点信息*/
G->adjList[i].firstedge=NULL;