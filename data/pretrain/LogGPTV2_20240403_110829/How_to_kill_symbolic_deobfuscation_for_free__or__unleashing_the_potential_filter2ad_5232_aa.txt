title:How to kill symbolic deobfuscation for free (or: unleashing the potential
of path-oriented protections)
author:Mathilde Ollivier and
S&apos;ebastien Bardin and
Richard Bonichon and
Jean-Yves Marion
How to Kill Symbolic Deobfuscation for Free
(or: Unleashing the Potential of Path-Oriented Protections)
Mathilde Ollivier
CEA, LIST,
Paris-Saclay, France
PI:EMAIL
Richard Bonichon
CEA, LIST,
Paris-Saclay, France
PI:EMAIL
Sébastien Bardin
CEA, LIST,
Paris-Saclay, France
PI:EMAIL
Jean-Yves Marion
Université de Lorraine, CNRS, LORIA
Nancy, France
PI:EMAIL
ABSTRACT
Code obfuscation is a major tool for protecting software intellec-
tual property from attacks such as reverse engineering or code
tampering. Yet, recently proposed (automated) attacks based on
Dynamic Symbolic Execution (DSE) shows very promising results,
hence threatening software integrity. Current defenses are not
fully satisfactory, being either not efficient against symbolic rea-
soning, or affecting runtime performance too much, or being too
easy to spot. We present and study a new class of anti-DSE pro-
tections coined as path-oriented protections targeting the weakest
spot of DSE, namely path exploration. We propose a lightweight,
efficient, resistant and analytically proved class of obfuscation algo-
rithms designed to hinder DSE-based attacks. Extensive evaluation
demonstrates that these approaches critically counter symbolic
deobfuscation while yielding only a very slight overhead.
CCS CONCEPTS
• Security and privacy → Software reverse engineering; Logic
and verification; Malware and its mitigation; • Software and its
engineering → Formal methods.
KEYWORDS
Reverse Engineering; Code Protection; Obfuscation
ACM Reference Format:
Mathilde Ollivier, Sébastien Bardin, Richard Bonichon, and Jean-Yves Mar-
ion. 2019. How to Kill Symbolic Deobfuscation for Free (or: Unleashing the
Potential of Path-Oriented Protections) . In 2019 Annual Computer Security Ap-
plications Conference (ACSAC ’19), December 9–13, 2019, San Juan, PR, USA.
ACM, New York, NY, USA, 13 pages. https://doi.org/10.1145/3359789.3359812
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
© 2019 Association for Computing Machinery.
ACM ISBN 978-1-4503-7628-0/19/12...$15.00
https://doi.org/10.1145/3359789.3359812
1 INTRODUCTION
Context. Reverse engineering and code tampering are widely used
to extract proprietary assets (e.g., algorithms or cryptographic keys)
or bypass security checks from software. Code protection techniques
precisely seek to prevent, or at least make difficult, such man-at-the-
end attacks, where the attacker has total control of the environment
running the software under attack. Obfuscation [21, 22] aims at
hiding a program’s behavior by transforming its executable code in
such a way that the behavior is conserved but the program becomes
much harder to understand.
Even though obfuscation techniques are quite resilient against ba-
sic automatic reverse engineering (including static attacks, e.g. dis-
assembly, and dynamic attacks, e.g. monitoring), code analysis
improves quickly [39]. Attacks based on Dynamic Symbolic Execu-
tion (DSE, a.k.a. concolic execution) [18, 30, 40] use logical formulas
to represent input constraints along an execution path, and then
automatically solve these constraints to discover new execution
paths. DSE appears to be very efficient against existing obfuscations
[5, 8, 13, 24, 37, 51], combining the best of dynamic and semantic
analysis.
Problem. The current state of symbolic deobfuscation is actually
pretty unclear. Dedicated protections have been proposed, mainly
based on hard-to-solve predicates, like Mixed Boolean Arithmetic
formulas (MBA) [52] or cryptographic hash functions [42]. Yet the
effect of complexified constraints on automatic solvers is hard to
predict [6], cryptographic hash functions may induce significant
overhead and are amenable to key extraction attacks (possibly
by DSE). On the other hand, DSE has been fruitfully applied on
malware and legit codes protected by state-of-the-art tools and
methods, including virtualization, self-modification, hashing or
MBA [8, 37, 51]. A recent systematic experimental evaluation of
symbolic deobfuscation [5] shows that most standard obfuscation
techniques do not seriously impact DSE. Only nested virtualization
seems to provide a good protection, assuming the defender is ready
to pay a high cost in terms of runtime and code size [37].
Goals and Challenges. We want to propose a new class of dedi-
cated anti-DSE obfuscation techniques to render automated attacks
based on symbolic execution inefficient. These techniques should
be strong – making DSE intractable in practice, and lightweight –
with very low overhead in both code size and runtime performance.
While most anti-DSE defenses try to break the symbolic reasoning
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
Mathilde Ollivier, Sébastien Bardin, Richard Bonichon, and Jean-Yves Marion
2 MOTIVATION
2.1 Attacker model
Scenario. We consider man-at-the-end scenarios where the at-
tacker has full access to a potentially protected code under attack.
The attacker only has the executable and no access to the source
code, is skilled in program analysis but with limited resources (typi-
cally: motivated by economic gains [19], short term attack scenarios
such as VOD cracking or video games).
As a consequence, this attacker has access to automated state-of-
the-art off-the-shelf tools (DSE, etc.), can try to attack protections
(tainting [40], slicing [44], patterns) and craft attacks by combining
those tools. But our attacker will not invest in crafting dedicated
tools going beyond state-of-the-art. Basically, our goal is to delay
the attack enough so that the attacker stops because of the cost.
We consider that if the attacker has to craft a dedicated tool beyond
state-of-the-art, then the defender has won.
Scope.We focus on Symbolic Execution and other trace-based se-
mantic attacks as they have proven to be useful automated tech-
niques in recent attacks. We thus aim to remove them from the
attacker’s toolbox to increase the attack’s costs. Typical DSE-based
attacks include finding rare behaviors (triggers [13], secrets, etc.)
of the whole program or local exhaustive exploration (proofs [8],
simplifications [37]). Such attacks can be abstracted by the two
following goals: (1) Secret Finding; (2) Exhaustive Path Exploration.
Caveat. Part of our experimental evaluations uses source codes, as
state-of-the-art source-level DSE tools are much more efficient than
binary-level ones. Our experimental conditions actually favors
the attacker more, and as a result they show that our approach is
all the more effective.
int check_char_0 ( char chr ) {
char ch = chr ;
ch ^= 9 7 ;
return ( ch == 3 1 ) ;
part of DSE (constraint solver), we instead target its real weak spot,
namely path exploration. Banescu et al. [5] present one such spe-
cific obfuscation scheme but with a large space overhead and no
experimental evaluation. We aim at proposing a general framework
to understand such obfuscations and to define new schemes both
strong and lightweight.
Contribution. We study path-oriented protections, a class of pro-
tections seeking to hinder DSE by substantially increasing the num-
ber of feasible paths within a program.
• We detail a formal framework describing path-oriented protec-
tions (Sec. 4). We characterize their desirable properties — namely
tractability, strength, and the key criterion of single value path (SVP).
The framework is predictive, in the sense that our classification is
confirmed by experimental evaluation (Sec. 8), allowing both to
shed new light on the few existing path-oriented protections and
to provide guidelines to design new ones. In particular, no existing
protection [5] achieves both tractability and optimal strength (SVP).
As a remedy, we propose the first two obfuscation schemes achieving
both tractability and optimal strength (Sec. 5).
• We highlight the importance of the anchorage policy, i.e. the
way to choose where to insert protection in the code, in terms
of protection efficiency and robustness. Especially, we identify a
way to achieve optimal composition of path-oriented protections
(Sec. 6.1), and to completely prevent taint-based and slic-based at-
tacks (two powerful code-level attacks against obfuscation), coined
as resistance by design (Sec. 6.2).
• We conduct extensive experiments (Sec. 8.3) with two differ-
ent attack scenarios — exhaustive path coverage (Sec. 8.3) and secret
finding. Results confirm that path-oriented protections are much
stronger against DSE attacks than standard protections (including
nested virtualization) for only a slight overhead. Moreover, while
existing techniques [5] can still be weak in some scenarios (e.g.,
secret finding), our new optimal schemes cripple symbolic deobfusca-
tion at essentially no cost in any setting. Finally, experiments against
slice, pattern-matching and taint attacks confirm the quality of our
robust-by-design mechanism.
As a practical outcome, we propose a new hardened deobfuscation
benchmark (Sec. 9), currently out-of-reach of symbolic engines, in
order to extend existing obfuscation benchmarks [1, 5, 37].
Discussion. We study a powerful class of protections against sym-
bolic deobfuscation, based on a careful analysis of DSE – we target
its weakest point (path exploration) when other dedicated meth-
ods usually aim at its strongest point (constraint solving and ever-
evolving SMT solvers). We propose a predictive framework allowing
to understand these protections, as well as several concrete pro-
tections impacting DSE more than three levels of virtualization at
essentially no cost. We expect them to be also efficient against other
semantic attacks [10, 31] (cf. Sec. 10). From a methodological point
of view, this work extends recent attempts at rigorous evaluation of
obfuscation methods. We provide both an analytical evaluation, as
Bruni et al. [15] for anti-abstract model checking, and a refinement
of the experimental setup initiated by Banescu et al. [5].
}
}
}
/ ∗
. . .
9 o t h e r
c h e c k s
. . .
∗ /
int check_char_10 ( char chr ) {
/ ∗
. . .
∗ /
}
int check ( char ∗ buf )
{
r e t v a l = 1 ;
int
r e t v a l
/ ∗
. . .
r e t v a l
return r e t v a l ;
∗= check_char_0 ( buf [ 0 ] ) ;
c h e c k b u f [ 1 ]
. . .
∗= check_char_10 ( buf [ 1 0 ] ) ;
t o b u f [ 9 ]
∗ /
int main ( int argc , char ∗ ∗ argv )
{
char ∗ buf = argv [ 1 ] ;
i f
else puts ( " l o s e " ) ;
( check ( buf ) ) puts ( " win " ) ;
Figure 1: Manticore crackme code structure
2.2 Motivating example
Let us illustrate anti-symbolic path-oriented protections on a toy
crackme program1. Fig. 1 displays a skeleton of its source code.
1https://github.com/trailofbits/manticore
How to Kill Symbolic Deobfuscation for Free
(or: Unleashing the Potential of Path-Oriented Protections)
main calls check to verify each character of the 11 bytes input. It
then outputs "win" for a correct guess, " lose " otherwise. Each sub-
function check_char_ii∈[0,10] hides a secret character value behind
bitwise transformations, like xor or shift. Such a challenge can be
easily solved, completely automatically, by symbolic execution tools.
KLEE [17] needs 0.03s (on C code) and Binsec [26] 0.3s (on binary
code) to both find a winning input and explore all paths.
Standard protections. Let us now protect the program with stan-
dard obfuscations to measure their impact on symbolic deobfusca-
tion. We will rely on Tigress [23], a widely used tool for systematic
evaluation of deobfuscation methods [5, 8, 37], to apply (nested)
virtualization, a most effective obfuscation [5]. Yet, Table 1 clearly
shows that virtualization does not prevent KLEE from finding the
winning output, though it can thwart path exploration – but with
a high runtime overhead (40×).
The case for (new) path-oriented protections. To defend against
symbolic attackers, we thus need better anti-DSE obfuscation: path-
oriented protections. Such protections aim at exponentially increas-
ing the number of paths that a DSE-based deobfuscation tool, like
KLEE, must explore. Two such protections are Split and For, illus-
trated in Fig. 2 on function check_char_0 of the example.
Split
For
int
func ( char chr ) {
char ch = 0 ;
for (int i=0; i 60) garb++; else garb−−;
if (ch2 > 20) garb++; else garb−−;
ch ^= 9 7 ;
return ( ch == 3 1 ) ;
}
{
}
Figure 2: Unoptimized obfuscation of check_char_0
For the sake of simplicity, the protections are implemented in a
naive form, sensitive to slicing or compiler optimizations. Robustness
is discussed afterwards. In a nutshell, Split— an instance of Range
Divider [5] — adds a number k of conditional statements depending
on new fresh inputs, increasing the number of paths to explore by a
factor of 2k. Also, in this implementation we use a junk variable garb
and two additional inputs ch1 and ch2 unrelated to the original code.
The novel obfuscation For (Sec. 5) adds k loops whose upper bound
depends on distinct input bytes and which recompute a value that
will be used later, expanding the number of paths to explore by a
factor of 28·k – assuming a 8-bit char type. This implementation does
not introduce any junk variable nor additional input. In both cases,
the obfuscated code relies on the input, forcing DSE to explore a
priori all paths. Table 1 summarizes the performance of Split and
For. Both Split and For do not induce any overhead, Split is
highly efficient (timeout) against coverage but not against secret
finding, while For is highly efficient for both. For (k = 2) performs
already better than Split (k = 19) and further experiments (Sec. 8)
shows For to be a much more effective path protection than Split.
Question: How to distinguish a priori between mildly effective and
very strong path-oriented protections?
Note that gcc -Ofast is removes this simple Split, as it is not
related to the output (slicing attack). A basic For resists this attack,
but clang -Ofast is able to remove it by an analysis akin to a pattern
Table 1: DSE Attack on the Crackme Example (KLEE)