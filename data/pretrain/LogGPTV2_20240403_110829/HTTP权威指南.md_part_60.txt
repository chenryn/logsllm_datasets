以计算两个对象之间的差异）。然后服务器必须计算差异，发送给客户端，告知客户
端所发送的是差异，并说明最新版页面的新标识（ETag），因为客户端将差异应用
于其老版本之后就会得到这个版本。
客户端在If-None-Match首部中使用的是它所持有页面版本的唯一标识，这个标
366 识是服务器之前响应客户端时在ETag首部中发送的。客户端是在对服务器说：“如
果你那里页面的最新版本标识和这个ETag不同，就把这个页面的最新版本发给
我。”如果只有If-None-Match首部，服务器将会把该页面的最新版本完整地发给
客户端。（假设最新版和客户端持有的版本不同。）
不过，如果客户端想告诉服务器它愿意接受该页面的差异，只要发送A-IM首部就
可以了。A-IM是Accept-Instance-Manipulation（接受实例操控）的缩写。形象比喻
的话，客户端相当于这样说：“哦对了，我能接受某些形式的实例操控，如果你会
其中一种的话，就不用发送完整的文档给我了。”在A-IM 首部中，客户端会说明它
知道哪些算法可以把差异应用于老版本而得到最新版本。服务端发送回下面这些内
容：一个特殊的响应代码——226 IM Used，告知客户端它正在发送的是所请求对象
382 ｜ 第15章
的实例操控，而不是那个完整的对象自身；一个IM（Instance-Manipulation的缩写）
首部，说明用于计算差异的算法；新的ETag首部和Delta-Base首部，说明用于
计算差异的基线文档的ETag（理论上，它应该和客户端之前请求里的If-None-
Match首部中的ETag相同！）。表15-5中总结了差异编码使用的首部。
请求报文
GET /bigfile.html HTTP/1.1
客户端
Date: Mon, 01 Feb 2001 12:03:00 GMT 2001年2月1日星期一
下午12时03分的页面
客户端收到这个响应并把
它缓存起来。第二天，客 Hello,welcome to
户端又要访问这个页面， 响应报文 Joe’s Hardware store.
它 经发 过现 期自 ，己 于的 是缓 就存 向副 服本 务已 H CT oT nP t/ e1 n. t1 t2 y0 p0 :O K 服务器Today h’ as m s mpe ec ri sa .l is on
器 - e text/html
请求最新的副本。因为客 Expires: Mon, 01 Feb 2001 12:00:00 GMT
户端已有一份缓存的副本， Etag: abcdefghi09876AF
...
它就告知服务器自己有哪
份副本，并说明自己愿意 差异请求报文
接受差异。
GET /bigfile.html HTTP.1.1 2001年2月2日星期二
If-None-Match: abcdefghi09876AF
A-IM: diffe 上午3时03分的页面
Date: Tue, 02 Feb 2001 03:03:00 GMT
Hello,welcome to
Joe’s Hardware store.
差异 Today’s special is
on chisels.
5c.
客户端收到差异并将 chisels.
.
其应用到自己缓存的 差异响应报文
页面版本上，生成了 差异生成器
HTTP/1.1 226 IM Used
页面的最新版本。客
IM: diffe
户端还要将ETag更 Etag: zywxtuv123456BG
新为页面最新版的值。 Delta-base: abcdefghi09876AF
...
差异应用器
Hello, welcome
to Joe’s Hardware
store.Today’s special
is on chisels.
图15-10 差异编码的结构
实体和编码 ｜ 383
表15-5 差异编码所用的首部
首 部 描 述
ETag 文档每个实例的唯一标识符。由服务器在响应中发送；客户端在后继请求的
If-Match首部和If-None-Match首部中可以使用它
If-None-Match 客户端发送的请求首部，当且仅当客户端的文档版本与服务器不同时，才向服务
器请求该文档
A-IM 客户端请求首部，说明可以接受的实例操控类型
IM 服务器响应首部，说明作用在响应上的实例操控的类型。当响应代码是226 IM
Used时，会发送这个首部
Delta-Base 服务器响应首部，说明用于计算差异的基线文档的ETag值（应当与客户端请求
中的If-None-Match首部里的ETag相同）
实例操控、差异生成器和差异应用器
客户端可以使用A-IM首部说明可以接受的一些实例操控的类型。服务器在IM首部
中说明使用的是何种实例操控。不过到底哪些实例操控类型是可接受的呢？它们又
是做什么的呢？表15-6 中列出了一些在IANA注册的实例操控类型。
表 15-6 在IANA注册的实例操控类型
类 型 说 明
vcdiff 用vcdiff 算法计算差异a
diffe 用Unix系统的diff-e命令计算差异
367 gdiff 用gdiff 算法计算差异b
gzip 用gzip算法压缩
deflate 用deflate算法压缩
range 用在服务器的响应中，说明响应是针对范围选择得到的部分内容
identity 用在客户端请求中的A-IM首部中，说明客户端愿意接受恒等实例操控
a： 因特网草案draft-korn-vcdiff-01中描述了vcdiff算法。该规范在2002年初期由IESG（Internet
Engineering Steering Group，因特网工程指导组）批准，将很快以RFC的形式发布。（译注：
vcdiff的规范由RFC3284发布。）
b： http://www.w3.org/TR/NOTE-gdiff-19970901.html 描述了gdiff算法。
图15-10中，服务器侧的“差异生成器”根据基线文档和该文档的最新实例，用客
户端在A-IM首部中指明的算法计算它们之间的差异。客户端侧的“差异应用器”
得到差异，将其应用于基线文档，得到文档的最新实例。例如，如果产生差异的算
法是Unix系统的diff-e命令，客户端就可以用Unix系统中的文本编辑器ed提供的
功能来应用差异，因为diff-e  产生了一系列ed命令来把
384 ｜ 第15章
转化为。ed是一个非常简单的编辑器，支持一些命令。在图15-10的例子中，
5c说明要删除基线文档的第5行，而chisels..说明要添加chisels.，就这么
简单。对于更大的改动，会产生更复杂的指令。Unix系统的diff-e算法是对文件
进行逐行比较的，这对于文本文件没问题，但并不适合二进制文件。vcdiff算法更强
大，对于非文本文件也适用，并且产生的差异比diff-e要小。
差异编码的规范中详细定义了A-IM 和IM首部的格式。在这里，我们只要知道这
些首部中可以说明多个实例操控（并可以带有相关的质量值）就够了。在返回给客
户端之前，文档可以经过多种实例操控，这样可以获得最大程度的压缩。例如，用
vcdiff 算法产生的差异随后可以再用gzip算法压缩。于是服务器的响应中就含有
IM:vcdiff, gzip首部。客户端应当先对内容进行gunzip，再把得到的差异应用
到自己的基线页面上，这样才能生成最终的文档。
差异编码可以减少传输次数，但实现起来可能比较麻烦。设想一下页面改动频繁，
而且有很多不同的人都在访问的情形。支持差异编码的服务器必须保存页面随时间
变化的所有不同版本，这样才能指出最新版本与所请求的客户端持有的任意版本之
间的差异。（如果文档变化频繁，而且有很多客户端都在请求文档，那它们就会获得 368
文档的不同实例。随后当它们再向服务器发起请求时，它们将请求它们所持有的版
本与最新版本之间的差异。为了能够只向它们发送变化的部分，服务器必须保存所
有客户端曾经持有过的版本。）要降低提交文档时的延迟时间，服务器必须增加磁盘
空间来保存文档的各种旧的实例。实现差异编码所需的额外磁盘空间可能很快就会
将减少传输量获得的好处抵消掉。
15.11 更多信息
关于实体和编码方面的更多信息，请参考以下资源。
• http://www.ietf.org/rfc/rfc2616.txt
RFC 2616，也就是HTTP/1.1版的规范，是实体主体管理和编码方面的主要参考。
• http://www.ietf.org/rfc/rfc3229.txt
RFC 3229，“Delta Encoding in HTTP”（“HTTP中的差异编码”），说明了如何通
过扩展HTTP/1.1来支持差异编码。
• Introduction to Data Compression11（《数据压缩导论》）
这本书的作者是Khalid Sayood，出版商为Morgan Kaufmann Publishers。该书介
绍了几种HTTP内容编码支持的压缩算法。
注11： 本书影印版由人民邮电出版社出版。（编者注）
实体和编码 ｜ 385
• http://www.ietf.org/rfc/rfc1521.txt
RFC 1521，“Multipurpose Internet Mail Extensions, Part One: Mechanisms for
Specifying and Describing the Format of Internet Message Bodies”（“多用途因
特网邮件扩展，第一部分：规定和描述因特网报文主体格式的机制”），描述了
MIME主体的格式。这份参考材料很有用，因为HTTP从MIME中借用了大量
内容。设计这份文档的目的，就是为了提供在单一报文中包含多个对象的各种设
施，比如用US-ASCII之外的字符集来表示主体文本，表示多种字体格式的文本
消息以及表示非文本类的信息，比如图像和声音片段等。
• http://www.ietf.org/rfc/rfc2045.txt
RFC 2045，“Multipurpose Internet Mail Extensions, Part One: Format of Internet
Message Bodies”（“多用途因特网邮件扩展，第一部分：因特网报文主体的格
式”），规定了用来描述MIME格式报文结构的各种首部，其中许多都和HTTP
中的用法类似或相同。
• http://www.ietf.org/rfc/rfc1864.txt
RFC 1864，“The Content-MD5 Header Field”（“Content-MD5首部字段”），提
供了用Content-MD5首部字段来做报文完整性检查的行为及用途方面的一些历史
细节。
• http://www.ietf.org/rfc/rfc3230.txt
RFC 3230，“Instance Digests in HTTP”（“HTTP 中的实例摘要”），描述了对
369 HTTP实体摘要处理的改进，解决了Content-MD5中存在的各种问题。
386 ｜ 第15章
第16章
国际化
387
每天有上亿的人用数百种语言写着各种文档。为了真正实现万维网的目标，HTTP
要能够传输和处理用多种语言和字母表编写的国际性文档。
本章涵盖网站国际化方面的两个主要问题：字符集编码（character set encoding）和
语言标记（language tag）。HTTP应用程序使用字符集编码请求和显示不同字母表中
的文本，它们使用语言标记根据用户所理解的语言来说明并限制内容。而在本章的
最后将讨论多语言URI和日期格式。
本章主要内容：
• 讲解HTTP如何与多语言字母表的方案和相关标准进行交互；
• 快速概览术语、技术和标准，以帮助HTTP编程人员正确理解（熟悉字符编码的
读者可以跳过本节）；
• 解释对各种语言的标准命名系统，以及标准化的语言标记如何描述和选择内容；
• 概述国际性的URI要遵循的规则和注意事项；
• 简要讨论日期格式和其他国际化方面的问题。
16.1 HTTP对国际性内容的支持
HTTP报文中可以承载以任何语言表示的内容，就像它能承载图像、影片，或任何
类型的媒体那样。对HTTP来说，实体主体只是二进制信息的容器而已。
为了支持国际性的内容，服务器需要告知客户端每个文档的字母表和语言，这样客
370 户端才能正确地把文档中的信息解包为字符并把内容呈现给用户。
服务器通过 HTTP 协议的 Content-Type首部中的 charset参数和 Content-
Language首部告知客户端文档的字母表和语言。这些首部描述了实体主体的“信
息盒子”里面装的是什么，如何把内容转换成合适的字符以便显示在屏幕上以及里
面的词语表示的是哪种语言。
同时，客户端需要告知服务器用户理解何种语言，浏览器上安装了何种字母表编码
算法。客户端发送Accept-Charset首部和Accept-Language首部，告知服务器
它理解哪些字符集编码算法和语言以及其中的优先顺序。
下面的HTTP报文中的这些Accept首部可能是母语为法语的人发出的。他喜欢
使用母语，但也会说一点儿英语，他的浏览器支持iso-8859-1西欧字符集编码和
UTF-8 Unicode字符集编码：
Accept-Language: fr, en;q=0.8
Accept-Charset: iso-8859-1, utf-8
388 ｜ 第16章
参数“q=0.8”是质量因子（quality factor），说明英语的优先级（0.8）比法语低
（默认值是1.0）。
16.2 字符集与HTTP
现在我们进入主题，开始研究网站国际化中最重要（且令人困惑）的方面——各国
的字母表和它们的字符集编码。
Web字符集标准很有些令人迷惑。由于必须阅读很多标准文档，其中术语复杂且不
一致，再加上对外语不太熟悉，很多人首次尝试编写国际化的网站软件时，都被搞
糊涂了。本节和下一节应该能让读者更容易地学会在HTTP中使用字符集。
16.2.1 字符集是把字符转换为二进制码的编码
HTTP字符集的值说明如何把实体内容的二进制码转换为特定字母表中的字符。每
个字符集标记都命名了一种把二进制码转换为字符的算法（反之亦然）。字符集标记
在由IANA维护（参见http://www.iana.org/assignments/character-sets）的MIME字
符集注册机构进行了标准化。附录H中概述了其中的很多字符集。
下面的 Content-Type首部告知接收者，传输的内容是一份 HTML 文件，用
charset参数告知接收者使用iso-8859-6 阿拉伯字符集的解码算法把内容中的二进
制码转换为字符： 371
Content-Type: text/html; charset=iso-8859-6
iso-8859-6的编码算法把8位值域映射为拉丁字母和阿拉伯字母，以及数字，标点和
其他符号1。例如，在图16-1中，突出显示的二进制码的值是225，它在iso-8859-6
中被映射到阿拉伯字母“FEH”（读音类似英语字母F）。
HTTP/1.1 200 OK
Content-type: text/html; charset=iso-8859-6 iso-8859-6字符集对11100001