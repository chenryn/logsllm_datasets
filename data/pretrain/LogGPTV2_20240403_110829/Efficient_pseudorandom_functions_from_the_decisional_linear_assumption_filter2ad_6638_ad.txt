Zp.
4.2 Security
Theorem 11 For each k ≥ 1, if the k-Linear Assumption holds, then Fk is a
pseudorandom function ensemble.
12
Proof. The proof is essentially the same as the proof of Theorem 8. Again, we
ﬁrst give an equivalent deﬁnition of f using a less eﬃcient algorithm. This would
not be used in practice, but is more convenient for use in the proof.
Ineﬃcient Evaluation(x, SK) → f (x)
Initialize variables A1 = gc1, . . . , Ak = gck in G.
For i from 1 to n do:
If xi = 0, set Am = Am for each m ∈ [k].
If xi = 1, set Am =(cid:81)k
(cid:96)=1 A
bi
m,(cid:96)
(cid:96)
for each m ∈ [k].
Output f(x) = A1.
We deﬁne a sequence of games, Game 0 through Game n. Each game has a
challenger and an attacker who makes function queries.
m,(cid:96) ∈ Zp for (m, (cid:96)) ∈ [k] × [k] and i from
Game j The challenger ﬁxes values bi
j + 1 to n. To respond to a query, the challenger sets A1, . . . , Ak as a random
function of the ﬁrst j bits of the input and then follows the iterative procedure
above for bits j + 1 to n.
If our function family Fn is not pseudorandom, this implies there exists an
attacker D who can distinguish between two consecutive games j and j + 1 with
non-negligible advantage.
Using the same argument as in the proof of Theorem 8, we note that D can be
used to deﬁne an attacker M who receives 2k-tuples of the form
chosen from Gk and each Bm =(cid:81)k
where either these tuples are uniformly chosen from G2k or (A1, . . . , Ak) is uniformly
for ﬁxed values bm,(cid:96). M will distinguish
(cid:96)=1 Abm,(cid:96)
(cid:96)
(A1, . . . , Ak, B1, . . . , Bk),
between these two cases with non-negligible advantage.
We will show that such an M can be used to break the k-Linear Assumption
using a hybrid argument. We deﬁne new Games 0 through k.
Game j M is given input tuples of the form
(A1, . . . , Ak, ˜B1, . . . , ˜Bj, Bj+1, . . . , Bk),
(cid:81)k
where Am’s and Bm’s are chosen uniformly randomly from G and ˜Bm is equal to
(cid:96)=1 Abm,(cid:96)
(cid:96)
for some ﬁxed values bm,(cid:96).
Since M distinguishes between Game 0 and Game k, it must distinguish be-
tween some Game j and Game j + 1 with non-negligible advantage (assuming k is
polynomial in the security parameter).
A k-Linear attacker can then use M as follows. First, upon receiving one in-
stance of the k-Linear Problem from the k-Linear challenger,
g0, g1, . . . , gk, gr1
1 , . . . , grk
k , gr0
0 ,
the k-Linear attacker generates t instances with the same g0, . . . , gk but diﬀerent
r(cid:48)
0, . . . , r(cid:48)
k values using Lemma 2 repeatedly. The ith instance is then used to gen-
erate the ith tuple to send to M. In the tuple, Am = gr(cid:48)
m for m from 1 to k. Then
m
13
(cid:96)=1 Abm,(cid:96)
(cid:96)
0
bm,(cid:96) are chosen randomly from Zp for (cid:96) from 1 to k and m from 1 to j. For m from
0 . Elements
1 to j, ˜Bm =(cid:81)k
If r0 = r1 + ··· + rk, then the j + 1 element of the tuple is ˜Bj+1 =(cid:81)k
. The j + 1 element of the tuple is set to gr(cid:48)
Bj+2, . . . , Bk are then chosen randomly from G.
(cid:96)=1 Abj+1,(cid:96)
,
where bj+1,(cid:96) satisﬁes gbj+1,(cid:96)
= g0. If r0 is random, then the j +1 element of the tuple
is a random element Bj+1. Hence, when M correctly distinguishes between Game j
and Game j + 1, it will allow the k-Linear attacker to distinguish r0 = r1 +··· + rk
from random. Thus, our function ensemble is pseudorandom under the k-Linear
Assumption. (cid:3)
(cid:96)
(cid:96)
5 Discussion and Performance
The primary advantage of our construction is an increase in security with only
a small cost in eﬃciency. We summarize the relevant properties of our construction
in the following table (with domain {0, 1}n under the k-Linear Assumption):
Computation time
Private key storage
1 exponentiation in G +
k2n multiplications in Zp
G, g, p +
k2n + k elements of Zp
Computational storage
2k elements of Zp +
log p elements of Zq
Table 1: Properties of our construction
The 2k elements of Zp in the computational storage are used to retain all of the
old values of the ai’s in our eﬃcient algorithm while we are computing the updated
ones. The log p elements of Zq come from preprocessing: we compute and store
the values of g2i mod q for i from 0 to log p and use these to speed up the ﬁnal
exponentiation. We do not include the private key in our computational storage
because we have listed it separately.
q, where
q is a 1024-bit prime and p is a 160-bit prime dividing q−1. We used 160-bit inputs
(i.e. n = 160). We chose a random key and computed our function on randomly
chosen inputs. The following table shows our running times as a function of the
parameter k. If we approximate these times with a quadratic polynomial using a
least squares ﬁt, we get the polynomial 441.4 + 1.57k + 39.57k2. Our table also
demonstrates how closely our times mimic this function:
We implemented our construction in a subgroup  of order p in Z∗
k microseconds
1
2
3
4
5
482
605
799
1083
1438
441.4 + 1.57k + 39.57k2
483
603
802
1081
1439
Table 2: Running times for n = 160 and 1 function evaluation
Our implementation was programmed in C using the GNU Multiple-Precision
Library (GMP). It was run on an Intel Core 2 6600 2.40GHz PC running the
14
Ubuntu (Linux-based) operating system and compiled with gcc 4.2.4. The eﬃcient
Evaluation algorithm given above is essentially pseudocode for our implementation
(we also pre-computed the values of g2i for i from 0 to log p to speed up the ﬁnal
exponentiation). These actual times are less important than the general behavior
they demonstrate: for small values of k, the quadratic growth in the computation
time is rather muted by the constant factor, so the increase in running time caused
by increasing k is very mild. In particular, one can increase k from 1 to 2 to rely
on the Linear Assumption instead of DDH, and the running time is only increased
by a factor of roughly 1.255.
We note that the output of our construction (based on the k-Linear Assumption)
could be expanded to k elements, A1 = ga1, . . . , Ak = gak. Pseudorandomness
still holds for this larger output by the same proof. There is a cost in eﬃciency:
computing the larger output takes k exponentiations in G instead of just one.
However, if one needs to generate more pseudorandom output elements, then it is
more eﬃcient to use this version with k outputs instead of computing the version
with one output on k diﬀerent inputs. This is because the computations in Zp are
then done only once instead of k times.
6 Conclusion
We have constructed relatively eﬃcient pseudorandom functions and proven
their security under the progressively weaker k-Linear Assumptions. Our proof
relies on a novel application of two hybrid arguments to accomodate the weaker
assumptions. An increase in the value of k leads to an increase in security (for
generic groups at least) and only a mild quadratic increase in running time and
private key size. Thus, we have made progress towards the important goal of pro-
viding provably secure alternatives to ad hoc constructions without sacriﬁcing too
much eﬃciency.
7 Acknowledgements
We thank Drake Dowsett for help with programming our implementation.
References
[1] L. Adleman. A subexponential algorithm for the discrete logarithm problem
with applications to cryptography. In Proceedings of the 20th IEEE Founda-
tions of Computer Science Symposium, volume 2656, 1979.
[2] M. Bellare, R. Canetti, and H. Krawczyk. Keying hash functions for message
In Advances in Cryptology - CRYPTO ’96, volume 1109 of
authentication.
LNCS, pages 1–16. Springer, 1996.
[3] M. Bellare and S. Goldwasser. New paradigms for digital signatures and mes-
sage authentication based on non-interactive zero knowledge proofs. In Ad-
vances in Cryptology - CRYPTO ’89, volume 435 of LNCS, pages 194–211.
Springer, 1990.
15
[4] E. Biham, R. Chen, A. Joux, P. Carribault, C. Lemuet, and W. Jalby. Colli-
sions of sha-0 and reduced sha-1. In Advances in Cryptology - EUROCRYPT
2005, LNCS.
[5] D. Boneh, X. Boyen, and H. Shacham. Short group signatures. In Advances
in Cryptology - CRYPTO 2004, volume 3152 of LNCS, pages 41–55. Springer,
2004.
[6] S. Brands. An eﬃcient oﬀ-line electronic cash system based on the represen-
tation problem. 1993.
[7] G. Brassard. Modern cryptology. volume 325 of LNCS. Springer, 1988.
[8] R. Cramer and V. Shoup. A practical public key cryptosystem provably se-
cure against adaptive chosen ciphertext attack. In Advances in Cryptology -
CRYPTO ’98, volume 1462 of LNCS, pages 13–25. Springer, 1998.
[9] T. Dierks and C. Allen. The tls protocol version 1.0. rfc 2246. January 1999.
[10] W. Diﬃe and M. Hellman. New directions in cryptography. In IEEE Trans-
actions in Information Theory, volume 22, pages 644–654, 1976.
[11] T. ElGamal. A public-key cryptosystem and a signature scheme based on
discrete logarithms. In Advances in Cryptology - CRYPTO ’ 84, volume 196
of LNCS, pages 10–18. Springer, 1985.
[12] O. Goldreich. Two remarks concerning the goldwasser-micali-rivest signature
In Advances in Cryptology - CRYPTO ’84, volume 263 of LNCS,
scheme.
pages 104–110. Springer, 1987.
[13] O. Goldreich, S. Goldwasser, and S. Micali. On the cryptographic applications
of random functions. In Advances in Cryptology - CRYPTO ’84, volume 196
of LNCS, pages 276–288. Springer, 1985.
[14] O. Goldriech, S. Goldwasser, and S. Micali. How to construct random func-
tions. In Journal of the ACM, volume 33, pages 792–807, 1986.
[15] J. Hastad, R. Impagliazzo, L. A. Levin, and M. Luby. Construction of a
In SIAM Journal on
pseudo-random generator from any one-way function.
Computing, volume 28, pages 1364–1396, 1999.
[16] D. Hofheinz and E. Kiltz. Secure hybrid encryption from weakened key encap-
sulation. In Advances in Cryptology - CRYPTO 2007, volume 4622 of LNCS,
pages 553–571. Springer, 2007.
[17] A. Joux and K. Nguyen. Separating decision diﬃe-hellman from computational
diﬃe-hellman in cryptographic groups. In Journal of Cryptology, volume 16,
pages 239–247, September 2003.
[18] E. Kiltz. Chosen-ciphertext secure key encapsulation based on hashed gap
decisional diﬃe-hellman. In Proceedings of IACR PKC 2007, volume 4450 of
LNCS, pages 282–297, 2007.
[19] D. E. Knuth. In The Art of Computer Programming, volume 3, pages 575–576,
1973.
[20] M. Luby. In Pseudo-randomness and applications. Princeton University Press,
1996.
16
[21] A. Menezes, T. Okamoto, and S. Vanstone. Reducing elliptic curve logarithms
to logarithms in a ﬁnite ﬁeld. In IEEE Transactions on Information Theory,
volume 39, pages 1639–1646, 1993.
[22] S. Micali, M. Rabin, and S. Vadhan. Veriﬁable random functions. In Proceed-
ings of 40th Annual Symposium on Foundations of Computer Science, pages
120–130, 1999.
[23] M. Naor and O. Reingold. Number-theoretic constructions of eﬃcient pseudo-
random functions. In 38th Annual Symposium on Foundations of Computer
Science, pages 458–467, 1997.
[24] J. Pollard. Monte carlo methods for index computations (mod p). In Mathe-
matics of Computation, volume 32, pages 918–924, 1978.
[25] A. Razborov and S. Rudich. Natural proofs.
System Sciences, volume 55, pages 24–35, 1997.
In Journal of Computer and
[26] H. Shacham. A cramer-shoup encryption scheme from the linear assumption
and from progressively weaker linear variants. 2007.
[27] M. Stadler. Publicly veriﬁable secret sharing.
In Advances in Cryptology -
EUROCRYPT ’96, volume 1070 of LNCS, pages 190–199. Springer, 1996.
[28] L. Valiant. A theory of the learnable. In Communications of the ACM, vol-
ume 27, pages 1134–1142, 1984.
[29] X. Wang and H. Yu. How to break md5 and other hash functions. In Ad-
vances in Cryptology - EUROCRYPT 2005, volume 3494 of LNCS, pages 19–
35. Springer, 2005.
17