parsing its subsequent application-level messages is only to
ﬁnd the end of those messages. Hence, parsing for those
messages can be even further streamlined.
While specifying all application messages seems daunting,
if an application level protocol were speciﬁed in a standard
and formalized format (such as our policy language-like for-
mat — see Section 5), we could automatically extract pay-
load format speciﬁcations and vulnerability state machines
from that format to our policy language. On the other hand,
if a Shield designer knows for a fact that scattered arrivals
of a message do never happen (e.g., single rather than mul-
tiple recvf rom() calls when receiving a single application
message in a UDP server implementation), then only events
involved in the vulnerability state machine need to be spec-
iﬁed.
4.2 Out-of-Order Arrivals
When an application-level protocol runs on top of UDP,
its datagrams can arrive out of order. Applications that care
about the ordering of these datagrams will have a sequence
number ﬁeld in their application-level protocol headers. For
Shield to properly carry out its exploit detection functions,
Shield copies the out-of-order datagrams, and passes them
on to the applications. This way, Shield can examine the
packets in their intended sequence. Shield sets the upper
limit of the number of copied datagrams to be the maximum
number of out-of-order datagrams that the application-level
protocol can handle. Hence, this maximum also needs to be
expressed in the policy descriptions, as does the sequence
number location.
4.3 Application Level Fragmentation
Shield runs on top of the transport layer. Hence, Shield
does not need to deal with network-layer fragmentation and
re-assembly. Nonetheless, some application-level protocols
use application data units and perform application level
fragmentation and re-assembly. For protocols over TCP,
bytes are received in order. For protocols over UDP, Shield
copies their out-of-order datagrams to retain the correct
packet sequence (see the above section). Therefore receiv-
ing and processing application level fragments is no diﬀerent
from processing partially arrived data, as explained in Sec-
tion 4.1. However, the Spec needs to contain the location of
the application-level fragment ID in the message, so that a
fragment is not treated as an entire message event.
5. SHIELD POLICY LANGUAGE
In this section, we present the Shield policy language
which is used to describe the vulnerabilities and their coun-
termeasures for an application.
Figures 3, 4, and 5 show some examples of our policy lan-
guage usage. They are policy scripts for the vulnerabilities
behind Slammer [40], CodeRed [7], and MSBlast [24], re-
spectively. Please note that these scripts are written based
on the knowledge of the vulnerabilities rather than their re-
spective attack instances.
# Vulnerability behind Slammer
SHIELD (Vulnerability_Behind_Slammer, UDP, (1434))
# 0 offset, size of 1 byte
MSG_TYPE_LOCATION = (0, 1);
INITIAL_STATE S_WaitForSSRPRequest;
FINAL_STATE S_Final;
# MsgType = 0x4
EVENT E_SSRP_Request = (0x4, INCOMING);
STATE_MACHINE = {
(S_WaitForSSRPRequest, E_SSRP_Request, H_SSRP_Request),
};
HANDLER H_SSRP_Request (DONT_CARE) {
COUNTER legalLimit = 128;
# MSG_LEN returns legalLimit + 1 when legalLimit is exceeded
COUNTER c = MSG_LEN (legalLimit);
IF (c > legalLimit)
DROP;
RETURN (S_FINAL);
FI
RETURN (S_Final);
};
Figure 3: Policy description of the vulnerability be-
hind Slammer
# Shield for vulnerability behind CodeRed
SHIELD(Vulnerability_Behind_CodeRed, TCP, (80))
INITIAL_STATE
FINAL_STATE
S_WaitForGetRequest;
S_Final;
#
MSG_TYPE_LOCATION= (0, 1) WORD;
MSG_BOUNDARY = "\r\n\r\n";
EVENT E_GET_REQUEST = ("GET", INCOMING);
STATE_MACHINE = {
(S_WaitForGetRequest, E_GET_Request, H_Get_Request),
};
PAYLOAD_STRUCT {
WORDS(1)
WORDS(1)
BYTES(REST) dummy2,
method,
URI,
} P_Get_Request;
HANDLER H_Get_Request (P_Get_Request) {
COUNTER legalLimit = 239;
COUNTER c = 0;
# \?(.*)$ is the regular expression to retrieve the
# query string in the URI
# MATCH_STR_LEN returns legalLimit + 1 when legalLimit is exceeded
c = MATCH_STR_LEN (>>P_Get_Request.URI, "\?(.*)$", legalLimit);
IF (c > legalLimit)
# Exploit!
TEARDOWN_SESSION;
RETURN (S_FINAL);
FI
RETURN (S_FINAL);
};
Figure 4: Policy description of the vulnerability be-
hind CodeRed
There are two parts to the policy speciﬁcation in the
Shield language. The ﬁrst part is static and includes states,
# SHIELD (Name, Transport_Protocol, (port-list))
SHIELD (Vulnerability_Behind_MSBlast, TCP, (135, 139, 445))
SESSION_ID_LOCATION = (12, 4); # offset 12, 4 bytes
MSG_TYPE_LOCATION = (2, 1);
# offset 2, 1 byte
S_Final;
INITIAL_STATE S_WaitForRPCBind;
FINAL_STATE
STATE
STATE
STATE
STATE
S_WaitForRPCBindAck;
S_WaitForRPCAlterContextResponse;
S_WaitForRPCRequest;
S_WaitForSessionTearDown;
= (0x0B, INCOMING);
# EVENT eventName = (, )
EVENT E_RPCBind
EVENT E_RPCBindAck = (0x0C, OUTGOING);
EVENT E_RPCBindNak = (0x0D, OUTGOING);
EVENT E_RPCAlterContext = (0x0E, INCOMING);
EVENT E_RPCAlterContextResponse = (0x0F, OUTGOING);
EVENT E_RPCRequest = (0x0,
EVENT E_RPCShutdown = (0x11, OUTGOING);
EVENT E_RPCCancel = (0x12, INCOMING);
EVENT E_RPCOrphaned = (0x13, INCOMING);
INCOMING);
STATE_MACHINE = {
# (State, Event, Handler),
(S_WaitForRPCBind, E_RPCBind, H_RPCBind),
(S_WaitForRPCBindAck, E_RPCBindAck, H_RPCBindAck),
(S_WaitForRPCRequest, E_RPCRequest, H_RPCRequest),
...
};
# payload parsing instruction for P_Context
PAYLOAD_STRUCT {
SKIP BYTES(6)
BYTES(1)
SKIP BYTES(1)
BYTES(16)
SKIP BYTES(4)
SKIP BYTES(numTransferContexts * 20) transferContexts,
UUID_RemoteActivation,
numTransferContexts,
version,
dummy1,
dummy2,
PAYLOAD_STRUCT {
SKIP BYTES(24)
BYTES(1)
SKIP BYTES(3)
P_Context[numContexts]
...
dummy1,
numContexts,
dummy2,
contexts,
} P_RPCBind;
HANDLER H_S_RPCBind (P_RPCBind)
{
# if invoking the RemoteActivation RPC call
IF (>>P_RPCBind.contexts[0]
== 0xB84A9F4D1C7DCF11861E0020AF6E7C57)
RETURN (S_WaitForRPCBindAck);
FI
RETURN (S_Final);
};
HANDLER H_RPCBindAck (P_RPCBindAck)
{
RETURN (S_WaitForRPCRequest);
};
HANDLER H_RPCRequest (P_RPCRequest)
{
IF (>>P_RPCRequest.bufferSize > 1023)
TEARDOWN_SESSION;
PRINT ("MSBlast!");
RETURN (S_Final);
FI
RETURN (S_WaitForSessionTearDown);
};
# other PAYLOAD_STRUCTs/Handlers
# are
not included here ...
} P_Context;
Figure 5: Excerpt from the policy description of the vulnerability behind MSBlast
events, state machine transitions, and generic application
level protocol information such as ports used, the locations
of the event type, session ID, sequence number or fragment
ID in a packet, and the message boundary marker. This
part of the policy speciﬁcation is loaded into the Spec data
structure directly by the Policy Loader (Figure 2), and is
independent of runtime conditions.
The second part of the policy speciﬁcation is for runtime
interpretation during exploit checking. This includes the
handler speciﬁcation and payload parsing instructions (i.e.,
PAYLOAD STRUCT deﬁnitions in the ﬁgures). The role of
the handler is to examine the packet payload and pinpoint
any exploit in the current packet payload, or to record the
session context that is needed for a later determinination of
exploit occurrence. To examine a packet, a handler needs
to follow the policy’s payload parsing instructions.
When a policy is loaded, the Policy Loader parses the
syntax of the handlers and the payload format, and stores
the syntax tree in the Spec for run-time interpretation.
5.1 Payload Speciﬁcation
The PAYLOAD STRUCT deﬁnitions specify how to parse
an application-level message. Shield needs not parse out all
the ﬁelds of a payload, as in the actual applications, but
only the ﬁelds relevant to the vulnerability. We allow the
policy writers to simplify payload parsing by clustering in-
signiﬁcant ﬁelds together as a single dummy ﬁeld of the re-
quired number of bytes (e.g., ﬁeld dummy1 of P RPC Bind
in Figure 5). Such ﬁelds are marked as skippable during
parsing using the keyword SKIP, so that no copy-buﬀer
is maintained for such ﬁelds (Section 4.1). From examin-
ing a number of application level protocols, we have found
that payload parsing speciﬁcation only needs to support a
limited set of types for ﬁelds, including bytes of any size
(i.e., BYTES(num) where “num” could be a variable size
or an expression), words of any size (i.e., WORDS(num))
for text-based protocols, (multi-dimensional) arrays of PAY-
LOAD STRUCT’s, and booleans.
5.2 Handler Speciﬁcation
The Shield language for handler speciﬁcation is very sim-
ple, and highly specialized for our purpose. Variables have
only two scopes: they are either local to a handler or “global”
within a session across its handlers. There are only four data
types: BOOL for booleans, COUNTER for whole numbers,
byte arrays such as “BYTES(numBytes)”, and word arrays
such as “WORD(numWords)”. We also have built-in vari-
ables for handlers to use, such as SESSION ID.
Built-in functions include DROP , TEARDOWN SESSION,
REGISTER PORT, length-based functions such as MSG LEN
(Figure 3) and MATCH STR LEN (Figure 4), and regular
expression functions that may be needed for text-based pro-
tocols. DROP drops a packet while TEARDOWN SESSION
closes all sockets associated with a session. The regular ex-
pression functions are data stream-based rather than string
buﬀer-based. That is, they must be able to cope with scat-
tered message arrivals. Similarly, length functions are also
stream-based with a required parameter of “stop count”
(e.g., “legalLimit” in our example scripts) to facilitate the
handling of buﬀer overrun-type vulnerabilities. When the
length reaches “stop count”, counting stops and returns
“stop count”+1. This way, Shield will not count and main-
tain state beyond what is necessary in the case of buﬀer-
overrun exploits.
The syntax “(cid:192)payload” instructs Shield to parse and to
refer to the bytes that represent the “payload” of the packet,
according to the parsing instruction deﬁned for “payload”
(i.e., there should be a deﬁnition: “PAYLOAD STRUCT
{...} payload;” earlier in the policy decription). The parsed
ﬁelds of a PAYLOAD STRUCT are treated as local variables
for that handler. Within the handler, we allow assignments,
if-statements, iterators, and return-statements that exit the
handler and indicate the next state the session should be in.
The iterators, rather than being traditional general-purpose
for-loops, are used for parsing iterative payload structures,
such as arrays of items. For example, given “FOREACH
(item IN (cid:192) Payload.itemArray) { ... }”, the interpreter
parses items of the “itemArray” ﬁeld of the “Payload” it-
eratively, according to the “Payload” deﬁnition, and along
the way, performs some operations on the bytes representing
each “item”. Note that the interpreter does not keep state
across items.
During handler interpretation, the current payload being
parsed may not be completely received. In this case, we save
the execution state of the handler as part of the session state
so that when new data arrives, the handler’s execution can
be resumed. This is very much like call continuation.
In
our case, the continuation state includes a queue of current
handler statements being executed because of potentially
nested statements and the parsing state (Section 4.1) for
the payload — that is, the current ﬁeld of the payload being
parsed, and the bytes read for that ﬁeld.
The restrictive nature of our language makes it a safer lan-
guage than general-purpose languages. While our language
is restrictive, we ﬁnd it suﬃcient for all of the vulnerabilities
that we have worked with and the application level protocols
that we have examined. However, it is still evolving as we
gain experience from shielding more vulnerabilities and pro-
tocols; and in the process, we are also investigating how we
may incorporate techniques from previous research in pro-
tocol, packet, or data structure speciﬁcation languages [21,