# Opaque Control-Flow Integrity

**Authors:**
- Vishwath Mohan<sup>∗</sup>, Per Larsen<sup>†</sup>, Stefan Brunthaler<sup>†</sup>, Kevin W. Hamlen<sup>∗</sup>, and Michael Franz<sup>†</sup>
- <sup>∗</sup>{vishwath.mohan, hamlen}@utdallas.edu, The University of Texas at Dallas
- <sup>†</sup>{perl, s.brunthaler, franz}@uci.edu, University of California, Irvine

## Abstract
We present a new binary software randomization and Control-Flow Integrity (CFI) enforcement system, Opaque CFI (O-CFI), which is the first to efficiently resist code-reuse attacks launched by informed adversaries who possess full knowledge of the in-memory code layout of victim programs. O-CFI mitigates recent implementation disclosure attacks, where adversaries exfiltrate in-memory code details to prepare code-reuse attacks, such as Return-Oriented Programming (ROP) attacks, that bypass fine-grained randomization defenses. Traditional fine-grained randomization assumes that the randomized locations of abusable code gadgets remain secret, but this assumption is undermined by implementation-aware attacks.

O-CFI overcomes this weakness through a novel combination of fine-grained code-randomization and coarse-grained control-flow integrity checking. It conceals the graph of hijackable control-flow edges even from attackers who can view the complete stack, heap, and binary code of the victim process. For maximal efficiency, the integrity checks are implemented using instructions that will soon be hardware-accelerated on commodity x86-x64 processors. The approach is highly practical since it does not require a modified compiler and can protect legacy binaries without access to source code. Experiments using our fully functional prototype implementation show that O-CFI provides significant probabilistic protection against ROP attacks launched by adversaries with complete code layout knowledge, and exhibits only 4.7% mean performance overhead on current hardware (with further overhead reductions expected on forthcoming Intel processors).

## I. Motivation
Code-reuse attacks have become a mainstay of software exploitation over the past several years, due to the rise of data execution protections that nullify traditional code-injection attacks. Instead of injecting malicious payload code directly onto the stack or heap, where modern data execution protections block it from being executed, attackers now inject addresses of existing in-memory code fragments (gadgets) onto victim stacks, causing the victim process to execute its own binary code in an unanticipated order. With a sufficiently large victim code section, the pool of exploitable gadgets becomes arbitrarily expressive, facilitating the construction of arbitrary attack payloads without the need for code-injection. Such payload construction has even been automated.

This has motivated extensive work on defenses against code-reuse threats. Prior defenses can generally be categorized into Control-Flow Integrity (CFI) and artificial software diversity. CFI restricts all of a program’s runtime control-flows to a graph of whitelisted control-flow edges, usually derived from the semantics of the program source code or a conservative disassembly of its binary code. Fine-grained CFI monitors indirect control-flows precisely, providing high security but often incurring high performance overheads. Coarse-grained CFI trades some security for better performance by reducing the precision of the checks, but this has proved dangerous, as minor relaxations can be exploited to effect attacks.

Artificial software diversity offers a different but complementary approach that randomizes programs so that attacks succeeding against one program instance have a very low probability of success against other instances. One of the simplest forms of artificial diversity is Address Space Layout Randomization (ASLR), which randomizes the base addresses of program segments at load-time. However, ASLR does not provide sufficient entropy to preserve memory secrecy, and there are numerous successful derandomization attacks against it. Finer-grained diversity techniques, such as binary-level Self-Transforming Instruction Relocation (STIR) and compilers with randomized code-generation, achieve higher entropy by randomizing the relative distances between all code points.

Recently, a new wave of implementation disclosure attacks has threatened to undermine fine-grained artificial diversity defenses. These attacks exploit information leak vulnerabilities to read memory pages of victim processes, violating the memory secrecy assumptions of artificial diversity and rendering their defenses ineffective. Finding and closing all information leaks is prohibitively difficult for many large software products, making these attacks a dangerous development in the cyber-threat landscape.

This paper presents Opaque CFI (O-CFI), a new approach to coarse-grained CFI that strengthens fine-grained artificial diversity to withstand implementation disclosure attacks. The core of O-CFI is a new form of control-flow check that conceals the graph of abusable control-flow edges even from attackers who have complete read-access to the randomized binary code, the stack, and the heap of victim processes. Artificial diversification varies the set of unprotected edges between program instances, maintaining the probabilistic guarantees of fine-grained diversity.

Experiments show that O-CFI enjoys performance overheads comparable to standard fine-grained diversity and non-opaque, coarse-grained CFI. Moreover, O-CFI’s control-flow checking logic is implemented using Intel x86/x64 memory-protection extensions (MPX) that are expected to be hardware-accelerated in commodity CPUs from 2015 onwards, leading to even better performance in the near future.

## II. Threat Model
Our work is motivated by the emergence of attacks against fine-grained diversity and coarse-grained control-flow integrity. We introduce these attacks and distill them into a single, unified threat model.

### A. Bypassing Coarse-Grained CFI
Ideally, CFI permits only programmer-intended control-flow transfers during a program’s execution. The typical approach is to assign a unique ID to each permissible indirect control-flow target and check the IDs at runtime. This introduces performance overhead proportional to the degree of the graph. Fine-grained CFI implements a dynamically computed shadow stack, incurring high overheads. To avoid this, coarse-grained CFI implementations use a reduced-degree, static approximation of the control-flow graph, merging identifiers at the cost of reduced security. Recent work has shown that these optimizations open exploitable security holes, allowing ROP chains to bypass CFI.

### B. Just-In-Time Code Reuse
Until recently, most threat models for CFI and artificial diversity assumed that the memory contents of protected processes were hidden from attackers. The advent of Just-In-Time ROP (JIT-ROP) demonstrated that this assumption might be unrealistic due to the existence of implementation disclosure vulnerabilities. Using heap feng shui, JIT-ROP places a buffer next to a string and a button object. By overflowing the buffer, the string length is set arbitrarily high, allowing the attacker to read any byte in the virtual address space. Parsing the button object through the overflowed string yields a reference to a mapped code page. Attackers can then recursively discover enough gadgets to mount a ROP attack, defeating fine-grained randomization defenses.

### C. Blind ROP
Blind Return Oriented Programming (BROP) targets vulnerable Internet-facing services, such as web-servers, that restart after a crash. It uses a buffer overflow to overwrite the stack byte-by-byte, distinguishing correct guesses from incorrect ones by observing whether the server continues responding or crashes. By remotely inferring secret stack cookie values, attackers can bypass stack guards and discover gadget locations. Once the write system function is located, the entire code section can be exfiltrated, and a traditional ROP attack can be launched, defeating ASLR, DEP, stack canaries, and fine-grained code randomization on 64-bit systems.

### D. Side Channel Disclosures
Recent work has shown that under certain circumstances, gadget locations can be leaked through side channels, such as timing channels. This underscores the difficulty of fully protecting software against all implementation disclosure vulnerabilities. Complete protection entails mitigating all side channel information leaks, which is widely recognized as prohibitively difficult for most non-trivial software products.

### E. Assumptions
Given these realities, we adopt a conservative threat model that assumes attackers will eventually find and disassemble all code pages in victim processes. Our threat model assumes that the adversary knows the complete in-memory code layout, including the locations of any gadgets required to launch a ROP attack. We also assume that the attacker can read and write the full contents of the heap and stack, as well as any data structures used by the dynamic loader. We assume that data execution protection is activated, so that code page permissions can be maintained as either writable or executable but not both. However, we assume that attackers cannot safely perform a comprehensive, linear scan of virtual memory, as defenders may place unmapped guard pages at random locations. Successful attacks against our system are those that reliably traverse control-flow edges not intended by the original program semantics without triggering an invalid access violation.

## III. O-CFI Overview
O-CFI combines insights from CFI and automated software diversity. It extends CFI with a new, coarse-grained CFI enforcement strategy inspired by bounds-checking, which validates control-flow transfers without divulging the bounds against which their destinations are checked. Bounds-checking is fast, the bounds are easier to conceal than arbitrary gadget locations, and the bounds are randomizable. This imbues CFI and fine-grained software diversity with an additional layer of protection against code-reuse attacks aided by implementation disclosures. As a result, O-CFI enjoys performance similar to coarse-grained CFI, with probabilistic security guarantees similar to fine-grained artificial diversity in the absence of implementation disclosures.