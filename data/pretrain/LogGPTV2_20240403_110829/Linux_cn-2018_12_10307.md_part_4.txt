.
> 
> **问题**
> 
> 
> 1. 在断点测试案例中，根据你在 IDT 中如何初始化断点条目的不同情况（即：你的从 `trap_init` 到 `SETGATE` 的调用），既有可能产生一个断点异常，也有可能产生一个一般保护故障。为什么？为了能够像上面的案例那样工作，你需要如何去设置它，什么样的不正确设置才会触发一个一般保护故障？
> 2. 你认为这些机制的意义是什么？尤其是要考虑 `user/softint` 测试程序的工作原理。
> 
> 
> 
#### 系统调用
用户进程请求内核为它做事情就是通过系统调用来实现的。当用户进程请求一个系统调用时，处理器首先进入内核模式，处理器和内核配合去保存用户进程的状态，内核为了完成系统调用会运行有关的代码，然后重新回到用户进程。用户进程如何获得内核的关注以及它如何指定它需要的系统调用的具体细节，这在不同的系统上是不同的。
在 JOS 内核中，我们使用 `int` 指令，它将导致产生一个处理器中断。尤其是，我们使用 `int $0x30` 作为系统调用中断。我们定义常量 `T_SYSCALL` 为 48（0x30）。你将需要去设置中断描述符表，以允许用户进程去触发那个中断。注意，那个中断 0x30 并不是由硬件生成的，因此允许用户代码去产生它并不会引起歧义。
应用程序将在寄存器中传递系统调用号和系统调用参数。通过这种方式，内核就不需要去遍历用户环境的栈或指令流。系统调用号将放在 `%eax` 中，而参数（最多五个）将分别放在 `%edx`、`%ecx`、`%ebx`、`%edi`、和 `%esi` 中。内核将在 `%eax` 中传递返回值。在 `lib/syscall.c` 中的 `syscall()` 中已为你编写了使用一个系统调用的汇编代码。你可以通过阅读它来确保你已经理解了它们都做了什么。
> 
> **练习 7**、在内核中为中断向量 `T_SYSCALL` 添加一个服务程序。你将需要去编辑 `kern/trapentry.S` 和 `kern/trap.c` 的 `trap_init()`。还需要去修改 `trap_dispatch()`，以便于通过使用适当的参数来调用 `syscall()` （定义在 `kern/syscall.c`）以处理系统调用中断，然后将系统调用的返回值安排在 `%eax` 中传递给用户进程。最后，你需要去实现 `kern/syscall.c` 中的 `syscall()`。如果系统调用号是无效值，确保 `syscall()` 返回值一定是 `-E_INVAL`。为确保你理解了系统调用的接口，你应该去阅读和掌握 `lib/syscall.c` 文件（尤其是行内汇编的动作），对于在 `inc/syscall.h` 中列出的每个系统调用都需要通过调用相关的内核函数来处理A。
> 
> 
> 在你的内核中运行 `user/hello` 程序（make run-hello）。它应该在控制台上输出 `hello, world`，然后在用户模式中产生一个页故障。如果没有产生页故障，可能意味着你的系统调用服务程序不太正确。现在，你应该有能力成功通过 `testbss` 测试。
> 
> 
> 
.
> 
> 小挑战！使用 `sysenter` 和 `sysexit` 指令而不是使用 `int 0x30` 和 `iret` 来实现系统调用。
> 
> 
> `sysenter/sysexit` 指令是由 Intel 设计的，它的运行速度要比 `int/iret` 指令快。它使用寄存器而不是栈来做到这一点，并且通过假定了分段寄存器是如何使用的。关于这些指令的详细内容可以在 Intel 参考手册 2B 卷中找到。
> 
> 
> 在 JOS 中添加对这些指令支持的最容易的方法是，在 `kern/trapentry.S` 中添加一个 `sysenter_handler`，在它里面保存足够多的关于用户环境返回、设置内核环境、推送参数到 `syscall()`、以及直接调用 `syscall()` 的信息。一旦 `syscall()` 返回，它将设置好运行 `sysexit` 指令所需的一切东西。你也将需要在 `kern/init.c` 中添加一些代码，以设置特殊模块寄存器（MSRs）。在 AMD 架构程序员手册第 2 卷的 6.1.2 节中和 Intel 参考手册的 2B 卷的 SYSENTER 上都有关于 MSRs 的很详细的描述。对于如何去写 MSRs，在[这里](http://ftp.kh.edu.tw/Linux/SuSE/people/garloff/linux/k6mod.c)你可以找到一个添加到 `inc/x86.h` 中的 `wrmsr` 的实现。
> 
> 
> 最后，`lib/syscall.c` 必须要修改，以便于支持用 `sysenter` 来生成一个系统调用。下面是 `sysenter` 指令的一种可能的寄存器布局：
> 
> 
> 
> ```
> eax - syscall number
> edx, ecx, ebx, edi - arg1, arg2, arg3, arg4
> esi - return pc
> ebp - return esp
> esp - trashed by sysenter
> ```
> 
> GCC 的内联汇编器将自动保存你告诉它的直接加载进寄存器的值。不要忘了同时去保存（`push`）和恢复（`pop`）你使用的其它寄存器，或告诉内联汇编器你正在使用它们。内联汇编器不支持保存 `%ebp`，因此你需要自己去增加一些代码来保存和恢复它们，返回地址可以使用一个像 `leal after_sysenter_label, %%esi` 的指令置入到 `%esi` 中。
> 
> 
> 注意，它仅支持 4 个参数，因此你需要保留支持 5 个参数的系统调用的旧方法。而且，因为这个快速路径并不更新当前环境的 trap 帧，因此，在我们添加到后续实验中的一些系统调用上，它并不适合。
> 
> 
> 在接下来的实验中我们启用了异步中断，你需要再次去评估一下你的代码。尤其是，当返回到用户进程时，你需要去启用中断，而 `sysexit` 指令并不会为你去做这一动作。
> 
> 
> 
#### 启动用户模式
一个用户程序是从 `lib/entry.S` 的顶部开始运行的。在一些配置之后，代码调用 `lib/libmain.c` 中的 `libmain()`。你应该去修改 `libmain()` 以初始化全局指针 `thisenv`，使它指向到这个环境在数组 `envs[]` 中的 `struct Env`。（注意那个 `lib/entry.S` 中已经定义 `envs` 去指向到在 Part A 中映射的你的设置。）提示：查看 `inc/env.h` 和使用 `sys_getenvid`。
`libmain()` 接下来调用 `umain`，在 hello 程序的案例中，`umain` 是在 `user/hello.c` 中。注意，它在输出 ”`hello, world`” 之后，它尝试去访问 `thisenv->env_id`。这就是为什么前面会发生故障的原因了。现在，你已经正确地初始化了 `thisenv`，它应该不会再发生故障了。如果仍然会发生故障，或许是因为你没有映射 `UENVS` 区域为用户可读取（回到前面 Part A 中 查看 `pmap.c`）；这是我们第一次真实地使用 `UENVS` 区域）。
> 
> **练习 8**、添加要求的代码到用户库，然后引导你的内核。你应该能够看到 `user/hello` 程序会输出 `hello, world` 然后输出 `i am environment 00001000`。`user/hello` 接下来会通过调用 `sys_env_destroy()`（查看`lib/libmain.c` 和 `lib/exit.c`）尝试去“退出”。由于内核目前仅支持一个用户环境，它应该会报告它毁坏了唯一的环境，然后进入到内核监视器中。现在你应该能够成功通过 `hello` 的测试。
> 
> 
> 
#### 页故障和内存保护
内存保护是一个操作系统中最重要的特性，通过它来保证一个程序中的 bug 不会破坏其它程序或操作系统本身。
操作系统一般是依靠硬件的支持来实现内存保护。操作系统会告诉硬件哪些虚拟地址是有效的，而哪些是无效的。当一个程序尝试去访问一个无效地址或它没有访问权限的地址时，处理器会在导致故障发生的位置停止程序运行，然后捕获内核中关于尝试操作的相关信息。如果故障是可修复的，内核可能修复它并让程序继续运行。如果故障不可修复，那么程序就不能继续，因为它绝对不会跳过那个导致故障的指令。
作为一个可修复故障的示例，假设一个自动扩展的栈。在许多系统上，内核初始化分配一个单栈页，然后如果程序发生的故障是去访问这个栈页下面的页，那么内核会自动分配这些页，并让程序继续运行。通过这种方式，内核只分配程序所需要的内存栈，但是程序可以运行在一个任意大小的栈的假像中。
对于内存保护，系统调用中有一个非常有趣的问题。许多系统调用接口让用户程序传递指针到内核中。这些指针指向用户要读取或写入的缓冲区。然后内核在执行系统调用时废弃这些指针。这样就有两个问题：
1. 内核中的页故障可能比用户程序中的页故障多的多。如果内核在维护它自己的数据结构时发生页故障，那就是一个内核 bug，而故障服务程序将使整个内核（和整个系统）崩溃。但是当内核废弃了由用户程序传递给它的指针后，它就需要一种方式去记住那些废弃指针所导致的页故障其实是代表用户程序的。
2. 一般情况下内核拥有比用户程序更多的权限。用户程序可以传递一个指针到系统调用，而指针指向的区域有可能是内核可以读取或写入而用户程序不可访问的区域。内核必须要非常小心，不能被废弃的这种指针欺骗，因为这可能导致泄露私有信息或破坏内核的完整性。
由于以上的原因，内核在处理由用户程序提供的指针时必须格外小心。
现在，你可以通过使用一个简单的机制来仔细检查所有从用户空间传递给内核的指针来解决这个问题。当一个程序给内核传递指针时，内核将检查它的地址是否在地址空间的用户部分，然后页表才允许对内存的操作。
这样，内核在废弃一个用户提供的指针时就绝不会发生页故障。如果内核出现这种页故障，它应该崩溃并终止。
> 
> **练习 9**、如果在内核模式中发生一个页故障，修改 `kern/trap.c` 去崩溃。
> 
> 
> 提示：判断一个页故障是发生在用户模式还是内核模式，去检查 `tf_cs` 的低位比特即可。
> 
> 
> 阅读 `kern/pmap.c` 中的 `user_mem_assert` 并在那个文件中实现 `user_mem_check`。
> 
> 
> 修改 `kern/syscall.c` 去常态化检查传递给系统调用的参数。
> 
> 
> 引导你的内核，运行 `user/buggyhello`。环境将被毁坏，而内核将不会崩溃。你将会看到：
> 
> 
> 
> ```
> [00001000] user_mem_check assertion failure for va 00000001
> [00001000] free env 00001000
> Destroyed the only environment - nothing more to do!
> ```
> 
> 最后，修改在 `kern/kdebug.c` 中的 `debuginfo_eip`，在 `usd`、`stabs`、和 `stabstr` 上调用 `user_mem_check`。如果你现在运行 `user/breakpoint`，你应该能够从内核监视器中运行回溯，然后在内核因页故障崩溃前看到回溯进入到 `lib/libmain.c`。是什么导致了这个页故障？你不需要去修复它，但是你应该明白它是如何发生的。
> 
> 
> 
注意，刚才实现的这些机制也同样适用于恶意用户程序（比如 `user/evilhello`）。
> 
> **练习 10**、引导你的内核，运行 `user/evilhello`。环境应该被毁坏，并且内核不会崩溃。你应该能看到：
> 
> 
> 
> ```
> [00000000] new env 00001000
> ...
> [00001000] user_mem_check assertion failure for va f010000c
> [00001000] free env 00001000
> ```
> 
> 
**本实验到此结束。**确保你通过了所有的等级测试，并且不要忘记去写下问题的答案，在 `answers-lab3.txt` 中详细描述你的挑战练习的解决方案。提交你的变更并在 `lab` 目录下输入 `make handin` 去提交你的工作。
在动手实验之前，使用 `git status` 和 `git diff` 去检查你的变更，并不要忘记去 `git add answers-lab3.txt`。当你完成后，使用 `git commit -am 'my solutions to lab 3’` 去提交你的变更，然后 `make handin` 并关注这个指南。
---
via: 
作者：[csail.mit](https://pdos.csail.mit.edu) 选题：[lujun9972](https://github.com/lujun9972) 译者：[qhwdw](https://github.com/qhwdw) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出