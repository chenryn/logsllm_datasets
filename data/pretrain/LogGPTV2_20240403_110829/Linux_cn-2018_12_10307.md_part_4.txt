### 问题

1. 在断点测试案例中，根据你在中断描述符表（IDT）中如何初始化断点条目的不同情况（即从 `trap_init` 到 `SETGATE` 的调用），既有可能产生一个断点异常，也有可能产生一个一般保护故障。为什么？为了能够像上面的案例那样工作，你需要如何去设置它？什么样的不正确设置才会触发一个一般保护故障？

2. 你认为这些机制的意义是什么？尤其是要考虑 `user/softint` 测试程序的工作原理。

### 系统调用

用户进程通过系统调用来请求内核执行特定任务。当用户进程发起一个系统调用时，处理器首先进入内核模式，保存用户进程的状态，并运行相关代码以完成系统调用，最后返回到用户进程。用户进程如何获得内核的关注以及指定所需的具体系统调用，在不同的系统上有所不同。

在 JOS 内核中，我们使用 `int` 指令来触发处理器中断。具体来说，我们使用 `int $0x30` 作为系统调用中断，并定义常量 `T_SYSCALL` 为 48（0x30）。你需要设置中断描述符表（IDT），以允许用户进程触发该中断。注意，中断 0x30 并不是由硬件生成的，因此允许用户代码生成它并不会引起歧义。

应用程序将在寄存器中传递系统调用号和参数。系统调用号放在 `%eax` 中，而最多五个参数分别放在 `%edx`、`%ecx`、`%ebx`、`%edi` 和 `%esi` 中。内核将通过 `%eax` 传递返回值。在 `lib/syscall.c` 中已经为你编写了使用系统调用的汇编代码。你可以阅读这些代码以确保理解其功能。

#### 练习 7

在内核中为中断向量 `T_SYSCALL` 添加一个服务程序。你需要编辑 `kern/trapentry.S` 和 `kern/trap.c` 中的 `trap_init()`。还需要修改 `trap_dispatch()`，以便通过适当的参数调用 `syscall()`（定义在 `kern/syscall.c` 中）处理系统调用中断，并将系统调用的返回值安排在 `%eax` 中传递给用户进程。最后，实现 `kern/syscall.c` 中的 `syscall()` 函数。如果系统调用号无效，确保 `syscall()` 返回 `-E_INVAL`。为确保你理解系统调用接口，请阅读和掌握 `lib/syscall.c` 文件（特别是行内汇编的动作），并为 `inc/syscall.h` 中列出的每个系统调用调用相应的内核函数。

在你的内核中运行 `user/hello` 程序（make run-hello）。它应该在控制台上输出 `hello, world`，然后在用户模式中产生一个页故障。如果没有产生页故障，可能意味着你的系统调用服务程序有问题。现在，你应该能够成功通过 `testbss` 测试。

### 小挑战

使用 `sysenter` 和 `sysexit` 指令而不是 `int 0x30` 和 `iret` 来实现系统调用。`sysenter/sysexit` 指令由 Intel 设计，比 `int/iret` 更快，通过寄存器而不是栈来传递信息，并假定分段寄存器的使用方式。关于这些指令的详细信息可以在 Intel 参考手册 2B 卷中找到。

在 JOS 中添加对这些指令支持的方法是，在 `kern/trapentry.S` 中添加一个 `sysenter_handler`，保存足够的用户环境信息，设置内核环境，推送参数到 `syscall()`，并直接调用 `syscall()`。一旦 `syscall()` 返回，它将设置好运行 `sysexit` 所需的信息。你还需要在 `kern/init.c` 中添加一些代码以设置特殊模型寄存器（MSRs）。关于 MSRs 的详细描述可以在 AMD 架构程序员手册第 2 卷的 6.1.2 节和 Intel 参考手册 2B 卷的 SYSENTER 部分找到。对于如何写 MSRs，可以参考 [这里](http://ftp.kh.edu.tw/Linux/SuSE/people/garloff/linux/k6mod.c) 提供的 `wrmsr` 实现。

最后，`lib/syscall.c` 必须修改以支持用 `sysenter` 生成系统调用。以下是 `sysenter` 指令的一种可能的寄存器布局：

- `%eax` - 系统调用号
- `%edx`, `%ecx`, `%ebx`, `%edi` - 参数 1, 参数 2, 参数 3, 参数 4
- `%esi` - 返回 PC
- `%ebp` - 返回 ESP
- `%esp` - 由 `sysenter` 销毁

GCC 的内联汇编器会自动保存你告诉它的直接加载进寄存器的值。不要忘记保存（`push`）和恢复（`pop`）你使用的其他寄存器，或告诉内联汇编器你正在使用它们。内联汇编器不支持保存 `%ebp`，因此需要手动增加代码来保存和恢复它，返回地址可以通过类似 `leal after_sysenter_label, %%esi` 的指令置入 `%esi` 中。

注意，它仅支持四个参数，因此需要保留支持五个参数的旧方法。此外，由于快速路径不更新当前环境的 trap 帧，因此不适合某些后续实验中的系统调用。

在接下来的实验中启用异步中断后，你需要重新评估代码。特别是在返回用户进程时，需要启用中断，而 `sysexit` 指令不会为你做这件事。

### 启动用户模式

用户程序从 `lib/entry.S` 的顶部开始运行。在一些配置之后，代码调用 `lib/libmain.c` 中的 `libmain()`。你应该修改 `libmain()` 以初始化全局指针 `thisenv`，使其指向 `envs[]` 数组中的 `struct Env`。（注意 `lib/entry.S` 中已经定义 `envs` 指向你在 Part A 中映射的设置。）提示：查看 `inc/env.h` 和使用 `sys_getenvid`。

`libmain()` 接下来调用 `umain`，在 `user/hello` 程序的案例中，`umain` 定义在 `user/hello.c` 中。注意，它在输出 `hello, world` 之后尝试访问 `thisenv->env_id`。这就是为什么前面会发生故障的原因。现在，你已经正确地初始化了 `thisenv`，它应该不会再发生故障。如果仍然发生故障，可能是你没有将 `UENVS` 区域映射为用户可读（回到 Part A 中查看 `pmap.c`）；这是我们第一次真正使用 `UENVS` 区域。

#### 练习 8

添加所需的代码到用户库，然后引导你的内核。你应该能够看到 `user/hello` 程序输出 `hello, world` 然后输出 `i am environment 00001000`。`user/hello` 接下来会通过调用 `sys_env_destroy()`（查看 `lib/libmain.c` 和 `lib/exit.c`）尝试“退出”。由于内核目前仅支持一个用户环境，它应该报告唯一的环境被销毁，并进入内核监视器。现在你应该能够成功通过 `hello` 测试。

### 页故障和内存保护

内存保护是操作系统最重要的特性之一，用于防止一个程序中的 bug 破坏其他程序或操作系统本身。操作系统通常依赖硬件支持来实现内存保护，告诉硬件哪些虚拟地址是有效的，哪些是无效的。当程序尝试访问无效地址或无权限地址时，处理器会在导致故障的位置停止程序，并捕获内核中关于尝试操作的相关信息。如果故障是可修复的，内核可能会修复它并让程序继续运行。如果故障不可修复，程序就不能继续，因为它永远不会跳过导致故障的指令。

作为一个可修复故障的示例，假设一个自动扩展的栈。在许多系统上，内核初始化分配一个单栈页，如果程序发生的故障是访问这个栈页下面的页，内核会自动分配这些页，并让程序继续运行。这样，内核只分配程序实际需要的内存栈，但程序可以运行在一个任意大小的栈的假象中。

对于内存保护，系统调用中有一个非常有趣的问题。许多系统调用接口让用户程序传递指针到内核中，这些指针指向用户要读取或写入的缓冲区。内核在执行系统调用时废弃这些指针，这带来了两个问题：
1. 内核中的页故障可能比用户程序中的多得多。如果内核在维护自己的数据结构时发生页故障，那就是一个内核 bug，故障服务程序将使整个内核（和整个系统）崩溃。但是当内核废弃了由用户程序传递给它的指针后，它需要一种方式记住那些废弃指针导致的页故障其实是代表用户程序的。
2. 通常情况下，内核拥有比用户程序更多的权限。用户程序可以传递一个指针到系统调用，而指针指向的区域可能是内核可以读取或写入但用户程序不可访问的区域。内核必须非常小心，不能被这种废弃的指针欺骗，因为这可能导致泄露私有信息或破坏内核的完整性。

因此，内核在处理由用户程序提供的指针时必须格外小心。你可以通过检查所有从用户空间传递给内核的指针来解决这个问题。当程序给内核传递指针时，内核将检查其地址是否在用户部分的地址空间，并且页表允许对该内存的操作。这样，内核在废弃用户提供的指针时绝不会发生页故障。如果内核出现这种页故障，它应该崩溃并终止。

#### 练习 9

如果在内核模式中发生页故障，修改 `kern/trap.c` 以崩溃。提示：判断页故障发生在用户模式还是内核模式，检查 `tf_cs` 的低位比特即可。

阅读 `kern/pmap.c` 中的 `user_mem_assert` 并在该文件中实现 `user_mem_check`。修改 `kern/syscall.c` 以常态化检查传递给系统调用的参数。

引导你的内核，运行 `user/buggyhello`。环境将被销毁，而内核不会崩溃。你将会看到：

```
[00001000] user_mem_check assertion failure for va 00000001
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!
```

最后，修改 `kern/kdebug.c` 中的 `debuginfo_eip`，在 `usd`、`stabs` 和 `stabstr` 上调用 `user_mem_check`。如果你现在运行 `user/breakpoint`，你应该能够从内核监视器中运行回溯，并在内核因页故障崩溃前看到回溯进入到 `lib/libmain.c`。是什么导致了这个页故障？你不需要修复它，但应该明白它是如何发生的。

注意，刚才实现的这些机制同样适用于恶意用户程序（如 `user/evilhello`）。

#### 练习 10

引导你的内核，运行 `user/evilhello`。环境应该被销毁，并且内核不会崩溃。你应该能看到：

```
[00000000] new env 00001000
...
[00001000] user_mem_check assertion failure for va f010000c
[00001000] free env 00001000
```

**本实验到此结束。** 确保你通过了所有的等级测试，并在 `answers-lab3.txt` 中详细描述你的挑战练习的解决方案。提交你的变更并在 `lab` 目录下输入 `make handin` 提交你的工作。在动手实验之前，使用 `git status` 和 `git diff` 检查你的变更，并不要忘记 `git add answers-lab3.txt`。完成后，使用 `git commit -am 'my solutions to lab 3’` 提交变更，然后 `make handin` 并遵循指南。

---

via: 
作者：[csail.mit](https://pdos.csail.mit.edu)  
选题：[lujun9972](https://github.com/lujun9972)  
译者：[qhwdw](https://github.com/qhwdw)  
校对：[wxy](https://github.com/wxy)  
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出。