i = Fi. If not, the
(3) The smart card selects α ∈R Z∗
n, F
session is rejected.
n and computes
Di = h(IDi)(cid:11) mod n, Wi = Ci · Di mod n and Mi =
h(IDi||Ci||Di||Wi||Ti), where Tu is the current timestamp
at the user side.
(4) U → S: {EIDi, Di, Mi, Ti}.
Authentication phase.
In this phase, the following
procedure is carried out by Ui and S to validate each other
as well as calculating a session key.
(1) On receiving the login request {EIDi, Di, Mi, Ti}
from Ui, S reads its current timestamp Ts1 and rejects
if (Ts1 − Ti) > T , where T is the allowed maximum
transmission delay.
(2) S retrieves (IDi||Tr) ← Dx+p(EIDi) to get the
values {IDi, Tr}.
(3) If (IDi||Tr) exists in RGR, S computes C
∗
i Di mod n, and M
h(IDi)x+Tr mod n, W
h(IDi||C
i ||Ti).
∗
∗
i = Mi, and the equivalence means that
i ||Di||W
∗
(4) S checks if M
∗
i = C
∗
i =
∗
i =
Ui is legitimate.
(5) S picks the current timestamp Ts and calculates
′
∗
i
i = Ex+p(IDi||Tr|| Ts) and Ls = EC
(IDi||EID
∗
∗
i ||Ts). S replaces the value x · p ⊕ (IDi||Tr) with
||W
∗
EID
i
x · p ⊕ (IDi||Tr||Ts) in RGR. Thus, when U logins next
time, S veriﬁes the existence of (IDi||Tr||Ts) in RGR to
ensure the dynamic nature of U
s identity.
(6) S → Ui: {Ls}.
(7) Smart card decrypts Ls to get {ID
′
i, EID
(8) Smart card veriﬁes the validity of ID
′
i = Wi and
(9) If ID
i ̸= EIDi. If not, the session is rejected. Otherwise,
′
s are valid, Ui checks if W
(10) U and S agree the same session key sk =
EID
smart card updates EIDi with EID
h(Wi∥EID
Password change phase. Ui can update P Wi to a new
one P W new
′
′
i, W
i , T
′
′
s.
i and T
′
i) = h(W
i ∥EID
∗
′
i and T
as follows:
s}.
′
∗
i ).
′
i.
′
i
(1) U inserts card into a card reader and inputs IDi,
i
i
i
i
i
i
i
.
h(IDi)P W new
mod n and F new
P Wi, and P W new
(2) Smart card calculates Ci = Bi/h(IDi)P Wi mod n,
i = Ci ⊕ P Wi ⊕ IDi and veriﬁes if F
∗
∗
i = Fi. If not, the
= Bi/h(IDi)P Wi·
F
update request is rejected.
(3) Smart card calculates Bnew
= Ci ⊕ P W new
(4) Smart card updates Bi and Fi with Bnew
⊕ (IDi).
and F new
.
4.2 Cryptanalysis of Kumari-Khan’s scheme
The two assumptions about the adversary’s capabilities
C-1 and C-2 are also explicitly made in Kumari-Khan’s
paper [24] when they analyze the security of the scheme
of Chen et al. [10]. Naturally, these two assumptions can
also be relied on in the following analysis of Kumari-Khan’s
scheme. We ﬁnd that this “improved” scheme still fails to
achieve the most important goal (i.e., two-factor security)
that they claimed. Besides,
it can not attain forward
secrecy and is prone to de-synchronization attack. Thus,
it is actually less secure than Chen et al.’s original scheme.
4.2.1 Type IV attack on two-factor security
In case Ui’s smart card is somehow obtained (stolen
or picked up) by A, and the stored data {Bi} can be
extracted by some means under Capability C-2 (see Table
1). Further, according to Capability C-1, it is fair to assume
that A has also intercepted the authentication messages
{Di, Mi, Ti} exchanged during one normal (successful) login
session between Ui and the server S. At this point, A can
obtain Ui’s password P Wi as follows:
Step 1. Guesses the value of IDi to be ID
Step 2. Computes C
Step 3. Computes W
∗
i from dictio-
nary space Did and the value of P Wi to be P W
∗
from dictionary space Dpw;
i
∗
i = Bi/H(ID
∗
i mod n, where
i · Di, where Di is intercepted
∗
i ∥Ti), where
∗
Di and Ti is intercepted from the public channel;
∗
i = C
i = H(IDi∥C
∗
Bi is revealed from Ui’s card;
from the channel;
i ∥Di∥W
∗
∗
i )P W
Step 4. Computes M
Step 5. Checks the correctness of (ID
∗
paring if M
i
is equal to the intercepted Mi;
∗
i , P W
∗
i ) by com-
Step 6. Repeats Step 1, 2, 3 and 4 of this procedure until
the correct value of (ID
∗
i , P W
∗
i ) is found.
The time complexity of the above attacking procedure
is O(|Did| ∗ |Dpw| ∗ (TE + TI + 2TH )), where TE is the
running time for modular exponentiation, TI is the running
time for modular inverse operation and TH is the running
time for Hash operation. In reality, the dictionary size is
very restricted, e.g., |Did| ≤ |Dpw| ≤ 106 [4, 35]. Further,
according to the timings in Table 6, A may determine the
password in about 24.7 days on a common PC, or spends
$30.56 and costs 16.47 hours by resorting to the Amazon
EC2 C4.4X-large cloud computing service [1].
Generally, user ID cannot be considered as a secret and
actually, it is often publicly available. Thus, there is a
high probability for A to learn the user’s IDi other than
guessing it.
In this light, the above attack will be more
practical. What’s more, high performance computers are
quite common those days. All this indicates that the above
attack is eﬀective even if A has to ﬁgure out both IDi and
P Wi simultaneously.
4.2.2 Type II attack on two-factor security
Suppose Ui’s smart card is somehow obtained (stolen
or picked up) by A, and the stored sensitive parameters
{Bi, Fi} can be extracted by exploiting side-channel attacks
under Capability C-2. At this point, A can obtain Ui’s
password P Wi as follows:
Step 1. Guesses the value of IDi to be ID
∗
i from dictio-
nary space Did and the value of P Wi to be P W
∗
from dictionary space Dpw;
i
∗
i = Bi/H(ID
i ⊕ ID
∗
∗
i )P W
Bi is revealed from Ui’s smart card;
i ⊕ P W
∗
∗
i );
∗
i , P W
∗
i mod n, where
∗
i ) by com-
Step 3. Computes F
Step 4. Checks the correctness of (ID
Step 2. Computes C
∗
i = C
paring if F
is equal to the extracted Fi;
∗
i
Step 5. Repeats Step 1, 2, 3 and 4 of this procedure until
the correct value of (ID
∗
i , P W
∗
i ) is found.
The time complexity of this attacking procedure is essen-
tially the same with that of the above Type IV attack.
4.2.3 No forward secrecy
What a scheme with forward secrecy can guarantee
is that, even if the long-term key(s) of one (or more)
is obtained by A through
participant in the protocol
leakage or stealing, previously agreed session keys remain
conﬁdential. Kumari and Khan [24] explicitly stated that,
their new scheme can provide forward secrecy even if the
server S’s private keys x and p are disclosed. However, in
the following we show that this is not the case:
Step 1. Intercepts the message {EIDi, Di, Mi, Ti, Ls}
that is exchanged between Ui and the server S
during the jth protocol run;
private keys x and p;
Step 2. Gets IDi and Tr by decrypting EIDi using S’s
Step 3. Computes Ci = h(IDi)x+Ti mod n, Wi = Ci · Di
mod n, where Di and Ti are intercepted from the
open channel;
′
i by decrypting Ls using Ci, where Ls
is intercepted from the channel;
Step 4. Gets EID
Step 5. Computes the session key skj = h(Wi∥EID
Our above attack well serves to show that forward
secrecy cannot be attained by Kumari-Khan’s scheme. The
failure of this scheme is essentially due to the violation
of “the forward secrecy principle” suggested in [34]: when
the scheme’s security is based on the discrete logarithmic
problem (DLP), at least two exponential operations should
be conducted on the server side. Otherwise, the scheme is
deﬁnitely to be short of forward secrecy.
′
i);
4.2.4 De-synchronization attack
Kumari-Khan’s
scheme
employs a synchronization
mechanism to provide the property of user un-traceability.
However, this mechanism introduces a serious usability
problem. This kind of attack is ﬁrst highlighted in [50]. In
such an attack, the adversary A can completely destroy
the “synchronization” between Ui and S by simply
modifying a single protocol transcript,
rendering the
scheme completely unusable. As summarized in Fig. 3, we
show how A succeeds by altering the second ﬂow from S
to Ui with Kumari-Khan’s scheme in place.
Fig. 3: De-synchronization attack
Suppose server S has performed Step 5 of the authen-
tication phase (see Section 4.1) and sends {Ls} to Ui as
speciﬁed, which means S has replaced the value x · p ⊕
(IDi||Tr) with x· p⊕ (IDi||Tr||Ts) in the backend database
RGR. Before {Ls} reaches Ui, A intercepts this message
and alters it to {X}, where X is a randomly selected value.
In Steps 8 and 9 of the authentication phase, Ui will ﬁnd
at least one of her four checks will fail. Consequently, Ui
will reject S’s response and refuse to update EIDi with
∗
EID
i ) in the card memory. As a result, the
consistency of the user-identiﬁcation data between Ui and
S is breached. From now on, Ui will send EIDi to S in her
∗
login requests, but S expects EID
i and will always reject Ui
unless Ui re-registers. One can see that, instead of altering
Ls, A might equally reach her aim by simply dropping Ls.
This kind of attack exists in a number of newly proposed
schemes [9, 23, 48, 56]. Yet, to the best of our knowledge,
there is no easy ﬁx other than radical protocol changes.
′
i(= EID
5. REVISIT ODELU ET AL.’S SCHEME
In 2015, Odelu et al.’s scheme [43] showed that Islam’s
scheme [19] (see Fig. 2) is vulnerable to Type II smart-
card-loss attack (see Table 4), and they further proposed
an improvement. Their new scheme employs three kinds of
formal methods to prove its security and is claimed to be
“a more secure and robust remote user authenticated key
agreement scheme in order to remedy the security ﬂaws”
in Islam’s scheme [19]. However, as we will show, it is not
only vulnerable to Type II attacks, but also introduces a
new vulnerability – Type VII smart-card-loss attack.
5.1 Review of Odelu et al.’s scheme
Initialization phase. The server S ﬁrst chooses a large
prime p, a secret key ks ∈ Z
∗
p and its public key Ps = gks
mod p, where g ∈ Z
∗
p .
Whenever Ui enrolls in S, the following steps are involved:
∗
p is a generator of the cyclic group Z
(1) Ui chooses her identity IDi;
(2) Ui ⇒ S : {IDi}.
(3) S checks if h(IDi||ks) is found in its database. If yes,
S requests Ui to submit a new identity. If not, S computes
Ci = h(IDi|| ks||SIDi) and stores {Ci, Ps, g, p, h(·)} into
the smart card SCi with identiﬁer SIDi, and S keeps
[h(IDi∥ks), SIDi] in the database for Ui.
InputIDiandPWi;Generatearandomnumberα∈RZ∗n;ComputeDi=h(IDi)αmodn;Wi=Ci·Dimodn;F∗i=Ci⊕PWi⊕IDi;EIDi,Di,Mi,TiCheckifW′i=WiandEID′i6=EIDiCheckthevalidityofTi;ComputeC∗i=(ID∗i)x+Trmodn;Updatex·p⊕(IDikTr)withx·p⊕(IDikTrkTs);LsUserUiServerSCheckthevalidityofID′iandT′s;DecryptL′stogetID′ikEID′ikW′ikkT′s;ObtainID∗ikT∗rbydecryptingEIDiusingx+p;ComputeEID∗i=Ex+p(IDikTrkTs);Ls=Ec∗i(IDikEID∗ikW∗ikTs));AAtleastoneoftheabovefourcheckswillfail;ComputeCi=Bi/h(IDi)PWimodn;Secrectkey:pandx∈Z∗n,wheren=pq;p,q:twolargeprimessuchthatp=2q+1;Mi=h(IDikCikDikWikTi);RejectifF∗idoesnotequalthestoredFi;PickthecurrenttimestampTi;W∗i=C∗i·Dimodn;CheckM∗i?=h(ID∗ikC∗ikDikW∗ikTi);PickthecurrenttimestampTs;sk=h(WikEID∗i);FailtoupdateEIDiwithEID′i;RejectifID∗ikT∗rarenotinRGR;L′s(5) S ⇒ Ui: A card with data {Ci, Ps, g, p, h(·)}.
(6) Ui keys her selected password pwi into the smart
card SCi. Then, SCi calculates Bi = Ci ⊕ h(pwi||IDi)=
h(IDi|| ks|| SIDi) ⊕ h(pwi||IDi) and Ai = h(Ci|| pwi||
IDi). Finally, SCi replaces Ci by Bi and keeps Ai in its
memory. Thus, SCi ﬁnally includes {Ai, Bi, Ps, g, p, h(·)}.
Login phase. When user Ui wants to login to S, she inserts
′
′
i .
i and P W
her smart card into a card reader and keys ID
i = Bi ⊕ h(pw
′
′
′
i) and A
i =
?= Ai. If not, SCi rejects.
h(C
Otherwise, SCi chooses α, n1 ∈R Z∗
p, and computes K1
= P h((cid:11)||Ci) mod p, T IDi = (IDi||n1) ⊕ h(K1) and Vi =
gh((cid:11)||Ci) mod p.
(1) SCi computes C
i|| pw
′
′
′
i), and checks A
i
i|| ID
′
i||ID
′
(2) Ui → S : {T IDi, Vi}.
)
(1) S calculates the decryption key K2 = V ks
Authentication phase Upon receiving the login request
from Ui, S and Ui carry out the following steps:
i mod p
and decrypts T IDi using K2 as (IDi||n1) = T IDi ⊕ h(K2).
S checks the validity of IDi by ﬁnding if h(IDi||ks) is in
its database. If there is no entry corresponding to IDi, S
rejects Ui’s login request.
p and computes Ci = h(IDi||
(2) S selects β ∈R Z
∗
ks|| SIDi), sks = V h(ks||(cid:12))
mod p, Vs = gh(ks||(cid:12)) mod p
and Ms = h(Vi|| Ci|| Vs|| sks ||n1), where SIDi is retrieved
from the backend database corresponding to IDi.
(3) S → Ui : {Vs, Ms}.
(4) Ui calculates ski = V H((cid:11)||Ci)
?=
h(Vi|| Ci|| Vs|| ski|| n1).
s
If it holds, Ui is assured that
S is authentic and computes Mi = h(ski|| Vs|| Ci|| n1).
Otherwise, Ui rejects and terminates the session.
mod p and checks Ms
i
(5) Ui → S : {Mi}.
(6) S checks Mi
?= h(sks|| Vs|| Ci|| n1).
If yes, S is
assured that Ui is authentic and agrees the session key sks.
5.2 Cryptanalysis of Odeulu et al.’s scheme
The two assumptions about the adversary’s capabilities
(i.e., C-1 and C-2 ) listed in Table 1 are also explicitly