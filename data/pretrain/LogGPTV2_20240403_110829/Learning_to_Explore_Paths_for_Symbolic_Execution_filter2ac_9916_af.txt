file with objcopy. Figure 11 is taken from make and contains a subtract
overflow at Line 5 which results in wrong or even out-of-bound
array accesses. AFL detected Figures 10 and 11 using the initial
seeds from Learch. Figure 12 shows a benign subtraction overflow
detected by KLEE with Learch for the coreutils tool sort. The code
computes the logarithm of a number stored in the unsigned char
array tmpa. To decide if the current array element is a digit, the code
uses the macro ISDIGIT which overflows when c < ’0’. When this
happens, ISDIGIT returns false, which is desired as c is not a digit.
Therefore, the overflow case was already considered and handled.
6.6 Effectiveness of Design Choices
We investigate the usefulness of Learch’s design choices. Due to
space limit, we mainly present the results on coreutils. For the real-
world programs, we observed the same phenomenon as coreutils.
Performance of individual strategies. As described in Sec-
tion 6.1, Learch consists of four learned strategies. We ran each
strategy for 1h on the coreutils test set and compare the results
with Learch (a union of the four strategies each running for 15m) in
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2537strat-1
strat-2
strat-3
strat-4
Learch
linear
rnn
Learch (feedforward)
Line coverage
640
566
566
560
563
618
480
320
160
0
93
88
70
75
# UBSan violations
100
71
75
50
25
0
(a) Line coverage for the whole package.
(b) Number of UBSan violations.
Figure 13: Results of learned strategies on coreutils test set.
Figure 13. The individual strategies already achieved more coverage
(∼20 lines) than the individual manual heuristics. Even though the
absolute coverage numbers were similar, the four strategies covered
different parts of the program. As a result, Learch, combined from
the four strategies, was the most performant overall. This is the
desired outcome of the iterative learning in Algorithm 4.
Learch also found more UBSan violations than strat-1, strat-2,
and strat-3, as a result of the combination. Learch found 5 fewer
violations than strat-4 because strat-4 found many violations after
15m. Therefore, to make Learch detect more violations, we can
simply increase the time budget.
Different choices of machine learning model. Other than
feedforward networks used in Learch, we considered simpler lin-
ear regression (linear) and more complicated recurrent neural net-
works (rnn). For rnn, we added a hidden state of dimension 64 be-
tween a state and its parent. We trained linear and rnn on the same
supervised dataset as Learch, and ran them with the same configu-
ration (i.e., four independent runs each taking a quarter of the time
budget) as Learch on our test set. The results on the coreutils test
set are shown in Figure 14, showing that Learch outperformed
linear and rnn. The reason is likely that the complexity of feedfor-
ward networks is well-suited for our learning task.
7 RELATED WORK
We discuss works closely related to ours.
Symbolic execution.
Symbolic execution based testing tech-
niques have been developed for decades [18, 44], yielding a number
of applications [23, 24, 27, 36, 53, 76] and systems [8, 16, 17, 22,
52, 68, 74]. The main challenges in symbolic execution include
path explosion and expensive constraint solving [18]. A number
of manual heuristics have been proposed for selecting promising
paths [16, 48]. Our learning-based strategy Learch significantly
outperforms those heuristics. Other orthogonal attempts for eas-
ing the path explosion problem include state merging [46], state
pruning [13, 14, 21, 70], and code transformation [25]. A number
of works focus on improving the performance of constraint solvers
[9, 28, 32, 61]. Some works combine the constraint solving process
with the symbolic execution framework by solving multiple path
constraints once [77], leveraging pending path constraints [43],
and introducing neural constraints [66]. While most of the above
approaches aim to explore the whole program (same as our goal),
directed symbolic execution aims to reach certain program parts or
changes [50, 56, 73].
Line coverage
640
517
480
320
160
618
541
# UBSan violations
100
88
70
62
75
50
25
0
0
(a) Line coverage for the whole package.
(b) Number of UBSan violations.
Figure 14: Results of different models on coreutils test set.
Concolic testing and fuzzing. Concolic testing and fuzzing are
different approaches for program testing but can benefit from ad-
vances in symbolic execution because many of them use symbolic
execution for triggering complex paths. Concolic testing [33, 57, 58,
62] concretely executes the program alongside symbolic execution
and negates the path constraint of visited branches to produce new
tests covering unvisited branches. Heuristics have been learned for
selecting branches in concolic testing [19, 20]. Fuzzing is a tech-
nique that concretely executes the program and generates concrete
inputs based on input specifications [11, 40, 47] or mutations from
existing inputs [1, 7, 12, 26, 30, 31, 41, 42, 45, 65, 72]. Symbolic exe-
cution has been used for improving fuzzing [29, 54]. Hybrid testing
[27, 69, 75] combines concolic testing and fuzzing in an alternative
manner to benefit from the advantages of both.
Machine learning for program analysis and security. Ma-
chine learning has been extensively used for security tasks. Markov
chain [12], feedforward networks [65], recurrent networks [35],
imitation learning [37], reinforcement learning [72] have been used
for improving test generation in fuzzing. The authors of [73] lever-
age reinforcement learning for directed symbolic execution. Many
other tasks such as binary analysis [38], malware analysis [60], and
taint analysis [64] have been solved by data-driven approaches.
8 CONCLUSION
In this work, we introduced Learch, a learning-based state selec-
tion strategy for symbolic execution. Learch works by estimating
a reward for each state and selecting the state with the highest
reward to maximize coverage while minimizing time cost. We con-
struct Learch by applying off-the-shelf regression learning on a
supervised dataset extracted from the tests generated by running
symbolic execution on a set of training programs. The training
process is iterative and constructs multiple strategies which pro-
duce more diverse tests than a single strategy. Learch benefits
from existing heuristics by incorporating them in both training and
feature extraction.
We instantiated Learch on KLEE [16] and evaluated it on the
coreutils programs and ten real-world programs. The results demon-
strated that Learch is effective and can produce higher-quality tests
than existing manually designed heuristics, either individual ones
or combined as portfolios: Learch’s tests yielded more code cover-
age, detected more security violations, and were better candidates
as initial seeds for fuzzers like AFL.
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2538REFERENCES
[1] 2021. American fuzzy lop. https://lcamtuf.coredump.cx/afl/
[2] 2021. Gcov (Using the GNU Compiler Collection (GCC)). https://gcc.gnu.org/
onlinedocs/gcc/Gcov.html
[3] 2021. Google Fuzzer Test Suite. https://github.com/google/fuzzer-test-suite
[4] 2021. UndefinedBehaviorSanitizer — Clang 6 documentation. https://releases.
llvm.org/6.0.0/tools/clang/docs/UndefinedBehaviorSanitizer.html
[5] Dennis Andriesse, Asia Slowinska, and Herbert Bos. 2017. Compiler-Agnostic
Function Detection in Binaries. In EuroS&P 2017. https://doi.org/10.1109/EuroSP.
2017.11
[6] Shay Artzi, Adam Kiezun, Julian Dolby, Frank Tip, Danny Dig, Amit M. Paradkar,
and Michael D. Ernst. 2008. Finding Bugs in Dynamic Web Applications. In ISSTA
2008. https://doi.org/10.1145/1390630.1390662
[7] Cornelius Aschermann, Sergej Schumilo, Tim Blazytko, Robert Gawlik, and
Thorsten Holz. 2019. REDQUEEN: Fuzzing with Input-to-State Correspondence.
In NDSS 2019. https://www.ndss-symposium.org/ndss-paper/redqueen-fuzzing-
with-input-to-state-correspondence/
[8] Thanassis Avgerinos, Alexandre Rebert, Sang Kil Cha, and David Brumley. 2014.
Enhancing Symbolic Execution with Veritesting. In ICSE 2014. https://doi.org/
10.1145/2568225.2568293
[9] Mislav Balunovic, Pavol Bielik, and Martin Vechev. 2018. Learning to Solve SMT
Formulas. In NeurIPS 2018. https://proceedings.neurips.cc/paper/2018/hash/
68331ff0427b551b68e911eebe35233b-Abstract.html
[10] Tiffany Bao, Jonathan Burket, Maverick Woo, Rafael Turner, and David Brumley.
2014. BYTEWEIGHT: Learning to Recognize Functions in Binary Code. In USENIX
Security 2014. https://www.usenix.org/conference/usenixsecurity14/technical-
sessions/presentation/bao
[11] Tim Blazytko, Cornelius Aschermann, Moritz Schlögel, Ali Abbasi, Sergej Schu-
milo, Simon Wörner, and Thorsten Holz. 2019. GRIMOIRE: Synthesizing Structure
while Fuzzing. In USENIX Security 2019. https://www.usenix.org/conference/
usenixsecurity19/presentation/blazytko
[12] Marcel Böhme, Van-Thuan Pham, Manh-Dung Nguyen, and Abhik Roychoud-
hury. 2017. Directed Greybox Fuzzing. In CCS 2017. https://doi.org/10.1145/
3133956.3134020
[13] Peter Boonstoppel, Cristian Cadar, and Dawson R. Engler. 2008. RWset: Attacking
Path Explosion in Constraint-Based Test Generation. In TACAS 2008. https:
//doi.org/10.1007/978-3-540-78800-3_27
[14] Suhabe Bugrara and Dawson R. Engler. 2013. Redundant State Detection for
Dynamic Symbolic Execution. In USENIX ATC 2013. https://www.usenix.org/
conference/atc13/technical-sessions/presentation/bugrara
[15] Frank Busse, Martin Nowack, and Cristian Cadar. 2020. Running Symbolic
Execution Forever. In ISSTA 2020. https://doi.org/10.1145/3395363.3397360
[16] Cristian Cadar, Daniel Dunbar, and Dawson R. Engler. 2008. KLEE: Unassisted and
Automatic Generation of High-Coverage Tests for Complex Systems Programs. In
OSDI 2008. http://www.usenix.org/events/osdi08/tech/full_papers/cadar/cadar.
pdf
[17] Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, David L. Dill, and Dawson R.
Engler. 2006. EXE: automatically generating inputs of death. In CCS 2006. https:
//doi.org/10.1145/1180405.1180445
[18] Cristian Cadar and Koushik Sen. 2013. Symbolic Execution for Software Testing:
https:
Three Decades Later. Communications of ACM 56, 2 (2013), 82–90.
//doi.org/10.1145/2408776.2408795
[19] Sooyoung Cha, Seongjoon Hong, Junhee Lee, and Hakjoo Oh. 2018. Automatically
Generating Search Heuristics for Concolic Testing. In ICSE 2018. https://doi.org/
10.1145/3180155.3180166
[20] Sooyoung Cha and Hakjoo Oh. 2019. Concolic Testing with Adaptively Changing
Search Heuristics. In FSE 2019. https://doi.org/10.1145/3338906.3338964
[21] Sooyoung Cha and Hakjoo Oh. 2020. Making Symbolic Execution Promising by
Learning Aggressive State-pruning Strategy. In ESEC/FSE 2020. https://doi.org/
10.1145/3368089.3409755
[22] Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David Brumley. 2012.
Unleashing Mayhem on Binary Code. In S&P 2012. https://doi.org/10.1109/SP.
2012.31
[23] Sze Yiu Chau, Omar Chowdhury, Md. Endadul Hoque, Huangyi Ge, Aniket Kate,
Cristina Nita-Rotaru, and Ninghui Li. 2017. SymCerts: Practical Symbolic Execu-
tion for Exposing Noncompliance in X.509 Certificate Validation Implementations.
In S&P 2017. https://doi.org/10.1109/SP.2017.40
[24] Sze Yiu Chau, Moosa Yahyazadeh, Omar Chowdhury, Aniket Kate, and Ninghui
Li. 2019. Analyzing Semantic Correctness with Symbolic Execution: A Case
Study on PKCS#1 v1.5 Signature Verification. In NDSS 2019. https://www.ndss-
symposium.org/ndss-paper/analyzing-semantic-correctness-with-symbolic-
execution-a-case-study-on-pkcs1-v1-5-signature-verification/
[25] Junjie Chen, Wenxiang Hu, Lingming Zhang, Dan Hao, Sarfraz Khurshid, and Lu
Zhang. 2018. Learning to Accelerate Symbolic Execution via Code Transforma-
tion. In ECOOP 2018. https://doi.org/10.4230/LIPIcs.ECOOP.2018.6
[26] Peng Chen and Hao Chen. 2018. Angora: Efficient Fuzzing by Principled Search.
In S&P 2018. https://doi.org/10.1109/SP.2018.00046
[27] Yaohui Chen, Peng Li, Jun Xu, Shengjian Guo, Rundong Zhou, Yulong Zhang,
Tao Wei, and Long Lu. 2020. SAVIOR: Towards Bug-Driven Hybrid Testing. In
S&P 2020. https://doi.org/10.1109/SP40000.2020.00002
[28] Leonardo Mendonça de Moura and Nikolaj Bjørner. 2008. Z3: An Efficient SMT
Solver. In TACAS 2008. https://doi.org/10.1007/978-3-540-78800-3_24
[29] Julian Fietkau, Bhargava Shastry, and Jean-Pierre Seifert. 2017. KleeFL - Seeding
Fuzzers With Symbolic Execution. In Posters presented at USENIX Security 2017.
https://github.com/julieeen/kleefl/raw/master/USENIX2017poster.pdf
[30] Shuitao Gan, Chao Zhang, Peng Chen, Bodong Zhao, Xiaojun Qin, Dong Wu, and
Zuoning Chen. 2020. GREYONE: Data Flow Sensitive Fuzzing. In USENIX Security
2020. https://www.usenix.org/conference/usenixsecurity20/presentation/gan
[31] Shuitao Gan, Chao Zhang, Xiaojun Qin, Xuwen Tu, Kang Li, Zhongyu Pei, and
Zuoning Chen. 2018. CollAFL: Path Sensitive Fuzzing. In S&P 2018. https:
//doi.org/10.1109/SP.2018.00040
[32] Vijay Ganesh and David L. Dill. 2007. A Decision Procedure for Bit-Vectors and
Arrays. In CAV 2007. https://doi.org/10.1007/978-3-540-73368-3_52
[33] Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed Auto-
mated Random Testing. In PLDI 2005. https://doi.org/10.1145/1065010.1065036
[34] Patrice Godefroid, Michael Y. Levin, and David A. Molnar. 2008. Automated White-
box Fuzz Testing. In NDSS 2008. https://www.ndss-symposium.org/ndss2008/
automated-whitebox-fuzz-testing/
[35] Patrice Godefroid, Hila Peleg, and Rishabh Singh. 2017. Learn&Fuzz: Machine
https://doi.org/10.1109/ASE.2017.
Learning for Input Fuzzing. In ASE 2017.
8115618
[36] Shengjian Guo, Meng Wu, and Chao Wang. 2018. Adversarial Symbolic Execution
for Detecting Concurrency-related Cache Timing Leaks. In FSE 2018,. https:
//doi.org/10.1145/3236024.3236028
[37] Jingxuan He, Mislav Balunovic, Nodar Ambroladze, Petar Tsankov, and Martin
Vechev. 2019. Learning to Fuzz from Symbolic Execution with Application to
Smart Contracts. In CCS 2019. https://doi.org/10.1145/3319535.3363230
[38] Jingxuan He, Pesho Ivanov, Petar Tsankov, Veselin Raychev, and Martin Vechev.
2018. Debin: Predicting Debug Information in Stripped Binaries. In CCS 2018.
https://doi.org/10.1145/3243734.3243866
[39] Adrian Herrera, Hendra Gunadi, Shane Magrath, Michael Norrish, Mathias Payer,
and Antony L. Hosking. 2021. Seed selection for successful fuzzing. In ISSTA
2021. https://doi.org/10.1145/3460319.3464795
[40] Christian Holler, Kim Herzig, and Andreas Zeller. 2012. Fuzzing with Code
https://www.usenix.org/conference/
Fragments. In USENIX Security 2012.
usenixsecurity12/technical-sessions/presentation/holler
[41] Heqing Huang, Peisen Yao, Rongxin Wu, Qingkai Shi, and Charles Zhang. 2020.
Pangolin: Incremental Hybrid Fuzzing with Polyhedral Path Abstraction. In S&P
2020. https://doi.org/10.1109/SP40000.2020.00063
[42] Jinho Jung, Hong Hu, David Solodukhin, Daniel Pagan, Kyu Hyung Lee, and
Taesoo Kim. 2019. Fuzzification: Anti-Fuzzing Techniques. In USENIX Security
2019. https://www.usenix.org/conference/usenixsecurity19/presentation/jung
[43] Timotej Kapus, Frank Busse, and Cristian Cadar. 2020. Pending Constraints in
Symbolic Execution for Better Exploration and Seeding. In ASE 2020. https:
//ieeexplore.ieee.org/document/9286054
[44] James C. King. 1976. Symbolic Execution and Program Testing. Communications
of ACM 19, 7 (1976), 385–394. https://doi.org/10.1145/360248.360252
[45] George Klees, Andrew Ruef, Benji Cooper, Shiyi Wei, and Michael Hicks. 2018.
Evaluating Fuzz Testing. In CCS 2018. https://doi.org/10.1145/3243734.3243804
[46] Volodymyr Kuznetsov, Johannes Kinder, Stefan Bucur, and George Candea. 2012.
Efficient State Merging in Symbolic Execution. In PLDI 2012. https://doi.org/10.
1145/2254064.2254088
[47] Vu Le, Mehrdad Afshari, and Zhendong Su. 2014. Compiler Validation via Equiv-
alence Modulo Inputs. In PLDI 2014. https://doi.org/10.1145/2594291.2594334
[48] You Li, Zhendong Su, Linzhang Wang, and Xuandong Li. 2013. Steering Symbolic
Execution to Less Traveled Paths. In OOPSLA 2013. https://doi.org/10.1145/
2509136.2509553
[49] Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor. 2016.
Making Smart Contracts Smarter. In CCS 2016. https://doi.org/10.1145/2976749.
2978309
[50] Kin-Keung Ma, Yit Phang Khoo, Jeffrey S. Foster, and Michael Hicks. 2011. Di-
rected Symbolic Execution. In SAS 2011. https://doi.org/10.1007/978-3-642-
23702-7_11
[51] Sebastian Österlund, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2020.
ParmeSan: Sanitizer-guided Greybox Fuzzing. In USENIX Security 2020. https:
//www.usenix.org/conference/usenixsecurity20/presentation/osterlund
[52] Corina S. Pasareanu and Neha Rungta. 2010. Symbolic PathFinder: symbolic
execution of Java bytecode. In ASE 2010. https://doi.org/10.1145/1858996.1859035
[53] Luis Pedrosa, Ari Fogel, Nupur Kothari, Ramesh Govindan, Ratul Mahajan, and
Todd D. Millstein. 2015. Analyzing Protocol Implementations for Interoperability.
In NSDI 2015. https://www.usenix.org/conference/nsdi15/technical-sessions/
presentation/pedrosa
[54] Hui Peng, Yan Shoshitaishvili, and Mathias Payer. 2018. T-Fuzz: Fuzzing by
Program Transformation. In S&P 2018. https://doi.org/10.1109/SP.2018.00056
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2539[55] Anton Permenev, Dimitar Dimitrov, Petar Tsankov, Dana Drachsler-Cohen, and
Martin Vechev. 2020. VerX: Safety Verification of Smart Contracts. In S&P 2020.
https://doi.org/10.1109/SP40000.2020.00024
[56] Suzette Person, Guowei Yang, Neha Rungta, and Sarfraz Khurshid. 2011. Directed
Incremental Symbolic Execution. In PLDI 2011. https://doi.org/10.1145/1993498.
1993558
[57] Sebastian Poeplau and Aurélien Francillon. 2020. Symbolic Execution with
SymCC: Don’t Interpret, Compile!. In USENIX Security 2020. https://www.usenix.
org/conference/usenixsecurity20/presentation/poeplau
[58] Sebastian Poeplau and Aurélien Francillon. 2021. SymQEMU: Compilation-
based Symbolic Execution for Binaries. In NDSS 2021.
https://www.ndss-
symposium.org/ndss-paper/symqemu-compilation-based-symbolic-execution-
for-binaries/
[59] David A. Ramos and Dawson R. Engler. 2015. Under-Constrained Sym-
bolic Execution: Correctness Checking for Real Code. In USENIX Security
2015. https://www.usenix.org/conference/usenixsecurity15/technical-sessions/
presentation/ramos
[60] Matthew G. Schultz, Eleazar Eskin, Erez Zadok, and Salvatore J. Stolfo. 2001.
Data Mining Methods for Detection of New Malicious Executables. In S&P 2001.
https://doi.org/10.1109/SECPRI.2001.924286
[61] Daniel Selsam, Matthew Lamm, Benedikt Bünz, Percy Liang, Leonardo de Moura,
and David L. Dill. 2019. Learning a SAT Solver from Single-Bit Supervision. In
ICLR 2019. https://openreview.net/forum?id=HJMC_iA5tm
[62] Koushik Sen, Darko Marinov, and Gul Agha. 2005. CUTE: a Concolic Unit Testing
Engine for C. In FSE 2005. https://doi.org/10.1145/1081706.1081750
[63] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitriy
Vyukov. 2012. AddressSanitizer: A Fast Address Sanity Checker. In USENIX ATC
2012. https://www.usenix.org/conference/atc12/technical-sessions/presentation/
serebryany
[64] Dongdong She, Yizheng Chen, Abhishek Shah, Baishakhi Ray, and Suman Jana.
2020. Neutaint: Efficient Dynamic Taint Analysis with Neural Networks. In S&P
2020. https://doi.org/10.1109/SP40000.2020.00022
[65] Dongdong She, Kexin Pei, Dave Epstein, Junfeng Yang, Baishakhi Ray, and Suman
Jana. 2019. NEUZZ: Efficient Fuzzing with Neural Program Smoothing. In S&P
2019. https://doi.org/10.1109/SP.2019.00052
[66] Shiqi Shen, Shweta Shinde, Soundarya Ramesh, Abhik Roychoud-
Neuro-Symbolic Execution: Aug-
In NDSS 2019.
hury, and Prateek Saxena. 2019.
menting Symbolic Execution with Neural Constraints.
https://www.ndss-symposium.org/ndss-paper/neuro-symbolic-execution-
augmenting-symbolic-execution-with-neural-constraints/
[67] Eui Chul Richard Shin, Dawn Song, and Reza Moazzezi. 2015. Recognizing Func-
tions in Binaries with Neural Networks. In USENIX Security 2015. https://www.
usenix.org/conference/usenixsecurity15/technical-sessions/presentation/shin
[68] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino,
Andrew Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Krügel,
and Giovanni Vigna. 2016. SOK: (State of) The Art of War: Offensive Techniques
in Binary Analysis. In S&P 2016. https://doi.org/10.1109/SP.2016.17
[69] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and
Driller: Augmenting Fuzzing Through Selective
http://wp.internetsociety.org/ndss/wp-
Wang,
Giovanni Vigna. 2016.
Symbolic Execution. In NDSS 2016.
content/uploads/sites/25/2017/09/driller-augmenting-fuzzing-through-
selective-symbolic-execution.pdf
[70] David Trabish, Andrea Mattavelli, Noam Rinetzky, and Cristian Cadar. 2018.
Chopped Symbolic Execution. In ICSE 2018. https://doi.org/10.1145/3180155.
3180251
[71] Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2017. Skyfire: Data-Driven
Seed Generation for Fuzzing. In S&P 2017. https://doi.org/10.1109/SP.2017.23
[72] Jinghan Wang, Chengyu Song, and Heng Yin. 2021.
Reinforcement
Learning-based Hierarchical Seed for Greybox Fuzzing.
In NDSS 2021.
https://www.ndss-symposium.org/ndss-paper/reinforcement-learning-based-
hierarchical-seed-scheduling-for-greybox-fuzzing/
[73] Jie Wu, Chengyu Zhang, and Geguang Pu. 2020. Reinforcement Learning Guided
Symbolic Execution. In SANER 2020. https://doi.org/10.1109/SANER48275.2020.
9054815
[74] Tao Xie, Nikolai Tillmann, Jonathan de Halleux, and Wolfram Schulte. 2009.
Fitness-guided path exploration in dynamic symbolic execution. In DSN 2009.
https://doi.org/10.1109/DSN.2009.5270315
[75] Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and Taesoo Kim. 2018. QSYM : A
Practical Concolic Execution Engine Tailored for Hybrid Fuzzing. In USENIX Se-
curity 2018. https://www.usenix.org/conference/usenixsecurity18/presentation/
yun
[76] Rui Zhang, Calvin Deutschbein, Peng Huang, and Cynthia Sturton. 2018. End-
to-End Automated Exploit Generation for Validating the Security of Processor
Designs. In MICRO 2018. https://doi.org/10.1109/MICRO.2018.00071
[77] Yufeng Zhang, Zhenbang Chen, Ziqi Shuai, Tianqi Zhang, Kenli Li, and Ji Wang.
2020. Multiplex Symbolic Execution: Exploring Multiple Paths by Solving Once.
In ASE 2020. https://doi.org/10.1145/3324884.3416645
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2540