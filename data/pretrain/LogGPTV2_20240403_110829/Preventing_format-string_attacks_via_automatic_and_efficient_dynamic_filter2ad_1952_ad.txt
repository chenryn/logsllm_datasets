FormatGuard [6] cleverly uses features of the Gnu C Pre-
processor to count arguments to printf-style functions. It
then calls wrapper functions that reject calls with too many
format speciﬁers. This approach relies on the fact that the
number of arguments is known at compile-time. As dis-
cussed in the previous section, the run-time overhead is
comparable to our approach. FormatGuard is simpler in
that it requires no compile-time ﬂow analysis, but it has
corresponding limitations.
Most importantly, it does not detect attacks on vprintf-
style functions. Not only are such attacks common, but
a system in which printf is more secure than vprintf dis-
courages the good practice of
interceding output with
application-speciﬁc functions. On the other hand, Format-
Guard could probably be extended to allow programmers to
explicitly declare their printing functions.
The FormatGuard approach will also miss an attack that
replaces another format speciﬁer with %n. We are unaware
of any such attacks; they seem quite diﬃcult to construct.
FormatGuard also lacks an analogue of our constant-string
optimization. It may be possible to add such an optimiza-
tion to FormatGuard by using gcc’s builtin function
__builtin_constant_p (or something similar). In our sys-
tem, however, the optimization was trivial to implement be-
cause of the type-checked abstract-syntax tree provided by
CIL.
5.2 Tainted-String Detection
A compile-time or run-time analysis can detect whether
a format string passed to a printing function could possibly
have come from an untrusted source. These format strings
can then be rejected. Diﬀerent systems use diﬀerent analyses
and diﬀerent deﬁnitions of untrusted sources.
Shankar et. al.
[31] and Guyer et. al.
[12] use compile-
time ﬂow analyses to identify and track strings that may
have come from I/O or that may have been modiﬁed by
the user. If this potentially tainted data is used as the for-
mat string of a printf or syslog call, an error is declared.
This approach is more conservative than necessary because
static analysis is inherently limited and much supposedly
“tainted” data is actually perfectly safe. In addition, purely
static-analysis based techniques like these require changing
the code to ﬁx any potential vulnerabilities that are found—
which can be diﬃcult when dealing with large applications
that you do not understand well (e.g., if you are trying to
protect open-source code that you are compiling and in-
stalling on your machine). With our approach, however, the
protection is automatic—the user does not have to change
any code.
Other compile-time approaches are less complete. For ex-
ample, Alan DeKok’s PScan [9] ﬁnds printf call sites where
the format string is both non-static and the ﬁnal parame-
ter. The gcc compiler [11] ﬂag -Wformat=2 causes the com-
piler to issue a warning whenever a non-static format string
is found. These approaches give warnings about safe code
(false positives) and can miss format-string vulnerabilities
(false negatives).
that corrupt
At run-time, we can detect suspicious format strings or
writes
The
libformat library, by Tim Robbins [27], takes the former
approach. It rejects any printf that uses a format string
function return addresses.
that is in writable memory and that contains a %n-speciﬁer.
This is essentially equivalent to using an empty white-list
in conjunction with our constant string optimization. This
approach may abort safe and correct programs, including
the example in Figure 1. The libsafe library of Tsai and
Singh [36] takes the latter approach, verifying that the write
caused by a %n is not to a function return address.
It is
equivalent to white-listing all of memory except the loca-
tions of the return addresses. This approach might miss
less direct format-string attacks. The implementation also
requires frame pointers, i.e., it is incompatible with gcc’s
-fomit-frame-pointer ﬂag.
5.3 Restricting Writes
One can view our explicit white-list as a software approach
to restricting a memory write based on the address being
written. Related work has taken a similar approach for an
entire application, rather than a speciﬁc vulnerability such
as format-string attacks.
Software fault isolation (SFI) [37] is one such approach.
The legal address range is chosen ahead of time and the bi-
nary code rewritten to enforce the restriction eﬃciently. Un-
fortunately, a compile-time white-list is not ﬂexible enough
to prevent format-string attacks.
Systems like Safe-C [1, 16] are more ﬂexible than SFI,
checking at run-time that writes to memory do not violate
array bounds, follow dangling pointers, etc. This approach
can slow down applications by as much as an order of mag-
nitude, making it inappropriate in many settings. On the
other hand, our white-list approach is relevant to only print-
ing functions, making the performance overhead more than
reasonable.
5.4 Safe printf
CCured [21, 5] (a type-safe implementation of C) and
Cyclone [14, 8] (a type-safe dialect of C) take similar ap-
proaches to making the printing functions safe. Roughly,
the caller provides the number and types of the variable ar-
guments, and the callee compares them against the format
string at run-time. The compiler does this implicitly at call
sites so there is no burden for the programmer using the
printing functions.
In Cyclone, no attempt is made to preserve the native
calling convention for variable-argument functions. Instead,
a stack-allocated array holds the variable arguments and
their type tags.
In CCured, the type information can be
passed via a global variable. In both cases, there is extra
data (the type tags) and extra parameter passing, even when
the format string does not contain %n. Despite using a ﬂow
analysis, our approach is simpler and more eﬃcient than
making C type-safe.
6. CONCLUSIONS
We have presented a solution to the problem of format-
string attacks, by providing an automated approach to main-
taining an explicit white-list. We have found that a white-
list directly encodes the relevant security policy, namely that
printing functions should modify only certain caller-speciﬁed
memory locations. Furthermore, a dynamic white-list pro-
vides ﬂexibility: We can change the policy at run-time and
we can directly encode common policies ranging from “no
checking” to sandboxing to “no writes.” With little perfor-
mance overhead, our approach has fewer false positives and
fewer false negatives than previous work. In particular, we
catch attacks using vprintf and we do not forbid the %n
format speciﬁer in non-static format strings.
An eﬃcient, automatic, whole-program static analysis and
transformation performs white-list maintenance without bur-
dening programmers. The analysis is simple and eﬃcient
using the right tool (such as CIL, which provides a type-
checked abstract-syntax tree), but would be impossible with
macros or simple scripts. Moreover, we use the analysis just
to insert the correct run-time checks, so the imprecision of
static analysis is not a limitation.
We believe white-lists are a useful tool for implement-
ing software security policies and consider this work a com-
pelling example. We look forward to considering white-lists
for reducing other security vulnerabilities. Speciﬁc examples
include preventing race conditions for ﬁle I/O [3], limiting
references to kernel data in user buﬀers, and restricting ac-
cess to communication ports.
7. ACKNOWLEDGMENTS
We would like to thank Steve Gribble, Michael Hicks,
Jesse Rothstein, and the anonymous reviewers for helpful
comments on earlier drafts.
8. REFERENCES
[1] Todd Austin, Scott Breach, and Gurindar Sohi.
Eﬃcient detection of all pointer and array access
errors. In ACM Conference on Programming Language
Design and Implementation, pages 290–301, Orlando,
FL, June 1994.
[2] William Bush, Jonathan Pincus, and David Sielaﬀ. A
static analyzer for ﬁnding dynamic programming
errors. Software Practice and Experience,
30(7):775–802, June 2000.
[3] Hao Chen, Drew Dean, and David Wagner. Model
checking one million lines of C code. In Proceedings of
the Network and Distributed System Security
Symposium, San Diego, CA, 2004.
[4] CIL - Infrastructure for C Program Analysis and
Transformation, version 1.3.2. Available at
http://manju.cs.berkeley.edu/cil/.
[5] Jeremy Condit, Matthew Harren, Scott McPeak,
George Necula, and Westley Weimer. CCured in the
real world. In ACM Conference on Programming
Language Design and Implementation, pages 232–244,
June 2003.
[6] C. Cowan, M. Barringer, S. Beattie, and
G. Kroah-Hartman. FormatGuard: Automatic
protection from printf format string vulnerabilities.
In Proceedings of the 10th USENIX Security
Symposium, Washington, D.C., Aug. 2001.
[7] Crispin Cowan, Calton Pu, Dave Maier, Heather
Hinton, Jonathan Walpole, Peat Bakke, Steve Beattie,
Aaron Grier, Perry Wagle, and Qian Zhang.
StackGuard: Automatic adaptive detection and
prevention of buﬀer-overﬂow attacks. In 7th USENIX
Security Symposium, pages 63–78, San Antonio, TX,
January 1998.
[8] Cyclone, version 0.8. Available at
http://www.research.att.com/projects/cyclone.
[9] Alan DeKok. Pscan: A limited problem scanner for C
[23] Bruce Perens. Electric fence. At www.gnu.org/
source ﬁles, July 2000. Available at
www.striker.ottawa.on.ca/˜aland/pscan/.
directory/All Packages in Directory/Electric-
Fence.html.
[10] Dawson Engler, Benjamin Chelf, Andy Chou, and
[24] NGSSoftware Insight Security Research. Pﬁnger 0.7.8
Seth Hallem. Checking system rules using
system-speciﬁc, programmer-written compiler
extensions. In 4th USENIX Symposium on Operating
System Design and Implementation, pages 1–16, San
Diego, CA, October 2000.
[11] Free Software Foundation. The GNU compiler
collection. Available at http://gnu.gcc.org/.
[12] S. Z. Guyer, E. D. Berger, and C. Lin. Detecting errors
with conﬁgurable whole-program dataﬂow analysis.
Technical Report UTCS TR-02-04, UT-Austin, 2002.
[13] Reed Hastings and Bob Joyce. Purify: Fast detection
of memory leaks and access errors. In Winter USENIX
Conference, pages 125–138, San Francisco, CA,
January 1992.
[14] T. Jim, G. Morrisett, D. Grossman, M. Hicks,
J. Cheney, and Y. Wang. Cyclone: A safe dialect of C.
In USENIX Annual Technical Conference, pages
275–288, Monterey, CA, June 2002.
[15] Stephen Johnson. Lint, a C program checker.
Computer Science Technical Report 65, Bell
Laboratories, December 1977.
[16] Richard Jones and Paul Kelly. Backwards-compatible
bounds checking for arrays and pointers in C
programs. In AADEBUG’97. Third International
Workshop on Automatic Debugging, volume 2(9) of
Link¨oping Electronic Articles in Computer and
Information Science, 1997.
[17] Michel Kaempf. Multiple vulnerabilities in splitvt,
January 2001. At www.securityfocus.com/
archive/1/156251.
[18] Vladimir Kiriansky, Derek Bruening, and Saman
Amarasinghe. Secure execution via program
shepherding. In 11th USENIX Security Symposium,
pages 191–206, August 2002.
[19] Gabriel A. Maggiotti. Unreal ircd format string vuln,
February 2002. At www.securityfocus.com/
archive/82/258190.
[20] G. C. Necula, S. McPeak, S. P. Rahul, and
W. Weimer. CIL: Intermediate language and tools for
analysis and transformation of C programs. In
Proceedings of the Conference on Compiler
Construction, pages 213–228, 2002.
[21] George Necula, Scott McPeak, and Westley Weimer.
CCured: Type-safe retroﬁtting of legacy code. In 29th
ACM Symposium on Principles of Programming
Languages, pages 128–139, January 2002.
[22] T. Newsham. Format string attacks. White Paper,
Sept. 2000. At www.securityfocus.com/guest/ 3342.
format string vulnerability, December 2002.
http://www.securityfocus.com/archive/1/303555.
[25] NGSSoftware Insight Security Research. zkﬁngerd
0.9.1 format string vulnerability, December 2002.
http://www.securityfocus.com/archive/1/303557.
[26] Michael F. Ringenburg and Dan Grossman.
www.cs.washington.edu/homes/miker/formatstring/.
[27] Tim Robbins. libformat, November 2001. At
www.wiretapped.net/˜fyre/software/libformat.html.
[28] Rwhoisd remote format string vulnerability, October
2001. At www.securityfocus.com/archive/1/ 222756.
[29] Jerome H. Saltzer and Michael D. Schroeder. The
protection of information in computer systems.
Proceedings of the IEEE, 63(9):1278–1308, September
1975.
[30] VOID.AT Security. isc dhcpd 3.0 format string
exploit, January 2003. At www.securityfocus.com/
archive/1/306327.
[31] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner.
Detecting format string vulnerabilities with type
qualiﬁers. In 10th USENIX Security Symposium, pages
201–220, 2001.
[32] Christopher Small and Margo Seltzer. MiSFIT:
constructing safe extensible systems. IEEE
Concurrency, 6(3):33–41, July–September 1998.
[33] Splint manual, version 3.0.6, 2002.
http://www.splint.org/manual/.
[34] @stake, Inc. tcpﬂow 0.2.0 format string vulnerability,
August 2003. At
www.securityfocus.com/advi-sories/5686.
[35] tf8@zolo.freelsd.net. Wu-ftpd remote format string
stack overwrite vulnerability, June 2000. At
www.securityfocus.com/bid/1387.
[36] T. Tsai and N. Singh. Libsafe: Protecting critical
elements of stacks. Technical Report ALR-2001-019,
Avaya Labs, Aug. 2001.
[37] Robert Wahbe, Steven Lucco, Thomas Anderson, and
Susan Graham. Eﬃcient software-based fault
isolation. ACM SIGOPS Operating Systems Review,
7(5):203–216, December 1993.
[38] J. Wilander and M. Kamkar. A comparison of publicly
available tools for static intrusion prevention. In
Proceedings of the 7th Nordic Workshop on Secure IT
Systems, pages 68–84, Nov. 2002.
[39] zillion. nn format string exploit, July 2002.
http://www.securityfocus.com/archive/82/280687.