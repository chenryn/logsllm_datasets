A(2)
B(1)
3
3
2
7
6
2
C
Join_Req
D(4)
3
F(5)
2
G(2)
Join_Req
2
3
2
3
E(5)
(b) E selects the new path
S(0)
1
A(2)
2
C(3)
B(1)
3
3
7
6
F(4)
2
G(2)
2
3
2
D(3)
3
3
2
E(4)
(c) E switches to the new path
(d) ﬁnal multicast tree
Figure 5. Tree reshaping in SMRP
For each on-tree node R, it is selected as the merger point
by the new member NR because, at the time when NR joins,
R has the minimum SHRS,R among all available nodes. If
the subsequent new members keep choosing R as the merger
point, the value of SHRS,R will be increased, making R un-
suitable for accommodating the previous NR. Similarly,
with the departure of certain underneath members, R may
become a good choice for other members which did not ini-
tially select R when they joined the group. Based on these
observations, the tree-reshaping operation can be triggered
by the following two conditions:
• Condition I: For each on-tree node R, every time a
new member NR joins the tree through a merger node
on the path PT (S,R), the value of SHRS,R is incre-
mented by the number of links shared by both the new
member and the current multicast tree. For example,
in Figure 4(d), SHRS,D is increased from 2 to 4 af-
ter F joined the group because the two links, LSA and
LAD, are used in F’s path. We maintain a data struc-
ture SHRold
S,Ru at R, which records the value of SHRS,Ru
received after last reshaping process. Once the dif-
ference between SHRS,Ru and SHRold
S,Ru is larger than a
threshold value, possibly meaning that the accommo-
dation of new members in the sibling subtrees makes
it inappropriate for R to use the current on-tree path, a
tree-reshaping operation is triggered at R.
• Condition II: This condition deals with the case when
the departure of members from other on-tree nodes
makes them become candidates for a new path. In or-
der to detect such a condition, each on-tree R sets up
a periodic timer. Once the timer expires, the node ini-
tiates another path selection process as it does when it
ﬁrst joins the multicast group.
The tree-reshaping procedure consists of two steps.
First, the reshaping node determines the new multicast path
by performing the same procedure as described in Sec-
tion 3.2.2.
If the new path is inferior to the current one,
the reshaping process is unnecessary. Otherwise, in the sec-
ond step, after the new path is set up, the reshaping node
switches all its communication to the new path and releases
the resources on the old path as in the member departure
procedure. Figure 5 illustrates the tree reshaping triggered
by E after F is admitted. The increase of SHRS,D by F’s
sharing of link LS,A and LA,D triggers the reshaping process
at E. As shown in Figure 5(b), E completes another path
selection process by selecting path E → C → A → S. The
merger point of the new path, i.e., A, has a smaller value
(SHRS,A = 2) than the merger point of the current path, D
(SHRS,D = 4). Note that since the current path still exists
when the new path is located, the value of SHRS,R may be
inaccurate and should be adjusted before the path compari-
son is made. Figure 5(c) shows the path switching process
after which a better tree structure for fault-tolerance is ob-
tained in Figure 5(d).
3.3 Discussion
In this section, we discuss the key aspects of SMRP and
describe potential extensions to make it more efﬁcient, ro-
bust, and scalable.
3.3.1 Knowledge of Topology
In Section 3.2.2, we assumed that each member has a full
knowledge of the current network topology. This might hin-
der the deployment of the protocol when the topology infor-
mation is not available. In what follows, we develop a query
scheme to obtain the required information.
In the query scheme, each new member relies on its
neighbor nodes to relay its query messages to on-tree nodes.
Speciﬁcally, the neighbor node sends the query message
along its shortest path to the multicast source. Once the
ﬁrst on-tree node R is met, a response message is generated
and sent back to the neighbor node, carrying the value of
SHRS,R. The disadvantage of this query scheme is that it
does not guarantee to obtain SHRS,R for all on-tree nodes
and the selected multicast path may not be optimal, thus
degrading the protocol performance.
3.3.2 Protocol Overhead
SMRP meets its design goals by inducing a certain amount
of computation overhead in the maintenance of SHRS,R. In
order to keep the value up-to-date, any change in the current
tree (e.g., node joins or leaves) might trigger a new tree-
wide update process. One solution is to defer the calcula-
tion of the new SHRS,R value until it is really needed. In the
modiﬁed protocol, each node initiates the re-calculation of
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:53:13 UTC from IEEE Xplore.  Restrictions apply. 
RD1
S
A1
Multicast Source S
RD Agent
Multicast Member
Recovery Domain L1
Recovery Domain L2
A3
RD3
RD0
RD2
A2
R1
R2
Figure 6. Hierarchical recovery architecture
its SHRS,R only when a query message from a certain new
member is received. With the adoption of this technique,
the maintenance overhead is amortized into each member’s
join process. Nowadays, with fast expansion of Internet ser-
vices, more and more functionalities (e.g., the identiﬁcation
of an authorized member for billing or auditing reasons)
have been emerging in the new multicast applications [8].
In view of these complicated functionalities, the fairly small
overhead introduced by SMRP should be acceptable, espe-
cially when fast service recovery is required or desired.
3.3.3 Hierarchical Recovery Architecture
All of the previous descriptions of SMRP assume a ﬂat net-
work topology. We now extend the basic protocol into an
N-level hierarchical network model and explore how this
structure improves the scalability of SMRP.
Figure 6 shows a 2-level hierarchical recovery architec-
ture. We choose a 2-level hierarchy because it can be eas-
ily mapped onto the current transit-stub Internet structure.
Such a 2-level hierarchical structure can be easily general-
ized into an N-level architecture. The recovery architecture
is created by constructing sub-multicast trees in different
levels. Each sub-multicast tree represents a recovery do-
main and any node/link failure inside a recovery domain
is handled by that domain. As shown in the ﬁgure, mem-
bers are usually clustered into the lowest level (i.e., recov-
ery domain L1) based on their proximity in the network. In
each recovery domain, there is an agent acting as the mul-
ticast source only for the members inside this domain. The
only exception is the recovery domain of the actual multi-
cast source in which the agent acts as a multicast member
(e.g., A1 in Figure 6) relaying packets from the source to the
rest of the tree. All (n − 1)-level agents are clustered so as
to create a certain number of n-level recovery domains.
In what follows, we examine how the multicast ses-
sion recovers from any link/node failure in the network.
Consider the multicast path between S and R1 which runs
through recovery domains RD1, RD0, and RD2 in order.
As long as the domain in which the failure occurs is iden-
tiﬁed [1], a fast recovery via local detour path is possi-
ble by deploying SMRP in that domain. For example, if
the failure occurs in RD0, agent A2 then uses its neighbor
node A3 to reconnect to the multicast tree and all tree re-
conﬁgurations are conﬁned inside RD0. The accommoda-
tion of SMRP into a hierarchical structure indicates the fea-
sibility of its incorporation into other hierarchical architec-
tures, like NICE [18], for better fault-tolerance.
4 The Simulation Results
In this section, we present the simulation results that
demonstrate the merits of the proposed protocol. We ﬁrst
describe the simulation setup and evaluation metrics, then
present the simulation results.
4.1 Simulation Setup
We use ns2 [24] to simulate the operations of SMRP. The
network topologies are generated by GT-ITM [11], adopting
the most common random graph model proposed by Wax-
man [2] to reﬂect the structure of real internetworks. With
this model, the nodes are distributed randomly in the plane,
and for an edge between pairs of nodes (u,v), the edge prob-
ability is given by:
P(u,v) = α · e− d(u,v)
β·L
,
where 0 ≤ α,β ≤ 1 and d(u,v) is the Euclidean distance
from u to v. An increase in α increases the edge density,
while an increase in β increases the number of connections
of distant nodes. Since we are only interested in the effects
of the average node degree on the performance of SMRP,
and Zegura et al. [7] showed that a targeted node degree
can be achieved by different combinations of α and β, we
ﬁx the value of β and only change α for our purpose.
In order to explore the characteristics of SMRP more
thoroughly, we introduce the following parameters to con-
ﬁgure the network scenarios and the proposed protocol.
• N: the number of nodes in the network.
• NG: the number of multicast members.
• α: the parameter to decide the average node degree.
• Dthresh: the parameter to bound the length of the path
as described in Section 3.2.2.
4.2 Evaluation Metrics
The simulations were conducted to compare SMRP
against the traditional SPF-based multiple routing protocols
in terms of the following performance metrics.
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:53:13 UTC from IEEE Xplore.  Restrictions apply. 
160
140
120
100
80
60
40
20
r
u
o
t
e
d
l
a
c
o
l
n
i
e
c
n
a
t
s
d
y
r
e
v
o
c
e
r
i
0
0
y = x
90
80
70
60
50
40
30
20
10
relative
Maximum RDR
Average RDR
relative
150
0
0.05
0.1
0.15
0.2
0.3
0.35
0.4
0.45
0.25
Dthresh
(a) performance improvement
50
100
recovery distance in global detour
Figure 7. Local detour vs global detour
• Recovery Distance (RDR): the distance between the
disconnected member R and its local recovery on-tree
node.
• End-to-End Delay (DS,R): the distance between the
source S and each multicast member R.
• Tree Cost (CostT ): the sum of the link costs in the
multicast tree. Although SPF-based multicast routing
protocols do not yield optimal paths in terms of tree
cost, we expect that the results presented in this pa-
per are also applicable to the cost-minimizing multi-
cast routing protocols using the study in [13].
The absolute value of the metrics varies arbitrarily, de-
pending on the speciﬁc network topology or multicast mem-
ber selection. Instead, we compute their relative values as
follows.
RDrelative
R
Drelative
S,R
Costrelative
T
= RDSPF
R − RDSMRP
R
RDSPF
DSMRP
S,R − DSPF
S,R
R
=
DSPF
S,R
= CostSMRP
T
−CostSPF
T
T
CostSPF
4.3 Analysis of Simulation Results
We conducted the simulation while varying the conﬁg-
uration of three major parameters, Dthresh in protocol de-
sign, α and NG in topology setup. Here we present and
analyze the main results, demonstrating the salient features
of SMRP.
4.3.1 Global Detour vs. Local Detour
In this section, we verify the correctness of the argument
that motivates the design of SMRP, that is, a local detour re-
covery path is superior to the path established automatically
by SPF-based multicast routing protocols (e.g., MOSPF [9],
relative
relative
Maximum DR
Average DR
relative
CostT
40
35
30
25
20
15
10
5
0
0.05
0.1
0.15
0.2
0.3
0.35