ETW registration (internally called EtwRegistration) object type, which allow a provider to be
registered from a user-mode application.
5. 
Registers the ETW bugcheck callback, used to dump logger sessions data in the bugcheck dump.
6.
Initializes and starts the Global logger and Autologgers sessions, based on the AutoLogger and
GlobalLogger registry keys located under the HKLM\System\CurrentControlSet\Control\WMI
root key.
7. 
Uses the EtwRegister kernel API to register various NT kernel event providers, like the Kernel
Event Tracing, General Events provider, Process, Network, Disk, File Name, IO, and Memory
providers, and so on.
8.
Publishes the ETW initialized WNF state name to indicate that the ETW subsystem is initialized.
9.
Writes the SystemStart event to both the Global Trace logging and General Events providers.
The event, which is shown in Figure 10-32, logs the approximate OS Startup time.
10. If required, loads the FileInfo driver, which provides supplemental information on files I/O to
Superfetch (more information on the Proactive memory management is available in Chapter 5
of Part 1).
502 
CHAPTER 10 Management, diagnostics, and tracing
FIGURE 10-32 The SystemStart ETW event displayed by the Event Viewer.
In early boot phases, the Windows registry and I/O subsystems are still not completely initialized. So 
ETW can’t directly write to the log files. Late in the boot process, after the Session Manager (SMSS.exe) 
has correctly initialized the software hive, the last phase of ETW initialization takes place. The purpose 
of this phase is just to inform each already-registered global ETW session that the file system is ready, 
so that they can flush out all the events that are recorded in the ETW buffers to the log file.
ETW sessions
One of the most important entities of ETW is the Session (internally called logger instance), which is a 
glue between providers and consumers. An event tracing session records events from one or more pro-
viders that a controller has enabled. A session usually contains all the information that describes which 
events should be recorded by which providers and how the events should be processed. For example, 
a session might be configured to accept all events from the Microsoft-Windows-Hyper-V-Hypervisor 
provider (which is internally identified using the {52fc89f8-995e-434c-a91e-199986449890} GUID). The 
user can also configure filters. Each event generated by a provider (or a provider group) can be filtered 
based on event level (information, warning, error, or critical), event keyword, event ID, and other char-
acteristics. The session configuration can also define various other details for the session, such as what 
time source should be used for the event timestamps (for example, QPC, TSC, or system time), which 
events should have stack traces captured, and so on. The session has the important rule to host the 
ETW logger thread, which is the main entity that flushes the events to the log file or delivers them to 
the real-time consumer.
CHAPTER 10 Management, diagnostics, and tracing
503
Sessions are created using the StartTrace API and configured using ControlTrace and EnableTraceEx2. 
Command-line tools such as xperf, logman, tracelog, and wevtutil use these APIs to start or control 
trace sessions. A session also can be configured to be private to the process that creates it. In this case, 
ETW is used for consuming events created only by the same application that also acts as provider. The 
application thus eliminates the overhead associated with the kernel-mode transition. Private ETW ses-
sions can record only events for the threads of the process in which it is executing and cannot be used 
with real-time delivery. The internal architecture of private ETW is not described in this book. 
When a global session is created, the StartTrace API validates the parameters and copies them in a 
data structure, which the NtTraceControl API uses to invoke the internal function EtwpStartLogger in the 
kernel. An ETW session is represented internally through an ETW_LOGGER_CONTEXT data structure, 
which contains the important pointers to the session memory buffers, where the events are written 
to. As discussed in the “ETW initialization” section, a system can support a limited number of ETW ses-
sions, which are stored in an array located in a global per-SILO data structure. EtwpStartLogger checks 
the global sessions array, determining whether there is free space or if a session with the same name 
already exists. If that is the case, it exits and signals an error. Otherwise, it generates a session GUID (if 
not already specified by the caller), allocates and initializes an ETW_LOGGER_CONTEXT data structure 
representing the session, assigns to it an index, and inserts it in the per-silo array. 
ETW queries the session’s security descriptor located in the HKLM\System\CurrentControlSet\
Control\Wmi\Security registry key. As shown in Figure 10-33, each registry value in the key is named as 
the session GUID (the registry key, however, also contains the provider’s GUID) and contains the binary 
representation of a self-relative security descriptor. If a security descriptor for the session does not ex-
ist, a default one is returned for the session (see the “Witnessing the default security descriptor of ETW 
sessions” experiment later in this chapter for details).
FIGURE 10-33 The ETW security registry key.
504 
CHAPTER 10 Management, diagnostics, and tracing
The EtwpStartLogger function performs an access check on the session’s security descriptor, request-
ing the TRACELOG_GUID_ENABLE access right (and the TRACELOG_CREATE_REALTIME or TRACELOG_
CREATE_ONDISK depending on the log file mode) using the current process’s access token. If the check 
succeeds, the routine calculates the default size and numbers of event buffers, which are calculated 
based on the size of the system physical memory (the default buffer size is 8, 16, or 64KB). The number 
of buffers depends on the number of system processors and on the presence of the EVENT_TRACE_
NO_PER_PROCESSOR_BUFFERING logger mode flag, which prevents events (which can be generated 
from different processors) to be written to a per-processor buffer.
ETW acquires the session’s initial reference time stamp. Three clock resolutions are currently support-
ed: Query performance counter (QPC, a high-resolution time stamp not affected by the system clock), 
System time, and CPU cycle counter. The EtwpAllocateTraceBuffer function is used to allocate each buffer 
associated with the logger session (the number of buffers was calculated before or specified as input 
from the user). A buffer can be allocated from the paged pool, nonpaged pool, or directly from physical 
large pages, depending on the logging mode. Each buffer is stored in multiple internal per-session lists, 
which are able to provide fast lookup both to the ETW main logger thread and ETW providers. Finally, 
if the log mode is not set to a circular buffer, the EtwpStartLogger function starts the main ETW logger 
thread, which has the goal of flushing events written by the providers associated with the session to the 
log file or to the real-time consumer. After the main thread is started, ETW sends a session notification to 
the registered session notification provider (GUID 2a6e185b-90de-4fc5-826c-9f44e608a427), a special 
provider that allows its consumers to be informed when certain ETW events happen (like a new session 
being created or destroyed, a new log file being created, or a log error being raised).
EXPERIMENT: Enumerating ETW sessions 
In Windows 10, there are multiple ways to enumerate active ETW sessions. In this and all the 
next experiments regarding ETW, you will use the XPERF tool, which is part of the Windows 
Performance Toolkit distributed in the Windows Assessment and Deployment Kit (ADK), which 
is freely downloadable from https://docs.microsoft.com/en-us/windows-hardware/get-started/
adk-install. 
Enumerating active ETW sessions can be done in multiple ways. XPERF can do it while 
executed with the following command (usually XPERF is installed in C:\Program Files  
(x86)\Windows Kits\10\Windows Performance Toolkit):
xperf -Loggers
The output of the command can be huge, so it is strongly advised to redirect the output in 
a TXT file:
xperf -Loggers > ETW_Sessions.txt
EXPERIMENT: Enumerating ETW sessions 
In Windows 10, there are multiple ways to enumerate active ETW sessions. In this and all the 
next experiments regarding ETW, you will use the XPERF tool, which is part of the Windows 
Performance Toolkit distributed in the Windows Assessment and Deployment Kit (ADK), which 
is freely downloadable from https://docs.microsoft.com/en-us/windows-hardware/get-started/
adk-install. 
Enumerating active ETW sessions can be done in multiple ways. XPERF can do it while 
executed with the following command (usually XPERF is installed in C:\Program Files 
(x86)\Windows Kits\10\Windows Performance Toolkit):
xperf -Loggers
The output of the command can be huge, so it is strongly advised to redirect the output in 
a TXT file:
xperf -Loggers > ETW_Sessions.txt
CHAPTER 10 Management, diagnostics, and tracing
505
The tool can decode and show in a human-readable form all the session configuration data. 
An example is given from the EventLog-Application session, which is used by the Event logger 
service (Wevtsvc.dll) to write events in the Application.evtx file shown by the Event Viewer:
Logger Name           : EventLog-Application 
Logger Id             : 9 
Logger Thread Id      : 000000000000008C 
Buffer Size
: 64 
Maximum Buffers
: 64 
Minimum Buffers
: 2 
Number of Buffers     : 2 
Free Buffers
: 2 
Buffers Written       : 252 
Events Lost
: 0 
Log Buffers Lost
: 0 
Real Time Buffers Lost: 0 
Flush Timer           : 1 
Age Limit             : 0 
Real Time Mode        : Enabled 
Log File Mode
: Secure PersistOnHybridShutdown PagedMemory IndependentSession 
NoPerProcessorBuffering 
Maximum File Size     : 100 
Log Filename          :  
Trace Flags
: "Microsoft-Windows-CertificateServicesClient-Lifecycle-User":0x800
0000000000000:0xff+"Microsoft-Windows-SenseIR":0x8000000000000000:0xff+ 
... (output cut for space reasons)
The tool is also able to decode the name of each provider enabled in the session and the 
bitmask of event categories that the provider should write to the sessions. The interpretation of 
the bitmask (shown under “Trace Flags”) depends on the provider. For example, a provider can 
define that the category 1 (bit 0 set) indicates the set of events generated during initialization 
and cleanup, category 2 (bit 1 set) indicates the set of events generated when registry I/O is per-
formed, and so on. The trace flags are interpreted differently for System sessions (see the “System 
loggers” section for more details.) In that case, the flags are decoded from the enabled kernel 
flags that specify which kind of kernel events the system session should log.
The Windows Performance Monitor, in addition to dealing with system performance counters, 
can easily enumerate the ETW sessions. Open Performance Monitor (by typing perfmon in the 
Cortana search box), expand the Data Collector Sets, and click Event Trace Sessions. The applica-
tion should list the same sessions listed by XPERF. If you right-click a session’s name and select 
Properties, you should be able to navigate between the session’s configurations. In particular, the 
Security property sheet decodes the security descriptor of the ETW session.
The tool can decode and show in a human-readable form all the session configuration data. 
An example is given from the EventLog-Application session, which is used by the Event logger 
service (Wevtsvc.dll) to write events in the Application.evtx file shown by the Event Viewer:
Logger Name           : EventLog-Application
Logger Id             : 9
Logger Thread Id      : 000000000000008C
Buffer Size
: 64
Maximum Buffers
: 64
Minimum Buffers
: 2
Number of Buffers     : 2
Free Buffers
: 2
Buffers Written       : 252
Events Lost
: 0
Log Buffers Lost
: 0
Real Time Buffers Lost: 0
Flush Timer           : 1
Age Limit             : 0
Real Time Mode        : Enabled
Log File Mode
: Secure PersistOnHybridShutdown PagedMemory IndependentSession 
NoPerProcessorBuffering
Maximum File Size     : 100
Log Filename          : 
Trace Flags
: "Microsoft-Windows-CertificateServicesClient-Lifecycle-User":0x800
0000000000000:0xff+"Microsoft-Windows-SenseIR":0x8000000000000000:0xff+ 
... (output cut for space reasons)
The tool is also able to decode the name of each provider enabled in the session and the 
bitmask of event categories that the provider should write to the sessions. The interpretation of 
the bitmask (shown under “Trace Flags”) depends on the provider. For example, a provider can 
define that the category 1 (bit 0 set) indicates the set of events generated during initialization 
and cleanup, category 2 (bit 1 set) indicates the set of events generated when registry I/O is per-
formed, and so on. The trace flags are interpreted differently for System sessions (see the “System 
loggers” section for more details.) In that case, the flags are decoded from the enabled kernel 
flags that specify which kind of kernel events the system session should log.
The Windows Performance Monitor, in addition to dealing with system performance counters, 
can easily enumerate the ETW sessions. Open Performance Monitor (by typing perfmon in the 
Cortana search box), expand the Data Collector Sets, and click Event Trace Sessions. The applica-
tion should list the same sessions listed by XPERF. If you right-click a session’s name and select 
Properties, you should be able to navigate between the session’s configurations. In particular, the 
Security property sheet decodes the security descriptor of the ETW session.
Security property sheet decodes the security descriptor of the ETW session.
Security
506 
CHAPTER 10 Management, diagnostics, and tracing
Finally, you also can use the Microsoft Logman console tool (%SystemRoot%\System32\
logman.exe) to enumerate active ETW sessions (by using the -ets command-line argument).
ETW providers
As stated in the previous sections, a provider is a component that produces events (while the applica-
tion that includes the provider contains event tracing instrumentation). ETW supports different kinds 
of providers, which all share a similar programming model. (They are mainly different in the way in 
which they encode events.) A provider must be initially registered with ETW before it can generate any 
event. In a similar way, a controller application should enable the provider and associate it with an ETW 
session to be able to receive events from the provider. If no session has enabled a provider, the pro-
vider will not generate any event. The provider defines its interpretation of being enabled or disabled. 
Generally, an enabled provider generates events, and a disabled provider does not.
Providers registration
Each provider’s type has its own API that needs to be called by a provider application (or driver) for reg-
istering a provider. For example, manifest-based providers rely on the EventRegister API for user-mode 
registrations, and EtwRegister for kernel-mode registrations. All the provider types end up calling the 
internal EtwpRegisterProvider function, which performs the actual registration process (and is imple-
mented in both the NT kernel and NTDLL). The latter allocates and initializes an ETW_GUID_ENTRY data 
structure, which represents the provider (the same data structure is used for notifications and traits). 
The data structure contains important information, like the provider GUID, security descriptor, refer-
ence counter, enablement information (for each ETW session that enables the provider), and a list of 
provider’s registrations. 
Finally, you also can use the Microsoft Logman console tool (%SystemRoot%\System32\
logman.exe) to enumerate active ETW sessions (by using the -ets command-line argument).
CHAPTER 10 Management, diagnostics, and tracing
507
For user-mode provider registrations, the NT kernel performs an access check on the calling pro-
cess’s token, requesting the TRACELOG_REGISTER_GUIDS access right. If the check succeeds, or if the 
registration request originated from kernel code, ETW inserts the new ETW_GUID_ENTRY data struc-
ture in a hash table located in the global ETW per-silo data structure, using a hash of the provider’s 
GUID as the table’s key (this allows fast lookup of all the providers registered in the system.) In case an 
entry with the same GUID already exists in the hash table, ETW uses the existing entry instead of the 
new one. A GUID could already exist in the hash table mainly for two reasons:
I 
Another driver or application has enabled the provider before it has been actually registered
(see the “Providers enablement” section later in this chapter for more details) .
I 
The provider has been already registered once. Multiple registration of the same provider GUID
are supported.
After the provider has been successfully added into the global list, ETW creates and initializes an 
ETW registration object, which represents a single registration. The object encapsulates an ETW_REG_
ENTRY data structure, which ties the provider to the process and session that requested its registration. 
(ETW also supports registration from different sessions.) The object is inserted in a list located in the 
ETW_GUID_ENTRY (the EtwRegistration object type has been previously created and registered with 
the NT object manager at ETW initialization time). Figure 10-34 shows the two data structures and their 
relationships. In the figure, two providers’ processes (process A, living in session 4, and process B, living 
in session 16) have registered for provider 1. Thus two ETW_REG_ENTRY data structures have been cre-
ated and linked to the ETW_GUID_ENTRY representing provider 1.
…
…
ETW_REG_ENTRY
for provider app. A
which registered provider 1
ETW_GUID_ENTRY
(for provider 1)
ETW_Global
per-SILO hash-table
Reg. List Entry
ETW_GUID ptr.
Process B
Session ID 0x10
Callback’s Info
Flags
Traits
Reg. Enablement
Mask
ETW_REG_ENTRY
for provider app. B
which registered provider 1
ETW_GUID_ENTRY
(for provider 2)
ETW_GUID List
entry
ETW registrations
List head
Provider’s
GUID
Security 
Descriptor
Ref.
Counter