we resort to vulnerability-based detections. In this section, we ﬁrst
present two types of deployment for JShield. Then, we model
drive-by download vulnerabilities based on their control and data
ﬂows.
JShield is a dynamic vulnerability signature based approach to
de-obfuscate and detect drive-by download attacks. There are two
major types of deployment for JShield: 1) at the Web Application
Firewalls (WAF) or Web IDS/IPS and 2) at Web malware scan-
ning services. For the former, JShield is deployed as a component
of anti-virus software, or as a detection engine at Internet Service
Providers (ISP) gateways. For example, Huawei deploys our sys-
tem in their intelligent cloud, inspecting potential malicious trafﬁc
from their switches and routers. On the other hand, JShield can
also be deployed on the sever side as a Web malware scanning ser-
vice, by search engines such as Google and Bing, or by a security
company for online web malware scanning.
Compared to an anomaly based approach like Zozzle [23] which
needs to retrain the detection engine to accommodate new drive-by
download exploits, JShield only needs to update its vulnerability
signature database for new drive-by download vulnerabilities. Due
to that fact that the number of vulnerabilities is always much less
than the amount of exploits, the update overhead of JShield will be
small.
4.2 Vulnerability Modeling
Traditionally, there are three types of signatures in literature [20]:
Turing machine signature, symbolic constraint signature, and regu-
lar expression signature. We look into those signatures in the con-
text of a drive-by download attack where the vulnerable program is
a browser and the input exploit is a JavaScript program. The Tur-
ing machine signature generation process from Brumley et al. [20]
would output a signature as large as a browser, hence making it
unusable. On the other hand, neither symbolic constraint signature
nor regular expression can represent a complex language like Java-
Script which have loops. Thus, for preciseness, we need to have
a new signature between a Turing machine signature generated by
Brumley et al. and a symbolic constraint signature. For matching
speed, we ﬁrst use regular expression signature to ﬁlter a majority
of benign JavaScript and then detect malicious JavaScript using the
precise detection format of our opcode signature. Since regular ex-
pression signature is well known, we focus on the detection format
of our opcode signature.
To model a vulnerability, we deﬁne a vulnerability condition as
a function that takes a certain path of a program’s control and data
ﬂow graph, and output whether the path is exploitable or not. For-
mally, given c ∈ C, where C is all possible paths of the program’s
control ﬂow graph, and d ∈ D, where D is all possible paths of the
program’s data ﬂow graph, a vulnerability condition k is a function,
k : C × D → {Saf e, Exploit}
In order to match a certain vulnerability, its corresponding vul-
nerability signature need to match both the path in the control ﬂow
Vulnerability
Modeling
Opcode Abstraction 
of JS Engine CFG
Opcode Abstraction 
of JS Engine DFG
DFA
Variable 
Pool
Opcode 
signature
Figure 4: Vulnerability Modeling.
Opcode
API Calls determined by 
opcodes + parameters
o pco d e 1
o p c o d e 2
S0
Parameters
S1_1
S2_1
Plug-in
Parameters
S2_2
DOM
S1_2
...
S1_n
Layer 1
Layer 2
Layer 3
Figure 5: Simpliﬁed Opcode Level Control Flow Graph of JavaScript Inter-
preter.
graph and the one in the data ﬂow graph. In the context of a drive-
by download attack where the vulnerability exist in a JavaScript
engine or a plugin, our observation is that control and data ﬂow
graphs of the opcode input is an abstraction of the control and data
ﬂow graphs of the native JavaScipt engine. Thus, as shown in Fig-
ure 4, we can model the underline vulnerability in the JavaScript
engine or plugin by abstracting the control and data ﬂow to the op-
code level.
To study the control ﬂow, we investigate the source code of sev-
eral JavaScript engines [14, 17, 39], and ﬁnd that the main body of a
JavaScript interpreter switches to different branches of codes based
on the input opcode through a code pattern similar to select input
case opcode. Then, different opcodes and parameters determine
subsequent API calls to external objects, plugin or DOM. There-
fore, we form the control ﬂow graph (CFG) of JavaScript engine
into an opcode driven three-layer structure as shown in Figure 5.
The CFG will shift based on the input opcode sequence. In other
words, opcode CFG is built upon the original application CFG.
Next, we categorize vulnerabilities into two types: JavaScript
engine vulnerability (including a web browser JavaScript engine
and/or a plugin JavaScript engine such as Adobe Reader JavaScript
engine) and external JavaScript engine vulnerability. We will ex-
plain them respectively.
Let us assume that the control ﬂow graph of a JavaScript engine
vulnerability condition is triggered by travelling through S1_1 and
S1_2 of Figure 5. Since there is only one path to travel to S1_1
and/or S1_2, which is to offer the corresponding opcode, the op-
code level signature represents this vulnerability.
For an external JavaScript engine vulnerability, the API calls to
those components such as plugin and DOM are determined by op-
code sequences and parameters. Song et al. [50] show that the inter-
module communication can represent a vulnerability and thus our
opcode signature can achieve the same functionality.
Therefore, we propose an opcode level deterministic ﬁnite au-
tomaton (further explained in Section 5) to match the opcode con-
trol ﬂow, an abstraction of the JavaScript engine control ﬂow, in a
vulnerability condition.
1 switch (opcode) {
2
case get_by_id:
// (1) look up the prototype chain
// (2) invoke getter method
// (3) move results to register r0
break;
case put_by_id:
// (4) move null to the prototype
break;
Figure 6: Pseudo JavaScript Engine Codes for CVE-2009-1833.
var obj = new Object();
obj.__proto__.__defineGetter__("a"
, function () {
this.__proto__ = null;
gc();
return 0;
});
3
4
5
6 }
1
2
3
4
5
6
7 obj.a;
Figure 7: Example I: CVE-2009-1833: Malicious JavaScript Exploit that
can Trigger a Mozilla Firefox JavaScript Engine Vulnerability.
To study the data ﬂow, JShield needs to record additional states
related to the vulnerability. Therefore, we propose a variable pool
(further explained in Section 5) to match the opcode data ﬂow, an
abstraction of JavaScript engine data ﬂow, in a vulnerability condi-
tion.
Now, we illustrate the point by a concrete running example from
CVE database. In Figure 6, we show how to trigger CVE-2009-
1833 in the pseudo code of JavaScript engine. The vulnerability
is triggered by two conditions: (i) looking up through prototype
chain to get a getter function, and (ii) setting the prototype itself to
be null inside the getter function.
When we abstract the JavaScript engine vulnerability to the op-
code level and take a look at a concrete exploit example trigger-
ing vulnerability in Figure 7 and Figure 8, we ﬁnd that the opcode
level CFG is an abstraction of the underline level JavaScript engine
CFG. S1_1 in Figure 5 is visited by get_by_id and S1_2 is visited
by put_by_id. For the data ﬂow, to match CVE-2009-1833, JShield
needs to remember the memory address of the prototype.
In sum, the JShield signature needs to match both the control
ﬂow graph and the data ﬂow graph of opcode sequence of a Java-
Script code, an abstraction for the control and data ﬂow graph of the
underline JavaScript engine, for a drive-by download vulnerability
condition as shown in Figure 4.
5. OPCODE SIGNATURE
As discussed in Section 4.2, a successful opcode signature needs
to match both the control ﬂow and the data ﬂow of a vulnerabil-
ity condition. In this section, we introduce the detailed design of
opcode signature matching drive-by download vulnerabilities. To
speed up the matching process, two types of opcode signature, the
detection format and the ﬁlter format, are described here by their
deﬁnition, structure and matching process. In the end, we present
the robustness of opcode vulnerability signature to polymorphic at-
tacks.
In the current version of JShield, all the opcode vulnerability sig-
natures are generated manually for each vulnerability. However, we
believe that the amount of involved manual work is small due to the
small number ( = f (ri, ai, p), for i = 0,..., n-1.
3. rn ∈ F .
In Deﬁnition 2, we formalize the ﬁlter format2 of the opcode
vulnerability signature as a regular expression.
DEFINITION 2. We deﬁne the ﬁlter format of opcode signature
as a 5-tuple (Q, Σ, f, q0, F), where
• Σ is ﬁnite set of input symbols, and Q is ﬁnite set of states.
• f is a transition function, Q × Σ → Q.
• q0 ∈ Q is a start state, and F ⊆ Q.
For input ai ∈ Σ, the next state of the automaton obeys the
following conditions:
1. r0 = q0.
2. ri+1 = f (ri, ai), for i = 0,..., n-1.
3. rn ∈ F .
5.2 Structure
We introduce the structures of the detection and ﬁlter format of
opcode signatures in this section.
2Unless speciﬁed, opcode signature refers to the detection format
of opcode signature. The ﬁlter format refers to the ﬁlter format of
opcode signature.
Detection Format:
#
Method Opcode
Condition
Action
Next
enter
true
get_by_id isFromProtoChain() x=proto (2)
N/A
(3)
N/A
(3)
N/A
(3)
N/A
(3)
enter
ret
ret
put_by_id x==dst & src==null report
quit
i=0
quit
i=i+1
quit
i=i-1
true
i==0
i>0
jmp
(1) match
default
(2) match
default
(3) match
match
match
match
default
Filter Format:
get_by_id enter .* put_by_id
Figure 9: Opcode Signature for CVE-2009-1833.
5.2.1 Detection Format
The detection format of an opcode signature, as shown in Fig-
ure 9, can be formalized into the following three concepts: clause,
sentence, and signature.
A clause in an opcode signature consists of ﬁve ﬁelds: “method”,
“opcode”, “condition”, “action”, and “next”. The “method” ﬁeld
speciﬁes what to be taken in this clause, where two methods are
currently deﬁned: “match” and “default”. “Match” means to match
the opcode, and “default” means that the default actions should be
taken if no matches are found in other clauses. Then if both “op-
code” ﬁeld matches the input opcode and the expression in “con-
dition” ﬁeld is true, the action in the “action” ﬁeld will be taken
and current state will be transferred to the number in “next” ﬁeld,
which represents the sentence number that will be explained right
after this paragraph.
Multiple clauses plus an index number together build a sentence,
a state in automaton. The number is used to differentiate one sen-
tence from the others. The clauses in one sentence are in sequence,
which means if JShield ﬁnds the ﬁrst match, the remaining ones
will be skipped. If no matches are found, the action corresponded
with the “default” clause will be taken.
A signature consists of multiple sentences. During matching, the
automaton will transfer from one sentence to anther based on the
matching results.
5.2.2 Filter Format
The ﬁlter format of an opcode signature, as shown in Figure 9,
can be formalized as a regular expression, which takes a series of
opcodes as input. For detection and ﬁlter format of opcode signa-
ture, the following statement holds: “Each detection format of an
opcode signature has a corresponding ﬁlter format of that opcode
signature”.
Here is the reason. Given a detection format of an opcode sig-
nature, for each sentence, we extract all Opcode ﬁelds and align
them into a unit by bracket symbol of regular expression. Then,
by following the jmp operations in Action ﬁeld, we align the units
into a regular expression. If a self loop is recognized, a symbol ∗
is introduced. The end of the regular expression is one or multiple
opcodes in bracket that leads to the vulnerability.
5.2.3 Data Structure of Both Formats
The ﬁlter format is simply stored as a regular expression. To
speed up matching process, we construct a reverse index for the
detection format of opcode signatures by the opcode ﬁeld. Suppose
we have two signatures: Sig1 and Sig2. Each signature has two
sentences. Each sentence has two clauses. Under each opcode,
both two signatures exist. Under each signature, both two sentences
exist. Under each sentence, only the clause with that opcode is
Algorithm 1 Matching Detection Format
Sample One:
if (IsAllT rue(Clause.Conditions) then
Take Actions
Signature.State ⇐ N ew_State
Break
for Signature in Pool[Input_Opcode] do
Sentence ⇐ Signature[State]
Clause ⇐ Sentence.Clause
if equal(M ethod, M atch) then
1: State ← Starting_State