the overhead under free scheduling is much higher than pinned
scheduling. We believe this is because these two benchmarks
depend more heavily on data (memory) access. Note that,
unlike Strata, for SDCG-ported V8, we not only shared the
code cache, but also shared the heaps used to store JS objects,
for the ease of RPC implementation. Besides RPC frequency,
this is another reason why we observed a higher overhead
compared with SDCG-ported Strata.
VII. DISCUSSION
In this section, we discuss the limitations of this work and
potential future work.
A. Reliability of Race Condition
Although we only showed the feasibility of the attack in
one scenario, the dynamic translator can be invoked under
different situations, each of which has its own race condition
window. Some operations can be quick (e.g., patching), while
others may take longer. By carefully controlling how the
translator is invoked, we can extend the race condition window
and make such attacks more reliable.
In addition, OS scheduling can also affect the size of the
attack window. For example, as we have discussed in the
Section III, the invocation of mprotect is likely to cause
13
-­‐1.00%	
  0.00%	
  1.00%	
  2.00%	
  3.00%	
  4.00%	
  5.00%	
  6.00%	
  perlbench	
  bzip2	
  gcc	
  mcf	
  gobmk	
  hmmer	
  sjeng	
  libquantum	
  h264ref	
  omnetpp	
  astar	
  xalancbmk	
  GEOMEAN	
  SDCG	
  (Pinned)	
  SDCG	
  (Free)	
  In addition, our current prototype implementations of
SDCG are not hardware-aware. Different processors can have
different shared cache architectures and cache management ca-
pabilities, which in turn affects cache synchronization between
different threads. Speciﬁcally, on a multi-processor system,
two cores may or may not share the same cache. As we
have demonstrated, if the translator thread and the execution
thread are scheduled to two cores with different cache, then the
performance is much worse than when they are scheduled to
cores with the same cache. To further reduce the overhead, we
can assign processor afﬁnity according to hardware features.
VIII. CONCLUSION
In this paper, we highlighted that a code cache injection
attack is a viable exploit technique that can bypass many state-
of-art defense mechanisms. To defeat this threat, we proposed
SDCG, a new architecture that enforces mandatory W⊕X
policy. To demonstrate the feasibility and beneﬁt of SDCG,
we ported two software dynamic translators, Google V8 and
Strata, to this new architecture. Our development experience
showed that SDCG is easy to adopt and our performance
evaluation showed the performance overhead is small.
ACKNOWLEDGEMENTS
The authors would like to thank the anonymous reviewers
their helpful feedback, as well as our operations staff for their
proofreading efforts. This material is based upon work sup-
ported in part by the National Science Foundation under Grants
No. CNS-1017265, CNS-0831300, and CNS-1149051, by the
Ofﬁce of Naval Research under Grant No. N000140911042,
by the Department of Homeland Security under contract No.
N66001-12-C-0133, and by the United States Air Force under
Contract No. FA8650-10-C-7025. Any opinions, ﬁndings, and
conclusions or recommendations expressed in this material are
those of the authors and do not necessarily reﬂect the views of
theNational Science Foundation, the Ofﬁce of Naval Research,
the Department of Homeland Security, or the United States Air
Force.
REFERENCES
[1] “Yet another new approach to seccomp,” http://lwn.net/Articles/
475043/, 2012.
[2] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-
ﬂow integrity,” in Proceedings of the 12th ACM conference on
Computer and Communications Security (CCS), 2005.
[3] Adobe Product Security Incident Response Team, “Inside
http://blogs.adobe.com/
Adobe Reader Protected Mode,”
security/2010/11/inside-adobe-reader-protected-mode-part-3-
broker-process-policies-and-inter-process-communication.html,
2010.
[4] S. Andersen and V. Abella, “Data Execution Prevention:
Changes to Functionality in Microsoft Windows XP Service
Pack 2, Part 3: Memory Protection Technologies,” http://technet.
microsoft.com/en-us/library/bb457155.aspx, 2004.
[5] J. Ansel, P. Marchenko, Ú. Erlingsson, E. Taylor, B. Chen,
D. L. Schuff, D. Sehr, C. L. Bifﬂe, and B. Yee, “Language-
independent sandboxing of just-in-time compilation and self-
modifying code,” in Proceedings of the 32nd ACM SIGPLAN
Conference on Programming Language Design and Implemen-
tation (PLDI), 2011.
[6] T. M. Austin, S. E. Breach, and G. S. Sohi, “Efﬁcient detection
of all pointer and array access errors,” in Proceedings of the
14
ACM SIGPLAN 1994 Conference on Programming Language
Design and Implementation (PLDI), 1994.
[7] J. Aycock, “A brief history of just-in-time,” ACM Computing
Surveys (CSUR), vol. 35, no. 2, pp. 97–113, 2003.
[8] E. G. Barrantes, D. H. Ackley, T. S. Palmer, D. Stefanovic, and
D. D. Zovi, “Randomized instruction set emulation to disrupt
binary code injection attacks,” in Proceedings of the 10th ACM
conference on Computer and Communications Security (CCS),
2003.
[9] F. Bellard, “Qemu, a fast and portable dynamic translator,”
in Proceedings of the Annual Conference on USENIX Annual
Technical Conference, 2005.
[10] M. Castro, M. Costa, J.-P. Martin, M. Peinado, P. Akritidis,
A. Donnelly, P. Barham, and R. Black, “Fast byte-granularity
software fault isolation,” in Proceedings of the ACM SIGOPS
22Nd Symposium on Operating Systems Principles (SOSP),
2009.
[11] X. Chen, “ASLR Bypass Apocalypse in Recent Zero-
http://www.ﬁreeye.com/blog/technical/cyber-
Day Exploits,”
exploits/2013/10/aslr-bypass-apocalypse-in-lately-zero-day-
exploits.html, 2013.
[12] W. Cheng, Q. Zhao, B. Yu, and S. Hiroshige, “Tainttrace:
Efﬁcient ﬂow tracing with dynamic binary rewriting,” in Pro-
ceedings of
the 11th IEEE Symposium on Computers and
Communications (ISCC), 2006.
[13] Y. Cheng, Z. Zhou, M. Yu, X. Ding, and R. H. Deng, “Ropecker:
A generic and practical approach for defending against rop
attacks,” in Proceedings of the Symposium on Network and
Distributed System Security (NDSS), 2014.
[14] Common Weakness Enumeration, “Cwe-416: use after free.”
[15] ——, “Cwe-680: Integer overﬂow to buffer overﬂow.”
[16] M. Conover, “w00w00 on heap overﬂows,” 1999.
[17] CVE,
in
vulnerabilities
“CVE
found
browsers,”
http://web.nvd.nist.gov/view/vuln/search-results?query=
browser&search_type=all&cves=on.
[18] M. Daniel, J. Honoroff, and C. Miller, “Engineering heap
overﬂow exploits with javascript,” in Proceedings of the 2Nd
Conference on USENIX Workshop on Offensive Technologies
(WOOT), 2008.
[19] D. Dhurjati and V. Adve, “Backwards-compatible array bounds
checking for c with very low overhead,” in Proceedings of the
28th International Conference on Software Engineering (ICSE),
2006.
[20] B. Ford and R. Cox, “Vx32: Lightweight user-level sandboxing
on the x86,” in USENIX 2008 Annual Technical Conference on
Annual Technical Conference, 2008.
[21] T. Garﬁnkel, B. Pfaff, and M. Rosenblum, “Ostia: A delegating
architecture for secure system call interposition,” in Proceedings
of the Symposium on Network and Distributed System Security
(NDSS), 2004.
[22] Google,
“Seccompsandbox,”
seccompsandbox/wiki/overview.
https://code.google.com/p/
[23] ——, “The sandbox design principles in Chrome,” http://dev.
chromium.org/developers/design-documents/sandbox.
[24] ——, “Design of chrome v8,” https://developers.google.com/v8/
design, 2008.
[25] J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and J. W. Davidson,
“ILR: Where’d My Gadgets Go?” in Proceedings of the 2012
IEEE Symposium on Security and Privacy (SP), 2012.
[26] W. Hu, J. Hiser, D. Williams, A. Filipi, J. W. Davidson,
D. Evans, J. C. Knight, A. Nguyen-Tuong, and J. Rowanhill,
“Secure and practical defense against code-injection attacks
using software dynamic translation,” in Proceedings of
the
2nd international conference on Virtual Execution Environments
(VEE), 2006.
[27] C. Kil, J. Jim, C. Bookholt, J. Xu, and P. Ning, “Address space
layout permutation (aslp): Towards ﬁne-grained randomization
of commodity software,” in Proceedings of the 22Nd Annual
Computer Security Applications Conference (ACSAC), 2006.
[28] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V. J. Reddi, and K. Hazelwood, “Pin: building
customized program analysis tools with dynamic instrumenta-
tion,” in Proceedings of the 2005 ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI),
2005.
[29] W. S. McPhee, “Operating system integrity in os/vs2,” IBM
Systems Journal, vol. 13, no. 3, pp. 230–252, 1974.
[30] Microsoft, “App capability declarations (Windows Runtime
apps),” http://msdn.microsoft.com/en-us/library/windows/apps/
hh464936.aspx, 2012.
[31] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, “Soft-
bound: Highly compatible and complete spatial memory safety
for c,” in Proceedings of the 2009 ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI),
2009.
[32] ——, “Cets: compiler enforced temporal safety for c,” in
Proceedings of the 2010 International Symposium on Memory
Management (ISMM), 2010.
[33] N. Nethercote and J. Seward, “Valgrind: a framework for heavy-
weight dynamic binary instrumentation,” in Proceedings of the
2007 ACM SIGPLAN Conference on Programming Language
Design and Implementation (PLDI), 2007.
[34] R. H. Netzer and B. P. Miller, “What are race conditions?:
Some issues and formalizations,” ACM Letters on Programming
Languages and Systems (LOPLAS), vol. 1, no. 1, pp. 74–88,
1992.
[35] T. Newsham, “Format string attacks,” 2000.
[36] J. Newsome and D. Song, “Dynamic taint analysis for automatic
detection, analysis, and signature generation of exploits on
commodity software,” 2005.
[37] B. Niu and G. Tan, “Modular control-ﬂow integrity,” in Proceed-
ings of the 35th ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI), 2014.
[38] ——, “Rockjit: Securing just-in-time compilation using modular
control-ﬂow integrity,” 2014.
[39] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Smashing
the gadgets: Hindering return-oriented programming using in-
place code randomization,” in Proceedings of the 2012 IEEE
Symposium on Security and Privacy (SP), 2012.
[40] ——, “Transparent rop exploit mitigation using indirect branch
tracing,” in Proceedings of the 22Nd USENIX Conference on
Security, 2013.
[41] H. PATIL and C. FISCHER, “Low-cost, concurrent checking of
pointer and array accesses in c programs,” Software: Practice
and Experience, vol. 27, no. 1, pp. 87–110, 1997.
[42] PaX-Team, “PaX Address Space Layout Randomization,” http:
//pax.grsecurity.net/docs/aslr.txt, 2003.
[43] P. Pie, “Mobile Pwn2Own Autumn 2013 - Chrome on Android
[45] F. Qin, C. Wang, Z. Li, H.-s. Kim, Y. Zhou, and Y. Wu, “Lift:
A low-overhead practical information ﬂow tracking system for
detecting security attacks,” in Proceedings of
the 39th An-
nual IEEE/ACM International Symposium on Microarchitecture,
2006.
[46] G. F. Roglia, L. Martignoni, R. Paleari, and D. Bruschi, “Sur-
gically returning to randomized lib (c),” in Proceedings of
the 2009 Annual Computer Security Applications Conference
(ACSAC), 2009.
[47] K. Scott, N. Kumar, S. Velusamy, B. Childers, J. W. Davidson,
and M. L. Soffa, “Retargetable and reconﬁgurable software
dynamic translation,” in Proceedings of the International Sym-
posium on Code Generation and Optimization (CGO), 2003.
[48] K. Scott and J. Davidson, “Strata: A software dynamic transla-
tion infrastructure,” Tech. Rep., 2001.
- Exploit Writeup,” 2013.
authors,
project
[44] T. V.
benchmarks/v7/run.html.
http://v8.googlecode.com/svn/data/
[49] D. Sehr, R. Muth, C. Bifﬂe, V. Khimenko, E. Pasko, K. Schimpf,
B. Yee, and B. Chen, “Adapting software fault isolation to
contemporary cpu architectures,” in Proceedings of the 19th
USENIX Conference on Security, 2010.
[50] F. J. Serna, “The info leak era on software exploitation,” Black
Hat USA, 2012.
[51] J. Seward and N. Nethercote, “Using valgrind to detect un-
deﬁned value errors with bit-precision,” in Proceedings of the
Annual Conference on USENIX Annual Technical Conference,
2005.
[52] H. Shacham, “The geometry of innocent ﬂesh on the bone:
Return-into-libc without function calls (on the x86),” in Pro-
ceedings of the 14th ACM conference on Computer and Com-
munications Security (CCS), 2007.
[53] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and
D. Boneh, “On the effectiveness of address-space randomiza-
tion,” in Proceedings of the 11th ACM conference on Computer
and Communications Security (CCS), 2004.
[54] A. Sintsov, “Writing jit-spray shellcode for fun and proﬁt,” 2010.
[55] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen,
and A.-R. Sadeghi, “Just-in-time code reuse: On the effective-
ness of ﬁne-grained address space layout randomization,” in
Proceedings of
the 2013 IEEE Symposium on Security and
Privacy (SP), 2013.
[56] Standard
Performance
Benchmarks,”
Evaluation Corporation,
“SPEC
http://www.spec.org/cpu2006/
CINT2006
CINT2006/.
[57] W3C, http://www.w3.org/TR/workers/, 2012.
[58] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham,
“Efﬁcient software-based fault isolation,” in Proceedings of the
Fourteenth ACM Symposium on Operating Systems Principles
(SOSP), 1994.
[59] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin, “Binary
stirring: Self-randomizing instruction addresses of legacy x86
binary code,” in Proceedings of the 2012 ACM conference on
Computer and Communications Security (CCS), 2012.
[60] T. Wei, T. Wang, L. Duan, and J. Luo, “Secure dynamic code
generation against spraying,” in Proceedings of the 17th ACM
conference on Computer and Communications Security (CCS),
2010.
[61] W. Xu, D. C. DuVarney, and R. Sekar, “An efﬁcient and
backwards-compatible transformation to ensure memory safety
of c programs,” in Proceedings of the 12th ACM SIGSOFT In-
ternational Symposium on Foundations of Software Engineering
(FSE), 2004.
[62] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy,
S. Okasaka, N. Narula, and N. Fullagar, “Native client: A
sandbox for portable, untrusted x86 native code,” in Proceedings
of the 2009 IEEE Symposium on Security and Privacy (SP),
2009.
[63] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
D. Song, and W. Zou, “Practical control ﬂow integrity and
randomization for binary executables,” in Proceedings of the
2013 IEEE Symposium on Security and Privacy (SP), 2013.
[64] M. Zhang and R. Sekar, “Control ﬂow integrity for cots bi-
naries,” in Proceedings of the 22Nd USENIX Conference on
Security, 2013.
15