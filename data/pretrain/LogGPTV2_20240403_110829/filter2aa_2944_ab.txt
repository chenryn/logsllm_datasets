7.1
Scoped tokens
218
Adding scoped tokens to Natter
220
■ The difference between scopes 
and permissions
223
7.2
Introducing OAuth2
226
Types of clients
227
■ Authorization grants
228
■ Discovering 
OAuth2 endpoints
229
7.3
The Authorization Code grant
230
Redirect URIs for different types of clients
235
■ Hardening code 
exchange with PKCE
236
■ Refresh tokens
237
7.4
Validating an access token
239
Token introspection
239
■ Securing the HTTPS client 
configuration
245
■ Token revocation
248
■ JWT access 
tokens
249
■ Encrypted JWT access tokens
256
■ Letting the 
AS decrypt the tokens
258
7.5
Single sign-on
258
7.6
OpenID Connect
260
ID tokens
260
■ Hardening OIDC
263
■ Passing an ID token 
to an API
264
8 
Identity-based access control
267
8.1
Users and groups
268
LDAP groups
271
8.2
Role-based access control
274
Mapping roles to permissions
276
■ Static roles
277
Determining user roles
279
■ Dynamic roles
280
8.3
Attribute-based access control
282
Combining decisions
284
■ Implementing ABAC decisions
285
Policy agents and API gateways
289
■ Distributed policy 
enforcement and XACML
290
■ Best practices for ABAC
291
9 
Capability-based security and macaroons
294
9.1
Capability-based security
295
9.2
Capabilities and REST
297
Capabilities as URIs
299
■ Using capability URIs in the Natter 
API
303
■ HATEOAS
308
■ Capability URIs for browser-based 
CONTENTS
ix
clients
311
■ Combining capabilities with identity
314
Hardening capability URIs
315
9.3
Macaroons: Tokens with caveats
319
Contextual caveats
321
■ A macaroon token store
322
First-party caveats
325
■ Third-party caveats
328
PART 4
MICROSERVICE APIS IN KUBERNETES...............333
10 
Microservice APIs in Kubernetes
335
10.1
Microservice APIs on Kubernetes
336
10.2
Deploying Natter on Kubernetes
339
Building H2 database as a Docker container
341
■ Deploying 
the database to Kubernetes
345
■ Building the Natter API as a 
Docker container
349
■ The link-preview microservice
353
Deploying the new microservice
355
■ Calling the link-preview 
microservice
357
■ Preventing SSRF attacks
361
DNS rebinding attacks
366
10.3
Securing microservice communications
368
Securing communications with TLS
368
■ Using a service mesh 
for TLS
370
■ Locking down network connections
375
10.4
Securing incoming requests
377
11 
Securing service-to-service APIs
383
11.1
API keys and JWT bearer authentication
384
11.2
The OAuth2 client credentials grant
385
Service accounts
387
11.3
The JWT bearer grant for OAuth2
389
Client authentication
391
■ Generating the JWT
393
Service account authentication
395
11.4
Mutual TLS authentication
396
How TLS certificate authentication works
397
■ Client certificate 
authentication
399
■ Verifying client identity
402
■ Using a 
service mesh
406
■ Mutual TLS with OAuth2
409
Certificate-bound access tokens
410
11.5
Managing service credentials
415
Kubernetes secrets
415
■ Key and secret management 
services
420
■ Avoiding long-lived secrets on disk
423
Key derivation
425
CONTENTS
x
11.6
Service API calls in response to user requests
428
The phantom token pattern
429
■ OAuth2 token exchange
431
PART 5
APIS FOR THE INTERNET OF THINGS ...............437
12 
Securing IoT communications
439
12.1
Transport layer security
440
Datagram TLS
441
■ Cipher suites for constrained devices
452
12.2
Pre-shared keys
458
Implementing a PSK server
460
■ The PSK client
462
Supporting raw PSK cipher suites
463
■ PSK with forward 
secrecy
465
12.3
End-to-end security
467
COSE
468
■ Alternatives to COSE
472
■ Misuse-resistant 
authenticated encryption
475
12.4
Key distribution and management
479
One-off key provisioning
480
■ Key distribution servers
481
Ratcheting for forward secrecy
482
■ Post-compromise 
security
484
13 
Securing IoT APIs
488
13.1
Authenticating devices
489
Identifying devices
489
■ Device certificates
492
Authenticating at the transport layer
492
13.2
End-to-end authentication
496
OSCORE
499
■ Avoiding replay in REST APIs
506
13.3
OAuth2 for constrained environments
511
The device authorization grant
512
■ ACE-OAuth
517
13.4
Offline access control
518
Offline user authentication
518
■ Offline authorization
520
appendix A
Setting up Java and Maven
523
appendix B
Setting up Kubernetes
532
index
535
xi
preface
I have been a professional software developer, off and on, for about 20 years now, and
I’ve worked with a wide variety of APIs over those years. My youth was spent hacking
together adventure games in BASIC and a little Z80 machine code, with no concern
that anyone else would ever use my code, let alone need to interface with it. It wasn’t
until I joined IBM in 1999 as a pre-university employee (affectionately known as
“pooeys”) that I first encountered code that was written to be used by others. I remem-
ber a summer spent valiantly trying to integrate a C++ networking library into a testing
framework with only a terse email from the author to guide me. In those days I was
more concerned with deciphering inscrutable compiler error messages than thinking
about security.
 Over time the notion of API has changed to encompass remotely accessed inter-
faces where security is no longer so easily dismissed. Running scared from C++, I
found myself in a world of Enterprise Java Beans, with their own flavor of remote API
calls and enormous weight of interfaces and boilerplate code. I could never quite
remember what it was I was building in those days, but whatever it was must be tre-
mendously important to need all this code. Later we added a lot of XML in the form
of SOAP and XML-RPC. It didn’t help. I remember the arrival of RESTful APIs and
then JSON as a breath of fresh air: at last the API was simple enough that you could
stop and think about what you were exposing to the world. It was around this time
that I became seriously interested in security.
 In 2013, I joined ForgeRock, then a startup recently risen from the ashes of Sun
Microsystems. They were busy writing modern REST APIs for their identity and access
PREFACE
xii
management products, and I dived right in. Along the way, I got a crash course in
modern token-based authentication and authorization techniques that have trans-
formed API security in recent years and form a large part of this book. When I was
approached by Manning about writing a book, I knew immediately that API security
would be the subject.
 The outline of the book has changed many times during the course of writing it,
but I’ve stayed firm to the principle that details matter in security. You can’t achieve
security purely at an architectural level, by adding boxes labelled “authentication” or
“access control.” You must understand exactly what you are protecting and the guar-
antees those boxes can and can’t provide. On the other hand, security is not the place
to reinvent everything from scratch. In this book, I hope that I’ve successfully trodden
a middle ground: explaining why things are the way they are while also providing lots
of pointers to modern, off-the-shelf solutions to common security problems.
 A second guiding principle has been to emphasize that security techniques are
rarely one-size-fits-all. What works for a web application may be completely inappro-
priate for use in a microservices architecture. Drawing on my direct experience, I’ve
included chapters on securing APIs for web and mobile clients, for microservices in
Kubernetes environments, and APIs for the Internet of Things. Each environment
brings its own challenges and solutions.
xiii
acknowledgments
I knew writing a book would be a lot of hard work, but I didn’t know that starting it
would coincide with some of the hardest moments of my life personally, and that I
would be ending it in the midst of a global pandemic. I couldn’t have got through it
all without the unending support and love of my wife, Johanna. I’d also like to thank
our daughter, Eliza (the littlest art director), and all our friends and family.
 Next, I’d like to thank everyone at Manning who’ve helped turn this book into a
reality. I’d particularly like to thank my development editor, Toni Arritola, who has
patiently guided my teaching style, corrected my errors, and reminded me who I am
writing for. I’d also like to thank my technical editor, Josh White, for keeping me hon-
est with a lot of great feedback. A big thank you to everybody else at Manning who has
helped me along the way. Deirdre Hiam, my project editor; Katie Petito, my copyedi-
tor; Keri Hales, my proofreader; and Ivan Martinovic´, my review editor. It’s been a
pleasure working with you all.
 I’d like to thank my colleagues at ForgeRock for their support and encouragement.
I’d particularly like to thank Jamie Nelson and Jonathan Scudder for encouraging me to
work on the book, and to everyone who reviewed early drafts, in particular Simon
Moffatt, Andy Forrest, Craig McDonnell, David Luna, Jaco Jooste, and Robert Wapshott.
 Finally, I’d like to thank Jean-Philippe Aumasson, Flavien Binet, and Anthony
Vennard at Teserakt for their expert review of chapters 12 and 13, and the anonymous
reviewers of the book who provided many detailed comments.
 To all the reviewers, Aditya Kaushik, Alexander Danilov, Andres Sacco, Arnaldo
Gabriel, Ayala Meyer, Bobby Lin, Daniel Varga, David Pardo, Gilberto Taccari, Harinath
ACKNOWLEDGMENTS
xiv
Kuntamukkala, John Guthrie, Jorge Ezequiel Bo, Marc Roulleau, Michael Stringham,
Ruben Vandeginste, Ryan Pulling, Sanjeev Kumar Jaiswal (Jassi), Satej Sahu, Steve