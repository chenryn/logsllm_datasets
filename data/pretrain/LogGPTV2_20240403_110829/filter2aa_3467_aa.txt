Unboxing Android
Everything you wanted to know about Android packers
Slava Makkaveev
Avi Bashan
Who Are We?
@Avi
R&D Team Leader at Check Point, former security 
researcher at Lacoon Mobile Security. 
Experienced in OS Internal research, mobile security, linux 
kernel.
@Slava
Senior Security Researcher at Check Point, former Security 
Researcher at Verint.
Vast experience in mobile OS research and linux internals.
“Boxing” Apps
●
Malware authors use various “boxing” techniques to prevent
○
Static Code Analysis
○
Reverse Engineering
●
This can be done by proprietary techniques or 3rd party software
●
This Includes 
○
Code Obfuscation
○
Anti Debugging
○
Anti Tampering
○
Anti Dumper
○
Anti Decompiler
○
Anti Runtime Injection
Maliciousness of Packed Apps
Analyzed 13,000 Apps (July 2017)
Techniques to protect an app’s 
code
● Obfuscators
● Packers
● Protectors
Apk Protection Techniques
● Obfuscators
● Packers
● Protectors
Apk Protection Techniques
pm.getClass().getMethod("getPackageSizeInfo", String.class, 
Class.forName("android.content.pm.IPackageStatsObserver")).invoke(pm, packInfo.packageName,
    new IPackageStatsObserver.Stub() {
        public void onGetStatsCompleted(PackageStats pStats, boolean succeeded) {
        }
    });
v6.getClass().getMethod("getPackageSizeInfo", String.class, 
Class.forName("android.a.a.a")).invoke(v6, ((PackageInfo)v0_5).packageName, 
    new a() {
        public void a(PackageStats arg3, boolean arg4) {            
        }
    });
● Obfuscators
● Packers
● Protectors
Apk Protection Techniques
Original 
DEX
● Obfuscators
● Packers
● Protectors
Packer
Loader
Encrypted
DEX
APK
APK
Packing 
process
Apk Protection Techniques
Packer
Loader
Encrypted 
DEX
● Obfuscators
● Packers
● Protectors
Packer
Loader
Original
DEX
APK
APK
Execution
Apk Protection Techniques
● Obfuscators
● Packers
● Protectors
Apk Protection Techniques
● Obfuscators
● Packers
● Protectors
Original
DEX
Encrypted 
Modified
DEX
APK
APK
Protection 
Process
Protector
Loader
Apk Protection Techniques
● Obfuscators
● Packers
● Protectors
Encrypted 
Modified 
DEX
Modified
DEX
APK
APK
Execution
Protector
Loader
Protector
Loader
Apk Protection Techniques
Back to Basics!
ART - Android RunTime VM
Provided an Ahead of Time (AOT) compilation 
approach
DEX
to
OAT
●
Pre-compilation at install time
○
installation takes more time
○
more internal storage is required
●
OAT vs JIT
○
Reduces startup time of applications
○
Improves battery performance
○
Uses less RAM
DEX Loading Process
Zygote 
process
App
process
classes.dex
OAT version of 
classes.dex
fork()
dex2oat
Load app code
●
App contains minimum one DEX file
●
App can load other DEX files during execution
●
Each DEX file will be compiled in OAT file
●
Android Runtime executes OAT files
●
Android Runtime checks DEX files checksum
OAT - Ahead of Time File
OAT is ELF
●
Three special symbols in dynamic section
○
oatdata 
○
oatexec 
○
aotlastword 
●
Original DEX file is contained in the oatdata 
section
●
Compiled native instructions are contained 
in the oatexec section
Android Java Native Interface (JNI)
●
Allows calling native code directly from JVM.
●
Execution path starts from System.loadLibrary
●
Used by some of the popular packers for the packing logic.
●
Packer library is called after activity is started 
How to unpack?
Possible Approaches to Unpack an Android App
● Find the algorithm
● Extract DEX from compiled OAT
● Dump DEX from memory
● Runtime environment modification
Notable Previous Work
●
Android Hacker Protection Level 0 
○
Tim Strazzere and Jon Sawyer 
○
DEFCON 22, 2015
○
Released a set of unpacking scripts
●
The Terminator to Android Hardening Services
○
Yueqian Zhang, Xiapu Luo , Haoyang Yin
○
HITCON,  2015
○
Released DexHunter - modified version of Android Dalvik/ART VM
Our Approach
Goals
● What did want
○ Find a solution that 
■ Require minimal changes to Android
■ Will work on most of the packers
● How did we do it?
○ Reversed most popular packers
○ Patched few code rows of Android Runtime
Goals
● What did want
○ Find a solution that 
■ Require minimal changes to Android
■ Will work on most of the packers
● How did we do it?
○ Reversed most popular packers
○ Patched few code rows of Android Runtime
PROFIT
Most popular packers encountered
● Baidu
● Bangcle
● Tencent
● Ali
● 360 Jiagu
● ... (and a few more)
Analyzed Packers
Abstract Packer Model
Loader DEX
libart.so
libc.so
open
read
mmap
...
Load protected DEX
Find a class
Open DEX file
Map data
Abstract Packer Model
Loader DEX
libart.so
.so
libc.so
open
read
mmap
...
Protected DEX
Load protected DEX
Find a class
Load native part
Open DEX file
Map data
Hook calls
Decrypt DEX
Read original data
Bangcle - Classification
Classes
-
ApplicationWrapper
-
FirstApplication
-
MyClassLoader
-
ACall
Files
-
libsecse
-
libsecmain
-
libsecexe
-
libsecpreload
-
bangcle_classes (original dex)
System.load("/data/data/" + getPackageName() + "/.cache/libsecexe.so");
Acall.getACall().a1(...);
Acall.getACall().r1(...);
Acall.getACall().r2(...);
...
public class MyClassLoader extends DexClassLoader {
    ...
}
cl = new MyClassLoader("/data/data/" + getPackageName() + "/.cache/classes.jar", ...);
realApplication = cl.loadClass(v0).newInstance();
Bangcle - Java Loader Implementation
assets/libsecexe.so               →    /data/data//.cache/libsecexe.so
assets/libsecmain.so               →    /data/data//.cache/libsecmain.so
assets/libsecpreload.so
   →    /data/data//.cache/libsecpreload.so
assets/bangcle_classes.jar    →    /data/data//.cache/classes.jar
Bangcle - Native Loader Implementation
public class ACall {
    public native void a1(byte[] arg1, byte[] arg2);
    public native void at1(Application arg1, Context arg2);
    public native void at2(Application arg1, Context arg2);
    public native void c1(Object arg1, Object arg2);
    public native void c2(Object arg1, Object arg2);
    public native Object c3(Object arg1, Object arg2);
    public native void jniCheckRawDexAvailable();
    public native boolean jniGetRawDexAvailable();
    public native void r1(byte[] arg1, byte[] arg2);
    public native void r2(byte[] arg1, byte[] arg2, byte[] arg3);
    public native ClassLoader rc1(Context arg1);
    public native void s1(Object arg1, Object arg2, Object arg3);
    public native Object set1(Activity arg1, ClassLoader arg2);
    public native Object set2(Application arg1, ...);
    public native void set3(Application arg1);
    public native void set3(Object arg1, Object arg2);
    public native void set4();
    public native void set5(ContentProvider arg1);
    public native void set8();
}
Func
Offset
Func
Offset
a1
0x4638
set1
0xCFFC
at1
0x8A44
set2
0x9BC8
at2
0x9184
set3
0x566C
c1
0xF984
set3
0x8CE8
c2
0x103E8
set4
0x63B4
c3
0x12E48
set5
0x4AA0
r1
0x4938
set8
0x16828
r2
0xDE38
s1
0x126B4
jniCheckRawDexAvailable
0x4408
rc1
0xBFE4
jniGetRawDexAvailable
0x44A0
Java Interface
Native Functions
Mapping
Bangcle - libsecexe.so
Class: