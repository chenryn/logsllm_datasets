比如，LDD3中的以下所列章节：构造和运行模块，并发和竞态，时间、延迟及延缓操作,分配内存，中断处理等，都属于驱动开发的支撑性子系统，虽说本书对这些子系统都专门开辟一个章节进行讲解，但是详细程度怎么能比得上PLKA，ULK3，LKD3这三本书，看完这三本书，你会发现读LDD3这些章节的时候简直跟喝白开水一样，太随意了，因为LDD3的讲解比之LKD3更粗略。打好了基础，PCI、USB、TTY驱动，块设备驱动，网卡驱动，需要了解和学习的东西就比较有针对性了。这些子系统就属于通用子系统，了解之后，基于这些子系统的子系统的开发---驱动(需进一步针对硬件特性)和网络(需进一步理解各种协议)---相对而言，其学习难度大大降低，学习进度大大加快，学习效率大大提升。说着容易做来难。达到这样一种效果的前提就是：必须得静下心来，认真读书，要看得进去，PLKA，ULK3厚得都跟砖头块儿一样，令人望之生畏，如果没有兴趣，没有热情，没有毅力，无论如何都是不行，因为需要时间，需要很长时间。我并不是说必须打好了基础才可以进行驱动开发，只是说打好了基础的情况下进行开发会更轻松，更有效率，而且自己对内核代码的驾驭能力会更强大。这只是我个人见解，我自己的学习方式，仅供参考。
### **语言**
PLKA是个德国人用德语写的，后来翻译成英文，又从英文翻译成中文，我在网上书店里没有找到它的纸质英文版，所以就买了中文版的。ULK3和LKD3都是英文版的。大牛们写的书，遣词造句真的是简洁，易懂，看原版对我们学习计算机编程的程序员来说完全不成问题，最好原汁原味。如果一本书确实翻译地很好，我们当然可以看中文版的，用母语进行学习，理解速度和学习进度当然是很快的，不作他想。看英文的时候不要脑子里想着把他翻译成中文，没必要。
### **API感想**
“比起知道你所用技术的重要性，成为某一个特别领域的专家是不重要的。知道某一个具体API调用一点好处都没有，当你需要他的时候只要查询下就好了。”这句话源于我看到的一篇翻译过来的博客。我想强调的就是，这句话针应用型编程再合适不过，但是内核API就不完全如此。
内核相当复杂，学习起来很不容易，但是当你学习到一定程度，你会发现，如果自己打算写内核代码，到最后要关注的仍然是API接口，只不过这些API绝大部分是跨平台的，满足可移植性。内核黑客基本上已经标准化、文档化了这些接口，你所要做的只是调用而已。当然，在使用的时候，最好对可移植性这一话题在内核中的编码约定烂熟于心，这样才会写出可移植性的代码。就像应用程序一样，可以使用开发商提供的动态库API，或者使用开源API。同样是调用API，不同点在于使用内核API要比使用应用API了解的东西要多出许多。
当你了解了操作系统的实现---这些实现可都是对应用程序的基础性支撑啊---你再去写应用程序的时候，应用程序中用到的多线程，定时器，同步锁机制等等等等，使用共享库API的时候，联系到操作系统，从而把对该API的文档描述同自己所了解到的这些方面在内核中的相应支撑性实现结合起来进行考虑，这会指导你选择使用哪一个API接口，选出效率最高的实现方式。对系统编程颇有了解的话，对应用编程不无益处，甚至可以说是大有好处。 
### **设计实现的本质，知道还是理解**
操作系统是介于底层硬件和应用软件之间的接口，其各个子系统的实现很大程度上依赖于硬件特性。书上介绍这些子系统的设计和实现的时候，我们读过了，也就知道了，如果再深入考虑一下，为什么整体架构要按照这种方式组织，为什么局部函数要遵循这样的步骤处理，知其然，知其所以然，如果你知道了某个功能的实现是因为芯片就是这么设计的，CPU就是这么做的，那么你的疑问也就基本上到此为止了。再深究，就是芯片架构方面的设计与实现，对于程序员来讲，无论是系统还是应用程序员，足迹探究到这里，已经解决了很多疑问，因为我们的工作性质偏软，而这些东西实在是够硬。
比如，ULK3中讲解的中断和异常的实现，究其根源，那是因为Intel x86系列就是这么设计的，去看看Intel V3手册中相应章节介绍，都可以为ULK3中描述的代码实现方式找到注解。还有时间和定时器管理，同样可以在Intel V3 对APIC的介绍中获取足够的信息，操作系统就是依据这些硬件特性来实现软件方法定义的。
又是那句话，不是理解不理解的问题，而是知道不知道的问题。有时候，知道了，就理解了。在整个学习过程中，知道，理解，知道，理解，知道……，交叉反复。为什么开始和结尾都是知道，而理解只是中间步骤呢？世界上万事万物自有其规律，人类只是发现而已，实践是第一位的，实践就是知道的过程，实践产生经验，经验的总结就是理论，理论源于实践，理论才需要理解。我们学习内核，深入研究，搞来搞去，又回到了芯片上，芯片是物质的，芯片的功用基于自然界中物质本有的物理和电子特性。追本溯源，此之谓也。
### **动手写代码**
纸上得来终觉浅，绝知此事要躬行。只看书是绝对不行的，一定要结合课本给出的编程建议自己敲代码。刚开始就以模块形式测试好了，或者自己编译一个开发版本的内核。一台机器的话，使用UML方式调试，内核控制路走到哪一步，单步调试看看程序执行过程，比书上的讲解更直观明了。一定要动手实际操作。
### **参考书**
LDD3 Linux Device Driver 3rd
LKD3 Linux Kernel Development 3rd
ULK3 Understanding the Linux Kernel 3rd
PLKA Professional Linux Kernel Architecture  
UML User Mode Linux
Intel V3 Intel? 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B & 3C): System Programming Guide
作者在写书的时候，都是以自己的理解组织内容，从自己的观点看待一个主题，关注点跟作者自身有很大的关系。出书的时间有先后，后来人针对同一个主题想要出书而又不落入窠臼，最好有自己的切入方式，从自己的角度讲解相关问题，这才值得出这本书，千篇一律是个掉价的行为，书就不值钱了。
尽信书不如无书。
  此处是一篇关于LKD3的书评，指出了其中的错误，当你读完的时候，不妨去找找，看一下自己在其中所描述的地方有什么特别的印象。
 此处是一篇对ULK3的介绍，我认为其中很关键的几句话就可以给本书定位：
 Many of the key control paths in the kernel are described, step by step;
 一步一步地讲述内核控制路径的实现。
 The level of detail sometimes makes it hard to get a sense for the big picture, but it does help somebody trying to figure out how a particular function works.
 对代码讲解的详细程度有时候很难让读者把握住它的主旨大意，但是确实有助于读者理解一个特定的函数到底是如何工作的。
 Indeed, that is perhaps the key feature which differentiates this book. It is very much a "how it works" book, designed to help people understand the code.
 事实上，这也正是本书与众不同的地方。更像一个“如何工作”的书，帮助读者理解代码实现。
 It presents kernel functions and data structures, steps the reader through them, but does not, for example, emphasize the rules for using them. UTLK is a study guide, not a programming manual.
 本书描述了内核函数和数据结构，引导读者穿行于其间，但是，并没有着重强调使用它们的法则。UTLK是一本学习指南，而不是编程手册。 
 这几句话对本书的描述非常到位。基于此，作为指导性原则，我们就可以很有效率地使用它了。
 看一本技术书籍，书中的序言部分绝对是首先应该翻阅的，其次就是目录。我发现在阅读过程中我会频繁的查看目录，甚至是喜欢看目录。
### **结尾**
兴趣的力量是无穷的。兴趣能带来激情，如果工作可以和兴趣结合到一起，工作起来才会有热情，那么工作就不只是工作了，更是一种享受。  
Linux，我的兴趣，我的动力，我的方向，我的未来！
【转载】