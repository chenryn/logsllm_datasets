查询结果如下所示：
cs-uri-stem
HitsAvgMax
Min
**
= = = =
/Emp1oyeeSearch.asp
2-
employeesearch.aspx
276421133635135016908
/employeesearch.aspx/
193335237341321647008
/rzsqli/EmployeeSearch.aspx
1.-
为了进一步分析，可以将接收到大量字节的IP地址与那些具有恶意查询参数的查询关联
起来进行分析。
经过上面的分析，应该可以识别出应用程序中已经被攻击的Web页面和可执行文件、攻
击的时间段和源IP地址。这些信息有助于分析其他的数据库证据，有助于确认攻击企图是否
成功。接下来将介绍的第二种证据是数据库执行计划，对于确认或判伪SQL注入攻击，这是一
种非常有价值的方法。
2.数据库执行计划
数据库执行计划是由RDBMS生成的执行步骤的列表，它说明了RDBMS在访问或修改信
息时效率最高的方式。可以用下面的例子来说明什么是执行计划，比如你正在查找到达某个街
区地址的路径。可以采用多种路线到达目的地，比如走公路或走城市的街道，其中有一条路线
是最快的。在数据库中，依此类推，要检索或更新的数据就是目的地址，有效的执行线路包括
使用索引（类似于走公路）、城市街道（类似于手工扫描所有数据页以查找特定数据），或者二者
的结合。
数据库使用执行计划以确保尽可能以最有效的方式处理和执行查询。当一个查询第一次送
360
---
## Page 375
第10章确认井从SQL注入攻击中恢复
到数据库服务器时，数据库服务器将解析、分析该查询，以确定需要访问哪些表、需要使用账
些索引（如果存在索引的话），以及如何连接(join）或合并（merge）结果集等。分析的结果将存储在
某种存储结构中，这就是数据库的执行计划。在执行期间，数据库内部组件之间可以共享这些
执行计划，执行计划可以存储在内存区域中，称为执行计划缓存，当接收到另外一个类似的查
询时，可以重用缓存的执行计划。
数据库服务器根据接收到的查询语句来创建执行计划，除了以最有效的方式执行查询之外，
执行计划还包含接收到的实际查询语句。由于执行计划可以提供之前执行的SQL语句的精确
语法，包括来自SQL注入攻击的恶意查询，因此在调查可疑攻击期间，执行计划中的信息是至
关重要的。一些RDBMS产品为不同类型的SQL维护着多个缓存。但为简洁起见，我们仅关
注为即席查询（ad hoc query)以及那些来自于 SQL对象—比如存储过程、触发器和扩展过程
缓存的执行计划。
分析已执行查询的副本与分析Web服务器的日志文件有些类似，但是请记住，在Web服
务器日志中发现的SQL注入查询，只能说明有攻击的企图并被记录在日志中—这并不能说明
SQL注入攻击已经成功。在数据库服务器上，代码内的保护措施和下游安全设备一比如位于
Web服务器和数据库服务器之间的主机和网络的IPS系统一都有可能检测到井阻正攻击。因
此无法确保能将恶意代码成功送达数据库服务器并被成功处理。检查数据库的执行计划可以消
除这种猜测，观察恶意的SQL注入查询可以判断攻击是否已经通过网络，是否成功地通过应
用程序的漏洞送达数据库服务器并被处理。另外，执行计划还提供了数据库服务器接收到的实
际查询语句，包括在攻击中被攻击者终止的代码。在Web服务器和防火墙的日志中这些数据是
被忽略的。
工具与陷阱
对于调查潜在的SQL注入攻击而言，缓存信息是有益的，但是缓存诸如系统密码
之类的敏感信息会产生一定的安全风险，在调查期间收集的信息可能会包含管理员级别
的数据库账号及密码，必须机密地处理这些信息。
较高版本的MicrosoftSQLServer和OracleRDBMS平台都具有内部机制，可以在
执行计划中防止泄漏敏感的系统密码。但是低版本的RDBMS则没用这种机制。例如在
低于Microsoft SQLServer2005的版本中，对于密码这样的敏感信息，当与sp_password
和OPENROWSET命令结合使用时，常常会存储在执行计划缓存中，从而可能泄漏给
其他用户。
MySQL和PostgreSQL没有用子保护敏感信息缓存的机制，它们可以将敏感信息记
录在其他文件中，比如普通日志文件和二进制日志文件。在调查期间收集的所有信息，
都必频机密地处理。
select EmployeeID, Fname from ssfa.employee where fname= 'Isaiah'; exec
xp_cmdshe11 "net user Isaiah Chuck13s /add* -- and ComponylD = 1967
请注意，执行计划中包含了原始的SQL查询，还包含了恶意的堆叠查询语句，它脱离了数
190
---
## Page 376
SQL注入攻击与防御（第2版）
据库的范围，进入到操作系统并创建了一个新的Windows用户账号。分析执行计划有一个重要的
作用，就是数据库服务器将缓存整批语句，包括注释掉部分SQL语句以避免该部分语句被RDBMS
执行的post-terminator逻辑。如果有效的逻辑被注释掉，而无关的堆叠查询却被执行，这种情
况就是一个良好的指示，它说明发现了一次成功的SQL注入攻击。
SQL注入漏洞时，端虫常常会搜索数据库的表以寻找合适的列来保存它的有效载荷，当找到了
合适的列时，它会使用恶意代码更新该列。在幕后，执行计划将被创建，它会响应最初的螺虫
感染，也会响应螨虫在持久存储它的有效载荷时所更新的每一列。
为了说明这一间题，下面介绍一下2011年11月发现的lilupophilupop SQL注入端虫。从一
个被感染的Microsoft SQLServer的执行计划中，可以捕获最初的感染：
set ansi_warnings off DECLARE 9T VARCHAR (255) ,@C VARCHAR(255)
from INFORMATION_SCHEMA.,columns C, INFORMATION_SCHEMA.tables t
where c.DATA_TYPE in ('nvarchar′, *varchar', *ntext', *text′) and
c,CHARACTER_XAXIMUM_LENGTH>30 and t.table_name=c.table_name
t.table_type=*BASE TABLE* OPEN Table_Cursor FETCH NEXT FROM
and
Table_Cursor INTO @T,8C WHILE (e9FETCH_STATUS=O) BEGIN EXEC (*UPDATE
['+8T+'] SET ['+8C+']=*'">**">((([))
在规划如何调查SQL注入攻击时，这些信息是至关重要的，因为它们可以告诉我们螺虫
执行的精确操作。本章后面将更详细地讨论这一问题，接下来我们将介绍另外一种活动，找到
这种活动就可以表明发现了一次成功的SQL注入攻击。
在缓存的执行计划中查找证据
在本书中我们已经介绍了多种用于确认和利用SQL注入漏润的技术。所介绍的例子和工
具都是目前流行的，它们反映了攻击者使用什么样的工具来利用漏洞。接下来将介绍这些攻击
在执行计划中产生的一些常见标志。要详细地回顾SQL注入攻击的不同方法，请参考本书前
对于某种SQL注入漏洞的类型和所使用的攻击工具，如果可以成功利用漏洞，就将在执
行计划中留下一些不同的痕迹。如果你正在大海捞针式地寻找攻击证据，那么可以利用执行计
划中遗留的痕迹进行最终的判断。一个使用了堆叠查询的SQL注入攻击会产生单个执行计划，
而一个使用了推断的SQL盲注则会产生数百个执行计划，这在缓存的执行计划中非常显眼。
例如，如果将本书前面曾介绍过的 Sqlmap工具配置为使用 SQL盲注和推断，那么该工具将产
362
---
## Page 377
第10章确认井从SQL注入攻击中恢复
生超过1300条如下所示的执行计划，它将枚举Microsof SQLServer的主要特征：
VARCHAR (8000)), CHAR (32))), 171, 1)) > 99 AND *Lyatf′=*Lyatf -=
下面是在执行计划中查找证据的另外一些指导原则：
寻找已知恶意攻击活动的残痕：在数据库服务器的缓存中，SQL注入工具和应用程序漏洞
扫描器会遗留下独特的印记。对于业界流行的SQL注入工具，本书是很好的参考资源。读者
应该使用这些工具进行实验，并为SQL注入攻击的调查创建已知攻击模式的备忘录，下面是
一个用pangolin攻击工具发起的 SQL注入攻击的例子，它成功利用了一个SQL注入漏洞，脱
离了数据库的上下文，并开始枚举操作系统文件目录的结构：
select EmployeeID, FName, LName, YOB from SSFA.Employee where
[fname]= *Mikaela′; declare @z nvarchar (4000) set @z=0x43003a005c00
5c0069006e0065007400700075006200 insert pango1in_test_tab1e execute
master,.xp_dirtree 8z, 1,1--*
在前面的执行计划中，如果使用了pangolin_test_table 表名，但还无法确定是否是通过 pangolin
漏洞利用工具进行的一次成功SQL注入攻击，那么可以在执行计划的内容中寻找与pangolin残
狼相匹配的语法和结构。
工具与陷阱
请注意，攻击者可能会使用十六进制编码，努力避免攻击被检测出来，攻击者将在
Web浏览器中输入十六进制编码的攻击语法，经过编码后的攻击将通过网络传递给Web
服务器，直到数据库服务器，在数据库服务器的执行计划中，实际上将按照编码之后的
格式缓存起来，当在执行计划缓存中搜索关键字符串时，请确保既搜索了ASCII格式的
字符，也搜索了其他格式（比如十六进制编码）的字符，请注意混清格式的列表，可以参
考本书第7章7.2节“避开输入过滤器”中的内容。
pangolin使用十六进制编码的另外一个好处，就是为了努力混淆它的攻击有效载荷。将十
六进制编码转换为字符可以使攻击载荷变为人类可读的信息。在本例中，攻击者通过xp_dirtree
扩展过程查看特定的文件夹。下面是一个例子，它说明了如何使用SQLServer2008原生的
convert 命令执行转换：
select convert (nvarchar (max),
0x43003a005c005c0069006e0065007400700075006200)
执行该语句后，将返回字符串C：inetpub，这是攻击者枚举的特定目录。
与注释协同使用的堆叠查询：堆叠查询既用于合法的查询，也可以用于恶意目的。某些
RDBMS广商在过程（procedure）内支持堆叠查询，合法的数据库管理员可以使用它们。因此执
行计划中如果仅有堆叠查询的存在，并不能准确地断定这是一次成功的SQL注入攻击。在第4
章中曾经讨论过，在绝大多数程序开发语言和数据库平台中，如果对用户的输入没有进行安全
处理，那么此时构造的SQL查询可能非常危险，因为这可能会导致攻击者操纵要执行的 SQL
363
---
## Page 378
SQL注入攻击与防御（第2版）
语法，只要平台允许，攻击者可以简单地在现有SQL查询语句的基础上，堆叠出新的查询语句。
在堆叠语句时，攻击者通常还需要注释掉开发人员之前期望应用程序执行的原始逻辑。因此请
在执行计划中仔细检查包含堆叠查询的条目，此外还需要仔细检查被终止的逻辑。被终止的逻
辑可以更准确地表明这是一次成功的SQL注入攻击。比如重新检查在本章前面的例子中的执
行计划，可以看到：
select EmployeeID, Fname from ssfa.employee where fname= *Lory′; exec
.961 = ai puo --pe/ sixonuqere zesn qeu, Treqspuodx
非法使用条件语句：在第4章中曾经介绍过条件操作符的使用，比如where 1-1或a=a。
下面是一个包含一个条件操作符的执行计划，它指出这是一次成功的SQL注入攻击：
Select fname, lname, date_of_birth, corp_credit_card_num from employee
从该执行计划可以看到，对于比较操作1=1并没有任何逻辑意义，它取消了程序员通过
where子句中的条件表达式所施加的限制。
高风险语句和数据库函数：数据库厂商在RDBMS内开发了各种函数，目的是简化普通用
户的很多工作任务。近年来，黑客们已经发现了很多办法可利用函数来实现漏洞的利用。根据
使用这些高风险函数和语句的上下文，使用了这些特性的证据可以很好地指明这是一次成功的
SQL注入攻击。本书前面的各个章节中已经介绍了其中很多特性，表10-3简要地汇总了通常
与SQL注入攻击有关的高风险函数。
请注意，尽管在执行计划中可能已经发现使用了表10-3中函数的语句，但在很多情况下，
还应该查看数据库语句，并判断它们是否确实是过去某个攻击的证据。在某些情况下，还需要
标识可疑的活动，并将其报告给公司的DBA或应用程序开发人员，以判断这是否属于应用程
序中正常的功能。
表10-3高风险语句和函数
数据库
通
数
XP_CMDSHELL
XP_reg*
SP_OACREATE
poqawvo°ds
Microsoft SQL Server
OPENROWSET
sp_configure
BULK INSERT
BCP
WAITFOR DELAY
UTL_FILE
Oracle
UTL_HTTP
HTTPURITYPE
UTL_INADDR
364
---
## Page 379
第10章确认井从SQL注入攻击中恢复
（续表）
数据库
函
数
LOAD DATA INFILE
LOAD_FILE
MySQL
BENCHMARK
ENCODE0
OUTFILE0
CONCATO
PostgreSQL
Pg_ls_dir
Pg_read_file
Pg_read_binary_fle
pg_stat_file
pg_sleep
现在我们已经知道了在执行计划中查看哪些线索，下面将介绍在一些主流RDBMS中，可