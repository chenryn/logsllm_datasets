\p{Thaana}
\p(Hebrew}
\p(Thai}
\p(Hiragana}
\p(Tibetan}
\p(Inherited}
\p(Yi}
\p(Kannada)
字母表是由某种人类特定语言书写系统使用的一组代码点。一些字母表，比如Thai，
对应于单个的人类语言。其他字母表，例如Latin，则会涉及多种语言。有些语言是由
多种字母表来组成的。例如，其中并不存在一种日语Unicode字母表；事实上，Unicode
提供了日语文档中通常会使用到的Hiragana、Katakana、Han和Latin字母表。
你可能已经注意到了，在上面的列表中列在第一个的Common字母表没有按照字母顺
序排列。这种字母表包含了对于许多字母表相同的各种字符，例如标点、空白符号以
及其他各色符号。
Unicode字形
当使用到组合标志（combiningmarks）的时候，代码点与字符的区别就展现出来了。
，
写字母a”。通常来说大多数人把二者都称作字符。
U+0300是“重音组合符号”的组合标志。它只有在一个字母之后使用才有意义。一个
包含Unicode代码点U+0061U+0300的字符串会被显示为a，这同U+00E0是完全一样
正则表达式的基本技巧
49
www.TopSage.com
---
## Page 66
的。组合标志U+0300会被显示到字符U+0061的顶上。
之所以会出现两种不同方式来表示一个加重音符号的字符，是因为在许多历史上的字
符集中，把“带有重音符号的a”编码为了单个字符。Unicode的设计者认为有必要与
这些常用的遗留字符集保持一对一的映射，另外Unicode新增了把标志和基本字母分开
的表示方式，这样可以使遗留字符集无法支持的任意组合成为可能。
对于一个正则表达式用户来说，重要的是本书中介绍的所有正则流派操作的都是代码
点而不是图形化的字符。当我们说正则表达式匹配单个字符的时候，实际上的含义是
它匹配单个的代码点。如果你的目标文本中包含了两个代码点U+0061U+0300，在像
Java这样的编程语言中它可以使用字符串常量"u0061\u0300"来表示，那么一个点号只
能匹配代码点U+0061（也就是a），而不会匹配重音符号U+0300。使用正则表达式）
才可以同时匹配二者。
Perl和PCRE提供了一个特殊的正则记号X，用来匹配任意单个的Unicode字形。本质上
说，它是Unicode版本的特殊点号。它会匹配不带有组合标志的任意Unicode代码点，以及
紧跟其后的所有组合标志（如果有的话）。我们也可以使用Unicode属性来做同样的事情：
会在文本a中找到两个匹配，而不管它是如何进行编码的。如果它被
编码为"u00E0u0061u0300"，那么第一个匹配是"u00E0”，第二个匹配则是"u0061u0300"。
变体
否定变体
大写形式的是小写形式的否定变体。例如，P{Sc}>会匹配不拥有“Currency
Symbol”Unicode属性的任意字符。所有支持的流派都会支持P)，并且会支持所
有相应的属性、区块和字母表。
字符类
所有流派都允许把它们所支持的所有的和记号用在字符类之内。这
样会把代码点所表示的字符，或者是在该类别、区块或者字母表中的字符添加到字符
类中。例如，你可以用如下的正则式来匹配一个左引号（初始标点属性）、一个右引号
（终止标点属性）或商标符号（U+2122）：
[\p(Pi}\p{Pf}\x{2122}]。
正则选项：无
正则流派：.NET、Java、PCRE、Perl、Ruby1.9
列出所有字符
如果你的正则表达式流派不支持Unicode类别、区块或字母表的话，那么你可以把属于
该类别、区块或字母表的字符罗列到一个字符类中。对于区块来说，这会比较容易：
因为每个区块其实就是两个代码点之间的一个范围。例如，希腊语扩展（Greek
50第2章
www.TopSage.com
---
## Page 67
Extended）区块包括U+1F00~U+1FFF的字符：
[\u1F00-\u1FFF]
正则选项：无
正则流派：.NET、Java、JavaScript、Python
[\x{1F00}-\x{1FFF}]
正则选项：无
正则流派：PCRE、Perl、Ruby1.9
然而对于大多数类别和许多字母表来说，与之等价的字符类是单个代码点和较短范围
的一个冗长列表。构成每个类别和许多字母表的字符是散布在Unicode表中的。下面表
示的是希腊语字母表：
[\u0370-\u0373\u0375\u0376-\u0377\u037A\u037B-\u037D\u0384\u0386
\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03F5\u03F6J
\u03F7-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00\u1F15
\u1F5F-\u1F7D\u1F80-\u1FB4\ulFB6-\u1FBC\ulFBD\ulFBE\ulFBF-\u1FC1
\ulFC2-\u1FC4\u1FC6-\u1FCC\u1FCD-\u1FCF\u1FD0-\u1FD3\u1FD6-\ulFDB+
\u1FDD-\u1FDF\u1FE0-\u1FEC\ulFED-\u1FEF\u1FF2-\u1FF4\u1FF6-\ulFFC
\u1FFD-\u1FFE\u2126]
正则选项：无
正则流派：.NET、Java、JavaScript、Python
在构造这个正则表达式的过程中，我们从http://www.unicode.org/Public/UNIDATA/
Scripts.txt复制了希腊语的字母表，然后使用如下3个正则表达式进行了查找和替换。
1.查找正则表达式.*，并把它的匹配替换为空，从而可以删除所有注释。如果它
不幸删除了所有内容，那么你需要取消操作，并记住要关闭“点号匹配换行符”
的选项。
2.打开“和S匹配换行处”选项，查找个，并把它的匹配替换为《u，这样可以给所
有代码点都加上\u前缀。把L>替换为《-\u》可以得到正确的范围。
3.最后，把（s+>替换为空，以删除换行符。在字符类的前后添加括号就完成了该
正则表达式。可能还需要在字符类的开始处添加\u，或者删除最后多余的u，这
取决于当你从Scripts.txt文件中复制该列表的时候是否包括了前导空行或者后续
空行。
这看起来好像要做很多工作，但是实际上Jan只用了不到一分钟。把上面的描述写下来
则要花费多出好几倍的时间。如果要用使用x语法来表示的话，也同样很简单。
1.查找正则表达式替换为《}-x{》可以得到正确的范围。
3.最后，把s+>替换为《}》，在添加右括号的同时删除换行符。在字符类的前后添加
括号就完成了该正则表达式。可能还需要在字符类的开始处添加x{，或者删除最后
多余的u，这取决于当你从Scripts.txt文件中复制该列表的时候是否包括了前导空行
或者后续空行。
这样所得到的结果如下：
[\x{0370}-\x{0373}\x{0375}\x{0376}\x{0377}\x{037A}\x{037B}-\x{037D}
\x{0384}\x{0386}\x{0388}-\x{038A}\x{038C}\x{038E)-\x{03A1}
\x{1F50}\x{1F57}\x{1F59}\x{1F5B}\x{1F5D}\x{1F5F}-\x{1F7D}
\x{1018A)\x{1D200)  \x{1D241)\x{1D242) - \x{1D24 4 )\x{1D245}]
正则选项：无
正则流派：PCRE、Perl、Ruby1.9
参见
http://www.unicode.org是Unicode协会的官方网站，可以下载官方的Unicode文档、字
符表等内容。
Unicode是一个庞大的话题，全部内容需要由整本书来进行讲解。我们推荐由JukkaK.
Korpela所著的UnicodeExplained一书。
我们不可能在一个小节中讲解你所需要知道的关于Unicode代码点、属性、区块和字母
表的全部内容。我们甚至都还没有尝试去解释为什么你应当关心这些内容一事实上
这些都是很重要的。虽然扩展的ASCII表示用起来会比较简单，但是在如今全球化的
世界上，使用它的人早已寥寥无几了。
2.8匹配多个选择分支之一
问题描述
创建一个正则表达式，当把它重复应用到目标文本Mary，Jane，andSuewenttoMary's
house之上时，会匹配到Mary、Jane、Sue，以及又一次匹配到Mary。之后再进行的匹
配尝试都会失败。
52第2章
www.TopSage.com
---
## Page 69
解决方案
Mary|Jane I Sue
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论
竖线（verticalbar），或称作管道符号（pipesymbol），会把正则表达式拆分成多个选
择分支。（MaryJane|Sue>会在每次匹配尝试时匹配Mary，或者Jane，或者Sue。每次只
会匹配一个名字，但是每次却可以匹配不同的名字。
本书中的所有正则表达式流派都会使用一个正则制导的引擎。这个引擎也就是那个使
得正则表达式可以工作的软件。这里的正则制导的含义是，在目标文本中的每个字符
位置会首先匹配该正则表达式的所有可能排列，然后才会到下一个字符位置进行匹配
尝试。
当你把应用到Mary，Jane,andSuewent toMary'shouse的时候，在字符串
起始处立即就会找到匹配Mary。
当你把同一个正则表达式应用到余下的字符串的时候，比如说，你可以在文本编辑器
中单击“查找下一个”，正则引擎就会尝试在该字符串中的第-一个逗号处匹配。
匹配会失败。然后，它会在同一个位置尝试去匹配Jane)，这也会失败。接着在逗号处
匹配（Mary>，当然也会失败。只有在所有匹配都失败之后，正则引擎才会前进到字符串
中的下-个字符。从第一个空格并始匹配，3个选择分支都会得到同样的失败结果。
从字母J开始匹配的时候，第一个选择分支，（Mary)，会出现匹配失败。接着第二个选
择分支，也就是Jane)，会在字母J处匹配成功。它匹配的是Jane。正则引擎宣布匹配
成功。
需要注意的是：虽然在目标文本中还存在另外一个Mary，而且在正则表达式中《Mary>
出现在Jane之前，但是这里匹配到的依然是Jane。至少在这个例子中，在正则表达
式中的顺序并不重要。正则表达式会查找最左匹配。它会从左向右扫描目标文本，在
扫描的每一步中都会尝试正则表达式中的所有选择分支，而当其中任意一个选择分支
产生一个合法匹配的时候，匹配过程就会停在这个位置。
如果我们再次对字符串余下部分进行查找，那么会找到Sue。而第四次查找则会再一次
找到Mary。如果你告诉正则引擎进行第五次查找，那么就会失败，因为这三个选择分
支都无法匹配余下的字串。
另外一种引擎是文本制导（text-directed）的引擎。二者之间的关键区别是文本制导的引擎只会访问
目标文本中的每个字符一次，而正则制导的引擎则会访问每个字符多次。文本制导的引擎速度更快，
但是只对我们在第1章中开始处介绍的数学意义上的正则表达式提供支持。而使得本书趣味益然的
Perl风格的正则表达式只能使用正则制导的引擎来实现。
正则表达式的基本技巧53
www.TopSage.com
---
## Page 70
只有当在字符串中的同一个位置存在两个选择分支同时匹配的时候，正则式中的选
择分支的顺序才有意义。例如，正则式JaneJanet在匹配目标文本HernameisJanet
的时候，就会有两个选择分支在同一位置出现匹配。在正则表达式中并不存在单词
边界的概念。事实上，Jane>完全也可以只匹配到HernameisJanet中的单词Janet
的一部分。
JaneJanet之所以会匹配到HernameisJanet中的单词Janet，是因为一个正则制导的正则
表达式引擎是积极的（eager）。除了会从左向右扫描目标文本，查找最左匹配之外，
它还会从左向右扫描正则式中的选择分支。而一旦它找到一个匹配的选择分支，正则
弓擎就会立即停止。
当JaneJanet到达了HernameisJanet中的J的时候，第一个选择分支，Jane)，发生
了匹配。第二个选择分支则根本没有进行尝试。如果我们告诉引擎接着查找下一个匹
配的话，这时候在自标文本中剩下的只有t。此时两个选择分支都不会产生匹配。
要想不让Jane抢夺Janet的光环的话，可以有两种方式。第一种方式是把较长的选择分
支放在前面：（JanetJane>。另外一种更为可靠的方式是清晰地表达我们所期望的结果：
我们在查找名字，而名字应该是完整的单词。正则表达式并不会处理单词，但是它们
可以处理单词边界。
因此，\bJane\b/\bJanet\b）和。
参见
实例2.9。
2.9分组和捕获匹配中的子串
问题描述
改进匹配Mary、Jane或Sue的正则表达式，使之只能匹配整个单词。使用分组来实现
这个功能，整个正则表达式只需要一对单词分界符，而不是给每个选择分支都使用一
对分界符。
创建一个正则表达式，使之匹配任意yyyy-mm-dd格式的日期，并且分别捕获年、月和
日。目标是在处理匹配的代码中可以更容易处理这些分别捕获的值。你可以假设目标
文本中的所有日期都是合法的。正则表达式不必要考虑去掉像9999-99-99这样的非法
数据，因为它们根本不可能出现在目标文本中。
54第2章
www.TopSage.com
---
## Page 71
解决方案
\b (Mary|Jane|Sue)\b
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
\b(\d\d\d\d)-(\d\d)-(\d\d)\b
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
讨论