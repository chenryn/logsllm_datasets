Installing lab1.1a (v1.0)...
Installed lab1.1a (v1.0) successfully.
Exploring the Filesystem
Although performing a mobile application assessment using a jailbroken device is always recommended, for
various reasons this may not always be possible. On non-jailbroken devices you can still access certain portions
of the filesystem, including the sandboxed area where applications are installed; this can facilitate some basic
investigations into what, if any, persistent storage is being performed by the application. To access the
filesystem, the device must first be paired with a host computer, although this is relatively seamless to you we
briefly describe the process next.
To prevent unauthorized access to the device, iOS requires you to pair it with a desktop first. Without this
process, you could connect a locked device to your computer using the USB connection and extract sensitive
user data. This would clearly be a huge security issue and would leave personal data at risk on lost or stolen
devices. The pairing process works by creating a trust relationship between the device and the client; this is
achieved by the desktop and device exchanging a set of keys and certificates that are later used to establish and
authenticate an SSL channel through which subsequent communication is performed. Before iOS 7 the pairing
process could be instigated simply by plugging the device into a compatible device, which need not necessarily
be a desktop, but also includes things like media players. iOS 7 introduced some added security by prompting
the user to trust the plugged-in device, thereby removing the likelihood of a user unwittingly pairing to an
unknown device such as a public charging point. If the user trusts the desktop and then goes on to unlock the
device, the aforementioned key exchange is initiated and creates a pairing record. This record is then stored on
the desktop and the device. The pairing record is never deleted from the device, which means that any
previously paired devices will always have access to the device’s filesystem and if the pairing record is
compromised, the attacker will also be afforded the same level of access. The pairing record also contains an
escrow keybag, which is generated by the device and passed to the host during the first unlock. It contains a
copy of the protection class keys used by the device to encrypt data using the Data Protection API (discussed
later in this chapter). However, at a high level you should realize that the pairing record is a powerful resource
that can be used to access even encrypted files on the device. For further information on how this process
works, refer to the presentation by Mathieu Renard at http://2013.hackitoergosum.org/presentations/Day3-
04.Hacking%20apple%20accessories%20to%20pown%20iDevices%20%E2%80%93%20Wake%20up%20Neo!%20Your%20phone%20got%20pwnd%20!%20by%20Mathieu%20GoToHack%20RENARD.pdf
After the pairing completes, you will be able to mount the /dev/disk0s1s2 device, which gives you access to the
third-party resources such as applications, media, the SMS database, and other data stored under the
/private/var mount point. You can use a number of tools to mount this filesystem on non-jailbroken devices;
popular solutions include iExplorer (http://www.macroplant.com/iexplorer/) and iFunBox (http://www.i-
funbox.com/).
If you are using a jailbroken device the easiest way to get access to the whole of the device’s filesystem is to
install SSH and log in as the root user as noted earlier in this chapter. During your explorations of the
filesystem, a number of locations are likely to be of interest, some of which are listed in Table 2.1.
Table 2.1 Interesting Filesystem Locations
DIRECTORY DESCRIPTION
/Applications System applications
/var/mobile/Applications Third-party applications
/private/var/mobile/Library/Voicemail Voicemails
/private/var/mobile/Library/SMS SMS data
/private/var/mobile/Media/DCIM Photos
/private/var/mobile/Media/Videos Videos
/var/mobile/Library/AddressBook/AddressBook .sqlitedb Contacts database
During your adventures in exploring the iOS filesystem, you’re likely to encounter a number of different file
types, some of which you may be familiar with, and others that may be more alien or Apple specific.
Property Lists
Property lists are used as a form of data storage and are commonly used in the Apple ecosystem under the
.plist file extension. The format is similar to XML and can be used to store serialized objects and key value
pairs. Application preferences are often stored in the /Library/Preferences directory (relative to the
application’s data directory) as property lists using the NSDefaults class.
Property lists can be parsed using the plutil utility as shown here:
# plutil com.google.Authenticator.plist
{
OTPKeychainEntries = (
);
OTPVersionNumber = "2.1.0";
}
You can store the property list file in a binary format; however, you can convert this to XML to allow easy
editing using the following:
$ plutil -convert xml1 com.google.Authenticator.plist
To convert the file back to the binary plist format, simply use the binary1 format:
$ plutil -convert binary1 com.google.Authenticator.plist
Binary Cookies
Binary cookies can be created by the URL loading system or webview as part of an HTTP request in a similar
way to standard desktop browsers. The cookies get stored on the device’s filesystem in a cookie jar and are
found in the /Library/Cookies directory (relative to the application sandbox) in the Cookies.binarycookies file.
As the name suggests, the cookies are stored in a binary format but can be parsed using the BinaryCookieReader
.py script (http://securitylearn.net/wp-content/uploads/tools/iOS/BinaryCookieReader.py).
SQLite Databases
SQLite is widely used for client-side storage of data in mobile applications and you are almost certain to use it at
some point. SQLite allows developers to create a lightweight client-side database that can be queried using SQL,
in a similar way to other mainstream databases such as MySQL and Oracle.
You can query SQLite databases using the sqlite3 client, available in saurik’s Cydia repository:
# sqlite3 ./Databases.db
SQLite version 3.7.13
Enter ".help" for instructions
sqlite> .tables
Databases Origins
Understanding the Data Protection API
The protection of data stored on a mobile device is perhaps one of the most important issues that an application
developer has to deal with. Protecting sensitive data stored client-side in a secure manner is imperative. Apple
has recognized this requirement and to facilitate secure storage it has provided developers with an API that uses
the built-in hardware encryption. Unfortunately, finding applications (even from large multinationals) that
store their sensitive data in cleartext is still common. The Register highlighted a good example of this in 2010
when vulnerabilities in the Citigroup online banking application caused it to be pulled from the App Store:
“In a letter, the U.S. banking giant said the Citi Mobile app saved user information in a hidden file that could
be used by attackers to gain unauthorized access to online accounts. Personal information stored in the file
could include account numbers, bill payments and security access codes. . . . ”
Citigroup says its iPhone app puts customers at risk
(http://www.theregister.co.uk/2010/07/27/
citi_iphone_app_weakness/)
At a basic level, file encryption in iOS is achieved by generating a per-file encryption key. Each file encryption
key is then locked with a protection class that is assigned to it by the developer. The protection classes govern
when the class keys are kept in memory and can be used to encrypt/decrypt the file encryption keys and by
consequence, the individual files. In devices with an A7 or later chip, the key management is performed by the
Secure Enclave, maintaining the integrity of the data protection even if the kernel has been compromised. The
Data Protection system uses a Password-Based Key Derivation Function 2 (PBKDF2) algorithm to generate a
passcode key, which uses a device-specific key known as the UID key and the user’s passcode as input. The UID
key itself cannot be accessed by software on the device; instead it is embedded in the device’s hardware-based
crypto accelerator. The UID key is also used to encrypt a static byte string to generate the device key; this key is
then used to encrypt all the protection class keys along with, in some cases, the passcode key. The passcode key
is held in memory until the device is locked meaning that the keys that it encrypts are available only while the
device is unlocked. Figure 2.4 summarizes this process, courtesy of the iOS Hackers Handbook.
Figure 2.4 The data protection key hierarchy
You can assign the relevant protection class to individual files using the Data Protection API, which allows four
levels of filesystem protection. The classes are configurable by passing an extended attribute to the NSData or
NSFileManager classes. The possible levels of protection are listed here:
No Protection—The file is not encrypted on the filesystem.
Complete Protection—The file is encrypted on the filesystem and inaccessible when the device is locked.
Complete Unless Open—The file is encrypted on the filesystem and inaccessible while closed. When a
device is unlocked, an app can maintain an open handle to the file even after it is subsequently locked;
however, during this time the file will not be encrypted.
Complete Until First User Authentication—The file is encrypted on the filesystem and inaccessible
until the device is unlocked for the first time. This helps offer some protection against attacks that require a
device reboot.
As of iOS 7, files are created with the Complete Until First User unlock protection class by default. To apply one
of the levels of protection, you must pass one of the extended attributes from Table 2.2 to either the NSData or
NSFileManager class.
Table 2.2 File Protection Classes
NSDATA NSFILEMANAGER
NSDataWritingFileProtectionNone NSFileProtectionNone
NSDataWritingFileProtectionComplete NSFileProtectionComplete
NSDataWritingFileProtectionCompleteUnlessOpen NSFileProtectionCompleteUnlessOpen
NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication NSFileProtectionCompleteUntilFirstUserAuthentication
The following code shows an example of how to set the protection class attribute on a file that is downloaded
and stored in the documents directory:
-(BOOL) getFile
{
NSString *fileURL = @"https://www.mdsec.co.uk/pdfs/wahh-live.pdf";
NSURL *url = [NSURL URLWithString:fileURL];
NSData *urlData = [NSData dataWithContentsOfURL:url];
if ( urlData )
{
NSArray *paths =
NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,
NSUserDomainMask,
YES);
NSString *documentsDirectory = [paths objectAtIndex:0];
NSString *filePath = [NSString stringWithFormat:@"%@/%@",
documentsDirectory,@"wahh-live.pdf"];
NSError *error = nil;
[urlData writeToFile:filePath
options:NSDataWritingFileProtectionComplete error:&error];
return YES;
}
return NO;
}
In this example the document is accessible only while the device is unlocked. The OS provides a 10-second
window between locking the device and this file being unavailable. The following shows an attempt to access the
file while the device is locked:
$ ls -al Documents/ total 372
drwxr-xr-x 2 mobile mobile 102 Jul 20 15:24 ./
drwxr-xr-x 6 mobile mobile 204 Jul 20 15:23 ../
-rw-r--r-- 1 mobile mobile 379851 Jul 20 15:24 wahh-live.pdf
$ strings Documents/wahh-live.pdf
strings: can't open file: Documents/wahh-live.pdf
(Operation not permitted)
You apply a protection class to data stored on the device in a similar manner to the preceding example by
passing the relevant attribute that best fits the requirement for file access.
Understanding the iOS Keychain
The iOS keychain is an encrypted container used for storing sensitive data such as credentials, encryption keys,
or certificates. In a similar way to the encryption of files, you can apply a protection level to keychain items
using the Data Protection API. The following list describes the available accessibility protection classes for
keychain items:
kSecAttrAccessibleAlways—The keychain item is always accessible.
kSecAttrAccessibleWhenUnlocked—The keychain item is accessible only when the device is unlocked.
kSecAttrAccessibleAfterFirstUnlock—The keychain item is only accessible after the first unlock from boot.
This offers some protection against attacks that require a device reboot.
kSecAttrAccessibleAlwaysThisDeviceOnly—The keychain item is always accessible but cannot be migrated
to other devices.
kSecAttrAccessibleWhenUnlockedThisDeviceOnly—The keychain item is only accessible when the device is
unlocked and may not be migrated to other devices.
kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly—The keychain item is accessible after the first unlock
from boot and may not be migrated to other devices.
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly—Only allows you to store keychain items if a passcode
is set on the device. These items are accessible only when a passcode is set; if the password is later unset,
they cannot be decrypted.
You can add keychain items using the SecItemAdd or update them using the SecItemUpdate methods, which
accept one of the preceding attributes to define the protection class to apply. As of iOS 7, all keychain items are
created with a protection class of kSecAttrAccessibleWhenUnlocked by default, which allows access to the
keychain item only when the device is unlocked. If a protection class is marked as ThisDeviceOnly, the keychain
item is nonmigratable; that is, it will not be synchronized to other devices or to iTunes backups. iOS 8
introduced a new protection class, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly, that allows you to
create keychain items that are accessible only when a passcode is set and the user has authenticated to the
device. If a keychain item is stored using this protection class and the user later removes the passcode, the key
protecting these items is destroyed from the Secure Enclave, which prevents these items being decrypted again.
To prevent any application on the device from accessing the keychain items of other applications, access is
restricted by the entitlements they are granted. The keychain uses application identifiers stored in the keychain-
access-group entitlement of the provisioning profile for the application; a sample provisioning profile that
allows keychain access only to that specific application’s keychain is shown here:
keychain-access-group
$(AppIdentifierPrefix)com.mdsec.mahhapp
Sometimes applications need to share keychain items; a good example of this would be an organization with a
suite of applications that require single sign-on. This can be done by using a shared keychain group. Each of the
applications must just simply have the same value set keychain group. As previously noted, the keychain uses
application identifiers to set the access groups; these are configured by the provisioning portal on the iOS
developer center, must be unique to that organization, and typically are done using a reverse top-level domain
(TLD) format. As such, this control prevents a malicious developer attempting to create an App Store application
with another application’s keychain access group.
An application can add an item to the keychain using the SecItemAdd method; consider the following example
app that wants to store a license key in the keychain and only requires access to the item when the device is
unlocked:
- (NSMutableDictionary *)getkeychainDict:(NSString *)service {
return [NSMutableDictionary dictionaryWithObjectsAndKeys:
(id)kSecClassGenericPassword, (id)kSecClass,
service,(id)kSecAttrService, service, (id)kSecAttrAccount,
(id)kSecAttrAccessibleWhenUnlocked, (id)kSecAttrAccessible, nil];
}
- (BOOL) saveLicense:(NSString*)licenseKey {
static NSString *serviceName = @"com.mdsec.mahhapp";
NSMutableDictionary *myDict = [self getkeychainDict:serviceName];
SecItemDelete((CFDictionaryRef)myDict);
NSData *licenseData = [licenseKey dataUsingEncoding:
NSUTF8StringEncoding];
[myDict setObject:[NSKeyedArchiver archivedDataWithRootObject:
licenseData] forKey:(id)kSecValueData];
OSStatus status = SecItemAdd((CFDictionaryRef)myDict, NULL);
if (status == errSecSuccess) return YES;
return NO;
}
The application creates a dictionary of key-value pairs that are the configuration attributes for the keychain. In
this instance the application sets the kSecAttrAccessibleWhenUnlocked attribute to allow access to the keychain
item whenever the device is unlocked. The application then sets the kSecValueData attribute to the value of the
data that it wants to store in the keychain—in this instance the license key data—and adds the item to the
keychain using the SecItemAdd method.
Access Control and Authentication Policies in iOS 8
In addition to the accessibility protection classes for keychain items, Apple introduced the concept of access
control and authentication policies for iOS 8 applications. This new authentication policy controls what happens
when a keychain item is accessed. Developers can now force the user to perform authentication by passcode or
Touch ID before the keychain item can be accessed. This prompts the user with an authentication screen when
the keychain item is being accessed and by virtue should only be used for keychain items that require the device
to be unlocked, as the user interface must be accessible. The access control policy is set by a new keychain
attribute, kSecAttrAccessControl that is represented by the SecAccessControlRef object. To create the access
control policy for the keychain item, this object must be populated with the options that define the
authentication and accessibility that is required.
The authentication policy in iOS 8 defines what has to be done before the keychain item is decrypted and
returned to the application. Currently the only available authentication policy is the user presence
(kSecAccessControlUserPresence) policy, which uses the Secure Enclave to determine which type of
authentication must be done. This policy prevents access to items when no passcode is set on the device, and
requires entry of the passcode. If a device passcode is set for devices supporting Touch ID and fingerprints are
enrolled, this authentication method is preferred. If Touch ID is unavailable then a backup mechanism using
the device’s passcode is available. Table 2.3 summarizes the user presence policy.
Table 2.3 User Presence Policy
DEVICE CONFIGURATION POLICY EVALUATION BACKUP MECHANISM
Device without passcode No access No backup
Device with passcode Requires passcode entry No backup
Device with Touch ID Prefers Touch ID entry Allows passcode entry
The following code shows an example of how to add a keychain item using an access control policy. In this
example the keychain item is accessible only when the device has a passcode set and the user enters the device’s
passcode or authenticates via Touch ID:
CFErrorRef error = NULL;
SecAccessControlRef sacObject =
SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence, &error);
NSDictionary *attributes = @{
(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrService: @"MAHHService",