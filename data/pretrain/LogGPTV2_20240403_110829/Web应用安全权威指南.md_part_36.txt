        close $pipe;
        # 下面为页面显示
        print encode('UTF-8', 
        提问已受理
        EndOfHTML
    ```
    需要注意的一点为，与 `system`
    函数同样，这里也应该使用多个参数的形式来指定命令与其参数。因为如果使用
    `/usr/sbin/sendmail $mail`
    这种利用空格来区分命令和参数的形式，调用时就会经过
    Shell，从而也就会引入 OS 命令注入漏洞。
-   **不将外界输入的字符串传递给命令行参数**
    只能经过 Shell 调用 OS
    命令的函数时，或者不清楚函数的内部实现是否经过 Shell 时，防范 OS
    命令注入漏洞的根本性策略就是不将参数传递给命令行。
    下面就让我们结合具体例子来看。sendmail 命令指定了 -t
    选项后，收件人邮箱地址就不再在命令行中指定，而是变为从邮件的各个消息头
    To、Cc、Bcc
    中读取。采用这个方法，就可以不用将外界输入的字符串指定给命令行，从而也就消除了
    OS 命令注入漏洞。
    示例脚本如下。
    > **代码清单 /4b/4b-002c.php**
    ``` 代码无行号
    提问已受理
    ```
    这段脚本中通过指定 sendmail 的 -t 选项，使得收件人信息变为从 To
    消息头中读取。然后又使用了 PHP 的 `popen` 和 `fwrite`
    函数将邮件内容传给 sendmail 命令。
    然而，虽然该脚本中消除了 OS
    命令注入漏洞，但还是存在邮件头注入漏洞。解决方法请参考 4.9 节。
-   **使用安全的函数对传递给 OS 命令的参数进行转义**
    如果使用以上3个方法都无法消除 OS 命令注入漏洞，就只能经过 Shell
    来调用 OS 命令，这时就需要对传给 OS 命令的参数进行转义。然而 Shell
    的转义规则颇为复杂，所以不应该自己去手动实现，而是要使用专门用来安全转义的程序库函数。PHP
    中相应的函数为 `escapeshellarg` 。
    使用 `escapeshellarg` 对 4b-002.php 进行操作后，调用 `system`
    函数的部分就被修改如下。
    > **代码清单 /4b/4b-002d.php**
    ``` 代码无行号
    system('/usr/sbin/sendmail  -   校验参数
    >
    > -   将运行应用的权限设为所需的最低权限
    >
    > -   给 Web 服务器上的 OS 或中间件更新安全补丁
    下面就让我们来依次看一下以上各项。
    -   **校验参数**
        4.2
        节中讲过，外界的输入值应当以应用的需求为基准进行校验，而输入值校验有时也具有防范
        OS 命令注入的效果。特别是在经过 Shell 调用 OS
        命令的情况下，最好对参数字符串的字符种类加以限制。
        例如，将文件名传给 OS
        命令的参数时，如果应用需求中将文件名限定为仅包含字母或数字，那么即使应用中忘了进行转义处理，OS
        命令注入攻击也无法得逞。
    -   **将运行应用的权限设为所需的最低权限**
        遭到 OS 命令注入攻击后，由于命令执行权限即为 Web
        应用所持有的权限，因此将 Web
        应用的权限设为所需的最低权限，就能够将攻击造成的损害程度控制到最低。
        将用户权限设为所需的最低权限，对防范目录遍历漏洞也同样有效。
    -   **给 Web 服务器上的 OS 或中间件更新安全补丁**
        服务器在内部受到针对操作系统漏洞的攻击（Local Exploit）时，OS
        命令注入攻击造成的危害程度最大。通常情况下，攻击造成的损害受限于操作
        Web 服务器的用户权限，而内部攻击的情况下，一旦攻击者获取到了
        root 权限，就能够对服务器为所欲为。
        因此，即使是不会受到外部攻击的安全隐患，也最好能够为系统更新安全补丁等。详情请参考
        7.1 节。
[62]{.注释编号下} 严格来说有 pcntl_exec 函数，但该函数只能用于 CGI 版的
PHP 中。  。
#### **参考：内部调用 Shell 的函数**
作为参考，下面对各个编程语言中内部调用 Shell
的函数进行了归纳。在开发过程中，建议不要使用下面列出的这些函数，而如果不得不使用的话，则应该选择不经过
Shell 的调用方式。
**PHP**
  -------------- ------------ ---------------- ----------------- ------------- ------------------ ---------------
  \`system()\`   \`exec()\`   \`passthru()\`   \`proc_open()\`   \`popen()\`   \`shell_exec()\`   `` \`...\` ``
  -------------- ------------ ---------------- ----------------- ------------- ------------------ ---------------
**Perl**
  ------------ -------------- --------------- -------------- ------------
  \`exec()\`   \`system()\`   `` \`...\` ``   \`qx/\.../\`   \`open()\`
  ------------ -------------- --------------- -------------- ------------
**Ruby**
  ------------ -------------- ---------------
  \`exec()\`   \`system()\`   `` \`...\` ``
  ------------ -------------- ---------------
^注：Ruby\ 中也能够像\ Perl\ 一样使用管道符号启动\ Shell。例如使用\ File.open()\ 来代替\ open()，就不用担心调用\ Shell\ 的问题了。^
> **参考文献**
>
> \[1\] 佐名木智贵 .（2008）《.セキュア Web プログラミング Tips
> 集》（《Web 编程安全性技巧》）. ソフト · リサーチ · センター .
>
> \[2\] 德丸浩 .（2011 年 1 月 1 日）. PHP の escapeshellcmd
> の危険性（PHP 的 escapeshellcmd 的危险性）. 参考日期：2011 年 1 月 1
> 日，参考网址：德丸浩の日记 :
> 
## **4.12 文件上传相关的问题** {#text00000.html#nav_point_49}
有些 Web 应用能让用户上传并公开图像文件或 PDF
文档。而本节就将讲述用户上传或下载文件时容易产生的安全隐患。
### **4.12.1 文件上传问题的概要** {#text00000.html#nav_point_50}
针对文件上传功能的攻击类型有如下几种。
> -   针对上传功能的 DoS 攻击
>
> -   使上传的文件在服务器上作为脚本执行
>
> -   诱使用户下载恶意文件
>
> -   越权下载文件
下面我们就来依次看一下上述的各种攻击类型。
-   **针对上传功能的 DoS 攻击**
    使用 Web
    应用的上传功能连续发送体积巨大的文件时，就可能会形成使网站负荷过载的
    DoS 攻击（Denial of Service Attack，拒绝服务攻击）。
    ![{%}](Image00154.jpg)
    **图 4-102 针对上传功能的 DoS 攻击**
    DoS 攻击会造成应用的响应速度下降，严重时还会造成服务器宕机等。
    防范 DoS 攻击的一种有效策略为限制上传文件的容量。PHP 能够在 php.ini
    中设置上传功能的容量限制。表 4-19
    中列出了与文件上传相关的配置项。建议在满足应用需求的前提下尽量将值设置得小一些。如果应用不提供文件上传功能，那么只需将
    file_uploads 设为 Off 即可。
    详情请参考 PHP 的官方文档（
    ）。
    **表 4-19 php.ini 中与文件上传相关的配置项**
      --------------------- ---------------------------- --------
      设置项目名            解说                         默认值
      file_uploads          是否允许使用文件上传功能     On
      upload_max_filesize   单个文件的最大容量           2MB
      max_file_uploads      单次请求最大文件上传个数     20
      post_max_size         POST 请求正文的最大限制      8MB
      memory_limit          脚本所能申请到的最大内存值   128MB
      --------------------- ---------------------------- --------
    另外，设置 Apache 的 httpd.conf
    也能限制请求正文的最大字节数。而且此设置也适用于 PHP
    以外的情况。通过在前期的检验中将不合法的请求拒之门外，能够有效提高防御
    DoS 的能力。以下设置为将请求正文限制在 100K 以内 [63]{.注释编号} 。
    ``` 代码无行号
    LimitRequestBody 102400
    ```
    关于 PHP 和 Apache
    以外的工具中限制上传文件容量的设置方法，请参考相关的文档。
    > **专栏：内存使用量与 CPU 使用时间等其他需要关注的资源**
    >
    > 前面提到的内容都只是校验了上传文件的容量，而为了能够更好地防御 DoS
    > 攻击，还应该
    > 对其他参数也进行校验。例如，在服务器上处理图像文件时，比起压缩后图像文件的大小，解压后图像所占用的内存容量更容易出问题。
    >
    > 因此，为了能够正确估算解压后的内存使用量，我们就不能仅仅着眼于所接收的文件大小，还需要确定图像的尺寸及色数的上限值，并尽量在早期进行校验处理。
    >
    > 同样，在执行使 CPU 负担过重的处理时，也需要事先对 CPU 资源（CPU
    > 的使用时间和执行时间）进行估算，并限制相关的参数。
-   **使上传的文件在服务器上作为脚本执行**
    如果用户上传的文件被保存在 Web
    服务器的公开目录中，外界上传的脚本文件就有可能在 Web
    服务器上被执行。
    ![{%}](Image00155.jpg)
    **图 4-103 在服务器上执行上传的脚本**
    如果执行了外界传入的脚本，就会造成与 4.11 节讲述的 OS
    命令注入攻击同样的影响。具体表现为，信息被泄漏、文件被篡改、其他服务器遭到攻击等。详情请参考
    4.12.2 节。
-   **诱使用户下载恶意文件**
    针对文件上传功能的第 3
    种攻击方式为上传恶意文件并诱使用户下载，一旦用户浏览了该恶意文件，其
    PC 就会执行 JavaScript 脚本或者感染病毒等。
    ![{%}](Image00156.jpg)
    **图 4-104 诱使用户下载恶意文件**
    然而，这时可能会有读者产生这样的疑问，用户只是下载了文件，怎么会造成