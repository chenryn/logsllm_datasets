on the dangling pointer occurs during the free operation
(where we do not perform any extra checks with respect
to double frees), while in the general use-after-free case,
the dereference occurs in another operation. Given that
both types of vulnerabilities require dereferencing the
pointer, the double frees tested here provide the exact
same information about our mitigation as a more general
use-after-free vulnerability.
Finally, a vulnerability [9] was privately reported
by Damien Millescamps to the ClamAV team, which
would trigger a use-after-free in version 0.98.4 of the
software when scanning a maliciously crafted PE binary.
The reporter provided a proof-of-concept binary that
would trigger the vulnerability. Compiling ClamAV with
FreeSentry resulted in the program crashing trying to
access an invalid pointer as soon as the free memory
is accessed, preventing exploitation of this vulnerability.
11
VI. RELATED WORK
A typical approach to preventing use-after-free vul-
nerabilities is to use garbage collection. However this
does not deallocate memory instantaneously, but defers
this to a scheduled time interval or till memory con-
straints require it to be collected. When garbage collec-
tion is done, only memory to which no references exist
anymore is deallocated, preventing pointers from refer-
ring to deallocated memory [10]. However, C programs
will generally not clear all pointers to a memory location
when they free that location. As such, using garbage
collection without modifying the program could result in
the program using an unacceptable amount of memory. It
also requires abandoning potentially customized memory
allocators and using the garbage collector instead.
Dhurjati and Adve [11] propose a mitigation that
protects against dangling pointers by ensuring that a new
virtual page is used for every allocation of the program.
To conserve memory this new virtual page is mapped
onto the same physical page as the original allocation.
This allows the mitigation to prevent stale pointers from
using the memory, but also reduces memory overhead by
reusing the original allocation. While the approach also
has a low overhead for UNIX servers, it suffers from
a signiﬁcant slowdown when used with programs that
perform frequent memory allocations.
Cling [12] is a memory allocator that is designed
to prevent attacks against use-after-free vulnerabilities
by making them harder to exploit. The overhead for
the approach is very low, but some of the performance
improvements and slowdowns are achieved due to the
fact that a different memory allocator is used, which
makes it harder to compare overhead completely. Cling
does not eliminate the use-after-free problem entirely. It
only allows address space reuse for freed objects among
objects of the same type. However, while it constraints
exploitation vectors, it does not really solve all issues
introduced by dangling pointers if the program’s control
ﬂow makes it hard to guess the object type being allo-
cated. It also does not support protection against dangling
pointers that refer to memory on the stack.
Undangle [13] is another mitigation that prevents use-
after-free vulnerabilities. Like Cling, it does not require
source code. It works by using taint tracking to track
how pointers are copied to other pointers. When memory
is destroyed, it can then see what pointers still point
to the memory location. It can report all the dangling
pointers that point to a particular memory location at a
given set in time and allows a user to specify a window
when to report these ﬁndings, allowing it to be used as a
bug tracking tool, but which can result in false positives.
Due to the very high performance overhead, the approach
is not really practical for deployment use and relies on
execution traces to perform analysis.
CETS [8] provides a compile-time approach to protect
against dangling pointers in C. It does this by maintaining
a unique identiﬁer with each object and then associates
the identiﬁer with a pointer when the pointer is set to
point to the object. Whenever a pointer is dereferenced,
the mitigation checks if the pointer’s unique identiﬁer is
still allocated. CETS achieves a mean overhead of 48%
for the programs measured. However, due to a lack of
robustness in their prototype implementation, a number
of the more complex SPEC CPU benchmarks were not
able to compile with their approach. If we compare the 14
benchmarks that overlap between both studies, the mean
overhead for CETS for these benchmarks is around 48%,
while FreeSentry has an overhead of around 29% with
stack protection enabled and 12% with only dynamic
memory protection enabled. CETS does not have the
option of enabling only dynamic memory protection. Due
to the lack of complex benchmarks supported by CETS
it is also unclear if there would be an additional impact
on performance for the regular benchmarks when adding
support for these more complex programs.
DieHard [14] is a memory allocator that is designed
to probabilistically tolerate errors including buffer over-
ﬂows and dangling pointers. It does randomized allo-
cation within a heap of a particular size, meaning that
chunks of memory are allocated at random locations
within this memory area. To prevent use-after-free at-
tacks, it also randomizes the reuse of chunks. DieHarder
[15] extends this approach by improving randomization
which makes exploitation harder, but attackers who can
control allocations (such as an attacker using JavaScript),
could still simply allocate memory until their desired
chunk is reused. DieHarder has a comparable geometric
mean performance overhead to FreeSentry: DieHarder
has an overhead of around 30% when compared to
dlmalloc 2.7.
SAFEDISPATCH [16], VTGuard [17] and VTV [18]
are three approaches that protect against the most widely
used technique to exploit use-after-free vulnerabilities:
overwriting virtual table pointers. These types of pointers
are used in C++ objects to be able to support dynamic
dispatching, so that the virtual method to execute for
12
the desired class can be decided at run-time. These ap-
proaches focus speciﬁcally on protecting these tables and
thus their overhead is very low. However, if an attacker
does not target the virtual table pointer, but instead targets
a pointer within an object (such as the vulnerability
discussed in Section II) then these mitigations would not
be effective.
There are also a number of other approaches that com-
bine bounds checking and dangling pointer mitigation.
Safe C [19] is a bounds checker for C that also
provides protection against dangling pointers. It deﬁnes a
kind of safe pointer that contains the following attributes:
value, pointer base, size, storage class (heap,
local,
global) and capability (forever, never). The value attribute
is the actual pointer, the base and size attributes are used
for spatial check while the storage class and capability
attributes are used for temporal checks. However the
pointer representation is changed, resulting in an incom-
patibility with existing code. The added checks also have
a signiﬁcant impact on performance.
Clause et al. [20] developed a dynamic taint tool
that checks for both spatial and temporal errors for
dynamically allocated memory. It works by assigning
taint marks to objects and assigning the same taint mark
to pointers to these objects. The taint marks for pointers
are then propagated and transformed through the program
whenever an operation (such as arithmetic) on a pointer
occurs. When the pointer is dereferenced, the taint mark
for the pointer is compared to the taint mark of the
object. If the taint marks differ then a memory error
has occurred. The approach discussed by Clause at al.
works on binaries rather than source code, but requires
hardware assistance to be able to efﬁciently check and
propagate the taint marks.
Fail-safe C [21] is a compiler that
implements a
memory safe version of the ANSI C standard. It does
this using a number of techniques: fat pointers and inte-
gers (because pointers can be cast to integers and back
again) for bounds checking, keeping track of runtime
type information, garbage collection to prevent dangling
pointers, etc. The overhead of this approach is, however,
signiﬁcant. The programs in the ByteMARK benchmark
were slowed down by two to four times on average.
Xu et al. [22] track metadata that they associate with
pointers to provide checks for both spatial and temporal
errors and ﬂags the spatial or bounds errors when a
pointer is dereferenced. As with the previous approach,
the overhead is signiﬁcant, on average the benchmarks
reported in the paper were slowed down up to two times.
Safe languages are languages where it is generally not
possible for any known memory corruption vulnerability
to exist as the language constructs prevent them from
occurring. A number of safe languages are available that
will prevent these kinds of implementation vulnerabilities
entirely. There are safe languages [23], [24], [25], [26],
[27], [28] that remain as close to C or C++ as possible,
these are generally referred to as safe dialects of C. While
some safe languages [29] try to stay more compatible
with existing C programs, use of these languages may
not always be practical for existing applications due to
the effort required to transform a project to adhere to the
syntactical changes imposed by these languages.
VII. FUTURE WORK
While this approach focuses speciﬁcally on prevent-
ing and measuring the technique to provide protection
against use-after-free vulnerabilities, the approach can
be extended to include bounds checking techniques that
perform bounds checking using the available bounds
information [3] for a modest increase in performance.
While both the FreeSentry and bounds checking mitiga-
tions have non-trivial overhead, their combination should
keep the overhead relatively close to the numbers of the
worst performing technique, since processing for both
techniques occurs during pointer creation and modiﬁca-
tion and not when the pointer is accessed.
VIII. CONCLUSION
There are many widely deployed mitigations, includ-
ing stack cookies and address space layout randomiza-
tion that are present in many of the current compilers
and operating systems. However,
there are currently
no widely deployed mitigations that prevent use-after-
free vulnerabilities. This has resulted in use-after-free
vulnerability becoming the most exploited type of vulner-
abilities on Windows operating systems. In this paper, we
presented FreeSentry, a mitigation which is transparent
to an unwitting programmer allowing easy deployment
to provide protection, but also provides the ﬂexibility to
allow programmers who are aware of the mitigation to
optimize their interaction with it. This allows us to offer
a more focused protection, which allows a more com-
plicated mitigation to be applied, with a lower measured
overhead than the ones that are currently deployed. Our
performance overhead is moderate for CPU-intensive
13
programs, while for programs that have high I/O it has
no impact on performance, allowing it to be deployed
as-is for server applications that rely on heavy I/O. In
environments where security is of paramount importance,
this type of mitigation can signiﬁcantly improve security
at a modest cost.
ACKNOWLEDGEMENTS
The author would like to thank Matthew Watchinski,
Richard B. Johnson, David Sufﬂing, David A. Raynor,
Jason V. Miller, Miet Loubele, Aaron Adams and Donato
Ferrante for their insightful comments during the devel-
opment of the mitigation. The author would also like to
thank Juan Caballero for his help as shepherd for this
paper and the anonymous reviewers for their comments
and suggestions.
REFERENCES
[1] Y. Younan, W. Joosen, and F. Piessens, “Runtime countermea-
sures for code injection attacks against c and c++ programs,”
ACM Computing Surveys, vol. 44, no. 3, Jun. 2012.
[2] S. S. Nagaraju, C. Craioveanu, E. Florio, and M. Miller,
“Software vulnerability exploitation trends”,” Microsoft, Tech.
Rep., 2013.
[3] Y. Younan, P. Philippaerts, L. Cavallaro, R. Sekar, F. Piessens,
and W. Joosen, “PAriCheck: an efﬁcient pointer arithmetic
checker for C programs,” in ACM Symposium on Information,
Computer and Communications Security, April 2010.
[4] CVE-2009-0749, “Use-after-free vulnerability in the gifread-
nextextension function in lib/pngxtern/gif/gifread.c in optipng
0.6.2.”
[5] G. C. Necula, S. McPeak, S. P. Rahul, and W. Weimer, “CIL:
Intermediate language and tools for analysis and transformation
of C programs,” in Proceedings of the Conference on Compiler
Construction (CC’02), ser. Lecture Notes in Computer Science,
vol. 2304, Grenoble, France, Mar. 2002, pp. 213–228.
[6] CVE-2010-0425, “Apache mod isapi dangling pointer.”
[7] P. Akritidis, M. Costa, M. Castro, and S. Hand, “Baggy
bounds checking: An efﬁcient and backwards-compatible de-
fense against out-of-bounds errors,” in Proceedings of the 18th
USENIX Security Symposium, Montreal, QC, Aug. 2009.
[8] S. Nagarakatte, J. Zhao, M. M. K. Martin, and S. Zdancewic,
“Cets: Compiler enforced temporal safety for c,” in Proceed-
ings of the International Conference on Memory Management
(ISMM 2010), Jun. 2010.
[9] CVE-2014-9050,
“Heap-based
the
cli scanpe function in libclamav/pe.c in clamav before 0.95.4
allows remote attackers to cause a denial of service (crash)
via a crafted y0da crypter pe ﬁle.”
overﬂow in
buffer
[11] D. Dhurjati and V. Adve, “Efﬁciently detecting all dangling
pointer uses in production servers,” in Proceedings of the In-
ternational Conference on Dependable Systems and Networks.
Philadelphia, Pennsylvania,: IEEE Computer Society, 2006, pp.
269–280.
[13]
[12] P. Akritidis, “Cling: A memory allocator to mitigate dangling
pointers,” in Proceedings of the 19th USENIX Security Sympo-
sium. USENIX Association, 2010.
J. Caballero, G. Grieco, M. Marron, and A. Nappa, “Undangle:
early detection of dangling pointers in use-after-free and double
free vulnerabilities,” in Proceedings of the 2012 International
Symposium on Software Testing and Analysis. ACM Press,
2012, pp. 133–143.
[14] E. D. Berger and B. G. Zorn, “Diehard: probabilistic memory
safety for unsafe languages,” in Proceedings of the 2006 con-
ference on Programming language design and implementation.
Ottawa, ON: ACM Press, 2006, pp. 158–168.
[15] G. Novak and E. D. Berger, “Dieharder: Securing the heap,”
in Proceedings of the 17th ACM Conference on Computer and
Communications Security, 2010.
[16] D. Jang, Z. Tatlock, and S. Lerner, “SAFEDISPATCH: Se-
curing c++ virtual calls from memory corruption attacks,” in
Proceedings of the Network and Distributed System Security
Symposium (NDSS), San Diego, CA, 2014.
[17] K. Johnson and M. Miller, “Exploit mitigation in Windows 8,”
in Blackhat USA, Las Vegas, NV, 2012.
[18] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, U. Er-
lingsson, L. Lozano, and G. Pike, “Enforcing forward-edge
control-ﬂow integrity in GCC & LLVM,” in Proceedings of
the 23rd USENIX Security Symposium, San Diego, CA, 2014.
[19] T. M. Austin, S. E. Breach, and G. S. Sohi, “Efﬁcient detection
of all pointer and array access errors,” in Proceedings of the
Conference on Programming Language Design and Implemen-
tation, Orlando, FL, Jun. 1994, pp. 290–301.
J. Clause, I. Doudalis, A. Orso, and M. Prvulovic, “Effective
memory protection using dynamic tainting,” in Proceedings
of
the 22nd IEEE and ACM International Conference on
Automated Software Engineering (ASE 2007), Atlanta, GA,
Nov. 2007, pp. 284–292.
[20]
[21] Y. Oiwa, “Implementation of the memory-safe full ansi-c
compiler,” in Proceedings of the Conference on Programming
Language Design and Implementation, Dublin, Ireland, Jun.
2009, pp. 259–269.
[22] W. Xu, D. C. DuVarney, and R. Sekar, “An Efﬁcient and
Backwards-Compatible Transformation to Ensure Memory
Safety of C Programs,” in Proceedings of
the 12th ACM
SIGSOFT International Symposium on Foundations of Software
Engineering, Newport Beach, CA, October 2004, pp. 117–126.
[23] T. Jim, G. Morrisett, D. Grossman, M. Hicks, J. Cheney, and
Y. Wang, “Cyclone: A safe dialect of C,” in USENIX Annual
Technical Conference, Monterey, CA, Jun. 2002, pp. 275–288.
[24] D. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, and
J. Cheney, “Region-based memory management in Cyclone,”
in Proceedings of the Conference on Programming Language
Design and Implementation, Berlin, Germany, Jun. 2002, pp.
282–293.
[10] H. Boehm and M. Weiser, “Garbage collection in an uncooper-
ative environment,” Software, Practice and Experience, vol. 18,
no. 9, pp. 807–820, September 1988.
[25] G. Necula, S. McPeak, and W. Weimer, “CCured: Type-safe
retroﬁtting of legacy code,” in Conference Record of POPL
2002: The 29th SIGPLAN-SIGACT Symposium on Principles
14
[26]
of Programming Languages, Portland, OR, Jan. 2002, pp. 128–
139.
J. R. Larus, T. Ball, M. Das, R. DeLine, M. F¨ahndrich,
J. Pincus, S. K. Rajamani, and R. Venkatapathy, “Righting
software,” IEEE Software, vol. 21, no. 3, pp. 92–100, May
2004.
[27] D. Dhurjati, S. Kowshik, V. Adve, and C. Lattner, “Mem-
ory safety without runtime checks or garbage collection,” in
Proceedings of the 2003 Conference on Language, Compiler,
and Tool Support for Embedded Systems, San Diego, CA, Jun.
2003, pp. 69–80.
[28] S. Kowshik, D. Dhurjati, and V. Adve, “Ensuring code safety
without runtime checks for real-time control systems,” in
Proceedings of
the International Conference on Compilers
Architecture and Synthesis for Embedded Systems, Grenoble,
France, Oct. 2002, pp. 288–297.
J. Condit, M. Harren, S. McPeak, G. C. Necula, and
W. Weimer, “CCured in the real world,” in Proceedings of the
Conference on Programming Language Design and Implemen-
tation, San Diego, CA, 2003, pp. 232–244.
[29]
15