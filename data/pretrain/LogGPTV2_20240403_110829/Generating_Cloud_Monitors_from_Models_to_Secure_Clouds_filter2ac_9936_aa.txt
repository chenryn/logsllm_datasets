title:Generating Cloud Monitors from Models to Secure Clouds
author:Elena Troubitsyna and
Irum Rauf
2018 48th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
Generating Cloud Monitors from Models to Secure
Clouds
Irum Rauf
ÀöAbo Akademi University,
Turku, Finland
Email: irum.rauf@abo.Ô¨Å
Elena Troubitsyna
KTH ‚Äì Royal Institute of Technology,
Stockholm, Sweden
Email: PI:EMAIL
Abstract‚ÄîAuthorization is an important security concern in
cloud computing environments. It aims at regulating an access of
the users to system resources. A large number of resources asso-
ciated with REST APIs typical in cloud makes an implementation
of security requirements challenging and error-prone. To alleviate
this problem, in this paper we propose an implementation of
security cloud monitor. We rely on model-driven approach to
represent the functional and security requirements. Models are
then used to generate cloud monitors. The cloud monitors contain
contracts used to automatically verify the implementation. We
use Django web framework to implement cloud monitor and
OpenStack to validate our implementation.
I. INTRODUCTION
In many companies, private clouds are considered to be
an important element of data center transformations. Private
clouds are dedicated cloud environments created for the inter-
nal use by a single organization [20]. According to the Cloud
Survey 2017 [3], private clouds are adopted by 72% of the
cloud users, while the hybrid cloud adoption (both public and
private) accounts for 67%. The companies, adopting private
clouds, vary in size from 500 to more than 2000 employees.
Therefore, designing and developing secure private cloud
environments for such a large number of users constitutes a
major engineering challenge.
Usually, cloud computing services offer REST APIs (REp-
resentational State Transfer Application Programming Inter-
face) [39] to their consumers. REST APIs, e.g., AWS[1], Win-
dows Azure [11], OpenStack [37], deÔ¨Åne software interfaces
allowing for the use of their resources in various ways. The
REST architectural style exposes each piece of information
with a URI, which results in a large number of URIs that can
access the system. Data breach and loss of critical data are
among the top cloud security threats [25]. The large number of
URIs further complicates the task of the security experts, who
should ensure that each URI, providing access to their system,
is safeguarded to avoid data breaches or privilege escalation
attacks.
Since the source code of the Open Source clouds is often
developed in a collaborative manner, it is a subject of frequent
updates. The updates might introduce or remove a variety
of features and hence, violate the security properties of the
previous releases. It makes it rather unfeasible to manually
check correctness of the APIs access control implementation
and calls for enhanced monitoring mechanisms.
In this paper, we present a cloud monitoring framework that
supports a semi-automated approach to monitoring a private
cloud implementation with respect to its conformance to the
functional requirements and API access control policy. Our
work uses UML (UniÔ¨Åed Modeling Language) [38] models
with OCL (Object Constraint Language) [31] to specify the
behavioral interface with security constraints for the cloud
implementation.
The behavioral
interface of the REST API provides an
information regarding the methods that can be invoked on it
and pre- and post-conditions of the methods. In the current
practice, the pre- and post-conditions are usually given as
the textual descriptions associated with the API methods. In
our work, we rely on the Design by Contract (DbC) frame-
work [28], which allows us to deÔ¨Åne security and functional
requirements as veriÔ¨Åable contracts. Our methodology enables
creating a (stateful) wrapper that emulates the usage scenarios
and deÔ¨Ånes security-enriched behavioural contracts to mon-
itor cloud. Moreover, the proposed approach also facilitates
the requirements traceability by ensuring the propagation of
the security speciÔ¨Åcations into the code. This also allows
the security experts to observe the coverage of the security
requirements during the testing phase.
The approach is implemented as a semi-automatic code
generation tool in Django ‚Äì a Python web framework [21]
‚Äì and validated using OpenStack as a case study. OpenStack
is an open source cloud computing framework providing
IaaS (Infrastructure as a Service) [37]. The validation using
OpenStack has shown promising results and motivates us to
continue the tool development described in this paper.
The paper is organized as follows: section II motivates our
work. Section III gives an overview of our cloud monitoring
framework. In section IV, we present our design approach
to modelling stateful REST services. The contract generation
mechanism is described in section V. Section VI presents the
tool architecture and our work with monitoring OpenStack.
The related work and the conclusion are presented in sections
VII and VIII correspondingly.
II. PRIVATE CLOUDS WITH REST PRINCIPLES
Cloud computing promises to improve agility, achieve scal-
ability, and shorten time to market [27] of software devel-
2158-3927/18/$31.00 √Ç¬©2018 IEEE
DOI 10.1109/DSN.2018.00060
526
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:49:51 UTC from IEEE Xplore.  Restrictions apply. 
opment. This vision relies on the use of REST APIs, which
enable extensibility and scalability of any cloud framework.
To facilitate extensibility, REST APIs expose their function-
ality as resources with unique Uniform Resource IdentiÔ¨Åers
(URIs). In complex systems, like the cloud frameworks, this
results in a large number of URIs. Since the same set of HTTP
methods (GET, PUT, POST, DELETE) can be invoked on
them, with different authorization rules, safeguarding such a
large number of URIs is a challenging task.
For example,
let us consider a volume resource that
is
offered by the Cinder API of OpenStack [8]. Cinder is one
of the services that
is a part of the modular architecture
of OpenStack. It provides storage resources (volume) to the
end users, which can be consumed by the virtual servers
[8]. A volume is a detachable block storage device that acts
like a hard disk. Cinder API exposes the volume resource
via (/{projectid}/volumes/). Any user of the project (e.g.,
project administrator, service architect or business analyst)
with the right credentials can invoke the GET method on
volume to learn its details. However, only the project admin-
istrator and service architect can update the existing volumes
or add new volumes, and only the project administrator can
delete a volume.
To offer scalability, REST advocates the stateless interaction
between the components. This allows the REST services
to cater to a large number of clients. Without storing the
state between the requests, the server frees resources rather
quickly that ensures system scalability. However, to construct
the advanced scenarios using a stateless protocol, we should
enforce a certain sequence of steps to be followed. Hence, we
can treat such a behavior as a stateful one, where the response
to a method invocation depends on the state of the resource.
For example, a POST request from the authorized user on the
volumes resource would create a new volume resource if the
project has not exceeded its share of the allowed volumes,
otherwise it will not be created. Similarly, a DELETE request
on the volume resource by an authorized user would delete
the volume if it is not attached to any instance, otherwise it
would be ignored.
The security requirements combined with the functional
requirements specifying the conditions under which a method
can be invoked and its expected output result in a large volume
of information. Moreover, such information should be deÔ¨Åned
for each resource, which becomes overwhelming for any cloud
developer. In addition, if an API is developed in a distributed
manner, i.e., by several developers working on implementing
different parts of API, then the design errors and inconsis-
tencies become inevitable. Therefore, we should propose an
automated approach that would facilitate implementing correct
security policies for each resource of the system and assure
that the right users have an access to the right resources.
III. CLOUD MONITORING FRAMEWORK
Figure 1 presents the overall architecture of the Cloud Mon-
itoring Framework. A cloud developer uses IaaS to develop
a private cloud for her/his organization that would be used

$	%





 
"&
!"

"

 








#





!

Fig. 1. Architecture of the Cloud Monitoring Framework
by different cloud users within the organization. In some
cases, this private cloud may be implemented by a group of
developers working collaboratively on different machines. The
REST API provided by IaaS is used to develop the private
cloud according to the speciÔ¨Åcation document and required
security policy.
The cloud monitor is implemented on top of the private
cloud. The main original components of our work are high-
lighted as grey boxes in Figure 1. The security analyst develops
the required design models based on the speciÔ¨Åcation docu-
ment and security policies. These models deÔ¨Åne the behavioral
interface for the private cloud and specify its functional and
security requirements. In addition, our design models deÔ¨Åne all
the information required to build the stateful scenarios using
REST as the underlying stateless architecture [35].
In our approach, the construction of the design models
serves several purposes: 1) the models specify the system
from different viewpoints and hence, the security analysts can
choose to specify in detail only those part of the system that
they consider to be critical; 2) the models provide a graphical
representation of the expected behavior of the system with
the contracts, which can be communicated with a relative
ease compared to the textual speciÔ¨Åcations; 3) the models
serve as the speciÔ¨Åcation document and facilitate reusability;
4) they are used to generate code skeletons with the integrated
behavioral and security contracts; and Ô¨Ånally, 5) we can use
several existing model-based testing approaches to facilitate
functional and security testing of private clouds.
We build on our partial code-generation tool [34] that is ca-
pable of generating the code skeletons from the design models.
We extend this work by targeting the security requirements,
i.e., the access rights over the resources, and propose an auto-
mated approach to representating the security requirements in
the code. The generated code skeletons are then completed by
the developer with the desired implementation of the methods.
A. WorkÔ¨Çow
Our cloud monitor acts as a proxy interface on top of the
private cloud implementation. It interprets the response codes
527
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:49:51 UTC from IEEE Xplore.  Restrictions apply. 
%



!"
'	

	

	
)

 
	
(





	

&


 
#
	
	
	
'
*
