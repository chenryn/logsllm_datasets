# WebLogic CVE-2021-2135分析及POC构造遇到的问题
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、前言
早在今年4月
Weblogic发布了安全公告，里面有一个编号是CVE-2021-2135的反序列化漏洞，因为工作原因需要构造该漏洞POC，当时拿到了安全补丁，但是奈何太菜并没有解出来。后来360CERT发布了分析文章，花了一周多的时间终于把POC构造出来了。现在把分析学习及POC构造中遇到的问题记录下来。
4月与1月补丁`WebLogicFilterConfig.class`diff后如下，将`com.tangosol.internal.util.SimpleBinaryEntry`加入了黑名单。
    private static final String[] DEFAULT_BLACKLIST_CLASSES = new String[]{"oracle.jdbc.pool.OraclePooledConnection"};
    private static final String[] DEFAULT_WLS_ONLY_BLACKLIST_CLASSES = new String[]{"com.tangosol.internal.util.SimpleBinaryEntry"};
根据补丁反向推漏洞的话主要两部分命令执行载体和反序列化载体，命令执行载体达到我们执行命令的目的，反序列化载体从反序列化从入口到命令执行载体入口的动态执行，我们先分别来分析下。
## 二、命令执行载体分析：
既然我们已经知道`com.tangosol.internal.util.SimpleBinaryEntry`在黑名单里，那么我们来分析下`com.tangosol.internal.util.SimpleBinaryEntry`的特性。
###  1、SimpleBinaryEntry的特性
`SimpleBinaryEntry`实现了`SerializerAware`、`ExternalizableLite`、`PortableObject`，`ExternalizableLite`用来处理序列化相关数据。
    public class SimpleBinaryEntry 
        implements Entry, SerializerAware, ExternalizableLite, PortableObject
`SimpleBinaryEntry`有2个可序列化属性和3个不可序列化属性，其中`m_binKey`和`m_binValue`是二进制类型。
    @JsonbProperty("binKey")
    protected Binary m_binKey; //二进制key，JsonbProperty作用是把该属性的名称序列化为另外一个名称，如把m_binKey属性序列化为binKey
    @JsonbProperty("binValue")
    protected Binary m_binValue; //二进制value
    protected transient Serializer m_serializer;
    protected transient K m_key;
    protected transient V m_value;
`SimpleBinaryEntry`有参构造方法通过传参`BinaryEntry`或者key和value给属性`m_binKey`和`m_binValue`赋值：
    public SimpleBinaryEntry(Binary binKey, Binary binValue) {
        this.m_binKey = binKey;
        this.m_binValue = binValue;
    }
**`SimpleBinaryEntry`借助`m_serializer`通过`getKey`和`getValue`方法处理另外两个属性`m_key`和`m_value`。当其没有被赋值，会调用`ExternalizableHelper.fromBinary`来处理并返回结果，这时候的`m_key`和`m_value`处理后可以是指定类型的实例，而这也是漏洞的关键之处，我们可以通过构造将`m_key`或`m_value`转为我们想要的对象。**
    public K getKey() {
        K key = this.m_key;
        if (key == null) {
            // 返回的是ExternalizableHelper.fromBinary(this.m_binKey,this.m_serializer)的结果
            key = this.m_key = ExternalizableHelper.fromBinary(this.m_binKey, this.getContextSerializer());
        }
        return key;
    }
    public V getValue() {
        V value = this.m_value;
        if (value == null) {
            // 返回的是ExternalizableHelper.fromBinary的结果
            value = this.m_value = ExternalizableHelper.fromBinary(this.m_binValue, this.getContextSerializer());
        }
        return value;
    }
SimpleBinaryEntry重写了toString方法，我们可以通过该方法调用getKey。
    public String toString() {
        return "SimpleBinaryEntry(key=\"" + this.getKey() + "\", value=\"" + this.getValue() + "\")";
    }
我们来看下`ExternalizableHelper.fromBinary`。
### 2、`ExternalizableHelper.fromBinary`
`ExternalizableHelper.fromBinary`最终会调用`ExternalizableHelper.deserializeInternal`处理，`deserializeInternal`方法如下，当`nType!=21`时调用`ExternalizableHelper.readObjectInternal`读取对象。
    // serializer可以是SimpleBinaryEntry.this.m_serializer，buf可以是SimpleBinaryEntry.m_binKey或m_binValue
    private static  T deserializeInternal(Serializer serializer, ReadBuffer buf, Function supplierBufferIn, Class clazz) throws IOException {
        BufferInput in = buf.getBufferInput();
        int nType = in.readUnsignedByte();
        switch(nType) {
        ...
        ...
        if (supplierBufferIn != null) {
            in = (BufferInput)supplierBufferIn.apply(in);
        }
        // nType!=21，调用ExternalizableHelper.readObjectInternal
        Object o = nType == 21 ? serializer.deserialize(in, clazz) : readObjectInternal(in, nType, ((ClassLoaderAware)serializer).getContextClassLoader());
        return realize(o, serializer);
    }
`ExternalizableHelper.readObjectInternal`会按照`nType`的值进行处理，根据`ExternalizableHelper.writeObjectnType`，在序列化时通过`getStreamFormat`进行赋值。
    // getStreamFormat:o instanceof ExternalizableLite ? 10，当对象是ExternalizableLite实例，nType=10
    public static int getStreamFormat(Object o) {
        return o == null ? 0 : (o instanceof String ? 6 : (o instanceof Number ? (o instanceof Integer ? 1 : (o instanceof Long ? 2 : (o instanceof Double ? 3 : (o instanceof BigInteger ? 4 : (o instanceof BigDecimal ? 5 : (o instanceof Float ? 14 : (o instanceof Short ? 15 : (o instanceof Byte ? 16 : 11)))))))) : (o instanceof byte[] ? 8 : (o instanceof ReadBuffer ? 7 : (o instanceof XmlBean ? 12 : (o instanceof ExternalizableHelper.IntDecoratedObject ? 13 : (o instanceof ExternalizableLite ? 10 : (o instanceof Boolean ? 17 : (o instanceof Serializable ? 11 : (o instanceof Optional ? 22 : (o instanceof OptionalInt ? 23 : (o instanceof OptionalLong ? 24 : (o instanceof OptionalDouble ? 25 : (o instanceof XmlSerializable ? 9 : 255))))))))))))));
    }
`ExternalizableHelper.readObjectInternal`代码如下，根据
**序列化数据的类型`nType`**进行反序列化读取对象，当nType=10，调用readExternalizableLite。
    private static Object readObjectInternal(DataInput in, int nType, ClassLoader loader) throws IOException {
        switch(nType) {
        case 0:
            return null;
        case 1:
            return readInt(in);
        case 2:
            return readLong(in);
        ......
        case 7:
            Binary bin = new Binary(); //调用Binary.readExternal反序列化读取
            bin.readExternal(in);
            return bin;
        ......
        case 10:
            return readExternalizableLite(in, loader); // 当nType=10，调用readExternalizableLite
        case 11:
            return readSerializable(in, loader);
        ......
        case 255:
            return readSerializable(in, loader);
        default:
            throw new StreamCorruptedException("invalid type: " + nType);
        }
    }
在`ExternalizableHelper.readExternalizableLite`中，会实例化类为value，并且会调用value所属类的readExternal方法来读取最终的对象。
    public static ExternalizableLite readExternalizableLite(DataInput in, ClassLoader loader) throws IOException {
        ExternalizableLite value;
        if (in instanceof PofInputStream) {
            value = (ExternalizableLite)((PofInputStream)in).readObject();
        } else {
            String sClass = readUTF((DataInput)in); // 获取类名
            WrapperDataInputStream inWrapper = in instanceof WrapperDataInputStream ? (WrapperDataInputStream)in : null;
            try {
                // 加载并实例化序列化时写入的类名
                value = (ExternalizableLite)loadClass(sClass, loader, inWrapper == null ? null : inWrapper.getClassLoader()).newInstance();
                ......
            // 调用value的readExternal方法读取对象
            value.readExternal((DataInput)in);
            // !!注意这里 当value是SerializerAware的实例，会设置它的Serializer
            if (value instanceof SerializerAware) {
                ((SerializerAware)value).setContextSerializer(ensureSerializer(loader));
            }
        }
        return value;
    }
看到这里我们已经明白了`SimpleBinaryEntry`本质是Entry，有键值对，它的key即`m_key`属性、value即`m_value`属性，可以通过`getKey`和`getValue`设置，而`getKey`通过`ExternalizableHelper.fromBinary`来处理，`ExternalizableHelper.fromBinary`会根据`m_binKey`的数据类型的不同调用不同的反序列化方法进行读取，那么我们可以构造`m_binKey`达到我们命令执行的目的。
那么到这里我们怎么执行命令？参考之前的漏洞[CVE-2020-14756](https://xz.aliyun.com/t/9550)，可以考虑通过`com.tangosol.coherence.rest.util.extractor.MvelExtractor#extrace`执行命令。
    ExternalizableHelper.readExternalizableLite()
            TopNAggregator.PartialResult.readExternal()
               TopNAggregator.PartialResult.add()
                 (AbstractExtractor)MvelExtractor.compare()
                   MvelExtractor.extract()
                     MVEL.executeExpression()
###  3、TopNAggregator.PartialResult.readExternal()到命令执行
`TopNAggregator$PartialResult`实现了`ExternalizableLite`，其重写了`readExternal()`，我们可以通过`ExternalizableHelper.readExternalizableLite()`调用`TopNAggregator$PartialResult.readExternal`。
`TopNAggregator$PartialResult.readExternal`主要读取和恢复`m_comparator`、`m_cMaxSize`、`m_map`属性的数据，其中调用了`Comparator.readObject`给属性`m_comparator`赋值，`comparator`
可控为
`MvelExtractor`，`m_map`是用`m_comparator`构造的`TreeMap`实例，并且通过`TopNAggregator$PartialResult.add`添加map的键值对。`TopNAggregator$PartialResult.add`会调用父类的add方法，最终通过map.put添加数据。
    public void readExternal(DataInput in) throws IOException {
        // 这里会调用Comparator.readObject给this.m_comparator赋值
        this.m_comparator = (Comparator)ExternalizableHelper.readObject(in);
        this.m_cMaxSize = ExternalizableHelper.readInt(in);
        //调用SortedBag.instantiateInternalMap
        this.m_map = this.instantiateInternalMap(this.m_comparator);
        int cElems = in.readInt();
        for(int i = 0; i < cElems; ++i) {
            // 调用add
            this.add(ExternalizableHelper.readObject(in));
        }
        this.m_comparator_copy = this.m_comparator;
    }
    public boolean add(E o) {
        NavigableMap map = this.getInternalMap();
        while(!Base.equals(o, this.unwrap(map.ceilingKey(o)))) {