Information Security, 5(2):100â€“110, 2011.
[31] D. P. Martin, E. Oswald, M. Stam, and M. WÂ´ojcik. A leakage
resilient mac. In IMACC 2015, pages 295â€“310, 2015.
[32] M. Medwed, F. Standaert, J. GroÃŸschÂ¨adl, and F. Regazzoni. Fresh
re-keying: Security against side-channel and fault attacks for low-
cost devices. In AFRICACRYPT, pages 279â€“296, 2010.
[33] S. Micali and L. Reyzin. Physically observable cryptography
(extended abstract). In TCC, pages 278â€“296, 2004.
[34] C. Namprempre, P. Rogaway, and T. Shrimpton. Reconsidering
generic composition. In EUROCRYPT, pages 257â€“274, 2014.
[35] NIST. FIPS PUB 186-4 Digital Signature Standard (DSS). http:
//nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf, 2013.
[36] K. G. Paterson and N. J. AlFardan. Plaintext-recovery attacks
against datagram TLS. In NDSS, 2012.
[37] O. Pereira, F. Standaert, and S. Vivek. Leakage-resilient authen-
tication and encryption from symmetric cryptographic primitives.
In ACM CCS, pages 96â€“108, 2015.
[38] K. Pietrzak. A leakage-resilient mode of operation. In EURO-
CRYPT, pages 462â€“482, 2009.
[39] E. Rescorla. The transport layer security (tls) protocol version
1.3. https://tlswg.github.io/tls13-spec/draft-ietf-tls-tls13.html,
July 2017.
[40] M. Rivain and E. Prouff. Provably secure higher-order masking
of AES. In CHES, pages 413â€“427, 2010.
[41] P. Rogaway and T. Shrimpton. Deterministic authenticated-
encryption: A provable-security treatment of the key-wrap prob-
lem. IACR Cryptology ePrint Archive, 2006:221, 2006.
[42] P. Rogaway and T. Shrimpton. A provable-security treatment of
the key-wrap problem. In EUROCRYPT, pages 373â€“390, 2006.
[43] F. Standaert, O. Pereira, and Y. Yu. Leakage-resilient symmet-
ric cryptography under empirically verifiable assumptions. In
CRYPTO, pages 335â€“352, 2013.
[44] N. Veyrat-Charvillon, B. GÂ´erard, and F. Standaert. Soft analytical
side-channel attacks. In ASIACRYPT, pages 282â€“296, 2014.
[45] N. Veyrat-Charvillon, M. Medwed, S. Kerckhof, and F. Standaert.
Shuffling against side-channel attacks: A comprehensive study
with cautionary note. In ASIACRYPT, pages 740â€“757, 2012.
Conferenceâ€™17, July 2017, Washington, DC, USA
[46] Y. Yu and F. Standaert. Practical leakage-resilient pseudorandom
objects with minimum public randomness. In CT-RSA, pages
223â€“238, 2013.
[47] Y. Yu, F. Standaert, O. Pereira, and M. Yung. Practical leakage-
resilient pseudorandom generators. In ACM CCS, pages 141â€“151,
2010.
A PROOF OF THEOREM 5.3
Let ğ’œ be a (ğ‘, ğ‘¡)-CIML adversary against DTE making ğ‘ğ‘’ +
ğ‘ğ‘‘ â‰¤ ğ‘ queries, where ğ‘ğ‘’ is the number of encryption queries
and ğ‘ğ‘‘ the number of decryption queries. We say that the
final output ciphertext (ğœâ€ , ğ‘â€ ) is the (ğ‘ + 1)-th query of the
game. Without loss of generality we assume that any answer
to some encryption query is never sent as a decryption query
and conversely. We also assume that the final output is not
an answer to some encryption query, otherwise the adversary
loses anyway.
Since we are in the same condition as in the proof of
misuse resistant, we name by Â¯ğ¸ğ‘– the event where the winning
condition of CIML is satisfied which can be viewed as the
analogue of ğ¸ğ‘– with an additional decryption query: the
(ğ‘ + 1)-th query which is the last of the game. We thus
have to focus on proving that the (ğ‘ + 1)-th query is also
invalid even when all the ephemeral key ğ‘˜0â€™s associated to
the encryption queries only are given in ğ¸ğ‘–.
Letâ€™s see what happens in ğ¸1 where F* was replaced by
a random function f if f(ğœ ) = ğ‘˜0 was given to the adversary,
where ğœ = f(H(ğ‘Ÿâ€–ğ‘š)) for the encryption query (ğ‘Ÿ, ğ‘š). Ob-
viously, ğ‘˜0 gives nothing more since in ğ¸1 the encryption
algorithm from ğ‘˜0 is run honestly as in ğ¸0. We then get an
adversary against F* in Â¯ğ¸1 making at most 2(ğ‘ + 1) queries
since we must count the (ğ‘ + 1)-th query and running in time
bounded by ğ‘¡ + (ğ‘ + 1)(ğ‘¡H + (2â„“ + 1)ğ‘¡F) â‰¤ ğ‘¡â€². Nevertheless, we
assume F* to be (2ğ‘ + 2, ğ‘¡â€², ğœ€F* )-pseudorandom and we find
| Pr[ Â¯ğ¸0] âˆ’ Pr[ Â¯ğ¸1]| â‰¤ ğœ€F* .
Likewise with ğ¸1, we consider the partition Â¯ğ¸1 âˆ© ( Â¯ğ¹1 âˆª Â¯ğ¹2)
and Â¯ğ¸1 âˆ© Â¯ğ¹3, where Â¯ğ¹1 is the analogue of ğ¹1 meaning that
collision on associated digests occurs, where Â¯ğ¹2 is an extended
version of ğ¹2 where some associated digest H(ğ‘Ÿ, ğ‘š) = â„ is
equal to some associated ğœâ€² or to some associated ğ‘˜â€²â€²
0 (which
simply has the form f(ğœâ€²â€²) for some associated ğœâ€²â€²), and where
Â¯ğ¹3 is the complement of Â¯ğ¹1 âˆª Â¯ğ¹2. We stress that the fact that
the ğ‘˜0â€™s associated to encryption queries leak does not affect
the emulations made in ğ¹1, ğ¹2 and ğ¹3 since we remain in the
same game. It is now straightforwards that Pr[ Â¯ğ¹1] â‰¤ ğœ€ğ‘ğ‘Ÿ since
we get an adversary against the (0, ğ‘¡â€², ğœ€ğ‘ğ‘Ÿ)-collision resistance
of H running in the time bounded by ğ‘¡â€². Moreover, since in
ğ¹ â€²
2 we already put targets of the range-oriented preimage
resistance of H in place of all the associated tags and the
associated ephemeral key ğ‘˜0â€™s we also have an adversary here
(built from ğ’œ), for Â¯ğ¹2, asking/receiving at most (2ğ‘ + 2)
targets and running in time bounded by ğ‘¡â€². By assumption
on H, we must have Pr[ Â¯ğ¹2] â‰¤ ğœ€ğ‘ğ‘Ÿ and we are thus left with
bounding Pr[ Â¯ğ¸1| Â¯ğ¹3].
We are ready for the last transition from Â¯ğ¸1| Â¯ğ¹3 to Â¯ğ¸2 where
we reach the game where all the decryption queries including
the (ğ‘ + 1)-th one are answered by âŠ¥. It is straightforward to
Francesco Berti, FranÂ¸cois Koeune, Olivier Pereira,
Thomas Peters, FranÂ¸cois-Xavier Standaert.
show that | Pr[ Â¯ğ¸1| Â¯ğ¹3]âˆ’ Pr[ Â¯ğ¸2]| â‰¤ (ğ‘ + 1)/2ğ‘›, which concludes
(cid:3)
the proof.
B PROOF OF THEOREM 6.1
Let ğ’œ be a (ğ‘, ğ‘¡)-CIML adversary against DCE making ğ‘ğ‘’ +
ğ‘ğ‘‘ â‰¤ ğ‘ queries, where ğ‘ğ‘’ is the number of encryption queries
and ğ‘ğ‘‘ the number of decryption queries. We have to bound
the probability Pr[CIMLDCE,ğ’œ = 1]. Without loss of generality
we assume that any answer to some encryption query is never
sent as a decryption query and conversely. We also assume
that the final output is not an answer to some encryption
query, otherwise the adversary looses anyway.
The proof is in the spirit of the proof of Theorem 5.3 except
that ğ’œ cannot compute H itself: it must query the random
oracle to get h. However, since h is random here, the distribu-
ğ‘˜(H(ğ‘Ÿâ€–ğ‘š)) in DCE is similar to the distribution of
tion of F*
ğ‘˜ âˆ˜ F*
ğ‘˜(H(ğ‘Ÿâ€–ğ‘š)) in DTE by relying on the pseudorandomness
F*
of F*. Then, all the ephemeral keys ğ‘˜0 associated to encryp-
tion queries are random (See the proof of Theorem 5.3).
Let us assume that the final output ciphertext (ğœâ€ , ğ‘â€ ) is the
(ğ‘+1)-th query of the game. Then we only need to replace ğ‘+1
outputs of F*
ğ‘˜ by random values (instead of computing ğ‘˜0â€™s).
By reusing the argument detailed in the proof of Theorem 5.3,
we obtain that the (ğ‘ + 1, ğ‘¡â€², ğœ€F* )-pseudorandomness of F*
is sufficient to bound the gap resulting from this transition
by ğœ€F* : we can easily build an adversary running in time
ğ‘¡ + (ğ‘ + 1)(2â„“ + 1)ğ‘¡F â‰¤ ğ‘¡â€², since all the hâ€™s are already random.
The probability that some collision occurs among all the hâ€™s
and the ğ‘˜0â€™s is bounded by 4(ğ‘ + 1)2/2ğ‘›. Therefore, assuming
that no collision happens, if a decryption query (h, ğ‘) is valid it
must be the case that H(ğ‘Ÿâ€–ğ‘š) returned by the random oracle
where ğ‘Ÿ and ğ‘š are computed during decryption matches h
which has a probability bounded by 1/2ğ‘› for each query. Thus
all the ciphertexts of the encryption queries including the
(ğ‘ + 1)-th one are invalid except with probability (ğ‘ + 1)/2ğ‘›.
(cid:3)
ğ’œL,DCE game.
C PROOF OF THEOREM 7.5
We start by defining Game 0 as the PrivKlmcpa,0
Game 1 is equal to Game 0, except that we abort if, when
processing the queries of ğ’œL, the same randomness ğ‘Ÿ is picked
ğ‘’ /|â„›|.
twice. The probability of this event is bounded by ğ‘2
Game 2 is equal to Game 1, except that we abort if, when
processing the queries of ğ’œL, a collision happens on the hash
function, that is, it the adversary provides messages ğ‘š and
ğ‘šâ€² such that, when performing their encryption, it happens
that H(ğ‘Ÿ|ğ‘š) = H(ğ‘Ÿâ€²|ğ‘šâ€²) (note that ğ‘Ÿ Ì¸= ğ‘Ÿâ€², because of the
failure condition of Game 1). The gap between Game 2 and
Game 1 is bounded by ğœ–cr: a collision resistance adversary
can run ğ’œL and its LMCPA challenger (in time ğ‘¡ğ‘, and using
ğ‘ğ‘’ + 1 leakage queries), and search for a collision (in time ğ‘¡ğ‘ ğ‘),
placing us within the bounds of the hash function security.
Game 3 is equal to Game 2 except that, for all queries, the
challenger replaces the computation of the key ğ‘˜0 = Fğ‘˜(h)
$â† â„¬ (we assume that
with the selection of a random key ğ‘˜0
this does not increase its running time). Since the previous
Ciphertext Integrity with Misuse and Leakage
Conferenceâ€™17, July 2017, Washington, DC, USA
evaluation of the hash function that result from answering
the adversaryâ€™s queries in the LMCPA game (in Game 2). (cid:3)
D PROOF OF THEOREM 7.6
We only detail the steps that differ from the proof of Thm. 7.5.
We split Game 3 into two steps, in order to be able to
replace the tag ğœ and key ğ‘˜0 values with random values.
In the first step, we replace Fğ‘˜ with a random function ğ‘“ ,
bringing an ğœ–F gap as before. In the second step, we replace
the evaluation of ğ‘“ by the selection of random values, which
is only equivalent if ğ‘“ is never queried on the same value
twice. This is actually the case, except with probability less
than 4(ğ‘ğ‘’ + 1)2/|â„¬|. Indeed: a collision between two hashes is
precluded by Games 1 and 2; a collision between two ğœ values
can only happen with probability bounded by (ğ‘ğ‘’ + 1)2/|â„¬|
(this upper-bounds the probability of a collision in the range
of ğ‘“ invoked on distinct values); and a collision between a
hash and a ğœ value is also bounded by by (ğ‘ğ‘’ +1)2/|â„¬| (the ğœ â€™s
a selected at random by ğ‘“ , and each of them will collide with
one of the ğ‘ğ‘’ + 1 distinct hashes with probability (ğ‘ğ‘’ + 1)/â„¬.
In a similar way, we add a step in Game 7, in order to
revert the transform above, bringing a second 2(ğ‘ğ‘’ + 1)2/|â„¬|
(cid:3)
gap.
failure conditions guarantee that h is always fresh, the gap
between Game 3 from Game 2 is bounded by ğœ–F: a PRF
adversary can run ğ’œL and its LMCPA challenger (within
(ğ‘ğ‘’ + 1, ğ‘¡ğ‘) bounds), except that it queries the PRF challenger
with all the h values that it computes.
Game 4 is equal to Game 3 except that, during the test
query of the LMCPA game, the computation of ğ»(ğ‘Ÿâ€–ğ‘š0)
(and the corresponding leakage) is replaced by the computa-
tion of H(ğ‘Ÿâ€–ğ‘š1). Here the probability of distinguishing Game
4 from Game 3 is bounded by ğœ–LH: an adversary against the
leakage resilience of H can run ğ’œL and its LMCPA challenger
(as tweaked in Game 3, and within (ğ‘ğ‘’ +1, ğ‘¡ğ‘) bounds), except
that it hands the computation of h to the leakage resilient
hash function challenger during the test query.
Game 5 is equal to Game 4 except that, during the test
query of the LMCPA game, the selection of a random ğ‘˜0
(from Game 3) is replaced by the selection of a random h*
and the computation of ğ‘˜0 = Fğ‘˜(h*). The gap between Game
5 from Game 4 is bounded by ğœ–F: a PRF adversary can run
ğ’œL and its LMCPA challenger (within (ğ‘ğ‘’ + 1, ğ‘¡ğ‘) bounds),
except that it queries the PRF challenger with the h* value
that it computes.
To sum up, at this stage, ğ’œL sees:
âˆ™ During an encryption query: the expected hash and
leakage, and an encryption component encrypting that
hash and leakage, but with a randomly chosen ğ‘˜0 (hence
independent of the long-term key ğ‘˜).
âˆ™ During the test query: the hash and leakage of (ğ‘Ÿâ€–ğ‘š1),
followed by a PSV encryption of (ğ‘Ÿâ€–ğ‘š0) with key ğ‘˜.
The presence of this isolated PSV encryption makes it possible
to use the leakage resilient eavesdropper security of that
scheme.
Game 6 is equal to Game 5 except that, during the test
query of the LMCPA game, we encrypt (ğ‘Ÿâ€–ğ‘š1) instead of
(ğ‘Ÿâ€–ğ‘š0). The gap between Game 6 and Game 5 is bounded
by ğœ–eav
PSVâˆ’ENC, since we can build an EAV adversary running
ğ’œL and the LMCPA challenger (within (ğ‘ğ‘’ + 1, ğ‘¡ğ‘) bounds),
except that it hands the two messages (ğ‘Ÿâ€–ğ‘š0) and (ğ‘Ÿâ€–ğ‘š1) to
the leavchallenger and returns the corresponding ciphertext
to ğ’œL.
Game 7 now hops to the PrivKlmcpa,1
Game 4-5 transform.
ğ’œL,DCE game by undoing
most of the hops that we made before, introducing the same
gaps again, but keeping ğ‘š1 in place:
âˆ™ We go back to a uniformly random ğ‘˜0 by undoing the
âˆ™ We go back to the selection of random ğ‘˜0â€™s everywhere
âˆ™ We stop aborting if the same randomness ğ‘Ÿ is picked
twice or if a collision happens in the hash function, as
in the Game 0-2 transforms.
to the use of a PRF as in the Game 2-3 transform.
To sum-up we observe that the total gap introduced by
our sequence of games is bounded by 2 ğ‘ğ‘’|â„›| + 2ğœ–ğ‘ğ‘Ÿ + 4ğœ–F +
ğœ–LH + ğœ–eav
PSVâˆ’ENC. Besides, none of our reductions requires more
leakage function queries than those needed to run the LMCPA
challenger, and time more than the one needed to run that
challenger and look for a collision in the outputs of the