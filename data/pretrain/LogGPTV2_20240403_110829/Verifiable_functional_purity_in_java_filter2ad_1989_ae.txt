verify that the voted ballot and behavior of the voting machine are
a deterministic function of the sequence of input events.
Functionally pure sequences also occur in Waterken’s implemen-
tation of deterministic server processes that react to input events.
Each event causes mutations in the internal state of a handler ob-
ject dedicated to that event’s connection. Because these mutations
are local to the per-connection object, the behavior of each server
process is a deterministic function of the sequence of input events
it receives, even though each individual call to the event-processing
method is not veriﬁably pure.
9. RELATED WORK
Object-capability languages have a long history [18]. Most of
these languages are more functional in style than the Joe-E subset
of Java, making it easier to limit side effects. In the E language,
the Functional auditor examines an object to check that “every
method on the object has no side effects and produces an immutable
result depending solely on its arguments” [28]. The auditor veriﬁes
this property using runtime introspection on an object; in contrast,
we verify it statically for individual methods.
In this paper, we
build upon Joe-E [16], another object-capability language designed
by some of the authors of this paper in related work, but we expect
that many of our techniques could be applied to many other object-
capability languages as well.
We were inspired by the notion of “environment-freeness” [24],
which is essentially the determinism portion of our notion of purity.
Environment-freeness was used to verify determinism of a decod-
ing operation and for fail-stop enforcement of the inverse property.
Most previous work on purity in imperative languages has fo-
cused on side-effect freeness and paid little attention to determin-
ism. The deﬁnition of side-effect free used has generally been
weaker than ours, as it has included only objects in memory and
has excluded state external to the program. For legacy code, Roun-
tev [21] and Salcianu and Rinard [23] provide pointer-based anal-
yses that recognize side-effect free methods. Both address only
in-language side effects; neither mentions any special treatment for
native methods, which can cause external side effects. Analysis-
based approaches have the advantage of being directly applicable
to legacy code. Language-based approaches, on the other hand,
provide more guidance for programmers in writing side-effect free
methods.
In Joe-E, we make use of class immutability both in enforcement
of determinism and for side-effect freeness. Speciﬁc classes in the
standard Java type system are considered immutable; standard Java
type safety and ﬁnal ﬁeld enforcement ensures that objects of such
classes are never mutated after construction. An alternative is to use
an extended type system that treats some references or instances as
read-only while allowing others to be mutated. The C++ const
qualiﬁer for pointers is the most well-known example of this. It is
a compilation error to assign the ﬁelds of, or invoke a non-const
method on, a const reference. Its use in preventing side effects is
limited because the restrictions are not transitive; it is possible to
modify an object contained in a ﬁeld reached via a const pointer.
A transitive analogue of this was introduced by the KeyKOS oper-
ating system [10] as a “sensory key”; such a key prohibits writes
and also causes all keys retrieved through it to be sensory. This
concept is also found in the type system of a few programming lan-
guages to improve reasoning about immutability and side effects.
Such types allow for documentation and modular checking of effect
restrictions on a per-function basis.
Ieurusalimschy and Rodriguez [12] use such a qualiﬁed type to
enforce side-effect freeness in the SmallTalk-like language School.
Methods annotated to be side-effect free are type-checked with all
arguments and the instance pointer implicitly marked with an old
qualiﬁer. This qualiﬁer prevents writes to the ﬁelds of old ob-
jects. The type checker only allows invocations of side-effect free
methods on old objects, and treats the return values from all such
invocations as old. This ensures that the only non-old (and thus
mutable) objects that can be used by the method are ones it cre-
ates itself. The paper makes no mention of rules for dealing with
mutable objects in the global scope or external side effects; their
emphasis on soundness would suggest that School has neither. The
Javari [26] type system provides similar qualiﬁers for Java, but in-
stead of having a side-effect free annotation, Javari uses explicit
readonly qualiﬁers as a transitive, sound version of C++’s const.
Like C++, Javari provides a way for ﬁelds of a class to be declared
as exempt from the readonly restrictions.
In addition to a sound, transitive version of const with no escape
clauses for mutable ﬁelds, the D language [5] provides an instance-
immutability qualiﬁer invariant that can be used to achieve func-
tional purity. Functions marked with the pure keyword must have
only invariant arguments, can only read invariant global state,
and can only call other pure methods. Their compiler restricts
invariant variables in the global scope to constant values that can
be computed by the compiler5, ensuring determinism. While this
approach avoids the need to eliminate mutable state and determin-
ism from the global scope, there is a substantial cost in expressivity
as it prevents pure functions from making any use of impure func-
tions and methods. The result is essentially of a partition of the
program into imperative and purely functional portions, whereas
our approach allows pure functions to make full use of the rest of
the program, limited only by the references they hold.
The increased convenience of reference immutability (const or
readonly) over class immutability is attractive, as one can just
use the type qualiﬁer with existing classes rather than modifying
the type hierarchy. However, class or instance immutability is nec-
essary to ensure determinism in a concurrent program, as other-
wise a mutable alias can be used to concurrently modify the object.
For non-concurrent programs, reference immutability would be ad-
equate provided that the global scope can only store immutable
references. As a general mechanism for defensive programming,
reference immutability can only serve to protect the originator of
a reference from unwanted modiﬁcations; the recipient of an im-
mutable reference may still need to make a defensive copy.
Instance immutability, like provided in D, is an interesting alter-
native to class immutability that deserves further exploration. For
Java, however, the lack of type safety for generics is likely to be
an issue. For immutable classes, we perform runtime checks to
ensure that the elements placed in an ImmutableArray are actu-
ally immutable; this would not be possible with a purely compile-
time invariant type qualiﬁer as would be required to preserve
full compatibility with Java.
Spec# [3] and JML [7, 15] are extensions to C# and Java that al-
low the programmer to specify invariants on functions and classes.
They follow Bertrand Meyer’s suggestion that classes and methods
should have a contract speciﬁed by invariants [15]. They support
annotating methods with the pure attribute, but purity as deﬁned
for JML includes only side-effect freeness and not determinism.
In strictly functional languages, like Haskell, nearly all functions
are pure. Monads can be deﬁned to allow writing in a more imper-
ative style, in which each operation takes an input state and re-
turns a monad instance that wraps the result along with auxiliary
information such as side effects [27]. The monad type deﬁnes an
operator for sequencing such invocations to obtain a ﬁnal result;
syntactic sugar makes this look like a sequence of imperative state-
5The D compiler can perform a substantial amount of computation
to determine these values, unlike Java’s, which only pre-assigns
literal constants.
ments. While some monads provide a way to retrieve a sequence’s
ﬁnal result integrated with any auxiliary information, other mon-
ads do not. They are “one-way”: once a value is wrapped with
the monad, it never comes out. The I/O monad is an example. All
functions that potentially expose nondeterminism or cause external
side effects use this monad, which allows them to be recognized as
potentially nondeterministic. All functions whose return type does
not mention the IO monad are functionally pure. While monads
provide a means to use effects in Haskell, the language is primarily
oriented at the functional style. In contrast to a mechanism for im-
perative patterns in a functional language, our approach is focused
on being able to recognize pure methods in an otherwise impera-
tive language. This reduces the changes needed to existing code
and programming patterns.
Other systems have mixed imperative and functional program-
ming styles to varying degrees. The Eiffel language [17] separates
what it calls commands and queries. Commands may have side
effects, while queries are supposed to be side-effect free. This is,
however, only a convention; it is not enforced in any way. Similarly,
both Euclid [14] and SPARK [2] deﬁne two distinct constructs for
routines: procedures can have side effects, while functions are only
able to compute a value (and thus are guaranteed to be free of side
effects). In Euclid, functions can only import variables read-only,
which prevents side effects and ensures determinism if the imported
variables (which may be modiﬁed elsewhere) are treated as addi-
tional arguments. In SPARK, annotations on procedures specify ex-
actly which variables can be modiﬁed by the procedure, and which
variables their modiﬁcations are derived from. This and other in-
formation ﬂow policies are veriﬁed by the SPARK Veriﬁer.
Jif [19] extends Java with label-based information ﬂow check-
ing. Variable declarations are annotated with labels that indicate
an owning principal and a policy for data stored in the variable.
The policy can specify (a) the principals whose data the variable
may depend on and (b) those whose data are allowed to affect the
information stored in the variable. These restrictions are enforced
statically, in cases where it is possible to statically guarantee that
the policy is followed, and dynamically, in cases where it is not.
As a special case, it is possible to specify data ﬂow restrictions
that ensure that a particular method is pure. In contrast, while our
approach does not allow for the rich policies expressible in Jif, ob-
taining purity in Joe-E does not require the explicit speciﬁcation of
principals or policies.
10. CONCLUSIONS
Veriﬁable purity is useful for verifying many kinds of high-level
security properties. A language with appropriate characteristics
can greatly simplify the task of writing veriﬁably pure code. By
combining determinism with object-capabilities, we describe a new
class of languages that allow purity to be achieved in largely imper-
ative programs. As such a language, Joe-E allows programmers to
ﬂexibly leverage veriﬁable purity while still using imperative algo-
rithms in a familiar language.
Acknowledgments
We thank David Molnar, Karl Chen, Arel Cordero, Tyler Close,
Toby Murray, Sandro Magi, Mike Samuel, our shepherd Sriram
Rajamani, and our anonymous reviewers for helpful comments on
earlier drafts of this paper. This research was supported by Na-
tional Science Foundation grants CNS-0716715, CNS-0524745,
CNS-0430585, and CCF-0424422.
11. REFERENCES
[1] M. Backes, M. Dürmuth, and D. Unruh. Information ﬂow in
the peer-reviewing process (extended abstract). In IEEE
Symposium on Security and Privacy, Proceedings of SSP’07,
pages 187–191, May 2007.
[2] J. Barnes. High Integrity Software: The SPARK Approach to
Safety and Security. Addison-Wesley Longman Publishing
Co., Inc., Boston, MA, USA, 2003.
[3] M. Barnett, K. R. Leino, and W. Schulte. The Spec#
programming system: An overview. In Proceedings of
Construction and Analysis of Safe, Secure and Interoperable
Smart Devices (CASSIS), 2004.
[4] D. J. Bernstein. Some thoughts on security after ten years of
qmail 1.0. In CSAW ’07: Proceedings of the 2007 ACM
workshop on Computer security architecture, pages 1–10,
New York, NY, USA, 2007. ACM.
[5] W. Bright. D language 2.0.
http://www.digitalmars.com/d/2.0/.
[6] L. Brown. AEScalc. http://www.unsw.adfa.edu.au/
~lpb/src/AEScalc/AEScalc.jar.
[7] L. Burdy, Y. Cheon, D. Cok, M. Ernst, J. Kiniry, G. Leavens,
K. R. Leino, and E. Poll. An overview of JML tools and
applications. International Journal on Software Tools for
Technology Transfer (STTT), 7(3):212–232, June 2005.
[8] Y. Cheon and G. Leavens. A runtime assertion checker for
the Java Modeling Language, 2002.
[9] T. Close and S. Butler. Waterken server.
http://waterken.sourceforge.net/.
[10] N. Hardy. Keykos architecture. SIGOPS Oper. Syst. Rev.,
19(4):8–25, 1985.
[11] HTML4 Test Suite.
http://www.w3.org/MarkUp/Test/HTML401/current/.
[12] R. Ierusalimschy and N. de La Rocque Rodriguez.
Side-effect free functions in object-oriented languages.
Comput. Lang., 21(3/4):129–146, 1995.
[13] M. F. Kaashoek, D. R. Engler, G. R. Ganger, n. Hector
M. Brice R. Hunt, D. Mazières, T. Pinckney, R. Grimm,
J. Jannotti, and K. Mackenzie. Application performance and
ﬂexibility on exokernel systems. In SOSP ’97: Proceedings
of the sixteenth ACM symposium on Operating systems
principles, pages 52–65, New York, NY, USA, 1997. ACM.
[14] B. W. Lampson, J. J. Horning, R. L. London, J. G. Mitchell,
J. G. Mitchell, G. J. Popek, and G. J. Popek. Report on the
programming language Euclid. SIGPLAN Not., 12(2):1–79,
1977.
[15] G. Leavens and Y. Cheon. Design by contract with JML,
2003.
[16] A. Mettler and D. Wagner. The Joe-E language speciﬁcation,
version 1.0. Technical Report UCB/EECS-2008-91, EECS
Department, University of California, Berkeley, August 7,
2008.
[17] B. Meyer. Eiffel: The Language. Object-Oriented Series.
Prentice Hall, Englewood Cliffs, NJ, USA, 1992.
[18] M. S. Miller. Robust Composition: Towards a Uniﬁed
Approach to Access Control and Concurrency Control. PhD
thesis, Johns Hopkins University, Baltimore, Maryland,
USA, May 2006.
[19] A. C. Myers and B. Liskov. A decentralized model for
information ﬂow control. In Symposium on Operating
Systems Principles, pages 129–142, 1997.
[20] D. Oswald, S. Raha, I. Macfarlane, and D. Walters.
class IntException extends Exception {
final int data;
IntException(int data) { this.data = data; }
}
int nondet() {
try { freemem(); return 0; }
catch (IntException ie) { return ie.data; }
}
void freemem() throws IntException {
int shift;
try {
for (shift = 0; ; ++shift) {
new double[1 << shift];
}
} finally { throw new IntException(shift); }
}
Figure 7: finally clauses expose nondeterminism.
HTMLParser 1.6.
http://htmlparser.sourceforge.net/.
[21] A. Rountev. Precise identiﬁcation of side-effect-free methods
in java. In ICSM ’04: Proceedings of the 20th IEEE
International Conference on Software Maintenance, pages
82–91, Washington, DC, USA, 2004. IEEE Computer
Society.
[22] A. Rudys and D. S. Wallach. Termination in language-based
systems. ACM Transactions on Information and System
Security, 5(2), May 2002.
[23] A. Salcianu and M. C. Rinard. Purity and side effect analysis
for java programs. In VMCAI, pages 199–215, 2005.
[24] N. K. Sastry. Verifying Security Properties in Electronic
Voting Machines. PhD thesis, University of California at
Berkeley, 2007.
[25] F. Sauer. Eclipse metrics plugin 1.3.6.
http://metrics.sourceforge.net/.
[26] M. S. Tschantz and M. D. Ernst. Javari: Adding reference
immutability to Java. In Object-Oriented Programming
Systems, Languages, and Applications (OOPSLA 2005),
pages 211–230, San Diego, CA, USA, October 18–20, 2005.
[27] P. Wadler. The essence of functional programming. In
Conference Record of the Nineteenth Annual ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages, pages 1–14, Albequerque, New
Mexico, 1992.
[28] K.-P. Yee and M. Miller. Auditors: An extensible, dynamic
code veriﬁcation mechanism, 2003. http://www.erights.
org/elang/kernel/auditors/index.html.
APPENDIX: FINALLY CLAUSES
Figure 7 shows how to return a nondeterministic value without
explicitly catching an Error by using a finally clause instead.
The freemem() method tries to allocate larger and larger arrays of
doubles until triggering an OutOfMemoryError. This causes the
finally clause to execute, which then throws an IntException
that hides the pending Error. The IntException contains nonde-
terministic state (how many arrays could be allocated before run-
ning out of memory), which is extracted from the exception and
returned by nondet().
Fortunately, Joe-E’s prohibition of the use of finally does not
reduce expressivity: Joe-E code can explicitly catch Exception,
which allows the catching and appropriate handling of any non-
Error throwable in the Java library.