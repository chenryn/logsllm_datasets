•
要进入AHCI模式，需要featureV&V11B≠0
FIS指令的触发
1 8
•
FIS由handle_reg_h2d_fis处理
•
AHCI_PORT_REG_CMD/CMD_ISSUE会调用check_cmdàhandle_cmd映射FIS
•
通过FIS的第一个字节，确认是否要调用handle_reg_h2d_fis，它会设置ide_state这个重
要结构体（模拟IDE寄存器）
IDE指令的运行
1 9
•
handle_reg_h2d_fis中设置完IDE寄存器后，会调用ide_exec_cmd处理IDE指令
•
根据规范，IDE指令位于FIS的第三字节（fis[2]）
•
它在ide_cmd_table中找寻和传入的命令对应的处理函数
•
我们需要它继续处理CommandVTable中的读取操作，因此应使用WIN_PACKETCMD指令
•
cmd_packet也可以通过IDE设备的ATA_IOPORT_WR_COMMAND触发，但使用FIS更简单
从cmd_packet到cmd_read
2 0 
•
cmd_packet通过读取ATAPI指令部分来跳转到cmd_read，比较简单不再展开
•
cmd_read的参数“buf”就是我们在物理内存写入的内容
•
QEMU的函数 ld*_be_p 用于读取值
•
*处可以是l=long,Vw=word,Vu=unsigned,Vbe=大端
•
因此nb_sectors/lba都是取自客户机的污染输入
•
还记得之前想要控制的size字段吗？这意味着size字段也
是可污染的
从cmd_read到ide_atapi_cmd_read_pio
2 1
•
我们已经很接近最终目标了
•
cmd_read调用ide_atapi_cmd_read，而我们找到的污染位置是ide_atapi_cmd_read_pio
•
查看代码可知s->atapi_dma为FALSE时，pio会被调用
•
我们之前要求的featureV&V11B不为0其实就是为了将它设置成0
ide_atapi_cmd_reply_end
2 2
•
我们从前后两个方向收敛到了这个可疑的位置，而且发现它的关键参数都是可控的
•
内部还有一些较细粒度的限制，但都可控：
•
即需要设置lba为-1，来绕过里面的一些检查
•
单次拷贝的长度受到lcyl、hcyl（即柱面cylinder）的限制
•
可在FIS中设置为最大0xfffe，或其他方便进行漏洞利用的值
代码总览
2 3
前半部分的总结
2 4
•
它调用pio_transfer进行传输
•
但传给pio_transfer的data_ptr就已经越界
•
理论上注册了它的设备都有问题，好在只有AHCI注册了它
但这只是前两步……我们只刚解决了FIS和ATAPI的问题
2 5
Solved
Solved
Unsolved
要利用这个漏洞，还得再处理PRDT表
PRDT的使用者——ahci_pio_transfer
2 6
•
从cur_cmd中取出opts(options)
•
opts的内容决定操作方向是读还是写
•
ahci_dma_prepare_buf从PRDT中取出任务
•
这些任务存放在sglist中
•
包括地址、长度等信息
•
调用dma_buf_write/read来处理sglist的任务
sglist的添加过程
2 7
•
Sglist (ScatterVGatherVList)被用来存放要读取的操作序列
•
遍历PRDT表，累加PRDT每一项的操作长度，与已操作的长度进行对比
•
当PRDT表累加到某一项时，若已超过已操作的长度，则将其后面的内容加入sglist
•
这里base即为数据基地址
AHCI设备的初始化
2 8
•
每个SATA控制器有6条主线，每条主线关联有一个设备
•
SATA对应的AHCI会初始化6个AHCIDevice结构体，以及其成员要使用的内存
任意长度越界读
2 9
•
越界读的是io_buffer之后的数据，长度任意
•
读出来的数据会写入DBA指向的物理内存，因此可以无限泄露QEMU的内存
•
只要不是最后一个port，ide_init1之后通常会有下一个port的硬盘控制结构
•
这个控制结构会包含多个全局变量、函数指针，可以绕过ASLR
io_buffer
越界读
ptr
任意长度越界写
3 0
•
opts也可以设置成写操作
•
写操作时，PRDT的DBA地址被当作源地址
•
代码会从DBA读出数据，写入io_buffer后已越界的地址空间中
•
长度、内容不限 è 我们现在有任意长度、任意内容越界读写的原语了
还是那个
io_buffer
越界写
ptr
内存布局与堆风水
3 1
•
发生溢出的s->io_buffer，长度130KB，在设备初始化（realize）时，被ide_init1申请
•
QEMU在初始化完成后，内存中间可能会有因其他操作留下的无权限的gap
•
越界操作是类似memcpy的连续操作，不可避免会经过gap
•
虽然可以通过技巧避免gap，但是直接选择分配在主heap区的port来利用漏洞更简单
实际的漏洞利用——布局部分
3 2
•
最稳定、最容易定位的当属读取后面的ahci_dma_ops结构体
•
这个结构体有10个字段，AHCI使用了其中8个
•
这8个都是函数指针，因此可以用来绕过ASLR
•
AHCI没有使用set_inactive(#8)和reset(#10)
•
reset通常用于重启时通知IDE设备
•
AHCI/IDE共享代码片段，设置reset后可进入IDE的流程
•
将第10个字段，即.reset改为ROP#1的地址
•
当QEMU重启时，reset会被调用，从而开始代码执行
利用时的一些细节
3 3
•
/x86_64-softmmu/qemu-system-x86_64V-enable-kvm -mV2048V
-deviceVich9-ahci,id=ahci -driveVfile=/home/leon/iso.iso,media=cdrom,if=none,id=mycdrom
-deviceVide-cd,drive=mycdrom,bus=ahci.4 è 可改为不同的数字，代表不同总线
-hda /home/leon/disk.qcow2
•
MMIO可以使用periphery库简化操作
•
漏洞可以稳定利用，以QEMU权限执行任意代码
逃逸演示
3 4
漏洞的处理
3 5
•
QEMU官方从源头上修复了问题（禁止CD读取时设置lba为-1）
•
但是CVE提交的信息却是错误的
企业使用或定制化QEMU时的一些思考
3 6
•
及时更新补丁
•
不让用户定制过多的启动参数，过多的灵活性可能带来安全问题
•
设置专门人员负责安全审计，将静态扫描的流程集中在开发环节每一个提交中
•
及时处理崩溃或告警信息，合并PATCH并回报官方
•
研制热补丁系统，以方便修补类似于CVE-2020-14364这样补丁不需要改动很多代码的
问题
3 7
M        A        N        O        E        U        V        R        E
感谢观看！
KCon 汇聚黑客的智慧