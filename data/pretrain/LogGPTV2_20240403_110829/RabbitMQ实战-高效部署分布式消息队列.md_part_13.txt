Error:unable to connect to node rabbit@mrhyde:nodedown
diagnostics:
---
## Page 87
3.4修复Rabbit：疑难解答
65
- nodes and their ports on mrhyde: [rabbit,54174}...]
-current node:'PI:EMAIL'
-current node home dir:/Users/mrhyde
-current node cookie hash: oNANSQ6MP0092ATN9U7Hcc==
将选项更改回读取sname后，一切正常。之后当我们讨论集群时，我们将会调
整该选项。
Mnesia和主机名
接下来我们来讨论Mnesia。作为Erlang数据库，它早在NoSQL流行之前就已
经存在了。RabbitMQ使用Mnesia存储队列、交换器、绑定等信息。RabbitMQ启
动时做的一件事就是启动Mnesia数据库。由于这是服务器正常运行的关键一步，因
此如果Mnesia启动失败，那么RabbitMQ也会跟着失败。
导致Mnesia启动失败的原因大致有二。第一个也是最常见的是MNESIA_BASE
目录的权限问题。运行RabbitMQ服务器的用户需要对该文件夹的写权限。另一个
常见的问题是你看到这样的错误消息：
starting database
...{"init terminating in
do_boot",{(nocatch,lerror,
{cannot_start_application,rabbit,
{{timeout_waiting_for_tables [...]
可以从消息中看到，Mnesia读取表格失败。如果主机名更改了，或是服务器运
行在集群模式下，无法在启动的时候连接到其他节点，这些都会导致失败。为什么
需要关注主机名呢？Mnesia会基于机器的主机名创建数据库 schema。如果你列出
MNESIA_BASE文件夹的内容，就会看到其中一个文件夹是rabbit@hostname。如
果由于网络重新配置的原因，主机名修改了，那么Mnesia就无法载人旧的schema。
同时请谨记RabbitMQ使用rabbit这个单词作为节点名。如果你使用ErlangSname
选项更改了它，Mnesia又会遇到同样的问题。
基于相同的原因，你会发现如果你重命名了rabbit@hostname文件夹，那么
Mnesia将无法找到l日的数据库文件。它会重新创建rabbit@hostname文件夹并启
动数据库。记住：你仍然可以在你重命名的文件夹下找到旧的数据库文件。
Mnesia很值得用一本书来讲述它。所以如果你想要深人了解，就可以阅读用户
指南 http://www.erlang.org/doc/apps/mnesia/users_guide.html。
---
## Page 88
66
第3章运行和管理Rabbit
Erlang故障排除技巧
让我们做一个简单的Erlang练习来结束本节。它会帮助你理解我们之前所讨论
的内容。你将Erlang节点连接到运行中的RabbitMQ服务器。你可以用这一知识监
控运行的服务器，远程执行Erlang函数，等等。
假设你用短名启动RabbitMQ，运行以下命令：
$ erl -sname test
依赖于你的主机名和Erlang版本，你应该会看到以下内容：
Erlang R13B04 (erts-5.7.5) [source] [64-bit] [smp:2:2] ..
Eshell v5.7.5 (abort with ^G)
(test@mrhyde)1>
这意味着你用test作为节点名启动了Erlang节点。你看到的是ErlangRead
EvalPrintLoop，简称REPL。你可以在此输入命令，执行Erlang代码等。让我们找
出节点名称：
(test@mrhyde)1> node() .
test@mrhyde
在REPL中，你输人入node（）并得到结果test@mrhyde。你的Erlang节点将
以这个名字被其他Erlang应用程序知晓。举例来说，如果你启动Mnesia数据库的话，
这就会被用作schema文件夹的名字。
现在让我们看看在你的机器上还运行着哪些节点。
(test@mrhyde)2>net_adm:names().
[ok,[{"rabbit",59106},{"test",59127}]}
你从 net_adm模块调用了names 函数。如你所见，RabbitMQ正运行在你的
机器上。它使用rabbit作为节点名称并使用59106端口。等等·...·那并不是你从
AMQP客户端用来连接RabbitMQ的端口。这是怎么回事呢？这就需要另外一位角
色登场了：ErlangPortMapperDaemon（epmd）。当你启动一个分布式Erlang节点时，
它会用epmd进程进行注册，提供OS内核分配的地址和端口。之后当另一个Erlang
节点启动时，它也会做同样的事情。最后，如果后者想要连接第一个节点的话，它
会查阅epmd以获得节点地址。通过这种方式，你就不需要自己来追踪信息了。然后，
那个端口号（示例中的59106）是由OS分配给运行RabbitMQ的ErlangVM的。
---
## Page 89
3.4修复Rabbit：疑难解答
67
现在你明白如何查找RabbitMQ节点了，让我们尝试建立到它的连接：
(test@mrhyde)3> net_adm:ping('rabbit@mrhyde').
pong
你使用ping函数尝试对其他节点的连接，参数为你想要连接的'node@
hostname’。如果应答是pong 的话，则表明连接成功了；如果应答是pang，那
意味着你无法连接到该节点。记住为了使一切工作正常，你必须共享同样的Erlang
cookie。
让我们确认你连上了rabbit节点：
(test@mrhyde)4> nodes().
[rabbit@mrhyde]
执行nodes（）函数会展示一Erlang中方括号为界的列表一—你连接上的节点
列表。
最后，让我们在远程rabbit节点上执行一个函数：
(test@mrhyde)8> rpc:call('rabbit@mrhyde',
erlang,
system_info,
[process_count]).
106
这里你使用了Erlang的rpc模块在rabbit@mrhyde节点调用了一个函数。
你使用erlang：system_info函数以获得在该节点上Erlang进程的数目。你
可以使用该函数监控RabbitMQ系统的健康状况。如果process_count超过了
process_limit的限制，你的服务器就会崩溃。这不太可能发生一有些机器的
限制是1048576—但将这些铭记于心总是有用的。
通过使用rpc:call，同时提供节点、模块、函数和参数作为人参，你可以在
远程rabbit上执行其他函数以获得不同的信息。最后一个示例，让我们搜集一下
远程rabbit节点上运行着的Mnesia系统的信息：
rpc:call('rabbit@mrhyde', mnesia, info, []).
REPL会打印关于Mnesia的若干行信息，比如RabbitMQ创建的表格、内存使
用情况等。
---
## Page 90
68
第3章运行和管理Rabbit
最后，执行q 函数退出ErlangREPL。这时，你应该回到了终端命令提示符：
(test@mrhyde) 1l> q() .
Ok
Erlang值得用一本书来讲述。不过先把这个想法放一边，你可以使用这里描述
的技巧来解决RabbitMQ的安装问题。举个例子，如果你使用和rabbitmqctl脚
本相同的参数启动ErlangVM的话，就应该可以连接到rabbit节点。如果不是这
样的话，你也能找出机器的主机名。然后你能列出注册在epmd守护进程的节点名
字等。有了这些简单的工具，你可以随时随地排查故障并且监控你的RabbitMQ服
务器。
3.5总结
在本章中，我们介绍了许多实用技术，能给日常RabbitMQ工作带来帮助。你
看到了如何执行服务器管理任务，比如使用RabbitMQ权限系统来添加和删除用户。
我们介绍了RabbitMQ配置文件并说明了如何使用rabbitmqctl命令一它是服
务器日常管理的“瑞士军刀”。然后你看到如何获取服务器的数据统计，以查看你创
建的队列、交换器和它们之间的关系。最后一点同样重要，我们讲解了RabbitMQ
可能向你一次又一次抛出的奇怪的Erlang错误。由于Erlang是服务器结构的基础，
因此你若对该语言有所了解的话，就能执行更高级的管理任务，同时也给了你坚实
的RabbitMQ原理和Erlang语法基础。有了这些知识，让我们进入第4章去看看一
些真实的例子：怎样用消息通信武装你的应用程序。
---
## Page 91
解决Rabbit相关问题
编码与模式
本章要点
■面向消息通信来设计应用程序
■消息通信模式
■发后即忘模型
■用RabbitMQ实现RPC
至此你已经知道了如何安装、配置，并在产品环境中运行Rabbit。现在是时候
让我们开始写点代码了。首先，当你将消息通信集成到应用程序时，你需要理解你
正在尝试解决的问题。像探索RabbitMQ的大多数人一样，我们并不是在寻找一个
消息队列，而是解决解耦问题方法。你如何将一个耗时的任务从触发它的应用程序
中移出（因该应用程序可以继续服务其他请求）？同样，你如何整合用不同语言（譬
如PHP和Erlang），编写的应用程序，使得它们运作起来像单个系统？这看起来像
两个不同的问题，但却有着共同的本质：解耦请求和操作。或者换种说法，这两个
问题均需要从同步编程模型转向异步编程模型。
通常情况下，当程序员听到异步编程时，他们要么吓跑了，要么在想“酷。就
像Node.js那样对吧？”有时则兼而有之。通常，异步编程解决方法的问题在于它
---
## Page 92
70
第4章解决Rabbit相关问题：编码与模式
们是全有或全无的方案。要么重写所有代码以至于没有一处是同步的，要么就是在
浪费时间。RabbitMQ为你提供了不同的方法。它允许你发送请求并在另一处进行
处理，这样同步程序可以返回继续运行。当开始使用消息通信时，你可以获得大部
分纯异步编程的益处，又不用将现有的代码和知识抛开。在本章中，我们将向你展
示Rabbit世界中异步编码的含义。特别是，我们将向你展示如何使用Rabbit去解决
一系列现实世界中的问题。这些问题包括从图片上传（并行处理）、告警（通知），
到使用RabbitMQ轻而易举实现分布式远程过程调用（API）。我们会从讲解一些基
础的消息通信方式开始，然后逐步深人到编码。让我们马上来解耦吧！
4.1解耦风雨路：谁将我们推向消息通信
你花费了所有精力。你编写了最新的、最伟大的Web应用程序（安排吉娃娃遛
狗程序），并决定最快的方式就是接受网络订单，并把它们直接装填到数据库去。听
起来很有道理。把一条很小的记录写到数据库里需要花费多少时间呢？更不用说编
写起来有多简单了。问题在于，当你走向全国，每小时调度安排100000条吉娃娃
遛狗记录时，该怎么办？或者更好的是，你决定要将数据存储到两个地方（将这些
请求进行归档）。猜猜看该怎么办？是时候剥离那些精心调试的代码了。应用程序
和存储之间直接耦合通常就是导致之后代码被淘汰和取代的原因。这正是消息通信
能够帮助你的地方。
4.1.1异步状态思维（分离请求和动作）
你多久会做一次同步动作？如果你订了一份比萨，你会一直等到它送上门来而
不做其他事儿吗？当然不会了。你看看电视或者读读书，或者和她甜言蜜语一会儿。
你极少会把自己的生活搁置起来去等待请求的回应。你一心多用，所以你的生活才
能丰富多彩。你的应用程序需要同样的方法。
为何你会首先将应用程序设计成同步的呢？大多数情况下是因为你思考看整个
任务，而非着眼于构成整体的更小的任务。你脑袋里想着：“我的应用程序需要安
排一个吉娃娃遛狗预约。”相反，现实情况是你的应用程序需要接收一个安排请求；
然后它需要将请求存储到数据库中；之后它需要向就近的遛狗师发送提示；最终需
收订单的速率。因为每个线程都不得不等待记录的存储以及遛狗师收到通知。而你
---
## Page 93
4.1解耦风雨路：谁将我们推向消息通信
71
应该将这四个步骤视为两个分隔的应用：其中一个专门接收请求，另一个专门处理
请求。从GregorHohpe那里窃取的灵感来做个伟大的类比，我们称之为CoffeeBear
模型（CoffeeBean&TeaLeaf是加州的一家连锁咖啡馆）。
当下了个拿铁订单时，你并不会一直等在收银台。相反，CoffeeBean会将接收
订单的操作和订单准备的操作分开。接单员会收集你的请求（和你的钱），并告诉咖
啡调理师你订的是什么。然后你等待订单完成，同时接单员可以腾出时间接其他订
单。当中最重要的部分是收你的钱，以及将订单处理和订单接收分开，CoffeeBean
已经最大化了每分钟所能接收的订单数。同样地，如果等待制作的咖啡积压太多的
话，他们会增加更多的咖啡调理师以减少订单积压，而无须更改接单员的数量。通
过解耦处理过程（分离请求和操作），他们以同样数量的工作人员完成了更多的工作，
同时工作文很容易按需扩展。消息通信可以为你的应用程序做同样的事情。
所以让我们用解耦的思想分析一下你的吉娃娃应用程序。图4.1展现了完成遛
狗订单的步骤。
接收遥狗
安排请求
将请求存储到数据库或
者其他持久化存储中
理
单请求
处
人
通知逾狗师他们
有一位新客户
向顾客确认请求
已经成功处理
遛狗订单应用
图4.1完成一笔遛狗订单的步骤
---
## Page 94
72
第4章解决Rabbit相关问题：编码与模式
如果你想要为自己的应用程序增添可扩展性和灵活性的话，就需要将其切分成
两个不同的应用：dog_walk_order 和dog_walk_process，如图4.2所示。dog_walk_
order 运行在互联网上并接收网络请求以安排遛狗。当收到请求时，dog_walk_order
创建一条新的AMQP消息并发送到Rabbit上的chihuahua_scheduling交换器。
之后 dog_walk_order将暂时搁置顾客A并继续接收其他请求。同时，dog_walk_
process 监听Rabbit队列并接收到包含顾客A的预约订单的消息。然后它就为订单
创建所需的数据库记录，并发送一条文本消息给主遛狗师Gustav。一旦文本消息发
送成功，dog_walk_process 会发送一条顾客A请求成功处理的消息回给dog_walk
order。就在dog_walk_process 处理顾客A请求的那段时间里，dog_walk_order又接
收100条新的遛狗请求。如果它们仍然处于同一个应用中的话，那么在整个时间段
里就只能接收一条遛狗请求。
遛狗订单请求应用
接收遛狗
向客户确认请求
安排请求
已经成功处理
遥狗安排
请求确认
请求消息
消息
RabbitMQ
将请求存储到数据
通知遛狗师他们
库或者其他持久化
存储中
有一位新客户
遛狗订单处理应用
图4.2将遛狗程序分离成两个应用
通过在应用中紧密耦合的两部分中间使用RabbitMQ，之前每次只能处理一个
请求而现在可以持续接收请求了。同时你也开辟了另一片新天地。如果负载过重，