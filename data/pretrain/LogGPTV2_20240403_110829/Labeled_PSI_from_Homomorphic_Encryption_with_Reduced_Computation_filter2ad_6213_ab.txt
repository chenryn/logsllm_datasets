ğ‘›(log ğ‘)2) to the
noise of the input ciphertext.
To sum up, the most costly homomorphic operation both in
running time and in noise growth is non-scalar multiplication. We
therefore measure the runtime complexity of our algorithms in
terms of the number of non-scalar multiplications. We also measure
the depth of our circuits in relation to non-scalar multiplications. We
say, then, that one (sequential) non-scalar multiplication consumes
one multiplicative level.
Note that non-scalar multiplications can sometimes be replaced
by the Frobenius operation when computing ciphertext powers.
Since the Frobenius operation introduces only additive noise, we
say that the Frobenius operation consumes no multiplicative levels,
i.e., it is depth-free.
3 UNLABELED PSI
Our basic PSI protocol follows closely the frameworks of Chen et
al. [13, 14], which are based on ideas from [49].
Input. The receiver has an input set ğ‘Œ of size |ğ‘Œ|. The senderâ€™s
input is a set ğ‘‹ of size |ğ‘‹|. Both sets contain bit strings of length ğœ.
The values of |ğ‘Œ|, |ğ‘‹| and ğœ are public.
Output. The receiver outputs ğ‘‹ âˆ© ğ‘Œ.
Setup. The receiver and the sender agree on an SHE scheme with
the plaintext space being a finite field F. They also publicly choose
the number (typically three) of hash functions â„ğ‘– : {0, 1}ğœ â†’ [ğ‘€],
where ğ‘€ is a positive integer. Finally, they agree an OPRF function
ğ¹k : ğ‘‹ âˆª ğ‘Œ â†’ F.
The receiver generates the public and the secret keys of the
SHE scheme. The sender samples an OPRF key k and computes
ğ‘‹ â€² := {ğ¹k(ğ‘¥) | ğ‘¥ âˆˆ ğ‘‹}. Then, both parties interact to apply the
OPRF to the receiverâ€™s set, whereby the receiver obtains ğ‘Œ â€² :=
{ğ¹k(ğ‘¦) | ğ‘¦ âˆˆ ğ‘Œ}. Now computing ğ‘‹ âˆ© ğ‘Œ amounts to computing
ğ‘‹ â€² âˆ© ğ‘Œ â€².
We note that there are multiple benefits in using OPRF values
instead of the original items. Most importantly, it is necessary to
provide security against a malicious receiver, because homomorphic
encryption does not automatically provide input privacy for the
senderâ€™s input. To address this issue, [14] used a noise flooding
technique to prove security against a semi-honest receiver, but
their approach does not extend to the malicious case. Another
reason is discussed more below in Section 3.1: using OPRF values
allows us to completely avoid costly extension field arithmetic.
Next, the receiver places each ğ‘¦ âˆˆ ğ‘Œ â€² into a cuckoo hash table ğµğ‘…
with bin size 1. Specifically, it will construct a table ğµğ‘… such that no
bin in ğµğ‘… has more than one element, and for all ğ‘¦ âˆˆ ğ‘Œ â€² there is an
ğ‘– such that ğµğ‘…[â„ğ‘–(ğ‘¦)] = ğ‘¦. The sender creates a cuckoo hash table
ğµğ‘† with bin size potentially greater than 1. For all ğ‘¥ âˆˆ ğ‘‹ â€² and all
ğ‘–, the sender places ğ‘¥ into ğµğ‘† [â„ğ‘–(ğ‘¥)], again, allowing for multiple
ğ‘¥ per bin. It is shown in [14] that if |ğ‘‹| â‰« ğ‘€, then each bin of the
sender contains ğ‘‚(|ğ‘‹|/ğ‘€) values with high probability. This setup
ensures that the intersection of ğ‘‹ â€² and ğ‘Œ â€² is equal to the union of
the respective bin intersections, namely,
ğµğ‘…[ ğ‘—] âˆ© ğµğ‘† [ ğ‘—] =
{ğ‘¦ ğ‘—} âˆ© ğµğ‘† [ ğ‘—],
ğ‘‹ â€² âˆ© ğ‘Œ â€² =


ğ‘— âˆˆ[ğ‘€]
ğ‘— âˆˆ[ğ‘€]
where ğ‘¦ ğ‘— denotes the ğ‘¦ value at ğµğ‘…[ ğ‘—]. Both parties encode their
respective bins into the plaintext field F. The receiver encrypts all
its bins and sends them to the sender.
Intersection. Given the encryption(cid:74)ğ‘¦ ğ‘—(cid:75) of the bin ğµğ‘…[ ğ‘—], the
sender computes the intersection polynomial

(1)
(cid:74)ğ‘§ ğ‘—(cid:75) := ğ‘ƒ((cid:74)ğ‘¦ ğ‘—(cid:75)) =
((cid:74)ğ‘¦ ğ‘—(cid:75) âˆ’ ğ‘¥)
ğ‘¥âˆˆğµğ‘† [ ğ‘—]
encrypts some non-zero value in F, depending on ğ‘Œ â€². This non-zero
value does not leak any information about ğ‘Œ, due to the OPRF step.
If ğ‘¦ ğ‘— âˆˆ ğµğ‘† [ ğ‘—], then(cid:74)ğ‘§ ğ‘—(cid:75) is an encryption of zero. Otherwise,(cid:74)ğ‘§ ğ‘—(cid:75)
The sender sends(cid:74)ğ‘§ ğ‘—(cid:75) to the receiver, who decrypts it and checks
whether ğ‘§ ğ‘— = 0.
Security. As shown in [13], the OPRF step makes the above PSI
protocol secure against a malicious receiver and provides privacy
against a malicious sender in the random oracle model. Our protocol
differs from [13] in algorithmic aspects; the security guarantees
and the security proof remain the same as in [13], i.e., the protocol
guarantees security against a malicious receiver and privacy against
a malicious sender [30]. With a small extra computational overhead
the protocol can be upgraded to provide further protection against
a malicious sender, as is described in [13].
3.1 Optimizations
In this section we discuss various optimization techniques to make
the above protocol practical. Some of these (SIMD packing, parti-
tioning, and windowing) have been discussed in the past in [13, 14]
and remain essential to our protocol. We improve the SIMD pack-
ing technique to use only more efficient and flexible prime fields,
although this mainly presents challenges in the labeled case dis-
cussed below in Section 4. We utilize the Paterson-Stockmeyer
algorithm [47] to improve the computational complexity and en-
able new communication-computation trade-offs. We change the
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1138windowing technique to use more efficient extremal postage-stamp
bases [10, 11], which reduces our communication cost significantly
in many cases. We show how many powers of the receiverâ€™s input
can be computed with zero multiplicative depth, resulting in a vari-
ant of the protocol with extremely low communication cost. Finally,
we adapt the Elligator 2 [5] map for the FourQ elliptic curve [17]
for a fast hash-to-curve implementation, which is needed for the
OMGDH-based OPRF protocol.
Permutation-based hashing [49] can be applied immediately in
our work to reduce the item lengths by a few bits. But this technique
will have only a marginal performance impact compared to our
other techniques, so we do not include it this work.
SIMD packing. As discussed in Section 2.3, we can pack mul-
3.1.1
tiple data values into one ciphertext, such that these values can
be simultaneously processed with homomorphic operations. Us-
ing this method, the receiver can essentially treat the slots in a
ciphertext as bins of the cuckoo hash table ğµğ‘…, and thus encode
multiple values ğ‘¦ ğ‘— âˆˆ ğ‘Œ â€² in a single ciphertext. The sender can sub-
sequently compute several intersection circuits (eq. (1)) in parallel,
which results in a significant improvement in both computation
and communication cost.
In [13] the authors were able to support arbitrary-length items
by first hashing them down to a smaller domain and, using SIMD
packing with extension field values that are large enough to hold
the hash values. Unfortunately, extension field arithmetic can have
a devastating effect on performance; this effect is particularly promi-
nent in the labeled mode. Furthermore, the extension fields must
have certain size characteristics to be useful, which in some cases
leads to suboptimal parameter choices.
We observe that it is possible to not use extension fields at all,
and instead use SIMD packing only over prime fields. Since the
element hashes are larger than a single SIMD slot, we simply split
the hash values to occupy several sequential slots. This was not
possible in [13], because the authors considered the OPRF step as
optional: since the individual SIMD slot values are small, they can
be guessed, and even a semi-honest adversary can learn information
about partially matching items with non-negligible probability. This
problem is resolved by always performing the OPRF step, which
randomizes the items and protects the senderâ€™s dataset from partial
item leakage. A few issues remain in the labeled case, which we
will discuss and resolve in Section 4.
3.1.2 Partitioning. To reduce the depth of computation, [14] pro-
posed to split every senderâ€™s bin into ğ›¼ subsets and then compute
intersection on each of these subsets separately. If ğµ is the maximal
size of a senderâ€™s bin, then this method reduces the circuit depth
from âŒˆlog ğµâŒ‰ to âŒˆlog âŒˆğµ/ğ›¼âŒ‰âŒ‰ at the cost of increasing the number of
ciphertexts sent by the sender to the receiver by a factor of ğ›¼.
To compute the intersection polynomial ğ‘ƒ((cid:74)ğ‘¦(cid:75)) of degree ğµ, the
sender can first compute all the monomial powers(cid:74)ğ‘¦(cid:75)2, . . . ,(cid:74)ğ‘¦(cid:75)âŒˆğµ/ğ›¼âŒ‰
using âŒˆğµ/ğ›¼âŒ‰ âˆ’ 1 non-scalar multiplications. These powers can be
used repeatedly to compute the intersection circuits for each of the
ğ›¼ partitions. Another advantage of partitioning: after the monomial
powers have been computed once, they can be used for each parti-
tion, i.e., ğ›¼ times, in relatively cheap scalar multiplication operations
to evaluate the intersection circuits.
3.1.3 Paterson-Stockmeyer algorithm. One issue with partitioning
is that in many situations it is advantageous to take ğµ to be relatively
large (say, in the few thousands), requiring âŒˆğµ/ğ›¼âŒ‰ âˆ’ 1 non-scalar
multiplications, while ğ›¼ remains relatively small (say, 10). In such
a case the computational cost of the non-scalar multiplications
may dominate the online running time. We suggest applying the
Paterson-Stockmeyer algorithm [47] to compute the intersection
polynomial in O(âˆš
ğµ) non-scalar multiplications instead. We now
ğ¿ â‰ˆ âˆšï¸2(ğµ + 1). The sender starts by computing the low powers
explain how this works.
First, pick positive integers ğ¿ and ğ» such that ğµ = ğ¿ğ» âˆ’ 1 and
(cid:74)ğ‘¦(cid:75)2,(cid:74)ğ‘¦(cid:75)3, . . . ,(cid:74)ğ‘¦(cid:75)ğ¿âˆ’1 and the high powers(cid:74)ğ‘¦(cid:75)ğ¿,(cid:74)ğ‘¦(cid:75)2ğ¿,(cid:74)ğ‘¦(cid:75)3ğ¿, . . . ,
(cid:74)ğ‘¦(cid:75)(ğ»âˆ’1)ğ¿ of the receiverâ€™s ciphertext(cid:74)ğ‘¦(cid:75). Then the intersection
polynomial can be rewritten as
ğ»âˆ’1âˆ‘ï¸
ğ‘–=0(cid:74)ğ‘¦(cid:75)ğ‘–ğ¿
ğ‘ƒ((cid:74)ğ‘¦(cid:75)) =
ğ¿âˆ’1âˆ‘ï¸
ğ‘—=0
ğ‘ğ‘–ğ¿+ğ‘—(cid:74)ğ‘¦(cid:75)ğ‘— ,
(2)
ğ¿ âˆ’ 2 + 2(ğ» âˆ’ 1) = ğ¿ + 2ğ» âˆ’ 4
where ğ‘ğ‘˜ is the ğ‘˜-th coefficient of ğ‘ƒ. The internal sums can be
computed by scalar multiplications and additions from the low
powers. Non-scalar multiplications are only needed to multiply
these internal sums by the high powers. The total computation
complexity of computing ğ‘ƒ((cid:74)ğ‘¦(cid:75)) is equal to
ğµ) is achieved when ğ¿ â‰ˆâˆšï¸2(ğµ + 1).
(3)
non-scalar multiplications. The minimal non-scalar complexity
O(âˆš
In fact, Paterson and Stockmeyer designed a slightly faster al-
gorithm with the same asymptotic complexity. Unfortunately, it
cannot be directly exploited in our work as it relies on the fact
that the coefficient ring of an evaluated polynomial is a Euclidean
domain. The coefficients of ğ‘ƒ((cid:74)ğ‘¦(cid:75)) are plaintexts from the ring ğ‘…ğ‘¡,
If the partitioning technique is used, then ğ‘ƒ((cid:74)ğ‘¦(cid:75)) is replaced
by ğ›¼ polynomials ğ‘ƒğ‘–((cid:74)ğ‘¦(cid:75)), ğ‘– âˆˆ [ğ›¼] of degree âŒˆğµ/ğ›¼âŒ‰. Select positive
integers ğ¿ğ›¼, ğ»ğ›¼ such that âŒˆğµ/ğ›¼âŒ‰ = ğ¿ğ›¼ ğ»ğ›¼ âˆ’ 1. To evaluate each ğ‘ƒğ‘–,
the sender precomputes ğ¿ğ›¼ low powers and ğ»ğ›¼ high powers and
computes each ğ‘ƒğ‘– as in eq. (2). Multiplication by the high powers
is performed for each ğ‘ƒğ‘–, i.e., ğ›¼(ğ»ğ›¼ âˆ’ 1) times. It implies that the
non-scalar multiplicative complexity of evaluating every ğ‘ƒğ‘– is equal
to
which is not Euclidean.
ğ¿ğ›¼ âˆ’ 2 + ğ»ğ›¼ âˆ’ 1 + ğ›¼(ğ»ğ›¼ âˆ’ 1) = ğ¿ğ›¼ + (ğ›¼ + 1)ğ»ğ›¼ âˆ’ (ğ›¼ + 3).
achieved by taking ğ¿ğ›¼ â‰ˆâˆšï¸(ğ›¼ + 1) (âŒˆğµ/ğ›¼âŒ‰ + 1).
Similar to eq. (3), the minimal non-scalar complexity O(âˆš
(4)
ğµ) is
Example 1. Consider a bin of size ğµ = 81. Depending on the
number of partitions, ğ›¼, we can compute the intersection either
with the Paterson-Stockmeyer method or with a naÃ¯ve method, that
precomputes all the powers(cid:74)ğ‘¦2(cid:75), . . . ,(cid:74)ğ‘¦ âŒˆğµ/ğ›¼âŒ‰(cid:75). When ğ›¼ â‰¤ 5, the
Paterson-Stockmeyer method requires fewer non-scalar multiplica-
tions, as demonstrated in the following table:
ğ›¼
P.-S. mult.
NaÃ¯ve mult.
1
23
80
2
18
40
3
16
26
4
14
20
5
14
16
6
15
13
7
16
11
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1139+ 3
2 .
log(ğµ + 1)
In Appendix A, we show how to identify from ğ›¼ and ğµ whether
the Paterson-Stockmeyer method with partitioning outperforms
the naÃ¯ve method.
3.1.4 Windowing. In modern leveled FHE schemes, encryption
parameters are set depending on the multiplicative depth of com-
putation: higher multiplicative depth requires larger parameters.
Unfortunately, larger parameters increase both the communication
and computation complexity.
The multiplicative depth of the Paterson-Stockmeyer algorithm
(as in eq. (2)) is equal to âŒˆlog((ğ» âˆ’ 1)ğ¿ + 1)âŒ‰ + 1, which is at most
one bigger than the depth of computing a polynomial of degree
ğµ = ğ¿ğ» âˆ’ 1. To reduce the depth, the receiver can send encryptions
depth max{âŒˆlog(ğ» âˆ’ 1)âŒ‰ , âŒˆlog(ğ¿ âˆ’ 1)âŒ‰}+1. Since the multiplicative
complexity is minimal when ğ¿ > ğ» (eq. (3)), the depth of computing
the intersection polynomial (2) is equal to
of additional precomputed powers of ğ‘¦. For example, if(cid:74)ğ‘¦(cid:75) and
(cid:74)ğ‘¦ğ¿(cid:75) are given to the sender, it can compute eq. (2) with a circuit of
âŒˆlog(ğ¿ âˆ’ 1)âŒ‰ + 1 â‰ˆ logâˆšï¸2(ğµ + 1) + 1 =
Sending more additional powers reduces multiplicative depth.
ğ‘ > 1, namely ğµ =âŒŠlogğ‘ ğµâŒ‹
The windowing technique, as described in [14], relies on the fact
that any integer ğµ > 0 can be represented uniquely in some base
that ğ‘¦ğµ =âŒŠlogğ‘ ğµâŒ‹
ğµğ‘–ğ‘ğ‘– with ğµğ‘– âˆˆ [0, ğ‘ âˆ’ 1]. This means
ğ‘–=0
ğ‘¦ğµğ‘–ğ‘ğ‘– . If all the powers ğ‘¦ğ‘–ğ‘ ğ‘— with ğ‘– âˆˆ [ğ‘ âˆ’ 1]
and ğ‘— âˆˆ [0, âŒŠlogğ‘ ğµâŒ‹] are precomputed, then ğ‘¦ğµ can be obtained by
a circuit of depth âŒˆlog(âŒŠlogğ‘ ğµâŒ‹ + 1)âŒ‰. As a result, the receiver can
send encryptions of these (ğ‘ âˆ’ 1)(âŒŠlogğ‘ ğµâŒ‹ + 1) additional powers
such that the sender can compute all the powers(cid:74)ğ‘¦(cid:75)2, . . . ,(cid:74)ğ‘¦(cid:75)ğµ with
the aforementioned depth.
In practice, it is convenient to fix a multiplicative depth ğ· and
derive ğ‘ from it. Since the function (ğ‘âˆ’1)(âŒŠlogğ‘ ğµâŒ‹+1) is increasing
with ğ‘, the smallest possible ğ‘ supporting depth ğ· results in the
minimal number of ciphertexts sent from the receiver to the sender.
ğ· =(cid:6)log(cid:0)(cid:4)logğ‘ ğµ(cid:5) + 1(cid:1)(cid:7) â‰¥ log(cid:0)(cid:4)logğ‘ ğµ(cid:5) + 1(cid:1) .
Hence, we obtain 2ğ· âˆ’ 1 â‰¥(cid:4)logğ‘ ğµ(cid:5) > logğ‘ ğµ âˆ’ 1 and thus 2ğ· >
(ğ‘ âˆ’ 1)(cid:0)(cid:4)logğ‘ ğµ(cid:5) + 1(cid:1) â‰¤ (ğ‘ âˆ’ 1)(cid:0)logğ‘ ğµ + 1(cid:1)  ğµ2âˆ’ğ· , or
ğ‘ = âŒŠğµ2âˆ’ğ· +1âŒ‹. The number of powers that must be sent is therefore
bounded by
Let ğ· be the target depth. This means that ğ· should satisfy
ğ‘–=0
2
While using the Paterson-Stockmeyer algorithm, the sender
should compute low and high powers and then multiply linear
combinations of the low powers by the high powers as in eq. (2).
This means that to achieve a target depth ğ· while computing the
intersection polynomial, the sender should be able to compute both
sets of powers with depth at most ğ· âˆ’ 1.3
Following the discussion above, we obtain that the receiver
should send (ğ‘ğ¿ âˆ’ 1)(âŒŠlogğ‘ğ¿ (ğ¿ âˆ’ 1)âŒ‹ + 1) encryptions of pow-
ers of ğ‘¦ for the sender to compute the low powers with the base
3The low powers need to be further scalar-multiplied by the polynomial coefficients,
which increases noise comparably to the non-scalar multiplications for some parame-
terizations. Thus, in some cases we require that high powers are compted with depth
ğ· âˆ’ 1 and low powers with depth ğ· âˆ’ 2.
ğ‘ğ¿ = âŒŠ(ğ¿ âˆ’ 1)2âˆ’(ğ·âˆ’1) + 1âŒ‹. To compute the high powers with the
same depth, the sender needs only (ğ‘ğ» âˆ’ 1)(âŒŠlogğ‘ğ» (ğ» âˆ’ 1)âŒ‹ + 1)
encryptions of powers of ğ‘¦ğ¿ with the base ğ‘ğ» = âŒŠ(ğ» âˆ’1)2âˆ’(ğ·âˆ’1) +1âŒ‹.
The upper bound on the number of powers that the receiver needs
to send is defined by the following lemma.
the multiplicative depth ğ· â‰¥ 0 using the Paterson-Stockmeyer method,
Lemma 2. To compute a polynomial ğ‘ƒ((cid:74)ğ‘¦(cid:75)) of degree ğµ > 0 with
the sender needs fewer than 3(ğµ + 1)2âˆ’ğ· (2ğ·âˆ’1 + 1) powers of(cid:74)ğ‘¦(cid:75).
The proof can be found in Appendix B.
3.1.5 Extremal postage-stamp bases. The windowing technique
of [14] described above is easy to use: the receiver always knows
exactly which powers to send. Unfortunately, it is far from optimal.
To demonstrate this point, consider a case where ğµ = 26. The user
could choose to encrypt and send powers {1, 2, 4, 8, 16} of their
query, which the sender can use to compute all powers up to 26 in a
depth-two computation, as illustrated by the first graph of Figure 1.
However, the second graph of Figure 1 demonstrates an alternative
computation, also of depth two, but with only three source pow-
ers: {1, 5, 8}. This immediately translates to a 40% reduction in the
receiver-to-sender communication.
More generally, we would like to answer the question: which
powers of the query should be sent so that the sender can compute
all powers of the query up to as large of a bound ğµ as possible,
without exceeding a target depth.
This problem can be viewed as a variant of the global postage-
stamp problem [10, 11]:
Definition 3 (Global postage-stamp problem). Given positive
integers â„ and ğ‘˜, determine a set of ğ‘˜ positive integers ğ´ğ‘˜ = {ğ‘1 =
1 < ğ‘2 < . . . < ğ‘ğ‘˜} such that all integers 1, 2, . . . , ğ‘› can be written as
a sum of â„ or fewer of the ğ‘ ğ‘— , and ğ‘› is as large as possible. The set ğ´ğ‘˜
is called an extremal postage-stamp basis.
The connection to our problem is clear. In the notation of Defi-
nition 3, if the receiver sends encrypted powers {(cid:74)ğ‘¦ğ‘1(cid:75),(cid:74)ğ‘¦ğ‘2(cid:75), . . .,
(cid:74)ğ‘¦ğ‘ğ‘›(cid:75)} to the sender, then the sender can compute all powers up
to ğµ = ğ‘› in multiplicative depth âŒˆlog2 â„âŒ‰. Concretely, consider the
powers {1, 5, 8} used in Figure 1. Upon receiving {(cid:74)ğ‘¦(cid:75),(cid:74)ğ‘¦5(cid:75),(cid:74)ğ‘¦8(cid:75)},
the sender iterates (in order) over all integers up to ğµ = 26, and for
each power that it has not yet computed (or received), it chooses
a depth-optimal way of computing it as a product of two lower
powers. This is exactly how the graphs in Figure 1 were generated.
In fact, the basis {1, 5, 8} is a unique extremal postage-stamp basis
for â„ = 4, ğ‘˜ = 3 [10].
No simple way of finding extremal postage-stamp bases is known,
nor is the complexity class of the global postage-stamp problem
known. Furthermore, extremal solutions are often unique (or almost
unique) and quickly become hard to find. Fortunately we only need
solutions for small instances of the problem, which have been brute-
forced and are presented in [11].
Extremal postage-stamp bases can be used in two ways with the
Paterson-Stockmeyer algorithm. Recall that in this case the sender
must compute all powers of the receiverâ€™s query up to some positive
integer ğ¿ âˆ’ 1, and all powers that are multiples of ğ¿ not exceeding
the bin size ğµ.
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1140Figure 1: Graphs depicting two possible ways for the sender to compute all powers up to 26 of the receiverâ€™s query from a given
set of source powers. The two arrows pointing out from a node indicate which lower powers need to be multiplied together to
produce the power indicated in the node label.
Naturally, an extremal postage-stamp basis with ğ‘› = ğ¿âˆ’1 can be
used to achieve the first goal. For enabling the sender to compute as
many powers of ğ¿ as possible from as few source powers as possible,
the receiver can apply a (possibly different) extremal postage-stamp
basis, but this time multiply the exponents by ğ¿.
For example, consider again the extremal postage-stamp basis
{1, 5, 8} in Figure 1. This works great for Paterson-Stockmeyer,
when ğ¿âˆ’1 = 26. To use Paterson-Stockmeyer, we could additionally
send powers {ğ¿, 5ğ¿, 8ğ¿} = {27, 135, 216}, which would allow the
server to compute polynomials up to degree 26ğ¿ + 26 = 728 with a
depth 3 circuit.