# 文本优化

## 表格和实验数据

### 表 4: Packer 分析
| 波次 | 时间 (ms) | 指令数 | 层数 |
| --- | --- | --- | --- |
| 1 | 62 | 1189 | 3 |
| 2 | 47 | 1115 | 3 |
| 3 | 20 | 357 | 1 |

- **#proc.** = 进程数
- **#thr.** = 线程数
- **#Wave** = 波次数
- **memory** = 内存使用
- **DM** = 在分配的内存中运行的代码

### 表 5: Aspack v2.12
| 波次 | 时间 (ms) | 指令数 | 层数 |
| --- | --- | --- | --- |
| 1 | 1 | 85 | 4 |
| 2 | 1 | 67 | 1 |
| 3 | 1 | 20 | 2 |
| 4 | 13 | 43 | 4 |
| 5 | 1 | 693 | 1 |
| 6 | 1 | 18 | 1 |
| 7 | 1 | 28 | 1 |
| 8 | 1 | 16 | 1 |
| 9 | 1 | 51 | 1 |
| 10 | 1 | 36 | 1 |
| 11 | 1 | 23 | 1 |
| 12 | 2 | 134 | 2 |
| 13 | 9 | 496 | 3 |
| 14 | 5 | 333 | 2 |
| 15 | 17 | 799 | 4 |
| 16 | 3 | 172 | 3 |
| 17 | 8 | 431 | 4 |
| 18 | 1 | 4 | 1 |

### 表 6: TELock v0.99
| 波次 | 时间 (ms) | 指令数 | 层数 |
| --- | --- | --- | --- |
| 1 | 1 | 8 | 1 |
| 2 | 1 | 8 | 1 |
| 3 | 1 | 8 | 1 |
| 4 | 13 | 43 | 1 |
| 5 | 1 | 693 | 1 |
| 6 | 1 | 18 | 1 |
| 7 | 1 | 28 | 1 |
| 8 | 1 | 16 | 1 |
| 9 | 1 | 51 | 1 |
| 10 | 1 | 36 | 1 |
| 11 | 1 | 23 | 1 |
| 12 | 2 | 134 | 2 |
| 13 | 9 | 496 | 3 |
| 14 | 5 | 333 | 2 |
| 15 | 17 | 799 | 4 |
| 16 | 3 | 172 | 3 |
| 17 | 8 | 431 | 4 |
| 18 | 1 | 4 | 1 |

## 实验结果分析

我们追踪了四个波次，并在最后一个波次中发现了三个进程。通过 CoDisasm 的反汇编输出，我们验证了第四波包含载荷 hupigon.eyf。然后，我们将从最后一波重构的 PE 文件发送到 Virus Total。这次，有 20 种杀毒软件正确地检测到了它为 hupigon.eyf。我们认为这个相对较低的检测率是由于 Virus Total 上的杀毒软件没有专门针对发送的 PE 文件进行扫描，这只是一个内存转储。

这个实验展示了恶意软件编写者如何通过打包器隐藏恶意代码的典型场景。关键在于 CoDisasm 的动态分析能够正确重构打包器生成的反汇编代码，并成功找到 hupigon.eyf。这使我们想到可以扩展 Virus Total，首先使用 CoDisasm 对每个可疑二进制文件进行反汇编，生成一系列波次，然后由各个杀毒软件解析这些波次。探索这一想法将是未来研究的重点。

## 讨论

在这项工作中，我们只考虑了一个执行跟踪。我们可能会质疑单个跟踪是否足够。根据我们的经验，打包器生成的波次序列很少依赖于程序输入，并且几乎不受其执行环境的影响。我们的假设得到了一些先前实验研究的支持 [4, 7]。为了开展这项工作，我们使用了六个知名家族中的 600 个恶意软件样本。我们发现，只有不到 2% 的恶意软件在中间波次与系统环境交互。我们还发现，（i）大多数情况下，载荷位于最后几个波次，（ii）波次结构相对简单。因此，我们能够在实验中提取载荷。然而，正如我们已经观察到的，我们需要迅速开发自动生成一组跟踪的能力，以应对仅在使用时触发的载荷代码片段。

当处理一般的二进制代码时，情况则有所不同。例如，一个僵尸网络会尝试连接以接收命令，但如果在隔离的测试环境中运行，它可能会失败 [5]。因此，获得的跟踪将不相关。一种解决方案是提取消息格式，然后伪造消息以生成跟踪，从而覆盖僵尸网络代码 [3, 6]。在其他情况下，一个有趣的方向是确定运行未探索路径的值，以查看是否会生成新的波次。举个简单的例子：

```c
if (date() == "Friday the 13th") {
    unpack();
} else {
    print("Hello world");
}
```

如果这段代码在一个波次中被发现，并且在除星期五之外的任何一天进行分析，它将不会产生解包后的代码。

## 结论

我们开发了一种名为 CoDisasm 的反汇编器，旨在针对 Windows 平台上运行的混淆 x86 二进制恶意软件文件。它附带了一个 IDA 插件 BinViz，用于可视化代码解包波次，虽然本文未详细描述，但可在 www.lhs.loria.fr 找到。CoDisasm 可以反汇编自修改和使用重叠指令作为混淆技术的二进制文件，这是现代恶意软件中越来越常见的现象。

为了实现这一点，反汇编器结合了二进制文件的动态分析和静态递归反汇编过程。我们设计并实现了一系列新技术，称为拼接反汇编，以解决诸如发现代码波次和代码层等挑战。从技术角度来看，二进制文件的动态分析依赖于一个强大的跟踪器，该跟踪器考虑了反分析机制并跟踪线程和进程。从理论和基础角度来看，我们提供了一个有效的自修改程序模型，其中包含重叠指令。CoDisasm 可能是第一个实现这些结果的工具之一。

CoDisasm 主要设计为自动反汇编工具，输出反汇编代码波次序列。每个波次可以被其他工具进一步分析。我们在第 5.5 节中以 Hupigon 恶意软件为例说明了这种方法。尽管它可以自动无缝处理一定数量的二进制代码（即每分钟 30 个二进制文件），但仍需加速反汇编以应对每天收到和处理大量二进制文件的杀毒公司。

## 致谢

作者感谢 Juan Caballero、Saumya Debray 和 Tim Kornau，他们讨论了这项工作并提供了宝贵的反馈。部分工作由法国国家科研署资助（项目 BINSEC，拨款 ANR-12-INSE-0002）。

## 参考文献

[略]

---

以上是对原文本的优化，使其更加清晰、连贯和专业。希望对您有所帮助！