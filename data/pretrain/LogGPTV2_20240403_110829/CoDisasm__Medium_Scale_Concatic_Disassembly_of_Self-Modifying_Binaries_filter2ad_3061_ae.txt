635
165
3
2
1
3
4
6
#proc. = number of processes ; #thr. = number of threads
#Wave = number of waves
memory
; DM = Code run in allocated
Table 4: Packer analysis
Wave Time (ms) #Instructions #Layers
1
2
3
62
47
20
1189
1115
357
3
3
1
Table 5: Aspack v2.12
Wave Time (ms) #Instructions #Layers
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
1
1
1
1
13
1
1
1
1
1
1
1
2
9
5
17
3
8
85
67
20
43
693
18
28
16
51
36
23
49
134
496
333
799
172
431
4
1
2
2
4
1
1
1
1
1
1
1
3
3
3
2
1
1
Table 6: TELock v0.99
754We traced the 4 waves and the 3 processes of the last wave.
We veriﬁed from the disassembly output of CoDisasm that
Wave 4 contains the payload hupigon.eyf. Then, we sent
to Virus Total the PE ﬁle reconstructed from the last wave.
This time, 20 antivirus products correctly detected it as
hupigon.eyf. We think that this relatively low rate of detec-
tion is due to the fact that the antivirus products available
on Virus Total are not made to scan the sent PE ﬁle, which
is just a memory dump at the last wave.
This experiment illustrates a typical scenario where a mal-
ware writer builds a new malware by concealing a malicious
code with a packer. The key point here is that the dynamic
analysis of CoDisasm correctly reconstructs the disassem-
bly code generated by the packer, and so successfully found
hupigon.eyf. This has lead us to think of the potential use-
fulness of a Virus Total extension where each suspect binary
is ﬁrst disassembled by CoDisasm, which then produces a set
of waves that can then be parsed by each anti-virus. Explor-
ing this idea will likely be the object of future research.
6. DISCUSSION
In this work, we have just considered a single execution
trace. We may wonder whether or not a single trace is
enough. From our experience, the sequence of waves gen-
erated by packers rarely depends on inputs to the program
and is almost blind to its execution environment. Our as-
sumption is comforted by some of our previous experimental
studies described [4, 7]. To conduct this work, we used 600
malware divided in six well-known families. We showed that
less than 2% of malware interact with the system environ-
ment in the middle waves. We found that, (i) most of the
time payloads are in the low last waves, and (ii) the wave
structure is relatively simple. That is why, we were able to
extract payloads in our experiments. But, and as we have
already observed it, we should quickly develop the ability
to automatically generate a set of traces to cope with code
slices of the payloads triggered only when they are used.
It is even possible to think of an attack, where the malware
writer generates a massive number of waves in order to block
and frustrate analysis with CoDisasm.
The situation is quite diﬀerent when we deal with binary
code in general. Take for example a botnet. A botnet will
try to connect in order to receive commands, but it may fail
if it is run in an isolated testbed [5]. As a result the trace
obtained will not be relevant. A solution is to extract mes-
sage formats and then to forge messages to generate traces
in order to cover the botnet code [3, 6]. In other cases, an
interesting direction would be to determine values to run
unexplored paths in a wave to see whether or not it will
produce new waves. Take this toy example:
i f
unpack ( ) ;
}
e l s e p r i n t ” H e l l o world ” ;
If this code is found in a wave and if it is analyzed in any
other day than Friday the 13th, it will not produce the un-
packed code.
( d a t e ( ) = ”F r i d a y t h e 13 th ” ) {
e x e c u t e P a y l o a d ( ) ;
7. CONCLUSION
We have developed a disassembler, called CoDisasm, that
targets obfuscated malware x86 binary ﬁles running on Win-
dows. It comes with an IDA plug-in, called BinViz, to vi-
sualize code unpacking waves, which was not described in
this paper, but is available at www.lhs.loria.fr. CoDis-
asm disassembles binaries that are both self-modifying and
that employ overlapping instructions as obfuscation tech-
niques, something that is increasingly common in modern
malware.
To accomplish this, the disassembler combines dynamic
analysis of the binary and a static recursive disassembly
procedure. We have devised and implemented an array of
novel techniques, that we have dubbed concatic disassem-
bly, to address challenges like the discovery of code waves
and code layers. From a technical point a view, the dy-
namic analysis of binaries relies on a robust tracer taking
into account anti-analysis mechanisms and tracing threads
and processes. From a theoretical and fundamental point of
view, we provide an eﬀective model of self-modifying pro-
grams with overlapping instructions. CoDisasm is probably
one of the ﬁrst tools to achieve these results.
CoDisasm was mainly designed as an automatic disas-
sembler tool which outputs sequence of disassembled code
waves. In turn, each wave may be analyzed by other tools.
We illustrate this approach with the example of the Hupigon
malware in Section 5.5. Nonetheless, while it is able to au-
tomatically and seamlessly process a moderate amount of
binary code (i.e. 30 binaries per minute in our lab), it would
be necessary to speed-up disassembly in order to face the
large amount of binaries received and processed each day by
anti-virus companies.
Acknowledgments
The authors would like to thank Juan Caballero, Saumya
Debray and Tim Kornau with whom we discussed this work,
and who provided invaluable feedback. Work partially funded
by French ANR (project BINSEC, grant ANR-12-INSE-0002).
8. REFERENCES
[1] S. Bardin, P. Herrmann, and F. V´edrine.
Reﬁnement-based cfg reconstruction from
unstructured programs. In Proc. Int. Conf.
Veriﬁcation, Model Checking, and Abstract
Interpretation (VMCAI), pages 54–69, 2011.
[2] J. Caballero, N. M. Johnson, S. Mccamant, and
D. Song. Binary code extraction and interface
identiﬁcation for security applications. In Proc. ISOC
Network and Distributed Systems Security Symp.
(NDSS), 2010.
[3] J. Caballero, H. Yin, Z. Liang, and D. Song. Polyglot:
Automatic Extraction of Protocol Message Format
using Dynamic Binary Analysis. In Proc. ACM Comp.
Communications Security Conf. (CCS), pages
523–529, 2007.
[4] J. Calvet. Analyse dynamique de logiciels malveillants.
PhD thesis, ´Ecole Polytechnique de Montr´eal and
Universit´e de Lorraine, 2013.
[5] J. Calvet, C. R. Davis, J. M. Fernandez, W. Guizani,
M. Kaczmarek, J.-Y. Marion, and P.-L. St-Onge.
Isolated virtualised clusters: Testbeds for high-risk
security experimentation and training. In Proc. Usenix
Cyber Security Experimentation and Testing (CSET),
2010.
[6] J. Calvet, C. R. Davis, J. M. Fernandez, J.-Y. Marion,
P.-L. St-Onge, W. Guizani, P.-M. Bureau, and
A. Somayaji. The case for in-the-lab botnet
755experimentation: creating and taking down a
3000-node botnet. In Proceedings of the 26th Annual
Computer Security Applications Conference, pages
141–150. ACM, 2010.
[22] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna.
Static disassembly of obfuscated binaries. In Proc.
USENIX Security Symposium, pages 255–270,
Berkeley, CA, USA, 2004.
[7] J. Calvet, F. Lalonde L´evesque, J. M. Fernandez, J.-Y.
[23] C. Linn and S. Debray. Obfuscation of executable
Marion, E. Traourouder, and F. Menet. WaveAtlas:
surﬁng through the landscape of current malware
packers. In Proc. Virus Bulletin Conf., 2015.
code to improve resistance to static disassembly. In
Proc. ACM Conf. Comp. Communications Security
(CCS), pages 290–299, 2003.
[8] C. Collberg and J. Nagra. Surreptitious Software -
[24] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
Obfuscation, Watermarking, and Tamperprooﬁng for
Software Protection. Addison-Wesley Software
Security Series, 2009.
[9] K. Coogan, S. Debray, T. Kaochar, and G. Townsend.
Automatic static unpacking of malware binaries. In
Proc. IEEE Working Conf. on Reverse Engineering
(WCRE), pages 167–176, 2009.
[10] S. Debray and J. Patel. Reverse engineering
self-modifying code: Unpacker extraction. In Proc.
IEEE Working Conf. on Reverse Engineering
(WCRE), pages 131–140, 2010.
[11] I. Guilfanov. The ida pro disassembler and debugger.
http://www.hex-rays.com/idapro/.
G. Lowney, S. Wallace, K. Hazelwood, and V. J.
Reddi. Pin: Building customized program analysis
tools with dynamic instrumentation. In Proc. ACM
SIGPLAN Conf. Programming Language Design and
Implementation (PLDI), 2005.
[25] L. Martignoni, M. Christodorescu, and S. Jha.
Omniunpack: Fast, generic, and safe unpacking of
malware. In Proc. Annual Computer Security
Applications Conference (ACSAC), 2007.
[26] A. Moser, C. Kruegel, and E. Kirda. Limits of static
analysis for malware detection. In Proc. Annual
Computer Security Applications Conference (ACSAC),
2007.
[12] W. Guizani, J.-Y. Marion, and D. Reynaud-Plantey.
[27] S. Nanda, W. Li, L.-C. Lam, and T. cker Chiueh.
Server-side dynamic code analysis. In Proc. Int. Conf.
Malicious and Unwanted Software (MALWARE),
pages 55–62, 2009.
Bird: binary interpretation using runtime disassembly.
In Proc. Int. Symp. Code Generation and
Optimization (CGO), 2006.
[13] F. Guo, P. Ferrie, and T.-C. Chiueh. A study of the
[28] M. D. Preda, R. Giacobazzi, S. Debray, K. Coogan,
packer problem and its solutions. In Proc. Int. Symp.
Recent Advances in Intrusion Detection (RAID),
pages 98–115, 2008.
[14] J. Gustafsson, A. Betts, A. Ermedahl, and B. Lisper.
The M¨alardalen WCET benchmarks – past, present
and future. In Proc. Int. Work. on Worst-Case
Execution Time Analysis (WCET), pages 137–147,
2010.
[15] N. M. Hai, O. Mizuhito, and Q. T. Tho. Pushdown
model generation of malware. Technical report, Japan
Advanced Institute of Science and Technology, Japan,
2014.
[16] C. J¨amthagen, P. Lantz, and M. Hell. A new
instruction overlapping technique for anti-disassembly
and obfuscation of x86 binaries. In Proc. Workshop on
Anti-malware Testing Research (WATeR), 2013.
[17] M. G. Kang, P. Poosankam, and H. Yin. Renovo: a
hidden code extractor for packed executables. In Proc.
ACM Workshop on Recurring Malcode (WoRM),
pages 46–53, 2007.
[18] J. Kinder. Static analysis of x86 executables. PhD
thesis, Technische Universit¨at Darmstadt, 2010.
[19] J. Kinder and D. Kravchenko. Alternating control ﬂow
reconstruction. In Proc. Int. Conf. Veriﬁcation, Model
Checking, and Abstract Interpretation (VMCAI),
pages 267–282, 2012.
[20] J. Kinder, F. Zuleger, and H. Veith. An abstract
interpretation-based framework for control ﬂow
reconstruction from binaries. In Proc. Int. Conf.
Veriﬁcation, Model Checking, and Abstract
Interpretation (VMCAI), pages 214–228, 2009.
[21] N. Krishnamoorthy, S. Debray, and K. Fligg. Static
detection of disassembly errors. In Proc. IEEE
Working Conf. on Reverse Engineering (WCRE),
pages 259–268, 2009.
and G. Townsend. Modelling metamorphism by
abstract interpretation. In Proc. Int. Static Analysis
Symposium (SAS), pages 218–235, 2010.
[29] T. W. Reps and G. Balakrishnan. Improved
memory-access analysis for x86 executables. In
Compiler Construction, volume 4959 of Lecture Notes
in Computer Science, pages 16–35. Springer, 2008.
[30] P. Royal, M. Halpin, D. Dagon, R. Edmonds, and
W. Lee. Polyunpack: Automating the hidden-code
extraction of unpack-executing malware. In Proc.
Annual Computer Security Applications Conference
(ACSAC), pages 289–300, 2006.
[31] B. Schwarz, S. Debray, and G. Andrews. Disassembly
of executable code revisited. In Proc. IEEE Working
Conference on Reverse Engineering (WCRE), pages
45–, 2002.
[32] X. Ugarte-Pedrero, D. Balzarotti, I. Santos, and P. G.
Bringas. SoK: Deep packer inspection: A longitudinal
study of the complexity of run-time packers. In Proc.
IEEE Symp. Security and Privacy (S&P), 2015.
[33] G. Vigna. Static disassembly and code analysis. In
M. Christodorescu, S. Jha, D. Maughan, D. Song, and
C. Wang, editors, Malware Detection, volume 27 of
Advances in Information Security, pages 19–41.
Springer US, 2007.
[34] B. Yadegari, B. Johannesmeyer, B. Whitely, and
S. Debray. A generic approach to automatic
deobfuscation of executable code. In Proc. IEEE
Symp. Security and Privacy (S&P), 2015.
756