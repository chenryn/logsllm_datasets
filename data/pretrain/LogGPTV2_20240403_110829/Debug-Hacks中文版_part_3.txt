分析内核信息
HACK #19-#20
HACK#35
HACK #38
---
## Page 24
9
不管怎么说，bug 总是要修改的，本 hack 针对难度较高的②总结了以下心得。
发现 bug 之后，为确定调试方向，必须收集信息并掌握当前状况。
#3
试环境不同的环境中发现的 bug、在多个功能的综合测试或压力测试中发现的 bug
②是最麻烦的情况。②中有自己发现的情况，也有别人发现的情况。因此，在与测
ACK
阅读本书有所帮助。
本 hack 说明了典型 bug 的区分方法和与本书的 hack 的对应关系。希望本 hack 能对
表 1-1 内核有问题的现象
6丨第1章热身准备
也有很多。
开发的程序都能较快地改正。
?
发现 bug 有几种形式。
总结
查看内核信息
gdb
strace
kill -9
键盘
ping
区分方法
在测试之外发现。
通过测试发现。
介绍调试前及调试时的心得体会。
调试的心得
www.TopSage.com
softlockup等有输出结果
无法附加（attach）到进程（无响应）
无法附加（attach）到进程（无响应)
无法结束程序
键盘无法输入
不返回响应
状态为 D
显示中途停止
结果
-大和一洋、安部东洋、大岩尚宏
---
## Page 25
根据笔者经验，下述环境一致的情况能够复现bug。
系统、版本、分区状况和交换区大小等各个细节的一致。
即使硬件不同，也要保证网卡和CPU数量等尽可能接近。软件方面，要保证操作
的发生环境一致。硬件和软件都相同的环境是最理想的。首先，要使用同样的硬件，
在bug发生的机器上复现是最好的，如果无法做到，应当尽可能让复现环境与bug
行为有可能不一样。
发现bug之后就该进行调试工作，但在不同的硬件或软件版本上确认bug的话，其
配置环境
获取内核崩溃转储”）。
“HACK#19 使用diskdump 获取内核崩溃转储”和“HACK#20 使用kdump
请参见“HACK#34kemelpanic（链表破坏篇)”。dump的采集方法请参见
这里说明一下复现之前的准备工作和心得（复现用的测试程序（TP）的制作方法
发现 bug之后的重要工作是以 dump（转储文件）为提示复现bug。
1.复现之前的心得
挂载（Mount）、内核模块等参数、选项。
配置文件的内容。
网络通信的对方的硬件（网卡）。
找不出问题原因时的心得。
磁盘的硬件制造商。
分析时的心得。
复现之后的心得。
复现之前的心得。
法再现。其原因是：/etc/sysconfig/network的设置内容不足。
另一个例子是，/etc/sysconfig/network-script/ifcfg-eth*的内容完全一致，却无
复现。其原因是：内部网络无法访问NTP服务器。
曾遇到过一个问题，在测试用的内部网络上无法复现的bug，在其他环境中却能
www.TopSage.com
---
## Page 26
通等，确认这些对于调试很有帮助。如果每次 bug 复现所用的时间都一样，就应该
启的，还是几十秒以后由 watchdog 重启的？重启之前键盘能否操作、ping 是否畅
比如进行某种操作后就重启的例子。应当确认，是执行特定操作后出现 panic 就重
下面讲述 bug 分析的切入点，以及寻找问题原因时的心得。
3.分析时的心得
现的时间和概率。
此外，有些bug 执行 30 分钟不能复现，而执行 10 小时才能复现。因此要弄清楚复
bug 是100%复现，还是仅在特定时机才会复现，使用的调试方法和时间是完全不
有时看似复现了 bug,其实却是完全不同的现象。要确认 bug 现象是否真的复现了。
2.复现之后的心得
确认网线、配置文件内容正常，并进一步用命令的输出确认是否有问题。
在忽忙中解决 bug 时，经常会犯下简单的错误，如配置错误等。无法复现时，应当
听取时应当考虑到这一点。
后再提问。此外，对方可能不告诉你重要信息，因为他觉得跟 bug 没关系，所以在
反复询问细小的问题会让人疲倦，所以应当先操作一遍，将问题、疑难事项总结之
试图复现他人发现的 bug 时，如果有疑问或需要更多信息，应当总结之后一起问。
听取.
81第1章热身准备
目视确认现象
同的。
确认复现率和时间
确认现象
下面讲讲复现之后的心得。
重新审视配置
须在第1次进行I/0O 处理时执行测试程序才能复现。
一人，因此没告诉我要几秒钟执行一次。此外，bug若是I/O 缓存相关的问题，必
问过测试程序的执行时机，但回答的人和实际编写测试程序并执行的人并不是同
每几分钟执行一次，都无法复现，但最后无意间几秒执行一次就复现了。我也曾
曾有一次，我试图用别人写的测试程序复现bug，但怎么也无法复现。连续一周，
www.TopSage.com
---
## Page 27
循环篇》。相反，版本升级后产生 bug，要确认低版本是否发生。
见“HACK#32应用程序停止响应（死循环篇)”、“HACK#36内核停止响应（死
果在高版本中不发生，那么只需调查代码差异即可。用版本判断问题原因的例子请
开源代码随时都在修改、更新。有些代码的版本要比现行系统中的代码新很多。如
根据版本划分问题
相关bug，禁用 NAPI 也许就能做出判断。
数中加上 nosmp，可以确认是否为 SMP 环境下发生的 bug。如果是el000 驱动程序
如果是内核的 bug，可以通过修改启动参数、内核配置的方法寻找原因。在启动参
根据内核配置、内核启动参数划分问题
panic".
短问题复现的时间。通过调整参数提高复现概率的例子请参见“HACK#35kermel
响应（死循环篇”。此外，还要调整相关参数。限制范围、调整参数后，应该能缩
从其他方向进行调试。通过选项缩小范围的例子请见“HACK#32应用程序停止
个程序，调试就会更加简单；如果必须同时执行3 个程序 bug 才会发生，那么可以
如果执行3 个测试程序会发生bug，那么应该试着逐个执行。如果范围能缩小到一
尽量缩小范围
确认这段时间的长短，这个值对于调试也经常有所帮助。
区。诸如此类问题，根据bug情况可以用各种方法改变参数。
驱动程序的缓冲区方面的 bug，可以用 ethtool-G ethX rx 64 tx 64缩小收发缓冲
（commit）时间从默认的5秒缩短到1秒，bug 可能更容易复现。如果是e1000
如果是文件系统日志（Journal）方面的bug，可以通过 mount-0 commit=1将提交
别还要低的消息都不会显示，这一点应当注意。
馈，这时请执行echo7>/proc/sys/kernel/printk。比这个文件设置的控制台级
再举个不同的例子。我们经常接到“控制台消息无法显示到画面上”这种问题反
呢？确认结果是14秒，这就是解决问题的切入点。
一步，如果sleep 10的话，会睡眠10倍，即50秒，还是睡眠10+4秒，即14秒
下现象，发现实际睡眠时间约为5秒（多4秒），而且每次都睡眠相同的秒数。进
内核计时器本身的 bug，因此用 time命令测量的结果没有参考价值。实际确认一
曾遇到过在 shell 中执行 sleep l，其睡眠时间明显超过1 秒的现象。可能是由于
www.TopSage.com
HACK#3 调试的心得 1 9
---
## Page 28
注2：
种很容易发现的问题，也可能会被当做软件故障。
但产生不自然的行为时，很有可能是硬件故障。虽说是硬件故障，但像没开电源这
可以怀疑是硬件问题。虽说一开始就怀疑硬件的话，本来能改好的问题也改不好了，
调试软件时会遇到无法解释的现象，或是同样条件下每次行为不一致的情况，此时
怀疑硬件问题
下的心得。
有时会调查不出问题原因而束手无策，有时会有说不清楚的现象。下面是这些情况
4.问题原因不明时的心得
感慨：“没想到原因在这儿啊！”
而应当认真地确认，否则，就会与真正的原因擦肩而过。解决问题时经常会有这种
根据现象很容易想到“很可能是某个原因”，但不要仅凭表象做出没有根据的判断，
根据事实做出判断
的显示也有 bug。
ifconfig命令，还要综合考虑ip命令、route 命令及/proc/net 的信息等。有时命令
不要受限于一种信息，而应当结合多种信息确认。网络问题的话，不应仅查看
通过其他途径确认
10 |第1章 热身准备
EDAC (Error Detection And Correction) (bluesmoke)
内存发生ECC 校验错误时，硬件会在MCH（Memory Controller Hub）寄存器
bluesmoke）。EDAC 能检测出内存的 ECC 校验错误和 PCI 总线的校验错误。
Linux 的校验错误检测和通知功能为 EDAC（合并到标准内核注2之前称为
都会对内核做修改，标准内核就是相对于这些而言的。——-译者注
标准内核（stock kernel），指由kermel.org 提供的官方内核。而大多数发行版
最后发现是硬件连接线断了一根。
不仅是笔者，其他人也有同样的经验。比如看上去像个 bug，于是反复调试软件，
件掉了。最后换了块硬盘就完全没问题了。
是哪儿掉下来的，于是怀着饶幸心理看了一眼磁盘内部，发现是磁盘里的电子元
件问题，但有时候又能看见分区。想起以前在旁边捡到个电子元件，完全不知道
以前曾遇到过分区突然看不见的现象。由于一直在更新软件，因此最初以为是软
www.TopSage.com
---
## Page 29
像Linux 等开源软件都有社区。有不明白的问题，可以在开发者的邮件列表里提问。
咨询社区
所以不要什么问题都问，仅限于那些实在无法解决的问题。
事讨论时，可能会得到意想不到的线索，或得到一些提示。但是，同事也是很忙的，
总结好。很多情况下用不着问，在总结的过程中就自己把问题解决了。而且，跟同
无论如何找不到原因时，可以试着跟同事讨论一下。为把现象讲清楚，必须自己先
跟同事讨论
/proc/slabinfo等日志。
等的日志，有助于调试的进行。可根据情况选择 sar、top、free、/proc/meminfo、
即使在深夜执行，之后也能确认其行为。定期获取内存、网络、IVO、CPU 使用率
应当为 bug 的发生做好充分准备。如果是自动化测试程序，就应当输出日志，这样
bug 突然产生时，如果不清楚 bug 产生之前做了什么处理，bug 就很难解决。因此,
为 bug 发生做准备
信息复现 bug，也可以弄清楚其原因。
此时应当在程序中加入输出调试信息的处理。下次发生同一现象时，就能根据这些
有时信息不足导致无法复现 bug，进而无法分析，而时间又不允许继续分析下去了。
无法复现、原因不明时
关键字搜索一下，也许能找到。
原因不明、无从下手时，可以找找以前是否有同类的 bug。在 git或 Bugzila 中用
找找以前改正的同类错误
详情请见内核代码的 Documentation/drivers/edac.txt 或 Documentation/edac.txt。
误的内存的 DIMM 编号。
EDAC 还能从 sysfs 文件系统中获取设置和错误的统计信息，还能获得产生错
寄存器，如果产生错误就引发 panic。
修复的错误，就故意让内核 panic。至于PCI总线的校验错误，EDAC 会轮询
查MCH寄存器，如果是能修正的1比特错误就产生警告，多于2比特的无法
上显示错误详情，并产生 NMI 中断。EDAC 利用该中断检测错误。EDAC 检
www.TopSage.com
HACK#3 调试的心得 I 11
return 0;
*a = 0x1; 
int *a = NULL
*a = 0x1;
www.TopSage.com
---
## Page 33
表 2-1 kernel.core_pattern 中可以设置的格式符
kernel.core_pattern 中可以设置的格式符如表 2-1 所示。
生成内核转储的时刻-进程名-PID-内核转储最大大小.core
文件名的格式如下所示。
在该状态下执行刚才的a.out 程序，就会在/var/core/下生成内核转储文件。
sysctl变量kernel.core_pattern设置。假设在/etc/sysctl.conf 中这样设置。
该分区中设置内核转储文件，这样就方便很多。转储保存位置的完整路径可以通过
可能会给系统的磁盘空间造成压力。这种情况下可以准备内核转储专用分区，并在
录中生成，但可能难以弄清文件到底在哪里生成。此外，大量生成的内核转储文件
使用大型文件系统时，会希望将内核转储放在固定的位置。默认情况下会在当前目
在专用目录中生成内核转储
地保存下来，有助于确定 bug 原因。
踪源代码会很难确定原因。这些情况下，内核转储能将问题发生时的状态原原本本
越难判断接收到信号时程序做了什么操作。此外，如果 bug 很难复现，那么单靠跟
6号
$
格式符
1223267175-a. 0ut-2820-18446744073709551615.core
$ ls /var/core/
# sysctl -p 
kernel.core_uses_pid = 0
kernel.core_pattern = /var/core/%t-%e-*p-sc.core
# cat /etc/sysctl.conf
转储文件的大小上限（内核版本2.6.24以后可以使用）
可执行文件名
主机名（同uname(2)返回的nodename）
转储时刻（从1970年1月1日0:00开始的秒数)
引发转储的信号编号 
被转储进程的真实组ID（real GID）
被转储进程的真实用户ID（real UID)
被转储进程的进程ID（PID）
%字符本身
www.TopSage.com
HACK#4 获取进程的内核转储 1  15 