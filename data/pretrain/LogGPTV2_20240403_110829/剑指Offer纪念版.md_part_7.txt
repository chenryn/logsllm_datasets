return instance;
lock(syncobj)
if
instance = new Singleton2();
（instance ==null)
---
## Page 47
还有更加优秀的解法。
两个if判断来提高效率。这样的代码实现起来比较复杂，容易出错，我们
时间效率比Singleton2要好很多。
为 null，因此只在第一次试图创建实例的时候需要加锁。这样 Singleton3的
instance已经创建出来之后，则无须加锁。因为只在第一次的时候instance
public sealed class Singleton3
于是我们可以把解法二中的代码再做进一步的改进：
创建出实例。而当实例已经创建之后，我们已经不需要再做加锁操作了。
可行的解法：加同步锁前后两次判断实例是否已存在
作，在没有必要的时候我们应该尽量避免。
Singleton2的实例，都会试图加上一个同步锁，而加锁是一个非常耗时的操
Singleton3用加锁机制来确保在多线程环境下只创建一个实例，并且用
Singleton3 中只有当 instance 为 null 即没有创建时，需要加锁操作。当
public static Singleton3 Instance
private static Singleton3 instance = null;
private static object syncobj = new object();
private Singleton3()
我们只是在实例还没有创建之前需要加锁操作，以保证只有一个线程
但是类型 Singleton2 还不是很完美。我们每次通过属性Instance 得到
get
return instance;
if
lock (syncobj)
(instance == null)
if
instance =new Singleton3();
(instance == null)
第2章
面试需要的基础知识
33
---
## Page 48
34
public sealed class Singleton5
机过早的问题：
·强烈推荐的解法二：实现按需创建实例
从而降低内存的使用效率。
的，但如果按照Singleton4的方式实现单例模式，则仍然会过早地创建实例：
的时候创建，而是在第一次用到 Singleton4 的时候就会被创建。假设我们在
在 Singleton4 中，实例 instance 并不是第一次调用属性 Singleton4.Instance
时发现第一次使用一个类型的时候自动调用该类型的静态构造函数。因此
一次 instance。
运行时能够确保只调用一次静态构造函数，这样我们就能够保证只初始化
候创建一个实例。由于C#是在调用静态构造函数时初始化静态变量，.NET
public sealed class Singleton4
我们可以利用C#这个特性实现单例模式如下：
强烈推荐的解法一：利用静态构造函数
public static Singleton5 Instance
Singleton5()
最后的一个实现 Singleton5 则很好地解决了 Singleton4中的实例创建时
C#中调用静态构造函数的时机不是由程序员掌控的，而是当.NET运行
Singleton4的实现代码非常简洁。我们在初始化静态变量instance 的时
public static Singleton4 Instance
private static Singleton4 instance = new Singleton4();
private Singleton4()
C#的语法中有一个函数能够确保只调用一次，那就是静态构造函数，
get
一名企面试官精讲典型编程题（纪念版）
return instance;
---
## Page 49
第四种或者第五种解法，毫无疑问会得到面试官的青睐。
在真正需要的时候才会创建实例，提高空间使用效率。如果在面试中给出
性，确保只创建一个实例。第五种方法利用私有嵌套类型的特性，做到只
保在多线程环境能高效率地工作。第四种方法利用C#的静态构造函数的特
都不是面试官期待的解法。在第三种方法中我们通过两次判断一次加锁确
能正常工作，第二种模式虽然能在多线程环境中正常工作但时间效率很低，
解法比较
需创建。
不会触发.NET运行时调用Nested，也不会创建实例，这样就真正做到了按
造函数创建实例 instance。如果我们不调用属性 Singleton5.Instance，那么就
Singleton5.Instance 得到 Singleton5的实例时，会自动调用 Nested 的静态构
其私有属性他人无法使用 Nested 类型。因此当我们第一次试图通过属性
的实例 instance。类型Nested 只在属性 Singleton5.Instance 中被用到，由于
当第一次用到这个嵌套类型的时候，会调用静态构造函数创建Singleton5
本题完整的源代码详见02_Singleton项目。
在前面的5种实现单例模式的方法中，第一种方法在多线程环境中不
源代码：
在上述 Singleton5的代码中，我们在内部定义了一个私有类型Nested。
classNested
internalstaticreadonlySingleton5instance=newSingleton5();
static Nested()
let
return Nested.instance;
第2章面试需要的基础知识
35
---
## Page 50
36剑指Offer-
有得到充分利用。
据预先分配内存。
据大小分配内存。即使我们只在数组中存储一个数字，也需要为所有的数
顺序存储数据。创建数组时，我们需要首先指定数组的容量大小，然后根
2.3.1
构能帮助我们解决很多算法问题。
结构，同样队列也与广度优先遍历算法紧密相关。深刻理解这两种数据结
鲁棒性，否则容易出现程序崩溃的问题。栈是一个与递归紧密相关的数据
树需要操作大量的指针，应聘者在解决相关问题的时候一定要留意代码的
字和字符。链表和树是面试中出现频率最高的数据结构。由于操作链表和
聘者都要熟练掌握这几种数据结构。
符串、链表、树、栈及队列这几种常见的数据结构展开的，因此每一个应
数据结构
这些派生类型都只能产生一个实例。请问该如何设计实现这些类型？
President，可以从该类型继承出FrenchPresident和AmericanPresident等类型。
不能作为其他类型的基类。现在我们要求定义一个表示总统的类型
本题扩展：
数组和字符串是两种最基本的数据结构，它们用连续内存分别存储数
数组可以说是最简单的一种数据结构，它占据一块连续的内存并按照
数据结构一直是技术面试的重点，大多数面试题都是围绕着数组、字
在前面的代码中，5种单例模式的实现把类型标记为 sealed，表示它们
数组
考查对多线程编程的理解。
考查对C#的基础语法的理解，如静态构造函数等。
考查对单例（Singleton）模式的理解。
一名企面试官精讲典型编程题（纪念版）
，因此数组的空间效率不是很好，经常会有空闲的区域没
---
## Page 51
小。这个数组包含5个整数，每个整数占4字节，因此总共是20字节。data2
int GetSize(int data[])
请问输出是什么？
的边界。下面通过一个例子来了解数组和指针的区别。运行下面的代码，
组的大小，因此用指针访问数组中的元素时，程序员要确保没有超出数组
素。我们可以用一个指针来访问数组。但值得注意的是，C/C++没有记录数
明
改变数组容量大小的次数。
的额外操作，这对时间性能有负面影响，因此使用动态数组时要尽量减少
样就能减少内存的浪费。但我们也注意到每一次扩充数组容量时都有大量
一次的两倍)，把之前的数据复制到新的数组中，再把之前的内存释放，这
新分配一块更大的空间（STL的vector每次扩充容量时，新的容量都是前
int
间，然后往数组中添加数据。当数据的数目超过数组的容量时，我们再重
比如C++的 STL中的vector。为了避免浪费，我们先为数组开辟较小的空
就可以在0(1)实现查找，从而可以快速高效地解决很多问题。面试题35“第
该下标对应的数字就组成了一个键值-值的配对。有了这样的哈希表，我们
把数组中的每一个数字设为哈希表的值（Value），这样每一个下标及数组中
用数组来实现简单的哈希表：把数组的下标设为哈希表的键值（Key），而
元素，因此它的时间效率是很高的。我们可以根据数组时间效率高的优点，
一个只出现一次的字母”就是一个很好的例子。
printf("%d, %d, %d", sizel, size2, size3);
答案是输出“20,4,4"。datal是一个数组，sizeof(datal)是求数组的大
int size2=sizeof(data2);
int datal[] ={1,
return sizeof(data);
一个数组时，其数组的名字也是一个指针，该指针指向数组的第一个元
int size3=GetSize（datal);
int*data2=datal;
int sizel
_tmain(int argc,
为了解决数组空间效率不高的问题，人们又设计实现了多种动态数组
在C/C++中，数组和指针是相互关联又有区别的两个概念。当我们声
由于数组中的内存是连续的，于是可以根据下标在O(1)时间读/写任何
sizeof(datal);
2，3，4，5};
_TCHAR* argv[])
第2章
面试需要的基础知识
37
---
## Page 52
8
剑指Offer
图2.1
（如图2.1（b）所示)。
要查找的数字，那么要查找的数字应该在当前选取的位置的上边或者左边
的位置的右边或者下边（如图2.1（a）所示)。同样，如果选取的数字大于
要查找的数字，那么根据数组排序的规则，要查找的数字应该在当前选取
数字刚好和要查找的数字相等时，就结束查找过程。如果选取的数字小于
从数组中选取一个数字，分3种情况来分析查找的过程。当数组中选取的
回 false。
查找数字7，则返回true；如果查找数字5，由于数组不含有该数字，则返
每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一
面试题3：二维数组中的查找
的结果仍然是4。
因此尽管函数GetSize的参数 data 被声明为数组，但它会退化为指针，size3
中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针，
个指针。在32位系统上，对任意指针求sizeof，得到的结果都是4。在C/C++
声明为指针，尽管它指向了数组datal的第一个数字，但它的本质仍然是一
9
：
2
一
个二维数组和一个整数，判断数组中是否含有该整数。
要查找的数字
在分析这个问题的时候，很多应聘者都会把二维数组画成矩形，然后
例如下面的二维数组就是每行、每列都递增排序。如果在这个数组中
题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，
二维数组中的查找
8
2
一名企面试官精讲典型编程题（纪念版）
L
6
8
15
13
（b）数组中的数字大于
要查找的数字
---
## Page 53
数字7，于是查找过程就可以结束了。
下两行两列数字（如图2.2（d）所示）。
数字4位于右上角，和前面一样，我们把数字4所在的行也删除，最后剩
除，只分析剩下的三行两列数字（如图2.2（c）所示)。在剩下的数字中，
右边，因此7只有可能出现在2的下边。于是我们把数字2所在的行也剔
我们已经发现2右边的列都已经被剔除了，也就是说7不可能出现在2的
那么要查找的7可能在2的右边，也有可能在2的下边。在前面的步骤中，
7，因此8所在的列我们也可以剔除。接下来我们只要分析剩下的两列即可
图2.2（a）所示)。在剩下的矩阵中，位于右上角的数字是8。同样8大于
是我们把这一列从需要考虑的区域内剔除，之后只需要分析剩下的3列（如
的第一个（也是最小的）数字，因此7不可能出现在数字9所在的列。于
况会不会变简单呢？
区域。如果我们从数组的一个角上选取数字来和要查找的数字做比较，情
字来和要查找的数字做比较，这样导致下一次要查找的是两个相互重叠的
数组中查找数字7为例来一步步分析查找的过程。
个问题，我们不妨也从一个具体的例子入手。下面我们以在题目中给出的
体的问题入手，通过分析简单具体的例子，试图寻找普遍的规律。针对这
是很多人就卡在这里束手无策了。
两个区域中出现，而且这两个区域还有重叠，这问题看起来就复杂了，于
数字可能出现的区域（阴影部分）。
（如图2.2（b）所示）。
在剩下的两行两列4个数字中，位于右上角的刚好就是我们要查找的
在由剩余的两列组成的数组中，数字2位于数组的右上角。2小于7，
首先我们选取数组右上角的数字9。由于9大于7，并且9还是第4列
前面我们之所以遇到难题，是因为我们在二维数组的中间选取一个数
当我们需要解决一个复杂的问题时，