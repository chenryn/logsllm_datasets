        v16 -= 2;
        xor_key = (_BYTE)v17  -2 );
      ++p;
    }
    while ( p >> eval('44646 + ( 64094 + ( 71825 * ( ( 15873 + ( 21793 * ( 7234 + ( 17649 * ( ( 2155 + ( 74767 * ( 35392 + ( 88216 * ( 83920 + ( 16270 + ( 20151 * ( 5268 + ( 90693 * ( 82773 + ( 716 + ( 27377 * ( 44329 + ( 49366 * ( ( ( 38790 + ( 70247 * ( 97233 + ( 18347 + ( 22117 * ( ( ( 72576 + ( ( 47541 + ( 46975 + ( 53769 * ( 94005 + ( ( 72914 + ( 5137 + ( 87544 * ( ( 71583 + ( 20370 + ( 37968 * ( 17478 + ( ( 40532 + ( 10089 + ( 13332 * ( ( 24170 + ( 46845 * ( 16048 + ( 23142 * ( 31895 + ( 62386 * ( 12179 + ( 94552 + ( ( ( 52918 + ( 91580 + ( ( ( 38412 + ( 91537 * ( 70 + ( 98594 * ( ( 35275 + ( 62912 * ( 4755 + ( 16737 * ( 27595 + ( ( 43551 + ( 64482 * 3550 ) ) - 21031 ) ) ) ) ) ) - 57553 ) ) ) ) ) - 89883 ) - 38900 ) ) ) - 19517 ) - 79082 ) ) ) ) ) ) ) ) ) - 70643 ) ) ) ) - 55350 ) ) ) ) ) - 40301 ) ) ) ) - 83065 ) ) ) ) ) - 52460 ) ) - 49428 ) - 94686 ) ) ) ) ) ) - 1653 ) - 65217 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) - 43827 ) ) ) ) ) - 66562 ) ) )')
    245160825372454180181035013425094268426669928853472000168466067114757309065141074622457247656884957267064733565L
    >>> hex(245160825372454180181035013425094268426669928853472000168466067114757309065141074622457247656884957267064733565)
    '0x686374667b50306c3173685f4475636b5f5461737433735f44336c3163693075735f44305f555f5468316e6b3f7dL'
    >>> '686374667b50306c3173685f4475636b5f5461737433735f44336c3163693075735f44305f555f5468316e6b3f7d'.decode('hex')
    'hctf{P0l1sh_Duck_Tast3s_D3l1ci0us_D0_U_Th1nk?}'
PS：题目一开始放出来的时候是另外一个奇怪的式子：
    notepad.exe44646 64094 71825 66562 15873 21793 7234 17649 43827 2155 74767 35392 88216 83920 16270 20151 5268 90693 82773 716 27377 44329 49366 65217 1653 38790 70247 97233 18347 22117 94686 49428 72576 52460 47541 46975 53769 94005 83065 72914 5137 87544 40301 71583 20370 37968 17478 55350 40532 10089 13332 70643 24170 46845 16048 23142 31895 62386 12179 94552 79082 19517 52918 91580 38900 89883 38412 91537 70 98594 57553 35275 62912 4755 16737 27595 21031 43551 64482 3550 *++-+*+*++-*+*++-+-+++-+-++*+*+*++-*+++-+*+++-*+++-+*+++-++-+-*++*++-+-*+*++*+*++*+*++-*+*++-*++
根据题目名称猜测是波兰式、逆波兰式一类的，但是运算数和运算符数量匹配不起来，看了一下午没想出来。
后来与作者沟通，原来要把式子里的`+-`->`-`，然后就能解出，不过作者最后还是换成正常表达式了2333
### Spiral
IDA打开，第一关判断了系统版本：
    v1 = GetVersion();
      return (unsigned __int8)v1 == 5 && HIBYTE(v1) == 1;
这里我的系统版本过不了，于是直接patch掉。
下一关判断了命令行参数（即flag）长度为73，然后再`sub_448726`函数中对前46位做了一个check：  
首先通过`sub_44AFA8`对flag加密，然后在`sub_44F5B0`与一个固定data做比较，大致就是data里面偶数位是opcode，奇数位是oprand，照着模拟一下即可得到flag的前半部分：
    data0=[0x07, 0xE7, 0x07, 0xE4, 0x01, 0x19, 0x03, 0x50, 0x07, 0xE4, 0x01, 0x20, 0x06, 0xB7, 0x07, 0xE4, 0x01, 0x22, 0x00, 0x28, 0x00, 0x2A, 0x02, 0x54, 0x07, 0xE4, 0x01, 0x1F, 0x02, 0x50, 0x05, 0xF2, 0x04, 0xCC, 0x07, 0xE4, 0x00, 0x28, 0x06, 0xB3, 0x05, 0xF8, 0x07, 0xE4, 0x00, 0x28, 0x06, 0xB2, 0x07, 0xE4, 0x04, 0xC0, 0x00, 0x2F, 0x05, 0xF8, 0x07, 0xE4, 0x04, 0xC0, 0x00, 0x28, 0x05, 0xF0, 0x07, 0xE3, 0x00, 0x2B, 0x04, 0xC4, 0x05, 0xF6, 0x03, 0x4C, 0x04, 0xC0, 0x07, 0xE4, 0x05, 0xF6, 0x06, 0xB3, 0x01, 0x19, 0x07, 0xE3, 0x05, 0xF7, 0x01, 0x1F, 0x07, 0xE4]
    s=''
    for i in range(0, len(data0), 2):
        x = data0[i]
        x2 = data0[i+1]
        if x == 0:
            x2-=34
        if x == 1:
            x2-=19
        if x == 2:
            x2-=70
        if x == 3:
            x2-=66
        if x == 4:
            x2^=0xca
        if x == 5:
            x2^=0xfe
        if x == 6:
            x2^=0xbe
        if x == 7:
            x2^=0xef
        #print x, x2, x|((x2<<3)&0x78)
        s+=chr(x|((x2<<3)&0x78))
    print s
后半部分写在一个驱动文件中，我的电脑无法直接运行，于是逆一下，发现主要逻辑从`sub_403310`开始，大致就是开了一个奇怪的vm（找到一个[类似的题](https://blog.attify.com/flare-on-5-writeup-part7/)），其中`sub_4030b0`中的一串相当于vm code：
    void vmcalls()
    {
      rdmsr(0x176);
      invd(0x4433);
      vmcall(0x30133403);
      vmcall(0x3401CC01);
      vmcall(0x36327A09);
      vmcall(0x3300CC00);
      vmcall(0x3015CC04);
      vmcall(0x35289D07);
      vmcall(0x3027CC06);
      vmcall(0x3412CC03);
      vmcall(0x3026CD06);
      vmcall(0x34081F01);
      vmcall(0x3311C302);
      vmcall(0x3625CC05);
      vmcall(0x3930CC07);
      vmcall(0x37249405);
      vmcall(0x34027200);
      vmcall(0x39236B04);
      vmcall(0x34317308);
      vmcall(0x3704CC02);
      invd(0x4434);
      vmcall(0x38531F11);
      vmcall(0x3435CC09);
      vmcall(0x3842CC0A);
      vmcall(0x3538CB0B);
      vmcall(0x3750CC0D);
      vmcall(0x3641710D);
      vmcall(0x3855CC0F);
      vmcall(0x3757CC10);
      vmcall(0x3740000C);
      vmcall(0x3147010F);
      vmcall(0x3146CC0B);
      vmcall(0x3743020E);
      vmcall(0x36360F0A);
      vmcall(0x3152CC0E);
      vmcall(0x34549C12);
      vmcall(0x34511110);
      vmcall(0x3448CC0C);
      vmcall(0x3633CC08);
      invd(0x4437);
      vmcall(0x3080CC17);
      vmcall(0x37742C16);
      vmcall(0x3271CC14);
      vmcall(0x3983CC19);
      vmcall(0x3482BB17);
      vmcall(0x3567BC15);
      vmcall(0x3188041A);
      vmcall(0x3965CC12);
      vmcall(0x32869C19);
      vmcall(0x3785CC1A);
      vmcall(0x3281CC18);
      vmcall(0x3262DC14);
      vmcall(0x3573CC15);
      vmcall(0x37566613);
      vmcall(0x3161CC11);
      vmcall(0x3266CC13);
      vmcall(0x39844818);
      vmcall(0x3777CC16);
      vmcall(0xFFEEDEAD);
    }
`sub_402880`函数是对应的解释函数：
    int sub_402880()
    {
      int opcode; // [esp+4h] [ebp-Ch]
      int v2; // [esp+Ch] [ebp-4h]
      opcode = vmread(0x4402);
      v2 = vmread(0x440C);
      r4 = vmread(0x681C);
      r8_ = vmread(0x681E);
      r9_ = vmread(0x6802);
      if ( !inited )
      {
        vm_init();
        inited = 1;
      }
      switch ( opcode )