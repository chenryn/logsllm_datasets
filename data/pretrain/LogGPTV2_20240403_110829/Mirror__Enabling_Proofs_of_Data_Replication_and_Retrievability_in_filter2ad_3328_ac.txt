a(k)
t+λ +1 = ∑λ
t+i for any t ≥ 0. Observe that due
to the fact that f ∗a (x) is a multiple of fa(x), it likewise
i=1 α∗i · a(k)
holds a(k)
t+i for any t ≥ 0. Finally,
the user publishes as part of the copy parameters
the values ga(k)
λ∗ ∈ ZN for each replica and the
coeﬃcients α∗1 , . . . ,α ∗λ∗ ∈ Z. Afterwards, he proceeds
analogously over Zq(cid:31) , i.e., sample coeﬃcients βi ∈ Zq(cid:31),
compute feedback functions fb(x), f ∗b (x), choose an
initial state (b(k)
λ ) for each replica, and so on.
Summing up, and assuming that the server should
construct r replicas, the user sets the ﬁle speciﬁc
veriﬁcation tag (which are kept secret by the user)
to:
λ ) ∈ Zλ
i=1 αi·a(k)
t+λ∗+1 = ∑λ∗
1 , . . . ,b (k)
1 , . . . ,g a(k)
τ
:= (cid:31)kprf, p,q,g,h, (a(k)
(b(k)
1 , . . . ,b (k)
1 , . . . ,a (k)
λ )1≤k≤r, (α1, . . . ,α λ ),
λ )1≤k≤r, (β1, . . . ,β λ )(cid:30) .
To enable the server to construct the r replicas, the
following copy parameters are given to the server:
Π := (cid:29)(ga(k)
1 , . . . ,g a(k)
(hb(k)
1 , . . . ,h b(k)
λ∗ )1≤k≤r, (α∗1 , . . . ,α ∗λ∗),
λ∗ )1≤k≤r, (β∗1 , . . . ,β ∗λ∗)(cid:28) .
That is, the user sends D, the values {σi}1≤i≤n, and
Π to the service provider and keeps the veriﬁcation
tag τ secret. Observe that the size of τ and Π are
independent of the ﬁle size.
Speciﬁcation of the CheckReplica Procedure: As the
replicas are completely generated by the service
provider, a CheckReplica procedure is not required in
Mirror. However, one could check the validity of the
data replicas by running the Replicate procedure and
simply comparing the outputs.
Speciﬁcation of the Replicate Procedure: Upon re-
ception of D, the values {σi}1≤i≤n, and Π, the service
provider S stores D and starts the construction of
the r additional replicas D(k) for 1 ≤ k ≤ r, of D. Here,
each sector d(k)
i, j of replica k has the following form:
i, j = di, j · g(k)
d(k)
i, j · h(k)
i, j ,
i, j and h(k)
(4)
We call these values g(k)
i, j blinding factors.
Both sets of blinding factors are computed by raising
g and h by elements of the LFSR sequences a(k)
and
t
b(k)
, respectively, but one in the forward and the
t
other in the backward order, namely:
i, j := ga(k)
g(k)
(i−1)·s+ j ,
i, j := hb(k)
h(k)
(n·s+1)−(i−1)·s− j .
(5)
To enable the provider to compute the blinding fac-
tors ga(k)
, we make use of the fact that for any t ≥ 0
it holds a(k)
t+λ∗+1 = ∑λ∗
t+i and hence
i
i=1 α∗i · a(k)
i=1(cid:29)ga(k)
t+i(cid:28)α∗i
λ∗
∏
ga(k)
t+λ∗+1 =
.
(6)
The computation of the blinding factors hb(k)
analogously.
i works
In summary, the server constructs replicas D(k) for
k = 1, . . . ,r as follows:
1
(n−1)·s+s
d1,1 · ga(k)
d2,1 · ga(k)
dn,1 · ga(k)
· hb(k)
s+1 · hb(k)
...
(s−1)·s+1 · hb(k)
(n−2)·s+s
s
. . .
. . .
. . .
. . .
(n−1)·s+1
(n−2)·s+1
s
d1,s · ga(k)
d2,s · ga(k)
· hb(k)
2·s · hb(k)
...
n·s · hb(k)
dn,s · ga(k)
1
R
Speciﬁcation of the Verify Procedure: The Verify pro-
tocol generates at ﬁrst a random challenge C. It con-
tains a random (cid:28)-element set of tuples (i,νi) where
i ∈ {1, . . . ,n} denotes a block index, and νi
← ZN is
a randomly generated integer. In addition, a non-
zero subset R ⊂ {1, . . . ,r} is sampled. The set R will
indicate which replicas will be involved in the chal-
lenge. Observe that R = /0 would mean that simply a
proof of retrievability is executed without checking
the replicas. The challenge is then the combination
of both:
c=1,R).
C = ((ic,νc)(cid:28)
(7)
Given a challenge C, the server computes the re-
sponse µ = (µ1, . . . , µs) ∈ Zs
dνc
ic, j,
N as follows:
j = 1, . . . ,s.
µ j :=
(8)
∏
(cid:28)
c=1
1058  25th USENIX Security Symposium 
USENIX Association
8
Observe that µ j
original data, that is dic, j
are processed in the same manner to obtain:
is the product of powers of the
νc . In addition, the ﬁle tags
σ =
(cid:30)
c=1(cid:31)σic ·
∏
s
∏
j=1
(k)(cid:30)νc
.
dic, j
∏
k∈R
(9)
The tuple (µ,σ ) marks the response and is sent back
to the user who veriﬁes (µ,σ ) similar to the private-
veriﬁable POR of [34]. First, he computes:
˜σ := σ ·
(cid:30)
c=1(cid:31) s
∏
∏
j=1
g(k)
ic, jh(k)
ic, j(cid:30)−νc
∏
k∈R
(10)
Observe that this will require the reconstruction of
the blinding factors. In Appendix C, we show how to
eﬃciently perform this veriﬁcation by the user, using
the knowledge of the veriﬁcation tags—in particular
the knowledge of the secret shorter LFSR, its initial
state, and the order of g and h, respectively.
Next, the user recovers the secret parameters εik ,
k = 1, . . . , (cid:30), using the key kprf as a seed for the PRF.
Finally, the user veriﬁes that the following holds:
s
∏
j=1
µ j
ε j+|R| = ˜σ .
(11)
it
.
First,
j=1 ∏r∈R dic, j(cid:28)νc
We now explain why the veriﬁcation step has
to hold if the response has been computed cor-
rectly.
from Equation (4)
that ∏(cid:30)
rewritten
can be
follows
ic, j(cid:28)νc
j=1 ∏r∈R d(r)
c=1(cid:29)∏s
as the product of ∏(cid:30)
ic, j(cid:28)νc
ic, jh(r)
c=1(cid:29)∏s
j=1 ∏r∈R g(r)
ic, j(cid:28)νc
j=1 d|R|
c=1(cid:29)∏s
c=1(cid:29)∏s
∏(cid:30)
. The second factor is
exactly the part that is canceled out in Equa-
tion (10) while the ﬁrst factor can be simpliﬁed to
∏(cid:30)
Given a series of straightforward calculations, one
j=1 (µ j)ε j+|R|.
can show that ˜σ can be rewritten to ∏s
This proves the correctness of Equation (11)—hence
the correctness with respect to extractability.
and
Moreover, it is easy to see that, since each sector
of a replica corresponds to the multiplication of the
corresponding sector of the uploaded ﬁle D with a
blinding factor (that can be reconstructed from Π),
the replicas are indeed copies of the original ﬁle. This
means that Replicate is correct. Summing up, all
three correctness requirements explained in Section 2
are fulﬁlled in Mirror.
4 Security Analysis
We now proceed to prove the security of our scheme
according to the deﬁnitions in Section 2.4. Recall that
the user is not involved in the replica generation and
that the size of the parameters involved in creating a
replica is independent of the ﬁle size. This ensures the
correct replication property described in Section 2.4.
It remains to prove that (i) if the service provider
S stores at least a fraction δ of all sectors in one
replica, then the ﬁle can be reconstructed (extractabil-
ity) and (ii) if the service provider stores less than
a fraction of δ of any replica, this misbehavior will
be detected with overwhelming probability (storage
allocation).
4.1 Extractability
In principle, the computations done in the Store and
Verify procedures of Mirror can be seen as multiplica-
tive variants of the corresponding mechanisms of the
privately-veriﬁable POR of [34] (see Appendix B for
details on the scheme of [34]).
In particular, the
extractability arguments given in [34] transport di-
rectly to Mirror. We assume that an erasure coding
is applied to the ﬁle to ensure the recovery of ﬁle
contents from any fraction δ of the ﬁle. In particular,
we refer to [34] for additional details on the choice
of parameters (e.g., for erasure coding) such that
retrievability is ensured if a fraction δ of the ﬁle is
stored.
= du
c=1 dic, j
To show that Mirror enables the reconstruction
of the ﬁle from suﬃciently many correct responses,
we point out that given a correct response, the user
νc for
learns expressions of the form µ j = ∏(cid:30)
known exponents νc ∈ Z and known indices. Let us
assume some arbitrary ordering µ (1), µ (2), . . . on these
expressions. If suﬃciently many responses µ (i) are
known, the user can choose for any (i, j) coeﬃcients
i, j =: ˜d for a known
c(k) ∈ Z such that ∏k(cid:29)µ (k)(cid:28)c(k)
value u ∈ Z.
Recall that the order of any di, j ∈ Z∗N is a divi-
sor of 2p(cid:26)q(cid:26). If u is odd, u is co-prime to p(cid:26)q(cid:26) with
overwhelming probability and the user can simply
compute u−1 mod p(cid:26)q(cid:26) and determine di, j = ˜du−1
. On
the other hand, if u is even (i.e., u = 2 · u(cid:26)), two
cases emerge. If the order of di, j is a divisor of p(cid:26)q(cid:26),
the exponent is again co-prime to the order with
In this case, the user computes
high probability.
u−1 mod p(cid:26)q(cid:26) and checks if
contains the char-
acteristic bit pattern (see description of the Store
procedure). If this fails, this means that the order of
˜d is even and the user proceeds as follows. Observe
that the order of d2
i, j is a divisor of p(cid:26)q(cid:26). Thus, the
user ﬁrst computes (u(cid:26))−1 mod p(cid:26)q(cid:26) and then ˜d(u(cid:26))−1
.
This yields d2
i, j. As the user knows the factorization
of N, he can compute all four possible roots of d2
i, j
˜du−1
USENIX Association  
25th USENIX Security Symposium  1059
9
(e.g., using the Chinese Remainder Theorem). Due
to the characteristic pattern embedded in di, j (see
the speciﬁcation of the Store procedure), the user is
able to identify the correct di, j.4
4.2 Storage Allocation
Observe that Mirror represents in fact a proof of
retrievability over the uploaded ﬁle and all repli-
cas. This means that if a challenge involves sectors
that are not stored, Mirror ensures that the service
provider fails with high probability unless he is able
to correctly reconstruct the missing replicas. In the
following, we therefore investigate the eﬀort of a
malicious service provider in reconstructing missing
sectors. That is, we consider the scenario where the
service provider has stored the complete ﬁle5 but
only parts of some replicas.
In Mirror, the service provider needs to compute the
corresponding blinding factors in order to recompute
any missing sectors. As these are products of the form
g(k)
· h(k)
j and since these sequences are independent
i
from each other, the service provider is forced to store
values of the sequences (g(k)
j ) j separately.
Moreover, since these values are diﬀerent for the
individual replicas, knowing (or reconstructing) a
value from one sequence and one replica does not
help the service provider in deriving values of other
sequences and/or replicas.
i )i and (h(k)
tion of larger coeﬃcients, this would incur additional
(signiﬁcant) computational overhead on the provider
compared to the user. For deducing the shorter feed-
back functions fa(x), fb(x), the provider would have
to determine Zp(cid:28) respectively Zq(cid:28)—which equally re-
quire the knowledge of the factors of N.
It remains to investigate the eﬀort for reconstruct-
ing values of the LFSR sequences. Note that the
sequences used in the replicas are deﬁned by diﬀerent
independent internal states and that, for each replica,
the sequences (a(k)i) and (b(k)
j ) are independent. We
can therefore without loss of generality restrict our
analysis to one sequence (gt )t≥1. For the ease of rep-
resentation, we omit in the sequel the index (k) and
write gi = gai for the ease of representation. We say
that (cid:30)v = (v1, . . . ,v n·s) ∈ Zn·s represents a valid relation
with respect to (gt )t≥1 if:
n·s
∏
gvi
i = 1.
i=1
(12)
It follows from known facts about LFSRs that valid
relations are the only means for the service provider
to compute missing values g j from known values gi
(see Appendix D for more details).
As the provider is forced to use the feedback func-
tion deﬁned by the coeﬃcients (α∗1 , . . . ,α ∗λ∗) (see
above), the only valid relations the provider can
derive are linear combinations of:
i
,hb(k)
A crucial aspect of Mirror is that a cheating service
provider should require a signiﬁcantly higher eﬀort
compared to an honest service provider in recom-
puting missing replicas. Recall that both the user
and the provider determine the blinding factors by
computing LFSR sequences. One diﬀerence though
is that the provider has to do his computations on
values ga(k)
j ∈ Z∗N while the user can eﬃciently
compute on the exponents in a(k)
j ∈ Zq(cid:28)
directly. Observe that the provider is not able to