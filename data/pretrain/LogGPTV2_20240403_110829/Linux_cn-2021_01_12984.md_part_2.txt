    }
    g.mtx.Unlock()
  }
}
```
你想选择哪一个？不要被欺骗了，以为通道的解决方案可以使它在更复杂的情况下更具可读性和可理解性。 拆解   Teardown 是非常困难的。这种拆解若用 互斥量   mutex 来做那只是小菜一碟，但最困难的是只使用 Go 专用通道来解决。另外，如果有人回复说发送通道的通道更容易推理，我马上就是感到头疼。
重要的是，这个特殊的情况可能真的 **很容易** 解决，而通道有一些运行时的帮助，而 Go 没有提供！不幸的是，就目前的情况来看，与 Go 的 CSP 版本相比，使用传统的 同步原语   synchronization primitives 可以更好地解决很多问题，这是令人惊讶的。稍后，我们将讨论 Go 可以做些什么来简化此案例。
**练习：** 还在怀疑？ 试着让上面两种解决方案（只使用通道与只使用互斥量channel-only vs mutex-only）在一旦 `bestScore` 大于或等于 100 时，就停止向 `Players` 索要分数。继续打开你的文本编辑器。这是一个很小的玩具问题。
这里的总结是，如果你想做任何实际的事情，除了通道之外，你还会使用传统的同步原语。
#### 通道比你自己实现要慢一些
Go 如此重视 CSP 理论，我认为其中一点就是，运行时应该可以通过通道做一些杀手级的调度优化。也许通道并不总是最直接的原语，但肯定是高效且快速的，对吧？
![](/data/attachment/album/202101/05/101257f9gnh028922k909h.jpg)
正如 [Dustin Hiatt](https://twitter.com/HiattDustin) 在 [Tyler Treat’s post about Go](http://bravenewgeek.com/go-is-unapologetically-flawed-heres-why-we-use-it/) 上指出的那样，
> 
> 在幕后，通道使用锁来序列化访问并提供线程安全性。 因此，通过使用通道同步对内存的访问，你实际上就是在使用锁。 被包装在线程安全队列中的锁。 那么，与仅仅使用标准库 `sync` 包中的互斥量相比，Go 的花式锁又如何呢？ 以下数字是通过使用 Go 的内置基准测试功能，对它们的单个集合连续调用 Put 得出的。
> 
> 
> 
```
> BenchmarkSimpleSet-8 3000000 391 ns/op
> BenchmarkSimpleChannelSet-8 1000000 1699 ns/o
>
```
无缓冲通道的情况与此类似，甚至是在争用而不是串行运行的情况下执行相同的测试。
也许 Go 调度器会有所改进，但与此同时，良好的旧互斥量和条件变量是非常好、高效且快速。如果你想要提高性能，请使用久经考验的方法。
#### 通道与其他并发原语组合不佳
好的，希望我已经说服了你，有时候，你至少还会与除了通道之外的原语进行交互。标准库似乎显然更喜欢传统的同步原语而不是通道。
你猜怎么着，正确地将通道与互斥量和条件变量一起使用，其实是有一定的挑战性的。
关于通道的一个有趣的事情是，通道发送是同步的，这在 CSP 中是有很大意义的。通道发送和通道接收的目的是为了成为同步屏蔽，发送和接收应该发生在同一个虚拟时间。如果你是在执行良好的 CSP 领域，那就太好了。
![](/data/attachment/album/202101/05/101259tqqfqthyzlidzn0m.jpg)
实事求是地说，Go 通道也有多种缓冲方式。你可以分配一个固定的空间来考虑可能的缓冲，以便发送和接收是不同的事件，但缓冲区大小是有上限的。Go 并没有提供一种方法来让你拥有任意大小的缓冲区 —— 你必须提前分配缓冲区大小。 *这很好*，我在邮件列表上看到有人在争论，*因为无论如何内存都是有限的*。
What。
这是个糟糕的答案。有各种各样的理由来使用一个任意缓冲的通道。如果我们事先知道所有的事情，为什么还要使用 `malloc` 呢？
没有任意缓冲的通道意味着在 *任何* 通道上的幼稚发送可能会随时阻塞。你想在一个通道上发送，并在互斥下更新其他一些记账吗？小心！你的通道发送可能被阻塞！
```
// ...
s.mtx.Lock()
// ...
s.ch  互斥量   mutexes 、 信号量   semaphores 和 回调   callbacks ，而不使用额外的 goroutine （因为所有事件边缘都是由 API 事件触发的），那么使用通道会迫使我在资源使用中添加另一个内存分配堆栈。是的，goroutine 比线程轻得多，但更轻量并不意味着是最轻量。
正如我以前 [在一篇关于使用通道的文章的评论中争论过的](http://www.informit.com/articles/article.aspx?p=2359758#comment-2061767464)（呵呵，互联网），如果你使用回调而不是通道，你的 API *总是* 可以更通用，*总是* 更灵活，而且占用的资源也会大大减少。“总是” 是一个可怕的词，但我在这里是认真的。有证据级的东西在进行。
如果有人向你提供了一个基于回调的 API，而你需要一个通道，你可以提供一个回调，在通道上发送，开销不大，灵活性十足。
另一方面，如果有人提供了一个基于通道的 API 给你，而你需要一个回调，你必须启动一个 goroutine 来读取通道，*并且* 你必须希望当你完成读取时，没有人试图在通道上发送更多的东西，这样你就会导致阻塞的 goroutine 泄漏。
对于一个超级简单的实际例子，请查看 [context 接口](https://godoc.org/golang.org/x/net/context)（顺便说一下，它是一个非常有用的包，你应该用它来代替 [goroutine 本地存储](https://github.com/jtolds/gls)）。
```
type Context interface {
  ...
  // Done returns a channel that closes when this work unit should be canceled.
  // Done 返回一个通道，该通道在应该取消该工作单元时关闭。
  Done() <-chan struct{}
  // Err returns a non-nil error when the Done channel is closed
  // 当 Done 通道关闭时，Err 返回一个非 nil 错误
  Err() error
  ...
}
```
想象一下，你要做的只是在 `Done()` 通道触发时记录相应的错误。你该怎么办？如果你没有在通道中选择的好地方，则必须启动 goroutine 进行处理：
```
go func() {
  <-ctx.Done()
  logger.Errorf("canceled: %v", ctx.Err())
}()
```
如果 `ctx` 在不关闭返回 `Done()` 通道的情况下被垃圾回收怎么办？哎呀！这正是一个 goroutine 泄露！
现在假设我们更改了 `Done` 的签名：
```
// Done calls cb when this work unit should be canceled.
Done(cb func())
```
首先，现在日志记录非常容易。看看：`ctx.Done(func() { log.Errorf ("canceled:%v", ctx.Err()) })`。但是假设你确实需要某些选择行为。你可以这样调用它：
```
ch := make(chan struct{})
ctx.Done(func() { close(ch) })
```
瞧！通过使用回调，不会失去表现力。 `ch` 的工作方式类似于用于返回的通道 `Done()`，在日志记录的情况下，我们不需要启动整个新堆栈。我必须保留堆栈跟踪信息（如果我们的日志包倾向于使用它们）；我必须避免将其他堆栈分配和另一个 goroutine 分配给调度程序。
下次你使用通道时，问问你自己，如果你用互斥量和条件变量代替，是否可以消除一些 goroutine ？ 如果答案是肯定的，那么修改这些代码将更加有效。而且，如果你试图使用通道只是为了在集合中使用 `range` 关键字，那么我将不得不请你放下键盘，或者只是回去编写 Python 书籍。