referred to as aggressor rows, whereas their neighbor rows
are referred to as victim rows. Kim et al. [51] are the ﬁrst to
perform a large-scale study of the properties of RowHammer
bit ﬂips on DDR3 modules. They report ∼85% of the tested
modules to be vulnerable to RowHammer. Since one can cause
RowHammer bit ﬂips solely by performing memory accesses,
RowHammer quickly became a popular vector for developing
real-world attacks [5], [11]–[13], [17], [23]–[25], [27], [28],
[39], [66], [76]–[79], [81], [88], [89], [91], [92], [96], [98].
Attacks. Seaborn and Dullien [81] initially demonstrated
RowHammer attacks for compromising the Linux kernel.
(cid:22)(cid:23)(cid:18)(cid:18)(cid:17)
(cid:14)(cid:9)(cid:10)(cid:11)
(cid:6)
(cid:5)
(cid:4)
(cid:2)
(cid:1)
(cid:3)
Afterwards, other researchers exploited RowHammer to break
cloud isolation [23], [33], [54], [77], [79], [89], [96], “root”
mobile devices [91], [92], take over browsers [14], [25], [28],
and attack server applications over the network [66], [89].
All these attacks demonstrate the severity of the RowHammer
threat and the need to build effective defenses.
Defenses. Various software-based RowHammer defenses ad-
vocate for the detection of the RowHammer patterns [7],
cross-domain [16] (or more general) memory isolation [53],
[89], [92], or software-controlled ECC [23]. Unfortunately,
these defenses are complex, expensive, and/or incomplete.
As a result, they are not deployed in practice. Immediately-
deployable hardware-based defenses, such as doubling (or
even quadrupling) the refresh rate or using existing DRAM
modules with error-correction code (ECC) capability to protect
against RowHammer, are used in the ﬁeld, yet they have been
shown to be insecure [7], [23], [51].
DDR4: Towards a RowHammer-less landscape. Most prior
RowHammer research focuses on DDR3 systems [5], [11]–
[13], [17], [23]–[25], [28], [39], [51], [77]–[79], [81], [88],
[89], [91], [92], [96], [98]. While there are reports of bit ﬂips
on DDR4 chips in prior work [27], [56], [66], these results
are on earlier generations of DDR4. Through communication
with industry, we have conﬁrmation that some early-generation
DDR4 chips did not have the “TRR” mitigation enabled by
default. In order to understand the modern landscape we
test a set of 42 recent DDR4 modules against all standard
hammering patterns: (i) single-sided, which simply activates
two arbitrary (aggressor) rows in the same bank to induce
bit ﬂips in their adjacent victim rows (Figure 3a); (ii) dou-
ble-sided, which uses the same access patterns as single-sided
but the two aggressor rows are chosen to both be adjacent
to a single victim row to amplify the effect of hammering
(Figure 3b); and (iii) one-location, which activates a single
row (Figure 3c) and only applies to systems where the MC
employs a closed-row [35], [52] or adaptive [47] page policy.
(a) Single-sided
(b) Double-sided
(c) One-location
Fig. 3: Standard hammering patterns. The aggressor rows are high-
lighted in red ( ) and victim rows are highlighted in blue ( ).
As we show in Figure 4, our analysis reveals that none
of these patterns manifest any bit ﬂip on the modules we
test, even when using the exact test suites provided by prior
work [27], [51], [88]. Our results suggest that recent DDR4
chips include effective mitigations against
the best known
hammering patterns, matching claims of DRAM vendors [63],
[70]. This raises the important question: Is RowHammer a
solved problem?
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:55 UTC from IEEE Xplore.  Restrictions apply. 
749
(cid:9)(cid:8) (cid:12)
(cid:9)(cid:8) (cid:11)
(cid:9)(cid:8) (cid:10)
(cid:9)(cid:8) (cid:25)
(cid:9)(cid:8) (cid:24)
(cid:9)(cid:8) (cid:7)
(cid:9)(cid:8) (cid:9)
(cid:9)(cid:8) (cid:8)
(cid:8)
(cid:30)
(cid:5)(cid:2)(cid:29)
(cid:28)
(cid:2)(cid:20)
(cid:27)
(cid:26)
(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)
(cid:22) (cid:22) (cid:23)(cid:24)
(cid:22) (cid:31)(cid:17)(cid:32)(cid:5)(cid:6)
(cid:22) (cid:22) (cid:23)(cid:25)
(cid:33) (cid:3)(cid:6) (cid:5)(cid:31)(cid:19)(cid:16)(cid:20)(cid:2)(cid:31)(cid:3)
(cid:7)(cid:8) (cid:9)(cid:10)
(cid:7)(cid:8) (cid:9)(cid:11)
(cid:7)(cid:8) (cid:9)(cid:12)
(cid:15)(cid:16)(cid:3)(cid:17)(cid:18)(cid:16)(cid:19)(cid:20)(cid:17)(cid:21)(cid:2)(cid:3)(cid:4) (cid:22) (cid:16)(cid:20)(cid:6)
(cid:7)(cid:8) (cid:9)(cid:13)
(cid:7)(cid:8) (cid:9)(cid:14)
Fig. 4: Bit ﬂips vs. manufacturing date.3 Analysis of standard
hammering patterns [51], [81], [88] on new DDR4 modules. We
compare our results with the dataset of Tatar et al. [88] on DDR3
modules (shown in the left part of the chart).
III. OVERVIEW
We start our analysis by showing that TRR is not a single
RowHammer mitigation mechanism. Speciﬁcally, we demon-
strate that TRR is an umbrella term for different solutions
at different levels of the hardware stack. Next, we analyze
what
is arguably the best-known TRR implementation in
memory controllers, Intel pTRR [46], and show that it is not
deployed in any consumer system we tested (Section IV).
Since our results indicate that recent systems do not use
TRR implemented at the memory controller level, we analyze
TRR implementations in the DRAM chip. We examine in
detail the effectiveness of the TRR mitigations that different
manufacturers employ inside their chips. In particular, we
show that once we reach a solid understanding of the behavior
of the mitigation mechanism and build targeted access patterns
accordingly, existing in-DRAM RowHammer mitigations be-
come ineffective and one can still trigger RowHammer bit ﬂips
under standard conditions (Section V).
We observe that 1) different DRAM chips across vendors
and generations can employ different TRR implementations
and 2) the distribution of DRAM cells that are vulnerable to
RowHammer is different for every chip. Since extensive inves-
tigation of every possible memory module is not practical, we
generalize the insights gained from our investigation to build
TRRespass: a black-box fuzzer for “TRR-aware” RowHammer
analysis and exploitation (Section VI). We show how TRRes-
pass can construct a plethora of new and effective RowHam-
mer patterns on multiple TRR-protected DRAM modules.
We analyze these patterns, which we collectively refer to
as many-sided RowHammer (Section VII), and discuss the
implications of TRR-aware hammering exploitation, showing
how an attacker armed with TRRespass can mount successful
state-of-the-art RowHammer attacks on recent DDR4 systems
(Section VIII).
IV. ANALYZING THE MEMORY CONTROLLER
After the initial discovery of RowHammer [8]–[10], [26],
[51], BIOS vendors ﬁrst responded to the vulnerability by
doubling the DRAM refresh rate [6], [7], [64]. However,
increasing the refresh rate incurs high overhead as more
3Following prior work [88], we approximate the manufacturing date with
the purchase date when the former is unavailable (Table II shows the modules
for which we applied such approximation).
refresh operations consume more energy and delay actual data
transfers [51], [67]. As a consequence, manufacturers of newer
CPU generations designed and deployed more efﬁcient and
effective hardware-based RowHammer mitigations [4], [8],
[9], [15], [26], [46]—solutions that would also prevent attacks
on vulnerable DDR3 chips.
As the MC services all incoming memory requests from
CPU cores, it can efﬁciently track the requests and implement
countermeasures in case of a RowHammer attack. Speciﬁcally,
the MC can actively monitor the number of activations to
speciﬁc DRAM rows and then thwart an attack by sending
additional activations to DRAM rows that might be affected by
RowHammer. Intel’s pseudo-TRR [46] (or pTRR) is the most
prominent example of a RowHammer defense that is deployed
in the memory controller. However, while it is widely cited in
the literature [7], [27], [28], [56], [66], [81], [89], [91], very
little is actually known about the pTRR mechanism. In this
section, we aim to verify the existence of pTRR and analyze
different Intel systems to better understand the deployment and
effectiveness of pTRR.
A. TRR-compliant Memory
To protect DRAM from RowHammer using additional tar-
geted refresh operations, the MC must know the maximum
number of ACTIVATEs a row can bear before any bit in its
neighboring rows ﬂips. Since the discovery of RowHammer,
manufacturers typically store this information on the Serial
Presence Detect (SPD) chip [50] of the DRAM module and
refer to it as Maximum Activate Count (MAC). The SPD
is a small read-only memory chip containing information
about the memory module (Figure 1). The CPU reads the
the necessary parameters
SPD at boot
required to initialize the memory controller,
including the
MAC ﬁeld. DRAM modules disclosing this ﬁeld have been
available approximately since 2014 and we denote them as
TRR-compliant. We discuss further details in Appendix A.
time to gather all
The JEDEC standard speciﬁes three possible conﬁgurations
for the MAC value: (i) unlimited, if the DRAM module claims
to be RowHammer-free; (ii) untested, if the DRAM module
was not inspected after production; or (iii) a discrete value
that describes the actual number of activations the DRAM
the MAC of
module can bear (e.g., 300K). We read out
the 42 DDR4 modules we test. We ﬁnd that, regardless of
the DRAM manufacturer, most of these modules claim to
be RowHammer-free by reporting an unlimited MAC value
(Table II).
B. Intel pTRR Explained
We now take a closer look at the only publicly adver-
tised MC-based solution for Intel CPUs: pseudo-TRR (or
pTRR) [46]. Introduced in the Ivy Bridge EP server fam-
ily [46], pTRR refreshes victim rows when the number of
row activations issued to the DRAM exceeds the MAC value—
according to Intel’s public documentation [46]. Unfortunately,
this solution is not applicable to non-TRR-compliant modules
(i.e., those without a MAC value or MAC set to untested). As a
result, when such modules are employed, the system defaults
to double refresh mode.
Observing pTRR. We analyze the only system ofﬁcially
reported to support pTRR: Xeon E5-2620 v2, with DDR3
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:55 UTC from IEEE Xplore.  Restrictions apply. 
750
memory [46]. We disable write-protection [41], [42] on the
SPD of a DDR3 module and we perform the following two
experiments.
1(cid:2) We overwrite the MAC value setting to two conﬁg-
urations: untested, simulating a non-TRR-compliant DRAM
module, and unlimited. As mentioned above, when non-TRR-
compliant memory is employed, the system should resort to
double refresh rate, making it possible to detect the mitigation
via frequency analysis of the access latency of uncached
memory reads [69]. Indeed, we can observe that with MAC
value set to untested, the system resorts to double refresh
(Figure 5).
(cid:18)(cid:19)(cid:20) (cid:21)(cid:8)
(cid:17)
(cid:2)
(cid:3)
(cid:16)
(cid:27)
(cid:26)
(cid:25)
(cid:15)
(cid:24)
(cid:23)
(cid:22)
(cid:10)(cid:1)(cid:1)
(cid:9)(cid:1)(cid:1)
(cid:8) (cid:1)(cid:1)
(cid:5)(cid:1)(cid:1)
(cid:1)(cid:2)(cid:1)
(cid:3)(cid:2)(cid:4)
(cid:5)(cid:6)(cid:2)(cid:7)
(cid:8) (cid:9)(cid:2)(cid:10)
(cid:12) (cid:13)(cid:14) (cid:15)(cid:16)(cid:1)(cid:2)(cid:17)
(cid:9)(cid:5)(cid:2)(cid:8)
(cid:9)(cid:11) (cid:2)(cid:1)
Fig. 5: Intel pTRR - Frequency of REFRESH commands. Uncached
memory access latency with MAC value set to Unlimited and Untested
on Xeon E5-2620 v2. The peaks reveal the delay introduced by the
REFRESH command. We observe twice as many peaks when the MAC
value is set to Untested.
2(cid:2) We overwrite the MAC value to different discrete values,
expecting to observe a difference in the number of bit ﬂips.
In the leftmost stack of Figure 6, we show the result of this
experiment when hammering the same chunk of memory with
MAC value set to 400K or to unlimited. We observe that the
number of bit ﬂips drastically decreases when pTRR is enabled
(i.e., MAC value set to 400K). Additionally (not shown in
Figure 6), we discover that when setting the MAC value to the
minimum value deﬁned in the DDR3 speciﬁcation [41] (i.e.,
200K), the system treats the module as a non-TRR-compliant
module; that is, it enables double refresh. We do not analyze
the effectiveness of pTRR in mitigating RowHammerbit ﬂips
in this paper. Lipp et al. [66] report bit ﬂips on a pTRR-
enabled system, and operating at increased refresh rate (i.e.,
double refresh rate) is known to be ineffective [7], [23], [51]
at protecting against RowHammer.
(cid:14) (cid:15)(cid:16)(cid:17) (cid:1)(cid:2)(cid:2)(cid:3)
(cid:14) (cid:15)(cid:16)(cid:17) (cid:9)(cid:10)(cid:11)(cid:12)(cid:13) (cid:12)(cid:14)(cid:6)(cid:15)
(cid:24)
(cid:22)(cid:19)(cid:23)
(cid:21)
(cid:19)(cid:20)
(cid:18)
(cid:26)
(cid:8)
(cid:7)
(cid:6)
(cid:5)
(cid:25)(cid:4)
(cid:1)(cid:2)(cid:2)
(cid:1)(cid:2)(cid:3)(cid:1)
(cid:1)(cid:2)(cid:3)(cid:4)
(cid:1)(cid:2)(cid:3)(cid:5)
(cid:6)(cid:7)(cid:8) (cid:9) (cid:10)(cid:11) (cid:3)
(cid:4)(cid:12) (cid:4)(cid:2) (cid:13)(cid:4)
(cid:16)(cid:8) (cid:27)(cid:7) (cid:19)(cid:28)(cid:3)
(cid:29)(cid:28)(cid:2)(cid:2)(cid:30)
Fig. 6: Intel pTRR - Bit ﬂips observed with different MAC values.
Frequency of observed bit ﬂips for different MAC conﬁgurations.
Comparison between a system employing pTRR (Xeon E5-2620 v2)
and a system with no MC-based RowHammer mitigation (Core i7-
8700K).
pTRR has limited deployment. We run the two experiments
for analyzing pTRR on 6 other Intel CPUs from different
architecture families that are descendants of Ivy Bridge—both
server and consumer lines. Surprisingly, the ﬁrst experiment
1(cid:2) shows that, when the MAC value is set to untested, the
memory controller of each of these 6 CPUs still refreshes
the DRAM with the default (not double) refresh rate. This
observation shows that no RowHammer mitigation is present
at the memory controller level in these CPUs. We corroborate
2(cid:2)
this hypothesis by carrying out the second experiment
where we measure the number of bit ﬂips as we vary the
MAC value. We use the new RowHammer patterns we present
in Section VI for the CPUs that support DDR4. In contrast
to Xeon E5-2620 v2 server-line CPU, which is reported to
support pTRR [46], the second experiment on consumer-line
CPUs does not identify a different number of bit ﬂips for
different MAC values. In the rightmost stack of Figure 6,
we show the results for the Intel Core i7-8700K consumer-
line CPU as an example to illustrate the difference between
any of these consumer systems and a pTRR-enabled system.
This experiment conﬁrms that pTRR is in fact not present
in customer-line CPUs that we test. We list the deployment
of MC-based RowHammer mitigations in both server- and
consumer-line CPUs in Table I.
TABLE I: Memory controller defenses. Defenses detected in our
experiments on Intel CPUs starting from the Ivy Bridge family.
CPU
Family
Year
DRAM
generation Defense
Broadwell
Ivy Bridge EP
Haswell
2016
2013
2013
Coffee Lake R 2018
2017
Coffee Lake
2017
Kaby Lake
Broadwell
2015
REF×2
pTRR
DDR4
DDR3
DDR3
DDR4
DDR4
DDR4
DDR3
Server Line
Xeon E5-2620 v4
Xeon E5-2620 v2
Xeon E3-1270 v3
Consumer Line
Core i9-9900K
Core i7-8700K