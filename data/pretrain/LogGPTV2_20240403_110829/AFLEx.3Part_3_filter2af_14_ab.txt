你应该读读`docs/README`。它的篇幅很短。如果你真的不想读它，那此篇文档将指导你如何开始你的模糊测试之旅:
  1. 用`make`编译`AFL`。 如果您构建失败，请参阅`docs/INSTALL`中的提示修复问题。
  2. 找一个或者编写一个合理且高效简单的程序，该程序可以从文件流或标准输入流`STDIN`中获取数据，它需要运行一个有测试价值的逻辑，然后干净地退出。如果您想测试网络服务逻辑，请将其修改为在前台运行并从`STDIN`中读取数据包。 当此程序需要使用一个带校验和的数据格式时，也请注释掉校验和的验证代码。遇到错误时，程序必须以标准形式崩溃。 请一定要注意程序中有关自定义的`SIGSEGV`或`SIGABRT`处理程序和后台进程。(译者注：此处的后台进程应当代指守护进程)若您想寻找一个不会导致程序崩溃的漏洞或缺陷，请参阅`docs/README`中的第`11`节以获取提示。[原译者注：可以自己写一个简单，有明显`bug`的程序测试。]
  3. 使用`afl-gcc`编译要进行`fuzz`的程序和库。 常用的命令是： 
        CC=/path/to/afl-gcc CXX=/path/to/afl-g++ ./configure --disable-shared
    make clean all
如果程序构建失败，请联系PI:EMAIL。[原译者注：注意`--disable-shared`]
  4. 获取一个对程序有意义的小而有效的输入文件。 在对使用语法冗长(`SQL`,`HTTP`等)的文本作为输入的程序进行模糊处理时，也请按照`dictionaries/README.dictionaries`中的描述创建样例输入字典。
  5. 如果程序从`stdin`读取数据，则按以下示例代码运行`afl-fuzz`： 
        ./afl-fuzz -i testcase_dir -o findings_dir -- /path/to/tested/program [...program's cmdline...]
如果程序从文件中获取输入，可以在程序的命令行的末尾输入`@@`，此时`AFL`会为你自动生成一个文件名。
  6. 监视`GUI`中显示的内容，关于这些内容的解释可以通过`docs/status_screen.txt`查看。
以上步骤都完成之后，你可以坐好，放松，喝杯茶，如果时间允许，您可以试着浏览以下文件：
  * `docs/README` ：对AFL的概述
  * `docs/perf_tips.txt`：关于如何快速模糊测试的简单提示
  * `docs/status_screen.txt`：UI显示的含义解释
  * `docs/parallel_fuzzing.txt`：关于在多核上运行AFL的建议
## 3\. status_screen.txt(GUI手册)
本文档提供了状态监控的概述，以及对任何警告或`UI`中显示的红色文本进行故障排除的提示。 有关一般说明手册，请参见自述文件。
###  3.0 多彩输出
状态监控和错误消息都使用了不用的颜色使内容保持可读性并试图通过此吸引您对重要细节的注意力。 例如，红色的信息几乎总是表示“请参考相关文档” 🙂
不幸的是，只有在您的终端使用传统的`Unix`配色方案(黑色背景上的白色文本)时或接近此方案的情况下，`UI`才能正确呈现。
如果您使用的是其他系统下的终端程序，则可能需要更改为以下设置，例如：
  * 对于`GNOME`终端，请转到`Edit`>`Profile preferences`，选择`colors`选项卡，然后从内置方案列表中选择`white on black`。
  * 对于`MacOS X Terminal`应用程序，通过`Shell`> `New Window`菜单使用`Pro`方案打开一个新窗口（或将`Pro`设置为默认设置）。
如果您确实喜欢您终端当前的颜色，则可以编辑`config.h`以注释掉`USE_COLORS`，然后执行`make clean all`。
我不知道有任何其他简单的方法使这工作不引起其他副作用——抱歉。(>_<)
好了，接下来让我们谈谈屏幕上的实际内容。
### 3.1 Process timing(`fuzz`时间)
    +----------------------------------------------------+
    |        run time : 0 days, 8 hrs, 32 min, 43 sec    |
    |   last new path : 0 days, 0 hrs, 6 min, 40 sec     |
    | last uniq crash : none seen yet                    |
    |  last uniq hang : 0 days, 1 hrs, 24 min, 32 sec    |
    +----------------------------------------------------+
此部分的内容很明显，它显示了`fuzzer`已经运行了多长时间，以及自从最近一次新发现以来已经花费了多少时间。每个`fuzzer`的发现分为路径(发现了一个可以触发新执行模式/分支的输入用例)、崩溃和挂起。
测试的时间没有硬性标准，但是大多数测试工作要持续数天或数周。
实际上，对于一个比较复杂的项目，测试的第一阶段可能需要一天左右的时间。有些测试甚至要持续一个月或更久。
尽管我们不用担心`fuzzer`的运行时间过长，但是有一种重要的情况要提防：如果`fuzzer`在启动后的几分钟内没有找到新路径，则可能是您没有正确调用目标待测文件，这表明它可能永远也无法解析我们要喂给它的输入文件。另一个可能的解释是，默认内存限制(`-m`)过于严格，这使得程序未能尽早分配缓冲区后退出。
当然也有可能是输入文件是无效的以致于始此输入终无法通过待测程序的基本标头检查。
如果一段时间内没有新路径出现，您将会看到一个红色的大警告:-)
### 3.2 Overall results(`fuzz`计数器)
    +-----------------------+
    |  cycles done : 0      |
    |  total paths : 2095   |
    | uniq crashes : 0      |
    |   uniq hangs : 19     |
    +-----------------------+
`cycles
done`表示到目前为止已完成的样例输入队列完成次数——即`fuzzer`遍历到目前为止发现的所有有趣样例输入对其进行测试并循环回到最开始的次数。每个模糊测试实例都应至少完成一个周期。
并且理想情况下，运行时间应该比这更长，即，运行更多的周期数。
如前所述，第一次周期完成可能需要一天或更长的时间，因此您请坐下来放松喝喝茶。
如果您想立即获得更广泛的结果，且您能接受代码覆盖率下降，请尝试使用`-d`选项，这将跳过确定性检查的`fuzz`步骤，它可以为您提供更熟悉便捷的体验。
但是，它在一些方面不如标准模式。
为了帮助您得知应该在何时按下`Ctrl-C`以中止测试，`cycle
counter`也使用了多彩输出方案。它将在第一次周期完成时以洋红色显示，如果在随后的循环中仍有新发现，则变为黄色，然后在循环结束时变为蓝色。最终，在较长时间没有任何新发现后后，变成绿色，表示您可以在此时中止。
此部分中的其余字段应该非常明显——到目前为止，已经发现的所有测试用例(路径)以及异常的数目。
如自述文件中所述，可以通过浏览输出目录来实时分析路径、崩溃和挂起。
### 3.3 Cycle progress(`fuzz`进度)
    +-------------------------------------+
    |  now processing : 1296 (61.86%)     |
    | paths timed out : 0 (0.00%)         |
    +-------------------------------------+
此部分告诉您`fuzzer`已完成了多少测试进度，当此进度为`100%`时，代表完成了一个`3.2`中所述的周期。此外此部分还会告诉您`fuzzer`因为持续超时而决定丢弃的样例输入数量。
有时在第一行中显示的`*`后缀表示当前处理的路径不是`favored`的(此属性将稍后在第`3.6`中讨论）
如果您认为`fuzzer`的进度太慢，请参阅本文档第`2`节中有关`-d`选项的注释。
###  3.4 Map coverage(代码覆盖率)
(译者注：若要理解此部分内容，那么需要先明确，`AFL`将为每个代码块生成一个随机数，作为其“位置”的记录。随后，对分支处的入口位置和结束目标位置进行异或，并将异或的结果作为该分支的`key`，用于保存每个分支的执行次数。用于保存执行次数的实际上是一个哈希表，大小为`MAP_SIZE=64K`，当然会存在碰撞的问题；但根据`AFL`文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的)
    +--------------------------------------+
    |    map density : 10.15% / 29.07%     |
    | count coverage : 4.03 bits/tuple     |
    +--------------------------------------+
此部分提供了关于`fuzzer`代码覆盖率的相关知识。
框中的第一行告诉您，`fuzzer`已经命中的分支数量占总哈希表容量(`MAP_SIZE`)的比例。
左边的数字描述了当前输入样例的覆盖率，右边的是整个输入语料库的覆盖率。
请注意以下极端情况：
  * 若出现一个低于200的数字(而非比例值)，将表明目标程序出现了以下三种情况之一： 
    * 目标程序过于简单
    * 目标程序没有正确的被检测(例如目标程序被链接到了非检测目标库文件的副本)
    * 目标程序在接收到测试用例后过早的退出了
此时，数据将被标记为粉红色以告知您发生了异常情况
  * 若您的目标程序是一个使用了大量的模板生成代码的非常复杂的程序，那么第一行的数据可能超过`70%`(尽管发生的可能性很低)。因为过高的分支密度将使`fuzzer`可靠地识别到新程序状态变的更加困难(译者注：当比例过高将极大地增加哈希表碰撞的概率，读者可以去了解哈希表碰撞的相关概念以进一步了解)，所以我建议使用`AFL_INST_RATIO = 10`左右的设置重新编译二进制文件然后重新启动模糊测试(请参阅`env_variables.txt`获取更多信息)。`fuzzer`将以红色标记高百分比的覆盖率。 但是，除非您正在对一个拥有非常多分支的程序进行测试(例如，`v8`、`perl`、`ffmpeg`)，您可能永远也看不到此红色标记。
此部分的第二行为某次输入用例中映射碰撞的计数。 本质上，如果对于我们尝试的所有输入样例，每个采用的分支始终采用固定的次数，则该读数将为`1.00`。
当我们设法触发每个分支的其他命中计数时，指针将开始向`8.00`移动(`8`位映射命中的每个位)，但可能永远不会达到极限。
那么综合这部分的两个值可用于比较针对同一个待测文件启动的不同`fuzzer`实例的覆盖率。
[原译者注：不大明白`map coverage`]
###  3.5 Stage progress(样本变异状态)
    +-------------------------------------+
    |  now trying : interest 32/8         |
    | stage execs : 3996/34.4k (11.62%)   |
    | total execs : 27.4M                 |
    |  exec speed : 891.7/sec             |
    +-------------------------------------+
这部分让你深入了解`fuzzer`现在对样例输入做什么。第一行告诉你当前的变异阶段，合法的取值可以是:
  * `calibration`(初始阶段)：预测试阶段，在该阶段检查执行路径以检测异常，确定基线执行速度等。 只要有新发现，就会非常简洁地继续执行。