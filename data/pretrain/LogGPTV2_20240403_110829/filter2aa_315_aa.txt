©	
  2012	
  The	
  MITRE	
  Corpora2on.	
  All	
  rights	
  reserved.	
No	
  More	
  Hooks:	
Trustworthy	
  Detec2on	
  of	
Code	
  Integrity	
  AGacks	
Xeno	
  Kovah,	
  Corey	
  Kallenberg,	
Chris	
  Weathers,	
  Amy	
  Herzog,	
MaGhew	
  Albin,	
  John	
  BuGerworth	
© 2012 The MITRE Corporation. All rights reserved. 
Security	
  SoPware	
Malicious	
  SoPware	
Dear	
  everyone:	
This	
  system	
  is	
Infected!	
2	
© 2012 The MITRE Corporation. All rights reserved. 
Security	
  SoPware	
Malicious	
  SoPware	
I	
  don't	
  like	
  you.	
You	
  are	
annoying.	
3	
© 2012 The MITRE Corporation. All rights reserved. 
Security	
  SoPware	
Malicious	
  SoPware	
I	
  don't	
  like	
  you.	
You	
  are	
annoying.	
*scribble*	
*scribble*	
*scribble*	
4	
© 2012 The MITRE Corporation. All rights reserved. 
Security	
  SoPware	
Malicious	
  SoPware	
Dear	
  everyone:	
This	
  system	
  is	
A-­‐OK!	
5	
© 2012 The MITRE Corporation. All rights reserved. 
Security	
  SoPware	
Malicious	
  SoPware	
That's	
  what	
  I'm	
talkin'	
  'bout	
(Bruce)	
  Willis!	
6	
© 2012 The MITRE Corporation. All rights reserved. 
Security	
  SoPware	
Malicious	
  SoPware	
Checkmate	
*scan*	
*scan*	
*scan*	
Security	
SoPware	
  is	
compromised!	
7	
© 2012 The MITRE Corporation. All rights reserved. 
Security	
  SoPware	
Malicious	
  SoPware	
Checkmate	
You	
  are	
similarly	
annoying!	
*scribble*	
*scribble*	
*scribble*	
8	
© 2012 The MITRE Corporation. All rights reserved. 
Security	
  SoPware	
is	
  OK.	
Security	
  SoPware	
Malicious	
  SoPware	
Checkmate	
*scan*	
*scan*	
*scan*	
Don't	
  believe	
  me!
I'm	
  compromised!	
9	
© 2012 The MITRE Corporation. All rights reserved. 
Security	
  SoPware	
Malicious	
  SoPware	
Checkmate	
Are	
  you	
  kidding	
me?	
  F*&@^	
  self-­‐
checking	
  tricorder…
This	
  is	
  ridiculous!	
*scribble*	
*scribble*	
*scribble*	
10	
© 2012 The MITRE Corporation. All rights reserved. 
Security	
  SoPware	
is	
  OK.	
Security	
  SoPware	
Malicious	
  SoPware	
Checkmate	
I…am…O…K…	
11	
© 2012 The MITRE Corporation. All rights reserved. 
Timing-­‐Based	
  AGesta2on	
(aka	
  SoPware-­‐Based	
  AGesta2on)	
•  Based	
  on	
  concept	
  of	
  Pioneer	
  by	
  Seshadri	
  et	
  al.	
•  Assump2ons	
–  You	
  can	
  know	
  the	
  client	
  hardware	
  proﬁle	
–  Your	
  self-­‐check	
  is	
  the	
  most	
  op2mized	
  implementa2on	
•  Implemented	
  from	
  scratch,	
  independently	
conﬁrmed	
  previous	
  results.	
•  Source	
  code	
  is	
  released	
  so	
  we	
  can	
  work	
  with	
other	
  researches	
  to	
  validate/improve	
  it.	
•  hGp://code.google.com/p/2ming-­‐aGesta2on	
12	
© 2012 The MITRE Corporation. All rights reserved. 
NiGy	
  GriGy	
  How	
  Does	
  it	
  Work?	
•  The	
  self-­‐check	
  is	
  hand	
  coded	
  asm	
  to	
  try	
  to	
build	
  a	
  2ming	
  side-­‐channel	
  into	
  its	
  execu2on	
•  The	
  system	
  measurements	
  are	
  things	
  like	
  you	
would	
  ﬁne	
  in	
  any	
  memory	
  integrity	
  checking	
soPware	
  like	
  MS's	
  PatchGuard,	
  Mandiant's	
MIR,	
  or	
  HBGary's	
  Ac2ve	
  Defense.	
•  We're	
  going	
  to	
  focus	
  on	
  the	
  self-­‐check,	
because	
  that's	
  what	
  we	
  have	
  that	
  others	
  don't	
13	
© 2012 The MITRE Corporation. All rights reserved. 
First	
  principles	
  1	
•  "I	
  want	
  to	
  know	
  that	
  my	
  code	
  isn't	
  changed	
  while	
it's	
  running"	
•  Malware	
  does	
  this	
  by	
  self-­‐checksumming	
  or	
  even	
self-­‐2ming	
  with	
  an	
  rdtsc	
  instruc2on.	
  This	
commonly	
  detects	
  hardware	
  and	
  soPware	
breakpoints.	
•  Problem:	
  An	
  aGacker	
  (from	
  malware's	
perspec2ve	
  the	
  analyst,	
  from	
  our	
  perspec2ve,	
malware)	
  can	
  just	
  force	
  the	
  check	
  to	
  always	
succeed.	
14	
© 2012 The MITRE Corporation. All rights reserved. 
Original	
  code	
int	
  main(){	
foo	
  =	
  Selfcheck();	
if(foo	
  ==	
  0x12341234){	
DoSomething();	
return	
  SUCCESS;	
}	
else{	
return	
  FAILURE;	
}	
}	
15	
© 2012 The MITRE Corporation. All rights reserved. 
AGacker	
  rewrites	
  code	
int	
  main(){	
foo	
  =	
  Selfcheck();	
  foo	
  =	
  0x12341234;	
if(foo	
  ==	
  0x12341234){	
DoSomething();	
return	
  SUCCESS;	
}	
else{	
return	
  FAILURE;	
}	
}	
16	
© 2012 The MITRE Corporation. All rights reserved. 
First	
  principles	
  2	
•  At	
  this	
  point	
  basically	
  everyone	
  gives	
  up,	
  and	
just	
  goes	
  with	
  code	
  obfusca2on.	
•  We	
  go	
  with	
– 1)	
  making	
  the	
  self-­‐check	
  a	
  func2on	
  of	
  a	
  nonce	
– 2)	
  controlling	
  the	
  execu2on	
  environment	
  to	
  yield	
highly	
  predictable	
  run2me	
– 3)	
  just	
  let	
  the	
  code	
  run,	
  and	
  evaluate	
  whether	
  it	
was	
  tampered	
  with	
  back	
  at	
  a	
  remote	
  server,	
based	
  on	
  the	
  self-­‐checksum	
  AND	
  the	
  run2me	
17	
© 2012 The MITRE Corporation. All rights reserved. 
New	
  outline	
  for	
  code	
int	
  main(){	
  int	
  selfchecksum[6];	
  nonce	
  =	
  WaitForMeasurementRequestFromVeriﬁer();	
Selfcheck(&selfchecksum,nonce);	
SendResultsToVeriﬁer(selfchecksum,nonce);	
results	
  =	
  DoSomething();	
SendResultsToVeriﬁer(results);	
return	
  SUCCESS;	
}	
18	
© 2012 The MITRE Corporation. All rights reserved. 
Thoughts	
  on	
  the	
  nonce	
•  No	
  single	
  correct	
  value	
  that	
  the	
  aGacker	
  can	
send-­‐back	
  to	
  indicate	
  the	
  code	
  is	
  intact	
•  Large	
  nonce	
  and/or	
  self-­‐checksum	
  size	
reduces	
  probability	
  of	
  encountering	
precomputa2on	
  aGacks	
– AGacker	
  needs	
  to	
  store	
  2^32*192	
  bits	
  (96GB)	
  in	
RAM	
  for	
  a	
  32	
  bit	
  precomputa2on	
  or	
  2^64*384	
  bits	
(768	
  Zetabytes)	
  for	
  our	
  64	
  bit	
  implementa2on	
19	
© 2012 The MITRE Corporation. All rights reserved. 
What	
  should	
  we	
  actually	
  read	
  to	
indicate	
  the	
  code	
  is	
  unmodiﬁed?	
•  A	
  pointer	
  which	
  points	
  at	
  our	
  own	
  code	
–  We	
  will	
  call	
  this	
  DP	
  for	
  data	
  pointer	
–  This	
  indicates	
  the	
  memory	
  range	
  where	
  our	
  code	
  is	
execu2ng	
  from.	
  Original	
  Pioneer	
  assumed	
  it	
  was	
  in	
  a	
  ﬁxed	
loca2on	
  that	
  we	
  could	
  know,	
  but	
  on	
  Widows,	
  no	
  such	
  luck	
(ASLR	
  &	
  faux	
  ASLR)	
•  Our	
  own	
  code	
  bytes	
–  We	
  will	
  call	
  this	
  *DP	
  (C	
  syntax)	
  or	
  [DP]	
  (asm	
  syntax)	
  to	
indicate	
  we're	
  dereferencing	
  the	
  data	
  pointer	
•  Our	
  instruc2on	
  pointer	
  (EIP)	
–  This	
  also	
  indicates	
  the	
  memory	
  range	
  where	
  our	
  code	
  is	
execu2ng	
  from.	
  Should	
  generally	
  agree	
  with	
  DP.	
20	
© 2012 The MITRE Corporation. All rights reserved. 
Selfcheck()	
  .01	
void	
  Selfcheck(int	
  *	
  selfchecksum,	
  int	
  nonce){	
  int	
  *	
  DP	
  =	
  GetMyCodeStart();	
  int	
  *	
  end	
  =	
  GetMyCodeEnd();	
  while(DP	
  <	
  end){	
  selfchecksum[0]	
  +=	
  nonce;	
  selfchecksum[1]	
  +=	
  *DP;	
  __asm{	
  call	
  $+5;	
  pop	
  eax;	
  mov	
  EIP,	
  eax;}	
  selfchecksum[2]	
  +=	
  EIP;	
  mix(selfchecksum);	
  DP++;	
  }	
}	
21	
© 2012 The MITRE Corporation. All rights reserved. 
Problems	
  with	
  Selfcheck()	
  .01	
•  It's	
  parallelizable.	
  An	
  aGacker	
  can	
  add	
compute	
  power	
  from	
  the	
  GPU	
  or	
  any	
  other	
processing	
  we're	
  not	
  using	
  to	
  counteract	
  any	
2me	
  he	
  may	
  incur	