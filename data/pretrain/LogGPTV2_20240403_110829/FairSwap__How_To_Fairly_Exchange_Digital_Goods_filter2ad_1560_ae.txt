1.6
1.4
1.2
1
Optimistic costs
Pessimistic costs
102
103
104
File Chunk Size λ [Byte]
]
D
S
U
[
s
t
s
o
C
s
a
G
14
12
10
8
6
4
2
0
Figure 7: Costs and encoding size for diﬀerent values of λ
some input. The costs for the complain originate from the length of the concise proof of misbehavior
π, which needs to be sent to the contract and evaluated on-chain:
|π| = |zin1| + |zin1| + |zout| + |ρin| + |ρout|
≤ 2µ × λ + µ + 2δ × µ
Figure 7 illustrates that even for very large ﬁle chunk sizes, the costs for optimistic execution is
close to constant around 1.73 USD, where the cost for pessimistic execution increases linearly in the
length of the ﬁle chunks. We highlight that using diﬀerent cryptocurrencies can decrease the price
for execution even further. In Ethereum classic6, a well known fork of the Ethereum blockchain,
the cost for optimistic execution is only fractions of cents.
The heavy computation of the protocol is executed in round 1 and 3, by both the sender and
the receiver in the two algorithms Extract and Encode. We will only take a closer look at the
performance of the sender, since the receiver will perform almost identical computations only in
reverse order. To encode ﬁle x = (x1, . . . , xn), S needs to ﬁrst generate M = Mtree(x) and store
all intermediate hashes. The result is n − 1 elements of size µ. Next, he encrypts each ﬁle chunk
(which requires n × λ hashes in total) and each hash from the Merkle tree M (n − 1 hashes). It
remains to compute the Merkle root of the combined encoding rz = Mtree(z1, . . . , zm), for which
he needs to hash 2m Elements. Therefore we get the following estimates:
|z| = |x| + (n − 1)32 Bytes = n × λ × 32 Bytes
Runtime of Extract = n × λ × O(H)
6https://ethereumclassic.github.io/
22
The size of z therefore can be used as an indicator for the performance of the algorithm Extract
and additionally aﬀects the communication complexity, since it needs to be transfered in the ﬁrst
protocol message which is the longest message in the protocol. We did not optimize the imple-
mentation of the algorithms Encode, Extract for runtime but it shall be noted that we reach an
encoding throughput of approximately 2 MB per second in a straightforward node.js implementa-
tion running on single core of a 2.67 GHz Intel©Core i7 CPU with 8 GB of RAM. Clearly, these
estimations indicate that the performance of the protocol is optimal for small λ. Figure 7 illustrates
his trade-oﬀ between the costs of the protocol and its performance, measured in the overhead of
encoding size in comparison to ﬁle length
|z|
|x| .
The protocol can be executed in 4 rounds, where each round requires sending a message to
the blockchain. The round ends, when the message is accepted by the miners and included in a
block. Cryptocurrencies ensure, that a correct message (with suﬃcient fees) is eventually included
in the blockchain, but this process might take some time. We denote this maximal round duration
with ∆, therefore the judge contract will have timeouts ∆ to measure whether some message has
been sent or not. The exact value of this parameters is chosen by the parties and depend on the
congestion of the blockchain, the amount of fees, they are willing to pay, their availability and the
number of blocks they require to succeed a transaction in order to consider it valid. We note that
the minimum duration of the protocol is 4 rounds, which in Ethereum can be executed in only a
few minutes, as long both parties agree.
5.3 Repeated fair exchange
For reasonably small values of λ the main cost for running fair ﬁle sale consists of the deployment
costs. Whenever two parties want to repeatedly run protocol Π, they can save costs by slightly
modifying the contract to decouple deployment of code and the initialization function. This allows
them to re-use the same contract for repeated executions of ﬁle sale. Deploying such a modiﬁed
contract costs 0.20 USD more than the same step in the standalone ﬁle sale, but every following
repetition of the protocol re-using same contract only costs 1.60 USD to execute. But even 1.60
USD is a high price to pay for fees in e.g. the distributed ﬁle sharing case, where these fees would
have to be payed for every ﬁle transfer. Another problem is that the execution of the protocol
requires four slow blockchain interactions. For distributed ﬁle sharing this means the execution of
the protocol will probably last at least a few minutes.
To minimize gas costs and conﬁrmation time for repeated execution, we propose to run the judge
contract described above oﬀ-chain in a so called state-channel. State channels are an extension of
payment channels and allow users to execute arbitrary smart contracts oﬀ-chain without requiring
interaction with the blockchain. Constructions for state channels have been proposed in earlier
works, e.g., in [36, 20]. Hence, we only describe here how they can be used for our application, and
provide a more technical speciﬁcation in Appendix D. In our basic system, the seller and the buyer
open a state channel by blocking money in a contract such that the money can only be payed out
(before some timeout) if both parties agree or by forcing the execution of the judge contract. Since
the parties want to execute multiple ﬁle sales, they freeze enough money in the channel.
Now the users can run multiple fair exchange executions without costly and time consuming
interactions with the blockchain.
If however at some point one of the parties starts to behave
maliciously (e.g., a sender does not provide the secret key for the i-th repetition of the protocol)
the parties can always execute the contract for this repetition on-chain and settle their disagreement
in a fair way. That is, the contract is executed on the blockchain and the funds are distributed to
23
the parties within some predeﬁned time.
The above approach suﬀers from the drawback that when S and R want to run a fair exchange,
they ﬁrst need to open a state channel between each other on the blockchain. When a system
has many senders and receivers that moreover may take diﬀerent roles during the lifetime of the
system, this would result into large overheads because opening a state channel requires a costly
interaction with the blockchain. To minimize these costs, we may integrate our system into a state
channel network. A state channel network allows to compose multiple state channels into new
longer state channels without the need to interact with the blockchain. For illustration, suppose
that Alice has a state channel opened with Bob, and Bob has a state channel opened wit Carol.
In a state channel network, Alice then also has an “implicit” state channel with Carol, which is
executed via the intermediate Bob. Notice that using the state channel between Alice and Carol
does not require any on-chain transactions. Using state channel networks, a sender Alice may thus
execute a fair exchange with Carol instantaneously via the intermediate Bob without the need to
explicitly open a state channel with Carol on the blockchain. We notice however that state channel
networks are currently only under development and no fully functioning system has been deployed
yet. We leave it as an interesting direction for future research to integrate fair ﬁle sale within a
state channel network.
5.4 Fault Attribution and Denial of Service Attacks
As soon as the judge contract is active, S can abort the protocol execution without being penalized.
Note that in the simpliﬁed version of the protocol which we considered so far, this does not hold
for sending a false witness. This allows the sender to force R to freeze coins. The sender S could
initiate the protocol without knowing the actual ﬁle which is sold. This cannot be prevented
because R is only allowed to learn the ﬁle at the end of the protocol, when the key is revealed.
But he needs to freeze his money in the beginning. A solution for this problem is to penalize S
when he misbehaves. This can be achieved by letting S also freeze some money for the execution
of the contract. If he behaves correctly (i.e. follows the protocol description and provides a correct
circuit) the money will be send back to him but if he does not, the money is instead sent to R.
This means the contract itself allows fault attribution and compensates attacked parties.
But even when penalties are added, we face the problem that R could run a Denial of Service
(DoS) attack towards S. This way DoS attacks cannot be prevented but it will make them more
expensive and the attacked parties will be compensated. The receiver can request multiple ﬁles from
senders without then accepting the execution of the contract, which forces the sender to (a) deploy
and initialize the contract on the blockchain and (b) force him to compute z = Extract(φ(x)). The
ﬁnancial risk of the sender can be mitigated by changing the protocol to let R deploy the contract
and thus pay the fees but this only shifts the risk to R. In order to mitigate the risk of attack (b),
we propose that the sender precomputes z and uses the same encoding/key combination for all
protocol executions (as long as the key was not revealed). Therefore if R repeatedly aborts after
the ﬁrst round, S only has the overhead of computing z once.
6 Conclusion
In this paper we presented a protocol, which allows fair sale of a witness where a judge smart
contract veriﬁes concise proofs of misbehavior. These proofs are short statements which a re-
24
ceiver generates if the delivered witness does not satisfy a circuit φ. We present three algorithms,
Encode, Extract and Judge where Encode is used by the sender S to generate an encoding of x
and each step of the evaluation of the circuit φ(x). Using this encoding and the decryption key
k, the receiver can run Extract to learn the witness x. If this witness does not satisfy the circuit,
namely φ(x) (cid:54)= 1, Extract outputs a concise proof of misbehavior, which can be sent to the judge
contract. We show that the veriﬁcation of this proof reveals if φ(x) (cid:54)= 1, and the contract uses
this information to pay out the money correctly. We argue why our protocol satisﬁes sender and
receiver fairness and terminates after at most 5 rounds. In the appendix we provide a formal proof
of security in the GUC model and show that our construction securely realizes the ideal function-
ality for fair exchange F L
cfe. We provide an implementation of the judge contracts and show that
our protocol works eﬃciently for large ﬁles and can be executed at low costs.
References
[1] Eytan Adar and Bernardo A Huberman. Free riding on gnutella. First monday, 5(10), 2000.
[2] Ian Allison. Ethereum’s vitalik buterin explains how state channels address privacy and scal-
ability, July 2016. https://tinyurl.com/n6pggct.
[3] Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and Lukasz Mazurek. Secure
multiparty computations on bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages
443–458, Berkeley, California, USA, May 18–21, 2014. IEEE Computer Society Press.
[4] The Internet Archive. Over 1,000,000 torrents of downloadable books, music, and movies,
2012. https://blog.archive.org/2012/08/07/over-1000000-torrents-of-downloadable
-books-music-and-movies/.
[5] N. Asokan, Victor Shoup, and Michael Waidner. Optimistic fair exchange of digital signatures
(extended abstract). In Kaisa Nyberg, editor, Advances in Cryptology – EUROCRYPT’98,
volume 1403 of Lecture Notes in Computer Science, pages 591–606, Espoo, Finland, May 31 –
June 4, 1998. Springer, Heidelberg, Germany.
[6] Christian Badertscher, Ueli Maurer, Daniel Tschudi, and Vassilis Zikas. Bitcoin as a transac-
tion ledger: A composable treatment. In CRYPTO 2017, pages 324–356, 2017.
[7] Waclaw Banasik, Stefan Dziembowski, and Daniel Malinowski. Eﬃcient zero-knowledge con-
tingent payments in cryptocurrencies without scripts.
In ESORICS 2016: 21st European
Symposium on Research in Computer Security, Part II, Lecture Notes in Computer Science,
pages 261–280. Springer, Heidelberg, Germany, September 2016.
[8] Mihir Bellare, Georg Fuchsbauer, and Alessandra Scafuro. NIZKs with an untrusted CRS:
Security in the face of parameter subversion. In Advances in Cryptology – ASIACRYPT 2016,
Part II, Lecture Notes in Computer Science, pages 777–804. Springer, Heidelberg, Germany,
December 2016.
[9] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Scalable zero knowledge
via cycles of elliptic curves.
In Juan A. Garay and Rosario Gennaro, editors, Advances in
Cryptology – CRYPTO 2014, Part II, volume 8617 of Lecture Notes in Computer Science,
pages 276–294, Santa Barbara, CA, USA, August 17–21, 2014. Springer, Heidelberg, Germany.
25
[10] Iddo Bentov and Ranjit Kumaresan. How to use bitcoin to design fair protocols. In Juan A.
Garay and Rosario Gennaro, editors, Advances in Cryptology – CRYPTO 2014, Part II, vol-
ume 8617 of Lecture Notes in Computer Science, pages 421–439, Santa Barbara, CA, USA,
August 17–21, 2014. Springer, Heidelberg, Germany.
[11] Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its appli-
cations (extended abstract). In 20th Annual ACM Symposium on Theory of Computing, pages
103–112, Chicago, Illinois, USA, May 2–4, 1988. ACM Press.
[12] Sean Bowe. Pay-to-sudoku, 2016.
[13] Christian Cachin and Jan Camenisch. Optimistic fair secure computation. In Mihir Bellare,
editor, Advances in Cryptology – CRYPTO 2000, volume 1880 of Lecture Notes in Computer
Science, pages 93–111, Santa Barbara, CA, USA, August 20–24, 2000. Springer, Heidelberg,
Germany.
[14] Jan Camenisch, Manu Drijvers, Tommaso Gagliardoni, Anja Lehmann, and Gregory Neven.
The wonderful world of global random oracles. Cryptology ePrint Archive, Report 2018/165,
2018. https://eprint.iacr.org/2018/165.
[15] Matteo Campanelli, Rosario Gennaro, Steven Goldfeder, and Luca Nizzardo. Zero-knowledge
contingent payments revisited: Attacks and payments for services. In ACM CCS 17: 24th
Conference on Computer and Communications Security, pages 229–243. ACM Press, 2017.
[16] Ran Canetti. Security and composition of multiparty cryptographic protocols. Journal of
Cryptology, 13(1):143–202, 2000.
[17] Ran Canetti, Abhishek Jain, and Alessandra Scafuro. Practical UC security with a global
random oracle. In Gail-Joon Ahn, Moti Yung, and Ninghui Li, editors, ACM CCS 14: 21st
Conference on Computer and Communications Security, pages 597–608, Scottsdale, AZ, USA,
November 3–7, 2014. ACM Press.
[18] Ran Canetti, Ben Riva, and Guy N. Rothblum. Practical delegation of computation using
multiple servers. In ACM Conference on Computer and Communications Security, pages 445–
454. ACM, 2011.
[19] Alessandro Chiesa, Eran Tromer, and Madars Virza. Cluster computing in zero knowledge. In
Elisabeth Oswald and Marc Fischlin, editors, Advances in Cryptology – EUROCRYPT 2015,
Part II, volume 9057 of Lecture Notes in Computer Science, pages 371–403, Soﬁa, Bulgaria,
April 26–30, 2015. Springer, Heidelberg, Germany.
[20] Stefan Dziembowski, Lisa Eckey, Sebastian Faust, and Daniel Malinowski. Perun: Virtual
payment hubs over cryptocurrencies. Cryptology ePrint Archive, Report 2017/635, 2017.
https://eprint.iacr.org/2017/635, accepted to IEEE S&P 2019.
[21] Marc Fischlin, Anja Lehmann, Thomas Ristenpart, Thomas Shrimpton, Martijn Stam, and
Stefano Tessaro. Random oracles with(out) programmability. In Masayuki Abe, editor, Ad-
vances in Cryptology – ASIACRYPT 2010, volume 6477 of Lecture Notes in Computer Science,
pages 303–320, Singapore, December 5–9, 2010. Springer, Heidelberg, Germany.
26
[22] Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. Zkboo: Faster zero-knowledge for
In USENIX Security Symposium, pages 1069–1083. USENIX Association,
boolean circuits.
2016.
[23] Oded Goldreich. Foundations of Cryptography: Volume 1. Cambridge University Press, New
York, NY, USA, 2006.
[24] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or A
completeness theorem for protocols with honest majority. In Alfred Aho, editor, 19th Annual
ACM Symposium on Theory of Computing, pages 218–229, New York City,, New York, USA,
May 25–27, 1987. ACM Press.
[25] Marek Jawurek, Florian Kerschbaum, and Claudio Orlandi. Zero-knowledge using garbled
circuits: how to prove non-algebraic statements eﬃciently. In Ahmad-Reza Sadeghi, Virgil D.
Gligor, and Moti Yung, editors, ACM CCS 13: 20th Conference on Computer and Communi-
cations Security, pages 955–966, Berlin, Germany, November 4–8, 2013. ACM Press.
[26] Murat Karakaya, ˙Ibrahim K¨orpeo˘glu, and ¨Ozg¨ur Ulusoy. Counteracting free riding in peer-to-
peer networks. Computer Networks, 52(3):675–694, 2008.
[27] Jonathan Katz, Ueli Maurer, Bj¨orn Tackmann, and Vassilis Zikas. Universally composable
synchronous computation. In Amit Sahai, editor, TCC 2013: 10th Theory of Cryptography
Conference, volume 7785 of Lecture Notes in Computer Science, pages 477–498, Tokyo, Japan,
March 3–6, 2013. Springer, Heidelberg, Germany.
[28] Aggelos Kiayias, Hong-Sheng Zhou, and Vassilis Zikas. Fair and robust multi-party compu-
tation using a global transaction ledger. Cryptology ePrint Archive, Report 2015/574, 2015.
Accepted to EUROCRYPT’16, http://eprint.iacr.org/.
[29] Aggelos Kiayias, Hong-Sheng Zhou, and Vassilis Zikas. Fair and robust multi-party computa-
tion using a global transaction ledger. In EUROCRYPT 2016, pages 705–734, 2016.
[30] Ranjit Kumaresan and Iddo Bentov. Amortizing secure computation with penalties. In ACM
CCS 16: 23rd Conference on Computer and Communications Security, pages 418–429. ACM
Press, 2016.
[31] Ranjit Kumaresan, Vinod Vaikuntanathan, and Prashant Nalini Vasudevan. Improvements
to secure computation with penalties. In ACM CCS 16: 23rd Conference on Computer and
Communications Security, pages 406–417. ACM Press, 2016.
[32] Alptekin K¨up¸c¨u and Anna Lysyanskaya. Usable optimistic fair exchange. Computer Networks,
56(1):50–63, 2012.
[33] Morgan G. I. Langille and Jonathan A. Eisen. Biotorrents: A ﬁle sharing service for scientiﬁc
data. PLoS ONE, 5(4):1–5, 04 2010.
[34] Henry Z. Lo and Joseph Paul Cohen. Academic torrents: Scalable data distribution. CoRR,
abs/1603.04395, 2016.
[35] Lee Mathews. Windows 10 lets you torrent updates and apps, 2015. http://www.geek.com/
microsoft/windows- 10-lets-you-torrent-updates-and-apps -1618036.
27
[36] Andrew Miller, Iddo Bentov, Ranjit Kumaresan, and Patrick McCorry. Sprites: Payment
channels that go faster than lightning. CoRR, abs/1702.05812, 2017.
[37] Jesper Buus Nielsen. Separating random oracle proofs from complexity theoretic proofs:
In Moti Yung, editor, Advances in Cryptology –
The non-committing encryption case.