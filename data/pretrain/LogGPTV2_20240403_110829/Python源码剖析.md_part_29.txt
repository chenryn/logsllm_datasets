## Page 203
10.1.1
10.1
析Python虚拟机中对比较操作的实现，所以在if_control.py中，我们列出了Python所支
们将通过对如下所示的if_control.py的研究来深入剖析Pyhon对选择控制语句的实现。
我们将剖析Pyhon中所提供的所有的流程控制手段，其中包含了异常机制。
制程序流程的语义元素，在C中甚至还有像goto这样的瞬间超距移动语义。在本章中，
对话。一个只会顺序执行的程序是没有什么趣味的，所有的现代编程语言中，都提供了控
我们所考察的程序的流程都是顺序执行的，在执行的过程中没有任何变化。在几年前风摩
elif
elif
[lf_control.py]
ia
在f_controlpy中，我们除了剖析Pyhon虚拟机中对i控制流的实现之外，还会剖
printUnknown吉”
print
print
在所有的编程语言中，i控制流是最简单也是最常用的流程控制语句。在这一节，我
Python虚拟机中的if控制流
在上一章，我们剖析了Pyhon虚拟机中的一般表达式的实现。在剖析一般表达式时
print
print
研究对象
10:
展
Python虚拟机中的控制流
-if_control.py
Python源码剖析
一深度探索动态语言核心技术
第
CHAPTER
---
## Page 204
Python源码剖析
174
关联着一个PyIntObject对象。
在当前活动的PyFrameobject对象的1ocal名字空间内添加一个名为“a”的符号，且其
40
28
10-1所示：
对if_control.py的编译之后，只会得到一个pyCodeObject对象。这个pyCodeobject对
持的几乎所有的判断操作。
LOAD_CONSI
LOAD_NAME
注意：字节码指令序列的顺序是从左到右，从上到下。
POP_TOE
JUMP_FORWARD S0 (EO 99)
PRINTNEWLINE
PRINT_IPEM
LOADICONST
print
POPTOP
COMPARE_OP
LOADLNAME
POPTOP
JUMPLFORWARD 72(tO
PRINT NEWLINE
LOAD_CONST
POP_TOP
JUMP_IFFALSE9（LO:27)
COMPAREJOP
对于其后的注控制流部分，
在ifcontrolpy中，第一行代码是我们已经非常熟悉的了。第一行代码执行的结果会
根据我们现在对Python编译器的工作过程的了解，我们知道，在Python编译器完成
第10章
a=2
一深度探索动态语言核心技术
Python虚拟机中的控制流
4(a
图10-1
length="6"
value=""/>
编译所得的字节码指令序列如下所示：
if_control.pyc中的常量表和符号表
6
88
85
59
JUMP_IR_FALSE9(EO93)
POE_TOP
JUMP FORWARD 6(CO.99)
LOADNCONST
POPTOP
COMPARE OP
LOADLCONST
WOAD NAME
PoPTop
JUMP
PRINT_TEM
LOADLCONST
POPLTOP
UMP_IFFALSE
COMPARE_OP
LOAD CONST
value="al-1
valne=“a
e
bo
99
711
elae:
102 RBIURN VALOE
66
98
PRINI_NEWLINE
a
---
## Page 205
10.1.2
PyCmp_IS,PyCmp_IS_NOT,PyCmp_EXC_MATCH,PYCmp_BAD);
些不同的比较操作在object.h中定义：
分支判断的关键所在。实际上，COMPARE_OP的不同指令参数对应了不同的比较操作。这
指令参数确实是不同的。所以，COMPARE_OP指令的指令参数实际上也就是区分这些不同
PyCmp_NE=Py_NE,
地方有所不同。通过观察，我们发现不同的分支判断在调用cOMPAREOP指令时，传入的
#definePy_GE
#define
支判断语句进行的是不同的比较操作。显然在相同的指令序列结构中，应该有某个细节的
[opcode.h]
#define
#define
[object.h]
都呈现出同样的字节码指令序列结构：
较操作为切入点，开始进入对控制流的剖析。
果。所以在本章的描述中，判断和比较这两个概念是可以互相替换的。现在，我们就以比
判断也是关键的一环，这一点我们将在以后看到。
于程序流程的控制至关重要。其实不仅仅是对于主注控制语句，对于其他的流程控制语句，
同的道路，就有可能经历不同的计算过程，最终导致不同的计算结果。所以，判断操作对
的流程的。在语句处，根据判断结果的不同，程序将选择向左走还是向右走。选择不
#define
可以看到，不同的分支判断语句编译后都是这样相同的指令序列结构，但是不同的分
仔细观察if_control.py中的各个判断分支语句，我们发现它们经Pyhon编译器编译后
执行某一条JUMP_*指令，根据COMPAREOP指令的运行结果进行字节码指令的跳跃
执行LOAD_cONST指令，从常量表consts中读取参与该分支判断操作的常量对象
执行LOAD_NAME指令，从local名字空间中获得变量名a所对应的变量值；
在进行程序设计时，判断主要就是对两个对象进行比较，判断的结果也就是比较的结
执行COMPAREOP指令，对前面两条指令取得的变量值和常量对象进行比较操作：
与其他的程序设计语言相同，Python中的ii控制语句也是通过一个判断来控制程序
比较操作
Py
Py_EQ
comparison opcodes/
Cm
(PyCmp_LT=Dy_LT,FyCmp_LE=Py_LE,PyCmp_EQ=Py_EQ
Pydmp
Python源码剖析
10.1Python虚拟机中的if控制流
一深度探索动态语言核心技术
175
---
## Page 206
Python源码剖析
10.1.2.1
176
的实现中为PyIntobject对象建立了快速通道。如果参与比较操作的两个对象都是
代码清单10-1
拟机中通用的用于比较操作的字节码指令一
以判断a10对应的coMPARE_oP的指令参数
第10章Python虚拟机中的控制流
COMPARE_OP指令
slow_compare:
深度探索动态语言核心技术
PREDICT(JUMPIF_TRUE）:
PREDICT(JUMP
SET_TOP(X):
PY_DECREF(V)
//[1]：PyIntobiecE对象的快速通道
VTOPO:
将比较结果压入到运行时栈中
-2对应的COMPARE_OP指令的指令参数正是1。
x=cmp_outcometoparg.v.w）;
一般对象的提速通道
Py_INCREF(X))
case
case
case
cas
17根据字节码指令的指今参数选择不同的比较操作
case
se
PyInt_AS_LONG(y)
NULLy break:
PyCmp_IS:
PyCmp_GE:
PyCnp_NE:
PyCmp_EQ:
PyCm：
CheckExaet（w)&&PyInt_CheckBxact(v)）(
int
IE
res
res
res
nes
B:
品
日
COMPAREOP中了（见代码清单10-1）。
b:
b:
break;
break;
break
---
## Page 207
比如下面的Python代码：
指令不仅管辖着两个对象之间比较操作，而且还覆盖了对象与集合之间关系的判断操作。
list
以看到了：
较操作与
机为比较操作准备的慢速通道，调用cmp_outcome进行常规的比较操作。这个常规的比
择不同的比较操作的。
代码清单10-1中可以清晰地看到，Pyhon正是通过coMPARE_OP指令的不同指令参数来选
PyIntobject对象，
JUMP_IF_FALSE
[ceval.c]
COMPARE_OP
LOAD_CONST
tatic Pyobject*cmp_outcome int op,register Pyobject
LOAD_NAME
在cmp_outcome的实现代码中，实际上透露了另一个信息，即Pyhon的coMPARE_OP
如果参与比较的两个对象不全是PyIntObject对象，很不幸，只能进入Python虚拟
returnav;
default:
=11,2,3.41
case
case
case
case
return
res
break:
if
res
break;
与PyIntobjecE对象的快速通道相比，执行效率真是有天壤之别，
PyCmp_EXCMATCH:
res
PyCmp_
PyCmp_IN:
PyCmD_ISNOT:
meturn
(res
(op)"
PySequence_Contains(w,
Pyobject_RichCompare（v,w,op);
nes:
NOT_IN:
，那么直接取得pyIntobject 对象中维护的整数值进行比较即可。从
(in)
NULL
(1）
_Contains（w,
VF
Python源码剖析
10.1
Python虚拟机中的if控制流
*v,registerPyobject*w)
一深度探索动态语言核心技术
马上我们就可
177
---
## Page 208
Python源码剖析
10.1.2.2
178
我们就在这里止步吧，不再深入Pyton的对象比较体系了，有兴趣的朋友可以深入追下去
这两个也是名副其实的Pyobject对象。
代表成功和失败的对象：Py_True和Py_False。注意，我说这两个东西是对象，没错，
值的C中，也会使用1和0来代替boo1值。Python虚拟机中也有这样两个对立而统一的
率上有很大的差别。在我个人看来，实在有点过设计的味道，可能这也是历史遗留的问题
的寻求比较的行为会影响比较操作的效率，使得慢速通道与针对整数的快速通道相比，效
所进行的动作错综复杂，看上去Pyhon是要想方设法地进行比较。这种不到黄河不死心
挣扎
的。如果这两个操作都没有成功，那么Python还不死心，还会调用do_richcmp进行垂死
tp_compare操作。在Python中，无论是Python内建对象，还是用户自定义的类的实例对
tp_richcompare操作：如果类型对象没有定义这个动作，就选择类型对象中定义的