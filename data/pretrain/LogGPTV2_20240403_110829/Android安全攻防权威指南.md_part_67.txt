各类外设，比如显示器、触摸屏、存储设备和音颜输人输出设备等。第二个子系统是蜂窝基带或
者蜂窝调制解调器。这个基带通常由一个ARMCPU和一个DSP（数字信号处理器）组成，负责
在手机与移动通信基础设施之间建立物理层的无线连接。设备具体使用哪种应用处理器和基带，
主要取决于设备的制造商以及设备支持的移动网络类型（比如GSM、CDMA等）。在设备的主板
上，这两个子系统互相连接。有时为了降低成本，芯片厂商也会将其集成到一块芯片中，但从功
能上看，它们依然是相互独立的。图11-1是智能手机架构的抽象示意图。
SoC
GPS
UART
基带
UART
CPU
CPU
内存
DSP
内存
显示屏
触摸屏
闪存
图11-1智能手机通用架构
---
## Page 302
286
第11章攻击RIL无线接口层
这两个子系统之间的接口类型主要取决于实际使用的组件以及设备厂商。常见的接口包括
SPI（串行外设接口）、USB（通用串行总线）、UART（通用异步收发器）和共享内存。由于存在
多种选择，RIL往往设计得非常灵活。
11.1.3Android电话栈
Android电话栈（AndroidTelephony Stack）由4部分组成，自顶向下分别是：电话和短信应
用程序、应用程序框架、RIL守护程序和内核级设备驱动。Android系统的代码分别由Java和C/C++
实现：前者运行在Dalvik虚拟机中，后者则以本地机器码的形式直接运行。寻找bug时，这个特
点非常重要。
具体到Android电话栈，Dalvik与本地代码的区别为：应用程序部分用Java编写，在Dalvik
虚拟机中执行：用户空间的组件都是本地代码，如RIL守护程序和库：当然，Limux内核也以本
地代码形式执行。图11-2是Android电话栈的概览图。
应用层
手机应用
通话限除信分配器服务踪器数除
应用框架层
Dalvik
Native
用户空间
商的RIL实现
语音和控制
Linux内核
平台和基带驱动序
基带
图11-2Android电话栈
---
## Page 303
11.1RIL简分287
1.电话相关的应用程序
这部分是高层的应用程序，主要包括电话拨号器和短信，实现了多个核心功能。谷歌将实现
某种功能的代码称为跟踪器（tracker）：通话跟踪器、短信分配器、服务跟踪器和数据跟踪器等。
通话跟踪器处理语音通话，比如拨打或者挂断电话。短信分配器负责处理短信与彩信消息。服务
跟踪器负责蜂窝连接，比如设备是否已经连接到网络，接收级别是多少，是否在漫游中，等等。
数据跟踪器则负责数据连接（移动上网）这些电话的应用程序与下一层（应用程序框架层）直
接通信。
2.应用框架层
在应用框架层中，RIL的组件主要有两类功能：第一，提供电话相关应用程序与RIL守护程
序之间的通信接口；第二，对不同移动网络中的各种概念进行抽象。开发应用程序时，开发者可
以通过android.telephony包提供的方法来使用这些抽象概念。
3.用户空间的本地组件
用户空间的组件主要包括RIL守护程序及其支持库。RIL守护程序是本章的重点闸述对象，
在11.1.5节和11.1.6节中会进一步介绍。
4.内核
Linux内核包含了电话栈的最底层组件，主要是基带硬件的驱动程序。这些驱动主要向用户
空间代码提供一个与基带进行对话的接口。该接口通常是一个串行链路，本章后面会详细介绍。
11.1.4对电话栈的定制
Android电话栈中的各层都可以定制，其中一些是必须定制的，比如基带驱动程序与设备硬
件的适配。除此之外，设备厂商通常也会对其他不必修改的部分进行定制，常见的有替换拨号器
替换或者修改原有的短信与彩信软件等。还有一些厂商会对电话相关的框架层核心代码进行频繁
改动。从安全的角度来看，这些定制和修改产生的新代码尤其有价值，因为它们大多是闭源的，
而且可能并尚未经过安全研究者的审计。
11.1.5RIL守护程序
RIL中最重要的组件是RIL守护程序（rild）。RIL守护程序是一个系统核心服务，以本地
Linux进程的形式运行，主要功能是在Android电话框架层与设备硬件之间建立连接。具体方式
是通过名为Binder的IPC机制向框架层提供接口。其开源部分的源代码位于AOSP源码仓库的
hardware/ril 目录下。
由于谷歌的特意设计，rild良好地支持第三方闭源的硬件代码接口。为了做到这一点，rild
提供了由一系列函数调用和回调构成的一整套API。启动时，rild会加载设备厂商提供的vendor-ril
共享库。在vendor-ril中，厂商实现了具体硬件的相关功能。
RIL守护程序是Android设备中少数由init进程管理的服务之一。因此，它会在系统引导时
启动；一旦进程意外终止，还会重新启动。与一些系统服务不同的是，RIL守护进程的崩溃通常
---
## Page 304
288
第11章攻击RIL无线接口层
不会导致设备重启，也不会让系统变得不稳定。这些特点让我们可以放心地操作rild。
1.不同设备上的RIL守护程序
不同设备上的RIL守护程序有细微的差别。后面我们会用自己的设备来举例分析，先了解它
的配置便于在自已的设备上操作。现在介绍如何快速了解手头设备的rild信息。这个示例用的是
HTCOneV手机，运行Android 4.0.3系统和HTC Sense 4.0主题。
读取RIL信息的主要方法是在ADBshell中执行一系列命令。首先，找出rild的进程ID（PID）。
有了PID就可以通过proc文件系统来查看该进程的各类信息，看到rild加载的所有动态库文件。
其次，检查init脚本文件，查到rild使用了哪些UNIX域套接字。接下来，回到proc文件系统中，
查看rild打开了哪些文件，从面确定rild使用的串行设备名称。最后，使用getprop工具dump
出所有与RIL相关的Android系统属性。
shel1gandroid:/ # ps Igrep ri1d
radio
14451
14364932
fffftfff 40063fb4 s /system/bin/ri1d
shel19android:/ + cat /proe/1445/maps 1grep ri1
8Z 6000020000d-00000000-00000000
861:0q00000000 dx-100000000-00080000
/system/bin/ri1d
/system/bin/ri1d
9001 61:0000000000 dx-100060009-0006000
/8ystem/1ib/11br11 .80
400b9000-400bb000 rw-p 00010000 b3:19
1056
/8y8tem/1ib/1ibri1 .80
866610000000000dx-100000000-0000000
/system/1ib/1ibhte_ri1.80
401ed000-401f3000 rw-p 0008f000 b3:19 998
/system/1ib/1ibhtc_r11.so
shellgandroid:/ # grep ri1d /init.rc
service ri1daemon /system/bin/ri1d
socket rild stream 660 root radio
socket ri1d-debug stream 660 radio system
socket ri1d-htc stream 660 radio system
shel1@android:/data # 1s -18
/proe/1445/fd |grep dev
Lrwx------
root
root
20130115 12:55 13 -> /dev/smd0
root
root
/  /dev/qmi.2
shel19android:/ $ getprop |grep ri1
[g8m.ver8ion.xi1-inp1] : [HTCRIL 4.0.0024HM (Mar  6 2012,10:40:00)]
[init,sve,ri1-daemon] : [running]
[xi1.ecelist]:[112,911]
[xi1.booted] : [1]
[ri1.gsm.only-vernion]: [2]
[ri1.modem_1ink.status] : [0]
[ril.reload.count] : [1]
[ril.sim.swap.status]: [0]
[xi1d.1ibpath.ganlite] : [/system/1ib/1ibri1sritch.so]
[ri1d,1ibpath] : [/syatem/1ib/libhte_ri1.so]
[rilswiteh.gan1ibpath] : [/system/1ib/1ibganri1.so]
[ri1switch,vendorlibpath]: [/ayetem/1ib/1sbhtc_ri1.so]
[ro.ri1.def.agps.mode] : [2]
[ro.r11.enable.a52.HTCITA] : [1]
---
## Page 305
11.1RIL简介2
68Z
[ro.ri1.enable.a52]: [0]
[ro.ri1 enable.a53,HrCITA] : [1]
[ro.ri1.enable.a53] : [1]
[ro.ri1, enable.amr,wideband] : [1]
[xo.ri1.enable.dtm] : [1]
[ro .ri1.enable.managed.roaming] : [1]
[ro.ri1.hsdpa.category]: [10]
[ro.ri1.gprsclass] : [12]
[ro.ri1.hsupa,category] : [6]
[ro.ri1.haxpa] : [2]
 - -
上面的输出结果包含许多重要的数据片段，比如vendor-ril库的具体文件名是libhtc_ril.so。
还得到了rild使用的套接字，位于/dev/socket下。这些套接字各有各的用处，比如/dev/socket/nild-debug
和/dev/socket/rild-htc为调试rild和vendor-ril 提供辅助。这些输出的数据中，最重要的信息是与
蜂窝基带进行通信的申行设备名称。在这部HTCOneV手机上，该设备是/dev/smd0。从安全的
角度来看，这个串行设备非常重要，因为rild通过它向调制解调器发送命令，包括收发短信等，
因此这个通信链路非常容易遭受攻击。
2.安全性
RIL守护程序是Android设备上为数不多可以从外界直接抵达的代码片段之一。rild和
vendor-ril都是用C和C++编写，然后编译成本地代码运行。这两种语言都不是内存安全的，因
此可能成为各类安全间题的主要源头。RIL守护程序需要处理不同来源的各种数据，比如解析并
处理来自蜂窝调制解润器和Android框架层的数据和控制信息，最直接的例子就是短信。
处理接收到的短信时，需要遍历硬件和软件中的多个模块，每个都有可能成为攻击目标。短
信发送到Android设备上以后，会被基带接收。基带将物理层链路传输的数据进行解码，通过Linux
内核中的基带驱动程序进行转发。内核里的驱动会将这条短信转给RIL守护程序中的vendor-ril
库，RIL守护程序再将其推送给Android电话栈的框架层。可以看到，在儿乎每一个Android设
备上，RL中的代码都可以受到远程攻击。通常情况下，攻击者更喜欢开展远程攻击，这样就不
需要与受害用户进行直接交互或接触。
刚启动时，RIL守护进程通常以root权限执行。为了降低风险，它在启动后会很快将权限
降低为radio用户。radio用户只能访问完成其职责所必需的资源。不过正如前面所说，rild需
要访问的资源本来就包括许多重要数据（比如短信），还要完成许多重要功能（比如发送短信、
拨打电话）。从另一个角度看，radio用户和同名的用户组也用于确保不把rild专用的资源暴露
给其他用户。
1
11.1.6用于vendor-ril的API
vendor-ril与制造商、设备型号紧密相关，负责与具体的蜂窝基带硬件进行交互。直到今天，
基带依然是高度私有化的，因此RIL子系统被特意设计成只支持二进制文件形式的扩展。事实上，