from a Node.js third-party library. The dynamic analysis tool
then extracts the corresponding dynamic permissions using
the test cases. The combination of permissions are used as
input to the policy enforcement component.
to dynamic program behavior. Several static analysis systems have
been developed for Node.js [5, 7, 18].
Dynamic analysis: Dynamic program analysis is a technique
for extracting information about a program by instrumenting its
execution. Because of its nature, dynamic analysis can extract a
wealth of information about a single execution but (1) this infor-
mation might not generalize to other executions, and (2) it might
impose a significant runtime overhead to the program’s execution.
Several dynamic analysis frameworks have been developed for
JavaScript [2, 10, 14, 17].
Combined analysis: While both static and dynamic analysis are
necessarily imprecise approximations of program behavior, their rel-
ative trade-offs make them complementary tools in a programmer’s
tool arsenal [3, 4]. By combining these two synergistic approaches,
as our demo shows, we aim at providing improved analysis results
with minimal-to-zero developer effort.
3 TOOL OVERVIEW
Fig. 1 shows an overview of our proposed techniques and the way
they are applied on a real use case.
Our techniques start by running a static program analysis on the
source code of the target library to extract a first set of candidate
permissions (Fig. 1, (1)). This phase analyzes the source code of
the library and corresponding dependencies to extract the set of
interfaces—e.g., functions, global objects, language built-ins—used
by the library.
Our techniques then pair this static permission set with a second
set gathered via dynamic program analysis (Fig. 1, (2)). During this
phase, dynamic analysis is applied against the testing infrastructure
of the library, which encodes anticipated library behaviors envi-
sioned by the library’s developers. We augment these test inputs
with ones gathered via active learning [15]—a critical addition for
libraries that do not have test cases.
Finally, our techniques enforce the permission sets gathered by
both analysis phases by instrumenting program execution (Fig. 1,
(3)). When this enforcement instrumentation framework detects
an access outside of the generated permission set, it throws an
exception aborting the execution of the program.
dec: Xhttp.createServerrequire("serial")serial.dec(data)evalxCombined Static/Dynamic AnalysisMaliciousInputInputStatic AnalysisPermissionseval: XDynamic AnalysisPermissionsTest InputPermissionsOutputOutput1 2 3 Session 8: Poster & Demo Session CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2430{ "~/libs/serialization/index.js":
{ "eval": "rx",
"module": "r",
"module.exports": "w" } }
The inferred permissions show the use of eval and module.export
for evaluating code and exporting library functionality.
Applying dynamic analysis: We then run perm.js -d, our
dynamic permission inference analysis, with the use of the provided
test cases in order to extract permissions from the third-party library
serialization. As all of the inputs are JSON objects, they only
additional permissions are related to a few built-in primitives such
as the Array constructor and the value null.
{ "~/libs/serialization/index.js":
{ "eval": "rx",
"module": "r",
"module.exports": "w",
"Array": "rx",
"null": "r", } }
Executing with permission enforcement: We launch the instru-
mented program enforcing the combined RWX permissions inferred
during the previous two phases. When the malicious input attempts
to access the fs library, the instrumented code throws an exception
that halts the execution of the program.
5 DISCUSSION & CONCLUSION
We hope that our demo will form the basis of a discussion around
the practices of third-party libraries. We outline a few potential
discussion threads below.
First, what is the best way for developers to incorporate specific
standards to the libraries they develop and make available to the
community? The goal here is to minimize supply-chain attacks
due to developer mistakes. A formalization could include language-
specific standards (e.g., minimizing the use of eval, or enforcing
the inclusion of test cases with adequate coverage) for ameliorating
security problems before the libraries are shared.
Second, what are the possible steps to be taken by library repos-
itories in order to shield the community against these problems?
The goal here is to identify a set of simple steps that repositories can
take in order to mitigate many of these problems—with minimal
overhead for the end user.
Finally, what is a good way to improve checks on program up-
dates? As the SolarWinds [1] attack has demonstrated, discovering
and mitigating vulnerabilities related to program updates is of para-
mount importance, and thus automating these checks to the extent
possible would provide significant security benefits.
We hope that our demonstration of a combined static and dy-
namic program analysis in the context of real Node.js applications,
will serve to kick off a targeted discussion around the problems of
third-party libraries and possible ways to mitigate them.
ACKNOWLEDGMENTS
This work was partly supported by DARPA contract no. HR0011202-
0013, HR001120C0191, and HR001120C0155. This work has also
received funding from the European Union’s Horizon 2020 research
and innovation programme under grant agreement No 830927
(CONCORDIA) and under grant agreement No 952690 (CYRENE).
[2] Esben Andreasen, Liang Gong, Anders Møller, Michael Pradel, Marija Selakovic,
Koushik Sen, and Cristian-Alexandru Staicu. 2017. A Survey of Dynamic Analysis
and Test Generation for JavaScript. ACM Comput. Surv. 50, 5 (2017), 66:1–66:36.
https://doi.org/10.1145/3106739
[3] Michael D Ernst. 2003. Static and dynamic analysis: Synergy and duality.
[4] Chris Hawblitzel and Thorsten Von Eicken. 1998. A case for language-based
protection. Technical Report. Cornell University.
[5] Igibek Koishybayev and Alexandros Kapravelos. 2020. Mininode: Reducing
the Attack Surface of Node.js Applications. In 23rd International Symposium on
Research in Attacks, Intrusions and Defenses ({RAID} 2020).
[6] Tobias Lauinger, Abdelberi Chaabane, Sajjad Arshad, William Robertson, Christo
Wilson, and Engin Kirda. 2017. Thou Shalt Not Depend on Me: Analysing the
Use of Outdated JavaScript Libraries on the Web. (2017).
[7] Magnus Madsen, Frank Tip, and Ondřej Lhoták. 2015. Static analysis of event-
driven Node. js JavaScript applications. ACM SIGPLAN Notices 50, 10 (2015),
505–519.
[8] Nick Nikiforakis, Luca Invernizzi, Alexandros Kapravelos, Steven Van Acker,
Wouter Joosen, Christopher Kruegel, Frank Piessens, and Giovanni Vigna. 2012.
You are what you include: large-scale evaluation of remote javascript inclusions.
In Proceedings of the 2012 ACM conference on Computer and communications
security. 736–747.
[9] npm. 2016. Run a security audit. https://docs.npmjs.com/cli/v7/commands/npm-
audit/. https://docs.npmjs.com/cli/v7/commands/npm-audit
[10] Koushik Sen, Swaroop Kalasapur, Tasneem Brutch, and Simon Gibbs. 2013.
Jalangi: A Selective Record-replay and Dynamic Analysis Framework for
JavaScript. In Proceedings of the 2013 9th Joint Meeting on Foundations of Soft-
ware Engineering (ESEC/FSE 2013). ACM, New York, NY, USA, 488–498. https:
//doi.org/10.1145/2491411.2491447
[11] Snyk. 2016. Find, fix and monitor for known vulnerabilities in Node.js and Ruby
packages. https://snyk.io/. https://snyk.io/
REFERENCES
[1] 2020. CVE-2020-10148. Available from NIST, CVE-ID CVE-2020-10148.. https:
//nvd.nist.gov/vuln/detail/CVE-2020-10148
University.
[12] Deian Stefan. 2015. Principled and Practical Web Application Security. Stanford
[13] Deian Stefan, Edward Z Yang, Petr Marchenko, Alejandro Russo, Dave Herman,
Brad Karp, and David Mazieres. 2014. Protecting Users by Confining JavaScript
with {COWL}. In 11th {USENIX} Symposium on Operating Systems Design and
Implementation ({OSDI} 14). 131–146.
[14] Haiyang Sun, Daniele Bonetta, Christian Humer, and Walter Binder. 2018. Ef-
ficient Dynamic Analysis for Node.Js. In Proceedings of the 27th International
Conference on Compiler Construction (CC 2018). ACM, New York, NY, USA, 196–
206. https://doi.org/10.1145/3178372.3179527
[15] Nikos Vasilakis, Achilles Benetopoulos, Shivam Handa, Alizee Schoen, Jiasi Shen,
and Martin C. Rinard. 2021. Supply-Chain Vulnerability Elimination via Active
Learning and Regeneration. In Proceedings of the 2021 ACM SIGSAC Conference
on Computer and Communications Security (CCS ’21). Association for Computing
Machinery, New York, NY, USA, 16. https://doi.org/10.1145/3460120.3484736
[16] Nikos Vasilakis, Ben Karel, Nick Roessler, Nathan Dautenhahn, André DeHon,
and Jonathan M. Smith. 2018. BreakApp: Automated, Flexible Application Com-
partmentalization. In Networked and Distributed Systems Security (NDSS’18).
https://doi.org/10.14722/ndss.2018.23131
[17] Nikos Vasilakis, Grigoris Ntousakis, Veit Heller, and Martin C. Rinard. 2021.
Efficient Module-Level Dynamic Analysis for Dynamic Languages with Module
Recontextualization. In Proceedings of the 29th ACM Joint Meeting on European
Software Engineering Conference and Symposium on the Foundations of Software
Engineering (ESEC/FSE 2021). Association for Computing Machinery, New York,
NY, USA, 1202–1213. https://doi.org/10.1145/3468264.3468574
[18] Nikos Vasilakis, Cristian-Alexandru Staicu, Grigoris Ntousakis, Konstantinos
Kallas, Ben Karel, André DeHon, and Michael Pradel. 2021. Preventing Dynamic
Library Compromise on Node.js via RWX-Based Privilege Reduction. In Pro-
ceedings of the 2021 ACM SIGSAC Conference on Computer and Communications
Security (CCS ’21). Association for Computing Machinery, New York, NY, USA,
18. https://doi.org/10.1145/3460120.3484535
[19] Markus Zimmermann, Cristian-Alexandru Staicu, Cam Tenny, and Michael Pradel.
2019. Smallworld with High Risks: A Study of Security Threats in the Npm
Ecosystem. In Proceedings of the 28th USENIX Conference on Security Symposium
(SEC’19). USENIX Association, USA, 995–1010.
Session 8: Poster & Demo Session CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2431