many recent proposals for declassiﬁcation, noting
shortcomings and anomalies which motivate the “pru-
dent principles” we address in Sect. 10. Another no-
table work is by van der Meyden [35]; it improves
on Rushby’s inﬂuential analysis of declassiﬁcation
policy that requires interfering ﬂows to go via channels
labelled at some level intended to represent trusted
sanitization code [27]. Like ours, these works also
distinguish low from high events and purge the latter as
a way to remove timing leaks from consideration. But
we address ﬁner-grained policies and also enforcement
for a concrete programming language.
Our work builds very directly on the gradual release
paper [4], more speciﬁcally on the semantic property
introduced in the ﬁrst part of the paper. Our formal-
ization is quite different, in part because we correct
an evident weakness in the attacker model: by ﬁat,
their attacker observes no steps if the computation
is not going to terminate. (Of course for terminating
computations their low events include termination as
well as low writes.) Askarov and Sabelfeld [4] ex-
tend gradual release to programs using cryptographic
primitives; in particular, declassiﬁcation is an atomic
action achieved by releasing a previously secret key
—the data of interest having already been released
but encrypted under that key. In Sect. 2 of [4] there
are brief comments on combining gradual release with
delimited release [28] but no hints as to how this would
be done. Gradual release is proved to be enforced
by a standard type system including the constraint
that declass commands are low [4]. This is in accord
with our result, since we use essentially the same
type system and one can take every ﬂowspec to have
agreements for all secrets read by the declass.
Any logic or veriﬁcation system can be used to
discharge the “valid pre-assertion” proof obligation,
Def. 6.2(2), —e.g., tools like ESC/Java and Spec# [7]
which can reason about pointer isolation (see Sect. 8).
To verify relational correctness, Def. 6.2(3), Ben-
ton’s [8] relational logic sufﬁces for the simple imper-
ative language of Sect. 3 and is implementable by self-
composition [26]. Motivated by the less conservative
analysis provided by logics, as opposed to usual type
systems, Amtoft et al [1] develop a relational logic
for object-based programs, using regions to express
agreements (there called “independences”) for anony-
mous objects. Besides the ability to prevent illegal
ﬂows while allowing standard programming idioms
including low/high aliases to objects with both low and
high ﬁelds, the other beneﬁt is the ability to express
ﬁne-grained ﬂow policies as we have proposed here.
Our use of state predicates in release policy is
inspired by Chong and Myers [11], who formulate the
idea in an elegant way, relative to an abstract notion
of “conditions” and means for verifying them. Policy
is expressed by fancy types that label variables and
designate a series of “conditions” following which the
secret may be released. They do not give examples
where it is a temporal series of events, though the
security property caters for that. Our proposal is more
deﬁnite (and so less general) in tying conditions to
state predicates, which can express past events using
speciﬁcation-only history variables (indeed, relevant
history is often already available in the program state).
Their security property is rather weak, as pointed
out in [29]: the program is noninterferent until the
conditions have been true, after which there is no
constraint on what might leak. Another proposal for
state-dependent labels [10] conditions the level on a
boolean ghost variable subject to updates in program
annotations which thereby express where in the code
declassiﬁcation is allowed. This is subsumed by our
proposal.
As discussed in more detail elsewhere [4], [21],
[29], several interesting proposals treat “where” declas-
siﬁcation policies using notions of bisimulation that
“reset” the program state at each release, in a way
that for sequential code does not correspond to feasible
attacks. Pre-assertions can sensibly be combined with
any means to specify where in the code declassiﬁcation
is permitted, perhaps even achieving an end-to-end
property like CGR.
Askarov and Sabelfeld [5] give a combination of
“what” and “where” policies, dubbed localized de-
limited release, different from ours. The idea is to
instrument the semantics to track expressions that have
been declassiﬁed. The security property is deﬁned as a
kind of bisimulation where indistinguishability is with
respect to the expressions that have been declassiﬁed
“up to now”. The property is termination insensitive
and differs from gradual release in that, although
release cannot happen unless a declass command ex-
ecutes,
the actual change in knowledge may come
later, as illustrated by the example h 0
:= h; h :=
0; l := declassify(h); h := h 0; l := h, where nothing is
learned at the declass step, but h is learned in the last
step. Allowing such tardy release might be difﬁcult to
reconcile with “when” policies like the accurate audit
log in our Sect. 2. Localized delimited release is said
to adhere to the prudent principles and is shown to be
enforced by the type system for delimited release [28],
with the additional restriction against declassiﬁcation
under high branch conditions. It could be interesting
13
to adapt the work to use more semantic reasoning
about equivalence of expressions, and to incorporate
assertions in policies. It does not seem obvious how to
adapt the instrumented semantics to features of richer
languages, such as heap objects.
10. Discussion
We extend the gradual release security property [4],
which uses knowledge to describe information ﬂow,
with state conditions and agreements. Conditioned
gradual release is able to capture conditions under
which secrets are released, the extent to which they are
released, and the absence of ﬂows except by explicit
downgrading actions. Our policy speciﬁcations make
simple use of static security labels and program as-
sertions so that information policy can be tied directly
with application requirements and access mechanisms.
Our enforcement r´egime combines simple type-based
rules with program veriﬁcation. To prove soundness,
we devised an apparently novel technique: Owing to
declassiﬁcation it does not seem possible to deﬁne a
notion of simulation (or unwinding conditions) of the
usual sort; in some sense our proof constructs a simula-
tion instance for a given pair of runs. Working out the
details led to revision of several obvious but wrong
deﬁnitions. We believe that our proofs address the
main complications and that the technique will extend
to the more complicated notion of low-equivalence
used for heaps in both [1] and [33] for Jif-style level-
polymorphic typing. Heap data structures are essential
for many applications.
Zdancewic
[38]
poses
three
results
simple
“challenges
typechecking (for
for
is integration
information-ﬂow security”. The ﬁrst
suggest
with existing infrastructure. Our
the use of
security-
labeled types) together with modest use of program
speciﬁcation for subprograms that must be exempt
because of declassiﬁcation or because typechecking
is too conservative. Our approach ﬁts well with
access control. For example,
the currently-enabled
permissions in Java stack inspection can be tracked in
a ghost variable [30] so ﬂowspecs can express what
is released given various privileges (cf. [6]). (Perhaps
schematic ﬂowspecs as in Sect. 4.) Zdancewic’s
second challenge is to “escape the conﬁnes of pure
noninterference”; he mentions both declassiﬁcation
and conservativity of ﬂow-insensitive static analysis.
The third challenge is to manage complex policies.
We conjecture that such policies should mostly be
expressed using ordinary program speciﬁcations
including state-based descriptions of sophisticated
access controls.
Sabelfeld and Sands [29] suggest informal princi-
ples, with which our proposal seems to be in accord.
Semantic consistency says that replacement of a “de-
class free” subprogram by a semantically equivalent
one does not affect security. For an attacker model
in which intermediate states are visible, the relevant
notion of equivalence is trace equivalence; for this,
our proposal
is semantically consistent. Of course
such ﬁne-grained observations disallow many standard
:= l , so
compiler optimizations, even skip for l
one must take the principle, and theoretical models
like ours, with a grain of salt. The principle of con-
servativity amounts to our Proposition 5.7. This is
problematic for [11] because their notion of security
is not purely semantic. The principle of monotonicity
of release says that adding a declassiﬁcation cannot
make a secure program insecure. This presupposes
a treatment of declassiﬁcation in which there is an
explicit construct that can be “added” to a program.
Unlike Jif and similar notations, our declass construct
is distinct from policy speciﬁcations; if we wrap l := l
in a declass, we had better also add a baseline ﬂowspec,
ﬂow pre A(l ) mod l , or CGR is violated. The
principle of non-occlusion says that adding declassi-
ﬁcation cannot make an insecure program secure. Our
proposal satisﬁes the principle, since the semantics
of an assignment is not altered by marking it as a
declass. A natural extension of our work is to add
atomic blocks to the language (c.f. [16]) which would
embody a more realistic attacker model for many
purposes. Declassiﬁcation of atomic blocks would not
risk occlusion.
Acknowledgements. The exposition in this version
of the paper is improved thanks to feedback from
Aslan Askarov, Paul Karger, Andrei Sabelfeld, and
anonymous referees. We also thank the organizers
and participants of the Dagstuhl Seminar on Mobility,
Ubiquity and Security, held in February 2007.
References
[1] T. Amtoft, S. Bandhakavi, and A. Banerjee. A logic
In
for information ﬂow in object-oriented programs.
POPL, pages 91–102, 2006.
[2] T. Amtoft and A. Banerjee. Veriﬁcation condition
generation for conditional information ﬂow. In FMSE,
2007.
[3] A. Askarov and A. Sabelfeld. Secure implementation
of cryptographic protocols: A case study of mutual
distrust. In ESORICS, pages 197–221, 2005.
14
[4] A. Askarov and A. Sabelfeld. Gradual release: Unifying
declassiﬁcation, encryption and key release policies.
In IEEE Symp. Security and Privacy, pages 207–221,
2007.
[5] A. Askarov and A. Sabelfeld. Localized delimited
release: combining the what and where dimensions of
information release. In PLAS, pages 53–60, 2007.
[6] A. Banerjee and D. A. Naumann. Stack-based access
control for secure information ﬂow. Journal of Func-
tional Programming, 15(2):131–177, 2005.
Special
issue on Language Based Security.
[21] H. Mantel and A. Reinhard. Controlling the what and
where of declassiﬁcation in language-based security. In
ESOP, pages 141–156, 2007.
[22] P. M¨uller. Modular Speciﬁcation and Veriﬁcation of
Object-Oriented Programs, volume 2262 of LNCS.
Springer-Verlag, 2002.
[23] P. M¨uller and A. Rudich. Ownership transfer in
universe types. In OOPSLA, pages 461–478, 2007.
[24] A. C. Myers. JFlow: Practical mostly-static information
ﬂow control. In POPL, pages 228–241, 1999.
[7] M. Barnett, K. R. M. Leino, and W. Schulte. The Spec#
programming system: an overview. In CASSIS, 2004.
[25] D. A. Naumann. Verifying a secure information ﬂow
analyzer. In TPHOLS, pages 211–226, 2005.
[8] N. Benton. Simple relational correctness proofs for
static analyses and program transformations. In POPL,
pages 14–25, 2004.
[26] D. A. Naumann. From coupling relations to mated
invariants for secure information ﬂow and data abstrac-
tion. In ESORICS, 2006.
[9] G. Boudol. On typing information ﬂow.
In ICTAC,
2005.
[10] N. Broberg and D. Sands. Flow locks. In ESOP, pages
180–196, 2006.
[27] J. Rushby. Noninterference, transitivity, and channel-
control security policies. Technical report, SRI, Dec.
1992.
[28] A. Sabelfeld and A. C. Myers. A model for delimited
information release. In ISSS, 2004.
[11] S. Chong and A. C. Myers.
Security policies for
downgrading. In ACM CCS, pages 198–209, 2004.
[29] A. Sabelfeld and D. Sands. Dimensions and principles
of declassiﬁcation. Journal of Computer Security, 2007.
[12] D. Clarke and S. Drossopoulou. Ownership, encapsula-
tion and the disjointness of type and effect. In OOPSLA,
pages 292–310, 2002.
[30] J. Smans, B. Jacobs, and F. Piessens. Static veriﬁcation
of code access security policy compliance of .NET
applications. Journal of Object Technology, 2006.
[13] E. S. Cohen.
Information transmission in sequential
In R. DeMillo, D. Dobkin, A. Jones, and
programs.
R. Lipton, editors, Foundations of Secure Computation,
1978.
[14] B. Cook, A. Podelski, and A. Rybalchenko. Termina-
tion proofs for systems code. In PLDI, 2006.
[15] D. E. Denning. Cryptography and Data Security. 1982.
[16] C. Flanagan and S. Qadeer. A type and effect system
for atomicity. In PLDI, 2003.
[17] B. Hicks, D. King, P. McDaniel, and M. Hicks. Trusted
declassiﬁcation: high-level policy for a security-typed
language. In PLAS, pages 65–74, 2006.
[18] K. Hristova, T. Rothamel, Y. A. Liu, and S. D. Stoller.
Efﬁcient type inference for secure information ﬂow. In
PLAS, pages 85–94, 2006.
[19] G. T. Leavens, Y. Cheon, C. Clifton, C. Ruby, and
D. R. Cok. How the design of JML accommodates both
runtime assertion checking and formal veriﬁcation. In
FMCO. 2003.
[20] P. Li and S. Zdancewic. Downgrading policies and
relaxed noninterference. In POPL, 2005.
[31] S. F. Smith and M. Thober.
Improving usability of
information ﬂow security in java. In PLAS, pages 11–
20, 2007.
[32] M. Strecker. Formal analysis of an information ﬂow
type system for MicroJava (extended version). Techni-
cal report, Technische Universit¨at M¨unchen, July 2003.
[33] Q. Sun, A. Banerjee, and D. A. Naumann. Modular
and constraint-based information ﬂow inference for an
object-oriented language. In SAS, 2004.
[34] T. Terauchi and A. Aiken. Secure information ﬂow as
a safety problem. In SAS, pages 352–367, 2005.
[35] R. van der Meyden. What,
indeed,
is intransitive
noninterference? In ESORICS, pages 235–250, 2007.
[36] D. Volpano and G. Smith. Eliminating covert ﬂows with
minimum typings. In CSFW, pages 156–169, 1997.
[37] D. Volpano, G. Smith, and C. Irvine. A sound type
system for secure ﬂow analysis. Journal of Computer
Security, 1996.
[38] S. Zdancewic. Challenges for information-ﬂow secu-
rity. In PLID, 2004.
15