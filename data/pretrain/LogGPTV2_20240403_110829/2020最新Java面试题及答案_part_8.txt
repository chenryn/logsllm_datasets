可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，
它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内
核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程
发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何
进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接
去使用数据了。
也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完
成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的
读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据
已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号
表示IO操作已经完成，不需要再在用户线程中调用IO函数进行实际的读写操作。
注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。
更多参考： http://www.importnew.com/19816.html
2.8.1. JAVA IO包
13/04/2018 Page 36 of 283
2.8.2. JAVA NIO
NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字
符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区
中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，
数据到达）。因此，单个线程可以监听多个数据通道。
13/04/2018 Page 37 of 283
NIO和传统IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。
2.8.2.1. NIO的缓冲区
Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何
地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓
存到一个缓冲区。NIO的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在
缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所
有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的
数据。
2.8.2.2. NIO的非阻塞
IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有
一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，
使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可
用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以
继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它
完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上
执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。
13/04/2018 Page 38 of 283
13/04/2018 Page 39 of 283
2.8.3. Channel
首先说一下Channel，国内大多翻译成“通道”。Channel和IO中的Stream(流)是差不多一个
等级的。只不过Stream是单向的，譬如：InputStream, OutputStream，而Channel是双向
的，既可以用来进行读操作，又可以用来进行写操作。
NIO中的Channel的主要实现有：
1. FileChannel
2. DatagramChannel
3. SocketChannel
4. ServerSocketChannel
这里看名字就可以猜出个所以然来：分别可以对应文件IO、UDP和TCP（Server和Client）。
下面演示的案例基本上就是围绕这4个类型的Channel进行陈述的。
2.8.4. Buffer
Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel提供从文件、
网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer。
上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送
数据时，必须先将数据存入Buffer中，然后将Buffer中的内容写入通道。服务端这边接收数据必
须通过Channel将数据读入到Buffer中，然后再从Buffer中取出数据来处理。
在NIO中，Buffer是一个顶层父类，它是一个抽象类，常用的Buffer的子类有：
ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、
ShortBuffer
2.8.5. Selector
Selector类是NIO的核心类，Selector能够检测多个注册的通道上是否有事件发生，如果有事
件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可
以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用
函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护
多个线程，并且避免了多线程之间的上下文切换导致的开销。
13/04/2018 Page 40 of 283
2.9. JVM 类加载机制
JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这
五个过程。
2.9.1.1. 加载
加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对
象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既
可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），
也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。
2.9.1.2. 验证
这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并
且不会危害虚拟机自身的安全。
2.9.1.3. 准备
准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使
用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：
public static int v = 8080;
实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的put static指令是
程序被编译后，存放于类构造器方法之中。
但是注意如果声明为：
public static final int v = 8080;
在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v
赋值为8080。
2.9.1.4. 解析
解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中
的：
13/04/2018 Page 41 of 283
1. CONSTANT_Class_info
2. CONSTANT_Field_info
3. CONSTANT_Method_info
等类型的常量。
2.9.1.5. 符号引用
(cid:132) 符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟
机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引
用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。
2.9.1.6. 直接引用
(cid:132) 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有
了直接引用，那引用的目标必定已经在内存中存在。
2.9.1.7. 初始化
初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载
器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。
2.9.1.8. 类构造器
初始化阶段是执行类构造器方法的过程。方法是由编译器自动收集类中的类变
量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类
的方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译
器可以不为这个类生成()方法。
注意以下几种情况不会执行类初始化：
1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
2. 定义对象数组，不会触发该类的初始化。
3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触
发定义常量所在的类。
4. 通过类名获取Class对象，不会触发类的初始化。
5. 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初
始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
6. 通过ClassLoader默认的loadClass方法，也不会触发初始化动作。
2.9.2. 类加载器
虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提
供了3种类加载器：
13/04/2018 Page 42 of 283
2.9.2.1. 启动类加载器(Bootstrap ClassLoader)
1. 负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被
虚拟机认可（按文件名识别，如rt.jar）的类。
2.9.2.2. 扩展类加载器(Extension ClassLoader)
2. 负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类
库。
2.9.2.3. 应用程序类加载器(Application ClassLoader)：
3. 负责加载用户路径（classpath）上的类库。
JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader
实现自定义的类加载器。
2.9.3. 双亲委派
当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父
类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，
只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的
Class），子类加载器才会尝试自己去加载。
采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载
器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载
器最终得到的都是同样一个Object对象。
13/04/2018 Page 43 of 283
2.9.4. OSGI（动态模型系统）
OSGi(Open Service Gateway Initiative)，是面向Java的动态模型系统，是Java动态化模块化系
统的一系列规范。
2.9.4.1. 动态改变构造
OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使
这些耦合度可管理，OSGi技术提供一种面向服务的架构，它能使这些组件动态地发现对方。
2.9.4.2. 模块化编程与热插拔
OSGi旨在为实现Java程序的模块化编程提供基础条件，基于OSGi的程序很可能可以实现模块级
的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企
业级程序开发来说是非常具有诱惑力的特性。
OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时
也有成熟的框架进行实现支持。但并非所有的应用都适合采用OSGi作为基础架构，它在提供强大
功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。
13/04/2018 Page 44 of 283
3. JAVA 集合
3.1. 接口继承关系和实现
集合类存放于Java.util包中，主要有3种：set(集）、list(列表包含Queue）和map(映射)。
1. Collection：Collection是集合List、Set、Queue的最基本的接口。
2. Iterator：迭代器，可以通过迭代器遍历集合中的数据
3. Map：是映射表的基础接口
13/04/2018 Page 45 of 283
13/04/2018 Page 46 of 283
3.2. List
Java的List是非常常用的数据类型。List是有序的Collection。Java List一共三个实现类：
分别是ArrayList、Vector和LinkedList。
3.2.1. ArrayList（数组）
ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数
组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数
组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进
行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。
3.2.2. Vector（数组实现、线程同步）
Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一
个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，
访问它比访问ArrayList慢。
3.2.3. LinkList（链表）