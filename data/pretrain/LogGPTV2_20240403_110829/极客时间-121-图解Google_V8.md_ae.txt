# 05｜原型链: V8是如何实现对象继承的？你好，我是李兵。 在前面两节中，我们分析了什么是 JavaScript 中的对象，以及 V8内部是怎么存储对象的，本节我们继续深入学习对象，一起来聊聊 V8 是如何实现JavaScript 中对象继承的。 简单地理解，**继承就是一个对象可以访问另外一个对象中的属性和方法**，比如我有一个 B 对象，该对象继承了 A 对象，那么 B对象便可以直接访问 A对象中的属性和方法，你可以参看下图： ![](Images/440b1f32adcbc99779e6869f55250fe1.png)savepage-src="https://static001.geekbang.org/resource/image/c9/7b/c91e103f535679a4f6901d0b4ff8cb7b.jpg"}什么是继承观察上图，因为 B 继承了 A，那么 B 可以直接使用 A 中的 color属性，就像这个属性是 B自带的一样。 不同的语言实现继承的方式是不同的，其中最典型的两种方式是**基于类的设计**和**基于原型继承的设计**。 C++、Java、C#这些语言都是基于经典的类继承的设计模式，这种模式最大的特点就是提供了非常复杂的规则，并提供了非常多的关键字，诸如class、friend、protected、private、interface等，通过组合使用这些关键字，就可以实现继承。 使用基于类的继承时，如果业务复杂，那么你需要创建大量的对象，然后需要维护非常复杂的继承关系，这会导致代码过度复杂和臃肿，另外引入了这么多关键字也给设计带来了更大的复杂度。 而 JavaScript的继承方式和其他面向对象的继承方式有着很大差别，JavaScript本身不提供一个 class 实现。虽然标准委员会在 ES2015/ES6 中引入了 class关键字，但那只是语法糖，JavaScript的继承依然和基于类的继承没有一点关系。所以当你看到 JavaScript 出现了class 关键字时，不要以为 JavaScript也是面向对象语言了。 JavaScript仅仅在对象中引入了一个原型的属性，就实现了语言的继承机制，基于原型的继承省去了很多基于类继承时的繁文缛节，简洁而优美。 原型继承是如何实现的？那么，基于原型继承是如何实现的呢？我们参看下图： ![](Images/8c109b68c83377956f751aff264ebd78.png)savepage-src="https://static001.geekbang.org/resource/image/68/ca/687740eecf5aad32403cc00a751233ca.jpg"}有一个对象 C，它包含了一个属性"type"，那么对象 C是可以直接访问它自己的属性 type的，这点毫无疑问。 怎样让 C 对象像访问自己的属性一样，访问 B对象呢？ 上节我们从 V8 的内存快照看到，JavaScript的每个对象都包含了一个隐藏属性 \_\_proto\_\_ ，我们就把该隐藏属性\_\_proto\_\_ 称之为该**对象的原型(prototype)**，\_\_proto\_\_ 指向了内存中的另外一个对象，我们就把\_\_proto\_\_指向的对象称为该对象的**原型对象**，那么该对象就可以直接访问其原型对象的方法或者属性。 比如我让 C 对象的原型指向 B 对象，那么便可以利用 C 对象来直接访问 B对象中的属性或者方法了，最终的效果如下图所示： ![](Images/a474e0162e31077c547980dcbe74c29e.png)savepage-src="https://static001.geekbang.org/resource/image/6e/ac/6e0edf92883d97be06a94dc5431967ac.jpg"}观察上图，当 C 对象将它的 \_\_proto\_\_ 属性指向了 B对象后，那么通过对象 C 来访问对象 B 中的 name 属性时，V8 会先从对象 C中查找，但是并没有查找到，接下来 V8 继续在其原型对象 B 中查找，因为对象B 中包含了 name 属性，那么 V8 就直接返回对象 B 中的 name 属性值，虽然 C和 B 是两个不同的对象，但是使用的时候，B 的属性看上就像是 C的属性一样。 同样的方式，B 也是一个对象，它也有自己的 \_\_proto\_\_属性，比如它的属性指向了内存中另外一块对象A，如下图所示： ![](Images/e0e651b77ee4d2a64ce4cc974a88171e.png)savepage-src="https://static001.geekbang.org/resource/image/63/88/63bd704eb45646e2f46af426196a3d88.jpg"}从图中可以看到，对象 A 有个属性是 color，那么通过 C.color 访问 color属性时，V8 会先在 C 对象内部查找，但是没有查找到，接着继续在 C对象的原型对象 B 中查找，但是依然没有查找到，那么继续去对象 B 的原型对象A 中查找，因为 color 在对象 A 中，那么 V8就返回该属性值。 我们看到使用 C.name 和 C.color 时，给人的感觉属性 name 和 color都是对象 C本身的属性，但是实际上这些属性都是位于原型对象上，我们把这个查找属性的路径称为**原型链，**它像一个链条一样，将几个原型链接了起来。 在这里还要注意一点，不要将原型链接和作用域链搞混淆了，作用域链是沿着函数的作用域一级一级来查找变量的，而原型链是沿着对象的原型一级一级来查找属性的，虽然它们的实现方式是类似的，但是它们的用途是不同的，关于作用域链，我会在《06\| 作用域链：V8是如何查找变量的？》这节课来介绍。 关于继承，还有一种情况，如果我有另外一个对象 D，它可以和 C共同拥有同一个原型对象B，如下图所示： ![](Images/18dc5d70a933b5e187c964ffb878b7d2.png)savepage-src="https://static001.geekbang.org/resource/image/44/4a/44a91019e752ae2e7d6b709562d2554a.jpg"}因为对象 C 和对象 D 的原型都指向了对象B，所以它们共同拥有同一个原型对象，当我通过 D 去访问 name 属性或者 color属性时，返回的值和使用对象 C 访问 name 属性和 color属性是一样的，因为它们是同一个数据。 我们再来回顾下继承的概念：**继承就是一个对象可以访问另外一个对象中的属性和方法，****在****JavaScript中，我们通过原型和原型链的方式来实现了继承特性。** 通过上面的分析，你可以看到在 JavaScript中的继承非常简洁，就是每个对象都有一个原型属性，该属性指向了原型对象，查找属性的时候，JavaScript虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。所以对于JavaScript中的原型继承，你不需要把它想得过度复杂。 实践：利用 \_\_proto\_\_ 实现继承了解了 JavaScript中的原型和原型链继承之后，下面我们就可以通过一个例子，看看原型是怎么应用在JavaScript中的，你可以先看下面这段代码：     var animal = {        type: "Default",        color: "Default",        getInfo: function () {            return `Type is: ${this.type}，color is ${this.color}.`        }    }    var dog = {        type: "Dog",        color: "Black",    }在这段代码中，我创建了两个对象 animal 和 dog，我想让 dog 对象继承于animal 对象，那么最直接的方式就是将 dog 的原型指向对象animal，应该怎么操作呢？ 我们可以通过设置 dog 对象中的 \_\_proto\_\_ 属性，将其指向animal，代码是这样的：     dog.__proto__ = animal设置之后，我们就可以使用 dog 来调用 animal 中的 getInfo方法了。     dog.getInfo()你可以尝试调用下，看看输出的内容。在这里留给你一个关于"this"的小思考题：调用dog.getInfo() 时，getInfo 函数中的 this.type 和 this.color都是什么值？为什么？ 还有一点我们要注意，通常隐藏属性是不能使用 JavaScript来直接与之交互的。虽然现代浏览器都开了一个口子，让 JavaScript可以访问隐藏属性 \_protoslate-object="mark"}\_，但是在实际项目中，我们不应该直接通过\_protoslate-object="mark"}\_来访问或者修改该属性，其主要原因有两个： 1.  首先，这是隐藏属性，并不是标准定义的    ;    2.  其次，使用该属性会造成严重的性能问题。        我们之所以在课程中使用 \_protoslate-object="mark"}\_属性，主要是为了方便教学，将其他的一些复杂的概念先抛到一边，这样有利于你循序渐进地掌握我们的课程内容，但是我并不推荐你这么做。那应该怎么去正确地设置对象的原型对象呢？ 答案是使用构造函数来创建对象，下面我们就来详细解释这个过程。 构造函数是怎么创建对象的？比如我们要创建一个 dog 对象，我可以先创建一个 DogFactory的函数，属性通过参数就行传递，在函数体内，通过 this设置属性值。代码如下所示：     function DogFactory(type,color){        this.type = type        this.color = color    }然后再结合关键字"new"就可以创建对象了，创建对象的代码如下所示：     var dog = new DogFactory('Dog','Black')通过这种方式，我们就把后面的函数称为构造函数，因为通过执行 new配合一个函数，JavaScript虚拟机便会返回一个对象。如果你没有详细研究过这个问题，很可能对这种操作感到迷惑，为什么通过new关键字配合一个函数，就会返回一个对象呢？ 关于 JavaScript为什么要采用这种怪异的写法，我们文章最后再来介绍，先来看看这段代码的深层含义。 其实当 V8 执行上面这段代码时，V8会在背后悄悄地做了以下几件事情，模拟代码如下所示：     var dog = {}      dog.__proto__ = DogFactory.prototype    DogFactory.call(dog,'Dog','Black')为了加深你的理解，我画了上面这段代码的执行流程图： ![](Images/f230b03ecac08a41d8c387158056a691.png)savepage-src="https://static001.geekbang.org/resource/image/19/8c/19c63a16ec6b6bb67f0a7e74b284398c.jpg"}观察上图，我们可以看到执行流程分为三步： 1.  首先，创建了一个空白对象    dog；    2.  然后，将 DogFactory 的 prototype 属性设置为 dog    的原型对象，这就是给 dog    对象设置原型对象的关键一步，我们后面来介绍；        3.  最后，再使用 dog 来调用 DogFactory，这时候 DogFactory 函数中的    this 就指向了对象 dog，然后在 DogFactory 函数中，利用 this 对对象    dog 执行属性填充操作，最终就创建了对象    dog。    构造函数怎么实现继承？好了，现在我们可以通过构造函数来创建对象了，接下来我们就看看构造函数是如何实现继承的？你可以先看下面这段代码：     function DogFactory(type,color){        this.type = type        this.color = color        //Mammalia        //恒温        this.constant_temperature = 1    }    var dog1 = new DogFactory('Dog','Black')    var dog2 = new DogFactory('Dog','Black')    var dog3 = new DogFactory('Dog','Black')我利用上面这段代码创建了三个 dog对象，每个对象都占用了一块空间，占用空间示意图如下所示： ![](Images/f9cc591b2a96ed274a8b45578c8aae47.png)savepage-src="https://static001.geekbang.org/resource/image/9a/2b/9aff57c8992de8b11b70439797a3862b.jpg"}从图中可以看出来，对象 dog1 到 dog3 中的 constant_temperature属性都占用了一块空间，但是这是一个通用的属性，表示所有的 dog对象都是恒温动物，所以没有必要在每个对象中都为该属性分配一块空间，我们可以将该属性设置公用的。 怎么设置呢？ 还记得我们介绍函数时提到关于函数有两个隐藏属性吗？这两个隐藏属性就是name 和 code，其实函数还有另外一个隐藏属性，那就是prototype，刚才介绍构造函数时我们也提到过。一个函数有以下几个隐藏属性： ![](Images/51b26e4ff3cee8ffba4c12a8c44959d8.png)savepage-src="https://static001.geekbang.org/resource/image/ec/e7/ec19366c204bcc0b30b9b46448cbbee7.jpg"}每个函数对象中都有一个公开的 prototype属性，当你将这个函数作为构造函数来创建一个新的对象时，新创建对象的原型对象就指向了该函数的prototype 属性。当然了，如果你只是正常调用该函数，那么 prototype属性将不起作用。 现在我们知道了新对象的原型对象指向了构造函数的 prototype属性，当你通过一个构造函数创建多个对象的时候，这几个对象的原型都指向了该函数的prototype 属性，如下图所示： ![](Images/f3c7812e9135b8de2cf69772c201ac98.png)savepage-src="https://static001.geekbang.org/resource/image/1d/4d/1d5e7c1f7006974aec657e8a3e9e864d.jpg"}这时候我们可以将 constant_temperature 属性添加到 DogFactory 的prototype属性上，代码如下所示：     function DogFactory(type,color){        this.type = type        this.color = color        //Mammalia    }    DogFactory. prototype.constant_temperature = 1    var dog1 = new DogFactory('Dog','Black')    var dog2 = new DogFactory('Dog','Black')    var dog3 = new DogFactory('Dog','Black')这样我们三个 dog 对象的原型对象都指向了 prototype，而 prototype又包含了 constant_temperature属性，这就是我们实现继承的正确方式。 一段关于 new 的历史现在我们知道 new关键字结合构造函数，就能生成一个对象，不过这种方式很怪异，为什么要这样呢？要了解这背后的原因，我们需要了解一段关于关于JavaScript 的历史。 JavaScript 是 Brendan Eich发明的，那是个"战乱"的时代，各种大公司相互争霸，有Sun、微软、网景、甲骨文等公司，它们都有推出自己的语言，其中最如日中天的编程语言是Sun 的 Java，而 JavaScript 就是这个时候诞生的。当时创造 JavaScript的目的仅仅是为了让浏览器页面可以动起来，所以尽可能采用简化的方式来设计JavaScript，所以本质上来说，Java 和 JavaScript的关系就像雷锋和雷峰塔的关系。 那么之所以叫 JavaScript是出于市场原因考量的，因为一门新的语言需要吸引新的开发者，而当时最大的开发者群体就是Java，于是 JavaScript 就蹭了 Java的热度，事后，这一招被证明的确有效果。 虽然叫 JavaScript，但是其编程方式和 Java比起来，依然存在着非常大的差异，其中 Java中使用最频繁的代码就是创建一个对象，如下所示：     CreateInstance instance = new CreateInstance();当时 JavaScript 并没有使用这种方式来创建对象，因为 JavaScript中的对象和 Java 中的对象是完全不一样的，因此，完全没有必要使用关键字 new来创建一个新对象的，但是为了进一步吸引 Java程序员，依然需要在语法层面去蹭 Java 热点，所以 JavaScript中就被硬生生地强制加入了非常不协调的关键字 new，然后使用 new来创造对象就变成这样了：     var bar = new Foo()Java 程序员看到这段代码时，当然会感到倍感亲切，觉得 Java 和JavaScript 非常相似，那么使用 JavaScript也就天经地义了。不过代码形式只是表象，其背后原理是完全不同的。 了解了这段历史之后，我们知道 JavaScript 的 new关键字设计并不合理，但是站在市场角度来说，它的出现又是非常成功的，成功地推广了JavaScript。 总结好了，今天的主要内容就介绍到这里，下面我们来回顾下。 今天我们的主要目的是介绍清楚 JavaScript中的继承机制，这涉及到了原型继承机制，虽然基于原型的继承机制本身比较简单，但是在JavaScript 中，这是通过关键字 new加上构造函数来体现的。这种方式非常绕，且不符合人的直觉，如果直接上来就介绍new加构造函数是怎么工作的，可能会把你给绕晕了。 于是我先通过每个对象中都有的隐含属性\_\_proto\_\_，来介绍了什么是原型和原型链。V8 为每个对象都设置了一个\_\_proto\_\_ 属性，该属性直接指向了该对象的原型对象，原型对象也有自己的\_\_proto\_\_属性，这些属性串连在一起就成了原型链。 不过在 JavaScript 中，并不建议直接使用 \_\_proto\_\_属性，主要有两个原因。 1.  一，这是隐藏属性，并不是标准定义的；        2.  二，使用该属性会造成严重的性能问题。        所以，而是在 JavaScript 中，是使用 new加上构造函数的这种组合来创建对象和实现对象的继承。不过使用这种方式隐含的语义过于隐晦，所以理解起来有点难度。 为什么 JavaScript中要使用这种怪异的方式来创建对象？为了理解这个问题，我们回顾了一段JavaScript 的历史。由于当前的 Java非常流行，基于市场推广的考虑，JavaScript 采取了蹭 Java热度的策略，在语言命名上使用了 Java 字样，在语法形式上也模仿了Java。事实上通过这些策略，确实为 JavaScript带来了市场上的成功。不过你依然要记住，JavaScript 和 Java是完全两种不同的语言。 思考题我们知道函数也是一个对象，所以函数也有自己的 \_\_proto\_\_属性，那么今天留给你的思考题是：DogFactory是一个函数，那么"DogFactory.prototype"和"DogFactory.\_protoslate-object="mark"}\_"这两个属性之间有关联吗？欢迎你在留言区与我分享讨论。 感谢你的阅读，如果你觉得这篇文章对你有所启发，也欢迎把它分享给你的朋友。 
# 06｜作用域链：V8是如何查找变量的？你好，我是李兵。在前面我们介绍了 JavaScript的继承是基于原型链的，原型链将一个个原型对象串起来，从而实现对象属性的查找，今天我们要聊一个和原型链类似的话题，那就是作用域链。作用域链就是将一个个作用域串起来，实现变量查找的路径。讨论作用域链，实际就是在讨论按照什么路径查找变量的问题。我们知道，作用域就是存放变量和函数的地方，全局环境有全局作用域，全局作用域中存放了全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。当在函数内部使用一个变量的时候，V8便会去作用域中去查找。我们通过一段在函数内部查找变量的代码来具体看一下：    var name = '极客时间'    var type = 'global'    function foo(){        var name = 'foo'        console.log(name)        console.log(type)    }    function bar(){        var name = 'bar'        var type = 'function'        foo()    }    bar()在这段代码中，我们在全局环境中声明了变量 name 和 type，同时还定义了bar 函数和 foo 函数，在 bar 函数中又再次定义了变量 name 和 type，在 foo函数中再次定义了变量 name。函数的调用关系是：在全局环境中调用 bar 函数，在 bar 函数中调用 foo函数，在 foo 函数中打印出来变量 name 和 type的值。 当执行到 foo 函数时，首先需要打印出变量 name的值，而我们在三个地方都定义了变量name，那么究竟应该使用哪个变量呢？在 foo 函数中使用了变量 name，那么 V8 就应该先使用 foo函数内部定义的变量name，最终的结果确实如此，也符合我们的直觉。接下来，foo 函数继续打印变量 type，但是在 foo 函数内部并没有定义变量type，而是在全局环境中和调用 foo 函数的 bar 函数中分别定义了变量type，那么这时候的问题来了，你觉得 foo 函数中打印出来的变量 type 是 bar函数中的，还是全局环境中的呢？什么是函数作用域和全局作用域？要解释清楚这个问题，我们需要从作用域的工作原理讲起。每个函数在执行时都需要查找自己的作用域，我们称为函数作用域，在执行阶段，在执行一个函数时，当该函数需要使用某个变量或者调用了某个函数时，便会优先在该函数作用域中查找相关内容。我们再来看一段代码：    var x = 4    var test    function test_scope() {        var name = 'foo'        console.log(name)        console.log(type)        console.log(test)        var type = 'function'        test = 1        console.log(x)    }    test_scope()  在上面的代码中，我们定义了一个 test_scope 函数，那么在 V8 执行test_scope 函数的时候，在编译阶段会为 test_scope 函数创建一个作用域，在test_scope 函数中定义的变量和声明的函数都会丢到该作用域中，因为我们在test_scope函数中定了三个变量，那么常见的作用域就包含有这三个变量。你可以通过 Chrome 的控制台来直观感受下 test_scope函数的作用域，先打开包含这段代码的页面，然后打开开发者工具，接着在test_scope函数中的第二段代码加上断点，然后刷新该页面。当执行到该断点时，V8会暂停整个执行流程，这时候我们就可以通过右边的区域面板来查看当前函数的执行状态。![](Images/7d3875829e71b6828281eb37e669b8b0.png)savepage-src="https://static001.geekbang.org/resource/image/e3/5a/e346a7664d91a80e5d694d20ea21275a.png"}观察作用域你可以参看图中右侧的 Scope 项，然后点击展开该项，这个 Local就是当前函数 test_scope 的作用域。在 test_scope函数中定义的变量都包含到了 Local 中，如变量name、type、test，另外系统还为我们添加了另外一个隐藏变量 this，V8还会默认将隐藏变量 this存放到作用域中。另外你还需要注意下，第一个 test1，我并没有采用 var等关键字来声明，所以 test1 并不会出现在 test_scope函数的作用域中，而是属于 this 所指向的对象。（this的工作机制不是本文讨论的重点，不展开介绍。如果你感兴趣，可以在《浏览器工作原理与实践》专栏中《11 \| this：从 JavaScript 执行上下文的视角讲清楚this  slate-object="inline"》这一讲查看。）那么另一个问题来了，我在 test_scope 函数使用了变量 x，但是在test_scope 函数的作用域中，并没有定义变量 x，那么 V8 应该如何获取变量x？ 如果在当前函数作用域中没有查找到变量，那么 V8会去全局作用域中去查找，这个查找的线路就称为作用域链。全局作用域和函数作用域类似，也是存放变量和函数的地方，但是它们还是有点不一样： **全局作用域是在V8 启动过程中就创建了，且一直保存在内存中不会被销毁的，直至 V8退出。** **而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉了**。全局作用域中包含了很多全局变量，比如全局的 this值，如果是浏览器，全局作用域中还有 window、document、opener等非常多的方法和对象，如果是 node 环境，那么会有 Global、File等内容。 V8启动之后就进入正常的消息循环状态，这时候就可以执行代码了，比如执行到上面那段脚本时，V8会先解析顶层 (Top Level) 代码，我们可以看到，在顶层代码中定义了变量x，这时候 V8 就会将变量 x添加到全局作用域中。作用域链是怎么工作的？理解了作用域和作用域链，我们再回过头来看文章开头的那道思考题： "foo函数中打印出来的变量 type 是 bar函数中的呢，还是全局环境中的呢?"我把这段代码复制到下面：    var name = '极客时间'    var type = 'global'    function foo(){        var name = 'foo'        console.log(name)        console.log(type)    }    function bar(){        var name = 'bar'        var type = 'function'        foo()    }    bar()现在，我们结合 V8 执行这段代码的流程来具体分析下。首先当 V8启动时，会创建全局作用域，全局作用域中包括了 this、window等变量，还有一些全局的 Web API接口，创建的作用域如下图所示：![](Images/3400972339a036091d19d71093a0dc27.png)savepage-src="https://static001.geekbang.org/resource/image/58/77/589622b2f517ce06487d3edbe28cf277.jpg"}全局作用域V8启动之后，消息循环系统便开始工作了，这时候，我输入了这段代码，让其执行。V8会先编译顶层代码，在编译过程中会将顶层定义的变量和声明的函数都添加到全局作用域中，最终的全局作用域如下图所示：![](Images/b3589371271816e51b08dace880b8926.png)savepage-src="https://static001.geekbang.org/resource/image/53/e8/532151cb2713a229550af215962deee8.jpg"}全局作用域全局作用域创建完成之后，V8便进入了执行状态。前面我们介绍了变量提升，因为变量提升的原因，你可以把上面这段代码分解为如下两个部分：    //======解析阶段--实现变量提升=======    var name = undefined    var type = undefined    function foo(){        var name = 'foo'        console.log(name)        console.log(type)    }    function bar(){        var name = 'bar'        var type = 'function'        foo()    }    //====执行阶段========    name = '极客时间'    type = 'global'    bar()第一部分是在编译过程中完成的，此时全局作用中两个变量的值依然是undefined，然后进入执行阶段；第二部代码就是执行时的顺序，首先全局作用域中的两个变量赋值"极客时间"和"global"，然后就开始执行函数bar 的调用了。当 V8 执行 bar函数的时候，同样需要经历两个阶段：编译和执行。在编译阶段，V8 会为 bar函数创建函数作用域，最终效果如下所示：![](Images/742ababc842b0bd619a49093fc8eb8fe.png)savepage-src="https://static001.geekbang.org/resource/image/e2/ce/e2958bebf2ef52023c5e514259ae2cce.jpg"}bar函数作用域然后进入了 bar 函数的执行阶段。在 bar 函数中，只是简单地调用 foo函数，因此 V8 又开始执行 foo函数了。 同样，在编译 foo 函数的过程中，会创建 foo函数的作用域，最终创建效果如下图所示：![](Images/9c13b8d9ee8ca95c36e68a15c2a1c6ea.png)savepage-src="https://static001.geekbang.org/resource/image/9d/d5/9dc20e0f38d04ae96296787c7190cad5.jpg"}foo函数作用域好了，这时候我们就有了三个作用域了，分别是全局作用域、bar的函数作用域、foo的函数作用域。现在我们就可以将刚才提到的问题转换为作用域链的问题了：foo函数查找变量的路径到底是什么？1.  沿着 foo 函数作用域--\>bar 函数作用域--\> 全局作用域    ;    2.  还是，沿着 foo 函数作用域---\>    全局作用域？        因为 JavaScript是基于词法作用域的，词法作用域就是指，查找作用域的顺序是按照函数定义时的位置来决定的。bar和 foo 函数的外部代码都是全局代码，所以无论你是在 bar函数中查找变量，还是在 foo函数中查找变量，其查找顺序都是按照当前函数作用域--\>全局作用域这个路径来的。由于我们代码中的 foo 函数和 bar 函数都是在全局下面定义的，所以在 foo函数中使用了 type，最终打印出来的值就是全局作用域中的type。 你可以参看下面这张图：![](Images/65f523ff10ebd20da2422e3e2335b1da.png)savepage-src="https://static001.geekbang.org/resource/image/97/67/97aa9b39d241f7da6675d2514535c767.jpg"}另外，我再展开说一些。因为词法作用域是根据函数在代码中的位置来确定的，作用域是在声明函数时就确定好的了，所以我们也将词法作用域称为静态作用域。和静态作用域相对的是动态作用域，动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从**何处调用**。换句话说，作用域链是基于调用栈的，而不是基于函数定义的位置的。（动态作用域不是本文讨论的重点，如果你感兴趣，可以参考《浏览器工作原理与实践》专栏中的《10 \| 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？slate-object="inline"》这一节。）总结今天，我们主要解释了一个问题，那就是在一个函数中，如果使用了一个变量，或者调用了另外一个函数，V8将会怎么去查找该变量或者函数。为了解释清楚这个问题，我们引入了作用域的概念。作用域就是用来存放变量和函数的地方，全局作用域中存放了全局环境中声明的变量和函数，函数作用域中存放了函数中声明的变量和函数。当在某个函数中使用某个变量时，V8就会去这些作用域中查找相关变量。沿着这些作用域查找的路径，我们就称为作用域链。要了解查找路径，我们需要明白词法作用域，词法作用域是按照代码定义时的位置决定的，而JavaScript所采用的作用域机制就是词法作用域，所以作用域链的路径就是按照词法作用域来实现的。思考题我将文章开头那段代码稍微调整了下，foo函数并不是在全局环境中声明的，而是在 bar函数中声明的，改造后的代码如下所示：    var name = '极客时间'    var type = 'global'    function bar() {        var type = 'function'        function foo() {            console.log(type)        }        foo()    }    bar()那么执行这段代码之后，打印出来的内容是什么？欢迎你在留言区与我分享讨论。感谢你的阅读，如果你觉得这篇文章对你有所启发，也欢迎把它分享给你的朋友。