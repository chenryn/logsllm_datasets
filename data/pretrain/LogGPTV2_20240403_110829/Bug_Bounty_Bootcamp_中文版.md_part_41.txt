改变用户数据的操作称为状态更改操作。例如，发送推文和修改用户设置都是状态更改操作。发现
CSRF 的第一步是登录到目标网站并浏览其中寻找任何更改数据的活动。
For example, let's say you're testing *email.example.com* , a subdomain
of *example.com* that handles email. Go through all the app's
functionalities, clicking all the links. Intercept the generated
requests with a proxy like Burp and write down their URL endpoints.
例如，假设您正在测试 email.example.com，这是处理电子邮件的 example.com
子域。浏览所有应用程序的功能，点击所有链接。使用 Burp
等代理拦截生成的请求，并记录其 URL 端点。
Record these endpoints one by one, in a list like the following, so you
can revisit and test them later:
请把这些端点逐个记录在下面的列表中，方便以后回顾和测试：
**State-changing requests on ***email.example.com*****
在 email.example.com 上的状态更改请求
-   Change password: *email.example.com/password_change*
    POST request
    \"POST请求\"
    Request parameters: `        new_password       `
    请求参数：新密码
-   Send email: *email.example.com/send_email*
    POST request
    \`POST请求\`
    Request parameters: `        draft_id       ` ,
    `        recipient_id       `
    请求参数：draft_id，接收者id
-   Delete email: *email.example.com/delete_email*
    POST request
    发布请求
    Request parameters: `        email_id       `
    请求参数：电子邮件 ID
### Step 2: Look for a Lack of CSRF Protections {#c09.xhtml#h2-501546c09-0002}
Now visit these endpoints to test them for CSRFs. First, open up Burp
Suite and start intercepting all the requests to your target site in the
Proxy tab. Toggle the **Intercept** button until it reads **Intercept is
on** ( [Figure 9-3](#c09.xhtml#figure9-3){#c09.xhtml#figureanchor9-3} ).
现在访问这些端点以测试是否存在 CSRF。首先，在代理选项卡中打开 Burp Suite
并开始拦截所有指向目标站点的请求。切换到截获按钮并将其调整为"截获已开启"(见图9-3)。
![[Figure 9-3]{#c09.xhtml#figure9-3} : Set to Intercept is on to capture
your browser's traffic. Click the ***Forward*** button to forward the
current request to the server. ¶
图9-3：开启截取功能以捕获浏览器流量。点击前进按钮将当前请求发送至服务器。](image_fi/501546c09/f09003.png){.keyline}
[ ]{#c09.xhtml#Page_162 .pagebreak title="162"} Let Burp run in the
background to record other traffic related to your target site while
you're actively hunting for CSRFs. Keep clicking the **Forward** button
until you encounter the request associated with the state-changing
action. For example, let's say you're testing whether the
password-change function you discovered is vulnerable to CSRFs. You've
intercepted the request in your Burp proxy:
在你积极寻找 CSRF 时，让 Burp
在后台运行以记录与目标站点相关的其他流量。不断点击"前进"按钮，直到你遇到与状态改变操作相关的请求。例如，假设你正在测试你发现的密码更改功能是否容易受到
CSRF 的攻击。你已经在你的 Burp 代理拦截了请求。
    POST /password_change
    Host: email.example.com
    Cookie: session_cookie=YOUR_SESSION_COOKIE
    (POST request body)
    new_password=abc123
In the intercepted request, look for signs of CSRF protection
mechanisms. Use the search bar at the bottom of the window to look for
the string `      "csrf"     ` or `      "state"     ` . CSRF tokens can
come in many forms besides POST body parameters; they sometimes show up
in request headers, cookies, and URL parameters as well. For example,
they might show up like the cookie here:
在拦截请求中，寻找CSRF保护机制的迹象。使用窗口底部的搜索栏搜索字符串"csrf"或"state"。除了POST主体参数外，CSRF令牌还可以采用许多形式；它们有时也会出现在请求头、cookie和URL参数中。例如，在此处可能会像cookie一样显示：
    POST /password_change
    Host: email.example.com
    Cookie: session_cookie=YOUR_SESSION_COOKIE; csrf_token=871caef0757a4ac9691aceb9aad8b65b
    (POST request body)
    new_password=abc123
But even if you find a CSRF protection present on the endpoint, you
could try a variety of protection-bypass techniques. I'll talk about
them later in the chapter.
即使您在端点上发现了CSRF保护，您仍可以尝试各种保护绕过技术。我将在本章稍后讨论它们。
### Step 3: Confirm the Vulnerability {#c09.xhtml#h2-501546c09-0003}
After you've found a potentially vulnerable endpoint, you'll need to
confirm the vulnerability. You can do this by crafting a malicious HTML
form that imitates the request sent by the legitimate site.
在找到潜在易受攻击的端点后，您需要确认这种脆弱性。您可以通过构建恶意HTML表单来模仿合法站点发送的请求来实现这一点。
Craft an HTML page like this in your text editor. Make sure to save it
with an *.html* extension! This way, your computer will open the file
with a browser by default:
使用文本编辑器制作一个像这样的HTML页面。确保将其保存为.html扩展名！这样，您的计算机将默认使用浏览器打开文件：
       1
         2
         3
       4
The `           ` tag specifies that you're defining an HTML form.
An HTML form's `      method     ` attribute specifies the HTML method
of the request generated by the form, and the `      action     `
attribute specifies where the request will be [ ]{#c09.xhtml#Page_163
.pagebreak title="163"} sent to [ 1 ]{.CodeAnnotation
aria-label="annotation1"} . The form generates a POST request to the
endpoint *https://email.example.com/password_change* . Next are two
input tags. The first one defines a POST parameter with the name
`      new_password     ` and the value `      abc123     ` [ 2
]{.CodeAnnotation aria-label="annotation2"} . The second one specifies a
`      Submit     ` button [ 3 ]{.CodeAnnotation
aria-label="annotation3"} . Finally, the `           ` tag at
the bottom of the page contains JavaScript code that submits the form
automatically [ 4 ]{.CodeAnnotation aria-label="annotation4"} .
\标签指定了HTML表单的定义。HTML表单的method属性指定了表单生成的请求的HTML方法，而action属性指定了请求将发送到的位置1。该表单生成一个POST请求到端点https://email.example.com/password_change。接下来是两个输入标签。第一个定义了一个名为new_password和值为abc123的POST参数2。第二个指定一个提交按钮3。最后，在页面底部的\标签包含自动提交表单的JavaScript代码4。
Open the HTML page in the browser that is signed into your target site.
This form will generate a request like this:
打开已登入目标站点的浏览器中的 HTML 页面。此表单将生成以下请求：
    POST /password_change
    Host: email.example.com
    Cookie: session_cookie=YOUR_SESSION_COOKIE
    (POST request body)
    new_password=abc123
Check if your password on *email.example.com* has been changed to
`      abc123     ` . In other words, check if the target server has
accepted the request generated by your HTML page. The goal is to prove
that a foreign site can carry out state-changing actions on a user's
behalf.
检查您在email.example.com上的密码是否被更改为abc123。换句话说，检查目标服务器是否接受了您的HTML页面生成的请求。目标是证明外部网站可以代表用户执行状态更改操作。
Finally, some websites might be missing CSRF tokens but still protect
against CSRF attacks by checking if the referer header of the request
matches a legitimate URL. Checking the referer header protects against
CSRF, because these headers help servers filter out requests that have
originated from foreign sites. Confirming a CSRF vulnerability like this
can help you rule out endpoints that have referer-based CSRF protection.
一些网站可能缺少CSRF令牌，但仍通过检查请求的引用来源头（referer
header）是否匹配合法的URL来防止CSRF攻击。检查引用来源头可以防止CSRF攻击，因为这些头信息帮助服务器筛选出源于外部网站的请求。确认这样的CSRF漏洞可以帮助您排除具有基于引用来源头的CSRF保护的节点。
However, it's important for developers to remember that referer headers
can be manipulated by attackers and aren't a foolproof mitigation
solution. Developers should implement a combination of CSRF tokens and
`      SameSite     ` session cookies for the best protection.
然而，开发人员需要记住，引用头可以被攻击者操纵，且不是绝对可靠的缓解解决方案。开发人员应该实现CSRF令牌和SameSite会话cookie的组合，以获得最佳保护。
## Bypassing CSRF Protection {#c09.xhtml#h1-501546c09-0004}
Modern websites are becoming more secure. These days, when you examine
requests that deal with sensitive actions, they'll often have some form
of CSRF protection. However, the existence of protections doesn't mean
that the protection is comprehensive, well implemented, and impossible
to bypass. If the protection is incomplete or faulty, you might still be
able to achieve a CSRF attack with a few modifications to your payload.
Let's talk about techniques you can use to bypass CSRF protection
implemented on websites.
现代网站变得更加安全。现在，当您检查涉及敏感操作的请求时，它们通常会有某种形式的CSRF保护。但是，保护的存在并不意味着保护是全面的，实施良好的并且不可能被绕过。如果保护不完整或有故障，您仍然可以通过对有效载荷进行一些修改来实现CSRF攻击。让我们谈谈您可以使用的绕过实施在网站上的CSRF保护的方法。
### Exploit Clickjacking {#c09.xhtml#h2-501546c09-0004}
If the endpoint uses CSRF tokens but the page itself is vulnerable to
clickjacking, an attack discussed in [ Chapter 8 ]{.xref
itemid="xref_target_Chapter 8"} , you can exploit clickjacking to
achieve the same results as a CSRF.
如果端点使用CSRF令牌，但页面本身容易受到点击劫持攻击（第8章中讨论的一种攻击），您可以利用点击劫持来实现与CSRF相同的结果。
This is because, in a clickjacking attack, an attacker uses an iframe to
frame the page in a malicious site while having the state-changing
request [ ]{#c09.xhtml#Page_164 .pagebreak title="164"} originate from
the legitimate site. If the page where the vulnerable endpoint is
located is vulnerable to clickjacking, you'll be able to achieve the
same results as a CSRF attack on the endpoint, albeit with a bit more
effort and CSS skills.
因为在点击劫持攻击中，攻击者使用一个iframe将页面嵌入到恶意站点而将状态改变请求源自合法站点。如果存在漏洞让受攻击终端页面易于遭到点击劫持，攻击者可以在终端点上达到和CSRF攻击的同样效果，只需更多的努力与CSS技能。
Check a page for clickjacking by using an HTML page like the following
one. You can place a page in an iframe by specifying its URL as the
`      src     ` attribute of an `           ` tag. Then, render
the HTML page in your browser. If the page that the state-changing
function is located in appears in your iframe, the page is vulnerable to
clickjacking:
使用以下HTML页面检查点击劫持。您可以通过将页面的URL指定为\标记的src属性来将页面放置在iframe中。然后，在浏览器中呈现HTML页面。如果包含状态更改函数的页面出现在您的iframe中，则该页面容易受到点击劫持攻击：
        Clickjack test page
        This page is vulnerable to clickjacking if the iframe is not blank!
Then you could use clickjacking to trick users into executing the
state-changing action. Refer to [ Chapter 8 ]{.xref
itemid="xref_target_Chapter 8"} to learn how this attack works.
那么你可以使用点击劫持来欺骗用户执行状态变更操作。参考第8章以了解此攻击的工作原理。
### Change the Request Method {#c09.xhtml#h2-501546c09-0005}
Another trick you can use to bypass CSRF protections is changing the
request method. Sometimes sites will accept multiple request methods for
the same endpoint, but protection might not be in place for each of
those methods. By changing the request method, you might be able to get
the action executed without encountering CSRF protection.
您可以使用的另一种绕过CSRF保护的方法是更改请求方法。有时站点会接受相同端点的多个请求方法，但每种方法可能都没有保护措施。通过更改请求方法，您可能能够执行操作而不遇到CSRF保护。
For example, say the POST request of the password-change endpoint is
protected by a CSRF token, like this:
例如，假设密码更改终端的POST请求由CSRF令牌保护，如下所示：
    POST /password_change
    Host: email.example.com
    Cookie: session_cookie=YOUR_SESSION_COOKIE
    (POST request body)
    new_password=abc123&csrf_token=871caef0757a4ac9691aceb9aad8b65b
You can try to send the same request as a GET request and see if you can
get away with not providing a CSRF token: