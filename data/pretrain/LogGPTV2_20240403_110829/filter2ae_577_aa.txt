**作者：天宸@蚂蚁安全实验室**  
**原文链接：**
南方科技大学教授张殷干：
智能合约是运行在区块链的具备图灵完备行的分布式应用程序，在以太坊、EOS等区块链上有广泛的应用。然而，随着智能合约的普及和应用，针对智能合约的攻击事件屡见不鲜。为了帮助人们更好地理解这些漏洞的原理，蚂蚁安全实验室“智能合约安全系列
-- 举一反三总结篇”文章总结了以太坊和EOS区块链上智能合约的一些已知攻击的原理。
  * 文章首先介绍了智能合约基本概念，以及智能合约运行机制。它从隔离机制、停机机制、以及跨合约调用三部分出发，阐明了智能合约本身的工作原理以及安全机制。其次，文章按照漏洞在各个平台上的通用性高低程度，对于已经发生的若干种漏洞进行分类总结。漏洞类型分为五类：1.基础漏洞类型 2.函数接口漏洞类型 3.平台特性漏洞类型 4.充值场景漏洞类型 5.经典攻击手法区块链上再现。
  * 由于智能合约漏洞常引发大规模的经济损失，智能合约的漏洞得到了人们的广泛关注，不少相关机构都已经提出类似的漏洞总结文章。蚂蚁安全实验室这篇文章从三个新角度带给人们一些启发性：（1）以太坊和EOS两条区块链上漏洞的共性和差异，（2）从平台适用性角度对这些漏洞的分类总结，（3）针对充值场景漏洞类型的几种分类。
蚂蚁安全实验室还发表了其他关于智能合约漏洞的文章总结，其中对于每一种漏洞的介绍更为具体详细。感谢蚂蚁安全实验室为区块链平台做出的努力和贡献，也由衷希望区块链在这些安全机构的帮助上能更加安稳、蓬勃发展。
本文是智能合约安全分析系列的最后一篇文章。[在智能合约安全系列 --运行平台科普篇](https://mp.weixin.qq.com/s/yDTx2-Ia8-b1PLz8oDzDfg "在智能合约安全系列 --运行平台科普篇")，[智能合约安全系列——百万合约之母以太坊的漏洞攻防术（上集）](https://mp.weixin.qq.com/s/hi2xigJFtHXbscATbXsAng
"智能合约安全系列——百万合约之母以太坊的漏洞攻防术（上集）")，[智能合约安全系列——百万合约之母以太坊的漏洞攻防术（下集)](https://mp.weixin.qq.com/s/Fj6cZ21yuGXDT0qStLaopw
"智能合约安全系列——百万合约之母以太坊的漏洞攻防术（下集\)")，[智能合约安全系列——EOS菠菜应用篇](https://mp.weixin.qq.com/s/QAvFyfAetlwF3Vow-liEew "智能合约安全系列——EOS菠菜应用篇")之后，本文希望对智能合约安全分析系列做一个总结。
# 1 引言
智能合约安全分析系列已接近尾声了。本系列前几篇文章着重分析了以太坊和 EOS
的智能合约漏洞。分析这两个平台一方面是因为这两个平台的漏洞数量多，损失重，另一方面是因为这两个平台是很多联盟链的借鉴对象，比如摩根大通开发的 Quorum
联盟链就是从以太坊演变而来，比如多个区块链平台都支持的回滚特性也是受这两个平台的影响。
分析这两个平台的合约漏洞对分析其他平台的合约漏洞有借鉴意义。本文的主要目的是总结这些漏洞类型，举一反三地看其他平台的智能合约安全。
# 2 平台安全机制总结
智能合约的运行离不开平台支持。平台本身也提供了一些安全机制，为智能合约的运行提供了有限的安全性。
## 2.1 隔离机制
图灵完备的智能合约意味着可以编写并执行任意的逻辑，包括恶意代码。如果智能合约能直接在区块链节点的宿主系统上运行，恶意代码可以破坏宿主系统的自身数据。因此智能合约必须放在一个隔离的沙盒环境中运行。对于这个问题，每个智能合约的合约平台都提供了虚拟机。
· 以太坊有 EVM
EVM 是内存隔离的。在每次消息调用开始，EVM 都要执行清除内存操作。EVM 虚拟机能够保证不同的合约之间，内存是隔离的。
· EOS 有 EOS-VM
EOSVM 是内存安全的。EOSVM
设定合约运行环境为32位机器，但是EOSVM运行环境需为64位。也正是通过这个机制，可以高效地控制内存使用。首先，EOSVM使用mmap方法为合约映射一块略大于4G大小的虚拟地址，作为合约可访问的数据边界。当合约内访问某个地址的数据时，实际上是访问基于该虚拟地址的偏移。因为合约的运行环境设定是32位，所以不存在越界访问的问题。
## 2.2 停机机制
智能合约的执行是需要消耗资源的，在区块链世界里，资源非常珍贵，不能任由智能合约无限执行，必须要让合约在一定的条件下停下来，也就是要解决停机问题。停机问题（halting
problem）是逻辑数学中可计算性理论的一个问题。通俗地说，停机问题就是判断任意一个程序是否能在有限的时间之内结束运行的问题。
· 比特币
比特币提供的比特币脚本执行机制只能算作智能合约模型，因为比特币脚本的指令有限，且非图灵完备。也得益于这些限制，尚未发现利用比特币脚本实现的攻击案例。因为比特币脚本是非图灵完备的，且没有循环或者复杂流控制功能，不能创造无限循环或其它类型的逻辑炸弹，所以比特币脚本是可停止的。
· 以太坊
以太坊提供了图灵完备的智能合约执行机制，提供的 Solidity 语言和 EVM
能够满足开发者开发出复杂的业务逻辑。相应的，就会面临停机问题。以太坊的应对方式是计价器方式，引入了 gas
机制，在以太坊中，每一个操作都需要消耗一定量的gas，如果gas消耗完了，程序就可以停止下来。以太坊在发起每笔交易时，都会预设一定量的gas
limit，如果在执行过程中，gas被消耗完，合约就会停止执行。
· EOS
EOS 和以太坊一样，也提供了图灵完备的合约执行机制，但是 EOS 解决停机问题的方式跟以太坊不同。EOS 采用了计时器方式，EOS
利用控制执行时间来解决停机问题，即用户须要预先抵押 EOS 换取 CPU 资源（以时间为单位，如300ms），在合约执行前在关键位置注入
checktime()，执行时不断检查时间，若已超出时间上限，则停止执行。
· 联盟链
联盟链有很多，如 fabric，quorum，mychain。联盟链的停机问题更多的是靠约束参与者本身达成的。如 Fabric 使用 docker
虚拟机，可支持多种编程语言，但是 Fabric 没有计价器也没有计时器，更多的是依赖审核联盟成员的身份来约束成员不作恶。Quorum 和 Mychain
都参考了以太坊的实现，尽管保留 gas 本身，但是删除了以太坊中 gas 的定价，即 gasPrice = 0，转账时没有矿工费。gas
也就不能作为停机的依据。这两个链也是默认联盟成员自身不作恶。
## 2.3 跨合约调用控制
跨合约调用必须是确定性的静态调用——在运行前即知晓被调用合约的地址，且调用结果是确定性的。需要注意两个方面：
### 2.3.1 上下文的切换
上下文切换常发生在跨合约调用中：合约A调用合约B时，上下文应是合约A还是变更为合约B。典型例子，在Solidity中，msg.sender和storage是上下文相关的，语言提供了call,
delegateCall 来适应不同的上下文切换的需求。
在EOS中，跨合约调用的上下文永远是被调用合约，由于调用action需要显式指定调用者账户（类似solidity中的msg.sender），且storage与上下文分离，因此没有以太坊那样的问题，使用起来更加简单。
### 2.3.2 权限控制
权限控制是跨合约调用中不可避免的问题，它关系到用户的数据安全。我们来看下面这个例子：
Bob 调用合约 A 的 hi 方法，hi 中包含一个跨合约调用，形如 B.hello()，调用了合约 B 的 hello 方法。
那么问题来了：Bob 只是希望调用合约 A 的方法，而合约 A 是否有权利以 Bob 的账户调用合约 B？
EVM实际并没有考虑权限的问题。开发者在编写合约时可自行选择 call, delegateCall
中任意一种方式调用其他合约。这么做似乎并没有太大的影响，因为以太坊合约部署后任何人不能修改，也无法升级，只要用户确认了代码是符合要求的，那调用的后果就应由用户自行负责。然而，合约开发者们还是担心资产安全问题，主流的资产标准（如ERC20）都提供了授权的接口，即只有被授权的合约才能进行转移用户的相应资产，以此实现权限的控制。
而在EOS中，由于合约代码可以升级，情况则大不一样：假如合约A的运营方在某次合约升级中（或被黑客攻击）悄悄把hi方法中对合约B的合约调用改为transfer，把Bob的
xxx Token转账给自己。Bob可能并不能及时知晓代码更新，则很有可能在后续调用中触发转账操作，丢失资产。为了解决这一情况，EOS提供了两种方法：
· Bob创建新的权限，并授予合约的eosio.code权限，并指定合约A的hi和合约B的hello，如此Bob账户只能用于调用A.hi与B.hello。
· 新增了require_receipt的通知方法，它使用合约A账户而非Bob账户调用合约B，并修改上下文变量以指明来源方。
以上问题是平台为智能合约提供的最基础的安全机制。这些安全机制为智能合约的执行提供了最基本的保障，然而，事实证明，这些安全机制仍然不足以保障智能合约的安全，和现实世界中涌现出的大量的智能合约漏洞。
# 3 合约漏洞类型总结
真实世界的智能合约反反复复被攻击，合约漏洞层出不穷，攻击方式多种多样，由攻击导致的损失已超百亿美元。这些漏洞的背后是否有迹可循呢？如此巨大的代价换来的经验是否可以服务于其他链平台的合约安全？本小节试图讨论一下这个问题。我们按照漏洞在各平台的通用性的高低把漏洞类型分为
5 个类型，分开讨论。
## 3.1 基础类型漏洞类型
基础类型漏洞最为通用，每个平台都会涉及。
### 3.1.1 整数溢出/Integer Overflow
整数溢出发生的原因是因为寄存器能表示的数值位数有限，当存储的数值大于能表示的最大范围后，数值发生溢出，或称为反转。最大值溢出会变成最小值，最小值溢出会变成最大值。
C++ 语言经常会发生整数溢出问题。看一个具体的案例:
    if (p->size() < x*y) {