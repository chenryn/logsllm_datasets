在这个指令参数oparg中，实际上记录的是函数参数的个数信息，包括位置参数的个数和
的操作。我们先来回顾一下call_function（见代码清单11-4）。
[ceval,c]
代码清单11-4
所以略过了。在这一节中，我们将详细地剖析Pyhon在call_Eunction中处理函数信息
参数信息的操作，当时由于我们的目的在于快速建立Pyhon中函数调用机制的整体框架，
扩展键参数和键参数之间的关系也是如此。
函数时向函数传入数量可变的位置参数，在某些情况下，这会给程序设计带来极大的便利。
A
当Pyhon虚拟机开始执行cALL_FUNCTToN指令时，会首先获得一个指令参数oparg
在之前对无参函数的调用的剖析中，我们在cal1_function中看到了一些处理函数
Pyabject
/[2]:获得PyFunctionobject对象
扩展位置参数是位置参数的更高级的形式，一个扩展位置参数的存在允许我们在调用
第11章Python虚拟机中的函数机制
nt
int
nt
：
展键参数。
扩展键参数（excess key argument）：def （a，b，
称为扩展位置参数：
位置参数（posionalargument）：（a，b）、a和b被称为位置参数：
在Pyhon中，函数的参数根据形式的不同可以分为四种类别，分别如下所示：
键参数：
参数类别
一深度探索动态语言核心技术
=oparg &Oxff;
处理函数参数信息
na
**pfune
pfune,
nk:
(*pp_stack)
&oxf：
**keys)，其中的**key被称为扩
---
## Page 257
此一举了吗？实际上，在Pyon中，函数参数和函数的局部变量关系非常密切，在某种
参数扯上关系呢？如果co_nlocals包含着函数参数的个数，那么co_argcount不就是多
输出了函数对应的ryCodeobject对象中维护的两个与参数有关的信息：co_argcount和
观察拥有不同种类参数的函数中的na和nk究竟是多少。在输出na和nk的同时，我们还
数的个数。下面我们将通过修改Python源代码，在call1_function中添加输出信息，来
和256个键参数，不过这已经足够了，估计没有哪个变态的函数会需要如此多的参数。
高字节，记录着键参数的个数。因此，在理论上，Pyhon中的函数只能有256个位置参数
2.位置参数+键参数
察（左边显示的是函数调用操作的指令序列）。
们剖析的深入，你会看到函数参数和局部变量的区别和联系。下面我们开始我们的实时观
argcount来告诉Pyhon函数一共有多少个参数。是不是觉得有点晕了？不要紧，随着我
中包含了参数的数量，但是没有办法从中获得这个数量，所以还必须有另外一个co
所以只有在co_nlocals中包含参数的数量，才能为参数申请内存空间。虽然co_nloca1s
为函数申请存放局部变量的内存空间时，就需要通过co_nlocals知道局部变量的总数，
意义上，函数参数就是一种函数局部变量，它们在内存中是连续放置的。当Pyhon需要
co_nlocals.
置参数和键参数的个数。
键参数。而（na，nk）对也从（2.0）变为了（1，1）。可见，na和nk确实忠实地反映着位
同样是为第2个参数b传递参数值2，由于采用了不同的实参形式，就从位置参数变为了
仅是由函数实参的形式所决定的，而与函数定义时的形参没有任何关系。从例1到例2，
1.位置参数
CALL_FUNCTION 257
LOAD_CONST
LOADLCONST
LOAD
LOAD-NAME
CALLFUNCMION2
LOADLCONST
LOAD CONST
LOAD_NAME D(PY_fune)
从cal1_function中我们可以看到na实际上就是位置参数的个数，而nk则是键参
CALL_FUNCTTON指令参数的长度是两个字节，在低字节，记录着位置参数的个数，在
您可能觉得奇怪了，co_nlocals看上去应该表示局部变量的个数，怎么又会和函数
从例1和例2的对比可以看出，函数参数中一个参数是位置参数还是键参数实际上仪
BONST
o（Py_fune)
2（2）
1（1）
fcall
call
[cal
cal
Py_Func（l,
function]
Py_Func(a,b）
Python源码剖析
b2）
na=1,
11.4函数参数的实现
nk=1,n=3
nk=0，r=2
一深度探索动态语言核心技术
co_nlacals=2
227
---
## Page 258
228
Python源码剖析
如何知道是要替换哪个变量的默认值呢？这正是键参数的作用。
获得参数有关的信息的个数，这个个数正是n。由于位置参数会导致一条LOAD_CONST指
Function中，如果我们想成功地回退到运行时栈中pyFunctionobject的位置处，必须
信息”也压入到运行时栈中，这些信息的个数会因函数的不同而不同，所以在cal1
虚拟机首先将PyFunctionobject对象压入到运行时栈，接着会将所有的与“参数有关的
pfunc就是栈顶指针回退（n+1）后的结果。从例1和例2左边的指令序列可以看到，Pyhon
那么为什么会有这个怪异的公式呢，这一切都要从的意义说起。
3.位置参数+扩展位置参数
E（b=4），我们希望替换b的默认值，而保留a和c的默认值，
必要呢？考虑一个带有默认参数值的函数deff（a=1，b=2，c=3），假如我们这样调用f：
=*pfunc这条语句使func指向运行时栈中存放的ryFunctionObject对象。在这条语句
同的。在例1中，n为2；而在例2中，n为3。这个不同源自n的计算公式：o=na+2*rk。
的结果。
将扩展位置参数*1ist作为一个局部变量了，这样才会有co_argcount=2，co_nlocals=3
值居然是2，而Py_Func的定义中明明声明了三个参数。唯一合理的解释是Python内部
nlocals的值为3还是合理的，那么最奇怪就是，表示函数参数个数的co_argcount的
数内同样没有局部变量，co_argcount和co_nlocals的值却是不相同的。如果说co
的值和co_nlocals的值是相同的，这是因为在函数内没有局部变量。但是在例3中，函
的。从na的值可以看到，扩展位置参数的信息确实被归在了位置参数一类。
键参数的位置必须在键参数之前，所以Py_Func（1，b=2，3，4）这样的函数调用是非法
含：
CALLFUNCTTON4
LOADLCONST
LOADMCONST
LOAD NAME
而键参数会导致两条LOAD_cONST指令，所以n的计算公式一定是n=na+2*nk
第11章Python虚拟机中的函数机制
在第2行输出信息中，我们发现了一些奇特的地方，在例1和例2中，co_argcount
回到cal1_function中，之前我们就曾提到，Python虚拟机会通过Pyobject*func
虽然在例1和例2中，na+nk的值是一样的，都是2，但是我们看到，n的值却是不
关于扩展位置参数的使用，有一点需要特别注意。在Python函数的参数表之中，非
为什么键参数会导致两条LOAD_CONST指令呢？换句话说，在例2中传递是否
CONSE
深度探索动态语言核心技术
O(Py_Func)
：（1qe）ounga9p>>Py_Func(1,
[call_function]:co_argcount=2;co_nlocals=3
[cal]
function]
pass
2
3
4）
nk=0
如果不传递“b’，Python
n=4
---
## Page 259
11.4.2
4.位置参数+扩展键参数
时，所有的扩展位置参数实际上是被存储在了一个PyListobject对象中。
nlocals=3的结果我们已经可以做一个大胆的猜测了，那就是，在Pyhon实现py_Func
是正确的，因为我们在图11-5中已经看到了，局部变量是属于另一个pycodeobject的。
边的指令序列可以看到，Py山on在调用函数时，没有任何涉及到局部变量的指令。这无疑也
5.位置参数+局部变量
作为一个局部变量来被对待的。
样的，而重要的不同之处就在于，在调用带参函数时，Python虚拟机必须传递参数。在这
看一看带参函数的调用过程。在带参函数的调用过程中，基本的调用流程是与无参函数一
CALLFUNCTION 514
LOAD_CONST
LOADCONST
LOAD NAME
节剖析函数执行时如何对函数参数进行访问。
析
一节中，我们将重点部析位置参数的传递过程，对于键参数的传递会在后面的小节进行剖
CAIL_FUNCTION 2
LOAD_CONST
LOAD_NAME
LOAD CONST
LOAD
co_nlocals的值，实际上不论这里传递的是多少个函数，都不能影响co_argcount
我们还能看到，尽管我们调用函数时传递了四个参数，但是这丝毫不能影响co_argcount
这里co_nlocals=3是理所当然的，因为 Py_Func内确实含有一个局部变量了。从左
从co_argcount和co_nlocals的值可以看到，扩展键参数在Python内部同样也是
前面我们已经分析了无参函数的调用过程，在这一节中，我们要在此基础上更进一步，
位置参数的传递
我们通过对func_1.py的剖析来研究位置参数的传递，同时，这个文件也用于下一小
CONST
0(Py_Func)
0（Py_Func)
6（4Guido)
Python)
name")
[call_functian]
>>>Py_Fune（1,
[call
[call_function]
[call
function]
Python源码剖析
naF2,nk=0，n=2
11.4函数参数的实现
ml=2
一深度探索动态语言核心技术
n=6
author=tGuidoty
229
---
## Page 260
Python源码剖析
230
11-10和图11-11所示：
print age
22
艺
("Robert",age)
print age
[fune_1.py]
第11章
age
STORE NAME
MAKE_FUNCTION
POP_TOP
CALL_FUNCTION
LOAD_NAME
LOAD_NAME
5
STORELFAST
INPLACE_ADD
LOAD_RAST
RETURN_VALUE
LOADCONST
LOAD
PRINT NEWLINE
PRTNT
LOADLCONST
PRINT_ITEM
PRINT_TTEM
LOADLCONST
PRINT_ITEM
LOADFAST
PRINT_ITEM
深度探索动态语言核心技术
Python虚拟机中的函数机制
age):
CONST
ITEM
name,
0
图11-10func_1.py的PyCodeObject对象
(age)
("Robert')
《三》
(E)
(code object
3（）
(ebe)
(0be)
(name
(None)
age,
中的常量表和符号表如图
---
## Page 261
fast_function(PyobjecE *func,Pyobject ***pp_stack,Int n,int na,int nk)
代码清单11-5
序流程进入fast_function（见代码清单11-5）。
*func正确地指向了运行时栈中存储的那个代表着王的PyFunctionobject对象。然后程
数，所谓位置参数，就是如主中所见的一般的参数。而oparg中高字节包含了另一种参数
statie
[ceval.c]
指令，其指令参数为2
static Pyobject*call_funetlon（Pyobject ***pp_stack,int oparg)
却有三条LOAD指令。这三条LOAD指令执行完成后运行时栈的情况如图11-12所示：
之前，只有一个LOADNAMEO，而在编译后的func_1py中，在CALL_FUNCTION之前，
[ceval.c]
PyCodeobiect co=(PyCodeobject ) PyFunction_CET_coDE(func):
前面我们提到，CALL_FUNCTION的指令参数oparg中，低字节包含了位置参数的个
可以看到，函数需要的参数已经被压入到了运行时栈中了。接下来执行CALLFUNCTION
int
ohiect
Pyobject
**pfunc
图11-12CALL_FUNCTION指令执行前的运行时栈
图11-11func_1.py中函数f的PyCodeObject对象
*pfunc;
c/varhlames>
sint
cNorieObject/>
>
"Robert"
Python源码剖析
age=5
11.4
一深度探索动态语言核心技术
函数参数的实现
231
---
## Page 262
Python源码剖析