解决之道：“采用良好的OO软件设计原则”。
如果能有一种建立软件的方
法，好让我们可以用一种对既有
的代码影响最小的方式来修改软件该有
多好。我们就可以花较少时间重做代码，
而多让程序去做更酷的事
PDG
你现在的位置》
7
---
## Page 44
不变的是变化
软件开发的一个不变真理
好吧！在软件开发上，有什么是你可以深信不疑的？
不管你在何处工作，构建些什么，用何种编程语言，在软件开发上，一直伴随你的那个不变真
理是什么？
CHAVCE
（用镜子来看答案）
不管当初软件设计得多好，一段时间之后，总是需要成长与改变，
否则软件就会“死亡”
Sharpen yourpencil
驱动改变的因素很多。找出你的应用中需要改变代码的原因，
一一列出来。（我们写下了一些我们的原因，给你起个头。）
我们的顾客或用户需要别的东西，或老想爱新功能。
我的公司决定采用别的数据库产品，又从另一家厂商买了数据，这造成数
据格式不兼容。哦！
PDG
8
第1章
---
## Page 45
设计模式入门
把问题归零···
现在我们知道使用继承并不能很好地解决问题，因为鸭子的行
为在子类里不断地改变，并且让所有的子类都有这些行为是不
恰当的。Flyable与Quackable接口一开始似乎还挺不错，解决
了问题（只有会飞的鸭子才继承Flyable）、但是Java接口不具
有实现代码，所以继承接口无法达到代码的复用。这意味着：
无论何时你需要修改某个行为，你必须得往下追踪并在每一个
定义此行为的类中修改它，一不小心，可能会造成新的错误！
幸运的是，有一个设计原则，恰好适用于此状况。
把会变化的部分取出
并“封装”起来，好让其
设计原则
他部分不会受到影响。
找出应用中可能需要变化之处，把它
们独立出来，不要和那些不需要变化
结果如何？代码变化引起
的代码混在一起。
的不经意后果变少，系统
N
这是我们的第一个设计原则，以
变得更有弹性。
后还有更多原则会陆续在本书中
出现。
换句话说，如果每次新的需求一来，都会使某方面的代码发生
变化，那么你就可以确定，这部分的代码需要被抽出来，和其
他稳定的代码有所区分。
下面是这个原则的另一种思考方式：“把会变化的部分取出并
封装起来，以便以后可以轻易地改动或扩充此部分，而不影响
不需要变化的其他部分”。
这样的概念很简单，几乎是每个设计模式背后的精神所在。所
有的模式都提供了一套方法让“系统中的某部分改变不会影响
其他部分”。
好，该是把鸭子的行为从Duck类中取出的时候了！
PD
你现在的位置，9
---
## Page 46
抽出变化的部分
分开变化和不会变化的部分
从哪里开始呢？就我们目前所知，除了fyO和quackO的问题之外，Duck类还算一切正常，似乎
没有特别需要经常变化或修改的地方。所以，除了某些小改变之外，我们不打算对Duck类做太
多处理。
现在，为了要分开“变化和不会变化的部分”，我们准备建立两组类（完全远离Duck类），一
个是“fy”相关的，一个是“quack”相关的，每一组类将实现各自的动作。比方说，我们可
能有一个类实现“呱呱叫”，另一个类实现“岐岐叫”，还有一个类实现“安静”。
我们知道Duck类内的fly(）和quack（）会随着鸭子的不同而改变。
为了要把这两个行为从Duck类中分开，我们将把它们从Duck类
中取出来，建立一组新类来代表每个行为。
Duck类仍是所有鸭子的超类，
但是飞行和呱呱叫的行为巴
现在飞行和呱呱叫都有它们
多种行为的实现被放
经被取出，放在别的类结构
自己的类了。
在这里。
中。
取出易于变化的部分
飞行行为
鸭子类
胍呱叫行为
鸭子行为
PDG
10
第1章
---
## Page 47
设计模式入门
设计鸭子的行为
如何设计那组实现飞行和呱呱叫的行为的类呢？
我们希望一切能有弹性，毕竞，正是因为一开始鸭子行为没有
弹性，才让我们走上现在这条路。我们还想能够“指定”行为
到鸭子的实例。比方说，我们想要产生一个新的绿头鸭实例，
并指定特定“类型”的飞行行为给它。干脆顺便让鸭子的行为
可以动态地改变好了。换句话说，我们应该在鸭子类中包含设
定行为的方法，这样就可以在“运行时”动态地“改变”绿头
从现在开始，鸭子的行
鸭的飞行行为。
为将被放在分开的类中，
有了这些目标要实现，接着看看第二个设计原则：
此类专门提供某行为接
设计原则
口的实现。
针对接口编程，而不是针对实现
编程。
这样，鸭子类就不再需
要知道行为的实现细节。
我们利用接口代表每个行为，比方说，FlyBehavior与Quack
Behavior，而行为的每个实现都将实现其中的一个接口。
所以这次鸭子类不会负责实现Flying与Quacking接口，反而是由
我们制造一组其他类专门实现FlyBehavior与QuackBehavior，这
就称为“行为”类。由行为类而不是Duck类来实现行为接口。
这样的做法迥异于以往，以前的做法是：行为来自Duck超类的
具体实现，或是继承某个接口并由子类自行实现而来。这两种
interfaceos
做法都是依赖于“实现”，我们被实现绑得死死的，没办法更
FlyBehavlor
改行为（除非写更多代码）。
dy
在我们的新设计中，鸭子的子类将使用接口（FlyBehavior与
QuackBehavior）所表示的行为，所以实际的“实现”不会被绑
FlyWithWings
FlyNoWay
死在鸭子的子类中。（换句话说，特定的具体行为编写在实现了
9y0 {
fy0 (
FlyBehavior与QuakcBehavior的类中）。
实现鸭子的飞行动作
什么都不做，不会飞！
你现在的位置
11
---
## Page 48
针对接口编程
我不懂你为什么非要把
FlyBehavior设计成接口。为何不使
用抽象超类，这样不就可以使用多
态了吗？
“针对接口编程”真正的意思是“针对超类型
(supertype）编程”。
这里所谓的“接口”有多个含义，接口是一个“概
念”，也是一种Java的interface构造。你可以在不涉及
Javainterface的情况下，“针对接口编程”，关键就在多
态。利用多态，程序可以针对超类型编程，执行时会根据
实际状况执行到真正的行为，不会被绑死在超类型的行为
上。“针对超类型编程”这句话，可以更明确地说成“变
量的声明类型应该是超类型，通常是一个抽象类或者是一
个接口，如此，只要是具体实现此超类型的类所产生的对
象，都可以指定给这个变量。这也意味着，声明类时不用
理会以后执行时的真正对象类型！”
这可能不是你第一次听到，但是请务必注意我们说的是同
一件事。看看下面这个简单的多态例子：假设有一个抽象
抽象超类型可以是抽象
类Animal，有两个具体的实现（Dog与Cat）继承Animal。
类“或”接口
做法如下：
“针对实现编程”
声明变量“”为Dos类型（是
Dog d = new Dog( );
Aximal的具体实现），会造成我们必
Animal
d.bark( );
须针对具体实现编码
makeSound()
但是，“针对接口/超类型编程”做法会如下：
我们知道该对象是狗，但是我
Animal animal = new Dog( );
animal.makeSound( );
们现在利用animal进行多态的
具体实现
调用。
更棒的是，子类实例化的动作不再需要在代码中硬编码，
Boa
Cat
例如newDogO，而是“在运行时才指定具体实现的对象”
makeSound( {
makeSound0 {
bark( );
meow( );
a = getAnimal( );
我们不知道实际的子类型是“什
a.makeSound();
bark() {1/ 汪汪叫}
meow(){/l 喵喵叫}
么”……….我们只关心它知送如何正
确地进行makeSound（的动作就够了。
12
第1章
---
## Page 49
设计模式入门
实现鸭子的行为
在此，我们有两个接口，FlyBehavior和QuackBehavior，还有它们对应的
类，负责实现具体的行为：
这是一个接口，所有飞行类都
呱呱叫行为也一样，一个接口只
实现它，所有新的飞行类都必
包含一个需要实现的guack（）方法。
须实现ly方法。
>
QuackBehavior
>
FlyBehavior
fly()
quack()
FlyWithWings
FlyNoWay
Quack
Squeak
MuteQuack
fy0 {
fyO {
quack() (
quack0 (
quack() {
Ⅱ实现鸭子飞行
Ⅱ什么都不微，不会飞
实现鸭子呱呱叫]
橡皮鸭子吱哎叫
什么都不做，不会叫
真的呱呱叫
这里实现了所有不会
名为呱呱叫，其实
这里实现了所有有翅膀
名为或或叫，
卫
的鸭子飞行动作
飞的鸭子的动作
是吱吱叫
实不出声
这样的设计，可以让飞行和呱呱叫的动作被其他
的对象复用，因为这些行为已经与鸭子类无关了。
这么一来，有了继承的
用”好处，却没有继承所带
来的色。
而我们可以新增一些行为，不会影响到既有的行
为类，也不会影响“使用”到飞行行为的鸭子类。
你现在的位置
13
---
## Page 50
类中的行为
thereareno
DumbQuestions
问：
我是不是一定要先把系统做出来，再看看有
哪些地方需要变化、然后才回头去把这些地方分离&封
类不是应该代表某种“东西”吗？类不是应该同时具备
装？
状态“与”行为吗？
然
合：
不尽然。通常在你设计系统时，预先考虑到
有哪些地方未来可能需要变化，于是提前在代码中加入是既有状态（实例变量）又有方法。只是在本例中，碰
这些弹性。你会发现，原则与模式可以应用在软件开发
巧“东西”是个行为。但是即使是行为、也仍然可以有
生命周期的任何阶段。
状态和方法，例如，飞行的行为可以具有实例变量，记
问：
录飞行行为的属性（每秒翅膀拍动几下、最大高度和速
Duck是不是也该设计成一个接口？
度等）。
合：
在本例中、这么做并不恰当。如你所见的，
我们已经让一切都整合妥当，而且让Duck成为一个具
体类，这样可以让衍生的特定类（例如绿头鸭）具有
Duck共同的属性和方法。我们已经从Duck的继承结构中
删除了变化的部分，原先的问题都已经解决了、所以不
需要把Duck设计成接口。
①使用我们的新设计，如果你要加上一个火箭动力的飞
行动作到SimUDuck系统中，你该怎么做？
鸭叫声的装置）。
（DuckCall）（一种会产生
2）例如：鸭鸣器
②除了鸭子之外，你能够想出有什么类会需要用到呱呱
现FlyBehavior接口。
叫的行为？
FlyRocketPowered类，实
1）建立一个
答案：
14
第1章
---
## Page 51
设计模式入门
整合鸭子的行为
关键在于，鸭子现在会将飞行和呱呱叫的动作“委托”（delegate）别人处
理，而不是使用定义在Duck类（或子类）内的呱呱叫和飞行方法。
做法是这样的：
首先，在Duck类中“加入两个实例变量”，分别为“flyBehavior”与“quack
Behavior”，声明为接口类型（而不是具体类实现类型），每个鸭子对象都会
动态地设置这些变量以在运行时引l用正确的行为类型（例如：FlyWithWings、
Squeak等）。
我们也必须将Duck类与其所有子类中的fyO与quackO删除，因为这些行为已经被
搬到FlyBehavior与QuackBehavior类中了。
我们用两个相似的方法performFly（和performQuack（）取代Duck类中的fly（与
quackO。稍后你就会知道为什么。
实例变量在运行时持有特
行为变量被声明为
定行为的引用。
行为“接口”类型。
Duck
FlyBehavior flyBehavior 
QuackBehavior quackBehavior
这些方法取代y（）和
performQuack(
飞行行为
quack()。
swim()
→
display0
叫行为
performFly()
鸭子行为
鸭子的其他方法
②
现在，我们来实现performQuack()：
每只鸭子都会引用实现QuackBehavior接口的对
public class Duck {
QuackBehavior quackBehavior;<
//还有更多
而是
鸭子对象不亲自处理呱吸叫行为，
public void performQuack()
鑫托给quackBehavior引用的对象。
quackBehavior.quack();
很容易，是吧？想进行呱呱叫的动作，Duck对象只要叫quackBehavior对象去呱
呱叫就可以了。在这部分的代码中，我们不在乎quackBehavior接口的对象到底
是什么，我们只关心该对象知道如何进行呱呱叫就够了。
你现在的位置
15
---
## Page 52
整合鸭子的行为
更多的整合···
③好吧！现在来关心“如何设定fyBehavior与quackBehavior的实例变量”。
看看MallardDuck类：
public class MallardDuck extends Duck {
绿头聘使用Quack类处理呱呱y.所
public MallardDuck() {
quackBehavior = new Quack() ;
以当petormQuack(）被调用时.叫的
flyBehavior = new FlyWithWings ();
职贵被器托给Quack对象，而我们得