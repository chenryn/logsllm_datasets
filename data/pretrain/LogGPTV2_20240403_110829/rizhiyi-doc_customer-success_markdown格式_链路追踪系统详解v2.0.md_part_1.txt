**链路追踪系统详解**
**北京优特捷信息技术有限公司**
**日志学院 调用链研究小组 出品**
**\
**
# 目录 {#目录 .TOC-标题1}
[编写目的 [5](#编写目的)](#编写目的)
[1 基本概念 [5](#基本概念)](#基本概念)
[1.1 链路追踪系统背景 [5](#链路追踪系统背景)](#链路追踪系统背景)
[1.2 链路追踪系统概念 [6](#链路追踪系统概念)](#链路追踪系统概念)
[1.3 链路追踪系统实现原理
[7](#链路追踪系统实现原理)](#链路追踪系统实现原理)
[1.4 链路追踪产品 [9](#链路追踪产品)](#链路追踪产品)
[1.4.1 Dapper [9](#dapper)](#dapper)
[1.4.2 OpenTracing [10](#opentracing)](#opentracing)
[1.4.3 其他分布式链路追踪产品
[11](#其他分布式链路追踪产品)](#其他分布式链路追踪产品)
[2 产品架构 [12](#产品架构)](#产品架构)
[2.1 产品设计思路 [13](#产品设计思路)](#产品设计思路)
[2.1.1 设计初衷 [13](#设计初衷)](#设计初衷)
[2.1.2 实现目标 [13](#实现目标)](#实现目标)
[2.1.3 技术栈 [13](#技术栈)](#技术栈)
[2.1.4 用例图 [13](#用例图)](#用例图)
[2.1.5 流程图 [14](#流程图)](#流程图)
[2.2 功能概要说明 [16](#功能概要说明)](#功能概要说明)
[2.2.1 全局概览功能设计 [16](#全局概览功能设计)](#全局概览功能设计)
[2.2.2 全链路监控功能设计
[17](#全链路监控功能设计)](#全链路监控功能设计)
[2.2.3 系统分析功能设计 [18](#系统分析功能设计)](#系统分析功能设计)
[2.2.4 单笔链路分析功能设计
[19](#单笔链路分析功能设计)](#单笔链路分析功能设计)
[2.2.5 日志查询功能设计 [20](#日志查询功能设计)](#日志查询功能设计)
[2.2.6 Agent性能指标 [21](#agent性能指标)](#agent性能指标)
[2.3 产品功能说明 [21](#产品功能说明)](#产品功能说明)
[2.4 数据结构 [26](#数据结构)](#数据结构)
[3 部署方案 [26](#部署方案)](#部署方案)
[3.1 产品部署 [27](#产品部署)](#产品部署)
[3.1.1 介质包 [27](#介质包)](#介质包)
[3.1.2 日志易部署 [27](#日志易部署)](#日志易部署)
[3.1.3 全链路模块部署 [33](#全链路模块部署)](#全链路模块部署)
[3.2 日志规范说明 [34](#日志规范说明)](#日志规范说明)
[3.2.1 日志格式 [34](#日志格式)](#日志格式)
[3.2.2 注意事项 [38](#注意事项)](#注意事项)
[3.2.3 日志样例 [39](#日志样例)](#日志样例)
[3.3 产品操作步骤 [42](#产品操作步骤)](#产品操作步骤)
[3.3.1 北京银行全链路追踪系统使用实践
[42](#北京银行全链路追踪系统使用实践)](#北京银行全链路追踪系统使用实践)
[3.3.2 亿联银行全链路追踪系统使用实践
[51](#亿联银行全链路追踪系统使用实践)](#亿联银行全链路追踪系统使用实践)
[4 使用场景 [51](#使用场景)](#使用场景)
[4.1 使用方式 [51](#使用方式)](#使用方式)
[4.1.1 被动模式 [52](#被动模式)](#被动模式)
[4.1.2 主动模式 [52](#主动模式)](#主动模式)
[4.1.3 链路故障分析 [55](#链路故障分析)](#链路故障分析)
[4.2 北京银行全链路监控场景
[59](#北京银行全链路监控场景)](#北京银行全链路监控场景)
[4.2.1 线上消费贷额度申请
[59](#线上消费贷额度申请)](#线上消费贷额度申请)
[4.2.2 线上消费贷可提额度计算
[63](#线上消费贷可提额度计算)](#线上消费贷可提额度计算)
[4.2.3 消费贷开立发放 [64](#消费贷开立发放)](#消费贷开立发放)
[4.3 亿联银行全链路监控场景
[65](#亿联银行全链路监控场景)](#亿联银行全链路监控场景)
[4.3.1 E帐通 [65](#e帐通)](#e帐通)
[4.3.2 金融超市 [66](#金融超市)](#金融超市)
[4.3.3 网联 [69](#网联)](#网联)
[4.3.4 银联 [71](#银联)](#银联)
[4.4 山东城商行联盟全链路监控场景
[72](#山东城商行联盟全链路监控场景)](#山东城商行联盟全链路监控场景)
[4.4.1 单笔交易链路分析 [72](#单笔交易链路分析)](#单笔交易链路分析)
[4.4.2 交易类型分析 [73](#交易类型分析)](#交易类型分析)
[4.4.3 总体交易链路监控分析
[74](#总体交易链路监控分析)](#总体交易链路监控分析)
[4.4.4 cmdb系统监控分析 [74](#cmdb系统监控分析)](#cmdb系统监控分析)
[5 引用 [75](#引用)](#引用)
[5.1 互联网环境 [75](#互联网环境)](#互联网环境)
[5.2 商业环境 [76](#商业环境)](#商业环境)
[5.3 内部链接 [76](#内部链接)](#内部链接)
**\
**
**文档修订记录**
  ---------------------------------------------------------------------------
  编号   修订内容简述                            修订日期   版本号   修订人
  ------ --------------------------------------- ---------- -------- --------
  1      新建文档                                20200309   V0.1     来永茂
  2      修改使用场景框架                        20200717   V0.2     来永茂
  3      新增亿联银行全链路场景                  20200720   V0.3     刘春雨
  4      新增北京银行全链路场景                  20200721   V0.4     许龙
  5      新增部署方案操作步骤                    20200722   V0.5     许龙
  6      新增城商行联盟全链路场景                20200722   V0.6     臧广绪
  7      新增产品架构说明，合并文档调整格式      20200722   V0.7     来永茂
  8      补充北京银行全链路系统实践              20200724   V0.8     来永茂
  9      调整文档格式、字体，正式发版            20200726   V1.0     来永茂
  ---------------------------------------------------------------------------
注：对该文件内容增加、删除或修改均需填写此变更记录，详细记载变更信息，以保证其可追溯性。初建版本号从V1.0开始，之后每次以0.1递增，遇规模较大的升级，则直接跳至2.0或3.0，以此类推。
# 编写目的
通过编写该文档，用以指引公司内部人员掌握链路追踪（trace）系统的相关知识，通过该文档能够了解主流互联网和商业链路追踪系统。
1.  # 基本概念
    1.  ## 链路追踪系统背景
为什么会有链路追踪（Trace）系统这个概念？首先我们来看一下以下几个问题：
*你能说一下，自己所运维系统的网络架构吗？*
*你能说一下，自己所运维系统的业务系统架构吗？*
*你能说一下，每次业务升级或者变更是否对已有的架构图及时更新？*
*你能说一下，自己所运维的系统承载的业务类型有哪些吗？*
*你能说一下，最重要的三种业务要经由哪些模块处理吗？他们的处理流程是什么样的？*
*业务系统发生故障时，你最有效的监控发现与预警手段是什么？目前精细化程度怎么样？*
*业务系统发生故障时，你可以快速判断是自己负责的模块问题还是其他人模块问题？*
*业务系统发生故障时，你可以直接定位是哪个业务系统模块有问题？是哪一个接口出现问题？*
*业务系统发生故障时，你可以直接定位是自身接口还是下游接口遇到处理超时、数据错误、逻辑错误？*
*业务系统发生故障时，你可以快速判断影响的业务范围吗？最重要的几种业务是否受到影响？*
即使是业务系统开发者，也很难清楚的说出某个服务的调用链路，况且服务调用链路还是动态变化的，这时候只能咬咬牙翻代码了。
业务系统的不断发现，使得已有的监控手段已不能满足现在大型集群系统或跨系统的应用监控需求。
在2010年，google发表了一篇名为"Dapper, a Large-Scale Distributed Systems
Tracing
Infrastructure"的论文，文中介绍了google生产环境中大规模分布式系统下的跟踪系统Dapper的设计和使用经验。这也是最早的链路追踪应用案例。
论文中的以下描述能够看出链路追踪应用的开发背景：
*"下面举一个跟搜索相关的例子，这个例子阐述了Dapper可以应对哪些挑战。比如一个前段服务可能对上百台查询服务器发起了一个Web查询，每一个查询都有自己的Index。这个查询可能会被发送到多个的子系统，这些子系统分别用来处理广告、进行拼写检查或是查找一些像图片、视频或新闻这样的特殊结果。根据每个子系统的查询结果进行筛选，得到最终结果，最后汇总到页面上。我们把这种搜索模型称为"全局搜索"（universal
search）。总的来说，这一次全局搜索有可能调用上千台服务器，涉及各种服务。而且，用户对搜索的耗时是很敏感的，而任何一个子系统的低效都导致最终的搜索耗时增加。如果一个工程师只能知道这个查询耗时不正常，但是他无从知晓这个问题到底是由哪个服务调用造成的，或者为什么这个调用性能差强人意。首先，这个工程师可能无法准确的定位到这次全局搜索是调用了哪些服务，因为新的服务、乃至服务上的某个片段，都有可能在任何时间上过线或修改过，有可能是面向用户功能，也有可能是一些例如针对性能或安全认证方面的功能改进。其次，你不能苛求这个工程师对所有参与这次全局搜索的服务都了如指掌，每一个服务都有可能是由不同的团队开发或维护的。再次，这些暴露出来的服务或服务器有可能同时还被其他客户端使用着，所以这次全局搜索的性能问题甚至有可能是由其他应用造成的。举个例子，一个后台服务可能要应付各种各样的请求类型，而一个使用效率很高的存储系统，比如Bigtable，有可能正被反复读写着，因为上面跑着各种各样的应用......"*
Dapper应对无所不在的部署的持续监控需求，提出了低消耗、应用级的透明、延展性三个设计目标。链路追踪系统即是这些设计目标的实现。
此后，Twitter的Zipkin，Uber的Jaeger，阿里的鹰眼，美团的Mtrace等系统都是基于这篇文章而实现的。
## 链路追踪系统概念
由于分布式系统变得日趋复杂，越来越多的组件开始走向分布式化，如微服务、分布式数据库、分布式缓存等，使得后台服务构成了一种复杂的分布式网络。在服务能力提升的同时，复杂的网络结构也使问题定位更加困难。在一个请求在经过诸多服务过程中，出现了某一个调用失败，查询具体的异常由哪一个服务引起的就变得十分抓狂的情况，问题定位和处理效率是也会非常低。
分布式链路追踪就是将一次分布式请求还原成调用链路，将一次分布式请求的调用情况集中展示，比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。
## 链路追踪系统实现原理
如果对链路追踪、调用链、全链路、分布式链路追踪的概念不做区分，都理解为整个链路，那么一个链路会经过如下图的调用过程：
![/var/folders/9r/l6470myd577ftvlvqjx5_60w0000gn/T/com.microsoft.Word/WebArchiveCopyPasteTempFiles/p5932](media/image1.png){width="5.763888888888889in"
height="2.673611111111111in"}
**图 1-3-1 典型的业务调用链示意图**
该图表示一个最典型的请求调用过程，所谓链路就是把图中 (1-6)
这6个环节串连起来。在进行链路分析时，需要为每次请求定义一个唯一标识traceid，这样才能根据traceid查出本次请求调用的所有服务。
图中标示的 (1-6) 分别代表两服务之间的一个请求-应答对，我们把它定义为一个span，每个span包含以下字段：
-   spanid：请求-应答对的唯一标识；
-   name：span的名称；
-   parentspanid：父span的id，根据spanid能区分调用的先后顺序，但无法体现调用层级关系，例如上图中多个服务，可能是逐级调用的链条，也可能是同时被同一个服务调用，应该每次都用parentspanid记录下是谁调用的；
-   timestamp：span的起止时间戳（starttime、endtime）；
-   duration：span的持续时间；
-   other fields：成功状态status、错误类型errortype等。
有了timestamp字段，就可以计算出从服务调用到服务返回的总耗时，但是这个时间包含了服务的执行时间和网络延迟，有时候我们需要区分出这两类时间以方便做针对性优化。那如何计算网络延迟呢？我们可以把调用和返回的过程分为以下四个事件：
-   Client Sent，cs事件，指客户端发起调用请求到服务端；
-   Server Received，sr事件，指服务端接收到了客户端的调用请求；
-   Server Sent，ss事件，指服务端完成了处理，将信息返回给客户端；
-   Client Received，cr事件，指客户端接收到了服务端的返回信息。
![/var/folders/9r/l6470myd577ftvlvqjx5_60w0000gn/T/com.microsoft.Word/WebArchiveCopyPasteTempFiles/p5930](media/image2.jpeg){width="5.763888888888889in"
height="2.126388888888889in"}**图 1-3-2 四类事件示意图**
我们将span的四个基本事件补充到调用链图上，得到以下图示：
![/var/folders/9r/l6470myd577ftvlvqjx5_60w0000gn/T/com.microsoft.Word/WebArchiveCopyPasteTempFiles/p5928](media/image3.jpeg){width="5.763888888888889in"
height="2.776388888888889in"}
**图 1-3-3 包含四类调用事件的调用链图**
在上图中，对服务器Service0来说，会产生两个事件，一个是发起事件cs，另一个是接收事件cr。对Service1来说，首先要接收Service0请求，即事件sr，当处理完成时，作为服务端对服务器Service0进行响应，即事件ss。其它服务之间的交互事件以此类推。
规范地记录以上信息，通过对该信息进行分析统计，进而实现可视化呈现，将帮助金融企业更好地监控业务调用状态及健康度，快速实现故障定位，分析及优化业务性能瓶颈，这即是链路追踪系统的实现原理。
## 链路追踪产品
链路追踪系统实现原理主要参照google dapper和openTracing语义标准。
### Dapper
目前业界的链路追踪系统，如Twitter的Zipkin，Uber的Jaeger，阿里的鹰眼，美团的Mtrace等都基本被启发于google发表的Dapper。
Dapper阐述了分布式系统，特别是微服务架构中链路追踪的概念、数据表示、埋点、传递、收集、存储与展示等技术细节。
为了实现链路追踪，dapper提出了trace，span，annotation的概念。
Trace的含义比较直观，就是链路，指一个请求经过后端所有服务的路径，可以用下面树状的图形表示。每一条链路都用一个全局唯一的traceid来标识。
![](media/image4.png){width="2.680858486439195in"
height="2.4418405511811025in"}
**图1-4-1-1**
### OpenTracing
OpenTracing中的Trace（调用链）通过归属于此调用链的Span来隐性的定义。
特别说明，一条Trace（调用链）可以被认为是一个由多个Span组成的有向无环图（DAG图），Span与Span的关系被命名为References。
例如：下面的示例Trace就是由8个Span组成：
![](media/image5.png){width="3.852296587926509in"