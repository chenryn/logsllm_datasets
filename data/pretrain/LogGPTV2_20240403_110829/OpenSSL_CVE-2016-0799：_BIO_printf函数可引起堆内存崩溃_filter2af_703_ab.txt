    769        dynbuf = NULL;
    770        CRYPTO_push_info("doapr()");
    771        _dopr(&hugebufp, &dynbuf, &hugebufsize, &retlen, &ignored, format, args);
    772        if (dynbuf) {
    773            ret = BIO_write(bio, dynbuf, (int)retlen);
    774            OPENSSL_free(dynbuf);
    775        } else {
    776            ret = BIO_write(bio, hugebuf, (int)retlen);
    777        }
    778        CRYPTO_pop_info();
    779        return (ret);
    780    }
BIO_vprintf()可以向系统提供静态分配的缓冲区（hugebuf），其大小在hugebufsize中进行了编码处理；并且还提供了一个指向char类型指针的指针(dynbuf)。BIO_print()函数所采用的运行机制与BIO_vprintf()函数的运行机制相同。
相比之下，另外两个*printf函数－BIO_vsnprintf()和BIO_snprintf()只能够使用静态分配的缓冲区，这部分数据由调用函数提供：
    int BIO_snprintf(char *buf, size_t n, const char *format, ...)
    789    {
    790        va_list args;
    791        int ret;
    792
    793        va_start(args, format);
    794
    795        ret = BIO_vsnprintf(buf, n, format, args);
    796
    797        va_end(args);
    798        return (ret);
    799    }
    800
    801    int BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)
    802    {
    803        size_t retlen;
    804        int truncated;
    805
    806        _dopr(&buf, NULL, &n, &retlen, &truncated, format, args);
    807
    808        if (truncated)
    809            /*
    810             * In case of truncation, return -1 like traditional snprintf.
    811             * (Current drafts for ISO/IEC 9899 say snprintf should return the
    812             * number of characters that would have been written, had the buffer
    813             * been large enough.)
    814             */
    815            return -1;
    816        else
    817            return (retlen <= INT_MAX) ? (int)retlen : -1;
    818    }
漏洞信息
doapr_outch()函数中存在的一个问题就是，其他函数在调用这个函数时，如果内存分配失败，系统不会提供任何的提示信息，因为这是一个没有返回值的函数：
    *buffer = OPENSSL_malloc(*maxlen);
    714                if (!*buffer) {
    715                    /* Panic! Can't really do anything sensible. Just return */
    716                    return;
    717                }
    …
    724                *buffer = OPENSSL_realloc(*buffer, *maxlen);
    725                if (!*buffer) {
    726                    /* Panic! Can't really do anything sensible. Just return */
    727                    return;
缺少错误提示，也就意味着只要还有字符串没有输出完成，_dopr()函数就会继续调用doapr_outch()。
除此之外，在分配内存空间之前，maxlen的值会递增，这也就意味着，即使内存空间分配失败，maxlen仍然可以表示堆内存的空间大小。实际上，无论内存空间的分配成功与否，maxlen的作用都是一样的：
    *maxlen += 1024;
    712            if (*buffer == NULL) {
    713                *buffer = OPENSSL_malloc(*maxlen);
    714                if (!*buffer) {
    715                    /* Panic! Can't really do anything sensible. Just return */
    716                    return;
    717                }
因此，在内存空间分配失败之后调用doapr_outch()函数，下列代码中的条件语句将为“假”：
    710        if (buffer && *currlen == *maxlen) {
内存空间的分配失败将会导致*buffer的值被清空，但是buffer（指针）仍然是有效的。
然而，此时*currlen指针的值与*maxlen指针的值就不同了，因为在之前调用的过程中，*maxlen的值只增加了1024。
如果if条件语句中的条件为“假”，系统将会跳过函数中的大部分核心代码：
    732        if (*currlen < *maxlen) {
    733            if (*sbuffer)
    734                (*sbuffer)[(*currlen)++] = (char)c;
    735            else
    736                (*buffer)[(*currlen)++] = (char)c;
    737        }
现在，*currlen实际上就是*maxlen，而*sbuffer的值为空。因此，下列这段代码将会被执行：
    736                (*buffer)[(*currlen)++] = (char)c;
buffer变成了空指针，而currlen指针有可能指向任何内容，其指向的内容具体将取决于系统在内存分配过程中的失败信息。
*currlen指针是一个长度为32个字节的整形指针，所以当指针在使用时，它会指向一个大小不超过4GB的虚拟内存空间。但是在32位内存布局中，攻击的成功率完全取决于攻击者的技术水平，特别是当攻击者可以利用某种方式来引起相关系统中发生内存溢出的时候。
然而，一个系统中可以供OpenSSL使用的内存空间还剩多少？当前系统中正在运行的其他应用程序如果也在使用OpenSSL的话，这些应用所需要消耗的资源将会对攻击者的操作产生影响。
即使攻击者能够通过内存消耗的手段来引起内存崩溃，并实现远程代码执行，但这样的操作在攻击实践的过程中是非常困难的。而且，程序的堆内存也有可能会发生崩溃，这样将会导致存储在其中的重要数据丢失，结果将会不堪设想。这也就是我们所说的堆破坏。
而且，即使你能够保证系统中不出现恶意软件，但是堆内存空间不足将会导致系统随时可能发生堆内存崩溃。
另一种能够触发这一漏洞的方法
除此之外，还有一件有趣的事情。现在还有另外一种确切的方法可以引起OPENSSL_realloc()失败。
实际上，OPENSSL_realloc()可以算得上是CRYPTO_realloc()函数的一个宏：
    375    void *CRYPTO_realloc(void *str, int num, const char *file, int line)
    376    {
    377        void *ret = NULL;
    378
    379        if (str == NULL)
    380            return CRYPTO_malloc(num, file, line);
    381
    382        if (num <= 0)
    383            return NULL;
num是一个有符号的32位整数，如果它的值为0或者为负数的话，函数将会返回NULL。
因为在doapr_outch()函数中，*maxlen指针会在每次进行内存分配时增加1024：
    711            *maxlen += 1024;
这个值最终将会变成一个负值。然后OPENSSL_realloc()也会不可避免地发生错误，因为CRYPTO_realloc()是不会对一个大小为负值的内容进行内存分配的。
换句话说，如果我们向BIO_printf()提供一个非常大的字符串，那么就肯定能够触发这一漏洞。
**受影响的软件**
Apache httpd同样也使用了BIO_printf：
[https://github.com/apache/httpd/blob/trunk/modules/ssl/ssl_util_ocsp.c#L46](https://github.com/apache/httpd/blob/trunk/modules/ssl/ssl_util_ocsp.c%23L46)
但是，我们目前还没有对其进行分析检测，所以暂时还不知道该漏洞在这一产品中将会被如何利用。
还有一些其他著名的应用程序也使用了BIO_printf()：
[https://codesearch.debian.net/results/BIO_printf/page_0](https://codesearch.debian.net/results/BIO_printf/page_0)