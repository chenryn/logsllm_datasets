by a 32-byte HMAC-SHA with a 224-bit key that is pre-shared
between the laptop and the mobile phone. Furthermore, we use 2-
byte packet IDs, 8-byte timestamps, a 16-byte initialization vector
for AES, and 1024-bit DH-key pairs. We use base64 encoding to
transmit the packets over an RFComm Bluetooth connection and
the tool srm to perform secure deletions on the laptop.
Figure 6b displays the execution times and the standard deviation
for 100 runs as measured on the laptop. We see that key storage and
retrieval are below one second, once the Bluetooth connection has
been established. The times for key storage have a larger variance
than for key retrieval since ﬁles are created and written rather than
just read.
The key storage and delayed deletion functionality on the porter
is implemented as follows. We store the keys along with their ex-
piration times in ﬁles. To ensure the timely deletion of a ﬁle (i. e.,
key), we set an alarm service to automatically trigger the deletion of
the respective ﬁle upon the timestamp’s expiration. If the phone is
shut down and rebooted before the expiration time, a background
process (triggered by the boot-complete system broadcast) parses
the key ﬁles, deletes ﬁles with expired timestamps, and resets the
alarms. Figure 6c displays the time for setting the system alarm
for different numbers of keys (ﬁles). We see the linear dependency
of the number of keys on the alarm reset time. This background
process does not signiﬁcantly degrade the usability of the device.
Given the execution times in Figure 6 and a consumption of
1.5 kB for program storage and 0.18 kB per key, our prototype im-
plementation conﬁrms the usability of our approach in practice.
Note on Secure Deletion
When exploring implementation options, we observed that many
embedded devices have limited functionality for secure deletion
due to OS characteristics (like versioning) or hardware speciﬁcs
(e.g., NAND storage often uses log-structured sequential writes).
Enabling secure deletion on these devices is subject to recent re-
search, examples include [26] for the Android YAFFS ﬁle sys-
tem, [30] for versioning ﬁle systems, and [34] regarding data re-
manence in ﬂash memory devices. Secure deletion may not be re-
alized on certain off-the-shelf devices and care should thus be taken
in the selection of the porter device.
5.3
Integration with Applications
Given a functional porter device, our solution can be integrated
Figure 5: Scyther result for Protocol 1.
after the key is retrieved from P . This is a worst case model be-
cause early key expiration only gives the attacker more knowledge
at earlier times and thus more possibilities for attacks.
Figure 5 shows the results of the Scyther analysis. Scyther vali-
dates that no attacks exist on the model of Protocol 1 that involve
less than four honest agent runs. For bounds of four or more parallel
runs, the veriﬁcation process did not terminate (within a day) due to
the complexity of the analysis. Similar to bounded model-checking
this neither falsiﬁes the protocol nor proves its correctness, but es-
tablishes that no attacks exist within the given bounds.
4.5.3 Analysis of Protocol 2
We model Protocol 2 (Figure 4) in Scyther by two send events
over the DY channel. Messages over the physically secure channel
are not modeled as events because they are not subject to compro-
mise (as opposed to the DY channel). Consequently, we veriﬁed the
following two claims: S: claim(S,Secret,m) and R: claim(R,Secret,
m). The input ﬁle provided to the Scyther tool can be found at [2].
The automatic analysis validates that no attacks exist on the model
of Protocol 2 that involve less than ten honest agent runs. For
bounds of ten or more parallel runs, the veriﬁcation process did
not terminate (within a day).
5.
IMPLEMENTATION AND EVALUATION
We now examine possible realizations of key storage devices
(Section 5.1), describe results from our mobile phone prototype
implementation (5.2), and evaluate our solution (5.3).
5.1 Possible Realizations of Porter Devices
Dedicated Platforms. One possible realization of the porter de-
vice uses a platform that is embedded in the receiver device or
is (occasionally) attached to the receiver. Example platforms on
which porter functionality (i. e., key storage and delayed deletion)
can be implemented are dedicated hardware security modules ( [1]
is an example of a platform that offer porter functionality). Note
that our solution does not assume that the porter is tamper-resistant.
Existing TPM modules could be used as porters but their function-
ality would have to be extended with delayed key deletion. TPMs
used for this purpose must have an internal battery and clock; these
are typically available in more advanced platforms (e. g., the IBM
4758 Cryptographic Coprocessor [14]). Typically, the communica-
tion with such a dedicated platform is a physically secure channel
(a wired link); thus no additional measures are needed to guarantee
the forward secrecy of the communication to and from the porter.
Mobile Phones. Private users might not have access to dedi-
cated platforms. However access to mobile phones is widespread,
so they are natural candidates for porter devices. For most users,
their primary mobile phone is always operational and users pay
close attention to their correct functioning and charging. The us-
ability of mobile phones and personal computers has improved over
the years and there are many convenient (wireless and wired) chan-
nels through which these devices can communicate and synchro-
(a)
(b)
(c)
Figure 6: (a) Prototype implementation of the key storage (porter) functionality on a NexusOne mobile phone. (b) Protocol execution times
for the receiver. The plot shows the average times and the standard deviation for 100 runs of Protocol 1. (c) Time for resetting the system
alarm (used to delete keys at their expiration time) after a phone reboot for different numbers of keys.
in many applications, such as ﬁle storage, web services, and e-mail.
File Storage. The simplest application of our solutions is to lo-
cal ﬁle storage, where a device locally stores conﬁdential data that
should be inaccessible after the expiration time. To enable this, the
device encrypts the data locally with a key stored on a porter de-
vice. Here, our protocols can be substantially simpliﬁed: the only
communication that needs to be forward-secret is that between the
device and the porter (this can be further simpliﬁed if this chan-
nel is physically secure). Remote ﬁle storage is similar to local ﬁle
storage in that the only device that has access to the data decryption
keys is the device that created them. However, the communication
between the user’s device and the remote ﬁle server where the data
is stored must be forward-secret.
Web Services. Another application is where users share their
data (e. g., pictures, movies, ﬁles) using remote storage in the form
of a web service. The data is to be kept secret even in the case of full
device (sender and receiver) and service compromise. In contrast
to standard remote ﬁle storage, here the communication key must
be agreed upon between the sender (who uploads the data) and the
receiver(s) (who download the data). The receiver stores the key
on a porter device and obtains it when it downloads the data. The
communication used for key agreement must be forward secret.
E-mail. Finally, we consider the scenario where the sender and
the receiver wish to preserve the secrecy of their e-mail correspon-
dence.
In this scenario, the parties ﬁrst agree on the keys that
they will use for their communication and on their expiration times.
They then store the keys on their respective porter devices and ex-
change e-mail. Although we could directly use Protocol 1, it can
be optimized by making a mobile phone porter establish the keys
directly with the sender. This can be alternatively done via e-mail
exchange, without the participation of the receiver. The receiver
could be notiﬁed that the keys are established when it synchronizes
(e. g., over an IMAP server) with the e-mail communication.
6. RELATED WORK
Shoup [32] deﬁned three notions for the compromise of prin-
cipals: static corruptions (in which principals are either compro-
mised or not), adaptive corruptions (in which long-term keys may
be compromised), and strong adaptive corruptions (in which the
compromise of principals reveals both long-term and short-term
stored secrets). In our attacker model, we build on the third notion
by considering full device and user password compromise after a
speciﬁc time.
Methods for protecting data conﬁdentiality under device com-
promise include secret sharing [31], threshold cryptography [17],
and forward secrecy [22]; we focus on the last method. Canetti
et al. [13] proposed a forward-secure public-key encryption scheme
in which a receiver evolves its private key such that it can only de-
crypt messages with a later timestamp. A similar idea was adopted
by Bellare et al. [8] for forward-secure digital signature schemes.
We cannot use such approaches because private keys cannot evolve
when devices are inactive.
The conﬁdentiality of data exchanged between individuals or or-
ganizations is attracting increasing attention. Centralized systems
such as [20] for server-based sharing and storage of personal data
offer access control and data deletion at user-deﬁned or automati-
cally derived times. However, they require full trust in the service
provider to treat passwords and data conﬁdentially and to delete
both when speciﬁed. Ephemerizer-based solutions [25,28,29] sim-
ilarly require trust in a central server. As discussed in [21], this
does not ensure the data conﬁdentiality in the presence of service-
provider mismanagement and legal action to reveal data.
7. CONCLUSION
We addressed the problem of data conﬁdentiality in scenarios
where attackers can observe the communication between princi-
pals and can also fully compromise the principals after the data
has been exchanged, thereby revealing the entire state of the prin-
cipals’ devices. We explored the design space of solutions to this
problem and proposed two protocols that use key storage on porter
devices along with explicit deletion and forward secret subproto-
cols to achieve secrecy under full device, user and communication
compromise. The solutions provide users with full control over
their data privacy. We formalized our proposed solutions and an-
alyzed them using an automatic veriﬁcation tool. Our prototype
implementation shows their practicality and feasibility.
Acknowledgment
The authors thank Claudio Marforio for his work on the implemen-
tation of the prototype.
8. REFERENCES
[1] Privat Server HSM (Hardware Security Module).
http://www.arx.com/products/hsm.php.
 880 900 920 940 960OperationGeneration time for the receiver (ms)Key storageKey retrieval 0 1000 2000 3000 4000 5000 6000 0 200 400 600 800 1000Number of stored keysTime to reset the alarm (ms)Alarm reset time[2] Scyther protocol models for keeping data secret under full
compromise using porter devices. http://people.inf.
ethz.ch/cremersc/scyther/DataDeletion, Oct
2010.
[3] Chris Alexander and Ian Goldberg. Improved user
authentication in off-the-record messaging. In Proceedings
of the ACM Workshop on Privacy in the Electronic Society
(WPES), pages 41–47, New York, 2007. ACM.
[4] Bouncy Castle Crypto APIs.
http://www.bouncycastle.org.
[5] Charu Arora and Mathieu Turuani. Validating integrity for
the Ephemerizer’s protocol with CL-Atse. In Formal to
Practical Security: Papers Issued from the 2005-2008
French-Japanese Collaboration, pages 21–32. Berlin, 2009.
[6] David Basin and Cas Cremers. Degrees of security: Protocol
guarantees in the face of compromising adversaries. In
Proceedings of the 24th International Workshop on
Computer Science Logic (CSL), pages 1–18. Springer, 2010.
[7] David Basin and Cas Cremers. Modeling and analyzing
security in the presence of compromising adversaries. In
Proceedings of the European Symposium on Research in
Computer Security (ESORICS), pages 340–356. Springer,
2010.
[8] Mihir Bellare and Sara K. Miner. A forward-secure digital
signature scheme. In Proceedings of the 19th Annual
International Cryptology Conference on Advances in
Cryptology (CRYPTO), pages 431–448, London, 1999.
[9] Bluecove. Java library for Bluetooth (JSR-82
implementation). http://bluecove.org.
[10] Bluetooth SIG, Inc. Bluetooth speciﬁcation version 3.0 +
HS, 2009.
[11] Nikita Borisov, Ian Goldberg, and Eric Brewer.
Off-the-record communication, or, why not to use PGP. In
Proceedings of the ACM Workshop on Privacy in the
Electronic Society (WPES), pages 77–84, New York, 2004.
ACM.
[12] Colin Boyd and Anish Mathuria. Protocols for
Authentication and Key Establishment. Springer, 2003.
[13] Ran Canetti, Shai Halevi, and Jonathan Katz. A
forward-secure public-key encryption scheme. In
Proceedings of the Annual International Conference on the
Theory and Applications of Cryptographic Techniques
(EUROCRYPT), pages 255–271. Springer, 2003.
[14] IBM Corporation. IBM PCI Cryptographic Coprocessor.
General Information Manual. http:
//www-03.ibm.com/security/cryptocards.
[15] Cas Cremers. Scyther. A tool for the automatic veriﬁcation
of security protocols. http:
//people.inf.ethz.ch/cremersc/scyther.
[16] Cas Cremers. Scyther—Semantics and Veriﬁcation of
Security Protocols. PhD thesis, Eindhoven University of
Technology, 2006.
[17] Yvo Desmedt and Yair Frankel. Threshold cryptosystems. In
Proceedings on Advances in Cryptology (CRYPTO), pages
307–315, New York, 1989. Springer.
[18] Whitﬁeld Difﬁe, Paul C. van Oorschot, and Michael J.
Wiener. Authentication and authenticated key exchanges.
Designs, Codes and Cryptography, 2(2):107–125, 1992.
[19] Danny Dolev and Andrew C. Yao. On the security of public
key protocols. IEEE Transactions on Information Theory,
29(2):198–208, 1983.
[20] Drop. Simple real-time sharing, collaboration, presentation.
http://drop.io.
[21] Roxana Geambasu, Tadayoshi Kohno, Amit Levy, and
Henry M. Levy. Vanish: Increasing data privacy with
self-destructing data. In Proceedings of the 18th USENIX
Security Symposium, pages 299–315. USENIX Association,
2009.
[22] Christoph G. Günther. An identity-based key-exchange
protocol. In Proceedings of the Workshop on the Theory and
Application of Cryptographic Techniques on Advances in
Cryptology (EUROCRYPT), pages 29–37, New York, 1990.
Springer.
[23] Prateek Gupta and Vitaly Shmatikov. Key conﬁrmation and
adaptive corruptions in the protocol security logic. In
Proceedings of the Joint Workshop on Foundations of
Computer Security and Automated Reasoning for Security
Protocol Analysis (FCS-ARSPA), 2006.
[24] Peter Gutmann. Secure deletion of data from magnetic and
solid-state memory. In Proceedings of the 6th USENIX
Security Symposium (SSYM), Focusing on Applications of
Cryptography, pages 77–90, Berkeley, California, 1996.
USENIX Association.
[25] Disappearing Inc.
http://www.disappearing-inc.com.
[26] Jaeheung Lee, Junyoung Heo, Yookun Cho, Jiman Hong,
and Sung Y. Shin. Secure deletion for NAND ﬂash ﬁle
system. In Proceedings of the ACM Symposium on Applied
Computing (SAC), pages 1710–1714, 2008.
[27] Alfred J. Menezes, Paul C. van Oorschot, and Scott A.
Vanstone. Handbook of Applied Cryptography. CRC Press,
1997.
[28] Radia Perlman. The Ephemerizer: Making data disappear.
Journal of Information System Security, 1:51–68, 2005.
[29] Radia Perlman. File system design with assured delete. In
Proceedings of the Network and Distributed System Security
Symposium (NDSS). ISOC, 2007.
[30] Zachary N. J. Peterson, Randal Burns, Joe Herring, Adam
Stubbleﬁeld, and Aviel D. Rubin. Secure deletion for a
versioning ﬁle system. In Proceedings of the 4th USENIX
Conference on File and Storage Technologies (FAST), pages
143–154, Berkeley, California, 2005. USENIX Association.
[31] Adi Shamir. How to share a secret. Commununications of the
ACM, 22(11):612–613, 1979.
[32] Victor Shoup. On formal models for secure key exchange.
Research Report RZ 3120, IBM Research, 1999.
[33] Muthian Sivathanu, Lakshmi N. Bairavasundaram,
Andrea C. Arpaci-Dusseau, and Remzi H. Arpaci-Dusseau.
Life or death at block-level. In Proceedings of the 6th
Symposium on Operating Systems Design and
Implementation (OSDI), pages 379–394, Berkeley,
California, 2004. USENIX Association.
[34] Sergei Skorobogatov. Data remanence in ﬂash memory
devices. In Proceedings of the Cryptographic Hardware and
Embedded Systems Workshop (CHES), pages 339–353, 2005.
[35] NexusOne Smartphone. http://www.htc.com.
[36] Scott Wolchok, Owen S. Hofmann, Nadia Heninger,
Edward W. Felten, J. Alex Halderman, Christopher J.
Rossbach, Brent Waters, and Emmett Witchel. Defeating
Vanish with low-cost Sybil attacks against large DHTs. In
Proceedings of the 17th Network and Distributed System
Security Symposium (NDSS). ISOC, 2010.