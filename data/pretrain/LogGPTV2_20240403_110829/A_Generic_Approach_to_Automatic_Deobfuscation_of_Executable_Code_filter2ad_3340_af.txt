o
o
M
l
l
u
B
t
l
u
m
-
x
i
r
t
a
m
a
h
c
t
a
n
u
h
l
a
i
r
o
t
c
a
f
5
d
m
e
g
a
r
e
v
A
Coogan’s approach
Our Approach
Fig. 9. Comparison with Coogan et al.
Code coverage can be an issue since we rely on dynamic
analysis, where only one execution path through the program
is observed. To overcome this problem we apply multi-path
exploration techniques based on concolic execution to iden-
tify inputs that will exercise alternative execution paths and
increase code coverage [21], [18]. The constraints used to iden-
tify such alternative inputs are computed from an execution
trace; in our system one can use either the original (obfuscated)
trace or the simpliﬁed trace for this. Our experiments indicate
that, due to the effects of obfuscation, the original traces
are often much larger and more complex than the simpliﬁed
traces, and result in correspondingly larger and more complex
constraints whose solutions require more time and memory.
We found that, in many cases, the constraint solver (our ex-
periments used STP [32]) fails to ﬁnd a solution for constraints
obtained from the original traces, e.g., because it runs out of
time or memory, but is able to solve those obtained from the
simpliﬁed traces. The process of deobfuscation is therefore
also helpful for exploring alternative behaviors in obfuscated
executables.
688688
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:09:00 UTC from IEEE Xplore.  Restrictions apply. 
   VirtualProtect
   GetProcAddress
   GetTickCount
   LoadLibraryA
   KiUserExceptionDispatcher
   __set_app_type
   __p__fmode
   __p__commode
   _controlfp
   _initterm
   __getmainargs
   GetStartupInfoA
   GetModuleHandleA
   SetErrorMode
   FreeLibrary
   GetSystemDirectoryA
   lstrcat
   GetModuleFileNameA
   lstrcpy
   lstrcmpi
   VirtualProtect
   GetProcAddress
   LoadLibraryA
   GetTickCount
   KiUserExceptionDispatcher
   __set_app_type
   __p__fmode
   __p__commode
   _controlfp
   _initterm
   GetStartupInfoA
   __getmainargs
   GetModuleHandleA
   FreeLibrary
   SetErrorMode
   GetSystemDirectoryA
   lstrcat
   GetModuleFileNameA
   lstrcpy
Original (cropped)
Deobfuscated (cropped)
Fig. 10.
shown in green while basic blocks that perform code unpacking, i.e., write to memory locations that are subsequently executed as code, are shown in red.
Partial Control ﬂow graphs for Win32/Kryptik.OHY Trojan before and after deobfuscation. The emulation-obfuscated portion of the program is
As discussed in Section II-C, our threat model assumes
that the adversary knows our semantics-based approach to
deobfuscation. We recognize three ways in which an adversary
can try to reduce the effectiveness of our analysis. The ﬁrst
is to leave the I/O operations of the input program unchanged
but entwine the obfuscation code with the original input-to-
output computation much more deeply in order to prevent the
obfuscation code from being simpliﬁed away. The second is to
introduce additional input/output operations into the program
along with (obfuscation) code that operates on the new input-
to-output ﬂow of values that this gives rise to. The third
approach is to hide some of the computation performed by
the program.
With the ﬁrst approach, entwining the obfuscation code
with the input-to-output ﬂow of values of the original pro-
gram in a way that is semantically signiﬁcant, but which at
the same time can be guaranteed to preserve the behavior
of the program being obfuscated, is a challenging problem
in general. The reason is that even simple transformations
can affect the observable behavior of the program, e.g., by
changing use/deﬁnition relationships, introducing arithmetic
overﬂow/underﬂow, or perturbing condition code settings. This
means that any such entanglement of the obfuscation code
will, at the very least, require sophisticated program analyses
that go well beyond the capabilities of today’s obfuscation
tools. Alternatively, instead of relying on general-purpose tools
capable of obfuscating arbitrary programs, the adversary could
try to hand-craft custom malware where the obfuscation code
is semantically integrated into the program logic. While such
an approach would reduce the efﬁcacy of our approach, it
would also require a lot more time and effort for malware
writers and would not scale.
The second approach actually changes the program’s se-
mantics (i.e., its observable interactions with its environment).
Since deobfuscation must preserve program semantics, a deob-
fuscation tool cannot reasonably be expected to automatically
disregard some of the semantically signiﬁcant operations of the
program. Thus, our approach will not be able to automatically
recover the logic of the original program in this case. However,
our ideas can be easily extended to deal with such obfuscations
interactively: the tool user can (optionally) specify some set
of input and/or output operations to be disregarded, and the
deobfuscation tool can simply not perform taint propagation
for the disregarded operations.
With the third approach, some of the logic of computation
can be hidden by performing the computation elsewhere, e.g.,
689689
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:09:00 UTC from IEEE Xplore.  Restrictions apply. 
on a remote host, where it cannot be observed. We note that
this would be a problem for every approach to automatic
deobfuscation that we are aware of, and believe that it is a
fundamental limitation of any automatic deobfuscation tool.
In summary, for each of these cases we signiﬁcantly raise
the bar for obfuscation of malicious code.
VI. RELATED WORK
the most
important being that
The work that is philosophically closest to ours is that
of Coogan et al. [6], who use equational reasoning about
assembly-level instruction semantics to simplify away obfus-
cation code from execution traces of emulation-obfuscated
programs. While their goals are similar to ours, the technical
details are very different. The biggest difference between the
two is in the processing and simpliﬁcation of execution traces.
The equational reasoning approach of Coogan et al. has some
signiﬁcant drawbacks,
is
difﬁcult to control the equational simpliﬁcation, making it hard
to separate out the different components of nested loops or
complex control ﬂow. This makes it difﬁcult for their approach
to extract the logic of the underlying computation into higher-
level structures such as control ﬂow graphs or syntax trees.
By contrast, our approach offers a lot more control over the
deobfuscation process and allows us to recover higher-level
representations, such as control ﬂow graphs, with a high degree
of precision, as illustrated by the data in Figure 9. Importantly,
Coogan et al. limit themselves to emulation-based obfuscation,
and provide data only for one level of emulation; by contrast,
we are able to handle multiple levels of emulation with good
results, and applies to other kinds of programs, e.g., ROPs.
it
Sharif et al. describe an approach [5] that works from the
outside in: it ﬁrst reverse engineers the VM emulator; uses
this information to work out individual byte code instructions;
and ﬁnally, recovers the logic embedded in the byte code
program. This outside-in approach can be very effective when
the structure of the emulator meets the assumptions of the
analyzer. However, when the emulator uses techniques that do
not ﬁt these assumptions the deobfuscator may not work well.
For example, this approach does not fully deobfuscate code
that has been obfuscated using Themida, which virtualizes the
unpacker routine for emulator instructions; for such programs,
it is able to automatically recover only the unpacker logic
(rather than that of the application), with further analysis then
done manually. We have recently seen similar characteristics
in code obfuscated with other emulation-based obfuscators
as well: e.g., a malware sample for Win32/Kryptik, whose
executable we obtained from virusshare.com, was found to
have been obfuscated using Code Virtualizer, with emulation-
obfuscation applied to just
the top-level unpacker routine
rather than the application logic (see Figure 10). We conjecture
that this selective application of emulation-based obfuscation
may have been motivated by a desire to avoid the space and
time overheads that would result from applying this obfusca-
tion to the entirety of the code; nevertheless, this development
suggests that obfuscation-speciﬁc approaches that focus on
identifying and reverse-engineering the emulator may become
690690
less effective in the face of selective application of obfuscation.
This approach may also not generalize easily to code that
uses multiple layers of emulation, since it may be difﬁcult to
distinguish between instruction fetches for various emulators.
Some researchers have proposed static approaches for sim-
plifying (quasi-)interpretive code. Udupa et al. [33] discuss
techniques for deobfuscating code that has been obfuscated
using control ﬂow ﬂattening [34], which in some ways resem-
bles emulation-based obfuscation. Jones et al. [35] describe
a technique called partial evaluation for specializing away
interpretive code. The analyses and transformations described
in these works are static, which suggests that it may not be
straightforward to apply them to highly obfuscated malware
binaries, e.g., due to dynamic unpacking and self-modifying
code.
There is a signiﬁcant and growing body of literature on
return-oriented programming, but most of it deals with attacks
[7], [8], [10], [11] or defenses [9], [36]–[38]. Lu et al. discuss
the conversion of ROP shellcode to semantically equivalent
shellcode that does not use ROP [9], but this work is speciﬁc
to ROP and not a generic technique.
VII. CONCLUSIONS
This paper describes a generic approach to deobfuscation
of executable code. Instead of making strong assumptions
about the obfuscation, e.g., the structure of the emulator, we
consider the semantics of the program in terms of the input-to-
output transformation it implements, and focus on identifying,
extracting, and simplifying the code that carries out
this
transformation. We have evaluated our approach on emulation-
based obfuscation and return-oriented programs. Experiments
using sophisticated commercial obfuscation tools indicate that
our approach is effective in stripping out the obfuscation and
extracting the logic of the original code.
VIII. ACKNOWLEDGMENTS
We are grateful to Patrick Chan for his implementation
of the control ﬂow graph similarity algorithm used in our
evaluation.
REFERENCES
[1] Oreans Technologies, “Code virtualizer: Total obfuscation against re-
verse engineering,” www.oreans.com/codevirtualizer.php.
[2] StrongBit Technology, “EXECryptor – bulletproof software protection,”
www.strongbit.com/execryptor.asp.
[3] VMProtect Software, “VMProtect – New-generation software protec-
tion,” www.vmprotect.ru/.
[4] Oreans Technologies, “Themida: Advanced windows software protection
system,” www.oreans.com/themida.php.
[5] M. Sharif, A. Lanzi, J. Gifﬁn, and W. Lee, “Automatic reverse engineer-
ing of malware emulators,” in Proc. 2009 IEEE Symposium on Security
and Privacy, May 2009.
[6] K. Coogan, G. Lu, and S. Debray, “Deobfuscating virtualization-
obfuscated software: A semantics-based approach,” in Proc. ACM Con-
ference on Computer and Communications Security (CCS), Oct. 2011,
pp. 275–284.
[7] R. Roemer, E. Buchanan, H. Shacham, and S. Savage, “Return-oriented
programming: Systems, languages, and applications,” ACM Transactions
on Information and System Security, vol. 15, no. 1, pp. 2:1–2:??, Mar.
2012.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:09:00 UTC from IEEE Xplore.  Restrictions apply. 
[8] H. Shacham, “The geometry of innocent ﬂesh on the bone: return-into-
libc without function calls (on the x86),” in proc. ACM Conference on
Computer and Communications Security, 2007, pp. 552–561.
[9] K. Lu, D. Zou, W. Wen, and D. Gao, “deRop: removing return-oriented
programming from malware,” in Proc. 27th. Annual Computer Security
Applications Conference (ACSAC), Dec. 2011, pp. 363–372.
[10] T. Bletsch, X. Jiang, V. Freeh, and Z. Liang, “Jump-oriented program-
ming: A new class of code-reuse attack,” in Proc. 6th ACM Symposium
on Information, Computer and Communications Security, ser. ASIACCS
’11, 2011, pp. 30–40.
[11] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham, and
M. Winandy, “Return-oriented programming without returns,” in Proc.
ACM Conference on Computer and Communications Security, 2010, pp.
559–572.
[12] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna, “Static disassembly
of obfuscated binaries,” in Proc. 13th USENIX Security Symposium,
Aug. 2004.
[13] M. G. Kang, P. Poosankam, and H. Yin, “Renovo: A hidden code
extractor for packed executables,” in Proc. Fifth ACM Workshop on
Recurring Malcode (WORM 2007), Nov. 2007.
[14] J. Stoy, Denotational Semantics of Programming Languages: The Scott-
Strachey Approach to Programming Language Theory. MIT, 1977.
[15] P.
Ferrie,
“Prophet
Sep.
www.virusbtn.com/virusbulletin/archive/2008/
09/vb200809-prophet-loss.
loss,” Virus Bulletin,
and
2008,
[16] A. Dinaburg, P. Royal, M. I. Sharif, and W. Lee, “Ether: malware analy-
sis via hardware virtualization extensions,” in Proc. ACM Conference on
Computer and Communications Security (CCS), Oct. 2008, pp. 51–62.
[17] B. Yadegari and S. Debray, “Bit-level taint analysis,” in Source Code
Analysis and Manipulation (SCAM), 2014 IEEE 14th International
Working Conference on.
IEEE, 2014, pp. 255–264.
[18] D. Brumley, C. Hartwig, Z. Liang, J. Newsome, D. Song, and H. Yin,
“Automatically identifying trigger-based behavior in malware,” in Botnet
Detection. Springer, 2008, pp. 65–88.
[19] V. Chipounov, V. Kuznetsov, and G. Candea, S2E: A platform for in-vivo
multi-path analysis of software systems. ACM, 2011, vol. 39, no. 1.
[20] K. Sen, D. Marinov, and G. Agha, CUTE: a concolic unit testing engine
for C. ACM, 2005, vol. 30, no. 5.
[21] A. Moser, C. Kruegel, and E. Kirda, “Exploring multiple execution
paths for malware analysis,” in Security and Privacy, 2007. SP’07. IEEE
Symposium on.
IEEE, 2007, pp. 231–245.
[22] E. J. Schwartz, T. Avgerinos, and D. Brumley, “All you ever wanted to
know about dynamic taint analysis and forward symbolic execution (but
might have been afraid to ask),” in IEEE Symposium on Security and
Privacy, 2010, pp. 317–331.
[23] C. Collberg, C. Thomborson, and D. Low, “Manufacturing cheap,
resilient, and stealthy opaque constructs,” in Proc. 25th. ACM Symp.
Principles of Programming Languages (POPL 1998), Jan. 1998, pp.
184–196.
[24] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman, Compilers –
Principles, Techniques, and Tools. Reading, Mass.: Addison-Wesley,
2007.
[25] D. Angluin, “On the complexity of minimum inference of regular sets,”
Information and Control, vol. 39, no. 3, pp. 337–350, 1978.
[26] E. M. Gold, “Complexity of automaton identiﬁcation from given data,”
Information and Control, vol. 37, pp. 302–320, 1978.
[27] L. Pitt and M. K. Warmuth, “The minimum consistent DFA problem
cannot be approximated within any polynomial,” J. ACM, vol. 40, no. 1,
pp. 95–142, 1993.
[28] X. Hu, T.-C. Chiueh, and K. G. Shin, “Large-scale malware indexing
using function-call graphs,” in Proc. ACM Conference on Computer and
Communications Security, Nov. 2009, pp. 611–620.
www.cert.org/historical/advisories/CA-
writeup.jsp?docid=2004-102522-4640-99&tabid=2.
[31] pakt,
“ROPC – Turing
complete ROP
compiler,” http:
www.symantec.com/security_response/
//gdtr.wordpress.com/2013/12/13/ropc-turing-
complete-rop-compiler-part-1/.
[29] W. worm,
2003-20.cfm.
[30] W32.Netsky.AE,
[32] V.
T.
https://github.com/stp/stp.
Ganesh
and
Hansen,
“STP,”
[33] S. K. Udupa, S. K. Debray, and M. Madou, “Deobfuscation: Reverse
engineering obfuscated code,” in Proc. 12th IEEE Working Conference
on Reverse Engineering, Nov. 2005, pp. 45–54.
[34] C. Wang, J. Davidson, J. Hill, and J. Knight, “Protection of software-
based survivability mechanisms,” in Proc. International Conference of
Dependable Systems and Networks, Jul. 2001.
[35] N. D. Jones, C. K. Gomard, and P. Sestoft, Partial Evaluation and
Automatic Program Generation. Prentice Hall, 1993.
[36] L. Davi, A.-R. Sadeghi, and M. Winandy, “ROPdefender: a detection
tool to defend against return-oriented programming attacks,” in Proc.
6th ACM Symposium on Information, Computer and Communications
Security (ASIACCS), Mar. 2011, pp. 40–51.
[37] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and E. Kirda, “G-free:
defeating return-oriented programming through gadget-less binaries,”
in Proc. 26th. Annual Computer Security Applications Conference
(ACSAC), Dec. 2010, pp. 49–58.
[38] Y. Cheng, Z. Zhou, M. Yu, X. Ding, and R. H. Deng, “ROPecker: A
generic and practical approach for defending against ROP attack,” in
Proc. 21th Annual Network and Distributed System Security Symposium
(NDSS), Feb. 2014.
691691
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:09:00 UTC from IEEE Xplore.  Restrictions apply.