第5章 表述性状态转移（REST） 55
5.5 小结
本章介绍了为分布式超媒体系统设计的表述性状态转移（REST）架构风格。REST提
供了一组架构约束，当作为一个整体来应用时，强调组件交互的可伸缩性、接口的通用性、
组件的独立部署、以及用来减少交互延迟、增强安全性、封装遗留系统的中间组件。我描述
了指导REST的软件工程原则和选择用来支持这些原则的交互约束，并将它们与其他架构风
格的约束进行了对比。
下一章通过从将REST应用于现代Web架构的设计、规范和部署的过程中学到的经验
和教训，介绍了对于REST架构的一个评估。这些工作包括创作当前的超文本转移协议
（HTTP/1.1）和统一资源标识符（URI）的Internet标准跟踪规范（standard-track
specification），以及通过libwww-perl客户端协议库和Apache HTTP服务器来实现这个架构。
第6章 经验与评估 56
第 6 章 经验与评估
自从1994年以来，REST架构风格就被用来指导现代Web架构的设计和开发。本章描
述了在创作超文本转移协议（HTTP）和统一资源标识符（URI）的Internet标准（这两个规
范定义了在Web上进行交互的所有组件使用的通用接口）的过程中，以及将这些技术部署
在libwww-perl客户端库、Apache HTTP服务器项目、以及协议标准的其他实现的过程中，
应用REST所学到的经验和教训。
6.1 Web标准化
如第4章所描述的那样，开发REST的动机是为Web应该如何运转创建一种架构模型，
使之成为Web协议标准的指导框架。REST被用来描述想要得到的Web架构，帮助识别出现
有的问题，对各种替代方案进行比较，并且保证协议的扩展不会违反使Web成功的那些核
心约束。这项工作是作为Internet工程工作组（IETF）和万维网协会（W3C）定义Web架构
的标准（HTTP、URI和HTML）的工作的一部分来完成的。
我参与Web标准的开发过程开始于1993年晚期，当时我开发了libwww-perl协议库，
作为MOMspider[39]的客户端连接器接口。在那个时候，Web的架构由一组非形式化的超文
本节点[14]来描述，两篇早期的介绍性论文[12,13]草拟了超文本规范，展现出了一些提议的
Web功能（一些已经被实现了），分布于世界各地的WWW项目的参与者使用公开的www-
talk邮件列表进行非正式的讨论。当与各种Web的实现相比时，每一个规范都显得相当过时，
这主要是因为在Mosaic图形化浏览器[NCSA]出现之后Web的快速进化。一些试验性的扩展
被添加到HTTP中以支持HTTP代理，但是协议的大部分内容都假设在用户代理和来源
HTTP服务器或一个到遗留系统的网关之间是一个直接的连接。在这个架构中，并不知道有
缓存、代理或网络爬虫的存在，甚至是在它们的实现已经存在并且正常运行的情况下。还有
很多其他的扩展被提议应该包括在下一版本的协议中。
与此同时，来自行业内的压力也不断增长，要求对Web接口协议的某个版本或某些版
本进行标准化。Berners-Lee[20]组建了W3C，对于Web的架构进行研究，并且为编写Web
标准和参考实现提供创作资源，但是标准化本身是由Internet工程工作组[www.ietf.org]及其
URI、HTTP和HTML工作组来掌管的。由于我在开发Web软件方面的经验，我被首先遴选
出来创作相对URL（Relative URL）的规范[40]，后来又与Henrik Frystyk Nielsen共同创作
了HTTP/1.0规范[19]，然后我成为了HTTP/1.1的主要的架构师，并且最终创作了形成URI
通用语法[21]标准的URL规范的修订版。
REST的第一版开发于1994年10月和1995年8月之间，起初是作为当我编写HTTP/1.0
规范和最初的HTTP/1.1建议时，用来沟通各种Web概念的一种方法。它在随后的5年中以
迭代的方式不断改进，并且被应用于各种Web协议标准的修订版和扩展之中。REST最初被
称作“HTTP对象模型”，但是那个名称常常引起误解，使人们误以为它是一个HTTP服务
器的实现模型。这个名称“表述性状态转移”是有意唤起人们对于一个良好设计的Web应
用如何运转的印象：一个由网页组成的网络（一个虚拟状态机），用户通过选择链接（状态
转移）在应用中前进，导致下一个页面（代表应用的下一个状态）被转移给用户，并且呈现
给他们，以便他们来使用。
REST并非是想要捕获Web协议标准的所有可能的使用方法。仍然存在着一些与分布式
超媒体系统的应用模型不匹配的HTTP应用和URI应用。然而，重要的是REST确实能够完
全捕获一个分布式超媒体系统的那些被认为是Web的行为和性能需求的核心的方面，这样
在这个模型中对行为进行优化，将能够导致在已部署的Web架构中得到最适宜的行为。换
句话说，REST是为常见的情况优化过的，这样它所应用于Web架构上的那些约束也同样是
第6章 经验与评估 57
为常见的情况优化过的。
6.2 将REST应用于URI
统一资源标识符（URI）既是Web架构的最简单的元素，也是最重要的元素。URI还有
很多的名称：WWW地址、通用文档标识符、通用资源标识符[15]、以及最后出现的统一资
源定位器（URL）和统一资源名称（URN）的组合。除了它的名称以外，URI的语法自从
1992年以来维持相对稳定。然而，Web地址的规范也定义了我们所称之为的“资源”的概
念的范围和语义，这个概念自从早期的Web架构以来发生了变化。REST被用来为URI标准
[21]定义术语“资源”，也被用来定义通过它们的表述来操作资源的通用接口的全部语义。
6.2.1 重新定义资源
早期Web架构将URI定义为文档的标识符。创作者得到的指导是按照网络上一个文档
的地点来定义标识符。然后能够使用Web协议来获取那个文档。然而，有很多理由可以证
实，这个定义并不是很令人满意。首先，它暗示创作者正在标识被转移的内容，这意味着任
何时候当内容改变了，这个标识符都应该改变。其次，存在着很多地址对应于一个服务，而
不是一个文档——创作者可能是有意将读者引导到那个服务，而不是引导到来自预先访问那
个服务而获取到的特定的结果。最后，存在着一些地址在某段时间内没有对应一个文档，例
如当文档尚不存在，或者当地址仅仅被用来进行命名，而不是被用来进行定位和获取信息时。
在REST中对于“资源”的定义基于一个简单的前提：标识符的改变应该尽可能很少发
生。因为Web使用内嵌的标识符，而不是链接服务器，创作者需要一个标识符，这个标识
符能够紧密地匹配他们想要通过一个超媒体引用来表达的语义，允许这个引用保持静态，甚
至是在访问该引用所获得的结果可能会随时间而变化的情况下。REST达到了这个目标，通
过将一个资源定义为创作者想要标识的语义，而不是对应于创建这个引用时的那些语义的值。
然后留给创作者来保证所选择的这个标识符确实真正标识出了他所想要表达的语义。
6.2.2 操作影子（Manipulating Shadows）
将“资源”定义为一个URI标识了一个概念，而不是标识了一个文档，这给我们带来
了另一个问题：一个用户如何访问、操作或转移一个概念，使得他们在选择了一个超文本链
接后能够得到一些有用的东西。REST通过定义在被标识的资源的“表述”之上执行的操作，
而不是在资源本身之上执行的操作回答了这个问题。一个来源服务器维护着从资源的标识符
到每个资源相对应的表述集合的映射，因此可以通过由资源标识符定义的通用接口转移资源
的表述来操作一个资源。
REST对于资源的定义来源于Web的核心需求：独立创作跨多个可信任域的互相连接的
超文本。强制接口的定义与接口的需求相匹配会使得协议似乎含糊不清，但这仅仅是因为被
操作的接口仅仅是一个接口，而不是一个实现。这些协议是与一个应用动作的意图密切相关
的，但是接口背后的机制必须要确定该意图如何来影响底层实现中资源到表述的映射。
这里所隐藏的信息是关键的软件工程原则之一，也就是REST使用统一接口的动机。因
为客户端被限制为只能对资源的表述执行操作，而不是直接访问资源的实现，因此资源的实
现可以以任何命名权威所希望的形式来建造，而不会影响到使用资源的表述的客户端。此外，
如果当资源被访问时，存在着资源的多个表述，可以使用一个内容选择算法来动态地选择一
个最适合客户端能力的表述。当然，其缺点就是对资源进行远程创作不像对文件进行远程创
作那么直接。
第6章 经验与评估 58
6.2.3 远程创作（Remote Authoring）
通过Web的统一接口执行远程创作的挑战在于：能够被客户端获取到的表述与服务器
端所使用的保存、生成或获取表述内容的机制之间是相互分离的。一个单独的服务器可以将
它的名字空间的一部分映射到一个文件系统，文件系统随后映射到一个i节点，随后再映射
到一个磁盘位置，但是这些底层机制提供了一种将一个资源与一组表述相关联的方法，而不
是标识资源本身。很多不同的资源能够映射到相同的表述，而其他资源可能完全没有映射到
的表述。
为了对一个现有的资源进行创作，创作者必须首先获得特定资源的URI：绑定到目标资
源的处理器底层表述上的URI集合。一个资源并不总是映射到单个的文件，但是所有非静态
的资源来自于某些其他资源，通过跟踪继承树，一个创作者能够最终找到所有必须编辑的资
源，以便修改一个资源的表述。这些相同的原则适用于以任何形式继承而来的表述，无论它
是来自内容协商、脚本、servlet、托管的配置（managed configurations）、翻译
（versioning）等等。
资源并不是存储对象（storage object）。资源并不是一种服务器用来处理存储对象的机
制。资源是一种概念上的映射——服务器接收到标识符（标识这个映射），将它应用于当前
的映射实现（mapping implementation，通常是与特定集合相关的树的深度遍历和/或哈希表
的组合）上，以发现当前负责处理该资源的处理器实现，然后处理器实现基于请求的内容选
择适当的动作+响应。所有这些特定于实现的问题都隐藏在Web接口之后，它们的性质无法
由仅能够通过Web接口访问资源的客户端来作出假设。
例如，考虑在以下场景中将会发生的事情。随着一个网站的用户量的增长，决定将旧的
基于XOS平台的Brand X服务器替换为一个新的运行于FreeBSD之上的Apache服务器。磁
盘存储硬件被替换掉了、操作系统被替换掉了、HTTP服务器也被替换掉了、也许为所有内
容生成响应的方法也被替换掉了。尽管如此，不需要改变的是Web的接口：如果设计正确，
新服务器上的名字空间可以完全镜象原先老服务器的名字空间，这意味着从客户端（它仅仅
知道资源，而不知道它们是如何实现的）的观点来看，除了改善了的站点的健壮性，什么变
化也没有发生。
6.2.4 将语义绑定到URI
正如上面所提到的，一个资源能够拥有多个标识符。换句话说，可以存在两个或更多个
不同的URI，当用来访问服务器时，具有相同的语义。也有可能有两个URI，在访问服务器
时导致使用相同的机制，然而两个URI标识的是两个不同的资源，因为它们并不意味着相同
的事物。
对于设置资源标识符和用表述组装那些资源的动作而言，语义是一个副产品。服务器或
客户端软件绝对不需要知道或理解URI的含义——它们仅仅扮演一个管道，通过这个管道，
资源的创建者（一个作为命名权威的人）能够将表述与通过URI标识的语义关联起来。换句
话说，在服务器端没有资源，仅仅是通过由资源定义的抽象接口提供答案的机制。这看起来
似乎很奇怪，但是这正是使得Web跨越如此众多的不同实现的关键所在。
按照用来组成已完成产品的组件来定义事物，是每一个工程师的天性。Web却并非是以
这种方式运作的。基于在一个应用动作期间每个组件的角色，Web架构由在组件之间的通信
模型之上的约束组成。这防止了组件对于每件事物作出超越资源抽象的假设，因此隐藏了抽
象接口任何一端的真实的机制。