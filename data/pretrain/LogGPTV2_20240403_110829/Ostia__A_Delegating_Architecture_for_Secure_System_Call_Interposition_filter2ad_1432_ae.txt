case, the penalty for sandboxing is less than 1%, because
none of these applications uses a great number of sandboxed
system calls.
Worst-case application overhead: We also benchmarked
a program build. This is an activity not often of interest
in sandboxing scenarios. For us, it provides an interesting
worst-case benchmark given the large number of restricted
system calls performed. It is not entirely contrived, as one
might wish to sandbox a build of software downloaded from
untrusted locations on the Internet (e.g. to protect against
malicious build scripts). Fortunately, building untrusted
software is not an activity that takes place frequently, nor
does it have real-time requirements as helper applications
often do. Thus even the relatively high 25% overhead for
this pathological example seems quite tolerable in practice.
Our example build decompresses, unpacks, conﬁgures,
and compiles the source tree for GNU gzip 1.3.5. This is a
system call intensive application, with little CPU needed to
compile under 10,000 lines of C, so the cost of sandboxing
is signiﬁcant in the bottom line.
Competing sandbox performance: Table 5 compares J2’s
and Ostia’s performance against published benchmarks of
other sandboxing tools. The ﬁgures suggest that Ostia per-
forms competitively. The numbers in the table, other than
those for J2 and Ostia, are taken from various published
sources using different applications and test platforms, so
use caution in drawing any more ambitious conclusions.
Jain&
Class
network <1% <1% <5%
compute <1% <1% <2%
system call
J2 Ostia Sekar Systrace MAPbox
17%
1%
41%
5%
0%
8% 25% — 31%
Table 5: Approximate overhead of sandboxing
tools on network-intensive (e.g. web serving),
compute-intensive (e.g.
encoding), and system
call intensive (e.g. program build) applications.
Numbers for Jain & Sekar obtained from [21],
Fig. 6; for Systrace, [31], Fig. 9; and for MAPbox,
[2], Table 2.
6 Related work
The ﬁrst hybrid system call interposition-based applica-
tion sandbox was Janus, developed by Goldberg [18] et al.
Janus set forth the basic architecture for ﬁltering sandboxes.
Janus is very similar to J2, as J2 evolved from the original
Janus system. Janus initially relied on the Solaris /proc
interface for interposition. This was noteworthy because it
did not require any kernel modiﬁcations. An extended de-
scription of Janus’s architecture is given in Wagner’s the-
sis [36].
The basic Janus architecture was subsequently replicated
in MapBox [2], which focused on the problem of policy
speciﬁcation.
It was also replicated in consh [3], which
leveraged system call interposition to transparently extend
the ﬁle system and other system interfaces, and to restrict
execution. The Systrace [31] system exhibits a ﬁltering ar-
chitecture very similar to J2. It provides a rich set of fea-
tures for specifying and generating policy. Systrace stands
out as being the most mature and signiﬁcantly deployed sys-
tem of this type.
System call interposition has also been a popular mecha-
nism for implementing intrusion detection systems. Several
notable examples of this include work by Wespi et al. [39]
and Hofmeyer et al. [20].
Jain et al. [21] presented a generalized framework for
building secure interposition systems on top of standard
process tracing mechanisms. As with all the aforemen-
tioned systems, this toolkit had a variety of security prob-
lems. Garﬁnkel [16] presented a full study of potential se-
curity problems in these tools, including race conditions,
indirect paths to resources, and side effects of denying sys-
tem calls.
The callback support added to the Linux kernel to sup-
port Ostia is reminiscent of a similar feature provided by the
Mach system call interception mechanism [25], which redi-
rects system calls to handlers in the same address space as
the calling process. Jones’ work on interposition agents [22]
presents a general framework that provides OS extensibility
by placing code in these handlers.
Using this mechanism to convert native system calls into
IPC messages to user-level processes via an emulation li-
brary, as done in Ostia, is reminiscent of traditional tech-
niques for building Unix emulation layers on top of micro-
kernels. For example, an implementation of 4.3 BSD on
top of Mach based on this technique is given by Golub et
al. [19]. In contrast to these techniques which virtualize the
entire OS interface, Ostia only virtualizes the access control
relevant portions of OS API.
Specialized kernel support for interposing on OS inter-
faces for extensibility purposes has been explored in other
work, such as pseudo-devices and pseudo-ﬁle systems in
Sprite [38] and work by Bershad et al. with Watchdogs [6].
A variety of purely kernel-level [12, 15, 10, 5, 13, 4]
and purely user-level [14, 23, 32] sandboxing systems have
been presented in the literature. A good comparative survey
of sandboxing mechanisms and alternatives, such as whole-
system access controls (e.g. DTE [37]), is given by Peterson
et al. [30].
7 Conclusion
We have explored the importance of system architecture
in secure interposition systems. We presented two systems
that implement different hybrid architectures: J2, based on
a “ﬁltering” architecture representative of many of today’s
sandboxing systems, and Ostia, based on a novel “dele-
gating” architecture. We have observed that many of the
problems in today’s ﬁltering architectures can be amelio-
rated by a delegation-based approach. Further, a delegating
approach can enhance the beneﬁcial properties of existing
hybrid approaches.
8 Acknowledgments
J2 was developed in collaboration with David Wagner,
who provided invaluable feedback and encouragement dur-
ing the early stages of this work. Steve Gribble, Costa Sa-
punzakis, and Ulfar Erlingson also provided helpful feed-
back at various stages of this work. Cristen Torrey provided
valuable editorial assistance. Finally, we are very grate-
ful for the generous feedback and comments of our anony-
mous reviewers. This work was supported in part by the
National Science Foundation under Grant No. 0121481, a
Stanford Graduate Fellowship, and by NSF CAREER CCR-
0093337.
References
[1] Subterfugue:
strace meets
expect.
http:
//subterfugue.org/.
[2] A. Acharya and M. Raje. MAPbox: Using parameterized
behavior classes to conﬁne untrusted applications. In Proc.
9th USENIX Security Symposium, Aug. 2000.
[3] A. Alexandrov, P. Kmiec, and K. Schauser.
Consh:
A conﬁned execution environment for internet computa-
tions. http://www.cs.ucsb.edu/berto/papers/
99-usenix-consh.ps, 1998.
[4] A. Berman, V. Bourassa, and E. Selberg. TRON: Process-
In
speciﬁc ﬁle protection for the UNIX operating system.
Proceedings of the Winter USENIX Conference, 1995.
[5] M. Bernaschi, E. Gabrielli, and L. V. Mancini. Remus: a
security-enhanced operating system. ACM Trans. Informa-
tion and System Security (TISSEC), 5(1):36–61, 2002.
[6] B. N. Bershad and C. B. Pinkerton. Watchdogs: Extending
the UNIX ﬁle system. In USENIX Conference Proceedings,
pages 267–75, Dallas, TX, Winter 1988.
[7] M. Bishop and M. Dilger. Checking for race conditions
in ﬁle accesses. Computing Systems, 9(2):131–152, Spring
1996.
[8] CERT. Vulnerability note VU#176888, Linux kernel con-
tains race condition via ptrace/procfs/execve. may 2002.
[9] H. Chen, D. Wagner, and D. Dean. Setuid demystiﬁed. In
Proc. 11th USENIX Security Symposium, August 2002.
[20] S. A. Hofmeyr, S. Forrest, and A. Somayaji. Intrusion detec-
tion using sequences of system calls. Journal of Computer
Security, 6(3):151–180, 1998.
[21] K. Jain and R. Sekar. User-level infrastructure for system call
interposition: A platform for intrusion detection and conﬁne-
ment.
In Proc. Network and Distributed Systems Security
Symposium, 2000.
[22] M. B. Jones. Interposition agents: Transparently interposing
user code at the system interface. In Symposium on Operat-
ing Systems Principles, pages 80–93, 1993.
[23] V. Kiriansky, D. Bruening, and S. Amarasinghe. Secure exe-
cution via program shepherding. In Proceedings of the 11th
USENIX Security Symposium, August 2002.
[24] C. Ko, T. Fraser, L. Badger, and D. Kilpatrick. Detecting
and countering system intrusions using software wrappers.
In Proc. 9th USENIX Security Symposium, August 2000.
[25] M. Accetta et al. Mach: A new kernel foundation for UNIX
development. In Proc. USENIX Summer Conference, 1986.
lc. ftp://ftp.qucis.queensu.ca/
[26] B. Marick.
pub/software-eng/software/Cmetrics/lc.
tar.gz%.
[10] C. Cowan, S. Beattie, G. Kroach-Hartman, C. Pu, P. Wagle,
and V. Gligor. Subdomain: Parsimonious server security. In
Proc. Systems Administration Conference, Dec. 2000.
[27] M. K. McKusick, K. Bostic, M. J. Karels, and J. S. Quarter-
man. The Design and Implementation of the 4.4 BSD Oper-
ating System, pages 112–114. Addison-Wesley, 1996.
[11] A. Cox. CAN-2003-0127, Linux kernel ptrace() ﬂaw lets
local users gain root privileges. March 2003.
[12] A. Dan, A. Mohindra, R. Ramaswami, and D. Sitaram.
Chakravyuha (CV): A sandbox operating system environ-
ment for controlled execution of alien code. Technical Re-
port 20742, IBM T.J. Watson Research Center, Sept. 1997.
[13] Entercept Security Technologies.
inter-
ception whitepaper. http://www.entercept.com/
whitepaper/systemcalls/.
System call
[14] Erlingsson and Schneider. SASI enforcement of security
policies: A retrospective. In WNSP: New Security Paradigms
Workshop. ACM Press, 2000.
[15] T. Fraser, L. Badger, and M. Feldman. Hardening COTS
software with generic software wrappers. In IEEE Sympo-
sium on Security and Privacy, pages 2–16, 1999.
[16] T. Garﬁnkel. Traps and pitfalls: Practical problems in system
call interposition based security tools. In Proc. Network and
Distributed Systems Security Symposium, February 2003.
[17] D. P. Ghormley, D. Petrou, S. H. Rodrigues, and T. E. Ander-
son. SLIC: An extensibility system for commodity operating
systems.
In Proc. USENIX Annual Technical Conference,
pages 39–52, June 1998.
[18] I. Goldberg, D. Wagner, R. Thomas, and E. Brewer. A secure
environment for untrusted helper applications. In Proc. 6th
USENIX Security Symposium, July 1996.
[19] D. B. Golub, R. W. Dean, A. Forin, and R. F. Rashid. UNIX
as an application program. In USENIX Summer, pages 87–
95, 1990.
[28] T. Mitchem, R. Lu, and R. O’Brien. Using kernel hypervi-
sors to secure applications. In Proc. 13th Annual Computer
Security Applications Conference, December 1997.
[29] V. Nakra. Architecture study: Janus—a practical tool for
application sandboxing.
[30] D. S. Peterson, M. Bishop, and R. Pandey. A ﬂexible con-
tainment mechanism for executing untrusted code. In Proc.
11th USENIX Security Symposium, August 2002.
[31] N. Provos. Improving host security with system call policies.
In Proc. 12th USENIX Security Symposium, pages 257–272,
august 2003.
[32] K. Scott and J. Davidson. Safe virtual execution using soft-
ware dynamic translation. In Proc. Annual Computer Secu-
rity Applications Conference, 2002.
[33] Steve Bellovin. Shifting the Odds, Writing More Secure
Software. http://www.research.att.com/˜smb/
talks/odds.ps.
[34] Teso Security Advisory. LIDS Linux Intrusion Detection
System vulnerability. http://www.team-teso.net/
advisories/teso-advisory-012.txt.
[35] J. Viega and G. McGraw. Building Secure Software, pages
209–229. Addison-Wesley, 2002.
[36] D. A. Wagner. Janus: An approach for conﬁnement of un-
trusted applications. Technical Report CSD-99-1056, Uni-
versity of California, Berkeley, 12, 1999.
[37] K. M. Walker, D. F. S. anad M. L. Badger, M. J. Petkac, D. L.
Shermann, and K. A. Oostendorp. Conﬁning root programs
with domain and type enforcement.
In Proceedings of the
sixth USENIX Security Symposium, July 1996.
[38] B. Welch and J. Ousterhout. Pseudo devices: User-level ex-
tensions to the Sprite ﬁle system. In Summer 1988 USENIX
Conference, pages 37–49, San Francisco, CA, 1988.
[39] A. Wespi, M. Dacier, and H. Debar. Intrusion detection us-
ing variable length audit trail patterns. In RAID 2000, pages
110–129, 2000.
A Ostia Policy Interface
Starting State
starting uid uid
starting gid gid
starting dir directory
Sets the initial user id, group id, and current working direc-
tory for the sandboxed process.
File System Policy
path-allow (read|write|unlink|exec). . .
path. . .
Provides access to ﬁle system resources. Files to which ac-
cess is granted are written as absolute ﬁle names that may
pattern matching wildcards. Keep in mind that directories
are ﬁles and must be authorized the same way; e.g. to stat
a directory, read permission for that directory is required.
Examples:
path-allow read /var/foo
Allows the contents of /var/foo to be read.
path-allow read /var/∗
Allows any ﬁle whose absolute path begins with the preﬁx
/var/ to be read.
Network Policy
net-allow (outgoing|incoming)
(tcp|udp) address[/mask] port[/mask]
The net-allow directive controls access to network re-
sources and limits IPC over sockets. All application use of
sockets must be explicitly allowed. Creating outgoing con-
nections to other local or remote processes and accepting
incoming connections from other processes are controlled
separately.
The syntax to allow a sandboxed application to connect to
another process or send trafﬁc directly to it is net allow
outgoing type end-point.
To allow a sandboxed application to bind a socket (i.e. wait
for a connection from some other process) or receive trafﬁc
from another address, write
net-allow incoming type end-point
Examples:
net-allow incoming unix-domain /var/∗
Allows a sandboxed process to bind a socket with any path
in /var.
net-allow outgoing tcp 128.36.31.50 80
Allows tcp connections to be made to the host at
128.36.31.50 on port 80.
net-allow outgoing tcp MYHOST ADDR 0/0
Allows a sandboxed process to make tcp connections to any
local port. Keyword MYHOST ADDR is special syntax for
the local IP address.