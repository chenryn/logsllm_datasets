fs
CCS â€™20, November 9â€“13, 2020, Virtual Event, USA
Schwabe, Stebila, Wiggers
Let KE be an M-stage key-exchange protocol, and let A be a
probabilistic adversary interacting with KE via the queries defined
in Appendix B.2. A tries to win the following game ğºMatch
KE,A :
key pairs(cid:0)pkğ‘ˆ , skğ‘ˆ(cid:1) for each participant ğ‘ˆ âˆˆ U that re-
Setup The challenger generates long-term public and private
quires a long-term key. All keys are provided to A.
Query The adversary has access to the queries NewSession,
Send, Reveal, Corrupt, and Test.
must have ğœ‹ .keyğ‘— = ğœ‹â€².keyğ‘—.
{1, . . . , M} for which ğœ‹ .sidğ‘– = ğœ‹â€².sidğ‘– Ì¸= âŠ¥.
lowing conditions:
Stop At some point, the adversary stops with no output.
Let ğœ‹, ğœ‹â€² be distinct partnered sessions with some stage ğ‘– âˆˆ
We say that A wins ğºMatch
KE,A if it can falsify any one of the fol-
(1) ğœ‹, ğœ‹â€² agree on the same key at every stage ğ‘— â‰¤ ğ‘–, i.e., they
(2) ğœ‹, ğœ‹â€² have opposite roles: ğœ‹ .role Ì¸= ğœ‹â€².role.
(3) ğœ‹, ğœ‹â€², partnered in some stage ğ‘–, have set and agree on the
contributive identifier, i.e., ğœ‹ .cidğ‘– = ğœ‹â€².cidğ‘– Ì¸= âŠ¥.
(4) for every stage ğ‘— â‰¤ ğ‘– of ğœ‹ that has reached a (retroactively) ex-
plicitly authenticated state, i.e., such that ğœ‹ .statusğ‘– = accepted
and ğ‘– â‰¥ ğœ‹ .authğ‘—, the identity of the peer is correct: ğœ‹ .pid =
ğœ‹â€².id.
(5) ğœ‹, ğœ‹â€² (not necessarily distinct) have distinct session identi-
fiers across distinct stages ğ‘–, ğ‘—: ğœ‹ .sidğ‘– = ğœ‹â€².sidğ‘— implies ğ‘– = ğ‘—.
(6) ğœ‹, ğœ‹â€² do not have any third partner session ğœ‹â€²â€², i.e., at any
stage ğ‘–, having ğœ‹ .sidğ‘– = ğœ‹â€².sidğ‘– = ğœ‹â€²â€².sidğ‘– Ì¸= âŠ¥ implies ğœ‹ = ğœ‹â€²,
ğœ‹â€² = ğœ‹â€²â€², or ğœ‹ = ğœ‹â€²â€².
Theorem B.2. KEMTLS is Match-secure. In particular, any effi-
cient adversary A has advantage
AdvMatch
KEMTLS,A â‰¤ ğ‘›ğ‘ (ğ›¿ğ‘’ + ğ›¿ğ‘ ) + ğ‘›2
ğ‘  /2|nonce|,
where ğ‘›ğ‘  is the number of sessions, |nonce| is the length of the nonces
ğ‘Ÿğ‘ and ğ‘Ÿğ‘  in bits, and the ephemeral and long-term KEM algorithms
are assumed to be ğ›¿ğ‘’- and ğ›¿ğ‘ -correct, respectively.
Proof. We need to show each property of Match security (Def-
inition B.1) holds:
(1) The session identifiers are defined to contain all handshake
messages. KEM messages and hashes of those messages are
only inputs into the key schedule. In stages 1 and 2, the input
to the agreed keys is the ephemeral KEMe shared secret and
the messages up to ServerHello. For stage 3 and 4, the input
to the agreed keys are the previous keys, messages up to
ClientKemCiphertext and the static KEMs shared secret.
For the final stages 5 and 6, the input to the keys is the
previous keys and the messages up to ClientFinished and
ServerFinished respectively. It is easy to confirm that this
is all included in the session identifiers. This means that
the parties use the same inputs to their computations. The
only way they can arrive at different keys is if any of their
computations are not perfectly correct. The ephemeral and
long-term KEMs have some small probability of failure, ğ›¿ğ‘’
and ğ›¿ğ‘ , respectively, in each of the ğ‘›ğ‘  sessions. This gives us
a failure probability of ğ‘›ğ‘  (ğ›¿ğ‘’ + ğ›¿ğ‘ ).
(2) No initiator or responder will ever accept a wrong-role in-
coming message, so any pair of two sessions must have both
an initiator and a responder. We will later show that at most
two sessions have the same sid, implying that this pairing
will be unique and thus opposite.
(3) By definition, cidğ‘– is final and equal to sidğ‘– whenever stage ğ‘–
is accepted.
(4) The partnered sessions only have to agree once they reach
a retroactively authenticated stage. The identity is learned
through the ServerCertificate sent by the responder. Be-
cause Match security only concerns honest sessions, the
ServerCertificate received by the initiator will set the
correct pid.
(5) Every stageâ€™s session identifier is defined to have a unique
label, thus there can be no confusion across distinct stages.
(6) The session identifiers include the random nonce and KEM
public key and ciphertext. For three sessions to have the
same identifier, we would need to have a collision of these
values picked by honest servers and clients. Without making
assumptions on the KEM scheme, we can rely on distinctness
of nonces under the birthday bound on ğ‘›ğ‘  the number of
sessions: the probability of failing in ğ‘›ğ‘  sessions is less than
ğ‘  /2|nonce|, which is negligible in the bit-length of the nonce.
ğ‘›2
â–¡
B.5 Multi-Stage security
The Multi-Stage experiment was introduced by [41] and was also
used by DFGS for TLS 1.3 [38, 39]. In this original formulation,
secrecy of each stage key is defined as being indistinguishable
from a random key, Bellareâ€“Rogaway-style [6]. Our formulation of
Multi-Stage is extended to also model explicit authentication.
We first define the terms fresh and maliciously accept.
Definition B.3 (Freshness). Stage ğ‘– of a session ğœ‹ is said to be fresh
if all of the following conditions hold:
(1) the stage key was not revealed (ğœ‹ .revealedğ‘– = false);
(2) the stage key of the partner session at stage ğ‘–, if the partner
exists, has not been revealed (for all ğ‘–, ğœ‹â€² such that ğœ‹ .sidğ‘– =
ğœ‹â€².sidğ‘–, we have that ğœ‹â€².revealedğ‘– = false);
(3) (weak forward secrecy 1) if there exists ğ‘— â‰¥ ğ‘– such that
ğœ‹ .FSğ‘–,ğ‘— = wfs1 and ğœ‹ .statusğ‘— = accepted, then there exists a
contributive partner at stage ğ‘–;
(4) (weak forward secrecy 2) if there exists ğ‘— â‰¥ ğ‘– such that
ğœ‹ .FSğ‘–,ğ‘— = wfs2 and ğœ‹ .statusğ‘— = accepted, then there exists a
contributive partner at stage ğ‘– or Corrupt(ğœ‹ .pid) was never
called;
(5) (forward secrecy) if there exists ğ‘— â‰¥ ğ‘– such that ğœ‹ .FSğ‘–,ğ‘— = fs
and ğœ‹ .statusğ‘— = accepted, then there exists a contributive
partner at stage ğ‘– or Corrupt(ğœ‹ .pid) was not called before
stage ğ‘— of session ğœ‹ accepted.
Definition B.4 (Malicious acceptance). Stage ğ‘– of session ğœ‹ is said
to have maliciously accepted if all of the following conditions hold:
= accepted;
(1) ğœ‹ .statusğœ‹ .authğ‘–
(2) there does not exist a unique partner of ğœ‹ at stage ğ‘–; and
(3) Corrupt(ğœ‹ .pid) was not called before stage ğ‘— of session ğœ‹
accepted, where ğ‘— = max{â„“ : ğœ‹ .statusâ„“ = accepted}.
Now we can define our version of the Multi-Stage security ex-
periment.
Post-Quantum TLS Without Handshake Signatures
CCS â€™20, November 9â€“13, 2020, Virtual Event, USA
Definition B.5 (Multi-Stage security). Let KE be an M-stage key-
exchange protocol, and let A be a probabilistic adversary interact-
ing with KE via the queries defined in Appendix B.2. The adversary
tries to win the following game ğºMulti-Stage
Setup The challenger generates all long-term keys(cid:0)pkğ‘ˆ , skğ‘ˆ(cid:1)
KE,A
:
for all identities ğ‘ˆ âˆˆ U and picks a uniformly random bit ğ‘
(for the Test queries). The public keys are provided to A.
Send, Reveal, Corrupt, and Test.
Query The adversary has access to the queries NewSession,
Stop At some point, A stops and outputs their guess ğ‘â€² of ğ‘.
Finalize The adversary wins the game if either of the following
conditions hold:
(1) all tested stages are fresh (for all ğ‘—, ğœ‹â€² such that ğœ‹ .testedğ‘— =
true, stage ğ‘— of session ğœ‹â€² is fresh), and ğ‘â€² = ğ‘; or
(2) there exists a stage that has maliciously accepted;
in which case the experiment ğºMulti-Stage
outputs 1. Oth-
erwise the adversary has lost the game, in which case the
experiment ğºMulti-Stage
outputs a uniform bit.
KE,A
KE,A
The Multi-Stage-advantage of A is defined as:
(cid:12)(cid:12)(cid:12)(cid:12)Pr(cid:104)ğºMulti-Stage
KE,A
â‡’ 1(cid:105) âˆ’ 1
2
(cid:12)(cid:12)(cid:12)(cid:12) .
AdvMulti-Stage
KE,A
=
Theorem B.6. Let A be an algorithm, and let ğ‘›ğ‘  be the number
of sessions and ğ‘›ğ‘¢ be the number of parties. There exist algorithms
B1, . . . , B16, described in the proof, such that
AdvMulti-Stage
KEMTLS,A â‰¤
ğ‘›ğ‘ 
(cid:169)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:171)
+ AdvPRF-sec
ğ‘›2
2|nonce| + AdvCOLL
ğ‘ 
H,B1
AdvIND-1CCA
HKDF.Extract,B3
KEMe,B2
+ AdvPRF-sec
+ Advdual-PRF-sec
HKDF.Expand,B4
+ Advdual-PRF-sec
+ AdvPRF-sec
HKDF.Expand,B6
+ AdvPRF-sec
+ AdvPRF-sec
HKDF.Expand,B8
AdvIND-CCA
+ Advdual-PRF-sec
KEMs,B10
HKDF.Extract,B11
+ AdvPRF-sec
HKDF.Expand,B12
+ AdvPRF-sec
HKDF.Expand,B14
+ ğ‘›ğ‘¢ Â· AdvEUF-CMA
HMAC,B16
HKDF.Extract,B5
HKDF.Extract,B7
HKDF.Expand,B9
(cid:169)(cid:173)(cid:173)(cid:173)(cid:171)
+ 2ğ‘›ğ‘¢
+ Advdual-PRF-sec
+ AdvPRF-sec
HKDF.Extract,B13
HKDF.Expand,B15
(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172)
(cid:169)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:171)
(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172)
(cid:170)(cid:174)(cid:174)(cid:174)(cid:172)
.
+ 6ğ‘›ğ‘ 
Proof. The proof follows the basic structure of the proof of
DFGS [38, 39] for the TLS 1.3 signed-Diffieâ€“Hellman full handshake,
and proceeds by a sequence of games.
We assume that all tested sessions remain fresh throughout the
experiment, as otherwise the adversary loses the indistinguishabil-
ity game.
Game 0. We define ğº0 to be the original Multi-Stage game:
AdvMulti-Stage
KEMTLS,A = Advğº0A .
Game 1. We abort if any honest session uses the same nonce ğ‘Ÿğ‘
or ğ‘Ÿğ‘  as any other session. Given that there are ğ‘›ğ‘  sessions each
using uniformly random nonces of size |nonce|= 256, the chance
of a repeat is given by a birthday bound:
Advğº0A â‰¤
ğ‘›2
2|nonce| + Advğº1A1
ğ‘ 
.
Game 2. In this game, the challenger will abort if any two honest
sessions compute the same hash for different inputs of hash function
H. If this happens, it induces a reduction B1 that can break the
collision-resistance of H. If a collision occurs, B1 outputs the two
distinct input values. Thus:
Advğº1A1 â‰¤ Advğº2A1
+ AdvCOLL
H,B1
.
Game 3. We now restrict A to only make a single Test query.
This reduces its advantage by at most 1/6ğ‘›ğ‘  for the six stages,
based on a hybrid argument by GÃ¼nther [50]. Any single-query
adversary A1 can emulate a multi-query adversary A by guessing
a to-be-tested session in advance. For any other Test queries A may
submit, A1 can substitute by Reveal queries. A1 will need to know
how sessions are partnered. Early partnering is decided by public
information (sid1, sid2), but later sids are encrypted. However, A1
can just reveal the handshake traffic keys to decrypt the subsequent
information.
A1 guess the right session and stage:
We get the following advantage by letting transformed adversary
Advğº2A â‰¤ 6ğ‘›ğ‘  Â· Advğº3A1
.
With this transformation, we can now refer to the session ğœ‹ tested
at stage ğ‘–, and assume that we know the tested session ğœ‹ at the
outset.
Case distinction.
We now consider three separate cases of game 3.
A. (denoted ğºğ´) The tested session ğœ‹ has a contributive partner
in stage 1. Formally, there exists ğœ‹â€² Ì¸= ğœ‹ where ğœ‹â€².cid1 =
ğœ‹ .cid1.
B. (denoted ğºğµ) The tested session ğœ‹ does not have a contribu-
tive partner in stage 1, and there was no Corrupt(ğœ‹ .pid)
query ever.
C. (denoted ğºğ¶) The tested session ğœ‹ does not have a contribu-
tive partner in stage 1, and there was no Corrupt(ğœ‹ .pid)
query before the stage ğ‘– of ğœ‹ accepted.
Notice that these cases roughly correspond to the three different
forward secrecy properties (wfs1, wfs2, fs).
We will consider the advantage of the adversary separately for
these three cases:
Advğº3A1 â‰¤ max(cid:110)
(cid:111)
Advğºğ´A1
+ AdvğºğµA1
â‰¤ Advğºğ´A1
, AdvğºğµA1
, Advğºğ¶A1
+ Advğºğ¶A1
Case A: Stage 1 contributive partner exists
If the tested session ğœ‹ is a client (initiator) session, then ğœ‹ .cid1 =
ğœ‹ .sid1, and a partner session at stage 1 also exists. Since sid1 in-
cludes both the client and server nonces ğ‘Ÿğ‘ and ğ‘Ÿğ‘  via the CH and
SH messages, and by game 1 no honest sessions repeat nonces, the
contributive partner is unique.
If the tested session ğœ‹ is a server (responder) session, then it
is possible that, while the contributive partner session at stage 1
exists, the partner session at stage 1 may not exist. However, since
cid1 includes the client nonce (which by Game 1 are unique) and
contributive partnering includes roles, there is no other honest
client session that is a contributive partner at stage 1.
CCS â€™20, November 9â€“13, 2020, Virtual Event, USA
Schwabe, Stebila, Wiggers
So we can talk of the tested session and its unique contributive
partner at stage 1. Let ğœ‹â€² be the unique honest contributive partner
of ğœ‹ at stage 1. In the following, we let ğœ‹ğ‘ denote the one of {ğœ‹, ğœ‹â€²}
which is a client (initiator) session, and we let ğœ‹ğ‘  denote the one
which is a server (responder) session.
Game A1 (guess contributive partner session). In this game,
the challenger tries to guess the ğœ‹â€² Ì¸= ğœ‹ that is the honest contribu-
tive partner to ğœ‹ at stage 1.
This reduces the advantage of A1 by a factor of the number of
sessions ğ‘›ğ‘ :