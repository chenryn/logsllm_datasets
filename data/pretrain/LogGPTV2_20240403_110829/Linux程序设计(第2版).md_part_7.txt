Info file, which is the authoritative documentation.
It we tind that the things in this man page that are out
of date cause significant confusion or complaints,we wil1
stop distributing the man page.The alternative, updating
because the rest of the work of meintaining GNU CC leaves
theman page when we update the Info file. is inpossible
obsolete and should not let then take tine away fron other
us no tine for that.
.The GNU project regards man pages as
For coeplete and current docunentation, refer to the Info
things.
version 2.0).Both are made from the Texinfo source file
file 'gce'
or the nanual Using and PurLing GNU CC
(for
gcc.texinfo.
如果愿意，我们可以看到编译器针对各种可供选用的目标处理器所支持的编译选项。这些
目标处理器的使用手册页相当长，但仍然只是GNU全部C（和C++）语言文档的一小部分。
在阅读使用手册页的时候，可以使用空格键阅读下一页，回车键阅读下一行，“q”键退出。
2）为了获得更多关于GNU的C语言编译器的资料，我们可以再试试info系统。
$ info goc
File: gcc.info,Node: Top.Next: Copying.Up:(DfR)
Intreduction
This manual documents how to run, install and port the GNU compiler.
as well as its new features and inconpatibilities, and how to report
bugs.
It corresponds to EGcS version 1.1.2.
* Menu:
G++and GCC::
Invoking GCC::
You can conpile C or C++ programs.
Installation::
Command options supported by'gcc'
C Extensions::
How to configure，
GNU extensions to the C language fanily.
compile and install GNU CC.
C++Extensions::
Trouble::
GNU extensions to the C++ language.
·Bugs::
If you have trouble installing GNU CC.
*Service::
How to Eind suppliers of support for GNU cC.
How, why and where to report bugs.
VMS: :
Using GNU CC on VMS.
·Portability::
+Interface::
Goals of GNU CC's portability features.
·Passes::
Function-call interface of CNu CC output.
Order of passes. what they do, and what each file is for.
*Machine Desc::
The intermediate representation that nost passes work on.
·Target Macros::
How to write machine description instruction patterns.
How to write the machine description C sacros.
-zz-Info:(gcc.info.gz)Top,36 1ines -Top- Subfile: gcc.info-1.g2-
* Config::
Writing thexm-MACHINe.h'Eile.
我们将看到一个很长的选项菜单，通过选择其中的选项，我们就可以在该文档完整的文本
内容里面四处移动。菜单项和树状结构的页面布局使我们可以在一个非常大的文档里漫游。如
果是在书面上，GNU的C语言文档会有几百页之多。
加入jaVa编程群：524621833
---
## Page 27
8Linut程序设计
当然，info系统本身还行个info格式的帮助页面如果你按下“Ctrl-H”组合键，就会看
到一些帮助信息、其中包括一个关于info系统使用方法的教程，许多种Linux发行版本里都带有
nfo程序，它还可以被安装到其他的UNIX系统上去、
1.8程序开发系统的预备知识
对--个UNIX开发人员来说，多少知道--点软件工其和开发资源都放在什么地方是很重要的
我们简单地介绍几个重要的子目录和文件。这部分内容上要足针对Linux的，但同样的原理也适
用于其他类型的UNIX系统。
1.8.1程序
程序通常都被保存在专门为此保留的于日录里。系统为正常使用情况准备的程序，包括程
序开发，都可以在/usr/bin子目录里找到，系统管理员为某个特定的主机系统或本地网络添加的
程序可以在/usr/local/bin子目录里找到。
系统管理员一般都喜欢使用/usr/local子目录，因为它可以把供应商提供的文件和后米添加的
尔西和系统本身提供的程序隔离开来。/usr子日录的这种布局方法在需要对操作系统进行升级的
时候非常有川，因为只有/usr/local子目录里的东西需要保留。我们建议读者编译自己的程序时
计它们遵照/usr/local子月录的树状结构来运行和访问必要的文件
某些随后安装的软件或者程序设计系统有它们自已的子口录结构，其执行程序也保存在特
定的子！1承里这类情况里面最明显的例子就是x窗“I系统、它通常被安装在一个名为/usr/X11
的子目录里其他的安装位置还有/usr/X11R6子日录，这是X窗口系统第6版安装的场所，XFrce
论坛组织发行的用于英特尔处理器芯片的各种XFree86窗口系统变体也安装在这里，大部分
Linux发行版本也使用这个场所安装x窗口系统：随Solaris操作系统提供的Sun开故窗I系统
1Sun OpenWindows system）—般安装在/usr/openwin子目录里
通常被安装在/usr/bin或者/usr/local/bin子目录里，但通过它运行的各种编译器支持程序一般都被
同面不同，对Linux系统来说，这个位置通常是/usr/lih/gcc-lib/目录下以其版本号确定的某个下
级子H录GNU的C/C++编译器的各道编译程序以及GNU专用的头文件都保存在这里
1.8.2头文件
在使用C语言和其他语言进行程序设计的时候，我们需要头文件来提供对常数的定义和对系
统及库函数调用的声明。对C语言来说，这些头文件几乎永远被保仔在/usr/include及其下级子目
里那些依赖于你所运行的UNIX或Linux操作系统特定版本的头文件一般可以在/usr/include
/sys或成/usr/include/linux子月录里找到。
其他的群泽设计软件系统也可以有一些预先定义好的声明文件，它们的保存位置可以被相
应的编译器白动查到。比如X窗口系统的/usr/include/X11f月录和GNU的C++编译器的
/usr/include/g++-2子日录等。
加入jaVa编程群：524621833
---
## Page 28
第1章入门知识9
在调用C语言编译器的时候可以通过给出“-I”标志来引用保存在下级子目录或者非标准位
置的头文件、请看下面的命令：
gcc -I /usr/openwin/include fred.c
它会使编译器在/usr/openwin/include子自录和标准位置两个地方去查找fred.c程序里包括的
头文件。具体情况请参考你自已的C语言编译器使用手册。
用grep命令来查找含有某些特定定义与函数声明的头文件是很方便的。假设你想知道用来返
回程序退出状态的定义的名字，办法很简单：先进人/usr/include子目录，然后在grep命令里给出
该名字的几个字母，如下所示：
$grep xxIr_*.h
sdlib.h:#define
EXIT_FAILURE
stdlib.h: #detine
EXIT_SUCCESS
*Pailing exit status.*/
/* Successful exit status.*/
grep命令会在该子目录里所有名字以.h结尾的文件里查找字符串“EXiT_"。在上面的例子
里，它（从其他文件中间）在文件stdlib.h里找到了我们需要的定义。
1.8.3库文件
库文件是一些预先编译好的函数的集合，那些函数都是按照可再使用的原则编写的。它们
通常由一组互相关联的用来完成某项常见工作的函数构成。比如用来处理屏幕显示情况的函数
（curses库）和数据库访问例程（dbm库）等。我们将在后续章节遇到这些函数库文件。
标准的系统库文件一般被保存在/lib或者/usr/lib子目录里。人们必须告诉C语言编译器（更
确切地说是链接程序）去查找哪些库文件：在默认的情况下，它只会查找C语言的标准库文件。
这是从计算机速度还很慢、CPU周期还很昂费的年代遗留下来的问题：在当时，把一个阵文件
放到标准化子目录里然后寄希望于编译器自己找到它是不实际的：库文件必须遵守一定的命名
规则，还必须在命令行”明确地给出来。
表示这是--个C语言库；而“m”表示这是一个数学运算库等）。文件名的最后部分以--个句点
（.）开始，然后给出这个库文件的类型，如下所示：
—
8传统的静态型函数库。
so和.sa共享型函数库（见下面的解释）。
函数库一般分为静态和共享两种格式，用“ls/usr/lib”命令查一下就能看到。在你通知编译
器查找某个库文件的时候，既可以给出其完整的路径名，也可以使用“-1”标志。如下所示：
cc -o fred fred.c/usr/lib/libm.a
这条命令让编译器对fred.c文件进行编译，编译得到的程序保存到fred文件；在处理函数定
义和引用时除了在C语言的标准库里进行查找外还要到数学运算库里进行查找。下面的命令也能
实现同样的效果：
cc -o fred fred.c -1n
“-Im”（在字母“1”和“m”之间没有空格）是-种简略写法（简略写法在UNIX环境里是
加入jaVa编程群：524621833
---
## Page 29
10Linux程序设计
很有用的）.它代表的是标准库目录（本例中是/usr/lib）中的名为libm.a的函数库。“-lm”记号
的额外好处是编译器会自动选用共享库（如果存在的话）。
虽然库文件在大多数情况下与头文件很相似，都是被保存在某个标准的位置，但我们仍然
可以通过“L”（大写字母）标志给编译器增加搜索子目录，如下所示：
void fred(int arg)
printf(*fred: you passed td\n*, arg):
include 
void bi1l(char *arg)
printf(*bill: you passed s\n*, arg);
F
我们对这两个函数分别进行编译以生成能够添加到一个函数库里去的二进制目标文件。这
需要在调用C编译器的时候加上“-c”选项以制止编译器试图生成最终的程序。因为我们没有定
义一个名为main的函数，所以直接生成程序将是失败的。
加入jaVa编程群：524621833
---
## Page 30
第1章入门知识
bil1.o fred.o
2）现在来编写一个程序，让它调用函数bil1。首先，为我们的函数库建立一个头文件。它的
作用是在我们的函数库里对这两个函数进行声明；如果有程序要使用我们的函数库，就必须用
includc语句引用它。
/*
This is lib.h. It declares the functions fred and bill for users
*/
[ PO
void fred(int);
实际工作中最好把这个头文件也包括在fred.c和bill.c文件里去，这样可以帮助编译器查找错误。
3）调用者程序（program.c）可以非常简单。它用include语句引用我们的函数库并调用其中
的一个函数。
#include *lib.h*
int main()
bill(*Hello Wor1d*):
exit(0);
1
4）现在来编译并测试这个程序。这一次，我们向编译器明确地给出目标代码文件，让它编
译我们的文件并把它与我们刚才编译的目标模块bill.o链接起来。
S cc -c program.c
$./program
Scc -oprogram progran.obill.o
bill: you passed Hello Wor1d
5）现在来编译并使用一个库。我们用ar程序来建立档案，并把我们的目标代码文件添加到
其中。这个程序之所以被叫做ar就是因为它是用来建立档案或者说把一组独立的小文件集中到一
个大文件里去的。请注意，我们还可以通过ar把任何类型的文件归为档案（和许多UNIX工具一
样，它是一个很基本的软件工具）。
Sar crv libfoo.a bill.o fred.o
a - fred.o
a - bill.0
函数库建立好了，两个目标文件也添加进去了。在某些系统，尤其是从BerkleyUNIX操作
系统演化而来的系统上，要想成功地使用函数库，必须先为这个函数库建立一个内容表。我们
用ranlib命令来完成这一工作。如果是在Linux里使用GNU的软件开发工具，这一步就不是必要
的（加上也不会有什么副作用）。
S ranlib libfoo.a
我们的函数库现在就可以用了。我们可以在编译器命令行的文件清单里加上我们的函数库
来建立我们的程序了，如下所示：
$ cc -o progran program,o libfoo.a
bill: you passed Hello World
./progru
加入jaVa编程群：524621833
---
## Page 31
12
Linux程序设计
我们也可以通过“-1”选项来访问我们的函数库，但是因为它并没有被保存在某个标准的地
点，所以需要使用“-L”选项告诉编译器到哪儿才能找到它，如下所示：
S cc-o progran progran.o-L.-1foo
libfoo.a的函数库（或者一个名为libfoo.so的共享库—如果有的话）
要想查看某个目标代码文件、函数库或者可执行程序单部包含有哪些两数，我们可以使用
nm命令。如果我们查看下program和libfoo.a，就会看到函数库里包含着fred和bill两个函数，
面program里只包含着billi函数。在编译程序的时候，只有程序中确实用到的函数才会被包括过
去，虽然·个头文件里包含着函数库中的全体函数，但在程序里使用include语句引用它并不会
把整个函数库的内容都包括到最终程序中去
如果读者熟悉MS-DOS或微软Windows的软件开发工作，就会发现两者之间存许多相似的
地方：
UNIX
DOS
标代码模块
func , 0
FINC 0BJ
静态数库
1 :b d
I.TR.LTB
program
PROGRAM.FXE