2
1
2
1
2
1
1
3
2
1
1
1
1
2
3
P
1
1
1
1
1
1
Real Testbed. Our real testbed consists of two commodity
RVs: a 3DR Solo [1] and an Erle-Rover [18]. 3DR Solo is a
typical commercial quadrotor that leverages heterogeneous
and redundant sensors for ﬂight stability. The aerial vehicle is
highly dynamic and can be easily affected by environmental
factors. The 3DR Solo system is implemented in Pixhawk
2 from the open-source autopilot project Pixhawk [44], and
uses APM:Copter, an open-source ﬂight controller based on
the MAVlink protocol and part of the ArduPilot project [2].
Erle-Rover is equipped with various sensors and is a represen-
tative ground RV. Erle-Rover is implemented with Erle-Brain
3, a linux-based system provided by Erle Robotics. We use
the open-source control software APMrover 2 for the rover.
Table 2 lists the sensors in 3DR Solo and Erle-Rover. 3DR
has 12 sensors and the rover has 6. Note that many sensors
are replicated with different hardware to avoid the same type
of failures. For example, 3DR has three gyroscope sensors
manufactured by different vendors. To compromise the en-
tire set of sensors of the same type, the attacker should have
different attack techniques.
Attack and Recovery Setting. To generate the physical sen-
sor attacks discussed earlier (See Section 1), we insert attack
modules into the ﬁrmware. Since it is difﬁcult to implement
the actual hardware attacks which require special devices, we
simulate the same effects with the attack modules - but the
actual attack does not access internals. Speciﬁcally, we add a
piece of malicious code into the sensor interface that transmits
the sensor measurements to the main closed control loop. The
attacks modify sensor measurements (through attack code)
to mimic the effect of real "controlled attacks" that control
sensor readings (e.g, a sinusoidal wave, random or selected
values). Moreover, we consider continuous attacks rather than
instantaneous attacks since temporary attacks can be easily
recovered by our method. We map Mavlink commands to var-
ious attack types to remotely trigger via the ground control.
We say recovery is successful, when after an attack is
launched, the technique detects it and triggers the recovery
logic to ensure the current states are within a certain error
bound of the expected states for a certain period of time:
Rsucc := |Yt − ¯Yt| ≤ ε,t ∈ [1...k]
(7)
where Yt is the real output, ¯Yt is prediction, ε is the error
margin, t is the timestamp in the recovery mode, and k is
the maximum time to decide recovery success. For example,
ε = 3 and k = 10 indicate that a RV performs missions within
3 meters error for 10 seconds under the recovery mode.
Note that our recovery technique does not consider the
previous maneuvers (at t ≤ 0) since our software sensors
accurately predict the real measurements in the "various ma-
neuvers" (Figure 12). As long as recovery starts with the
accurate initial states via software sensors, subsequent sensor
feedbacks are precise and the control loop can obviously con-
trol the vehicle to stable states and recover. Also, our goal is
to prevent immediate crash and provide the transition time for
emergency operation (e.g., manual mode), not to replace the
compromised sensor permanently. Therefore, after recovery
mode on, the vehicle would conduct stable operation (e.g.,
hovering) before changing to the emergency operation.
4.2 Experiments and Results
4.2.1 Efﬁciency
In terms of the space overhead, we measure the ﬁrmware size
before and after our recovery code is inserted. For the runtime
overhead, we compare the execution time of the main control
loop before and after. Speciﬁcally, we ﬁrst measure the (space
and runtime) cost of the original code as a baseline, which
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    357
Vehicle
Sensors
Model
Location
STMicroelectronics
InvenSense
STMicroelectronics
Pixhawk 2 (onboard)
Gyroscope1
Gyroscope2
Gyroscope3
Manufacturer
InvenSense
InvenSense
Table 2: Sensors in 3DR Solo quadrotor and Erle-Rover
Measurement
Angular Rate
Angular Rate
Angular Rate
Acceleration
Acceleration
Acceleration
Magnetic Field
Magnetic Field
Magnetic Field
Air Pressure
Air Pressure
Pixhawk 2
Pixhawk 2
Pixhawk 2
Pixhawk 2
Pixhawk 2
Pixhawk 2
Pixhawk 2
Body (Leg)
Pixhawk 2
Pixhawk 2
Body (Head)
MPU6000
MPU6000
L3GD20
Accelerometer1 Measurement Specialties MPU6000
MPU6000
Accelerometer2
Accelerometer3
LSM303D
HMC 5983
Magnetometer1
LSM303D
Magnetometer2
HMC 5983
Magnetometer3
MS5611
MS5611
NEO-7M
Erle-Brain
Erle-Brain
Erle-Brain
Neo-M8N
Erle-Brain
Neo-M8N
Measurement Specialties
Measurement Specialties
Erle Robotics
Erle Robotics
Erle Robotics
Angular Rate
Erle-Brain 3 (onboard)
Erle-Brain 3 (onboard)
Acceleration
Erle-Brain 3 (onboard) Magnetic Field
Magnetic Field
Air Pressure
Erle-Brain 3 (onboard)
External (roof)
Gyroscope
Gravity Sensor
Barometer1
Barometer2
GPS
Erle Robotics
u-blox
u-blox
Compass1
Compass2
Honeywell
STMicroelectronics
Honeywell
Pressure Sensor
GPS
External (roof)
Position
Data Type
Frequency
Angular Motion
Angular Motion
Angular Motion
Linear Motion
Linear Motion
Linear Motion
Angular Position
Angular Position
Angular Position
Linear Position
Linear Position
Linear Position
Angular Motion
Linear Motion
Angular Position
Angular Position
Linear Position
Linear Position
400Hz
400Hz
400Hz
400Hz
400Hz
400Hz
100Hz
100Hz
100Hz
50Hz
50Hz
50Hz
50 Hz
50 Hz
10 Hz
10 Hz
10 Hz
50 Hz
3DR Solo
Erle-Rover
u-blox
Position
does not include the recovery code. Then, for each sensor, we
insert the recovery code including the required libraries that
correspond to the sensor (e.g., ﬁlters and utility functions)
and measure the overhead. Finally, we insert all the recovery
code for all sensors to obtain the total overhead (for all the
simulated and real RVs).
(a) GPS sensor (positon E)
(b) Barometer (pressure)
Figure 10: Space and Runtime overhead
Space Overhead. Unlike traditional computing systems, RVs
usually have limited memory space. As such, code size is an
important performance factor. As shown in Figure 10, the
increase of code size (i.e., additional ﬁrmware size needed)
incurred by our recovery modules is marginal. The space
overhead is at most 1.3% when all software sensors are loaded
and less than 0.7% for individual sensors. Note that some
code pieces are shared across software sensors. The simulated
vehicles have negligible overhead since the executables are
relatively larger than those of the real vehicles.
Runtime Overhead. We measure the average per-iteration
execution time of the main loop which includes various con-
trol functions and auxiliary tasks. In ArduCopter and APM-
rover2, the system loop execution frequency is 400HZ and
50Hz respectively. Every 2.5ms or 20ms, the scheduler exe-
cutes the control functions, and then schedules auxiliary tasks
using the remaining time in the epoch. Basically, all the tasks
should be completed within the hard deadline (i.e., 2.5ms or
20ms). Figure 10 shows the results. The runtime overhead
introduced by the recovery module for single sensor recovery
is at most 6.9%, whereas, for multiple sensor recovery, the
total overhead is at most 8.8%. We also consider the CPU
utilization rate (for real vehicles), which is the iteration exe-
cution time over the hard deadline. For the 3DR Solo, the rate
(c) Gyroscope (roll rate)
(d) Magnetometer (normalized)
Figure 11: Sensor prediction
increases from 63.32% to at most 67.68% (i.e., by 4.36%)
for single sensor recovery, and to 68.88% (i.e., by 5.56%)
for multiple sensor recovery. For the Erle-rover, the rate in-
creases from 26.7% to at most 27.8% (i.e., by 0.9%), and to
28.4% (i.e., by 1.7%) for single and multiple sensor recovery,
respectively. Note that the observed overhead does not im-
pact normal operations, as the per-iteration runtime does not
exceed the hard deadline. Real recovery cases in Section 4.3
demonstrate that our technique is practically effective.
4.2.2 Effectiveness
We evaluate effectiveness as follows. (1) We ﬁrst show soft-
ware sensors can precisely predict real sensor measurements
under various maneuvers; (2) we show that the error correc-
tion techniques can effectively attenuate the prediction errors;
(3) we demonstrate that parameter selection is effective; (4)
we show that our framework can successfully recover from
multiple attacks with real vehicles in real environments; (5)
last, we further evaluate our technique under various environ-
mental conditions and attack scales.
Software Sensors. Figure 11 shows how closely software
sensors predict (blue lines) the real readings (red lines) in
the various maneuvers of 3DR Solo. The ﬁgures for other
358    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
systems are similar and hence omitted. It can be observed
that there are errors (e.g. drift and external error) between the
predictions and the real measurements, which we will remove
using the error correction techniques demonstrated below.
sensors can produce accurate predictions after correction.
(a) Roll prediction and accumulated errors without correction
(b) Roll prediction and error correction with synchronization
Figure 12: Drift correction with synchronization and error reset
Error Corrections. Figure 12 shows the drift in the roll angle
prediction before and after error correction. We measure the
roll value and the prediction error during a real ﬂight of the
quadrotor (left of (a)). As shown in (b), at each window start,
the initial state is synchronized, and the accumulated error is
reset. As such, the accumulated error is signiﬁcantly reduced
(right of (b)). In this experiment, we used 1.0s window size
with the main sampling rate Ts = 2.5ms. The results for other
sensors and vehicles are similar.
(a) False positives rates
Figure 14: Different recovery parameters and FP/FN rates
(b) False negative rates
Parameter Selection We study the effect of recovery param-
eters (i.e., window size and recovery switch threshold) on
the recovery mode activation. We generate 20 missions (i.e.,
a sequence of primitive moves like straight ﬂy, turns, etc.)
with no attack, to measure the FP rates (i.e. how many times
recovery is activated), and 20 missions with the injected at-
tacks to measure the FN rates (i.e. how many times recovery
activation is missed). Figure 14 shows the results for different