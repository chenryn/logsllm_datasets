CHECK SERVICE TRANSACTION)
cacheﬂush(*,*,0,0,*)
clone(child stack=*,ﬂags=CLONE VM|CLONE FS|CLONE FILES|CLONE SIGHAND|CLONE THREAD|CLONE SYSVSEM)
connect(*,{sa family=AF UNIX,
connect(*,{sa family=AF UNIX,
access(, F OK)
access(,X OK)
access(,
R OK|W OK|X OK)
brk
chdir
access(,R OK)
access(, F OK)
bind
connect(*,{sa family=AF INET,*,*},*)
path=@”jdwp-control”},*)
path=},*)
socket(PF INET,SOCK STREAM,
socket(PF INET,SOCK STREAM,
socket(PF UNIX, SOCK STREAM, 0)
statfs64(,*)
umask
utimes
stat64
symlink(,)
uname
vfork
10
epoll create(*)
execve
exit group()
fcntl64(,F GETFD)
fcntl64(,F SETFL,*)
fork
ftruncate(*,*)
getegid32
getpeername
getppid
getrlimit(RLIMIT NOFILE,*)
getrusage(RUSAGE SELF,*)
getsockopt(*,SOL SOCKET,
SO PEERCRED,*,*)
getuid32
ioctl(,*,*)
ioctl(*,SIOCGIFCONF,*)
ioctl(*,SIOCGIFINDEX,*)
ioctl(*,SNDCTL TMR TIMEBASE
or TCGETS,*)
lseek(*,*,SEEK CUR)
lstat64
madvise(*,*,MADV RANDOM)
mmap2
munmap
open(,*)
pipe
prctl(PR SET NAME,*,*,*,*)
ptrace(PTRACE TRACEME,*,0,0)
recvmsg
rt sigprocmask(SIG BLOCK,*,*,*)
rt sigtimedwait([QUITUSR1],
NULL, NULL, 8)
sched yield
sendto
setpriority(PRIO PROCESS,*,0)
setsockopt(*,SOL SOCKET,*,*,*)
sigaction
sigprocmask(SIG UNBLOCK,*,*)
socket(PF INET,SOCK DGRAM,
IPPROTO ICMP)
IPPROTO IP)
dup
epoll ctl(*,*,*,*)
exit()
exit group(0)
fcntl64(*,F GETFL)
fcntl64(,F SETLK,*)
fstat64
futex
geteuid32
getpgid(0)
getpriority(PRIO PROCESS,*)
getrlimit(RLIMIT STACK,*)
getsockname
getsockopt(*,SOL SOCKET,SO RCVBUF,*,*)
ioctl(,*,*)
ioctl(*,SIOCGIFADDR,*)
ioctl(*,SIOCGIFFLAGS,*)
ioctl(*,SIOCGIFNETMASK,*)
ioctl(,
SNDCTL TMR TIMEBASE or TCGETS,*)
lseek(*,*,SEEK END)
madvise(*,*,MADV DONTNEED)
mkdir(,*)
mprotect
nanosleep
open(,*,*)
poll
prctl(PR SET NAME,*,*,*,0)
readlink(,*,*)
rename(,)
rt sigprocmask(SIG SETMASK,*,*,*)
sched getparam
select
setitimer(ITIMER REAL,*,*)
setrlimit(RLIMIT NOFILE,*)
set tls(*,*,*,*,*)
sigprocmask(SIG BLOCK,*,*)
sigreturn
socket(PF INET,SOCK DGRAM,
IPPROTO IP)
IPPROTO TCP)
cacheﬂush(*,*,0,*,*)
chmod(,*)
connect(*,{sa family=AF UNIX,
path=@”android:debuggerd”},*)
dup2
epoll wait
exit(0)
fcntl64(,F DUPFD,*)
fcntl64(,F SETFD,*)
fdatasync(*)
fsync(*)
getcwd
getgid32
getpid
getrlimit(RLIMIT DATA,*)
getrusage(RUSAGE CHILDREN,*)
getsockopt(*,SOL SOCKET,SO ERROR,*,*)
gettid
ioctl(*,FIONBIO,*)
ioctl(*,SIOCGIFBRDADDR,*)
ioctl(*,SIOCGIFHWADDR,*)
ioctl(, SNDCTL TMR
TIMEBASE or TCGETS, *)
listen
lseek(*,*,SEEK SET)
madvise(*,*,MADV NORMAL)
mkdir(,*)
mremap(*,*,*,MREMAP MAYMOVE)
open(,*,*)
open(,*)
prctl(PR GET NAME,*,0,0,0)
prctl(PR SET NAME,*,0,0,0)
recvfrom
rmdir()
rt sigreturn(*)
sched getscheduler
sendmsg
setpriority(PRIO PROCESS,*,)
setsockopt(*,SOL IP,*,*,*)
set tls(*,*,0,*,*)
sigprocmask(SIG SETMASK,*,*)
sigsuspend([])
socket(PF INET,SOCK DGRAM,
IPPROTO UDP)
socket(PF NETLINK,SOCK RAW, 0)
statfs64(,*)
tgkill(*,*,SIGTRAP)
unlink()
wait4
TABLE XV.
SYMBOLS USED TO REPLACE THE ARGUMENTS OF
SYSTEM CALLS.
A ﬁle path in the apps’
directory or in the sdcard
A ﬁle path different than the
 A ﬁle descriptor equal 0, 1, or 2
ones represented by 
“/dev/random” or “/dev/urandom”
“/dev/ashmem”
“/dev/log/system”, “/dev/log/main”,
“/dev/log/events” or “/dev/log/radio”
A negative number
A ﬁle descriptor different than 0, 1, or 2
An integer greater than 0
fully block a number of root exploits. Similarly, we believe
that useful policies can be generated by our dynamic analysis
system that will be able to block future exploits.
B. Java Methods
Even with the system call restrictions, native code can still
perform dangerous actions by invoking Java methods. This can
be accomplished by using certain JNI functions, as discussed in
Section III-B. Static analysis of the Java component of apps
cannot identify these calls, therefore, the possibility of apps
calling methods in Java libraries poses a threat to the system
and can be abused by malicious apps.
We performed the same process presented in Section V-A
to automatically generate policies that restrict
the use of
methods in Java libraries. Table XVII presents these policies,
using different values as the minimum percentage of allowed
apps that reached native code during dynamic analysis. We
used 97%, 98%, and 99% as the values for the minimum.
The methods authorized for each threshold include the ones
associated with lower thresholds.
Using the list of apps associated with a minimum of
allowed apps of 99% (the most permissive of our thresh-
olds), we would block 1,414 apps (0.12%). The method
java.lang.ClassLoader.loadClass, which is al-
lowed when using 99% as a threshold, causes the invocation
of the static initialization block () of a class.
Therefore, it could be used to execute the static initialization
block of classes in Java libraries. However, as far as we know,
these blocks do not contain important operations that need to
be contained.
VI.
IMPACT OF SECURITY POLICIES
Considering both our policies—Java methods and system
calls—, and the 99% threshold, we would block 0.23% (2,730)
of all the apps in our dataset. To understand what the impact
of implementing (and enforcing with the strictest enforcement
mechanism) these policies would be on users, we analyzed the
popularity (lower number of installations) of the apps whose
behavior seen during the dynamic analysis would be blocked.
Figure 2 presents the cumulative distribution of the popularity
of the apps that would be blocked. As the ﬁgure shows, among
the applications for which our policy would block at least one
behavior that has been executed at runtime, 1.87% (51) of them
have more than 1 million installations.
Because manual analysis is very time-consuming, we did
not perform it on all blocked apps. However, we did a general
Fig. 2.
Popularity of apps that would be blocked by enforcing our policy.
X-axis is in logarithmic scale, and the Y -axis is the percentage of apps that
would be blocked.
investigation of the blocked apps and manually analyzed the
ones that showed traces of suspicious behavior. We identiﬁed
three types of suspicious activities among these apps, and we
discuss them here.
Ptrace. Overall, 280 apps used ptrace. 276 of these only
call ptrace to trace itself without checking the result. We
assume that the developers do this as a defensive measure to
prevent the analysis of the app, because an app cannot be
traced by another process if there is already a process tracing
it. Therefore, for these 276 apps we believe that the app’s
functionality would remain intact with our policy. Four apps,
on the other hand, create a child process, which try to attach
ptrace to the parent, checking the result of the call and
changing behavior if the call failed.
Modifying Java code. We identiﬁed 7 apps that modify the
Java section of the app from native code. All these apps per-
form this action from the library libAPKProtect.so [3].
This library is provided by an obfuscation service, thus making
it harder for reverse engineering tools to decompile the app.
This functionality can also be used by malicious apps and
illustrates the importance of isolating native code.
Fork and inotify. We identiﬁed 57 apps that create a child
process in native code and use inotify to monitor the apps’
directory, in order to identify when they are uninstalled. In fact,
the spawned child process uses inotify to detect when the
app is uninstalled and, when this happens, it opens a survey in
the browser. This behavior is not a malicious action; however,
executing code after being uninstalled is suspicious, as the user
does not expect the app to be running after being uninstalled.
VII. DYNAMIC COVERAGE
Dynamic analysis is inherently incomplete, and in this
section we attempt
to measure the code coverage of the
dynamic analysis that we used, using function coverage of the
11
1e+001e+021e+041e+061e+080.00.20.40.60.81.0Number of installs1.87 % −>  1M+TABLE XVI.
THIS TABLE SHOWS THE LIST OF CONSIDERED ROOT EXPLOITS, ON WHICH SYSCALL-LEVEL BEHAVIOR THEY RELY, AND WHICH
EXPLOITS ARE SUCCESSFULLY BLOCKED BY OUR POLICY.
Exploid (CVE-2009-1185)
Needs a NETLINK socket with NETLINK_KOBJECT_UEVENT protocol
GingerBreak (CVE-2011-1823) Needs a NETLINK socket with NETLINK_KOBJECT_UEVENT protocol
Description
RATC (CVE-2010-EASY)
Name / CVE
CVE-2013-2094
Vold/ASEC [34]
CVE-2013-6124
CVE-2011-1350
Zimperlinch
CVE-2011-1352
CVE-2011-1149
CVE-2012-4220
CVE-2012-4221
CVE-2012-4222
Uses perf_event_open system call
Creates symbolic link to a system directory
Relies on invoking many times the fork syscall
Creates symbolic links to system ﬁles
ioctl call used violates our rules
Relies on invoking many times the fork syscall
ioctl call used violates our rules
It relies on the mprotect syscall
ioctl call used violates our rules
ioctl call used violates our rules
ioctl call used violates our rules
Blocked
Yes
Yes
Yes
Yes
No
Yes
Yes
No
Yes
No
Yes
Yes
Yes
TABLE XVII.
LIST OF ALLOWED METHODS (JAVA METHODS CALLED
FROM NATIVE CODE) AUTOMATICALLY GENERATED FOR ALLOWING A
MINIMUM OF 97%, 98% AND 99% OF APPS THAT REACHED NATIVE CODE.
Allowed
apps (%)
97
97
97
98
98
98
98
98
98
98
98
98
98
98
98
98
98
99
99
99
99
99
99
99
99
99
99
Method
java.lang.Integer.doubleValue
android.content.ContextWrapper.getPackageName
java.lang.String.getBytes
java.lang.Double.doubleValue
android.content.ContextWrapper.getClassLoader
android.content.ContextWrapper.getFilesDir
java.io.File.getPath
android.content.ContextWrapper.getExternalFilesDir
android.view.WindowManagerImpl.getDefaultDisplay
java.lang.String.toLowerCase
android.app.Activity.getWindowManager
android.view.View.getWindowVisibleDisplayFrame
java.util.ArrayList.add
android.view.Display.getMetrics
android.app.Activity.getWindow
java.util.Calendar.getInstance
android.view.View.getDrawingRect
java.util.Calendar.get
android.os.Bundle.getByteArray
android.content.ContextWrapper.getPackageManager
android.content.res.AssetManager$AssetInputStream.read
java.lang.Long.doubleValue
java.lang.ClassLoader.loadClass
android.app.ApplicationPackageManager.getPackageInfo
android.content.res.AssetManager$AssetInputStream.close
java.lang.Float.doubleValue
java.lang.Class.getClassLoader
Java code and function coverage of the native code. Both code
coverage methods have large overhead, so we were only able
to analyze a subset of the apps.
A. Java Method Code Coverage
To measure the code coverage based on the Java methods
executed, we instrumented the DVM. The instrumented code
records the execution of every method of the app under
analysis. Since this instrumentation introduces more overhead
and slows the emulator, we did the experiment with 25,000
apps randomly selected and used a kernel driver,
instead
of strace, to record the system calls executed. The code
coverage obtained was 8.31%