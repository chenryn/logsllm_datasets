Glucose Monitoring Proﬁle: Bluetooth proﬁle speciﬁca-
tion v1.0.1, 12 2015.
[11] BLUETOOTH SPECIAL INTEREST GROUP. Bluetooth
core speciﬁcation v5.0, 12 2016.
[12] BLUETOOTH SPECIAL INTEREST GROUP. Bluetooth
mesh networking / an introduction for developers, 2017.
[13] BRONZI, W., FRANK, R., CASTIGNANI, G., AND EN-
GEL, T. Bluetooth Low Energy performance and robust-
ness analysis for inter-vehicular communications. Ad
Hoc Netw. 37, P1 (Feb 2016), 76–86.
[14] CYR, B., HORN, W., MIAO, D., AND SPECTER, M.
Security analysis of wearable ﬁtness devices (Fitbit).
Massachusetts Institute of Technology (2014).
[15] DAS, A. K., PATHAK, P. H., CHUAH, C.-N., AND MO-
HAPATRA, P. Uncovering privacy leakage in BLE net-
work trafﬁc of wearable ﬁtness trackers. In Proceedings
of the 17th International Workshop on Mobile Comput-
ing Systems and Applications (2016), ACM, pp. 99–104.
[3] ANDROID. Bluetooth Low Energy overview, Apr 2018.
[Online]. Available: https://developer.android.
com/guide/topics/connectivity/bluetooth-le.
[Accessed: 18 July 2018].
[16] DESNOS, A., ET AL. Androguard: Reverse engineer-
ing, malware and goodware analysis of Android appli-
cations ... and more (ninja !). https://github.com/
androguard/androguard.
USENIX Association
28th USENIX Security Symposium    15
[17] EGELE, M., BRUMLEY, D., FRATANTONIO, Y., AND
KRUEGEL, C. An empirical study of cryptographic mis-
use in Android applications. In Proceedings of the 2013
ACM SIGSAC conference on Computer & communica-
tions security (2013), ACM, pp. 73–84.
[18] ELKHODR, M., SHAHRESTANI, S., AND CHEUNG,
H. Emerging wireless technologies in the Internet of
Things: A comparative study. International Journal of
Wireless & Mobile Networks (IJWMN) 8, 5 (Oct 2016),
67–82.
[19] FAWAZ, K., KIM, K.-H., AND SHIN, K. G. Protect-
ing privacy of BLE device users. In USENIX Security
Symposium (2016), pp. 1205–1221.
[20] FIDO ALLIANCE.
FIDO Bluetooth Speciﬁcation
https://fidoalliance.org/specs/
v1.0, 2017.
fido-u2f-bt-protocol-id-20150514.pdf.
[21] FRITZ, C., ARZT, S., AND RASTHOFER, S. Droid-
bench: A micro-benchmark suite to assess the stability
of taint-analysis tools for Android. https://github.
com/secure-software-engineering/DroidBench.
[22] GOMEZ, C., OLLER, J., AND PARADELLS, J. Overview
and evaluation of Bluetooth Low Energy: An emerging
low-power wireless technology. Sensors (Basel, Switzer-
land) 12, 9 (2012), 11734–11753.
[23] GUO, X., YIN, Y., DONG, C., YANG, G., AND ZHOU,
G. On the class imbalance problem. In Natural Compu-
tation, 2008. ICNC’08. Fourth International Conference
on (2008), vol. 4, IEEE, pp. 192–201.
[24] HOFFMANN, J., USSATH, M., HOLZ, T., AND SPRE-
ITZENBARTH, M. Slicing Droids: Program slicing
In Proceedings of the 28th Annual
for smali code.
ACM Symposium on Applied Computing (2013), ACM,
pp. 1844–1851.
[25] IDC. Worldwide wearables market grows 7.3% in Q3
2017 as smart wearables rise and basic wearables de-
cline, says IDC. [Online]. Available: https://github.
com/secure-software-engineering/DroidBench
[Accessed 16-Feb-2017].
[26] JENI, L. A., COHN, J. F., AND DE LA TORRE, F. Fac-
ing imbalanced data–recommendations for the use of
performance metrics. In Affective Computing and In-
telligent Interaction (ACII), 2013 Humaine Association
Conference on (2013), IEEE, pp. 245–251.
[27] KARANI, R., DHOTE, S., KHANDURI, N., SRINI-
VASAN, A., SAWANT, R., GORE, G., AND JOSHI, J.
Implementation and design issues for using Bluetooth
Low Energy in passive keyless entry systems. In In-
dia Conference (INDICON), 2016 IEEE Annual (2016),
IEEE, pp. 1–6.
[28] KOROLOVA, A., AND SHARMA, V. Cross-app tracking
via nearby Bluetooth Low Energy devices. In Privacy-
Con 2017 (2017), Federal Trade Commission.
[29] KRÜGER, S., NADI, S., REIF, M., ALI, K., MEZINI,
M., BODDEN, E., GÖPFERT, F., GÜNTHER, F., WEIN-
ERT, C., DEMMLER, D., ET AL. CogniCrypt: support-
ing developers in using cryptography. In Proceedings
of the 32nd IEEE/ACM International Conference on
Automated Software Engineering (2017), IEEE Press,
pp. 931–936.
[30] KRÜGER, S., SPÄTH, J., ET AL. CogniCrypt_SAST:
CrySL-to-static analysis compiler. https://github.
com/CROSSINGTUD/CryptoAnalysis/.
[31] NAVEED, M., ZHOU, X., DEMETRIOU, S., WANG, X.,
AND GUNTER, C. A. Inside job: Understanding and
mitigating the threat of external device mis-binding on
Android. In 21st Annual Network and Distributed Sys-
tem Security Symposium, NDSS 2014, San Diego, Cali-
fornia, USA, February 23-26, 2014 (2014).
[32] NORDIC SEMICONDUCTOR.
droid v1.0.1.
[Online]. Available:
//devzone.nordicsemi.com/attachment/
bdd561ff56924e10ea78057b91c5c642.
05 Feb 2018].
BLE on An-
https:
[Accessed:
[33] ORACLE.
Java Cryptography Architecture (JCA)
[Online]. Available: https:
Reference Guide.
//docs.oracle.com/javase/8/docs/technotes/
guides/security/crypto/CryptoSpec.html.
[Accessed: 18 July 2018].
[34] PAUCK, F., BODDEN, E., AND WEHRHEIM, H. Do
Android taint analysis tools keep their promises? In
Proceedings of the 2018 26th ACM Joint Meeting on
European Software Engineering Conference and Sym-
posium on the Foundations of Software Engineering
(New York, NY, USA, 2018), ESEC/FSE 2018, ACM,
pp. 331–341.
[35] POEPLAU, S., FRATANTONIO, Y., BIANCHI, A.,
KRUEGEL, C., AND VIGNA, G. Execute this! Ana-
lyzing Unsafe and malicious dynamic code loading
In NDSS (2014), vol. 14,
in Android applications.
pp. 23–26.
[36] QIU, L., WANG, Y., AND RUBIN, J. Analyzing the an-
alyzers: FlowDroid/IccTA, AmanDroid, and DroidSafe.
In Proceedings of the 27th ACM SIGSOFT International
Symposium on Software Testing and Analysis (2018),
ACM, pp. 176–186.
16    28th USENIX Security Symposium
USENIX Association
[37] RYAN, M. Bluetooth: With low energy comes low se-
In 7th USENIX Workshop on Offensive Tech-
curity.
nologies, WOOT ’13, Washington, D.C., USA, August
13, 2013 (2013).
[38] SILVA, B. N., KHAN, M., AND HAN, K. Internet of
Things: A comprehensive review of enabling technolo-
gies, architecture, and challenges. IETE Technical Re-
view 35, 2 (2018), 205–220.
[39] UNIVERSITÉ DU LUXEMBOURG. Lists of APKs. [On-
line]. Available: https://androzoo.uni.lu/lists.
[Accessed: 12 Nov 2018].
[40] WEI, F., ROY, S., OU, X., ET AL. Amandroid: A precise
and general inter-component data ﬂow analysis frame-
work for security vetting of Android apps. In Proceed-
ings of the 2014 ACM SIGSAC Conference on Computer
and Communications Security (2014), ACM, pp. 1329–
1341.
1 .method private
2
3
4
5
6
7
8
9
10
11
12
13
14
a(Landroid/bluetooth/BluetoothGatt;[B...)V
.locals 10
.prologue
const/4 v9, 0x2
const/4 v8, 0x3
const/4 v7, 0x1
...
invoke-virtual {v0, v3},
Landroid/bluetooth/BluetoothGattService;->
getCharacteristic(Ljava/util/UUID;)
Landroid/bluetooth/BluetoothGattCharacteristic;
move-result-object v3
...
invoke-virtual {v3, p2},
Landroid/bluetooth/BluetoothGattCharacteristic;
->setValue([B)Z
invoke-virtual {v1, v3},
Landroid/bluetooth/BluetoothGatt;
->writeCharacteristic(Landroid/bluetooth/
BluetoothGattCharacteristic;)Z
Appendix A: BLECryptracer Logic
Figure 8: Sample smali code for BLE attribute write.
We describe here the basic tracing mechanism employed
by BLECryptracer in order to identify the presence of
application-layer security for BLE data.
Backtracing BLE writes
BLE writes use one of the setValue methods in Table 2
to ﬁrst set the value that is to be written, before calling the
method for performing the actual write. BLECryptracer iden-
tiﬁes all calls to these methods, and then traces the origins of
the data held in the registers that are passed as input to the
methods.
Considering the smali4 code in Figure 8 as an example,
setValue is invoked at Line 13 and is passed two registers as
input. As setValue is an instance method, the ﬁrst input, lo-
cal register v3, holds the BluetoothGattCharacteristic
object that the method is invoked on. The second input, pa-
rameter register p2, holds the data that is to be written to
the BLE device, and is the second argument that is passed
to the method a (Line 1). BLECryptracer identiﬁes p2 as the
register that holds the data of interest, and traces backward
to determine if this data is the result of some cryptographic
processing. To achieve this, the method(s) within the APK
that invoke method a are identiﬁed, and the second input to
each such method is traced. If the BLE data had come from a
local register, rather than a parameter register, BLECryptracer
would trace back within method a’s instructions, to deter-
mine the origin of the data. This backtracing is performed
until either a crypto-library is referenced, or a const-<> or
4Android applications are typically written in Java and converted into
Dalvik bytecode. The smali format can be considered an “intermediate” step
between the high-level Java source and the bytecode.
new-array declaration is encountered (which would indicate
that no cryptography is used). Note that calls to any method
within the crypto-libraries mentioned in Section 4.2 are ac-
cepted as evidence of the use of cryptography with BLE data.
The tool stops processing an APK at the ﬁrst instance where
such a method call is identiﬁed.
During execution, the BLECryptracer maintains a list of
registers (set within the context of a method) to be traced,
for each setValue method call within the application code.
This initially contains a single entry, which is the input to
the setValue method. A new register is added to the list if it
appears to have tainted the value of any of the registers already
in the list. This could be due to simple operations such as
aget, aput or move-<> (apart from move-result variants),
or it could be as a result of a comparison, arithmetic or logic
operation (in which case, the register holding the operand
on which the operation is performed is added to the trace
list). Similarly, if a register obtains a value from an instance
ﬁeld (via sget or iget), then all instances where that ﬁeld is
assigned a value are analyzed. However, the script does not
analyze the order in which the ﬁeld is assigned values, as this
would require activity life-cycle awareness.
Where a register is assigned a value that is output from a
method invocation via move-result, if the method is not an
external method, then the instructions within that method are
analysed, beginning with the return value and tracing back-
wards. In some instances, the actual source of a register’s
value is obfuscated due to the use of intermediate formatting
functions. In an attempt to overcome this, BLECryptracer
traces the inputs to called methods as well. Further, if a regis-
ter is used as input to a method, then all other registers that are
USENIX Association
28th USENIX Security Symposium    17
1 .method public onCharacteristicread(Landroid/bluetooth/
BluetoothGatt;Landroid/bluetooth/
BluetoothGattCharacteristic;I)V
...
invoke-virtual {p2}, Landroid/bluetooth/
BluetoothGattCharacteristic;->getValue()[B
move-result-object v0
new-instance v2, Ljava/lang/StringBuilder;
invoke-direct {v2},
Ljava/lang/StringBuilder;->()V
const-string v3, "read value: "
invoke-virtual {v2, v3},
Ljava/lang/StringBuilder;->append(Ljava/lang/
String;)Ljava/lang/StringBuilder;
move-result-object v2
invoke-static {v0},
Ljava/util/Arrays;->toString([B)Ljava/lang/ String;
move-result-object v3
invoke-virtual {v2, v3},
Ljava/lang/StringBuilder;->append(Ljava/lang/
String;)Ljava/lang/StringBuilder;
move-result-object v2
...
2
3
4
5
6
7
8
9
10
11
12
13
14
Figure 9: Sample smali code for BLE attribute read.
inputs to the method are also added to the trace list. While this
captures some indirect value assignments, it runs the risk of
false positives. For this reason, we have included the concept
of Conﬁdence Levels for the code output.
If, for an APK, the input to the setValue method can be
backtraced to cryptography directly, via only register value
transfers and as immediate results of method invocations, then
a conﬁdence level of “High” is assigned to the result. If a reg-
ister cannot be traced back directly to a cryptographic output,
but if an indirect trace identiﬁes the use of a cryptography
library, then a conﬁdence level of “Medium” is assigned. Fi-
nally, in the event that no cryptography use is identiﬁed at
High or Medium conﬁdence levels, the script performs a less
stringent search through all the instructions of the methods
that it previously analyzed. This risks including instances
of cryptography use with functions unrelated to BLE and is
therefore assigned a “Low” conﬁdence level.
Forward-tracing BLE reads
With BLE reads, a getValue variant is invoked and the output,
i.e., the value that is read, is moved to a register. To trace this
value, BLECryptracer identiﬁes all calls to getValue variants,
then traces the output registers and all registers they taint
until either a crypto-library is referenced or the register value
changes. Such value changes can occur due to new-array,
new-instance and const declarations, as well as by being
assigned the output of various operations (such as method
invocations or arithmetic/logic operations).
With forward-tracing, the register holding the BLE data is
considered to taint another if, for example, the source register
is used in a method invocation, or comparison/arithmetic/logic
operation, whose result is assigned to the destination register.
The destination register is then added to the trace list. When
a register is used as input to a method, then along with the
output of that method, the use of the register within the method
is also analyzed.
This method of analysis tends to result in a “tree” of traces.
As an example, considering the smali code in Figure 9, the
byte array output from the BLE read is stored in register
v0 (Line 4). This taints register v3 via a format conversion
function (Lines 10 and 11), which in turn taints v2 via a
java.lang.StringBuilder function (Lines 12 and 13). At
this point, all three registers are tainted and will be traced
until their values change.
The forward-tracing mode also assigns one of three
conﬁdence levels to its output. “High” is assigned when
cryptographically-processed data is identiﬁed via the tracing
mechanism above; “Medium” is when the use of cryptogra-
phy is identiﬁed by tracing classes that implement interfaces.
“Low” is assigned when a less stringent search through all
encountered methods results in identiﬁcation of a reference
to a cryptography library (similar to the backtracing case).
Handling obfuscation
APKs sometimes employ obfuscation techniques to protect
against reverse-engineering, and the question then arises as
to whether these techniques may impact the results of our
analysis. We therefore brieﬂy discuss different obfuscation
techniques and why they do not impact our tool.
One of the most common techniques is identiﬁer renam-
ing, where identiﬁers within the code are replaced with short,
meaningless names. However, because Androguard operates
on smali (rather than Java) code, BLECryptracer is able to
overcome the challenges posed by this technique. String en-
cryption is another obfuscation mechanism, but it again does
not affect the output of our tool as BLECryptracer does not
search for hard-coded strings. Further, our tool was veriﬁed
successfully against three out of four benchmarking applica-
tions that utilized reﬂection. The most complex obfuscation
techniques are packing and runtime-based obfuscation, but
these are typically employed by malware. Because we are
looking for vulnerable (not malicious) applications, we do not
consider these techniques. Therefore, in general, we believe
our analysis to be unaffected by most benign obfuscation
mechanisms.
18    28th USENIX Security Symposium
USENIX Association