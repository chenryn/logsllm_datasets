### `HTTP/1.1` - 1999
`HTTP/1.0` 经过仅仅 3 年，下一个版本，即 `HTTP/1.1` 就在 1999 年发布了，改进了它的前身很多问题，主要的改进包括：
* **增加了许多 HTTP 请求方法**，包括 `PUT`、`PATCH`、`HEAD`、`OPTIONS`、`DELETE`。
* **主机标识符** `Host` 在 `HTTP/1.0` 并不是必须的，而在 `HTTP/1.1` 是必须的。
* 如上所述的**持久连接**。在 `HTTP/1.0` 中每个连接只有一个请求并在该请求结束后被立即关闭，这导致了性能问题和增加了延迟。 `HTTP/1.1` 引入了持久连接，即连接在默认情况下是不关闭并保持开放的，这允许多个连续的请求使用这个连接。要关闭该连接只需要在头信息加入 `Connection: close`，客户通常在最后一个请求里发送这个头信息就能安全地关闭连接。
* 新版本还引入了“ 管线化   （    pipelining    ） ”的支持，客户端可以不用等待服务器返回响应，就能在同一个连接内发送多个请求给服务器，而服务器必须以接收到的请求相同的序列发送响应。但是你可能会问了，客户端如何知道哪里是第一个响应下载完成而下一个响应内容开始的地方呢？要解决这个问题，头信息必须有 `Content-Length`，客户可以使用它来确定哪些响应结束之后可以开始等待下一个响应。
	+ 值得注意的是，为了从持久连接或管线化中受益， 头部信息必须包含 `Content-Length`，因为这会使客户端知道什么时候完成了传输，然后它可以发送下一个请求（持久连接中，以正常的依次顺序发送请求）或开始等待下一个响应（启用管线化时）。
	+ 但是，使用这种方法仍然有一个问题。那就是，如果数据是动态的，服务器无法提前知道内容长度呢？那么在这种情况下，你就不能使用这种方法中获益了吗？为了解决这个问题，`HTTP/1.1` 引进了分块编码。在这种情况下，服务器可能会忽略 `Content-Length` 来支持分块编码（更常见一些）。但是，如果它们都不可用，那么连接必须在请求结束时关闭。
* 在动态内容的情况下**分块传输**，当服务器在传输开始但无法得到 `Content-Length` 时，它可能会开始按块发送内容（一块接一块），并在传输时为每一个小块添加 `Content-Length`。当发送完所有的数据块后，即整个传输已经完成后，它发送一个空的小块，比如设置 `Content-Length` 为 0 ，以便客户端知道传输已完成。为了通知客户端块传输的信息，服务器在头信息中包含了 `Transfer-Encoding: chunked`。
* 不像 HTTP/1.0 中只有 Basic 身份验证方式，`HTTP/1.1` 包括 摘要验证方式   （    digest authentication    ） 和 代理验证方式   （    proxy authentication    ） 。
* 缓存。
*  范围请求   （    Byte Ranges    ） 。
* 字符集。
*  内容协商   （    Content Negotiation    ） 。
* 客户端 cookies。
* 支持压缩。
* 新的状态码。
* 等等。
我不打算在这里讨论所有 `HTTP/1.1` 的特性，因为你可以围绕这个话题找到很多关于这些的讨论。我建议你阅读 [`HTTP/1.0` 和 `HTTP/1.1` 版本之间的主要差异](http://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf)，希望了解更多可以读[原始的 RFC](https://tools.ietf.org/html/rfc2616)。
`HTTP/1.1` 在 1999 年推出，到现在已经是多年前的标准。虽然，它比前一代改善了很多，但是网络日新月异，它已经垂垂老矣。相比之前，加载网页更是一个资源密集型任务，打开一个简单的网页已经需要建立超过 30 个连接。你或许会说，`HTTP/1.1` 具有持久连接，为什么还有这么多连接呢？其原因是，在任何时刻 `HTTP/1.1` 只能有一个未完成的连接。 `HTTP/1.1` 试图通过引入管线来解决这个问题，但它并没有完全地解决。因为一旦管线遇到了缓慢的请求或庞大的请求，后面的请求便被阻塞住，它们必须等待上一个请求完成。为了克服 `HTTP/1.1` 的这些缺点，开发人员开始实现一些解决方法，例如使用 spritesheets、在 CSS 中编码图像、单个巨型 CSS / JavaScript 文件、[域名切分](https://www.maxcdn.com/one/visual-glossary/domain-sharding-2/)等。
### SPDY - 2009
谷歌走在业界前列，为了使网络速度更快，提高网络安全，同时减少网页的等待时间，他们开始实验替代的协议。在 2009 年，他们宣布了 `SPDY`。
> 
> `SPDY` 是谷歌的商标，而不是一个缩写。
> 
> 
> 
显而易见的是，如果我们继续增加带宽，网络性能开始的时候能够得到提升，但是到了某个阶段后带来的性能提升就很有限了。但是如果把这些优化放在等待时间上，比如减少等待时间，将会有持续的性能提升。这就是 `SPDY` 优化之前的协议的核心思想，减少等待时间来提升网络性能。
> 
> 对于那些不知道其中区别的人，等待时间就是延迟，即数据从源到达目的地需要多长时间（单位为毫秒），而带宽是每秒钟数据的传输量（比特每秒）。
> 
> 
> 
`SPDY` 的特点包括：复用、压缩、优先级、安全性等。我不打算展开 `SPDY` 的细节。在下一章节，当我们将介绍 `HTTP/2`，这些都会被提到，因为 `HTTP/2` 大多特性是从 `SPDY` 受启发的。
`SPDY` 没有试图取代 HTTP，它是处于应用层的 HTTP 之上的一个传输层，它只是在请求被发送之前做了一些修改。它开始成为事实标准，大多数浏览器都开始支持了。
2015年，谷歌不想有两个相互竞争的标准，所以他们决定将其合并到 HTTP 协议，这样就导致了 `HTTP/2` 的出现和 `SPDY` 的废弃。
### `HTTP/2` - 2015
现在想必你明白了为什么我们需要另一个版本的 HTTP 协议了。 `HTTP/2` 是专为了低延迟地内容传输而设计。主要特点和与 `HTTP/1.1` 的差异包括：
* 使用二进制替代明文
* 多路传输 - 多个异步 HTTP 请求可以使用单一连接
* 报头使用 HPACK 压缩
* 服务器推送 - 单个请求多个响应
* 请求优先级
* 安全性
![](/data/attachment/album/201609/26/222101jfrcxjyrbmeumxfd.png)
#### 1. 二进制协议
`HTTP/2` 通过使其成为一个二进制协议以解决 HTTP/1.x 中存在的延迟问题。作为一个二进制协议，它更容易解析，但可读性却不如 `HTTP/1.x`。 帧   （    frames    ） 和 流   （    stream    ） 的概念组成了 `HTTP/2` 的主要部分。
**帧和流**
现在 HTTP 消息是由一个或多个帧组成的。`HEADERS` 帧承载了 元数据   （    meta data    ） ，`DATA` 帧则承载了内容。还有其他类型的帧（`HEADERS`、`DATA`、`RST_STREAM`、`SETTINGS`、`PRIORITY` 等等），这些你可以通过 [HTTP/2 规范](https://http2.github.io/http2-spec/#FrameTypes)来了解。
每个 `HTTP/2` 请求和响应都被赋予一个唯一的流 ID，并切分成帧。帧就是一小片二进制数据。帧的集合称为流，每个帧都有个标识了其所属流的流 ID，所以在同一个流下的每个帧具有共同的报头。值得注意的是，​除了流 ID 是唯一的之外，​由客户端发起的请求使用了奇数作为流 ID，从来自服务器的响应使用了偶数作为流 ID。
除了 `HEADERS` 帧和 `DATA` 帧，另一个值得一提的帧是 `RST_STREAM`。这是一个特殊的帧类型，用来中止流，即客户可以发送此帧让服务器知道，我不再需要这个流了。在 `HTTP/1.1` 中让服务器停止给客户端发送响应的唯一方法是关闭连接，这样造成了延迟增加，因为之后要发送请求时，就要必须打开一个新的请求。而在 `HTTP/2`，客户端可以使用 `RST_STREAM` 来停止接收特定的数据流，而连接仍然打开着，可以被其他请求使用。
#### 2. 多路传输
因为 `HTTP/2` 是一个二进制协议，而且如上所述它使用帧和流来传输请求与响应，一旦建立了 TCP 连接，相同连接内的所有流都可以同过这个 TCP 连接异步发送，而不用另外打开连接。反过来说，服务器也可以使用同样的异步方式返回响应，也就是说这些响应可以是无序的，客户端使用分配的流 ID 来识别数据包所属的流。这也解决了 HTTP/1.x 中请求管道被阻塞的问题，即客户端不必等待占用时间的请求而其他请求仍然可以被处理。
#### 3. HPACK 请求头部压缩
RFC 花了一篇文档的篇幅来介绍针对发送的头信息的优化，它的本质是当我们在同一客户端上不断地访问服务器时，许多冗余数据在头部中被反复发送，有时候仅仅是 cookies 就能增加头信息的大小，这会占用许多宽带和增加传输延迟。为了解决这个问题，`HTTP/2` 引入了头信息压缩。
![](/data/attachment/album/201609/26/222101he6zaua8bz3b085g.png)
不像请求和响应那样，头信息中的信息不会以 `gzip` 或者 `compress` 等格式压缩。而是采用一种不同的机制来压缩头信息，客户端和服务器同时维护一张头信息表，储存了使用了哈夫曼编码进行编码后的头信息的值，并且后续请求中若出现同样的字段则忽略重复值（例如 用户代理   （    user agent    ） 等），只发送存在两边信息表中它的引用即可。
我们说的头信息，它们同 `HTTP/1.1` 中一样，并在此基础上增加了一些伪头信息，如 `:scheme`，`:host` 和 `:path`。
#### 4. 服务器推送
服务器推送是 `HTTP/2` 的另一个巨大的特点。对于服务器来说，当它知道客户端需要一定的资源后，它可以把数据推送到客户端，即使客户端没有请求它。例如，假设一个浏览器在加载一个网页时，它解析了整个页面，发现有一些内容必须要从服务端获取，然后发送相应的请求到服务器以获取这些内容。
服务器推送减少了传输这些数据需要来回请求的次数。它是如何做到的呢？服务器通过发送一个名字为 `PUSH_PROMISE` 特殊的帧通知到客户端“嘿，我准备要发送这个资源给你了，不要再问我要了。”这个 `PUSH_PROMISE` 帧与要产生推送的流联系在一起，并包含了要推送的流 ID，也就是说这个流将会被服务器推送到客户端上。
#### 5. 请求优先级
当流被打开的时候，客户端可以在 `HEADERS` 帧中包含优先级信息来为流指定优先级。在任何时候，客户端都可以发送 `PRIORITY` 帧来改变流的优先级。
如果没有任何优先级信息，服务器将异步地无序地处理这些请求。如果流分配了优先级，服务器将基于这个优先级来决定需要分配多少资源来处理这个请求。
#### 6. 安全性
在是否强制使用 `TLS` 来增加安全性的问题上产生了大范围的讨论，讨论的结果是不强制使用。然而大多数厂商只有在使用 `TLS` 时才能使用 `HTTP/2`。所以 `HTTP/2` 虽然规范上不要求加密，但是加密已经约定俗成了。这样，在 `TLS` 之上实现 `HTTP/2` 就有了一些强制要求，比如，`TLS` 的最低版本为 `1.2`，必须达到某种级别的最低限度的密钥大小，需要布署 ephemeral 密钥等等。
到现在 `HTTP/2` 已经[完全超越了 SPDY](http://caniuse.com/#search=http2)，并且还在不断成长，HTTP/2 有很多关系性能的提升，我们应该开始布署它了。
如果你想更深入的了解细节，请访问[该规范的链接](https://http2.github.io/http2-spec)和 [HTTP/2 性能提升演示的链接](http://www.http2demo.io/)。请在留言板写下你的疑问或者评论，最后如果你发现有错误，请同样留言指出。
这就是全部了，我们之后再见~
---
via: 
作者：[Kamran Ahmed](http://github.com/kamranahmedse) 译者：[NearTan](https://github.com/NearTan) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出