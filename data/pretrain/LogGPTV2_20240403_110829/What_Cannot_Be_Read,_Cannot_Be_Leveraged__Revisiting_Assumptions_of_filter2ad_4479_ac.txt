0x2000: push ebp
; 0xe8fb1f0000
; 0xe8f61f0000
; 0x5d(@FUN_1)
f u n c t i o n j s _ c a l l _ g a d g e t () {
/* emits a call */
a s m _ c a l l () ;
a s m _ c a l l () ;
/* ... ( many a s m _ c a l l () s t a t e m e n t s ) */
a s m _ c a l l () ;
}
Figure 2: Direct call
Listing 1: JavaScript function js call gadget
IE: IE deploys JIT-hardening mechanisms that go be-
yond the protections in Chrome and Firefox. IE (i) has
a size limit on code segments generated by the JIT com-
piler, and (ii) randomly inserts NOPs (i.e., instructions
that do not change the program state) in JIT-compiled
code. Because of (i), we can only emit two-byte gadgets.
Due to (ii), these gadgets are then further modiﬁed by in-
serting NOPs inside the if body and, thus, changing the
value emitted in the conditional jump. The latter tech-
nique is similar to librando [17]. Nevertheless, even with
these defenses in place, we can still emit arbitrary two-
byte gadgets by measuring the size of the emitted code
at run time. We will describe this attack in Section 4.4 in
the discussion about Internet Explorer.
4.3 Direct Call Gadgets
We found that conditional jumps are not the only in-
structions to embed implicit constants that can be in-
directly controlled by the attacker. Direct calls (e.g.,
call 0x1234560) are another example of such instruc-
tions. In our second approach, we leverage the JavaScript
statements that are compiled to instructions containing
direct calls.
Direct call constants: Direct calls in x86/x64 change the
execution ﬂow of the program by modifying the instruc-
tion pointer (eip/rip). The constant encoded in a direct
call instruction represents a relative address of the callee.
That is, the call instruction’s displacement ﬁeld contains
the distance between the addresses of the instruction fol-
lowing the call and the callee. Therefore, any two di-
rect call instructions to the same function will encode
different constants. For example, in Figure 2, there are
two consecutive calls to the function FUN 1 (at address
0x2000). The constant encoded in the ﬁrst call denotes
the distance between FUN 1 and the instruction following
the call (i.e., the second call at 0x05). Therefore, its value
is 0x2000-0x5=0x1ffb, which is 0xfb1f0000 encoded in
little-endian.
In the example above, the difference between two con-
secutive direct call constants is 0x5 (the size of a direct
call instruction). In general, the difference is equal to the
size of the instructions between two consecutive calls. In
our case, we want to use JavaScript statements to emit
direct calls in the JIT-compiled code. Therefore, the dif-
ference between the constants will be the size of the in-
structions in which the JavaScript statement is compiled.
To generalize this attack vector, we aim for a
JavaScript function similar to js call gadget (List-
ing 1). The asm call() statement is a placeholder for
any JavaScript statement (not necessarily a function call)
that is compiled into a sequence of instructions contain-
ing a direct call. The exact statement that replaces the
placeholder depends on the target browser.
Finding callee address: Let our goal be to emit a three-
byte gadget and ﬁx its third byte to 0xc3 (ret). To cal-
culate the constant encoded in the displacement ﬁeld of
a direct call instruction, we have to know the addresses
of the call instruction and its destination. The destina-
tions of the emitted call instructions that we have encoun-
tered are either helper functions (e.g., inline caches gen-
erated by V8) or built-in functions (such as Math.random
or String.substring). The helper functions are JIT-
compiled by V8 as regular functions. We can leak
their addresses either by stack reading (e.g., by leaking
the return address put there by the call instruction in-
side the helper function), or by reading the V8’s heap,
where all the references of compiled helper functions
are stored.
In IE, the built-in functions are located in
libraries and thus are randomized via ﬁne-grained ASLR
schemes [12, 11, 17]. However, their corresponding
JavaScript objects (e.g., Math.random) contain the code
pointer to the function. Knowing the structure of these
JavaScript objects, which are not randomized according
to our assumptions, we can get the addresses of built-in
functions via a memory disclosure vulnerability. Note
that after code pointer hiding, the addresses that the at-
tacker leaks from these JavaScript objects will be the ad-
dresses of the trampolines and not the actual functions.
Nevertheless, offsets, encoded in call (or jump) instruc-
tions, will also be computed relative to the trampolines
and thus can be used for calculating emitted constants.
Emitting call instructions: Knowing the address of the
callee, the next step is to emit direct call instructions at
the correct distance. Given that we cannot inﬂuence the
address where the function will be compiled, we have to
acquire sufﬁciently large code space to cover all three-
byte distances to the callee. To this end, we create a
JavaScript function that spans 0x1 00 00 00 bytes after JIT
compilation and consists of JavaScript statements emit-
ting direct calls. More precisely, we require the dis-
tance between the ﬁrst and the last emitted direct call
USENIX Association  
25th USENIX Security Symposium  145
7
instructions to be at least 0x1 00 00 00 bytes. This way,
regardless of where our function is allocated, we will be
guaranteed that it covers all possible three-byte distances
from the callee, allowing us to emit arbitrary three-byte
gadgets by carefully placing direct call instructions.
Emitting required gadgets: Creating such a large func-
tion (16 MB) emits many three-byte gadgets, and also
covers all two-byte gadgets. For example, if we have a
JavaScript statement that generates a call instruction and
is compiled to 0x10 bytes of native code, we can create a
big function containing this statement 0x10 00 00 times.
The compiled function will have 0x10 00 00 direct call
instructions 0x10 bytes apart.
If we consider the least
signiﬁcant three bytes of the emitted displacement ﬁelds
of these direct calls, they will have the following form:
0x*Y ** **, where * denotes any hexadecimal digit [0-f]
and Y is a constant, which encodes the least signiﬁcant
half-bytes of emitted values.
Because of the little-endian format used in x86/x64 ar-
chitectures, Y is part of the ﬁrst byte of emitted gadgets.
Therefore, to emit three-byte gadgets, we must be able
to set Y accordingly. To this end, we modify the value of
Y by varying the size of the instructions before the ﬁrst
direct call. That is, we ﬁnd any JavaScript statement that
compiles to an odd number of bytes, and then use it up to
15 times to get any out of all possible 16 half-bytes. For
example, if the least signiﬁcant half-byte of the call in-
struction is 0x0 and we want to make it 0xd, and we have
a JavaScript statement that compiles to an odd number of
bytes (e.g., i+=1 in 32-bit Chrome, 0x13 bytes), we use
this statement 15 times (0x13*15=0x11d).
Computing addresses of emitted gadgets: Assuming
that the address of the ﬁrst call instruction in our func-
tion is Fcall, and the address of the callee is Fdest, we
can compute three bytes of the displacement ﬁeld of
the ﬁrst call instruction by C1=Fdest -(Fcall +5) mod 224. If
the required gadget is G, then we can compute the dis-
tance (dist) between the call instruction, emitting G,
and the ﬁrst call instruction: dist=C1-G mod 224. Using
dist, we can calculate the address of the call instruc-
tion emitting G (Fcall +dist), and therefore the address of
the gadget (Gaddr) which is located 1 byte after the call:
Gaddr=(Fcall +dist)+1.
4.4 Direct Call Gadgets in Browsers
We will next discuss techniques that we use to instantiate
the attack in three popular browsers.
Firefox: Emission of direct call gadgets is not possible in
Firefox, as the baseline JIT compiler of Firefox does not
emit direct calls. Although the optimizing JIT compiler
of Firefox emits direct calls, e.g., when compiling regular
expressions, it only optimizes JavaScript functions after
they have been executed more than 1,000 times. Trig-
gering the optimizing compiler on the large functions (as
required for our attack) thus makes our attack impractical
against Firefox.
Chrome: Chrome compiles most JavaScript statements
to direct calls. Consequently, we have a large selection
of JavaScript statements with varying post-compilation
sizes. We use a statement that is compiled to 0x10 bytes
of assembly code (e.g., i=i+j for 32-bit Chrome). For
demonstration purposes, we aim to emit a system call
gadget (int 0x80;ret), implicitly also revealing all two-
byte gadgets. To this end, we create a function shown
in Figure 3(A). The function starts with a sequence of
JavaScript statements that align the ﬁrst call instruc-
tion to 0xe. After this, the emitted call distances will
be calculated relative to 0x3, i.e., (0xe+0x5) mod 0x10,
where a direct call is 0x5 bytes large. Considering that
the callee is at least half-byte aligned, the lower half-
byte of all emitted gadgets’ ﬁrst bytes will be 0xd, i.e.,
(0x0-0x3) mod 0x10. The alignment code is followed by
a sequence of call-generating statements (e.g., i=i+j),
each of which compiles to 0x10 byte-long code. The
compiled i=i+j statement emits a call instruction at off-
set 0x*e (due to alignment) as shown in Figure 3(B).
Generating a sequence of 0x10 00 00 call instructions, we
are guaranteed to have an int 0x80;ret gadget encoded
into one of the call instruction constants (Figure 3(C)).
Note that the aforementioned technique is used in the
32-bit version of Chrome. For 64-bit, we use the v++
statement, which is compiled to 0x20 bytes (instead of
0x10) and emits a call instruction. Having 0x20 bytes
between call instructions changes the upper half of the
least signiﬁcant byte. For example, after aligning the
least signiﬁcant half-byte to 0xd via padding, the emit-
ted ﬁrst bytes will be either 0x{0,2,4,6,8,a,c,e}d or
0x{1,3,5,7,9,b,d,f}d, depending on the initial value of
the upper half of the least signiﬁcant byte. We can mod-
ify this value to our liking by adding the i=i statement,
which is compiled to 0x10 bytes, as padding.
Internet Explorer: For the two main reasons mentioned
in Section 4.1 (code size limit and NOP insertion), emit-
ting gadgets is harder in IE. The per-function code size
limit forbids us to emit 0x1 00 00 00 bytes of native code,
which is required to span all possible third bytes of the
constants encoded in call instructions. However, in the
following, we describe how an attacker can still encode
gadgets in direct calls even in IE.
Emitting calls at correct distance: IE still allows us
to create many small functions. These functions will
be distributed in the set of pages, each of them be-
ing 0x2 00 00 bytes large. We thus allocate many func-
tions (200 in our case), each of them being (cid:31)0x1 00 00
bytes (i.e., two functions per page). Given the align-
ment (0x1 00 00) and the size (0x2 00 00) of the spanned
code pages, each page will cover two third-bytes of
146  25th USENIX Security Symposium 
USENIX Association
8
js_call_gadget_v8(){
function
  var
  // Align calls to 0xe
  i = i + j;
i,j;
  // i=i+j 0x3a86b times
  i = i + j;
  // i=i+j 0xc5793 times
  i = i + j;
}
0x*0: ...
0x*7: ...
0x*e: call BINARY_OP_IC
...
0x*7: ...
0x*e: call BINARY_OP_IC
...
0x*7: ...
0x*e: call BINARY_OP_IC
;e8  8d07feff
;e8  cd80c3ff
;e8  8d07fefe
(A) JavaScript function
(B) i=i+j direct calls
(C) Bytes emitted by direct calls
Figure 3: JavaScript function emitting gadgets via direct call constants
the absolute address completely (e.g., from 0x12 34 00 00
to 0x12 35 ff ff). Considering that the callee is not
aligned to the same boundary, direct calls emitted in
these pages will have three distinct third bytes in their
constants, only one of them covered completely. For
example,
if we assume the callee to be at address
0x12 34 56 70 and the page emitted at 0x01 70 00 00,
only the call instructions located in the address range
[0x01 70 56 70, 0x01 71 56 70] can emit complete three-
byte constants, having 0xc3 as their third byte, i.e., con-
stants from 0x12 34 56 70 - 0x01 70 56 70 = 0x10 c4 00 00
to 0x12 34 56 70 - 0x01 71 56 70 = 0x10 c3 00 00. On the
other hand, the ranges [0x01 70 00 00, 0x01 70 56 70] and
[0x01 71 56 70, 0x01 71 ff ff] cover only parts of the con-
stants, with 0xc4 and 0xc2 as their third bytes.
After allocating the functions, we dynamically check
their addresses to ﬁnd the one with the correct distance
from the callee (using the same technique as described
at the end of Section 4.1), i.e., the one having the cor-
rect third byte in its direct call instruction’s displace-
ment ﬁeld. Allocating 200 JavaScript functions, each of
them containing 0x1 00 00 bytes, is inefﬁcient, especially
if the code has to be downloaded to the victim’s machine.
Therefore, we use eval to spam IE’s code pages with the
dynamically created functions. The problem with evalu-
ated functions is that IE does not emit direct call instruc-
tions in them and uses indirect calls instead. Therefore,
we use these functions only as temporary placeholders.
Once we ﬁnd any evaluated function at the correct place,
we deallocate it to make its place available for the sub-
sequently compiled functions. To deallocate a JavaScript
function, we set null to all of its references and wait un-
til the garbage collector removes it (typically within less
than a second).
Verifying emitted gadgets: At ﬁrst sight, IE’s NOP
insertion conﬂicts with our assumption about the pre-
dictability of JIT-compiled code. With NOP insertion,
and likewise with many other ﬁne-grained code random-
ization schemes, we cannot guarantee that the call in-
struction, which is supposed to emit the gadget, ends up
f u n c t i o n j s _ c a l l _ g a d g e t _ I E () {
// Padding to correct address
var i = Math . random () ; // emit direct call
c h e c k _ a d d r e s s ( ) ;
}
Listing 2: JavaScript function js call gadget IE
at the correct address. However, because NOPs are in-
serted at random, compiling the same JavaScript func-
tion multiple times actually increases the chance that in
one of the compiled versions, the call instruction ends
up at the correct place.
Following our threat model, though, we cannot read
executable code segments to verify if the compiled
call instruction is at the desired place. As an alter-
native, we read the stack, as shown in Listing 2.
In
js call gadget IE(),
the statement i=Math.random()
emits a direct call. We pad the beginning of the
function with a few JavaScript statements to place
i=Math.random() at approximately the correct address,
such that the relative address would encode the desired
gadget, accounting the randomness induced by NOP in-
sertions. We then check the correctness of the position
via check address, a JavaScript function that reads the
stack to ﬁnd the return instruction pointer put there by
the call instruction.
Using the leaked return address, we can calculate
the address of the direct call instruction emitted by
i=Math.random(), verify that it is at the correct place
and if so, use it as a gadget. A simple implementation
of check address is shown in Listing 3, where it uses a
memory disclosure vulnerability (mem read in this case)
to read the stack from some starting point (ESP ), until
it ﬁnds its own parameter (cookie). The parameter is a
random number, reducing the chance that multiple po-
sitions have the same value (note that this chance can