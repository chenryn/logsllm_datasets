Program libraries are designed to
support a large number of functionalities for different users.
Library debloating customizes the general code base for each
program and leads to significant code reduction. Mulliner
et al. propose CodeFreeze to remove the unnecessary func-
tionalities from Windows shared libraries [36]. They start
from per-library control-flow analysis to identify the code
dependency of each exported function. Then they check the
program binary to find all required library functions. By
stitching program required functions and per-library CFG,
they rewrite the library to remove unreachable code region.
Similarly, Quach et al. [40] present library debloating through
piece-wise compilation and loading. Instead of customizing
the library for each program, they split the large library into
small groups based on the control-flow dependency. At run-
time, they use a customized loader to rewrite the library code
to remove unnecessary functions. Jiang et al. [23, 22] pro-
pose to remove dead code from Android Apps, Java Runtime
Environment, and SDKs. Our system is different from library
debloating in two ways. First, previous work performs the
binary rewriting at the beginning of each process, leading
to performance overhead for each execution, while RAZOR
generates the debloated binary through static binary rewrit-
ing, which is only performed once and used forever. Second,
library debloating utilizes static analysis to find the unused
code and has to conservatively keep all potentially useful
code. In contrast, our system relies on a dynamic execution
trace to locate the code that is executed during tracing or
inferred with our heuristic and removes all others.
Delta debugging. Delta debugging is proposed to minimize
bug-triggering inputs. For example, Regehr et al. [42] pro-
pose C-Reduce to generate a smaller test cases efficiently. Sun
et al. [49] present Perses, which exploits formal syntax to
generate smaller and functionally equivalent program in a
timely manner. Recently, Heo et al. [15] proposed CHISEL
to use reinforcement learning for further speeding up the
delta debugging process. However, the programs generated
by delta debugging only support given test cases, while real-
world software usually has an infinite number of test cases for
certain functionalities. Instead, RAZOR takes control-flow-
based heuristics to infer more related-code that is necessary
to complete the required functionalities.
Source code debloating.
Several recent works use pro-
gram analysis to debloat programs. Bu et al. [8] propose a
bloat-ware design paradigm that analyzes Java source code to
optimize object allocations to avoid memory usage bloating
at runtime. Sharif et al. [44] propose Trimmer, which prop-
agates a user-provided configuration to program code and
utilizes the compiler optimization to reduce code size. These
systems, as well as [42, 49, 15], rely on the complicated anal-
ysis of program source code, which is not always available
for deployed programs. In contrast, RAZOR only requires
program binaries, making it more practical for deployment.
Container Debloating. Containers are becoming more pop-
ular, and their code base is bloated. Guo et al. [14] proposed
a method to monitor the program execution to identify neces-
sary resources and create a minimal container for the traced
program. Rastogi et al. [41] developed Cimplifier, which
uses dynamic analysis to collect resource usages for different
programs and partitions the original container into a set of
smaller ones based on user-defined policies. The resulting
containers only have resources to run one or more executable
programs. The design of RAZOR is also applicable for de-
bloating containers or other systems. For example, Intel PT
supports tracing operating systems.
Hardware Debloating. Nowadays, hardware devices are
also bloated. For example, general-purpose processors are
overly designed for specific applications, such as implanta-
bles, wearables, and IoT devices. Cherupalli et al. propose an
approach that automatically removes unused gates from the
design of a general-purpose processor to generate a bespoke
processor for a specific application [10]. On average, the
approach can reduce the area by 62% and the power by 50%
from the general processor. Currently, software debloating
and hardware debloating are performed separately. An in-
teresting direction is to consider both hardware devices and
software programs to find more debloating space.
8 Conclusion
In this paper, we presented RAZOR, a framework for prac-
tical software debloating on program binaries. It utilizes a
set of test cases and control-flow-based heuristics to collect
necessary code to support user-expected functionalities. The
debloated binary has a reduced attack surface, improved se-
curity guarantee, robust functionality, and efficient execution.
Our evaluation shows that RAZOR is a practical framework
for debloating real-world programs.
Acknowledgment
We thank the anonymous reviewers, and our shepherd,
Michael Bailey, for their helpful feedback. This research
was supported in part by the DARPA Transparent Computing
program under contract DARPA-15-15-TC-FP006, by the
ONR under grants N00014-17-1-2895, N00014-15-1-2162
and N00014-18-1-2662. Any opinions, findings, conclusions
or recommendations expressed in this material are those of
the authors and do not necessarily reflect the views of DARPA
and ONR.
USENIX Association
28th USENIX Security Symposium    1747
References
[1] Martín Abadi, Mihai Budiu, Úlfar Erlingsson, and Jay
Ligatti. Control-Flow Integrity. In Proceedings of the
12th ACM Conference on Computer and Communica-
tions Security, 2005.
[2] Dennis Andriesse, Xi Chen, Victor van der Veen, Asia
Slowinska, and Herbert Bos. An In-Depth Analysis
of Disassembly on Full-Scale x86/x64 Binaries.
In
Proceedings of the 25th USENIX Security Symposium
(USENIX), 2016.
[3] Dennis Andriesse, Asia Slowinska, and Herbert Bos.
Compiler-Agnostic Function Detection in Binaries. In
Proceedings of the 2nd IEEE European Symposium on
Security and Privacy, 2017.
[4] Tiffany Bao, Jonathan Burket, Maverick Woo, Rafael
Turner, and David Brumley. BYTEWEIGHT: Learning
to Recognize Functions in Binary Code. In Proceedings
of the 23rd USENIX Conference on Security Symposium,
2014.
[5] Erick Bauman, Zhiqiang Lin, and Kevin Hamlen. Su-
perset Disassembly: Statically Rewriting x86 Binaries
Without Heuristics. In Proceedings of the 25th Annual
Network and Distributed System Security Symposium,
2018.
[6] Fabrice Bellard. QEMU, a Fast and Portable Dynamic
Translator. In Proceedings of the 2005 USENIX Annual
Technical Conference, 2005.
[7] Derek Bruening and Saman Amarasinghe. Efficient,
Transparent, and Comprehensive Runtime Code Manip-
ulation. PhD thesis, Massachusetts Institute of Tech-
nology, Department of Electrical Engineering and Com-
puter Science, 2004.
[8] Yingyi Bu, Vinayak Borkar, Guoqing Xu, and Michael J.
Carey. A Bloat-aware Design for Big Data Applications.
In Proceedings of the 2013 International Symposium on
Memory Management, 2013.
[9] Nathan Burow, Scott A. Carr, Joseph Nash, Per Larsen,
Michael Franz, Stefan Brunthaler, and Mathias Payer.
Control-Flow Integrity: Precision, Security, and Perfor-
mance. ACM Comput. Surv., 2017.
[10] Hari Cherupalli, Henry Duwe, Weidong Ye, Rakesh
Kumar, and John Sartori. Bespoke Processors for Ap-
plications with Ultra-low Area and Power Constraints.
In Proceedings of the 44th Annual International Sympo-
sium on Computer Architecture, 2017.
[11] Stephen Crane, Christopher Liebchen, Andrei Homescu,
Lucas Davi, Per Larsen, Ahmad-Reza Sadeghi, Stefan
Brunthaler, and Michael Franz. Readactor: Practical
Code Randomization Resilient to Memory Disclosure.
In Proceedings of the 36th IEEE Symposium on Security
and Privacy, 2015.
[12] Enes Göktas, Elias Athanasopoulos, Herbert Bos, and
Georgios Portokalidis. Out of Control: Overcoming
Control-Flow Integrity. In Proceedings of the 35th IEEE
Symposium on Security and Privacy, 2014.
[13] Google. V8 JavaScript Engine. https://chromium.
googlesource.com/v8/v8.git.
[14] Philip J. Guo and Dawson Engler. CDE: Using System
Call Interposition to Automatically Create Portable Soft-
ware Packages. In Proceedings of the 2011 USENIX
Annual Technical Conference, 2011.
[15] Kihong Heo, Woosuk Lee, Pardis Pashakhanloo, and
Mayur Naik. Effective Program Debloating via Rein-
forcement Learning. In Proceedings of the 25th ACM
SIGSAC Conference on Computer and Communications
Security, 2018.
[16] Gerard J. Holzmann. Code Inflation. IEEE Software,
32(2), Mar 2015.
[17] Hong Hu, Chenxiong Qian, Carter Yagemann, Simon
Pak Ho Chung, William R. Harris, Taesoo Kim, and
Wenke Lee. Enforcing Unique Code Target Property for
Control-Flow Integrity. In Proceedings of the 25th ACM
Conference on Computer and Communications Security,
2018.
[18] ImageTragick. ImageMagick Is On Fire: CVE-2016-
3714. https://imagetragick.com/.
[19] Intel. Control-Flow Enforcement Technology Pre-
view.
https://software.intel.com/sites/
default/files/managed/4d/2a/control-flow-
enforcement-technology-preview.pdf.
[20] Intel Corporation. Intel R⃝ 64 and IA-32 Architectures
Software Developer’s Manual, volume 3 (3A, 3B, 3C &
3D): System Programming Guide. November 2018.
[21] Yaoqi Jia, Zheng Leong Chua, Hong Hu, Shuo Chen,
Prateek Saxena, and Zhenkai Liang. The Web/Local
Boundary Is Fuzzy: A Security Study of Chrome’s
Process-based Sandboxing. In Proceedings of the 23rd
ACM SIGSAC Conference on Computer and Communi-
cations Security, 2016.
[22] Y. Jiang, D. Wu, and P. Liu. JRed: Program Customiza-
tion and Bloatware Mitigation Based on Static Analysis.
In 2016 IEEE 40th Annual Computer Software and Ap-
plications Conference, 2016.
1748    28th USENIX Security Symposium
USENIX Association
[23] Yufei Jiang, Qinkun Bao, Shuai Wang, Xiao Liu, and
Dinghao Wu. RedDroid: Android Application Redun-
dancy Customization Based on Static Analysis. In Pro-
ceedings of the 29th IEEE International Symposium on
Software Reliability Engineering, 2018.
[24] Volodymyr Kuznetsov, László Szekeres, Mathias Payer,
George Candea, R. Sekar, and Dawn Song. Code-
Pointer Integrity. In Proceedings of the 11th USENIX
Conference on Operating Systems Design and Imple-
mentation, 2014.
[25] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish
Patil, Artur Klauser, Geoff Lowney, Steven Wallace,
Vijay Janapa Reddi, and Kim Hazelwood. Pin: Build-
ing Customized Program Analysis Tools with Dynamic
Instrumentation. In Proceedings of the 2005 ACM SIG-
PLAN Conference on Programming Language Design
and Implementation, 2005.
[26] Haoyu Ma, Kangjie Lu, Xinjie Ma, Haining Zhang,
Chunfu Jia, and Debin Gao. Software Watermarking
Using Return-Oriented Programming. In Proceedings
of the 10th ACM Symposium on Information, Computer
and Communications Security, 2015.
[27] John Martellaro. Why Your iPhone Uses PNG
https:
for Screen Shots and JPG for Photos.
//www.macobserver.com/tmo/article/why-
your-iphone-uses-png-for-screen-shots-
and-jpg-for-photos.
[28] The Top 500 Sites on the Web. https://www.alexa.
com/topsites.
[29] Dromaeo-DOM. http://dromaeo.com/?dom.
[30] Dromaeo-JS. http://dromaeo.com/?dromaeo.
[31] The Heartbleed Bug. http://heartbleed.com/.
[32] Function and Macro Index. https://www.gnu.org/
software/libc/manual/html_node/Function-
Index.html.
[33] Octane. https://chromium.github.io/octane.
[34] SunSpider.
https://webkit.org/perf/
sunspider-1.0.2/sunspider-1.0.2/driver.
html.
[35] CVE-2014-0038:
X32 ABI.
bin/cvename.cgi?name=CVE-2014-0038, 2014.
Privilege
in
https://cve.mitre.org/cgi-
Escalation
[37] Ben Niu and Gang Tan. Per-Input Control-Flow In-
tegrity. In Proceedings of the 22nd ACM SIGSAC Con-
ference on Computer and Communications Security,
2015.
[38] The Chromium Projects.
Site
Isolation.
https://www.chromium.org/Home/chromium-
security/site-isolation.
[39] Anh Quach, Rukayat Erinfolami, David Demicco, and
Aravind Prakash. A Multi-OS Cross-Layer Study of
Bloating in User Programs, Kernel and Managed Exe-
cution Environments. In Proceedings of the 2017 Work-
shop on Forming an Ecosystem Around Software Trans-
formation, 2017.
[40] Anh Quach, Aravind Prakash, and Lok Yan. Debloating
Software through Piece-Wise Compilation and Loading.
In Proceedings of the 27th USENIX Security Symposium,
2018.
[41] Vaibhav Rastogi, Drew Davidson, Lorenzo De Carli,
Somesh Jha, and Patrick McDaniel. Cimplifier: Auto-
matically Debloating Containers. In Proceedings of the
11th Joint Meeting on Foundations of Software Engi-
neering, 2017.
[42] John Regehr, Yang Chen, Pascal Cuoq, Eric Eide,
Chucky Ellison, and Xuejun Yang. Test-case Reduc-
tion for C Compiler Bugs. In Proceedings of the 33rd
ACM SIGPLAN Conference on Programming Language
Design and Implementation, 2012.
[43] Felix Schuster, Thomas Tendyck, Christopher Liebchen,
Lucas Davi, Ahmad-Reza Sadeghi, and Thorsten Holz.
Counterfeit Object-oriented Programming: On the Diffi-
culty of Preventing Code Reuse Attacks in C++ Appli-
cations. In Proceedings of the 36th IEEE Symposium on
Security and Privacy, 2015.
[44] Hashim Sharif, Muhammad Abubakar, Ashish Gehani,
and Fareed Zaffar. TRIMMER: Application Specializa-
tion for Code Debloating. In Proceedings of the 33rd
ACM/IEEE International Conference on Automated Soft-
ware Engineering, 2018.
[45] Eui Chul Richard Shin, Dawn Song, and Reza Moazzezi.
Recognizing Functions in Binaries with Neural Net-
works. In Proceedings of the 24th USENIX Conference
on Security Symposium, 2015.
[36] Collin Mulliner and Matthias Neugschwandtner. Break-
ing Payloads with Runtime Code Stripping and Image
Freezing. In Black Hat USA Briefings (Black Hat USA),
Las Vegas, NV, August 2015.
[46] Igor Skochinsky.
tions and RTTI.
content/uploads/2012/06/Recon-2012-
Skochinsky-Compiler-Internals.pdf, 2012.
Excep-
http://www.hexblog.com/wp-
Compiler
Internals:
USENIX Association
28th USENIX Security Symposium    1749
[47] Kevin Z. Snow, Fabian Monrose, Lucas Davi, Alexandra
Dmitrienko, Christopher Liebchen, and Ahmad-Reza
Sadeghi. Just-In-Time Code Reuse: On the Effective-
ness of Fine-Grained Address Space Layout Random-
ization. In Proceedings of the 34th IEEE Symposium on
Security and Privacy, 2013.
[48] Peter Snyder, Cynthia Taylor, and Chris Kanich. Most
Websites Don’t Need to Vibrate: A Cost-Benefit Ap-
proach to Improving Browser Security. In Proceedings
of the 2017 ACM SIGSAC Conference on Computer and
Communications Security, 2017.
[49] Chengnian Sun, Yuanbo Li, Qirun Zhang, Tianxiao Gu,
and Zhendong Su. Perses: Syntax-guided Program
Reduction. In Proceedings of the 40th International
Conference on Software Engineering, 2018.
[50] Caroline Tice, Tom Roeder, Peter Collingbourne,
Stephen Checkoway, Úlfar Erlingsson, Luis Lozano,
and Geoff Pike. Enforcing Forward-edge Control-Flow
Integrity in GCC & LLVM. In Proceedings of the 23rd
USENIX Security Symposium, 2014.
[51] Ruoyu Wang, Yan Shoshitaishvili, Antonio Bianchi,
Aravind Machiry, John Grosen, Paul Grosen, Christo-
pher Kruegel, and Giovanni Vigna. Ramblr: Making
Reassembly Great Again. In Proceedings of the 24th
Annual Network and Distributed System Security Sym-
posium, 2017.
[52] Shuai Wang, Pei Wang, and Dinghao Wu. Reassem-
In Proceedings of the 24th
bleable Disassembling.
USENIX Conference on Security Symposium, 2015.
[53] Mingwei Zhang and R. Sekar. Control Flow Integrity
for COTS Binaries. In Proceedings of the 22nd USENIX
Security Symposium, 2013.
Appendix
A Settings for Evaluating PathFinder
Program Training
Set Size
10
6
22
19
10
12
10
12
10
24
bzip2
chown
date
grep
gzip
mkdir
rm
sort
tar
uniq
Testing
Set Size Options
30
17
33
38
30
24
20
28
30
40
-c
-h, -R
–date, -d, –rfc-3339, -utc
-a, -n, -o, -v, -i, -w, -x
-c
-m, -p
-f, -r
-r, -s, -u, -z
-c, -f
-c, -d, -f, -i, -s, -u, -w
Table 7: Settings for evaluating PathFinder on the CHISEL bench-
marks. We use the training set to debloat the binary, and run the
generated code with the testing set. The last column is the options
we pass to the binaries during training and testing.
1750    28th USENIX Security Symposium
USENIX Association