•  Only upper case letters and digits are used.  
• 
Foreground (i.e. challenge text) is dark blue and background 
light gray. 
•  Warping  (both  local  and  global)  is  used  for  character 
distortion.  
Local  warp  produces  “small  ripples,  waves  and  elastic 
deformations along the pixels of the character”, and it foils 
“feature-based algorithms which may use character thickness 
or  serif  features  to  detect  and  recognise  characters”  [6]. 
Characters in the first and second rows of Table 1 are largely 
distorted by local warping.  
Global  warp  generates  character-level,  elastic  deformations 
to foil template matching algorithms for character detection 
and  recognition.  Characters  in  the  third  and  fourth  rows  of 
Table 1 are largely distorted by global warping. 
The following random arcs of different thicknesses are used 
as the main anti-segmentation measure. 
o  Thick  foreground  arcs:  These  arcs  are  of  foreground 
color.  Their  thickness  can  be  the  same  as  the  thick 
portions  of  characters.  They  do  not  directly  intersect 
with  any  characters,  so  they  are  also  called  “non-
intersecting arcs”. 
• 
o  Thin  foreground  arcs:  These  arcs  are  of  foreground 
color.  Although  they  are  typically  not  as  thick  as  the 
above  type  of  arcs,  their  thickness  can  be  the  same  as 
the thin portions of characters.  They intersect with thick 
arcs,  characters  or  both,  and 
thus  also  called 
“intersecting thin arcs”. 
o  Thin  background  arcs:  These  arcs  are  thin  and  of 
background  color.  They  cut  through  characters  and 
remove some character content (pixels).  
robustness.  However, 
Both local and global warping is commonly used for distortion in 
text-based  CAPTCHAs.  Many schemes  use  background  textures 
and  meshes  in  foreground  and  background  colors  as  clutter  to 
increase 
random  arcs  of  different 
thicknesses are used as clutter in the MSN scheme. The rationale 
was  as  follows.  These  arcs  are  themselves  good  candidates  for 
false  characters.  The  mix  of  random  arcs  and  characters  would 
confuse  state  of  the  art  segmentation  methods,  providing  strong 
segmentation resistance [5].  
4.  A SEGMENTATION ATTACK 
We  have  developed  a  low-cost  attack  that  can  effectively  and 
efficiently  segment  challenges  generated  by  the  MSN  scheme. 
Specifically, our attack achieves the following: 
• 
• 
Identify and remove random arcs 
Identify  all  character  locations  in  the  right  order;  in  other 
words, divide each challenge into 8 ordered segments, each 
containing a single character. 
Our  attack  is  built  on  observing  and  analysing  the  100  random 
samples we collected – this is a “sample set”. The effectiveness of 
this  attack  was  tested  not  only  on  the  sample  set,  but  also  on  a 
large  test  set  of  500  random  samples  –  the  design  of  the  attack 
used  no  prior  knowledge  about  any  sample  in  this  set.  This 
methodology  follows  the  common  practice  in  the  fields  such  as 
computer  vision  and  machine  learning2.  (All  the  samples  were 
collected in the summer of 2007.) 
Our attack involves 6 consecutive steps, each of which is detailed 
in the following sections.  
4.1  Pre-processing  
We  first  convert  a  rich-color  challenge  to  a  black-white  image 
using  a  threshold  method:  pixels  with  intensity  higher  than  a 
threshold  value  are  converted  to  white,  and  those  with  a  lower 
intensity  to  black  (see  Fig.  2(a)  and  (b)).  The  threshold  was 
manually  determined  by  analysing  the  sample  set,  and  the  same 
value was used for each image in both the sample and test sets.  
(a) 
(c) 
(b) 
Fig 2. Pre-processing. (a) original image, (b) binarized image, 
(c) after fixing broken characters. 
 (This sample is taken from [8], in which its resistance to 
segmentation is ranked by Microsoft as “hard”, the highest level 
among all examples. We will use this sample to illustrate the 
whole process of our segmentation attack in this paper.)  
The second step of pre-processing is to fix broken characters: thin 
background arcs remove some character content, and sometimes 
they create a crack in characters (e.g., the second character ‘T’ in 
Fig  2(a)  is  broken  due  to  this  reason).  This  step  serves  two 
purposes: i) to keep a character as a single entity and consequently 
enhance our follow-up segmentation methods, and ii) to prevent 
small  portions  of  characters  from  being  removed  as  a  noise  arc 
later on.  
We  observed  that  thin  background  arcs  are  typically  1-2  pixels 
wide  after  binarization,  and  the  following  simple  method  works 
well to identify and fix broken characters caused by such arcs.   
(1)  Find  pixels  that  are  of  background  color  and  have  left  and 
right neighbours with foreground color (see Fig 3(a)). 
(2)  Find  pixels  that  are  of  background  color  and  have  top  and 
bottom neighbours with foreground color (see Fig 3(b)). 
(3)  Convert pixels identified above to foreground color. 
x
x
x
fg
fg
fg
x
x
x
x
x
x
bg
bg
bg
x
x
x
x
x
x
fg
fg
fg
x
x
x
x
x
x
fg
fg
fg
x
x
x
x
x
x
fg
fg
fg
x
x
x
x
x
x
fg
fg
fg
x
x
x
x
x
x
x
x
x
x
x
x
fg
fg
fg
bg
bg
bg
fg
fg
fg
x
x
x
x
x
x
x
x
x
(a)  
   (b) 
x
x
x
x
x
x
x
x
x
fg
fg
fg
fg
fg
fg
fg
fg
fg
x
x
x
x
x
x
x
x
x
Fig 3. Connecting 1-pixel gap (‘x’ represents a pixel that is of 
either foreground or background color). 
This method connects any 1-pixel gap that satisfies the conditions 
illustrated  in  Fig  3.  Its  effect  is  illustrated  in  Fig  2  (c):  some 
missing pixels for character ‘T’ are recovered. A side effect of this 
method is that it might introduce additional foreground pixels that 
2  In  a  related  study  [10]  published  at  CVPR’04,  the  premier 
computer vision conference, the size of sample set was 564 and 
the size of test set 736.  
connect components that are initially disconnected. For example, 
in Fig 2 (c), a thin arc intersecting with ‘R’ is now connected with 
another arc intersecting with ‘E’. But this drawback has proven a 
negligible issue in our study – that would not be the case if we 
chose to connect all two-pixel gaps.  
4.2  Vertical Segmentation 
A vertical segmentation method is applied to segment a challenge 
vertically into several chunks, each of which might contain one or 
more  characters.  The  process  of  vertical  segmentation  starts  by 
mapping the image to a histogram that represents the number of 
foreground  pixels  per  column  in  the  image.  Then,  vertical 
segmentation  lines  separate  the  image  into  chunks  by  cutting 
through  columns  that  have  no  foreground  pixels  at  all.  Fig  4 
shows that such vertical histogram segmentation cuts a challenge 
into two chunks.  
Fig 4. Vertical Segmentation  
Typically, 
this  vertical  method  not  only  achieves  partial 
segmentation,  but  also  contributes  to  our  divide-and-conquer 
strategy, which is key to the success of our attack. 
4.3  Color filling segmentation 
In  this  step,  a  “color  filling  segmentation  (CFS)”  algorithm  is 
applied to each chunk segmented in the previous step. The basic 
idea  of  this  algorithm  is  to  detect  every  connected  component, 
which  we  call  an  object,  in  a  chunk.  An  object  can  be  an  arc, 
character, connected arcs, or connected characters. The algorithm 
works as follows. First, detect a foreground pixel, and then trace 
all  its  foreground  neighbours  until  all  pixels  in  this  connected 
component are traversed – that is, an object is detected. Next, the 
algorithm  locates  a  foreground  pixel  outside  of  the  area  of  the 
detected object(s), and starts another traversal process to identify a 
next object. This process continues until all objects in the chunk 
are located. This method is effectively like using a distinct color 
to  flood  each  connected  component,  so  we  call  it  the  “color 
filling” segmentation. In the end, the number of colours used to 
fill a chunk is the number of objects in the chunk.  
With our CFS method, as shown in Fig 5 (a), we determine that 
there are six objects in the first chunk and five in the second.  
(b) 
(a) 
Fig 5. Color filling segmentation 
Often, a challenge is divided into four or five chunks by vertical 
segmentation.  It  is  worthwhile  to  mention  that  this  color  filling 
step is applied to each chunk, rather than only those wider chunks 
that probably contain more than one object. The reason is simply 
that thinner chunks might also contain more than one object (see 
Fig  5(b)),  and  we  need  to  locate  all  objects  in  each  chunk  and 
track  the  number  of  objects  for  the  follow-up  arc  removal  and 
other steps.   
CFS contributes to further segmentation by detecting objects that 