## DOM 树如何生成在渲染引擎内部，有一个叫**HTML解析器（HTMLParser）**的模块，它的职责就是负责将 HTML 字节流转换为 DOM结构。所以这里我们需要先要搞清楚 HTML 解析器是怎么工作的。在开始介绍 HTML解析器之前，我要先解释一个大家在留言区问到过好多次的问题：**HTML解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML文档边加载边解析的？**在这里我统一解答下，HTML解析器并不是等整个文档加载完成之后再解析的，而是**网络进程加载了多少数据，HTML解析器便解析多少数据**。那详细的流程是怎样的呢？网络进程接收到响应头之后，会根据响应头中的content-type 字段来判断文件的类型，比如 content-type的值是"text/html"，那么浏览器就会判断这是一个 HTML类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，**网络进程和渲染进程之间会建立一个共享数据的管道**，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据"喂"给HTML解析器。你可以把这个管道想象成一个"水管"，网络进程接收到的字节流像水一样倒进这个"水管"，而"水管"的另外一端是渲染进程的HTML 解析器，它会动态接收字节流，并将其解析为 DOM。解答完这个问题之后，接下来我们就可以来详细聊聊 DOM 的具体生成流程了。前面我们说过代码从网络传输过来是字节流的形式，那么后续字节流是如何转换为DOM 的呢？你可以参考下图：![](Images/52df9e4c47b1cc67bdef093322fd11db.png){savepage-src="https://static001.geekbang.org/resource/image/1b/8c/1bfcd419acf6402c20ffc1a5b1909d8c.png"}```{=html}```字节流转换为 DOM]{.reference}```{=html}```从图中你可以看出，字节流转换为 DOM 需要三个阶段。**第一个阶段，通过分词器将字节流转换为 Token。**前面[《14 \| 编译器和解释器：V8 是如何执行一段 JavaScript代码的？》](https://time.geekbang.org/column/article/131887)文章中我们介绍过，V8编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个Token，分为 Tag Token 和文本 Token。上述 HTML 代码通过词法分析生成的Token 如下所示：![](Images/5acb68b5ae7a7719ec63047b594f52ea.png){savepage-src="https://static001.geekbang.org/resource/image/b1/ac/b16d2fbb77e12e376ac0d7edec20ceac.png"}```{=html}```生成的 Token 示意图]{.reference}```{=html}```由图可以看出，Tag Token 又分 StartTag 和 EndTag，比如``就是StartTag ，`就是EndTag`，分别对于图中的蓝色和红色块，文本 Token对应的绿色块。**至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM节点，并将 DOM 节点添加到 DOM 树中。**HTML 解析器维护了一个**Token 栈结构**，该 Token栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token会被按照顺序压到这个栈中。具体的处理规则如下所示：-   如果压入到栈中的是**StartTag Token**，HTML 解析器会为该 Token    创建一个 DOM 节点，然后将该节点加入到 DOM    树中，它的父节点就是栈中相邻的那个元素生成的节点。-   如果分词器解析出来是**文本    Token**，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本    Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM    节点。-   如果分词器解析出来的是**EndTag 标签**，比如是 EndTag div，HTML    解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将    StartTag div 从栈中弹出，表示该 div 元素解析完成。通过分词器产生的新 Token就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。为了更加直观地理解整个过程，下面我们结合一段 HTML代码（如下），来一步步分析 DOM 树的生成过程。        1    test这段代码以字节流的形式传给了 HTML解析器，经过分词器处理，解析出来的第一个 Token 是 StartTaghtml，解析出来的 Token 会被压入到栈中，并同时创建一个 html 的 DOM节点，将其加入到 DOM 树中。这里需要补充说明下，**HTML 解析器开始工作时，会默认创建了一个根为document 的空 DOM 结构**，同时会将一个 StartTag document 的 Token压入栈底。然后经过分词器解析出来的第一个 StartTag html Token会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document上，如下图所示：![](Images/82de5c0a5eaa55f35cd1a8a736f501a7.png){savepage-src="https://static001.geekbang.org/resource/image/7a/f1/7a6cd022bd51a3f274cd994b1398bef1.png"}```{=html}```解析到 StartTag html 时的状态]{.reference}```{=html}```然后按照同样的流程解析出来 StartTag body 和 StartTag div，其 Token 栈和DOM 的状态如下图所示：![](Images/219a03707a6a6eaaa5a21595c9a72c6d.png){savepage-src="https://static001.geekbang.org/resource/image/8c/a5/8c7ba966cebb0050b81c0385ffb4f2a5.png"}```{=html}```解析到 StartTag div 时的状态]{.reference}```{=html}```接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token栈顶元素对应的节点，如下图所示：![](Images/a44b85fd2a89ac9f490afd7e9cf77634.png){savepage-src="https://static001.geekbang.org/resource/image/dc/af/dc0ddd4e3bf3569555f4b1ebec7a8caf.png"}```{=html}```解析出第一个文本 Token 时的状态]{.reference}```{=html}```再接下来，分词器解析出来第一个 EndTag div，这时候 HTML解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出StartTag div，如下图所示：![](Images/63782ed3649498d829df48ee5026068a.png){savepage-src="https://static001.geekbang.org/resource/image/c4/a6/c4a255a8881ef9d21e419aa010ce24a6.png"}```{=html}```元素弹出 Token 栈示意图]{.reference}```{=html}```按照同样的规则，一路解析，最终结果如下图所示：![](Images/61f4bc957d88f9d58391d1a74c46a0a9.png){savepage-src="https://static001.geekbang.org/resource/image/aa/2e/aabf14cde38b058c5203195db82ec22e.png"}```{=html}```最终解析结果]{.reference}```{=html}```通过上面的介绍，相信你已经清楚 DOM是怎么生成的了。不过在实际生产环境中，HTML 源文件中既包含 CSS 和JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个示范Demo 复杂。不过理解了这个简单的 Demo生成过程，我们就可以往下分析更加复杂的场景了。
## JavaScript 是如何影响 DOM 生成的我们再来看看稍微复杂点的 HTML 文件，如下所示：        1        test我在两段 div 中间插入了一段 JavaScript脚本，这段脚本的解析过程就有点不一样了。``标签之前，所有的解析流程还是和之前介绍的一样，但是解析到``标签时，渲染引擎判断这是一段脚本，此时HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript可能要修改当前已经生成的 DOM 结构。通过前面 DOM 生成流程分析，我们已经知道当解析到 script 脚本标签时，其DOM 树结构如下所示：![](Images/990df6072a5317c92067b287ba42f3b9.png){savepage-src="https://static001.geekbang.org/resource/image/41/54/4150e27b332fab9f5a10bfafb524ff54.png"}```{=html}```执行脚本时 DOM 的状态]{.reference}```{=html}```这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang了。脚本执行完成之后，HTML解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。以上过程应该还是比较好理解的，不过除了在页面中直接内嵌 JavaScript脚本之外，我们还通常需要在页面中引入 JavaScript文件，这个解析过程就稍微复杂了些，如下面代码：    //foo.jslet div1 = document.getElementsByTagName('div')[0]div1.innerText = 'time.geekbang'        1        test这段代码的功能还是和前面那段代码是一样的，不过这里我把内嵌 JavaScript脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript代码。这里需要重点关注下载环境，因为**JavaScript 文件的下载过程会阻塞DOM 解析**，而通常下载又是非常耗时的，会受到网络环境、JavaScript文件大小等因素的影响。不过 Chrome浏览器做了很多优化，其中一个主要的优化是**预解析操作**。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析HTML 文件中包含的 JavaScript、CSS等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript文件中没有操作 DOM 相关代码，就可以将该 JavaScript脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：         async 和 defer 虽然都是异步的，不过还有一些差异，使用 async标志的脚本文件一旦加载完成，会立即执行；而使用了 defer标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。现在我们知道了 JavaScript 是如何阻塞 DOM解析的了，那接下来我们再来结合文中代码看看另外一种情况：    //theme.cssdiv {color:blue}                        1        test该示例中，JavaScript 代码出现了 `div1.style.color = ‘red'`的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。所以说 JavaScript脚本是依赖样式表的，这又多了一个阻塞过程。至于如何优化，我们在下篇文章中再来深入探讨。通过上面的分析，我们知道了 JavaScript 会阻塞 DOM生成，而样式文件又会阻塞 JavaScript的执行，所以在实际的工程中需要重点关注 JavaScript文件和样式表文件，使用不当会影响到页面性能的。
## 总结好了，今天就讲到这里，下面我来总结下今天的内容。首先我们介绍了 DOM 是如何生成的，然后又基于 DOM 的生成过程分析了JavaScript 是如何影响到 DOM 生成的。因为 CSS 和 JavaScript 都会影响到DOM 的生成，所以我们又介绍了一些加速生成 DOM的方案，理解了这些，能让你更加深刻地理解如何去优化首次页面渲染。额外说明一下，渲染引擎还有一个安全检查模块叫XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor会对该脚本或者下载任务进行拦截。详细内容我们会在后面的安全模块介绍，这里就不赘述了。
## 思考时间看下面这样一段代码，你认为打开这个 HTML 页面，页面显示的内容是什么？        1        test欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/7e91bd5c116048de87e68468f727fc3c.png){savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}
# 23 \| 渲染流水线：CSS如何影响首次加载时的白屏时间？在[上一篇文章](https://time.geekbang.org/column/article/140140)中我们详细介绍了DOM 的生成过程，并结合具体例子分析了 JavaScript 是如何阻塞 DOM生成的。那本文我们就继续深入聊聊渲染流水线中的 CSS。因为 CSS是页面中非常重要的资源，它决定了页面最终显示出来的效果，并影响着用户对整个网站的第一体验。所以，搞清楚浏览器中的CSS 是怎么工作的很有必要，只有理解了 CSS是如何工作的，你才能更加深刻地理解如何去优化页面。本文我们先站在渲染流水线的视角来介绍 CSS 是如何工作的，然后通过 CSS的工作流程来分析性能瓶颈，最后再来讨论如何减少首次加载时的白屏时间。
## 渲染流水线视角下的 CSS我们先结合下面代码来看看最简单的渲染流程：    //theme.cssdiv{     color : coral;    background-color:black}            geekbang com这两段代码分别由 CSS 文件和 HTML 文件构成，我们来分析下打开这段 HTML文件时的渲染流水线，你可以先参考下面这张渲染流水线示意图：![](Images/55d133f96b22475d13bc481de6715db8.png){savepage-src="https://static001.geekbang.org/resource/image/70/18/70a7ea0212ff35fc2be79f1d574ed518.png"}```{=html}```含有 CSS 的页面渲染流水线]{.reference}```{=html}```下面我们结合上图来分析这个页面文件的渲染流水线。首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建DOM。这里你需要特别注意下，请求 HTML 数据和构建 DOM中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。``{=html}上一篇文章](https://time.geekbang.org/column/article/140140)中我们提到过，当渲染进程接收HTML 文件字节流时，会先开启一个**预解析线程**，如果遇到 JavaScript文件或者 CSS文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的theme.css 文件，并发起 theme.css的下载。这里也有一个空闲时间需要你注意一下，就是在 DOM构建结束之后、theme.css文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。**那渲染流水线为什么需要 CSSOM 呢？**和 HTML 一样，渲染引擎也是无法直接理解 CSS文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是CSSOM。和 DOM 一样，CSSOM 也具有两个作用，**第一个是提供给 JavaScript操作样式表的能力，第二个是为布局树的合成提供基础的样式信息**。这个 CSSOM体现在 DOM中就是`document.styleSheets`。具体结构你可以去查阅相关资料，这里我就不过多介绍了，你知道CSSOM 的两个作用是怎样的就行了。有了 DOM 和 CSSOM，接下来就可以合成布局树了，我们在前面[《05 \|渲染流程（上）：HTML、CSS 和 JavaScript文件，是如何变成页面的？》](https://time.geekbang.org/column/article/118205)这篇文章中讲解过布局树的构造过程，这里咱们再简单回顾下。等DOM 和 CSSOM都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制 DOM树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如display:none 属性的元素、head 标签、script标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM元素选择对应的样式信息，这个过程就是**样式计算**。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是**计算布局**。通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进行后续的绘制操作了。这就是在渲染过程中涉及到 CSS 的一些主要流程。了解了这些之后，我们再来看看稍微复杂一点的场景，还是看下面这段 HTML代码：    //theme.cssdiv{     color : coral;    background-color:black}            geekbang com        geekbang com这段代码是我在开头代码的基础之上做了一点小修改，在 body标签内部加了一个简单的 JavaScript。有了JavaScript，渲染流水线就有点不一样了，可以参考下面这张渲染流水线图：![](Images/40b90e9412cb68d8627341c9fb72b61b.png){savepage-src="https://static001.geekbang.org/resource/image/f8/1c/f85f8778f273710ca559a52027ed731c.png"}```{=html}```含有 JavaScript 和 CSS 的页面渲染流水线]{.reference}```{=html}```那我们就结合这张图来分析含有外部 CSS 文件和 JavaScript代码的页面渲染流水线，[上一篇文章](https://time.geekbang.org/column/article/140140)中我们提到过在解析DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS文件的引用，或者通过 style 标签内置了 CSS内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS在部分情况下也会阻塞 DOM 的生成。我们再来看看更加复杂一点的情况，如果在 body 中被包含的是 JavaScript外部引用文件，Demo 代码如下所示：    //theme.cssdiv{     color : coral;    background-color:black}    //foo.jsconsole.log('time.geekbang.org')            geekbang com        geekbang com从上面代码可以看出来，HTML 文件中包含了 CSS 的外部引用和 JavaScript外部文件，那它们的渲染流水线是怎样的呢？可参考下图：![](Images/fa80ac916a65039d6efae6eb20e4ea90.png){savepage-src="https://static001.geekbang.org/resource/image/76/1f/7641c75a80133e747aa2faae8f4c8d1f.png"}```{=html}```含有 JavaScript 文件和 CSS 文件页面的渲染流水线]{.reference}```{=html}```从图中可以看出来，在接收到 HTML 数据之后的预解析过程中，HTML预解析器识别出来了有 CSS 文件和 JavaScript文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。
## 影响页面展示的因素以及优化策略前面我们为什么要花这么多文字来分析渲染流水线呢？主要原因就是**渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验**，所以我们分析渲染流水线的目的就是为了找出一些影响到首屏展示的因素，然后再基于这些因素做一些针对性的调整。那么接下来我们就来看看从发起 URL请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。-   第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。关于提交数据你可以参考前面[《04    \| 导航流程：从输入 URL    到页面展示，这中间发生了什么？》](https://time.geekbang.org/column/article/117637)这篇文章。-   第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为**解析白屏**，并等待    CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和    DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。-   第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。影响第一个阶段的因素主要是网络或者是服务器处理这块儿，前面文章中我们已经讲过了，这里我们就不再继续分析了。至于第三个阶段，我们会在后续文章中分析，所以这里也不做介绍了。现在我们重点关注第二个阶段，这个阶段的主要问题是白屏时间，如果白屏时间过久，就会影响到用户体验。为了缩短白屏时间，我们来挨个分析这个阶段的主要任务，包括了解析HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行JavaScript、生成布局树、绘制页面一系列操作。通常情况下的瓶颈主要体现在**下载 CSS 文件、下载 JavaScript 文件和执行JavaScript**。所以要想缩短白屏时长，可以有以下策略：-   通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到    HTML 文件之后就可以直接开始渲染流程了。-   但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过    webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。-   还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者    defer。-   对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的    CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。通过以上策略就能缩短白屏展示的时长了，不过在实际项目中，总是存在各种各样的情况，这些策略并不能随心所欲地去引用，所以还需要结合实际情况来调整最佳方案。