### 优化后的文本

**引理证明**

假设 \((\{P_2\}, C_\emptyset), n_0\) 满足 \((\Sigma, \sigma)\)。根据定理6，我们得到 \((\{P_2\}, \emptyset) \xrightarrow{c} (P_2, C_2) \in \Gamma(n)\)。由定义12，存在 \(\Phi(C_2)\sigma \downarrow \sim \Phi(C_2)\sigma \downarrow\)。因此，我们有 \(tr_{c\Phi \downarrow} = tr_{\Sigma \Phi \downarrow}\) 和 \(\Phi \sim \Phi(C_2)\sigma \downarrow\)。由此，我们可以得出 \((\{P_2\}, \emptyset) \xrightarrow{c} (P_2, C_2)\)。

**图6：分区树示例**

此引理证明了给定一个分区树时迹等价的可判定性。分区树的构造将在下一段中概述，随后我们将讨论复杂性问题。

**备注5.1**：类似的结果也可以用于标记的双模拟等价，但由于篇幅限制在此省略。在本质上，我们通过考虑T的子树而不是简单的节点来处理更复杂的等价概念。该过程在附录中概述，并在技术报告[2]中详细描述。

**生成分区树**

现在，我们大致描述计算 \(T \in PTree(P_1, P_2)\) 的主要步骤：

1. **扩展约束系统**：首先，扩展约束系统以包含附加组件，例如二阶项的逻辑约束或表示攻击者知识的推理事实。符号语义被提升到扩展约束系统，目的是在整个过程中携带额外信息以帮助生成谓词 \(\pi\)。通常，初始进程 \(P_i = \{P_i\}\)，\(i \in \{1, 2\}\)，被转换为 \((P_i, C_\emptyset, Ce_\emptyset)\)，其中 \(Ce_\emptyset\) 是空的扩展约束系统。

2. **简化规则**：定义简化规则，将扩展约束系统转换为易于判断满足性的形式。通常，根节点处的符号进程集合 \(S_{root}\) 通过对 \(\{(P_1, C_\emptyset, Ce_\emptyset), (P_2, C_\emptyset, Ce_\emptyset)\}\) 进行 \(\varepsilon\)-跃迁饱和并使用简化规则消除不可满足的约束系统获得。

3. **定义子进程集**：从根节点的进程中定义两个子进程集：\(S_{in}\)（经过输入跃迁后 \(\varepsilon\)-可达的进程）和 \(S_{out}\)（经过输出跃迁后 \(\varepsilon\)-可达的进程）。为了满足同一配置中的进程静态等价的要求，可能需要对 \(S_{in}\) 和 \(S_{out}\) 进行划分。这通过区分规则实现，最终形成：
   \[
   S_{out} = S^1_{out} \cup \ldots \cup S^q_{out}
   \]
   \[
   S_{in} = S^1_{in} \cup \ldots \cup S^p_{in}
   \]

4. **递归构建**：对于所有当前叶子节点，如果可见动作仍然可达，则生成 \(S_{in}\) 和 \(S_{out}\) 并使用区分规则进行划分，从而生成新的叶子节点。由于跃迁关系 \(a \xrightarrow{s}\) 强终止，这一过程自然会终止。

我们在技术报告[2]中证明了这一过程确实生成了一个分区树 \(T \in PTree(P_1, P_2)\)。

**最终结果**

使用上述过程生成分区树并通过引理7，我们得到了迹等价的判定程序。这一程序实际上已经在我们的自动化工具DEEPSEC中实现。如前所述，我们也基于分区树有一个标记双模拟等价的判定程序，详见附录。然而，最终我们使用不同的论据来获得预期的理论复杂度上限（coNEXP）。通过仔细分析过程中携带的扩展约束系统的大小并限制区分规则的应用次数，我们可以证明生成的分区树具有指数级大小的解。因此：

**定理8**：存在 \(p \in \mathbb{N}\)，对于所有收敛的子项销毁重写系统 \(R\) 和封闭的普通进程 \(P_1\) 和 \(P_2\)，存在一个分区树 \(T \in PTree(P_1, P_2)\)，使得对于所有 \(n\) 节点，\(\forall \Sigma \in mgs(n), |\Sigma|_{dag} < 2(|P_1, P_2, R|_{dag} + |F|)^p\)。

结合此定理和引理7，可以简单地证明当 \(P_1 \not\approx_t P_2\) 时，存在一个在 \(P_1\) 或 \(P_2\) 中指数级大小的具体迹，而在另一个进程中不存在匹配的迹。这很容易导致迹等价的 coNEXP 决策程序，利用静态等价是 NP 的事实——这一结果很容易从现有程序中获得，例如 [3], [27], [29]。正如我们所解释的，该程序可以适应于标记双模拟等价。详情请参阅附录或技术报告[2]。

**定理9**：Equiv ≈t 和 Equiv ≈(cid:2) 对于子项销毁重写系统是 coNEXP。

**实现**

基于前一节的内容，我们用OCaml实现了一个原型工具DEEPSEC（Deciding Equivalence Properties in SECurity protocols），公开可用 [1]。该工具的规范语言扩展了第2.2节中介绍的语法：特别地，我们定义了一个非确定性选择操作符 \(P + Q\)、一个变量赋值的let操作符 \(let x = u in P else Q\) 以及有界复制操作符 \(!nP\) 定义了并行运行的 \(n\) 个副本 \(P\)。这些附加原语只是为了建模方便——并且与初始演算相比，本地集成允许特定优化。DEEPSEC 输入文件的语法和结构类似于广泛使用的 ProVerif [17] 工具。我们希望这将使新用户更容易发现和使用我们的工具。

**部分顺序约简**

该工具还实现了部分顺序约简（POR），这是Baelde等人开发的一种协议分析优化技术 [12]。基本思想是丢弃冗余的状态空间。当进程是动作确定的时，这种优化是合理的，如 [12] 中定义的那样。为每个并行进程分配不同的通道名称是一种简单且语法上确保该属性的方法，尽管这并不总是可能的——特别是在查看匿名性或不可链接性属性时。实际上，DEEPSEC 自动检测动作确定的进程并激活 POR，这大大减少了需要考虑的符号执行数量。

**分布式计算**

根据第5节的概述，DEEPSEC的主要任务是生成一个分区树。这个任务可以分布执行：计算给定节点的任务可以独立于其兄弟节点进行。但是，需要一些工程设计来避免由于任务调度引起的大量通信开销。实际上，分区树并不是平衡树，无法知道哪些分支会比其他分支更大。因此，在实践中，我们不直接以最直接的方式计算和返回每个节点的所有子节点，而是分两步进行：

1. 我们从广度优先生成分区树开始。待处理节点的数量将逐渐增加，直到超过阈值参数 \(n\)。
2. 每个可用核心专注于这些节点之一，计算以该节点为根的整个子树（深度优先方式），然后被分配一个新的节点。如果在某些时候核心变得空闲（因为所有在第一步生成的节点要么已完成，要么已被分配给活跃的核心），我们会在未完成的节点上重新开始这个两步过程。

虽然AKISS工具也支持并行化，但DEEPSEC更进一步，能够通过计算机集群分发计算。

**基准测试**

我们进行了广泛的基准测试，比较了我们的工具与其他验证有限会话数等价性质的工具：AKISS [19]、APTE [20]、SAT-EQUIV [30] 和 SPEC [47]。实验在Intel Xeon 3.10GHz核心上进行，内存为50GB。AKISS和DEEPSEC使用35个核心，而其他工具使用单个核心。结果总结在图7中。

我们分析了几种经典认证协议的强保密性，这是一种基于等价性的保密性版本。这些基准测试主要用于测量会话数增加时的可扩展性（图7指示了并行角色的数量，具体场景可能需要更多或更少的角色）。DEEPSEC工具明显优于AKISS、APTE和SPEC。当会话数显著增加时，SAT-EQUIV工具变得更加高效。然而，Otway-Rees协议不能被SAT-EQUIV分析，因为它不符合他们的类型兼容条件，Needham-Schroeder-Lowe协议也不在其范围内，因为SAT-EQUIV不支持非对称加密。DEEPSEC甚至能够验证比图7中报告的更多角色。设置12小时超时时间，例如，Denning-Sacco和Yahalom-Lowe协议可以在11小时09分钟内验证52个角色，在10小时04分钟内验证25个角色。

为了说明工具的广泛适用性，我们分析了其他协议的不可链接性和匿名性属性：Abadi和Fournet的匿名认证协议 [5]、3G电话网络中部署的AKA协议 [10]、欧洲护照中实施的被动认证和基本访问控制（BAC）协议 [37]，以及Prêt-à-Voter（PaV）[43]和几种基于mixnet的Helios [7]投票协议变体。我们对投票协议示例稍作评论。依赖于Arapinis等人的简化结果 [9]，我们知道只需考虑三个选民，两个诚实的和一个不诚实的，即可推断出任意数量选民的投票隐私。此外，当允许重新投票时（例如Helios，但不是PaV），我们只需要考虑接受七个选票的服务器，这些选票可能来自三个选民中的任何一个。对于Helios协议，我们考虑了几个版本。不允许重新投票的原始Helios版本容易受到选票复制攻击 [32]——攻击者只需复制一个诚实选民的选票以影响结果。提出了两种对策来阻止这种攻击：一种应用选票筛选程序（W），另一种基于零知识证明（ZKP），将选民身份与选票关联起来。当不允许重新投票时，这两个版本确实是安全的。当允许重新投票时，我们考虑七张选票被接受的情况 [9]，在两种不同情况下。当只有不诚实的选民重新投票（dR）时，我们可以证明筛选机制的安全性。然而，当一个诚实的选民重新投票两次（相同的选票）时，Rønne [41] 指出筛选版本中可能出现选票复制的变体。攻击者拦截或延迟第一个诚实的选票，并投出这张选票。