分析复现一下几个draytek的漏洞
1.CVE-2020-8515  
漏洞描述如下：
    DrayTek Vigor2960 1.3.1_Beta, Vigor3900 1.4.4_Beta, and Vigor300B 1.3.3_Beta, 1.4.2.1_Beta, and 1.4.4_Beta devices allow remote code execution as root (without authentication) via shell metacharacters to the cgi-bin/mainfunction.cgi URI. This issue has been fixed in Vigor3900/2960/300B v1.5.1.
我这里选取Vigor2960 1.5.0版本的固件和1.5.1版本的固件作为对比。  
首先提取固件：  
固件是ubi类型的，需要使用[ubi_reader](https://github.com/jrspruitt/ubi_reader.git
"ubi_reader")这个工具进行提取，提取出来之后就是一个完整的文件系统。  
lighttpd是一个轻量级的web服务器，一般会有cgi文件作为支持，在./etc/lighttpd/lighttpd.conf中可以看到服务器的各个配置项，在分析固件之前可以先查看一下服务器的配置文件，这样有助于我们确定分析目标。  
根据漏洞通告，问题出现在cgi-bin目录下的mainfunction.cgi程序。  
那么我们就来分析这个文件，IDA打开，看到main函数：  
在33行中获取到PATH_INFO这个环境变量，这个环境变量表示紧接在CGI程序名之后的其他路径信息，它常常作为CGI程序的参数出现。比如：,  
那么PATH_INFO=/webrestore.  
一直看到最下面：  
除了通过PATH_INFO来确定要访问的路径，main函数还通过action参数来确定要执行的动作，跟进sub_B44C函数中  
在0x4240c地址处有一张函数表：  
遍历函数表名，并且和用户传入的action的值进行比较来确定要执行的函数。  
main函数的逻辑大概理清楚了，接下来开始分析漏洞。  
漏洞点在登录时的keyPath参数中，通过搜索字符串定位到函数，并且这个函数位于上面的函数表中，函数名为login：  
这也是为什么这个漏洞能够导致未认证的命令注入，因为是发生在登录过程中的命令注入。  
首先是获取keypath的值，然后进行对这个值进行check，check函数如下：  
过滤了常用的`;|>$(  
空格等命令拼接字符，看起来过滤的很严格，但是问题不大，依然可以绕过  
在unix上可以通过如下字符来执行多条命令：
    %0a
    %0d 
    ;
    &
    |
    $(shell_command)
    `shell_command`
    {shell_command,}
;&|被过滤了，可以考虑使用%0a来绕过，而且$(的检测也不对，这里是先检测当前字符是否为$,并且下一个字符得为(才会发生替换，目的是为了检测$(shellcommand)这种类型的命令执行，但并没有过滤单独的$,这样子的话空格就可以使用${IFS}来绕过。  
check之后，通过snprintf函数将路径拼接在一起，类似于这样：
    /tmp/rsa/private_key_keypath
后面接着再使用一个snprintf函数来将命令拼接：
    openssl rsautl -inkey '/tmp/rsa/private_key_keypath' -decrypt -in /tmp/rsa/binary_login
之后将这条命令作为参数传递给run_command函数(这里我自己重名了函数)，run_command如下：  
使用popen函数执行这条命令，由此便造成了未授权的命令执行。  
分析完原理，来实际操作一下，以vigor2960为例：  
随便输入用户名和密码，然后抓包：  
可以看到以POST方式访问/cgi-bin/mainfunction.cgi，传入的action=login，要执行的动作为login，按照上面分析的，我们修改keypatch的值为：  
执行效果如下：  
成功地执行了ls。  
再换一个需要空格的命令：  
执行效果如下：  
注意，keypatch的值前面加上'的作用是为了闭合命令中的单引号，因为在单引号包围中的命令是不会执行的。  
实际上如果固件版本小于1.4.2.1，在rtick参数中也存在命令注入，这里使用1.4.1版本的固件来说明。  
还是在login函数中：  
这里会取rtick作为时间戳来生成验证码。  
查找rtick或者formcaptcha这两个字符串的交叉引用可以定位到验证码的生成函数：  
可以看到这个函数里面直接将rtick的值作为验证码名，然后调用system函数执行，因此只需要修改rtick就可以达成未认证命令执行。  
实际操作这一块就跳过了，感兴趣的可以自己尝试。  
下面来和1.5.1的版本进行比较，直接定位到login函数：  
除了有过滤函数还有一个判断，判断字符是否为十六进制字符，而且check函数也完善了：  
再看到rtick那边：  
将rtick的值限制在数字之内防止命令注入。
2.CVE-2020-15415  
漏洞描述如下：
    On DrayTek Vigor3900, Vigor2960, and Vigor300B devices before 1.5.1, cgi-bin/mainfunction.cgi/cvmcfgupload allows remote command execution via shell metacharacters in a filename when the text/x-python-script content type is used, a different issue than CVE-2020-14472.
在1.5.1版本下，当访问cgi-bin/mainfunction.cgi/cvmcfgupload这个路径时，如果content
type为text/x-python-script，则在filename中存在命令注入。  
知道了漏洞所在，直接定位过去：  
看路径名猜测这个是一个用来上传文件的页面。  
getenv("QUERY_STRING")，如果服务器与CGI程序信息的传递方式是GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号'?'分隔。  
首先获取QUERY_STRING的值，然后判断是否存在session=字符串，如果不存在的话就进入到sub_13450函数中，跟进去看看：  
看到了一个system的执行点，但该怎么利用,漏洞通告中的filename并未在这里出现，出现filename的函数又和/cvmcfgupload路径不对应。  
结合已有[POC](https://github.com/CLP-team/Vigor-Commond-Injection "POC")继续分析：
    POST /cgi-bin/mainfunction.cgi/cvmcfgupload?1=2 HTTP/1.1
    Host: xxx.xxx.xxx.xxx:xxxx
    Content-Length: 174
    Cache-Control: max-age=0
    Upgrade-Insecure-Requests: 1
    Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
    Accept-Encoding: gzip, deflate
    Accept-Language: zh,en;q=0.9,zh-CN;q=0.8,la;q=0.7
    Connection: close
    ------WebKitFormBoundary
    Content-Disposition: form-data; name="abc"; filename="t';id;echo '1_"
    Content-Type: text/x-python-script
    ------WebKitFormBoundary--
/cgi-bin/mainfunction.cgi/cvmcfgupload?1=2  
使得getenv("QUERY_STRING")能够获取到值，顺利进入到sub_13450函数；接着看到Content-Type=multipart/form-data; boundary=----WebKitFormBoundary，以及body部分的Content-Disposition等属性，这几个需要说明一下。  
这篇[文章](https://zhuanlan.zhihu.com/p/122912935 "文章")中介绍了multipart/form-data，在往服务器发送表单数据之前需要对数据进行编码，multipart/form-data的编码规则为不做编码，发送二进制数据。对于multipart/form-data的编码规则有以下规范特征：1.必须以POST方式发送数据；2.Content-Type格式为multipart/form-data;
boundary=${boundary}。其中的boundary是长度为16的随机base64字符，浏览器会自动创建，类似下面这样:
    Content-Type: multipart/form-data; boundary=----WebKitFormBoundary222BPd3etU0TLTOv
不过在这个漏洞利用中，WebKitFormBoundary是我们手动添加的，自然也没必要添加后面的boundary。  
然后，这个boundary=----WebKitFormBoundary222BPd3etU0TLTOv  
作为数据的起始符、分隔符，终结标记符相比于起始符和分隔符多了--。  
数据内容主要包括：Content-Disposition、Content-Type、数据内容等；其中数据内容前面有\n\r标记的空行；Content-Disposition是必选项，其它都是可选项；Content-Disposition 包含了 type 和 一个名字为 name 的
parameter，type 是 form-data，name 参数的值则为表单控件（username）的名字，如果是文件，那么还有一个 filename
参数，值就是文件名。  