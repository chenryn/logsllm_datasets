API list (only for this experiment).
DoubleX detects all vulnerabilities for 62 / 73 extensions, which
corresponds to the accurate detection of 151 / 163 flaws (92.64%). For
the twelve missing flaws, four are related to dynamic arrays, such
as invocations of a function through handlers[event.message], which
we cannot statically resolve. Four other cases are data flow issues
related to circular references in objects. For the last four cases, the
handler function invokes a function that is not defined at this point
in the parsing process. While DoubleX correctly hoists function
declarations, this occurs when a function is defined as a variable
(i.e., foo = function() {...}), which should be defined before use, accord-
ing to the ECMAScript specification [25, 56]. In addition, for six
extensions, which have not been updated since Somé’s analysis, we
report (and confirm, after manual review) three XMLHttpRequest and
four storage vulnerabilities, which had not been found previously.
This way, besides accurately detecting vulnerabilities in the wild
(89% verified reported data flows, cf. Section 5.2.1), DoubleX also
correctly flags the majority of known flaws (92.64%).
5.5 Run-Time Performance
Finally, we evaluated DoubleX run-time performance on a server
with four Intel(R) Xeon(R) Platinum 8160 CPUs (each with 48 logical
cores) and a total of 1.5 TB RAM. Since DoubleX runs the analysis
of each extension on a single core, the run-time reported is for a
single CPU only. The most time-consuming step of our approach
is related to the data flow and pointer analyses. These operations
naturally highly depend on the AST size, as we traverse it to store
the variables newly declared or look for variables previously defined,
and we re-traverse functions when they are called. On average,
DoubleX needs 11 seconds to analyze an extension with content
scripts and background page; and 96.5 seconds for content scripts
and WARs (as the WARs are larger, cf. Section 5.1.2; Figure 7 in the
Appendix presents DoubleX run-time performance depending on
the extension size). Still, the corresponding median times are 2.5
and 31.8 seconds, while the maximum amount of time are 1,498 and
1,116 seconds. In practice, our average results are heavily biased
by a few extensions, whose analysis lasted a long time. Figure 5
presents the Cumulative Distribution Function (CDF) [49] for our
5Storing and extracting data from an extension storage is not part of our attacker
model, as we cannot assess to what extent this may cause damage
Session 6B: Web VulnerabilitiesCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1799extensions that have privileges such as , which would
allow an attacker who can exploit them to make arbitrary and
authenticated requests and leak their content. As Google readily
points out, high-privilege extensions require a more thorough anal-
ysis. Therefore, the information about vulnerabilities can also be of
interest to the auditor, to limit the number of vulnerable extensions
entering the store. This is all the more important as we noticed that
very few developers acknowledged and fixed the vulnerabilities we
reported (cf. Section 5.2.4).
6.2 Limitations
Regarding our extension set, we considered only the scripts which
are part of the extension package, and we did not take import state-
ments into account. Also, we chose not to analyze modules, as we
are looking for vulnerabilities directly in the extension components.
As for our approach, DoubleX rests on a static analysis to build
the EDG, including control, data, and message flows, and pointer
analysis. While static analysis provides complete coverage of the
available code, it is subject to the traditional flaws induced by
JavaScript dynamic character [3, 30, 36, 37, 79]. For example, we
may miss flaws due to dynamic code generation. While we can
handle dynamically invoked sink functions (e.g., window[’e’ + ’v’
+ ” + ’al’](value), cf. example in Section 4.4.2), as long as we can
statically resolve and/or compute the arguments, we may miss
dynamic function invocations (e.g., handlers[partOfMessage]), as
discussed in Section 5.4. In addition, we chose to build the PDG of
extension components by traversing the CFG one time (vs. iterating
until we reach a fixed point; cf. Section 4.2.3), which may lead to
under-approximations. We discussed the concept of soundiness
in Section 5.2.1, though. Besides, as argued in Section 5.3, in an
Open World model like ours, it would be extremely challenging to
determine the number of vulnerable extensions DoubleX misses,
as we would have to manually review hundreds of extensions to
find a few vulnerable ones. As a best-effort strategy, we evaluated
DoubleX on the vulnerable extension set released with EmPoWeb,
where we accurately detect 92.64% of the flaws (naturally, if both
DoubleX and EmPoWeb missed a vulnerable extension, there is no
way for us to tell that). In addition, our tool is very precise, with
over 89% of our reports which have a verified dangerous data flow.
6.3 Analyzing Firefox Extensions
Besides Chromium-based extensions, DoubleX can also analyze
Firefox. To collect these extensions, we visited the Firefox gallery,
which contains links to all extensions, ordered per category [51].
We used Puppeteer [68] to automatically download and unpack
the extensions. We crawled the store on April 6, 2021, and could
successfully collect 19,577 extensions. As for Chrome, we parsed the
manifest.json of each extension to extract their components and
ran DoubleX on them. Table 4 summarizes our findings. Out of 24
reports, we detected 8 that are exploitable under our threat model.
In addition, we verified the presence of 22 dangerous data flows and
2 additional data flows without a backchannel. For example, and
as previously, we consider that merely controlling a URL prefix for
an XMLHttpRequest is not exploitable. As mentioned in Section 4.3.1,
we took into account the specific message-passing APIs for Firefox
and handled responses with a Promise. For the exfiltration APIs,
Figure 5: Run-time performance of DoubleX
run-time performance. In particular, we could analyze 93% of our
extension set for content scripts and background page in less than
20 seconds and 45% for the content scripts and WARs. This way,
DoubleX can effectively analyze extensions from the wild, with an
analysis time of mostly a few seconds per extension.
5.6 Summary
To sum up, out of the 154,484 Chrome extensions DoubleX ana-
lyzed, it reported only 278 (0.18%) as having a data flow between
an attacker and the sensitive APIs we considered. These suspicious
flows expand to 309 reports, 275 (89%) of which have a verified dan-
gerous data flow. Therefore, DoubleX is highly accurate to detect
suspicious data flows. In addition, we verified that we could exploit
209 reports, according to our threat model. These 209 flaws corre-
spond to 184 vulnerable extensions, with a total of over 2.4 million
users. Regarding vulnerable extensions we may have missed, we
evaluated DoubleX on the vulnerable extension set provided by
EmPoWeb, where we accurately flag almost 93% of the flaws.
In addition, we observed that 87% of the vulnerable extensions
were already in the store and vulnerable one year ago (despite
disclosure and half of the extensions being updated in between).
As extension developers do not necessarily have any incentive to
patch vulnerable extensions, we believe that DoubleX could be inte-
grated into the vetting process already conducted by Google (cf. Sec-
tion 6.1). This would also delegate the responsibility of having vul-
nerable extensions in the store to Google. In addition to this, we
envision that DoubleX could provide a feedback channel to devel-
opers, e.g., regarding the execution of attacker-controllable input or
sensitive user data exfiltration, to limit having such vulnerabilities
in the first place.
6 Discussion
In this section, we envision the option to integrate DoubleX into
Chrome’s vetting process. Then, we discuss limitations of our ap-
proach before considering its applicability to other ecosystems like
Firefox extensions.
6.1 Extension Vetting: Workflow Integration
Given the precision and recall of DoubleX, we believe that it can be
integrated into the vetting process already conducted by Google for
newly uploaded extensions [16]. Currently, this system aims at iden-
tifying extensions that request powerful permissions or are clearly
malicious, e.g., by spreading malicious software. Still, we envision
that a feedback channel to alert developers regarding potential
vulnerabilities would be relevant. It is particularly important for
Session 6B: Web VulnerabilitiesCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1800Sensitive API
ajax
downloads.download
eval
fetch
setTimeout
tabs.executeScript
XMLHttpRequest.open
Sum
#Reports
1
3
2
4
5
2
7
24
#DF
1
3
2
3
5
2
6
22
#1-way DF
0
-
-
1
-
-
1
2
#Exploitable
0
3
0
1
0
1
3
8
Table 4: DoubleX findings on Firefox extensions
though, we detect suspicious data flows based on callbacks and
leave the Promise implementation for future work.
7 Related Work
In this section, we discuss prior work related to vulnerable extension
analysis and data flow-based vulnerability detection.
Browser Extension Security — In 2010, Bandhakavi et al. intro-
duced Vex, which leverages static information flow tracking on
2,452 (now deprecated) XPCOM [52] Firefox extensions [5]. With
this XPCOM interface, though, they did not have the message-
passing API problematic. In 2012, Carlini et al. combined a network
traffic analysis of 100 Chrome extensions with a manual review to
evaluate the effectiveness of Chrome security mechanisms [8]. In
2015, Calzavara et al. proposed a purely formal security analysis of
browser extensions, looking for the privileges an attacker may esca-
late if a specific component was compromised [7]. In 2016, Salih et
al. highlighted a security issue of the XPCOM namespace [6]. With
CrossFire, they did a static data flow analysis to identify flows
between globally accessible variables from extensions and security-
sensitive XPCOM calls. In 2017, Starov et al. performed a dynamic
analysis with BrowsingFog to detect privacy leakage from 10,000
Chrome extensions, showcasing that most leakage are not inten-
tional [76]. Finally, in 2019, Somé considered message-passing APIs
to exploit browser extension capabilities [72]. Still, his analysis,
which merely relies on a lightweight call graph analysis and a fixed
list of possible ways to invoke specific APIs, yields an extremely
large number of false positives (of the 3.3k Chrome extensions he
flagged, only 171 were vulnerable). In contrast, DoubleX defines
an EDG to model the control, data, and message flows, including
pointer analysis, inside an extension (as well as external messages).
This graph then enables us to precisely reason about suspicious
data flows, with regard to, e.g., aliasing, to detect non-obvious
vulnerabilities.
While our approach targets vulnerable extensions, prior work
also focussed on detecting malicious extensions, e.g., by monitoring
their behavior [39, 81], detecting anomalous ratings [66], or track-
ing developer reputation [35]. Such malicious behaviors include
stealing users’ credentials, tracking users [82], spying on them [1],
and voluntarily exfiltrating sensitive user information [9].
Data Flow Analysis for Vulnerability Detection — DoubleX
can also be compared to systems using control and data flow track-
ing for vulnerability detection. For PHP, Jovanovic et al. imple-
mented Pixy to perform a static data flow analysis to discover
cross-site scripting vulnerabilities [38]. Yamaguchi et al. leveraged
the AST enhanced with control and data flow information to model
templates for known vulnerabilities with graph traversals and find
similar flaws in other projects [83]. Backes et al. also used this
data structure to identify vulnerabilities in PHP application [4].
Similarly, with VulSniper, Duan et al. leveraged control flow infor-
mation to encode a program as a feature tensor and feed it to a
neural network to detect vulnerabilities [24]. Contrary to these ap-
proaches, DoubleX does not need any information about previous
vulnerabilities to operate.
8 Conclusion
In this paper, we designed and built DoubleX to detect security
and privacy threats in benign-but-buggy extensions. In particular,
we studied to what extent a web page or another extension without
any specific privilege could exploit the capabilities of a vulnerable
extension. To this end, DoubleX statically abstracts an extension
source code to its EDG and performs a data flow analysis to de-
tect suspicious flows between external actors (i.e., a web page or
another extension, under the control of an attacker) and security-
or privacy-critical APIs. The core components of DoubleX are
the following. First, we abstract the source code of each extension
component to its AST, which we enhance with control and data
flows, and pointer analysis information. Second, we model mes-
sages exchanged between extension components with a message
flow, and we collect messages exchanged outside of an extension
(i.e., with an attacker). We refer to the resulting graph structure as
the Extension Dependence Graph (EDG). Finally, we leverage this
graph to perform an in-depth data flow analysis between sensitive
APIs in browser extensions and external messages.
[3] Esben Andreasen and Anders Møller. 2014. Determinacy in Static Analysis for
jQuery. In Conference on Object Oriented Programming Systems, Languages, and
Applications (OOPSLA).
[4] Michael Backes, Konrad Rieck, Malte Skoruppa, Ben Stock, and Fabian Yamaguchi.
2017. Efficient and Flexible Discovery of PHP Application Vulnerabilities. In Euro
S&P.
We analyzed 154,484 Chrome extensions and flagged 278 as
having a suspicious data flow. These suspicious flows expand to
309 reports, 89% of which have a verified dangerous data flow. This
highlights the precision of our analysis. In addition, we detected 184
extensions that are exploitable under our threat model, leading to,
e.g., arbitrary code execution in any website or sensitive user data
exfiltration. Furthermore, we evaluated the recall of DoubleX on a
ground-truth extension set, where it accurately flags almost 93%
of known flaws. Finally, to raise awareness and enable developers
and extension operators to automatically detect such threats before
large-scale deployment, we make DoubleX publicly available [27].
Acknowledgments
We thank the anonymous reviewers for their valuable feedback. In
particular, we thank our shepherd Yousra Aafer for her guidance
and support in preparing the final version of this paper.
References
[1] Anupama Aggarwal, Bimal Viswanath, Liang Zhang, Saravana Kumar, Ayush
Shah, and Ponnurangam Kumaraguru. 2018. I Spy with My Little Eye: Analysis
and Detection of Spying Browser Extensions. In Euro S&P.
[2] Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. 2006. Compilers:
Principles, Techniques, and Tools (Second Edition). Addison Wesley. ISBN: 978-
0321486813.
Session 6B: Web VulnerabilitiesCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1801[5] Sruthi Bandhakavi, Samuel T. Kingand P. Madhusudan, and Marianne Winslett.
2010. VEX: Vetting Browser Extensions for Security Vulnerabilities. In USENIX
Security Symposium.
[6] Ahmet Salih Buyukkayhan, Kaan Onarlioglu, William Robertson, and Engin
Kirda. 2016. CrossFire: An Analysis of Firefox Extension-Reuse Vulnerabilities.
In NDSS.
[7] Stefano Calzavara, Michele Bugliesi, Silvia Crafa, and Enrico Steffinlongo. 2015.
Fine-Grained Detection of Privilege Escalation Attacks on Browser Extensions.
In Programming Languages and Systems.
[8] Nicholas Carlini, Adrienne Porter Felt, and David Wagner. 2012. An Evaluation
of the Google Chrome Extension Security Architecture. In USENIX Security
Symposium.
[9] Quan Chen and Alexandros Kapravelos. 2018. Mystique: Uncovering Information
Leakage from Browser Extensions. In CCS.
[10] chrome. [n. d.]. Chrome Web Store Sitemap. https://chrome.google.com/webstore/
[11] chrome. [n. d.]. chrome.extension. https://developer.chrome.com/extensions/
sitemap. Accessed on 2021-04-25.
extension. Accessed on 2021-04-21.
[12] chrome. [n. d.]. chrome.runtime. https://developer.chrome.com/docs/extensions/
reference/runtime. Accessed on 2021-04-29.
[13] chrome. [n. d.]. chrome.tabs. https://developer.chrome.com/extensions/tabs.
Accessed on 2021-04-21.
[14] chrome. [n. d.]. Declare Permissions. https://developer.chrome.com/docs/
extensions/mv3/declare_permissions. Accessed on 2021-04-21.
[15] chrome. [n. d.]. externally_connectable. https://developer.chrome.com/docs/
extensions/mv3/manifest/externally_connectable/. Accessed on 2021-04-21.
[16] chrome. [n. d.]. How long will it take to review my item? https://developer.
chrome.com/docs/webstore/faq/#faq-listing-108. Accessed on 2021-04-26.
[17] chrome. [n. d.]. Manifest File Format. https://developer.chrome.com/docs/
extensions/mv3/manifest. Accessed on 2021-04-25.
[18] chrome. [n. d.]. Message Passing. https://developer.chrome.com/docs/extensions/
mv3/messaging. Accessed on 2021-04-21.
[19] chrome. [n. d.]. Migrating to Manifest V3. https://developer.chrome.com/docs/
extensions/mv3/intro/mv3-migration. Accessed on 2021-04-21.
[20] chrome. [n. d.]. Overview of Manifest V3. https://developer.chrome.com/docs/