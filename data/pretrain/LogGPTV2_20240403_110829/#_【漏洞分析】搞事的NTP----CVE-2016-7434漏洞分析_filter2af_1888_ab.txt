    0xbfade1fa: "laddr"
    0xbfade200: "0x%hx"
这里data部分就是之前初始化in_parms用于存放后续做比较的所有块的名称，而val的值是0x0.
通过调用ctl_getitem来获取下一个小块的内容，而返回值v，就是下一小块的起始地址，val是下一小块存放内容的地址值。首先会对小块进行切割，以逗号作为结束标志，以等于号作为值判断的标志。
    gdb-peda$ next
    Program received signal SIGALRM, Alarm clock.
     [----------------------------------registers-----------------------------------]
    EAX: 0xb75536c8 --> 0xb769c760 --> 0x20002 
    EBX: 0x99e6e40 ("e, laddr=[]:Hrags=32, laddr=[]:WOP")
    ECX: 0x65 ('e')
    EDX: 0x0 
    ESI: 0x99e6e72 --> 0x0 
    EDI: 0xbfade550 --> 0x8058ff0 (: mov    eax,DWORD PTR [esp+0x4])
    EBP: 0x99e6e3c ("nonce, laddr=[]:Hrags=32, laddr=[]:WOP")
    ESP: 0xbfade170 --> 0xbfade1e4 --> 0x0 
    EIP: 0x805a4b5 (: add    ebx,0x1)
    EFLAGS: 0x216 (carry PARITY ADJUST zero sign trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
       0x805a4af : nop
       0x805a4b0 : cmp    cl,0x2c
       0x805a4b3 : je     0x805a4d8 
    => 0x805a4b5 : add    ebx,0x1
       0x805a4b8 : cmp    ebx,esi
       0x805a4ba : je     0x805a4d8 
       0x805a4bc : movzx  ecx,BYTE PTR [ebx]
       0x805a4bf : cmp    cl,0x3d
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
    3111 for (tp = NULL, cp = reqpt; cp != reqend; ++cp) {
    gdb-peda$ next
    Program received signal SIGALRM, Alarm clock.
     [----------------------------------registers-----------------------------------]
    EAX: 0xb75536c8 --> 0xb769c760 --> 0x20002 
    EBX: 0x99e6e41 (", laddr=[]:Hrags=32, laddr=[]:WOP")
    ECX: 0x2c (',')
    EDX: 0x0 
    ESI: 0x99e6e72 --> 0x0 
    EDI: 0xbfade550 --> 0x8058ff0 (: mov    eax,DWORD PTR [esp+0x4])
    EBP: 0x99e6e3c ("nonce, laddr=[]:Hrags=32, laddr=[]:WOP")
    ESP: 0xbfade170 --> 0xbfade1e4 --> 0x0 
    EIP: 0x805a4bf (: cmp    cl,0x3d)
    EFLAGS: 0x297 (CARRY PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)
    Legend: code, data, rodata, value
    3112 if (*cp == '=' && tp == NULL)
    gdb-peda$ next
    Program received signal SIGALRM, Alarm clock.
     [----------------------------------registers-----------------------------------]
    EAX: 0xb75536c8 --> 0xb769c760 --> 0x20002 
    EBX: 0x99e6e41 (", laddr=[]:Hrags=32, laddr=[]:WOP")
    ECX: 0x2c (',')
    EDX: 0x0 
    ESI: 0x99e6e72 --> 0x0 
    EDI: 0xbfade550 --> 0x8058ff0 (: mov    eax,DWORD PTR [esp+0x4])
    EBP: 0x99e6e3c ("nonce, laddr=[]:Hrags=32, laddr=[]:WOP")
    ESP: 0xbfade170 --> 0xbfade1e4 --> 0x0 
    EIP: 0x805a4b0 (: cmp    cl,0x2c)
    EFLAGS: 0x293 (CARRY parity ADJUST zero SIGN trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
       0x805a4ab : xor    edx,edx
       0x805a4ad : jmp    0x805a4bf 
       0x805a4af : nop
    => 0x805a4b0 : cmp    cl,0x2c
       0x805a4b3 : je     0x805a4d8 
       0x805a4b5 : add    ebx,0x1
       0x805a4b8 : cmp    ebx,esi
       0x805a4ba : je     0x805a4d8 
    [------------------------------------stack-------------------------------------]
    0000| 0xbfade170 --> 0xbfade1e4 --> 0x0 
    0004| 0xbfade174 --> 0x80 
    0008| 0xbfade178 --> 0x99ea4e0 --> 0x0 
    0012| 0xbfade17c --> 0x99e6e72 --> 0x0 
    0016| 0xbfade180 --> 0xf 
    0020| 0xbfade184 --> 0x74 ('t')
    0024| 0xbfade188 --> 0xbfade568 --> 0x99e6ddc --> 0x10920002 
    0028| 0xbfade18c --> 0xbfade310 ("addr.15")
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
回头看一下我们之前的数据包，其中nonce块没有赋值，在ctl_getitem中，会对val的值赋值为NULL，如果没有等于号赋值，那么这个值就一直为NULL，这样当执行到返回的时候，val的值为NULL。ntp_control.c第3080行:
    static const struct ctl_var *
    ctl_getitem(
    const struct ctl_var *var_list,
    char **data
    )
    {
      //3119行
    *data = NULL;
data赋值为0x0后，会对data进行赋值，但是这里由于没有值，所以没有做处理，直接令其为0x0，然后返回。
    gdb-peda$ c
    Continuing.
    Program received signal SIGALRM, Alarm clock.
    [-------------------------------------code-------------------------------------]
       0x805a670 : pop    esi
       0x805a671 : pop    edi
       0x805a672 : pop    ebp
    => 0x805a673 : ret    
    Legend: code, data, rodata, value
    Breakpoint 8, 0x0805a673 in ctl_getitem (var_list=, 
        data=data@entry=0xbfade1e4) at ntp_control.c:3195
    3195 }
    gdb-peda$ x/10x 0x99ea4e0
    0x99ea4e0: 0x00000000
随后调用了strcmp做了一个比较，比较的内容就是v的text字段到底属于哪一段，第一个比较的值就是nonce，这里数据包中Data部分的地一小块就是nonce，因此进入nonce处理。
    [-------------------------------------code-------------------------------------]
       0x805f97e : sub    esp,0x8
       0x805f981 : push   edi
       0x805f982 : push   eax
    => 0x805f983 : call   0x804a050 
       0x805f988 : add    esp,0x10
       0x805f98b : test   eax,eax
       0x805f98d : 
        jne    0x805f9c0 
       0x805f98f : mov    eax,DWORD PTR [ebp-0x3ac]
    Guessed arguments:
    arg[0]: 0xbfebcc18 ("nonce")
    arg[1]: 0x88c78e8 ("nonce")
而nonce此时没有值，val被赋值为0x0，进入estrdup后，造成了空指针引用。
    gdb-peda$ n
    Program received signal SIGALRM, Alarm clock.
    [-------------------------------------code-------------------------------------]
       0x805f9a2 : add    esp,0x10
       0x805f9a5 : sub    esp,0xc
       0x805f9a8 : push   DWORD PTR [ebp-0x384]
    => 0x805f9ae : call   0x80948e0 
       0x805f9b3 : add    esp,0x10
       0x805f9b6 : mov    DWORD PTR [ebp-0x3ac],eax
       0x805f9bc : 
        jmp    0x805f950 
       0x805f9be : xchg   ax,ax
    Guessed arguments:
    arg[0]: 0x0 
    [------------------------------------stack-------------------------------------]
    0000| 0xbfebcbc0 --> 0x0 
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
    Breakpoint 2, 0x0805f9ae in read_mru_list (rbufp=0x88c4dd8, 
        restrict_mask=0x0) at ntp_control.c:4041
    4041 pnonce = estrdup(val);
    gdb-peda$ x/10x $esp
    0xbfebcbc0: 0x00000000
**补丁对比**
此漏洞是由于val作为参数传入estrdup_impl函数中，在函数中会调用strlen获取val长度，当val的值为0x0的时候，会由于空指针引用引发拒绝服务漏洞。来看一下在4.2.8p8版本中，ntp_control.c中关于val处理的部分，第4034行：
    while (NULL != (v = ctl_getitem(in_parms, &val)) &&
           !(EOV & v->flags)) {
    int si;
    if (!strcmp(nonce_text, v->text)) {
    if (NULL != pnonce)
    free(pnonce);
    pnonce = estrdup(val);
这里没有对val进行判断，导致获取val之后直接传入estrdup中执行，在4.2.8p9，也就是ntp.org中11月更新的最新版中，对这一块处理进行了修复，ntp_control.c中第4048行：
    while (NULL != (v = ctl_getitem(in_parms, (void*)&val)) &&
           !(EOV & v->flags)) {
    int si;
    if (NULL == val)
    val = nulltxt;
    if (!strcmp(nonce_text, v->text)) {
    free(pnonce);
    pnonce = (*val) ? estrdup(val) : NULL;
可以看到在进入estrdup处理前，先对val本身的值进行了判断，当nonce的值没有未初始化时，会将nonce的值初始化，则将val赋值为nulltxt，关于nulltxt在ntp_control.c开始的位置进行了定义。
    static const charnulltxt[1] = { '' };
赋值之后，在pnonce调用estrdup函数的时候对val存放的值进行了判断，如果为NULL，则直接pnonce，这样就不会再将vul空指针传入estrdup中调用strlen导致空指针引用了。