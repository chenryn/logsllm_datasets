219190092923698137571174584001618243726404688552257457773360565493810569068383
273664286929905167374986060851892496173584735684037889535771979124074591360189
776288360130316240776662582509201693427241370225544170475960286150066498263 
于是可以写脚本解密了： 
import gmpy 
p=1222818722210917739238420912585314719488861203362844825556051676838296900731
108986732607128650212446339089827052902015989075389756929203052399616451098970
810115244857067557948822838920118240061172761621193319707282291087316961643778
08170099285659797066904706924125871571157672409051718751812724929680249712137 
q=1702899108128354650963385429974774873594357986416933811252769120706025487113
282191900929236981375711745840016182437264046885522574577733605654938105690683
832736642869299051673749860608518924961735847356840378895357719791240745913601
89776288360130316240776662582509201693427241370225544170475960286150066498263 
e=65537 
n=2082336911455626076291358884447186972576298581221598799386778363005142024105
791238505548278801632797846831806707823384405259975081315564434112331488276205
752409873296138283321529126659182463239286771617496790654435614407205113265933
914015588956981088501385146705604800367216505964040839495357307243152355684807
795800597153361891221979391452407791905859158645171611363777024506768759893107
182734474093698277611298610405119192261361604510285904423478963605856839661103
096663956192203671200191123855239162565874165964488806924472972929792727938431
8252191421446283531524990762609975988147922688946591302181753813360518031 
print  n==p*q 
phi = (p-1)*(q-1) 
d = gmpy.invert(e, phi) 
c=0x68d5702b70d18238f9d4a3ac355b2a8934328250efd4efda39a4d750d80818e6fe228ba3af47
1b27cc529a4b0bef70a2598b80dd251b15952e6a6849d366633ed7bb716ed63c6febd4cd0621b0c
4ebfe5235de03d4ee016448de1afbbe61144845b580eed8be8127a8d92b37f9ef670b3cdd5af613c
76f58ca1a9f6f03f1bc11addba30b61bb191efe0015e971b8f78375faa257a60b355050f6435d94b4
9eab07075f40cb20bb8723d02f5998d5538e8dafc80cc58643c91f6c0868a7a7bf3bf6a9b4b6e79e0
a80e89d430f0c049e1db4883c50db066a709b89d74038c34764aac286c36907b392bc299ab8288f
9d7e372868954a92cdbf634678f7294096c7 
msg = pow(c, d, n) 
print msg 
print ('0' + hex(msg)[2:]).decode('hex') 
#sH1R3_PRlME_1N_rsA_iS_4ulnEra5le 
得到数据之后写解压得到 flag ：SCTF{5o0_mAtI4E_TrE1SUre_ILn_rSA_a55aCk_3}
写在后面的话：这个 n 分解出来之后我发现，所有的 n 值存在一个公约数，也就是说，这
个题目其实很简单的。只要想到这个，直接使用 Python 的 gcd 就可以分解出来一个 n，然
后就做出来了，但是当时我想多了。。。我以为是考察数据的并行运算。。。。 
Code300(300) 
有两轮加密 
第一轮： 
注意到这一组加密数据中有两个 n 是相同的，而且加密内容相关，并且大部分相同 
可进行 Coppersmith’s Short Pad attack 和 Franklin-Reiter related messages attack 
参考 http://mslc.ctf.su/wp/confidence-ctf-2015-rsa1-crypto-400/ 
完整代码： 
from sage.all import * 
e=3 
n1=253579011891727331496253323915370645782650032499178176828641206638983365109
221132583974413782393423497673172852212958324624133003767045079363590461209433
342150785409039621287197060770675579482183087001431384204080535006286162993382
047182132834818335133736961707744256198860494081032171792622640037656953905473
556248679513797899242475973704965462498989246482744191648998311919251271820663
012376732434235396042192743975397868594208663298852852321799830557637042010232
130871198953212600466177607023204730697436887784388548994092925276959930454825
49594428191729963645157765855337481923730481041849389812984896044723939553 
C1=211661986371197990180162042952505361669158566389194052618409153149880428734
326205185776151324484487233276894786787551724625566828895710758910415162208349
414890062192507122336833723490634662371777098674169164769851700933875541522323
275275814661437802225602104466631082944248576498208512713083411784678860915781
16410156922264637037227745852409331989620504 
C2=211661986371197990180162042952505361669158566389194052618409153149880428734
326205185776151324484487233276894786787921764226446623369660503639406353313612
057934181799450761164327088095909281450307952589232069116944395338556299785633
826175784066392440140038485315406130759724950305728001072004894704986472367100
18970753334604604728734347799544201644707336 
PRxy. = PolynomialRing(Zmod(n1)) 
PRx. = PolynomialRing(Zmod(n1)) 
PRZZ. = PolynomialRing(Zmod(n1)) 
g1 = x**e - C1 
g2 = (x + y)**e - C2 
q1 = g1.change_ring(PRZZ) 
q2 = g2.change_ring(PRZZ) 
h = q2.resultant(q1) 
# need to switch to univariate polynomial ring 
# because .small_roots is implemented only for univariate 
h = h.univariate_polynomial() # x is hopefully eliminated 
h = h.change_ring(PRx).subs(y=xn) 
h = h.monic() 
roots = h.small_roots(X=2**40, beta=0.3) 
assert roots, "Failed1" 
diff = roots[0] 
if diff > 2**32: 
    diff = -diff 
    C1, C2 = C2, C1 
print "Difference:", diff 
#x = PRx.gen() # otherwise write xn 
#x=1002 
x=xn 
g1 = x**e - C1 
g2 = (x + diff)**e - C2 
# gcd 
while g2: 
    g1, g2 = g2, g1 % g2 
g = g1.monic() 
assert g.degree() == 1, "Failed 2" 
# g = xn - msg 
msg = -g[0] 
# convert to str 
h = hex(int(msg))[2:].rstrip("L") 
h = "0" * (len(h) % 2) + h 
print `h.decode("hex")` 
得到 F4An8LIn_rElT3r_rELa53d_Me33Age_aTtaCk_e_I2_s7aP6 
减去 userid 为 
F4An8LIn_rElT3r_rELa53d_Me33Age_aTtaCk_e_I2_s7aLL 
进入第二轮： 
明显的小指数广播攻击，参考 
http://codezen.fr/2014/01/16/hackyou-2014-crypto-400-cryptonet/ 
完整代码： 
from struct import pack,unpack 
import zlib 
import gmpy 
def my_parse_number(number): 
    string = "%x" % number 
    #if len(string) != 64: 
    #    return "" 
    erg = [] 
    while string != '': 
        erg = erg + [chr(int(string[:2], 16))] 
        string = string[2:] 
    return ''.join(erg) 
def extended_gcd(a, b): 
    x,y = 0, 1 
    lastx, lasty = 1, 0 
    while b: 
        a, (q, b) = b, divmod(a,b) 
        x, lastx = lastx-q*x, x 
        y, lasty = lasty-q*y, y 
    return (lastx, lasty, a) 
def chinese_remainder_theorem(items): 
  N = 1 
  for a, n in items: 
    N *= n 
  result = 0 
  for a, n in items: 
    m = N/n 
    r, s, d = extended_gcd(n, m) 
    if d != 1: 
      N=N/n 
      continue 
      #raise "Input not pairwise co-prime" 
    result += a*s*m 
  return result % N, N 
sessions=[ 
[21778816622407043254249033744556437773178718344170907687035355752306254181495
272254316323076827432323583279284697609943296234700945010885010381052459024155
936090811012664924674758219163065019349740707282354505096608107707774970709715
259835448587834080152409078047162951805940071358655938727249679105305351838950
073539149057650448964397736279148746703675407495243942505041731104580156762842