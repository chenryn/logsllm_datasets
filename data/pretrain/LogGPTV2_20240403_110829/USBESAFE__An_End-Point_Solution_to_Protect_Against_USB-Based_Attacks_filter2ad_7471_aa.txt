# USBESAFE: An End-Point Solution to Protect Against USB-Based Attacks

## Authors
Amin Kharraz†, Brandon L. Daley (cid:5)‡, Graham Z. Baker (cid:5)‡, William Robertson‡, Engin Kirda‡

- (cid:5) MIT Lincoln Laboratory
- † University of Illinois at Urbana-Champaign
- ‡ Northeastern University

## Abstract
Targeted attacks via transient devices are not new. However, the introduction of BadUSB attacks has significantly shifted the attack paradigm. These attacks embed malicious code in device firmware and exploit the lack of access control in the USB protocol. In this paper, we propose USBESAFE as a mediator of the USB communication mechanism. By leveraging insights from millions of USB packets, we propose techniques to generate a protection model that can identify covert USB attacks by distinguishing BadUSB devices. Our results show that USBESAFE achieves a true positive (TP) rate of 95.7% with a false positive (FP) rate of 0.21%, with latency as low as three malicious USB packets. We tested USBESAFE by deploying the model at several end-points for 20 days and running multiple types of BadUSB-style attacks with varying levels of sophistication. Our analysis shows that USBESAFE can detect a large number of mimicry attacks without introducing significant changes to the standard USB protocol or underlying systems. The performance evaluation also demonstrates that USBESAFE is transparent to the operating system and imposes no discernible performance overhead during the enumeration phase or USB communication compared to the unmodified Linux USB subsystem.

## 1. Introduction
Transient devices such as USB devices have long been used as an attack vector. Most of these attacks rely on users who unwittingly open their organizations to internal threats. Recent security breaches illustrate that adversaries employ such devices to spread malware, take control of systems, and exfiltrate information.

Despite several warnings about the risks of malicious peripherals, users remain vulnerable to USB attacks [27, 28]. Antivirus software is becoming increasingly adept at scanning USB storage for malware, automatically checking removable devices like USB sticks, memory cards, external hard drives, and even cameras after they are plugged in. Unfortunately, bypassing these checks is often not difficult, as the firmware of USB devices cannot be scanned by the host. The introduction of BadUSB attacks has shifted the attack paradigm, as adversaries can easily hide malicious code in the firmware, allowing the device to take covert actions on the host [9]. For example, a USB flash drive could register itself as both a storage device and a Human Interface Device (HID), enabling it to inject surreptitious keystrokes.

Existing defenses against malicious USB devices have improved end-user protection, but these solutions often require major changes to the current USB protocol, such as introducing access control mechanisms [26], modifying certificate management [20], or changing the user experience (e.g., a user-defined policy infrastructure) [3, 24]. Our goal is to improve the security of USB devices while keeping the corresponding protection mechanism completely in the background. This approach offers flexibility, allowing organizations to use standard devices, manufacturers to avoid changing how their hardware operates, and users to continue using their current USB devices.

In this paper, we propose USBESAFE, a system to identify BadUSB-style attacks, which are among the most prominent attacks exploiting the USB protocol. Our approach relies on analyzing how benign devices interact with the host and the operating system. By leveraging insights from millions of USB Request Blocks (URBs) collected over 14 months from various USB devices such as keyboards, mice, headsets, mass storage devices, and cameras, we propose classification techniques that can capture how a benign USB device interacts with a host by monitoring URBs. Starting with a wide range of classification features, we carefully analyze the labeled data and narrow down to three feature categories: content-based, timing-based, and type-based features. We train several machine learning techniques, including SVM [14], Nearest Neighbor [13], and Cluster-based Techniques [12], to find the most accurate algorithm for building our detection model. Our analysis showed that One-Class SVM achieved the highest detection results with a low false positive rate (a TP rate of 95.7% with 0.21% FPs) on the labeled dataset. The constructed model allows us to identify covert USB attacks by distinguishing BadUSB devices as novel observations for the trained dataset.

To test USBESAFE, we deployed the constructed model as a service on end-user machines for 20 days. Our analysis shows that USBESAFE is successful in identifying several forms of BadUSB attacks with a low false positive rate on live, unknown USB traffic. For real-world deployment, we also performed a training/re-training analysis to determine how USBESAFE should be deployed on new machines to maintain a high detection rate with under a 1% false positive rate. We show that training USBESAFE with as little as two training days and re-training it every 16 days for 82 seconds is sufficient to maintain a detection rate over 93% across all machines.

The most important finding in this paper is practical evidence that it is possible to develop models that can explain benign data in a very precise fashion. This makes anomaly detection a promising direction to defend against BadUSB-style attacks without performing any changes to the standard USB protocol or underlying systems. We ran multiple adversarial scenarios to test USBESAFE’s resilience to evasion, assuming adversaries have significant freedom to generate new forms of BadUSB-style attacks to evade detection. Our analysis shows that USBESAFE can successfully detect mimicry attacks with different levels of sophistication without imposing a discernible performance impact or changing the way users interact with the operating system. We envision multiple potential deployment models for USBESAFE. Our detection approach can be incorporated as a lightweight operating system service to identify BadUSB attacks and disable the offending port or as an early-warning solution to automatically identify the attacks and notify system administrators.

## 2. Background, Threat Model, and Related Work

### 2.1 Universal Serial Bus (USB)
A Universal Serial Bus (USB) device can be a peripheral such as a Human Interface Device (HID), printer, storage, or a USB transceiver. An attached USB device can have multiple functionalities, each determined by its interfaces. The host controller interacts independently with these interfaces by loading a device driver for each interface. When a USB device is attached, the USB controller in the host issues a set of control requests to obtain the configuration parameters of the device to activate the supported configuration. The host parses the configuration and reads the device descriptor, which contains information about the device's functionality. This information allows the host to load a driver based on the configuration information. This procedure is called the enumeration phase. In the enumeration phase of the USB protocol, endpoints are addressed as IN and OUT to manage USB traffic. The IN endpoint stores data coming to the host, and the OUT endpoint receives data from the host. After the enumeration phase, the host loads the USB interfaces, allowing the device to operate.

### 2.2 Threat Model
In our threat model, we assume that a connecting device can report any capabilities to the bus, and the host machine trusts the information it receives from the device. Similar to BadUSB attacks [9], an adversary can use this capability by rewriting the firmware of an existing device to hide malware in the code that communicates with a host. Specifically, upon insertion into a host USB port, a mass storage device, such as a USB flash drive (with capabilities for Windows and Linux), can covertly perform keyboard actions to open a command prompt, issue a shell command to download malicious code from the Internet, and execute the downloaded malware. Classic USB attacks, such as using the autorun capabilities of USB devices to distribute malware, are out of the scope of this paper, as these attacks can be detected by most malware scanners. Similar to prior work [24], we address the advanced persistent threat (APT) scenario where an adversary attempts to expand their presence in a network by distributing USB devices with malicious firmware. We assume that the malicious USB device can generate new device identities during the enumeration phase by providing varying responses to evade potential device identification mechanisms. We also assume that there is no USB-level authentication mechanism between the device and the target host. The OS acts on the information provided by the device and will load a driver to accept the USB drive, for example, as an HID device. Once connected, the adversary can use any technique to expand their presence, such as opening a command prompt to perform privilege escalation, exfiltrate files, or copy itself for further propagation. Finally, in this work, we assume that the trusted computing base includes the display module, OS kernel, and underlying software and hardware stack. Therefore, we consider these components free of malicious code, and normal user-based access control prevents attackers from running malicious code with superuser privileges.

### 2.3 Related Work
A wide range of attacks have been introduced via USB, including malware, data exfiltration on removable storage [8, 16, 17, 22], and tampered device firmware [5, 9]. Defending against USB attacks is often not straightforward, as these attacks can be tailored for many scenarios. Existing solutions include hardwiring USB microcontrollers to only allow firmware updates digitally signed by the manufacturer, adhering to IEEE Standard 1667 [20] for bidirectional authentication, and proposing access control mechanisms on USB storage devices [6, 19, 23, 30]. While these approaches can lead to better defense mechanisms, recent studies [21, 24] have shown that they are coarse and cannot distinguish between desired and undesired usage of a particular interface. Very recently, Hernandez et al. [7] introduced FirmUSB, a firmware analysis framework, to examine firmware images using symbolic analysis techniques. Another approach to mitigating such attacks is to minimize the attack surface without changing the fundamentals of USB communication or patching major operating systems. Tian et al. [24] proposed GoodUSB, which constructs a policy engine that relies on virtualization and a database of known USB devices, reporting unknown devices to the user. Tian et al. [26] also proposed USBFilter, a packet-driven access control mechanism for USB, and ProvUSB [25], which incorporates provenance-based data forensics and integrity assurance. Angel et al. [3] leverages virtualization to achieve similar goals. We posit that a solution that introduces as little change as possible to the user operational status quo is more likely to prevent exploitation in practice, given a reliable underlying detection mechanism.

## 3. Overview of the Approach
In this section, we provide more details on the components of USBESAFE and the model we use to detect BadUSB attacks. Figure 1 shows the pipeline used by USBESAFE to identify BadUSB-style attacks.

### 3.1 System Design
The architecture of a USBESAFE-enhanced system requires interactions among multiple components of the operating system. In this section, we describe the abstract design of USBESAFE, independent of the underlying OS. Later, we will demonstrate how our design can be realized in a prototype running on Linux. USBESAFE’s components are mostly managed by a user space daemon, which includes three main subsystems: a lightweight user space module that processes transaction flows between the host and the connected device; a detection module that implements the USB mediator logic; and a user interface that generates alerts and notifies the user. When a USB device is connected to the host, USBESAFE collects and preprocesses the URBs. The protection engine utilizes the preprocessed data to construct the feature vector and test whether the incoming USB packets are indeed new observations. If the system detects a novel sequence of USB packets, it creates a notification and sends an alert to the user.

#### 3.1.1 USB Event Monitor
The ultimate goal of the event monitor is to analyze URBs and transform them into an appropriate format for the protection engine. The USB event monitor detects a connected device and processes the transaction flows in the form of URBs, which contain USB packets during the USB connection lifecycle from enumeration to configured communication to termination. To store and analyze USB packets, we implemented a set of data objects. The module parses each URB, extracts the USB packet, and generates a TraceEvent containing the USB header information and payload. Each TraceEvent is a tuple that includes the host bus ID and the assigned device ID on the bus. Each TraceEvent, representing a single USB packet, is appended to a Trace—a list of TraceEvents. USBESAFE generates a single Trace file for each USB device from the enumeration to the disconnection phase. TraceEvents in each Trace are sorted according to their timestamp, from earliest to most recent. For each Trace, we identify the device and configuration descriptor responses, storing them as auxiliary information for the Trace.

The root of the data structure is called the TraceLibrary, which organizes and manages the Traces.