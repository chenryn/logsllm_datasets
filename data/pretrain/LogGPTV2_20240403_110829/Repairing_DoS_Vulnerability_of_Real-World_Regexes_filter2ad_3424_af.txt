sions is out of scope for their work as mentioned in their pa-
pers. Additionally, supporting them would require a substantial
overhaul as described in Sections III, IV, and V.
In summary, REMEDY improves the other state-of-the-art
tools from a theoretical point of view, and is the only one to
support all characteristics. We emphasize that all the other
state-of-the-art tools can repair none of the regexes used in
the evaluation.
Furthermore, we have compared REMEDY against the DFA-
based approach of [41]. Their approach is not PBE but claims
to produce an invulnerable pure regex that is semantically
equivalent to the given pure regex. We performed an experi-
ment by using 100 pure regexes randomly selected from the
data set of [7], and compare the size of the regex repaired by
the DFA-based approach and REMEDY.
We observed that (1) 100/100 of the regexes repaired by
REMEDY are more concise than those of the DFA-based
approach, and (2) the size of the regex repaired by the DFA-
based approach is 37.3 times larger than that of REMEDY on
average. We observe that this is partly because REMEDY can
use real-world extensions (even for repairing pure regexes),
and also because the DFA-based approach ensures semantic
equivalence, which is often undesirable (cf. Section VII).
Note that a semantics-preserving DFA conversion can generate
exponentially large DFAs. For example, for the regex ·∗·∗=,
which is vulnerable, REMEDY returns the repaired invulnerable
regex ··∗(?]∗font-style:italic[ˆ>]∗>
REMEDY returns the repaired invulnerable regex
]∗)>
while the one returned by the DFA-based approach is of
size 73,433,094. In summary, compared to the DFA-based
approach, REMEDY can find simpler and more understandable
regexes.
F. Availability
Our tool is available in [42].
VII. LIMITATIONS AND FUTURE WORK
We discuss some limitations of our approach and directions
for future work. The first limitation is that we do not consider
extraction of captured strings. This is a common limitation in
regex repair and synthesis and many other recent works also
do not support extraction [20], [22]–[24].
Extraction is especially problematic for real-world regexes
as which string is captured in a lookahead is regex engine
dependent.3 A recent work has proposed an approach to cope
with the issue in the context of symbolic execution [44] that in-
volves executing an actual regex engine. But such an approach
would be less ideal for repairs where we want to generate a
regex that is correct and invulnerable in all contexts. We leave
as future work to investigate the support for extraction. It is
important to note that our formal definition of vulnerability
considers all possible captures that can happen in a lookahead,
and thus our approach is regex-engine-independently sound
with respect to invulnerability.
The second limitation is the lack of support for semantic
equivalence. As in other PBE methods, we consider the use
case where the given regex is incorrect or only partly built. As
argued by others [7], [13], [24], often, semantic equivalence
is too strong to use in practice and PBE is better at reflecting
users’ intentions. But in future work, we would like to also
3It can even cause differences in the matching results in the rare cases where
strings captured in lookaheads are backreferenced. For example, matching
1 )\1a with a succeeds in Python’s re and PCRE, but fails in
(?=(a∗)+
ECMAScript [43].
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
122071
TABLE I: A comparison of current state-of-the-art tools. ! and ✗ indicate that the tool has and does not have the characteristic,
respectively. Binary Alphabet and Multiple Alphabet indicate that the tool can synthesize a regex over binary and multiple
alphabets, respectively. Correctness Guarantees indicates that the tool guarantees that synthesized regexes are consistent with
all examples. Invulnerability Guarantees indicates that the tool guarantees that synthesized regexes are not ReDoS vulnerable.
Real-world Extensions indicates that the tool can support real-world extensions.
Tool
Binary Alphabet Multiple Alphabet
Correctness Guarantees
Invulnerability Guarantees
Real-world Extensions
REMEDY
AlphaRegex [20]
RFixer [22]
FlashRegex [24]
!
!
!
!
!
✗
!
!
!
!
!
!
!
✗
✗
✗
!
✗
✗
✗
support the case where the user is interested in only repairing
vulnerability (e.g., because the regex is built correct by using
some PBE method). However, whether a regex can be repaired
to be invulnerable while preserving its semantics in general is
an open problem. At least for real-world regexes, there are
some reasons to doubt the possibility: semantic equivalence
of real-world regexes is undecidable [26] and regexes with
backreferences are not determinizable in general [45].
VIII. RELATED WORK
As remarked in Section I, there has been substantial work
on PBE methods for synthesizing and repairing regexes [5],
[19]–[24]. However, the existing methods do not support the
real-world features such as lookarounds and backreferences.
Furthermore, with the exception of [24] discussed below, the
existing methods are not designed with resilience to ReDoS
in mind and may generate vulnerable regexes.
A recent work by Li et al. [24] proposes a PBE regex
synthesis and repair method that addresses vulnerability. Their
method guarantees that
the generated regex is determinis-
tic (i.e., 1-unambiguous) [28], [29]. However, as we have
shown in Section IV-A, 1-unambiguity is insufficient for
invulnerability. Therefore, their method does not guarantee the
invulnerability of the returned regexes. Also, their method only
synthesizes and repairs pure regexes and does not support the
real-world extensions. By contrast, our work supports real-
world regexes and also formally guarantees the invulnerability
of the synthesized regexes.
While not PBE, the work by van der Merwe et al. [41]
proposes a technique based on DFA conversion and insertion
of positive lookaheads to convert a vulnerable regex into an
invulnerable one. However, they only consider the fragment
with the positive lookahead extension. Also, as discussed in
Section VI-E, the DFA-based approach can produce complex
regexes that are hard to understand. In a similar vein, Cody-
Kenny et al. [46] proposes a genetic-programming based
method to convert a regex into one with more efficient
matching. However, their method only supports pure regexes
and does not guarantee invulnerability.
While our work concerns repairing vulnerability, there has
been considerable work on the related problem of detecting
vulnerability [12]–[16]. It is worth noting that while some
(namely [12], [14], [16]) proposes to detect vulnerability
formally rather than experimentally, no prior work on formal
vulnerability detection supports the real-world extensions.
Whether a sound-and-complete detection of vulnerability for
real-world regexes is possible is an open question.
Another related work is a recent work by Davis et al. [47]
that proposes a regex engine optimization to eliminate super-
linear behavior of real-world regex matching at run time.
Finally, a recent work by Loring et al. [44] presents a dynamic
symbolic execution method for real-world regexes that ad-
dresses the regex-engine-dependent capturing issue mentioned
in Section VII.
IX. CONCLUSION
We have presented a novel PBE regex repair method that
guarantees the invulnerability of synthesized regexes and
supports real-world regexes containing extended features of
lookarounds, capturing groups, and backreferences. For this,
we have defined a novel formal semantics of backtracking
matching algorithm for real-world regexes and a formal defi-
nition of its time complexity. With them, we have defined the
first formal definition of ReDoS vulnerability for real-world
regexes. Additionally, we have presented a novel condition
called real-world strong 1-unambiguity (RWS1U) which we
proved to be sound for guaranteeing ReDoS invulnerability
of real-world regexes, formalized the RWS1U repair problem
and proved its NP-hardness. We have presented an algorithm
for solving the RWS1U repair problem and experimentally
evaluated its implementation, REMEDY, on a real-world data
set. The evaluation have shown that REMEDY can repair
vulnerable real-world regexes successfully and efficiently.
To the best of our knowledge, we are the first to tackle the
ReDoS vulnerabilities for real-world regexes and the challenge
of repairing them, whose theoretical properties are substan-
tially different from that of pure regexes which are tackled
by prior works [5], [19]–[24], [41], [46] that only considered
pure regexes and/or did not concern ReDoS vulnerability.
ACKNOWLEDGEMENTS
We thank the anonymous reviewers for their useful com-
ments. This work was supported by JSPS KAKENHI Grant
Numbers 17H01720, 18K19787, 20H04162, and 20K20625.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
132072
REFERENCES
[1] C. Chapman and K. T. Stolee, “Exploring regular expression usage and
context in python,” in Proceedings of the 25th International Symposium
on Software Testing and Analysis, ser. ISSTA 2016. New York,
NY, USA: Association for Computing Machinery, 2016, pp. 282–293.
[Online]. Available: https://doi.org/10.1145/2931037.2931073
[2] R. Cox,
(but
“Regular
can
is slow in java, perl, php, python,
expression matching
fast
https://swtch.com/∼rsc/regexp/regexp1.html
December-2021].
[Online;
be
ruby,
simple
and
...),” 2007,
10-
accessed
[3] P. Hooimeijer, B. Livshits, D. Molnar, P. Saxena, and M. Veanes,
“Fast and precise sanitizer analysis with bek,” in Proceedings of the
20th USENIX Conference on Security, ser. SEC’11. USA: USENIX
Association, 2011, p. 1.
[4] F. Yu, C.-Y. Shueh, C.-H. Lin, Y.-F. Chen, B.-Y. Wang, and T. Bultan,
“Optimal sanitization synthesis for web application vulnerability repair,”
in Proceedings of the 25th International Symposium on Software Testing
and Analysis, ser. ISSTA 2016. New York, NY, USA: Association
for Computing Machinery, 2016, pp. 189–200. [Online]. Available:
https://doi.org/10.1145/2931037.2931050
[5] A. Bartoli, A. De Lorenzo, E. Medvet, and F. Tarlao, “Inference of reg-
ular expressions for text extraction from examples,” IEEE Transactions
on Knowledge and Data Engineering, vol. 28, no. 5, pp. 1217–1230,
May 2016.
[6] Y. Li, R. Krishnamurthy, S. Raghavan, S. Vaithyanathan, and H. V.
Jagadish, “Regular expression learning for information extraction,”
in Proceedings of
the 2008 Conference on Empirical Methods in
Natural Language Processing. Honolulu, Hawaii: Association for
Computational Linguistics, Oct. 2008, pp. 21–30. [Online]. Available:
https://www.aclweb.org/anthology/D08-1003
the ecosystem scale,” in Proceedings of
[7] J. C. Davis, C. A. Coghlan, F. Servant, and D. Lee, “The impact of
regular expression denial of service (redos) in practice: An empirical
the 2018 26th
study at
ACM Joint Meeting on European Software Engineering Conference
and Symposium on the Foundations of Software Engineering, ser.
ESEC/FSE 2018. New York, NY, USA: ACM, 2018, pp. 246–256.
[Online]. Available: http://doi.acm.org/10.1145/3236024.3236027
[8] A. Weidman, “Regular expression denial of
redos,”
2017, https://owasp.org/www-community/attacks/Regular expression -
Denial of Service - ReDoS [Online; accessed 10-December-2021].
service -
[9] J. Graham-Cumming, “Outage postmortem july 20, 2016,” 2016,
https://stackstatus.net/post/147710624694/outage-postmortem-july-20-
2016 [Online; accessed 10-December-2021].
[10] ——, “Details of
the cloudflare outage on july 2, 2019,” 2019,
https://blog.cloudflare.com/details-of-the-cloudflare-outage-on-july-2-
2019/ [Online; accessed 10-December-2021].
in javascript-based web servers,”
[11] C.-A. Staicu and M. Pradel, “Freezing the web: A study of
in 27th
redos vulnerabilities
USENIX Security Symposium (USENIX Security 18). Baltimore, MD:
USENIX Association, Aug. 2018, pp. 361–376. [Online]. Available:
https://www.usenix.org/conference/usenixsecurity18/presentation/staicu
[12] V. W¨ustholz, O. Olivo, M. J. Heule, and I. Dillig, “Static detection
of dos vulnerabilities in programs that use regular expressions,” in
Proceedings, Part II, of the 23rd International Conference on Tools
and Algorithms for the Construction and Analysis of Systems - Volume
10206. Berlin, Heidelberg: Springer-Verlag, 2017, pp. 3–20. [Online].
Available: https://doi.org/10.1007/978-3-662-54580-5 1
[13] Y. Shen, Y. Jiang, C. Xu, P. Yu, X. Ma, and J. Lu, “Rescue: Crafting
regular expression dos attacks,” in Proceedings of the 33rd ACM/IEEE
International Conference on Automated Software Engineering, ser. ASE
2018. New York, NY, USA: ACM, 2018, pp. 225–235. [Online].
Available: http://doi.acm.org/10.1145/3238147.3238159
[14] N. Weideman, B. van der Merwe, M. Berglund, and B. Watson,
“Analyzing matching time behavior of backtracking regular expression
matchers by using ambiguity of nfa,” in Implementation and Application
of Automata, Y.-S. Han and K. Salomaa, Eds.
Cham: Springer
International Publishing, 2016, pp. 322–334.
[15] J. Kirrage, A. Rathnayake, and H. Thielecke, “Static analysis for regular
expression denial-of-service attacks,” in Network and System Security,
J. Lopez, X. Huang, and R. Sandhu, Eds. Berlin, Heidelberg: Springer
Berlin Heidelberg, 2013, pp. 135–148.
[16] S. Sugiyama and Y. Minamide, “Checking time linearity of regular
expression matching based on backtracking,” Information and Media