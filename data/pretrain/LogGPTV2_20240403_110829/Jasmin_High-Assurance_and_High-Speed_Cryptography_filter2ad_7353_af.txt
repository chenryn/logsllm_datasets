then the proof is completed in Coq. Intuitively, moving to Coq is
necessary whenever there is a semantic gap—in this case due to com-
plex algebraic arguments—between the expressed post-condition
(e.g. x = y × x mod 2p) and the assertions that can be proved by
the SMT solver, which typically encode details of how the modular
reduction is carried out within the program (e.g., by first reducing
modulo 2256 and then adjusting the result). This approach has the
important benefit of reasoning directly over assembly code. How-
ever, it is labour-intensive, and delivers weak guarantees, since the
qhasm language has no formal semantics.
Zinzindohoué and co-workers [36] use an approach based on
refinement types for verifying functional correctness of an imple-
mentation of Curve25519 written in a stateful, verification-aware,
higher-order functional programming language from the ML family.
However, the assembly code is very inefficient. In a recent work,
Bhargavan and co-workers [16, 35] propose a different approach for
generating efficient and functionally verified C implementations;
however, the fastest implementations are obtained using an unveri-
fied compiler. In an independent work, Erbsen et al. [22] propose yet
another alternative approach for synthesizing functionally correct
and efficient implementations from high-level specifications written
in Coq. Finally, Bernstein and Schwabe [15] develop an automated
tool for proving functional correctness of a C implementation of
Curve25519. Starting from a sufficiently-annotated C implementa-
tion, the gfverif tool generates a set of algebraic equalities which are
sufficient to guarantee functional correctness and can be proved au-
tomatically using a symbolic computation tool. All these approaches
yield strong guarantees on the source programs, but the assembly
code is generated with untrusted tools, which is clearly undesirable
for high-assurance software. Most of these approaches also depart
significantly from current practices, and require programmers to
adopt non-conventional languages, which may be a serious obstacle
to adoption. In addition, none of these works consider side-channel
security of the assembly implementations—side-channel security
of C implementations is discussed in [16], but obviates the security
gap in modern compilers [21].
Other work. Our work is also closely related to Vale [17], which
leverages the Dafny verifier to provide a framework for prov-
ing functional correctness and side-channel resistance of high-
performance assembly code. The Vale language provides high-level
control-flow structures that simplify the writing and verification of
cryptographic routines. In contrast to Jasmin, the Vale compiler is
not verified: all verification is performed on the generated anno-
tated assembly.
Almeida et al. [2, 3] propose a general methodology for obtain-
ing strong guarantees for assembly-level implementations, through
proving simultaneously the three properties, using a C implemen-
tation of MEE-CBC as an illustrative case study. Their approach
relies on a combination of multiple tools, including EasyCrypt for
proving security of algorithmic descriptions, Frama-C for proving
functional equivalence between algorithmic descriptions and C
implementations, CompCert for proving functional equivalence
between C implementations and assembly code, and a formally
verified type system for constant-time for side-channel security.
Appel [5] leverages the Verified Software Toolchain [6] to prove
functional correctness of an assembly-level implementation of
SHA256 generated using the CompCert compiler [28]. In a related
effort, Beringer and co-workers [10] further leverage the Foun-
dational Cryptographic Framework [31] to prove, in addition to
functional correctness, cryptographic security of an assembly-level
implementation of HMAC. Recently, Ye and co-workers [34] have
extended this approach for proving correctness and cryptographic
security of the mbedTLS implementation of HMAC-DRGB.
Beyond these works on validating cryptographic implementa-
tions, there is a significant amount of work on building verified
compilers and formal models of assembly languages.
There has been a significant amount of work on analyzing side-
channel resistance of cryptographic implementations. Our work is
most closely related to static analyses for cryptographic constant-
time, including [8, 33], and specially to the product-based approach
of ct-verif [4]. However, ct-verif targets LLVM intermediate repre-
sentation, leaving open the question of carrying the results of the
analysis to assembly code, while we target code that is significantly
closer to assembly, and (informally) argue that the Jasmin compiler
preserves cryptographic constant-time.
8 CONCLUSION
Jasmin is a framework for building high-speed and high-assurance
cryptographic implementations using a programming language
Session H4:  Formal VerificationCCS’17, October 30-November 3, 2017, Dallas, TX, USA1819that simultaneously guarantees control on the generated assem-
bly and verifiability of the source programs. We justify our design
with proofs that the Jasmin compiler preserves behavior, safety,
and constant-time security of source programs; the main correct-
ness result—semantics preservation—is formally verified in the Coq
proof assistant.
Our main pending task is proving functional correctness of Jas-
min programs. We are completing a foundational (i.e. formally
verified in Coq) infrastructure for proving correctness of Jasmin
programs, and intend to leverage prior work on certified tactics for
arithmetic to achieve higher automation. Another task is to build
a foundational infrastructure for proving functional equivalence
between two Jasmin implementations. We plan to use these tools
in combination for proving functional correctness of our Jasmin
implementation of Curve25519. Moreover, we intend to include
support for richer instruction sets, and for different architectures.
As a first step, we intend to add support for vector instructions that
are routinely used in cryptographic implementations.
Acknowledgments. This work is partially supported by ONR
Grants N000141210914 and N000141512750, by Google Chrome
University, by Cátedra PT-FLAD em Smart Cities & Smart Gov-
ernance, and by Project “TEC4Growth - Pervasive Intelligence,
Enhancers and Proofs of Concept with Industrial Impact/NORTE-
01-0145-FEDER- 000020” Financed by the North Portugal Regional
Operational Programme (NORTE 2020), under the PORTUGAL
2020 Partnership Agreement, and through the European Regional
Development Fund (ERDF).
REFERENCES
[1] Nadhem J. AlFardan and Kenneth G. Paterson. 2013. Lucky Thirteen: Breaking
the TLS and DTLS Record Protocols. In IEEE Symposium on Security and Privacy,
SP 2013. IEEE Computer Society, 526–540.
José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, and François Dupressoir.
2013. Certified computer-aided cryptography: efficient provably secure machine
code from high-level implementations. In ACM CCS 13, Ahmad-Reza Sadeghi,
Virgil D. Gligor, and Moti Yung (Eds.). ACM Press, 1217–1230.
José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, and François Dupres-
soir. 2016. Verifiable Side-Channel Security of Cryptographic Implementations:
Constant-Time MEE-CBC. In FSE 2016 (LNCS), Thomas Peyrin (Ed.), Vol. 9783.
Springer, Heidelberg, 163–184. https://doi.org/10.1007/978-3-662-52993-5_9
Jose Carlos Bacelar Almeida, Manuel Barbosa, Gilles Barthe, François Dupressoir,
and Michael Emmi. 2016. Verifying Constant-time Implementations. In 25th
USENIX Security Symposium (USENIX Security 16). USENIX Association, Austin,
TX. https://www.usenix.org/conference/usenixsecurity16/technical-sessions/
presentation/almeida
[2]
[3]
[4]
[5] Andrew W. Appel. 2015. Verification of a Cryptographic Primitive: SHA-256.
ACM Trans. Program. Lang. Syst. 37, 2 (2015), 7:1–7:31. https://doi.org/10.1145/
2701415
[6] Andrew W Appel, Robert Dockins, Aquinas Hobor, Lennart Beringer, Josiah
Dodds, Gordon Stewart, Sandrine Blazy, and Xavier Leroy. 2014. Program logics
for certified compilers. Cambridge University Press.
[7] Michael Barnett, Bor-Yuh Evan Chang, Robert DeLine, Bart Jacobs, and K. Rus-
tan M. Leino. 2005. Boogie: A Modular Reusable Verifier for Object-Oriented
Programs. In Formal Methods for Components and Objects, 4th International Sym-
posium, FMCO 2005, Amsterdam, The Netherlands, November 1-4, 2005, Revised
Lectures (Lecture Notes in Computer Science), Frank S. de Boer, Marcello M. Bon-
sangue, Susanne Graf, and Willem P. de Roever (Eds.), Vol. 4111. Springer, 364–
387. https://doi.org/10.1007/11804192_17
[8] Gilles Barthe, Gustavo Betarte, Juan Diego Campo, Carlos Daniel Luna, and David
Pichardie. 2014. System-level Non-interference for Constant-time Cryptography.
In ACM CCS 14, Gail-Joon Ahn, Moti Yung, and Ninghui Li (Eds.). ACM Press,
1267–1279.
[9] Evmorfia-Iro Bartzia and Pierre-Yves Strub. 2014. A Formal Library for Elliptic
Curves in the Coq Proof Assistant. In Interactive Theorem Proving - 5th Inter-
national Conference, ITP 2014, Held as Part of the Vienna Summer of Logic, VSL
2014, Vienna, Austria, July 14-17, 2014. Proceedings (Lecture Notes in Computer
Science), Gerwin Klein and Ruben Gamboa (Eds.), Vol. 8558. Springer, 77–92.
https://doi.org/10.1007/978-3-319-08970-6_6
[10] Lennart Beringer, Adam Petcher, Katherine Q. Ye, and Andrew W. Appel.
2015. Verified Correctness and Security of OpenSSL HMAC. In 24th USENIX
Security Symposium, USENIX Security 15, Washington, D.C., USA, August 12-
14, 2015., Jaeyeon Jung and Thorsten Holz (Eds.). USENIX Association, 207–
221. https://www.usenix.org/conference/usenixsecurity15/technical-sessions/
presentation/beringer
[11] Dan Bernstein. Writing high-speed software. (????). http://cr.yp.to/qhasm.html
[12] Daniel J. Bernstein. 2005. Cache-timing attacks on AES. (2005). http://cr.yp.to/
antiforgery/cachetiming-20050414.pdf.
[13] Daniel J. Bernstein. 2006. Curve25519: New Diffie-Hellman Speed Records. In
PKC 2006 (LNCS), Moti Yung, Yevgeniy Dodis, Aggelos Kiayias, and Tal Malkin
(Eds.), Vol. 3958. Springer, Heidelberg, 207–228.
[14] Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang.
2011. High-Speed High-Security Signatures. In CHES 2011 (LNCS), Bart Preneel
and Tsuyoshi Takagi (Eds.), Vol. 6917. Springer, Heidelberg, 124–142.
[15] Dan Berstein and Peter Schwabe. 2015. gfverif: fast and easy verification of
finite-field arithmetic. (2015). http://gfverif.cryptojedi.org/
[16] Karthikeyan Bhargavan, Antoine Delignat-Lavaud, Cédric Fournet, Catalin
Hritcu, Jonathan Protzenko, Tahina Ramananandro, Aseem Rastogi, Nikhil
Swamy, Peng Wang, Santiago Zanella Béguelin, and Jean Karim Zinzindohoué.
2017. Verified Low-Level Programming Embedded in F. CoRR abs/1703.00053
(2017). http://arxiv.org/abs/1703.00053
[17] Barry Bond, Chris Hawblitzel, Manos Kapritsos, K. Rustan M. Leino, Jacob R.
Lorch, Bryan Parno, Ashay Rane, Srinath Setty, and Laure Thompson. 2017. Vale:
Verifying High-Performance Cryptographic Assembly Code. In 26th USENIX
Security Symposium (USENIX Security 17). USENIX Association, Vancouver,
BC. https://www.usenix.org/conference/usenixsecurity17/technical-sessions/
presentation/bond
[18] Billy Bob Brumley, Manuel Barbosa, Dan Page, and Frederik Vercauteren. 2012.
Practical Realisation and Elimination of an ECC-Related Software Bug Attack.
In CT-RSA 2012 (LNCS), Orr Dunkelman (Ed.), Vol. 7178. Springer, Heidelberg,
171–186.
[19] Yu-Fang Chen, Chang-Hong Hsu, Hsin-Hung Lin, Peter Schwabe, Ming-Hsien
Tsai, Bow-Yaw Wang, Bo-Yin Yang, and Shang-Yi Yang. 2014. Verifying
Curve25519 Software. In ACM CCS 14, Gail-Joon Ahn, Moti Yung, and Ninghui
Li (Eds.). ACM Press, 299–309.
[20] Leonardo Mendonça de Moura and Nikolaj Bjørner. 2008. Z3: An Efficient SMT
Solver. In Tools and Algorithms for the Construction and Analysis of Systems,
14th International Conference, TACAS 2008, Held as Part of the Joint European
Conferences on Theory and Practice of Software, ETAPS 2008, Budapest, Hungary,
March 29-April 6, 2008. Proceedings (Lecture Notes in Computer Science), C. R.
Ramakrishnan and Jakob Rehof (Eds.), Vol. 4963. Springer, 337–340. https://doi.
org/10.1007/978-3-540-78800-3_24
[21] Vijay D’Silva, Mathias Payer, and Dawn Xiaodong Song. 2015. The Correctness-
Security Gap in Compiler Optimization. In 2015 IEEE Symposium on Security
and Privacy Workshops, SPW 2015, San Jose, CA, USA, May 21-22, 2015. IEEE
Computer Society, 73–87. https://doi.org/10.1109/SPW.2015.33
[22] Andres Erbsen, Jade Philipoom, Jason Gross, Robert Sloan, and Adam Chli-
pala. 2017. Systematic Synthesis of Elliptic Curve Cryptography Implemen-
tations.
(2017). https://people.csail.mit.edu/jgross/personal-website/papers/
2017-fiat-crypto-pldi-draft.pdf
[23] Shay Gueron and Vlad Krasnov. 2013. The fragility of AES-GCM authentication
algorithm. Cryptology ePrint Archive, Report 2013/157. (2013). http://eprint.
iacr.org/2013/157.
[24] Darrel Hankerson, Alfred Menezes, and Scott Vanstone. 2004. Guide to elliptic
curve cryptography. (2004).
Jacques-Henri Jourdan, François Pottier, and Xavier Leroy. 2012. Validating LR(1)
Parsers. In European Symposium on Programming (ESOP). Springer, 397–416.
[26] Thierry Kaufmann, Hervé Pelletier, Serge Vaudenay, and Karine Villegas.
2016. When Constant-Time Source Yields Variable-Time Binary: Exploiting
Curve25519-donna Built with MSVC 2015. In Cryptology and Network Security -
15th International Conference, CANS 2016, Milan, Italy, November 14-16, 2016, Pro-
ceedings (Lecture Notes in Computer Science), Sara Foresti and Giuseppe Persiano
(Eds.), Vol. 10052. 573–582. https://doi.org/10.1007/978-3-319-48965-0_36
[27] K. Rustan M. Leino. 2010. Dafny: An Automatic Program Verifier for Functional
Correctness. In Logic for Programming, Artificial Intelligence, and Reasoning -
16th International Conference, LPAR-16, Dakar, Senegal, April 25-May 1, 2010,
Revised Selected Papers (Lecture Notes in Computer Science), Edmund M. Clarke
and Andrei Voronkov (Eds.), Vol. 6355. Springer, 348–370. https://doi.org/10.
1007/978-3-642-17511-4_20
[28] Xavier Leroy. 2006. Formal certification of a compiler back-end, or: programming
a compiler with a proof assistant. In 33rd ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages, POPL 2006. ACM, 42–54.
[29] George C. Necula. Translation validation for an optimizing compiler. In ACM
[25]
sigplan notices (2000), Vol. 35. ACM, 83–94.
Session H4:  Formal VerificationCCS’17, October 30-November 3, 2017, Dallas, TX, USA1820[30] Aina Niemetz, Mathias Preiner, and Armin Biere. 2014 (published 2015). Boolector
2.0 system description. Journal on Satisfiability, Boolean Modeling and Computa-
tion 9 (2014 (published 2015)), 53–58.
[31] Adam Petcher and Greg Morrisett. 2015. The Foundational Cryptography Frame-
work. In Principles of Security and Trust - 4th International Conference, POST 2015,
Held as Part of the European Joint Conferences on Theory and Practice of Software,
ETAPS 2015, London, UK, April 11-18, 2015, Proceedings (Lecture Notes in Computer
Science), Riccardo Focardi and Andrew C. Myers (Eds.), Vol. 9036. Springer, 53–72.
https://doi.org/10.1007/978-3-662-46666-7_4
[32] Massimiliano Poletto and Vivek Sarkar. 1999. Linear scan register allocation. 21,
5 (1999), 895–913.
[33] Bruno Rodrigues, Fernando Magno Quintão Pereira, and Diego F. Aranha. 2016.
Sparse representation of implicit flows with applications to side-channel detec-
tion. In Proceedings of the 25th International Conference on Compiler Construc-
tion, CC 2016, Barcelona, Spain, March 12-18, 2016, Ayal Zaks and Manuel V.
Hermenegildo (Eds.). ACM, 110–120. https://doi.org/10.1145/2892208.2892230
[34] Katherine Ye, Matthew Green, Naphat Sanguansin, Lennart Beringer, Adam
Petcher, and Andrew W. Appel. 2017. Verified correctness and security of
mbedTLS HMAC-DRBG. In ACM CCS 2017.
Jean Karim Zinzindohoué, Karthikeyan Bhargavan, Jonathan Protzenko, and
Benjamin Beurdouche. 2017. HACL*: A Verified Modern Cryptographic Library.
IACR Cryptology ePrint Archive 2017 (2017), 536. http://eprint.iacr.org/2017/536
Jean Karim Zinzindohoué, Evmorfia-Iro Bartzia, and Karthikeyan Bhargavan.
2016. A Verified Extensible Library of Elliptic Curves. In IEEE 29th Computer
Security Foundations Symposium, CSF 2016, Lisbon, Portugal, June 27 - July 1, 2016.
IEEE Computer Society, 296–309. https://doi.org/10.1109/CSF.2016.28
[35]
[36]
A JASMIN SYNTAX REFERENCE
This section presents the concrete syntax of Jasmin source pro-
grams using BNF notation. Terminals are typeset in capital letters
or literally when no confusion should arise, non-terminals are sur-
rounded by angle brackets. Optional parts are written within square
brackets. Repeated parts are suffixed by an asterisk ∗ (not to be
confused with the terminal asterisk *).
Some rules (not shown) enable to concisely express common
patterns as non-empty sequences of elements (X) separated by
commas (⟨tuple1⟩ X), etc.
Types. Jasmin types are boolean, mathematical integers, bit-
vectors of some predetermined sizes, or arrays of such bit-vectors.
The sizes of these arrays are given through arbitrary expression
which must reduce to positive integers at compile-time.
⟨ptype⟩
| T_INT
⟨utype⟩ ⟨brackets⟨pexpr⟩⟩
::= T_BOOL
|
⟨utype⟩
⟨utype⟩
::= T_U8
|
T_U64
|
| T_U16
| T_U128
| T_U32
| T_U256
Expressions. Jasmin expressions are made of variables, array ac-
cesses, literal constants (booleans or mathematical integers), mem-
ory accesses, prefix unary operators, infix binary operators, and
function and primitive calls.
Operators include usual arithmetic, boolean and bit-wise oper-
ations. When relevant, arithmetic operators come with a signed
variant (with an ‘s’ suffix), which interpret their arguments as
signed integer.
The prefixed type in memory accesses corresponds to the type
of the value to fetch; it defaults to b64. The pointer expression is
made of a base (variable) and an offset (expression).
⟨pexpr⟩
⟨ident⟩
⟨var⟩
⟨prim⟩
⟨peop1⟩