第5章MySQL运维管理实践丨213
a3ee-a4badb1b4a00
Can't
for
NOT_FOUND;the
可以从错误日志
find
at position
Could not
cecor
---
## Page 236
214丨MySQL DBA工作笔记：数据库管理、架构优化与运维开发
作具有幂等性。
库和从库的信息都正确输入。
如果存在差别则会有 diffs 字段进行标示。
backend.sys_resource
达到目标然后深究。
grant insert,delete,update,select on backend.* to 'pt_checksum'@'10.127
而这个操作的原理其实就是 replace into。
如果确认无误，可以开始修复数据，借助 pt-table-sync 先把 SQL 输出不执行，把主
完成之后，在 percona 数据库下会就生成一个表，里面的数据就是一些对比的元数据，
11-29T17:45:34
这个过程持续的时间不长，
11-29T17:45:34
percona.checksums
我们使用如下命令开启 checksum 的检查：
checksum的过程其实很复杂，大体有下图 5-30所示的步骤，当然我们可以简化一下,
grant all on percona.* to 
切记要注意权限，
创建的临时数据库为 percona，
TS ERRORS DIFFS
EXPLAIN checksum chunk
Getnext chunkboundaries
DELETE old checksums fort
Startchecksu
Adjust-chunk-size
Check/create checksum table
Check slaves for replication filters
对于这个同步数据的用户要开通操作目标数据库的权限。
nectto
很快就能够执行完毕，修复之后再次做checksum 就完全正常了。
maste
C
mingtable
'pt_checksum'@'10.127.%.%' ;
也需要赋予相应的权限。
rtable
ROWS
ou-
D
C
图5-30
check-replication-filters-
CHUNKS SKIPPED
如果数据存在则会忽略，
9
Exit=nwarn/er/diffs els
105
Repeat from #5 while tables
Wait forchecksums toreplicate
Done
Wait for slaves to catch up
Adjust-chunk-size
SELECTchecksum chunk
SHOWWARNINGS
172
99
echecksummingtable
一
TIME TABLE
--replicate=
使得数据修复操
O
O
.%.%;
0.017
0.017
0.015
0.017
---
## Page 237
然，不知道该如何下手，或者给出的优化建议比较片面，那么我们可以先停下来夯实基础，
6.1
行解读，基本架构如下图6-1所示。
提高系统负载能力。
时间内的资源使用量，可以充分利用现有的软硬件资源，。
用性能差的 SQL 造成的。
少；相反，对于应用性能的优化却成为了重中之重。根据统计，80%的响应时间问题都应
未来的借鉴。
这个公式的最终产出就是 SQL优化的一个本质：缩短响应时间，提高资源利用率，
我们本小节会从优化基础、SQL 查询优化、优化技巧和优化器高级特性这几个方面进
MySQL 优化是一门手艺活，而查询优化是其中的重头戏，如果做优化的时候比较茫
减少S 是作为大部分调优的重中之重，也就是减少I/O；而增加V，也就是提高单位
T表示执行的时间，S表示需要的资源情况，V表示单位时间内的资源使用量。
关于SQL优化，有一个很经典的公式：
关系数据库发展到今天，并且随着云计算的普及，对于基础运维的需求有了显著的减
历史孕育了真理，他与时间抗衡，保存了人们的实践；他是往昔的见证，当今的教训，
这个公式的目标很明确；就是要减少T，所以可以通过减少S或者增加V来解决。
MySQL优化基础
数据类型优化
表关联优化
业务优化
索引优化
第6章
优化技巧
MySQL查询优化
SQL优化方法
图6-1
T=S/V
SQL查询优化
优化基础执行计划
profile
SQL解析
行值表达式
反连接
—《堂吉诃德》
---
## Page 238
216丨MySQL DBA工作笔记：数据库管理、架构优化与运维开发
也叫二级索引)，从存储的角度来说，
应的影响，比如唯一性索引、非唯一性索引、覆盖索引等都是辅助索引（secondary index,
存放的，我们叫做聚簇索引表或者索引组织表（IOT)，表中主键的参考依据如下：
我们在这里来简单分析一下为什么？
性索引潜在的数据陷阱。
且还高调的把索引名字命名为从 AI开头的名字，其实对于 MySQL 来说也不遥远了。
除了要掌握索引的一些基础原理，还需要理解索引设计的本质，那就是以空间换时间。
SQL优化，其实索引是一种催化剂；或者更确切一些说，索引仅仅是一种优化工具，我们
的不同。本小节主要想表述的内容是：对于
在此，我们不会花大篇幅的内容去讲每种索引
些额外的索引，比如全文索引，函数索引等
方面做一些改进和补充。
对于SQL查询优化，其实很多都是在辅助索引
两个体系的，主键的性能相对来说最好的；而
图6-2所示。
6.1.1
展开。
够知己知彼，我们接下来会按照索引、SQL 解析、执行计划、SQL Profile 这几个知识点
哪些工作，并能够定位基本的性能问题，熟悉了SQL之后，我们处理 SQL 优化问题才能
了解索引的基本原理，熟悉 SQL 的解析过程，能够读懂执行计划，熟悉优化器层面在做
这些基础其实就是对于 SQL 的理解，SQL 的执行效率必然离不开索引的辅助，我们需要
除了规范，从存储方式上来说，在 InnoDB 存储引擎中，表都是按照主键的顺序进行
在这个基本分类之上，我们可以引申出一
从右图我们可以看到，主键和辅助索引是
从以上可以看到，MySQL 对于主键有一套维护机制，而一些常见的索引也会产生相
（1）显式的创建主键 Primary key。
在学习MySQL 开发规范之索引规范的时候，强调过一个要点：每张表都建议有主键
在这方面，Oracle 19c 已经走在了优化的前沿，它们推出了新特性：自动化索引，而
对于索引的分类，主要从两个维度来进行区分：主键索引和辅助索引，具体分类如下
（3）如果都不符合上述条件，则会生成UUID的一个隐式主键（6字节大）。
（2）判断表中是否有非空唯一索引，如果有，则为主键。
1．MySQL主键隐患问题
MySQL索引I解析
二级索引列中默认包含主键列，如果主键太长，也
索引分类
图6-2
辅助索引
主键
覆盖索引
复合索引
普通索引
---
## Page 239
来说，是使用B+树的方式，我们对两种存储方式做下分析。
结构。
们从B+树开始吧，这是索引存储设计的切入点。
水单号，它都有一定的业务属性在里面，对于我们去理解业务的使用是一种不错的借鉴。
一个不错的例子，把证号分成了几个区段，偏于检索和维护；或者是外出就餐时得到的流
一定是从1开始的整数类型，我们需要结合业务场景来看待，比如我们的身份证其实就是
用的方式就存在了偏差。
属性，添加一系列的唯一性索引，非唯一性索引等等，这样一来我们坚持的规范和业务使
唯一性，但是业务开发无法直接根据主键自增列来进行查询，于是他们需要寻找新的业务
列，但是大多数情况下，这种自增列却没有实际的业务含义，尽管是主键列保证了ID 的
向持续改造的一个过程，将技术价值和业务价值结合起来。我看到很多业务中设置了自增
会使得二级索引很占空间。
对于数据库和文件系统中,大量使用了平衡二叉树（B 树)来实现索引,而对于 MySQL
从另外一个维度来说，我们对于主键的理解是有偏差的，我们不能单一的认为主键就
，这就引出行业里非常普遍的主键性能问题，这不是一个单一的问题，需要MySQL方
刚刚说了下主键的一些基本观点，本质上我们还是需要了解一下索引的基本原理，我
如下图6-4是B+树的存储方式。
如下图6-3是B树的存储方式。
对于数据库的设计来说，如何高效地查询数据是关键，所以我们需要熟悉索引的存储
2.了解一下B+树
图6-4
图6-3
6810
1112
第6章MySQL查询优化丨217
---
## Page 240
218丨MySQLDBA工作笔记：数据库管理、架构优化与运维开发
个地方可能被大家忽略了。
通过这3个列能够定位到具体1行的数据，但是在实际中却发现这个唯一性索引还是有一
个例子说明下。
一些基础概念之外，其实这很容易陷入一个索引陷阱：产生大量的余数据，我们来举一
这种消耗也是可以平衡的。
重复出现，所以从存储空间上，B+树相比B 树会有额外的空间开销，但相比于性能来说，
能是来自于多个部门抽调。虚拟小组之间可以自由沟通，不会存在太多的部门规约的限制。
有些公司为了提高工作效率，弱化“部门墙”问题，会有一些产品研发的虚拟小组，组员可
多，而对于B 树来说，就需要做局部的中序遍历，可能会跨层访问。同样可以举一个例子，
一定只查出一条，如果是多条，因为数据都在叶子节点，而且是有序的，处理起来会容易的
一些，B+树的管理方式也是类似。
个例子来解释，现在很多公司提倡扁平化管理，彼此之间都是平行的，开展工作也会方便
但是也做一些具体事务。
些程序员，他平时也会参与一些关键任务的开发工作，虽然从组织架构上他属于管理层
上。这个可以通过生活中的例子来类比，比如某公司里面有一个开发小组，组长管理着一
有一个表里存在一个唯一性索引，这个索引包含3个列，这个唯一性索引的意义就是
（4）从存储的角度来考虑，因为 B+树的键不只在叶子节点，还可能在非叶子节点中
－（3）B+树的叶子节点是跟后续节点连接的，形成了一个链表，我们查询数据的时候，不
（2）B 树查询效率与在B树的存储位置有关，而B+树是相对稳定的。同样可以用一
> select count(*)from test_base_data;
) ENGINE=InnoDB DEFAULT CHARSET=utf8
我们先来看看数据的情况，如下。
表里的数据量在300万左右，如下所示：
对于很多业务同学来说，认为建立唯一性索引和主键没有什么差别，除了我们知道的
3．数据陷阱：唯一性索引产生的冗余数据
（1）B 树的键值不会出现多次，而 B+树却不同，键值对应的具体数据都在叶子节点
CREATE TABLE ‘test base data`
我们来做下对比和分析：
count(*）
UNIQUE
3818630
appkey`
idx
varchar(64) DEFAULT NULL,
Varchar（50）DEFAULT NULL COMMENT‘时区',
date
ime
servertime`,`appkey`)
'servertime_appkey_timezone
---
## Page 241
数据，为什么唯一性索引就查不出来呢。
13:15:00
让我惊呆了。
的错误，如下。
>select count (1) from ccb_realtime_base_data where servertime ='2017-05-09 
 > alter table test_base_data add primary key ^servertime_appkey_timezone
我们删除原来的索引，创建一个新的唯一性索引，基于列（id，name）。
   :) 
再插入1行数据，毫无疑问会抛出如下错误。
insert into unique_test values(1,'aa');
插入1行数据。
alter table unique_test add unique key(id);
添加唯一性约束。
create table unique_test(id int,name varchar(30))
首先，我创建一个简单的表 unique_test。
我们来做一个测试来进行说明。
这一行记录，在这个表里竟然有重复数据700多条，也就意味着表里存在大量的冗余
单纯这样看，看不出什么问题来，但是当我通过count来得到重复数据的时候，着实
> select servertime,appkey,timezone from ccb_realtime_base_data limit 5;
insert into unique_test values(1,'aa');
数据按照 appkey 1461048746259 来过滤，得到的一个基本情况，如下：
ERROR
于是我尝试删除已有的唯一性索引，转而创建主键，操作过程中竟然抛出了数据冲突
我在分析时候，
count(1)
2017-05-09
2017-05-09
2017-05-09
2017-05-09 20:25:00
 servertime
7091
time
and appkey='1461048746259';
一+
(23000)：
dde
20:30:00
19:00:00
13:15:00
，和业务方进行确认，这个唯一性索引其实是可以重建为主键的。
Iappkey
: Duplicate entry '2017-05-09 13:15:00-1461048746259-
1461048746259
1461048746259
1461048746259
1461048746259
|timezone|
NULL
NULL
NULL
NULL
NULL
第6章MySQL查询优化丨219
---
## Page 242
220丨MySQL DBA工作笔记：数据库管理、架构优化与运维开发
个完全对立的对象，尽管表现形式看上去相似，都是没有数据。
性，那就是not null。
一性索引和主键的一个差别，就是主键约束相较于唯一性约束来说，还有一个默认的属
mysql> select count(*)from unique_test where id=1;
（2）count处理的差异
（1）null和空串的处理方式差异
而这也就是 MySQL 中产生冗余数据的罪魁祸首。
mysql> select *from unique_test;
这个时候查看数据，发现已经存在了冗余数据。
问题在哪里呢？其实就在那个 null 的地方上，这是问题的症结，进一步来说，这个是
> select *from unique_test;
这个时候竟然校验不出来了，数据分布如下：
> insert into unique_test values(l,null);
一
比如下面的两条 SQL 的输出就会截然不同。
不同数据库中对于 null 和空串的处理方式也有所不同，在 MySQL 中 null 和空串是两
而 null 带给我们的疑惑还远不止于此，我列举如下三个方面：
-
而我们继续测试，
可见，唯一性约束生效了，然后我们做进一步测试：
插入新的数据。
row in set (0.00 sec)
count(*）
id