title:Forward-secure signatures in untrusted update environments: efficient
and generic constructions
author:Benoît Libert and
Jean-Jacques Quisquater and
Moti Yung
Forward-Secure Signatures in Untrusted Update
Environments: Efﬁcient and Generic Constructions
Benoˆıt Libert
UCL Crypto Group
Belgium
Jean-Jacques
Quisquater
UCL Crypto Group
Belgium
Moti Yung
Columbia University
USA
ABSTRACT
Forward-secure signatures (FSS) prevent forgeries for past
time periods when an attacker obtains full access to the
signer’s storage. To simplify the integration of these primi-
tives into standard security architectures, Boyen, Shacham,
Shen and Waters recently introduced the concept of forward-
secure signatures with untrusted updates where private keys
are additionally protected by a second factor (derived from
a password). Key updates can be made on encrypted ver-
sion of signing keys so that passwords only come into play
for signing messages.
The scheme put forth by Boyen et al. relies on bilinear
maps and does not require the random oracle. The latter
work also suggested the integration of untrusted updates
in the Bellare-Miner forward-secure signature and left open
the problem of endowing other existing FSS systems with
the same second factor protection.
This paper solves this problem by showing how to adapt
the very eﬃcient generic construction of Malkin, Micciancio
and Miner (MMM) to untrusted update environments. More
precisely, our modiﬁed construction - which does not use
random oracles either - obtains a forward-secure signature
with untrusted updates from any 2-party multi-signature in
the plain public key model. In combination with Bellare and
Neven’s multi-signatures, our generic method yields imple-
mentations based on standard assumptions such as RSA,
factoring or the hardness of computing discrete logarithms.
Like the original MMM scheme, it does not require to set a
bound on the number of time periods at key generation.
Categories and Subject Descriptors: E.3 [Data]: Data
Encryption – Public Key Cryptosystems
General Terms: Design, Security, Performance.
1.
INTRODUCTION
If not appropriately dealt with, key exposures are likely to
ruin the eﬀorts of the research community towards devising
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’07, October 29–November 2, 2007, Alexandria, Virginia, USA.
Copyright  2007  ACM  978-1-59593-703-2/07/0010. . .$5. 00.
more sophisticated and secure cryptographic systems. They
seem unavoidable in the modern age of ubiquitous comput-
ing with the ever-increasing use of mobile and unprotected
devices.
It is indeed generally much easier to break into
users’ private storage than to ﬁnd out their secret by actual
cryptanalytic techniques. Hence, it turns out that the only
way to cope with such a threat is to contain the damage
when private keys are exposed.
In the public key setting, the past recent years saw the
exploration of various techniques addressing the problem
by means of key evolving protocols where public keys re-
main ﬁxed throughout the lifetime of schemes whereas pri-
vate keys are updated at discrete time intervals. This line
of research was initiated by Anderson’s suggestion [3] of
forward-secure mechanisms that aim at preserving the se-
curity of past time periods after a private key theft. Sub-
sequently introduced key-insulated [15, 16] and intrusion-
resilient [23] security paradigms strive to protect communi-
cations not only preceding, but also following break-ins by
storing part of the key material in a separate device.
Anderson’s original ﬂavor of key evolving security was for-
malized by Bellare and Miner [4] who gave proper deﬁni-
tions of forward-secure signatures (FSS) and proposed two
constructions. The ﬁrst one was a generic method with log-
arithmic complexity in the number of periods built on any
signature. Their second scheme extended Fiat-Shamir sig-
natures [18] into a FSS scheme with signatures of constant
(i.e. independent of the lifetime of the scheme) size but lin-
ear cost in signature generation and veriﬁcation. This num-
ber theoretic method was improved by Abdalla-Reyzin [2]
and Itkis-Reyzin [22], the latter work notably achieving op-
timal signing and veriﬁcation at the expense of slower key
updates using Guillou-Quisquater signatures [20]. Kozlov
and Reyzin [26] ﬁnally showed another method with fast
updates and a great online/oﬄine eﬃciency. Meanwhile,
forward security was also considered in special kinds of sig-
nature schemes [1, 35]. On the other hand non-trivial re-
alizations of forward-secure public key encryption schemes
remained elusive until the work by Canetti, Halevi and Katz
[13] that was improved by Boneh, Boyen and Goh [10].
Among generic FSS schemes that start from any digital
signature, Anderson’s storage-demanding construction [3]
was improved by Krawczyk [25] into a scheme requiring con-
stant private storage (though the overall storage remained
linear). Using Merkle trees [29] in a suitable fashion, Malkin,
Micciancio and Miner [28] interestingly described another
system with an essentially unbounded number of time peri-
266ods: the maximal number of periods did not have to be set
at key generation and the complexity of their scheme was
rather (and moderately) depending on the number of past
periods. Besides, their technique (often called MMM) was
quite eﬃcient. Not only did it outperform previous generic
constructions, but it also beat number theoretic schemes in
at least one metric when implemented with similar param-
eters. A practical evaluation of the eﬃciency of all these
schemes can be found in [14].
Forward-secure signatures with untrusted updates. In
many existing software environments (such as GNU-PG or
S/MIME), private keys are additionally proctected by an ex-
tra secret which is possibly derived from a password. In or-
der to facilitate the integration of forward-secure primitives
into such existing software architectures, Boyen, Shacham,
Shen and Waters [12] suggested a new a forward-secure sig-
nature where private keys are additionally shielded by a sec-
ond factor. Their scheme allows for an automated update
procedure of encrypted keys: the user holding the second
factor does not have to intervene in operations where the
update algorithm is programmed to move forward in time a
blinded version of the key at the beginning of each period.
The second factor is only needed for signing messages as in
many typical implementations of digital signatures. Beyond
the usual forward security requirement, such a scheme pre-
vents an adversary just in possession of the encrypted key
to forge signatures for past, current and future periods.
The compatibility of key-evolving signatures with a sec-
ond factor protection surprisingly remained overlooked un-
til [12]. When FSS schemes are designed for very ﬁne time
granularities, it is handy to leave the implemented software
automatically carry out updates at pre-scheduled instants.
In realistic settings however, key management techniques
should take into account the possible weaknesses of the com-
puting environment. In particular, key-evolving signatures
should be endowed with a safeguard against maliciously con-
trolled computing platforms. Otherwise, adversaries may be
able to delay the clock of signers’ computers and thereby ob-
tain a key that should have been erased for instance.
While the usual model [4] of forward security captures one
aspect of exposures (i.e. the user’s storage), “untrusted up-
dates” introduced in [12] deal with a potential exposure of
the computing environment. In forward-secure signatures,
a second factor protection thus especially strengthens sig-
natures as evidence of the signer’s intentionality of actually
signing the message.
The concrete implementation of forward-secure signature
with untrusted updates (FSS-UU) suggested in [12] enjoys a
provable security in the standard model, as opposed to the
random oracle model [5]. It simultaneously oﬀers a very at-
tractive eﬃciency, notably featuring constant-size signatures
and at most log-squared complexity in other metrics. On
the other hand, it makes use of a very speciﬁc mathematical
setting consisting of groups equipped with a bilinear map-
ping (a.k.a. pairing) whose computation remains expensive
(from twice to four times as slow as RSA in currently most
optimized implementations). Boyen et al. [12] also showed
how to simply obtain untrusted updates in the Bellare-Miner
[4] factoring-based FSS scheme and the same key-blinding
method is easily seen to apply to the Abdalla-Reyzin sys-
tem [2] as well. Unfortunately, these methods both suﬀer
from linear complexities for signing and key generation and
directly applying the same idea to the Itkis-Reyzin scheme
[22] removes its attractive performance advantages. The au-
thors of [12] left open the problem of eﬃciently achieving un-
trusted updates in other existing forward-secure signatures.
Our contribution. We describe generic forward-secure sig-
natures with untrusted updates. We ﬁrst show that un-
trusted updates can be simply obtained from any traditional
forward-secure signature. The idea is merely to sign a mes-
sage twice: once using a classical FSS scheme and a second
time using a regular (i.e. non forward-secure) digital sig-
nature, the private key of which is re-derived from a sec-
ond factor at each signing operation instead of being stored.
While very simple, this method induces a deﬁnite overhead
and we will of course be after more eﬃcient constructions.
Extending the above idea a little further, we construct
FSS-UU schemes from bipartite multi-signatures [21]. Re-
call that these primitives are meant to allow several sign-
ers to jointly sign a common message. We start from any
2-party such signature satisfying appropriate security deﬁ-
nitions and see it as a FSS-UU scheme with a single time
period. We then show how to bootstrap it by applying the
sum and product compositions of Malkin et al. [28] so as to
obtain FSS-UU schemes with more periods.
More precisely, when applied to a secure bipartite multi-
signature in Boldyreva’s model [9], the iterated sum compo-
sition of [28] provides a FSS-UU system with logarithmic-
size signatures. The basic idea of this construction is to ap-
ply the key updating technique of the sum composition to
only one of the two parties in the multi-signature and keep
the second key unchanged as a function of the second factor
throughout all periods. We also suggest eﬃciency tradeoﬀs
that can be obtained by combining this modiﬁed sum com-
position with non-generic FSS-UU schemes built on [4, 2].
In a second step, we show how to beneﬁt from the full
power of the MMM construction if we start from a secure 2-
party signature in the plain public key model of Bellare and
Neven [7]. By adapting the sum-product composition of [28],
we interestingly obtain a generic construction of forward-
secure signature with untrusted updates for a practically un-
bounded number of periods. When combined with recently
suggested [7] multi-signatures built on Schnorr [34], Guillou-
Quisquater [20], Fiat-Shamir [18] or Ong-Schnorr [31], our
construction provides pairing-free schemes based on discrete
logarithm, RSA and factoring that enjoy the same eﬃciency
as traditional FSS signatures resulting from [28]. These con-
crete instantiations rely on the random oracle methodology
[5] only because underlying signatures do: our extension
of MMM does not introduce additional random oracle as-
sumptions. Hence, standard model multi-signatures ﬁtting
the plain public key model of [7] would thus give rise to
new FSS-UU schemes without random oracles. This yields
answers to the open question, raised in [12], of how to eﬃ-
ciently provide existing forward-secure signatures with the
untrusted update property.
In the forthcoming sections, we ﬁrst recall deﬁnitions and
security notions for FSS-UU schemes in section 2. The
generic method for obtaining untrusted updates in any FSS
scheme in detailed in section 3 and section 4 describes our
eﬃcient extension of the MMM method.
2. DEFINTIONS
A forward-secure signature scheme with untrusted up-
dates (FSS-UU) is made of the following algorithms.
Keygen(λ, r, T ): on input of a security parameter λ, a ran-
dom tape r and a number of time periods T , this ran-
domized algorithm returns a public key PK, the initial
encrypted signing key EncSK0 and a random second
factor secret decryption key DecK. The initial period
number is set to 0.
CheckKey(t, T, EncSKt, PK): is an algorithm used to check
the well-formedness of the private key EncSKt at pe-
riod t. The output is (cid:2) if the latter was correctly
generated and ⊥ otherwise.
Update(t, T, EncSKt, PK): given a period number t and the
corresponding encrypted key EncSKt, this algorithm
returns an encrypted key EncSKt+1 for the next period
and erases EncSKt. It does not need the second factor
decryption key.
Sign(t, T, EncSKt, DecK, M, PK): takes as input a message
M , a period number t, the matching encrypted key
EncSKt and the second factor decryption key DecK. It
returns a signature σ. The period number t is part of
the latter.
Verify(t, T, PK, M, σ): takes as input the public key PK, a
period number t and a message M bearing an alleged
signature σ. It outputs (cid:2) if the signature is correct
and ⊥ otherwise.
In these syntactic deﬁnitions, the validity test CheckKey
aims at completely validating a newly generated encrypted
key before erasing the old key. In practice, a check of EncSK
by the signing algorithm suﬃces and an additional validity
test at each update should only be performed at the signer’s
discretion to make sure that the signing process will not be
disrupted in the new period.
The obvious completeness requirement imposes that prop-
erly generated signatures are always accepted by the veriﬁ-
cation algorithm.
The security model of [12] considers two orthogonal deﬁ-
nitions that are both inspired from the well-known concept
of chosen-message security [19]. The ﬁrst one considers a
game extending the usual notion of forward security as de-
ﬁned by Bellare-Miner [4]. In the game that the adversary
plays against her challenger, she should be unable to forge
a signature pertaining to an unexposed stage even knowing
the second factor decryption key DecK.
Definition 1. The forward security notion captures the
negligible advantage of any PPT adversary in this game.
1. The challenger runs the key generation algorithm and
gives the public key PK and the second factor decryp-
tion key DecK to the forger F. The initial period num-
ber t is set to 0.
2. F adaptively interacts with the following oracles.
· Sign : at any time, the forger can ask for a sig-
nature on an arbitrary message M for the current
time period t.
· Update : once she decides to move forward in
time, the adversary queries the challenger that
runs the update algorithm and increments the pe-
riod number t.
· Break-in : at some period, the forger enters the
break-in phase and requests the challenger to re-
veal the current encrypted signing key EncSKt.
3. F comes up with a message M (cid:2) and a signature σ(cid:2)
for some period t(cid:2). If t(cid:2)
denotes the time period where
the break-in query was made, F is declared successful
provided Verify(t(cid:2), T, PK, M (cid:2), σ(cid:2)) = 1, t(cid:2) < t(cid:2)