ement that may contain any data.
?
?
?
?
*
*
*
Figure 3: SAML assertion structure.
3.2 XML Schema
The W3C recommendation XML Schema [36] is a lan-
guage to describe the layout, semantics, and content of
an XML document. A document is deemed to be valid,
when it conforms to a speciﬁc schema. A schema con-
sists of a content model, a vocabulary, and the used data
types. The content model describes the document struc-
ture and the relationship of the items. The standard pro-
vides 19 primitive data types to deﬁne the allowed con-
tent of the elements and attributes.
Regarding to our evaluation of SAML based XML
Signature Wrapping attacks there is one important el-
ement deﬁnition in XML Schema. The any element
allows the usage of any well-formed XML document
in a declared content type. When an XML processor
validates an element deﬁned by an any element, the
processContents attribute speciﬁes the level of ﬂex-
ibility. The value lax instructs the schema validator to
check against the given namespace. If no schema infor-
mation is available, the content is considered valid. In the
case of processContents="skip" the XML processor
does not validate the element at all.
3.3 SAML
SAML is an XML standard for exchanging authentica-
tion and authorization statements about Subjects [11].
Several proﬁles are deﬁned in [10]. The most important
proﬁle is the Browser SSO proﬁle, which deﬁnes how to
use SAML with a web browser.
A SAML assertion has the structure described in Fig-
ure 3. The issuing time of the assertion is speciﬁed in
saml:IssueInstant. All attributes are required.
The saml:Issuer element speciﬁes the SAML au-
thority (the IdP) that is making the claim(s) in the asser-
tion. The assertion’s saml:Subject deﬁnes the princi-
pal about whom all statements within the assertion are
made. The saml:*Statement elements are used to
specify user-deﬁned statements relevant for the context
of the SAML assertion.
To protect the integrity of the security claims made
by the Issuer, the whole saml:Assertion element must
be protected with a digital signature following the XML
Figure 4: SAML message examples (SOAP and REST):
The SAML assertion is put into a root element R and
signed using an enveloped signature. When signing the
SOAP body, an additional detached signature is used.
Signature standard. Therefore,
the SAML speciﬁca-
tion [11] requires that either the saml:Assertion ele-
ment or an ancestor element must be referenced by the
Signature element, with an enveloped XML Signature
([11], Section 5.4.1). Furthermore, Id-based referencing
must be used ([11], Section 5.4.2), which opens the way
for XSW attacks.
In REST based frameworks, the SAML assertion is
typically put into an enveloping Response element.
Frameworks applying SOAP insert the SAML assertions
into the SOAP header (or the Security element in-
side of the SOAP header). For clariﬁcation purposes,
consider that the SAML assertions are signed using en-
veloped XML Signatures and are put into some binding
root element R (see Figure 4).
3.4 XML Signature Wrapping Attacks
XML documents containing XML Signatures are typi-
cally processed in two independent steps: signature val-
idation and function invocation (business logic). If both
modules have different views on the data, a new class of
vulnerabilities named XML Signature Wrapping attacks
(XSW) [27, 23] exists.
In these attacks the adversary
modiﬁes the message structure by injecting forged ele-
ments which do not invalidate the XML Signature. The
goal of this alteration is to change the message in such
a way that the application logic and the signature veriﬁ-
cation module use different parts of the message. Con-
sequently, the receiver veriﬁes the XML Signature suc-
cessfully but the application logic processes the bogus
element. The attacker thus circumvents the integrity pro-
tection and the origin authentication of the XML Signa-
ture and can inject arbitrary content. Figure 5 shows a
simple XSW attack on a SOAP message.
XSW attacks resemble other classes of injection at-
tacks like XSS or SQLi: in all cases, the attacker tries to
force different views on the data in security modules (e.g.
Web Application Firewalls) and data processing modules
(HTML parser, SQL engine).
SignedProcessedEnvelopeAssertionHeaderID=“123“SignatureSignedInfoReferenceURI=“#123“ResponseAssertionSignatureSignedInfoReferenceURI=“#123“ID=“123“BodyBinding root element RFigure 5: A simple XML Signature wrapping attack: The
attacker moves the original signed content to a newly cre-
ated Wrapper element. Afterwards, he creates an arbi-
trary content with a different Id, which is invoked by the
business logic.
4 XSW Attacks on SAML
In this section we ﬁrst characterize the assumed threat
model. Second, we describe the basic attack principle
that underlies our analysis of the 14 frameworks.3
4.1 Threat Model
As a prerequisite the attacker requires an arbitrary signed
SAML message. This could be a single assertion A or a
whole document D with an embedded assertion, and its
lifetime can be expired. After obtaining such a message,
the attacker modiﬁes it by injecting evil content, e.g. an
evil assertion EA. In our model we assume two differ-
ent types of adversaries, which are both weaker than the
classical network based attacker:
1. Advacc. To obtain an assertion, this attacker regis-
ters as a user of an Identity Provider IdP. Advacc
then receives, through normal interaction with IdP,
a valid signed SAML assertion A (probably as a
part of a larger document D) making claims about
Advacc. The attacker now adds additional claims EA
about any other subject S, and submits the modiﬁed
document D(cid:48) (A(cid:48)) to RP.
2. Advintc. This adversary retrieves SAML assertions
from the Internet, but he does not have the abil-
ity to read encrypted network trafﬁc. This can
be done either by accessing transmitted data di-
rectly from unprotected networks (snifﬁng), or in
an ”ofﬂine” manner by analyzing proxy or browser
caches. Since SAML assertions should be worthless
once their lifetime expired, they may even be posted
3Please note that from now on we distinguish between the document
D and the root element R. This is to make clear the distinction between
the element referenced by the XML signature, and the document root:
Even if the root element R of the original document D is signed, we
may transform this into a new document D(cid:48) with a new evil root ER,
without invalidating the signature.
Figure 6: Types of signature applications on SAML as-
sertions on the left. The new malicious content needed
to execute the attacks depicted on the right, accordingly.
in technical discussion boards, where Advintcmay
access them.
4.2 Basic Attack Principle
As described in the previous section, XML Signatures
can be applied to SAML assertions in different ways and
placed in different elements. The only prerequisite is that
the Assertion element or the protocol binding element
(ancestor of Assertion) is signed using an enveloped
signature with Id-based referencing. In this section we
analyze the usage of SAML assertions in different frame-
works and the possibilities of inserting malicious con-
tent. Generally, SAML assertions and their signatures
are implemented as depicted in Figure 6:
1. The ﬁrst possible usage of signatures in SAML as-
sertions is to insert the XML Signature S1 as a
child of the SAML assertion A1 and sign only the
Assertion element A1. This type can be used in-
dependently of the underlying protocol (SOAP or
REST).
2. The second type of signature application in SAML
signs the whole protocol binding element R. The
XML Signature can be placed into the SAML asser-
tion A1 or directly into the protocol binding root ele-
ment R. This kind of signature application is used in
different SAML HTTP bindings, where the whole
Response element is signed.
3. It is also possible to use more than one XML Sig-
nature. The third example shows this kind of signa-
ture application: the inner signature S1 protects the
SAML assertion and the outer signature S addition-
ally secures the whole protocol message. This kind
of signature application is e.g. used by the Simple-
SAMLphp framework.
In order to apply XSW attacks to SAML assertions,
the basic attack idea stays the same: The attacker has
SignedProcessedEnvelopeWrapperHeaderID=“123“SignatureSignedInfoReferenceURI=“#123“BodyBodyCreateKeyPairMonitorInstancesID=“attack“A1S1EAA1S1REREAA1SRS1EREALegitimate contentInjected evil contentSignedProcessedSigning Type 1)Signing Type 2)Signing Type 3)to create new malicious elements and force the assertion
logic to process them, whereas the signature veriﬁcation
logic veriﬁes the integrity and authenticity of the original
content. In applications of the ﬁrst signature type, the
attacker only has to create a new evil assertion EA. In the
second and third signing types, he also has to create the
whole evil root ER element including the evil assertion.
4.3 Attack Permutations
The attacker has many different possibilities where to in-
sert the malicious and the original content. To this end,
he has to deal with these questions:
sertion logic?
• At which level in the XML message tree should the
malicious content and the original signed data be
included?
• Which Assertion element is processed by the as-
• Which element is used for signature veriﬁcation?
By answering these questions we can deﬁne different
attack patterns, where the original and the malicious el-
ements can be permuted (Figure 7). We thus get a com-
plete list of attack vectors, which served as a guideline
for our investigations.
For the following explanations we only consider sign-
ing type 1) deﬁned in Figure 6. In this signing type only
the Assertion element is referenced.
The attack permutations are depicted in Figure 7. In
addition, we analyze their SAML standard conformance
and the signature validity:
1. Malicious assertion, original assertion, and signa-
ture are left on the same message level: This kind of
XML message can have six permutations. None of
them is SAML standard compliant, since the XML
Signature does not sign its parent element. The di-
gest value over the signed elements in all the mes-
sages can be correctly validated. We can use this
type of attack messages if the server does not check
the SAML conformance.
2. All the three elements are inserted at different mes-
sage levels, as child elements of each other, which
again results in six permutations: Messages 2-a and
2-b show examples of SAML standard conform-
ing and cryptographically valid messages. In both
cases the signature element references its parent –
the original assertion A1. Message 2-c illustrates a
message which is not SAML standard conform as
the signature signs its child element. Nevertheless,
the message is cryptographically valid. Lastly, mes-
sage 2-d shows an example of an invalid message
since the signature would be veriﬁed over both as-
sertions. Generally, if the signature is inserted as the
Figure 7: Possible variants for XSW attacks applied on
messages with one signed SAML assertion divided ac-
cording to the insertion depth of the evil assertion EA,
the original assertion A1 and the signature S1. The var-
ious permutations are labeled according to their validity
and SAML-conformance.
child of the root element, the message would also be
either invalid or not SAML standard compliant.
3. For the insertion of these three elements we use two
message levels: Message 3-a shows an example of
a valid and SAML compliant document. By con-
structing message 3-b, the signature element was
moved to the new malicious assertion. Since it ref-
erences the original element, it is still valid, but does
not conform to the SAML standard.
The analysis shown above can similarly be applied to
messages with different signing types (see Figure 6).
5 Practical Evaluation
We evaluated the above deﬁned attacks on real-world
systems and frameworks introduced in Section 2. In this
section we present the results.
5.1 Signature Exclusion Attacks
We start the presentation of our results with the simplest
attack type called Signature exclusion attack. This at-
tack relies on poor implementation of a server’s security
logic, which checks the signature validity only if the sig-
nature is included. If the security logic does not ﬁnd the
Signature element, it simply skips the validation step.
A1S1EARA1S1EARA1S1EAR2) Three Levels (6 Permutations)3) Two Levels (12 Permutations)A1S1EARA1S1EARA1S1EARA1S1EAR1) One Level (6 Permutations)SignedProcessedSignature Invalidnot SAML-conforma)b)c)d)a)b)EAS1A1REAS1A1Rc)EAS1A1Rd)SAML-conformFigure 8: XML tree-based illustration of reﬁned XSW attacks found in Type 1 signature applications.
The evaluation showed that three SAML-based frame-
works were vulnerable to these attacks: Apache Axis2
Web Services Framework, JOSSO, and the Java-based
implementation of SAML 2.0 in Eduserv (other versions
of SAML and the C-implementation in Eduserv were not
affected).
By applying this attack on JOSSO and Eduserv the at-
tacker had to remove the Signature element from the
message, since if it was found, the framework tried to
validate it. On the other hand, the Apache Axis2 frame-
work did not validate the Signature element over the
SAML assertion at all, even if it was included in the mes-
sage. Apache Axis2 validated only the signature over the
SOAP body and the Timestamp element. The signature
protecting the SAML assertion, which is included sep-
arately in the Assertion element, was completely ig-
nored.
5.2 Reﬁned Signature Wrapping
Ten out of 14 systems were prone to reﬁned XSW at-
tacks.
Classiﬁed on the three different signature application
types given in Figure 6, ﬁve SAML-based systems failed
in validating Type 1 messages, where only the asser-
tion is protected by an XML Signature. Figure 8 depicts
the XML tree-based illustration of the found XSW vari-
ants. Starting from left to right, Higgins, Apache Axis2,
and the IBM XS 40 Security Gateway were outfoxed
by the two depicted permutations.
In the ﬁrst variant
it was sufﬁcient to inject an evil assertion with a dif-
ferent Id attribute in front of the original assertion. As
the SAML standard allows to have multiple assertions in
one protocol element, the XML Schema validation still
succeeded. The second attack type embedded the orig-
inal assertion as a child element into the evil assertion
EA. In both cases the XML Signature was still standard
conform, as enveloped signatures were applied. This
was broken in the case of OIOSAML by using detached
signatures. In this variant the original Signature ele-
ment was moved into the EA, which was inserted be-
fore the legitimate assertion. The last shown permuta-
tion was applicable to the cloud services of Salesforce
Figure 9: XML tree-based illustration of reﬁned XSW
attacks found in Type 2 signature applications.
and the OpenAM framework. At this, the genuine asser-
tion was placed into the original Signature element. As
both implementations apply XML Schema for validating
the schema conformance of a SAML message, this was
done by injecting them into the Object element, which
allows arbitrary content. Again, this is not compliant
to the SAML standard because this mutation transforms
the enveloped to an enveloping signature. Finally, the
OneLogin Toolkits were prone to all shown attack vari-
ants as they did not apply XML Schema, validated the
XML Signature independent of it’s semantic occurrence
and used a ﬁxed reference to the processed SAML claims
(/samlp:Response/saml:Assertion[1]).
We found three susceptible implementations, which
applied Type 2 messages, where the whole message is
protected by an XML Signature. We depict the attacks
on these implementations in Figure 9.
In the Guanxi
and JOSSO implementations the legitimate root element
was inserted into the Object element in the original
Signature. The Signature node was moved into the
ER element which also included the new evil assertion.
In the case of WSO2, it was sufﬁcient to place the orig-
inal root element into the ER object. Naturally, some-
one would expect that enforcing full document signing
would eliminate XSW completely. The both given ex-
amples demonstrate that this does not hold in practice.
Again, this highlights the vigilance required when im-
plementing complex standards such as SAML.
Finally, we did not ﬁnd vulnerable frameworks that
applied Type 3 messages, where both the root and the as-
RootAssertionID=“evil“AssertionID=“123“SignatureSignedInfoReferenceURI=“#123“RootAssertionID=“evil“AssertionID=“123“SignatureSignedInfoReferenceURI=“#123“RootAssertionID=“evil“AssertionID=“123“SignatureSignedInfoReferenceURI=“#123“SignedProcessedRootAssertionID=“evil“AssertionID=“123“SignatureSignedInfoReferenceURI=“#123“OIOSAMLHiggins, Apache Axis2, IBM XS 40 Security GatewayOpenAM, SalesforceRootAssertionRootID=“123“SignatureSignedInfoReferenceURI=“#123“ID=“evil“AssertionRootAssertionRootID=“123“SignatureSignedInfoReferenceURI=“#123“ID=“evil“AssertionGuanxi, JOSSOWSO2sertion are protected by different signatures. Indeed, one
legitimate reason is, that most SAML implementations
do not use Type 3 messages. In our practical evaluation,
only SimpleSAMLphp applied them by default. Never-
theless, this does not mean that XSW is not applicable to
this message type in practice.
5.3 OpenSAML Vulnerability
The attack vectors described above did not work against
the prevalently deployed OpenSAML library. The reason