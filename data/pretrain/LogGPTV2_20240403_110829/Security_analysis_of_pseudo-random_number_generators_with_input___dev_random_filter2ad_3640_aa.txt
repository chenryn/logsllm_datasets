title:Security analysis of pseudo-random number generators with input: /dev/random
is not robust
author:Yevgeniy Dodis and
David Pointcheval and
Sylvain Ruhault and
Damien Vergnaud and
Daniel Wichs
Security Analysis of Pseudo-Random Number Generators
with Input: /dev/random is not Robust ∗
Yevgeniy Dodis
Dept. of Computer Science
New York University
David Pointcheval
DI/ENS
ENS-CNRS-INRIA
Sylvain Ruhault
DI/ENS
ENS-CNRS-INRIA
and Oppida, France
Damien Vergnaud
DI/ENS
ENS-CNRS-INRIA
Daniel Wichs
Dept. of Computer Science
Northeastern University
ABSTRACT
A pseudo-random number generator (PRNG) is a determin-
istic algorithm that produces numbers whose distribution
is indistinguishable from uniform. A formal security model
for PRNGs with input was proposed in 2005 by Barak and
Halevi (BH). This model involves an internal state that is re-
freshed with a (potentially biased) external random source,
and a cryptographic function that outputs random numbers
from the continually internal state. In this work we extend
the BH model to also include a new security property captur-
ing how it should accumulate the entropy of the input data
into the internal state after state compromise. This prop-
erty states that a good PRNG should be able to eventually
recover from compromise even if the entropy is injected into
the system at a very slow pace, and expresses the real-life
expected behavior of existing PRNG designs.
Unfortunately, we show that neither the model nor the
speciﬁc PRNG construction proposed by BH meet this new
property, despite meeting a weaker robustness notion intro-
duced by BH. From a practical side, we give a precise assess-
ment of the Linux PRNGs, /dev/random and /dev/urandom.
In particular, we show attacks proving that these PRNGs
are not robust according to our deﬁnition, due to vulnera-
bilities in their entropy estimator and their internal mixing
function. Finally, we propose a simple PRNG construction
that is provably robust in our new and stronger adversarial
model and we show that it is more eﬃcient than the Linux
PRNGs. We therefore recommend to use this construction
whenever a PRNG with input is used for cryptography.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—
Cryptographic controls; G.3 [Mathematics of Comput-
∗A full version of this paper is available at Cryptology ePrint
Archive, Report 2013/338
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516653.
ing]: Probability and Statistics—Random number genera-
tion
Keywords
Randomness; Entropy; Security models; /dev/random
1.
INTRODUCTION
Generating random numbers is an essential task in cryp-
tography. Random numbers are necessary not only for gen-
erating cryptographic keys, but are also needed in steps
of cryptographic algorithms or protocols (e.g.
initializa-
tion vectors for symmetric encryption, password generation,
nonce generation,
. . . ). Cryptography practitioners usu-
ally assume that parties have access to perfect randomness.
However, quite often this assumption is not realizable in
practice and random bits in protocols are generated by a
Pseudo-Random Number Generator (PRNG). When this is
done, the security of the scheme depends of course in a cru-
cial way on the quality of the (pseudo-)randomness gen-
erated.
If a user has access to a truly random bit-string,
he can use a deterministic (or cryptographic) PRNG to ex-
pand this short seed into a longer sequence which distribu-
tion is indistinguishable from the uniform distribution to a
computationally-bounded adversary (which does not know
the seed). However, in many situations, it is unrealistic to
assume that users have access to secret and perfect random-
ness. In a PRNG with input, one only assumes that users
can store a secret internal state and have access to a (po-
tentially biased) random source.
In spite of being widely deployed in practice, PRNGs with
input were only formalized by Barak and Halevi in 2005 [1].
They proposed a security notion, called robustness, to cap-
ture the fact that the bits generated should look random to
an observer with (partial) knowledge of the internal state
and (partial) control of the entropy source. Combining the-
oretical and practical analysis of PRNGs with input, this pa-
per presents an extension of the Barak-Halevi security model
and analyses the Linux PRNGs /dev/random and /dev/u-
random.
Randomness weaknesses in cryptography. The lack of
insurance about the generated random numbers can cause
serious damages in cryptographic protocols, and vulnerabil-
ities can be exploited by attackers. One striking example is
the recent failure in the Debian Linux distribution [4], where
a commented code in the OpenSSL PRNG with input led
647to insuﬃcient entropy gathering and then to concrete at-
tacks on TLS and SSH protocols. More recently, Lenstra,
Hughes, Augier, Bos, Kleinjung and Wachter [15] showed
that a non-negligible percentage of RSA keys share prime
factors. Heninger, Durumeric, Wustrow and Halderman [9]
presented an analysis of the behavior of Linux PRNG that
explains the generation of low entropy keys when these keys
are generated at boot time. Moreover, cryptographic algo-
rithms are highly vulnerable to weaknesses in the underly-
ing random number generation process. For instance, sev-
eral works demonstrated that if nonces for DSS signature
algorithm are generated with a weak PRNG then the secret
key can be quickly recovered after seeing a few signatures
(see [16] and references therein). This illustrates the need
for precise evaluation of PRNGs based on clear security re-
quirements.
Security Models. Descriptions of PRNGs with input are
given in various standards [12, 10, 7]. They identiﬁed the
following core components: the entropy source which is the
source of randomness used by the generator to update an in-
ternal state which consists of all the parameters, variables,
and other stored values that the PRNG uses for its opera-
tions.
Several desirable security properties for PRNGs with in-
put have been identiﬁed in [10, 12, 7, 2]. These standards
consider adversaries with various means: those who have ac-
cess to the output of the generator; those who can (partially
or totally) control the source of the generator and those who
can (partially or totally) control the internal state of the gen-
erator (and combination of them). Several security notions
have been deﬁned:
• Resilience: an adversary must not be able to predict
future PRNG outputs even if he can inﬂuence the en-
tropy source used to initialize or refresh the internal
state of the PRNG;
• Forward security ( resp. backward security): an ad-
versary must not be able to predict past (resp. future)
outputs even if he can compromise the internal state
of the PRNG.
Desai, Hevia and Yin [5] modelled a PRNG as an iterative al-
gorithm and formalized the above security properties in this
context. Barak and Halevi [1] model a PRNG with input as
a pair of algorithms (refresh, next) and deﬁne a new security
property called robustness that implies resilience, forward
and backward security. This property actually assesses the
behavior of a PRNG after compromise of its internal state
and responds to the guidelines for developing PRNG given
by Kelsey, Schneier, Wagner and Hall [11].
Linux PRNG. In Unix-like operating systems, a PRNG
with input was implemented for the ﬁrst time for Linux
1.3.30 in 1994. The entropy source comes from device drivers
and other sources such as latencies between user-triggered
events (keystroke, disk I/O, mouse clicks, . . . ). It is gathered
into an internal state called the entropy pool. The internal
state keeps an estimate of the number of bits of entropy in
the internal state and (pseudo-)random bits are created from
the special ﬁles /dev/random and /dev/urandom. Barak and
Halevi [1] discussed brieﬂy the PRNG /dev/random but its
conformity with their robustness security deﬁnition is not
formally analyzed.
The ﬁrst security analysis of these PRNGs was given in
2006 by Gutterman, Pinkas and Reinman [8]. It was com-
pleted in 2012 by Lacharme, R¨ock, Strubel and Videau [14].
Gutterman et al. [8] presented an attack based on kernel ver-
sion 2.6.10 for which a ﬁx has been published in the following
versions. Lacharme et al. [14] gives a detailed description of
the operations of the PRNG and provides a result on the
entropy preservation property of the mixing function used
to refresh the internal state.
Our Contributions. From a theoretical side, we propose a
new formal security model for PRNGs with input, which en-
compasses all previous security notions [1]. This new prop-
erty captures how a PRNG with input should accumulate
the entropy of the input data into the internal state. This
property was not initially formalized in [1] but it actually
expresses the real-life expected behavior of a PRNG after
a state compromise, where it is expected that the PRNG
quickly recovers enough entropy.
On a practical side, we give a precise assessment of the two
Linux PRNGs, /dev/random and /dev/urandom. We prove
that these PRNGs are not robust and do not accumulate
entropy properly, due to the behavior of their entropy esti-
mator and their internal mixing function. We also analyze
the PRNG with input proposed by Barak and Halevi. This
scheme was proven robust in [1] but we prove that it does
not generically satisfy our expected property of entropy ac-
cumulation. On the positive side, we propose a PRNG con-
struction that is robust in the standard model and in our
new stronger adversarial model.
Finally, we perfome benchmarks between our construction
and the Linux PRNGs and we show that it is far more eﬃ-
cient than the Linux PRNGs for both internal state recovery
and key generation.
2. PRELIMINARIES
Probabilities. When X is a distribution, or a random vari-
able following this distribution, we denote x $← X when x
is sample according to X. We denote by M (X) the distri-
bution probability of the output of the Turing machine M ,
while running on the input x drawn according to X, and
with its random coins (if any). The notation X ← Y says
that X is assigned with the value of the variable Y , and
that X is a random variable with distribution equal to that
of Y . For a variable X and a set S (e.g., {0, 1}m for some
integer m), the notation X $← S denotes both assigning X a
value uniformly chosen from S and letting X be a uniform
random variable over S. The uniform distribution over n
bits is denoted Un.
Indistinguishability. Two distributions X and Y are said
(t, ε)-computationally indistinguishable, (CDt(X, Y ) ≤ ε),
if for any distinguisher A running within time t, Pr[A(X) =
1] − Pr[A(Y ) = 1] ≤ ε. When t = ∞, meaning A is un-
bounded, we say that X and Y are ε-close, and their statis-
tical distance is at most ε: SD(X, Y ) ≤ ε.
SD(X, Y |Z) ≤ ε (resp. CDt(X, Y |Z) ≤ ε) is a shorthand
for SD((X, Z), (Y, Z)) ≤ ε (resp. CDt((X, Z), (Y, Z)) ≤ ε.
Entropy. For a discrete distribution X over a set S, we
denote its min-entropy by
{− log Pr[X = x]}
H∞(X) = min
x∈Supp(X)
where Supp(X) ⊆ S is the support of the distribution X. A
distribution X is called a k-source if H∞(X) ≥ k. We also
deﬁne worst-case min-entropy of X conditioned on another
648random variable Z by:
H∞(X|Z) = − log
 max
x∈Supp(X),
z∈Supp(Z)
 (1)
Pr[X = x|Z = z]
It is worth noting that conditional min-entropy is deﬁned
more conservatively than usual, so that it satisﬁes the fol-
lowing relations (the ﬁrst of which, called the chain rule, is
not true for the “average-case” variant of conditional min-
entropy):
H∞(X, Z) − H∞(Z) ≥ H∞(X|Z)
≥ H∞(X, Z) − |Z| ≥ H∞(X) − |Z|
(2)
where |Z| is the bit-length of Z. Extractors. Let H =
{hX :
{0, 1}n → {0, 1}m}X∈{0,1}d be a hash function
family. We say that H is a (k, ε)-extractor if for any ran-
dom variable I over {0, 1}n with H∞(I) ≥ k, the distri-
butions (X, hX (I)) and (X, U ) are ε-close where X is uni-
formly random over {0, 1}d and U is uniformly random over
{0, 1}m. We say that H is ρ-universal if for any inputs
I (cid:54)= I(cid:48) ∈ {0, 1}n we have PrX∈{0,1}d [hX (I) (cid:54)= hX (I(cid:48))] ≤ ρ.
Lemma 1 (Leftover-Hash Lemma). Assume that H is ρ-
universal where ρ = (1 + α)2−m for some α > 0. Then, for
√