# 一、Docker 简介
在本章中，我们将做的第一件事是解释 Docker 及其架构背后的推理。我们将涵盖 Docker 概念，如映像、层和容器。接下来，我们将安装 Docker，并学习如何从`remote`注册表中提取一个示例、基本的 Java 应用映像，并在本地机器上运行。
Docker 是作为平台即服务公司 dotCloud 的内部工具而创建的。2013 年 3 月，以开源方式向公众发布。其源代码在 GitHub 上免费提供给所有人，网址为:[h](https://github.com/docker/docker)[t](https://github.com/docker/docker)[t](https://github.com/docker/docker)[p](https://github.com/docker/docker)[s](https://github.com/docker/docker)[://g](https://github.com/docker/docker)[I](https://github.com/docker/docker)t[h](https://github.com/docker/docker)[u](https://github.com/docker/docker)[b](https://github.com/docker/docker)[。](https://github.com/docker/docker)[c](https://github.com/docker/docker)[o](https://github.com/docker/docker)[m](https://github.com/docker/docker)[/d](https://github.com/docker/docker)T32】oT34】cT36】kT38】eT40】rT42】/dT44】oT46】cT48】k[e](https://github.com/docker/docker)T52】r。不仅仅是 Docker Inc .的核心团队致力于 Docker 的开发，还有很多大牌赞助他们的时间和精力来提升 Docker，为 Docker 做贡献，比如谷歌、微软、IBM、红帽、思科系统等等。Kubernetes 是一个由谷歌开发的工具，用于根据他们在博格(谷歌的自制容器系统)上学习到的最佳实践，在计算机集群之间部署容器。它补充了 Docker 在编排、自动化部署、管理和扩展容器方面的不足；它通过在集群中保持容器部署的平衡来管理 Docker 节点的工作负载。Kubernetes 还为容器提供了相互通信的方式，而不需要打开网络端口。Kubernetes 也是一个开源项目，在 GitHub 上以[h](https://github.com/kubernetes/kubernetes)T56】tT58t[p](https://github.com/kubernetes/kubernetes)T62】sT64】://gT66】IT68T70】hT72】uT74】bT76[c](https://github.com/kubernetes/kubernetes)[o](https://github.com/kubernetes/kubernetes)[m](https://github.com/kubernetes/kubernetes)[/k](https://github.com/kubernetes/kubernetes)[u](https://github.com/kubernetes/kubernetes)[b](https://github.com/kubernetes/kubernetes)T90】eT92】rT94】nT96】eT98】tT100】eT102】s[/每个人都可以贡献。让我们先从 Docker 开始我们的旅程。以下内容将在中介绍:](https://github.com/kubernetes/kubernetes)
*   我们将从这个出色工具背后的基本理念开始，并展示与传统虚拟化相比，使用它所获得的优势
*   我们将在三个主要平台上安装 Docker:macOS、Linux 和 Windows
# Docker 背后的想法
Docker 背后的想法是将一个应用及其所需的所有依赖项打包到一个单一的标准化部署单元中。这些依赖项可以是二进制文件、库、JAR 文件、配置文件、脚本等等。Docker 将所有这些打包成一个完整的文件系统，其中包含了您的 Java 应用运行虚拟机本身、应用服务器(如 Wildfly 或 Tomcat)、应用代码和`runtime`库所需的所有内容，以及您将在服务器上安装和部署以使应用运行的所有内容。将所有这些打包成一个完整的映像保证了它的可移植性；无论部署在什么环境中，它都将始终以相同的方式运行。使用 Docker，您可以运行 Java 应用，而不必在主机上安装 Java 运行时。所有与 JDK 或 JRE 不兼容、应用服务器版本错误等相关的问题都消失了。升级也很容易，毫不费力；您只需在主机上运行容器的新版本。
如果你需要做一些清理，你可以直接破坏 Docker 映像，就好像什么都没发生过一样。想想 Docker，它不是一种编程语言或框架，而是一种帮助解决常见问题(如安装、分发和管理软件)的工具。它允许开发人员和开发人员在任何地方构建、发布和运行他们的代码。Anywhere 也意味着在多台机器上，这就是 Kubernetes 派上用场的地方；我们将很快回到这个话题。
将您的所有应用代码和运行时依赖项打包为一个完整的软件单元，看起来可能与虚拟化引擎相同，但事实远非如此，我们现在将对此进行解释。要完全了解 Docker 到底是什么，首先我们需要了解传统虚拟化和容器化之间的区别。现在让我们比较一下这两种技术。
# 虚拟化和容器化比较
传统虚拟机代表硬件级虚拟化。本质上，它是一个完整的虚拟化物理机，安装了基本输入输出系统和操作系统。它运行在主机操作系统之上。您的 Java 应用在虚拟化环境中运行，就像它通常在您自己的机器上运行一样。将虚拟机用于您的应用有很多优势。每个虚拟机可以有完全不同的操作系统；例如，这些可以是不同的 Linux 风格、Solaris 或 Windows。根据定义，虚拟机也非常安全；它们是完全隔离的，盒子里完整的操作系统。
然而，没有什么是没有代价的。虚拟机包含操作系统运行所需的所有功能:核心系统库、设备驱动程序等。有时，他们可能是资源饥渴和重量级的。虚拟机需要完全安装，这有时会很麻烦，并且不太容易设置。最后但同样重要的是，您将需要更多的计算能力和资源来在虚拟机中执行您的应用虚拟机管理程序需要首先导入虚拟机，然后启动它，这需要时间。然而，我认为，当运行 Java 应用时，拥有完整的虚拟化环境并不是我们经常想要的。Docker 带着容器化的概念前来救援。Java 应用(当然，不限于 Java)在 Docker 上运行在一个名为容器的隔离环境中。容器不是通俗意义上的虚拟机。它表现为一种操作系统虚拟化，但根本没有仿真。主要区别在于，虽然每个传统虚拟机映像运行在独立的客户操作系统上，但 Docker 容器运行在主机上运行的同一内核中。容器是自给自足的，不仅与底层操作系统隔离，还与其他容器隔离。它有自己独立的文件系统和环境变量。当然，容器可以相互通信(例如作为应用和数据库容器)，也可以共享磁盘上的文件。与传统虚拟化相比，主要区别在于容器运行在同一个内核中，它们使用的系统资源更少。所有操作系统核心软件都将从 Docker 映像中删除。基本容器可以是并且通常是非常轻的。没有与经典虚拟化虚拟机管理程序和来宾操作系统相关的开销。这样，您可以为您的 Java 应用实现几乎裸机的核心性能。此外，由于容器的开销最小，容器化的 Java 应用的启动时间通常很短。您还可以在几秒钟内推出数百个应用容器，以减少配置软件所需的时间。在接下来的章节中，我们将使用 Kubernetes 实现这一点。虽然 Docker 与传统的虚拟化引擎有很大的不同。请注意，容器不能替代所有用例的虚拟机；仍然需要经过深思熟虑的评估来确定什么最适合您的应用。两种解决方案都有各自的优势。一方面，我们有性能一般的完全隔离的安全虚拟机。另一方面，我们的容器缺少一些关键功能，但配备了可以快速调配的高性能。让我们看看在使用 Docker 容器化时，您还会获得哪些其他好处。
# 使用 Docker 的好处
正如我们之前所说的，使用 Docker 的主要明显优势将是非常快的性能和短的资源调配时间。您可以快速轻松地创建或销毁容器。容器与其他 Docker 容器有效地共享资源，例如操作系统的内核和所需的库。因此，在容器中运行的应用的多个版本将非常轻量级。其结果是更快的部署、更容易的迁移和启动时间。
Docker 在部署 Java 微服务时特别有用。在接下来的一章中，我们将详细回到微服务。微服务应用由一系列离散的服务组成，通过应用编程接口与其他服务通信。微服务将一个应用分成大量的小进程。它们与单一应用相反，单一应用将所有操作作为单个进程或一组大型进程运行。
使用 Docker 容器使您能够部署随时可以运行的软件，它是可移植的，并且非常容易分发。您的容器化应用只是在其容器内运行；不需要安装。缺少安装过程有巨大的优势；它消除了软件和库冲突甚至驱动程序兼容性问题等问题。Docker 容器是便携式的；它们可以从任何地方运行:您的本地机器、远程服务器以及私有或公共云。所有主要的云计算提供商，如**亚马逊网络服务** ( **AWS** )和谷歌的计算平台现在都支持 Docker。比方说，一个运行在 Amazon EC2 实例上的容器可以很容易地转移到其他环境中，实现完全相同的一致性和功能。Docker 在您的基础结构层之上提供的额外抽象级别是一个不可或缺的特性。开发人员可以创建软件，而不用担心以后运行的平台。Docker 有着和 Java 一样的承诺；写一次，跑遍任何地方；除了不使用代码之外，您可以完全按照您想要的方式配置您的服务器(通过选择操作系统、调整配置文件、安装依赖项)，并且您可以确定您的服务器模板将在运行 Docker 的任何主机上完全相同地运行。
由于 Docker 的可复制构建环境，它特别适合测试，尤其是在您的持续集成或持续交付流程中。您可以快速启动相同的环境来运行测试。而且因为容器映像每次都是相同的，所以您可以分配工作负载并并行运行测试，而不会出现问题。开发人员可以在他们的机器上运行相同的映像，这些映像将在以后的生产中运行，这在测试中也有巨大的优势。
Docker 容器的使用加速了持续集成。不再有无休止的构建-测试-部署周期；Docker 容器确保应用在开发、测试和生产环境中运行相同。代码随着时间的推移而增长，变得越来越麻烦。这就是为什么不可改变的基础设施的想法现在变得越来越流行，容器化的概念变得如此流行。通过将您的 Java 应用放入容器中，您可以简化部署和扩展的过程。通过拥有一个几乎不需要配置管理的轻量级 Docker 主机，您可以简单地通过向主机部署和重新部署容器来管理您的应用。同样，因为容器非常轻，只需要几秒钟。
我们已经谈论了很多关于映像和容器的内容，但没有深入细节。让我们现在就做，看看什么是 Docker 映像和容器。
# Docker 概念-映像和容器
在处理 Kubernetes 时，我们将使用 Docker 容器；它是一个开源的容器集群管理器。要运行我们自己的 Java 应用，我们需要首先创建一个映像。让我们从 Docker 映像的概念开始。
# 形象
将映像视为只读模板，这是创建容器的基础。它与包含应用运行所需的一切定义的配方是一样的。它可以是带有应用服务器的 Linux(例如 Tomcat 或 Wildfly)和您的 Java 应用本身。每个映像都从一个基础映像开始；比如 Ubuntu 一个 Linux 映像。虽然您可以从一个简单的映像开始，并在其上构建您的应用栈，但是您也可以从互联网上的数百个可用映像中挑选一个已经准备好的映像。有很多图片对 Java 开发人员特别有用:`openjdk`、`tomcat`、`wildfly`以及其他很多图片。我们将在以后使用它们作为我们自己映像的基础。比方说，将 Wildfly 正确安装和配置作为自己映像的起点要容易得多。然后，您可以专注于您的 Java 应用。如果你是一个构建映像的新手，下载一个专门的基础映像是一个很好的方法，与自己开发一个相比，可以大大提高速度。
映像是使用一系列称为指令的命令创建的。指令放在 Dockerfile 中。Dockerfile 只是一个纯文本文件，包含`root`文件系统更改的有序集合(与运行启动应用服务器的命令、添加文件或目录、创建环境变量等相同)。)以及稍后在容器运行时中使用的相应执行参数。当您开始构建映像并逐一执行指令时，Docker 将读取 Dockerfile。结果将是最终的映像。每个指令都会在映像中创建新层。然后，该映像层成为由下一条指令创建的层的父层。Docker 映像可以跨主机和操作系统高度移植；映像可以在运行 Docker 的任何主机上的 Docker 容器中运行。Docker 在 Linux 中是本地支持的，但是必须在 Windows 和 macOS 上的虚拟机中运行。重要的是要知道 Docker 使用映像来运行您的代码，而不是 Dockerfile。当您运行`docker build`命令时，Dockerfile 用于创建映像。此外，如果您将映像发布到 Docker Hub，则发布的是带有图层的结果映像，而不是源 Dockerfile 本身。
我们之前说过，Dockerfile 中的每个指令都会创建一个新层。图层是映像的内在本质；Docker 映像就是由它们组成的。现在我们来解释一下它们是什么，它们的特点是什么。
# 层
每个映像由一系列堆叠的层组成，一个在另一个之上。其实每一层都是一个中间形象。通过使用**联合文件系统**，Docker 将所有这些层组合成一个映像实体。union 文件系统允许透明地覆盖不同文件系统的文件和目录，从而产生一个单一的、一致的文件系统，如下图所示:
![](img/93252b1b-c607-42a4-a7d3-272602eb5c34.jpg)
在这些独立的文件系统中具有相同路径的目录的内容和结构将一起出现在新的、类似虚拟的文件系统中的一个合并目录中。换句话说，顶层的文件系统结构将与底层的结构合并。与上一层路径相同的文件和目录将覆盖下面的文件和目录。移除上层将再次显示和展示以前的目录内容。正如我们前面提到的，层被放置在一个栈中，一个在另一个之上。为了保持层的顺序，Docker 使用了层标识和指针的概念。每个层都包含标识和指向其父层的指针。没有指针引用父层的层是栈中的第一层，即基层。您可以在下图中看到这种关系:
![](img/340edb83-5778-4456-b305-21cdd1a4d395.jpg)
图层有一些有趣的特征。首先，它们是可重用和可缓存的。在前面的图中，指向父层的指针非常重要。当 Docker 正在处理您的 Docker 文件时，它看到了两件事:正在执行的 Docker 文件指令和父映像。Docker 将扫描父层的所有子层，并查找其命令与当前指令匹配的子层。如果找到匹配，Docker 会跳到下一个 Dockerfile 指令并重复该过程。如果在缓存中找不到匹配的图层，则会创建一个新图层。对于将文件添加到您的映像的说明(我们将在稍后详细了解)，Docker 会为每个文件内容创建一个校验和。在构建过程中，将该校验和与现有映像的校验和进行比较，以检查该图层是否可以从缓存中重用。如果两个不同的映像有一个共同的部分，比如说一个 Linux shell 或 Java 运行时，跟踪所有提取的层的 Docker 将在两个映像中重用 shell 层。这是一个安全的操作；正如您已经知道的，图层是只读的。当下载另一个映像时，图层将被重用，并且只有差异将从 Docker Hub 中提取。这当然节省了时间、带宽和磁盘空间，但它还有另一个巨大的优势。如果您修改您的 Docker 映像，例如通过修改您的容器化 Java 应用，只有应用层会被修改。从 Dockerfile 成功构建映像后，您会注意到同一 Dockerfile 的后续构建完成得更快。一旦 Docker 缓存了指令的映像层，就不需要重新构建。稍后，您只推送更新的部分，而不是分发整个映像。它使过程变得更简单、更快速。如果您在连续部署流程中使用 Docker，这尤其有用:推送 Git 分支将触发构建映像，然后为用户发布应用。由于层重用特性，整个过程要快得多。
可重用层的概念也是 Docker 与不共享任何东西的完整虚拟机相比如此轻量级的原因。多亏了图层，当你拉一个映像时，你最终不需要下载它的所有文件系统。如果您已经有了另一个映像，其中包含您提取的映像的一些图层，那么实际上只会下载缺失的图层。不过，有一个警告词与层的另一个特性有关:除了可重用之外，层也是附加的。如果您在容器中创建了一个大文件，然后提交(我们稍后会谈到这一点)，然后删除该文件，并再次提交；该文件仍将出现在图层历史记录中。想象一下这个场景:你拉基本的 Ubuntu 映像，并安装 Wildfly 应用服务器。然后你改变主意，卸载 Wildfly 并安装 Tomcat。从 Wildfly 安装中删除的所有文件仍将出现在映像中，尽管它们已被删除。映像尺寸将很快增长。理解 Docker 的分层文件系统可以大大改变映像的大小。当您将映像发布到注册表时，大小会成为一个问题；它需要更多的请求，传输时间也更长。
例如，当需要在集群中部署数千个容器时，大型映像就成为一个问题。您应该始终意识到层的可加性，并尝试在 Dockerfile 的每一步优化映像，例如，与使用命令链接相同。稍后在创建 Java 应用映像时，我们将使用命令链接技术。
因为图层是可叠加的，所以它们提供了特定映像是如何构建的完整历史。这给了你另一个很好的特性:可以回滚到映像历史中的某个点。由于每个映像都包含其所有的构建步骤，如果我们愿意，我们可以轻松地返回到上一步。这可以通过标记某个层来完成。我们将在本书的后面介绍映像标记。
图层和映像是密切相关的。如前所述，Docker 映像存储为一系列只读层。这意味着一旦创建了容器映像，它就不会改变。但是让所有文件系统都是只读的没有多大意义。修改映像怎么样？或者将您的软件添加到基础 web 服务器映像中？当我们启动一个容器时，Docker 实际上获取了只读映像(及其所有只读层)，并在层栈的顶部添加了一个可写层。现在让我们把重点放在容器上。
# 容器
映像的运行实例称为容器。Docker 使用 Docker 映像作为只读模板来启动它们。如果您启动一个映像，您就有一个运行该映像的容器。自然，您可以有许多相同映像的运行容器。事实上，我们经常会在稍后使用 Kubernetes 来实现。
要运行容器，我们使用`docker run  `命令:
```
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  
```
有很多`run`命令选项和开关可以使用；我们以后会了解他们的。一些选项包括网络配置，例如(我们将在[第 2 章](02.html)、*网络和持久存储*中解释 Docker 的网络概念)。其他，和`-it`一样(来自交互)，告诉 Docker 引擎行为不同；在这种情况下，使容器具有交互性，并将终端附加到它的输出和输入。让我们只关注容器的想法，以便更好地理解整个画面。我们稍后将使用`docker run`命令来测试我们的设置。
那么，当我们运行`docker run`命令时，引擎盖下会发生什么？Docker 将检查您想要运行的映像在您的本地机器上是否可用。如果没有，将从`remote`库中下拉。Docker 引擎获取映像，并在映像的层栈上添加一个可写层。接下来，它初始化映像的名称、标识和资源限制，如中央处理器和内存。在这个阶段，Docker 还将通过从池中查找并附加一个可用的 IP 地址来设置容器的 IP 地址。执行的最后一步将是实际命令，作为`docker run`命令的最后一个参数传递。如果使用了`it`选项，Docker 将捕获并提供容器输出，它将显示在控制台中。现在，您可以做一些在准备操作系统运行应用时通常会做的事情。这可以是安装软件包(例如通过`apt-get`)，用 Git 拉源代码，用 Maven 构建你的 Java 应用，等等。所有这些操作都将修改顶层可写层中的文件系统。如果您随后执行`commit`命令，将会创建一个包含您所有更改的新映像，该映像有点冻结，准备稍后运行。要停止容器，使用`docker stop`命令:
```
docker stop  
```
容器停止后将保留所有设置和文件系统更改(在可写的顶层)。容器中运行的所有进程都将停止，您将丢失内存中的所有内容。这就是停止的容器与 Docker 映像的区别。
要列出系统中所有正在运行或已停止的容器，请执行`docker ps`命令:
```
docker ps -a
```
因此，Docker 客户端将列出一个表，其中包含容器 id(您可以在其他命令中用来引用容器的唯一标识符)、创建日期、用于启动容器的命令、状态、公开的端口和一个名称，可以是您分配的，也可以是 Docker 为您挑选的有趣名称。要移除容器，只需使用`docker rm`命令。如果您想一次移除几个容器，您可以使用容器列表(由`docker ps`命令给出)和过滤器: