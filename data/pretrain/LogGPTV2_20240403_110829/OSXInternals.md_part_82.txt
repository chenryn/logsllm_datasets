printf("parent: task = %x, thread = %x\n", mach_task_self(),
pthread_mach_thread_np(pthread_self()));
// vfork() if no extra command-line arguments
if (argc == 1)
ret = vfork();
else
ret = fork();
if (ret 
#define TASK_PATH "/bin/sleep"
#define TASK_ARGS "5"
int
main()
{
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
NSTask *newTask;
int status;
// allocate and initialize an NSTask object
newTask = [[NSTask alloc] init];
// set the executable for the program to be run
[newTask setLaunchPath:@TASK_PATH];
// set the command arguments that will be used to launch the program
[newTask setArguments:[NSArray arrayWithObject:@TASK_ARGS]];
// launch the program -- a new process will be created
[newTask launch];
NSLog(@"waiting for new task to exit\n");
[newTask waitUntilExit];
// fetch the value returned by the exiting program
status = [newTask terminationStatus];
NSLog(@"new task exited with status %d\n", status);
[pool release];
exit(0);
}
$ gcc -Wall -o nstask NSTask.m -framework Foundation
$ ./nstask
2005-08-12 13:42:44.427 nstask[1227] waiting for new task to exit
2005-08-12 13:42:49.472 nstask[1227] new task exited with status 0
7.3.6. The NSThread Cocoa Class
The NSThread class allows for creation of multiple threads in Cocoa applications. It is particularly
convenient to use NSThread for running an Objective-C method in its own thread. Each instance of the
NSThread class controls one thread of execution, which maps to one pthread. Figure 734 shows an
example of using NSThread.
Figure 734. Using the NSThread Cocoa class
// NSThread.m
#import 
@interface NSThreadController : NSObject
{
unsigned long long sum1;
unsigned long long sum2;
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh62C7.htm 20.08.2007
Chapter 7. Processes Page 59 of 107
}
- (void)thread1:(id)arg;
- (void)thread2:(id)arg;
- (unsigned long long)get_sum1;
- (unsigned long long)get_sum2;
@end
@implementation NSThreadController
- (unsigned long long)get_sum1
{
return sum1;
}
- (unsigned long long)get_sum2
{
return sum2;
}
- (void)thread1:(id)arg
{
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
[NSThread setThreadPriority:0.0];
sum1 = 0;
printf("thread1: running\n");
for (;;)
sum1++;
[pool release];
}
- (void)thread2:(id)arg
{
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
[NSThread setThreadPriority:1.0];
sum2 = 0;
printf("thread2: running\n");
for (;;)
sum2++;
[pool release];
}
@end
int
main()
{
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
NSTimeInterval secs = 5;
NSDate *sleepForDate = [NSDate dateWithTimeIntervalSinceNow:secs];
NSThreadController *T = [[NSThreadController alloc] init];
[NSThread detachNewThreadSelector:@selector(thread1:)
toTarget:T
withObject:nil];
[NSThread detachNewThreadSelector:@selector(thread2:)
toTarget:T
withObject:nil];
printf("main: sleeping for %f seconds\n", secs);
[NSThread sleepUntilDate:sleepForDate];
printf("sum1 = %lld\n", [T get_sum1]);
printf("sum2 = %lld\n", [T get_sum2]);
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh62C7.htm 20.08.2007
Chapter 7. Processes Page 60 of 107
[pool release];
exit(0);
}
$ gcc -Wall -o nsthread NSThread.m -framework Foundation
$ ./nsthread
main: sleeping for 5.000000 seconds
thread2: running
thread1: running
sum1 = 49635095
sum2 = 233587520
7.3.7. The Carbon Process Manager
The Process Manager provided a cooperative multitasking environment on several versions of Mac OS
prior to Mac OS X. It is supported on Mac OS X as the Carbon Process Manager (CPM), but certain
functionality and aspects that are not applicable in the Mac OS X environment are either unavailable or
have been modified for accommodation in Mac OS X's different architecture.
Each CPM process maps to a BSD process, but not vice versa. Only those processes that are launched
through the CPM are managed by Carbon. For each process that it manages, the CPM maintains certain
state, including a process serial number (PSN) that is different from the BSD process ID. The PSN
consists of a high part and a low part, both of which are unsigned long quantities.
struct ProcessSerialNumber {
unsigned long highLongOfPSN;
unsigned long lowLongOfPSN;
};
typedef struct ProcessSerialNumber ProcessSerialNumber;
typedef ProcessSerialNumber *ProcessSerialNumberPtr;
You can start a CPM process using the Carbon API's LaunchApplication() function, which launches an
application from the specified file and returns the PSN on a successful launch.
As we saw in the implementation of our lstasks program, given a CPM process, the corresponding PSN
and Carbon-specific process name can be retrieved using GetProcessForPID() and CopyProcessName
(), respectively. CPM processes can be identified in the process listing generated by the ps command, as
they are shown with an argument of the form -psn_X_Y, where X and Y are the high and low parts,
respectively, of the PSN.
Figure 735 shows an example of launching a CPM process.
Figure 735. Launching an application through the Carbon Process Manager
// CarbonProcessManager.c
#include 
#define PROGNAME "cpmtest"
int
main(int argc, char **argv)
{
OSErr err;
Str255 path;
FSSpec spec;
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh62C7.htm 20.08.2007
Chapter 7. Processes Page 61 of 107
LaunchParamBlockRec launchParams;
if (argc != 2) {
printf("usage: %s \n", PROGNAME);
exit(1);
}
c2pstrcpy(path, argv[1]);
err = FSMakeFSSpec(0, // use the default volume
0, // parent directory -- determine from filename
path, &spec);