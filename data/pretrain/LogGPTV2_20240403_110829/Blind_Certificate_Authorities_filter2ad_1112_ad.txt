In AES-GCM,
the situation is the opposite. Here, the client chooses
a random IV and uses counter mode, namely, all
messages M1, . . . , Mt are encrypted using the ‚Äúkey
stream‚Äù AESK(IV + 1), . . . , AESK(IV + t). The client
can simply send the portion of the key stream that is
associated with the injected message of the proxy, and
no secure computation of AES is needed. However, the
.
4That is, this is the leakage the proxy receives regarding the input of
the client.
(cid:18)(cid:17)(cid:19)(cid:18)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:08 UTC from IEEE Xplore.  Restrictions apply. 
that
is not known to the client, on a point
authentication data involves evaluation of a polynomial
that
is
known only to the client. We therefore use oblivious
polynomial evaluation [29, 30, 43] to perform this part of
the computation. See full details in Appendix B.
Other secure channels. We focused above on TLS using
common record layer encryption schemes. Our techniques
can be adapted to some other protocols and authenticated
encryption schemes, such as Encrypt-then-MAC (e.g.,
IPsec) and Encrypt-and-MAC (e.g., SSH). There are a
number of in-use authenticated encryption schemes such
as ChaCha20/Poly1305 [47] and CCM [41] for which we
have not yet explored how to perform efÔ¨Åcient SCI. Com-
mon to them is the use of Encrypt-then-MAC type modes
with a ‚Äúweaker‚Äù MAC such as CBC-MAC. Theoretically,
constructing SCI for these secure channels is always
possible. We leave constructing efÔ¨Åcient SCI protocols for
these schemes to future work.
V. ANONYMOUS PAOS AND BLIND CERTIFICATE
AUTHORITIES
We introduce two applications of SCI in this section:
anonymous proofs of account ownership (PAOs) and blind
certiÔ¨Åcate authorities (blind CAs). We focus on SMTP
as the application layer protocol. We introduce a basic
SMTP-STARTTLS workÔ¨Çow, our requirements of SMTP
implementations, and our application design, and brieÔ¨Çy
discuss potential application-speciÔ¨Åc attacks and the cor-
responding defenses towards the end of this section.
A. SMTP with STARTTLS
We Ô¨Årst brieÔ¨Çy discuss the workÔ¨Çow of sending an
email in SMTP-STARTTLS as our application is inti-
mately tied to the workings of SMTP implementations.
We focus on PLAIN as the target authentication mecha-
nism, which is the most widely used authentication mech-
anism [33]. The client Ô¨Årst sends a STARTTLS command
to initialize a TLS-protected SMTP session after checking
the SMTP server‚Äôs support for TLS. In the session, the
client sends the following commands in order: AUTH
PLAIN account_name password (authentication),
MAIL and RCPT (setting the sender/recipient addresses),
DATA (notifying the begin of email transactions), the
email content, and Ô¨Ånally QUIT (closing the session).
The AUTH, MAIL, RCPT, and DATA are mandatory and
must be sent in order according to RFC [37], while other
commands are optional. The client needs to wait for the
server‚Äôs response to a command before sending the next
one, unless the PIPELINING extension, which allows
the client to send several commands in a batch, is enabled
by the server. But according to RFC [37], the server
should respond to each command individually.
B. System Assumptions
The security of anonymous PAOs and blind CAs rely on
the security of SCI. So, they have the same threat model
and underlying assumptions as SCI (e.g., parties do not
collude). See ¬ßIII and ¬ßIV. Besides, we assume that the
challenges generated during anonymous PAOs will not be
leaked by the prover intentionally or unintentionally. And,
the certiÔ¨Åcate generated by the blind CA should contain
sufÔ¨Åcient entropy to rule out brute-force inversion of the
certiÔ¨Åcate hash, which is revealed to the CA. This require-
ment is easily satisÔ¨Åed as long as the certiÔ¨Åcate includes
the prover‚Äôs public key. We also assume that the prover
might communicate with the veriÔ¨Åer (the CA) through an
anonymous or pseudonymous channel, such as Tor and
public wireless networks, to achieve IP anonymity. The
veriÔ¨Åer must be associated with a valid certiÔ¨Åcate that can
be used to identify the veriÔ¨Åer.
We assume the target STMP server supports the fol-
lowing property: during one SMTP session, only one
email, with a secret challenge injected in the designated
location, will be generated and sent from the authenticated
account, and each TLS message sent from the prover
contains exactly one SMTP command as speciÔ¨Åed by
our protocols. Thus, the SMTP server should meet the
following requirements:
(1) Auth: The server should use correctly conÔ¨Ågured
SMTPS (e.g., using valid TLS certiÔ¨Åcate and being con-
Ô¨Ågured as a closed relay) and only authenticated users
with correct sender addresses can send emails [23,40,59].
(2) NoEcho: the server should not echo back received
commands to the client, which would immediately break
injection secrecy. (3) NoPipeline: the server should not
support the PIPELINING extension; or (4) RFCCom-
pliant: If the server does not satisfy NoPipeline, the
server must be RFC-compliant in terms of how it responds
to pipelined commands, as described in ¬ßV-A. These
requirements help anonymous PAOs and blind CAs to
achieve security (See ¬ßV-E).
To understand how stringent these requirements are, we
investigated the behavior of 150 popular SMTP servers
(supporting STARTTLS)
from public lists available
on the Internet [2, 24]. Overall, we found 112 SMTP
servers (75% of those examined) meet our requirements
and can be used for anonymous PAOs and blind CAs,
including popular services that have a large user base:
Gmail, Outlook, Hotmail, Mail.com, etc.
C. Anonymous PAO for SMTP
Using anonymous PAO, a prover (who owns an email
account PI:EMAIL that is administered by
a service domain.com) can prove to the veriÔ¨Åer that
she owns an email account from domain.com, without
disclosing the exact email address. Unlike conventional
PAOs in which a veriÔ¨Åer sends a challenge to a prover‚Äôs
(cid:18)(cid:17)(cid:19)(cid:19)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:08 UTC from IEEE Xplore.  Restrictions apply. 
'%+'
	" $)

"'+"$+
' .'
'%,-
'+ 
'+'
'%+'
	" $)
	
'%,-
'+ 
'+'





&#%(/
#%#&/
)-%#$/#+
0




"%%'!
0 
#%#&/
)-%#$/#+
 






$(!(
()')*)$) ) %$
$*)$) ) %$
	
# "
	
$((( %$


1%#).2
# """$
""$
')&'%%
 $
')
' -&'%%

1%#).2
%## )#$)
	%#'

$')
')&'%%

*!&',

++!
+'('/&(-+
Fig. 5: Technical Ô¨Çows of (a) SMTP-based anonymous PAO and (b)
blind CA. For blind CA: 1 The CA saves the Ô¨Årst message as the
commitment; 2 The CA and the prover use anonymous PAO to inject
a challenge; 3 The CA and the prover run a zero-knowledge protocol
to generate a legitimate X.509 certiÔ¨Åcate.
account, our anonymous PAO realizations work in the
opposite direction. The setup is shown in Figure 5: the
prover runs a modiÔ¨Åed SMTP client, and uses SMTP-
STARTTLS to interact with the private SMTP server of
domain.com via a proxy managed by the veriÔ¨Åer using
the following protocol:
(1) The veriÔ¨Åer (i.e., the proxy in the SCI) determines
the address of smtp.domain.com, e.g., via DNS,
and checks whether the server satisÔ¨Åes the aforemen-
tioned requirements.
(2) The prover (i.e., the client in the SCI) sends an email
using the SMTP server, to any location only accessi-
ble to the prover, via the veriÔ¨Åer. Most of the SMTP
messages are sent in separate TLS fragments. For the
body of the email the client and proxy use a shared
template that speciÔ¨Åes the location of the challenge in
the body and its format (e.g., the challenge should be
a certain-length string of random ASCII characters).
(3) The proxy injects a challenge into that email via
SCI. The TLS fragment containing the email body
is handled via our SCI-TLS injection protocol; this
u message using the notation from ¬ßIV. The
is the Q‚àó
resulting TLS record will be sent to the server by the
proxy, and then the client can Ô¨Ånish the session.
(4) The client will
later retrieve the email (via an
independent and standard connection to its email
provider), and extract the challenge.
(5) The client will verify the veriÔ¨Åer‚Äôs identity (e.g,
proxy‚Äôs certiÔ¨Åcate) and send the challenge to
the veriÔ¨Åer
to complete proof. Assuming only
authenticated users can use the server to send emails,
this will prove ownership of an account.
Challenge steganography. Recall that one of our se-
curity goals is service obliviousness. This is not always
important, but could be in some settings. Assuming that
SCI-TLS is server oblivious, meaning it is not uniquely
identiÔ¨Åable as such, what remains is to ensure that injected
messages are not detectable as PAOs. This is fundamen-
tally a task of steganography, but we are aided here by the
fact that challenges can be relatively short and the rest of
the message can even be hand-crafted.
We designed various example message templates that
can be used for hiding a challenge. For example, the
message template can be an email that contains a public
key or encrypted Ô¨Åles (PDF, zip Ô¨Åle, etc.); It is easy to
embed a short random-string challenge in the template,
by simply replacing a portion of the random string with
the challenge.
D. Blind CertiÔ¨Åcate Authorities
We now show how to extend our SMTP-based anony-
mous PAO to build a blind certiÔ¨Åcate authority service.
A blind CA can verify a person‚Äôs ownership of an email
account and then sign an X.509 certiÔ¨Åcate for the user‚Äôs
public key. The certiÔ¨Åcate is mainly for binding the public
key to the email account and serves as a proof of email
account ownership for uses in other privacy-enhancing
systems like Cinderella. Unlike conventional CAs, ours
will be blind: the CA does not learn the user‚Äôs identity or
public key.
At a high level, our blind CA implementation works
as follows. (1) The CA runs the SMTP-based anonymous
PAO protocol with the client, but additionally extracts
from the transcript of the protocol execution a crypto-
graphic commitment to the client‚Äôs username, alice.
(2) The CA gives the client a certiÔ¨Åcate template that is
completely Ô¨Ålled except for the entries subject (the client‚Äôs
username, e.g., alice) and public key. The client Ô¨Ålls
in these missing entries, and then sends the hash of this
certiÔ¨Åcate and a zero-knowledge proof to the CA to prove
that the same username has been used in the commitment
and the certiÔ¨Åcate. (3) The CA veriÔ¨Åes that the proof is
correct, signs the hash using a standard digital signature
scheme and sends it back. The result is that the client
obtains a valid certiÔ¨Åcate, signed by the CA.
We next elaborate on how to generate a valid commit-
ment during the anonymous PAO, and then describe the
certiÔ¨Åcate generation procedures.
Anonymous PAO with binding identity. For blind
CA, we need a slightly stronger form of PAO in which
upon acceptance of the statement by the proxy (i.e.,
being convinced that the client is some eligible user of
domain.com), it outputs in addition a cryptographic
commitment to the identity of the client (henceforth, say,
alice). The commitment is hiding (and therefore does
not reveal the identity of alice), but it also binding (and
so it is infeasible to link this interaction with a different
user rather than alice).
Ristenpart et al. show that for several ciphersuites for
TLS, their ciphertexts bind the underlying plaintexts and
(cid:18)(cid:17)(cid:19)(cid:20)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:08 UTC from IEEE Xplore.  Restrictions apply. 
can be treated as secure commitments, where the opening
is the keys derived from the handshake phase [50]. Such
a ciphersuite is AES-CBC with HMAC. In our context of
anonymous PAO and SMTP, the encrypted messages that
are being delivered by the veriÔ¨Åer (i.e., the proxy) to the
server contain the authentication data of the client such
as username and password. We refer to this information
as the identity of the client, and elaborate how these