In the AES-GCM (Galois/Counter Mode) encryption scheme, the process is reversed compared to other modes. The client selects a random Initialization Vector (IV) and employs counter mode for encryption. This means that all messages \( M_1, \ldots, M_t \) are encrypted using the key stream generated by \( \text{AES}_K(\text{IV} + 1), \ldots, \text{AES}_K(\text{IV} + t) \). The client can transmit only the portion of the key stream associated with the message injected by the proxy, thereby eliminating the need for secure computation of AES. However, this results in the proxy receiving information about the client's input, which is considered leakage.

For authentication data, the client evaluates a polynomial known only to them. To handle this, we utilize oblivious polynomial evaluation [29, 30, 43] to perform the necessary computations securely. Detailed information on this process is provided in Appendix B.

### Other Secure Channels
Our focus has been on TLS with common record layer encryption schemes. Our techniques can be adapted to other protocols and authenticated encryption schemes, such as Encrypt-then-MAC (e.g., IPsec) and Encrypt-and-MAC (e.g., SSH). There are several in-use authenticated encryption schemes, like ChaCha20/Poly1305 [47] and CCM [41], for which we have not yet explored efficient SCI (Secure Channel Injection) methods. These schemes typically use Encrypt-then-MAC type modes with a "weaker" MAC, such as CBC-MAC. Theoretically, constructing SCI for these secure channels is possible, but we leave the development of efficient SCI protocols for these schemes to future work.

### Anonymous PAOs and Blind Certificate Authorities
In this section, we introduce two applications of SCI: anonymous proofs of account ownership (PAOs) and blind certificate authorities (blind CAs). We focus on SMTP as the application layer protocol. We outline the basic SMTP-STARTTLS workflow, our requirements for SMTP implementations, and our application design. We also briefly discuss potential application-specific attacks and corresponding defenses.

#### A. SMTP with STARTTLS
We first discuss the workflow of sending an email using SMTP-STARTTLS, as our application is closely tied to the operation of SMTP implementations. We focus on PLAIN as the target authentication mechanism, which is the most widely used method [33]. The client initiates a TLS-protected SMTP session by sending a STARTTLS command after verifying the server's support for TLS. In the session, the client sends the following commands in order: AUTH PLAIN (for authentication), MAIL, RCPT (to set sender/recipient addresses), DATA (to notify the start of email transactions), the email content, and finally QUIT (to close the session). Commands AUTH, MAIL, RCPT, and DATA are mandatory and must be sent in sequence according to RFC [37], while others are optional. The client must wait for the server's response to each command unless the PIPELINING extension is enabled, allowing batched commands. However, the server should respond to each command individually, as per RFC [37].

#### B. System Assumptions
The security of anonymous PAOs and blind CAs relies on the security of SCI. They share the same threat model and underlying assumptions, such as non-collusion among parties. Additionally, we assume that challenges generated during anonymous PAOs will not be leaked by the prover, and the certificate generated by the blind CA should contain sufficient entropy to prevent brute-force inversion of the certificate hash. This requirement is easily met if the certificate includes the prover's public key. We also assume that the prover communicates with the verifier (the CA) through an anonymous or pseudonymous channel, such as Tor or public wireless networks, to achieve IP anonymity. The verifier must be associated with a valid certificate for identification.

We assume the target SMTP server supports the following properties:
1. **Auth**: The server uses correctly configured SMTPS (with a valid TLS certificate and closed relay) and allows only authenticated users with correct sender addresses to send emails [23, 40, 59].
2. **NoEcho**: The server does not echo back received commands, which would break injection secrecy.
3. **NoPipeline**: The server does not support the PIPELINING extension.
4. **RFCCompliant**: If the server does not satisfy NoPipeline, it must be RFC-compliant in its responses to pipelined commands, as described in §V-A.

These requirements help ensure the security of anonymous PAOs and blind CAs. To understand the feasibility of these requirements, we investigated 150 popular SMTP servers supporting STARTTLS from public lists [2, 24]. We found that 112 servers (75% of those examined) meet our requirements, including popular services like Gmail, Outlook, Hotmail, and Mail.com.

#### C. Anonymous PAO for SMTP
Using anonymous PAO, a prover (who owns an email account at `domain.com`) can prove to the verifier that they own an email account without disclosing the exact email address. Unlike conventional PAOs where the verifier sends a challenge to the prover, our anonymous PAO works in the opposite direction. The setup is shown in Figure 5: the prover runs a modified SMTP client and uses SMTP-STARTTLS to interact with the private SMTP server of `domain.com` via a proxy managed by the verifier. The protocol steps are as follows:

1. **Verifier Setup**: The verifier (i.e., the proxy in the SCI) determines the address of `smtp.domain.com` (e.g., via DNS) and checks if the server meets the required conditions.
2. **Email Sending**: The prover (i.e., the client in the SCI) sends an email using the SMTP server to a location accessible only to the prover, via the verifier. Most SMTP messages are sent in separate TLS fragments. For the email body, the client and proxy use a shared template specifying the location and format of the challenge.
3. **Challenge Injection**: The proxy injects a challenge into the email using our SCI-TLS injection protocol. The resulting TLS record is sent to the server by the proxy, and the client completes the session.
4. **Challenge Retrieval**: The client later retrieves the email (via an independent and standard connection to their email provider) and extracts the challenge.
5. **Verification**: The client verifies the verifier’s identity (e.g., the proxy’s certificate) and sends the challenge to the verifier to complete the proof. Assuming only authenticated users can use the server to send emails, this proves account ownership.

**Challenge Steganography**: To ensure service obliviousness, the challenge must not be detectable as a PAO. This is a steganographic task, but we are aided by the fact that challenges can be short and the rest of the message can be hand-crafted. We designed various message templates, such as an email containing a public key or encrypted files (PDF, zip file, etc.), where a short random-string challenge can be embedded.

#### D. Blind Certificate Authorities
We extend our SMTP-based anonymous PAO to build a blind certificate authority service. A blind CA can verify a person’s ownership of an email account and sign an X.509 certificate for the user’s public key, binding the public key to the email account. Unlike conventional CAs, ours is blind: the CA does not learn the user’s identity or public key.

The blind CA implementation works as follows:
1. **Anonymous PAO Execution**: The CA runs the SMTP-based anonymous PAO protocol with the client and extracts a cryptographic commitment to the client’s username (e.g., `alice`).
2. **Certificate Template**: The CA provides the client with a partially filled certificate template, missing the subject (client’s username) and public key. The client fills in these entries and sends the hash of the certificate and a zero-knowledge proof to the CA, proving the same username was used in the commitment and the certificate.
3. **Certificate Signing**: The CA verifies the proof, signs the hash using a standard digital signature scheme, and sends it back. The client then obtains a valid, signed certificate.

**Anonymous PAO with Binding Identity**: For blind CAs, we need a stronger form of PAO that, upon acceptance, outputs a cryptographic commitment to the client’s identity. Ristenpart et al. [50] show that for several TLS ciphersuites, ciphertexts bind the underlying plaintexts and can be treated as secure commitments. In our context, the encrypted messages delivered by the verifier (i.e., the proxy) to the server contain the client’s authentication data, such as the username and password. This information is referred to as the client’s identity, and we elaborate on how these commitments are used in the context of anonymous PAOs and SMTP.