# 将用户alice和admin role关联起来，赋予admin权限给user    $ etcdctl user grant-role alice admin --user root:root    Role admin is granted to user alice然后当你再次使用 etcdctl 执行 put hello 命令时，鉴权模块会从 boltdb查询 alice 用户对应的权限列表。 因为有可能一个用户拥有成百上千个权限列表，etcd为了提升权限检查的性能，引入了区间树，检查用户操作的 key是否在已授权的区间，时间复杂度仅为O(logN)。 在我们的这个案例中，很明显 hello 在 admin 角色可读写的\[hello，helly)数据范围内，因此它有权限更新 key hello，执行成功。你也可以尝试更新 keyhey，因为此 key 未在鉴权的数据区间内，因此 etcd server会返回\"etcdserver: permission denied\"错误给client，如下所示。     $ etcdctl put hello world --user alice:alice    OK    $ etcdctl put hey hey --user alice:alice    Error: etcdserver: permission denied小结最后我和你总结下今天的内容，从 etcd 鉴权模块核心原理分析过程中，你会发现设计实现一个鉴权模块最关键的目标和挑战应该是安全、性能以及一致性。首先鉴权目的是为了保证安全，必须防止恶意用户绕过鉴权系统、伪造、篡改、越权等行为，同时设计上要有前瞻性，做到即使被拖库也影响可控。etcd的解决方案是通过密码安全加密存储、证书认证、RBAC等机制保证其安全性。 然后，鉴权作为了一个核心的前置模块，性能上不能拖后腿，不能成为影响业务性能的一个核心瓶颈。etcd的解决方案是通过 Token降低频繁、昂贵的密码验证开销，可应用在内网、小规模业务场景，同时支持使用证书认证，不存在Token 过期，巧妙的取 CN字段作为用户名，可满足较大规模的业务场景鉴权诉求。 接着，鉴权系统面临的业务场景是复杂的，因此权限控制系统应当具备良好的扩展性，业务可根据自己实际场景选择合适的鉴权方法。etcd的 Token Provider 和 RBAC 扩展机制，都具备较好的扩展性、灵活性。尤其是RBAC机制，让你可以精细化的控制每个用户权限，实现权限最小化分配。 最后鉴权系统元数据的存储应当是可靠的，各个节点鉴权数据应确保一致，确保鉴权行为一致性。早期etcd v2 版本时，因鉴权命令未经过 Raft 模块，存在数据不一致的问题，在etcd v3 中通过 Raft模块同步鉴权指令日志指令，实现鉴权数据一致性。 思考题最后，我给你留了一个思考题。你在使用 etcd鉴权特性过程中遇到了哪些问题？又是如何解决的呢？ 感谢你的阅读，欢迎你把思考和观点写在留言区，也欢迎你把这篇文章分享给更多的朋友一起阅读。 04 思考题参考答案04 讲的思考题 mckee同学给出了精彩回答，下面是他的回答。 1. 哪些场景会出现 Follower 日志与 Leader冲突？ leader 崩溃的情况下可能 (如老的 leader可能还没有完全复制所有的日志条目)，如果 leader 和 follower出现持续崩溃会加剧这个现象。follower 可能会丢失一些在新的 leader中有的日志条目，他也可能拥有一些 leader没有的日志条目，或者两者都发生。 2.follower如何删除无效日志？ leader 处理不一致是通过强制 follower 直接复制自己的日志来解决。因此在follower 中的冲突的日志条目会被 leader 的日志覆盖。leader 会记录follower 的日志复制进度 nextIndex，如果 follower在追加日志时一致性检查失败，就会拒绝请求，此时 leader 就会减小 nextIndex值并进行重试，最终在某个位置让 follower 跟 leader一致。 这里我补充下为什么 WAL日志模块只通过追加，也能删除已持久化冲突的日志条目呢？ 其实这里 etcd在实现上采用了一些比较有技巧的方法，在 WAL日志中的确没删除废弃的日志条目，你可以在其中搜索到冲突的日志条目。只是etcd 加载 WAL 日志时，发现一个 raft log index位置上有多个日志条目的时候，会通过覆盖的方式，将最后写入的日志条目追加到raft log 中，实现了删除冲突日志条目效果，你如果感兴趣可以参考下我和Google ptabor关于这个问题的讨论slate-object="inline"。 