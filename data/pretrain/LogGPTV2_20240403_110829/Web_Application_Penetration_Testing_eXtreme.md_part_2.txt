WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.29
4.2.2.1.1 Character Escaping > Unicode
Blocked!!
We can also see here, Unicode escaping using native
functions. Note, eval is just one of many:
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.30
4.2.2.1.2 Character Escaping > Decimal, Octal,
Hexadecimal
Blocked!!
If the filtered vector is within a string, in addition to Unicode,
there are multiple escapes we may adopt:
Octal escape
 Hexadecimal escape
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.31
4.2.2.1.2 Character Escaping > Decimal, Octal,
Hexadecimal
Blocked!!
Hexadecimal Numeric Character Reference
 Decimal NCR
Superfluous escapes characters
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.32
4.2.2.1.2 Character Escaping > Decimal, Octal,
Hexadecimal
Blocked!!
All character escaping can stay together!
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.33
4.2.2.2 Constructing Strings
Knowing how to construct strings is an important skill in
bypassing filters.
For example, as usual, the alert keyword is blocked, but
most likely "ale"+"rt" is not detected. Let’s see some
examples.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.34
4.2.2.2 Constructing Strings
JavaScript has several functions useful to create strings.
/ale/.source+/rt/.source
String.fromCharCode(97,108,101,114,116)
atob("YWxlcnQ=")
17795081..toString(36)
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.35
4.2.2.3 Execution Sinks
To execute code, we have used the eval function before, as
well as the events associated to some tags. Technically,
functions that parse string as JavaScript code are called
execution sinks, and JavaScript offers several alternatives.
The reason why we must analyze these function is simple:
if we are able to control one of them, we can execute
JavaScript code!
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.36
4.2.2.3 Execution Sinks
The following are just a few sinks; for a complete list, refer
to the DOM XSS Wiki:
setTimeout("JSCode") //all browsers
setInterval("JSCode") //all browsers
setImmediate("JSCode") //IE 10+
Function("JSCode") //all browsers
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.37
https://code.google.com/p/domxsswiki/wiki/ExecutionSinks
4.2.2.3 Execution Sinks
An interesting variation of the Function sink is:
[].constructor.constructor(alert(1))
Object Array Function XSS Vector
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.38
4.2.2.4 Pseudo-protocols
javascript: is an "unofficial URI scheme", commonly
referred as a pseudo-protocol. It is useful to invoke
JavaScript code within a link.
A common pattern recognized by most filters is
javascript keyword followed by a colon character (:)
Blocked!!
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.39
http://tools.ietf.org/html/draft-hoehrmann-javascript-scheme-03
4.2.2.4 Pseudo-protocols
Note: javascript: is not needed on event handlers; so, we
should avoid using it. Since the pseudo-protocol is often
introduced within a string, we can use all the variations
seen before.
Let’s check out some examples.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.40
4.2.2.4 Pseudo-protocols
Blocked!!
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.41
4.2.2.4 Pseudo-protocols
In addition to javascript:, there are also data: (RFC
2397) and the Internet Explorer exclusive vbscript:.
Let’s see how they work.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.42
http://tools.ietf.org/html/rfc2397
4.2.2.4.1 Pseudo-protocols > data:
The data URI scheme allows for the inclusion of small data
items served with different media types. This is the
structure form:
data:[][;base64],
The media type that mainly interests us is text/html, and
the base64 indicator, which allows us to encode our data.
Let’s see some implementations.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.43
4.2.2.4.1 Pseudo-protocols > data:
Blocked!!
If javascript: is blocked:
Base64 encoded
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.44
4.2.2.4.1 Pseudo-protocols > data:
Blocked!!
If data: is blocked:
etc..
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.45
4.2.2.4.2 Pseudo-protocols > vbscript:
The vbscript pseudo-protocol is not so common since it
can only be used on Internet Explorer.
From the IE11 in Edge mode, VBScript is no longer
supported for the Internet zone. Let’s check out some
scenarios.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.46
http://msdn.microsoft.com/en-us/library/ie/dn384057(v=vs.85).aspx
4.2.2.4.2 Pseudo-protocols > vbscript:
To invoke VBScript, we may use vbscript:, as well as vbs:
 Works till IE8
 Works till IE Edge
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.47
4.2.2.4.2 Pseudo-protocols > vbscript:
Unlike JavaScript, till version 8 the code is case insensitive.
This is very useful when the application transforms the
input.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.48
4.2.2.4.2 Pseudo-protocols > vbscript:
Blocked!!
If the vbscript: is blocked, we could use the usual encoding
techniques:
etc…
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.49
4.2.2.4.2 Pseudo-protocols > vbscript:
Blocked!!
But do not forget that IE is NUL bytes friend!!
NULL NULL NULL
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.50
4.2.2.4.2 Pseudo-protocols > vbscript:
An old feature that Microsoft provided was the
Script Encoder tool. This feature allows us to obfuscate
VBScript and JScript code, and was originally designed to
prevent users from inspecting client-side script code.
The command-line utility (srcenc) is only available in older
versions of Windows. Online there are some tools for this
purpose; for example, Scripts Encryptor.
http://msdn.microsoft.com/en-us/library/cbfz3598(v=vs.84).aspx WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.51
http://dennisbabkin.com/screnc/
4.2.2.4.2 Pseudo-protocols > vbscript:
Works till IE8
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.52
You’ve been studying quite
intently. We recommend taking
a quick break and come back
refreshed. ^_^
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.53
4.3
Bypassing
Sanitization
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.54
4.3 Bypassing Sanitization
Often, security mechanisms choose to sanitize potential
XSS vectors instead of blocking the entire request. These
are probably the most common filters we may encounter
during our tests.
For example, the most common is to HTML-encode some
key characters, such as  (&gt;), etc. This is not
always enough and depends in which point of the page the
untrusted data is injected.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.55
4.3.1 String Manipulations
In some situations, a filter may manipulate your vector by
removing malicious keywords. For example, removing the
tags.
A common mistake with this behavior is that the rule
removes only the first instance of the matched expression.
WAPTXv2: Section 01, Module 04 -Caendra Inc. © 2020| p.56
4.3.1.1 Removing HTML Tags
For example,  is correctly
sanitized to alert(1), but since the check is not performed
recursively:
 tag, then the next one and so
on, without restarting again from the first to check if there
are no more malicious strings.