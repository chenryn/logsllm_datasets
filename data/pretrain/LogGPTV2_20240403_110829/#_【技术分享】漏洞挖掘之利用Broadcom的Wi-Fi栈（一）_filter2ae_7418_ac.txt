### 优化后的文本

#### 图18
该情况看起来较为简单——我们无需担心在溢出前验证存储在FTIE中的值，因为这些值都在缓冲区范围内。相反，攻击者控制的部分只是不需要任何验证的备用数据，因此可以自由选择。不过，溢出的程度非常有限，最多只能多写25个字节超出缓冲区范围。

**编写利用代码**

#### 研究堆状态
现在我们已经了解了手头的原语，是时候测试我们的假设是否与实际情况相符了。为此，我们需要一个测试平台，能够发送专门设计的帧以触发溢出。回想一下，`wpa_supplicant` 是一个完全支持 TDLS 的开源可移植请求者，这使其成为我们研究平台的首选。我们可以使用 `wpa_supplicant` 作为基础来设计我们的帧，从而避免重新实现建立和维护 TDLS 连接所需的所有逻辑。

为了测试这些漏洞，我们将修改 `wpa_supplicant`，使其能够发送包含过大 FTIE 的 TDLS 断开帧。查看 `wpa_supplicant` 的代码后，我们可以快速识别负责生成和发送断开帧的函数 `wpa_tdls_send_teardown`。通过对此函数进行一些小的更改（如图所示），我们应该能够在收到断开帧时触发溢出，导致超写 25 个字节的 `0xAB`。

#### 图19
接下来，我们需要与 `wpa_supplicant` 交互，以建立和断开与目标设备的 TDLS 连接。`wpa_supplicant` 支持多种命令接口，包括一个名为 `wpa_cli` 的命令行实用程序，这非常方便。此命令行接口还支持若干暴露 TDLS 功能的命令：
- `TDLS_DISCOVER`：发送“TDLS 发现请求”帧并列出响应。
- `TDLS_SETUP`：建立与具有给定 MAC 地址的对等体的 TDLS 连接。
- `TDLS_TEARDOWN`：断开与具有给定 MAC 地址的对等体的 TDLS 连接。

实际上，在编译支持 TDLS (`CONFIG_TDLS`) 的 `wpa_supplicant`、建立网络并将我们的目标设备和研究平台连接到网络后，我们可以看到发出 `TDLS_DISCOVER` 命令是有效的，确实可以识别我们的对等体。

#### 图20
我们现在可以发送一个 `TDLS_SETUP` 命令，然后发送我们专门设计的 `TDLS_TEARDOWN`。如果一切正常，这应该会触发溢出。然而，这提出了一个稍微复杂的问题——我们如何得知溢出的发生？可能的情况是我们溢出的数据未被使用，或者固件崩溃时默默重启，让我们一无所知。

为了充分回答这个问题，我们需要了解 Broadcom 堆实现背后的逻辑。深入分析分配器的逻辑，我们发现它是一个简单的“最佳匹配”分配器，执行向前和向后合并，并保持一个空闲块单链表。当分配块时，从最适合的空闲块（足够大的最小块）的末端（最高地址）对其进行切取。堆块具有以下结构：

#### 图21
（回想一下，Cortex R4 是一款 32 位 ARM 处理器，所以所有字节都以低字节序存储）

通过对分配器的实现进行逆向工程，我们还可以找到指向 RAM 中第一个空闲块头的指针的位置。将这两个事实结合在一起，我们可以创建一个实用程序，在给出固件 RAM 转储的情况下，绘制堆的空闲列表的当前状态。使用 `dhdutil` 的“upload”命令可以轻松获取固件的 RAM 快照。

在编写了一个遍历堆的空闲列表并将其内容导出为 dot 文件的小型可视化脚本后，我们可以使用 graphviz 绘制空闲列表的状态，如下所示：

#### 图22
现在我们可以发出专门设计的 `TDLS_TEARDOWN` 帧，立即生成固件 RAM 的快照，并检查空闲列表是否有任何损坏迹象：

#### 图23
事实上，在断开连接后，空闲列表中的其中一个块的大小突然异常大。由于分配器使用“最佳匹配”，这意味着只要存在其他足够大的空闲块，后续分配将不会被放置在此块中。这也意味着固件不会崩溃，实际上会继续正常运行。如果我们不可视化堆的状态，我们就根本无法确定发生了什么事。

无论如何，现在我们已经确认了溢出确实发生了，接下来进入开发的下一阶段。我们需要巧妙的工具，以便能够在建立和断开期间监测堆的状态。为此，将固件中的 `malloc` 和 `free` 函数结合在一起，并追踪其参数和返回值是不错的选择。

首先，我们需要编写一个“补丁程序”，这将使我们可以在给定的 RAM 驻留函数上插入挂钩。要注意，`malloc` 和 `free` 函数都存在于 RAM 中（它们是 RAM 代码块中的第一个函数）。这使我们可以自由地重写其序言，以便为我们自己的代码引入一个分支。我写了一个执行此类挂钩插入的补丁程序，从而可以在调用挂钩函数之前和之后执行小的程序集存根。

简而言之，修补程序是相当标准的——它将补丁的代码写入 RAM 中的一个未使用的区域（堆中最大的空闲块的头），然后从挂钩函数的序言将 Thumb-2 宽分支插入挂钩本身。

#### 图24
使用我们的新修补程序，我们现在可以调用 `malloc` 和 `free` 函数，以添加踪迹，使我们能够跟踪堆上发生的每个操作。然后可以通过发出 `dhdutil` 的“consoledump”命令，从固件的控制台缓冲区中读取这些跟踪。请注意，在一些较新的芯片上，此命令无效。这是因为 Broadcom 忘记给指向控制台的数据结构的固件中的 magic 指针添加偏移量。您可以通过向驱动程序添加正确的偏移量或将 magic 值和指针写入列表中的探测内存地址之一来解决此问题。

无论如何，您可以在此处找到 `malloc` 和 `free` 挂钩以及从固件中解析踪迹所需的相关脚本。

使用新获取的踪迹，我们可以编写一个更好的可视化程序，使我们能够在整个建立和断开阶段跟踪堆的状态。该可视化程序可以看到堆上发生的每个操作，从而提供更细粒度的数据。我写了这样一个可视化程序（请见 [链接]）。

我们来看看建立 TDLS 连接时的堆活动：

#### 图25
纵轴表示时间——每行都是 `malloc` 或 `free` 操作后新的堆状态。横轴表示空间——较低地址在左，较高地址在右。红色块表示正在使用的块，灰色块表示空闲块。

从上面可以清楚看到，建立 TDLS 连接是一个混乱的过程。对于大小区域有很多的分配和释放。这么多的噪音对我们来说并不利。回想一下，在建立阶段的溢出是高度受限制的，无论是在写入数据方面，还是在溢出数据的范围方面。此外，溢出发生在建立阶段许多分配之一过程中。这不允许我们在触发溢出之前对堆的状态进行很多的控制。

然而，退一步看，我们可以观察到一个相当令人惊讶的事实。除了在 TDLS 连接建立期间的堆活动，似乎在堆上几乎没有任何活动。事实上，结果表明发送和接收的帧是从共享池而不是堆中提取的。不仅如此，其处理不会导致堆操作——一切都是“就地”完成。即使尝试通过发送包含异常位组合的随机帧来有意地导致分配，固件的堆仍然在很大程度上不受影响。

这有利也有弊。一方面，这意味着堆的结构是高度一致的。在鲜有的数据结构分配事件中，其随后被立即释放——使堆回到了原始状态。另一方面，这意味着我们对堆结构的控制程度相当有限。在大多数情况下，在固件初始化之后，无论堆有什么样的结构，我们都要应付。

也许我们应该看看断开阶段？实际上，在 TDLS 断开阶段激活踪迹表明，在触发溢出之前非常少，所以其看起来像是一个更方便的探索环境。

#### 图26
虽然这些深入的踪迹对于获取堆状态的高级视图很有用，但它们很难被破译。事实上，在大多数情况下，只需要对堆的单个快照进行可视化即可，就像我们之前使用 graphviz 可视化程序所作的一样。在这种情况下，让我们通过允许堆可视化程序根据堆的单个快照生成详细的图形输出来改进我们以前的堆可视化程序。

正如我们之前看到的，我们可以“遍历”空闲列表来提取每个空闲块的位置和大小。此外，我们可以通过遍历空闲块之间的间隙及从每个使用中的块读取“大小”字段来推断使用中的块的位置。我写了另一个完成此工作的可视化程序（请见 [链接]）——从一系列“快照”镜像生成堆状态的可视化。

现在可以使用该可视化程序查看建立 TDLS 连接后堆的状态。这将是我们在断开阶段触发溢出时需要处理的堆的状态。

#### 图27
我们可以看到，在建立 TDLS 连接之后，大多数堆的使用的块是连续的，但也形成了两个孔，其中一个大小为 `0x11C`，另一个大小为 `0x124`。激活断开阶段的踪迹后可以看到发生了以下分配：

#### 图28
突出显示的行表示为断开帧的 MIC 计算分配的 256 字节缓冲区，我们可以使用我们的漏洞造成同等大小的溢出。此外，在发送溢出帧之前，似乎堆活动相当低。将上面的堆快照与踪迹文件相结合，我们可以推断出 256 字节缓冲区最适合的块位于 `0x11C` 字节的孔中。这意味着使用我们的 25 字节溢出，我们可以覆写：
1. 下一个使用中的块的 header
2. 下一个使用中的块的内容的几个字节

我们来仔细看看下一个使用中的块，看看是否有什么有趣的信息可以覆写：

#### 图29
下一个块几乎为空（除靠近其 head 的几个指针外）。这些指针对我们是否有用？也许其是写入对象？或是后期释放？我们可以通过手动破坏这些指针（将它们指向无效的存储器地址，例如 `0xCDCDCDCD`）以及检测固件的异常向量（以查看其是否崩溃）来找到答案。不幸的是，经过多次这样的尝试，发现这些指针实际上均未被使用。

这使我们只剩下一个可能性——破坏使用中的块的“大小”字段。回想一下，一旦 TDLS 连接断开，与之相关的数据结构将被释放。释放大小我们已经损坏的使用中的块会产生许多有趣的后果。如果我们减小块的大小，我们可以有意地“泄漏”缓冲区的尾端，使其永远保持不可分配。不过，更有趣的是，我们可以将块的大小设置为更大的值，从而导致下一个释放操作创建一个尾端与另一个堆块重叠的空闲块。

#### 图30
一旦一个空闲块与另一个堆块重叠，则随后的分配（重叠的自由块是最适合的块）将从空闲块的末端切取，从而可破坏其尾部的任何字段。但是，在开始构思之前，我们需要确认在断开操作完成后我们可以创建这样的状态（即重叠的块）。