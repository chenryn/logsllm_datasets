图18
这似乎更简单——我们不需要担心在溢出之前验证的存储在FTIE中的值，因为其全部放置在缓冲区的范围内。相反，攻击者控制的部分只是不需要进行任何验证的备用数据，因此可以由我们自由选择。也就是说，溢出的程度是非常有限的，我们最多只能多写超过缓冲区范围的25个字节。
**编写利用代码**
研究堆状态
现在我们已了解了手头的原语，是时候来测试我们的假设是否与现实符合了。为此，我们需要一个测试台，使我们能发送专门设计的帧，从而触发溢出。回想一下，wpa_supplicant是一个完全支持TDLS的开源可移植请求者。这使它成为我们研究平台的首选。我们可以使用wpa_supplicant作为基础来设计我们的帧。这样我们就无需重新实现建立和维护TDLS连接所需的所有逻辑。
为了测试这些漏洞，我们将修改wpa_supplicant，以使我们能发送包含过大FTIE的TDLS断开帧。查看wpa_supplicant的代码可快速识别负责生成和发送断开帧的函数wpa_tdls_send_teardown。通过对该函数添加一些小的更改（绿色），我们应该能够在收到断开帧时触发溢出，导致超写25个字节的0xAB：
图19
现在，我们只需要与wpa_supplicant进行交互，以建立和断开与目标设备的TDLS连接。wpa_supplicant支持很多命令接口，包括一个名为wpa_cli的命令行实用程序，这非常方便。此命令行接口还支持若干暴露TDLS功能的命令：
TDLS_DISCOVER – 发送“TDLS发现请求”帧并列出响应
TDLS_SETUP – 建立与具有给定MAC地址的对等体的TDLS连接
TDLS_TEARDOWN – 断开与具有给定MAC地址的对等体的TDLS连接
实际上，在编译支持TDLS
(CONFIG_TDLS)的wpa_supplicant、建立网络、将我们的目标设备和我们的研究平台连接到网络后，我们可以看到发出TDLS_DISCOVER命令是有效的，我们确实可以识别我们的对等体。
图20
我们现在可以发送一个TDLS_SETUP命令，然后发送我们专门设计的TDLS_TEARDOWN。如果一切正常，这应该会触发溢出。然而，这提出了一个略微更微妙的问题——我们如何得知溢出的发生？可能的情况是我们溢出的数据未被使用，或者，当固件崩溃时，其默默重新启动，让我们一无所知。
为了充分回答这个问题，我们需要了解Broadcom堆实现背后的逻辑。深入分析分配算符的逻辑，我们发现其非常简单，其是一个简单的“最适合”分配算符，其执行向前和向后合并，并保持一个空闲块单链表。当分配块时，从最适合空闲块（足够大的最小块）的末端（最高地址）对其进行切取。堆块具有以下结构：
图21
（回想一下，Cortex R4是一款32位ARM处理器，所以所有字节都以低字节序存储）
通过对分配算符的实现进行逆向工程，我们还可以找到指向RAM中第一个空闲块头的指针的位置。将这两个事实结合在一起，我们可以创建一个在给出固件的RAM的转储的情况下可绘制堆的空闲列表的当前状态的实用程序。通过使用dhdutil的“upload”命令可以轻松获取固件的RAM快照。
在写了一个遍历堆的空闲列表并将其内容导出为dot的小型可视化脚本后，我们可以使用graphviz绘制空闲列表的状态，如下所示：
图22
现在我们可以发出专门设计的TDLS_TEARDOWN帧了，立即生成固件RAM的快照，并检查空闲列表是否有任何损坏迹象：
图23
事实上，在断开连接后，空闲列表中的其中一个块的大小突然异常大。回想一下，由于分配算符使用“最适合”，这意味着只要存在其他足够大的空闲块，后续分配将不会被放置在此块中。这也意味着固件不会崩溃，实际上会继续正常运行。如果我们不可视化堆的状态，我们就根本无法确定发生了什么事。
无论如何，现在我们已经确认了溢出事实上已经发生了，现在是转到开发的下一阶段了。我们需要巧妙的工具，以便能够在建立和断开期间监测堆的状态。为此，将固件中的malloc和free函数结合在一起，并追踪其参数和返回值是不错的选择。
首先，我们需要编写一个“补丁程序”，这将使我们可以在给定的RAM驻留函数上插入挂钩。要注意，malloc和free函数都存在于RAM中（它们是RAM的代码块中的第一个函数）。这使我们可以自由地重写其序言，以便为我们自己的代码引入一个分支。我写了一个执行此类挂钩插入的补丁程序，从而可以在调用挂钩函数之前和之后执行小的程序集存根。
简而言之，修补程序是相当标准的 –
它将补丁的代码写入RAM中的一个未使用的区域（堆中最大的空闲块的头），然后从挂钩函数的序言将Thumb-2宽分支插入挂钩本身。
图24
使用我们的新修补程序，我们现在可以调用malloc和free函数，以添加踪迹，使我们能够跟踪堆上发生的每个操作。然后可以通过发出dhdutil的“consoledump”命令，从固件的控制台缓冲区中读取这些跟踪。请注意，在一些较新的芯片上，此命令无效。这是因为Broadcom忘记给指向控制台的数据结构的固件中的magic指针添加偏移量。您可以通过向驱动程序添加正确的偏移量或将magic值和指针写入列表中的探测内存地址之一来解决此问题。
无论如何，您可以在此处找到malloc和free 挂钩以及从固件中解析踪迹所需的相关脚本。
使用新获取的踪迹，我们可以编写一个更好的可视化程序，使我们能够在整个建立和断开阶段跟踪堆的状态。该可视化程序可以看到堆上发生的每个操作，从而可提供更细粒度的数据。我写了这样一个可视化程序（请见： ）。
我们来看看建立TDLS连接时的堆活动：
图25
纵轴表示时间——每行都是malloc或free操作后新的堆状态。横轴表示空间——较低地址在左，较高地址在右。红色块表示正在使用的块，灰色块表示空闲块。
从上面可以清楚看到，建立TDLS连接是一个凌乱的过程。对于大小区域均有很多的分配和释放。这么多的噪音对我们来说并不利。回想一下，在建立阶段的溢出是高度受限制的，无论是在写入数据方面，还是在溢出数据的范围方面。此外，溢出发生在建立阶段许多分配之一过程中。这不允许我们在触发溢出之前对堆的状态进行很多的控制。
然而，退一步，我们可以观察到一个相当令人惊讶的事实。除了在TDLS连接建立期间的堆活动，似乎在堆上几乎没有任何活动。事实上，结果表明发送和接收的帧是从共享池而不是堆中提取的。不仅如此，其处理不会导致堆操作——一切都是“就地”完成。即使尝试通过发送包含异常位组合的随机帧来有意地导致分配，固件的堆仍然在很大程度上不受影响。
这有利也有弊。一方面，这意味着堆的结构是高度一致的。在鲜有的数据结构分配事件中，其随后被立即释放——使堆回到了原始状态。另一方面，这意味着我们对堆结构的控制程度相当有限。在大多数情况下，在固件初始化之后，无论堆有什么样的结构，我们都要应付。
也许我们应该看看断开阶段？实际上，在TDLS断开阶段激活踪迹表明，在触发溢出之前非常少，所以其看起来像是一个更方便的探索环境。
图26
虽然这些深入的踪迹对于获取堆状态的高级视图很有用，但是它们很难被破译。事实上，在大多数情况下，只需要对堆的单个快照进行可视化即可，就像我们之前使用graphviz可视化程序所作的一样。在这种情况下，让我们通过允许堆可视化程序根据堆的单个快照生成详细的图形输出来改进我们以前的堆可视化程序。
正如我们之前看到的，我们可以“遍历”空闲列表来提取每个空闲块的位置和大小。此外，我们可以通过遍历空闲块之间的间隙及从每个使用中的块读取“大小”字段来推断使用中的块的位置。我写了另一个完成此工作的可视化程序（请见https://bugs.chromium.org/p/project-zero/issues/detail?id=1046#c6）——从一系列“快照”镜像生成堆状态的可视化。
现在可以使用该可视化程序查看建立TDLS连接后堆的状态。这将是我们在断开阶段触发溢出时需要处理的堆的状态。
（上层：初始堆状态，下层：建立TDLS连接后的堆状态）
图27
我们可以看到，在建立TDLS连接之后，大多数堆的使用的块是连续的，但是也形成了两个孔，其中一个大小为0x11C，另一个大小为0x124。激活断开阶段的踪迹后可以看到发生了以下分配：
图28
突出显示的行表示为断开帧的MIC计算分配的256字节缓冲区，我们可以使用我们的漏洞造成同等大小的溢出。此外，在发送溢出帧之前，似乎堆活动相当低。将上面的堆快照与踪迹文件相结合，我们可以推断出256字节缓冲区最适合的块位于0x11C字节的孔中。这意味着使用我们的25字节溢出，我们可以覆写：
1\. 下一个使用中的块的header
2\. 下一个使用中的块的内容的几个字节
我们来仔细看看下一个使用中的块，看看是否有什么有趣的信息可以覆写：
图29
下一个块几乎为空（除靠近其head的几个指针外）。这些指针对我们是否有用？也许其是写入对象？或是后期释放？我们可以通过手动破坏这些指针（将它们指向无效的存储器地址，例如0xCDCDCDCD）以及检测固件的异常向量（以查看其是否崩溃）来找到答案。不幸的是，经过许多这样的尝试，发现似乎这些指针实际上均未被使用。
这使我们只剩下一个可能性——破坏使用中的块的“大小”字段。回想一下，一旦TDLS连接断开，与之相关的数据结构将被释放。释放大小我们已经损坏的使用中的块会产生许多有趣的后果。如果我们减小块的大小，我们可以有意地“泄漏”缓冲区的尾端，使其永远保持不可分配。不过，更有趣的是，我们可以将块的大小设置为更大的值，从而导致下一个释放操作创建一个尾端与另一个堆块重叠的空闲块。
图30
一旦一个空闲块与另一个堆块重叠，则随后的分配（重叠的自由块是最适合的块）将从空闲块的末端切取，从而可破坏其尾部的任何字段。但是，在开始构思之前，我们需要确认在断开操作完成后我们可以创建这样的状态（即重叠的块）。