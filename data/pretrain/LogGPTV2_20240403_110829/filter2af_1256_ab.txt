mbn，每块长度为243。 Curl-P不使用消息填充，如果一条消息的长度不是243的倍数，允许最后一个消息块小于243。4（3）每个消息块mb0 · ·
· mbn依次被复制到状态S的前三分之一，并由函数f r进行转换。 （4）当没有消息块之后，Curl-P返回最终状态的前三分之一。有关更详细的描述，请参阅算法1。
现在来看负责转换状态S的函数fr 。转换函数fr 就是将f函数递归调用r次，例如f 3(S) = f (f (f (S)))。
Curl-P-27就是Curl-P哈希函数，其变换函数是f27。
调用一次fr 就能获得S的新状态。 如算法2中所述，初始状态中的每相邻两位符码通过简单函数g的转换，变成新状态中的一位数字。
当前状态中的每一位都会被使用两次，一次作为g的第一个参数（由a表示），一次作为g的第二个参数（由b表示）。 在表1中，我们给出g作为替换表（s-box）。
### 4 Curl-P的密码分析
在本节中，我们应用常见的差分密码分析法来构造完全碰撞。我们构造两条相同长度的消息，设置他们只有一个符码不同，而且他们通过 Curl-P-27
会映射到相同的值。我们可以控制碰撞消息的内容，包括任意消息前缀和后缀。在下一节中，我们将利用他们来伪造有效IOTA支付的签名。
除了IOTA开源项目发布的一部分源代码，我们无法找到 Curl-P 或 Curl-P-27 的正式规范文档。此外，IOTA开发人员表示，Curl-P-27
旨在对特定的输入组[5]进行碰撞。事实上，Curl-P-27 是非随机的。正如[10]中详细探讨的那样，可以在相同长度的消息中观察到 Curl-P-27
的非随机行为；碰撞和第二个预成像对于生成不同长度的消息是微不足道的。因此，为了确保我们真正破解了 Curl-P-27，我们表明我们的碰撞攻击破坏了
Curl-P-27 的安全属性（参见第5节）。
在高层次上，我们的攻击工作如下所示。我们选择两条长度至少为三个消息块的消息，并且他们只有一位符码不同。为了降低困难，我们使这两条消息满足某些约束方程（在第
4.2
节中详细说明）。一旦我们进入包含不同符码的消息块，我们就需要确保会发生碰撞。为此，我们在两个消息中随机翻转一组三进制数，并且每组不能超出其所在的消息块。我们的思路是对两条消息做变换处理，并且使不同的那一位在转换完成后处于结果状态的前三分之一的位置。
f 27(S)[243,729] = f27(S‘)[243,729]
因为Curl-P用下一个消息块替换了S的前三分之一，这导致原本的差异被覆盖，造成完全碰撞。我们利用Curl-P-27的不同特性多次强制转换函数，这样的话，在最后一轮时这些差异可能还保持在状态的前三分之一。经过多轮转换之后还保持着一位差异，找到这样的两条消息需要调用Curl-P-27次数的上限是760
万次或 22287次。
在图2中，我们可以看到在Curl-P-27中，不同的轮数会导致不同的结果。我们用颜色代表发生碰撞的可能性，x轴表示差异点的位置，y轴表示在该轮数内差异没有扩散。我们对每个位置和深度执行100个样本（总共11
243 100 = 267300个样本），每个样品随机初始化，差异点的内容设置也是随机的。更多数学分析请参阅[10]中的复现。
我们设置差异符码出现在第 17
位。根据实验结果，知道了轮次和差异点的位置，我们可以计算碰撞的概率。在此条件下递归20次后，碰撞的概率是1.0。因此，只要我们保证差异不会扩散，我们就可以制造碰撞。这种攻击应该同样适用于输入的消息块中的其他位置（如[10]所示）。请注意，这是确保发生碰撞的上限，因为递归次数少于20次时也可能发生碰撞。
#### 4.1 Curl-P变换函数f r的不同性质
在本节中，我们将展示如何找到目标状态，将差异保持至少20轮。这需要我们分析Curl-P变换函数f的不同性质。
差分密码分析涉及研究两组及两组以上的输入之间的差异传播模式。最常见的技术是寻找差异轨迹。差异轨迹是一组概率偏差，表示一组差异如何通过多轮加密函数传播到另一组差异。这里我们只使用特定的差异轨迹，即在转换函数f的重复应用下,两个状态S，S‘之间的某一位的差异。我们证明了
Curl-P 强烈偏向于保持一轮的单符码差异（即f的应用）。
首先介绍其中涉及的术语。由于Curl-P使用三进制符码∈{?1,0,1}，我们必须使用新的三元符号表示法。为了表示两个符码 x 和 x'
之间的差异，我们使用Θ ( 0Θ ?1 代表 x = 0 ，x’ = ?1 或者 x = ?1 ， x‘ =
0)。通过术语扩散，我们指出在调用f之后，两个状态之间的差异的数量已经增加（即，差异已被使用）。
我们的攻击是围绕着一个事实，即s-box g不会一直传播差异。例如，考虑g的两组输入和输出：g: a,b,c and a‘, b’, c‘ such
that g( a, b ) = c and g( a', b' ) = c'。我们做出以下观察：
1.对于所有可能的值，如果 a ≠ a' 且 b = b'，那么 c ≠ c' 。
2.如果a = a' 且 b ≠ b'，则可能有 c = c' 或 c≠c'（例如，a = a'= 1，b = 0且b' = 1，则c = c' = 0）。
每调用一次 f 就是更新一次状态。如3.3节所述，g
中每两位符码经过转换以后变成新状态中的一位符码。先前状态的每一位最多被转换两次：一次作为第一个变量a，一次作为第二个变量b。这意味着单位符码差异将延续到下一轮，因为当它是s-box
g的第一个变量a时，g的输出将与a不同（如图1所示）。因此，如果将f应用于两个状态S，S'，更新后的状态f（S），f（S'）将始终有一位或两位的不同，不会出现无符码差异。
我们模拟了状态在k轮Curl-P后保持单位符码差异的概率。 如图3所示，此马尔可夫模型列举出了所有可能的输入与其转换后的结果。 例如，如果当前的差异为
0Θ1，那么它有 1/9 的概率在下一轮中保持不变（即0 1），2/9 的概率变为 -1Θ0，或者有 6/9
的概率使差异个数从1增加到2（标记为失败状态，因为它未能保持单符码差异）。
顶行表示 0Θ1 的转换到各个结果的概率，第二行是 -1Θ0，第三行 -1Θ1，第四行是差异由一位变为两位。使用这个矩阵，我们计算了在调用 k 次 f
之后差异保持一位的概率的下界，因为我们没有计算差异位数超过 1 位之后再变回1位的情况，所以这是一个下限。
因此，从 0Θ1 开始，通过将矩阵提高到我们希望的轮数并计算概率。例如我们将矩阵幂 3 次，那么得到的矩阵中的数字就是符码在转换 3
次以后变成对应新符码的概率。因此，我们可以测量k轮后也不失败的概率。
之前，我们通过实验验证了，如果经过 20 轮
Curl-P-27（即调用20次f）转换仍保持单符码差异，那么碰撞的概率是1.0。使用我们的状态转移矩阵，我们计算20轮，我们的攻击有一个每个查询成功概率下限为
2-42。也就是说，我们需要尝试242次才有可能找到将差异保持到20轮以后的消息对，这样的消息对可以产生碰撞。在下一节中，我们将展示如何显着减少对
Curl-P-27 的必要查询次数。
4.2差分求解
在本节中，我们将展示如何通过选择具有特定属性的消息来减少 Curl-P-27 的查询次数。我们首先展示如何约束有一位差异符码的状态 S 和
S‘，使得他们需要至少9次递归才能保持一位的差异（即差异没有扩散）。为此，我们将f表示为方程组，并求解状态S和S’中的特定值。
我们可以将变换函数f r(S) 表示为一系列方程。例如，调用一次 f 可以写为
f (S)0 = g(S0,S364),f (S)1 = g(S364,S728),...,f (S)728 = g(S365,S0)
其中f
(S)0是调用f后获得的新状态的第0位的数字。由于每一轮只是f的递归应用，我们可以根据状态S的初始值在f轮后写出特定位的值。我们使用上标来表示轮次。例如，用
f 2(S)6 = g(g(S366,S1),g(S184,S548))
表示在位置6进行两次递归运算。
使用这种表示，我们找到可以使得 0Θ1 的差异保持9轮的方程。然后我们找到满足这些方程的消息前缀。
目前，我们可以在一秒之内查找到此消息前缀（有关我们的性能评估，请参见第 5.3 节）。
另外，给定一个特定的消息模板，我们只需要在两个消息块中更改一小组三进制位，便可以将其转换为令人满意的消息。
#### 4.3 寻找碰撞
攻击需要至少3个信息块：mba, mbb, 和
mbc。其中mbb含有一个差异符码。mba前面的消息块数量没有限制，mba和mbb之间也没有，mbc总是跟在mbb之后并且重写mbb在前三分之一制造的差异。mbc的取值不会对攻击造成影响，可以取任意值。
完整的攻击过程如下。首先，在我们攻击的约束阶段，我们通过调整mba和mbb来找到合适的消息前缀，这样它们可以保证 9 轮的单位符码差异。
接下来，在蛮力阶段，我们在mbb中的特定位置随机改变符码，目的是找到两个消息，使得从位置 17 开始的差异保持 20 轮。
由于约束阶段确保蛮力阶段的每次尝试在 9 轮中保持单符码差异不同，因此蛮力阶段的攻击复杂性从 20 轮减少到 11 轮。
结果，每个查询的成功率的下限减少到大约2 -22.87或 760 万分之一。
正如差分密码所分析的，我们的概率计算简化了假设，即输入值是均匀随机的。考虑到 Curl-P-27 的低扩散率和Curl-P
的非随机性，这种假设可能不会总是成立。 但是，如第 5.3 节所示，本节给出的界限与实际结果相当接近。
### 5 利用Curl-P中的碰撞来伪造签名
本节中，我们将使用Curl-P-27碰撞对IOTA签名方案（ISS）执行签名伪造攻击。结合上一节的内容，我们将展示如何创建两个有效的IOTA
bundle（即支付），这两个bundle最多只有两位不同，并且他们具有相同的Curl-P-27哈希值。然后，我们将描述攻击的设置，利用这些碰撞的
bundle 来伪造签名。最后，我们将展示如何攻击ISS多重签名。
#### 5.1 对ISS的选择消息攻击
我们的攻击是一种选择消息攻击，恶意用户 Eve
欺骗用户Alice，先是要求Alice签署b1，然后根据b1生成相应的b2，这个b2也能通过验证。具体过程如下：
  1. Alice生成密钥对（PK, SK）。
  2. Eve通过碰撞攻击产生两个bundle b1，b2，并使得 b1 ≠ b2 且 CurlHash（b1）= CurlHash（b2）。
  3. Eve将b1发送给Alice并要求Alice签名。Alice检查b1，确认它是安全的。
  4. Alice在夏娃上给b1签名，即Sign（SK, b1）→ σ。
  5. Eve产生一个bundle对（σ，b2），使得 b1≠b2，b2是一个有效的 bundle，就算 Alice从未见过b2，b2也能够通过Alice的公钥验证。
在4.3节中，我们介绍了攻击的一般格式，它至少需要三个消息块 mba，mbb和mbc。 为了执行攻击的第一阶段，我们将 mba 和 mbb