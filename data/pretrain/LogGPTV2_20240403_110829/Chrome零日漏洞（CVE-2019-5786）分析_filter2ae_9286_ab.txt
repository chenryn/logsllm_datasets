### 3.3 寻找漏洞触发点
现在，我们已经下载了一个尚未补丁的Chromium版本，并且已经知道如何用调试器去附加调试它。接下来编写一段JavaScript代码，来看看是否能够到达我们所关注的代码位置。
代码如下：
为了总结这将发生的事情，上述代码中我们创建了一个Blog对象用于传递给FileReader。此外，我们还注册了progress事件的一个回调函数onProgress，并当该事件触发的时候，我们还试图多次访问FileReader返回值。在之前的文中，我们已经知道，数据需要被完全加载（这就是我们检查缓冲区大小的原因），并且如果我们使用同一个ArrayBuffer获得多次DOMArrayBuffer,
JavaScript中他们看起来应该是多个分离对象（相等测试）。最后，为确认我们已经有两个指向同一个缓冲区的不同对象，我们创建了两个视图对象并修改数据，结果验证了如果修改一个对象，另一个对象也随之改变。
在此，我们没有预见到，发生了一个令人非常遗憾的问题：progress事件其实并不是经常性的会被调用，导致我们必须加载一个非常大的数组，用以强制进程花销一些时间并多次触发progress事件。也许，会存在比上述做法更好的技术方法（可能谷歌的漏洞报告中会揭露一个好方法）。但是，所有创建慢速加载的对象的尝试都失败了（比如使用Proxy，扩展Blob类等…）。或者我们可以把数据加载与一个Mojo管道绑定，因此使用MojoJS看起来是一个拥有更多控制的好方法，但是在实际的攻击场景中却似乎不切实际。有关该方法的示例，可查看[链接](https://www.exploit-db.com/exploits/46475)。
### 3.4 导致崩溃
到此，既然我们已清楚了如何进入存在漏洞的代码路径，那么我们又该如何来利用这个漏洞呢？这绝对是最难回答的问题，本段旨在分享找到该问题答案的过程。
我们已经看到底层的ArrayBuffer会被引用计数，所以如果只是通过从已获得的一些DOMArrayBuffer中进行垃圾内存搜集的方法，我们无法对其进行释放。使引用计数溢出，这听起来是一个非常有趣的想法。但是，如果我们通过手动修改引用计数值为接近其最大值（比如通过x64dbg），再来看看会发生什么…。好吧，进程崩溃了。最终，我们无法对这些ArrayBuffer做更多的事情；我们能修改它们的内容，却不能修改它们的大小，除非我们能手动释放它们…
如果对这些代码库不是很熟悉的话，最好的方法就是去查阅各种提及了use-after-free、ArrayBuffer等关键词的漏洞报告。去看看别人都做了什么，谈论了什么。必须假设在某个地方一定存在一个拥有底层内存的DOMArrayBuffer对象，这也是一个我们知道的并努力实现的假设。
经过一些网络搜索，我们发现了一些很有趣的评论，比如[链接1](https://bugs.chromium.org/p/v8/issues/detail?id=2802)和[链接2](https://bugs.chromium.org/p/chromium/issues/detail?id=761801)。这两个链接讨论了DOMArrayBuffer被外部化（externalized）、被转移（transferred）以及被阉割（neutered）的各种情况。对上述这些术语我们不是很清楚，但是从上下文结合来看，当上述情况发生时，内存的所属权就转移到了其他人身上。这听起来非常完美，因为我们希望底层缓冲区能被释放（就像我们急切的在寻找一个use-after-free漏洞一样）
WebAudio中存在的use-after-free漏洞向我们展示了如何让我们的ArrayBuffer发生“转移”，所以让我们试试吧！
在调试器下可以看到：
图中我们可以看到，被解除的内存引用的地址保存在ECX中（我们看到EAX=0,这是因为我们正在该视图对象中寻找第一个选项）。该地址看起来有效，但是事实却并非如此。ECX指向数组缓冲区的原始数据（AAAAA…）的地址，但是由于其被释放，系统取消了保存它的页面映射，从而导致了内存访问冲突（我们试图访问一个未映射的内存地址）。因此，我们找到了一个一直在寻找的use-after-free漏洞。
## 4\. 漏洞利用和下一步工作思考
### 4.1 漏洞利用
本文重点不是展示如何通过use-after-free漏洞获取完整代码执行权限（事实上，在本文发布的同时，Exodus已发布了一篇[博客文章](https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/)及一个可用的[漏洞利用](https://github.com/exodusintel/CVE-2019-5786)代码）。
根据我们触发该use-after-free漏洞的方法，我们最终获得了一个非常大的未分配的内存缓冲区。use-after-free漏洞通常利用方法是在释放区域之上分配一个新对象从而产生某种混淆。文中，我们释放了用于备份ArrayBuffer对象数据的原始内存。很好的是，我们可以读取/写入一个大内存区域。但是，这种方法也存在问题，就是由于该内存区域确实太大了，导致没有一个对象可以符合该要求。假如我们有一个小一点的内存区域，我们就能创建大量特定大小的对象，希望可能有一个对象正好在该区域被分配。不过这个更难，我们需要去等待，一直要到堆为不相关的对象回收内存。在64位windows
10系统，由于内存随机分配方式以及随机地址可用等机制导致很难做到这一点。在32的windows
7系统中，由于地址空间要小的多，因此相对而言堆的分配更具确定性。分配10K左右的对象可能足以让我们控制一些地址空间中的元数据。
另外有趣的是，由于要取消引用一个未映射的内存区域。如果上面提到的10K分配方法无法在我们控制的那个区域中分配至少一个对象，那么我们未免就太不走运了。我们将由于内存访问冲突而导致进程崩溃。此外，也有一些方法可以使得这一步更稳定，比如有些文章描述的利用
iframe的[方法](https://halbecaf.com/2017/05/24/exploiting-a-v8-oob-write/),以及Javascript对象元数据被破坏的[示例](https://halbecaf.com/2017/05/24/exploiting-a-v8-oob-write/)。
### 4.2 下一步工作
即使攻击者在浏览器渲染进程中获得代码执行权限，但是依然受到沙箱机制的限制。本漏洞发现的野外利用，攻击者使用了另外一个零日漏洞用于躲避沙箱机制。最近360CoreSec发布了一篇描述该野外漏洞利用的[技术文章](http://blogs.360.cn/post/RootCause_CVE-2019-0808_EN.html)。
## 5\. 结论
通过研究提交的漏洞修复方式，查找提示和类似的修复，我们有可能恢复漏洞利用路径。再一次的，我们可以看到，在windows新近操作系统版本中引入的安全防护机制使得攻击者的日子愈发困难，从防守方的角度来说，我们应该对此表示庆祝。此外，谷歌在漏洞修补策略方面非常高效、积极，其大部分用户群的Chrome浏览器已经及时更新到最新版本。
## Links
[1]   
[2]   
[2b]   
[3]
[3b]
[4a]
[4b]
[5]   
[6a]
[6b]   
[7]   
[8]   
[9]   
[10a]   
[10b]   
[11]   
[12]   
[13] 