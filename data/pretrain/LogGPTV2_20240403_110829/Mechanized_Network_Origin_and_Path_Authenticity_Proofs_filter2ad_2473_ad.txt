key setup or forwarding program.
One of the principals in the list of princi-
pals P owns the thread i.
s is only known to principals in P.
All occurrences of s in message M are
protected by one of the keys in K (s is
safe in M w.r.t. K)
w.r.t. K .
s is safe in all messages sent by any
thread (including adversarial ones) w.r.t.
K up to time u.
Figure 5: Predicates used in key setup.
sendsSafeMsg i s K s is safe in all messages sent by thread i
Authenticity proofs. To prove the authenticity property of the list
of keys accepted by the destination, we ﬁrst consider the authen-
ticity property of one key (Lemma 3). Assume that rt is an honest
router and pkD is a session key for the destination D. If sig is a
signature of the tuple (k , pkD, downstream) signed using the pri-
vate key of rt, then we can prove that k is computed by applying
the pseudo random function to the correct arguments.
LEMMA 3
(KEY AUTHENTICATION). For all i sig d rt pkD
k t, verify i sig (k , pkD, downstream) pk(rt)@t, honest rt
imply k = PrfMsg SVS (rt) pkD
To prove Lemma 3, we use Axiom Verify and conclude that an
honest thread must have signed the tuple. Then we use LS2 infer-
ence rules and prove that an honest node only signs a key, k, that is
generated by applying the pseudo random function to the thread’s
local secret and the hash of the public key that it encrypts k with.
The conclusion follows directly. By induction over the length of
the trace, we can prove the ﬁrst condition in Theorem 1.
Secrecy proofs. The secrecy proofs follow similar strategies as de-
scribed by Garg et al.
[25], where rely-guarantee reasoning prin-
ciples are used to show that the keys have been safe in all network
messages w.r.t. secret keys only known to the trusted principals.
We ﬁrst consider one key. Assume that rt and D are honest. For a
given session, we prove that the symmetric key k generated by rt
to be shared with D is always protected by the private key pkD−1 ,
formalized below. Recall pkD is the public session key for D in
that session.
LEMMA 4
(SAFENET). For all S D path pkS pkD pkD−1
rt k, honest rt, honest D, asymKeyPair pkD pkD−1 ,
k = PrfMsg SVD (rt) pkD and session S D path pkS pkD imply
that for all u, safeNet k (pkD−1 :: nil ) u
The proof of the above lemma uses the rely-guarantee reasoning
principles (RG1-RG3) outlined in Section 3.1 with
= ∃node, owner i node ∧ honest node.
ι(i)
ψ(i, u) = ∀rt, sendsSafeMsg i PrfMsg SVD(rt) pkD)
(pkD−1 :: nil )@u.
The three conditions in rely-guarantee principles (introduced in
Section 3.1) are now instantiated as follows: Condition RG1 says
that initially these keys are safe in all network messages. This is
trivially true because no message is sent at time 0. Condition RG2
says that if a router-generated key is protected by pkD−1 in all
network messages, up to u (excluding u), then honest threads will
protect this key in all messages they send out at time u. This condi-
tion can be proved by reasoning about the protocol code. Condition
RG3 says that if a router-generated key is protected by pkD−1 in
all messages that have been sent out at any time before u, and that
all honest nodes protect this key, using pkD−1 in all messages they
send at time u, then this key is also protected by pkD−1 in all mes-
sages sent by all threads up to time u inclusive. Next we explain
how RG3 is proven.
We prove another lemma (shown below), which states that if the
key PrfMsg (SVD(rt)) pk, denoted m, has been safe in all net-
work messages protected by keys in K , then anyone with knowl-
edge of m must either have the router’s secret or a key k in K .
LEMMA 5
(POS). For all i m rt pk t, safeNet m K t,
m = PrfMsg SVD(rt) pk, and has i m t imply
has i SVD (rt) t and there exists k in K such that has i k t
The proof of RG3 uses Lemma 5 to show that if a thread i can
compute this key at time u, it must be the case that i knows either
rt’s local secret value or pkD−1 . According to our axioms, we
know that i must be owned by either rt or D, both of which are
honest. Therefore, condition RG3 holds.
From Lemma 4 and Lemma 5, we can prove that the key k gen-
erated by rt for D is known only to rt and D (formalized below).
(HASONLY). For all S D path pkS pkD pkD−1
LEMMA 6
rt k, honest rt, honest D, asymKeyPair pkD pkD−1 ,
k = PrfMsg SVD(rt) pkD and session S D path pkS pkD
imply hasOnly (rt :: D :: nil ) k
The second condition in Theorem 1 can be proved by induction
on the length of the trace and Lemma 6. Combining this with the
authenticity proofs, we have successfully verﬁed that the DRKey
protocol has the desired security properties.
5. THE ORIGIN AND PATH AUTHENTIC-
ITY OF THE OPT PROTOCOL
We prove two origin and path authenticity theorems for packet
forwarding: one for intermediary routers and the other for the des-
tination. We only present the source-based origin and path authen-
ticity for routers. The corresponding theorem for the destination
differs only in that source is not assumed to be trusted. A direct
beneﬁt of constructing proofs is that we are able to verify these
topology-independent properties.
Property speciﬁcations. A list of key predicates is summarized
in Figure 6. Next we deﬁne the predicate (goodPathSrc n S D
pkS pkt path t) to mean that a packet with payload pkt has path
authenticity w.r.t. source S, destination D, the session public key
pkS, a path path, and a time point t at index n. It is inductively
deﬁned over n, a position on the path. pkS is S’s session public
key and path is the path on which the source has intended to send
the packet in this session. The time point, t, is used to enforce the
order in which the packet has traversed the network.
goodPathSrc 0 S D pkS pkt path t
∼ honest R
pathN path R (n+1)
goodPathSrc n S D pkS pkt path t
goodPathSrc n+1 S D pkS pkt path t
honest R
if n = 0 then rt
(cid:48)
if n = n
(cid:48)
recvFrom i rt
pathN path R (n+1)
(cid:48)
= S
+1 then pathN path rt
(cid:48)
n
owner i R
(cid:48)
(cid:48)
(cid:48)
, D
, path
, hashMsg(pkS ),
(S
kDh, pvfS , pvfD, opvs, pkt)@tr
ts ≤ t
(cid:48)
, path
, D
, hashMsg(pkS ), kDh,
ts > tr
(cid:48)
tr < t
send i (S
(cid:48)
pvfS1 , pvfD1 , opvs, pkt)@ts
pvfS1 = macMsg (PrfMsg SVS(R) hashMsg(pkS )) pvfS
pvfD1 = macMsg(PrfMsg SVD(R) kDh)
(pvfD, rt
, hashMsg(pkt))
(cid:48)
goodPathSrc n S D pkS pkt path tr
goodPathSrc n+1 S D pkS pkt path t
In the base case when n = 0, there are no additional require-
ments. There are two inductive cases for when n = j + 1. Let
the jth and (j + 1)th routers on path (R1,R2,··· ,Rn) be Rj and
Rj+1, respectively. When Rj+1 is dishonest, pkt is required to
have path authenticity w.r.t. S, path, and t at index j, and there
pathN path R n
acceptRt i pkt pvfS rt(cid:48) kSh @ t
ﬂagSRsF S path keys pkS
ﬂagSR k S rt pkS
session S D path pkS pkD
goodPvfS pvfS S D pkS path keys pkt
goodVrf opv S D pkS path keys pkt k rt
Router R is the nth node on path from the left (path =R1,R2,...,Rn).
Thread i has accepted payload pkt from router rt(cid:48) with PVFS = pvfS
veriﬁed using key kSh at time t.
S has set up keys keys for path path using public key pkS.
S has set up key k with router rt using public key pkS.
S and D has agreed on a session to forward along path based on key
pkS (for S) and pkD (for D).
pvfS has the correct format of PVFSn w.r.t. S D pkS path keys pkt
opv has the correct format of OPVn w.r.t. S D pkS path keys pkt k rt
Figure 6: Predicates in forwarding
is no further requirement for router Rj+1. When Rj+1 is honest,
there exist two time points tr and ts earlier than t, such that router
Rj+1 receives from Rj payload pkt at tr and sends pkt out at a
later time ts, and pkt has path authenticity w.r.t. S, path, and tr at
index j.
Theorem 7 states that the forwarding protocol provides origin
and path validation for each intermediary router. It is source-based
validation because S needs to be honest. However, we do not as-
sume the destination to be trusted.
THEOREM 7
(SOURCE-BASED OPT). For all S, D, rt, pkD,
kD, pkS −1 , path, keys, pkt, pkS, pvfS rt(cid:48), ta, i,
• session S D path pkS pkD
• asymKeyPair pkS pkS −1
• honest S, honest rt
• ﬂagSRsF S (path , D) (keys, kD) pkS
• owner i rt, acceptRt i pkt pvfS rt(cid:48) hashMsg(pkS ) @ ta
then exists n j ms ts opvs pvf0 kD pkD(cid:48), such that
• pathN (path , D) (S n) rt
• goodPathSrc n S D pkS pkt (path, D) ta
• ts ≤ ta, owner j S, send j ms @ ts
• pvf0 = macMsg kD (hashMsg(pkt))
• ms = (S, D, path , hashMsg(pkS ), hashMsg(pkD), pvf0 ,
pvf0 , opvs, pkt).
Theorem 7 states that if a router accepts a packet, then the pay-
load, pkt, originates from S and has traversed all the honest nodes
on the path intended by S, up to the router, in the correct order.
High-level descriptions of proofs. The correctness of the forward-
ing protocol relies on the following properties related to veriﬁed
MACs. MACProp 1: once the router Ri validates the origin and
path validation ﬁeld (opv) in the packet header, opv must be the
correct OPVi as shown in Section 2.2.3. MACProp 2: a validated
origin and path validation ﬁeld (opv) indicates that the packet must
have originated from the source. MACProp 3: The presence of
(PVFSi−1) of the correct format indicates that the packet must
have traversed the path from S to R1 to Ri−1.
MACProp 1 holds because opv is a MAC that can only be com-
puted by S, and S’s program guarantees to only compute OPV
ﬁelds of the right form. MACProp 2 holds for the same reason.
MACProp 3 holds because only Rk and S have the key KSk to
compute PVFSi−1, where 0<k<i. From MACProp 1, we can
derive that once the router Ri veriﬁes the OPVi ﬁeld, it must be
the case that the path validation ﬁeld it received in the packet is
the same as PVFSi−1. Origin and path authenticity follows from
MACProp 2 and MACProp 3. An interesting proof technique is
the use of rely-guarantee reasoning to prove MACProp 1–3, as
they are invariant properties about MACs in PVFS, PVFD, and
OPV. Next we show three lemmas that formalize these properties.
Proof of MACProp 1. We deﬁne a predicate sendsSafeVrf i S D
rt pkS opv t stating that if a thread i sends out a message m that
contains a message, opv, which is the MAC of some message pvfS,
the hash of pkt, and a principal rt(cid:48) using key k, then opv must be
a valid origin and path validation ﬁeld (OPV) for some path and
keys, w.r.t. S D pkS pkt and k.
sendsSafeVrf i S D rt pkS opv t =
∀k m pkt pvfS rt(cid:48),
send i m @ t → contain m opv →
opv = macMsg k (pvfS , hashMsg(pkt), rt(cid:48)) →