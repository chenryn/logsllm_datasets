title:Efficient and extensible security enforcement using dynamic data flow
analysis
author:Walter Chang and
Brandon Streiff and
Calvin Lin
Efﬁcient and Extensible Security Enforcement Using
Dynamic Data Flow Analysis
Walter Chang
PI:EMAIL
Brandon Streiff
PI:EMAIL
Calvin Lin
PI:EMAIL
Department of Computer Sciences
The University of Texas at Austin
Austin, TX 78712
ABSTRACT
Current taint tracking systems suffer from high overhead and a lack
of generality. In this paper, we solve both of these issues with an
extensible system that is an order of magnitude more efﬁcient than
previous software taint tracking systems and is fully general to dy-
namic data ﬂow tracking problems. Our system uses a compiler
to transform untrusted programs into policy-enforcing programs,
and our system can be easily reconﬁgured to support new analyses
and policies without modifying the compiler or runtime system.
Our system uses a sound and sophisticated static analysis that can
dramatically reduce the amount of data that must be dynamically
tracked.
For server programs, our system’s average overhead is 0.65%
for taint tracking, which is comparable to the best hardware-based
solutions. For a set of compute-bound benchmarks, our system pro-
duces no runtime overhead because our compiler can prove the ab-
sence of vulnerabilities, eliminating the need to dynamically track
taint. After modifying these benchmarks to contain format string
vulnerabilities, our system’s overhead is less than 13%, which is
over 6× lower than the previous best solutions. We demonstrate
the ﬂexibility and power of our system by applying it to ﬁle dis-
closure vulnerabilities, a problem that taint tracking cannot handle.
To prevent such vulnerabilities, our system introduces an average
runtime overhead of 0.25% for three open source server programs.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—Informa-
tion Flow Controls
General Terms
Reliability, Security, Veriﬁcation
Keywords
Dynamic Data Flow Analysis, Security Enforcement, Static Anal-
ysis
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’08, October 27–31, 2008, Alexandria, Virginia, USA.
Copyright 2008 ACM 978-1-59593-810-7/08/10 ...$5.00.
Traditional Tainted Data Attacks
Format String Attacks
SQL Injection
Command Injection
Cross-Site Scripting
Privilege Escalation
Other Security Problems
File Disclosure Vulnerabilities
Labeled Security Enforcement
Role-Based Access Control
Mandatory Access Control
Accountable Information Flow
Table 1: A sampling of the kinds of problems that our system can
handle. Taint tracking can only handle the top set of problems.
1.
INTRODUCTION
Many security attacks rely on the ability to pass carefully crafted
hostile data to vulnerable portions of a target program. One method
of preventing such attacks is to perform dynamic taint analysis [46,
37, 44, 16, 38, 10, 39, 48, 31]. Dynamic taint analysis marks un-
trusted data as tainted, tracks the ﬂow of tainted data through the
system, and checks that tainted data is not misused. Existing taint
analysis research has largely followed one of two directions: (1)
improving runtime overhead and (2) extending the generality of
taint tracking.
Signiﬁcant progress has been made in the ﬁrst direction. Recent
work [39] has reduced the extreme overheads of early systems [37]
by performing taint-speciﬁc optimizations, but performance still re-
mains a challenge, with average overheads of 260% for compute-
bound applications [39]. Alternative techniques [48] can reduce the
average overhead to 75% for compute-bound applications, but this
result requires processor and OS-speciﬁc assumptions that are not
generally applicable.
The second direction, which has received less attention, extends
the generality of taint analysis, recognizing that taint tracking is a
special case of data ﬂow tracking. Whereas taint analysis tracks
one bit of information, data ﬂow tracking can track multiple bits
of information and can combine the information in more ﬂexible
ways than taint analysis. More concretely, taint-based systems are
limited to the top set of exploits listed in Table 1, while general
data ﬂow tracking, which is based on the more general notion of
data ﬂow analysis [29], can handle all of them. Such generality will
become particularly important as developers move to memory-safe
languages such as Java and C#, where the use of taint tracking to
enforce secure control ﬂow is not needed.
Our System
Broadway Compiler
Static Vulnerability Analysis
Dependence Analysis
Source Code
Enhanced Program
Policy Specification
Figure 1: The overall structure of our system. The compiler takes a
source program and a security policy and produces an enhanced ver-
sion of the program that enforces the policy by performing dynamic
data ﬂow analysis.
In this paper, we describe an extensible compiler-based system
that simultaneously advances the state of the art in both directions.
The performance of our system is an order of magnitude better than
any previous software taint tracking system. The generality of our
system allows it to support all of the problems listed in Table 1.
Moreover, this generality is easily accessible, as we now explain.
Figure 1 shows the overall architecture of our system. The in-
put is an untrusted program. The output is an enhanced program
that enforces some speciﬁed security policy, which is selected by
the end-user at compile time. To enforce the desired policy, the
compiler ﬁrst performs a static vulnerability analysis that identi-
ﬁes whether the input program might violate the policy; the com-
piler then performs an analysis that identiﬁes those locations in the
input program that require dynamic analysis. The appropriately
enhanced program then dynamically enforces the policy by per-
forming a tag-based dynamic data ﬂow analysis, discussed in Sec-
tion 4.1.
The policy itself is deﬁned in an annotation ﬁle that describes
the policy and the effects of standard library calls on the policy.
Thus, the policy is entirely separate from the data ﬂow tracking
mechanism, so in addition to the existing security policies that we
have already deﬁned, new security policies can be speciﬁed without
modifying either the compiler or the runtime system.
The key to our system’s low overhead is our compiler’s ability
to identify many innocuous ﬂows of data that provably do not need
to be tracked. For example, a program might read data into several
different buffers, only one of which is used in a way that violates
the policy. It is therefore not necessary to track the other buffers and
everything they ﬂow into. In cases where the compiler can prove
that no policy violations are possible, the resulting output program
contains no instrumentation and thus incurs no runtime overhead.
Our compiler can precisely identify innocuous data ﬂow because
(1) our system’s security policy can be interpreted as a static data-
ﬂow analysis that determines whether the policy was violated, and
(2) our compiler performs an interprocedural analysis that uses a
precise and scalable pointer analysis [23]. By contrast, other cur-
rent systems do not attempt to statically detect the policy violation,
and they perform static analysis that is limited in scope (they are
intraprocedural) and precision.
This paper makes three main contributions:
• We introduce a system that accepts untrusted C programs
as input and produces C programs that can enforce any pol-
icy that can be expressed as data ﬂow tracking. Our system
comes with predeﬁned policies for taint and ﬁle disclosure,
and our system can be easily extended to handle other prob-
lems and security policies without modifying our system im-
plementation. Our system uses sophisticated static analysis
to minimize the amount of dynamic analysis that is needed.
• We show that our system is general by using it enforce ﬁle
disclosure vulnerabilities—a privacy problem that taint track-
ing cannot handle—as well as to perform traditional taint
tracking. Our system is as general as GIFT [31], but our
system is conﬁgured through an existing declarative annota-
tion language [21] rather than by writing wrapper functions
or new code.
• We demonstrate our system’s performance advantages by eval-
uating it on both server programs and compute-bound pro-
grams. For common open-source server programs, our sys-
tem’s average overhead is 0.65%, compared with 6% for the
previous best reported results [48]. For compute-bound SPECint
benchmarks, our system is able to prove the absence of for-
mat string errors entirely, giving a true overhead of 0%. Af-
ter inserting vulnerabilities into these programs, our system’s
average overhead for compute-bound programs is less than
13%, compared with 75-260% for previous systems [48, 39].
The remainder of this paper is organized as follows. Section 2
discusses related work, Section 4 describes our solution, and Sec-
tion 5 presents our evaluation.
2. RELATED WORK
Our work is a generalization of dynamic taint tracking [46, 37,
38, 44, 16, 10, 12, 48, 39, 31, 11], which has been used to protect
against buffer overﬂows, stack smashing, and format string attacks,
and which covers attacks previously addressed separately by vari-
ous different solutions [15, 14, 4, 13]. Taint tracking is a practical
realization of some of the concepts of information ﬂow control [5,
18] and integrity [8], but it typically ignores implicit ﬂows. Much
of the previous work in taint tracking has used dynamic binary
instrumentation frameworks [37, 12, 39, 11] or specialized hard-
ware [44, 16, 17]. Except where noted below, these systems are not
designed for more general data ﬂow tracking problems, and core
components would need to be rewritten to accommodate such gen-
erality. Instead, these systems have focused on reducing runtime
overhead.
Many taint tracking systems based on binary instrumentation,
such as TaintCheck [37] or Dytan [11], have enormous overheads,
as high as 37×. More recent binary instrumentation systems such
as LIFT [39] have signiﬁcantly improved performance, but over-
head for compute-bound programs remains as high as 7.9×.
Xu, et al. present a high-performance compiler-based taint track-
ing system [48], which achieves an average overhead of 6% for
server applications. However, to achieve this performance, the sys-
tem exploits assumptions about the memory layout in 32-bit x86
Linux, allowing it to write the tag map directly to unused mem-
ory at ﬁxed addresses. Even with this optimization, their average
overhead for compute-bound applications is 75%. Without this op-
timization, their overhead is “unacceptable” [48].
Hardware-based taint tracking [44, 16, 17] can in most cases
eliminate the overhead associated with software-based taint track-
ing. However, overhead can still occasionally be as high as 23% [44]
due to cache performance degradation. Furthermore, most hardware-
based systems only defend against memory and control ﬂow errors.
Raksha [17] provides additional ﬂexibility by using tag propagation
registers and OS traps, but this comes at a high cost, with average
overhead exceeding 3×.
Lam and Chiueh’s General Information Flow Tracking [31] is a
framework that uses a compiler to automatically add code to prop-
agate and check tags associated with data, allowing it to handle
a wide range of problems beyond overwrite attacks. GIFT can
be extended to handle new policies by deﬁning wrapper functions
and transformations for the the GIFT compiler that implement the
policy and related tag management. However, the policies are de-
ﬁned operationally by writing code that implements transforma-
tions. Without an understanding of the semantics of the policy it-
self, the compiler is limited in its ability to analyze and optimize
the added code, leading to an average CPU time overheads of 82%
for the sandboxing of client applications.
Inline reference monitors [19, 41] use security automata to de-
fend against attacks. However, ﬁnite state automata are awkward
and unsuitable for addressing problems that require the tracking
of information ﬂow. PQL [32] presents a more ﬂexible scheme
based on pattern matching of event sequences on objects. This sys-
tem can track direct information ﬂows and uses static analysis to
reduce overhead a including direct information ﬂows. However,
their techniques require type safety and work only on heap objects,
so their techniques are unsound for programs with ﬂows through
scalar variables.
Static analysis can be used to ﬁnd bugs and potential security
vulnerabilities in software [42, 2, 20, 23]. While extremely valu-
able, such systems still require that software developers expend sig-
niﬁcant effort to verify and ﬁx any vulnerabilities reported by the
tool. For example, CQUAL has been used to ﬁnd format string
vulnerabilities [42]. However, to use their results, programmers
must examine the output and the original source program using
an advanced graphical interface and attempt to determine manu-
ally whether the reported vulnerability is real or a false positive.
Moreover, they report a false positive rate of approximately 84%,
so considerable programmer effort is wasted. In contrast, our sys-
tem uses statically identiﬁed vulnerabilities to determine where dy-
namic guards are required, producing a system protected from the
vulnerability without additional programmer effort. Thus, our sys-
tem complements static tools by guaranteeing that possible vulner-
abilities are prevented even if the programmer has not yet ﬁxed the
problem.
Language-based security solutions range from type-safe C [35,
27] and bounds checking for C [28] to full language support for
information ﬂow [33, 40]. These systems can provide strong guar-
antees at compile time, but they either impose signiﬁcant perfor-
mance overhead or require signiﬁcant developer effort to rewrite
and redesign current programs. The “safe-C” approaches cannot
handle errors like SQL injection that do not violate language se-
mantics. By contrast, JiF [33] supports complex information ﬂow
policies that our system cannot support.
Finally, static analysis can also be used to construct static mod-
els of program behavior that can then be enforced dynamically. For
example, control [30, 1] and data ﬂow integrity [9] ensure that the
program never deviates from statically computed models of control
and data ﬂow, respectively. However, these systems are not gen-
eralizable to security problems that do not violate control or data
ﬂow integrity, and they are of limited use in languages that already
provide similar guarantees. In contrast, our system is capable of
handling a far broader class of problems that plague even safe lan-
guages.
3. MOVING BEYOND TAINT ANALYSIS
Before we describe the details of our system, we will explain the
importance of moving beyond taint analysis into a realm of richer
data ﬂow tracking problems.
With respect to properties, taint tracking does not provide suf-
ﬁcient information to handle many attacks. In Section 4.3.2, we
discuss the problem of ﬁle disclosure vulnerabilities. Taint track-
ing cannot handle this problem because it requires the simultaneous
tracking of two different properties. In addition, taint tracking is too
simplistic for problems in privacy and access control. For example,
to enforce a policy based on labeled security [34], the system must
simultaneously track hierarchical levels and non-hierarchical cate-
gories. To meet future challenges, systems must be able to track
multiple complex properties at the same time.
With respect to policies, most taint tracking systems enforce “low-
level” policies that prevent overwrite attacks. While overwrite at-
tacks are a major concern in unsafe languages, they are not a sig-
niﬁcant concern in managed languages and scripting languages that
already guarantee memory safety. For example, SQL injection
and cross-site scripting attacks do not overwrite pointers but do
occur in safe languages. Moreover, privacy breaches and infor-
mation breaches are usually accomplished without memory errors,
and they represent a serious challenge for current and future web
applications. To meet these and future attacks, systems must sup-
port higher-level policies that are aware of higher-level application