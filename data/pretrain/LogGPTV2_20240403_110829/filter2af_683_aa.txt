现代网站为了提高性能，获取数据并提供更多的服务，通常采取透明系统（译者注:
透明系统是指程序的输入输出可知）镜像来供用户访问。这种几乎不可见的攻击面已经被人们过于的忽略了。
在这篇文章中，我会向大家展示如何使用畸形请求和迷惑的请求头去欺骗系统暴露它们自己，同时打开通往受害者网络的大门。同时我将分享如何把这些技术与bash组合去突破防御部门的网络，并在漏洞悬赏中获取了超过3万美元的奖励以及意外的渗透了自己的ISP（因特网服务供应商）。
当论及到损害程度的话，我也会展示几个系统从隐藏到被揭露的状态，这不仅包括对英国最大的ISP的隐蔽请求的窃听，还有相当可疑的哥伦比亚ISP，令人困惑的Tor后台，以及一个能够将反射型XSS升级为SSRF的系统。你也可以了解到一些策略，用于屏蔽使用了exp链和缓存机制的盲打SSRF。最后，为了推动这些系统发展，我发布了一款Collaborator
Everwhere—— 一个开源burp插件，通过选择最好的技术来增加你的网站流量，从而获得更多的来自合作网站的客户。
这篇文章也可以打印成[白皮书](https://portswigger.net/knowledgebase/papers/CrackingTheLens-whitepaper.pdf)。与此对应的BlackHat USA演讲视频可能会在9月份公布。
# 介绍
无论是ShellShock，StageFright还是ImageTragick，在被忽视的攻击面中发现一个严重的漏洞，其背后常常隐藏着许多类似的问题。这是由于安全测试人员的关注点不在重大的攻击面中的“柔软”部分了。在本文中，我将展示反向代理，负载平衡器和后端分析系统所带来的丰富的攻击面，尽管这被过度忽视了多年。我将通过一种简单的方法来高效地对这些系统进行大规模的审计，然后选择所发现的关键漏洞中的一部分进行展示。
这次，我会发布两个工具。 Collaborator Everywhere是一个Burp
Suite插件，可以自动将一些危害低的攻击载荷注入你的Web流量来揭露后端系统。它可以通过BApp商店安装，也可以通过
Probe是一个分析连接客户端的攻击面的网页，可从
# 方法论
### 善于监听
这一系列研究都需要目标系统被是成不可见的。过于明显的负载均衡在设计上就是失败的，而对于后端分析系统来说用户对其存在一无所知，毫无疑问这非常好。因此，我们不能依靠分析响应内容来可靠地识别这些系统中的漏洞。相反，我们应该发送攻击载荷使这些系统与我们联系，并从生成的DNS查找和HTTP请求中了解情况。本文提出的所有调查结果都是[pingback](https://zh.wikipedia.org/wiki/Pingback)开始的;如果没有这个开始，这些漏洞和系统都不会被发现。在这个过程我使用了Burp
Collaborator记录这些请求，但你也可以同时托管自己的日志记录DNS服务器，或者需使用[Canarytokens](https://canarytokens.org/)来进行简单的探测。
### 研究线
一开始我使用简单的Burp匹配/替换奖硬编码的pingback攻击载荷注入到所有浏览器流量中。这种方法失败了，因为攻击载荷引起了太多的pingback，这导致了无法将pingback与请求匹配起来以及不知道是哪个网站触发的pingback。很快就看出有些攻击载荷会引起一些延迟（三分钟、几小时、甚至每24小时），然后pingback才返回。
为了帮助有效地区分pingback，我写了Collaborator
Everywhere，一个简单的Burp扩展，将包含唯一标识符的攻击载荷注入到所有代理的流量中，并让它们自动将pingback与相应的攻击相关联。比如说，下面这张屏幕截图显示了Collaborator
Everywhere已经识别出了在我访问Netfix网站后四个小时，Netflix访问了Referer头中指定的URL，并伪装是在x86
CPU上运行的iPhone。
### 扩大规模
对于专注的手动审计来说，Collaborator
Everywhere非常高效，本文中提及的漏洞有大概一半是通过它来发现的。然而，在这次研究中我发现了雅虎服务器的一个漏洞，该漏洞的通过扫描发现的概率只有30%。这个现象的根本原因是雅虎通过三台不同的前置服务器使用了DNS循环负载均衡来路由请求，这三台服务器只有一台是存在漏洞的。对于侧重后端应用程序的安全审计来说，这种奇怪的场景很少，但是这种情况可以作为渗透负载均衡的新奇淫技巧。为了确保没有存在漏洞的服务器不被检测到，有必要在目标基础设备的每个部分进行系统识别和直接攻击尝试。
为了按上面说的做，最开始我选择了[Masscan](https://github.com/robertdavidgraham/masscan)和Burp
Collaborator，但最后用[Zmap/ZGrab](https://github.com/zmap/zgrab)代替了Masscan，因为它支持HTTP1.1和HTTPS。为了将pingback与目标相关联，我将目标主机名和每个payload进行了简单的相加，如果在example.com存在漏洞那么会导致DNS查找example.com.collaboratorid.burpcollaborator.net。这些目标域名和IP地址都是来自公开或者私有的漏洞悬赏中可测试的域名名单，接着我将这些域名和IP映射到[Rapid7的Project
Sonar Forward
DNS数据库](https://scans.io/study/sonar.fdns_v2)中。通过这个技术，我确定了几百万个IP地址，其中大约50000台主机监听着80/443端口。最初我试着使用反向DNS记录，但我发现了许多服务器伪装成google的基础设施，而且它们并对突如其来的安全审计表示了不欢迎。
于是我向成千上万的服务器发送了攻击载荷，如果这些载荷根本没有击中存在漏洞的代码路径，那效果甚微。为了最大化覆盖率，每个IP地址我用了5个主机名，同时使用HTTP和HTTPS，并尝试使用了`X-Forwarded-Proto:HTTPS`和`Max-Forwards`去触发边缘情况。同时为了防止中间服务器破坏我的攻击载荷，我还发送了`Cache-Control:no-transform`
# 错误路由请求
反向代理会对收到的请求进行轮询，并转到适当的内部服务器。这些服务器通常处于一个特殊的网络位置，能够接受公网的请求同时也可以访问公司的DMZ区域，但这并不是整个内网。使用恰当的攻击载荷，可以操纵一些反向代理导致错误路由请求，这些请求的目的地是攻击者选择的。这些错误的请求相当于一道无限制访问目标内网的大门，也可以看成是SSRF的强大变体。下面是这种攻击的简单流程图：
请注意，这种攻击通常涉及高度畸形的请求，可能会破坏[诸如ZAP的工具](https://github.com/zaproxy/zaproxy/issues/1318)，并可能无意中利用了公司或ISP的中间网关。对于工具我建议使用Burp
Suite，mitmproxy和Ncat / OpenSSL。
# 不正确的host字段
触发回调函数的最简单方法是发送不正确的HTTP主机头：
    GET / HTTP/1.1
    Host: uniqid.burpcollaborator.net
    Connection: close
虽然这项技术在一些圈子里已经存在多年了，但它仍没令人满意。通过这个技术，我成功的渗透了27个DoD服务器，我的ISP、一个哥伦比亚ISP（通过DNS投毒将其暴露出来），还有`http://ats-vm.lorax.bf1.yahoo.com`的服务器。作为展示这个漏洞严重程度的例子，我们来来看看在`ats-vm.lorax.bf1.yahoo.com`发现的内部服务器。
初略看一眼，并不能知道服务器在运行什么软件：
    GET / HTTP/1.1
    Host: XX.X.XXX.XX:8082
    HTTP/1.1 200 Connection Established
    Date: Tue, 07 Feb 2017 16:32:50 GMT
    Transfer-Encoding: chunked
    Connection: close
    Ok
    / HTTP/1.1 is unavailable
    Ok
    Unknown Command
    Ok
    Unknown Command
    Ok
    Unknown Command
    Ok
接着不到一分钟，我就准确的知道了服务器在运行什么软件并且怎么和它通讯，这多亏了助人为乐的`HELP`命令：
    HELP / HTTP/1.1
    Host: XX.X.XXX.XX:8082
    HTTP/1.1 200 Connection Established
    Date: Tue, 07 Feb 2017 16:33:59 GMT
    Transfer-Encoding: chunked
    Connection: keep-alive
    Ok
      Traffic Server Overseer Port
      commands:
        get 
        set  = ""
        help
        exit
      example:
        Ok
        get proxy.node.cache.contents.bytes_free
        proxy.node.cache.contents.bytes_free = "56616048"
        Ok
      Variable lists are conf/yts/stats records, separated by commas
    Ok
    Unknown Command
    Ok
    Unknown Command
    Ok
    Unknown Command
    Ok
大量的`Unknown
Command`是因为服务器将请求的每一行理解成一个命令了。我猜测服务器那的解释器正使用一个类换行符终止协议，这会导致经典的SSRF的exp很难构造。幸运的是，基于路由的SSRF更灵活，我能够构造一个POST风格内容（包含一条命令）的GET请求：