### 优化后的文本

#### 图10：检查点树中所有创建和淘汰的检查点的深度分布，以及通过Syzkaller-USB模糊测试测量的树的分支因子
- **AR5523**
- **MWIFIEX**
- **RSI**
- **0**
- **100**
- **200**
- **300**
- **400**
- **500**
- (c) 分支因子

在机器上，尽管遇到内核崩溃，Agamotto仍能持续生成并运行测试用例，最终绕过已知错误以发现未知错误。此外，即使频繁遇到这些错误，Agamotto也能保持模糊测试的吞吐量。在对MWIFIEX和RSI进行模糊测试时，Agamotto每10分钟遇到超过6,000次和200次错误，而其基准吞吐量显著低于其他驱动程序的观察值。相比之下，Agamotto在所有实验中保持了相似水平的吞吐量。

#### 脏页统计
为了展示我们的增量检查点和增量恢复技术在实践中的有效性，我们测量了每次模糊测试循环中恢复和污染的页数。结果如图12a和12b所示。在实验中，执行测试用例后污染的页数上限接近8,000页。恢复的页数也有类似的上限，但当被恢复的检查点修改的页与当前脏页集不完全重叠时，该数量通常会超过此限制。这意味着，如第5.1节和第5.2节所述，虚拟机检查点和恢复的运行时开销大大降低。

#### 图11：Syzkaller-USB模糊测试中恢复路径长度的分布
- **0**
- **1**
- **2**
- **3**
- **4**
- **5**
- **6**
- 路径长度

#### 图12：Syzkaller-USB模糊测试中每次迭代恢复和污染的页数分布，以及检查点大小
- **0**
- **4k**
- **8k**
- **12k**
- **16k**
- (a) 恢复的页数
- (b) 污染的页数
- **0**
- **8**
- **16**
- **24**
- **32**
- **40**
- **48**
- (MiB)
- (c) 检查点大小

启用零页优化后，大多数检查点小于32MiB，如图12c所示。

### 5.4 AFL-PCI模糊测试
**实验设置**：为了评估基于设备虚拟化的PCI模糊器（增强版Agamotto），我们对四个PCI驱动程序进行了模糊测试。这次我们使用AFL作为模糊器，并且其模糊算法未做任何修改；请注意，AFL实现了一种与Syzkaller不同的输入生成和调度算法。在我们的PCI模糊器中，我们使用了一个保守的基线，其中应用了Agamotto，但禁用了非根检查点的创建。实际上，我们的PCI实验测量了由Agamotto创建的细粒度检查点在提高内核驱动程序模糊测试性能方面的有效性。

为了避免通过种子输入引入随机性，我们从一个包含八字节字符串“Agamotto”（ASCII格式）的单一输入开始模糊测试，并且没有使用任何字典条目。模糊测试算法中的随机性也像USB实验一样受到控制。每个驱动程序使用32个实例进行三个小时的模糊测试。由于驱动程序与PCI设备的交互速度比我们在USB模糊测试中观察到的要快，我们将初始检查点间隔减少到50ms。我们使用100ms作为超时值，在驱动程序最后一次访问I/O映射后100ms终止每次迭代。

**模糊测试吞吐量**：尽管AFL使用的模糊算法与Syzkaller不同，但Agamotto再次平均提高了21.6%的吞吐量，如图13所示。我们强调，无论是AFL还是Syzkaller的模糊算法都不会产生对Agamotto加速最有利的测试用例序列。特别是，AFL的模糊算法并不针对事件驱动系统的模糊测试（例如，它总是从第一个字节开始变异每个测试用例）。然而，Agamotto在所有实验中始终提高了模糊测试的吞吐量，并且当检查点管理策略与其他模糊算法方面一起优化时，有可能进一步提高吞吐量。

**路径覆盖率**：表4显示了在模糊测试每个驱动程序时，所有模糊测试实例中发现的最大代码路径数。当底层模糊器不断发现新的、更深的代码路径时，Agamotto的效果更加明显；Agamotto在深代码路径中创建的检查点越多，节省的时间就越多。在模糊测试ATLANTIC、RTL8139和STMMAC时，Agamotto在相同时间内覆盖了更多的路径；通过平均执行多32.8%的测试用例，Agamotto覆盖了47.8%更多的路径。而在模糊测试SNIC时，AFL只发现了有限数量的路径。不过，Agamotto仍然比基线多执行了6.2%的测试用例。

| 驱动程序 | 执行次数 | 发现路径数 |
| --- | --- | --- |
| ATLANTIC | 147k | 191k (30.1%) |
| RTL8139 | 152k | 259k (70.5%) |
| STMMAC | 137k | 160k (16.6%) |
| SNIC | 144k | 153k (6.2%) |

* 中位数来自三次独立运行。

| 驱动程序 | Agamotto-R | Agamotto (增加) |
| --- | --- | --- |
| ATLANTIC | 112 | 142 (18.7%) |
| RTL8139 | 71 | 153 (115.4%) |
| STMMAC | 87 | 121 (50.5%) |
| SNIC | 8 | 8 (0%) |

### 6 讨论
**检查点感知模糊算法**：我们的检查点原语为优化模糊内核驱动程序或其他事件驱动、反应式系统引入了一个新的维度。我们保守地评估了Agamotto，而没有修改底层的模糊算法；也就是说，我们仅利用了现有最先进的模糊器中已经存在的空间和时间局部性。因此，可以重新审视模糊算法的各个方面，如输入选择和变异策略。我们打算在未来的工作中探索检查点感知或无感的模糊算法。

**支持其他操作系统**：Agamotto本身不需要对操作系统进行任何修改。Agamotto使用标准的虚拟机内省机制（如hypercalls、VIRTIO和共享内存设备）与虚拟机交互，这些机制在闭源专有操作系统（如Windows [45]）中也是可用的。Syzkaller的USB模糊组件需要内核修改，以便通过系统调用接口将USB驱动程序的I/O请求重定向到用户空间。我们对Syzkaller的修改仅涉及其用户空间组件。由于其操作系统无关性，Agamotto可以与通用内核模糊方法结合使用 [53, 54]。

**模糊系统调用接口**：操作系统内核是一个处理来自外设和用户空间程序输入的事件驱动系统。Agamotto可以使模糊系统调用攻击面更高效。系统调用模糊从Agamotto中受益的程度取决于目标内核子系统。解决类似Agamotto所解决挑战的内核子系统可能受益更多。通过同时模糊设备驱动程序的系统调用（如ioctl）和外围攻击面，可以更彻底地测试设备驱动程序。本地攻击者可以通过这种二维模糊找到的漏洞来破坏操作系统内核。先前的工作表明，二维模糊在查找文件系统中的错误非常有效 [64]。同样的想法也可以应用于设备驱动程序，而Agamotto可以促进对其二维输入空间的深入探索。

**模糊其他事件驱动系统**：虚拟化技术也被用于运行和模糊物联网固件 [17, 22, 25, 66]。虽然本文重点是模糊运行在完整操作系统内核中的内核模式设备驱动程序，但Agamotto的核心技术也可以应用于模糊运行在虚拟机中的物联网固件。运行在用户模式下的事件驱动系统也可以从Agamotto中受益。例如，在模糊多进程系统时，进程之间相互交互，Agamotto可以在虚拟机级别透明地捕获所有运行进程的状态，从而促进对整个系统状态空间的深入探索。

**进一步优化**：在多实例模糊设置中，可以通过共享内存跨模糊实例去重检查点。去重允许Agamotto在内存中存储更多的检查点，从而防止抖动并提高检查点的命中率。还可以探索不同的检查点创建和淘汰策略，这些策略可以是通用的（例如我们介绍的那些），也可以针对某些类别的模糊算法进行定制。虚拟机内省原语也可以通过软件和硬件技术进一步优化 [4]。

**局限性**：Syzkaller支持多进程模式，该模式在一个客户操作系统中运行多个模糊器实例，从而提高模糊吞吐量。目前Agamotto不支持此模式，但我们认为可以通过更细粒度的检查点机制（例如，通过更细粒度的虚拟机内省或内核修改 [30]）来支持此模式。我们打算在未来的工作中探索这一方向。我们强调，即使采用更细粒度的检查点机制，Agamotto的其他方面（例如，检查点管理和优化技术）仍然适用。我们还强调，选择在虚拟机级别进行检查点使得Agamotto能够支持其他基于虚拟机的内核驱动程序模糊器，正如我们在PCI-AFL实验中所展示的那样。

### 7 相关工作
**外设攻击和防御**：恶意外设长期以来一直是威胁操作系统内核安全的一个因素。一个著名的例子是恶意USB设备，它们通常表现为良性的USB闪存盘 [42]。除了USB设备之外，即使是SoC中硬连线的不可插拔外设也可能通过外设攻击变得恶意 [9, 11]。已经提出了许多针对恶意外设的防御措施 [5, 13, 58–60]，但保护外设攻击面仍然是一个正在进行的工作 [39]。借助Agamotto提供的性能改进，可以通过模糊测试更有效地探索外设攻击面，从而减少发现新漏洞的时间。

**内核模糊**：存在许多用于在内核子系统中发现漏洞的模糊器 [2, 3, 18, 24, 26, 27, 29, 32, 40, 46, 48, 53–55, 57, 64]。一些工作使用了各种快照技术 [2, 64]，这已在第2节中详细讨论。其他工作主要集中在模糊算法上，例如生成增加覆盖率的测试用例；Agamotto补充了这些努力，因为它透明地创建和使用检查点来节省执行生成的测试用例所需的时间。混合模糊（符号执行和模糊的组合）也已被用于在操作系统内核中发现错误 [33, 36, 49, 51]。由于Agamotto和符号执行系统维护不同形式的快照，通过设计在这两种快照形式之间的切换机制，Agamotto也可以增强混合内核模糊。

### 8 结论
我们介绍了Agamotto，这是一个使用高度优化的动态虚拟机检查点原语透明地提高内核驱动程序模糊器性能的系统。在模糊测试过程中，Agamotto自动在细粒度间隔处检查虚拟机，并从这些检查点恢复虚拟机，从而跳过内核崩溃后的重启，并快速跳过反复执行的耗时部分。我们在各种USB和PCI模糊测试场景中使用两个不同的模糊器对Agamotto进行了评估，并展示了其在提高模糊测试吞吐量和路径覆盖率方面的有效性。