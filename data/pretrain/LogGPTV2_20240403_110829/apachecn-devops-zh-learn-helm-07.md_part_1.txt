# 七、使用 CI/CD 和 GitOps 自动化 Helm 流程
在本书中，我们到目前为止已经讨论了两个高级流程。首先，我们探索了使用 Helm 作为最终用户，利用 Helm 作为包管理器来将不同复杂性的应用部署到 Kubernetes。其次，我们探索了作为图表开发人员开发和测试 Helm 图表，这包括将 Kubernetes 复杂性封装在 Helm 图表中，并在图表上执行测试，以确保所需的功能成功交付给最终用户。
这两个过程都涉及调用各种不同的 Helm CLI 命令。这些 Helm CLI 命令虽然在执行各自的任务时很有效，但需要从命令行手动调用。当管理多个不同的图表或应用时，手动调用可能会成为一个痛点，并且会使大型企业难以扩展。因此，我们应该探索在 Helm 已经提供的基础上提供额外自动化的替代选项。在本章中，我们将研究与**持续集成**和**持续交付** ( **CI** / **CD** )和`GitOps`相关的概念，它们是可以自动调用 Helm CLI 和其他命令的方法，以便针对 Git 存储库的内容执行自动化工作流。这些工作流可用于使用 Helm 自动部署应用，并在图表开发生命周期中构建、测试和打包 Helm 图表。
在本章中，我们将涵盖以下主题:
*   理解 CI/CD 和 GitOps
*   建立我们的环境
*   创建配置项管道以构建 Helm 图表
*   使用 Helm 创建光盘管道来部署应用
*   清理
# 技术要求
本章要求您在本地计算机上安装以下技术:
*   迷你库比
*   舵
*   库布特雷
*   饭桶
除了这些工具之外，您应该可以在 https://github.com/PacktPublishing/-Learn-Helm 找到包含与 GitHub 本章中使用的示例相关的资源的 Packt 存储库。本章将引用该存储库。
# 理解 CI/CD 和 GitOps
到目前为止，我们已经解决了 Helm 开发固有的许多关键概念——构建、测试和部署。然而，我们的探索仅限于手动配置和调用 Helm CLI。虽然这在开始使用 Helm 时没问题，但是当您希望将图表移动到类似生产的环境中时，您需要考虑几个问题，包括以下问题:
*   如何确保图表开发和部署的最佳实践得到实施？
*   合作者参与开发和部署过程会有什么影响？
这些要点适用于任何软件项目，而不仅仅是 Helm 图表开发。虽然到目前为止，我们已经介绍了许多最佳实践，但是在与新的合作者打交道时，他们可能对这些主题或执行这些关键步骤的规程没有相同的理解。通过使用自动化和可重复的流程，已经建立了 CI/CD 等概念来应对其中的一些挑战。
## 置信区间/置信区间
对自动化的软件开发过程的需求导致了 CI 的创建，该过程可以在每次软件变更发生时坚持。CI 不仅确保了最佳实践得到遵守，而且还有助于消除许多开发人员面临的共同挑战，正如“它在我的机器上工作”这句话所体现的那样我们之前讨论的的一个因素是使用**版本控制系统**，比如`git`，来存储源代码。通常，每个用户都有自己独立的源代码副本，这使得维护代码库变得很难管理，因为引入了额外的贡献者。
通过使用自动化工具来正确启用配置项，每当发生更改时，都会检索源代码并经历一组预定的步骤。对合适的自动化工具的需求导致了专门为此目的设计的软件的兴起。竞争情报工具的几个例子包括詹金斯、团队城市和竹子，以及各种基于软件即服务的解决方案。通过将任务的责任转移到第三方组件上，开发人员更有可能频繁提交代码，并且项目经理可以对其团队的技能和产品的健壮性充满信心。
这些工具中的一个关键特性是能够提供关于项目当前状态的及时通知。不是在软件开发周期的后期发现一个突破性的变更，而是通过 CI 的使用，一旦变更被合并，流程就被执行，并向相关方发送通知。通过利用快速通知，它为引入变更的用户提供了解决问题的机会，同时感兴趣的领域在考虑的前面，而不是稍后在交付过程中当他们可能被其他地方占用时。
当一个应用走向生产时，在整个软件交付生命周期中应用 CI 的许多概念的能力导致了 CD 的产生。光盘是一组定义好的步骤，通过发布过程(通常称为管道)来编写软件。配置项和光盘通常配对在一起，因为许多执行配置项的相同执行引擎也可以实现光盘。CD 在许多组织中获得了认可和普及，在这些组织中，为了使软件发布过程进入下一阶段，需要实施适当的变更控制并获得批准。由于围绕 CI/CD 的许多概念都是以可重复的方式自动化的，一旦团队确信他们有一个可靠的框架，他们就可以完全消除手动批准步骤的需要。
在没有任何人工干预的情况下实现完全自动化的构建、测试、部署和发布过程的过程被称为**连续部署**。虽然许多软件项目从未完全实现连续部署，但是通过仅仅实现 CI/CD 强调的概念，团队能够更快地产生真正的业务价值。在下一节中，我们将介绍 GitOps 作为一种机制来改进应用及其配置的管理。
## 使用 GitOps 将 CI/CD 提升到下一个级别
Kubernetes 是一个使用声明性配置的平台。就像用任何编程语言编写的应用一样，例如 Python、Golang 或 Java，通过 CI/CD 管道遍历应用，Kubernetes 清单可以实现许多相同的模式。清单还应该存储在源代码存储库中，例如 Git，并且可以经历相同类型的构建、测试和部署实践。在 Git 存储库中管理 Kubernetes 集群配置的生命周期，然后以自动化的方式应用这些资源，这种方式的流行导致了 GitOps 的概念。GitOps 于 2017 年由软件公司 WeaveWorks 首次推出，此后作为管理 Kubernetes 配置的一种方式，它的受欢迎程度不断提高。虽然 GitOps 在 Kubernetes 环境中最为人所知，但它的原理可以应用于任何云原生环境。
与 CI/CD 类似，开发了管理 GitOps 流程的工具。其中包括来自 Intuit 的 **ArgoCD 和来自 WeaveWorks** 的 **Flux，该组织负责创造术语 GitOps。您不需要使用专门为 GitOps 设计的工具，因为可以使用任何自动化工具，尤其是为管理 CI/CD 流程而设计的工具。传统的 CI/CD 工具和为 GitOps 设计的工具之间的主要区别在于 GitOps 工具能够持续观察 Kubernetes 集群的状态，并在当前状态与所需状态不匹配时应用所需的配置，如存储在 Git 中的清单中所定义的。这些工具利用了对 Kubernetes 本身至关重要的控制器模式。**
由于 Helm 图表最终呈现为 Kubernetes 资源，因此它们也可以用于参与 GitOps 流程，并且前面提到的许多 GitOps 工具都支持 Helm。在本章的剩余部分，我们将看到如何使用使用 CI/CD 和 GitOps 的 Helm 图表，利用 Jenkins 作为 CI 和 CD 的选择工具。
# 建立我们的环境
在本章中，我们将开发两个不同的管道来演示 Helm 周围的不同流程如何实现自动化。
采取以下步骤开始设置您的本地环境:
1.  首先，考虑到本章增加的内存需求，如果在 [*第 2 章*](02.html#_idTextAnchor098) *，准备一个 Kubernetes 和 Helm 环境*中没有用 4g 内存初始化，您应该删除您的`minikube`集群并用`4g`内存重新创建它。这可以通过运行以下命令来完成:
    ```
    $ minikube delete
    $ minikube start --memory=4g
    ```
2.  一旦 Minikube 启动，创建一个名为`chapter7` :
    ```
    $ kubectl create namespace chapter7
    ```
    的新命名空间
此外，您应该分叉 Packt 存储库，这将允许您根据这些练习中描述的步骤对存储库进行修改:
1.  Create a fork of the Packt repository by clicking the **Fork** button on the Git repo:
    ![Figure 7.1 – Select the Fork button to fork the Packt repository ](img/Figure_7.1.jpg)
    图 7.1–选择分叉按钮来分叉 Packt 存储库
    您必须有一个 GitHub 帐户才能分叉一个存储库。创建新账户的过程在 [*第五章*](05.html#_idTextAnchor265)*建立你的第一个 Helm 图表*中有描述。
2.  创建 Packt 存储库的分叉后，通过运行以下命令将这个分叉克隆到您的本地机器上:
    ```
    $ git clone https://github.com/$GITHUB_USERNAME/-Learn-Helm.git Learn-Helm
    ```
除了创建 Packt 存储库的分叉之外，您可能还想从您的 Helm 存储库中移除`guestbook`图表，该图表是从您的 GitHub Pages 存储库中提供的，我们在 [*第 5 章*](05.html#_idTextAnchor265)*构建您的第一个 Helm 图表*中创建了该存储库。虽然严格来说没有必要，但本章中的示例将假定是全新的。
使用以下步骤从图表库中删除此图表:
1.  导航到您的 Helm 图表存储库的本地克隆。如您所知，我们为您的图表存储库推荐的名称是`Learn-Helm-Chart-Repository`，因此我们将在本章中使用该名称来指代您基于 GitHub Pages 的图表存储库:
    ```
    $ cd $LEARN_HELM_CHART_REPOSITORY_DIR
    $ ls
    guestbook-1.0.0.tgz   index.yaml   README.md
    ```
2.  从图表库中删除`guestbook-1.0.0.tgz`和`index.yaml`文件:
    ```
    $ rm guestbook-1.0.0.tgz index.yaml
    $ ls
    README.md
    ```
3.  将这些更改推送到您的远程存储库:
    ```
    $ git add --all
    $ git commit -m 'Preparing for chapter 7'
    $ git push origin master
    ```
4.  您应该能够在 GitHub 中确认您的图表和索引文件已被删除，只留下`README.md`文件:
![Figure 7.2 – The only file you should see in your chart repository is the README.md file ](img/Figure_7.2.jpg)
图 7.2–您应该在图表存储库中看到的唯一文件是 README.md 文件
现在您已经启动了 Minikube，创建了 Packt 存储库的分叉，并从`Learn-Helm-Chart-Repository`中移除了留言簿图表，让我们开始学习如何创建 CI 管道来发布 Helm c harts。
# 创建 CI 管道以构建 Helm 图表
CI 的概念可以应用于构建、测试、打包并将 Helm 图表发布到图表存储库的图表开发人员的视角。在本节中，我们将描述使用端到端配置项管道来简化这个过程可能是什么样子，并向您介绍如何构建一个示例管道。第一步是设计示例 pi peline 所需的组件。
## 设计管道
在前面的章节中，开发 Helm 图表主要是一个手动过程。虽然 Helm 为在 Kubernetes 集群中创建`test`钩子提供了自动化，但是`helm lint`、`helm test`或`ct lint-and-install`命令的调用是在代码更改后手动执行的，以确保测试仍然通过。一旦林挺和测试在代码更改后继续通过，就可以通过运行`helm package`命令打包图表。如果图表是使用 GitHub Pages 存储库提供的(例如在 [*第 5 章*](05.html#_idTextAnchor265)*构建您的第一个 Helm 图表*中创建的)，则通过运行`helm repo index`创建`index.yaml`文件，并将`index.yaml`文件连同打包的图表一起推送到 GitHub 存储库。
虽然手动调用每个命令肯定是可行的，但是随着您开发更多的 Helm 图表或添加更多的贡献者，这个工作流会变得越来越难以维持。使用手动工作流，很容易允许对图表进行未经测试的更改，并且很难确保贡献者遵守测试和贡献指南。幸运的是，这些问题可以通过创建一个 CI 管道来避免，该管道可以自动化您的发布过程。
以下步骤概述了一个使用本书中讨论的命令和工具的配置项工作流示例。假设结果图表保存在 GitHub Pages 存储库中:
1.  图表开发人员在`git`单回购中对一个图表或一组图表进行代码更改。
2.  开发人员将变更推送到远程存储库。
3.  通过运行`ct lint`和`ct install`命令，已修改的图表会自动在 Kubernetes 命名空间中进行剪切和测试。
4.  如果林挺和测试成功，图表将自动与`helm package`命令打包。
5.  使用`helm repo index`命令自动生成`index.yaml`文件。
6.  打包的图表和更新后的`index.yaml`文件会自动推送到存储库。它们被推至`stable`或`staging`，这取决于作业所针对的分支。
在下一节中，我们将使用**詹金斯**执行该过程。让我们从了解詹金斯是什么和它是如何工作的开始。
## 了解詹金斯
Jenkins 是一个用于执行自动化任务和工作流的开源服务器。通常使用通过詹金斯的**管道创建 CI/CD 管道，作为代码**特征，写在一个名为`Jenkinsfile`的文件中，该文件定义了一个詹金斯管道。
詹金斯管道是使用常规**领域特定语言** ( **DSL** )编写的。Groovy 是一种类似于 Java 的语言，但与 Java 不同，它可以用作面向对象的脚本语言，有助于编写易于阅读的自动化代码。在本章中，我们将带您浏览已经为您准备好的两个现有`Jenkinsfile`文件。你不需要有任何从零开始编写`Jenkinsfile`文件的经验，因为深入了解詹金斯已经超出了本书的范围。话虽如此，到本章结束时，您应该能够将学到的概念应用到您选择的自动化工具中。虽然詹金斯是本章的特色，但它的概念可以应用于任何其他自动化工具。
当创建`Jenkinsfile`文件时，工作流的已定义步骤集将在 Jenkins 服务器本身上执行，或者在被委派运行作业的单独代理中执行。每当构建开始时，通过自动将 Jenkins 代理调度为单独的 Pods，可以将附加功能与 Kubernetes 集成，从而简化代理的创建和管理。代理完成后，可以将其配置为自动终止，以便下一个构建可以在全新、干净的 Pod 中运行。在本章中，我们将使用詹金斯代理运行示例管道。
詹金斯还通过提供扫描源代码管理存储库来寻找`Jenkinsfile`文件的能力，很好地适应了 GitOps 的概念。对于包含`Jenkinsfile`文件的每个分支，将自动配置一个新作业，该作业将从克隆所需分支的存储库开始。这使得测试新特性和修复变得很简单，因为新作业可以在它们对应的分支旁边自动创建。
对詹金斯有了基本的了解，现在让我们在 Minikube 环境中安装詹金斯。
安装詹金斯
与通常部署在 Kubernetes 上的许多应用一样，Jenkins 可以使用 Helm Hub 的许多不同社区 Helm 图表之一进行部署。在本章中，我们将使用来自**代码中心**软件开发公司的詹金斯 Helm 图表。添加`codecentric`图表库，开始安装以代码为中心的詹金斯 Helm 图表:
```
$ helm repo add codecentric https://codecentric.github.io/helm-charts
```
在预期的与 Kubernetes 相关的值中，例如配置资源限制和服务类型，`codecentric` Jenkins Helm 图表包含用于自动配置不同 Jenkins 组件的其他与 Jenkins 相关的值。
由于配置这些值需要对 Jenkins 有更深入的了解，这超出了本书的范围，因此为您提供了一个`values`文件，它将自动准备以下 Jenkins 配置:
*   添加未包含在基础映像中的相关 Jenkins 插件。
*   配置使用 GitHub 进行身份验证所需的凭据。
*   配置专门为测试和安装 Helm 图表而设计的 Jenkins 代理。
*   将 Jenkins 配置为基于`Jenkinsfile`文件的存在自动创建新作业。
*   跳过通常在新安装启动时出现的手动提示。
*   禁用身份验证以简化本章的 Jenkins 访问。
`values`文件还将配置以下与 Kubernetes 相关的详细信息:
*   针对 Jenkins 服务器设置资源限制。
*   将詹金斯服务类型设置为`NodePort.`
*   创建 Jenkins 和 Jenkins 代理在 Kubernetes 环境中运行作业和部署 Helm 图表所需的服务帐户和 RBAC 规则。
*   将詹金斯`PersistentVolumeClaim`尺寸设置为`2Gi.`
该值文件可在[上获得。浏览这些值的内容时，可能会注意到`fileContent`下定义的配置包含 Go 模板。这个值的开头可以在这里看到:](https://github.com/PacktPublishing/-Learn-Helm/blob/master/jenkins/values.yaml)