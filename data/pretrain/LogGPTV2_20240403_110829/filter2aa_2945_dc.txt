AdventureWorksServicennnnnnnnn class does provide protected
constructors that do not require authentication information. You might
be tempted simply to change the access to these constructors to public so
that you can use them, but bear in mind that if you regenerate the REST
API client code, you will lose these changes (and it is also not good
practice). Instead, you should create a new class that extends
AdventureWorksServicennnnnnnnn and add a public constructor to this
class that calls the appropriate protected constructor in the
AdventureWorksServicennnnnnnnn class.
Azure API App Security
By default, when you deploy an Azure API app, authentication is
disabled, meaning that the web service exposed by the API is
available for use by anyone. You can see this in the Azure portal if
you go to your Azure API app and click the
Authentication/Authorization settings:
Download from finelybook PI:EMAIL
1051
However, you can easily enable authentication simply by
clicking the On button. You will then be given the option of how to
authenticate users. For example, you could ask users to log in
using a Microsoft account, or through Facebook, Twitter, or
Google (you can select multiple authentication options if required).
If you are creating a corporate application, you might prefer to use
Azure Active Directory. In each case, you need to register your
application with the authentication provider and arrange how users
will be authorized once they are authenticated.
Download from finelybook PI:EMAIL
1052
For more information, visit Authentication and authorization in
Azure App Service at  https://docs.microsoft.com/en-gb/azure/app-
service/app-service-authentication-overview#what-is-app-service-
authentication--authorization.
Once you have configured authentication, when you connect to
the web service you will be prompted for your credentials using
the appropriate authentication provider. If you are building a UWP
app, you can provide these credentials to the constructor that
creates the object that connects to the web service (an instance of
the AdventureWorksServicennnnnnnnn class in the example
shown in the exercises).
17. In Solution Explorer, right-click the Customers project, point to Add,
and then click Class. In the Add New Item – Customers dialog box,
enter the name AdventureWorksService.cs, and then click Add.
18. In the Code and Text Editor window, modify the
Download from finelybook PI:EMAIL
1053
AdventureWorksService class to inherit from the
AdventureWorksServicennnnnnnnn class, as shown below in bold:
Click here to view code image
class AdventureWorksService : AdventureWorksServicennnnnnnnn
{
}
19. Add the public constructor shown in bold in the code that follows, to the
AdventureWorksService class:
Click here to view code image
class AdventureWorksService : AdventureWorksServicennnnnnnnn
{
    public AdventureWorks()
        : base ()
    {
    }
}
This constructor actually invokes the following constructor in the
AdventureWorksServicennnnnnnnn class:
Click here to view code image
protected AdventureWorksServicennnnnnnnn(params
DelegatingHandler[] handlers) : base(handlers)
{
    this.Initialize();
}
Remember that the params keyword specifies a parameters array. If you
pass an empty parameter list, the params array will be empty. The
Initialize method in the AdventureWorksServicennnnnnnnn class
actually does the work of initializing the settings for the connection to
the web service
20. In Solution Explorer, double-click ViewModel to display the ViewModel
class in the Code and Text Editor window.
21. In the ViewModel constructor, comment out the code that sets the
customers field to the DataSource.Customers list, and add the following
code shown in bold:
Click here to view code image
Download from finelybook PI:EMAIL
1054
public ViewModel()
{
    ...
    // this.customers = DataSource.Customers;
    try
    {
        AdventureWorksService service = new
AdventureWorksService();
        this.customers =
service.CustomersOperations.GetCustomers().ToList();
    }
    catch
    {
        this.customers = null;
    }
}
The customers list contains the customers displayed by the app; it was
previously populated with the data in the DataSource.cs file that you
removed. The new code creates an AdventureWorksService object that
connects to your web service. The CustomersOperations property of this
object is a reference to a CustomerOperations object, which provides the
GetCustomers method to fetch the data from the web service, as
described previously. The data is converted to a list and stored in the
customers variable. Note that if an exception occurs, the customers list
is set to null; no customers will appear.
22. On the Debug menu, click Start Debugging to build and run the app.
It will take a few moments while the application fetches the data from
the web service; the splash screen will appear, but then the details of the
first customer, Orlando Gee, should be displayed:
Download from finelybook PI:EMAIL
1055
23. Use the navigation buttons in the command bar to move through the list
of customers to verify that the form works as expected.
24. Return to Visual Studio and stop debugging.
Inserting, updating, and deleting data through a REST
web service
Apart from giving users the ability to query and display data, many apps have
the requirement to let users insert, update, and delete information. The
ASP.NET Web API implements a model that supports these operations
through the use of HTTP PUT, POST, and DELETE requests.
Conventionally, a PUT request modifies an existing resource in a web
service, and a POST request creates a new instance of a resource. A DELETE
request removes a resource. The code generated by the Add Scaffold wizard
Download from finelybook PI:EMAIL
1056
in the ASP.NET Web API template follows these conventions.
Idempotency in REST web services
In a REST web service, PUT requests should be idempotent, which
means that if you perform the same update repeatedly, the result should
always be the same. In the case of the AdventureWorksService
example, if you modify a customer and set the telephone number to
“888-888-8888,” it does not matter how many times you perform this
operation because the effect is identical. This might seem obvious, but
you should design a REST web service with this requirement in mind.
With this design approach, a web service can be robust in the face of
concurrent requests, or even in the event of network failures (if a client
app loses the connection to the web service, it can simply attempt to
reconnect and perform the same request again without being concerned
whether the previous request was successful). Therefore, you should
think of a REST web service as a means for storing and retrieving data,
and you should not attempt to implement business-specific operations.
For example, if you were building a banking system, you might be
tempted to provide a CreditAccount method that adds an amount to the
balance in a customer’s account and expose this method as a PUT
operation. However, each time you invoke this operation, the result is
an incremental credit to the account. Therefore, it becomes necessary to
track whether calls to the operation are successful. Your app cannot
invoke this operation repeatedly if it thinks an earlier call failed or
timed out because the result could be multiple, duplicated credits to the
same account.
For more information about managing data consistency in cloud
applications, see “Data Consistency Primer” at
https://msdn.microsoft.com/library/dn589800.aspx.
In the next exercise, you will extend the Customers app and add features
with which users can add new customers and modify the details of existing
customers. The app will use the construct and submit the appropriate REST
Download from finelybook PI:EMAIL
1057
requests by using the REST API client and model you generated by using
Visual Studio. You will not provide any functionality to delete customers.
This restriction ensures that you have a record of all customers that have done
business with the Adventure Works organization, which might be required
for auditing purposes. Additionally, even if a customer has not been active
for a long time, there is a chance that the customer might place an order at
some point in the future.
Note It is becoming increasingly commonplace for business
applications never to delete data but simply to perform an update that
marks the data as “removed” in some way and prevents it from being
displayed. This is primarily because of the requirements to keep
complete data records, often to meet regulatory requirements.
Implement add and edit functionality in the ViewModel class
1. Return to Visual Studio.
2. In Solution Explorer, double-click the Customer.cs file in the root folder
of the Customers project to display it in the Code and Text Editor
window.
3. Immediately after the Phone property, add the following public
properties shown in bold to the Customer class:
Click here to view code image
public class Customer : INotifyPropertyChanged
{
    ...
    public string Phone
    {
        ...
    }
    public System.Guid rowguid { get; set; }
    public System.DateTime ModifiedDate { get; set; }
    ...
}
Download from finelybook PI:EMAIL
1058
The web service retrieves these fields from the database. Previously you
have ignored them when copying data into the customers list, but these
properties are important for updating data; the entity framework uses
these properties to determine which rows to change and to help resolve
conflicts if multiple users attempt to modify the same data
simultaneously.
4. In the Customers project, delete the ViewModel.cs file to remove it from
the project. Allow Visual Studio to delete this file permanently.
5. Right-click the Customers project, point to Add, and then click Existing
Item. Select the ViewModel.cs file, which is located in the \Microsoft
Press\VCSBS\Chapter 27 folder in your Documents folder, and then
click Add.
The code in the ViewModel.cs file is getting rather lengthy, so it has
been reorganized into regions to make it easier to manage. The
ViewModel class has also been extended with the following Boolean
properties that indicate the mode in which the ViewModel is operating:
Browsing, Adding, or Editing. These properties are defined in the region
named Properties For Managing The Edit Mode:
IsBrowsing This property indicates whether the ViewModel is
in Browsing mode. When the ViewModel is in Browsing mode,
the FirstCustomer, LastCustomer, PreviousCustomer, and
NextCustomer commands are enabled, and a view can invoke
these commands to browse data.
IsAdding This property indicates whether the ViewModel is in
Adding mode. In this mode, the FirstCustomer, LastCustomer,
PreviousCustomer, and NextCustomer commands are disabled.
You will define an AddCustomer command, a SaveChanges
command, and a DiscardChanges command that will be enabled
in this mode.
IsEditing This property indicates whether the ViewModel is in
Editing mode. As in Adding mode, in this mode, the
FirstCustomer, LastCustomer, PreviousCustomer, and
NextCustomer commands are disabled. You will define an
EditCustomer command that will be enabled in this mode. The
SaveChanges command and DiscardChanges command will also
Download from finelybook PI:EMAIL
1059
be enabled, but the AddCustomer command will be disabled. The
EditCustomer command will be disabled in Adding mode.
IsAddingOrEditing This property indicates whether the
ViewModel is in Adding or Editing mode. You will use this
property in the methods that you define in this exercise.
CanBrowse This property returns true if the ViewModel is in
Browsing mode and there is an open connection to the web
service. The code in the constructor that creates the
FirstCustomer, LastCustomer, PreviousCustomer, and
NextCustomer commands has been updated to use this property to
determine whether these commands should be enabled or
disabled, as follows:
Click here to view code image
public ViewModel(){
    ...
    this.NextCustomer = new Command(this.Next,
         () => { return this.CanBrowse &&
                 this.customers != null && !this.IsAtEnd;
});     this.PreviousCustomer = new Command(this.Previous,
         () => { return this.CanBrowse &&
                 this.customers != null && !this.IsAtStart;
});
    this.FirstCustomer = new Command(this.First,
         () => { return this.CanBrowse & &
                 this.customers != null && !this.IsAtStart;
})
    this.LastCustomer = new Command(this.Last,
         () => { return this.CanBrowse &&
                 this.customers != null && !this.IsAtEnd;
});}
CanSaveOrDiscardChanges This property returns true if the
ViewModel is in Adding or Editing mode and has an open
connection to the web service.
The Methods For Fetching And Updating Data region contains the
following methods:
ValidateCustomer This method takes a Customer object and
examines the FirstName and LastName properties to ensure that
they are not empty. It also inspects the EmailAddress and Phone
properties to verify that they contain information that is in a valid
Download from finelybook PI:EMAIL
1060
format. The method returns true if the data is valid and false
otherwise. You will use this method when you create the
SaveChanges command later in this exercise.
Note The code that validates the EmailAddress and Phone
properties performs regular expression matching by using the
Regex class defined in the System.Text.RegularExpressions
namespace. To use this class, you define a regular expression
in a Regex object that specifies the pattern that the data should
match, and then you invoke the IsMatch method of the Regex
object with the data that you need to validate. For more
information about regular expressions and the Regex class,
see “The Regular Expression Object Model” on the Microsoft
website at http://msdn.microsoft.com/library/30wbz966.
CopyCustomer The purpose of this method is to create a
shallow copy of a Customer object. You will use it when you
create the EditCustomer command to make a copy of the original
data of a customer before it is changed. If the user decides to
discard the changes, the original data can simply be copied back
from the copy made by this method.
6. In the ViewModel.cs file, find the Methods For Fetching And Updating
Data region (expand this region if necessary). In this region, above the
ValidateCustomer method, create the Add method shown here:
Click here to view code image
// Create a new (empty) customer
// and put the form into Adding mode
private void Add()
{
    Customer newCustomer = new Customer { CustomerID = 0 };
    this.customers.Insert(currentCustomer, newCustomer);
    this.IsAdding = true;
    this.OnPropertyChanged(nameof(Current));
Download from finelybook PI:EMAIL
1061
}
This method creates a new Customer object. It is empty apart from the
CustomerID property, which is temporarily set to 0 for display purposes.
The real value for this property is generated when the customer is saved
to the database, as described earlier. The customer is added to the
customers list (the view uses data binding to display the data in this list),
the ViewModel is placed in Adding mode, and the PropertyChanged
event is raised to indicate that the Current customer has changed.
7. Add the following Command variable shown in bold to the list at the
start of the ViewModel class:
Click here to view code image
public class ViewModel : INotifyPropertyChanged
{
    ...
    public Command LastCustomer { get; private set; }
    public Command AddCustomer { get; private set; }
    ...
}
8. In the ViewModel constructor, instantiate the AddCustomer command as
shown here in bold:
Click here to view code image
public ViewModel()
{
    ...
    this.LastCustomer = new Command(this.Last, ...);
    this.AddCustomer = new Command(this.Add,
        () => { return this.CanBrowse; });
    ...
}
This code references the Add method that you just created. The
command is enabled if the ViewModel has a connection to the web
service and is in Browsing mode (the AddCustomer command will not
be enabled if the ViewModel is already in Adding mode).
9. After the Add method in the Methods For Fetching And Updating Data
region, create a private Customer variable called oldCustomer and
define another method called Edit:
Click here to view code image
Download from finelybook PI:EMAIL
1062
// Edit the current customer
// - save the existing details of the customer
//   and put the form into Editing mode
private Customer oldCustomer;
private void Edit ()
{
    this.oldCustomer = new Customer();
    this.CopyCustomer(this.Current, this.oldCustomer);
    this.IsEditing = true;
}
This method copies the details of the Current customer to the
oldCustomer variable and puts the ViewModel into Editing mode. In
this mode, the user can change the details of the current customer. If the
user subsequently decides to discard these changes, the original data can
be copied back from the oldCustomer variable.
10. Add the following Command variable shown in bold to the list at the
start of the ViewModel class:
Click here to view code image
public class ViewModel : INotifyPropertyChanged
{
    ...
    public Command AddCustomer { get; private set; }
    public Command EditCustomer { get; private set; }
    ...
}
11. In the ViewModel constructor, instantiate the EditCustomer command as
shown in bold in the following code:
Click here to view code image
public ViewModel()
{
    ...
    this.AddCustomer = new Command(this.Add, ...);
    this.EditCustomer = new Command(this.Edit,
        () => { return this.CanBrowse; });
    ...
}
This code is similar to the statement for the AddCustomer command,
except that it references the Edit method.
Download from finelybook PI:EMAIL
1063
12. After the Edit method in the Methods For Fetching And Updating Data
region, add a method named Discard to the ViewModel class, as shown
here:
Click here to view code image
// Discard changes made while in Adding or Editing mode
// and return the form to Browsing mode
private void Discard ()
{
    // If the user was adding a new customer, then remove it
    if (this.IsAdding)
    {
        this.customers.Remove(this.Current);
        this.OnPropertyChanged(nameof(Current));
    }
    // If the user was editing an existing customer,
    // then restore the saved details
    if (this.IsEditing)
    {
        this.CopyCustomer(this.oldCustomer, this.Current);
    }
    this.IsBrowsing = true;
}
The purpose of this method is to enable the user to discard any changes
made when the ViewModel is in Adding or Editing mode. If the
ViewModel is in Adding mode, the current customer is removed from
the list (this is the new customer created by the Add method), and the
PropertyChanged event is raised to indicate that the current customer in
the customers list has changed. If the ViewModel is in Editing mode, the
original details in the oldCustomer variable are copied back to the
currently displayed customer. Finally, the ViewModel is returned to
Browsing mode.
13. Add the DiscardChanges Command variable to the list at the start of the
ViewModel class, and update the constructor to instantiate this
command, as shown here in bold:
Click here to view code image
public class ViewModel : INotifyPropertyChanged
{
    ...
    public Command EditCustomer { get; private set; }
Download from finelybook PI:EMAIL
1064
    public Command DiscardChanges { get; private set; }
    ...
    public ViewModel()