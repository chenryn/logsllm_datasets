在收集到一份静态节点列表，获取静态节点列表的链接信息之后，我们就该考虑一下如何触发各个节点上的事件了。
首先，我们来谈一下如何触发鼠标、键盘相关的事件，主要方法有两：
  * dispatchEvent
  * CDP 的 Input.dispatchMouseEvent
我们使用一个简单的例子看一下两者最大的差别：
使用 CDP 测试两者区别：
结果：
`dispatchEvent` 和 `Input.dispatchMouseEvent` 这两者最大的区别就是事件来源是否是真实的用户点击， 虽说
`isTrusted` 也就是一个改 Chromium 代码就能解决的问题，但我们也没法保证还有没有其他黑科技来检测是否事件是否来自真实用户。
然而我还是觉得 CDP 实在太慢，所以还是继续选择使用 `dispatchEvent` 来触发各种事件。
接下来我们要考虑一下如何使用 `dispatchEvent` 触发事件， 可能有些同学觉得，我们可以扫描所有元素节点，收集内联事件，对于动态添加的事件，可以
Hook addEventListener 获取到， 最后再挨个触发元素相对应的事件，其实这样做是有问题的。
我们还是先看看一个例子：
例子将事件绑定在 container 内，等事件冒泡到 container，再通过 event.target 区分元素。
如果按照之前的思路，我们的代码将会在 container 中触发一个点击事件，而忽略了 container 下的两个按钮，所以之前的思路并不合理。
我个人的想法是，每个元素都只触发常用的事件，比如说 click、dbclick、mouseover 等事件，忽略一些非主流事件。
只触发常见的键盘、鼠标事件让我们的行为更像是一个正常人类的行为，这样也减少了被反爬虫机制带入坑的可能性。
另外，说到爬虫行为做到和正常人类类似，还有一个小细节，那就是元素是否在可见区域， 以前都是直接将浏览器的 viewpoint 设置最大，现在我们使用
`element.scrollIntoViewIfNeeded` 将滚动条滚动到元素的位置，然后再触发事件。
#### 0x05 新节点
那么问题又来了，由于我们各种点击、敲击键盘、尝试触发各种操作而产生新的节点，我们该怎么办？
肯定还是要继续处理这些新节点，但是怎么找到这些新节点，难道还要重新再扫一遍 DOM 查找新节点？ 有没有一个方法可以获取到变化的属性和节点？
在 HTML5 中就刚好有这么一个类 `MutationObserver`，我们看看例子：
按顺序点击 btn1 和 btn2 的结果：
所以我们完全可以利用 MutationObserver
作深度优先的扫描，如果弹出新的节点，那就优先处理新的节点。每次都是先静态扫描新的节点列表，然后再尝试触发新增节点列表的事件。
但是值得注意的是 MutationObserver
并不会实时将变更元素传回来，而是收集一个时间段的元素再传回来，所以未能及时切换到新的节点继续触发事件也是正常的事情。
#### 0x06 自动填写表单
OK，事件我们触发了，新节点我们也处理了，这里我们还需要对一些元素进行特殊处理，比如说自动填写表单内的输入元素。
这一小节没什么难度，主要是判定哪些地方该填名字，哪些地方该填邮箱，哪些地方该填号码，
需要根据不同情况输入对应的数据。另外还要注意的是在填写数据的时候还要触发对应的事件，例如填写 `` 的时候，
我们需要把鼠标移动到 input 元素上，对应触发 mouseover、mouseenter、mousemove 消息， 接着要鼠标点击一下输入点，对应
mousedown、mouseup、click 消息， 然后鼠标移开转到其他元素去，对应 mousemove、mouseout、mouseleave 消息。
这里还有个小建议，所有的用户输入都带上一个可识别的词， 例如我们自定义词为 CasterJS，email 处就填写 casterjs @gmail.com，
addr 处就写 casterjs road， 至于为什么下一篇再说。
#### 0x07 CDP
这一个小结主要和 CDP 相关的 TIP ，使用什么语言操控 CDP 都行，在这里我选择我比较熟悉的 Python 作为解释。
##### 自定义 request
CDP 在 navigate 的时候并不能直接自定义 request，通俗的讲就是在 navigate 的时候并不能设置 method 和 headers
等信息， 但很明显这个功能对我们的扫描器来说非常重要。幸运的是，虽然 CDP 没有直接支持这样的功能，但可以通过
`Network.requestIntercepted` 变向实现这样的功能。
代码如下：
结果：
##### 网络优化
我们的浏览器是肯定需要加载 css 和 js 的，那其他网络资源如图片、视频等媒体资源是不是可以直接禁止加载？
其实这样做并不合理，直接禁用图片等资源可能会影响到用户代码执行逻辑，例如我们常见的 ``，
所以比较好的解决方法就是返回假的媒体资源。
代码如下：
##### session isolate
我们的扫描器可能会有使用不同用户信息扫描同一个域名的情况， 我们肯定不希望在同一个 browser 下，不同 tab 的 Cookie 信息等串在一起，
我们希望每个 tab 都有一个隐身模式，每个 tab 都资源互不影响， 比较走运的是 Headless Chrome 刚好有这么一个功能，叫 session
isolate ，也是 Headless 模式下独有的功能。
我们看一下 Headless 模式的 session isolate 功能的简单例子：
运行结果：
如果注释 1、2 两行，运行结果：
所以只要每个 tab 都新建一个 BrowserContext 就可以做到互不干扰了， 这也就相当于每个 tab 都是一个独立的隐身模式，能够做到每个
tab 互不影响， 也可以共用一个 BrowserContext 达到共享 cache、cookie 之类信息的功能。
##### 安全问题
从 chromium 62 开始存在一个安全问题，在使用 remote-debugging-port 参数的时候可以系统上任意写文件， 我已经提交安全
issue 给 chromium， 可惜撞洞了，有人比我早了一个月提交了相关漏洞， 所以在选定 chromium
版本的时候要注意跳过这些版本或者自行修复这些问题。
#### 0x08 结合
讲了那么多，是时候该把所有的东西结合在一起，我们先简单捋一下执行过程：
  1. 注入 Hook 相关的 JavaScript 代码
  2. 使用 TreeWalker 遍历节点，收集节点链接信息，获取静态的节点列表
  3. 触发各个节点的相关操作，自动填写表单
  4. MutationObserver 监控动态节点创建，优先处理新节点
我们以 `http://testphp.vulnweb.com/AJAX/index.php` 作为例子跑一遍，看一下我们代码的执行状况，
为了更方便的展示，我将每个节点（触发事件）的处理时间都额外增加了 0.1s，同时也给所有节点都加上了边框，蓝色边框表示正在处理的节点。
测试视频：
通过加边框和打 log 的方式，我们完全可以一步一步的看着爬虫的操作是否符合我们的预期。这个例子的结果证明了:
  * xhr 的 hook（不被其他 xhr 中断）
  * 事件的触发（新节点的产生）
  * MutationObserver 的监控（正确处理新节点）
  * 图片资源的处理（原始图片被替换）
  * 窗口的处理（没有弹 alert 窗）
上面的行为是符合我们的预期的。
目前第一篇和第二篇的内容总算是组合在了一起，成为了一个能够独立运行、测试的组件，该组件所提供的功能就是输入一个 request 相关的信息，返回
response 中所有的链接信息， 如果我们的爬虫存在链接信息漏抓，那很可能就是这部分出问题，所以也只需要调试这部分代码即可，非常方便。
该组件可以通过stdin/stdout、RPC、消息队列等方式传递任务和结果。 可以通过在单台机器上多开 tab 达到纵向扩展，也可以在多台机器上启多个
browser 达到横向扩展，这部分各自有自个的想法，不会就这个方向继续写下去了。
#### 0x09 总结
至此，Web 漏洞扫描器爬虫中的 Downloader 这部分我已经简单地介绍了一遍，
对照一下我自己的代码，也深知这部分我并没有讲全，因为这部分坑多，内容也乱且多，但是再写下去就真的没完没了，看着累，写着更累，得赶紧切到下一个话题。
* * *