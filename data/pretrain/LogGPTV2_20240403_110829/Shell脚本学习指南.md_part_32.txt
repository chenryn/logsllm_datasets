变量替换
R
?
合令替换
算水表达式替换
展开的文本进行单偶分
通配符展开
会查找：特殊内建合令，孟数，
内建合令
图7-1：命令行处理中的步骤
www.TopSage.com
---
## Page 192
180
第7章
整个参骤顺序如图7-1所示，看起来有点复杂，当命令行被处理时、每一个步骤都是在
Shell的内存里发生的：Shell不会真地把每个步骤的发生显示给你看。所以，你可以假
想这是我们偷窥Shell内存里的情况，从而知道每个阶段的命令行是如何被转换的。我
们从这个例子开始说：
$ mkdir, /tnp/x
建立临时性目录
$ od/tnp/x
切换到该目录
$ touch f1 f2
建立文件
S echo +/$(f)[12] $y $（echo cnd eubat）$（(3+2))>oat
S f=f y=*a b"
赋值两个变量
忙绿的命令
上述的执行步骤要如下：
1.命令一开始会根据Shell语法而分割为token。最重要的一点是：I/O重定向>out
在这里是被识别的，并存储供稍后使用。流程继续处理下面这行，其中每个token
的范围显示于命令下方的行上：
echo ~+/$(f) [12] $y $(echo cmd subst) $((3 + 21)
1 11 [=.- 2 -·-1  3 [=··..- 4 -*...-| |-- 5 =*-|
2.检查第一个单词（echo）是否为关键字，例如if或for。在这里不是，所以命令
行不变继续处理。
3.
检查第一个单词（依然是echo）是否为别名。在这里并不是，所以命令行不变，
继续往下处理，
4.
扫描所有单词是否需要波浪号展开。在本例中，~+为ksh93与bash的扩展，等
同于SPWD，也就是当前的目录（这部分在14.3.7节介绍）。token2将被修改，处
理继续如下：
echo /tmp/×/$(f) (12] $y $(echo cnd subnt) $((3 + 2))
1 11 1----- 2 -----1  3 1---.-- 4 -...-1 1-- 5 ---]
5.下一步是变量展开：token2与3都被修改.这会产生：
echo /tmp/x/f(12] a b $(echo cnd subst) $[(3 + 21)
1 11 1===- 2 =.=] 131 |=.*=== 4 ==.**=| 1-- 5 -==]
6.再来要处理的是命令替换，注意，这里可递归引用列表里的所有步骤！在此例中，
因为我们试图让所有的东西容易理解，因此命令替换修改了token4，结果如下：
1 11 [---- 2 ---| J31, 1--_ 4 --1 1-- 5 ---]
({z + t11s #qns puoq e. [2t13/x/dea/ ouoe
7.现在执行算术替换。修改的是token5，结果是：
5 xsqne puo q e (zt1z/x/dua/ ouoe
1 11 1---- 2 ---| 131 1-- 4 --1 5
‘8
前面所有的展开产生的结果：都将再一次被扫描，看看是否有$IFS字符。如果有，
则它们是作为分隔符（separator），产生额外的单词。例如，两个字符Sy原来是组
www.TopSage.com
---
## Page 193
y
输入/输出、文件与命令执行
成一个单词，但展开式“a-空格-b”，在此阶段被切分为两个单词；a与b.相同cOm1
方式也应用于命令替换S（echocmdsubst）的结果上。先前的token3变成了
token3与4。先前的token4则成了token5与6。结果则为：
1 111-2-1 341511617
q/xd/
9.最后的替换阶段是通配符展开。token2变成了token2与3，结果如下：
echo /tmp/x/f1 /tap/x/f2 a b cmd subst 5
1 11 1-- 2 --1 1-- 3 =-1 4 5 6 1 7 1 8
10.这时，Shell已经准备好要执行最后的命令了。它会去寻找echo。正好ksh93与
bash里的echo都已内建到Shell中。
11.Shell实际执行命令：首先执行>out的I/O重定向，再调用内部的echo版本，显
示最后的参数。
这是最后的结果：
S cat out
/tnp/x/f1 /tmp/x/f2 a b cmd subst 5
7.8.1eval语句
eval语句是在告知Shell取出eval的参数，并再执行它们一次，使它们经过整个命令
行的处理步骤，这里有个例子可以让你了解eval究竞是什么。
evalls会传递字符串1s给Shell执行，所以Shell显示当前目录下的文件列表。这个
例子太简单了：字符串1s上没有东西需要被送出以让命令行处理两个步骤。所以我们
来看这个：
listpage=*1s 1 more*
$listpage
为什么Shell会把1与more看作ls的参数，而不是直接产生一页页的文件列表呢？这
是由于在Shel执行变量时，管道字符出现在步骤5，也就是在它确实寻找管道字符之后
（在步骤1）。变量的展开一直要到步骤8才进行解析。结果，Shell把1与more看作1s
的参数，使得1s会试图在当前目录下寻找名为1与more的文件！
现在，想想evalSlistpage吧，在Shell到达最后一步时，会执行带有ls、1与more
参数的eval。这会让Shell回到步骤1；具有一行包括了这些参数的命令。在步骤1发
现1后，将该行分割为两个命令：1s与more。每个要被处理的命令都以一般方式执行，
最后的结果是在当前目录下已分页的文件列表。
www.TopSage.com
---
## Page 194
182
第7章
7.8.2subShell与代码块
还有两个其他的结构，有时也很有用：subShell与代码块（codeblock）。
subShell是一群被括在圆括号里的命令，这些命令会在另外的进程中执行（注4）。当你
需要让一小组的命令在不同的目录下执行时，这种方法可以让你不必修改主脚本的目录，
直接处理这种情况。例如，下面的管道是将某个目录树复制到另一个地方，在原始的V7
UNIXtar（1）的手册页里可以看到此例：
tar -cf - . 1(cd /newdiri tar -xpf -)
左边的tar命令会产生当前目录的tar打包文件（archive），将它传送给标准输出。这
份打包文件会通过管道传递给右边subShell里的命令。开头的cd命令会先切换到薪目
录，也就是让打包文件在此目录下解开。然后，右边的tar将从打包文件中解开文件。
请注意，执行此管道的Shell（或脚本）并未更改它的目录。
代码块（codeblock）概念上与subShell雷同，只不过它不会建立新进程。代码块里的
命令以花括号（（））括起来，且对主脚本的状态会造成影响（例如它的当前目录），一
般来说，花括号被视为Shell关键字：意即它们只有出现在命令的第一个符号时会被识
别。实际上：这表示你必须将结束花括号放置在换行字符（newline）或分号之后。例如：
cd /eome/directory 11 (
代码块开始
echo could not chanige to /some/directory! >&2
怎么了
echo you lose! >k2
挖害信息
exit 1
终上整个润抑车
代码块结束
I/O重定向也可套用到subShell（如先前的两个tar例子）与代码块里。在该情况下，所
有的命令会从重定向来源读取它们的输人或传送它们的输出。表7-8简单说明subShell
与代码块之间的差异。
表7-8：SubShell与代码块
SubShell().
行上的任何位置
代码块（}
在换行字符、分号或关键字之后否
要用subShell还是代码块需要根据个人的喜好而定，主要差异在于代码块会与主脚本共
享状态。这么一来，cd命令会对主脚本造成影响，也会对变量赋值产生影响。特别是，
注 4:
POSIX的标准说法是“subShell环境”，即命令不需要真的在另外的进程中执行：然而，
它们只是被禁止更换主脚本的环境（变量、目意目录等等），ksh93会避免为subShell命
今启动一个实际的进程（如果它可以的语），大部分其他的Shell会产生一个单个进程，
www.TopSage.com
---
## Page 195
输入/输出、文件与命令执行
183
代码块里的exit会终止整个脚本。因此，如果你希望将一组命令括起来执行，而不要
影响主脚本，则应该使用subShell。否则，请使用代码块。
7.9
内建命令
Shell有为数不少的内建（built-in）命令，指的是由Shell本身执行命令，而并非在另外
的进程中执行外部程序，POSIX更进一步将它们区分为“特殊（special）内建命令以
及“一般（regular）”内建命令。内建命令行参见表7-9，特殊内建命令以+标示。大部
分这里列出的一般内建命令都必须内建于ShelI中，以维持Shell正常地运行（例如
read）.其他内建于Shell内的命令，则只是为了效率（例如true与false）。在此标准
下，也为了更有效率，而允许内建其他的命令，不过所有的一般内建命令都必须能够以
单个的程序被访问，也就是可以被其他二进制程序直接执行。像test内建命令就是为
了让Shell的执行更有效率。
表7-9：POSIX的Shell内建命令
命令
摘要
：（冒号）送
不做任何事（只作参数的展开）
（点号）
读取文件井于当前Shell中执行它的内容
alias(别名)
设置命令或命令行的捷径（交互式使用）
bg
将工作置于后台（交互式使用）
break
从for，while或until循环中退出
cd
改变工作目录
command
找出内建与外部命令：寻找内建命令而非同名的函数
continue
跳到下一个for，while或until循环重复
eva1 
将参数当成命令行来处理
xe
以给定的程序取代Shell或为Shell改变I/O
exit
退出 Shell
export a
建立环境变量
false
什么事也不微，指不成功的状态
fc
与命令历史一起运行（交互式使用）
fg
将后台工作置于前台（交互式使用）
sqdoqab
处理命令行的选项
jobs
列出后台工作（交互式使用）
k111
传送信号
www.TopSage.com
---
## Page 196
184
表7-9：POSIX的Shell内建命令（续）
com
命令
摘要
newgrp
以新的groupID启动新Shell（已过时）
pwd
打印工作目录
read
从标准输入中读取一行
readonly
让变量为只读模式（无法指定的）
return
从包围函数中返网
set
设置选项或是位置参数
shife #
移位命令行参数
timeg
针对Shel1与其子代Shell，显示用户与系统CPU时间的累计
trap
设置信号捕捉程序
ture
什么事也不做，表示成功状态
umask
设置/显示文件权限掩码（mask）
unalias
删除别名定义（交互式使用）
unset α
删除变量或函数的定义
wa1t
等待后台工作完成
注：bash的source命今（来自于BSDCShell）是等网于点号命今，
特殊内建命令与一般内建命令的差别在于Shell查找要执行的命令时。命令查找次序是
先找特殊内建命令，再找Shell函数，接下来才是一般内建命令，最后则为SPATH内所
列目录下找到的外部命令。这种查找顺序让定义Shell函数以扩展或覆盖一般sehll内建
命令成为可能。
这一功能最常用于交互式Shell中，举例来说，当你希望Shell的提示号能包含当前目录
路径的最后一个组成部分。最简单的实现方式，就是在每次你改变目录时，都让Shell改
变PS1。你可以写一个自己专用的函数，如下所示：
chdir---在改变目录时也更新PS1的个人函数
chdir ()(
cd *$e*
取得当前目录的名称，传到变量x
实际更改目录
x=S (pwd)
PS1=*S(x#*/)\S *
截新前面的组成部分后，指定给PS1
这么微会有个问题：你必须在Shell下输人chdir而不是cd，如果你突然忘了而输人
cd，你会在新的目录上，但提示号就不会改变了，基于这个原因，你可以写一个名为cd
的函数，然后Shell就会先找到你的函数，因为cd是一般内建命令：
www.TopSage.com
---