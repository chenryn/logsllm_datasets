S
9
9
S
9
9
*
R
U
0
3
U
0
3
R
0
3
L
9
7
A
Figure 10: The variation in code generation for six selected
distributions, n = 125, 000.
S99* uses the same distribution, but for a different rate.
As described in Section 4, when the total number of edges
generated by the left and right nodes do not match, edges
are added to or subtracted from random nodes until they
do match. Thus, even a regular distribution such as this
one, when employed for the wrong rate as in this instance,
can generate a wide variety of graphs. It is interesting that
this distribution produces better codes for the wrong rate,
both in the best and median case, than the rate for which it
is developed. It is also interesting that this regular graph,
which theoretically should achieve an asymptotic overhead
3 [Sho99], in actuality
factor of
achieves a far better one for both rates.
= 1.45 for R = 2
0.68731
1
The next two distributions, RU03 and U03, are for Gal-
lager graphs with rate 1
2 . RU03 is right regular, meaning
all right-hand nodes have the same number of incoming
edges, which is a desirable property, because it simpliﬁes
code analysis and distribution generation [Sho99, RU03].
U03 is nearly right regular. Both distributions generate
codes with a large spread in performance; however, both
have the desirable quality that their medians are very close
to their minimum values.
In other words, one does not
have to generate many codes to get one that performs op-
timally or near optimally.
The next distribution, for IRA graphs, is also right regu-
lar, but has far less desirable generation properties, as it has
a very large range of overhead factors, and its median is ex-
tremely high. The last distribution, for two-level System-
atic codes, is one whose nodes have an exceptionally large
range of cardinalities – over a million for left nodes (al-
though with n = 125, 000, the range is reduced to 32,769),
and over 30,000 for right nodes. Interestingly, though, its
range of overhead factors is less than R03, although it is
still a large range.
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:51:25 UTC from IEEE Xplore.  Restrictions apply. 
While more distributions can be displayed, the bottom
line remains the same — some distributions yield good
codes with only a few iterations of code generation. Oth-
ers require a longer time to generate good codes. Clearly,
one must generate multiple instances of codes to ﬁnd one
that performs well for given values of n and m.
Challenge To The Community: Besides asymptotic
performance, some measure of how quickly a distribution
yields good codes in practice should be developed. While
distributions such as R03 for IRA graphs and L97A for
Systematic graphs do produce excellent codes, they only
do so in relatively rare cases, and thus are difﬁcult to uti-
lize.
6.5 Question 5
How do the codes compare to Reed-Solomon coding?
The Digital Fountain authors have demonstrated that
Tornado codes greatly outperform Reed-Solomon codes
for R = 1
2 and large n [BLMR98]. On the other end of
the spectrum, the implementers of OceanStore, a highly
distributed ﬁle system, selected Reed-Solomon coding for
their erasure-based archival service, employing small val-
ues of n and a rate of 1
4 [RWE+01]. In the middle of these
two extremes resides a gray area, which is exacerbated by
the fact that the literature on LDPC codes is heavy on the-
ory and light on practice.
Answering this question thoroughly is beyond the scope
of this paper. However, as a “teaser,” we present example
results of a basic simulation, where timings of wide-area
downloads to a client (Dell Precision 330, with an Intel
Pentium 4 processor) on a wireless network were com-
bined with timings of the processor reconstructing those
blocks using both LDPC codes, and a public-domain im-
plementation of Reed-Solomon codes [Pla03]. These tim-
ings were used to calculate the average time to download a
1 GB ﬁle using Reed-Solomon coding and the three kinds
of LDPC codes. The results are plotted in Figure 11.
For each value of n, we break the ﬁle into n equal size
blocks, and calculate the appropriate number of coding
blocks. We then use our timings and best LDPC codes to
calculate the average download times given that the down-
loaded blocks arrive in random order. We plot results for
all n ≤ 150. We include the “perfect” download time in
these graphs – this is the optimal time to download the ﬁle
without coding (or erasures).
For all rates, Reed-Solomon coding outperforms the
LDPC codes for small values of n (n < 36 for R = 1
3 ,
n < 26 for R = 1
3 ). This is due
to the perfect overhead factor of Reed-Solomon codes as
compared to the LDPC codes. However, the performance
of Reed-Solomon coding rapidly deteriorates because of
its expensive arithmetic operations and its O(n3) matrix
2 , and n < 12 for R = 2
Systematic
Gallager
Rate = 2/3
Reed-Solomon
Perfect
s
d
n
o
c
e
S
1300
1200
1100
1000
900
Rate = 1/3
1300
1200
1100
1000
900
IRA
Rate = 1/2
1300
1200
1100
1000
900
0 5
0
1
0
0
1
5
0
0 5
0
1
0
0
1
5
0
0 5
0
1
0
0
1
5
0
n
n
n
Figure 11: Example comparison of LDPC and Reed-
Solomon codes downloading a 1 GB ﬁle to a client on a
wireless network.
inversion. Focusing solely on the LDPC codes, the Sys-
tematic codes outperform the IRA codes, which in turn
outperform the Gallager codes. This is due to the fact
that the underlying graphs have fewer edges – the Gallager
graphs have m more left nodes than the others, and the
IRA graphs have an extra 2m − 1 edges for the accumula-
tor nodes.
The complete simulation (in [PT03]) gives the fol-
lowing insights with regard to Question 5: As down-
load speeds improve, rates increase, and n increases,
LDPC codes signiﬁcantly outperform Reed-Solomon
codes. However, when n is small and the download speeds
are slow, Reed-Solomon coding can signiﬁcantly outper-
form LDPC codes.
Challenge to the Community: The simulation used to
produce this example was simplistic in that it employed
simple equations based on average values.
In reality,
download speeds can vary greatly from block to block, fol-
lowing non-trivial probability distributions. A better anal-
ysis of Question 5 needs to be performed, which either
performs actual downloads of data on the wide-area net-
work, or employs download traces to simulate downloads.
Additionally, Cauchy Reed-Solomon coding [BKK+95]
should be evaluated, as it performs arithmetic operations
in GF (21) for all values of n and m.
7 Conclusion
This paper has performed a practical exploration of the
utility of LDPC codes for wide-area network storage ap-
plications. While the asymptotic properties of these codes
have been well studied, we have attempted to illuminate
their performance for ﬁnite systems by addressing ﬁve
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:51:25 UTC from IEEE Xplore.  Restrictions apply. 
questions, whose answers we summarize below:
Question 1: The overhead factor of LDPC codes, while
asymptotically approaching 1, reaches its maximum value
when n is in the range of 10 to 100. This maximum in-
creases as the rate decreases, roughly summarized as 1.20
for R = 1
2 and 1.10 for R = 2
3 .
3 , 1.15 for R = 1
Question 2: The three types of codes perform differ-
ently. Systematic codes perform the best for n < 100.
IRA codes perform the best for n ≥ 100.
Question 3: Codes derived adaptively from other codes
perform better than those derived from published distribu-
tions. Systematic codes in particular do not perform well
from the distributions designed for them.
Question 4: Some distributions produce codes that
vary widely in performance. Others produce codes that
are more consistent with one another. Properties like right-
regularity do not appear to make a difference.
Question 5: While there are practical situations where
Reed-Solomon coding clearly outperforms LDPC codes
for small values of n, as n grows, the LDPC codes vastly
outperform Reed-Solomon coding.
From these questions, we can draw the following bottom
line conclusions:
Conclusion #1: While Λ and P sufﬁce for deriving
codes with asymptotically good performance, their use as
generators of ﬁnite codes and indicators of ﬁnite code per-
formance is lacking.
In the course of this research, we
have compiled a mass of codes which perform well, but
these have come about by brute force Monte Carlo tech-
niques. The theoretical community is challenged to derive
more effective techniques for generating ﬁnite codes.
Conclusion #2: Clearly, LDPC codes, even subopti-
mal ones, are very important alternatives to Reed-Solomon
codes. A more thorough analysis comparing the perfor-
mance of these two types of codes needs to be performed,
with the goal of providing storage system users with rec-
ommendations for the optimal coding technique, value
of n, and value of m, given their system’s performance
and failure parameters.
One limitation of the LDPC codes in this paper is that
they have not been designed to adjust to different rates. It
is easy to envision a situation where a ﬁle already broken
into n blocks is spread among n + m storage servers, and
then m(cid:1) new servers are added to the system. If the cod-
ing method that stores the original n + m blocks can adapt
n+m+m(cid:1) , then adding new coding
efﬁciently to a rate of
blocks to the system is a straightforward and efﬁcient op-
eration. However, if the coding technique must be altered
to accommodate the new rate, then old coding blocks must
be discarded, and new ones calculated in their place, which
will be inefﬁcient. Reed-Solomon codes have the feature
that they adapt to any rate, although the same inefﬁcien-
n
cies pointed out by section 6.5 apply. New codes called
LT codes and Raptor codes, that adapt to any rate with
optimal asymptotic performance have been developed by
Luby and Shokrollahi [Lub02, Sho03]. It is a subject of
future work to perform a practical analysis of these codes.
References
[ASE92]
[AW03]
[BKK+95]
[BLM99]
[BLMR98]
[BM93]
N. Alon, J. W. Spencer, and P. Erdos. The Probabilistic Method. John
Wiley & Sons, New York, 1992.
M. S. Allen and R. Wolski. The Livny and Plank-Beck Problems:
Studies in data movement on the computational grid. In SC2003.
J. Blomer et al. An XOR-based erasure-resilient coding scheme. Tech.
Rep. TR-95-048, Int. Computer Science Inst., August 1995.
J. W. Byers et al. Accessing multiple mirror sites in parallel: Using
tornado codes to speed up downloads. In IEEE INFOCOM, 1999.
J. Byers, M. Luby et al. A digital fountain approach to reliable distri-
bution of bulk data. In ACM SIGCOMM ’98, pages 56–67, 1998.
W. A. Burkhard and J. Menon. Disk array storage system reliability.
In 23rd Int. Symp. on Fault-Tolerant Comp., pages 432–441, 1993.
[CLG+94] P. M. Chen et al. RAID: High-performance, reliable secondary stor-
age. ACM Computing Surveys, 26(2):145–185, June 1994.
[Gal63]
[JKM00]
[DPT+02] C. Di et al. Finite-length analysis of low-density parity-check codes
on the binary erasure channel. IEEE Trans. Infor. Thy., 48:1570–1579,
2002.
R. G. Gallager. Low-Density Parity-Check Codes. MIT Press, Cam-
bridge, MA, 1963.
H. Jin, A. Khandekar, and R. McEliece. Irregular repeat-accumulate
codes. In 2nd Int. Symp. on Turbo codes and Related Topics, 2000.
J. Kubiatowicz et al. Oceanstore: An architecture for global-scale
persistent storage. In Proceedings of ACM ASPLOS. Nov. 2000.
[LMS+97] M. Luby, M. Mitzenmacher, A. Shokrollahi, D. Spielman, and V. Ste-
mann. Practical loss-resilient codes. In 29th Annual ACM Symposium
on Theory of Computing,, pages 150–159, 1997.
[KBC+00]
[LS00]
[Lub02]
[McE00]
[LMS98] M. Luby, M. Mitzenmacher, and A. Shokrollahi. Analysis of random
processes via and-or tree evaluation. In 9th Annual ACM-SIAM Sym-
posium on Discrete Algorithms, January 1998.
W. Litwin and T. Schwarz. Lh*rs: a high-availability scalable dis-
tributed data structure using Reed Solomon codes. In 2000 ACM SIG-
MOD, pages 237–248, 2000.
M. Luby. LT codes. In IEEE Symp. on Found. of Comp. Sci., 2002.
R. J. McEliece. Achieving the Shannon Limit: A progress report.
Plenary Talk, 38th Allerton Conference, October 2000.
J. S. Plank. Improving the performance of coordinated checkpointers
on networks of workstations using RAID techniques. In 15th Sympo-
sium on Reliable Distributed Systems, pages 76–85, October 1996.
J. S. Plank. GFLIB - C procedures for Galois Field arithmetic and
Reed-Solomon coding. http://www.cs.utk.edu/˜plank/
plank/gflib/index.html, 2003.
J. S. Plank and M. G. Thomason. On the practical use of LDPC erasure
codes for distributed storage applications. Technical Report CS-03-
510, University of Tennessee, September 2003.
[Pla03]
[Pla96]
[PT03]
[RGCV03] A. Roumy et al. Design methods for irregular repeat accumulate
codes. In IEEE Int. Symp. on Information Theory, Yokohoma, 2003.
T. Richardson and R. Urbanke. Modern coding theory. Draft from
lthcwww.epfl.ch/papers/ics.ps, August 2003.
[RWE+01] S. Rhea et al. Maintenance-free global data storage. IEEE Internet
[RU03]
[Sho99]
[Sho00]
[Sho03]
[SS00]
[Tuf83]
[Urb03]
[WK02]
[WK03]
[ZL02]
Computing, 5(5):40–49, 2001.
M. A. Shokrollahi. New sequences of linear time erasure codes ap-
proaching the channel capacity. In Proceedings of AAECC-13, Lecture
Notes in CS 1719, pages 65–76, New York, 1999. Springer-Verlag.
M. A. Shokrollahi. Codes and graphs. Lecture Notes in Computer
Science, 1770, 2000.
A. Shokrollahi. Raptor codes. Technical Report DR2003-06-001, Dig-
ital Fountain, 2003.
M. A. Shokrollahi and R. Storn. Design of efﬁcient erasure codes with
differential evolution. In IEEE Int. Symp. on Infor. Theory, 2000.
E. R. Tufte. The Visual Display of Quantitative Information. Graphics
Press, Cheshire, Connecticut, 1983.
R. Urbanke et al. LdcpOpt - a fast and accurate degree distribution
optimizer for LPDC ensembles. http://lthcwww.epfl.ch/
research/ldpcopt/index.php, 2003.
H. Weatherspoon and J. Kubiatowicz. Erasure coding vs. replication:
A quantitative comparison. 1st Int. Work. on Peer-to-Peer Sys., 2002.
S. B. Wicker and S. Kim. Fundamentals of Codes, Graphs, and Itera-
tive Decoding. Kluwer Academic Publishers, Norwell, MA, 2003.
Z. Zhang and Q. Lian. Reperasure: Replication protocol using erasure-
code in peer-to-peer storage network. In 21st IEEE Symposium on Re-
liable Distributed Systems (SRDS’02), pages 330–339, October 2002.
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:51:25 UTC from IEEE Xplore.  Restrictions apply.