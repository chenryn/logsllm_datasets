## 为什么要有线程？其实，对于任何一个进程来讲，即便我们没有主动去创建线程，进程也是默认有一个主线程的。线程是负责执行二进制指令的，它会根据项目执行计划书，一行一行执行下去。进程要比线程管的宽多了，除了执行指令之外，内存、文件系统等等都要它来管。所以，**进程相当于一个项目，而线程就是为了完成项目需求，而建立的一个个开发任务**。默认情况下，你可以建一个大的任务，就是完成某某功能，然后交给一个人让它从头做到尾，这就是主线程。但是有时候，你发现任务是可以拆解的，如果相关性没有非常大前后关联关系，就可以并行执行。例如，你接到了一个开发任务，要开发 200个页面，最后组成一个网站。这时候你就可以拆分成 20 个任务，每个任务 10个页面，并行开发。都开发完了，再做一次整合，这肯定比依次开发 200个页面快多了。![](Images/aad05f6a7db260de5d11c5ae4bdbba0c.png){savepage-src="https://static001.geekbang.org/resource/image/48/9e/485ce8195d241c2a6930803286302e9e.jpg"}那我们能不能成立多个项目组实现并行开发呢？当然可以了，只不过这样做有两个比较麻烦的地方。第一个麻烦是，立项。涉及的部门比较多，总是劳师动众。你本来想的是，只要能并行执行任务就可以，不需要把会议室都搞成独立的。另一个麻烦是，项目组是独立的，会议室是独立的，很多事情就不受你控制了，例如一旦有了两个项目组，就会有沟通问题。``{=html}所以，使用进程实现并行执行的问题也有两个。第一，创建进程占用资源太多；第二，进程之间的通信需要数据在不同的内存空间传来传去，无法共享。除了希望任务能够并行执行，有的时候，你作为项目管理人员，肯定要管控风险，因此还会预留一部分人作为应急小分队，来处理紧急的事情。例如，主线程正在一行一行执行二进制命令，突然收到一个通知，要做一点小事情，应该停下主线程来做么？太耽误事情了，应该创建一个单独的线程，单独处理这些事件。另外，咱们希望自己的公司越来越有竞争力。要想实现远大的目标，我们不能把所有人力都用在接项目上，应该预留一些人力来做技术积累，比如开发一些各个项目都能用到的共享库、框架等等。在 Linux中，有时候我们希望将前台的任务和后台的任务分开。因为有些任务是需要马上返回结果的，例如你输入了一个字符，不可能五分钟再显示出来；而有些任务是可以默默执行的，例如将本机的数据同步到服务器上去，这个就没刚才那么着急。因此这样两个任务就应该在不同的线程处理，以保证互不耽误。
## 如何创建线程？看来多线程还是有很多好处的。接下来我们来看一下，如何使用线程来干一件大事。假如说，现在我们有 N个非常大的视频需要下载，一个个下载需要的时间太长了。按照刚才的思路，我们可以拆分成N 个任务，分给 N 个线程各自去下载。我们知道，进程的执行是需要项目执行计划书的，那线程是一个项目小组，这个小组也应该有自己的项目执行计划书，也就是一个函数。我们将要执行的子任务放在这个函数里面，比如上面的下载任务。这个函数参数是 void类型的指针，用于接收任何类型的参数。我们就可以将要下载的文件的文件名通过这个指针传给它。为了方便，我将代码整段都贴在这里，这样你把下面的代码放在一个文件里面就能成功编译。当然，这里我们不是真的下载这个文件，而仅仅打印日志，并生成一个一百以内的随机数，作为下载时间返回。这样，每个子任务干活的同时在喊："我正在下载，终于下载完了，用了多少时间。"    #include #include #include  #define NUM_OF_TASKS 5 void *downloadfile(void *filename){   printf("I am downloading the file %s!\n", (char *)filename);   sleep(10);   long downloadtime = rand()%100;   printf("I finish downloading the file within %d minutes!\n", downloadtime);   pthread_exit((void *)downloadtime);} int main(int argc, char *argv[]){   char files[NUM_OF_TASKS][20]={"file1.avi","file2.rmvb","file3.mp4","file4.wmv","file5.flv"};   pthread_t threads[NUM_OF_TASKS];   int rc;   int t;   int downloadtime;    pthread_attr_t thread_attr;   pthread_attr_init(&thread_attr);   pthread_attr_setdetachstate(&thread_attr,PTHREAD_CREATE_JOINABLE);    for(t=0;t#include #include  #define NUM_OF_TASKS 5 int money_of_tom = 100;int money_of_jerry = 100;// 第一次运行去掉下面这行pthread_mutex_t g_money_lock; void *transfer(void *notused){  pthread_t tid = pthread_self();  printf("Thread %u is transfering money!\n", (unsigned int)tid);  // 第一次运行去掉下面这行  pthread_mutex_lock(&g_money_lock);  sleep(rand()%10);  money_of_tom+=10;  sleep(rand()%10);  money_of_jerry-=10;  // 第一次运行去掉下面这行  pthread_mutex_unlock(&g_money_lock);  printf("Thread %u finish transfering money!\n", (unsigned int)tid);  pthread_exit((void *)0);} int main(int argc, char *argv[]){  pthread_t threads[NUM_OF_TASKS];  int rc;  int t;  // 第一次运行去掉下面这行  pthread_mutex_init(&g_money_lock, NULL);   for(t=0;t#include #include  #define NUM_OF_TASKS 3#define MAX_TASK_QUEUE 11 char tasklist[MAX_TASK_QUEUE]="ABCDEFGHIJ";int head = 0;int tail = 0; int quit = 0; pthread_mutex_t g_task_lock;pthread_cond_t g_task_cv; void *coder(void *notused){  pthread_t tid = pthread_self();   while(!quit){     pthread_mutex_lock(&g_task_lock);    while(tail == head){      if(quit){        pthread_mutex_unlock(&g_task_lock);        pthread_exit((void *)0);      }      printf("No task now! Thread %u is waiting!\n", (unsigned int)tid);      pthread_cond_wait(&g_task_cv, &g_task_lock);      printf("Have task now! Thread %u is grabing the task !\n", (unsigned int)tid);    }    char task = tasklist[head++];    pthread_mutex_unlock(&g_task_lock);    printf("Thread %u has a task %c now!\n", (unsigned int)tid, task);    sleep(5);    printf("Thread %u finish the task %c!\n", (unsigned int)tid, task);  }   pthread_exit((void *)0);} int main(int argc, char *argv[]){  pthread_t threads[NUM_OF_TASKS];  int rc;  int t;   pthread_mutex_init(&g_task_lock, NULL);  pthread_cond_init(&g_task_cv, NULL);   for(t=0;t`{=html}[[P[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.096em;"}]{#12.html#MathJax-Span-32.mistyle="font-family: MathJax_Math-italic;"}[r]{#12.html#MathJax-Span-33.mistyle="font-family: MathJax_Math-italic;"}[o]{#12.html#MathJax-Span-34.mistyle="font-family: MathJax_Math-italic;"}[g[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"}]{#12.html#MathJax-Span-35.mistyle="font-family: MathJax_Math-italic;"}[r]{#12.html#MathJax-Span-36.mistyle="font-family: MathJax_Math-italic;"}[a]{#12.html#MathJax-Span-37.mistyle="font-family: MathJax_Math-italic;"}[m]{#12.html#MathJax-Span-38.mistyle="font-family: MathJax_Math-italic;"}[m]{#12.html#MathJax-Span-39.mistyle="font-family: MathJax_Math-italic;"}[i]{#12.html#MathJax-Span-40.mistyle="font-family: MathJax_Math-italic;"}[n]{#12.html#MathJax-Span-41.mistyle="font-family: MathJax_Math-italic;"}[g[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"}]{#12.html#MathJax-Span-42.mistyle="font-family: MathJax_Math-italic;"}[w]{#12.html#MathJax-Span-43.mistyle="font-family: MathJax_Math-italic;"}[i]{#12.html#MathJax-Span-44.mistyle="font-family: MathJax_Math-italic;"}[t]{#12.html#MathJax-Span-45.mistyle="font-family: MathJax_Math-italic;"}[h]{#12.html#MathJax-Span-46.mistyle="font-family: MathJax_Math-italic;"}[P[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.096em;"}]{#12.html#MathJax-Span-47.mistyle="font-family: MathJax_Math-italic;"}[O]{#12.html#MathJax-Span-48.mistyle="font-family: MathJax_Math-italic;"}[S[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.049em;"}]{#12.html#MathJax-Span-49.mistyle="font-family: MathJax_Math-italic;"}[I[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.049em;"}]{#12.html#MathJax-Span-50.mistyle="font-family: MathJax_Math-italic;"}[X[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.049em;"}]{#12.html#MathJax-Span-51.mistyle="font-family: MathJax_Math-italic;"}[T[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.144em;"}]{#12.html#MathJax-Span-52.mistyle="font-family: MathJax_Math-italic;"}[h]{#12.html#MathJax-Span-53.mistyle="font-family: MathJax_Math-italic;"}[r]{#12.html#MathJax-Span-54.mistyle="font-family: MathJax_Math-italic;"}[e]{#12.html#MathJax-Span-55.mistyle="font-family: MathJax_Math-italic;"}[a]{#12.html#MathJax-Span-56.mistyle="font-family: MathJax_Math-italic;"}[d[]{style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"}]{#12.html#MathJax-Span-57.mistyle="font-family: MathJax_Math-italic;"}[s]{#12.html#MathJax-Span-58.mi style="font-family: MathJax_Math-italic;"}]{#12.html#MathJax-Span-31.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.461em, 1015.53em, 2.638em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 15.579em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.291em; border-left: 0px solid; width: 0px; height: 1.238em;"}]{#12.html#MathJax-Span-30.mathstyle="width: 19.485em; display: inline-block;"}``{=html}[$ProgrammingwithPOSIXThreads$]{.MJX_Assistive_MathMLrole="presentation"}]{#12.html#MathJax-Element-2-Frame .MathJaxtabindex="0" style="position: relative;"mathml="ProgrammingwithPOSIXThreads"role="presentation"}$$，你可以系统地学习一下。另外，上面的代码，建议你一定要上手编译运行一下。欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。![](Images/1a5564dd4e1c9f25d4772c7f844ca84a.png){savepage-src="https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg"}
# 12 \| 进程数据结构（上）：项目多了就需要项目管理系统前面两节，我们讲了如何使用系统调用，创建进程和线程。你是不是觉得进程和线程管理，还挺复杂的呢？如此复杂的体系，在内核里面应该如何管理呢？有的进程只有一个线程，有的进程有多个线程，它们都需要由内核分配 CPU来干活。可是 CPU总共就这么几个，应该怎么管理，怎么调度呢？你是老板，这个事儿得你来操心。首先，我们得明确，公司的项目售前售后人员，接来了这么多的项目，这是个好事儿。这些项目都通过办事大厅立了项的，有的需要整个项目组一起开发，有的是一个项目组分成多个小组并行开发。无论哪种模式，到你这个老板这里，都需要有一个项目管理体系，进行统一排期、统一管理和统一协调。这样，你才能对公司的业务了如指掌。那具体应该怎么做呢？还记得咱们平时开发的时候，用的项目管理软件 Jira吧？它的办法对我们来讲，就很有参考意义。我们这么来看，其实，无论是一个大的项目组一起完成一个大的功能（单体应用模式），还是把一个大的功能拆成小的功能并行开发（微服务模式），这些都是开发组根据客户的需求来定的，项目经理没办法决定，但是从项目经理的角度来看，这些都是任务，需要同样关注进度、协调资源等等。同样在 Linux里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构**task_struct**进行管理。这个结构非常复杂，但你也不用怕，我们慢慢来解析。``{=html}![](Images/cb450afbeeb481db7ded08f2475c919d.png){savepage-src="https://static001.geekbang.org/resource/image/75/2d/75c4d28a9d2daa4acc1107832be84e2d.jpeg"}接下来，我们沿着建立项目管理体系的思路，设想一下，**Linux的任务管理都应该干些啥？**首先，所有执行的项目应该有个项目列表吧，所以 Linux内核也应该先弄一个**链表**，将所有的 task_struct 串起来。    struct list_headtasks;接下来，我们来看每一个任务都应该包含哪些字段。
## 任务 ID每一个任务都应该有一个ID，作为这个任务的唯一标识。到时候排期啊、下发任务啊等等，都按 ID来，就不会产生歧义。task_struct 里面涉及任务 ID 的，有下面几个：    pid_t pid;pid_t tgid;struct task_struct *group_leader; 你可能觉得奇怪，既然是ID，有一个就足以做唯一标识了，这个怎么看起来这么麻烦？这是因为，上面的进程和线程到了内核这里，统一变成了任务，这就带来两个问题。第一个问题是，**任务展示**。啥是任务展示呢？这么说吧，你作为老板，想了解的肯定是，公司都接了哪些项目，每个项目多少营收。什么项目执行是不是分了小组，每个小组是啥情况，这些细节，项目经理没必要全都展示给你看。前面我们学习命令行的时候，知道 ps命令可以展示出所有的进程。但是如果你是这个命令的实现者，到了内核，按照上面的任务列表把这些命令都显示出来，把所有的线程全都平摊开来显示给用户。用户肯定觉得既复杂又困惑。复杂在于，列表这么长；困惑在于，里面出现了很多并不是自己创建的线程。第二个问题是，**给任务下发指令**。如果客户突然给项目组提个新的需求，比如说，有的客户觉得项目已经完成，可以终止；再比如说，有的客户觉得项目做到一半没必要再进行下去了，可以中止，这时候应该给谁发指令？当然应该给整个项目组，而不是某个小组。我们不能让客户看到，不同的小组口径不一致。这就好比说，中止项目的指令到达一个小组，这个小组很开心就去休息了，同一个项目组的其他小组还干的热火朝天的。Linux 也一样，前面我们学习命令行的时候，知道可以通过 kill来给进程发信号，通知进程退出。如果发给了其中一个线程，我们就不能只退出这个线程，而是应该退出整个进程。当然，有时候，我们希望只给某个线程发信号。所以在内核中，它们虽然都是任务，但是应该加以区分。其中，pid 是 processid，tgid 是 thread group ID。任何一个进程，如果只有主线程，那 pid 是自己，tgid 是自己，group_leader指向的还是自己。但是，如果一个进程创建了其他线程，那就会有所变化了。线程有自己的pid，tgid 就是进程的主线程的 pid，group_leader 指向的就是进程的主线程。好了，有了 tgid，我们就知道 tast_struct代表的是一个进程还是代表一个线程了。
## 信号处理这里既然提到了下发指令的问题，我就顺便提一下 task_struct里面关于信号处理的字段。    /* Signal handlers: */struct signal_struct*signal;struct sighand_struct*sighand;sigset_tblocked;sigset_treal_blocked;sigset_tsaved_sigmask;struct sigpendingpending;unsigned longsas_ss_sp;size_tsas_ss_size;unsigned intsas_ss_flags;这里定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。信号处理函数默认使用用户态的函数栈，当然也可以开辟新的栈专门用于信号处理，这就是sas_ss_xxx 这三个变量的作用。上面我说了下发信号的时候，需要区分进程和线程。从这里我们其实也能看出一些端倪。task_struct 里面有一个 struct sigpending pending。如果我们进入 structsignal_struct \*signal 去看的话，还有一个 struct sigpendingshared_pending。它们一个是本任务的，一个是线程组共享的。关于信号，你暂时了解到这里就够用了，后面我们会有单独的章节进行解读。