1.声明一结点p和q；
2.将第一个结点赋值给p；
3.循环：
·将下一结点赋值给g；
释放p；
将q赋值给p。
实现代码算法如下：
/*初始条件：顺序线性表L已存在，操作结果：将L重置为空表*/
Status ClearList（LinkList *L）
LinkList p,q
p-（*L）->next;
/*p指向第一个结点·/
while（p)
/没到表尾*/
q=p->next;
free（p):
rb=d
1TT0N=xaunext即可。可这样会带来什么问题？
要知道p是一个结点，它除了有数据域，还有指针域。你在做free（p）：时，其
69
---
## Page 94
大话数据结构
实是在对它整个结点进行删除和内存释放的工作。这就好比皇帝快要病死了，却还没
有册封太子，他儿子五六个，你说要是你脚一蹬倒是解脱了，这国家咋办，你那几个
儿子咋办？这要是为了皇位，什么亲兄弟血肉情都成了浮云，一定会打起来。所以不
行，皇帝不能马上死，得先把遗瞩写好，说清楚，哪个儿子做太子才行。而这个遗瞩
就是变量q的作用，它使得下一个结点是谁得到了记录，以便于等当前结点释放后，
把下一结点拿回来补充。明白了吗？
好了，说了这么多，我们可以来简单总结一下。
3.11单链表结构与顺序存储结构优缺点
简单地对单链表结构和顺序存储结构做对比：
存储分配方式
时间性能
空间性能
·顺序存储结构用一段连
查找
·顺序存储结构需要预分配
续的存储单元依次存储
·顺序存储结构0（1）
存储空间，分大了，浪费，
线性表的数据元素
·单链表0(n）
分小了易发生上溢
·单链表采用链式存储结
插入和删除
·单链表不需要分配存储空
构，用一组任意的存储
·顺序存储结构需要平均
问，只要有就可以分配，
单元存放线性表的元素
移动表长一半的元素，
元素个数也不受限制
时间为0(n）
·单链表在线出某位置的
指针后，插入和删除时
间仅为0（1）
图3-11-1
通过上面的对比，我们可以得出一些经验性的结论：
·若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结
构。若需要频繁插入和删除时，宜采用单链表结构。比如说游戏开发中，
对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读
取，所以应该考虑用顺序存储结构。而游戏中的玩家的武器或者装备列
表，随着玩家的游戏过程中，可能会随时增加或删除，此时再用顺序存储
就不太合适了，单链表结构就可以大展拳脚。当然，这只是简单的类比，
现实中的软件开发，要考虑的问题会复杂得多。
70
---
## Page 95
第3章线性表
■当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表
结构，这样可以不需要考虑存储空间的大小问题。面如果事先知道线性表
的大致长度，比如一年12个月，一周就是星期一至星期日共七天，这种用
顺序存储结构效率会高很多。
总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个
好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需
求和性能。
休息一下，我们再来看看其他的链表结构。
3.12静态链表
其实C语言真是好东西，它具有的指针能力，使得它可以非常容易地操作内存中
的地址和数据，这比其他高级语言更加灵活方便。后来的面向对象语言，如Java、C#
等，虽不使用指针，但因为启用了对象引用机制，从某种角度也间接实现了指针的某
些作用。但对于一些语言，如Basic、Fortran等早期的编程高级语言，由于没有指
针，链表结构按照前面我们的讲法，它就没法实现了。怎么办呢？
有人就想出来用数组来代替指针，来描述单链表。真是不得不佩服他们的智慧，
我们来看看他是怎么做到的。
首先我们让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每
个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我
们要处理的数据；而游标cur相当于单链表中的next指针，存放该元素的后继在数组
中的下标。
我们把这种用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实
现法。
为了我们方便插入数据，我们通常会把数组建立得大一些，以便有一些空闲空间
可以便于插入时不至于溢出。
/*线性表的静态链表存储结构*/
define MAXSIzE 1000
/*假设链表的最大长度是1000*/
typedef struct
ElenType data;
71
---
## Page 96
大语数据结构
int cur;
/*游标（Cursor），为0时表示无指向*/
另外我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。我们通常
把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为0的元素的cur
就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有
数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为0²。如
图3-12-1所示。
数组第一个元素的cur用米存
数组最后一个元素的cur用来存放第一
放备用链表第一个结点的下标
个插入元素的下标，相当于头结点
4
下标
7
999
data
图3-12-1
此时的图示相当于初始化的数组状态，见下面代码：
/*将一维数组space中各分量链成一备用链表，*/
/*space[0】.cur为头指针，“0"表示空指针·/
Status InitList(StaticLinkList space)
inti;
for（i=0;iListLength（L）+1）
6.
return ERROR;
j-Mal1oc_SSL（L）；/*获得空闲分量的下标*/
8.
if（j）
9.
10.
L[j].data=e;/*济数据赋值给此分量的data*/
11.
for（1-1：1<=1-1：1++）/*我到第1个元素之前的位置*/
12.
k=L[k].cur;
13.
L[j].cur-L[k].cur：/*把第个元素之前的cur赋值给新元素的cur*/
14.
L[k].cur-j;
/*把新元素的下标赋值给第1个元素之前元素的cur*/
15.
return OK;
16.
1
17.
return ERROR;
74
---
## Page 99
第3章线性表
18.
当我们执行插入语句时，我们的目的是要在“乙”和“丁”之间插入
“丙”。调用代码时，输入i值为3。
第4行让k=MAX_SIZE-1=999。
第7行，j=Malloc_SSL（L）=7。此时下标为0的cur也因为7要被占用而
更改备用链表的值为8。
第11~12行，for循环1由1到2，执行两次。代码k=L[k].cur使得k=999，
得到k=L[999].cur=1，再得到k=L[1].cur=2。
第13行，L.cur=L[k].cur因j=7，面k=2得到L[7].cur=L[2].cur=3。这就
是刚才我说的让“丙”把它的cur改为3的意思。
第14行，L[k].cur=i意思就是L[2].cur=7。也就是让“乙”得点好处，把
它的cur改为指向“丙”的下标7。
就这样，我们实现了在数组中，实现不移动元素，却插入了数据的操作（如图3-12-3
所示）。没理解可能觉得有些复杂，理解了，也就那么回事。
庚
内
9
下标0
23
6
8
999
图3-12-3
3.12.2静态链表的删除操作
故事没完，接着，排在第一个的甲突然接到一电话，看着很急，多半不是家里有
紧急情况，就是单位有突发状况，反正稍有犹豫之后就急匆匆离开。这意味着第一位
空出来了，那么自然刚才那个收了好处的乙就成了第一位一有人走运起来，喝水都
长肉。
和前面一样，删除元素时，原来是需要释放结点的函数free（）。现在我们也得自