f_locals
“0LOAD_CONSTO”，虚拟机的执行动作如
Python源码剖析
None
None
9.1简单内建对象的创建
None
None
深度探索动态语言核心技术
159
---
## Page 190
160
Python源码剖析
字空间，从而完成变量名1到变量值1之间映射关系的创建。
到符号所对应的对象。Python虚拟机通过执行字节码指令STORE_NAME来改变1ocal名
“1”到pyIntobject对象1的映射关系，这样如果以后我们需要使用符号1，才能寻找
但是按照正常的猜测，执行=1这个表达式应该在1ocal名字空间中创建一个从符号
注意，由于在STORE_NAME指令的执行过程中，进行了POP的动作，所以这时运行时栈中
种方式捆绑在一起的了。指令“3STORE_NAME0”完成后的虚拟机状态如图9-4所示。
指令参数是0，对照图9-1，我们发现，STORE_NAME获得的变量名确实是“”。
names（同样与consts类似，在以后的叙述中，我们有时将names称为符号表）。这里的
f->f_1ocals中。与上面看到的consts类似，这里的names实际上是f->t_code->co
NAME0”首先根据指令参数从符号表names中读取序号为0的元素作为变量名，然后将
已不存在任何对象了。
“0LOAD_CONSTO”指令读取的元素作为变量值，将（变量名，变量值）元素对添加到
情况。一般情况下，f->f_1ocals都会是一个PyDictObject对象。字节码指令“3STORE
//从运行时栈中获得值
W=GETITEM(names,
//从符号表中获得符号，其中oparg=0
[STORE_NAME]
（（x=f->f_1ocals）1=NUl)
第9章Python虚拟机中的一般表达式
第一条字节码指令LOAD_CONST只改变了运行时栈，对1ocal名字空间没有任何影响。
现在我们可以很清晰地看到Python代码中变量名与变量值在内存中是通过怎样的
在这里，我们只考虑1ocai名字空间（f->f_locals）确实是pyDictobject对象的
PY_DECREP(V）;
1将（符号，
lse
Pyobject_SetItem（x,w,v)
PyDict_SetItem(x,w.v）
深度探索动态语言核心技术
值）的映射关系存储到Iocal名字空间中
oparg);
图9-4STORE_NAME之后的虚拟机状态
---
## Page 191
情形了，如图9-6所示：
18
但是在这里，我们根本没有看到使用这个参数。可能，这又是“历史遗留”问题。
中，可以发现，BUILD_MAP是一条带有参数的字节码指令，从opcode.h中也能证实这一点，
Object对象，
PUSH(X);
load了而是凭空创建了一个pyDictobject对象：
[BUILD MAP]
动态变化过程：
行代码是一样的，只是操作的参数不同了：
669
对于sinple_objpy中最后一行Python代码，居然编译出了4条字节码指令：
接下来的是STORE_NAME指令，看到这条指令，实际上我们就可以看到执行完毕后的
细心的读者一定发现了，这里有一件很奇怪的事：从Pyhon源代码编译出的字节码
对于指令“12BUILD_MAPo”，Python虚拟机在执行指令时会创建一个空的ryDict-
="Python"
IST CIE
在simple_obj.py的第3行，我们见到了一点新鲜的东西，在这里，我们并不是简单地
PyDict
图9-5展示了这段字节码序列执行时Python虚拟机的运行时栈和1ocal名字空间的
STORE_NAME
simple_obj.py中第1行代码执行完毕，
STORENAME
BUILDMAP
LOAD
"Python"
CONST
New():
，并把这个对象压入到运行时栈中：
BUILD_MAPO
LOAD CONSTI
0
图9-5
2(a)
0
图9-6d=0执行过程中虚拟机状态的转变
(s)
(Python)
S=“python”执行过程中虚拟机状态的转变
第2行代码所产生的字节码序列实际上跟第1
Python源码剖析
9.1简单内建对象的创建
一深度探索动态语言核心技术
STORE NAME2
STORE_NAME1
"d”
3"
161
---
## Page 192
Python源码剖析
162
RETURN_VALUE使用。可以看到，压入栈中的返回值是一个NoneObject，实际上什么有价
所有工作都完成了，那最后两条字节码指令的作用呢？
PyListobject对象中，因为这些对象其实就是1ist中的元素。这一点我们后面会详细考
令之前一定会有许多LOAD_CONST的操作，这将导致有许多对象被压入运行时栈中，在真
而不是像BUILD_MAP那样，仅仅做个摆设：
但是，BUILD工IST更好，它善待了字节码指令所带的指令参数，真正利用了这个参数，
所有有用的信息都已经到了local名字空间的掌握之中，如图9-7所示：
值的东西也没有返回，但这个过场还是要走的，不走，人民是不答应的。
节码指令“24LOAD_CONST2”的作用就很清楚了，它将返回值压入运行时栈中，以供
是用来返回某些值的：
正执行BUILD_LIST指令时，会将这些对象一一从栈中弹出元素，加入到新创建的
[BUILD_LIST]
22
why= WHY_RETURN;
retval
[RETURN VALUE]
第9章Python虚拟机中的一般表达式
在Python虚拟机执行simple_obj.py中的所有字节码指令的瞬间，运行时变空了
可以推测，如果Pyhon源代码中创建的不是一个空的1ist，那么在BUILDLIST指
对于指令“18BUILD_LISTO”我们猜想它所执行的操作会与BUILD_MAP指令类似，
实际的返回值在retval中，是从运行时栈中取得的，所以RETURN_VALUE前的那条字
原来Python在执行了一段CodeBlock后，一定要返回一些值，这两条字节码指令就
PUSH(X:
for（-oparg>=0:)
RETURN VALUE
PyList
STORE_NAME
Pybist_SET_ITEM(x,oparg.W）:
WE
深度探索动态语言核心技术
POP()
POPUY:
（1）
---
## Page 193
9.2
们不再考察。而在创建非空的aict时，字节码序列与simple_objpy中的不同了：
我们通过adv_obj.py来研究：
如果是创建非空的aict和1ist，Pyhon的运行时行为又是如何的呢？这个问题很有趣，
[adv_obj.py]
TT=
复杂内建对象的创建
对于adv_obj.py，在Python虚拟机运行期间，它所对应的符号表names（co_names）
前面我们看了Python是如何在运行时创建空的dict对象和空的1iat对象的，那么
在编译得到的字节码指令序列中，前两行Pyhon代码的字节码序列都是相同的，我
"Python"
二
STORE SUBSCR
DUP_TOP
BUILD_MAP
LOAD_CONST
ROT_TWO
2:20
2:2}
2
cconsts
0(1）
图9-8adv_obj.pyc中的符号表和常量表
图9-7Python虚拟机结束时的状态
Python源码剖析
9.2
value
s
复杂内建对象的创建
深度探索动态语言核心技术
163
---
## Page 194
164
Python源码剖析
TWO指令完成后的情形如图9-10所示。
成后的情形如图9-9所示：
象中的第一个元素对的值（）读取出来，压入运行时栈中，前3条字节码指令完
令，所以会将创建的pyDictObject对象的引用计数增加1，并再次压入该PyDictObject
我们就能看到这个动作的用意。由于在DUP_TOP指令之前是一条“12BUILD_MAP0”指
次压入栈中。如此看上去，DUP似乎是duplicate的缩写。这一动作非常诡异，不过马上
PUSH(V):
却是一条全新的指令。对于这条指令，Python虚拟机会进行如下的动作：
对象。
PY-
[aoL ana]
2
SET-SECOND(v)
#define SET_SEcOND(v)
#define
#define ToP()
[ceval.c]
[ROT_TWO]
10
58
第9章
三
需要注意的是，DUP_TOP指令不只是增加了栈顶元素的引用计数，还将栈顶元素又
INGREF(V):
仔细观察后我们发现，其实ROT_TWO所做的就是将栈顶的两个元素进行对调。ROT
其中的 SET_TOP等宏也是在PyEval_EvaIFrameEx中定义的：
Pyhon虚拟机在接下来对指令“19ROT_Two”的执行过程中，会做一些奇怪的动作：
SECOND(）:
STORE_NAME
STORE_
LOAD_CONST
ROTTWO
DUP_TOP
SET_TOP(V)
SECOND()
Python虚拟机中的一般表达式
一深度探索动态语言核心技术
SUBSCR
2(ay
4129
E
(stack_pointer[-1])
图9-9
---
## Page 195
CONST、ROT_TWO、LOAD_CONST、STORE_SUBSCR）4个字节码为一组，每组的目的是重复
运行时栈里又只剩下了最初由BUILD_MAP创建的PyDictObject对象。到这里，Python
指令会将（键，值）对插入到PyDictobjeot对象中去：
对象中的第一个元素对的键（）读取出来。而紧随的“23STORE_SUBSCR
有的字节码指令执行完成之后，情形如图9-11所示：
PyDictobject对象添加到1ocal名字空间中去，并为其关联一个名为“a”的符号。当所
元素对的插入动作都完成之后，将由我们的老朋友“33STORE_NAME2”指令最终把这个
上面我们所看到的动作，不断地将后续元素对插入到pyDictobject对象中去。当所有的
虚拟机就完成了将一个元素对插入到pyDictobject的操作。剩下的字节码序列以（LOAD
PyListObject对象：
PY_DECREF（W）:
STACKADJ(-30;
[STORE_SUBSCR]
Pyobieot
/v[w]=u,
2
=01，21
DECREE(V):
11
随着STACKADU的执行，栈顶指针回退了3格，所以STORE_SUBSCR指令执行完后，
TOPO):
随后的一条“20LOAD_cONST2”指令会从consts中将需要插入到PyDictObject
在成功创建了非空PyDictObject对象之后，Python虚拟机还会创建一个非空的
THIRD（）
SECOND():
STORE_NAME
BUILD LIST
LOAD_CONST
LOADICONST
即dict[1]=1
图9-11创建PyDictObject对象之后的虚拟机状态
diat object
3（1)
LO
e
图9-10ROT_TWO之后虚拟机的状态
>
>
1
Python源码剖析
9.2
>
复杂内建对象的创建
一深度探索动态语言核心技术
165
---
## Page 196
Python源码剖析
9.3.1
9.3其他一般表达式
166第9章Python虚拟机中的一般表达式
0”，我们还是第一次遇到（见代码清单9-1）。
量之间的赋值运算：
co_consts和co_names如图9-12所示：
作，完成对一般Pyhon语句的剖析工作：