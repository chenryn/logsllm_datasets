on the set of values s. The k-means clustering algorithm
divides the points in s into k (k (cid:28) |V|) clusters such that
the sum of squares J from points to the assigned cluster
centers is minimized.
J =
|V|
∑
i=1
(cid:107)si − c j(cid:107)2,
(4)
k
∑
j=1
where c j is the center of cluster j. The within-cluster sum
of squares for each cluster constitutes the cluster score.
The parameter k is chosen using the method of Pelleg
and Moore [56]. Starting from a user speciﬁed minimum
number of clusters k = kmin we repeatedly compute k-
means over our dataset by incrementing k up to a max-
imum of kmax. We then select the best-scoring k value.
kmin and kmax correspond to the minimum and maximum
number of possible botnets within the dataset. In our ex-
periments, we used kmin = 0 and kmax = 20.
Each of the k clusters corresponds to a set of nodes
in VG, so we may partition our graph into subgraphs
{G1,G2, . . . ,Gk}. We must now conﬁrm or reject the hy-
pothesis that each of these subgraphs contains a struc-
tured P2P graph. Clustering helps speed up the super-
linear components of the following algorithm; we may
also be able to focus our attention on a particular sub-
set of clusters if misuse detection is concentrated within
them.
Note that we can use the sparse nature of the ma-
trix P to compute qt using Equation 2 very efﬁciently
in O(|E| · t) time. The time and space complexity of
Equation 3 is O(|V|), while Equation 4 can be computed
in O(k · |V|) iterations. Thus the preﬁltering step is a
very efﬁcient mechanism to obtain a set of candidate P2P
nodes, capable of operating on large node graphs.
3.3 Clustering P2P Nodes
The subgraphs computed by the above step are likely
to contain P2P nodes, but they are also likely to con-
tain some non-P2P nodes due to the “leakage” of random
walks out of the structured subgraph. We perform a sec-
ond pass over the each subgraph Gl ∈ G1,G2, . . . ,Gk to
remove weakly connected nodes.
We cluster P2P nodes by using the SybilInfer [21]
framework. SybilInfer is a technique to detect Sybil
identities in a social network graph; a key feature of
SybilInfer is a sampling strategy to identify a good parti-
tion out of an extremely large space of possibilities (2V ).
However, the detection algorithm used in SybilInfer re-
lies on the existence of a small cut between the honest
social network and the Sybil subgraph, and is thus not
directly applicable to our setting. Next, we present a
modiﬁed SybilInfer algorithm that is able to detect P2P
nodes.
1. Generation of Traces : The ﬁrst step of the clus-
tering is the the generation of a set of random walks on
the input graph. The walks are generated by perform-
ing a number n of random walks, starting at each node in
the graph. A special probability transition matrix is used,
deﬁned as follows:
(cid:40)min( 1
di
0
P(cid:48)
i j =
, 1
d j
)
if i → j is an edge in G
otherwise
(5)
This choice of transition probabilities ensures that the
stationary distribution of the random walk is uniform
over all vertices. The length of the random walk is
O(log|V|), while the number of random walks per node
4
(denoted by n), is a tunable parameter of the system.
Only the start vertex and end vertex of each random walk
are used by the algorithm, and this set of vertex pairs is
called the traces, denoted by T .
2. A probabilistic model for P2P nodes: At the heart
of our detection algorithm lies a model that assigns a
probability to each subset of nodes of being P2P nodes.
Consider any cut X ⊆ V of nodes in the graph. We wish
to compute the probability that the set of nodes X are all
P2P nodes, given our set of traces T, i.e. P(X = P2P|T ).
Through the application of Bayes theorem, we have an
expression of this probability:
P(X = P2P|T ) =
P(T|X = P2P)· P(X = P2P)
Z = P(T )
(6)
Note that we can treat P(T ) as a normalization con-
stant Z, as it does not change with the choice of X. The
prior probability P(X = P2P) can be used to encode any
further knowledge about P2P nodes (using honeynets), or
can simply be set uniformly over all possible cuts. Our
key theoretical task here is the computation of the proba-
bility P(T|X = P2P), since given this probability, we can
compute P(X = P2P|T ) using the Bayes theorem.
Our intuition in proposing a model for P(T|X = P2P)
is that for short random walks, the state probability mass
for peer-to-peer nodes quickly approaches the station-
ary distribution. Recall that the stationary distribution of
our special random walks is uniform, and thus, the state
probability mass for peer-to-peer nodes should be homo-
geneous. We can classify the random walks in the trace T
into two categories: random walks that end in the set X,
and random walks that end in the set X (complementary
set of nodes).
Using our intuition that for short random walks, the
state probability mass associated with peer-to-peer nodes
is homogeneous, we assign a uniform probability to all
walks ending in the set X. On the other hand, we make
no assumptions about random walks ending in the set X
(in contrast to the original SybilInfer algorithm). Thus,
P(T|X = P2P) = Πw∈T P(w|X = P2P),
(7)
where w denotes a random walk in the trace. Now if the
walk w ends in vertex a in X, then we have that
P(w|X = P2P) = ∑
v∈X
Nv
n·|V| · 1
|X| ,
(8)
where Nv denotes the number of random walks ending in
vertex v. Observe that this probability is the same for all
vertices in X. On the other hand, if the walk w ends in
vertex a in X, then we have that
P(w|X = P2P) =
(9)
Na
n·|V| .
3. Metropolis-Hastings Sampling: Using the proba-
bilistic model for P2P nodes, we have been able to com-
pute the the probability P(X = P2P|T ) up to a multi-
plicative constant Z. However, computing Z is difﬁcult
since it involves enumeration over all subsets X of the
graph. Thus, instead of directly calculating this prob-
ability for any conﬁguration of nodes X, we will sam-
ple conﬁgurations Xi following this distribution. We use
the Metropolis-Hastings algorithm [34] to compute a set
of samples Xi ∼ P(X|T ). Given a set of samples S, we
can compute marginal probabilities of nodes being P2P
nodes as follows:
|S|
P[i is P2P] =
(10)
where I(i ∈ Xj) is an indicator random variable taking
value 1 if node i is in the P2P sample Xj, and value 0 oth-
erwise. Finally, we can use a threshold on the marginal
probabilities (set to 0.5) to partition the set of nodes into
fast-mixing and slow-mixing components.
∑ j∈S I(i ∈ Xj)
,
3.4 Validation
We note that a general graph may be composed of mul-
tiple subgraphs having different mixing characteristics.
However, our modiﬁed SybilInfer based clustering ap-
proach only partitions the graph into two subgraphs. This
means we may have to use multiple iterations of the mod-
iﬁed SybilInfer based clustering algorithm to get to the
desired fastest mixing subgraph. This raises an impor-
tant question - what is the termination condition for the
iteration.
In other words, we need a validation test to
establish that we have obtained the fast-mixing P2P sub-
graph that we were trying to detect. Next, we propose
a set of validation tests: if all of the tests are true, the
iteration is terminated.
• Graph Conductance test: It has been shown [62]
that the presence of a small cut in a graph results
in a slow mixing time and that a fast-mixing time
implies the absence of small cuts. To formalize the
notion of a small cut, we use the measure of graph
conductance (Φx) [43] between cuts (X, X), deﬁned
as
ΦX =
Σx∈XΣy /∈Xπ(x)Pxy
π(X)
Since peer-to-peer networks are fast mixing, their
graph conductance should be high (they do not have
a small cut). Thus we can prevent further parti-
tioning of a fast-mixing subgraph by testing that the
graph conductance between the cuts is high.
• q(t) entropy comparison test: Random walks on
structured homogeneous P2P graphs are character-
ized by high entropy state probability distributions.
5
This means that on a graph with n nodes, a random
walk of length t (cid:117) log|n| results in q(t)
i = 1/n. In
this sense they are theoretically optimal. We com-
pute the relative entropy of the state probability dis-
tribution in graph G(V,E) versus its theoretical op-
timal equivalent graph GT . For this we use the
Kullback-Leibler (KL) divergence measure [45] to
calculate the relative entropy between qG and qGT :
FG = ∑x qGT (x)log qGT (x)
qG(x) When FG is close to zero
then the mixing rates of G and GT are compara-
ble. This step can be computed in O(|V|) time and
O(|V|) space.
• Degree-homogeneity test: The entropy comparison
test above does not rule out fast-mixing heteroge-
neous graphs such as a star topology. However since
structured P2P graphs have relatively homogeneous
degree distributions (by deﬁnition), we need an ad-
ditional test to measure the dispersion of degree val-
ues. In our study, we measured the coefﬁcient of
variation of the degree distribution of G, deﬁned as
the ratio of standard deviation and mean: cG = σ/µ.
cG will be 0 for a fully homogeneous degree dis-
tribution. This metric can also be computed within
O(|V|) time and space.
4 Privacy Preserving Graph Algorithms
In general, ISPs treat the monitoring data they collect
from their own networks as conﬁdential, since it can re-
veal proprietary information about the network conﬁg-
uration, performance, and business relationships. Thus,
they may be reluctant to share the pieces of the commu-
nication graph they collect with other ISPs, presenting a
barrier to deploying our algorithms. In this section, we
present privacy-preserving algorithms for performing the
computations necessary for our botnet detection. Funda-
mentally, these algorithms support the task of performing
a random walk across a distributed graph.
4.1 Establishing a Common Identiﬁer
Space
Our algorithms are expressed in terms of a graph G =
(V,E), where the vertices are Internet hosts and edges
such that G =Sm
are connections between them. This graph is assembled
from m subgraphs belonging to m ASes, Gi = (Vi,Ei)
i=1 Gi. To simplify computations, we
would like to generate an index mapping I : Z|V| → V .
We base our approach on private set intersection pro-
tocols. In particular, Jarecki and Liu have shown how
to use Oblivious Pseudo-Random Functions (OPRFS)
to perform private set intersection in linear time, i.e.,
O(|Vi| +|Vj|). [37]. The basic approach consists of hav-
ing a server pick a PRF fk(x), with a secret k. The
server then evaluates S = { fk(si)} for all points within
the server’s set and sends it to the client. The client then,
together with the server, evaluates the PRF obliviously
on all ci for its own set; i.e, the client learns C = { fk(ci)}
without learning k, whereas the server learns nothing ex-
cept |C|. The client can then compute C∪ S and thus ﬁnd
the intersection.
We extend this approach to our problem as follows: we
pick one AS to act as the server, and the rest as clients.
Each client uses OPRF to compute fk(Vi). The server
then generates an ordered list of fk(V1) and sends it to the
second AS. The second AS ﬁnds fk(V1)∩ fk(V2) and thus
identiﬁes the positions of its nodes in the vector. It then
appends fk(V2) fk(V1) to the list and sends the resulting
list fk(V1 ∪ V2) to the next AS. This process continues
until the last AS is reached, who then reports |V| to all of
the others. Each AS can then compute I for any node v
in its subgraph by ﬁnding the corresponding position of
fk(v) in the list it saw.
Next, the ASes needs to eliminate duplicate edges. A
similar algorithm can be used here, with each ISP drop-
ping from its observations any edge that was also ob-
served by another ISP that comes earlier in the list. Al-
ternatively, routing information can be used to determine
which edges might be observed by which other AS and
perform a pairwise set intersection including only those
nodes.
Finally, to perform random walk, each AS needs to
learn the degree of each node. Since we eliminated du-
plicated edges, d(v) = ∑m
i=1 di(v), where di(v) is the de-
gree of node v in Gi. The sum can be computed by a
standard privacy-preserving protocol, which is an exten-
sion of Chaum’s dining cryptographer’s protocol [13].
j ∈ Zl such that
Each AS i creates m random shares s(i)
j ≡ di(v) mod l (where l is chosen such that l >
j=1 s(i)
∑m
maxv d(v)). Each share s(i)
is sent to AS j. After all
j
shares have been distributed, each AS computes si =
j=1 s( j)
∑m
i mod l and broadcasts it to all the other ASes.
Then d(v) = ∑m
i=1 si mod l. This protocol is information-
theoretically secure: any set of malicious ASes S only
learns the value d(v)− ∑ j∈S di(v). The protocol can be
executed in parallel for all nodes v to learn all node de-
grees.
4.2 Random Walk
We perform a random walk by using matrix operations.
In particular, given a transition matrix T and an initial
state vector(cid:126)v, we can compute T(cid:126)v, the state vector after a
single random walk step. Our basic approach is to create
matrices Ti such that ∑m
i=1 Ti = T . We can then compute
6
Ti(cid:126)v in a distributed fashion and compute the ﬁnal sum at
the end.
To construct Ti, an AS will set the value (Ti) j,k to be
1/d(v j) for each edge ( j,k) ∈ Ei (after duplicate edges
have been removed). Note that this transition matrix is
sparse; it can be represented by N linked lists of non-
zero values (Ti) j,k. Thus, the storage cost is O(|Ei|) (cid:28)
O(|Vi|2).
To protect privacy, we use Paillier encryption [55] to
perform computation on an encrypted vector E((cid:126)v). Pail-
lier encryption supports a homomorphism that allows
one to compute E(x) ⊕ E(y) = E(x + y); it also allows
the multiplication by a constant: c⊗E(x) = E(cx). This,
given an encrypted vector E((cid:126)v) and a known matrix Ti, it
is possible to compute E(Ti(cid:126)v).