thus much of legacy and even new software still relies on version
3.*. The use of HttpClient is often hidden inside Web-services mid-
dleware such as Axis 2 and XFire, which—several years after ver-
sion 4.* became available—still ship with HttpClient 3.* and thus
skip hostname veriﬁcation for SSL certiﬁcates.
It is worth noting that the custom hostname veriﬁcation code
added to HttpClient 4.* is incorrect and will reject valid certiﬁcates.
The following code is from HttpClient 4.2.1:
/ / The CN b e t t e r h a v e a t
l e a s t
tw o d o t s
i f
i t w a n t s
w i l d c a r d
[ ∗ . o r g . uk ] ,
I t a l s o can ’ t be [ ∗ . co . uk ] o r
/ / a c t i o n .
/ /
String parts[] = cn.split("\\.");
boolean doWildcard = parts.length >= 3 &&
e t c . . .
[ ∗ . co . j p ] o r
parts[0].endsWith("*") &&
acceptableCountryWildcard(cn) &&
!isIPAddress(host);
if(doWildcard) {
if (parts[0].length() > 1) { / /
e . g .
s e r v e r ∗
String prefix = parts[0].substring(0, parts.length
-2); / /
e . g .
s e r v e r
String suffix = cn.substring(parts[0].length());
/ /
s k i p w i l d c a r d p a r t
f r o m cn
String hostSuffix = hostName.substring(prefix.length
()); / /
s k i p w i l d c a r d p a r t
f r o m h o s t
match = hostName.startsWith(prefix) && hostSuffix.
endsWith(suffix);
} else {
match = hostName.endsWith(cn.substring(1));
}
if(match && strictWithSubDomains) {
I f we ’ r e i n s t r i c t mode ,
/ /
/ / a l l o w e d t o match [ a . b . f o o . com ]
match = countDots(hostName) == countDots(cn);
}
t h e n [ ∗ . f o o . com ]
i s n o t
} else {
match = hostName.equals(cn);
}
example, it will reject mail...com if the name in the
certiﬁcate is m*...com.
Furthermore, the original patch, as well as its derivatives, has
a minor bug in the regular expression for parsing IPv4 addresses,
causing it to accept IP addresses starting with zero (this does not
immediately result in a security vulnerability):
private static final Pattern IPV4_PATTERN =
Pattern.compile("^(25[0-5]|2[0-4]\\d|[0-1]?\\d
?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d))
{3}\$");
7.6 Trillian
Trillian, a popular instant messenger client, relies on OpenSSL
for SSL connection establishment. By default, OpenSSL does not
throw a run-time exception if the certiﬁcate is self-signed or has an
invalid chain of trust. Instead, it sets ﬂags. Furthermore, OpenSSL
does not provide any hostname veriﬁcation.
If the application has called SSL_CTX_set to set the SSL_VERIFY
_PEER ﬂag (see Section 4.1), then SSL_connect exits and prints an
error message when certiﬁcate validation fails. Trillian does not set
the SSL_VERIFY_PEER ﬂag. When this ﬂag is not set, SSL_connect
returns 1. The application is then expected to check the status of
certiﬁcate validation by calling SSL_get_verify_result. Trillian
does not call this function.
Trillian thus accepts any SSL certiﬁcate and is insecure against a
man-in-the-middle attack. Depending on the speciﬁc module cho-
sen by the Trillian user, this reveals usernames, passwords, secu-
rity tokens, etc. for Google Talk (typically compromising all of the
user’s Google services), AIM, ICQ, Windows Live (including Sky-
Drive), and Yahoo! Messenger (and thus all Yahoo! services).
Interestingly, it was reported back in 2009 that older versions of
Trillian do not correctly validate MSN certiﬁcates [20]. This bug
was ostensibly ﬁxed in Trillian 4.2. Our analysis shows, however,
that SSL certiﬁcate validation is still completely broken for all ser-
vices, not just for MSN (Windows Live), in Trillian 5.1.0.19.
7.7 Rackspace
The Rackspace app for iOS (version 2.1.5) is an open-source
application for administering Rackspace cloud services. It uses the
OpenStack iOS cloud client framework, which in turn relies on the
ASIHTTPRequest library to set up HTTPS connections.
ASIHTTPRequest provides a conﬁguration variable Validates
SecureCertificate, set to 1 by default.
If reset to 0, it turns
off both chain-of-trust and hostname veriﬁcation. OpenStack sup-
ports multiple accounts on remote servers and lets users customize
SSL certiﬁcate validation on per-account basis using the ignoreSSL
Validation variable. The value of this variable depends on the GUI
switch validateSSLSwitch, which should be shown to the user.
The Rackspace app (version 2.1.5) does not present the user with
this option.9 The GUI switch validateSSLSwitch is thus never dis-
played or explicitly assigned. Instead, it is simply initialized to 0 by
the Objective-C allocator. This turns on ignoreSSLValidation in
ASIHTTPRequest, which in turn sets ValidatesSecureCertificate
to 0 and disables certiﬁcate validation.
As a consequence, SSL connections established by the Rackspace
app on iOS are insecure against a man-in-the-middle attack.
7.8 TextSecure
This code computes the length of the preﬁx by subtracting 2
from the number of parts (determined by the number of dots in the
name). This logic is incorrect: validity of the ﬁrst part of a domain
name should have nothing to do with the total number of parts. For
TextSecure is an Android application for encrypting SMS and
It was written by Moxie Marlinspike who had
MMS messages.
9We are informed by Mike Mayo that this was an accidental over-
sight and will be ﬁxed in subsequent releases of the app.
45previously discovered several SSL certiﬁcate validation vulnerabil-
ities [11, 12]. This following code can be found in the application
(however, it does not appear to be reachable from the user interface
and may not currently lead to an exploitable vulnerability):
schemeRegistry.register(new Scheme("http",
PlainSocketFactory.getSocketFactory(), 80));
schemeRegistry.register(new Scheme("https",
SSLSocketFactory.getSocketFactory(), 443));
...
HttpHost target = new HttpHost(hostUrl.getHost(),
hostUrl.getPort(), HttpHost.DEFAULT_SCHEME_NAME);
...
HttpResponse response = client.execute(target, request);
Even if the port number is 443, DEFAULT_SCHEME_NAME is “http”
and the connection is over HTTP, not HTTPS.
8. USING INSECURE MIDDLEWARE
As explained in Section 5, software based on Web services usu-
ally relies on middleware libraries to manage network connections.
SSL functionality inside these libraries is opaque to the applica-
tions. If the middleware employs a broken HTTPS implementation
that does not correctly validate SSL certiﬁcates, all applications
based on it typically “inherit” the vulnerability.
8.1 Apache Axis, Axis 2, Codehaus XFire
Apache Axis is an open-source Java implementation of SOAP.
The latest release is 1.4, discontinued in 2007 in favor of Axis 2,
but the library is still used, for example, in PayPal’s Java SDKs.
Apache Axis 2 is a complete redesign of Apache Axis. The lat-
est release is 1.6.2. Codehaus XFire is another open-source Java
implementation of SOAP. It was discontinued in 2007 in favor of
Apache CXF, but is still used, for example, in Amazon’s EC2 Java
SDK. The latest release of XFire is 1.2.6.
Apache Axis uses its own version of HttpClient, while Axis 2
and XFire use Apache HttpClient version 3.1. Both versions of
HttpClient rely on SSLSocketFactory for SSL connection estab-
lishment but mistakenly omit hostname veriﬁcation (Section 4.2).
SSL vulnerabilities caused by bugs in Web-services middleware
are pervasive in Amazon libraries. Affected software includes Ama-
zon EC2 API Tools Java library, which uses XFire to set up SSL
connections to EC2 servers, and Amazon Flexible Payments Ser-
vice (Java) merchant SDK, which relies on an old Apache Http-
Client. The latter library is used by merchants to transmit cus-
tomers’ payment details to the FPS gateway. The PHP version of
the library is broken, too, but in a very different way (Section 7.1).
In contrast to the PHP version, however, the Java utility for verify-
ing instant payment notiﬁcations uses JSSE’s HttpsClient instead
of Apache HttpClient and thus checks SSL certiﬁcates correctly.
Other software that relies on Axis includes Java SOAP SDKs
for PayPal Payments Pro (Direct Payment), PayPal Transac-
tional Information, and PayPal Mass Pay, as well as Apache
ActiveMQ implementation of JMS (Java Message Service).
8.2 Pusher
Pusher is a WebSocket-based API that provides real-time mes-
saging functionality to mobile and Web applications. Pusher’s An-
droid libraries10 are based on Weberknecht (see Section 4.2). Any
application using these libraries (e.g., GitHub’s Gaug.es) is thus
insecure. It is also worth noting that Gaug.es is using an updated
version of Weberknecht, which, in addition to incorrectly using raw
SSLSocketFactory (see Section 4.1), disables the trust manager.
10https://github.com/EmoryM/Android_Pusher
In summary, any software using any of the above Web-services
frameworks is insecure against a man-in-the-middle attack.
Apache CXF. Apache CXF is a continuation of XFire. It supports
SOAP, along with REST and CORBA; the latest release is 2.6.1.
It does not rely on Apache HttpClient. Instead, SSL connections
are established using OpenJDK’s HttpsClient. Therefore, prop-
erly conﬁgured instances of CXF do verify hostnames.
Apache CXF provides an application-controlled option to turn
off certiﬁcate validation. Certiﬁcate validation is enabled by de-
fault, but was disabled in the sample wsdl_first_https code sup-
plied with CXF until we notiﬁed the developers.
9. USING INSECURE SSL LIBRARIES
As described in Section 4.2, PHP’s fsockopen does not validate
SSL certiﬁcates. Nevertheless, it is often used even by applications
that must be secure against a man-in-the-middle attack. For exam-
ple, PayPal’s IPN utility contains this code:
/ / p o s t b a c k t o P ayP al u t i l i t y
...
$fp = fsockopen (’ssl://www.paypal.com’, 443, $errno,
t o v a l i d a t e
$errstr, 30);
This code is replicated in PayPal payment modules for ZenCart
and PrestaShop shopping carts. PrestaShop uses fsockopen in its
CanadaPost payment module, too. Other similarly vulnerable soft-
ware includes Open Source Classiﬁeds,
Python’s URL libraries do not validate certiﬁcates (Section 4.2),
yet developers still use them for SSL connections. Examples in-
clude Tweepy, a library for accessing Twitter API that uses httplib,
and Mozilla’s Zamboni project, which accepts contributions for
extension developers and uses urllib2 to connect to PayPal.
10. BREAKING OR DISABLING
CERTIFICATE VALIDATION
In general, disabling proper certiﬁcate validation appears to be
the developers’ preferred solution to any problem with SSL libraries.
Here are a few typical quotes from developers’ forums:
• “I want my client to accept any certiﬁcate (because I’m only
ever pointing to one server) but I keep getting a javax.net.
ssl.SSLException: Not trusted server certificate ex-
ception”11—[note the fallacious reasoning!]
• “Tutorial: Disabling Certiﬁcate Validation in an HTTPS Con-
nection. . . Reply: Thank you very much. You solved my
biggest problem in the project.” 12
• “I have always turned off CURLOPT_SSL_VERIFYPEER
in curl.”13
• “I am using axis on java to consume a webservice. The web
service is in https, and I want to avoid the the check for cer-
tiﬁcate.”14
11http://stackoverflow.com/questions/2642777/
trusting-all-certificates-using-httpclient-
over-https
12http://www.exampledepot.com/egs/javax.net.
ssl/trustall.html
13http://stackoverflow.com/questions/
10102225/curl-ssl-certificates
14http://stackoverflow.com/questions/9079298/
axis-fake-certificate
46• “However, by default, SSL support in NSStream is a little
paranoid.
It won’t, for example, use a self-signed certiﬁ-
cate or an expired certiﬁcate to establish a secure connec-
tion. NSStream does a number of validity checks when es-
tablishing the secure connection, and if they don’t all pass,
the streams appear to be valid, but no data gets sent or re-
ceived. This is somewhat frustrating, and it could be there’s
a way to ﬁnd out when the secure connection failed, but I
haven’t been able to ﬁnd it in the documentation, or using
Google. There is an error domain declared for these errors
(NSStreamSocketSSLErrorDomain), but in my experimenta-
tion, no errors gets generated, the streams even accept bytes
for transfer, but nothing happens.” 15
Unfortunately, these bad development practices ﬁnd their way
even into critical software responsible for transmitting ﬁnancial in-
formation and sensitive data, where security against man-in-the-
middle attacks is absolutely essential and SSL certiﬁcate valida-
tion should be mandatory. For example, a comment in the Autho-
rize.Net eCheck module of ZenCart says that certiﬁcate validation
is disabled for “compatibility for SSL communications on some
Windows servers (IIS 5.0+)”—note the fallacious reasoning!
10.1 Chase mobile banking
Chase is a major US bank. SSL connections established by its
mobile banking application on Android are insecure against a man-
in-the-middle attack. This allows a network attacker to capture cre-
dentials, such as username and password, of any Chase customer
using this app, along with the rest of their session.
Decompilation and analysis of this app’s code show that it over-
rides the default X509TrustManager. The replacement code simply
returns without checking the server’s certiﬁcate. The code below
is the result of reverse-engineering, thus variable names and other
details may differ from the actual code:
public final void checkServerTrusted(X509Certificate[]
paramArrayOfX509Certificate, String paramString)
{
if ((paramArrayOfX509Certificate != null) && (
paramArrayOfX509Certificate.length == 1))
paramArrayOfX509Certificate[0].checkValidity();
while (true)
{
return;
this.a.checkServerTrusted(
paramArrayOfX509Certificate, paramString);
}
}
Note the unreachable invocation of checkServerTrusted. We
conjecture that this was a temporary plug during development that
somehow found its way into the production version of the app.
10.2 Apache Libcloud
Apache Libcloud16 is a Python library extension providing sup-
port for 26 different cloud service providers. Libcloud relies on
the underlying Python library to verify the chain of trust in SSL
certiﬁcates; internally, Python uses OpenSSL. Once the chain of
trust is veriﬁed, Libcloud veriﬁes the hostname using the _verify
_hostname method in httplib_ssl.py. This code uses an in-
correct regular expression for hostname veriﬁcation. For example,
it accepts oogle.com as a match for google.com, exposing all
Libcloud clients to a man-in-the-middle attack:
def _verify_hostname(self, hostname, cert):
# V e r i f y h o s t n a m e a g a i n s t p e e r
c e r t
# C heck b o t h commonName and e n t r i e s
# u s i n g a r u d i m e n t a r y g l o b t o d n s
# t o f i n d m a t c h e s
i n s u b j e c t A l t N a m e ,