ringsâ€”is very natural using the generic pair type (,): whenever types a and b respectively
represent rings ğ´ and ğµ, the pair type (a,b) represents the product ring ğ´ Ã— ğµ. This just
requires deï¬ning the obvious instances of Additive and Ring for (a,b)â€”which in fact
has already been done for us by the numeric prelude. Products of more than two rings are
immediately supported by nesting pairs, e.g., ((a,b),c), or by using higher-arity tuples
like (a,b,c). A ï¬nal nice feature is that a pair (or tuple) has ï¬xed representation size if
45
all its components do, so arrays of pairs can be stored directly in â€œunboxedâ€ form, without
requiring any layer of indirection.
3.2.2
Reduce and Lift
Two basic, widely used operations are reducing a Z-element to its residue class in Zğ‘,
and lifting a Zğ‘-element to its smallest integer representative, i.e., in Z âˆ© [âˆ’ ğ‘
2). These
operations are examples of the natural homomorphism, and canonical representative map,
2, ğ‘
for arbitrary quotient groups. Therefore, we deï¬ne class (Additive a, Additive b)
=> Reduce a b to represent that b is a quotient group of a, and class Reduce a b =>
Lift b a for computing canonical representatives.4 These classes respectively introduce
the functions
reduce :: Reduce a b => a -> b
lift
:: Lift
b a => b -> a
where reduce âˆ˜ lift should be the identity function.
Instances of these classes are straightforward. We deï¬ne an instance Reduce z
(ZqBasic q z) for any suitable integer type z and q representing a modulus that ï¬ts
within the precision of z, and a corresponding instance for Lift. For product groups (pairs)
used for CRT representation, we deï¬ne the natural instance Reduce a (b1,b2) whenever
we have instances Reduce a b1 and Reduce a b2. However, we do not have (nor do we
need) a corresponding Lift instance, because there is no sufï¬ciently generic algorithm to
combine canonical representatives from two quotient groups.
3.2.3
Rescale
Another operation commonly used in lattice cryptography is rescaling (sometimes also called
rounding) Zğ‘ to a different modulus. Mathematically, the rescaling operation âŒŠÂ·âŒ‰ğ‘â€² : Zğ‘ â†’
4Precision issues prevent us from merging Lift and Reduce into one class. For example, we can reduce an
Int into Zğ‘1 Ã— Zğ‘2 if both components can be represented by Int, but lifting may cause overï¬‚ow.
46
Zğ‘â€² is deï¬ned as
âŒŠï¸ ğ‘â€²
âŒ‰ï¸
ğ‘ Â· (ğ‘¥ + ğ‘Z)
âŒ‰ï¸
âŒŠï¸ ğ‘â€²
ğ‘ Â· ğ‘¥
=
âŒŠğ‘¥ + ğ‘ZâŒ‰ğ‘â€² :=
+ ğ‘â€²Z âˆˆ Zğ‘â€²,
(3.2.1)
where âŒŠÂ·âŒ‰ denotes rounding to the nearest integer. (Notice that the choice of representa-
tive ğ‘¥ âˆˆ Z has no effect on the result.) In terms of the additive groups, this operation is at
least an â€œapproximateâ€ homomorphism: âŒŠğ‘¥ + ğ‘¦âŒ‰ğ‘â€² â‰ˆ âŒŠğ‘¥âŒ‰ğ‘â€² + âŒŠğ‘¦âŒ‰ğ‘â€², with equality when ğ‘|ğ‘â€².
We represent the rescaling operation via class (Additive a, Additive b) => Rescale
a b, which introduces the function
rescale :: Rescale a b => a -> b
Instances. A straightforward instance, whose implementation just follows the mathemati-
cal deï¬nition, is Rescale (ZqBasic q1 z) (ZqBasic q2 z) for any integer type z and
types q1, q2 representing moduli that ï¬t within the precision of z.
More interesting are the instances involving product groups (pairs) used for CRT repre-
sentation. A naÃ¯ve implementation would apply Equation (3.2.1) to the canonical represen-
tative of ğ‘¥ + ğ‘Z, but for large ğ‘ this would require unbounded-integer arithmetic. Instead,
following ideas from [GHS12c], here we describe algorithms that avoid this drawback.
To â€œscale upâ€ ğ‘¥ âˆˆ Zğ‘1 to Zğ‘1ğ‘2
âˆ¼= Zğ‘1 Ã—Zğ‘2 where ğ‘1 and ğ‘2 are coprime, i.e., to multiply
by ğ‘2, simply output (ğ‘¥ Â· ğ‘2 mod ğ‘1, 0). This translates easily into code that implements
the instance Rescale a (a,b). Notice, though, that the algorithm uses the value of the
modulus ğ‘2 associated with b. We therefore require b to be an instance of class Mod, which
exposes the modulus value associated with the instance type. The instance Rescale b
(a,b) works symmetrically.
To â€œscale downâ€ ğ‘¥ = (ğ‘¥1, ğ‘¥2) âˆˆ Zğ‘1 Ã— Zğ‘2
âˆ¼= Zğ‘1ğ‘2 to Zğ‘1, we essentially need to divide
by ğ‘2, discarding the (signed) remainder. To do this,
1. Compute the canonical representative Â¯ğ‘¥2 âˆˆ Z of ğ‘¥2.
47
(Observe that (ğ‘¥â€²
ğ‘¥ = (ğ‘¥1, ğ‘¥2).)
1 = ğ‘¥1 âˆ’ (Â¯ğ‘¥2 mod ğ‘1), 0) âˆˆ Zğ‘1 Ã— Zğ‘2 is the multiple of ğ‘2 closest to
2. Divide by ğ‘2, outputting ğ‘âˆ’1
2
Â· ğ‘¥â€²
1 âˆˆ Zğ‘1.
The above easily translates into code that implements the instance Rescale (a,b) a, using
the Lift and Reduce classes described above. The instance Rescale (a,b) b works
symmetrically.
3.2.4
Gadget, Decompose, and Correct
Many advanced lattice cryptosystems use special objects called gadgets [MP12], which
support certain operations as described below. For the purposes of this work, a gadget
is a tuple over a quotient ring ğ‘…ğ‘ = ğ‘…/ğ‘ğ‘…, where ğ‘… is a ring that admits a meaningful
â€œgeometry.â€ For concreteness, one can think of ğ‘… as merely being the integers Z, but later
on we generalize to cyclotomic rings.
Perhaps the simplest gadget is the powers-of-two vector g = (1, 2, 4, 8, . . . , 2â„“âˆ’1)
over Zğ‘, where â„“ = âŒˆlg ğ‘âŒ‰. There are many other ways of constructing gadgets, either
â€œfrom scratchâ€ or by combining gadgets. For example, one may use powers of integers other
than two, mixed products, the Chinese Remainder Theorem, etc. The salient property of a
gadget g is that it admits efï¬cient algorithms for the following tasks:
1. Decomposition: given ğ‘¢ âˆˆ ğ‘…ğ‘, output a short vector x over ğ‘… such that âŸ¨g, xâŸ© =
gğ‘¡ Â· x = ğ‘¢ (mod ğ‘).
2. Error correction: given a â€œnoisy encodingâ€ of the gadget bğ‘¡ = ğ‘  Â· gğ‘¡ + eğ‘¡ mod ğ‘,
where ğ‘  âˆˆ ğ‘…ğ‘ and e is a sufï¬ciently short error vector over ğ‘…, output ğ‘  and e.
48
A key property is that decomposition and error-tolerant encoding relate in the following way
(where the notation is as above, and â‰ˆ hides a short error vector over ğ‘…):
ğ‘  Â· ğ‘¢ = (ğ‘  Â· gğ‘¡) Â· x â‰ˆ bğ‘¡ Â· x (mod ğ‘).
We represent gadget vectors and their associated operations via the following classes:
class Ring u => Gadget gad u where
gadget
::
Tagged gad [u]
encode
:: u -> Tagged gad [u]
class (Gadget gad u, Reduce r u) => Decompose gad u r where
decompose :: u -> Tagged gad [r]
class Gadget gad u => Correct gad u where
correct
:: Tagged gad [u] -> (u, [LiftOf u])
The class Gadget gad u says that the ring u supports a gadget vector indexed by the type
gad; the gadget vector itself is given by the term gadget. Note that its type is actually
Tagged gad [u]: this is a newtype for [u], with the additional type-level context Tagged
gad indicating which gadget the vector represents (recall that there are many possible
gadgets over a given ring). This tagging aids safety, by preventing the nonsensical mixing
of values associated with different kinds of gadgets. In addition, Haskell provides generic
ways of â€œpromotingâ€ ordinary operations to work within this extra context. (Formally, this
is because Tagged gad is an instance of the Functor class.)
The class Decompose gad u r says that a u-element can be decomposed into a vector
of r-elements (with respect to the gadget index by gad), via the decompose method.5 The
5For simplicity, here we have depicted r as an additional parameter of the Decompose class. Our actual
code adopts the more idiomatic practice of using a type family DecompOf u, which is deï¬ned by each instance
of Decompose.
49
class Correct gad u says that a noisy encoding of a u-element (with respect to the gadget)
can be error-corrected, via the correct method.
Note that we split the above functionality into three separate classes, both because their
arguments are slightly different (e.g., Correct has no need for the r type), and because in
some cases we have meaningful instances for some classes but not others.
Instances. For our type ZqBasic q z representing Zğ‘, we give a straightforward instan-
tiation of the â€œbase-ğ‘â€ gadget g = (1, ğ‘, ğ‘2, . . .) and error correction and decomposition
algorithms, for any positive integer ğ‘ (which is represented as a parameter to the gadget
type). In addition, we implement the trivial gadget g = (1) âˆˆ Z1
ğ‘, where the decomposition
algorithm merely outputs the canonical Z-representative of its Zğ‘-input. This gadget turns
out to be useful for building nontrivial gadgets and algorithms for product rings, as described
next.
For the pair type (which, to recall, we use to represent product rings in CRT represen-
tation), we give instances of Gadget and Decompose that work as follows. Suppose we
have gadget vectors g1, g2 over ğ‘…ğ‘1, ğ‘…ğ‘2, respectively. Then the gadget for the product ring
ğ‘…ğ‘1 Ã— ğ‘…ğ‘2 is essentially the concatenation of g1 and g2, where we ï¬rst attach 0 âˆˆ ğ‘…ğ‘2 com-
ponents to the entries of g1, and similarly for g2. The decomposition of (ğ‘¢1, ğ‘¢2) âˆˆ ğ‘…ğ‘1 Ã— ğ‘…ğ‘2
with respect to this gadget is the concatenation of the decompositions of ğ‘¢1, ğ‘¢2. All this
translates easily to the implementations
gadget = (++)  (map (,zero)  gadget)  (map (zero,)  gadget)
decompose (a,b) = (++)  decompose a  decompose b
In the deï¬nition of gadget, the two calls to map attach zero components to the entries of
g1, g2, and (++) appends the two lists. (The syntax ,  is standard applicative notation,
which promotes normal functions into the Tagged gad context.)
50
3.2.5
CRTrans
Fast multiplication in cyclotomic rings is made possible by converting ring elements to
the Chinese remainder representation, using the Chinese Remainder Transform (CRT)
over the base ring. This is an invertible linear transform akin to the Discrete Fourier
Transform (over C) or the Number Theoretic Transform (over appropriate Zğ‘), which has a
fast algorithm corresponding to its â€œsparse decompositionâ€ (see Equation 3.3.1 and [LPR13a,
Section 3] for further details).
Applying the CRT and its inverse requires knowledge of certain roots of unity, and the
inverse of a certain integer, in the base ring. So we deï¬ne the synonym type CRTInfo r =
(Int -> r, r), where the two components are (1) a function that takes an integer ğ‘– to the
ğ‘–th power of a certain principal6 ğ‘šth root of unity ğœ”ğ‘š in r, and (2) the multiplicative inverse
of Ë†ğ‘š in r, where Ë†ğ‘š = ğ‘š/2 if ğ‘š is even, else Ë†ğ‘š = ğ‘š. We also deï¬ne the class CRTrans,
which exposes the CRT information:
class (Monad mon, Ring r) => CRTrans mon r where
crtInfo :: Int -> mon (CRTInfo r)
Note that the output of crtInfo is embedded in a Monad mon, the choice of which can reï¬‚ect
the fact that the CRT might not exist for certain ğ‘š. For example, the CRTrans instance for
the complex numbers C uses the trivial Identity monad, because the complex CRT exists
for every ğ‘š, whereas the instance for ZqBasic q z uses the Maybe monad to reï¬‚ect the fact
that the CRT may not exist for certain combinations of ğ‘š and moduli ğ‘.
We give nontrivial instances of CRTrans for ZqBasic q z (representing Zğ‘) for prime ğ‘,
and for Complex Double (representing C). In addition, because we use tensors and cyclo-
tomic rings over base rings like Z and Q, we must also deï¬ne trivial instances of CRTrans
for Int, Int64, Double, etc., for which crtInfo always returns Nothing.
6A principal ğ‘šth root of unity in r is an element ğœ”ğ‘š such that ğœ”ğ‘š
ğ‘š âˆ’ 1 is not a zero divisor
for every prime ğ‘¡ dividing ğ‘š. Along with the invertibility of ^ğ‘š in r, these are sufï¬cient conditions for the
index-ğ‘š CRT over r to be invertible.
ğ‘š = 1, and ğœ”ğ‘š/ğ‘¡
51
3.2.6 Type-Level Cyclotomic Indices
Recall that there is one cyclotomic ring for every positive integer ğ‘š. The index ğ‘š of a
cyclotomic ring, and in particular its factorization, plays a major role in the deï¬nitions of
the ring operations. For example, the index-ğ‘š â€œChinese remainder transformâ€ is similar to a
mixed-radix FFT, where the radices are the prime divisors of ğ‘š. In addition, cyclotomic
rings can sometimes be related to each other based on their indices. For example, the ğ‘šth
cyclotomic can be seen as a subring of the ğ‘šâ€²th cyclotomic if and only if ğ‘š|ğ‘šâ€²; the largest
common subring of the ğ‘š1th and ğ‘š2th cyclotomics is the gcd(ğ‘š1, ğ‘š2)th cyclotomic, etc.
In Î›âˆ˜ğœ†, a cyclotomic index ğ‘š is speciï¬ed by an appropriate type m, and the data types
representing cyclotomic rings (and their underlying coefï¬cient tensors) are parameterized
by such an m. Based on this parameter, Î›âˆ˜ ğœ† generically derives algorithms for all the
relevant operations in the corresponding cyclotomic. In addition, for operations that involve
more than one cyclotomic, Î›âˆ˜ğœ† expresses and statically enforces (at compile time) the laws
governing when these operations are well deï¬ned.
We achieve the above properties using Haskellâ€™s type system, with the help of the pow-
erful data kinds extension [Yor+12] and the singletons library [EW12; ES14]. Essentially,
these tools enable the â€œpromotionâ€ of ordinary values and functions from the data level to
the type level. More speciï¬cally, they promote every value to a corresponding type, and
promote every function to a corresponding type family, i.e., a function on the promoted
types. We stress that all type-level computations are performed at compile time, yielding the
dual beneï¬ts of static safety guarantees and no runtime overhead.
We provide a brief overview of the interface for type-level factored numbers below. In
subsection 3.2.7 below we give more details on how cyclotomic indices are represented and
operated upon at the type level. Then in subsection 3.2.8 we describe how all this is used to
generically derive algorithms for arbitrary cyclotomics.
52
Interface. Concretely, Î›âˆ˜ğœ† deï¬nes a special data type Factored that represents positive
integers by their factorizations, along with several functions on such values. Singletons
then promotes all of this to the type level. This yields concrete â€œfactored typesâ€ Fm for
various useful values of m, e.g., F1, . . . , F100, F128, F256, F512, etc. In addition, it yields
the following type families, where m1, m2 are variables representing any factored types:
â€¢ FMul m1 m2 (synonym: m1 * m2) and FDiv m1 m2 (synonym: m1 / m2) respectively
yield the factored types representing ğ‘š1 Â· ğ‘š2 and ğ‘š1/ğ‘š2 (if it is an integer; else it
yields a compile-time error);
â€¢ FGCD m1 m2 and FLCM m1 m2 respectively yield the factored types representing
gcd(ğ‘š1, ğ‘š2) and lcm(ğ‘š1, ğ‘š2);
â€¢ FDivides m1 m2 yields the (promoted) boolean type True or False, depending on
whether ğ‘š1|ğ‘š2. In addition, m1 â€˜Dividesâ€˜ m2 is a convenient synonym for the
constraint True ~ Divides m1 m2. (This constraint is used section 3.5 below.)
Finally, Î›âˆ˜ğœ† also provides several entailments representing number-theoretic laws that
the compiler itself cannot derive from our data-level code. For example, transitivity of the
â€œdividesâ€ relation is represented by the entailment
(k â€˜Dividesâ€˜ l, l â€˜Dividesâ€˜ m) :- (k â€˜Dividesâ€˜ m)
which allows the programmer to satisfy the constraint ğ‘˜|ğ‘š in any context where the con-
straints ğ‘˜|â„“ and â„“|ğ‘š are satisï¬ed.
3.2.7 Promoting Factored Naturals
Operations in a cyclotomic ring are governed by the prime-power factorization of its index.
Therefore, we deï¬ne the data types PrimeBin, PrimePower, and Factored to represent
factored positive integers (here the types Pos and Bin are standard Peano and binary
encodings, respectively, of the natural numbers):
53
-- Invariant: argument is prime
newtype PrimeBin
= P
Bin