要对每一篇文章每一个单词顺序查找。在文章数是海量的情况下，这样的做法只存在
理论上可行性，现实中是没有人愿意使用的。
在这里这张单词表就是索引表，索引项的通用结构是：
■次关键码，例如上面的“英文单词”；
■记录号表，例如上面的“文章编号”。
其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指
针或者是该记录的主关键字），这样的索引方法就是倒排索引（invertedindex）。倒排
索引源于实际应用中需要根据属性（或字段、次关键码）的值来查找记录。这种索引
表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来
确定属性值，面是由属性值来确定记录的位置，因面称为倒排索引。
倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不
用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长，比如上例有7个
单词的文章编号只有一个，而“book”、“friend”、“good”有两个文章编号，若是对
312
---
## Page 337
第8章查找
多篇文章所有单词建立倒排索引，那每个单词都将对应相当多的文章编号，维护比较
困难，插入和删除操作都需要作相应的处理。
当然，现实中的搜索技术非常复杂，比如我们不仅要知道某篇文章有要搜索的关
键字，还想知道这个关键字在文章中的哪些地方出现，这就需要我们对记录号表做一
些改良。再比如，文章编号上亿，如果都用长数字也没必要，可以进行压缩，比如三
篇文章的编号是“112,115，119”，我们可以记录成“112，+3，+4”，即只记录差值，
这样每个关键字就只占用一两个字节。甚至关键字也可以压缩，比如前一条记录的关
<>，
以起到压缩数据的作用。再比如搜索时，尽管告诉你有几千几万条查找到的记录，但
其实真正显示给你看的，就只是当中的前10或者20条左右数据，只有在点击下一页
时才会获得后面的部分索引记录，这也可以大大提高了整体搜索的效率。
呵呵，有同学说得没错，如果文章是中文就更加复杂。比如文章中出现“中国
人”，它本身是关键字，那么“中国”、“国人”也都可能是要查找的关键字一啊，太
复杂了，你还是自已去找相关资料吧。如果想彻底明白，努力进入google或者百度公
司做搜索引擎的软件工程师，我想他们会满足你对技术知识的渴求。
我们课堂上就是起到抛砖引玉的作用，希望可以让你对搜索技术产生兴趣，我会
非常欣慰的，休息一下。
8.6二叉排序树
大家可能都听过这个故事，说有两个年轻人正在深山中行走。忽然发现远处有一
只老虎要冲过来，怎么办？其中一个赶忙弯腰系鞋带，另一个奇怪地间：“你系鞋带干
跑得比你快就行了。
这真是交友不慎呀！别急，如果你的朋友是系鞋带者，你怎么办？
后来老虎来了，系鞋带者拼命地跑，另一人则急中生智，爬到了树上。老虎在选
择爬树还是追人之间，当然是会选择后者，于是结果爬树者改变了跑的思想，这
一改变何等重要，捡回了自已的一条命。
313
---
## Page 338
大话数据结构
图 8-6-1
好了，这个故事也告诉我们，所谓优势只不过是比别人多深入思考一点而已。
假设查找的数据集是普通的顺序存储，那么插人操作就是将记录放在表的末端，
给表记录数加一即可，删除操作可以是删除后，后面的记录向前移，也可以是要删除
的元素与最后一个元素互换，表记录数减一，反正整个数据集也没有什么顺序，这样
的效率也不错。应该说，插入和删除对于顺序存储结构来说，效率是可以接受的，但
这样的表由于无序造成查找的效率很低，前面我们有讲解，这就不在啰啸。
如果查找的数据集是有序线性表，并且是顺序存储的，查找可以用折半、插值、
斐波那契等查找算法来实现，可借，因为有序，在插人和翻除操作上，就需要耗费大
量的时间。
有没有一种即可以使得插入和删除效率不错，又可以比较高效率地实现查找的算
法呢？还真有。
我们在8.2节把这种需要在查找时插入或删除的查找表称为动态查找表。我们现
在就来看看什么样的结构可以实现动态查找表的高效率。
如果在复杂的问题面前，我们束手无策的话，不妨先从最最简单的情况入手。现
在我们的目标是插入和查找同样高效。假设我们的数据集开始只有一个数（62），然后
现在需要将88插入数据集，于是数据集成了{62,88}，还保持着从小到大有序。再查
找有没有58，没有则插入，可此时要想在线性表的顺序存储中有序，就得移动62和
88的位置，如图8-6-2左图，可不可以不移动呢？嗯，当然是可以，那就是二叉树结
构。当我们用二叉树的方式时，首先我们将第一个数62定为根结点，88因为比62
大，因此让它做62的右子树，58因比62小，所以成为它的左子树。此时58的插入
314
---
## Page 339
第8章查找
并没有影响到62与88的关系，如图8-6-2右图所示。
下标
62
62
88
88
线性表的顺序存储结构
二叉树结构
图8-6-2
也就是说，若我们现在需要对集合（62.88，58,47,35,73，51,99,37,93}做查找，在我们
打算创建此集合时就考虑用二叉树结构，而且是排好序的二叉树来创建。如图8-6-3
所示，62、88、58创建好后，下一个数47因比58小，是它的左子树（见③），35
是47的左子树（见④），73比62大，但却比88小，是88的左子树（见），51比
62小、比58小、比47大，是47的右子树（见6），99比62、88都大，是88的
右子树（见），37比62、58、47都小，但却比35大，是35的右子树（见⑧），
93则因比62、88大是99的左子树（见9）。
62
58
47
73
35
51
93
37
图8-6-3
这样我们就得到了一棵二叉树，并且当我们对它进行中序遍历时，就可以得到一
个有序的序列（35.3747,51,58,62,73.88，93.99)，所以我们通常称它为二叉排序树。
二叉排序树（BinarySortTree），又称为二叉查找树。它或者是一棵空树，或者
是具有下列性质的二叉树。
若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
315
---
## Page 340
大据数据结构
■它的左、右子树也分别为二叉排序树。
从二叉排序树的定义也可以知道，它前提是二叉树，然后它采用了递归的定义方
法，再者，它的结点间满足一定的次序关系，左子树结点一定比其双亲结点小，右子
树结点一定比其双亲结点大
构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删
除关键字的速度。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的
数据集的，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。
8.6.1二叉排序树查找操作
首先我们提供一个二叉树的结构。
/二叉树的二叉链表结点结构定义*/
typedefstruct BiTNode
结点结构/
int data;
1结点数据
struct BiTNode *lchild,*rchild;
左右孩子指针*/
)BiTNode,*BiTree;
然后我们来看看二叉排序树的查找是如何实现的。
/递归查找二叉换序树中是否存在key，·/
/*指针指向的双亲，其初始调用值为NULL*/
/若壹我成功，则指针D指向该数据元素结点，并退回TRUE*/
/否则指针p指向壹找路径上访问的最后一个结点并返图FALSE*/
1Status SearchBsT（BiTree T,int key,BiTree f,BiTree *p）
3
if（!T）
1查找不成功/
4
5
*p-f;
6
return FALSE;
7
8
else1f（key=->data）/*查我成功·/
9
10
*p-T;
11
return TRUE;
12
316
---
## Page 341
第8章查找
13
elseif（keydata）
14
returnSearchBsT（T->lchild，key，T，p）:/*在左子树继续查找*/
15
else
16
return SearchBST（T->rchild，key，T，p）/在右于树继续查找*/
171
1.SearchBST函数是一个可递归运行的函数，函数调用时的语句为
SearchBST（T,93,NULL,p），参数T是一个二叉链表，其中数据如图8-6-3所
示，key代表要查找的关键字，目前我们打算查找93，二叉树f指向T的双
亲，当T指向根结点时，f的初值就为NULL，它在递归时有用，最后的参数
P是为了查找成功后可以得到查找到的结点位置。
2.第3~7行，是用来判断当前二叉树是否到叶子结点，显然图8-6-3告诉我们
当前T指向根结点62的位置，T不为空，第5~6行不执行。
3.第8~12行是查找到相匹配的关键字时执行语句，显然93=62，第10~11
行不执行。
4.第13~14行是当要查找关键字小于当前结点值时执行语句，由于93>62，第
14行不执行。
5.第15~16行是当要查找关键字大于当前结点值时执行语句，由于93>62，所
以递归调用SearchBST（T->rchidkeyTp）。此时T指向了62的右孩子88，
如图8-6-4所示。
62
58
47
73
35
51
93
37
图8-6-4
6.此时第二层SearchBST，因93比88大，所以执行第16行，再次递归调用
SearchBST（T->rchildkey，Tp)。此时T指向了88的右孩子99，如图8-6-5
所示。
317
---
## Page 342
大话数据结构
73
6
37
图8-6-5
7.第三层的SearchBST，因93比99小，所以执行第14行，递归调用
SearchBST（T->kchildkey，T,p）。此时T指向了99的左孩子93，如图8-6-6
所示。
6
47
51
93
37
图8-6-6
8.第四层SearchBST，因key等于T>data，所以执行第10~11行，此时指针p
指向93所在的结点，并返回True到第三层、第二层、第一层，最终函数返
回True。
8.6.2二叉排序树插入操作
有了二叉排序树的查找函数，那么所谓的二叉排序树的插入，其实也就是将关键
字放到树中的合适位置而已，来看代码。
/当二叉排序树T中不存在关键字等于key的数据元素时，/
/*扬入key并返四TRUE，否则返四FALSE*/
318
---
## Page 343
第8章查找
Status InsertBST（BiTree *T,int key)
BiTree p,s;
if（1SearchBST（*T，key，NULL，6p））/·壹找不成功*/
s-（BiTree）malloc（sizeof（BiTNode））;
s->data-key;
N-PTTdata)
1-PTTTrchild-s;
return TRUE;
else
return FALSE;
树中已有关键字相同的结点，不再描入
这段代码非常简单。如果你调用函数是“InsertBST（T93）：”，那么结果就是
FALSE，如果是“InsertBST（T95）：”，那么一定就是在93的结点增加一个右孩子
95，并且返回True。如图8-6-7所示。
62
58
88
47
73
93
37
95
图8-6-7
有了二叉排序树的插入代码，我们要实现二叉排序树的构建就非常容易了。下面
的代码就可以创建一棵图8-6-3这样的树。
319
---
## Page 344
大语数保结构