ity FauthZK with only circuit-based commands to compute a
Boolean circuit AdderModp. In both protocols, we assume
that Fzk-edaBits shares the same initialization procedure with
FauthZK, and thus the same global keys are used in the two
functionalities. This is the case, when we use the protocol
Πzk-edaBits shown in Figure 6 to UC-realize Fzk-edaBits in the
FauthZK-hybrid model. We also assume that FauthZK can use
authenticated values generated by Fzk-edaBits. This is easy to
be realized by viewing Fzk-edaBits as a part of FauthZK.
We provide the full details about the conversion from arith-
metic to Boolean circuits in Figure 7. In Figure 8, we de-
scribe in details how to perform an efﬁcient conversion from
Boolean to arithmetic circuits.
Below, we prove the security of the two protocols in the
following theorems.
Theorem 2. Protocol ΠA2B
Convert UC-realizes the convertA2B
command of functionality FauthZK in the presence of a
static, malicious adversary with statistical error 1/pk in the
(Fzk-edaBits,FauthZK)-hybrid model.
Theorem 3. Protocol ΠB2A
Convert UC-realizes the convertB2A
508    30th USENIX Security Symposium
USENIX Association
Protocol ΠB2A
Convert
Let p > 2 be a prime and m = (cid:100)log p(cid:101).
Initialize: P and V send (init) to Fzk-edaBits, which re-
turns two uniform global keys to V .
Input: Two parties P and V hold m authenticated bits
[x0]2, . . . , [xm−1]2.
Convert: P and V convert m authenticated bits into one
authenticated value over ﬁeld Fp as follows:
1. Call funcationality Fzk-edaBits, which returns ([r0]2,
. . . , [rm−1]2, [r]p) to the parties.
2. Compute ([z0]2, . . . , [zm−1]2) := AdderModp([x0]2,
. . . , [xm−1]2, [r0]2, . . . , [rm−1]2) by calling functional-
ity FauthZK, such that ∑m−1
h=0 xh · 2h +
∑m−1
h=0 rh · 2h mod p.
h=0 zh · 2h = ∑m−1
3. Execute the BatchCheck procedure on ([z0]2, . . . ,
[zm−1]2) to obtain (z0, . . . ,zm−1), and then compute
z := ∑m−1
h=0 zh · 2h mod p.
4. Compute and output [x]p := z− [r]p.
Figure 8: Protocol for converting from Boolean to arith-
metic circuits in the (Fzk-edaBits,FauthZK)-hybrid model.
command of FauthZK in the presence of a static, malicious
adversary in the (Fzk-edaBits,FauthZK)-hybrid model.
The proofs of the above two theorems can be found in the
full version of this paper [53].
Optimization using circuit-based zk-edaBits. In the con-
version protocols described as above, a prover P and a veriﬁer
V generate random zk-edaBits using functionality Fzk-edaBits
in the preprocessing phase, and then convert authenticated
values between arithmetic and Boolean circuits using these
random zk-edaBits in the online phase.
We can use an alternative approach to convert authenticated
values between arithmetic and Boolean circuits, and obtain
better whole efﬁciency but larger online cost. Speciﬁcally,
for authenticated bits [x0]2, . . . , [xm−1]2 on m output wires of
a Boolean circuit, P can compute x := ∑m−1
h=0 xh · 2h mod p
locally. Then, P sends (input,x, p) to FauthZK and V sends
(input, p) to FauthZK, which returns [x]p to the parties. Simi-
larly, the parties can also convert an authenticated value [x]p
on an output wire of an arithmetic circuit into m authenti-
cated bits [x0]2, . . . , [xm−1]2, by calling the (input) command
of FauthZK. In this way, two parties can create N circuit-based
zk-edaBits for some integer N. However, in the circuit-based
zk-edaBits, a malicious prover may cause the ﬁeld elements
over Fp are inconsistent with corresponding bits. Veriﬁer V
can check the consistency of these circuit-based zk-edaBits
using the cut-and-bucketing technique. Speciﬁcally, in the
online phase, two parties can execute the checking proce-
dure shown in Figure 6 to check the consistency of these
circuit-based zk-edaBits by sacriﬁcing (B− 1)N + c random
zk-edaBits generated in the preprocessing phase. Using this
optimization, for computing N circuit-based zk-edaBits, we
can save N random zk-edaBits and N evaluations of circuit
AdderModp in terms of the whole efﬁciency, but increase the
online cost by a factor of B− 1.
5 Converting Publicly Committed Values to
Privately Authenticated Values
The second type of conversions that we would like to study
is the conversion from publicly committed data to privately
authenticated data. Here, publicly committed data referred
to those committed with a short digest, which can be pub-
lished on something that can be modeled as a bulletin board
(e.g., well-established websites or some blockchain). Pri-
vately authenticated data refers to the values only known
by a prover that are authenticated by a designated veriﬁer
based on IT-MACs, and thus can be efﬁciently used to prove
any mixed arithmetic-Boolean circuit using the recent ZK pro-
tocols [7, 27, 52, 54] and our arithmetic-Boolean conversion
protocols. The conversion from publicly committed data to
privately authenticated data will allow us to efﬁciently prove
statements on consistent committed data to multiple different
veriﬁers for multiple times.
Our commitment-authentication conversion protocol. We
present our efﬁcient conversion protocol in Figure 9. This pro-
tocol consists of two phases: 1) generating a non-interactive
commitment and 2) converting publicly committed values to
privately authenticated values in an interactive manner. To
commit a large volume of data or different types of data, we
divide them into pieces, where the i-th piece is denoted by
xxxi ∈ Fm
q with a prime q≥ 2 and a parameter m. Then, we let the
prover sample a random key sk and a uniform randomness r
both in {0,1}λ. Our commitment consists of com0 = H(sk,r)
and ccci = PRF(sk,i)+xxxi ∈ Fm
q for all i ∈ [1, (cid:96)] with some (cid:96) ∈ N,
where H is a random oracle and PRF is a pseudorandom func-
tion. To perform conversion, the prover P proves knowledge
of sk and xxxi, such that com0 and ccci are computed with the
key and data piece. Since ccci can be put in the public domain,
one can further reduce the size of the overall commitment by
computing a Merkle tree on top of all ccci’s. In this way, the
commitment only has a size of 4λ bits, including com0 and
the root of the Merkle tree (i.e., com1).
Since key sk ∈ {0,1}λ has a high entropy, we can actually
remove the randomness r. That is, the prover can just set
H(sk) as com0 in the commitment phase and prove com0 =
H([ssskkk]2) in the conversion phase. This will slightly improve
the efﬁciency of this protocol.
USENIX Association
30th USENIX Security Symposium    509
Protocol ΠNICom→[·]
q be a pseudorandom function.
Let q ≥ 2 be a prime. Let H : {0,1}∗ → {0,1}2λ be a
hash function modeled as a random oracle, and PRF :
{0,1}λ ×{0,1}λ → Fm
Compute a public commitment: A prover P computes
and publishes a non-interactive commitment on values:
1. Sample sk,r ← {0,1}λ; compute com0 := H(sk,r).
q with (cid:96),m ∈ N, compute ccci :=
2. On input xxx1, . . . ,xxx(cid:96) ∈ Fm
PRF(sk,i) + xxxi ∈ Fm
q for i ∈ [1, (cid:96)].
3. Compute di := H(ccci) for all i ∈ [1, (cid:96)]; build a Merkle
tree on these values using H with com1 as the root.
4. Publish the commitment (com0, com1).
Initialize: Prover P and a veriﬁer V send (init) to
FauthZK, which returns two uniform global keys to V .
Convert committed values into authenticated values:
This procedure can be executed multiple times. For
some i ∈ [1, (cid:96)], P and V convert a committed value
xxxi ∈ Fm
q only known by P to m authenticated values
[xi,1], . . . , [xi,m]:
1. Let pathi be the set containing all siblings of the nodes
in the path from the i-th leaf to the root com1. Prover
P sends (ccci, pathi) to V , who veriﬁes that H(ccci) is a
leaf node rooted in com1.
2. By calling functionality FauthZK, the parties obtain
authenticated bit-vectors [ssskkk]2, [rrr]2 on key sk and ran-
domness r, and then P proves in zero-knowledge that
com0 = H([ssskkk]2, [rrr]2).
3. The parties call functionality FauthZK to compute
q , and then
([xi,1], . . . , [xi,m]) ← ccci − PRF([ssskkk]2,i) ∈ Fm
output {[xi, j]} j∈[1,m].
Figure 9: Protocol for converting committed values into
authenticated values in the FauthZK-hybrid model.
Theorem 4. Let H be a random oracle and PRF be a pseu-
dorandom function. Then protocol ΠNICom→[·] shown in Fig-
ure 9 UC-realizes the convertC2A command of functionality
FauthZK in the presence of a static, malicious adversary in the
FauthZK-hybrid model.
Below, we discuss the intuition of the above theorem and
leave the full formal proof to the full version [53]. We commit
to sk using a standard UC commitment in the random-oracle
model, and so sk is computationally hiding, meaning that
PRF(sk,i) for all i ∈ [1, (cid:96)] are indistinguishable from uni-
formly random values in Fm
q . In the FauthZK-hybrid model,
the ZK proof does not reveal any information of committed
values. Overall, the committed data is hidden. In the proof of
security, the simulator can extract the key sk from com0 in the
random-oracle model. Once sk was extracted, the simulator
can easily recover xxxi by decrypting ccci for i ∈ [1, (cid:96)]. This also
implies the binding property. Together with the soundness of
the ZK protocol realizing FauthZK, we can ensure the consis-
tency between authenticated values and committed values.
i over Fm
Note that this commitment (com0, com1) itself is not equiv-
ocal if we use the natural “open” algorithm that sends (sk,r):
although it is possible to equivocate the key sk to any value by
programming the random oracle, the function PRF is ﬁxed.
Equivocating from xxxi to xxx(cid:48)
i would require ﬁnding a key sk(cid:48)
such that PRF(sk(cid:48),i)−PRF(sk,i) = xxxi−xxx(cid:48)
q . However,
we can make it equivocal by an interactive opening: instead of
directly sending (sk,r), we can send ccci and the corresponding
path that can be veriﬁed with com1, and prove knowledge of
a key sk and a randomness r such that com0 = H(sk,r) and
the other relationship on ccci hold. In this way, we can use the
zero-knowledge property to equivocate the commitment.
Instantiation of PRF. We use LowMC [2] to instantiate PRF
for reducing circuit complexity. One issue with LowMC is
that it contains a lot of XOR gates. Although they are free
cryptographically, the computation complexity can be fairly
high. We adopt the following optimizations for competitive
performance:
• Similar to the signature scheme Picnic [56], we need to
run PRF on a single key for many times, and thus can
precompute the matrix multiplication about the key only
once and use it for all PRF evaluations.
• We pick the block size as 64 bits to further reduce the
number of XOR operations. The resulting protocol is highly
efﬁcient, and can convert 18,000 publicly committed data
blocks (totally 144KB) to authenticated values per second.
• To reduce the number of rounds in LowMC, we choose
the data complexity to be 230 blocks, which is sufﬁcient to
commit 8 GB data. If the data is larger than that, we can
just pick a new PRF key and commit this key.
Comparing with other candidates. We brieﬂy discuss the
concrete efﬁciency of our protocol for one commitment-
authentication conversion, and compares it with other alterna-
tives shown in Table 1. Here, we ignore the efﬁciency com-
parison for the commitment-generation phase, as it needs to
be executed only once.
For SHA-256 and LowMC-256, they refer to building a
hash function modeled as a random oracle, and further con-
struct a commitment on message x via H(x,r) with a random-
ness r. For SHA-256, one invocation takes 22573 AND gates
and can commit 256 bits of messages. For LowMC-256, we
ﬁrst pick a LowMC block cipher with 256-bit key and block
510    30th USENIX Security Symposium
USENIX Association
Scheme
Time (µs)
Comm. (bits)
55
62
395
705
This work
SHA-256 LowMC-256
≥ 1000
49
Table 1: Efﬁciency comparison between our protocol and
alternative protocol with natural commitments. Running
time in microsecond (µs) is based on two Amazon EC2 ma-
chines of type m5.2xlarge.
sizes, and then use Davies–Meyer to build a hash function.
The SHA-256 method requires a lot of communication due to
a large circuit size. The LowMC-256 approach is signiﬁcantly
slower compared to ours because: 1) our 64-bit block cipher
only computes 64-bit matrix multiplication, but LowMC-256
needs 256-bit matrix multiplication meaning 16 times more
operations; 2) we only need 11 rounds but LowMC-256 needs
53 rounds; 3) we can use a ﬁxed key for all messages but
LowMC-256 needs to rekey for every block of the message.
Conversion from authenticated values to publicly com-
mitted values. In some applications, two parties P and V
may want to convert authenticated values (say, output by some
MPC protocol) into a public commitment on the same values.
Based on the protocol ΠNICom→[·] shown in Figure 9, this is
easy to be realized by the following execution:
1. To convert authenticated values {[xi, j]}i∈[1,(cid:96)], j∈[1,m] into
publicly committed values, P commits these vectors
(xi,1, . . . ,xi,m) for i ∈ [1, (cid:96)] by executing the commitment-
generation phase of protoocol ΠNICom→[·]. Then P pub-
lishes the resulting commitment (com0, com1).
2. Then, P and V execute protocol ΠNICom→[·]
to con-
vert commitment (com0, com1) into authenticated values
{[x(cid:48)
i, j]}i∈[1,(cid:96)], j∈[1,m].
3. The parties call the CheckZero procedure on [x(cid:48)
for all i ∈ [1, (cid:96)], j ∈ [1,m], and abort if the check fails.
i, j]− [xi, j]