Fooling Image Search Engine
Yuanjun Gongï¼ŒBin Liang*ï¼ŒJianjun Huang 
{Gongyuanjun, liangb, hjj}@ruc.edu.cn
Renmin University of China
1
2
1. Introduction
2. Technical Background
3. Methodology
4. Attacking Google Image Search Engine
5. Discussion
6. Conclusion
Outline
â€¢ Image search engines (e.g. Google, Baidu) provide service of reverse image
search, or search by image, to allow users to search for related images by
uploading an image or image URL.
â€¢ Reverse image search is a content-based image retrieval (CBIR) query
technique that involves providing the CBIR system with a sample image
that it will then base its search upon; in terms of information retrieval, the
sample image is what formulates a search query.[1]
Reverse image search may be used to
â€¢
Locate the source of an image 
â€¢
Find higher resolution versions
â€¢
Track down the content creator
â€¢
Detect plagiarism
[1]https://en.wikipedia.org/wiki/Reverse_image_search
1. Introduction
Query image  x
Search result
4
â€¦â€¦
Query image
Search result
5
Query image
Search result
6
Plagiarism Detection
Original image
Poster of a TV play 
suspected plagiarism
The poster of TV play Fuyao released in June 2016,
was accused of
plagiarism. The original image is created in 2014 by LuHe, a painter.
7
Plagiarism Detection
â€¦â€¦
poster
Original picture
â€¢ CBIR system can be a potential attack target.
â€¢ Adversaries may evade the search engine by introducing 
perturbations to the query image.  
8
+ğœ€
Query image  x
adversarial image  xâ€™
No results
Evasion
Matching Images
Query image  x
Threat model
9
Evasion
Search result: original image
Query image
10
Evasion
Adversarial image
No search result: evasion
11
Images Database
Local Features
ï¼ˆSIFT, SURF, etc.ï¼‰
Index Database
Â·Â·Â·
Aggregated Feature
(BoF, VLAD, etc.)
Query image
Â·Â·Â·
Image With
greatest 
similarity 
CBIR framework
Similarity 
matching
2. Technical Background
Local Features
ï¼ˆSIFT, SURF, etc.ï¼‰
Aggregated Feature
(BoF, VLAD, etc.)
12
â€¢ Essentially, searching similar images in CBIR systems is a image
descriptors matching process. SIFT (Scale Invariant Feature Transform ) [2]
and SURF (Speeded Up Robust Features) [3] are widely used local
featuring algorithms.
SIFT descriptor matching
Local Features
â€¢ SIFT is more accurate while SURF has a higher speed.
[1] Lowe, David G., and D. G. Lowe. "Distinctive Image Features from Scale-Invariant Keypoints." International Journal of Computer
Vision 60.2(2004):91-110
[2] Bay, Herbert, T. Tuytelaars, and L. V. Gool. "SURF: Speeded Up Robust Features." European Conference on Computer Vision
Springer-Verlag, 2006:404-417.
13
SIFT and SURF algorithms both build image pyramids, referred to
as scale space, to find keypoints in different scale. They both apply a
non-maximum suppression in a 3Ã—3Ã—3 neighborhood to find the
potential keypoints. Point ğ’™ is recorded as a keypoint only when
ğ‘ğ‘ğ‘ (ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’(ğ‘¥))>T, while T refers to the threshold of the algorithm.
For each octave of scale space, the initial image is repeatedly
convolved with Gaussians to produce the set of scale space.
Adjacent Gaussian images are subtracted to produce the difference-
of-Gaussian images.
Scale space
26 neighbors in 3Ã—3Ã—3 regions
SIFT [2]
14
Instead of using DOG-value, SURF uses the approximation
of the
determinant of Hessian matrix. Given a point ğ’™ =
(ğ‘¥, ğ‘¦) in an image I, the Hessian matrix ğ»(ğ’™, ğœ) in ğ’™ at scale
ğœ is defined as follows
ğ» ğ’™, ğœ = ğ¿ğ‘¥ğ‘¥ ğ’™, ğœ
ğ¿ğ‘¥ğ‘¦ ğ’™, ğœ
ğ¿ğ‘¥ğ‘¦ ğ’™, ğœ
ğ¿ğ‘¦ğ‘¦ ğ’™, ğœ
where ğ¿ğ‘¥ğ‘¥(ğ‘¥, ğœ) is the convolution of the Gaussian second
order derivative with the image I in point ğ‘¥.
Using box filter instead of Gaussian second order derivative
to speed up, the approximation of ğ¿ğ‘¥ğ‘¥ ğ’™, ğœ
is denoted by
ğ·ğ‘¥ğ‘¥ ğ’™, ğœ .
Therefore ğ‘‘ğ‘’ğ‘¡ ğ»ğ‘ğ‘ğ‘ğ‘Ÿğ‘œğ‘¥ = ğ·ğ‘¥ğ‘¥ğ·ğ‘¥ğ‘¦ âˆ’ 0.9ğ·ğ‘¥ğ‘¦
2
SURF [3]
15
â€¢ CBIR systems perform well with rotated image, gray scale
image, or even part of the image.
SIFT/SURF
are
rotation
invariable and scale invariable,
therefore original image can be
retrieved using rotated image
and small-scale image as query
images.
SIFT/SURFâ€™s robustness makes
it
possible
to
achieve
a
successful
search
with
only
about 10% keypoints.
Small-scale image
original image
Part of the image
Rotated image 
Performance
â€¢ Descriptor
plays
an
important
role
in
image
matching. Therefore, the basic idea of bypassing an
image retrieval system is to change the statistical
histogram of keypoints descriptors.
â€¢ Two methods
â‘  Removing original keypoints from the image
â‘¡ Injecting external keypoints to the image
â€¢ Note that utility-preserving is required.
16
3. Methodology
â€¢ An adversarial image should be utility-preserving, i.e., it
must keep its original visual semantics for a human observer.
17
Adversarial image 
(acceptable)
Original image
Adversarial image
(unacceptable)
Utility-Preserving Requirement
+ğœ€
+ğœ€
18
Original image
187 SIFT keypoints
Processed image
73 SIFT keypoints
RMD
Removal with Minimum local Distortion attack (RMD) targets a limited
number of keypoints to be erased. It introduce a value ğ›¿+ > 0 that defines
the subset ğœ€ğ›¿+ = ğ‘¥: ğ¶ < ğ· ğ‘¥ < ğ¶ + ğ›¿+ . Erasing keypoint x in
ğœ€ğ›¿+
means to decrease the absolute of DOG-value |D(x)| by an amount |ğ›¿| such
that its new value is below the threshold C ,C is the fixed contrast threshold.
Some SIFT keypoints removal algorithm have been proposed in resent
years, We employ the fast and effective RMD [4] method to remove SIFT
keypoints.
[4] Do, Thanh Toan, et al. "Deluding image recognition in sift-based cbir systems." ACM Workshop on Multimedia 
in Forensics, Security and Intelligence ACM, 2010:7-12.
3.1 SIFT Keypoints Removing Method
As far as we know, there are no particular SURF keypoint removal algorithms
in the early works. Therefore we propose a method called R-SURF to remove
SURF keypoints, it is a optimization-based keypoints removing algorithm.
For every target keypoint, support area S(x) is determined and three box filters
ğ¾ğ‘¥ğ‘¥, ğ¾ğ‘¥ğ‘¦, ğ¾ğ‘¦ğ‘¦ are reconstructed based on the scale ğœ of the keypoint, and the
following nonlinear optimization is constructed.
19
min ğ‘“ =
à·
ğ‘¢,ğ‘£ âˆˆğ‘† ğ’™
ğœ€ ğ‘¢, ğ‘£
ğ‘ . ğ‘¡.
ğ¾ğ‘¥ğ‘¥â¨‚Iâ€² ğ’™
Ã— ğ¾ğ‘¦ğ‘¦â¨‚Iâ€² ğ’™
âˆ’ 0.81 Ã— ğ¾ğ‘¥ğ‘¦â¨‚Iâ€² ğ’™
2
< ğ‘‡
I ğ‘¢, ğ‘£ + ğœ€ ğ‘¢, ğ‘£ â‰¥ 0 , ğ‘¢, ğ‘£ âˆˆ ğ‘† ğ’™
I ğ‘¢, ğ‘£ + ğœ€ ğ‘¢, ğ‘£ â‰¤ 255 , ğ‘¢, ğ‘£ âˆˆ ğ‘† ğ’™
Where ğ¼â€² ğ‘¢, ğ‘£ = ğ¼ ğ‘¢, ğ‘£ + ğœ€ ğ‘¢, ğ‘£
, the increment ğœ€ ğ‘¢, ğ‘£
is added to each
point I(u,v) in support area S(x). Try to find smallest distortion Ïƒ ğœ€ ğ‘¢, ğ‘£ when
ğ· â€²(ğ‘¥, ğœ) < ğ‘‡ holds.
3.2 R-SURF:SURF Keypoints Removing Method
20
Original image
186 SURF keypoints
Processed image
122 SURF keypoints
R-SURF
â€¢ This algorithm causes very little distortion to image. In general, we only
remove some low-level, small-scale keypoints in the images to avoid
obvious distortion.
21
â€¢ Target system:
The target system VisualIndex is a MATLAB and VLFeat based 
simple image indexing engine, created by Andrea Vedaldi. 
https://github.com/vedaldi/visualindex
(codebook=10000ï¼Œimage database=flikr2500)
Query in target system
RMD with ten iterations 
Can bypass
VisualIndex
The system can be bypassed with removal algorithm, when query 
images contain small amount of keypoints.  
3.3 Evaluation: Removal
Query image
Search result
22
Query in target system
RMD with sixty iterations 
Can bypass
But cannot preserve utility
Query in target system
RMD with ten iterations 
Cannot bypass
VisualIndex
VisualIndex
Evaluation: Removal
Query image
Search result
Query image
Search result
23
In order to meet the utility-preserving requirement, keypoints
injection methods are introduced as well. Two problems are
needed to be addressed.
â€¢ Where to inject SIFT keypoints?
â€¢ Inject inside the original image directly
â€¢ Inject to a frame surrounding the image
â€¢ How to generate SIFT keypoints to be injected?
â€¢ Generate SIFT keypoints with IMD algorithm (the inverse 
operation of RMD)
â€¢ Construct a frame with malformed basic bricks
3.4 Keypoints Injection Method
24
IMD (Injection with Minimum local Distortion ) is the inverse operation of
RMD algorithm. It targets a collection of potential keypoints, assigning
location and scale information for each point randomly.
For each potential keypoint, the absolute of DOG-value |D(x)| is calculated.
If |D(x)| is smaller than the threshold C, a patch will be added upon the
original image to meet the threshold. The size and value of the patch is
calculated using scale information and Gaussian filter.
resultant image
Keypoints of resultant image
Keypoints of original image
IMD Algorithm
Introduced keypoints
25
IMD
Introduced keypoints
IMD image
Original image
Inject to a frame
26
To minimize the size of frame, we construct the frame with basic bricks to
generate keypoints as many as possible.
In order to know the visual feature of SIFT keypoints, we extract SIFT keypoints
as well as their surrounding regions from images, using K-means clustering
algorithm to obtain multiple centroids, and finally build grains based on the
result of clustering algorithm. We can see that a keypoint generates where there
is an edge or corner.
One cluster of k-means
A kind of grain is build. The contrast of grain should be changed to meet different SIFT 
threshold. Keypoints are generated as many as possible.
Keypoints visualization
grain
Basic Bricks
27
Query in target system
IMD inside image
Can bypass
VisualIndex
Query image
Search result
The system can be bypassed with injection algorithm, when 
query images contain small amount of keypoints.  
3.5 Evaluation: Injection
Evaluation: Injection
28
Query in target system
IMD inside image
Cannot bypass
Query in target system
Inject frame (IMD)
Cannot bypass
VisualIndex
VisualIndex
Query image
Search result
Query image
Search result
Query in target system
RMD removal + basic bricks Injection
Query in target system
RMD removal + IMD Injection
29
This experiment shows that it is feasible to bypass 
VisualIndex system with removal and injection algorithms.  
VisualIndex
Query image
Search result
VisualIndex
Query image
Search result
3.6 Evaluation: Hybrid
â€¢ Challenge
â€¢ Unknown algorithm
â€¢ 0/1 feedback
â€¢ Our guess
â€¢ Google image retrieval system uses local descriptors 
such as SIFT/SURF.
â€¢ Bypassing strategy
â€¢ Removal only
â€¢ Injection only
â€¢ Hybrid: Combination of the above two methods 
30
4. Attacking Google Image Search Engine
31
For some images that contain very few keypoints, performing RMD 
with one iteration can bypass google image search engine successfully.
Original image
Adversarial  image
RMD with one iteration
Removal Only
32
Keypoints removal algorithms may cannot remove big-scale keypoints
without making unacceptable distortion. Experiment shows that if
leaving the big-scale keypoints unremoved, 10% of keypoints can lead
to correct searching results, due to the robustness of CBIR system.
RMD with one iteration
CANNOT bypass
RMD with five iterations
CAN bypass
Removal Only
Original image
33
Injection only strategy performs well on some simple images, however, as
the image on the right shows, sometimes â€˜injection onlyâ€™ strategy is useless
and unacceptable. On account of utility preserving, we should make the
adversarial image as natural as possible. Strategies â€˜Removal onlyâ€™ and
â€˜Injection onlyâ€™ may not meet this requirement sometimes. We should use a
hybrid strategy for better performance.
IMD on 50-pixel-wide frame
CANNOT bypass Google image search
IMD on 15-pixel-wide frame
CAN bypass Google image search
Injection Only
34
SIFT 
keypoints
visualization
SIFT keypoints
of original picture
Injected keypoints
Removed keypoints
New keypoints 
generated
RMD with one iteration + IMD on 15-pixel-wide frame
Hybrid: Combination of Removal and Injection
35
Matching images can be retrieved using original image
36
Successfully bypassing Google image search 
RMD with one iteration + IMD on 15-pixel-wide frame
37
Successfully bypassing Google image search 
RMD with one iteration + basic brick frame
38
Evasion
Search result: original image
Query image
39
Evasion
Adversarial image
No search result: evasion
Injected keypoints
Removed keypoints
â€¢ Source/target attack
â€¢ A source/target attack means to force the search result of an
adversarial image to be a specific target image.
40
â€¢ Source/target attacks will support more sophisticated attacks.
+ğœ€
adversarial image  xâ€™
Query image  x
specific target image y
Threat model
5. Discussion
41
Query in target system
Injected with keypoints from 
target image
â€¢ This experiment shows it is possible to achieve source/target 
attack by injecting keypoints from target image.  
â€¢ However, severe distortion is caused.
â€¢ We will seek for a better strategy in further study.
VisualIndex
Query image
Search result
Source/Target attacking demo
42
â€¢ In this work, we present
â€¢ A threat model of evading CBIR systems
â€¢ Several algorithms for removing/injecting keypoints
â€¢ Three bypassing strategies: removal only, injection only and
hybrid
â€¢ Evading VisualIndex system
â€¢ Evading Google Image Search Engine
â€¢ To conclude, our work proves the existence of threats to
CBIR systems and demonstrates that industrial-level image
search engines, such as Google Image Search, are prone to
be attacked with adversarial images.
6. Conclusion
THANKS!
Q&A