0.01679
0.0200
0.0342
30%
0.039
0.0467
0.0756
Table 2: Client and server running time (in seconds) for Shamir secret sharing/reconstruction and PRG expansion (AES in
counter mode), for different rates of dropouts. The setting is γ = 1/20, δ = 1/3, σ = 40, η = 30, and a semi-honest server. In this
setting the number of neighbors that provides security is is roughly 100 for all the values of n considered. We do not assume
any parallelization at the client (and thus all pairwise masks are computed sequentially). For the server we return the cost per
client. In particular, note that the cost per client of the server is two orders of magnitude smaller than the client cost. This is
because the client has to expand k ∼ 100 seeds in this setting, while the server only needs to obtain one self-mask per client.
We fixed l = 105 to ease the comparison with the experimental results in Bonawitz et al. [8]. It is easy to extrapolate costs w.r.t.
l, as the relationship is linear.
Session 4D: Distributed Protocols CCS '20, November 9–13, 2020, Virtual Event, USA1266Figure 3: Values of α as the number of neighbors increases, for n = 104.
Session 4D: Distributed Protocols CCS '20, November 9–13, 2020, Virtual Event, USA1267Algorithm 2: Abstract summation protocol.
Parties: Clients 1, . . . , n, and Server.
Public Parameters: Vector length l, input domain Xl , and PRG F : {0, 1}λ (cid:55)→ Xl
Input: (cid:174)xi ∈ Xl (by each client i).
Output: z ∈ X (for the server).
We denote by A1, A2, A′
those who finish step 5, and A3 those who finish step 7. For each Ai , A′
Thus, A1 ⊇ A′
1 ⊇ A2 ⊇ A′
(1) The server runs (G, t, k) = GenerateGraph(n), where G is a regular degree-k undirected graph with n nodes. By NG(i) we denote the set of k nodes
(2) Each client i generates key pairs (sk1
(3) Each client i:
• Generates a random PRG seed bi .
• Computes two sets of shares:
2, A3 the sets of clients that reach certain points without dropping out. Specifically A1 consists of the clients who finish step 3, A2
is the set of clients for which the server sees they have completed that step on time.
2 ⊇ A3 ⊇ A′
3.
i ) to the server who forwards the message to NG(i).
adjacent to i (its neighbors).
i ) and sends (pk1
i ), (sk2
i , pk1
i , pk2
i , pk2
i
• Sends to the server a message m = (j, ci, j), where ci, j = Eauth .Enc(ki, j, (i ||j ||hb
encrypted under ki, j = KA.Aдr ee(sk2
j ).
i , pk2
1| < (1 − δ)n and otherwise forwards all messages (j, ci, j) to client j, who deduces A′
1 ∩ NG(j).
i = {hb
H b
i = {hs
H s
i,1, . . . , hb
i,1, . . . , hs
i,k } = ShamirSS(t, k, bi)
i )
i,k } = ShamirSS(t, k, sk1
i, J )) for each j ∈ NG(i), where ci, j is a ciphertext
i, j ||hs
(4) The server aborts if |A′
(5) Each client i:
• Computes a shared random PRG seed si, j as si, j = KA.Aдr ee(sk1
• Sends to the server their masked input
j ).
i , pk1
(cid:174)yi = (cid:174)xi + (cid:174)ri − 
(cid:174)mi, j + 
(cid:174)mi, j
j∈A1∩NG(i)
0<j <i
j∈A1∩NG(i)
i <j≤n
(cid:32)

i∈A′
2
i


(cid:33)
(cid:174)mi, j
.
(cid:174)yi − (cid:174)ri +
(cid:174)mi, j −
j∈NG(i)∩(A′
0<j <i
1\A′
2)
j∈NG(i)∩(A′
i <j≤n
1\A′
2)
- where (cid:174)ri = F(bi) and (cid:174)mi, j = F(si, j).
every client i ∈ A′
2.
(6) The server collects masked inputs for a determined time period. It aborts if |A′
2| < (1 − δ)n and otherwise sends (A′
2) ∩ NG(i)) to
i, j)}i∈R1 ∪ {(i, hs
i, j)}i∈R2, obtained by decrypting the ciphertext ci, j received in Step 3.
(7) Each client j receives (R1, R2) from the server and sends {(i, hb
(8) The server aborts if |A′
sent by clients in A3. Then aborts if |Bi | < t and recovers bi and (cid:174)ri otherwise using
3| < (1 − δ)n and otherwise:
2 ∩ NG(i), (A1 \ A′
2, the set Bi of all shares in H b
i
the t shares received which came from the lowest client IDs.
• Collects, for each client i ∈ A′
• Collects, for each client i ∈ (A1 \ A′
2), the set Si of all shares in H s
sent by clients in A3. Then aborts if |Si | < t and recovers sk1
and (cid:174)mi, j
i
Outputs
otherwise.
i∈A′
2 (cid:174)xi as
Session 4D: Distributed Protocols CCS '20, November 9–13, 2020, Virtual Event, USA1268Algorithm 3: Summation protocol in the malicious setting.
Parties: Clients 1, . . . , n, and Server.
Public Parameters: Vector length l, input domain Xl , and PRG F : {0, 1}λ (cid:55)→ Xl .
Input: (cid:174)xi ∈ Xl (by each client i).
Output: z ∈ X (for the server).
We denote by A1, A2, A3 and A4 the sets of clients that send messages at the end of steps 6, 8, 11 and 13 of the protocol respectively. Then A′
i
clients whose messages reach the server on time. Note that [n] ⊇ A1, Ai ⊇ A′
Part I: public key commitments. In this part only, we assume the server to behave semi-honestly.
= (sk2
(1) Each client i generates key pairs K1
i
(2) The server commits to both vectors of public keys pk1 = (pk1
Part II: distributed graph generation. In these steps, the clients and server will jointly generate a directed graph G([n], E).
(3) Each client i selects k neighbors randomly by sampling without replacement k times from the set of all clients [n], and sends the resulting set N•→(i)
is the set of
2 is the set of clients who will be included in the final sum.
i ) to the server.
i ⊇ Ai +1 and A′
i , pk2
(4) The server sends(cid:16)
to the server. This set represents the “outgoing” neighbors of client i. We note that the choices made by all clients implicitly define a set of “ingoing”
neighbors for client i, denoted as N•←(i) ⊆ {i ∈ N•→(j) : j ∈ [n]} Denote N(i) = N•←(i) ∪ N•→(i).
(cid:17) to client i ∈ [n], together with |N(i)| log2(n) hashes for the Merkle tree verification.
i , pk2
i )i and pk2 = (pk2
i )i by means of a Merkle tree.
i ) and sends (pk1
N•←(i), (j, pk1
i ), K2
= (sk1
i , pk1
(5) Each client i aborts if the server is sending her more than 3k + k public keys. Otherwise, she verifies that the public keys sent by the server are
consistent with the Merkle tree root and that she has been given the public keys of everyone in N•→(i), and aborts otherwise.
j )j∈N(i)
j , pk2
, A′
i
i
i, j)) for each j ∈ N•→(i), where ci, j is a ciphertext
1| < (1 − δ)n, and otherwise forwards all messages (j, ci, j) to client j. We note that this essentially defines a set A2, j ⊆ N(j) of
i,1, . . . , hs
i,k } = ShamirSS(t, k, sk1
i ).
Part III: Masks generation and secret sharing.
(6) Each client i:
= {hb
i,k } = ShamirSS(t, k, bi) and H s
• Generates a random PRG seed bi .
• Computes two sets of shares H b
i
• Sends to the server messages mj = (j, ci, j), where ci, j = Eauth .Enc(ki, j, (i || j || hb
encrypted under ki, j = KA.Aдr ee(sk2
i,1, . . . , hb
j ).
i , pk2
the clients i from which client j received (j, ci, j).
• Decrypts all the ciphertexts received, and aborts if decryption fails.
• Computes a shared random PRG seed si, j as si, j = KA.Aдr ee(sk1
• Computes (cid:174)ri = F(bi) and (cid:174)mi, j = F(si, j) and computes their masked input (cid:174)yi = (cid:174)xi + (cid:174)ri −j∈A2,i
(7) The server aborts if |A′
(8) Each client i:
= {hs
i, j || hs
j ) with every j ∈ A2,i .
0<j <i
i , pk1
i
• Signs the message mi, j = (“included′′ || i || j ) with sk2
• Sends ((cid:174)yi, (mi, j, σ incl
i, j )j∈A2,i ) to the server.
i
to obtain a signature σ incl
i, j
for all j ∈ A2, j .
(cid:174)mi, j +j∈A2,i
i <j≤n
(cid:174)mi, j .
Part IV: Unmasking.
(9) If |A′
2| < (1 − δ)n, it aborts, and otherwise sends (A′
2 ∩ N•←(i), (A1 \ A′
2) ∩ N•←(i)) and all messages/signatures (mj,i, σ incl
j,i ) to every i ∈ A′
2. We note
that this essentially defines two sets Ab3,i, As3,i
(10) Each client checks that Ab3,i ∩ As3,i
(11) Each client i, for every j ∈ Ab3,i ⊆ N•←(i), signs a message mi, j = (“ack′′ || i || j) using sk2
3| < (1 − δ)n, and otherwise forwards all messages (j, mi, j, σi, j) to client j.
(12) The server aborts if |A′
(13) Each client collects all messages and signatures, and checks that all the signatures are valid using pk2
i
= ∅, Ab3,i, As3,i ⊆ N•←(i) ∩ A2,i , and that all signatures σ incl
i
of the clients j for every client i that received the message sent by the server.
are valid for j ∈ Ab3,i
j,i
, and send the signature (mi, j, σ ack
, and aborts otherwise.
i, j ) to the server.
(abort otherwise). Once client j receives p such
valid signatures from parties in N•→(j), she sends {(i, hb
4| < (1 − δ)n, and otherwise:
2, the set Bi of all shares in H b
i
shares received which came from the lowest client IDs.
(14) The server aborts if |A′
• Collects, for each i ∈ A′
• Collects, for each i ∈ A1 \ A′
Outputs
2, the set Si of all shares in H s
i
∪ {(i, hs
i, j)}i∈Ab3, j
sent by clients in A′
i, j)}i∈As3, j
4. It aborts if |Bi | < t and otherwise recovers bi and (cid:174)ri using the t
.
sent by clients in A′
4. It aborts if |Si | < t and recovers sk1
and (cid:174)mi, j otherwise.
i
(cid:32)
(cid:174)yi − (cid:174)ri + 

i∈A′
2
(cid:174)mi, j − 
(cid:33)
(cid:174)mi, j
.
j∈N(i)∩(A1\A′
2)
0<j <i
j∈N(i)∩(A1\A′
2)
i <j≤n
Session 4D: Distributed Protocols CCS '20, November 9–13, 2020, Virtual Event, USA1269