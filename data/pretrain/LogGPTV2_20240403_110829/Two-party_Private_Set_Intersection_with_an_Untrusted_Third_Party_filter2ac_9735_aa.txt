title:Two-party Private Set Intersection with an Untrusted Third Party
author:Phi Hung Le and
Samuel Ranellucci and
S. Dov Gordon
Two-party Private Set Intersection with an Untrusted Third Party
Phi Hung Le
PI:EMAIL
George Mason University
Fairfax, Virginia
Samuel Ranellucci∗
PI:EMAIL
Unbound Tech
Petach Tikva, Israel
S. Dov Gordon
PI:EMAIL
George Mason University
Fairfax, Virginia
ABSTRACT
We construct new protocols for two parties to securely compute
on the items in their intersection. Our protocols make use of an
untrusted third party that has no input. The use of this party allows
us to construct highly efficient protocols that are secure against a
single malicious corruption.
CCS CONCEPTS
• Security and privacy → Cryptography; Security services.
KEYWORDS
Private Set Intersection; Cryptography
ACM Reference Format:
Phi Hung Le, Samuel Ranellucci, and S. Dov Gordon. 2019. Two-party Pri-
vate Set Intersection with an Untrusted Third Party. In 2019 ACM SIGSAC
Conference on Computer and Communications Security (CCS ’19), November
11–15, 2019, London, United Kingdom. ACM, New York, NY, USA, 18 pages.
https://doi.org/10.1145/3319535.3345661
ACKNOWLEDGMENTS
This material is based upon work supported by the Defense Ad-
vanced Research Projects Agency (DARPA) and Space and Naval
Warfare Systems Center, Pacific (SSC Pacific) under Contract No.
N66001-15-C-4070.
1 INTRODUCTION
Secure multi-party computation protocols enable multiple distrust-
ing data holders, to jointly compute on their collected input, while
revealing nothing to any party other than the output. Many of the
foundational questions about secure computation were resolved
in the last century; in the last decade, a long line of research has
focused on concrete complexity, in an attempt to close the gap be-
tween the cost of computing on private data, and that of computing
in the clear. Today, a handful of companies across the world have
begun selling secure computation for a variety of applications1, and
Google claims to be using it in-house to perform set intersection,
helping advertisers to determine the efficacy of their ads [23].
∗This work was partially done at George Mason University and University of Maryland.
1Unbound Tech, Sharemind, and Partisia, to name a few.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’19, November 11–15, 2019, London, United Kingdom
© 2019 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-6747-9/19/11...$15.00
https://doi.org/10.1145/3319535.3345661
Protocols for secure computation can be categorized according
to various modeling parameters. Generally speaking, protocols
that are secure when a majority of parties are honest have much
lower bandwidth requirements than those that tolerate a malicious
majority. This makes the three-party setting for secure computation
especially appealing in real deployments: users can outsource their
private computation by secret sharing their input among three
servers, with a guarantee of security so long as at most one party
becomes malicious. Consequently, there has been a lot of recent
advancement in making three-party [2, 6, 14, 16, 25, 26] and four-
party [20] secure computation highly efficient in the face of a single
corruption. In the three-party setting, Furukawa et al. [16] require
just 10 bits of communication per party for each Boolean gate, Araki
et al. [1] require just 7, and in the four-party setting, Gordon et
al. [20] require just 1.5 bits of data. As a point of contrast, using
garbled circuits requires sending O(κ) bits per gate in the two-party
setting.
Most of the literature exploring the advantages of computing
in the three-party or four-party model have focused on generic
computation. (One important exception is the work of Kamara
et al. [26], which we discuss below.) However, certain problems
are important enough to warrant optimized protocols that out-
perform the generic solutions. Perhaps no single application has
received as much attention as private set intersection (PSI). In part,
undoubtedly, this is because PSI is such an important application.
But it is also a natural, simply stated problem that makes for the
perfect academic challenge: PSI protocols have been constructed
through polynomial interpolation [15], oblivious PRFs [28], public
key encryption [9], Bloom filters [12, 35], and cuckoo hashing
[33], to name just some of the results on PSI. At one point, it was
demonstrated that garbled circuits out-performed many of these
constructions in certain domains [22], but the research continued,
and the fastest PSI protocols are again custom constructions [28, 36].
While this focus on PSI is understandable, arguably it goes too
far in its lack of generality. While intersection is undoubtedly an im-
portant computation, one can easily imagine many scenarios where
it is only the first step in a broader computation. (Pinkas et al. [33]
provide a nice list of such examples.) A more general application,
which we call f (PSI), has received somewhat less attention. In this
application, the users wish to compute some arbitrary function f
over the intersection, revealing f (PSI), but not the items in the in-
tersection themselves. Motivated by the discussion described above,
we look at this problem while enlisting the help of an untrusted
third party: we assume that two parties each have large input sets,
and that a third party is available to help them compute. We allow
for the malicious corruption of at most one party. Taking two fur-
ther relaxations, in nearly all of our protocols we allow the third
party to learn the size of the intersection, and, although we assume
an honest majority among the three parties, we do not guarantee
Session 10C: Secret SharingCCS ’19, November 11–15, 2019, London, United Kingdom2403fairness: one of the parties might receive output and then choose
to abort the protocol before the others learn anything.
1.1 Contributions
We develop several new protocols related to private set intersection
and private set union, in the three-party model. Our protocols are
of two varieties: one group of protocols relies on polynomial inter-
polation, and the other relies on a mix of generic techniques, both
existing and new, for 3-party computation. Protocols using interpo-
lation require less communication, while those from circuits require
less local computation; we also construct a hybrid protocol that
leverages the advantages, and disadvantages, of both approaches.
We explore these tradeoffs experimentally.
Intersection cardinality. We design three new protocols for pri-
vately computing the cardinality of the set intersection. (Sections
3 and 4.1.) Note that this is a harder problem than PSI, since it
leaks strictly less information. These protocols serve as a building
block for some of our constructions of f (PSI), though, viewing
intersection cardinality as a particular f in the f (PSI) problem, we
see these results as independently interesting.
In the LAN setting, our circuit-based protocol improves on the
runtime of the 2-party protocol of De Cristefaro et al. [8] by 190-
1018X, but may need 3X more bandwidth. Our polynomial-based
protocol improves on their communication cost by more than 6X,
while improving the runtime by 20-26X. Our hybrid protocol im-
proves the runtime by 28-54X and requires 2X less bandwidth. In
WAN setting, the above protocols are faster than [8] 33-84X, 20-
25X, and 25-40X respectively. Compared with the generic merge-
compare-add protocol implemented with [1] in three-party setting,
if the indices have length σ = 80 bits, our circuit-based PSI-CA is
about 5X-25X faster in LAN, 5X-14X faster in WAN, and use 5X-35X
less bandwidth.
Computing functions of the intersection payload. We identify
an interesting restriction of f (PSI) in which the function f depends
only on the payload data, and not on the indices themselves. This is
a natural restriction and would arise, for example, when the indices
are unique record identifiers, such as social security numbers or
public keys. Interestingly, this restriction does not seem to help in
the 2-party setting.
Intuitively, to compute f on the z items in the intersection, the
parties need to learn which outputs from the intersection com-
putation should be “stitched” into the evaluation of f . Unless the
outputs are obliviously shuffled, which requires O(n log n) secure
swaps, the stitching leaks which elements are in the intersection.2
In the 3-party setting, the third party (P3) can help permute
the input arrays such that the intersection is at the front of the
array, and is easily stitched into the circuit computing f . One of our
technical contributions is a concretely efficient protocol, requiring
O(n) secure operations (and local sorting) for obliviously permuting
an array according to one party’s specified permutation (Section
4.3).
Computing functions of the intersection indices. Extending
the protocols that compute a function over the intersection payload,
2Orlandi et al. [7] and Pinkas et al. [33] propose a way around this problem. We briefly
discuss their approaches in Section 1.2.
we also design two protocols for computing on the indices (with
or without payload). Unfortunately, these constructions are quite
inefficient, and further work is required here. The more efficient
protocol requires non-black box access to a PRF. We instantiate this
with AES, and implement it. Despite the size of the AES circuit, we
still estimate that this will outperform existing constructions for
certain functions f , and for payloads greater than ≈ 160 bits.
Our second protocol makes black-box use of a two-party shared
oblivious prf (2soprf). This is a PRF in which the input can be secret
shared by two parties. We instantiated this using the 2soprf pro-
posed by Gordon et al. [19], but found that it performed worse than
the first protocol. However, we are hopeful that this instantiation
can be replaced by something more efficient, perhaps built from
OT extension. We leave this to future work.
1.2 Related work
PSI with an untrusted mediator. Kamara et al. [26] proposed the
same security model and constructed very efficient PSI protocols.
Our protocols also naturally cover the case of PSI, but we do not
claim this as a contribution, mainly because of their work. Their
protocols are faster than our own, when we restrict to computing
PSI. Unfortunately, there is no clear way to extend their results to
computing cardinality of the PSI or f(PSI). In their protocols, the
input parties use dummy elements, and duplicated inputs, to catch
a cheating server that tries to remove any records. To verify that
the server is honest, they reveal the intersection and verify that
all intersecting dummy elements have been included in the output.
This is perfectly fine when computing PSI but it reveals too much
when we want to compute PSI cardinality or f(PSI). We provide
several new, completely different approaches for enforcing honest
behavior by the server.
PSI with computation. Recently, Orlandi et al. [7] and Pinkas
et al. [32, 33] provide 2-party protocols for computing arbitrary
functions over the intersection. They both claim O(n) complexity
in the semi-honest setting. To avoid the issue we previously de-
scribed, which required the output of the intersection computation
to be obliviously shuffled, in these works they instead feed all 2n
values into the circuit for f , together with indicator bits that de-
note whether an item was in the intersection. Depending on f , this
might be a very reasonable solution: for example, if f is a simple
summation, then a linear-sized circuit can easily include exactly
the right items, using 1 multiplication for each indicator bit. How-
ever, for some functions this will result in the log n overhead that
we manage to avoid. For example, if f computes the median of
the intersecting items, the best oblivious construction we know of
requires O(n log n) gates.3 In our construction, since we only feed
t = |X ∩ Y| into the circuit for f , we would need only t log t gates
to complete the computation.
The protocol of Pinkas et al. is secure in the 2-party, semi-honest
setting, while ours is secure in the 3-party malicious setting, as-
suming an honest majority, so we are forced to compare apples
3We note that median is an example of a symmetric function. As Pinkas et al. [33]
point out, When avoiding the oblivious shuffle of the intersection, it is necessary
that f be a symmetric function, or the output of f may leak something about the
intersecting items. While this property is necessary for claiming security, the case of
median demonstrates that it might not be sufficient for claiming efficiency.
Session 10C: Secret SharingCCS ’19, November 11–15, 2019, London, United Kingdom2404to oranges.4 In their work, they provided experiment results for
PSI cardinality threshold (PSI-CAT), which has O(n) complexity.
We compare our PSI cardinality protocols with this (with the as-
sumption that their PSI-CA runtime would be similar to that of
PSI-CAT). Our circuit-based protocol is 4.4X-24X faster in LAN,
and 3.5X-9X faster in WAN while using 3.5X-25X less bandwidth
for n = 220, depending on the size of the intersection. We note that
we can choose the most efficient protocol for PSI-CA “on the fly”
after learning the intersection size. Also, the performance of their
protocol depends on the input length. The gap will be about 2.5X
wider if the input has variable length. The detailed comparison is
shown in Table 1.
On the other hand, when computing functions on the intersect-
ing indices, the comparison depends on the functionality and the
size of the payload. For f that requires only O(n) gates, their pro-
tocol is likely much faster than ours, due to our non-blackbox use
of AES. However, if f requires O(n log n) gates for them, and only
O(t log t) gates for us, then on payloads of about 160 bits, we will
become competitive.
Other related work. There are multiple works looking at intersec-
tion cardinality [8, 11, 15, 27]. These protocols are secure against one
malicious party in the two-party setting, however, they are very in-
efficient. In [8, 11], it takes more than an hour for two parties to find
the intersection cardinality for sets of size 220. Ion et al. compute
the sum of all items in the intersection [24]. Another application
that relates to f (PSI) is labeled-PSI [4], in which a sender sends a
label li to a receiver if the item xi is in the intersection. Labeled-PSI
is an efficient two-party protocol to perform computation over the
intersection in the asymmetric setting (a server has many items
and a client has few ones). However, labeled-PSI leaks the whole
intersection, which we aim not to do. It also would compare very
unfavorably in the symmetric setting, where input sets are roughly
the same size. Finally, their security model is incomparable, as they
are secure against a malicious receiver, but can only ensure privacy
against a malicious sender, while we assume an honest majority.
Finally, a crucial idea underlying all of our protocols is that, by
revealing a deterministic encryption of the input to a third party,
who can then compute the intersection from the encrypted values.
A similar approach was used in other settings for PSI [21, 26].
2 DEFINITIONS AND NOTATION
2.1 Security Definitions
We prove our protocols secure in the real/ideal paradigm, in the
stand-alone setting, and achieving security with abort. Formal defi-
nitions can be found in Goldreich [17]. Furthermore, in all of our
protocols, we allow P3 to learn the size of the intersection of the
input sets; this is reflected in our ideal functionalities. Of course, it
is possible to achieve fairness when only one out of three parties is
4If we choose to model each player becoming maliciously corrupt with independent
probability p, then the probability of 0 or 1 corruptions among 3 parties is strictly
smaller than the probability of 0 corruptions among 2 parties, which is needed in the
2-party, semi-honest setting. (Independence of the corruption events is not entirely
necessary for this argument, but some restriction on the corruption events is necessary.)
Although this is never explicitly modeled in the literature, it does provide a nice
justification, from a security stand point, for preferring the 3-party, malicious, honest-
majority assumption, over the 2-party, semi-honest assumption. Of course, this model
of corruption is not always reasonable, but it does seem to be implicitly used in many
real-world deployments, where the computing parties are operated by a single agency.
malicious, and revealing the intersection to P3 could be avoided as
well. However, these relaxations are important for achieving the
level efficiency that we demonstrate.
2.2 Secret Sharing
We use several different secret sharing schemes in our protocols.
In our constructions based on polynomial interpolation (Section 3),
we rely on Shamir secret sharing. In our circuit-based protocols of
Section 4.1, we use additive, 2-out-of-2 sharings of field elements,
and replicated secret sharing. The latter is a 2-out-of-3 secret shar-
ing scheme where, to share a field element x, 3 field elements are
selected at random, subject to x1 + x2 + x3 = x. Then, P1 is given
x1 and x2, P2 is given x2 and x3, and P3 is given x3 and x1. We will
move back and forth between these two sharing schemes, and we
will apply them both to binary values, as well as to larger fields.
Notation: we denote [x]A,[x]B as replicated arithmetic and bi-