more than 13 name servers in a referral response,
and less than one percent have more than 7. The
limitation should be a function of the level of the
zone and of the authoritative name server from
which the referral that creates the NS record arrives.
Thus, for an SLD zone, a default restriction of 4
might make sense. Investigating the exact limits
and eﬀects of this MaxBreadth proposal is beyond
the scope of the current paper.
5.2 MaxFetch(k)
We propose to amortize the resolution of multiple delega-
tions for a zone over multiple requests that use that zone,
one or a few (k) resolutions per request, rather than re-
solving all the delegations of the zone at once, when the
referral for the zone ﬁrst arrives. Thus, in general, in the
resolution of each client request, while using an already
resolved delegated name server, the resolver resolves the
IP address of an additional k delegated name servers to
be ready for future requests. This process continues until
all the delegations provided in a referral response are re-
solved. Several variations are possible in this scheme, for
example; start with k concurrent resolutions of referred
name server names upon receiving the ﬁrst referral re-
sponse within the resolution of a client request. Then, on
each subsequent client request that results in the same
referral, make one (or more) additional name server name
resolutions.
We modiﬁed the BIND 9.12.3 resolver algorithm to
implement MaxFetch(1). The max number of external
fetches (additional resolutions) we enforce at each level
is conﬁgurable. MaxFetch(k) allows the resolution of k
additional delegations that do not have an associated
IP address, per request. In MaxFetch(1), a resolver that
uses a zone z while resolving a request checks whether
there are unresolved delegations for z in z’s NS record.
If such a delegation is found, the resolver initiates its
resolution, while continuing in parallel the resolution of
the original request, using an already resolved delegate
for zone z. Note that the ﬁrst request that uses zone
z (which has also received the corresponding referral
response) may have to wait for the resolution of the ﬁrst
delegate if all of them came without a glue record in
the referral response (or all are out-of-bailiwick). In this
case the second request that uses zone z will use the
same delegate as used by the ﬁrst one (one may consider
resolving two delegations in the ﬁrst request, something
we have not tested).
It is important to note that MaxFetch(1) does not
negatively aﬀect the latency of a request resolution (see
latency analysis in §5.3 and §5.4), nor does it disturb
the RTT estimation algorithms (such as sRTT). Most
recursive resolvers perform latency-wise algorithms to
decide which server to query next. However, MaxFetch(1)
does not disrupt these algorithms because it allows a
resolution of an additional name server that may be
selected in the next client request, and after enough re-
quests all the delegations are resolved. The resolution of
an additional name server does not add to the latency of
a response since each request, except the ﬁrst, uses a pre-
viously resolved name server while issuing the additional
resolution in parallel.
In the next sub-sections we evaluate and compare
the original BIND and MaxFetch(1). We focus on the
impact on the latency and the number of packets, per
client request, under normal traﬃc and under attack.
5.3 MaxFetch(1) evaluation under at-
tack
In Figure 7 (§4.1) we compare the PAF of the origi-
nal BIND to that of the MaxFetch(1) variant, during a
long-lived simulated NXNSAttack against an SLD vic-
tim. The blue line (−4−) shows that the MaxFetch(1)
enhancement avoids most of the additional resolutions,
since it initiates only two additional requests, one IPv4
and one IPv6 per reqest. Instead of 1,500,319 packets
exchanged by the original BIND recursive resolver (as a
result of 10,000 malicious client requests), MaxFetch(1)
exchanges only 60,061 packets (the measured Mac1Fetch
PAF is reduced from 75x to 3x).
We also repeated the stress tests as in §4.5 to measure
the maximal number of client queries per second that
the BIND resolver is able to sustain under the NXNSAt-
tack with and without MaxFetch(1). As seen in Table 4,
BIND with MaxFetch(1) is capable of processing many
642    29th USENIX Security Symposium
USENIX Association
Max requests/sec
Avg. Latency (ms)
Median Latency (ms)
std Latency
Orig Bind 9.12.3
932
4.31
4
4.51
MaxFetch(1)
3390
1.32
1
1.37
Table 4: Comparing BIND resolver performance under
the NXNSAttack with and without MaxFetch(1).
more attack requests, 3,390 vs. 932 under the NXNSAt-
tack (and 3708 orig. BIND under the NXDomain attack
§4.5). We also compared the latency of attack requests
with and without MaxFetch(1). The latency values are
observed at the attacker client, which that generates re-
quests during a simulation of the NXNSAttack against
an SLD victim in our testbed. As seen in Table 4, the
average, median, and std latency, under attack, are much
better with MaxFetch(1) than without.
5.4 MaxFetch(1) in normal operation
Here we evaluate the recursive resolver operation in
practice, with and without MaxFetch(1) under normal
operation (without an attack). We measure (i) the la-
tency of client queries and (ii) the number of IPv4 pack-
ets processed by the resolver in the resolution process.
The purpose is twofold: ﬁrst, we wish to verify that the
MaxFetch(1) modiﬁcation does not incur query delays
or resolution failures (i.e., the number of SERVFAIL and
NOERROR responses is not higher than that observed
in the original BIND). Second, we wish to measure the
impact of the Out-of-Bailiwick overhead on the recursive
resolver under normal operation, to determine whether
the cache mitigates this overhead over time.
5.4.1 Datasets
Two datasets are used to study the normal operation of
a BIND resolver:
Dataset A: A list of the top million domains [21].
Here we executed DNS ‘A’ requests (IPv4 resolution) for
the ﬁrst 100,000 domains in this list.
Dataset B: Campus DNS trace. A 24-hour trace
of live DNS traﬃc observed on a campus DNS server.
Out of the 1,027,359 queries to domains that do not
reside within the campus zone, we took the 386,736 ‘A’
queries, with 10,092 unique ones.
Ethical Consideration: Dataset B is a sequence of
DNS queries with their timestamps but without the IP
addresses that originated them.
With each dataset, we send its query stream (100,000
queries in Dataset A, and 386,736 queries in Dataset B)
to both original BIND and BIND with MaxFetch(1). The
1GB resolvers’ cache is empty at the beginning of each
Resolver
Impl.
Total Req.
Unique Req.
Total recur-
sion packets
NOERROR
SERVFAIL
NXDOMAIN
Latency (ms)
Mean
Median
Std
Dataset A
(100K top domains)
Original Max-
BIND
100,000
100,000
747,494
Fetch(1)
100,000
100,000
650,864
Dataset B
(Campus trace)
Max-
Fetch(1)
386,691
10,092
422,946
Original
BIND
386,691
10,092
454,032
363028
18911
4752
41.50
13
101.03
363031
18910
4750
40.97
13
95.81
157.37
53
298.63
155.95
52
293.37
Table 5: Comparing original BIND and BIND with
MaxFetch(1) during the resolution of the query streams
in Datasets A and B.
experiment, and it can store all the responses received
in each experiment. We record the traﬃc between the
recursive resolver and the authoritative hierarchy, as well
as collecting the BIND statistics.
5.4.2 Results
Resolution overhead. We start by measuring the drop
in resolution cost introduced by Max1Fetcch in normal
operation (see §2.2). Figure 8 and the fourth row (Total
recursion packets) in Table 5 show the number of packets
processed by the recursive resolver (with and without
MaxFetch(1)) in each of the datasets. Using original
BIND, the resolver exchanges 14.84% more packets in
the resolution of the queries in Dataset A than it does
using the MaxFetch(1) variant (747,494 vs. 650,864). Sim-
ilarly, for Dataset B (campus DNS trace), original BIND
exchanges 7.34% more packets (454,032 vs. 422,946).
As seen by the green overhead lines (−(cid:5)−) in Figures
8a and 8b, MaxFetch(1) saves more than 50% of the
resolution cost in the ﬁrst 1000 requests, when the cache
has not yet ﬁlled up. The lines show the resolution drop
−1)·100). The gap
in percentages, ((
decreases as more requests are processed and the cache is
ﬁlled up with name server resolutions that are shared by
multiple requests. After 20K requests, the gap remains
stable at around 15% for Dataset A, and 7% for Dataset
B. Furthermore, MaxFetch(1) does not result with more
SERVFAIL, NOERROR, or NXDOMAIN than original
BIND in the resolution of the 386,691 queries in Dataset
B (Fifth row in Table 5).
P acketsM axF etch(1)
P acketsorig
Latency. The last row in Table 5 shows the average,
median and std latency, in both data sets, with and
without MaxFetch(1). The response time is slightly faster
using MaxFetch(1): 157.37ms using original BIND vs.
155.95ms using MaxFetch(1) in Dataset A (top domains),
and 41.5ms vs. 40.97ms in Dataset B (campus trace).
Note that in Dataset B, most queries are served by the
USENIX Association
29th USENIX Security Symposium    643
747,494
650,864
600,000
500,000
400,000
s
t
e
k
c
a
P
4
v
P
I
f
o
r
e
b
m
u
N
300,000
200,000
100,000
0
0
Original BIND
MaxFetch(1)
Overhead (%)
Original BIND
Original BIND
MaxFetch(1)
MaxFetch(1)
Overhead in %
60
50
40
30
20
14.8
10
%
n
i
d
a
e
h
r
e
v
O
454,032
422,946
400,000
300,000
200,000
100,000
s
t
e
k
c
a
P
4
v
P
I
f
o
r
e
b
m
u
N
20,000
40,000
60,000
80,000
Requests
(a) 100K Top Domains
0
1 · 105
0
0
1 · 105
2 · 105
Requests
3 · 105
(b) Campus 1-Day Trace
60
50
40
30
20
)
%
(
d
a
e
h
r
e
v
O
7.3410
0
Figure 8: The number of recursion packets exchanged by a BIND resolver (with and without MaxFetch(1)) in the
resolution of Dataset A and B query streams. The green line (−(cid:5)−) shows the overhead that is relative to MaxFetch(1).
F
D
C
1
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
F
D
C
1
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
Original BIND
MaxFetch(1)
Original BIND
MaxFetch(1)
0
1,000 2,000 3,000 4,000 5,000
Latency (ms)
0
1,000 2,000 3,000 4,000 5,000
Latency (ms)
(a) 100K top domains
(b) Campus trace
Figure 9: Latency of queries in Datasets A and B: Com-
parison between original BIND and MaxFetch(1).
resolver cache because not all the requests are unique.
Thus, when calculating the average, median and std
calculations, we exclude queries with zero latency (we
consider only 114,570 out of 386,691 queries).
Figures 9a shows the cumulative distribution of the
queries’ latency values for Dataset A, with and without
MaxFetch(1), and Figure 9b shows the same for Dataset
B. The latency values for both datasets with and with-
out MaxFetch(1) are between 0 and 5 seconds. In both
datasets, the original BIND and MaxFetch(1), the CDF
lines overlap, exhibiting a nearly identical distribution.
The 99th percentile latency distribution in Dataset