# CVE-2020-14644：weblogic iiop反序列化漏洞分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
作者：ph4nt0mer@360CERT
## 0x01 weblogic 受影响版本
Oracle WebLogic Server 12.2.1.3.0, 12.2.1.4.0, 14.1.1.0.0
## 0x02 环境准备
1、安装weblogic server版本。
安装weblogic_server可以参考``。
2、生成wlfullclient.jar包
wlfullclient可以通过，在安装完weblogic服务以后，来到`~/Oracle/Middleware/Oracle_Home/wlserver/server/lib`目录，运行`java
-jar
~/Oracle/Middleware/Oracle_Home/wlserver/modules/com.bea.core.jarbuilder.jar`，就会在lib目录下生成一个wlfullclient.jar包。这个wlfullclient.jar包包含了weblogic的基本所有功能类。
3、在IDEA新建一个工程文件。把coherence.jar包和wlfullclient.jar包放在同一个目录下，同时添加到库里。
## 0x03 反序列化gadget分析。
这次iiop的关键反序列化类是`RemoteConstructor`。代码如下：
    //
    // Source code recreated from a .class file by IntelliJ IDEA
    // (powered by FernFlower decompiler)
    //
    package com.tangosol.internal.util.invoke;
    import com.tangosol.io.ClassLoaderAware;
    import com.tangosol.io.ExternalizableLite;
    import com.tangosol.io.SerializationSupport;
    import com.tangosol.io.Serializer;
    import com.tangosol.io.SerializerAware;
    import com.tangosol.io.pof.PofReader;
    import com.tangosol.io.pof.PofWriter;
    import com.tangosol.io.pof.PortableObject;
    import com.tangosol.util.Base;
    import com.tangosol.util.ExternalizableHelper;
    import java.io.DataInput;
    import java.io.DataOutput;
    import java.io.IOException;
    import java.io.ObjectStreamException;
    import java.io.Serializable;
    import java.util.Arrays;
    import javax.json.bind.annotation.JsonbProperty;
    public class RemoteConstructor implements ExternalizableLite, PortableObject, SerializationSupport, SerializerAware {
        @JsonbProperty("definition")
        protected ClassDefinition m_definition;
        @JsonbProperty("args")
        protected Object[] m_aoArgs;
        private transient Serializer m_serializer;
    protected transient ClassLoader m_loader;
        public RemoteConstructor() {
    }
        public RemoteConstructor(ClassDefinition definition, Object[] aoArgs) {
    this.m_definition = definition;
            for(int i = 0; i  that = (RemoteConstructor)o;
                return this == that || this.getClass() == that.getClass() && Base.equals(this.m_definition, that.m_definition) && Base.equalsDeep(this.m_aoArgs, that.m_aoArgs);
            }
    }
        public int hashCode() {
            int nHash = this.m_definition.hashCode();
            nHash = 31 * nHash + Arrays.hashCode(this.m_aoArgs);
            return nHash;
    }
        public String toString() {
            return "RemoteConstructor{definition=" + this.m_definition + ", arguments=" + Arrays.toString(this.m_aoArgs) + '}';
    }
        public void readExternal(DataInput in) throws IOException {
            this.m_definition = (ClassDefinition)ExternalizableHelper.readObject(in);
    Object[] aoArgs = this.m_aoArgs = new Object[ExternalizableHelper.readInt(in)];
            for(int i = 0; i  {
                return new Object[x$0];
            });
    }
        public void writeExternal(PofWriter out) throws IOException {
            out.writeObject(0, this.m_definition);
            out.writeObjectArray(1, this.m_aoArgs);
    }
        public Object readResolve() throws ObjectStreamException {
            return this.newInstance();
    }
        public Serializer getContextSerializer() {
            return this.m_serializer;
    }
        public void setContextSerializer(Serializer serializer) {
            this.m_serializer = serializer;
            if (serializer instanceof ClassLoaderAware) {
                this.m_loader = ((ClassLoaderAware)serializer).getContextClassLoader();
    }
        }
    }
`RemoteConstructor`实现了`ExternalizableLite`接口，`ExternalizableLite`接口继承了`Serializable`，所以这个`RemoteConstructor`类是可以进行序列化的。
该类里没有readobject函数，但有readResolve函数。详细了解可以参考``
目前总结如下：
  * 必须实现Serializable接口或Externalizable接口的类才能进行序列化
  * transient和static修饰符修饰的成员变量不会参与序列化和反序列化
  * 反序列化对象和序列化前的对象的全类名和serialVersionUID必须一致
  * 在目标类中添加私有的writeObject和readObject方法可以覆盖默认的序列化和反序列化方法
  * 在目标类中添加私有的readResolve可以最终修改反序列化回来的对象，可用于单例模式防止序列化导致生成第二个对象的问题
readResolve操作是在readobject后面，所以readResolve会覆盖readobject的内容。
查看下readResolve函数的内容：
    public Object readResolve() throws ObjectStreamException {
            return this.newInstance();
        }
    public T newInstance() {
            RemotableSupport support = RemotableSupport.get(this.getClassLoader());
            return support.realize(this);
    }
getClassLoader()代码：
        protected ClassLoader getClassLoader() {
            ClassLoader loader = this.m_loader;
            return loader == null ? Base.getContextClassLoader(this) : loader;
    }
根据RemoteConstructor的构造函数可知。我们先写个大框架：
    public class App2 {
        public static void main(String[] args) throws NotFoundException, IOException, CannotCompileException {
            /*ClassIdentity classIdentity = new ClassIdentity(
                    org.iiop.test1.class
    );*/
            RemoteConstructor remoteConstructor = new RemoteConstructor(
                    new ClassDefinition(),
                    new Object[]{}
    );
    byte[] serialize= Serializables.serialize(remoteConstructor);
            try {
                Serializables.deserialize(serialize);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
    }
        }
    }
因为this.m_loader是transient修饰的，所以loader会是null，返回的是Base.getContextClassLoader(this)。
看下RemotableSupport里面的realize方法：
    public  T realize(RemoteConstructor constructor) {
            ClassDefinition definition = this.registerIfAbsent(constructor.getDefinition());
            Class clz = definition.getRemotableClass();
            if (clz == null) {
                synchronized(definition) {
                    clz = definition.getRemotableClass();
                    if (clz == null) {
                        definition.setRemotableClass(this.defineClass(definition));
                    }
                }
    }
            Remotable instance = (Remotable)definition.createInstance(constructor.getArguments());
            instance.setRemoteConstructor(constructor);
            return instance;
    }
第一张图片的报错是在registerIfAbsent方法里，因为ClassDefinition我们定义的是空，所以取到definition.getId()为null。
    protected ClassDefinition registerIfAbsent(ClassDefinition definition) {
    assert definition != null;
            ClassDefinition rtn = (ClassDefinition)this.f_mapDefinitions.putIfAbsent(definition.getId(), definition);
            return rtn == null ? definition : rtn;
    }
然后导致(ClassDefinition)this.f_mapDefinitions.putIfAbsent(definition.getId(),
definition)报错了
那我们接着看一下ClassDefinition是做啥的，必须给他一个初始化有值的对象，代码如下:
    //
    // Source code recreated from a .class file by IntelliJ IDEA
    // (powered by FernFlower decompiler)
    //
    package com.tangosol.internal.util.invoke;
    import com.tangosol.io.ExternalizableLite;
    import com.tangosol.io.pof.PofReader;
    import com.tangosol.io.pof.PofWriter;
    import com.tangosol.io.pof.PortableObject;
    import com.tangosol.util.Base;
    import com.tangosol.util.ClassHelper;
    import com.tangosol.util.ExternalizableHelper;
    import java.io.DataInput;
    import java.io.DataOutput;
    import java.io.File;
    import java.io.FileOutputStream;
    import java.io.IOException;
    import java.io.OutputStream;
    import java.lang.invoke.MethodHandle;
    import java.lang.invoke.MethodHandles;
    import java.lang.invoke.MethodType;
    import java.lang.reflect.Constructor;
    import java.lang.reflect.InvocationTargetException;
    import javax.json.bind.annotation.JsonbProperty;
    public class ClassDefinition implements ExternalizableLite, PortableObject {
        protected transient Class m_clz;
        protected transient MethodHandle m_mhCtor;
        @JsonbProperty("id")
        protected ClassIdentity m_id;
        @JsonbProperty("code")
    protected byte[] m_abClass;
        public ClassDefinition() {
    }
        public ClassDefinition(ClassIdentity id, byte[] abClass) {
            this.m_id = id;
            this.m_abClass = abClass;
            String sClassName = id.getName();
            Base.azzert(sClassName.length()  getRemotableClass() {
            return this.m_clz;
    }
        public void setRemotableClass(Class clz) {
            this.m_clz = clz;
            Constructor[] aCtor = clz.getDeclaredConstructors();
            if (aCtor.length == 1) {
                try {
                    MethodType ctorType = MethodType.methodType(Void.TYPE, aCtor[0].getParameterTypes());
                    this.m_mhCtor = MethodHandles.publicLookup().findConstructor(clz, ctorType);
                } catch (IllegalAccessException | NoSuchMethodException var4) {
                    throw Base.ensureRuntimeException(var4);
                }
    }
    }
        public Object createInstance(Object... aoArgs) {
            try {
                return this.getConstructor(aoArgs).invokeWithArguments(aoArgs);
            } catch (NoSuchMethodException var10) {
                Constructor[] aCtors = this.m_clz.getDeclaredConstructors();
                Constructor[] var4 = aCtors;
    int var5 = aCtors.length;
                for(int var6 = 0; var6 < var5; ++var6) {
                    Constructor ctor = var4[var6];
                    if (ctor.getParameterTypes().length == aoArgs.length) {
                        try {
                            return ctor.newInstance(aoArgs);
                        } catch (InvocationTargetException | IllegalAccessException | IllegalArgumentException | InstantiationException var9) {
                        }
                    }
    }
                throw Base.ensureRuntimeException(var10);
            } catch (Throwable var11) {
                throw Base.ensureRuntimeException(var11);
            }
    }
        protected MethodHandle getConstructor(Object[] aoArgs) throws NoSuchMethodException {
            if (this.m_mhCtor != null) {
                return this.m_mhCtor;
            } else {
    Class[] aParamTypes = ClassHelper.getClassArray(aoArgs);
                try {
                    MethodType ctorType = MethodType.methodType(Void.TYPE, ClassHelper.unwrap(aParamTypes));
                    return MethodHandles.publicLookup().findConstructor(this.m_clz, ctorType);
                } catch (NoSuchMethodException var6) {
                    try {
                        MethodType ctorType = MethodType.methodType(Void.TYPE, aParamTypes);
                        return MethodHandles.publicLookup().findConstructor(this.m_clz, ctorType);
                    } catch (IllegalAccessException var5) {
                        throw Base.ensureRuntimeException(var5);
                    }
                } catch (IllegalAccessException var7) {
                    throw Base.ensureRuntimeException(var7);