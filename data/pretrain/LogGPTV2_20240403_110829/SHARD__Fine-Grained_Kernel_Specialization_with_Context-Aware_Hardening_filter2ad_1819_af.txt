to valid targets. Previous work has applied CFI to protect
privileged software, including kernels and hypervisors. Hy-
perSafe [56] applies CFI to hypervisors. For CFI enforcement,
they introduce a lightweight Restricted Pointer Indexing (RPI)
approach. SHARD proposes a modiﬁed implementation of
RPI which is compatible with function addresses.
KGuard [34] protects the kernel against return-to-user at-
tacks by ensuring indirect control-ﬂow transfers in the kernel
cannot target user space addresses. KCoFI [26] uses the se-
cure virtual architecture (SVA) [27] to enforce CFI on the
system’s kernel. However, their implementation incurs a high
overhead, exceeding 100% in some scenarios. Furthermore,
Ge et al. [29] apply ﬁne-grained CFI to kernel software by
using RPI. The instrumentation causes a high overhead of up
to 50%. While SHARD’s implementation of CFI is similar, it
introduces a modiﬁed RPI instrumentation, compatible with
function addresses, which allows near-native non-hardened
execution. Additionally, SHARD enforces strict debloating,
which completely removes many vulnerabilities; thereby, pre-
venting a wide-range of attacks with a low overhead, unlike
CFI-only schemes.
Specialized kernel hardening. To the best of our knowl-
edge, the Split-Kernel [39] technique is the only previous
effort in specialized kernel hardening. Both Split-Kernel and
SHARD implement selective hardening of kernel execution
by providing different kernel views to applications based on
whether they are trusted or not. However, a major difference is
that Split-Kernel fully hardens the kernel view (using coarse-
CFI) of untrusted applications, which incurs a high overhead
(40% on average on a web server). In contrast, SHARD avoids
this overhead by hardening only potentially reachable code
paths while allowing reachable code to execute unrestricted.
13 Conclusion
This paper presents SHARD, a run-time ﬁne-grained kernel
specialization system that combines debloating with context-
aware hardening to prevent kernel attacks. SHARD achieves
an order of magnitude higher attack surface reduction than
Figure 14: The performance overhead of Redis when the sys-
tem is proﬁled with complete (SHARD) and partial set of
redis-benchmark (SHARD-Profpart).
payload directly with context-aware CFI (due to SHARD’s
hardening and debloating), the attacker can potentially make
a malicious update to a function pointer and trick trusted ap-
plications (for which the kernel is not hardened or debloated
by SHARD) to use the malicious function pointer. Although
possible, we expect such attacks to be signiﬁcantly difﬁcult
to perform for several reasons. In particular, the untrusted ap-
plication is sandboxed (refer to §5); therefore, its interactions
with the outside world are rigorously controlled. Furthermore,
the attacker must both know the system call semantics of a
trusted application and be able to trick the application to use
the malicious function pointer in a speciﬁc scenario to con-
duct such attacks. We leave the investigation of these attacks
to future work.
Moreover, other techniques can be applied to the kernel
with SHARD to provide alternative or complementary context-
aware hardening protection. For example, stack exhaustion
and stack clearance checks can be applied to prevent attacks
through the kernel’s stack. These techniques, unlike CFI, are
not subject to the limitations of selective hardening [39].
12 Related Work
Dynamic kernel debloating. SHARD is most closely re-
lated to previous work in application-driven, run-time ker-
nel (debloating-based) specialization [30, 36, 62]. However,
compared to these schemes, SHARD signiﬁcantly reduces the
attack surface by specializing at both the application and sys-
tem call levels and strictly enforces debloating.
Static kernel debloating. Static, conﬁguration-based spe-
cialization [37, 38, 53] is another approach for kernel min-
imization. Since such techniques statically determine the
kernel-view, they provide good performance but with lower se-
curity guarantees (e.g., larger attack surface and/or non-strict
enforcement).
Application specialization. Specializing of applications has
been explored extensively, including for debloating purposes.
Trimmer [50] employs static analysis techniques to identify
reachable application code with respect to a particular user-
INCRSADDSPOPRPOPSETRPUSHMSET0510152025Overhead(%)SHARDSHARD-Profpartprior work and implements strict enforcement. Furthermore,
SHARD incurs an overhead of only 3-10% on Redis, 10-36%
on NGINX, and 0-2.7% on the SPEC CPU benchmarks.
Acknowledgement
We thank our shepherd, Vasileios Kemerlis, and the anony-
mous reviewers for their valuable comments and suggestions.
We also thank Mathias Payer for earlier discussion on soft-
ware debloating and hardening. This work was supported in
part by ONR under Grant N00014-17-1-2513. Any opinions,
ﬁndings, and conclusions in this paper are those of the authors
and do not necessarily reﬂect the views of the ONR.
References
[1] ab -
apache
tool.
https://httpd.apache.org/docs/2.4/programs/
ab.html/.
server benchmarking
http
[2] Amd64 architecture programmer’s manual vol-
ume 3: General-purpose and system instructions.
https://www.amd.com/system/files/TechDocs/
24594.pdf.
[3] Cve-2017-10661 detail.
https://nvd.nist.gov/
vuln/detail/CVE-2017-10661.
[4] Cve-2017-11176 detail.
https://nvd.nist.gov/
vuln/detail/CVE-2017-11176.
[5] Cve-2017-17052 detail.
https://nvd.nist.gov/
vuln/detail/CVE-2017-17052.
[6] Cve-2017-17052 detail.
https://nvd.nist.gov/
vuln/detail/CVE-2018-10880.
[7] Cve-2017-5123.
https://security.archlinux.
org/CVE-2017-5123.
[8] Cve-2017-7308 detail.
https://nvd.nist.gov/
vuln/detail/CVE-2017-7308.
[9] Cve-2018-17182 detail.
https://nvd.nist.gov/
vuln/detail/CVE-2018-17182.
[10] Cve-2018-7480 detail.
https://nvd.nist.gov/
vuln/detail/CVE-2018-7480.
[11] Cve-2019-20054 detail.
https://nvd.nist.gov/
vuln/detail/CVE-2019-20054.
[12] Jonathansalwan/ropgadget.
https://github.com/
JonathanSalwan/ROPgadget.
[13] L1 terminal fault / cve-2018-3615 , cve-2018-3620,cve-
https://software.
2018-3646 /
intel.com/security-software-guidance/
software-guidance/l1-terminal-fault.
intel-sa-00161.
[14] The linux kernel enters 2020 at 27.8 million
lines in git but with less developers for 2019.
https://www.phoronix.com/scan.php?page=
news_item&px=Linux-Git-Stats-EOY2019#:~:
text=The%20Linux%20Kernel%20Enters%202020,
Less%20Developers%20For%202019%20%2D%
20Phoronix&text=As%20of%20this%20morning%
20in,in%20at%2027.8%20million%20lines!
[15] Linux kernel grows past 15 million lines of
https://www.tomshardware.com/news/
code.
Linux-Linus-Torvalds-kernel-too-complex-code,
14495.html.
[16] Nginx | high performance load balancer, web server,
view-source:https://www.
amp; reverse proxy.
nginx.com/.
[17] Redis. redis.io.
[18] Vulnerability details : Cve-2016-0728. https://www.
cvedetails.com/cve/CVE-2016-0728/.
[19] wrk - a http benchmarking tool. https://github.
com/wg/wrk.
[20] M. Abadi, M. Budiu, Ú. Erlingsson, and J. Ligatti.
Control-ﬂow integrity principles, implementations, and
applications. ACM Transactions on Information and
System Security (TISSEC), 2009.
[21] B. A. Azad, P. Laperdrix, and N. Nikiforakis. Less is
more: Quantifying the security beneﬁts of debloating
web applications. In Proceedings of the 28th USENIX
Security Symposium (Security), 2019.
[22] J.-J. Bai, J. Lawall, Q.-L. Chen, and S.-M. Hu. Effec-
tive static analysis of concurrency use-after-free bugs in
linux device drivers. In Proceedings of USENIX Annual
Technical Conference (ATC), 2019.
[23] T. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang. Jump-
oriented programming: a new class of code-reuse attack.
In Proceedings of the 6th ACM Symposium on Infor-
mation, Computer and Communications Security, pages
30–40, 2011.
[24] N. Burow, X. Zhang, and M. Payer. Shining light on
shadow stacks. arXiv preprint arXiv:1811.03165, 2018.
[25] N. Burow, X. Zhang, and M. Payer. Sok: Shining light
on shadow stacks. In 2019 IEEE Symposium on Security
and Privacy (SP), pages 985–999, 2019.
[26] J. Criswell, N. Dautenhahn, and V. Adve. Kcoﬁ: Com-
plete control-ﬂow integrity for commodity operating
system kernels. In Proceedings of IEEE Symposium on
Security and Privacy (S&P), 2014.
[27] J. Criswell, A. Lenharth, D. Dhurjati, and V. Adve. Se-
cure virtual architecture: A safe execution environment
for commodity operating systems. In Proceedings of the
21st ACM Symposium on Operating Systems Principles
(SOSP), 2007.
[28] T. H. Dang, P. Maniatis, and D. Wagner. The perfor-
mance cost of shadow stacks and stack canaries.
In
Proceedings of the 10th ACM Symposium on Informa-
tion, Computer and Communications Security, pages
555–566, 2015.
[29] X. Ge, N. Talele, M. Payer, and T. Jaeger. Fine-grained
control-ﬂow integrity for kernel software. In Proceed-
ings of the IEEE European Symposium on Security and
Privacy (EuroS&P), 2016.
[30] Z. Gu, B. Saltaformaggio, X. Zhang, and D. Xu. FACE-
CHANGE: application-driven dynamic kernel view
switching in a virtual machine. In Proceedings of the
44th Annual IEEE/IFIP International Conference on
Dependable Systems and Networks, (DSN), 2014.
[31] K. Heo, W. Lee, P. Pashakhanloo, and M. Naik. Effec-
tive program debloating via reinforcement learning. In
Proceedings of the ACM Conference on Computer and
Communications Security (CCS), 2018.
[32] Intel Corporation. Intel® 64 and IA-32 Architectures
Optimization Reference Manual. December 2016.
[33] K. K. Ispoglou, B. AlBassam, T. Jaeger, and M. Payer.
Block oriented programming: Automating data-only at-
tacks. In Proceedings of the 2018 ACM Conference on
Computer and Communications Security (CCS), 2018.
[34] V. P. Kemerlis, G. Portokalidis, and A. D. Keromytis.
kguard: lightweight kernel protection against return-to-
user attacks. In Proceedings of the 21st USENIX Secu-
rity Symposium (Security), 2012.
[35] A. Konovalov.
Blogger.
googleprojectzero.blogspot.com/.
https://
[36] H. Kuo, A. Gunasekaran, Y. Jang, S. Mohan, R. B.
Bobba, D. Lie, and J. Walker. Multik: A framework
for orchestrating multiple specialized kernels. CoRR,
abs/1903.06889, 2019.
[37] H.-C. Kuo, J. Chen, S. Mohan, and T. Xu. Set the con-
ﬁguration for the heart of the os: On the practicality
of operating system kernel debloating. Proceedings of
the ACM on Measurement and Analysis of Computing
Systems, 2020.
[38] A. Kurmus, R. Tartler, D. Dorneanu, B. Heinloth,
V. Rothberg, A. Ruprecht, W. Schröder-Preikschat,
D. Lohmann, and R. Kapitza. Attack surface metrics
and automated compile-time OS kernel tailoring. In Pro-
ceedings of the 20th Annual Network and Distributed
System Security Symposium (NDSS), 2013.
[39] A. Kurmus and R. Zippel. A tale of two kernels: To-
wards ending kernel hardening wars with split kernel.
In Proceedings of the ACM Conference on Computer
and Communications Security (CCS), 2014.
[40] P. Larson. Testing linux® with the linux test project. In
Ottawa Linux Symposium, page 265, 2002.
[41] C. Lattner and V. Adve. Llvm: A compilation frame-
work for lifelong program analysis & transformation.
In International Symposium on Code Generation and
Optimization, 2004. CGO 2004., pages 75–86. IEEE,
2004.
[42] K. Lu, A. Pakki, and Q. Wu. Detecting missing-check
bugs via semantic-and context-aware criticalness and
In Proceedings of the 28th
constraints inferences.
USENIX Security Symposium (Security), 2019.
[43] A. Lyashko. Hijack linux system calls: Part iii. system
call table. Blog] System Programming, Available at:.
[44] A. Machiry, C. Spensky, J. Corina, N. Stephens,
C. Kruegel, and G. Vigna. DRCHECKER: A soundy
analysis for linux kernel drivers. In Proceedings of the
26th USENIX Security Symposium (Security), 2017.
[45] D. Merkel. Docker: lightweight linux containers for
consistent development and deployment. Linux journal,
2014.
[46] C. Qian, H. Hu, M. Alharthi, P. H. Chung, T. Kim, and
W. Lee. RAZOR: A framework for post-deployment
software debloating. In 28th USENIX Security Sympo-
sium (USENIX Security 19), pages 1733–1750, Santa
Clara, CA, Aug. 2019. USENIX Association.
[47] A. Quach, A. Prakash, and L. Yan. Debloating software
through piece-wise compilation and loading. In 27th
USENIX Security Symposium (USENIX Security 18),
pages 869–886, 2018.
[48] D. Rosenberg. Anatomy of a remote kernel exploit,
2011.
[49] H. Shacham. The geometry of innocent ﬂesh on the
bone: Return-into-libc without function calls (on the
x86). In Proceedings of the 14th ACM conference on
Computer and communications security, pages 552–561,
2007.
[50] H. Sharif, M. Abubakar, A. Gehani, and F. Zaffar. Trim-
mer: application specialization for code debloating. In
Proceedings of the 33rd ACM/IEEE International Con-
ference on Automated Software Engineering, pages 329–
339, 2018.
[51] L. Szekeres, M. Payer, L. T. Wei, and R. Sekar. Eternal
war in memory. In Proceedings of the IEEE Symposium
on Security & Privacy (S&P), 2014.
[52] R. Ta-Min, L. Litty, and D. Lie. Splitting interfaces:
Making trust between applications and operating sys-
tems conﬁgurable. In Proceedings of the 7th sympo-
sium on Operating Systems Design and Implementation
(OSDI), 2006.
[53] R. Tartler, A. Kurmus, B. Heinloth, V. Rothberg,
A. Ruprecht, D. Dorneanu, R. Kapitza, W. Schröder-
Preikschat, and D. Lohmann. Automatic OS kernel
TCB reduction by leveraging compile-time conﬁgurabil-
ity. In Proceedings of the 8th Workshop on Hot Topics
in System Dependability, (HotDep), 2012.
[54] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway,
Ú. Erlingsson, L. Lozano, and G. Pike. Enforcing
forward-edge control-ﬂow integrity in GCC & LLVM.
In 23rd USENIX Security Symposium (USENIX Security
14), pages 941–955, 2014.
[55] W. Wang, K. Lu, and P.-C. Yew. Check it again: Detect-
ing lacking-recheck bugs in os kernels. In Proceedings
of the ACM Conference on Computer and Communica-
tions Security (CCS), 2018.
[56] Z. Wang and X. Jiang. Hypersafe: A lightweight ap-
proach to provide lifetime hypervisor control-ﬂow in-
tegrity. In Proceedings of the IEEE Symposium on Se-
curity and Privacy (S&P), 2010.
[57] Z. Wang, C. Wu, M. Xie, Y. Zhang, K. Lu, X. Zhang,
Y. Lai, Y. Kang, and M. Yang. Seimi: Efﬁcient and
secure smap-enabled intra-process memory isolation. In
2020 IEEE Symposium on Security and Privacy (SP),
pages 592–607, 2020.
[58] W. Wu, Y. Chen, X. Xing, and W. Zou. KEPLER: Fa-
cilitating control-ﬂow hijacking primitive evaluation for
linux kernel vulnerabilities. In Proceedings of the 28th
USENIX Security Symposium (Security), 2019.
[59] W. Wu, Y. Chen, J. Xu, X. Xing, X. Gong, and W. Zou.
FUZE: Towards facilitating exploit generation for ker-
nel use-after-free vulnerabilities. In 27th USENIX Secu-
rity Symposium (USENIX Security 18), pages 781–797,
2018.
[60] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Or-
mandy, S. Okasaka, N. Narula, and N. Fullagar. Native
client: A sandbox for portable, untrusted x86 native code.
In Proceedings of the 30th IEEE Symposium on Security
and Privacy (S&P), 2009.
[61] T. Zhang, W. Shen, D. Lee, C. Jung, A. M. Azab, and
R. Wang. Pex: A permission check analysis framework
for linux kernel. In Proceedings of the 28th USENIX
Security Symposium (Security), 2019.
[62] Z. Zhang, Y. Cheng, S. Nepal, D. Liu, Q. Shen, and
F. A. Rabhi. KASR: A reliable and practical approach
to attack surface reduction of commodity OS kernels.
In Proceedings of the 21st International Symposium on
Research in Attacks, Intrusions, and Defenses (RAID),
2018.
[63] Z. Zhou, M. K. Reiter, and Y. Zhang. A software ap-
proach to defeating side channels in last-level caches. In
Proceedings of the 23rd ACM Conference on Computer
and Communications Security (CCS), 2016.
[64] P. Zieris and J. Horsch. A leak-resilient dual stack
scheme for backward-edge control-ﬂow integrity. In
Proceedings of the 2018 on Asia Conference on Com-
puter and Communications Security, pages 369–380,
2018.