http://www.slideshare.net/kaigai/pgconfasia2016-plcuda
PL/CUDA
~Fusion of HPC Grade Power with In-Database Analytics~
The PG-Strom Project / NEC OSS Promotion Center
KaiGai Kohei 
自己绍介
▌KaiGai Kohei
 tw: @kkaigai
 https://github.com/kaigai
▌PostgreSQL
 SELinux, FDW, CustomScan, ...
▌PG-Strom
 GPUを用いたPostgreSQL向け
高速化モジュールの作者
▌お仕事
 NEC OSS推进センタ
 SW开発／ビジネス开拓
2 PGconf.ASIA - PL/CUDA / Fusion of HPC Grade Power with In-Database Analytics The PG-Strom Project
PG-Strom概要 (1/2) – アーキテクチャ
Application
No Query
Changes
 机能
• SQLからGPUコードを自动生成。
SQL Parser
• GPUによる非同期/超并列実行
Query
PG-Strom
• WHERE句、JOIN、GROUP BY、
Optimizer
Extension Projectionに対応
 利点
Query
Executor GPU • 数千演算コアを用いた透过的な
アクセラレーション
Storage Manager
• 解析系ワークロードに対する
低コストのソリューション
No Storage
Storage
Changes
3 PGconf.ASIA - PL/CUDA / Fusion of HPC Grade Power with In-Database Analytics The PG-Strom Project
GPU (Graphic Processor Unit) の特徴
GPU CPU
NVIDIA Intel Xeon
Model
Tesla P100 E5-2699v4
Architecture Pascal Broadwell
Launch Q2-2016 Q1-2016
# of transistors 15billion 7.2billion
3584 22
# of cores
(simple) (functional)
1.126GHz 2.20GHz
core clock
~1.303GHz ~3.60GHz
Perk FFLOPS 1.2 TFLOPS
9.3 TFLOPS
(FP32) (with AVX2)
DRAM Size 16GB (HBM2) max 1.5TB (DDR4)
Memory Band 732GB/s 76.8GB/s
Power
250W 145W
Consumption
4 PGconf.ASIA - PL/CUDA / Fusion of HPC Grade Power with In-Database Analytics The PG-Strom Project
PG-Strom概要 (2/2) – GPUバイナリの自动生成
QUERY: SELECT cat, count(*), avg(x) FROM t0
WHERE x between y and y + 20.0 GROUP BY cat;
例） WHERE句での计算式を
Just-in-time
CUDAプログラムに変换。
Compile
:
STATIC_FUNCTION(bool)
gpupreagg_qual_eval(kern_context *kcxt,
kern_data_store *kds,
Run-time
size_t kds_index)
Compiler
{ Reference to input data
(nvrtc)
pg_float8_t KPARAM_1 = pg_float8_param(kcxt,1);
pg_float8_t KVAR_3 = pg_float8_vref(kds,kcxt,2,kds_index);
pg_float8_t KVAR_4 = pg_float8_vref(kds,kcxt,3,kds_index);
return EVAL((pgfn_float8ge(kcxt, KVAR_3, KVAR_4) &&
pgfn_float8le(kcxt, KVAR_3,
pgfn_float8pl(kcxt, KVAR_4, KPARAM_1))));
} : Parallel
SQL expression in CUDA source code
Execution
5 PGconf.ASIA - PL/CUDA / Fusion of HPC Grade Power with In-Database Analytics The PG-Strom Project
GPUによるSQL実行高速化の一例
PG-Strom microbenchmark with JOIN/GROUP BY
300
CPU: Xeon E5-2670v3
248.95
250 GPU: GTX1080
]
c
e RAM: 384GB
s
[ 201.12
e 200 OS: CentOS 7.2
m
i DB: PostgreSQL 9.5 +
T
e
s PG-Strom v1.0 144.55
n 150
o
p 119.51
s
e 100.50
R
100
y 79.82
r
e 62.79
u
Q
50 40.44
9.96 9.93 9.96 9.99 10.02 10.03 9.98 10.00
0
2 3 4 5 6 7 8 9
Number of joined tables
PostgreSQL v9.5 PG-Strom v1.0
▌Test Query:
SELECT cat, count(*), avg(x)
FROM t0 NATURAL JOIN t1 [NATURAL JOIN t2 ...]
GROUP BY cat;
 t0 contains 100M rows, t1...t8 contains 100K rows (like a start schema)
6 PGconf.ASIA - PL/CUDA / Fusion of HPC Grade Power with In-Database Analytics The PG-Strom Project
v1.0开発过程におけるユーザからのフィードバック
Application
SQL Parser
计算集约的ワークロード
Query
PG-Strom
• In-database Analytics
Optimizer
Extension • 科学技术计算、マーケティング
 by PL/CUDA + Matrix-Array
Query
Executor GPU
Storage Manager
I/O集约的ワークロード
• 泛用の大规模OLAP
• ETL、レポーティング
Storage
 by SSD-to-GPU P2P DMA
7 PGconf.ASIA - PL/CUDA / Fusion of HPC Grade Power with In-Database Analytics The PG-Strom Project
Introduction of PL/CUDA
8 PGconf.ASIA - PL/CUDA / Fusion of HPC Grade Power with In-Database Analytics The PG-Strom Project
失败から学ぶ (1/3) – アルゴリズムをSQLで记述する
Apr-2016
9 PGconf.ASIA - PL/CUDA / Fusion of HPC Grade Power with In-Database Analytics The PG-Strom Project
失败から学ぶ (2/3) – 性能上のアドバンテージ (?)
Apr-2016
10 PGconf.ASIA - PL/CUDA / Fusion of HPC Grade Power with In-Database Analytics The PG-Strom Project
失败から学ぶ (3/3) – 问题点
▌问题① – SQLでアルゴリズムを记述する人なんていない。
 そもそも、アルゴリズムの大半は手続き型言语を前提として开発されている。
 ユーザがCUDAでアルゴリズムの核を记述する必要がないとしても、
これは権局、SQLのパズルを考えながらアルゴリズムのロジックを记述
しているのと同じ事。
▌问题② – 性能上のメリットは本当にあった？
 Min-Max法の距离计算において、确かにPG-Stromの実行性能は
PostgreSQLを遥かに上回っているが、そもそも、この种の计算を
PostgreSQLで行っている人っていないんじゃないの？
 GpuProjectionの性能は、このアルゴリズムを処理するために设计された
CPU版の外部アプリの性能と概ね同等だった。なぜ？
SQL互换性に由来する非效率性
PostgreSQLの行フォーマットに由来する非效率性
11 PGconf.ASIA - PL/CUDA / Fusion of HPC Grade Power with In-Database Analytics The PG-Strom Project
解决策 – PL/CUDA + Array-Matrix
PL/CUDA
Post SQL Process
手动での最适化手段
 Tables JOIN  ORDER BY
 Window  GROUP BY
CREATE FUNCTION my_logic(matrix, matrix) Function  etc....
RETURNS vector 结果セットの
AS $$ 书き戻し
GPU Kernel
ユーザ定义のCUDAコードブロック
ユーザ定义の
CUDAコードブロック
$$ LANGUAGE ‘plcuda’;
関数の引数を
ロード
Array-Matrix
非NULLの2次元配列を“行列”と解釈
𝑎 ⋯ 𝑑 Storage
1 1
⋮ ⋱ ⋮ 4列N行 行列
𝑎 ⋯ 𝑑
𝑁 𝑁
ArrayType ヘッダ a a a b b b c c c d d d
1 2 … N 1 2 … N 1 2 … N 1 2 … N
12 PGconf.ASIA - PL/CUDA / Fusion of HPC Grade Power with In-Database Analytics The PG-Strom Project
PL/CUDA関数定义の例
CREATE OR REPLACE FUNCTION
knn_gpu_similarity(int, int[], int[]) CUDA code block
RETURNS float4[]
AS $$
#plcuda_begin
cl_int k = arg1.value;
MatrixType *Q = (MatrixType *) arg2.value;
MatrixType *D = (MatrixType *) arg3.value;
MatrixType *R = (MatrixType *) results;
:
nloops = (ARRAY_MATRIX_HEIGHT(Q) + (part_sz - k - 1)) / (part_sz - k);
for (loop=0; loop e, result,
isinf(arg1.value) || isinf(arg2.value),
arg1.value == 0.0 || arg2.value == 0.0);