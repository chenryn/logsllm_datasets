+
+
+
+
+++
id *id
P
P!*
￥
FT'E
FT
FT'1
L
山
栈
id +id *id$
$P! * P!+ P!
$P!* P!.+
+
id *ids
输入
*
输
匹配
动价
P!←d
E'→+ TE'
145
您
→
口
---
## Page 162
会引起一些问题，其原因有多个。首先，由语法
栈操作。改变栈中符号或将新符号压人栈中可能
并发出适当的错误消息。它们也可能执行一些出
这些例程可以改变、插人或删除输人中的符号，
分析表的空白条目中填写指向处理例程的指针。
现的地方。
描述相应的错误，还必须引导人们注意错误被发
须提供足够的包含有用信息的错误消息，它不仅
虑有关错误消息的重要问题。编译器的设计者少
示。
图 4-22中的错误恢复机制的工作过程如图4-23月
被弹出。如果栈顶的词法单元和输入符号不匹配，那么我们就按上述方式从栈中弹出这个单元。
那么输入符号α就被忽略。如果该条目是“synch”，
各个非终结符号的 FOLLOW 集合是从例子4.30 中得到的。
出。图4-22 中使用“synch”来表示根据相应非终结符号的 FOLLOW 集合得到的同步词法单元。
符号作为同步集合就能够很好地完成任务。图4-17 中此文法的语法分析表在图 4-22中再次给
所有其他词法单元的集合作为一-个词法单元的同步集合。
发出一个消息称已经插入了这个终结符号,同时继续进行语法分析。从效果上看，这个方法是将
误恢复时需要考虑的非终结符号的数量。
么做可能会延迟对某些错误的检测，但是不会使错误被漏检。这个方法可以减少我们在处理错
的某个符号出现在输人中时，我们就有可能可以根据A 继续进行语法分析。
把语句开头的关键字加人到生成表达式的非终结符号的同步集合中去。
等等。我们可以把较高层构造的开始符号加人到较低层构造的同步集合中去。比如，我们可以
图4-22 中的分析表将按照如下方式使用。如果语法分析器查看 M[A，α］并发现它是空的，
4）如果一个非终结符号可以生成空串，那么可以把摧导出ε的产生式当作默认值使用。这
3）如果我们把 FIRST（A)中的符号加人到非终结符号A的同步集合中，那么当 FIRST（A）中
短语层次错误恢复的实现方法是在预测语法
短语层次的恢复
上面的关于恐慌模式错误恢复的讨论没有
对于错误输人+id*+id，语法分析器以及
146
非终结符号
图4-22加人到图4-17的预测分析表中的同步词法单元
P!←d
synch
→e
发
考
所
synch
输入符号
，那么在试图继续分析时，栈项的非终结符号
3
L
22
L
栈
图4-23--个预测分析器所做的
()←
E→TE
6
6
GA
的
6
6
语法分析和错误恢复步骤
id *+ id !
synch
synch
E'→el
synch
十
+
+
P
P
6
6A
子
69
A
synch
synch
E→c
synch
↑
说明
第 4章
---
## Page 163
CNF 文法可以生成∈)的 CNF 文法。
CNF)文法。说明如何将任意文法转变成一个生成相同语言（唯一可能的例外是空串一
C是非终结符号,而α是终结符号，那么这个文法就称为 Chomsky 范式（Chomsky Normal Forrn，
A 存在一步或多步的推导A A)的等价文法。
非终结符号对A 和 B：存在一系列单产生式使得AB。
形如 A→B 的产生式，其中 A、B 为任意的非终结符号。
的非终结符号。非终结符号可能为空是指它(可能通过很长的推导)生成é。
一可能的例外是空串—没有哪个无ε产生式的文法能生成ε)。提示：首先找出所有可能为空
是无∈产生式的。
别到串 αa。因此，任何合理的递归下降分析器将首先尝试 S→aSa。
法设计一个带回溯的递归下降分析器。如果我们选择先用产生式 S一a 展开，那么我们只能识
中的语言(运算分量为α的后缀表达式)对应的预测分析器？
文法进行提取左公因子或消除左递归的操作。
.4.4.64.4节的练习
输入符号(当到达输入结尾处时，则需要保证栈中的内容会变少）。
不会陷入无限循环。防止出现无限循环的一个好办法是保证任何恢复动作最终都会消耗掉某个
分析器执行的动作可能根本不对应于语言中任何句子的推导过程。第二，我们必须保证分析器
的、
中定义。
！练习4.4.6：如果一个文法没有产生式体为∈的产生式(称为∈产生式），那么这个文法就
语法分析
！！练习4.4.8：如果一个文法的每个产生式要么形如 A→BC，要么形如A→→α，其中A、B和
.无ε产生式、无单产生式的文法。提示：首先消除ε-产生式，然后找出所有满足下列条件的
！练习4.4.7：单产生式(single production)是指其产生式体为单个非终结符号的产生式，即
2）将你的算法应用于文法 S-→aSbS丨bSaS丨∈。
1）给出一个算法，它的功能是把任何文法转变成--个无ε产生式的生成相同语言的文法（唯
2）将你的算法应用于 4.1.2节的算法(4.1)。
下面的练习是构造任意文法的“Chomsky 范式”的有用步骤。Chomsky 范式将在练习 4.4.8
1）说明这个递归下降分析器识别输人 aa、aaa 和 aaaaaa，但是识别不了aaaaaa。
！！2)这个递归下降分析器识别什么样的语言？
练习 4.4.5：文法 S→→aSa”αa 生成了所有由α 组成的长度为偶数的串。我们可以为这个文
练习 4.4.3：计算练习 4.2.1的文法的 FIRST 和 FOLLOW 集合。
！！练习4.4.2：有没有可能通过某种方法修改练习4.2.1中的文法，构造出一个与该练习
6）练习4.2.2(7)中的文法。
+
3）
2）
1）练习4.2.2(1)中的文法，
练
习4.4.4：计算练习4.2.2中各个文法的FIRST和FOLLOW集合。
练习4.2.2(5)中的文法，
练习4.2.2(4)中的文法，
练习4.2.2(3)中的文法
练习4.2.2(2)中的文法
一没有
147
---
## Page 164
虽然手工构造一个 LR 语法分析器的工作量非常大，但借助语法分析器自动生成工具可以使人们
节和4.7节中讨论LR 文法类，它是最大的、可以构造出相应移入－归约语法分析器的文法类。
分析的过程。
的分析树的快照序列演示了按照表达式文法(4.1)对词法单元序列id＊id进行的自底向上语法
便，虽然编译器前端实际上不会显式地构造出语法分析树，而是直接进行翻译。图4-25 中显示
(底部)开始逐渐向上到达根结点(顶部）。将语法分析描述为语法分析树的构造过程会比较方
4.5自底向上的语法分析
析表。
步符号的思想：
else 时就选择消耗掉这个 else。使用4.4.5 节中描述的同
结符号 stmtTail)而引起的冲突：当我们从输人中看到一个
的句子。
多少次插人、删除和修改错误(每个错误是--个字符)的操作才能将这个串变成基础文法的语言
A放到T;中。
αα…α,对应的一棵语法分析树？提示：修改练习4.4.9中的表T，使得对于表的每个条目T;中
内填写完毕。给出一个能够正确填写这个表的条目的算法，并说明你的算法的时间复杂度为
内完成识别。完成这种识别工作的一个简单方法称为 Coche-Younger-Kasami（CYK)算法。该算法
1）为这个文法构造一个带有错误纠正信息的预测分
！练习.4.4.12：图4-24 中给出了对应于某些语句的文法。你可以将é和s 当作分别代表条
！练习4.4.11：修改练习4.4.9中的算法，使得对于任意符号串，它可以找出至少需要执行
！练习4.4.10：说明我们如何能够在填好练习 4.4.9中的表之后，在 0(n)时间内获得
！练习 4.4.9：对于每个具有上下文无关文法的语言，其长度为n的串可以在 0(n²）的时间
148
本节将介绍一个被称为移人－归约语法分析的自底向上语法分析的通用框架。我们将在4.6
-一个自底向上的语法分析过程对应于为一个输人串构造语法分析树的过程，它从叶子结点
 while e do begin s ; if e then s ; end 
@ if e then s; if e then s end
2）给出你的语法分析器在处理下列输人时的行为：
id * id
F*id
图4-25id*id的自底向上分析过程
*id
3
一
stmt.
图4-24某种类型语句的文法
tTail
while e do stmt
if e then stmt stmtTait
else stmt.
第4章
---
## Page 165
型都有且只有一个句柄。