## 高可用状态决策 {#06.html#-}无论是计算高可用还是存储高可用，其基础都是"**状态决策**"，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。如果状态决策本身都是有错误或者有偏差的，那么后续的任何行动和处理无论多么完美也都没有意义和价值。但在具体实践的过程中，恰好存在一个本质的矛盾：**通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确**。下面我基于几种常见的决策方式进行详细分析。1\. 独裁式独裁式决策指的是存在一个独立的决策主体，我们姑且称它为"决策者"，负责收集信息然后进行决策；所有冗余的个体，我们姑且称它为"上报者"，都将状态信息发送给决策者。![](Images/61b21f7f3c9e8d9aa13c9cf0351af1d5.png){savepage-src="https://static001.geekbang.org/resource/image/f7/cf/f749a798fd189c9032f05f6eb41cdecf.png"}独裁式的决策方式不会出现决策混乱的问题，因为只有一个决策者，但问题也正是在于只有一个决策者。当决策者本身故障时，整个系统就无法实现准确的状态决策。如果决策者本身又做一套状态决策，那就陷入一个递归的死循环了。2\. 协商式协商式决策指的是两个独立的个体通过交流信息，然后根据规则进行决策，**最常用的协商式决策就是主备决策**。![](Images/33ed63fa2bd254de2d82e3b8ddc2568d.png){savepage-src="https://static001.geekbang.org/resource/image/2d/11/2d6cd4d81842494c6583bfa227f53e11.png"}这个架构的基本协商规则可以设计成：-   2 台服务器启动时都是备机。-   2 台服务器建立连接。-   2 台服务器交换状态信息。-   某 1 台服务器做出决策，成为主机；另一台服务器继续保持备机身份。协商式决策的架构不复杂，规则也不复杂，其难点在于，如果两者的信息交换出现问题（比如主备连接中断），此时状态决策应该怎么做。-   如果备机在连接中断的情况下认为主机故障，那么备机需要升级为主机，但实际上此时主机并没有故障，那么系统就出现了两个主机，这与设计初衷（1    主 1 备）是不符合的。![](Images/bc8e2612296996b22754abeda58791c9.png){savepage-src="https://static001.geekbang.org/resource/image/09/6f/0919428efccf7fde2e02f92b89f1626f.png"}-   如果备机在连接中断的情况下不认为主机故障，则此时如果主机真的发生故障，那么系统就没有主机了，这同样与设计初衷（1    主 1 备）是不符合的。![](Images/d480998b4f97acbd848753a1521af4fc.png){savepage-src="https://static001.geekbang.org/resource/image/2a/52/2a3e013ab1e2e5086679becba0308652.png"}-   如果为了规避连接中断对状态决策带来的影响，可以增加更多的连接。例如，双连接、三连接。这样虽然能够降低连接中断对状态带来的影响（注意：只能降低，不能彻底解决），但同时又引入了这几条连接之间信息取舍的问题，即如果不同连接传递的信息不同，应该以哪个连接为准？实际上这也是一个无解的答案，无论以哪个连接为准，在特定场景下都可能存在问题。![](Images/39963bae9afc5ee620807fe239d537a3.png){savepage-src="https://static001.geekbang.org/resource/image/28/32/28a95c98954c47b70d7f1d8f826c2932.png"}综合分析，协商式状态决策在某些场景总是存在一些问题的。3\. 民主式民主式决策指的是多个独立的个体通过投票的方式来进行状态决策。例如，ZooKeeper集群在选举 leader 时就是采用这种方式。![](Images/56994ed0d5d614e5b4e433f60489d0ae.png){savepage-src="https://static001.geekbang.org/resource/image/c5/d9/c5ac18b395e05be0fc336c1a4eb524d9.png"}民主式决策和协商式决策比较类似，其基础都是独立的个体之间交换信息，每个个体做出自己的决策，然后按照"**多数取胜**"的规则来确定最终的状态。不同点在于民主式决策比协商式决策要复杂得多，ZooKeeper的选举算法Paxos，绝大部分人都看得云里雾里，更不用说用代码来实现这套算法了。除了算法复杂，民主式决策还有一个固有的缺陷：脑裂。这个词来源于医学，指人体左右大脑半球的连接被切断后，左右脑因为无法交换信息，导致各自做出决策，然后身体受到两个大脑分别控制，会做出各种奇怪的动作。例如：当一个脑裂患者更衣时，他有时会一只手将裤子拉起，另一只手却将裤子往下脱。脑裂的根本原因是，原来统一的集群因为连接中断，造成了两个独立分隔的子集群，每个子集群单独进行选举，于是选出了2 个主机，相当于人体有两个大脑了。![](Images/80bc6581e01cee6f3f79f9c2a23fb194.png){savepage-src="https://static001.geekbang.org/resource/image/0e/da/0eeb06db1097e02957fc14a037f328da.png"}从图中可以看到，正常状态的时候，节点 5作为主节点，其他节点作为备节点；当连接发生故障时，节点 1、节点 2、节点 3形成了一个子集群，节点 4、节点 5形成了另外一个子集群，这两个子集群的连接已经中断，无法进行信息交换。按照民主决策的规则和算法，两个子集群分别选出了节点2 和节点 5作为主节点，此时整个系统就出现了两个主节点。这个状态违背了系统设计的初衷，两个主节点会各自做出自己的决策，整个系统的状态就混乱了。为了解决脑裂问题，民主式决策的系统一般都采用"投票节点数必须超过系统总节点数一半"规则来处理。如图中那种情况，节点4 和节点 5 形成的子集群总节点数只有 2 个，没有达到总节点数 5个的一半，因此这个子集群不会进行选举。这种方式虽然解决了脑裂问题，但同时降低了系统整体的可用性，即如果系统不是因为脑裂问题导致投票节点数过少，而真的是因为节点故障（例如，节点1、节点 2、节点 3真的发生了故障），此时系统也不会选出主节点，整个系统就相当于宕机了，尽管此时还有节点4 和节点 5 是正常的。综合分析，无论采取什么样的方案，状态决策都不可能做到任何场景下都没有问题，但完全不做高可用方案又会产生更大的问题，如何选取适合系统的高可用方案，也是一个复杂的分析、判断和选择的过程。
## 小结 {#06.html#-}今天我给你讲了复杂度来源之一的高可用，分析了计算高可用和存储高可用两个场景，给出了几种高可用状态决策方式，希望对你有所帮助。这就是今天的全部内容，留一道思考题给你吧。高性能和高可用是很多系统的核心复杂度，你认为哪个会更复杂一些？理由是什么？欢迎你把答案写到留言区，和我一起讨论。相信经过深度思考的回答，也会让你对知识的理解更加深刻。（编辑乱入：精彩的留言有机会获得丰厚福利哦！）![](Images/f2eae62fce5bba3ca5ee38d11da01862.png){savepage-src="https://static001.geekbang.org/resource/image/ba/37/ba6fcd186893b8cc9977d18e1fa5ab37.jpg"}
# 06 \| 复杂度来源：可扩展性复杂度来源前面已经讲了高性能和高可用，今天来聊聊[可扩展性]{.orange}。可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。由于软件系统固有的多变性，新的需求总会不断提出来，因此可扩展性显得尤其重要。在软件开发领域，面向对象思想的提出，就是为了解决可扩展性带来的问题；后来的设计模式，更是将可扩展性做到了极致。得益于设计模式的巨大影响力，几乎所有的技术人员对于可扩展性都特别重视。设计具备良好可扩展性的系统，有两个基本条件：**正确预测变化**、**完美封装变化**。但要达成这两个条件，本身也是一件复杂的事情，我来具体分析一下。``{=html}
## 预测变化 {#07.html#-}软件系统与硬件或者建筑相比，有一个很大的差异：软件系统在发布后还可以不断地修改和演进，这就意味着**不断有新的需求需要实现**。如果新需求能够不改代码甚至少改代码就可以实现，那当然是皆大欢喜的，否则来一个需求就要求系统大改一次，成本会非常高，程序员心里也不爽（改来改去），产品经理也不爽（做得那么慢），老板也不爽（那么多人就只能干这么点事）。因此作为架构师，我们总是试图去预测所有的变化，然后设计完美的方案来应对，当下一次需求真正来临时，架构师可以自豪地说：这个我当时已经预测到了，架构已经完美地支持，只需要一两天工作量就可以了！然而理想是美好的，现实却是复杂的。有一句谚语，"唯一不变的是变化"，如果按照这个标准去衡量，架构师每个设计方案都要考虑可扩展性。例如，架构师准备设计一个简单的后台管理系统，当架构师考虑用MySQL 存储数据时，是否要考虑后续需要用 Oracle 来存储？当架构师设计用HTTP 做接口协议时，是否要考虑要不要支持ProtocolBuffer？甚至更离谱一点，架构师是否要考虑 VR技术对架构的影响从而提前做好可扩展性？如果每个点都考虑可扩展性，架构师会不堪重负，架构设计也会异常庞大且最终无法落地。但架构师也不能完全不做预测，否则可能系统刚上线，马上来新的需求就需要重构，这同样意味着前期很多投入的工作量也白费了。同时，"预测"这个词，本身就暗示了不可能每次预测都是准确的，如果预测的事情出错，我们期望中的需求迟迟不来，甚至被明确否定，那么基于预测做的架构设计就没什么作用，投入的工作量也就白费了。综合分析，预测变化的复杂性在于：-   不能每个设计点都考虑可扩展性。-   不能完全不考虑可扩展性。-   所有的预测都存在出错的可能性。对于架构师来说，如何把握预测的程度和提升预测结果的准确性，是一件很复杂的事情，而且没有通用的标准可以简单套上去，更多是靠自己的经验、直觉，所以架构设计评审的时候经常会出现两个设计师对某个判断争得面红耳赤的情况，原因就在于没有明确标准，不同的人理解和判断有偏差，而最终又只能选择一个判断。
## 应对变化 {#07.html#-}假设架构师经验非常丰富，目光非常敏锐，看问题非常准，所有的变化都能准确预测，是否意味着可扩展性就很容易实现了呢？也没那么理想！因为预测变化是一回事，采取什么方案来应对变化，又是另外一个复杂的事情。即使预测很准确，如果方案不合适，则系统扩展一样很麻烦。![](Images/479e28f2127cad9b60f5a0efe44ce9c8.png){savepage-src="https://static001.geekbang.org/resource/image/64/c2/644e3f458ce3e9ce915705b3e396e3c2.png"}第一种应对变化的常见方案是**将"变化"封装在一个"变化层"，将不变的部分封装在一个独立的"稳定层"**。无论是变化层依赖稳定层，还是稳定层依赖变化层都是可以的，需要根据具体业务情况来设计。例如，如果系统需要支持XML、JSON、ProtocolBuffer三种接入方式，那么最终的架构就是上面图中的"形式 1"架构，也就是下面这样。![](Images/e9593821f16ae6122be77a3d9cdca639.png){savepage-src="https://static001.geekbang.org/resource/image/5a/af/5a562eea83641cb021712b5e522468af.png"}如果系统需要支持 MySQL、Oracle、DB2数据库存储，那么最终的架构就变成了"形式 2"的架构了，你可以看下面这张图。![](Images/923b6f6ee06dfb4de8b7b7297e3bb162.png){savepage-src="https://static001.geekbang.org/resource/image/ff/ac/ff74b3261aeb6f1a6ebd57f0b37a28ac.png"}无论采取哪种形式，通过剥离变化层和稳定层的方式应对变化，都会带来两个主要的复杂性相关的问题。1\. 系统需要拆分出变化层和稳定层对于哪些属于变化层，哪些属于稳定层，很多时候并不是像前面的示例（不同接口协议或者不同数据库）那样明确，不同的人有不同的理解，导致架构设计评审的时候可能吵翻天。2\. 需要设计变化层和稳定层之间的接口接口设计同样至关重要，对于稳定层来说，接口肯定是越稳定越好；但对于变化层来说，在有差异的多个实现方式中找出共同点，并且还要保证当加入新的功能时原有的接口设计不需要太大修改，这是一件很复杂的事情。例如，MySQL的 REPLACE INTO 和 Oracle 的 MERGE INTO语法和功能有一些差异，那存储层如何向稳定层提供数据访问接口呢？是采取MySQL 的方式，还是采取 Oracle 的方式，还是自适应判断？如果再考虑 DB2的情况呢？相信你看到这里就已经能够大致体会到接口设计的复杂性了。第二种常见的应对变化的方案是**提炼出一个"抽象层"和一个"实现层"**。抽象层是稳定的，实现层可以根据具体业务需要定制开发，当加入新的功能时，只需要增加新的实现，无须修改抽象层。这种方案典型的实践就是设计模式和规则引擎。考虑到绝大部分技术人员对设计模式都非常熟悉，我以设计模式为例来说明这种方案的复杂性。以设计模式的"装饰者"模式来分析，下面是装饰者模式的类关系图。![](Images/5fd05afdab28c422c7de43b6a7d2c47f.png){savepage-src="https://static001.geekbang.org/resource/image/df/9a/df5bce71ff70a9abde3ca94cbaa7a39a.png"}图中的 Component 和 Decorator 就是抽象出来的规则，这个规则包括几部分：1.Component 和 Decorator 类。 2.Decorator 类继承 Component 类。3.Decorator 类聚合了 Component 类。这个规则一旦抽象出来后就固定了，不能轻易修改。例如，把规则 3去掉，就无法实现装饰者模式的目的了。装饰者模式相比传统的继承来实现功能，确实灵活很多。例如，《设计模式》中装饰者模式的样例"TextView"类的实现，用了装饰者之后，能够灵活地给TextView增加额外更多功能，比如可以增加边框、滚动条、背景图片等，这些功能上的组合不影响规则，只需要按照规则实现即可。但装饰者模式相对普通的类实现模式，明显要复杂多了。本来一个函数或者一个类就能搞定的事情，现在要拆分成多个类，而且多个类之间必须按照装饰者模式来设计和调用。规则引擎和设计模式类似，都是通过灵活的设计来达到可扩展的目的，但"灵活的设计"本身就是一件复杂的事情，不说别的，光是把23 种设计模式全部理解和备注，都是一件很困难的事情。