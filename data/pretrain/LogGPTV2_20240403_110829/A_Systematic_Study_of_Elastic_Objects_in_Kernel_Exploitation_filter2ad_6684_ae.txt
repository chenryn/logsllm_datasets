that none can be useful or practical for hindering the threat of
elastic kernel objects. Inspired by this finding, we introduce a new
lightweight defense mechanism. We conclude that the threat of
elastic objects can be, to some extent, mitigated if the kernel could
place elastic objects into separated caches or zones.
9 ACKNOWLEDGEMENTS
We thank the anonymous reviewers for their helpful feedback. This
work was supported by the 2020 IBM PhD Fellowship Program,
NSF 1718459, and ONR N00014-20-1-2008.
REFERENCES
[1] 2015. Phoronix Test Suite. http://www.phoronix-test-suite.com/.
[2] 2019. Code and Exploits for ELOISE. https://github.com/chenyueqi/w2l.
[3] 0x3f97. 2018. cve-2017-8890 root case analysis. https://0x3f97.github.io/exploit/
[4] Thanassis Avgerinos, Sang Kil Cha, Brent Lim Tze Hao, and David Brumley. 2011.
AEG: Automatic Exploit Generation. In Proceedings of the 2016 Network and
Distributed System Security Symposium (NDSS).
2018/08/13/cve-2017-8890-root-case-analysis/.
[5] Tiffany Bao, Ruoyu Wang, Yan Shoshitaishvili, and David Brumley. 2017. Your Ex-
ploit is Mine: Automatic Shellcode Transplant for Remote Exploits. In Proceedings
of the 38th IEEE Symposium on Security and Privacy (S&P).
[6] Ian Beer. 2017. Exception-oriented exploitation on iOS. https://googleprojectzer
o.blogspot.com/2017/04/exception-oriented-exploitation-on-ios.html.
[7] David Brumley, Pongsin Poosankam, Dawn Xiaodong Song, and Jiang Zheng.
2008. Automatic Patch-Based Exploit Generation is Possible: Techniques and Im-
plications. In Proceedings of the 29th IEEE Symposium on Security and Privacy
(S&P).
[8] Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David Brumley.
2012. Unleashing Mayhem on Binary Code. In Proceedings of the 33rd IEEE
Symposium on Security and Privacy (S&P).
[9] Shuo Chen, Jun Xu, Emre C. Sezer, Prachi Gauriar, and Ravishankar K. Iyer.
2005. Non-Control-Data Attacks Are Realistic Threats. In Proceedings of the
14th USENIX Security Symposium (USENIX Security).
[10] Weiteng Chen, Xiaochen Zou, Guoren Li, , and Zhiyun Qian. 2020. KOOBE:
Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vul-
nerabilities. In Proceedings of the 29th USENIX Security Symposium (USENIX
Security).
[11] Yueqi Chen and Xinyu Xing. 2019. SLAKE: Facilitating Slab Manipulation for
Exploiting Vulnerabilities in the Linux Kernel. In Proceedings of the 26th ACM
SIGSAC Conference on Computer and Communications Security (CCS).
[12] Yueqi Chen, Xinyu Xing, and Jimmy Su. 2019. Hands off and putting SLAB/SLUB
fengshui in a blackbox. https://i.blackhat.com/eu-19/Wednesday/eu-19-Chen-
Hands-Off-And-Putting-SLAB-SLUB-Feng-Shui-In-A-Blackbox.pdf.
[13] Eric Chiang. 2019. User Namespaces. https://ericchiang.github.io/post/user-
namespaces/.
[14] Haehyun Cho, Jinbum Park, Joonwon Kang, Tiffany Bao, Ruoyu Wang, Yan
Shoshitaishvili, Adam Doupé, and Gail-Joon Ahn. 2020. Exploiting Uses of
Uninitialized Stack Variables in Linux Kernels to Leak Kernel Pointers. In 14th
USENIX Workshop on Offensive Technologies (WOOT).
es/2017/11/14/security-things-in-linux-v4-14/.
es/2017/09/05/security-things-in-linux-v4-13/.
[15] Kees Cook. 2017. security things in Linux v4.13. https://outflux.net/blog/archiv
[16] Kees Cook. 2017. security things in Linux v4.14. https://outflux.net/blog/archiv
[17] Jonathan Corbet. 2012. Supervisor mode access prevention. https://lwn.net/Art
[18] Jonathan Corbet. 2016. Exclusive page-frame ownership. https://lwn.net/Artic
[19] Jonathan Corbet. 2017. The current state of kernel page-table isolation. https:
icles/517475/.
[20] SSD Secure Disclosure. 2017. SSD Advisory – Linux Kernel AF_PACKET Use-
//lwn.net/Articles/741878/.
After-Free. https://ssd-disclosure.com/archives/3484.
[21] dp304. 2018. Alternative to flexible array members for avoiding multiple alloca-
tions. https://www.gamedev.net/forums/topic/696730-alternative-to-flexible-
array-members-for-avoiding-multiple-allocations/.
les/700647/.
[22] Jake Edge. 2016. Hardened usercopy. https://lwn.net/Articles/695991/.
[23] Stefan Esser. 2016. iOS 10 - Kernel Heap Revisited.
[24] Dmitry Evtyushkin, Dmitry Ponomarev, and Nael Abu-Ghazaleh. 2016. Jump over
ASLR: Attacking branch predictors to bypass ASLR. In Proceedings of the 49th
Annual IEEE/ACM International Symposium on Microarchitecture (MICRO).
[25] Google. 2019. syzkaller - kernel fuzzer. https://github.com/google/syzkaller.
[26] Google. 2020. syzbot Dashboard. https://syzkaller.appspot.com/upstream.
[27] Daniel Gruss, Clémentine Maurice, and Anders Fogh. 2016. Prefetch Side-Channel
Attacks: Bypassing SMAP and Kernel ASLR. In Proceedings of the 23rd ACM
SIGSAC Conference on Computer and Communications Security (CCS).
[28] Mathieu Hautebas. 2018. empty_list - exploit for p0 issue 1564 (CVE-2018-4243)
iOS 11.0 - 11.3.1 kernel r/w. https://github.com/Jailbreaks/empty_list.
[29] Sean Heelan, Tom Melham, and Daniel Kroening. 2018. Automatic Heap Lay-
out Manipulation for Exploitation. In Proceedings of the 27th USENIX Security
Symposium (USENIX Security).
[30] Sean Heelan, Tom Melham, and Daniel Kroening. 2019. Gollum: Modular and
Greybox Exploit Generation for Heap Overflows in Interpreters. In Proceedings of
the 26th ACM SIGSAC Conference on Computer and Communications Security
(CCS).
[31] Jann Horn. 2018. A cache invalidation bug in Linux memory manage-
ment. https://googleprojectzero.blogspot.com/2018/09/a-cache-invalidation-
bug-in-linux.html.
[32] Jann Horn. 2020. Linux Email list: CONFIG_DEBUG_INFO_BTF and CON-
FIG_GCC_PLUGIN_RANDSTRUCT. https://www.spinics.net/lists/bpf/msg16
648.html.
[33] Hong Hu, Zheng Leong Chua, Sendroiu Adrian, Prateek Saxena, and Zhenkai
Liang. 2015. Automatic Generation of Data-oriented Exploits. In Proceedings of
the 24th USENIX Security Symposium (USENIX Security).
[34] Ralf Hund, Carsten Willems, and Thorsten Holz. 2013. Practical Timing Side
Channel Attacks Against Kernel Space ASLR. In Proceedings of the 34th IEEE
Symposium on Security and Privacy (S&P).
[35] Nur Hussein. 2017. Randomizing structure layout. https://lwn.net/Articles/7222
[36] Kyriakos K. Ispoglou, Bader AlBassam, Trent Jaeger, and Mathias Payer. 2018.
Block Oriented Programming: Automating Data-Only Attacks. In Proceedings of
the 2018 ACM SIGSAC Conference on Computer and Communications Security
(CCS).
[37] Yeongjin Jang, Sangho Lee, and Taesoo Kim. 2016. Breaking Kernel Address
Space Layout Randomization with Intel TSX. In Proceedings of the 23rd ACM
SIGSAC Conference on Computer and Communications Security (CCS).
[38] M. Jones. 2010. User space memory access from the Linux kernel.
93/.
https:
//developer.ibm.com/technologies/linux/articles/l-kernel-memory-access/.
[39] Vasileios P. Kemerlis, Michalis Polychronakis, and Angelos D. Keromytis. 2014.
ret2dir: Rethinking Kernel Isolation. In Proceedings of the 23rd USENIX Security
Symposium (USENIX Security).
[40] Kengiter and adityapakki. 2019. Crix: Detecting Missing-Check Bugs in OS
[41] Andrey Konovalov. 2017.
Kernels. https://github.com/umnsec/crix.
Exploiting the Linux kernel via packet sock-
ets. https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-
via-packet.html.
[42] Andrey Konovalov. 2017. A proof-of-concept local root exploit for CVE-2017-6074.
https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-6074/poc.c.
//github.com/xairy/kernel-exploits/blob/master/CVE-2017-18344/poc.c.
oming-the-ios-kernel-heap/.
[44] Azeria Labs. 2020. Grooming the iOS Kernel Heap. https://azeria-labs.com/gro
[45] Lexfo. 2018. CVE-2017-11176: A step-by-step Linux Kernel exploitation. https:
[43] Andrey Konovalov. 2018. A proof-of-concept exploit for CVE-2017-18344. https:
//blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html.
[46] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas,
Anders Fogh, Jann Horn, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval
Yarom, and Mike Hamburg. 2018. Meltdown: Reading Kernel Memory from
User Space. In Proceedings of the 27th USENIX Security Symposium (USENIX
Security).
[47] Kangjie Lu and Hong Hu. 2019. Where Does It Go? Refining Indirect-Call
Targets with Multi-Layer Type Analysis. In Proceedings of the 26th ACM SIGSAC
Conference on Computer and Communications Security (CCS).
[48] Kangjie Lu, Aditya Pakki, and Qiushi Wu. 2019. Detecting Missing-Check Bugs
via Semantic- and Context-Aware Criticalness and Constraints Inferences. In
Proceedings of the 28th USENIX Security Symposium (USENIX Security).
[49] Kangjie Lu, Marie-Therese Walter, David Pfaff, and Stefan Nürnberger and Wenke
Lee and Michael Backes. 2017. Unleashing Use-Before-Initialization Vulnerabil-
ities in the Linux Kernel Using Targeted Stack Spraying. In Proceedings of the
2017 Network and Distributed System Security Symposium (NDSS).
[50] Wolfgan Mauerer. 2008. Professional Linux Kernel Architectures. Chapter 12.11.
[51] Larry McVoy and Carl Staelin. 2015. LMbench - Toos for Performance Analysis.
http://lmbench.sourceforge.net/.
[52] Patrick Mochel and Mike Murphy. 2020. sysfs - The filesystem for exporting
kernel objects. https://www.kernel.org/doc/Documentation/filesystems/sysfs.t
xt.
om/john/.
[53] Vitaly Nikolenko. 2016. CVE-2016-6187: Exploiting Linux kernel heap off-by-one.
https://duasynt.com/blog/cve-2016-6187-heap-off-by-one-exploit.
om/slides/bevx-talk.pdf.
/blog/linux-kernel-heap-spray.
[54] Vitaly Nikolenko. 2018. Dissecting a 17-year-old kernel bug. https://duasynt.c
[55] Vitaly Nikolenko. 2018. Linux Kernel universal heap spray. https://duasynt.com
[56] OpenWall. 2020. John the Ripper password cracker. https://www.openwall.c
[57] Alexander Popov. 2017. CVE-2017-2636: exploit the race condition in the n_hdlc
Linux kernel driver bypassing SMEP. https://a13xp0p0v.github.io/2017/03/24/C
VE-2017-2636.html.
[58] Sergej Proskurin, Marius Momeu, Seyedhamed Ghavamnia, Vasileios P. Kemerlis,
and Michalis Polychronakis. 2020. xMP: selective memory protection for kernel
and user space. In Proceedings of the 41st IEEE Symposium on Security and
Privacy (S&P).
[59] Dusan Repel, Johannes Kinder, and Lorenzo Cavallaro. 2017. Modular Synthesis
of Heap Exploits. In ACM SIGSAC Workshop on Programming Languages and
Analysis for Security (PLAS).
[60] Microsoft Research. 2020. Z3. https://github.com/Z3Prover/z3.
[61] Chris Salls. 2017. Exploiting CVE-2017-5123 with full protections. SMEP, SMAP,
and the Chrome Sandbox! https://salls.github.io/Linux-Kernel-CVE-2017-5123/.
[62] Yan Shoshitaishvili, Ruoyu Wang, Christophe Hauser, Christopher Kruegel, and
Giovanni Vigna. 2015. Firmalice - Automatic Detection of Authentication Bypass
Vulnerabilities in Binary Firmware. In Proceedings of the 2015 Network and
Distributed System Security Symposium (NDSS).
[63] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino,
Audrey Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel,
and Giovanni Vigna. 2016. SoK:(State of) The Art of War: Offensive Techniques
in Binary Analysis. In Proceedings of the 37th IEEE Symposium on Security and
Privacy (S&P).
om/questions/3047530/flexible-array-member-in-c-structure.
[64] Spudd86. 2010. Flexible array member in C-structure. https://stackoverflow.c
[65] Richard M. Stallman. 2019. GNU Debugger. https://www.gnu.org/software/gdb/.
[66] Nick Stephens, John Grosen, Christopher Salls, Audrey Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In
Proceedings of the 2016 Network and Distributed System Security Symposium
(NDSS).
[69] syzbot. 2018. KASAN: slab-out-of-bounds Write in pipe_write. https://syzkalle
[71] syzbot. 2018. KASAN: use-after-free Read in __lock_acquire (2). https://syzkalle
[70] syzbot. 2018. KASAN: slab-out-of-bounds Write in sha512_final. https://syzkal
[72] syzbot. 2018. KASAN: use-after-free Read in snd_timer_open. https://syzkalle
[67] syzbot. 2018. KASAN: slab-out-of-bounds Write in crypto_dh_encode_key. https:
//syzkaller.appspot.com/bug?id=a84d6ad70b281bfc5632f272f745104fb43d219d.
[68] syzbot. 2018. KASAN: slab-out-of-bounds Write in mpol_parse_str. https://syzk
aller.appspot.com/bug?id=3d67d693e0529df8ac89ba55b00b54e5d967e021.
r.appspot.com/bug?id=422a020e119fbac4c15d8fed114cc1696fe5c51a.
ler.appspot.com/bug?id=e4be30826c1b7777d69a9e3e20bc7b708ee8f82c.
r.appspot.com/bug?id=1379b6b21a2ffecd1ea4e2b564cc7e35d9f388b2.
r.appspot.com/bug?id=e9287fe57ad2f862eedb05012481132486f3b887.
ppspot.com/bug?id=6a6fd266a962be281b17c864a073675150e36ca5.
spot.com/bug?id=bf967d2c5ba62946c61152534c8b84823d848f05.
zkaller.appspot.com/bug?id=ebeba334a8a886e3d5dc25641e201e894d4d9657.
ot.com/bug?id=5bb09c0c5b65ab2ce628ba26fe7cbd06144bd952.
.
[73] syzbot. 2018. KASAN: use-after-free Write in bpf_tcp_close. https://syzkaller.a
[74] syzbot. 2018. KASAN: use-after-free Write in dst_release. https://syzkaller.app
[75] syzbot. 2019. KASAN: use-after-free Write in __xfrm_policy_unlink. https://sy
[76] syzbot. 2020. KASAN: use-after-free Read in route4_get. https://syzkaller.appsp
[77] PaX Team. 2000. Design & implementation of PAGEEXEC.
[78] Yan Wang, Chao Zhang, Xiaobo Xiang, Zixuan Zhao, Wenjie Li, Xiaorui Gong,
BingChang Liu, Kaixiang Chen, and Wei Zou. 2018. Revery: From Proof-of-
Concept to Exploitable. In Proceedings of the 25nd ACM SIGSAC Conference on
Computer and Communications Security (CCS).
[79] Wei Wu, Yueqi Chen, Xinyu Xing, and Wei Zou. 2019. KEPLER: Facilitating
Control-flow Hijacking Primitive Evaluation for Linux Kernel Vulnerabilities. In
Proceedings of the 28th USENIX Security Symposium (USENIX Security).
[80] Wei Wu, Yueqi Chen, Jun Xu, Xinyu Xing, Wei Zou, and Xiaorui Gong. 2018.
FUZE: Towards Facilitating Exploit Generation for Kernel Use-After-Free Vul-
nerabilities. In Proceedings of the 27th USENIX Security Symposium (USENIX
Security).
[81] Wen Xu, Juanru Li, Junliang Shu, Wenbo Yang, Tianyi Xie, Yuanyuan Zhang,
and Dawu Gu. 2015. From Collision To Exploitation: Unleashing Use-After-
Free Vulnerabilities in Linux Kernel. In Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications Security (CCS).
[82] Insu Yun, Dhaval Kapil, and Taesoo Kim. 2020. Automatic Techniques to System-
atically Discover New Heap Exploitation Primitives. In Proceedings of the 29th
USENIX Security Symposium (USENIX Security).
summarize these communication channels and categorize them
into three types.
User Space Memory Access APIs [38]. User space memory ac-
cess APIs are those functions like copy_to_user() and copyout(). For
copy_to_user(), this API copies n bytes of data from kernel address
from to user address to. When executing this function, the Linux
kernel first ensures the destination memory region (i.e., (to, to + n])
is mapped in userspace. Then, the Linux kernel maps this region to
kernel space and disables SMEP/SMAP protections (PXN/PAN on
ARM) to avoid Oops or panic. For the function copyout(), it works
similarly to copy_to_user(), coping nbytes data from kernel_addr to
user_addr.
In addition to the two APIs mentioned above, kernels have other
APIs or macros like put_user_4 to transfer data from kernel space
to userspace. These APIs are similar to copy_to_user() and copyout
(cid:44)→ (). However, they determine the amount of transfer data at
the compilation phase (e.g., 4 bytes in put_user_4). As such, the
exploitation method cannot manipulate such APIs. In this work, we
exclude such non-manipulable APIs and list only those manipulable
ones in Table 3.
Netlink socket family. This channel uses the networking frame-
work for kernel-user communication. Designed as a generic object
model [50], netlink passes all kinds of status information about
internal kernel activities to user processes (e.g., registration, re-
moval of new devices, and hardware-related events). Although
CAP_NET_ADMIN capability is generally required to build netlink
socket, as is mentioned in Section 5, unprivileged users like contain-
ers can easily bypass this restriction by creating a user namespace
(CLONE_NEWUSER). In Linux distributions (e.g., Ubuntu and Debian),
the namespace is broadly deployed. Therefore, unprivileged users
with CAP_NET_ADMIN capability can easily communicate with ker-
nel through netlink message. In Table 3, we summarize all the
kernel functions in this type. It should be noted that some com-
munication channels are a combination of two sequential function
calls.
General Networking. Different from the netlink socket family,
which only establishes communication channels between kernel
space and userspace in a local machine, APIs in general networking
category enable remote data transfer. The Linux kernel sends and
receives network packets by manipulating a socket buffer. Take
the practice of sending packets for an example. In the beginning, the
kernel allocates and reserves a socket buffer to store user data.
When protocol control and user data are passed through TCP/IP
layers, the kernel prepends/appends them to socket buffer and,
at the same time, performs data validation. After this entire proce-
dure, the NIC driver copies the entire network data in the socket
buffer to a hardware buffer. Besides, it capsules the kernel data
(e.g., authentication associated data in the link layer) into network
packets. As such, the APIs responsible for general networking op-
erations provide adversaries with the ability to disclose data to
remote hosts. In Table 3, we list all the functions in this type and
specify the number of data that the kernel can capsule into network
packets.
7FreeBSD has no heap cookie protection and thus no impact on heap protector.
Figure 5: The alternative implementations of elastic kernel
objects.
A APPENDIX
A.1 Implementation of Elastic Kernel Objects
The kernel object xfrm_replay_state_esn shown in Figure 1 is just
one kind of implementation for an elastic kernel structure/object
which encloses not only a length field but also the elastic buffer.
Based on our manual analysis on Linux, FreeBSD, and XNU, we also
discover three alternative implementations. Here, we summarize
them below.
As is illustrated in the first example shown in Figure 5, the first
alternative implementation is to have a large buffer defined in the
middle of a data object and a field within that object indicating the
actual buffer size or more precisely speaking the actual bytes used
for storing data. At the time of defining the actual number of bytes
used for storing data, kernel typically examines the length field
and ensures it does not go beyond the boundary of the large buffer.
However, we discover that the kernel does not always enforce this
essential check at the time of reading data from that buffer. As such,
it eases an attacker’s ability to manipulate the length field and thus
construct a buffer overread.
As is depicted in the second and third examples shown in Fig-
ure 5, the rest two alternative implementations do not enclose the
length field and elastic buffer in the same kernel object. Instead,
they place the length field and the elastic buffer in two individ-
ual kernel objects. The difference between the second and third
implementation is that one implementation contains an explicit
reference to the elastic buffer and, in contrast, the other implemen-
tation references the elastic buffer through a third intermediate
kernel object.
A.2 Summary of Critical Kernel Functions
Modern OS kernels use virtual memory for isolation and provide
separate address spaces for kernel and application processes. During
kernel execution, however, userland processes need to inspect the
on-going activities in the kernel and control kernel behavior from
time to time. The kernel also needs to copy extra arguments from
userland for processing and copy results back as a response to
system call invocation. As a result, kernels design and implement
various communication channels to facilitate data transfer between
kernel space and userspace. While many communication channels
(e.g., sysfs [52] in Linux) require root privilege or high privilege
(e.g., CAP_SYS_PTRACE) for data migration, unprivileged users in
a local or remote machine can still obtain data from kernel space
through unprivileged communication channels. In this work, the
exploitation method takes advantage of these unprivileged channels
to uncover kernel data to userland processes. In the following, we
bufferlenp1p1 + lenp1p23rdp21stMAXlenlenbufferA2ndbufferplenpp + lenlenABABClenTypes of Channel
User Space
Memory Access APIs
Netlink
General Networking
Function Prototypes
unsigned long copy_to_user(void __user* to, const void* from,
int copyout( const void *kernel_addr, user_addr_t user_addr,
int nla_put(struct sk_buff* skb, int attrtype,
unsigned long n);
vm_size_t nbytes);
int attrlen, const void* data);
:::::::::::
:::::::::::
int nla_put_nohdr(struct sk_buff *skb,
::::::::
int attrlen, const void* data)
int attrlen, const void* data, int padattr)
::::::::
int nla_put_64bit(struct sk_buff *skb, int attrtype,
size_t count);
void* nlmsg_data(const struct nlmsghdr* nlh); void* memcpy(void* dest, const void* src, :::::::::
size_t count);
void* nla_data(const structure nlattr *nla); void* memcpy(void* dest, const void* src, ::::::::
::::::::
void* skb_put_data(struct sk_buff* skb, const void* data,
unsigned int len);
:::::::::::
void* skb_put(struct sk_buff* skb, unsigned int len); void* memcpy(void* dest, const void* src, ::::::::
size_t count);
Table 3: The summary of the FreeBSD/Linux/XNU critical kernel functions responsible for migrating data from kernel space
to userspace. In the column of “function prototypes”, the parameters in bold specify the addresses from which the kernel data
originate. The parameters with ::::wavy::::line indicate the amount of kernel data that an attacker can potentially disclose to the