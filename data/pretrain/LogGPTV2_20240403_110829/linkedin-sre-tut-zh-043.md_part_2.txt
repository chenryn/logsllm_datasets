    传统的集群机制从客户端抽象出集群拓扑。客户端不需要知道实际数据驻留在哪里，也不需要知道它正在与哪个节点通信。集群在传统的 RDBMS 中非常常用，它可以在一定程度上帮助扩展持久层。
3.  **将读写分离**
    在这种方法中，您将拥有托管相同数据的多个副本。传入的写入通常发送到单个节点(主节点)或多个节点(多主节点)，而其余的副本(从节点)处理读取请求。领导者将写入异步复制到所有追随者。然而，写入延迟无法完全避免。有时领导者会在将所有数据复制给追随者之前崩溃。当这种情况发生时，一个拥有最一致数据的追随者可以转变为领导者。正如您现在所意识到的，在这个模型中很难实现完全的一致性。您还需要考虑读写流量的比率。当写操作高于读操作时，这种模式没有意义。复制方法也可能千差万别。一些系统定期进行完整的状态转移，而其他系统使用增量状态转移方法。您也可以通过按顺序转移操作来转移状态。然后，跟随者可以应用与领导者相同的操作来赶上。
4.  **分片**
    共享是指以这样一种方式划分数据，即数据均匀地分布在一个节点群集中(就存储和处理能力而言)。它还可能意味着数据局部性，这意味着相似和相关的数据存储在一起，以促进更快的访问。反过来，可以进一步复制一个碎片来满足负载平衡或灾难恢复需求。单个碎片复制副本可以接收所有写入(单个领导者)，或者多个复制副本可以接收写入(多个领导者)。读取可以分布在多个副本上。由于数据现在分布在多个节点上，客户端应该能够始终如一地找出数据托管的位置。我们将在下面看看一些常见的技术。分片的缺点是分片之间的连接是不可能的。因此，上游/下游应用必须聚合来自多个碎片的结果。
![alt_text](img/101cabaa229558c6b6788924d236266e.png "Sharding")
分片示例
### 散列法
哈希函数是将一段数据(通常描述某种对象，通常为任意大小)映射到另一段数据(通常为整数，称为*哈希代码*，或简称为*哈希*的函数。在分区数据库中，将一个键一致地映射到一个服务器/副本是很重要的。
例如:你可以使用一个非常简单的散列作为取模函数。
```sh
_p = k mod n_ 
```
在哪里
```sh
p -> partition,
k -> primary key
n -> no of nodes 
```
这个简单散列的缺点是，每当集群拓扑发生变化时，数据分布也会发生变化。当您处理内存缓存时，将分区分布在各处会很容易。每当一个节点加入/离开拓扑时，分区可以重新排序，缓存未命中可以从后端数据库重新填充。然而，当您查看持久数据时，这是不可能的，因为新节点没有为其提供服务所需的数据。这给我们带来了一致散列。
#### 一致散列法
一致散列是一种分布式散列方案，通过在抽象圆或*散列环*上给它们分配一个位置，独立于分布式*散列表*中的服务器或对象的数量进行操作。这允许服务器和对象在不影响整个系统的情况下进行扩展。
假设我们的散列函数 h()生成一个 32 位整数。然后，为了确定我们将向哪个服务器发送密钥 k，我们找到其散列 h(s)是大于 h(k)的最小整数的服务器 s。为了简化这个过程，我们假设这个表是循环的，这意味着如果我们找不到一个散列值大于 h(k)的服务器，我们就绕回并从数组的开头开始查找。
![alt_text](img/08730d9299569abdbf1d62253a32bb71.png "Consistent Hashing")
一致散列图
在一致散列中，当服务器被移除或添加时，只有来自该服务器的密钥被重定位。例如，如果服务器 S3 被移除，则来自服务器 S3 的所有密钥将被移动到服务器 S4，但是存储在服务器 S4 和 S2 上的密钥不会被重新定位。但是有一个问题，当服务器 S3 被移除时，来自 S3 的密钥不能在剩余的服务器 S4 和 S2 之间平均分配。它们仅被分配给服务器 S4，这增加了服务器 S4 的负载。
为了在添加或删除服务器时在服务器之间平均分配负载，它会为每个服务器创建固定数量的副本(称为虚拟节点),并沿圆圈分布。因此，代替服务器标签 S1、S2 和 S3，我们将有 S10 S11…S19、S20 S21…S29 和 S30 S31…S39。根据具体情况，多个副本的系数也称为*重量*。
映射到复制品 Sij 的所有密钥都存储在服务器 Si 上。要找到一个密钥，我们做同样的事情，找到圆上的密钥的位置，然后向前移动，直到找到一个服务器副本。如果服务器复制品是 Sij，则密钥存储在服务器 Si 中。
假设服务器 S3 被移除，那么所有带有标签 S30 S31 … S39 的 S3 复制品必须被移除。现在，邻近 S3X 标签的对象关键点将自动重新分配给 S1X、S2X 和 S4X。最初分配给 S1、S2 和 S4 的所有密钥都不会被移动。
如果我们添加一个服务器，类似的事情也会发生。假设我们想要添加服务器 S5 作为 S3 的替代，那么我们需要添加标签 S50 S51 … S59。在理想情况下，来自 S1、S2 和 S4 的四分之一的密钥将被重新分配给 S5。
当应用于持久存储时，进一步的问题出现了:如果一个节点已经离开场景，存储在这个节点上的数据变得不可用，除非它之前已经被复制到其他节点；在新节点加入其他节点的相反情况下，相邻节点不再负责它们仍然存储但不再被请求的一些数据，因为相应的对象不再被请求客户端散列到它们。为了解决这个问题，可以引入复制因子(r)。
在分区方案中引入副本，除了可靠性优势之外，还可以将读取请求的工作负载分散到负责所请求数据的任何物理节点。如果客户端必须在数据集的多个版本之间做出决定，则可伸缩性不起作用，因为它们需要从服务器的仲裁中读取，这反过来降低了负载平衡的效率。
### 法定人数
Quorum 是群集中必须联机并且能够相互通信的最小节点数。如果超过此阈值出现任何额外的节点故障，群集将停止运行。
要获得法定人数，您需要大多数节点。通常是(N/2 + 1)，其中 N 是系统中节点的总数。对于 ex 来说，
在 3 节点集群中，大多数情况下需要 2 个节点，
在 5 节点集群中，大多数情况下需要 3 个节点，
在 6 节点群集中，大多数情况下需要 4 个节点。
![alt_text](img/85721d9b83313009af3f2083c64ee410.png "image_tooltip")
法定人数示例
网络问题会导致群集节点之间的通信失败。一组节点可能能够在网络的功能部分一起通信，但是不能与网络的另一部分中的不同组节点通信。这就是众所周知的在集群或集群分割中的裂脑。
现在，具有仲裁的分区被允许继续运行应用。其他分区将从集群中删除。
例如:在一个 5 节点集群中，考虑如果节点 1、2 和 3 可以相互通信，但不能与节点 4 和 5 通信，会发生什么情况。节点 1、2 和 3 构成了大多数，它们继续作为一个集群运行。作为少数，节点 4 和 5 停止作为集群运行。如果节点 3 失去与其他节点的通信，所有节点将停止作为群集运行。但是，所有运行的节点将继续侦听通信，以便当网络重新开始工作时，群集可以形成并开始运行。
下图演示了在分为两个集的集群上选择仲裁。
![alt_text](img/5ff431b374f0cc9ac0fc7b5b631c1033.png "image_tooltip")
**集群定额示例**