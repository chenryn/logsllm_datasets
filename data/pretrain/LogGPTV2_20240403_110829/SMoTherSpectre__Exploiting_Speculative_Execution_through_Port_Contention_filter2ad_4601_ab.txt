introduce no contention as they execute only on port 1. Instruction-
to-port mappings are available through reverse engineering [10] or
the Intel Architecture Code Analyzer (IACA) tool.
3.1.3 Results and discussion. We report averages over 10,000 runs,
together with a 95%-confidence interval calculated using the Stu-
dent’s t-distribution. The experiment successfully demonstrates
that port contention occurs and that the SMoTher side channel
can be used to extract information, as we can see in Table 1. Indeed,
the run time of the contention experiment is about twice of the
non-contended one. This indicates that port contention is likely the
main bottleneck in this experiment.
This result shows how SMoTher can be used as a reliable covert
communication channel between two co-located threads. However,
as this experiment requires precisely choosing the type and number
of instructions running in one of the two threads, it is yet unclear if
port contention may serve as a practical side channel. We explore
this aspect in the next section.
Experiment
Port contention
No port contention
Execution Time (cycles)
1214 ± 67
674 ± 13
Table 1: Port contention covert channel: a thread running a long se-
quence of port 06 instructions is twice as slow when a co-located
thread executes a long sequence of port 06 instructions, when com-
pared to a co-located thread executing a long sequence of port-1-
only instructions
3.2 Characterization of the side channel
We now analyse whether SMoTher is effective as a side channel for
distinguishing realistic sequences of instructions on a simultane-
ously executing, co-located victim process. Specifically, we want to
explore whether an attacker can distinguish between the different
sequences of instructions from a known set which the victim may
run. To encapsulate this property of the set, we define the term
SMoTher-differentiability.
SMoTher differentiability. Let us consider that the victim
runs one sequence out of a set V = {V0, V1, ...}. The attacker is
allowed to craft any sequence of instructions A and time multiple
iterations of A running concurrently with the victim. If the attacker
can infer which sequence Vi ∈ V the victim was running based on its
timing measurements, the sequences in V are said to be SMoTher-
differentiable. On its part, the attacker has a-priori knowledge of
what timing to expect when A runs concurrently with each of Vi ∈
V . It can use experiments in a similar, but controlled, environment
to generate this knowledge. Further, the attacker is allowed to use
any statistical test or metric to make its decision. Examples of such
metrics include the mean or the median of the timings, or their
distribution.
In experiments in later sections of this paper, we shall establish
various pairs of sequences to be SMoTher-differentiable. After
collecting attacker timings distributions for each victim sequence
in our controlled environment, we shall use the Student’s t-test
to establish statistical difference between them with at-least 95%-
confidence. We argue that an attacker, in an adversarial scenario,
can correlate its own timing distribution with either of the a-priori
distributions to identify the victim sequence.
At its core, SMoTher-differentiability implies that the sequences
in V have differing degrees of utilization on some specific port(s)
and vice-versa. The attacker would ideally choose a sequence of
instructions scheduled solely on these ports to maximize the chance
of encountering different levels of contention across the different
possible Vi. Through our experiments, we wish to explore how short
SMoTher-differentiable sequences can be and the ideal length of
attacker sequences to differentiate them.
Experiment design and setup. In our first experiment, we
consider a victim running sequences of either popcnt (port 1) or
ror (port 06) and an attacker timing a sequence of popcnt. We
vary the length of both attacker and victim sequences, and check
for SMoTher-differentiability by noting the percentage change in
mean execution time for the attacker. In a second experiment, the
victim runs either cmovz (port 06) instructions or popcnt. In this
case, the attacker times a sequence of bts (port 06) instructions
with both operands as registers.
To run this experiment, an orchestrator process is used to fork
the victim and attacker processes, and to set their core affinities
so that they share a physical core. We require the execution of the
target sequence in the victim to temporally overlap with the (timed)
execution of the attacker sequence to assure port contention. There-
fore, the processes use a synchronization barrier which ensures
that any following instructions will be run concurrently. Thereafter,
each process runs their respective sequence, using rdtscp to take
timestamps at the beginning and end of each run. The timestamps
tell us the number of cycles taken to execute the sequence and were
used to also check that the executions were properly synchronized.
Atomic operations on variables in shared memory were used to
implement the synchronization. We repeat this process to collect
multiple timing samples.
In this set of experiments, we keep the same hardware and OS
configuration as used in the covert channel experiment, while pre-
cisely controlling the synchronization of threads through the addi-
tional instrumentation described above.
Results. Figure 2 plots the average difference in attacker execu-
tion time between the two sequences of victim instructions for each
experiment. The length of the sequence for the victim was taken
from the set {1, 4, 8, 16, 32} while the attacker sequence varied in
length between one and 100 instructions.
Our measurements confirm that timing short sequences of in-
structions is feasible: for a vast majority of sequence-length combi-
nations the victim sequences were SMoTher-differentiable using
the Student’s t-test on the attacker’s running time distributions.
While timing popcnt, 83% of all combinations plotted in Figure 2a
showed significant differences in means between the victim’s se-
quences of popcnt and ror.
The measured differences vary from close to 0% to 40%. Longer
sequences of instructions in the victim lead to higher differences and
less variability in measurements. Only 48% of popcnt measurements
with sequence of 1 victim instruction are SMoTher-differentiable,
as opposed to 83% for a sequence of 4, and 100% for a sequence of
32 victim instructions. This means that distinguishing a sequence
of one victim instruction (max. 9% difference and more variability)
is much harder than a sequence of 32 victim instructions (max. 38%
difference and less variability).
We observe that there is an optimal number of attacker instruc-
tions to measure a victim instruction sequence of a given length,
which increases with the number of victim instructions: from 10
attacker instructions for one victim instruction to 45 instructions
for 32 victim instructions. This is explained by the following obser-
vations: contention for longer instruction sequences in the attacker
is easier to time, since attacker and victim sequences are more likely
to overlap. This effect fades when the attacker sequence becomes
significantly longer than the victim’s, at which point only a small
portion of the executed instructions will contend, thereby leading
to a smaller difference.
To show the breadth of possible SMoTher-differentiability re-
sults, we perform a second experiment, with a victim running
instructions which may be scheduled to more than one port. Specif-
ically, the victim runs either cmovz (port 06) or popcnt (port 1). The
attacker times a sequence of bts instructions (port 06) to measure
the contention on ports zero and six. Figure 2b shows that multiport
instructions are still SMoTher-differentiable. However, variance is
(a) SMoTher attack using popcnt to detect if the co-located victim
runs on port 1.
(b) SMoTher attack using bts to detect if the co-located victim runs
on port 06.
Figure 2: SMoTher side channel characterization. Each data point represents the difference between the average execution time of the attacker
thread, between the port contention scenario and the baseline. We do not plot the few data points where Student’s t-test shows no statistically
significant difference between both distributions at 95%-confidence. The data points for which the attacker runs fewer instructions than the
victim are plotted in grey.
higher, and we notice a steeper cut-off point beyond the optimal
number of attacker instructions. Indeed, intuitively, with more exe-
cution ports available, the instructions are less likely to contend. In
practice, this means the attacker may need more runs to extract in-
formation, and the choice of the number of attacker instructions is
more important than in the previous experiment. As in the previous
experiment, we observe that the optimal number of attacker instruc-
tions increases with the number of victim instructions. Beyond this
number, most experiments show lower SMoTher-differentiability,
with most between 0 and 5%.
While our results show that the SMoTher side channel exists
and can be measured even for a small sequence of instructions,
we have noted a number of takeaways and pitfalls to avoid during
measurements, namely:
• Synchronisation of the target code sequence in the victim
and the timed code sequence in the attacker is extremely
important, more so when the target code sequence in the
victim is short;
• Pipeline bottlenecks other than port contention may occur
and overshadow the side channel. One such example is read-
after-write hazards;
• The CPU may eliminate the execution of some instructions
based on their operands (one such case is zero idioms). This
results in those operands not being executed, and removing
contention;
• Some instructions (e.g., those from the SSE and AVX exten-
sions) are subject to aggressive power-saving features on
modern CPUs. This makes measuring port contention more
difficult (and the power savings may in fact serve as its own
side channel [29] separately from SMoTher).
Finally, we note that practical instruction sequences are unlikely
to be identical repeated instructions. However, this is not required
for practical SMoTher side channels: it is only required that, among
a sequence of instructions, they exercise different degees of port
pressure on the port that the attacker is measuring. We further ex-
pand on this idea in Section 5 for practical SMoTher-differentiable
sequences.
4 SMOTHERSPECTRE
SMoTherSpectre is a speculative code-reuse attack technique
which starts at an indirect jump on the victim’s usual execution path.
The attacker leverages Branch Target Injection (BTI) to “poison” the
CPU’s branch predictor such that when the victim’s fetch unit asks
for the target of the indirect jump, it is sent the address of a separate
data-dependent conditional jump within the victim’s binary with
SMoTher-differentiable fall-through and target sequences. During
the period of the speculative execution, the victim evaluates the
condition and jumps to either the target or fall-through sequences.
The attacker times a sequence of relevant instructions to identify
which sequence is run on the victim (SMoTher), thereby inferring
the outcome of the condition and learning some information about
the victim’s data.
SMoTherSpectre complements and extends existing attacks [5,
23, 24] which use cache-based side channels to exfiltrate secrets.
Using such channels implies that these exploits i) require the pres-
ence of special gadgets in the victim code, or the ability to inject
them; and ii) depend on speculative execution leaving persistent,
measurable microarchitectural side-effects.
Calls using function pointers in C/C++ are traditionally imple-
mented by indirect calls in assembly. While exploitable indirect
jumps are prevalent in most programs, the first observation lim-
its the set of available gadgets for ultimately leaking secrets. This
scarcity, along with the overheads of some software-only mitiga-
tions, justifies the use of user-space programs to not deploy coun-
termeasures such as retpolines or STIBP by default. In contrast,
SMoTher-differentiable gadgets are easily found (as we demon-
strate in Section 5). Almost every conditional jump can be part of a
SMoTher-gadget, requiring only its fall-through and target to be
020406080100# of instructions in the attacker051015202530354045Attacker execution time difference (%)020406080100# of instructions in the attacker051015202530354045Attacker execution time difference (%) 1 victim instructions 4 victim instructions 8 victim instructions16 victim instructions32 victim instructionscommon libraries and open-sourced applications, and where it is
located in memory. It must be able to circumvent ASLR and similar
controls: the literature contains several examples [9, 19, 30] of how
this is achievable in practice, including an approach using the same
BTB weaknesses that make BTI possible.
4.2 Attack principle
Figure 3 shows a side-by-side layout of the code of a victim and an
attacker in the SMoTherSpectre setting. As the figure shows, the
attack requires two types of gadgets in the victim code:
• A BTI gadget: Stores secret data into memory or a register
(called the SMoTherSpectre target) followed by an indirect
branch that can be poisoned by the attacker;
• A SMoTher gadget: A data-dependent conditional jump
whose control variable is the SMoTherSpectre target, with
SMoTher-differentiable (see Section 3.2) target and fall-
through code paths.
The example BTI gadget in Figure 3 stores the secret into the
register rdi, a pointer into rax and finally jumps to the location
pointed to by rax. The corresponding SMoTher gadget contains
an rdi-dependent conditional branch where the jump target and
fall-through contain SMoTher-differentiable instruction sequences
(popcnt and ror).
Note an important difference between traditional data-dependent
control flow sequences and SMoTherSpectre. Data-dependent con-
trol flow sequences over confidential data are considered vulnera-
bilities, especially when found in cryptographic libraries. SMoTh-
erSpectre does not require such a vulnerability to be present in
the victim. It connects the loading of a secret variable to a regis-
ter or memory location (BTI gadget) with an altogether indepen-
dent, speculatively executed sequence, which happens to perform
a compare-and-jump over that same register or memory location
(SMoTher gadget). The two sets of instructions may well be entirely
uncorrelated from a software development perspective, making the
pattern harder, if not entirely impossible, to eliminate.
The attacker proceeds in two main steps, as shown in Figure 3:
in the first phase the attacker performs traditional, Spectre v2 style
BTI and then enters in a busy wait sequence, for instance a sequence
of nop instructions. The purpose of the latter is to align the second
phase of the attack with the speculative execution of the mark or
fall-through sequence in the victim. In the second phase the at-
tacker performs a SMoTher-style timing of a carefully selected
sequence of instructions – ror in the example. The attacker then
proceeds to a statistical analysis of the gathered timing information
to learn one bit of information. This entire process can be repeated
with different gadgets to leak different bits, and thereby reconstruct
the secret. Note that while the example utilizes the indirect-branch
prediction hardware to steer speculative execution to gadgets, any
existing branch redirection method may be used for this purpose
(for example the return stack buffer).
4.3 Characterization of the Side Channel
In our experimental testbed to characterize the SMoTherSpectre
side channel, an orchestrator process forks a victim and an attacker
process, pins them to two threads on the same physical core and
executes an attacker and a victim process (similar to the testbed in
Figure 3: Overview of the SMoTherSpectre components.
SMoTher-differentiable. For example, libcrypto from the OpenSSL
library contains more than 12,000 readily usable gadgets.
The second observation has lead to the proposal of defenses that
ensure that all changes to microarchitectural state be undone [21].
However, the port-contention based side-channel persists even
if the CPU were able to perform a perfect roll-back of changes
caused by non-retired instructions. The very fact that instructions
are speculatively executed remains a measurable quantity. These
characteristics allow SMoTherSpectre to present a more powerful
avenue of attack.
In this section, we first present the attacker model and objec-
tives for SMoTherSpectre. We then explain the basic premise of
the attack, the conditions required and how we ensure these are
met in our proof-of-concept. We then present a characterization of
the SMoTherSpectre side channel. Finally, we discuss the charac-
teristics of some SMoTher-gadgets we found in common system
libraries, and what information they may be used to leak.
4.1 Attacker model
The objective of a SMoTherSpectre adversary is to extract secret
information from a victim process and we make the following
assumptions about the attacker: i) they control code in a process
co-located with the victim process; ii) they can launch branch target
injection attacks.
The first assumption is justified: if the attacker can execute code
on the same machine of the victim, the scheduler may schedule the
attacker and victim on two different threads of the same physical
core. An example of such colocation may exist in public cloud
offerings where compute resources are shared at a fine granularity
between tenants: for IaaS, virtual cores for different customers may
map to the same physical core, for PaaS/SaaS processes for different
tenants may be similarly scheduled [4, 13].
Existing mitigations against BTI include software (retpolines)
and a set of hardware interfaces for flushing the indirect branch
predictors at the appropriate times and for not sharing them across
SMT threads (IBRS, IBPB and STIBP in Intel). These mitigations
come with a potentially severe performance impact [31]. As such,
these controls have been enabled only for selected system com-
ponents such as the kernel, and none of the user-space programs
we have analysed make use of them. The adversary also needs to
know the victim’s code base, which is possible through the use of
Victimload rdi, (secret)load rax, (pointer)jmp [rax] cmp rdi, 0 jl  popcnt ...mark: ror ...BTI gadgetSmother gadgetAttackerrdtscprorrorrorrorrorrdtscpPoison BTBload rax, smotherloop: jmp [rax]jmp Time smother gadgetSection 3.2). Attacker and victim processes execute the body of a
loop after synchronization using atomic operations on shared mem-
ory. The body of the loop is constructed as described in Figure 3.
In our proof-of-concept, we leverage the branch target buffer
to redirect an indirect branch in the BTI gadget of the victim to
the SMoTher gadget. In order to maximize the success rate, we
i) insert a series of N always-taken branches just prior to the indirect
branch; ii) ensure that the addresses of the branches (including the
target of BTI) are located at congruent addresses between attacker
and victim; iii) disable ASLR; iv) evict the cache-line containing
the indirect jump pointer. As other works have shown, the random
ASLR offset can be leaked in a real-life attack [9, 30], and BTI can be
performed by aliasing addresses (in the BTB) with very high success
rates [18]. Therefore, we disregard these factors while creating our
proof-of-concept (PoC). Evicting the jump pointer allows us to
extend the duration of the victim’s speculative execution, in order
to establish an upper bound for accuracy and throughput for the
channel. In alternate settings, we have noticed that usual victim
computation can evict the pointer from the L1 cache. The resulting
period of speculation is enough for our attack to work.
Further, we introduce instrumentation to obtain information
about the success of the BTI attack. This information is sup-
plied by the Performance Counter Monitor (PMC) infrastruc-
ture and can be obtained by using the msr kernel module. We