###  5.1 过渡提取
​ 在提取内部类和片段中的活动转换之前，我们先说明它们中的转换关系。图4 (a)是Vespucci地图编辑器的sub ATG。首先，activity
Main启动PrefEdititor，然后其中的PrefEditorFragment随着启动。PrefEditorFragment进一步启动AdvancedPrefEditor。具体来说，如图6所示，片段可以通过两种方式添加到一个活动中：
（1）通过调用片段修改API，例如“`replace()`，”`add()`”和进一步利用“`fragmenttransaction
.commit()`”（第34行）来启动片段；
（2）通过使用“`setAdapter`”（第6行）在特定视图中显示片段（例如，ViewPager）。PrefEditorFragment启动后，又开始一个新的活动（例如，AdvancedPrefEditor）。图4
(b)显示ADSdroid的sub
ATG，其中SearchPanel使用一个内部类SearchByPartName来处理耗时的操作，如图7所示。在完成任务后，它通过调用“`StartActivity()`”（第5行）来启动一个活动PartList。在这个例子中，我们的目标是提取活动转换:Main→PreEditor,
PreEditor→AdvancedPreEditor和SearchPanel→PartList。
​
算法1详细描述了ATG和渲染资源的提取，包括布局类型（即静态、动态或混合）和适配器映射关系。具体来说，它将apk作为输入，并输出活动转换图（`atg`）、适配器映射（`adapters`）和布局类型（`layout_type`）。我们首先将`atg`初始化为一个空集（第1行），它逐步存储活动转换。然后通过分析动态布局加载的存在性，生成给定布局的调用图（`cg`），得到布局类型API（2
– 3行）。对于每个类（`c`）中的每个方法（`m`），如果存在一个活动转换，我们首先通过分析Intent中的数据获得目标活动（`callee
act`）（行5-9）。如果方法（`m`）在内部类中，我们将外部类视为启动目标活动的活动，并将转换添加到atg（第10-12行）。以图4
(b)为例，我们将边缘SearchPanel→PartList添加到atg中。如果`m`在一个片段中，我们构造片段（`caller_frag`)和目标活动之间的关系（第13-14行）。注意，这个关系并不代表实际的活动转换，我们通过识别启动第19-22行片段的活动来优化它。这种关系用于A
TG构造和UI页面呈现。之后，我们通过合并片段关系来构造实际的活动转换来更新`atg`（第23行）。例如，在图4
(a)中，我们首先得到PrefEditorFragment→advedpreeditor和PrefEditor→PrefEditorFragment的关系，然后我们将它合并到PrefEditor→AdvancedPreEditor来表示实际的活动转换。对于既不在内部类中也不在片段中的方法`m`，我们从`m`开始向后遍历`cg`，以获得启动目标活动的所有活动（`callee
_act`），然后将它们添加到`atg`（第15-18行）。
​ 此外，为了补充需要使用不同类型的视图（如ListView, RecyclerView,
ViewPager）从数据提供者（如ContentProvider,
Preference）加载数据的UI布局，我们首先确定使用`Adapter`的方法并获得相应的视图类型（`view_type`）（第24-25行）。然后，我们利用适配器上的向后数据流分析来跟踪相应的布局文件，从而确定将嵌入以`view_type`显示的数据的布局/活动。我们将每个映射关系定义为一个元组——并将它们保存在用于UI渲染的`adatpers`中。以图3为例，我们将关系表示为。
###  5.2 UI页面渲染
​
在使用动态工具进行UI页面呈现时（例如，需要登录或特殊输入才能到达另一个活动），由于不同活动之间的数据依赖关系的限制，我们建议静态呈现UI页面。我们呈现的活动是每个活动的初始状态。对于只使用静态布局来显示UI页面的应用，我们可以直接提取相应的布局文件进行渲染。而对于动态/混合布局，我们需要解决两个挑战：
（1）将动态/混合布局转换为静态布局，因为不完整的布局无法准确呈现相应的UI页面
（2）用虚拟数据（文本、图像）填充动态数据加载区域，因为我们无法渲染从远程服务器加载动态数据的对应组件，涉及后台代码
​
为了解决这些问题，我们首先静态地分析活动源代码，并确定与布局填充相关的逻辑，包括添加新视图和修改视图的参数。然后我们将目标应用程序中的动态布局转换为静态布局。此外，由于我们的方法是基于静态分析的，无法获得动态加载的真实图像，如`ListView`和`GridView`。我们没有让这个位置保持朴素，而是用虚拟图像填充这个位置，这样用户就可以直接区别它和朴素的背景。否则，图像位置可能会被同一页面的其他组件抢占。我们将虚拟数据与算法1中识别的适配器关联起来，以不同的样式显示数据。通过翻译后的静态布局和虚拟的动态数据，我们将它们编译成apk来呈现UI页面。
​
算法2详细描述了UI页面渲染过程。它将活动转换图（`atg∗`）、适配器映射关系（`adapter`）、布局类型（`latout_type`）作为输入，并输出呈现的UI页面。我们首先从`atg∗`中提取所有的活动和片段，因为我们需要渲染活动ui和片段ui，以使它更接近真实的ui。对于每个活动/片段(`act`)，如果`act`使用静态布局，我们直接进行渲染。如果应用程序使用动态/混合布局，我们的目标是将动态组件及其属性添加到相应的父布局中。具体来说，我们首先提取并精确定位父布局（例如，LinearLayout）（第8行）。然后我们遍历每个方法(`m`)，通过关键字匹配(例如，`inflate`和`addView`)，并在`onCreate()`中向前分析视图相关变量的数据流。然后我们将`compt`添加到相应的父布局(第7-11行)。至于属性，如果它是通过调用另一个方法获得的，我们利用数据流分析来得到属性的定义，并将其附加到相应的组件(第12-13行)。否则，我们通过`getElementByName()`通过属性名在资源文件中标识相应的元素，并将其附加到`compt`(第15-16行)。在对动态组件的父布局进行修改之后，我们附加了新的`par`布局来作为`act`布局，并将其保存为布局格式，以便进一步呈现(第18-19行)。以图2为例，我们的方法能够将动态/混合布局转换为静态布局(即XML格式)。
​
此外，对于使用适配器显示数据，我们将每个适配器与活动匹配，并通过嵌入视图类型修改相应的布局，例如ListView、RecyclerView(第20-22行)以及虚拟数据。我们最终得到了一个视图树，并确保从源代码中添加了相应的属性。最后，我们构建了一个apk来渲染所有的活动和片段，并对实际应用程序中的每个UI进行截图保存(第23-24行)。
###  5.3 语义名称推断
​
在Android应用开发中，建议应用的活动名称包含语义，并以“activity”结尾，因此我们假设开发者定义的活动名称具有相应功能的基本语义。为了验证这个假设，我们从F-Droid中随机下载1000个应用程序，从每个应用程序中提取所有的活动名称，最后得到6767个活动名称。我们手动调查活动名称，并观察到大多数活动名称具有语义意义。然而，Android混淆技术经常用于谷歌Play应用程序，以保护其安全。活动名称会被翻译成“a”、“b”、“c”等简单的单词，完全失去了实际的语义意义。这些模糊的名称极大地阻碍了用户对故事板的理解。为了解决这个问题，因为活动布局文件在应用程序中不会混淆，所以我们建议通过比较待测活动与数据库中的现有活动布局层次(即ViewGroup和View)，自动推断混淆活动的语义名称。在本文中，我们将长度小于三个字母的活动名视为模糊活动名。为了推断混淆活动的语义名称，我们打算从开源应用程序的活动名称中学习。
​ 如图8 (a)所示，我们抓取了F-Droid上的所有应用(共计4426个)，并基于应用的布局层次构建了一个大型数据库进行相似性比较。布局层次结构是基于XML布局代码的布局树(如图8
(b))。树的根节点是一种ViewGroup类型，其他的ViewGroup和Views类型是添加到根节点的子节点。我们最终得到了13,792个带有布局层次结构的活动。给定模糊活动的XML文件(布局文件)和XML名称，我们通过以下三个步骤推断其语义名称：
(1)布局层次提取，从XML文件中提取布局树(T)
(2)相似度比较，利用树编辑距离(tree edit distance,
TED)算法[70]计算T与数据库中树的相似度，TED算法定义为节点编辑操作将一棵树转换成另一棵树的最小成本序列。根据随机抽取100个树对的初步研究，我们在TED中定义一个阈值为5，并过滤TED小于5的活动名作为候选
(3)排序与匹配，根据每个活动名称和对应布局名称(XML文件名)的出现频率，从候选活动中推断出活动名称。具体来说，我们根据活动名称的频率对其进行排名，使用正则表达式将驼峰式布局名称分割为多个单个单词，过滤掉“活动”、“布局”等一般单词，并通过关键字匹配将其与数据库中的单词进行比较。最匹配的活动名称将用于重命名混淆的活动名称。但是，如果布局名称与候选名称不匹配，则使用最频繁的名称重命名它。注意，尽管布局名称没有混淆，但如果我们只使用它们来推断语义名称是无效的，因为使用动态布局的活动没有静态布局，因此没有布局名称。
## 0x6 实现
​
我们实现了一个自动化工具STORYDROID，用3K行Java代码和2K行Python代码编写。STORYDROID构建在几个现成的工具之上：IC3、JADX和SOOT。我们使用SOOT提取UI页面呈现的输入，并从apks获取调用图。在IC3的基础上建立活动过渡提取，得到比较完整的ATG。JADX用于将apk反编译为Android应用程序的源代码。我们还使用JADX从每个apk中提取XML布局代码，这不会受到混淆的影响，因此不会影响语义名称推断方法。我们使用数据驱动文档（D3）来可视化STORYDROID的结果，它提供了一种基于HTML、JavaScript和CSS数据的可视化技术。可视化包含4部分：（1）带有活动名称和相应UI页面的ATG；（2）各UI页面布局代码；（3）各活动的功能代码；（4）每个活动中的方法调用关系。
## 0x7 效果评估
​ 在本节中，我们基于以下三个研究问题来评估STORYDROID的有效性：
  * **RQ1** ：STORYDROID能否为应用提取更完整的ATG，并实现比动态测试工具（如STOAT）更好的活动覆盖率?
  * **RQ2** ：STORYDROID能否渲染出与真实截图高度相似的UI页面?
  * **RQ3** ：STORYDROID能否为混淆的活动推断出准确的语义名称?
###  7.1 实验设置
​
为了研究处理片段和内部类的能力，我们自行开发了10个apps作为groundtruth基准，涵盖了我们声称要解决的不同特性（例如，活动，片段和内部类）。这是准确知道所有转换的唯一方法，即使是在片段或内部类中，这种方法在文献中被广泛使用。我们遵循以下特性来生成应用程序：（1）仅在活动中具有转换的应用程序；只在内部类中使用转换的应用程序；只有片段转换的应用程序；在活动和内部类中都有转换的应用程序；在活动和片段中都有转换的应用程序；（2）我们开发了2个app，每条规则下有7-10个活动。我们将IC3和STORYDROID分别应用于这10个应用并进行提取转换。此外，由于利益相关者更关心那些已经主导市场的热门竞争应用。为了模拟真实的场景，我们随机从GooglePlay
Store下载了50个应用，安装量超过1000万次，以演示STORYDROID在真实应用中的有效性。我们比较了由IC3和STORYDROID识别的迁移对的数量。我们还使用这100个应用程序来评估STORYDROID的活动覆盖率和最先进的动态测试工具STOAT，该工具已被证明在应用探索方面比其他工具（如MONKEY和SAPIENZ）更有效。具体来说，我们从AndroidManifest.xml中收集每个应用程序中定义的所有活动，并比较STORYDROID呈现的活动的数量和STOAT探索的活动的数量。
​
对于RQ2，我们评估静态呈现的UI页面与STOAT基于100个应用动态呈现的真实UI页面的相似性。STOAT配置了默认设置，并有30分钟时间来测试每个应用程序，以便收集已探索的活动。我们进一步在每个应用程序上应用STOAT来收集每个活动的截图。由于STOAT在给定的时间内只能探索应用程序的部分活动，为了公平的比较，我们只能通过STORYDROID比较探索活动与相应呈现活动的相似性。
​ 对于RQ3，为了证明推理语义名的准确性，我们从第四节中提取的6767个活动名中随机选择100个具有语义意义的活动名作为ground
truth。我们从源文件中收集相应的布局文件，并进一步利用我们基于TED的方法，基于我们的布局树集合（13,792个布局文件）获取100个活动的语义名。然后，我们将结果与原始活动名称进行比较，以评估我们的方法的准确性，即正确推断语义名称的比例。
###  7.2 实验结果
**RQ1**
：表一显示了在10个基础基准测试应用程序上处理片段和内部类的能力评估结果。我们可以看到，IC3能够在活动中提取转换，但是在片段和内部类中却很弱。相反，STORYDROID可以提取与所有这些特性相关的转换。因为我们通过使用特定的API（例如，StartActivity,
StartActivityForReulst，StrartActivityIfNeeded），使用数据流分析启动新活动，提取的转换更准确。结果证明了STORYDROID在提取活动转换方面的有效性，特别是在片段和内部类中。此外，我们还在图9
(a)中评估了STORYDROID与IC3相比在真实应用上的有效性。结果表明，STORYDROID提取的活动转换几乎是IC3的2倍，无论对于开源应用还是闭源应用，STORYDROID都比IC3更有效。
​
除了内部类和fragments的限制，根据我们的观察，在IC3中会丢失Android系统事件回调中的过渡。例如，(1)PodListen是一个播客播放器，并且在回调方法（`DownloadReceiver.onReceive()`）中存在一个活动转换，当BroadcastReceiver接收Intent广播时调用它。然而，IC3不能提取活动转换。(2)
CSipSimple是一个在线语音通信应用程序，其中系统回调方法（`SipService.adjustVolume()`）启动一个新的活动，但IC3无法识别过渡。
​ 图9
(b)描述了活动覆盖结果。平均而言，STORYDROID在活动覆盖率方面优于STOAT，开源应用和闭源应用的覆盖率分别为87%和74%。此外，与STOAT（即30分钟）相比，STORYDROID提取和呈现活动的时间（即平均3分钟）要少得多。由于逆向工程技术的限制，部分类和方法无法从apks中反编译，导致无法提取活动过渡和覆盖。由于封装和混淆，这种情况在闭源应用程序中更为严重。在我们评估的应用中，PodListen是唯一一个由于SubscribeDialog片段反编译失败导致STORYDROID的活动覆盖率低于STOAT的项目。（2）另一个原因是死活动（没有过渡），如应用中未使用的遗留代码和测试代码。
**RQ2**
：对于呈现的图像与STOAT获得的图像的相似度，我们使用两种广泛使用的图像相似度度量(即均值绝对)(MAE)和均方误差(MSE))来逐个像素地度量相似度。MAE测量的是预测值和实际值之间差异的平均幅度，MSE测量的是两者之间差异的平均平方。平均而言，我们渲染的图像在MAE和MSE方面分别达到84%和88%的相似度。不一致的原因解释如下。(1)组件中的一些数据是从web服务器或本地存储(如Preference、SD卡)动态加载的，如ListView的列表数据、TextView的文本数据、ImageView的图像背景。如图10
(a) (b)所示。(2)某些组件(如Button)在用户输入一些数据后，会改变其颜色或可见性。例如，如图10
(c)所示，当用户输入“昵称”时，按钮的颜色会发生变化。STORYDROID渲染活动的初始状态，从而减少了两个UI页面的相似性，但这并不影响对应用功能的理解。
**RQ3**
：根据我们的方法，100个活动名称中有92个是正确推断的，准确率是92%。为了证明和解释推断结果，我们随机选取了表二所列的10个案例。第一列是指groundtruth活动名称。根据与数据库中布局树的比较结果，我们根据第二列中每个名称的频率列出正确活动名称的排名。第三列是相应的XML布局名称。STORYDROID准确地推断出与基本事实相符的10个语义名称中的8个。TrackListAct.,
PersonalInfoAct.和SearchAct.(表二以灰色突出显示)，由于布局名称无法与候选名称进行匹配，所以我们选择第一级名称作为语义名称。其中有两处与事实不符。但是请注意，我们的方法的性能被严重低估了，尽管来自STORYDROID的一些推荐名称与实际情况不同，但它们实际上具有相似的含义，例如SearchAct.和Searcher.
。此外，随着我们数据库的扩大，准确性也将得到提高。总的来说，结果表明STORYDROID可以有效地推断混淆活动的语义名称。
>
> 注：STORYDROID在ATG提取上优于IC3，在更短的时间内比STOAT的提取活动多2倍。STORYDROID可以呈现与真实页面高度相似（84%）的UI页面，并准确（92%）推断混淆的活动名称的真实语义名称。
## 0x8 实用性评估
​
除了有效性评估，我们进一步进行了用户研究，以证明STORYDROID的实用性。我们的目标是检验：（1）STORYDROID是否能够有效地探索和理解应用的功能？（2）