the ones generated by a worm, for which one would expect connections between
multiple hosts from both the inside and outside networks.
7 Evaluation
7.1 Identifying Code Regions
The ﬁrst goal of the evaluation of the prototype system was to demonstrate that
the system is capable of distinguishing between code and non-code regions of net-
work streams. To accomplish this, the tool was executed over several datasets.
The ﬁrst dataset was composed of the ELF executables from the /bin and
/usr/bin directories of a Gentoo Linux x86 installation. The second dataset was
a collection of around 5 Gigabytes of media ﬁles (i.e., compressed audio and video
ﬁles). The third dataset was 1 Gigabyte of random output from OpenBSD 3.6’s
ARC4 random number generator. The ﬁnal dataset was a 1.5 Gigabyte selection
of texts from the Project Gutenberg electronic book archive. These datasets were
selected to reﬂect the types of data that might commonly be encountered by the
tool during the processing of real network traﬃc. For each of the datasets, the
total number of ﬁngerprints, total Kilobytes of data processed, and the number
of ﬁngerprints per Kilobyte of data were calculated. For this and all following
experiments, we use a value of 10 for k. The results are shown in Table 2.
Table 2. Fingerprint statistics for various datasets
Dataset
Executables
Media
Random
Text
Total Fingerprints Total KB Fingerprints/KB
128.673495
0.042569
0.042253
0.000036
18,882,894
209,348
43,267
54
146,750
4,917,802
1,024,000
1,503,997
By comparing the number of ﬁngerprints per Kilobyte of data for each of the
datasets, it is clear that the tool can distinguish valid code regions from other
types of network data. As asserted in Section 4, disassemblies that contain invalid
instruction sequences within basic blocks or a lack of suﬃciently connected basic
blocks produce many subgraphs with less than 10 nodes. Since a ﬁngerprint is
only produced for a subgraph with at least 10 nodes, one expects the rate of
ﬁngerprints per Kilobyte of data to be quite small, as we see for the media,
random, and text datasets. On the other hand, disassemblies that produce large,
strongly-connected graphs (such as those seen from valid executables) result in
a large rate of ﬁngerprints per Kilobyte, as we see from the executables dataset.
7.2 Fingerprint Function Behavior
As mentioned in Section 3, the ﬁngerprints generated by the prototype system
must ideally be “unique” so that diﬀerent subgraphs will not map to the same
220
C. Kruegel et al.
Table 3. Fingerprint collisions for coreutils dataset
Fingerprints Total Collisions Collision Rate Mismatched Coll. Mismatch Rate
83,033
17,320
20.86%
84
0.10%
ﬁngerprint. To evaluate the extent to which the system adheres to this property,
the following experiment was conducted to determine the rate of ﬁngerprint col-
lisions from non-identical subgraphs. The prototype was ﬁrst run over a set of 61
ELF executables from the Linux coreutils package that had been compiled with
debugging information intact, including the symbol table. The ﬁngerprints and
corresponding subgraphs produced during the run were extracted and recorded.
An analyzer then processed the subgraphs, correlating each node’s address with
the symbol table of the corresponding executable to determine the function from
which the subgraph was extracted. Finally, for those ﬁngerprints that were pro-
duced by subgraphs from multiple executables, the analyzer compared the list
of functions the subgraphs had been extracted from. The idea was to determine
whether the ﬁngerprint collision was a result of shared code or rather was a
violation of the ﬁngerprint uniqueness property. Here, we assume that if all sub-
graphs were extracted from functions that have the same name, they are the
result of the same code. The results of this experiment are shown in Table 3.
From the table, we can see that for the coreutils package, there is a rather large
ﬁngerprint collision rate, equal to about 21%. This, however, was an expected
result; the coreutils package was chosen as the dataset for this experiment in
part because all executables in the package are statically linked with a library
containing utility functions, called libfetish. Since static linking implies that
code sections are copied directly into executables that reference those sections,
a high degree of code sharing is present in this dataset, resulting in the observed
ﬁngerprint collision rate.
The mismatched collisions column records the number of ﬁngerprint collisions
between subgraphs that could not be traced to a common function. In these cases,
we must conclude that the ﬁngerprint uniqueness property has been violated,
and that two diﬀerent subgraphs have been ﬁngerprinted to the same value. The
number of such collisions in this experiment, however, was very small; the entire
run produced a mismatched collision rate of about 0.1%.
As a result of this experiment, we conclude that the prototype system pro-
duces ﬁngerprints that generally map to unique subgraphs with an acceptably
small collision rate. Additionally, this experiment also demonstrates that the
tool can reliably detect common subgraphs resulting from shared code across
multiple analysis targets.
7.3 Analysis of False Positive Rates
In order to evaluate the degree to which the system is prone to generating false
detections, we evaluated it on a dataset consisting of 35.7 Gigabyte of network
traﬃc collected over 9 days on the local network of the Distributed Systems
Polymorphic Worm Detection Using Structural Information of Executables
221
Table 4. Incorrectly labeled ﬁngerprints as a function of M. 1,400,174 total ﬁngerprints
were encountered in the evaluation set.
M
Fingerprints
M
Fingerprints
M
Fingerprints
3
4
5
11
12,661 7,841 7,215 3,647 3,441 3,019 2,515 1,219 1,174
20
23
18
43
19
24
17
43
10
8
9
6
15
150
24
22
7
16
44
25
22
12
1,134
21
22
13
944
22
22
14
623
23
22
Group at the Technical University of Vienna. This evaluation set contained
661,528 total network streams and was veriﬁed to be free of known attacks.
The data consists to a large extent of HTTP (about 45%) and SMTP (about
35%) traﬃc. The rest is made up of a wide variety of application traﬃc including
SSH, IMAP, DNS, NTP, FTP, and SMB traﬃc.
In this section, we explore the degree to which false positives can be mitigated
by appropriately selecting the detection parameter M. Recall that M determines
the number of unique source-destination pairs that a network stream set Si must
contain before the corresponding ﬁngerprint fi is considered to belong to a worm.
Also recall that we require that a certain ﬁngerprint must occur in network streams
between two or more internal and external hosts, respectively, before being consid-
ered as a worm candidate. False positives occur when legitimate network usage is
identiﬁed as worm activity by the system. For example, if a particular ﬁngerprint
appears in too many (benign) network ﬂows between multiple sources and desti-
nations, the system will identify the aggregate behavior as a worm attack. While
intuitively it can be seen that larger values of M reduce the number false positives,
they simultaneously delay the detection of a real worm outbreak.
Table 4 gives the number of ﬁngerprints identiﬁed by the system as suspi-
cious for various values of M. For comparison, 1,400,174 total ﬁngerprints were
observed in the evaluation set. This experiment indicates that increasing M be-
yond 20 achieves diminishing returns in the reduction of false positives (for this
traﬃc trace). The remainder of this section discusses the root causes of the false
detections for the 23 erroneously labeled ﬁngerprint values for M = 20.
The 23 stream sets associated with the false positive ﬁngerprints contained
a total of 8,452 HTTP network ﬂows. Closer inspection of these showed that
the bulk of the false alarms were the result of binary resources on the site that
were (a) frequently accessed by outside users and (b) replicated between two
internal web servers. These accounted for 8,325 ﬂows (98.5% of the total) and
consisted of:
– 5544 ﬂows (65.6%): An image appearing on most of the pages of a Java
programming language tutorial.
– 2148 ﬂows (25.4%): The image of the research group logo, which appears on
many local pages.
– 490 ﬂows (5.8%): A single Microsoft PowerPoint presentation.
222
C. Kruegel et al.
– 227 ﬂows (2.7%): Multiple PowerPoint presentations that were found to con-
tain common embedded images.
The remaining 43 ﬂows accounted for 0.5% of the total and consisted of ex-
ternal binary ﬁles that were accessed by local users and had ﬁngerprints that,
by random chance, collided with the 23 ﬂagged ﬁngerprints.
The problem of false positives caused by heavily accessed, locally hosted ﬁles
could be addressed by creating a white list of ﬁngerprints, gathered manually or
through the use of an automated web crawler. For example, if we had prepared
a white list for the 23 ﬁngerprints that occurred in the small number of image
ﬁles and the single PowerPoint presentation, we would not have reported a single
false positive during the test period of 9 days.
7.4 Detection Capabilities
In this section, we analyze the capabilities of our system to detect polymor-
phic worms. Polymorphism exists in two ﬂavors. On one hand, an attacker can
attempt to camouﬂage the nature of the malicious code using encryption. In
this case, many diﬀerent worm variations can be generated by encrypting the
payload with diﬀerent keys. However, the attacker has to prepend a decryption
routine before the payload. This decryption routine becomes the focus of de-
fense systems that attempt to identify encrypted malware. The other ﬂavor of
polymorphism (often referred to as metamorphism) includes techniques that aim
to modify the malicious code itself. These techniques include the renaming of
registers, the transposition of code blocks, and the substitution of instructions.
Of course, both techniques can be combined to disguise the decryption routine
of an encrypted worm using metamorphic techniques.
In our ﬁrst experiment, we analyzed malicious code that was disguised by
ADMmutate [11], a well-known polymorphic engine. ADMmutate operates by
ﬁrst encrypting the malicious payload, and then prepending a metamorphic de-
cryption routine. To evaluate our system, we used ADMmutate to generate 100
encrypted instances of a worm, which produced a diﬀerent decryption routine for
Table 5. Malware variant detection within families
Family
FIZZER
FRETHEM
KLEZ
KORGO
LOVGATE
MYWIFE
NIMDA
OPASERV
All
Variant Tests Matches Match Rate
100.00%
100.00%
100.00%
0.07%
100.00%
0.33%
100.00%
0.064%
16.97%
1
1
6
136
300
3
1
171
1,991
1
1
6
9
300
1
1
11
338
Polymorphic Worm Detection Using Structural Information of Executables
223
each run. Then, we used our system to identify common substructures between
these instances.
Our system could not identify a single ﬁngerprint that was common to all 100
instances. However, there were 66 instances that shared one ﬁngerprint, and 31
instances that shared another ﬁngerprint. Only 3 instances did not share a single
common ﬁngerprint at all. A closer analysis of the generated encryption routines
revealed that the structure was identical between all instances. However, ADM-
mutate heavily relies on instruction substitution to change the appearance of the
decryption routine. In some cases, data transfer instructions were present in a ba-
sic block, but not in the corresponding block of other instances. These diﬀerences
resulted in a diﬀerent coloring of the nodes of the control ﬂow graphs, leading
to the generation of diﬀerent ﬁngerprints. This experiment brings to attention
the possible negative impact of colored nodes on the detection. However, it also
demonstrates that the worm would have been detected quickly since a vast major-
ity of worm instances (97 out of 100) contain one of only two diﬀerent ﬁngerprints.
The aim of our second experiment was to analyze the structural similarities
between diﬀerent members of a worm family. Strictly speaking, members of a
worm family are not polymorphic per se, but the experiment provides evidence
of how much structural similarity is retained between variations of a certain
worm. This is important to understand how resilient our system is to a surge of
worm variations during an outbreak.
For this experiment, the prototype was run against 342 samples of malware vari-
ants from 93 distinct families. The ﬁngerprints generated for each of the malware
variants were extracted and recorded. An analyzer then performed a pairwise com-
parison between each member of each family, searching for common ﬁngerprints. If
a common ﬁngerprint was found, a match between the family variants was recorded.
Table 5 summarizes some of the more interesting results of this experiment.
From the results, one can see that certain malware variants retain signiﬁcant
structural similarity within their family. Notably, all 25 LOVGATE variants share
common structural characteristics with one another. There are, however, many
cases in which the structural characteristics between variants diﬀers greatly;
manual inspection using IDA Pro veriﬁed that our system was correct in not
reporting common ﬁngerprints as the CFGs were actually very diﬀerent. While
one might consider this disappointing, recall instead that it is rather diﬃcult for
an attacker to implement a worm that substantially and repeatedly mutates its
structure after each propagation while retaining its intended functionality. Thus,
the experiment should demonstrate that the prototype is capable of detecting
similarity between real-world examples of malware when it is present.
8 Limitations
One limitation of the current prototype is that it operates oﬀ-line. Our exper-
iments were performed on ﬁles that were captured from the network and later
analyzed. As future work, we plan to implement the necessary infrastructure to
operate the system on-line.
224
C. Kruegel et al.
Related to this problem is that our analysis is more complex, and, thus,
more costly than approaches that are based on substrings [6, 19]. Not only is it
necessary to parse the network stream into instructions, we also have to build the
control ﬂow graph, generate subgraphs, and perform canonical graph labeling.
While many network ﬂows do not contain executables, thus allowing us to abort
the analysis process at an early stage, performance improvements are necessary
to be able to deploy the system on-line on fast network links. Currently, our
system can analyze about 1 Megabyte of data per second. Most of the processing
time is spent disassembling the byte stream and generating the CFG.
A key advantage of our approach over the Earlybird [19] and Autograph [6]
systems is that our system is more robust to polymorphic modiﬁcations of a
malicious executable. This is due to the fact that we analyze the structure of an
executable instead of its byte stream representation. However, an attacker could