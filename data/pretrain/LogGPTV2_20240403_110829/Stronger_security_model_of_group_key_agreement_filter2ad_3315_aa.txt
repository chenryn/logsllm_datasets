title:Stronger security model of group key agreement
author:Jianjie Zhao and
Dawu Gu and
M. Choudary Gorantla
Stronger Security Model of Group Key Agreement
∗
M. Choudary Gorantla
PI:EMAIL
School of Information Security
Jianjie Zhao
Engineering
Dawu Gu
Department of Computer
Science and Engineering
Shanghai Jiao Tong University
Shanghai Jiao Tong University
Shanghai 200240, China
PI:EMAIL
Shanghai 200240, China
PI:EMAIL
ABSTRACT
In PKC 2009, Gorantla, Boyd and Gonz(cid:19)alez Nieto presented
a nice result on modelling security for group key agreemen-
t (GKA) protocols. They proposed a novel security model
(GBG model) that better supports the adversaries’ queries
than previous models for GKA protocols by considering KCI
resilience. However, ephemeral key leakage attack resistance
has been left outside the scope of the GBG model. In this
paper, we demonstrate an ephemeral key leakage on an exist-
ing GKA protocol which has been shown secure in the GBG
model. We then extend the GBG model by allowing the ad-
versary greater attack powers of leaking ephemeral keys in
GKA protocol session. We also apply the well known NAX-
OS trick to propose an improvement to an existing GKA
protocol, which can resist the ephemeral key leakage attack.
The security of the improved protocol has been argued under
the our new model.
Categories and Subject Descriptors
C.2.0 [Computer-Communication networks]: Gener-
al|Security and Protection, Data Communications
General Terms
Security, Algorithms, Design, Theory
Keywords
Group key agreement, Ephemeral key leakage attack, Secu-
rity model, Provable security
1.
INTRODUCTION
Recent rapid developments in networking and related mass
communication media and digital technology have opened
∗
Corresponding author; This work is partially supported by
Science and Technology Commission of Shanghai Municipal-
ity(10DZ1500202) and National Natural Science Foundation
of China (No.61073150).
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS ’11, March 22–24, 2011, Hong Kong, China.
Copyright 2011 ACM 978-1-4503-0564-8/11/03 ...$10.00.
extensive possibilities for group applications. Group appli-
cations represent a special case of multi-party applications
where the participants have some unifying relationship con-
cerning their rights, responsibility and application goals [16].
Some well known group applications are digital conferences,
text-based group communication, (cid:12)le and data sharing etc.
Similar to other applications, security is a major concern
in these applications where group members would like to
prevent outsiders from obtaining sensitive communication
content. The detailed information on the security issues for
group applications can be found in [16].
Group key establishment is a cryptographic protocol that
enables a set of users to establish a common secret session
key by communicating over a public channel. This ses-
sion key can be applied for subsequent cryptographic us-
age. Group key establishment can be divided in two di(cid:11)er-
ent classes: group key distribution (GKD) and group key
agreement (GKA). In GKD protocols, a trusted party (ei-
ther a third party or a group member) called group manager
distributes the session key securely to the members of the
group. In contrast, a GKA protocol allows all the partici-
pants to establish the session key where no party is needed
to be chosen as the key generator and/or distributor and
no secure channel is required. In this paper, we restrict our
research to GKA protocols.
Although there are many security models [3, 12, 15, 1, 18,
19, 4] for two or three-party key agreement protocols, the
formal model proposed by Bresson, Chevassut, Pointcheval
and Quisquater [10], which we refer to as the BCPQ model,
is the (cid:12)rst security model for GKA protocols. Following the
work of Bresson, Chevassut and Pointcheval [8] (BCP mod-
el) that extended the BCPQ model to the dynamic mem-
bership case, they [9] revised the BCP model to meet the
internal state information reveal resistance (BCP+) model.
However, these models do not consider any malicious be-
haviour by the participants themselves. In CCS 2005, Katz
and Shin [14] proposed a security model for GKA protocol,
which provides the (cid:12)rst formal treatment of security of G-
KA in the presence of malicious participants (or insiders).
Bohli, Gonz(cid:19)alez-Vasco and Steinwandt [5] (BGS model) and
Bresson and Manulis [11] (BM model) later proposed two
extensions of the KS model under di(cid:11)erent corruption mod-
els. Additionally, the BGS and BM models deal with the
issue of contributiveness in the presence of insiders.
All the models above provide de(cid:12)nitions that consider the
requirements on indistinguishability of computed group keys
and forward secrecy. However, as discussed by Gorantla et
al. [13] the above security notions do not consider key com-
435
promise impersonation (KCI) resilience. To demonstrate the
importance of considering resistance to KCI attacks for G-
KA protocols, they presented KCI attacks on GKA protocols
in di(cid:11)erent settings [6, 2, 7]. Gorantla et al. then proposed
a new model (GBG model) by taking KCI resilience into
account and also showed that the protocol of Bohli et al. [5]
(BGS protocol) to be secure in the GBG model.
Inspired by Manulis et al.’s recent work [17] where the au-
thors pointed out that the GKA security models have so far
not considered leakage of ephemeral keys, we augment the
GBG model by considering ephemeral key leakage. In our
new model, we allow the adversary to reveal any long-term
key and ephemeral key of participants involved except for
both long-term key and ephemeral key of one of the partici-
pants of the test session. We then improve the BGS protocol
and show that it is secure in the new model. More specially,
we have the following results:
1. A stronger security model for GKA protocols. We pro-
pose a new model for GKA protocols which provides
the adversary more attack capabilities than those in
earlier models.
2. An attack on the BGS protocol and its improvement.
We (cid:12)rst show that the BGS protocol is not secure in
the proposed security model. To avoid this drawback,
a solution where the ephemeral secret result will be
generated by the hash function of the long-term key
and the ephemeral key is put forward. This technique
is known as the NAXOS trick in the literature [15].
3. A straightforward security proof in the new model. Un-
der some well-studied assumptions, we prove that the
improved BGS protocol is secure in our new model.
We begin with a brief review of the GBG model and dis-
cuss the attack not covered by their model in Section 2. We
also give a simple ephemeral key leakage attack on the BGS
protocol in the same section. Section 3 introduces our ex-
tended GBG model. In Section 4, we present an improved
version of the BGS protocol which can resist the ephemeral
key leakage attack. The formal security argument about the
improved BGS protocol is given in Section 5.
2. THE GBG MODEL AND THE BGS PRO-
TOCOL
In this section, we give an overview the GBG model and
point out that the ephemeral key leakage attack is not cov-
ered by it. Then we present this attack on the BGS protocol
which has been proven secure in the GBG model.
2.1 Overview of GBG model
The GBG model [13] provides a formal security assurance
to GKA protocols. We give a high-level overview of the
GBG model in this subsection.
Participants. A GKA protocol runs in a network of
multiple interconnected participants where each participant
is activated to run multiple sessions with its peers. As a
result, participants in each such successful session establish
a key called a session key. We denote the participant set by
U = {U1; U2;··· ; Un} and the protocol may be run among
any subset of these parties. In a GKA protocol, each partici-
pant may execute a polynomial number of protocol instances
436
∏
i
U .
∏
in parallel. We refer to the i-th instance of protocol run at
U ∈ U as
Adversary model. The communication network is as-
sumed to be fully controlled by an adversary M , that is, it
may eavesdrop, delay, alter and insert messages during the
run of the protocol at will. We de(cid:12)ne the security of a GKA
protocol by a game between a challenger and the adversary
M (an outsider adversary or a malicious insider) in which
the adversary must solve a challenge given by the challenger
to be considered successful. In this games, M is allowed to
ask the following queries in any sequence.
Execute(
i
U ). This query returns the protocol messages
i
that were exchanged during the honest execution
U
of the protocol. This query models the passive attacks.
∏
∏
∏
Send(
i
U ; m). The adversary makes this query to obtain
i
U would generate on
the message that the instance
receipt of the message m. If m is an empty message
the i-th instance of the protcol will be initiated at U .
RevealKey(
i
U ). This query returns the session key es-
tablished at the accepted instance
∏
i
U .
Corrup(U ). The adversary makes this query to obtain the
long-term key of the participant U .
∏
∏
∏
i
U ). The query returns the internal state
i
U ). We assume that the internal state is erased
i
U has accepted. Hence, a RevealState query
of (
once
to an accepted instance returns nothing.
∏
i
U ). Only one query of this type is allowed to be
i
asked by the adversary on an accepted instance
U
at any time. To respond to this query, a random bit
b ∈ {0; 1} is secretly chosen. If b = 1, then the real ses-
i
U ) is returned. Otherwise,
sion key established at (
a uniformly chosen random value from the session key
distribution is returned.
∏
RevealState(
∏
∏
Test(
∏
We now de(cid:12)ne the AKE security, the MA security and
the Contributiveness based on the de(cid:12)nitions of partner
and freshness.
∏
∏
i
De(cid:12)nition 1 (Partner). Informally, an instance
U is said
to be accepted if it goes into an accept state after receiving
the last expected protocol message, that is, when an instance
accepts, it holds a session key, a unique session identi(cid:12)er sid
and a partner identi(cid:12)er pid. We assume that sid for each
session is generated during the run of the protocol. The pid
i
U is a set of identities of the parties with
of an instance
i
U wants to establish a session. It also includes the
whom
identity of U itself. The information of whether an instance
has terminated with acceptance or not is assumed to be
j
U′ at
known to the adversary. Two instances
two di(cid:11)erent parties U and U
respectively are considered
partnered i(cid:11)
i
U and
∏
∏
′
1. Both the instances have accepted.
2. The session identi(cid:12)ers of
3. The partner identi(cid:12)ers of
i
U and
i
U and
j
U′ are the same.
j
U′ are the same.
De(cid:12)nition 2 (Freshness). An instance
following conditions hold:
i
U is fresh if the
∏
∏
∏
∏
∏
∏
∏
1. The instance
i
U or any its partner has not been asked
a RevealKey query after their acceptance.
2. The instance
i
U or any its partner has not been asked
a RevealState query before their acceptance.
j
U′
is a partner of
), then any message that M sends to
j
U′ must come from
j
U′ intended to
i
U .
i
U and M asked Corrupt
i
U on behalf
∏
∏
′
3. If
(U
of
∏
∏
∏
∏
∏
De(cid:12)nition 3 (AKE security). In Stage 1, an adversary
MAKE against the AKE security notion is allowed to make
all the queries de(cid:12)ned above. MAKE makes Test query to
i
an instance
U at the end of Stage 1 and is given a challenge
key Kb. It can continue asking queries in Stage 2. Finally,
and wins the AKE security game if
MAKE outputs a bit b
i
(1) b = b
U that was asked Test query
remained fresh till the end of MAKE’s execution. We de(cid:12)ne
the advantage of MAKE in winning the AKE security game
= b]− 1|. A protocol is called AKE
as AdvMAKE = |2· P r[b