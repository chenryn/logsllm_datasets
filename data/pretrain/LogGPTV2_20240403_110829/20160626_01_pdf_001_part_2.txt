• Datum retvals[4]; // 返回值子类
• bool retnulls[4]; // 返回值子类是否为空
• HeapTuple rettuple; // 返回tuple
• // get the tuple header of 1st argument
• th = PG_GETARG_HEAPTUPLEHEADER(0);
• // get argument Datum's and convert them to int32
• a = DatumGetInt32(GetAttributeByName(th, "a", &aisnull)); // 从composite c type获取子类
Datum并转换为C type
• b = DatumGetInt32(GetAttributeByName(th, "b", &bisnull));
• c = DatumGetInt32(GetAttributeByName(th, "c", &cisnull));
返回 例子
record
• // debug: report the extracted field values
• ereport(INFO,
• (errmsg("arg: (a: %d,b: %d, c: %d)", a, b, c)) );
• // set up tuple descriptor for result info
• get_call_result_type(fcinfo, &resultTypeId, &resultTupleDesc);
• // check that SQL function definition is set up to return arecord
• Assert(resultTypeId == TYPEFUNC_COMPOSITE);
• // make the tuple descriptor known to postgres as valid return type
• BlessTupleDesc(resultTupleDesc);
• retvals[0] = Int32GetDatum(c); // 构造返回值子集
• retvals[1] = Int32GetDatum(b);
• retvals[2] = Int32GetDatum(a);
• retvals[3] = Int32GetDatum(retvals[0]*retvals[1]+retvals[2]);
• retnulls[0] = aisnull;
• retnulls[1] = bisnull;
• retnulls[2] = cisnull;
• retnulls[3] = aisnull || bisnull || cisnull;
• rettuple = heap_form_tuple( resultTupleDesc, retvals, retnulls ); // 构造tuple
• PG_RETURN_DATUM( HeapTupleGetDatum( rettuple ) ); // 返回Datum
• }
返回表 例子
(SRF)
• 伪代码
• Datum
• my_set_returning_function(PG_FUNCTION_ARGS)
• {
• FuncCallContext *funcctx;
• Datum result;
• further declarations as needed
• if (SRF_IS_FIRSTCALL()) // 判断该函数是否在该会话第一次被调用
• {
• MemoryContext oldcontext;
• funcctx = SRF_FIRSTCALL_INIT(); // 初始化FuncCallContext
• oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);
• /* One-time setup code appears here: */
• user code
• if returning composite
• build TupleDesc, and perhaps AttInMetadata
• endif returning composite
• user code
• MemoryContextSwitchTo(oldcontext);
• }
返回表 例子
(SRF)
• /* Each-time setup code appears here: */
• user code
• funcctx = SRF_PERCALL_SETUP(); // 清除之前调用产生的结果
• user code
• /* this is just one way we might test whether we are done: */
• if (funcctx->call_cntr max_calls)
• {
• /* Here we want to return another item: */
• user code
• obtain result Datum
• SRF_RETURN_NEXT(funcctx, result); // 返回一条记录，循环往复
• }
• else
• {
• /* Here we are done returning items and just need to clean up: */
• user code
• SRF_RETURN_DONE(funcctx); // 调用结束，返回
• }
• }
示例
• #include 
• #include "postgres.h"
• #include "fmgr.h"
• PG_MODULE_MAGIC; // V1 C UDF
• PG_FUNCTION_INFO_V1(text_reverse); // 声明
• /*
• * Return reversed string
• */
• Datum
• text_reverse(PG_FUNCTION_ARGS)
• {
• text *str = PG_GETARG_TEXT_PP(0);
• const char *p = VARDATA_ANY(str);
• int len = VARSIZE_ANY_EXHDR(str);
• const char *endp = p + len;
• text *result;
• char *dst;
• result = palloc(len + VARHDRSZ);
• dst = (char *) VARDATA(result) + len;
• SET_VARSIZE(result, len + VARHDRSZ);
示例
• if (pg_database_encoding_max_length() > 1)
• {
• /* multibyte version */
• while (p 1 和1就是操作符时指定了它的commutator是是它的commutator。
• 另外需要注意，有commutator操作符的操作符的左右两
侧的参数类型必须一致，这样才能满足x op1 y等价于y
op2 x。
• 优化器如何利用commutator呢？例如索引扫描，列必须
在操作符的左侧才能使用索引。1 > tbl.c这个条件，如
果>没有commutator的话，是不能使用索引的。
如何自定义操作符
• 2. negator，指 x op1 y 等价于 not(y op2 x)，或
者 等价于 ，或者 等价于
x op1 not( y op2) op1 x
，因此 支持一元和二元操作
not(op2 y) negator
符。
• 例子 :
• 如果 =和 <>是一对 negator操作符， NOT (x = y)
可以替换为 。
x <> y
• 同样，操作符两侧参数 x,y的类型必须一致。并
且仅适用于返回布尔逻辑类型的操作符。
如何自定义操作符
• 3. restrict，是用于评估选择性的函数，仅适
用于二元操作符，例如 ，这
where col>100
个查询条件，如何评估选择性呢？是通过
操作符的 来指定的，选择性乘以
restrict
就可以评估得到这个查询
pg_class.reltuples
条件的行数。
如何自定义操作符
• 4. join，是 joinsel即 join的选择性计算函数。
• 对应 pg_operator.oprjoin
• 5. hashes
• 6. merges
• hashes和 merges表示该操作符是否允许 hash
和 只有返回布尔逻辑值的二
join merge join,
元操作符满足这个要求。
自定义操作符例子
• Datum
• citext_ne(PG_FUNCTION_ARGS)
• {
• text *left = PG_GETARG_TEXT_PP(0);
• text *right = PG_GETARG_TEXT_PP(1);
• char *lcstr,
• *rcstr;
• bool result;
• /* We can't compare lengths in advance of downcasing ... */
• lcstr = str_tolower(VARDATA_ANY(left), VARSIZE_ANY_EXHDR(left), DEFAULT_COLLATION_OID);
• rcstr = str_tolower(VARDATA_ANY(right), VARSIZE_ANY_EXHDR(right), DEFAULT_COLLATION_OID);
• /*
• * Since we only care about equality or not-equality, we can avoid all the
• * expense of strcoll() here, and just do bitwise comparison.
• */
• result = (strcmp(lcstr, rcstr) != 0);
• pfree(lcstr);
• pfree(rcstr);
• PG_FREE_IF_COPY(left, 0);
• PG_FREE_IF_COPY(right, 1);
• PG_RETURN_BOOL(result);
• }
自定义操作符例子
• CREATE FUNCTION citext_ne( citext, citext )
• RETURNS bool
• AS 'MODULE_PATHNAME'
• LANGUAGE C IMMUTABLE STRICT;
• CREATE OPERATOR <> (
• LEFTARG = CITEXT,
• RIGHTARG = CITEXT, x <> y
• NEGATOR = =, 等价于
• COMMUTATOR = <>,
not( x = y )
• PROCEDURE = citext_ne,
• RESTRICT = neqsel,
• JOIN = neqjoinsel
• );
• 等效优化
• https://yq.aliyun.com/articles/51131
自定义索引语法
• 扩展索引语法
• CREATE OPERATOR CLASS name [ DEFAULT ] FOR TYPE data_type
• USING index_method [ FAMILY family_name ] AS
• { OPERATOR strategy_number operator_name [ ( op_type,
op_type ) ] [ FOR SEARCH | FOR ORDER BY sort_family_name ]
• | FUNCTION support_number [ ( op_type [ , op_type ] ) ]
function_name ( argument_type [, ...] )
• | STORAGE storage_type
• } [, ... ]
• 操作符strategy_number、函数support_number
• https://www.postgresql.org/docs/9.5/static/xindex.html
开放索引接口介绍
• GIN
– 索引结构 value : (ctid1, ctid2, .... )
– https://www.postgresql.org/docs/9.5/static/gin.html
– 开发接口
– https://www.postgresql.org/docs/9.5/static/gin-extensibility.html
– int compare(Datum a, Datum b)
• 比较两个element
– Datum *extractValue(Datum itemValue, int32 *nkeys, bool **nullFlags)
• 输入ctid返回对应行所在列存储的elements
– Datum *extractQuery(Datum query, int32 *nkeys, StrategyNumber n, bool **pmatch, Pointer
**extra_data, bool **nullFlags, int32 *searchMode)
• column op query 返回对应行(s)所在列存储的elements
– bool consistent(bool check[], StrategyNumber n, Datum query, int32 nkeys, Pointer extra_data[],
bool *recheck, Datum queryKeys[], bool nullFlags[])
• column op query 返回 true or false
– GinTernaryValue triConsistent(GinTernaryValue check[], StrategyNumber n, Datum query, int32 nkeys,
Pointer extra_data[], Datum queryKeys[], bool nullFlags[])
• GIN_TRUE, GIN_FALSE and GIN_MAYBE(需要recheck, lossy部分).
• 例子
– array, ts, hstore