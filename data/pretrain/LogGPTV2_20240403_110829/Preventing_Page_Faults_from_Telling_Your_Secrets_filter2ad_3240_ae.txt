1.311
28.563
1.840
23.744
10.623
3.558
Ovh (%)
-3.08
-10.15
29.22
7413.66
3.67
-4.80
4.26
-8.89
-12.23
-3.41
-5.57
-1.10
1.057
10.836
0.546
10.174
8.295
3.737
81.18
96.82
99.16
93.28
67.31
70.66
Average Performance Overhead
5.615
340.579
65.029
151.490
25.378
12.734
• No Leakage.
In Libgcrypt implementations of Blowﬁsh,
Camellia, DES, 3DES, IDEA, RC5, Serpent, Twoﬁsh, ECDSA,
and SHA512, all the input-dependent code and data memory
accesses are conﬁned within a page for the sensitive portions.
Similarly AES, Blowﬁsh, Camellia, DES, 3DES, IDEA, RC5,
Serpent, Twoﬁsh, DSA, RSA, and SHA512 in OpenSSL do
not exhibit leakage via page fault side channel.
• Leakage via input dependent code page access. In Libgcrypt,
EdDSA and powm exhibit input dependent code access across
pages and are vulnerable to pigeonhole attacks. The powm
function is used in ElGamal, DSA and RSA which leaks bits
of information about the secret exponents.
• Leakage via input dependent data page access. In case of
AES, CAST5, SEED, Stribog, Tiger and Whirlpool imple-
mentations in Libgcrypt, at least one of the S-Boxes crosses
page boundary and leaks information about the secret in-
puts. Similarly, implementations of CAST5 and SEED in
OpenSSL are also vulnerable.
6.2 Application to Case Studies
We transform the 8 Libgcrypt and 2 OpenSSL vulnerable imple-
mentations of our case studies in our evaluation.
Compiler Toolchain Implementation. We implement our automa-
tion tool in LLVM 3.4 and Clang 3.4 C / C++ front-end to transform
C / C++ applications [1,6]. For our case studies, we log all the anal-
ysis information which is used for the layout analysis and also to
facilitate our developer-assisted improvements study. Our transfor-
mation pass applies deterministic multiplexing to the programs at
the LLVM IR level.
Empirical Validation. Our applications are compiled into static
binaries for testing. We run these executables on PODARCH [44]
which is implemented on QEMU emulator, and only supports static
linking. To test our patched applications, we execute the stan-
dard regression test-suite available with the cryptographic libraries
(make check). To empirically validate that our defenses work,
we ensure that the page fault proﬁle of patched executions under
all test inputs is indistinguishable w.r.t. page access proﬁles. To
verify the correctness, we analyze the page fault access patterns
in the transformed application using a PinTool [4] that logs all in-
structions and memory accesses. We have analyzed the PinTools
logs and report that our deterministic multiplexing produces indis-
tinguishable page access proﬁles for all regression and test inputs.
6.3 Performance Evaluation
Normalized Baseline. To ensure that the choice of our evaluation
platform (PODARCH) does not signiﬁcantly bias the overheads, we
conduct two sets of measurements. First, we run the unmodiﬁed
OpenSSL and Libgcrypt implementations on PODARCH and mea-
sure the execution time. This forms the baseline for all our perfor-
mance measurements. Column 3, 4 in Table 2 shows the number of
page faults and the execution time for vanilla code in PODARCH.
Second, to check that the overheads of our defenses are not an arti-
fact of PODARCH, we also run our vanilla and modiﬁed binaries on
native Intel CPU Intel Core i7-2600 CPU. The overheads on a na-
tive CPU are similar to that on PODARCH and deviate only within
a range of 1%. This conﬁrms that our baseline of PODARCH does
not skew our experimental results signiﬁcantly.
Overhead. We calculate the overhead by comparing the base-
line performance of unmodiﬁed code against the execution time of
the patched application functions. We use input patterns to repre-
sent the best, worst and average case executions of the application,
speciﬁcally, inputs with (a) all 0s, (b) all 1s, (c) random number
of 0s and 1s, and (d) all the regression tests from the built-in test-
suite.
The applications patched with the deterministic multiplexing tech-
nique incurs an average overhead of 705× and up to maximum
overhead of 4000× in case of powm (Column 10 in Table 2). To
investigate the main sources of these overheads we measure the
break-down for the fetch step and the execute step in deterministic
multiplexing. We observe that the overhead is mainly dominated
by the copying of data to and from the staging area in the fetch step
(Column 6 and 9 in Table 2), and accounts for 76.5% out of the
total overhead on average. We notice that the fetch step time is es-
pecially high for cases like Stribog and Tiger where it accounts for
96.82% and 99.16% of the overhead.
6.4 Effectiveness of Optimizations
We apply the developer-assisted strategies discussed in Section 5
to experimentally validate and demonstrate their effectiveness. They
reduce the average overhead from 705× to −2.7% for our 10 case
studies; 29.22% in the worst case. In the case of powm, O3 reduces
the performance overhead from 4000× to 74×. With O4 we com-
pletely remove memory copying for code determinization which
reduces the overhead from 74× to 3.67%. We apply O1 to the 8
cases of input dependent data page access to reduce the number of
copy operations. Further we also apply O2 to reorder the lookup
table layout, such that after the developer-assisted transformations
are in place, the execution incurs lower page faults. In fact, our
patched version executes faster than the baseline code (as denoted
by negative overhead in Column 14 in Table 2) for 7 cases. After
manual inspection, this is explained because in the patched code,
the lookup tables take up less number of pages which reduces the
total number of page faults incurred during the execution (Column
12 in Table 2). On the other hand, in the vanilla case, the program
incurs more page faults which is a costly operation. Thus, eliminat-
ing this cost results in a negative overhead. For EdDSA, we directly
apply the peephole optimization O5 which transforms the input de-
pendent code access to data access. This reduces the overhead from
3000× to 29.22%.
7. HARDWARE-ENABLED DEFENSES
So far we have discussed purely software solutions. Readers
might wonder if pigeonhole attacks can be mitigated with hardware
support. Here, we brieﬂy discuss an alternative hardware-assisted
defense which guarantees enclaved execution at an average cost of
6.77% for our benchmarks.
7.1 Our Proposal: Contractual Execution
We propose a hardware-software technique wherein the enclave
is guaranteed by the hardware that certain virtual addresses will al-
ways be mapped to physical memory during its execution. The en-
clave application is coded optimistically assuming that the OS will
always allocate speciﬁc number of physical pages to it while exe-
cuting its sensitive code blocks. The enclave informs its memory
requirements to the OS via a callback mechanism. These require-
ments act as a contract if the OS agrees, or else the OS can refuse to
start execution of the enclave. The enclave states the set of virtual
addresses explicitly to the OS before starting its sensitive compu-
tation. The CPU acts as a contract mediator and is responsible for
enforcing this guarantee on the OS. We term such an execution as
contractual execution. Note that the contract is not a hard guarantee
i.e., the enclave cannot pin the pages in physical memory to launch
a denial-of-service attack on the OS. In fact, the OS has the ﬂexibil-
ity to take back pages as per its own scheduling policy. However,
when the CPU observes that OS has deviated from the contract —
either genuinely or by injecting random faults, it immediately re-
ports the contract violation to the enclave. This needs two types
of changes in the hardware (a) support for notifying the enclave
about its own page faults and (b) guaranteeing a safe mechanism
for enclave to mitigate the contract violation.
Contract Enforcement in SGX. In a traditional CPU as well as in
original SGX speciﬁcation [7], all page faults are reported directly
to the OS without the intervention of the faulting process. Thus, the
process is unaware of its own page faults. This makes it impossible
for the enclave to detect pigeonhole attacks. For contractual execu-
tion, the hardware needs to report its faults to the process instead,
which calls for a change in the page fault semantics. A limited
amount of support is already available for this in SGX. As per the
new amendments in Revision 2, SGX can now notify an enclave
about its page faults by setting the SECS.MISCSELECT.EXINFO
bit [8, 10]. When an enclave faults, the SGX hardware notiﬁes the
enclave about the fault, along with the virtual address, type of fault,
the permissions of the page, register context. We can think of im-
plementing contractual execution on SGX directly by setting the
SGX conﬁguration bit such that when there is a page fault, the
enclave will be notiﬁed directly by the CPU. The benign OS is
expected to respect the contract and never swap out the pages dur-
ing the execution. However a malicious OS may swap out pages,
Figure 9: Contractual Execution. (1) Enclave registers a con-
tract (2) CPU directly reports the fault to the enclave page fault
handler. (3) Enclave page fault handler fakes access for time t
- k and sends command to terminate. (4) Enclave fault han-
dler terminates the enclave.
in which case the CPU is responsible for reporting page faults for
these pages to the enclave directly.
Mitigating Contract Violation. When the CPU signals contract
violation and the control returns to the enclave, it is important to
terminate the program safely, without leaking any information (See
Figure 9). When the enclave is notiﬁed about contract violation, it
is the enclaves responsibility to decide whether to handle the fault
or ignore it. One straightforward way to handle the fault is termi-
nate the enclave, but our observation is that immediate program ter-
mination leaks information. In our solution, our goal is to hide the
following facts (a) whether the enclave incurred a page fault dur-
ing the execution after the contract is enforced (b) if so, at which
point in the execution tree did the fault occur. To this end, in our
defense we intercept the page faults from the underlying hardware
and from that point of contract violation, we perform a fake exe-
cution to suppress the location at which the fault happened. This
defense can only work if we can ensure that the enclave page fault
handler is necessarily invoked. In the present SGX design it is un-
clear if the hardware can guarantee the invocation of the page fault
handler. So we propose that SGX can adopt this solution in the
future. The details of this mechanism are a bit involved and for
brevity we discuss it in the extended version for interested read-
ers [43]. We have implemented this defense in PODARCH and our
evaluation on Libgcrypt 8 shows that such an approach incurs an
overhead of 6.77% which is much lower as compared to the purely
software based solutions (Table 3). We elide the details here due to
space limits. Please refer to [43] for details.
7.2 Discussion: Other Alternative Approaches
Randomization of Page Access. Oblivious RAM (ORAM) is a
generic defense that randomizes the data access patterns [25, 46].
Intuition suggests that the enclave can use ORAM techniques to
conceal its memory access pattern. In this case, when an adver-
sary observes the physical storage locations accessed, the ORAM
algorithm will ensure that the adversary has negligible probability
of learning anything about the true (logical) access pattern. For our
AES example, we can place the tables in an ORAM to randomize
their ordering, such that the adversary cannot distinguish which off-
sets in the tables are accessed. However, ORAM involves continu-
ous shufﬂing and re-encryption of the data after every access. In our
case studies, the lookup operations dominate the computation in
cryptographic implementations. For millions of accesses, the cost
incurred for the shufﬂing is signiﬁcant poly log (say over 1000×)
and slows down the applications, which is not desirable [42]. Fur-
8We did not implement contractual execution for OpenSSL be-
cause it requires dynamic loading which is not supported in PO-
DARCH.
Malicious OSCPU4Sensitive ComputationEnclave Fault Handler:get kwait (t-k )terminate ()EnclaveBucket:{P1, P2, P3, P4}213Table 3: Evaluation. Column 2 denotes the bucket size (Code + Data). Columns 5 and 7 denote average execution time and deviation
in benign OS. Columns 8-10 denote total time spent for 3 test-case scenarios that stress the corner cases in Libgcrypt. Both the
executions exhibit no statistically signiﬁcant differences.
Cases
AES
CAST5
EdDSA
powm
SEED
Stribog
Tiger
Whirlpool
Bucket
Size
3 + 3
1 + 2
19 + 1
21 + 1
2 + 2
1 + 5
1 + 3
1 + 5
PF
Handler
(Bytes)
274
231
204
256
261
253
244
245
Benign OS
Malicious OS
Vanilla
Time (ms)
4.157
2.901
9729.526
4783.997
1.269
0.803
0.506
12.680
Contractual
Time (ms)
4.161
2.969
9754.806