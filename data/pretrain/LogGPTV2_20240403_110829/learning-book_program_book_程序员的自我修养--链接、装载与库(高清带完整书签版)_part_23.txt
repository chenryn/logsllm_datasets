2e:
83  c4 24
add
59
pop
$0x24, $esp
§d
$ecx
30 :
2 f :
8d 61 fc
pop
1ea
tebp
0xfffffffc ($ecx), $esp
:
c3
ret
我们知道在程序的代码里面使用的都是虚拟地址，在这里也可以看到“main”的起始
地址为0x00000000，这是因为在未进行前面提到过的空间分配之前，目标文件代码
段中的起始地址以0x00000000开始，等到空间分配完成以后，各个函数才会确定自
已在虚拟地址空间中的位置。
我们可以很清楚地看到“ao”的反汇编结果中，“ao”共定义了一个函数main。这个
函数占用0x33个字节，共17条指令：最左边那列是每条指令的偏移量，每一行代表一条指
令（有些指令的长度很长，如第偏移为0x18的mov指令，它的二进制显示占据了两行）。
条“mov”指令，这条指令总共8个字节，它的作用是将“shared”的地址赋值到ESP寄存
器+4的偏移地址中去，前面4个字节是指令码，后面4个字节是“shared”的地址，我们只
关心后面的4个字节部分，如图4-4所示。
因为它们定义在其他目标文件中。所以编译器就暂时把地址0看作是“shared”的地址，我
程序员的自我修养一链接、装载与库
---
## Page 128
4.2符号解析与重定位
105
mov的脂令码
C4 44 24 04
00 00 00 00
shared的址址
图4-4绝对地址指令
另外一个是偏移为0x26的指令的一条调用指令，它其实就表示对swap函数的调用，如
图 4-5所示。
相对偏移调用指令cal的瘤令码
E8FC FF FF FF
目的地址相对于下一条指令的编移
图4-5相对地址指令
这条指令共5个字节，前面的 0xE8 是操作码（Operation Code），从 Intel 的IA-32 体系
软件开发者手册（1A-32 Intel Architecture Software Developer's Manual，参考文献里有详细介
绍）可以查阅到，这条指令是一条近址相对位移调用指令（Callnear,relative，displacement
令的偏移量。在没有重定位之前，相对偏移被置为OxFFFFFFFC（小端），它是常量“-4”
的补码形式。
让我们米仔细看这条指令的含义。紧跟在这条call指令后面的那条指令为add指令，add
指令的地址为0x2b.而相对于add指令偏移为“4”的地址即0x2b-4=0x27.所以这条
call指令的实际调用地址为0x27、我们可以看到0x27存放着并不是swap函数的地址，跟前
面“shared”一样，“OxFFFFFFFC”只是一个临时的假地址，因为在编译的时候，编译器并
不知道“swap”的真正地址。
编译器把这两条指令的地址部分暂时用地址“0x00000000”和“0xFFFFFFFC”代替着，
把真正的地址计算工作留给了链接器。我们通过前面的空间与地址分配可以得如，链接器在
完成地址和空间分配之后就已经可以确定所有符号的虚拟地址了，那么链接器就可以根据符
程序员的自我修养一链接、装载与库
---
## Page 129
106
第4章静态链接
号的地址对每个需要重定位的指令进行地位修正。我们用objdump来反汇编输出程序“ab”
的代码段，可以看到main函数的两个重定位入口都已经被修正到正确的位置：
$objdunp -d ab
ab:
file format elf32-i386
Disassenbly of section -text :
08048094 :
8048094 :
8d 4c 24 04
lea
0x4($esp),$ecx
8048098 :
83 e4 f0
and
:q60808
ff 71 fc
push1
Oxfffffffc (eecx)
:960808
55
89 e5
push
8ebp
804809f :
80480a11
AOU
$esp, tebp
83 ec 24
51
pu8h
$0x24,tesp
$ecx
80480a2:
64 00 00 00
sub
: 9e0808
c7 44 24 04 08 91 04
c745
f8
mOV1
s0x64, 0xfffffff8($ebp)
80480ac:
mov1
$0x8049108,0x4(%e8p)
80480b3 :
80480b4 :
8d 45 f8
80
1,90808
1ea
890424
10000
mov
80480ba1
e8 09 00
ca11
8008708
seax, (tesp)
80480bf :
80480c2 :
83 c4 24
add
Becx
S0x24, te8p
80480c3:
65
5d
pop
pop
Lea
dqag
80480c4 :
8d 61 fc
0xfffrrrrc(kecx), tesp
80480c7:
ret
080480c8 :
80480c8:
55
pushsebp
- - -
经过修正以后，“shared”和“swap”的地址分别为0x08049108和0x00000009（小端字
节序）。关于“shared”很好理解，因为“shared”变量的地址的确是0x08049108，对于“swap”
来说稍显酶涩。我们前面介绍过，这个“call”指令是一条近址相对位移调用指令，它后面
式”一节，那里我们将更加详细介绍指令修正时的地址计算方式。
4.2.2重定位表
那么链接器是怎么知道哪些指令是要被调整的呢？这些指令的哪些部分要被调整？怎
文件中，有一个叫重定位表（RelocationTable）的结构专门用来保存这些与重定位相关的
信息，我们在前面介绍ELF文件结构时已经提到过了重定位表，它在ELF文件中往往是
个或多个段。
程序员的自我修养一链接、装载与库
---
## Page 130
4.2符号解析与重定位
107
对于可重定位的ELF文件来说，它必须包含有重定位表，用来描述如何修改相应的段
里的内容。对于每个要被重定位的ELF段都有一个对应的重定位表，面一个重定位表往往
就是ELF文件中的一个段，所以其实重定位表也可以叫重定位段，我们在这里统一称作重
定位表。比如代码段“Jext”如有要被重定位的地方，那么会有一个相对应叫“rel.text”的
叫“rel.data”的段保存了数据段的重定位表。我们可以使用objdump来查看目标文件的重
定位表：
$ objdunp -r a.o
a.0:
file format elf32i386
RELOCATION RECORDS FOR [ .teXt] :
0000001c R_386_32
OFPSET
VALUE
00000027 R_386_PC32
shared
swap
地址。每个要被重定位的地方叫一个重定位入口（RelocationEntry），我们可以看到“a.o”
里面有两个重定位入口。重定位入口的偏移（Oset）表示该入口在要被重定位的段中的位
置，“RELOCATIONRECORDSFOR[text]”表示这个重定位表是代码段的重定位表，所以
偏移表示代码段中须要被调整的位置。对照前面的反汇编结果可以知道，这里的0xlc和0x27
对于32位的Intelx86系列处理器来说，重定位表的结构也很简单，它是一个Elf32_Rel
结构的数组，每个数组元素对应一个重定位入口。Ef32_Rel的定义如下：
typedef struct(
E1f32_word r_info;
)E1f32_Rel;
重定位入口的偏移，对于可重定位文件来说，这个值是该重定位入口所要修正的位
置的第一个字节相对于没起始的偏移：对于可扶行文件或共享对象文件来说，这个
r_offset
值是谊重定位入口所要修正的位置的第一个字节的虚拟地址。
我们这里只关心可重定位文件的情况，可执行文件或共享对象文件的情况，将在下
一章“动态链接”再作分析
重定位入口的类型和持号，这个成员的低8位表示重定位入口的类型，高24位表
示重定位入口的符号在符号表中的下标。
r_info
因为各种处理器的指令格式不一样，所以重定位所修正的指令地垃格式也不一样。
每种处理器都有自己一套重定位入口的类型，对于可执行文件和共享目标文件来
说，它们的重定位入口是动态链接类型的，请参考“动态链楼”一章
程序员的自我修养一链接、装载与库
---
## Page 131
108
第4章静态链接
4.2.3符号解析
在我们通常的观念里，之所以要链接是因为我们目标文件中用到的符号被定义在其他目
标文件，所以要将它们链接起来。比如我们直接使用Id来链接“a.o”，面不将“b.o”作为
输入。链接器就会发现shared和swap两个符号没有被定义，没有办法完成链接工作：
$ 1d a.o
a.c:(.text•0xlc): undefined reference to ^shared*
a.c:(.text+0x27): undefined reference to *swap*
这也是我们平时在编写程序的时候最常碰到的问题之一，就是链接时符号未定义。导致
这个问题的原因很多，最常见的一般都是链接时缺少了某个库，或者输入目标文件路径不正
确或符号的声明与定义不一样。所以从普通程序员的角度看，符号的解析占据了链接过程的
主要内容。
通过前面指令重定位的介绍，我们可以更加深层次地理解为什么缺少符号的定义会导致
链接错误。其实重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，
也可能引用到定义在其他目标文件的符号，重定位的过程中，每个重定位的入口都是对一个
符号的引用，那么当链接器须要对某个符号的引用进行重定位时，它就要确定这个符号的目
标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相
应的符号后进行重定位。
比如我们查看“ao”的符号表：
*e 9- apea $
Symbol table ',symtab' contains 10 entries1
Num:
0：000000OO0 NOTYPELOCALDEFAULTUND
Ndx Name
1：
000000000FILE
0 SECTION LOCAL
LOCAL
DEFAULT
DEFAULT
ABS a,c
21
00000000
00000000
0SBCTION LOCAL
DEFAULT
DEFAULT
4:
5:
00000000
10 SECTION
LOCAL
DEFAULT
00000000
52 FUNC
GLOBAL DEFAULT 1 nain
9: 00000000 0 NOTYPE GLOBAL DEFAULT UND SWap