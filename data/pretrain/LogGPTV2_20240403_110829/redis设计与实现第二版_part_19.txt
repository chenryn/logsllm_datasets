服务器已经自动将它们删除了，但实际上这些键仍然存在，而且键所占用的内存也没有释
消息。
会自己去释放它们，这对于运行状态非常依赖于内存的Redis 服务器来说，肯定不是一个好
可以将这种情况看作是一种内存泄漏一—无用的垃圾数据占用了大量的内存，而服务器却不
访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至
然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。
理的键，这个策略不会在删除其他无关的过期键上花费任何CPU 时间。
这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处
9.5.2惰性删除
的访问就会大大减少，甚至不再访问，如果这类过期数据大量地积压在数据库中，用户以为
性删除策略的缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍
性删除策略对CPU 时间来说是最友好的：程序只会在取出键时才对键进行过期检查，
在前一节，我们讨论了定时删除、情性删除和定期删除三种过期键删除策略，Redis 服
举个例子，对于一些和时间有关的数据，比如日志（log），在某个时间点之后，对它们
在使用性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被
因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行
口 如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和性删除策
口如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时
定期删除策略的难点是确定删除操作执行的时长和频率：
口 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的
口 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的
定期删除策略是前两种策略的一种整合和折中：
口 性删除浪费太多内存，有内存泄漏的危险。
口 定时删除占用太多CPU 时间，影响服务器的响应时间和吞吐量。
从上面对定时删除和情性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷：
Redis 的过期键删除策略
略一样，出现浪费内存的情况。
删除策略，以至于将CPU 时间过多地消耗在删除过期键上面。
内存浪费。
时长和频率来减少删除操作对CPU时间的影响。
---
## Page 113
服务器周期性操作 redis.c/serverCron 函数执行时，activeExpireCycle 函数就会
9.6.2定期删除策略的实现
是否存在以及键是否过期，然后根据判断来执行合适的动作。
个命令的实现函数都必须能同时处理键存在以及键不存在这两种情况：
输人键，从而避免命令接触到过期键。
Redis 命令在执行之前都会调用expireIfNeeded 函数对输人键进行检查：
9.6.1
中，我们将对 Redis 服务器中惰性删除和定期删除的具体实现进行说明。
以很好地在合理使用CPU 时间和避免浪费内存空间之间取得平衡。
过期键的定期删除策略由 redis.c/activeExpireCycle 函数实现，每当 Redis 的
另外，因为每个被访问的键都可能因为过期而被 éxpireIfNeeded 函数删除，所以每
图9-15命令调用expireIfNeeded 来删除过期键
过期键的情性删除策略由 db.c/expireIfNeeded 函数实现，所有读写数据库的
因为前一节已经介绍过情性删除和定期删除两种策略的概念了，在接下来的两个小节
举个例子，图9-16展示了GET命令的执行过程，在这个执行过程中，命令需要判断键
口 当键不存在或者键因为过期而被expireIfNeeded 函数删除时，命令按照键不存
口当键存在时，命令按照键存在的情况执行。
expireIfNeeded 函数就像一个过滤器，它可以在命令真正执行之前，过滤掉过期的
命令调用expireIfNeeded 函数的过程如图 9-15 所示。
 如果输人键未过期，那么 expireIfNeeded 函数不做动作。
口 如果输人键已经过期，那么 expireIfNeeded 函数将输人键从数据库中删除。
在的情况执行。
SET.LRANGE、SADD、 HGET、KEYS等
惰性删除策略的实现
删除键
调用expirelINeeded函数
所有读写数据库的命令
执行实际的命令流程
输人键已经过期？
否
图9-16GET 命令的执行过程
返回键key的值
键已过期？
删除过期键
V
键不存在？
GET 
第9章数据库+109
返回空回复
是
---
## Page 114
110·第二部分单机数据库的实现
典中随机检查一部分键的过期时间，并删除其中的过期键。
被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的 expires 字
activeExpireCycle函数的工作模式可以总结如下：
整个过程可以用伪代码描述如下：
def activeExpireCycle():
#全局变量，
#默认每个数据库检查的键数量
DEFAULT_DB_NUMBERS =
鲁默认每次检查的数据库数量
for i
#遍历各个数据库
else:
if server.dbnum  SUBSCRIBE.
数据库通知是 Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频
从服务器在接收到主服务器发来的
假设在此之后，有客户端向主服务器发送命令GETmessage，那么主服务器将发现键
如果这时有客户端向从服务器发送命令 GET message，那么从服务器将发现 me ssage
数据库通知
客户端
)
数据库
主服务器
YYY
xxx
GET message
(niI)
图 9-19主从服务器删除过期键（3）
图9-18主从服务器删除过期键（2）
_keyspace@o
eae)
从服务器
//订阅信息
主服务器
数据库
数据库
YYY
XXX
YYY
xXx
返回message键的值
 DEL message
GET message
图9-20主从服务器删除过期键（4）
主服务器
数据库
YYY
xXx
客户端
数据库
从服务器
YYY
XXX
第9章数据库·113
从服务器
数据库
YYY
xxx
---
## Page 118
114·第二部分单机数据库的实现
置，Redis 的官方文档已经做了很详细的介绍，这里不再赘述。
DEL命令的键：
个命令被什么键执行了”。
除此之外，还有另一类称为键事件通知（key-event notification）的通知，它们关注的是“某
操作。
这一类关注“某个键执行了什么命令”的通知称为键空间通知（key-space notification）,
以下是一个键事件通知的例子，代码展示了客户端如何获取0号数据库中所有执行
关于数据库通知功能的详细用法，以及 notify-keyspace-events 选项的更多设
根据发回的通知显示，先后共有 SET、EXPIRE、DEL 三个命令对键 me ssage 进行了
口想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为E1。
口想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$。
口想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE。
口想让服务器发送所有类型的键空间通知，可以将选项的值设置为 AK。
口想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为 AKE。
根据发回的通知显示，key、number、message 三个键先后执行了 DEL命令。
127.0.0.1:6379> SUBSCRIBE
2
八
?
3) (integer) 1
"message"
"number"
"message"
"key"
"message"
"subscribe"
"del"
"expire"
"message"
"message"
"message"
"abessaw:- -ogaoedsray
_:del"
._:message"
keyeventeo_
//键message 执行了DEL命令
//键 number 执行了 DEL 命令
//键key执行了 DEL命令
//订阅信息
//执行DEL 命令
//执行 EXPIRE 命令
//执行 SET命令
---
## Page 119
行 SADD 命令所产生的通知)。
KeyspaceEvent 函数，并向函数传递传递该命令所引发的事件的相关信息。
码，函数会根据type 参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。
送通知。
就是服务器配置 notify-keyspace-events 选项所选定的通知类型，从而决定是否发
9.8.1发送通知