这个代码编辑器Tab”，而只能告诉代码评审者“这段代码还没有通过测试”。
供及时的反馈，它们只能被称为批量测试。这些测试不能告诉工程师“先不要关掉
需要同时协调很多服务器与容器的测试通常仅仅启动就要数秒，
反馈信息
计算容器中运行几秒完成的。这些测试可以在工程师切换工作环境之前提供及时的
大部分测试都是很简单的，意味着它们是用一个密闭型、
测试截止时间
一般是一次测试所运行的一小
自包含的测试文件在某个
，这样的测试无法提
大规模测试
169
197
<198
---
## Page 212
6
170
有效的API和ABI管理工具，以及大规模的解释性语言让每几分钟编译和执行一次新的
藏其中。于是，上次更新的可靠性数据对下次来说没有任何意义。
测试也是一样。由于每次发布中产生了非常多的修改，肯定会有某些用户可见的问题隐
户培训和其他因素上。这些发布流程的平均失败时间（MTBF）是一年，不管再写多少
高，但是并没有什么需要去进行自动化的。发布成本主要集中于文档化、数据迁移、用
数天产生，同时大部分的测试都是由人针对书面流程手工执行的。这种发布流程效率不
不久以前，软件项目还是每年发布一次。二进制文件由一套编译系统执行数小时，甚至
允许测试失败
测试的失败比其他测试预示了更大的风险。
的不确定性呢？很明显，某些测试覆盖区域要比其他区域更敏感。通用一点来说：某些
受一个测试系统给出1/10不正确的反馈，那么完全迁移之后我们到底能够接受什么程度
测试结构下最坏的可能是什么呢？正如前文所说，我们已经假设一个软件工程师能够接
我们来考虑一种统一的版本化和测试化场景，以便可以使用SRE方法论。迁移到分布式
导致整个研发的停滞，因为危险总是不可能完全消除的。
这可能会影响想要在开发环境中重现这种不一致问题的工程师。但是至少这种分离不会
在SRE模型下，生产环境和测试环境的分离可能也会导致生产环境和测试环境的不一致，
本控制系统之间经常需要互相协调。
套工具行为上的不一致。同时，这样的分离也会导致项目发布速度的下降，因为两套版
题。这样的分离同时容易造成重复开发工具。在Ops环境中，这种不一致可能会导致两
两套测试环境在最好的情况下也是很烦人的，最差情况下会严重导致可靠性和敏捷性问
在传统的企业环境中，开发者负责编译可执行文件，然后由另外一批管理者更新服务器。
结构下进行。测试自动化系统经常忽略这类地方。
存放在同一个代码仓库中，配置文件的修改也常常在分支上进行，或者是在不同的目录
存放。同样的，软件测试基础设施通常不会使用生产环境配置文件。就算两个配置文件
生产环境的配置信息通常来说保存在版本控制系统中，配置文件通常和源代码文件分开
发布到生产环境
预示着这些独立的测试必须要以99.9999%的概率正确执行（这很难）。
00012 ×266 0 
第17章
测试可靠性
---
## Page 213
注15可能是通过类似AmazonMechanicalTurk这样的服务招聘而来的。
平均修复时间（MTTR）保持在较低的水平。然而，很多配置文件的修改并不需要这种
配置文件的存在是因为修改配置要比重新构建一个工具要快。这种快速迭代是为了保障
工具”一小节中提到了SRE工具如何提高测试覆盖度，这里我们讨论的是测试决定SRE
要等待监控系统提供更多的分析数据来排除不确定性。在本章前面“测试大规模使用的
降低以历史数据预测未来的自信（因为可能产生了尚未发现的Bug），这种自信的降低需
需要SRE手工参与时，SRE所使用的工具必须是经过合理测试的。否则，这项操作将会
能研发团队的目标是控制不确定性以达到他们预期的发布节奏。SRE团队则拥有另外一
要将可靠性预算按功能划分，甚至（更容易的）按团队划分。在这种情况下，一个新功
结合起来，调节发布的节奏。这种组合可以最大化从运维中和实际用户那里得到的反馈
进行测试。如果这些测试被建立起来，每项测试都可以确保问题未来不再重现。仔细的
用户有更多的机会接触到有问题的版本。然而，我们可以从此得出哪些区域需要更多地
如果我们让用户在一年中测试更多的版本，平均失败周期（MTBF）反而会下降，因为
试相结合是非常有效的。
从而确保根源问题而不仅仅是表面现象得到了修复。缩短反馈周期这种理念与自动化测
得到了测试。使用这些中间版本，我们可以很自信地将发现的问题与根源问题相对应，
种方式发布的版本会比年度发布的代码质量高。因为在年度测试之外，所有中间版本也
个版本，从而获得同样的发布质量。虽然同样的测试最终会运行在同样的代码上，用这
软件版本成为了可能。理论上来说，足够多的人注15可以利用前述的方法完整地测试每一
快速迭代，从可靠性的视角来看：
可以安全使用这些工具的频率。
行。为了达到无人值守目标，生产环境必须能够应对小型的失败问题。当一项重大问题
为了让服务更可靠，避免SRE团队人数线性增长，生产环境必须做到基本上无人值守运
套可靠性预算，以控制他们修改生产环境的节奏。
个功能），道理是一样的。如果我们根据可靠程度来决定发布的节奏，那么很多时候需
如果SRE修改了某个配置文件，或者调节了某种自动化工具的策略（而不是新实现了某
信息。这些反馈信息可以更好地驱动测试覆盖度，从而驱动产品发布速度。
可靠性管理可以将对不确定性的限制（由代码测试覆盖度决定）与用户可见问题的控制
·如果一个配置文件的存在是为了保证MTTR足够低，但是仅仅在系统出现问题
分造成影响。
这项修改其实引入了很大程度的不确定性，因为不知道这项修改是否会对其他部
的时候才会修改，那么这个配置文件的修改频率比系统的MTBF还要低。那么
大规模测试
171
200
---
## Page 214
load）可以将维护配置文件的成本降低。精心挑选的语法和分析器可以为配置文件加载
如果配置文件是用一种特殊语法的文本格式写成的，那么每种测试覆盖度都需要从零实
测试可以在合理时间内结束。
的测试之外，我们应该将这种类型的集成测试中加入小心的截止时间检查，以确保某些
实际意义的上限（你不知道加载配置文件的过程需要多少资源、时间等）。在其他类型
使用解释性语言编写配置文件是有风险的，因为这种方式经常会导致无法完全定位的潜
入的运行时，同时一些简单的沙盒机制可以应对一些非恶意的代码错误。
难性的。解释性语言（Python等）经常被用来处理配置文件，因为它们提供了一个可嵌
用单元测试测试某个配置文件可以提高可靠性之外，针对配置文件进行集成测试也很重
集成
部，同时想办法强制执行这条规定。如果你采用上述第二种做法，那么请保证：
正确处理配置文件的一种方式是规定每个配置文件都是上述两种可能性之一，而不是全
172
在问题。因为加载一个配置文件实际上是执行了一段程序，该程序的执行时间没有任何
要。配置文件的内容（以测试角度来看）有可能对解释执行这段文件的解释器来说是灾
应急机制可以抢占常规测试的工作负载，以便更快地提供反馈。
布可以很快地被另一次（希望是没那么多问题的）手动发布而替代。理想情况下
测试失败之后（最快速度下）标记之前的发布事件。这样，一次有问题的手动发
好我们能在后台继续运行测试，将发布动作与正在执行的测试关联起来，然后在
发布的人无法获知任何错误反馈，直到监控系统汇报最终用户已经受到影响。最
我们可以部属一套应急机制，以绕开发布测试，但是这样做会导致使用这个机制
·配置文件的修改比软件更新要更频繁（例如，保存了某种更新信息的配置文件），
）在发布之前，对文件的修改需要等待发布测试的完成。
·每个配置文件都有足够的测试覆盖度，以确保可以经常修改。
可靠性，通常情况下可以让执行应急机制（例如）自动提交一份Bug报告，以便
提供一种应急机制以确保可以在测试完成之前将文件发布。由于应急机制会影响
影响。
没有比应用程序的做得更好，那么这个配置文件可能会对可靠性带来很大的负面
这类修改如果不认真对待也会产生重大风险。如果对这个配置文件的测试和监控
下次使用更好的方案处理该问题。
第17章测试可靠性
应急机制和测试
---
## Page 215
我们可以将任两类作为集成测试和发布测试，大部分测试也可以用来作为监控探针。
划分为可针对生产环境重放，和不可针对生产环境重放。这就产生了如下三类请求：
常是一个好主意。我们可以在每次发布测试时重放这些请求。将已知的正确请求进一步
已知的正确请求应该成功，而已知的错误请求应该失败。将这两种情形作为集成测试通
和未知问题，但是实际的危险性是更复杂的情况。
数据输入下确认系统行为可以接受。看起来通过测试和监控，我们可以覆盖主要的已知
由于测试机制是通过提供确定的数据检验系统行为是否可接受，而监控机制则是在未知
生产环境探针
只在于汇报问题，所以这个工具不应该试着自我修复这个错误（通过删除用户数据）。
量和（一半的）用户列表之间的区别，同时紧急汇报这种不一致情况。这个工具的作用
识不到有问题发生。但是负责维护用户目录的工具可以很容易地发现实际存在的目录数
停止了。因为最近加入的用户没有被处理，这个机器可能还在正常运行，很多用户都意
/etc/passwd），同时针对这个文件的一项编辑意外导致了解释器处理了一半文件之后就
举例来说，假设一个配置文件包含了一系列用户（例如非联网环境下的UNIX机器内的
复，甚至不能停止目前的行为，但是最少可以在造成严重问题前汇报检测到的问题。
者某些其他工具的输入检查器）可以汇报这些问题。出现异常的工具可能并不能自我修
保障网站可靠性的关键因素在于找到某种可预期的异常情况，然后确保有某些测试（或
分其他工具具有足够的信心，以便利用其他工具解决或者缓解之前异常工具带来的问题。
多个层面上建立防范机制。当某一个工具行为出现异常时，工程师必须对他们的绝大部
的验证性测试。所有工具都可能由于测试时没有发现的问题而行为失常，所以我们要在
SRE的职责经常包括编写系统工程工具准7（如果没有其他人写的话），和为服务增加可靠
从而避免发生更多的问题，同时能提供良好的运行时上限。
使用ProtocolBuffer注1这种架构的好处在于提前定义了格式，在加载时可以自动检查，
经常是没有运行时上限的。更糟的是，这些策略通常都不是可靠地测试过的。
过程提供运行时上限。但是，实现者仍需要处理配置文件结构错误，最简单的处理方式
跨多个抽象层，这种类型的工具的开发团队经验比较少，系统管理员团队较多。
不是因为软件开发工程师不写这类工具，
已知的正确请求，不可以针对生产重放。
已知的正确请求，
已知的错误请求。
可以针对生产重放。
，而是这类工具通常需要纵越不同的技术领域，以及同时横
大规模测试
173
202
---
## Page 216
大部分API。
版发布时）还不能正常工作的API。最好能确保这些探针都有向前兼容性，同时能覆盖
新版本程序使用过时的API。或者，旧版本程序在联络新版本程序时，使用当时（在旧
假设每个组件都有旧版本和新版本同时运行。新版本可能会跟旧版本的服务联络，强迫
返回得越早越有用。最好这种测试是自动化的，这样这种方式也变得可扩展。
生产环境探针测试确实对服务提供了保障，提供了一种清晰的反馈信号。这种反馈信息
并且让生产环境更新工具执行回滚。
会发往该新版本。本次更新保持停止状态，直到工程师有时间和精力来解决为什么出错，
短暂的不健康状态。如果初始化没有成功，更新工具会安全地停止更新，没有用户请求
到之前正确的配置上。通常情况下，更新工具预计每个新开启的应用程序实例会有一段
往新旧服务器的4种情况在持续进行着。如果生产系统更新工具检测到错误，就会回滚
生产系统更新工具逐渐替换应用服务器的同时也逐渐替换掉这些探针，所以新旧探针发
两种环境为什么存在不一致，服务很可能没有正常工作。
或者后端API（持久化存储）在测试环境和发布环境中是不一致的。除非你已经知道这
这些探针应该永远不会失败，但是如果失败了意味着什么呢？前端API（负载均衡器）
因此，生产环境监控探针测试了一种之前没有测试过的配置。
被试过两次了。但是这两种请求可能由于以下几种原因不同：
可能从理念上来看起来，部属这种监控探针是没有意义的，因为这些测试请求已经至少
174
进制文件加入前端服务器发布包中。
团队可以同时发布伪后端服务器、生产后端服务器和探针程序。同时可以将这个二
这种构建时依赖可以提供一个可以运行的二进制文件，理想情况下，维护它的研发
务器和伪后端服务器。
这种密闭型的由测试基础设施执行的测试可保证永远使用相同代码版本测试前端服
当实现发布测试时，伪后端（fakebackend）经常由伙伴研发团队维护，用作构建依赖，