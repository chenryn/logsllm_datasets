的各个领域，越来越多的人开始依赖软件工作和生活。
与传统的产品相比，软件产品具有根本的不同，其生产过程也有着
根本的差异。在开发软件的整个过程中，存在非常多的不确定性因素。
在一个软件真正完成之前，它的完成日期是很难预计的。很多软件项目
都经历了多次的延期，还有很多中途夭折了。直到今天，人们还没有找
到一种有效的方法来控制软件的生产过程。导致软件生产难以控制的根
本原因是源自软件本身的复杂性。一个软件的规模越大，它的复杂度也
越高。
简单来说，软件是程序（program）和文档（document）的集合，
程序的核心内容便是按一定顺序排列的一系列指令（instruction）。如
果把每个指令看作一块积木，那么软件开发就是使用这些积木修建一个
让CPU（中央处理器）在其中运行的交通系统。这个系统中有很多条不
同特征的道路（函数）。有些道路只允许一辆车在上面行驶，一辆车驶
出后另一辆才能进入；有些道路可以让无数辆车同时在上面行驶。这些
道路都是单行道，只可以沿一个方向行驶。在这些道路之间，除了明确
的入口（entry）和出口（exit）之外，还可以通过中断和异常等机制从
一条路飞越到另一条，再由另一条飞转到第三条或直接飞回到第一条。
在这个系统中行驶的车辆也很特殊，它们速度很快，而且“无人驾驶”，
完全不知道会跑到哪里，唯一的原则就是驶入一条路便沿着它向前
跑……
如果说软件的执行过程就像是CPU在无数条道路（指令流）间飞
奔，那么开发软件的过程就是设计和构建这个交通网络的过程。其基本
目标是要让CPU在这个网络中奔跑时可以完成需求（requirement）中所
定义的功能。对这个网络的其他要求通常还有可靠（reliable）、灵活
（flexible）、健壮（robust）和易于维护（maintainable），开发者通过
简单的改造就能让其他类型的车辆（CPU）在上面行驶（portable）
……
开发一个满足以上要求的软件系统不是一件简单的事，通常需要经
历分析（analysis）、设计（design）、编码（code）和测试（test）等多
个环节。通过测试并发布（release）后，还需要维护（maintain）和支
持（support）工作。在以上环节中，每一步都可能遇到这样那样的技术
难题。
在软件世界中，螺丝刀、万用表等传统的探测工具和修理工具都不
再适用了，取而代之的是以调试器为核心的各种软件调试（software
debugging）工具。
软件调试的基本手段有断点、单步执行、栈回溯等，其初衷就是跟
踪和记录CPU执行软件的过程，把动态的瞬间“凝固”下来，以供检查和
分析。
软件调试的基本目标是定位软件中存在的设计错误（bug）。但除
此之外，软件调试技术和工具还有很多其他用途，比如分析软件的工作
原理、分析系统崩溃、辅助解决系统和硬件问题等。
综上所述，软件是通过指令的组合来指挥硬件，既简单又复杂，是
个充满神秘与挑战的世界。而软件调试是帮助人们探索和征服这个神秘
世界的有力工具。
第1章 软件调试基础
著名的计算机科学家布莱恩·柯林汉（Brian Kernighan）说过，“软
件调试要比编写代码困难一倍，如果你发挥了最大才智编写代码，那么
你的智商便不足以调试它。”
此外，软件调试是软件开发和维护中非常繁重的一项任务，几乎在
软件生命周期的每个阶段，都有很多问题需要调试。
一方面是难度很高，另一方面是任务很多。因此，在一个典型的软
件团队中，花费在软件调试上的人力和时间通常是很可观的。据不完全
统计，一半以上的软件工程师把一半以上的时间用在软件调试上。很多
时候，调试一个软件问题可能就需要几天乃至几周的时间。从这个角度
来看，提高软件工程师的调试效率对于提高软件团队的工作效率有着重
要意义。
本书旨在从多个角度和多个层次解析软件调试的原理、方法和技
巧。在深入介绍这些内容之前，本章将做一个概括性的介绍，让读者了
解一个简单的全貌，为阅读后面的章节做准备。
1.1 简介
本节首先给出软件调试的解释性定义，然后介绍软件调试的基本过
程。
1.1.1 定义
什么是软件调试？我们不妨从英文的原词software debug说起。
debug是在bug一词前面加上词头de，意思是分离和去除bug。
bug的本意就是“昆虫”，但早在19世纪时，人们就开始用这个词来
描述电子设备中的设计缺欠。著名发明家托马斯·阿尔瓦·爱迪生（1847
—1931）就用这个词来描述电路方面的设计错误。
关于bug一词在计算机方面的应用，业内流传着一个有趣的故事。
20世纪40年代，当时的电子计算机体积非常庞大，数量也非常少，主要
用在军事领域。1944年制造完成的Mark I、1946年2月开始运行的
ENIAC（Electronic Numerical Integrator and Computer）和1947年完成的
Mark II是其中赫赫有名的几台。Mark I是由哈佛大学的Howard Aiken教
授设计，由IBM公司制造的。Mark II是由美国海军出资制造的。与使用
电子管制造的ENIAC不同，Mark I和Mark II主要是用开关和继电器制造
的。另外，Mark I和Mark II都是从纸带或磁带上读取指令并执行的，因
此它们不属于从内存读取和执行指令的存储程序计算机（stored-program
computer）。
1947年9月9日，当人们测试Mark II计算机时，它突然发生了故障。
经过几个小时的检查后，工作人员发现一只飞蛾被打死在面板F的第70
号继电器中。取出这只飞蛾后，计算机便恢复了正常。当时为Mark II计
算机工作的著名女科学家Grace Hopper将这只飞蛾粘贴到了当天的工作
手册中（见图1-1），并在上面加了一行注释——“First actual case of bug
being found”，当时的时间是15:45。随着这个故事的广为流传，越来越
多的人开始用bug一词来指代计算机中的设计错误，并把Grace Hopper登
记的那只飞蛾看作计算机历史上第一个记录于文档（documented）中的
bug。
图1-1 计算机历史上第一个记录于文档中的bug
在bug一词广泛使用后，人们自然地开始用debug这个词来泛指排除
错误的过程。关于谁最先创造和使用了这个词，目前还没有公认的说
法，但可以肯定的是，Grace Hopper在20世纪50年代发表的很多论文中
就已频繁使用这个词了。因此可以肯定地说，在20世纪50年代，人们已
经开始用这个词来表达软件调试这一含义，而且一直延续到了今天。
尽管从字面上看，debug的直接意思就是去除bug，但它实际上包含
了寻找和定位bug。因为去除bug的前提是要找到bug，如何找到bug大都
比发现后去除它要难得多。而且，随着计算机系统的发展，软件调试已
经变得越来越不像在继电器间“捉虫”那样轻而易举了。因此，在我国台
湾地区，人们把software debug翻译为“软件侦错”。这个翻译没有按照英
文原词直译，超越了单指“去除”的原意，融入了“侦查”的含义，是个很
不错的意译。
在我国，我们通常将software debug翻译为“软件调试”，泛指重现软
件故障（failure）、定位故障根源并最终解决软件问题的过程。这种理
解与英语文献中对software debug的深层解释也是一致的，如《微软计算
机综合词典》（第5版）对debug一词的解释是：
debug vb. To detect, locate, and correct logical or syntactical errors in a
program or malfunctions in hardware.
对软件调试另一种更宽泛的解释是指使用调试工具求解各种软件问
题的过程，例如跟踪软件的执行过程，探索软件本身或与其配套的其他
软件，或者硬件系统的工作原理等，这些过程有可能是为了去除软件缺
欠，也可能不是。
1.1.2 基本过程
尽管取出那只飞蛾非常轻松，但为了找到它还是耗费了几个小时的
时间。因此，软件调试从一开始实际上就包含了定位错误和去除错误这
两个基本步骤。进一步讲，一个完整的软件调试过程是图1-2所示的循
环过程，它由以下几个步骤组成。
图1-2 软件调试过程
第一，重现故障，通常是在用于调试的系统上重复导致故障的步
骤，使要解决的问题出现在被调试的系统中。
第二，定位根源，即综合利用各种调试工具，使用各种调试手段寻
找导致软件故障的根源（root cause）。通常测试人员报告和描述的是软
件故障所表现出的外在症状，比如界面或执行结果中所表现出的异常；
或者是与软件需求（requirement）和功能规约（function specification）
不符的地方，即所谓的软件缺欠（defect）。而这些表面的缺欠总是由
一个或多个内在因素导致的，这些内因要么是代码的行为错误，要么
是“不行为”（该做而未做）错误。定位根源就是要找到导致外在缺欠的
内因。
 老雷评点 
“不行为”三字应连读，本书第1版中无引号，有读者断句
为“要么-是不-行为”，问我“是不”是否该为“不是”。在此致谢。
第三，探索和实现解决方案，即根据找到的故障根源、资源情况、
紧迫程度等设计和实现解决方案。
第四，验证方案，在目标环境中测试方案的有效性，又称为回归
（regress）测试。如果问题已经解决，那么就可以关闭问题；如果没有
解决，则回到第三步调整和修改解决方案。
在以上各步骤中，定位根源常常是最困难也是最关键的步骤，它是
软件调试过程的核心。如果没有找到故障根源，那么解决方案便很可能
是隔靴搔痒或者头痛医脚，有时似乎缓解了问题，但事实上没有彻底解
决问题，甚至是白白浪费时间。
1.2 基本特征
1.1节介绍了软件调试的定义和基本过程。本节将进一步从3个方面
介绍它的基本特征。
1.2.1 难度大
诚如Brian Kernighan先生所说的，软件调试是一项复杂度高、难度
大的任务。以下是导致这种复杂性的几个主要因素。
第一，如果把定位软件错误看作一种特殊的搜索问题，那么它通常
是个很复杂的搜索问题。首先，被搜索的目标空间是软件问题所发生的
系统，从所包含的信息量来看，这个空间通常是很庞大的，因为一个典
型的计算机系统中包含着成百上千的硬件部件和难以计数的软件模块，
每个模块又常常包含着数以百万计的指令（代码）。其次，这个搜索问
题并没有明确的目标和关键字，通常只知道不是非常明确的外在症状，
必须通过大量的分析才能逐步接近真正的内在原因。
第二，为了探寻问题的根源，很多时候必须深入到被调试模块或系
统的底层，研究内部的数据和代码。与顶层不同，底层的数据大多是以
原始形态存在的，理解和分析的难度比顶层要大。举例来说，对于顶层
看到的文字信息，在底层看到的可能只是这些文字的某种编码（ANSI
或UNICODE等）。对于代码而言，底层意味着低级语言或汇编语言甚
至机器码，因为当无法进行源代码级的调试时，我们不得不进行汇编一
级的跟踪和分析。对于通信有关的问题，底层意味着需要观察原始的通
信数据包和检查包的各个部分。另外，很多底层的数据和行为是没有文
档的，不得不做大量的跟踪和分析才能摸索出一些线索和规律。从API
的角度来看，底层意味着不仅要理解API的原型和使用方法，有时还必
须知道它内部是如何实现的、执行了哪些操作，这一点也证实了Brian
Kernighan所说的“调试要比编写代码困难”。
 老雷评点  
人生的境界在于高度，有高度方能俯瞰世间万物，超然物
外。软件的境界在于深度，有深度方能穿透纷纭表象，直击内
里。从业十几年中，老雷的电脑中一直有一个名叫dig的目录，
里面放着老雷最看重的文档和资料，包括《软件调试》的书稿。
表象浮华如过眼烟云，深挖、深挖再深挖，挖之弥深，意志弥
坚。
第三，因为要在一个较大的问题域内定位错误，所以要求调试者必
须有丰富的知识，熟悉问题域内的各个软硬件模块以及它们之间的协作
方式。从纵向来看，要理解系统从最上层到最下层的各个层次。从横向
来看，要理解每个层次内的各个模块。对于每个模块，不仅要知道其概
况，有时还必须深刻理解其细节。举例来说，对于那些包含驱动程序的
软件，有时必须同时进行用户态调试和内核态调试，这就要求调试者对
应用程序、操作系统和硬件都要有比较深刻的理解。
第四，每个软件调试任务都有很多特殊性，或者说很难找到两个完
全相同的调试任务。这意味着，在执行一个软件调试任务时，很难找到
可以模仿或借鉴的先例，几乎每一步都必须靠自己的探索来完成。而编
写代码和其他软件活动通常有示例代码或模板可以参考或套用。
第五，软件的大型化、层次的增多、多核和多处理器系统的普及都
令软件调试的难度增加了。
以上介绍的第一、第二、第五个因素是软件调试所固有的，第三、
第四个因素是可以随着软件技术的发展和人们对软件调试重视程度的不
断提高而改善的。
1.2.2 难以估计完成时间
就像侦破一个案件所需的日期很难确定一样，对于一个软件错误，
到底需要多久才能定位到它的根源并解决这个问题是一个很难回答的问
题。这是因为软件调试问题的问题域比较大，调试过程中包含的随机性
和不确定性很多，调试人员对问题及相关模块和系统的熟悉程度、对调
试技术的熟练程度也会加入很多不确定性。
调试任务的难以预测性经常给软件工程带来重大的麻烦，其中最常
见的便是导致项目延期。事实上，很多软件项目的延期是与无法定位和
解决存留的bug有关的。Grey Pascal Zachary[2]的著作生动地讲述了
Windows NT（3.1）内核开发中因严重bug而多次延期的故事（详见本书
后续分卷）。比NT 3.1还不幸的项目有很多，在它们被多次延期后，仍
然有大量的问题无法解决，最后因为资金等问题不得不被取消和放弃。
在现实中，很多软件难题经常成为整个项目的瓶颈，是项目团队中