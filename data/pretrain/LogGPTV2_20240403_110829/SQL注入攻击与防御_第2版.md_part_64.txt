句中是有效的。
表8-5MySQLLIKE子句的通配符
字符
含义
%
匹配0个或多个任意字符
精确匹配任意一个字符
为防止出现与表8-5列出的某一字符相匹配的情况，可以使用反斜线字符（）来避开通配符。
下面给出使用Java实现该操作的代码：
(\。)ooedox·bs -bs
sql = sql.replace ("_°, "\_") ;
314
---
## Page 329
第8章代码层防御
损害与防御.·
编码来自数据库的数据
使用数据库时常见的问题是对包含在数据库中的数据的内在信任，数据库中的数据
在保存到数据库之前通常不会经过严格的输入验证或审查，它们可能来自外部的源（来
自该组织内另一个应用或者来自第三方的源）。使用参数化语句是导致出现这种情况的
行为之一，参数化语甸通过避免动态SQL来防止SQL注入利用.从这一点看它是安全
的，但它在使用时并未验证输入，所以，存储在数据库中的数据可以包含来自用户的悉
意输入，对于这些情况，访问数据库中的数据时必须格外小心，这样才能在最终使用数
据或者将其展示给用户时避免SQL注入及其他类型的应用安全问题，
数据库中出现不安全的数据时通常会引发XSS问题，这种情况下也可能引发SQL
题，应该坚持对从数据库提取的数据针对语境进行编码，这样的例子包括：在将内客展
示给用户测览器之前对XSS问题进行编码，以及刚才介绍的在动态SQL中使用数据库
内容之前对SQL注入字持进行编码。
4.针对PostgreSQL的编码
PostgreSQL也使用单引号作为字符串字面量的结束符，可以采用两种办法对单引号进行编
码。第一种方法与Oracle或Microsof SQLServer中采用的方法类似，使用两个单引号替换一
个单引号。在PHP中可以使用下面的代码来实现：
SencodedValue = str_replace ("**, "**", $value) ;
第二种办法是使用一个反斜线对单引号进行编码，但PostgreSQL还需要在字符串字面量
之前放置一个大写的E字母：
SELECT * FROM User WHERE LastName=E*O\*Boyle*
在 PHP 中，可以使用add_slashesO或 str_replaceO方法对反斜线执行编码，但这并不是推
荐的方法。在PHP中，对于PostgreSQL数据库面言，最佳的字符串编码方式是使用pq_escape_
stringO方法：
$encodedValue = Pg_escape_string (Svalue) ;
该函数将调用libpq的PQescapeStringO方法，它将把单反斜线替换为双反斜线，并且用两
个单引号替换一个单引号：
1 → 11
在PostgreSQL中还可以采用其他办法创建字符串字面量，即使用s字符。$字符允许开发
人员在SQL语句中使用类似于标记（tag-like)的功能。下面就是一个使用这种语法创建的字符串：
315
---
## Page 330
SQL注入攻击与防御（第2版）
在这种情况下，对于用户输入的任何一个S字符，都需要确保使用一个反斜线进行转义处理：
SencodedValue = str_replace (*s*, "\\s*, $value) ;
警告：
如果查询是由包含了数据和控制的字符串连接而成，那么在使用这种API时请特别小心。
它们很容易被类似于SQL注入的方法攻击。对于使用了 JSON、XML、XPath、LDAP的API
或其他查询语言，如果没有对编码正确地进行处理，也容易遭到注入攻击，无论何时，只要使
用了这样的API，请注意使用的环境以及每一个API如何进行编码。
5.防止 NoSQL 注入
NoSQL数据库系统在实现和API上与其他数据库系统存在较大差异。在NoSQL的查询
API中，绝大多数方法都提供了将数据与代码清晰分离的方法.例如，当从PHP中使用MongoDB
时，典型的方法是使用关联数组（associative array)插入数据：
users->insert (array(*username*=> $username, "password" => Spassvord) )
查询则如下所示：
Suser = $users->findOne (array(*username* => $username))
这两个例子使用的语法都类似于参数化的语句。当使用这些API时，由于避免了使用字符
串连接来构造查询，因此防止了注入攻击。
对于其中一些API，我们需要特别小心。对于更高级的查询，MongoDB允许开发人员使
用Swhere关键字提交一个JavaScript函数：
this.username.indexOf(*$test′) > -1 "));
可以看到，该JavaScript函数很容易遭到注入攻击。攻击者可以转义indexOfO内的字符串，
并改变查询执行的方式，为了防止这种攻击，我们必须对JavaScript进行编码。使用十六进制
的xnn编码类型，或使用unnmn类型的Unicode编码，对所有非字母或数字的字符全部进行转
义，这是最安全的办法。
8.7规范化
输入验证和输出编码面临的困难是：确保将正在评估或转换的数据解释成最终使用该输入
的用户所需要的格式。避开输入验证和输出编码的常用技术是：在将输入发送给应用程序之前
对其进行编码，之后再对其进行解码和解释以符合攻击者的目标。例如，表8-6列出了编码单
引号字符时可以使用的方法。
表8-6表示单引号的例子
表示
编码类型
%27
URL 编码
316
---
## Page 331
第8章代码层防御
(续表)
表示
编码类型
%2527
双 URL 编码
%%317
嵌套的双URL编码
%u0027
Unicode 表示
697on%
Unicode表示
%ca%b9
Unicode表示
&apos
HTML实体
&#39
十进制HTML实体
&#x27
十六进制HTML实体
%26apos
混合的URL/HTML编码
在有些情况下，这是可选的字符编码方法（%27是单引号的URL编码表示）：而对于其他情
况，这是双编码方法（假定应用对数据进行显式解码（对%2527进行URL解码后，它将变成表
8-6中所示的%27：%%317也一样)）或是各种Unicode表示方法（不管有效还是无效）。并非所有
这些表示都会被正常解释成单引号。大多数情况下，它们依赖于所使用的特定条件（比如解码
操作是位于应用层、应用服务器层、WAF层还是Web服务器层），所以很难预测应用程序是否
会按这种方式进行解释
出于上述原因，一定要考虑将规范化（canonicalization）作为输入验证方法的一部分。规范化
是指将输入简化成标准或简单的形式，例如表8-6中的单引号示例被规范化后通常会变成单引
号字符
规范化方法
处理不常见的输入时应该考虑哪些方法呢？通常最容易实现的一种方法是拒绝所有不符
合规范格式的输入。例如，可以拒绝应用程序接收的所有HTML编码和URL编码的输入。如
果不希望出现经过编码的输入，那么这是最可靠的方法之一。进行白名单输入验证时通常会默
认采用该方法，因为在验证已知的良好输入时不会接收不常见的字符格式。这种方法至少不会
接收用于编码数据的字符（比如表8-6中列举的%、&和，因面不允许输入这些字符。
如果无法拒绝包含编码格式的输入，就需要寻找解码方法或者使用其他方法来保证接收到
的数据的安全。这可能包含儿个会潜在重复多次的解码步骤，比如URL解码和HTML解码。
但是这种方法容易出错，因为需要在每个编码步骤之后执行检查以确定输入中是否仍然包含经
过编码的数据。比较可行的方法是只将输入解码一次，接下来如果数据中仍然包含经过编码的
字符，就拒绝。该方法假设真正的输入不会包含双编码值。大多数情况下，这是一种有效的
假设。
适用于Unicode的方法
遇到像UTF-8这样的Unicode 输入时，一种方法是将输入标准化（normalization)。该方法
使用定义好的规则集将Unicode转换成最简单的形式。Unicode标准化与规范化的差别在于：
根据使用规则集的不同，Unicode字符可能会存在多种标准形式。建议使用NFKC(Normalization
317
---
## Page 332
SQL注入攻击与防御（第2版）
FormKC)作为输入验证目的的标准化形式。可以访问www.unicode.org/reports/tr15以获取关于
标准化形式的更多信息。
标准化操作将Unicode字符分解成有代表性的组件，之后按照最简单的形式重组该字符。
大多数情况下，它会将双倍宽度及其他的Umicode编码在它们所处的位置转换成各自的ASCII
等价形式。
可以使用Java中的Normalizer类（Java6及以上版本）来将输入标准化，如下所示：
normalized - Normalizer,normalize (input, Normalizer.Form.NFKC) ;
可以使用C#中String类的Normalize方法来将输入标准化，如下所示：
normalized - input.Normalize (NormalizationForm.FormKC) ;
可以使用PHP中PEAR库的PEAR:I18N_UnicodeNormalizer包来将输入标准化，如下所示：
$normalized - I18N_UnicodeNormalizer::toNFKC ($input, *Ure-8*);
还有一种方法是首先检查Umicode是有效的（不是无效的表示)，然后将数据转换成一种可
预见的格式，例如像ISO-8859-1这样的西欧字符集。接下来从该位置开始在应用中按这种格
式使用输入。这是一种考虑周到的有损方法，因为在转换时通常会丢失那些无法使用字符集表
示的Unicode字符。不过，就输入验证决策的目的而言，这种方法对那些未本地化为西欧语言
之外的应用程序会很有用。
可以通过表8-7中列出的正则表达式来对使用UTF-8编码的Unicode进行Unicode有效性
检查。如果输入能与这些条件中的某个条件相匹配，那么它应该是个有效的UTF-8编码。如果
不匹配，就不是有效的UTF-8编码，应该被拒绝。对于其他类型的Unicode，则应该查阅正在
使用的框架的说明文档，以确定是否存在测试输入有效性的功能。
表8-7用于解析UTF-8的正则表达式
正则表达式
[x00-x7F]
ASCII
[xC2-xDF][x80-1xBF]
双字节表示
xE0[xA0-xBF]x80-xBF]
双字节表示
[xE1-xECxEExEF][x80-xBF]{(2}
三字节表示
xED [x80-x9F][x80-xBF]
三字节表示
xF0 [x90-(xBF][x80-xBF]{2)
plane 1 到 3
[xF1-xF3]x80-xBF]{3}
panel 4 到 15
xF4 [x80-x8F][x80-xBF](2]
panel 16
检查完输入是有效的格式后，现在可以将它转换成可预见的格式。例如，将UnicodeUTF-8
字符申转换成诸如ISO-8859-1(Latin1)这样的其他字符集。
在Java中，可以使用CharsetEncoder类或比较简单的getBytes0方法(Java6及之后的版本)
如下所示：
318
---
## Page 333
第8章代码层防御
string asci1 - utf8.getBytes (*ISOo-88591*);
在C#中，可以使用Encoding.Converter类，如下所示：
byte[] asciiBytes = Encoding.Convert (Encoding.UTF8, Encoding .ASCII
utf8Bytes) :
在PHP中，可以使用utf8_decode，如下所示：
ascii - utf8_decode (Sutf8string);
8.8通过设计来避免SQL注入的危险
本章介绍的解决方案包含了用于保护应用程序免受SQL注入攻击的模式。大多数情况下，
这些模式是一些可应用到正处于开发阶段的以及现有应用程序中的技术（虽然需要对原来的应
注入的危险。不过，在设计层面上，这些技术对新的开发更有益，因为要想对现有的应用程序
进行重大的架构重组以便集成不同的设计技术，需要花费大量功夫。
接下来介绍的设计技术均可独立实现。不过，为达到最好效果，建议在实现这些技术时结
层防御。
8.8.1使用存储过程
将应用程序设计成专门使用存储过程米访问数据库是一种可以防止或减轻SQL注入影响
的设计方式。存储过程是保存在数据库中的程序。根据数据库的不同，可以使用很多不同语言
及其变体(例如 SQL(用于 Oracle 的 PL/SQL、用于 SQLServer 的 Transact-SQL、用于 MySQL
的 SQL：2003标准)、Java(Oracle)或其他语言）米编写存储过程。
存储过程非常有助于减轻潜在SQL注入漏洞的严重影响，因为在大多数数据库中使用存
储过程时都可以在数据库层配置访问控制。这一点很重要，意味着如果发现了可利用的SQL
注入问题，就可通过正确配置许可权限来保证攻击者无法访问数据库中的敏感信息。
之所以会出现这种情况，是因为动态SQL（源于其动态特性）要求的权限许可比应用程序严格
需要的权限史大。由于动态SQL是在应用程序中（或者数据库中的其他位置）组装的，之后被发送
给数据库执行，因而数据库中所有需要被应用程序读取、写入或更新的数据均需要能够被用于访
问数据库的数据库用户账户访问到。因此，如果出现SQL注入问题，攻击者就可以潜在地访间
数据库中所有能够被应用程序访问的信息，因为攻击者拥有应用程序的数据库许可权限。
可以使用存储过程来改变这种状况。本例将创建存储过程以执行应用程序需要的所有数
据库访问。为应用程序访问数据库时使用的数据库用户分配执行应用程序所需的存储过程的
许可权限，但不要为它分配数据库中其他的数据许可（例如，用户账户没有对应用程序的数据
执行SELECT、INSERT或UPDATE操作的权限，但是拥有存储过程的 EXECUTE权限)。接
下来存储过程使用不同的许可访问数据（例如创建存储过程而非调用存储过程的用户许可）并
按需与应用程序数据进行交互。这样有助于减轻SQL注入问题的影响，因为它会限制攻击者