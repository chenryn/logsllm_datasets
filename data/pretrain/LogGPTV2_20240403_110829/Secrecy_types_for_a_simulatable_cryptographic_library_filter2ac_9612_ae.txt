6. CORRECTNESS OF THE TYPE SYSTEM
The type system is correct in the following sense.
THEOREM 1
(PRESERVATION OF SECRECY). Let ChanP be
the set of abstract channels used by all processes in the initial states
of all the machines Pi. If there exists a typing (cid:0) with dom((cid:0)) =
ChanP (cid:2)fs; rg, such that (cid:0) satisﬁes the constraints put on (cid:0)(c; s)
and (cid:0)(c; r), as stated in Sec. 5, and (cid:0) ‘ I for all input processes I
in the initial states of the machines Pi executing the protocols then
the execution of the conﬁgurations of the structure C 0
n satisﬁes the
properties (I)–(V).
From this result and from the preservation of secrecy of mes-
sages under simulatability we immediately get
COROLLARY 2. If the conditions of Theorem 1 are met then the
structure Cn preserves the secrecy of messages that it receives over
the channels pinui .
Let us give a sketch of the correctness proof; full details can be
found in [34]. The main tool in showing the correctness of the type
system is a result similar to subject reduction. For this we have to
keep track of the secrets given to participants of the protocol by
the users, as well as the orders of symmetric keys. We extend the
deﬁnition of values (Fig. 1) by v ::= (cid:1) (cid:1) (cid:1) j ntrk and of expressions
by e ::= (cid:1) (cid:1) (cid:1) j ntrk, where n 2 N; we call such values tracked. If
the participant Pi has received a message n from the i-th user then
this message is saved in the state of Pi as ntrk. We must ensure
that the conditions (I)–(III) hold for these values. We also change
the workings of some commands of THn, such that the “raw data”
that has been stored in the database of THn can be tracked, too. In
particular the command store of THn must be aware whether its
argument is tracked and store it differently from untracked values
in the database. The trackedness is also preserved in the return val-
ues of the command retrieve. To remain faithful to the observable
n we deﬁne that in an if -statement of
behavior of the structure C 0
some process, the values n and ntrk are considered equal.
Another slight modiﬁcation to the operation of THn is neces-
sary; the observable semantics remains unchanged by it. Namely,
when Pi sends the command gen symenc key(i) to THn for gen-
erating a new symmetric key of order i then THn also stores i to-
gether with the newly created term denoting the key.
For deﬁning when a state C types according to (cid:0) we have to
extend (cid:0) to the terms T in the database of THn and to the handles
of terms that the machine THn has returned to the participants. We
denote the type of the handle n 2 N given to the i-th participant
by (cid:0)(n; i). We also have to extend the typing relation ‘. The
semantics of processes replaces variables with their values, but the
typing rules in Fig. 7 do not allow an integer to represent a handle
to a term. For each participant identity i we deﬁne a relation ‘i for
expressions and processes. All the rules given in Figures 7–9 are
also deﬁned to hold for ‘i. Additionally we introduce the axioms
(cid:0) ‘i ntrk : SecRD, (cid:0) ‘i n : (cid:0)(n; i), and (cid:0) ‘i NF(ntrk). We
write (cid:0) ‘ C if the following holds:
(A) (cid:0) ‘i P for all (input) processes P in the state Si, for all i. If
some state Si is active and the source of the message in that
state is not some participant then the received message in that
state is a handle to some term T in the database of THn and
(cid:0)(T) (cid:20) (cid:0)(c; r) where c is the abstract channel name that
is stored in Si. If there is a message that awaits sending (a
process has just executed a send-command) then it is a pair
where the ﬁrst component indicates the abstract channel c,
the second component is the actual message and the type of
the second component, given by (cid:0) is less or equal to (cid:0)(c; s).
The same condition (the type of message is less or equal to
the type of the abstract channel) holds for the messages in
the buffers Li!j
of secure and authentic channels. Addi-
tionally, the abstract channel recorded in the message must
correspond to the security level of the concrete channel.
c
(B) If n has been given as a handle to the term T to some par-
ticipant i and n is present in the state Si (as part of an ex-
pression in a process, or as a handle to the received message)
then (cid:0)(n; i) = (cid:0)(T).
(C) Let (cid:28) be the type of the term T, as recorded by THn. De-
pending on (cid:28) , the type (cid:0)(T) must be one of the following:
(cid:15) (cid:28) = data: (cid:0)(T) must be either PubData or SecData.
If the stored data is ntrk then (cid:0)(T) must be SecData.
(cid:15) (cid:28) = list: (cid:0)(T) must be List((cid:0)(T1); : : : ; (cid:0)(Tk)) where
T1; : : : ; Tk are the immediate subterms of T.
(cid:15) (cid:28) = nonce: (cid:0)(T) must be either SNonce or Public.
(cid:15) (cid:28) = skse: (cid:0)(T) must be either Public (if T was cre-
ated by the adversary) or SKi(T ) for some T , where i
is the order of T (if T was created by an honest party).
(cid:15) (cid:28) = ske: (cid:0)(T) must be either Public or DK(T ) for
some T . If T is generated by a protocol party (i.e. a
protocol party has a handle to it) then (cid:0)(T) 6= Public.
(cid:15) (cid:28) = pke: Let T0 be the term representing the corre-
sponding secret key. If (cid:0)(T0) = Public then (cid:0)(T) =
Public. If (cid:0)(T0) = DK(T ) then (cid:0)(T) = EK(T ).
(cid:15) for other values of (cid:28) , (cid:0)(T) must be Public.
We call a term public if its type, according to (cid:0), is public.
Otherwise we call a term secret.
(D) If the adversary has handle to a term T then T is public.
(E) If a term T is public and its immediate subterm T0 is secret
(the subterms of a ciphertext are the plaintext and the public
key of type pke or pkse) then the type of T, as recorded by
THn, is enc or symenc, T0 is the corresponding plaintext,
and the decryption key is secret.
(F) If the type of the term T, as recorded by THn, is symenc,
and the type (by (cid:0)) of the corresponding key is SKi(T ) for
some type T , then the type (by (cid:0)) of the plaintext must be a
subtype of List(T ). If the type of T is enc and the type of
the corresponding decryption key is DK(T ) then the type of
the plaintext must be a subtype of List(T ) or a public type.
With the deﬁnition of (cid:0) ‘ C in place, the following lemmas and
theorems are straightforward to prove:
LEMMA 3. Let C be a state of the conﬁguration C, let (cid:0) ‘ C.
Let e be a closed expression, v be a value and e C:O+i
O0 v. Let
C0 = CO O0. Let (cid:0) ‘i e : T . Then there exists a typing (cid:0)0 of C0
that extends (cid:0) (i.e. dom((cid:0)0) (cid:19) dom((cid:0)) and (cid:0)0 agrees with (cid:0) on
all arguments from dom((cid:0))), such that (cid:0)0 ‘ C0, and if T 2 TH
then v is either ? or contains a handle to a term Tv, such that
(cid:0)0(Tv) (cid:20) T .
LEMMA 4. Let C be a state of the conﬁguration C, let (cid:0) ‘ C.
Let e be an expression and let v be the result of the i-th participant
computing its value in the state C. If (cid:0) ‘i NF(e) and e has a type
according to (cid:0) and ‘i then v 6= ?. If (cid:0) ‘i AF(e) then v = ?.
THEOREM 5
(SUBJECT REDUCTION). Let C and C0 be two
states of the composition C and let (cid:0) be a typing such that (cid:0) ‘ C
and C ! C0. Then there exists a typing (cid:0)0 extending (cid:0), such that
(cid:0)0 ‘ C0.
7. CONCLUSIONS
We have presented a rather simple type-system for protocols that
use the Backes-Pﬁtzmann-Waidner (BPW) cryptographic library.
The type system can be used to show that the protocol preserves
the secrecy of input messages. Our result shows that the existing
methods of (semi)automatically checking the security of protocols
(not only type systems, but also model-checking, program analy-
sis, constraint solving, etc.) are applicable to that library. Indeed,
Abadi and Blanchet [3] describe an automatic tool whose operation
is equivalent to the type inference according to their type system;
this tool should be readily modiﬁable for our type system. We are
also quite conﬁdent that the more complex type systems by Gor-
don and Jeffrey [26, 25, 27] for checking integrity properties in
protocols using Dolev-Yao model can be carried over to the BPW
library.
8. ACKNOWLEDGMENTS
We are thankful to C´edric Fournet and to the anonymous referees
of CCS 2005 for their comments. This research has been supported
by Estonian Science Foundation, grant #6095.
9. REFERENCES
[1] M. Abadi. Secrecy by Typing in Security Protocols. Journal of the ACM,
46(5):749–786, Sept. 1999.
[2] M. Abadi and B. Blanchet. Secrecy types for asymmetric communication.
Theoretical Computer Science, 298(3):387–415, 2003.
[3] M. Abadi and B. Blanchet. Analyzing Security Protocols with Secrecy Types
and Logic Programs. Journal of the ACM, 52(1):102–146, Jan. 2005.
[4] M. Abadi and A. Gordon. A Calculus for Cryptographic Protocols: The Spi
Calculus. Information and Computation, 148(1):1–70, Jan. 1999.
[5] M. Abadi and J. J¨urjens. Formal Eavesdropping and Its Computational
Interpretation. In proc. of TACS 2001 (LNCS 2215), pages 82–94.
[6] M. Abadi and P. Rogaway. Reconciling Two Views of Cryptography (The
Computational Soundness of Formal Encryption). In proc. of International
Conference IFIP TCS 2000 (LNCS 1872) pages 3–22.
[7] M. Backes. A Cryptographically Sound Dolev-Yao Style Security Proof of the
Otway-Rees Protocol. In proc. of ESORICS 2004 (LNCS 3193) pages 89–108.
[8] M. Backes and B. Pﬁtzmann. A Cryptographically Sound Security Proof of the
Needham-Schroeder-Lowe Public-Key Protocol. In proc. of FST TCS 2003
(LNCS 2914), pages 1–12.
[9] M. Backes and B. Pﬁtzmann. Symmetric Encryption in a Simulatable
Dolev-Yao Style Cryptographic Library. In proc. of IEEE CSFW 2004, pages
204–218.
[10] M. Backes and B. Pﬁtzmann. Relating Symbolic and Cryptographic Secrecy. In
proc. of IEEE S&P 2005.
[11] M. Backes, B. Pﬁtzmann, and M. Waidner. Symmetric authentication within a
simulatable cryptographic library. In proc. of ESORICS 2003 (LNCS 2808),
pages 271–290.
[12] M. Backes, B. Pﬁtzmann, and M. Waidner. A Universally Composable
Cryptographic Library. In proc. of ACM CCS 2003, pages 220-230.
[13] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A Concrete Security
Treatment of Symmetric Encryption. In proc. of FOCS 1997, pages 394–403.
[14] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among
Notions of Security for Public-Key Encryption Schemes. In proc of. CRYPTO
’98 (LNCS 1462), pages 26–45.
[15] B. Blanchet. Automatic Proof of Strong Secrecy for Security Protocols. In proc.
of IEEE S&P 2004, pages 86–100.
[16] R. Canetti. Universally Composable Security: A New Paradigm for
Cryptographic Protocols. In proc. of FOCS 2001, pages 136–145.
[17] R. Canetti and M. Fischlin. Universally Composable Commitments. In proc. of
CRYPTO 2001 (LNCS 2139), pages 19–40.
[18] R. Canetti and J. Herzog. Universally Composable Symbolic Analysis of
Cryptographic Protocols (The case of encryption-based mutual authentication
and key exchange). Cryptology ePrint Archive: Report 2004/334, 22 Feb. 2005.
[19] R. Canetti and H. Krawczyk. Universally Composable Notions of Key
Exchange and Secure Channels. In proc. of EUROCRYPT 2002 (LNCS 2332),
pages 337–351.
[20] R. Canetti, Y. Lindell, R. Ostrovsky, and A. Sahai. Universally composable
two-party and multi-party secure computation. In proc. of STOC 2002, pages
494–503.
[21] V. Cortier and B. Warinschi. Computationally Sound, Automated Proofs for
Security Protocols. In proc. of ESOP 2005 (LNCS 3444), pages 157–171.
[22] D. Dolev and A. Yao. On the security of public key protocols. IEEE
Transactions on Information Theory, IT-29(12):198–208, Mar. 1983.
[23] O. Goldreich. Foundations of Cryptography (Basic Tools). Cambridge
University Press, 2001.
[24] S. Goldwasser and S. Micali. Probabilistic Encryption. Journal of Computer
and System Sciences, 28(2):270–299, Apr. 1984.
[25] A. D. Gordon and A. Jeffrey. Authenticity by Typing for Security Protocols.
Journal of Computer Security, 11(4):451–520, 2003.
[26] A. D. Gordon and A. Jeffrey. Typing correspondence assertions for
communication protocols. Theoretical Computer Science, 300(1-3):379–409.
[27] A. D. Gordon and A. Jeffrey. Types and effects for asymmetric cryptographic
protocols. Journal of Computer Security, 12(3-4):435–483, 2004.
[28] J. Guttman, F. Thayer, and L. Zuck. The faithfulness of abstract protocol
analysis: message authentication. In proc. of ACM CCS 2001, pages 186–195.
[29] J. Herzog, M. Liskov, and S. Micali. Plaintext Awareness via Key Registration.
In proc. of CRYPTO 2003 (LNCS 2729), pages 548–564.
[30] R. Janvier, Y. Lakhnech, and L. Mazar´e. Completing the Picture: Soundness of
Formal Encryption in the Presence of Active Adversaries. In proc. of ESOP
2005 (LNCS 3444), pages 172–185.
[31] R. Janvier, Y. Lakhnech, and L. Mazar´e. (De)Compositions of Cryptographic
Schemes and their Applications to Protocols. Cryptology ePrint Archive, Report
2005/020, 1 Feb. 2005.
[32] P. Laud. Handling Encryption in Analyses for Secure Information Flow. In
proc. of ESOP 2003 (LNCS 2618), pages 159–173.
[33] P. Laud. Symmetric encryption in automatic analyses for conﬁdentiality against
active adversaries. In proc. of IEEE S&P 2004, pages 71–85.
[34] P. Laud. Secrecy Types for a Simulatable Cryptographic Library. Research
Report IT-LU-O-162-050823, Cybernetica, Aug. 2005.
[35] P. Laud and V. Vene. A Type System for Computationally Secure Information
Flow. In proc. of FCT 2005 (LNCS 3623), pages 365–377.
[36] P. Lincoln, J. Mitchell, M. Mitchell, and A. Scedrov. A Probabilistic Poly-Time
Framework for Protocol Analysis. In proc. of ACM CCS ’98, pages 112–121.
[37] P. Lincoln, J. Mitchell, M. Mitchell, and A. Scedrov. Probabilistic
Polynomial-Time Equivalence and Security Analysis. In proc. of FM ’99
(LNCS 1708), pages 776–793.
[38] G. Lowe. Breaking and Fixing the Needham-Schroeder Public-Key Protocol
Using FDR. In proc. of TACAS ’96 (LNCS 1055), pages 147–166.
[39] C. Meadows. Formal Methods for Cryptographic Protocol Analysis: Emerging
Issues and Trends. IEEE Journal on Selected Areas in Communication,
21(1):44–54, Jan. 2003.
[40] D. Micciancio and S. Panjwani. Adaptive Security of Symbolic Encryption. In
proc. of TCC 2005 (LNCS 3378), pages 169–187.
[41] D. Micciancio and B. Warinschi. Completeness theorems for the
Abadi-Rogaway logic of encrypted expressions. In Workshop on Issues in the
Theory of Security - WITS 2002, Portland, Oregon, Jan. 2002.
[42] D. Micciancio and B. Warinschi. Soundness of Formal Encryption in the
Presence of Active Adversaries. In proc. TCC 2004 (LNCS 2951), pages
133-151.
[43] R. M. Needham and M. D. Schroeder. Using Encryption for Authentication in
Large Networks of Computers. Communications of the ACM, 21(12):993–999,
Dec. 1978.
[44] B. Pﬁtzmann and M. Waidner. A Model for Asynchronous Reactive Systems
and its Application to Secure Message Transmission. In IEEE S&P 2001, pages
184–200.
[45] C. Rackoff and D. R. Simon. Non-interactive zero-knowledge proof of
knowledge and chosen ciphertext attack. In proc. of CRYPTO ’91 (LNCS 576),
pages 433–444.
[46] A. Ramanathan, J. C. Mitchell, A. Scedrov, and V. Teague. Probabilistic
Bisimulation and Equivalence for Security Analysis of Network Protocols. In
proc. of FOSSACS 2004 (LNCS 2987), pages 468–483.
[47] A. Yao. Theory and applications of trapdoor functions (extended abstract). In
proc. of FOCS ’82, pages 80–91.
[48] R. Zunino and P. Degano. A Note on the Perfect Encryption Assumption in a
Process Calculus. In proc. of FOSSACS 2004 (LNCS 2987), pages 514–528.