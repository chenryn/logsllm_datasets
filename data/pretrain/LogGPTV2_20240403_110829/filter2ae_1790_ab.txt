      1: dup
      2: invokespecial // Method java/lang/Throwable."":()V
      3: athrow
      4: new           // class java/lang/RuntimeException
      5: dup
      6: invokespecial // Method java/lang/RuntimeException."":()V
      7: athrow
      8: return
      Exception table:
       from    to  target type
          0    4    8   Class java/lang/Throwable
          StackMapTable: number_of_entries = 2
            frame at instruction 3
              local = [UNINITIALIZED_THIS]
              stack = [ class java/lang/Throwable ]
            frame at instruction 8
              locals = [TOP]
              stack = [ class java/lang/Throwable ]
    ---------------------------------------------------------------------------    
我们可以将局部变量的最大数目和堆栈的最大尺寸都设置为2，以满足第1个条件。此外，第3行代码处，当前帧会将“UNINITIALIZED_THIS”设置为true，以满足第2个条件。最后，未初始化的局部变量不会用于“athrow”指令的目标操作数(第8行)，因为局部变量的第一个元素被初始化为“TOP”，这样第3个条件也能得到满足。
请注意，这些代码位于try/catch语句块中，以便通过函数is_assignable_to()将“is_exception_handler”设置为“true”。
此外，还需要注意的是，该字节码都位于构造函数（字节码形式的`()`）中。要想将标志“UNINITIALIZED_THIS”设置为true，必须如此。
我们现在已经知道，安全分析人员能够构造出返回其自身尚未被初始化的对象的字节码了。乍一看，可能很难看出这种对象是如何供安全分析人员使用的。但是，通过仔细观察就会发现，所需的类可以实现为一个系统类的子类，可以在不调用超类的构造函数`super.()`的情况下完成初始化。这个类可用于实例化因构造函数是私有的或包含权限检查而无法由不受信任的代码实例化的那些公共系统类。下一步是寻找含有安全分析人员“感兴趣的”功能的类。这样做的目的是，将所有功能组合在一起，以便能够在沙箱环境中执行任意代码，从而绕过沙箱。然而，寻找有用的类本身就是一项非常复杂的任务。
具体而言，我们面临着以下挑战。
**挑战1：到哪里寻找助手代码**
JRE提供了许多包含JCL（Java类库）类的jar文件。这些类作为_trusted_类进行加载，并且可以在构造漏洞利用代码时使用。当前，有越来越多的类被标记为“restricted”，这意味着_untrusted_代码将无法直接实例化它们——对于安全分析人员来说，这是非常不幸的；但是对于Java用户来说，这又是非常幸运的。在1.6.0_01版本中，访问权限为restricted的包的数量只有1个，到1.8.0_121版本发布时，这种类型的包的数量已经变为47个。这意味着安全分析人员在构建漏洞利用代码时无法直接使用的代码的百分比，从1.6.0_01版本升级到1.8.0_121版本的过程中，已经从20％提升到54％了。
**挑战2：字段可能未初始化**
如果没有适当的权限，通常无法实例化新的类加载器。在构造函数中接受检查的_ClassLoader_类的权限，看起来似乎是一个不错的目标。
借助于CVE-2017-3289漏洞，我们确实可以在没有相应权限的情况下实例化新的类加载器，因为构造函数代码——以及权限检查代码——不会被执行。但是，由于绕过了构造函数，因此，这时会使用默认值来初始化各个字段（例如，对于整数来说，将被初始化为0；对于引用来说，将被初始化为null）。所以，这可能导致某些问题：我们感兴趣的方法通常是允许为定义的新类赋予全部权限的那些方法，但是在这种情况下，这些方法都无法正常运行，因为代码将尝试解除对未正确初始化的字段的引用。在手动检查之后，我们发现似乎很难绕过字段的解引用，因为所有路径都是通过该指令来解除对非初始化字段的引用的。这样看来，利用_ClassLoader_似乎是一个死胡同。当利用CVE-2017-3289中的漏洞时，非初始化字段是一个主要挑战：除了要求目标类的访问权限是public、非final和非restricted之外，其感兴趣的方法也不应该执行撤销对未初始化的字段的引用的方法。
对于Java version 1.8.0 update
112来说，我们还没有找到有用的助手代码。为了阐明CVE-2017-3289漏洞的形成机制，我们将展示用于利用编号为0422和0431的漏洞的助手代码。这两个漏洞依赖于
_MBeanInstantiator_
，该类定义了可以加载任意类的方法，即findClass()。类_MBeanInstantiator_只提供了私有构造函数，因此无法直接进行实例化。
最初，这些漏洞都是通过_JmxMBeanServer_来创建_MBeanInstantiator_的实例。这里，我们将证明，安全分析人员可以直接子类化
_MBeanInstantiator_ ，并利用编号为3289的漏洞来获取它的实例。
用于实例化_MBeanInstantiator_的原始助手代码依赖于 _JmxMBeanServer_ ，具体如下所示：
    ---------------------------------------------------------------------------      1: JmxMBeanServerBuilder serverBuilder = new JmxMBeanServerBuilder();
      2: JmxMBeanServer server =
      3:      (JmxMBeanServer) serverBuilder.newMBeanServer("", null, null);
      4: MBeanInstantiator instantiator = server.getMBeanInstantiator();
    ---------------------------------------------------------------------------    
实例化_MBeanInstantiator_的代码利用了CVE-2017-3289漏洞：
    ---------------------------------------------------------------------------      1: public class PoCMBeanInstantiator extends java.lang.Object {
      2:   public PoCMBeanInstantiator(ModifiableClassLoaderRepository clr) {
      3:     throw new RuntimeException();
      4:   }
      5:
      6:   public static Object get() {
      7:     return new PoCMBeanInstantiator(null);
      8:   }
      9: }
    ---------------------------------------------------------------------------    
请注意，由于_MBeanInstantiator_没有任何公共构造函数，_PoCMBeanInstantiator_必须在源代码中扩展一个虚拟类，在我们的示例中为
_java.lang.Object_ 。我们将通过ASM [28]字节码操作库，把_PoCMBeanInstantiator_的超类改为
_MBeanInstantiator_ 。此外，我们还将使用ASM来修改构造函数的字节码，以绕过对`super.(*)`的调用。
自Java 1.7.0 update
13版本以来，Oracle已将_com.sun.jmx._添加为受限程序包。类_MBeanInstantiator_就位于这个程序包中，因此，我们无法在更高版本的Java中继续使用该助手代码。
出乎我们意料之外的是，这个漏洞影响了40多个不同的公开发行版本。Java 7的所有版本，包括从update 0到update
80，都含有这个漏洞。从update 5到update 112的所有Java 8版本也会受到该漏洞的影响。不过，Java 6版本并没有受到该漏洞的影响。
通过检查Java 6 update 43发行版的字节码验证器与Java 7 update 0发行版的源代码，我们发现主要的区别对应于上面提供的补丁的逆操作。
这意味着堆栈帧可分配给构造函数中异常处理程序内的目标堆栈帧的条件已被削弱。diff中的注释表明，这个新代码是应7020118号请求[26]而添加的。该请求要求更新字节码验证程序的代码，以使NetBeans的分析器（profiler）能够生成可以覆盖构造函数的全部代码的处理程序。
这个漏洞已经通过收紧约束条件得到了修复，只有满足了这个加强版的约束条件，当前堆栈帧（位于try/catch代码块中的构造函数中）才可以分配给目标堆栈帧。这样就能有效地防止字节码从构造函数返回未初始化的“this”对象了。
据我们所知，Java至少有三个已经公开的_uninitialized
instance_漏洞。其中，第1个漏洞是本文介绍的CVE-2017-3289。第2个漏洞于2002年被发现，具体见参考文献[29]。同时，该文献的作者还利用了字节码验证器中的漏洞，该漏洞的作用是让Java平台无法调用超类的构造函数。但是，利用这些漏洞时，无法开发出能够实现沙箱的完全逃逸的利用代码。但是，它们能够可以用来访问网络并将文件读写入磁盘。第3个漏洞是普林斯顿的一个研究小组于1996年发现的，具体见参考文献[30]。同样，这个安全问题也是位于字节码验证器中。它允许构造函数捕获调用super()时抛出的异常，并返回部分初始化的对象。请注意，利用该漏洞发动攻击时，ClassLoader类没有任何实例变量。因此，利用该漏洞来实例化类加载器的时候，能够获得一个完全初始化的类加载器，可以在其上调用任何方法。
**\------[ 4.2.3 -讨论**
* * *
这个漏洞的根本原因是对C/C++编写的字节码验证代码的修改，而原来验证代码的作用是，保证安全分析人员构造出的Java字节码无法绕过对子类构造函数中的super()的调用。但是，该漏洞直接违反了虚拟机的相关规范[21]。
但是，如果没有合适的_helper_代码，这个漏洞将毫无用处。不过，Oracle已经开发了一款静态分析工具，专门用于查找危险的gadget，并将其列入黑名单[31]。这使得安全分析人员在开发用于绕过沙箱的漏洞利用程序的时候，难度更大了。实际上，我们只发现了能够与旧版JVM配套使用的gadget。由于它们已被列入最新版本的黑名单，因此，这种攻击方法已经失效了。
然而，即使可以使用静态分析工具进行防御，但是仍然面临两个问题：（1）可能会引发许多假正例，这使得识别真正危险的gadget变得更加困难，并且（2）可能导致许多假负例，因为它无法模拟语言的所有特性，比如反射和JNI，因此，这种防御方式还不够健全。
**小结**
* * *
在本文中，我们为读者详细介绍了实例未初始化漏洞。在下一篇文章中，我们将继续为读者介绍更多精彩内容，敬请期待。