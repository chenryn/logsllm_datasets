u st S
•
•
•
-
-
•
-
-
D
ple
X
S
T a L
•
•
-
•
•
•
-
•
Intel G
•
•
-
-
-
-
•
-
L
o S
S
K ’s tlsclie nt
W olf S
-
•
-
-
-
•
-
-
•
-
-
•
-
•
•
•
E
ple
n cla v e
E
S y n a ptics S y n a T
x a m
E
E
D riv er
F in g erprint D riv er
G
o o dix
•
-
-
•
-
•
•
•
Table 2: Overview of results of our analysis of public enclave code. Some patterns are not applicable for every enclave, because
the relevant code constructs are not used or the source is unavailable.
big integer can actually point to arbitrary memory, including
enclave memory.
This vulnerability allows an attacker to perform an arbi-
trary memory write, with controlled content and controlled
size. TEEREX identiﬁes the arbitrary write vulnerability in
multiple ECALLs. They all share the same structure as the
one depicted in Figure 4. In our proof-of-concept exploit,
we abuse the e_mpz_add ECALL: we set the value of the
underlying buffer of the big integer parameter a_unsafe to
our payload, the big integer b_unsafe to a big integer ini-
tialized as 0, and the underlying buffer of c_unsafe to our
target address for the arbitrary write. We choose an address
on the enclave stack that points to a return address used by the
enclave. This effectively allows us to write a ROP-payload
directly onto the enclave stack.
Intel acknowledged the problem, updated their documen-
tation, and ﬁxed the issue by using serialization: instead of
passing pointers to GMP structures, the demo code now se-
rializes GMP big integer objects to strings and passes those
strings over the host-to-enclave boundary. The enclave then
deserializes the data structure, computes the result, and ﬁnally
returns the serialized result back to the host application. Since
no longer GMP big integer pointers are passed between the
host and enclave, this ﬁxes the vulnerability and removes the
problematic pattern Passing Data-Structures with Pointers
(P1) from the enclave code, which is deﬁned in the following:
P1: Passing Data-Structures with Pointers. This type of
vulnerability occurs due to complex data types in C/C++ that
are using pointers as their primary mechanism to form com-
plex data structures like lists, trees, or maps. When program-
ming with the Intel SGX SDK, the interface provided by an
enclave allows utilization of complex data types using point-
ers. However, currently the Intel SGX SDK does not automat-
ically perform a recursive copy/validation of pointer-heavy
data structures. As a consequence, it becomes dangerous to
pass data structures containing pointers to an enclave. Any
data structure containing pointers must be treated the same
way as pointers annotated with the [user_check] attribute.
5.2 WolfSSL Example Enclave
WolfSSL [69] is a small TLS/SSL library without external de-
pendencies designed for embedded devices and applications
that require to be small and self-contained. It also features
SGX support. The wolfSSL project offers an enclave that
showcases how to use the wolfSSL TLS library within SGX.
The enclave allows the host application to terminate a TLS
connection within the SGX enclave thereby protecting all
cryptographic secrets used by TLS. However, the enclave
exposes a large subset of the WolfSSL API via the ECALL
interface. We analyzed the enclave with TEEREX and discov-
ered a control-ﬂow hijacking primitive in the enclave. Our
root-cause analysis revealed the following pattern, which is
common to all the TLS enclaves we analyzed.
P2: Returning pointers to enclave memory. We observed
that many enclaves provide functionality to allocate a resource
in secure memory, e.g., a TLS session or a ﬁle object, and then
return a reference to this resource to the host application. The
next time the host application attempts to use this resource,
the corresponding function of the enclave is called with that
reference as a parameter. In C/C++ code, this is typically
achieved by returning and passing a pointer to the object
containing the resource’s data. The enclave typically validates
that the given pointer indeed points to secure memory.
In the case of wolfSSL, the legacy API of the TLS library
was almost directly accessible through the ECALL API of the
WolfSSL Example Enclave, only secured by the in-secure-
memory check, which still entailed passing the pointers of
the TLS context, TLS session, and I/O buffer objects between
host and enclave. These data structures are part of a legacy
USENIX Association
29th USENIX Security Symposium    849
/* ECALL Definition in EDL */
// a pointer to enclave memory returned
public WOLFSSL* enc_wolfSSL_new([user_check] WOLFSSL_CTX* ctx);
// pointer is passed to enclave
public int enc_wolfSSL_connect([user_check]WOLFSSL* ssl);
// ...
/* ECALL Definition in EDL */
public void* tls_client_new()
public int tls_client_write(
[user_check]
[in, size=cnt] char* buf,
int cnt);
void* session,
/* C Source Code */
typedef int (*CallbackIOSend)(WOLFSSL *ssl, char *buf,
// Rust Source Code
pub extern "C" fn tls_client_write(
int sz, void *ctx);
/* WolfSSL session type */
struct WOLFSSL {
WOLFSSL_CTX*
/* ... */
// attacker-controlled function pointer!
CallbackIOSend CBIOSend;
ctx;
}
// ...
int enc_wolfSSL_connect(WOLFSSL* ssl) {
 if(sgx_is_within_enclave(ssl, wolfSSL_GetObjectSize()) != 1)
abort();
/* ... */ }
session: *const c_void,
bu: * const c_char,
cnt: c_int) -> c_int {
 if session.is_null() {
return -1;
}
 if rsgx_raw_is_outside_enclave(
session as * const u8,
mem::size_of::()) {
return -1;
}
rsgx_lfence();
Figure 5: Relevant parts of the EDL deﬁnition and C source
code of the tlsclient enclave. Note the insufﬁcient valida-
tion .
let session = unsafe { &mut *(session as *mut TlsClient) };
Figure 6: Vulnerable Rust code: Check  can be bypassed.
API which were not designed with a split trust model in mind
and it is very hard for the enclave to thoroughly validate the
pointers forwarded to the legacy interface. Figure 5 shows
the deﬁnition of the ECALL interface: a pointer to a WOFLSSL
structure is passed with the [user_check] attribute. Note,
that the WOLFSSL data structure contains a function pointer
used for issuing callbacks in the TLS library (CBIOSend).
TEEREX identiﬁed a control-ﬂow hijacking primitive by pass-
ing a fake WOLFSSL data structure with an attacker-controlled
CBIOSend function pointer.
However, the WolfSSL Example Enclave still implements
a pointer validation routine: it validates that the pointer does
point to enclave memory (Figure 5: ). However, this pointer
validation is not sufﬁcient to protect the enclave. It is com-
mon that an attacker can actually control parts of the en-
clave memory, simply by providing input arguments. For
example, an attacker can abuse a different ECALL with
a buffer parameter to force the enclave to copy arbitrary
data into enclave memory. In our PoC exploit, we abused
the function enc_wolfSSL_CTX_use_PrivateKey_buffer
to copy a fake WOLFSSL structure into unrelated enclave
memory (a simple buffer). Thereafter, we call the function
enc_wolfSSL_connect, which uses the attacker-controlled
CBIOSend function pointer in the fake data structure, which
now resides in secure memory.
This could either be ﬁxed by using session identiﬁers as it
was done by the Rust SGX SDK’s tlsclient enclave (cf. Sec-
tion 5.3) or—to not change the external API—by saving all
created session pointers in secure memory and only accepting
these known pointers.
5.3 Rust SGX SDK’s tlsclient/server
The Rust SGX SDK [22] aims at introducing memory safety
for SGX. As such, enclaves developed with this framework
should very unlikely suffer from memory corruption bugs. To
validate this, we analyze code shipped with the Rust SGX
SDK that shows how to run a TLS server and client inside of
an SGX enclave. The code consists of two similarly structured
applications and enclaves that interconnect using TLS to send
an HTTP request. This shows how secure communication can
be achieved while secret keys remain in protected memory.
Since both applications are similar in terms of their enclave
interfaces, we only discuss the tlsclient enclave. The enclave
API consists of functions to create a new TLS session and then
utilize the session to send and receive data securely. TEEREX
discovered a control-ﬂow hijacking primitive in the enclave
function tls_client_write that abuses the session pointer
parameter of the ECALL. The root cause for the vulnerability
of this enclave is the same pattern that already made the Wolf-
SSL Example Enclave (Section 5.2) vulnerable (Returning
pointers to enclave memory (P2)). The TLS session object
is allocated within enclave memory with the tls_client_
new function and then passed to further API calls like tls_
client_write. The pointer has to be marked as user_check.
Otherwise, the SGX SDK would reject the raw pointer. How-
ever, there is a variable nested in the TLSSession object that
contains a pointer to a virtual method table (vtable) for dy-
namic dispatch. By controlling the pointer to the object, the
attacker controls the pointer to the virtual method table and
gains full control over the target of an indirect call.
The enclave code, as shown in Figure 6, implements two
pointer validation checks on the session pointer: (1) the
850    29th USENIX Security Symposium
USENIX Association
pointer is checked to be not null  and (2) not to be out-
side of the enclave . However, the check at  is not
sufﬁcient to protect the enclave since there are two pos-
sible bypasses. First, the attacker can abuse a different
ECALL to copy attacker-controlled data from the host ap-
plication into the enclave memory (cf. Section 5.2). Sec-
ond, the check at  neglects that there are three memory
states: outside, within the enclave, and partially inside the en-
clave. Hence, outside_enclave and within_enclave are
not strictly inverse, both return false for any memory that
is neither strictly outside nor strictly within the enclave. The
intention of the enclave developer for check  was to as-
sess whether the session pointer does indeed point to mem-
ory inside of the enclave, i.e. return an error if it is not
strictly within (if ! rsgx_raw_is_within_enclave(...)
return -1;). This error belongs to the following pattern.
P3: Pointers to Overlapping Memory. For validating that
an object is in secure memory, the Intel SGX SDK pro-
vides two functions: sgx_is_within_enclave and sgx_is_
outside_enclave. These functions check whether a mem-
ory area is strictly outside or inside enclave memory. How-
ever, they return unexpected results when handling edge-cases,
where a memory buffer is overlapping both areas. Figure 7
shows three different scenarios with buffers located either out-
side, inside, or outside as well as inside enclave memory. The
validation functions from the Intel SGX SDK return false
for buffers that are overlapping both memory areas.
In the case of the Rust SGX SDK’s tlsclient, we can abuse
the buggy check in  to bypass the pointer validation rou-
tine in our PoC exploit. We allocate a page in the virtual
address space right before the ﬁrst page of enclave memory.