ℓ=1 𝑚ℓ. Recall that 𝑅𝑝 = Z𝑝[𝜁𝑚1, . . . , 𝜁𝑚𝑡], and that
Z*
𝑚ℓ is a group isomorphism. Using this, we can
Z*
𝑚ℓ. With this indexing, the CRT basis ⃗𝑐𝑚 of 𝑅𝑝 is
the natural homomorphism 𝜑 : Z*
ℓ
ℓ
the Kronecker product of the CRT bases ⃗𝑐𝑚ℓ of Z𝑝[𝜁𝑚ℓ]:
⨂︁
⃗𝑐𝑚 =
⃗𝑐𝑚ℓ,
ℓ
i.e., the 𝜑(𝑖)th entry of ⃗𝑐𝑚 is the product of the 𝜑(𝑖)ℓth entry of ⃗𝑐𝑚ℓ, taken over all ℓ. It is
easy to verify that Equation (2.2.7) holds for ⃗𝑐𝑚, because it does for all the ⃗𝑐𝑚ℓ.
Prime-power cyclotomics. Now let 𝑚 be a positive power of a prime 𝑝, and let 𝜔𝑚 ∈ Z*
be an element of order 𝑚 (i.e., a primitive 𝑚th root of unity), which exists because Z*
𝑝 is a
cyclic group of order 𝑝 − 1, which is divisible by 𝑚. We rely on two standard facts:
𝑝
27
1. the Kummer-Dedekind Theorem, which implies that the ideal 𝑝𝑅 =∏︀
into the product of 𝜙(𝑚) distinct prime ideals p𝑖 = (𝜁𝑚 − 𝜔𝑖
𝑚)𝑅 + 𝑝𝑅 ⊂ 𝑅; and
𝑖∈Z*
𝑚
p𝑖 factors
2. the Chinese Remainder Theorem (CRT), which implies that the natural homomor-
phism from 𝑅𝑝 to the product ring∏︀
𝑖∈Z*
𝑚
𝑅/p𝑖 is a ring isomorphism.
Using this isomorphism, the basis ⃗𝑐𝑚 is deﬁned so that its 𝑖th entry 𝑐𝑖 ∈ 𝑅𝑝 satisﬁes
𝑐𝑖 = 𝛿𝑖,𝑖′ (mod p𝑖′) for all 𝑖, 𝑖′ ∈ Z*
𝑚. Observe that this deﬁnition clearly satisﬁes Equa-
tion (2.2.7).
Like the powerful and decoding bases, for any extension 𝑅′
𝑝/𝑅𝑝 where 𝑅′ = 𝒪𝑚′,
𝑅 = 𝒪𝑚 for powers 𝑚|𝑚′ of 𝑝, there is a relative CRT 𝑅𝑝-basis ⃗𝑐𝑚′,𝑚 of 𝑅′
𝑝, which has a
Kronecker-product factorization mirroring the one in Equation (2.2.1). The elements of this
𝑅𝑝-basis satisfy Equation (2.2.7), and hence their traces into 𝑅𝑝 are all unity.
2.2.7 Computational Problems for Cyclotomic Rings
Learning with Errors Ring-Learning-With-Errors (Ring-LWE) is a family of computa-
tional problems that was deﬁned and analyzed in [LPR13b; LPR13a]. Those works use a
form of Ring-LWE involving the dual ideal 𝑅∨. Formally, for an integer 𝑞 > 1 deﬁning
𝑅𝑞 := 𝑅/𝑞𝑅, a secret 𝑠 ∈ 𝑅∨, and an error distribution 𝜓 over 𝐾R, 𝑅-LWE is a distribution
𝐴𝑞,𝑠,𝜓 where samples are generated by choosing a uniformly random 𝑎 ∈ 𝑅𝑞, 𝑒 ← 𝜓, and
outputting
(𝑎, 𝑏 = 𝑎 · 𝑠 + 𝑒 mod 𝑞𝑅∨) ∈ 𝑅𝑞 × (𝐾R/(𝑞𝑅∨)).
Typically, 𝜓 is either a continuous spherical Gaussian or its discretization to 𝑅∨; these
respectively give us continuous (where 𝑏𝑖 ∈ 𝐾/𝑞𝑅∨) and discrete (where 𝑏𝑖 ∈ 𝑅∨
𝑞 ) forms of
the following problems:
Search-Ring-LWE The search problem is to recover the secret 𝑠 given polynomially many
samples from 𝐴𝑞,𝑠,𝜓.
28
Decision-Ring-LWE The decision problem is to distinguish (with non-negligible advantage
in 𝑛) between independent samples from 𝐴𝑞,𝑠,𝜓 and uniformly random samples.
It is often more convenient for implementations to use an equivalent form of Ring-LWE
that does not involve 𝑅∨. As ﬁrst suggested in [AP13], this can be done with no loss in
security or efﬁciency by working with an equivalent “tweaked” form of the problem, which
is obtained by multiplying the noisy products 𝑏𝑖 by the tweak factor 𝑡 = 𝑡𝑚 = ˆ𝑚/𝑔𝑚 ∈ 𝑅.
Doing so yields new noisy products
𝑖 := 𝑡 · 𝑏𝑖 = 𝑎𝑖 · (𝑡 · 𝑠) + (𝑡 · 𝑒𝑖) = 𝑎𝑖 · 𝑠′ + 𝑒′
𝑏′
𝑖 mod 𝑞𝑅,
𝑖 = 𝑡 · 𝑒𝑖 come from
where both 𝑎𝑖 and 𝑠′ = 𝑡 · 𝑠 reside in 𝑅/𝑞𝑅, and the error terms 𝑒′
the “tweaked” distribution 𝑡 · 𝜓. Note that when 𝜓 corresponds to a spherical Gaussian
(in the canonical embedding), its tweaked form 𝑡 · 𝜓 may be highly non-spherical, but this
is not a problem: the tweaked form of Ring-LWE is entirely equivalent to the above one
involving 𝑅∨, because the tweak is reversible.
In this paper, our exposition primarily uses the original form of Ring-LWE involving 𝑅∨,
so that we can use sharp concentration bounds on spherical Gaussians. Our implementations,
however, uses the tweaked form, where equivalent bounds follow by ‖𝑔 · 𝑒′‖ = ‖𝑔 · 𝑡 · 𝑒‖ =
ˆ𝑚 · ‖𝑒‖, where 𝑒 is the original error term and 𝑒′ = 𝑡 · 𝑒 is its tweaked counterpart.
Learning with Rounding Ring-Learning-With-Rounding (Ring-LWR) is closely related
to Ring-LWE. It replaces the error term from a distribution with deterministic roundoff
error. For two integers 𝑞 ≥ 𝑝 ≥ 2 and a secret 𝑠 ∈ 𝑅𝑞, 𝑅-LWR is a distribution 𝐿𝑠,𝑞,𝑝 over
𝑅𝑞 × 𝑅𝑝. Samples are obtained by sampling a uniformly random 𝑎 ∈ 𝑅𝑞 and outputting
(𝑎, 𝑏 = ⌊𝑎 · 𝑠⌉𝑝).
Like Ring-LWE, there is a search and decision variant of Ring-LWR , deﬁned analogously.
29
2.3 Haskell Background
In this section we give a brief primer on the basic syntax, concepts, and features of Haskell
needed to understand the material in the rest of the paper. For further details, see the
excellent tutorial [Lip11].
2.3.1 Types
Every well-formed Haskell expression has a particular type, which is known statically (i.e.,
at compile time). An expression’s type can be explicitly speciﬁed by a type signature using
the :: symbol, e.g., 3 :: Integer or True :: Bool. However, such low-level type
annotations are usually not necessary, because Haskell has very powerful type inference,
which can automatically determine the types of arbitrarily complex expressions (or declare
that they are ill-typed).
Every function, being a legal expression, has a type, which is written by separating the
types of the input(s) and the output with the arrow -> symbol, e.g., xor :: Bool -> Bool
-> Bool. Functions can be either fully or only partially applied to arguments having the
appropriate types, e.g., we have the expressions xor False False :: Bool and xor True
:: Bool -> Bool, but not the ill-typed xor 3. Partial application works because -> is
right-associative, so the “true” type of xor is Bool -> (Bool -> Bool), i.e., it takes a
boolean as input and outputs a function that itself maps a boolean to a boolean. Functions
can also take functions as inputs, e.g.,
selfCompose :: (Integer -> Integer) -> (Integer -> Integer)
takes any f :: Integer -> Integer as input and outputs another function (presumably
representing f ∘ f).
The names of concrete types, such as Integer or Bool, are always capitalized. This is
in contrast with lower-case type variables, which can stand for any type (possibly subject to
some constraints; see the next subsection). For example, the function alwaysTrue :: a
30
-> Bool takes a value of any type, and outputs a boolean value (presumably True). More
interestingly, cons :: a -> [a] -> [a] takes a value of any type, and a list of values all
having that same type, and outputs a list of values of that type.
Types can be parameterized by other types. For example:
• The type [] seen just above is the generic “(ordered) list” type, whose single argument
is the type of the listed values, e.g., [Bool] is the “list of booleans” type. (Note that
[a] is just syntactic sugar for [] a.)
• The type Maybe represents “either a value (of a particular type), or nothing at all;” the
latter is typically used to signify an exception. Its single argument is the underlying
type, e.g., Maybe Integer.
• The generic “pair” type (,) takes two arguments that specify the types being paired
together, e.g., (Integer,Bool).
Only fully applied types can admit values, e.g., there are no values of type [], Maybe, or
(Integer,).
2.3.2 Type Classes
Type classes, or just classes, deﬁne abstract interfaces that types can implement, and are
therefore a primary mechanism for obtaining polymorphism. For example, the Additive
class (from the numeric prelude [TTJ15]) represents types that form abelian additive groups.
As such, it introduces the terms4
zero
:: Additive a => a
negate
:: Additive a => a -> a
(+), (-) :: Additive a => a -> a -> a
4Operators like +, -, *, /, and == are merely functions introduced by various type classes. Function names
consisting solely of special characters can be used in inﬁx form in the expected way, but in all other contexts
they must be surrounded by parentheses.
31
In type signatures like the ones above, the text preceding the => symbol speciﬁes the class
constraint(s) on the type variable(s). The constraints Additive a seen above simply mean
that the type represented by a must be an instance of the Additive class. A type is made an
instance of a class via an instance declaration, which simply deﬁnes the actual behavior of
the class’s terms for that particular type. For example, Integer and Double are instances of
Additive. While Bool is not, it could be made one via the instance declaration
instance Additive Bool where
zero
= False
negate = id
(+)
= xor
-- same for (-)
Using class constraints, one can write polymorphic expressions using the terms associ-
ated with the corresponding classes. For example, we can deﬁne double :: Additive a
=> a -> a as double x = x + x. The use of (+) here is legal because the input x has type
a, which is constrained to be an instance of Additive by the type of double. As a slightly
richer example, we can deﬁne
isZero :: (Eq a, Additive a) => a -> Bool
isZero x = x == zero
where the class Eq introduces the function (==) :: Eq a => a -> a -> Bool to represent
types whose values can be tested for equality.5
The deﬁnition of a class C can declare other classes as superclasses, which means that
any type that is an instance of C must also be an instance of each superclass. For example,
the class Ring from numeric prelude, which represents types that form rings with identity,
has Additive as a superclass; this is done by writing class Additive r => Ring r in
the class deﬁnition.6 One advantage of superclasses is that they help reduce the complexity
5Notice the type inference here: the use of (==) means that x and zero must have the same type a (which
must be an instance of Additive), so there is no ambiguity about which implementation of zero to use.
6It is generally agreed that the arrow points in the wrong direction, but for historical reasons we are stuck
with this syntax.
32
of class constraints. For example, we can deﬁne f :: Ring r => r -> r as f x = one
+ double x, where the term one :: Ring r => r is introduced by Ring, and double is
as deﬁned above. The use of (+) and double is legal here, because f’s input x has type r,
which (by the class constraint on f) is an instance of Ring and hence also of Additive.
So far, the discussion has been limited to single-parameter classes: a type either is,
or is not, an instance of the class. In other words, such a class can be seen as merely the
set of its instance types. More generally, multi-parameter classes express relations among
types. For example, the two-argument class deﬁnition class (Ring r, Additive a) =>
Module r a represents that the additive group a is a module over the ring r, via the scalar
multiplication function (*>) :: Module r a => r -> a -> a.
33
CHAPTER 3
Λ∘𝜆: FUNCTIONAL LATTICE CRYPTOGRAPHY
Recent theoretical improvements in lattice cryptography have paved the way for the practical
implementation of lattice/ring-based schemes, with many impressive results. To date, each
such implementation has been specialized to a particular cryptographic primitive (and
sometimes even to a speciﬁc computational platform), e.g., collision-resistant hashing (using
SIMD instruction sets) [Lyu+08], digital signatures [GLP12; Duc+13], key-establishment
protocols [Bos+15; Alk+16; Bos+16b], and homomorphic encryption (HE) [NLV11; HS]
(using GPUs and FPGAs [Wan+12; Cou+14]), to name a few.
However, the state of lattice cryptography implementations is also highly fragmented:
they are usually focused on a single cryptosystem for ﬁxed parameter sets, and have few
reusable interfaces, making them hard to implement other primitives upon. Those interfaces
that do exist are quite low-level; e.g., they require the programmer to explicitly convert
between various representations of ring elements, which calls for specialized expertise and
can be error prone. Finally, prior implementations either do not support, or use suboptimal
algorithms for, the important class of arbitrary cyclotomic rings, and thereby lack related
classes of HE functionality. (See subsection 3.1.4 for a more detailed review of related
work.)
With all this in mind, we contend that there is a need for a general-purpose, high-
level, and feature-rich framework that will allow researchers to more easily implement and
experiment with the wide variety of lattice-based cryptographic schemes, particularly more
complex ones like HE.
34
3.1 Contributions
This work describes the design, implementation, and evaluation of Λ∘𝜆, a general-purpose
framework for lattice-based cryptography in the compiled, functional, strongly typed pro-
gramming language Haskell.1,2 Our primary goals for Λ∘ 𝜆 include: (1) the ability to
implement both basic and advanced lattice cryptosystems correctly, concisely, and at a high
level of abstraction; (2) alignment with the current best theory concerning security and
algorithmic efﬁciency; and (3) acceptable performance on commodity CPUs, along with the
capacity to integrate specialized backends (e.g., GPUs) without affecting application code.
3.1.1 Novel Attributes of Λ∘𝜆
The Λ∘𝜆 framework has several novel properties that distinguish it from prior lattice-crypto
implementations.
Generality, modularity, and concision: Λ∘ 𝜆 deﬁnes a collection of simple, modular
interfaces and implementations for the lattice cryptography “toolbox,” i.e., the collection
of operations that are used across a wide variety of modern cryptographic constructions.
This generality allows cryptographic schemes to be expressed very naturally and concisely,
via code that closely mirrors their mathematical deﬁnitions. For example in chapter 4,
we implement a full-featured SHE scheme (which includes never-before-implemented
functionality) in as few as 2–5 lines of code per feature.
While Λ∘𝜆’s interfaces are general enough to support most modern lattice-based cryp-
tosystems, our main focus (as with most prior implementations) is on systems deﬁned over
cyclotomic rings, because they lie at the heart of practically efﬁcient lattice-based cryp-
by Λ and 𝜆, respectively. The recommended pronunciation is “L O L.”
tography (see, e.g., [HPS98; Mic07; LPR13b; LPR13a]). However, while almost all prior
1The name Λ∘𝜆 refers to the combination of lattices and functional programming, which are often signiﬁed
2Λ∘𝜆 is available under the free and open-source GNU GPL2 license. It can be installed from Hackage,
the Haskell community’s central repository, via stack install lol. The source repository is also available
at https://github.com/cpeikert/Lol.
35
implementations are limited to the narrow subclass of power-of-two cyclotomics (which are
the algorithmically simplest case), Λ∘𝜆 supports arbitrary cyclotomic rings. Such support
is essential in a general framework, because many advanced techniques in ring-based cryp-
tography, such as “plaintext packing” and homomorphic SIMD operations [SV10; SV14],
inherently require non-power-of-two cyclotomics when using characteristic-two plaintext
spaces (e.g., F2𝑘).
Theory afﬁnity: Λ∘𝜆 is designed from the ground-up around the specialized ring represen-
tations, fast algorithms, and worst-case hardness proofs developed in [LPR13b; LPR13a] for
the design and analysis of ring-based cryptosystems (over arbitrary cyclotomic rings), partic-
ularly those relying on Ring-LWE. To our knowledge, Λ∘𝜆 is the ﬁrst-ever implementation
of these techniques, which include: