â„“=1 ğ‘šâ„“. Recall that ğ‘…ğ‘ = Zğ‘[ğœğ‘š1, . . . , ğœğ‘šğ‘¡], and that
Z*
ğ‘šâ„“ is a group isomorphism. Using this, we can
Z*
ğ‘šâ„“. With this indexing, the CRT basis âƒ—ğ‘ğ‘š of ğ‘…ğ‘ is
the natural homomorphism ğœ‘ : Z*
â„“
â„“
the Kronecker product of the CRT bases âƒ—ğ‘ğ‘šâ„“ of Zğ‘[ğœğ‘šâ„“]:
â¨‚ï¸
âƒ—ğ‘ğ‘š =
âƒ—ğ‘ğ‘šâ„“,
â„“
i.e., the ğœ‘(ğ‘–)th entry of âƒ—ğ‘ğ‘š is the product of the ğœ‘(ğ‘–)â„“th entry of âƒ—ğ‘ğ‘šâ„“, taken over all â„“. It is
easy to verify that Equation (2.2.7) holds for âƒ—ğ‘ğ‘š, because it does for all the âƒ—ğ‘ğ‘šâ„“.
Prime-power cyclotomics. Now let ğ‘š be a positive power of a prime ğ‘, and let ğœ”ğ‘š âˆˆ Z*
be an element of order ğ‘š (i.e., a primitive ğ‘šth root of unity), which exists because Z*
ğ‘ is a
cyclic group of order ğ‘ âˆ’ 1, which is divisible by ğ‘š. We rely on two standard facts:
ğ‘
27
1. the Kummer-Dedekind Theorem, which implies that the ideal ğ‘ğ‘… =âˆï¸€
into the product of ğœ™(ğ‘š) distinct prime ideals pğ‘– = (ğœğ‘š âˆ’ ğœ”ğ‘–
ğ‘š)ğ‘… + ğ‘ğ‘… âŠ‚ ğ‘…; and
ğ‘–âˆˆZ*
ğ‘š
pğ‘– factors
2. the Chinese Remainder Theorem (CRT), which implies that the natural homomor-
phism from ğ‘…ğ‘ to the product ringâˆï¸€
ğ‘–âˆˆZ*
ğ‘š
ğ‘…/pğ‘– is a ring isomorphism.
Using this isomorphism, the basis âƒ—ğ‘ğ‘š is deï¬ned so that its ğ‘–th entry ğ‘ğ‘– âˆˆ ğ‘…ğ‘ satisï¬es
ğ‘ğ‘– = ğ›¿ğ‘–,ğ‘–â€² (mod pğ‘–â€²) for all ğ‘–, ğ‘–â€² âˆˆ Z*
ğ‘š. Observe that this deï¬nition clearly satisï¬es Equa-
tion (2.2.7).
Like the powerful and decoding bases, for any extension ğ‘…â€²
ğ‘/ğ‘…ğ‘ where ğ‘…â€² = ğ’ªğ‘šâ€²,
ğ‘… = ğ’ªğ‘š for powers ğ‘š|ğ‘šâ€² of ğ‘, there is a relative CRT ğ‘…ğ‘-basis âƒ—ğ‘ğ‘šâ€²,ğ‘š of ğ‘…â€²
ğ‘, which has a
Kronecker-product factorization mirroring the one in Equation (2.2.1). The elements of this
ğ‘…ğ‘-basis satisfy Equation (2.2.7), and hence their traces into ğ‘…ğ‘ are all unity.
2.2.7 Computational Problems for Cyclotomic Rings
Learning with Errors Ring-Learning-With-Errors (Ring-LWE) is a family of computa-
tional problems that was deï¬ned and analyzed in [LPR13b; LPR13a]. Those works use a
form of Ring-LWE involving the dual ideal ğ‘…âˆ¨. Formally, for an integer ğ‘ > 1 deï¬ning
ğ‘…ğ‘ := ğ‘…/ğ‘ğ‘…, a secret ğ‘  âˆˆ ğ‘…âˆ¨, and an error distribution ğœ“ over ğ¾R, ğ‘…-LWE is a distribution
ğ´ğ‘,ğ‘ ,ğœ“ where samples are generated by choosing a uniformly random ğ‘ âˆˆ ğ‘…ğ‘, ğ‘’ â† ğœ“, and
outputting
(ğ‘, ğ‘ = ğ‘ Â· ğ‘  + ğ‘’ mod ğ‘ğ‘…âˆ¨) âˆˆ ğ‘…ğ‘ Ã— (ğ¾R/(ğ‘ğ‘…âˆ¨)).
Typically, ğœ“ is either a continuous spherical Gaussian or its discretization to ğ‘…âˆ¨; these
respectively give us continuous (where ğ‘ğ‘– âˆˆ ğ¾/ğ‘ğ‘…âˆ¨) and discrete (where ğ‘ğ‘– âˆˆ ğ‘…âˆ¨
ğ‘ ) forms of
the following problems:
Search-Ring-LWE The search problem is to recover the secret ğ‘  given polynomially many
samples from ğ´ğ‘,ğ‘ ,ğœ“.
28
Decision-Ring-LWE The decision problem is to distinguish (with non-negligible advantage
in ğ‘›) between independent samples from ğ´ğ‘,ğ‘ ,ğœ“ and uniformly random samples.
It is often more convenient for implementations to use an equivalent form of Ring-LWE
that does not involve ğ‘…âˆ¨. As ï¬rst suggested in [AP13], this can be done with no loss in
security or efï¬ciency by working with an equivalent â€œtweakedâ€ form of the problem, which
is obtained by multiplying the noisy products ğ‘ğ‘– by the tweak factor ğ‘¡ = ğ‘¡ğ‘š = Ë†ğ‘š/ğ‘”ğ‘š âˆˆ ğ‘….
Doing so yields new noisy products
ğ‘– := ğ‘¡ Â· ğ‘ğ‘– = ğ‘ğ‘– Â· (ğ‘¡ Â· ğ‘ ) + (ğ‘¡ Â· ğ‘’ğ‘–) = ğ‘ğ‘– Â· ğ‘ â€² + ğ‘’â€²
ğ‘â€²
ğ‘– mod ğ‘ğ‘…,
ğ‘– = ğ‘¡ Â· ğ‘’ğ‘– come from
where both ğ‘ğ‘– and ğ‘ â€² = ğ‘¡ Â· ğ‘  reside in ğ‘…/ğ‘ğ‘…, and the error terms ğ‘’â€²
the â€œtweakedâ€ distribution ğ‘¡ Â· ğœ“. Note that when ğœ“ corresponds to a spherical Gaussian
(in the canonical embedding), its tweaked form ğ‘¡ Â· ğœ“ may be highly non-spherical, but this
is not a problem: the tweaked form of Ring-LWE is entirely equivalent to the above one
involving ğ‘…âˆ¨, because the tweak is reversible.
In this paper, our exposition primarily uses the original form of Ring-LWE involving ğ‘…âˆ¨,
so that we can use sharp concentration bounds on spherical Gaussians. Our implementations,
however, uses the tweaked form, where equivalent bounds follow by â€–ğ‘” Â· ğ‘’â€²â€– = â€–ğ‘” Â· ğ‘¡ Â· ğ‘’â€– =
Ë†ğ‘š Â· â€–ğ‘’â€–, where ğ‘’ is the original error term and ğ‘’â€² = ğ‘¡ Â· ğ‘’ is its tweaked counterpart.
Learning with Rounding Ring-Learning-With-Rounding (Ring-LWR) is closely related
to Ring-LWE. It replaces the error term from a distribution with deterministic roundoff
error. For two integers ğ‘ â‰¥ ğ‘ â‰¥ 2 and a secret ğ‘  âˆˆ ğ‘…ğ‘, ğ‘…-LWR is a distribution ğ¿ğ‘ ,ğ‘,ğ‘ over
ğ‘…ğ‘ Ã— ğ‘…ğ‘. Samples are obtained by sampling a uniformly random ğ‘ âˆˆ ğ‘…ğ‘ and outputting
(ğ‘, ğ‘ = âŒŠğ‘ Â· ğ‘ âŒ‰ğ‘).
Like Ring-LWE, there is a search and decision variant of Ring-LWR , deï¬ned analogously.
29
2.3 Haskell Background
In this section we give a brief primer on the basic syntax, concepts, and features of Haskell
needed to understand the material in the rest of the paper. For further details, see the
excellent tutorial [Lip11].
2.3.1 Types
Every well-formed Haskell expression has a particular type, which is known statically (i.e.,
at compile time). An expressionâ€™s type can be explicitly speciï¬ed by a type signature using
the :: symbol, e.g., 3 :: Integer or True :: Bool. However, such low-level type
annotations are usually not necessary, because Haskell has very powerful type inference,
which can automatically determine the types of arbitrarily complex expressions (or declare
that they are ill-typed).
Every function, being a legal expression, has a type, which is written by separating the
types of the input(s) and the output with the arrow -> symbol, e.g., xor :: Bool -> Bool
-> Bool. Functions can be either fully or only partially applied to arguments having the
appropriate types, e.g., we have the expressions xor False False :: Bool and xor True
:: Bool -> Bool, but not the ill-typed xor 3. Partial application works because -> is
right-associative, so the â€œtrueâ€ type of xor is Bool -> (Bool -> Bool), i.e., it takes a
boolean as input and outputs a function that itself maps a boolean to a boolean. Functions
can also take functions as inputs, e.g.,
selfCompose :: (Integer -> Integer) -> (Integer -> Integer)
takes any f :: Integer -> Integer as input and outputs another function (presumably
representing f âˆ˜ f).
The names of concrete types, such as Integer or Bool, are always capitalized. This is
in contrast with lower-case type variables, which can stand for any type (possibly subject to
some constraints; see the next subsection). For example, the function alwaysTrue :: a
30
-> Bool takes a value of any type, and outputs a boolean value (presumably True). More
interestingly, cons :: a -> [a] -> [a] takes a value of any type, and a list of values all
having that same type, and outputs a list of values of that type.
Types can be parameterized by other types. For example:
â€¢ The type [] seen just above is the generic â€œ(ordered) listâ€ type, whose single argument
is the type of the listed values, e.g., [Bool] is the â€œlist of booleansâ€ type. (Note that
[a] is just syntactic sugar for [] a.)
â€¢ The type Maybe represents â€œeither a value (of a particular type), or nothing at all;â€ the
latter is typically used to signify an exception. Its single argument is the underlying
type, e.g., Maybe Integer.
â€¢ The generic â€œpairâ€ type (,) takes two arguments that specify the types being paired
together, e.g., (Integer,Bool).
Only fully applied types can admit values, e.g., there are no values of type [], Maybe, or
(Integer,).
2.3.2 Type Classes
Type classes, or just classes, deï¬ne abstract interfaces that types can implement, and are
therefore a primary mechanism for obtaining polymorphism. For example, the Additive
class (from the numeric prelude [TTJ15]) represents types that form abelian additive groups.
As such, it introduces the terms4
zero
:: Additive a => a
negate
:: Additive a => a -> a
(+), (-) :: Additive a => a -> a -> a
4Operators like +, -, *, /, and == are merely functions introduced by various type classes. Function names
consisting solely of special characters can be used in inï¬x form in the expected way, but in all other contexts
they must be surrounded by parentheses.
31
In type signatures like the ones above, the text preceding the => symbol speciï¬es the class
constraint(s) on the type variable(s). The constraints Additive a seen above simply mean
that the type represented by a must be an instance of the Additive class. A type is made an
instance of a class via an instance declaration, which simply deï¬nes the actual behavior of
the classâ€™s terms for that particular type. For example, Integer and Double are instances of
Additive. While Bool is not, it could be made one via the instance declaration
instance Additive Bool where
zero
= False
negate = id
(+)
= xor
-- same for (-)
Using class constraints, one can write polymorphic expressions using the terms associ-
ated with the corresponding classes. For example, we can deï¬ne double :: Additive a
=> a -> a as double x = x + x. The use of (+) here is legal because the input x has type
a, which is constrained to be an instance of Additive by the type of double. As a slightly
richer example, we can deï¬ne
isZero :: (Eq a, Additive a) => a -> Bool
isZero x = x == zero
where the class Eq introduces the function (==) :: Eq a => a -> a -> Bool to represent
types whose values can be tested for equality.5
The deï¬nition of a class C can declare other classes as superclasses, which means that
any type that is an instance of C must also be an instance of each superclass. For example,
the class Ring from numeric prelude, which represents types that form rings with identity,
has Additive as a superclass; this is done by writing class Additive r => Ring r in
the class deï¬nition.6 One advantage of superclasses is that they help reduce the complexity
5Notice the type inference here: the use of (==) means that x and zero must have the same type a (which
must be an instance of Additive), so there is no ambiguity about which implementation of zero to use.
6It is generally agreed that the arrow points in the wrong direction, but for historical reasons we are stuck
with this syntax.
32
of class constraints. For example, we can deï¬ne f :: Ring r => r -> r as f x = one
+ double x, where the term one :: Ring r => r is introduced by Ring, and double is
as deï¬ned above. The use of (+) and double is legal here, because fâ€™s input x has type r,
which (by the class constraint on f) is an instance of Ring and hence also of Additive.
So far, the discussion has been limited to single-parameter classes: a type either is,
or is not, an instance of the class. In other words, such a class can be seen as merely the
set of its instance types. More generally, multi-parameter classes express relations among
types. For example, the two-argument class deï¬nition class (Ring r, Additive a) =>
Module r a represents that the additive group a is a module over the ring r, via the scalar
multiplication function (*>) :: Module r a => r -> a -> a.
33
CHAPTER 3
Î›âˆ˜ğœ†: FUNCTIONAL LATTICE CRYPTOGRAPHY
Recent theoretical improvements in lattice cryptography have paved the way for the practical
implementation of lattice/ring-based schemes, with many impressive results. To date, each
such implementation has been specialized to a particular cryptographic primitive (and
sometimes even to a speciï¬c computational platform), e.g., collision-resistant hashing (using
SIMD instruction sets) [Lyu+08], digital signatures [GLP12; Duc+13], key-establishment
protocols [Bos+15; Alk+16; Bos+16b], and homomorphic encryption (HE) [NLV11; HS]
(using GPUs and FPGAs [Wan+12; Cou+14]), to name a few.
However, the state of lattice cryptography implementations is also highly fragmented:
they are usually focused on a single cryptosystem for ï¬xed parameter sets, and have few
reusable interfaces, making them hard to implement other primitives upon. Those interfaces
that do exist are quite low-level; e.g., they require the programmer to explicitly convert
between various representations of ring elements, which calls for specialized expertise and
can be error prone. Finally, prior implementations either do not support, or use suboptimal
algorithms for, the important class of arbitrary cyclotomic rings, and thereby lack related
classes of HE functionality. (See subsection 3.1.4 for a more detailed review of related
work.)
With all this in mind, we contend that there is a need for a general-purpose, high-
level, and feature-rich framework that will allow researchers to more easily implement and
experiment with the wide variety of lattice-based cryptographic schemes, particularly more
complex ones like HE.
34
3.1 Contributions
This work describes the design, implementation, and evaluation of Î›âˆ˜ğœ†, a general-purpose
framework for lattice-based cryptography in the compiled, functional, strongly typed pro-
gramming language Haskell.1,2 Our primary goals for Î›âˆ˜ ğœ† include: (1) the ability to
implement both basic and advanced lattice cryptosystems correctly, concisely, and at a high
level of abstraction; (2) alignment with the current best theory concerning security and
algorithmic efï¬ciency; and (3) acceptable performance on commodity CPUs, along with the
capacity to integrate specialized backends (e.g., GPUs) without affecting application code.
3.1.1 Novel Attributes of Î›âˆ˜ğœ†
The Î›âˆ˜ğœ† framework has several novel properties that distinguish it from prior lattice-crypto
implementations.
Generality, modularity, and concision: Î›âˆ˜ ğœ† deï¬nes a collection of simple, modular
interfaces and implementations for the lattice cryptography â€œtoolbox,â€ i.e., the collection
of operations that are used across a wide variety of modern cryptographic constructions.
This generality allows cryptographic schemes to be expressed very naturally and concisely,
via code that closely mirrors their mathematical deï¬nitions. For example in chapter 4,
we implement a full-featured SHE scheme (which includes never-before-implemented
functionality) in as few as 2â€“5 lines of code per feature.
While Î›âˆ˜ğœ†â€™s interfaces are general enough to support most modern lattice-based cryp-
tosystems, our main focus (as with most prior implementations) is on systems deï¬ned over
cyclotomic rings, because they lie at the heart of practically efï¬cient lattice-based cryp-
by Î› and ğœ†, respectively. The recommended pronunciation is â€œL O L.â€
tography (see, e.g., [HPS98; Mic07; LPR13b; LPR13a]). However, while almost all prior
1The name Î›âˆ˜ğœ† refers to the combination of lattices and functional programming, which are often signiï¬ed
2Î›âˆ˜ğœ† is available under the free and open-source GNU GPL2 license. It can be installed from Hackage,
the Haskell communityâ€™s central repository, via stack install lol. The source repository is also available
at https://github.com/cpeikert/Lol.
35
implementations are limited to the narrow subclass of power-of-two cyclotomics (which are
the algorithmically simplest case), Î›âˆ˜ğœ† supports arbitrary cyclotomic rings. Such support
is essential in a general framework, because many advanced techniques in ring-based cryp-
tography, such as â€œplaintext packingâ€ and homomorphic SIMD operations [SV10; SV14],
inherently require non-power-of-two cyclotomics when using characteristic-two plaintext
spaces (e.g., F2ğ‘˜).
Theory afï¬nity: Î›âˆ˜ğœ† is designed from the ground-up around the specialized ring represen-
tations, fast algorithms, and worst-case hardness proofs developed in [LPR13b; LPR13a] for
the design and analysis of ring-based cryptosystems (over arbitrary cyclotomic rings), partic-
ularly those relying on Ring-LWE. To our knowledge, Î›âˆ˜ğœ† is the ï¬rst-ever implementation
of these techniques, which include: