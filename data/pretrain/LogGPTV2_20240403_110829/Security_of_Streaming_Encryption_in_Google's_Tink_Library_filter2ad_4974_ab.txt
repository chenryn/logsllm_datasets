ğ‘“1, ğ‘“2, . . . , â†$ Func(â„³,{0, 1}ğ‘›)
procedure Finalize(ğ‘â€²)
return (ğ‘â€² = ğ‘)
procedure Eval(ğ‘–, ğ‘€)
ğ‘Œ1 â† ğ¹ (ğ¾ğ‘–, ğ‘€); ğ‘Œ0 â† ğ‘“ğ‘–(ğ‘€)
return ğ‘Œğ‘
Fig. 1: Game Gprf
ğ¹ defining multi-user prf security of a function ğ¹.
procedure Initialize
ğ¾1, ğ¾2, . . . â†$ ğ’¦; ğ‘ â†$ {0, 1}
ğœ‹1, ğœ‹2, . . . â†$ Perm(ğ‘›)
procedure Finalize(ğ‘â€²)
return (ğ‘â€² = ğ‘)
procedure Eval(ğ‘–, ğ‘€)
ğ‘Œ1 â† ğ¸(ğ¾ğ‘–, ğ‘€); ğ‘Œ0 â† ğœ‹ğ‘–(ğ‘€)
return ğ‘Œğ‘
Fig. 2: Game Gprp
ğ¸ defining multi-user prp security of a blockcipher ğ¸.
Systems and Transcripts. Following the notation from [16], it is convenient to consider inter-
actions of a distinguisher ğ’œ with an abstract system S which answers ğ’œâ€™s queries. The resulting
interaction then generates a transcript ğœ = ((ğ‘‹1, ğ‘Œ1), . . . , (ğ‘‹ğ‘, ğ‘Œğ‘)) of query-answer pairs. It is
known that S is entirely described by the probabilities pS(ğœ) that correspond to the system S
responding with answers as indicated by ğœ when the queries in ğœ are made.
We will generally describe systems informally, or more formally in terms of a set of oracles they
provide, and only use the fact that they define corresponding probabilities pS(ğœ) without explicitly
giving these probabilities.
Multi-user PRF. Let ğ¹ : ğ’¦ Ã— â„³ â†’ {0, 1}ğ‘› be a function. For an adversary ğ’œ, let
Advprf
ğ¹ (ğ’œ) = 2 Pr[Gprf
ğ¹ (ğ’œ)] âˆ’ 1 ,
be the advantage of the adversary against the multi-user PRF security of ğ¹, where game Gprf
defined in Fig. 1.
For any function ğ¹ of key length ğ‘˜, by adapting Bihamâ€™s key-collision attack on DES [5], one can
obtain PRF advantage ğ‘ğ‘/2ğ‘˜+2 using ğ‘‚(ğ‘) queries and ğ‘‚(ğ‘) calls to ğ¹. See Appendix B for a
description and a rigorous analysis of this attack.
Multi-user PRP. Let ğ¸ : ğ’¦ Ã— {0, 1}ğ‘› â†’ {0, 1}ğ‘› be a blockcipher. For an adversary ğ’œ, let
ğ¹ is
Advprp
ğ¸ (ğ’œ) = 2 Pr[Gprp
ğ¸ (ğ’œ)] âˆ’ 1 ,
be the advantage of the adversary against the multi-user PRP security of ğ¸, where game Gprp
ğ¸ is
defined in Fig. 2. This game is written as a standard-model notion; in the ideal-cipher model, the
adversary will be given oracle access to ğ¸ and its inverse as well.
3 Nonce-based Online AE
In this section, we will recall the syntax and security notion for (nonce-based) online AE of Hoang
et al. [15]. We however present a single, unified security notion nOAE instead of giving separate
5
procedure Initialize
ğ¾1, ğ¾2,Â·Â·Â· â†$ ğ’¦
ğ‘ â†$ {0, 1}
procedure Enc(ğ‘–, ğ‘, ğ´, ğ‘€)
ğ¶1 â† E(ğ¾ğ‘–, ğ‘, ğ´, ğ‘€); ğ¶0 â†$ {0, 1}|ğ¶1|
return ğ¶ğ‘
procedure Dec(ğ‘–, ğ‘, ğ´, ğ¶)
if ğ‘ = 0 then return false
ğ‘€ â† D(ğ¾ğ‘–, ğ‘, ğ´, ğ¶)
return (ğ‘€ Ì¸= âŠ¥)
procedure Finalize(ğ‘)
return (ğ‘â€² = ğ‘)
Fig. 3: Game Gae
(K, E, D).
ğ›±(ğ’œ) that defines the (multi-user) security of a conventional AE scheme ğ›± =
privacy and authenticity definitions. In addition, compared to the notion of Hoang et al., ours is
stronger, as (i) the adversary can target multiple users, and (ii) for each user, it is allowed to make
multiple forgery attempts.
The treatment in [15] however assumes that a receiver will perform decryption in an in-order fashion,
but there are applications that demand random-access decryption. We identify a class of online AE
schemes that can support random-access decryption, formalize a corresponding (multi-user) notion
nOAE2, and explore the relationship between nOAE and nOAE2.
As a warm-up, we will begin with the multi-user version of the classical security notion of conven-
tional AE schemes.
Conventional AE. A conventional AE scheme ğ›± is a triple of algorithms (K, E, D); the last two
are deterministic. The key-generation algorithm K samples a key ğ¾ at random. The encryption
algorithm E takes as input a key ğ¾, a message ğ‘€, a nonce ğ‘, and an associated data (AD) ğ´
to produce a ciphertext ğ¶. Given a key ğ¾, a nonce ğ‘, an AD ğ´, and a ciphertext ğ¶, the decryp-
tion algorithm D either produces a message ğ‘€, or outputs a symbol âŠ¥ indicating invalidity. For
correctness, we require that decryption reverses encryption, meaning that if ğ¶ â† E(ğ¾, ğ‘, ğ´, ğ‘€)
then ğ‘€ â† D(ğ¾, ğ‘, ğ´, ğ¶). In this paper, we assume that there is a constant ğœ that a ciphertext is
always ğœ-bit longer than its plaintext. For example, in GCM, ğœ = 128.
Given an adversary ğ’œ, define
Advae
ğ›±(ğ’œ) = 2 Pr[Gae
ğ›±(ğ’œ)] âˆ’ 1
as the advantage of the adversary against the (multi-user) nonce-based security of a conventional
AE scheme ğ›±, where game Gae
ğ›± is defined in Fig. 3. The adversary is given an encryption oracle and
a decryption one. For encryption queries Enc(ğ‘–, ğ‘, ğ´, ğ‘€), we require that the adversary be nonce-
respecting, meaning that each pair (ğ‘–, ğ‘) must never repeat. The adversary may repeat nonces in
decryption queries, but to avoid trivial wins, if the adversary queries Enc(ğ‘–, ğ‘, ğ´, ğ‘€) to receive ğ¶,
subsequently it is prohibited from querying Dec(ğ‘–, ğ‘, ğ´, ğ¶). We note that the decryption oracle
only tells the adversary whether a query succeeds, but does not return the decrypted message.
For any conventional AE scheme of key length ğ‘˜, by adapting Bihamâ€™s key-collision attack on
DES [5], one can obtain advantage ğ‘ğ‘/2ğ‘˜+2 by making ğ‘‚(ğ‘) encryption queries and ğ‘‚(ğ‘) calls to
the encryption scheme. See Appendix B for a description and a rigorous analysis of this attack. Still,
this attack requires that some particular nonce is used for all users, which is a realistic scenario
if one implements nonces via a counter. However, if there is some variation in choosing nonces
among usersâ€”for example, if one picks nonces at randomâ€”then this attack can be mitigated.
6
Following Bose, Hoang, and Tessaro [6], we say that an adversary is ğ‘‘-repeating if among its
encryption queries, each nonce is used for at most ğ‘‘ users. Note that we levy no restriction on
nonces of decryption queries. If we restrict to ğ‘‘-repeating adversaries then the key-collision attack
only achieves advantage ğ‘‘ğ‘/2ğ‘˜+2.
Online AE. An online AE scheme ğ›± is a triple (ğ’¦,â„°,ğ’Ÿ). The key-generation algorithm ğ’¦, as
usual, samples a key ğ¾ at random. Messages, AD, and ciphertexts are vectors of strings. We
speak of segmented messages, segmented AD, and segmented ciphertexts to refer to those vectors,
and message segments, AD segments, and ciphertext segments when we refer to their components.
Nonces however are still short strings.
The encryption scheme â„° consists of three deterministic algorithms (â„°.init,â„°.next,â„°.last).
â€“ Algorithm â„°.init takes as input a key ğ¾ and a nonce ğ‘ to produce a state ğ‘†. This is used to
â€“ Algorithm â„°.next takes as input a state ğ‘†, an AD segment ğ´, and a message segment ğ‘€, to
â€“ Algorithm â„°.last takes as input a state, an AD segment, and a message segment, to produce
a ciphertext segment. This is used for the last AD segment and message segment, closing
the encryption.
initiate the encryption of a segmented message with a segmented AD.
produce a ciphertext segment ğ¶ and an updated state ğ‘†*.
In particular, to encrypt a segmented message ğ‘€ = (ğ‘€1, . . . , ğ‘€ğ‘š) and a segmented AD ğ´ =
(ğ´1, . . . , ğ´ğ‘š) under a nonce ğ‘ and a key ğ¾, one runs the following code, resulting in a segmented
ciphertext ğ¶ = (ğ¶1, . . . , ğ¶ğ‘š).
ğ‘†0 â† â„°.init(ğ¾, ğ‘)
for ğ‘– â† 1 to ğ‘š âˆ’ 1 do (ğ¶ğ‘–, ğ‘†ğ‘–) â† â„°.next(ğ‘†ğ‘–âˆ’1, ğ´ğ‘–, ğ‘€ğ‘–)
ğ¶ğ‘š â† â„°.last(ğ‘†ğ‘šâˆ’1, ğ´ğ‘š, ğ‘€ğ‘š)
return (ğ¶1, . . . , ğ¶ğ‘š)
The decryption scheme ğ’Ÿ likewise consists of three deterministic algorithms (ğ’Ÿ.init,ğ’Ÿ.next,ğ’Ÿ.last).
To decrypt a segmented ciphertext ğ¶ = (ğ¶1, . . . , ğ¶ğ‘š) and a segmented AD ğ´ = (ğ´1, . . . , ğ´ğ‘š)
under a nonce ğ‘ and a key ğ¾, one runs the following code, resulting in a (possibly partial)
segmented message.
ğ‘†0 â† ğ’Ÿ.init(ğ¾, ğ‘)
for ğ‘– â† 1 to ğ‘š âˆ’ 1 do
(ğ‘€ğ‘–, ğ‘†ğ‘–) â† ğ’Ÿ.next(ğ‘†ğ‘–âˆ’1, ğ´ğ‘–, ğ¶ğ‘–)
if ğ‘€ğ‘– = âŠ¥ then return (ğ‘€1, . . . , ğ‘€ğ‘–âˆ’1)
ğ‘€ğ‘š â† ğ’Ÿ.last(ğ‘†ğ‘šâˆ’1, ğ´ğ‘š, ğ¶ğ‘š)
if ğ‘€ğ‘š = âŠ¥ then return (ğ‘€1, . . . , ğ‘€ğ‘šâˆ’1)
return (ğ‘€1, . . . , ğ‘€ğ‘š)
Note that in the code above, if some (ğ´ğ‘–, ğ¶ğ‘–) is invalid and consequently ğ‘€ğ‘– = âŠ¥, then we immedi-
ately terminate the decryption process, returning the partial segmented message (ğ‘€1, . . . , ğ‘€ğ‘–âˆ’1).
For correctness, we require that decryption reverses encryption.
The nOAE notion. Given an adversary ğ’œ, define
Advnoae
ğ›± (ğ’œ) = 2 Pr[Gnoae
ğ›± (ğ’œ)] âˆ’ 1
7
procedure Initialize
ğ¾1, ğ¾2,Â·Â·Â· â†$ ğ’¦; ğ½1, ğ½2,Â·Â·Â· â† 0; ğ‘ â†$ {0, 1}
procedure Enc.init(ğ‘–, ğ‘)
ğ½ğ‘– â† ğ½ğ‘– + 1; ğ‘— â† ğ½ğ‘–; ğ‘†ğ‘–,ğ‘— â† â„°.init(ğ¾ğ‘–, ğ‘); return ğ½ğ‘–
procedure Enc.next(ğ‘–, ğ‘—, ğ´, ğ‘€)
if ğ‘†ğ‘–,ğ‘— = âŠ¥ then return âŠ¥
(ğ¶1, ğ‘†ğ‘–,ğ‘—) â† â„°.next(ğ‘†ğ‘–,ğ‘—, ğ´, ğ‘€); ğ¶0 â†$ {0, 1}|ğ¶1|
return ğ¶ğ‘
procedure Enc.last(ğ‘–, ğ‘—, ğ´, ğ‘€)
if ğ‘†ğ‘–,ğ‘— = âŠ¥ then return âŠ¥
ğ¶1 â† â„°.last(ğ‘†ğ‘–,ğ‘—, ğ´, ğ‘€); ğ¶0 â†$ {0, 1}|ğ¶1|; ğ‘†ğ‘–,ğ‘— â† âŠ¥
return ğ¶ğ‘
procedure Dec(ğ‘–, ğ‘, ğ´, ğ¶, ğ‘)
if ğ‘ = 0 or |ğ´| Ì¸= |ğ¶| then return false
ğ‘† â† ğ’Ÿ.init(ğ¾ğ‘–, ğ‘); ğ‘š â† |ğ¶|
for ğ‘— â† 1 to ğ‘š âˆ’ ğ‘ do
(ğ‘€, ğ‘†) â† ğ’Ÿ.next(ğ‘†, ğ´[ğ‘—], ğ¶[ğ‘—])
if ğ‘€ =âŠ¥ then return false
return (ğ‘ = 0 or ğ’Ÿ.last(ğ‘†, ğ´[ğ‘š], ğ¶[ğ‘š]) Ì¸= âŠ¥)
procedure Finalize(ğ‘â€²)
return (ğ‘â€² = ğ‘)
Fig. 4: Game defining the (multi-user) nOAE security of an online AE scheme ğ›± =
(ğ’¦,â„°,ğ’Ÿ).
ğ›±
as the advantage of the adversary against the (multi-user) nonce-based security of an online AE
scheme ğ›±, where game Gnoae
is defined in Fig. 4. In this game, the adversary is given access to