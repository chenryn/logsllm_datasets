Setup 方法为例来进行介绍，表 25-23 给出了 Setup 函数符号的属性。 
表 25-23  Setup 方法的函数符号 
属性 
值 
说明 
get_access 
public[3] 
可访问性，public 方法 
get_addressOffset 
0x620 
地址偏移 
get_addressSection 
2 
所在的节 
get_classParentId 
3266 
所属类的类型符号 ID 
get_customCallingConvention 
0 
没有使用定制的调用协议 
get_farReturn 
0 
没有包含 far return 
get_hasAlloca 
0 
方法中没有调用 alloca* 
get_hasEH 
0 
没有使用非托管的异常处理 
get_hasEHa 
0 
没有使用/EHa 编译 
get_hasInlAsm 
0 
没有使用嵌入式汇编 
get_hasLongJump 
0 
没有长跳转（long jump）** 
get_hasSecurityChecks 
0 
没有使用安全检查（cookie） 
get_hasSEH 
0 
没有使用结构化异常处理（SEH） 
get_hasSetJump 
0 
没有使用 setjump** 
get_InlSpec 
0 
没有被标记为 inline 
get_interruptReturn 
0 
是否包含中断返回指令，如 iret 
get_intro 
1 
是引入 virtual 的方法*** 
get_isNaked 
0 
是否具有 naked 属性，该属性告
诉编译器不要加入序言和结语 
get_isStatic 
0 
不是静态方法 
get_length 
0xc3 
函数的长度 
get_lexicalParentId 
316 
父词条 ID，即 BaseClass.obj 
get_locationType 
static[1] 
位置属性 
get_name 
CBaseClass::Setup 
名称 
get_noInline 
0 
没有 noinline 标记 
get_noReturn 
0 
没有 noreturn 标记 
get_noStackOrdering 
0 
安全检查（GS）时可以栈定序 
get_notReached 
0 
不具有“never reached”特征 
get_optimizedCodeDebugInfo 
0 
不属于包含调试信息的优化代码 
get_pure 
0 
不是纯虚函数 
get_relativeVirtualAddress 
71200 
函数入口相对于模块起点的地址 
get_typeId 
1261 
函数类型符号的 ID 
get_undecoratedName 
**** 
未修饰过的名称 
get_virtual 
1 
是虚函数 
get_virtualAddress 
0x11620 
函数入口的虚拟地址 
get_virtualBaseOffset 
4 
这个虚函数在虚函数表中的偏移 
*alloca 是从栈上分配内存的 C 标准函数。 
**setjump 可以把栈环境保存起来，以便以后可以使用 longjump 跳回到这个状态。Setjump 和 longjump 一起可以实现跨
函数的跳转。C 中的异常处理使用这种方法来执行异常处理和恢复代码。 
***如果父类和子类中都有相同的虚方法，那么最早将该方法声明为 virtual 的那个方法就是所谓的引入 virtual 的方法
（Introducing Virtual Function）。 
****内容为 public: virtual int __thiscall CBaseClass::Setup(wchar_t const *)，使用 get_undecoratedNameEx 方法可以取得不
同形式的修饰名。 
25.11.4  SymTagFunctionStart[21] 
SymTagFunctionStart 符号用来描述源代码调试时函数的可调试起点。举例来说，当我
们在源程序中对函数入口设置断点时，调试器实际上会把断点设置在函数序言之后的某一
位置上，FunctionStart 符号便是用来描述这一位置的。 
《软件调试》补编 
- 48 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
通过 SymView 的 Compiland 视图，我们可以观察函数的 FunctionStart 符号，表 25-24
列出了 Setup 方法的 FunctionStart 符号的主要属性。 
表 25-24  Setup 方法的 FunctionStart 符号 
属性 
值 
说明 
get_addressOffset 
0x643 
调试起点的偏移地址 
get_addressSection 
2 
调试起点所在的节号 
get_locationType 
static[1] 
位置类型 
get_relativeVirtualAddress 
0x11643 
调试起点相对于模块起点的地址 
get_virtualAddress 
0x11643 
调试起点的虚拟地址 
从上表可以看出，FunctionStart 符号所定义的位置是 0x11643，这与 VC2005 调试器
实际设置断点的位置（0x00411643）是一致的，因为我们使用 SymView 工具观察的值没
有算模块基地址。 
25.11.5  SymTagFunctionEnd[22] 
与 FunctionStart 符号的功能类似，SymTagFunctionEnd 符号用来描述源代码级调试时
函数的调试结束位置。还是以 Setup 方法为例，它的 FunctionEnd 符号所定义的偏移地址
是 0x6cd，对应的是设置返回值的下一条语句： 
004116C8  mov         eax,1  
return TRUE; 
004116CD  pop         edi   
FunctionStart 符号和 FunctionEnd 符号主要是供源代码级调试使用的，在汇编窗口调
试时可以把断点设置在起始点之前，也可以跟踪到截止点之后。 
25.11.6  SymTagLabel[9] 
SymTagLabel 符号用来描述程序中的标号（Label）。因为标号实际上记录的就是某段
代码的地址，所以标号既可以是跳转语句的目标，也可以被当作函数来调用。表 25-25 列
出了一个典型标号符号的各种属性，这个符号描述的是 HiWorld 程序中的 TAG_EXIT 标
号，位于 LabelTest 函数中。 
表 25-25  标号符号的属性 
属性 
值 
说明 
get_addressOffset 
0xa019 
节内偏移 
get_addressSection 
1 
所属节 
get_locationType 
static[1] 
位置类型 
get_name 
TAG_EXIT 
名称 
get_relativeVirtualAddress 
0xb019 
标号的 RVA 
get_virtualAddress 
0xb019 
标号的虚拟地址 
其中的父词条 ID（#1786）代表的是所在函数的符号，因为这个标号是函数内标号。
对于函数外标号，父符号是它所在的 Compiland。 
25.12  数据符号 
数据符号（SymTagData[7]）用来描述程序中的常量和各种变量，包括局部变量、全
局变量、类的成员和参数。我们先来看数据符号的公共属性，然后再分别介绍各种数据符
号。 
《软件调试》补编 
- 49 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
25.12.1  公共属性 
除了符号 ID 和 SymTag，数据符号通常还具有如下属性。 
名称：即变量或常量的名称。 
类型：用来描述变量类型的类型符号。 
取值：常量的取值，该属性是一个 VARIANT 结构，可以表示各种类型的常量。对于
变量，应该从其存储空间（内存、栈或寄存器）读取它的值。 
数据种类（Data Kind）：数据的种类，其值为表 25-26 所列出的 DataKind 枚举常量之
一。 
位置类型（Location Type）：数据存放的位置类型，其值为表 25-27 所列出的
LocationType 枚举常量之一。 
表 25-26  描述数据符号种类的 DataKind 枚举类型 
常量 
值 
说明 
DataIsUnknown 
0 
未知种类 
DataIsLocal 
1 
局部变量 
DataIsStaticLocal 
2 
静态局部变量 
DataIsParam 
3 
参数 
DataIsObjectPtr 
4 
对象指针，即 this 指针 
DataIsFileStatic 
5 
文件作用域内（File-scoped）的静态变量 
DataIsGlobal 
6 
全局变量 
DataIsMember 
7 
成员变量 
DataIsStaticMember 
8 