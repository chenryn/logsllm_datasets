# 伪造面向对象编程——COOP
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
C和C++向来以“let the programmer do what he wants to
do”的贴近底层而为广大开发者所喜爱。语言对开发者行为的较少限制，就使其成为不安全的语言。针对C和C++程序的控制流劫持攻击，如ROP、JOP等已经在长期的实践中证明了其破坏力，而众多保护措施也已经被提出。攻击者要么是将控制流转向其注入的恶意代码，要么是借由代码重用攻击来恶意地重用进程空间中已有的代码片段。无论是已有的攻击，还是相应的防御措施，往往都没有，或者是很少考虑C++的自身语言特性，包括其面向对象的特性。而现如今许许多多的应用程序都是通过C++开发，或者是包含部分C++代码，如Microsoft
Internet Explorer,Google Chrome, Mozilla Firefox, Adobe Reader, Microsoft
Office, LibreOffice,
和openJDK等等。因此，针对C++语言特性的攻击很可能造成巨大的破坏。接下来，我就为大家介绍一下针对C++特性的攻击——伪造面向对象编程（COOP）。
伪造面向编程（counterfeit object-oriented programming ，以下简称COOP）是由Felix
Schuster等人于2015年提出来的一种主要针对C++语言特性的攻击方式。C++提供了面向对象的特性，如类、方法以及虚函数等。而COOP就利用了C++程序中的虚函数都要进行取地址操作（因为要维持一张虚函数表），而这就意味着有一个存在一个不变的指针来对应一个虚函数，同时也会使得C++程序中相比同样体量的C程序中存在更多的进行取地址操作的函数。下面我具体给大家介绍一下。
## 前期知识：二进制层面的C++虚函数
对于每个至少包含一个虚函数的对象来说，在其内部偏移0处都会存在一个相应的指针，通常被称为vptr。如下图所示：
可以看到，类A不含虚函数，那么它的内存布局中就没有vptr指针和虚函数表。类B则恰好相反，在其内部偏移0处存放有vptr指针，指向虚函数表。
而调用一个虚函数通常会对应类似以下的汇编指令：
rcx寄存器存储着this指针，通过取内容将vptr指针存入rax寄存器，然后再通过相应的偏移量（此处是8，但有可能是其他数）读取虚函数表，取出对应虚函数地址进行调用。
## 攻击假设
COOP对攻击者的能力做了如下假设：
  1. 攻击者控制了一个包含虚函数的C++对象.
  2. 攻击者能够推断出一个他已经知道内存布局（至少是部分知道）的C++模块基址。
对于第一点来说，攻击者只要利用邻近该对象的某处溢出漏洞或者是use-after-free漏洞（正如后续某些攻击时所提到的那样）。
而对于第二点来说，一个公开的C++库就能符合要求。
## 攻击目标
COOP的设计初衷是为了达成以下目标：
（1）不出现已有代码重用攻击的特征，包括：
  1. 不会间接跳转（通过call 或者是jmp指令）到没有被取地址（被取地址的通常包括函数头等）的内存位置。
  2. 不会不经调用栈（call stack）执行return操作。
  3. 控制流中不出现过多的间接跳转。
  4. 不会劫持栈上指针。
  5. 不会注入新的或者是利用已有的代码指针（返回地址或者是函数指针）。
（2）使控制流和数据流尽量与一般的C++代码相似。
（3）能被广泛地用于攻击C++程序。
（4）在真实情景下实现图灵完备（Turing complet，具体定义比较复杂，可以自行了解，简单的说就是能够实现条件分支，循环、读写等操作）。
## 攻击实施步骤
为了更好地理解COOP攻击模式，在介绍COOP具体攻击实施步骤时，将会使用简单的代码来进行介绍，主要涉及以下几个类：Student、Course和Exam。
（1）劫持C++对象
每一次COOP攻击都要以劫持目标C++对象开始，称为initial
object。这一步是为了是控制流转向下一步伪造的对象当中。比如可以劫持以下类Course:
students是一个指向数组的指针。其中的Student类定义如下：
（2）伪造对象
在上一步操作之后已经可以使控制流发生改变，接下来要做的就是伪造包含有攻击者选定的vptr指针和一些数据域的对象。伪造的对象并不是目标程序自身有的，而是由攻击者注入到程序进程空间中的。伪造的对象和必要的一些数据将会作为连续的一个内存块（chunk）被注入到攻击者控制的某片内存区域。注入伪造对象后的内存布局如下图所示：
其中的object0和object1就是伪造的对象，而initial
object（也就是上文提到的Course类）已经被劫持，students数组各成员已经指向相应的伪造对象，nStudents已经被设置为伪造对象的数量。接下来要做的就是通过各个vptr指针调用攻击者选定的虚函数了。
（3）调用虚函数
通过initial
object和伪造对象，相应的vptr指针和需要的数据已经准备好，接下来就是调用攻击者选定的虚函数执行相应操作了。值得注意的是，由于COOP的目标之一是使控制流和数据流尽量与一般的C++代码相似，所以各个vptr指针应该指向实际存在的虚函数表（理想情况下应该是虚函数表开头）。与ROP中的gadgets类似，COOP中的目标虚函数被称为vfgadgets，从其功能上来看，具体可以分为以下几类：
  1. 主循环函数ML-G。
ML-G是包含有以指向伪造对象指针为循环变量的循环的虚函数，比如前述Course类中的˜Course函数：
该函数会在循环过程中访问每个students数组成员，而该数组已经指向伪造对象，也就是说，通过该循环能将控制流转向伪造对象。
现实当中也有相应的例子，比如VS 2013 agents.h中：
  2. 算数或逻辑运算函数ARITH-G。
如Exam类中以下虚函数：
  3. 内存读/写函数W-G/R-G。
如涉及字符串读写等函数。如以下函数：
  4. 调用函数指针函数INV-G。
如以下函数：
  5. 条件写函数W-COND-G。
  6. 带有initial object的数据作为参数的主循环函数ML-ARG-G。
  7. 写入第一个参数指针指向地址的函数W-SA-G。
  8. 只调整栈指针而无其他操作的函数MOVE-SP-G。
  9. 64位下读取参数寄存器rdx,r8,r9函数LOAD-R64-G。
有了这些类型的vfgadgets，COOP的整个流程就比较清晰了：从initial
object的vptr指针开始，调用第一个虚函数进入到主循环函数ML-G（如果选定的主循环函数有参数的话就是ML-ARG-G）,然后循环地通过各个伪造对象的vptr指针去调用对应的由攻击者选定的虚函数。整个流程如下图所示：