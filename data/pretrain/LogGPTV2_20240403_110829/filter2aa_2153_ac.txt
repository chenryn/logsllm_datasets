// Resource Di
#define CSIDL_RESOURCES_LOCALIZED
0x0039
// Localized R
#define CSIDL COMMON OEM LINKS
0x003a
// Links to Al
SpecialFolderDataBlock
• By assigning different CSIDL in SpecialFolderID
• We can call ParseDisplayName method of many different interfaces!
#define CSIDL_DESKTOP
0x0000
// 
#define CSIDL_INTERNET
0x0001
// Internet Explorer (icon on desktop)
#define CSIDL_PROGRAMS
0x0002
// Start Menu\Programs
#define CSIDL_CONTROLS
0x0003
// My Computer\Control Panel
#define CSIDL_PRINTERS
0x0004
// My Computer\Printers
#define CSIDL_PERSONAL
0x0005
// My Documents
#define CSIDL_FAVORITES
0x0006
// \Favorites
#define CSIDL_STARTUP
0x0007
// Start Menu\Programs\Startup
#define CSIDL_RECENT
0x0008
// \Recent
#define CSIDL_SENDTO
0x0009
// \SendTo
#define CSIDL_BITBUCKET
0x000a
// \Recycle Bin
#define CSIDL_STARTMENU
0x000b
// \Start Menu
#define CSIDL_MYDOCUMENTS
CSIDL_PERSONAL //
Personal was just a silly name for My Documents
#define CSIDL_MYMUSIC
0x000d
// "My Music" folder
#define CSIDL_MYVIDEO
0x000e
// "My Videos" folder
#define CSIDL_DESKTOPDIRECTORY
0x0010
// \Desktop
#define CSIDL_DRIVES
0x0011
// My Computer
#define CSIDL_NETWORK
0x0012
// Network Neighborhood (My Network Places)
#define CSIDL_NETHOOD
0x0013
// \nethood
#define CSIDL_FONTS
0x0014
// windows\fonts
#define CSIDL_TEMPLATES
0x0015
#define CSIDL_COMMON_STARTMENU
0x0016
// All Users\Start Menu
#define CSIDL_COMMON_PROGRAMS
0X0017
// All Users\Start Menu\Programs
#define CSIDL_COMMON_STARTUP
0x0018
// All Users\Startup
#define CSIDL_COMMON_DESKTOPDIRECTORY
0x0019
// All Users\Desktop
#define CSIDL_APPDATA
0x001a
// \Application Data
#define CSIDL_PRINTHOOD
0x001b
// \PrintHood
#define CSIDL_LOCAL_APPDATA
0x001c
// 
#define CSIDL_ALTSTARTUP
0x001d
// non localiz
#define CSIDL_COMMON_ALTSTARTUP
0x001e
// non localiz
#define CSIDL_COMMON_FAVORITES
0x001f
#define CSIDL_INTERNET_CACHE
0x0020
#define CSIDL_COOKIES
0x0021
#define CSIDL_HISTORY
0x0022
#define CSIDL_COMMON_APPDATA
0x0023
// All Users\A
#define CSIDL_WINDOWS
0x0024
// GetWindowsD
#define CSIDL_SYSTEM
0x0025
// GetSystemDi
#define CSIDL_PROGRAM_FILES
0x0026
// C:\Program
#define CSIDL_MYPICTURES
0x0027
// C:\Program
#define CSIDL_PROFILE
0x0028
// USERPROFILE
#define CSIDL_SYSTEMX86
0x0029
// x86 system
#define CSIDL_PROGRAM_FILESX86
0x002a
// x86 C:\Prog
#define CSIDL_PROGRAM_FILES_COMMON
0x002b
// C:\Program
#define CSIDL_PROGRAM_FILES_COMMONX86
0x002c
// x86 Program
#define CSIDL_COMMON_TEMPLATES
0x002d
// All Users\T
#define CSIDL_COMMON_DOCUMENTS
0x002e
// All Users\D
#define CSIDL_COMMON_ADMINTOOLS
0x002f
// All Users\S
#define CSIDL_ADMINTOOLS
0x0030
// 
#define CSIDL_CONNECTIONS
0x0031
// Network and
#define CSIDL_COMMON_MUSIC
0x0035
// All Users\M
#define CSIDL_COMMON_PICTURES
0x0036
// All Users\M
#define CSIDL_COMMON_VIDEO
0x0037
// All Users\M
#define CSIDL_RESOURCES
0x0038
// Resource Di
#define CSIDL_RESOURCES_LOCALIZED
0x0039
// Localized R
#define CSIDL COMMON OEM LINKS
0x003a
// Links to Al
SpecialFolderDataBlock
• Most of Special Folder are handled by CFSFolder::ParseDisplayName
and CRegFolder::ParseDisplayName
• Only few interfaces have self implemented parse methods
• CSIDL_INTERNET   -> CInternetFolder::ParseDisplayName
• CSIDL_BITBUCKET  -> CBitBucket::ParseDisplayName
• CSIDL_FONTS
-> CFontFolder::ParseDisplayName
• CSIDL_HISTORY    -> CHistory::ParseDisplayName
• CSIDL_CONTROLS 
-> CControlPanelFolder::ParseDisplayName
• No interesting bugs found : (
KnownFolderDataBlock
• As of Windows Vista, CSIDL have been replaced by KNOWNFOLDERID
• We found KnownFolderDataBlock is handled in a similar way to SpecialFolder
HRESULT CShellLink::_DecodeSpecialFolder(CShellLink *this)
{
ITEMIDLIST* folder_id_list = NULL;
KnownFolderDataBlock* known_folder = SHFindDataBlock(this->ExtraBlock, 0xA000000B);
if ( known_folder )
{
if ( !CShellLink::_ShouldDecodeSpecialFolder(this, known_folder->KnownFolderID) )
goto RET;
hr = SHGetKnownFolderIDList_Internal(known_folder->KnownFolderID,
(this->header.LinkFlags & SLDF_NO_KF_ALIAS | SLDF_UNALIAS_ON_SAVE) >> 10, 0, &ppidl) >> 31;
...
}
else
{
EXP_SPECIAL_FOLDER* special_folder = SHFindDataBlock(this->ExtraBlock, 0xA0000005);
folder_id_list = SHCloneSpecialIDList(special_folder->idSpecialFolder, 0);
Offset = special_folder->cbOffset;
}
KnownFolderDataBlock
• Collect KNOWNFOLDERID from KnownFolder.h and Registry
• HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\
FolderDescriptions\
$ wc -l ./known_folder_id.txt
377 ./known_folder_id.txt
KnownFolderDataBlock
• Collect KNOWNFOLDERID from KnownFolder.h and Registry
• HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\
FolderDescriptions\
$ wc -l ./known_folder_id.txt
377 ./known_folder_id.txt
KnownFolderDataBlock
• Construct LNK with KnownFolderDataBlock to call different ParseDisplayName
1600 1400
....
00000050: 3200 0000 0000 0000 0000 0000 5445 5354 2...........TEST
00000060: 0000 0000 1c00 0000 0b00 00a0 c4ee 0bd2 ................
00000070: a85c 0549 ae3b bf25 1ea0 9b53 0000 0000 .\.I.;.%...S....
00000080: 0000 0000                               ....
LinkTargetIDList
IDList[0]       = File -> “TEST”
ExtraData
BlockSignature
= 0xA000000B (KnownFolderDataBlock) 
KnownFolderID 
= {D20BEEC4-5CA8-4905-AE3B-BF251EA09B53} (FOLDERID_NetworkFolder)
Fuzzing Results
• Serveral DoS bugs found in different interfaces
• Not bad, but useless
• Where is an Interface, there is a way
Windows Search LNK
Secret in LNK File Format
• When collecting corpus for fuzzing…
• I found a special kind of LNK can be created from Windows Search results
Secret in LNK File Format
• It contains some complex data blobs in LinkTargetIDList
• LECmd didn’t parsed all the stuffs in property store
Secret in LNK File Format
• It contains some complex data blobs in LinkTargetIDList
• LECmd didn’t parsed all the stuffs in property store
Digging Deeper
Documented
Undocumented
LNK
PropVariant Deserialization
• Undocumented data format
• Parsed by Windows Search and StructuredQuery library
• IDList contains a DelegateFolder ItemID with CLSID_SearchFolder
windows_storage!CRegFolder::BindToObject()
windows_storage_search!CDBFolder::BindToObject()
windows_storage_search!CDBFolder::GetFilterConditionForChild()
windows_storage_search!SHLoadFilterFromStream()
windows_storage_search!IUnknown_LoadFromStream()
windows_storage_search!CFilterCondition::Load()
windows_storage_search!LoadConditionFromStream()
windows_storage_search!IUnknown_LoadKnownImplFromStream
StructuredQuery!StructuredQuery1::LeafCondition::Load
StructuredQuery!StructuredQuery1::ReadPROPVARIANT
PropVariant Deserialization
• StructuredQuery1::ReadPROPVARIANT
• Deserialize data from stream into a PROPVARIANT structure
• We already have IPropertyStorage / IPropertyStore
• Why reinventing the wheel? 
• Let the REVERSING begin
By Dmitriy Turchenkov
PropVariant Deserialization
• PROPVARIANT can hold different types of data as an union
• CHAR / SHORT / LONG
• FLOAT / DOUBLE
• BOOL
• DATE / FILETIME
• BSTR / BSTRBLOB  / LPSTR / LPWSTR 
• IUnknown / IDispatch / IStream / IStorage 
• PROPVARIANT
• Arrays
• …
PropVariant Deserialization
typedef struct tagPROPVARIANT {
union {
typedef struct {
VARTYPE
vt;
...
union {
CHAR
cVal;
UCHAR
bVal;
SHORT
iVal;
USHORT
uiVal;
LONG
lVal;
ULONG
ulVal;
INT
intVal;
UINT
uintVal;
LARGE_INTEGER
hVal;
ULARGE_INTEGER
uhVal;
FLOAT
fltVal;
DOUBLE
dblVal;
VARIANT_BOOL
boolVal;
VARIANT_BOOL
__OBSOLETE__VARIANT_BOOL;
SCODE
scode;
CY
cyVal;
DATE
date;
FILETIME
filetime;
CLSID
*puuid;
CLIPDATA
*pclipdata;
BSTR
b t V l
PropVariant Deserialization
HRESULT StructuredQuery1::ReadPROPVARIANT(IStream *pstm, PROPVARIANT *prop) 
1F 00 07 00 00 00 48 00 49 00 54 00 43 00 4F 00  .......H.I.T.C.O. 
4E 00 6C 00 00 00 00 00 06 00 00 00 00 00 00 00  N................
PropVariant Deserialization
1F 00 07 00 00 00 48 00 49 00 54 00 43 00 4F 00  .......H.I.T.C.O. 
4E 00 6C 00 00 00 00 00 06 00 00 00 00 00 00 00  N................
HRESULT StructuredQuery1::ReadPROPVARIANT(IStream *pstm, PROPVARIANT *prop) 
{
hr = IStream_Read(pstm, &prop->vt, 2);
0x1F = VT_LPWSTR
PropVariant Deserialization
1F 00 07 00 00 00 48 00 49 00 54 00 43 00 4F 00  .......H.I.T.C.O. 
4E 00 6C 00 00 00 00 00 06 00 00 00 00 00 00 00  N................
HRESULT StructuredQuery1::ReadPROPVARIANT(IStream *pstm, PROPVARIANT *prop) 
{
hr = IStream_Read(pstm, &prop->vt, 2);
switch ( prop->vt & VT_TYPEMASK ) {
0x1F = VT_LPWSTR
PropVariant Deserialization
1F 00 07 00 00 00 48 00 49 00 54 00 43 00 4F 00  .......H.I.T.C.O. 
4E 00 6C 00 00 00 00 00 06 00 00 00 00 00 00 00  N................
HRESULT StructuredQuery1::ReadPROPVARIANT(IStream *pstm, PROPVARIANT *prop) 
{
hr = IStream_Read(pstm, &prop->vt, 2);