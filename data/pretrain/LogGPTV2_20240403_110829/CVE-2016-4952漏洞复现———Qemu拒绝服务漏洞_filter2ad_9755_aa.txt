# CVE-2016-4952漏洞复现———Qemu拒绝服务漏洞
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
这次漏洞复现是我第一次没有借助已有复现文章和已有的poc复现的漏洞，所以写了这篇文章记录下，如果文章出现什么错误，恳请各位师傅斧正。
## 环境配置
环境搭建参照CVE-2015-5165漏洞复现———QENU信息泄露漏洞那篇文章：[http://www.resery.top/2020/10/13/CVE-2015-5165%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0——QENU%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/](http://www.resery.top/2020/10/13/CVE-2015-5165%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0
------QENU%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/)
qemu版本：2.3.0
启动脚本：
    qemu-system-x86_64 --enable-kvm -m 1G -hda /home/resery/QEMU/Resery.img -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 -net user,hostfwd=tcp::22222-:22 -net nic -device pvscsi
调试脚本：
    gdb --args qemu-system-x86_64 --enable-kvm -m 1G -hda /home/resery/QEMU/Resery.img -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 -net user,hostfwd=tcp::22222-:22 -net nic -device pvscsi
## 漏洞分析
先从CVE描述下手，看一下这个漏洞属于是什么类型的漏洞
    QEMU (aka Quick Emulator), when built with VMWARE PVSCSI paravirtual SCSI bus emulation support, 
    allows local guest OS administrators to cause a denial of service (out-of-bounds array access) 
    via vectors related to the (1) PVSCSI_CMD_SETUP_RINGS or (2) PVSCSI_CMD_SETUP_MSG_RING SCSI command.
根据描述我们可以知道是由一个越界访问触发的拒绝服务漏洞，并且问题出在了PVSCSI上，之后我们再来看一下qemu官网上面的patch信息，patch信息如下
    From: Prasad J Pandit 
    Vmware Paravirtual SCSI emulation uses command descriptors to
    process SCSI commands. These descriptors come with their ring
    buffers. A guest could set the ring buffer size to an arbitrary
    value leading to OOB access issue. Add check to avoid it.
    Reported-by: Li Qiang 
    Signed-off-by: Prasad J Pandit 
    ---     hw/scsi/vmw_pvscsi.c | 24 ++++++++++++++++++++----     1 file changed, 20 insertions(+), 4 deletions(-)
    diff --git a/hw/scsi/vmw_pvscsi.c b/hw/scsi/vmw_pvscsi.c
    index e690b4e..e1d6d06 100644
    --- a/hw/scsi/vmw_pvscsi.c
    +++ b/hw/scsi/vmw_pvscsi.c
    @@ -153,7 +153,7 @@ pvscsi_log2(uint32_t input)
         return log;
     }
    -static void
    +static int
     pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)
     {
         int i;
    @@ -161,6 +161,10 @@ pvscsi_ring_init_data(PVSCSIRingInfo *m, 
    PVSCSICmdDescSetupRings *ri)
         uint32_t req_ring_size, cmp_ring_size;
         m->rs_pa = ri->ringsStatePPN reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)
    +        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {
    +        return -1;
    +    }
         req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;
         cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;
         txr_len_log2 = pvscsi_log2(req_ring_size - 1);
    @@ -192,15 +196,20 @@ pvscsi_ring_init_data(PVSCSIRingInfo *m, 
    PVSCSICmdDescSetupRings *ri)
         /* Flush ring state page changes */
         smp_wmb();
    +
    +    return 0;
     }
    -static void
    +static int
     pvscsi_ring_init_msg(PVSCSIRingInfo *m, PVSCSICmdDescSetupMsgRing *ri)
     {
         int i;
         uint32_t len_log2;
         uint32_t ring_size;
    +    if (ri->numPages > PVSCSI_SETUP_MSG_RING_MAX_NUM_PAGES) {
    +        return -1;
    +    }
         ring_size = ri->numPages * PVSCSI_MAX_NUM_MSG_ENTRIES_PER_PAGE;
         len_log2 = pvscsi_log2(ring_size - 1);
    @@ -220,6 +229,8 @@ pvscsi_ring_init_msg(PVSCSIRingInfo *m, 
    PVSCSICmdDescSetupMsgRing *ri)
         /* Flush ring state page changes */
         smp_wmb();
    +
    +    return 0;
     }
     static void
    @@ -770,7 +781,10 @@ pvscsi_on_cmd_setup_rings(PVSCSIState *s)
         trace_pvscsi_on_cmd_arrived("PVSCSI_CMD_SETUP_RINGS");
         pvscsi_dbg_dump_tx_rings_config(rc);
    -    pvscsi_ring_init_data(&s->rings, rc);
    +    if (pvscsi_ring_init_data(&s->rings, rc) rings_info_valid = TRUE;
         return PVSCSI_COMMAND_PROCESSING_SUCCEEDED;
     }
    @@ -850,7 +864,9 @@ pvscsi_on_cmd_setup_msg_ring(PVSCSIState *s)
         }
         if (s->rings_info_valid) {
    -        pvscsi_ring_init_msg(&s->rings, rc);
    +        if (pvscsi_ring_init_msg(&s->rings, rc) msg_ring_info_valid = TRUE;
         }
         return sizeof(PVSCSICmdDescSetupMsgRing) / sizeof(uint32_t);
    -- 
    2.5.5
通过这个patch我们可以发现漏洞出在了两个函数上，一个是`pvscsi_ring_init_data`另一个是`pvscsi_ring_init_msg`。下面我们来具体分析一下这两个函数
###  pvscsi_ring_init_data
下面的代码是没有打patch前的代码，我们可以看到20行和24行有一个循环，循环多少次分别是由ri结构体的reqRingNumPages和cmpRingNumPages来决定的然而这两个值是可以被我们控制的，如果说我们给它赋一个很大的值的话那么在循环的时候就会产生越界的问题
    static void
    pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)
    {
        int i;
        uint32_t txr_len_log2, rxr_len_log2;
        uint32_t req_ring_size, cmp_ring_size;
        m->rs_pa = ri->ringsStatePPN reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;
        cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;
        txr_len_log2 = pvscsi_log2(req_ring_size - 1);
        rxr_len_log2 = pvscsi_log2(cmp_ring_size - 1);
        m->txr_len_mask = MASK(txr_len_log2);
        m->rxr_len_mask = MASK(rxr_len_log2);
        m->consumed_ptr = 0;
        m->filled_cmp_ptr = 0;
        for (i = 0; i reqRingNumPages; i++) {
            m->req_ring_pages_pa[i] = ri->reqRingPPNs[i] cmpRingNumPages; i++) {
            m->cmp_ring_pages_pa[i] = ri->cmpRingPPNs[i] numPages * PVSCSI_MAX_NUM_MSG_ENTRIES_PER_PAGE;
        len_log2 = pvscsi_log2(ring_size - 1);
        m->msg_len_mask = MASK(len_log2);
        m->filled_msg_ptr = 0;
        for (i = 0; i numPages; i++) {
            m->msg_ring_pages_pa[i] = ri->ringPPNs[i] io_space，也就是说这个内存要是想要访问到的话需要使用IO来访问，使用mmio是无法访问到的
    ----------------------------------------------------------------------------------------------------------------------------    static const MemoryRegionOps pvscsi_ops = {
            .read = pvscsi_io_read,
            .write = pvscsi_io_write,
            .endianness = DEVICE_LITTLE_ENDIAN,
            .impl = {
                    .min_access_size = 4,
                    .max_access_size = 4,
            },
    };
    ----------------------------------------------------------------------------------------------------------------------------    static int
    pvscsi_init(PCIDevice *pci_dev)
    {
        PVSCSIState *s = PVSCSI(pci_dev);
        trace_pvscsi_state("init");
        /* PCI subsystem ID */
        pci_dev->config[PCI_SUBSYSTEM_ID] = 0x00;
        pci_dev->config[PCI_SUBSYSTEM_ID + 1] = 0x10;
        /* PCI latency timer = 255 */
        pci_dev->config[PCI_LATENCY_TIMER] = 0xff;
        /* Interrupt pin A */
        pci_config_set_interrupt_pin(pci_dev->config, 1);
        memory_region_init_io(&s->io_space, OBJECT(s), &pvscsi_ops, s,
                              "pvscsi-io", PVSCSI_MEM_SPACE_SIZE);
        pci_register_bar(pci_dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->io_space);
        pvscsi_init_msi(s);
        s->completion_worker = qemu_bh_new(pvscsi_process_completion_queue, s);
        if (!s->completion_worker) {
            pvscsi_cleanup_msi(s);
            return -ENOMEM;
        }
        scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(pci_dev),
                     &pvscsi_scsi_info, NULL);
        /* override default SCSI bus hotplug-handler, with pvscsi's one */
        qbus_set_hotplug_handler(BUS(&s->bus), DEVICE(s), &error_abort);
        pvscsi_reset_state(s);
        return 0;
    }
    ----------------------------------------------------------------------------------------------------------------------------    
那么这里就又遇到了一个问题，既然mmio无法使用那就应该是使用pmio了，但是lspci
-v的输出结果里面也没有IO端口呀，后来查了点资料发现硬件接入系统的时候,系统会为硬件的寄存器分配连续的IO端口或者IO内存。也就是说lspci
-v输出的memory部分属于是IO内存，想要读写IO内存的话我们需要编写一个内核驱动，然后运行驱动才可以读写到IO内存，简单的交互代码如下
    #include 
    #include 
    #include 
    #include 
    long pmem;//注意这里不要使用指针类型,不然后面地址加偏移的时候很容易出错
    void m_init(){
           printk("m_init\n");
           int i,cmd,cmd_size;
           int va,offset;
           pmem=ioremap(0xfebf0000,0x8000);//映射io内存
           offset=0x10;//根据设备情况而定
           if (pmem){
                 writel(value,pmem+offset);//通常情况下都是写4字节,你也可以根据源码的处理方式选择
           }else printk("ioremap fail\n");
           iounmap(pmem);
           return;
    }
    void m_exit(){
           printk("m_exit\n");