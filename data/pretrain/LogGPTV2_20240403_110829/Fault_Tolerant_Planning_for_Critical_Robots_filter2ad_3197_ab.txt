completely different and (b) an unforeseen adverse environ-
mental situation may completely prevent some goals from
being achieved, thus ineluctably degrading the system per-
formance, however well it behaves (for example, cliffs, or
some other feature of the local terrain, may make a position
goal unreachable).
One way to address the latter issue is to deﬁne an oracle
as a set of constraints that necessarily and sufﬁciently char-
acterizes a correct plan: plans satisfying the constraints are
deemed correct. Such a technique was used for thorough
testing of the RAX planner during the NASA Deep Space
One project [3], or in the VAL validation tool [10]. Ex-
tensive collaboration of application and planner experts is
necessary to generate the correct set of constraints. A Fail-
ure Recovery Analysis tool is proposed in [9] to ease model
corrections during development.
Automatic static analysis may also be used to ascertain
properties on planning models, whereas manual static anal-
ysis requires domain experts to closely scrutinize models
proposed by planning developers. For example, the devel-
opment tool Planware [2] offers facilities for both types of
analysis.
Some work has also been done on evaluating planning
dependability. A measure for planner reliability is proposed
in [5], which compares theoretical results to experimen-
tal ones, showing a necessary compromise between tem-
poral failures (related to calculability of decisional mech-
anisms) and value failures (related to correctness of deci-
sional mechanisms). Later work [4] proposes concurrent
use of planners with diversiﬁed heuristics to answer this
compromise: a ﬁrst heuristic, quick but dirty, is used when
a slower but more focussed heuristic fails to deliver a plan
in time. To our knowledge, no other fault tolerance mech-
anisms have been proposed in this domain. We strongly
believe, however, that such mechanisms are essential to pro-
vide more dependability in autonomous systems.
3. Fault Tolerant Planning
We investigate here how to tolerate design and imple-
mentation faults in planner models and heuristics. These
mechanisms are particularly well adapted to hierarchical
1How to conclude on correctness of a program’s outputs to selected test
inputs?
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:20 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007autonomous systems with a centralized planner at the de-
cisional layer.
3.1. Principles
Complementary to testing, diversity is the only known
approach to improve trust in the behavior of a critical sys-
tem regarding development faults (e.g., diversiﬁcation is
used in software components of the Airbus A320, and in
hardware components of the Boeing B777). The general
principle of the mechanisms that we propose is to execute
sequentially or concurrently diversiﬁed variants of the plan-
ner, following similar approaches to recovery blocks [22]
and distributed recovery blocks [13]. In particular, diver-
sity is encouraged by forcing the use of different algorithms,
variable domains and parameters in the models and heuris-
tics of the variants.
3.1.1. Detection.
Implementing error detection for deci-
sional mechanisms in general, and planners in particular, is
difﬁcult [16]. There are often many different valid plans,
which can be quite dissimilar. Therefore, error detection
by comparison of redundantly-produced plans is not a vi-
able option. Thus, we must implement error detection by
independent means. Here, we propose four complementary
error detection mechanisms: a watchdog timer, a plan ana-
lyzer, a plan failure detector and an on-line goal checker.
A watchdog timer is used to detect when the search pro-
cess is too slow or when a critical failure such as a deadlock
occurs. Timing errors can be due to faults in the planner
model, in its search engine, or ineffectiveness of the search
heuristics.
A plan analyzer can be applied on the output of the plan-
ner. It is an acceptance test (i.e., an on-line oracle) that ver-
iﬁes that the produced plan satisﬁes a number of constraints
and properties. This set of constraints and properties can be
obtained from the system speciﬁcation and from domain ex-
pertise but it must be diverse from the planner model. This
mechanism is able to detect errors due to faults in the plan-
ner model or heuristics, and in the planner itself.
A plan failure detector is a classical mechanism used in
robotics for execution control. Failure of an action which
is part of the plan may be due to an unresolvable adverse
environmental situation, or may indicate errors in the plan
due to faults in the knowledge or in the search engine. Usu-
ally, when such an action failure is raised, thesearch engine
tries to repair the plan. When this is not possible, it raises a
plan failure. We use these plan failure reports for detection
purposes.
An on-line goal checker veriﬁes whether goals are
reached while the plan is executed. Goals can only be de-
clared as failed when every action of the plan has been car-
ried out. This implies that the checker maintains an internal
1. begin mission
2.
3.
4.
5.
6.
failed_planners ← ∅;
while (goals 6= ∅)
candidates ← planners;
while (candidates 6= ∅
& goals 6= ∅)
& (k /∈ failed_planners);
choose k such as (k ∈ candidates)
candidates ← candidates \ k;
init_watchdog(max_duration);
send (plan) to k;
wait % we wait any of these two events
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
2 receive (plan_found) from k
stop watchdog;
if analyze(plan)=OK then
failed_planners ← ∅;
k.execute_plan();
% if the plan fails goals != empty
% and then we loop line 3
else
send(invalid_plan) to operator;
failed_planners ← failed_planners ∪ k;
2 watchdog timeout
end if
failed_planners ← failed_planners ∪ k;
end wait
if failed_planners = planners then
raise exception "no valid plan
found in time";
% no remaining planner,
% the mission has failed
end if
25.
26.
end while
27.
28. end mission
end while
Figure 1. Sequential Planning Policy
representation of the system state and of the goals that have
been reached.
3.1.2. Recovery. We propose two recovery mechanisms,
both using different planners based on diverse knowledge.
With the ﬁrst mechanism, the planners are executed se-
quentially, one after another. The principle is given in Fig-
ure 1. Basically, each time an error is detected, we switch to
another planner until all goals have been reached or until all
planners fail in a row. Once all the planners have been used
and there are still some unsatisﬁed goals, we go back to the
initial set of planners. This algorithm illustrates the use of
the four detection mechanisms presented in Section 3.1.1:
watchdog timer (lines 8 and 20), plan analyzer (line 13),
plan failure detector (line 15), on-line goal checker (lines 3
and 5).
Reusing planners that have been previously detected as
failed makes sense for two different reasons: (a) a perfectly
correct plan can fail during execution due to an adverse en-
vironmental situation, and (b) some planners, even faulty,
can still be efﬁcient for some settings since the situation
that activated the fault may have disappeared.
It is worth noting that the choice of the planners, and the
order in which they are used, is arbitrary in this particular
example (line 6). However, the choice of the planner could
take advantage of application-speciﬁc knowledge about the
most appropriate planner for the current situation or knowl-
edge about recently observed failure rates of the planners.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:37:20 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007With the second recovery mechanism, the planners are
executed concurrently [15]. The main differences with re-
spect to the algorithm given in Figure 1 are: (a) the plan re-
quest message is sent to every planning candidate, (b) when
a correct plan is found, the other planners are requested to
stop planning, and (c) a watchdog timeout means that all the
planners have failed.
Here, the choice of planner order is implicit:
the ﬁrst
planner obtaining a plan is chosen. However, this could
lead to the repeated selection of the same faulty but rapid
planner. Some additional mechanism is thus required to cir-
cumvent this problem. For example, the planner selected
during the previous round can be withdrawn from the set of
candidates for the current round.
3.1.3. Coordination. From a dependability point of view,
the fault-tolerance mechanisms have to be as independent as
possible from the decisional layer, i.e., in this case from the
planners. This is why we propose to handle both the detec-
tion and recovery mechanisms and the services necessary
for their implementation in a middleware level component
called FTplan, standing for Fault-Tolerant PLANner coor-
dinator.
This component has to integrate the fault
tolerance
mechanisms into the robot architecture. This implies es-
sentially communication between, and synchronization and
coordination of, the error detection mechanisms and the re-
dundant planners.
To avoid error propagation from a possible faulty plan-
ner, FTplan should not take any information that comes
from or depends on the planners themselves. The watchdog
can easily be implemented from the operating system tim-
ing primitives. Action failure detection is performed at the
execution control layer, so error reports can be obtained and
reused at the FTplan level. A plan analyzer performs sim-
ple acceptance checks using rules expressed independently
from the planners and their knowledge.
However, implementing an on-line goal checker without
relying on information obtained through the planner is more
difﬁcult. FTplan maintains for this purpose its own system
state representation, based on information gathered from the
lower layers. It obtains this information from the execution
control layer, whose abstraction level is near to that of the
decisional layer. This system state representation is checked
against the set of goals prescribed for the current mission.
Whatever the particular recovery mechanism it imple-
ments, sequential or parallel, FTplan has to manage sev-
eral planners. It needs to communicate with them, e.g., for
sending plan requests or for updating their goals and system
state representations before replanning. It also needs to be
able to control their life cycle: start a new instance or even
stop one when it takes too long to produce a plan.
FTplan is intended to allow tolerance of development
faults in planners (and particularly in planning models). FT-
plan itself is not fault-tolerant, but being much simpler than
the planner it coordinates, we can safely rely on classic ver-
iﬁcation and testing to assume that it is fault-free.
3.2. Implementation
We present here the implementation of the proposed
mechanisms. We introduce the target architecture and then
give some implementation details about the FTplan compo-
nent.
3.2.1. LAAS architecture. The LAAS architecture is pre-
sented in [1], and some recent modiﬁcations have been pro-
posed in [14]. It has been successfully applied to several