反例：
注意到，服务器根据所请求属性的访问控制策略来确定其与客户端的连接的安全级别。如计数器示例所示，当访问控制策略允许连接的最低安全级别（即安全级别1）时，可以以纯文本形式发送属性访问请求和响应。在这种情况下，将不会部署任何链路层身份验证。因此，攻击者可以对服务器和客户端设备发起欺骗攻击。
由于连接的安全级别由服务器指导，因此如果服务器仅允许安全级别为1的连接，则客户端将无法强制执行更高安全级别的连接。这方面使得服务器和客户端都容易受到欺骗攻击。
####  漏洞2：规避身份验证
当客户端在配对后与服务器重新连接时，BLE规范提供了两种可能的身份验证过程。
**（1）响应式认证：**
在此过程中，客户端在建立连接后立即以纯文本（即，安全级别1）发送属性访问请求。仅当服务器响应并显示一条错误消息，表明连接的当前安全级别与访问该属性所需的安全级别不一致时，客户端才会通过启用加密/身份验证做出反应。对于此过程，形式分析表明可以违反访问响应的真实性，如下面的ProVerif输出所示。
反例：
尽管存储在服务器上的敏感属性没有泄漏给攻击者，但攻击者可以窃听客户端发送的请求，模拟服务器并用与敏感属性相对应的欺骗响应来欺骗客户端。Linux上的现有BLE堆栈实现（当通过gatttool访问时）遵循此反应式身份验证，从而使相应的客户端容易受到欺骗攻击。
**（2）主动式身份验证：**
在此过程中，客户端设备会在向服务器发送任何请求之前主动启用加密/身份验证。特别是，客户端使用先前建立的预共享密钥启用加密，然后继续进行身份验证。在这种情况下，如果服务器未能启用加密（这也意味着它未能启用身份验证）
，客户端将中止连接。形式化验证表明，所有检查的安全目标都在主动身份验证期间成立，如以下结果所示。
不幸的是，Andriod和iOS使用的现有BLE堆栈实现无法正确遵循此过程，从而使相应的客户端容易受到欺骗攻击。
## 0x04 BLE Spoofing Attack (BLESA)
通过形式化验证确定的设计漏洞来构造BLE欺骗攻击（BLESA）。在这种攻击中，攻击者向伪装成先前配对服务器设备的客户端设备提供欺骗数据。
**攻击设置：**
本研究检查了服务器和客户端在上一个会话中安全配对的情况，当前它们已断开连接，但它们打算开始新的会话。例如，当客户端移出服务器的通信范围然后又返回时，就会发生这种情况。
在这种情况下，攻击者首先发现服务器并与其连接以获得有关服务器属性的信息（例如标识符）。由于BLE协议旨在允许任何设备与另一个BLE设备连接并获取有关提供的属性的信息，因此攻击者可以轻松获取此信息。此外，由于BLE广播数据包始终以明文形式发送，因此攻击者可以通过广播相同的数据包并克隆其MAC地址来轻松地模拟良性服务器。然后，攻击者开始广播欺骗性的广告包以确保无论何时客户端尝试启动与先前配对的服务器进行新会话后，它可以发现欺骗性广播包并与攻击者建立连接。此时，攻击者已准备好针对客户端启动BLESA。在以下各节中，将按照被动身份验证过程以及遵循主动身份验证过程针对客户端介绍BLESA的工作流。
###  A.针对响应式身份验证的BLESA
上图a展示了客户端和服务器重新连接以及反应式身份验证过程在良性环境中进行的示意图。客户端首先向最低安全级别（即，安全级别1级的服务器发送属性读取请求），无需任何加密/身份验证。如果属性是敏感的并且可以在更高的安全级别（例如，具有加密和身份验证的安全级别3）上是只读的，则服务器会以错误消息（例如，加密不足）来响应客户端。收到错误消息后，客户端通过使用预共享的密钥启用加密和身份验证来提高安全级别，然后再次发送请求。此时，服务器很容易接受读取请求并返回属性值。
现在，介绍BLESA的工作流程，如上图b所示。在此，攻击者拦截来自客户端的属性读请求并以欺骗性的属性值进行响应。由于客户端没有遇到任何错误消息，因此错误地假定可以在最低安全级别（即，以纯文本格式）访问该属性。因此，客户端不启用加密/身份验证，并且接受欺骗的属性值。在BLESA的此实例中，使攻击成为可能的根本原因是客户端设备依赖于服务器的错误消息来进行攻击。调整使用的安全级别。
###  B.针对主动式身份验证的BLESA
上图a显示了客户端设备与良性服务器重新连接时触发的主动身份验证过程的工作流程。连接后，客户端立即请求使用预共享密钥启用加密（和身份验证），服务器将遵守该请求。然后，客户端安全地发送属性读取请求，并且服务器使用（加密和认证的）属性值安全地进行响应。如果BLE堆栈正确地执行了主动身份验证，遵循了规范，则BLESA将失败。但是进一步分析表明，基于Android和iOS的客户端设备都遭受逻辑错误，使BLESA可以针对这些设备。
上图b展示了BLESA如何使用主动身份验证过程成功胜过客户端设备，但受到所解释的实施漏洞的影响。具体地，在连接到攻击者之后，如果客户端尝试启用加密，则攻击者向客户端发送一条错误消息，指定长期密钥不可用，从而使加密失败。此时，客户端未正确遵循BLE规范（在这种情况下，建议中止连接），但继续与攻击者建立连接，客户端随后继续以明文形式发送对目标属性的读取请求。与服务器不同，攻击者很容易授予对属性的访问权限，使其在最低安全级别（即安全级别1）下可用，并将伪造的属性数据提供给客户端。因此，客户接受来自攻击者的欺骗性数据。
**漏洞利用：**
根据BLE规范，当客户端与先前配对的服务器重新连接时，如果在主动身份验证过程中加密启用过程失败，则客户端应与服务器重新配对（如上图所示）或中止连接。但是，某些客户端（即基于Android和iOS的设备）中的BLE堆栈无法正确遵循规范。具体来说，发现即使启用加密过程失败，客户端也可能不会中止连接并以明文形式继续通信，而无需与服务器重新配对。攻击者可以利用此缺陷来启动BLESA。怀疑此实现漏洞可能是由官方文档中解释BLE协议这一部分的方式引起的。
为了访问基本属性，并且某些服务器设备不支持链路层加密（即设计漏洞1），BLE规范做出了一些规定，以维护与这些资源受限的服务器设备的兼容性并增强可用性。因此，当加密/身份验证失败时，仍然可以按照规范中的说明以纯文本格式传输BLEdata和控制消息（上图）。认为上图中所示规范中的细节引起的矛盾可能使BLE堆栈开发人员感到困惑。这样，他们犯了逻辑错误，即在加密过程失败的情况下不中止连接，这对于访问先前配对的服务器上的安全敏感属性是必不可少的。
## 0x05 Implementation and Impact
###  A.设计漏洞-1的检查
为了确定是否确实存在某些不使用链路层身份验证的BLE服务器设备，采用两种方法：（1）通过静态分析来检查一组BLE设备的配套应用程序的行为。（2）对一组实际的BLE设备进行采样，并通过运行时分析检查它们的通信数据包。
**移动应用程序的静态分析：**
典型的BLE设备（例如Fitbit健身追踪器）依赖于其伴随移动应用程序（例如Fitbit应用程序），该应用程序使最终用户能够访问和管理记录的属性数据（例如步数）。由于配对过程（建立密钥）是启用链路层身份验证的先决条件之一，因此，如果在其伴随应用程序中未调用配对API，可以很容易地确认BLE设备不支持链路层身份验证。为此，利用静态分析框架FlowDroid来检查Android
BLE应用程序。更具体地说，对于每个伴随应用程序，在FlowDroid中使用Class Hierarchical
Analysis（CHA）选项来构建调用图，并确定是否应用程序确实从其任何入口点（例如，活动）调用配对API。由于CHA是用于调用图构造的相对保守的方法，因此可能会丢失部分方法调用。但是，与其他选项（例如，SPARK）相比，分析结果更加精确，误报率极低。因此，它使用配对提供了一个较低范围的BLE
app。
静态分析从33,785个受欢迎的应用程序开始，这些应用程序于2020年1月和2020年2月从AndroZoo网站自动爬取。基于这些应用程序的构造调用图和相应的API，发现只有127个应用程序包含读取的BLE数据读/写操作。然后，检查在这些应用程序中是否调用了配对API（createBond(
)）。不幸的是，发现在127个检查的应用程序中，只有41个（32.3％）包含配对过程，这意味着大多数被调查的BLE伴侣应用程序（67.7％）没有实现链路层身份验证。
**传输数据包的运行分析：** 研究了12种BLE设备（如上表所示），这些设备被选择代表了主流BLE设备制造商的各种应用。将每台服务器设备与Google
Pixel XL手机相连，并读取其属性。在这些实验中，使用Ubertooth
One无线电拦截运行时通信的数据包。通过分析截获的数据包，发现在检查的12个BLE设备中，有10个不支持任何链路层加密/身份验证。为此得出的结论是，大多数现实世界中的BLE设备都不采用链路层身份验证。
###  B.设计漏洞-2的检查