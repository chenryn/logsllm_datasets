打开一个新的文件编辑器窗口，将它保存为mapIt.py。
第1步：弄清楚URL
根据附录B中的指导，建立mapIt.py，这样当你从命令行运行它时，例如
C:\> mapit 870 Valencia St, San Francisco, CA 94110
该脚本将使用命令行参数，而不是剪贴板。如果没有命令行参数，程序就知道
要使用剪贴板的内容。
首先你需要弄清楚，对于指定的街道地址，要使用怎样的URL。你在浏览器中打
开http://maps.google.com/并查找一个地址时，地址栏中的URL看起来就像这样：https://
www.google.com/maps/place/870+Valencia+St/@37.7590311,-122.4215096, 17z/data=
!3m1!4b1!4m2!3m1!1s0x808f7e3dadc07a37:0xc86b0b2bb93b73d8.
地址就在URL中，但其中还有许多附加的文本。网站常常在URL中添加额外
的数据，帮助追踪访问者或定制网站。但如果你尝试使用 https://www.google.
com/maps/place/870+Valencia+St+San+Francisco+CA/，会发现仍然可以到达正确的页
面。所以你的程序可以设置为打开一个浏览器，访问'https://www.google.com/
maps/place/your_address_string'（其中your_address_string是想查看地图的地址）。
190 Python编程快速上手——让繁琐工作自动化
第2步：处理命令行参数
让你的代码看起来像这样：
#! python3
# mapIt.py - Launches a map in the browser using an address from the
# command line or clipboard.
import webbrowser, sys
if len(sys.argv) > 1:
# Get address from command line.
address = ' '.join(sys.argv[1:])
# TODO: Get address from clipboard.
在程序的#!行之后，需要导入webbrowser模块，用于加载浏览器；导入sys模
块，用于读入可能的命令行参数。sys.argv 变量保存了程序的文件名和命令行参数
的列表。如果这个列表中不只有文件名，那么len(sys.argv)的返回值就会大于1，这
意味着确实提供了命令行参数。
命令行参数通常用空格分隔，但在这个例子中，你希望将所有参数解释为一个字符串。
因为sys.argv是字符串的列表，所以你可以将它传递给join()方法，这将返回一个字符串。
你不希望程序的名称出现在这个字符串中，所以不是使用sys.argv，而是使用sys.argv[1:]，
砍掉这个数组的第一个元素。这个表达式求值得到的字符串，保存在address变量中。
如果运行程序时在命令行中输入以下内容：
mapit 870 Valencia St, San Francisco, CA 94110
…sys.argv变量将包含这样的列表值：
['mapIt.py', '870', 'Valencia', 'St, ', 'San', 'Francisco, ', 'CA', '94110']
address变量将包含字符串'870 Valencia St, San Francisco, CA 94110'。
第3步：处理剪贴板内容，加载浏览器
让你的代码看起来像这样：
#! python3
# mapIt.py - Launches a map in the browser using an address from the
# command line or clipboard.
import webbrowser, sys, pyperclip
if len(sys.argv) > 1:
# Get address from command line.
address = ' '.join(sys.argv[1:])
else:
# Get address from clipboard.
address = pyperclip.paste()
webbrowser.open('https://www.google.com/maps/place/' + address)
如果没有命令行参数，程序将假定地址保存在剪贴板中。可以用pyperclip.paste()取
第11章 从Web抓取信息 191
得剪贴板的内容，并将它保存在名为 address 的变量中。最后，启动外部浏览器访
问Google地图的URL，调用webbrowser.open()。
虽然你写的某些程序将完成大型任务，为你节省数小时的时间，但使用一个程序，
在每次执行一个常用任务时节省几秒钟时间，比如取得一个地址的地图，这同样令人
满意。表11-1比较了有mapIt.py和没有它时，显示地图所需的步骤。
表11-1 不用和利用mapIt.py取得地图
手工取得地图 利用mapIt.py
高亮标记地址 高亮标记地址
拷贝地址 拷贝地址
打开Web浏览器 运行mapIt.py
打开http://maps.google.com/
点击地址文本字段
拷贝地址
按回车
看到程序让这个任务变得不那么繁琐了吗？
第4步：类似程序的想法
只要你有一个URL，webbrowser模块就让用户不必打开浏览器，而直接加载一
个网站。其他程序可以利用这项功能完成以下任务：
• 在独立的浏览器标签中，打开一个页面中的所有链接。
• 用浏览器打开本地天气的URL。
• 打开你经常查看的几个社交网站。
11.2 用 requests 模块从 Web 下载文件
requests模块让你很容易从Web下载文件，不必担心一些复杂的问题，诸如网
络错误、连接问题和数据压缩。requests模块不是Python自带的，所以必须先安装。
通过命令行，运行pip install requests（附录A详细介绍了如何安装第三方模块）。
编写requests模块是因为Python的urllib2模块用起来太复杂。实际上，请拿一
支记号笔涂黑这一段。忘记我曾提到 urllib2。如果你需要从 Web 下载东西，使用
requests模块就好了。
接下来，做一个简单的测试，确保 requests 模块已经正确安装。在交互式环境
中输入以下代码：
>>> import requests
如果没有错误信息显示，requests模块就已经安装成功了。
192 Python编程快速上手——让繁琐工作自动化
11.2.1 用requests.get()函数下载一个网页
requests.get()函数接受一个要下载的 URL 字符串。通过在 requests.get()的返回
值上调用type()，你可以看到它返回一个Response对象，其中包含了Web服务器对
你的请求做出的响应。稍后我将更详细地解释Response对象，但现在请在交互式环
境中输入以下代码，并保持计算机与因特网的连接：
>>> import requests
 >>> res = requests.get('http://www.gutenberg.org/cache/epub/1112/pg1112.txt')
>>> type(res)
 >>> res.status_code == requests.codes.ok
True
>>> len(res.text)
178981
>>> print(res.text[:250])
The Project Gutenberg EBook of Romeo and Juliet, by William Shakespeare
This eBook is for the use of anyone anywhere at no cost and with
almost no restrictions whatsoever. You may copy it, give it away or
re-use it under the terms of the Proje
该 URL 指向一个文本页面，其中包含整部罗密欧与朱丽叶，它是由古登堡计
划提供的。通过检查Response对象的status_code属性，你可以了解对这个网页的
请求是否成功。如果该值等于requests.codes.ok，那么一切都好（顺便说一下，HTTP
协议中“OK”的状态码是200。你可能已经熟悉404状态码，它表示“没找到”）。
如果请求成功，下载的页面就作为一个字符串，保存在 Response 对象的 text
变量中。这个变量保存了包含整部戏剧的一个大字符串，调用 len(res.text)表明，
它的长度超过178000个字符。最后，调用print(res.text[:250])显示前250个字符。
11.2.2 检查错误
正如你看到的，Response 对象有一个 status_code 属性，可以检查它是否等于
requests.codes.ok，了解下载是否成功。检查成功有一种简单的方法，就是在Response
对象上调用raise_for_status()方法。如果下载文件出错，这将抛出异常。如果下载成
功，就什么也不做。在交互式环境中输入以下代码：
>>> res = requests.get('http://inventwithpython.com/page_that_does_not_exist')
>>> res.raise_for_status()
Traceback (most recent call last):
File "", line 1, in 
res.raise_for_status()
File "C:\Python34\lib\site-packages\requests\models.py", line 773, in raise_for_status
raise HTTPError(http_error_msg, response=self)
requests.exceptions.HTTPError: 404 Client Error: Not Found
raise_for_status()方法是一种很好的方式，确保程序在下载失败时停止。这是一
件好事：你希望程序在发生未预期的错误时，马上停止。如果下载失败对程序来说
第11章 从Web抓取信息 193
不够严重，可以用try和except语句将raise_for_status()代码行包裹起来，处理这一
错误，不让程序崩溃。
import requests
res = requests.get('http://inventwithpython.com/page_that_does_not_exist')
try:
res.raise_for_status()
except Exception as exc:
print('There was a problem: %s' % (exc))
这次raise_for_status()方法调用导致程序输出以下内容：
There was a problem: 404 Client Error: Not Found
总是在调用requests.get()之后再调用raise_for_status()。你希望确保下载确实成
功，然后再让程序继续。
11.3 将下载的文件保存到硬盘
现在，可以用标准的open()函数和write()方法，将Web页面保存到硬盘中的一
个文件。但是，这里稍稍有一点不同。首先，必须用“写二进制”模式打开该文件，
即向函数传入字符串'wb'，作为 open()的第二参数。即使该页面是纯文本的（例如
前面下载的罗密欧与朱丽叶的文本），你也需要写入二进制数据，而不是文本数据，
目的是为了保存该文本中的“Unicode编码”。
Unicode编码
Unicode编码超出了本书的范围，但你可以通过以下网页了解更多的相关内容：
• Joel on Software: The Absolute Minimum Every Software Developer
Absolutely, Positively Must Know About Unicode and Character Sets (No
Excuses!): http://www.joelonsoftware.com/articles/Unicode.html
• Pragmatic Unicode: http://nedbatchelder.com/text/unipain.html
为了将 Web 页面写入到一个文件，可以使用 for 循环和 Response 对象的
iter_content()方法。
>>> import requests
>>> res = requests.get('http://www.gutenberg.org/cache/epub/1112/pg1112.txt')
>>> res.raise_for_status()
>>> playFile = open('RomeoAndJuliet.txt', 'wb')
>>> for chunk in res.iter_content(100000):
playFile.write(chunk)
100000
78981
>>> playFile.close()
iter_content()方法在循环的每次迭代中，返回一段内容。每一段都是bytes数据
194 Python编程快速上手——让繁琐工作自动化
类型，你需要指定一段包含多少字节。10万字节通常是不错的选择，所以将100000
作为参数传递给iter_content()。
文件 RomeoAndJuliet.txt 将存在于当前工作目录。请注意，虽然在网站上文件
名是pg1112.txt，但在你的硬盘上，该文件的名字不同。requests模块只处理下载网
页内容。一旦网页下载后，它就只是程序中的数据。即使在下载该网页后断开了因
特网连接，该页面的所有数据仍然会在你的计算机中。
write()方法返回一个数字，表示写入文件的字节数。在前面的例子中，第一段
包含100000个字节，文件剩下的部分只需要78981个字节。
回顾一下，下载并保存到文件的完整过程如下：
1．调用requests.get()下载该文件。
2．用'wb'调用open()，以写二进制的方式打开一个新文件。
3．利用Respose对象的iter_content()方法做循环。
4．在每次迭代中调用write()，将内容写入该文件。
5．调用close()关闭该文件。
这就是关于 requests 模块的全部内容！相对于写入文本文件的 open()/write()/
close()工作步骤，for循环和iter_content()的部分可能看起来比较复杂，但这是为了
确保 requests 模块即使在下载巨大的文件时也不会消耗太多内存。你可以访问
http://requests.readthedocs.org/，了解requests模块的其他功能。
11.4 HTML
在你拆解网页之前，需要学习一些 HTML 的基本知识。你也会看到如何利用
Web浏览器的强大开发者工具，它们使得从Web抓取信息更容易。
11.4.1 学习HTML的资源
超文本标记语言（HTML）是编写 Web 页面的格式。本章假定你对 HTML 有
一些基本经验，但如果你需要初学者指南，我推荐以下站点：
• http://htmldog.com/guides/html/beginner/
• http://www.codecademy.com/tracks/web/
• https://developer.mozilla.org/en-US/learn/html/
11.4.2 快速复习
假定你有一段时间没有看过HTML了，这里是对基本知识的快速复习。HTML
文件是一个纯文本文件，带有.html文件扩展名。这种文件中的文本被“标签”环绕，
标签是尖括号包围的单词。标签告诉浏览器以怎样的格式显示该页面。一个开始标
签和一个结束标签可以包围某段文本，形成一个“元素”。“文本”（或“内部的
第11章 从Web抓取信息 195
HTML”）是在开始标签和结束标签之间的内容。例如，下面的 HTML 在浏览器中
显示Hello world!，其中Hello用粗体显示。
Hello world!
这段HTML在浏览器中看起来如图11-1所示。
图11-1 浏览器渲染的Hello world!
开始标签表明，标签包围的文本将使用粗体。结束标签告诉
浏览器，粗体文本到此结束。
HTML中有许多不同的标签。有一些标签具有额外的特性，在尖括号内以“属
性”的方式展现。例如，标签包含一段文本，它应该是一个链接。这段文本链
接的URL是由href属性确定的。下面是一个例子：
Al's free Python books.
这段HTML在浏览器中看起来如图11-2所示。
图11-2 浏览器中渲染的链接