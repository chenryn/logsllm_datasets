sets
post.PrevHash ← postprev.Hash. Otherwise
it sets post.PrevHash ← (Root: CID), where
this labeling uniquely identiﬁes it as ﬁrst post
associated with CID.
It sets post.Data ← Data.
It
post.PrevHash).
It records (post, CID) on the public ledger.
sets post.Hash ← HL(post.Data(cid:107)
•
The ledger computes an authentication tag σ over the
entire structure post and returns (post,σ).
Ledger.Verify(post, σ) → {0, 1}.
The verify algorithm is a public algorithm that will
return 1 only if the authenticator σ was authentically
generated by the ledger over that speciﬁc post. In gen-
eral, this can be viewed as analogous to the veriﬁcation
algorithm of a digital signature scheme.
For some applications it may also be desirable for third
parties to possess an interface to read data from the ledger.
We omit this interface for simplicity of exposition, although we
stress that the ledger is public and hence such a functionality
is implicit.
Remark. We note that the functionality of the above ledger can
be simulated locally by an enclave that receives the full ledger
contents L. Speciﬁcally, on receiving the full contents of a
ledger L can construct our abstraction by e.g., setting CID to be
the public key of a digital signature scheme, and signing each
message; it can then scan the full ledger to compute Hashi−1
and Hashi locally.
Security and ﬁnality of the Ledger. Informally, we require
that it is difﬁcult to construct a new pair (S, σ) such that
Ledger.Verify(S, σ) = 1 except as the result of a call to
Ledger.Post, even after the adversary has received many au-
thenticator values on chosen strings. We refer to this deﬁnition
as SUF-AUTH, and it is analogous to the SUF-CMA deﬁnition
used for signatures. We note that
in our proofs we will
assume an oracle that produces authentication tags, optionally
without actually posting strings to a real ledger. For example,
in a ledger based on signatures, our proofs might assume
the existence of a signing oracle that produces signatures on
chosen messages. When using “proof of work” ledgers, the
authenticators have economic security instead of cryptographic
security; we discuss this further in §V-B.
C. Enclave-Ledger Interaction
An ELI scheme consists of a tuple of possibly probabilistic
algorithms (Setup, ExecuteEnclave, ExecuteApplication). The
interface for these algorithms is given in Figure 2.
6
Setup(1λ) → (K, pp). This trusted setup algorithm is executed
once to conﬁgure the enclave. On input a security parameter λ, it
samples a long-term secret K which is stored securely within the
enclave, and the (non-secret) parameters pp which are provided
to the enclave and the host.
ExecuteApplication(pp, P ). This algorithm is run on the host.
It proceeds in an inﬁnite loop, invoking the ledger operations
and enclave operations. In each iteration of the loop, the user
selects a step input, commits to it and posts it to the ledger. It
then sends that input and the Ledger’s output into the enclave
to actually execute the next step.
ExecuteEnclaveK,pp((P, i,Si, Ii, ri, σi, posti))
→
(Si+1, Oi, Pubi). This algorithm is
run by the enclave,
which is conﬁgured with K, pp. At the ith computation step it
takes as input a program P , an encrypted previous state Si, a
program input Ii, commitment randomness ri, a ledger output
posti and a ledger authentication tag σi. The enclave invokes
P and produces a public output Oi, as well as a new encrypted
state Si+1 and a public output Pubi.
Fig. 2. Deﬁnition of an Enclave Ledger Interaction (ELI) scheme.
D. Correctness and Security
Correctness. Correctness for an ELI scheme is deﬁned in
terms of the program P . Intuitively, at each step of execution,
an honest enclave (operating in combination with the an honest
host and ledger) should correctly evaluate the program P on
the given inputs.
Simulation Security. Intuitively, our deﬁnition speciﬁes two
experiments: a Real experiment in which an adversarial host
application runs the real ELI protocol with oracles that im-
plement honest enclave and ledger functionalities respectively,
and an Ideal experiment that models the correct and stateful
execution of the underlying program P by a trusted party.
Our security deﬁnition requires that for every p.p.t. adversary
H that runs the Real experiment, there must exist an ideal
adversary ˆH that runs the Ideal experiment such that the output
of H is computationally indistinguishable from that of ˆH.
As we discuss in later sections, this intuitive deﬁnition
may not be strong enough for real deployments. Because in
some instantiations (such as proof-of-work blockchains) our
ledger may provide only economic security: that is, the cost
of forgeries may be impractical. Despite the high cost, in this
setting an attacker may be able to forge a small number of
ledger proofs. We wish to show that the advantage afforded
such an attacker is minimized. In the appendix we strengthen
our deﬁnition to allow the attacker to forge a limited number
of ledger authentication tags.
III. OUR CONSTRUCTION
In this section we present a speciﬁc construction of an
Enclave-Ledger Interaction scheme. Our construction makes
black box use of commitment schemes, authenticated sym-
metric encryption, collision-resistant hash functions and pseu-
dorandom functions.
Notation. Let λ be a security parameter. Let (cid:96) be a non-
negative integer where (cid:96) = poly(λ). In our constructions we
deﬁne Verify(·) as a primitive that veriﬁes a statement, and
aborts the program (with output ⊥) if the statement evaluates
to false. Let (Pad, Unpad) be a padding algorithm that, on
input a program P , pads a series of inputs to the maximum
length of the provided data.
Commitment schemes. Let Σcom = (CSetup, Commit) be a
commitment scheme where CSetup generates public parame-
ters pp. The algorithm Commit(pp, M ; r) takes in the public
parameters, a message M, along with random coins r, and
outputs a commitment C (cid:54)= ε which can be veriﬁed by re-
computing the commitment on the same message and coins.
Deterministic authenticated encryption. We require a sym-
metric authenticated encryption scheme consisting of the algo-
rithms (Encrypt, Decrypt) where each accepts a key uniformly
sampled from {0, 1}κ. It is critical that both algorithms are
deterministic. This does not require strong assumptions, as
we will use Encrypt at most once for any given key; hence
standard AE modes can be used if they are conﬁgured with a
ﬁxed nonce. For simplicity we further deﬁne the specialized
algorithm Encryptpad as one that pads the plaintext
to (a
maximum state size) n bits prior to encrypting it, and deﬁne
Decryptunpad as removing this padding.
Pseudorandom Functions. Our construction uses a pseudo-
random function family PRF : {0, 1}(cid:96) × {0, 1}∗ → {0, 1}2(cid:96)
that on input an (cid:96)-bit key and a string of arbitrary length,
outputs a 2(cid:96)-bit pseudorandom string.
Collision-resistant hashing. Our
rely on two
collision-resistant hash functions HL : {0, 1}∗ → {0, 1}(cid:96) and
H : {0, 1}∗ → {0, 1}(cid:96) where (cid:96) is polynomial in the scheme’s
security parameter. For simplicity we do not specify a key for
these functions, and we will instead assume that any attack
on the scheme implicitly results in the extraction of a hash
collision (see e.g., [55]).
schemes
A. Main Construction
We now present our main construction for a Enclave-
Ledger Interaction scheme and address its security. Recall
that an ELI consists of the three algorithms with the inter-
face described in Figure 2. We present pseudocode for our
construction in Algorithms 1, 2 and 3 below.
Discussion. The scheme we present in this section differs
somewhat from the pedagogical scheme we discussed in the
introduction. Many of these differences address minor details
that affect efﬁciency or simplify our security analysis: for
example we do not encrypt state directly using the ﬁxed key
K, but instead derive a unique per-execution key k using a
pseudorandom function (PRF). This simpliﬁes our analysis by
allowing us to instantiate with a single-message authenticated
encryption scheme (e.g., an AE scheme with a hard-coded
nonce) without concerns about how to deal with encrypting
multiple messages on a single key.
A second modiﬁcation from our pedagogical construction
is that we evaluate a pseudorandom function on the hash of the
structure returned by the ledger. By the nature of our ledger
abstraction, this data structure enforces a hash chain over all
previous transactions; as a result this ensures that all random
coins and keys are themselves a function of the full execution
history of the program. This ensures that an attacker – even
7
Algorithm 1: Setup
commitment parameters pp
Data: Input: 1λ
Result: Secret K for the enclave and public
K $← {0, 1}λ
pp ← CSetup(1λ)
Output (K, pp)
Algorithm 2: ExecuteApplication
Data: Input: pp, P
// Set counter to 0 and state to ε
S0 ← ε
i ← 0
Pub0 ← ε
// Loop and run the program
while true do
Obtain Ii from the user
if Ii = ⊥ then
Terminate
$← {0, 1}(cid:96)
ri
Ci ← Commit(pp, (i, Ii,Si, P ); ri)
(σi, posti) ← Ledger.Post ((Pubi, Ci))
(Si+1, Oi, Pubi) ← ExecuteEnclave(P, i,Si, Ii, ri,
σi, posti)
Output (Oi, Pubi) to the user
i ← i + 1
Algorithm 3: ExecuteEnclave
Data: Input: (P, i,Si, Ii, ri, σi, posti)
Internal values: K, pp
Result: (Si+1, Oi, Pubi) or ⊥
// Verify and parse the inputs
Assert (Ledger.Verify(posti, σi))
Assert(posti.Hash = HL(posti.Data(cid:107)posti.PrevHash))
Parse (Pubi−1, Ci) ← post.Data
Assert(Ci = Commit(pp, (i, Ii,Si, P ); ri))
// Compute the ith state encryption key
(ki,·) ← PRFK(posti.PrevHash)
if Si = ε then
else
// First execution step, no state.
Assert(i = 0)
Si = ε
(Si, HP ) ← Decryptunpad(ki,Si)
Assert((Si, HP ) (cid:54)= ⊥)
Assert(HP = H(P(cid:107)i(cid:107)Pubi−1))
fails
encryption key
// Compute randomness and i + 1th
(ki+1, ¯ri) ← PRFK(posti.Hash)
// Run the program and abort if it
(Si+1, Pubi, Oi) ← P (Si, Ii; ¯ri)
Assert((Si+1, Pubi, Oi) (cid:54)= ⊥)
// Encrypt the resulting state
Si+1 ← Encryptpad(ki+1, (Si+1, H(P(cid:107)i + 1(cid:107)Pubi))
Output (Si+1, Pubi, Oi)
a powerful one that can forge some ledger outputs – cannot
use the state resulting from those forgeries to continue normal
execution via the real ledger, since the execution history on
the real ledger will not contain these forgeries.
We remark again that this more powerful ledger abstraction
does not truly represent a stronger assumption when compared
to our pedagogical construction, since the more powerful
ledger can be “simulated” by enclave itself, provided the
enclave has access to the full contents of a simple ledger.
Security. We now present our main security theorem.
ledger authentication tags are unforgeable,
Theorem 1: Assuming a secure commitment scheme, a
secure authenticated encryption scheme (in the sense of [54]);
that H and HL are collision resistant; PRF is pseudorandom;
and that
then
the scheme Π = (Setup, ExecuteEnclave, ExecuteApplication)
presented in Algorithms 1, 2 and 3 satisﬁes Deﬁnition 1
(supplied explicitly in the appendix).
We present a proof sketch of Theorem 1 in the appendix. We
are limited to a proof sketch because of space constraints. We
provide a full proof in the full version of this work.
IV. APPLICATIONS
We now describe several applications that use Enclave-
Ledger Interaction and present the relevant implementations
for each. Each application employs the main construction we
presented in §III to implement a speciﬁc functionality. Except
where explicitly noted, these applications are implemented as
many-time execution programs: this means the host can re-
launch the same program P many times, but each execution
thread is independent and threads do not share state.
A. Private Smart Contracts
Smart contract systems comprise a network of volunteer
nodes that work together to execute multi-step interactive
programs called contracts. These systems, which are exem-
pliﬁed by Ethereum and the Hyperledger platforms [6], [31]
as well as research systems like Ekiden [21] maintain a shared
ledger that records both the previous and updated state of
the contract following each execution of a contract program.
These platforms are designed for ﬂexibility: they are capable
of executing many different contracts on a single network.
Smart contract systems come in two varieties: public contract
networks (exempliﬁed by Ethereum [6]), where all state and
program code is known to the world; and private contract
systems where some portion of this data is held secret. In both
settings the computation (and veriﬁcation) is conducted by a
set of nodes who are not assumed to always be trustworthy.
In the public setting (e.g., [6]) a single node performs each
contract execution, and the remaining nodes simply verify the
(deterministic) output of this calculation. This approach does
not work in the private setting, where some of the program
inputs are unknown to the full network.
Platforms such as Hyperledger Sawtooth [33] have sought
to address this concern by employing trusted execution tech-
nology [31]. In these systems, contract code executes within a
trusted enclave on a single node, and the TEE system generate
public attestation signatures proving the correctness of the
resulting output. The network then veriﬁes the attestation to
8
ensure that the execution was correct. A challenge in these
systems is to ensure that a smart contract remains synchro-
nized, despite the fact that execution migrates from one host
to another between steps. A secondary challenge is to ensure
that the enclave only executes contract code on valid inputs
from the ledger, and cannot be forced to run on arbitrary input
or perform additional steps by a malicious host.
Bowman et al. of Intel corporation [19] independently pro-
posed a solution reminiscent of an ELI for securing contracts
in this setting. (Figure 1 presents an illustration of this model.)
This setting is also a natural solution for our ELI system, given
that the contract system – with many distinct enclave copies
– can be viewed as merely being a special case of our main
construction.
To instantiate an ELI in this setting, we require the contract
author to pre-position a key K within each enclave.9 Encrypted
state outputs can now be written to the ledger as a means
to distribute them. Given these modiﬁcations, each enclave
can simply read the current state from the ledger in order
to obtain the most recent encrypted state and commitment to
the next contract input (which may be transmitted by users to
the network).10 Other enclaves can verify the correctness of
the resulting output state by either (1) verifying an attestation
signature, or (2) deterministically re-computing the new state
and comparing it to the encrypted state on the ledger.
B. Logging and Reporting
Algorithm 4: File Access Logging Plogging
Data: Input: Ii , Si; Constants: pk auditor
Parse (phase, sk , CT, ﬁlename) ← Si
if Si = ε then // Generate master keypair
else if phase = PUBLISH then // Send filename