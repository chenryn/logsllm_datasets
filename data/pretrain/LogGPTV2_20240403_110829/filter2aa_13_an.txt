如果想修改文件的权限为所有者是rwx，同组用户的权限是r--，其他用户的权限是--x，命令如下：
这里看到：u代表所有者，g代表同组用户，o代表其他用户。
使用数字更简单：
·7代表所有者：1+2+4
·1代表同组用户：1
·4代表其他用户：4
如下所示，可以看到文件的权限：
下面再来看一下如何修改文件为setuid和setgid。设置之后文件相应被设置了SUID或SGID位，分别表现在所有者或同组用户权限的可执行位上。例如：
1）-rwsr-xr-x表示SUID和所有者权限中可执行位被设置。
2）-rwsr--r--表示SUID被设置，但所有者权限中可执行位没有被设置。
3）-rwxr-sr-x表示SGID和同组用户权限中可执行位被设置。
4）-rw-r-sr--表示SGID被设置，但同组用户权限中可执行位没有被设置。
其实，在Unix的实现中，文件权限用12个二进制位表示，如果该位上的值是1，表示有相应的权限：
第11位为SUID位，第10位为SGID位，第9位为粘着位，第8～0位对应于上面的三组rwx位。
-rwsr-xr-x的值为：1 0 0 1 1 1 1 0 1 1 0 1
-rw-r-sr--的值为：0 1 0 1 1 0 1 0 0 1 0 0
1）所有者的s位对应的数字是：4
2）所有组的s位对应的数字是：2
3）粘着位对应的数字是：1
给文件加SUID和SUID的命令如下：
1）chmod u+s filename设置SUID位
2）chmod u-s filename去掉SUID设置
3）chmod g+s filename设置SGID位
4）chmod g-s filename去掉SGID设置
也可以用八进制表示方法来设置，如果明白了前面的12位权限表示法，八进制方法也很简单。
使用数字来设置文件的SUID、SGID、粘着位：
第一位的7就代表1+2+4，即设置了三个位。
10.3 Android中setuid和setgid的使用场景
前面介绍了Linux中setuid、setgid的用法和作用，以及如何使用chmod命令来操作。下面就来看看Android中有哪些场景用到了setuid、setgid。
1.zygote降权处理
首先不得不说zygote这个进程，Android中应用启动的过程都是和这个进程息息相关的，每个应用启动都是来找zygote做事的。zygote启动之后，会进入一个轮询使用socket来监听ActivityManagerService发来的消息，比如应用的启动，然后zygote就fork出一个进程，开始运转。那么问题来了，在Linux中，父进程fork出一个子进程，默认子进程会拥有和父进程一样的uid，那么zygote是root用户的，按照常理，所有fork出来的应用都是root用户了，看上去很危险——每个应用都有root权限了。其实每个应用只有指定的权限，这是由于zygote使用setuid、setgid做了降权处理，如下所示：
下面来看一下源码：dalvik_system_Zygote.cpp。
提示：源码位置：Android源码\dalvik\vm\native\dalvik_system_Zygote.cpp
zygote中主要做处理的是forkAndSpecializeCommon函数，如下所示：
往下面看：
这里将fork出来的进程的gid和uid设置成上层传递过来的值，从而实现降权。
这里还有一个函数enableDebugFeatures，这个函数是干什么的，其实看到名字都知道，让一个应用具备可调试功能，在debug的情况下：
继续往下看：
注意，在gDvm.jdwpAllowed字段判断时可以看到，Java中的调试系统还是很复杂的，由jdb、jdbserver、jwdp组成，这里遵从的是C/S模式：
·jdb是客户端，需要调试的应用。
·jdbserver是服务器端，调试代码信息处理的那一端。
·jwdp是调试协议。
而且每个可以调试的应用启动之后，都会有一个jwdp线程来运作这些事，可以使用：
来查看进程的线程，如下所示：
这里介绍的内容是为了接下来分析Android中的调试工具gdb、gdbserver做准备的。
2.su工具原理
Android手机的root原理是：一个普通的进程通过执行su，从而获得一个具有root权限的进程。有了这个具有root权限的进程之后，就可以想干什么就干什么了。su所做的事情其实很简单，它再fork另外一个子进程来做真正的事情，也就是在执行su的时候后面所跟的那些参数。由于运行su的进程的uid是root，因此由它fork出来的子进程的uid也是root，于是子进程也可以想干什么就干什么了。不过，用来root手机的su还会配合另外一个称为superuser的App来使用。su在fork子进程来做真正的事情之前，会先启动superuser，询问用户是否允许fork一个uid是root的子进程。这样就可以对root权限进行控制，避免被恶意应用偷偷地使用。
下面来看看su的源码，如图10-5所示。
图10-5 su的源码
可以看到，这里就是用了setuid和setgid来设置指定的uid，如果没有指定uid，默认是root用户，uid=0。
3.run-as命令
上面说到使用chmod命令可达到setuid等效果，在Android中也有类似的场景，前面分析的run-as命令就是一个很好的例子，run-as命令本身的uid是root，gid是shell。
如果用chmod 6755 run-as设置完权限之后如下面的代码所示，就具备了这种功能，即只要运行run-as命令的用户就会立马升级到root用户，因为root用户可以进入任何应用的data/data/目录下：
现在也知道了前面为什么修改了run-as命令之后会报错，然后修改回来之后又可以了。
从这里可以看到Android中的run-as命令其实还是很危险的，虽然它本身有很多限制，但追根到底还是Linux中setuid的安全性最为值得考究，setuid的危险性还是很大的。
10.4 run-as命令的作用
现在知道了run-as命令能够在非root设备上查看debug模式的应用沙盒数据，其实它还有一个重要作用，就是为Android中的调试做基础。上面在分析zygote源码的时候提到了Java中的调试系统jdb，其实Android中的调试系统是gdb，通过gdb和gdbserver来调试App。具体来说，就是gdbserver通过ptrace附加到目标App进程去，然后gdb再通过socket或者pipe来链接gdbserver，并且向它发出命令来对App进程进行调试。需要注意以下关键点：
·每一个需要调试的apk在打包的时候都会带上一个gdbserver，因为手机上面不带有gdbserver工具。gdbserver用来通过ptrace附加到要调度的App进程去。
·要注意ptrace的调用。一般来说，只有root权限的进程可以调用。例如，如果我们想通过ptrace向目标进程注入一个so，那么就需要在root过的手机上向su申请root权限。但是，这不是绝对的。如果一个进程与目标进程的uid是相同的，那么该进程就具有调用ptrace的权限。gdbserver在调试一个App之前，首先要通过ptrace_attach来附加到该App进程去。ptrace_attach在执行实际操作之后，会调用__ptrace_may_access来检查调用进程的权限，如果调用进程与目标进程具有相同的uid和gid，那么权限检查通过。否则的话，就要求调用者进程具有执行ptrace的能力，这是通过另外一个函数ptrace_has_cap来检查的。如果调用进程的uid是root，那么ptrace_has_cap一定会检查通过。当然，通过了上述两个权限检查之后，还要接受内核安全模块的检查，这就不是通过uid或者capability这一套机制来控制的了。
·如何让gdbserver进程的uid与要调试的App进程的uid一样？因为在没有root过的手机上要想获得root权限是不可能的，因此只能选择以目标进程相同的uid运行这个方法。这时可以使用run-as工具。
到这里知道了，在Android中要调试一个程序，首先这个程序必须是debug模式的，也就是在AndroidManifest.xml中设置的属性，所以以往在使用动态方式破解apk的时候，首先是反编译，然后修改XML中的debug属性，然后才能进行代码关联调试，而且动态调试so的强大工具IDA也是利用附加到目标进程中才进行调试的，原理和这里的gdb一样。
10.5 调用系统受uid限制的API
前面说了几次关于降权的问题，再用一个例子来详细介绍Android中如何降权，这个例子是模拟一个系统的API，但是这个API只允许system用户调用，代码如下：
这里做了用户uid的判断，如果不是system用户，直接返回错误信息。为了简单，也是为了向用户演示Android中如何执行jar功能，这里再加一个入口类：
把项目导出jar，然后用dx命令进程转化成dex，因为Android中是不识别class文件的，它只识别dex文件：
然后将生成的classes.dex文件塞到jar中，直接使用压缩软件就可以了，如图10-6所示。
图10-6 压缩软件查看jar文件
然后把exec.jar导入设备的/data目录下，如下所示：
接着把exec.jar设置到类环境变量中，运行即可：
·export CLASSPATH jar的路径。
·exec/system/bin/app_process jar的目录jar中的入口类。
为了演示，例子都是在root用户下做的操作，如下所示：
运行成功，看到打印的log信息，权限拒绝了，因为只能允许system用户访问，下面就用su降权到system再运行，如下所示：
注意：每次切换用户的时候，一定要记得重新设置一下类变量，不然会运行失败的。
成功获取到值了。总结一下步骤：
1）导出可执行的jar文件。
2）使用dx命令将class文件转化成dex文件。
3）将转化之后的dex文件塞到jar文件中，然后导入设备的指定目录。
4）设置可执行jar文件到类环境变量中。
5）执行app_process命令，运行jar文件。
补充一些说明：上面看到了可以成功使用app_process命令来运行一个jar文件，关于app_process的相关知识网上有很多资料，它是Android系统中启动Java代码的关键。这里也可以直接运行dex文件，使用命令dalvikvm。
首先将上面执行dx命令后的classes.dex文件adb放到/data目录下，如下所示：
然后执行dalvikvm命令，如下所示：
这里同样看到权限拒绝，降级切换到system用户，如下所示：
了解了如何使用app_process来运行jar文件，便体验到了Android中一些API的访问限制该如何处理，主要是用su来进行降权处理，而su能够降权是因为它本身提供了可以修改uid的功能，即调用setuid和setgid函数即可，所以在手机root之后发现还是不能调用系统的一些API时，可以尝试使用su来降权进行调用。
10.6 本章小结
本章知识点有点多，一环扣着一环，分析run-as命令的用法时去分析源码，发现错误的根源之后，引出Linux中的setuid和setgid问题，解决问题之后，总结了setuid和setgid的使用场景，然后继续分析了run-as命令的作用。最后也解决一个问题，即如何调用系统中那些有uid限制的API，通过一个例子来解析问题，引出了Android中如何执行jar文件。
第11章 Android中的allowBackup属性
很多开发者对Android关于AndroidManifest.xml中的allowBackup属性不太了解，而开发者在使用IDE工具开发的时候自动生成代码，而这个属性的值会被设置成true，会直接导致隐私数据的丢失。本章就介绍这个属性对应用安全的影响到底有多大以及注意事项。
11.1 allowBackup属性介绍
Android API Level 8及以上Android系统提供了为应用程序数据的备份和恢复功能，此功能的开关由应用程序中AndroidManifest.xml文件中的allowBackup属性值决定，其属性值默认是true。当allowBackup标志为true时，用户即可通过adb backup和adb restore命令对应用数据进行备份和恢复，这可能会带来一定的安全风险。
这个属性的安全风险源于adb backup命令容许任何一个能够打开USB调试开关的人从Android手机中复制应用数据到外设，一旦应用数据被备份之后，所有应用数据都可被用户读取；adb restore容许用户指定一个恢复的数据来源（即备份的应用数据）来恢复应用程序数据的创建。因此，当一个应用数据被备份之后，用户即可在其他Android手机或模拟器上安装同一个应用，并通过恢复该备份的应用数据到该设备上，在该设备上打开该应用即可恢复到被备份的应用程序的状态。
尤其是通讯录应用，一旦应用程序支持备份和恢复功能，攻击者即可通过adb backup和adb restore命令进行恢复新安装的同一个应用来查看聊天记录等信息；对于支付金融类应用，攻击者可通过此方法来进行恶意支付、盗取存款等。因此为了安全起见，开发者务必将allowBackup标志值设置为false来关闭应用程序的备份和恢复功能，以免造成信息泄露和财产损失。
allowBackup安全风险详情：
·allowBackup风险位置：AndroidMannifest.xml文件android：allowBackup属性。
·allowBackup风险触发前提条件：未将AndroidMannifest.xml文件中的android：allowBackup属性值设为false。
·allowBackup风险原理：当allowBackup标志值为true时，即可通过adb backup和adb restore命令来备份和恢复应用程序数据。
11.2 如何获取应用隐私数据
前面了解了allowBackup属性的相关知识点，可以看到allowBackup属性的风险非常大。如果这个属性是true的话，怎么在没有root的设备去获取数据呢？
首先看这样一个场景，现在市场上有一些应用锁类的App，它们就是给每个应用打开的时候添加一个密码，打开App的时候需要输入密码才能进入应用，一般会把自己的银行App、通讯类的App加密。现在市场上这些应用锁的原理也很简单，一般是三种方式实现：
·最古老的方式是后台启动一个service，然后隔一段时间去轮询，获取当前的topActivity，然后进行操作。
·因为Android 5.0以后，获取当前的topActivity需要授权，所以这里还需要做一个操作就是引导用户去开一些权限功能。
·通过辅助功能可以监听当前Window的变化，这种方式比上面的轮询方式高效多了。
其实前两种方式差不多，唯一的区别就在于获取topActivity的方式，其实Google可能意识到了，获取topActivity是很危险的一件事：比如现在有一个恶意的软件，可以通过这个功能，当用户启动设备中的一些通讯、银行App的时候，可以监听到然后就启动他们自己定义的钓鱼登录页面，模拟这些App的登录，最终可以获取到用户名和密码了，完成盗取。
下面来看一个市场上比较火的一款应用锁App，如图11-1所示。