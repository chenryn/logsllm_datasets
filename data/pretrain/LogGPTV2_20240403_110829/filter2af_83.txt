# 【缺陷周话】第59期：重复加锁
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 1、重复加锁
所有针对互斥量的加锁解锁操作，都必须针对同一模块并且在同一抽象层面进行，否则将会可能导致某些加锁/解锁操作不会依照多线程设计而被执行，重复加锁即对已经加锁的资源进行再次加锁。
## 2、“重复加锁”的危害
某些情况下，重复加锁操作会导致第二次加锁操作要等待前一次加锁的解锁操作，由于加锁操作的重复，被等待的行为永远无法达到，造成死锁、程序拒绝服务等漏洞。CVE中也有一些与之相关的漏洞信息，从2019年1月至2019年11月，CVE中就有1条相关漏洞信息。漏洞信息如下：
CVE | 概述  
---|---  
CVE-2019-14763 | Linux kernel 4.16.4之前版本的drivers/usb/dwc3/gadget.c 中存在一个
double-locking error（重复加锁错误），导致死锁问题。  
## 3、示例代码
示例源于toyota-itc-benchmarks-master (https://github.com/regehr/itc-benchmarks)，源文件名：double_lock.c。
### 3.1 缺陷代码
在上述示例代码中，第40行使用 pthread_mutex_lock() 函数对double_lock_001_glb_mutex
进行加锁操作，在没有进行解锁的情况下，第42行再次使用 pthread_mutex_lock() 函数对double_lock_001_glb_mutex
进行加锁操作，因此存在“重复加锁”问题。使用代码卫士对上述示例代码进行检测，可以检出“重复加锁”缺陷，显示等级为中。如图1所示：
图1：“重复加锁”检测示例
### 3.2 修复代码
在上述修复代码中，第40行使用 pthread_mutex_lock() 函数对double_lock_001_glb_mutex
进行加锁操作，在第42行使用pthread_mutex_unlock()
对其进行解锁，此时第44行再次进行加锁操作时，就避免了重复加锁问题。使用代码卫士对修复后的代码进行检测，可以看到已不存在“重复加锁”缺陷。如图2：
图2：修复后检测结果
## 4、如何避免“重复加锁”
（1）在进行加锁操作时，需要检查代码逻辑，避免对已经进行锁定的互斥量进行重复加锁。（2）当互斥量类型为PTHREAD_MUTEX_ERRORCHECK时，会提供错误检查。如果某个线程尝试重新锁定的互斥锁已经由该线程锁定，则将返回错误。