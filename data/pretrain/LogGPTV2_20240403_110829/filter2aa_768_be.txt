对于相容（conforming）代码段5，DPL 大于 CPL 
代码段选择子索引 
数据段选择子（data segment selector）超出描述符表限制 
数据段选择子索引 
数据段描述符的类型不是可读的代码或数据类型 
数据段选择子索引 
2 TSS 中指向前一个任务的 TSS 的段选择子，简称 backlink。 
3 繁忙的任务是指正在运行的任务或者被挂起（suspended）的任务。从 IRET 切换回去的任务是被打断的
任务，其 Busy 标志应该为繁忙。Busy 标志是为了防止任务切换陷入死循环。通常，当切换到的目标任务
（新任务）的繁忙标志已经设置时，会产生一般保护异常。但是如果该次任务切换是由 IRET 指令发起的
那么便不会产生异常。 
4 非相容代码段的代码只能被 CPL（Current Previlege Level）与其 DPL（Descriptor Previlege Level）相等的
程序所调用，也就是只有同等优先级的代码才可以调用或跳转到非相容代码段的代码。 
5 相容代码段的代码可以被 CPL（Current Previlege Level）与其 DPL（Descriptor Previlege Level）相等或更
小的程序所调用，也就是同等优先级或更低优先级的代码可以调用或跳转到相容代码段的代码。 
《软件调试》补编 
- 119 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
无效情况 
错误码索引域 
数据段描述符的类型是非相容代码类型而且 RPL>DPL 
数据段选择子索引 
数据段描述符的类型是非相容代码类型而且 CPL>DPL 
数据段选择子索引 
对于 LTR 指令，TSS 段选子为空 
TSS 段选择子索引 
对于 LTR 指令，TSS 段选子的 TI 标志为 1 
TSS 段选择子索引 
TSS 段描述符超出 GDT 段限制 
TSS 段选择子索引 
TSS 段或 upper 描述符不是可用的 TSS 类型 
TSS 段选择子索引 
IA-32e 模式下，TSS 段描述符是 286 TSS 类型 
TSS 段选择子索引 
TSS 段 upper 描述符不是正确的类型  
TSS 段选择子索引 
TSS 段描述符包含不规范的（non-canonical）基址（base） 
TSS 段选择子索引 
试图从 TSS 加载 SS 选择子或 ESP 时超出限制 
TSS 段选择子索引 
CPU 可能按照原任务的上下文产生无效 TSS 异常，也可按照新任务的上下文产生该
异常。如果处理器已经完成对新 TSS 的检验，那么就在新任务的上下中产生异常，否则
处理器会在原任务的上下文中产生异常。 
无效 TSS 异常的处理例程必须是通过任务门调用的任务。在 TSS 有问题的任务中处
理该异常可能因处理器的状态不一致而出问题。 
错误代码：错误码包含了导致异常的段描述符的段选择子索引和段描述符表的种类
（IDT/GDT）。如果 EXT 标志被置位，那么表示该异常是由外部事件（相对于正在运行的
程序）导致的，例如当有外部硬件中断发生时，使用任务门调用外部中断服务例程过程中
目标 TSS 无效。 
保存的程序指针：如果是在任务切换完成前检测到异常，那么栈中保存的 CS 和 EIP
值指向的是请求（invoke）任务切换的那条指令。如果是在任务切换完成后检测到异常，
那么栈中保存的 CS 和 EIP 值指向的是新任务的第一条指令。 
程序状态变化：如果无效 TSS 异常发生在任务移交点（即执行权移交给新任务那一点）
之前，那么程序状态没有变化。如果发生在移交点（新的段选择子的段描述符信息已经被
加载到段寄存器中）之后，那么处理器会在产生异常前从新 TSS 加载所有状态信息。在
任务切换过程中，处理器首先从 TSS 中装载所有段寄存器，然后再检查其内容的有效性。
如果在检查中发现无效 TSS 异常，那么处理器不再继续检查还没有检查的段寄存器。因
此无效 TSS 异常处理例程如果使用各个段寄存器（CS、DS、ES、FS、GS 和 SS）中的段
选择子，那么有可能再次导致无效 TSS 异常。英特尔推荐使用一个单独的任务来处理无
效 TSS 异常，那么当从异常处理例程切换回被打断的任务时，CPU 在从 TSS 加载该任务
时会检查各个段寄存器。 
C.12  段不存在异常（#NP） 
向量号：11 
异常类型：错误（Fault） 
引入该异常的处理器：286 处理器最早引入该异常，其后的所有 IA-32 处理器都实现了
该异常。 
描述：表示段或门描述符的存在（present）标志为 0。以下操作可能导致处理器产生
该异常： 
试图加载 CS、DS、ES、FS、GS 寄存器。如果在加载 SS 寄存器时检测到存在位为 0，
那么会导致栈错误异常（#SS）。 
《软件调试》补编 
- 120 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
使用 LLDT 指令加载 LDTR 寄存器。如果在任务切换过程中加载 LDTR 检测到 LDT
不存在那么会导致无效 TSS 异常（#TS）。 
当执行 LTR 指令时 TSS 被标记为不存在。 
试图使用一个被标记为段不存在（其它属性都有效）的门描述符或 TSS。 
操作系统可以使用段不存在异常实现段一级的虚拟内存。当要访问一个不在物理内存
中的段时，CPU 产生段不存在异常并调用异常处理程序，异常处理程序可以把该段从虚
拟内存中加载到物理内存中，然后返回继续执行。 
在门描述符中，因为门并不对应段，所以“不存在”并不表示段不存在。操作系统可
以使用该标志表示其它含义。 
在报告或处理有益类（contributory）异常和页错误异常时如果引用了不存在的段，那
么处理器会报告双重错误异常（#DF）而不是段不存在异常（#NP）。 
错误代码：错误码中包含了导致错误的段描述符的段选择子索引。如果 EXT 标志为 1，
那么该异常是由于以下情况之一导致的： 
外部事件（不可屏蔽中断或 INTR）导致了异常，随后引用了不存在的段。 
良性（benign）类异常随后引用了不存在的段。 
如果错误码描述的是 IDT 表项，那么 IDT 标志为 1。这类错误是由于被响应中断的向
量值指向的 IDT 表项是不存在的中断门。 
保存的程序指针：栈中保存的 CS 和 EIP 值指向的通常是导致该异常的那条指令。如
果该异常是发生在任务切换过程中加载新任务的段描述符，那么 CS 和 EIP 寄存器指向的
新任务的第一条指令。如果是在访问门描述符时发生该异常，那么 CS 和 EIP 寄存器指向
的请求访问的那条指令（比如引用调用门的 CALL 指令）。 
程序状态变化：如果段不存在异常是因为加载 CS、DS、ES、FS 或 GS 寄存器而发生
的，那么程序状态不会改变6，因为寄存器内容并没有改变。对于此种异常，异常处理程
序可以在将缺少的段加载到内存并设置段描述的存在标志后恢复运行原来的程序。 
如果在访问门描述符时发生了段不存在异常，不会伴有程序状态变化，异常处理程序
只要设置好存在标志就可以恢复程序运行。 
当段不存在异常发生在任务切换过程中，如果发生时刻是在把控制权移交给新任务那
一点之前，那么程序状态没有变化。如果发生在移交点之后，那么处理器会在产生异常前
从新的 TSS 加载所有状态信息。 
C.13  栈错误异常（#SS） 
向量号：12 
异常类型：错误（Fault） 
引入该异常的处理器：80286 最早引入该异常，其后的所有 IA-32 处理器都实现了该异
常。 
描述：该异常表示 CPU 检测到与栈有关的以下情况之一： 
6 IA-32 手册此处有误，原句为”a program state does accompany the exception because the register is not 
loaded”，应该是遗漏了“not”。 
《软件调试》补编 
- 121 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
在执行某个引用 SS 寄存器的操作时 CPU 检测到段界违例（limit violation）。导致段
界违例的操作有以下两类：明确或隐含使用 SS 寄存器的指令，如 MOV AX, [BP+6]或 MOV 
AX, SS:[EAX+6]；栈操作指令，如 POP、PUSH、CALL、RET、IRET、ENTER 和 LEAVE，
当使用 ENTER 指令来为一个过程建立栈桢（stack frame）时，如果没有足够的栈空间来
分配局部变量，那么便会产生此异常。 
当加载 SS 寄存器时，CPU 检测到栈段不存在（not present stack segment）。这种情况
可能发生在执行任务切换的过程中，目标优先级不同的 CALL 指令，返回到不同的优先级，
LSL 指令（Load Segment Limit，即加载段界），目标为 SS 寄存器的 MOV 或 POP 指令。 
栈错误异常是可能被恢复的，对于第一种情况可以通过扩展段界的方式来修正这个错
误；对于第二种情况只要把缺少的栈段加载到内存。 
错误代码：对于栈段不存在（第二类情况）和不同优先级间的调用导致的栈溢出（第
一类情况中的跨优先级情况），错误码中包含了导致异常的那个段的段选择子。异常处理
例程可以通过该选择子找到该段的段描述符并判断其存在标志。 
对于通常情况（发生在一个已经使用了的栈）的栈界违例，错误码为 0。 
保存的程序指针：栈中保存的 CS 和 EIP 值通常指向的是导致该异常的那条指令。但
如果是在任务切换时由于试图加载一个不存在的栈段而导致异常，那么 CS 和 EIP 指向的
是新任务的第一条指令。 
程序状态变化：如果栈错误异常是在任务切换过程中发生的，那么它可能发生在把控
制权移交给新任务那一点之前，也可能发生在巴控制权移交给新任务之后。如果是发生在
之前，那么程序状态没有改变。如果是发生在之后，那么处理器会在产生异常前继续从新
的 TSS 加载所有状态信息（而且不再做边界、类型和存在性检查）。所以异常处理例程不
能假定使用 CS、SS、DS、ES、FS 和 GS 段寄存器中的段选择子不会再导致异常。异常处
理例程应该认真检查每个段寄存器后再恢复运行原来的程序，否则可能再次发生错误使问
题更难定位和解决。 
对于其它情况的栈错误异常，不会伴有程序状态变化，因为 CPU 在报告异常前会恢
复到执行触发异常的指令前的状态。 
C.14  一般性保护异常（#GP） 
向量号：13 
异常类型：错误（Fault） 
引入该异常的处理器： 
80286 最早引入该异常，其后的所有 IA-32 处理器都实现了该异常。 
描述：CPU 的保护模式旨在提供一种多个应用程序在系统软件的监管下共享资源同时
运行的多任务环境，首先要保护系统软件的安全，使其不会受到其它软件的有意或无意破
坏，其次就是要保护系统中运行着的每个任务不受其它任务的破坏。为了实现这两种保护，
CPU 制定了一系列保护性规则（protection rule），并要求系统中运行的所有程序都要遵守
这些规则。如果有程序违反了保护性规则（称为 protection violation），那么 CPU 便会通过
异常的方式汇报给系统软件，系统软件根据情况采取措施，必要时会强行关闭“违例”的
程序（参见 3.6 节）。为了报告监测到的“违例”情况，CPU 定义了几种异常。比如当程
序中的指针指向了无效的内存地址时（比如空指针），那么 CPU 便会通过页错误异常（#PF）
《软件调试》补编 
- 122 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
将这一情况报告给系统软件。再比如，当一个程序试图向栈中压入过多数据，将导致超出
栈边界（limit）时，那么 CPU 便会通过栈错误异常（#SS）将该情况报告给操作系统。对
于 Windows 操作系统来说，如果该情况发生在用户模式，那么操作系统会尝试分配更多
的栈空间然后恢复执行被中断的指令，如果该情况发生在内核模式，那么操作系统便会。
但更多的情况下，CPU 会通过一般性保护异常（#GP——General Protection Exception）来
报告违反保护模式规则的情况。按照 IA-32 手册的说法，凡是不属于（已定义的）其它异
常的保护性违例都会作为一般性保护异常来报告。目前会导致一般性保护异常的情况有： 
当访问 CS、DS、ES、FS 或 GS 段时超出段边界。 
当引用一个描述符表时超出段边界（不包括发生在任务切换或栈切换过程中的情况，
因为这两种情况会分别报告无效 TSS 异常和栈错误异常）。 
向不可执行的段移交执行权。 
向代码段或只读数据段写。 
读仅可以执行（execute-only）的代码段。 
向 SS 寄存器中加载指向只读段的段选择子（不包括在切换任务时从 TSS 中读出的段
选择子，该情况会以无效 TSS 异常的形式汇报）。 
向 SS、DS、ES、FS 或 GS 寄存器中加载指向系统段的段选择子。 
向 DS、ES、FS 或 GS 寄存器中加载指向只可执行（execute-only）代码段的段选择子。 
向 SS 寄存器中加载指向可执行段的段选择子或空段选择子7（null segement selector）。 
向 CS 寄存器中加载指向数据段的段选择子或空段选择子。 
当 DS、ES、FS 或 GS 寄存器中包含空段选择子时使用它们访问内存。 
当使用指向 TSS 的 CALL 或 JMP 指令进行任务切换时，目标任务忙（busy）。 
在使用非 IRET（non-IRET）指令切换任务时使用的段选择子指向了当前 LDT（局部
描述符表）的 TSS。TSS 段只能位于 GDT（全局描述符表）中。如果在使用 IRET 指
令切换任务时检测到这种情况，那么 CPU 会报告无效 TSS 异常。 
违反任何权限规则（privilege rules），参见 2.3 节。 
指令超出长度限制（最长 15 字节），这种情况只可能发生在指令前放置了过多的前缀
（否则便会导致无效指令异常）。 
试图将 CR0 寄存器加载为 PG 标志为 1（paging enabled）PE 标志为 0（protection 
disabled），也就是没有启用保护模式时启用内存页支持。因该先启用保护模式（PE
位置 1）或同时将 PE 和 PG 位置 1。 
试图将 CR0 寄存器加载为 NW（Not Write-through）标志为 1 但 CD（Cache Disable）
标志为 0。 
中断或异常所引用的中断描述符表（IDT）表项不是中断门、陷阱门或任务门。 
企图从虚拟 8086 模式通过中断或陷阱门访问所在代码段的 DPL 大于 0 的中断或陷阱
处理例程。 
企图向 CR4 寄存器的保留位写 1。 
当 CPL（当前权限级别）不等于 0 时执行特权指令。 
写 MSR 寄存器的保留位。 
7 GDT 表的第一个表项是保留不用的，指向这个表项的段选择子（也就是 TI 标志为 0，索引也为 0）被称
为空段选择子。当向 CS 或 SS 寄存器加载空段选择子，CPU 会立刻报告一般性保护异常。向其它段寄存器
加载空段选择子时，CPU 不会报告异常，但如果使用这些寄存器访问内存时，CPU 便会报告异常。 
《软件调试》补编 
- 123 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
访问包含空段选择子的门。 
执行 INT n 指令时 CPL 大于（数值上）引用的中断门、陷阱门或任务门的 DPL。 
调用门、中断门或陷阱门中的段选择子指向的不是代码段。 
LLDT 指令中的段选择子操作符是局部类型（TI 位为 1）或者没有指向 LDT 类型的段
描述符。 
LTR 指令中的段选择子操作符是局部类型（TI 位为 1）或者指向的 TSS 不可用。 
调用、跳转或返回的目标代码段选择子为空。 
当 CR4 寄 存 器 的 PAE 和 / 或 PSE 位 为 1 时 CPU 检 测 到 页 目 录 指 针 表
（page-directory-pointer-table）表项的保留位被置位 1。当写 CR0、CR3 或 CR4 控制
寄存器时导致重新加载页目录指针表表项时，CPU 会检查这些位。 
试图向 MXCSR 寄存器的保留位写非零的值。 
执行要求按 16 字节对齐的 SSE/SSE2/SSE3 指令访问 128 位的内存区域时边界地址没
有按 16 字节对齐。这一规则也适用于堆栈段。 
错误代码：处理器会向异常处理例程的堆栈压入一个错误码。如果错误是在加载段描
述符时检测到的，那么错误码会包含指向这个代码段描述符的段选择子或者这个描述符对
应的 IDT 向量号。CPU 可能从以下来源提取错误码中的段选择子：指令操作数；参数所
指定的门（gate）的选择子；参与任务切换的 TSS 的选择子；IDT 向量号。 
保存的程序指针：栈中保存的 CS 和 EIP 值指向的是产生异常的那条指令。 
程序状态变化：通常一般性保护异常不会伴有程序状态变化，因为无效的指令或操作
没有被执行（严格说是 CPU 会恢复到导致异常的指令被执行前的状态）。因此，异常处理
程序可以纠正导致一般性保护错误的情况，然后恢复被中断的任务或程序。 
当一般性保护异常是在任务切换过程中发生的，那么它可能发生在把控制权移交给新
任务那一点之前，也可能发生在巴控制权移交给新任务之后。如果是发生在之前，那么程
序状态没有改变。如果是发生在之后，那么处理器会在产生异常前继续从新的 TSS 加载
所有状态信息（而且不再做边界、类型和存在性检查）。所以异常处理例程不能假定使用
CS、SS、DS、ES、FS 和 GS 段寄存器中的段选择子不会再导致异常。异常处理例程应该
认真检查每个段寄存器后再恢复运行原来的程序，否则可能再次发生错误使问题更难定位
和解决。 
如果异常发生在试图调用中断处理例程的过程中，那么被中断的程序可以重新运行，
但是中断可能丢失了。 
C.15  页错误异常（#PF） 
向量号：14 
异常类型：错误（Fault） 
引入该异常的处理器：80386 最早引入该异常，其后所有 IA-32 处理器都实现了该异常。 
描述：表示在启用了页机制（paging）（也就是 CR0 寄存器的 PG 标志为 1）的情况下，