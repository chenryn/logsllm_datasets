练习12.1.2：图12-11中有--个函数id，这个函数
4）描述f和g的所有调用串。
3）画出这个程序的调用图。
2）对于每个调用点，p可能指向哪些函数？q可能指向哪些函数?
1）找出本程序中的所有调用点。
int id(int x) { return x;}
else
图12-11练习12.1.2的代码片断
x+y;
第12章
--个常
---
## Page 597
12. 2.5 SQL 注入 
个精心构造的字符串，使得它从缓冲区中延伸到未预料到的区域，从而控制这个程序的运行。
这个弱点，通过操控被 Web 应用接收的输人来获取对数据库的控制。
的两个“最流行”的威胁系统完全的人侵形式是：
Metal是两个实用的工具，它们有效地使用过程间分析技术在大型程序中寻找多种程序错误。
一个重要源头是跨越过程边界的代码之间的不--致性，因此过程间分析极为重要。PREfix
保护。另--个例子是，在操作系统中屏蔽一个中断后必须随后重新启用这个中断。这类错误
机系统。计算机系统的代码错误可能引起严重的安全漏洞。
12.2.4软件错误和漏洞的检测
量优化(即基于简单变量的值的优化，比如第9章中讨论的技术)和并行化之间有很大的不同,
12.2.3并行化
能确定在基本块的结尾处等于1。
例12. 9
量。然而，指针的使用是很常见的，在像C这样的语言中尤其如此。如果知道多个指针是否可能
上也可以从过程间指针分析中获益。第9 章给出的所有分析只能应用于没有别名的局部标量变
大大提高软件的可靠性。
使
这
类
分
在
--个程序的最外层循环中找到的并行性。要完成这个任务，过程间分析技术是非常重要的。标
12.2.2指针别名分析
以内联这个m的代码，编译器甚至不需要在生成的代码中加人对x的类型检查代码。
在下一节中，我们将讨论如何使用过程间分析技术来保护程序不受这样的攻击。
当考虑安全缺陷时，我们非常期望找到一个程序中所有可能的错误。在2006 年，黑客使用
工具无法使用。无论如何，虽然这些工具不是完美的，但它们的系统化使用已经表明它们能的
用的过程间分析技术相当地不精确，如果让这些工具报告所有可能的错误，大量的假报警会使
个意义上说，它们不能找到所有的错误，并且不是报告的所有警告都是错误。遗憾的是，它们
工具可以静态地找到错误，从而大大提高软件可靠性。但是，这些工具既不完全也不健全。
错误。这些错误可能会使得软件变得不可靠，黑客可以利用这些错误来控制或毁坏一个计算
过程间分析不仅仅对优化代码很重要。同样的技术也可以用于分析已有软件，寻找各种编
优化机会即可。错过-一两个机会并不会引起很大的不同。
性。这种对不精确性的放大在标量优化中是看不到的。在标量优化中，我们只需要找出大部
并行化中，--个可疑的数据依赖关系就可能使得整个循环不可并行化，从而大大降低优化的有
即使我们不想执行诸如到达定值这样的常见数据流分析的过程间分析版本，这些分析实际
过程间分析
2)C和C+程序中的缓冲区溢出。因为C和C++不对数组访问进行边界检查，黑客就可以写出-
1）Web 应用中输人确认机制的缺失：SQI.注人是这种攻击最流行的形式之--。黑客们利用
静态分析可以用于检测是否存在常见的多种错误模式。比如，一个数据项必须用一个锁来
如第11章中所讨论的，将一个应用并行化的最有效方法是寻找最粗粒度的并行性，例如在
SQL 注人是一种黑客攻击方法。黑客可以通过操纵--个Web 应用的用户输人，从而获得对
如果不知道p和α是否可能指向同一-个位置，也就是说，它们是否可能互为别名，那么就不
li
*P：
5
考虑下面的三个语句组成的序列，它们可能组成了一个基本块：
581
---
## Page 598
为程序使用的某些数据可能已经被改变了。
存位置上的值将会被改变。这个情况本身可能会使程序产生故障，或者至少产生错误的答案，因
把它拷贝到一个缓冲区中。如果字符串s实际上比缓冲区6长，那么在缓冲区之外的某些内
串，然后使用函数调用
发生了缓冲区溢出攻击(buffer overllow attack）。比如，一个C程序可能从用户那里读取一个字符
12.2.6 缓冲区溢出 
真实的情况中，这些字符串可能被多次复制，或者和其他字符串组成完整的查询语句。如果我们不对
说，
个人的账户余额，而不考虑在 name-password-balance 三元组中和该名字一起出现的口令。也就是
而不是双引号来分割符号串，n 和p 之前的冒号表明它们是外围语言的变量。
中的当前字符串；然后打印这一行的第三个分量(余额）。”"请注意，这个SQL 语句使用了单引号
出一-行，要求第--个分量(名字)等于变量n中的当前字符串，而第二个分量(口令)等于变量p
例子是更复杂情况的典型代表，更复杂的情况是黑客可以使用那个账户付账。
能够看到账户余额。让一个黑客看到账户余额并不是可能发生的最糟糕的事情，但是这个简单
账户口令和该账户的余额。系统的本意是使得客户只有在提供了他们的名字和正确口令之后才
的访问。也就是说，这个关系是一个由多个三元组组成的表，每个三元组包含一个客户的名字，
例12.10假设一个银行向它的客户提供了对一个关系
的字符串可能以不可预料的方式改变这个SQL语句的含义。
成业务处理。这类系统的一个常用体系结构是让用户在一-个 Web 表单中输人字符串，然后把这
数据库的未授权访问。比如，银行可能希望只要它的用户能够提供正确的口令，他就可以在线完
个注释。结果，现在这个查询语句要求数据库系统打印出每个名字为'Charles Dickens'的
strcpy(b,s);
当一个由用户提供的精心制作的数据被写到了预想的缓冲区之外并操纵程序的执行时，就
，删除注释之后，这个查询变成了：
582
在例子12.10中，这个“坏"字符串被保存在两个变量中，它们可能在过程之间传递。但是，在更加
 SELECT balance FROM AcctData
在很多数据库系统中，--是一个注释引导符号，其作用是把该行中跟在其后的所有内容看作
假设一个黑客想找到 Charles Dickens 的账户余额，他向 n 和 p提供了下面的值：
我们向不熟悉 SQL 的读者解释--下这个查询含义。该语句的含义是：“在表 AcctData 中找
系统可以按照如下方式实现一次余额查询：
AcctData(name, password, balance)
n = Charles Dickens'
2）
ERE name
个奇怪的字符串的作用是把上面的查询转变成
ECT balance FROM AcctData
然后，可能在某些其他过程中，执行下列 SQL 查询：
名字被拷贝到一个变量n，口令被拷贝到另一个变量 P。
用户调用--个 Web 表单，在表单中输人他们的名字和口令。
= 'Charles Dickens' --′ and password = 'who cares'
p = who cares
第12章
---
## Page 599
Datalog 的元素是形如 p（X，X2，，Xn）的原子（atom），其中：
12.3.1Datalog 简介
们能高效地实现这些规则，实现方法是对集合运算的位向量方法进行推广。最后，逻辑方法使我
表示同样的意思。这么做使我们把那些用以推断程序性质的简明的“规则”表示出来。它也使
我们不再说诸如“定值 D在 IN[B]中"这样的断言，而是使用类似于in(B，D)这样的表示方法来
们用基本块 B 的 gen 和 kil 集合来表示这个基本块的内容。
我们把信息表示成集合，并通过交、并这样的运算来计算结果。比如，当我们在9.2.4节中介绍
于消除不必要的边界检查。
提供的内容。和SQL 注人一样，如果我们能够跟踪一个输人值在过程间传递复制的过程，就有利
户输人字符串有关的缓冲区溢出，那么可以使用静态分析技术来决定哪个变量可能存放了用户
的大小以应对缓冲区溢出。
指
向某个数组的中间，而且我们还不知道这个数组的大小。可以使用已有的技术来动态跟踪各
捕捉每个可能违背边界条件的情况。而且，我们只需要优化那些频繁执行的代码区域。
作上插人动态边界检查，并以静态分析为手段尽可能优化掉动态检查代码。这样就不再需要
所有事情就是保证正确地插人了动态检查代码。因此，一个可行的策略是让编译器在每个写
查是否在调用一个 strcpY 之前至少进行了某些测试，虽然这些测试不一定是正确的。
程序员很容易忘记插人测试代码，或者插人错误的测试代码。人们已经开发了启发式工具来
要么必须进行适当的动态数组边界检查。因为在C 和C++程序中必须手工插人这些边界检查，
传递到作为字符串的一部分的代码中，这样就能将任何种类的程序插人到正在执行的代码中。
他们控制这台计算机的能力。在有些情况下，他们甚至可以有能力让那个假的返回地址把控
到黑客选择的地方。如果黑客熟悉操作系统和硬件，那么他们就能够执行一个命令，让系统赋
可以被合并成为一组逻辑规则。我们可以同时求解这些规则。
据
12.3
是
是引起一个错误。比
二
Datalog 是--个使用类 Prolog 表示方法的语言，但是它的语义要比 Prolog 简单得多。首先,
能把几个看起来不一样的分析合并成为一个一体化的算法。比如，在9.5节中，我们用四个数
达定值问题时，我们为一个基本块 B计算 IN[B]和 OUT[B]，并把它们描述为定值的集合。
出，如果我们不允许所有的缓冲区溢出，
流分析组成的序列及两个中间步骤描述了部分冗余消除方法。在逻辑表示方法中，这些步骤
是，我们并不建议一检测到缓冲区溢出就停止执行程序。实际上，实践中确实会发生缓冲区
旨针指向的缓冲区的大小。这个信息允许编译器为所有的访问都插人数组边界测试。有意思白
为了防止缓冲区溢出，我们要么必须通过静态的方法证明每个数组写运算都处于边界之内
过程间分析
为了应对过程间分析的复杂性，我们引人一个更加通用且更加明确的基于逻辑的表示方法
可以说，到现在为止，我们对数据流问题和解答的表示方法是基于集合理论的。也就是说，
可以利用过程间分析技术来提高动态的数组边界检查的速度。比如，假设我们只关注和！
即使我们不在乎运行开销，在C程序中插人边界检查也不是容易的事情。一个指针可能
动态边界检查是不可避免的，因为不可能静态地确定用户输人的大小。静态分析可以做日
但是实际情况会更糟糕，选择字符串的黑客可以选择一个特别的值，使得它的作用不仅
1)p是一个断言一
数据流的一种逻辑表示方式
比如，如果该缓冲区位于一个运行时刻栈中，那么它可能离存放该函数的返
一个表示了一类语句的符号，比如“一个定值到达了一个基本块的
一个程序就很容易出错。解决的方法是动态扩展缓冲[
583
区
买
只
操
司
仅
---
## Page 600
程序将不断应用其中的规则，直到不能推断出新的基础原子为止。
子集合。这个程序的结果也是一组基础原子的集合，这个集合通过应用程序中的规则推断得到。
息，替换后的规则头可能为真也可能为假。
变量替换为常量之后得到的断言为真。不能使所有子目标都为真的替换方法没有给我们任何信
（假设所有且只有给定的基础原子为真），那么我们可以推断：按照这个替换方法把规则头中的
能把规则中的变量替代为常量的替换方法。如果某个替换方法使得规则体的每个子目标都为真
真
的计算。一-个规则的形式为：
12.3.2Datalog 规则
NOT in(B，D)是一个断言，表示定值 D 不能到达基本块 B的开始处。
标准解释，而像in 这样的普通断言的含义是由一个 Datalog 程序(将在下面描述)定义的。
的断言形式：equas(X,10)。但是比较断言和其他断言有一个最大的不同之处。一个比较断言有它的
如X≠Y或者X=10。在这些例子中，断言实际上是比较运算符。也就是说，我们可以把X=10看作它
(b2，d)和(b2，d2)。
真
处”，并假设对于特定的流图 in(b，d)为真且 in(b2，d)和in(bz，d2)也为
例12.11我们假设断言in(B，D)表示“定值 D 到达了基本块B 的开始
分量。在该关系中的所有基础原子的值都是真，不在此关系中的基础原子的值都为假。
名，对于每个属性，每个元组都有-一个对应的分量。这些属性对应于用关系方式表示的基础原子的
的表)通常比较方便。每个基础原子表示成关系的一行，或者说--个元组。这个关系的列以属性台
事实，它的值要么是真要么是假。把一-个断言表示为-一个关系（或者说令该断言取真值的基础原子
参数
开始处”
"。更精确地说，我们按照下面的方法把规则应用到一组给定的基础原子集合上。考虑所有可
阝么图 12-12 中的关系就表示了对应于这个流图的此断言的取值。
真。我们也可以假设对于这个流图而言，所有其他关于的描述都是假的。
严格地讲，这样的项是从函数符号构造而来的。它们大大增加了 Daalog 实现的复杂性。但是，只有在不把事情
规则是表示逻辑推理关系的一种方法。在Datalog 中，规则也说明了如何完成对正确的事实
有时我们也会看到一个实际上是变量及常量之间的比较运算的原子。比
2）X、X2、"、X，是变量或常量的项。我们也可以把一些简单表达式当作一个断言的
584
--个 Datalog 程序是一组规则的集合。这个程序被应用于一组“数据”，即某些断言的基础原
字面值(literal)是一个原子或其否定形式。我们在一个原子前加 NOT 来表示否定。因此，
我们应该把符号：－读作“如果”。--个规则的含义是“如果规则体为真，那么规则头也为
其中的组成部分如下：
这个关系的属性为B和 D。这个关系有三个元组，分别是（b;，d）、
一个基础原子(ground atom)是--个其参数都是常量的断言。每个基础原子表明了--个特定的
●每个B;有时被称为规则的子目标（subgoal）。
复杂化的情况下我们才会使用少量运算符，比如常量的加法和减法。
?
H是规则的头,B、B2、…、B,组成了规则的体。