简单的性能优化
性能优化对数据库工程师来说是一个重要的课题。本节将介绍一些只需调整SQL语句就能实现的通
用的忧化Tips
写在前面
SQL的性能优化是数据库工程师在实际工作中必须面对的重要课题
之一。对于某些数据库工程师来说，它几乎是唯一的课题。实际上，在像
Web服务这样需要快速响应的应用场景中，SQL的性能直接决定了系统
是否可以使用。
因此，本节不再像前面一样介绍SQL的各种功能的应用技巧，而是
将重点转向SQL的优化方面，介绍一些使SQL执行速度更快、消耗内存
更少的优化技巧。
严格地优化查询性能时，必须要了解所使用数据库的功能特点。此外，
查询速度慢并不只是因为SQL语句本身，还可能是因为内存分配不佳、
文件结构不合理等其他原因。因此本节即将介绍的优化SQL的方法未必
能解决所有的性能问题，但是确实很多时候查询性能不好的原因还是SQL
的写法不合理。
本节将尽量介绍一些不依赖具体数据库实现，而且简单易行的优化方
法。若这些方法能使大家在平常工作中感觉到SQL执行速度慢时得到帮
助，笔者将不胜荣幸。
使用高效的查询
在SQL中，很多时候不同代码能够得出相同结果。从理论上来说，
得到相同结果的不同代码应该有相同的性能，但遗的是，查询优化器生
图灵社区会员 非洲钢(PI:EMAIL) 专享 尊重版权
---
## Page 200
1-11让SOL飞起来
187
成的执行计划很大程度上要受到代码外部结构的影响。因此如果想优化查
询性能，必须知道如何写代码才能使优化器的执行效率更高。
参数是子查询时，使用EXISTS代替IN
IN谓词非常方便，而且代码也容易理解，所以使用的频率很高。但是
方便的同时，IN谓词却有成为性能优化的瓶颈的危险。如果代码中大量
用到了IN谓词，那么一般只对它们进行优化就能大幅度地提升性能。
如果IN的参数是“1，2，3”这样的数值列表，一般还不需要特别
注意。但是如果参数是子查询，那么就需要注意了。
在大多时候，[NOT]IN和[NOT]EXISTS返回的结果是相同的。但
是两者用于子查询时，EXISTS的速度会更快一些。
我们先看个例子。这里使用前面用过的两张用于管理员工学习过的培
训课程的表作为测试数据。
Class_A
Class_B
[名字】
尚编号）
（名字）
中田
田中
铃木
铃木
伊集院
西园寺
我们试着从Class_A表中查出同时存在于Class_B表中的员工。下面
两条SQL语句返回的结果是一样的，但是使用EXISTS的SQL语句更快
一些。
--慢
SELECT *
MHERE id IN(SBLBCT id
FROM Class_B} 1
--快
SELECT *
MHERE EXISTS
FROM C1a8s_AA
ISELECT *
FROM Class_B B
WHERE A.id = B. id) ↓
---
## Page 201
188—第1章神奇的SOL
■两个结果都如下所示
1d nane
1田中
2铃木
使用EXISTS时更快的原因有以下两个。
·如果连接列（id）上建立了索引l，那么查询Class_B时不用查实
际的表，只需查索引就可以了。
·如果使用EXISTS，那么只要查到一行数据满足条件就会终止查询，
不用像使用IN时一样扫描全表。在这一点上NOTEXISTS也一样。
当IN的参数是子查询时，数据库首先会执行子查询，然后将结果存储
在一张临时的工作表里（内联视图），然后扫描整个视图。很多情况下这种
做法都非常耗费资源。使用EXISTS的话，数据库不会生成临时的工作表。
但是从代码的可读性上来看，IN要比EXISTS好。使用IN时的代码
看起来更加一目了然，易于理解。因此，如果确信使用IN也能快速获取
结果，就没有必要非得改成EXISTS了。
注0
而且，最近有很多数据库也尝试着改善了IN的性能·。也许未来的
例如，在 Drnace 数据库中， 如果
我们使用了建有素引的列，那么
某一天，无论在哪个数据库上，IN都能具备与EXISTS一样的性能。
即使使用I也金先扫提索引。
也改善了使用子查询作为IN 调
此外, PostgreSOL 从&本 7,4 起
参数是子查询时，使用连接代替IN
误参数时的查次速度。
要想改善IN的性能，除了使用EXISTS，还可以使用连接。前面的查
询语句就可以像下面这样“扁平化”。
-使用连接代替IN
SELSCT A.id, A.nane
FBOM Class_A A INNER JOIN Class_B B
ON A.id = B.id;
子查询，所以数据库也不会生成中间表。我们很难说与EXISTS相比哪个
更好，但是如果没有索引，那么与连接相比，可能BXISTS会略胜一筹。
而且，从本节后面的很多例题也可以看出，有些情况下使用EXISTS比使
用连接更合适。
---
## Page 202
1-11让SOL飞起来189
避免排序
与面向过程语言不同，在SQL语言中，用户不能显式地命令数据库
进行排序操作。对用户隐藏这样的操作正是SQL的设计思想。
但是，这样并不意味着在数据库内部也不能进行排序。其实正好相反，
在数据库内部频繁地进行着暗中的排序。因此最终对于用户来说，了解都
有哪些运算会进行排序很有必要（从这个意义上讲，“隐藏操作”这个目
标的实现似乎还任重道远）。
会进行排序的代表性的运算有下面这些。
GROUP BY子句
ORDER BY子句
·聚合函数（SUM、COUNT、AVG、MAX、MIN）
*DISTINCT
*集合运算符（UNION、INTERSECT、EXCEPT）
。窗口函数〔RANK、ROW_NUMBER等）
排序如果只在内存中进行，那么还好：但是如果内存不足因而需要在
硬盘上排序，那么伴随着“赋啦吡啦”的硬盘访间声，排序的性能也会急
剧恶化（下面的数据可能不太准确据说硬盘的访问速度比内存的要慢
上100万倍）。因此，尽量避免（或减少）无谓的排序是我们的目标。
灵活使用集合运算符的ALL可选项
SQL中有 UNION、INTERSECT、EXCEPT三个集合运算符。
在默认的使用方式下，这些运算符会为了排除掉重复数据而进行排序。
SELBCT * FROX Class_A
UNION
SELBCT * FROM Cla8s_B/
id nane
田中
 =***
2
铃木
3伊集院
4西园寺
---
## Page 203
190—第1章神奇的SQL
如果不在乎结果中是否有重复数据，或者事先知道不会有重复数据，
请使用UNIONALL代替UNION。这样就不会进行排序了。
SELSCT * FROM ClaBs_A
MIONhLL
SSLSCT * FROM Cla8s_BJ
id nane
田中
2
拾木
3
伊集院
田中
铃木
2
居为不需除重显取提所以由不要要进行承厅
西园寺
对于INTERSECT 和EXCEPT也是一样的，加上ALL可选项后就不会
进行排序了。
加上ALL可选项是优化性能的一个非常有效的手段，但问题是各种
数据库对它的实现情况参差不齐。下表中汇总了目前各种数据库的实现
情况。
■集合运算符ALL可选项的实现情况
Oracle
DB2
SOLServer
MySOL
UNION
O
O
 O
INTERSECT
×
 ×
O
EXCEPT
×
×
1. Orade使用xINUs代替&xCBPT
2.MySOL连IRNTERBECT和EXCEPT运算本身还没有实现
上面这张表从侧面展现出了各个数据库厂商对标准SQL的遵从程度，
很有意思。DB2果然忠实地实现了全部功能。而PostgreSQL虽然是开
源软件，但是也兼顾到了所有细节，很符合学院派的作风。MySQL和
SQLServer稍微差一些，Oracle很重视自已的个性。人们很容易想当
然地以为所有的数据库都支持ALL可选项，但事实并非如此，请注意
一下。
---
## Page 204
1-11让SOL起来
—191
使用EXISTS代替DISTINCT
为了排除重复数据，DISTINCT也会进行排序。如果需要对两张表的
连接结果进行去重，可以考虑使用EXISTS代替DISTINCT，以避免排序。
Items
SalesHistory
em_no
iterr
sale_dale
em_no
quanbity
10
 FD
2007100110
4
20
CDR
20071001 |20
10
30
MO
20071001 |30
3
40
DVD
20071003
10
32
2007100 30
12
20071004 20
22
20071004 30
7
我们思考一下如何从上面的商品表Items中找出同时存在于销售记录
表SalesHistory中的商品。简而言之，就是找出有销售记录的商品。
使用IN是一种做法。但是前面我们说过，当IN的参数是子查询时，
使用连接要比使用IN更好。因此我们像下面这样使用“item_no”列对两
张表进行连接。
SELBCT I-item_no
FROM Itens I INNER JOIN SalesHistory SH
ON I. iten_no = SH. iten_noj
item_no
= * *
10
10
30
20
30
30
因为是一对多的连接，所以“item_no”列中会出现重复数据。为了
排除重复数据，我们需要使用DISTINCT。
SELBCT DISTINCT I.Iten_no
FROM Itens I INNER JOIN SalesHiatory SH
ON I. 1ten_no = SH. iten_no;
---
## Page 205
192—第1章神奇的SQL
iten_no
10
20
30
但是，其实更好的做法是使用BXISTS。
SELscr iten_no
FBOM Itens I
(SSLSCT *
FBOM SalesHiatory SH
HHERE I.iten_no = SH.iten_no) :
这条语句在执行过程中不会进行排序。而且使用BXISTS和使用连接
一样高效。
在极值函数中使用索引（MAX/IMIN）
SQL语言里有MAX和MIN两个极值函数。
使用这两个函数时都会进行排序。但是如果参数字段上建有索引，则
只需要扫描索引，不需要扫描整张表。以刚才的表Items为例来说，SQL
语句可以像下面这样写。
-这样写需要扫腊全表
SELSCT KAX(item)
FROH ItenR;
-这样写能用到惠引
SEL&CT KAX(1tem_no)
FEOM Iteng;
因为item_no是表Items 的唯一索引，所以效果更好。对于联合索引，
只要查询条件是联合索引的第一个字段，索引就是有效的，所以也可以对
表SalesHistory 的 sale_date 字段使用极值函数。
这种方法并不是去掉了排序这一过程，而是优化了排序前的查找速度，
从而减弱排序对整体性能的影响。
图灵社区会员非洲铜(PI:EMAIL）专享尊重版权
---
## Page 206
1-11让SOL飞起来—193
能写在WHERE子句里的条件不要写在HAVING子句里