run on binary alphabets and security parameter λ = 80. The results
of these tests appear in the lower part of Table 4.
8 CONCLUSIONS AND FUTURE WORK
In this work we implemented GGH15-based branching-program
obfuscation, showing that on one hand it is feasible to use it to
obfuscate non-trivial functions, and on the other hand that the class
of functions that it can handle is still extremely limited. In the course
of this work we developed many tools and optimizations, that we
expect will be useful also elsewhere. In particular We expect that our
Gaussian sampling techniques will find use in other lattice-based
cryptographic constructions. In this context, it will be interesting
to explore using these techniques also in the realm of ring-LWE
schemes.
An interesting topic to explore is hardware acceleration (with
GPUs or FPGAs), which may be able to reduce overhead to a point
where some niche applications can use it.
9 ACKNOWLEDGMENTS
Supported by the Defense Advanced Research Projects Agency
(DARPA) and Army Research Office(ARO) under Contract No. W911NF-
15-C-0236.
REFERENCES
[1] M. R. Albrecht. Private communications, 2016.
[2] M. R. Albrecht, C. Cocis, F. LaguillAumie, and A. Langlois. Implementing can-
didate graded encoding schemes from ideal lattices. In Progress in Cryptology -
AsiaCRYPT’15, Lecture Notes in Computer Science. Springer, 2015.
14
[3] M. R. Albrecht, R. Player, and S. Scott. On the concrete hardness of learning with
errors. J. Mathematical Cryptology, 9(3):169–203, 2015.
[4] D. Apon, Y. Huang, J. Katz, and A. J. Malozemoff. Implementing cryptographic
program obfuscation. Cryptology ePrint Archive, Report 2014/779, 2014. http:
//eprint.iacr.org/.
[5] S. Arora and R. Ge. New algorithms for learning in presence of errors. In ICALP
(1), volume 6755 of Lecture Notes in Computer Science, pages 403–415. Springer,
2011.
[6] Y. Chen, C. Gentry, and S. Halevi. Cryptanalyses of candidate branching program
obfuscators. Cryptology ePrint Archive, Report 2016/998, 2016. http://eprint.iacr.
org/2016/998.
[7] J. Coron, T. Lepoint, and M. Tibouchi. Practical multilinear maps over the integers.
In R. Canetti and J. A. Garay, editors, CRYPTO 2013, volume 8042 of Lecture Notes
in Computer Science, pages 476–493. Springer, 2013.
[8] J.-S. Coron, M. S. Lee, T. Lepoint, and M. Tibouchi. Cryptanalysis of ggh15
multilinear maps. Cryptology ePrint Archive, Report 2015/1037, 2015. http:
//eprint.iacr.org/2015/1037.
[9] S. Garg, C. Gentry, and S. Halevi. Candidate multilinear maps from ideal lattices.
In Advances in Cryptology - EUROCRYPT’13, volume 7881 of Lecture Notes in
Computer Science, pages 1–17. Springer, 2013.
[10] S. Garg, C. Gentry, S. Halevi, M. Raykova, A. Sahai, and B. Waters. Candidate
indistinguishability obfuscation and functional encryption for all circuits. SIAM
J. Comput., 45(3):882–929, 2016.
[11] C. Gentry, S. Gorbunov, and S. Halevi. Graph-induced multilinear maps from
lattices. In Y. Dodis and J. B. Nielsen, editors, Theory of Cryptography - 12th
Theory of Cryptography Conference, TCC 2015, Warsaw, Poland, March 23-25, 2015,
Proceedings, Part II, volume 9015 of Lecture Notes in Computer Science, pages
498–527. Springer, 2015. https://eprint.iacr.org/2014/645.
[12] C. Gentry, S. Halevi, and N. Smart. Homomorphic evaluation of the AES circuit.
In "Advances in Cryptology - CRYPTO 2012", volume 7417 of Lecture Notes in
Computer Science, pages 850–867. Springer, 2012. Full version at http://eprint.
iacr.org/2012/099.
[13] C. Gentry, C. Peikert, and V. Vaikuntanathan. Trapdoors for hard lattices and
new cryptographic constructions. In STOC’08, pages 197–206, 2008.
pages 20–31. ACM, 1988.
[14] J. Kilian. Founding cryptography on oblivious transfer. In J. Simon, editor, STOC,
[15] A. Langlois, D. Stehlé, and R. Steinfeld. Gghlite: More efficient multilinear maps
from ideal lattices. In P. Q. Nguyen and E. Oswald, editors, EUROCRYPT, volume
8441 of Lecture Notes in Computer Science, pages 239–256. Springer, 2014.
[16] K. Lewi, A. J. Malozemoff, D. Apon, B. Carmer, A. Foltzer, D. Wagner, D. W.
Archer, D. Boneh, J. Katz, and M. Raykova. 5gen: A framework for prototyping
applications using multilinear maps and matrix branching programs. In ACM
Conference on Computer and Communications Security, pages 981–992. ACM,
2016.
[17] J. Liu. Eigenvalue and Singular Value Inequalities of Schur Complements, pages
[18] D. Micciancio and C. Peikert. Trapdoors for lattices: Simpler, tighter, faster,
smaller. In EUROCRYPT, volume 7237 of Lecture Notes in Computer Science, pages
700–718. Springer, 2012. Full version at http://ia.cr/2011/501.
[19] C. Peikert. An efficient and parallel gaussian sampler for lattices. In T. Rabin,
editor, Advances in Cryptology - CRYPTO 2010, 30th Annual Cryptology Conference,
Santa Barbara, CA, USA, August 15-19, 2010. Proceedings, volume 6223 of Lecture
Notes in Computer Science, pages 80–97. Springer, 2010.
[20] V. Shoup. NTL: A Library for doing Number Theory. http://shoup.net/ntl/,
Version 9.11.0, 2016.
47–82. Springer US, Boston, MA, 2005.
[21] F. Zhang. The Schur Complement and Its Applications. Numerical Methods and
Algorithms. Springer, 2005.
A MORE PERFORMANCE DETAILS
A.1 Asymptotics of Obfuscation
For a given branching-program length L and security parameter λ,
our choice of parameters from before ensures that ℓ = log(q) and
the lattice dimension m satisfy ℓ ≥ Ω(L log m + λ) and m ≥ Ω(ℓλ).
It is easy to see that these constraints imply ℓ ≥ Ω(λ + L log(λL))
2 + λL log(λL)). This means that each encoding matrix
and m ≥ Ω(λ
C ∈ Zm×m
3 log3(λL)) to write down,
takes space ℓm
7 +
and multiplying or inverting such matrices takes time ℓm
3
λ
obfuscated program consists of 2σ(L − 1) matrices, so:
q
4 log4(λL)).
L
For a length-L branching program over an alphabet of size σ, the
3 = Ω(λ
2 = Ω(λ
5 + λ
L
2
Session D1:  Functional Encryption and ObfuscationCCS’17, October 30-November 3, 2017, Dallas, TX, USA7962
4 log3(λL))),
L
L+σλ
5 log4(λL)).
L
• the total space that it consumes is Ω(σλ
• the time to compute it is Ω(σλ
L + σλ
and
7
5
3
In words, the obfuscation running time is linear in σ, sextic in λ,
and quasi-quintic in L, and the hard-disk size needed is linear in σ,
quintic in the security parameter, and quasi-quartic in L.
We note, however, that our implementation is parallelized across
the different CRT components, whose number is proportional to
ℓ = log q, so we expect one factor of ℓ from the running-time to be
eaten up by this parallelism. We thus expect the wall-clock time of
the obfuscation to be “only” quasi-quartic in the program length
6).
˜Ω(L
4), and sextic in the security parameter Ω(λ
For the RAM requirements, our implementation keeps only two
matrices in RAM at the same time so it uses Ω(λ
3 log3(λL))
5 + λ
memory, but this could be reduced further (by only keeping a small
number of CRT components in memory, or only keeping a small
number of slices of each matrix in memory).
L
2
A.2 Concrete Results
To save time, we did almost all of our experiments with binary
alphabet |Σ| = 2, but for our parameter L = 15 we also ran it where
the input is expressed in nibbles |Σ| = 16, to verify that it works also
for that setting. As expected, initialization and evaluation were not
affected by the alphabet size, and RAM usage during obfuscation
was only marginally higher, while running-time and disk usage in
obfuscation were exactly 8 times larger for |Σ| = 16 than for |Σ| = 2.
The timing results for various settings can be found in Table 4, and
memory and disk-space usage are described in Figures 6, 7, and 8.
We also ran tests to examine the effectiveness of our paralleliza-
tion strategies, comparing the running times for the same parame-
ters (L = 8, binary alphabet, and 12 CRT factors) across different
number of threads. As expected given our choice of parallelism
across CRT component, increasing the number of threads upto the
number of CRT factors reduces the running time, but adding more
threads after that has no effect. The detailed results are described
in Figure 5. 9
9Our code always allocates 1-2 threads for pipelined I/O, and only increases the number
of worker threads after that, hence the decrease in running-time only begins at 2-3
threads. Also the running time plateaus at 15 threads, even though there are only 12
CRT factors.
15
# of threads
1
2
3
4
6
12
16
32
Initialization Obfuscation Evaluation
90.4
91.2
89.5
87.2
89.7
88.7
91.8
98.5
15809.2
15837.1
15844.3
8605.9
4917.8
3298.5
2375.8
2168.1
3840.2
3833.6
2032.0
1451.8
1120.0
803.0
560.1
568.9
Figure 5: Running time (seconds) as a function of the num-
ber of threads.
L
5
6
8
10
12
14
16
17
20
m
3352
3932
5621
6730
8339
9923
10925
11928
14145
RAM
(Obfuscation)
5.5
8.7
25
43
81
137
184
241
401
Figure 6: RAM usage (Gigabytes) as a function of the BP-
length. (L = input size, m = large dimension)
Session D1:  Functional Encryption and ObfuscationCCS’17, October 30-November 3, 2017, Dallas, TX, USA797L
5
6
8
10
12
14
16
17
20
m Initialization (GB) Obfuscation (GB)
2.3
5.0
13
50
120
244
383
538
1124
3.7
7.3
28
61
141
280
432
602
1236
3352
3932
5621
6730
8339
9923
10925
11928
14145
Figure 7: Hard disk usage as a function of the input length.
(L = input size, m = large dimension)
# of threads
1
2
3
4
6
12
16
32
Initialization (GB) Obfuscation (GB) Evaluation (GB)
8.2
8.2
8.2
8.2
8.2
8.3
8.3
7.9
10
10
12
14
18
28
29
29
33
33
33
33
33
39
41
45
Figure 8: Memory usage for different number of threads,
length L = 8.
16
Session D1:  Functional Encryption and ObfuscationCCS’17, October 30-November 3, 2017, Dallas, TX, USA798