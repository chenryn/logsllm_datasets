title:GemFI: A Fault Injection Tool for Studying the Behavior of Applications
on Unreliable Substrates
author:Konstantinos Parasyris and
Georgios Tziantzoulis and
Christos D. Antonopoulos and
Nikolaos Bellas
2014 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
GemFI: A Fault Injection Tool for Studying the
Behavior of Applications on Unreliable Substrates
Konstantinos Parasyris∗
∗‡§Dept. of Electrical and Computer Eng.
Georgios Tziantzoulis†
∗‡§I.RE.TE.TH.
Christos D. Antonopoulos‡
University Of Thessaly
Centre for Research and Technology, Hellas
E-mail: ∗
‡
koparasy,
Volos, Greece
§
cda,
PI:EMAIL,
†
Volos, Greece
PI:EMAIL
Chicago, U.S.A.
Nikolaos Bellas§
†Computer Science Dept.
Northwestern University
Abstract—Dependable computing on unreliable substrates is
the next challenge the computing community needs to overcome
due to both manufacturing limitations in low geometries and the
necessity to aggressively minimize power consumption. System
designers often need to analyze the way hardware faults manifest
as errors at the architectural level and how these errors affect
application correctness.
This paper introduces GemFI, a fault injection tool based on
the cycle accurate full system simulator Gem5. GemFI provides
fault injection methods and is easily extensible to support future
fault models. It also supports multiple processor models and
ISAs and allows fault injection in both functional and cycle-
accurate simulations. GemFI offers fast-forwarding of simulation
campaigns via checkpointing. Moreover, it facilitates the parallel
execution of campaign experiments on a network of workstations.
In order to validate and evaluate GemFI, we used it to
apply fault injection on a series of real-world kernels and
applications. The evaluation indicates that its overhead compared
with Gem5 is minimal (up to 3.3%), whereas optimizations such
as fast-forwarding via checkpointing and execution on NoWs can
signiﬁcantly reduce simulation time of a fault injection campaign.
Keywords-fault-injection; simulation; cycle accurate; full sys-
tem
I. INTRODUCTION
Fault injection is a fundamental experimental method for
assessing the dependability and identifying weaknesses in the
design of fault tolerant systems. Fault injection can also be
used to simulate execution on unreliable systems, to study
the behavior of applications under the presence of faults, or
evaluate the coverage of a software fault tolerance mechanism.
Different fault injection techniques are appropriate for dif-
ferent phases of the design cycle of systems. Simulator-based
fault injection can be used early in the design cycle, software
and pin level fault injection require the availability of a system
prototype. Most fault injection tools target a speciﬁc system
using customized user interfaces. Extending such infrastruc-
tures is unrealistic, limiting the tool’s application domain.
In this paper we introduce GemFI, a cycle accurate fault
injection tool based on the Gem5 simulator [1]. A primary ob-
jective of the tool is to enable fault injection based on different
fault models and on systems with various conﬁgurations. We
target full system simulations to evaluate the impact of faults
on the complete system stack, from the the architectural level
978-1-4799-2233-8/14 $31.00 © 2014 IEEE
DOI 10.1109/DSN.2014.96
622
up to applications. A variety of different system conﬁgura-
tions and architectures can be supported without affecting the
implementation of fault injection in GemFI.
GemFI supports the generic behavioral-level fault model for
the register ﬁle within a processor [2]. The model describes
the behavior of micro-architectural components of a generic
processor under the presence of faults. The fault model is
abstracting the low-level fault effects to the micro-architectural
level. It can be used to simplify and accelerate fault injection
campaigns – compared with injection on RTL models –
without sacriﬁcing accuracy of the obtained results.
GemFI can support any processor model and ISA available
in the Gem5 simulator. For the purposes of this study we use
the Alpha ISA1. To provide more accurate results, GemFI in-
jects faults on the CPU while simulating both user- and kernel-
level instructions and models a complete system including
CPU, memory and the peripheral devices. The tool includes a
number of performance enhancing features: checkpointing and
restart functionality and the ability to launch fault injection
simulation campaigns on a network of workstations (NoW).
To evaluate GemFI, we inject with faults a number of codes
from different application domains with diverse characteristics.
We focus on correlating the effects of faults in different
architectural components with the particular characteristics of
each application and its inherent error tolerance. Moreover, we
study the relation of the timing of faults during the application
life with the effect on the correctness of results.
The remainder of the paper is organized as follows. An
overview of Gem5 simulator is given in Section II. Section III
discusses the internal design and implementation of the tool
and its usage. Section IV describes our experimental method-
ology and outlines the results of the experimental validation of
the simulator. Section V focuses on the quantitative evaluation
of GemFI performance. Section VI discusses previous work.
Finally, Section VII concludes the paper.
II. THE GEM5 SIMULATOR
Gem5 is a popular open-source system simulator. It provides
a modular platform for computer system-level architecture
1GemFI also supports Intel x86 ISA, however we discuss the Alpha ISA
implementation due to the mature support of the Alpha architecture by GEM5.
research, encompassing system-level architecture as well as
processor micro-architecture.
Object oriented design enhances the ﬂexibility of Gem5.
The ability to construct conﬁgurations from independent ob-
jects facilitates multicore and multi-system design. Moreover,
Gem5 provides four different CPU models, each of them rep-
resenting a different point in the speed vs simulation accuracy
trade-off. Atomic Simple is a single IPC CPU model. Timing
Simple is similar but also simulates the timing of memory
references. InOrder is a pipelined in order CPU. Finally, O3
is a pipelined out-of-order CPU model. Gem5 also supports
two memory system models: classic and ruby. The classic is
fast and easily conﬁgurable, while the ruby model provides a
ﬂexible infrastructure capable of accurately simulating a wide
variety of cache coherence memory systems.
Gem5 operates in two modes: System Call Emulation (SE)
and Full System (FS). In SE mode applications execute on
simulated “bare metal”. Whenever the program executes a
system call, Gem5 traps and emulates the call usually by
passing it to the host OS. Currently there is no thread scheduler
in SE mode. Therefore, threads are statically mapped to a
core, hindering its use with multi-threaded applications. FS
mode offers an environment for running an operating system
(OS) on top of the simulator. There is support for interrupts,
exceptions and I/O devices. Applications are executed under
the control of the OS.
Gem5 supports a number of ISAs, including Alpha, MIPS,
ARM, Power, SPARC and x86. The simulators modularity
allows these different ISAs to be easily implemented on top of
the generic CPU models and the memory system. Alpha is the
most maturely supported ISA, with ARM and x86 following.
III. GEMFI DESIGN AND IMPLEMENTATION
We extended Gem5 with fault injection capabilities, follow-
ing the General Processor fault model described in [2]. The
result, GemFI, is a conﬁgurable tool for studying the effect of
faults in a processor.
GemFI was developed using C++ and Python. It fully
supports the Alpha and Intel x86 ISAs. Supporting more
instruction sets is rather straightforward, since the implemen-
tation of GemFI is fairly ISA-agnostic. GemFI supports full
system simulation mode as well as the execution of multi-
threaded applications. An architectural overview of GemFI is
depicted in Fig. 1, whereas the following sections discuss its
main features in more detail.
A. GemFI User Interface
GemFI provides an API consisted of two intrinsic functions.
• void ﬁ activate inst(int id) is translated to a pseudo-
assembly instruction. Its successive occurrences toggle
(active/inactive) the manifestation of faults for the spe-
ciﬁc process/thread. The executing thread is assigned a
numerical id which can be used as an identiﬁer of the
thread in fault injection conﬁguration.
• void ﬁ read init all() checkpoints the simulation. Upon
restoring from the checkpoint, it resets all the internal
623
Fig. 1: An architectural overview of GemFI. The red com-
ponents of the architecture demonstrate the possible locations
where faults can be injected, whereas the red ovals represent
applications which use the extended ISA.
information of GemFI, allowing the same checkpoint to
be used as a starting point for multiple experiments with
potentially different fault injection conﬁgurations.
On GemFI invocation the user also provides – at command
line – an input ﬁle specifying the faults to be injected in the
upcoming simulation. Each line of the input ﬁle describes the
attributes of a single fault. Faults are characterized by four
attributes: Location, Thread, Time and Behavior.
1) Location: Fault location speciﬁes the micro-architectural
modules to be targeted for fault injection. The user speciﬁes
the core, the module within the core and ﬁnally the speciﬁc bit
location to be corrupted. Supported locations include registers
(integer, ﬂoating point, special purpose), the fetched instruc-
tion, the selection of read/write registers during the decoding
stage, the result of an instruction at the execution stage, the
PC address and ﬁnally memory transactions (load/stores).
2) Thread: The thread attribute allows to selectively inject
faults to speciﬁc threads, using the id assigned to the thread
upon execution of ﬁ activate inst(id) as an identiﬁer.
3) Time: Another important aspect of the fault injection
conﬁguration is its timing. Timing is relative to a simulation
milestone, marked by the execution of the ﬁ activate inst.
Faults are scheduled relatively to the number of instructions
already executed, or to the number of elapsed simulation ticks
of the targeted thread.
4) Behavior: The values of the speciﬁed faulty location can
be corrupted in following ways:
• by assigning an immediate value provided by the user to
the location.
”RegisterInjectedFault Inst:2457 Flip:21
Threadid:0 system.cpu1 occ:1 int 1”
Listing 1: A sample input ﬁle to GemFI
#include 
int main(int argc, char ∗argv[]){
int id = 0;
initialize input data();
ﬁ read init all();
ﬁ activate inst(id);
foo();
ﬁ activate inst(id);
}
Listing 2: Modiﬁed source code of an application for fault
injection.
• by XORing the running value at this location with a user-
speciﬁed constant.
• by ﬂipping the running value at bit locations. Multiple
bit ﬂips are supported by injecting multiple faults on the
same module.
• by setting all bits of the location to a value of 0 or 1.
To emulate the behavior of transient and permanent faults,
the user can deﬁne how long the fault is active in terms of
the number of simulation ticks or number of instructions. For
example, a fault injected in the execution stage of the processor
can be injected continuously for the next N instructions (or for
the next N simulation cycles) if so instructed by the user.
B. Simple Example
Listing 1 outlines a user-provided fault conﬁguration ex-
ample. The fault is injected in the 21st bit of register R1 of
the CPU (location), when the application fetches the 2457th
instruction after the initiation of fault injection for this thread
(ﬁ activate inst). The fault is activated for a single instruction
(occ:1) and only for the thread with id equal to 0.
The end user compiles (or cross-compiles) the application
to be tested (Listing 2). Target applications must, at least,
contain one call to initialize fault injection. Afterwards, the
user moves the binaries into the disk image serving as the
virtual disk of GemFI. Using the command line, the user
provides a conﬁguration ﬁle (Listing 1) describing all the
faults to be injected in the simulation. After ﬁ activate inst(id)
is called, the thread identiﬁer is stored in the internal data
structures of GemFI. Simulation continues normally, until it
is time for a fault to be injected. At that time, GemFI alters
the state of the target hardware structure according to the fault
speciﬁcation in the conﬁguration ﬁle.
C. GemFI Internals and Implementation
Fig. 2 demonstrates the main abstract steps executed by
GemFI on each simulated served instruction.
Threads that have enabled fault
injection are internally
represented as instances of a class (ThreadEnabledFault),
624
Fig. 2: GemFI functionality on each simulated instruction.
containing all per thread information necessary for fault in-
jection, such as the number of instructions the thread has
executed on each core. Each simulated core has a pointer to a
ThreadEnabledFault object. If the thread executing on the core
has not activated fault injection, the pointer is NULL. When a
thread executes ﬁ activate inst(), GemFI looks in a hash table
to identify whether the speciﬁc thread has already activated
fault injection. Threads are identiﬁed at the hardware/simulator
level by their unique Process Control Block (PCB) address. If
the thread is not found in the hash table, a new ThreadEnabled-
Fault object is created and the running core is set to point to
that object. On the other hand, if there was already an entry in
the hash table, the invocation of ﬁ activate inst() deactivates
fault injection for the speciﬁc thread. The thread is removed
from the hash table, the corresponding ThreadEnabledFault
object is destroyed and the core’s pointer is set to NULL.
During context switches, which are identiﬁed by the change
of the PCB address, GemFI checks whether the switched-in