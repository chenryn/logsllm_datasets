try:
s = time.time()
g = fn() # 调⽤用⽬目标⽣生成器器函数。
g.send(None) # 启动，开始执⾏行行请求代码。
time.sleep(2)
g.send(f"done: {time.time() - s}") # 阻塞结束后，将结果传回任务。
except StopIteration: # ⽬目标结束，拦截异常。
pass
def service(fn):
threading.Thread(target=target, args=(fn,)).start()
如此，既没有影响异步执⾏，也不再碎⽚化。
service(request)
print("do something")
输出：
start
do something # 发起请求后，并未阻塞。
done: 2.0059099197387695
协程
协程（coroutine）以协作调度⽅式，在单个线程上切换执⾏并发任务。配合异步接⼜，可
将原本 IO 阻塞时间⽤来执⾏更多任务。因在⽤户空间实现，也被称作⽤户线程。
理论上，任何具备 yield 功能的语⾔都能轻松实现协程。
当然，基于性能考虑，专业异步框架会选⽤ greenlet 之类的协程实现。
def sched(*tasks):
tasks = list(map(lambda t: t(), tasks)) # 调⽤用所有任务函数，⽣生成器器列列表。
while tasks: # 循环调⽤用任务。
try:
!186
学习笔记 . 第三版
t = tasks.pop(0) # 从列列表头部弹出任务。
t.send(None) # 开始执⾏行行该任务。
tasks.append(t) # 如果任务没有结束，则放回列列表尾部。
except StopIteration: # 任务结束，则放弃。
pass
from functools import partial
def task(id, n, m): # 模拟任务模版。
for i in range(n, m):
print(f"{id}: {i}")
yield # 主动调度。
t1 = partial(task, 1, 10, 13)
t2 = partial(task, 2, 30, 33)
sched(t1, t2)
输出：
1: 10
2: 30
1: 11
2: 31
1: 12
2: 32
!187
学习笔记 . 第三版
4. 函数式编程
函数式编程（Functional Programming）中的 “函数” 更趋近于数学概念，以计算表达式替
代命令式语句。强调逐级结果推导，⽽⾮执⾏过程。
要求函数为第⼀类型，可作为参数和返回值传递。需要时，可⽤闭包构成带有上下⽂状态
的逻辑返回。通常不使⽤变量，所有状态以参数传递，⽤嵌套或链式调⽤代替过程语句。
最好是没有外部依赖的纯函数，且参数不可变，仅以结果带⼊下⼀级运算。
命令式
x = a + b
y = x * 2
函数式
mul(add(a, b), 2)
add(a, b).mul(2)
相⽐命令式代码，函数式风格更精简，易组合，可替换。对单元测试和并发编程友好，引
⽤透明且没有副作⽤。
三⼤特征：第⼀类型函数，不可变数据，尾递归优化。函数式编程只是⼀种编程范式，多数语⾔
都⽀持或部分⽀持，这与计算机架构⽆关。实际上，现有冯·诺伊曼结构就是按命令序列执⾏。
迭代
以迭代器⽅式，⽤指定函数处理数据源。相⽐推导式，它能从多个数据源中平⾏接收参数，
直⾄最短数据源迭代完成。
1, 2, 3 a, b, c, d ...
1 a ?
map function
call(1, a, ?)
!188
学习笔记 . 第三版
>>> x = map(lambda a, b: (a, b), [1, 2, 3], "abcd")
>>> list(x) # 将迭代器器对象转换为列列表。
[(1, 'a'), (2, 'b'), (3, 'c')]
Python 3 以最短数据源为截⽌，⽽不是像 Python 2 那样以 None 补位。
如果参数已经完成并⾏组合，可使⽤ itertools.starmap 代替。
聚合
平⾏从多个数据源接收参数，聚合成元组，直到最短数据源迭代结束。
>>> x = zip([1, 2, 3], "abcd", (1.1, 1.2))
>>> list(x)
[(1, 'a', 1.1), (2, 'b', 1.2)]
常被⽤来构造字典。
>>> kv = zip("abcd", range(100, 200))
>>> dict(kv)
{'a': 100, 'b': 101, 'c': 102, 'd': 103}
如果以最长数据源为准，可使⽤ itertools.zip_longest。
累积
迭代数据源，将结果带⼊下次计算，适合完成统计或过滤操作。
func 初始化值或上次计算结果 本次迭代数据
!189
学习笔记 . 第三版
>>> import functools
>>> def calc(ret, x):
print(f"ret = {ret}, x = {x}")
return ret + x
>>> functools.reduce(calc, [1, 2, 3]) # 没有初始化值，直接将第⼀一数据当结果。
ret = 1, x = 2
ret = 3, x = 3
6
>>> functools.reduce(calc, [1, 2, 3], 100) # 需要对第⼀一数据和初始化值进⾏行行计算。
ret = 100, x = 1
ret = 101, x = 2
ret = 103, x = 3
106
如果没有初始值，则跳过第⼀数据，直接将其当作下次计算参数。
同 Python 2 内置函数 reduce。
过滤
使⽤指定函数对数据进⾏迭代过滤。
函数返回布尔值决定数据去留。
为 None 时相当于 bool 函数，移除所有 False 元素。
>>> x = filter(lambda n: n % 2 == 0, range(10))
>>> list(x)
[0, 2, 4, 6, 8]
>>> list(filter(None, [0, 1, "", "a", [], (1,)]))
[1, 'a', (1,)]
!190
学习笔记 . 第三版
判断
判断⼀系列数据中，全部或某个元素为真值。
>>> all([1, "a", (1,2)])
True
>>> any([0, "", (1,2)])
True
标准库 itertools 拥有⼤量针对迭代器的操作函数，推荐使⽤。
!191
学习笔记 . 第三版
六. 模块
1. 模块
!192
学习笔记 . 第三版
2. 导入
!193
学习笔记 . 第三版
3. 包
!194
学习笔记 . 第三版
七. 类
1. 定义
!195
学习笔记 . 第三版
2. 字段
!196
学习笔记 . 第三版
3. 属性
!197
学习笔记 . 第三版
4. 方法
!198
学习笔记 . 第三版
5. 继承
!199
学习笔记 . 第三版
6. 开放类
!200
学习笔记 . 第三版
7. 操作符重载
__repr__, __str__ 输出对象信息。
!201
学习笔记 . 第三版
八. 异常
LabelException
Exception 与 Goexit 的对⽐，中断调⽤堆栈。
1. 异常
!202
学习笔记 . 第三版
2. 断言
!203
学习笔记 . 第三版
3. 上下文
!204
学习笔记 . 第三版
九. 元编程
1. 装饰器
!205
学习笔记 . 第三版
2. 描述符
!206
学习笔记 . 第三版
3. 元类
!207
学习笔记 . 第三版
4. 注解
!208
学习笔记 . 第三版
十. 进阶
1. 解释器
!209
学习笔记 . 第三版
2. 扩展
!210
学习笔记 . 第三版
十一. 测试
1. 单元测试
!211
学习笔记 . 第三版
2. 性能测试
!212
学习笔记 . 第三版
十二. 工具
1. PDB
!213
学习笔记 . 第三版
2. PIP
!214
学习笔记 . 第三版
3. iPython
!215
学习笔记 . 第三版
4. Jupyter Notebook
!216
学习笔记 . 第三版
5. VirtualENV
wheel?
!217
学习笔记 . 第三版
下卷 标准库
Python 3.6
!218
学习笔记 . 第三版
十三. 文件
!219
学习笔记 . 第三版
十四. 数据
!220
学习笔记 . 第三版
十五. 数据库
!221
学习笔记 . 第三版
十六. 网络
!222
学习笔记 . 第三版
十七. 并发
!223
学习笔记 . 第三版
十八. 系统
!224