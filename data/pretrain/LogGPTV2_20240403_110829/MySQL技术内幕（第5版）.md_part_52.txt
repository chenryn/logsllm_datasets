户不存在时，会出现一条警告消息。如果你没有SUPER权限，则只能把定义者设置为你自己的
户。
CURRENT_USER或CURRENT_USER（）。它表明定义者就是执行这条CREATE语句的那个用户的账
该格式与账户管理语句（如CREATEUSER）里所用的格式一样。更多相关信息请参考13.2.1.1
行时检查访问权限的目的。例如：
个DEFINER=account子句。这样，这里列出的账户就能跟定义者完全一样，从而达到在执
过程，进而访问到我的表，因为它是以我的权限来运行的。这种类型的安全上下文有利有弊：
用于访问我的表。如果我把p（)的EXECUTE 权限授予你，那么你便可以使用CALLp（)来调用该
应该使用什么样的安全上下文来检查访问权限呢？也就是说，
4.3
在视图或存储程序里，CURRENT_USER（）函数会默认返回与该对象的 DEFINER属性相对应
如果某个视图或存储程序以定义者的权限来运行，但那个定义者账户并不存在，那么会出
服务器会自动调用触发器和事件，所以这里的“调用者”概念对它们并不适用。因此，它
对于视图和存储例程（包括存储函数和存储过程），还可以使用SQL SECURITY 特性，用于
如果你拥有 SUPER 权限，则可以使用任何一种语法正确的账户名来作为DEFINER值。当账
，如果没有给出DEFINER子句，则默认使用同一个账户。
默认情况下，服务器会使用定义该对象的那个用户的账户。假设我定义了一个存储过程p（），
CREATE SQL SECURITY INVOKER VIEW V
适合使用SQLSECURITYINVOKER的场合是：只想以调用者所拥的权限来执行视图或存储程
在 DEFINER子句里，
CREATE DEFINER=sampadm'@'localhost
在定义存储程序或视图时，显式指定定义者的方法是，在该对象的CREATE语句里包含一
口有利的一面是：精心编写的存储程序可以把表开放给那些无法直接访问它们的用户
在定义视图时，需要设置一条用于以后调用的SELECT语句。
AS SELECT CONCAT(User,'@',Host） AS Account,Password FROM mysql.user;
口
ALTER EVENT event_name ENABLE;
ALTER EVENT event_name DISABLE;
，既可以使用完整的账户名，也可以使用CURRENT_USER。
视图和存储程序的安全性
了其他可以调用该对象的人也会访问到那些敏感数据，则会造成安全漏洞。
1有弊的一面是：如果某个用户创建了某个可以访问到敏感数据的存储程序，但却忘记
并可对访问进行控制。
，定义者的具体值可以是格式为user_name'@'host_name'的账户名，
PROCEDURE count_students()
4.3视图和存储程序的安全性
，应该应用哪个账户的权限呢？
”预示着实际执行这些对象的
，在定义存储程序时，也有相
199
---
## Page 220
低性能的情况，并对如何为表合理地选择索引提供指导。在下一节，我们将讨论MySQL的查
该首先使用索引来最大程度地改进性能，然后再看看是否还有其他有用的技术。
使用索引，那么在许多情况下，通过其他途径来提高性能的各种尝试都纯粹是在浪费时间。应
便能立马解决问题。但也并非总是如此，因为优化通常都不是件简单的事情。然而，如果你不
查询速度差异的最大因素就是索引是否使用得当。多数情况下，当查询速度很慢时，加上索引
5.1
也可以更加快速地运行查询。
地处理查询。MySQL数据库已经很快了，但是如果你能“施以援手”，那么即使最快的数据库
去寻找能够加快查询的方法。所幸的是，还真有一些技术可以实现这个目标。
际硬件的具体实现会受到各种真实物理条件的约束。因此，查询需要占用一定的时间一
上就是集合操作，其中没有时间的概念。
数据的底层表示。集合理论里的另一个抽象概念是，对表的操作都是立刻发生的；查询在概念
和列的另一个集合，即另一个表。这些都是很抽象的概念，并不涉及数据库系统用来操作表中
查询优化
本节将描述索引是什么，以及索引是怎样改进查询性能的。另外，还会讨论到索引可能降
用来加速查询的技术有很多，其中最为重要的就是索引。也就是说，在通常情况下，造成
不过，真实世界完全是另一回事。数据库管理系统的确能实现这些抽象概念，但依赖于实
本章将着重讨论上述几个方面的内容，以帮助你优化数据库系统的性能，使它尽可能快速
口选择能够让服务器进行高效处理的数据类型和表存储格式。
口认真考虑如何编写能够最大程度利用这些索引I的查询，并且使用EXPLAIN 语句来检查
口为表创建索引，能让数据库服务器查找行的速度更快。
使用索引
MySQL服务器是否真的那样做了。
系数据库理论涉及的主要内容有表、集合，以及针对表和集合的操作。数据库是表的
第
5章
一有时
---
## Page 221
重要。重要的是，我们要知道这些技术很有效，并且还要知道使用索引的确是个好方法。
都使用了各种各样的技术来快速定位索引值，但这些技术具体是什么对本书的读者来讲并不
多)。这样，我们便可以快速地定位到第一个匹配值，从而节省大量的搜索时间。许多数据
达
为了查找匹配项，一行一行地搜索整个表了，我们可以使用这个索引。假设，我们要找出
那么整个扫描过程的效率将会超级低。
这是一个全表扫描操作，其效率很低，如果表很大，而且仅有少数几个行与搜索条件相匹配，
果我们想要找到某个公司的行，那么需要检查表的每一行，看看它是否与那个期望值相匹配。
组无序的行。图5-1展示了 ad表，我们在第1章中讨论过它。因为这个表没有索引，所以，如
5.1.1
些查询编写方法实际上会阻碍你对索引的有效利用，你肯定想避免这种情况。
优化程序也有所理解，那就更好了。因为这样一来，你就能更加充分地利用创建的索引了。有
询优化程序，该程序会尝试找出最为有效的查询执行方式。除了解如何创建索引之外，若能对
索引开始位置进行线性扫描，即可直接找到第一个匹配项（例如，二分搜索比扫描要快
位置结束，从而跳过其余部分。
可以退出查找过租
我们读到那条包含
公司编号为14的索引值，该值比我们正查找的值要大一点。由于索引值已是有序的，
编号为13的所有行。我们开始扫描索引，便会找到3个属于该公司的值。然后，我们会
图5-2显示的是同一个表，
让我们先从一个没有索引的表开始，一起来看看索引是如何工作的。无索引的表就只是一
索引的优点
程。由此可见，
含14的索引行时，我们便知道再也无法找到更多与13匹配的内容了，
，不同之处在于 ad 表的 company_num 列增加了一个索引。
company_num
另一种使用索引提高效率的做法是，利用定位算法，不用
一种使用索提高效率的做法是，我们可以得知匹配行在个
表
图5-2
图5-1无索引的ad表
142317 13 2328 23 13281413171
索引后的ad表
company_num
ad num
142817132323231323 4137
hitfee
ad numhit fee
2
0
14 4 252 8 4799101019
0
5.1使用索引
因
201
库
很
Y
---
## Page 222
加上索引通常能够使性能得到显著提升。
夸张。虽然这个例子是用来说明索引用处的，但是它所揭示的问题却是真实存在的，而且为表
和
查完为止。
的速度，
索
配
到那些与WHERE子句相匹配的行。可能的组合总共有1000×1000×1000（共10亿!）种，这比匹
此查询的结果应该有1000个行，其中每一个行都包含有3个相等的值。如果我们不使用索引
个行的所有组合中
在执行单表全扫描查询时，你必须不断地检查行数，以确保它就是表的行数。在多表查询里，
全表扫描，从而可以极大地提高搜索速度。在执行连接多个表的查询时，索引发挥的作用更大。
来
这
自
引值
关键字行主要用于快速访问数据文件。
其数据行保留在数据文件里，而索引值则保留在索引文件里。一个表可以有多个索引，但它们
保持排序顺序，来回移动较短的索引值，要比来回移动较长的数据行更加容易。
创建出多个索引。此外，索引里的行通常都要比表里的数据行更短。当插入或删除新值时，
ID号或电话号码的索引。将索引从数据行中整体分离出来，便可以解决这个问题，并且还可以
如果表只有一个索引，那么回答是肯定的。但是你有可能还想添加第二个索引，但又不能同时
202
口t3执行的是索引查找。这种查询方式的运行速度比不使用索引的方式要快100万倍—毫不
引，那么处理表之间的连接所花费的时间将会大大增加。
数目多
来进行查询，那么根本无法知道哪些个行包含了哪些值。于是，我们必须尝试所有组合，以找
口i3，并且每个列都有1000个行，这些行中包含的是1~1000的数字。如果想要在这些表的各
这个数可能是一个天文数字，因为它是所有这些表中所有行的乘积。
己的表空
此时，我们对表t1执行的仍然是全扫描操作，但是为了将那些行直接挑选出来，对表t2
假议
对于不同的MySQL存储引擎，索引的具体实现细节会有所不同。例如，对于MyISAM表，
口对于使用MIN（）或MAX（）函数的查询，MySQL可以在不用逐行检查的情况下，快速找
口如上所述，索引可以用于加快对WHERE子句匹配的行进行搜索的速度，或者用于加快
MySQL使用索引的方式有以下几种。
(3）继续选择表t1的下一个行，然后重复前面的过程。一直持续到表t1的所有行都被检
直接转到与表t1的值相匹配的那个行。
（1）从表t1中选择第一个行，看该行包含的是什么值。
WHERE t1.i1= t2.i2 AND t2.i2 = t3.i3;
上述讨论描述的是，在查询单个表时，索引所具有的优势，即使用索引可以不再需要执行
(2）利用表t2的索引，直接转到与表t1的值相匹配的那个行。类似地，利用表t3的索
当作是
为何不直接对数据行排序，省掉索引操作呢？这样做难道不是同样能够加快搜索速度吗？
FROMt1
管理着房
对，与另一个连接表里的行匹配的行，进行搜索的速度。
度，因为有了索引，查询就可以像下面这样进行处理。
目多了100万倍。这可是一种巨大的浪费。随着表的增长，情况会变得更糟。如果不使用
设，
之相比，InnoDB存储引擎没有按照上面的方法将行和索引值分开放置，尽管它也是把索
到索引列里的最小值或最大值。
第5章
，你有3个无索引表t1、t2和t3，其中每个表都包含有一个列，它们分别为i1、i2
空间，但是即便如此，给定表的数据和索引也同样保存在同一个表空间文件里。
所有
一组有序值。默认情况下，InnoDB存储引擎只使用一个表空间，在这个表空间的内
INNER
查询优化
中，将其值彼此相等的行找出来，那么可以用如下语句进行查询：
InnoDB表的数据存储和索引存储。可以配置InnoDB，让它创建的每个表都有
JOIN
t2 INNER JOIN t3
。索引文件里的每一个索引都由一组有序的关键字行构成，这个组
，为表建立索引，可以大幅提高查询
为
---
## Page 223
是很好的索引候选列：
BY 或 GROUP BY子句中的列。而那些只是出现在 SELECT 关键字后面的输出列表里的列，则不
是说，最佳索引候选列是那些出现在WHERE子句中的列、连接子句中的列，或者出现在ORDER
本节将在如何确定出索引候选列方面给出一些指导。
只了解语法，并不能帮助你确定要创建哪些索引。该操作需要你认真考虑各个表的具体用途。
5.1.3挑选索引
么就不要创建它。
均性能下降得也就越多。大部分的表都是读操作多写操作少，但对于那些写操作较多的表来说，
中，这些缺点常被其优点所掩盖，但是你应该对此有所了解。
描绘了一幅玫瑰般漂亮的画面。它没有缺点吗？有，它们在时间和空间上都有成本。在实际
5.1.2索引的代价
会让你很快便达到表的大小极限。
在索引更新方面的开销会非常大。5.5节将讨论如何减少这方面的开销。
人一个行不仅是写入一个数据行，还要更改索引。表的索引越多，需要做出的更改就越多，平
也就是说，
意味着，在大部分情况下，如果不为表创建索引，那么你就是在自残。对于索引的优点，我已
（1）为用于搜索、排序或分组的列创建索引，而对于用作输出显示的列则不用创建索引。也就
其次，索引也会占用磁盘空间，多个索引会占据更大的空间。与没有索引相比，使用索引
与索引创建有关的语法，已在2.6.4.2节里讲过了。这里假定你已阅读了该节的内容。但是
上述两个因素的现实指导意义是什么呢？如果不需要某个特定的索引来加快查询速度，那
首先，
SELECT
一般来讲，如果MySQL 知道如何通过索引来更快速地处理查询，那么它都会那样做。
WHERE
FROM
口存储在InnoDB系统表空间里的所有InnoDB表，都共享同一个存储空间池，添加索引会
口对于MyISAM表，大量地对它进行索引，有可能导致索引文件比数据文件更快地到达
口
口对于ORDER BY和GROUP BY子句，MySQL经常使用索引来高效地完成分类和分组
操作。
引将导致表的大小更加快速地到达文件的最大大小。
col_d = expr;
使用独立表空间的InnoDB表，会把数据和索引集中存储在同一个文件里，因此增加索
其他的磁盘空间，那么你就可以采用将其添加为新部件的方式来扩展表空间。
系统表空间不会受到操作系统文件大小的限制，因为可以配置它使用多个文件。如果有
使表空间里用于存储的空间减少得更快。不过，
其最大大小。
行得到的值一样。
该表的其他列。在这种情况下，MySQL读取索引值获得的值，跟通过读取相应的数据
有时，MySQL 也会通过索引来读取查询所请求的所有信息。假设有一个InnoDB
tbl1 LEFT JOIN tb12
col_a
索引降低了大部分与写入相关的操作的速度。之所以会出现这样的情况，是因为写
索引可以加快检索速度，但是它同时也降低了索引列插入、删除和更新值的速度。
，没理由读取两次那些值，因此根本就不用访问这个数据行。
←候选列
←候选列
←不是候选列
，与MyISAM表所用的文件不同，InnoDB
5.1使用索引
203
这
或
---
## Page 224
city。在索引里,行的排列顺序为country/state/city,因此,行首先会自动按country/state