subsequent works on PBE regex synthesis and repair [22],
[23]. We extend the idea with the support for the real-world
features.
The over- and under-approximation t⊤ and t⊥ are built to
satisfy the properties L(r′) ⊆ L(t⊤) and L(t⊥) ⊆ L(r′) for any
regex r′ obtainable by filling the holes of t. If P ⊈ L(t⊤) or
N ∩ L(t⊥) ̸= /0, then there is no way to get a regex consistent
with P and N from the template, and thus we safely discard
the template from the search.
The approximations are built by filling each hole in t
with either ·∗ or [/0] based on whether an under- or over-
approximation is to be made and whether the hole appears in
even or odd number of negative lookarounds. Let ·∗ = [/0] and
[/0] = ·∗. Then, t⊤ = α(t,·∗) and t⊥ = α(t, [/0]) where α(t,r) is
inductively defined as follows:
α([C],r) = [C]
α(ε,r) = ε
α(t∗,r) = α(t,r)∗
α(\i,r) = \i
α((?!t),r) = (?!α(t,r))
α((cid:50),r) = r
α(t1t2,r) = α(t1,r)α(t2,r)
α(t1|t2,r) = α(t1,r)|α(t2,r)
α((t)i,r) = (α(t,r))i
α((?=t),r) = (?=α(t,r))
α((?, without the
(cid:50) because · and > are
only generate one template <s(cid:50)an(cid:50)
the only sets of characters that violate the RWS1U condition.
∗
VI. IMPLEMENTATION AND EVALUATION
In this section, we present the results of our evaluation.
We evaluate the performance of REMEDY by answering the
following questions.
RQ1 Can REMEDY repair vulnerable regexes efficiently?
RQ2 Can REMEDY find high-quality regexes?
RQ3 What is the effect of the optimization?
For the first question, we measure the time taken to repair
vulnerable regexes on a real-world data set. For the second