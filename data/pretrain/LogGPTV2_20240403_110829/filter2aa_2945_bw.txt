  return (!cardsInSuit.Exists(c => c.CardSuit == suit &&
c.CardValue == value));
}
11. Display the Hand.cs file in the Code and Text Editor window. Add the
following using directive to the list at the top of the file:
using System.Collections.Generic;
12. The Hand class currently uses an array called cards to hold the playing
cards for the hand. Modify the definition of the cards variable to be a
List collection, as shown here in bold:
Click here to view code image
class Hand
{
   public const int HandSize = 13;
   private List cards = new List
(HandSize);
   ...
}
13. Find the AddCardToHand method.
This method currently checks to see whether the hand is full; if it is not,
it adds the card provided as the parameter to the cards array at the index
specified by the playingCardCount variable.
Update this method to use the Add method of the List
collection instead.
This change also removes the need to explicitly keep track of how many
cards the collection holds because you can use the Count property of the
Download from finelybook PI:EMAIL
634
cards collection instead. Therefore, remove the playingCardCount
variable from the class and modify the if statement that checks whether
the hand is full to reference the Count property of the cards collection.
The completed method should look like this, with the changes
highlighted in bold:
Click here to view code image
public void AddCardToHand(PlayingCard cardDealt)
{
   if (this.cards.Count >= HandSize)
   {
     throw new ArgumentException("Too many cards");
   }
   this.cards.Add(cardDealt);
}
14. On the Debug menu, click Start Debugging to build and run the
application.
15. When the Card Game form appears, click Deal.
Note The Deal button is located on the command bar. You may
need to expand the command bar to reveal the button.
Verify that the cards are dealt and that the populated hands appear as
before. Click Deal again to generate another random set of hands.
The following image shows the application running:
Download from finelybook PI:EMAIL
635
16. Return to Visual Studio 2017 and stop debugging.
Summary
In this chapter, you learned how to use some of the common collection
classes to store and access data. In particular, you learned how to use generic
collection classes to create type-safe collections. You also learned how to
create lambda expressions to search for specific items within collections.
If you want to continue to the next chapter, keep Visual Studio 2017
running and turn to  Chapter 19, “Enumerating collections.”
If you want to exit Visual Studio 2017 now, on the File menu, click
Exit. If you see a Save dialog box, click Yes and save the project.
Quick reference
To
Do this
Create a
Use the constructor for the collection class. For example:
Download from finelybook PI:EMAIL
636
new
collection
Click here to view code image
List cards = new List();
Add an
item to a
collection
Use the Add or Insert methods (as appropriate) for lists, hash
sets, and dictionary-oriented collections. Use the Enqueue
method for Queue  collections. Use the Push method for
Stack collections. For example:
Click here to view code image
HashSet employees = new HashSet();
employees.Add("John");
...
LinkedList data = new LinkedList();
  data.AddFirst(101);
...
Stack numbers = new Stack(); numbers.Push(99);
Remove an
item from a
collection
Use the Remove method for lists, hash sets, and dictionary-
oriented collections. Use the Dequeue method for Queue
collections. Use the Pop method for Stack collections. For
example:
Click here to view code image
HashSet employees = new HashSet();
  employees.Remove("John");
...
LinkedList data = new LinkedList();
  data.Remove(101);
...
Stack numbers = new Stack();
...
int item = numbers.Pop();
Find the
number of
elements in
a collection
Use the Count property. For example:
Click here to view code image
List cards = new List();
...
int noOfCards = cards.Count;
Locate an
item in a
collection
For dictionary-oriented collections, use array notation. For
lists, use the Find methods. For example:
Click here to view code image
Dictionary ages = new Dictionary();
ages.Add("John", 47);
int johnsAge = ages["John"];
...
List personnel = new List();
Person match = personnel.Find(p => p.ID == 3);
Note: The Stack, Queue, and hash set collection
classes do not support searching, although you can test for
membership of an item in a hash set by using the Contains
method.
Iterate
through the
elements of
a collection
Use a for statement or a foreach statement. For example:
Click here to view code image
LinkedList numbers = new LinkedList();
...
for (LinkedListNode node = numbers.First; node !=
null;
node = node.Next)
{
   int number = node.Value;
   Console.WriteLine(number);
}
...
foreach (int number in numbers)
{
   Console.WriteLine(number);
}
Download from finelybook PI:EMAIL
638
CHAPTER 19
Enumerating collections
After completing this chapter, you will be able to:
Manually define an enumerator that you can use to iterate over the
elements in a collection.
Implement an enumerator automatically by creating an iterator.
Provide additional iterators that can step through the elements of a
collection in different sequences.
Chapter 10, “Using arrays,” and Chapter 18, “Using collections,” show how
you work with arrays and collection classes for holding sequences or sets of
data. Chapter 10 also details the foreach statement, which you can use to step
through, or iterate over, the elements in a collection. In these chapters, you
use the foreach statement as a quick and convenient way of accessing the
contents of an array or a collection, but now it is time to learn a little more
about how this statement actually works. This topic becomes important when
you define your own collection classes, and this chapter describes how you
can make collections enumerable.
Enumerating the elements in a collection
Chapter 10 presents an example of using the foreach statement to list the
items in a simple array. The code looks like this:
Click here to view code image
Download from finelybook PI:EMAIL
639
int[] pins = { 9, 3, 7, 2 };
foreach (int pin in pins)
{
    Console.WriteLine(pin);
}
The foreach construct provides an elegant mechanism that greatly
simplifies the code you need to write, but it can be exercised only under
certain circumstances—you can use foreach only to step through an
enumerable collection.
But what exactly is an enumerable collection? The quick answer is that it
is a collection that implements the System.Collections.IEnumerable interface.
Note Remember that all arrays in C# are actually instances of the
System.Array class.  The System.Array class is a collection class that
implements the IEnumerable interface.
The IEnumerable interface contains a single method called
GetEnumerator:
IEnumerator GetEnumerator();
The GetEnumerator method should return an enumerator object that
implements the System.Collections.IEnumerator interface. The enumerator
object is used for stepping through (enumerating) the elements of the
collection. The IEnumerator interface specifies the following property and
methods:
Click here to view code image
object Current { get; }
bool MoveNext();
void Reset();
Think of an enumerator as a pointer indicating elements in a list. Initially,
the pointer points before the first element. You call the MoveNext method to
move the pointer down to the next (first) item in the list; the MoveNext
method should return true if there actually is another item and false if there
Download from finelybook PI:EMAIL
640
isn’t. You use the Current property to access the item currently pointed to,
and you use the Reset method to return the pointer back to before the first
item in the list. By using the GetEnumerator method of a collection to create
an enumerator, repeatedly calling the MoveNext method, and using the
enumerator to retrieve the value of the Current property, you can move
forward through the elements of a collection one item at a time. This is
exactly what the foreach statement does. So, if you want to create your own
enumerable collection class, you must implement the IEnumerable interface
in your collection class and also provide an implementation of the
IEnumerator interface to be returned by the GetEnumerator method of the
collection class.
Important At first glance, it is easy to confuse the IEnumerable and
IEnumerator interfaces because their names are so similar. Be certain
not to mix them up.
If you are observant, you will have noticed that the Current property of
the IEnumerator interface exhibits non–type-safe behavior in that it returns
an object rather than a specific type. However, you should be pleased to
know that the Microsoft .NET Framework class library also provides the
generic IEnumerator interface, which has a Current property that returns
a T instead. Likewise, there is also an IEnumerable interface containing
a GetEnumerator method that returns an Enumerator object. Both of
these interfaces are defined in the System.Collections.Generic namespace,
and if you are building applications for the .NET Framework version 2.0 or
later, you should make use of these generic interfaces rather than the
nongeneric versions when you define enumerable collections.
Manually implementing an enumerator
In the following exercise, you will define a class that implements the generic
IEnumerator interface and create an enumerator for the binary tree class
that is demonstrated in Chapter 17, “Introducing generics.”
Download from finelybook PI:EMAIL
641
Chapter 17 illustrates how easy it is to traverse a binary tree and display
its contents. You would, therefore, be inclined to think that defining an
enumerator that retrieves each element in a binary tree in the same order
would be a simple matter. Sadly, you would be mistaken. The main problem
is that when defining an enumerator, you need to remember where you are in
the structure so that subsequent calls to the MoveNext method can update the
position appropriately. Recursive algorithms, such as those used when
walking a binary tree, do not lend themselves to maintaining state
information between method calls in an easily accessible manner. For this
reason, you will first preprocess the data in the binary tree into a more
amenable data structure (a queue) and actually enumerate this data structure
instead. Of course, this deviousness is hidden from the user iterating through
the elements of the binary tree!
Create the TreeEnumerator class
1. Start Microsoft Visual Studio 2017 if it is not already running.
2. Open the BinaryTree solution, which is located in the \Microsoft
Press\VCSBS\Chapter 19\ BinaryTree folder in your Documents folder.
This solution contains a working copy of the BinaryTree project you
created in Chapter 17. You will add a new class to this project in which
to implement the enumerator for the BinaryTree class.
3. In Solution Explorer, click the BinaryTree project. On the Project menu,
click Add Class to open the Add New Item - BinaryTree dialog box. In
the middle pane, select the Class template, type TreeEnumerator.cs in
the Name box, and then click Add.
4. The TreeEnumerator class will generate an enumerator for a
Tree object. To ensure that the class is type safe, you must
provide a type parameter and implement the IEnumerator interface.
Also, the type parameter must be a valid type for the Tree
object that the class enumerates, so it must be constrained to implement
the IComparable interface (the BinaryTree class requires that
items in the tree provide a means to be compared for sorting purposes).
In the Code and Text Editor window displaying the TreeEnumerator.cs
file, modify the definition of the TreeEnumerator class to satisfy these
requirements, as shown in bold in the following example:
Download from finelybook PI:EMAIL
642
Click here to view code image
class TreeEnumerator : IEnumerator where TItem :
IComparable
{
}
5. Add the following three private variables, shown in the following code
in bold to the TreeEnumerator class:
Click here to view code image
class TreeEnumerator : IEnumerator where TItem :
IComparable
{
    private Tree currentData = null;
    private TItem currentItem = default(TItem);
    private Queue enumData = null;
}
The currentData variable will be used to hold a reference to the tree
being enumerated, and the currentItem variable will hold the value
returned by the Current property. You will populate the enumData
queue with the values extracted from the nodes in the tree, and the
MoveNext method will return each item from this queue in turn. The
default keyword is explained in the section “Initializing a variable
defined with a type parameter” later in this chapter.
6. Add a constructor that takes a Tree parameter called data to the
TreeEnumerator  class. In the body of the constructor, add the
statement shown in bold that initializes the currentData variable to data:
Click here to view code image
class TreeEnumerator : IEnumerator where TItem :
IComparable
{
    ...
    public TreeEnumerator(Tree data)
    {
       this.currentData = data;
    }
}
7. Add the following private method shown in bold, called populate, to the
TreeEnumerator class, immediately after the constructor:
Download from finelybook PI:EMAIL
643
Click here to view code image
class TreeEnumerator : IEnumerator where TItem :
IComparable
{
    ...
    public TreeEnumerator(Tree data)
    {
       this.currentData = data;
    }
    private void populate(Queue enumQueue, Tree
tree)
    {
        if (tree.LeftTree != null)
        {
            populate(enumQueue, tree.LeftTree);
        }
         enumQueue.Enqueue(tree.NodeData);
         if (tree.RightTree != null)
         {
             populate(enumQueue, tree.RightTree);
         }
    }
}
This method walks the binary tree, adding the data it contains to the
queue. The algorithm used is similar to that used by the WalkTree
method in the Tree class, which is described in Chapter 17. The
main difference is that rather than appending NodeData values to a
string, the method stores these values in the queue.
8. Return to the definition of the TreeEnumerator class. In the
class declaration, hover over the text IEnumerator. On the
drop-down context menu that appears (with a lightbulb icon), click
Implement Interface Explicitly.
This action generates stubs for the methods in the IEnumerator
interface and the IEnumerator interface and adds them to the end of the
class. It also generates the Dispose method for the IDisposable interface.
Download from finelybook PI:EMAIL
644
Note The IEnumerator interface inherits from the
IEnumerator and IDisposable interfaces, which is why their
methods also appear. In fact, the only item that belongs to the
IEnumerator interface is the generic Current property.
The MoveNext and Reset methods belong to the nongeneric
IEnumerator interface. Chapter 14, “Using garbage collection and
resource management,” describes the IDisposable interface.
9. Examine the code that has been generated.
The bodies of the properties and methods contain a default
implementation that simply throws a NotImplementedException
exception. You will replace this code in the following steps.
10. Update the body of the MoveNext method and replace the throw new
NotImplementedException() statement with the code shown in
bold here:
Click here to view code image
bool IEnumerator.MoveNext()
{
     if (this.enumData == null)
     {
        this.enumData = new Queue();
        populate(this.enumData, this.currentData);
     }
     if (this.enumData.Count > 0)
     {
        this.currentItem = this.enumData.Dequeue();
        return true;
     }
     return false;
}
The purpose of the MoveNext method of an enumerator is actually
twofold. The first time it is called, it should initialize the data used by
the enumerator and advance to the first piece of data to be returned.
(Before MoveNext being called for the first time, the value returned by
the Current property is undefined and should result in an exception.) In
this case, the initialization process consists of instantiating the queue and
Download from finelybook PI:EMAIL
645
then calling the populate method to fill the queue with data extracted
from the tree.
Subsequent calls to the MoveNext method should just move through data
items until there are no more left, dequeuing items until the queue is
empty, as in this example. It is important to keep in mind that MoveNext
does not actually return data items—that is the purpose of the Current
property. All MoveNext does is update the internal state in the
enumerator (that is, the value of the currentItem variable is set to the
data item extracted from the queue) for use by the Current property,
returning true if there is a next value and false otherwise.
11. Modify the definition of the get accessor of the generic Current property
and replace the expression-bodied member with the following code
shown in bold:
Click here to view code image
TItem IEnumerator.Current
{
     get
     {
        if (this.enumData == null)
        {
          throw new InvalidOperationException("Use MoveNext
before calling Current");
     }
     return this.currentItem;
    }
}
Important Be sure to add the code to the correct implementation
of the Current property. Leave the nongeneric version,
System.Collections.IEnumerator.Current, with its default
implementation that throws a NotImplementedException exception.
The Current property examines the enumData variable to ensure that
MoveNext has been called. (This variable will be null before the first call
to MoveNext.) If this is not the case, the property throws an
Download from finelybook PI:EMAIL
646
InvalidOperationException—this is the conventional mechanism used
by .NET Framework applications to indicate that an operation cannot be
performed in the current state. If MoveNext has been called beforehand,