title:McBoost: Boosting Scalability in Malware Collection and Analysis Using
Statistical Classification of Executables
author:Roberto Perdisci and
Andrea Lanzi and
Wenke Lee
2008 Annual Computer Security Applications Conference
2008 Annual Computer Security Applications Conference
McBoost: Boosting Scalability in Malware Collection and Analysis Using
Statistical Classiﬁcation of Executables
{PI:EMAIL, PI:EMAIL, PI:EMAIL}
Roberto Perdisci1,3, Andrea Lanzi2,3, Wenke Lee3,1
1Damballa, Inc. Atlanta, GA 30308, USA
2Dip. di Informatica e Comunicazione, Universit´a degli Studi di Milano, Italy
3College of Computing, Georgia Institute of Technology, Atlanta, GA 30332, USA
Abstract
In this work, we propose Malware Collection Booster
(McBoost), a fast statistical malware detection tool that is
intended to improve the scalability of existing malware col-
lection and analysis approaches. Given a large collection of
binaries that may contain both hitherto unknown malware
and benign executables, McBoost reduces the overall time
of analysis by classifying and ﬁltering out the least suspi-
cious binaries and passing only the most suspicious ones to
a detailed binary analysis process for signature extraction.
The McBoost framework consists of a classiﬁer special-
ized in detecting whether an executable is packed or not, a
universal unpacker based on dynamic binary analysis, and
a classiﬁer specialized in distinguishing between malicious
or benign code. We developed a proof-of-concept version of
McBoost and evaluated it on 5,586 malware and 2,258 be-
nign programs. McBoost has an accuracy of 87.3%, and an
Area Under the ROC curve (AUC) equal to 0.977. Our eval-
uation also shows that McBoost reduces the overall time of
analysis to only a fraction (e.g., 13.4%) of the computation
time that would otherwise be required to analyze large sets
of mixed malicious and benign executables.
1 Introduction
Malicious executables pose a signiﬁcant threat to the In-
ternet. As a consequence of malware infection, a victim
machine may unintentionally expose sensitive information,
participate in remotely coordinated large scale attacks, be-
come a spam sender, host phishing websites, etc. Malware
analysis techniques are used for understanding the behav-
ior of malicious executables and extracting signatures use-
ful for detection and containment.
The ﬁrst step in malware analysis is collecting new mal-
ware samples. Existing malware collection tools usually
rely on honeypots [26], spam traps [14], and other passive
techniques. However, these techniques are “slow” because
they require waiting until a new malware starts propagat-
ing on a large scale before collecting a copy of it. For ex-
ample, by the time a new malware hits a honeypot it may
have already infected a large number of machines. Ac-
tively looking for malware in the Internet has been proposed
for example in [21], although in this case the search is re-
stricted to a limited number of suspicious URLs that are
considered to be responsible for drive-by malware down-
loads. Crawling P2P networks or the Web is one alterna-
tive to the more traditional honeypots and spam traps, and
may help reduce the time it takes to collect a new piece of
malware. This is true in particular for malware that spread
mainly via P2P [19, 7]. Another collection strategy may
be to use an executables sniffer, which may be deployed
at the edge of a network to “sniff” the PE (portable exe-
cutable) executables that the users of the monitored network
are downloading [22]. Considering the disadvantages of
traditional malware collection approaches described above
(e.g. honeypots and spamtraps), these alternative and more
active collection strategies are attractive because they help
reduce the time it takes to discover new malware. However,
crawling P2P networks or the Web, and “snifﬁng” executa-
bles may result in a very large collection of binaries (e.g.,
several thousands) that contains a small number of hitherto
unknown malware and a high number of benign executa-
bles. This would overwhelm most existing binary analy-
sis approaches, for example [8, 24], because they typically
need to run each executable for several minutes to under-
stand its behavior. Therefore, we need a way to quickly and
accurately classify the executables into malware or benign,
thus allowing us to ﬁlter out the least suspicious binaries
and focus the analysis on only the most suspicious ones.
Statistical classiﬁcation of executables provides a way
1063-9527/08 $25.00 © 2008 IEEE
1063-9527/08 $25.00 © 2008 IEEE
DOI 10.1109/ACSAC.2008.22
DOI 10.1109/ACSAC.2008.22
301
301
to quickly classify executables into malware or benign,
and has been explored in a number of works, for exam-
ple [17, 9, 15, 25]. In particular, n-gram analysis has been
shown to be quite successful in detecting malicious exe-
cutables. However, to the best our knowledge no previous
work on statistical malware detection using n-gram analysis
takes into account the fact that most malware (92%, accord-
ing to [4]) use executable packing techniques [18, 20] in
order to hide their malicious code. Furthermore, previous
works do not consider the fact that some benign executa-
bles also use packing techniques in order to protect them-
selves against violations of commercial licenses. We will
show in Section 3 that not taking executable packing into
account during the training of classiﬁers based on n-gram
analysis such as the one proposed in [9], for example, may
cause their classiﬁcation accuracy to degrade. In particular,
these classiﬁers may become biased in distinguishing be-
tween packed and non-packed executables, instead of cor-
rectly distinguish between malware and benign executables.
As a consequence, packed benign executables would likely
cause false positives, whereas non-packed malware may re-
main undetected.
In this paper, we propose Malware Collection Booster
(McBoost), a new fast and accurate statistical malware de-
tection tool that takes executable packing into account, and
is intended to improve the scalability of existing malware
collection and analysis approaches. Given a large collection
of binaries that may contain both hitherto unknown mal-
ware and benign executables, McBoost reduces the over-
all time of analysis by classifying and ﬁltering out the least
suspicious binaries and passing the most suspicious ones
to a detailed binary analysis process for signature extrac-
tion. Figure 1 presents an overview of McBoost. Our sys-
tem consists of three modules: A) A classiﬁer specialized
in detecting whether an executable is packed or not; B) a
universal unpacker based on dynamic binary analysis; and
C) a classiﬁer specialized in distinguishing between mali-
cious or benign code. If an executable e is deemed packed
by module A, it will be given to an external unpacker (mod-
ule B) for hidden code extraction, and then the hidden code
will be passed to module C. In case the unpacker is not able
to extract any hidden code (perhaps because e implements
strong anti-emulation techniques), e will be added to a list
of (likely) “heavily” packed executables which need to be
manually inspected (and thus will not be further analyzed
by McBoost). The executables are stored into this list along
with additional information on what caused the unpacker to
fail (e.g., time-out, application crash, malformed PE header,
etc.). On the other hand, if the executable is deemed non-
packed by module A, the code portion of the executable will
be directly given to module C. Module C will then output
the probability that the executable being tested contains ma-
licious code.
Figure 1: Overview of McBoost Classiﬁcation System.
It is worth noting that there exists evidence that more
than 50% of new malware are simply re-packed versions of
already known malware [20]. Therefore, detecting packed
malware, and then unpacking them, helps the accuracy of
classiﬁer C because the extracted hidden code will likely
be similar to malicious code seen by C during the training
phase.
We will show in Section 3 that modules A and C pro-
vide fast and accurate classiﬁcation. On the other hand,
module B performs dynamic-analysis-based universal un-
packing in a very similar way as [8], and is therefore com-
putationally expensive. However, in the case of malware
collection via P2P, Web crawling, or executable snifﬁng,
we expect the percentage of zero-day malware to be fairly
small compared to the benign executables (note that here
we assume the known malware have already been ﬁltered
out using signature-based AV-software). Given that most
benign executables are non-packed, the majority of the col-
lected executables will be quickly and accurately classiﬁed,
and be passed directly from module A to module C with-
out the need to attempt a time-consuming unpacking pro-
cess. Therefore, McBoost provides a fast way to correctly
classify and ﬁlter out most of the benign executables, thus
decreasing the workload of the tools (and humans) that are
responsible for performing further detailed binary analysis.
This makes the collection and analysis of new malware scal-
able in the presence of large sets of mixed (unknown) mal-
ware and benign executables. Without a system like Mc-
Boost this process would take too much time, because all
the collected executables would need to undergo a time-
consuming analysis, and even by using sophisticated binary
analysis tools (e.g.,
[24]) the average time needed to an-
alyze and classify each single executable is still very high
(e.g., several minutes).
Modules A and C both use n-gram analysis for differ-
ent classiﬁcation purposes, as we discuss in Section 2. We
would like to emphasize the fact that although n-gram anal-
302302
ysis for malware detection has already been used in a num-
ber of previous works [9, 15, 25], we apply n-gram analysis
in a novel way. Differently from other works, we recog-
nize that not taking into account the fact that most malware
are packed may degrade the classiﬁcation accuracy of pre-
viously proposed malware detection approaches (see Sec-
tion 3). Therefore, we propose to use n-gram analysis in
combination with heuristics approaches in order to accu-
rately distinguish between packed and non-packed executa-
bles, ﬁrst. Then, we study the effectiveness of n-gram anal-
ysis for the detection of hidden code extracted from packed
executables. The hidden code extracted using universal un-
packing may only partially include the original malicious
code, as we discuss in Section 2.2. However, we show in
Section 3 that even in this case n-gram analysis may still
allow us to detect malicious code with relatively high accu-
racy. To the best of our knowledge, this is also a new result.
We developed a proof-of-concept version of Mc-
Boost and evaluated it on 5,586 distinct known mal-
ware from the Malfease dataset (http://malfease.
oarci.net) and 2,258 benign extracted from an instal-
lation of Windows XP Home with the addition of common
user applications (e.g., WinZIP, WinAmp, AcroRead, etc.).
We obtained a classiﬁcation accuracy of 87.3% (using a de-
tection threshold equal to 0.5) and an Area Under the ROC
curve (AUC) equal to 0.977. The AUC can be interpreted as
the probability of scoring malware executables higher than
benign executables [5], and shows that our classiﬁcation ap-
proach is very promising. Our evaluation also shows that
the total time it takes for modules A and C to classify an
PE executable is as low as 1.06 seconds, on average. This
means that McBoost is able to quickly ﬁlter out the least
suspicious executables, thus reducing the number of bina-
ries that need to undergo detailed, time-consuming, binary
analysis for studying possible malicious behavior and ex-
tracting a detection signature. Therefore, McBoost reduces
the overall time of analysis to only a fraction (e.g., 13.4%)
of the computation time that would be otherwise required to
analyze large sets of mixed malicious and benign executa-
bles.
The remainder of the paper is organized as follows. We
present the details of our McBoost classiﬁcation system in
Section 2. In Section 3 we report the experimental results.
We discuss the most relevant related work in Section 4, and
then we brieﬂy conclude in Section 5.
2 McBoost’s Internals
McBoost consists of three modules, namely module A,
B, and C, as shown in Fig. 1. In this section we describe the
internals of each single module.
303303
2.1 Detecting Packed Executables
Module A performs detection of packed executables us-
ing a Multiple Classiﬁer System (MCS) [10] that combines
three classiﬁers (see Fig. 1). The ﬁrst classiﬁer is based on
a number of heuristics on the structure of the PE ﬁle (A1) as
proposed in [13]. The second classiﬁer is based on n-gram
analysis of the code portion of the executable (A2), while
the third classiﬁer is based on n-gram analysis of the entire
binary (A3). Although each single module has already high
detection accuracy (see Section 3), we combine module A1
to A2 and A3 in order to make the classiﬁcation of packed
executables even more accurate and robust against evasion.
The design and implementation of module A2 and A3,
and the MCS that combines them with A1 to improve on
the accuracy and robustness of single classiﬁers is one of
the contributions of this work.
2.1.1 Heuristics-based Classiﬁer
Module A1 performs classiﬁcation of packed vs.
non-
packed executables using a number of heuristics extracted
from the structure of PE ﬁles. We use the approach pro-
posed in [13]. We extract nine features from the PE ﬁle,
namely: 1) Number of standard sections; 2) Number of
non-standard sections; 3) Number of Executable sections;
4) Number of Readable/Writable/Executable sections; 5)
Number of entries in the IAT; 6) Entropy of the PE header;
7) Entropy of the code (i.e., executable) sections; 8) Entropy
of the data sections; 9) Entropy of the entire PE ﬁle.
A Multi-Layer Perceptron (MLP) classiﬁer that uses
these features is trained to distinguish between packed and
non-packed executables, as we describe in Section 3. We
chose to use MLP because this classiﬁcation algorithm was
shown to achieve better accuracy and generalization abil-
ity than other classiﬁcation algorithms and signature-based
detection approaches [13].
2.1.2 n-gram-based Classiﬁers
Modules A2 and A3 perform n-gram analysis of the code
section and of the entire PE ﬁle, respectively. Each PE ex-
ecutable can be seen as a binary string s. For module A2,
s represents only the code section, whereas for A3 it rep-
resents the entire ﬁle. Given a training dataset of packed
and non-packed executables, we create a dataset of binary
strings S (P) = {s(P)