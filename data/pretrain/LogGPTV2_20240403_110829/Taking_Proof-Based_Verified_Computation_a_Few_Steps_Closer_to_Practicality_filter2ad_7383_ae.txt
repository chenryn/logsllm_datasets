represent quantities by their bits (which GINGER does
only when computing inequalities). Figure 9 gives a
rough end-to-end comparison.
6.3 Scalability of the parallel implementation
To demonstrate the scalability of GINGER’s paralleliza-
tion, we run the prover using many CPU cores, many
GPUs, and many machines. We measure end-to-end la-
tency, as observed by the veriﬁer. Figure 10 summarizes
the results for various computations. In most cases, the
speedup is near-linear.
7 Related work
A substantial body of work achieves two of our goals—
it is general-purpose and practical—but it makes strong
assumptions about the servers (e.g., trusted hardware).
There is also a large body of work on protocols for
special-purpose computation. We regard this work as
orthogonal to our efforts; for a survey of this land-
scape, see [45]. Herein, we focus on approaches that are
general-purpose and unconditional.
Homomorphic encryption and secure multi-party
protocols. Homomorphic encryption (which enables
computation over ciphertext) and secure multi-party pro-
tocols (in which participants compute over private data,
revealing only the result [34, 39, 52]) provide only pri-
vacy guarantees, but one can build on them for veriﬁable
computation. For instance, the Boneh-Goh-Nissim ho-
momorphic cryptosystem [18] can be adapted to evaluate
circuits, Groth uses homomorphic commitments to pro-
duce a zero-knowledge argument protocol [33], and Ap-
plebaum et al. use secure multi-party protocols for ver-
10
ifying computations [4]. Also, Gentry’s fully homomor-
phic encryption [27] has engendered protocols for veriﬁ-
able non-interactive computation [20, 24, 26]. However,
despite striking improvements [28, 42, 47], the costs of
hiding inputs (among other expenses) prevent any of the
aforementioned veriﬁed computation schemes from get-
ting close to practical (even by our relaxed standards).
PCPs, argument systems, and interactive proofs. Ap-
plying proof systems to veriﬁable computation is stan-
dard in the theory community [5–7, 10, 15, 32, 37, 38,
41], and the asymptotics continue to improve [13, 14, 22,
43]. However, none of this work has paid much attention
to building systems.
Very recently, researchers have begun to explore using
this theory for practical veriﬁed outsourced computation.
In a recent preprint, Ben-Sasson et al. [12] investigate
when PCP protocols might be beneﬁcial for outsourcing.
Since many of the protocols require representing compu-
tations as constraints, Ben-Sasson et al. [11] study im-
proved reductions to constraints from a RAM model of
computation. And Gennaro et al. [25] give a new charac-
terization of NP to provide asymptotically efﬁcient argu-
ments without using PCPs.
However, as far as we know, only two research groups
have made serious efforts toward practical systems. Our
previous work [44, 45] built upon the efﬁcient argument
system of Ishai et al. [35]. In contrast, Cormode, Mitzen-
macher, and Thaler [21] (hereafter, CMT) built upon the
protocol of Goldwasser et al. [31], and a follow-up effort
studies a GPU-based parallel implementation [49].
Comparison of GINGER and CMT [21, 49]. We
compared three different implementations: CMT-native,
CMT-GMP, and GINGER. CMT-native refers to the code
and conﬁguration released by Thaler et al. [49]; it works
over a small ﬁeld and thereby exploits highly efﬁcient
machine arithmetic but restricts the inputs to the compu-
tation unrealistically (see Section 4.1). CMT-GMP refers
to an implementation based on CMT-native but modiﬁed
by us to use the GMP library for multi-precision arith-
metic; this allows more realistic computation sizes and
inputs, as well as rational numbers.
 0 20 40 60 80matrix multdegree-2 poly eval(compiler-output code)degree-3 poly evalm-Hamming distancebisection method(compiler-output code)speedup1 core1 core1 core1 core1 core4 cores4 cores4 cores4 cores4 cores1 GPU1 GPU1 GPU1 GPU1 GPU3 GPUs3 GPUs3 GPUs3 GPUs3 GPUs60 cores60 cores60 cores60 cores60 cores60 cores (ideal)60 cores (ideal)60 cores (ideal)60 cores (ideal)60 cores (ideal)m
256
Z
128 Q
domain component
veriﬁer
prover
network
veriﬁer
prover
network
CMT-native
40 ms
22 min
88 KB
–
–
–
CMT-GMP
0.6 s
2.5 hr
0.3 MB
260 ms
1.0 hr
1.8 MB
GINGER
0.3 s
36 min
1.1 MB
190 ms
21 min
1.4 MB
Figure 11—CMT [21] compared to GINGER, in terms of amor-
tized CPU and network costs (GINGER’s total costs are divided
by a batch size of β=5000 instances), for m × m matrix mul-
tiplication. CMT-native uses native data types but is restricted
to small problem sizes and domains. CMT-GMP uses the GMP
library for multi-precision arithmetic (as does GINGER).
We perform two experiments using m× m matrix mul-
tiplication. Our testbed is the same as in Section 6. In the
ﬁrst one, we run with m = 256 and integer inputs. For
CMT-GMP and GINGER, the inputs are 32-bit unsigned
integers, and the prime (the ﬁeld modulus) is 128 bits.
For CMT-native, the prime is 261 − 1. In the second ex-
periment, m is 128, the inputs are rational numbers (with
Na = Nb = 32; see Section 4.1), the prime is 320 bits,
and we experiment only with CMT-GMP and GINGER.
We measure total CPU time and network cost; for
CMT, we measure “network” trafﬁc by counting bytes
(the CMT veriﬁer and prover run in the same process
and hence the same machine). Each reported datum is an
average over 3 sample runs; there is little experimental
variation (less than 5% of the means).
Figure 11 depicts the results. CMT incurs a signiﬁcant
penalty when moving from native to GMP (and hence
to realistic problem sizes). Comparing CMT-GMP and
GINGER, the network and prover costs are similar (al-
though network costs for CMT reﬂect high ﬁxed over-
head for their circuit). The per-instance veriﬁer costs
are also similar, but GINGER is batch verifying whereas
CMT does not need to do so (a signiﬁcant advantage).
A qualitative comparison is as follows. On the one
hand, CMT does not require cryptography, has better
asymptotic prover and network costs, and for some com-
putations the veriﬁer does not need batching to gain from
outsourcing [49]. On the other hand, CMT applies to a
smaller set of computations: if the computation is not ef-
ﬁciently parallelizable or does not naturally map to arith-
metic circuits (e.g., it has order comparisons or condi-
tionality), then CMT in its current form will be inappli-
cable or inefﬁcient, respectively. Ultimately, GINGER and
CMT should be complementary, as one can likely ease or
eliminate some of the restrictions on CMT by incorporat-
ing the constraint formalism together with batching [48].
8 Summary and conclusion
This paper is a contribution to the emerging area of
practical PCP-based systems for unconditional veriﬁable
11
computation. GINGER has combined theoretical reﬁne-
ments (slashing query costs and network overhead); a
general computational model (including fractions and
standard program constructs) with a compiler; and a mas-
sively parallel implementation that takes advantage of
modern hardware. Together, these changes have brought
us closer to a truly deployable system. Nevertheless,
much work remains: the efﬁciency of the veriﬁer depends
on special hardware, the costs for the prover are still too
high, and looping cannot yet be handled concisely.
Acknowledgments
Detailed attention from Edmund L. Wong substantially
clariﬁed this paper. Yuval Ishai, Mike Lee, Bryan Parno,
Mark Silberstein, Chung-chieh (Ken) Shan, Sara L. Su,
Justin Thaler, and the anonymous reviewers gave useful
comments that improved this draft. The Texas Advanced
Computing Center (TACC) at UT supplied computing
resources. We thank Jane-Ellen Long, of USENIX, for
her good nature and inexhaustible patience. The research
was supported by AFOSR grant FA9550-10-1-0073 and
by NSF grants 1055057 and 1040083.
Our code and experimental conﬁgurations are avail-
able at http://www.cs.utexas.edu/pepper
References
[1] CUDA (http://developer.nvidia.com/what-cuda).
[2] Open MPI (http://www.open-mpi.org).
[3] PAPI: Performance Application Programming Interface.
[4] B. Applebaum, Y. Ishai, and E. Kushilevitz. From secrecy to
soundness: efﬁcient veriﬁcation via secure computation. In
ICALP, 2010.
[5] S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy.
Proof veriﬁcation and the hardness of approximation problems.
J. of the ACM, 45(3):501–555, May 1998.
[6] S. Arora and S. Safra. Probabilistic checking of proofs: a new
characterization of NP. J. of the ACM, 45(1):70–122, Jan. 1998.
[7] L. Babai, L. Fortnow, L. A. Levin, and M. Szegedy. Checking
computations in polylogarithmic time. In STOC, 1991.
[8] M. Bellare, D. Coppersmith, J. H˚astad, M. Kiwi, and M. Sudan.
Linearity testing in characteristic two. IEEE Transactions on
Information Theory, 42(6):1781–1795, Nov. 1996.
[9] M. Bellare, S. Goldwasser, C. Lund, and A. Russell. Efﬁcient
probabilistically checkable proofs and applications to
approximations. In STOC, 1993.
[10] M. Ben-Or, S. Goldwasser, J. Kilian, and A. Wigderson.
Multi-prover interactive proofs: how to remove intractability
assumptions. In STOC, 1988.
[11] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. Fast
reductions from RAMs to delegatable succinct constraint
satisfaction problems. Feb. 2012. Cryptology eprint 071.
[12] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. On the
concrete-efﬁciency threshold of probabilistically-checkable
proofs. ECCC, (045), Apr. 2012.
[13] E. Ben-Sasson, O. Goldreich, P. Harsha, M. Sudan, and
S. Vadhan. Robust PCPs of proximity, shorter PCPs and
applications to coding. SIAM J. on Comp., 36(4):889–974, Dec.
2006.
[14] E. Ben-Sasson and M. Sudan. Short PCPs with polylog query
[40] R. C. Merkle. Digital signature based on a conventional
complexity. SIAM J. on Comp., 38(2):551–607, May 2008.
encryption function. In CRYPTO, 1987.
[15] M. Blum and S. Kannan. Designing programs that check their
[41] S. Micali. Computationally sound proofs. SIAM J. on Comp.,
work. J. of the ACM, 42(1):269–291, 1995.
[16] M. Blum, M. Luby, and R. Rubinfeld. Self-testing/correcting
with applications to numerical problems. J. of Comp. and Sys.
Sciences, 47(3):549–595, Dec. 1993.
[17] D. Boneh and D. M. Freeman. Homomorphic signatures for
polynomial functions. In EUROCRYPT, 2011.
[18] D. Boneh, E. J. Goh, and K. Nissim. Evaluating 2-DNF
formulas on ciphertexts. In TCC, 2005.
[19] G. Brassard, D. Chaum, and C. Cr´epeau. Minimum disclosure
proofs of knowledge. J. of Comp. and Sys. Sciences,
37(2):156–189, 1988.
[20] K.-M. Chung, Y. Kalai, and S. Vadhan. Improved delegation of
computation using fully homomorphic encryption. In CRYPTO,
2010.
[21] G. Cormode, M. Mitzenmacher, and J. Thaler. Practical veriﬁed
computation with streaming interactive proofs. In ITCS, 2012.
[22] I. Dinur. The PCP theorem by gap ampliﬁcation. J. of the ACM,
54(3), June 2007.
[23] T. ElGamal. A public key cryptosystem and a signature scheme
based on discrete logarithms. IEEE Transactions on Information
Theory, 31:469–472, 1985.
[24] R. Gennaro, C. Gentry, and B. Parno. Non-interactive veriﬁable
computing: Outsourcing computation to untrusted workers. In
CRYPTO, 2010.
[25] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic
span programs and succinct NIZKs without PCPs. Apr. 2012.
Cryptology eprint 215.
[26] R. Gennaro and D. Wichs. Fully homomorphic message
authenticators. May 2012. Cryptology eprint 290.
[27] C. Gentry. A fully homomorphic encryption scheme. PhD thesis,
Stanford University, 2009.
[28] C. Gentry, S. Halevi, and N. Smart. Homomorphic evaluation of
the AES circuit. In CRYPTO, 2012.
[29] D. Goldberg. What every computer scientist should know about
ﬂoating-point arithmetic. ACM Computing Surveys, 23(1):5–48,
Mar. 1991.
[30] O. Goldreich. Foundations of Cryptography: II Basic
Applications. Cambridge University Press, 2004.
[31] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum. Delegating
computation: Interactive proofs for muggles. In STOC, 2008.
[32] S. Goldwasser, S. Micali, and C. Rackoff. The knowledge
complexity of interactive proof systems. SIAM J. on Comp.,
18(1):186–208, 1989.
[33] J. Groth. Linear algebra with sub-linear zero-knowledge
arguments. In CRYPTO, 2009.
[34] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster secure
two-party computation using garbled circuits. In USENIX
Security, 2011.
[35] Y. Ishai, E. Kushilevitz, and R. Ostrovsky. Efﬁcient arguments
without short PCPs. In Conference on Computational
Complexity (CCC), 2007.
[36] K. Jang, S. Han, S. Han, S. Moon, and K. Park. SSLShader:
Cheap SSL acceleration with commodity processors. In NSDI,
2011.