12
B. Native Code Coverage
While code coverage of the Java methods allows us to
gain insight into the high level code coverage of our dynamic
analysis system, it does not shed light on the core issue we are
interested in: how much of an app’s native code is the dynamic
analysis able to execute? To answer this question, we modiﬁed
both the Android emulator and the Android framework to
support measuring function coverage of the native code.
One technical challenge here is that the native code cov-
erage must understand not only which native libraries are
loaded by an app, but also which part of the native library
is actually executed. Thus we need to: (1) trace the executed
native functions and (2) statically determine the total number
of native functions. This will allow us to calculate the function
coverage of the native code.
To the best of our knowledge,
there is no previously
released tool to trace the execution of the native code of an app.
Android Open Source Project implements a tracing mechanism
since version 4.4. This tracing mechanism is implemented
using a kernel device called qemutrace that is part of the
goldﬁsh kernel. The kernel send information to assist
the
emulator to trace correctly the execution, e.g., the PID of the
running process each time there is a context switch, a message
that notiﬁes that a fork or an execve is executed, etc. The whole
tracing system signiﬁcantly slows down the performance of the
emulator. However, this tracing system is too general: we are
interested only in the execution of the native code of a speciﬁc
app. We need to trace only functions of loaded libraries of the
app under analysis.
For this reason, we created two ways to limit the tracing to
the interesting part only. First, we only want to trace processes
with a speciﬁc UID because each app in Android is executed
with it own UID. In addition, we are interested only in portions
of the executable memory where the native libraries have been
loaded.
To inform the emulator about the UID of the currently
executing process we leverage the existing qemutrace de-
vice. We added the UID into the message sent for each
context switch. To send the information about the map of
the memory to the emulator we cannot use the qemutrace
device, since it can only pass 32 bit integers as messages.
generation on data and insights obtained by means of dynamic
analysis, which is well-known to be incomplete and affected by
code coverage issues. In fact, dynamic analysis does not ensure
that all native code is exercised in the apps that actually use
it, and for those apps that used native code, dynamic analysis
may not have exercised all code paths in the native code.
Consequently, the policies that our tool generated might not be
complete, they might block more applications when adopted at
large-scale, and the performance overhead of isolating native
code could be higher. However, using a more-sophisticated
instrumentation tool could possibly improve the amount of
native code behavior that our system observes, or deploying
the automatically generated policies in a native sandbox with
reporting mode would help to observe the behaviors that the
policies would block.
Nonetheless, we believe this work to be a signiﬁcant ﬁrst
step in a very important direction. In fact, to the best of our
knowledge, this work is the ﬁrst, largest, and most comprehen-
sive study on how real-world applications use native code. Our
results demonstrate that it is infeasible to adopt a completely
restrictive sandboxing policy. In addition, we propose a system
to automatically generate a native code sandboxing policy
following a data-driven approach. This system could be used
by large organizations that are interested in automatically
generating a native code sandboxing policy. Furthermore, the
completeness issues could possibly be addressed by increasing
the ﬁdelity of the dynamic analysis, either through more
sophisticated analysis techniques or increased resources, or by
obtaining the actual behavior of native code in the wild, by
instrumenting real-world Android devices.
Another limitation is that our approach restricts access to
permissions from native code, but it still allows the native
code to invoke (some) Java methods. This aspect would make,
in principle, Java-only analysis more precise, but still not
completely sound, as a malicious application could introduce
hidden execution paths by invoking a native method, which,
in turn, could invoke a Java method. However, we note that
our automatically-generated policy only allows native code to
invoke a very narrow subset of Java methods deﬁned in the
Android framework (Table XVII), through which it is virtually
impossible to perform any security-sensitive operation. Thus,
our policy, although not perfect, would drastically reduce the
possibility of introducing malicious behaviors.
Lastly, we consider all the apps we obtained from Google
Play as benign, but we cannot be completely certain that there
are no malicious apps among them. The effects of having
malicious apps in our dataset vary depending on how the
malware works. In the worst case it could cause our policies
to allow some malicious actions.
IX. RELATED WORK
In this section we relate our work to the vast amount of
research published in the ﬁeld of Android security.
Large Measurement Studies. Several works have analyzed
large datasets of Android apps, but with goals that differ
from ours. Viennot et al. [37] did a large measurement study
on 1,100,000 applications crawled from the Google Play app
store. In particular, they collected meta-data and statistics taken
from the Google Play store itself. As part of their study, they
images/per_lib_coverage.pdf
Fig. 3. Per library coverage of executed functions. Horizontal axis contains
libraries name, vertical, instead contains the function coverage. For each bar
we also show the number of libraries that has been found in all executed
applications
Moreover, we also need a mechanism to extract the libraries
from the emulated system. To solve both problems we instru-
mented the Android framework. We found that the function
java.lang.Runtime.doLoad is able to intercept all the
loading operations. Our hook inside the doLoad function
blocks the loading (and the app) while syncing all the gathered
data to the external emulator. The mapping of the memory and
the PID are read from /proc/self/. The path of the loaded
library is one of the parameters of the doLoad function.
Hence, when doLoad returns, the emulator knows the address
space reserved for the new library, and the content of the native
library.
After the dynamic execution, we compute the code cover-
age using all the data gathered during the execution. We use
IDA Pro to ﬁnd all functions boundaries of libraries. Then, we
use the map of the memory to translate the virtual addresses
traced by the emulator. Next, we ﬂag all the functions whose
boundaries include at least one address of the trace. The code
coverage is then calculated.
Our tracing system slows down the execution of the apps by
around 10 times. Therefore, we only ran it on a small subset
of the apps, more speciﬁcally, we analyzed 177. The code
coverage of most libraries is less that 1%. Some small libraries,
on the other hand, were covered by 100%. Furthermore,
the average coverage was 7%. More details about executed
libraries and coverage can be seen in Figure 3.
VIII. THREATS TO VALIDITY
Our study is affected by a few limitations, which we discuss
in this section. An intrinsic limitation of the automatically-
generated security policies is that we base their automatic
13
measured the frequency with which Android applications make
use of native code components. Another important measure-
ment study has been performed by Lindorfer et al. [27]. In
their work, they analyzed 1,000,000 apps, of which 40% are
malware. To perform the analysis, the authors used Andrubis,
a publicly-available analysis system for Android apps that
combines static and dynamic analysis. When focusing on
native code, our work signiﬁcantly extends their study.
Application Analysis Systems. Several systems have been
proposed to perform behavioral analysis of Android applica-
tions based on dynamic analysis [13], [14], [30], [31], [36],
[41]. Moreover, several other works have been proposed to
identify malicious Android apps [4], [9], [23]. Our analysis
complements all these research efforts by performing a large
scale study, based on dynamic analysis, speciﬁcally focused
on native code usage.
Protection Systems. Fedler et al. [15] proposes a protection
system from root exploits by preventing apps from giving
execution permission for custom executable ﬁles and by in-
troducing a permission related to the use of the System
class. PREC [24] is a framework intended to protect Android
systems from root exploits. PREC uses two steps, learning and
enforcement. During the learning phase, the analysis generates
a model of the normal behavior for a given app. Then, during
the enforcement phase, the system makes sure that the app
does not deviate from the normal behavior. Our work has the
advantage that the generated policies can be applied to all apps,
whereas PREC generates per-app models. Hence, our results
are more general. Moreover, our analysis also monitors, in
addition to system calls, JNI function calls, Binder transactions
and calls from Java to native methods.
Native Code Isolation. Another way to protect the system
is by isolating native code. The challenge of isolating native
code components used by managed languages has been exten-
sively studied. For instance, Klinkoff et al. [26] focus on the
isolation of .NET applications, whereas Robusta [33] focuses
on the isolation of native code used by Java applications.
Recently, NativeGuard [35] proposed a similar mechanism to
isolate native code in the context of Android. Our work is
complementary to these sandboxing mechanisms and ﬁlls the
knowledge gap necessary to deﬁne security policies on the
execution of native code in Android that are both usable in real-
world applications and effective in blocking malicious behavior
of native components.
X. CONCLUSION
While allowing developers to mix Java code and na-
tive code enables developers to fully harness the computing
power of mobile devices, we believe that,
in the current
state, this feature does more harm than good and that native
code sandboxing is the correct approach to properly limit
its potentially malicious side-effects. However, a native code
sandboxing mechanism without a proper policy will never be
feasible. We hope that, in addition to shedding light on the
previously unknown native code usage of Android apps, this
paper demonstrates an approach to automatically generate an
effective and practical native code sandboxing policy.
ACKNOWLEDGMENT
This material is based upon work supported by CAPES
Foundation under Award No. BEX 12269/13-1, by NSF under
Award No. CNS-1408632, by DHS under Award No. 2009-ST-
061-CI0001, and by Secure Business Austria. Any opinions,
ﬁndings, and conclusions or recommendations expressed in
this publication are those of the author(s) and do not nec-
essarily reﬂect the views of CAPES Foundation, NSF, DHS,
or Secure Business Austria.
This material
is also based on research sponsored by
DARPA under agreement number FA8750-12-2-0101. The
U.S. Government is authorized to reproduce and distribute
reprints for Governmental purposes notwithstanding any copy-
right notation thereon. The views and conclusions contained
herein are those of the authors and should not be interpreted as
necessarily representing the ofﬁcial policies or endorsements,
either expressed or implied, of DARPA or the U.S. Govern-
ment.
REFERENCES
[1] V. Afonso, A. Bianchi, Y. Fratantonio, A. Doup´e, M. Polino, P. de Geus,
C. Kruegel, and G. Vigna, “Full version of Tables 5, 6, 7, 8, and
11.” [Online] Available: https://github.com/ucsb-seclab/android going
native.
[2] AppBrain, “Number of Available Android Applications,” [Online]
Available: http://www.appbrain.com/stats/number-of-android-apps.
[3] A. Apvrille and R. Nigam, “Obfuscation in Android Malware, and How
to Fight Back,” in Virus Bulletin, 2014.
[4] D. Arp, M. Spreitzenbarth, M. H¨ubner, H. Gascon, and K. Rieck,
“DREBIN: Effective and Explainable Detection of Android Malware
in Your Pocket,” in Proceedings of
the 21st Annual Network and
Distributed System Security Symposium (NDSS), 2014.
[5] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y. Le
Traon, D. Octeau, and P. McDaniel, “FlowDroid: Precise Context, Flow,
Field, Object-sensitive and Lifecycle-aware Taint Analysis for Android
Apps,” in Proceedings of 35th annual ACM SIGPLAN conference on
Programming Language Design and Implementation (PLDI), 2014.
[6] K. W. Y. Au, Y. F. Zhou, Z. Huang, and D. Lie, “Pscout: Analyzing the
Android Permission Speciﬁcation,” in Proceedings of the 2012 ACM
conference on Computer and Communications Security (CCS), 2012.
[7] L. Batyuk, M. Herpich, S. A. Camtepe, K. Raddatz, A.-D. Schmidt,
and S. Albayrak, “Using Static Analysis for Automatic Assessment
and Mitigation of Unwanted and Malicious Activities Within Android
Applications,” in Proceedings of the 2011 6th International Conference
on Malicious and Unwanted Software (MALWARE), 2011.
[8] A. Bittau, P. Marchenko, M. Handley, and B. Karp, “Wedge: Splitting
Applications into Reduced-Privilege Compartments,” in Proceedings
of the 5th USENIX Symposium on Networked Systems Design and
Implementation (NSDI), 2008.
I. Burguera, U. Zurutuza, and S. Nadjm-Tehrani, “Crowdroid: Behavior-
based Malware Detection System for Android,” in Proceedings of the
1st ACM workshop on Security and privacy in smartphones and mobile
devices (SPSM), 2011.
[9]
[10] V. Chebyshev and R. Unuchek,
Available:
[Online]
2013,”
kaspersky-security-bulletin/58335/mobile-malware-evolution-2013/,
Feb. 2014.
“Mobile Malware Evolution:
http://securelist.com/analysis/
[11] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, “Analyzing Inter-
Application Communication in Android,” in Proceedings of the 9th
international conference on Mobile systems, applications, and services
(MobiSys), 2011.
[12] A. Desnos, “Androguard: Reverse Engineering, Malware and Goodware
Analysis of Android Applications... and More (Ninja!),” [Online] Avail-
able: https://code.google.com/p/androguard/.
[13] Droidbox, “Android Application Sandbox,” [Online] Available: https:
//code.google.com/p/droidbox/.
14
[14] W. Enck, P. Gilbert, B. Chun, L. Cox, J. Jung, P. McDaniel, and
A. Sheth, “TaintDroid: an Information-ﬂow Tracking System for Re-
altime Privacy Monitoring on Smartphones,” in Proceedings of the 9th
USENIX Symposium on Operating Systems Design and Implementation
(OSDI), 2010.
[15] R. Fedler, M. Kulicke, and J. Sch¨utte, “Native Code Execution Control
for Attack Mitigation on Android,” in Proceedings of the Third ACM
workshop on Security and privacy in smartphones & mobile devices
(SPSM), 2013.
[16] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner, “Android
Permissions Demystiﬁed,” in Proceedings of the 18th ACM conference
on Computer and Communications Security (CCS), 2011.
[17] A. P. Fuchs, A. Chaudhuri, and J. S. Foster, “SCanDroid: Automated
Security Certiﬁcation of Android Applications,” Manuscript, Univ. of
Maryland, http://www. cs. umd. edu/˜ avik/projects/scandroidascaa,
2009.
[18] C. Gibler, J. Crussel, J. Erickson, and H. Chen, “AndroidLeaks: De-
tecting Privacy Leaks in Android Applications,” Tech. rep., UC Davis,
Tech. Rep., 2011.
[19] Google, “Android NDK,” [Online] Available: https://developer.android.
com/tools/sdk/ndk/index.html.
[20] ——, “UI/Application Exerciser Monkey — Android Developers,” [On-
line] Available: http://developer.android.com/tools/help/monkey.html.
[21] R. Gordon, Essential JNI: Java Native Interface. Prentice-Hall, Inc.,
1998.
[22] M. Grace, Y. Zhou, Z. Wang, and X. Jiang, “Systematic Detection of
Capability Leaks in Stock Android Smartphones,” in Proceedings of
the 19th Annual Network and Distributed System Security Symposium
(NDSS), 2012.
[23] M. Grace, Y. Zhou, Q. Zhang, S. Zou, and X. Jiang, “Riskranker:
Scalable and Accurate Zero-Day Android Malware Detection,” in
Proceedings of the 10th international conference on Mobile systems,
applications, and services (MobiSys), 2012.
[24] T.-H. Ho, D. Dean, X. Gu, and W. Enck, “PREC: Practical Root Exploit
Containment for Android Devices,” in Proceedings of the 4th ACM
conference on Data and application security and privacy (CODASPY),
2014.
IDC Corporate, “IDC: Smartphone OS Market Share 2014, 2013,
2012, and 2011,” [Online] Available: http://www.idc.com/prodserv/
smartphone-os-market-share.jsp.
[25]
[26] P. Klinkoff, E. Kirda, C. Kruegel, and G. Vigna, “Extending .NET
Security to Unmanaged Code,” International Journal of Information
Security, 2007.
[27] M. Lindorfer, M. Neugschwandtner, L. Weichselbaum, Y. Fratantonio,
V. van der Veen, and C. Platzer, “Andrubis - 1,000,000 Apps Later:
A View on Current Android Malware Behaviors,” in Proceedings of
the 3rd International Workshop on Building Analysis Datasets and
Gathering Experience Returns for Security (BADGERS), 2014.
[28] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang, “CHEX: Statically Vetting
Android Apps for Component Hijacking Vulnerabilities,” in Proceed-
ings of the 2012 ACM Conference on Computer and Communications
Security (CCS), 2012.
[29] C. Mann and A. Starostin, “A Framework for Static Detection of Privacy
Leaks in Android Applications,” in Proceedings of the 27th Annual
ACM Symposium on Applied Computing (SAC), 2012.
[30] G. Portokalidis, P. Homburg, K. Anagnostakis, and H. Bos, “Paranoid
Android: Versatile Protection for Smartphones,” in Proceedings of the
26th Annual Computer Security Applications Conference (ACSAC),
2010, pp. 347–356.
[31] C. Qian, X. Luo, Y. Shao, and A. T. Chan, “On Tracking Information
Flows through JNI in Android Applications,” in Proceedings of the 44th
Annual IEEE/IFIP International Conference on Dependable Systems
and Networks (DSN), 2014.
[32] V. Rastogi, Y. Chen, and W. Enck, “AppsPlayground: Automatic Se-
curity Analysis of Smartphone Applications,” in Proceedings of the
third ACM conference on Data and application security and privacy
(CODASPY), 2013.
J. Siefers, G. Tan, and G. Morrisett, “Robusta: Taming the Native Beast
of the JVM,” in Proceedings of the 17th ACM conference on Computer
and Communications Security (CCS), 2010.
[33]
[34] A. D.
. Space, “Local Root Vulnerability in Android 4.4.2,”
[Online] Available: http://blog.cassidiancybersecurity.com/post/2014/
06/Android-4.4.3,-or-ﬁxing-an-old-local-root.
[35] M. Sun and G. Tan, “NativeGuard: Protecting Android Applications
from Third-Party Native Libraries,” in Proceedings of the 2014 ACM
conference on Security and privacy in wireless & mobile networks
(WiSec), 2014.
[36] K. Tam, S. J. Khan, A. Fattori, and L. Cavallaro, “CopperDroid:
Automatic Reconstruction of Android Malware Behaviors,” in Pro-
ceedings of the 22nd Annual Network and Distributed System Security
Symposium (NDSS), 2015.
[37] N. Viennot, E. Garcia, and J. Nieh, “A Measurement Study of Google
Play,” in Proceedings of the 2014 ACM SIGMETRICS International
Conference on Measurement and Modeling of Computer Systems (SIG-
METRICS), 2014.
[38] C. Warren, “Google Play Hits 1 Million Apps,” [Online] Available:
http://mashable.com/2013/07/24/google-play-1-million/, Jul. 2013.
[39] F. Wei, S. Roy, X. Ou et al., “Amandroid: A Precise and General
Inter-component Data Flow Analysis Framework for Security Vetting of
Android Apps,” in Proceedings of the 2014 ACM SIGSAC Conference
on Computer and Communications Security (CCS), 2014.
[40] L. Weichselbaum, M. Neugschwandtner, M. Lindorfer, Y. Fratantonio,
V. van der Veen, and C. Platzer, “ANDRUBIS: Android Malware Under
The Magnifying Glass,” Vienna University of Technology, Tech. Rep.
TR-ISECLAB-0414-001, 2014.
[41] L. K. Yan and H. Yin, “Droidscope: Seamlessly reconstructing the os
and dalvik semantic views for dynamic android malware analysis,” in
Proceedings of the 21st USENIX Security Symposium, 2012.
[42] Z. Yang and M. Yang, “Leakminer: Detect Information Leakage on
Android with Static Taint Analysis,” in Proceedings of the 2012 Third
World Congress on Software Engineering (WCSE), 2012.
[43] Z. Zhao and F. C. C. Osono, ““TrustDroidTM”: Preventing the Use of
SmartPhones for Information Leaking in Corporate Networks Through
the Use of Static Analysis Taint Tracking,” in Proceedings of the 2012
7th International Conference on Malicious and Unwanted Software
(MALWARE), 2012.
[44] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang, “Hey, You, Get Off of My
Market: Detecting Malicious Apps in Ofﬁcial and Alternative Android
Markets,” in Proceedings of the 19th Annual Network and Distributed
System Security Symposium (NDSS), 2012.
[45] Y. Zhou and X. Jiang, “Detecting Passive Content Leaks and Pollution
in Android Applications,” in Proceedings of the 20th Annual Network
and Distributed System Security Symposium (NDSS), 2013.
15