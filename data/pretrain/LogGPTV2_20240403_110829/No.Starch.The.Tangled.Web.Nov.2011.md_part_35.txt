therace conditions outlined in Chapter 14, and they seemto be lacking
in other ways, as shown in Figure 17-1.
l
Figure 17-1: A seriously confusing prompt in Firefox. The prompt shown in the upper
area of the browser window was generated by the browser in response to a call to
the registerProtocolHandler(...) API, with the protocol name set to “doing really awe-
some stuff” and application name set to “Firefox (mozilla.org)”. This particular example
is harmless, but more sinister abuse is within reach.
Address bar manipulation
The newly introduced HTML5 history.pushState(...) API,2 supported by
Firefox, WebKit, and Opera, permits the currently displayed document
to change the contents of the address bar to any other same-origin URL,
without actually triggering a page transition normally associated with this
step. The API offers a superior alternative to the widespread abuse of
location.hash to store application state. Interestingly, despite its simplicity,
it has already led to a fair number of interesting security bugs. For example,
some implementations briefly allowed not only the top-level document
256 Chapter 17
but also any dodgy third-party frames to change the top-level URL shown
in the address bar, and they permitted origins such as about:blank to put
largely unconstrained gibberish in the URL field.
Binary HTTP
SPDY3 (“Speedy”) is a simple, encrypted drop-in replacement for HTTP
that preserves the protocol’s key design principles (including the layout
and function of most headers). At the same time, it mini- mizes the over-
head associated with delivering concurrent requests or with the parsing
of text-based requests and response data. The protocol is currently sup-
ported only in Chrome, and other than select Google services, it is not
commonly encountered on the Web. It may be coming to Firefox soon,
too, however.
HTTP-less networking
WebSocket4 is a still-evolving API designed for negotiating largely
unconstrained, bidirectional TCP streams for when the transactional
nature of TCP gets in the way (e.g., in the case of a low-latency chat appli-
cation). The protocol is bootstrapped using a keyed challenge-response
handshake, which looks sort of like HTTP and which is (quite remarkably)
impossible to spoof by merely exploiting a header-splitting flaw in the des-
tination site. Following a successful handshake, raw data may be exchanged
bidirectionally within the resulting long-lived TCP connection, with each
message enveloped inside a simple protocol frame. The mechanism is
supported in WebKit and is probably coming soon to Firefox.
P2P networking
WebRTC5 is a proposed set of APIs and network protocols designed to facil-
itate the discovery of and communication with other browsers without the
need for a centralized server infrastructure. The primary use case for such
a protocol is the implementation of IP telephony and video-conferencing
features within web apps. No stable browser support is available yet.
Offline applications
Cache manifests6 are a relatively simple way for aweb server to instruct
the browser that copies of certain documents should be stored indefi-
nitely and reused whenever the client appears to have no network con-
nectivity. In conjunction with client-side storage mechanisms such as
localStorage (Chapter 9), this allows certain self-sufficient JavaScript appli-
cations to be used in offline mode. Offline operation is supported in Fire-
fox, the WebKit browser, and Opera. As with localStorage, the persistent
nature of this mechanism could exacerbate the long-term consequences
of visiting an untrusted network.
Better cookies
Cake7 is a now-expired proposal drafted by Adam Barth that aims to cre-
ate a more lightweight and secure alternative to HTTP cookies: one ori-
gin-bound, browser-generated nonce for every destination site. A more
current but incomplete proposal appears to flirt with normal but origin-
based cookies as an alternative. Neither approach is available in any
browser today.
Other Browser Mechanisms of Note 257
Content-Level Features
The proposals outlined in this section aim to enable new classes of web appli-
cations to be built on top of HTML and JavaScript.
Client-side databases
Several APIs for creating and manipulating locally stored databases have
been proposed over the years, including the notorious WebSQL API,8
which would have brought the famously dangerous SQL syntax to client-
side JavaScript. The WebSQL proposal was ditched in favor of a more sen-
sible IndexedDB design,9 which offers a clean API without serialized queries
and has a security model comparable to that of localStorage—but not until
WebSQL support had shipped ina couple of browsers. Meanwhile, the
new API has shipped in Chrome and is expected to appear in Firefox.
Background processes
The Worker API,10 available in Firefox, WebKit, and Opera, permits the
creation of background JavaScript processes to perform computationally
expensive tasks without having to worry about blocking the browser UI.
Each worker runs in an isolated environment that lacks the usual window
or document DOM and may communicate with its creator asynchronously
through the postMessage(...) API. Dedicated workers are directly reachable
only by their creator, while shared workers may be “attached” to several dif-
ferent sites at any given time. (Persistent workers, which would run indepen-
dently of any sustained demand for their services, were proposed early on
but then dropped.) The concept of worker threads raises some periph-
eral DoS concerns but otherwise poses no apparent security risks.
Geolocation discovery
The navigator.geolocation.getCurrentPosition(...) API11 permits any website
to request information about the physical location of the client device,
subject to a user’s (largely hijackable) consent. The computed geoloca-
tion data may be derived from GPS information on a system with a suit-
able hardware module, or it may be looked up based on the names of
nearby wireless access points, cell towers, and so forth. The API is sup-
ported in all major browsers except for Internet Explorer.
Device orientation
A nonrestricted event-driven DeviceOrientation API12 allows websites to
read back the orientation of the device, based on accelerometer data.
This API, which is probably geared toward mobile gaming, is available in
Firefox, WebKit, and Opera on systems equipped with the appropriate
hardware. Two researchers at the University of California, Davis have
recently demonstrated a fatal flaw: On smartphones, minute movements
of the device may be used to reliably reconstruct on-screen keyboard
input, including passwords entered on unrelated websites.13
Page prerendering
This experimental feature in Chrome allows pages to be prefetched in
anticipation of the user following a particular link, and it permits the entire
HTML document to be prerendered in a hidden tab14 and momentarily
258 Chapter 17
revealed once the predicted navigation action takes place. The mech-
anism has some interesting browser security consequences if the pre-
rendered page turns out to be malicious. The implementation in Chrome
is careful to defer any disruptive actions until the tab is revealed, but mis-
takes will be very easy to make across all browser codebases.
Navigation timing
Several complementary APIs, currently available only in Chrome, permit
certain types of navigation, including cross-domain page loads, to be very
accurately benchmarked from client-side JavaScript.15 This interface is
designed to allow site owners to identify obvious performance bottle-
necks, as experienced by a typical visitor. The API allows some privacy-
related information to be collected by profiling the time needed to load
certain third-party content, but because the same attack is possible in
many other ways (for example with onload handlers on subresources),
that probably does not matter much.
I/O Interfaces
The features listed below offer new input and output capabilities to web-
based scripts.
UI notifications
Notification and window.notifications16 APIs allow the creation of text-only or
HTML-based, always-on-top pop-ups in the corner of the screen, allowing
select web applications to gently notify users of important developments
(such as a new mail message). User consent to receiving notifications is
required on a per-site basis, limiting the risk of abuse. Nevertheless, care
must be taken to properly communicate the origin of the tiny notification
window and any dialogs or prompts it subsequently creates, an aspect that
took some time to refine. The API is available only in WebKit today.
Full-screen mode
Several proposals have been circulated to allow JavaScript to maximize
the current browser window and hide all the browser chrome. This func-
tionality is essential to tasks such as viewing presentations or watching
movies, but it is obviously very dangerous from the security standpoint:
Once in control of the entire screen, any malicious page may draw a fake
browser window with a fake address bar. So far, no specific implementa-
tion seems to be available for review. An early-stage proposal for mouse
cursor locking is being discussed, too.
Media capture
A proposed suite of navigator.device.capture APIs17 has been postulated for
giving websites access to webcam and microphone data. Obvious security
and privacy concerns arise around this mechanism, especially around
the resilience of any associated security prompts with respect to race con-
dition attacks. The API has no stable browser support today.
Other Browser Mechanisms of Note 259
C O M M O N W E B
V U L N E R A B I L I T I E S
Up until this point, we have paid little attention to
the taxonomy of common web vulnerabilities. Gaining
insight into the underlying mechanics of web applica-
tions is far more important than memorizing several
thousand random and often unnecessary terms; nomen-
clature such as improper restriction of operations within the
bounds of a memory buffer (Common Weakness Enumer-
ation) or insecure direct object references (Open Web Appli-
cation Security Project) finds no place in a reasonable
conversation—and rightly so.
Nevertheless, the industry has come up with a handful of reasonably
precise phrases that security researchers use every day. Having thoroughly
discussed the inner workings of the browser, it seems useful to recap and
highlight the terminology the average reader is likely to see.
Vulnerabilities Specific to Web Applications
The terms outlined in this section are unique to the technologies used on
the Web and often have no immediate counterparts in the world of “tradi-
tional” application security.
Cross-site request forgery (XSRF, CSRF)
A vulnerability caused by the failure to verify that a particular state-
changing HTTP request received by the server-side portion of the web
application was initiated from the expected client-side origin. This flaw
permits any third-party website loaded in the browser to perform actions
on behalf of the victim.
 See Chapter 4 for a more detailed discussion of XSRF.
Cross-site script inclusion (XSSI)
A flaw caused by the failure to secure sensitive JSON-like responses
against being loaded on third-party sites via . User-specific
information in the response may be leaked to attackers.
 See Chapter 6 for an overview of the problem (and potential fixes).
Cross-site scripting (XSS)
Insufficient input validation or output escaping can allow an attacker to
plant his own HTML markup or scripts on a vulnerable site. The injected
scripts will have access to the entirety of the targeted web application
and, in many cases, to HTTP cookies stored by the client.
The qualifier reflected refers to cases where the injected string is
simply a result of incorrectly echoing back a portion of the request,
whereas stored or persistent refers to a situation where the payload takes a
more complex route. DOM-based may be used to denote that the vulner-
ability is triggered by the behavior of the client-side portion of the web
app (i.e., JavaScript).
 See Chapter 4 for common XSS vectors in HTML documents.
 See Chapter 6 for an overview of DOM-based XSS risks.
 See Chapter 13 for XSS vectors associated with content sniffing.
 See Chapter 9 for a discussion of the normal security model for JS code.
Header injection (response splitting)
Insufficient escaping of newlines (or equivalent characters) in HTTP
responses generated by the server-side portion of a web application.
Thisbehavior will typically lead to XSS, browser, or proxy cache poison-
ing and more.
 See Chapter 3 for a detailed discussion of the flaw.
Mixed content
A catch-all name for loading non-HTTPS subresources on HTTPS pages.
In the case of scripts and applets, this behavior makes the application
trivially vulnerable to active attackers, particularly on open wireless
262 Chapter 18
networks (at cafés, airports, and so on), and undoes almost all benefits of
HTTPS. The consequences of mixed content bugs with stylesheets, fonts,
images, or frames are usually also fairly serious but more constrained.
 See Chapters 4 and 8 for content-specific precautions on HTTPS sites.
 See Chapter 11 for an overview of mixed-content handling rules.
Open redirection
A term used to refer to applications that perform HTTP- or script-based
requests to user-supplied URLs without constraining the possible desti-
nations in any meaningful way. Open redirection is not advisable and
may be exploitable in some scenarios, but it is typically not particularly
dangerous by itself.
 See Chapter 10 for cases where unconstrained redirection may lead to XSS.
Referer leakage
Accidental disclosure of a sensitive URL by embedding an off-site sub-
resource or providing an off-site link. Any security- or privacy-relevant
data encoded in the URL of the parent document will be leaked in the
Referer header, with the exception of the fragment identifier.
 See Chapter 3 for an overview of the Referer logic.
Problems to Keep in Mind in Web Application Design
The problems outlined in this section are an unavoidable circumstance of
doing business on the Internet and must be properly accounted for when
designing or implementing new web apps.
Cache poisoning
The possibility of long-term pollution of the browser cache (or any
interim proxies) with a fabricated, malicious version of the targeted
webapplication. Encrypted web applications may be targeted due to
response-splitting vulnerabilities. For nonencrypted traffic, active net-
work attackers may be able to modify the responses received by the
requestor, too.
 See Chapter 3 for an overview of HTTP-caching behaviors.
Clickjacking
The possibility of framing or otherwise decorating or obscuring a por-
tion of another web application so that the victim, when interacting with
the attacker’s site, is not aware that individual clicks or keystrokes are
delivered to the other site, resulting in undesirable actions being taken
on behalf of the user.
 See Chapter 11 for a discussion of clickjacking and related UI issues.
Common Web Vulnerabilities 263
Content and character set sniffing
Describes the possibility that the browser will ignore any authoritative
content type or character set information provided by the server and
interpret the returned document incorrectly.
 See Chapter 13 for a discussion of content-sniffing logic.
 See Chapters 4 and 8 for scenarios where Content-Type data is ignored.
Cookie forcing (or cookie injection)
The possibility of blindly injecting HTTP cookies into the context of an
otherwise impenetrable web application due to issues in how the mecha-
nism is designed and implemented in modern browsers. Cookie injec-
tion is of particular concern to HTTPS applications. (Cookie stuffing is a
less common term referring specifically to maliciously deleting cookies
belonging to another application by overflowing the cookie jar.)
 See Chapter 9 for more information on cookie scoping.
 See Chapter 3 for a general discussion of the operation of HTTP cookies.
Denial-of-service (DoS) attacks
A broad term denoting any opportunities for the attacker to bring down
a browser or server or otherwise make the use of a particular targeted
application significantly more difficult.
 See Chapter 14 for an overview of DoS considerations with JavaScript.
Framebusting
The possibility of a framed page navigating the top-level document to a
new URL without having to satisfy same-origin checks. The behavior may
be exploited for phishing attacks or simply for petty mischief.
 See Chapter 11 for this and other frame navigation quirks.
HTTP downgrade
The ability for active attackers to prevent the user from reaching an
HTTPS version of a particular site or to downgrade an existing HTTPS
session to HTTP.
 See Chapter 3 for an overview of HTTPS.
 See Chapter 16 for Strict Transport Security, a proposed solution to the
problem.
Network fenceposts
The prospect of websites on the Internet leveraging the browser to inter-
act with destinations not directly accessible to the attacker, for example,
with the systems on a victim’s internal network. Such attacks can be per-
formed blindly, or (with the help of attacks such as DNS rebinding) the
attacker may be able to see responses to all requests.
 See Chapter 12 for an overview of non-SOP boundaries in a browser.
 See Chapter 15 for Internet Explorer zone model, a potential approach to
thisrisk.
264 Chapter 18
NOTE Beware non-buzzword bugs! Not all vulnerabilities have catchy names. Web developers
should be wary of many other implementation and design issues that are outside the
scope of this book but that can nevertheless bite hard. Examples include weak pseudo-