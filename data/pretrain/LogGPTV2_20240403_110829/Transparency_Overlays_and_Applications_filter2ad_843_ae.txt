As depicted in Section 2, Bitcoin has three actors in the system Sys: a sender Sender, a receiver Receiver,
and a miner Miner. The sender and the miner must participate in the Log protocol to enter transactions into
the log (although really this can be done by only the miner, after it has collected all relevant transactions),
and the receiver participates in the CheckEntry protocol to check that the transaction in which it should
be receiving bitcoins is in the log. Our transparency overlay for Bitcoin then instantiates GenEventSet as
follows:
Receiver Sender(tx) Miner(headold, hgt, txset)
return ε
return ε
tx
txset ← txset ∪ {tx}
r←− Mine(headold, txset)
head
return (head, hgt, txset)
An event is a transaction tx, which must have a certain structure (i.e., lists of input and output addresses)
and satisfy certain requirements (i.e., that is does not represent double-spending). A set of events eventset
is a block, which contains not only a list of transactions txset but also a hash head, a pointer headprev to the
previous block, and a height hgt; combining events in an event set also allows us to impose the required notion
of timing, which is the block height hgt. By combining GenEventSet with the modiﬁed protocols described
in Section 4.4, we can thus apply Theorem 4.5 to get a secure basic transparency overlay in the setting of
Bitcoin.
6.2 Further security implications
By applying a transparency overlay to Bitcoin, we have provided a method for achieving provable transparency
guarantees in this setting. We have also achieved (in a manner similarly observed by Miller et al. [27], although
they did not provide any security guarantees) a much more eﬃcient version of the system: senders and receivers
5https://blockchain.info/charts/blocks-size
15
/
/
Bitcoin
Na¨ıve overlay CT-like overlay
Hashing
Set of miners
Broadcast
Provable security
decentralized
yes
yes
no
yes
hybrid*
yes
yes*
no
distributed
no
yes
Table 1: The diﬀerent tradeoﬀs between Bitcoin, our na¨ıve overlay, and a “CT-like” overlay in which log servers
completely replace miners. Our na¨ıve solution provides the same openness that Bitcoin has for miners but also
provable security guarantees for those who make (optional) use of distributed log servers, while our CT-like solution
requires trust in the set of log servers but achieves both provable security and signiﬁcantly better eﬃciency.
now store nothing (or, if the auditor collapses into the users as discussed in Section 5.3 for CT, they store
a snapshot), as compared to the entire blockchain or set of block headers that they were required to store
previously. While this goal was of course already achievable by Bitcoin senders and receivers using web
solutions (i.e., storing their bitcoins in an online wallet), our system is the ﬁrst to achieve this goal with any
provable security guarantees, thus minimizing the trust that such users must place in any third party.
Our analysis also has implications beyond users’ storage of the blockchain. To go beyond our initial
attempt at an overlay (which we dub the “na¨ıve overlay” in Table 1), one might observe that the miner
provides no additional value beyond that of the log server: whereas in CT the CA was necessary to provide
a signature (and more generally is assumed to perform external functions such as verifying the owner of a
website), here the miner just collates the transactions and sends them to the log server. By having senders
contact log servers directly, one could therefore eliminate entirely the role of mining without any adverse
eﬀects on security. Thus, if users are willing to make the trust assumptions necessary for our transparency
overlay — namely, to assume that some honest majority of a distributed set of log servers provide the correct
response about the inclusion of a transaction — then the system can collapse into a distributed structure (the
“CT-like overlay” in Table 1) in which no energy is expended to produce the ledger, and users have minimal
storage requirements. Moreover, if users communicate directly with the log server, then we could add a signed
acknowledgment from the log server that would allow us to satisfy accountability. Interestingly, this solution
closely resembles the recent RSCoin proposal [14] (but with our additional consistency and non-frameability
guarantees), which achieves linear scaling in transaction throughput; this provides additional validation and
suggests that this distributed approach presents an attractive compromise between the two settings.
7 Conclusions and Open Problems
In this paper, we initiated a formal study of transparency overlays by providing deﬁnitions and a generic secure
construction of this new primitive. To demonstrate the broad applicability of our generic formalization, we
proved that Certiﬁcate Transparency (CT) is a secure transparency overlay, and presented a Bitcoin-based
transparency overlay that achieves provable notions of security and signiﬁcantly reduces the storage costs of
regular Bitcoin users. Our comparison reveals that in any settings where distributed trust is possible (i.e.,
one is willing to trust any set of known participants), Bitcoin can collapse into CT and the need for both
mining and the storage of the blockchain disappears. On the other hand, if one is not willing to trust anyone,
then on a certain level these requirements seem inevitable.
While our constructions provide provably secure properties concerning integrity, it is not clear how our
transparency overlay could provide this same value to any system in which a meaningful notion of privacy is
required. It is thus an interesting open problem to explore the interaction between transparency and privacy,
and in particular to provide a transparency overlay that preserves any privacy guarantees of the underlying
system.
Acknowledgments
Sarah Meiklejohn is supported in part by EPSRC Grant EP/M029026/1.
References
[1] A. Anagnostopoulos, M. T. Goodrich, and R. Tamassia. Persistent authenticated dictionaries and their
applications. In G. I. Davida and Y. Frankel, editors, ISC 2001, volume 2200 of LNCS, pages 379–393,
16
Malaga, Spain, Oct. 1–3, 2001. Springer, Berlin, Germany.
[2] M. Andrychowicz and S. Dziembowski. Pow-based distributed cryptography with no trusted setup. In
Proceedings of Crypto 2015, 2015.
[3] M. Andrychowicz, S. Dziembowski, D. Malinowski, and L. Mazurek. Secure multiparty computations
on Bitcoin. In Proceedings of the IEEE Symposium on Security and Privacy, 2014.
[4] D. Basin, C. Cremers, T. H.-J. Kim, A. Perrig, R. Sasse, and P. Szalachowski. ARPKI: Attack Resilient
Public-Key Infrastructure. In Proceedings of ACM CCS 2014, pages 382–393, 2014.
[5] M. Bellare and S. Keelveedhi. Interactive message-locked encryption and secure deduplication. In
Proceedings of PKC 2015, volume 9020 of LNCS, pages 516–538, 2015.
[6] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Zerocash:
Decentralized anonymous payments from Bitcoin. In Proceedings of the IEEE Symposium on Security
and Privacy, 2014.
[7] J. C. Benaloh and M. de Mare. One-way accumulators: A decentralized alternative to digital sinatures
(extended abstract). In T. Helleseth, editor, EUROCRYPT’93, volume 765 of LNCS, pages 274–285,
Lofthus, Norway, May 23–27, 1993. Springer, Berlin, Germany.
[8] I. Bentov and R. Kumaresan. How to use bitcoin to design fair protocols. In J. A. Garay and
R. Gennaro, editors, CRYPTO 2014, Part II, volume 8617 of LNCS, pages 421–439, Santa Barbara,
CA, USA, Aug. 17–21, 2014. Springer, Berlin, Germany.
[9] J. Bonneau, A. Miller, J. Clark, A. Narayanan, J. A. Kroll, and E. W. Felten. Research perspectives
and challenges for Bitcoin and cryptocurrencies. In Proceedings of the IEEE Symposium on Security
and Privacy, 2015.
[10] P. Bright. Independent Iranian hacker claims responsibility for Comodo hack, Mar. 2011.
[11] J. Camenisch, M. Kohlweiss, and C. Soriente. An accumulator based on bilinear maps and eﬃcient
revocation for anonymous credentials. In S. Jarecki and G. Tsudik, editors, PKC 2009, volume 5443 of
LNCS, pages 481–500, Irvine, CA, USA, Mar. 18–20, 2009. Springer, Berlin, Germany.
[12] J. Camenisch and A. Lysyanskaya. Dynamic accumulators and application to eﬃcient revocation of
anonymous credentials. In M. Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 61–76, Santa
Barbara, CA, USA, Aug. 18–22, 2002. Springer, Berlin, Germany.
[13] S. Crosby and D. Wallach. Eﬃcient data structures for tamper-evident logging. In Proceedings of the
18th USENIX Security Symposium, 2009.
[14] G. Danezis and S. Meiklejohn. Centrally banked cryptocurrencies. In Proceedings of NDSS 2016, 2016.
[15] B. Dowling, F. G¨unther, U. Herath, and D. Stebila. Secure logging schemes and Certiﬁcate
Transparency. IACR Cryptology ePrint Archive, Report 2016/452, 2016.
http://eprint.iacr.org/2016/452.pdf.
[16] C. Fromknecht, D. Velicanu, and S. Yakoubov. A decentralized public key infrastructure with identity
retention. IACR Cryptology ePrint Archive, Report 2014/803, 2014.
http://eprint.iacr.org/2014/803.pdf.
[17] J. Garay, A. Kiayias, and N. Leonardos. The Bitcoin backbone protocol: Analysis and applications. In
Proceedings of Eurocrypt 2015, 2015.
[18] C. Garman, M. Green, and I. Miers. Decentralized anonymous credentials. In Proceedings of the NDSS
Symposium 2014, 2014.
[19] D. Goodin. Fraudulent Google credential found in the wild, Aug. 2011.
[20] T. H.-J. Kim, L.-S. Huang, A. Perrig, C. Jackson, and V. Gligor. Accountable key infrastructure
(AKI): a proposal for a public-key validation infrastructure. In Proceedings of WWW 2013, pages
679–690, 2013.
[21] B. Laurie, A. Langley, and E. Kasper. Certiﬁcate transparency, 2013.
17
[22] J. Leyden. Inside ‘Operation Black Tulip’: DigiNotar hack analysed, Sept. 2011.
[23] H. Lipmaa. Secure accumulators from euclidean rings without trusted setup. In F. Bao, P. Samarati,
and J. Zhou, editors, ACNS 12, volume 7341 of LNCS, pages 224–240, Singapore, June 26–29, 2012.
Springer, Berlin, Germany.
[24] M. S. Melara, A. Blankstein, J. Bonneau, E. W. Felten, and M. J. Freedman. CONIKS: Bringing key
transparency to end users. In Proceedings of USENIX Security 2015, 2015.
[25] J. Menn. Key Internet operator VeriSign hit by hackers, Feb. 2012.
[26] R. C. Merkle. A certiﬁed digital signature. In G. Brassard, editor, CRYPTO’89, volume 435 of LNCS,
pages 218–238, Santa Barbara, CA, USA, Aug. 20–24, 1989. Springer, Berlin, Germany.
[27] A. Miller, M. Hicks, J. Katz, and E. Shi. Authenticated data structures, generically. In Proceedings of
POPL 2014, 2014.
[28] S. Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System, 2008. bitcoin.org/bitcoin.pdf.
[29] Nasdaq. Nasdaq launches enterprise-wide blockchain technology initiative, May 2015.
[30] D. O’Leary, V. D’Agostino, S. R. Re, J. Burney, and A. Hoﬀman. Method and system for processing
Internet payments using the electronic funds transfer network, Nov. 2013.
[31] C. Papamanthou, E. Shi, R. Tamassia, and K. Yi. Streaming authenticated data structures. In
T. Johansson and P. Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 353–370,
Athens, Greece, May 26–30, 2013. Springer, Berlin, Germany.
[32] C. Papamanthou, R. Tamassia, and N. Triandopoulos. Authenticated hash tables. In P. Ning, P. F.
Syverson, and S. Jha, editors, ACM CCS 08, pages 437–448, Alexandria, Virginia, USA, Oct. 27–31,
2008. ACM Press.
[33] M. D. Ryan. Enhanced certiﬁcate transparency and end-to-end encrypted mail. In Proceedings of
NDSS 2014, 2014.
A Interactive Protocols
We present a formal description of an interactive protocol between multiple participants, as modiﬁed from
the deﬁnitions given by Bellare and Keelveedhi [5]. Consider a protocol Prot with a set of participants
Parties, where each participant is invoked at most q times; then the protocol can be represented as a tuple
(Prot[party, j])party∈Parties,j∈[q]. Each algorithm in this tuple is given as input the security parameter 1λ, a value
a, and a message m ∈ {0, 1}∗, and produces as output a value a(cid:48), a message m(cid:48), an indicator party of the next
algorithm to run, and an output out, where out = ⊥ indicates that the participant has not yet terminated.
When all participants have terminated, the protocol has terminated. In the case of a stateful participant, the
values a and a(cid:48) are replaced with stateparty.
The execution of a protocol is captured by Run, which takes a list of inputs inputs and returns a list of
outputs outputs; the algorithm is described below.
Run(1λ, Prot, Parties, inputs)
T ← ∅; party ← Parties[1]; m ← ε; outputs ← ∅
for party ∈ Parties do a[party, 1] ← inputs[party]; round[party] ← 1
while T (cid:54)= Parties do
if party ∈ T return ⊥
i ← round[party]
(a[party, i + 1], m, party(cid:48), out) r←− Prot[party, i](1λ, a[party, i], m)
if (out (cid:54)= ⊥) T ← T ∪ {party}; outputs[party] ← out
round[party] ← i + 1; party ← party(cid:48)
return outputs
Finally, the transcript (i.e., the messages exchanged during the protocol) is captured by Msgs, which takes
a list of inputs and returns a matrix of messages; the algorithm is described below.
18
Msgs(1λ, Prot, Parties, inputs)
T ← ∅; party ← Parties[1]; m ← ε; M ← ε
for party ∈ Parties do a[party, 1] ← inputs[party]; round[party] ← 1
while T (cid:54)= Parties do
if party ∈ T return ⊥
i ← round[party]
(a[party, i + 1], m, party(cid:48), out) r←− Prot[party, i](1λ, a[party, i], m)
if (out (cid:54)= ⊥) T ← T ∪ {party}
round[party] ← i + 1; party ← party(cid:48); M [party][round[party]] ← m(cid:48)
return M
B Hash-Based Dynamic List Commitments
In Section 3.2, we presented the formalization of a dynamic list commitment (DLC), and deﬁned its algorithms
and desired security properties abstractly. To prove that such structures exist, we present two constructions
here and prove their security.
B.1 An instantiation based on hash chains
Brieﬂy, our ﬁrst construction is essentially a rolling hash chain: the commitment to a list is an iterated hash
of its elements (i.e., a hash of the ﬁrst element is hashed with the second element, etc.), and as new elements
are appended they are folded into the hash. Proofs are simple and mainly involve revealing certain parts of
the list and committing to the rest.
Com(list)
h ← ε
for all 1 ≤ i ≤ len(list)
c ← (h, len(list))
return c
h ← H(h(cid:107)list[i])
Append(list∆, cold)
(h, (cid:96)) ← cold
for all 1 ≤ i ≤ len(list∆)
h ← H(h(cid:107)list∆[i])
c ← (h, (cid:96) + len(list∆))
return c
CheckCom(c, list)
return (c = Com(list))
ProveAppend(cold, cnew, list)
(hold, (cid:96)old) ← cold
if cnew (cid:54)= Append(list[(cid:96)old + 1 :], cold)