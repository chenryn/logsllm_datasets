## Page 157
●144—第1章神奇的SOL
好了，就算我们盯着有问题的表发牢骚，它也不会变得好起来。如果
不能改变表的结构，那么接受这一点并继续想其他办法才是有意义的。
在使用这种模拟数组的表时遇到的需求一般都是下面这两种形式
1.查询“都是1”的行。
2.查询“至少有一个9”的行。
EXISTS谓词主要用于进行“行方向”的量化，而对于这个间题，我
们需要进行“列方向”的量化。虽然这里不能用EXISTS，但是实际上可
以像下面这样解答。
-“列方向”的全称量化：不优雅的解答
SSLSCT *
MHERE co11 = 1
AND co12 = 1
AND co110 = 1/
这种解法不是很优雅（但是也没有错），还可以改进。只有10列的话
还可以忍受，如果增加到50列、100列，那么这种SQL语句就会变得太
长而让人难以阅读。但是不用担心，SQL语言其实还准备了一个谓词，帮
助我们进行“列方向”的量化。
注0
“列方向”的全称量化：优雅的解答
此经代病在 PostgreSOL 中运行时
会报错。要相成功运行，霉务代
SELECT +
码量后一行括号内的字物改为
FROM AarrayTb1
raluee (eo1.1) , (eoL.2) , (eo1.3) 
WERE 1 = ALL (col1, co12, co13, col4, col5, col6, col7, col8, col9, col10) ;
[eo14) , leol.5) , leoL4) , leo1.7)
leo18) , leo1a) , leo1.101°。
—译者注
C
1
1
1
1
1
1
1
1
直接翻译成了SQL语句，既简洁又很好理解。
反过来，如果想表达“至少有一个9”这样的存在量化命题，可以使
用ALL的反义谓词ANY。
---
## Page 158
18 EXISTS 谓闻的用法
145 
注0
在 PostgneSOL 中运行时，请鲁考
-列方向的存在量化（1)
P144 期注@
泽者注
SELECT *
PRCM ArrayTb1
KERE 9 = ANY (ool1, col2, col3, col4, col5, col6, co17, col8, col9, col10l
key
9
或者也可以使用I谓词代替ANY。
-列方向的存在量化[2）
SELECT *
KHERE 9 IN (co11, co12, co13, co14, co15, col6, co17, col8, co19, co110) ;
我们一般都像co11IN[1，2，3]这样来使用IN谓词，左边是列名，
右边是值的列表。可能有人不太习惯上面这种左右颠倒了的写法，但是其
实这种写法也是被允许的。
但是，如果左边不是具体值而是NULL，这种写法就不行了。
注图
-查测全是NULL的行：错误的解法
在 PostgneSOL中运行时，请鲁考
P144 脚注 @
译者注
SELECT +
WERRE MOLL
 AIL (coll, co12, co13, co14, col5, col6, col7, cole, co19, col14) ;
不管表里的数据是什么样的，这条SQL语句的查询结果都是空。这
是因为，ALL 谓词会被解释成 co11-NULL AND col2-NULL AND
注
col10-NULL。这种情况下，我们需要使用 COALESCE 函数，
如果不明白。请退同1-3节复习
下。
-查询全是ILL的行：正确的解法
SELECT *
FROK ArrayTb1
KHEFE
CCALESCE(col1, co12, col3, co14, co15, co1f, col7, co18, co19, col10) Is BUL;
....
....
这样，“列方向”的量化也就不足为惧了。
---
## Page 159
146—第1章神奇的SOL
本节小结
从集合论的角度来看，SQL具备的能力配得上它面向集合语言的称号。
而从谓词逻辑的角度来看，我们又能发现它作为一种函数式语言的特点。
在函数式语言中，高阶函数发挥着很大的作用。同样，在SQL中，
EXISTS谓词也是很重要的。如果能灵活运用EXISTS，那么可以说就突破
了中级水平关卡中的一个。下一节准备了很多会用到EXISTS的例题，到
时请结合本节学习到的基础知识挑战一下。
下面是本节要点。
1.SQL中的谓词指的是返回真值的函数。
2.EXISTS与其他谓词不同，接受的参数是集合。
3.因此EXISTS可以看成是一种高阶函数。
4.SQL中没有与全称量词相当的谓词，可以使用NOTEXISTS代替。
如果大家想了解更多关于EXISTS谓词的内容，请参考下面的资料。
1.JoeCelko，《SQL解惑（第2版）（人民邮电出版杜，2008年）
该书收录了很多关于EXISTS和 NOT EXISTS的应用例题。例如，关于
关于EXISTS在差集运算中的应用，请参考“谜题57间隔—版本1”
2.C.J.Date，《深度探索关系数据库：实践者的关系理论》（电子工业出版
杜，2007年）
关于SQL中量词的内容参考该书附录A.5.
注0
3.户田山和久，《逻辑学的创立》（名古屋大学出版会，2000年）
原书名为“理学<]类
无中文版。
—泽者注
关于谓词逻辑的量词，请参考第5章“扩展逻辑学的对象语言”。
练习题
练习题1-8-1：数组表——行结构表的情况
在“对列进行量化：查询全是1的行”部分，我们讨论了对模拟数组
---
## Page 160
18EXISTS 请罚的用法
147
的表按“列方向”量化的方法。接下来我们将正文中的表改成行结构的表，
并通过这张表来练习一下。“i”列表示数组的下标，因此主键是“key，i”。
ArrayTbl2
val
10
10
个实体对应10行数据，所以上面的表省略了一部分以方便显示。A、
B、C的元素和正文中是一样的。key为A的行val 全都是NULL，key为
B的行中只有i=I的行 val 是3，其他的都是 nULL，key为 C的行 val 全
部都是1。
请思考一下如何从这张表中选出val全是1的key。答案是C。这次，
我们要按“行方向”进行全称量化，所以使用EXISTS谓词。严格
来说，这个问题还是相当复杂的，如果能注意到问题在哪里，那你就是高
级水平了。
在使用EXISTS解答之后，请再试试看有没有别的解法。这个间题有
很多种解法，非常有趣。
---
## Page 161
148—第1章神奇的SQL
练习题1-8-2：使用ALL谓词表达全称量化
全称量化除了可以用NOTEXISTS表达，也可以用ALL谓词。如果使
用ALL谓词，那么不借助双重否定也可以，所以写出来的代码会更简洁。
的 SQL语句。
练习题1-8-3：求质数
最后再练习一个有趣的数学谜题。质数是自然数的一种，我们在学校
里都学过。它的定义如下。
除了1和它自身之外不存在正约数（也就是说，除了1和它自身之
外不能被任何自然数除尽）且大于1的自然数
虽然质数的定义很简单，但是由于它有很多有趣的性质，所以长期以
来都吸引着很多人来研究。
那么请用SQL求一下质数。因为质数有无限多个，所以这里把范围
限定在100以内。我们先准备一张存储了1～100的所有自然数的表
Numbers（这张表的简单生成方法将在下一节介绍）。
Numbers
Lm
98
99
100
如果把100以内的质数从小到大排列出来，那么就是下面这些。请用
SQL求出它们
2, 3, 5, 7, 11, 13, 17, **, 83, 89, 97
---
## Page 162
19用 SOL 处理数列 
149
用SQL处理数列
灵活使用请词运辑
SQL语言在处理数据时默认地都不考虑顺序。因此，如果遇到了需要考虑数据顺序的情况，处理方
法与面向过程语言及文件系统的处理方法很不一样。本节将以数列为例介绍一下SQL的处理方法，并且
挖掘出隐藏在背后的基本原理。
写在前面
关系模型的数据结构里，并没有“顺序”这一概念。因此，基于它实
现的关系数据库中的表和视图的行和列也必然没有顺序。同样地，处理有
序集合也并非SQL的直接用途
因此，SQL处理有序集合的方法，与原本就以处理顺序为目的的面向
过程语言及文件系统的处理方法在性质上是不同的。尽管性质不同，但其
背后都有坚实的理论基础。用一句话概括就是，集合和谓词一特别是前
本节将介绍使用SQL处理数列或日期等有序数据的方法。我们不只
会列举出解决间题的Tips，还会尽可能地挖掘出各个解法背后共同的基本
原理，从而整理出能够用来解决新间题的一般性的方法。
生成连续编号
我们来思考一下如何使用SQL生成连续编号。目前很多数据库实现
都包含了序列对象（sequence object），如果要按照顺序一个一个地获取连
续编号，可以使用这个方法。但是，如何只用一条SQL就能生成任意长
的连续编号序列呢？例如生成0～99这100个连续编号。有一些依赖数
据库实现的方法，比如 coNN&cT BY（Oracle）、WITH子句（DB2、SQL
Server），但是这里要求必须使用不依赖数据库实现的方法来实现。
在思考这道例题之前，请先思考下面这样一道谜题。
---
## Page 163
150—第1章神奇的SOL
谜题：00-99的100个数中，0,1,2,，9这10个数字分别出现
了多少次？
对于只有一位的数字，我们在前面加上0，比如01、07。请不要使用
纸笔，只在脑海中思考一下。开始吧。
算出来了吗？正确答案是，每个数字都出现了20次。例如，我们数
一下出现在十位和个位上的数字1一共有多少个。我们会发现，十位上的
数字1有10个，个位上的数字1也有10个。11的十位和个位都是1，但
是11本来就包括两个1，所以数字1并没有被重复计数。
■00-99的数中，数字0-9各出现了20次
00
01
02
03
04
05
06
07
08
60
10
11
12
13
14
16
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
39
40
41
42
43
44
45
46
47
4B
49
50
51
52
53
55
56
57
58
59
60
81
62
63
64
65
66
67
6B
69
70
71
72
73
74
75
76
77
78
79