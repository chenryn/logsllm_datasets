和排序规则必须要相兼容。
的字符集。
Table:mytbl
BINARY(40)
CHAR(10)
CHAR(40) CHARACTER SET 1atin2,
CHAR(10)
binary（40）DEFAULT
char(10) CHARACTER
char(40)
char(10)
Table:
，因此那些字符集属性对它们不适用。c2 列的排序规则是latin2_general_ci，
binary(40)
char(10)
char(40)
char(10)
CREATE TABLEmytb1
CHARACTER SET
1Collation
NULL
latinl_germanl_ci
latin2_general_ci
utf8_general_ci
SET
NULL
latinl
latin2 DEFAULT NULL,
。例如，对于字符集latin2，排序规则可以使月
1 COLLATE latin1_germanl_ci DEFAULT NULL
因为没有给出表选项COLLATION，所以默认的
YES
YES
YES
Null IKeyI Default l...
YES
，则表明它与表的默认字符集相同。如果
3.2MySQL数据类型
NULL
NULL
NULL
NULL
153
用
---
## Page 174
3.2.5.6选择字符串数据类型
在3.2.3节描述了在某个列定义没有包含DEFAULT子句时，MySQL所使用的默认值赋值规则。
限制。
认为它包含的是非空值。如果想让所有字符串值全部为非空，则必须在应用程序里实施这样的
过，把一个字符串列声明为NOTNULL，并不意味着它不能存储空字符串（即··）。在MySQL
集信息的字符串列。
讨论的那样发挥作用。
列定义为相应的二进制串类型。在下面几对列定义里，每一对里的那两条语句都是等价的：
使在任何低层级没有显示指定字符集，这一搜索过程也肯定会在到达数据库级别之后终止。
到它找到某个定义的字符集为止，然后将它用于该列。数据库始终有一个默认字符集，因此即
如果以前没有为数据库显式指定字符集，那么数据库的字符集将沿用服务器的。
性的情况，因为MySQL可以根据排序规则名确定使用哪一种字符集。
154
，空值与没有值是有区别的。因此，千万不要因为某个字符串列声明成 NOT NULL，就错误地
也可以使用DEFAULT子句，为除 BLOB 和TEXT类型外的其他字符串数据类型指定默认值。
型了。
如果把 binary 字符集赋值为表选项，那么它将应用到所有在其定义里没有指定任何字符
任何字符串类型都能使用通用属性 NULL或NOT NULL。如果没有指定，则默认为 NULL。不
也就是说，MySQL在确定列的字符集时，会试着向上搜索可能指定字符集的各个层级，直
（1）这些值是要表示为字符数据，还是二进制数据？如果答案是字符数据，则选择非二进制
在为字符串列选择数据类型时，
对于字符列定义的属性，MySQL还提供了多种简写形式。
如果为某个二进制串列指定了CHARACTER SETbinary，那么它将被忽略，因为该类型已
C3BLOB
C3 TEXT CHARACTER SET binary
c2 VARCHAR(10) CHARACTER SET binary
C1 CHAR(10) CHARACTER SET binary
(3）否则，把数据库的字符集作为表的默认字符集，该字符集还将成为列的默认字符集。
(2）否则，如果表的定义里有字符集选项，那么使用这个字符集。
（1）如果列的定义里指定了字符集，那么使用这个字符集。这里包括只给出COLLATON属
口又
UNICODE属性是CHARACTERSETUCS2的简写。
ASCII属性是CHARACTERSETlatin1的简写。
如果为某个二进制串列指定了BINARY，那么它将被忽略，因为该类型已经是二进制类
1BINARY(10)
C3
C1 CHAR(10) BINARY
是等效的：
字符集的二进制排序规则。例如，某个表的默认字符集为latin1，则以下这些定义
对于非二进制串列、ENUM 列或 SET 列，如果指定 BINARY 属性，则等同于在指定该列
VARBINARY(10)
第3章数据类型
CHAR(10)
CHAR(10)
CHARACTER SET latin1 COLLATE latinl_bin
CHARACTER SET latinl BINARY
，请认真考虑以下几个问题。
---
## Page 175
TEXT,BLOB
BINARY
MySQL 如何处理各种字符串数据类型在存储和检索数据时的尾部填充问题。
或加密数据时，这一点非常关键，因为它们的编码方法可能会导致尾部空格。表3-11展示了
二进制串，而选用BLOB
格（对二进制数据类型，具体值为字节OxOO），那么应该选用TEXT或VARCHAR列来存放非
所期望的任何顺序让这些值进行排序。
类型会非常有用。对 ENUM值的排序依据的是列定义里那些枚举值的排列顺序，因此可以按你
度的类型。
符串上，效果是一样的)：
面的比较操作会区分大小写（COLLATE 运算符可以放在左边的字符串上，也可以放在右边的字
VARCHAR,
更改排序规则。例如，如果 mycol 是一个使用latin1 字符集的 CHAR 列，则可以选择
规则要与你最常执行的比较类型相对应。对于其他类型的比较，则可以利用COLLATE运算符来
CHAR
种不同的字符串。
种不区分大小写的排序规则，如latinl_swedish_ci，那么它们将被认为是相同的。如果使）
认为是不同的。假设，字符串'mysql′、‘MySQL'和'MYSQL'都是latin1字符集。如果使用某
分大小写的排序规则在比较两个字符时，使用的是该种排序规则特有的字符顺序——它不一
或区分大小写的排序规则。二进制排序规则在比较两个字符时，使用的是它们的数值编码。
与
区分大小写，则应该选用一种不区分大小写的排序规则。否则，应该选用一种二进制排序规则
字符，与字符集和排序规是相关联的。
串类型最为合适。如果答案是二进制数据，则选用二进制串类型。
进制排序规则latin1_bin或某种区分大小写的排序规则latin1_general_cs，则它们是
与字符编码的大小顺序相同。对于这两种情况，给定字符的小写和大写版本在比较操作中会
启用 SQL模式 PAD_CHAR_TO_FULL_LENGTH，可以让检索出来的CHAR 列值保留尾部空格。
（5）尾部的填充值很重要吗？如果要求数据必须原样存人和取出，不能增加和移除尾部的空
如果需要使用到的列里既有区分大小写的比较，又有不区分大小写的比较，则使用的排序
非二进制串值在比较和排序时是否区分大小写，受制于为它们指定的排序规则。如果不想
（2）比较操作需要区分大小写吗？如果是，则应该选用一种非二进制串类型，因为这些存储
如果字符串值是一个有限集合，并且想按照某种非字母表顺序对它们进行排序，那么ENUM
（4）列的取值总是从固定的某些值里选取吗？如果是，则ENUM或SET可能是最好的选择。
（3）想要少占用存储空间吗？如果是，则可以选用一种可变长度的类型，而不要选用固定长
myCOlCOLLATE
当需要区分大小写的比较时，可以使用排序规则latinl_general_cs 或latin1_bin。
mycol=ABC'
col
VARBINARY
数据类型
COLLATE
1
'ABC
COLLATE latinl_bin
latinl_bin =
或 VARBINARY 列来存放二进制串。当想要存储压缩数据、散列数据
表3-11处理字符串数据类型的填充值
不处理
不处理
填充0x00
填充空格
存储
不处理
不处理
不处理
去掉
检索
尾部填充无变化
尾部填充无变化
检索值会保留尾部填充
检索值无尾部填充
3.2MySQL数据类型
结果
155
风
用
被
---
## Page 176
各种日期/时间类型的零值情况。如果想要把非法值处理为错误，并拒绝接受，则需要设置相应
小数秒精度
类型名称
数秒部分的类型所具有的额外存储空间要求。
许的小数位数分别为3位和6位：
type_name为 TIME、DATETIME 或 TIMESTAMP，fsp 为小数秒精度。例如，下面的 TIME 列允
了在MySQL5.6.4里对小数秒的额外支持。（对于5.6.4之前的版本，可以将小数秒部分忽略掉。
和YEAR。在MySQL5.6版本里，对这些类型进行了多项重要的改进。
fsp值的取值范围必须为0~6。如果未给定，
3.2.6
5，6
3，4
YEAR
TIMESTAMP
DATETIME
TIME
DATE
156
当为某种日期/时间类型插入非法值时，该类型会把它存储为一个“零”值。表3-15列出了
2
表3-13展示的是每一种时态数据类型的存储空间要求。表3-14展示的是那些声明中带有小
t2TIME(6)
如果要声明包含小数秒部分的时态类型列，
表3-12列出了这些时态数据类型，以及每种类型的合法取值范围。这些范围同时也反映出
MySQL提供了多种存储时态（与时间相关的)值的类型：DATE、TIME、DATETIME、TIMESTAMP
t1 TIME(3)
YEAR
TIMESTAMP
DATETIME
口MySQL5.6.6丢弃了对YEAR(2)的支持，取而代之的是允许创建像YEAR(4)那样的列。
口对于数据类型TIME、DATETIME和TIMESTAMP，MySQL 5.6.4增加了对小数秒的支持。
TIME
DATE
口
TIMESTAMP列，并且也可用于DATETIME列。
MySQL5.6.5引入了扩展支持：自动把当前时间戳作为初始值并进行更新。
这些类型现在允许的可选小数部分多达6位（微秒）精度。
时态（日期/时间）数据类型
类型名称
数据类型
1字节
4字节
8字节
3字节
3字节
存储要求（5.6.4以前的版本）
1901~2155
1970-01-01 00:00:01[.000000]~2038-01-19 03:14:07[.999999]
1000-01-0100:00:00[.000000]~9999-12-3123:59:59[.999999]
1000-01-01*~'9999-12-31
表3-13时态数据类型的存储空间要求
表3-14小数秒部分的存储空间要求
表3-12时态数据类型的取值范围
3字节
2字节
1字节
0字节
存储要求
，则默认为0。更多相关信息请参考3.2.6.5节。
则需要把定义写成 type_name( fsp)，其中，
取值范围
存储要求（5.6.4及以后版本）
1字节
4字节+fsp的存储要求
5字节+fsp的存储要求
3字节+fsp的存储要求
3字节
，在以前的版
---
## Page 177
干的部分去掉：
反方向的转换也同样有效。如果把DATETIME值赋值给DATE或TIME列，那么 MySQL 会把不相
信息请参考3.2.6.6节。
代表世纪、年、月、日、时、分、秒和微秒。对于MySQL5.6.4之前的版本，TIME和DATETIME
'CCYY-MM-DD hh:mm:Ss[.uuuuuu]`，其中的CC、YY、MM、DD、hh、mm、ss和 uuuuuu分别
间的组合值。这3种类型值的格式分别是CCYY-MM-DD'
3.2.6.1DATE、TIME和DATATIME数据类型
格式的日期值。例如，mytbl表拥有一个日期列date_col，你可以像下面那样插入各个值：
象的样子有所不同。此时，可以借助于STR_TO_DATE（）函数，把非ISO格式的字符串转换为ISO
一月-日”。
位数的年份，并且对于小于10的月和日，不用提供前导数字0。不过，这些值的顺序必须为“年
和TIME_FORMAT（）函数来显示各种格式的日期和时间。
年12月3日将被表示为'2015-12-03"。为满足检索显示要求，可以使用DATE_FORMAT（）函数
/时间类型列的默认值。