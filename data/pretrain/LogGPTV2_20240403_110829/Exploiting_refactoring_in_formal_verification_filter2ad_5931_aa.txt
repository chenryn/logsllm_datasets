title:Exploiting refactoring in formal verification
author:Xiang Yin and
John C. Knight and
Westley Weimer
978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
53
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:35:32 UTC from IEEE Xplore.  Restrictions apply. 
AbstractIn previous work, we introduced Echo, a newapproach to the formal verification of the functionalcorrectness of software. Part of what makes Echo prac-tical is a technique called verification refactoring. Theprogram to be verified is mechanically refactored spe-cifically to facilitate verification. After refactoring, theprogram is documented with low-level annotations,and a specification is extracted mechanically. Proofsthat the semantics of the refactored program are equiv-alent to those of the original program, that the codeconforms to the annotations, and that the extractedspecification implies the program’s original specifica-tion constitute the verification argument. In this paper,we discuss verification refactoring and illustrate it witha case study of the verification of an optimized imple-mentation of the Advanced Encryption Standard (AES)against its official specification. We compare the prac-ticality of verification using refactoring with tradi-tional correctness proofs and refinement, and weassess its efficacy using seeded defects.1.IntroductionDeveloping software that is sufficiently depend-able for critical applications is a difficult challenge. Adesirable technology for helping to meet that challengeis formal verification. Unfortunately, although formalverification has proven effective, it is not widely used.In part, this is because of pragmatic difficulties.In previous work, we introduced the Echoapproach to formal verification[14, 17]. The goal thatwe have for Echo is to make formal verification ofsoftware more practical. We seek an approach thatworks seamlessly with existing software developmenttechniques, that can be applied routinely and with rea-sonable effort, and that requires only average skill.By formal verification we mean the establishmentof a proof based on logical inference (as opposed tomodel checking) that a given program is a correctimplementation of a given specification. Differentaspects of a specification are sometimes dealt with sep-arately in formal verification. For example, verificationof functionality is often separated from verification oftiming in real-time software. Our focus in this paper ison verification of functionality.A factor that frequently limits formal verificationof functionality is the complexity of the subject soft-ware. Efforts to build software that is compact, effi-cient, and highly functional tend to produce softwaresystems that, in principle, could be verified, but forwhich the human effort involved and the detail man-agement required make formal verification either unat-tractive or infeasible.To deal with this problem, Echo includes a mecha-nism that we refer to as verification refactoring. Theconcept is to refactor software that was developed byconventional means using semantics-preserving trans-formations to produce a functionally equivalent ver-sion for which formal verification is practical. Thetransformations that are applied are selected solely tofacilitate the major verification proofs and each isproven to be semantics preserving.In this paper, we discuss the concept and mecha-nism of verification refactoring. As part of the refactor-ing process, we introduce the use of softwarecomplexity metrics as a tool for guiding the refactoringprocess. We present preliminary assessment data froma case study of the verification of an optimized imple-mentation of the Advanced Encryption Standard (AES)against its official specification. We also present theresults of an experiment in which we seeded defectsinto the implementation to determine the difficultydevelopers might face when locating defects that causeformal verification to fail.2.Existing Approaches to VerificationExisting approaches to verification fall basicallyinto three categories: correctness proofs, refinement,and model checking and static analysis. Correctness proof, for example the weakest pre-condition approach, tries to establish the theorem thatExploiting Refactoring in Formal VerificationXiang Yin, John Knight, Westley WeimerDepartment of Computer Science, University of Virginia{xyin,knight,weimer}@cs.virginia.edu978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
54
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:35:32 UTC from IEEE Xplore.  Restrictions apply. 
when a program’s precondition is satisfied, its postcon-dition will be satisfied after execution. The main diffi-culty that arises with it is complexity. Althoughmachine assistance has been developed, the details caneasily overwhelm whatever machine resources areavailable, even for relatively small programs. The issueis not just the cumulative detail for the program, butalso the complexity of individual predicates associatedwith elaborate or intricate source statements.Refinement based approaches such as the BMethod[1] have been created in response to practicaldifficulties with correctness proofs. Software develop-ment by refinement involves the transformation of anabstract specification to a concrete implementation bya series of refinement transformations. The output ofeach transformation is proved to imply the input.Creating a proof along with the program to whichit applies is a laudable goal. However, the goal restrictsthe exploration of alternatives during software devel-opment and leads to the following limitations:•Many existing software development techniquescannot be used because software development isconstrained by the simultaneous proof development.•If changes to an existing program are required tomeet performance goals, the whole refinement pathneeds to be revisited so as to update the proof.These limitations essentially make refinementapproaches either impractical or undesirable for thevast majority of software developments.To achieve necessary levels of assurance for cru-cial applications, testing is usually not feasible, and somechanical analysis, where possible, is an attractivealternative. In addition to correctness proof and refine-ment, several other verification techniques have beendeveloped, such as model checking and static analysis,to try to facilitate mechanical verification. Althoughsuch techniques scale quite well and have been appliedsuccessfully, their analysis targets only certain proper-ties. For crucial applications, functional verification ishighly desirable.3.The Echo Verification ApproachWe present a brief summary of the Echo approach.Further details are available elsewhere[14, 17].At the heart of Echo verification is a process thatwe refer to as reverse synthesis in which a high-level,abstract specification (that we refer to as the extractedspecification) is synthesized from a low-level, detailedspecification of a system. Verification then involvestwo proofs: (1) the implementation proof, a proof thatthe source code implements the low-level specificationcorrectly; and (2) the implication proof, a proof thatthe extracted specification implies the original systemspecification from which the software was built. Eachof these proofs is either generated automatically ormechanically checked, and each can be tackled withseparate specialized techniques and notations.The Echo approach imposes no restrictions onhow software is built except that development has tostart with a formal system specification, and develop-ers have to create the low-level specification docu-menting the source code. There are no limitations ondesign or implementation techniques nor on notationsthat can be used. The present instantiation of Echouses: (1) PVS [12] to document the system specifica-tion and the extracted specification; (2) the SPARKsubset of Ada[3] for the source program; and (3) theSPARK Ada annotation language to document the low-level specification. In the current instantiation, theproof that the extracted specification implies the sys-tem specification is created using the PVS theoremprover, and the proof that the low-level specification isimplemented by the source code is created by theSPARK Ada tools. The extracted specification is cre-ated by custom tools.4.Motivation for Verification RefactoringInformally, by verification refactoring we meanthe transformation of a program in such a way that thefunctional semantics of the program (but not necessar-ily the temporal semantics) are preserved and verifica-tion is facilitated. The reverse synthesis process inEcho makes extensive use of verification refactoring,and it is a critical part of the way in which Echo ismade more broadly applicable. In this section, we dis-cuss the motivation for verification refactoring in termsof the difficulties that it helps to circumvent in the twoEcho proofs.Significant effort in software development goesinto making sure that the software is adequately effi-cient. The result of this effort is careful treatment ofspecial cases, compact data structures and efficientalgorithms, with the inevitable introduction of com-plexity into the control- and data-flow graphs. Much ofthe difficulty in formal verification results from thecomplexity of the source program. One of the reasonsfor the use of verification refactoring is to reduce thiscomplexity.A second reason for the use of verification refac-toring is to align the structure of the extracted specifi-cation with the structure of the system specification.This alignment permits the implication proof to bestructured as a series of lemmas and allows an efficient978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
55