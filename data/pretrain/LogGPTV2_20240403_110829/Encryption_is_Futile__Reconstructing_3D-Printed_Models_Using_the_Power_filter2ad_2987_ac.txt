4.3 Reversals and Error Correction
The largest issue to overcome in this algorithm is handling mal-
formed segments of the trace. Because of the motors’ internal struc-
ture, there are only two valid firing orders that they can perform,
and we can only reconstruct motion that exhibits this behavior (see
Section 3 for details). The firing orders are associated with forward
and backward movement, and the motor controller switches be-
tween them to execute a reversal. Figure 9 illustrates this behavior.
Figure 9: A reversal captured in the trace. Peaks are anno-
tated A, B, C, or D to indicate the firing order. Note how the
order reverses at 130.41s.
As a result of the difficulties discussed in Section 3, the trace
contains both false-negative and false-positive peaks. Our observa-
tion shows that many of these occur around reversals or dwells, or
during periods of inactivity. Either type of invalid peak is incredibly
likely to create an invalid firing order4. Until these are corrected,
it is not possible to accurately reconstruct motion. Further, if a
section is recognized as correct but not accurate to the actual motor
behavior, the reconstructed motion will drift: our estimate of the
printhead position will accumulate error based on the difference
between reconstruction and reality.
We attempt to correct these errors by first segmenting the trace
into sections with valid firing orders and sections with invalid
firing orders. The valid sections are processed according to the
normal logic of motor operation. For invalid sections, contextual
information is gathered and saved alongside the section in a list.
This list is processed by a heuristic solver, which attempts to find
the best weighted reconstruction for that sections by adding and
deleting peaks. The best solutions are applied to the trace.
4.4 Segmentation into Good and Bad Sections
With all peaks recognized, our approach next identifies the firing
order on each axis. The initial synchronization of our traces occurs
on a long, linear, multiaxial move immediately before the print.
This ensures there is a long enough section of consistent movement
on every axis to recognize the firing order dynamically.
The pseudocode in Figure 10 details the process of identifying
the firing order. Identifying the firing order from the data, rather
than using a hard-coded order makes the algorithmic approach
independent of the physical instrumentation, such as which wire is
clamped by which probe. The firing order for an axis is “locked in”
after the first 16 consistent peaks have been detected. This firing
order is maintained for the remainder of the print, although it may
be inverted when reversals occur.
Next, the algorithm scans across the list of peaks, comparing
each in sequence to the firing order. It recognizes three cases: valid
forward motion, valid reverse motion, and invalid firing orders.
The pseudocode in Figure 11 outlines the process. As in the trace
diagram of Figure 9, if the last peak to fire was, for example, B,
then the next peak can be valid if it is on phases A or C. One
phase represents forward motion, the other represents a reversal,
4Peak errors, much like parity error checking, always produce firing order errors in
sections with only one bad peak. However, sections with two consecutive bad peaks
can produce valid firing orders that are nonetheless not accurate to motor movements.
130.32130.35130.38130.41130.44130.47110011A    B    C    D   A    B   C      B    A  D  C  B    A      D 140Encryption is Futile
a x i s P e a k s = getPeaks ( a x i s )
I n i t i a l i z e
/ /
o r d e r b u f f e r
int FOBuffer [ 4 ] = a x i s P e a k s [ 0 : 3 ]
f i r i n g
p r e d i c t i o n C o u n t = 0
while p r e d i c t i o n C o u n t  goodPeaksNeeded :
/ / C l o s e o u t bad s e c t i o n .
endBound = FindEndOfBadSection ( )
S a v e B a d S e c t i o n I n f o ( o r i g i n a l F O B u f f e r , mustReverse ,
b a d O r d e r Se c t i o n s . append ( b a d S e c t i o n )
b a d S e c t i o n = NULL
startBound , endBound )
e l i f nextPeak == p r e d i c t R e v e r s a l ( FOBuffer , peakIndex ) :
r e v e r s e B u f f e r ( FOBuffer )
i f b a d S e c t i o n == NULL :
f l a g R e v e r s a l ( peakIndex )
else :
f l a g
/ / T o g g l e
t h e m u s t R e v e r s e
mustReverse = ! mustReverse
/ / Good r e v e r s a l s a l s o
goodPeaksCounter ++
/ / Accumulated enough p e a k s
i f goodPeaksCount > goodPeaksNeeded :
/ / C l o s e o u t bad s e c t i o n .
i n c r e m e n t
t h e
c o u n t e r
t o end bad s e c t i o n ?
endBound = FindEndOfBadSection ( )
S a v e B a d S e c t i o n I n f o ( o r i g i n a l F O B u f f e r , mustReverse ,
b a d O r d e r Se c t i o n s . append ( b a d S e c t i o n )
b a d S e c t i o n = NULL
startBound , endBound )
else :
/ / Found a bad peak . B e g i n l o o k i n g f o r b o u n d a r i e s .
i f b a d S e c t i o n != NULL :
b a d S e c t i o n = createNewBadSection ( peakIndex )
/ / Any bad peak r e s e t s
goodPeaksCounter = 0
s hi f t FO B u ff e r To C u rr e n tP e a k ( peakIndex )
t h e
c o u n t e r and F O B u f f e r .
peakIndex += 1
return b a d O r d e r S ec t i o n s
Figure 11: Identifying Good and Bad Sections.
depending on the history of the firing order going into that peak.
Firing on a D peak immediately after a B peak would be an error,
since these peaks are nonadjacent.
When two nonadjacent peaks are processed in series, the algo-
rithm treats this as the beginning of an invalid section. Next, it
searches for the end of the section, which occurs when any valid
RAID ’21, October 6–8, 2021, San Sebastian, Spain
Table 1: Solutions considered for badly ordered pairs and
their effects on firing order. The beginning ABCD exempli-
fies a possible firing order prior to the badly ordered pair
(indicated in red and underlined).
Detected Corrected Solution
ABCDAC
ABCDABC
Insert Forward Peak
ABCDADC Insert Reverse Peak
ABCDC
ABCDA
Delete First Peak
Delete Second Peak
ABCDAA ABCDABA Insert Forward Peak
ABCDADA Insert Reverse Peak
ABCDA
Delete Peak
sequence is detected for three peaks in a row. Three peaks are nec-
essary because the correction process (handled in the next stage)
can require changes as far as three peaks after the last invalid sec-
tion. Since there is no way of knowing how many valid peaks have
occurred since the beginning of the invalid section, we must build
up the detected firing sequence one peak at a time, determining for
each peak if it is part of a potentially valid firing order. We achieve
this by circularly shifting the firing order so that the current peak’s
phase is in the starting position, then compare the following peaks
to the forward and reverse phases of the new firing order. Because
there might be reversals in this sequence of three peaks, it may be
necessary to invert the firing order again on the second valid peak.
When the end of a bad section is detected, the algorithm saves the
endpoints and contextual information of the section to a list. The
contextual information contains whether the firing order reversed
during the section, the timestamps at the start and end of the section,
as well as on which axis the section occurred. The algorithm may
then resume normal behavior and continue detecting reversals. This
continues until all peaks in the axis are processed. The result is a
partially annotated list of peaks and a list of invalid sections. This
process is repeated for each axis.
4.5 Heuristic Correction of Bad Sections
The invalid sections produced by the previous stage are processed
individually in this stage. We recognize two forms of error: missing
peaks and duplicate peaks. Missing peaks are flagged whenever
two nonadjacent phases are detected in sequence; duplicate peaks
are flagged when the same phase is detected twice in a row. Badly
ordered sections can contain any number of badly ordered pairs,
and we have observed up to 20 in a single section in our test set.
Each badly ordered pair has multiple potentially valid corrections:
4 for missing peaks and 3 for duplicate peaks. This produces a large
problem space, and the available data does not clearly identify the
correct solution. Therefore, we have developed a heuristic approach
to search the problem space and identify the solution that best fits
a defined set of metrics.
Correcting a badly ordered section involves either deleting the
first or second peak of a badly ordered pair, or inserting a new peak
in between them. The inserted peak can be on either the forward
phase or the reverse phase. These four changes represent all of the
corrections the heuristic solver considers. All four apply to missing
141RAID ’21, October 6–8, 2021, San Sebastian, Spain
Gatlin et al.
/ / C o n t a i n e r F u n c t i o n
def b a d S e c t i o n S o l v e r C o n t a i n e r ( b a d S e c t i o n s )
s e c t i o n in b a d S e c t i o n s :
e a c h s o l u t i o n documents
s o l u t i o n s
for
/ /
/ /
s o l u t i o n s = [ ]
can be a p p l i e d t o
t h e bad s e c t i o n and p e a k s
c o r r e c t
t h e
s e c t i o n
badPeakIndex = 0
while badPeakIndex < len ( s e c t i o n ) :
i f missingPeakError ( badPeakIndex )
s o l u t i o n s . append ( m i s s i n g S o l u t i o n s ( badPeakIndex ) )
e l i f d u p l i c a t e P e a k E r r o r ( badPeakIndex )
s o l u t i o n s . append ( d u p l i c a t e S o l u t i o n s ( badPeakIndex ) )
badPeakIndex ++
b e s t S o l u t i o n , b e s t C o s t = s e a r c h S o l u t i o n s ( s o l u t i o n s ,
ap pl yS olu ti on To Tra ce ( b e s t S o l u t i o n )
0 )
Figure 12: Heuristic Solver Container.
peak pairs. For duplicate peak pairs, deleting the first and deleting
the second peak are functionally the same choice with respect to
the firing order. Therefore, duplicate peak pairs have only the three
solutions of deletion, insertion of a forward peak, and insertion of
a reverse peak. This is illustrated in Table 1.
The solutions themselves can be compared on the quality of the
peaks inserted or deleted. We do this by defining a cost function
for each of the solutions that considers the height, prominence,
proximity to other peaks, and several other characteristics of the
peaks to insert or delete. The insertion cost functions operate on the
segment of a trace in between the badly ordered peaks, searching
for the best point to insert a new peak on the target phase. The
deletion functions evaluate the first and second peaks of the badly
ordered pair to determine which is more likely to be a false positive.
Both use a relatively complex set of metrics and weightings, which
we tuned by gradually identifying error cases in our test set and
creating general metrics to correct them.
In addition to the heuristic costs for individual pairs, the solution
must consider the entire section and its context to ensure the firing
order is still valid. For example: consider the sequence ABCDACD.
The badly ordered pair, AC, is identified as a missing peak pair
and can be repaired by any of our four solutions. However, in
the context of the surrounding sequence, different choices could
produce an additional reversal, multiple reversals, or none at all.
Based on the surrounding sequences, a badly ordered section should
contain either an even or odd number of reversals; this is taken into
account by the solver, which discards solutions that do not satisfy
this constraint.
Pseudocode summarizing the heuristic process is presented in
Figures 12 and 13. The solver consists of two portions, a non-recur-
sive container and a recursive search function. The non-recursive
container iterates over all badly ordered sections for each axis. The
recursive search explores the solution space for each badly ordered
section, eventually returning the solution with the lowest cost. The
container then applies this solution to the trace, annotating the
appropriate peaks with reversals. After the list of badly ordered
sections is exhausted, the trace is fully annotated and can be used
to produce a point cloud reconstruction of the 3D printed object.
def
s e a r c h S o l u t i o n s ( s o l u t i o n s ,
c o s t )
len ( s o l u t i o n s ) == 0 :