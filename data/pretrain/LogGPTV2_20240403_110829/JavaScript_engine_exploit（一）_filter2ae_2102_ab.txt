  * 在JavaScriptCore中是 _Structures_
  * 在Spidermonkey中是 _Shapes_
根据ECMAScript的规范，所有JavaScript对象都被定义为一个由字符串键值映射到属性值的一个字典。引用MDN的描述：
> An object is a collection of properties, and a property is an association
> between a name (or _key_ ) and a value.
既然如此，作为键值的字符串如果存储在对象的内存中将会十分浪费空间，因为这样的话每生成一个对象就出多出一份键值的拷贝。而在JavaScript中，多个对象具有相同的属性是经常发生的事情，从某个方面来讲，这些对象都具有相同的形状（Shapes），也可以说具有相同的结构（Structure）。比如：
    const object1 = { x: 1, y: 2 };
    const object2 = { x: 3, y: 4 };
`object1`和`object2`虽然是两个不同的对象，但是他们的键值都是一样的。这种情况下它们就具有相同的结构，在JavaScriptCore中也能看到它们具有相同的StructureID。
    >>> describe(object1)
    Object: 0x106ab0100 with butterfly 0x0 (Structure 0x106a500e0:[Object, {x:0, y:1}, NonArray, Proto:0x106ab4000, Leaf]), StructureID: 289
    >>> describe(object2)
    Object: 0x106ab0140 with butterfly 0x0 (Structure 0x106a500e0:[Object, {x:0, y:1}, NonArray, Proto:0x106ab4000, Leaf]), StructureID: 289
    >>>
如果我们要访问对象的属性，JSC就会先根据StructureID找到对应的Structure，然后找到对应的属性名，读取属性在内联存储或者是butterfly中的偏移值，最后读取属性值。
如果此时给`object2`增加一个属性`z`，JavaScriptCore就会在Structure链中寻找有没有只拥有`x,y,z`三个属性的Structure，如果没有则重新创建一个并分配一个新的StructureID。
    >>> objectY.z = 0
    0
    >>> describe(objectY)
    Object: 0x106ab0140 with butterfly 0x0 (Structure 0x106a50150:[Object, {x:0, y:1, z:2}, NonArray, Proto:0x106ab4000, Leaf]), StructureID: 290
    >>>
###  Just-In-Time compiler
前面提到过JIT，但没有细说。其实JIT也是一个编译器，可以简单理解为和gcc一样的编译器，不过JS引擎中的JIT是将JavaScript代码编译成了机器码。JIT在JSC中一共分为四个等级：
  1. LLInt (LowLevelInterpreter)
  2. Baseline JIT compiler
  3. DFG JIT
  4. FTL JIT
#####  LLInt
llint是JavaScriptCore虚拟机的基础组件，逻辑非常简单，可以理解为一个switch循环，传入对应的JavaScript机器码，然后执行对应的指令。
#####  Baseline JIT compiler
当一个function被多次调用之后，它就会变得”hot”，这时候就需要使用JIT
compiler对它进行优化。在`Source/JavaScriptCore/jit/JIT.cpp`中：
> _// We can only do this optimization because we execute ProgramCodeBlock’s
> exactly once._
>
> // This optimization would be invalid otherwise. When the LLInt determines
> it wants to*
>
> _// do OSR entry into the baseline JIT in a loop, it will pass in the
> bytecode offset it_
>
> _// was executing at when it kicked off our compilation. We only need to
> compile code for_
>
> _// anything reachable from that bytecode offset._
当function需要进一步优化的时候，JSC就会通过OSR（On Stack Replacement ）从LLInt切换到Baseline JIT。
#####  DFG JIT
引用WebKit官方文档[WebKit JIT](https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/)中的一段话：
> The first execution of any function always starts in the interpreter tier.
> As soon as any statement in the function executes more than 100 times, or
> the function is called more than 6 times (whichever comes first), execution
> is diverted into code compiled by the Baseline JIT. This eliminates some of
> the interpreter’s overhead but lacks any serious compiler optimizations.
> Once any statement executes more than 1000 times in Baseline code, or the
> Baseline function is invoked more than 66 times, we divert execution again
> to the DFG JIT.
和前面从LLInt切换到Baseline JIT的条件类似，如果一个函数在Baseline JIT中执行次数过多，又会切换到DFG JIT中。
从文档中还可以看到一个关于DFG的细节：
> The DFG starts by converting bytecode into the DFG CPS form, which reveals
> data flow relationships between variables and temporaries. Then profiling
> information is used to infer guesses about types, and those guesses are used
> to insert a minimal set of type checks. Traditional compiler optimizations
> follow. The compiler finishes by generating machine code directly from the
> DFG CPS form.
DFG会根据搜集到的信息去推测变量的类型，如果认定了一个变量的类型，在之后将不会对变量类型进行检查，这个对我们之后的利用会很有帮助。
#####  FTL JIT
> We reuse most of the DFG phases including its CPS-based optimizations. The
> new FTL pipeline is a drop-in replacement for the third-tier DFG backend. It
> involves additional JavaScript-aware optimizations over DFG SSA form,
> followed by a phase that lowers DFG IR ( _intermediate representation_ ) to
> LLVM IR. We then invoke LLVM’s optimization pipeline and LLVM’s MCJIT
> backend to generate machine code.
其实FTL相对于其他三个JIT算是新加入的一个技术，设计它的目的是想让JavsScript的运行更加接近C的速度，事实证明确实非常接近了。值得一提的是FTL重用了DFG的一些部分，包括类型推理引擎。
## 0x02 搭建调试环境
官方文档：[Building Webkit](https://webkit.org/building-webkit/)
我使用的系统是MacOS，不过WebKit同样可以在其他系统（Windows、Linux）编译运行，我看到大多数人会选择在Ubuntu
18.04上编译，不过我没编译成功过，不知道什么原因。我直接引用别人在Ubuntu 18.04的编译命令：
    # sudo apt install libicu-dev python ruby bison flex cmake build-essential ninja-build git gperf
    $ git clone git://git.webkit.org/WebKit.git && cd WebKit
    $ Tools/gtk/install-dependencies
    $ Tools/Scripts/build-webkit --jsc-only --debug
    $ cd WebKitBuild/Debug
    $ LD_LIBRARY_PATH=./lib bin/jsc
我说一下在MacOS的build流程。首先确保安装了Xcode和Xcode的命令行工具。
    #我的系统版本 macOS Mojave
    $ sw_vers
    ProductName:    Mac OS X
    ProductVersion:    10.14.6
    BuildVersion:    18G84
    $ git clone git://git.webkit.org/WebKit.git WebKit
    #这个说明已经安装好了
    $ xcode-select --install
    xcode-select: error: command line tools are already installed, use "Software Update" to install updates
    #确定Xcode路径是否正确
    $ xcode-select -p
    /Applications/Xcode.app/Contents/Developer
    #Xcode路径和上面不一样的，可以是用如下命令切换
    $ sudo xcode-select --s /Applications/Xcode.app/Contents/Developer
    $ xcodebuild -version
    Xcode 10.3
    Build version 10G8
    #编译之前确定切换到漏洞分支
    $ git checkout ...
    #到WebKit根目录下执行这个指令就可以了
    $ Tools/Scripts/build-webkit --jsc-only --debug
我可能运气比较好，到这里都没出现过什么问题。直接可以运行JSC的 _REPL(**_ R **ead** E **val** P **rint**
L**oop)。
    $ WebKitBuild/Debug/bin/jsc
    >>> a = 1
    1
    >>>
如果遇到`DYLD_FRAMEWORK_PATH`路径的问题可以手动设置一下环境变量：
    #补全为绝对路径就行了
    export DYLD_FRAMEWORK_PATH=.../WebKitBuild/Debug
调试器我用的lldb，对比gdb的指令可以很快上手：[GDB to LLDB command
map](https://lldb.llvm.org/use/map.html)
## 0x03 开始调试
可以直接用lldb载入jsc：
    $ lldb ./WebKitBuild/Debug/bin/jsc
    (lldb) target create "./WebKitBuild/Debug/bin/jsc"
    Current executable set to './WebKitBuild/Debug/bin/jsc' (x86_64).
    (lldb) run
    Process 39132 launched: '/Users/7o8v/Documents/SecResearch/Browser/WebKit/WebKit.git/WebKitBuild/Debug/bin/jsc' (x86_64)
    >>>
调试过程中可以配合JSC提供的调试函数进行调试，比如`describe()`：
    >>> a = [1,2,3]
    1,2,3
    >>> describe(a)
    Object: 0x108ab4340 with butterfly 0x8000e4008 (Structure 0x108af2a00:[Array, {}, ArrayWithInt32, Proto:0x108ac80a0, Leaf]), StructureID: 97
    >>> a[3] = 1.1
    1.1
    >>> describe(a)
    Object: 0x108ab4340 with butterfly 0x8000e4008 (Structure 0x108af2a70:[Array, {}, ArrayWithDouble, Proto:0x108ac80a0, Leaf]), StructureID: 98
    >>> a[4] = {}
    [object Object]
    >>> describe(a)
    Object: 0x108ab4340 with butterfly 0x8000e4008 (Structure 0x108af2ae0:[Array, {}, ArrayWithContiguous, Proto:0x108ac80a0]), StructureID: 99
    >>>
更多的调试技巧可以看这篇文章：[WebKit JavaScriptCore的特殊调试技巧](http://dwfault-blog.imwork.net:30916/2019/01/03/WebKit%20JavaScriptCore%E7%9A%84%E7%89%B9%E6%AE%8A%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/)
过程中也可以使用`Ctrl+C`中断，然后使用lldb命令。
也可以载入JSC之后，运行脚本文件：
    $ lldb ./WebKitBuild/Debug/bin/jsc
    (lldb) target create "./WebKitBuild/Debug/bin/jsc"
    Current executable set to './WebKitBuild/Debug/bin/jsc' (x86_64).
    (lldb) run -i ./poc.js
    Process 39152 launched: ...
    >>>
## 0x04 Reference
[1] 
[2] 
[3] 
[4] 
[5] 
[6] 
[7] 
[8] 