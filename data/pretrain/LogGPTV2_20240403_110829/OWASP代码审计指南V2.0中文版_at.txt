KeyGenerator keyGen = KeyGenerator.getInstance(“DES”); 
SecretKey secretKey = keyGen.generateKey(); 
/** Step2. Create a Cipher by specifying the following parameters 
* a. Algorithm name - here it is DES 
* b. Mode - here it is CBC 
* c. Padding - PKCS5Padding */ 
Cipher desCipher = Cipher.getInstance(“DES/CBC/PKCS5Padding”); 
3.6.4.2 良好实践:使用强熵 
下面示例中的源代码概述了每次使用强熵时的安全密钥生成: 
示例： 
187 
package org.owasp.java.crypto; 
import java.security.SecureRandom; 
import java.security.NoSuchAlgorithmException; 
import sun.misc.BASE64Encoder; 
/** 
* This program provides the functionality for Generating a Secure Random Number. 
* There are 2 ways to generate a Random number through SecureRandom. 
* 1. By calling nextBytes method to generate Random Bytes 
* 2. Using setSeed(byte[]) to reseed a Random object 
*/ 
public class SecureRandomGen { 
public static void main(String[] args) { 
try { 
// Initialize a secure random number generator 
SecureRandom secureRandom = SecureRandom.getInstance(“SHA512”); 
// Method 1 - Calling nextBytes method to generate Random Bytes 
byte[] bytes = new byte[512]; 
secureRandom.nextBytes(bytes); 
// Printing the SecureRandom number by calling secureRandom.nextDouble() 
System.out.println(“ Secure Random # generated by calling nextBytes() is “ + secureRandom. 
nextDouble()); 
// Method 2 - Using setSeed(byte[]) to reseed a Random object 
int seedByteCount = 10; 
byte[] seed = secureRandom.generateSeed(seedByteCount); 
secureRandom.setSeed(seed); 
System.out.println(“ Secure Random # generated using setSeed(byte[]) is “ + secureRandom. 
nextDouble()); 
} catch (NoSuchAlgorithmException noSuchAlgo){ 
System.out.println(“ No Such Algorithm exists “ + noSuchAlgo); 
188 
} 
} 
} 
3.6.4.3 良好实践:使用强算法 
下面举例说明了高级加密标准的实现(可通过使用 Java 加密扩展获得): 
示例： 
package org.owasp.java.crypto; 
import javax.crypto.KeyGenerator; 
import javax.crypto.SecretKey; 
import javax.crypto.Cipher; 
import java.security.NoSuchAlgorithmException; 
import java.security.InvalidKeyException; 
import java.security.InvalidAlgorithmParameterException; 
import javax.crypto.NoSuchPaddingException; 
import javax.crypto.BadPaddingException; 
import javax.crypto.IllegalBlockSizeException; 
import sun.misc.BASE64Encoder; 
/** 
* This program provides the following cryptographic functionalities 
* 1. Encryption using AES 
* 2. Decryption using AES 
* 
* High Level Algorithm : 
* 1. Generate a DES key (specify the Key size during this phase) 
* 2. Create the Cipher 
* 3. To Encrypt : Initialize the Cipher for Encryption 
* 4. To Decrypt : Initialize the Cipher for Decryption 
189 
*/ 
public class AES { 
public static void main(String[] args) { 
String strDataToEncrypt = new String(); 
String strCipherText = new String(); 
String strDecryptedText = new String(); 
try{ 
/** 
* Step 1. Generate an AES key using KeyGenerator 
* Initialize the keysize to 128 
*/ 
KeyGenerator keyGen = KeyGenerator.getInstance(“AES”); 
keyGen.init(128); 
SecretKey secretKey = keyGen.generateKey(); 
/** 
* Step2. Create a Cipher by specifying the following parameters 
* a. Algorithm name - here it is AES 
*/ 
Cipher aesCipher = Cipher.getInstance(“AES”); 
/** 
* Step 3. Initialize the Cipher for Encryption 
*/ 
aesCipher.init(Cipher.ENCRYPT_MODE,secretKey); 
/** 
* Step 4. Encrypt the Data 
* 1. Declare / Initialize the Data. Here the data is of type String 
* 2. Convert the Input Text to Bytes 
* 3. Encrypt the bytes using doFinal method 
*/ 
190 
strDataToEncrypt = “Hello World of Encryption using AES “; 
byte[] byteDataToEncrypt = strDataToEncrypt.getBytes(); 
byte[] byteCipherText = aesCipher.doFinal(byteDataToEncrypt); 
strCipherText = new BASE64Encoder().encode(byteCipherText); 
System.out.println(“Cipher Text generated using AES is “ +strCipherText); 
/** 
*/ Step 5. Decrypt the Data 
* 1. Initialize the Cipher for Decryption 
* 2. Decrypt the cipher bytes using doFinal method 
*/ 
aesCipher.init(Cipher.DECRYPT_MODE,secretKey,aesCipher.getParameters()); 
byte[] byteDecryptedText = aesCipher.doFinal(byteCipherText); 
strDecryptedText = new String(byteDecryptedText); 
System.out.println(“ Decrypted Text message is “ +strDecryptedText); 
} 
catch (NoSuchAlgorithmException noSuchAlgo){ 
System.out.println(“ No Such Algorithm exists “ + noSuchAlgo); 
} 
catch (NoSuchPaddingException noSuchPad){ 
System.out.println(“ No Such Padding exists “ + noSuchPad); 
} 
catch (InvalidKeyException invalidKey){ 
System.out.println(“ Invalid Key “ + invalidKey); 
} 
catch (BadPaddingException badPadding){ 
System.out.println(“ Bad Padding “ + badPadding); 
} 
catch (IllegalBlockSizeException illegalBlockSize){ 
System.out.println(“ Illegal Block Size “ + illegalBlockSize); 
191 
}catch (InvalidAlgorithmParameterException invalidParam){ 
System.out.println(“ Invalid Parameter “ + invalidParam); 
} 
} 
} 
3.6.4.4 参考 
[1]布鲁斯·施奈尔，《应用密码学》，约翰·威利父子公司，第二版，1996 年。 
[2]迈克尔·霍华德，史蒂夫·李普纳，《安全开发生命周期》，2006 年，页。251 - 258 
[3] 
.NET
框
架
开
发
者
指
南
，
加
密
服
务
，
http://msdn2.microsoft.com/en-us/library/93bskf9z.aspx 
[4]微软开发者网，Windows 数据保护，http://msdn2.microsoft.com/en-us/library/ 
ms995355.aspx 
[5] Sun 开发人员网络，Java 加密扩展，http://java.sun.com/products/jce/ 
[6] 
Sun
开 发 者 网 络 ， 加 密 服 务 提 供 商 和 洁 净 室 实 现 ，
http://java.sun.com/products/jce/jce122_providers.html 
[7]联邦信息处理标准 http://csrc.nist.gov/publications/fips/ 
3.6.5 加密、散列和加盐 
加密哈希算法，也称为哈希函数，是一种计算机算法，旨在从任意数据块(二进制数据
字符串)中提供随机映射，并返回称为“消息摘要”的固定大小的位字符串，从而实现一定
192 
的安全性。 
加密散列函数用于创建数字签名、消息认证码(MACs)、其他形式的认证以及信息基础
设施中的许多其他安全应用。它们还用于将用户密码存储在数据库中，而不是以明文形式存
储密码，有助于防止网络应用程序会话管理中的数据泄漏。用于创建密码函数的实际算法因
实施方式而异(SHA-256、SHA-512 等)。 
不要在代码审计中接受程序员为散列而创建的算法。始终使用由语言、框架或通用(受
信任)加密库提供的加密功能。经验丰富的密码学家对这些功能进行了很好的审计和测试。 
在 2000 年，美国商务部出口局修订了加密出口条例。新出口条例的结果表明，该条例
已大大放宽。但是，如果代码要出口到来源国之外，则应审计出口国和进口国的现行出口法
律是否合规。 
一个恰当的例子是，如果整个消息被散列，而不是消息的数字签名，国家安全局(NSA)
认为这是一种准加密，国家控制将适用。 
如果正在进行代码审计以确保法律合规性，在组织内寻求法律建议始终是一个有效的选
择。 
有了安全，没有什么是永远安全的。加密散列函数尤其如此。一些哈希算法，比如
Windows LanMan 哈希，被认为是非常脆弱的。其他类似 MD5 的算法，在过去被认为是
安全的密码哈希算法，也有类似冲突攻击的问题(注意冲突攻击不影响密码哈希)。代码审计
者需要了解过时散列函数的弱点，以及选择加密算法的当前最佳实践。 
193 
3.6.5.1 使用盐 
哈希最常见的编程问题是: 
⚫ 
不使用盐值 
⚫ 
使用盐，盐值太短 
⚫ 
在多个散列中使用相同的盐值。 
salt 的目的是使攻击者更难执行预先计算的哈希攻击(例如，使用彩虹表)。例如，
SHA512 的“password”如下表 20 的第 1 行所示，任何使用彩虹表的攻击者都会发现对
应于“password”的哈希值。考虑到需要几天或几周的时间来计算彩虹表的值，这样最多
可达 8 或 10 个字符，当应用程序不使用任何盐时，制作该表的成本是值得的。 
现在来看一个场景，一个应用程序在所有输入的密码中添加了一点“WindowCleaner”。
现在“密码”的散列变成了“passwordWindowCleaner”的散列，如表 20 的第 2 行所示。
这不太可能出现在攻击者的彩虹表中，但是攻击者现在可以用接下来的 10 天(例如)在每 8
到 10 个字符串的末尾用“WindowCleaner”计算一个新的彩虹表，他们现在可以再次解
码我们的散列密码数据库。 
在最后一步，应用程序可以为每个条目创建一个随机的 salt，并将该 salt 与哈希密码
一起存储在数据库中。现在，对于用户 1，随机 salt 为“a0w8hsdfas8ls587uas87”，这
意味着要进行哈希运算的密码为“passworda0w8hsdfas8ls587uas87”，如表第 3 行所
示；对于用户 2，随机 salt 为“8ash87123klinF9D8dq3w”，这意味着要进行哈希运算的
密码为“password8ash87123klinF9D8dq3w”，如表 X 第 4 行所示，对所有用户重复这
样。 
194 
现在，攻击者需要一个彩虹表来存放他们想要解密的每个用户的密码——而在此之前，
使用相同的 salt 解密所有数据库密码需要 10 天，现在为用户 1 的密码创建彩虹表需要 10