tualization protected code, and therefore they are out of our
scope.
Existing import table reconstruction approaches commonly
rely on a number of assumptions that may not reﬂect the com-
plexity of advanced packers. In particular, these assumptions
include: 1) the address of a target API is statically identiﬁable
in the unpacked code [2, 15, 69]; 2) when the control ﬂow
arrives at a DLL, it necessarily points to the target API’s entry
point [40, 62, 73]; 3) API calls have to be forwarded through
the IAT [2, 15, 40, 62, 69, 73]. We conduct our study with the
following three questions in mind. Unfortunately, our deep
inspection gives negative answers to all of them.
Q1: Can target APIs’ addresses be statically identiﬁable in
the unpacked code?
Some methods use memory static scanning to reconstruct
import tables [2, 15, 69]. They have a simple assumption
that the addresses of target APIs are statically identiﬁable in
the OEP memory (e.g., Figure 2(a)). However, this assump-
tion can be violated by a dynamically computed address. Fi-
gure 2(b) illustrates a complicated example of IAT redirection,
which is adopted by Obsidium packer. The IAT entry points
to a “trampoline” area ﬁrst. This code area is maintained by
the unpacking routine as the relay to obfuscate the control
ﬂow 1 in Figure 2(a). For Figure 2(b), the trampoline furt-
her installs a custom structured exception handler (SEH) and
intentionally executes an erroneous instruction (e.g., division
by zero) to jump to the SEH at another place. Finally, the
SEH forwards the control ﬂow to the target API. Without
executing the trampoline code and SEH in Figure 2(b), we
cannot identify the target API address.
Q2: When the control ﬂow arrives at a DLL, does it neces-
sarily point to the target API’s entry point?
Dynamic-based approaches hold a common assumption
that if the control ﬂow reaches a DLL, it necessarily points to
the target API’s entry point. However, we ﬁnd a few counte-
rexamples that defy this assumption, and we summarize them
into three types. First, we ﬁnd some packers (Armadillo, PEP,
and Obsidium) call the anti-debugging APIs before the target
API (as shown in Figure 2(c)). These anti-debugging APIs
perform timing checks or checksum for the anti-analysis pur-
pose. Second, some packers (e.g., PELock and Obsidium)
3456    30th USENIX Security Symposium
USENIX Association
kernel32.dll                 (b)  IAT Redirection via SEHOriginal Code Section     …….    call [f1];      next inst.;IAT  Sectionf1:Trampoline     ...Trampoline     ...    xor eax, eax    div eax  ;     1kernel32.dll                 TargetAPI:   mov edi,edi  push ebp   mov ebp, esp   ......    ret   SEH    ...  jmp TargetAPI23Control Flow TransferIAT ReferenceIAT  Sectionf1:TargetAPI         ......Original Code Section     …….    call [f1];      next inst.;(a) Standard API Call          1(c)  Anti-debugging RoutineOriginal Code Section    …    call [f1];      next inst.;      IAT  Sectionf1:Trampoline     …Trampoline    ...  call Anti-debuggingAPI   ...   jmp TargetAPI1kernel32.dllTargetAPI:   mov edi,edi  push ebp   mov ebp, esp  ...   ret Anti-debuggingAPI:    mov edi,edi    push ebp     mov ebp, esp    ......                  ret    Original Code Section    …    call [f1];      next inst.;IAT  Sectionf1:Trampoline     …Trampoline    ...   jmp  TempAPI’s ret   ...  jmp TargetAPI1kernel32.dll4(d) ROP Redirection         3TargetAPI:   mov edi,edi  push ebp   mov ebp, esp   ...   ret  TempAPI :   mov edi,edi  push ebp   mov ebp, esp  ...   ret     2Original Code Section     …    call [f1];     next inst.;IAT  Sectionf1:Trampoline    ...Trampoline    mov edi,edi   push ebp    mov ebp, esp   jmp TargetAPI+51kernel32.dll     (e) Stolen Code        5 bytesTargetAPI:   mov edi,edi  push ebp   mov ebp, esp   ...        ret  Original Code Section     …    call Tampoline;    next inst.;IAT  Sectionf1: …Trampoline    …   jmp TargetAPI1kernel32.dll(f) Rewrite API CallsiteTargetAPI:   mov edi,edi  push ebp   mov ebp, esp  ...    ret  2TargetAPI:   mov edi,edi  push ebp   mov ebp, esp   ......    ret   33224use the ROP style to redirect their API calls (as shown in
Figure 2(d)). That is, the trampoline ﬁrst transfers the control
ﬂow to the ret-like instruction of a temporary API; then the
control ﬂow will go back to the trampoline again. After that,
the trampoline ﬁnally forwards the control ﬂow to the target
API. Since this process, such as Figure 2(d), is similar to the
ROP attack, we name it as “ROP redirection.”
The third type is the so-called “stolen code” [15, 42, 63].
As shown in Figure 2(e), the stolen code invokes an API by
ﬁrst executing a few bytes copied from the head of API, and
then it jumps back to the target API code right after the copied
instructions. Because many API monitoring tools set hooks at
the entry of an API, stolen code can evade these monitoring
tools. We observe the adoption of stolen code in the packers
such as Themida, PELock, and Enigma. Regarding how many
bytes the stolen code can copy, our large-scale evaluation
shows that it typically steals the ﬁrst 3 bytes, 5 bytes, ..., until
one basic-block size from the target API [63]. The goal of
such a choice is to be compatible with a common design
in DLLs—Position Independent Code. Otherwise, copying
more bytes to the trampoline area may also include relative-
addressing instructions, which can lead to an execution crash.
Q3: Are API calls necessarily referred to the IAT?
All of the existing import table reconstruction approaches
assume that API calls must be referred to the IAT ﬁrst. How-
ever, some packers (e.g., PEP, ASProtect, and Themida) use a
direct call instruction to invoke a target API, without passing
through the IAT. Figure 2(f) illustrates the high-level idea of
this mechanism. To achieve this goal, these packers have to
rewrite the original instruction at the API callsite. Suppose
the original API call is an indirect call (machine code: FF15),
these packers rewrite it as a direct call (machine code: E8).
Note that the direct call instruction is one byte shorter than
the indirect call, and thus these packers also add one padding
byte to the direct call instruction.
#Branches. We summarize the control ﬂow transfer in-
formation of various API obfuscation techniques in Table 3.
To the best of our knowledge, no previous work discussed
“Anti-debugging Routine” and “ROP Redirection” ever before
in the context of API obfuscation. Note that the number of
branches involved in the complicated control ﬂow, as shown
in the second column of Table 3, could be very large. The
maximum number encountered so far is 39,322!
4 System Design and Implementation
4.1 Overview
The overview of API-Xray is shown in Figure 3. The input to
API-Xray is the OEP memory captured by a binary unpacking
tool ( 1 in Figure 3), such as PinDemonium [50], CAPE [18],
or BinUnpack [15]. At this moment, the unpacking routine
has ﬁnished multi-layer unpacking, and the control ﬂow just
jumps back to the malware’s OEP. Then, the binary unpacking
tool imports API-Xray as a custom DLL to reconstruct im-
port tables ( 4 ), which are ﬁnally stitched together with the
unpacked code to assemble an executable malware sample for
further analysis. API-Xray’s memory static analysis module
explores all possible API callsites in the OEP memory ( 2 );
then API-Xray enforces the execution at each API callsite
to efﬁciently pass through the trampoline code ( 3 ). At the
same time, the underlying hardware tracing offers a transpa-
rent environment to capture the branch that jumps to a DLL’s
memory page. Note that this branch may not point to the tar-
get API. We use the heuristics of trampoline address scope
collected from hardware tracing to further determine whether
the current branch reaches the target API. Compared with the
existing work, API-Xray’s static and dynamic analyses ( 2 &
3 ) work in concert to amplify each other’s beneﬁt.
4.2 Memory Static Analysis
When the packed malware’s OEP is reached, we ﬁrst attach
the Windows Debugger (WinDbg) to the packed malware
process. Then we use IDA Pro to disassemble the OEP me-
mory via IDA WinDbg plugin [36]. After that, we run our
custom IDA Pro plugin, which follows Eureka’s search al-
gorithm [69], to explore all potential API callsites. We ﬁrst
locate all indirect call and jump instructions; then we rule out
the following cases: 1) control ﬂow instructions whose targets
reside within the unpacked program; 2) indirect jumps that
access a lookup table for switch-case handlers; 3) valid API
callsites through standard IAT reference. The remaining CALL
or JMP instructions that have unrecognized targets are poten-
tial API callsites. After that, we save the disassembly code
and detach WinDbg. The reason for doing so is that during
our API Micro Execution, the trampoline code may detect the
presence of a debugging environment (see Figure 2(c)).
4.3 API Micro Execution
To get rid of the complex control ﬂow shown in the second
column of Table 3 and resolve API names, we need to meet
the following two requirements:
1. Req1: executing the trampoline code associated with
each API callsite, so that we can efﬁciently pass through
lengthy, back-and-forth jumps;
2. Req2: capturing the control ﬂow branch whose destina-
tion eventually resides within the target API’s code.
As shown in Figure 2’s red-colored boxes, the trampoline
code contains various types to obfuscate API name resolution,
such as SEH, junk code, call stack preparation for running
anti-debugging APIs, the code for control ﬂow relay, and a
few bytes of stolen code. Our key observation is, given the
runtime context of OEP memory, the trampoline code can run
USENIX Association
30th USENIX Security Symposium    3457
Figure 3: The Overview of API-Xray.
independently. Recall that binary packers are directly applied
to the original binary code. The attached unpacking routine
for the packed program is unaware of the original code logic.
It is also the unpacking routine to allocate and maintain the
trampoline code area. Therefore, the trampoline code’s exe-
cution does not depend on the particular API arguments of
the original code. Ugarte-Pedrero et al.’s longitudinal study
in S&P’15 [73] also conﬁrms that the trampoline code’s exe-
cution is independent of the original code.
To meet Req1, our API Micro Execution creates a new
thread from the address of each API callsite to dynamically
execute the trampoline code. We borrow the name of “Mi-
cro Execution” from Patrice Godefroid’s ICSE’14 work [33],
which uses a runtime virtual machine to execute “any code
fragment without a user-provided test driver or input data”.
Similarly, we enforce executing each API callsite without re-
quiring concrete function arguments. When we decide that the
control ﬂow has just arrived at the target API, we terminate
the current thread because we can already resolve the API
name. Then we start a new API Micro Execution thread to
explore the next API name. In this way, we can resolve API
names one-by-one without raising any conﬂict. In what fol-
lows, we explore how we achieve Req2 by taking advantage
of BTS-based tracing and NX bit.
4.4 Hardware-Assisted Tracing
For the initiated API Micro Execution thread, its backend runs
a hardware-assisted control ﬂow monitoring system. Table 2
compares three hardware tracing mechanisms. LBR and IPT
exhibit low runtime overhead, but they do not meet our requi-
rements. LBR is limited by the number of branch pairs it can
record (16 or 32), while IPT does not record unconditional
direct branches. IPT will cause our tracing to miss the branch
whose destination address just hits the target API. Therefore,
we adopt BTS branch tracing and set the threshold of BTS
buffer as 1000. Once BTS buffer is full, it will trigger a system
interrupt, and our predeﬁned interrupt handler will save BTS
buffer’s record, reset it, and resume BTS’s monitoring. In this
way, we do not lose any branch.
Another question is how to set up the “checkpoint”, so
that we can timely inspect the recorded branches. The re-
cent work [9] takes the strategy of 1-branch interruption; that
is, BTS has to be interrupted for security checking at every
control ﬂow deviation instruction. However, this design will
become a performance bottleneck in our scenario. For exam-
ple, Obsidium packer’s trampoline code can execute up to
39,322 branches before reaching the target API. Our solution
is to enable NX bit for DLL’s memory pages, and we hook
page fault handler to copy recorded branch data for further
inspection. As shown in Figure 4, API-Xray’s implementation
consists of multiple kernel-level and user-level components.
4.5 Kernel Module
API-Xray’s kernel module is responsible for three main tasks.
First, it conﬁgures and enables BTS branch tracing. Second,
the kernel module hooks the related kernel functions that are
used to enable/disable and detect NX bit. In particular, we call
“ZwProtectVirtualMemory” and “ZwQueryVirtualMemory”
to enable or disable NX bit for DLL and non-DLL pages.
Prior to API Micro Execution, we only switch on NX bit for
the loaded DLL pages in the target process. When API Micro
Execution arrives at a DLL, it will trigger a page fault ( 2 in
Figure 4). We further discuss the reason for enabling/disabling
NX for non-DLL pages in §4.7. The beneﬁt of our design is
that we can intercept user-level malware’s manipulation to NX
bit. Third, when a non-executable interruption is triggered in
DLL pages, our customized page fault handler will take the
following two actions: 1) notify the user module to save the
current stack frame ( 3 in Figure 4), which will be used in
§4.7 to verify whether the current branch points to the target
API; 2) copy BTS trace buffer to the user space for further
analysis and then reset BTS buffer ( 4 in Figure 4).
4.6 Process Filtering
The limitation of BTS tracing is that it is not process-speciﬁc.
In addition to the target process’s branch data, BTS buffer
may contain the branch data coming from other processes.
As we have the OEP memory, we know the memory range
of the current process, including loaded DLLs. Besides, we
also disassembled the OEP memory so that we know the
instruction at the source address of a BTS record. To ﬁlter
out the noise caused by other processes, we will search for
a branch chain that meets the following three criteria: 1)
for each pair (source and target) in the branch chain, both
source address and destination address are within our process
3458    30th USENIX Security Symposium
USENIX Association
Memory Static AnalysisAPI-XrayAPI Call Sites& ContextHardware-Assisted API Micro ExecutionHardware Tracing(BTS & NX bit)1Reconstruct Import Tables (IAT & INT)OEP MemoryPE HeaderExecutable Malware Memory DumpOEP MemoryGeneric UnpackingPacked Malware010101010100011010101111000101011111001010010111100001010101234Figure 4: The detailed architecture of API-Xray. The shaded boxes in red represent API-Xray’s functional modules.
memory range; 2) the instruction at the source address must
be a branch instruction, because the source address from a
different process may not correspond to a branch instruction
in the current process; 3) the last record in the branch chain
transfer the control ﬂow from a non-DLL location (i.e., an
address in the trampoline code area) to an address located
within a DLL page range.
Among the collected branch chain, the ﬁrst branch jumps
to the trampoline code area (either from an API callsite or
a DLL’s memory page); the last branch jumps to a DLL’s
memory page. The rest of branches represents the back-and-
forth jumps that occur within the trampoline code area. Based
on the collection of trampoline code addresses, which share
the same high bytes, we can quickly infer the base address
of the trampoline code. This information will also be used in
§4.7 to check a valid branch pointing to the target API. The
output of our process ﬁltering is the last valid branch, as well
as the trampoline code’s base address ( 5 in Figure 4).
4.7 Destination Address Checking
This subsection discusses how to verify whether the desti-
nation address is located at the target API. Recall that when
the control ﬂow arrives at a DLL, it does not necessarily
point to the target API. We need to manage two counterex-
amples: “Anti-debugging Routine” (Figure 2(c)) and “ROP
Redirection” (Figure 2(d)). For the rest of the cases shown in
Figure 2, they will pass our destination address checking.
Figure 5: The stack frame of “Anti-debugging Routine.”
Anti-debugging Routine. Given the destination address
of a branch, we rule out the case of jumping to an anti-
debugging API using: 1) its stack frame when a DLL’s non-
executable interruption is triggered (as shown in Figure 5),
and 2) the trampoline base address. The current stack frame
of this anti-debugging API is prepared by the trampoline, and
the top of the stack stores the return address, which also points
to the trampoline code area. If the high bytes of this return
address matches the trampoline base address, we decide the
current branch does not point to the target API.
ROP Redirection. To detect this counterexample, we ﬁrst
disassemble the instruction at the destination address; if the
instruction is one of “ret-like” instructions, it means current
control ﬂow is caused by “ROP Redirection.” “Ret-like” in-
structions include the ret instruction and its semantically-