open ﬁle descriptors and backed by regular Linux shmem
objects, the existing support for SELinux appeared sufﬁ-
cient to provide basic control over read and write access to
ashmem regions by Android apps. However, an area for fur-
ther exploration of security hooks and SELinux permission
checks lies in the ashmem-speciﬁc ioctl commands.
Study and possible instrumentation of the remaining
Android-speciﬁc subsystems remains as future work. We
expect that some of these subsystems will require their own
set of security hooks and corresponding SELinux permis-
sion checks in order to fully control security-relevant oper-
ations and potential means of communications among apps.
3.2. Userspace support
Enabling userspace support for SELinux in Android re-
quired changes to a wide variety of software components,
ranging from Android’s C library implementation, ﬁlesys-
tem generation tools, and init program up through the An-
droid framework services. It also required porting the core
SELinux userspace components to Android. In this section,
we examine each aspect of enabling support for SELinux in
the Android userspace software stack.
3.2.1. C library and dynamic linker support. The
SELinux userspace code makes extensive use of the Linux
extended attribute system calls in order to get and set ﬁle
security labels. Therefore, we had to ﬁrst extend Android’s
C library implementation, called bionic, with wrappers for
these calls. Previously, bionic did not provide these wrap-
pers as no other Android userspace code was using these
calls. While our motivation for adding these calls was for
SELinux, Linux extended attributes are generally useful for
other purposes as well, and thus this was a general feature
enhancement for Android.
We also had to modify Android’s dynamic linker to rec-
ognize and use the kernel-supplied AT SECURE auxiliary
vector (auxv) ﬂag for determining whether to enable se-
cure mode. The Linux kernel provides this ﬂag to inform
userspace whether or not a security transition has occurred.
Checking the ﬂag is more reliable than checking the uid/gid
against the euid/egid as was done by the Android linker
prior to this change, because the ﬂag covers not only the
setuid/setgid case but also ﬁle capabilities, SELinux, and
any other security module state transitions. Using the ﬂag
is also a more efﬁcient test since it does not require the ad-
ditional system calls to get the uid/gid.
3.2.2. SELinux libraries and tools. In order to leverage
the SELinux facilities from the Android userspace, we had
Command Action
seclabel
restorecon
setcon
setenforce
setsebool
Set service security context.
Restore ﬁle security context.
Set init security context.
Set enforcing mode.
Set policy boolean.
Table 1. Android init language extensions.
Change ﬁle security context.
Get enforcing mode.
Get policy boolean values.
Display process security context.
Command Action
chcon
getenforce
getsebool
id
load policy Load policy ﬁle.
ls -Z
ps -Z
restorecon
runcon
setenforce
setsebool
Display ﬁle security context.
Display process security context.
Restore ﬁle security context.
Run program in security context.
Set enforcing mode.
Set policy boolean values.
Table 2. Android toolbox extensions.
to port the core SELinux userspace libraries and tools to
Android. In order to minimize the userspace footprint of
SE Android, we created a minimal port of the SELinux
API library (called libselinux) for Android. As bionic lacks
various GNU extensions which the mainstream libselinux
presently leverages, we also had to adapt our port of lib-
selinux to eliminate these dependencies.
The other SELinux libraries, namely libsepol and libse-
manage, are not required on the Android device, as they
are only required for creating and manipulating SELinux
policy, which can be done off-line. However, we did need
to adapt libsepol and the SELinux policy compiler, called
checkpolicy, so that they could be built and used not only
on Linux but also MacOS X, as many Android developers
use the latter platform as a build host OS for Android.
Speciﬁc SELinux utilities were ported to Android on an
as-needed basis. As Android’s init program directly inter-
prets the initialization conﬁguration ﬁles (the init.rc ﬁles)
rather than running a shell interpreter, support was added for
several of the SELinux utilities as init built-in commands,
as shown in Table 1. Support was also added for several
of these utilities as part of the Android toolbox, as shown
in Table 2, which supports various Linux commands via a
single binary for use from a shell or by apps.
3.2.3. Labeling ﬁles. Android ﬁlesystem images for the
device are generated using special purpose tools, namely
mkyaffs2image and make ext4fs, during the Android build
process. These tools have Android-speciﬁc support for set-
ting the UID, GID, and mode bits on the ﬁles within the im-
ages when they are initially generated. However, the tools
had no support for setting security labels on ﬁles within the
generated ﬁlesystem image. We extended both tools to sup-
port setting of ﬁle security labels based on the SELinux
ﬁle contexts conﬁguration, which speciﬁes the initial as-
signment of security labels for each ﬁle. As a result, the
images generated during the Android build process for the
system and the userdata partitions have correct security la-
bel assignments from the very beginning, and there is no
need for a separate relabeling step in the SE Android instal-
lation process.
We also extended the Android recovery console and up-
dater programs to ensure that ﬁles created from the recovery
console, e.g. system updates, are correctly labeled. This
was necessary to ensure that the system remains in a se-
curely labeled state even across updates and likewise avoids
the need for a separate relabeling step after updates or other
changes are applied from recovery. We included a copy of
the ﬁle contexts conﬁguration ﬁle within the recovery im-
age so the updater program can determine the correct ﬁle
labels, as the recovery image is the only visible mounted
ﬁle system during the update process.
3.2.4. System initialization. Android has its own unique
init program for system initialization and its own unique
ueventd program for managing device nodes. We extended
Android’s init program to load the SELinux policy early
during startup prior to executing any commands from the
init.rc ﬁles, and we extended the ueventd program to label
device nodes in accordance with policy. The security con-
text of the init process is set from the early-init section of
the init.rc conﬁguration using the new setcon built-in com-
mand. Processes and ﬁles created after this initial setup can
then be labeled automatically in most cases.
Most system services are automatically transitioned into
their own security contexts by the kernel when they are ex-
ecuted from the system image by init. A few early ser-
vices, such as ueventd and adbd, require explicit labeling
via a new seclabel option in the init.rc conﬁguration be-
cause their executables live in the root ﬁlesystem, which is
merely an in-memory ﬁlesystem unpacked from the initial
ramfs image passed to the kernel and thus does not have
per-ﬁle security labels. This allows each system service to
be distinguished in the SELinux policy.
The Android init program handles the creation and bind-
ing of local sockets for many of the system services. As
these sockets should be labeled to reﬂect the security at-
tributes of the individual service and not just those of the
init process, we also extended init to set the security context
for the sockets and the socket ﬁles. This allows connections
to each service socket to be controlled by SELinux policy.
The other new built-in commands can be used from the
init.rc to specify the initial state for SELinux operation.
In particular, the setenforce command can be used to put
SELinux into enforcing mode and the setsebool command
can be used to set speciﬁc SELinux policy booleans to a de-
sired initial state. Other approaches to managing SELinux
enforcing mode and policy booleans are described in Sec-
tion 3.2.8.
3.2.5. App security labeling. All Android apps are created
by the zygote process, typically at the request of the Activi-
tyManagerService (AMS) running within the system server
process. The AMS invokes the Process.start() method,
which sends a command string over a local socket to the zy-
gote. The zygote then calls the Zygote.forkAndSpecialize()
method, which in turn performs a JNI call to the native im-
plementation within the Dalvik VM. The Dalvik VM then
forks a child process and sets the DAC credentials (UID,
GID, supplementary groups) for the child process to reﬂect
the credentials of the app.
Even the Android system server, which provides the An-
droid framework services for the apps and runs in the system
UID with a number of Linux superuser capabilities, is cre-
ated by the zygote. This is done using a variant interface,
forkSystemServer, which is also implemented by the Dalvik
runtime and internally uses the same function, forkAndSpe-
cializeCommon, within the Dalvik VM.
To enable the system server and the Android apps to be
labeled differently from the zygote process, we had to ex-
tend the Dalvik VM to also set the SELinux security con-
text for the child process. To support this functionality, we
inserted a hook within the Dalvik VM to call a new inter-
face in the libselinux library at the right point during setup
of the new child process. The setting of the SELinux secu-
rity context for the child must occur after the setting of the
DAC credentials as the new SELinux security context may
not be allowed to change DAC credentials at all, and it must
occur before any other threads or objects are created by the
child to ensure proper labeling of all associated threads and
objects.
In order to support a greater range of inputs to select a
SELinux security context for app processes, we extended
the relevant interfaces and their callers to take an additional
seinfo string argument that can be used to pass higher-level
information from the AMS about the particular app being
started. These changes spanned the Dalvik VM, the zygote,
and the AMS in order to convey the additional argument all
the way through the call chain for spawning an app process.
We also extended the relevant interfaces and their callers to
provide the name of the application package as one of the
inputs.
This mechanism allows SELinux to distinguish the sys-
tem server process from all apps, even apps running in the
system UID. It also allows SELinux to distinguish apps from
one another based on their platform UID, package name, or
other higher-level information provided by the AMS of the
system server. The seinfo string for the app is determined
from the middleware MAC policy conﬁguration, described
in Section 3.3.2.
In addition to setting the security label of each app pro-
cess, we also needed to set the security label of each app
data directory. The creation of the app data directories is
performed by the installd daemon in Android, which re-
ceives commands over a local socket from the PackageM-
anagerService running in the system server. As with the
Dalvik VM, we inserted hooks into installd to call a new
interface in the libselinux library when the app data direc-
tories are being created to set the directory security context
correctly.
The new functions in libselinux that implement these
hooks for both Dalvik VM and installd are driven by a sin-
gle shared conﬁguration ﬁle, the seapp contexts conﬁgura-
tion. This conﬁguration was introduced speciﬁcally for SE
Android but is similar to other SELinux policy conﬁgura-
tion ﬁles. The conﬁguration allows speciﬁcation of how to
label app processes and data directories based on the avail-
able inputs.
3.2.6. Userspace policy enforcement. SELinux provides
support to allow seamless extension of the Mandatory Ac-
cess Control model to application layer objects and opera-
tions. The libselinux library provides interfaces for use by
applications to obtain security contexts for their own ob-
jects and to apply SELinux permission checks on opera-
tions performed on these objects. These userspace com-
ponents are typically referred to as userspace object man-
agers in the terminology of the Flask architecture on which
SELinux is based [46]. This approach has been previously
applied to various Linux applications such as the D-Bus
message bus [42], the X Window System [48], the Post-
greSQL DBMS [20], and the GConf [8] conﬁguration sys-
tem.
In Android, there are number of applications that imple-
ment their own permission checking logic, typically based
on the DAC UID of the requesting process. Two such com-
ponents include the init program, which provides a global
property name/value space for all Android processes, and
the zygote, which provides the interface for spawning new
apps.
The init program was extended to apply security label-
ing for the system properties and to enforce mandatory ac-
cess controls over attempts to set their values. Fine-grained
control over reading the system properties is not presently
possible as they are stored in a single shared mapping that
is mapped read-only by all processes in Android. By con-
trolling the ability to set the system properties, SELinux
can prevent a compromise of one of the privileged system
services from being leveraged to set any arbitrary property.
SELinux can also support ﬁner-grained distinctions over the
ability to set properties than the existing DAC controls.
The zygote was likewise extended to enforce manda-
tory access controls over the use of its socket interface for
spawning new apps. While the kernel can directly control
what processes can connect to the zygote via this socket in-
terface, ﬁner-grained distinctions over the use of privileged
commands issued over the socket require permission check-
ing by the zygote itself. In order to enable the use of the
SELinux APIs from the zygote Java code and from the An-
droid framework services written in Java, we created a set
of SELinux JNI bindings for a subset of the libselinux in-
terfaces. The ZygoteConnection class was then extended to
use these APIs to obtain the security context of the client
process and apply SELinux permission checks for any priv-
ileged operation, such as specifying the UID and GID for
the new app being spawned. As with the property MAC
controls, these controls enable SELinux to prevent a com-
promise of one of the privileged system services from be-
ing leveraged to spawn apps with arbitrary credentials or
resource limits.
3.2.7. Middleware policy enforcement. Although the
SELinux userspace object manager approach worked well
for the init property service and the zygote, it proved far
more problematic at the Android middleware layer. First,
apps communicate with the Android middleware via Binder
IPC rather than socket IPC. Thus, the lack of support for
obtaining the sender security context for binder IPC was an
initial obstacle. We overcame this problem by implement-
ing support for passing the sender security context on binder
transactions.
However, we then discovered that binder transactions
often involve multi-stage call chains that require saving
and restoring caller identity for permission checking pur-
poses. For example, content providers are accessed in-
directly via the AMS, which saves the caller identity in
thread-local storage before invoking the content provider,
so that it can look up the original caller identity when the
content provider later queries the AMS for a permission
check. Providing similar support for saving and restoring
the sender security context would have required an invasive
and potentially costly set of changes.
Further, Android permission checks are often invoked by
application components using the public checkPermission
API, which only supports passing the sender PID and UID.
This would have required that we extend the public check-
Permission API in order to fully support permission check-
ing based on SELinux security contexts, thereby creating
compatibility problems for existing apps and impacting An-
droid app developers. We were further concerned about the
potential implications of using the SELinux policy to cap-
ture middleware MAC semantics on our goals for keeping
the SELinux policy small, simple, and relatively static.
As a result of these considerations, we chose to intro-
duce a separate middleware MAC (MMAC) layer for An-
droid. The MMAC layer should only interact with the ker-
nel MAC layer with respect to determining the seinfo string
used for app security labeling, as described in Section 3.2.5.
Otherwise, the two layers should largely function indepen-
dently, with the kernel MAC layer enforcing a small set of
ﬁxed security goals based on the assigned security contexts.
As this design decision removed the need to pass sender se-
curity context information on Binder IPC, we reverted the
corresponding code changes from our reference implemen-
tation.
We have developed several MMAC mechanisms for
Android to explore the design and implementation space.
These MMAC mechanisms provide different forms of
mandatory restrictions over the Android permissions model.
One of these mechanisms, known as install-time MAC, has
been integrated as part of the core SE Android implemen-
tation as it provides the basis for determining seinfo strings