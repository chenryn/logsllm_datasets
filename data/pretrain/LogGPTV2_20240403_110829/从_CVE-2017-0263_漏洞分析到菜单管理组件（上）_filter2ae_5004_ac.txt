          return 0;
        lRet = pwnd->lpfnWndProc(pwnd, message, wParam, lParam);
        if ( !lpdwResult )
          return lRet;
        *(_DWORD *)lpdwResult = lRet;
      }
      else
      {
        xxxSendMessageToClient(pwnd, message, wParam, lParam, 0, 0, &fuFlags);
        [...]
      }
_函数 xxxSendMessageTimeout 执行窗口对象消息处理函数的逻辑_
如果该标志位置位，则函数将直接使当前线程在内核上下文调用目标窗口对象的消息处理函数；否则，函数通过调用函数 `xxxSendMessageToClient`
将消息发送到客户端进行处理，目标窗口对象的消息处理函数将始终在用户上下文调用和执行。
诸如菜单层叠窗口对象之类的特殊窗口对象拥有专门的内核模式消息处理函数，因此这些窗口对象的成员标志位 `bServerSideWindowProc`
在对象创建时就被置位。而普通窗口对象由于只指向默认消息处理函数或用户进程自定义的消息处理函数，因此该标志位往往不被置位。
如果能够通过某种方式将未置位标志位 `bServerSideWindowProc`
的窗口对象的该标志位置位，那么该窗口对象指向的消息处理函数也将直接在内核上下文中执行。
### 阴影窗口
在 Windows XP 及更高系统的 `win32k` 内核模块中，系统为所有带有 `CS_DROPSHADOW` 标志的窗口对象创建并关联对应的类名称为
`SysShadow` 的阴影窗口对象，用来渲染原窗口的阴影效果。内核中存在全局表 `win32k!gpshadowFirst`
用以记录所有阴影窗口对象与原窗口对象的关联关系。函数 `xxxAddShadow` 用来为指定的窗口创建阴影窗口对象，并将对应关系写入
`gpshadowFirst` 全局表中。
全局表 `gpshadowFirst` 以链表的形式保存阴影窗口的对应关系。链表的每个节点存储 3
个指针长度的成员域，分别存储原窗口和阴影窗口的对象指针，以及下一个链表节点的指针。每个新添加的关系节点将始终位于链表的首个节点位置，其地址被保存在
`gpshadowFirst` 全局变量中。
_全局变量 gpshadowFirst 指向阴影窗口关联链表_
相应地，当阴影窗口不再需要时，系统调用 `xxxRemoveShadow`
来将指定窗口的阴影窗口关联关系移除并销毁该阴影窗口对象，函数根据通过参数传入的原窗口对象的指针在链表中查找第一个匹配的链表节点，从链表中取出节点并释放节点内存缓冲区、销毁阴影窗口对象。
### 子菜单
如果当前在屏幕中显示的菜单中存在子菜单项，那么当用户通过鼠标按键点击等方式选择子菜单项时，系统向子菜单项所属的菜单窗口对象发送
`WM_LBUTTONDOWN` 鼠标左键按下的消息。如果菜单为非模态（`MODELESS`）类型，内核函数 `xxxMenuWindowProc`
接收该消息并传递给 `xxxCallHandleMenuMessages` 函数。
函数 `xxxCallHandleMenuMessages` 负责像模态窗口的消息循环那样处理非模态窗口对象的消息。在函数中，系统根据通过参数
`lParam` 传入的相对坐标和当前窗口在屏幕上的坐标来计算鼠标点击的实际坐标，并向下调用 `xxxHandleMenuMessages` 函数。
函数将计算的实际坐标点传入 `xxxMNFindWindowFromPoint`
函数查找坐标点坐落的在屏幕中显示的窗口，并将查找到的窗口对象指针写入菜单状态结构体的成员域 `uButtonDownHitArea`
中。当该值确实是窗口对象时，函数向该窗口对象发送 `MN_BUTTONDOWN` 鼠标按下的消息。
接着执行流又进入函数 `xxxMenuWindowProc` 并调用函数 `xxxMNButtonDown` 以处理 `MN_BUTTONDOWN` 消息。
    case 0x1EDu:
      if ( wParam cItems || wParam >= 0xFFFFFFFC )
        xxxMNButtonDown(popupMenu, menuState, wParam, 1);
      return 0;
_函数 xxxMenuWindowProc 调用 xxxMNButtonDown 函数_
函数 `xxxMNButtonDown` 调用 `xxxMNSelectItem` 函数以根据鼠标按下区域选择菜单项并存储在当前弹出菜单对象的成员域
`posSelectedItem` 中，随后调用函数 `xxxMNOpenHierarchy` 以打开新弹出的层叠菜单。
在函数 `xxxMNOpenHierarchy` 执行期间，系统调用函数 `xxxCreateWindowEx` 创建新的类名称为 `MENUCLASS`
的子菜单层叠窗口对象，并将新创建的子菜单窗口对象关联的弹出菜单结构体 `tagPOPUPMENU` 对象插入弹出菜单对象延迟释放链表中。
函数将新分配的子菜单窗口对象指针写入当前菜单窗口对象关联的弹出菜单信息结构体 `tagPOPUPMENU` 对象的成员域 `spwndNextPopup`
中，并将当前菜单窗口对象指针写入新分配的菜单窗口对象关联的 `tagPOPUPMENU` 对象的成员域 `spwndPrevPopup`
中，使新创建的弹出菜单对象成为当前菜单对象的子菜单。
新创建的子菜单窗口和原菜单窗口 tagMENUWND 对象的对应关系
函数将当前菜单窗口对象的弹出菜单信息结构体 `tagPOPUPMENU` 对象的标志成员域 `fHierarchyDropped`
标志置位，这个标志位表示当前菜单对象已弹出子菜单。
接下来函数调用 `xxxSetWindowPos` 以设置新的菜单层叠窗口在屏幕中的位置并将其显示在屏幕中，并调用函数 `xxxWindowEvent`
发送 `EVENT_SYSTEM_MENUPOPUPSTART` 事件通知。新菜单窗口对象对应的阴影窗口会在这次调用 `xxxSetWindowPos`
期间创建并与菜单窗口对象关联。
简要执行流如下：
_点击子菜单项以弹出子菜单时的简要执行流_
### 终止菜单
在用户进程中可以通过多种接口途径触达 `xxxMNEndMenuState` 函数调用，例如向目标菜单的窗口对象发送 `MN_ENDMENU` 消息，或调用
`NtUserMNDragLeave` 系统服务等。
当某调用者向目标菜单窗口对象发送 `MN_ENDMENU` 消息时，系统在菜单窗口消息处理函数 `xxxMenuWindowProc` 中调用函数
`xxxEndMenuLoop` 并传入当前线程关联的菜单状态结构体对象和其成员域 `pGlobalPopupMenu`
指向的根弹出菜单对象指针作为参数以确保完整的菜单对象被终止或取消。如果菜单对象是非模态类型的，那么函数接下来在当前上下文调用函数
`xxxMNEndMenuState` 清理菜单状态信息并释放相关对象。
      menuState = pwnd->head.pti->pMenuState;
      [...]
    LABEL_227: // EndMenu
      xxxEndMenuLoop(menuState, menuState->pGlobalPopupMenu);
      if ( menuState->flags & 0x100 )
        xxxMNEndMenuState(1);
      return 0;
_函数 xxxMenuWindowProc 处理 MN_ENDMENU 消息_
函数 `xxxEndMenuLoop` 执行期间，系统调用 `xxxMNDismiss` 并最终调用到 `xxxMNCancel`
函数来执行菜单取消的操作。
    int __stdcall xxxMNDismiss(tagMENUSTATE *menuState)
    {
      return xxxMNCancel(menuState, 0, 0, 0);
    }
_函数 xxxMNDismiss 调用 xxxMNCancel 函数_
函数 `xxxMNCancel` 调用 `xxxMNCloseHierarchy` 函数来关闭当前菜单对象的菜单层叠状态。
    popupMenu = pMenuState->pGlobalPopupMenu;
    [...]
    xxxMNCloseHierarchy(popupMenu, pMenuState);
_函数 xxxMNCancel 调用 xxxMNCloseHierarchy 函数_
函数 `xxxMNCloseHierarchy` 判断当前通过参数传入的弹出菜单 `tagPOPUPMENU` 对象成员域
`fHierarchyDropped` 标志位是否置位，如果未被置位则表示当前弹出菜单对象不存在任何弹出的子菜单，那么系统将使当前函数直接返回。
接下来函数 `xxxMNCloseHierarchy` 获取当前弹出菜单对象的成员域 `spwndNextPopup`
存储的指针，该指针指向当前弹出菜单对象所弹出的子菜单的窗口对象。函数通过 `xxxSendMessage` 函数调用向该菜单窗口对象发送
`MN_CLOSEHIERARCHY` 消息，最终在消息处理函数 `xxxMenuWindowProc` 中接收该消息并对目标窗口对象关联的弹出菜单对象调用
`xxxMNCloseHierarchy` 以处理关闭子菜单的菜单对象菜单层叠状态的任务。
      popupMenu = *(tagPOPUPMENU **)((_BYTE *)pwnd + 0xb0);
      menuState = pwnd->head.pti->pMenuState;
      [...]
    case 0x1E4u:
      xxxMNCloseHierarchy(popupMenu, menuState);
      return 0;
_函数 xxxMenuWindowProc 处理 MN_CLOSEHIERARCHY 消息_
函数 `xxxSendMessage` 返回之后，接着函数 `xxxMNCloseHierarchy` 调用 `xxxDestroyWindow`
函数以尝试销毁弹出的子菜单的窗口对象。需要注意的是，这里尝试销毁的是弹出的子菜单的窗口对象，而不是当前菜单的窗口对象。
在函数 `xxxDestroyWindow` 执行期间，系统调用函数 `xxxSetWindowPos` 以隐藏目标菜单窗口对象在屏幕中的显示。
    dwFlags = 0x97;
    if ( fAlreadyDestroyed )
      dwFlags = 0x2097;
    xxxSetWindowPos(pwnd, 0, 0, 0, 0, 0, dwFlags);
_函数 xxxDestroyWindow 隐藏目标窗口对象的显示_
在函数 `xxxSetWindowPos` 执行后期，与当初创建菜单窗口对象时相对应地，系统调用函数 `xxxSendChangedMsgs`
发送窗口位置已改变的消息。在该函数中，系统根据设置的 `SWP_HIDEWINDOW` 状态标志，通过调用函数 `xxxRemoveShadow` 在
`gpshadowFirst` 阴影窗口关联表中查找第一个与目标菜单窗口对象关联的阴影窗口关系节点，从链表中移除查找到的关系节点并销毁该阴影窗口对象。
接下来执行流从函数 `xxxDestroyWindow` 中进入函数 `xxxFreeWindow` 以执行对目标窗口对象的后续销毁操作。
函数根据目标窗口对象的成员域 `fnid` 的值调用对应的消息处理包装函数 `xxxWrapMenuWindowProc` 并传入
`WM_FINALDESTROY` 消息参数，最终在函数 `xxxMenuWindowProc` 中接收该消息并通过调用函数
`xxxMNDestroyHandler` 对目标弹出菜单对象执行清理相关数据的任务。在该函数中，目标弹出菜单对象的成员标志位 `fDestroyed`
和根弹出菜单对象的成员标志位 `fFlushDelayedFree` 被置位：
    *(_DWORD *)popupMenu |= 0x8000u;
    [...]
    if ( *((_BYTE *)popupMenu + 2) & 1 )
    {
      popupMenuRoot = popupMenu->ppopupmenuRoot;