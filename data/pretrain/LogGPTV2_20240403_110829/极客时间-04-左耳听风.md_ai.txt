# 10 \| 如何成为一个大家愿意追随的Leader？之前的文章，我们分享过技术领导力（Leadership）相关的话题，主要讨论了作为一个技术人，如何取得技术上的领先优势，而不是如何成为一个技术管理者。今天的文章中，我们着重聊聊如何成为一个大家愿意跟随的技术领导者（Leader）。注意，Leader不是管理者，不是经理，更不是职称，而是一个领头人。所谓领头人和经理或管理者的最大差别就是，领头人（Leader）是大家愿意追随的，而经理或管理者（Boss）则是一种行政和职位上的威慑。说白了，Leader的影响力来自大家愿意跟随的现象，而经理或管理者的领导力来自职位和震慑，这两者是完全不同的。
# Leader 和 Boss 的不同再或者用通俗的话说，Leader 是大家跟我一起上，而 Boss则是大家给我上，一个在团队的前面，一个在团队的后面。具体来说，这两者的不同点如下。-   **Boss 是驱动员工，Leader 是指导员工**。在面对项目的时候，Boss    制定时间计划，并且推动（push）和鞭策员工完成工作，而 Leader    则是和员工一起讨论工作细节，指导员工关注工作的重点，和员工一起规划出（work    out）工作的方向和计划，并且在工作中和员工一起解决细节难题，帮助员工完成工作。-   **Boss 制造畏惧，Leader 制造热情**。Boss    在工作中是用工作职位级别压人，用你的绩效考核来制造威慑，让员工畏惧他，从而推行工作。而    Leader    是通过描绘远景，制造激动人心的目标来鼓舞和触发团队的热情和斗志。``{=html}-   **Boss 面对错误喜欢使用人事惩罚的手段，而 Leader    面对错误喜欢寻找解决问题的技术或管理方法**。惩罚员工和解决问题完全是两码事，Boss    因为并不懂技术也并不懂问题的细节，所以他们只能使用惩罚这样的手段，而    Leader    通常是喜欢解决问题的技术型人才，所以，他们会深入技术细节，从技术上找到既治标又治本的技术方案或管理方式。-   **Boss 只是知道怎么做，而 Leader 则是展示怎么做**。一个好 Leader    的最大特点就是 Lead by Example，以身作则，用身教而不是言传。而 Boss    只是在说教，总是在大道理上说的一套又一套，但从来不管技术细节。-   **Boss 是用人，而 Leader 是发展人**。Boss    不关心人的发展，把人当成劳动力。而 Leader    则会看到人的潜力和特长，通过授权、指导和给员工制定成长计划让员工成长，从而发展员工。所以，我们通常可以看到    Boss 总是说自己的员工有这个问题有那个问题，而 Leader    总是说，如何让员工成长以解决员工个人的各种问题。-   **Boss 从团队收割成绩，而 Leader 则是给予团队成绩**。Boss    通常都会把团队的成绩占为己有，虽然 Boss    会说这是团队的功劳，但基本上是一句带过。而 Leader    则是让团队成功，让团队的成员站在台前，自己甘当绿叶和铺路石。Leader    知道只有团队的每个人成功了，团队才会成功，所以，Leader    会帮助团队中的每个人更好更流畅地走向成功。-   **Boss 喜欢命令和控制（ Command + Control ），而 Leader    喜欢沟通和协作（ Communication + Cooperation ）**。Boss    喜欢通过命令来控制员工的行为，从而实现团队的有效运转，而 Leader    喜欢通过沟通和协作来增加员工的参与感，从而让员工觉得这是自己的事，愿意为之付出。-   **Boss 喜欢说"给我上"，而 Leader 喜欢说"跟我上"**。Boss    总是躲在团队后面，让团队冲锋陷阵，而 Leader    总是冲在前面用自己的行动领着团队浴血奋战。![](Images/96eb5e2f958a30ac3d4a1561f0d4de41.png){savepage-src="https://static001.geekbang.org/resource/image/2d/ce/2dd368279b137d965d2591d4b2c166ce.jpg"}从上面这些比较，我们应该可以看到 Boss 和 Leader的不同，相信你已经有了一些了解和认识到什么才是一个真正的Leader，什么才是一个 Leader 应有的素质和行为。下面，我将结合我的一些经历和经验分享一下，如何才能成为一个大家愿意追随的人。
# 如何成为众人愿意追随的 Leader说白了，要成为一个大家愿意追随的人，那么你需要有以下这些"征兆"。-   **帮人解决问题**。团队或身边大多数人都在问："这个问题怎么办？"，而你总是能站出来告诉大家该怎么办。-   **被人依赖**。团队或身边大多数人在做比较关键的决定时，都会来找你咨询意见和想法。要有这样的现象，你需要有技术领导力。关于技术领导力，你可以参看本专栏主题为《如何才能拥有技术领导力？》的文章。有没有技术领导力（Leadership），是成为一个Leader非常关键的因素。因为人们想要跟随的人通常都是比自己强比自己出色的人，或是能够跟他学到东西，能够跟他成长的人。但是，有了技术领导力可能并不够，作为一个Leader，你还需要有其它的一些能力和素质。比如，和我一起共事过的人和下属，他们会把我当成他们的朋友，他们会和我交流很多在员工和老板间比较禁忌的话题，比如：-   有猎头或是别的公司来挖我的下属，我的下属会告诉我，并会征求我的意见。除了帮他们分析利弊，有些时候，我还会帮他们准备面试。甚至，我有时候还会为我的下属介绍其它公司的工作机会。不要误会我（Don't    get me    wrong），我并不是不站在公司利益的角度，我这样做完全是站在公司利益的角度。    你要知道这个世界很大，一个公司或是一个 Leader    很难做到把人一辈子留下来，因为人总是需要有不同经历的，优秀的人更是如此。既然做不到把人留一辈子，那么不妨把这件事做得漂亮一些，这样会让要离开的员工觉得这个    Leader 或是这个公司的胸怀不一般，可能是他再也碰不到的公司或    Leader，反而会想留下来，或是离开后又想回来。-   下属会来找我分享他的难处和让他彷徨的事情，包括吐槽公司。一般来说，下属是不会找老板吐槽公司的，因为这是办公室中的禁忌。但是作为老板和经理，其实我们都知道，员工是一定会吐槽老板和公司的。既然做不到不让员工吐槽公司，那么不妨让这件事做得更漂亮一些------可以公开透明地说，而不是在背后说，因为在背后说对公司或是团队的伤害更大。举了上面两个例子，我只是想告诉你一个 Leader除了有技术领导力还需要有其它的素质和人格魅力。如果你的员工把这些看似禁忌的事和你分享向你倾吐，说明他们是何等信任你，何等看重你，这就说明你对他的价值已经非同寻常了，这份信任和托付对于一个Leader 来说要小心呵护。下面是我罗列的一些比较关键的除了技术领导力之外的一个 Leader 需要的素质。-   **赢得他人的信任**。信任是人类一切活动的基础，人与人之间的关系是否好，完全都是基于信任的。**对于信任来说，并不完全是别人相信你能做到某个事，还有别人愿意向你打开心扉，和你说他心里面最柔软的东西。而后者才是真正的信任**。这还需要你的人格魅力，你的真诚，你的可信，你的价值观和你的情怀等一些诸多因素，才会让别人愿意找你分享心中的想法和情绪。-   **开放的心态 +    倾向性的价值观**。这两个好像太矛盾了，其实并不是。我想说的是，对于新生事物要有开放的心态，对于每个人的观点都有开放的心态，但并不是要认同所有的观点和事情，成为一个油腔滑调的人。    也就是说，我可以听进各种不同观点，并在讨论中根据自己的价值观对不同的观点做出相应的判断，而并不是不加判断全部采用。因为如果你要做一个    Leader，你需要有明确的方向和观点，而不是说一些放之四海皆准的完全正确的废话。我的经验告诉我，对于各种各样的技术都要持一种比较开放的态度，可以讨论优缺点，但不会争个是非对错，尤其对于新技术来说，更要开放。    然而，就价值观来说，还是需要有倾向性的，比如，我就倾向于不加班的文化，倾向于全栈，倾向于按职责分工而不是按技能分工，倾向于做一个    Leader 而不是 Boss，倾向于技术是第一生产力，倾向于 OKR 而不是    KPI......    **我的这些倾向性可以让别人更清楚地知道我是一个什么样的人，而不会对我琢磨不透，一会东一会西只会让人觉得你太油了，反而会产生距离感和厌恶感。我认为，倾向性的价值观是别人是否可以跟随你的一个基础**。-   **Lead by Example**。用自己的示例来    Lead，用自己的行为来向大家展示你的    Leadership。这就是说，你需要给大家做示范。很多时候，道理人人都知道，但未必人人都会做，知易行难，以身示范，一个示例会比讲一万遍道理都管用。    所以我认为，对于软件开发来说，不写代码的架构师是根本不靠谱的。**要做一个有人愿意跟随的技术    Leader，你需要终身写代码，也就是所谓的 ABC -- Always Be    Coding。这样，你会得到更多的实际经验，能够非常明白一个技术方案的优缺点，实现复杂度，知道什么是    Best    Practice，你的方案才会更具执行力和实践性。当有了执行力，你就会获得更多的成就，而这些成就反过来会让更多的人来跟随你**。-   **保持热情和冲劲**。在这个世界上，有太多太多的东西会让人产生沮丧、不满、彷徨、迷茫、疲惫等这些负面情绪，但是几乎所有的人都不会喜欢在这样的情绪中生活，我们每个人都会去追求更为积极更为正面的生活方式。    所以，作为一个 Leader    无论在什么情况下，你都需要保持热情和冲劲，只有这样，你才会让别人有跟随的想法和冲动。    但是，**所谓的保持热情和冲劲，并不是自欺欺人，也不是文过饰非，因为掩耳盗铃、掩盖问题、强颜欢笑的方式根本不是热情。真正的热情和冲劲是，正视问题，正视不足，正视错误，从中进行反思和总结得到更好的解决方案，不怕困难，迎难而上**。    正如鲁迅先生在《记念刘和珍君》中所说的那句话------"真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血"。-   **能够抓住重点，看透事物的本质**。这个世界太复杂，有太多的因素和杂音影响着我们的判断和决定。绝大多数人都会在多重因素中迷失或是纠结。作为一个    Leader，能够抓住主要矛盾，看清事物的本质，给出清楚的观点或方向，简化复杂的事情，传道解惑、开启民智，让人豁然开朗、醍醐灌顶，才会让人追随之。-   **描绘令人激动的方向，提供令人向住的环境**。我相信，我们每个人心中都有激动和理想，就算是被现实摧残得最凶残的人，他们已经忘却了心中那些曾经的激动和理想，但我相信也只是暂时的。一个好的    Leader    一定会把每个人心中最真善美的东西呼唤出来，并且还能让人相信这是有机会有可能做到的。-   **甘当铺路石，为他人创造机会**。别人愿意跟随你，愿意和你共事，有一部分原因是你能够给别人带来更多的可能性和机会，别人觉得和你在一起能够成长，能够进步，你能够带着大家到达更远的地方。帮助别人其实就是帮助自己，成就他人其实也是在成就自己，这就像一个好的足球队一样，球队中的人都互相给队友创造机会，整个团队成功了，球队的每个人也就成功了。作为一个好的    Leader，你一定要在团队中创造好这样的文化和风气。做一个好的 Leader真的不容易，你需要比大家强很多，你需要比大家付出更多；你需要容天下难容之事，你还需要保持热情和朝气；你需要带领团队守护理想，你还需要直面困难迎刃而上......也许，你不必做一个 Leader，但是如果你有想跟随的人，你应该去跟随这样的Leader！![](Images/1c1e992cf41f5294df097aabed82f9e4.png){savepage-src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg"}
# 11 \| 程序中的错误处理：错误返回码和异常捕捉今天，我们来讨论一下程序中的错误处理。也许你会觉得这个事没什么意思，处理错误的代码并不难写。但你想过没有，要把错误处理写好，并不是件容易的事情。另外，任何一个稳定的程序中都会有大量的代码在处理错误，所以说，处理错误是程序中一件比较重要的事情。这里，我会用两篇文章来系统地讲一下错误处理的各种方式和相关实践。
# 传统的错误检查首先，我们知道，处理错误最直接的方式是通过错误码，这也是传统的方式，在过程式语言中通常都是用这样的方式处理错误的。比如C语言，基本上来说，其通过函数的返回值标识是否有错，然后通过全局的`errno`变量并配合一个`errstr` 的数组来告诉你为什么出错。为什么是这样的设计？道理很简单，除了可以共用一些错误，更重要的是这其实是一种妥协。比如：`read()`,`write()`, `open()`这些函数的返回值其实是返回有业务逻辑的值。也就是说，这些函数的返回值有两种语义，一种是成功的值，比如`open()` 返回的文件句柄指针 `FILE*` ，或是错误`NULL`。这样会导致调用者并不知道是什么原因出错了，需要去检查 `errno`来获得出错的原因，从而可以正确地处理错误。``{=html}一般而言，这样的错误处理方式在大多数情况下是没什么问题的。但是也有例外的情况，我们来看一下下面这个C 语言的函数：    int atoi(const char *str)这个函数是把一个字符串转成整型。但是问题来了，如果一个要传的字符串是非法的（不是数字的格式），如\"ABC\"或者整型溢出了，那么这个函数应该返回什么呢？出错返回，返回什么数都不合理，因为这会和正常的结果混淆在一起。比如，返回`0`，那么会和正常的对 "0"字符的返回值完全混淆在一起。这样就无法判断出错的情况。你可能会说，是不是要检查一下`errno`，按道理说应该是要去检查的，但是，我们在 C99的规格说明书中可以看到这样的描述------> 7.20.1>> The functions atof, atoi, atol, and atoll need not affect the value of> the integer expression errno on an error. If the value of the result> cannot be represented, the behavior is undeﬁned.像`atoi()`, `atof()`, `atol()` 或是 `atoll()` 这样的函数是不会设置`errno`的，而且，还说了，如果结果无法计算的话，行为是`undefined`。所以，后来，libc又给出了一个新的函数`strtol()`，这个函数在出错的时会设置全局变量`errno`：    long strtol(const char *restrict str, char **restrict endptr, int base);于是，我们就可以这样使用：    long val = strtol(in_str, &endptr, 10);  //10 的意思是 10 进制 // 如果无法转换if (endptr == str) {    fprintf(stderr, "No digits were found\n");    exit(EXIT_FAILURE);} // 如果整型溢出了if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN)) {    fprintf(stderr, "ERROR: number out of range for LONG\n");    exit(EXIT_FAILURE); } // 如果是其它错误if (errno != 0 && val == 0) {    perror("strtol");    exit(EXIT_FAILURE);} 虽然，`strtol()` 函数解决了 `atoi()`函数的问题，但是我们还是能感觉到不是很舒服和自然。因为，这种用 `返回值` + `errno` 的错误检查方式会有一些问题:-   程序员一不小心就会忘记返回值的检查，从而造成代码的 Bug；-   函数接口非常不纯洁，正常值和错误值混淆在一起，导致语义有问题。所以，后来，有一些类库就开始区分这样的事情。比如，Windows的系统调用开始使用 `HRESULT`的返回来统一错误的返回值，这样可以明确函数调用时的返回值是成功还是错误。但这样一来，函数的input 和 output 只能通过函数的参数来完成，于是出现了所谓的 `入参` 和`出参` 这样的区别。然而，这又使得函数接入中参数的语义变得复杂，一些参数是入参，一些参数是出参，函数接口变得复杂了一些。而且，依然没有解决函数的成功或失败可以被人为忽略的问题。