title:Uniform Application-level Access Control Enforcement of Organizationwide
Policies
author:Tine Verhanneman and
Frank Piessens and
Bart De Win and
Wouter Joosen
Uniform Application-level Access Control Enforcement of Organizationwide
Policies
Tine Verhanneman
Frank Piessens
Bart De Win Wouter Joosen
Katholieke Universiteit Leuven, Department of Computer Science
Celestijnenlaan 200A, 3001 Leuven
ftine,frank,bartd,PI:EMAIL
Abstract
The application developer provides the application logic.
Fine-grained and expressive access control policies on
application resources need to be enforced in application-
level code. Uniformly enforcing a single policy (referred to
as the organizationwide policy) in diverse applications is
challenging with current technologies. This is due to a poor
delimitation of the responsibilities of application deployer
and security of(cid:2)cer, which hampers a centralized manage-
ment of a policy and therefore compromises the uniformity
of its enforcement.
To address this problem, the concept of an access inter-
face is introduced as a contract between an organization-
wide authorization engine and the various applications that
need its services. The access interface provides support for
the central management of the policy by the security of(cid:2)cer.
By means of a view connector, the application deployer en-
sures that each application complies with this contract, so
that the policy can be enforced.
1. Introduction
Many applications require the enforcement of an expres-
sive access control policy, which, for example, takes into
consideration application state. In the context of an organi-
zation, where one single organizationwide policy needs to
be enforced, support should be provided to administer the
policy centrally and to enforce it uniformly in the various
applications deployed within the organization.
Various stakeholders are involved in the enforcement of
an access policy. The security of(cid:2)cer manages the policy
centrally. The application deployer tunes the access con-
trol enforcement for each application so that the policy can
be enforced. The access control decision itself can be del-
egated to an organizationwide authorization engine, which
may be developed independently of a particular application
setting and provided by an authorization engine provider.
In this paper, the observation is made that the delimita-
tion of the responsibilities between the security of(cid:2)cer and
application deployer, is poorly supported by current tech-
nologies: In reality, the application deployer bears complete
responsibility for the uniform enforcement of the policy.
This renders it hard to manage the policy centrally, espe-
cially if this policy is liable to frequent changes.
The contribution of the paper consists in providing an ab-
straction layer, named access interface, which captures the
requirements an application needs to ful(cid:2)ll so that the orga-
nizationwide policy can be enforced. This access interface,
for example, includes explicitly the additional information
that is needed to evaluate an access request. The access
interface abstracts from application-speci(cid:2)c details by in-
cluding only information that is relevant for access control.
It can therefore be speci(cid:2)ed by the security of(cid:2)cer, who is
responsible for the de(cid:2)nition and centralized management
of the policy.
The application deployer binds the access interface to
each application by means of application-speci(cid:2)c view con-
nectors. A view connector speci(cid:2)es (1) how the application
ful(cid:2)lls the requirements that are put forward in the access
interface, and (2) how access requests within the applica-
tion are translated to the access interface. A prototype has
been implemented as an extension of an aspect-oriented ap-
plication container, whereby the view connector acts as a
deployment descriptor.
The remainder of the paper is organized as follows. Sec-
tion 2 motivates the need for an intermediary abstraction
layer, illustrated by a case in the health care application do-
main.
In Section 3 the access interface approach is pre-
sented, followed by a discussion in Section 4. The proto-
type is discussed in Section 5. Section 6 gives an overview
of related work and conclusions are drawn in Section 7.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
2. Detailed motivation
In this section, the challenge of implementing an access
control policy in an application with state-of-the-art tech-
nologies will be illustrated by means of a case in the health
care application domain. After having identi(cid:2)ed the short-
comings of current technologies, we list the requirements
our approach should meet.
2.1. High›level policy
Health care organizations must ensure that appropriate
technical and organizational measures are in place to pro-
tect patient data: Based on the principles of least privilege
and minimum necessary [24], the disclosure of health care
information should be limited to the minimum necessary to
accomplish the intended purpose.
We discuss a subset of the security policy of an academic
hospital in Belgium [28, 18]. These rules are typical for
access control policies in a medical context [24, 25, 3, 1].
Our setting is a hospital with a large number of physicians
and associated general practitioners. The following rules
deal with accesses to a contact, which is a logical unit of
medical data.
Rule 1 A physician will be granted access to a patient’s
data if a contact exists to which he was assigned. The ac-
cess rights are only valid until 30 days after the contact was
closed.
The policy allows to overrule the access decision, for ex-
ample for emergency access, provided that it is possible to
hold physicians accountable for any access granted on the
basis of this rule.
Rule 2 The system provides the possibility to overrule the
access decision, on condition that the user requesting ac-
cess, speci(cid:2)es a reason. The reason, the requesting user’s
and the patient’s name, along with some context informa-
tion (time, place) are logged.
To improve communication between the patient, his gen-
eral practitioner (GP) and the team of caregivers, view ac-
cess is granted to the patient’s GP.
Rule 3 The patient’s general practitioner has view access
to all the patient’s contacts, whether these contacts have
been closed or not.
These three rules will serve as the basis for further dis-
cussion.
In the following paragraphs, roles and permis-
sions (objects and operations) are identi(cid:2)ed (conforming to
RBAC [12]) as a (cid:2)rst step towards an implementation of the
policy.
Roles. Two roles can be distinguished: A physician, who
is a staffmember and a licensed medical practitioner (e.g. a
specialist), and the general practitioner, who maintains the
overview of the patient’s social background, medical history
and current health condition and acts as a con(cid:2)dant for the
patient.
Permissions. This policy only concerns objects which
represent identi(cid:2)able medical data. The status of medical
data can be open or closed, depending on whether the con-
tact, the data is part of, has been closed or not. The oper-
ations that can be carried out on a medical data object are
restricted to view, append and close. The latter is invoked
by the patient’s responsible physician to close the contact.
Pure RBAC lacks granularity to enforce the rules men-
tioned earlier: For an access decision, the relationship be-
tween the user requesting access and the patient whose
data is about to be accessed, should also be taken into ac-
count [3]. Table 1 summarizes the policy rules and illus-
trates that only the responsible physician is allowed to close
the medical data of his patient.
2.2. Enforcing the policy in applications
The organizationwide policy speci(cid:2)ed above must now
be enforced in all applications running in the hospital, such
as for example an appointment and prescription system
[28]. Given the increased use of information technology in
health care, this number of applications can be quite high.
We describe a simpli(cid:2)ed model of one example appli-
cation: an Integrated Care Pathways (ICP) application. An
Integrated Care Pathway [19] is a prede(cid:2)ned plan for care
relating to a certain diagnosis, which serves as a guideline
to organize care more effectively and ef(cid:2)ciently; e.g.
to
shorten hospital stays, to raise resource utilization and to
reduce unnecessary variations in patient care and outcomes.
In short, an ICP constitutes a work(cid:3)ow, which guides the
health care provider through the different steps in the health
care process by providing a template, indicating the health
care services which should be provided at a certain point in
the treatment. Upon commencing the treatment, the respon-
sible physician instantiates an ICP for his patient, and plans
and executes the steps as the treatment proceeds. These
steps are, for example, examinations, medication prescrip-
tions and notes. Figure 1 shows a simpli(cid:2)ed classdiagram
for the ICP application. The medical data to protect is con-
tained within the Integrated Care Pathway (ICP) and its as-
sociated steps (Step). The application keeps a reference to
both the GP of the patient and the responsible physician.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Roles/status (Medical Data)
if responsible
Physician
if in overrule mode
Physician
if patient’s GP
GP
Table 1. Medical data
open
30 days closed
view,append,close
view
view
view
view
view
-
view
view
Figure 1. ICP›application
Personnel
Technician
Physician
-licenseID: LicenseID
-name: String
-department: String
+getDepartment()
+getName()
Patient
-name: String
-ssn: SSN
-GeneralPractioner: GP
1
+getGP(): GP
+getName(): String
+getSSN(): SSN
*
1
GP
-licenseID: LicenseID
+getLicenseID(): LicenseID
ComposedStep
-steps: Arraylist
ActionStep
+execute(pers:Personnel)
+getLicenseID(): LicenseID
+getStepAt(index:int)
1
1
1
responsible
*
ICP
1
-patient: Patient
-responsiblePhysician: Physician
-creationTime: Date
-closingTime: Date
-step: ComposedStep
*
+getPatient(): Patient
+getResponsiblePhysician(): Physician
+close(): void
+getICPStep(): ComposedStep
+getCreationTime(): Date
+getClosingTime(): Date
+isClosed(): boolean
*
Step
-responsiblePhysician: Physician
-parentStep: ComposedStep
+planNextStep(): void
+getParentStep(): ComposedStep
+getResponsiblePhysician(): Physician
2.3. Problems when implementing and managing
the policy
Before elaborating on the challenges of the application-
level enforcement of a policy, two important stakeholders
are introduced:
(cid:15) The security of(cid:2)cer draws up and manages the policy
without needing to have extensive knowledge of the
internal operation of the different applications.
(cid:15) The application deployer tunes the access control en-
forcement by the application, ensuring that it conforms
to the policy.
How should an organizationwide policy, like the policy
presented in Section 2.1, be enforced in the application?
The deployer has to translate the high-level, organization-
wide policy into application terms, by providing for ex-
ample deployment descriptors, con(cid:2)guration (cid:2)les or code.
This typically results in a series of lower-level rules, indicat-
ing for each type of object which methods may be invoked
by whom. An example of such a low-level rule might be
that a physician is allowed to invoke getPatient() on
all objects of the class ICP. This means that once the high-
level policy has been de(cid:2)ned by the security of(cid:2)cer, the bur-
den is placed entirely on the application deployer to uni-
formly translate this policy into application terms for each
of the applications deployed within the organization, which
is a very intricate job.
This lack of an abstraction layer between an applica-
tion and the security logic also becomes apparent if a
common organizationwide authorization engine is used:
Application-speci(cid:2)c access requests need to be translated
in terms understood by the engine. A rather ad hoc ap-
proach consists in conveying labels to the authorization en-
gine, which abstract the action and/or object that is being
accessed.
Uniformly enforcing an access policy tends to get harder
as policy rules are frequently updated, added or removed.
The application deployer has to translate the high-level pol-
icy once again and has to ensure that the access control en-
forcement points and the information passed to the autho-
rization engine (if an engine is used) are adapted to re(cid:3)ect
the updated policy. Consider, for illustration purposes, the
following two additional rules:
Rule 4 Each time the GP accesses his patient’s medical
data, the responsible physician is noti(cid:2)ed of this access.
Rule 5 Psychiatric - and human heredity records are clas-
si(cid:2)ed as highly sensitive, and cannot be viewed by the
GP [18].
For Rule 4 the responsible physician and for Rule 5 the
sensitivity level of the data need to be conveyed to the au-
thorization engine. The deployer also faces similar prob-
lems when the application itself changes, e.g. due to code
refactoring.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
2.4. The requirements
We now de(cid:2)ne the major requirements that we took into
account when developing our approach for the integration
of access control enforcement in applications. These re-
quirements are mainly based on [4].
1. The expressiveness of the policies that can be enforced,
should not be constrained [3].
In practice, in order
to enforce application-level security, the granularity
of the policy that can be speci(cid:2)ed, should be small
enough to encompass the application resources to be
protected. Likewise, the variety (richness) and the
amount of information serves as a criterion of the ex-
pressiveness of the supported policies. For example,
the state a work(cid:3)ow process is in, the time or other
contextual information may be relevant when making
an access control decision.
2. Separation of concerns must be supported by clearly
delimiting responsibilities of the stakeholders identi-
(cid:2)ed in Section 2.3. Separation of concerns is the key to
support evolution, which encompasses both manage-
ability and extensibility.
3. Multiple applications that obey the same security pol-
icy, must be treated and described uniformly. Unifor-
mity requires support for the central management of an
organizationwide policy, as well as the enforcement of
a single policy in diverse applications. In short, what
we aim for is to write the policy once and to enforce it
everywhere.
Of course, any proposed design should also have no ad-
verse effects on other important properties of an access con-
trol infrastructure (such as performance and scalability). We
return to this point in the discussion section 4.
3. Proposed solution
In this section, our solution is described. In the overview
shown in Figure 2, an organizationwide authorization en-
gine is used to evaluate access requests.
Two new concepts are introduced as part of this solution.
The access interface describes explicitly what the autho-
rization engine expects from applications in order to make
access decisions. Such an access interface should be rel-