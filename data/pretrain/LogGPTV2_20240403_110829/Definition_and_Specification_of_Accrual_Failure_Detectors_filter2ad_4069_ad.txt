Cosquer et al. [11] proposed a group membership service that allows the tuning of its failure detec-
tion (called suspectors) by applications. Applications do so by specifying interpretation conditions that
are used by the failure detector to do the interpretation. The paper introduces many excellent ideas with
respect to the tailoring of failure detectors, but does not address the issue of decoupling monitoring and
interpretation. In contrast, our work focuses on the latter issue. This said, this should not be too difﬁcult
to adapt their system so that it implements an accrual failure detector.
More recently, Friedman [18] outlined in a position paper the idea of a fuzzy group membership,
where a value called fuzziness level would be associated with each process to determine the extent
to which the process belongs to the group. Technical issues were developed later by Friedman and
Tcharny [19, 20]. Although the papers address different issues, the authors rely on some fuzzy failure
detector that outputs some integer value and uses two thresholds to deﬁne three suspicion levels (trusted,
fuzzy, or suspected). There are no details, however, because this is not the focus of their work.
In
particular, they provide no deﬁnition nor implementation of fuzzy failure detectors. We believe that,
although developed independently, our works could nicely complement each other.
Aguilera et al. [1] propose the failure detector called HB (Heartbeat) that can be used together
with an unreliable failure detector to solve Consensus in partitionable systems. Roughly speaking, the
failure detector associates to each process an integer value that increases as long as the process remains
reachable. This failure detector is used as a complement for other failure detectors, and not as a lower-
level building block.
Several papers have proposed failure detectors that internally used some counters. However, these
counters are used as an implementation technique and not as a means to separate decoupling system
monitoring and interpretation. Bondavalli et al. [5] proposed the notion of α-count to distinguish be-
tween the transient and permanent/intermittent faults of system components. A value is associated with
each component and incremented each time the component fails. When the value grows beyond a given
threshold, the corresponding component is reported as permanently faulty. Chu [9], and later Mostefaoui
et al. [27], present different algorithms to transform an unreliable failure detector into a leader oracle
(also called Ω failure detector). The two algorithms are based on a similar approach. Brieﬂy speaking,
each process maintains a counter associated with each other process. The counters are incremented and
processes exchange information on their values using gossiping. The process with the lowest value is
deemed the most trustworthy and hence the most desirable candidate for a leader.
In recent work, Dunagan et al. [13] proposed a failure monitoring system called FUSE. They ad-
vocate providing failure detection as a global service and address several related engineering issues. In
particular, they focus on providing consistent failure notiﬁcations in large-scale and wide-area networks.
12
Whereas FUSE addresses issues related to notiﬁcations about failures, accrual failure detectors provide
a solution for detecting failures, and are thus useful components on top of which a system like FUSE
could be built.
7 Conclusion
Failure detection constitutes a fundamental abstraction for fault tolerant distributed systems. However,
from a more practical perspective, the binary model of classical failure detectors limit the development
of failure detection as a generic service because this model combines monitoring and interpretation. The
accrual failure detectors presented in this paper decouple these two tasks by outputting a suspicion level
rather than a binary value, and leaving it to applications to interpret this value. Ideally, the monitoring
is done by a single service running on each machine, while the interpretation of the suspicion level is
left to each application process. Such a service can be implemented as a daemon, a linked library or a
kernel service, depending on the desired tradeoff between intrusiveness and performance.
This paper gives a rigorous deﬁnition for accrual failure detectors that is compatible with the seminal
work of Chandra and Toueg [7].
In particular, we presented important conditions for the suspicion
level under which an accrual failure detector (♦P ac) is computationally equivalent to an eventually
perfect binary failure detectors (i.e., of class ♦P). This equivalence is important because it shows that
accrual failure detectors do not hide any additional synchrony assumptions with respect to their binary
counterparts. However, equivalence does not imply that accrual failure detectors cannot be more efﬁcient
or expressive than binary failure detectors. In fact, we argued extensively the architectural advantages
of accrual failure detectors, and presented usage patterns that are very difﬁcult to handle using a binary
failure detector.
We have also outlined four different ways to implement accrual failure detectors and discussed their
respective advantages. This is not exhaustive and there is room for developing many other implementa-
tions in the future.
Acknowledgments
The example discussed in the introduction was kindly suggested to us by Francisco V. Brasileiro.
The authors are also grateful to the following persons for their insightful comments and suggestions:
Adel Cherif, Matti Hiltunen, Michel Raynal, Robbert van Renesse, Richard D. Schlichting, Yoichi Shin-
oda, Makoto Takizawa, and Paulo Ver´ıssimo.
References
[1] M. Aguilera, W. Chen, and S. Toueg. Using the heartbeat failure detector for quiescent reliable communication and
consensus in partitionable networks. Theor. Comput. Science, 220(1):3–30, June 1999.
[2] M. Aguilera, C. Delporte-Gallet, H. Fauconnier, and S. Toueg. Thrifty generic broadcast. In M. Herlihy, editor, Proc.
14th Intl. Symp. on Distributed Computing (DISC’00), LNCS 1914, pages 268–282, Oct. 2000.
[3] M. Bertier, O. Marin, and P. Sens. Implementation and performance evaluation of an adaptable failure detector. In Proc.
IEEE Intl. Conf. on Dependable Systems and Networks (DSN’02), pages 354–363, June 2002.
[4] M. Bertier, O. Marin, and P. Sens. Performance analysis of a hierarchical failure detector. In Proc. IEEE Intl. Conf. on
Dependable Systems and Networks (DSN’03), pages 635–644, June 2003.
[5] A. Bondavalli, S. Chiaradonna, F. Di Giandomenico, and F. Grandoni. Discriminating fault rate and persistency to
improve fault treatment. In Proc. 27th Intl. Symp. on Fault-Tolerant Computing (FTCS-27), pages 354–362, June 1997.
[6] T. Chandra, V. Hadzilacos, and S. Toueg. The weakest failure detector for solving consensus. J. ACM, 43(4):685–722,
July 1996.
[7] T. Chandra and S. Toueg. Unreliable failure detectors for reliable distributed systems. J. ACM, 43(2):225–267, 1996.
13
[8] W. Chen, S. Toueg, and M. Aguilera. On the quality of service of failure detectors.
IEEE Trans. on Computers,
51(5):561–580, May 2002.
[9] F. Chu. Reducing Ω to ♦W. Inf. Process. Lett., 67(6):289–293, Sept. 1998.
[10] W. Cirne, F. Brasileiro, J. Sauv´e, N. Andrade, et al. Grid computing for Bag-of-Tasks applications. In Proc. 3rd IFIP
Conf. on E-Commerce, E-Business and E-Goverment, Sept. 2003.
[11] F. Cosquer, L. Rodrigues, and P. Ver´ıssimo. Using tailored failure suspectors to support distributed cooperative applica-
tions. In Proc. 7th IASTED Intl. Conf. on Parallel and Distributed Computing and Systems (PDCS’95), pages 352–356,
Oct. 1995.
[12] X. D´efago, P. Urb´an, N. Hayashibara, and T. Katayama. On accrual failure detectors. RR IS-RR-2004-11, JAIST,
Ishikawa, Japan, May 2004.
[13] J. Dunagan, N. Harvey, M. Jones, D. Kostic, et al. FUSE: Lightweight guaranteed distributed failure notiﬁcation. In
Proc. 6th Symp. on Operating Systems Design and Implementation (OSDI’04), Dec. 2004.
[14] C. Dwork, N. A. Lynch, and L. Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 35(2):288–323,
Apr. 1988.
[15] R. Ekwall, A. Schiper, and P. Urb´an. Token-based atomic broadcast using unreliable failure detectors. In Proc. 23nd
IEEE Intl. Symp. on Reliable Distributed Systems (SRDS’04), pages 52–65, Oct. 2004.
[16] P. Felber, X. D´efago, R. Guerraoui, and P. Oser. Failure detectors as ﬁrst class objects.
In Proc. 1st Intl. Symp. on
Distributed-Objects and Applications (DOA’99), pages 132–141, Sept. 1999.
[17] C. Fetzer, M. Raynal, and F. Tronel. An adaptive failure detection protocol. In Proc. 8th IEEE Paciﬁc Rim Symp. on
Dependable Computing (PRDC’01), pages 146–153, Dec. 2001.
[18] R. Friedman. Fuzzy group membership. In A. Schiper, A. Shvartsman, H. Weatherspoon, and B. Y. Zhao, editors, Future
Directions in Distributed Computing, LNCS 2584, pages 114–118, Jan. 2003. Position paper.
[19] R. Friedman and G. Tcharny. Evaluating failure detection in mobile ad-hoc networks. TR CS-2003-06, Technion, Israel,
Oct. 2003.
[20] R. Friedman and G. Tcharny. Stability detection in mobile ad-hoc networks. TR CS-2003-12, Technion, Israel, Nov.
2003.
[21] N. Hayashibara. Accrual Failure Detectors. PhD thesis, JAIST, Ishikawa, Japan, June 2004.
[22] N. Hayashibara, X. D´efago, and T. Katayama. Flexible failure detection with κ-fd. RR IS-RR-2004-006, JAIST,
Ishikawa, Japan, Feb. 2004.
[23] N. Hayashibara, X. D´efago, R. Yared, and T. Katayama. The ϕ accrual failure detector. In Proc. 23nd IEEE Intl. Symp.
on Reliable Distributed Systems (SRDS’04), pages 66–78, Oct. 2004.
[24] M. Hurﬁn, A. Most´efaoui, and M. Raynal. A versatile family of consensus protocols based on Chandra-Toueg’s unreli-
able failure detectors. IEEE Trans. on Computers, 51(4):395–408, Apr. 2002.
[25] A. Most´efaoui, E. Mourgaya, and M. Raynal. Asynchronous implementation of failure detectors. In Proc. IEEE Intl.
Conf. on Dependable Systems and Networks (DSN’03), pages 351–360, June 2003.
[26] A. Most´efaoui, D. Powell, and M. Raynal. A hybrid approach for building eventually accurate failure detectors. In Proc.
10th IEEE Paciﬁc Rim Intl. Symp. on Dependable Computing (PRDC), pages 57–65, Mar. 2004.
[27] A. Most´efaoui, M. Raynal, and C. Travers. Crash-resilient time-free eventual leadership. TR, IRISA, Rennes, France,
Apr. 2004.
[28] L. Sampaio, F. Brasileiro, W. Cirne, and J. Figueiredo. How bad are wrong suspicions? towards adaptive distributed
protocols. In Proc. IEEE Intl. Conf. on Dependable Systems and Networks (DSN’03), pages 551–560, June 2003.
[29] R. van Renesse, Y. Minsky, and M. Hayden. A gossip-style failure detection service. In N. Davies, K. Raymond, and
J. Seitz, editors, Middleware’98, pages 55–70, The Lake District, UK, 1998.
14
A Appendix
This appendix presents technical details that are not essential to convey the ideas presented in the pa-
per, but that are important to justify the correctness of the argumentation (e.g., complete proofs of the
theorems).
A.1 Proof for the transformation from accrual (♦P ac) to binary (♦P)
Lemma 7 (Strong completeness) Given an accrual failure detector Dac of class ♦P ac, Algorithm 1
satisﬁes the property of Strong Completeness.
PROOF.
every correct process.
Strong Completeness requires that every faulty process is eventually suspected forever by
Consider a faulty process p and some correct process q that monitors p. We must show that there is
a time after which p is permanently suspected by q.
Consider the system after the stabilization, i.e., when sl qp is increasing and increases by at least
once every Q consecutive queries for some positive Q.
We ﬁrst show that there is a last T-transition (if T-transitions occur at all). We show this by proving
that no more than Q T-transitions may occur after stabilization. Suppose that stabilization and Q T-
transitions have already occurred. As the run length for trusting Ltrust increases by one at each T-
transition, Ltrust > Q forever. As only run lengths shorter than Q will ever appear, the condition
l > Ltrust will never hold. Moreover, as sl qp is monotonously increasing, sl  Ltrust ) will
never hold again.
Now, consider a time after which both stabilization and the last T-transition have occurred. If p is
suspected at this time, it will be suspected forever, and the proof is complete. If p is trusted at this time,
an S-transition will occur, as sl qp goes to inﬁnity, and thus sl > SLsusp will eventually hold forever,
whatever the value of SLsusp may be. After the S-transition, p will be suspected forever, and the proof
(cid:3)Lemma 7
is complete.
Lemma 8 (Eventual strong accuracy) Given an accrual failure detector Dac of class ♦P ac, Algo-
rithm 1 satisﬁes the property of Eventual Strong Accuracy.
PROOF. Eventual Strong Accuracy requires that, after some time, no correct process is suspected by
a correct process. We prove the lemma by considering two correct processes p and q chosen arbitrarily,
and such that q monitors p. We must show that there is a time after which p is never suspected. We can
rely on the existence of a bound SLmax on the suspicion level sl qp.
We ﬁrst show that there is a last S-transition (if S-transitions occur at all). We show this by proving
that no more than dSLmax /e S-transitions occur, where  is the resolution of the suspicion level (see
Deﬁnition 1). Suppose that dSLmax /e S-transitions have already occurred. As Ssusp increases by at
least  upon every S-transition, SLsusp ≥ SLmax , and hence sl > SLsusp will never hold again. We have
shown that the condition to trigger an S-suspicion will never hold again.
Now, consider the system after the last S-transition (or any time if no S-transition occurs). If p is
trusted at this time, it will be trusted forever. If p is suspected at this time, a T-transition will occur, as
we show below. After the T-transition, p will be trusted forever, and the proof is complete.
We must now prove that a T-transition occurs. Let si denote the value that s takes during the i-th
query. If the sequence si is not monotonously increasing, the condition sl  Ltrust will hold at least once, and thus
15
a T-transition occurs. As p and q were chosen arbitrarily, we have shown that Eventual Strong Accuracy
(cid:3)Lemma 8
holds.
Theorem 9 Algorithm 1 transforms an accrual failure detector of class ♦P ac into one of class ♦P.
PROOF.
(cid:3)Theorem 9
Follows from Lemma 7 (Strong completeness) and Lemma 8 (Eventual strong accuracy).
A.2 Proof for the transformation from binary (♦P ac) to accrual (♦P)
Lemma 10 (Accruement) Given a binary failure detector D of class ♦P, Algorithm 2 satisﬁes the
property of Accruement (Prop. 1).
PROOF. Consider a faulty process p and a correct process q. Since p is faulty, D ensures that p is
eventually suspected permanently (Strong completeness). Consider the system after the last S-transition
(or from the start if p is never trusted). sl qp(t) is obviously increasing by  upon every query. We have
(cid:3)Lemma 10
thus shown that Accruement holds.
Lemma 11 (Upper Bound) Given a binary failure detector D of class ♦P, Algorithm 2 satisﬁes the
property of Upper Bound (Prop. 2).
PROOF. Consider two correct processes p and q. Since p is correct, D ensures that p is eventually
trusted permanently (Strong eventual accuracy). Consider a point in time after the last T-transition (or
any time if p is never suspected). Every query after this point in time returns 0. A suitable upper bound
for sl qp is thus the highest suspicion level returned up to this point in time. We have thus shown that
(cid:3)Lemma 11
Upper bound holds.
Theorem 12 Algorithm 2 transforms ♦P into ♦P ac.
PROOF. Follows directly from Lemma 10 (Accruement), and Lemma 11 (Upper bound). (cid:3)Theorem 12
A.3 Proofs for the theorems about quality of service
In this section, we present the proofs for the theorems in Section 4.4. We start by presenting Algorithm 3,
an unambiguous description of the failure detector D0
T (where T is a threshold function).
status := trust