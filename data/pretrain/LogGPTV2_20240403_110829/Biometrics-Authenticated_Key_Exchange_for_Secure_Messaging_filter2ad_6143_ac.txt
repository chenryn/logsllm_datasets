by the DDH assumption under the random oracle model. We omit
the details since the analysis is similar to that in Section 3.2.
, . . . , u
ğ‘— = ğ‘ğ‘œğ‘™ğ‘¦
ğ‘› } and ğ‘ as (ğ‘ğ‘œğ‘™ğ‘¦, ğ‘”ğ‘Ÿ (cid:4), ğ‘”ğ‘Ÿ , {ğ‘ğ‘œğ‘š0,
âŠ• (ğ‘”ğ‘Ÿ )ğ» (u(cid:4)
ğ‘— )
(ğ‘”ğ‘Ÿ (cid:4)
4 BIOMETRICS-AUTHENTICATED KEY
EXCHANGE FOR SECURE MESSAGING
We design a Biometrics-Authenticated Key Exchange (BAKE) frame-
work based on AFEM and explain how this framework can be ap-
plied to secure messaging. We also instantiate BAKE with two
common biometric characteristics, including irises and fingerprints,
to intuitively show the practicability of our BAKE framework.
4.1 BAKE Framework
Our BAKE framework involves two participants communicating
on an insecure channel and consists of three phases: the initial-
ization (Init) phase, the key generation (KeyGen) phase, and the
authenticated key exchange (AKE) phase. The core idea of our
framework is to derive a session key for secure messaging from
random strings generated by two participants. To securely transmit
a random string generated by one participant to the other one, we
employ an AFEM scheme to encapsulate the string. Authentication
is implicitly executed when a participant tries to decapsulate the
received encapsulated string. The detail of our BAKE framework is
shown in Figure 2.
Init Phase. This phase provides all public parameters required
in other phases. Specifically, P0 and P1 have to agree on essential
parameters, that is, the security parameter ğœ† and the threshold ğœ.
Then, the setup algorithm AFEM.Setup is invoked to produce the
public parameters ğ‘ğ‘ğ‘Ÿ of AFEM. Finally, the public parameters of
BAKE are set to ğ‘ğ‘ğ‘Ÿ and are accessible to both participants.
In real-world applications (e.g., secure messaging), a service
provider could produce the public parameters ğ‘ğ‘ and publish them
on a bulletin board or encode them into software, so that every
participant can access them.
KeyGen Phase. In this phase, each participant produces a pub-
lic key based on her/his biometric characteristics and sends it to
the other one. Specifically, Pğ‘– (ğ‘– âˆˆ {0, 1}) generates a secret key ğ‘ ğ‘˜ğ‘–
based on the biometric characteristics, which is instantiated in the
following two subsections. Then, Pğ‘– obtains her/his public key ğ‘ğ‘˜ğ‘–
Session 10B: Crypto and Protocol Security CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2622P0
P1
$â† S
ğ‘ sid0
0
Choose
Run AFEM.Enc(ğ‘ğ‘˜1, ğ‘ sid0
Output ğ‘˜sid0
0
= ğ» (ğ‘ğ‘˜0 ||ğ‘ğ‘˜1 ||sid0 ||ğ‘sid0
0
0
) â†’ ğ‘sid0
0
Run AFEM.Dec(ğ‘ ğ‘˜sid
0
Output ğ‘˜sid1
= ğ» (ğ‘ğ‘˜0 ||ğ‘ğ‘˜1 ||sid1 ||ğ‘˜sid0
0
0
(cid:4)
1
, ğ‘sid1
1
(cid:4)
) â†’ ğ‘ sid
1
1
||ğ‘ sid0
0
)
AKE Phase
(Session sid0)
sid0, ğ‘sid0
0
-
(Session sid1)
 sid1, ğ‘sid1
1
)
...
||ğ‘sid1
1
||ğ‘ sid
(cid:4)
1
1
Run AFEM.Dec(ğ‘ ğ‘˜sid
1
Output ğ‘˜sid0
(cid:4)
0
, ğ‘sid0
0
(cid:4)
) â†’ ğ‘ sid
0
= ğ» (ğ‘ğ‘˜0 ||ğ‘ğ‘˜1 ||sid0 ||ğ‘sid0
0
0
$â† S
ğ‘ sid1
1
Choose
Run AFEM.Enc(ğ‘ğ‘˜0, ğ‘ sid1
Output ğ‘˜sid1
1
) â†’ ğ‘sid1
1
= ğ» (ğ‘ğ‘˜0 ||ğ‘ğ‘˜1 ||sid1 ||ğ‘˜sid0
1
1
1
||ğ‘ sid
(cid:4)
0
)
0
||ğ‘sid1
1
||ğ‘ sid1
1
)
Figure 3: Asynchronous mode of our BAKE framework.
by running the public key generation algorithm AFEM.PubGen.
Finally, Pğ‘– sends the public key ğ‘ğ‘˜ğ‘– to P1âˆ’ğ‘– through an authenti-
cated channel, which means that adversaries cannot modify that
public key. Note that the requirement of an authenticated channel
is essential for all authenticated key exchange protocols [6].
In real-world applications, the authenticated channel can be
implemented by Public-Key Infrastructure (PKI) technology [52], in
which an authority generates a certificate to bind an identity and
a public key. Messaging applications also suggest an out-of-band
fashion to authenticate public keys, such as comparing public key
fingerprints and scanning a Quick Response (QR) code [44].
AKE Phase. This phase enables both participants to authenti-
cate each other and negotiate a session key. Specifically, Pğ‘– (ğ‘– âˆˆ
{0, 1}) first chooses a random message ğ‘ ğ‘– . Then, ğ‘ ğ‘– is encapsulated
into ğ‘ğ‘– by running the encapsulation algorithm AFEM.Enc and sent
to P1âˆ’ğ‘– . After receiving ğ‘1âˆ’ğ‘– , Pğ‘– generates a secret key ğ‘ ğ‘˜ (cid:4)
ğ‘– based on
the biometric characteristics and decapsulates ğ‘1âˆ’ğ‘– using the decap-
sulation algorithm AFEM.Dec to obtain ğ‘  (cid:4)
1âˆ’ğ‘– . Finally, Pğ‘– computes
a session key ğ‘˜ğ‘– by a hash function ğ» .
In real-world applications, communicating participants are usu-
ally not online at the same time and a participant may want to
leave a message to an offline participant through a service provider.
To deal with this asynchronous scenario, we design another AKE
phase that allows a unidirectional session key at the beginning as
shown in Figure 3. Roughly speaking, in each session, a session
key is derived from the session ID, a random string chosen by a
participant, and the session key of the last session if it exists. To
obtain the random string encapsulated by the other participant, a
participant needs to generate a fresh secret key based on her/his
biometric characteristics in each session for implicit authentication.
More specifically, for the first session whose ID is sid0, the sender
to generate the session key
P0 first chooses a random message ğ‘ sid0
0
0
0
into ğ‘sid0
, and then encapsulates ğ‘ sid0
ğ‘˜sid0
. When the receiver P1
0
gets online, she/he generates a secret key based on the biometric
characteristics to decapsulate ğ‘sid0
and obtain the session key ğ‘˜sid0
.
Then, the sender P1 launches the second session sid1 to send a
message to the receiver P0, where the new session key ğ‘˜sid1
is
generated by decapsulating ğ‘sid1
. The subsequent session keys could
be negotiated in the same manner, which provides the key rotation
property for our BAKE framework.
1
1
0
1
4.2 Secret Key from Iris
IrisCode [16] is the most widely used iris recognition method due
to its computational advantages, e.g., high matching speed and
accuracy. Over 60 million people are using IrisCode to perform
iris recognition and many other biometric algorithms are extended
from IrisCode [16]. Generally, iris recognition is simply achieved by
computing the Hamming distance between two IrisCodes. In BAKE,
IrisCode is suitable for instantiation by our first AFEM construction
that is illustrated in Section 3.2.
Iris Vector from IrisCode. An iris image is transformed into
4.2.1
random texture after localization, segmentation, and normalization,
which is then encoded into a 2048-bit stream [17]. To construct a
valid secret key for the AFEM construction in Section 3.2, a 2048-bit
IrisCode should be transformed into a vector. We naturally employ
a simple solution to shard a 2048-bit IrisCode into ğ‘š elements that
compose an iris vector. As shown in Figure 4, we take the first
2048/ğ‘š bits as the first element, and take the second 2048/ğ‘š bits
as the second element, and so on. Finally, we obtain an iris vector
v = {ğ‘£1, . . . , ğ‘£ğ‘š }.
4.2.2 Tolerating Iris Noise with Lattice. Due to capture deviation,
the decoding algorithm in Section 3.2 may fail even if the two iris
Session 10B: Crypto and Protocol Security CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2623...
...
01011...00010...10100.........10101...01010...01010
10101...01010...10101.........01001...00111...01100
11111...01111...01010.........10101...01011...10101
01001...01010...10100.........10010...10111...11010
10100...10100...10010.........10101...00101...11101
00101...01001...01000.........01001...01010...00001
01010...10101...00101.........01010...01010...11010
00101...01010...10010.........10100...01010...01010
...
Figure 4: An illustration of constructing an iris vector.
(cid:4) = ğ‘“ (v
vectors are from the same user. To tackle this issue, we expect to
find an algorithm ğ‘“ (Â·) to obtain the same output vectors u = u
(cid:4)
(cid:4), where u = ğ‘“ (v),
from two slightly different iris vectors v and v
(cid:4)). We enforce this goal by solving the ğ›¾-CVP problem [1]
u
on a well-chosen lattice L with Babaiâ€™s algorithm [3]. Roughly
speaking, Babaiâ€™s algorithm maps all vectors close to a certain point
in a lattice to that point, where a lattice is a discrete set of points in
a vector space. Therefore, we employ this algorithm to eliminate
noises in our design.
ğ›¿
Definition 4.1 (Lattice [29]). Let u1, . . . , uğ‘š âˆˆ R
be a set of
linearly independent vectors. The lattice L generated by u1, . . . , uğ‘š
is the set of linear combinations of u1, . . . , uğ‘š,
L = {ğ‘1u1 + ğ‘2u2 + Â· Â· Â· + ğ‘ğ‘š uğ‘š : ğ‘1, ğ‘2, . . . , ğ‘ğ‘š âˆˆ Z}.
Any set of independent vectors that generates L is a basis. The
number ğ‘š of vectors in a basis is known as the dimension for L.
Definition 4.2 (ğ›¾ -Closest Vector Problem [1]). For any approxima-
and a basis for a
ğ›¿
tion factor ğ›¾ (ğ‘š) â‰¥ 1, given a target vector v âˆˆ R
ğ›¿
lattice L âŠ‚ R
, find u âˆˆ L satisfying
(cid:12)u âˆ’ v(cid:12) â‰¤ ğ›¾ (ğ‘š) Â· ğ‘‘ğ‘–ğ‘  (v, L),
where ğ‘‘ğ‘–ğ‘  (v, L) = min
uâˆˆ L
(cid:12)u âˆ’ v(cid:12).
For efficiency, we first choose an orthonormal basis for L. Then
(cid:4), we invoke the
for any two slightly different target vectors v and v
Babaiâ€™s algorithm to achieve
Babai(L, v) = u = u
(cid:4) = Babai(L, v
(cid:4)).
4.3 Secret Key from Fingerprint
Most researches take FingerCode to present the fingerprint, which
is a 640-dimensional vector of integers [11, 58]. However, Finger-
Code is rotation-variant such that rotating a fingerprint image
usually causes distinct FingerCodes as described in [58], which
is not suitable for our first AFEM construction in Section 3.2. In
addition, a 640-dimensional vector is not lightweight enough for
real-world applications.
Another fingerprint recognition method is based on minutiae-
based fingerprint presentation, which consists of a set of minutiae
points [35]. Specifically, a human fingerprint is a unique pattern of
ridges and valleys on the surface of an individual finger. Minutiae
points are defined as the positions of local discontinuities where
the ridge splits or ends, and are typically represented as: 1) an
Pointj,1
vecj,3
Pointj,3
vecj,1
vecj,2
Pointj,2
Pointj
vecj,4
Pointj,4
Figure 5: An illustration of constructing a fingerprint vector.
ğ‘‹ -coordinate, 2) a ğ‘Œ -coordinate, 3) an orientation corresponding
to the angle between the minutiae ridge and the horizontal line
measured in degrees. To extract high-accuracy minutiae points
with varied-quality fingerprint images, the segmentation algorithm
first separates the foreground from the noisy background. Then,
the original ridge flow pattern is kept with an image enhancement
algorithm without introducing false information. Finally, minutiae
points are located accurately with binarized minutiae extraction.
Since minutiae-based fingerprint presentation produces a set
of minutiae points, it is suitable for instantiation by our second
AFEM construction in Section 3.3. Moreover, we note that a good
quality human fingerprint generally contains about 40 âˆ¼ 100 minu-
tiae points and a partial human fingerprint contains much fewer
minutiae points (20 âˆ¼ 30 approximately). The performance of our
BAKE protocol is significantly enhanced with the smaller finger-
print vector set ğ‘› compared to FingerCode.
Fingerprint Vector Set from Minutiae Points. To facilitate the
4.3.1
practicability of our BAKE protocol, we propose a minutiae-based
algorithm to produce a fingerprint vector set of size ğ‘›, where ğ‘› is
the number of minutiae points that a human fingerprint contains.
Specifically, for ğ‘› minutiae points {Point1, . . . , Pointğ‘› } in the X-Y
coordinate space, a fingerprint vector set is constructed as depicted
in Algorithm 2. In this algorithm, every minutiae point is initialized
as the central point for exactly one time. Then, the straight-line
nearest ğœ‡ points are chosen to form a structure as shown in Figure 5.
We take ğœ‡ = 4 as an example. Let Point ğ‘— (ğ‘— âˆˆ [1, ğ‘›]) be the core
point and Point ğ‘—,ğœŒ (ğœŒ âˆˆ [1, 4]) be the top ğœ‡ straight-line nearest
points to Point ğ‘— . We define vecğ‘—,ğœŒ (ğœŒ âˆˆ [1, 4]) as the vector from
Point ğ‘— to Point ğ‘—,ğœŒ . Let ğ‘‘ ğ‘—,ğœŒ denote the length of the vector vecğ‘—,ğœŒ
and ğœ™ ğ‘—,ğœ” (ğœ” âˆˆ [1, 6]) denote the angles. Then, we can represent
vğ‘—,0 = (ğ‘‘ ğ‘—,1, ğ‘‘ ğ‘—,2, ğ‘‘ ğ‘—,3, ğ‘‘ ğ‘—,4, ğœ™ ğ‘—,1, ğœ™ ğ‘—,2, ğœ™ ğ‘—,3, ğœ™ ğ‘—,4, ğœ™ ğ‘—,5, ğœ™ ğ‘—,6). Next, for