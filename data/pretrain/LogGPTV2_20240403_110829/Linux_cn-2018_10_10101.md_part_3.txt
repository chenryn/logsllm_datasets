# Go 运行时调度与栈管理

## Goroutine 调度

尽管 goroutine 采用协作式调度，但 Go 的运行时会自动处理调度。Goroutine 可以在以下情况下让出 CPU 时间：

- 阻塞的通道发送和接收操作。
- `go` 语句，虽然不能保证立即调度新的 goroutine。
- 文件和网络操作等阻塞系统调用。
- 在垃圾回收暂停后。

### 示例

下面的例子展示了上文提到的一些调度点：

- 箭头所示的线程从左侧的 `ReadFile` 函数开始。遇到 `os.Open` 时，线程在等待文件操作完成时被阻塞，因此调度器将线程切换到右侧的 goroutine。
- 当右侧 goroutine 执行直到从通道 `c` 中读取数据时，`os.Open` 调用已完成，调度器将线程切换回左侧并继续执行 `file.Read` 函数，此时再次因文件 I/O 操作而阻塞。
- 调度器再次将线程切换回右侧进行另一个通道操作，该操作在左侧运行期间已解锁，但在通道发送时再次阻塞。
- 最后，当 `Read` 操作完成且数据可用时，线程切换回左侧。

## `runtime.Syscall` 函数

`runtime.Syscall` 函数是 `os` 包中所有函数的基础。只要你的代码调用操作系统，就会通过此函数。对 `entersyscall` 的调用通知运行时该线程即将阻塞，允许运行时启动一个新线程，在当前线程被阻塞时为其他 goroutine 提供服务。这导致每个 Go 进程的操作系统线程相对较少，Go 运行时负责将可运行的 goroutine 分配给空闲的操作系统线程。

## 栈管理

### 内存布局

这是一个进程的内存布局图。我们关注的关键点是堆和栈的位置。传统上，堆位于内存的底部，位于程序（代码）的上方并向上增长；栈位于虚拟地址空间的顶部，并向下增长。

### 保护页

因为堆和栈相互覆盖会导致灾难性的结果，操作系统通常会在栈和堆之间放置一个不可写内存区域，称为保护页。这有效地限制了进程的栈大小，通常约为几兆字节。

### 线程栈

由于线程共享相同的地址空间，每个线程必须有自己的栈。由于难以预测特定线程的栈需求，因此为每个线程的栈和保护页面保留了大量内存。希望这些区域永远不被使用，防护页永远不会被触发。缺点是随着程序中线程数的增加，可用地址空间的数量会减少。

### Go 的栈管理

Go 运行时将大量的 goroutine 调度到少量线程上，但那些 goroutines 的栈需求如何解决呢？Go 编译器不使用保护页，而是在每个函数调用时插入一个检查，以确保有足够的栈来运行该函数。如果没有足够的栈空间，运行时可以分配更多的栈空间。这种机制使得 goroutines 的初始栈可以做得更小，从而使 Go 程序员可以将 goroutines 视为廉价资源。

#### 栈管理示例

- **Go 1.2**：当 `G` 调用 `H` 时，如果栈空间不足，运行时会从堆中分配一个新的栈帧，然后在新的栈段上运行 `H`。当 `H` 返回时，栈区域返回到堆，然后返回到 `G`。
- **热分裂问题**：对于某些类型的代码（通常是递归代码），可能会导致程序的内部循环跨越这些栈边界之一。例如，在程序的内部循环中，函数 `G` 可能在循环中多次调用 `H`，每次都会导致栈拆分。这被称为“热分裂”问题。
- **Go 1.3**：为了解决热分裂问题，Go 1.3 采用了一种新的栈管理方法。如果 goroutine 的栈太小，则不会添加和删除其他栈段，而是分配一个新的更大的栈。旧栈的内容被复制到新栈，然后 goroutine 使用新的更大的栈继续运行。在第一次调用 `H` 之后，栈将足够大，对可用栈空间的检查将始终成功。

## 结论

值、内联、逃逸分析、goroutines 和分段/复制栈是使 Go 成为快速语言的重要特性。这些特性并不是孤立存在的，它们互相支持。例如，运行时将 goroutine 复用到线程上的方式在没有可扩展栈的情况下几乎没有效率。内联通过将较小的函数组合成较大的函数来降低栈大小检查的成本。逃逸分析通过自动将实例从堆移动到栈来减少垃圾回收器的压力，并提供更好的缓存局部性。如果没有可增长的栈，逃逸分析可能会对栈施加太大的压力。

## 致谢

- 感谢 Gocon 主办方允许我今天发言。
- Twitter / Web / Email 详情。
- 感谢 @offbymany, @billkennedy_go 和 Minux 在准备这个演讲过程中提供的帮助。

### 相关文章
1. [听我在 OSCON 上关于 Go 性能的演讲](https://dave.cheney.net/2015/05/31/hear-me-speak-about-go-performance-at-oscon)
2. [为什么 Goroutine 的栈是无限大的？](https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite)
3. [Go 的运行时环境变量的旋风之旅](https://dave.cheney.net/2015/11/29/a-whirlwind-tour-of-gos-runtime-environment-variables)
4. [没有事件循环的性能](https://dave.cheney.net/2015/08/08/performance-without-the-event-loop)

---

**作者简介**

David 是来自澳大利亚悉尼的程序员和作者。自 2011 年 2 月起成为 Go 的贡献者，自 2012 年 4 月起成为提交者。

- **联系信息**
  - Email: [PI:EMAIL](mailto:PI:EMAIL)
  - Twitter: @davecheney

**译者**：[houbaron](https://github.com/houbaron)  
**校对**：[wxy](https://github.com/wxy)  
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出。