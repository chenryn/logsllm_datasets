Read Response: 
onRead
getValue()
Figure 3: Attack 2 - Illustrative message exchange depicting
the access of pairing-protected data by reusing an existing
connection. Note: Dashed lines indicate encrypted trafﬁc.
by ﬁrst writing to certain other characteristics on the tracker.
Despite this, we found that by deploying our second attack,
our AttackApp was able to obtain Heart Rate Measurement
readings without the need for performing any “unlocking”.
4    28th USENIX Security Symposium
USENIX Association
This is because the AttackApp connects to the GATT server
by reusing an existing connection that was initiated by the
ofﬁcial application. The unlocking procedure would therefore
already have been performed for that connection by the ofﬁ-
cial application. This result shows that artiﬁcially restricting
access to data using non-cryptographic means will not be
effective. We notiﬁed the device developer of this issue on 01
Nov 2018, but have not yet received a response.
It should be noted that the above attack could be used by a
malicious application to target other sensitive health informa-
tion such as ECG, glucose or blood pressure measurements
from vulnerable BLE devices, to build up a proﬁle on a user’s
health. Further, Smart Home devices and BLE-enabled ve-
hicles may hold information on a user’s habits and lifestyle
(e.g., time at home, alcohol consumption, driving speed), and
could be exploited. It may also be possible for a malicious ap-
plication to overwrite values on the BLE device, such that the
written data either causes unexpected behavior on the device,
or is read back by the legitimate application, thereby giving
the user an incorrect view of the data on the peripheral. For ex-
ample, it may be possible to update the peripheral’s ﬁrmware
via GATT writes. If this mechanism is not suitably protected,
then a malicious application could potentially install mali-
cious ﬁrmware onto the BLE device, as we demonstrate in
Section 4.6.
3.2.2 Comparison with Classic Bluetooth
In their experiments with Classic Bluetooth, Naveed et al.
found that an unauthorized Android application would not
be able to obtain data from a Classic Bluetooth device if
the authorized application had already established a socket
connection with the device, as only one application can be
in communication with the device at one time. Therefore, a
malicious application would either require some side-channel
information in order to determine the correct moment for data
access, or would need to interfere with the existing connec-
tion, thereby potentially alerting the user [31]. This limits the
attack window for the malicious application. Our experiments
show that this is not the case with BLE communication chan-
nels. With BLE, there are no socket connections and if the
ofﬁcial application has established a connection with the BLE
device, then this connection can be utilized by any application
that is running on the Android device. That is, a malicious ap-
plication does not have to wait for the authorized application
to disconnect before it can access data.
3.2.3 Attack Limitations
The main limitation for the AttackApp in the case of
the ﬁrst attack is that it requires the BLUETOOTH and
BLUETOOTH_ADMIN permissions in its manifest, and also
needs to explicitly request LOCATION permissions at ﬁrst run-
time in order to be able to invoke the BLE scanner. This
enables the AttackApp to connect to the BLE device regard-
less of whether or not another application is also connected,
but increases the risk of raising a user’s suspicions.
In the second attack scenario, the obvious limitation for the
AttackApp that requests only the BLUETOOTH permission is
that the application will only be able to access data from the
BLE peripheral when the peripheral is already in a connection
with (another application on) the Android device. That is, data
access will have to be opportunistic. This can be achieved,
for example, by periodically polling for a list of connected
devices.
3.3 Stakeholders, Mitigation Strategies and
Awareness
In this section, we discuss potential mitigating strategies that
different stakeholders within the BLE ecosystem could im-
plement in order to prevent the attacks detailed in Section 3.1.
We consider the Bluetooth Special Interest Group (SIG), An-
droid (i.e., Google), and BLE device/application developers
as stakeholders.
3.3.1 Bluetooth SIG
The Bluetooth SIG is the group that is responsible for deﬁning
and maintaining the Bluetooth standard, which provides de-
tails on pairing, bonding and BLE attribute permissions. The
SIG also deﬁnes various BLE services, including some that
handle user health information, e.g., the Heart Rate Service
and the Continuous Glucose Monitoring Service. The Blue-
tooth speciﬁcations for these services require only pairing
as a protection mechanism for the characteristics that hold
health-related measurements [9, 10]. This protection is in-
tended to avoid man-in-the-middle attacks and eavesdropping.
However, as shown in Section 3.1, pairing will not prevent
unauthorized Android applications from accessing the sensi-
tive data held in these characteristics.
This issue could be avoided by modifying the Bluetooth
speciﬁcation and introducing speciﬁc security measures for
protecting data at higher layers. However, this would require
changes to all devices within the ecosystem, which may not be
feasible due to the sheer volume of devices and applications
currently available, and which could lead to fragmentation and
reduced interoperability. Despite this, we believe that devel-
opers accessing Bluetooth documentation should at least be
made aware of the risks involved, and have therefore notiﬁed
the SIG via their Support Request Form (17 Dec 2018). We
were informed (19 Dec 2018) that the case had been assigned
to the appropriate team for assessment.
3.3.2 Android
Allowing all applications on an Android device to share BLE
communication channels and long-term keys may well be by
USENIX Association
28th USENIX Security Symposium    5
design, particularly since the BLE standard does not provide
explicit mechanisms for selectively allowing or denying ac-
cess to data based on the source application. This model may
work in some situations, for example on a platform where all
applications originate from the same trusted source. However,
the Android ecosystem is such that, many of the applica-
tions on a device are from different and potentially untrusted
sources. In this scenario, providing all applications with ac-
cess to a common BLE transport opens up possibilities for
attack, as we have demonstrated.
One option to eliminate the problem is to modify how
Android handles BLE communication channels. The modiﬁ-
cation would require some form of association between BLE
credentials and the application that triggers the pairing/bond-
ing process. Each data access request would then be checked
against the permissions associated with the requesting ap-
plication. This approach is favoured by Naveed et al., who
propose a re-architected Android framework which will create
a bonding policy when an application triggers pairing with a
Bluetooth device [31]. This strategy has the advantage that
Bluetooth devices will be protected by default from unautho-
rized access to their data. Further, assuming a suitably strong
pairing mechanism is used, a minimum level of security will
also be guaranteed. However, not only will the operating sys-
tem(s) need to be modiﬁed, but also a mechanism will be
required for ensuring that all users’ mobile devices are up-
dated. Otherwise, it is fairly likely that this measure will result
in a fragmented ecosystem, with some devices running the
modiﬁed operating system with protection mechanisms, and
others running older versions of the OS with no protection.
Regardless of whether or not the above measure is imple-
mented, we believe that developers should be made aware of
the possibility of unauthorized applications accessing their
BLE device data. At present, Android does not mention the
issue in its Developer Guide [3]. In fact, to the best of the
authors’ knowledge, there is only a single document, from
a BLE chipset manufacturer, which explicitly references the
fact that multiple Android applications can simultaneously
use a connection to a BLE device [32]. Apart from this, the
risks of “system-wide pairing” have been mentioned in a
speciﬁcation issued by the Fast ID Online (FIDO) Alliance,
without speciﬁc reference to mobile platforms [20].
We submitted an issue to the Android Security Team on
02 Nov 2018, focusing on the need of clear documentation
so that developers are aware of the need for implementing
additional protection measures if they are handling sensitive
BLE data. The issue was reviewed by the security team and
rated as Moderate severity (16 May 2019), based on Android’s
severity assessment matrix [5].
3.3.3 BLE Device/Application Developers
Despite the BLE stack containing an application layer, it could
be argued that BLE is commonly viewed as a lower-layer tech-
nology for providing wireless communication capabilities, on
top of which higher-layer technologies operate [12, 38]. This
would result in the responsibility of securing user data being
transferred from the Bluetooth SIG or Android to the BLE
application/device developers. At any rate, this is the only
mechanism available at present for protecting data against
access by co-located applications.
That is, rather than relying solely on the pairing provided
by the underlying operating system, developers can imple-
ment end-to-end security from their Android application to
the BLE peripheral ﬁrmware. It may be possible to achieve
such behavior via BLE authorization permissions, because
even though their purpose is to specify a requirement for
end user authorization, the behavior of BLE devices when
encountering authorization requirements is implementation-
speciﬁc. Most modern BLE chipsets implement authorization
capabilities by intercepting read/write requests to the pro-
tected characteristics, and allowing for developer-speciﬁed
validation.
One advantage of this method is that it gives the developer
complete control over the strength of protection that is applied
to BLE device data, as well as over the timings of security
updates. However, leaving the implementation of security to
the developer runs the risk of cryptography being applied
improperly, thereby leaving the data vulnerable [17]. For
existing developments, retroﬁtting application-layer security
would mean that both an update for the Android application
and a ﬁrmware update for the BLE device would be required,
and there is a risk that the BLE ﬁrmware update procedure
itself may not be secure [6].
Due to the lack of clear guidelines regarding attribute secu-
rity in both the Android Developer Guide and the Bluetooth
speciﬁcation, it is also possible that developers implement no
security at all, due to an assumption that protection will be
handled by pairing. In the next section, we test this assertion
of a lack of developer awareness by exploring the current state
of application-layer security deployments via a large-scale
analysis of BLE-enabled Android applications.
4 Marketplace Application Analysis
As evidenced by our experiments, it is fairly straightforward
for any Android application to connect to a BLE device and
read or write pairing-protected data. As discussed in Sec-
tion 3.3, the only strategy available at present is for developers
to implement application-layer security, typically in the form
of cryptographic protection, between the Android application
and the BLE peripheral.
In this section, we identify the proportion of applications
that do not implement such security mechanisms, to demon-
strate a possible lack of awareness surrounding the issue, and
to be able to estimate the number of devices that are poten-
tially vulnerable to the types of attack shown in Section 3.1.
6    28th USENIX Security Symposium
USENIX Association
3012 [1263]
1501 [1006]
1489 [950]
1428 [891]
1268 [685]
948 [545]
526 [305]
446 [284]
406 [239]
313 [225]
383 [190]
348 [181]
407 [177]
395 [146]
259 [126]
236 [119]
146 [87]
114 [80]
203 [77]
746 [516]
Table 1: APKs and Downloads per Google Play Category
Category
APKs [packages] Downloads(mn)
Health & Fitness
Lifestyle
Business
Tools
Sports
Travel & Local
Productivity
Entertainment
Music & Audio
Education
Shopping
Maps & Navigation
Medical
Communication
Finance
Auto & Vehicles
Food & Drink
Photography
Social
Other
a We make the assumption that all versions of an application
fall under the same category.
b Some APKs within the dataset are no longer available on
Google Play and hence, have no corresponding category.
These have not been included.
344.95
52.60
39.62
6308.62
17.74
31.83
43.05
128.41
51.48
3.35
144.87
33.21
5.68
755.89
96.38
4.13
6.23
45.78
663.43
258.41
To identify the presence of application-layer security, there
are two possible targets for analysis: BLE peripheral ﬁrmware
or Android applications. At present, there is no public reposi-
tory of BLE ﬁrmware, which means that the ﬁrmware would
need to be obtained from the peripherals themselves. This
would necessitate the purchase of a large number of de-
vices and would not be ﬁnancially viable. Further, reverse-
engineering and analyzing BLE ﬁrmware is not straightfor-
ward, as the ﬁrmware image is usually a .hex ﬁle, which can
typically only be converted to binary or assembly. Android
APKs, on the other hand, are easier to obtain, and a number
of decompilers exist that allow for conversion of APKs to a
human-readable format.
We therefore target Android applications for our analysis
and perform the following: (1) obtain a substantial dataset of
BLE-enabled Android APKs, (2) determine the BLE method
calls and the cryptography libraries of interest, and (3) deﬁne
a mechanism to determine whether BLE reads and writes
make use of cryptographically processed data. We then apply
this mechanism to our dataset and analyze the results.
4.1 APK Dataset
We obtained our dataset from the AndroZoo project [1]. This
is an online repository that has been made available for re-
search purposes and which contains APKs from several differ-
ent application marketplaces. We focus on only those APKs
that were retrieved from the ofﬁcial Google Play store, which
nevertheless resulted in a sizeable dataset of over 4.6 million
APKs. This dataset includes multiple versions for each ap-
plication, as well as applications that are no longer available
on the marketplace. We performed our analysis over the en-
tire dataset, rather than focusing on only those APKs that
are currently available on Google Play. This was in part be-
cause older versions of an application may still be residing
on users’ devices, and in part to be able to identify trends in
application-layer security deployments over time.
As we are only interested in those applications that per-
form BLE attribute access, and because such access always
requires communicating with the GATT server on the BLE
peripheral, the APKs were ﬁltered by the BLUETOOTH permis-
sion declaration and by calls to the connectGatt method,
which is called prior to performing any data reads or writes.
18,929 APKs, comprising 11,067 unique packages1, from the
original set of 4,600,000+ APKs satisfy this criteria, and these
formed our ﬁnal dataset.
Application Categories
Applications are categorized in Google Play according to their
primary function, such as “Productivity” or “Entertainment”,
and it may be possible to gauge the sensitivity of the BLE data
handled by an application based on the category it falls under.
For example, “Health and Fitness” applications are probably
more likely to hold personal user data than “Entertainment”
applications.
The number of APKs per category has been listed in Table 1
for our dataset. Approximately 23% of the APKs (18% of
unique applications) fall under the categories of “Health and
Fitness” and “Medical”, with a cumulative download count
of over 350 million. Note that the disproportionately high
volume of downloads for the category “Tools” is due to the
Google and Google Play applications, which include BLE
capabilities and are installed on most Android devices.
4.2
Identiﬁcation of BLE Methods and
Crypto-Libraries
We perform our analysis against speciﬁc BLE methods
and crypto-libraries. When considering BLE methods, we
focus on those methods that involve data writes and
1An Android application may have many versions, each of which will be
a separate APK ﬁle (with a unique SHA256 hash), but all of which will have
the same package name. We use the terms “unique applications” or “unique
packages” to denote the set of APKs that contain only the latest version of
each application.
USENIX Association
28th USENIX Security Symposium    7
Access
Read
Write
Table 2: BLE Data Access Methods
Method Signaturea
byte[] getValue ()
Integer getIntValue (int, int)
String getStringValue (int)
Float getFloatValue (int, int)