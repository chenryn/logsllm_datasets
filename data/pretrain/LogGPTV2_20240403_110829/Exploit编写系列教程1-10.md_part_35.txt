一种标准，它可以使电脑得以体现世界上数十种文字的系统。Unicode 是基于通用字符集（Universal Character
Set）的标准来发展，并且同时也以书本的形式（The Unicode Standard，目前第五版由Addison-Wesley Professional
出版，ISBN-10: 0321480910）对外发表。Unicode包含了超过十万个字符（在2005年，Unicode的第十万个字
符被采纳且认可成为标准之一）、一组可用以作为视觉参考的代码图表、一套编码方法与一组标准字符编码、一
套包含了上标字、下标字等字符特性的枚举等。”
简而言之，unicode 可以帮助我们在世界多数操作系统上以统一的方式直观地表示和/或操作文本。因此，
程序可实现跨全球性，而无需担心在电脑上会显示乱码。相信大部分读者或多或少都对ASCII比较熟悉。实质
上，它是使用7 bits来表示128个字符，经常是以8bits来存储它们，或者每字符一字节。每字符以00开头，
末尾以低于等于 7F 的十六进制表示（参见 ASCII 码表：http://www.asciitable.com）。你也可以在下列网站查看
各类Unicode字符码：http://unicode.org/charts/index.html
例如：字符’A’的ASCII码 = 41（十六进制），而用Basic Latin Unicode表示则为0041。
还有很多其它的代码页（译注：codepage 就是各国的文字编码和 Unicode 之间的映射表），其中有些并不是以
00开头，这些很重要，需要记住它们。
用 unicode 表示有很大的用处，但为什么还有很多信息用 ASCII表示呢？那是因为大多数的应用程序使用到字
符串，它们都是以NULL字节表示字符串结束。所以如果你将unicode数据转换成ASCII字符串，字符串就会
被中断掉…这也是为什么许多程序（smtp,pop3 等等）依然使用 ASCII 来表示明文以用于通讯设置的原因。
（payload可以用unicode编码，但通讯工具本身是使用ASCII编码的。）
如果你将ASCII文本转换成Unicode（codepage为ansi），那么在每一字节前就会被加上“00”。因此AAAA
就会被转换成0041 0041 0041 0041。当然，这是数据转换成宽字符的结果，一些unicode转换结果依赖于所使
用的代码页。
下面看下MultiByteToWideChar函数原型（用于将字符串转换成宽字符unicode字节串）：
int MultiByteToWideChar(
UINT CodePage,
DWORD dwFlags,
LPCSTR lpMultiByteStr,
int cbMultiByte,
LPWSTR lpWideCharStr,
int cchWideChar
);
其中参数CodePage比较重要，它可能为以下值：
CP_ACP（Ansi code page，用于windows系统，也可用于utf-16），CP_OEMCP（OEM code page），CP_UTF7
（UTF-7 code page），CP_UTF8（UTF8 code page）等等。
lpMultiBytestr 参数指向用于转换的字符串，而 lpWideCharStr 参数指向用于保存转换后的 uicode字符串的缓冲
区地址。
因此说“unicode = 00 + 原始字节”是错误的，它依赖于code page。
你可以通过查看“Regional and Language Options”来获得系统上使用的code page类型，如下图所示：
在 FX 的文章（http://www.blackhat.com/presentations/win-usa-04/bh-win-04-fx.pdf）中有一份 ASCII 字符表（十
六进制），用各种unicode hex表示（ansi,oem,utf-7和utf-8）。你可能会注意到，在ASCII 0x80之后，一些ansi
并不包含 null 字节（它们被转换成 0xc200XXXX 或者 0xc300XXXX），一些OEM转换则更为不同。我们需要
记住的是在01h与7fh之间的ASCII字符，它们转换成unicode后会被添加null字节，稍后我们会用到这一知
识。
一些开发者可能出于某种目的才使用这一功能，但最主要的原因还是上面提及的。有些开发者可能甚至都
不知道程序在创建或编译时会被扩展成 unicode。实际上，一些 Win32 API 函数在使用前经常转换字符串为
Unicode。在一定情况下，比如Visual Studio，所使用的API是否被转换成unicode主要依赖于_UNICODE宏的
使用。如果该宏被设置了，那么处理例程及输入数据都会转换成unicode进行处理，API函数可能也因此改变。
比如，CreateProcess 函数会被转换成 CreateProcessW（Unicode）或者 CreateProcessA（Ansi），这主要依赖于
_UNICODE宏的设置状态。
Unicode转换结果对构造exploit的影响
对于 0x00与 0x7f之间的字符，当这些输入字符串被转换成ansi unicode时，被自动被添加 null 字节。而
0x7f以上的字符会被转换成其它2字节，这2字节并不需要包含原有字节。这就对我们构造exploit和shellcode
产生一定的负面影响。在前面的教程中，我们使用4字节去覆盖EIP（包括其它内部数据的覆写）。对于Unicode，
你只需要用2字节（因此另外2字节会被转换成null，所以你也得去控制这些NULL）。
另外，对于一些指令集（用于shellcode和跳转等等）将会受到一定限制。更为重要的是，大多数字节前都会被
添加上 null 字节，而在>0x7f 之上的字符会被转换成完全不同的字节。在 Phrack 上的文章（见 chapter 2）
(http://www.phrack.org/issues.html?issue=61&id=11#article)讲述了哪些指令不能再用了。
现在原本简单的事情（比如一连串的 nops(0x90)）都成了问题，因此出于对齐， nop 会变成指令 0090(或
者009000)，这已经不再是nop了。现在看起来确实存在许多困难，也难怪之前人们都认为它们是不可利用的。
阅读文档
（译注：这部分内容主要是讲作者通过查看一些文档，寻求解决的方法，并向一些专家请教，可惜都没有回复，
不过最后有一个人给它回复了，帮了他的忙，这部分都是作者的一些唠叨，因此在译文里面将其省略，以省略
时间^_^）。
当缓冲区数据被转换成unicode后是否还可构造出exploit呢?
第一步
首先，你需要知道这里并没有提供各种创建unicode exploit的模板。每个exploit可能是不同的，它要求有不同
的处理方式，也可能需要付出更多的工作和努力。这可能涉及到偏移，寄存器和指令，然后再写你自己的venetian
shellcode。因此本文所讲述的内容，对于你的实际操作可能没有帮助。本文结合实例向读者展示各种技术，希
望对你创建出自己的exploit有所帮助。
EIP=0x00410041
在之前的教程中，我们主要讨论了两种利用方式：直接覆盖RET和SEH。这两种覆盖方式对于unicode exploit
依然是有效的。在典型的栈溢出中，你可以使用4字节覆盖RET，或者用8字节覆盖SEH区域（next SEH和
SEH Handler），但你只能控制其中一半的字节。为了能够继续控制 EIP，我们需要如何利用呢？答案很简单：
用2字节来覆盖EIP。
直接覆盖RET控制EIP
控制EIP后的主要目的就是跳到shellcode，这点依然不变，无论是ASCII还是 unicode缓冲区溢出。在覆盖返
回地址的方法中，你需要找到一个指向指令（或者一连串指令）的地址来帮助你执行到shellcode，然后用这一
地址覆盖EIP。接着找到一个指向缓冲区的寄存器（即使在每一字符中包含null字节也不用担心），令执行流跳
转到该寄存器。但是这里仅有的一个问题就是，该地址必须以特定格式存在，一个即使添加了00而依然有效的
地址。因此这对我们来说，只有两种选择：
1、找到jump/call/…指令地址，比如0x00nn00mm。如果你用0xnn,0xmm覆盖RET，就会变成0x00nn00mm。
2、找到一个格式为0x00nn00mm的地址，它必须位于call/jump/…指令地址附近。修改此地址与call/jump地址
之间的指令并不会破坏到你的堆栈和寄存器，可以放心使用该地址。
如何查找这类地址呢？
FX写了一个很好的OD插件OllyUNI，或者我写的ImmDbg插件pvefindaddr。假设你需要跳转至eax，那么下
载pvefindaddr.py并将其放在ImmDbg安装目录下的pyCommand文件夹中，然后在ImmDbg命令行中输入以下
命令：
!pvefindaddr j eax
它将会列出所有”jump eax”指令的地址。这些地址不仅会在log view中显示，还可写入名为j.txt的文本文件中。
打开文件搜索“Unicode”即可找到以下两类地址：一类为“Maybe Unicode compatible”，一类为“Unicode
compatible”。
如果你找到“Unicode compatible”这类地址，并且地址格式为0x00nn00mm，那么你就可以使用其中一个
地址来覆盖返回地址。如果你找到的是“Maybe Unicode compatible”一类的地址，那么你也需要查看这些地址
是不是以0x00nn0mm格式存在的。如果这些指令在0x00nn00mm和0x00nn0mmm之间，你可以看到这些指令
对程序流程/寄存器并无多大负面影响，然后你就可以使用 0x00nn00mm 样的地址了（它将一直执行到位于
0x00nn0mmm的call/jump指令）。实际就是跳转到接近真正jump指令的地址，但愿这一地址与真实跳转地址之
间的指令不会把你给KO掉。
OllyUNI的使用也是大同小异，它也可找到一些 Unicode 地址，实际上是一些 call/jump reg/…指令（因此你需
要通过查看日志，进而判断这些地址是不是跳转到所期望的寄存器）。
通常我们要找的地址中，在其右边都会包含有null字节。如果EIP是0x00nn00mm的形式，那么你就必须找到
相同格式的地址；如果EIP是0xnn00mm00，那么你也必须找出与之相同格式的地址。
之前我们总是尽量避免null字节，因为它是一个字符串终止符。但现在我们需要包含null字节的地址了。
不过我们不用担心字符串会被中断，因为被发送到程序的字符串并不会被置入null字节。而对于unicode转换，
它将自动插入null字节。假设拥有一个用于跳转的指令地址，该地址为0x005E0018，这地址并没包含>7f的字
符，因此它可正常工作。假设你已知道覆盖EIP需要的字节数（可以使用metasploit pattern来计算），下面我将
结合实例来讲述如何利用它。
假设发送500个A可覆盖EIP，那么你可以用“jump eax”（因为EAX指向A’s）指令地址（0x005e0018）
来覆盖EIP，脚本代码如下：
my $junk="A" x 500;
my $ret="\x18\x5e";
my $payload=$junk.$ret;
用5E 18覆盖EIP之后，Unicode会在5E和18之前加上null字节，变成005e0018，因此EIP将会变成0x005e0018。
基于SEH：控制EIP + short jump？
如果漏洞是基于SEH呢？通过教程第三篇及第3b篇，我们知道需要用pop pop ret地址来覆盖SEH Handler，
而用一个short jump地址来覆盖nSEH。对于unicode，你依然需要用pop pop ret地址来覆盖SEH Handler，这
个可以用pvefindaddr帮忙：
!pvefindaddr p2
它将会在 log 中输出结果，同时保存在 ppr2.txt 文件中。打开文件并搜索“Unicode”。如果你找到并不包含>7f
的入口地址，那么你就可以用它来覆盖SEH Handler。另外，要省略到null字节，因为它们经unicode转换后会
被自动添加上。在nseh上，我们用\xcc\xcc（两个断点，2字节，同样会被添加null字节）覆盖掉，看看结果如
何。如果一切顺利，那么pop pop ret会被执行，然后重定向到第一个断点上。对于非unicode exploit，就需要用
一个short jump替换这些nseh上的这些断点，然后通过SEH Handler地址跳转至shellcode。但在unicode上用
short jump地址覆盖SEH，只需2字节，并被null字节分隔，但不用将null计算在内，否则就不能正常工作。
基于SEH：jump
这里补充一个理论知识，以帮忙大家更好地理解后面的实例。
理论知识：不用short jump(0xeb,0x06)去覆盖nSEH，而用一些无害代码替代来覆盖nSEH，以使其能够执行到
被覆写的SEH结构之后，然后用再将执行代码放置于被覆盖的SEH结构之后，这样跳过nSEH和SEH之后就
执行我们的代码了。
为达到这目的，我需要完成以下两步：
● 一些无害指令，当执行时并不会造成任何危害，我们将它放置在nSEH中；
● “Unicode compatible”的地址用来覆盖SEH Handler，并且要求当执行它时并不会造成任何危害。
后面我将更为详细地解释这些内容。
我们是否只需将EIP覆盖为0x00nn00nn?
当 你 再 回 头 看 unicode translation table 时
（http://www.blackhat.com/presentations/win-usa-04/bh-win-04-fx.pdf），你可能会萌发其它获取各个 0x00nn00nn
格式地址想法。在ASCII Hex值>0x7f时，经unicode转换后都会被变成完全不同的值。例如0x82会变成1A20,
因此如果你看到0x00nn201A这样格式的地址，你就可以用0x82来替换201A。
如果创建一个基于SEH的exploit，那么可能会遇到一个问题，因为pop pop ret之后，地址字节是作为指令
来执行的。只要指令作为nops或者其它没有太大变化的操作，就没有问题。我猜可能你会去尝试各个”unicode
compatible”地址，看这些地址是否可以正常工作。在此你同样可以使用pvefindaddr(Immdbg plugin)来查找符合
unicode compatible的pop pop ret地址。看下地址，你可能会发现它们都是以下列字节开对或结尾的：
ac20 (=80 ASCII), 1a20 (=82 ASCII), 9201 (=83 ASCII), 1e20 (=84 ASCII)等等（读者可自行查看转换表），可能不
会成功，但仍值得去尝试。
准备运行shellcode，但shellcode准备好了吗？
现在我们已知知道该用什么地址去覆盖EIP了，但如果你再查看一下你的ASCII shellcode会发现：它也包含有
null 字节，如果使用 0x7f 以上的指令（机器码），那么指令可能会被更改。我们该如何让它可正常工作呢？是
否有种方法可将ASCII shellcode转换成unicode compatible shellcode呢，比如使用metasploit生成，或者自己编
写出这样的程序？
Shellcode：技巧1：查找等效ASCII并跳转到该处
在多数情况下，ASCII字符串被程序放入内存中的堆栈后，都会被转换成unicode，因此你可能在其中找到
ASCII版本的 shellcode。如果你能控制EIP，使其跳转到指定地址，那么就有可能实现 exploit。如果 ASCII版
本的 shellcode 无法直接达到（通过跳转到寄存器），但你又可以控制某一寄存器的内容，那么你依然可以跳转
到那寄存器，然后在其指向的地址上放置一些跳转代码，使其跳转到ASCII版本的shellcode上。稍后我们将讨
论这些跳转代码。
读者可以在下列地址找到一个使用此技术的实例：http://www.milw0rm.com/exploits/6302
Shellcode：技巧2：编写自己的unicode-compatible shellcode
这个确实有点难度，但却是最好的方法（见技巧3）
Shellcode：技巧3：使用编码器
我们已知知道用metasploit生成或自己编写的shellcode将无法正常工作，如果它不是针对unicode编写的，
那么都将会失败（插入null字节，机器码被更改等等）。幸运的是，一群聪明的人(Dave Aitel, FX and Skylined)
编写出了一些现成的工具（基于venetian shellcode理论），既而解决了这类问题。
实际上就是将 ASCII shellcode 编码成 unicode-compatible 代码，并在其前端放上解码器（也是
unicode-compatible）。经解码后，它就可以生成原始代码并执行。
这里主要有两种可以实现以上效果：一种是通过在特定的内存地址上重构原始代码，然后跳转到那个地址；
另一种是通过改变代码的执行流程，使其运行到重构的shellcode上。你可以在相应文档或者文章开头引用的文
章中了解到这些工具。第一种技巧要求做到2点：其中某寄存器必须指向decoder+shellcode的入口地址，另一
个寄存器必须指向可写的内存地址（用于写入生成的 shellcode）。第二种技巧只须使用到一个指向
decoder+shellcode入口地址的寄存器即可，同时让原始shellcode经重构后保存在该处。
下面介绍一些相关工具及其用法。
1.makeunicode2.py(Dave Aitel)
此脚本是 CANVAS 中的，是 Immunity 的一个商业工具（http://www.immunitysec.com/products-canvas.shtml）。
由于我没有注册码，因此无法对其进行测试，自然也就不能讲述它的用法了。
2.vense.pl(FX)
下载地址：http://www.phenoelit-us.org/win/
这 是 FX 在 BlackHat 2004 大 会 上 面 所 公 布 的 一 个 工 具
（http://www.blackhat.com/presentations/win-usa-04/bh-win-04-fx.pdf），这一强大的perl脚本出现后，又有了一个
经改良的makeunicode2.py。
该脚本生成的是一字节字符串，包含有decoder和原始shellcode。因此可以在buffer中替换成由metasploit
生成的shellcode，vense.pl的输出数据也会放置在buffer中。为了使用decoder，你还需要采用以下方法设置寄
存器：一个寄存器直接指向 buffer 入口地址，用于存放由 vense.pl 生成的 shellcode。第二寄存器需要指向一段
可写可执行（RWX）的内存地址，以能够向其写入数据。假设这里存放生成的 shellcode 的入口地址位于 eax
中，而edi指向可写内存地址：
编辑vense.pl，并将$basereg和$writable参数设置为要求的值。
向下滚动可以看到变量$secondstage，删除其中的内容，并替换为由metasploit生成的perl shellcode（这是一个
ASCII shellcode，并解码后可正常执行）。
保存文件，然后运行脚本，将会输出以下内容：
● 原始shellcode
● 新生成的shellcode（包含decoder）
接着将新生成的shellcode放入你的exploit，将确保eax指向shellcode的入口地址，除非特别幸运，否则你可能
得重新调整寄存器。寄存器设置好了之后，运行”jump eax”，解码器就是提取出原始shellocde并执行它。下一
节中将向您讲述如何设置/调整寄存器，并使用unicode-compatible代码实现跳转。
注意1：生成的encoder+shellcode只有在转换成unicode后才能执行，因此你不能在non-unicode exploit上使用
这类shellcode。
注意2：虽然脚本中使用的算法是经makeunicode2.py改善后的版本，但依然会生成很长的shellcode，所以要求
缓冲区空间（或者短而简单的shellcode）要足够大才行。