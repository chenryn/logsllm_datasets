case the session does not use the circular log mode. Its execution logic is
simple. After it’s started, it links itself to the ETW_LOGGER_CONTEXT data
structure representing the associated ETW session and waits on two main
synchronization objects. The Flush event is signaled by ETW every time a
buffer belonging to a session becomes full (which can happen after a new
event has been generated by a provider—for example, as discussed in the
previous section, “Providing events”), when a new real-time consumer has
requested to be connected, or when a logger session is going to be stopped.
The TimeOut timer is initialized to a valid value (usually 1 second) only in
case the session is a real-time one or in case the user has explicitly required it
when calling the StartTrace API for creating the new session.
When one of the two synchronization objects is signaled, the logger thread
rearms them and checks whether the file system is ready. If not, the main
logger thread returns to sleep again (no sessions should be flushed in early
boot stages). Otherwise, it starts to flush each buffer belonging to the session
to the log file or the real-time consumer.
For real-time sessions, the logger thread first creates a temporary per-
session ETL file in the %SystemRoot%\ System32\LogFiles\WMI\RtBackup
folder (as shown in Figure 10-35.) The log file name is generated by adding
the EtwRT prefix to the name of the real-time session. The file is used for
saving temporary events before they are delivered to a real-time consumer
(the log file can also store lost events that have not been delivered to the
consumer in the proper time frame). When started, real-time auto-loggers
restore lost events from the log file with the goal of delivering them to their
consumer.
Figure 10-35 Real-time temporary ETL log files.
The logger thread is the only entity able to establish a connection between
a real-time consumer and the session. The first time that a consumer calls the
ProcessTrace API for receiving events from a real-time session, ETW sets up
a new RealTimeConsumer object and uses it with the goal of creating a link
between the consumer and the real-time session. The object, which resolves
to an ETW_REALTIME_CONSUMER data structure in the NT kernel, allows
events to be “injected” in the consumer’s process address space (another
user-mode buffer is provided by the consumer application).
For non–real-time sessions, the logger thread opens (or creates, in case the
file does not exist) the initial ETL log file specified by the entity that created
the session. The logger thread can also create a brand-new log file in case the
session’s log mode specifies the EVENT_TRACE_FILE_MODE_NEWFILE
flag, and the current log file reaches the maximum size.
At this stage, the ETW logger thread initiates a flush of all the buffers
associated with the session to the current log file (which, as discussed, can be
a temporary one for real-time sessions). The flush is performed by adding an
event header to each event in the buffer and by using the NtWriteFile API for
writing the binary content to the ETL log file. For real-time sessions, the next
time the logger thread wakes up, it is able to inject all the events stored in the
temporary log file to the target user-mode real-time consumer application.
Thus, for real-time sessions, ETW events are never delivered synchronously.
Consuming events
Events consumption in ETW is performed almost entirely in user mode by a
consumer application, thanks to the services provided by the Sechost.dll. The
consumer application uses the OpenTrace API for opening an ETL log file
produced by the main logger thread or for establishing the connection to a
real-time logger. The application specifies an event callback function, which
is called every time ETW consumes a single event. Furthermore, for real-time
sessions, the application can supply an optional buffer-callback function,
which receives statistics for each buffer that ETW flushes and is called every
time a single buffer is full and has been delivered to the consumer.
The actual event consumption is started by the ProcessTrace API. The API
works for both standard and real-time sessions, depending on the log file
mode flags passed previously to OpenTrace.
For real-time sessions, the API uses kernel mode services (accessed
through the NtTraceControl system call) to verify that the ETW session is
really a real-time one. The NT kernel verifies that the security descriptor of
the ETW session grants the TRACELOG_ACCESS_REALTIME access right
to the caller process’s token. If it doesn’t have access, the API fails and
returns an error to the controller application. Otherwise, it allocates a
temporary user-mode buffer and a bitmap used for receiving events and
connects to the main logger thread (which creates the associated
EtwConsumer object; see the “ETW logger thread” section earlier in this
chapter for details). Once the connection is established, the API waits for
new data arriving from the session’s logger thread. When the data comes, the
API enumerates each event and calls the event callback.
For normal non–real-time ETW sessions, the ProcessTrace API performs
a similar processing, but instead of connecting to the logger thread, it just
opens and parses the ETL log file, reading each buffer one by one and calling
the event callback for each found event (events are sorted in chronological
order). Differently from real-time loggers, which can be consumed one per
time, in this case the API can work even with multiple trace handles created
by the OpenTrace API, which means that it can parse events from different
ETL log files.
Events belonging to ETW sessions that use circular buffers are not
processed using the described methodology. (There is indeed no logger
thread that dumps any event.) Usually a controller application uses the
FlushTrace API when it wants to dump a snapshot of the current buffers
belonging to an ETW session configured to use a circular buffer into a log
file. The API invokes the NT kernel through the NtTraceControl system call,
which locates the ETW session and verifies that its security descriptor grants
the TRACELOG_CREATE_ONDISK access right to the calling process’s
access token. If so, and if the controller application has specified a valid log
file name, the NT kernel invokes the internal EtwpBufferingModeFlush
routine, which creates the new ETL file, adds the proper headers, and writes
all the buffers associated with the session. A consumer application can then
parse the events written in the new log file by using the OpenTrace and
ProcessTrace APIs, as described earlier.
Events decoding
When the ProcessTrace API identifies a new event in an ETW buffer, it calls
the event callback, which is generally located in the consumer application. To
be able to correctly process the event, the consumer application should
decode the event payload. The Event Trace Decode Helper Library (TDH.dll)
provides services to consumer applications for decoding events. As discussed
in the previous sections, a provider application (or driver), should include
information that describes how to decode the events generated by its
registered providers.
This information is encoded differently based on the provider type.
Manifest-based providers, for example, compile the XML descriptor of their
events in a binary file and store it in the resource section of their provider
application (or driver). As part of provider registration, a setup application
should register the provider’s binary in the
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publish
ers registry key. The latter is important for event decoding, especially for the
following reasons:
■    The system consults the Publishers key when it wants to resolve a
provider name to its GUID (from an ETW point of view, providers do
not have a name). This allows tools like Xperf to display readable
provider names instead of their GUIDs.
■    The Trace Decode Helper Library consults the key to retrieve the
provider’s binary file, parse its resource section, and read the binary
content of the events descriptor.
After the event descriptor is obtained, the Trace Decode Helper Library
gains all the needed information for decoding the event (by parsing the
binary descriptor) and allows consumer applications to use the
TdhGetEventInformation API to retrieve all the fields that compose the
event’s payload and the correct interpretation the data associated with them.
TDH follows a similar procedure for MOF and WPP providers (while
TraceLogging incorporates all the decoding data in the event payload, which
follows a standard binary format).
Note that all events are natively stored by ETW in an ETL log file, which
has a well-defined uncompressed binary format and does not contain event
decoding information. This means that if an ETL file is opened by another
system that has not acquired the trace, there is a good probability that it will
not be able to decode the events. To overcome these issues, the Event Viewer
uses another binary format: EVTX. This format includes all the events and
their decoding information and can be easily parsed by any application. An
application can use the EvtExportLog Windows Event Log API to save the
events included in an ETL file with their decoding information in an EVTX
file.
EXPERIMENT: Decoding an ETL file
Windows has multiple tools that use the EvtExportLog API to
automatically convert an ETL log file and include all the decoding
information. In this experiment, you use netsh.exe, but
TraceRpt.exe also works well:
1. 
Open a command prompt and move to the folder where the
ETL file produced by the previous experiment (“Listing
processes activity using ETW”) resides and insert
Click here to view code image
netsh trace convert input=process_trace.etl 
output=process_trace.txt dump=txt
overwrite=yes
2. 
where process_trace.etl is the name of the input log file,
and process_trace.txt file is the name of the output
decoded text file.
3. 
If you open the text file, you will find all the decoded events
(one for each line) with a description, like the following:
Click here to view code image
[2]1B0C.1154::2020-05-01 12:00:42.075601200 
[Microsoft-Windows-Kernel-Process]
Process 1808 started at time 2020 - 05 - 
01T19:00:42.075562700Z by parent 6924
running in session 1 with name 
\Device\HarddiskVolume4\Windows\System32\notepad.
exe.
4. 
From the log, you will find that rarely some events are not
decoded completely or do not contain any description. This
is because the provider manifest does not include the
needed information (a good example is given from the
ThreadWorkOnBehalfUpdate event). You can get rid of
those events by acquiring a trace that does not include their
keyword. The event keyword is stored in the CSV or EVTX
file.
5. 
Use netsh.exe to produce an EVTX file with the following
command:
Click here to view code image
netsh trace convert input=process_trace.etl 
output=process_trace.evtx dump=evtx
overwrite=yes
6. 
Open the Event Viewer. On the console tree located in the
left side of the window, right-click the Event Viewer
(Local) root node and select Open Saved Logs. Choose the
just-created process_trace.evtx file and click Open.
7. 
In the Open Saved Log window, you should give the log a
name and select a folder to display it. (The example
accepted the default name, process_trace and the default
Saved Logs folder.)
8. 
The Event Viewer should now display each event located in
the log file. Click the Date and Time column for ordering
the events by Date and Time in ascending order (from the
oldest one to the newest). Search for ProcessStart with
Ctrl+F to find the event indicating the Notepad.exe process
creation:
9. 
The ThreadWorkOnBehalfUpdate event, which has no
human-readable description, causes too much noise, and
you should get rid of it from the trace. If you click one of
those events and open the Details tab, in the System node,
you will find that the event belongs to the
WINEVENT_KEYWORD_ WORK_ON_BEHALF
category, which has a keyword bitmask set to
0x8000000000002000. (Keep in mind that the highest
16 bits of the keywords are reserved for Microsoft-defined
categories.) The bitwise NOT operation of the
0x8000000000002000 64-bit value is
0x7FFFFFFFFFFFDFFF.
10. 
Close the Event Viewer and capture another trace with
XPERF by using the following command:
Click here to view code image
xperf -start TestSession -on Microsoft-Windows-Kernel-
Process:0x7FFFFFFFFFFFDFFF
-f c:\process_trace.etl
11. 
Open Notepad or some other application and stop the trace
as explained in the “Listing processes activity using ETW”
experiment. Convert the ETL file to an EVTX. This time,
the obtained decoded log should be smaller in size, and it
does not contain ThreadWorkOnBehalfUpdate events.
System loggers
What we have described so far is how normal ETW sessions and providers
work. Since Windows XP, ETW has supported the concepts of system
loggers, which allow the NT kernel to globally emit log events that are not
tied to any provider and are generally used for performance measurements.
At the time of this writing, there are two main system loggers available,
which are represented by the NT kernel logger and Circular Kernel Context
Logger (while the Global logger is a subset of the NT kernel logger). The NT
kernel supports a maximum of eight system logger sessions. Every session
that receives events from a system logger is considered a system session.
To start a system session, an application makes use of the StartTrace API,
but it specifies the EVENT_TRACE_SYSTEM_LOGGER_MODE flag or the
GUID of a system logger session as input parameters. Table 10-16 lists the
system logger with their GUIDs. The EtwpStartLogger function in the NT
kernel recognizes the flag or the special GUIDs and performs an additional
check against the NT kernel logger security descriptor, requesting the
TRACELOG_GUID_ENABLE access right on behalf of the caller process
access token. If the check passes, ETW calculates a system logger index and
updates both the logger group mask and the system global performance
group mask.
Table 10-16 System loggers
IN
DE
X
Name
GUID
Symbol
0
NT kernel logger
{9e814aad-3204-11d2-
9a82-006008a86939}
SystemTraceC
ontrolGuid
1
Global logger
{e8908abc-aa84-11d2-
9a93-00805f85d7c6}
GlobalLogger
Guid
2
Circular Kernel 
Context Logger
{54dea73a-ed1f-42a4-
af71-3e63d056f174}
CKCLGuid
The last step is the key that drives system loggers. Multiple low-level
system functions, which can run at a high IRQL (the Context Swapper is a
good example), analyzes the performance group mask and decides whether to
write an event to the system logger. A controller application can enable or
disable different events logged by a system logger by modifying the
EnableFlags bit mask used by the StartTrace API and ControlTrace API. The
events logged by a system logger are stored internally in the global
performance group mask in a well-defined order. The mask is composed of
an array of eight 32-bit values. Each index in the array represents a set of
events. System event sets (also called Groups) can be enumerated using the
Xperf tool. Table 10-17 lists the system logger events and the classification
in their groups. Most of the system logger events are documented at
https://docs.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-
event_trace_properties.
Table 10-17 System logger events (kernel flags) and their group
Name
Description
Group
ALL_FA
ULTS
All page faults including hard, 
copy-on-write, demand-zero faults, 
and so on
None
ALPC
Advanced Local Procedure Call
None
CACHE_
FLUSH
Cache flush events
None
CC
Cache manager events
None
CLOCKI
NT
Clock interrupt events
None
COMPA
CT_CSW
ITCH
Compact context switch
Diag
CONTM
EMGEN
Contiguous memory generation
None
CPU_CO
NFIG
NUMA topology, processor group, 
and processor index
None
CSWITC
H
Context switch
IOTrace
DEBUG_
EVENTS
Debugger scheduling events
None
DISK_IO
Disk I/O
All except SysProf, 
ReferenceSet, and 
Network
DISK_IO
_INIT
Disk I/O initiation
None
DISPAT
CPU scheduler
None
CHER
DPC
DPC events
Diag, DiagEasy, and 
Latency
DPC_QU
EUE
DPC queue events
None
DRIVER
S
Driver events
None
FILE_IO
File system operation end times 
and results
FileIO
FILE_IO
_INIT
File system operation 
(create/open/close/read/write)
FileIO