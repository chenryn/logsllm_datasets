而言，开始一发动机完成一部件集中到位→组装完成就是关键路径，路径长度为
5.5。
如果我们需要缩短整个工期，去改进轮子的生产效率，哪怕改动成0.1也是无益
于整个工期的变化，只有缩短关键路径上的关键活动时间才可以减少整个工期长度。
例如如果发动机制造缩短为2.5，整车组装缩短为1.5，那么关键路径长度就为4.5，
整整缩短了一天的时间。
那么现在的问题就是如何找出关键路径。对人来说，图7-9-3第二幅这样的AOE
网，应该比较容易得出关键路径的，而对于图7-9-2的A0E网，就相对麻烦一些，如
果继续复杂下去，可能就非人脑该去做的事了。
7.9.1关键路径算法原理
为了讲清楚求关键路径的算法，我还是来举个例子。假设一个学生放学回家，除
279
---
## Page 304
大数据结构
掉吃饭、洗激外，到睡觉前有四小时空闲，面家庭作业需要两小时完成。不同的学生
会有不同的做法，抓紧的学生，会在头两小时就完成作业，然后看看电视、读读课外
书什么的：但也有超过一半的学生会在最后两小时才去做作业，要不是因为没时间，
可能还要再拖延下去。下面的同学不要笑，像是在说你的是吧，你们是不是有过暑假
两个月，要到最后几天才去赶作业的坏毛病呀？这也没什么好奇怪的，拖延就是人性
几大弱点之一，
这里做家庭作业这一活动的最早开始时间是四小时的开始，可以理解为0，而最
晚开始时间是两小时之后马上开始，不可以再晚，否则就是延迟了，此时可以理解为
2。显然，当最早和最晚开始时间不相等时就意味着有空闲。
接着，你老妈发现了你拖延的小秘密，于是买了很多的课外习题，要求你四个小
时，不许有一丝空闲，省得你拖延或偷懒。此时整个四小时全部被占满，最早开始时
间和最晚开始时间都是0，因此它就是关键活动了。
也就是说，我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较
它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。如果不等，
则就不是。
为此，我们需要定义如下几个参数。
1.事件的最早发生时间et（earliesttimeofvertex）：即顶点vk的最早发生时
间。
2.事件的最晚发生时间ltv（hatest timeofvertex）：即顶点v的最晚发生时间，
也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工
期。
3.活动的最早开工时间ete（earliesttimeofedge）：即弧a的最早发生时间。
4.活动的最晚开工时间lte（atesttimeofedge）：即弧ak的最晚发生时间，也就
是不推迟工期的最晚开工时间。
我们是由1和2可以求得3和4，然后再根据ete[k]是否与lte[k]相等来判断a是
杏是关键活动。
7.9.2关键路径算法
我们将图7-9-2的A0E网转化为邻接表结构如图7-9-4所示，注意与拓扑排序时
邻接表结构不同的地方在于，这里弧链表增加了weight城，用来存储弧的权值。
280
---
## Page 305
点
汇点
下标
adjvexweight next
V
24
13A
V
46
35
V
57
38
43A
74
69
76A]
V6
V6
V,
85
93
Va
图 7-9-4
求事件的最早发生时间etv的过程，就是我们从头至尾找拓扑序列的过程，因
此，在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算etv和拓扑序列
列表。为此，我们首先在程序开始处声明几个全局变量。
int*etv，*ltv;/·事件最早发生时间和最迅发生时阁数组*/
int*stack2;
1用于存储拓朴序列的栈*/
int top2:
/*用于stack2的指针·/
其中stack2用来存储拓扑序列，以便后面求关键路径时使用。
下面是改进过的求拓扑序列算法。
1·拓扑排序，用于关键路径计算·/
1Status TopologicalSort(GraphAdjList GL)
2
EdgeNode *e:
4
int i,k,gettop;
5
int top=0;
用于栈指针下标·/
6
int count-0;
/用于统计输出顶点的个数/
281
---
## Page 306
大语数据结构
int *stack;
1建栈将入度为0的项点入税/
8
stack=（int·）malloc（GL->numVertexes·sizeof（int））;
9
for（1-0:inumVertexes;i++)
10
if（0==GL->adjList[i].in）
11
=[do++]x8
12
top2=0;
/*初始化为0*/
13
etv=（int*）malloc（GL->numVertexes*sizeof（int））:/*事价最平发生时间*/
14
for（i=O;inumVertexes;1++)
15
etv[1]=0:
1*初始化为0*/
16
stack2=（int*)malloc（GL->numVertexes*sizeof（int)):/*地化*/
17
while（top!=0)
18
19
20
count++;
21
stack2[++top2]=gettop：/*将弹出的顶点序号压入拓朴序列的栈*/
22
for（e-GL->adjList[gettop].firstedge;e;e=e->next）
23
24
k=e->adjvex;
25
if（！（--GL->adjList[k].in））
26
stack[++top]-k;
27
if（（etv[gettop]+e->weight）>etv[k]）/*水各项点事件最平发生时阅值·/
28
q6TnnumVertexes）
32
return ERROR;
33
else
34
return oK;
代码中，除加粗部分外，与前面讲的拓扑排序算法没有什么不同。
第11~15行为初始化全局变量etv数组、top2和stack2的过程。第21行就是
将本是要输出的拓扑序列压入全局栈stack2中。第27~28行很关键，它是求etv数
组的每一个元素的值。比如说，假如我们已经求得顶点vo对应的etv[0]=0，顶点v对
应的etv[1]=3，顶点v2对应的etv[2]=4，现在我们需要求顶点v对应的etv[3]，其实
就是求etv[1]+len与etv[2]+ken的较大值。显然3+5weight就是当前弧的长度。
etv[1]=3-
长度为5
=6
etv[3]=max(3+5,4+8)=12
Y2
etv[2]=4-
长度为8
图7-9-5
由此我们也可以得出计算顶点v即求etv[k]的最早发生时间的公式是：
erv[k}”
0
当k=0时
[max{ev[]ten1，当k=0且∈P[k]
其中P[K]表示所有到达顶点v的弧的集合。比如图7-9-5的P[3]就是和
两条弧。en是弧上的权值。
下面我们来看求关键路径的算法代码。
/求关键路径，GL为有向网，输出GL的各项关健活动·/
1
void CriticalPath（GraphAdjList GL)
2
EdgeNode *e;
4
int i,gettop,k,j;
S
int ete,lte;
/*声明活动最早发生时间和最退发生时间变量*/
6
TopologicalSort（GL）;
/·求拓扑序列，计算数组etv和stack2的值·/
7
1tv=（int*)malloc（GL->numVertexes*sizeof（int）):/·事件最晚发生时网*/
8
for（i=0;inumVertexes;i++）
9
1tv[i]-etv[GL->numVertexes-1]:/*和始化1tv*/
10
while(top2!=0)
/计算1tv*/
11
12
/将拓补序列出栈，后进先出
13
for（e-GL->adjList[gettop].firstedge;e;e-e->next)
14
（/求各顶点事件的最迟发生时间1tv值*/
15
k-e->adjvex;
16
if（1tv[k]-e->weightnumVertexes;j++）/·求ete，1te和关健活动·/
21
22
for（e-GL->adjList[5l.firstedge;e;e-e->next）
23
24
k-e->adjvex;
25
ete=etv(j];
1活动最平发生时间/
26
.-0-[]-
27
if（ete==lte）
两者相等即在关键路径上·
28
printf（"1ength:td，“,
29
GL->adjList[1].data,GL->adjList[k].data,e->weight);
30
31
321
1.程序开始执行。第5行，声明了ete和lte两个活动最早最晚发生时间变量。
2.第6行，调用求拓扑序列的函数。执行完毕后，全局变量数组etv和栈stack
的值如图7-9-6所示，top2=10。也就是说，对于每个事件的最早发生时间，
我们已经计算出来了。
下标
etv03412151124192427
stack2vovv2vvvovsvvv9
top2↑
图 7-9-6
3.第7~9行为初始化全局变量ltv数组，因为etv[9]=27，所以数组ltv当前的
值为：{27，27，27，27，27，27,27，27,27,27}
4.第10~19行为计算Itv的循环。第12行，先将stack2的栈头出栈，由后进
先出得到gettop=9。根据邻接表中，v没有弧表，所以第13~18行循环体未
执行。
5.再次来到第12.行，gettop=8，在第13~18行的循环中，v的弧表只有一条
，第15行得到k=9，因为ltv[9]-3<ltv[8]，所以Itv[8]=ltv[9]-
284