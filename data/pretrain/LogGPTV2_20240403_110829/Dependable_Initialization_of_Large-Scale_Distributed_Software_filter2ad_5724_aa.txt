title:Dependable Initialization of Large-Scale Distributed Software
author:Jennifer Ren and
Rick Buskens and
Oscar J. Gonzalez
Dependable Initialization of Large-Scale Distributed Software
Yansong (Jennifer) Ren, Rick Buskens and Oscar Gonzalez 
Bell Laboratories, Lucent Technologies 
{reny, rbuskens, ojgonzale}@lucent.com
Abstract
in 
Most
efforts 
documented 
fault-tolerant
computing address  the  problem  of  recovering  from
failures that occur during normal system operation. To 
bring a system to a point where it can begin performing
its  duties  first  requires  that  the  system  successfully
complete initialization. Large-scale distributed systems
may  take  hours  to  initialize.  For  such  systems,  a  key 
challenge  is  tolerating  failures  that  occur during
initialization, while  still  completing  initialization  in  a 
timely manner. In this paper, we present a dependable
initialization model that captures the architecture of the
system  to be  initialized, as well  as  interdependencies
among  system  components.  We  show  that  overall
system  initialization may  sometimes  complete  more
quickly  if  recovery  actions are  deferred  as  opposed  to
commencing  recovery  actions  as  soon  as a  failure  is 
detected. This  observation  leads us  to introduce a
recovery decision  function  that dynamically  assesses
when  to  take  recovery  actions.  We  then  describe  a
dependable  initialization algorithm  that  combines  the
dependable 
the  recovery
decision  function  for achieving  fast  initialization.
Experimental results  show  that  our algorithm  incurs
lower 
a
conventional  initialization algorithm.  This work  is  the
first  effort  we  are  aware of  that  formally  studies  the
challenges of initializing  a distributed  system  in  the
presence of failures.
initialization model  and 
initialization  overhead 
that  of
than 
1.  Introduction 
Initialization refers to the procedure of starting up a 
system  and  bringing  the  system  to  a  point  in  its 
operation  where  it  can  begin  performing  its  normal
function.    For a  system  consisting  of  a  single  software
component  that  operates  in  isolation,  initializing  the
system  is  a  simple  procedure  that  consists  of  creating 
the  software  component  and  setting  the  component's
local 
initial  value.
Initialization complexity increases rapidly, however, as 
the number of system components and their interaction
increases,  due  to  interdependencies  between  system
components.
  Interdependencies  reflect  relationships
information 
some 
state 
to 
system 
between 
that
initialization  actions be properly  sequenced  to  ensure
that interdependency conditions are met.
components 
require 
and
in 
to 
of 
the
presence
or  even 
(such  as 
initialization 
those  encountered 
A key challenge for systems consisting of multiple
components  is  to  initialize  the  system  as  quickly  as
possible 
component
interdependencies.    For  large-scale  distributed  systems
consisting  of  hundreds
thousands  of
components  (such  as 
in  grid
computing [5,10]), this is especially important, as naive
approaches 
initializing
components one at a time) could result in initialization 
times  that  take  hours. A further complication  is  that
failures may occur during initialization.  Restarting the
entire  initialization  procedure  from  the  beginning  may
not  be  desirable  because  of  lengthy  initialization  times
of various system components. However, restarting and
reinitializing  only  the  failed  components  may  not  lead 
to  a  successfully  initialized system  as  dependencies of
fault-free  components  on  the  failed  components  may
prevent  successful  initialization.    For  example,  if  a
failed  component  is  restarted,  interdependent  fault-free
components  must  re-establish  new  communication
channels to the restarted component.
is 
information, 
or  persistent 
feasible,  characteristics  unique 
Traditional  fault  tolerance  research  might  suggest
using  rollback  recovery  as  a  technique  for  recovering
from failures that occur during initialization.  While this
approach 
to 
initialization  can be  exploited  to optimize  recovery
actions  resulting  from  failures  during  initialization.
Basically,  since  all  state  information  introduced  into  a 
component during  initialization  is  either derived  from
hard-coded
such  as 
configuration information  stored  in  a  database, or  is
take  place  during 
determined  from  actions 
initialization 
the
to  a 
communication channel involving another component),
this state information can easily be recreated should the
component  fail.    Note  in  some  cases  that  the  recreated
state may  be  different  from  the  original  state.    Hence,
persisting 
via
  However, undo
checkpointing) 
(e.g.,  closing  a  broken  communication
operations
  Interestingly,  certain 
channel)  are  still  required. 
conditions 
in  a 
that 
(e.g.,  obtaining 
that  hold for  a  specific  stage 
information 
required.
handle 
is  not
(e.g., 
state 
this 
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:51:18 UTC from IEEE Xplore.  Restrictions apply. 
implies 
that  some  completed 
component's  initialization  procedure  may also need  to 
hold for  later  stages  in  the procedure,  although  these
conditions  need  not  hold  throughout  the  procedure.
This 
initialization
activities may need  to  be  repeated  as  part of recovery
(e.g.,  re-open  a  communication  channel  to  another
initialization 
component) while  other  completed 
activities  can  be  skipped  (e.g.,
requesting  static 
configuration information from another component).
the system 
This  paper  examines
dependable  distributed
initialization for software systems, where the goal is to
successfully bring a distributed system to a point where
it  can,  as  quickly  as  possible, begin performing  its
normal  function,  in  spite  of  failures  that may  occur
during  the  initialization  procedure. We first  present  a
dependable  initialization  model  that  captures  both  the
architecture of 
initialized  and 
interdependencies  among  system  initialization  tasks
that  affect  the  order  in  which  these  tasks  must  be 
executed. Using  this  model,  we  describe  an  algorithm
for  constructing  an  initialization  sequencing  graph  that
allows  initialization  tasks  that  do not  need  to  be  re-
executed  as  part  of  failure  recovery  to  be  skipped. We
show  that  there  are  circumstances  where  deferring 
recovery  activities  after  a  failure  is  detected  actually
leads to shorter system initialization times.  To capture
this,  we  introduce  a  recovery  decision  function  that
dynamically  assesses,  based  on  current  initialization
conditions, whether or not  recovery  actions  should  be
taken  immediately  or  deferred. We  then  describe  a 
dependable  initialization  algorithm  that  combines  the
dependable 
the  recovery
decision  function  for  achieving  fast  initialization. We
present  experimental 
the dependable
initialization algorithm  by  comparing it  with  a 
conventional initialization algorithm.
initialization  model  and 
results 
to be 
for 
introduces 
assumptions, 
The reminder of the paper is organized as follows.
Section  2  gives a short  overview  of the system model
and 
dependable
initialization model,  proposes  a  recovery  decision
function  and describes  our  dependable  initialization
algorithm.  Section  3  presents  experimental  results. 
Section 4 revisits our assumptions. Section 5 discusses
related work. Finally, Section 6 concludes the paper.
the
2. Dependable Distributed Initialization
interdependent 
system,  consisting
components, 
We  define distributed  initialization  as  the  process
by  which  a  distributed 
of
communicating, 
is
successfully brought from a non-existent state to a point
where the system can begin its normal operation. In our
model  this means  that  all  components  have  completed
their  individual  initialization  procedures. We  define
dependable distributed initialization as the procedure of
successfully  initializing  the system  even  if  failures 
occur. While we  may  think of  initialization  as  a  'one-
time'  operation,  in  real  systems,  software  updates  may
necessitate  terminating  a  running  system, loading new
software onto the  system,  and  then  re-initializing  the
updated system. Hence, minimizing initialization times
contributes 
increased
availability  and  is  an  important  goal for any  system.
The challenges associated with distributed initialization
are exacerbated in the case where initialization must be
dependable because  of  the  need  to  properly  deal  with
failures that occur during initialization.
reduced downtime  and 
to 
2.1. System Model and Assumptions
We  model 
the  hardware  components  of  a 
distributed  system  as  a  collection  of  processors
interconnected  via  a  communication network.  System
software  is  modeled  as  a  collection  of  processes  that
execute  on  the processors.  Processes  represent  the
smallest execution units that can be started from within
an operating system shell.  Each process contains one or
more application components. In our work, components
are the atomic units of initialization and recovery1.  To 
ease  in understanding  the results  of  this  paper, we
assume that each component has exactly one dedicated
thread of execution2.
We decompose  initialization  into  a  collection of
interdependent  units  of work,  which we  call  tasks,
involving processors, processes, and components.  This 
enables us  to easily  identify  independent  initialization
tasks  that  can execute  in parallel,  helping  to  minimize
overall system initialization time. 
We  assume 
that  a  centralized  coordinator
synchronizes initialization and recovery activities for all 
tasks. It  constructs  an  initialization  graph  that  contains
the  processors,  processes,  components,  tasks  and  their
interdependencies. It triggers the execution of tasks and 
receives notifications once tasks are completed.
We  initially make  simplifying  assumptions  about
  Specifically,  we  assume  that
the  failure  model. 
processors and processes fail by crashing ("fail silent")
and that application components fail either by crashing
or by  not  responding  (e.g.,  due  to deadlocks,  etc.)3.
Failure of a process is modeled as all of the components
1  Introducing  the  notion  of  components  allows  us  to  describe
operational behavior difficult to describe with a simpler model.  It is
also representative of how software systems are built today. 
2 In practice, the mapping of components to execution threads may be
quite  complex  –  components may  share  threads  or may  exclusively 
own more  than  one  thread.    The model  described  in  this  paper
supports any component-to-thread mapping.
3  In  addition  to  threads  associated  with  a  component  blocking,
causing a component to not respond, certain operating systems allow 
threads associated with a component to abort (crash) without causing
the containing process to also crash. 
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:51:18 UTC from IEEE Xplore.  Restrictions apply. 
failing;  similarly,  failure  of  a  processor  is modeled  as
failure of all components within all processes executing
on  the  processor. We  also  assume  that  network
partitions do not occur during system initialization and 
failure detection is accurate. Please note that the above
assumptions are made only to simplify the discussion of
the  novel  aspects  of  our  work;  in  practice,  a  more
realistic set of assumptions must be used (see Section 4 
for further discussion).
The following  subsection  describes  a  simplified
model that we will use throughout the rest of the paper
to represent distributed initialization activities.
2.2. Modeling Initialization Dependencies
We  model  initialization  dependencies using  an 
interdependency  graph –  a  directed  acyclic  graph  with 
an  arc  connecting  an  initialization  task Ti  to  another
initialization task Tj if there is a dependency of Tj on Ti.
This  implies  that Ti  must  be  executed before Tj  can  be
executed. We  call  Ti the  parent  of Tj.    Similarly,  Tj  is 
the  child of Ti.    In  cases  where  a  task  Tj  has  multiple
dependencies,  all  tasks  on  which Tj  depends  must
complete  before Tj  can be executed.   Note  that  this
allows us  to model  dependencies within and  between
components  contained 
the  same or  different
processes running on the same or different processors.
in 
Dependencies  between tasks  identify the  sequence
in  which  the  tasks  must  be  executed.    If  no failures
occur,  correct  initialization  sequencing  is  achieved by
executing a child task as soon as all of its  parent tasks
have  executed.    Independent tasks  may  be  executed  in
parallel.   To  capture  the  fact  that  recovery  actions  do 
not require  some  initialization  tasks  to be  re-executed,
we  distinguish  different  types  of  dependencies.    For
simplicity in our discussion, we identify only two types
of 
and 
operational dependencies.
dependencies:
dependencies 
sequential
  There  are  no  requirements  for 
A sequential  dependency of  task Tj  on  task Ti
simply  requires  that  Tj  cannot  execute  before Ti
completes. 
the
component  associated with Ti  to  remain  failure-free
during  execution of Tj. An example  where  this  occurs
is where Ti writes some data to permanent storage that
is subsequently accessed by Tj.  Should the component
associated  with  Ti  fail  during  execution of Tj, Tj  can
continue  execution 
the data on
permanent storage is not corrupted).
(assuming 
that 
An operational  dependency of  task Tj  on  task Ti
specifies that Tj cannot execute before Ti completes and
that  the  component  associated  with Ti  must  remain
failure-free during execution of Tj. An example where
this  occurs  is  where Ti populates  a  specific  region  of 
memory that is accessed by Tj.  Should the component
associated  with Ti  fail during  execution of Tj,  it  is 
possible  that  the  contents  of  the  memory  region
populated  by Ti may  be  corrupt.    For  these  types  of
dependencies, 
re-
executing Ti before Tj is re-executed.
recovery  actions will 
require
that 
Note 
types  of 
dependencies not  introduced  here  for  the  sake  of
simplicity.  Section 4 discusses this further.
there  are  many  other 
and 
label  an  arc 
Graphically,  we  represent  the  tasks  as  nodes  in  a 
graph, with dependencies represented as arcs. We place 
the  label  ‘S’  on  an  arc  to indicate a sequential
dependency,
representing  an
operational dependency with an ‘O’.  Refer to Figure 1.
For  convenience,  we  label  each task  with  an  identifier
that represents a unique initialization task for a specific 
entity  (component or process).    The  shaded boxes
represent  fault  containment  boundaries  –  components
may fail on their own; a process failure implies that all
of  its  components  fail;  a  processor  failure  implies  that
all processes executing on the processor fail.
Figure 1  shows  a  small  system  consisting of  three
processes,  and  four  components  (for  simplicity  we  do
not  show  the processors). Components  A  and  B  exist
within process  P1,  component  C  exists  within  process
P2,  and  component  D  exists  within  process  P3.    If  we
think of  task P1-0  as  creating  P1  and  task  A1  and  B1
for  components  A  and  B  as  creating  A  and  B
respectively,  then  we  see  that  task  P1-0  must  execute 
before  A1  and  B1.
If we  also  consider  a  practical 
system  where  a  failure  of  component A  might require
restarting process P1, then there must be an operational
dependency  between tasks  P1-0 and  A1  (as  shown).
Once task A1 is executed, task A2 can execute. If task
A2 depends only on the successful execution of task A1
and not on any data generated by task A1, then the type
of dependency between tasks A1 and A2 is a sequential
dependency (this is marked in the figure).
2.3. Handling Failures During Initialization
We now describe  how  to use  the  interdependency
graph  to derive  a  new  sequence of  initialization
activities  that  enable  us  to  efficiently  recover from
failures  that  occur  during  initialization. Clearly,  all
tasks  associated  with entities  that  fail  must  be  re-
executed.    For  those  entities that  remain  fault-free,  the
types  of  dependencies  in  the  interdependency  graph
identify which  additional 
tasks  are 
impacted by the failure.
initialization 
The  challenge  lies  not  in  identifying  initialization
tasks impacted by a failure, but in identifying the set of 
initialization tasks already completed or in progress that
must  be  re-executed.    For  this  purpose, we introduce  a
recovery  graph.    A  recovery  graph  is  a  recomputed
interdependency  graph  containing  initialization  tasks
to  complete
that  must  be  re-executed 
in order 
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:51:18 UTC from IEEE Xplore.  Restrictions apply. 
B10
B10B10
O
O
S
S
B8
B8B8
O
O
B5
B5B5
S
S
B3
B3B3
S
S
O
O
B6
B6B6
O
O
B4
B4B4
O
O
O
O
O
O
B2
B2B2
S
S
B1
B1B1
B9
B9B9
S
S
B7
B7B7
O
O
O
O
O
O
O
O