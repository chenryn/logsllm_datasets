Manual Study. SVF test cases annotate alias by placing a pair
of pointers in a special function call, as follows:
MAYALIAS(p,q); //p and q should be ’’may alias’’
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:18 UTC from IEEE Xplore.  Restrictions apply. 
1106
INSPECTING 24 SVF IR PROGRAMS LIFTED BY RE TDE C.
TABLE VI
Correct
1
Inconsistent & Not Fixable
7
Inconsistent & Fixable
16
When the analysis pass of SVF reaches a callsite of
MayAlias during its traverse of the LLVM IR control ﬂow
graph, it checks whether the two parameters of this callsite
point to the same object. NoAlias and MustAlias are
annotated similarly. However, McSema completely changes
the callsite interfaces. As mentioned in Sec. V-A, functions in
its lifted IR are in the following form:
define @MAYALIAS(State %s, PC %pc, Mem* %memory)
from which SVF cannot extract two target pointers for check-
ing. Similarly, as introduced in Sec. V-A, function information
is trimmed from the outputs of BinRec. Therefore, function
callsites like MayAlias are absent in the lifted IR code.
Sec. V-A introduces that RetDec emits succinct and vi-
sually superior IR code, while mctoll sometimes emulates
computation of CPU registers, which may be due to its
struggling to recover certain variables. mctoll thus produces
much more obscure IR code than RetDec, as shown in the
“#Pointers” column of Table IV.
RetDec marginally outperforms others by generating sev-
eral true positives. We also notice that the average SVFG graph
of RetDec-generated IR is smaller than that of compiled IR.
This is due to the heavy optimizations that are applied by
RetDec (see discussions in Sec. VI-C). To determine which
aspect of the lifted IR code can be enhanced for pointer
analysis, we manually check and ﬁx inconsistencies in the
RetDec-lifted IR to correct the analysis results. We iterate
all supplied SVF test cases (24 programs), but exclude the
60 EMI-based mutations, as they are too complex to be ﬁxed
manually. The manual conﬁrmation results are presented in
Table VI; these show that all of the alias facts of only one
program are correctly analyzed, and hence do not need to be
ﬁxed. Seven programs are too challenging to ﬁx, as SVF’s
ﬂow-sensitive analysis conservatively analyzes arrays, whereas
RetDec does not recover arrays in the lifted IR at all. We
manually ﬁx the remaining 16 cases to correct the pointer
analysis results. The results are given in Table VII.
RetDec exhibits reasonable accuracy in recovering vari-
ables (except those from arrays, as revealed in Table VI).
However, inaccurate type-inference impedes pointer analysis;
213 cases are caused by incorrectly treating a local variable
of pointer type (e.g., i8*) as an integer (e.g., i32). We also
ﬁnd many function prototype-recovery errors (e.g., a parameter
of i32* type is recovered as i32). We also add a few new
statements and adjust existing statements (66 in total).
Findings. Our observation shows that modern (static) binary
lifters, particularly, RetDec and mctoll, can recover vari-
ables reasonably well (see Table VII). They also strive to
infer types and function prototypes, although the accuracy
is low. As a result, the induced IR code can hardly support
rigorous static analysis. We summarize two major obstacles
that could be addressed: 1) Type recovery, particularly, at
MANUALLY FIXING 16 SVF LLVM IR PROGRAMS LIFTED BY RE TDE C TO
CORRECT POINTER ANALYSIS RESULTS.
TABLE VII
Programs
branch 1.c
branch 2.c
branch 3.c
strong update.c
global 1.c
global 2.c
global 3.c
global 5.c
simple 1.c
simple 2.c
simple 3.c
struct 1.c
struct 2.c
pcycle1.c
pcycle2.c
test su.c
Total
Variable
Type
5
6
20
1
25
28
16
20
4
6
4
6
6
6
41
19
213
Function
Prototype
2
4
4
4
4
2
2
4
4
4
4
4
4
2
2
50
Added/Tweaked
Statements
2
0
4
2
3
2
2
3
2
2
2
1
36
5
66
Variable
Recovery
2
2
least distinguishing variables of pointer and non-pointer types.
Recovering composite data types like C array and struct is not
yet supported and could be challenging [100]. 2) Function
prototype recovery, particularly, generating more “high-level”
function prototype aligned with compiled IR code. Function
prototypes generated by McSema are highly inconsistent with
clang, RetDec, and mctoll generated IR code.
We emphasize that the aforementioned issues are common
limitations of binary lifters. Some engineering mismatches
of McSema and BinRec hinder the pointer analysis passes
of SVF. More importantly, our manual
inspection shows
that McSema and BinRec struggle to recover the variables
of pointer types. Thus, the ﬁxing of shallow “engineering
mismatches” in McSema and BinRec cannot substantially
enhance the pointer analysis accuracy. Overall, RetDec
marginally outperforms the other binary lifters for this task
by performing well in recovering variables and recovering a
small number of variable types. It also preserves the callsite
prototype (e.g., the callsites of the MayAlias utility func-
tion). Nevertheless, even for this “best” tool, we ﬁnd that
it implements rudimentary inference passes [8], [6], [7]. Its
inference modules therefore require principled improvement,
rather than only minor engineering-level modiﬁcations.
Possible Enhancements. Our further manual study on the
source code of binary lifters shows that inconsistencies ex-
posed in this evaluation (e.g., type recovery failures) are not
primarily due to bugs. Rather, lifters have not fully imple-
mented research products in this ﬁeld (to date, relevant passes
are generally rudimentary [8], [6], [7]). Existing research has
proposed static analysis approaches for variable recovery and
type inference, such as Value Set Analysis (VSA) [23], [24],
[72]. Function prototype recovery can be conducted following
very similar principles or with AI techniques [36], [19]. Also,
we note that binary lifters such as McSema employ a com-
mercial tool, IDA-Pro [60], as its reverse engineering frontend.
In addition to function boundary information currently being
acquired from IDA-Pro, we suggest McSema to leverage
function prototypes already inferred by IDA-Pro. Currently,
IDA-Pro is not fully used by McSema, which might be due to
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:18 UTC from IEEE Xplore.  Restrictions apply. 
1107
Fig. 3. Classiﬁcation analysis results. We report accuracy of each tool across all 104 classes of the POJ-104 dataset.
“open-source” concerns (see a note from the lead developer of
McSema [56]). Overall, we advocate lifter developers to adopt
research products or explore the full potential of its employed
third-party tools. It can thus ease the adoption of analysis
facilities provided by the LLVM ecosystem. See Appx. E for
further exploration of promoting pointer analysis.
AVERAGE CLASSIFICATION ACCURACY. HIGHER ACCURACY INDICATES
BETTER SUPPORT OF VARIOUS SIMILARITY-BASED APPLICATIONS.
TABLE VIII
Clang
McSema0
mctoll
87.3%
4.3%
77.4%
McSema
RetDec
BinRec
46.0%
81.9%
11.6%
C. Discriminability Analysis
Discriminability analysis is evaluated to classify POJ-104
programs. Fig. 3 reports the classiﬁcation accuracy across 104
classes, with the average number given in Table VIII. As afore-
mentioned, mctoll does not lift executable compiled from
C++ programs, and BinRec failed over 9K cases. Therefore,
their accuracy of some classes (e.g., 27) are omitted.
McSema has an average accuracy of 46.0%, while
McSema0, with no optimization applied, drops to barely
functional. This inconsistency illustrates the importance of
using code optimization. Fig. 3 shows that RetDec is even
better than clang for certain classes (e.g., class 57). This
is reasonable: when compiling POJ-104 programs into IR
using clang, we disable any optimization (-O0). In con-
trast, RetDec optimizes lifted LLVM IR code using its own
optimization and LLVM optimization passes. Our manual
study shows that RetDec applies 38 optimization passes
when lifting an executable ﬁle, where 26 are from the LLVM
framework, and 12 are implemented by its own.
Sec. IV-B has introduced that ncc extracts contextual ﬂow
graph [26], denoting how data ﬂow is propagated and how
control structures can inﬂuence data propagations. Fig. 2 has
motivated this study by showing that McSema maintains local
variables in an emulation-style paradigm as follows:
define @main(State %s, i64 %pc, Mem %memory) {
eax = %s.Regs[0]; ebx = %s.Regs[1]; ...
... // operations among vars. and %memory
where some LLVM identiﬁers are initialized at the beginning
of every function and used to mimic CPU registers. A global
memory array, representing memory stack,
is shared and
accessed by all functions. Such a paradigm, while faithfully
emulating the machine code computation, exhibits distinct data
access and usage patterns, undermining discriminability anal-
ysis. In other words, POJ-104 programs of different categories
become undesirably indistinguishable since their data ﬂow
patterns are too similar.
BinRec shows relatively lower accuracy for this evaluation
due to similar reasons. Although the average function coverage
rate of BinRec is 93% when processing POJ-104 programs,
the lifted code is put into a uniﬁed wrapper function, breaking
the original call graph. Our manual study on the wrapper
functions shows that it is generally difﬁcult for human to
identify the similarity of two wrapper functions implementing
different tasks. Typically, a few thousand IR statements, corre-
sponding to several logged execution traces, are merged within
one wrapper function. Local variables are named aligned with
CPU registers (R ECX, R ESP, etc.), mimicking the machine
computation occurred on the logged execution traces.
For certain classes, both compiled and lifted IR have low
accuracy. For instance, many IR programs of class 85 are
labeled as class 100. After inspecting the source code, we
ﬁnd that programs of class 85 and class 100 have similar data
structures and access patterns, i.e., a matrix is deﬁned and each
cell in the matrix is updated using its adjacent cells.
Findings & Lessons. Lifters like RetDec and mctoll
show encouraging support for discriminability analysis, whose
performance is comparable to compiled IR code (i.e., the
“upper bound”). Sec. IX and Appx. B further compare lifter-
enabled approaches and binary-only tools over binary difﬁng
tasks, which induce consistent ﬁndings. In sum, our ﬁndings
reveal promising progress and continuous effort made by the
lifter developers and the community. It might not be inaccurate
to assume that
these ﬁndings increase the conﬁdence for
security researchers to use binary lifters, particularly RetDec
and mctoll, in similarity analysis and binary difﬁng-related
tasks, e.g., code patch search [120], [124], [121].
Possible Enhancements. Our manual study shows that
program optimization is critical in generating concise and
discriminable IR code. We note that Table VIII has shown a
signiﬁcant improvement comparing McSema with McSema0.
That is, by enabling LLVM optimization passes (eliminating
deadcode, inlining routine functions, etc.), even the emulation-
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:18 UTC from IEEE Xplore.  Restrictions apply. 
1108
RetDecClangmctollMcSemaMcSema-00.20.40.60.8113579111315171921232527293133353739414345474951535557596163656769717375777981838587899193959799101103binrecxstyle lifting can exhibit non-trivial support of discriminability
analysis. Again, optimization passes customized by RetDec
(e.g., [8], [6], [7]) can be referred by developers of other lifters
as the starting point for enhancement.
Our study advocates for high-level
lifting (see research
motivation in Sec. III) instead of emulation-style lifting which
mimics the physical stack with a global array. RetDec and
mctoll, when reasonably meeting this criterion, have much
better performance that is close to compiled IR code. RetDec
has certain disassembling ﬂaws (failed to recover certain code
components; also noted in Sec. VI-E), which likely explains
ways to further enhance its accuracy (i.e., eventually reaching
87.3%). Regarding local variable recovery, the SecondWrite
paper [19] has proposed symbolic execution-based approaches
and demonstrates the scalability on complex SPEC programs.
Appx. E further assesses a recent AI-based approach [59] to
predicting debug information from stripped binary code, which
could boost local variable recovery as well.
Threat To Validity: Potential Bias of DNN-Based Dis-
criminability Analysis. Many recent works on binary code
similarity analysis employ neural networks and its enabled
representation learning (e.g., [44], [46]). However,
to our
knowledge, ncc is the only tool that presents an end-to-end
solution to generate embeddings of LLVM IR code which
can smoothly support discriminability (similarity) analysis. It
could be difﬁcult to estimate the effort to migrate other code
embedding tools (e.g., [44], [17]) to the LLVM ecosystem.
We clarify that ncc not merely builds on syntactic in-
formation. It is trained over the contextual ﬂow graphs of
LLVM IR [26]. Semantics-level features, including both data-
and control-ﬂow, are leveraged to construct such contextual
ﬂow graphs. We admit that it is still an open problem for
DNN models to precisely reason about code semantics (e.g.,
analyzing code inlining or eliminating dead code). However,