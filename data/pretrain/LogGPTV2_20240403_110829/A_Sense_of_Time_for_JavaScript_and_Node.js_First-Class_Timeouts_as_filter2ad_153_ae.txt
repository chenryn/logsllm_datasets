### Patch Implementation and I/O Partitioning
Our patch divides the I/O operations into a series of 64KB reads. As previously discussed, partitioning I/O is not a perfect solution, but it is better than having no partitioning at all. This patch was integrated after several months of deliberation on the performance-security tradeoff.

### Discussion

#### Other Examples of EHP Attacks
Two additional EHP (Event Handler Poisoning) attacks are worth noting:
1. **Memory Allocation in Garbage-Collecting Languages**: If the EDA (Event-Driven Architecture) framework uses a garbage-collected language for the Event Loop (e.g., Node.js, Vert.x, Twisted), triggering many memory allocations can lead to unpredictable blockage of the Event Loop. Although we are not aware of any reported attacks of this nature, such an attack could bypass first-class timeouts unless the garbage collector is partitioned.
2. **Asynchronous DNS Requests**: Linux lacks kernel support for asynchronous DNS requests, so they are typically implemented in the Worker Pool of EDA frameworks. If an attacker controls a DNS nameserver configured as a tarpit and can convince an EDA-based victim to resolve name requests using this server, each request will poison one of the Workers in the Worker Pool. First-class timeouts can protect against this class of attacks, similar to ReadDoS.

#### Programming with First-Class Timeouts
What would it be like to develop software for an EDA framework with first-class timeouts? Implementing first-class timeouts changes both the language and framework specifications. Developers must choose a timeout threshold and implement exception handling code for both asynchronous APIs (which may result in a `TimeoutError`) and synchronous APIs (which may throw a `TimeoutError`).

Selecting the right timeout is a Goldilocks problem: too short, and legitimate requests may result in erroneous `TimeoutError` (false positives); too long, and malicious requests will waste a lot of service time before being detected (false negatives). While timeouts in other contexts are often chosen without much consideration, for first-class timeouts, a good choice is relatively straightforward. A typical web server can handle hundreds or thousands of clients per second, and each client requires at least one callback on the Event Loop. Therefore, individual callbacks and tasks should take no longer than milliseconds to complete. A universal callback-task timeout of around 1 second should not result in erroneous timeouts during normal execution but would allow for rapid detection and response to EHP attacks. By definition, first-class timeouts preclude undetected EHP attacks (false negatives) with a reasonable timeout choice, as demonstrated by our Node.cure prototype.

Developers can assign tighter timeout thresholds to reduce the impact of EHP attacks. If a tight timeout can be assigned, a malicious request trying to trigger EHP will get about the same amount of server time as a legitimate request before being detected and aborted with a `TimeoutError`. The lower the variance in callback and task times, the more tightly the timeout thresholds can be set without false positives. Our implementation uses coarse-grained timeouts for callbacks and tasks, but more fine-grained timeouts are possible, such as through an API like `process.runWithTimeout(func)`. Appropriate coarse or fine-grained timeout thresholds could also be suggested automatically or tuned over the process lifetime of the server.

If a tight timeout cannot be assigned due to significant natural variation in the cost of handling legitimate requests, we recommend that the `TimeoutError` exception handling logic incorporate a blacklist. With a blacklist, the total time wasted by EHP attacks is equal to the number of attacks multiplied by the timeout threshold. Since DDoS is outside our threat model, this value should be small, and EHP attacks should not prove overly disruptive.

After choosing a timeout, developers need to modify their code to handle `TimeoutErrors`. For asynchronous APIs that submit tasks to the Worker Pool, a `TimeoutError` will be delivered like any other error, and existing error handling logic can be extended, for example, to blacklist the client. For synchronous APIs or synchronous links in an asynchronous sequence of callbacks, it is somewhat unusual that an unexceptional-looking sequence of code such as a loop can now throw an error. Wrapping every function with a try-catch block seems inelegant, but recent trends in asynchronous programming techniques have made it easier for developers to handle these errors. The ECMAScript 6 specification introduced Promises as a native JavaScript feature, simplifying data-flow programming. Promise chains permit catch-all handling of exceptions thrown from any link in the chain, so existing catch-all handlers can be extended to handle `TimeoutError`.

#### Detecting EHP Attacks Without First-Class Timeouts
Without first-class timeouts, a service that is not perfectly partitioned may have EHP vulnerabilities. In existing EDA frameworks, there is no elegant way to detect and recover from an EHP attack. Introducing a heartbeat mechanism into the service would enable the detection of an EHP attack, but what then? If more than one client is connected, as is inevitable given the multiplexing philosophy of the EDA, it is not feasible to interrupt the hung request without disrupting other clients, nor is it straightforward to identify which client was responsible. In contrast, first-class timeouts will produce a `TimeoutError` during the handling of the malicious request, allowing exception handling logic to easily respond by dropping the client and, perhaps, adding them to a blacklist.

In §4, we described two ways to achieve EHP-safety within the existing EDA paradigm. Other approaches are also viable but depart from the EDA paradigm. Significantly increasing the size of the Worker Pool, performing speculative concurrent execution, or switching to preemptable callbacks and tasks could each prevent or reduce the impact of EHP attacks. However, each of these is a variation on the same theme: dedicating isolated execution resources to each client, leading to the One Thread Per Client Architecture (OTPCA). The recent development of serverless architectures is another form of OTPCA, with the load balancing role played by a vendor rather than the service provider. If the server community wishes to use the EDA, which offers high responsiveness and scalability through cooperative multitasking, we believe first-class timeouts are a good path to EHP-safety.

#### Generalizability
Our first-class timeouts technique can be applied to any EDA framework. Callbacks must be made interruptible, and tasks must be made abortable. While these properties are more readily obtained in interpreted languages, they could, in principle, be enforced in compiled or VM-based languages as well.

### Related Work

#### JavaScript and Node.js
Ojamaa and Duuna assessed the security risks in Node.js applications, including ReDoS and other expensive computations as a means of blocking the event loop. However, they overlooked the risks of I/O and the fact that the small Worker Pool makes its poisoning possible. Two recent studies have explored the incidence and impact of ReDoS in the Node.js ecosystem.

Our preliminary work sketched EHP attacks and advocated Constant Worst-Case Execution Time partitioning as a solution. However, analysis in the present work reports that this approach imposes significant refactoring costs and is an ad hoc security mechanism. Other works have identified the use of untrusted third-party modules as a common liability in Node.js applications. DeGroef et al. proposed a reference monitor approach to securely integrate third-party modules from npm. Vasilakis et al. went further in their BreakApp system, providing strong isolation guarantees at module boundaries with dynamic policy enforcement at runtime. The BreakApp approach can be used to defeat EHP attacks through what might be called Second-Class Timeouts. Our work mistrusts particular instructions and permits the delivery of `TimeoutErrors` at arbitrary points in sequential code, while these reference monitor approaches mistrust modules and only permit the delivery of `TimeoutErrors` at module boundaries. Moving modules to separate processes to handle EHP attacks incurs significant performance overheads at start-up and larger performance overheads than Node.cure at run-time, placing more responsibility on developers to understand implementation details in their dependencies.

Static analysis can be used to identify vulnerabilities in JavaScript and Node.js applications. Guarnieri and Livshits demonstrated static analyses to eliminate the use of vulnerable language features or program behaviors in the client-side context. Staicu et al. offered static analyses and dynamic policy enforcement to prevent command injection vulnerabilities in Node.js applications. Static taint analysis for JavaScript, as proposed by Tripp et al., enables the detection of other injection attacks. These techniques can detect the possibility of EHP attacks that exploit known-vulnerable APIs (e.g., I/O such as `fs.readFile`), but not those exploiting arbitrary computation. Our first-class timeouts approach is instead a dynamic detect-and-respond defense against EHP attacks.

More broadly, other research on the EDA has studied client-side JavaScript/Web and Java/Android applications, often focusing on platform-specific issues such as DOM issues in web browsers.

#### Embedded Systems
Time is precious in embedded systems as well. Lyons et al. proposed the use of `TimeoutErrors` in mixed-criticality systems to permit higher-priority tasks to interrupt lower-priority tasks. Their approach incorporates timeouts as a notification mechanism for processes that have overrun their time slices, introducing preemption in a non-preemptive operating system. Our work is similar in principle but differs significantly in execution.

#### Denial of Service Attacks
Research on DoS can be broadly divided into network-level attacks (e.g., DDoS attacks) and application-level attacks. Since EHP attacks exploit the semantics of the application, they are application-level attacks, not easily defeated by network-level defenses.

DoS attacks seek to exhaust the resources critical to the proper operation of a server, and various kinds of exhaustion have been considered. The literature has focused on exhausting the CPU via worst-case performance, infinite recursion, and infinite loops. We are not aware of prior research work that incurs DoS using the file system, as do our ReadDoS attacks, though we have found a handful of CVE reports to this effect.

Our work identifies and shows how to exploit and protect the most limited resource of the EDA: Event Handlers. Although we use previously-reported attacks such as ReDoS, the underlying resource we are exhausting is not the CPU but the small, fixed-size set of Event Handlers deployed in EDA-based services.

#### Practitioner Awareness
The server-side EDA practitioner community is aware of the risk of DoS due to EHP on the Event Loop. A common rule of thumb is "Don't block the Event Loop," advised by many tutorials and recent books about EDA programming for Node.js. Wandschneider suggests worst-case linear-time partitioning on the Event Loop, while Casciaro advises developers to partition any computation on the Event Loop and offload computationally expensive tasks to the Worker Pool. Our work offers a more complete evaluation of EHP attacks and extends the rule of "Don't block the Event Loop" to the Worker Pool.

#### Future Work
Automatically identifying modules with computationally expensive paths would permit detecting EHP vulnerabilities in advance. As future work, we believe that research into computational complexity estimation and measurement might be adapted to the Node.js context for EHP vulnerability detection.

### Reproducibility
Everything needed to reproduce our results is available at [Node.cure GitHub Repository](https://github.com/VTLeeLab/node-cure), including scripts for our analysis of the Snyk.io vulnerability database, links to our contributions to the Node.js community, and the source code for the Node.cure prototype.

### Conclusion
The Event-Driven Architecture (EDA) holds great promise for scalable web services and is increasingly popular in the software development community. In this paper, we defined Event Handler Poisoning (EHP) attacks, which exploit the cooperative multitasking at the heart of the EDA. We showed that EHP attacks occur in practice and, as the EDA rises in popularity, we believe EHP attacks will become an increasingly critical DoS vector. The Node.js community has endorsed our expression of this problem, hosting our guide to avoiding EHP attacks on nodejs.org.

We proposed two defenses against EHP attacks and prototyped the more promising: first-class timeouts. Our prototype, Node.cure, enables the detection and defeat of all known EHP attacks with low overhead. Our findings can be directly applied by the EDA community, and we hope they influence the design of existing and future EDA frameworks.

### Acknowledgments
We thank the reviewers for their helpful feedback and Adam Doupé for his shepherding. Snyk.io provided a dump of their vulnerability database for npm, and C. Coghlan helped us analyze it. J.D. Greef of Ronomon suggested the EHP attacks listed in the discussion. A. Kazerouni, S. Rahaman, and the Virginia Tech Systems Reading Group were helpful sounding boards for our ideas and manuscripts, as were M. Hicks, G. Wang, and D. Yao.