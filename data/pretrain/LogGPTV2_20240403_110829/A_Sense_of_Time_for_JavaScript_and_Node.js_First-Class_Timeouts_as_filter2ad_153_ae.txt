quest. Our patch partitions it into a series of 64KB reads.
As discussed earlier, partitioning I/O is an imperfect so-
lution, but it is better than none. This patch was merged
after several months of discussion on the performance-
security tradeoff involved.
8 Discussion
Other examples of EHP attacks. Two other EHP at-
tacks are worth mentioning. First, if the EDA framework
uses a garbage collected language for the Event Loop (as
do Node.js, Vert.x, Twisted, etc.), then triggering many
memory allocations could lead to unpredictable block-
age of the Event Loop. We are not aware of any reported
attacks of this form, but such an attack would defeat ﬁrst-
class timeouts unless the GC were partitioned. Second,
Linux lacks kernel support for asynchronous DNS re-
quests, so they are typically implemented in EDA frame-
works in the Worker Pool. If an attacker controls a DNS
nameserver conﬁgured as a tarpit [73] and can convince
an EDA-based victim to resolve name requests using this
server, then each such request will poison one of the
Workers in the Worker Pool. First-class timeouts will
protect against this class of attacks as it does ReadDoS.
Programming with ﬁrst-class timeouts. What would
it be like to develop software for an EDA framework with
ﬁrst-class timeouts? First-class timeouts change the lan-
guage and framework speciﬁcations. First, developers
must choose a timeout threshold. Then, exception han-
dling code will be required for both asynchronous APIs,
which may be fulﬁlled with a TimeoutError, and syn-
chronous APIs, which may throw a TimeoutError.
The choice of a timeout is a Goldilocks problem. Too
short, and legitimate requests will result in an erroneous
TimeoutError (false positive). Too long, and malicious
requests will waste a lot of service time before being de-
tected (false negative). Timeouts in other contexts have
been shown to be selected without much apparent con-
sideration [85], but for ﬁrst-class timeouts we suggest
that a good choice is relatively easy. Consider that a
typical web server can handle hundreds or thousands of
clients per second. Since each of these clients requires
the invocation of at least one callback on the Event Loop,
simple arithmetic tells us that in an EDA-based server,
individual callbacks and tasks must take no longer than
milliseconds to complete. Thus, a universal callback-
task timeout on the order of 1 second should not result in
erroneous timeouts during the normal execution of call-
backs and tasks, but would permit relatively rapid detec-
tion of and response to an EHP attack12. By deﬁnition,
ﬁrst-class timeouts preclude the possibility of undetected
EHP attacks (false negatives) with a reasonable choice of
timeout, and our Node.cure prototype demonstrates that
this guarantee can be provided in practice.
Developers can assign tighter timeout thresholds to
If a tight time-
reduce the impact of an EHP attack.
out can be assigned, then a malicious request trying to
trigger EHP will get about the same amount of server
time as a legitimate request will, before the malicious
request is detected and aborted with a TimeoutError.
The lower the variance in callback and task times, the
more tightly the timeout thresholds can be set with-
out false positives. Though our implementation uses
coarse-grained timeouts for callbacks and tasks, more
ﬁne-grained timeouts are possible. Such an API might
be called process.runWithTimeout(func). Appropriate
coarse or ﬁne-grained timeout thresholds could also be
suggested automatically or tuned over the process life-
time of the server.
If a tight timeout cannot be assigned, perhaps be-
cause there is signiﬁcant natural variation in the cost of
handling legitimate requests, then we recommend that
the TimeoutError exception handling logic incorporate
a blacklist. With a blacklist, the total time wasted by
EHP attacks is equal to the number of attacks multiplied
by the timeout threshold. Since DDoS is outside of our
12If a service is unusually structured so as to run operations on be-
half of many clients in a single callback, then when this service is over-
loaded such a callback might throw a TimeoutError. We recom-
mend that such a callback be partitioned.
354    27th USENIX Security Symposium
USENIX Association
threat model, this value should be small and EHP attacks
should not prove overly disruptive.
After choosing a timeout, developers would need to
modify their code to handle TimeoutErrors. For asyn-
chronous APIs that submit tasks to the Worker Pool, a
TimeoutError will be delivered just like any other er-
ror, and error handling logic should already be present.
This logic could be extended, for example to blacklist
the client. For synchronous APIs or synchronous links
in an asynchronous sequence of callbacks, we acknowl-
edge that it is a bit strange that an unexceptional-looking
sequence of code such as a loop can now throw an er-
ror, and wrapping every function with a try-catch block
seems inelegant. Happily, recent trends in asynchronous
programming techniques have made it easy for develop-
ers to handle these errors. The ECMAScript 6 speciﬁ-
cation made Promises a native JavaScript feature, sim-
plifying data-ﬂow programming (explicit encoding of a
lifeline) [44]. Promise chains permit catch-all handling
of exceptions thrown from any link in the chain, so ex-
isting catch-all handlers can be extended to handle a
TimeoutError.
Detecting EHP attacks without ﬁrst-class timeouts.
Without ﬁrst-class timeouts, a service that is not per-
fectly partitioned may have EHP vulnerabilities. In exist-
ing EDA frameworks there is no way to elegantly detect
and recover from an EHP attack.
Introducing a heart-
beat mechanism into the service would enable the detec-
tion of an EHP attack, but what then? If more than one
client is connected, as is inevitable given the multiplex-
ing philosophy of the EDA, it is not feasible to interrupt
the hung request without disrupting the other clients, nor
it does seem straightforward to identify which client was
responsible. In contrast, ﬁrst-class timeouts will produce
a TimeoutError at some point during the handling of the
malicious request, permitting exception handling logic
to easily respond by dropping the client and, perhaps,
adding them to a blacklist.
In §4 we de-
scribed two ways to achieve EHP-safety within the ex-
isting EDA paradigm. Other approaches are also viable
but they depart from the EDA paradigm. Signiﬁcantly
increasing the size of the Worker Pool, performing spec-
ulative concurrent execution [48], or switching to pre-
emptable callbacks and tasks could each prevent or re-
duce the impact of EHP attacks. However, each of these
is a variation on the same theme: dedicating isolated ex-
ecution resources to each client, a road that leads to the
One Thread Per Client Architecture. The recent develop-
ment of serverless architectures [70] is yet another form
of the OTPCA, with the load balancing role played by
a vendor rather than the service provider. If the server
community wishes to use the EDA, which offers high
responsiveness and scalability through the use of coop-
Other avenues toward EHP-safety.
erative multitasking, we believe ﬁrst-class timeouts are a
good path to EHP-safety.
Generalizability. Our ﬁrst-class timeouts technique
can be applied to any EDA framework. Callbacks must
be made interruptible, and tasks must be made abortable.
While these properties are more readily obtained in an
interpreted language, they could in principle be enforced
in compiled or VM-based languages as well.
9 Related Work
JavaScript and Node.js. Ojamaa and Duuna assessed
the security risks in Node.js applications [79]. Their
analysis included ReDoS and other expensive computa-
tion as a means of blocking the event loop, though they
overlooked the risks of I/O and the fact that the small
Worker Pool makes its poisoning possible. Two recent
studies have explored the incidence and impact of Re-
DoS in the Node.js ecosystem [92, 53].
Our preliminary work [52] sketched EHP attacks and
advocated Constant Worst-Case Execution Time parti-
tioning as a solution. However, analysis in the present
work reports that this approach imposes signiﬁcant refac-
toring costs and is an ad hoc security mechanism (§4.3).
Other works have identiﬁed the use of untrusted third-
party modules as a common liability in Node.js appli-
cations. DeGroef et al. proposed a reference monitor
approach to securely integrate third-party modules from
npm [55]. Vasilakis et al. went a step further in their
BreakApp system, providing strong isolation guarantees
at module boundaries with dynamic policy enforcement
at runtime [95]. The BreakApp approach is complete
enough that it can be used to defeat EHP attacks, through
what might be called Second-Class Timeouts. Our work
mistrusts particular instructions and permits the delivery
of TimeoutErrors at arbitrary points in sequential code,
while these reference monitor approaches mistrust mod-
ules and thus only permit the delivery of TimeoutErrors
at module boundaries. In addition, moving modules to
separate processes in order to handle EHP attacks incurs
signiﬁcant performance overheads at start-up and larger
performance overheads than Node.cure at run-time, and
places more responsibility on developers to understand
implementation details in their dependencies.
Static analysis can be used to identify a number of
vulnerabilities in JavaScript and Node.js applications.
Guarnieri and Livshits demonstrated static analyses to
eliminate the use of vulnerable language features or pro-
gram behaviors in the client-side context [65]. Staicu
et al. offered static analyses and dynamic policy en-
forcement to prevent command injection vulnerabilities
in Node.js applications [93]. Static taint analysis for
JavaScript, as proposed by Tripp et al., enables the de-
tection of other injection attacks as well [94]. The tech-
niques in these works can detect the possibility of EHP
USENIX Association
27th USENIX Security Symposium    355
attacks that exploit known-vulnerable APIs (e.g. I/O such
as fs.readFile), but not those exploiting arbitrary com-
putation. Our ﬁrst-class timeouts approach is instead
a dynamic detect-and-respond defense against EHP at-
tacks.
More broadly, other research on the EDA has studied
client-side JavaScript/Web [71, 69, 54, 76] and Java/An-
droid [59, 58, 43, 68, 72] applications. These have often
focused on platform-speciﬁc issues such as DOM issues in
web browsers [71].
Embedded systems. Time is precious in embed-
ded systems as well. Lyons et al. proposed the use
of TimeoutErrors in mixed-criticality systems to per-
mit higher-priority tasks to interrupt lower-priority tasks
[74]. Their approach incorporates timeouts as a notiﬁ-
cation mechanism for processes that have overrun their
time slices, toying with preemption in a non-preemptive
operating system. Our work is similar in principle but
differs signiﬁcantly in execution.
Denial of Service attacks. Research on DoS can be
broadly divided into network-level attacks (e.g. DDoS
attacks) and application-level attacks [41]. Since EHP
attacks exploit the semantics of the application, they are
application-level attacks, not easily defeated by network-
level defenses.
DoS attacks seek to exhaust the resources critical to
the proper operation of a server, and various kinds of ex-
haustion have been considered. The brunt of the litera-
ture has focused on exhausting the CPU, e.g. via worst-
case performance [75, 51, 50, 90, 80], inﬁnite recur-
sion [49], and inﬁnite loops [91, 45]. We are not aware
of prior research work that incurs DoS using the ﬁle sys-
tem, as do our ReadDoS attacks, though we have found
a handful of CVE reports to this effect13.
Our work identiﬁes and shows how to exploit and pro-
tect the most limited resource of the EDA: Event Han-
dlers. Although we prove our point using previously-
reported attacks such as ReDoS, the underlying resource
we are exhausting is not the CPU but the small, ﬁxed-size
set of Event Handlers deployed in EDA-based services.
Practitioner awareness. The server-side EDA prac-
titioner community is aware of the risk of DoS due to
EHP on the Event Loop. A common rule of thumb is
“Don’t block the Event Loop”, advised by many tuto-
rials as well as recent books about EDA programming
for Node.js [96, 47]. Wandschneider suggests worst-case
linear-time partitioning on the Event Loop [96], while
Casciaro advises developers to partition any computation
on the Event Loop, and to ofﬂoad computationally ex-
pensive tasks to the Worker Pool [47]. Our work offers a
13For DoS by reading the slow ﬁle /dev/random, see CVE-2012-
1987 and CVE-2016-6896. For a related DOS by reading large ﬁles,
CVE-2001-0834, CVE-2008-1353, CVE-2011-1521, and CVE-2015-
5295 mention DoS by memory exhaustion using /dev/zero.
more complete evaluation of EHP attacks, and in partic-
ular we extend the rule of “Don’t block the Event Loop”
to the Worker Pool.
Future work. Automatically identifying modules
with computationally expensive paths would permit de-
tecting EHP vulnerabilities in advance. As future work,
we believe that research into computational complexity
estimation ([81, 66, 86]) and measurement ([87, 63, 46])
might be adapted to the Node.js context for EHP vulner-
ability detection.
10 Reproducibility
Everything needed to reproduce our results is avail-
able at https://github.com/VTLeeLab/node-cure
— scripts for our analysis of the Snyk.io vulnerability
database, links to our contributions to the Node.js com-
munity, and the source code for the Node.cure prototype.
11 Conclusion
The Event-Driven Architecture (EDA) holds great
promise for scalable web services, and it is increasingly
popular in the software development community. In this
paper we deﬁned Event Handler Poisoning (EHP) at-
tacks, which exploit the cooperative multitasking at the
heart of the EDA. We showed that EHP attacks occur
in practice already, and as the EDA rises in popularity
we believe that EHP attacks will become an increasingly
critical DoS vector. The Node.js community has en-
dorsed our expression of this problem, hosting our guide
to avoiding EHP attacks on nodejs.org.
We proposed two defenses against EHP attacks, and
prototyped the more promising: ﬁrst-class timeouts. Our
prototype, Node.cure, enables the detection and defeat of
all known EHP attacks, with low overhead. Our ﬁnd-
ings can be directly applied by the EDA community, and
we hope they inﬂuence the design of existing and future
EDA frameworks.
Acknowledgments
We thank the reviewers for their helpful feedback, as well
as Adam Doup´e for his shepherding. Snyk.io was kind
enough to provide a dump of their vulnerability database
for npm, which C. Coghlan helped us analyze.
J.D.
Greef of Ronomon suggested the EHP attacks listed in
the discussion. A. Kazerouni, S. Rahaman, and the Vir-
ginia Tech Systems Reading Group were helpful sound-
ing boards for our ideas and manuscripts, as were M.
Hicks, G. Wang, and D. Yao.
356    27th USENIX Security Symposium
USENIX Association
References
[1] 2017 User Survey Executive Summary. The Linux Foundation.
[2] ab – apache http server benchmarking tool. https://httpd.
apache.org/docs/2.4/programs/ab.html.
[3] acmeair-node.
acmeair-nodejs.
https://github.com/acmeair/
[4] Cylon.js. https://cylonjs.com/.
[5] express. https://github.com/expressjs/express.
[6] Gnu libc – posix safety concepts.
https://www.
gnu.org/software/libc/manual/html_node/
POSIX-Safety-Concepts.html.