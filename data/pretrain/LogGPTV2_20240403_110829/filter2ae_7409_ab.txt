**蓝色部分为：目录源数据（Central Directory）**
主要记录文件目录相关信息，如文件注释，大小，文件名等等…。由文件头（File Header）组成，通常是以`504b0102`标识开头
**灰色部分：目录源数据结束标识（End of central directory record）**
主要记录压缩包开始分卷号开始的偏移量，主要决定文件的目录结构，以及压缩包的相关信息，以`504b0607`开头（只有一个）
并且他们是有对应的关系的，压缩包中的一个文件实体对应一个文件头。目录源数据（Central Directory）是由多个文件头（File
header）组成，在。其中的关系基本如下。
## 4.压缩包各部分详细介绍。
#### 1.文件实体（File Entry）
文件实体通常又包括两部分：文件实体头（File Entry Header），数据描述（Data descriptor）两部分组成
**1.1文件实体头（File Entry Header）**
文件实体头部通常包含着文件的主要信息，包括文件的名称，文件的大小，文件的内容，文件的校验值，或者其他的等等。以`504b0304`开始
对应的编码如下。注意：图中所有关于十六进制都是从高位到低位写的，winhex中正好相反，所以图中`0x04034b50`,在winhex中显示为`50 4b
03 04`。
拿个压缩包尝试看下，新建文件"1"，然后在里面写进内容`dasdasdasdasdadas`然后添加到压缩文件。用WINHEX打开得到如图，我们从分析文件实体部分开始（`504b0304`）一直分析到目录源数据（`504b0102`）。
`504b0304`文件实体的固定值，`0a00`解压缩版本，`0000`标志（通常伪加密是在这），`0000`压缩方式，`1096`文件的最后修改时间，`594d`文件的最后修改日期。`84e45592`文件的CRC
32值
`14000000`压缩后的打小，`14000000`压缩前的大小，`0100`文件名称的长度（实际压缩读写的时候是按照0001来读取的），所以长度就是1，拓展长度为`0000`，文件名称为`31`（ascii对应为1）`6461736461736461736461736461736461646173`为拓展字段也就是压缩过的数据，这里因为我压缩的是纯文本而且并没有加密，我们直接看到其中的内容为可以直接显示`dasdasdasdasddadas`。
**1.2数据描述符（Data descriptor）**
用于表示文件压缩结束，只有在文件实体中通用标记字段的第3bit位为1时才会出现。一般zip上没有这个数据描述符，对应的编码格式如下。
#### 2.目录源数据
目录源数据通常由多个文件头（File
Header）组成。主要记录被压缩文件的目录结构，以及被压缩文件的属性，包括文件长度，压缩之后的长度，文件注释等。一个文件实体与一个文件头相对应。
**2.1 文件头（File Header）：**
通常以`504b0102`标识开头。对应的编码如下
还是拿刚才那个压缩包我们接着分析他的目录源数据从`504b0102`开始。`504b0102`目录源数据的固定值，`3F00`压缩版本，`0A00`解压缩版本，`0000`标志，`0000`压缩方式，`1096`文件的最后修改时间，`594d`文件的最后修改时期，`84e45592`文件的`CRC32`校验值，`14000000`文件压缩后的大小，`14000000`文件的压缩前的大小，`0100`文件的名称长度，拓展字段长度`2400`等等就不再一一写了，一直到`504b0506`。
**3.目录结束标识**
在目录源数据结束后，用于标记目录数据的结束，每个压缩文件有且只有一个。对应的编码格式如下
​
到这里压缩包的知识我们就看的看不多了，我们做个小小的总结发现压缩包的编码其实部分是一一对应的，比如我们添加标注的这些信息（标红）的这些信息，在文件实体中和在目录源数据中他们是一一对应的。我们可以通过其中之一推出另外一个。这样我们就可以根据这些对应关系将混淆的这些编码去掉。思路出来了我们回头做CTF题目。
## 5.题目解析
首先我们先找出所有的文件实体，搜索`504b0304`然后整理换行起码看着舒服，因为`504b0304`也可能被混淆接着我尝试搜`4b0304`果然找到了。为了确认是不是文件实体，我们核对下后面的压缩方式等信息，之后确认将？替换成5
修复之后发现三个文件实体`504b0304`，那对应的最少应该有三个目录源数据，然后搜索找找有没有跟`504b0102`很像的组合。找到了`50>b0102140000a000;`如下图。发现跟目录源数据`504b0102`的头很像，仔细核对后面的信息确认猜测，`>`替换成`4`，同时将`;`替换成`9`
替换之后我们重新整理下文件将文件实体，目录源数据分别整理出来，得到如下效果图
现在整体一看整个压缩包大致有个样子，四个文件实体，四个目录源数据，一个目录结束标识。仔细看下每个文件实体都有对应的文件描述`504b0708`，根据文件描述的文件头编码表,我们将相应的混淆替换掉。将`=`替换为`7`，将`：`替换为`8`，将`p`替换成`0`
替换完成后仔细观察下好像文件标识没办法再替换了，那我们接着往下推利用`crc`校验值，文件名等来推，根据第一个文件实体对应的文件描述，我们可以根据`CRC32`校验值来将一些字符替换掉。如下图。将`\xe58`替换为`E8`
同理第二个文件实体对应的文件描述的`CRC32`位校验值也应该是一样的，我们将第二个实体对应的字符串替换掉，如下图。将`0x038` 替换成`C8`
同理第四个文件实体的`CRC32`校验值与文件描述，以及第四个目录源数据对应CRC32位校验值也应该是一样，将文件目录源数据`50b0102`混淆字符串替换掉，如下图。将`\xe2A`替换为
`BA`
根据同样的原理利用第三个目录源数据的CRC32位校验值混淆字符串替换掉。如下图。将<替换成6。
我们接着从第一个文件实体往后看，发现第一，二个文件实体混淆字符串已经被替换没了。那我我们就看看文件叫什么名字吧，先看看文件名称长度，对照着顶部文件实体表，发现文件名称长度为`0005`。文件的名称为`662e747874`，转码一下发现`f.txt`，相信嗅觉灵敏的小伙伴肯定觉得不一般，猜想会不会压缩包里面是`f.txt，l.txt，a.txt，g.txt`。大致一看确实存在这种可能，因为确实有四个文件实体。用同样的方法查看第二个文件名称，确实`6C2E747874`就是`l.txt`，基本可以确定后面两个文件的文件名称，然后将四个文件名称在文件实体`504b0304`，文件描述`504b0708`，目录源数据`504b0102`对应位置替换，如下图。把`~`替换为`4`，将`r`替换为`2`，将`z`替换成`8`，最后根据拓展长度将`q`替换成`1`
到这里我们把所有的混淆替换掉了。这里贴出来最后去过混淆的字符串。
`504B03040A000900000044490A477E8BB5F4120000000600000005000000662E7478741716518DC72E49DFB8DB31631B5DAEC42F90504B07087E8BB5F41200000006000000504B03040A000900000053490A47C874AAA51200000006000000050000006C2E7478741716518DC72E49DFB8DB261BAA24C6A6CB3B504B0708C874AAA51200000006000000504B03040A000900000034620A4745D600C1120000000600000005000000612E7478741716518DC72E49DFB8DB414A032A257BE2F9504B070845D600C11200000006000000504B03040A00090000007D490A47642CBAEE120000000600000005000000672E7478741716518DC72E49DFB8DB080A066FF02FFEC5504B0708642CBAEE1200000006000000504B010214000A000900000044490A477E8BB5F41200000006000000050000000000000001002000000000000000662E747874504B010214000A000900000053490A47C874AAA512000000060000000500000000000000010020000000450000006C2E747874504B010214000A000900000034620A4745D600C1120000000600000005000000000000000100200000008A000000612E747874504B010214000A00090000007D490A47642CBAEE12000000060000000500000000000000010020000000CF000000672E747874504B05060000000004000400CC000000`
思路也有了修复出来压缩包。打开`f.txt，l.txt，a.txt，g.txt`。但是相信细心的小伙伴在复原的时候都会发现，每个文件实体对应的标志都是0900，这就意味着压缩包是加密的。我们试试，在`WINHEX`打开一个新文件，然后刚才还原的字符串粘贴为HEX。保存为233.zip。用360打开发现，确实存在密码，四个文件。如下图所示
想着暴力破解，无果，大佬给了个提示`crc32`，瞬间觉得自己嗅觉太差。因为题目都写着宇宙的一切答案32。然后用`WINRAR`打开想直接找`CRC32`校验值，为毛只有一个文件…。难道我修复错了。
仔细想想不可能。360都能解压，那问题可能是出在目录结束标识那`504b0607`，因为他记录着目录的偏移量，只有找到目录源数据`504b0102`的偏移量，`WINRAR`才能读出来整个文件的目录结构。找到`504b0506`，对照表，找到文件偏移量对应位置，发现刚好没有…23333。那我们就给他补充一个，首先找到第一个目录源数据`504b0102`算算前面一共552个16进制，那也就是227字节，转化为16进制114，那就应该填充的字符为`14010000`，最后补上。重新保存下。打开就没问题。然后就`crc32`碰撞出里面的内容。这里要说下，`GITHUB`上`CRC32.py`是不包括特殊字符的，（刚开始我怎么弄，就是找不出来可疑字符的原因）。我们需要手动补充下特殊字符，编辑`crc32.py`，然后添加你认为可能出现的字符串。如图
碰撞出来的结果为：`cr4ck_ crc32_ _is_s0_ e4sy_`
答案是将这四个字符拼接。小菜初次发文，有问题请大佬轻喷。