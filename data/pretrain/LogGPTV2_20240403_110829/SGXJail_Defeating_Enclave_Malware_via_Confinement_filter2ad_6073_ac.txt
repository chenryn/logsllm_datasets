5.2 Implementation Details
For generating dispatcher code, we extend the edger8r
tool [25] accordingly. The sandbox dispatchers are generated
in the ﬁles Enclave_us.c|h, while the application dispatch-
ers are located in Enclave_u.c|h. An enclave always copies
arguments to enclave memory before processing it. Similarly,
our dispatcher code copies arguments to application mem-
ory before invoking an OCALL. This prevents TOCTOU
vulnerabilities such as double-fetch bugs [58] by design.
ECALLs and OCALLs are routed between application and
sandbox process via two distinct shared memory regions, one
for each direction. The dispatchers synchronize ECALL/O-
CALL interaction via shared semaphores. This has the advan-
tage that processes (application and sandbox) are consuming
no CPU time while waiting for the other communication part-
ner. For receiving OCALLs, the application installs a separate
listener thread that only gets active upon incoming OCALLs.
358          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX AssociationSelection of appropriate syscall ﬁlters is crucial for the
security of SGXJail, as a malicious enclave can directly ex-
ploit a lax conﬁguration (e.g., via rogue EEXIT attacks). It
is favorable to restrict both the number of syscalls as well
as their complexity to reduce the attack surface given by the
whitelisted syscalls. This also has an impact on the type of
inter-process communication between sandbox and applica-
tion process. By choosing shared memory as communica-
tion channel, we do not require any syscall for the actual
communication, and only one syscall (futex) for synchro-
nization. In summary, we conﬁgure seccomp [36] to only
allow the syscalls futex necessary for semaphores as well
as exit_group for terminating the sandbox process. Thus,
the shared memory approach results in only one whitelisted
syscall in addition to the required exit_group syscall. Un-
less the implementation of these two syscalls is buggy, they
cannot cause a security violation when issued by a malicious
enclave.
The SGX SDK passes OCALL function arguments from
the enclave to the application via the application’s stack. The
enclave knows the application’s stack location via the stack
pointer (RSP register), which is preserved by the EENTER in-
struction. Hence, it can allocate a stack frame on the host stack
via a function called sgx_ocalloc and store any outgoing
OCALL arguments there. One can leverage this mechanism
for reducing SGXJail overhead, as follows. Currently, when
doing an OCALL, our sandbox dispatchers copy OCALL
arguments from the sandbox to the shared memory. By mod-
ifying RSP immediately before an EENTER to point to the
shared memory, one can instruct the enclave to write OCALL
arguments directly to the shared memory instead of the sand-
box application’s stack. When the enclave EEXITs, one can
simply restore the original sandbox stack (namely, RSP).
In our current implementation, the size of the shared mem-
ory is hard-coded to three pages for each direction. For ECAL-
L/OCALL arguments exceeding the shared memory, one can
dynamically resize the shared memory on demand. Although
multithreaded enclaves are currently not supported by our
prototype implementation, support can be easily added. This
is done by installing separate semaphores and shared buffers
for all enclave threads, which are enumerated in a public en-
clave XML conﬁguration ﬁle. Also, support for nested calls
(OCALLs issuing ECALLs) can be added by adapting the
synchronization mechanism appropriately.
An interesting question arises whether SGXJail should be
integrated with the SGX SDK in a way that does not demand
recompilation of the application. Thus, system administrators
can globally enforce SGXJail by just installing corresponding
shared libraries. Since the enclave’s EDL ﬁle is public anyway
and will be distributed alongside third-party enclaves, the gen-
eration of dispatcher code is straight forward. Moreover, one
would need to hook the enclave API of the unmodiﬁed appli-
cation binary and inject dispatcher code, which can be done by
preloading SGX SDK libraries (in particular, sgx_urts.so).
Table 2: ECALL and OCALL latency in CPU cycles of
SGXJail compared to the unprotected Vanilla version.
The standard deviation is shown in braces.
Latency
Vanilla
SGXJail
ECALL
15 624 (± 301)
22 094 (± 814)
OCALL
13 438 (± 1046)
19 515 (± 1360)
5.3 Evaluation
SGXJail does not affect runtime performance of host applica-
tions or enclaves in isolation. That is, as long as no interaction
between enclave and application takes place, they can run
without performance loss. The only performance overhead
occurs when doing ECALLs and OCALLs due to the message
passing via shared memory and the necessary synchroniza-
tion between application and sandbox process. To evaluate
this effect, we ﬁrst present microbenchmarks for bare metal
ECALL and OCALL latency, which are followed by mac-
robenchmarks on more representative workloads.
Test Setup. All evaluations are done on a commodity note-
book featuring an Intel i5-6200U CPU, a Samsung SM951
SSD and running Ubuntu 16.04 Desktop and SGX SDK ver-
sion 2.4. For the benchmarks, we disabled the screen as well
as network interfaces to reduce noise from screen redrawing
or external interrupts. Also, we ﬁxed the CPU frequency to
its maximum (2.3 GHz) and pinned the benchmark to a single
core. The benchmarks include a warm-up phase.
Microbenchmarks. To measure the ECALL latency, we im-
plemented a simple ECALL and measured its execution time
from within the host application. That is, the ECALL latency
includes EENTER, EEXIT, all glue code for the enclave and
the host, as well as context switching and synchronization be-
tween application and sandbox for SGXJail. To measure the
OCALL latency, we, in addition, perform one simple OCALL
from within the ECALL and subtract the ECALL latency. We
repeated the measurement 500 times. The resulting latencies
are shown in Table 2. The raw ECALL latency increases from
15.6·103 cycles to 22.1·103 cycles while the OCALL latency
increases from 13.4· 103 cycles to 19.5· 103 cycles. Hence,
the absolute latency remains small. Since many practical
usage scenarios of SGX involve somewhat complex computa-
tions inside the enclave, the actual runtime overhead is much
lower than the pure ECALL/OCALL overhead.
Macrobenchmarks. Quantifying performance of enclaves
is highly application speciﬁc. Unfortunately, enclaves are not
widely deployed yet and standardized benchmarking suites are
unavailable to the best of our knowledge. A common approach
is to port existing programs to an enclave [61]. While this
sounds appealing, it tends to introduce many unnecessary
OCALLs to the standard library which well-designed enclaves
would not perform, e.g., the getpid syscall in openVPN [61].
Instead, we quantify the performance of SGXJail as fol-
lows. First, we benchmark a synthetic workload under dif-
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 359ferent OCALL frequencies. The results of this benchmark
are generic and can be applied to any enclave for which the
OCALL frequency can be determined. Second, we benchmark
storage of sensitive enclave data to disk via the Intel protected
ﬁlesystem (PFS). The PFS is integrated within the SGX SDK
and is likely to be used by a vast number of enclaves.
For our ﬁrst benchmark, we observe that an enclave typi-
cally issues OCALLs to perform syscalls, e.g., writing to ﬁles.
Our benchmarked OCALL performs a close syscall on an in-
valid ﬁle descriptor. Such a fast syscall gives an upper bound
on the performance overhead since longer syscalls decrease
the inﬂuence of the OCALL overhead. We repeated each mea-
surement 100 times. The OCALL-to-enclave ratio (w.r.t. their
runtime) as well as the overhead of SGXJail compared to
unprotected Vanilla applications is given in Figure 3, whereas
the simple standard deviation is shown as the area under the
curves. We execute a ﬁxed baseline workload inside the en-
clave, which corresponds to 2201.44 (± 25.67) ·106 cycles,
or 0.96 (± 0.011) s on our 2.3 GHz CPU. As this workload
runs within the enclave, we quantify it as enclave seconds, or
Esec. While we keep the enclave workload constant, we issue
OCALLs at different frequencies and measure the additional
OCALL work. This is shown as ratio on the left axis of Fig-
ure 3 and allows us to decouple the OCALL overhead from
the OCALL frequency, which we quantify as OCALLs/Esec.
One can see that the overhead of SGXJail is virtually non-
existent for low-frequency OCALLs, meaning that pure en-
clave execution is not impeded by SGXJail at all. Even for
10 000 OCALLs/Esec the overhead is below 3% and for a
large number of 50 000 OCALLs/Esec the overhead is only
around 11%. To put these numbers into perspective, Netﬂix
observed a maximum of 50 000 OCALLs/s across their sys-
tems [20]. For even higher OCALL frequencies the OCALL
workload starts to exceed the enclave workload in the vanilla
version already. With SGXJail, enclaves can issue up to
113 000 OCALLs/Esec before OCALL processing exceeds
actual enclave computations (ratio=1). For unprotected apps
this point is reached for 164 000 OCALLs/Esec. Such situ-
ations should be dealt with in practice by redesigning the
enclave API and reducing or removing unnecessary OCALLs.
Yet, SGXJail only introduces around 20% overhead even in
this extreme case.
Our ﬁrst benchmark measures the raw OCALL perfor-
mance. However, this does not reﬂect the performance of
copying OCALL arguments between enclave and applica-
tion. To evaluate the maximum overhead of a real-world
scenario, we benchmark an enclave which only accesses
ﬁles via the Intel protected ﬁle system (PFS) library. PFS
is shipped with the SGX SDK and is intended for sealing
sensitive enclave data on the host ﬁle system for persisting
state across reboots. To resemble a worst-case scenario of
PFS, we implement and benchmark a single ECALL which
opens a new ﬁle (sgx_fopen_auto_key), writes a ﬁxed-size
buffer (sgx_fwrite), and immediately closes the ﬁle again
.
s
v
L
L
A
C
O
f
o
o
i
t
a
R
d
a
o
l
k
r
o
w
e
v
a
l
c
n
e
Vanilla
SGXJail
Overhead
10
8
6
4
2
0
40
30
20
10
0
%
n
i
a
l
l
i
n
a
V
/
l
i
a
J
X
G
S
101
101
102
102
103
103
OCALLs / Esec
104
104
105
105
106
106
Figure 3: Benchmark on unprotected (Vanilla) and hard-
ened (SGXJail) applications, plotted over different num-
bers of OCALLs per enclave second (Esec).
s
m
n
i
e
m
i
t
n
u
R
10
1
0.1
Vanilla
SGXJail
Overhead
80
60
40
20
0
%
n
i
d
a
e
h
r
e
v
O
100
100
101
101
103
103
104
102
102
104
Payload size in bytes
105
105
106
106
Figure 4: PFS runtime of SGXJail compared to unpro-
tected Vanilla enclaves for different payload sizes.
(sgx_fclose). We repeat the measurements 200 times. After