to this situation and runs properly even without administrator privileges [1].
Eﬃcient Label Computation. Computing labels for programs should only incur
a small performance penalty. We add only a few instructions to the fast path in
the Windows memory management routines (which are executed for every page
fault). Moreover, the label computation is done incrementally; it only needs
to inspect the new, executable memory regions that are added to the process
address space. As a result, our label computation is fast, as demonstrated by
the performance overhead measured in our experiments (which are discussed in
Section 5).
3 System Implementation
In this section, we describe Dymo’s implementation in detail. In particular, we
discuss how our system extends the Windows XP kernel to track the executable
regions of a process and uses this information to compute identity labels.
Dynamically maintaining a process’ identity over the course of its execution
is a diﬃcult problem. The ﬁrst concern is that processes load dynamic link
libraries (DLLs) during run-time, which makes it diﬃcult to predetermine all of
the code segments that will reside in a process’ address space. Second, processes
may allocate arbitrary memory regions with execute permission, for example,
when dynamically generating code. This is commonly done by packed malware,
which produces most of its code on-the-ﬂy in an eﬀort to thwart signature-based
detection, but also by just-in-time compilers that generate code dynamically.
A third issue concerns image rebasing. When the preferred load addresses of
two DLLs conﬂict, one has to be relocated, and all addresses of functions and
global variables must be patched in the code segment of the rebased DLL. This
poses a problem because we do not want the identities of two processes to diﬀer
simply because of diﬀerences in DLL load order. Dymo is able to track a process’
identity in spite of these problems, as discussed in the following sections.
3.1 System Initialization
We assume that Dymo is installed on a clean machine and is executed before any
malicious process is running. Our system begins its operation by registering for
kernel-provided callbacks that are associated with process creation and image
loading (via PsSetCreateProcessNotifyRoutine and PsSetLoadImageNotify-
Routine, respectively) and hooking the NT kernel system services responsible
for allocating memory, mapping ﬁles, and changing the protection of a memory
region (these functions are NtAllocateVirtualMemory, NtMapViewOfSection,
and NtProtectVirtualMemory, respectively).
By registering these callbacks and hooks, Dymo can observe and track all
regions of memory from which a process could potentially execute code. Dymo
also hooks the page fault handler so that it will be alerted when a tracked mem-
ory region has been requested for execution. This allows for the inclusion of this
region into the identity label. This alert strategy makes use of hardware-enforced
Data Execution Prevention (DEP/NX) [16]. DEP/NX utilizes No eXecute hard-
ware support to disallow execute access to memory pages that have the NX bit
set. Note that only those DEP/NX violations that are due to our tracking tech-
nique are processed in the hooked page fault handler. The vast majority of page
faults are eﬃciently passed on to the original handler.
3.2 Identity Label Generation
An identity label encapsulates all memory regions (sets of consecutive memory
pages) of a process’ address space that are executed. Since each executable mem-
ory region is self-contained and can be modiﬁed independently, Dymo tracks
them individually through image hashes and region hashes.
Image and region hashes are cryptographic hashes (currently we use SHA-
1) that represent images (i.e., .exe ﬁles and DLLs) and executable memory
regions, respectively. The primary diﬀerence between the two types of hashes
is that the former refer to image code segments while the latter correspond to
all other executable memory allocations. We make this distinction because of
the diﬀerences in generating the two types of hashes, as discussed later. A basic
identity label is generated by aggregating all image and region hashes into a set.
In Section 4.2, we discuss an optimization step that allows us to compress the
size of identity labels signiﬁcantly.
Since the label is a set of hashes, the constituent image and region hashes can
be individually extracted. As a result, the identity label is independent of the
exact layout of executable memory regions in the process’ address space (which
can change between executions). Furthermore, the identity label encapsulates
DLLs that are dynamically loaded according to the run-time behavior of a par-
ticular process execution (e.g., the dynamic loading of a JavaScript engine by a
browser when rendering a web page that contains JavaScript). The creation of
image and region hashes is described next.
Image Hashes. It is easiest to understand the operation of Dymo by walking
through the loading and execution of an application. After a process is started
and its initial thread is created – but before execution begins – Dymo is notiﬁed
through the process creation callback. At this point, Dymo constructs a process
proﬁle to track the process throughout its execution.
Just before the initial thread starts executing, the image loading callback
is invoked to notify Dymo that the application’s image (the .exe ﬁle) and the
Ntdll.dll library have begun loading. Dymo locates the code segment for each
of these images in the process’ virtual address space and modiﬁes the page pro-
tection to remove execute access from the region. Dymo then adds the original
protection (PAGE EXECUTE READ), the new protection (PAGE READONLY), and the
image base address to the process proﬁle.
Ntdll.dll is responsible for loading all other required DLL images into
the process, so the initial thread is set to execute an initialization routine in
Ntdll.dll. Note that this marks the ﬁrst user mode execution attempt in the
new process. Since Dymo has removed execute access from the Ntdll.dll code
segment, the execution attempt raises a DEP/NX exception, which results in a
control transfer to the page fault handler. Dymo’s page fault handler hook is
invoked ﬁrst, which allows it to inspect the fault. Dymo determines that this is
the DEP/NX violation that it induced, and it uses the process proﬁle to match
the faulting address to the Ntdll.dll code segment. Using the memory region
information in the process proﬁle, Dymo creates the image hash that identiﬁes
Ntdll.dll. It does this by computing a cryptographic hash of the code segment.
Note that special care must be taken to ensure that the image hash is not
aﬀected by image rebasing. Dymo accomplishes this by parsing the PE header
and .reloc section of the image ﬁle to ﬁnd the rebase ﬁxup points and revert
them to their canonical values. That is, those addresses in a library’s code that
change depending on the library’s base address are overwritten with their initial
values, which are derived from the preferred base address. This is necessary
to avoid the generation of diﬀerent hashes when the same library is loaded at
diﬀerent addresses in diﬀerent program executions.
The image hash is then added to the process proﬁle. Finally, Dymo restores
the original page protection (PAGE EXECUTE READ) to the faulting region and
dismisses the page fault, which allows execution to continue in the Ntdll.dll
initialization routine.
Ntdll.dll consults the executable’s Import Address Table (IAT) to ﬁnd re-
quired DLLs to load (and recursively consults these DLLs for imports) and maps
them into memory. Dymo is notiﬁed of these image loads through a callback,
and it carries out the processing described above for each library. The callback
is also invoked when DLLs are dynamically loaded during run-time, which en-
ables Dymo to process them as well. After loading, each DLL will attempt to
execute its entry point, a DEP/NX exception will be raised, and Dymo will add
an image hash for each DLL to the process proﬁle as described above.
Region Hashes. Collecting image hashes allows Dymo to precisely track all of a
process’ loaded images. But there are other ways to introduce executable code
into the address space of a process, such as creating a private memory region or
ﬁle mapping. Furthermore, the page protection of any existing memory region
may be modiﬁed to allow write and/or execute access.
All of these methods eventually translate to requests to one of three sys-
tem services that are used for memory management – NtAllocateVirtual-
Memory, NtMapViewOfSection, or NtProtectVirtualMemory – which are hooked
by Dymo. When a request to one of these system services is made, Dymo ﬁrst
passes it to the original routine, and then it checks whether the request resulted
in execute access being granted to the speciﬁed memory region. If so, Dymo
reacts as it did when handling loaded DLLs: it removes execute access from the
page protection of the region, and it adds the requested protection, the granted
protection, and the region base address to the process proﬁle. When the sub-
sequent DEP/NX exception is raised (when code in the region is executed for
the ﬁrst time), Dymo creates a region hash for the region. Unfortunately, gen-
erating a region hash is not as straightforward as creating an image hash (i.e.,
calculating a cryptographic hash over the memory region). This is because these
executable regions are typically used for dynamic code generation, and so the
region contents vary wildly over the course of the process’ execution. Handling
this problem requires additional tracking, which we describe next.
Handling Dynamic Code Generation. To motivate the problem created by dy-
namic code generation, consider the operation of the Firefox web browser. As
of version 3.5, Firefox uses a component called TraceMonkey [15] as part of its
JavaScript engine to JIT compile traces (hot paths of JavaScript code), and it
executes these traces in an allocated memory region. Since the generated code
will vary depending upon many factors, it is diﬃcult to track and identify the
region (a similar issue arises with recent versions of Adobe’s Flash player and
other JIT compiled code). Nonetheless, care must be taken to eﬀectively track
the JIT code region as it represents a writable and executable memory region
that may be the target of JIT spraying attacks [3].
To overcome this diﬃculty, Dymo tracks the images that are responsible
for allocating, writing, and calling into the region in question. The allocator is
tracked by traversing the user mode stack trace when the region is allocated
until the address of the code that requested the allocation (typically a call to
VirtualAlloc) is reached. Dymo tracks the writer by ﬁltering write access from
the region, and, in the page fault handler, capturing the address of the instruction
that attempts the write. The caller is tracked by locating the return address
from the call into the region. In the page fault handler, this return address
can be found by following the user mode stack pointer, which is saved on the
kernel stack as part of the interrupt frame. Dymo creates a (meta) region hash
by concatenating the image hashes of the allocator, writer, and caller of the
region and hashing the result. In the case of Firefox TraceMonkey, a hash that
describes that the region belongs to its JavaScript engine housed in Js3250.dll
is generated.
Dynamic code rewriting is handled in a similar fashion. Code rewriting oc-
curs, for example, in the Internet Explorer 8 web browser when Ieframe.dll
rewrites portions of User32.dll to detour [11] functions to its dynamically gen-
erated code region. In this case, since User32.dll has already been registered
with the system and Dymo is able to track that Ieframe.dll has written to it,
the User32.dll image hash is updated to reﬂect its trusted modiﬁcation.
Handling the PAGE EXECUTE READWRITE Protection. When a process makes a
call that results in a memory protection request that includes both execute
and write access, Dymo must take special action. This is because Dymo must
allow both accesses to remain transparent to the application. However, it must
also diﬀerentiate between the two, so that it can reliably create hashes that
encapsulate any changes to the region. The solution is to divide the PAGE -
EXECUTE READWRITE protection into PAGE READWRITE and PAGE EXECUTE READ
and toggle between the two.
To this end, Dymo ﬁlters the PAGE EXECUTE READWRITE request in a system
service hook and, initially, only grants PAGE READWRITE to the allocated region.
Later, if the application attempts to execute code in the region, a DEP/NX
exception is raised, and Dymo creates a hash as usual, but instead of granting
the originally requested access, it grants PAGE EXECUTE READ. In other words,
Dymo removes the write permission from the region so that the application
cannot update the code without forcing a recomputation of the hash.
If a fault is later incurred when writing to the region, Dymo simply tog-
gles the protection back to PAGE READWRITE and dismisses the page fault. This
strategy allows Dymo to compute a new hash on every execution attempt, while
tracking all writes and remaining transparent to the application.
3.3 Establishing Identity
So far, we have described how Dymo computes the identity labels of processes.
However, we have not yet discussed how these labels can be used to identify
applications.
Recall that a label is a set of hashes (one for each executable memory region).
One way to establish identity is to associate a speciﬁc label with an application.
A process is identiﬁed as this application only when their labels are identical;
that is, for each hash value in the process’ label, there is a corresponding hash
in the application’s label. We call this the strict matching policy.
A limitation of the strict matching policy is that it can be overly conservative,
rejecting valid labels of legitimate applications. One reason is that an application
might not always load the exact same set of dynamic libraries. This can happen
when a certain application feature has not been used yet, and, as a result, the
code necessary for this feature has not been loaded. As another example, take
the case of dynamic code generation in a web browser. When the user has not yet
visited a web page that triggers this feature, the label will not contain an entry
for a dynamically allocated, executable region created by the JIT compiler. To
address this issue, we propose a relaxed matching policy that accepts a process
label as belonging to a certain application when this process label contains a
subset of the hashes that the application label contains and the hash for the
main code section of the application is present.
4 Applications for Dymo
Dymo implements a dynamic code identity primitive. This primitive has a vari-
ety of applications, both on the local host and in the network. In this section, we
ﬁrst describe a scenario where Dymo is used for performing local (host-based)
access control using the identity of processes. Then, we present an application
where Dymo is extended to label network connections based on the program
code that is the source of the traﬃc.
4.1 Application-Based Access Control
Modern operating systems typically make access control decisions based on the
user ID under which a process runs. This means that a process generally has