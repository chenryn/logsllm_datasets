To formalize such a protocol, we consider the following
signature:
Σc ={enc, dec, dh, mac, gen, g, ok} and Σd ={neq}.
Except g and ok which are public constants, all these function
symbols are public constructor symbols of arity 2. The de-
structor neq has already be deﬁned in Section II. The symbol
dh is used to model modular exponentiation whereas mac will
be used to model message authentication code. We consider
the equational theory E deﬁned by the following equations:
dec(enc(x, y), y) = x
dh(dh(x, y), z) = dh(dh(x, z), y)
This protocol falls into our generic class of 2-party protocols.
We take
ΠPACE =(k,{sT , nT , n′
T},{nR, n′
R},IPACE,RPACE)
a responder role (we do not detail the continuation R′ and
we omit trivial conditionals). The process modeling the role
where the RPACE process (reader), described in Figure 8, is
IPACE can be obtained in a similar way.
RPACE ∶= in(cR, y1).
out(cR, dh(g, nR)).in(cR, y2).
out(cR, dh(G, n′
R)).in(cR, y3).
let ytest = neq(y3, dh(G, n′
R)) in
out(cR, mac(y3, k′));
in(cR, y4).
let y5 = eq(y4, mac(dh(G, n′
R), k′)) in R′.
where G= gen(dec(y1, k), dh(y2, nR)) and k′ = dh(y3, n′
R).
Fig. 8. Process RPACE
Unfortunately, ProVerif cannot handle the equation above
on the dh operator (due to some termination issues). Instead
of that single equation, we consider the following equational
theory that is more suitable for ProVerif:
dh(dh(g, y), z) = dh(dh(g, z), y)
dh(dh(gen(x1, x2), y), z) = dh(dh(gen(x1, x2), z), y)
1We do not model the getChallenge constant message that is used to initiate
the protocol but it is clear this message does not play any role regarding the
security of the protocol.
This is sufﬁcient for the protocol to work properly but it
obviously lacks equations that the attacker may exploit.
577577
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:14:24 UTC from IEEE Xplore.  Restrictions apply. 
First, we would like to highlight an imprecision in the
ofﬁcial speciﬁcation [38] that may lead to practical attacks
on unlinkability. As the speciﬁcation seems to not forbid
it, we could have assumed that the decryption operation in
way that it may fail when the key k does not match with
the key of the ciphertext y1. In that case, an attacker could
G = gen(dec(y1, k), dh(y2, nR)) is implemented in such a
eavesdrop a ﬁrst message c0 = enc(s0
T , k0) of a certain tag T 0
scan a tag T but replace its challenge enc(sT , k) by c0 and
the decryption did not fail and thus k = k0: the tag T is
dec(⋅,⋅) as a destructor (that may fail) and the computation of
actually T 0. We discovered this attack using our method since
in our ﬁrst attempt to modelize the protocol, we modelized
wait for an answer of the reader. If it answers, he learns that
and then, in a future session, it would let the reader optically
G as an evaluation:
let G= gen(dec(y1, k), dh(y2, nR)) in[...]
This test has to satisfy our requirement in order to declare
the protocol well-authenticating. But this conditional com-
puting G is not safe and does not satisfy the requirements
of Deﬁnition 14 (the attack scenario described is a counter
example). The same attack scenario shows that the protocol
does not ensure unlinkability (this scenario cannot be observed
when interacting with SΠ). Similarly to the attack on LAK, we
highlight here the importance to take the reader into account
and give it as much importance as the tag in the deﬁnition of
unlinkability. Indeed, it is actually a leakage from the reader
that allows an attacker to trace a speciﬁc tag.
Second, we report on an attack2 that that we discovered
using our method on some modelizations of PACE found in
the literature [29], [39], [40]. Indeed, in all those papers, the
ﬁrst conditional of the reader
let ytest = neq(y3, dh(G, n′
R)) in
resulting protocol
is omitted. Then the
is not well-
authenticating. To see this, we simply have to consider a
scenario where the attacker will send to the reader the message
it has outputted at the previous step. Such an execution will
allow the reader to execute its role until the end, and therefore
execute τthen, but the resulting trace is not an honest one.
Again,
this scenario can be turned into an attack against
unlinkability as explained next. As before, an attacker could
eavesdrop a ﬁrst message c0 = enc(s0
T , k0) of a certain tag T 0.
a tag T but replace its challenge enc(sT , k) by c0. Whatever k
Then, in a future session, it would let the reader optically scans
is equal or k0, the reader answers gnR. The attacker then
plays the two rounds of Difﬁe-Hellman by reusing messages
from the reader (he actually performs a reﬂection attack).
R and
More precisely, he replies with gnT = gnR, Gn′
mac(Gn′
T , k′). The crucial point is that the
R , k′) = mac(Gn′
T = Gn′
attacker did not prove he knows k (he supposed to do so to
generate G at step 4) thanks to the reﬂection attack that is not
detected. Now, the attacker waits for the reader’s answer. If it
2For that different attack, we obviously consider that decryption is a
constructor, and thus cannot fail.
578578
is positive (the process R′ is executed), he learns that k = k0:
the tag T is actually the same as T 0.
Third, we turn to PACE as properly understood from the
ofﬁcial speciﬁcation: when the latter test is present and the
decryption may not fail. In that case, we report on a new attack.
UKano found that the last test of the reader violates well-
authentication. This is the case for the following scenario: the
message enc(sT , k) from a tag T(k, nT) is fed to two readers
R) of same identity name. Then, the attacker
R(k, n1
R), R(k, n2
just forwards messages from one reader to the other. They can
thus complete the two rounds of Difﬁe-Hellman (note that the
test avoiding reﬂection attacks holds). More importantly, the
mac-key veriﬁcation phase (messages 8 and 9 from Figure 7)
goes well and the attacker observes that the last conditional
of the two readers holds. This violates well-authentication
but also unlinkability because the latter scenario cannot be
observed at all in SΠ: if the attacker makes two readers talk
to each other in SΠ they cannot complete a session because
they must have different identity names. In practice, this ﬂaw
seems hard to exploit but it could be a real privacy concern: if a
tag initiates multiple readers, an attacker may learn which ones
it had initiated by forwarding messages from one to another.
It does not seem to be realistic in the e-passport scenario, but
could be harmful in other contexts.
Finally, we propose a simple ﬁx to the above attack
by adding tags avoiding confusions between reader’s mes-
sages and tag’s messages. It sufﬁces to replace messages 8
and 9 from Figure 7 by respectively mac(⟨cr, Gn′
mac(⟨ct, Gn′
T⟩, k′) and
R⟩, k′) where cr, ct are public constants, and
adding the corresponding checks. Frame opacity and well-
authentication can be automatically established using UKano,
in around 20 minutes. Therefore, PACE with tags preserves
unlinkability in the model considered here.
VIII. CONCLUSION
We
two
have
identiﬁed
conditions,
tool ProVerif,
namely well-
authentication and frame opacity, which imply anonymity and
unlinkability for a wide class of protocols. Additionally, we
these two conditions can be checked
have shown that
automatically using the
and we have
mechanized the veriﬁcation of our conditions in a tool
called UKano. This yields a new veriﬁcation technique to
check anonymity and unlinkability for an unbounded number
of sessions. It has proved quite effective on various case
studies. In particular, it has brought ﬁrst-time unlinkability
proofs for the BAC protocol (e-passport). Our case studies
also illustrated that our methodology is useful to discover
attacks against unlinkability and anonymity as illustrated by
the new attacks we found on PACE and LAK.
In the future, we plan to develop a mature implementation
of our tool in order to make it widely accessible for the design
and study of privacy-preserving 2-party protocols. We could
also try to translate our conditions into more comprehensive
guidelines helping the design of new privacy-enhancing pro-
tocols.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:14:24 UTC from IEEE Xplore.  Restrictions apply. 
We also identify a number of research problems aimed at in-
creasing the scope of our technique. Currently, our conditions
are checked using ProVerif which, despite its great ﬂexibility,
supports only a limited kind of equational theory. In particular,
full Difﬁe-Hellman theory or associative-commutative theories
needed for xor (widely used in RFID protocols) are not sup-
ported. It seems likely that frame opacity can be checked using
ad-hoc methods rather than ProVerif, which could support
wider classes of theories. Concerning well-authentication, we
could consider various extensions of ProVerif with partial
support for xor [41], or other tools such as Tamarin and
Maude−NPA. We would also like to investigate the extension
of our main theorem to the case of protocols with state. This is
certainly technically challenging, but would make it possible to
model more protocols, or at least model them more faithfully.
Finally, we would like to investigate whether our frame opacity
condition could be relaxed to allow one to deal more precisely
with primitives that are neither transparent, nor totally opaque
in general (e.g. zero-knowledge proofs, signatures).
REFERENCES
[1] “Iso 15408-2: Common criteria for information technology security
evaluation - part 2: Security functional components,” July 2009.
[2] T. Van Deursen and S. Radomirovic, “Attacks on RFID protocols.” IACR
Cryptology ePrint Archive, vol. 2008, p. 310, 2008.
[3] A. Armando, R. Carbone, L. Compagna, J. Cu´ellar, and M. L. Tobarra,
“Formal analysis of SAML 2.0 web browser single sign-on: breaking
the SAML-based single sign-on for Google apps,” in Proc. 6th ACM
Workshop on Formal Methods in Security Engineering (FMSE’08).
ACM, 2008, pp. 1–10.
[4] V. Cortier and B. Smyth, “Attacking and ﬁxing Helios: An analysis of
ballot secrecy,” Journal of Computer Security, vol. 21, no. 1, pp. 89–148,
2013.
[5] A. Armando et al., “The AVANTSSAR platform for the automated
validation of trust and security of service-oriented architectures,” in
Proc. 18th International Conference on Tools and Algorithms for the
Construction and Analysis of Systems (TACAS’12), vol. 7214. Springer,
2012, pp. 267–282.
[6] S. Meier, B. Schmidt, C. Cremers, and D. Basin, “The Tamarin Prover
for the Symbolic Analysis of Security Protocols,” in Proc. 25th Interna-
tional Conference on Computer Aided Veriﬁcation (CAV’13), ser. LNCS,
vol. 8044. Springer, 2013, pp. 696–701.
[7] B. Blanchet, “An Efﬁcient Cryptographic Protocol Veriﬁer Based on
IEEE Comp. Soc. Press,
Prolog Rules,” in Proceedings of CSFW’01.
2001, pp. 82–96.
[8] M. Arapinis, T. Chothia, E. Ritter, and M. Ryan, “Analysing unlinka-
bility and anonymity using the applied pi calculus,” in Proceedings of
CSF’10.
IEEE Comp. Soc. Press, 2010.
[9] M. Bruso, K. Chatzikokolakis, and J. den Hartog, “Formal veriﬁcation
of privacy for RFID systems,” in Proceedings of CSF’10, 2010.
[10] S. Delaune, S. Kremer, and M. D. Ryan, “Verifying privacy-type
properties of electronic voting protocols,” Journal of Computer Security,
no. 4, 2008.
[11] M. Backes, C. Hritcu, and M. Maffei, “Automated veriﬁcation of remote
electronic voting protocols in the applied pi-calculus,” in Proceedings of
the 21st IEEE Computer Security Foundations Symposium, CSF 2008,
Pittsburgh, Pennsylvania, 23-25 June 2008.
IEEE Computer Society,
2008, pp. 195–209.
[12] N. Dong, H. Jonker, and J. Pang, “Formal analysis of privacy in an
Springer,
ehealth protocol,” in Computer Security–ESORICS 2012.
2012, pp. 325–342.
[13] M. Arapinis, L. Mancini, E. Ritter, M. Ryan, N. Golde, K. Redon,
and R. Borgaonkar, “New privacy issues in mobile telephony: ﬁx and
veriﬁcation,” in Proceedings of the 2012 ACM conference on Computer
and communications security. ACM, 2012, pp. 205–216.
[14] M. Arapinis, L. I. Mancini, E. Ritter, and M. Ryan, “Privacy through
pseudonymity in mobile telephony systems.” in NDSS, 2014.
[15] R. Chr´etien, V. Cortier, and S. Delaune, “From security protocols
to pushdown automata,” ACM Transactions on Computational Logic,
vol. 17, no. 1:3, Sep. 2015.
[16] M. Baudet, “Deciding security of protocols against off-line guessing
attacks,” in Proc. 12th Conference on Computer and Communications
Security. ACM, 2005.
[17] V. Cheval, H. Comon-Lundh, and S. Delaune, “Trace equivalence deci-
sion: Negative tests and non-determinism,” in Proceedings of CCS’11.
ACM Press, 2011.
[18] V. Cheval and B. Blanchet, “Proving more observational equivalences
with proverif,” in Principles of Security and Trust. Springer, 2013, pp.
226–246.
[19] D. Basin, J. Dreier, and R. Sasse, “Automated symbolic proofs of
observational equivalence,” in Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications Security. ACM, 2015,
pp. 1144–1155.
[20] S. Santiago, S. Escobar, C. Meadows, and J. Meseguer, “A formal
indistinguishability and its veriﬁcation using
Springer, 2014, pp.
deﬁnition of protocol
maude-npa,” in Security and Trust Management.
162–177.
[21] M. Abadi and C. Fournet, “Mobile values, new names, and secure
communication,” in Proceedings of POPL’01. ACM Press, 2001.
[22] B. Blanchet, M. Abadi, and C. Fournet, “Automated veriﬁcation of