Ramblr Fast achieves an extremely low mis-classiﬁcation
rate, the former performs better than the latter, as expected.
E. Comparative Evaluation - Correctness
We compare Ramblr against Uroboros by evaluating
both tools (plus Ramblr with Fast Workarounds) against our
datasets. We run Uroboros, Ramblr, and Ramblr Fast on
6Clang displays error messages and terminates at duplicated labels, while
GCC does not seem to care as long as duplicated labels do not reference
different addresses.
12
Arch
Dataset
Opt. Level
i386
CGC
i386
Coreutils
x86 64
Coreutils
O0
O1
O2
O3
Os
Ofast
O0
O1
O2
O3
Os
Ofast
O0
O1
O2
O3
Os
Ofast
Solution
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Total References
False Negatives
False Negative % False Positives
False Positive %
500682
500682
501613
501613
505409
505409
505813
505813
469512
469512
505828
505828
128065
128065
124555
124555
122215
122215
192863
192863
83600
83600
193317
193317
125005
125005
123156
123156
113651
113651
171302
171302
82592
82592
171849
171849
12112
12120
12064
12120
0
0
0
0
0
0
3
0
0
0
0
0
0
0
0
4
1
1
0
0
4
4
4
4
4
4
4
4
4
4
8
12
2.39
2.39
0.0006
2.56
2.39
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0.0021
0.0012
0.0012
0.00319
0.00319
0.0032
0.0032
0.0035
0.0035
0.0023
0.0023
0.0048
0.0048
0.0047
0.0070
0
0
0
0
0
15
0
15
0
15
0
15
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0.02
0.02
0.02
0.02
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
TABLE IV: Symbolization ground truth for different approaches across different datasets. Since reassembly failures are caused
by mis-classiﬁcation of symbols, we measure the rate at which symbols are mis-classiﬁed against ground truth provided by the
linker during compilation.
each binary, and then run test cases against the reassembled
binary to see if it still functions correctly. Using this data, we
compile the rate of failures, which we present in Table V.
We evaluate both ﬂavors of Ramblr on all optimization
levels. However, Uroboros’ failure rates increase to meaning-
less levels for optimizations above O1, so we only present O0
and O1 results. Furthermore, the Uroboros prototype that we
initially used completely fails to reassemble 64-bit binaries7.
Regardless of the reason, we were only able to carry out the
comparative evaluation on 32-bit binaries. For CGC binaries,
we evaluate all optimization levels on all tools.
As demonstrated in Table V, both Ramblr and Ramblr
Fast are strictly better than Uroboros. With optimizations
disabled, Uroboros breaks 22.64% of the Coreutils binaries,
which is signiﬁcantly worse than Ramblr and Ramblr
Fast, which break none. Enabling optimization, this goes up
to 56.61% for Uroboros and still none for Ramblr.
On the CGC dataset, Uroboros breaks 15% to 25% op-
timized binaries, which means that, when applied on real-
world binaries, one out of four binaries will require manual
inspection, intervention, and repair. For larger binaries, this is
infeasible. By comparison, Ramblr achieves a success rate of
over 98% across all levels, over 99% for optimization levels
below O3, and 100% for unoptimized binaries.
7Upon contact, authors of Uroboros conﬁrmed that there was a bug in their
prototype, which causes misalignment of data sections in generated x86-64
assembly. Commit 45f018a was made to address this issue.
Correctness of Uroboros. The fact that Uroboros breaks
many Coreutils binaries is unexpected, as it contradicts the
claim in the Uroboros paper that no broken Coreutils binary
was generated by Uroboros under any assumption. We investi-
gated the issue, and found out the culprit was differing versions
of GCC. Uroboros was evaluated on all Coreutils binaries
compiled by the GCC version shipped with Ubuntu 12.04 LTS,
which was GCC 4.6. Our Coreutils binaries are compiled by
GCC 5.4.1. The prototype of Uroboros has trouble dealing
with some memory references (e.g. __JCR_LIST__) in some
binaries, and those references do not exist in ones generated by
GCC 4.6. Additionally, GCC 5 introduces new optimizations
that were not present in GCC 4, such as inter-procedural op-
timizations [9]. These optimizations more frequently produce
hard-to-handle folded constants.
We reran the evaluation on Coreutils 8.15 compiled by
GCC 4.6 shipped in Ubuntu 12.04 with the default opti-
mization level (O2), and were able to reproduce their results.
However, this reveals the fragility of the Uroboros approach.
For instance, when running the evaluation on Coreutils 8.25
with O0 under the same setting, we found out that factor
was broken due to an incorrect symbolization in data sections.
Opt-out case study. Ramblr successfully detects the
use of pointer encryption and decryption in KPRCA_00044
and opts out, while Ramblr Fast fails to detect it, and
generates a broken reassembled binary. Ramblr is the ﬁrst
binary reassembly engine with this detection capability. In fact,
Ramblr was able to opt out of breaking all but one binary,
resulting in a single broken binary out of the entire dataset.
13
Dataset
Opt. Level
CGC
Coreutils
O0
O1
O2
O3
Os
Ofast
O0
O1
O2
O3
Os
Ofast
Solution
Uroboros
Ramblr
Ramblr Fast
Uroboros
Ramblr
Ramblr Fast
Uroboros
Ramblr
Ramblr Fast
Uroboros
Ramblr
Ramblr Fast
Uroboros
Ramblr
Ramblr Fast
Uroboros
Ramblr
Ramblr Fast
Uroboros
Ramblr
Ramblr Fast
Uroboros
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Ramblr
Ramblr Fast
Safety Opt-outs
Generation Failures
Test Failures
Successes
Total
Success %
0
0
0
0
1
0
0
1
0
0
1
0
0
1
0
0
1