"grant_types":"authorization_code",
"token_endpoint_auth_method":"client_secret_basic",
}
Let’s examine the definition of each parameter:
• 
client_id: The generated unique identifier for the client.
• 
client_secret: The generated client secret corresponding to the 
client_id. This is optional. For example, for public clients the 
client_secret isn’t required.
• 
client_id_issued_at: The number of seconds since January 1, 1970.
• 
client_secret_expires_at: The number of seconds since January 1, 
1970 or 0 if it does not expire.
• 
redirect_uris: Accepted redirect_uris.
• 
token_endpoint_auth_method: The accepted authentication method 
for the token endpoint.
Note the Dynamic Client registration Oauth 2.0 profile is quite useful in mobile 
applications. Mobile client applications secured with Oauth have the client iD 
and the client secret baked into the application. these are the same for all the 
installations of a given application. if a given client secret is compromised, that will 
affect all the installations, and rogue client applications can be developed using 
the stolen keys. these rogue client applications can generate more traffic on the 
server and exceed the legitimate throttling limit, hence causing a denial of service 
attack. With dynamic client registration, you need not set the same client iD and 
client secret for all the installations of a give application. During the installation 
process, the application can talk to the authorization server’s registration endpoint 
and generate a client iD and a client secret per installation.
Chapter 9  Oauth 2.0 prOfiles
225
 Token Revocation Profile
Two parties can perform OAuth token revocation. The resource owner should be able to 
revoke an access token issued to a client, and the client should be able to revoke an access 
token or a refresh token it has acquired. The Token Revocation OAuth 2.0 profile3 addresses 
the latter. It introduces a standard token-revoke endpoint at the authorization server end. 
To revoke an access token or a refresh token, the client must notify the revoke endpoint. 
Note in October 2013, there was an attack against Buffer (a social media 
management service that can be used to cross-post between facebook, twitter, 
etc.). Buffer was using Oauth to access user profiles in facebook and twitter. 
Once Buffer detected that it was under attack, it revoked all its access keys from 
facebook, twitter, and other social media sites, which prevented attackers from 
getting access to users’ facebook and twitter accounts.
The client must initiate the token revocation request. The client can authenticate 
to the authorization server via HTTP Basic authentication (with its client ID and client 
secret), with mutual TLS or with any other authentication mechanism proposed by the 
authorization server and then talk to the revoke endpoint. The request should consist 
of either the access token or the refresh token and then a token_type_hint that informs 
the authorization server about the type of the token (access_token or refresh_token). 
This parameter may not be required, but the authorization server can optimize its search 
criteria using it.
Here is a sample request:
POST /revoke HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic czZCaGRSdadsdI9iuiaHk99kjkh
token=dsd0lkjkkljkkllkdsdds&token_type_hint=access_token
3 https://tools.ietf.org/html/rfc7009
Chapter 9  Oauth 2.0 prOfiles
226
In response to this request, the authorization server first must validate the client 
credentials and then proceed with the token revocation. If the token is a refresh 
token, the authorization server must invalidate all the access tokens issued for the 
authorization grant associated with that refresh token. If it’s an access token, it’s up to 
the authorization server to decide whether to revoke the refresh token or not. In most 
cases, it’s ideal to revoke the refresh token, too. Once the token revocation is completed 
successfully, the authorization server must send an HTTP 200 status code back to the 
client.
 Summary
• 
The OAuth 2.0 profiles built on top of the core framework build a 
security ecosystem to make OAuth 2.0 ready for enterprise grade 
deployments.
• 
OAuth 2.0 introduced two extension points via grant types and token 
types.
• 
The Token Introspection profile for OAuth 2.0 introduces a standard 
API at the authorization server, allowing the resource server to talk to 
it and retrieve token metadata. 
• 
According to the OAuth Chain Grant Type profile, the API hosted 
in the first resource server must talk to the authorization server and 
exchange the OAuth access token it received from the client for a 
new one that can be used to talk to another API hosted in a second 
resource server.
• 
The OAuth 2.0 Token Exchange is a draft proposal discussed under 
the IETF working group at the moment, which solves a similar 
problem as the Chain Grant Type proposal with some improvements.
• 
The aim of the Dynamic Client Registration OAuth 2.0 profile is to 
expose an endpoint for client registration in a standard manner to 
facilitate on-the-fly registrations. 
• 
The Token Revocation OAuth 2.0 profile introduces a standard token- 
revoke endpoint at the authorization server to revoke an access token 
or a refresh token by the client.
Chapter 9  Oauth 2.0 prOfiles
227
© Prabath Siriwardena 2020 
P. Siriwardena, Advanced API Security, https://doi.org/10.1007/978-1-4842-2050-4_10
CHAPTER 10
Accessing APIs via Native 
Mobile Apps
The adoption of native mobile apps has increased heavily in the last few years. Within the 
first decade of the 21st century, the Internet users worldwide increased from 350 million 
to more than 2 billion and mobile phone subscribers from 750 million to 5 billion—and 
today it hits 6 billion, where the world population is around 7 billion. Most of the mobile 
devices out there–even the cheapest ones—could be used to access the Internet.
We treat a native mobile application as an untrusted or a public client. A client 
application, which is not capable of protecting its own keys or credentials, is identified as 
a public client under OAuth terminology. Since the native mobile apps run on a device 
owned by the user, the user who is having complete access to the mobile device can 
figure out any keys the application hides. This is a hard challenge we face in accessing 
secured APIs from a native mobile application.
In this chapter, we discuss the best practices in using OAuth 2.0 for native apps, Proof 
Key for Code Exchange (PKCE), which is an approach for protecting native apps from 
code interception attack and protecting native apps in a browser-less environment.
 Mobile Single Sign-On (SSO)
It takes an average of 20 seconds for a user to log in to an application. Not having to 
enter a password each time a user needs to access a resource saves time and makes 
users more productive and also reduces the frustration of multiple login events and 
forgotten passwords. When we have single sign-on, the users will only have one 
password to remember and update and only one set of password rules to remember. 
Their initial login provides them with access to all the resources, typically for the entire 
day or the week.
228
If you provide multiple mobile applications for your corporate employees 
to access from their mobile devices, it’s a pain to ask them to re-login to each 
application independently. Possibly all of them may be sharing the same credential 
store. This is analogous to a case where Facebook users log in to multiple third-party 
mobile applications with their Facebook credentials. With Facebook login, you only 
login once to Facebook and will automatically log into the other applications rely on 
Facebook login.
In mobile world, login to native apps is done in three different ways: directly asking 
for user credentials, using a WebView, and using the system browser.
 Login with Direct Credentials
With this approach, the user directly provides the credentials to the native app itself 
(see Figure 10-1). And the app will use an API (or OAuth 2.0 password grant type) to 
authenticate the user. This approach assumes the native app is trusted. In case your 
native app uses a third-party identity provider for login, we must not use this. Even this 
approach may not be possible, unless the third-party identity provider provides a login 
API or supports OAuth 2.0 password grant type. Also this approach can make the users 
vulnerable for phishing attacks. An attacker can plant a phishing attack by fooling the 
user to install a native app with the same look and feel as the original app and then 
mislead the user to share his or her credentials with it. In addition to this risk, login 
with direct credentials does not help in building a single sign-on experience, when you 
have multiple native apps. You need to use your credentials to log in to each individual 
application.
Chapter 10  aCCessing apis via native Mobile apps
229
 Login with WebView
The native app developers use a WebView in a native app to embed the browser, so that 
the app can use web technologies such as HTML, JavaScript, and CSS. During the login 
flow, the native app loads the system browser into a WebView and uses HTTP redirects 
to get the user to the corresponding identity provider. For example, if you want to 
authenticate users with Facebook, to your native app, you load the system browser into a 
WebView first and then redirect the user to Facebook. What’s happening in the browser 
loaded into the WebView is no different from the flow you see when you log in to a web 
app via Facebook using a browser.
The WebView-based approach was popular in building hybrid native apps, because 
it provides better user experience. The users won’t notice the browser being loaded into 
the WebView. It looks like everything happens in the same native app.
Figure 10-1. The Chase bank’s mobile app, which users directly provide 
credentials for login
Chapter 10  aCCessing apis via native Mobile apps
230
It also has some major disadvantages. The web session under the browser loaded 
into a WebView of a native app is not shared between multiple native apps. For example, 
if you do login with Facebook to one native app, by redirecting the user to facebook.com 
via a browser loaded into a WebView, the user has to log in to Facebook again and again, 
when multiple native apps follow the same approach. That is because the web session 
created under facebook.com in one WebView is not shared with another WebView of a 
different native app. So the single sign-on (SSO) between native apps will not work with 
the WebView approach.
WebView-based native apps also make the users more vulnerable to phishing 
attacks. In the same example we discussed before, when a user gets redirected to 
facebook.com via the system browser loaded into a WebView, he or she won’t be able to 
figure out whether they are visiting something outside the native app. So, the native app 
developer can trick the user by presenting something very similar to facebook.com and 
steal user’s Facebook credentials. Due to this reason, most of the developers are now 
moving away from using a WebView for login.
 Login with a System Browser
This approach for login into a native app is similar to what we discussed in the previous 
section, but instead of the WebView, the native app spins up the system browser 
(see Figure 10-2). System browser itself is another native app. User experience in this 
approach is not as smooth as with the WebView approach, as the user has to switch 
between two native apps during the login process, but in terms of security, this is the 
best approach. Also, this is the only approach we can have single sign-on experience in 
a mobile environment. Unlike WebView approach, when you use the system browser, 
it manages a single web session for the user. Say, for example, when there are multiple 
native apps using Facebook login via the same system browser, the users only need to 
log in to Facebook once. Once a web session is created under facebook.com domain 
with the system browser, for the subsequent login requests from other native apps, users 
will be logged in automatically. In the next section, we see how we can use OAuth 2.0 
securely to build this use case.
Chapter 10  aCCessing apis via native Mobile apps
231
 Using OAuth 2.0 in Native Mobile Apps
OAuth 2.0 has become the de facto standard for mobile application authentication. In 
our security design, we need to treat a native app a dumb application. It is very much 
similar to a single-page application. The following lists out the sequence of events that 
happen in using OAuth 2.0 to log in to a native mobile app.
Figure 10-2. Login to Foursquare native app using Facebook
Chapter 10  aCCessing apis via native Mobile apps
232
 1. Mobile app developer has to register the application with the 
corresponding identity provider or the OAuth 2.0 authorization 
server and obtain a client_id. The recommendation is to use 
OAuth 2.0 authorization code grant type, without a client secret. 
Since the native app is an untrusted client, there is no point of 
having a client secret. Some were using implicit grant type for 
native apps, but it has its own inherent security issues and not 
recommended any more.
 2. Instead of WebView, use SFSafariViewController with iOS9+ or 
Chrome Custom Tabs for Android. This web controller provides all 
the benefits of the native system browser in a control that can be 
placed within an application. Then you can embed the client_id 
obtained from step 1 into the application. When you embed a 
client_id into an app, it will be the same for all the instances of that 
native app. If you want to differentiate each instance of the app 
(installed in different devices), then we can dynamically generate 
a client_id for each instance at the start of the app, following the 
protocol defined in OAuth 2.0 Dynamic Client Registration profile, 
which we explained in detail in Chapter 9.
Figure 10-3. A typical login flow for a native mobile app with OAuth 2.0 
Chapter 10  aCCessing apis via native Mobile apps
233
 3. During the installation of the app, we need to register an app-
specific custom URL scheme with the mobile operating system. 
This URL scheme must match the callback URL or redirect URI 
you used in step 1, at the time of app registration. A custom URL 
scheme lets the mobile operating system to pass back the control to 
your app from another external application, for example from the 
system browser. If you send some parameters to the app-specific 
custom URI scheme on the browser, the mobile operating system 
will track that and invoke the corresponding native app with those 
parameters.
 4. Once the user clicks login, on the native app, we need to spin up 
the system browser and follow the protocol defined in OAuth 
2.0 authorization code grant type (see Figure 10-3), which we 
discussed in detail in Chapter 4.
 5. After the user authenticates to the identity provider, the browser 
redirects the user back to the registered redirect URI, which is in 
fact a custom URL scheme registered with the mobile operating 
system.
 6. Upon receiving the authorization code to the custom URL scheme 
on the system browser, the mobile operating system spins up the 
corresponding native app and passes over the control.
 7. The native app will talk to the token endpoint of the authorization 
server and exchange the authorization code to an access token.
 8. The native app uses the access token to access APIs.
 Inter-app Communication
The system browser itself is another native app. We used a custom URL scheme as a way 
of inter-app communication to receive the authorization code from the authorization 
server. There are multiple ways for inter-app communication available in a mobile 
environment: private-use URI scheme (also known as custom URL scheme), claimed 
HTTPS URL scheme, and loopback URI scheme.
Chapter 10  aCCessing apis via native Mobile apps
234
 Private URI Schemes
In the previous section, we already discussed how a private URI scheme works. When 
the browser hits with a private URI scheme, it invokes the corresponding native app, 
registered for that URI scheme, and hands over the control. The RFC 75951 defines 
guidelines and registration procedures for URI schemes, and according to that, it is 
recommended to use a domain name that is under your control, in its reverse order  
as the private URI scheme. For example, if you own app.foo.com, then the private  
URI scheme should be com.foo.app. The complete private URI scheme may look like 
com.foo.app:/oauth2/redirect, and there is only one slash that appears right after the 
scheme component.
In the same mobile environment, the private URI schemes can collide with each 
other. For example, there can be two apps registered for the same URI scheme. Ideally, 
this should not happen if you follow the convention we discussed before while choosing 
an identifier. But still there is an opportunity that an attacker can use this technique to 
carry out a code interception attack. To prevent such attacks, we must use Proof Key 
for Code Exchange (PKCE) along with private URI schemes. We discuss PKCE in a later 
section.
 Claimed HTTPS URI Scheme
Just like the private URI scheme, which we discussed in the previous section, when a 
browser sees a claimed HTTPS URI scheme, instead of loading the corresponding page, 
it hands over the control to the corresponding native app. In supported mobile operating 
systems, you can claim an HTTPS domain, which you have control. The complete 
claimed HTTPS URI scheme may look like https://app.foo.com/oauth2/redirect. 
Unlike in private URI scheme, the browser verifies the identity of the claimed HTTPS URI 
before redirection, and for the same reason, it is recommended to use claimed HTTPS 
URI scheme over others where possible.
 Loopback Interface
With this approach, your native app will listen on a given port in the device itself. In 
other words, your native app acts as a simple web server. For example, your redirect 
URI will look like http://127.0.0.1:5000/oauth2/redirect. Since we are using the 
1 https://tools.ietf.org/html/rfc7595#section-3.8
Chapter 10  aCCessing apis via native Mobile apps
235
loopback interface (127.0.0.1), when the browser sees this URL, it will hand over the 
control to the service listening on the mobile device on port 5000. The challenge with 
this approach is that your app may not be able to run on the same port on all the devices, 
if there are any other apps on the mobile device already using the same port.
 Proof Key for Code Exchange (PKCE)
Proof Key for Code Exchange (PKCE) is defined in the RFC 7636 as a way to mitigate 