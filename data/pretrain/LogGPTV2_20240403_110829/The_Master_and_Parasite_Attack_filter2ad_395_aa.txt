title:The Master and Parasite Attack
author:Lukas Baumann and
Elias Heftrig and
Haya Shulman and
Michael Waidner
The Master and Parasite Attack
Lukas Baumann, Elias Heftrig, Haya Shulman and Michael Waidner
Fraunhofer Institute for Secure Information Technology
Darmstadt, Germany
1
2
0
2
l
u
J
3
1
]
R
C
.
s
c
[
1
v
5
1
4
6
0
.
7
0
1
2
:
v
i
X
r
a
Abstract—We explore a new type of malicious script attacks:
the persistent parasite attack. Persistent parasites are stealthy
scripts, which persist for a long time in the browser’s cache.
We show to infect the caches of victims with parasite scripts via
TCP injection.
Once the cache is infected, we implement methodologies for
propagation of the parasites to other popular domains on the
victim client as well as to other caches on the network. We
show how to design the parasites so that they stay long time
in the victim’s cache not restricted to the duration of the
user’s visit to the web site. We develop covert channels for
communication between the attacker and the parasites, which
allows the attacker to control which scripts are executed and
when, and to exﬁltrate private information to the attacker, such
as cookies and passwords. We then demonstrate how to leverage
the parasites to perform sophisticated attacks, and evaluate the
attacks against a range of applications and security mechanisms
on popular browsers. Finally we provide recommendations for
countermeasures.
I. INTRODUCTION
Malware is the most signiﬁcant threat to computer users;
and, from all types of malware, the greatest threat are ad-
vanced persistent threats (APTs), which may reside in the
victim’s computer for long time without detection. However,
installing malware - and APTs - on a victim’s computer
can be challenging. Either the attacker has to trick the user
into installing a malicious software, or a vulnerability in
user’s system or applications must be exploited to install the
malicious software without the user’s permission.
In contrast, browsers automatically download and execute
code from remote websites. Unlike with malicious software,
such code runs in a restricted sandbox, rather than the ‘native’
code of malware. The goal of the sandbox is to prevent attacks
by automatically downloaded code. Furthermore, remotely-
downloaded Javascript code executes only while the browser
visits the relevant website, i.e., ephemerally rather than per-
sistently, and stays in the browser for as long as there is place
in the cache and the website does not serve a new version
of the same object. Hence, any malicious computation, such
as abusing users’ compute power for crypto-currency mining
[24], can affect the users only as long as they visit the website
or until the script is evicted from the cache.
In summary, Javascript and other remote code executed in
a sandbox is believed to be a relatively minor – in contrast to
user or root level malware – ephemeral (non-persistent) threat.
However, in this work, we show that remotely-downloaded
Javascript can be persistent and poses a serious threat. In
particular, we show that attackers can perform an attack so that
these scripts are executed permanently in victims’ browsers
and then actively spread this attack to other domains. The ﬁrst
step of our attack includes injecting and spreading a malicious
script, which we call parasite. We then show how these scripts
can be abused by the attacker to perform various attacks
against applications, such as stealing clients’ credentials on
popular web sites or bypassing a two factor authentication. We
evaluate the effectiveness of these attacks on popular browsers.
Typically such attacks should not be possible: a script coming
from an attacker would be restricted by the Same Origin
Policy (SOP) and hence should not be able to access data
of objects coming from other domains. To bypass the SOP the
attacker camouﬂages the malicious (parasite) script to appear
as if it originated from a real origin website. We develop
methodologies to keep the parasite in the victim’s browser over
long time periods and to control it to launch attacks against
different applications, even after the client moves to a different
(e.g., home) network. The parasite uses modules we developed
for Command and Control (C&C) to the attacker and for
propagation. We demonstrate attacks that we implemented
using the parasites and provide results of our experimental
evaluation.
Attack Overview. The attack consists of four modules: (1)
cache eviction, (2) injection into transport layer, (3) parasite
construction and ﬁnally (4) applying the parasites to launch
sophisticated attacks.
As a ﬁrst step, the attacker performs cache eviction (Section
IV), to remove cached objects of popular target domains, then
causes the browser to issue an HTTP request to the target
website. The attacker injects a spoofed TCP segment with the
infected object into the HTTP response from the server, which
delivers the malicious payload into victim’s cache (Section
V). The injection can be performed with a remote attacker
by launching DNS cache poisoning [33, 16, 34, 17, 13, 5,
15, 19, 21, 1, 44, 5]. As soon as the parasite is cached in
the victim’s browser, it starts infecting other domains in the
cache and establishes a C&C to the remote attacker to carry
out advanced attacks against applications (Section VII).
Contributions. Our goal is to explore the attacks against ap-
plications that remotely controlled parasite scripts can launch
and the feasibility of constructing such parasite scripts in the
wild. Our contributions can be summarised as follows:
• We identify websites which use persistent objects. We
measure the persistency and prevalence of these objects on
popular websites. We found that more than 87% of the
websites have at least one object persistent over a period of
5 days. We modify these objects attaching to them malicious
©2021 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other uses, in any current or future media, including
reprinting/republishing this material for advertising or promotional purposes, creating new collective works, for resale or redistribution to servers or lists, or
reuse of any copyrighted component of this work in other works.
parasites.
for communication between the attacker and the parasites.
• We develop methodologies to force the browsers to keep
our parasite scripts in the cache even after the victim stops
visiting the website whose object was infected with a parasite,
and even after the victim moves to a different network.
• We devise techniques to bypass SOP, allowing the para-
sites to propagate between different domains and caches. Our
techniques can be systematically launched via TCP injection
in contrast to previous work which exploited bugs to bypass
SOP [27]. Since our approach leverages the standard behaviour
of the systems it is much more difﬁcult to block.
• We develop and evaluate command and control channels
• We developed a taxonomy of popular caches and evaluate
our attacks experimentally against them. These are caches that
can be infected with our parasite and then used to attack the
applications.
• We developed a taxonomy of the exploits against popular
applications which we attacked with our parasites botnet.
The applications range from ﬁnancial and banking systems to
hardware components on devices (such as camera and mic).
Organisation. In Related Work, Section II we review
research relevant
to our work. In Section III we explain
our attacker model. In Sections IV, V and VI we present
the implementation of our attacker and report results of our
evaluations in the Internet. In Section VII we demonstrate
how parasites can be leveraged to attack a wide range of
systems and applications and provide recommendations for
countermeasures in Section VIII. We conclude this work in
Section IX.
II. RELATED WORK
Malicious JavaScript attacks. Due to policies like SOP
[30], CORS [40] and CSP [36] execution of scripts is sand-
boxed to the speciﬁc domain. Nevertheless, there have been at-
tacks that demonstrated that scripts can utilise side channels to
read memory or even change content of memory [23, 14, 35].
Furthermore, malicious scripts do not necessarily need to break
out to cause harm, as they have access to the CPU and may
utilise this computing power for cryptojacking [12]. Prior
Javascript attacks exploited bugs in browser’s implementations
of SOP [8, 3, 18, 29]. We demonstrate attacks which do not
exploit a bug in the SOP, but combine transport layer attacks
in tandem with browser’s cache infection to bypass SOP
restrictions. This makes our attacks much more difﬁcult to
block since they exploit the correct behaviour of the protocols.
There has been work on how to circumvent SOP and CSP by
loading images, that contain JavaScript, e.g., [20]. An attacker
would still need access to the domain as his image has to be
loaded there, to unleash the full potential of JavaScript. Same
applies to the SOP. In contrast, our attack infects the domain
directly and supplies new methods to create communication
channels outside the SOP. The CSP is able to reduce the
impact, but as the scripts are executed within the domain, a
wide range of attacks may be executed.
Browser cache poisoning. There has been research on
how to poison the cache of a browser in different ways,
e.g., [7, 39, 9]. These show, that caching is a problem at
the clientside as the server is not contacted once an element
has been cached. This is extended by even injecting malicious
code into objects loaded via HTTPS due to users ignoring the
certiﬁcate errors or supplying malicious browser extensions for
the clientside. In this work we show how to create a persistent
network of malicious ﬁles without a user browsing these while
being exposed to an attacker.
Finally, we perform the ﬁrst experimental study of the
attacks that parasite scripts can launch against different ap-
plications. We also evaluate the infection, the propagation and
the communication of the parasites on popular browsers.
III. ATTACKER MODEL
Our attacker consists of a master which injects malicious
scripts - we call parasites - into the browser caches of the
victim clients. The master then controls the parasites and uses
them to launch sophisticated attacks against the victim clients.
Master can eavesdrop on the packets exchanged by the
victim client but cannot block or modify them. Such an
attacker can be another client on a public Wireless network.
The master sees the TCP source port and the TCP sequence
number in the segments sent by the client and hence can craft
correct response segments impersonating the server, without
the need to guess these parameters. Our attack proceeds by
injecting TCP segments into the TCP connection between the
victim client and the target website.
Parasites are scripts coming from the legitimate website
modiﬁed by the attacker to include a malicious behaviour.
The parasite is injected by the master into the communication
between the client and the website. It is then cached by the
victim client’s browser. We show how to construct the parasite
so that it stays in the browser persistently over long time
periods, even when the victim client shuts down its device or
changes network. The parasite propagates and infects multiple
other domains in the victim’s browser’s cache. The parasites
communicate between themselves and the master and execute
commands and attacks on behalf of the master.
IV. EVICTION FROM BROWSER’S CACHE
To infect an object from some website with a malicious
script of the attacker, the attacker has to cause the client to
issue an HTTP request for that object. Typically objects from
popular websites will be cached in victims’ browsers, hence
during repeated visits to a website the client will not issue
requests for objects that are already cached. As a result the
attacker cannot inject its malicious script.
Victim
Attacker
GET any.com
Server
1
3
3
3
3
3
tcp injection
2
ignored benign response
GET attacker.com/junk01.jpg
GET attacker.com/junk02.jpg
GET attacker.com/junk03.jpg
GET ...
GET popular.com/img.png
Fig. 1. Cache eviction. Legitimate messages are blue, attack are red.
To force the browsers to retrieve the newest copy of the
object we perform an enforced cache cleaning. We developed
a cache eviction module, which removes (evicts) all the objects
from the browser’s cache. Cache cleaning is illustrated in
Figure 1 and proceeds as follows: When a user establishes
a connection to some website, the attacker injects a spoofed
TCP segment (a small inline script), impersonating an authen-
tic TCP segment from the website, into a TCP connection
between the user and the website. The injection is illustrated
in Figure 1 2 . This script dynamically loads requests for
junk objects (images) in the attacker’s domain. The responses
populate the cache with the objects and supplant (older) cached
elements. The cache eviction procedure ensures that all further
requests for objects generate new retrieval requests from the
web server (Figure 1 3 ), which responses get modiﬁed by
the attacker in the next step.
Evaluation. We evaluated cache eviction against popular
browsers1. The browsers differ in cache types, sizes and cache
eviction methodologies. We also investigated, whether they
allocate memory per domain. If cache capacity is shared be-
tween all domains, even if a victim cached objects of a.com,
they may be evicted upon visit to b.com, for example. The
results are shown in Table IV. Eviction from Chromium-
Browser
Chrome
Chrome*
Edge
IE
Firefox
Opera
Version
81.0.4044.122
81.0.4044.122
84.0.522.59
11.1365.17134.0
75.0
68.0.3618.56
I.D.
Ev.
(cid:8)
(cid:8)
(cid:8)
(cid:8)
(cid:8)