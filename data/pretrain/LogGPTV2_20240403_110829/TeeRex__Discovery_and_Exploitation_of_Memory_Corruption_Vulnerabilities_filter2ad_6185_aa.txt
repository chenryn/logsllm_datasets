title:TeeRex: Discovery and Exploitation of Memory Corruption Vulnerabilities
in SGX Enclaves
author:Tobias Cloosters and
Michael Rodler and
Lucas Davi
TeeRex: Discovery and Exploitation of Memory 
Corruption Vulnerabilities in SGX Enclaves
Tobias Cloosters, Michael Rodler, and Lucas Davi, University of Duisburg-Essen
https://www.usenix.org/conference/usenixsecurity20/presentation/cloosters
This paper is included in the Proceedings of the 29th USENIX Security Symposium.August 12–14, 2020978-1-939133-17-5Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.TEEREX: Discovery and Exploitation of Memory Corruption
Vulnerabilities in SGX Enclaves
Tobias Cloosters, Michael Rodler, Lucas Davi
University of Duisburg-Essen, Germany
{tobias.cloosters, michael.rodler, lucas.davi}@uni-due.de
Abstract
Intel’s Software Guard Extensions (SGX) introduced new
instructions to switch the processor to enclave mode which
protects it from introspection. While the enclave mode
strongly protects the memory and the state of the proces-
sor, it cannot withstand memory corruption errors inside the
enclave code. In this paper, we show that the attack surface
of SGX enclaves provides new challenges for enclave devel-
opers as exploitable memory corruption vulnerabilities are
easily introduced into enclave code. We develop TEEREX to
automatically analyze enclave binary code for vulnerabilities
introduced at the host-to-enclave boundary by means of sym-
bolic execution. Our evaluation on public enclave binaries re-
veal that many of them suffer from memory corruption errors
allowing an attacker to corrupt function pointers or perform
arbitrary memory writes. As we will show, TEEREX features
a speciﬁcally tailored framework for SGX enclaves that al-
lows simple proof-of-concept exploit construction to assess
the discovered vulnerabilities. Our ﬁndings reveal vulnerabil-
ities in multiple enclaves, including enclaves developed by
Intel, Baidu, and WolfSSL, as well as biometric ﬁngerprint
software deployed on popular laptop brands.
1 Introduction
Intel recently introduced a sophisticated trusted execu-
tion environment (TEE) called Software Guard Extensions
(SGX) [30, 37, 50]. SGX allows application developers to
create so-called enclaves to encapsulate sensitive application
code and data inside a TEE that is completely isolated from
other applications, operating systems, and hypervisors. The
only trusted component in the SGX setting is the Intel CPU
itself. Most prominently, SGX features conﬁdentiality and
integrity protection for any data that is written to its main
memory. In addition, SGX implements well-known Trusted
Computing concepts such as data binding and sealing as well
as remote attestation, i.e., ensuring the remote SGX enclave is
in a trustworthy state. Putting all these features together, this
allows a user to establish a secure channel directly to the SGX
enclave (which potentially runs in an untrusted cloud environ-
ment) and perform remote attestation to ensure the integrity
of the remote SGX hardware and enclave. That said, SGX is
a strong isolation mechanism for sensitive data (e.g., personal
information or cryptographic keys) as well as security-critical
code (e.g., for the sake of intellectual property protection).
It also found its way into commercial applications, e.g., ﬁn-
gerprint sensor software (Section 5), DRM protection [20],
and privacy-preserving applications like Signal [48]. As such
a promising technology, SGX has been used and targeted
extensively in previous research. Many projects propose to
utilize SGX for enhanced security guarantees, e.g., processing
private data in public clouds [6, 55].
From its infancy, it was clear that SGX cannot withstand
all ﬂavors of attacks [40]. In particular, SGX cannot protect
against two classes of attacks: (1) side-channel attacks and
(2) memory corruption attacks inside the enclave. The former
attack technique exploits shared resources (e.g., cache) to
steal secret information from within an enclave. This line
of research has become a very active research ﬁeld [65, 70].
Especially micro-architectural side-channels have been shown
to be effective for attacking SGX enclaves due to the shared
micro-architectural state of enclaves and untrusted code [62].
To our surprise, memory corruption attacks have been
rarely investigated in the context of SGX. These attacks ex-
ploit programming errors (e.g., a buffer overﬂow) allowing
an attacker to take over the enclave, hijacking the enclave’s
control-ﬂow, and perform code-reuse attacks such as return-
oriented programming (ROP) [57]. Further, the attacker can
also exploit these errors to corrupt enclave data variables and
pointers to launch data-oriented attacks such as information
leaks or data-oriented programming (DOP) [33]. Prior re-
search studied the applicability of offensive and defensive
techniques against memory corruption exploits. For instance,
Lee et al. [44] presented DARKROP, a code-reuse attack tech-
nique, which shows that the enclave code must not be known
to an attacker to successfully launch ROP attacks against the
enclave. Biondo et al. [7] showed that it is easily possible to
USENIX Association
29th USENIX Security Symposium    841
launch powerful code-reuse attacks due to particularities of
the Intel SGX SDK bypassing existing ASLR defenses such
as SGX-Shield [56].
However, prior research on memory corruption attacks al-
ways assumed the existence of memory errors, but did not
investigate whether or to which extent such errors exist in
real-world enclaves. Due to the rather slow adoption of the
SGX technology, this is not an easy question to answer. Ide-
ally, SGX enclaves contain only a minimal amount of code,
which can be manually audited or even formally veriﬁed to
not contain any programming mistakes. However, in our ex-
perience, legacy code bases are often ported to SGX enclaves.
These ports are often not revised to handle the specialties of
SGX enclaves and inherit security vulnerabilities from the
legacy code base or introduce new security vulnerabilities
particular to SGX enclaves. This is similar for newly written
SGX code by developers not familiar with the peculiarities of
SGX.
One common aspect of all SGX enclaves is that they always
link to an untrusted host application. The host application
loads an SGX enclave into its address space as it would do in
case of a shared library. Indeed, the Intel SGX SDK offers a
C-function like interface allowing bidirectional communica-
tion from the host application to the enclave. This interface is
highly critical as invalid input may lead to a privilege escala-
tion attack. As shown by prior research in the context of other
privilege separation technologies, this is especially true when
software is partitioned into privilege levels [13, 32]. That said,
whenever an enclave is called, it must take special care to
validate any input, particularly when the input contains code
or data pointers.
Contributions.
In this paper, we demonstrate that the attack
surface of SGX enclaves provides new challenges for enclave
developers as exploitable memory corruption vulnerabilities
are easily introduced into enclave code due to a combina-
tion of the unique threat model of SGX enclaves and the
current prevalent programming model for SGX (i.e., the Intel
SGX SDK). We introduce the ﬁrst SGX vulnerability analysis
framework, called TEEREX, to automatically analyze enclave
binary code based on symbolic execution (see Section 4). We
implement vulnerability detectors in TEEREX that take all the
peculiarities of SGX enclaves into account allowing develop-
ers to identify vulnerabilities in enclave binaries a priori, i.e.,
before they are utilized in production.
Using TEEREX, we identiﬁed several vulnerabilities in
publicly available enclave binaries developed at major compa-
nies such as Intel, Baidu, and Synaptics (see Section 5). Our
framework features detailed vulnerability reports signiﬁcantly
simplifying the construction of proof-of-concept exploits to
assess the reported vulnerability. Even if no information on
the enclave is available, we are able to construct exploits (see
the ﬁngerprint enclaves analyzed in Section 5.5 and 5.6). Our
exploits hijack the enclave’s control-ﬂow, effectively bypass-
ing all security guarantees of the SGX technology. By per-
forming root-cause analysis we identiﬁed ﬁve vulnerability
classes that repeatedly occur in our dataset: Passing Data-
Structures with Pointers (P1), Returning pointers to enclave
memory (P2), Pointers to Overlapping Memory (P3), NULL-
Pointer Dereferences (P4), and Time-of-Check Time-of-Use
(P5).
Interestingly, among the enclaves we found vulnerable is
one enclave written by Intel engineers and published as an
open-source example enclave on Intel’s GitHub page [34].
Another interesting ﬁnding is a vulnerability in a sample SGX
enclave originally developed at Baidu with the Rust SGX SDK
(now an Apache Incubator project). Rust features memory
safety and as such has the potential to eradicate memory
corruption attacks. However, the host-to-enclave boundary is
inherently memory unsafe and as such, using memory-safe
programming languages in SGX does not automatically result
in secure enclave code.
2 Memory Corruption in SGX
The lack of built-in memory safety in the common system-
level programming languages C/C++ has led to a multi-
tude of memory corruption vulnerabilities in the last three
decades [60]. These vulnerabilities allow an attacker to per-
form a limited or (often) arbitrary write to memory. Such
malicious writes manipulate (1) control-ﬂow information on
stack and heap (e.g., return addresses and function pointers)
or (2) so-called non-control data (e.g., decision-making vari-
ables). In both cases, the attacker inﬂuences the program’s
execution ﬂow and eventually executes a malicious sequence
of instructions. In the recent past, we witnessed an arms
race between defenses and memory corruption attacks: data-
execution prevention [51, 52] effectively prevents malicious
code injection in data memory, but can be bypassed by means
of return-oriented programming (ROP) attacks as these only
reuse code already residing in code memory [57]. Software-
diversity based defenses [39, 43] mitigate ROP attacks by
randomizing the location of code in memory but are circum-
vented if an attacker manages to dynamically disclose the
code location [59]. Similarly, control-ﬂow integrity (CFI) [1]
depends on the precision of the control-ﬂow graph (CFG)
as CFG over-approximation opens the door for subtle ROP
attacks [11, 21, 27]. Lastly, even if one would be able to de-
velop a perfect CFI scheme, non-control data attacks would
We especially focus our investigation on the validation
of pointers that are passed from the host application to the
enclave. Our ﬁndings demonstrate that developers are not
aware of the difﬁculties of securely implementing enclave
code when dealing with the critical host-to-enclave boundary.
We found that the automatically generated checks of the Intel
SGX SDK are insufﬁcient for non-trivial pointer-based data
structures and a lack of proper manual validation of pointers
or pointer-heavy data structures can easily lead to memory
corruption vulnerabilities.
842    29th USENIX Security Symposium
USENIX Association
still be a viable attack option as they only execute execution
paths that adhere to the program’s CFG [15, 33, 38, 53].
In general, SGX enclaves are as susceptible to memory
corruption attacks as any other system software. In fact, al-
most all enclaves are developed in C/C++ mainly because
the ofﬁcial Intel SGX SDK [36] provides a C/C++ develop-
ment environment. Only recently, memory-safe languages
such as Rust have been explored as a programming language
for SGX enclaves [67]. However, as we will show, even these
cannot guarantee that enclaves are free of memory corruption
vulnerabilities.
One particular challenge arises when launching memory
corruption attacks against SGX enclaves: since SGX enclaves
are encrypted in memory and can be shipped as an encrypted
binary [6, 55], an attacker cannot necessarily perform static
analysis on the enclave’s binary to search for interesting ROP
gadgets (i.e., enclave code sequences maliciously combined
to trigger malicious operations). Lee et al. [44] tackle this
challenge by repeatedly executing an enclave, triggering the
execution at different entry points, and analyzing memory
access to dynamically identify ROP gadgets. Note that this
attack does not apply to enclaves whose code addresses are
randomized for each instantiation of the enclave. On the other
hand, existing SGX randomization schemes such as SGX-
Shield [56] are not able to apply randomization to all of the
enclave’s code area: Biondo et al. [7] demonstrated that the
Intel SGX SDK provides enclave libraries that are not random-
ized and include several powerful ROP gadgets (i.e., gadgets
that allow control of many processor registers). Speciﬁcally,
these gadgets are invoked when resuming the context of an
SGX enclave (OCALL-return). Hence, an attacker only needs
to launch a memory corruption attack and provide counterfeit
context information to hijack a vulnerable enclave.
Problem Setting. We observe that existing memory corrup-
tion attacks against SGX [7, 44] exploit the host-to-enclave
boundary as this serves as entry point to trigger and halt en-
clave execution. Further, the existing attacks assumed that
the attacker is capable of hijacking the control ﬂow of the
enclave’s code by means of a given memory corruption vul-
nerability. However, the open question is whether such vul-
nerabilities are likely to occur when developing enclaves.
To answer this question, we reverse-engineer public enclave
code and develop automated analysis techniques to assess
the security of enclaves with regards to memory corruption
vulnerabilities. Our ﬁndings demonstrate that an erroneous
implementation of the API at the host-to-enclave boundary is
often the root-cause for memory corruption vulnerabilities in
SGX code.
3 SGX Preliminaries
In this section, we provide background information on the
Software Guard Extensions (SGX) technology of modern
Figure 1: General overview on SGX-enabled applications.
Intel processors and more speciﬁcally the Intel SGX SDK.
The Intel SGX SDK is currently the primary way to develop
SGX enclave code and is ofﬁcially endorsed by Intel.
3.1 Host-Enclave Interface
Figure 1 provides a general overview of the memory layout of
SGX-enabled applications as well as the channel for host-to-
enclave interaction. The SGX enclave is part of a user space
application, called host process or application, which even-
tually loads and executes the enclave. Both host and enclave
share the same virtual address space with the exception that
the enclave resides in encrypted and integrity-protected mem-
ory. As shown in Figure 1, in the enclave view enclaves can
access all of the host application’s memory. Only the enclave
memory is assumed as trusted, whereas all other memory
parts are considered as untrusted.
The host process starts the enclave’s execution by issuing
the special EENTER instruction to enter the enclave. For this,
enclaves deﬁne entry points in the so-called thread control
structures (TCS), which are locked while in use by a thread.
This makes the number of TCS also the maximum number
of threads that can enter an enclave concurrently. A jump
from the executing enclave to code in the host application
results in a segmentation fault, effectively making host code
non-executable for the enclave. As such, the enclave must
explicitly leave enclave mode by using the EEXIT instruction
before the thread can execute any non-enclave code.
The Intel SGX SDK provides the concept of ECALLs (en-
clave calls) on-top of EENTER to control the transition from
application code to enclave code. For a simple enclave, not
requiring multi-threading, the SDK uses only one TCS which
is called with the index of the desired ECALL. First, the host
application calls the ECALL wrapper in the untrusted runtime
(urts). Next, the urts prepares the transition to the SGX en-
clave according to the so-called EDL ﬁle. Second, it executes