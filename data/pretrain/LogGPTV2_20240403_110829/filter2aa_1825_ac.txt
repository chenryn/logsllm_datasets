routine called the system service dispatcher.
The system service dispatcher, in turn, uses the value in that EAX register as an index into a System Service
Dispatch Table (SSDT). Using this table, the code jumps to the system service (system call) itself. For
our Notepad example, the SSDT entry would point to the NtCreateFile function, implemented by the
kernel’s I/O manager. Notice the function has the same name as the one in NTDLL.dll, and has the same
parameters as well. On the kernel side is the real implementation. Once the system service is complete,
the thread returns to user mode to execute the instruction following sysenter/syscall. This sequence
of calls is depicted in figure 1-8.
Figure 1-8: System service function call flow
Chapter 1: Windows Internals Overview
13
General System Architecture
Figure 1-9 shows the general architecture of Windows, comprising of user-mode and kernel-mode
components.
Figure 1-9: Windows system architecture
Here’s a quick rundown of the named boxes appearing in figure 1-9:
• User processes
These are normal processes based on image files, executing on the system, such as instances of
Notepad.exe, cmd.exe, explorer.exe, and so on.
• Subsystem DLLs
Subsystem DLLs are dynamic link libraries (DLLs) that implement the API of a subsystem. A
subsystem is a particular view of the capabilities exposed by the kernel. Technically, starting from
Windows 8.1, there is only a single subsystem – the Windows Subsystem. The subsystem DLLs
include well-known files, such as kernel32.dll, user32.dll, gdi32.dll, advapi32.dll, combase.dll, and
many others. These include mostly the officially documented API of Windows.
• NTDLL.DLL
A system-wide DLL, implementing the Windows native API. This is the lowest layer of code which
is still in user mode. Its most important role is to make the transition to kernel mode for system call
invocation. NTDLL also implements the Heap Manager, the Image Loader and some part of the user
mode thread pool.
Chapter 1: Windows Internals Overview
14
• Service Processes
Service processes are normal Windows processes that communicate with the Service Control
Manager (SCM, implemented in services.exe) and allow some control over their lifetime. The SCM
can start, stop, pause, resume and send other messages to services. Services typically execute under
one of the special Windows accounts – local system, network service or local service.
• Executive
The Executive is the upper layer of NtOskrnl.exe (the “kernel”). It hosts most of the code that is
in kernel mode. It includes mostly the various “managers”: Object Manager, Memory Manager, I/O
Manager, Plug & Play Manager, Power Manager, Configuration Manager, etc. It’s by far larger than
the lower Kernel layer.
• Kernel
The Kernel layer implements the most fundamental and time-sensitive parts of kernel-mode OS
code. This includes thread scheduling, interrupt and exception dispatching, and implementation of
various kernel primitives such as mutexes and semaphores. Some of the kernel code is written in
CPU-specific machine language for efficiency and for getting direct access to CPU-specific details.
• Device Drivers
Device drivers are loadable kernel modules. Their code executes in kernel mode and so has the full
power of the kernel. This book is dedicated to writing certain types of kernel drivers.
• Win32k.sys
This is the kernel-mode component of the Windows subsystem. Essentially, it’s a kernel module
(driver) that handles the user interface part of Windows and the classic Graphics Device Inter-
face (GDI) APIs. This means that all windowing operations (CreateWindowEx, GetMessage,
PostMessage, etc.) are handled by this component. The rest of the system has little-to-none
knowledge of UI.
• Hardware Abstraction Layer (HAL)
The HAL is a software abstraction layer over the hardware closest to the CPU. It allows device
drivers to use APIs that do not require detailed and specific knowledge of things like Interrupt
Controllers or DMA controller. Naturally, this layer is mostly useful for device drivers written to
handle hardware devices.
• System Processes
System processes is an umbrella term used to describe processes that are typically “just there”, doing
their thing where normally these processes are not communicated with directly. They are important
nonetheless, and some in fact, critical to the system’s well-being. Terminating some of them is fatal
and causes a system crash. Some of the system processes are native processes, meaning they use
the native API only (the API implemented by NTDLL). Example system processes include Smss.exe,
Lsass.exe, Winlogon.exe, and Services.exe.
• Subsystem Process
The Windows subsystem process, running the image Csrss.exe, can be viewed as a helper to the
kernel for managing processes running under the Windows subsystem. It is a critical process,
meaning if killed, the system would crash. There is one Csrss.exe instance per session, so on a
standard system two instances would exist – one for session 0 and one for the logged-on user session
(typically 1). Although Csrss.exe is the “manager” of the Windows subsystem (the only one left these
days), its importance goes beyond just this role.
Chapter 1: Windows Internals Overview
15
• Hyper-V Hypervisor
The Hyper-V hypervisor exists on Windows 10 and server 2016 (and later) systems if they support
Virtualization Based Security (VBS). VBS provides an extra layer of security, where the normal OS is
a virtual machine controlled by Hyper-V. Two distinct Virtual Trust Levels (VTLs) are defined, where
VTL 0 consists of the normal user-mode/kernel-mode we know of, and VTL 1 contains the secure
kernel and Isolated User Mode (IUM). VBS is beyond the scope of this book. For more information,
check out the Windows Internals book and/or the Microsoft documentation.
Windows 10 version 1607 introduced the Windows Subsystem for Linux (WSL). Although this
may look like yet another subsystem, like the old POSIX and OS/2 subsystems supported by
Windows, it is not like that at all. The old subsystems were able to execute POSIX and OS/2 apps
if these were compiled using a Windows compiler to use the PE format and Windows system
calls. WSL, on the other hand, has no such requirement. Existing executables from Linux (stored
in ELF format) can be run as-is on Windows, without any recompilation.
To make something like this work, a new process type was created – the Pico process together
with a Pico provider. Briefly, a Pico process is an empty address space (minimal process) that is
used for WSL processes, where every system call (Linux system call) must be intercepted and
translated to the Windows system call(s) equivalent using that Pico provider (a device driver).
There is a true Linux (the user-mode part) installed on the Windows machine.
The above description is for WSL version 1. Starting with Windows 10 version 2004, Windows
supports a new version of WSL known as WSL 2. WSL 2 is not based on pico processes anymore.
Instead, it’s based on a hybrid virtual machine technology that allows installing a full Linux
system (including the Linux kernel), but still see and share the Windows machine’s resources,
such as the file system. WSL 2 is faster than WSL 1 and solves some edge cases that didn’t work
well in WSL 1, thanks to the real Linux kernel handling Linux system calls.
Handles and Objects
The Windows kernel exposes various types of objects for use by user-mode processes, the kernel itself and
kernel-mode drivers. Instances of these types are data structures in system space, created by the Object
Manager (part of the executive) when requested to do so by user-mode or kernel-mode code. Objects are
reference counted – only when the last reference to the object is released will the object be destroyed and
freed from memory.
Since these object instances reside in system space, they cannot be accessed directly by user mode. User
mode must use an indirect access mechanism, known as handles. A handle is an index to an entry in a table
maintained on a process by process basis, stored in kernel space, that points to a kernel object residing in
system space. There are various Create* and Open* functions to create/open objects and retrieve back
handles to these objects. For example, the CreateMutex user-mode function allows creating or opening a
mutex (depending on whether the object is named and exists). If successful, the function returns a handle
to the object. A return value of zero means an invalid handle (and a function call failure). The OpenMutex
function, on the other hand, tries to open a handle to a named mutex. If the mutex with that name does
not exist, the function fails and returns null (0).
Chapter 1: Windows Internals Overview
16
Kernel (and driver) code can use either a handle or a direct pointer to an object. The choice is usually
based on the API the code wants to call. In some cases, a handle given by user mode to the driver must be
turned into a pointer with the ObReferenceObjectByHandle function. We’ll discuss these details in a
later chapter.
Most functions return null (zero) on failure, but some do not. Most notably, the CreateFile
function returns INVALID_HANDLE_VALUE (-1) if it fails.
Handle values are multiples of 4, where the first valid handle is 4; Zero is never a valid handle value.
Kernel-mode code can use handles when creating/opening objects, but they can also use direct pointers
to kernel objects. This is typically done when a certain API demands it. Kernel code can get a pointer
to an object given a valid handle using the ObReferenceObjectByHandle function. If successful,
the reference count on the object is incremented, so there is no danger that if the user-mode client
holding the handle decided to close it while kernel code holds a pointer to the object would now hold
a dangling pointer. The object is safe to access regardless of the handle-holder until the kernel code calls
ObDerefenceObject, which decrements the reference count; if the kernel code missed this call, that’s
a resource leak which will only be resolved in the next system boot.
All objects are reference counted. The object manager maintains a handle count and total reference count
for objects. Once an object is no longer needed, its client should close the handle (if a handle was used to
access the object) or dereference the object (if kernel client using a pointer). From that point on, the code
should consider its handle/pointer to be invalid. The Object Manager will destroy the object if its reference
count reaches zero.
Each object points to an object type, which holds information on the type itself, meaning there is a single
type object for each type of object. These are also exposed as exported global kernel variables, some of
which are defined in the kernel headers and are needed in certain cases, as we’ll see in later chapters.
Object Names
Some types of objects can have names. These names can be used to open objects by name with a suitable
Open function. Note that not all objects have names; for example, processes and threads don’t have names
– they have IDs. That’s why the OpenProcess and OpenThread functions require a process/thread
identifier (a number) rather than a string-base name. Another somewhat weird case of an object that does
not have a name is a file. The file name is not the object’s name – these are different concepts.
Threads appear to have a name (starting from Windows 10), that can be set with the user-
mode API SetThreadDescription. This is not, however, a true name, but rather a friendly
name/description most useful in debugging, as Visual Studio shows a thread’s description, if
there is any.
Chapter 1: Windows Internals Overview
17
From user-mode code, calling a Create function with a name creates the object with that name if an object
with that name does not exist, but if it exists it just opens the existing object. In the latter case, calling
GetLastError returns ERROR_ALREADY_EXISTS, indicating this is not a new object, and the returned
handle is yet another handle to an existing object.
The name provided to a Create function is not actually the final name of the object. It’s prepended with
\Sessions\x\BaseNamedObjects\ where x is the session ID of the caller. If the session is zero, the name is
prepended with \BaseNamedObjects\. If the caller happens to be running in an AppContainer (typically
a Universal Windows Platform process), then the prepended string is more complex and consists of the
unique AppContainer SID: \Sessions\x\AppContainerNamedObjects\{AppContainerSID}.
All the above means is that object names are session-relative (and in the case of AppContainer – package
relative). If an object must be shared across sessions it can be created in session 0 by prepending
the object name with Global\; for example, creating a mutex with the CreateMutex function named
Global\MyMutex will create it under \BaseNamedObjects. Note that AppContainers do not have the power
to use session 0 object namespace.
This hierarchy can be viewed with the Sysinternals WinObj tool (run elevated) as shown in figure 1-10.
Figure 1-10: Sysinternals WinObj tool
The view shown in figure 1-9 is the object manager namespace, comprising of a hierarchy of named objects.
This entire structure is held in memory and manipulated by the Object Manager (part of the Executive)
Chapter 1: Windows Internals Overview
18
as required. Note that unnamed objects are not part of this structure, meaning the objects seen in WinObj
do not comprise all the existing objects, but rather all the objects that were created with a name.
Every process has a private handle table to kernel objects (whether named or not), which can be viewed
with the Process Explorer and/or Handles Sysinternals tools. A screenshot of Process Explorer showing
handles in some process is shown in figure 1-11. The default columns shown in the handles view are the
object type and name only. However, there are other columns available, as shown in figure 1-11.
Figure 1-11: Viewing handles in processes with Process Explorer
By default, Process Explorer shows only handles for objects, which have names (according to Process
Explorer’s definition of a name, discussed shortly). To view all handles in a process, select Show Unnamed
Handles and Mappings from Process Explorer’s View menu.
The various columns in the handle view provide more information for each handle. The handle value and
the object type are self explanatory. The name column is tricky. It shows true object names for Mutexes
(Mutants), Semaphores, Events, Sections, ALPC Ports, Jobs, Timers, Directory (object manager Directories,
not file system directories), and other, less used object types. Yet others are shown with a name that has a
different meaning than a true named object:
• Process and Thread objects, the name is shown as their unique ID.
• For File objects, it shows the file name (or device name) pointed to by the file object. It’s not the
same as an object’s name, as there is no way to get a handle to a file object given the file name -
only a new file object may be created that accesses the same underlying file or device (assuming
sharing settings for the original file object allow it).
• (Registry) Key objects names are shown with the path to the registry key. This is not a name, for
the same reasoning as for file objects.
• Token object names are shown with the user name stored in the token.
Chapter 1: Windows Internals Overview
19
Accessing Existing Objects
The Access column in Process Explorer’s handles view shows the access mask which was used to open or
create the handle. This access mask is key to what operations are allowed to be performed with a specific
handle. For example, if client code wants to terminate a process, it must call the OpenProcess function
first, to obtain a handle to the required process with an access mask of (at least) PROCESS_TERMINATE,
otherwise there is no way to terminate the process with that handle. If the call succeeds, then the call to
TerminateProcess is bound to succeed.
Here’s a user-mode example for terminating a process given a process ID:
bool KillProcess(DWORD pid) {
//
// open a powerful-enough handle to the process
//
HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
if (!hProcess)
return false;
//
// now kill it with some arbitrary exit code
//
BOOL success = TerminateProcess(hProcess, 1);
//
// close the handle
//
CloseHandle(hProcess);
return success != FALSE;
}
The Decoded Access column provides a textual description of the access mask (for some object types),
making it easier to identify the exact access allowed for a particular handle.
Double-clicking a handle entry (or right-clicking and selecting Properties) shows some of the object’s
properties. Figure 1-12 shows a screenshot of an example event object properties.
Chapter 1: Windows Internals Overview
20
Figure 1-12: Object properties in Process Explorer
Notice that the dialog shown in figure 1-12 is for the object’s properties, rather than the handle’s. In other
words, looking at an object’s properties from any handle that points to the same object shows the same
information.
The properties in figure 1-12 include the object’s name (if any), its type, a short description, its address
in kernel memory, the number of open handles, and some specific object information, such as the state
and type of the event object shown. Note that the References shown do not indicate the actual number
Chapter 1: Windows Internals Overview
21
of outstanding references to the object (it does prior to Windows 8.1). A proper way to see the actual
reference count for the object is to use the kernel debugger’s !trueref command, as shown here:
lkd> !object 0xFFFFA08F948AC0B0
Object: ffffa08f948ac0b0
Type: (ffffa08f684df140) Event
ObjectHeader: ffffa08f948ac080 (new version)
HandleCount: 2
PointerCount: 65535
Directory Object: ffff90839b63a700
Name: ShellDesktopSwitchEvent
lkd> !trueref ffffa08f948ac0b0
ffffa08f948ac0b0: HandleCount: 2 PointerCount: 65535 RealPointerCount: 3
We’ll take a closer look at the attributes of objects and the kernel debugger in later chapters.
In the next chapter, we’ll start writing a very simple driver to show and use many of the tools we’ll need
later in this book.
Chapter 2: Getting Started with Kernel
Development
This chapter deals with the fundamentals needed to get up and running with kernel driver development.
During the course of this chapter, you’ll install the necessary tools and write a very basic driver that can
be loaded and unloaded.
In this chapter:
• Installing the Tools
• Creating a Driver Project
• The DriverEntry and Unload routines
• Deploying the Driver
• Simple Tracing
Installing the Tools
In the old days (pre-2012), the process of developing and building drivers included using a dedicated build
tool from the Device Driver Kit (DDK), without having an integrated development experience developers
were used to when developing user-mode applications. There were some workarounds, but none of them
was perfect nor officially supported by Microsoft.
Fortunately, starting with Visual Studio 2012 and Windows Driver Kit 8, Microsoft officially supports
building drivers with Visual Studio (with msbuild), without the need to use a separate compiler and build
tools.
To get started with driver development, the following tools must be installed (in this order) on your
development machine:
• Visual Studio 2019 with the latest updates. Make sure the C++ workload is selected during
installation. Note that any SKU will do, including the free Community edition.
• Windows 11 SDK (generally, the latest is recommended). Make sure at least the Debugging Tools for
Windows item is selected during installation.
• Windows 11 Driver Kit (WDK) - it supports building drivers for Windows 7 and later versions of
Windows. Make sure the wizard installs the project templates for Visual Studio at the end of the
installation.
Chapter 2: Getting Started with Kernel Development
23
• The Sysinternals tools, which are invaluable in any “internals” work, can be downloaded for free
from http://www.sysinternals.com. Click on Sysinternals Suite on the left of that web page and
download the Sysinternals Suite zip file. Unzip to any folder, and the tools are ready to go.
The SDK and WDK versions must match. Follow the guidelines in the WDK download page to
load the corresponding SDK with the WDK.
A quick way to make sure the WDK templates are installed correctly is to open Visual Studio
and select New Project and look for driver projects, such as “Empty WDM Driver”.
Creating a Driver Project
With the above installations in place, a new driver project can be created. The template you’ll use in this
section is “WDM Empty Driver”. Figure 2-1 shows what the New Project dialog looks like for this type
of driver in Visual Studio 2019. Figure 2-2 shows the same initial wizard with Visual Studio 2019 if the
Classic Project Dialog extension is installed and enabled. The project in both figures is named “Sample”.
Figure 2-1: New WDM Driver Project in Visual Studio 2019
Chapter 2: Getting Started with Kernel Development
24
Figure 2-2: New WDM Driver Project in Visual Studio 2019 with the Classic Project Dialog extension
Once the project is created, the Solution Explorer shows a single file within the Driver Files filter -
Sample.inf. You won’t need this file in this example, so simply delete it (right-click and select Remove
or press the Del key).
Now it’s time to add a source file. Right-click the Source Files node in Solution Explorer and select Add /
New Item… from the File menu. Select a C++ source file and name it Sample.cpp. Click OK to create it.
The DriverEntry and Unload Routines
Every driver has an entry point called DriverEntry by default. This can be considered the “main”
function of the driver, comparable to the classic main of a user-mode application. This function is called
by a system thread at IRQL PASSIVE_LEVEL (0). (IRQLs are discussed in detail in chapter 8.)
DriverEntry has a predefined prototype, shown here:
NTSTATUS
DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath\
);
The _In_ annotations are part of the Source (Code) Annotation Language (SAL). These annotations are
transparent to the compiler, but provide metadata useful for human readers and static analysis tools. I may
Chapter 2: Getting Started with Kernel Development
25
remove these annotations in code samples to make it easier to read, but you should use SAL annotations