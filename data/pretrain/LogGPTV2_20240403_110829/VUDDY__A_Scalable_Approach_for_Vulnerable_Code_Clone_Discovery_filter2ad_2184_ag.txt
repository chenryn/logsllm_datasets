ﬁxed granularity levels.
this does not necessarily imply that
3) Accuracy: Considering the former discussion from a
different standpoint, ﬁxed granularity can impair the accuracy
of an approach. In other words, an approach that attempts
to detect vulnerable code clones using granularity g cannot
detect clones with a length smaller than g, which causes
false negatives. As a remedy, we could generate ﬁngerprints
for every possible g value and search for the corresponding
ﬁngerprint from every dictionary whenever it fails to detect
functions smaller than the ﬁxed granularity, which causes a
tremendous amount of overhead. Moreover, it is obvious that
the false positive rate increases when we use ﬁner granularity,
as shown in subsection VII-C. The false positive rate is directly
related to the trustworthiness of a vulnerable clone detector.
Vulnerable clone detectors that report numerous false alarms
do not actually help developers identify the problems in their
code; instead, they lead to increased efforts to routinely check
meaningless alarms. In this respect, we believe that our design
of VUDDY achieves the right balance between accuracy and
scalability.
B. Room for speedup
Currently, a large portion of the overhead is concentrated
in the parsing step. When generating a ﬁngerprint of Android
ﬁrmware, VUDDY spent 973 seconds (95.1 %) out of 1023
seconds only for parsing. To resolve this performance bottle-
neck, we also implemented a faster version of VUDDY, called
VUDDY-fast, which utilizes regular expression to identify and
analyze functions. VUDDY-fast required only 1 hour and 17
minutes for generating ﬁngerprint dictionary of 1 BLoC input
in Table I, but it identiﬁed 9.7 % less functions. As one of the
future works, we plan to improve the performance of parser
by optimizing the grammar and leveraging parser generator
which is faster than ANTLR.
TABLE V: Memory use when preprocessing functions in the
vulnerability database with the given granularity. l refers to
the LoC of a function.
Property
Variable
Fixed
Granularity (LoC)
Memory use (MB)
l
4
10
40
100
48
651
496
172
49
C. Open service
In April 2016, we launched an open web service via web
with which anyone can use VUDDY to inspect their programs.
A number of open source developers, device manufacturers,
and commercial product developers tested more than 14 BLoC
for 11 months, and VUDDY detected 144,496 vulnerable
functions. For lack of space, the results and insights drawn
from the service is described in the Appendix.
XI. CONCLUSION AND FUTURE WORK
In this paper, we proposed VUDDY, which is an approach
for scalable and accurate vulnerable code clone discovery. The
design principles of VUDDY are directed towards extending
scalability through function-level granularity and a length
ﬁlter, while maintaining accuracy so that it can afford to detect
vulnerable clones from the rapidly expanding pool of open
source software. VUDDY adopts a vulnerability preserving
abstraction scheme which enables it to discover 24 % more
unknown variants of vulnerabilities. We implemented VUDDY
to demonstrate its efﬁcacy and effectiveness. The results
show that VUDDY can actually detect numerous vulnerable
clones from a large code base with unprecedented scalability
and accuracy. In the case study, we presented several cases
discovered by VUDDY, in which vulnerable functions remain
unﬁxed for years and propagate to other programs.
Tremendous number of vulnerable code fragments will
continue to be propagated to countless programs and devices.
We strongly believe that VUDDY is a must-have approach to
be used for securing various software when scalability and
accuracy is required.
Our work can be extended in multiple directions. Firstly, we
plan to continue improving the performance of VUDDY by
reﬁning the parser and expanding the vulnerability database.
It will boost
the speed of VUDDY and increase detec-
tion rate. Moreover, we will try to combine our approach
with other types of vulnerability-detecting techniques (e.g.,
fuzzers), which will allow a more sophisticated detection of
vulnerability.
ACKNOWLEDGMENT
We thank the anonymous reviewers for their insightful
comments to improve the quality of the paper. We are also
grateful to Donghyeok Kim for his contribution on the parser
generation, and Taebeom Kim for his help on the manual
inspection process. This work was supported by Institute for
Information & communications Technology Promotion (IITP)
grant funded by the Korea government (MSIP) (No.R0190-16-
2011, Development of Vulnerability Discovery Technologies
for IoT Software Security).
609
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:17 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] M. W. Godfrey and Q. Tu, “Evolution in open source software: A
case study,” in Software Maintenance, 2000. Proceedings. International
Conference on.
IEEE, 2000, pp. 131–142.
[2] G. Succi, J. Paulson, and A. Eberlein, “Preliminary results from an
empirical study on the growth of open source and commercial software
products,” in EDSER-3 Workshop. Citeseer, 2001, pp. 14–15.
[3] W. Scacchi, “Understanding open source software evolution,” Software
Evolution and Feedback: Theory and Practice, vol. 9, pp. 181–205,
2006.
[4] “SourceForge,” http://sourceforge.net, accessed: 2016-11-01.
[5] “GitHub,” http://github.com, accessed: 2016-11-01.
[6] M. Kim, L. Bergman, T. Lau, and D. Notkin, “An ethnographic study
of copy and paste programming practices in OOPL,” in Empirical
Software Engineering, 2004. ISESE’04. Proceedings. 2004 International
Symposium on.
IEEE, 2004, pp. 83–92.
[7] C. J. Kapser and M. W. Godfrey, ““Cloning considered harmful”
considered harmful: patterns of cloning in software,” Empirical Software
Engineering, vol. 13, no. 6, pp. 645–692, 2008.
[8] J. Mayrand, C. Leblanc, and E. M. Merlo, “Experiment on the automatic
detection of function clones in a software system using metrics,” in
Software Maintenance 1996, Proceedings., International Conference on.
IEEE, 1996, pp. 244–253.
[9] M. Kim, V. Sazawal, D. Notkin, and G. Murphy, “An empirical study
of code clone genealogies,” in ACM SIGSOFT Software Engineering
Notes, vol. 30, no. 5. ACM, 2005, pp. 187–196.
[10] T. Lavoie, M. Eilers-Smith, and E. Merlo, “Challenging cloning related
problems with gpu-based algorithms,” in Proceedings of the 4th Inter-
national Workshop on Software Clones. ACM, 2010, pp. 25–32.
[11] B. S. Baker, “On ﬁnding duplication and near-duplication in large
software systems,” in Reverse Engineering, 1995., Proceedings of 2nd
Working Conference on.
IEEE, 1995, pp. 86–95.
[12] N. H. Pham, T. T. Nguyen, H. A. Nguyen, and T. N. Nguyen, “Detection
of recurring software vulnerabilities,” in Proceedings of the IEEE/ACM
international conference on Automated software engineering. ACM,
2010, pp. 447–456.
[13] H. Li, H. Kwon, J. Kwon, and H. Lee, “CLORIFI: software vulnerability
discovery using code clone veriﬁcation,” Concurrency and Computation:
Practice and Experience, pp. 1900–1917, 2015.
[14] A. Nappa, R. Johnson, L. Bilge, J. Caballero, and T. Dumitras, “The
attack of the clones: a study of the impact of shared code on vulnerability
patching,” in 2015 IEEE Symposium on Security and Privacy.
IEEE,
2015, pp. 692–708.
[15] T. Kamiya, S. Kusumoto, and K. Inoue, “CCFinder: a multilinguistic
token-based code clone detection system for large scale source code,”
Software Engineering, IEEE Transactions on, vol. 28, no. 7, pp. 654–
670, 2002.
[16] I. D. Baxter, A. Yahin, L. Moura, M. S. Anna, and L. Bier, “Clone
detection using abstract syntax trees,” in Software Maintenance, 1998.
Proceedings., International Conference on.
IEEE, 1998, pp. 368–377.
[17] L. Jiang, G. Misherghi, Z. Su, and S. Glondu, “DECKARD: Scalable and
accurate tree-based detection of code clones,” in Proceedings of the 29th
international conference on Software Engineering.
IEEE Computer
Society, 2007, pp. 96–105.
[18] J. Jang, A. Agrawal, and D. Brumley, “ReDeBug: ﬁnding unpatched
code clones in entire os distributions,” in Security and Privacy (SP),
2012 IEEE Symposium on.
IEEE, 2012, pp. 48–62.
[19] H. Sajnani, V. Saini, J. Svajlenko, C. K. Roy, and C. V. Lopes,
“SourcererCC: scaling code clone detection to big-code,” in Proceedings
of the 38th International Conference on Software Engineering. ACM,
2016, pp. 1157–1168.
[20] S. Bellon, R. Koschke, G. Antoniol, J. Krinke, and E. Merlo, “Com-
parison and evaluation of clone detection tools,” IEEE Transactions on
Software Engineering, vol. 33, no. 9, pp. 577–591, 2007.
[21] R. Koschke, “Survey of research on software clones,” in Dagstuhl Sem-
Schloss Dagstuhl-Leibniz-Zentrum f¨ur Informatik,
inar Proceedings.
2007.
[22] C. K. Roy, J. R. Cordy, and R. Koschke, “Comparison and evaluation
of code clone detection techniques and tools: A qualitative approach,”
Science of Computer Programming, vol. 74, no. 7, pp. 470–495, 2009.
[23] D. Rattan, R. Bhatia, and M. Singh, “Software clone detection: A
systematic review,” Information and Software Technology, vol. 55, no. 7,
pp. 1165–1199, 2013.
[24] Z. Li, S. Lu, S. Myagmar, and Y. Zhou, “CP-Miner: Finding copy-paste
and related bugs in large-scale software code,” Software Engineering,
IEEE Transactions on, vol. 32, no. 3, pp. 176–192, 2006.
[25] X. Yan, J. Han, and R. Afshar, “CloSpan: Mining: Closed sequential pat-
terns in large datasets,” in Proceedings of the 2003 SIAM International
Conference on Data Mining. SIAM, 2003, pp. 166–177.
[26] F. Yamaguchi, F. Lindner, and K. Rieck, “Vulnerability extrapolation:
assisted discovery of vulnerabilities using machine learning,” in Pro-
the 5th USENIX conference on Offensive technologies.
ceedings of
USENIX Association, 2011, pp. 13–13.
[27] F. Yamaguchi, M. Lottmann, and K. Rieck, “Generalized vulnerability
extrapolation using abstract syntax trees,” in Proceedings of the 28th
Annual Computer Security Applications Conference. ACM, 2012, pp.
359–368.
[28] R. C. Read and D. G. Corneil, “The graph isomorphism disease,” Journal
of Graph Theory, vol. 1, no. 4, pp. 339–363, 1977.
[29] L. Jiang, Z. Su, and E. Chiu, “Context-based detection of clone-related
bugs,” in Proceedings of the the 6th joint meeting of the European
software engineering conference and the ACM SIGSOFT symposium on
The foundations of software engineering. ACM, 2007, pp. 55–64.
[30] Y. Sasaki, T. Yamamoto, Y. Hayase, and K. Inoue, “Finding ﬁle clones
in FreeBSD ports collection,” in Mining Software Repositories (MSR),
2010 7th IEEE Working Conference on.
IEEE, 2010, pp. 102–105.
[31] Z. Li, D. Zou, S. Xu, H. Jin, H. Qi, and J. Hu, “VulPecker: an automated
vulnerability detection system based on code similarity analysis,” in
Proceedings of
the 32nd Annual Conference on Computer Security
Applications. ACM, 2016, pp. 201–213.
[32] “The Expat XML Parser,” http://expat.sourceforge.net/, accessed: 2016-
11-01.
[33] M. Zhang, Y. Duan, H. Yin, and Z. Zhao, “Semantics-aware android mal-
ware classiﬁcation using weighted contextual api dependency graphs,”
in Proceedings of the 2014 ACM SIGSAC Conference on Computer and
Communications Security. ACM, 2014, pp. 1105–1116.
[34] “Common Vulnerability Enumeration,” http://cve.mitre.org, accessed:
2016-11-01.
[35] “ANTLR, ANother Tool for Language Recognition,” http://www.antlr.
org/, accessed: 2016-11-01.
[36] N. Synytskyy, J. R. Cordy, and T. R. Dean, “Robust multilingual parsing
using island grammars,” in Proceedings of the 2003 conference of the
Centre for Advanced Studies on Collaborative research.
IBM Press,
2003, pp. 266–278.
[37] S. Neuhaus, T. Zimmermann, C. Holler, and A. Zeller, “Predicting
vulnerable software components,” in Proceedings of
the 14th ACM
conference on Computer and communications security. ACM, 2007,
pp. 529–540.
[38] A. Van Deursen and T. Kuipers, “Building documentation generators,”
in Software Maintenance, 1999.(ICSM’99) Proceedings. IEEE Interna-
tional Conference on.
IEEE, 1999, pp. 40–49.
[39] L. Moonen, “Generating robust parsers using island grammars,” in
Reverse Engineering, 2001. Proceedings. Eighth Working Conference
on.
IEEE, 2001, pp. 13–22.
[40] G. Pike and J. Alakuijala, “Introducing cityhash,” 2011.
[41] A. Appleby, “Murmurhash 2.0,” 2008.
[42] B. Jenkins, “SpookyHash: a 128-bit non-cryptographic hash (2010),”
2014.
[43] X. Wang and H. Yu, “How to break MD5 and other hash functions,”
in Annual International Conference on the Theory and Applications of
Cryptographic Techniques. Springer, 2005, pp. 19–35.
[44] T. Wang, M. Harman, Y. Jia, and J. Krinke, “Searching for better
conﬁgurations: a rigorous approach to clone evaluation,” in Proceedings
of the 2013 9th Joint Meeting on Foundations of Software Engineering.
ACM, 2013, pp. 455–465.
[45] J. Svajlenko and C. K. Roy, “Evaluating modern clone detection tools,”
in Software Maintenance and Evolution (ICSME), 2014 IEEE Interna-
tional Conference on.
IEEE, 2014, pp. 321–330.
610
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:17 UTC from IEEE Xplore.  Restrictions apply. 
APPENDIX
VUDDY AS AN OPEN SERVICE
VUDDY has been serviced online (at IoTcube, https://iotcube.net) since April 2016, facilitating scalable and accurate
inspection of software. Users of our service include commercial software developers, open source committers, and IoT device
manufacturers. Here, we present the working example of VUDDY given the ﬁrmware of an Android smartphone. When the
ﬁngerprint is uploaded to our service platform, the platform shows the number of detected vulnerable clones, the origins
of clones, yearly distribution of CVEs assigned to vulnerabilities, CVSS (Common Vulnerability Scoring System) score
distribution, CWE (Common Weakness Enumeration) distribution, and a tree view with which users are able to locate the
ﬁles affected by vulnerable clones. Graphs in the appendix are downloaded as vector images from IoTcube, and the other
ﬁgures are screen-captured.
Fig. 10: The main page of IoTcube. The implementation of VUDDY is under the White-box Testing menu.
Fig. 11: Statistical knowledge obtained by web service for 11 months. Tables show the most frequently detected CVEs and
CWEs, respectively. This information is also open to the users.
611
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:17 UTC from IEEE Xplore.  Restrictions apply. 
The origin of vulnerabiliঞes
codeaurora
6363
number of vulnerability
linux
chromium
11
11
special
22
ubuntu
129129
0
20
40
60
80
100
120
140
Fig. 12: The origin of vulnerabilities. 129 vulnerable functions detected in the smartphone are already reported and patched
in the repository of Ubuntu-Trusty.
100
80
60
40
20
0
Yearly distribuঞon of CVEs
CVE
9090
8080
00
00
11
11
00
11
55
99
99
2006
2007
2008
2009
2010
2011
2012
2013
2014
2015
2016
Fig. 13: Yearly distribution of CVEs. As the tested smartphone uses the Linux kernel version 3.18.14, which was released in
May 2015, many of the vulnerabilities exposed in 2015 and 2016 are not patched yet.
612
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:17 UTC from IEEE Xplore.  Restrictions apply. 
CVSS
HHigh: 18.4 %
High: 18.4 %
Low: 51.5 %
Low: 51.5 %
Medium: 30.1 %
Medium: 30.1 %
Fig. 14: The distribution of CVSS. Over 18 % of the detected CVEs are assigned with high severity score.
CWE
CWE-200: 5.6 %
CWE-200: 5.6 %
CWE-020: 2.0 %
CWE-020: 2.0 %
CWE-017: 0.5 %
CWE-017: 0.5 %
CWE-362: 5.6 %
CWE-362: 5.6 %
CWE-264: 16.8 %
CWE-264: 16.8 %
CVE-264: 1.0 %
CVE-264: 1.0 %
CWE-189: 2.0 %
CWE-189: 2.0 %
CWE-399: 6.6 %
CWE-399: 6.6 %
CWE-254: 1.5 %
CWE-254: 1.5 %
CWE-119: 8.2 %
CWE-119: 8.2 %
Fig. 15: The distribution of CWE. Permission-related vulnerabilities (CWE-264) are dominant in the Android smartphone.
CWE-000: 50.0 %
CWE-000: 50.0 %
613
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:17 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 16: A snippet of tree view. Internal nodes denote directories, and leaf nodes denote ﬁles. In this tree, dir.c ﬁle located
under
/fs/nilfs2/ has two vulnerable functions. Clicking the leaf nodes, users can also browse the vulnerable functions and
corresponding patches.
614
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:17 UTC from IEEE Xplore.  Restrictions apply.