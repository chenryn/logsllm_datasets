Porosity: A Decompiler For Blockchain-Based
Smart Contracts Bytecode
Matt Suiche
Comae Technologies
PI:EMAIL
July 7, 2017
Abstract
Ethereum is gaining a signiﬁcant popularity in the blockchain com-
munity, mainly due to fact that it is design in a way that enables devel-
opers to write decentralized applications (Dapps) and smart-contract
using blockchain technology. This new paradigm of applications opens
the door to many possibilities and opportunities. Blockchain is often
referred as secure by design, but now that blockchains can embed ap-
plications this raise multiple questions regarding architecture, design,
attack vectors and patch deployments. In this paper I will discuss the
architecture of the core component of Ethereum (Ethereum Virtual
Machine), its vulnerabilities as well as my open-source tool “Poros-
ity”. A decompiler for EVM bytecode that generates readable Solid-
ity syntax contracts. Enabling static and dynamic analysis of such
compiled contracts.
Contents
1
Ethereum Virtual Machines (EVM)
4
2
Memory Management
4
2.1
Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
2.2
Storage (Persistent) . . . . . . . . . . . . . . . . . . . . . . . .
4
2.3
Memory (Volatile)
. . . . . . . . . . . . . . . . . . . . . . . .
5
3
Addresses
6
4
Call Types
6
4.1
EVM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
4.1.1
Basic Blocks . . . . . . . . . . . . . . . . . . . . . . . .
6
4.1.2
EVM functions . . . . . . . . . . . . . . . . . . . . . .
7
4.1.3
EVM Call . . . . . . . . . . . . . . . . . . . . . . . . .
8
4.2
User-deﬁned functions (Solidity) . . . . . . . . . . . . . . . . .
9
5
Type Discovery
10
5.1
Address
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
5.1.1
Non-optimized Address Mask
. . . . . . . . . . . . . .
10
5.1.2
Optimized Address Mask . . . . . . . . . . . . . . . . .
10
5.1.3
Parameter Address Mask . . . . . . . . . . . . . . . . .
12
6
Smart-Contract
12
6.1
Pre-Loader . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
6.2
Runtime Dispatcher . . . . . . . . . . . . . . . . . . . . . . . .
13
6.2.1
Function Hashes
. . . . . . . . . . . . . . . . . . . . .
14
6.2.2
Dispatcher . . . . . . . . . . . . . . . . . . . . . . . . .
15
7
Code Analysis
20
7.1
Vulnerable Contract
. . . . . . . . . . . . . . . . . . . . . . .
20
7.1.1
Solidity source code . . . . . . . . . . . . . . . . . . . .
21
7.1.2
Runtime Bytecode
. . . . . . . . . . . . . . . . . . . .
22
7.1.3
ABI Deﬁnition
. . . . . . . . . . . . . . . . . . . . . .
23
7.1.4
Decompiled version . . . . . . . . . . . . . . . . . . . .
24
1
8
Bugs
24
8.1
Reentrant Vulnerability / Race Condition
. . . . . . . . . . .
24
8.2
Call Stack Vulnerability
. . . . . . . . . . . . . . . . . . . . .
25
8.3
Time Dependance Vulnerability . . . . . . . . . . . . . . . . .
25
9
Future
25
10 Acknowledgments
26
2
List of Figures
1
Static CFG
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
2
Enulated CFG . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
3
List of Listings
1
Storage (Persistent) Exmaple
. . . . . . . . . . . . . . . . . .
5
2
EVM Parameter/Return Stack Location Example . . . . . . .
7
3
call Proto-type Declaration . . . . . . . . . . . . . . . . . . . .
8
4
Pre-compiled Contracts . . . . . . . . . . . . . . . . . . . . . .
9
5
CALLDATALOAD Example . . . . . . . . . . . . . . . . . . .
9
6
CALLDATALOAD EVM Pseudo-code
. . . . . . . . . . . . .
10
7
Non-optimized Assembly Code Example
. . . . . . . . . . . .
10
8
Optimized Assembly Code Example . . . . . . . . . . . . . . .
11
9
msg.sender EVM Bytecode Example
. . . . . . . . . . . . . .
11
10
Parameter Address Mask Example
. . . . . . . . . . . . . . .
12
11
Porosity Pre-loader Disassembly Output
. . . . . . . . . . . .
13
12
ABI Deﬁnition
. . . . . . . . . . . . . . . . . . . . . . . . . .
14
13
double Function Declaration . . . . . . . . . . . . . . . . . . .
14
14
double/triple Function Hashes . . . . . . . . . . . . . . . . . .
15
15
EVM Runtime Bytecode Example . . . . . . . . . . . . . . . .
15
16
Runtime Bytecode Porosity Disassembly . . . . . . . . . . . .
17
17
dispdisasm . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
18
EVM Emulator . . . . . . . . . . . . . . . . . . . . . . . . . .
18
19
Static/Dynamic Graph Pseudo-C Code . . . . . . . . . . . . .
19
20
Decompiled Pseudo-C code . . . . . . . . . . . . . . . . . . . .
20
21
Vulnerable Smart Contract . . . . . . . . . . . . . . . . . . . .
21
22
Vulnerable Smart Contract Runtime Bytecode . . . . . . . . .
22
23
Vulnerable Smart Contract ABI Deﬁnition . . . . . . . . . . .
23
24
Vulnerable Smart Contract Decompilation . . . . . . . . . . .
24
4
1
Ethereum Virtual Machines (EVM)
The Ethereum Virtual Machine (EVM) is the runtime environment for smart
contracts in Ethereum. The EVM runs smart-contracts that are built up
from bytecodes. Bytecodes are identiﬁed by a 160-bit address, and stored in
the blockchain, which is also known as “accounts”. The EVM operates on
256-bit pseudo registers. Which means that the EVM does not operate via
registers. But, through an expandable stack which is used to pass parameters
not only to functions/instructions, but also for memory and other algorithmic
operations.
The following excerpt is taken from the Solidity documentation, and it is
also worth mentioning:
There are two kinds of accounts in Ethereum which share
the same address space: External accounts that are controlled
by public-private key pairs (i.e. humans) and contract accounts
which are controlled by the code stored together with the account.
The address of an external account is determined from the
public key while the address of a contract is determined at the
time the contract is created (it is derived from the creator address
and the number of transactions sent from that address, the so-
called “nonce”).
Regardless of whether or not the account stores code, the two
types are treated equally by the EVM.
2
Memory Management
2.1
Stack
It does not have the concept of registers. A virtual stack is being used instead
for operations such as parameters for the opcodes. The EVM uses 256-bit
values from that virtual stack. It has a maximum size of 1024 elements.
2.2
Storage (Persistent)
The Storage is a persistent key-value storage mapping (256-to-256-bit inte-
gers). And is documented as below:
5
Every account has a persistent key-value store mapping 256-
bit words to 256-bit words called storage. Furthermore, every
account has a balance which can be modiﬁed by sending transac-
tions.
Each account has a persistent memory area which is called
storage. Storage is a key-value store that maps 256-bit words to
256-bit words. It is not possible to enumerate storage from within
a contract and it is comparatively costly to read and even more
so, to modify storage. A contract can neither read nor write to
any storage apart from its own.
The storage memory is the memory declared outside of the user-deﬁned
functions and within the Contract context. For instance, in listing 1, the
userBalances and withdrawn will be in the memory storage. This can also
be identiﬁed by the SSTORE / SLOAD instructions.
1
contract SendBalance {
2
mapping ( address => uint ) userBalances;
3
bool withdrawn = false;
4
(...)
5
}
Listing 1: Storage (Persistent) Exmaple
2.3
Memory (Volatile)
This memory is mainly used when calling functions or for regular memory op-
erations. The oﬃcial documentation explicitly indicates that the EVM does
not have traditional registers. Which means that the virtual stack previously
discussed will be used primarily to push arguments to the instructions. The
following is the excerpt explaining such behavior:
The second memory area is called memory, of which a contract
obtains a freshly cleared instance for each message call. Memory
is linear and can be addressed at byte level, but reads are limited
to a width of 256 bits, while writes can be either 8 bits or 256 bits
wide. Memory is expanded by a word (256-bit), when accessing
6
(either reading or writing) a previously untouched memory word
(ie. any o↵set within a word). At the time of expansion, the cost
in gas must be paid. Memory is more costly the larger it grows
(it scales quadratically).
Traditionally the MSTORE instruction is what we would generally consider
to be the instruction responsible for adding data to the stack in any typ-
ical x86/x64 system.
Therefore, the instructions
MSTORE / MLOAD could be
identiﬁed as such with respect to the x86/x64 system. Consequently, both
mstore(where, what) and mload(where) are frequently used.
3
Addresses
EVM uses 160-bit addresses.
It is extremely crucial to understand that
fact when one has to deal with type discovery. As we often see the mask
0xffffffffffffffffffffffffffffffffffffffff being applied for optimiza-
tion purposes either on code or on the EVM registers.
4
Call Types
There are two types of functions to di↵erentiate when working with the EVM.
The ﬁrst type is the EVM functions (or EVM instructions), while the second
type is the user-deﬁned function when creating the smart-contract.
4.1
EVM
4.1.1
Basic Blocks
Basic Blocks usually starts with the instruction JUMPDEST , with the exception
of very few exception cases. Most of the conditional and unconditional jumps
have a PUSH instruction preceding them in order to push the destination o↵set
into the stack. Although, in some cases we would also notice that the PUSH
instruction containing the o↵set can be executed way before the actual JUMP
instruction, and retrieved using stack manipulation instructions such as DUP ,
SWAP or POP . Those cases require dynamic execution of the code to record
the stack for each JUMP instruction, as we are going to discuss this later on
in sub-section 6.2.2.
7
4.1.2
EVM functions
EVM functions and/or instructions includes, but are not limited to, some of
the the following:
Arithmetic Operations.
Comparison & Bitwise Logic Operations.
SHA3.
Environmental Information.
Block Information.
Stack, Memory, Storage and Flow Operations.
Push/Duplication/Pop/Exchange Operations.
Logging Operations.
System Operations.
Since the EVM does not have registers, therefore all instructions invoca-
tion are done through the EVM stack. For example, an instruction taking
two parameters such as an addition or a subtraction, would use the stack
entries index 0 and 1. And the return value would be stored in the stack
entry index 0. In listing 2, we can see more clearly how it looks like under
the hood.
1
PUSH1 0x1 ==> {stack[0x0] = 0x1}
2
PUSH2 0x2 ==> {stack[0x0] = 0x2, stack[0x1] = 0x1}
3
ADD
==> {stack[0x0] = 0x3}
Listing 2: EVM Parameter/Return Stack Location Example
The above EVM assembly snippet would translate to the EVM pseudo-
code add(0x2, 0x1) and returns 0x3 in the stack entry 0. The EVM stack
model follows the standard last-in, ﬁrst-out (LIFO ) algorithm.
8
4.1.3
EVM Call
There are two possible types of external EVM function calls. They can be
identiﬁed with the CALL instruction. However, this is not necessarily always
a concrete identiﬁer to the call being external.
Some mathematical and cryptographic functions have to be called through
external contracts such as sha256 or ripemd160 using the call function. De-
spite the fact of having an explicitly deﬁned instruction for the sha3 function.
Which is due to the frequent usage, especially with mapping arrays such as
mapping(address => uint256) balances . Where the sha3 function is used to
compute the index.
The function call is where the dispatching magic happens. Listing 3
shows the proper proto-type declaration for such function.
1
call(
2
gasLimit,
3
to,
4
value,
5
inputOffset,
6
inputSize,
7
outputOffset,
8
outputSize
9
)
Listing 3: call Proto-type Declaration
There are four ‘pre-compiled’ contracts that are present as extensions of
the current design. The four contracts in addresses 1, 2, 3 and 4 executes the
elliptic curve public key recovery function, the SHA2 256-bit hash scheme,
the RIPEMD 160-bit hash scheme and the identity function respectively.
Listing 4 shows such contracts, obtained from the EVM source code.
9
1
precompiled.insert(
2
make_pair(Address(1), PrecompiledContract(3000, 0,
3
PrecompiledRegistrar::executor("ecrecover"))));
4
5
precompiled.insert(
6
make_pair(
7
Address(2),
8
PrecompiledContract(
9
60,
10
12,
11
PrecompiledRegistrar::executor("sha256"))));
12
13
precompiled.insert(
14
make_pair(Address(3), PrecompiledContract(600, 120,
15
PrecompiledRegistrar::executor("ripemd160"))));
16
17
precompiled.insert(
18
make_pair(Address(4), PrecompiledContract(15, 3,
19
PrecompiledRegistrar::executor("identity"))));
Listing 4: Pre-compiled Contracts
4.2
User-deﬁned functions (Solidity)
In order to call user-deﬁned functions, another level of abstraction is managed
by the instruction CALLDATALOAD . The ﬁrst parameter for that instruction is
the o↵set in the current environment block.
The ﬁrst 4-bytes indicates the 32-bit hash of the called function. Then
the input parameters follows next. Listing 5, shows an example of such case.
1
function foo(int a, int b) {
2
return a + b;
3
}
Listing 5: CALLDATALOAD Example
In the previous example, the outcome of such code snippet would be
a = calldataload(0x4) and
b = calldataload(0x24) .
Its imperative to re-
member that by default “registers” are 256-bits. Since the ﬁrst 4 bytes are
10
pre-allocated for the function’s hash value, therefore the ﬁrst parameter will
be at the o↵set 0x4, followed by the second parameter at o↵set 0x24. This is
derived mathematically by simply calculating the number of bytes added to
the previous number of bytes taken by the ﬁrst parameter. So in short words,
4 + (256/8) = 0x24 . We can then conclude the EVM pseudo-code shown in
listing 6.
1
return(add(calldataload(0x4), calldataload(0x24))
Listing 6: CALLDATALOAD EVM Pseudo-code
5
Type Discovery
5.1
Address
Addresses can be identiﬁed by their sources such as speciﬁc instruction such
as caller but in most of cases we can proceed to better results by identifying
mask applied to those values.
5.1.1
Non-optimized Address Mask
In listing 7, the 0x16 bytes EVM assembly code would translate to reg256
and 0xffffffffffffffffffffffffffffffffffffffff.
1
00000188 73ffffffff
+
PUSH20 ffffffffffffffffffffffffffffffffffffffff
2
0000019d 16
AND
Listing 7: Non-optimized Assembly Code Example
5.1.2
Optimized Address Mask
Listing 8 shows the optimized 0x9 bytes EVM assembly code, which also
yields the same operation as shown previously in listing 7.
11