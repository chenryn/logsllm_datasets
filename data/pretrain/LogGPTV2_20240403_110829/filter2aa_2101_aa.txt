Practical Tips for Playing Hide and Seek with Linux EDRs
DEFCON 27
@Op_Nomad
Zombie Ant Farm
!
!
!
!
$ who –m
Dimitry Snezhkov 
• Technologist
• Member of the X-Force Red Team 
ü
hacking
ü
tools, research
ü
all things offensive
@Op_Nomad
github.com/dsnezhkov
Linux Offense: The Context
Linux matters
• It runs 90% of cloud workloads.
• Attacks bypass office networks and land directly in the backend. 
• Attacks follows maximum ROI (access to data or computing resources).
• Linux Adversarial efforts may be focused and targeted.  
• Defense follows the attacker. 
Endpoint Detection and Response (EDR) solutions appear in Linux.
•
Operators have to respond
Linux EDRs - A Case of a Mistaken Identity
• Pure play EDR products
• Heuristic engine in Antivirus
• Security Automation toolkits
• Deployment / Patch Management
• Side gig for app whitelisting solutions
• As features of DLP products
• Home grown monitoring frameworks
• Tool assisted Threat Hunting.
“Who in the world am I? Ah, that's the great puzzle.”
No, you are 
not… 
Have a good 
day.
Blue
I am in your 
Linux 
box…
Operator has to address:
• Initial foothold mechanism viability. Immediate detection.
• Logging of activities, delayed interception and analysis.
• Behavioral runtime patterns that trigger heuristics.
• Persistent readiness for the long haul.
• Evade Automation
• Deflect tool assisted threat hunting
• Proactive Supervision Context
• Quiet boxes. Reliance on behavioral anomaly.
• Locked down boxes. Reliance on known policy enforcement.
• Peripheral sensors, honeypots.
Linux Offense: Strategic Sketches
Operational evasion:
•
Operationally shut down EDRs.
•
Directly exploit EDRs. 
•
Blind EDR reporting and response.
•
Operationally confuse EDRs
Targeted behavior evasion:
•
Target execution confusion.
•
Bypass EDR detection with novel ways of target exploitation
•
Deflect artifact discovery by Manual or Tool Assisted Threat hunting.
Strategic Goals and Objectives, Distilled
•
Choice: Drop ready offensive tools on the target
Ø May be outright detected. The unknown unknown.
•
Choice: Develop offensive tools on the target.
Ø May not have tooling, footprint of presence, noise increases.
•
Choice: Utilization principle, aka “Living off the land”
Ø May not be possible in the proactive supervision context.
Strategic Goals and Objectives, Distilled
• Need a viable path to building Linux malware in the face of EDRs:
• Evade detection at target runtime.
• Hide and serve payloads in an unpredictable ways to counter “the story”.
Strategic Goals and Objectives, Distilled
Assembled Attack: A blended approach to break the consistent story.
Idea A: Bring in clean instrumented malware cradles.
Build iterative capabilities.
Idea B: Turn good binaries into instrumented malware cradles. 
Use them as decoys.
Tactical Goals and Objectives, Sketches
Stage I: Build out Offensive Primitives
•
Indiscriminate “preload and release” of legitimate binaries at runtime.
•
Preload library chaining, 
"split/scatter/assemble” of payload features.
•
Delayed payload triggers and features at runtime.
•
Rapid payload delivery mechanism prototypes with instrumented cradles.
Tactical Goals and Objectives, Sketches
Stage II: Weaponize and Operationalize Offensive Capabilities
•
Payload brokers, “Preload-as-a-service”. Inter-process and remote 
payload loading and hosting
•
Process mimicry and decoys
•
Library preloading in novel ways over memory.
Stage I: Offensive Primitives
• Basics of Offensive Dynamic Linking an Loading
• Prototyping Offensive Mechanisms
• Discussing Offensive Tradeoffs
Linker wires up dynamic locations 
of needed libraries specified in the image.
Dynamic Link Loading: The Basics
ELF
$ ./executable
Error loading libctx.so
The Basics of Dynamic Link Loading
$ LD_DEBUG=libs LD_LIBRARY_PATH=./lib executable
107824: find library=libctx.so.1 [0]; searching
107824: 
Found file=./lib/libctx.so.1
“Hello World!”
$ ldd executable
libctx.so.1 => not found
$ readelf -d executable
0x0000000000000001 (NEEDED) 
Shared library: [libctx.so.1]
Execution Error: Dynamic dependency not found…
Where is the dependency?
Dependency is resolved!
Dynamic ELF Hooking: The Basics
Hook
Redefine and reroute KNOWN function entry points
Generic Dynamic API Hooking Tradeoffs
We  are are implementing an API detour to execute foreign logic. 
Challenges:
• Need to know the details of target API
FILE *fopen(const char *pathname, const char *mode);
• Invoke and avoid detection. Opsec. Known signatures for known exploits.
• Interoperate with the target binary in a clean fashion without crashing it.
• Assumption inspection tooling availability on target. 
New ideas: Viability Check
Tip: Be more agnostic to the specifics of any single API in the binary. 
Tip: Do not subvert the target. Instead:
• Compel it to execute malicious code
• Use it as a decoy.
• If you can start a process you 
likely own the entire bootstrap of this process
• Preload the payload generically into a known target and 
release for execution?
• Expand malware features by bringing other modules out of band. 
• EDR sees the initial clean cradle, malware module loading is delayed.
• EDR sees the code executing by approved system binaries in the process table, 
trusts the integrity of the known process.
• EDR may not fully trace inter-process data handoff 
• preloaded malware calls on external data interchange 
• memory resident executables and shared libraries
Parent / Child process relationships in Linux are transitive. We take advantage of this.
• If you can start the parent process, you fully own its execution resources, 
and the resources of its progeny
Offensive Strategy: Desired Outcomes
Primitives for Working with Offensive Preloading
What we Want
0x0 - ELF ABI Level : .INIT/.FINI/.PREINIT
.INIT
MAIN
.FINI
__attribute__((section(".init_array"), used)) 
static typeof(init) *init_p = init;
__attribute__((section(".fini_array"), used)) 
static typeof(fini) *fini_p = fini;
__attribute__((section(".preinit_array"), used)) 
... main()...
,.. 
0x1 – C runtime level : __libc_start_main
main_orig = main;
typeof(&__libc_start_main) orig = 
dlsym(RTLD_NEXT, "__libc_start_main");
return orig(main_hook, argc, argv, init, fini, 
rtld_fini, stack_end);
Is it optimal?
0x2 – Linker Level: Weakrefs
ü Controlled Weak Refs
ü Foreign Weak Refs
ü Chained Weak Refs
void debug() __attribute__((weak)); 
void debug(){
if (mstat)
mstat(); 
}
$ nm --dynamic
/bin/ls | grep 'w '
w __cxa_finalize
w __gmon_start__
void mstat(){
;
}
Chain1.so
Chain2.so
void main(){
if (debug)
debug(); 
}
LD_PRELOAD=chain1.so:chain2.so
,)),,),),") 
• ,,),
• .),)(,),
• ),),)),
• ,),) 
0x3 - .CTOR/.DTOR __attribute__((constructor (P)))
void before_main(void) __attribute__((constructor ));
void after_main(void)  __attribute__((destructor  ));
void before_main(void) __attribute__((constructor (101)));
void after_main(void)
__attribute__((destructor(65534)));
0x5 - Signals, Exceptions, Fault branching
Let’s keep breaking the EDR "story" of execution that leads to a confirmed IoC
ü Out of Band 
signals.
ü Fault Branching
ü Self-triggered fault 
recovery
ü Exception 
Handlers
ü Timed execution
void fpe_handler(int signal, siginfo_t *w, 
void *a)
{
printf("In SIGFPE handler\n");
siglongjmp(fpe_env, w->si_code);
}
$LD_PRELOAD=lib/libinterrupt.so bin/ls
Trigger SIGFPE handler
In SIGFPE handler
1 / 0: caught division by zero!
Executing payloads here ...
• Rootkit style LD_PRELOAD cleanup (proc)
• Obfuscation (compile time)
• Runtime Encryption (memory)
• Runtime situational checks
• Better context mimicry
• Access to EDRs to prove the exact primitives
• No “main” no pain? 
• Alternative loaders
0x6 - Back to Basics: Protecting Payloads
int _(void);
void __data_frame_e()
{
int x = _(); 
exit(x);
}
int _() {}
// Dynamic assignment to .interp section:
const char my_interp[] __attribute__((section(".interp"))) = 
"/usr/local/bin/gelfload-ld-x86_64";
Expanding and Scaling the Evasion Capabilities
We now have some evasion primitives to work with. Nice.
Let’s expand the evasion.
Highlights:
• Target utilization.
• Hiding from EDRs via existing trusted binary decoys.
• Dynamic scripting capabilities in the field.
• Progressive LD_PRELOAD command line evasion.
• Malware preloaders with self-preservation instincts.
Utilization: Out of the Box Decoys
HOW MANY TIMES CAN YOUR PROCESS REGEX FAIL
• System binaries that run other binaries.
• Great decoys already exist on many Linux systems. 
•
ld.so is a loader that can run executables directly as parameters. 
ld.so is always approved (known good)
•
busybox meta binary is handy.
Combine the two to escape process pattern matching defensive engines?
Bounce off something trusted and available  to break the path  of analysis
 3,.3.,,
$ LD_PRELOAD=payload.so
/lib64/ld-linux-x86-64.so.2 /bin/busybox
run-parts
--regex '^main_.*$' ./bin/