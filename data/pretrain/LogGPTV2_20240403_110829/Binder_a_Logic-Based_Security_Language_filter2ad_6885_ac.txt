cult  [10],  and  Binder  does  not  attempt  to  do  so.  Instead, 
much  the  same  effect  is  achieved  using  explicit  rules  in 
the  Binder  language,  as  in  the  “trust”  statements  in  Pro-
grams 1 and 2.  
Delegation is represented clumsily in SPKI. If the lo-
cal Department of Motor Vehicles (DMV) is to be author-
ized to license drivers, then the DMV must itself be a li-
censed  driver.  Binder’s  explicit  handling  of  delegation 
avoids such problems. 
Although  SDSI/SPKI  let  us  talk  about  k-out-of-n 
principals from a group, it does not let us talk about prin-
cipals  from different  groups.  There  is no  easy  way,  as  in 
the following Binder rule 
    can(read, P, resource_r) :- 
      vouched-for(P, D), 
      vouched-for(P, R), 
      senator(D, democrat), 
      senator(R, republican). 
to  talk  about  access  being  vouched  for  by  any  one  De-
mocrat and any one Republican from the U.S. Senate. 
7.3 PolicyMaker and KeyNote 
Statements  in  PolicyMaker  [4]  and  KeyNote  [5]  ex-
press  conditions  for  granting  access. This  can  be  thought 
of  as  defining  some  abstract can  predicate.  PolicyMaker 
and KeyNote programs can state various conditions on the 
can  predicate  but  cannot  define  additional  lemma  predi-
cates, so they violate properties 2 and 3. For example, the 
boss example in Section 2 is difficult for PolicyMaker or 
KeyNote to encode. Binder lets us express the boss rela-
tion  separately  from  can,  while  PolicyMaker  and  Key-
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE 
Note require us to collapse their definitions into its single 
can predicate. 
PolicyMaker  and  KeyNote  each  construct  a  proof 
chain  for  a  request,  starting  from  the  local  policy,  where 
each link of the chain can assert a filter (condition) on the 
request’s  parameters.  One  limitation  of  PolicyMaker  and 
KeyNote is that this chain must be linear, while a Binder 
proof  can  be  a  directed  acyclic  graph  (DAG).  Policy-
Maker  and  KeyNote  also  limit  themselves  to  rules  that 
state conditions on the request itself, and they cannot state 
conditions on other relations which may be lemmas to the 
request. Binder, in contrast, allows lemma predicates to be 
stated and composed. 
Because  PolicyMaker  allows  any  programming  lan-
guage to be used to state policies, it fails property 5. Addi-
tionally, we  cannot easily reason about PolicyMaker pro-
grams 
7.4 SD3 and other logic-based security languages 
Like  Binder,  SD3  is  a  security  language  based  on 
datalog [13]. SD3 does not allow the transmission of rules 
in certificates, however; SD3 certificates can contain only 
facts. SD3 thus violates property 3. 
D1LP [14] is also based on predicate calculus. It has 
a  built-in  treatment  of  “speaks-for”  for  delegation,  but 
allows  for  the  definition  of  other  predicates  that  can  be 
used  in  lemmas.  D1LP  does  not  allow  the  explicit  con-
struction  of  rules  defining  variants  of  delegation  or  for 
passing  these  rules  in  certificates;  it  therefore  violates 
properties 2 and 3. 
Appel  and  Felten  have  defined  a  security  language 
based on a higher-order logic. Their system is more pow-
erful  than  Binder  but  it  has  no  decision  procedure,  and 
thus it violates property 4. Although undecidability is not 
a  problem  for  a  service  if  proofs  come  from  the  clients, 
where a given request might be more constrained and per-
haps  more  decidable,  we  believe  it  would  be  impractical 
to require each request site to contain a significant amount 
of hand-crafted custom code to generate proofs. 
7.5 DRM languages 
Digital  Rights  Management  languages  (DRM  lan-
guages) model consumers’ access rights for digital media; 
XrML and ODRL are two examples [7, 11]. A DRM rule 
might  give  permission  to  play  a  movie  two  times,  after 
paying  $5.  DRM  rules  can  therefore  talk  about  action 
(paying $5) as well as state (the number of plays remain-
ing),  while  Binder  cannot.  Actions  and  state  are  difficult 
to discuss in a logic-based language, but we are currently 
investigating  ways  to  extend  Binder  to  handle  these  fea-
tures of DRM languages. 
Note that if multiple proofs are possible for an access 
request,  but  with  different  side-effects—for  example,  if 
different proofs draw on different accounts—then only the 
client may be in a situation to know which proof is prefer-
able. 
8. Experience with Binder 
Most  experience  with  Binder  to  date  has  involved 
writing  small  Binder  programs,  either  to  compare  Binder 
with  other  security  languages  or  using  Binder  as  a  lan-
guage for expressing and comparing sample security poli-
cies.  In  particular,  Binder  has  been  used  as  a  target  for 
translating proposed security languages, in order to under-
stand  what  statements  Binder  can  express  but  these  lan-
guages  cannot,  or  vice  versa. This  work has included  the 
prototyping of automated translators from these proposed 
languages  to  Binder,  as  well  as  the  hand-translation  of 
many examples. 
Some  features  originally  considered  for  Binder  have 
been left out because they were not needed in our experi-
ence  to  date. This has resulted  in a relatively  simple  lan-
guage that  is nevertheless  as  expressive  as needed  in  our 
experience.  Further  experience  is  needed  with  the  con-
struction  of  large  Binder  programs to  understand,  for  ex-
ample,  whether  Binder’s  current  limited  mechanisms  for 
the composition of rules are adequate or whether extend-
ing  them  could  make  large  Binder  programs  easier  to 
write or to understand. 
Because  Binder  is  close  in  form  to  Prolog,  Binder 
programs  can  be  translated  into  Prolog;  we  can  simulate 
Binder’s  extra  proof  rules  in  a  straightforward  way. 
Binder programs have thereby  been executed in an exist-
ing Prolog environment. 
9. Future work 
Is  Binder  strong  enough?  Binder may  be  too  weak  a 
language  to  model  some  real  authorization  problems;  it 
might  not  be  expressive  enough  to  write  certain  security 
programs, or to write them well. For example, the wordi-
ness  caused  by  expressing  all  trust  relations  explicitly 
might  complicate  writing  large  security  programs  in 
Binder.  Alternatively,  Binder’s  current  inability  to  talk 
about actions and state might become a problem. Further 
experience  with  writing  large  Binder  programs  will  help 
us  understand  such  possible  problems.  Strengthening 
Binder might involve strengthening the Binder logic, pre-
sumably  by  adding  additional  modal  proof  rules,  such  as 
direct support for predicates like “speaks-for.” 
It is  also  possible  that  Binder  is  already  too  strong  a 
language.  Although  Binder provides  powerful  constructs, 
it may  be  too  easy  to  misuse  them  and  build a  complex, 
incorrect security policy. It is possible that a simpler lan-
guage  might  be  easier  to  use  and  yet  still  be  expressive 
enough in practice. Again, further experience will help us 
decide. 
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE 
[11]  Iannella,  R.,  editor,  Open  Digital  Rights  Language 
(ODRL), available at http://odrl.net. 
[12]  ITU-T  Recommendation  X.509,  “The  directory: 
public-key  and  attribute  certificate  frameworks,”  March 
2000. 
[13]  T. Jim, “SD3: a trust management system with certi-
fied  evaluation,”  Proceedings  of  the  22nd  IEEE  Sympo-
sium on Security and Privacy, Oakland, Calif., May 2001. 
[14]  N. Li, B. Grosof, and J. Feigenbaum, “A practically 
implementable  and  tractable  delegation  logic,”  Proceed-
ings of the 21st IEEE Symposium on Security and Privacy, 
Oakland, Calif., May 2000, pp. 27–42. 
[15]  D.  McDermott  and  J.  Doyle,  “Nonmonotonic  logic 
I,” Artificial Intelligence, 1980, pp. 41–72. 
[16]  R.  Rivest  and  B.  Lampson,  “SDSI—a  simple 
distributed 
infrastructure,” 
at 
http://theory.lcs.mit.edu/~cis/ sdsi.html. 
[17]  J.  Ullman,  Database  and  Knowledge-Base  Systems, 
volume 2, Computer Science Press, Rockville, Maryland, 
1989. 
available 
security 
Although  an  open  security  language  must  be  highly 
expressive,  most  of  its  uses  will  be  application-specific 
and  perhaps  constrained.  We  might  use  Binder  to  define 
families  of  application-specific  predicates  that  would  be 
less powerful and less flexible, but easier for non-special-
ists  to  apply.  While  each  application-specific  family 
would  be  restricted  in  expressiveness,  there  would  be  no 
such  restriction  in  the  core  language,  and  programs  in 
these  various  families  would  interoperate  via  their  ulti-
mate  definition  in  Binder.  Again,  more  experience  is 
needed to validate such an approach. 
Acknowledgements 
The author would like to thank Martín  Abadi for his 
many  helpful  comments  and  insights  on  earlier  drafts  of 
this  paper.  The  author  would  also  like  to  thank  Tony 
Hoare  and  the  anonymous  referees  of  the  2002  IEEE 
Symposium  on  Security  and  Privacy  for  their  advice  on 
improving the paper’s presentation. 
References 
[1]  M. Abadi and R. Needham. 1996. “Prudent engineer-
ing practices for cryptographic protocols,” IEEE Transac-
tions on Software Engineering, January 1996, pp. 6–15. 
[2]  M.  Abadi,  “On  SDSI’s  linked  local  name  spaces,” 
Proceedings of the 10th IEEE Computer Security Founda-
tions Workshop, Rockport, Mass., June 1997, pp. 98–108. 
[3]  A.  Appel  and  E.  Felten.  “Proof-carrying  authentica-
tion,”  Proceedings  of  the  6th  ACM  Conference  on  Com-
puter  and  Communications  Security,  Singapore,  Novem-
ber 1999, pp. 52–62. 
[4]  M. Blaze, J. Feigenbaum, and J. Lacy. “Decentralized 
trust management,” Proceedings of the 17th IEEE Sympo-
sium on Security and Privacy, Oakland, Calif., May 1996, 
pp. 164–173. 
[5]  M.  Blaze,  J.  Feigenbaum,  J.  Ioannidis,  and  A. 
Keromyrtis.  “The  KeyNote  Trust  Management  System 
Version 2,” IETF RFC 2704, September 1999. 
[6]  Clocksin,  W.,  and  C.  Mellish.  Programming  in 
Prolog (3rd ed.), Springer-Verlag, 1987. 
[7]  ContentGuard, 
Inc.,  eXtensible 
Language 
http://www.xrml.org. 
[8]  C. Ellison, B. Frantz, B. Lampson, R. Rivest, B. Tho-
mas, and T. Ylonen, “SPKI certificate theory,” IETF Net-
work Working Group RFC 1693, September 1999. 
[9]  P.  Gutmann,  “X.509  style  guide,”  available  at 
http://www.cs.auckland.ac.nz/~pgut001/pubs/x509guide.t
xt, October 2000. 
[10]  J.  Halpern,  and  R.  van  der  Meyden,  “A  logic  for 
SDSI’s linked local name spaces,” Proceedings of the 12th 
IEEE  Computer  Security  Foundations  Workshop,  1999, 
pp. 111–122. 
rights  Markup 
(XrML)  2.0  Specification,  available  at 
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE 
Appendix A. EBNF grammar for Binder 
can be imported as 
 ::=  
 ::=  [ “:-”  ] “.” 
 ::=  
 ::= [  (“,” )* ] 
 ::= [  “says” ] 
            [ “(”  “)” ] 
 ::=  
 ::=  (“,” )* 
 ::=  
         |  
 ::=  
 ::=  * 
             | “"” * “"” 
 ::=  * 
        | “_”  
Here,  is an upper-case letter;  is a 
lower-case  letter;   is any  character;    is 
any character that can appear in an identifier;  
is any character that can appear in a string. 
The Binder grammar differs from a datalog grammar 
only  in  the  optional  quoting  of  atoms  via   
says. Quoting can appear only to depth 1; a quoted atom 
cannot  be  quoted  again.    Terms  cannot  be  quoted  at  all. 
These  restrictions  are  designed  to  interoperate  with  the 
rules for importing Binder statements, discussed below. 
Appendix B. Semantics of Binder 
The  semantics  of  Binder  are  based  on  the  semantics 
of  datalog.  We  can  transliterate  a  Binder  program  into 
datalog  by  moving  the  says  quoting  into  an  ex- 
tra  argument  in  every  atom;  C  says  pred(args)  be-
comes  pred(C,  args),  while  pred(args)  becomes 
pred(null,  args)  where  null  is  a  new  term  that  ap-
pears nowhere else in the program. After such a rewriting, 
we can adopt datalog’s proof rules directly for Binder. 
Under certain circumstances, a Binder statement from 
a  context  C—a  fact,  a  rule,  or  a  derivable  atom—can  be 
exported  in  a  certificate  signed  by  C,  and  imported  into 
another  context  quoted  by  C.  Below,  we  consider  deriv-
able  atoms  separately  from  facts  and rules,  as  we  extend 
datalog’s  standard  proof  rules  with  two  additional  proof 
rules for Binder (stated here informally). 
B.1. Proof Rule 1 
A  certificate  signed  by  C  and  containing  a  derivable 
atom  that  is  not  quoted  with  says  (i.e.,  an  atom  of  the 
form  pred(args))  can  be  imported  into  any  context, 
quoted with C. For example, the atom-bearing certificate 
    member(john_smith, bcl). 
    (signed: C) 
    C says member(john_smith, bcl). 
An atom that is already quoted cannot be imported. 
B.2 Proof Rule 2 
A rule can be imported if the atom in its head is not 
quoted. A fact is equivalent to a rule with an empty body. 
When a rule in a certificate from context C is imported, its 
head will be quoted with C, and all unquoted atoms in its 
body will be quoted with C. For example, the rule-bearing 
certificate 
    member(X, bigco) :- member(X, bcl). 
    (signed: C) 
can be imported as 
    C says member(X, bigco) :- 
      C says member(X, bcl). 
while the certificate 
    member(X, bigco) :- 
      C′ says member(X, bigco). 
    (signed: C) 
can be imported as 
    C says member(X, bigco) :- 
      C′ says member(X, bigco). 
Since  an  imported  rule  will  have  quoting  in  its  head,  an 
imported  rule  cannot  be  exported  and  imported  again. 
Instead, the original certificate must be reused. 
Appendix C. Time complexity of Binder 
At any point in the execution of a Binder program at 
some  context,  the  current  rules  and  derivable  atoms  can 
be  translated  into  datalog  as  described  in  Appendix  B. 
Since  datalog  is  decidable  in  polynomial  time,  there  is  a 
local  polynomial-time  decision  procedure  for  Binder  that 
ignores future communication. 
While  the restrictions  on  statement  import  in  Binder 
may seem onerous, we suspect they may not be very sig-
nificant  in  practice.  We  can  imagine  removing  these  re-
strictions,  while  at  the  same  time  generalizing  Binder  so 
that each atom can be quoted by zero or more terms, con-
stant  or  variable,  and terms  can  themselves  be  quoted  by 
contexts  to  provide  namespaces—as  a  generalization  of 
SDSI—but  so  generalized  a  language  would  soon  be  no 
longer  decidable.  We  suspect  that  there  are  lesser  gener-
alizations to Binder that retain a polynomial-time decision 
procedure, and  we  are  currently  exploring possible  alter-
natives. 
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE