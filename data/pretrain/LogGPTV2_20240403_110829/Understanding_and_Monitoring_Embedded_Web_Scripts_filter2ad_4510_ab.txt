node described in the ﬁrst line, but the script accesses all of
its ancestor nodes. The APIs called on these nodes usually do
not reveal much information, e.g. GetID or GetClientWidth.
We suspect this is due to the script using a JavaScript library
helper such as jQuery. To capture this behavior pattern, the
root matching mode can be used to match all three accesses
to GetClientWidth in Listing 1, as shown here:
/BODY[1]/DIV[3]/DIV[4]/DIV[1]:AppendChild
root:/BODY[1]/DIV[3]/DIV[4]/DIV[1]:GetClientWidth
2.3 Permission interference
Attribute-based selectors open the possibility that one
permission interferes with another, undesirably extending the
collection of matched nodes and allowed APIs. For example,
suppose the following two permissions were granted:
// DIV[@class=‘tracker’]:SetId
// DIV[@id=‘adPos’]:AppendChild
The ﬁrst permission allows the id attribute to be set on
any DIV node that has a certain class; the second allows
appendChild to be called on any DIV node that has a certain
id. In combination, they allow the script to set id attribute
of any DIV that has class tracker, thus gaining permission
to call appendChild on those nodes.
Manually-created policies need to be carefully examined
to exclude the use of certain attributes as selectors if policies
853853
from the same third party allows them to be set freely. The
PolicyGenerator tool is designed to automatically avoid such
conﬂicts (Section 7.1).
Sometimes the site owner wants to grant
third-party
scripts permission to call any API on certain nodes (e.g.,
placeholder nodes to be replaced by ads or widgets). How-
ever, enabling a wild card action that matches all DOM
APIs is dangerous due to possible interference scenarios. To
support this scenario, we created a special action denoted by
the exclamation mark to indicate all API calls except those
that may cause policy interferences.
For example, the permission,
// DIV[@class=‘content’]:!,
allows the script
to call any API on any DIV node
with class content, except ones that may set the class at-
tribute to prevent self-interference. Similarly, the permission,
// DIV[@id=‘adPos’]:!, allows any API on the DIV with id
adPos, except for ones that may set its id attribute. However,
when these two permissions co-exist for a script, they will
forbid API calls to both setClass and setID, to prevent self
and mutual interference. This feature proved to be extremely
helpful in our evaluation (Section 7.2).
3 INSPECTING SCRIPT BEHAVIOR
ScriptInspector is a tool for inspecting the behavior of
scripts, focused on monitoring how they manipulate re-
sources and detecting violations of the permissions we
deﬁned in Section 2. Next, we explain how ScriptInspector
records third-party script behavior. Section 3.2 discusses
how the records are checked against policies or output to
logs for admin’s inspection.
3.1 Recording accesses
ScriptInspector is implemented by modifying Firefox to
add hooks to JavaScript API calls. ScriptInspector records
all API calls made by scripts that
involve any of the
critical resources mentioned in Section 2.1. Modiﬁcations
are primarily made in the DOM-JS binding section, and
approximately 2000 lines of code were added. The modiﬁed
browser retains the same functionality as a normal browser,
with the addition of access recording capability.
DOM access recording. We modiﬁed Firefox’s C++ im-
plementations of relevant DOM APIs such as insertBefore,
setAttribute and document.write to record DOM accesses.
Complete mediation is ensured as Firefox uses a code
generator to generate the C++ implementation according to
the deﬁned interfaces, and our modiﬁcations are inserted to
the code generator, rather than individual implementations.
ScriptInspector augments each DOM node with a hidden
ﬁeld to record accesses to that node. For each access,
the caller identity as well as the API name and optional
arguments are recorded in this hidden ﬁeld. Thus, function
call information is preserved with the node for the node’s
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:03:40 UTC from IEEE Xplore.  Restrictions apply. 
lifetime. We discuss necessary steps to address node removal
events in Section 3.2.
Recording other actions. For non-DOM resources, we also
add hooks to their C++ implementations. Since these calls
are not tied to a particular node, the caller records are stored
in the hidden ﬁeld on the document object of the page.
Script-injected nodes. To support the [o] tag (Section 2.1),
ScriptInspector tracks the ownership of a node by aug-
menting node-creation APIs such as document.write and
document.createElement. If a third-party script creates a
node and inserts it into the document, we record the respon-
sible party as that node’s owner. This feature is especially
useful since the host can simply ignore accesses to third-
party owned nodes and ensure its own nodes are not used
in any arguments.
Attribution. Correctly attributing actions to scripts is impor-
tant, since policies are applied based on the domain hosting
the script. To obtain the identity of the caller, ScriptInspector
leverages existing error handling mechanisms implemented
in Firefox. Firefox’s JavaScript engine, SpiderMonkey, pro-
vides a convenient API to obtain the current call stack.
It contains information about the script’s origin and line
number, which are all we need to attribute the accesses.
Additionally, a site administrator can provide ScriptInspector
with a list of whitelist domains. When a call takes place,
ScriptInspector records all third party domains on the stack,
except for host domain and whitelisted domains.
The call stack information is sufﬁcient to correctly at-
tribute most introduced dynamic inline code (e.g., through
eval or document.write), but falls short when an inline event
handler is registered to an object and is later triggered.
ScriptInspector currently cannot handle this scenario and we
rely on future Mozilla patches to ﬁx this issue.
3.2 Checking policies
To check recorded accesses against a given policy, Script-
Inspector introduces the checkPolicy function. When this
function is called, ScriptInspector walks the DOM tree,
collects all DOM accesses and other accesses stored in
the document node, and checks them against the policy.
The violating accesses can be used for visualization by the
Visualizer (Section 4) or as input to PolicyGenerator to use
in automatic policy generation (Section 6). A log ﬁle is
also produces for site administrators to inspect manually
(an example log ﬁle with violations serialized to absolute
XPaths is shown in Listing 1).
As opposed to the straightforward design of recording
and serializing violations as the accesses happen, our design
only records them at access time, but collects and serializes
the access records when the page unloads. The additional
complexity here may be counter-intuitive; however, such a
delay is important for improving the robustness of DOM
permissions. For example, a third-party script may obtain the
height of a node before the host script sets its id to ‘adPos’.
In this case, the permission // DIV[@id=‘adPos’]:GetHeight
cannot cover this access if the policy is checked immedi-
ately, since its id is yet to be set to ‘adPos’. Due to the
nondeterministic execution order of scripts, checking policy
when the access happens is not a good choice.
However,
this leaves opportunities to evade mediation
if a script reads content of a node and later removes
that node. To eliminate this leak, we tweak the APIs that
directly (e.g. removeChild) or implicitly (e.g. setInnerHTML)
remove DOM nodes: ScriptInspector automatically performs
checkPolicy on the to-be-removed nodes and stores the
violations into the hidden ﬁeld of its owner document before
they are actually removed.
4 VISUALIZATION
To visualize the access violations and permission candi-
dates, we built Visualizer, a ScriptInspector extension that
takes the instrumented DOM and accesses as input, offers
a convenient user interface (shown in Figure 2) to display
the page content that is read or modiﬁed by the third party.
We envision Visualizer being used by concerned site admin-
istrators who hope to gain insight as to how the embedded
scripts interact their websites. With this goal in mind, we
next describe using Visualizer from the perspective of a site
administrator seeking to understand the behaviors of scripts
on her site. We present some interesting discoveries from our
experiments visualizing script behaviors in Section 5. The
Visualizer may also be used to visualize the node collections
that are matched by a permission. This can be used together
with the PolicyGenerator to help administrators make their
decisions (see Section 7.1).
Figure 2 is a screenshot of visualized accesses at foxnews.
com. The left sidebar displays the domains of all third-party
scripts embedded on the page (googleadservices.com and
googlesyndication.com shown in the screenshot), and the site
administrator may click a domain (googlesyndication.com in
this example) to expand it and highlight the nodes access by
scripts from that domain.
Visualizer classiﬁes DOM accesses into three subcate-
gories — getContentRecords (reading the content of a node,
e.g. getInnerHTML), setterRecords (modifying the attribute
or content of the node), and getterRecords (reading proper-
ties of a node other than the content itself). These categories
help administrators quickly locate the accesses of interest.
Uses may click on these categories to further expand them
into individual accesses.
Users may hover over each entry to highlight the accessed
node on the right side. They may also click on a category
to see all nodes that were accessed that way (enclosed by
double blue border and covered in a faint blue overlay in
the screenshot). For accesses to nodes that any third-party
owns (See Section 2.1), the entry is displayed in green and
854854
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:03:40 UTC from IEEE Xplore.  Restrictions apply. 
enclosed by a dashed border. In Figure 2, the scripts form
googlesyndication.com, representing one of Google Ad net-
works, accessed non-content properties of its own inserted
ads on foxnews.com. Upon seeing this, the administrator may
proceed to make decisions to approve embedding Google
Ads on their site.
5 FINDINGS
We used ScriptInspector and Visualizer to examine the top
200-ranked US websites from Alexa.com. Assuming the role
as their administrators, we aim to understand how resources
are accessed by embedded scripts. We created accounts
at these sites and logged into them if possible. We also
attempted some typical user actions on these sites, such as
adding merchandise into cart for e-commerce websites, and
visiting user proﬁle pages for sites that support login.
Browser properties. Almost all of the tested third-party
scripts access a number of generic properties of the browser
including the navigator, screen object, and some properties
of root DOM nodes such as the document and body element.
Although this information information could also be used
for ﬁngerprinting browsers [2], we consider this behavior
reasonable for most scripts since they determine what con-
tent to serve based on the browser’s vendor and version
(navigator.userAgent), and user’s screen size (screen.height
or body.clientHeight).
Network. Another unsurprising but concerning fact is that
most scripts we observed send out network requests, at least
to their own host servers. Quite a few advertising scripts
(e.g., googleadservices.com, moatads.com) also send re-
quests to many other destinations (mostly afﬁliate networks).
Modifying page content. Advertising scripts and social
widget scripts often modify the container page by injecting
or replacing placeholders with content in the page, as seen
in Figure 2. In addition, multiple tracking scripts insert
Figure 3: Script reading EddieBauer’s shopping cart
tracking pixels and scripts from other tracking companies,
and advertising scripts may inject other scripts from afﬁliate
programs. However, it is hard for us to determine if such
modiﬁcations violate the site administrator’s expectations.
Reading page content. Finding scripts that read speciﬁc
page content was less common, but we did observe this
for several scripts. The content read ranges from a speciﬁc
element to the full document. Reading page content may
compromise user privacy. Visualizer alerts the site adminis-
trators to scripts that read page content by presenting them
in a different category, especially when network access also
happens in the same session.
Scripts from adroll.com read the DOM element that dis-
plays the SKU number of online merchandises on certain
e-commerce pages. We initially discovered this when using
Visualizer on newegg.com, but later found similar behaviors
on dx.com and bhphotovideo.com. We manually examined
Adroll’s script after using deobfuscation and code beautiﬁers,
and found out that it indeed contains case-switch statements
to handle many particular e-commerce site layouts.
the script
According to Adroll’s company website,
is
used for ad-“retargeting” purposes. This means the company
learns the user’s purchasing interests from shopping sites
that embed the script, and then displays relevant advertise-
ments to the user on other sites, hoping for a better conver-
sion rate. It seems likely that in this case Newegg agreed
to embed the adroll.com scripts, however, its users have no
idea their detailed interactions with newegg.com are being
tracked by an external service. Newegg’s privacy policy
states vaguely that it may employ third-party companies to
perform functions on their behalf and the third parties have
limited access to user’s personal information, but nothing
that suggests user’s shopping actions are immediately re-
vealed to third parties.
3P Owned ([o]) nodes 
Displaying nodes 
Figure 2: Visualizer interface
Similar behaviors were observed on other e-commerce
sites (e.g., autozone.com, eddiebauer.com) involving other
third-party service providers (e.g., monetate.com, certona.
com, tiqcdn.com). For example, a script from monetate.com
that is embedded by EddieBauer’s site accesses and trans-
855855
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:03:40 UTC from IEEE Xplore.  Restrictions apply. 
popular third-party scripts. The PolicyGenerator and Visual-
izer are often not needed to develop base policies (especially
for the script’s author who should already understand its
expected behavior), as the base policy often does not contain
speciﬁc DOM accesses.
Figure 4: Script sending out EddieBauer’s shopping cart
information
6.1 Evaluation method
mits user’s shopping cart information (Figure 3). Figure 4
shows a captured form submission request in Fiddler [16]
that was initiated by a script from monetate.com, with
red box highlighting the cart information, and blue box
highlighting the product page.
In another case, crwdctnrl.net scripts read user inputs on
some sites. On ask.com, the script reads the main text input
box used by users to submit questions. On weather.com, it
reads the text input in which the user enters their zip code
or address to request local weather. The script subsequently
sends trafﬁc back to its own server, although we are not able
to conﬁrm that the trafﬁc leaks the user input.
Many scripts occasionally read certain properties from a
particular node type, for example, scorecardresearch.com
scripts read all images’ outerHTML on allrecipes.com. Since
allrecipes.com’s user login information is included as an
attribute of user’s login avatar, comScore (the company
who operates scorecardresearch.com) may obtain user’s
information through the image accesses. Other commonly
accessed tag/attribute pairs include getting the href attribute
of all a elements or the content attribute of all meta elements.
Either of these may contain sensitive information.
The most concerning scenario comes from the sites that
embed krxd.net scripts, which consistently read all content
of the embedding host page. This includes all values of all
text nodes, and innerHTML of all elements. We have also
observed that scripts from this domain send requests to at
least 25 different domains, requesting additional scripts and
tracking pixels. We ﬁnd this behavior appalling, and cannot
fathom the reasons behind it by looking at its description on
Krux’s company website.
6 DEVELOPING BASE POLICIES
The base policy for each script is a policy intended to
be used across all sites that embed that script. Obtaining
a script’s base policy only requires a one-time effort, with
perhaps additional work required to update the policy when
the script is modiﬁed signiﬁcantly. Hence, it is not necessary
to automate developing base policies. In deployment, the
base policies could be centrally maintained and distributed,
either by the script’s service provider (perhaps motivated to
disclose its behavior to earn the trust of potential integra-
tors), or by a trusted security service.
In this section, we report on our experience using the logs
generated by ScriptInspector to develop base policies for 25
We manually developed policies for 25 selected scripts.
The manual effort required to develop these policies limits
the number of scripts we can examine. However, the scripts
we examined are the most popular ones among their respec-
tive categories, and our experience from Section 5 indicates
that their behavior is a good representation of extant third-
party scripts.
To select the 25 scripts, we ﬁrst took the 1000 highest-
ranked websites from alexa.com and visited their homepages
repeatedly over a week, crawling pages to collect embedded
scripts. We extracted all third-party scripts seen in this pro-
cess, and sorted them based on the number of occurrences.
We took the top 25 on the list and manually visited 100 sites
which embed each script, sampled randomly from the 1000
sites on the alexa.com list.2
Of those 100 sites, 77 include user registration and login
functionality. For each of these, we manually created a test
account and logged in to the website to mimic a typical
user’s experience. After user sessions are prepared, we
ﬁrst visit each site’s homepage, follow links to navigate to
several subpages, and call document.checkPolicy to output an
access report. We repeat this process until no new accesses
are seen in ﬁve consecutive requests. We then manually
extract the most commonly observed accesses to form the
base policy. Our overall goal in writing base policies is to
allow all behaviors that an integrator is likely to encounter
without over-generalizing. The base policy should contain
mostly special API accesses and generic DOM accesses to
the root elements of the page (document, body and head).
However, if certain DOM accesses with ﬁxed patterns are
seen consistently, they are also included in the base policy.
6.2 Base policy examples
For clearer presentation, we discuss base policies orga-
nized by grouping scripts into four categories: analytics,
advertising, social widgets, and web development.