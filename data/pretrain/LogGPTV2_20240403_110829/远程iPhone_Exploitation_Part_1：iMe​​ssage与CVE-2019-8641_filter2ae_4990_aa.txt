# 远程iPhone Exploitation Part 1：iMe​​ssage与CVE-2019-8641
|
##### 译文声明
本文是翻译文章，文章原作者 googleprojectzero，文章来源：googleprojectzero.blogspot.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 简介
这是三篇系列文章中的第一篇，将详细介绍如何在iOS
12.4上远程利用iMessage中的漏洞，无需任何用户交互，它是我在2019年12月的36C3会议上演讲的一个更详细的版本。
本系列的第一部分对该漏洞进行了深入的分析，第二部分介绍了一种远程破坏ASLR的技术，第三部分介绍了如何获得远程代码执行（RCE）。
本系列中介绍的攻击使攻击者能够在几分钟内远程控制用户的iOS设备，攻击者仅拥有用户的Apple
ID（移动电话号码或电子邮件地址）。之后，攻击者可以窃取文件、密码、2FA代码、短信和电子邮件以及其他用户APP数据。还可以远程激活麦克风和摄像头。所有这些都是可能的，而无需向用户显示任何交互（打开攻击者发送的URL或者消息通知）。首先攻击利用CVE-2019-8641漏洞绕过ASLR，然后在目标设备的沙盒外执行代码。
这项研究的主要原因是：仅给出一个远程内存破坏漏洞，是否有可能在iPhone上实现远程代码执行而没有其他漏洞，并且无需任何形式的用户交互？这个系列文章表明这实际上是可能的。
这个漏洞是与娜塔莉·西尔瓦诺维奇(Natalie
Silvanovich)合作的漏洞研究项目中的一部分，已于2019年7月29日报告给Apple,这个漏洞首先在iOS
12.4.1中得到了缓解，于8月26日发布，[使易受攻击的代码无法通过iMessage访问](https://twitter.com/5aelo/status/1172534071332917248)，在2019年10月28日发布的iOS
13.2中完全修复。根据在exploit开发过程中获得的见解，提出了进一步的强化措施，如果实施这些措施，将来会使类似的漏洞利用变得更加困难。由于其中一些强化措施与其他messenger服务和手机操作系统相关，因此在本系列文章中会提到它们，并在最后进行总结。
对于安全研究人员来说，[这里](https://bugs.chromium.org/p/project-zero/issues/detail?id=1917#c6)提供了一个针对iPhone XS上iOS
12.4的POC。为了防止滥用，它在整个利用过程中显示多个通知，提醒受害者正在遭受攻击。而且，它不能实现本地代码执行(即执行shellcode)，因此它很难与现有的特权提升漏洞相结合。这些限制都不需要进一步的漏洞来弥补，只需要有能力的攻击者重新设计exploit。内置的限制和通知仅仅是为了阻止非研究人员滥用而设计的。需要注意的是，专业的研究员很可能已经具备了利用已公布的代码的能力，无论是自己发现漏洞还是通过补丁对比来发现漏洞，或者通过CVE-2019-8646与其他任何内存破坏漏洞相结合，进行1-day的漏洞利用。
和之前一样，我希望这项研究能够帮助其他安全研究人员和软件开发人员，介绍如何绕过缓解措施，并分享一些我的想法，以确保我所发现的漏洞能够得到缓解。
## iMessage架构
在最终向用户显示通知并将消息写入messages数据库之前，传入的iMessages会经过多个服务和框架。下图描述了在iOS
12.4上处理iMessage而不需要与用户交互的主要服务。(红色边框表示该进程存在沙盒)
在以下截图中可以看到：
Natalie
Silvanovich在之前的一篇[文章](https://googleprojectzero.blogspot.com/2019/08/the-fully-remote-attack-surface-of.html)中介绍了远程可访问的攻击面，其中包括众所周知的[NSKeyedUnarchiver
API](https://developer.apple.com/documentation/foundation/nskeyedunarchiver?language=objc)以及iMessage数据格式。在本系列文章中，必须知道到NSKeyedUnarchiver
API中的漏洞通常可以在两种不同的上下文中触发：在沙盒的imagent和非沙盒SpringBoard进程（后者管理主iOS
UI，包括主屏幕），两种情况在漏洞利用方面都各有利弊。例如，虽然SpringBoard已经在沙箱外部运行，似乎是更好的目标,但它也是一个比较重要的系统进程，当崩溃时会导致设备明显的“注销重启桌面”，屏幕突然变黑，并且在锁定屏幕出现之前加载图标会出现几秒。
从iOS13开始，`NSKeyedUnarchiver`数据的解码不再发生在`SpringBoard`内部，而是发生在沙箱`IMDPersistenceAgent`中，这大大减少了iMessage的非沙箱攻击面。
## iMessage 传递
为了通过iMessage传递exploit，需要能够向目标发送自定义iMessage。这需要与Apple的服务器进行交互，并处理iMessage的`end2end`加密。用于这项研究的一种简单的方法是通过使用FRIDA这样的工具将`imagent`中处理iMessage的代码HOOK到现有代码中。这样，可以通过以下方式在macOS上运行的脚本发送自定义iMessage：
  * 1.生成所需的payload（例如触发NSKeyedUnarchiver错误）并将其存储到磁盘
  * 2.调用一个小的Apple脚本，该脚本显示Messages.app将带有占位符内容（例如“ REPLACEME”）的消息发送给目标
  * 3.使用frida来Hook imagent,并将包含占位符的iMessages的内容替换为payload文件的内容
同样，也可以通过使用frida来Hook imagent中的`receiver`函数。
例如，当从Messages.app发送“REPLACEME”消息时，将向receiver发送以下iMessage（编码为二进制plist）：
    {
        gid = "008412B9-A4F7-4B96-96C3-70C4276CB2BE";
        gv = 8;
        p =     (
            "mailto:PI:EMAIL",
            "mailto:PI:EMAIL"
        );
        pv = 0;
        r = "6401430E-CDD3-4BC7-A377-7611706B431F";
        t = "REPLACEME";
        v = 1;
        x = "REPLACEME";
    }
然后，frida钩子会在消息被序列化、加密发送到Apple服务器之前对其进行修改:
    {
        gid = "008412B9-A4F7-4B96-96C3-70C4276CB2BE";
        gv = 8;
        p =     (
            "mailto:PI:EMAIL",
            "mailto:PI:EMAIL”
        );
        pv = 0;
        r = "6401430E-CDD3-4BC7-A377-7611706B431F";
        t = "REPLACEME";
        v = 1;
        x = "REPLACEME";
        ati = ;
    }
这将导致接收设备上的imagent使用`NSKeyedUnarchiver`
API解码`ati`字段中的数据。可以在[这里](https://github.com/googleprojectzero/iOS-messaging-tools/tree/master/iMessage)找到允许发送自定义消息和转储传入消息的示例代码。
## CVE-2019-8641
用于此研究的漏洞是CVE-2019-8641，对应于[Project Zero issue
1917](https://bugs.chromium.org/p/project-zero/issues/detail?id=1917)。这是`NSKeyedUnarchiver`组件中的另一个bug,
Natalie已经对此进行了深入的讨论。虽然可能以类似的方式在本研究的`NSKeyedUnarchiver`组件中发现的其他内存破坏漏洞，但该漏洞似乎最容易利用。
这个BUG发生在`NSSharedKeyDictionary`的解档（unarchiving）过程中，`NSSharedKeyDictionary`是一种特殊的`NSDictionary`。其中，在`NSSharedKeySet`中预先声明了`keys`，以允许更快地访问元素。此外，`NSSharedKeySet`本身具有`subSharedKeySet`，基本上是可以构建一个KeySet的链表。
要理解这个漏洞，首先需要了解`NSKeyedUnarchiver`序列化格式。下面是一个简单的存档文件，其中包含了由plutil（1）打印的序列化NSSharedKeyDictionary（NSKeyedArchiver将对象图编码为plist），并添加了一些注释：
    {
      "$archiver" => "NSKeyedArchiver"
      # The objects contained in the archive are stored in this array
      # and can be referenced during decoding using their index
      "$objects" => [
        # Index 0 always contains the nil value
        0 => "$null"
        # The serialized NSSharedKeyDictionary
        1 => {
          "$class" => {value = 7}
          "NS.count" => 0
          "NS.sideDic" => {value = 0}
          "NS.skkeyset" => {value = 2}
        }
        # The NSSharedKeySet associated with the dictionary    
        2 => {
          "$class" => {value = 6}
          "NS.algorithmType" => 1
          "NS.factor" => 3
          "NS.g" => 
          "NS.keys" => {value = 3}
          "NS.M" => 6
          "NS.numKey" => 1
          "NS.rankTable" => 
          "NS.seed0" => 361949685
          "NS.seed1" => 2328087422
          "NS.select" => 0
          "NS.subskset" => {value = 0}
        }
        # The keys of the NSSharedKeySet 
        3 => {
          "$class" => {value = 5}
          "NS.objects" => [
            0 => {value = 4}
          ]
        }