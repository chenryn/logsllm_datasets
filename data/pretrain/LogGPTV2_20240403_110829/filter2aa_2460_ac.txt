14.0"\VC\bin\dumpbin.exe /IMPORTS:rpcrt4.dll $_.VersionInfo.FileName); If($out -
like "*RpcServerListen*"){ Write-Host "[+] Exe starting RPC Server: 
$($_.VersionInfo.FileName)"; Write-Output "[+] $($_.VersionInfo.FileName)`n`n 
$($out|%{"$_`n"})" | Out-File -FilePath EXEs_RpcServerListen.txt -Append } }
Another way to find interesting RPC servers is by querying the RPC Endpoint Mapper, either 
locally or on any remote system. 
Microsoft has a test utility called PortQry to do that (there is also a GUI version of that tool 
available) that you can use like this: C:\PortQryV2\PortQry.exe -n  -e 135
This tool gives you some information about remote RPC interfaces that the Endpoint Mapper 
knows about (remember that Well-known Endpoints do not have to inform the Endpoint Mapper 
about their interfaces).
Another option is to query the Endpoint Manager directly by calling RpcMgmtEpEltInqBegin and 
iterating over the interfaces via RpcMgmtEpEltInqNext. A sample implementation, named 
RPCDump, of this approach was included in Chris McNab’s amazing book ‘Network Security 
Assessment’, O’Reilly published the tool written in C here (according to the comment annotation 
credits for this code should go to Todd Sabin). 
I have ported this cool tool to VC++ and made some slight usability changes. I’ve published my 
fork at https://github.com/csandker/RPCDump.
As shown this tool also list the interfaces of the found RPC endpoints, along with some other 
information. I won’t go into the details of all these fields, but if you’re interested check out the 
code and read along the Windows API documentation. The stats for example are retrieved by a 
call to RpcMgmtInqStats, where the values returned are referenced in the Remarks section.
Once again remember that there are only the RPC interfaces that are registered with the target’s 
Endpoint Mapper.
RPC Clients
Finding clients that connect to remote or local RPC servers might also be an interesting target. 
There is no single authority that is aware of which RPC clients are currently running, therefore 
you’re down to two options for finding clients:
Finding executables/Processes that use client RPC APIs; Or
Caught clients in the act
Finding local executables that import client RPC API is analogous to what we already did to find 
servers with DumpBin. A good Windows API to look for is RpcStringBindingCompose:
Get-ChildItem -Path "C:\Windows\System32\" -Filter "*.exe" -Recurse -ErrorAction 
SilentlyContinue | % { $out=$(C:\"Program Files (x86)"\"Microsoft Visual Studio 
14.0"\VC\bin\dumpbin.exe /IMPORTS:rpcrt4.dll $_.VersionInfo.FileName); If($out -
like "*RpcStringBindingCompose*"){ Write-Host "[+] Exe creates RPC Binding 
(potential RPC Client) : $($_.VersionInfo.FileName)"; Write-Output "[+] 
$($_.VersionInfo.FileName)`n`n $($out|%{"$_`n"})" | Out-File -FilePath 
EXEs_RpcClients.txt -Append } }
The other option to find RPC clients is by spotting them while they’re connection to their target. 
One example of how clients can be spotted is by inspecting the traffic that is sent over the wire 
between two systems. Wireshark has a ‘DCERPC’ filter that can be used to spot connections.
An example of a client connecting to a server is shown below:
The bind request is one of the things we can look for to identify clients. In the select package we 
can see a client trying to bind to a server interface with the UUID of “d6b1ad2b-b550-4729-b6c2-
1651f58480c3”.
Unauthorized Access
Once you identified an RPC server that exposes interesting functionality that could be useful to 
your attack chain the most obvious thing to check is if you can access the server unauthorized. 
You could either implement your own client, e.g. based on the my Sample Implementation, or 
refer to the Access Matrix to check if your client can connect to the server.
If you already got heads deep into reverse engineering the RPC server and found that the server 
sets authentication information by calling RpcServerRegisterAuthInfo with its SPN and a specified 
Service Provider, be reminded that an authenticated server binding does not enforce the 
client to use an authenticated binding. In other words: Just because the server sets 
authentication information does not mean the client needs to connect through an authenticated 
binding. Moreover when connecting to a server that sets authentication information be aware 
that client calls with invalid credentials will not be dispatched by the run time library 
(rpcrt4.dll), however, client calls with no credentials will be dispatched. Or to put it with 
Microsoft words:
Remember that, by default, security is optional 
Source: https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterif
ex
Once you are connected to a server the question of “what to do next?” arises… 
Well you’re then in a position to call interface functions, the bad news is: You need to identify the 
function names and parameters first, which comes down to reverse engineering your target 
server. 
If you’re lucking and you’re not looking at a pure RPC server, but a COM server (COM, especially 
DCOM, uses RPC under the hood) the server might come with a Type Library (.tlb) that you could 
use to lookup interface functions.
I won’t go any deeper into type libraries or anything else here (the blog post is quite long already), 
but my general recommendation for someone in this situation would be: Take my sample RPC 
client and server code, compile it and start your reverse engineering journey with sample code 
you know. In that particular case, let me add another clue: My sample interface has an “Output” 
function defined in the IDL file, this “Output” function begins with the print statement printf("
[~] Client Message: %s\n", pszOutput); , you could for example start by searching for the 
substring [~] Client Message  to figure out where this particular interface function is.
Client Impersonation
Client impersonation also provides interesting attack surface. I’ve already put some light on what 
Impersonation is and how it works in the last part of the series, if you missed that and need a 
fresh up on Impersonation you will find that bit explained in the Impersonation Section of my last 
post.
The recipe for impersonating a client is as follows:
You need a RPC client connecting to your server
The client must use an authenticated binding (otherwise there would be no security 
information you could impersonate)
The client must not set the Impersonation Level authenticated binding below 
SecurityImpersonation
… that’s it
The process of impersonation is as easy as:
Calling RpcImpersonateClient from within your server interface function 
Note that this function takes the binding handle as input, therefore you need a Explicit binding 
server to use impersonation (which makes sense)
If that call succeeds, the server’s thread context is changed to the client’s security context 
and you can call GetCurrentThread & OpenThreadToken to receive the client’s 
Impersonation token. 
If you’re now like ‘WTF security context change?!’ you will find answers in the IPC Named Pipe post 
if you’re more like ‘WTF Impersonation token?!’ you will find answers in my Windows Authorization 
Guide
Once you’ve called DuplicateTokenEx to turn your Impersonation token into a primary token, 
you can happily return to your original server thread context by calling RpcRevertToSelfEx
And finally you can call CreateProcessWithTokenW to create a new process with the client’s 
token.
Please note that this is only one way to create a process with the client’s token, but in my eyes it 
pictures the way of doing these things pretty well and therefore i use this approach here. A 
sample implementation of this code can be found here. 
This is by the way the same procedure i used for impersonating Named Pipe clients in my last 
post.
As said in the recipe steps above, you just need a client that connects to your server and that 
client must use an authenticated binding. 
If the client does not authenticate its binding that the call to RpcImpersonateClient will result in 
Error 1764 (RPC_S_BINDING_HAS_NO_AUTH). 
Finding a suitable client that you can make connect to your server comes down to finding a RPC 
client (see section Finding RPC Clients) and finding one that you can make connect to your server. 
Well the later might be the tricky part in this exploit chain and I can’t give general 
recommendation here on how to find those connections. One reason for that is because it 
depends on the protocol sequence used by the client, where an unanswered TCP call might be 
best detectable when sniffing on the wire where an unanswered Named Pipe connection attempt 
could also be spotted on the client’s or server’s host system.
In the 1st part of the series (which was about Named Pipes) I pulled a bigger spotlight on client 
impersonation, therefore i will safe myself a few words here. However, if you haven’t already 
done it I would recommend reading up on Instance Creation Race Conditions and also Instance 
Creation Special Flavors. The same principals apply here.
The more interesting aspect is that I intentionally wrote above: “The client must not set the 
Impersonation Level authenticated binding below SecurityImpersonation* … which sounds kinda 
like an opt-out process and that’s exactly what it is. 
Remember that you can set the Quality of Service (QOS) structure on the client side when creating 
an authenticated binding? As said back in section Authenticated Bindings you can use that 
structure to determine the Impersonation Level when connecting to the server. Interestingly if 
you don’t set any QOS structure the default will be SecurityImpersonation, which allows any 
server to impersonate an RPC client as long as the client does not set the Impersonation Level 
explicitly below SecurityImpersonation.
The result of an impersonation could then look like this:
Server Non-Impersonation
There is another side of impersonation that is often missed, but is not less interesting from an 
attackers perspective. 
In part 1 of the series i detailed the steps that are involved when impersonating a client, these 
equally apply also for RPC impersonations (and in all other similar technologies), where the 
following two steps are especially interesting:
>> Step 8: The server’s thread context is then changed to the client’s security context. 
>> Step 9: Any action the server takes and any function the server calls while in the security 
context of the client are made with the identify of the client and thereby impersonating the 
client. 
Source: Offensive Windows IPC Internals 1: Named Pipes
The server’s thread context is changed and all actions then made are made with the security 
context of the client. In the above section (and in my sample code) I used that to grab the current 
thread token, which then is the client’s token and transform that into a primary token to launch a 
new process with that token. I could as well just called any action i want to do directly, because I’m 
all ready operating in the client’s security context. Based on the section title you might already 
guess now where this is heading… what if the impersonation fails and the server does not check 
for that?
The call to RpcImpersonateClient, the API function that does all the impersonation magic for you, 
returns the status of the impersonation operation and it is crucial for the server to check that. 
If the impersonation is successful you’re inside the client’s security context afterwards, but if it 
fails you’re in the same old security context from where you called the RpcImpersonateClient. 
Now a RPC server is likely to run as another user (often also in a higher security context) and in 
those cases it might try to impersonate its clients to run client operations in a lower, presumably 
safer client security context. As an attacker you could use those cases for privilege escalation 
attack vectors by forcing a failing impersonation attempt on the server side and therefore causing 
the server to execute client operating in the higher security context of the server.
The recipe for this attack scenario is simple:
You need a server that impersonates its clients and does not carefully check the return 
status of RpcImpersonateClient before executing further actions.
The action taken by the server after an impersonation attempt must be exploitable from 
your client’s perspective.
You need to force the impersonation attempt to fail.
Finding a local server that tries to impersonate a client is a simple task if you read the previous 
sections and took note of how to use DumpBin.
Finding a server that runs actions in a ‘assumed impersonated’ context which can be used from 
an attackers perspective is pretty much a creative case-by-case analysis of what the server does. 
The best advise to analyze those cases is to think outside the box and potentially be prepared to 
chain multiple events and actions. A rather simple but powerful example could be a file operation 
conducted by the server; Maybe you could use junctions to create a file in a write protected 
system path or maybe you could cause the server to open a Named Pipe instead of a file and then 
use Named Pipe Impersonation to impersonate the server…
Last on the checklist is causing the server’s impersonation attempt to fail and that’s the easiest 
part of the job. There are two ways to achieve this:
You could connect from an unauthenticated binding; Or
You could connect from an authenticated binding and set the Impersonation Level of the 
QOS structure to SecurityAnonymous
Either of this actions will safely cause a failed impersonation attempt. 
This technique is by the way not a new thing, it’s widely known… just forgotten sometimes. Maybe 
there also is a more fancy name out there for this technique that i haven’t come across yet. 
Microsoft even especially reminds you of this in the Remarks section (they even gave this a special 
‘Securtiy Remarks’ heading) of the RpcImpersonateClient function:
If the call to RpcImpersonateClient fails for any reason, the client connection is not 
impersonated and the client request is made in the security context of the process. If the 
process is running as a highly privileged account, such as LocalSystem, or as a member of an 
administrative group, the user may be able to perform actions they would otherwise be 
disallowed. Therefore it is important to always check the return value of the call, and if it 
fails, raise an error; do not continue execution of the client request. 
Source: RpcImpersonateClient: Security Remarks
MITM Authenticated NTLM Connections
The last two sections cover the fact that RPC can be used as a remote networking communication 
technology and therefore also comes with an interesting attack surface on the network side. 
Side Note: I intentionally phrased it this way; Your initially though might have been “Dooough 
what else do you gonna use a technology called Remote Procedure Call for?!” … But in fact RPC is 
very well also intended to be used purely locally as a wrapper for ALPC (i get back to this in part 3 
of the series once i figured out all the mysteries of ALPC).
Anyhow, if you’re using RPC over the wire and you want your binding to be authenticated you will 
need a network protocol that does the authentication for you. That’s why the second parameter 
(AuthnSvc) of the RpcServerRegisterAuthInfo, which is the API function you’d call on the server side 
to create an authenticated binding, let’s you define which authentication service you would like to 
use. You could for example specify Kerberos with the constant value of 
RPC_C_AUTHN_GSS_KERBEROS, or you could specify RPC_C_AUTHN_DEFAULT to use the default 
authentication service, which is - interestingly enough - NTLM (RPC_C_AUTHN_WINNT). 
Kerberos was set to be the default authentication scheme since Windows 2000, but RPC still 
defaults to NTLM.
So if you’re in suitable position on the network and see a NTLM connection coming by there are 
two interesting things you could do with that:
You could grab the NTLM(v2) challenge response hash off the wire and offline brute-force 
the user’s password; And/Or
You could intercept and relay the NTLM connection to gain access to another system.
I don’t want to deep dive into those two topics (if you made it until here you sure have read 
enough already), so I’ll add just two remarks here:
NTLM(v2) challenge brute-forcing is very well known, so you should not have trouble finding 
how to do that. Check out hashcat mode 5600 on https://hashcat.net/wiki/doku.php?id=exa
mple_hashes for an example.
NTLM Relay is very well described by the great Pixis at https://en.hackndo.com/ntlm-relay/. 
There are a few things to be aware of depending on the protocol used so make sure you 
check out that post if you’re interested.
MITM Authenticated GSS_NEGOTIATE Connections
Last but not least… you nearly made it through this post. 
Next to NTLM based network authentication schemes, which is what you get if you chose 
RPC_C_AUTHN_WINNT or RPC_C_AUTHN_DEFAULT as the authentication service in your 
RpcServerRegisterAuthInfo call, the very often used RPC_C_AUTHN_GSS_NEGOTIATE constant is also 
an interesting target. 
If RPC_C_AUTHN_GSS_NEGOTIATE is chosen Microsoft’s Negotiate SSP is used to instruct the client 
and server to negotiate on their own if NTLM or Kerberos should be used to authenticate users. 
By default this negotiation will always result in Kerberos if client and server support it.
This negotiation can be attacked from an intercepting network position to force the usage of 
NTLM over Kerberos, effectively downgrading the authentication scheme. The caveat is that this 
attack requires a suitable network position and missing signatures. I will not dive deeper into this 
at this point, mostly cause I’ve detailed the process and the attack in an older post here: 
Downgrade SPNEGO Authentication.
By the way the authentication service constants that mentioned here can be found here: https://d
ocs.microsoft.com/en-us/windows/win32/rpc/authentication-service-constants.
That’s it.. you made it!
References
Microsoft’s documentation of RPC: https://docs.microsoft.com/en-us/windows/win32/rpc/ov
erviews
Jonathan Johnson’s (more defensive focused) Review of RPC: https://ipc-research.readthedoc
s.io/en/latest/subpages/RPC.html
Adam Chester’s Review of RPC: https://blog.xpnsec.com/analysing-rpc-with-ghidra-neo4j/
A Code Project on how to start programming with RPC: https://www.codeproject.com/Article
s/4837/Introduction-to-RPC-Part-1#Implicitandexplicithandles17