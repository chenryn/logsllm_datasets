服务网格化：微服务的牧人？
Matt Klein, Lyft
  在过去的5到10年中，微服务在分布式系统设计和运营中风靡一时。曾经只有大型的互联网公司才有资格谈论的基础设施，但现在诸如“不可变容器供应和调度”、“持续集成和部署”、“分散控制”和“多语言实现”之类的词汇普通人就会耳熟能详。确实，微服务架构确实允许大型开发团队以更灵活的方式运行。然而，经常被忽视的是大型互联网公司通常在开发和运营方面投入数百人年的严酷现实，以使分布式架构在实践中运行良好。可靠性工程师不知道如何解决在试图摆脱我们的单片应用程序并在实践中部署这样的架构时出现的无数操作问题。服务如何找到并相互通信？如何观察和调试分布式服务？如何打包和部署服务？可能发生什么样的复杂故障情况？
正如微服务的实践者很快意识到的那样，迁移到分布式体系结构时出现的大多数操作问题最终都基于两个领域：网络和可观察性。与单个整体应用程序相比，网络和调试一组相互交织的分布式服务只是一个数量级较大的问题。这一事实最终对可靠性工程师意味着什么？一个巨大的混乱，难以可靠地操作。在过去的几年里，一个新的这里说的“新”是一种非常广义的新。在计算领域，没有什么是新事物。服务网格化的起源可以一直追溯到大型机时代的企业服务总线（ESB）。计算模型已经出现，这是最常见的称为服务网格。服务网格通过创建应用程序通信的通用基板，为试图构建和操作微服务体系结构的人员提供了缓期执行。开发人员可以使用任何语言编写应用程序，但基本上不知道分布式网络是如何实现、检测以及最重要的是可靠操作的。本章探讨引入服务网格背后的原因，以及微服务开发人员和可靠性工程师的体系结构优势。本章最后对在 Lyft 部署基于 Envoy 的服务网格进行案例研究。
准备好摆脱全家桶了吗？
  在任何人开始考虑微服务之前，他们通常已经有一个由以下部分组成的功能单一的应用程序，如#monolithic_architecture所示：
互联网负载均衡器（例如亚马逊 Web 服务 [AWS] 的弹性负载平衡器 [ELB]）无状态应用程序堆栈（例如 PHP 或 Node.js）
数据库（例如，MongoDB 或 MySQL）
单体架构。
非常多著名的互联网应用程序（例如 Twitter、Salesforce、Snapchat 和许多其他应用程序）变得非常大，且能处理高流量负载。为什么？因为与完全分布式的体系结构相比，理解和操作这样的体系结构要简单得多。本章没有详细说明为什么公司最终几乎总是从单体架构切换到微服务架构；市面上已经有很多关于这个话题的著作。马丁·福勒的著作（https://martinfowler.com/microservices/）可能是这个主题中最著名的。 但是，从网络和可观察性的角度来看，讨论一些运维问题很有启发性，即使对这种非常基本的体系结构，这些运维问题也很明显。现在让我们来看一些：
缺乏网络可见性缺乏网络可见性
在#monolithic_architecture中，客户端需要与负载均衡器、负载均衡器与应用程序，以及应用程序与数据库进行通信。因此，实际上，简单单体已经是具有网络和可观察性复杂性的分布式应用程序。如果出现问题，工程师如何确定问题的根源？他们将依赖于任何可用的统计信息、日志记录和跟踪。奇怪的是，调试工具和数据很少，难以访问，并且在所有组件中各不相同，使得诊断变得极其困难。
应用程序层连接处理效率低下
许多单体 Web 应用程序开发使用的语言，往往开发起来非常高效，但不一定性能良好，例如 Ruby、Python 和 Node.js。这些语言通常不能很好地处理异步计算，特别是网络延迟。随着请求量的增加，网络停滞的可能性也会增加。当出现停滞时，如果没有适当的异步处理能力，这些平台可能会很快变得不堪重负并失效。此问题的典型解决方案是在应用程序旁边安装高性能代理（如 HAProxy）。这种模式已经使用了很多年了，从某种意义上说，它可以被认为是全服务网格的前身。即使采用这种相对“简单”的体系结构，从业者也已经看到操作和可靠性方面的痛苦，这主要是由于网络问题和可观察性（或相当缺乏）。当决定从整体转向分布式微服务体系结构（通常有充分理由）时，已经出现的新兴网络和可观察性问题几乎立即变得更糟。事实上，由于网络可靠性问题，微服务体系结构部署被中止的情况并不少见。如果没有适当的提示，开发人员就不了解网络或如何调试网络，于是他们不信任它。于是，开发人员通常回头往单体应用添加功能，从而保留运行一些“非关键”微服务。这是一个恶性循环。从某种意义上说，使网络可靠、透明且易于操作是成功部署分布式体系结构的必要要求。
微服务网络的当前状态
  在这一点上，退一步看看业界微服务网络的现状是有用的。在较高级别，涉及以下组件：
语言和框架语言和框架
几乎所有的现代应用程序都是跨语言（多语言的）。现在很少能找到能够将使用的语言集限制为只有一两种语言的组织。相反，更常见的是找到用 Ruby、PHP 或 Node.js 编写的单体应用，而服务是用 Python、Go、Java 和C++ 编写的。每种语言都具有完全不同的性能特征，以及一个或多个构建应用程序的框架（例如通过 Python 和 gRPC 中的 Flask 进行 REST 调用）。
协议
现代分布式应用程序由许多与实时远程过程调用 （RPC） （例如 REST、gRPC、HTTP/1.1 和 HTTP/2）、消息传递（例如 Kafka 和 Kinesis）、缓存（例如 Redis 和 memcached）和数据库（例如 MySQL 和 MongoDB）。
基础架构基础架构
在整个行业中，我们现在看到部署在基础设施即服务（IaaS 如 AWS 弹性计算云 [EC2] 和 Google 计算引擎 [GCE]）、容器即服务 （CaaS 如 AWS 弹性容器服务 [ECS] 和 Google Kubernetes 引擎 [GKE]）以及“无服务器”或“功能即服务”（FaaS 如 AWS Lambda 和 Google 云函数）。
负载平衡器
负载均衡器是分布式体系结构的主要组件。部署的解决方案范围从 F5 和 Juniper 网络的传统硬件设备，以及同一供应商的虚拟设备，以及 AWS ELB 和 Google 云平台 （GCP）的内部负载均衡器（ILB）等云解决方案。
服务发现
分布式应用程序需要相互查找。从域名系统（DNS）到完全一致的解决方案（如 Consul）等，各种机制的复杂性不一。
分布式系统最佳实践分布式系统最佳实践
在理论层面上，微服务从业者被告知，他们需要采用最佳实践，例如用二进制指数退避和对于电路中断、带宽限制和超时的重试。这些最佳实践的实际实现通常各不相同或完全缺失。
身份验证和授权
尽管大多数 Internet 体系结构通过传输层安全（TLS）和某些类型的边缘身份验证使用边缘加密，但实现差异很大，从专有到 OAuth。对于服务到服务身份验证和授权，许多部署不执行任何操作。另一些使用 HTTP 基本身份验证，而一小部分具有极其复杂的系统，这些系统使用双向 TLS、集中式证书颁发机构以及基于角色的访问控制（RBAC）。
网络库网络库
试图将所有这些内容拼接在一起是各种语言的流程内网络库。这些库的复杂性范围从简单的 HTTP 请求和响应库（如 Python 请求和 PHP cURL 库），到 10 多种语言的 gRPC 库，到专门为 Java 虚拟机（JVM）设计的（但功能非常丰富的）Finagle。每个库都尝试使前面描述的一个或多个网络功能透明化。流程中库解决方案的一个共同点是升级的痛苦；大型部署可能有数百个服务，通常在每个服务中升级库的唯一方法是完全部署。这是痛苦的，但不会削弱功能升级。但是对于安全问题，所需的部署工作会导致巨大的运维负担。
可观察性
 最终，开发人员和可靠性工程师需要对整个系统进行运维。他们通过日志记录、指标以及（如果幸运的话）分布式跟踪的组合来执行此操作。但是，所有这些组件通常输出日志、指标和跟踪的不同组合和不同的格式（有时干脆无法找到！）试图将所有这些不同系统的输出拼凑成一个连贯的调试和操作故事的认知负载是极其困难的，有时几乎是不可能的。对于大多数从业者来说，上述所有问题会导致怎样的体验？如导言所述，一场巨大的混乱。另一个重要的启示是，尽管所有这些列出的项目都很重要，但最终最关键的是可观察性。正如我喜欢说的：可观察性、可观察性、可观察性！如果不对系统进行简单和一致的反省，调试不可避免的问题几乎是不可能的。这直接导致大众有这样的看法，即分布式网络对于应用程序开发是不可靠的。要成功推出分布式微服务，所有已部署的服务都可以应该提供一致的功能和可观察性，这绝对至关重要。作为一个行业，我们可以做得更好吗？
服务网格来救援
  面对上一节中介绍的令人困惑的网络环境，开发人员和 SRE 工程师如何控制并将理智带回微服务应用程序开发？他们有两个真正的选择：
选项 1
限制组织中使用的语言数，并引入极其复杂的库，以一致的方式封装所有必需的功能。这是一个非常昂贵的选择，但许多最大的互联网公司（包括谷歌、Facebook 和 Twitter）已经成功地使用它（我在开始时曾提到几百人年的项目，这些年来已经罕见）。选项 2
为每个应用程序部署类似“边三轮”的高性能代理，如#service_mesh_architecture所示。此代理以单一语言编写一次，封装了所有必需的功能，旨在使网络对应用程序透明，无论使用哪种语言编写。当每个应用程序都部署在一个边三轮代理旁边时，应用程序只与代理通信，而代理负责发现和相互通信。这样的体系结构现在就是网格，确切地说，是服务网格。
服务网格体系结构
边三轮代理的好处
最初，边三轮代理体系结构的好处是违反直觉的。如何在系统中引入全新的组件，提高开发人员的效率及整体可靠性？事实上，这种方法的好处很多，包括：
进程外体系结构
边三轮代理是一个独立的服务器，这意味着可以一次性实现各种复杂的功能。然后，您可以将这些功能与任何应用程序语言一起使用，无论是 Java、Go、Python 还是 Haskell。
高性能代码库高性能代码库
由于是独立的服务器，因此理应通过尽可能高性能的方式（比如 C/C++）来实现代理。以性能较差的语言编写的应用程序仍然能够访问高性能接口（稍后介绍这带来的影响）。
可插拔性
可以使代理成为热拔插的，以便它支持不同的协议和功能。例如，除了 HTTP 之外，代理还可以支持 Redis 和 MongoDB。可以将连接和/或请求级全局速率限制添加到 HTTP 和 MongoDB 流量。只要一个代码库就能使得支持各种协议和方案成为可能。
高级协议支持
与许多语言和框架相比，边三轮模式将更快地支持最先进的协议。例如，HTTP/2、QUIC 和 TLS 1.3。