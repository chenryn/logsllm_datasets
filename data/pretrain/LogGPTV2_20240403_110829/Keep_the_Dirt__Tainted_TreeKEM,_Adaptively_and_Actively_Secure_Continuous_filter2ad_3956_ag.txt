[17] T. Perrin and M. Marlinspike, “The Double Ratchet Algorithm,”
https://signal.org/docs/speciﬁcations/doubleratchet/, 2016.
[18] M. Bellare, A. C. Singh, J. Jaeger, M. Nyayapati, and I. Stepanovs,
“Ratcheted encryption and key exchange: The security of messaging,”
in CRYPTO 2017, Part III, ser. LNCS, J. Katz and H. Shacham, Eds.,
vol. 10403. Springer, Heidelberg, Aug. 2017, pp. 619–650.
[19] J. Jaeger and I. Stepanovs, “Optimal channel security against ﬁne-
grained state compromise: The safety of messaging,” in CRYPTO 2018,
Part I, ser. LNCS, H. Shacham and A. Boldyreva, Eds., vol. 10991.
Springer, Heidelberg, Aug. 2018, pp. 33–62.
[20] B. Poettering and P. R¨osler, “Towards bidirectional ratcheted key
exchange,” in CRYPTO 2018, Part I, ser. LNCS, H. Shacham and
A. Boldyreva, Eds., vol. 10991. Springer, Heidelberg, Aug. 2018, pp.
3–32.
[21] Matthew A. Weidner, “Group Messaging for Secure Asynchronous
Collaboration,” Master’s thesis, University of Cambridge, June 2019.
[22] D. Rybski, S. V. Buldyrev, S. Havlin, F. Liljeros, and H. A. Makse,
“Scaling laws of human interaction activity,” Proceedings of
the
National Academy of Sciences, vol. 106, no. 31, pp. 12 640–12 645,
2009. [Online]. Available: https://www.pnas.org/content/106/31/12640
[23] X. Gabaix, “Zipf’s law for cities: An explanation,” The Quarterly
Journal of Economics, vol. 114, no. 3, pp. 739–7675, 1999. [Online].
Available: https://doi.org/10.1162/003355399556133
[24] C. H. Bennett, “Time/space trade-offs for reversible computation,” SIAM
J. Comput., vol. 18, no. 4, pp. 766–776, 1989.
[25] G. Fuchsbauer, C. Kamath, K. Klein, and K. Pietrzak, “Adaptively secure
proxy re-encryption,” in PKC 2019, Part II, ser. LNCS, D. Lin and
K. Sako, Eds., vol. 11443. Springer, Heidelberg, Apr. 2019, pp. 317–
346.
A. Notation
APPENDIX
Throughout the remaining document we will use the func-
tions child, parents, partner to refer to the child,
parents and partner (the other parent of the child) of any
given node. The function index(ID) returns the leaf ID
has assigned, and get_pk, get_sk, get_tainter the
public key, secret key and tainter ID of a given node re-
spectively. Similarly, the binary functions set_pk(vi, pki),
set_sk(vi, ski) and set_tainter(vi, ID) overwrite the
public key, secret key or tainter ID associated to vi. We
will use the function path to recover the nodes in the
to the root. Further, we use
path of a user
get_members(), get_tree(), get_hash()
to recover
the member list,
tree or transcript hash from a state. To
update one’s view of group state, we use the functions
add_party(ID, pk) to add ID to the leftmost free spot in the
tree; remove_party(ID) to remove ID; update_hash(T )
to update our
transcript hash with the message T ;
init_state(M,T ,H) to initialize our state after join-
(cid:48)
ing; and update_pks_and_tainter(new pks, ID, ID
)
to update the public keys of nodes corresponding to ID, and
changing their tainter ID to ID’. We will need to sample fresh
random seeds to generate new key pairs when refreshing a
path, we do this through gen-seed.
(’s leaf)
B. Path partitions
When updating, a user needs to partition the set of extra
nodes to be refreshed (nodes not on their path with a tainted
ancestor) into paths, so that a single seed can be used to update
each path. Formally, for a user id, we want a set of paths
Pi = {vi,0, . . . , vi,mi} such that every tainted node is in some
path Pi and moreover:
• child(vi,j) = vi,j+1 for j < mi (Pi is a path)
• vi,j (cid:54)= vk,l if i (cid:54)= k for any j, l (each node is only in one
path)
node tainted by id)
• get_tainter(vi,0) = id (the start of each path is a
• ∀i, j : child(vi,mi) (cid:54)= vj,0 (paths are maximal)
• Pi
• child(vi,mi) ∈ Pid ∨ child(vj,mj ) ∈ Pi with i < j
(cid:84) Pid = ∅ (paths are disjoint from main path to root)
(the partition is unique)
• vi,0 < vj,0 if i < j (there is a total ordering on paths)
where Pid is the path from the user’s leaf to the root and
vi < vj if vi is more to the left in a graphical representation
281
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:16:47 UTC from IEEE Xplore.  Restrictions apply. 
of the tree (any total ordering on vertices sufﬁces). We denote
this ordered partition by tainted-by(id). Note that the ﬁrst
ﬁve conditions ensure that the partition contains only the nodes
to be refreshed and that its size is minimal, while the sixth
and seventh conditions guarantee that the partition is unique.
A common ordering of the paths is needed, since when we re-
fresh two paths that “intersect” (such that child(vi,mi) ∈ Pj,
as the blue and red paths in the image below for example), the
node secret in the “upper” path (the red path in this example)
needs to be encrypted under the new public key of the node in
the “lower” path (the new blue node) to achieve PCS. Thus,
in this case, the blue path will need to be refreshed before
the red one when processing the update. In general we will
refresh paths right to left, i.e. Pi will be refreshed after Pj if
i < j.
1) TTKEM Dynamics in detail: In this section we provide
a more detailed description of the group operations together
with pseudo-code for them.
The initiator of a group operation creates a message T which
contains all information needed by the other group members
to process it (though different members might only need to
retrieve a part of T for performing the update) and in case of
an Add also a welcome message W for the new member. The
message T contains the following ﬁelds:
• Tsender - ID of the sender
• Top - type of operation (remove/add/update)
• Tnew seeds - vector of ciphertexts which contains the en-
crypted seeds under the appropriate keys of all refreshed
nodes
• Tnew pks - vector of new public keys (derived from the
new seeds) for all refreshed nodes
• TH - hash-transcript
If the operation is a removal, the ID of the party removed will
also be included in Top. Similarly, in Add messages, Top will
contain the ID of the party added, together with the public
key used to add him. A welcome message W would also
contain the type of operation (welcome) and the sender ID,
but additionally include:
• Wseed - an encryption of the child node’s seed
• WT - the current tree structure, with public keys
• WM - current list of group members
• WH - current hash-transcript of the group
A new member should also be communicated the current
symmetric epoch key used to communicate text messages. As
this is not strictly part of the GCKA we ignore it for simplicity.
In order to refresh the node secrets we use the function
refresh(γ, ID, T ), which takes a user’s state, a user in the group
and a message T . It generates new secrets for all the nodes
in that user’s path to the root as well as all nodes tainted
by them, update γ accordingly and store their encryptions in
Tnew seeds. We use the pointer me to refer to the identity of
the user sending the protocol message.
We use the function refresh-node that inputs a user local
state γ, a node v, a seed ∆ and message T . It updates the
information related to v in the state γ using ∆ to derive the
new public and secret key and store the public key in Tnew pks.
refresh (γ, ID, T )
P0 ← γ.path(ID)
{P1, . . . , Pn} ← γ.tainted-by(ID) #refresh all
paths from tainted nodes to root
for i = n, . . . , 0 do
vi,0, . . . , vi,m ← Pi
{∆i,0, . . . ∆i,m} ←
expand(gen-seed(), m + 1)
for p ∈ parents(vi,0) do
#encrypt ﬁrst to parents of 1st node
if p (cid:54)= ⊥ then
Tnew seeds.insert(Encγ.get_pk(p)(∆i,0))
refresh-node(γ, vi,0, ∆i,0, T )
for j = 1, . . . , m do
Tnew seeds.insert(Encγ.get_pk(γ.partner(vi,j−1))(∆i,j))
refresh-node(γ, vi,j, ∆i,j, T )
refresh-node (γ, v, ∆, T )
if v = vroot then
else
γ.set_sk(vroot, ∆)
(sk, pk) ← Gen(H2(∆))
γ.set_pk(v, pk);
γ.set_tainter(v, me)
Tnew pks.insert(pk)
if v ∈ γ.path(ID) then
γ.set_sk(v, sk)
(a)
(b)
Fig. 9: Sample Add operation: (a) illustrates the state of the tree before Alice
adds Frank (6th node) after which it turns into (b).
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:16:47 UTC from IEEE Xplore.  Restrictions apply. 
282
add (γ, ID, pk)
γ(cid:48) ← γ
γ(cid:48).add_party(ID, pk)
{v0, . . . , vd} ← γ(cid:48).path(ID)
sk ← γ(cid:48).get_sk(γ(cid:48).index(me))
r ← $; ∆ ← h(sk, r)
{∆0, . . . , ∆d} ← expand(∆, d + 1)
refresh-node(γ(cid:48), v0, ∆0, T )
for i = 1, . . . , d do
u ← γ.partner(vi−1)
if u (cid:54)= ⊥ then
rem (γ, ID)
req me (cid:54)= ID
Top = (rem, ID)
Tsender = me
TH = γ.get_hash()
γ(cid:48) ← γ
refresh(γ(cid:48), ID, T )
γ(cid:48).remove_party(ID)
γ(cid:48).update_hash(T )
return(γ(cid:48), T )
Tnew seeds.insert(Encγ.get_pk(u)∆i)
refresh-node(γ, vi, ∆i, T )
Top ← (add, ID, pk)
Tsender ← me
TH ← γ.get_hash()
γ(cid:48).update_hash(T )
Wop ← welcome
Wsender ← me
Wseed ← Encpk(∆)
WT ← γ(cid:48).get_tree()
WH ← γ.get_hash()
WM ← γ.get_members()
return(γ(cid:48), W, T )
upd (γ)
Top = upd
Tsender = me
TH = γ.get_hash()
γ(cid:48) ← γ
refresh(γ(cid:48), me, T )
γ(cid:48).update_hash(T )
return(γ(cid:48), T )
For our process algorithm we use the algorithms get enc,
update-path and proc-refresh as subroutines. The function
get enc inputs a user local state γ, a node v0, a set of paths Pi
and the set of encryptions received from the Update/Remove
message, and returns the encryption corresponding to v0.
Given path P, seed ∆, and update author ID, update-path
updates P using ∆ as seed. Finally, proc-refresh takes a user
(me) local state γ, the set of encryptions received from the
Update/Remove message Tnew seeds, the id ID of the user
that made the update/was removed, and the user sender that
made the operation (distinct from ID if the operation was a
Remove), and it updates all the secret keys in the path from
the me leaf to vroot.
update-path (γ, P, ∆, ID)
for v ∈ P do
if v = vroot then
else
γ.set_sk(vroot, ∆)
(sk, ) ← Gen(H2(∆))
∆ ← H1(∆)
γ.set_sk(v, sk)
proc-refresh (γ, Tnew seeds, ID, sender)
P0 ← γ.path(ID)
{P1, . . . , Pn} ← γ.tainted-by(ID) #refresh all
paths from tainted nodes to root
for i = n, . . . , 0 do
{v0, . . . , vn} ←
intersection(Pi, γ.path(me))
enc ← get enc(γ, v0, P0, Tnew seeds)
(pl, pr) ← γ.parents(v0)
if pl (cid:54)= ⊥ ∧ pl ∈ γ.path(me) then
sk ← γ.get_sk(pl)
sk ← γ.get_sk(pr)
else
update-path(γ,{v0, . . . , vn}, Decsk(enc), sender)
Fig. 11: Alice removes Frank (dotted) and in the process has to update his
tainted nodes. Old state is again showed in gray.
H
Fig. 10: A sample Update operation: Alice added Eve to the group which
resulted in the tainted nodes (ﬁlled). Alice decided to later update herself.
The state of the tree before the Update is in a lighter shade.
283
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:16:47 UTC from IEEE Xplore.  Restrictions apply. 
proc-refresh(γ, Tnew keys, Tsender, Tsender)
γ.update_pks_and_tainter(Tnew pks, Tsender, Tsender)
if ID (cid:54)= me then
if Top = (rem, ID) then
proc-refresh(γ, Tnew keys, ID, Tsender)
γ.update_pks_and_tainter(Tnew pks, ID, Tsender)
γ.remove_party(ID)
γ ← ; γ(cid:48) ← 
# removed user cleans its states.
else
if Top = (add, ID, pk) ∧ ID (cid:54)= me then
γ.add_party(ID, pk)
proc-refresh(γ, Tnew keys, ID, Tsender)
γ.update_pks_and_tainter(Tnew pks, ID, Tsender)
process (γ, T )
req TH = γ.get_hash()
if Top = upd then
if Top = welcome then
γ.init_state(TM, TT , TH)
update-path(γ,{γ.index(me), . . . , vroot},
Decsk(Tseed), Tsender)
if Top = conﬁrm then
γ ← γ(cid:48); γ(cid:48) ← 
if Top = reject then
γ(cid:48) ← 
if Top /∈ {conﬁrm, reject} then
γ.update_hash(T )
return(γ, key(γ))
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:16:47 UTC from IEEE Xplore.  Restrictions apply. 
284