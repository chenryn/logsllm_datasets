以下是优化后的文本，使其更加清晰、连贯和专业：

---

### 参考文献

[1] [Online]. Available: <http://marc.info/?l-openbsd-isc&m=118296441702631>, 2007.

[2] DE VRIES. Understanding the Detailed Architecture of AMD’s 64-bit Core. [Online]. Available: <http://www.chip-architect.com/news/2003-09-21-Detailed-Architecture-of-AMDs-64bit-Core.html>.

[3] DUFLOT, L. CPU Bugs, CPU Backdoors and Consequences on Security. In ESORICS (2008), pp. 580–599.

[4] E. G. SUH et al. AEGIS: Architecture for Tamper-Evident and Tamper-Resistant Processing. In International Conference on Supercomputing (2003), pp. 160–171.

[5] FAVOR, J. G. Risc86 Instruction Set, Jan. 1, 2002. US Patent 6,336,178.

[6] FUDZILLA STAFF. AMD Denies Existence of NSA Backdoor. [Online]. Available: <http://www.fudzilla.com/32120-amd-denies-existence-of-nsa-backdoor>.

[7] G. A. REIS et al. Configurable Transient Fault Detection via Dynamic Binary Translation. In Workshop on Architectural Reliability (2006).

[8] HABIB, S. Microprogrammed Enhancements to Higher Level Languages - An Overview. In Workshop on Microprogramming (1974), pp. 80–84.

[9] INTEL CORPORATION. i960 VH Processor Developer’s Manual, 1998.

[10] INTEL CORPORATION. Pentium® Pro Processor Specification Update, 2016.

[11] JACOB, B., NG, S., AND WANG, D. Memory Systems: Cache, DRAM, Disk. Morgan Kaufmann Publishers Inc., 2007.

[12] JONES, L. H. A Survey of Current Work in Microprogramming. Computer 8, 8 (Aug. 1975), pp. 33–38.

[13] K. SHIRRIFF. Reverse Engineering the ARM1 Processor’s Microinstructions. [Online]. Available: <http://www.righto.com/2016/02/reverse-engineering-arm1-processors.html>.

[14] KOCHER, P. C. Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and Other Systems. In CRYPTO (1996), pp. 104–113.

[15] LIBSODIUM. [Online]. Available: <https://github.com/jedisct1/libsodium/tree/master/src/libsodium/crypto_core/curve25519/ref10>.

[16] M. HICKS et al. SPECS: A Lightweight Runtime Mechanism for Protecting Software from Security-Critical Processor Bugs. In ASPLOS (2015), pp. 517–529.

[17] M. MAAS et al. PHANTOM: Practical Oblivious Computation in a Secure Processor. In CCS (2013), pp. 311–324.

[18] MAISURADZE, G., BACKES, M., AND ROSSOW, C. Dachshund: Digging for and Securing (Non-)Blinded Constants in JIT Code. In Symposium on Network and Distributed System Security (NDSS) (2017).

[19] MCGRATH, K. J., AND PICKETT, J. K. Microcode Patch Device, Aug. 27, 2002. US Patent 6,438,664.

[20] MEIXNER, A., AND SORIN, D. J. Detouring: Translating Software to Circumvent Hard Faults in Simple Cores. In IEEE/IFIP International Conference on Dependable Systems and Networks, DSN (2008), pp. 80–89.

[21] MELVIN, S., AND PATT, Y. SPAM: A Microcode Based Tool for Tracing Operating System Events. SIGMICRO Newsl. 19, 1-2 (June 1988), pp. 58–59.

[22] MICROPROGRAMS. [Online]. Available: <https://github.com/RUB-SysSec/Microcode>.

[23] RAUSCHER, T. G., AND ADAMS, P. M. Microprogramming: A Tutorial and Survey of Recent Developments. IEEE Trans. Computers 29, 1 (1980), pp. 2–20.

[24] RUTKOWSKA, J. Why Do I Miss Microsoft BitLocker? [Online]. Available: <http://theinvisiblethings.blogspot.de/2009/01/why-do-i-miss-microsoft-bitlocker.html>, 2009.

[25] RUTKOWSKA, J. Intel x86 Considered Harmful. [Online]. Available: <https://blog.invisiblethings.org/2015/10/27/x86-harmful.html>, 2015.

[26] S. E. QUADIR et al. A Survey on Chip to System Reverse Engineering. J. Emerg. Technol. Comput. Syst. 13, 1 (Apr. 2016), pp. 6:1–6:34.

[27] S. GHANDALI et al. A Design Methodology for Stealthy Parametric Trojans and Its Application to Bug Attacks. In CHES (2016), pp. 625–647.

[28] S. NARAYANASAMY et al. Patching Processor Design Errors. In International Conference on Computer Design ICCD (2006), pp. 491–498.

[29] S. R. SARANGI et al. Patching Processor Design Errors with Programmable Hardware. IEEE Micro 27, 1 (2007), pp. 12–25.

[30] SCHAUMONT, P. R. A Practical Introduction to Hardware/Software Codesign. Springer, 2010.

[31] SINTSOV, A. Jit-spray Attacks & Advanced Shellcode. HITBSecConf Amsterdam (2010).

[32] SKOROBOGATOV, S. P. Semi-Invasive Attacks – A New Approach to Hardware Security Analysis. PhD thesis, University of Cambridge, 2005.

[33] SMOTHERMAN, M. A Brief History of Microprogramming. [Online]. Available: <http://ed-thelen.org/comp-hist/MicroprogrammingABriefHistoryOf.pdf>, 2012.

[34] STALLINGS, W. Computer Organization and Architecture: Designing for Performance (7th Edition). Prentice-Hall, Inc., 2005.

[35] SUN MICROSYSTEMS, INC. OpenSPARC Overview. [Online]. Available: <http://www.oracle.com/technetwork/systems/opensparc/index.html>.

[36] T. ARONS et al. Formal Verification of Backward Compatibility of Microcode. In CAV (2005), pp. 185–198.

[37] T. KAUFMANN et al. When Constant-Time Source Yields Variable-Time Binary: Exploiting Curve25519-donna Built with MSVC 2015. In CANS (2016), pp. 573–582.

[38] TEHRANIPOOR, M., AND KOUSHANFAR, F. A Survey of Hardware Trojan Taxonomy and Detection. IEEE Des. Test 27, 1 (Jan. 2010), pp. 10–25.

[39] TRIULZI, A. Pneumonia, Shardan, Antibiotics and Nasty MOV: A Dead Hand’s Tale. [Online]. Available: <https://www.troopers.de/events/troopers15/449-pneumonia-shardan-antibiotics-and-nasty-mov-a-dead-hands-tale/>, 2015.

[40] TRIULZI, A. The Chimaera Processor. [Online]. Available: <https://www.troopers.de/events/troopers16/655-the-chimaera-processor/>, 2016.

[41] WILKES, M. V. The Best Way to Design an Automatic Calculating Machine. In The Early British Computer Conferences. MIT Press, 1989, pp. 182–184.

[42] WOLFE, A. For Intel, It's a Case of FPU All Over Again. EE-Times [Online]. Available: <http://www.fool.com/EETimes/1997/EETimes970516d.htm>, 1997.

### 附录

#### A.1 微代码规范

如第5.1节所述，我们设计了自动化测试用例来记录微代码ROM中用于实现特定x86指令的三元组位置。然后我们清除了由测试环境引起的影响，并将所有向量路径指令的热图结合起来。表4显示了结果的一部分。

| ROM 地址        | 向量指令         |
|-----------------|------------------|
| 0x900 - 0x913   | -                |
| 0x900 - 0x913   | -                |
| 0x914 - 0x917   | rep cmps mem8    |
| 0x918 - 0x95f   | -                |
| 0x960           | mul mem16        |
| 0x961           | idiv             |
| 0x962           | mul reg16        |
| 0x963           | -                |
| 0x964           | imul mem16       |
| 0x965           | bound            |
| 0x966           | imul reg16       |
| 0x967           | -                |
| 0x968           | bts imm          |
| 0x969 - 0x971   | -                |
| 0x972 - 0x973   | div              |
| 0x974 - 0x975   | -                |
| 0x976 - 0x977   | idiv             |
| 0x978           | -                |
| 0x979 - 0x97a   | idiv             |
| 0x97b - 0x9a7   | -                |
| 0x9a8           | mfence           |
| 0x9a9 - 0x9ad   | -                |
| 0x9ae           | -                |
| 0x9af - 0x9ff   | -                |

**表4：截断的微代码ROM热图**

在第5.2节中，我们介绍了微代码指令集结构，这是我们的逆向工程工作的主要成果之一。我们发现了四个操作类别，这些类别将不同领域的操作分开。操作类型决定了具体的操作，如加法或乘法。我们的操作类型及其编码列于表5。

| 操作类别 | 操作类型 | 编码          |
|----------|----------|---------------|
| RegOp    | add      | 000000000     |
| RegOp    | or       | 000000001     |
| RegOp    | adc      | 000000010     |
| RegOp    | sbb      | 000000011     |
| RegOp    | and      | 000000100     |
| RegOp    | sub      | 000000101     |
| RegOp    | xor      | 000000110     |
| RegOp    | cmp      | 000000111     |
| RegOp    | test     | 000001000     |
| RegOp    | rll      | 000010000     |
| RegOp    | rrl      | 000010001     |
| RegOp    | sll      | 000010100     |
| RegOp    | srl      | 000010101     |
| RegOp    | mov      | 001100000     |
| RegOp    | mul      | 001110000     |
| RegOp    | imul     | 001110001     |
| SpecOp   | bswap    | 111000000     |
| SpecOp   | not      | 111110101     |
| LdOp     | ld       | 001000000     |
| StOp     | st       | 0101CCCCC     |

**表5：微代码操作类型集合**

微指令结构提供了两个专用的寄存器字段。通过启用寄存器模式，可以解锁一个额外的寄存器字段，该字段替换了16位立即数字段。寄存器字段可以编码多个寄存器，包括x86通用寄存器和微代码寄存器。微代码寄存器不能通过x86指令访问。微代码寄存器的内容仅在一条宏指令解码期间是持久的。大多数微代码寄存器作为立即数值的一般用途空间。然而，存在一些特殊的微代码寄存器，它们持有下一个解码程序计数器（pcd）或始终读为零（zerod）。我们在表6中列出了带有助记符和编码的微代码寄存器。

| 大小 | 编码 | 助记符  |
|------|------|---------|
| 00   | 0000 | al      |
| 00   | 0001 | cl      |
| 00   | 0010 | dl      |
| 00   | 0011 | bl      |
| 00   | 0100 | ah      |
| 00   | 0101 | ch      |
| 00   | 0110 | dh      |
| 00   | 0111 | bh      |
| 00   | 1000 | t1l     |
| 00   | 1001 | t2l     |
| 00   | 1010 | t3l     |
| 00   | 1011 | t4l     |
| 00   | 1100 | t1h     |
| 00   | 1101 | t2h     |
| 00   | 1110 | t3h     |
| 00   | 1111 | t4h     |
| 00   | 1111 | regmb   |
| 00   | 1111 | regb    |
| 00   | 1111 | pcb     |
| 00   | 1111 | zerob   |
| 01   | 0000 | ax      |
| 01   | 0001 | cx      |
| 01   | 0010 | dx      |
| 01   | 0011 | bx      |
| 01   | 0100 | sp      |
| 01   | 0101 | bp      |
| 01   | 0110 | si      |
| 01   | 0111 | di      |
| 01   | 1000 | t1w     |
| 01   | 1001 | t2w     |
| 01   | 1010 | t3w     |
| 01   | 1011 | t4w     |
| 01   | 1100 | t5w     |
| 01   | 1101 | t6w     |
| 01   | 1110 | t7w     |
| 01   | 1111 | t8w     |
| 01   | 1111 | regmw   |
| 01   | 1111 | regw    |
| 01   | 1111 | pcw     |
| 01   | 1111 | zerow   |
| 10   | 0000 | eax     |
| 10   | 0001 | ecx     |
| 10   | 0010 | edx     |
| 10   | 0011 | ebx     |
| 10   | 0100 | esp     |
| 10   | 0101 | ebp     |
| 10   | 0110 | esi     |
| 10   | 0111 | edi     |
| 10   | 1000 | t1d     |
| 10   | 1001 | t2d     |
| 10   | 1010 | t3d     |
| 10   | 1011 | t4d     |
| 10   | 1100 | t5d     |
| 10   | 1101 | t6d     |
| 10   | 1110 | t7d     |
| 10   | 1111 | t8d     |
| 10   | 1111 | regmd   |
| 10   | 1111 | regd    |
| 10   | 1111 | pcd     |
| 10   | 1111 | zerod   |
| 11   | 0000 | rax     |
| 11   | 0001 | rcx     |
| 11   | 0010 | rdx     |
| 11   | 0011 | rbx     |
| 11   | 0100 | rsp     |
| 11   | 0101 | rbp     |
| 11   | 0110 | rsi     |

**表6：微代码寄存器列表**

---

希望这能帮助你更好地组织和呈现你的内容。