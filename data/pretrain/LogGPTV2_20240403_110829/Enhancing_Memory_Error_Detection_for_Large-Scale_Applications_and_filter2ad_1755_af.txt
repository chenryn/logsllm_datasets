280,279
7,184
1,788,698
1,805,388
1,213,057
535,144
975,416
ASAN
1.23x
1.06x
1.73x
1.02x
57.57x
MEDS
21.73x
8.46x
2.21x
1.94x
7,680.44x
TABLE VIII: The number of system calls invoked while running
benchmarks
App.
Chrome
Firefox
Apache
Nginx
OpenSSL
Baseline
Memory Usage ASAN
Overhead
MEDS
HS
H
HSG
83% 110% 116%
111%
95% 130% 136%
128%
44%
74%
82%
98%
78% 292% 301%
57% 367% 409% 432%
58%
733MB
725MB
217KB
195KB
339KB
TABLE IX: Physical memory uses of MEDS, along with the baseline
and ASAN for comparison. Overall, on average MEDS uses physical
memory 218% more than the baseline, and it uses 68% more than
ASAN.
it is a reasonable cost of MEDS’s enhanced security services,
in terms of detectability.
immense virtual address space.
Physical Memory. MEDS imposes more physical memory
uses because it keeps extra metadata for shadow memory as
well as page-alias mapping information. As shown in Table IX,
MEDS-H, HS, and HSG imposed 133%, 200%, and 212% more
physical memory uses on average than the baseline, respectively.
In particular, while MEDS imposed 432% in OpenSSL, and
301% in Apache, it imposed 109% on average for the rest
of four applications. This is because all memory allocations
in OpenSSL were small sized allocations (i.e., from 8 to
32 Byte) and MEDS appends 8 Byte of per-object metadata to
keep aliasing information. Also, OpenSSL does not deallocate
memory objects during the evaluation. Thus, corresponding
shadow memory pages are mapped to physical memory pages.
This runtime characteristic was also captured in TLB misses
in Table VII—OpenSSL incurred the highest TLB misses as it
intensely stretches virtual address space. On the contrary, ASAN
imposed 95% more on average than the base line, because
ASAN actually commits physical memory space for the redzone
as well as the quarantine zone. We believe this demonstrates the
effectiveness of our page aliasing mechanism in that MEDS does
not impose impractical physical memory uses while utilizing
VII. DISCUSSION
Potential Use-cases. Throughout this paper, we tried to neu-
tralize use-cases of MEDS as we believe MEDS’s contribution
is general in enhancing memory error detection capability. One
specific use-cases would be in deploying MEDS for mitigating
memory corruption attacks for large scale applications. Since
MEDS indeed meets compatibility requirements (as it can
run large scale programs including Chrome, Firefox, Nginx,
and Apache) and enhances detection capability compared
to other detection tools, it would be a good fit for these
cases especially focusing on detection itself. However, the
performance overheads that MEDS introduces can be an issue,
so it may not be suitable for performance critical applications.
The other use-cases of MEDS would be augmenting the
fuzz testing. As we have shown in §VI-C, MEDS significantly
outperforms the state-of-the-art memory error detection tool,
ASAN. Recognizing the importance of fuzz testing, the vast
majority of vendors today employ fuzz testing in their regular
software development cycles with huge computing resources.
For example, Google reported that they are dedicating a cluster
13
of hundreds of virtual machines for fuzzing, which runs around
6,000 Chrome instances simultaneously. Because MEDS is
capable of finding more memory errors than ASAN given the
same computing time, we believe MEDS will be useful not
only saving computing resources for fuzzing, but also notifying
the memory error bugs earlier in their development cycles.
Kernel-Level Support
for Performance Improvements.
This paper focused on keeping the compatibility of MEDS,
particularly without introducing new features in an underlying
operating system, Linux. As shortly mentioned before, the
performance of MEDS can be further improved if it can
leverage a few kernel changes in the future. For example,
when implementing a user-level copy-on-write (COW) (§IV-E),
the kernel can be modified to maintain a special flag for
page aliasing. This would require to add a few additional
flags in mremap() system calls. By doing this, MEDS does
not need to implement relatively expensive user-level COW
mechanisms, reducing runtime overheads of MEDS. As another
example, MEDS has to re-allocate all the list of global objects
at loading time §IV-D. This is because the kernel always
assigns MAP_PRIVATE in memory pages used for global objects,
prohibiting to be used for a page aliasing mechanism. This
redundant allocation phase can be avoided if we can provide
yet another ELF loader in the Linux kernel, which specifies
MAP_SHARED for those memory pages.
VIII. ADDITIONAL RELATED WORK
Pointer-based Memory Error Detection.
Pointer-based
detection techniques keep track of pointer capabilities and
check the validity of memory access based on the capabilities.
Depending on where the capabilities of pointers are stored,
pointer-based detectors can be further classified into fat-
pointer-based and disjoint-metadata-based. CCured [24] is a
representative work for fat-pointer-based approaches where
unsafe (WILD) pointers are extended with its capabilities stored
together with the pointer itself. One drawback of software
fat-pointer-based approaches is that they break the memory
layout compatibility with unprotected code, which requires
special hardware support (e.g., CHERI [36]) to eliminate.
SoftBound [21] is a representative work in disjoint-metadata-
based approach where the capabilities are stored in a dedicated
table. While this approach does not break the memory layout
of objects, accessing metadata is usually more expensive. Intel
MPX [17] is a new hardware-based security feature introduced
in the latest Intel processors, which is essentially a hardware
implementation of SoftBound. There is a couple of works [10]
and [11] which utilizes the pointer-based approach with low
overhead. SGXBound [18] uses 32-bit of pointer values to store
the upper bound of the object, and the upper bound address
stores the lower bound of the object. However, it only utilizes
32-bit of virtual address, since they assume that the applications
run on Intel SGX which has limited memory.
A critical limitation of pointer-based approaches is in its
limited compatibility with C/C++ language features. In order to
function correctly, these approaches must propagate capabilities
correctly between pointers, which is not easy for certain
language features. As a result, they all suffer from backward-
compatibility issues especially for C++ programs. For instance,
CCured only supports limited features of C and the prototype
of SoftBound cannot compile all C benchmarks in the SPEC
CPU benchmark suite, so there is still a long way to go before
they can support large-scale complex software like Chrome
and Firefox. Even commodity features like Intel MPX has
false positives in running Chrome browsers [30]. As this issue
is deeply connected to the difficulty of covering all different
C/C++ syntax use-cases as well as applying optimization for
Intel MPX, it is unclear whether it can be resolved in the near
future.
Memory Error Exploits and Mitigation. Memory errors
(ultimately) will allow attackers to perform arbitrary memory
read and write. Attackers can then leveraging such capabilities
to launch different attacks. For example, a simple stack buffer
overflow bug may allow attackers to overwrite (1) stack content
with malicious shellcode and (2) the return address, leading
to arbitrary code execution when the function returns. Based
on how these capabilities are abused, Szekeres et. al [34]
classify existing attacks into four categories: code corruption
attacks, control-flow hijacking attacks, data-only attacks, and
information leak. For each specific exploit strategy, a set of
corresponding mitigation mechanisms are then developed. For
instance, code integrity measurement (e.g., code signing) [3]
and data execution prevention (DEP) [2] is developed to defeat
code corruption attacks. And a large number of techniques
have been proposed to prevent control-flow hijacking attacks,
including Stack cookie [8], shadow stack [9], control-flow
integrity (CFI) [1], vtable pointer integrity [39], and code
pointer integrity [19]. The problem with mitigation techniques
is that arbitrary read and write capability is too powerful that
it usually allows attackers to find a new way to launch the
attacks.
IX. CONCLUSION
This paper presents MEDS to enhance the detectability of
memory errors. MEDS achieves this via utilizing the 64-bit
virtual address space to approximate the infinite gap and infinite
heap. A novel allocator MEDSALLOC uses page-aliasing
scheme to approximate above properties while minimizing
physical memory overhead. Our evaluation on MEDS using
large-scale real-world programs showed that MEDS provides
good compatibility and detectability with moderate runtime
overhead.
ACKNOWLEDGMENT
This research was supported,
in part, by NSF award
CNS-1718997, ONR under grant N00014-17-1-2893, Korea
NRF/MSIT (2017M3C4A7065925), and Samsung Research
Funding & Incubation Center (SRFC-IT1701-05).
REFERENCES
[1] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti. Control-flow integrity.
In ACM Conference on Computer and Communications Security (CCS),
2005.
[2] S. Andersen and V. Abella. Data Execution Prevention: Changes
to Functionality in Microsoft Windows XP Service Pack 2, Part 3:
Memory Protection Technologies. http://technet.microsoft.com/en-us/
library/bb457155.aspx, 2004.
[3] Apple. ios security. https://www.apple.com/la/iphone/business/docs/iOS_
Security_May12.pdf, 2012.
[4] A. Arcangeli, I. Eidus, and C. Wright. Increasing memory density by
using ksm. In Ottawa Linux Symposium (OLS), 2009.
14
[28] P. M. Sanjay Ghemawat. Tcmalloc : Thread-caching malloc. http://goog-
perftools.sourceforge.net/doc/tcmalloc.html, 2014.
[29] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and T. Holz.
Counterfeit Object-oriented Programming: On the difficulty of preventing
code reuse attacks in C++ applications. In IEEE Symposium on Security
and Privacy (Oakland), 2015.
Serebryany.
[30] K.
tion
AddressSanitizerIntelMemoryProtectionExtensions, 2016.
protec-
https://github.com/google/sanitizers/wiki/
extensions.
Address
sanitizer
intel memory
[31] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov. Address-
Sanitizer: A Fast Address Sanity Checker. In USENIX Annual Technical
Conference (ATC), 2012.
[32] F. J. Serna. The info leak era on software exploitation. In Black Hat
USA, 2012.
[33] H. Shacham. The geometry of innocent flesh on the bone: Return-into-libc
without function calls (on the x86). In ACM Conference on Computer
and Communications Security (CCS), 2007.
[34] L. Szekeres, M. Payer, T. Wei, and D. Song. Sok: Eternal war in memory.
In IEEE Symposium on Security and Privacy (Oakland), 2013.
[35] L. Tovalds. mremap feature discussion. https://lkml.org/lkml/2004/1/12/
265, 2004.
[36] R. N. M. Watson, J. Woodruff, P. G. Neumann, S. W. Moore, J. Anderson,
D. Chisnall, N. Dave, B. Davis, K. Gudka, B. Laurie, S. J. Murdoch,
R. Norton, M. Roe, S. Son, and M. Vadera. CHERI: A hybrid capability-
system architecture for scalable software compartmentalization. In IEEE
Symposium on Security and Privacy (Oakland), 2015.
[37] H. Yin, D. Song, M. Egele, C. Kruegel, and E. Kirda. Panorama: capturing
system-wide information flow for malware detection and analysis. In
ACM Conference on Computer and Communications Security (CCS),
2007.
[38] M. Zalewski. American fuzzy lop. http://lcamtuf.coredump.cx/afl/, 2017.
[39] C. Zhang, S. A. Carr, T. Li, Y. Ding, C. Song, M. Payer, and D. Song.
In Annual Network and
VTrust: Regaining trust on virtual calls.
Distributed System Security Symposium (NDSS), 2016.
[5] E. D. Berger and B. G. Zorn. DieHard: Probabilistic Memory Safety
for Unsafe Languages. In ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI), 2006.
[6] T. Boland and P. E. Black. Juliet 1.1 c/c++ and java test suite. Computer,
45(10):0088–90, 2012.
[7] M. Castro, M. Costa, and T. Harris. Securing software by enforcing
data-flow integrity. In USENIX Symposium on Operating Systems Design
and Implementation (OSDI), 2006.
[8] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie, A. Grier,
P. Wagle, Q. Zhang, and H. Hinton. Stackguard: Automatic adaptive
detection and prevention of buffer-overflow attacks. In USENIX Security
Symposium (Security), 1998.
[9] T. H. Dang, P. Maniatis, and D. Wagner. The performance cost of shadow
stacks and stack canaries. In ACM Symposium on Information, Computer
and Communications Security (ASIACCS), 2015.
[10] G. J. Duck and R. H. Yap. Heap bounds protection with low fat
pointers. In Proceedings of the 25th International Conference on Compiler
Construction, pages 132–142. ACM, 2016.
[11] G. J. Duck, R. H. Yap, and L. Cavallaro. Stack bounds protection with
In Symposium on Network and Distributed System
low fat pointers.
Security, 2017.
[12] O. S. Foundation. OpenSSL: Cryptography and SSL/TLS Toolkit. https:
//www.openssl.org/, 2017.
[13] T. A. S. Foundation. ab - Apache HTTP server benchmarking tool.
https://httpd.apache.org/docs/2.4/programs/ab.html, 2017.
[14] Google. Octane - The JavaScript Benchmark Suite for the modern web.
https://developers.google.com/octane/, 2017.
[15] M. Hicks. What is memory safety? http://www.pl-enthusiast.net/2014/
07/21/memory-safety/, 2014.
[16] H. Hu, S. Shinde, S. Adrian, Z. L. Chua, P. Saxena, and Z. Liang. Data-
oriented programming: On the expressiveness of non-control data attacks.
In IEEE Symposium on Security and Privacy (Oakland), 2016.
[17] Intel Corporate. Intel architecture instruction set extensions programming
reference. https://software.intel.com/en-us/intel-architecture-instruction-
set-extensions-programming-reference, 2013.
[18] D. Kuvaiskii, O. Oleksenko, S. Arnautov, B. Trach, P. Bhatotia, P. Felber,
and C. Fetzer. Sgxbounds: Memory safety for shielded execution. In
Proceedings of the Twelfth European Conference on Computer Systems,
pages 205–221. ACM, 2017.
[19] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and D. Song.
Code-pointer integrity. In USENIX Symposium on Operating Systems
Design and Implementation (OSDI), 2014.
[20] Microsoft Support. How to use pageheap.exe in windows xp, windows
2000, and windows server 2003. https://support.microsoft.com/en-us/kb/
286470, 2009.
[21] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic. SoftBound:
highly compatible and complete spatial memory safety for c.
In
ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI), 2009.
[22] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic. CETS: compiler
enforced temporal safety for C. In International Symposium on Memory
Management, 2010.
[23] S. Nagarakatte, M. M. Martin, and S. Zdancewic. Watchdoglite:
Hardware-accelerated compiler-based pointer checking. In Proceedings
of Annual IEEE/ACM International Symposium on Code Generation and
Optimization, page 175. ACM, 2014.
[24] G. C. Necula, J. Condit, M. Harren, S. McPeak, and W. Weimer.
Ccured: type-safe retrofitting of legacy software. ACM Transactions
on Programming Languages and Systems (TOPLAS), 27(3):477–526,
2005.
[25] N. Nethercote and J. Seward. Valgrind: a framework for heavyweight
In ACM SIGPLAN Conference on
dynamic binary instrumentation.
Programming Language Design and Implementation (PLDI), 2007.
[26] G. Novark and E. D. Berger. DieHarder: Securing the Heap. In ACM
Conference on Computer and Communications Security (CCS), 2010.
[27] T. C. Projects. Using ClusterFuzz. http://dev.chromium.org/Home/
chromium-security/bugs/using-clusterfuzz, 2017.
15