el−→ Ml of N et(p
∗
),
i for all i, 0 < i ≤ l.
8.3 Basic nets, trace languages and event
structures
Because strand spaces can be easily turned into event
structures, Section 8.1 yields an event structure for each
!-par process. But, without any restrictions, we can relate
the net semantics to traditional independence models such
as event structures and Mazurkiewicz trace languages. The
crux of the construction is that of eliminating the persistent
conditions from the net N et(p), of a closed process term
p, in an initial marking Init(p) ∪ s ∪ t, to produce a ba-
sic net.
It’s well-known how to “unfold” a basic net to a
Mazurkiewicz trace language and event structure. Assume
N et(p) has input events In and output events Out. Then:
Theorem 8.5. There is a basic net N with events
E = Out∪ {(∗, e) | e ∈ In & oe ⊆ t}
∪ {(e1, e) | e ∈ In & e1 ∈ Out & oe = eo
1}
such that letting the map σ : E → Out ∪ In leave events in
Out unchanged and project pairs (∗, e), (e1, e) to the com-
ponent e:
1,··· , e
i) If N has a run with events e
(cid:1)
(cid:1)
k, then there is
1),··· , σ(e
(cid:1)
(cid:1)
k) of N et(p) from the
a run with events σ(e
initial marking Init(p) ∪ s ∪ t.
ii) If N et(p) has a run e1,··· , ek from the initial marking
1,··· , e
Init(p) ∪ s ∪ t, then N has a run e
(cid:1)
(cid:1)
k where
e1,··· , ek = σ(e
1),··· , σ(e
(cid:1)
(cid:1)
k).
The construction used to obtain N above is an example
of the construction for eliminating colours from a coloured
net - see [14]; ﬁrst colours are introduced to the persistent
conditions and input events of N et(p) to distinguish the dif-
ferent ways in which they are made to occur, and then elim-
inated through splitting the conditions and events according
to their colours. The result in this case is a basic net. Its
runs form a Mazurkiewicz trace language from which we can
then obtain an event structure - see [15].
9. CONCLUDING REMARKS
A role of the language SPL is that it can support, and so
help relate, diﬀerent semantics useful in the analysis of secu-
rity protocols - we have seen several examples. Future goals
are to relate to a probabilistic semantics, moving away from
the perfect cryptography assumption, and to study what
equivalences and compositional reasoning ﬁt with the rather
intensional event-based methods dealt with here. We hope
our work helps towards a more high-level analysis of security
protocols. To this end, we see the net semantics of SPL as
giving a potentially useful, concrete model theory for logics
for security protocols. The net runs are histories on which to
interpret security properties, perhaps expressed in the style
of BAN logic. On another tack, Petri nets form models of
linear logic [5], close it seems to the linear logic for secu-
rity protocols based on multiset rewriting [2]. As suggested
by an anonymous referee, the expressiveness of SPL could
be useful in characterising natural classes of protocols with
decidable security properties.
Acknowledgements. We are grateful to Stewart Lee
and an anonymous referee for suggestions and encourage-
ment. GW thanks Mart´ın Abadi for a timely overview of
approaches to security protocols while they were both visit-
ing Microsoft Research, Cambridge.
10. REFERENCES
[1] M. Abadi and A. Gordon. A calculus for cryptographic
protocols: The Spi calculus. In 4th ACM CCS, 1997.
[2] I. Cervesato, N. A. Durgin, M. Kanovich, and
A. Scedrov. Interpreting strands in linear logic. In
FMCS’00, 2000.
[3] I. Cervesato, N. A. Durgin, P. D. Lincoln, J. C.
Mitchell, and A. Scedrov. Relating strands and
multiset rewriting for security protocol analysis. In
13th IEEE CSFW, 2000.
[4] D. Dolev and A. C. Yao. On the security of public key
protocols. IEEE Trans. on Inf. Theory, 2(29), 1983.
[5] U. Engberg and G. Winskel. Linear logic on Petri
nets. In REX, a decade of concurrency, 1993, volume
803 of LNCS, 1994.
[6] G. Lowe. Breaking and ﬁxing the Needham-Schroeder
public-key protocol using FDR. In TACAS’96, volume
1055 of LNCS, 1996.
[7] R. Milner. Communicating and mobile systems: The
π-calculus. Cambridge University Press, 1999.
[8] U. Montanari and F. Rossi. Contextual nets. Acta
Informatica, (32), 1995.
[9] L. C. Paulson. Proving security protocols correct. In
LICS, 14th Symp., July 1999.
[10] A. M. Pitts and I. Stark. Observable properties of
higher order functions that dynamically create local
names, or: What’s new? In MFCS 18th Int. Symp.,
volume 711 of LNCS, 1993.
[11] R. L. Rivest, A. Shamir, and L. Adleman. A method
for obtaining digital signatures and public-key
cryptosystems. Comm. of the ACM, 21(2), 1978.
[12] J. Thayer, J. Herzog, and J. Guttman. Strand spaces:
Why is a security protocol correct? In 1998 IEEE
Symposium on Security and Privacy.
[13] G. Winskel. Event structures. In Advanced Course on
Petri nets, volume 255 of LNCS, 1986.
[14] G. Winskel. Petri nets, algebras, morphisms, and
compositionality. Inf. & Comput., 72, 1987.
[15] G. Winskel and M. Nielsen. Models for concurrency.
In Handbook of Logic in Comp. Sci., volume 4, 1995.
103APPENDIX
A. PETRI NETS
The explanation of general Petri nets involves a little al-
gebra of multisets (or bags), which are like sets but where
multiplicities of elements matters.
It’s convenient to also
allow inﬁnite multiplicities, so we adjoin an extra element
∞ to the natural numbers, though care must be taken to
avoid subtracting ∞. ∞-Multisets support addition + and
multiset inclusion ≤, and even multiset subtraction X − Y
provided Y ≤ X and Y has no inﬁnite multiplicities, in
which case we call Y simply a multiset.
A.1 General Petri nets
·
A general Petri net (place-transition system) consists of
• a set of conditions (or places), P ,
• a set of events (or transitions), T ,
• a precondition map pre, which to each t ∈ T assigns a
t for
multiset pre(t) over P - it is traditional to write
pre(t),
• a postcondition map post which to each t ∈ T assigns
an ∞-multiset post(t) over P , traditionally written t
·
,
• a capacity function Cap which is an ∞-multiset over P ,
assigning a nonnegative number or ∞ to each condition
p, bounding the multiplicity to which the condition can
hold; a capacity of ∞ means the capacity is unbounded.
A state of a Petri net consists of a marking, an ∞-multiset
M over P bounded by the capacity function, i.e. M ≤ Cap.
A marking captures a notion of distributed, global state.
Token game for general nets: Markings can change
as events occur, precisely how being expressed by the tran-
sitions M t→ M(cid:1)
events t determine between markings M
and M(cid:1)
and t ∈ T , deﬁne
. For markings M, M(cid:1)
M t−→ M(cid:1)
·
t ≤ M and M(cid:1)
iﬀ
= M − ·
·
.
t + t
An event t is said to have concession (or be enabled) at a
marking M iﬀ its occurrence leads to a marking, i.e. iﬀ
·
t ≤ M and M − ·
· ≤ Cap .
t + t
There is a widely-used graphical notation for nets in which
events are represented by squares, conditions by circles and
the pre- and postcondition maps by directed arcs carrying
numbers or ∞ as weights. A marking is represented by the
presence of tokens on a condition, the number of tokens
representing the multiplicity to which the condition holds.
When an event with concession occurs tokens are removed
from its preconditions and put on its postconditions with
multiplicities according to the pre- and postcondition maps.
Because of this presentation, the transition relation on Petri
nets is described as the “token game”.
A.2 Basic nets
We instantiate the deﬁnition of general Petri nets to an
important case where in all the multisets the multiplicities
are either 0 or 1, and so can be regarded as sets. In particu-
lar, we take the capacity function to assign 1 to every condi-
tion, so that markings become simply subsets of conditions.
The general deﬁnition now specialises to the following.
A basic Petri net consists of
• a set of conditions, B,
• a set of events, E, and
• two maps: a precondition map pre : E→Pow(B), a
postcondition map post : E → Pow(B). We can still
for the postcondi-
write
tions of e ∈ E and we require .e ∪ e. (cid:26)= ∅.
·
·
e for the preconditions and e
Now a marking consists of a subset of conditions, specify-
Token game for basic nets: For markings M,M(cid:1) ⊆ B
ing those conditions which hold.
and event e ∈ E, deﬁne
e ⊆ M & (M \·
e) ∩ e
·
·
iﬀ (1)
e) ∪ e
·
.
M e→ M(cid:1)
= (M \·
= ∅ and
(2) M(cid:1)
Property (1) expresses that the event e has concession at
the marking M. Returning to the deﬁnition of concession
for general nets, of which it is an instance, it ensures that
the event does not load another token on a condition that is
already marked. Property (2) expresses in terms of sets the
marking that results from the occurrence of an event. So, an
occurrence of the event ends the holding of its preconditions
and begins the holding of its postconditions. (It is possible
for a condition to be both a precondition and a postcondition
of the same event, in which case the event is imagined to end
the precondition before immediately restarting it.)
There is contact at a marking M when for some event e
e ⊆ M & (M \·
·
e) ∩ e
· (cid:26)= ∅.
The occurrence of an event is blocked through conditions,
which it should begin, holding already. Blocking through
contact is consistent with the understanding that the occur-
rence of an event should end the holding of its preconditions
and begin the holding of its postconditions; if the postcon-
ditions already hold, and are not also preconditions of the
event, then they cannot begin to hold on the occurrence of
the event. Avoiding contact ensures the freshness of names
in the semantics of name creation.
Basic nets are important because they are related to many
other models of concurrent computation, in particular, Ma-
zurkiewicz trace languages (languages subject to trace equiv-
alence determined by the independence of actions) and event
structures (sets of events with extra relations of causality
and conﬂict) - see [15].
A.3 Nets with persistent conditions
Sometimes we have use for conditions which once estab-
lished continue to hold and can be used repeatedly. If we
are to use net events to represent rules of the kind we ﬁnd
in inductive deﬁnitions, we need conditions that persist.
Persistent conditions can be understood as an abbrevia-
tion for conditions within general nets which once they hold,
do so with inﬁnite multiplicity. Consequently any number
of events can make use of them as preconditions but with-
out their ever ceasing to hold. Such conditions, having un-
bounded capacity, can be postconditions of several events
without there being conﬂict.
To be more precise, we modify the deﬁnition of basic
net given above by allowing certain conditions to be per-
sistent. A net with persistent conditions will still consist
of events and conditions related by pre- and postcondition
maps which to an event will assign a set of preconditions and
a set of postconditions. But, now amongst the conditions
are the persistent conditions forming a subset P . A marking
of a net with persistent conditions will be simply a subset of
104conditions, of which some may be persistent. Nets with per-
sistent conditions have arisen independently several times
and have been studied for example in contextual nets [8].
A net with persistent conditions can be understood on
its own terms, or as standing for a general net with the
same sets of conditions and events. The general net’s ca-
pacity function will be either 1 or ∞ on a condition, being
∞ precisely on the persistent conditions. When p is persis-
tent, p ∈ e
·
is interpreted in the general net as arc weight
(e.)p = ∞, and p ∈. e as (.e)p = 1. A marking of a net with
persistent conditions will correspond to a marking in the
general Petri net in which those persistent conditions which
hold do so with inﬁnite multiplicity. Graphically, we will
distinguish persistent conditions by drawing them as double
circles: ❢❤
Token game with persistent conditions: The token
game is modiﬁed to account for the subset of conditions P
being persistent. Let M and M(cid:1)
be markings (i.e. subsets
of conditions), and e an event. Deﬁne
e ⊆ M & (M \ (
e) ∪ e
B. THE EVENTS OF NSL
e ∪ P )) ∩ e
·
· ∪ (M ∩ P ) .
= (M \ ·
M e→ M(cid:1)
= ∅ and
(2) M(cid:1)
iﬀ (1)
·
.
We classify the events Ev(N SL) of the NSL protocol:
Initiator events:
✎
Init(A, B)
✍✌
❅
❅❅❘

✎
✍✌
out new m{m, A}P ub(B)
✄
{m, A}P ub(B)
✎❧
✄✎
❙✇
❦
✍✌
m
in{m, y, B}P ub(A).out{y}P ub(B)
in{m, y, B}P ub(A).out{y}P ub(B)
✴
❙
✎❧
✍✌
{m, n, B}P ub(A)
 
in{m, n, B}P ub(A)
  ✠
✎
✍✌
❅
❅❅❘

✎
✍✌
out{n}P ub(B)
✎
out{n}P ub(B)
✍✌
❅
❅❅❘
✴
out{n}P ub(B)
{n}P ub(B)
✎❧
❙✇
✍✌
❙
Responder events:
✎
✍✌
❅
❅❅❘

✎
✍✌
out new y{m, y, B
✴
✎❧
✍✌
{m, A}P ub(B)
 
  ✠
in{m, A}P ub(B)
105