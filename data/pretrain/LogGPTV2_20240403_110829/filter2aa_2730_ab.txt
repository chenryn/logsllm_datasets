如左图，一般的调试器需要有断点机制、异
常事件分发、调试管理程序三个部分
软件断点原理
软件断点在x86中就是指令int3，它的
二进制代码opcode是0xCC，当程序执
行到int3指令时，会引发异常。随后操
作系统会将异常抛给调试器，从而调试
器就有了处理断点的机会
软件断点需要写入指令，因此很容易被
对抗，常见的对抗方法有crc，函数头
部检测等
软件断点检测实例
此例子循环的进行一些文件操作，同时会不停的检测CreateFileW头部指令，如果我们在调试时
给CreateFileW下软件断点，调试器就会写入0xcc，程序会检测到并弹窗退出
如何隐藏软件断点？
隐藏软件断点
有了前面ept hook模拟执行的方法，隐
藏软件断点就变得非常容易，只需要把
原来hook插入的jmp修改成int3即可
当cpu执行X页面时，遇到int3会产生异
常，调试器可以接收到异常并处理
如右图mov rax,[0x1000]指令去读取
0x1000时，由于页面只有X权限，会触
发ept violation，被kvm接管后进入模
拟执行逻辑，模拟执行会欺骗cpu，返
回0x1000中的原始内容sub rsp,88，达
到隐藏断点的目的
编写虚拟化调试器
从头开发存在以下问题
•
工作量巨大
•
UI交互不如商业化产品友好
•
用户切换成本高
断点机制
异常事件分发
虚拟化加持
调试管理程序
因此我们选择去适配加持市面上已经成熟的
调试器如x64dbg,ida，这样一方面切换成
本低，一方面更加稳定
x64dbg、ida
x64dbg这类开源调试器很好适配，但是ida
等一些调试器不开源，如何在不进行任何
patch的情况下进行适配加持？
介绍完了隐藏软件断点的原理，我们该如何
编写具有隐藏软件断点的调试器呢？
类似HyperDbg这样从头开发？
加持现有调试器
如左图，是ida下软件断点的过程，我们可以通
过hook捕获到这种行为
向被调试进程写入int3
WriteProcessMemory
NtWriteVirtualMemory
MmCopyVirtualMemory
vmcall handler
R3
R0
R-1
check bp
ept
hook
vmcall
add hidden int3
有了虚拟化后,我们对MmCopyVirtualMemory
进行ept hook，检测是否是调试器在下断点，
随后将事件通过vmcall转发给kvm，kvm接收
到事件后，将int3断点转化成隐藏断点
隐藏软件断点演示
左图就是前面软件断点检测
的例子，当我们在
createfilew下断点后，kvm
会感知到并将createfilew所
在地址0x7FFDFE422090对
应的物理页设置成只保留X权
限，并写入0xcc,当
0x7FF6464E1058处指令
cmp byte ptr[rax],0xcc读取
0x7FFDFE422090时，会触
发模拟执行，cpu会读取到原
始指令
从下面kvm日志中能看到此
次模拟执行的rip，vcpu等信
息
隐藏软件断点视频演示
只需要将ida等调
试器放入
vt_hidden目录
下，无需任何修
改patch，就能
获得虚拟化加持，
绕过检测
容易踩的坑
•
guest 内存被交换到磁盘
•
copy on write问题
•
qemu 换页导致ept失效
mdl锁住内存，防止换页
写入一份相同内存的内容，保证当前GVA-
>GPA唯一性
qemu启动命令行添加mlock，防止qemu
进程换页
硬件断点原理
x86提供8个调试寄存器（DR0~DR7）用
于硬件调试。其中前四个DR0~DR3是硬
件断点寄存器，可以放入内存地址或者IO
地址，还可以设置为执行、修改等条件，
CPU在执行到满足条件的指令就会自动停
下来，一般用于监控数据读写，因此也叫
做数据断点。硬件断点十分强大，但缺点
是只有四个，同时也比较容易被检测
硬件检测实例
此例子循环读取变量并打印，如果我们在
调试时给global_var下硬件读写断点，调
试器会将global_var的地址写入Dr0，程
序通过GetThreadContext检测到Dr0中存
在有效地址，命中硬件断点检测逻辑，进
入异常流程，弹窗并退出
如何隐藏硬件断点？
隐藏硬件断点
从右图可以看到隐藏硬件断点跟
隐藏软件断点原理基本类似，差
别在于不需要patch内存，以读
写断点为例，只需要去掉页面
RW权限。在命中时根据当前线
程、断点进行匹配，匹配成功后
kvm会向guest注入#DB，x86硬
件断点只有4个，用了我们这种
模拟实现，可支持“无限硬断”
注入#DB的实现比较简单，直接
调用kvm现有的中断注入函数即
可
如何获取guest当前线程？
kvm中获取guest当前线程
Guest里面如何获取当前线程？
1、kvm中直接执行这段代码？
2、gsbase + kvm_read_guest_virt？
直观能想到的获取方法
为什么需要修正？修正后为什么还是读取失败？
以上是windows x64内核获取当
前线程的代码，可以看到实现非
常简单，直接获取的gs:188h
•
显然不行，gs不是guest的，并且cr3已经
切换到host，guest内存空间不可直接访问
•
gsbase虽然是vmexit时guest的gs，但测
试发现它不正确，需要修正
•
修正后我们再用kvm_read_guest_virt去读
取，发现依旧读取失败
失败原因分析
经过研究发现，我们模拟的硬件断点触发
vmexit的时机是R3，此时的gs指向teb，
只有在R0时，gs才会指向kpcr，
KeGetCurrentThread才能正确索引
如左图，KiSystemCall64Shadow是系统
调用入口函数，可以看到第一条执行的就
是swapgs，这个指令研究过cpu投机执行
的应该不陌生，根据intel手册它会将
GS.base=MSR.C0000102H(IA32_KERNE
L_GS_BASE)
因此我们只需要在kvm中获取
MSR.C0000102就能得到正确的gsbase，
获取msr有现成的函数vmx_get_msr
kvm_read_guest_virt失败的原因类似，
当vcpu.cpl=3时，会导致这个函数鉴权失
败，我们需要用更底层的函数来绕过
隐藏硬件断点视频演示
内核级trace
插桩实现指令trace
左图是基于intel pin二进制插桩，实现的trace工
具，它可以trace出ls程序执行的指令序列
实际的指令trace信息会比图中更全面，在脱壳、
去vmp虚拟化、二进制分析等场景都能用到
但是intel pin等常见的二进制插桩工具目前都不
支持内核态，我们如何借助硬件虚拟化来实现内
核态trace？
内核级trace
xxx.sys
加载回调
emulator
单步
去除代码段
X权限
entry
trace log
插桩
也有一些其他生成内核级trace的方法，比如在调
试器中生成，纯QEMU模拟生成，对比它们，我
们使用EPT+模拟器软硬结合的方法，性能消耗更
小，噪音更小，更不容易被对抗
整体思路还是真实执行+模拟执行，左边是我们
将一个驱动程序xxx.sys生成trace的全过程
总结
总结
我们介绍了如何基于硬件虚拟化特性，配合模拟器，实现无影子页ept hook，解决了传统方法存
在的问题。同时介绍了如何基于qemu\kvm快速打造虚拟化调试器、内核级trace工具
Q/A
欢迎添加我的微信进一步交流!
程聪
ID:
kingofmycc
昵称:
Ae0LuS