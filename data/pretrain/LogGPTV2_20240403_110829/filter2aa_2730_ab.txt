### 调试器的基本组成
一般的调试器通常包含三个核心部分：断点机制、异常事件分发和调试管理程序。

### 软件断点原理
在x86架构中，软件断点通过指令`int3`实现，其二进制代码操作码为`0xCC`。当程序执行到`int3`指令时，会引发一个异常。操作系统随后将该异常传递给调试器，从而使得调试器有机会处理这个断点。

#### 对抗方法
由于软件断点需要写入指令，因此容易被检测和对抗。常见的对抗手段包括CRC校验和函数头部检测等。

### 软件断点检测实例
假设有一个循环进行文件操作的程序，并且不断检测`CreateFileW`函数头部指令。如果我们在调试过程中对`CreateFileW`设置软件断点，调试器会写入`0xCC`，程序会检测到这一改变并弹出窗口后退出。

### 隐藏软件断点的方法
利用EPT Hook模拟执行技术，可以轻松隐藏软件断点。具体步骤是将原来的Hook插入的`jmp`指令修改为`int3`。当CPU执行X页面时遇到`int3`会产生异常，调试器可以接收到并处理该异常。

例如，在读取`0x1000`地址时，由于页面只有执行权限（X），会触发EPT Violation，由KVM接管后进入模拟执行逻辑。模拟执行会欺骗CPU，返回`0x1000`中的原始内容`sub rsp, 88`，从而达到隐藏断点的目的。

### 编写虚拟化调试器
从头开发一个虚拟化调试器面临以下挑战：
- 工作量巨大
- 用户界面不如商业化产品友好
- 用户切换成本高

因此，我们选择适配现有的成熟调试器，如x64dbg和IDA，这样可以降低切换成本并提高稳定性。

### 适配现有调试器
对于开源调试器如x64dbg，适配较为简单。但对于闭源调试器如IDA，则需找到一种无需任何补丁的方法进行适配。

### 隐藏软件断点的具体实现
以IDA为例，我们可以捕获IDA下软件断点的过程。通过Hook捕获到这种行为后，向被调试进程写入`int3`指令。然后对`MmCopyVirtualMemory`进行EPT Hook，检测是否是调试器在设置断点，并将事件通过vmcall转发给KVM。KVM接收到事件后，将`int3`断点转换成隐藏断点。

### 隐藏软件断点演示
当我们在`CreateFileW`处设置断点后，KVM会感知并将`CreateFileW`所在地址对应的物理页设置为只保留执行权限（X），并写入`0xCC`。当指令`cmp byte ptr [rax], 0xcc`读取该地址时，会触发模拟执行，CPU读取到原始指令。

### 隐藏软件断点视频演示
只需将IDA等调试器放入`vt_hidden`目录下，无需任何修改即可获得虚拟化加持，绕过检测。

### 容易踩的坑
- Guest内存被交换到磁盘
- Copy on Write问题
- QEMU换页导致EPT失效

解决方法：
- 使用MDL锁住内存，防止换页
- 写入一份相同内存的内容，保证当前GVA->GPA的唯一性
- 在QEMU启动命令行中添加`mlock`，防止QEMU进程换页

### 硬件断点原理
x86架构提供了8个调试寄存器（DR0~DR7）用于硬件调试。其中前四个（DR0~DR3）是硬件断点寄存器，可以存放内存地址或I/O地址，并设置执行、修改等条件。当CPU执行到满足条件的指令时，会自动停下来。硬件断点强大但数量有限（只有四个），并且容易被检测。

### 硬件检测实例
在一个循环读取变量并打印的例子中，如果我们在调试时对`global_var`设置硬件读写断点，调试器会将`global_var`的地址写入DR0。程序通过`GetThreadContext`检测到DR0中存在的有效地址，命中硬件断点检测逻辑，进入异常流程并弹窗退出。

### 隐藏硬件断点
隐藏硬件断点的原理与隐藏软件断点类似，不同之处在于不需要修改内存。以读写断点为例，只需去掉页面的RW权限。当命中时，根据当前线程和断点进行匹配，匹配成功后KVM会向Guest注入`#DB`中断。这种方法可以支持“无限硬断”。

### 获取Guest当前线程
在KVM中获取Guest当前线程的方法：
1. 直接执行代码？
2. 使用`gsbase + kvm_read_guest_virt`？

直观的方法可能不适用，因为：
- `gs`不是Guest的，并且CR3已切换到Host，Guest内存空间不可直接访问
- `gsbase`虽然是vmexit时Guest的gs，但测试发现它不正确，需要修正

修正后的`gsbase`仍然无法通过`kvm_read_guest_virt`读取，原因是vcpu.cpl=3时鉴权失败。我们需要使用更底层的函数来绕过。

### 失败原因分析
硬件断点触发vmexit的时机是在R3，此时`gs`指向TEB，只有在R0时`gs`才指向KPCR，`KeGetCurrentThread`才能正确索引。通过获取`MSR.C0000102`可以得到正确的`gsbase`。

### 隐藏硬件断点视频演示
内核级Trace

### 插桩实现指令Trace
基于Intel PIN二进制插桩实现的Trace工具可以跟踪程序执行的指令序列。实际的指令Trace信息更加全面，适用于脱壳、去VMP虚拟化和二进制分析等场景。但Intel PIN等工具不支持内核态，我们可以通过硬件虚拟化来实现内核态Trace。

### 内核级Trace
通过EPT+模拟器软硬结合的方法，性能消耗更小，噪音更低，更不容易被对抗。整体思路是真实执行+模拟执行。

### 总结
本文介绍了如何基于硬件虚拟化特性，配合模拟器实现无影子页EPT Hook，解决了传统方法存在的问题。同时，介绍了如何快速打造虚拟化调试器和内核级Trace工具。

### Q&A
欢迎添加我的微信进一步交流！
- 微信号: kingofmycc
- 昵称: Ae0LuS