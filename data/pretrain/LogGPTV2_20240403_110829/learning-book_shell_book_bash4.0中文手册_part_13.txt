HOME
当前用户的主目录，也是内部命令cd的默认值。这个变量的值还用在波浪号扩展中（参见53.5.2波
浪号扩展]，p15）
IFS
用来分隔字段的一组字符：在扩展时，shell用它来拆分单词。
MAIL
如果这个变量设为一个文件名，并且没有设置MAILPATH变量，Bash将通知用户在指定文件中有
新邮件。
冒号分隔的一级文件名，shell会定期在这些文件中检查新邮件。每个文件名都可以名称后面
用"？分隔，然后指定一条消息，当新邮件到达时将把这条消息打印出来。在消息文本中，$_扩展成
当前邮箱文件名。
OPTARG
内部命令getopts处理的最后一个选项。
OPTIND
内部命令getopte处理的最后一个选项参数。
HIVA
冒号分隔的一组目录，shell用它来搜索命令，长度为零的（空目录）目录名表示当前目录，它可以
作为两个连在一起的冒号出现，也可以作为开始或结束的冒号出现。
PS1
主提示符，它的默认值是"s=vs_"。关于在显示PS1之前就被扩展的转义序列完整列表，请参
见56.9[提示符的控制]，p64
PS2
第二提示符，默认值是“>_"
传统的mbox邮箱中能保存多封邮件，而对于maildir则是每个文件只存放一封邮件。所以如果邮件系统是maildir英型的，例
如 qmall，则应该指定MAILPATH 而不是MAIL。
注意最后的空格。
国注意，最后面应有个空格。
BASH 中文文档
p48
---
## Page 60
$5.2BASH的变量
第五章SHELL变量
55.2Bash的变量
下面的变量是Bash设置和使用的，但是其它shell通常都不会对它们进行特殊处理。有些Bash变量
在其它章节中介绍，例如作业控制所使用的变量（参见57.3作业控制变量]：p71）。
BASH
执行当前Bash所用的完整路径。
BASHPID
扩展为当前Bash进程的进程号。在有些情况下，这和 S$是不同的：例如子shell 中，这时
Bash不会重新初始化。
BASH_ALIASES
一个键值数组变量，其中的元素和内部命令alias所维护的别名列表相对应（参
见g4.2[Bash的内部命令alas]p34）.这个数组中添加的元素将也出现在别名列表中：而删除
元素将会同时删除别名列表中的别名。
BASH_ARGC
一个数组变量，其中的元素是当前Bash的执行栈中每个顿里面的参数个数。当前子程序（即
shell函数，或者用，或source执行的shell脚本）的参数个数在栈的顶端。执行子程序时，转递给它
的参数个数被压入BASH_ARGC数组，只有shell运行在扩展的调试模式中（参见≤87[内部命令shopt]
p46）才会设置这个数组。
BASHARGV
一个数组变量，包含当前Bash的执行栈中的所有变量。最后一个子程序调用的最后一个参
压入到BASH_ARGV中.只有shell运行在扩展的调试模式中（参见587[内部命令shopt]，p46）才会设置
这个数组。
BASH_CMDS
一个键值数组变量，其中的元素和内部命令hash所维护的命令散列表相对应（参见54.1[波
恩Shell的内部命令haeb]。p31).这个数组中添加的元素将也出现在散列表中：而删除元素将会同时
删除散列表中的命令。
BASH_COMMAND
当前正在或即将执行的命令。如果这个命令是从属于陷阱，则表示触引发陷阱的命令。
BASH.ENV
如果在启动Bash来执行一个shell脚本时设置了这个变量，它的值就会在执行脚本前被扩展
并当作初始化文件来读取（参见56.2Bash的启动脚本]，p56）。
BASH.EXECUTION_STRING
启动选项”-e”的命令参数。
BASHLINENO
一个键值数组变量，其中的元素是与每个FUNCNAME对应的源文件中的行号。S{BASH_LINEND[$i]}
是源文件中调用${FUNCNAME[$s]}地方的行号（如果是在其它shel函数中调用，则是S{BASH_LINENO[$i=1]}），
而对应的源文件名是${BASH_SOURCE[Si]}。可以用LINEND来获得当前的行号。
BASH_REMATCH
一个数组变量，其中的元素由条件结构命令[L的双目运算符"-”（参见≤3.2.4.2[条件结
构[[--]]]：p10）来赋值。下标为0的元素是字符串中与整个正则表达式匹配的部分：下标为n的
元素是字符申中与第n个括号中的子模式匹配的部分。这个变量是只读的。
BASH.SOURCE
一个数组变量，其中的元素是与数组变量FUNCNAME中元素对应的源文件名。
BASH_SUBSHELL
每次创建一个子shell或子shell环境中都把这个变量增加一。它的初始值是0
BASH_VERSINFO
一个只读数组变量（参见56.7数组）.p62），其中的元素保存了当前Bash的版本信息。
元素的值如下：
BASH_VERSINFO[0]
主版本号（发布号）。
p49
目录
BASH 中文文
---
## Page 61
第五章SHELL变量
5.2BASH的变量
BASH_VERSINFO[1]
次版本号（版本号BASH_VERSION）
BASH_VERSINF0[2]
补丁级别。
BASH_VERSINFD[3]
编译版本号。
BASH_VERSINFD[4]
发布状态（例如betal）.
BASH_ VERSINFO[S]
MACHTYPE的值
BASH_VERSION
当前Bash的版本号。
COLUMNS
内部命令Belect在打印待选列表时用它来决定终端的宽度。它会在接收到SIGWINCH信号时
自动改变。
CONP_CWORD
在包含当前光标位置的单词${COMP_WORDS}中的下标。这个变量只能在可编程补全的shell
函数中使用（参见58.6[可编程的补全]，p86）.
CONP LINE
当前的命令行。这个变量只能在可编程补全的shell函数中使用（参见58.6[可编程的补全]，
p86)-
CONP_POINT
当前光标位置相对于当前命令行开头的下标。如果当前光标位置在当前命令行的尾部，则这
个变量的值就与S{#COMP_LINE}相同。这个变量只能在可编程补全的shell函数中使用（参见58.6[可
编程的补全]，p86）。
CONP_TYPE
一个整数值，与触发调用补全函数时试图进行补全的类型相对应：正常补全时为TAB，连续
输入制表符后的补全列表为？，列出其它部分补全条目时为！，没有修改单词而列出补全条目时为，
补全菜单时为%。这个变量只能在可编程补全的shell函数中使用（参见58.6[可编程的补全]，p86）。
COMP_KEY
触发当前补全函数的键（或键序列中的最后一个键）。
CONP_WORDBREAKS
Readline库进行单词补全时用作单词分隔的字符。如果没有设置这个变量，它就会失
去特殊作用，即使以后再设置。
CONP_WORDS
一个数组变量，包含当前命令行的每个单词。当前行被上面所说的COMP_WORRBREAKS拆分
成单词，
和Readline的方式一样。这个变量只能在可编程补全的shell函数中使用（参见g8.6[可编程
的补全，p86）。
COMPREPLY
一个数组变量：Bash从这个变量中读取可编程补全所调用的shell函数生成的补全条目（参
见58.6可编程的补全]，p86）.
DIRSTACK
一个数组变量，包含了当前目录栈的内容。目录在栈中按照内部命令dire所显示的顺序保
存。可以通过对这个数组中元素赋值来修改栈中已有的目录，但必须用pushd或popd才能删除栈中
的目录。对这个变量赋值不会改变当前目录。如果没有设置这个变量，则它就会失去其特殊作用，即
使以后再设置。
EMACS
如果Bash启动时在环境中有这个变量并且其值为“t”，就会认为它正在emacs的shell缓存中运
行，并禁止行编辑。
当前用户的有效用户号，这个变量是只读的。
FCEDIT
内部命令fc带有“-e”选项时默认要使用的编辑器。
BASH 中文文档
目录
p50
---
## Page 62
5.2BASH的变量
第五章SHELL变量
FIGNORE
进行文件名扩展时要忽略的冒号分隔的后缀。如果一个文件名的后缀和这个变量某个条目匹
配，它就不会出现在匹配的文件名列表中。例如，它可以取值为”.心：-”。
FUWICNANE
一个数组变量，包含当前执行栈中所有shell函数的名称。下标为0的元素是当前正在执行
的shell函数：而栈底是“main”。这个变量只有在执行shell函数时才有。对FUNCNAME赋值不会生效
并且会返回一个错误状态。如果没有设置这个变量，它就会推动特殊作用，即使以后再设置。
GLOBIGNORE
冒号分隔的一组模式，它定义了文件名扩展时所要忽略的文件名，在文件名扩展中，如果
匹配了一个文件名，而这个文件名又和GLDBIGNDRE中的一个模式匹配，则它将被从匹配列表中删
除。
S
一个数组变量，包含当前用户所属的用户组。对GROUPS赋值不会生效并且会返回一个错误的状
态。如果没有设置这个变量，它就会失去其特殊作用，即使以后再设置。
histchars
不超过三个字符，用来控制历史扩展、快速替换、符号化（参见59[历史的交互使用），p90）
其中的第一个是历史扩展字符，即表示历史扩展开始的字符，它通常是“"。第二个字符如果出现在行
的开头，则表示要进行“快速替换”，它通常是“”。第三个字符是可选的，它如果是一个单词的第一个
字符，就表示本行中剩余的部分是注释：它通常是“#，历史注释字符使得历史替换忽略本行中剩余
的单词：而不一定表示shell解释器会把剩余部分当成注释。
HISTCMD
历史号，即当前命令在历史中的索引号。如果没有设置这个变量，它就失去特殊的作用，即使
以后再设置。
HISTCONTROL
冒号分隔的一组值，它控制命令怎么在历史中保存。如果值中包含“ignorespace"，
则不在历史中保存以空格开头的行。值为“gnoredupe"表示不保存与前一历史条目匹配的行。
值"ignoreboth”是“ignorespace"和"ignoredupe"两者的简写。值"eragedupe”表示在保存本行时首
先删除与本行匹配的前一行。此外的所有值都会被忽略，如果没有设置这个变量，或它不包含有效的
值，则shell解释器会根据HISTIGNORE的值在历史中保存所有读取的行。多行命令的第二和其余行不
会进行如上的检测，不管这个变量如何设置都会保存到历史中。
HISTFILE
用来保存命令历史的文件，默认值是-/.bashhistory
HISTFILESIZE
历史文件中包含的最多行数。如果给这个变量赋值，历史文件就会在必要时剩除最早的
记录，以保证不超过指定的行数。当交互式的shell退出运行时也会删除这个文件中的最早记录并只
保留不超过指定的行数。这个变量的默认值是500.
HISTIGNORE
冒号分隔的一组模式，用以决定哪些命令可以保存在历史中。每个模式都定位在行的开头，
必须和整行匹配（没有隐式加上“）。在进行HISTCONTROL指定的检查后，每个模式都会和当前行匹
配。除了shell中通常的模式匹配字符，还可以用“”来匹配历史中的前一行，如果用使用“”本身，可
以用反斜杠转义：在匹配之前，这个反斜杠将被删除。多行命令的第二和其余行不会进行检测，不管
这个变量如何设置都会保存到历史中。
HISTIGNORE包括了HISTCONTROL的功能。“&”模式与ignoredups是等价的，而“[]*模式和ignorespace
是等价的。把这两个模式用冒号连接起来就和ignoreboth是等价的。
HISTSIZE
历史中保存的最多命令个数，默认值是500.
HISTTINEFORMAT
如果设置了这个变量且不为空，它的值将用作trftime的格式字符串，并被内部命
令history显示历史条目时打印每条历史的时间戳。如果设置了这个变量，时间戳也会写入到历史文
件中以便在不同的shell会话中保留这些信息。它使用历史注释字符以便把时间截和其它历史行区别
开来。
即制前说的第三个字符。
p51
目录
BASH 中文文
---
## Page 63
第五章SHELL变量
$5.2BASH的变量
HOSTFILE
指定一个格式与/etc/hoste 相同的文件，以便shell补全主机名时使用.在shell运行时可
以更改主机名补全的条目，改变这个值后再进行主机名补全时，Bash会把新文件中的内容加入到已有
的列表中。如果设置了这个变量却没有指定值，Bash就试图读取/etc/hogtB来获得主机名补全的
条目。如果重置这个变量，就会清空主机名列表。
HOSTNANE
当前主机的名称。
HOSTTYPE
一个字符串，它描述了运行Bash的机器的类型。
IGNOREEOF
控制着shell读取到EOF字符作为整个输入时的行为。如果设置了，它的值表示连续EDF字
符的个数：如果shell输入的行首有这么多EDF，就会退出，如果设置了这人变量，而其值却不是数
值（或没有值），则默认为10.如果这个变量不存在，EDF字符就表示shell输入的结束。这只有在交
互式的shell 中才有效。
INPUTRC
Readline初始化文件的名称，用来覆盖默认值-/.inputrc。
LANG
用来指定语言类别，如果这个类别没有特别地用LC_开头的变量指定。
LC_ALL
这个变量覆盖LANG和所有其它LC变量指定的语言类别。
LC_COLLATE
这个变量决定文件名扩展结果的排序顺序，以及文件名扩展和文件名匹配中的范围表达式、
等价字符类、语言区域序列（参见53.5.8文件名扩晨，p19）。
LC_CTYPE
这个变量决定文件名扩展和模式匹配中对字符的解释和字符类的行为（参见3.5.8[文件名扩
展]，p19).
LC_MESSAGES
这个变量决定翻译$后面的双引用字符串（参见53.1.2.1[Locale专用的翻译]，p6）时所使