![](/data/attachment/album/201612/14/165844p0qe3mkemqv08xa0.png)
他们都有对最后找到的地点的 `:LIKES` 关系，然后我们可以在 Cypher 中很容易的计算出他们之间的欧几里得距离，计算方法为他们对各个地点评分差的平方求和再开平方根。
在两个特定用户的例子中上面这个方法或许能够工作。但是，在实时情况下，当你想要通过和实时数据库中的其他用户比较，从而由一架飞机上的一个用户推断相似用户时，这个方法就不一定能够工作。不用说，至少它不能够很好的工作。
为了找到解决这个问题的好方法，我们可以预先计算好距离并存入实际关系中：
![](/data/attachment/album/201612/14/165848gf8w1f4cuf4m9fbf.png)
当遇到一个很大的数据集时，我们需要成批处理这件事，在这个很小的示例数据集中，我们可以按照所有用户的 迪卡尔乘积   （    Cartesian product    ） 和他们共同“喜好”的地点来进行匹配。当我们使用 `WHERE id(u1)  集群推荐   （    Cluster Recommendations    ） 
我们最后要讲的一个例子是集群推荐，在 Cypher 中，这可以被想像成一个作为临时解决方案的离线计算工作流。这可能完全基于在[欧洲 GraphConnect 上宣布的新方法](https://neo4j.com/blog/neo4j-3-0-massive-scale-developer-productivity/)，但是有时你必须进行一些 Cypher 2.3 版本所没有的算法逼近。
在这儿你可以使用一些统计软件，把数据从 Neo4j 取出然后放入像 Apache Spark、R 或者 Python 这样的软件中。下面是一段把数据从 Neo4j 中取出的 R 代码，运行该程序，如果正确，写下程序返回结果的给 Neo4j，可以是一个属性、节点、关系或者一个新的标签。
通过持续把程序运行结果放入到图表中，你可以在一个和我们刚刚看到的查询相似的实时查询中使用它：
![](/data/attachment/album/201612/14/165855lss9sbi9b5r34srz.png)
下面是用 R 来完成这件事的一些示例代码，但是你可以使用任何你最喜欢的软件来做这件事，比如 Python 或 Spark。你需要做的只是登录并连接到图表。
在下面的例子中，我基于用户的相似性把他们聚合起来。每个用户作为一个观察点，然后得到他们对每一个目录评分的平均值。
![](/data/attachment/album/201612/14/165857r7f3zi9fcjj9w37g.png)
假定用户对酒吧类评分的方式和一般的评分方式相似。然后我攫取出喜欢相同类别中的地点的用户名、类别名、“喜好”关系的平均权重，比如平均权重这些信息，从而我可以得到下面这样一个表格：
![](/data/attachment/album/201612/14/165900saw16a1a2anl5ln3.png)
因为我们把每一个用户都作为一个观察点，所以我们必须巧妙的处理每一个类别中的数据，这些数据的每一个特性都是用户对该类中餐厅评分的平均权重。接下来，我们将使用这些数据来确定用户的相似性，然后我将使用 聚类   （    clustering    ） 算法来确定在不同集群中的用户。
在 R 中这很直接：
![](/data/attachment/album/201612/14/165902n6vqnqq68pv6vg56.png)
在这个示例中我们使用 K-均值   （    k-means    ） 聚类算法，这将使你很容易攫取集群分配。总之，我通过运行聚类算法然后分别得到每一个用户的集群分配。
Bob 和 David 在一个相同的集群中 - 他们在集群二中 - 现在我可以实时查看哪些用户被放在了相同的集群中。
接下来我把集群分配写入 CSV 文件中，然后存入图数据库：
![](/data/attachment/album/201612/14/165905a1iulczzc20zzve2.png)
我们只有用户和集群分配，因此 CSV 文件只有两列。 `LOAD CSV` 是 Cypher 中的内建语法，它允许你从一些其他文件路径或者 URL 调用 CSV ，并给它一个别名。接下来，我们将匹配图数据库中存在的用户，从 CSV 文件中攫取用户列然后合并到集群中。
我们在图表中创建了一个新的标签节点：`Cluster ID`， 这是由 K-平均聚类算法给出的。接下来我们创建用户和集群间的关系，通过创建这个关系，当我们想要找到在相同集群中的实际推荐用户时，就会很容易进行查询。
我们现在有了一个新的集群标签，在相同集群中的用户和那个集群存在关系。新的数据模型看起来像下面这样，它比我们前面探索的其他数据模型要更好：
![](/data/attachment/album/201612/14/165908d61pprs00ov26hys.png)
现在让我们考虑下面的查询：
![](/data/attachment/album/201612/14/165912qo90f0nofoi0wfoi.png)
通过这个 Cypher 查询，我们在更远处找到了在同一个集群中的相似用户。由于这个原因，我们删除了“距离”关系：
![](/data/attachment/album/201612/14/165918mf77g2g7pqhhhmz8.png)
在这个查询中，我们取出已经登录的用户，根据用户-集群关系找到他们所在的集群，找到他们附近和他们在相同集群中的用户。
我们把这些用户分配到变量 `c1` 中，然后我们得到其他被我取别名为 `neighbor` 变量的用户，这些用户和那个相同集群存在着用户-集群关系，最后我们得到这些附近用户“喜好”的地点。再次说明，我把“喜好”放入了变量 r 中，因为我们需要从关系中攫取权重来对结果进行排序。
在这个查询中，我们所做的改变是，不使用相似性距离，而是攫取在相同集群中的用户，然后对类别、航站楼以及我们所攫取的登录用户进行声明。我们收集所有的权重：来自附近用户“喜好”地点的“喜好”关系，得到的类别，确定的距离值，然后把它们按升序进行排序并返回结果。
在这些例子中，我们可以进行一个相当复杂的处理并且将其放到图数据库中，然后我们就可以使用实时算法结果-聚类算法和集群分配的结果。
我们更喜欢的工作流程是更新这些集群分配，更新频率适合你自己就可以，比如每晚一次或每小时一次。当然，你可以根据直觉来决定多久更新一次这些集群分配是可接受的。
---
via: 
作者：[Nicole White](https://neo4j.com/blog/contributor/nicole-white/) 译者：[ucasFL](https://github.com/ucasFL) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出