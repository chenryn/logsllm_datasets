Kerberos Security 
Package
BeginTracking
…
X
Hash Value
Session ID
User Session X
Local Security Authority
❷ Update AES-CMAC hash 
with security buﬀer contents
LSA Loopback Library
Kerberos Security 
Package
UpdateTracking
AP-REQ
AP-REQ
FEEDACDC
X
Hash Value
Session ID
InitializeSecurityContext
User Session
Local Security Authority
❸ Accept AP-REQ and add 
AES-CMAC entry
LSA Loopback Library
AcceptSecurityContext
Kerberos Security 
Package
BeginTracking
AP-REQ
FEEDACDC
X
Hash Value
Session ID
FEEDACDC
0
Local Security Authority
User Session
❹ Create token and lookup 
ﬁnal hash. If a match is 
found, move the token to the 
client session
LSA Loopback Library
AcceptSecurityContext
Kerberos Security 
Package
LsapCreateTokenEx
FEEDACDC
X
Hash Value
Session ID
FEEDACDC
0
Token
LsapApplyLoopbackSessionId
LSA Loopback Library
ELI5
1.
Loopback Library will hash all security 
buﬀers between LSA and clients. If 
hashes match when a token is being 
built, the token will be moved to the 
client session.
2.
We need to start using 
InitializeSecurityContext with our silver 
tickets to get the hash entry initialized.
3.
We need to modify the PAC inside the 
AP-REQ, but if we touch the buﬀers the 
hash lookup will break. (or will it?)
User Session
Local Security Authority
Kerberos Security Package
Our Code
(Initialize/Accept)SecurityContext
No Fly Zone!
Loopback Security Buﬀer Hashing Bug
PSecBufferDesc pInput = ...;
for(ULONG i = 0; i cBuffers; ++i) {
  PSecBuffer pBuffer = &pInput->pBuffers[i];
  if (pBuffer.BufferType == SECBUFFER_TOKEN) {
    BCryptHashData(hHash, pDirectionGuid, cbDirectionGuid);
    BCryptHashData(hHash, pBuffer->pvBuffer, pBuffer->cbBuffer);
  }
}
Security Buﬀer Types
Buﬀer Type
Meaning
Value
SECBUFFER_EMPTY
Undeﬁned, replaced by the 
security package function
0x00000000
SECBUFFER_TOKEN
Security token
0x00000002
…
SECBUFFER_READONLY
Buﬀer is read-only, no 
checksum
0x80000000
SECBUFFER_READONLY_WITH_CHECKSUM
Buﬀer is read-only, and 
checksummed
0x10000000
The buﬀer types can be combined using a bitwise-OR operation 
with the READONLY buﬀer types.
Security Buﬀer Descriptor
Type Confusion in AcceptSecurityContext
Kerberos Security 
Package
Original AP-REQ from 
InitializeSecurityContext
SECBUFFER_TOKEN
Loopback Library
Modified AP-REQ with 
Silver Ticket
SECBUFFER_TOKEN | 
SECBUFFER_READONLY
Ignored by Loopback library.
Used by Kerberos.
Hashed by LoopbackLibrary.
Ignored by Kerberos.
Demo Time
Fixed in Windows 11 ?
if (pBuffer.BufferType == SECBUFFER_TOKEN) {
    BCryptHashData(hHash, pDirectionGuid, cbDirectionGuid);
    BCryptHashData(hHash, pBuffer->pvBuffer, pBuffer->cbBuffer);
}
if ((pBuffer.BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_TOKEN) {
    BCryptHashData(hHash, pDirectionGuid, cbDirectionGuid);
    BCryptHashData(hHash, pBuffer->pvBuffer, pBuffer->cbBuffer);
}
Windows 10:
Windows 11:
Masking the upper byte out
LSA Loopback Library
Danger Zone
User Session
Local Security Authority
Kerberos Security Package
Our Code
(Initialize/Accept)SecurityContext
No Fly Zone!
Man in the middle 
is on the table?
KDC.REALM
Modifying on the Wire
Local Security Authority
CIFS/ABC
TGS U2U
bob@REALM
PAC w/admin
KDC
CIFS/ABC
TGS U2U
bob@REALM
PAC
Session Key
TGS-REP
TGS-REP
(evil)
What about Credential Guard ?
Kerberos Considerations
When you enable Windows Defender Credential Guard, 
you can no longer use Kerberos unconstrained 
delegation or DES encryption. Unconstrained 
delegation could allow attackers to extract Kerberos 
keys from the isolated LSA process. Use constrained 
or resource-based Kerberos delegation instead.
https://docs.microsoft.com/en-us/windows/security/identity-
protection/credential-guard/credential-guard-considerations
LSA Loopback Library
BYOKDC
User Session
Local Security Authority
Kerberos Security Package
Our Code
(Initialize/Accept)SecurityContext
No Fly Zone!
Bring Your Own KDC?
KDC.FAKE
KDC Pinning
struct SECPKG_CALL_PACKAGE_PIN_DC_REQUEST {
    ULONG          MessageType;
    ULONG          Flags;
    UNICODE_STRING DomainName;
    UNICODE_STRING DcName;
    ULONG          DcFlags;
};
MessageType can be SecPkgCallPackagePinDcMessage or KerbPinKdcMessage
User Session X
Custom KDC
Local Security Authority
TGS-REP Local KDC
Kerberos Security 
Package
Client
LsaCallAuthPackage
FAKE
Y
Host
PID
Realm
TID
X
localhost
krbtgt@FAKE
❶ Pin our fake KDC to 
localhost
User Session X
Custom KDC
Local Security Authority
TGS-REP Local KDC
Kerberos Security 
Package
Client
fake credentials
LsaLogonUser
FAKE
Y
Host
PID
Realm
TID
X
localhost
KerbMakeSocketCall
krbtgt@FAKE
❷ Issue our own 
tickets with arbitrary 
PAC data
(despite being 
diﬀerent domains)
CIFS/CLIENT
TGS U2U
bob@REALM
PAC w/admin
u: FAKE\bob
pw: WooHoo!
Demo Time
“Security 
Boundaries”
and where they aren’t
Service Account S4U2Self
KDC.REALM
Service Account Session
Local Security Authority
Client
LsaLogonUser(S4U, …)
UPN: Admin
Realm: REALM
TGS-REP 
+ PA-FOR-USER
Access Token
User: REALM\Admin
Level: Identiﬁcation
We have 
SeImpersonate but 
the token is locked to 
Identiﬁcation
KEY: svc@REALM
CNAME: Admin
S4U TCB Privilege Check
KerbCreateTokenFromLogonTicket(...) {
    if (MessageType == KerbTicketLogon || MessageType == KerbTicketUnlockLogon ||
        MessageType == KerbS4ULogon || …
    ){
        if (!ClientInfo.HasTcbPrivilege)
            PrimaryCredentials->Flags |= PRIMARY_CRED_LOGON_NO_TCB;
    }
}
LsapAuApiDispatchLogonUser(...) {
    BOOL UseIdentify = PrimaryCredentials.Flags & PRIMARY_CRED_LOGON_NO_TCB;
    LsapCreateV3Token(...
        (UseIdentify ? TokenImpersonation : TokenPrimary),
        (UseIdentify ? SecurityIdentification : SecurityImpersonation),
        &Token
    );
}
Service Account Session
KRB_CRED
krbtgt/REALM
Service Account S4U2Self
KDC.REALM
Local Security Authority
Client
krbtgt/REALM
TGT
TGT Extraction
Service Account Session
KRB_CRED
krbtgt/REALM
Service Account S4U2Self
KDC.REALM
Local Security Authority
Client
KEY: svc@REALM
CNAME: Admin
TGS-REP 
+ PA-FOR-USER
krbtgt/REALM
TGT
Service Account Session
KRB_CRED
krbtgt/REALM
Service Account S4U2Self
KDC.REALM
Local Security Authority
Client
KEY: svc@REALM
CNAME: Admin
Access Token
User: REALM\Admin
Level: Impersonation
krbtgt/REALM
TGT
KEY: svc@REALM
CNAME: Admin
AcceptSecurityContext
What about UAC ?
2.2.5. LSAP_TOKEN_INFO_INTEGRITY
The LSAP_TOKEN_INFO_INTEGRITY structure specifies the 
integrity level information for the client.
typedef struct _LSAP_TOKEN_INFO_INTEGRITY {
unsigned long Flags;
unsigned long TokenIL;
unsigned char MachineID[32];
}
[MS-KILE]: Kerberos Protocol Extensions
Authoriziation Data Entries
AP-REQ
Service Ticket
bob@REALM
PAC
KERB-AD-RESTRICTION-ENTRY
_LSAP_TOKEN_INFO_INTEGRITY {
   Flags = RestrictedToken;
   TokenIL = Medium;
   MachineID = {FEED-ACDC};
}
Authorization
Data
Authenticator
Authorization
Data
[...]
Ticket’s AD entry taken in 
preference to Authenticator’s
Token Filtering Logic
LSA Token Filtering
No Filtering
Filter Token
User is a 
Local 
Account
Local Account 
Token Filtering 
is enabled
Machine is not 
a domain 
controller 
&&
&&
True
False
True
True
True
False
via LsaISetSupplementalTokenInfo()
False
info.MachineId == 
LsapGlobalMachineID
Network Auth Token 
Filtering is enabled
info.Flags & 
LimitedToken
Service Account Session
Kerberos UAC Bypass
KDC.REALM
Local Security Authority
Client
Service Session
RPC/CLIENT
TGS
uac admin
Session
Key
Auth 
Data
LsaCallAuthPackage
❶ Request service 
ticket and session 
key from ticket 
cache
SCM RPC 
Service
Kerberos Security 
Package
Service Account Session
Kerberos UAC Bypass
KDC.REALM
Local Security Authority
Client
Service Session
❷ Manually renew 
the service ticket 
without any 
authorization data
RPC/CLIENT
TGS
Session
Key
Auth 
Data
SCM RPC 
Service
Kerberos Security 
Package
Service Account Session
Kerberos UAC Bypass
KDC.REALM
Local Security Authority
Client
Service Session
Kerberos Security 
Package
❸ Pass clean ticket 
to RPC server
RPC/CLIENT
TGS
Auth 
Data
SCM RPC 
Service
Session
Key
Full Token
Demo Time
Wrap Up Time
CVE-2022-35756
cred->Flags & SECPKG_CRED_ATTR_PAC_BYPASS
(auto) AcquireCredentialsHandle w/
SECPKG_CRED_INBOUND && NT AUTHORITY\SERVICE && 
!KerbGlobalValidateKDCPACSignature
(manual) SetCredentialsAttributes w/SeTcbPrivilege
“SYSTEM” Equivalent
SeTcbPrivilege || SYSTEM || LOCAL/NETWORK SERVICE
context->Flags & ASC_RET_USE_SESSION_KEY
Logon Session:
Credentials Handle:
ASC Context Flags:
Mitigation Thoughts
●
Enable KerbGlobalValidateKDCPACSignature
○
Prevent “NT AUTHORITY\SERVICE” SID from bypassing PAC veriﬁcation
○
Doesn’t prevent “LOCAL/NETWORK SERVICE” or “SYSTEM” though
●
Force Kerberos Armoring / FAST
○
Makes it harder to tamper with network traﬃc
●
Enable Credential Guard
○
Block trivial access to TGT session keys
●
Build Kerberos ﬁrewall rules
○
Block access to KDCs outside an approved list
Special privileges assigned to new logon.
Subject:
Security ID:  REALM\bob
Account Name:  bob
Account Domain:  REALM
Logon ID:  0x4b842
Privileges:
SeSecurityPrivilege
SeTakeOwnershipPrivilege
SeLoadDriverPrivilege
...
Security -> Logon/Logoff -> Special Logon -> Event 4672
Detection Thoughts
Limitations of Time
NtApiDotNet (tooling used in presentation)
https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools
UAC Bypass Trickery
https://www.tiraniddo.dev/2022/03/bypassing-uac-in-most-complex-way.html 
Remote Credential Guard Code Execution
https://bugs.chromium.org/p/project-zero/issues/detail?id=2271
AppContainer Escapes
https://bugs.chromium.org/p/project-zero/issues/detail?id=2273 
LSASS Impersonation Check Failures
https://bugs.chromium.org/p/project-zero/issues/detail?id=2278 
Service Account S4U Elevation
https://cyberstoph.org/posts/2021/06/abusing-kerberos-s4u2self-for-local-privilege-escalation/ 
Acknowledgements
Elad Shamir | @elad_shamir
Benjamin Delpy | @gentilkiwi
Will Schroeder | @harmj0y
Christoph Falta | @cfalta
Charlie Clark | @exploitph
One Last Thing !
Questions ?