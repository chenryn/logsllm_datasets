• The overhead of BINSEC/REL compared to our best
setting for SE (SE+FlyRow), in terms of speed (#I/s),
is only ×1.8. Hence CT comes almost for free on top
of standard SE. This is consistent with the fact
that
our simpliﬁcations discard most insecurity queries, letting
only the exploration queries which are also part of SE.
• FlyRow completely outperforms PostRow. First, PostRow
is not designed for relational veriﬁcation and must reason
about pairs of memory. Second, PostRow simpliﬁca-
tions are not propagated along the execution and must
be recomputed for every query, producing a signiﬁcant
simpliﬁcation-time overhead. On the contrary, FlyRow
models a single memory containing relational values and
propagates along the symbolic execution.
• FlyRow also improves the performance of standard SE
by a factor 450, performing much better than PostRow in
our experiments.
Conclusion (RQ3, RQ4, RQ5). BINSEC/REL performs signif-
icantly better than previous approaches to relational symbolic
execution (×715 speedup vs. RelSE). The very main source
of improvement is the FlyRow on-the-ﬂy simpliﬁcation (×569
speedup vs. RelSE, ×60 less insecurity queries). Note that,
in our context, FlyRow completely outperforms state-of-the-
art binary-level simpliﬁcations, as they are not designed to
efﬁciently cope with relational properties and introduce a sig-
niﬁcant simpliﬁcation-overhead at every query. Fault-packing
and untainting, while effective over RelSE, have a much
slighter impact once FlyRow is activated; fault-packing can
still be useful when report precision is not the main concern.
Finally, in our experiments, FlyRow signiﬁcantly improves the
performance of standard SE (×450 speedup).
VIII. DISCUSSION
Implementation limitations. Our implementation shows three
main limitations commonly found in research prototypes: it
does not support dynamic libraries – executable must be
statically linked or stubs must be provided for external function
calls, it does not implement predeﬁned syscall stubs, and it
does not support ﬂoating point instructions. These problems
are orthogonal to the core contribution of this paper and the
two ﬁrst ones are essentially engineering tasks. Moreover, the
prototype is already efﬁcient on real-world case studies.
Threats to validity in experimental evaluation. We assessed
the effectiveness of our tool on several known secure and
insecure real-world cryptographic binaries, many of them
taken from prior studies. All results have been crosschecked
with the expected output, and manually reviewed in case of
deviation.
Our prototype is implemented as part of BINSEC [55],
whose efﬁciency and robustness have been demonstrated in
prior large scale studies on both adversarial code and managed
code [61], [74]–[76]. The IR lifting part has been positively
evaluated in external studies [53], [77] and the symbolic
engine features aggressive formula optimizations [66]. All our
experiments use the same search heuristics (depth-ﬁrst) and,
for bounded-veriﬁcation, smarter heuristics do not change the
performances. Also, we tried Z3 and conﬁrmed the better
performance of Boolector.
Finally, we compare our tool to our own versions of SC
and RelSE, primarily because none of the existing tools can
be easily adapted for our setting, and also because this allows
comparing very close implementations.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:41:43 UTC from IEEE Xplore.  Restrictions apply. 
1032
IX. RELATED WORK
Related work has already been lengthly discussed along the
paper. We add here only a few additional discussions, as well
as an overview of existing SE-based tools for information ﬂow
(Table VIII) and an overview of (other) existing automatic
analyzers for CT (Table IX), partly taken from [16].
SC
RelSE
Technique
 type-based SC
Target NI
imp-for 
Java 
C
P/BV/BF/C ≈XP max Iu/s
Tool
///
RelSym [49]
10 loc
NA
///
IF-exploit[41]
20 loc
NA
///
Type-SC-SE[42]
20 loc
NA
Casym [17]
LLVM  SC+over-approx ///
200 (C)
NA
IF-low-level [40] binary  SC + invariants ///
250 Is
NA
binary  SC + concretize ///
500k Iu 260
IF-ﬁrmware[43]
binary  concret+tainting ///
31M Iu 2010
CacheD [20]
binary  RelSE + simpl. ///
BINSEC/REL
10M Iu 3861
Table VIII: SE-based tools for Information Flow. NI indi-
cates whether the technique handles general non-interference
(diverging paths) or not (CT-like properties), P: proof, BV:
bounded-veriﬁcation, BF: bug-ﬁnding, C: counterexample. Is:
static instr., Iu: unrolled instr., NA: non-applicable.
Self-compositon and SE has ﬁrst been used by Milushev et
al. [42]. They use type-directed self-composition and dynamic
symbolic execution to ﬁnd bugs of noninterference but they do
not address scalability and their experiments are limited to toy
examples. The main issues here are the quadratic explosion of
the search space (due to the necessity of considering diverging
paths) and the complexity of the underlying formulas. Later
works [40], [41] suffer from the same problems.
Instead of considering the general case of noninterference,
we focus on CT, and we show that it remains tractable for SE
with adequate optimizations.
Relational symbolic execution. Shadow Symbolic Execu-
tion [48], [78] aims at efﬁciently testing evolving softwares
by focusing on the new behaviors introduced by a patch.
The paper introduces the idea of sharing formulas across
two executions in the same SE instance. The term relational
symbolic execution has been coined more recently [49] but
this work is limited to a simple toy imperative language and
do not address scalability.
We maximize sharing between pairs of executions, as Shad-
owSE does, but we also develop speciﬁc optimizations tailored
to the case of binary-level CT. Experiments show that our
optimizations are crucial in this context.
Symbolic execution for CT. Only three previous works in
this category achieve scalability, yet at
the cost of either
precision or soundness. Wang et al. [20] and Subramanyan
et al. [43] sacriﬁce soundness for scalability (no bounded-
veriﬁcation). The former performs symbolic execution on fully
concrete traces and only symbolize the secrets. The latter
concretizes memory accesses. In both cases, they may miss
feasible paths as well as vulnerabilities. Brotzman et al. [17]
take the opposite side and sacriﬁce precision for scalability
(no bug-ﬁnding). Their analysis scales by over-approximating
loops and resetting the symbolic state at chosen code locations.
C
Technique
type-system
over-approx. SE
Target Analysis
binary dynamic
P/BV/BF/C
abstract-interpretation
///
///
logical, product-programs //∗/ 
///
///
///
///
///
///
Tool
ct-ai [15]
static
FlowTracker [81] LLVM static
ct-verif [16]
LLVM static
Casym [17]‡
LLVM static
VirtualCert† [8]
static
x86
ctgrind [18]
CacheAudit [24]‡ binary
CacheD [20]‡
BINSEC/REL
Table IX: Automatic analysis tools for CT-like properties
(see [16]). ∗ ct-verif can be incomplete because of invariant
inference. † As part of CompCert, cannot be used on arbitrary
executables. ‡ Also implements a cache model.
binary dynamic
binary
abstract-interpretation
RelSE + simpl.
type-system
Valgrind
static
SE
DSE
We adopt a different approach and scale by heavy formula
optimizations, allowing us to keep both correct bug-ﬁnding
(BF) and correct bounded-veriﬁcation (BV). Interestingly, our
method is faster than these approximated ones. We propose
the ﬁrst technique for CT-veriﬁcation at binary-level that is
correct for BF and BV and scales on real world cryptographic
examples. Moreover, our technique is compatible with the
previous approximations for extra-scaling.
Other Methods for CT Analysis. Static approaches based
on sound static analysis [8], [14]–[16], [22]–[24], [79]–[81]
give formal guarantees that a program is free from time
side-channels but they cannot ﬁnd bugs when a program is
rejected. Some work also propose program transformations
to make a program secure [17], [79], [80], [82], [83] but
they consider less capable attackers and target higher-level
code. Dynamic approaches for constant-time are precise (they
ﬁnd real violations) but limited to a subset of the execution
traces, hence they are not complete. These techniques include
statistical analysis [84], dynamic binary instrumentation [18],
[21], and dynamic symbolic execution (DSE) [19].
X. CONCLUSION
We tackle the problem of designing an automatic and
efﬁcient binary-level analyzer for constant-time, enabling both
bug-ﬁnding and bounded-veriﬁcation on real-world crypto-
graphic implementations. Our approach is based on relational
symbolic execution together with original dedicated optimiza-
tions reducing the overhead of relational reasoning and allow-
ing for a signiﬁcant speedup. Our prototype, BINSEC/REL,
is shown to be highly efﬁcient compared to alternative ap-
proaches. We used it to perform extensive binary-level CT
analysis for a wide range of cryptographic implementations
and to automate and extend a previous study of CT preserva-
tion by compilers. We found three vulnerabilities that slipped
through previous manual and automated analyses, and we
discovered that gcc -O0 and backend passes of clang
introduce violations of CT out of reach of state-of-the-art CT
veriﬁcation tools at LLVM or source level.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:41:43 UTC from IEEE Xplore.  Restrictions apply. 
1033
REFERENCES
[1] D. Brumley and D. Boneh, “Remote timing attacks are
practical”, Computer Networks, vol. 48, no. 5, 2005.
[2] B. B. Brumley and N. Tuveri, “Remote timing attacks
are still practical”, in ESORICS, 2011.
[3] P. C. Kocher, “Timing attacks on implementations of
in
Difﬁe-Hellman, RSA, DSS, and other systems”,
Annual International Cryptology Conference, 1996.
[4] D. J. Bernstein, “Cache-timing attacks on AES”, 2005.
[5] D. A. Osvik, A. Shamir, and E. Tromer, “Cache attacks
and countermeasures: The case of AES”, in CT-RSA,
2006.
[6] C. Percival, “Cache missing for fun and proﬁt”, 2009.
[7] E. Ronen, K. G. Paterson, and A. Shamir, “Pseudo
constant time implementations of TLS are only pseudo
secure”, in CCS, 2018.
[8] G. Barthe, G. Betarte, J. D. Campo, C. D. Luna, and D.
Pichardie, “System-level non-interference for constant-
time cryptography”, in CCS, 2014.
[9] T. Pornin, BearSSL. [Online]. Available: https://www.
bearssl.org/ (visited on 05/23/2019).
[10] D. J. Bernstein, T. Lange, and P. Schwabe, “The security
in LATIN-
impact of a new cryptographic library”,
CRYPT, 2012.
J. K. Zinzindohoué, K. Bhargavan, J. Protzenko, and B.
Beurdouche, “Hacl*: A veriﬁed modern cryptographic
library”, in CCS, 2017.
[11]
[12] L. Simon, D. Chisnall, and R. J. Anderson, “What you
get is what you C: controlling side effects in mainstream
C compilers”, in EuroS&P, 2018.
[13] T. Kaufmann, H. Pelletier, S. Vaudenay, and K. Ville-
gas, “When constant-time source yields variable-time
binary: Exploiting curve25519-donna built with MSVC
2015”, in CANS, 2016.
J. B. Almeida, M. Barbosa, J. S. Pinto, and B.
Vieira, “Formal veriﬁcation of side-channel counter-
measures using self-composition”, Sci. Comput. Pro-
gram., vol. 78, no. 7, 2013.
[14]
[15] S. Blazy, D. Pichardie, and A. Trieu, “Verifying
constant-time implementations by abstract interpreta-
tion”, in ESORICS, 2017.
J. B. Almeida, M. Barbosa, G. Barthe, F. Dupressoir,
and M. Emmi, “Verifying Constant-Time Implementa-
tions.”, in USENIX, 2016.
[16]
[17] R. Brotzman, S. Liu, D. Zhang, G. Tan, and M. Kan-
demir, “CaSym: Cache aware symbolic execution for
side channel detection and mitigation”, in S&P, 2019.
[18] A. Langley, ImperialViolet - Checking that functions are
constant time with Valgrind, 2010. [Online]. Available:
https://www.imperialviolet.org/2010/04/01/ctgrind.
html.
[19] S. Chattopadhyay, M. Beck, A. Rezine, and A. Zeller,
“Quantifying the information leak in cache attacks via
symbolic execution”, in MEMOCODE, 2017.
[20] S. Wang, P. Wang, X. Liu, D. Zhang, and D. Wu,
“Cached: Identifying cache-based timing channels in
production software”, in USENIX, 2017.
J. Wichelmann, A. Moghimi, T. Eisenbarth, and B.
Sunar, “Microwalk: A framework for ﬁnding side chan-
nels in binaries”, in ACSAC, 2018.
[21]
[22] B. Köpf, L. Mauborgne, and M. Ochoa, “Automatic
Quantiﬁcation of Cache Side-Channels”, in CAV, 2012.
[23] G. Doychev, B. Köpf, L. Mauborgne, and J. Reineke,
“CacheAudit: A Tool for the Static Analysis of Cache
Side Channels”, ACM Transactions on Information and
System Security, vol. 18, no. 1, 2015.
[25]
[24] G. Doychev and B. Köpf, “Rigorous analysis of soft-
ware countermeasures against cache attacks”, in PLDI,
2017.
J. B. Almeida, M. Barbosa, G. Barthe, A. Blot, B. Gré-
goire, V. Laporte, T. Oliveira, H. Pacheco, B. Schmidt,
and P. Strub, “Jasmin: High-assurance and high-speed
cryptography”, in CCS, 2017.
[26] B. Bond, C. Hawblitzel, M. Kapritsos, K. R. M. Leino,
J. R. Lorch, B. Parno, A. Rane, S. T. V. Setty, and
L. Thompson, “Vale: Verifying high-performance cryp-
tographic assembly code”, in USENIX, 2017.
[27] S. Cauligi, G. Soeller, F. Brown, B. Johannesmeyer,
Y. Huang, R. Jhala, and D. Stefan, “Fact: A ﬂexi-
ble, constant-time programming language”, in SecDev,
2017.
[28] Z. Zhou, M. K. Reiter, and Y. Zhang, “A software ap-
proach to defeating side channels in last-level caches”,
in CCS, 2016.
[29] F. Liu, Q. Ge, Y. Yarom, F. McKeen, C. V. Rozas,
G. Heiser, and R. B. Lee, “Catalyst: Defeating last-
level cache side channel attacks in cloud computing”,
in HPCA, 2016.
[30] Q. Ge, Y. Yarom, T. Chothia, and G. Heiser, “Time
protection: The missing OS abstraction”, in EuroSys,
2019.
[31] D. Gruss, J. Lettner, F. Schuster, O. Ohrimenko, I.
Haller, and M. Costa, “Strong and efﬁcient cache side-
channel protection using hardware transactional mem-
ory”, in USENIX, 2017.
[32] M. R. Clarkson and F. B. Schneider, “Hyperproperties”,
Journal of Computer Security, vol. 18, no. 6, 2010.
[33] G. Barthe, P. R. D’Argenio, and T. Rezk, “Secure
information ﬂow by self-composition”, in CSFW, 2004.
[34] T. Terauchi and A. Aiken, “Secure information ﬂow as
a safety problem”, in SAS, 2005.
[35] G. Balakrishnan and T. W. Reps, “WYSINWYX: what
you see is not what you execute”, ACM Trans. Program.
Lang. Syst., vol. 32, no. 6, 2010.
[36] A. Djoudi, S. Bardin, and É. Goubault, “Recovering
high-level conditions from binary programs”, in FM,
2016.
[37] P. Godefroid, M. Y. Levin, and D. Molnar, “SAGE:
Whitebox fuzzing for security testing”, Communica-
tions of the ACM, vol. 55, no. 3, 2012.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:41:43 UTC from IEEE Xplore.  Restrictions apply. 
1034
[38] C. Cadar and K. Sen, “Symbolic execution for software
testing: Three decades later”, Communications of the
ACM, vol. 56, no. 2, 2013.
[39] E. Bounimova, P. Godefroid, and D. A. Molnar, “Bil-
lions and billions of constraints: Whitebox fuzz testing
in production”, in ICSE, 2013.
[40] M. Balliu, M. Dam, and R. Guanciale, “Automating