two values to 1. (You can set them to 0 to gain the opposite effect of preventing those events from 
being generated, even on Server SKUs.) You should get a registry state like the following one:
EXPERIMENT: Enable services logging
The Service Control Manager usually logs ETW events only when it detects abnormal error con-
ditions (for example, while failing to start a service or to change its configuration). This behavior 
can be overridden by manually enabling or disabling a different kind of SCM events. In this ex-
periment, you will enable two kinds of events that are particularly useful for debugging a service 
change of state. Events 7036 and 7042 are raised when a service change status or when a STOP 
control request is sent to a service.
Those two events are enabled by default on server SKUs but not on client editions of 
Windows 10. Using your Windows 10 machine, you should open the Registry Editor (by typing 
regedit.exe in the Cortana search box) and navigate to the following registry key: HKLM\
SYSTEM\CurrentControlSet\Control\ScEvents. If the last subkey does not exist, you should create 
it by right-clicking the Control subkey and selecting the Key item from the New context menu).
Now you should create two DWORD values and name them 7036 and 7042. Set the data of the
two values to 1. (You can set them to 0 to gain the opposite effect of preventing those events from
being generated, even on Server SKUs.) You should get a registry state like the following one:
CHAPTER 10 Management, diagnostics, and tracing
449
Restart your workstation, and then start and stop a service (for example, the AppXSvc service) 
using the sc.exe tool  by opening an administrative command prompt and typing the following 
commands:
sc stop AppXSvc 
sc start AppXSvc
Open the Event Viewer (by typing eventvwr in the Cortana search box) and navigate to 
Windows Logs and then System. You should note different events from the Service Control 
Manager with Event ID 7036 and 7042. In the top ones, you should find the stop event generated 
by the AppXSvc service, as shown in the following figure:
Note that the Service Control Manager by default logs all the events generated by services 
started automatically at system startup. This can generate an undesired number of events flood-
ing the System event log. To mitigate the problem, you can disable SCM autostart events by 
creating a registry value named EnableAutostartEvents in the HKLM\System\CurrentControlSet\
Control key and set it to 0 (the default implicit value is 1 in both client and server SKUs). As a 
result, this will log only events generated by service applications when starting, pausing, or stop-
ping a target service.
Restart your workstation, and then start and stop a service (for example, the AppXSvc service) 
using the sc.exe tool  by opening an administrative command prompt and typing the following 
commands:
sc stop AppXSvc
sc start AppXSvc
Open the Event Viewer (by typing eventvwr in the Cortana search box) and navigate to 
Windows Logs and then System. You should note different events from the Service Control 
Manager with Event ID 7036 and 7042. In the top ones, you should find the stop event generated 
by the AppXSvc service, as shown in the following figure:
Note that the Service Control Manager by default logs all the events generated by services 
started automatically at system startup. This can generate an undesired number of events flood-
ing the System event log. To mitigate the problem, you can disable SCM autostart events by 
creating a registry value named EnableAutostartEvents in the HKLM\System\CurrentControlSet\
Control key and set it to 0 (the default implicit value is 1 in both client and server SKUs). As a 
result, this will log only events generated by service applications when starting, pausing, or stop-
ping a target service.
450 
CHAPTER 10 Management, diagnostics, and tracing
Network drive letters
In addition to its role as an interface to services, the SCM has another totally unrelated responsibil-
ity: It notifies GUI applications in a system whenever the system creates or deletes a network drive-
letter connection. The SCM waits for the Multiple Provider Router (MPR) to signal a named event, 
\BaseNamedObjects\ScNetDrvMsg, which MPR signals whenever an application assigns a drive letter 
to a remote network share or deletes a remote-share drive-letter assignment. When MPR signals the 
event, the SCM calls the GetDriveType Windows function to query the list of connected network drive 
letters. If the list changes across the event signal, the SCM sends a Windows broadcast message of type 
WM_DEVICECHANGE. The SCM uses either DBT_DEVICEREMOVECOMPLETE or DBT_DEVICEARRIVAL 
as the message’s subtype. This message is primarily intended for Windows Explorer so that it can up-
date any open computer windows to show the presence or absence of a network drive letter.
Service control programs
As introduced in the “Service applications” section, service control programs (SCPs) are stan-
dard Windows applications that use SCM service management functions, including CreateService, 
OpenService, StartService, ControlService, QueryServiceStatus, and DeleteService. To use the SCM func-
tions, an SCP must first open a communications channel to the SCM by calling the OpenSCManager 
function to specify what types of actions it wants to perform. For example, if an SCP simply wants 
to enumerate and display the services present in the SCM’s database, it requests enumerate-service 
access in its call to OpenSCManager. During its initialization, the SCM creates an internal object that 
represents the SCM database and uses the Windows security functions to protect the object with a 
security descriptor that specifies what accounts can open the object with what access permissions. For 
example, the security descriptor indicates that the Authenticated Users group can open the SCM object 
with enumerate-service access. However, only administrators can open the object with the access 
required to create or delete a service.
As it does for the SCM database, the SCM implements security for services themselves. When an 
SCP creates a service by using the CreateService function, it specifies a security descriptor that the 
SCM associates internally with the service’s entry in the service database. The SCM stores the security 
descriptor in the service’s registry key as the Security value, and it reads that value when it scans the 
registry’s Services key during initialization so that the security settings persist across reboots. In the 
same way that an SCP must specify what types of access it wants to the SCM database in its call to 
OpenSCManager, an SCP must tell the SCM what access it wants to a service in a call to OpenService. 
Accesses that an SCP can request include the ability to query a service’s status and to configure, stop, 
and start a service.
The SCP you’re probably most familiar with is the Services MMC snap-in that’s included in Windows, 
which resides in %SystemRoot%\System32\Filemgmt.dll. Windows also includes Sc.exe (Service 
Controller tool), a command-line service control program that we’ve mentioned multiple times.
SCPs sometimes layer service policy on top of what the SCM implements. A good example is the 
timeout that the Services MMC snap-in implements when a service is started manually. The snap-in 
presents a progress bar that represents the progress of a service’s startup. Services indirectly inter-
act with SCPs by setting their configuration status to reflect their progress as they respond to SCM 
CHAPTER 10 Management, diagnostics, and tracing
451
commands such as the start command. SCPs query the status with the QueryServiceStatus function. 
They can tell when a service actively updates the status versus when a service appears to be hung, and 
the SCM can take appropriate actions in notifying a user about what the service is doing.
Autostart services startup
SvcCtrlMain invokes the SCM function ScAutoStartServices to start all services that have a Start value 
designating autostart (except delayed autostart and user services). ScAutoStartServices also starts auto-
start drivers. To avoid confusion, you should assume that the term services means services and drivers 
unless indicated otherwise. ScAutoStartServices begins by starting two important and basic services, 
named Plug and Play (implemented in the Umpnpmgr.dll library) and Power (implemented in the 
Umpo.dll library), which are needed by the system for managing plug-and-play hardware and power 
interfaces. The SCM then registers its Autostart WNF state, used to indicate the current autostart phase 
to the Power and other services. 
Before the starting of other services can begin, the ScAutoStartService routine calls ScGetBootAnd 
SystemDriverState to scan the service database looking for boot-start and system-start device driver 
entries. ScGetBootAndSystemDriverState determines whether a driver with the start type set to Boot 
Start or System Start successfully started by looking up its name in the object manager namespace 
directory named \Driver. When a device driver successfully loads, the I/O manager inserts the driver’s 
object in the namespace under this directory, so if its name isn’t present, it hasn’t loaded. Figure 10-15 
shows WinObj displaying the contents of the Driver directory. ScGetBootAndSystemDriverState 
notes the names of drivers that haven’t started and that are part of the current profile in a list named 
ScStoppedDrivers. The list will be used later at the end of the SCM initialization for logging an event to 
the system event log (ID 7036), which contains the list of boot drivers that have failed to start.
FIGURE 10-15 List of driver objects.
452 
CHAPTER 10 Management, diagnostics, and tracing
The algorithm in ScAutoStartServices for starting services in the correct order proceeds in phases, 
whereby a phase corresponds to a group and phases proceed in the sequence defined by the group 
ordering stored in the HKLM\SYSTEM\CurrentControlSet\Control\ServiceGroupOrder\List registry 
value. The List value, shown in Figure 10-16, includes the names of groups in the order that the SCM 
should start them. Thus, assigning a service to a group has no effect other than to fine-tune its startup 
with respect to other services belonging to different groups.
FIGURE 10-16 ServiceGroupOrder registry key.
When a phase starts, ScAutoStartServices marks all the service entries belonging to the phase’s 
group for startup. Then ScAutoStartServices loops through the marked services to see whether it can 
start each one. Part of this check includes seeing whether the service is marked as delayed autostart or 
a user template service; in both cases, the SCM will start it at a later stage. (Delayed autostart services 
must also be ungrouped. User services are discussed later in the “User services” section.) Another part 
of the check it makes consists of determining whether the service has a dependency on another group, 
as specified by the existence of the DependOnGroup value in the service’s registry key. If a dependency 
exists, the group on which the service is dependent must have already initialized, and at least one 
service of that group must have successfully started. If the service depends on a group that starts later 
than the service’s group in the group startup sequence, the SCM notes a “circular dependency” error 
for the service. If ScAutoStartServices is considering a Windows service or an autostart device driver, 
it next checks to see whether the service depends on one or more other services; if it is dependent, it 
determines whether those services have already started. Service dependencies are indicated with the 
DependOnService registry value in a service’s registry key. If a service depends on other services that 
belong to groups that come later in the ServiceGroupOrder\List, the SCM also generates a “circular 
dependency” error and doesn’t start the service. If the service depends on any services from the same 
group that haven’t yet started, the service is skipped.
CHAPTER 10 Management, diagnostics, and tracing
453
When the dependencies of a service have been satisfied, ScAutoStartServices makes a final check 
to see whether the service is part of the current boot configuration before starting the service. When 
the system is booted in safe mode, the SCM ensures that the service is either identified by name or by 
group in the appropriate safe boot registry key. There are two safe boot keys, Minimal and Network, 
under HKLM\SYSTEM\CurrentControlSet\Control\SafeBoot, and the one that the SCM checks depends 
on what safe mode the user booted. If the user chose Safe Mode or Safe Mode With Command Prompt 
at the modern or legacy boot menu, the SCM references the Minimal key; if the user chose Safe Mode 
With Networking, the SCM refers to Network. The existence of a string value named Option under the 
SafeBoot key indicates not only that the system booted in safe mode but also the type of safe mode the 
user selected. For more information about safe boots, see the section “Safe mode” in Chapter 12.
Service start
Once the SCM decides to start a service, it calls StartInternal, which takes different steps for services 
than for device drivers. When StartInternal starts a Windows service, it first determines the name of 
the file that runs the service’s process by reading the ImagePath value from the service’s registry key. 
If the service file corresponds to LSASS.exe, the SCM initializes a control pipe, connects to the already-
running LSASS process, and waits for the LSASS process response. When the pipe is ready, the LSASS 
process connects to the SCM by calling the classical StartServiceCtrlDispatcher routine. As shown in 
Figure 10-17, some services like Credential Manager or Encrypting File System need to cooperate with 
the Local Security Authority Subsystem Service (LSASS)—usually for performing cryptography opera-
tion for the local system policies (like passwords, privileges, and security auditing. See Chapter 7 of Part 
1 for more details).
FIGURE 10-17 Services hosted by the Local Security Authority Subsystem Service (LSASS) process.
454 
CHAPTER 10 Management, diagnostics, and tracing
The SCM then determines whether the service is critical (by analyzing the FailureAction registry value) 
or is running under WoW64. (If the service is a 32-bit service, the SCM should apply file system redirec-
tion. See the “WoW64” section of Chapter 8 for more details.) It also examines the service’s Type value. If 
the following conditions apply, the SCM initiates a search in the internal Image Record Database:
I 
The service type value includes SERVICE_WINDOWS_SHARE_PROCESS (0x20).
I 
The service has not been restarted after an error.
I 
Svchost service splitting is not allowed for the service (see the “Svchost service splitting” section
later in this chapter for further details).
An Image record is a data structure that represents a launched process hosting at least one service. 
If the preceding conditions apply, the SCM searches an image record that has the same process execut-
able’s name as the new service ImagePath value. 
If the SCM locates an existing image database entry with matching ImagePath data, the service can 
be shared, and one of the hosting processes is already running. The SCM ensures that the found host-
ing process is logged on using the same account as the one specified for the service being started. (This 
is to ensure that the service is not configured with the wrong account, such as a LocalService account, 
but with an image path pointing to a running Svchost, such as netsvcs, which runs as LocalSystem.) A 
service’s ObjectName registry value stores the user account in which the service should run. A service 
with no ObjectName or an ObjectName of LocalSystem runs in the local system account. A process can 
be logged on as only one account, so the SCM reports an error when a service specifies a different ac-
count name than another service that has already started in the same process. 
If the image record exists, before the new service can be run, another final check should be per-
formed: The SCM opens the token of the currently executing host process and checks whether the nec-
essary service SID is located in the token (and all the required privileges are enabled). Even in this case, 
the SCM reports an error if the condition is not verified. Note that, as we describe in the next section 
(“Service logon”), for shared services, all the SIDs of the hosted services are added at token creation 
time. It is not possible for any user-mode component to add group SIDs in a token after the token has 
already been created.
If the image database doesn’t have an entry for the new service ImagePath value, the SCM creates 
one. When the SCM creates a new entry, it stores the logon account name used for the service and 
the data from the service’s ImagePath value. The SCM requires services to have an ImagePath value. 
If a service doesn’t have an ImagePath value, the SCM reports an error stating that it couldn’t find the 
service’s path and isn’t able to start the service. After the SCM creates an image record, it logs on the 
service account and starts the new hosting process. (The procedure is described in the next section, 
“Service logon.”)
After the service has been logged in, and the host process correctly started, the SCM waits for the 
initial “connection” message from the service. The service connects to SCM thanks to the SCM RPC pipe 
(\Pipe\Ntsvcs, as described in the “The Service Control Manager” section) and to a Channel Context 
data structure built by the LogonAndStartImage routine. When the SCM receives the first message, it 
proceeds to start the service by posting a SERVICE_CONTROL_START control message to the service 
process. Note that in the described communication protocol is always the service that connects to SCM. 
CHAPTER 10 Management, diagnostics, and tracing
455
The service application is able to process the message thanks to the message loop located in the 
StartServiceCtrlDispatcher API (see the “Service applications” section earlier in this chapter for more de-
tails). The service application enables the service group SID in its token (if needed) and creates the new 
service thread (which will execute the Service Main function). It then calls back into the SCM for creat-
ing a handle to the new service, storing it in an internal data structure (INTERNAL_DISPATCH_TABLE) 
similar to the service table specified as input to the StartServiceCtrlDispatcher API. The data structure is 
used for tracking the active services in the hosting process. If the service fails to respond positively to 
the start command within the timeout period, the SCM gives up and notes an error in the system Event 
Log that indicates the service failed to start in a timely manner.
If the service the SCM starts with a call to StartInternal has a Type registry value of SERVICE_KERNEL_
DRIVER or SERVICE_FILE_SYSTEM_DRIVER, the service is really a device driver, so StartInternal enables 
the load driver security privilege for the SCM process and then invokes the kernel service NtLoadDriver, 
passing in the data in the ImagePath value of the driver’s registry key. Unlike services, drivers don’t 
need to specify an ImagePath value, and if the value is absent, the SCM builds an image path by ap-
pending the driver’s name to the string %SystemRoot%\System32\ Drivers\.
Note A device driver with the start value of SERVICE_AUTO_START or SERVICE_DEMAND_
START is started by the SCM as a runtime driver, which implies that the resulting loaded 
image uses shared pages and has a control area that describes them. This is different than 
drivers with the start value of SERVICE_BOOT_START or SERVICE_SYSTEM_START, which are 
loaded by the Windows Loader and started by the I/O manager. Those drivers all use private 
pages and are neither sharable nor have an associated Control Area.
More details are available in Chapter 5 in Part 1.
ScAutoStartServices continues looping through the services belonging to a group until all the 
services have either started or generated dependency errors. This looping is the SCM’s way of auto-
matically ordering services within a group according to their DependOnService dependencies. The SCM 
starts the services that other services depend on in earlier loops, skipping the dependent services until 
subsequent loops. Note that the SCM ignores Tag values for Windows services, which you might come 
across in subkeys under the HKLM\SYSTEM\CurrentControlSet\Services key; the I/O manager honors 
Tag values to order device driver startup within a group for boot-start and system-start drivers. Once 
the SCM completes phases for all the groups listed in the ServiceGroupOrder\List value, it performs 
a phase for services belonging to groups not listed in the value and then executes a final phase for 
services without a group.
After handling autostart services, the SCM calls ScInitDelayStart, which queues a delayed work item 
associated with a worker thread responsible for processing all the services that ScAutoStartServices 
skipped because they were marked delayed autostart (through the DelayedAutostart registry value). 
This worker thread will execute after the delay. The default delay is 120 seconds, but it can be overrid-
den by the creating an AutoStartDelay value in HKLM\SYSTEM\CurrentControlSet\Control. The SCM 
performs the same actions as those executed during startup of nondelayed autostart services.
456 
CHAPTER 10 Management, diagnostics, and tracing
When the SCM finishes starting all autostart services and drivers, as well as setting up the delayed 
autostart work item, the SCM signals the event \BaseNamedObjects\SC_AutoStartComplete. This event 
is used by the Windows Setup program to gauge startup progress during installation.
Service logon 
During the start procedure, if the SCM does not find any existing image record, it means that the host 
process needs to be created. Indeed, the new service is not shareable, it’s the first one to be executed, 
it has been restarted, or it’s a user service. Before starting the process, the SCM should create an access 
token for the service host process. The LogonAndStartImage function’s goal is to create the token and 
start the service’s host process. The procedure depends on the type of service that will be started.
User services (more precisely user service instances) are started by retrieving the current 
logged-on user token (through functions implemented in the UserMgr.dll library). In this case, the 
LogonAndStartImage function duplicates the user token and adds the “WIN://ScmUserService” security 
attribute (the attribute value is usually set to 0). This security attribute is used primarily by the Service 
Control Manager when receiving connection requests from the service. Although SCM can recognize 
a process that’s hosting a classical service through the service SID (or the System account SID if the 
service is running under the Local System Account), it uses the SCM security attribute for identifying a 
process that’s hosting a user service.
For all other type of services, the SCM reads the account under which the service will be started 
from the registry (from the ObjectName value) and calls ScCreateServiceSids with the goal to create a 
service SID for each service that will be hosted by the new process. (The SCM cycles between each ser-
vice in its internal service database.) Note that if the service runs under the LocalSystem account (with 
no restricted nor unrestricted SID), this step is not executed. 
The SCM logs on services that don’t run in the System account by calling the LSASS function 
LogonUserExEx. LogonUserExEx normally requires a password, but normally the SCM indicates to LSASS 
that the password is stored as a service’s LSASS “secret” under the key HKLM\SECURITY\Policy\Secrets 
in the registry. (Keep in mind that the contents of SECURITY aren’t typically visible because its default 
security settings permit access only from the System account.) When the SCM calls LogonUserExEx, it 
specifies a service logon as the logon type, so LSASS looks up the password in the Secrets subkey that 
has a name in the form _SC_. 
Note Services running with a virtual service account do not need a password for having 
their service token created by the LSA service. For those services, the SCM does not provide 
any password to the LogonUserExEx API.
The SCM directs LSASS to store a logon password as a secret using the LsaStorePrivateData function 
when an SCP configures a service’s logon information. When a logon is successful, LogonUserEx returns 
a handle to an access token to the caller. The SCM adds the necessary service SIDs to the returned 
token, and, if the new service uses restricted SIDs, invokes the ScMakeServiceTokenWriteRestricted 
CHAPTER 10 Management, diagnostics, and tracing
457
function, which transforms the token in a write-restricted token (adding the proper restricted SIDs). 
Windows uses access tokens to represent a user’s security context, and the SCM later associates the 
access token with the process that implements the service.
Next, the SCM creates the user environment block and security descriptor to associate with the 